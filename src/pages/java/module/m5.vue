<!--
 * @Date           : 2020-08-31 16:40:04
 * @FilePath       : /jinnian-space/src/pages/java/module/m5.vue
 * @Description    : 
-->
<template>
    <div>
       <div>  </div>
       <pre>
            collection  map   list  arraylist  linkedlist set hashset treeset   HashMap   TreeMap
            数组长度固定， 集合 会自动扩缩容 每次 1.5倍数，长度小于10  是 10
            栈  压栈 弹栈
            队列  入队列             出队列    前端  后端   
            数组   查询快 增删慢   因为 增删 需要 把后面的 每个都平移一位 
            链表    增删快 查询慢  必须 从  头开始查  单向链表
            链表   结点   头结点（地址）数据地址数据地址。。。。。^ 结束  火车一样，每一个结点 都由 数据 和地址组成  
                    链表有头有尾  尾巴 是 一个空地址   ，前一个结点 记录后一个结点的地址值
            双向链表      前一个结点的地址+值+下一个结点的地址   
            linkedlist 链表  增删方法比较特殊 ， 有一些特殊方法 

            泛型  
            不写 默认 Object,,提供 编译时候 安全检测机制   
            
            collection  单列集合   list set 
            set 没有索引 只能用迭代器  iterator 进行迭代    或者 增强 for 进行魂环 
            hashset  treeset
            treeset 可以对 内部元素 进行 排序 要想使用 treeset 必须 指定 排序规则   自然排序
              内部的 元素 必须 实现 comparable 接口  并且重写 compareTo 方法 
              compareTo  返回 0 则 不存储 ， 大于存右边 ，小于存左边
              字符串也有 compareTo 方法 
              comparator  比较器 类 实现 compare 方法  抽象类
            

            数据结构 树   结点
              二叉树    结点  父节点+当前节点值+左子节点+右子节点 
              二叉树的查询都是从根节点进行查询
              度： 每一个节点的子节点的 数量
              高度， 二叉树的 根节点 到最 末梢结点的 最长层级 ，也就是 分叉 分了 几次+1

              普通二叉树     二叉查找树，二叉搜索树
              普通二叉树     左右子节点 大小没关系
              二叉查找树     左子节点小于右边子节点  ，一样的 不存储  ，
              二叉查找树     每一次存储一个值 都要从根节点 开始找路径 进行比较，找到自己的位置 ，
                             可能出现 左右子树高度差的很远
              平衡二叉树     任意左右节点 的 两个子树都是一棵平衡二叉树 ，左右高度相差不超过1
                             左右 旋转 ， 变化根节点，根节点 会变化，普通二叉树 不会变根节点
                             左旋 ，原本根节点的右节点 升为根节点 
                                    新的根节点的 原本的左节点 倒向左侧， 链接旧的的根节点作为右侧，做为右弦
                             右旋 ：和上面的左旋 处处相反
                             左左插入--右旋 ， 
                             左右插入--失衡区域左旋，然后整体右旋 ，两次旋转
                             右右插入--左旋
                             右左插入--失衡区域右旋，然后整体左旋
              红黑树         一种自平衡的二叉查找树 ，但不是高度平衡，不是每次都去计算是否平衡，有自己的红黑规则
                             每一个节点 都是 红色 或者黑色
                             根节点必须黑色
                             如果一个节点没有子节点或者父节点，则这个节点相应的值为Nil，被称为叶节点，都是黑色的
                             如果一个节点是红色的，那么它的子节点必须是黑色的，不能出现两个红色的节点相连
                             每一个节点，从该节点到它所有的后代叶节点的简单路径上，都包含相同数目的黑色节点
                             红黑树多了一个颜色属性
                             添加三个默认黑色 调整两次
                             添加三个默认红色 调整1次数
                             红黑树为了提升性能，默认添加数据颜色为红色
                             红黑树  ---旋转 区域小，只旋转了父节点 祖父节点， 把父节点提升祖父节点下降作为父节点的右子节点 ，或者左子节点
                             红黑树 添加数据 需要变色 ，只有在父节点红色，叔叔节点黑色，才会旋转
            
            hashset  
              
                  a.hashCode() 计算 哈希值， 同一个对象的 哈希值 一样的
                  0.75 扩展因子， 满容量的 0.75  则扩容 2倍数
                  集合 ，每个位置 一个哈希 ，如果 相同哈希，则存在同一个位置， 同一个位置总数小于8 采用 链表 ，大于等于8 采用 红黑树
               hashset  必须重写 hashcode 和 equals 方法   
                
            MAP
            Interface Map K,V     
            键值对 ，entry 对象
            hashmap  底层 还是 数组 和 红黑树 ，也有 扩展因子  和 hashset 很类似 
            terrmap  底层 是根据key 排序的 treeset 类似的 原理 

            可变参数  （int ...a）  类似 js 的 数组解构， 底层是一个数组，是一种  简便写法
            
            stream  流
            流 操作 可以 过滤 和js 的  过滤一样  相当于读数据中 每个去过滤 执行
            流水线 ，每次操作一波，  流水线 ，准备物料 --> 各种一次次操作加工 -->出货  . 获取流--> 中间方法--> 终结方法
            list1.stream().filter(()->{ }).filter(()->{ }).filter(()->{ }).filter(()->{ }).filter(()->{ }).forEach(()->{})
            list1.stream().filter(()->{ }).filter(()->{ }).filter(()->{ }).filter(()->{ }).filter(()->{ }).xollect(Collectors.toList())
            stream.of()
            limit()  skip() 
            
            
            
            
                       
       </pre>
    </div>
</template>

<script>
    export default {
        
    }
</script>

<style lang="scss" scoped>

</style>