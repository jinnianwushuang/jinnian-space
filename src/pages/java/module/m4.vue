<!--
 * @Date           : 2020-08-31 16:40:04
 * @FilePath       : /jinnian-space/src/pages/java/module/m4.vue
 * @Description    : 
-->
<template> 
    <div>
       <div> 高级面向对象 </div>
       <pre>
            业务对象类  本身  
            DAO  访问存储数据的数组 或者集合  data access object
            Service  用来 处理业务逻辑 ，服务器内部的 逻辑
            Controller  用来 处理     用户  和网页 的相关 逻辑  
            业务逻辑流程：
            controller 的 addItem 调用 service  的 addItem , service  的 addItem 调用 dao 的 addItem
           与试图打交道的 类 调用 与数据库打交道的类 ，与数据库打交道的类 调用 数据库类

            private  static  ， static 修饰的  静态成员属性 在内存中 所有这个类的实例中共享
             一般 存在于方法区中 
       </pre>
       <div>继承</div>
       <pre>
           继承： 让类鱼类之间产生 父子类关系 ， 子类可以直接使用 父类的非私有的成员  
                  例如 你可以用你爸爸的车 ，但你不能用他的内裤 
                  父类 ： 基类 超类   子类 ： 派生类 
                  public class ZI extends FU { }
            继承好处：复用性，维护性，让类之间产生关系是多态的前台
            继承弊端：继承是侵入性的 ，不灵活 ，子类   必须拥有父类的非私有属性和方法
                      耦合性强   父类中 非私有的东西 不能随便改 随便删除 
            JAVA 只支持 单继承 ，不支持 多继承 ，但是 支持多层继承  
             一个儿子不能 有两个亲爹 ，但是可以 有 爷爷 ， 有十八辈祖宗    
             this  自己的 当前类的  super  父级的   父类的 
             this() 访问本类的构造方法  super()访问父类的构造方法
            子父类同名属性或者方法：    可以通过 this.  读取 自己的 属性方法   ，super. 读取 父级的 属性方法
            
            方法 重写  ， 注解  @Override 检查 是否 正确重写 （必须一模一样）
            <div class="text-red">
                <div>父类的静态方法，个非静态方法 ， 子类必须一摸一样的名字才能重写 </div>
                
                <div>静态方法不能重写，父子类静态方法同名 ，只是子类将父类中的同名方法隐藏起来了。  就近原则</div>
            </div>
            子类 重写 父类 方法 ， 权限必须大于等于 父类 权限 
            java  四个 权限修饰符   private  小于 默认 小于 protected  小于 public 
            private  同一个类中
            默认     同一个包中 子类 无关类
            protected 不同包的子类
            public   不同包的 无关类

            子类的  构造方法 会默认调用 super() ；即便是不写 ，也会默认加上。不然子类没办法拿到继承而来的东西

            其实每一个类  都继承与 Objiect  类 如果没 指定继承则该类的构造方法 默认 继承自 Object 默认调用 super()

            抽象类   abstract
            抽象方法： 将共性的方法 抽取到父类之中后，发现该方法的实现逻辑无法确定，该方法就要可以定义为抽象方法
            抽象类： 如果一个类中 存在 抽象方法 ，那么这个类 就必须 声明为 抽象类
            public  abstract void aa();  
            public  abstract class  A1{}
            public  class A99  extends A1{}
            抽象类 只能被 继承 实现 。 不能创建 实例对象。因为 没有方法体的方法 不能调用。
            抽象类的 子类 必须 重写 父类的  抽象方法 ， 但是 子类也可以把自己变成 抽象类。
            抽象类 不一定有抽象方法， 有抽象方法的类 必定是抽象方法 

            抽象类  体现的是 一种  模板设计模式  
            final 关键字 可以修饰 属性 方法 类名   ，final 修饰的 属性方法 将不能重写 ，类不能  继承 ，一般用于  属性 和方法  禁止重写 
            局部代码块 在 方法中定义，限定变量的 生命周期，快速释放，提高内存利用率
             { }  构造代码块 在 类的 构造方法执行之前执行 ，  可以放  构造方法的 公用代码 
             static {}  静态代码块 随着 类的加载而加载，只执行一次， 一般用于数据初始化 ，只在类文件加载的时候执行。和构造方法调用无关
                    
       </pre>
       <div>接口</div>
       <pre>
           抽象类 可以制定 模板 ，制定一定规则 去让子类去实现
           但是如果某个抽象类的所有方法都是抽象方法的时候，我们就可以将其定义为接口
           接口也是一种引用数据类型， 比抽象类 更加抽象 
           接口的存在有两个重要意义： 1. 规则的定义  2. 程序的扩展性
           public interface AA {}
           接口本身 和 抽象方法一样不能实例化 
           public class AA_ZI implements AA{} 
           类不能多继承 ，但是 类 可以实现 多个接口 
           接口 因为是定义规则  ， 接口中的 属性 变量  默认是 final 修饰的 不能被修改 静态的 
           全部的修饰符 是  public static final 
           接口没有构造方法 
           接口中可以 使用 default 定义修饰 默认方法 ，默认方法 只要是用于 接口的迭代升级
           类 实现多个接口 ，如果多个接口中有重名的 默认方法 ，  子类 必须重写 这个 方法 
           接口中可以 使用 static 定义修饰 静态 方法  通过 接口名.静态方法名 来调用  
           接口中 可以有  静态 方法  默认方法 私有方法  抽象方法   

            继承亲爹 实现干爹  

            类和类之间       继承关系   只能 单继承  但是可以 多层继承    你-- 你爹  -你爷爷  - 你十八辈子祖宗
            类和接口之间     实现关系   可以单实现也可以多实现 ，还可以在继承一个类的时候 同时实现多个接口
            接口和接口之间   继承关系   可以单继承也可以多继承            

           
       </pre>
       <div> 多态</div>
       <pre>
           通用对象类型  ，例如 全球 70 亿人 实例 都是 人类 
           多态的前提是  要有 继承 或者实现关系  ，要有方法重写 ，要有父类引用 指向子类对象

           Animal a = new Cat();
           多态中的 成员访问 特点
           构造方法：  同继承一样 ，子类会通过  super 访问 父类 构造器
           成员变量： 编译看左边 父类  ， 执行 看左边父类
           成员方法：  编译看左边父类，   执行 看 右边子类
            多态 弊端：  不能调用子类特有 方法 属性
           多态中的 转型
           向上转型  父类引用  指向子类对象     把一个 子类类型  转换为 一个 父类类型   小的转大的  不用强制转换
           向下转型  子类引用  指向父类对象     把一个 父类类型  转换为 一个 子类类型    大的转小的  需要强制类型转换
           instanceof  
           
       </pre>
       <div> 内部类</div>
       <pre>
           Outer.Inner i = new Outer().new Inner();
           匿名内部类
           函数式编程思想
           lambda   箭头 函数   是将 匿名 内部类 的  一个  优化 
           doaaaa( AA a){ a.nn(); }
            doaaaa(new AA(){
                public void nn(){
                    sout("Niubi ")
                }
            })
           doaaaa(()->{  sout("Niubi ") })
           匿名内部类 ，必须 实现一个接口 ，生产 一个实现类的对象 ，重写方法 ，读取重写的方法 ，执行方法  
           这个方法 根本的阐述    传递的是一个函数 ， 箭头函数方式 我们直接传入 的 是 方法的 实体 ，
           把原本的关注点 转到方法的具体实现
           lambda 使用前提：  必须有一个接口  接口中 有且仅有一个 抽象方法 
           这种 根本上 传入的  还是一个 匿名对象，实例的 匿名实现类的 一个具体的 对象
       </pre>
    </div>
</template>

<script>
    export default {
        
    }
</script>

<style lang="scss" scoped>

</style>