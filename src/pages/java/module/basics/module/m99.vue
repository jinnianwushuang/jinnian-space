<!--
 * @Date           : 2020-08-31 16:40:04
 * @FilePath       : /jinnian-space/src/pages/java/module/m2.vue
 * @Description    : 
-->
<template>
    <div>
        <div class="text-h5">JAVA 基础</div>
          <div class="text-h6"> 基本环境 </div>
       <pre>
        java SE ME  EE 
        跨平台  -- jvm 虚拟机  jvm 虚拟机本身 不能跨平台 java 程序在 不同平台的不同的 jvm 虚拟机  运行
        JRE JDK JVM 作用 
        开发java : 编写代码 编译代码  运行代码 
        JRE : JAVA  Runtime Enviroment   包含 JVM 虚拟机 和 JAVA 核心 类库  
        类= java 文件 ，每个 java 文件是一个 Java 类 
        核心类库：  java 已写好的 非常核心的 代码仓库  ，很多个java  核心 类 文件 
        代码中 会用到 java 存放在 JRE 中 写好的 核心 java 文件 比如： System   String Number 
        java 文件的 编译 是使用 java JDK 中的  编译工具 进行编译 ，编译为 jvm 能够识别运行的 程序文件 
        JDK : JAVA development Kit  Java 语言的 软件开发工具包 ，内部包含了 代码的 编译工具和 运行工具 
        流程：1.使用JDK中的编译工具编译 .java  文件到      .class 字节码文件，
              2.使用JDK中的运行工具 将  .class 文件运行在  JVM 虚拟机当中  
        总结：1. 编写代码 需要使用 JRE 中 java 已经写好的 代码 （核心类库）
              2. 编译代码 需要使用 JDK 中 的 编译工具
              3. 运行代码 需要使用 JDK 中 的  运行工具
              4. 代码运行在  JVM 虚拟机当中  
         JDK=( JRE=(JVM 虚拟机 + 核心类库)  + 开发工具=（编译工具 + 运行工具） )    
         系统环境变量 添加变量 Java_Home  D:\Program Files\Java\jdk1.8.0_91
                       path 编辑 新建    %Java_Home%\bin    %Java_Home%\jre\bin           
        javac  AAA.java  执行生成 AAA.class 文件 
        java  AAA    执行 AAA.class 文件 
        main 方法 程序的 入口点
        public static void main(String[] args ){
        }
        public 确保 文件名称和 类名 必须 同名         
        java 关键字  基本  都是小写的
       </pre>
       <div class="text-h6"> 数据类型 </div>
       <pre>
           java 有字符串 和 字符 区别  字符串 双引号 任意个字符    字符 单引号 且只能1个字符 
          不同数据类型  占用内存空间
          byte 1 short 2 int 4 long 8     float 4 double 8  char 2 boolean 1 
          引用数据类型： class interface  array
          基本数据类型  整数 浮点数 字符  布尔 
          int a = 1;
          float b = 1.36F; float 类型 不加 F 标识， 则默认 double 类型转换 会报错 丢失精度
          long c = 556188L; long 类型  后面加 L 标识
        数据范围关系 从小到大
        byte, (short=char) , int ,long ,float ,double 
        隐式转换 小的直接变大的
        运算过程中，小的会先提升为大的，当类型统一之后，再进行运算 。 同类型 运算
        byte short char 三种数据类型在运算的时候，不管是否有更高的数据类型，都会提升为 int 然后再运算
        也就是 最低隐士转换为 int 类型 ， 结果 最低是 int 类型
        强制转换  大的转小的 强转格式 ： int a=10; byte b= (byte)a;   强转可能丢失精度
        byte d =3+4 ; java 中存在常量优化机制：
         根据常量计算的结果 判定是否在类型范围内，在就编译通过，不在就报错
            java 变量作用域： 只在 变量所在的大括号内有用 
         java 整数相除 结果是整数  10/3 = 3    10/3.0 = 3.333333...
         	 char b = 'a';	 int c= b +20;  结果  c = 117 ; 字节 a 对应的 ASCII 码表 97 
              1+99+“年” = "100年"
               &  并且 |  或者 ！ 非 ^ 异或      && || 短路 效果
               &  |无论如何 左右都会执行 && || 有短路效果 左边值能确定结果 则 右边不执行
        break continue 只能跳出自己所在的那一层关系。
        如果想要跳出跳过置顶一层，可以加入标号。
        IDEA 目录层级关系： project - module - package - class 
        快捷键：
        ctrl+shirt+a    ctrl+alt+v   ctrl+alt+m 包裹方法
        psvm ，sout , alt+1，alt+4 ,ctrl+alt+l ,alt+enter   ,ctrl+b 跟进源码
        数组 int[] arr= new int[30]  初始化定义一个长度是30的数组
             int arr[] =new int[30]
        sout 输出 数组 变量 输出的是 数组的 内存地址 
        java 内存分配： 
        栈内存 ： 方法运行时，进入的内存，局部变量都存放于这块内存中，
        堆内存 ： new 出来的内容都会进入堆内存，并且会有对应的地址值
        方法区 ： 字节码文件 .class 加载时进入的内存 
        本地方法栈 ：调用操作系统相关的资源
        寄存器： 交给CPU 去使用
        类的加载过程：
        1.类的字节码文件加载进方法区 main 方法存放在自己吗文件中
        2.main方法被jvm 自动调用进入栈内存中执行
        3. 因为main 方法在 栈内存 ，创建变量 也在 栈内存
        4.new 方法创建的实例放在堆内存中 ， 有 内存地址，并且有默认初始化值。
          把地址值给到 变量。（因此打印数组，打印出来的是内存地址）
        java 数组默认值
        整数型 0  浮点数 0.0 布尔 false 字符  空字符  引用数据类型 null  
        int[] arr=new int[]{5,7,8,999};    
        int[] arr={5,7,8,999};     arr[0]   
        方法定义：
        格式：
         public static void aaa(int num){  //方法体 }
         public static int aaa(int num){   return 100; //方法体 }  int bb = aaa(30);
         public static int[] aaa(int[] arr){   int[] b={1,2,3}    return b //方法体 }  int[] cc = aaa(arr) 
        方法和方法之间 是平级 关系 ，不能嵌套定义
        栈内存： 手枪弹夹  先进后出
        方法参数类型 和个数 必须匹配 
        方法的形参，相当于一个局部变量
        方法重载： java 允许 多个个相同方法名，但是形参不同的方法存在。（个数，类型，顺序）
                   Java jvm 会通过 参数去匹配调用哪个方法  
        方法参数传递：
                基本数据类型 ，传递的是值本身，改变传入值，是改变的这个值 ，对其他无影响。不影响原始值
                引用数据类型 ，传递的是 内存地址 。 改变的是堆内存内的数据。会改变传入的数据本身
         原码 反码 补码
         计算机中的数据都是以二进制补码的形式在运算，而补码则是通过反码和原码推算出来的。 
         原码： 看数据 ，反码：转数据 ，补码：运算数据
         原码 ：
         二进制的定点表示法。最高位是符号位。 0 代表正 1代表负值 其余位数表示值的大小
         一个字节等于8个比特位 ，也就是 8个二进制位
         byte b1 = 7  ;   0(符号位)0000111    byte b2 = -7 ; 1(符号位) 0000111
         反码：
         正数的反码与其原码相同 ； 负数的反码与其原码逐位取反（0变1 ， 1 变 0），符号位除外
         补码：
         正数的补码与其原码相同 ； 负数的补码是在其 反码  的末位 加 1 得到的 
         二维数组
         int[][] arr 或者   int arr[][]   或者    int[] arr[]  
          int[][] arr = mew int[30][10];  30个一维数组 ，每个一维数组有10个元素
        </pre>
        <div class="text-red">
            方法执行完成 弹栈消失
        </div>
        <pre>
           类文件在方法区 ，对象实例在堆内存 ， 
           对象实例的方法地址指向方法区的类文件内的方法
          变量在栈内存，地址指向堆内存中的类的实例对象
           方法的调用， 类的实例对象的方法的调用 会进栈 
          类的主方法 main 方法 会被 jvm 主动调用 ，然后 main 方法 进栈
           代码由上往下执行， 方法顺序进栈  ， 栈内 方法 先进后出。
           最后调用的方法完成执行后 最先消失 
           当方法 执行完成 弹栈 消失
           </pre>

        <div class="text-h6">基础</div>
       <pre> 
           单个实例对象的 实例在 堆内存中 ，实例的  成员属性在堆内存，
          成员方法 在方法区 ，但是堆内存中存有 成员方法的内存地址
          成员变量： 
          类中方法外的变量 ，有初始默认值 ，堆内存 ，随对象GC 消失
          局部变量：
          类中方法内的变量 ，无初始默认值， 栈内存 ，随着方法的执行完成弹栈消失
          private 权限修饰符 
          私有 保证数据安全 ，需要根基需求提供 set 和 get 方法 获取 和设置 私有 成员属性 
          java 类的 构造方法
          1.方法名称和类名相同，大小写一致
          2.没有返回值类型，连 void 也没有
          3.没有具体的返回值 ，不能 由 return 带回 结果数据

          java 类的 构造方法 可以通过 方法的 重载 通过不同的参数 进行 不同 的 初始化
       </pre>
       <div>String</div>
       <pre>
         "" 创建的字符串  存在 字符串常量池   （在  堆内存 存储 ） 存在则不再创建  ,不可改变
         s1 = "123"  s2 = "123"  s1==s2 结果是true 
         new 创建的 每次都是不同的 内存地址 放在 堆内存中 new 创建的  不可能相等
         字符串的加号拼接 ：系统底层会自动创建一个 stringBuilder 对象 ，
         再调用其append 方法完成拼接 。拼接后，再调用toString 方法 转换为 String 类型
         因此  s1="abc"  s2="ab"  s3=s2+"c"   s1==s3   s3 是变量计算拼接 不是常量拼接  返回  false  
         "abc" == "a" + "b" + "c"  返回 true 原因 ：
          a,b,c 都是常量 java 的 常量优化机制 在编译的时候 就把右侧直接计算了
          equals 方法 比较 值是否相等
          String 类型 + 常量字符串 的 字符串拼接每次都会创建 两个对象 ，一个 stringBuilder 一个 string 
       </pre>
       <div>StringBuilder   一个可变的字符串类   append toString  reverce</div>
       <div>打印string  stringBuilder 集合 类  都不会出现内存地址。  打印数组  会出现 </div>
       <div> 集合 ArrayList</div>
       <pre>
           Student[] arr = new Student[3]  

        集合和数组 对比
        集合类 ：  提供一种存储空间可变的存储模型，容量可变
        数组类 ：   容量是固定的 不可变的 
        ArrayList  list = new ArrayList();
        集合内 可以放任意类型数据      
        泛型
        ArrayList&lt;String&gt;  list = new ArrayList &lt;&gt;();
        集合内 只能放 字符串 String 数据   
        集合常用API :   add remove  set  get size        
       </pre>
             <div> 高级面向对象 </div>
       <pre>
            业务对象类  本身  
            DAO  访问存储数据的数组 或者集合  data access object
            Service  用来 处理业务逻辑 ，服务器内部的 逻辑
            Controller  用来 处理     用户  和网页 的相关 逻辑  
            业务逻辑流程：
            controller 的 addItem 调用 service  的 addItem , service  的 addItem 调用 dao 的 addItem
           与试图打交道的 类 调用 与数据库打交道的类 ，与数据库打交道的类 调用 数据库类

            private  static  ， static 修饰的  静态成员属性 在内存中 所有这个类的实例中共享
             一般 存在于方法区中 
       </pre>
       <div>继承</div>
       <pre>
           继承： 让类鱼类之间产生 父子类关系 ， 子类可以直接使用 父类的非私有的成员  
                  例如 你可以用你爸爸的车 ，但你不能用他的内裤 
                  父类 ： 基类 超类   子类 ： 派生类 
                  public class ZI extends FU { }
            继承好处：复用性，维护性，让类之间产生关系是多态的前台
            继承弊端：继承是侵入性的 ，不灵活 ，子类   必须拥有父类的非私有属性和方法
                      耦合性强   父类中 非私有的东西 不能随便改 随便删除 
            JAVA 只支持 单继承 ，不支持 多继承 ，但是 支持多层继承  
             一个儿子不能 有两个亲爹 ，但是可以 有 爷爷 ， 有十八辈祖宗    
             this  自己的 当前类的  super  父级的   父类的 
             this() 访问本类的构造方法  super()访问父类的构造方法
            子父类同名属性或者方法：    可以通过 this.  读取 自己的 属性方法   ，super. 读取 父级的 属性方法
            
            方法 重写  ， 注解  @Override 检查 是否 正确重写 （必须一模一样）
            <div class="text-red">
                <div>父类的静态方法，个非静态方法 ， 子类必须一摸一样的名字才能重写 </div>
                
                <div>静态方法不能重写，父子类静态方法同名 ，只是子类将父类中的同名方法隐藏起来了。  就近原则</div>
            </div>
            子类 重写 父类 方法 ， 权限必须大于等于 父类 权限 
            java  四个 权限修饰符   private  小于 默认 小于 protected  小于 public 
            private  同一个类中
            默认     同一个包中 子类 无关类
            protected 不同包的子类
            public   不同包的 无关类

            子类的  构造方法 会默认调用 super() ；即便是不写 ，也会默认加上。不然子类没办法拿到继承而来的东西

            其实每一个类  都继承与 Objiect  类 如果没 指定继承则该类的构造方法 默认 继承自 Object 默认调用 super()

            抽象类   abstract
            抽象方法： 将共性的方法 抽取到父类之中后，发现该方法的实现逻辑无法确定，该方法就要可以定义为抽象方法
            抽象类： 如果一个类中 存在 抽象方法 ，那么这个类 就必须 声明为 抽象类
            public  abstract void aa();  
            public  abstract class  A1{}
            public  class A99  extends A1{}
            抽象类 只能被 继承 实现 。 不能创建 实例对象。因为 没有方法体的方法 不能调用。
            抽象类的 子类 必须 重写 父类的  抽象方法 ， 但是 子类也可以把自己变成 抽象类。
            抽象类 不一定有抽象方法， 有抽象方法的类 必定是抽象方法 

            抽象类  体现的是 一种  模板设计模式  
            final 关键字 可以修饰 属性 方法 类名   ，final 修饰的 属性方法 将不能重写 ，类不能  继承 ，一般用于  属性 和方法  禁止重写 
            局部代码块 在 方法中定义，限定变量的 生命周期，快速释放，提高内存利用率
             { }  构造代码块 在 类的 构造方法执行之前执行 ，  可以放  构造方法的 公用代码 
             static {}  静态代码块 随着 类的加载而加载，只执行一次， 一般用于数据初始化 ，只在类文件加载的时候执行。和构造方法调用无关
                    
       </pre>
       <div>接口</div>
       <pre>
           抽象类 可以制定 模板 ，制定一定规则 去让子类去实现
           但是如果某个抽象类的所有方法都是抽象方法的时候，我们就可以将其定义为接口
           接口也是一种引用数据类型， 比抽象类 更加抽象 
           接口的存在有两个重要意义： 1. 规则的定义  2. 程序的扩展性
           public interface AA {}
           接口本身 和 抽象方法一样不能实例化 
           public class AA_ZI implements AA{} 
           类不能多继承 ，但是 类 可以实现 多个接口 
           接口 因为是定义规则  ， 接口中的 属性 变量  默认是 final 修饰的 不能被修改 静态的 
           全部的修饰符 是  public static final 
           接口没有构造方法 
           接口中可以 使用 default 定义修饰 默认方法 ，默认方法 只要是用于 接口的迭代升级
           类 实现多个接口 ，如果多个接口中有重名的 默认方法 ，  子类 必须重写 这个 方法 
           接口中可以 使用 static 定义修饰 静态 方法  通过 接口名.静态方法名 来调用  
           接口中 可以有  静态 方法  默认方法 私有方法  抽象方法   

            继承亲爹 实现干爹  

            类和类之间       继承关系   只能 单继承  但是可以 多层继承    你-- 你爹  -你爷爷  - 你十八辈子祖宗
            类和接口之间     实现关系   可以单实现也可以多实现 ，还可以在继承一个类的时候 同时实现多个接口
            接口和接口之间   继承关系   可以单继承也可以多继承            

           
       </pre>
       <div> 多态</div>
       <pre>
           通用对象类型  ，例如 全球 70 亿人 实例 都是 人类 
           多态的前提是  要有 继承 或者实现关系  ，要有方法重写 ，要有父类引用 指向子类对象

           Animal a = new Cat();
           多态中的 成员访问 特点
           构造方法：  同继承一样 ，子类会通过  super 访问 父类 构造器
           成员变量： 编译看左边 父类  ， 执行 看左边父类
           成员方法：  编译看左边父类，   执行 看 右边子类
            多态 弊端：  不能调用子类特有 方法 属性
           多态中的 转型
           向上转型  父类引用  指向子类对象     把一个 子类类型  转换为 一个 父类类型   小的转大的  不用强制转换
           向下转型  子类引用  指向父类对象     把一个 父类类型  转换为 一个 子类类型    大的转小的  需要强制类型转换
           instanceof  
           
       </pre>
       <div> 内部类</div>
       <pre>
           Outer.Inner i = new Outer().new Inner();
           匿名内部类
           函数式编程思想
           lambda   箭头 函数   是将 匿名 内部类 的  一个  优化 
           doaaaa( AA a){ a.nn(); }
            doaaaa(new AA(){
                public void nn(){
                    sout("Niubi ")
                }
            })
           doaaaa(()->{  sout("Niubi ") })
           匿名内部类 ，必须 实现一个接口 ，生产 一个实现类的对象 ，重写方法 ，读取重写的方法 ，执行方法  
           这个方法 根本的阐述    传递的是一个函数 ， 箭头函数方式 我们直接传入 的 是 方法的 实体 ，
           把原本的关注点 转到方法的具体实现
           lambda 使用前提：  必须有一个接口  接口中 有且仅有一个 抽象方法 
           这种 根本上 传入的  还是一个 匿名对象，实例的 匿名实现类的 一个具体的 对象
       </pre> 
       <div>  </div>
       <pre>
            collection  map   list  arraylist  linkedlist set hashset treeset   HashMap   TreeMap
            数组长度固定， 集合 会自动扩缩容 每次 1.5倍数，长度小于10  是 10
            栈  压栈 弹栈
            队列  入队列             出队列    前端  后端   
            数组   查询快 增删慢   因为 增删 需要 把后面的 每个都平移一位 
            链表    增删快 查询慢  必须 从  头开始查  单向链表
            链表   结点   头结点（地址）数据地址数据地址。。。。。^ 结束  火车一样，每一个结点 都由 数据 和地址组成  
                    链表有头有尾  尾巴 是 一个空地址   ，前一个结点 记录后一个结点的地址值
            双向链表      前一个结点的地址+值+下一个结点的地址   
            linkedlist 链表  增删方法比较特殊 ， 有一些特殊方法 

            泛型  
            不写 默认 Object,,提供 编译时候 安全检测机制   
            
            collection  单列集合   list set 
            set 没有索引 只能用迭代器  iterator 进行迭代    或者 增强 for 进行魂环 
            hashset  treeset
            treeset 可以对 内部元素 进行 排序 要想使用 treeset 必须 指定 排序规则   自然排序
              内部的 元素 必须 实现 comparable 接口  并且重写 compareTo 方法 
              compareTo  返回 0 则 不存储 ， 大于存右边 ，小于存左边
              字符串也有 compareTo 方法 
              comparator  比较器 类 实现 compare 方法  抽象类
            

            数据结构 树   结点
              二叉树    结点  父节点+当前节点值+左子节点+右子节点 
              二叉树的查询都是从根节点进行查询
              度： 每一个节点的子节点的 数量
              高度， 二叉树的 根节点 到最 末梢结点的 最长层级 ，也就是 分叉 分了 几次+1

              普通二叉树     二叉查找树，二叉搜索树
              普通二叉树     左右子节点 大小没关系
              二叉查找树     左子节点小于右边子节点  ，一样的 不存储  ，
              二叉查找树     每一次存储一个值 都要从根节点 开始找路径 进行比较，找到自己的位置 ，
                             可能出现 左右子树高度差的很远
              平衡二叉树     任意左右节点 的 两个子树都是一棵平衡二叉树 ，左右高度相差不超过1
                             左右 旋转 ， 变化根节点，根节点 会变化，普通二叉树 不会变根节点
                             左旋 ，原本根节点的右节点 升为根节点 
                                    新的根节点的 原本的左节点 倒向左侧， 链接旧的的根节点作为右侧，做为右弦
                             右旋 ：和上面的左旋 处处相反
                             左左插入--右旋 ， 
                             左右插入--失衡区域左旋，然后整体右旋 ，两次旋转
                             右右插入--左旋
                             右左插入--失衡区域右旋，然后整体左旋
              红黑树         一种自平衡的二叉查找树 ，但不是高度平衡，不是每次都去计算是否平衡，有自己的红黑规则
                             每一个节点 都是 红色 或者黑色
                             根节点必须黑色
                             如果一个节点没有子节点或者父节点，则这个节点相应的值为Nil，被称为叶节点，都是黑色的
                             如果一个节点是红色的，那么它的子节点必须是黑色的，不能出现两个红色的节点相连
                             每一个节点，从该节点到它所有的后代叶节点的简单路径上，都包含相同数目的黑色节点
                             红黑树多了一个颜色属性
                             添加三个默认黑色 调整两次
                             添加三个默认红色 调整1次数
                             红黑树为了提升性能，默认添加数据颜色为红色
                             红黑树  ---旋转 区域小，只旋转了父节点 祖父节点， 把父节点提升祖父节点下降作为父节点的右子节点 ，或者左子节点
                             红黑树 添加数据 需要变色 ，只有在父节点红色，叔叔节点黑色，才会旋转
            
            hashset  
              
                  a.hashCode() 计算 哈希值， 同一个对象的 哈希值 一样的
                  0.75 扩展因子， 满容量的 0.75  则扩容 2倍数
                  集合 ，每个位置 一个哈希 ，如果 相同哈希，则存在同一个位置， 同一个位置总数小于8 采用 链表 ，大于等于8 采用 红黑树
               hashset  必须重写 hashcode 和 equals 方法   
                
            MAP
            Interface Map K,V     
            键值对 ，entry 对象
            hashmap  底层 还是 数组 和 红黑树 ，也有 扩展因子  和 hashset 很类似 
            terrmap  底层 是根据key 排序的 treeset 类似的 原理 

            可变参数  （int ...a）  类似 js 的 数组解构， 底层是一个数组，是一种  简便写法
            
            stream  流
            流 操作 可以 过滤 和js 的  过滤一样  相当于读数据中 每个去过滤 执行
            流水线 ，每次操作一波，  流水线 ，准备物料 --> 各种一次次操作加工 -->出货  . 获取流--> 中间方法--> 终结方法
            list1.stream().filter(()->{ }).filter(()->{ }).filter(()->{ }).filter(()->{ }).filter(()->{ }).forEach(()->{})
            list1.stream().filter(()->{ }).filter(()->{ }).filter(()->{ }).filter(()->{ }).filter(()->{ }).xollect(Collectors.toList())
            stream.of()
            limit()  skip() 
            
            
            
            
                       
       </pre>
            <div>IO</div>
        <pre>
            字节流 写 各种文件类型 
            字符流 写  记事本 txt 文件 
            释放资 源 close     捕获错误
            FileOutputStream   FileInputStream 
            字节缓冲流  BufferedOutputStream   BufferedInputStream
            字符输出流   FileWriter   
            字符缓冲流  BufferedWriter   BufferedReader
            转换流
            对象操作流   ObjectOutputStream   ObjectInputStream  
                           对象需要实现 可序列化接口 ，需要抛出各种异常  需要看 demo
                           transient  路过的  序列化跳过字段  例如密码
            properties  
                        MAP       双列集合的操作流  
                        put   setProperty 
                        load  加载.property 文件
                        store  存储.property 文件      
                        等号 形式 ，键值对 ，一般作为配置文件  .property 文件
                        搜索  .property 文件 读取   需要关闭 IO 流 
                        
            apche-commons-io
            
            
        </pre>
        <div> 多线程</div>
        <pre>
            cpu 在 多个 进程中 高速切换， 表征是 同时运行 ，例如电脑 同时 执行很多个软件
            并行： 同一时刻，有多个指令 在多个 CPU 上 同时执行    三个人同时做三件事
            并发： 在同一时刻， 有多个指令 在单个CPU 上交替执行   一个人同时做三件事

            进程 线程
            进程： 正在 运行的 软件   ，独立 动态 并发
            线程： 单个进程中的单个顺序控制流 ，一条执行 路径
                   单线程： 一个进程  只有一条执行路径
                   多线程： 一个进程  有多条执行路径 
            多线程的 实现方案
             1.继承 Thread 类   2.实现 Runable 接口 ，调用 Thread 类  3. 利用 callable 和 future 接口实现  ，调用 Thread 类 
             继承 Thread 类   
             继承 线程类 重写 run 方法  创建一个线程对象 ，开启多个线程  t1.start()
             run 方法 没有开启线程 ，只是一般的方法 ， start 方法 开启线程
             实现 Runable 接口
             定义xx类 实现 Runable 接口  重写 run 方法  创建对象 xxa
             创建 Thread 类对象 把  xxa对象 作为构造方法的参数 启动线程
             类 可执行 run 方法      线程 可执行 start 方法   
             琼东一个线程 去 执行 可执行类的 run 方法 
             利用 callable 和 future 接口实现 
             定义一个类 实现 callable 接口  重写 call 方法  创建 aa 对象
             创建 future 接口 的 实现类 ff对象  把aa对象 作为 ff构造方法的参数  FutureTask
             创建 Thread 类对象 ，把 ff对象 作为 构造方法的参数  启动线程
             这种 方式 可以有返回值

            传递给 thread 的 参数 必须 实现了  runable 接口
            线程的  get 方法 可以 获取 线程执行完的 返回结果 
            线程 可以自定义  线程名字   setName  getName
            线程   可以  sleep  休眠  时常  

            线程调度
            计算机中的 CPU  在任意时刻只能执行一条机器命令。每个线程只有在 获得CPU 的使用权才能执行代码
            各个线程轮流获得CPU的 使用权 ，分别执行各自的任务 
            分时调度模型   ，抢占式调度模型 
            java 使用的是 抢占调度模式  ，每个线程可以 设置 优先级 (10-1)   setPriority
            
            后台线程  守护线程    普通线程执行完成后，守护线程不再执行
            setDaemon   设置为守护线程

            线程 安全问题
            三个窗口卖100张电影票 ， 相同票买了很多次 ，出现 负数票号
            执行每一行代码的时候 ，CPU  执行权力 都可能被别的线程 抢走。 
            多线程安全问题是因为多线程操作共享数据造成的
            加锁----------------加锁      
            十个人抢着上一个厕所，抢到的上厕所就立即锁门 ，免得别人进厕所  ，同步执行的代码块，只能单线程，别的只能等 
            多线程安全问题的解决方案基本思想： 让程序没有安全问题的环境
            解决方法：
                    把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可
                    java 提供了同步代码块的方式 来解决
            synchronized(任意锁对象（类的静态成员属性，全部类实例公用的）){多条线程操作的共享数据的代码块} 
                                  代码执行会去改变和还原这个锁对象， 锁对象 必须唯一
            synchronized 会自动上锁
                        好处： 线程安全
                        坏处： 线程很多的时候，每个线程都会去判断同步上的锁，很消耗资源，会降低程序的运行效率
            同步方法和同步代码块：
                    同步代码块可以锁住指定的代码，同步方法是锁住方法中的所有代码
                    同步代码块可以指定锁对象，同步方法不能指定锁对象
                    同步方法 的锁对象 是锁定的  this  对象本身
            Lock 锁接口       lock  unlock    自定义 锁定 和解锁方法 ， 方便
            死锁：是指两个或者多个线程相互之间持有对方所需要的 资源，相互等待，无法继续执行。 叉号
                 死锁是多个锁的 嵌套导致
             生产者，消费者     
            wait  notify  notifyAll    等待 通知 唤醒  ，使用 锁对象 去 等待和唤醒
                等待和唤醒机制，需要中间参照    厨师 ，餐桌，顾客
            阻塞队列    
            queue    BlockingQueue    一根管子  通道 ， 一头生产者一头消费者 ， 消息队列
            ArrayBlockingQueue   底层 数组 ，有界限
            LinkedBlockingQueue  底层 链表 ，无界限   最大为 int 的最大 值
            阻塞队列 设置最大值  while 循环 无线 添加  无线读取 ， 超限 报警
            线程池 volatile  threadpool  线程池    executor    submit 提交任务
            线程 生命周期：创建 new： start---就绪 runnable： 有执行资格，无执行权限---运行：抢到执行权 run----结束 死亡 垃圾回收  
            线程  其他状态： 阻塞（有锁 lock blocked） ， 等待（wait） ，计时等待(sleep) ，唤起 就绪 notify  
            线程的每次创建，等待创建和销毁以及等待销毁 都消耗系统资源，因此 线程池 很重要， 就好比碗柜，吃饭拿碗，吃碗放回去
            线程池 执行原理 和 100人食堂吃饭，使用可循环的碗筷一样 ，只不过 这个放碗的碗柜 可以自己制造碗 
            Executors 可以创建 线程池  ，  
            ExecutorService 可以管理线程池 定量或者不限量   poll-1-thread-1  线程池子内的线程的 getName 返回的 样子
            Thread.currentThread().getName()
            ThreadPoolExector  
            核心线程数，最大线程数，空闲线程最大存活时间，时间单位，任务队列，创建线程工厂，任务的拒绝策略
            任务的拒绝策略：1.丢弃并抛异常 2.丢弃不抛异常 3.抛弃队列中等待最久的任务，添加当前任务 4.调用任务的run方法跳过线程池直接执行
             修改了共享数据 ，某些线程不知道修改 ，消息不同步  反复无常 ，不稳定
            共享数据的修改并不能 通知告知 哥哥线程 自己修改了 ， 每个线程也没有每次都去都最新的 ，而是从自己的变量副本读取
            每个线程有自己的独立的线程栈  ，共享数据 ，多个线程共享、  共享数据在每个线程内是变量副本 ，不是时时刻刻从共享数据读取
            volatile  ： 强制要求 每次线程执行的时候 去读取 最新的 共享数据 ，在变量前面 加上 volatile 这个关键字  （不稳定的）
            public static volatile int money = 100000;
            加了 volatile 之后：  同步代码块 synchronized 执行步骤：
             1.线程获得锁 2.清空变量副本 3.拷贝共享变量最新的值到变量副本 4.执行代码 5.将修改后的变量副本中的值赋值给共享数据  6. 释放锁 

            原子性： 是指在一次操作或者多次操作中，必须所有的操作全部完整执行才可以，否则所有的操作都不执行，多个操作是一个不可分割的整体
            原子性 ： 比如 银行转账  扣款和到账必须 是一体的 
            volatile  只能保证 最新 ，不能保证原子性     volatile   +   synchronized锁  可以保证 原子性  ， 但是 性能较差
            Atomic 接口  原子类 接口  实现保证原子性，更新 数据  AtomicInterger   以 原子的方式 对值进行修改
            把共享数据  使用 原子类来实现 ， 共享数据的改变使用  使用原子类来操作    ac.incrementAndGet
            原子类 原理 ：  自旋锁 + CAS算法 
                           CAS 算法 有三个操作数 ： 内存值V 旧的预期值A 要修改的值B 
                           自旋操作： 当 A==V 修改成功，把V 赋值为B ， 当 A!=V 修改失败 不做任何操作V还是原来的，并且重新获取现在的最新值
                                  这个重新获取的动作就是自旋。  自旋以后重新去执行CAS算法 ，执行运算
                                   
             volatile   +   synchronized锁 与 Atomic  CAS  的区别
                相同点： 多线程情况下都能保证共享数据的安全
                不同点： （悲观锁）synchronized锁 总是从最坏的角度出发 ，认为每次获取的数据的时候别人都可能修改了，因此每次读取共享数据之前都上锁
                         （乐观锁）CAS 从乐观的角度出发，假设每次获取数据别人都不会修改，所以不上同步锁，
                         只不过在每次修改共享数据的时候都会检查一下，别人有没有修改过数据。 （旧的期望值 等不等于  当前的内存值（变量副本中的值））
             hashmap 是线程不安全的 ，多线程环境下存在问题。为了保证数据安全可以使用 hashTable 但是 hashTable 效率低下 
                       hashTable  是 悲观锁 实现 数据安全性 ， 只要有数据改变 ，就锁表
             ConcurrentHashMap 既可以保证线程安全，数据安全 ，又可以保证执行效率    （并发的 hash 双列表 结构） 
             ConcurrentHashMap JDK1.7
                        二次哈希 ，也会锁表，但是锁的是单个地址位置上的 hashentry数组 ,不影响其他位置使用
                        第一次会根据 键的哈希值来计算出 在大数组中的应存入的位置，  
                        如果为null ，创建小数组，二次哈希，计算出小数组的存储位置， 存入。 
                        如果不为null,先找到小数组，再计算出小数组中的位置，没有就存，有就比较后存储，

             ConcurrentHashMap JDK1.8
                        数组 链表 红黑树  CAS 原子锁  ，只锁 单个位置上的链表或者红黑树
             CountDownLatch (倒数计秒 取插销)  传递需要等待的线程数   很奇怪 的 东西  ， 线程数 ，等待 ，以及通知 。某个线程 干完事说一声
                        CountDownLatch  可以传递给每一个线程， 用于几个线程之间通知 线程执行完毕的状态
                        每个线程执行完 要调用  countdown 方法   ，再等待的线程 wait 等待 ，等它等待的几条线程全部执行完毕，会被自动唤起开始继续执行
                        例如 要等待 三个线程 ，等三个线程都完成了 则 再等待的线程开始执行 ， 底层原理 是一个计数器
            Semaphore     信号标， 通行证 ，令牌 ， 一段时间内 只能去允许 几个线程执行 ， 当某一个执行完成，释放信号，归还通行证， 
                         别的等待的就能领取通行证，开始执行。 原理就跟 限定10辆车进入园区一样， 进去拿通行证，出去交还通行证，最多十辆
                         多个线程 共同找同一个管理员：   获取通行证 ， 拿到通行证开始执行 方法块代码，执行完了 ， 归还通行证
                         
            
        </pre>
        <div> 网络编程  UDP TCP</div>
        <pre>
            三要素： IP地址  端口  协议     ，服务运行的 IP , 程序跑的端口 ， 约定的协议
            ping 域名  可以取到 这个域名 的 IP 
            IPV4 本身 是 32bit  4个8bit 位置的数组组成   点分 十进制 表示法   127.23.36.23  256 的4次方  42亿个地址左右
            IPV6 是  128个bit 位置  每16个一组 ，分为8组  冒分 十六进制 表示法   2404:3c00:484d:b300:84ff:c8e3:999c:ecf2   
            InetAddress  可以获取 电脑的 相关的 名字属性等  网络相关的  地址 协议 等
            
            UDP 协议  面向无连接的协议 ，不管对方是否建立连接 ，   速度快 最多64K 不安全 容易丢失数据
            TCP 协议  面向有连接的协议 ，速度慢 ，没有大小限制 ，数据安全  

            UDP 通讯程序
                DatagramSocket   数据程序通信    指定端口收发数据 。 发送的都是 字节码  接收 可以指定接收容器大小
                发送端：  步骤： 新建socket对象， 新的接收消息存放箱子，  消息打包  ，发送出去 ，释放资源 
                接收端：  步骤： 新建socket对象， 新的接收消息存放箱子，  消息打包  ，从箱子获取消息 ，释放资源 
            UDP 三种通讯形式： 单播， 组播 （局域网） ，广播     
                单播 发送端 指定 接收端 ip 和端口   接收端 接收 指定的 IP端口
                组播 在 224.1.x.x  号段 端口  组播 需要 发送端 和接收端约定 组播地址 ip 和端口
                广播 在 255.255.255.255  号段  端口  接收端 接收指定 端口  ， 广播针对 当前路由器链接的所有电脑
                无论如何  接收端 都需要订阅  或者固定 IP端口  或者是 号段
            TCP 通讯程序
                在客户端和 服务端 各自建立一个 socket 对象
                TCP 发送数据通讯之前 必须保证 连接建立
                客户端    发送数据步骤：
                        1.创建 客户端的 Socket 对象 与指定的 服务端 链接  Socket( host ,port)
                        2.获取输出流 ，写数据   OutputStream 
                        3.释放资源  close 
                服务端    接收数据步骤：  
                        1.创建服务器端的Socket 对象  ServerSocket(port)
                        2.监听客户端链接，  accept()  如果收到数据则返回一个Socket 对象 ，  死等 阻塞形式的等待
                        3.获取输入流，读数据，并把数据显示在控制台   InputStream 
                        4.释放资源   close 

                注意点：不论是 客户端还是服务器端，有至少有一个写入或者写出流 和 一个 socket 需要 关闭 释放资源 
                        如果是建立链接后多次写入写出 ，则需要使用 socket 去 关闭写入写出流，并且对socket 没有影响 ，不会关闭自己 
                        如果传输中文，需要把字节流转换为 字符缓冲流
                        1. accept 方法是阻塞的 ，作用是等待客户端 链接
                        2. 客户端创建对象并链接服务器，此时是通过三次握手协议保证跟服务器之间的连接
                        3.和UDP 相反， TCP 针对客户端来讲，是往外写，是输出流。 针对服务端来讲，是往里读，是输入流
                        4.服务器 读数据也是阻塞的 ，一直读取
                        5.在客户端关闭输出流的时候， 还会向服务器发送一个结束标记 的动作 信息
                        6.客户端断开链接，通过四次挥手协议保证链接终止
                三次握手： 1.客户端向服务器端发出链接请求 ，等待服务器确认是否可以链接
                           2.服务器端向客户端返回一个相应，告诉客户端收到了请求，你可以链接/或者不能链接
                           3.客户端向服务器端再次发出确认信息， 建立链接  去索要东西
                四次挥手： 1.客户端向服务器发出取消连接请求
                           2.服务器向客户端返回一个响应，表示收到客户端的取消请求
                            中间这里，服务器将最后的数据处理完毕
                           3.服务器向客户端发出确认取消的消息
                           4.客户端再次发送确认消息 ，取消链接      
                文件上传要使用 线程池  多线程 实现
                                 


        </pre>
        <div>类加载器和 反射</div>
        <pre>
            classLoader   类加载器     
            启动类加载器  平台类加载器  系统类加载器  自定义类加载器
            双亲委派模型  默认先由 父加载器加载类文件 
            类加载器，可以去加载文件 返回 字节流 

            java的 反射机制   reflect
                   是指再 java 运行状态中，对于任意一个类，都能知道这个类的所有属性和方法
                   对于任意一个对象，都能够调用它的任意属性和方法
                   这种动态获取信息以及动态调用对象的功能称为 java 语言的反射机制
                通过配置文件 动态的加载类名 和方法名字， 进行调用   
            获得 class 对象的三种形式   Student.getClass()  Class.forName(类的全类名)   Student.class  
             使用 反射 获取 类的  constructor field   method  单个对象 的  实例
            利用反射创建对象实例步骤：
                1.forName 获取 class 对象
                2.获取构造方法对象
                3.利用newInstance  创建 类 的 对象
                被 private 修饰的 成员 是不能直接使用的，如果使用反射强行获取并且使用，需要临时取消访问检查
                setAccessible  暴力反射  强行使用
                field  get  set 设置值 必须指定对象 
                method  invoke 运行方法

            XML 
                小于  &lt;  大于 &gt; 和号 &amp; 单引号 &apos; 双引号 &quot;
                &lt;![CDATA[内容]]&gt;
                XML 解析 ： jaxp   jdom dom4j  pull  
                add as libary
                使用 解析插件  解析xml  获得  document 对象
            DTD  schema
            自定义dtd    自定义 文档定义类型
            !DOCTYPE 跟标签 SYSTEM 本地文件路径
            !DOCTYPE 跟标签 PUBLIC  文件名  文件网络上的路径
            ELEMENT ATTLIST 
            schema  .xsd  文件     schema 文档约束文件   更加灵活
            名称空间 约定  顺序 类型

            枚举  ENUM 
                通过枚举类名.枚举项名称 方式去访问指定的枚举项
                每一个枚举项其实就是该枚举的一个对象
                枚举也是一个类，可以去定义成员变量、
                第一行必须是枚举项
                枚举类可以有构造器 ，必须是 private 的
                枚举类也可以有抽象方法，但是枚举项必须重写这个方法

            注解
                deprecated 过时的   suppressWarning 压制警告  retention 注解存活保留时间 生命周期
                注解是给编译器看的 ，代表一些特殊功能
                自定义注解 
                public @interface 注解名称{
                        public 属性类型 属性名() default 默认值;
                }
                自定义注解的 属性 类型 可是是 基本类型， class 类型 注解类型  枚举类型 ，或者这些可选类型的一维数组类型
                在使用注解的时候，如果注解里面的属性没有指定默认值，就需要我们手动给出注解属性的默认值
                @anni(name="但是此时") 针对 value 这个特殊的注解属性，如果只需要给这个属性赋值则可以@ann("杀杀杀")
                利用反射 获取到类的 方法 ，方法是 method 类的 实例 method 有方法判定是否自身有注解
                method 注解包内有 方法判定是否预设了指定的注解 ，从而来判断一个方法是否添加了注解 
                retention  默认 是 只在Java 文件内有效，在 字节码文件  运行时 无效
            元注解 
                描述注解的注解      
                    常用元注解：retention 生命周期  target 使用范围  inherited  可被继承  documented   会出现在API文档
            单元测试 Junit 
                @Test   @before  @after  
            日志技术 log4j
                日志体系结构 两套接口 ： JCL slf4j
                可以直接使用 log4j
                也可以使用 slf4j 里面的 api 来获取日志对象，使用 log4j 来实现 slf4j
                好处是 以后更换日志的实现类 代码 基本不用改什么
                log4j 组成：
                    1.loggers 记录器 日志的级别
                    2.appenders 输出源 日志要输出的地方
                    3.layouts 布局 日志输出的格式 

        </pre>
         
    </div>
</template>
<script>
    export default {
    }
</script>
<style lang="scss" scoped>
</style>