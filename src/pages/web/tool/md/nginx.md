# nginx

## 正向代理与反向代理

### 同域的要求

- 1.协议相同
- 2.域名相同
- 3.端口相同

### 正向代理与反向代理

- 正向代理

	- 解释

		- 意思是一个位于客户端和目标服务器(target server)之间的服务器，为了从目标服务器取得内容，客户端向代理发送一个请求并指定目标(目标服务器)，然后代理向目标服务器转交请求并将获得的内容返回给客户端。

	- 通俗地说

		- 「客户端」可以看作一个黑社会大佬，「目标服务器」可以看作一家饭店，「代理服务器」可以看作小弟。
		- 「老大」想吃饭店的酱排骨饭，就让「小弟」去买，「小弟」跑到「饭店」要个酱排骨饭。
		- 「饭店」酱排骨饭做好，送到「小弟」手上，「小弟」最后再把酱排骨饭拿给「大佬」。
		- 说白了，小弟就是个跑腿的，代理大佬的需求。

	- 数据流程

		- 数据请求过程：浏览器 -> 代理服务器 -> 目标服务器
		- 数据返回过程：目标服务器 -> 代理服务器 -> 浏览器

	- 应用

		- 最经典的应用就是科学上网：我是一个国内用户，我访问不了google，但是我能访问一个香港的某个代理服务器。这个香港的代理服务器可以访问google，于是我先把请求发送到那个代理服务器，告诉他我需要访问google，代理服务器去取内容，最后返回给我。

- 反向代理

	- 解释

		- 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。

	- 数据流程

		- 数据请求过程：浏览器 ->【反向代理服务器 -> 处理数据的服务器】
		- 数据返回过程：【处理数据的服务器 -> 反向代理服务器】-> 浏览器

	- 通俗地说

		- 「浏览器」可以看作食客，「【反向代理服务器-》处理数据的服务器】」这一个整体可以看作饭店，其中「反向代理服务」相当于点单的服务员。「处理数据的服务器」可以理解为是厨师。
		- 「食客」向来到「饭店」向「服务员」点菜，但服务员并不会真正去做菜，他是下达命令让「厨师」去做菜。
		- 「厨师」把菜做好了给「服务员」，「服务员」再把菜端给「食客」。
		- 在外部看来，「代理服务器」和「处理数据的服务器」是一个整体。就好比，食客只会去饭店吃饭，而不是去找厨师吃饭（即对于浏览器来说，到达反向代理服务器已经完成任务了，后面的操作则由反向代理服务器负责）。具体饭店怎么操作，对食客是透明的。有可能某个服务员即当服务器也当厨师（即反向代理服务器和处理数据的服务器是同一台PC机）。

- 比较

	- 从用途上来讲

		- 正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。
		- 反向代理的典型用途是为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。

	- 从安全性来讲

		- 正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。
		- 反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。

	- 从使用方来看

		- 正向代理是浏览器端进行配置的，与服务器端无关，甚至可以对服务端隐藏。
		- 反向代理是服务器端配置的，对浏览器端是透明的。

- 总结

	- 正向代理代理客户端，反向代理代理服务器

### 利用代理实现跨域

- 正向代理

	- 对正向代理服务器进行配置，当获取非接口数据时，让代理服务器指向开发者本机的资源。当访问接口时，访问后端接口数据。
	- Charles、Fiddler

- 反向代理

	- Nginx

		- 用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。
		- 原理

			- 只需要配置nginx，在一个服务器上配置多个前缀来转发http/https请求到多个真实的服务器即可。这样，这个服务器上所有url都是相同的域名、协议和端口。因此，对于浏览器来说，这些url都是同源的，没有跨域限制。而实际上，这些url实际上由物理服务器提供服务。这些服务器内的javascript可以跨域调用所有这些服务器上的url。

		- 使用

			- server {
        listen       9000;  #配置第一台服务器
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            #alias D:\\develop\\project1dir\\app\\; #配置别名到项目源代码目录，那么访问http://localhost:9000/即访问此目录
            # Frontend Server
            proxy_pass http://localhost:8001/;  #更聪明的做法是代理到前端服务器地址，比如gulp+browser-sync开启的服务器，能看到代码实时更新效果
        }

        location /api/ {
            rewrite ^/api/(.*)$ /$1 break;   #所有对后端的请求加一个api前缀方便区分，真正访问的时候移除这个前缀
            # API Server
            proxy_pass http://www.serverA.com;  #将真正的请求代理到serverA,即真实的服务器地址，ajax的url为/api/user/1的请求将会访问http://www.serverA.com/user/1
        }
}
