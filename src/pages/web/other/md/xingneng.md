# 性能

## 程序性能

### Web Worker

- JavaScript 当前并没有任何支持多线程执行的功能。
- 程序中每一个这样的独立的多线程部分被称为一个（Web）Worker
- Worker 之间以及它们和主程序之间，不会共享任何作用域或资源
- 专用 Worker 和创建它的程序之间是一对一的关系，通过 meaasge 通信
- 在 Worker 内部是无法访问主程序的任何资源的
- 以执行网络操 作（Ajax、WebSockets）以及设定定时 器
- 可以访问几个重要的全局变量和功能的本地复 本
- 需要在线程之间通过事件机制传递大量的信息，可能是双向的
- SharedWorker 可以共享的中心 worker
- 在共享 Worker 内部，必须要处理额外的一个事件："connect"

### 　SIMD

- 单指令多数据（SIMD）是一种数据并行 （data parallelism）方式
- SIMD JavaScript 计划向 JavaScript 代码暴露短向量类型和 API

### asm.js

- asm.js（http://asmjs.org ）这个标签是指 JavaScript 语言中可以高度优化的一个子集。
- 现有的程序可以从asm.js 风格的优化得益而无需特意做什么
- 关于 asm.js 优化，首先要理解的是类型和强制类型转换
- var a= 42；var b = a | 0;
- 对 JavaScript 性能影响最大的因素是内存分配、垃圾收集和作用域访问。
- 对特定的任务处理提供一种优化方法，比如数学运算

## 性能测试与调优

### 性能测试

- 简单的数学平均值绝对不足以对你要外推到整个应用范围的性能作出判断
- 一个统计学上有效的性能测试工具，名为 Benchmark.js

### 　环境为王

- 现代引擎要比我们凭直觉进行的推导复杂得多
- 引擎可能不会优化这样无关紧要的代码，但是在系统已经在运行更复杂的程序时可能会
- 倾向于激进的优化。

### jsPerf.com

- 交叉引用多个浏览器上的测试运行结果
- 测试结果就会被收集并持久化，累积的测试结果会被图形化

### 写好测试

- 要写好测试，需要认真分析和思考两个测试用例之间有什么区别，以及这些区别是有意 还是无意 的
- 编写更好更清晰的测试
- 不要试图窄化到真实代码的微小片段

### 微性能

- 有时候编译器可能会决定执行与你所写的不同的代码，不只是顺序不同，实际内容也会不同
- 花费在优化关键路径上的时间不是浪费，不管节省的时间多么少
- 而花在非关键路径优化上的时间都不值得，不管节省的时间多么多

### 尾调用优化

- 尾调用就是一个出现在另一个函数“结尾”处的函数调用
- 调用一个新的函数需要额外的一块预留内存来管理调用栈，称为栈帧，尾部调用可以使用上一个函数的栈帧
- 有了 TCO，尾调用的递归函数本质上就可以任意运行，因为再也不需要使用额外的内存！

## JavaScript性能

### 脚本阻塞

- 减少JavaScript文件大小并限制HTTP请求数量
- 将外链JavaScript放置页面底部加载
- defer: 本元素所含的脚本不会修改,因此代码能安全地延迟执行，页面加载完成后执行
- async：下载完成后自动执行，采用并行下载，下载过程中不会发生阻塞（同defer）
- 动态脚本加载：操作DOM添加 script，所有的外链都是非阻塞加载，且加载完后会立即执行（FireFox和Opera会等所有动态脚本元素加载完后再执行）
- IE中的script标签加载生命周期,只需监测带星号的状态

	- uninitialized
	- loading
	- loaded(*)
	- interactive
	- complete(*)

### 数据存取

- 作用域

	- 全局作用域
	- 局部作用域

		- 函数作用域

			- 创建函数时，它的作用域链插入了一个对象变量，这个对象变量包含该作用域下声明的所有的变量
			- 执行函数时，创建一个执行环境（执行上下文），执行结束执行环境就被销毁。（call stack）

		- 块状语句

	- 作用域链

		- 每个执行环境都有自己的作用域链，用解析标识符，如果当前作用域没有该标识符，则在上一级作用域查询，直到全局作用域。查询结束后，会创建一个活动对象（作为函数运行时的变量对象，然后此对象被推入作用域链最前端；执行环境被销毁，活动对象也随之销毁），正是这个查询过程影响了性能。

	- 改变作用域链

		- try...catch

			- catch语句会把错误对象推入作用域链最前端

		- with

			- 创建一个新的变量对象并将其推入作用域链最前端

		- eval

			- 动态作用域

- 闭包

	- 闭包的[[scope]]属性包含了与执行环境作用域链相同的对象引用。函数的活动对象会随着执行环境一起销毁，但引入闭包后，由于引用仍然存在于闭包的[[scope]]属性中，所以此活动对象无法被销毁。

- 原型

	- 原型、原型链可参照作用域链，表现和原理极其类似。

### 算法和流程控制

- 循环

	- 过程式

		- for in（也会遍历原型属性，bad）
		- for
		- while
		- do while
		- for of（ES6）

	- 基于函数的迭代普遍慢于过程式迭代
	- 避免for in，减少每次迭代处理的事务，减少迭代的次数

- 条件语句和查找表

	- 根据场景需要，选择合适的方案。通常switch优于ifelsel，当判断条件很多时，使用查找表更优。

- 递归和迭代

	- 大多数浏览器有调用栈限制，考虑用迭代替代一些递归
	- 缓存前一个计算结果供后续计算使用

### 管理JavaScript运行时间

- 浏览器UI线程（单线程）

	- 执行JavaScript代码
	- 更新用户界面（重排重绘）

- 定时器

	- 用定时器将执行JavaScript代码的时间让给浏览器更新UI，然后再执行JavaScript代码
	- 注意事项

		- 设置的时间只是说明，在那个时间后 定时器绑定的事件才加入任务队列，并非是执行该事件。

	- 将耗时长的任务分割为一堆子任务

- Web Workers

	- 未绑定UI线程，所以可在UI线程外执行特定的代码
	- 通过postMessage message来进行页面与Web Workers的通信

- 注意事项

	- JavaScript脚本运行时间不应超过100ms

### 事件循环

- https://geniusfunny.github.io/2018/06/27/event-loop/

### Ajax

- 数据传输

	- 请求数据

		- 动态脚本注入
		- XMLHttpRequest
		- Multipart XHR

			- 无法缓存
			- 通过readystate为3来进行XHR流式处理

	- 发送数据

		- XHR
		- 信标（Beancons）

- 数据格式

	- XML
	- Xpath
	- JSON
	- JSON-P
	- HTML
	- 自定义格式

- 性能指南

	- 数据缓存

		- 设置HTTP头信息
		- 本地数据存储

### 编程实践

- 双重求值

	- 在程序中提取一个包含代码的字符串，然后动态执行它。

- 使用Object/Array直接量
- 延迟加载

	- 当一个函数在页面不会立刻调用时

- 条件预加载

	- 当一个函数马上就要用到并且整个页面周期中频繁出现

- 使用语言中快速的一部分

	- 位操作
	- 原生方法

###  构建及部署

- 合并多个JavaScript文件以减少HTTP请求
- JavaScript压缩（剥离与运行无关的代码）
- 在服务器端压缩JavaScript文件（Gzip）
- 设置HTTP响应头来缓存JavaScript文件（协商缓存、强制缓存）
- 使用CDN（内容分发网络）提供JavaScript文件

## 前端性能指南

### 减少HTTP请求

- 图片

	- 图片地图（合并图片，一张图片上关联多个url，目标url取决于用户点击图片位置，常见于导航栏）
	- CSS Sprites（合并图片，然后使用background-position将HTML元素放到背景图片中期望的位置）
	- 内联图片（data:URL，有大小限制且比转化后比占据空间比原图大1/3，内联在页面时不会被缓存，但可缓存在样式表内部）

- 合并脚本和样式表

	- 多个脚本合并为1个脚本，多个样式表合并为1个样式表

### 使用内容分发网络（CDN）

- CDN是一组分布在多个不同地理位置的Web服务器
- 就近访问、全局负载均衡流量
- 其目的是通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络"边缘"，使用户可以就近取得所需的内容，解决Internet网络拥塞状况，提高用户访问网站的响应速度。

### 使用浏览器缓存(Cache-Control/Expires)

### 压缩

- Accept-Encoding: gzip, deflate
- 考虑代理缓存及浏览器压缩支持

### 将样式表放置顶部

- 在样式表还在加载中时，浏览器不会构建呈现树。（详情见页面构建流程）

### 将脚本放在底部

- HTTP1.1规范建议一个主机名只能并行下载2个资源（除脚本），所以将资源分布到多个主机名（建议2个，更多的并行下载会消耗更多的CPU、网络）。
- 脚本可能会使用document.write等方法修改页面内容，所以浏览器会等待，确保页面能够适当的布局。

### 避免CSS表达式

### 使用外部JavaScript和CSS

- 外部JavaScript和CSS可以被浏览器缓存
- 左右因素：页面浏览量、空缓存vs完整缓存、组件重用
- 加载后下载：页面加载后，通过创建对应的DOM元素并赋予指定的URL来实现
- 动态内联：通过cookie来反馈浏览器中的缓存给服务端，供其智能匹配内联/外部

### 通过使用Keep-Alive和较少的域名来减少DNS查询

### 精简JavaScript代码（删除空白字符、注释）、混淆JavaScript代码（除此之外会修改原代码）

### 避免重定向（redirect会阻塞所有请求）

### 去除重复的JavaScript脚本

## 只有10%～20%的最终用户响应时间花在接受所请求的HTML文档上，剩余80%～90%的时间花在为HTML文档所引用的所有组件（图片、脚本、样式表、Flash等）

