# 算法

## 什么是时间复杂度

### （1）语句频度

- 算法就是你解决问题的方法，而你用这个方法解决这个问题所执行的语句次数，称为语句频度或者时间频度，记为T(n)。
- 在上面提到的时间频度T(n)中，n是指算法的规模，n不断的变化，T(n)就会不断的变化，而这些变化的规律是怎样的呢？于是我们引入了时间复杂度的概念。

### （2）时间复杂度

- 算法中某个函数有n次基本操作重复执行，用T(n)表示，现在有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。通俗一点讲，其实所谓的时间复杂度，就是找了一个同样曲线类型的函数f(n)来表示这个算法的在n不断变大时的趋势 。当输入量n逐渐加大时，时间复杂性的极限情形称为算法的“渐近时间复杂性”。 

### （3）大O记法

- 在这种描述中使用的基本参数是 n，即问题实例的规模，把复杂性或运行时间表达为n的函数。这里的“O”表示量级 (order)，比如说“二分检索是 O(logn)的”,也就是说它需要“通过logn量级的步骤去检索一个规模为n的数组”记法 O ( f(n) )表示当 n增大时，运行时间至多将以正比于 f(n)的速度增长。 

### （4）简单算法的时间复杂度举例

- O(1)的算法是一些运算次数为常数的算法。

	- 例如：temp=a;a=b;b=temp;
	- 上面语句共三条操作，单条操作的频度为1，即使他有成千上万条操作，也只是个较大常数，这一类的时间复杂度为O(1)。

- O(n)的算法是一些线性算法。

	- sum=0；                 
for(i=0;i<n;i++)       
sum++；
	- 上面代码中第一行频度1，第二行频度为n，第三行频度为n，所以f(n)=n+n+1=2n+1。所以时间复杂度O(n)。这一类算法中操作次数和n正比线性增长。

- O(logn) 一个算法如果能在每个步骤去掉一半数据元素，如二分检索，通常它就取 O(logn)时间。

	- int i=1; 
while (i<=n) 
i=i*2; 
	- 上面代码设第三行的频度是f(n),   则：2的f(n)次方<=n;f(n)<=log₂n，取最大值f(n)= log₂n，所以T(n)=O(log₂n ) 。

- O(n²)（n的k次方的情况）最常见的就是平时的对数组进行排序的各种简单算法都是O(n²)，例如直接插入排序的算法。而像矩阵相乘算法运算则是O(n³)。

	- sum=0；                
for(i=0;i<n;i++)  
  for(j=0;j<n;j++) 
    sum++；
	- 第一行频度1，第二行n，第三行n²，第四行n²，T(n)=2n²+n+1 =O(n²)

- O(2的n次方) 比如求具有n个元素集合的所有子集的算法 
- O(n!) 比如求具有N个元素的全排列的算法

### （5）时间复杂度按n越大算法越复杂来排

- 常数阶O(1)、对数阶O(logn)、线性阶O(n)、线性对数阶O(nlogn)、平方阶O(n²)、立方阶O(n³)、……k次方阶O(n的k次方)、指数阶O(2的n次方)。

### （6）最坏情况的时间和期望时间

- 比如说快速排序，最坏情况运行时间是 O(n²)，但期望时间是O(nlogn)。但是我们只要通过一些手段，可以避免最坏情况发生，所以在实际情况中，精心设计的快速排序都能以期望时间运行。

## 【栈，队列，链表】用JavaScript实现

### 栈

- 栈的特点是只能在某一端添加或删除数据，遵循先进后出的原则
- 实现

### 队列

- 队列一个线性结构，特点是在某一端添加数据，在另一端删除数据，遵循先进先出的原则。
- 实现

	- 单链队列

	- 循环队列

		- 因为单链队列在出队操作的时候需要 O(n) 的时间复杂度，所以引入了循环队列。循环队列的出队操作平均是 O(1) 的时间复杂度。
### 链表

- 头节点

- 插入节点

- 删除节点

- 链表的设计（简易版）

	- 单向链表

		- 我们设计链表包含两个类，一个是 Node 类用来表示节点，另一个事 LinkedList 类提供插入节点、删除节点等一些操作。
		- Node类

			- Node类包含两个属性： element 用来保存节点上的数据，next 用来保存指向下一个节点的链接
		- LinkedList类

			- LinkedList类提供了对链表进行操作的方法，包括插入删除节点，查找给定的值等。值得注意的是，它只有一个 属性，那就是使用一个 Node 对象来保存该链表的头节点。
		- 具体方法的实现

			- find：查找给定节点

			- insert：向链表插入一个节点

			- display：显示链表

			- remove：从链表中删除一个节点

				- 从链表中删除节点时，我们先要找个待删除节点的前一个节点，找到后，我们修改它的 next 属性，使其不在指向待删除的节点，而是待删除节点的下一个节点。那么，我们就得需要定义一个 findPrevious 方法遍历链表，检查每一个节点的下一个节点是否存储待删除的数据。如果找到，返回该节点，这样就可以修改它的 next 属性了。 
	- 双向链表

	- 循环链表

		- 循环链表和单链表相似，节点类型都是一样，唯一的区别是，在创建循环链表的时候，让其头节点的 next 属性执行它本身，即，head.next = head;
		- 这种行为会导致链表中每个节点的 next 属性都指向链表的头节点，换句话说，也就是链表的尾节点指向了头节点，形成了一个循环链表
## 【排序算法】优雅的 JAVASCRIPT 排序算法（ES6）

### 总结

- 名词解释

	- n: 数据规模
	- k:“桶”的个数
	- In-place: 占用常数内存，不占用额外内存
	- Out-place: 占用额外内存
	- 稳定性：排序后2个相等键值的顺序和排序之前它们的顺序相同

		- 1、堆排序、快速排序、希尔排序、直接选择排序不是稳定的排序算法；
		- 2、基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法。
		- 稳定排序在给定相同输入时具有确定性输出，这对于调试和测试可能很重要。

### 冒泡排序（Bubble Sort）

- 须知

	- 还有一种优化算法，就是立一个flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。

- 工作原理

	- （1）比较相邻的元素。如果第一个比第二个大，就交换他们两个。
	- （2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
	- （3）针对所有的元素重复以上的步骤，除了最后一个。
	- （4）持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

- 什么时候最快（Best Cases）：

	- 当输入的数据已经是正序时

- 什么时候最慢（Worst Cases）：

	- 当输入的数据是反序时

- JavaScript代码

### 选择排序（Selection Sort）

- 须知

	- 在时间复杂度上表现最稳定的排序算法之一，因为无论什么数据进去都是O(n²)的时间复杂度。。。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。

- 工作原理

	- 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

- JavaScript代码

### 插入排序（Insertion Sort）

- 须知

	- 插入排序的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。
	- 插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。

- 工作原理

	- （1）从第一个元素开始，该元素可以认为已经被排序
	- （2）取出下一个元素，在已经排序的元素序列中从后向前扫描
	- （3）如果该元素（已排序）大于新元素，将该元素移到下一位置
	- （4）重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
	- （5）将新元素插入到该位置后
	- （6）重复步骤2~5

- JavaScript代码

### 快速排序（Quick Sort）

- 须知

	- 又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。

- 原理

	- （1）在数据集之中，选择一个元素作为"基准"（pivot）。
	- （2）所有小于"基准"的元素，都移到"基准"的左边；所有大于"基准"的元素，都移到"基准"的右边。
	- （3）对"基准"左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。
	- 理解此版本的核心函数（分区并返回基准下标的函数）

		- 即除首项（left先做基准值）后面的所有项依次与首项基准值作比较，注意如果不大于基准值的话，i会持续增加，而index不会，所以找到比基准值小的项时，就让它的位置i与之前记录的index（此时index为最早发现的大于基准值的下标）交换，以此操作遍历完数组，最后在将，基准值与大小区分界的小数交换，即可完成分区

- JavaScript代码

*XMind: ZEN - Trial Version*