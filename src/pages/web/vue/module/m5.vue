<template>
    <div>
    <h2>vue-router</h2>
<h3>基础</h3>
<ul>
<li><p>Vue.router基础</p>
<ul>
<li><p>开始</p>
<ul>
<li><p>作用：创建单页应用</p>
</li>
<li><p>例子</p>
<ul>
<li>实例1（简单）</li>
<li>实例2（复杂但有说明--命名路由中的例子）</li>
</ul>
</li>
</ul>
</li>
<li><p>动态路由匹配</p>
<ul>
<li><p>基本知识</p>
<ul>
<li><p>说明</p>
<ul>
<li>动态路由以冒号开头；通过$route.params可以访问相对应的值</li>
</ul>
</li>
<li><p>例子</p>
<ul>
<li>实例</li>
</ul>
</li>
</ul>
</li>
<li><p>响应路由参数的变化</p>
<ul>
<li><p>想对路由变化（从预设的路由A切换值预设的路由B）做出反应，可采用watch</p>
</li>
<li><p>例子</p>
<ul>
<li>实例</li>
</ul>
</li>
</ul>
</li>
<li><p>高级匹配模式</p>
</li>
<li><p>匹配优先级</p>
<ul>
<li>有时一个路径会有多个路由，这时以最先定义的路由优先级最高的原则来处理</li>
</ul>
</li>
</ul>
</li>
<li><p>嵌套路由</p>
<ul>
<li><p>例子</p>
<ul>
<li>实例</li>
</ul>
</li>
</ul>
</li>
<li><p>编程式导航</p>
<ul>
<li>router.push(location)</li>
<li>router.replace(location)</li>
<li>router.go(n)</li>
</ul>
</li>
<li><p>命名路由</p>
<ul>
<li><p>注意事项</p>
<ul>
<li>1、需要命名（to及routes里都要有name属性）</li>
<li>2、router-link 里的to 需要加v-bind</li>
</ul>
</li>
<li><p>例子</p>
<ul>
<li>实例</li>
</ul>
</li>
</ul>
</li>
<li><p>命名视图</p>
<ul>
<li><p>作用</p>
<ul>
<li>可以在界面中拥有多个单独命名的视图router-view ,而不是只有一个单独的出口</li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li>1、如果router-view没有设置名字，那么默认为default</li>
<li>2、此时的component应该为复数即components</li>
</ul>
</li>
<li><p>例子</p>
<ul>
<li>实例</li>
</ul>
</li>
</ul>
</li>
<li><p>重定向和别名</p>
<ul>
<li><p>重定向</p>
<ul>
<li><p>类型</p>
<ul>
<li><p>参数为单纯的一个链接</p>
<ul>
<li>实例</li>
</ul>
</li>
<li><p>参数为一个命名的路由</p>
</li>
<li><p>参数为一个方法</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>别名</p>
<ul>
<li><p>例子</p>
<ul>
<li>实例</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>HTML5 History模式</p>
<ul>
<li><p>好处</p>
<ul>
<li>vue-router默认使用的是hash模式，如果不想觉得hash模式（#）丑陋可以使用history模式；</li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li><p>需要后台配置支持，否则可能会返回404了</p>
<ul>
<li><p>后台配置例子</p>
<ul>
<li>实例</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>用法举例</p>
<ul>
<li>实例</li>
</ul>
</li>
<li><p>其它建议</p>
<ul>
<li><p>为了不让服务器给出404错误，可以给个警告。</p>
<ul>
<li><p>非node.js后台</p>
<ul>
<li>实例</li>
</ul>
</li>
<li><p>node.js后台</p>
<ul>
<li>可以在后台匹配路由，没匹配到时给出404，从而实现fallback</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>进阶</h3>
<ul>
<li><p>导航钩子</p>
<ul>
<li><p>作用</p>
<ul>
<li>用来拦截导航，让它完成跳转或取消</li>
</ul>
</li>
<li><p>执行钩子的方式</p>
<ul>
<li><p>全局钩子（beforeEach）</p>
<ul>
<li><p>使用方法</p>
<ul>
<li>说明</li>
</ul>
</li>
<li><p>例子</p>
<ul>
<li>实例--代码</li>
<li>实例--运行结果</li>
</ul>
</li>
</ul>
</li>
<li><p>某个路由独享的钩子（beforeEnter）</p>
<ul>
<li><p>与全局before钩子的方法参数一样</p>
</li>
<li><p>使用方法</p>
<ul>
<li><p>官网简介</p>
</li>
<li><p>例子</p>
<ul>
<li>实例</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>组件内的钩子（beforeRouteEnter/Update/Leave）</p>
<ul>
<li><p>使用方法</p>
<ul>
<li>官网例子</li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li>使用beforeRouteEnter无法访问组件实例this；不过可以通过传一个回调给next来访问组件实例</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
    </div>
</template>
<script>
    export default {
    }
</script>
<style lang="scss" scoped>
</style>