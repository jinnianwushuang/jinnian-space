# http

## Web 及网络协议基础

### 网络基础TCP/IP

- 通常使用的网络是在TCP/IP协议族的基础上运作的，HTTP属于他内部的一个子集
- 把与互联网相关联的协议集合起来总称为 TCP/IP
- TCP/IP 协议族按层次分别分为以下 4 层:应用层、传输层、网络层和数据链路层
- 发送端在层与层之间传输数据时,每经过一层时必定会被打上一个该层所属的首部信息。
反之,接收端在层 与层传输数据时,每经过一层时会把对应的首部消去

### 与 HTTP 关系密切的协议：IP、TCP和DNS

- IP 协议的作用是把各种数据包传送给对方
- IP 地址指明了节点被分配到的地址,MAC 地址是指网卡所属的固定地址。
- 在进行中转时,会利用下一站中转设备的 MAC 地址来搜索下一 个中转目标。这时,会采用 ARP 协议
- 无论哪台计算机、哪台网络设备,它们都无法全面掌握互联网中的细节
- 按层次分,TCP 位于传输层,提供可靠的字节流服务。
- 将大块数据分割成以报文段为单位的数据包进行管理
- TCP 协 议为了更容易传送大数据才把数据分割
- TCP 协议采用了三次握手(three-way handshaking)策略

	-  若在握手过程中某个阶段莫名中断，TCP 协议
会再次以相同的顺序发送相同的数据包

- DNS 协议提供通过域名查找 IP 地址,或逆向从 IP 地址反查域名 的服务

### URL 和 URL

- URL 正是使用 Web 浏览器等访问 Web 页面时需要输入的网页地址
- URI 就是由某个协议方案表示的资源的定位标识符

## 构建 Web 内容的技术

### HTML

- HTML5 标准不仅解决了浏览器之间的兼容性问题,并且可把文本作为数据对待,更容易复用,动画等效果也 变得更生动。
- CSS(Cascading Style Sheets,层叠样式表)可以指定如何展现 HTML 内的各种元素,属于样式表标准之一
- 所谓动态 HTML(Dynamic HTML),是指使用客户端脚本语言将静态的 HTML 内容变成动态的技术的总 称。
- DOM 是用以操作 HTML 文档和 XML 文档的 API(

### Web 应用

- Web 应用是指通过 Web 功能提供的应用程序
- CGI(Common Gateway Interface,通用网关接口)是指 Web 服务器在接收到客户端发送过来的请求后转发 给程序的一组机制
- 随着 CGI 的普及,每次请求都要启动新 CGI 程序的 CGI 运行机制逐渐变成了性能瓶颈,
所以之后 Servlet 和 mod_perl 等可直接在 Web 服务器上运行的程序才得以开发、普及

### 数据发布的格式及语言

- XML(eXtensible Markup Language,可扩展标记语言)是一种可按应用目标进行扩展的通用标记语言
- RSS(简易信息聚合,也叫聚合内容)和 Atom 都是发布新闻或博客日志等更新信息文档的格式的总称
- JSON(JavaScript Object Notation)是一种以 JavaScript(ECMAScript)的对象表示法为基础的轻量级数据 标记语言

## 基于 HTTP 的功能追加协议

### 消除HTTP 瓶颈的 SPDY

- 其开发目标旨在解决 HTTP 的性能瓶颈,缩短 Web 页面的加载时间(50%)
- 一条连接上只可发送一个请求。
-  请求只能从客户端开始。 客户端不可以接收除响应以外的指令。
-  请求 / 响应首部未经压缩就发送。 首部信息越多延迟越大。
-  发送冗长的首部。 每次互相发送相同的首部造成的浪费较多。
-  可任意选择数据压缩格式。 非强制压缩发送。
- SPDY 没有完全改写 HTTP 协议,而是在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作
- 多路复用流

	- 通过单一的 TCP 连接,可以无限制处理多个 HTTP 请求

- 赋予请求优先级

	- SPDY 不仅可以无限制地并发处理请求,还可以给请求逐个分配优先级顺序

- 压缩 HTTP 首部

	- 压缩 HTTP 请求和响应的首部

- 推送功能

	- 支持服务器主动向客户端推送数据的功能

- 服务器提示功能

	- 服务器可以主动提示客户端请求所需的资源

- SPDY 的确是一种可有效消除 HTTP 瓶颈的技术,但很多 Web 网站存在的问题并非仅仅是由 HTTP 瓶颈所 导致

### 使用浏览器进行全双工通信的WebSocket

- 一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接,之后所有的通信都依靠这个专用协议进 行。
- 连接的发起方仍是客户端,而一旦确立 WebSocket 通信连接,不 论服务器还是客户端,任意一方都可直接向对方发送报文
- 支持由服务器向客户端推送数据的推送功能。
- 和 HTTP 相比,不但每次连接时的总开销减少, 而且由于 WebSocket 的首部信息很小,通信量也相应减少了

### 期盼已久的HTTP/2.0

- HTTP/2.0 的目标是改善用户在使用 Web 时的速度体验。

### Web 服务器管理文件的 WebDAV

- 一 个可对 Web 服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统

## HTTP 报文内的 HTTP信息

### HTTP 报文

- 用于 HTTP 协议交互的信息被称为 HTTP 报文
- HTTP 报文大致可分为报文首部和报文主体两块

### 报文结构

- 请求行
- 状态行
- 首部字段
- 其他

### 编码提升传输速率

- 通过在传 输时编码,能有效地处理大量的访问请求。但是,编码的操作需要计算机来完成,因此会消耗更多的 CPU 等 资源
- 报文

	- 是 HTTP 通信中的基本单位,由 8 位组字节流(octet sequence,其中 octet 为 8 个比特)组成,通过 HTTP 通信传输

- 实体

	- 作为请求或响应的有效载荷数据(补充项)被传输,其内容由实体首部和实体主体组成

- 向待发送邮件内增加附件时,为了使邮件容量变小,我们会先用 ZIP 压缩文件之后再添加附件发送
- 常用的内容编码有以下几种

	- gzip( GNU zip)
	- compress( UNIX 系统的标准压缩)
	- deflate ( zlib)
	- identity(不进行编码)

- 在 HTTP 通信过程中,请求的编码实体资源尚未全部传输完成之前,浏览器无法显示请求页面。

### 发送多种数据的多部分对象集合

- 在 MIME 扩展中会使用一种称为多部分对象集合(Multipart)的方法,来容纳多份不同类型的数据
- 多部分对象集合包含的对象

	- multipart/form-data
	- multipart/byteranges
	- multipart/form-data
	- multipart/byteranges

- 在 HTTP 报文中使用多部分对象集合时,需要在首部字段里加上 Content-type

### 获取部分内容的范围请求

- 执行范围请求时,会用到首部字段 Range 来指定资源的 byte 范围。

### 内容协商返回最合适的内容

- 当浏览器的默认语言为英语或中文,访问相同 URI 的 Web 页面时,则会显示对应的英语版或中文版的 Web 页面。这样的机制称为内容协商(
- 内容协商机制是指客户端和服务器端就响应的资源内容进行交涉,然后提供给客户端最为适合的资源
- 由服务器端进行内容协商。以请求的首部字段为参考,在服务器端自动处理
- 由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择
- 是服务器驱动和客户端驱动的结合体,是由服务器端和客户端各自进行内容协商的一种方法
- Accept Accept-Charset Accept-Encoding Accept-Language Content-Language

## 与 HTTP 协作的 Web 服务器

### 用单台虚拟主机实现多个域名

- HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点

### 通信数据转发程序 :代理、网关、隧道

- 代理

	- 代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器
	- 缓存代理
	- 透明代理

- 网关

	- 利用网关可以由 HTTP 请求转化为其他协议通信

- 隧道

	- 隧道的目的是确保 客户端能与服务器进行安全的通信

### 保存资源的缓存

- 代理服务器

	- 缓存是指代理服务器或客户端本地磁盘内保存的资源副本

- 缓存的有效期限

	- 即使存在缓存,也会因为客户端的要求、缓存的有效期等因素,向源服务器确认资源的有效性

- 客户端的缓存

	- 浏览器缓存如果有效,就不必再向服务器请求相同的资源了,可以直接从本地磁盘内读取

## HTTP 头部

###   HTTP 报文的结构

- 在请求中,HTTP 报文由方法、URI、HTTP 版本、HTTP 首部字段等部分构成。
- 在响应中,HTTP 报文由 HTTP 版本、状态码(数字和原因短语)、HTTP 首部字段 3 部分构成

### HTTP 首部字段

- HTTP 首部字段是由首部字段名和字段值构成的,中间用冒号“:” 分隔。
- 字段值对应单个 HTTP 首部字段可以有多个值
- 4 种 HTTP 首部字段类型

	- 通用首部字段( General Header Fields)
	- 请求首部字段( Request Header Fields)
	- 响应首部字段( Response Header Fields)
	- 实体首部字段( Entity Header Fields)

### HTTP/1.1 首部字段一览

- Cache-Control

	- 控制缓存行为

- Connection

	- 逐跳首部、连接的管理

- Date

	- 创建报文的日期时间

- Pragma

	- 报文指令

- Trailer

	- 报文末端的首部一览

- Transfer-Encoding

	- 指定报文主体的传输编码方式

- Upgrade

	- 升级为其他协议

- Via

	- 代理服务器的相关信息

- Warning

	- 错误通知

- Accept

	- 用户代理可处理的媒体类型

- Accept-Charset

	- 优先的字符集

- Accept-Encoding

	- 优先的内容编码

- Accept-Language

	- 优先的语言(自然语言)

- Authorization

	- Web认证信息

- Expect

	- 期待服务器的特定行为

- From

	- 用户的电子邮箱地址

- Host

	- 请求资源所在服务器

- If-Match

	- 比较实体标记(ETag)

- If-Modified-Since

	- 比较资源的更新时间

- If-None-Match

	- 比较实体标记(与 If-Match 相反)

- If-Range

	- 资源未更新时发送实体 Byte 的范围请求

- If-Unmodified-Since

	- 比较资源的更新时间(与If-Modified-Since相反)

- Max-Forwards

	- 最大传输逐跳数

- Proxy-Authorization

	- 代理服务器要求客户端的认证信息

- Range

	- 实体的字节范围请求

- Referer

	- 对请求中 URI 的原始获取方

- TE

	- 传输编码的优先级

- User-Agent

	- HTTP 客户端程序的信息

- Accept-Ranges

	- 是否接受字节范围请求

- Age

	- 推算资源创建经过时间

- ETag

	- 资源的匹配信息

- Location

	- 令客户端重定向至指定URI

- Proxy-Authenticate

	- 代理服务器对客户端的认证信息

- Retry-After

	- 对再次发起请求的时机要求

- Server

	- HTTP服务器的安装信息

- Vary

	- 代理服务器缓存的管理信息

- WWW-Authenticate

	- 服务器对客户端的认证信息

- Allow

	- 资源可支持的HTTP方法

- Content-Encoding

	- 实体主体适用的编码方式

- Content-Language

	- 实体主体的自然语言

- Content-Length

	- 实体主体的大小(单位:字节)

- Content-Location

	- 替代对应资源的URI

- Content-MD5

	- 实体主体的报文摘要

- Content-Range

	- 实体主体的位置范围

- Content-Type

	- 实体主体的媒体类型

- Expires

	- 实体主体过期的日期时间

- Last-Modified

	- 资源的最后修改日期时间

- 还有 Cookie、 Set-Cookie 和 Content-Disposition 等在其他 RFC 中定义的首部字段,它们的使用频率也很高

### End-to-end 首部和 Hop-by-hop 首部

- 端到端首部( End-to-end Header)
- 逐跳首部( Hop-by-hop Header)

## 确保 Web 安全的 HTTPS

### HTTP 的缺点

- 通信使用明文(不加密), 内容可能会被窃听
- 不验证通信方的身份, 因此有可能遭遇伪装
- 无法证明报文的完整性, 所以有可能已遭篡改

### HTTP+ 加密 + 认证 + 完整性保护 =HTTPS

- 我们把添加了加密及认证机制 的 HTTP 称为 HTTPS
- 只是 HTTP 通信接口部分用 SSL(Secure Socket Layer)和TLS(Transport Layer Security)协议代替而已
- SSL 是独立于 HTTP 的协议,所以不光是 HTTP 协议,其他运行在应用层的 SMTP 和 Telnet 等协议均可配 合 SSL 协议使用
- SSL 采用一种叫做公开密钥加密(Public-key cryptography)的加密处理方式
- 加密和解密都会用到密钥。没有密钥就无法对密码解密,反过来说,任何人只要持有密钥就能解密了
- 加密和解密同用一个密钥的方式称为共享密钥加密(Common key crypto system),也被叫做对称密钥 加密
- 公开密钥加密使用一对非对称的密钥。一把叫做私有密钥(private key),另一把叫做公开密钥(public key)
- HTTPS 采用混合加密机制
- 数字证书认证机构(CA,Certificate Authority)和其相关机关颁发的公开密 钥证书

## 返回结果的 HTTP 状态码

### 状态码的职责

- 当客户端向服务器端发送请求时,描述返回的请求结果

### 状态码的大致分类

- 1XX

	- 信息性状态码

		- 接收的请求正在处理

- 2XX

	- 成功状态码

		- 请求正常处理完毕

- 3XX

	- 重定向状态码

		- 需要进行附加操作以完成请求

- 4XX

	- 客户端错误状态码

		- 服务器无法处理请求

- 5XX

	- 服务器错误状态码

		- 服务器处理请求出错

### 2XX 成功

- 200 OK

	- 表示从客户端发来的请求在服务器端被正常处理了

- 204 No Content

	- 该状态码代表服务器接收的请求已成功处理,但在返回的响应报文中不含实体的主体部分

- 206 Partial Content

	- 该状态码表示客户端进行了范围请求,而服务器成功执行了这部分的 GET 请求

### 3XX 重定向

- 301 Moved Permanently

	- 永久性重定向。该状态码表示请求的资源已被分配了新的 URI,以后应使用资源现在所指的 URI。

- 302 Found

	- 临时性重定向。该状态码表示请求的资源已被分配了新的 URI,希望用户(本次)能使用新的 URI 访问

- 303 See Other

	- 该状态码表示由于请求对应的资源存在着另一个 URI,应使用 GET 方法定向获取请求的资源
	- 303 状态码和 302 Found 状态码有着相同的功能,但 303 状态码明确表示客户端应当采用 GET 方法获取资 源

- 304 Not Modified

	- 该状态码表示客户端发送附带条件的请求 2 时,服务器端允许请求访问资源,但未满足条件的情况

- 307 Temporary Redirect

	- 临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET

### 4XX 客户端错误

- 400 Bad Request

	- 该状态码表示请求报文中存在语法错误

- 401 Unauthorized

	- 该状态码表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息

- 403 Forbidden

	- 该状态码表明对请求资源的访问被服务器拒绝了

- 404 Not Found

	- 该状态码表明服务器上无法找到请求的资源

### 5XX 服务器错误

- 500 Internal Server Error

	- 该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障

- 503 Service Unavailable

	- 该状态码表明服务器暂时处于超负载或正在进行停机维护,现在无法处理请求

## 确认访问用户身份的认证

### 何为认证

- 密码:只有本人才会知道的字符串信息。
- 动态令牌:仅限本人持有的设备内显示的一次性密码
- 数字证书:仅限本人(终端)持有的信息
- 生物认证:指纹和虹膜等本人的生理信息。
- IC 卡等:仅限本人持有的信息
- BASIC 认证(基本认证)
- DIGEST 认证(摘要认证)
- SSL 客户端认证
- FormBase 认证(基于表单认证)

### BASIC 认证

- BASIC 认证(基本认证)是从 HTTP/1.0 就定义的认证方式。
- BASIC 认证使用上不够便捷灵活,且达不到多数 Web 网站期望的安全性等级,因此它并不常用。
- 步骤 1: 当请求的资源需要 BASIC 认证时,服务器会随状态码 401 Authorization Required,返回带 WWW-Authenticate 首部字段的响应
- 步骤 2: 接收到状态码 401 的客户端为了通过 BASIC 认证,需要将用户 ID 及密码发送给服务器
- 步骤3：接收到包含首部字段 Authorization 请求的服务器,会对认证信息的正确性进行验证

### DIGEST 认证

- DIGEST 认证同样使用质询 / 响应的 方式(challenge/response),但不会像 BASIC 认证那样直接发送明文密码。
- 步骤 1: 请求需认证的资源时,服务器会随着状态码 401 Authorization Required,返 回带 WWW-Authenticate 首部字段的响应
- 步骤 2: 接收到 401 状态码的客户端,返回的响应中包含 DIGEST 认证必须的首部字段 Authorization 信 息。
- 步骤 3: 接收到包含首部字段 Authorization 请求的服务器,会确认认证信息的正确性。

### SSL 客户端认证

- SSL 客户端认证是借由 HTTPS 的客户端证书完成认证的方式。
- 步骤 1: 接收到需要认证资源的请求,服务器会发送 Certificate Request 报文,要求客户端提供客户端证 书。
- 步骤 2: 用户选择将发送的客户端证书后,客户端会把客户端证书信息以 Client Certificate 报文方式发送给 服务器。
- 步骤 3: 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥,然后开始 HTTPS 加密通 信。

###  基于表单认证

- 认证多半为基于表单认证
- 基于表单认证的标准规范尚未有定论,一般会使用 Cookie 来管理 Session(会话)
- 步骤 1: 客户端把用户 ID 和密码等登录信息放入报文的实体部分,通常是以 POST 方法把请求发送给服务 器。
- 步骤 2: 服务器会发放用以识别用户的 Session ID。会在首部字段 Set-Cookie 内写入 Session ID
- 步骤 3: 客户端接收到从服务器端发来的 Session ID 后,会将其作为 Cookie 保存在本地

## TCP/IP协议族

### 是互联网相关的各类协议族的总称

- 协议就是计算机与网络设备之间互相同通信的规则
- http属于他内部的一个子集

### 通信传输流

- 发送端从应用层往下走，接收端从链路层往上走
- 发送端在层与层之间传输数据时，每经过一层必定会被打上一个该层所属的首部信息
- 接收端在层与层之间传输数据时，每经过一层会把对应的首部去掉
- 这种数据信息包装的做法称为封装

### 负责传输的IP协议

- 把各种数据包传送给对方（两个重要的条件）

	- IP地址（节点被分配的地址）
	- MAC地址（网卡所属的固定地址）

### 确保可靠性的TCP协议

- 提供可靠的字节流服务，把数据准确可靠的传给对方
- 为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理（为了传输大的数据）
- 三次握手

	- 客户端发送SYN给服务端，（同步请求）
	- 服务端发送SYN/ACK（同步请求和确认）
	- 客户端发送ACK（确认）
	- 若在某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包

### DNS域名解析服务

- 通过域名查找IP地址或逆向从IP查找域名的服务

### URI与URL

- URI统一资源标识符，标识资源
- URL统一资源定位符、是URI的子集，标识资源地址

###  分层管理

- 链路层

	- 用来处理网络连接的硬件部分

- 传输层

	- 为应用层提供网络连接中的两台计算机之间的数据传输
	- TCP传输控制协议
	- UDP用户数据报协议
	- 将应用层的数据进行分割，并在各个报文打上标记序号及端口号后发给网络层

- 网络层

	- 处理在网络上流动的数据包，数据包是网路传输协议的最小数据单位，规定通过怎么的路径到达目的地。
	- 增加作为通信目的地的MAC地址后转发给链路层

- 应用层

	- 决定了向用户提供的应用服务时通信的活动
	- FTP文件传输协议
	- DNS域名系统

- 分层次的好处

	- 应变不同需求

		- 当需求不同的时候不需要改变所有整体、只需要修改相应的层次就行了。

	- 分工明确

		- 只需要考虑分配给自己的任务

## 简单HTTP协议

### 客户端与服务端通讯

- 在两台计算机之间使用 HTTP 协议通信时,在一条通信线路上必定有一端是客户端,另一端则是服务器端
- 请求必定由客户端发出, 而服务器端回复响应
- 请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的
- 响应报文基本上由协议版本、状态码(表示请求成功或失败的数字代码)、用以解释状态码的原因短语、可 选的响应首部字段以及实体主体构成

### 请求报文的构成

- 方法/URI/协议版本
- 请求首部字段
- 内容实体

### HTTP是不保存状态的协议

- 协议自身不具备保存之前发送过的请求或相应的功能
- HTTP/1.1虽然无状态协议，但是引入Cookies之后可以管理状态了
- 无状态的优点是可以减少服务器的CPU以及内存资源的消耗
- Cookies技术通过在请求和响应报文中写入Cookies来控制客户端的状态
- 在服务端发送的响应报文内添加Set-Cookies的首部字段信息，通知客户端保存Cookies。当下次客户端发送请求时，客户端会自动在请求报文中加入Cookies值后发送出去

### 告知服务器意图的HTTP方法

- GET：获取资源

	- 使用GET方法请求访问已被URI识别的资源

- POST：传输实体的主体

	- 虽然GET也可以但是一般不使用GET，POST的主要目的不是获取响应的主体内容

- PUT：传输文件

	- 像FTP协议的文件上传一样，要求在请求的报文 主体中包含文件内容，然后保存到请求URI指定的位置，

- HEAD：获取报文首部

	- 用于确认URI的有效性和资源更新的日期时间等
	- 和GET一样但是不返回报文主体

- DELETE删除文件

	- 请求删除URI指定的资源

- OPTIONS：询问支持的方法

	- 用来查询针对请求URI指定资源支持的方法

- TRACE：追踪路径

	- 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服 务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最 后接收到请求的服务器端则返回状态码 200 OK 的响应。 
	- 客户端通过TRACE方法查询发送出去的请求是怎么样被加工修改的。
	- 请求想要连接到源目标服务器可能会通过代理中转，TRACES方法就是用来确认连接过程中发生的一系列操作
	- 容易引发XST扩展追踪攻击

- CONNECT：要求用隧道协议连接代理

	- 要求与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信
	- 主要使用SSL安全套接层和TLS传输安全协议把通信内容加密后经网络隧道传输
	- CONNECT 代理服务器名：端口号 HTTP版本

### 持久连接节省通信量

- HTTP/1.1新增keep-alive方法
- 特点：只要任意一端没有明确提出断开连接，则保持TCP连接状态
- HTTP 协议的初始版本中,每进行一次 HTTP 通信就要断开一次 TCP 连接
- 持久连接的特点是,只要任意 一端没有明确提出断开连接,则保持 TCP 连接状态
- 持久连接使得多数请求以管线化(pipelining)方式发送成为可能
- 减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务端的负载
- HTTP/1.1中所有的连接默认都是持久连接

### 使用 Cookie 的状态管理

- HTTP 是无状态协议,它不对之前发生过的请求和响应的状态进行管理
- Cookie 技术通过在请 求和响应报文中写入 Cookie 信息来控制客户端的状态
- Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息,通知客户端保存 Cookie
- 当下次客户端再往该服务器发送请求时,客户端会自动在请求报文中加入 Cookie 值后发送出去

### 管线化

- 持久连接使得多数请求以管线化方式发送成为可能
- 能够做到同时并行发送多个请求，不需要一个接一个地等待响应了

## WebSocket与HTTP

### 相同点

- 基于TCP的可靠传输
- 都是应用层协议

### 不同点

- WebSocket

	- 双向通信协议，模拟Socket协议
	- 可以双向发送或接受信息

- HTTP

	- 单向发送信息或接受信息
	- 浏览器向服务器发起连接
	- 服务器预先不知道这个连接

### 联系

- web Socket建立握手时，数据是通过HTTP传输的
- 建立之后不需要HTTP协议

### Socket

- 应用层与TCP/IP协议族通信的中间软件抽象层
- 它是一组接口，提供一套调用TCP/IP协议的API
- Socket是传输控制层接口，WebSocket是应用层协议。

## DNS原理

### 递归查询

- 客户端问本地DNS服务器
- 本地DNS服务器问根域名服务器
- 根域名服务器问顶级域名服务器
- 顶级域名服务器问主域名服务器

### 迭代查询

- 客户端询问本地DNS服务器
- 客户端问根域名服务器
- 客户端问顶级域名服务器
- 客户端问主域名服务器

### 域名系统

- DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议

	- 区域传送时使用TCP

		- 辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动
		- 如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。

	- 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可

### 查找顺序

- 浏览器缓存

	- 根据本地DNS服务器的设置，采用递归或者迭代查询，直至解析完成。

- 系统缓存

	- 检查自己本地的hosts文件是否有这个网址映射关系

-  路由器缓存

	- 进入路由器缓存中检查

- 本地DNS解析器缓存，是否有这个网址映射关系
- 根据本地DNS服务器的设置，采用递归或者迭代查询，直至解析完成。

## http/http2

### http1.x缺点

- 对同一个域名的并发连接最多只能2个，而平均一个页面有40个资源
- 线头阻塞，同一个连接请求，需要一个接一个串行发送和接受
- 请求和响应的头部信息大，无法压缩
- 不能控制响应的优先级
- 只能单项请求

### http2

- 传输内容使用二进制协议，在应用层和传输层之间增加了二进制分帧层
- 使用帧作为最小传输单位

	- 所有的帧以固定的9个八位字节头部开头，随后是一个可变长的的有效载荷

- 多路复用
- 服务器推送
- 优先级与依赖性
- 可重置

	- RST_STREAM 帧来中断

- 流量控制

## HTTP与HTTPS的区别

### HTTP

- 运行在TCP上
- 明文传输
- 端口80
- 工作在应用层

### 证书+数字签名

- 网站信息加密后通过第三方机构的私钥再次加密生成数字签名
- 数字证书=网站信息+数字签名
- 因为数字签名的存在，会导致客户端验证签名不匹配，这样就防止了中间人替换公钥的问题
- 安全拿到服务器的公钥之后，使用公钥对随机生成的对称密钥进行加密传输给服务器，此后的数据将使用对称加密的方式进行传输

### 对称加密

- 加密和解密用同一个密钥的加密方式
- 传输的密钥会被劫持

### HTTPS

- CA证书

	- 免费证书少

- SSL/TLS加密

	- 加密后运行在TCP上

- 端口443
- 防止运营商劫持
- 工作在传输层

### 非对称加密

- 私钥加密的内容，公钥可以解开
- 公钥加密的内容，只有私钥可以解开
- 私钥存在服务端，公钥发送到客户端，客户端用公钥加密
- 这样的传输方式公钥容易被中间人篡改

## 面向前端的CDN原理

### （1）为什么需要CDN

- 根本上的原因是

	- 网站需要提高访问速度，HTTP传输时延对web的访问速度的影响很大，在绝大多数情况下是起决定性作用的，这是由TCP/IP协议的一些特点决定的。物理层上的原因是光速有限、信道有限，协议上的原因有丢包、慢启动、拥塞控制等。

- 最简单的做法

	- 当然就是多设置几个服务器，让终端用户离服务器“更近”。典型的例子是各类下载网站在不同地域不同运营商设置镜像站，或者是像Google那样设置多个数据中心。
	- 问题

		- 一是多地部署时的困难
		- 二是一致性没法保障
		- 三则是管理困难、成本很高
		- 实际上，在排除多地容灾等特殊需求的情况下，对大多数公司这种做法是不太可取的。

- CDN

	- CDN是一种公共服务，他本身有很多台位于不同地域、接入不同运营商的服务器，而所谓的使用CDN实质上就是让CDN作为网站的门面，用户访问到的是CDN服务器，而不是直接访问到网站。由于CDN内部对TCP的优化、对静态资源的缓存、预取，加上用户访问CDN时，会被智能地分配到最近的节点，降低大量延迟，让访问速度可以得到很大提升。

### （2）CDN的原理

- CDN做了什么？

	- CDN做了两件事，一是让用户访问最近的节点，二是从缓存或者源站获取资源

- 访问 CDN的过程

	- 流程图

	- 1.首先访问本地的 DNS ，如果没有命中，继续递归或者迭代查找，直到命中拿到对应的 IP 地址。 

		- 这个过程中，有一个 CNAME 的过程，我们访问 CDN 资源的地址一般是 a.cloud.com 或者类似的地址，是一个公司的访问 CDN 的专用地址。但是我们用的 cdn 的服务却是第三方的，即其实资源在他们的地址上比如 tencent.cdn。这时候就需要在 dns 查询的时候，需要把我们访问 a.cloud.com的地址映射到 tencent.cdn 的地址上，然后拿着映射后的地址再去走一遍 DNS 解析，成功之后才获取到第三方提供的全局负载均衡系统的 IP。再继续走后面的流程。

	- 2.拿到对应的 IP 地址之后服务器端发送请求到目的地址。注意这里返回的不直接是 cdn 服务器的 IP 地址，而是全局负载均衡系统的 IP 地址
	- 4.全局负载均衡系统会根据客户端的 IP地址和请求的 url 和相应的区域负载均衡系统通信
	- 5.区域负载均衡系统拿着这两个东西获取距离客户端最近且有相应资源的cdn 缓存服务器的地址，返回给全局负载均衡系统 
	- 6.全局负载均衡系统返回确定的 cdn 缓存服务器的地址给客户端。
	- 7.客户端请求缓存服务器上的文件

- 通俗理解

	- 其实 CDN就是个放服务端资源的一个仓库。康师傅的泡面如果不是有家门口的小卖部，我们就得去人家的工厂门口拿。有了小卖部，我们只需要去一个卖康师傅或者有货的小卖部拿，就是这个道理。

- 回源

	- 当 CDN 缓存服务器中没有符合客户端要求的资源的时候，缓存服务器会请求上一级缓存服务器，以此类推，直到获取到。最后如果还是没有，就会回到我们自己的服务器去获取资源。 那都有哪些时候会回源呢？没有资源，资源过期，访问的资源是不缓存资源等都会导致回源。
	- 专业术语

		- 边缘节点：指距离最终用户接入具有较少的中间环节的网络节点

### （3）资源的过期如何判定？cdn 是如何更新数据的？

- 资源过期时间就是根据我们老生常谈的请求头部来判定。
- CDN更新数据分两种，主动（PUSH）和被动（PULL）。被动刚才我们已经提到过了，利用回源就可以被动在途经的 CDN 节点缓存数据。 而主动指的是，我们从服务器主动往 CDN 推送数据。

## 【HTTPS】HTTPS与HTTP的区别，以及HTTP2

### HTTP与HTTPS的区别

- （1）HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。
- （2）HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
- （3）HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
- （4）HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。

### HTTPS中的对称加密与非对称加密

- 非对称加密，XX网站生成公钥和私钥，公钥发给别人进行信息传输加密，私钥留在本地进行获取信息解码。公钥用于信息发送，私钥用于信息接收
- 对称加密与非对称加密

	- 对称加密就是加密与解密的秘钥是相同的。而非对称加密就是公钥加密的内容，必须用私钥才能解密，私钥加密的内容，必须用公钥才能解密。

- 加密图解

- 加密过程

	- （1）server生成一个公钥和私钥，把公钥发送给第三方认证机构（CA）；
	- （2）CA把公钥进行MD5加密，生成数字签名；再把数字签名用CA的私钥进行加密，生成数字证书。CA会把这个数字证书返回给server；
	- （3）server拿到数字证书之后，就把它传送给浏览器；
	- （4）浏览器会对数字证书进行验证，首先，浏览器本身会内置CA的公钥，会用这个公钥对数字证书解密，验证是否是受信任的CA生成的数字证书；
	- （5）验证成功后，浏览器会随机生成对称秘钥，用server的公钥加密这个对称秘钥，再把加密的对称秘钥传送给server；
	- （6）server收到对称秘钥，会用自己的私钥进行解密，之后，它们之间的通信就用这个对称秘钥进行加密，来维持通信。

### 谷歌2012年提出SPDY方案

- SPDY可以说是综合了HTTPS和HTTP两者有点于一体的传输协议，主要解决：
- （1）降低延迟

	- 针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。
	- 多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。

- （2）请求优先级

	- 多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。
	- SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。

- （3）header压缩

	- HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。

- （4）基于HTTPS的加密协议传输
- （5）服务端推送（server push）

	- 采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。

- SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。

### HTTP2：SPDY的升级版

- 基于SPDY设计，与其不同之处

	- HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS
	- HTTP2.0 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE

- HTTP2 新特性

	- 新的二进制格式（Binary Format）

		- HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。

	- 多路复用（MultiPlexing）

		- 即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
		- 原理图

	- header压缩

		- HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。

	- 服务端推送（server push）

## 【TCP、UDP】互联网协议

### TCP 三次握手和四次挥手

- 定义

	- 三次握手与四次挥手分别对应TCP连接建立过程与断开过程，先上TCP报文格式

- 字段介绍

	- （1）序号

		- Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。

	- （2）确认序号

		- Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。

	- （3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等

		- （A）URG：紧急指针（urgent pointer）有效。
		- （B）ACK：确认序号有效。
		- （C）PSH：接收方应该尽快将这个报文交给应用层。
		- （D）RST：重置连接。
		- （E）SYN：发起一个新连接。
		- （F）FIN：释放一个连接。

- 三次握手

	- 简明理解

		- 第一次握手：Client什么都不能确认；Server确认了对方发送正常
		- 第二次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：自己接收正常，对方发送正常
		- 第三次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：自己发送、接收正常，对方发送接收正常

	- 实际过程

		- A对B说：我的序号是x，我要向你请求连接；（第一次握手，发送SYN包，然后进入SYN-SEND状态）
		- B听到之后对A说：我收到你的序号x了，我给你返回一个x+1，我的序号是y，期待你下一句序号是y+1的话（意思就是收到了序号为y的话，即ack=y+1），同意建立连接。（第二次握手，发送ACK-SYN包，然后进入SYN-RCVD状态）
		- A听到B说同意建立连接之后，对B说：与确认你同意与我连接（ack=y+1,ACK=1,seq=x+1）。（第三次握手，A已进入ESTABLISHED状态）
		- B听到A的确认之后，也进入ESTABLISHED状态。

	- 为什么要有三次握手？

		- 两次握手的问题

			- 两次握手的问题在于服务器端不知道一个SYN是否是无效的
			- 假设只有两次握手，比如图中的1，2步，当A想要建立连接时发送一个SYN，然后等待ACK，结果这个SYN因为网络问题没有及时到达B，所以A在一段时间内没收到ACK后，在发送一个SYN，B也成功收到，然后A也收到ACK，这时A发送的第一个SYN终于到了B，对于B来说这是一个新连接请求，然后B又为这个连接申请资源，返回ACK，然而这个SYN是个无效的请求，A收到这个SYN的ACK后也并不会理会它，而B却不知道，B会一直为这个连接维持着资源，造成资源的浪费

		- 三次握手可以保证任何一次握手出现问题，都是可以被发现或补救的

			- 因为客户端会给服务器回复第二次握手，也意味着服务器会等待客户端的第三次握手，如果第三次握手迟迟不来，服务器便会认为这个SYN是无效的，释放相关资源。

		- 一句话：“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”

- 四次挥手

	- 实际过程

		- 1.A与B交谈结束之后，A要结束此次会话，对B说：我要关闭连接了（seq=u,FIN=1）。（第一次挥手，A进入FIN-WAIT-1）
		- 2.B收到A的消息后说：确认，你要关闭连接了。（seq=v,ack=u+1,ACK=1）（第二次挥手，B进入CLOSE-WAIT）
		- 3.A收到B的确认后,等了一段时间，因为B可能还有话要对他说。（此时A进入FIN-WAIT-2）
		- 4.B说完了他要说的话（只是可能还有话说）之后，对A说，我要关闭连接了。（seq=w, ack=u+1,FIN=1，ACK=1）(第三次挥手)
		- 5.A收到B要结束连接的消息后说：已收到你要关闭连接的消息。（seq=u+1,ack=w+1,ACK=1）(第四次挥手，然后A进入CLOSED)
		- 6.B收到A的确认后，也进入CLOSED。

	-  为什么要四次挥手？

		- 根本原因是，一方发送FIN只表示自己发完了所有要发的数据，但还允许对方继续把没发完的数据发过来。

### TCP、UDP协议区别

- 1，TCP是面向连接的协议，UDP是无连接协议； 

	- 对于面向连接的： 两个人打电话时，双方确认并建立连接后才能进行通信。 
	- 对于面向无连接的：在邮局寄信时，你只需要将信放在邮筒里，不需要给收件人通知，收件人也不知道你给他寄信了

- 2，TCP无界，UDP有界； 

	- TCP通过字节流传输，即TCP将应用程序看成是一连串的无结构的字节流。每个TCP套接口有一个发送缓冲区，如果字节流太长时，TCP会将其拆分进行发送。当字节流太短时，TCP会等待缓冲区中的字节流达到一定程度时再构成报文发送出去，TCP发给对方的数据，对方在收到数据时必须给矛确认，只有在收到对方的确认时，本方TCP才会把TCP发送缓冲区中的数据删除。 
	- 而UDP传输报文的方式是由应用程序控制的，应用层交给UDP多长的报文，UDP照样发送，既不拆分，也不合并，而是保留这些报文的边界，即一次发送一个报文。 

- 3，TCP可靠，UDP不可靠； 
- 4，TCP有序，UDP无序； 

	- 消息在传输过程中可能会乱序，后发送的消息可能会先到达，TCP会对其进行重排序，UDP不会。

- 5，TCP有流量控制（以及拥塞处理），UDP没有； 

	- 流量控制

		- TCP利用滑动窗口机制在TCP连接上实现对发送方的流量控制， 如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。 
		- 滑动窗口

	- 拥塞处理

		- 防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。 

	- 拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接受数据。而前者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。
	- 当出现网络抖动时，TCP会自觉降低发送速度，他会努力维护次序，但udp依然保持速度不变

- 应用场景

	- TCP应用场景

		- 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。

	- UDP应用场景

		- 效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。

## WEBSOCKET 

### （1）基于 HTTP 协议的方案的本质缺陷

- 在浏览器与服务器通信间，传统的 HTTP 请求在某些场景下并不理想，比如实时聊天、实时性的小游戏等等，其面临主要两个缺点：

	- 无法做到消息的「实时性
	- 服务端无法主动推送信息

- 其基于 HTTP 的主要解决方案有：

	- 基于 ajax 的轮询：客户端定时或者动态相隔短时间内不断向服务端请求接口，询问服务端是否有新信息；其缺点也很明显：多余的空请求（浪费资源）、数据获取有延时；
	- Long Poll：其采用的是阻塞性的方案，客户端向服务端发起 ajax 请求，服务端挂起该请求不返回数据直到有新的数据，客户端接收到数据之后再次执行 Long Poll；该方案中每个请求都挂起了服务器资源，在大量连接的场景下是不可接受的；

- 本质缺陷即「被动性」，服务端无法下推消息，仅能由客户端发起请求不断询问是否有新的消息，同时对于客户端与服务端都存在性能消耗。

### （2）WebSocket 是 HTML5 中提出的新的网络协议标准

- 初步了解

	- WebSocket 是 HTML5 开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。 
	-  在 WebSocket API 中，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。

- 特点

	- （1）建立于 TCP 协议之上的应用层；
	- （2）一旦建立连接（直到断开或者出错），服务端与客户端握手后则一直保持连接状态，是持久化连接；
	- （3）服务端可通过实时通道主动下发消息；
	- （4）数据接收的「实时性（相对）」与「时序性」；

### （3）Websocket实践

- 浏览器提供原生对象

	- 在浏览器中使用 Websocket 非常简单，在支持 Websocket 的浏览器中提供了原生的 WebSocekt 对象，其中对于消息的接收与数据帧处理在浏览器中已经封装好了。

- 服务端实现

	- 使用 Websocket 需要服务端与客户端都提供相应能力，这里基于 Node.js 和 ws 简单建立一个服务端 Websocket 接口：

	- （1）在 8080 端口中监听了 express 的请求与 Websocket 请求，因为他们本身协议（http(s):// 与 ws(s)://）不同，因此不会冲突。
	- （2）同时在代码中可以看到其首先监听了 connection 事件（建立连接触发），在其回调中监听 message 事件（接收到消息）并立即 send 一条数据。

- 浏览器实现

	- Websocket API

		- 浏览器中提供了原生类 WebSocket ，使用 new 关键字实例化它：

			- new  WebSocket(String url,optional String | [] protocols);

		- （1）接收两个参数：

			- url 表示需要连接的地址，比如：ws://localhost:8080；
			- protocols 可选参数，可以是一个字符串或者一个数组，用来表示子协议，这样做可以让一个服务器实现多种 WebSocket 子协议；

		- （2）实例化对象提供两个方法：

			- send 接收一个 String|ArrayBuffer|Blob 数据，作为数据发送到服务端；
			- close 接收一个（可选）的 code（关闭状态号，默认为 1000） 与一个（可选）的字符串（表示断开原因），客户端主动断开连接；

		- （3）连接状态：

			- WebSocket 类提供了一些常量表示连接状态：

				- WebSocket.CONNECTING 0 连接还没开启；
				- WebSocket.OPEN 1 连接已开启并准备好进行通信；
				- WebSocket.CLOSING 3 连接正在关闭的过程中；
				- WebSocket.CLOSED 4 连接已经关闭，或者连接无法建立；

			- WebSocket 的实例对象中提供了 readyState 属性来判断当前状态；

		- （4）实例化对象中可以监听到以下事件：

			- open 连接打开的回调事件，这时 readyState 变为 OPEN；
			- message 收到消息的回调事件，同时回调函数接收到一个 MessageEvent 数据；
			- close 连接关闭的回调事件，这时 readyState 变为 CLOSED；
			- error 建立与连接过程发生错误的回调事件；

	- 具体代码

	- 控制台中可以看到：

		- 首先触发 open 事件，之后每次发送数据服务端都会回复数据，因此触发了 message 事件，当发送 10 次之后浏览器主动断开连接，因此触发 close 事件；这里最后一次发送之后未收到服务端回复也是因为客户端立即断开了连接；

- 事件与数据

	- 对 WebSocket 实例监听事件有两种方式，这里以 message 事件为例：

		- 对 onmessage 属性直接赋值，正如以上：ws.onmessage = function () {};；
		- 使用 addEventListener 监听事件，如：ws.addEventListener('message', function () {})；

	- 在 message 回调函数中得到 MessageEvent 类型参数 e ，我们需要的数据可以通过 e.data 获取；
	- 需要注意的一点是：

		- 不论服务端与客户端，其接受到的数据都是序列化后的字符串（当然也有 ArrayBuffer|Blob 类型数据），很多时候我们需要解析处理数据，比如 JSON.parse(e.data)；

- 连接稳定性

	- 由于网络环境复杂，某些情况会出现断开连接或者连接出错，需要我们在 close 或者 error 事件中监听非正常断开并重连；
	- 由于一些原因在 error 时浏览器并不会响应回调事件，因此稳妥的做法还需要在 open 之后开启一个定时任务去判断当前的连接状态 readyState ，在出现异常情况下尝试重连；

- 心跳

	- websocket规范定义了心跳机制，一方可以通过发送ping（opcode 0x9）消息给另一方，另一方收到ping后应该尽可能快的返回pong（0xA）。
	- 心跳机制是用于检测连接的对方在线状态，因此如果没有心跳，那么无法判断一方还在连接状态中，一些网络层比如 nginx 或者浏览器层会主动断开连接，
	- 在 JavaScript 中，WebSocket 并没有开放 ping/pong 的 API ，虽然浏览器自带了心跳处理，然而不同厂商的实现也不尽相同，因此需要在我们开发时候与服务端约定好一个自实现的心跳机制；
	- 比如浏览器中，检测到 open 事件后，启动一个定时任务，每次发送数据 0x9 给服务端，而服务端返回 0xA 作为响应；
	- 实践下来，心跳的定时任务一般是相隔 15-20 秒发送一次。

### （4）网络协议

- WebSocket与网络协议的关系

	- 前文说到，Websocket 是建立与 TCP 之上，那么其与 HTTP 协议有和关系呢？
	- Websocket 连接分为建连阶段与连接阶段，在建立连接阶段借助于 HTTP ，而在连接阶段则与 HTTP 无关。

- 建立连接阶段

	- 从浏览器的 Network 中，找到 ws 连接，可以看到：

	- 这是一个标准的 HTTP 请求，相比于我们常见的 HTTP 请求协议，请求头中多了几个字段：

		- Connection 为 Upgrade ，Upgrade 为 websocket ，表示告知 Nginx 与 Apache 等服务器该次连接并非为 HTTP 连接，实质上是一个 websocket ，因此服务器会转发到相应的 websocket 任务处理；
		- Sec-WebSocket-Key 是一个 Base64 encode 的值，由浏览器随机生成的，用于验证服务器连接的正确性；
		- Sec-WebSocket-Versio 表示为使用的 websocket 服务版本；

	- 响应头中：

		- 可以看到其返回状态码为 101 ，表示切换协议；
		- Upgrade 与 Connection 用于回复客户端表示已经切换协议成功；
		- Sec-WebSocket-Accept 字段与 Sec-WebSocket-Key 相对应，用于验证服务的正确性；

- 连接阶段

	- 当通过 HTTP 建立连接握手后，接下来则是真正的 Websocket 连接了，其基于 TCP 收发数据，Websocket 封装并开放接口。

- WSS

	- 在 HTTP 协议中，很多时候为了加密与安全需要使用 HTTPS 请求（HTTP + TCL）；相应的，在 Websocket 协议中，也是可以使用加密传输的 —— wss ，比如 wss://localhost:8080。
	- 使用的也是与 HTTPS 一样的证书，在这里一般是交由 Nginx 等服务层去做证书处理。

