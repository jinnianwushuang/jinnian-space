# 安全

## Web安全

### XSS

- 危害

	- Cookie劫持
	- 构造POST、GET请求
	- XSS钓鱼
	- 识别用户浏览器、识别用户安装的软件
	- CSS History Hack
	- 获取用户真实IP
	- XSS Worm

- 构造

	- 利用字符编码
	- 绕过长度限制
	- base标签
	- window.name

- 防御

	- HttpOnly
	- 输入检查
	- 输出检查

### CSRF

- 危害

	- 伪造请求
	- CSRF Worm

- 防御

	- 验证码
	- Referer Check
	- Anti CSRF Token

### ClickJacking

- 危害

	- 视觉欺骗，诱导用户在该网页上操作
	- 图片覆盖攻击
	- 拖拽劫持和数据窃取
	- 触屏劫持

- 构造

	- 调整iframe页面的位置，是用户恰好点击在iframe页面的一些功能性按钮上

- 防御

	- frame busting
	- X-Frame-Options(优)

### 注入攻击

- SQL注入
- 数据库攻击技巧
- 正确防御SQL注入
- 其他注入攻击

### 文件上传漏洞

- 一般场景

	- 上传Web脚本能够被服务器解析

- 解决方案

	- 文件上传目录设置为不可执行
	- 判断文件类型
	- 使用随机数改写文件名和文件路径
	- 单独设置文件服务器的域名

### 认证与会话

### 拒绝服务攻击

### 浏览器

- 同源策略

	- 端口号、IP地址、子域名、协议必须相同的两个origin才为同源。
	- 跨域

		- window.name
		- jsonp
		- nginx转发
		- Node中间层
		- 配置CORS
		- websocket

- Cookie策略

	- Cookie种类

		- Session Cookie

			- 存于浏览器进程的内存空间里（服务端不设置Expire和max-age时触发）

		- Third-party Cookie

			- 存于本地

		- 浏览器从一个域的页面加载另外一个域的资源，部分浏览器会阻止Third-party Cookie的发送

### HTML5安全

- 新标签、新事件可能带来新XSS攻击

	- 例如vedio的onloadedmetadata、ondurationchange等

- 设置iframe的sandbox属性来增强应用使用iframe安全性

	- allow-same-origin
	- allow-top-navigation
	- allow-forms
	- allow-scripts

- Link Type: noreferrer

	- 给link标签设置rel='noreferrer'后，浏览器请求时将不再发送referrer

- Canvas

	- 可以识别图片验证码

- CORS
- postMessage

	- postMessage允许每一个window对象向其他窗口发送文本消息，从而实现跨窗口的消息传递。

- Web Storage

## JWT(Json Web token)

### （1）认识JWT

- jwt是为了在网络应用环境传递声明而执行的一种基于json的开放标准。
- jwt被用来在身份提供者和服务提供者间传递被认证的用户身份信息，简单来说，就是用来验证身份的手段，例如登录校验，像我们之前用的cookie。
- jwt可以使用HMAC算法或者是RSA的公私秘钥对来进行签名，来保证信息的可靠性。

### （2）应用场景

- 在例如身份验证场景中，用户一旦登录，接下来的每个请求都会包含jwt，用来验证身份信息。由于通信双方使用jwt对数据进行编码，它的信息是经过签名的，所以可以确保信息的安全性。

### （3）JWT对比cookie

- Cookie缺点

	- 客户端发请求给服务器，服务器种植cookie后，每次请求都会带上cookie，浪费带宽
	- cookie不能跨服务器访问，不支持跨域
	- 服务器要对登录的用户对象进行存储，浪费服务器内存

- JWT优点

	- （1）jwt是不基于状态的，不需要每次请求都带上token，节约流量
	- （2）可以跨服务端，可以共用
	- （3）体积小，因而传输速度快
	- （4）传输方式多样，可以通过 URL/POST 参数/HTTP 头部 等方式传输
	- （4）严谨的结构化。它自身（在 payload 中）就包含了所有与用户相关的验证消息，如用户可访问路由、访问有效期等信息，服务器无需再去连接数据库验证信息的有效性，并且 payload 支持为你的应用而定制化
	- （5）支持跨域验证，多应用于单点登录。

		- 单点登录（Single Sign On）：在多个应用系统中，用户只需登陆一次，就可以访问所有相互信任的应用。
		- 用户登陆之后，服务器会返回给他一个 token，由他保存在本地，在这之后的对服务器的访问都要带上这串 JWT ,来获得访问服务器相关路由、服务及资源的权限。比如单点登录就比较多地使用了 JWT，因为它的体积小，并且简单处理（使用 HTTP 头带上 Bearer 属性 + token ）就可以支持跨域操作。

	- （6）比 cookie 更支持原生移动端应用

		- 原生的移动应用对 cookie 与 session 的支持不够好，而对 token 的方式支持较好。

	- （7）验证解耦，无需使用特定的身份验证方案， token 可以在任何地方生成

		- 只要拥有生成 token 所需的验证信息，在何处都可以调用 token 生成接口，无需繁琐的耦合的验证操作，可谓是一次生成，永久使用。

	- （8）充分依赖无状态 API ，契合 RESTful 设计原则

		- 有状态

			- server 保存了 client 的请求状态， server 会通过 client 传递的 sessionID 在其 session 作用域内找到之前交互的信息并应答。

		- 无状态

			- 无状态是 RESTful 架构设计的一个非常主要的原则。无状态 API 的每一个请求都是独立的，它要求由客户端保存所有需要的认证信息，每次发请求都要带上自己的状态

	- （9）易于实现 CDN，将静态资源分布式管理

		- 在传统的 session 验证中，服务端必须保存 session ID，用于与用户传过来的 cookie 验证。而在一开始保存 session ID 时， 只会保存在一台服务器上，所以只能由一个 server 应答，就算其他服务器有空闲也无法应答，因此也利用不到分布式服务器的优点。
		- 而 JWT 依赖的是在客户端本地保存验证信息，不需要利用服务器保存的信息来验证，所以任意一台服务器都可以应答，服务器的资源也被较好地利用。

### （4）JWT结构

- Header头部

	- { typ:'jwt' ,alg:'HS256' }
 alg:当前用的什么算法加密的；使用Base64Url编码组成了JWT结构的第一部分

- PlyLoad负载

	- 存放有效信息的地方

- Signature签名

	- 创建签名需要使用编码后的header和payload以及一个秘钥；例如如果希望使用HMAC SHA256算法，那么签名应该使用下列方式创建
	- HMACSHA256( base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)

- 完整的jwt格式的输出是以 . 分隔的三段Base64编码 密钥secret是保存在服务端的，服务端会根据这个密钥进行生成token和验证，所以需要保护好。

### （5）例子

- 流程图

- 流程

	- （1）首先，拥有某网站账号的某 client 使用自己的账号密码发送 post 请求 login
	- （2）由于这是首次接触，server 会校验账号与密码是否合法，如果一致，则根据密钥生成一个 token 并返回
	- （3）client 收到这个 token 并保存在本地的 localStorage。
	- （4）在这之后，需要访问一个受保护的路由或资源时，而只要附加上你保存在本地的 token（通常使用 Bearer 属性放在 Header 的 Authorization 属性中），server 会检查这个 token 是否仍有效，以及其中的校验信息是否正确，再做出相应的响应。

### 理解 JSON Web Tokens (JWT) 的 5 个简单步骤

- JWT的定义

	- JSON Web令牌（JWT）是一种 JSON 对象（双引号字符串被认为是有效的 JSON 对象），是一套开放的标准定义的两方之间表示一组信息的安全方式。 JWT 由头部（header），负载（payload）和签名（signature）组成。
	- 简单地说，JWT只是一个具有以下格式的字符串：

- 实际场景

	- 此示例中的三个不同的实体是用户，应用程序服务器和身份验证服务器。 验证服务器将向用户提供 JWT。 使用 JWT，用户可以安全地与应用程序通信。

		- 在该示例中，用户首先使用认证服务器的登录系统登录认证服务器（例如，用户名和密码，Facebook登录，Google登录等）。 然后，身份验证服务器创建 JWT并将其发送给用户。 当用户对应用程序进行 API 调用时，用户将传递 JWT 以及 API 调用。 在这个实例中，应用程序服务器将可以验证传入的 JWT 是否是由身份验证服务器创建的（验证过程将在稍后更详细地说明）。当用户使用附加的 JWT 进行API 调用时，应用程序可以使用 JWT 来验证该 API 调用是否来自经过身份验证的用户。

- 构建JWT

	- Step 1. 创建 Header

		- JWT 的 Header 部分包含有关如何计算 JWT 签名的信息，是一个以下形式的 JSON 对象

		- 在上面的 JSON 中，“typ”键的值指定对象是JWT，“alg”键的值指定用于创建 JWT 签名的算法。 在示例中，我们使用 HMAC-SHA256算法（一种使用密钥的散列算法）来计算签名

	- Step 2. 创建 Payload

		- JWT 的 payload 部分时是存储在 JWT 内的数据。在我们的示例中，身份验证服务器创建一个JWT，其中存储有用户信息，特别是用户ID。

		- 在我们的示例中，我们只将一个声明放入 payload 中。 你可以根据需要添加任意数量的声明。JWT 规定了7个官方字段，供选用。

			- iss (issuer)：签发人
			- exp (expiration time)：过期时间
			- sub (subject)：主题
			- aud (audience)：受众
			- nbf (Not Before)：生效时间
			- iat (Issued At)：签发时间
			- jti (JWT ID)：编号

		- 除了官方字段，你还可以在这个部分定义私有字段。请记住，数据的大小将影响JWT的总体大小，这通常不是问题，但过大的 JWT 可能会对性能产生负面影响并导致延迟。

	- Step 3. 创建 Signature

		- 使用某算法，其所做的是 base64url 对在步骤1和2中创建的header和payload进行编码。然后，算法将得到的编码字符串用“点”（.）连在一起。

		- 在示例中，header 和 payload 被 base64url 编码，然后，在加入周期的编码头和编码有效载荷上应用带有密钥的指定签名算法，我们得到签名所需的散列数据。 在我们的例子中，这意味着在数据字符串上应用 HS256 算法，并将密钥设置为字符串“secret”，以获取 hashedData字符串。 之后，通过base64url 编码 hashedData 字符串

	- Step 4. 把 JWT 的三个部分组合在一起

		- 我们只需要组合以上的三个部分，用点（.）分隔它们。

			- // JWT Token
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ.-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM

	- Step 5. 校验 JWT

		- 在我们的示例中，我们使用的是由 HS256 算法签名的JWT，其中只有身份验证服务器和应用服务器知道密钥。当应用程序设置其身份验证过程时，应用程序服务器从身份验证服务器接收密钥。由于应用程序知道密钥，当用户对应用程序进行带有 JWT 附加的 API 调用时，应用程序可以执行与 JWT 上的步骤3相同的签名算法。然后，应用程序可以验证从其自己的哈希操作获得的签名是否与 JWT 本身上的签名匹配（即，它与由认证服务器创建的 JWT 签名匹配）。如果签名匹配，则表示 JWT 有效，表示 API 调用来自可信源。否则，如果签名不匹配，则表示收到的 JWT 无效，这可能是对应用程序的潜在攻击的指示。因此，通过验证 JWT，应用程序在其自身和用户之间添加了一层信任。

- JWT 如何保护我们的数据？

	- 要理解使用 JWT 的目的不是以任何方式隐藏或模糊数据，而是为了证明发送的数据是由真实的来源创建的。
	- 由于 JWT 仅被签名和编码，并且由于 JWT 未加密，因此 JWT 不能保证敏感数据的安全性。

## Web 的攻击技术

### 针对 Web 的攻击技术

- 简单的 HTTP 协议本身并不存在安全性问题,因此协议本身几乎不会成为攻击的对象
- 在运作的 Web 应用背后却隐藏着各种容易被攻击者滥 用的安全漏洞的 Bug
- 在 Web 应用中,从浏览器那接收到的 HTTP 请求的全部内容,都可以在客户端自由地变更、篡改
- 在 HTTP 请求报文内加载攻击代码,就能发起对 Web 应用的攻击
- 主动攻击(active attack)是指攻击者通过直接访问 Web 应用,把攻击代码传入的攻击模式
- 被动攻击(passive attack)是指利用圈套策略执行攻击代码的攻击模式。

### 因输出值转义不完全引发的安全漏洞

- 跨站脚本攻击(Cross-Site Scripting,XSS)是指通过存在安全漏洞的 Web 网站注册用户的浏览器内运行非 法的 HTML 标签或 JavaScript 进行的一种攻击
- 利用虚假输入表单骗取用户个人信息。
- 利用脚本窃取用户的 Cookie 值, 被害者在不知情的情况下, 帮助攻击者发送恶意请求。
- 显示伪造的文章或图片
- 跨站脚本攻击案例
- 在动态生成 HTML 处发生
- 对用户 Cookie 的窃取攻击
- SQL 注入(SQL Injection)是指针对 Web 应用使用的数据库,通过运行非法的 SQL 而产生的攻击。
- 非法查看或篡改数据库内的数据
- 规避认证
- 执行和数据库服务器业务关联的程序等
- OS 命令注入攻击(OS Command Injection)是指通过 Web 应用,执行非法的操作系统命令达到攻击的目 的
- HTTP 首部注入攻击(HTTP Header Injection)是指攻击者通过在响应首部字段内插入换行,添加任意响应首部或主体的一种攻击。
- 设置任何 Cookie 信息
- 重定向至任意 URL
- 显示任意的主体( HTTP 响应截断攻击)
- HTTP 首部注入攻击案例
- 邮件首部注入(Mail Header Injection)是指 Web 应用中的邮件发送功能,攻击者通过向邮件首部 To 或 Subject 内任意添加非法内容发起的攻击
- 目录遍历(Directory Traversal)攻击是指对本无意公开的文件目录,通过非法截断其目录路径后,达成访问 目的的一种攻击
- 远程文件包含漏洞(Remote File Inclusion)是指当部分脚本内容需要从其他文件读入时,攻击者利用指定外 部服务器的 URL充当依赖文件,让脚本读取之后,就可运行任意脚本的一种攻击

### 因设置或设计上的缺陷引发的安全漏洞

- 强制浏览

	- 强制浏览(Forced Browsing)安全漏洞是指,从安置在 Web 服务器的公开目录下的文件中,浏览那些原本 非自愿公开的文件
	- 泄露顾客的个人信息等重要情报
	- 泄露原本需要具有访问权限的用户才可查阅的信息内容
	- 泄露未外连到外界的文件

- 不正确的错误消息处理

	- Web 应用不必在用户的浏览画面上展现详细的错误消息。对攻击者来说,详细的错误消息有可能给他们下一 次攻击以提示

- 开放重定向

	- 开放重定向(Open Redirect)是一种对指定的任意 URL 作重定向跳转的功能。

### 因会话管理疏忽引发的安全漏洞

- 会话劫持(Session Hijack)是指攻击者通过某种手段拿到了用户的会话 ID,并非法使用此会话 ID 伪装成用 户,达到攻击的目的
- 对以窃取目标会话 ID 为主动攻击手段的会话劫持而言,会话固定攻击(Session Fixation)攻击会强制用户 使用攻击者指定的会话 ID,属于被动攻击。
- 跨站点请求伪造(Cross-Site Request Forgeries,CSRF)攻击是指攻击者通过设置好的陷阱,强制对已完 成认证的用户进行非预期的个人信息或设定信息等某些状态更新,属于被动攻击。

### 其他安全漏洞

- 密码破解攻击(Password Cracking)即算出密码,突破认证
- 通过网络的密码试错

	- 穷举法
	- 字典攻击

- 对已加密密码的破解(指攻击者入侵系统, 已获得加密或散列处理的密码数据的情况)
- 点击劫持(Clickjacking)是指利用透明的按钮或链接做成陷阱,覆盖在 Web 页面之上。然后诱使用户在不 知情的情况下,点击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装(UI Redressing)。
- DoS 攻击(Denial of Service attack)是一种让运行中的服务呈停止状态的攻击
- 后门程序(Backdoor)是指开发设置的隐藏入口,可不按正常步骤使用受限功能

## web安全机制

### 基础安全知识

- XSS(跨站脚本攻击)

	- XSS通常是由带有页面可解析内容的数据未经处理直接插入到页面上解析导致的。
	- 存储型XSS的攻击脚本常常是由前端提交的数据未经处理直接存储到数据库然后从数据库中读取出来后又直接插入到页面中所导致的
	- 反射型XSS可能是在网页URL参数中注入了可解析内容的数据而导致的，如果直接获取URL中不合法的并插入页面中则可能出现页面上的XSS攻击
	- MXSS（也叫DOM XSS）则是在渲染DOM属性时将攻击脚本插入DOM属性中被解析而导致的
	- XSS主要的防范方法是验证输入到页面上所有内容来源数据是否安全，如果可能含有脚本标签等内容则需要进行必要的转义。

- SQL(结构化查询语言)注入

	- SQL注入攻击主要是因为页面提交数据到服务器端后，在服务器端未进行数据验证就将数据直接拼接到SQL语句中执行，因此产生执行与预期不同的现象。
	- 主要防范措施是对前端网页提交的数据内容进行严格的检查校验。

- CSRF(跨站请求伪造)

	- CSRF是指非源站点按照源站点的数据请求格式提交非法数据给源站点服务器的一种攻击方法。
	- 非源站点在取到用户登录验证信息的情况下，可以直接对源站点的某个数据接口进行提交，如果源站点对该提交请求的数据来源未经验证，该请求可能被成功执行，这其实并不合理。通常比较安全的是通过页面Token（令牌）提交验证的方式来验证请求是否为源站点页面提交的，来阻止跨站伪请求的发生。

### 请求劫持与HTTPS

- DNS劫持

	- DNS劫持通常是指攻击者劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致用户对该域名地址的访问由原IP地址转入到修改后的指定IP地址的现象，其结果就是让正确的网址不能解析或被解析指向另一网站IP，实现获取用户资料或者破坏原有网站正常服务的目的。DNS劫持一般通过篡改DNS服务器上的域名解析记录，来返回给用户一个错误的DNS查询结果实现。
	- DNS劫持症状可能为在某些地区的用户在成功连接宽带网络后，访问域名为www.a.com的网站，出现的却是www.b.com网站的内容，因为DNS服务器www.a.com域名的解析结果被修改指向了www.b.com网站指向的IP地址。

- HTTP劫持

	- HTTP劫持是指，在用户浏览器与访问的目的服务器之间所建立的网络数据传输通道中从网关或防火墙层上监视特定数据信息，当满足一定的条件时，就会在正常的数据包中插入或修改成为攻击者设计的网络数据包，目的是让用户浏览器解释“错误”的数据，或者以弹出新窗 口的形式在使用者浏览器界面上展示宣传性广告或者直接显示某块其他的内容。
	- 这种情况下一般用户请求源网站的IP地址及网站加载的内容和脚本都是正确的，但是在网站内容请求返回的过程中，可能被ISP（Internet Service Provider，互联网服务提供商）劫持修改，最终在浏览器页面上添加显示一些广告等内容信息。

- 对于这些情况，网站开发者常常就无法通过修改网站代码程序等手段来进行防范了。请求劫持唯一可行的预防方法就是尽量使用HTTPS协议来访问目标网站。

### HTTPS协议通信过程

- HTTPS协议是通过加入SSL（Secure Sockets Layer）层来加密HTTP数据进行安全传输的HTTP协议，同时启用默认的443端口进行数据传输。
- 公钥（Public Key）与私钥（Private Key）是通过一种加密算法得到的密钥对（即一个公钥和一个与之匹配的私钥），公钥是密钥对中公开的部分，私钥则是非公开的部分。公钥通常用于会话加密、验证数字签名或者加密可以用相应私钥解密的数据。通过这种算法得到的密钥对保证是唯一的。使用这个密钥对的时候，如果用其中一个密钥加密一段数据，则必须用另一个密钥解密。

### HTTPS协议解析

- HTTPS请求报文和HTTP的请求报文区别不大，但是在请求的头部域字段多了upgrade-insecure-requests，该头部字段指令很关键，它可以用于让页面打开的后续请求自动从 HTTP请求升级到HTTPS请求。否则如果使用HTTPS来加载HTML文件，而HTML中加载的是HTTP链接的资源文件，则会产生Mixed Content类型的错误，并且无法加载资源。
- 在服务器端响应头域中也要加入下面的头域来返回给浏览器，否则浏览器默认安全显示策略会阻塞内容并提示block-all-mixed-content类型的错误。
header("Content-Security-Policy: upgrade-insecure-requests") ;

### 浏览器Web安全控制

- X-XSS-Protection

	- 这个head消息头设置主要是用来防止浏览器中的反射性XSS问题的发生，通过这种方式可以在浏览器层面增加前端网页的安全性。
	- X-XSS-Protection通常设置如下。

X-XSS-Protection: 1;
mode=block 0 –关闭对浏览器的xss防护；1 –开启xss防护
mode=block可以开启XSS防护并通知浏览器阻止而不是过滤用户注入的XSS脚本

- Strict-Transport-Security

	- Strict Transport Security（STS）是一种用来配置浏览器和服务器之间安全通信的机制，主要用来防止中间者攻击，因为它强制所有的通信都使用HTTPS，在普通的HTTP报文请求中配置STS是没有作用的，而且攻击者也能更改这些值。
	- 为了防止这样的现象发生，很多浏览器内置了一个配置STS的站点列表，在Chrome浏览器下可以通过访问chrome://net-internals/#hsts查看浏览器中站点的STS列表，一般STS的配置实现如下。

max-age=31536000 –告诉浏览器将域名缓存到STS列表中，只有这些特定域名下的资源内容才允许被加载，时
间是一年
max-age=31536000;
includeSubDomains;
preload; –告诉浏览器将域名缓存到STS列表里面并且包含所有的子域名，并可支持预加载，时间是一年
max-age= 0 –告诉浏览器移除在STS缓存里的域名，或者不保存当前域名

- Content-Security-Policy

	- 我们简称它为CSP，这是一种由开发者定义的安全策略性声明，通过CSP所约束的的规则设定，浏览器只可以加载指定可信的域名来源的内容（这里的内容可以是脚本、图片、iframe、font、style等等远程资源）。通过CSP协定，Web只能加载指定安全域名下的资源文件，保证运行时的内容总处于一个安全的环境中。

- Access-Control-Allow-Origin

	- Access-Control-Allow-Origin是从Cross Origin Resource Sharing（CORS）中分离出来的。这个头部设置是决定哪些网站可以访问当前服务器资源的设置，通过定义一个通配符或域名来决定是单一的网站还是所有网站可以访问服务器的资源。
	- 需要注意的是，如果服务器端定义了通配符“＊”，那么服务端的Access-Control-Allow-Credentials（是否允许请求时携带验证信息）选项就无效了，此时用户浏览器中的不同域Cookie信息将默认不会在服务器请求里发送（即如果需要实现带Cookie进行跨域请求，则要明确地配置允许来源的域，使用任意域的配置是不合法的）。

Access-Control-Allow-Origin : * *– 通配符允许任何远程资源来访问 Access-Control-Allow-Origin
的内容  
http://www.domain.com – 只允许特定站点才能访问当前资源
	- Access-Control-Allow-Origin常常作为跨域共享设置的一种实现方式，其他常用的跨域手段还有： JSONP(JSON with Padding)、 script标签跨域、 window.postMessage、修改 document.domain跨子域、 window.name跨域和 WebSocket跨域等。

##  XSS

### 跨站脚本攻击(Cross Site Scripting)，缩写为XSS

- （1）XSS的定义：跨域脚本注入，攻击者通过某种方式将恶意代码注入到网页上，然后其他用户观看到被注入的页面内容后会受到特定攻击

	- 恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。

- （2）XSS的原理

	- 1.攻击者对含有漏洞的服务器发起XSS攻击（注入JS代码）。
	- 2.诱使受害者打开受到攻击的服务器URL。
	- 3.受害者在Web浏览器中打开URL，恶意脚本执行。

- （3）XSS的攻击方式

	- 1.反射型：（直接通过URL注入，而且很多浏览器都自带防御）

		- 发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS随响应内容一起返回给浏览器，最后浏览器解析执行XSS代码，这个过程就像一次发射，所以叫反射型XSS
		- 反射型XSS漏洞的攻击步骤

			- （1） 用户正常登录Web应用程序，登录成功会得到一个会话信息的cookie：

			- （2） 攻击者将含有攻击代码的URL发送给被攻击人；

			- （3） 用户打开攻击者发送过来的ULR；
			- （4） Web应用程序执行用户发出的请求；
			- （5） 后台对URL参数未做任何过滤处理，返回给客户端，前端直接从url上获取参数，会导致URL上的js代码执行
			- （6） 例子中攻击者使用的攻击代码作用是将用户的cookie信息发送到cookie_save.php这个文件来记录下来；
			- （7） 攻击者在得到用户的cookie信息后，将可以利用这些信息来劫持用户的会话。以该用户的身份进行登录。

	- 2.存储型：（存储到DB后读取时注入）

		- 存储型XSS和反射型的XSS差别就在于，存储型的XSS提交的代码会存储在服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交XSS代码。

	- 3. DOM-based XSS

		- 代码

		- 理解

- （4）XSS的防御措施

	- （1）输出进行编码：

		- HTML实体编码

			- 在 HTML 中，某些字符是预留的，比如不能使用小于号（<）和大于号（>），这是因为浏览器会误认为它们是标签。如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。当然还另一个重要原因，有些字符在 ASCII 字符集中没有定义，因此需要使用字符实体来表示，比如中文。
			- 最常见的五种实体编码

		- 和输入过滤类似，不过是从输出上着手，数据输出到页面时，经过HtmlEncoder等工具编码，这样就不会存在直接输出可执行的脚本了

	- （2）输入过滤：

		- 不信任用户的任何输入，过滤其中的“<”、“>”、“/”等可能导致脚本注入的特殊字符， 或者过滤“script”、“javascript”等脚本关键字，或者对输入数据的长度进行限制等等， 还得考虑攻击者使用十六进制编码来输入脚本的方式。
		- 而在一些前端框架中，都会有一份 decodingMap， 用于对用户输入所包含的特殊字符或标签进行编码或过滤，如 <，>，script，防止 XSS 攻击：

	- （3）Cookie设置http-only（防止劫取 Cookie）：

		- HttpOnly 最早由微软提出，至今已经成为一个标准。浏览器将禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。
		- 上文有说到，攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。

	- （4）Cookie防盗：

		- 在 Cookie 中防止放入用户名和密码，对 Cookie 信息进行 MD5 等算法进行多次散列存放，必要时还要对 ip 和 cookie 进行绑定，一旦检测异常，立马让用户重新登录；

## CSRF

### CSRF（跨站请求伪造）（cross-site request forgery）

- （1）CSRF的定义：冒用用户身份，进行恶意操作

	-  攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。

- （2）CSRF的原理

	- 1. 用户打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；
	- 2.在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；
	- 3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；
	- 4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；
	- 5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 
	- CSRF攻击的本质原因 ：CSRF 攻击时源于 WEB 的隐式身份验证机制！WEB 的身份验证机制虽然可以保证一个请求是来自某个用户的浏览器，但无法保证该请求是经过用户批准发送的。

- （3）CSRF的攻击手段

	-  1.譬如在网站内的图片资源中潜入恶意的转账操作

	-  2.构建恶意的隐藏表单，并通过脚本提交恶意请求

	- 【注意】

		- 从头到尾，攻击网站都没有获取到过 cookie，都是通过浏览器间接实现（利用Web的cookie隐式身份验证机制），所以HttpOnly并不会影响这个攻击

	- 【例子】（必看）

		- （1）假设有一个 bbs 站点：http://www.c.com，当登录后的用户发起如下 GET 请求时，会删除 ID 指定的帖子

			- 如发起 http://www.c.com:8002/content/delete/87343 请求时，会删除 id 为 87343 的帖子。当用户登录之后，会设置如下 cookie

		- （2）然后构造一个页面 A

		- （3）页面 A 使用了一个 img 标签，其地址指向了删除用户帖子的链接

		- （4）可以看到，当登录用户访问攻击者的网站时，会向 www.c.com 发起一个删除用户帖子的请求。此时若用户在切换到 www.c.com 的帖子页面刷新，会发现ID 为 87343 的帖子已经被删除。
		- 深刻理解

			- 由于 Cookie 中包含了用户的认证信息，当用户访问攻击者准备的攻击环境时，攻击者就可以对服务器发起 CSRF 攻击。在这个攻击过程中，攻击者借助受害者的 Cookie 骗取服务器的信任，但并不能拿到 Cookie，也看不到 Cookie 的内容。而对于服务器返回的结果，由于浏览器同源策略的限制，攻击者也无法进行解析。因此，攻击者无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。

- （4）常见的CSRF防御手段

	- 1.利用Token来防御

	  CSRF 攻击之所以能够成功，是因为攻击者可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 Cookie 中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的 Cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求

		- 当客户端请求页面时，服务器会生成一个随机数Token，并且将Token放置到session当中，然后将Token发给客户端（一般通过构造hidden表单）。下次客户端提交请求时，Token会随着表单一起提交到服务器端。 
		- 然后，如果应用于"anti csrf攻击"，则服务器端会对Token值进行验证，判断是否和session中的Token值相等，若相等，则可以证明请求有效，不是伪造的。 

	- 2.检测referer

		- referer是什么？

			- 根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。通过 Referer Check，可以检查请求是否来自合法的"源"。

		- 场景

			- 比如，如果用户要删除自己的帖子，那么先要登录 www.c.com，然后找到对应的页面，发起删除帖子的请求。此时，Referer 的值是 http://www.c.com；当请求是从 www.a.com 发起时，Referer 的值是 http://www.a.com 了。因此，要防御 CSRF 攻击，只需要对于每一个删帖请求验证其 Referer 值，如果是以 www.c.com 开头的域名，则说明该请求是来自网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是 CSRF 攻击，可以拒绝该请求。

		- 代码

			- 针对上文的例子，可以在服务端增加如下代码：

		- 存在问题

			- 后台在进行删除操作之前先判断referer，如果不是本域的请求，则直接拒绝，这种做法很有效。但是，想想这样一个场景：如果博客允许评论里面插图，攻击者完全可以将 img插入到原网站中，这样refer还是在当下域名，博客依然会被删除。所有可能引入链接的html标签都是不可信的，如script、link，后台过滤策略一定要考虑到。

	- CSRF 防御主要是过滤那些非法伪造的请求来源。

- （5）CSRF与AJAX的关系

	- 分析AJAX中带cookie验证的情况：

		- 1. AJAX受到浏览器的同源策略限制
		- 2. AJAX默认无法请求跨域的接口（当然后台可以配置`Access-Control-Allow-Origin: *`之类的允许所有的跨域请求）
		- 3. AJAX请求无法携带跨域cookie（如果强行开启withCredentials，必须服务端配合认证，无法用作攻击）

	- CSRF与AJAX无关

*XMind: ZEN - Trial Version*