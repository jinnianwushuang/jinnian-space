# js2

## JavaScript 高级

### 编程思想：

- 面向过程：

	- 什么是面向过程？

		- 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了

	- 优缺点：

		- 优点：性能比面向对象高，步骤练习紧密
		- 缺点：不好维护，不易多次使用及扩展

- 面向对象：

	- 什么是面向对象？

		- 面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作

	- 三大特性：

		- 1.封装性
		- 2.继承性
		- 3.多态性

	- 优缺点：

		- 优点：易维护，可复用，可扩展，灵活性高
		- 缺点：性能没有面向过程高

### 类和对象

- ES6

	- 对象

		- 什么是对象？

			- 对象是具体的

	- 类

		- 什么是类？

			- 类模拟抽象的，泛指的

		- 创建类

			- 例：class 类名 {
                                                }      类名首字母要大些

		- constructor构造函数

			- 例：class Star {
	constructor (uname,age){
		this.uname = uname;
		this.age = age;
	}
}

				- 注意：1.类里面的方法不带function，直接写既可
				- 2.类中定义属性，调用方法都得用this
				- 3.方法之间不能加逗号分隔

		- 继承：

			- extends

		- super关键字：

			- 用于访问和调用对象父类上的函数

				- 注意：子类在构造函数中使用super, 必须放到this 前面(必须先调用父类的构造方法,在使用子类构造方法）

		- 三个比较重要的注意点：

			- 在ES6中类没有变量提升，所以必须先定义类，才能通过类实例化对象.
			- 类里面的共有属性和方法一定要加this使用.
			- this指向的问题

				- 方法里面的this，谁调用，this就代表谁
				- 构造方法里面的this，代表当前实例对象

- ES5

	- 成员

		- 1.静态成员

			- 不需要实例对象调用属性（不需要new）

		- 2.实例成员

			- 需要实例对象调用属性（需要new）

	- 构造函数原型（prototype 原型对象-构造函数的一个属性）

		- 1.所有的属性都要写在构造函数里面
		- 2.所有的方法都要写在原型对象里面

	- 对象原型:简称“原型”（__proto__）

		- 1.每一个对象都有一个原型
		- 2.作用是指向原型对象prototype

	- 构造函数 constructor

		- 作用：指回原来的构造函数

	- 继承：

		- 属性继承

			- call(this,m,n)-------m,n为不确定参数，参数个数可变

		- 方法继承

			- 原理：1.子类的原型对象 《=》父类的实例对象
			- 2.继承完毕之后，子类的constructor的指向已经不见，需要将子类的custructor手动指回

### 函数

- 声明方式

	- 1.命名函数

		- function fn（）{}

	- 2.匿名函数

		- var fn = function(){}

	- 3.new function函数

		- var fn = new Function('a', 'b', 'console.log(a + b)')

- 调用：

	- 1.普通函数

		- function fn() {
	console.log('人生的巅峰');
}
fn();

	- 2.对象的方法

		- var o = {
  sayHi: function() {
  	console.log('人生的巅峰');
  }
}
o.sayHi();

	- 3.构造函数

		- function Star() {};
new Star();

	- 4.绑定事件函数

		- btn.onclick = function(){}

	- 5.定时器函数

		- setInterval(function() {}, 1000); 

			- 注意：非定时器的代码要快于定时器代码（即使定时器代码时间为0）

	- 6.立即执行函数(自调用函数)

		- (function (){
	console.log('自调函数');
})();

- this

	- 指向

		- 1.普通函数

			- window

		- 2.对象函数

			- 该方法所属的对象

		- 3.构造函数

			- new出来的实例对象

		- 4.绑定事件函数

			- 事件源，绑定时间对象

		- 5.定时器函数

			- window

		- 6.立即执行函数（自调用函数）

			- window

	- 改变指向

		- 1.call（this，m，n…………）

			- 参数:

				- 参数使用，逗号分隔开

			- 应用场景:

				- 父子继承上面

		- 2.apply（this，[m，n…………]）

			- 参数：

				- 参数使用[] 数组包含上

			- 应用场景：

				- 常常跟数组有关系，例如：借助Math种的最大值，最小值，求出数组中的最大值，最小值

		- 3.bind（this，m，n…………）

			- 参数

				- 参数使用，逗号分隔开

			- 应用场景

				- 不调用函数，并且还想改变this的指向

- 模式：

	- 正常模式：
	- 严格模式：

		- 1.声明：

			- “use strict”

		- 2.使用位置

			- 1.函数的顶端（使当前的函数声明为严格模式）
			- 2.脚本的顶端（是脚本声明为严格模式）

		- 3.注意事项

			- 1.变量

				- 1.变量声明中，必须加var
				- 2.不准删除变量

			- 2.this的指向：

				- 正常模式：

					- 在全局的作用域下，函数中的this，指向的是window

				- 严格模式：

					- 在全局的作用域下，函数中的this，是undefined

			- 3.函数变化

				- 1.函数不能有重复函数
				- 2.非函数体内不能含有函数体

- 高阶函数：

	- 1.将函数当作值传入参数
	- 2.将函数当作返回值返回

- 闭包

	- 一个作用域访问另一个作用域内的局部变量

### 递归

- 什么是？

	- 函数调用函数本身

- 深拷贝与浅拷贝

	- 浅拷贝

		- 第一层：简单数据类型

			- 扩展：ES6新增方法Object.assign(“新的”，“源的”)

	- 深拷贝

		- 实现复杂类型的赋值，切记不能直接赋值，考虑复杂类型地址的问题

- 补充知识：

	- instenceof 判断是不是数组或者对象

### 正则表达式

- 什么是？

	- 匹配字符串，检索，验证，表单验证

- 创建方式

	- 1.var reg = new RegExp(/abc/)
	- 2.var reg = /abc/

- 组成

	- 简单字符和特殊字符【元字符】

- 边界符

	- n表示匹配行首的文本
	- $表示匹配行尾的文本

- 中括号

	- 例：var reg = /^[abc]$/    也可以写成    var reg = /^[a|b|c]$/

		- a或b或c
		- 多选1

	- ^   这个需要注意一下：括号外边是边界符，里面是取反的意思

- 量词符

	- *

		- 重复0次或者多次

	- .

		- 任意的

	- +

		- 最少一次

	- ？

		- 重复0次或者1次

	- {n}

		- 重复n次

	- {n，}

		- 重复n次或者更多次

	- {n，m}

		- 重复n到m次

- 括号总结

	- 大括号

		- 量词符

			- 表示重复里面的次数

	- 中括号

		- 匹配括号中的任意字符

	- 小括号

		- 表示优先级

## 一些重点问题

### 【ES6】Promise解决了什么问题及使用

- 【异步】Promise真正解决了什么？

	- 解决了回调地狱？

		- “回调地狱”所说的嵌套其实是指异步的嵌套。它带来了两个问题：可读性的问题和捕获错误问题。

	- 回调地狱的真正问题不是缩进

		- 可读性的问题

			- 代码逻辑书写顺序与执行顺序不一致，不利于阅读与维护。
			- 异步操作的顺序变更时，需要大规模的代码重构。
			- 回调函数基本都是匿名函数，bug 追踪困难。

		- 捕获错误问题

			- 控制反转

				- 在回调函数中，控制权被交给了第三方，由第三方决定什么时候调用回调以及如何调用回调。

			- 根本问题

				- 回调函数真正的问题是剥夺了程序员使用return和throw等捕捉错误和返回值的能力
				- 程序的执行流程是基于一个函数在执行过程中调用另一个函数时候会产生函数调用栈，而回调函数不是运行在栈上的，因此不能使用return和throw。

			- 代码的脆弱

				- 假设是这两个函数有顺序依赖的关系，我们要让A发生后B才执行，我们要把它们连接到一起的话只能手工硬编码
				- 这种方法会使得代码脆弱，你要在回调中捕获错误，必须在这个回调函数中创建大量逻辑来判断处理这些可能的情况，但这毫无疑问地会严重影响代码的可读性与开发效率。

			- 举例

				- 比如Ajax，可能会出现很多问题

					- 对于回调过早的问题
					- 对于回调过晚或没有调用的问题
					- 对于回调次数太少或太多的问题

			- 业界其他方案

				- （1）分离回调

					- 一个用于成功的处理函数，一个用于错误的处理函数！

				- （2）error-first风格，nodejs

					- 回调第一个参数作为错误对象(if exists)。 如果成功，error为 清空/置假 ，如果失败，if(err)为真。

				- 问题

					- 但这并没有解决 重复调用回调的问题。 你可能同时得到成功或失败的结果！ 或者都没有！ 
					- 事实上：你需要额外的写更多的逻辑来处理回调过快或者失败或者太慢的问题， 

	- 问题的解决

		- 如何解决可读性的问题

			- 链式调用相当于给了你一张可以把解题思路清晰记录下来的草稿纸，你不在需要用脑子去记忆执行顺序。

		- 如何解决捕获错误问题

			- Promise并没有取消控制反转，而是把反转出去的控制再反转一次，也就是反转了控制反转。
			- 与普通的回调的方式的区别

				- 普通的方式

					- 回调成功之后的操作直接写在了回调函数里面，而这些操作的调用由第三方控制。

				- Promise的方式

					- 回调只负责成功之后的通知，而回调成功之后的操作放在了then的回调里面，由Promise精确控制。
					- 反转控制反转

						- Promise 其实应验了 CS 的名言【所有问题都可以通过加一层中间层来解决】。在解决回调嵌套的问题中，Promise 就充当了一个中间层，用来【把回调造成的控制反转再反转回去】

					- 异步前后

						- 在使用 Promise 的例子中，控制流分为了两个部分：触发异步前的逻辑通过 new传入 Promise，而异步操作完成后的逻辑则传入 Promise 的 then 接口中。通过这种方式，第一方业务和第三方库的相应逻辑都由 Promise 来调用，进而在 Promise 中解决异步编程中可能出现的各种问题。

					- 接近观察者模式

						- 这种模式其实和观察者模式是接近的。下面的代码将 resolve / then 换成了 publish / subscribe ，将通过 new Promise 生成的 Promise 换成了通过 observe 生成的 observable 实例。可以发现，这种调用同样做到了回调嵌套的解耦。这就是 Promise 魔法的关键之一。

			- 解决传统回调的问题

				- 对于回调过早的问题

					- Promise不必担心，因为即使是立即完成的promise，对一个promise调用then的时候，即使这个promise已经resolution，提供给then的回调也总是异步调用的
					- 不需要setTimeout(,,0) hack, Promise不会导致竞态。

				- 对于回调过晚或没有调用的问题

					- Promise本身不会回调过晚，只要决议了，它就会按照规定运行。Promise创建对象调用resolve() 或reject() 的时候， 这个promise的then(…)注册的观察回调会被自动调度。 
					- 至于服务器或者网络的问题，并不是Promise能解决的，一般这种情况会使用Promise的竞态APIPromise.race加一个超时的时间

						- race()是一个解决如果Promise永远不能被resolved的解决方法

				- 对于回调次数太少或太多的问题

					- 回调被调用的正确次数应该是1。Promise的定义方式使得它只能被resolved 一次，如果处于某种原因。Promise创建的代码试图call resolve(…) or reject(..)多次， 那这个promise只会接收第一次resolved，并忽略后面的调用。 

			- Promise A+规范

				- 1. 如果promise被resolve，它要不是success就是failure，不可能同时存在。
				- 2. 一旦promise被resolve，它就再也不会被resolve(不会出现重复调用)。
				- 3. 如果promise返回了成功的信息，那么你绑定在成功事件上的回调会得到这个消息。
				- 4. 如果发生了错误，promise会收到一个带有错误信息的错误通知。
				- 5. 无论promise最后的结果是什么(success或者failure)，他就不会改变了，你总是可以获得这个消息只要你不销毁promise。

- 【异步】Promise的使用以及了解

	- （1）了解 Promise 吗？

		- Promise 是异步编程的一种解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。现已被 ES6 纳入进规范中。

	- （2）Promise 解决的痛点是什么？

		- 在 Promise 出现以前，我们处理一个异步网络请求，大概是这样：

			- 我们基本上还要对每次请求的结果进行一些处理，代码会更加臃肿，在一个团队中，代码 review 以及后续的维护将会是一个很痛苦的过程。

		- 回调地狱带来的负面作用有以下几点：

			- 代码臃肿。
			- 可读性差。
			- 耦合度过高，可维护性差。
			- 代码复用性差。
			- 容易滋生 bug。
			- 只能在回调里处理异常。

		- 出现了问题，自然就会有人去想办法。这时，就有人思考了，能不能用一种更加友好的代码组织方式，解决异步嵌套的问题。

	- （3）Promise 解决的痛点还有其他方法可以解决吗？如果有，请列举。
	- （4）Promise 如何使用？

		-  Promise 的常规写法：

			- 比较一下这种写法和上面的回调式的写法。我们不难发现，Promise 的写法更为直观，并且能够在外层捕获异步函数的异常信息。

		- 用法举例

			- 一，需求方法步骤

				- 你先去超市买菜。
				- 用超市买回来的菜做饭。
				- 将做好的饭菜送到老婆单位。
				- 送到单位后打电话告诉我。

			- 二，写好函数

			- 三，利用promise实现功能

			- 注意：请一定要谨记：如果我们的后续任务是异步任务的话，必须return 一个 新的 promise 对象。如果后续任务是同步任务，只需 return 一个结果即可。

我们上面举的例子，除了电话通知我是一个同步任务，其余的都是异步任务，异步任务 return 的是 promise对象。

		- 使用总结

			- 
（1）首先初始化一个 Promise 对象，可以通过两种方式创建， 这两种方式都会返回一个 Promise 对象。

				- 1、new Promise(fn)
				- 2、Promise.resolve(fn)

			- （2）然后调用上一步返回的 promise 对象的 then 方法，注册回调函数。

				- then 中的回调函数可以有一个参数，也可以不带参数。如果 then 中的回调函数依赖上一步的返回结果，那么要带上参数。比如
			- （3）最后注册 catch 异常处理函数，处理前面回调中可能抛出的异常。

	- （5）Promise 常用的方法，方法的作用？

		- Promise.resolve(value)

			- 有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用。

				- Promise.resolve等价于下面的写法。

			- 1、如果这个值是个thenable（即带有then方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态（指 resolved/rejected/pending/settled）

			- 2、如果传入的 value 本身就是 promise 对象，则该对象作为 Promise.resolve 方法的返回值返回。

			- 3、其他情况以该值为成功状态返回一个 promise 对象。

		- Promise.reject(value)

			- 与 resolve 唯一的不同是，返回的 promise 对象的状态为 rejected。

		- Promise.then

			- 为 promise 注册回调函数，函数形式：fn(vlaue){}，value 是上一个任务的返回结果，then 中的函数一定要 return 一个结果或者一个新的 Promise 对象，才可以让之后的then 回调接收。

		- Promise.catch

			- 捕获异常，函数形式：fn(err){}, err 是 catch注册 之前的回调抛出的异常信息。

		- Promise.race

			- 多个promise 任务同时执行，只返回最先执行完的 Promise 任务的结果。 

		- Promise.all

			- 多个promise 任务同时执行，返回所有promise 任务的执行结果。

	- （6）Promise 在事件循环中的执行过程是怎样的？
	- （7）Promise 的升级

		- ES6 出现了 generator 以及 async/await 语法，使异步处理更加接近同步代码写法，可读性更好，同时异常捕获和同步代码的书写趋于一致。
	- （8）能不能手写一个 Promise 的polyfill。

### 【ES6】说出你知道的ES6新特性

- ES6常考问题

	- 为什么const定义一个数组与对象，仍然可以对其操作?

		- const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。
		- 对于简单类型的数据（数值、字符串、布尔值）

			- 值就保存在变量指向的那个内存地址，因此等同于常量。

		- 对于复合类型的数据（主要是对象和数组）

			- 变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了
			- 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。

			- 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。

			- 如果真的想将对象冻结，应该使用Object.freeze方法。

				- 上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。
				- 除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。

- Promise

	- 什么是Promise？

		- 传统的异步编程最大的特点就是地狱般的回调嵌套，一旦嵌套次数过多，就很容易使我们的代码难以理解和维护。而Promise则可以让我们通过链式调用的方法去解决回调嵌套的问题，使我们的代码更容易理解和维护，而且Promise还增加了许多有用的特性，让我们处理异步编程得心应手。
		- 传统的异步回调函数

			- （1）每个回调函数，都会无法确定另一个回调函数会在何时会被调用，因为这个控制权不在当前这个程序之中。
			- （2）每个回调函数，都或多或少的依赖于上一个回调函数执行的时间和数据
			- 问题

				- 基于这两点，我们就会发现，一旦你需要这样去编写代码，就必须保证你的上一个回调函数在下一个回调函数之前进行。我们还可以发现，它们之间缺乏一种约定，就是一旦上一个发生了，无论是正确还是错误，都会通知对应的回调函数的约定。

	- 如何创建Promise？

		- 代码示例

		- 代码解释

			- （1）因为Promise是一个构造函数，所以我们使用了new操作符来创建promise。
			- （2）构造函数Promise的参数是一个函数（暂时叫它func），这个函数（func）有两个参数resolve和reject，它们分别是两个函数，这两个函数的作用就是将promise的状态从pending（等待）转换为resolved（已解决）或者从pending（等待）转换为rejected（已失败）。
			- （3）创建后的promise有一些方法，then和catch。当然我们也可以人为的在Promise函数上添加一些满足我们自己需求的方法，方便每一个promise对象使用。

		- 理解Promise

			- Promise函数体的内部包裹着一个异步的请求或者操作或者函数；然后我们可以在这个异步的操作完成的时候使用resolve函数将我们获得的结果传递出去，或者使用reject函数将错误的消息传递出去。

	- Promise对象的一些方法

		- then方法

			- 初步了解

				- 可以通过使用then方法将上一步返回的结果获取过来（不管是resolved还是rejected）

			- then方法的使用

				- 示例1

					- 也就是说，我们在创建p这个Promise对象的时候，通过函数resolve传递出去的结果可以被p的第一个then方法中的第一个函数捕获然后作为它的参数。通过函数reject传递出去的结果可以被p的第一个then方法中的第二个函数捕获然后作为它的参数。

				- （1）then方法可以接受两个函数作为参数，第一个函数是用来处理resolve的结果，第二个是可选的，用来处理reject的结果。
				- 示例2

					- 一旦创建一个Promise对象之后，我们就可以使用then方法来进行链式的调用，而且我们可以把每一次的结果都返还给下一个then方法，然后在下一个then方法中对这个值进行处理。每一个then方法中都可以再次新创建一个Promise对象，然后返还给下一个then方法处理。

				- （2）还可以在每一个then方法中创建新的Promise，然后将这个Promise对象返回，之后我们就可以在后面的then方法中继续对这个对象进行操作。

		- catch方法

			- 初步了解

				- 这个方法其实是then方法的一种特例，这个特例就是：.then(null, rejection)，相当于我们不使用then方法的第一个函数，只是用第二个函数；catch函数比较简单，就是用来捕获之前的then方法里面的异常

		- all方法

			- 初步了解

				- 
Promise.all方法用来包装许多个Promise实例，然后组成了一个新的Promise对象
				- 新的Promise对象的状态由前面几个被包裹的Promise对象的状态决定，如果前面的Promise都被resolve了，那么新的Promise的状态也是resolve的；只要有一个Promise被reject了，那么组成的新的Promise的状态也是reject的。

			- 方法的使用

		- race方法

			- 初步了解

				- 和上面的Promise.all有点类似，都是包装许多的Promise对象，然后组成了一个新的Promise对象
				- 但是使用Promise.race的含义是：只要包裹的的Promise对象中有一个的状态发生了改变，那么组成的这个新的Promise对象的状态就是上面那个率先改变的Promise实例的状态。

			- 方法的使用

		- resolve方法

			- 初步了解

				- 主要是将一个值转变为一个Promise对象，然后使它具有Promise的一些方法和特性，为了满足我们一些特殊情况下的要求。

			- 方法的使用

		- reject方法

			- 初步了解

				- 和Promise.resolve方法一样，只不过通过Promise.reject方法产生的Promise对象的状态是rejected的，

- let与const

	- （1）在同一个块级作用域中，不允许重复定义。
	- （2）const定义的变量不允许二次修改。
	- （3）let和const定义的变量会形成块级作用域
	- （4）它们定义的变量不存在变量提升，以及存在暂时性死区

- 函数的变化——箭头函数，剩余参数，参数默认值

	- 箭头函数

		- 规则

			- （1）变量如果只有一个的时候，可以省略()
			- （2）如果是只有一句返回语句时，可以直接省略{return }这一部分
			- （3）因为它本身叫做arrow，所以每次都必须带上=>符号

		- 注意事项

			- （1）箭头函数不能作为构造函数

			- （2）箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域。（取决于箭头函数定义时的作用域，不受apply，call，bind影响）

			- （3）箭头函数没有arguments。

	- rest剩余参数

		- ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。
		- 注意

			- （1）与扩展运算符相反

				- 扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。

			- （2）rest 参数之后不能再有其他参数（即只能是最后一个参数）
			- （3）arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组

	- 参数默认值

		- ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。

- 数组——解构赋值、二进制数组

	- 解构赋值

		- 注意

			- （1）必须保证有赋值的过程。

			- （2）左边内容部分的结构必须与右边保持一致。

		- 使用

			- （1）默认值的使用。

			- （2）在变量中使用解构赋值

	- 二进制数组

- 字符串——模版字符串、startsWith、endsWith

	- startWith

		- 用法

			- 返回值为boolean型，然后去匹配字符串开头的部分

		- 使用

			- 这个API仅仅在一些场景下起到一定的便捷。比方说，我们需要去匹配一个URL的协议头是什么时，我们往往需要用到这种方式。

	- endsWith

		- 用法

			- 返回值是boolean类型，然后去匹配字符串的结尾。

		- 使用

			- 这种情况的使用场景是，往往我们需要为上传的文件准备图标，那么我们就可以根据后缀来确定图标。

- Class和extends

	- ES6的class是一种更简洁的语法糖，JS面向对象编程依然是基于原型实现的

		- ES5中声明类的方式

		- 利用class语法糖

	- extends类的继承，我们可以用extends扩展一个类并继承它的行为，在构造函数中，也可以通过super关键字引用父类的构造函数

### 【This】JavaScript This 关键字的理解？以及call、apply、bind

- this

	- （1）this的定义

		- this是在执行上下文创建时确定的一个在执行过程中不可更改的变量。
		- 执行上下文

			- 就是JavaScript引擎在执行一段代码之前将代码内部会用到的一些变量、函数、this提前声明然后保存在变量对象中的过程。
			- 这个'代码片段'包括：全局代码(script标签内部的代码)、函数内部代码、eval内部代码。而我们所熟知的作用域链也会在保存在这里，以一个类数组的形式存储在对应函数的[[Scopes]]属性中。

		- this的多变性

			- this只在函数调用阶段确定，也就是执行上下文创建的阶段进行赋值，保存在变量对象中。这个特性也导致了this的多变性:即当函数在不同的调用方式下都可能会导致this的值不同。

	- （2）严格模式与非严格模式下

		- 当函数独立调用的时候，在严格模式下它的this指向undefined，在非严格模式下，当this指向undefined的时候，自动指向全局对象(浏览器中就是window)

	- （3）函数的四种调用方式

		- 在全局环境或是普通函数中直接调用

			- 需要特别注意的情况

				- window, 自执行函数调用时,没有宿主对象,默认是window
				- 解释，自执行函数需要外部函数调用才会执行

				- 与此种情况相同（当函数独立调用的时候，在严格模式下它的this指向undefined，在非严格模式下，当this指向undefined的时候，自动指向全局对象(浏览器中就是window)。）

		- 作为对象的方法

			- 需要注意隐式丢失

				- （1）

				- （2）

				- obj对象的属性存储的是对该匿名函数的一个引用，可以理解为一个指针。当赋值给其他变量的时候，并没有单独开辟内存空间存储新的函数，而是让其存储了一个指针，此时的obj2就是一个指向匿名函数的指针，调用obj2，相当于直接调用fun，

		- 使用apply和call
		- 作为构造函数

			- 使用new命令时，它后面的函数调用就不是正常的调用，而是依次执行下面的步骤。

				- （1）创建一个空对象，作为将要返回的对象实例
				- （2）将这个空对象的原型，指向构造函数的prototype属性
				- （3）将这个空对象赋值给函数内部的this关键字
				- （4）开始执行构造函数内部的代码，并且返回这个对象

			- 当this碰到return时

				- 如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。
	- （4）箭头函数

		- （1）箭头函数中的this固定，箭头函数是根据外层（函数或者全局）作用域来决定this

			- 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。this对象的指向是可变的，但是在箭头函数中，它是固定的。

		- （2）实质上箭头函数没有自己的this，不能作为构造函数

			- this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。

		- （3）由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。
		- 理解

			- 1.箭头函数作为对象的方法

				- 作用域根据外层，即对象所在作用域

			- 2.箭头函数作为函数的返回值或者构造函数的方法

				- 作用域根据外层，即其父函数本身的函数作用域

			- 3.箭头函数作为回调函数

				- 一层箭头函数

				- 多层嵌套的箭头函数

				- 复杂情况: 普通函数和箭头函数混杂嵌套

				- 严格模式下的情况

- bind与call，apply的区别

	- 
bind 返回的是一个函数,并没有执行原函数,只是这个函数的this指向了你给的参数
	- apply ，call是执行函数,这个函数的this指向了你给的第一个参数

### 【闭包】什么是闭包及其应用场景

- 关于闭包的黄金理解

	- （1）JavaScript中的闭包，无非就是变量解析的过程。

	  每次定义一个函数，都会产生一个作用域链（scope chain）。当JavaScript寻找变量varible时（这个过程称为变量解析），总会优先在当前作用域链的第一个对象中查找属性varible ，如果找到，则直接使用这个属性；否则，继续查找下一个对象的是否存在这个属性；这个过程会持续直至找到这个属性或者最终未找到引发错误为止。

	  

	- （2）JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。

- 闭包的形成与变量的作用域以及变量的生存周期密切相关

	- 变量的作用域

		- （1）全局作用域
		- （2）函数作用域

	- 变量的生存周期

		- （1）对于全局作用域来说，生命周期是永久的，除非你主动销毁
		- （2）对于函数内的局部变量来说，随着函数调用的结束而被销毁
		- 当创建闭包时，函数执行完毕，局部变量并没有消失，这是因为在闭包里返回了一个函数的引用，它可以访问调用到原闭包（外层）函数所产生的环境，而局部变量一直处于这个环境之中，既然局部变量所在的函数还能被外界所访问到，这个局部变量就有了不被销毁的理由，在这里产生了一个闭包结构，局部变量的生命看起来被延续了

- 闭包的应用

	- （1）管理私有变量和私有方法，将对变量（状态）的变化封装在安全的环境中
	- （2）将代码封装成一个闭包形式，等待时机成熟的时候再使用，比如实现柯里化和反柯里化

		- 函数柯里化

			- 柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。

- 闭包引发的问题

	- 
闭包和内存泄露有关系的地方是，使用闭包的同时比较容易造成循环引用，如果闭包的作用域链中保存着一些DOM节点，这时候就有可能造成内存泄漏

		- 解决：把循环引用中的变量设为null即可，即为切断变量和它此前引用的值之间的连接，当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存
		- 举个例子

		- 解决

	- 关于JS内存泄露

		- （1）什么是内存泄漏？

			- 程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。
			- 对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。
			- 不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。

		- （2）垃圾回收机制

			- 存在理由

				- 有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。
				- 这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为"垃圾回收机制"（garbage collector）。

			- JS中的垃圾回收机制

				- （1）标记清除（现代浏览器使用）

					- 通常javascript通过标记变量的状态来判断是否被回收,当变量在函数中被声明时标记进入环境,在函数执行结束时,环境被销毁标记离开环境等待回收.只要不释放进入环境的变量,他在环境中的任何位置任何时刻都可以被访问,就不会被垃圾回收机所回收.

					- 标记清除算法将“不再使用的对象”定义为“无法达到的对象”

						- 简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。

					- 问题

						- 对现代浏览器来说，唯一要注意的就是明确切断需要回收的对象与根部的联系。有时候这种联系并不明显，且因为标记清除算法的强壮性，这个问题较少出现。最常见的内存泄露一般都与DOM元素绑定有关：

							- div元素已经从DOM树中清除，也就是说从DOM树的根部无法触及该div元素了。但是请注意，div元素同时也绑定了email对象。所以只要email对象还存在，该div元素将一直保存在内存中。

				- （2）引用计数（IE）

					- javascript去维护一张表,存储内存中资源的引用次数,资源被引用+1,结束引用或者函数执行完毕结束作用域,引用次数-1,引用次数由1到0时不会执行,节省开销,直接标记

					- 问题

						- 这个方式存在一个比较大的问题就是循环引用，就是说A对象包含一个指向B的指针，对象B也包含一个指向A的引用。 这就可能造成大量内存得不到回收（内存泄露），因为它们的引用次数永远不可能是 0 。
						- 例子

							- 执行这段代码的时候，将匿名函数对象赋值给el的onclick属性；然后匿名函数内部又引用了el对象，存在循环引用，所以不能被回收；

						- 解决方法：

		- （3）内存泄漏的识别方法

			- 1、经验方法

				- 如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。 这要我们实时查看内存占用。

			- 2、浏览器方法

				- 1）打开开发者工具，选择 Timeline 面板
				- 2）在顶部的Capture字段里面勾选 Memory
				- 3）点击左上角的录制按钮。
				- 4）在页面上进行各种操作，模拟用户的使用情况。
				- 4）一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。
				- 如果内存占用基本平稳，接近水平，就说明不存在内存泄漏。 反之，就是内存泄漏了。

			- 3、命令行方法

				- 命令行可以使用 Node 提供的 process.memoryUsage 方法。（判断内存泄漏，以heapUsed字段为准。）
					- rss（resident set size）：所有内存占用，包括指令区和堆栈。
					- heapTotal："堆"占用的内存，包括用到的和没用到的。
					- heapUsed：用到的堆的部分。
					- external： V8 引擎内部的 C++ 对象占用的内存。

		- （4）WeakMap

			- 问题的提出

				- 及时清除引用非常重要。但是，你不可能记得那么多，有时候一疏忽就忘了，所以才有那么多内存泄漏。
				- 最好能有一种方法，在新建引用的时候就声明，哪些引用必须手动清除，哪些引用可以忽略不计，当其他引用消失以后，垃圾回收机制就可以释放内存。这样就能大大减轻程序员的负担，你只要清除主要引用就可以了。

			- ES6的弱引用

				- ES6 考虑到了这一点，推出了两种新的数据结构：WeakSet 和 WeakMap。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个"Weak"，表示这是弱引用。

			- 使用

				- 解释

					- 先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。
					- 也就是说，DOM 节点对象的引用计数是1，而不是2。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。

				- 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。

### 【防抖与节流】JS中的函数防抖与节流

- 函数防抖

	- 解释

		- 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

	- 实现

- 函数节流

	- 解释

		- 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。

	- 实现

- 区别以及应用场景

	- 区别

		- 假设，我们观察的总时间为10秒钟，规定1秒作为一次事件的最小间隔时间。

			- 如果触发事件的频率是 0.5s/次，那么

				- 函数防抖

					- 因为始终没法等一秒钟就被再次触发了，所以最终没有一次事件是成功的。

				- 函数节流

					- 因为控制了最多一秒一次，频率为0.5s/次，所以每一秒钟就有一次事件作废。最终控制成1s/次

			- 如果触发事件的频率是 2s/次，那么

				- 函数防抖

					- 因为2s/次已经大于了规定的最小时间，所以每计时两秒便触发一次。

				- 函数节流

					- 同样，2s/次 大于了最小时间规定，所以每一次触发都生效。

	- 应用场景

		- 函数防抖（哪些时候对于连续的事件响应我们只需要执行一次回调？）

			- 适合多次事件一次响应的情况

				- 
（1）文本输入的验证（连续输入文字后发送 AJAX 请求进行验证，验证一次就好）
				- （2）判断scroll是否滑到底部，滚动事件+函数防抖
				- （3）调节浏览器size，监听resize()函数

					- 对于浏览器窗口，每做一次 resize 操作，发送一个请求，很显然，我们需要监听 resize 事件，但是和 mousemove 一样，每缩小（或者放大）一次浏览器，实际上会触发 N 多次的 resize 事件，用节流？节流只能保证定时触发，我们一次就好，这就要用去抖。

			- 简单的说，函数去抖就是对于一定时间段的连续的函数调用，只让其执行一次。

		- 函数节流（哪些时候我们需要间隔一定时间触发回调来控制函数调用频率？）

			- 适合大量事件按时间做平均分配触发

				- （1）DOM 元素的拖拽功能实现（mousemove）

					- 实现一个原生的拖拽功能（不能用 H5 Drag&Drop API），需要一路监听 mousemove 事件，在回调中获取元素当前位置，然后重置 dom 的位置（样式改变）。如果我们不加以控制，每移动一定像素而触发的回调数量是会非常惊人的，回调中又伴随着 DOM 操作，继而引发浏览器的重排与重绘，性能差的浏览器可能就会直接假死，这样的用户体验是非常糟糕的。我们需要做的是降低触发回调的频率，比如让它 500ms 触发一次，或者 200ms，甚至 100ms，这个阈值不能太大，太大了拖拽就会失真，也不能太小，太小了低版本浏览器可能就会假死，这样的解决方案就是函数节流，英文名字叫「throttle」。

				- （2）射击游戏的 mousedown/keydown 事件（单位时间只能发射一颗子弹）
				- （3）计算鼠标移动的距离（mousemove）
				- （4）Canvas 模拟画板功能（mousemove）
				- （5）搜索联想（keyup）
				- （6）监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次

			- 函数节流的核心是，让一个函数不要执行得太频繁，减少一些过快的调用来节流。

### 【深浅拷贝】JavaScript 对象的浅拷贝和深拷贝区别？

- 怎么判断两个对象相等？

	- 浅度比较

		- 使用JSON.stringify序列化一个对象时

			- （1）序列化后的属性出现的顺序是不定的，除了数组中的元素-其按数组中位置顺序序列化
			- （2）Boolean/Number/String对象转成其原始值
			- （3）如果属性值为undefined、函数对象，symbol(ES6中新类型)，那么这个属性要么在序列化的时候被忽略，要么被转成null（当在数组中出现时）
			- （4）以symbol类型为属性key的属性被完全忽略
			- （5）不可枚举的属性也被忽略

	- 深度比较

		- underscore中的eq函数源码

- 浅拷贝

	- 定义

		- 只会将对象的各个属性进行依次复制，并不会进行递归复制，而js存储对象都是存地址的，所以浅复制会导致old.c和new.c 指向同一块内存地址；会导致引用。

	- 实现

		- （1）简单的赋值语句

		- （2）Object.assign(目标对象，源对象)

			- Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign() 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。

- 深拷贝

	- 定义

		- 它不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上。这就不会存在上面old和new的c属性指向同一个对象的问题。

	- 实现

		- （1）JSON.parse()方法

			- 使用JSON.stringify进行序列化，JSON.parse进行反序列化，实现"偷懒版"的深复制
			- 坏处：

				- （1）它会抛弃对象的constructor。也就是深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成Object。
				- （2）这种方法能正确处理的对象只有 Number, String, Boolean, Array, 扁平对象，即那些能够被 json 直接表示的数据结构。RegExp对象是无法通过这种方式深拷贝。
				- （3）用此法无法深复制对象中的方法

					- 原因是 一个对象 上可能还有很多其他的无法被转为json string的东西

				- （4）通过 deep clone 一般都是有限定复制层次的，一般情况下不会无限层的复制下去。如果使用 JSON 方式来复制，通常不能控制层次。

			- JSON.parse()是怎么实现深拷贝的？

				- var a = JSON.stringify(oldObject)  
// a是一个oldObject序列化后得到的字符串 和 oldObject没任何关系的新对象
				- var b = JSON.parse(a); 
// b 是从字符串a反序列化为一个全新的对象 所以 不但和a没关系 和oldObject更没关系
				- 序列化是一种将对象以一连串的字节描述的过程；反序列化是一种将这些字节重建成一个对象的过程

		- （2）使用递归拷贝

			- 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况

		- （3）$.extend()的深拷贝和浅拷贝

			- 用法

			- $.extend()的浅拷贝

				- 如果第二个参数对象有的属性第一个参数对象也有，那么不会进行相同参数内部的比较，直接将第一个对象的相同参数覆盖。

			- $.extend()的深拷贝

				- ：如果第二个参数对象有的属性第一个参数对象也有，还要继续在这个相同的参数向下一层找，比较相同参数的对象中是否还有不一样的属性，如果有，将其继承到第一个对象，如果没有，则覆盖。

- 区别？

	- 
浅复制只复制一层对象的属性，而深复制则递归复制了所有层级。浅复制是对对象地址的复制，而深复制则是让其指向不同的堆内存
	- 浅拷贝

		- 深拷贝

- 堆内存与栈内存

	- 为什么会有栈内存和堆内存之分？

		- 通常与垃圾回收机制有关。为了使程序运行时占用的内存最小。
		- stack为自动分配的内存空间，它由系统自动释放；而heap则是动态分配的内存，大小不定也不会自动释放。　

	- 什么存于栈内存？什么存于堆内存？

		- 当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；
		- 当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。

	- 区别

		- 栈中存储的是基础变量以及一些对象的引用变量，基础变量的值是存储在栈中，而引用变量存储在栈中的是指向堆中的数组或者对象的地址，这就是为何修改引用类型总会影响到其他指向这个地址的引用变量。

### 【事件流】什么是事件流，事件代理委托原理

- 事件流

	- 定义

		-  事件流描述的是从页面中接受事件的顺序
		- document.querySelector(）

			- 如果没有找到匹配元素，则返回 null，如果找到多个匹配元素，则返回第一个匹配到的元素。

		- target.addEventListener(type, listener[, useCapture])

			- 接受三个参数。

				- type：事件名称，大小写敏感。
				- listener：监听函数。事件发生时，会调用该监听函数。
				- useCapture：布尔值，表示监听函数是否在捕获阶段（capture）触发，默认为false（监听函数只在冒泡阶段被触发）。

	- 事件捕获的三个阶段

		- 事件捕获阶段
		- 目标阶段
		- 事件冒泡阶段

	- Event对象的常见应用

		- 取消事件的默认行为

			- event.preventDefault()

		- 取消事件的进一步捕获或冒泡

			- event.stopPropagation()

		- 处理事件响应优先级

			- event.stopImmediatePropagation()

		- 当前被绑定事件的对象

			- event.currentTarget

		- 当前被点击的对象

			- event.target

- 事件的代理

	- 原理

		- 事件代理就是在祖先级DOM元素绑定一个事件，当触发子孙级DOM元素的事件时，利用事件流的原理来触发绑定在祖先级DOM的事件。

	- 检查事件源event.target

### 【面试：JS运行机制】

- 【面试：JS 执行机制】这一次，彻底弄懂 JavaScript 执行机制

	- 关于多线程

		- 一切javascript版的"多线程"都是用单线程模拟出来的

	- javascript事件循环

		- 同步任务

			- 当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。

		- 异步任务

			- 而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。

			- （1）同步和异步任务分别进入不同的执行"场所"，同步的进入主线程，异步的进入Event Table并注册函数。
			- （2）当指定的事情完成时，Event Table会将这个函数移入Event Queue（事件队列）。
			- （3）主线程内的任务执行完毕为空，会去Event Queue（事件队列）读取对应的回调函数，进入主线程执行。
			- （4）上述过程会不断重复，也就是常说的Event Loop(事件循环)。

		- 怎么知道主线程执行栈为空啊？

			- js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。

- 【面试：JS 执行机制】从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理

	- 区分进程和线程

		- 
- 进程是一个工厂，工厂有它的独立资源 -> 系统分配的内存（独立的一块内存）
		- - 工厂之间相互独立 -> 进程之间相互独立
		- - 线程是工厂中的工人，多个工人协作完成任务 -> 多个线程在进程中协作完成任务
		- - 工厂内有一个或多个工人 -> 一个进程由一个或多个线程组成
		- - 工人之间共享空间 -> 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）
		- 线程与进程

			- 
进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）
			- 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）

		- tips

			- 
不同进程之间也可以通信，不过代价较大
			- 现在，一般通用的叫法：单线程与多线程，都是指在一个进程内的单和多。（所以核心还是得属于一个进程才行）

	- 浏览器是多进程的

		- 初步认知

			- 
浏览器是多进程的
			- 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）
			- 简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。

		- 浏览器都包含哪些进程？

			- Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有

				- 负责浏览器界面显示，与用户交互。如前进，后退等
				- 负责各个页面的管理，创建和销毁其他进程
				- 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上
				- 网络资源的管理，下载等

			- 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
			- GPU进程：最多一个，用于3D绘制等
			- 浏览器渲染进程（浏览器内核）（Render进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为页面渲染，脚本执行，事件处理等

		- 浏览器多进程的优势

			- 避免单个page crash影响整个浏览器
			- 避免第三方插件crash影响整个浏览器
			- 多进程充分利用多核优势
			- 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性
			- 简单理解

				- 如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。当然，内存等资源消耗也会更大，有点空间换时间的意思。

					- orw83p

		- 重点是浏览器内核（Renderer渲染进程）

			- 初步认知

				- 对于普通的前端操作来说，最终要的是渲染进程，页面的渲染，JS的执行，事件的循环，都在这个进程内进行

			- 该进程包含线程有：

				- GUI渲染线程

					- 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
					- 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
					- 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。

				- JS引擎线程

					- 
也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）
					- JS引擎线程负责解析Javascript脚本，运行代码。
					- JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序
					- 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

				- 事件触发线程

					- 
归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）
					- 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中
					- 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
					- 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）

				- 定时触发器线程

					- 
传说中的setInterval与setTimeout所在线程
					- 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
					- 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
					- 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。

				- 异步http请求线程

					- 
在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
					- 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。

		- Browser进程和浏览器内核（Renderer进程）的通信过程

			- 初步理解

				- 
如果自己打开任务管理器，然后打开一个浏览器，就可以看到：任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程）

			- 整个过程

				- Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程
				- Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染

					- 渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染
					- 当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）
					- 最后Render进程将结果传递给Browser进程

				- Browser进程接收到结果并将结果绘制出来

	- 梳理浏览器内核中线程之间的关系

		- GUI渲染线程与JS引擎线程互斥

			- 
由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。
			- 因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。

		- JS阻塞页面加载

			- 
假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。 然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。
			- 所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。

		- WebWorker，JS的多线程？

			- 初步理解

				- 前文中有提到JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？

			- Web Worker

				- 
创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）
				- JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）
				- 所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程，只待计算出结果后，将结果通信给主线程即可，perfect!

			- WebWorker与SharedWorker

				- Web Worker

					- WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享
					- 所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。

				- SharedWorker

					- SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用
					- 所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。

				- 本质上就是进程和线程的区别。SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程

	- 简单梳理下浏览器渲染流程

		- 前期工作

			- 浏览器输入url，浏览器主进程接管，开一个下载线程，然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，随后将内容通过RendererHost接口转交给Renderer进程

- 浏览器渲染流程开始

		- 浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤

			- 解析html建立dom树
			- 解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）
			- 布局render树（Layout/reflow），负责各元素尺寸、位置的计算
			- 绘制render树（paint），绘制页面像素信息
			- 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。
			- 渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了

		- load事件与DOMContentLoaded事件的先后

			- 当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。 (譬如如果有async加载的脚本就不一定完成)
			- 当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。 （渲染完毕了）
			- 顺序是：DOMContentLoaded -> load

		- CSS加载（头部引入CSS时）是否会阻塞DOM树渲染？

		  因为你加载css的时候，可能会修改下面DOM节点的样式，

		  如果css加载不阻塞render树渲染的话，那么当css加载完之后，

		  render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。

		  所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后，

		  在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。

			- css是由单独的下载线程异步下载的。
			- css加载不会阻塞DOM树解析（异步加载时DOM照常构建）
			- 但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）

		- 普通图层和复合图层

			- 浏览器渲染的图层一般包含两大类：普通图层以及复合图层
			- 首先，普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中）
			- 其次，absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层。
			- 然后，可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源 （当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）
			- 可以简单理解下：GPU中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒
			- 【重点！！！】如何变成复合图层（硬件加速）

				- （1）最常用的方式：translate3d、translateZ
				- （2）opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）
				- （3）will-chang属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）
				- （4）<video><iframe><canvas><webgl>等元素
				- （5）其它，譬如以前的flash插件

			- absolute和硬件加速的区别

				- absolute虽然可以脱离普通文档流，但是无法脱离默认复合层。所以，就算absolute中信息改变时不会改变普通文档流中render树，但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。（浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的）
				- 而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层 （当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）

			- 复合图层的作用？

				- 一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能
				- 但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡

	- 从Event Loop谈JS的运行机制

		- 发生时机

			- 到此时，已经是属于浏览器页面初次渲染完毕后的事情，JS引擎的一些运行机制分析。

		- Event Loop（事件循环机制的核心是：JS引擎线程和事件触发线程）

			- JS分为同步任务和异步任务
			- 同步任务都在主线程上执行，形成一个执行栈
			- 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。
			- 一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。

		- 单独说说定时器

			- 为什么需要定时器线程？

				- 为什么要单独的定时器线程？因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时。

			- 什么时候会用到定时器线程？

				- 当使用setTimeout或setInterval时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。

			- 代码的执行情况

			- setTimeout而不是setInterval

				- setTimeout

					- 每次setTimeout计时到后就会去执行，然后执行一段时间后才会继续setTimeout，中间就多了误差 （误差多少与代码执行时间有关）

				- setInterval

					- setInterval则是每次都精确的隔一段时间推入一个事件 （但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了）
					- JS引擎会对setInterval进行优化，如果当前事件队列中有setInterval的回调，不会重复添加。不过，仍然是有很多问题。。。

			- 事件循环进阶：macrotask与microtask

				- 初步认识

					- 
JS中分为两种任务类型：macrotask和microtask，在ECMAScript中，microtask称为jobs，macrotask可称为task

				- macrotask（又称之为宏任务）

					- 可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）
					- 每一个task会从头到尾将这个任务执行完毕，不会执行其它
					- 浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染 （task->渲染->task->...）

				- microtask（又称为微任务）

					- 可以理解是在当前 task 执行结束后立即执行的任务
					- 也就是说，在当前task任务后，下一个task之前，在渲染之前
					- 所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染
					- 也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）

				- 什么样的场景会形成macrotask和microtask？

					- macrotask：主进程，setTimeout，setInterval，setImmediate, I/O, rendering等（可以看到，事件队列中的每一个事件都是一个macrotask）
					- microtask：Promise，process.nextTick，Object.observe, MutationObserver等

				- 各自使用时机？

					- 至于什么时候需要使用 microtask 呢? 我觉得这个问题很好地指出两者(macrotask, microtask)的不同, 在你觉得需要将这个异步任务同步化的时候, 就使用
microtask , 否则就使用 macrotask.换种说法, 也就是这个任务你需要尽可能快地执行, 就使用 microtask.

				- 补充：在node环境下，process.nextTick的优先级高于Promise，也就是可以简单理解为：在宏任务结束后会先执行微任务队列中的nextTickQueue部分，然后才会执行微任务中的Promise部分。
				- 小测试加补充：setTimeout触发时机不明，受机器与运行环境影响很大，产生很多不确定的因素。

### 【异步设计】探寻JavaScript的异步设计（理解性）

- 开始

	- 一切得先从CPU开始讲起，CPU的指令执行速度是远高于硬盘读取速度和主存读取速度的。而I/O操作就会涉及到硬盘存取和主存读取，常见的I/O操作有文件I/O,网络I/O。(I/O = Input / Output)。
	- 所以，观察以下这一段伪代码：

		- 在CPU眼中，他会把代码看成这两部分：

			- 绿色部分因为不涉及到I/O操作，所以CPU执行速度超快，但是当运行到红色部分时，却是一个非常耗时的操作，而这段时间，CPU是处于一个’无所事事’的状态（DMA获取总线控制权之后一切I/O与CPU无关），因为文件如果没有读取进来，下面的工作也无法开展。

	- 同步在这里的意思，即书写代码的顺序就是代码执行的顺序，如果JavaScript设计成同步的话，那么当执行到openFile这一行的时候，将会等待该I/O操作完成CPU才继续往下执行。

		- 设想一下，当发送Ajax请求(网络I/O)的时候，整个页面被阻塞无法操作将会是多差的体验。
		- 而诸如鼠标点击事件，滑动事件，失焦事件，在CPU看来，都是处理得特别慢的事件（虽然对我们来说是一瞬间的事情），如果将JavaScript设计成同步，也会特别浪费CPU性能。

	- 而阻塞和非阻塞关注CPU在I/O发生时的工作情况

		- 怎样理解阻塞非阻塞与同步异步的区别？

			- 1.同步与异步

				- 概述

					- 同步和异步关注的是消息通信机制

				- 同步

					- 就是在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了。
					- 换句话说，就是由*调用者*主动等待这个*调用*的结果。

				- 异步

					- 相反，*调用*在发出之后，这个调用就直接返回了，所以没有返回结果。
					- 换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在*调用*发出后，*被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用。

				- 举个通俗的例子

					- 你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。
					- 而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。

			- 2. 阻塞与非阻塞

				- 概述

					- 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.

				- 阻塞

					- 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。

				- 非阻塞

					- 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

				- 还是上面的例子

					- 你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果
					- 如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。
					- 在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。

			- 阻塞和非阻塞，应该描述的是一种状态，同步与非同步描述的是行为方式

		- 阻塞式

			- 在上面这个读取文件的例子中，如果在读取文件的同时，该线程被‘挂起’（可以理解为进程的阻塞态），CPU不在关注这个线程直到结果被返回，属于阻塞式

		- 非阻塞式

			- 如果在读取文件的同时，CPU会时不时关注并检查一遍结果是否返回，则属于非阻塞式

	- 异步则解决了代码被耗时任务阻止其往下执行的缺点

- 多线程异步有着比较好的解决方案

	- （1）给涉及到I/O操作的部分新开一个线程执行
	- （2）主线程不等待继续往下执行
	- （3）I/O线程执行完之后将结果写回公共区并通知主线程(也可以是主线程去轮询)
	- （3）主线程执行其回调

- JavaScript是一门单线程语言，本身无法提供多线程，那么是通过怎样的机制来实现异步的？

	- 先给出答案

		- JavaScript通过事件循环和浏览器各线程协调共同实现异步

	- JavaScript认为任务分为两种

		- 一种是全由CPU决定完成速度的任务，我们称其为同步任务。
		- 一种是由多种因素（如硬盘读取速度，网速，点击反馈速度）决定完成速度的任务，我们称其为异步任务。
		- 举个简单的例子

			- 函数声明，for循环，变量声明，赋值操作等都可以属于同步任务
			- 读取文件，网络请求，网页事件都看做异步任务

	- 事件循环

		- JavaScript将所有的异步任务都会放进一个队列里面，在执行完所有的同步任务之后，会去队列中找到最先进入队列的异步任务执行。

		- 仔细观察上图，结合浏览器多线程设计：

			- JavaScript线程首先执行同步任务
			- 在执行完同步任务之后，会去异步任务队列的队头取出任务执行
			- 浏览器各个线程会在事件触发且完成事件之后将回调函数写入异步队列（先进先出队列）

		- 事件循环

			- 因为诸如事件触发，http请求都是耗时无法直接确定的任务，也就是说JavaScript线程无法得知异步的任务回调函数究竟什么时候会写入异步任务队列，那么这个地方，就需要一个机制，去时刻轮询这个任务队列，这就是事件循环(event loop)

- 讨论下为什么这样设计

	- 因为JavaScript的工作环境是一个典型的异步应用场景：充斥着各种ajax事件和浏览器事件。各个事件的触发时间和得到反馈的时间都不得而知，如果设计成同步语言，将会带来极差的浏览器使用体验。
	- 浏览器需要做的事情太多了，一手需要负责渲染，一手需要负责http请求，一手还需要执行JavaScript，将JavaScript设计成单线程不仅能够让浏览器更好地控制各个线程，同时对开发者来说也更简单。多线程涉及到锁，临界区，冲突解决的学习成本还是比较高的。

### 【执行机制】JS执行机制与异步队列

- Event Loop

	- 一个 Event Loop 中，可以有一个或者多个任务队列(task queue)，一个任务队列便是一系列有序任务(task)的集合；每个任务都有一个任务源(task source)，源自同一个任务源的 task 必须放到同一个任务队列，从不同源来的则被添加到不同队列。

- 每一次循环tick，分为四个关键步骤

	- 在此次 tick 中选择最先进入队列的任务(oldest task)，如果有则执行(一次)
	- 检查是否存在 Microtasks，如果存在则不停地执行，直至清空 Microtasks Queue
	- 更新 render
	- 主线程重复执行上述步骤

- 任务可分为 （macro）task 和 microtask 两类

	- 不同的API注册的异步任务会依次进入自身对应的队列中，然后等待 Event Loop 将它们依次压入执行栈中执行。
	- (marco)task主要包括

		- script(整体代码)、setTimeout、setInterval、I/O、UI交互事件、setImmediate(Node.js 环境)

	- microtask主要包含

		- Promise、MutaionObserver、process.nextTick(Node.js 环境)

- 任务源

	- setTimeout/Promise 等API便是任务源，而进入任务队列的是他们指定的具体执行任务。来自不同任务源的任务会进入到不同的任务队列。其中setTimeout与setInterval是同源的。

- 示例

	- 代码

	- 步骤

		- （1）事件循环从宏任务(macrotask)队列开始，这个时候，宏任务队列中，只有一个script(整体代码)任务；当遇到任务源(task source)时，则会先分发任务到对应的任务队列中去。

		- （2）然后遇到了 console 语句，直接输出 script start。输出之后，script 任务继续往下执行，遇到 setTimeout，其作为一个宏任务源，则会先将其任务分发到对应的队列中：

		- （3）script 任务继续往下执行，遇到 Promise 实例。Promise 构造函数中的第一个参数，是在 new 的时候执行，构造函数执行时，里面的参数进入执行栈执行；而后续的 .then 则会被分发到 microtask 的 Promise 队列中去。所以会先输出 promise1，然后执行 resolve，将 then1 分配到对应队列。

构造函数继续往下执行，又碰到 setTimeout，然后将对应的任务分配到对应队列：

		- （4）script任务继续往下执行，最后只有一句输出了 script end，至此，全局任务就执行完毕了。

根据上述，每次执行完一个宏任务之后，会去检查是否存在 Microtasks；如果有，则执行 Microtasks 直至清空 Microtask Queue。

因而在script任务执行完毕之后，开始查找清空微任务队列。此时，微任务中，只有 Promise 队列中的一个任务 then1，因此直接执行就行了，执行结果输出 then1。当所有的 microtast 执行完毕之后，表示第一轮的循环就结束了。

		- （5）这个时候就得开始第二轮的循环。第二轮循环仍然从宏任务 macrotask开始。此时，有两个宏任务：timeout1 和 timeout2。

取出 timeout1 执行，输出 timeout1。此时微任务队列中已经没有可执行的任务了，直接开始第三轮循环：

		- （6）第三轮循环依旧从宏任务队列开始。此时宏任务中只有一个 timeout2，取出直接输出即可。

这个时候宏任务队列与微任务队列中都没有任务了，所以代码就不会再输出其他东西了。那么例子的输出结果就显而易见：

- Promise的特殊情况

	- 代码

	- 结果

		- 4321

	- 为什么 t2 会先执行呢？理由如下：

		- 实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行
		- Promise.resolve 方法允许调用时不带参数，直接返回一个resolved 状态的 Promise 对象。立即 resolved 的 Promise 对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。

## 生成器

### 打破完整运行

- 一个假定：一个函数一旦开始执行,就会运行到结束,期间不会有其他代码能够打断它并插入其间
- ES6 引入了一个新的函数类型,它并不符合这种运行到结 束的特性。这类新的函数被称为生成器
- 生成器就是一类特殊的函数,可以一次或多次启动和停止,并不一定非得要完成
- 除了能够接受参数并提供返回值之外,生成器甚至提供了更强大更引人注目的内建消息输 入输出能力
- :每次构建一个 迭代器 ,实际上就隐式构建了生 成器的一个实例,通过这个 迭代器 来控制的是这个生成器实例

### 生成器产生值

- 迭代器 是一个定 义良好的接口, 用于从一个生产者一步步得到一系列值
- 的一个术语是 iterable (可迭代),即指一个包含可以在迭代器的值上迭代的迭代器的对象
- iterable 必须支持一个函数,其名称 是专门的 ES6 符号值 Symbol.iterator 。 调用这个函数时, 它会返回一个迭代器
- 把生成器看作一个值的生产 者,我们通过迭代器接口的 next() 调用一次提取出一个值
- for..of 循环的“异常结束”(也就是“提前终 止”),通常由 break 、 return 或者未捕获异常引起,会向生成器的迭代器发送一个信号使 其终止
- 可以在外部通过 return(..) 手工终止生成器的迭代器实例

###  异步迭代生成器

- 异步作为实现细节抽象了出去,使得我们可以以同步顺序的形式追 踪流程控制
- 不仅能够从异步函数调用得到看似同步的返回值,还 可以同步捕获来自这些异步函数调用的错误

### 生成器 +Promise

- 获得 Promise 和生成器最大效用的最自然的方法就 是 yield 出来一个 Promise, 然后通过这个 Promise 来控制生成器的迭代器
- await 了一个 Promise, async 函数就会自动获知要做什么,它会暂停这个函数(就 像生成器一样),直到 Promise 决议
- Promise 所有的并发能力在生成器 +Promise 方法中都可以使用
- 使用生成器实现异步的方法的全部要点在于创建简单、顺序、看似同步的代码,将异步的 细节尽可能隐藏起来

### 生成器委托

- 从一个生成器调用另一个生成器,使用辅助函数 run()
- yield 委托 的具体语法是: yield * __(注意多出来的 * )
- yield 委托的主要目的是代码组织,以达到与普通函数调用的对称
- 保持生成器分离有助于程序的可读性、可维护性和可调试性
- yield 委托是如何不只用于迭代器控制工作,也用于双向消息传递工 作的呢
- 错误和异常也是双向传递的
-  异步委托

	- 调用 yield *function()

- 递归委托

	- 使用 委托实现异步的生成器 递归 ,即一个 yield 委托到它自身的生成器

### 生成器并发

- 两个实例 都是各自的响应一回来就取得了数据, 然后每个实例再次 yield , 用于控制传递的目的
- runAll(..) 的工具

### 形实转换程序

- JavaScript 中的 thunk 是指一个用于调用另外一个函数的函数,没有任何参数
- 你用一个函数定义封装函数调用,包括需要的任何参数,来定义这个调用的执 行,那么这个封装函数就是一个形实转换程序之后在执行这个 thunk 时,最终就是调用 了原始的函数

### ES6 之前的生成器

- 手工转换

	- 生成器是如何 工作的推导练习

- 自动转换

	- 自动把 ES6 生成器转化为前面小节中我们推导出来的 结果那样的生成器的代码

## 混合对象“类”

### 类理论

- 数据结构：把数据以及和它相关的行为打包
- 面向对象编程

	- 实例化
	- 继承
	- 多态
	- 多态

### JavaScript中的 “ 类 ”

-  JavaScript 只有一些近似类的语法元素（语法糖）

### 类的机制

- “类”和“实例”

	- 建筑蓝图和实际建筑

- 类的继承

	- 继承通用 的特性并根据自身类别修改某些特性

- 多态

	- 多态性取决于你是在哪个类的实例中引用它

- 多重继承

### 在继承或者实例化时JavaScript 的对象机制并不会 自动 执行复制行为，它们会被 关联起来

## 继承

### 【继承】JavaScript 各种继承方式优缺点对比

- （1）原型对象

	- 1.无论什么时候，只要创建一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性指向 prototype 属性所在的函数。

	- 2.当我们用构造函数创建一个实例时，也会为这个实例创建一个 __proto__ 属性，这个__proto__ 属性是一个指针指向构造函数的原型对象

- （2）重写原型对象

	- 我们经常用一个包含所有属性和方法的对象字面量来重写整个原型对象
	- 如果将 Person.prototype 设置为一个新对象，而这个对象中没有constructor属性，这导致 constructor 属性不再指向 Person，而是指向 Object。

	- 所以如果 constructor 的值很重要，我们可以像下面这样特意将它设置回设置回适当的值

- （3）原型链及原型链继承

	- 解释清楚

		- 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针(constructor)，而实例都包含一个指向原型对象的内部指针(__proto__)。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个构造函数的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。

	- 例子

		- 理解

			- 上面的代码中Sub.prototype = new Super();通过创建Super的实例，并将该实例赋值给Sub.prototype来实现继承。此时存在于Super的实例和原型对象中的所有属性和方法，也都存在于Sub.prototype中。instanse的__proto__属性指向Sub的原型对象Sub.prototype，Sub原型对象的__proto__属性又指向Super的原型对象Super.prototype。

	- 1.原型链搜索机制

		- 当访问一个实例的属性时，首先会在该实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链继承的情况下，搜索过程就得以沿着原型链继续向上查找，直到找到该属性为止，或者搜索到最高级的原型链Object.prototype中，任然没有找到则返回undefined。就拿上面的例子来说，调用instance.getSuperValue()会经历三个搜索步骤：1）搜索实例；2）搜索Sub.prototype;3）搜索Super.prototype，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链的末端才会停下。

	- 2.原型链继承的缺陷

		- 理解

			- 原型链继承最大的问题是来自包含引用类型值的原型。引用类型值的原型属性会被所有实例共享。而这正是为什么要在构造函数中，而不是原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。

		- 例子

			- 解释

				- 上面的代码中，Super 构造函数定义了一个colors 属性，该属性是一个数组。Super 的每个实例都会有各自包含自己数组的colors 属性。当Sub 通过原型链继承了Super之后，Sub.prototype 就变成了Super 的一个实例，因此它也拥有了一个它自己的colors 属性。结果是所有的Sub 实例都会共享这一个colors 属性。

		- 原型链的第二个问题是没有办法在不影响所有对象实例的情况下，给超类的构造函数传递参数。

- （4）构造函数继承（经典继承）

	- 理解

		- 即在子类构造函数的中调用父类构造函数，此时当构建一个子类实例时，此实例也会拥有父类实例的属性和方法。

	- 例子

		- 解释

			- 上面的代码，当构建Sub的实例时，也会调用Super 的构造函数，这样就会在新Sub对象上执行Super()函数中定义的所有对象初始化代码。结果，Sub 的每个实例就都会具有自己的colors 属性的副本了。

	- 构造函数继承的缺陷

		- 如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数服用就无从谈起。而且，在超类原型中定义的方法，对子类而已也是不可见的。

- （5）组合继承

	- 原理

		- 是指将原型链和构造函数的相结合，发挥二者之长的一种继承模式。其思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，即通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。

	- 例子

		- 解释

			- 在上面的例子中，Sup构造函数定义了两个属性：name和colors。Sup的原型定义了一个方法sayName()。Sub构造函数在调用Sup构造函数时传入了name参数，紧接着又定义了它自己的属性age。然后，将Sup的实例赋值给Sub的原型，然后又在该新原型上定义了sayAge()方法。这样就可以让两个不同的Sub 实例即分别拥有自己的属性————包括colors 属性，又可以使用相同的方法了。
			- 组合继承避免了原型链和构造函数的缺陷，融合了它们的优点，是JavaScript中最常用的继承模式。

	- 美中不足

		- 上面的代码中调用了两次父类构造函数。Sub.prototype = new Super(); 第一次调用父类构造函数时，将Sup父类构造函数的实例赋值给了Sub子类的原型对象Sub.prototype。此时也会将父类构造函数实例上的属性赋值给子类的原型对象Sub.prototype。而第二次是在子类的构造函数中调用父类的构造函数 Super.call(this)，此时会将父类构造函数实例上的属性赋值给子类的构造函数的实例。根据原型链搜索原则，实例上的属性会屏蔽原型链上的属性。因此我们没有必要将父类构造函数实例的属性赋值给子类的原型对象，这是浪费资源而又没有意义的行为。

- （6）优化后的组合继承

	- 例子一

		- 解释

			- 上面的例子通过将父类的原型对象直接赋值给一个中间构造函数的原型对象，然后将这个中间构造函数的实例赋值给子类的原型对象Sub.prototype，从而完成原型链继承。它的高效性体现在只调用了一个父类构造函数Super，并且原型链保持不变。

	- 例子二

		- 解释

			- 还有一种简便的写法是采用ES5的Object.create()方法来替代中间构造函数，其实原理都是一样的

- （7）更简单的继承方式

	- 简要理解

		- 直接将子类的原型对象(prototype)上的__proto__指向父类的的原型对象(prototype)，这种方式没有改变子类的原型对象，所以子类原型对象上的constructor属性还是指向子类的构造函数，而且当子类的实例在子类的原型对象上没有搜索到对应的属性或方法时，它会通过子类原型对象上的__proto__属性，继续在父类的原型对象上搜索对应的属性或方法

	- 例子

- （8）Object.setPrototypeOf()

	- 理解

		- Object.setPrototypeOf()是ECMAScript 6最新草案中的方法，相对于 Object.prototype.proto ，它被认为是修改对象原型更合适的方法

	- 例子

- （9）类的静态方法继承

	- 理解

		- 上面所有的继承方法都没有实现类的静态方法继承，而在ES6的class继承中，子类是可以继承父类的静态方法的。我们可通过Object.setPrototypeOf()来实现类的静态方法继承，非常简单

	- 例子

### JavaScript8种继承方式

- 继承需要实现两点

	- 父类实例上的属性和方法
	- 父类原型对象上的属性和方法

- 原型链继承

	- 关键代码

		- p = new Parent('father');
		- Child.prototype = p;

	- 优点

		- 可以调用原型链上的方法
		- 可以获取父类实例的属性
		- 可以直接修改父类实例属性
		- 可以通过子类实例修改父类上的引用类型

	- 缺点

		- 修改父类实例属性，所有原型链上的对象的属性都会被影响
		- 修改父类实例引用类型，其他对象也会受影响
		- 调用子类构造函数时，不能像父类构造函数传递参数

- 借用构造函数继承

	- 关键代码

		- function Child(name) {
  Parent.call(this, name)
}

	- 关键思路

		- 把本来父类构造函数中指向父类实例的this，通过在子类构造函数中call(this)把上下文修改为子类实例。也就是把父类实例的属性复制一份给子类实例

	- 优点

		- 可以在call()中向父类构造函数传递参数
		- 可以访问父类实例上的属性，但是是自己的，并不是._proto_指向的。
		- 修改父类属性不会影响其他子类实例

	- 缺点

		- 因为没有原型链，所以子类实例实际上是不能访问到父类原型对象上的属性和方法
		- 每次创建一次实例都会创建一遍构造函数的方法
		- 方法都在构造函数中定义，因此，函数的复用就无从谈起。

- 组合继承

	- 关键代码

		- 1.借用构造函数

			- function Child1(name) {
  Father.call(this, name)
  // 注意，要先 call 父构造函数，再定义子类实例自己的属性
  // 否则子类实例属性会被父类实例同名属性覆盖
  this.age = 10
}


		- 2.添加原型链

			- 
// 修改原型对象
Child1.prototype = f
// 修改原型对象的构造函数
Child1.prototype.constructor = Child1

	- 关键思想

		- 复制一份父类实例的属性到子类实例上
		- 将子类实例添加到原型链上

	- 优点

		- 可以向父类构造函数传参
		- 可以通过原型链访问父类属性
		- 可以修改父类属性而不影响其他子类实例

	- 缺点

		- 会调用两次父构造函数。
		- 一个子类实例将会持有两份父类实例的数据。

- 原型式继承

	- 关键思想

		- 比较原型链继承

			- 原型链继承，是先在子类构造函数定义好了实例属性，再new一个父类实例，把子类构造函数的原型指向该实例
			- 原型式继承，已经有了一个父类实例，最后也同样把子类构造函数的原型指向该实例，只不过在中间定义子类构造函数的时候，定义了一个空的函数

	- 关键代码

		- 通过Object.create()来创建子类实例

			- // 为一个对象生成子类实例的函数。其实 Object.create() 就是这样实现的
function object(obj){
  // 传入的参数 obj 就相当于是父类实例
  // F 就相当于子类构造函数，不过是空的，啥也没
  function F(){}
  // 把子类构造函数的原型对象设置为父类实例
  F.prototype = obj
  // 调用子类构造函数，创建一个实例并返回
  return new F()
}
			- // 为一个对象生成子类实例的函数。其实 Object.create() 就是这样实现的
function object(obj){
  // 传入的参数 obj 就相当于是父类实例
  // F 就相当于子类构造函数，不过是空的，啥也没
  function F(){}
  // 把子类构造函数的原型对象设置为父类实例
  F.prototype = obj
  // 调用子类构造函数，创建一个实例并返回
  return new F()
}

	- 缺点

		- 子类修改引用类型，父类的引用属性也会改变

	- 优点

		- 与原型链继承最大的区别就是在定义子类构造函数的时候定义了一个空函数
		- 在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的。

- 混入式继承mixin

	- 说白了就是把一个对象的属性复制到另一个对象上去。
	- 通过混入的方式为子类实例添加父类原型对象的属性

		- // 创建一个没有实例属性的 Mother 的实例
m = Object.create(Mother.prototype)
// 修改 Me 的原型对象，现在 Me 位于 Mother 实例的原型链上了
Me.prototype = m
// 修改构造函数
Me.prototype.constructor = Me
// 再把 Father 原型对象上的属性方法复制到 Me 的原型对象 m 上
// 现在，虽然 Me 的实例并不在 Father 实例的原型链上
// 但是也可以访问 Father.prototype 上的属性方法
Object.assign(Me.prototype, Father.prototype)

me = new Me()
console.log(me)

- ES6 extends

	- 实现思路和寄生组合继承是一样的

- 寄生组合式继承

	- 关键思路

		- 利用Object.create()的“使用现有的对象来提供新建对象的_proto_”特性，来消除组合式继承的子类具有两份父类属性的缺点
		- 这两份数据中，通过 Father.call(this) 复制到子类实例 c 上的这一份是真正需要的，而 c.__proto__ 上的这一份是多余的，是把子类实例放到原型链上时产生的副作用。
		- 让子类实例在原型链上，但是不能让父类实例的属性位于原型链上

	- 关键代码

		- function Parent(name) {
  this.name = name
  this.age = 40
  this.relation = ['grandma', 'grandpa']
}
Parent.prototype.say = function () {
  console.log(this.name)
}
function Child(name) {
  Parent.call(this, name)
}

// 开始实现继承
// Object.create 创建没有实例属性的父类实例
p = Object.create(Parent.prototype)
// 修改子类构造函数原型对象
Child.prototype = p
// 这里的 p 只是个普通对象，没有 constructor 属性，手动添加一下
p.constructor = Child

- 寄生式继承

	- 关键思路

		- 在原型式继承生成子类实例后，在返回之前处理了子类实例，增加了一些属性或方法

	- 代码

		- 关键代码

			- function createAnother(original){
  // 使用前面的 object 函数，生成了一个子类实例
  var clone = object(original)
  // 先在子类实例上添加一点属性或方法
  clone.sayHi = function(){
    console.log("hi")
  }
  // 再返回
  return clone
}

### 行为委托（原型继承）

- 面向委托（原型）的设计

	- JavaScript中这个机制（原型继承）的本质就是 对象之间的关联关系 。
	- 关联风格

		- 委托中最好把状态保存在委托者（原型）上
		- 避免在原型链的不同级别中使用相同的命名
		- 静止相互委托

- 类与对象

	- 传统的类与对象的开发，需要在父类中定义基础方，然后在子类中重写（丑陋的伪多态）
	- 委托控件，在对象之间建立关联，定义不同的具有描述性的方法名

- 提升

	- 更简洁的设计

	- 内省

		- 自省就是检查实例的类型

