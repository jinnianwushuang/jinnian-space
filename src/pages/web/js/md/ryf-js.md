# 阮一峰JavaScript基础总结

## 阮一峰·JS基 础语法部分

### 基本语法

- switch不进行类型转换

- 三元运算符

- break与continue语句

- 标签：Label

### 数据类型

- 六种主要数据类型

	- 字符串，数值，布尔值，null，undefined，对象
	- ES6新增Symbol

- JavaScript确定值类型的三种方法

	- typeof运算符

		- 一共六种类型，注意6，7。对于Array,Null等特殊对象使用typeof一律返回object，这正是typeof的局限性，typeof只能区分值类型的，不能区分引用类型
		- 注意使用typeof得到的六种结果为：number，function，object，string，undefined，boolean

	- instanceof运算符

		- instanceof：用于判断 引用类型 属于哪个构造函数的方法
	- Object.prototype.toString方法

- null与undefined

	- 区别：null是一个表示“空”的对象，转为数值时为0；undefined是一个表示”此处无定义”的原始值，转为数值时为NaN。

	- 用法与含义

- 布尔值

	- 哪些运算符会返回布尔值？

		- 两元逻辑运算符： && (And)，|| (Or)
		- 前置逻辑运算符： ! (Not)
		- 相等运算符：===，!==，==，!=
		- 比较运算符：>，>=，<，<=

	- 转换规则

		- 除了下面六个值被转为false，其他值都视为true。
		- undefined，null，false，0，NaN，""或''（空字符串）

### 数值

- 整数和浮点数

	- JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。

	- JavaScript语言底层没有整数
	- 涉及到小数的比较与运算要特别小心

- 数值范围

	-  JavaScript 能够表示的数值范围为2的1024次方到2的-1023次方（开区间），超出这个范围的数无法表示
	- 正向溢出

	- 负向溢出

	- JavaScript 提供Number对象的MAX_VALUE和MIN_VALUE属性，返回可以表示的具体的最大值和最小值。

		- Number.MAX_VALUE // 1.7976931348623157e+308
		- Number.MIN_VALUE // 5e-324

- 数值进制

	- 十进制：没有前导0的数值。
	- 八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。
	- 十六进制：有前缀0x或0X的数值。
	- 二进制：有前缀0b或0B的数值。

- 正负零的唯一区别

- NaN

	- 含义

		- 数据类型依然属于Number，主要出现在将字符串解析成数字出错的场合。另外，一些数学函数的运算结果会出现NaN。0除以0也会得到NaN。

	- 运算规则

		- NaN不等于任何值，包括它本身。
		- 数组的indexOf方法内部使用的是严格相等运算符，所以该方法对NaN不成立。

		- NaN在布尔运算时被当作false。
		- NaN与任何数（包括它自己）的运算，得到的都是NaN。

- 相关方法

	- parseInt()

		- 
该方法用于将字符串转为整数。返回值只有两种可能，要么是一个十进制整数，要么是NaN。

1）如果字符串头部有空格，空格会被自动去除。

2）如果parseInt的参数不是字符串，则会先转为字符串再转换。

3）字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。
		- 对于自动转科学计数法的情况

		- 进制转换

			- parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。
			- 第一个参数自转字符串引发进制转换的错误

	- parseFloat()

		- 
该方法用于将一个字符串转为浮点数。
		- parseFloat()在转化NaN不同于Number()，如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN。尤其注意！parseFloat会将空字符串转为NaN。

	- isNaN()

		- 
isNaN方法可以用来判断一个值是否为NaN。
		- 可以令isNaN()返回true的情况：NaN、字符串、对象、数组

		- 使用

			- 使用isNaN之前，最好判断一下数据类型。

				- function myIsNaN(value) {
  return typeof value === 'number' && isNaN(value);
}

		- 替代

			- 判断isNaN更可靠的方法是，利用NaN为唯一不等于自身的值的这个特点，进行判断。

				- function myIsNaN(value) {
  return value !== value;
}

	- isFinite()

		- isFinite方法返回一个布尔值，表示某个值是否为正常的数值。
		- 除了Infinity、-Infinity和NaN这三个值会返回false，isFinite对于其他的数值都会返回true。

			- isFinite(Infinity) // false
			- isFinite(-Infinity) // false
			- isFinite(NaN) // false
			- isFinite(-1) // true

### 字符串

- 定义

	- 字符串默认只能写在一行内，分成多行将会报错。

	- 如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。

- 转义

	- 反斜杠的特殊用法

- 字符串与数组的相似性

	- 字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。
	- 如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。

- length属性

	- length属性返回字符串的长度，该属性也是无法改变的。

- 字符集

	- JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。

JavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成\uxxxx的形式，其中xxxx代表该字符的 Unicode 码点。比如，\u00A9代表版权符号。
	- 对于码点在U+10000到U+10FFFF之间的字符，JavaScript 总是认为它们是两个字符（length属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是不正确的。

- Base64转码

  有时，文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。

	- 定义

		- 
一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符

	- 使用目的

		- 不是为了加密，而是为了不出现特殊字符，简化程序的处理。

	- JavaScript 原生提供两个 Base64 相关的方法。

		- btoa()：任意值转为 Base64 编码
		- atob()：Base64 编码转为原来的值
	- 注意

		- 这两个方法不适合非 ASCII 码的字符
		- 要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。

### 对象

- 键名

	- 
如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。

- 对象的引用

	- 如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。

	- 此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。

- 表达式还是语句

	- 如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。

- 属性的操作

	- 属性读取

		- 
请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。

		- 注意，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。

	- 查看所有属性

		- 查看一个对象本身的所有属性，可以使用Object.keys方法。

	- delete 命令

		- delete命令用于删除对象的属性，删除成功后返回true。

		- 注意，删除一个不存在的属性，delete不报错，而且返回true。不能根据delete命令的结果，认定某个属性是存在的。

		- 只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。

		- 需要注意的是，delete命令只能删除对象本身的属性，无法删除继承的属性

	- in 运算符

		- 
in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true
		- in运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。

	- for…in 循环

		- for...in循环用来遍历一个对象的全部属性。

		- 注意点

			- 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。
			- 它不仅遍历对象自身的属性，还遍历继承的属性。

		- 使用

			- 使用for...in的时候，应该结合使用hasOwnProperty方法，在循环内部判断一下，某个属性是否为对象自身的属性。

	- with 语句

		- 作用

			- 操作同一个对象的多个属性时，提供一些书写的方便。

		- 注意

			- 如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。

### 数组

- 定义

	- 任何类型的数据，都可以放入数组。

- length 属性

	- length属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。清空数组的一个有效方法，就是将length属性设为0。
	- 如果人为设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。当length属性设为大于数组个数时，读取新增的位置都会返回undefined
	- 注意

		- 由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响length属性的值。

- in 运算符

	- 
检查某个键名是否存在的运算符in，适用于对象，也适用于数组。

- for…in 循环和数组的遍历

	- for...in不仅会遍历数组所有的数字键，还会遍历非数字键。
	- 不推荐使用for...in遍历数组。数组的遍历可以考虑使用for循环或while循环。

	- foreach方法

		- 数组的forEach方法，也可以用来遍历数组

- 数组的空位

	- 数组的空位在length属性中有体现，并且是可以读取的，返回undefined。
	- 注意

		- 数组的某个位置是空位，与某个位置是undefined，是不一样的。如果是空位，使用数组的forEach方法、for...in结构、以及Object.keys方法进行遍历，空位都会被跳过。
		- 如果某个位置是undefined，遍历的时候就不会被跳过。

- “类似数组的对象”使用数组方法

	- 1）数组的slice方法可以将“类似数组的对象”变成真正的数组。

		- var arr = Array.prototype.slice.call(arrayLike);

	- 2）就是通过call()把数组的方法放到对象上面。

	  注意，这种方法比直接使用数组原生的forEach要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的forEach方法。

### 函数

- 递归

	- 函数可以调用自身，这就是递归（recursion）

- 变量提升

	- 如果同时采用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义。

- 不能在条件语句中声明函数

	- 根据 ES5 的规范，不得在非函数的代码块中声明函数，最常见的情况就是if和try语句。
- 函数的属性和方法

	- name 属性

		- 函数的name属性返回函数的名字。
		- 用处

			- name属性的一个用处，就是获取参数函数的名字。

	- length 属性

		- 
函数的length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。
		- length属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的”方法重载“

	- toString()

		- 
函数的toString方法返回一个字符串，内容是函数的源码。

- 函数的参数

	- 参数的省略

		- 需要注意的是，函数的length属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。
		- 没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入undefined。

	- 参数的传递

		- 原始类型的值（数值、字符串、布尔值），传递方式是传值传递（在函数体内修改参数值，不会影响到函数外部。）
		- 参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（内部修改参数，将会影响到原始值。）

		- 注意！如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。

- arguments 对象

	- 定义

		- 
这个对象只有在函数体内部，才可以使用。

	- argument.length

		- 通过arguments对象的length属性，可以判断函数调用时到底带几个参数。

	- 与数组的关系

		- 虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。
		- 让argument对象使用数组方法

			- 如果要让arguments对象使用数组方法，真正的解决方法是将arguments转为真正的数组。下面是两种常用的转换方法：slice方法和逐一填入新数组。

	- callee 属性

		- arguments对象带有一个callee属性，返回它所对应的原函数。
- 闭包

	- 闭包的作用

		- 1.读取函数内部的变量，并让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。

		- 2.封装对象的私有属性和私有方法。

	- 注意

		- 注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。

- eval 命令

	- 定义

		- eval命令的作用是，将字符串当作语句执行。

	- 性质

		- 放在eval中的字符串，应该有独自存在的意义，不能用来与eval以外的命令配合使用。
		- eval没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。

	- 与eval()相类似的

### 运算符

- 数值运算符

	- 数值运算符的作用在于可以将任何值转为数值（与Number函数的作用相同）。

- 指数运算符

- 字符串的比较

	- JavaScript 引擎内部首先比较字符串中首字符的 Unicode 码点。如果相等，再比较第二个字符的 Unicode 码点，以此类推。

- 非字符串的比较

	- （1）原始类型的值

		- 先转成数值再比较。

	- （2）对象

		- 如果运算子是对象，会转为原始类型的值，再进行比较。
		- 对象转换成原始类型的值，算法是先调用valueOf方法；如果返回的还是对象，再接着调用toString方法，

	- （3）undefined == null // true;  undefined === null //false

- 且运算符（&&）

	- 运算规则

		- 如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。

	- 取代if结构

	- 多个连用

		- 且运算符可以多个连用，这时返回第一个布尔值为false的表达式的值。
- 或运算符（||）

	- 或运算符常用于为一个变量设置默认值。
- 逗号运算符

	- 逗号运算符用于对两个表达式求值，并返回后一个表达式的值。
### 数据类型转换

- 强制转换

	- Number()

		- 定义

			- 使用Number函数，可以将任意类型的值转化成数值。

		- 参数为原始类型的值

			- 只要有一个字符无法转成数值，整个字符串就会被转为NaN。
		- 参数为对象

			- Number方法的参数是对象时，将返回NaN，除非是包含单个数值的数组。

	- String()

		- （1）原始类型值

			- 数值：转为相应的字符串。
			- 字符串：转换后还是原来的值。
			- 布尔值：true转为字符串"true"，false转为字符串"false"。
			- undefined：转为字符串"undefined"。
			- null：转为字符串"null"。

		- （2）对象

			- String方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。

	- Boolean()

		- 除了以下五个值的转换结果为false，其他的值全部为true。

			- undefined
			- null
			- -0或+0
			- NaN
			- ''（空字符串）

		- 注意

			- 所有对象（包括空对象）的转换结果都是true，甚至连false对应的布尔对象new Boolean(false)也是true
- 自动转换

	- !! expression

- 对象类型转换

	- valueOf（）

	- toString（）

### 错误处理机制

- Error 实例对象

	- message属性：错误提示信息
	- name属性：错误名称（非标准属性）
	- stack属性：错误的堆栈（非标准属性）

- Error的6个派生对象

	- SyntaxError 对象

		- SyntaxError对象是解析代码时发生的语法错误。

	- ReferenceError 对象

		- ReferenceError对象是引用一个不存在的变量时发生的错误。
		- 另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值。

	- RangeError 对象

		- RangeError对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。

	- TypeError 对象

		- TypeError对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。

	- URIError 对象

		- URIError对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。

	- EvalError 对象

		- eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。

- throw 语句

	- 定义

		- throw语句的作用是手动中断程序执行，抛出一个错误。实际上，throw可以抛出任何类型的值。也就是说，它的参数可以是任何值

- try…catch 结构

	- 定义

		- try代码块抛出错误（上例用的是throw语句），JavaScript 引擎就立即把代码的执行，转到catch代码块，或者说错误被catch代码块捕获了。catch接受一个参数，表示try代码块抛出的值。

## 阮一峰·JS标 准库

### Object对象

- 概述

	- JavaScript 的所有其他对象都继承自Object对象，即那些对象都是Object的实例。
	- Object对象的原生方法

		- Object本身的方法（静态方法）

		- Object的实例方法。

- Object作为函数的用法：Object()

	- Object作为工具函数

		- 如果参数是原始类型的值，Object方法将其转为对应的包装对象的实例

		- 如果Object方法的参数是一个对象，它总是返回该对象，即不用转换。

			- 利用这一点，可以写一个判断变量是否为对象的函数。
	- Object 作为构造函数

		- Object构造函数的首要用途，是直接通过它来生成新对象，通过var obj = new Object()的写法生成新对象，与字面量的写法var obj = {}是等价的。
		- 与其作为工具函数的用法相似，但是Object(value)与new Object(value)两者的语义是不同的，Object(value)表示将value转成一个对象，new Object(value)则表示新生成一个对象，它的值是value。

- Object 的静态方法

	- （0）遍历对象的属性的两种方法

		- Object.keys方法只返回可枚举的属性，Object.getOwnPropertyNames方法还返回不可枚举的属性名。

	- （1）对象属性模型的相关方法

		- Object.getOwnPropertyDescriptor()：获取某个属性的描述对象。
		- Object.defineProperty()：通过描述对象，定义某个属性。
		- Object.defineProperties()：通过描述对象，定义多个属性。

	- （2）控制对象状态的方法

		- Object.preventExtensions()：防止对象扩展。
		- Object.isExtensible()：判断对象是否可扩展。
		- Object.seal()：禁止对象配置。
		- Object.isSealed()：判断一个对象是否可配置。
		- Object.freeze()：冻结一个对象。
		- Object.isFrozen()：判断一个对象是否被冻结。

	- （3）原型链相关方法

		- Object.create()：该方法可以指定原型对象和属性，返回一个新的对象。
		- Object.getPrototypeOf()：获取对象的Prototype对象。

- Object 的实例方法

	- Object.prototype.valueOf()：返回当前对象对应的值。

		- valueOf方法的作用是返回一个对象的“值”，默认情况下返回对象本身。
	- Object.prototype.toString()：返回当前对象对应的字符串形式。

		- toString方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串。

		- 数组、字符串、函数、Date 对象都分别部署了自定义的toString方法，覆盖了Object.prototype.toString方法。

		- toString() 的应用：判断数据类型

			- 概述

			- 应用

			- 不同数据类型的Object.prototype.toString方法返回值如下。即利用这个特性可以做一个准确的类型判断。

				- 数值：返回[object Number]。
				- 字符串：返回[object String]。
				- 布尔值：返回[object Boolean]。
				- undefined：返回[object Undefined]。
				- null：返回[object Null]。
				- 数组：返回[object Array]。
				- arguments 对象：返回[object Arguments]。
				- 函数：返回[object Function]。
				- Error 对象：返回[object Error]。
				- Date 对象：返回[object Date]。
				- RegExp 对象：返回[object RegExp]。
				- 其他对象：返回[object Object]。

	- Object.prototype.toLocaleString()：返回当前对象对应的本地字符串形式。

		- Array.prototype.toLocaleString()
		- Number.prototype.toLocaleString()
		- Date.prototype.toLocaleString()

	- Object.prototype.hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。

		- Object.prototype.hasOwnProperty方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。
	- Object.prototype.isPrototypeOf()：判断当前对象是否为另一个对象的原型。
	- Object.prototype.propertyIsEnumerable()：判断某个属性是否可枚举。

### Array 对象

- 作为构造函数

	- Array构造函数有一个很大的缺陷，就是不同的参数，会导致它的行为不一致。

	- 不建议使用它生成新数组，直接使用数组字面量是更好的做法。

		- var arr = new Array(1, 2); // bad
		- var arr = [1, 2]; // good

- 静态方法

	- Array.isArray()

		- Array.isArray方法返回一个布尔值，表示参数是否为数组。它可以弥补typeof运算符的不足
- 实例方法

	- valueOf()，toString()
	- push()，pop()

		- push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。

		- pop方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组

		- 对空数组使用pop方法，不会报错，而是返回undefined。

		- push和pop结合使用，就构成了“后进先出”的栈结构（stack）。

	- shift()，unshift()

		- shift方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。

		- shift方法可以遍历并清空一个数组。

		- push和shift结合使用，就构成了“先进先出”的队列结构（queue）。
		- unshift方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。

	- join()

		- join方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。

		- 如果数组成员是undefined或null或空位，会被转成空字符串。

		- 通过call方法，这个方法也可以用于字符串或类似数组的对象。

	- concat()

		- concat方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。

		- 除了数组作为参数，concat也接受其他类型的值作为参数，添加到目标数组尾部。

		- 如果数组成员包括对象，concat方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是新数组拷贝的是对象的引用。

	- reverse()

		- reverse方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。
	- slice()

		- slice方法用于提取目标数组的一部分，返回一个新数组，原数组不变。
		- 它的第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。

		- 如果slice方法的参数是负数，则表示倒数计算的位置。

		- slice方法的一个重要应用，是将类似数组的对象转为真正的数组。

	- splice()

		- splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。
		- splice的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。

			- arr.splice(start, count, addElement1, addElement2, ...);
		- 起始位置如果是负数，就表示从倒数位置开始删除。
		- 如果只是单纯地插入元素，splice方法的第二个参数可以设为0。

		- 如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。

	- sort()

		- sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。
		- sort方法不是按照大小排序，而是按照字典顺序。也就是说，数值会被先转成字符串，再按照字典顺序进行比较，所以101排在11的前面。

		- 如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数。

	- map()

		- map方法对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。

		- map方法接受一个函数作为参数。该函数调用时，map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。

		- map方法不仅可以用于数组，还可以用于字符串，用来遍历字符串的每个字符。但是，不能直接使用，而要通过函数的call方法间接使用，或者先将字符串转为数组，然后使用。

		- map方法还可以接受第二个参数，表示回调函数执行时this所指向的对象。

		- 如果数组有空位，map方法的回调函数在这个位置不会执行，不会跳过undefined和null，但是会跳过数组的空位。

	- forEach()

		- forEach方法与map方法很相似，也是遍历数组的所有成员，执行某种操作，但是forEach方法一般不返回值，只用来操作数据。如果需要有返回值，一般使用map方法。
		- forEach方法的参数与map方法一致，也是一个函数，数组的所有成员会依次执行该函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。

		- forEach方法也可以接受第二个参数，用来绑定回调函数的this关键字。

		- 注意，forEach方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用for循环。
		- forEach方法不会跳过undefined和null，但会跳过空位。
		- forEach方法也可以用于类似数组的对象和字符串。

	- filter()

		- filter方法的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。

		- filter方法的参数函数可以接受三个参数，第一个参数是当前数组成员的值，这是必需的，后两个参数是可选的，分别是当前数组成员的位置和整个数组。

		- filter方法还可以接受第二个参数，指定测试函数所在的上下文对象（即this对象）。

	- some()，every()

		- 这两个方法类似“断言”（assert），用来判断数组成员是否符合某种条件。
		- 它们接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。
		- some()

			- some方法是只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。

		- every()

			- every方法则是所有数组成员的返回值都是true，才返回true，否则false。

		- 注意，对于空数组，some方法返回false，every方法返回true，回调函数都不会执行。
		- some和every方法还可以接受第二个参数，用来绑定函数中的this关键字。

	- reduce()，reduceRight()

		- 定义

			- reduce方法和reduceRight方法依次处理数组的每个成员，最终累计为一个值。

		- 差别

			- 它们的差别是，reduce是从左到右处理（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。

		- 参数

			- 这两个方法的第一个参数都是一个函数。该函数接受以下四个参数。这四个参数之中，只有前两个是必须的，后两个则是可选的。

				- 累积变量，默认为数组的第一个成员
				- 当前变量，默认为数组的第二个成员
				- 当前位置（从0开始）
				- 原数组

		- 示例

			- 求数组成员之和。

			- 利用reduce方法，可以写一个数组求和的sum方法。

		- 如果要对累积变量指定初值，可以把它放在reduce方法和reduceRight方法的第二个参数。第二个参数相当于设定了默认值，处理空数组时尤其有用。

		- 由于reduce方法依次处理每个元素，所以实际上还可以用它来搜索某个元素。比如，下面代码是找出长度最长的数组元素。

	- indexOf()，lastIndexOf()

		- indexOf()

			- indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。

			- indexOf方法还可以接受第二个参数，表示搜索的开始位置。

		- lastIndexOf()

			- lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。

		- 注意，如果数组中包含NaN，这两个方法不适用，即无法确定数组成员是否包含NaN。

	- 链式使用

		- 上面这些数组方法之中，有不少返回的还是数组，所以可以链式使用。
### 包装对象

- 包装对象的定义

	- 有人说，JavaScript 语言“一切皆对象”。这是因为数组和函数本质上都是对象，就连三种原始类型的值——数值、字符串、布尔值——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”。

	- 所谓“包装对象”，就是分别与数值、字符串、布尔值相对应的Number、String、Boolean三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。
	- 这三个对象作为构造函数使用（带有new）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有new），可以将任意类型的值，转为原始类型的值。

- 包装对象实例的方法

	- 包装对象实例可以使用Object对象提供的原生方法，主要是valueOf方法和toString方法。

		- valueOf()

		- toString()

- 原始类型的自动转换

	- 定义

		- 原始类型的值，可以自动当作对象调用，即调用各种对象的方法和参数。这时，JavaScript引擎会自动将原始类型的值转为包装对象，在使用后立刻销毁。

			- 上面代码中，abc是一个字符串，本身不是对象，不能调用length属性。JavaScript引擎自动将其转为包装对象，在这个对象上调用length属性。调用结束后，这个临时对象就会被销毁。这就叫原始类型的自动转换。

	- 内部属性[[PrimitiveValue]]

		- 上面代码中，字符串abc的包装对象有每个位置的值、有length属性、还有一个内部属性[[PrimitiveValue]]保存字符串的原始值。这个[[PrimitiveValue]]内部属性，外部是无法调用，仅供ValueOf或toString这样的方法内部调用。

	- 这个临时对象是只读的，无法修改。所以，字符串无法添加新属性。

	- 另一方面，调用结束后，临时对象会自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。如果想要为字符串添加属性，只有在它的原型对象String.prototype上定义
	- 这种原始类型值可以直接调用的方法还有很多（详见后文对各包装对象的介绍），除了前面介绍过的valueOf和toString方法，还包括三个包装对象各自定义在原型上的方法。。

- 自定义方法

	- 三种包装对象还可以在原型上添加自定义方法和属性，供原始类型的值直接调用。

- 注意

	- 注意，false对应的包装对象实例，布尔运算结果也是true。是因为false对应的包装对象实例是一个对象，进行逻辑运算时，被自动转化成布尔值true（因为所有对象对应的布尔值都是true）

### Number对象

- 概述

	- Number对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。
	- 作为构造函数时，它用于生成值为数值的对象。

		- var n = new Number(1);
typeof n // "object"

	- 作为工具函数时，它可以将任何类型的值转为数值。

		- Number(true) // 1

- Number对象的属性

	- Number对象拥有以下一些属性。

		- Number.POSITIVE_INFINITY：正的无限，指向Infinity。
		- Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。
		- Number.NaN：表示非数值，指向NaN。
		- Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。
		- Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。
		- Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。
		- Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。

- Number 对象实例的方法

	- Number.prototype.toString()

		- 将一个数值转为字符串形式。toString方法可以接受一个参数，表示输出的进制。

	- Number.prototype.toFixed()

		- toFixed方法用于将一个数转为指定位数的小数，返回这个小数对应的字符串。

	- Number.prototype.toExponential()

		- toExponential方法用于将一个数转为科学计数法形式。

	- Number.prototype.toPrecision()

		- toPrecision方法用于将一个数转为指定位数的有效数字。

- 自定义方法

	- 与其他对象一样，Number.prototype对象上面可以自定义方法，被Number的实例继承。
### String对象

- 概述

	- 
String对象是JavaScript原生提供的三个包装对象之一，用来生成字符串的包装对象。
	- 实际上，字符串的包装对象是一个类似数组的对象（即很像数组，但是实质上不是数组）。
	- 当做构造函数使用
	- 还可以当作工具方法使用，将任意类型的值转为字符串。

- 静态方法

	- 
String.fromCharCode()

		- 该方法的参数是一系列Unicode码点，返回对应的字符串。
		- 注意，该方法不支持Unicode码点大于0xFFFF的字符，即传入的参数不能大于0xFFFF。

- 实例对象的属性和方法

	- length属性返回字符串的长度。

		- 'abc'.length // 3

	- charAt()

		- charAt方法返回指定位置的字符，参数是从0开始编号的位置。

		- 这个方法完全可以用数组下标替代。
		- 如果参数为负数，或大于等于字符串的长度，charAt返回空字符串。

	- charCodeAt()

		- charCodeAt方法返回给定位置字符的Unicode码点（十进制表示），相当于String.fromCharCode()的逆操作。

	- concat()

		- concat方法用于连接两个字符串，返回一个新字符串，不改变原字符串。

		- 该方法可以接受多个参数。

			- 'a'.concat('b', 'c') // "abc"

		- 如果参数不是字符串，concat方法会将其先转为字符串，然后再连接。

	- slice()

		- slice方法用于从原字符串取出子字符串并返回，不改变原字符串。
		- 它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。

			- 'JavaScript'.slice(0, 4) // "Java"

		- 如果省略第二个参数，则表示子字符串一直到原字符串结束。

			- 'JavaScript'.slice(4) // "Script"

		- 如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。
		- 如果第一个参数大于第二个参数，slice方法返回一个空字符串。

	- substring()

		- substring方法用于从原字符串取出子字符串并返回，不改变原字符串。它与slice作用相同，但有一些奇怪的规则，因此不建议使用这个方法，优先使用slice。
		- 如果第二个参数大于第一个参数，substring方法会自动更换两个参数的位置。
		- 如果参数是负数，substring方法会自动将负数转为0。

	- substr()

		- substr方法用于从原字符串取出子字符串并返回，不改变原字符串。
		- substr方法的第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。
		- 如果省略第二个参数，则表示子字符串一直到原字符串的结束。
		- 如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。

	- indexOf()，lastIndexOf()

		- 这两个方法用于确定一个字符串在另一个字符串中的位置，都返回一个整数，表示匹配开始的位置。如果返回-1，就表示不匹配。两者的区别在于，indexOf从字符串头部开始匹配，lastIndexOf从尾部开始匹配。

		- 它们还可以接受第二个参数，对于indexOf方法，第二个参数表示从该位置开始向后匹配；对于lastIndexOf，第二个参数表示从该位置起向前匹配。

	- trim()

		- trim方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。该方法去除的不仅是空格，还包括制表符（\t、\v）、换行符（\n）和回车符（\r）。

			- '\r\nabc \t'.trim() // 'abc'

	- toLowerCase()，toUpperCase()

		- 
toLowerCase方法用于将一个字符串全部转为小写，toUpperCase则是全部转为大写。它们都返回一个新字符串，不改变原字符串。
		- 这个方法也可以将布尔值或数组转为大写字符串，但是需要通过call方法使用。

	- localeCompare()

		- localeCompare方法用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。

	- match()

		- match方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。

		- 返回数组还有index属性和input属性，分别表示匹配字符串开始的位置和原始字符串。

		- match方法还可以使用正则表达式作为参数

	- search()

		- search方法的用法等同于match，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。

			- 'cat, bat, sat, fat'.search('at') // 1

		- search方法还可以使用正则表达式作为参数

	- replace()

		- replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。
	- split()

		- split方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。

			- 'a|b|c'.split('|') // ["a", "b", "c"]

		- 如果分割规则为空字符串，则返回数组的成员是原字符串的每一个字符。

			- 'a|b|c'.split('') // ["a", "|", "b", "|", "c"]

		- 如果省略参数，则返回数组的唯一成员就是原字符串。

		- 如果满足分割规则的两个部分紧邻着（即中间没有其他字符），则返回数组之中会有一个空字符串。

		- split方法还可以接受第二个参数，限定返回数组的最大成员数。

### Math对象

- 概述

	- Math是JavaScript的内置对象，提供一系列数学常数和数学方法。该对象不是构造函数，不能生成实例，所有的属性和方法都必须在Math对象上调用。

- 属性

	- Math.E：常数e。
	- Math.LN2：2的自然对数。
	- Math.LN10：10的自然对数。
	- Math.LOG2E：以2为底的e的对数。
	- Math.LOG10E：以10为底的e的对数。
	- Math.PI：常数Pi。
	- Math.SQRT1_2：0.5的平方根。
	- Math.SQRT2：2的平方根。

- 方法

	- Math.abs()：绝对值

		- Math.abs方法返回参数值的绝对值。

	- Math.ceil()：向上取整

		- Math.ceil方法接受一个参数，返回大于该参数的最小整数。

	- Math.floor()：向下取整

		- Math.floor方法接受一个参数，返回小于该参数的最大整数。

	- Math.max()：最大值
Math.min()：最小值

		- Math.max方法和Math.min方法都可以接受多个参数，Math.max返回其中最大的参数，Math.min返回最小的参数。有趣的是, Math.min 不传参数返回 Infinity, Math.max 不传参数返回 -Infinity。

	- Math.pow()：指数运算

		- Math.pow方法返回以第一个参数为底数、第二个参数为幂的指数值。

	- Math.sqrt()：平方根

		- Math.sqrt方法返回参数值的平方根。如果参数是一个负值，则返回NaN。

	- Math.log()：自然对数

		- Math.log方法返回以e为底的自然对数值。

	- Math.exp()：e的指数

		- Math.exp方法返回常数e的参数次方。

	- Math.round()：四舍五入

		- Math.round方法用于四舍五入。
		- 注意，它对负数的处理（主要是对0.5的处理）。

	- Math.random()：随机数

		- Math.random()返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。

	- 三角函数方法

		- Math.sin()：返回参数的正弦
		- Math.cos()：返回参数的余弦
		- Math.tan()：返回参数的正切
		- Math.asin()：返回参数的反正弦（弧度值）
		- Math.acos()：返回参数的反余弦（弧度值）
		- Math.atan()：返回参数的反正切（弧度值）

### Date对象

- 概述

	- 
Date对象是JavaScript提供的日期和时间的操作接口。它可以表示的时间范围是，1970年1月1日00:00:00前后的各1亿天（单位为毫秒）。
	- Date对象可以作为普通函数直接调用，无论有没有参数，总是返回一个代表当前时间的字符串。

- 作为构造函数使用

	- 不传参数

		- 对它使用new命令，会返回一个Date对象的实例。如果不加参数，生成的就是代表当前时间的对象。
	- 传参数

		- （1）new Date(milliseconds)

			- Date对象接受从1970年1月1日00:00:00 UTC开始计算的毫秒数作为参数。这意味着如果将Unix时间戳（单位为秒）作为参数，必须将Unix时间戳乘以1000。

		- （2）new Date(datestring)

			- Date对象还接受一个日期字符串作为参数，返回所对应的时间。所有可以被Date.parse()方法解析的日期字符串，都可以当作Date对象的参数。
			- 注意

				- 在ES5之中，如果日期采用连词线（-）格式分隔，且具有前导0（即YYYY-MM-DD），JavaScript会认为这是一个ISO格式的日期字符串，导致返回的时间是以UTC时区计算的。

		- （3）new Date(year, month [, day, hours, minutes, seconds, ms])

			- Date对象还可以接受多个整数作为参数，依次表示年、月、日、小时、分钟、秒和毫秒。如果采用这种格式，最少需要提供两个参数（年和月），其他参数都是可选的，默认等于0。因为如果只使用“年”这一个参数，Date对象会将其解释为毫秒数。

- 日期的运算

	- 类型转换时，Date对象的实例如果转为数值，则等于对应的毫秒数；如果转为字符串，则等于对应的日期字符串。所以，两个日期对象进行减法运算，返回的就是它们间隔的毫秒数；进行加法运算，返回的就是连接后的两个字符串。

- Date对象的静态方法

	- Date.now()

		- Date.now方法返回当前距离1970年1月1日 00:00:00 UTC的毫秒数（Unix时间戳乘以1000）。

	- Date.parse()

		- Date.parse方法用来解析日期字符串，返回距离1970年1月1日 00:00:00的毫秒数。
		- 其解析的参数最好为YYYY-MM-DDTHH:mm:ss.sssZ格式
		- 如果解析失败，返回NaN。

	- Date.UTC()

		- 默认情况下，Date对象返回的都是当前时区的时间。Date.UTC方法可以返回UTC时间（世界标准时间）。该方法接受年、月、日等变量作为参数，返回当前距离1970年1月1日 00:00:00 UTC的毫秒数。

- Date实例对象的方法

	- to类：从Date对象返回一个字符串，表示指定的时间。
	- get类：获取Date对象的日期和时间。

	- set类：设置Date对象的日期和时间。

### RegExp对象

- 概述

	- 新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束。

	- 另一种是使用 RegExp 构造函数。

	- 它们的主要区别是：第一种方法在编译时新建正则表达式，第二种方法在运行时新建正则表达式。
	- RegExp 构造函数还可以接受第二个参数，表示修饰符

	- 正则对象生成以后，有两种使用方式：

		- 正则对象的方法：将字符串作为参数，比如regex.test(string)。
		- 字符串对象的方法：将正则对象作为参数，比如string.match(regex)。

- 正则对象的属性和方法

	- 属性

		- 正则对象的属性分成两类。
		- 一类是修饰符相关，返回一个布尔值，表示对应的修饰符是否设置。

			- ignoreCase：返回一个布尔值，表示是否设置了i修饰符，该属性只读。
			- global：返回一个布尔值，表示是否设置了g修饰符，该属性只读。
			- multiline：返回一个布尔值，表示是否设置了m修饰符，该属性只读。

		- 另一类是与修饰符无关的属性，主要是下面两个。

			- lastIndex：返回下一次开始搜索的位置。该属性可读写，但是只在设置了g修饰符时有意义。
			- source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。

	- test()

		- 正则对象的test方法返回一个布尔值，表示当前模式是否能匹配参数字符串。

		- 如果正则表达式带有g修饰符，则每一次test方法都从上一次结束的位置开始向后匹配。

		- 如果正则模式是一个空字符串，则匹配所有字符串。

	- exec()

		- 正则对象的exec方法，可以返回匹配结果。如果发现匹配，就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null。

		- 圆括号，组匹配

			- 如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的length属性等于组匹配的数量再加1。

		- exec方法的返回数组还包含以下两个属性：

			- input：整个原字符串。
			- index：整个模式匹配成功的开始位置（从0开始计数）

		- 如果正则表达式加上g修饰符，则可以使用多次exec方法，下一次搜索的位置从上一次匹配成功结束的位置开始。

		- 利用g修饰符允许多次匹配的特点，可以用一个循环完成全部匹配。

		- 正则对象的lastIndex属性不仅可读，还可写。一旦手动设置了lastIndex的值，就会从指定位置开始匹配。但是，这只在设置了g修饰符的情况下，才会有效。

		- 如果正则对象是一个空字符串，则exec方法会匹配成功，但返回的也是空字符串。

- 字符串对象的方法

	- 字符串对象的方法之中，有4种与正则对象有关。

		- match()：返回一个数组，成员是所有匹配的子字符串。
		- search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。
		- replace()：按照给定的正则表达式进行替换，返回替换后的字符串。
		- split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。

	- String.prototype.match()

		- 字符串对象的match方法对字符串进行正则匹配，返回匹配结果。

		- 如果正则表达式带有g修饰符，则该方法与正则对象的exec方法行为不同，会一次性返回所有匹配成功的结果。

	- String.prototype.search()

		- 字符串对象的search方法，返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1。

		- 该方法会忽略g修饰符。

	- String.prototype.replace()

		- 字符串对象的replace方法可以替换匹配的值。它接受两个参数，第一个是搜索模式，第二个是替换的内容。

			- str.replace(search, replacement)

		- 搜索模式如果不加g修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。

		- replace方法的一个应用，就是消除字符串首尾两端的空格。

		- 参数

			- replace方法的第二个参数可以使用美元符号$，用来指代所替换的内容。

				- $& 指代匹配的子字符串。
				- $` 指代匹配结果前面的文本。
				- $' 指代匹配结果后面的文本。
				- $n 指代匹配成功的第n组内容，n是从1开始的自然数。
				- $$ 指代美元符号$。

			- replace方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值。

	- String.prototype.split()

		- 字符串对象的split方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。

			- str.split(separator, [limit])

		- 该方法接受两个参数，第一个参数是分隔规则，第二个参数是返回数组的最大成员数。

- 匹配规则

	- 字面量字符和元字符

		- 大部分字符在正则表达式中，就是字面的含义，比如/a/匹配a，/b/匹配b。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的a和b），那么它们就叫做“字面量字符”
		- 除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”（metacharacters），主要有以下几个。

			- （1）点字符（.)

				- 点字符（.）匹配除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符。
			- （2）位置字符

				- 位置字符用来提示字符所处的位置，主要有两个字符。

					- ^ 表示字符串的开始位置
					- $ 表示字符串的结束位置

			- （3）选择符（|）

				- 竖线符号（|）在正则表达式中表示“或关系”（OR），即cat|dog表示匹配cat或dog。

				- 多个选择符可以联合使用。
				- 选择符会包括它前后的多个字符，比如/ab|cd/指的是匹配ab或者cd，而不是指匹配b或者c。如果想修改这个行为，可以使用圆括号。

			- 其他的元字符还包括\\、\*、+、?、()、[]、{}等，将在下文解释。

	- 转义符

		- 正则表达式中那些有特殊含义的字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配加号，就要写成\+。
		- 正则模式中，需要用斜杠转义的，一共有12个字符：^、.、[、$、(、)、|、*、+、?、{和\\。需要特别注意的是，如果使用RegExp方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。

	- 字符类

		- 定义

			- 字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[xyz] 表示x、y、z之中任选一个匹配。

		- 有两个字符在字符类中有特殊含义。

			- （1）脱字符（^）

				- 如果方括号内的第一个字符是[^]，则表示除了字符类之中的字符，其他字符都可以匹配。比如，[^xyz]表示除了x、y、z之外都可以匹配。
				- 如果方括号内没有其他字符，即只有[^]，就表示匹配一切字符，其中包括换行符，而点号（.）是不包括换行符的。
				- 注意，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。

			- （2）连字符（-）

				- 某些情况下，对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。比如，[abc]可以写成[a-c]，[0123456789]可以写成[0-9]，同理[A-Z]表示26个大写字母。
	- 预定义模式

		- 预定义模式指的是某些常见模式的简写方式。

			- \d 匹配0-9之间的任一数字，相当于[0-9]。
			- \D 匹配所有0-9以外的字符，相当于[^0-9]。
			- \w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。
			- \W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。
			- \s 匹配空格（包括制表符、空格符、断行符等），相等于[\t\r\n\v\f]。
			- \S 匹配非空格的字符，相当于[^\t\r\n\v\f]。
			- \b 匹配词的边界。
			- \B 匹配非词边界，即在词的内部。

	- 重复类

		- 模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。
	- 量词符

		- 量词符用来设定某个模式出现的次数。

			- ? 问号表示某个模式出现0次或1次，等同于{0, 1}。
			- * 星号表示某个模式出现0次或多次，等同于{0,}。
			- + 加号表示某个模式出现1次或多次，等同于{1,}。

	- 贪婪模式

		- 定义

			- 默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。
		- 如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。

		- 除了非贪婪模式的加号，还有非贪婪模式的星号（*）。

			- *?：表示某个模式出现0次或多次，匹配时采用非贪婪模式。
			- +?：表示某个模式出现1次或多次，匹配时采用非贪婪模式。

	- 修饰符

		- 修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。可以单个使用，也可以多个一起使用。
		- （1）g修饰符

			- 默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。g修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。

		- （2）i修饰符

			- 默认情况下，正则对象区分字母的大小写，加上i修饰符以后表示忽略大小写（ignorecase）。

		- （3）m修饰符

			- m修饰符表示多行模式（multiline），会修改^和$的行为。默认情况下（即不加m修饰符时），^和$匹配字符串的开始处和结尾处，加上m修饰符以后，^和$还会匹配行首和行尾，即^和$会识别换行符（\n）。

	- 组匹配

		- （1）概述

			- 
正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。
		- 在正则表达式内部，可以用\n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号。
		- （2）非捕获组

			- (?:x)称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。
			- 非捕获组的作用请考虑这样一个场景，假定需要匹配foo或者foofoo，正则表达式就应该写成/(foo){1, 2}/，但是这样会占用一个组匹配。这时，就可以使用非捕获组，将正则表达式改为/(?:foo){1, 2}/，它的作用与前一个正则是一样的，但是不会单独输出括号内部的内容。

		- （3）先行断言

			- x(?=y)称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成/\d+(?=%)/。

		- （4）先行否定断言

			- x(?!y)称为先行否定断言（Negative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成/\d+(?!%)/。

### JSON对象

- JSON.stringify()

	- 基本用法

		- JSON.stringify方法用于将一个值转为字符串。该字符串符合 JSON 格式，并且可以被JSON.parse方法还原。
		- 需要注意的是，对于原始类型的字符串，转换结果会带双引号。
		- 如果原始对象中，有一个成员的值是undefined、函数或 XML 对象，这个成员会被过滤。
		- 如果数组的成员是undefined、函数或 XML 对象，则这些值被转成null。
		- 正则对象会被转成空对象。

	- 第二个参数

		- JSON.stringify方法还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。这个类似“白名单”的数组，只对对象的属性有效，对数组无效。

		- 第二个参数还可以是一个函数，用来更改JSON.stringify的默认行为。

	- 第三个参数

		- JSON.stringify还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。

	- toJSON 方法

		- 如果对象有自定义的toJSON方法，那么JSON.stringify会使用这个方法的返回值作为参数，而忽略原对象的其他属性。

- JSON.parse()

	- JSON.parse方法用于将JSON字符串转化成对象。

	- JSON.parse方法可以接受一个处理函数，用法与JSON.stringify方法类似。

### console对象

### 属性描述对象

- 概述

	- JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为“属性描述对象”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。
	- 属性描述对象提供6个元属性。

		- （1）value

			- value是该属性的属性值，默认为undefined。

		- （2）writable

			- writable是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为true。

		- （3）enumerable

		  具体来说，如果一个属性的enumerable为false，下面三个操作不会取到该属性。

		  

		  for..in循环

		  Object.keys方法

		  JSON.stringify方法

			- enumerable是一个布尔值，表示该属性是否可遍历，默认为true。如果设为false，会使得某些操作（比如for...in循环、Object.keys()）跳过该属性。

		- （4）configurable

			- configurable是一个布尔值，表示可配置性，默认为true。如果设为false，将阻止某些操作改写该属性，比如无法删除该属性，也不得改变该属性的属性描述对象（value属性除外）。也就是说，configurable属性控制了属性描述对象的可写性。

				- 可配置性决定了目标属性是否可以被删除（delete）。

		- （5）get

			- get是一个函数，表示该属性的取值函数（getter），默认为undefined。

		- （6）set

			- set是一个函数，表示该属性的存值函数（setter），默认为undefined。

- Object.getOwnPropertyDescriptor()

	- Object.getOwnPropertyDescriptor方法可以获取属性描述对象。它的第一个参数是一个对象，第二个参数是一个字符串，对应该对象的某个属性名。
	- 注意，Object.getOwnPropertyDescriptor方法只能用于对象自身的属性，不能用于继承的属性。

- Object.getOwnPropertyNames()

	- Object.getOwnPropertyNames方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。
- Object.defineProperty()，Object.defineProperties()

	- Object.defineProperty方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象，它的用法如下。
	- Object.defineProperty方法接受三个参数，依次如下。

		- 属性所在的对象
		- 属性名（它应该是一个字符串）
		- 属性描述对象

	- 如果属性已经存在，Object.defineProperty方法相当于更新该属性的属性描述对象。
	- 注意，一旦定义了取值函数get（或存值函数set），就不能将writable属性设为true，或者同时定义value属性，否则会报错。

- Object.prototype.propertyIsEnumerable()

	- 实例对象的propertyIsEnumerable方法返回一个布尔值，用来判断某个属性是否可遍历。
- 存取器

	- 定义

		- 除了直接定义以外，属性还可以用存取器（accessor）定义。其中，存值函数称为setter，使用属性描述对象的set属性；取值函数称为getter，使用属性描述对象的get属性。

	- 一旦对目标属性定义了存取器，那么存取的时候，都将执行对应的函数。利用这个功能，可以实现许多高级特性，比如某个属性禁止赋值。

	- JavaScript 还提供了存取器的另一种写法。

	- 注意，取值函数get不能接受参数，存值函数set只能接受一个参数（即属性的值）。
	- 存取器往往用于，属性的值依赖对象内部数据的场合。

- 对象的拷贝
- 控制对象状态

	- 概述

		- 有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供了三种冻结方法，最弱的一种是Object.preventExtensions，其次是Object.seal，最强的是Object.freeze。

	- Object.preventExtensions()

		- Object.preventExtensions方法可以使得一个对象无法再添加新的属性。

		- Object.isExtensible()

			- Object.isExtensible方法用于检查一个对象是否使用了Object.preventExtensions方法。也就是说，检查是否可以为一个对象添加属性。

	- Object.seal()

		- Object.seal方法使得一个对象既无法添加新属性，也无法删除旧属性。Object.seal只是禁止新增或删除属性，并不影响修改某个属性的值。

		- Object.isSealed()

			- Object.isSealed方法用于检查一个对象是否使用了Object.seal方法。

	- Object.freeze()

		- Object.freeze方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。

		- Object.isFrozen()

			- Object.isFrozen方法用于检查一个对象是否使用了Object.freeze方法。

	- 局限性

		- 上面的三个方法锁定对象的可写性有一个漏洞：可以通过改变原型对象，来为对象增加属性。

		- 另外一个局限是，如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容。

## 阮一峰·JS面向对 象编程

### 构造函数与 new 命令

- 对象是什么

	- （1）对象是单个实物的抽象。
	- （2）对象是一个容器，封装了属性（property）和方法（method）。

- 构造函数

	- 典型的面向对象编程语言（比如 C++ 和 Java），存在“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。
	- JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成对象的函数。它提供模板，描述对象的基本结构。一个构造函数，可以生成多个对象，这些对象都有相同的结构。
	- 构造函数的特点有两个。

		- 函数体内部使用了this关键字，代表了所要生成的对象实例。
		- 生成对象的时候，必需用new命令，调用Vehicle函数。

- new 命令

	- 基本用法

		- new命令的作用，就是执行构造函数，返回一个实例对象。

			- new命令执行时，构造函数内部的this，就代表了新生成的实例对象

		- 使用new命令时，根据需要，构造函数也可以接受参数。

		- new命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。
		- 如果忘了使用new命令，直接调用构造函数会发生什么事？

			- 这种情况下，构造函数就变成了普通函数，并不会生成实例对象。而且由于后面会说到的原因，this这时代表全局对象，将造成一些意想不到的结果。

			- 解决方法

				- 一个解决办法是，在构造函数内部使用严格模式，即第一行加上use strict。
				- 另一个解决办法，是在构造函数内部判断是否使用new命令，如果发现没有使用，则直接返回一个实例对象。

	- new 命令的原理

		- 概述

			- 使用new命令时，它后面的函数调用就不是正常的调用，而是依次执行下面的步骤。
			- （1）创建一个空对象，作为将要返回的对象实例
			- （2）将这个空对象的原型，指向构造函数的prototype属性
			- （3）将这个空对象赋值给函数内部的this关键字
			- （4）开始执行构造函数内部的代码

		- 原理

			- 构造函数内部，this指的是一个新生成的空对象，所有针对this的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即this对象），将其“构造”为需要的样子。

		- 构造函数有return的情况

			- 如果构造函数内部有return语句，而且return后面跟着一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。

		- 构造函数没有this而使用new来构造的情况

			- 如果对普通函数（内部没有this关键字的函数）使用new命令，则会返回一个空对象。

		- new命令简化的内部流程

	- new.target

		- 定义

			- 函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined。

		- 使用

			- 使用这个属性，可以判断函数调用的时候，是否使用new命令。

	- 使用 Object.create() 创建实例对象

		- 使用Object.create()方法，直接以某个实例对象作为模板，生成一个新的实例对象。
### this 关键字

- 使用场合

	- （1）全局环境

		- 在全局环境使用this，它指的就是顶层对象window。

	- （2）构造函数

		- 构造函数中的this，指的是实例对象。

	- （3）对象的方法

		- 当 A 对象的方法被赋予 B 对象，该方法中的this就从指向 A 对象变成了指向 B 对象。所以要特别小心，将某个对象的方法赋值给另一个对象，会改变this的指向。

- 使用注意点

	- （1）避免多层 this

		- 一个解决方法是在第二层改用一个指向外层this的变量。

		- JavaScript 提供了严格模式，也可以硬性避免这种问题。在严格模式下，如果函数内部的this指向顶层对象，就会报错。

	- （2）避免数组处理方法中的this

		- 数组的map和foreach方法，允许提供一个函数作为参数。这个函数内部不应该使用this。

			- 解决这个问题的一种方法，是使用中间变量。

			- 另一种方法是将this当作foreach方法的第二个参数，固定它的运行环境。

	- （3）避免回调函数中的this

		- 回调函数中的this往往会改变指向，最好避免使用。

- 绑定 this 的方法

	- 概述

		- JavaScript提供了call、apply、bind这三个方法，来切换/固定this的指向。

	- function.prototype.call()

		- 函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。
		- call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。

		- call的第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数。
		- 应用

			- call方法的一个应用是调用对象的原生方法。

	- function.prototype.apply()

		- apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。func.apply(thisValue, [arg1, arg2, ...])
		- 应用

			- （1）找出数组最大元素

			  var a = [10, 2, 4, 15, 9];

			  

			  Math.max.apply(null, a)

			  // 15

				- JavaScript不提供找出数组最大元素的函数。结合使用apply方法和Math.max方法，就可以返回数组的最大元素。

			- （2）将数组的空元素变为undefined

			  Array.apply(null, ["a",,"b"])

			  // [ 'a', undefined, 'b' ]

				- 空元素与undefined的差别在于，数组的forEach方法会跳过空元素，但是不会跳过undefined。因此，遍历内部元素的时候，会得到不同的结果。

			- （3）转换类似数组的对象

			  Array.prototype.slice.apply({0:1,length:1})

			  // [1]

			  

			  Array.prototype.slice.apply({0:1})

			  // []

			  

			  Array.prototype.slice.apply({0:1,length:2})

			  // [1, undefined]

			  

			  Array.prototype.slice.apply({length:1})

			  // [undefined]

				- 上面代码的apply方法的参数都是对象，但是返回结果都是数组，这个方法起作用的前提是，被处理的对象必须有length属性，以及相对应的数字键。

			- （4）绑定回调函数的对象

			  var o = new Object();

			  

			  o.f = function () {

			    console.log(this === o);

			  }

			  

			  var f = function (){

			    o.f.apply(o);

			    // 或者 o.f.call(o);

			  };

			  

			  $('#button').on('click', f);

	- function.prototype.bind()

		- 概述

			- bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。

		- bind比call方法和apply方法更进一步的是，除了绑定this以外，还可以绑定原函数的参数。

		- 如果bind方法的第一个参数是null或undefined，等于将this绑定到全局对象，函数运行时this指向顶层对象（在浏览器中为window）。
		- bind方法有一些使用注意点。

			- （1）每一次返回一个新函数

				- 监听事件的时候，不能写成下面这样。element.addEventListener('click', o.m.bind(o));
click事件绑定bind方法生成的一个匿名函数。这样会导致无法取消绑定
				- 正确的方法是写成下面这样：

					- var listener = o.m.bind(o);
element.addEventListener('click', listener);
//  ...
element.removeEventListener('click', listener);

			- （2）结合回调函数使用

				- 回调函数是JavaScript最常用的模式之一，但是一个常见的错误是，将包含this的方法直接当作回调函数。
				- 还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。这些函数内部的this指向，很可能也会出错。

			- （3）结合call方法使用

				- 利用bind方法，可以改写一些JavaScript原生方法的使用形式，以数组的slice方法为例。

			- （4）与call，apply的区别

				- call和apply都是改变上下文中的this并立即执行这个函数，bind方法可以让对应的函数想什么时候调就什么时候调用，并且可以将参数在执行的时候添加，这是它们的区别

### prototype 对象

- 概述

	- 通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。

- prototype 属性的作用

	- JavaScript 的每个对象都继承另一个对象，后者称为“原型”（prototype）对象
	- 原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在所有实例对象上。

		- 当实例对象本身没有某个属性或方法的时候，它会到构造函数的prototype属性指向的对象，去寻找该属性或方法。这就是原型对象的特殊之处。
		- 如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。

	- 总结

		- 原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象。

- 原型链

	- 原型链的作用

		- “原型链”的作用是，读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的Object.prototype还是找不到，则返回undefined。

	- 对于性能的影响

		- 需要注意的是，一级级向上，在原型链寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。

	- 举例

		- 如果让某个函数的prototype属性指向一个数组，就意味着该函数可以当作数组的构造函数，因为它生成的实例对象都可以通过prototype属性调用数组方法。

- constructor 属性

	- prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。

	- 由于constructor属性定义在prototype对象上面，意味着可以被所有实例对象继承。
	- 作用

		- constructor属性的作用，是分辨原型对象到底属于哪个构造函数。

	- 应用

		- 有了constructor属性，就可以从实例新建另一个实例。

		- 这使得在实例方法中，调用自身的构造函数成为可能。

			- Constr.prototype.createCopy = function () {
  return new this.constructor();
};

	- 注意

		- 修改原型对象时，一般要同时校正constructor属性的指向。

- instanceof 运算符

	- instanceof运算符返回一个布尔值，表示某个对象是否为指定的构造函数的实例。

	- 它会检查右边构建函数的原型对象（prototype），是否在左边对象的原型链上。

	- 由于instanceof对整个原型链上的对象都有效，因此同一个实例对象，可能会对多个构造函数都返回true。

	- 注意

		- instanceof运算符在判断类型的值时只能用于对象，不适用原始类型的值。
		- 对于undefined和null，instanceOf运算符总是返回false。

- Object.getPrototypeOf()

	- Object.getPrototypeOf方法返回一个对象的原型。这是获取原型对象的标准方法。

- Object.setPrototypeOf()

	- Object.setPrototypeOf方法可以为现有对象设置原型，返回一个新对象。
	- Object.setPrototypeOf方法接受两个参数，第一个是现有对象，第二个是原型对象。

- Object.create()

	- 由来

		- 生成实例对象的常用方法，就是使用new命令，让构造函数返回一个实例。但是很多时候，只能拿到一个实例对象，它可能根本不是由构建函数生成的，那么能不能从一个实例对象，生成另一个实例对象呢？

	- 概述

		- JavaScript 提供了Object.create方法，用来满足这种需求。该方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。该实例完全继承原型对象的属性。

	- 手动实现Object.create()

			- Object.create方法的实质是新建一个构造函数F，然后让F.prototype属性指向参数对象obj，最后返回一个F的实例，从而实现让该实例继承obj的属性。

	- 注意

		- 如果想要生成一个不继承任何属性（比如没有toString和valueOf方法）的对象，可以将Object.create的参数设为null。

		- 使用Object.create方法的时候，必须提供对象原型，即参数不能为空，或者不是对象，否则会报错。
		- Object.create方法生成的对象，继承了它的原型对象的构造函数。

- Object.prototype.isPrototypeOf()

	- 对象实例的isPrototypeOf方法，用来判断一个对象是否是另一个对象的原型。

	- 只要某个对象处在原型链上，isPrototypeOf都返回true。

- Object.prototype.__proto__

	- 概述

		- __proto__属性（前后各两个下划线）可以改写某个对象的原型对象。

	- 注意事项

		- 根据语言标准，__proto__属性只有浏览器才需要部署，其他环境可以没有这个属性，而且前后的两根下划线，表示它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用Object.getPrototypeof()（读取）和Object.setPrototypeOf()（设置），进行原型对象的读写操作。

- 获取原型对象方法的比较

	- 获取实例对象obj的原型对象，有三种方法。

		- obj.__proto__
		- obj.constructor.prototype
		- Object.getPrototypeOf(obj)

	- 上面三种方法之中，前两种都不是很可靠。最新的ES6标准规定，__proto__属性只有浏览器才需要部署，其他环境可以不部署。而obj.constructor.prototype在手动改变原型对象时，可能会失效。
	- 推荐使用第三种Object.getPrototypeOf方法，获取原型对象。

### Object 对象与继承

- Object.getOwnPropertyNames()

	- 定义

		- Object.getOwnPropertyNames方法返回一个数组，成员是对象本身的所有属性的键名，不包含继承的属性键名。

	- 与Object.keys()对比

		- 对象本身的属性之中，有的是可以枚举的（enumerable），有的是不可以枚举的，Object.getOwnPropertyNames方法返回所有键名。只获取那些可以枚举的属性，使用Object.keys方法。

- Object.prototype.hasOwnProperty()

	- 定义

		- 对象实例的hasOwnProperty方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上。

	- 特点

		- hasOwnProperty方法是JavaScript之中唯一一个处理对象属性时，不会遍历原型链的方法。

- 对象的拷贝

	- 初步认识

		- 如果要拷贝一个对象，需要做到下面两件事情。

			- 确保拷贝后的对象，与原对象具有同样的prototype原型对象。
			- 确保拷贝后的对象，与原对象具有同样的属性。

	- ES5版本

	  function copyObject(orig) {

	  -  var copy = Object.create(Object.getPrototypeOf(orig));

	   -  copyOwnPropertiesFrom(copy, orig);

	   -  return copy;

	  }

	  

	  function copyOwnPropertiesFrom(target, source) {

	    Object

	    .getOwnPropertyNames(source)

	    .forEach(function(propKey) {

	      var desc = Object.getOwnPropertyDescriptor(source, propKey);

	      Object.defineProperty(target, propKey, desc);

	    });

	    return target;

	  }

	- 另一种更简单的写法，是利用 ES2017 才引入标准的Object.getOwnPropertyDescriptors方法。

	  function copyObject(orig) {

	    return Object.create(

	      Object.getPrototypeOf(orig),

	      Object.getOwnPropertyDescriptors(orig)

	    );

	  }

### 面向对象编程的模式

- 构造函数的继承（注意是构造函数之间的继承，和构造函数通过new关键字生成实例是不一样的）

	- 写法一：让一个构造函数继承另一个构造函数，是非常常见的需求。这可以分成两步实现。

		- 第一步是在子类的构造函数中，调用父类的构造函数。（注意没有new，相当于普通函数，借用了他的属性而已，这一步相当于拷贝了父构造函数的属性且this为子构造函数下的this）

				- 第一步为复制属性

		- 第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型（使用creat是为了不让子构造函数的原型对象影响到父构造函数的原型对象，后两行是指定修改子构造函数为其实例的构造函数，修改原型对象时，一般要同时校正constructor属性的指向。以及自定义方法）

				- 第二步为继承父构造函数原型对象上的方法

	- 写法二：直接让Sub.prototype等于一个父类实例。

		- Sub.prototype = new Super();
		- 上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以不推荐使用这种写法。

	- 举例说明

		- 整体继承

		- 单个方法的继承

- 多重继承（Mixin混入）

	- 概述

		- JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。
		- Object.assign({},obj,obj1);

			- 花括号叫目标对象，后面的obj、obj1是源对象。对象合并是指：将源对象里面的属性添加到目标对象中去，若两者的属性名有冲突，后面的将会覆盖前面的

	- 实例

			- 子类S同时继承了父类M1和M2。这种模式又称为 Mixin（混入）。

- 模块

	- 基本的实现方法

		- 概述

			- 模块是实现特定功能的一组属性和方法的封装。

		- 可以把模块写成一个对象，所有的模块成员都放到这个对象里面。

			- 上面的函数m1和m2，都封装在module1对象里。使用的时候，就是调用这个对象的属性。

				- module1.m1();

			- 但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。

				- module1._count = 5;

	- 封装私有变量：构造函数的写法

		- 可以利用构造函数，封装私有变量。

			- 这种方法将私有变量封装在构造函数中，违反了构造函数与实例对象相分离的原则。并且，非常耗费内存。
			- 这种方法将私有变量放入实例对象中，好处是看上去更自然，但是它的私有变量可以从外部读写，不是很安全。

	- 封装私有变量：立即执行函数的写法

		- 使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。

			- 使用上面的写法，外部代码无法读取内部的_count变量。

	- 模块的扩展模式

		- 如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）。

			- 上面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。

		- 在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽扩展模式”（Loose augmentation）。

			- 与”扩展模式”相比，“宽扩展模式”就是“立即执行函数”的参数可以是空对象。

	- 输入全局变量

		- 独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。
		- 为了在模块内部调用全局变量，必须显式地将其他变量输入模块。

			- 上面的module1模块需要使用jQuery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module1。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。

## 阮一峰·JS语法 专题

### 定时器

- setTimeout()

  过了一定时间执行一次，只执行一次。比如隔一秒后执行一次，过了十万八千秒后也只在第一秒执行了一次，仅有的一次

	- 参数

		- 除了前两个参数，setTimeout还允许添加更多的参数。它们将被传入推迟执行的函数（回调函数）。

	- 需要注意的地方

		- 如果被setTimeout推迟执行的回调函数是某个对象的方法，那么该方法中的this关键字将指向全局环境，而不是定义时所在的那个对象。

- setInterval()

  每间隔一定时间执行一次，循环往复。比如每隔一秒执行一次，六十秒过后执行了60次

	- 应用

		- 一个通过setInterval方法实现网页动画的例子

		- setInterval的一个常见用途是实现轮询。下面是一个轮询URL的Hash值是否发生变化的例子。

	- 注意

		- setInterval指定的是“开始执行”之间的间隔，并不考虑每次任务执行本身所消耗的时间。因此实际上，两次执行之间的间隔会小于指定的时间。比如，setInterval指定每100ms执行一次，每次执行需要5ms，那么第一次执行结束后95毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要105毫秒，那么它结束后，下一次执行就会立即开始。

	- 用setTimeOut代替

		- 为了确保两次执行之间有固定的间隔，可以不用setInterval，而是每次执行结束后，使用setTimeout指定下一次执行的具体时间。

- clearTimeout()，clearInterval()

	- 函数防抖

		- 就是如果用户连续击键，就会连续触发keydown事件，造成大量的Ajax通信。这是不必要的，而且很可能会发生性能问题。正确的做法应该是，设置一个门槛值，表示两次Ajax通信的最小间隔时间。如果在设定的时间内，发生新的keydown事件，则不触发Ajax通信，并且重新开始计时。如果过了指定时间，没有发生新的keydown事件，将进行Ajax通信将数据发送出去。
		- 这种做法叫做debounce（防抖动）方法，用来返回一个新函数。只有当两次触发之间的时间间隔大于事先设定的值，这个新函数才会运行实际的任务。假定两次Ajax通信的间隔不小于2500毫秒，上面的代码可以改写成下面这样。

			- $('textarea').on('keydown', ajaxAction);
			- $('textarea').on('keydown', debounce(ajaxAction, 2500))
		- 注意

			- 现实中，最好不要设置太多个setTimeout和setInterval，它们耗费CPU。比较理想的做法是，将要推迟执行的代码都放在一个函数里，然后只对这个函数使用setTimeout或setInterval。

- 应用

	- 它的一大应用是，可以调整事件的发生顺序。比如，网页开发中，某个事件先发生在子元素，然后冒泡到父元素，即子元素的事件回调函数，会早于父元素的事件回调函数触发。如果，我们先让父元素的事件回调函数先发生，就要用到setTimeout(f, 0)。

	- 用户自定义的回调函数，通常在浏览器的默认动作之前触发。比如，用户在输入框输入文本，keypress事件会在浏览器接收文本之前触发。因此，下面的回调函数是达不到目的的。

	- 由于setTimeout(f,0)实际上意味着，将任务放到浏览器最早可得的空闲时段执行，所以那些计算量大、耗时长的任务，常常会被放到几个小部分，分别放到setTimeout(f,0)里面执行。

			- 上面代码有两种写法，都是改变一个网页元素的背景色。写法一会造成浏览器“堵塞”，因为JavaScript执行速度远高于DOM，会造成大量DOM操作“堆积”，而写法二就不会，这就是setTimeout(f, 0)的好处。
			- 另一个使用这种技巧的例子是代码高亮的处理。如果代码块很大，一次性处理，可能会对性能造成很大的压力，那么将其分成一个个小块，一次处理一块，比如写成setTimeout(highlightNext, 50)的样子，性能压力就会减轻。

### Promise对象

- JavaScript的异步执行

	- 概述

		- JavaScript 语言本身并不慢，慢的是读写外部数据，比如等待 Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。
		- 异步模式

			- “异步模式”中，每一个任务分成两段，第一段代码包含对外部数据的请求，第二段代码被写成一个回调函数，包含了对外部数据的处理。第一段代码执行完，不是立刻执行第二段代码，而是将程序的执行权交给第二个任务。等到外部数据返回了，再由系统通知执行第二段代码。所以，程序的执行顺序与任务的排列顺序是不一致的、异步的。

	- 回调函数

		- 定义

			- 假定有两个函数f1和f2，后者必须等到前者执行完成，才能执行。这时，可以考虑改写f1，把f2写成f1的回调函数。

		- 优缺点

			- 回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），使得程序结构混乱、流程难以追踪（尤其是回调函数嵌套的情况），而且每个任务只能指定一个回调函数。

	- 事件监听

		- 定义

			- 
另一种思路是采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。

		- 做法

			- 还是以f1和f2为例。首先，为f1绑定一个事件（这里采用的jQuery的写法）。

				- f1.on('done', f2);

			- 上面这行代码的意思是，当f1发生done事件，就执行f2。然后，对f1进行改写：

				- function f1(){
  setTimeout(function () {
    // f1的任务代码
    f1.trigger('done');
  }, 1000);
}

			- 上面代码中，f1.trigger('done')表示，执行完成后，立即触发done事件，从而开始执行f2。

		- 优缺点

			- 这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合“（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。

	- 发布/订阅

		- 定义

			- “事件”完全可以理解成”信号”，如果存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式“，又称”观察者模式“。

		- 实现（采用一个插件来实现）

			- 首先，f2向”信号中心”jQuery订阅”done”信号。

			- 然后，f1进行如下改写：

			- f2完成执行后，也可以取消订阅（unsubscribe）。

		- 优缺点

			- 这种方法的性质与”事件监听”类似，但是明显优于后者。因为我们可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。

- 异步操作的流程控制

	- 初步认识

		- 如果有多个异步操作，就存在一个流程控制的问题：确定操作执行的顺序，以后如何保证遵守这种顺序。
		- 回调函数的嵌套

			- async函数是一个异步任务，非常耗时，每次执行需要1秒才能完成，然后再调用回调函数。

			- 如果有6个这样的异步任务，需要全部完成后，才能执行下一步的final函数。

			- 只能采用6个回调函数的嵌套，不仅写起来麻烦，易出错，且难维护

	- 串行执行

		- 我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。
			- 此处定义的async第一个参数是异步任务的参数，第二个参数是异步任务的回调函数，这里回调函数直接在调用的时候才定义

		- 上面代码中，函数series就是串行函数，它会依次执行异步任务，所有任务都完成后，才会执行final函数。items数组保存每一个异步任务的参数，results数组保存每一个异步任务的运行结果。

	- 并行执行

		- 流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行final函数。
		- 上面代码中，forEach方法会同时发起6个异步任务，等到它们全部完成以后，才会执行final函数。
		- 优缺点

			- 并行执行的好处是效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。



		- 所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行n个异步任务。这样就避免了过分占用系统资源。
		- 上面代码中，最多只能同时运行两个异步任务。变量running记录当前正在运行的任务数，只要低于门槛值，就再启动一个新的任务，如果等于0，就表示所有任务都执行完了，这时就执行final函数。

- Promise对象

	- 简介

		- Promise 对象是 CommonJS 工作组提出的一种规范，目的是为异步操作提供统一接口。
		- 初步认识

			- 首先，它是一个对象，也就是说与其他JavaScript对象的用法，没有什么两样；其次，它起到代理作用（proxy），充当异步操作与回调函数之间的中介。它使得异步操作具备同步操作的接口，使得程序具备正常的同步运行的流程，回调函数不必再一层层嵌套。

		- 三种状态

			- 异步操作未完成（pending）
			- 异步操作成功（fulfilled）
			- 异步操作失败（rejected）

		- 使用

			- 它的思想是，每一个异步任务立刻返回一个Promise对象，由于是立刻返回，所以可以采用同步操作的流程。这个Promises对象有一个then方法，允许指定回调函数，在异步任务完成后调用。

				- 比如，异步操作f1返回一个Promise对象，它的回调函数f2写法如下。

				- 这种写法对于多层嵌套的回调函数尤其方便。

		- 总结

			- 总的来说，传统的回调函数写法使得代码混成一团，变得横向发展而不是向下发展。Promises规范就是为了解决这个问题而提出的，目标是使用正常的程序流程（同步），来处理异步操作。它先返回一个Promise对象，后面的操作以同步的方式，寄存在这个对象上面。等到异步操作有了结果，再执行前期寄放在它上面的其他操作。

	- Promise接口

		- Promise接口的基本思想是，异步任务返回一个Promise对象。
		- Promise对象的最终结果只有两种。

			- 异步操作成功，Promise对象传回一个值，状态变为resolved。
			- 异步操作失败，Promise对象抛出一个错误，状态变为rejected。

		- 回调函数then

			- Promise对象使用then方法添加回调函数。then方法可以接受两个回调函数，第一个是异步操作成功时（变为resolved状态）时的回调函数，第二个是异步操作失败（变为rejected）时的回调函数（可以省略）。一旦状态改变，就调用相应的回调函数。

			- then方法可以链式使用。

- Promise的应用

