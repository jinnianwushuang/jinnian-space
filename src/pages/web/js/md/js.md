# js

## 作用域

### 执行上下文

- 变量对象 AO

	- 变量对象是与执行上下文相关的数据作用域

		- 全局上下文

			- 变量对象即全局对象

		- 函数上下文

			- 活动对象，是由引擎实现的，在执行上下文中被激活

		- AO（活动变量） = VO（变量对象 + function parameters + arguments

	- 变量对象在执行过程中的变化

		- 进入执行上下文

			- 创建变量对象

		- 代码执行

			- 顺序执行代码，修改上下文变量的值

		- 执行完毕，上下文弹出

	- 函数的所有形参
	- 函数声明
	- 变量声明

- 作用域链 Scope

	- 函数被创建，保存函数父作用域到函数[[scope]]属性
	- 函数执行，进入上下文吗，函数作用域压入栈
	- 复制函数[[scope]]属性，创建作用域链
	- 用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明
	- 将活动对象压入  函数作用域链顶端
	- 开始执行函数，随着函数的执行，修改 AO 的属性值
	- 函数执行完毕，函数上下文从执行上下文栈中弹出

- this

	- 简单的理解 this 为调用函数的对象

- 执行上下文

	- JavaScript代码被解析和执行时所在环境的抽象概念
	- 执行上下文的类型

		- 全局执行上下文

			- 只有一个，浏览器中的全局对象window，this执行这个全局对象

		- 函数执行上下文

			- 存在无数个，在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文

		- Eval函数执行上下文

			- 指运行在eval函数中的代码，不建议使用

	- 执行栈也叫调用栈

		- 用于存储在代码执行期间创建的所有执行上下文
		- 首次运行会创建一个全局的执行上下文，push到当前的执行栈中，每当有函数调用，引擎都会为该函数创建一个新的函数执行上下文并push到当前执行栈的栈顶。
		- 栈顶函数运行完成后，会将其pop出栈，执行下一个栈顶函数

	- 执行上下文的创建

		- 创建阶段

			- 确定this
			- 词法环境

				- 环境记录

					- 存储变量和函数声明的实际位置

				- 对外部环境的引用

					- 可以访问的外部词法环境

			- 变量环境

				- 也是一个词法环境

					- 主要区别变量使用var声明、而词法环境用let、const声明

		- 执行阶段

			- 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值
			- 在代码执行阶段，会再次修改变量对象的属性值

### 提升

- 提升

	- 引擎会 在解释 JavaScript 代码之前首先对其进行编译。编译阶段找到所有声明,用合适的作用域将它们关联起来
	- var a = 2; 会被拆成两个阶段进行，var a （编译阶段）a=2（执行阶段），这个过程就叫作 提升
	- 一个普通块内部的函数声明通常会被提升到所在作用域的顶部
	- 每个作用域 都会进行提升操作

- 函数优先

	- 函数会首先被提升,然后才是变量

### 词法作用域

- 词法阶段

	- 词法作用域都只由函数被声明时所处的位置决定
	- 作用域查找会在找到第一个匹配的标识符时停止（遮蔽效应）

- 欺骗词法

	- 欺骗词法作用域会导致性能 下降，不是好主意
	- eval
	- with

### 函数作用域和块作用域

- 隐藏内部实现

	- 从所写的代码中挑选出一个任意的片段,然后用函数声明对它进行包装（隐藏代码）
	- 规避冲突：“隐藏”作用域中的变量和函数所带来的另一个好处,是可以避免同名标识符之间的冲突
	- 规避冲突方法

		- 命名空间
		- 模块管理

- 函数作用域

	- 匿名函数，最熟悉的场景可能就是回调参数

		- 匿名函数在栈追踪中不会显示出有意义的函数名,使得调试很困难。
		- 如果没有函数名,当函数需要引用自身时只能使用已经 过期 的 arguments.callee 引用
		- 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名

	- 立即执行函数表达式，IIFE

		- 普遍的进阶用法是把它们当作函数调用并传递参数进去
		- IIFE 还有一种变化的用途是倒置代码的运行顺序

- 块作用域

	- with 关键字是 块作用域的一 个例子
	- try / catch 的 catch 分句会创建一个块作 用域
	-  ES6 引入了新的 let 关键字
	- ES6 还引入了 const , 同样可以用来创建块作用域变量
	- 另一个块作用域非常有用的原因和闭包及回收内存垃圾的回收机制相关

### 作用域

- 能够储存变量当中的值,并且能在之后对这个 值进行访问或修改
- 编译原理

	- 分词/词法分析：这个过程会将由字符组成的字符串分解成(对编程语言来说)有意义的代码块
	- 解析/语法分析:将词法单元流(数组)转换成一个由元素逐级嵌套所组成的代表了程序语法
结构的树(抽象语法树 AST)
	- 代码生成:将 AST 转换为可执行代码的过程称被称为代码生成
	- javascript 编译过程发生在代码执行前几微妙
	- JavaScript 引擎用尽了各种办法(比如 JIT, 可以延 迟编译甚至实施重编译)来保证性能最佳。

- 作用域

	- 几个概念

		- 编译器
		- 引擎
		- 作用域

	- var a = 2;

		- 编译器会询问作用域是否已经有一个该名称的变量

			- 如果是,编译器会忽略该声明
			- 否则,要求作用域在当前集合声明一个新变量 a

		- 接下来编译器会为引擎生成运行时所需的代码，处理 a=2 的赋值操作

	- 引擎查找变量规则

		- LHS，当变量出现在赋值操作的左侧时进行LHS查询
		- RHS,出现在右侧时进行RHS查询

	- 作用域嵌套

		- 引擎从当前的执行作用域开始查找变量,如果找不到, 就向上一级继续查找

### 作用域闭包

- javascript 中闭包无处不在,你只需要能够识别并拥抱它
- 闭包概念

	- 闭包：函数是在当前词法作用 域之外执行
	- 闭包阻止了引擎有垃圾回收器用来释放不再使用的内存空间
	- 函数不在定义词法中执行，但是依然保持对该词法的引用，这个引用叫做闭包

- 模块

	- 最常见的实现模块模式的方法通常被称为 模块暴露
	- 必须有外部的封闭函数,每次调用都会创建一个新的模块 实例
	- 封闭函数必须返回至少一个内部函数
	- 大多数模块依赖加载器 / 管理器本质上都是将这种模块定义封装进一个友好的 API。
	- ES6 会将文件当作独立 的模块来处理

		- 每个模块都可以导入其他模块或特定的 API 成员
		- 同样也可以导出自己的 API 成员

## this

### this 的误解

- 隐式传递一个对象的引用
- this 在任何情况下都不指向函数的词法作用域
- this 是在函数运行时，创建上下文的时候确定的

### this 的绑定规则

- 默认绑定

	- 使用不带任何修饰的函数引用进行调用的

- 隐式绑定

	- 调用位置是否有上下文对象
	- 隐式丢失

		- 通常发生在对象赋值的情况

- 显式绑定

	- 使用函数的 call(..) 和 apply(..) 方法
	- 硬绑定

- new 绑定

	- 创建(或者说构造)一个全新的对象。
	- 这个新对象会被执行[[原型]]连接。
	- 这个新对象会绑定到函数调用的 this
	- 如果函数没有返回其他对象,那么 new 表达式中的函数调用会自动返回这个新对象

### 箭头函数 this 指向

- 根据外层(函数或者全局)作用域来决 定 this

## 原型

###   [[Prototype]]

- JavaScript 中的对象有一个特殊的内置属性，是对于其他对象的引 用
- 对象访问属性会触发[[Get]]操作，如果无法在本身找到需要的属性
如果没有就要使用对象的 [[Prototype]] 链了
- 任何可以通过原型链访问到的属性都会被枚举
- 所有 普通 的 [[Prototype]] 链最终都会指向内置的 Object.prototype 。
- 属性的设置（例如赋值操作）

	- 属性不存在于原型链上层，新属性会被直接添加到对象上
	- （普通访问属性）属性存在于原型链上层，创建（屏蔽属性）新属性
	- 标记为只读( writable:false )属性存在于原型链上，不会进行赋值，不发生屏蔽
	- 新属性在原型链上以setter 的形式纯在，调用 setter ，不添加新属性，不发生屏蔽

### “类”

- JavaScript 中 只有 对象。
- “ 类 ” 函数

	- 所有的函数默认都会拥有一个 名为 prototype 的公有并且不可枚举的属性,它会指向另一个对象
	- javascript 可以创建多个对象，并将他们关联到同一个原型
	- function Foo(){...}; var a=new Foo();造成了a.[[prototype]]==Foo.prototype(实例与原型的关联)
	- javascript 和传统的面向对象的继承不太一样，不会将“类”复制到“实例”中，而是通过原型链将他们关联起来

- ”构造函数“

	- Foo.prototype 默认(在代码中第一行声明时!)有一个公有并且不可枚举的属性 .constructor
	- 函数本身并不是构造函数，new 关键字，把函数变成“构造函数”

- 技术

	- constructor 并不表示被构造
	- Foo.prototype.constructor === Foo;    a.constructor === Foo

### （原型）继承

- Object.create(..) 会凭空创建一个“新”对象并把新对象内部的 [[Prototype]] 关联到你指定的对象
- 通过.__proto__ 属性修改对象关联
- 判断对象是否委托关联某个函数，instanceof 操作符的左操作数是一个普通的对象,右操作数是一个函数

### 对象关联

- [[Prototype]] 机制就是存在于对象中的一个内部链接, 它会引用其他 对象。
- var bar = Object.create( foo );  Object.create(..) 会创建一个新对象( bar )并把它关联到我们指定的对象( foo )

## 数据类型

### 类型

- Undefined

	- 只有一个值：undefined，变量不需要显性设置为undefined值
	- undefined 指没有值(missing value)，指从未赋值
	- void 并不改变表达式的结果,只是让表达式不返回值
	- undefined 是一个内置标识符 它的值为 undefined，通过 void 运算符即可得到该值
	- 声明但未初始化的变量和未声明的变量都返回undefined

- Null

	- 空对象指针，只有一个值null
	- null 指空值(empty value)，指曾赋过值,但是目前没有值
	- typeof 返回"object"，准备用于保存对象的变量初始化时最好为null
	- undefined值派生自null值，undefined==null返回true

- Boolean

	- 两个字面值true和false，ECMAScript中所有类型的值都有与这两个值等价的值
	- 不同数据类型转换为Boolean

		- String类型：任何非空字符串可转换为true，""(空字符串)转换为false
		- Number：任何非零数字值可转换为true，0和NaN转换为false
		- Object：任何对象可转换为true，null转换为false
		- Undefined：n/a（not applicable，“不适用”）可转换为true，undefined可转换为false

- Number

	- 数字语法

		- 包括“整数”和带小数的十进制数
		- 数字前后的 0 都可以省略
		- 特别大和特别小的数字默认用指数格式显示
		- tofixed(..) 方法可指定小数部分的显示位数
		- toPrecision(..) 方法用来指定 有效数位 的显示位数
		- 小数点是一种运算符，常见一种数字调用函数方式 42..tofixed(3)
		- 数字常量还可以用其他格式来表示,如二进制、八进制和十六进制

	- 较小的数值

		- 0.1 + 0.2 === 0.3; // false
		- 如何判断 0.1 + 0.2 的值是否和 0.3相等 
		- 最常见的方法是设置一个误差范围值, 通常称为“机器精度”

	-  整数的安全范围

		- 能够被“安全”呈现的最大整数是 2^53 - 1
		- 最小整数是 -（2^53 - 1）
		- 需 要 处 理 一 些 比 较 大 的 数 字，（转存）保存成字符串

	- 整数检测

		- 使用 ES6 中的 Number.isInteger(..) 方法
		- return typeof num == "number" && num % 1 == 0;
		- 可以使用 ES6 中的 Number.isSafeInteger(..)
		- return Number.isInteger( num ) && Math.abs( num ) <= Number.MAX_SAFE_INTEGER;

	- 32 位有符号整数

		- 是有些数字操作(如数位操作)只适用于 32 位数字

	- 整数

		- 进制表示格式

			- 十进制
			- 八进制字面值第一位为0，然后是八进制数字序列（0~7）
			- 十六进制前两位为0x，后面跟十六进制数字（0~f），字母大小写都可以

		- 进行算术计算时所有以八进制和十六进制表示的数值都将被转换为十进制

	- 浮点数值

		- 浮点数值必须有一个小数点，小数点后必须有至少一位小数，最高精度是17位小数
		- e表示法（科学记数法）：3.125e7=3.125*10^7=31250000
		- 浮点数值计算会产生舍入误差如0.1+0.2=0.30000000000000004不等于0.3，所以不要用特定浮点数值进行测试

	- NaN（非数值）

		- 表示一个本来要返回数值的操作数未返回数值的情况
		- 任何涉及NaN的操作都会返回NaN，同时NaN与任何数值包括自身都不相等（NaN==NaN返回false）
		- isNaN()函数：接收一个值后，尝试将其转换为数值。不能被转换为数值的值会导致这个函数返回true

	- 无穷数 Infinity
	- 零值

		- JavaScript 有一个常规的 0 (也叫作 +0 )和一个 -0

	- 特殊等式

		- NaN 和自身不相等
		- -0 等于 0
		- ES6中新加入了一个工具方法 Object.is(..) 来判断两个值是否绝对相等

	- 数值转换函数

		- parseInt()
		- Number()
		- parseFloat()

- String

	- 以引号（单双引号都可以但是要配对）表示
	- 字符串一旦创建，值就不可变
	- 字符串和数组的确很相似,它们都是类数组
	- JavaScript 中字符串是不可变的, 而数组是可变的
	- 通过“借用”数 组的非变更方法来处理字符串
	- 转换为字符串

		- toString()方法，适用于数值、布尔值、对象和字符串值

			- 调用数值的toString()方法时可以传递一个参数，来输出以二进制、八进制等进制格式表示的字符串

- 数组

	- 数组可以容纳任何类型的值
	- 使用delete删除数组内容，但是数组的长度不会变化
	- 字符串键值能够被强制类型转换为十进制数字的话,它 就会被当作数字索引来处理
	- 有时需要将类数组转换为真正的数组

- symbol（es6 新增）

### 引用类型（对象定义）

- Object类型 

	- 创建方法

		- 使用new操作符跟Object构造函数

			- var person=new Object(); person.name="Nick"; person.age=29;

		- 对象字面量表示法

			- var person={ name: "Nick", age:29}; 花括号内可以为空，属性名可以使用字符串如"name": "Nick"

	- 对象的内容（属性）

		- 对象的内容（属性）
		- 属性名永远都是字符串。
		- 对象的“方法”：对函数的一种引用
		- 复制对象

			- 深拷贝
			- 浅拷贝

		- 属性描述符

			- writable (可写)
			- enumerable (可枚举)
			- configurable (可配置)

		-   [[Get]]

			-  myObject.a 在 myObject 上实际上是实现了 [[Get]] 操作

		-   [[Put]]

			- 并非在赋值的时候触发，具体逻辑在原型链里做分析

		- 使用 getter 和 setter 部分改写默认操作（运用在单个属性上）

			- getter 是一个隐藏函数,会在获取属性值时调用
			- setter 也是一个隐藏 函数,会在设置属性值时调用

		- hasOwnProperty(..) 方法检查属性是否存在
		- 不可变

			- Object.seal(..)
			- Object.preventExtensions(..)
			- Object.freeze(..)

		- 属性遍历

	- 访问方法

		- 点表示法 person.name
		- 属性名中包含易导致语法错误的字符或使用变量时可以用方括号表示法 person["first name"]

- Array类型

	- 数组的每一项可以保存任何类型的数据
	- 创建方法

		- 使用Array构造函数

			- var colors= new Array(); new操作符可省略，可以给构造函数传递要保存的项目数量，该数量会自动成为length属性的值

		- 数组字面量表示法

			- var colors=["red", "blue", "green" ]

	- 数组的length属性可以修改，通过设置这个属性可以从数组末尾移除或添加项

		- 利用length属性的值也可以方便地添加新项，因为数组最后一项的索引始终是length-1
		- var colors=["red", "blue", "green" ]; colors[colors.length]= "black"; colors[colors.length]= "brown";

	- 检测方法

		- Array.isArray()
		- instanceof只适用于一个全局执行环境

	- 转换方法

		- toLocaleString()/toString()/valueOf()

	- 栈方法（Last-In-First-Out后进先出）

		- push()方法：接受任意数量的参数，逐个添加到数组末尾并返回修改后的数组长度
		- pop()方法：从数组末尾移除最后一项，减少数组的length值并返回移除的项

	- 队列方法FIFO（先进先出）

		- shift()方法：移除数组中的第一个项，减少数组长度并返回移除的项
		- shift()方法和push()方法合用可以像使用队列一样使用数组
		- unshift()方法：在数组前端添加任意个项并返回数组的length
		- unshift()方法与pop()方法合用可以从反方向模拟队列

	- 重排序方法

		- reverse()方法：反转数组项的顺序
		- sort()方法：按升序排列数组项

			- 通过调用每个数组项的toString()方法来比较得到的字符串，很多情况下不符合要求
			- 可以接收一个比较函数作为参数，方便指定数组项排序

	- 操作方法

		- contact()方法基于当前数组所有项创建一个新数组

			- var colors2=colors1.concat("yellow", ["black", "brown"]); 返回新构建的数组

		- slice()方法基于当前数组的一个或多个项创建一个新数组

			- var colors2=colors1.slice(1);一个参数情况下返回该参数指定位置到当前数组末尾所有项
			-  var colors3=colors1.slice(1, 4); 两个参数情况下返回起始位置和结束位置之间的项，不包括结束位置的项

		- splice()方法

			- 删除

				- 指定2个参数：要删除的第一项的位置和要删除的项数，删除任意数量的项

					- .splice(1, 4);

			- 插入

				- 指定3个参数：起始位置、0（要删除的项数）、要插入的项

					- .splice(2, 0, "yellow", "orange");

			- 替换

				- 指定3个参数：起始位置、要删除的项数、要插入的项

	- 位置方法

		- indexOf()方法

			- 接收两个参数，分别表示要检索的项和索引起始位置

		- LastindexOf()方法

			- 同上

	- 迭代方法

		- every()
		- filter()
		- forEach()
		- map()
		- some()

	- 归并方法

- Date类型

	- 创建方法

		- 使用new操作符和Date构造函数

			- var now= new Date();
			- 传参数的方法

				- Date.parse()方法

					- 接受一个表示日期的字符串，尝试根据字符串返回相应日期的毫秒数，未定义支持的日期格式
					- var someDate= new Date(Date.parse("May 25, 2004")); 如字符串不能表示日期，返回NaN
					- var someDate=new Date("May 25, 2004);直接将表示日期的字符串传给Date函数会在后台直接调用Date.parse()方法

				- Date.UTC()方法

					- var someDate=new Date(Date.UTC(2005,4,5,17,55,55));
					- 参数分别是年、月、日、小时、分钟、秒、毫秒等，其中月份从0开始
					- 也可以直接将表示日期的字符串传给Date函数

		- Date.now()返回表示调用这个函数的日期和时间

### 值和类型

- JavaScript 中的变量是没有类型的, 只有值才有
- 变量可以随时持有任何类型的值
- undefi ned 和 undeclared

	- 变量在未持有值的时候为 undefined
	- 还没有在作用域中声明 过的变量,是 undeclared 的
	- “undefined”和“is not defined”是两码事

-   typeof  Undeclared

	- 会检查变量是否已被声明
	- 访问不存在的对象属性不会产生 ReferenceError 错误

## 原生函数

### 常用的原生函数有

- String()
- Number()
- Boolean()
- Array()
- Object()
- Function()
- RegExp()
- Date()
- Error()
- Symbol()——ES6 中新加入的!

### 内部属性[[class]]

- 所有 typeof 返回值为 "object" 的对象(如数组)都包含一个内部属性 [[Class]]

### 封装对象包装

- 基 本 类 型 值 没 有 .length 和 .toString() 这样的属性和方法,需要通过封装对象才能访问
- 封装对象释疑  !new Boolean( false ) //false

### 拆封

- 如果想要得到封装对象中的基本类型值,可以使用 valueOf() 函数

### 原生函数作为构造函数

-   Array(..)

	- Array 构造函数只带一个数字参数的时候,该参数会被作为数组的预设长度
	- 包含至少一个“空单元”的数组称为“稀疏数组”
	- 可以通过 delete b[1] 在数组 b 中制造出一个空单元
	- 永远不要 创建和使用空单元数组

- Object(..)、Function(..) 和 RegExp(..)

	- 尽量不要使用 Object(..) / Function(..) / RegExp(..)
	- 使用 new Object() 来创建对象,必须逐一设置属性
	- 构造函数 Function 只在极少数情况下很有用,比如动态定义函数参数和函数体的时候
	- 强烈建议使用常量形式(如 /^a*b+/g )来定义正则表达式

- Date(..) 和 Error(..)

	- Date(..) 可以带参数,用来指定日期和时间,而不带 参数的话则使用当前的日期和时间。
	- 创建错误对象(error object)主要是为了获得当前运行栈的上下文

- Symbol(..)

	- 符号是具有唯一性的特殊值(并 非绝对),用它来命名对象属性不容易导致重名
	- 不能带 new 关键 字,否则会出错:

- 原生原型

	- 原生构造函数有自己的 .prototype 对象,如 Array.prototype 、 String.prototype 等
	- 将原型作为默认值，例如：, RegExp.prototype 是一个“空”的正则表达式

## 强制类型转换

### 值类型转换

- 将值从一种类型转换为另一种类型通常称为 类型转换（显示）

	- 类型转换发生在静态类型语言的编译阶段

- 隐式的情况称为 强制类型转换

	- 强制类型转换则发生在动态类型语言的运行时

### 抽象值操作

- ToString

	- 它负责处理非字符串到字符串的强制类型转换
	- 对普通对象来说, 除非自行定义, 否则 toString() ( Object.prototype.toString() )返回 内部 属性 [[Class]] 的值
	- 数组的默认 toString() 方法经过了重新定义, 将所有单元字符串化以后再用 "," 连接起 来
	- 工具函数 JSON.stringify(..) 在将JSON对象序列化为字符串时也用到了 ToString
	- JSON.stringify(..) 在对象中遇到 undefined 、 function 和 symbol 时会自动将其忽略，在数组中则返回 null
	- toJSON() 应该“返回一个能够被字符串化的安全的 JSON 值”, 而不是“返回 一个 JSON 字符串”
	- 字符串、数字、布尔值和 null 的 JSON.stringify(..) 规则与 ToString 基本相同
	- 如果传递给 JSON.stringify(..) 的对象中定义了 toJSON() 方法, 那么该方法会在字符 串化前调用,以便将对象转换为安全的 JSON 值

- ToNumber

	- 对象(包括数组)会首先被转换为相应的基本类型值
	- 处理失败 时返回 NaN
	- 检查该值是否有 valueOf() 方法

		- 如果有

			- 使用该值进行强制类型转换

		- 如果没有

			- 使用 toString() 的返回值(如果存在)来进行强制类型转换。

- ToBoolean

	- 可以被强制类型转换为 false 的值
	- 其他(被强制类型转换为 true 的值)
	- 假值

		- undefined
		- null
		- false
		- +0、-0和 NaN
		- “ ”

	- 假值对象

		- document.all 

	- 真值

		- 假值列表之外的值

### 显式强制类型转换

- 字符串和数字之间转换

	- 日期显式转换为数字

		- +new Date();

	- 奇特的 ~ 运算符

		- 字位运算符(如 | 和 ~ )和某些特殊数字一起使用时会产生
类似强制类型转换的效果

	- 字位截除

		- 使用 ~~ 来截除数字值的小数部分

- 显式解析数字字符串

	- 解析非字符串

		- parseInt(..) 会根据字符串的第一个字符来自行决定基数

- 显式转换为布尔值

	- 三元运算符
	- if 判断
	- ！！强制转换

### 隐式强制类型转换

- 隐式地简化

	- 隐式强制类 型转换同样可以用来提高代码可读性

- 字符串和数字之间的隐式强制类型转换

	- 根据 ToPrimitive 抽象操作规则, a + "" 会对 a 调用 valueOf() 方法,然后通过 ToString 抽象 操作将返回值转换为字符串
	- - 是数字减法运算符,因此 “3.14” - 0 会将 “3.14” 强制类型转换为数字。

- 布尔值到数字的隐式强制类型转换

	- 复杂的布尔逻辑转换为数字加法

-  隐式强制类型转换为布尔值

	- if (..)
	- for ( .. ; .. ; .. )
	- while (..) 和 do..while(..)
	- ? :
	- 逻辑运算符 || (逻辑或)和 && (逻辑与)左边的操作数

- || 和 &&
- 符号的强制类型转换

	- 从符号到字符串的 显式 强制类型转换,然而 隐式 强制类型转换会产生错误

### 宽松相等和严格相等

- == 允许在相等比较中进行强制类型转换,而 === 不允许
- 相等比较操作的性能

	- 然强制类型转换确实要多花点时间, 但仅仅是微秒级 (百万分之一秒)的差别而已

- 抽象相等

	- NaN 不等于NaN
	- +0 等于-0
	- == 在比较两个不同类型的值时会发生 隐式 强制类型转换
	- true 和 false 与其他类型之间的相等比较
	- == 对不同的类型组合处理方式不同 
	- 在 == 中 null 和 undefined 相等
	- 对象和非对象之间的相等比较

		- 对对象调用 ToPromitive 抽象操作，拆分封装对象

-  比较少见的情况

	- 返回其他数字
	- 假值的相等比较
	- 极端情况
	- 完整性检查
	- 安全运用隐式强制类型转换

### 抽象关系比较

- 比较双方都是字符串

	- 则按字母顺序来进行比较

- 和其他情况

	- 比较双方首先调用 ToPrimitive ,如果结果出现非字符串,就根据 ToNumber 规则将双方强 制类型转换为数字来进行比较。

- 相等比较有严格相等,关系比较却没有“严格关系比较”

## 语法

### 语句和表达式

- 语句相当于句子, 表达式相当于短语
- var b = a 称为“声明语句”
- b = a (不带 var )叫作“赋值表达式”
- 语句的结果值

	- 在控制台中输入 var a = 42 会得到结果值 undefined
	- 代码中是没有办法获得这个结果值
	- 代码块，返回最后一条语句的结果值
	- 多个赋值语句串联时 ,赋值表达式(和语句)的结果值就 能派上用场

- 表达式副作用

	- 递增运算符 ++ 和递减运算符 -- 都是一元运算符
	- ++a++ 会产生 ReferenceError 错误, 因为运算符需要将产生的副作用赋值给 一个变量

- 上下文规则

	- 大括号
	- 代码块
	- 对象解构
	- else if 和可选代码块

### 运算符优先级

- 短路

	- && 和 || 运算符的“短路”
	- 如果从左边的操作数能够得出结果,就可以忽略右边的操作数

- 更强的绑定

	- a && b || c ? c || b ? a : c && b : a

- 关联
- 释疑

	- 编写程序时要将两者结合起来,既要依赖运算符 优先级 关联规则
	- 也要适当使用 ( ) 自行控制方式

### 自动分号

- 有时 JavaScript 会自动为代码行补上缺失的分号, 即自动分号插入
- , ASI 只在换行符处起作用,而不会在代码行的中间插入分号
- ASI 实际上是一个“纠错”(error correction)机制
- 建议在所有需要的地方加上分号,将对 ASI  的依赖降到最低

### 错误

- 在编译阶段发现的代码错误叫作“早期错误”
- 这些错误在代码执行之前是无法用 try..catch 来捕获的，还会导致解析/编译 失败。
- 非法正则产生早期错误
- 语法规定赋值对象必须是一个标识符
- 严格模式中,函数的参数不能重名
- ES6 规范定义了一个新概念,暂时性死区

### 函数参数

- 在 ES6 中,如果参数被省略或者值为 undefined ,则取该参数的默认值
- 如果向参数传递 undefined ，会出现一个undefined 单元，而不是默认值
- 向函数传递参数时, arguments 数组中的对应单元会和命名参数建立关联

### try..finally

- finally 中的代码总是会在 try 之后执行,如果有 catch 的话则在 catch 之后执行
- try 中的 return ，函数执行完毕后悔将函数的返回值设置为 return 的值
- 如果 finally 中抛出异常(无论是有意还是无意),函数就会在此处终止

###   switch

- 可以把它看作 if..else if..else.. 的简化版本

## 回调

### 　continuation

- 回调函数包裹或者说封装了程序的延续（continuation）
- 代码变得更加难以理解、追踪、调试和维护

### 顺序的大脑

- 并行执行多个任务时，实际上极有可能是在进行快速的上下文切换
- 异步事件并发机制很相似
- JavaScript 程序中总是有很多噪声，使得代码更加杂乱回调地狱理解起来很难
- 顺序阻塞式的大脑计划行为无法很好地映射到面向回调的异步代码

### 信任问题

- 控制反转 （inversion of control），也就是把自己程序一部分的执行控制交给某个第三方
- 对于被传给你无法信任的工具的每个回调，你都将不得不创建大量的混乱逻辑
- 回调最大的问题是控制反转，它会导致信任链的完全断裂
- 没有应用某种逻辑来解决所有这些控制反转导致的信任问题
那你的代码现在已经有了 bug

### 省点回调

- 为了更优雅地处理错误，有些 API 设计提供了分离回调 
- 回调可以实现你想要的功能，但是要付出很多努力，代码也会变得笨重

## ajax

### Ajax

- 请求

	- 流程

		- 1.创建浏览器内置的对象 XMLHttpRequest
		- 2.调用xhr对象的open方法，设置请求方式和请求的url
		- 3.调用xhr对象的send方法，向服务器发送请求
		- 4.当请求响应整个过程结束，然后接收服务器响应的结果（返回的数据）

			- 使用xhr的response属性来接收服务器响应的结果

	- 方式

		- get

			- 说明：一般用户从服务器获取数据
			- 参数：需要在设置url的时候将参数传递

				- 例子：?nam=xxx&sex=yyy

			- 缓存：

				- 说明：在get的请求方式下，IE浏览器会出现缓存现象
				- 解决办法：接收动态参数

		- post

			- 说明：把数据提交给服务器
			- 参数：需要在send发送请求处添加参数

				- 例子：xhr.send('name=zhangsan&age=18')

			- 注意：

				- post会比get请求多一行代码：xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')

- 响应数据格式

	- JSON

		- 本质：字符串
		- 注意点：

			- 1.JSON 中属性名称必须用“双引号”包裹
			- 2.JSON 中表述字符串（值）必须使用双引号
			- 3.JSON 中不能有注释
			- 4.JSON 没有 undefined 这个值

	- XML

		-  可扩展标记语言

			- 1.只有一个根标签
			- 2.区分大小写
			- 3.标签必须闭合
			- 4.属性值必须加引号

	- HTML

		- 超文本标记语言

- 模板引擎

	- 使用的原因：可以更容易更高效的将数据渲染到HTML字符串中
	- 使用步骤：

		- 1.引入template-web.js文件
		- 2.定义模板，一定要指定script的id和type属性
		- 3.调用template函数，为模板分配数据，template函数有两个参数一个返回值
	1）. 参数1：模板的id
	2）. 参数2：分配的数据，必须是一个JS对象的形式
	3）. 一个返回值：是数据和模板标签组合好的结果

	- 调用方式：

		- 普通流：var
		- 条件：if age > 18
		- 循环：each arr

- 异步&同步

	- 同步

		- 例：一个人在同一个时刻只能做一件事情，在执行一些耗时的操作的时候，不能去做别的事，只是等待

	- 异步

		- 例：在执行一些耗时的操作的时候，同时去做别的事，而不是等待

	- xhr.open（请求参数，请求url，boolean） 

		- 第三个参数即为false同步，true异步（默认）

- XHR对象其他API

	- 1.readyState

		- 状态 xhr.readyState

			- 0

				- 代理（XHR）被创建，但尚未调用 `open()` 方法。

			- 1

				- open()` 方法已经被调用，建立了连接。

			- 2

				- send()` 方法已经被调用，并且已经可以获取状态行和响应头。

			- 3

				- 响应体（服务器返回的数据）下载中， `responseText` 属性可能已经包含部分数据。

			- 4

				- 响应体（服务器返回的数据）下载完成，可以直接使用 `responseText`或response 获取完整的结果。

	- 2.onreadystatechange

		- 1.每当XHR对象的状态发生变化的时候，就会触发这个事件
		- 2.xhr对象分块接收数据

	- 3.progress( 过程，进度)

		- 1.onload -- 当readyState等于4的时候触发。只有请求成功了才触发。
		- 2.onprogress -- 当readyState等于3的时候触发（数据正在返回途中的时候触发）
		- 3.onloadstart() -- 当开始发送请求的时候触发，要放到send之前
		- 4.onloadend() -- 当请求响应过程结束的时候触发。无论成功还是失败都会触发。

	- XHR对象的兼容方案

		- 解释：XMLHttpRequest 在老版本浏览器（IE5/6）中有兼容问题
		- 书写：var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP')

	- responseType

		- 1.“”  -- 空，表示文本，
		- 2.text -- 文本
		- 3.json -- JSON格式数据
		- 4.document -- 文档对象

- jQuery封装

	- 格式：

		-     $.ajax({
     type: 'GET', // 请求方式
     url: '/query-get',
     data: {id: 333, age: 666, name: 'zs'}, // 发送给接口的数据，可以写成对象，jQuery内部会自动将对象转成字符串
    dataType: 'json', // 如同 responseType。
    success: function (res) {
        console.log(res);
    }
});

	- 常用参数：

		- cache: 设置ie浏览器的缓存问题， cache: false 不缓存
		- url：请求地址
		- type：请求方法，默认为 `get
		- dataType：预期服务端响应数据类型
		- contentType：请求体内容类型，如果是POST请求，默认 `application/x-www-form-urlencoded
		- data：（object|string）传递到服务端的数据
		- timeout：请求超时时间
		- beforeSend：请求发起之前触发
		- complete：请求完成触发（不管成功与否）
		- success：请求成功之后触发（响应状态码 200）
		- error：请求失败触发
		- processData：是否让jQuery帮我们将发送给服务器的数据进行处理（默认：true表示将对象处理成字符串）

	- 快捷方法

		- $.get(url, [data], [callback], [dataType])
		- $.post(url, [data], [callback], [dataType])

	- 全局事件处理

		- 语法：

			- $.ajaxSetup({事件: 处理函数, 事件:处理函数, ...});

		- 示例

			- // 设置全局事件处理
$.ajaxSetup({
    // 设置发送请求前的事件
    beforeSend: function () {
        // 这里可以提示，玩命加载中...
    },
    // 设置完全接收响应数据后的事件
    complete: function () {
        // 这里可以去掉“玩命加载中...”
    }
});

- FormData对象

	- 说明：主要用于表单发送数据
	- 使用方式：

		- 例如：var form = $('form').get(0);
          var fd = new FormData(form);

	- 注意事项：

		- 使用FormData的时候，form表单中的各项必须有name属性。没有name属性是收集不到数据的

- 补充知识点：

	- 1.?id=457 问怎么可以拿到457
 答：str.replace(/\D/g,""); 使用正则将非数字剔除掉
	- 2.location.search  返回/设置当前的url的查询部分
	- 3.confirm（“你确定么”） 返回boolean
	- 4.console.log（）会在浏览器控制台打印出信息
   console.dir（）可以显示一个对象所有的方法和属性

## 一些容易混淆的小概念

### undefined 与 not defined

- 例子

	- 在c语言里面，会去严格区分声明(declared)和定义(defined),而在JS里，is not defined却会让人误以为是声明了没有定义的变量，但是实际上，却是没有声明，这个地方用ReferenceError: b is not declared

- 理解

	- 某开发者想要声明两个变量，一个值类型为number的A,一个值类型为string的B，他在程序里写了

	- 这个时候实际上就是变量A去'继承'了type为'undefined'的值，B没有声明,现在就不知道继承哪种值，称为undeclared

	- 这个时候这位开发者写入

	- 那么就变成了

	- 所以此时typeof A会得到’number’，B目前存在于开发者的脑子里，所以为undeclared

### 为什么[] == ![]为true？

- （1）首先![] 转换为false，此时比较[] == false
- （2）[]是对象，false转换为number，就是0，此时比较[] == 0;
- （3）[] == 0将[]转换为字符串，就是"" == 0，然后""转换为字符串，就是0 == 0，即最终为true
- == 的转换机制，先调用valueof，不行再调用toString

### 手写原生Ajax请求

- Ajax请求

	- 在这里， 我们创建了一个能向服务器发出 HTTP 请求的类的实例。然后调用其 open 方法，其中第一个参数是 HTTP 请求方法，第二个参数是请求页面的 URL。第三个参数是true（异步）或 false（同步）；最后，我们调用参数为 null 的 send 方法。假如使用 POST 请求方法（这里我们使用了 GET），那么 send 方法 的参数应该包含任何你想发送的数据。

- 处理响应

### Object.create 的模拟实现

- 将传入的对象作为创建的对象的原型
- 详解Object.create(null)

	- Object.create()的定义

		- Object.create(proto,[propertiesObject])
		- proto:新创建对象的原型对象
		- propertiesObject:可选。要添加到新对象的可枚举（新添加的属性是其自身的属性，而不是其原型链上的属性）的属性。

	- Object.creat()的使用

	- Object.create()、{…}的区别

		- 先看看我们经常使用的{}创建的对象是什么样子的

			- 在chrome控制台打印如下

			- 新创建的对象继承了Object自身的方法，如hasOwnProperty、toString等，在新对象上可以直接使用。

		- 再看看使用Object.create()创建对象

			- Object.creat(null)

				- 在chrome控制台打印如下

				- 新创建的对象除了自身属性a之外，原型链上没有任何属性，也就是没有继承Object的任何东西，此时如果我们调用o.toString()会报Uncaught TypeError的错误。

			- Object.creat({})

				- 在chrome控制台打印如下

				- 这样创建的对象和使用{}创建对象已经很相近了，但是还是有一点区别：多了一层proto嵌套。

			-  Object.create(Object.prototype)

				- chrome控制台打印如下

	- Object.create(null)的使用场景

		- 进一步比较一下Object.create(null)和{}创建控对象的区别

		- 使用场景

			- 使用create创建的对象，没有任何属性，显示No properties，我们可以把它当作一个非常纯净的map来使用，我们可以自己定义hasOwnProperty、toString方法，不管是有意还是不小心，我们完全不必担心会将原型链上的同名方法覆盖掉。

		- 举个例子

		- 另一个使用create(null)的理由是，在我们使用for..in循环的时候会遍历对象原型链上的属性，使用create(null)就不必再对属性进行检查了，当然，我们也可以直接使用Object.keys[]。

	- 总结

		- 你需要一个非常干净且高度可定制的对象当作数据字典的时候；
		- 想节省hasOwnProperty带来的一丢丢性能损失并且可以偷懒少些一点代码的时候
		- 其他时候，请用{}

### New 关键字的内部实现

- 当我们使用 new 操作符时，生成的实例对象拥有了 _proto_属性。在 new 的过程中，新对象被添加了 _proto_ 并且链接到构造函数的原型上。

- New()的过程

	- （1）新生成了一个对象
	- （2）链接到原型
	- （3）绑定 this
	- （4）返回新对象

- New()的实现

	- 最初版

		- 代码

		- 理解

			- （1）用new Object() 的方式新建了一个对象 obj
			- （2）取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数
			- （3）将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性
			- （4）使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性
			- （5）返回 obj

	- 完整版

		- 起源

			- 如果构造函数有返回值

				- 返回值是对象

					- 构造函数返回了一个对象，在实例 person 中只能访问返回的对象中的属性。

				- 返回值是基本类型

					- 结果完全颠倒过来，这次尽管有返回值，但是相当于没有返回值进行处理。

		- 还需要判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么。

### js 中的 !! 与 ~~

- !!

	- 将操作数转化为布尔类型。

	- 实际上等效于 Boolean 被当做函数调用的效果

- ~~

	- 将操作数转化为 32 位有符号整数。

	- 如果你需要将一个参数转化为 32 位有符号整数，那么 ~~ 将是最简便的方式。不过要切记，它会损失精度，包括小数和整数部分。
	- 按位非操作符~

		- 作用是将数值比特位中的 1 变成 0，0 变成 1。
