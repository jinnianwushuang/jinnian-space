(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[14],{"0ad4":function(n,r,e){var t={"./0.概述笔记.md":"92fc","./1.node全栈项目依赖.md":"e52a","./2.node-schedule增加定时任务.md":"e68a"};function o(n){var r=a(n);return e(r)}function a(n){if(!e.o(t,n)){var r=new Error("Cannot find module '"+n+"'");throw r.code="MODULE_NOT_FOUND",r}return t[n]}o.keys=function(){return Object.keys(t)},o.resolve=a,n.exports=o,o.id="0ad4"},"92fc":function(n,r,e){"use strict";e.r(r),r["default"]="# 一些散乱笔记\r\n\r\nnode 项目 遇到的坑\r\n\r\n- linux 部署 node 项目 后台运行 需要两次回车 ，第一次 退出 node 项目界面 ，第二次 才是背后运行\r\n- nohup , 后缀 $ ， forever start xxxxx, node ./server.js  \r\n- \r\n\r\n"},bbaf:function(n,r,e){"use strict";e.r(r);var t=function(){var n=this,r=n.$createElement,e=n._self._c||r;return e("div",[e("q-markdown",{attrs:{"no-heading-anchor-links":"",extend:n.extendMarkdown,src:n.MainComponent}})],1)},o=[],a=e("3686"),s=e("1b62"),i="/books/node/",d=Object(a["a"])(e("0ad4"),"md",!0),l=d.all_components,c=d.all_modules,u={mixins:[s["c"],s["b"]],data:function(){return{relative_path:i,img_prefix:"."+i,tab:c[0].value,tab_level:1,MainComponent:l[c[0].value],tabs:c}},watch:{tab:function(n,r){this.MainComponent=l[this.tab],this.compute_img_prefix()}}},m=u,p=e("2877"),v=Object(p["a"])(m,t,o,!1,null,"86873e20",null);r["default"]=v.exports},e52a:function(n,r,e){"use strict";e.r(r),r["default"]='# node全栈项目的几套依赖参照\r\n\r\n```json\r\n{\r\n  "name": "node-web-fullstack",\r\n  "version": "0.0.1",\r\n  "description": "锦年node全栈学习项目",\r\n  "productName": "锦年fullstack",\r\n  "author": "jinnianwushuang ",\r\n  "private": true,\r\n  "main": "server.js",\r\n  "apidoc":{\r\n    "name": "锦年node全栈学习项目API",\r\n    "version": "0.1.0",\r\n    "description": "明日复明日，万事成蹉跎。",\r\n    "title": "锦年node全栈学习项目API",\r\n    "url": "http://192.168.0.36:19090"\r\n  },\r\n  "scripts": {\r\n    "test": "echo \\"No test specified\\" && exit 0",\r\n    "start-makedoc": "apidoc -i app/ -o apidoc/",\r\n    "start-docpage": " http-server ./apidoc -a 192.168.0.36 -p 19092 -s -o ",\r\n    "start-docpage-b": "http-server ./apidoc -a 192.168.0.36 -p 19092 -s -o ",\r\n    "start-server": "nodemon --harmony  server.js",\r\n    "start-webpage": "quasar dev",\r\n    "start-doc-s": "run-s start-makedoc start-docpage",\r\n    "start-fullstack-p": "run-p  start-server  start-webpage",\r\n    "init-env": "node init.js",\r\n    "start": "run-s  init-env   start2",\r\n    "start2": "run-p   start-fullstack-p start-doc-s"\r\n  },\r\n  "dependencies": {\r\n    "@quasar/extras": "^1.0.0",\r\n    "axios": "^0.18.1",\r\n    "body-parser": "^1.19.0",\r\n    "core-js": "^3.6.5",\r\n    "cors": "^2.8.5",\r\n    "express": "^4.17.1",\r\n    "lodash": "^4.17.20",\r\n    "log4js": "^6.3.0",\r\n    "md5": "^2.3.0",\r\n    "mongoose": "^5.8.10",\r\n    "mongoose-paginate-v2": "^1.3.9",\r\n    "quasar": "^1.0.0",\r\n    "vue-i18n": "^8.0.0"\r\n  },\r\n  "devDependencies": {\r\n    "@quasar/app": "^2.0.0",\r\n    "apidoc": "^0.25.0",\r\n    "http-server": "^0.12.3",\r\n    "nodemon": "^2.0.4",\r\n    "npm-run-all": "^4.1.5"\r\n  },\r\n  "browserslist": [\r\n    "ie >= 11",\r\n    "last 10 Chrome versions",\r\n    "last 10 Firefox versions",\r\n    "last 4 Edge versions",\r\n    "last 7 Safari versions",\r\n    "last 8 Android versions",\r\n    "last 8 ChromeAndroid versions",\r\n    "last 8 FirefoxAndroid versions",\r\n    "last 10 iOS versions",\r\n    "last 5 Opera versions"\r\n  ],\r\n  "engines": {\r\n    "node": ">= 10.18.1",\r\n    "npm": ">= 6.13.4",\r\n    "yarn": ">= 1.21.1"\r\n  }\r\n}\r\n```\r\n\r\n'},e68a:function(n,r,e){"use strict";e.r(r),r["default"]="# 从零开始在NodeJs中使用node-schedule增加定时任务\r\n\r\n## 简介\r\n\r\njava中直接使用定时器类就行了，但是在node中就没有这么简单了，只能使用setInterval或者setTimeout两个方法来实现，但是太繁琐了，搜索了之后发现`node-schedule`这个包，特意试用一下\r\n\r\n## 版本\r\n\r\nnode版本12.16.2\r\n\r\nkoa2版> 2.7.0\r\n\r\n## 1. 安装\r\n\r\n```javascript\r\nnpm insatll node-schedule -S\r\n\r\n```\r\n\r\n## 2. 使用方法\r\n\r\n### 2-1. 调用格式\r\n\r\n```javascript\r\n// 任务名称可以用中文，也可以用英文，但必须唯一\r\nschedule.scheduleJob(`任务名称`, `时间`, () => {\r\n});\r\n\r\n```\r\n\r\n### 2-2. 时间格式\r\n\r\n- 每分钟的第30秒触发： '30 * * * * *'\r\n- 每小时的1分30秒触发 ：'30 1 * * * *'\r\n- 每天的凌晨1点1分30秒触发 ：'30 1 1 * * *'\r\n- 每月的1日1点1分30秒触发 ：'30 1 1 1 * *'\r\n- 2016年的1月1日1点1分30秒触发 ：'30 1 1 1 2016 *'\r\n- 每周1的1点1分30秒触发 ：'30 1 1 * * 1'\r\n\r\n## 3. 在项目中使用\r\n\r\n### 3-1. 建立schedule.js\r\n\r\n```javascript\r\nconst schedule = require('node-schedule');\r\n\r\n// 生成新的定时任务\r\nlet interval = async (options) => {\r\n  return new Promise((resolve) => {\r\n    \r\n    // 这里设定14天为一个循环周期\r\n    // 假如设定的日期是2020-06-08, 返回就是{year: 2020, month: 6, day: 22, hour: 8, min: 0}\r\n    let time14 = GetDateStr(options.maintain_time, 14)\r\n    console.log(`${options.unit_name}_${time14.year}-${time14.month}-${time14.day}`, `1-2 1 1 ${time14.day} ${time14.month} *`)\r\n    \r\n    // 终止之前的定时任务\r\n    editMaintainTime(options)\r\n    \r\n    // 按照固定格式，设定定时任务，这里使用每条数据的唯一字段+定时任务时间，作为任务名称\r\n    // 任务名称就是'名字_2020-6-22'\r\n    // 任务时间就是'1-2 1 1 22 6 *' ，意思是每年的6月22日的1点1分的1秒~10秒触发，触发10次\r\n    schedule.scheduleJob(`${options.unit_name}_${time14.year}-${time14.month < 10 ? \"0\" + time14.month: time14.month}-${time14.day < 10 ? \"0\" + time14.day: time14.day}`, `1-10 * * ${time14.day} ${time14.month} *`, () => {\r\n        console.log(options,'The world is going to end today.' +  new Date())\r\n\r\n      // 写入你自己想在定时任务触发的时候，想要执行的函数\r\n    });\r\n}\r\n\r\n// 删除定时任务\r\nlet editMaintainTime = async (options) => {\r\n    console.log('options', options)\r\n  \r\n    // 查看所有的定时任务\r\n    for (let i in schedule.scheduledJobs) {\r\n      console.error(\"任务删除前：\"+i);\r\n    }\r\n    // 终止之前的定时任务\r\n    console.log('终止的任务', `${options.alarm14}`)\r\n    if (schedule.scheduledJobs[`${options.alarm14}`]) {\r\n      schedule.scheduledJobs[`${options.alarm14}`].cancel();\r\n    }\r\n    \r\n    // 查看剩下的定时任务\r\n    for (let i in schedule.scheduledJobs) {\r\n      console.error(\"任务删除后：\"+i);\r\n    }\r\n    // time.cancel()\r\n    \r\n     console.log('删除成功')\r\n}\r\n\r\n\r\n// 时间选择\r\nlet GetDateStr = (maintain_time, AddDayCount) => {\r\n  var dd = new Date(`${maintain_time}`);\r\n  dd.setDate(dd.getDate() + AddDayCount); // 获取AddDayCount天后的日期\r\n  var y = dd.getFullYear(); \r\n  var m = dd.getMonth() + 1\r\n  var d = dd.getDate()\r\n  var h = dd.getHours()\r\n  var min = dd.getMinutes()\r\n  return {\r\n    year: y,\r\n    month: m,\r\n    day: d,\r\n    hour: h,\r\n    min: min,\r\n  }\r\n}\r\n\r\nconst intervalControl = {\r\n  interval: interval\r\n}\r\n\r\nmodule.exports = intervalControl\r\n\r\n```\r\n\r\n### 3-2. 调用该方法\r\n\r\n```javascript\r\nconst intervalControl = require('../util/schedule')\r\n\r\n// options传入{unit_name: '名字', maintain_time: '自己选择的开始时间', alarm14: '上一次定时任务的任务名称'}\r\n// unit_name，无格式\r\n// maintain_time：2020-06-08\r\n// alarm14: 2020-06-22\r\nintervalControl.interval(options)\r\n```"}}]);