(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[7],{"132d":function(n,r,e){var t={"./Excel 函数.md":"e220","./Mac电脑Tomcat下载及安装.md":"17c5","./Shell.md":"fdf5","./basis.md":"5a01","./linux.md":"524a","./mac.md":"a85d","./win-cmd.md":"ddf5"};function i(n){var r=o(n);return e(r)}function o(n){if(!e.o(t,n)){var r=new Error("Cannot find module '"+n+"'");throw r.code="MODULE_NOT_FOUND",r}return t[n]}i.keys=function(){return Object.keys(t)},i.resolve=o,n.exports=i,i.id="132d"},"17c5":function(n,r,e){"use strict";e.r(r),r["default"]="#### Mac电脑Tomcat下载及安装(详细)\r\n\r\n```\r\n           1.打开Apache Tomcat官网,选择你需要的版本进行下载:\r\n地址http://tomcat.apache.org/download-70.cgi\r\n\r\n2.解压apache-tomcat-7.0.82文件,最好把他放入/Library(资源库中)\r\nmac寻找library资源库\r\n\r\n(1).点击finder--\x3e用户--\x3e你电脑的名字--\x3e资源库(有的也叫/Library)\r\n\r\n\r\n\r\n(2).有些苹果将library目录隐藏起来了，要进入那个目录，需要用到一定的技巧。 \r\n\r\n打开Finder，按下shift+command+g，输入“~/Library”（输入引号里面的），再按回车就到了。\r\n\r\n3.配置Tomcat\r\n\r\n(1).对目录进行权限设置：\r\n\r\n打开终端输入  sudo chmod 755 Library/tomcat/bin/*.sh  回车，设置文件的读写执行权限；(这里需要输入管理员密码)\r\n\r\n为了方便使用把这里把解压后的apache-tomcat-7.0.82重新命名为tomcat.\r\n\r\nsudo chmod 755 (你Tomcat解压的位置,可以直接拖拽放入)/bin/*.sh\r\n\r\n注释:sudo通常为系统超级管理员755 代表用户对该文件拥有读，写，执行的权限，\r\n同组其他人员拥有执行和读的权限，没有写的权限，其他用户的权限和同组人员权限一样。777代表，user,group ,others ,都有读写和可执行权限。\r\n\r\n(2).启动Tomcat      \r\n\r\n启动方法一:在终端中输入 sudo sh startup.sh\r\n\r\n若出现如下提示则表示安装并运行成功： \r\n\r\n\r\n启动方法二:在Library/tomcat/bin中找到startup.sh文件,把文件拖入到终端中回车启动\r\n\r\n\r\n4.验证Tomcat是否启动\r\n\r\n打开你的safari,然后在网址输入框输入http://localhost:8080/回车\r\n\r\n如果能正常打开tomcat首页，说明tomcat 配置启动成功:\r\n--------------------- \r\n\r\n       \r\n```"},"1b62":function(n,r,e){"use strict";e.d(r,"d",(function(){return l})),e.d(r,"c",(function(){return d})),e.d(r,"a",(function(){return T})),e.d(r,"b",(function(){return I}));e("4de4"),e("c975");var t=e("448a"),i=e.n(t),o=["/第1阶段-运维基本功（升级7.6版本）/01运维概述与Linux系统安装.pdf","/第1阶段-运维基本功（升级7.6版本）/02Linux基础命令.pdf"],s="linux/heima-Linux云计算",l={name:"Container",data:function(){return{prefix:s,book_options:o,book_options_all:[],show:!0,book:o[0],src:""}},created:function(){this.book_options_all=i()(this.book_options),this.src=this.$utils.compute_book_src(this.prefix+this.book)},watch:{book:function(n,r){n&&this.change_book()}},methods:{change_book:function(){console.log("this.book",this.book),this.src=this.$utils.compute_book_src(this.prefix+this.book)},filterFn:function(n,r){var e=this;r(""!==n?function(){var r=n.toLowerCase();e.book_options=e.book_options_all.filter((function(n){return n.toLowerCase().indexOf(r)>-1}))}:function(){e.book_options=e.book_options_all})}}},a=e("ded3"),c=e.n(a),h=e("2f62"),d={data:function(){return{tab:"",tab_level:1,is_active:!1}},computed:c()({},Object(h["c"])(["get_current_selected_right_menu"])),created:function(){this.is_active=!0,this.fix_right_menu_config()},watch:{tab:function(){this.tab||this.fix_right_menu_config()},get_current_selected_right_menu:function(n,r){this.tab=this.get_current_selected_right_menu["t"+this.tab_level]}},methods:c()(c()({},Object(h["b"])(["set_right_menu_fix_config"])),{},{fix_right_menu_config:function(){this.set_right_menu_fix_config({tl:this.tab_level,tabs:this.tabs||[],tv:this.tab||this.tabs[0]["value"]})}}),beforeDestroy:function(){this.is_active=!1}},u=(e("99af"),e("d81d"),e("fb6a"),e("a434"),e("07ac"),function(){var n=this,r=n.$createElement,e=n._self._c||r;return e("div",{staticClass:"q-my-md q-mx-sm"},[e("div",{staticClass:"q-mb-md row q-gutter-x-md q-gutter-y-sm"},[e("q-select",{staticStyle:{width:"300px"},attrs:{dense:"",filled:"","use-input":"","hide-selected":"","fill-input":"","input-debounce":"0",options:n.topic_options_filtered},on:{filter:n.filterFn,"filter-abort":n.abortFilterFn,input:n.handle_topic_change},scopedSlots:n._u([{key:"before",fn:function(){return[n._v("\n        主题\n      ")]},proxy:!0}]),model:{value:n.topic,callback:function(r){n.topic=r},expression:"topic"}}),e("q-select",{staticStyle:{width:"300px"},attrs:{dense:"",filled:"",options:n.column_options},on:{input:n.handle_column_change},scopedSlots:n._u([{key:"before",fn:function(){return[n._v("\n        列数\n      ")]},proxy:!0}]),model:{value:n.column,callback:function(r){n.column=r},expression:"column"}})],1),e("q-markup-table",{attrs:{dense:""}},[e("thead",[e("tr",[e("th",{staticClass:"text-left text-weight-bolder  ",attrs:{colspan:n.column}},[n._v("\n          "+n._s(n.table_title?n.table_title+"------":"")+"当前词条数量："+n._s(n.word_total)+"\n        ")])])]),e("tbody",[n._l(n.table_data,(function(r,t){return[n.compute_if_show(r)?e("tr",{key:t,class:n.compute_topic_options_style(r)},n._l(n.column,(function(t){return e("td",{key:t,staticClass:"text-left"},[n._v("\n            "+n._s(r[t-1])+"\n          ")])})),0):n._e()]}))],2)])],1)}),p=[],m=(e("caad"),e("a9e3"),e("2532"),{data:function(){return{topic:"全部",column:2,topic_options_filtered:[],topic_options_all:[]}},props:{table_title:{type:String,default:""},word_total:{type:Number,default:0},topic_options:{type:Array,default:function(){return[]}},column_options:{type:Array,default:function(){return[]}},table_data:{type:Array,default:function(){return[]}},show_empty_line:!1},watch:{topic_options:function(n,r){this.init_topic_options_related()},column_options:function(n,r){this.init_column()}},created:function(){this.init_topic_options_related(),this.init_column(),this.handle_column_change(),this.handle_topic_change()},methods:{init_topic_options_related:function(){this.topic_options_all=i()(this.topic_options),this.topic_options_filtered=i()(this.topic_options)},filterFn:function(n,r,e){var t=this;console.log("this.topic_options_all",this.topic_options_all),setTimeout((function(){r((function(){if(""===n)t.topic_options_filtered=i()(t.topic_options_all);else{var r=n.toLowerCase();t.topic_options_filtered=t.topic_options_all.filter((function(n){return n.toLowerCase().indexOf(r)>-1}))}t.$forceUpdate()}),(function(r){""!==n&&r.options.length>0&&(r.setOptionIndex(-1),r.moveOptionSelection(1,!0))}))}),300)},abortFilterFn:function(){},handle_column_change:function(){this.$emit("handle_column_change",this.column)},handle_topic_change:function(){this.$emit("handle_topic_change",this.topic)},init_column:function(){var n=this.$q.platform.is.desktop,r=window.innerWidth;r=n?r-200:r-100,r=r<370?370:r,console.log("ww",r);var e=Math.ceil(r/350);e=e<1?1:e,r<400&&(e=1),e=e>8?8:e,this.column=e},compute_topic_options_style:function(n){var r="",e=1==n.length&&this.topic_options.includes(n[0]);return r=e?"bg-teal-4":"",r},compute_if_show:function(n){if(this.show_empty_line)return!0;var r=n.filter((function(n){return n}));return r.length>0}}}),E=m,S=e("2877"),x=Object(S["a"])(E,u,p,!1,null,"4e74a874",null),f=x.exports,T={components:{excelTable:f},data:function(){return{workSheetsFromFile:[[{data:[]}]],table_title:"",column:8,word_total:0,table_data:[],table_data_all:[],column_options:[1,2,3,4,5,6,7,8],exclude_topic_options:!0,show_empty_line:!1,topic:"",topic_options:[]}},created:function(){this.init_workSheetsFromFile()},methods:{init_workSheetsFromFile:function(){},handle_column_change:function(n){this.column=n,this.init_data()},handle_topic_change:function(n){this.topic=n,console.log("this.topic----",this.topic),this.compute_table_data_show_and_word_total()},rebuild_arr_reduce_empty_line:function(n){var r=[[""]];return n.map((function(n){var e=n.filter((function(n){return n})),t=e.length;if(t)r.push(n);else{var i=r[r.length-1].filter((function(n){return n})).length,o=r[r.length-1].length;o>0&&i>0&&r.push([""])}})),r},init_data:function(){var n=this;console.log("workSheetsFromFile --------",this.workSheetsFromFile);var r=[],e={},t=[];this.workSheetsFromFile.map((function(n){r=r.concat(n["data"])}));var o=this.$lodash.cloneDeep(r[0].filter((function(n){return n})));o.map((function(n,r){e["key_"+r]={title:n,words_raw:[]}})),this.exclude_topic_options&&r.splice(0,1),r.map((function(n,r){n.map((function(n,r){e["key_"+r]["words_raw"].push(n)}))})),console.log("final_obj------------",e);var s=Object.values(e);s.map((function(r,e){t.push([r["title"]]),t=t.concat(n.$lodash.chunk(r["words_raw"],n.column)),t=t.concat([[""]])})),this.topic_options=["全部"].concat(i()(o)),this.table_data_all=this.rebuild_arr_reduce_empty_line(t),this.compute_table_data_show_and_word_total(),console.log("  this.table_data_all   ",this.table_data_all)},compute_table_data_show_and_word_total:function(){var n=[],r=[],e=0;if(r=this.$lodash.cloneDeep(this.table_data_all),console.log(" table_data--------",r),"全部"==this.topic)n=r;else{var t=this.topic_options.indexOf(this.topic),i=t==this.topic_options.length-1,o=i?"":this.topic_options[t+1],s=this.find_topic_index(this.topic),l=o?this.find_topic_index(o):r.length;n=r.slice(s,l)}n.map((function(n){var r=n.filter((function(n){return n})).length;e+=r})),this.word_total=e,this.table_data=n},find_topic_index:function(n){for(var r=0,e=0;e<this.table_data_all.length;e++){var t=this.table_data_all[e];if(1==t.length&&t[0]&&t[0]==n){r=e;break}}return r}}},I=(e("ac1f"),e("1276"),{data:function(){return{tab:"",MainComponent:"",img_prefix:"./img/linux/heima-Linux云计算/讲义/"}},methods:{extendMarkdown:function(n){var r=this;console.log(n.renderer.rules);var e=n.renderer.rules.html_block;n.renderer.rules.html_block=function(n,t,i,o,s){var l=n[t];if(console.log("1"),l.content.includes("<img")){console.log("token-- ",l);var a="";a=l.content;var c=a.split('src="'),h=c[0]+' src="'+r.img_prefix+c[1];l.content=h}return l.attrSet("class","q-markdown--token  "),e(n,t,i,o,s)},n.renderer.rules.image=function(n,e,t,i,o){var s=n[e];console.log("3"),s.attrSet("class","q-markdown--image"),console.log("token--- "+e+"-----",s);var l=s.attrGet("src");return console.log(l),s.attrSet("src",r.img_prefix+l),o.renderToken(n,e,t)}}}})},"1c0f":function(n,r,e){"use strict";e.r(r);var t=function(){var n=this,r=n.$createElement,e=n._self._c||r;return e("div",[e("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}})],1)},i=[],o=e("3686"),s=e("1b62"),l=Object(o["a"])(e("132d"),"md",!0),a=l.all_components,c=l.all_modules,h={mixins:[s["c"],s["b"]],data:function(){return{img_prefix:"./books/os/",tab:c[0].value,tab_level:1,MainComponent:a[c[0].value],tabs:c}},watch:{tab:function(n,r){this.MainComponent=a[this.tab]}}},d=h,u=e("2877"),p=Object(u["a"])(d,t,i,!1,null,"061ab790",null);r["default"]=p.exports},3686:function(n,r,e){"use strict";e.d(r,"a",(function(){return o}));e("e260"),e("d81d"),e("fb6a"),e("4e82"),e("d3b7"),e("ac1f"),e("5319"),e("ddb0");var t=e("d958"),i=function(n){var r=t(n,{style:t.STYLE_NORMAL}),e="";return r.map((function(n){e+=n[0]})),e},o=function(n){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"md",e=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];console.log("当前 require.context---",n),console.log("当前 field_components.keys()---",n.keys());var t=n.keys(),o={},s=[],l={},a=[];t.map((function(t){var s=/[^\u4E00-\u9FA5A-Za-z]+/g,c=t.slice(2,t.length-r.length-1),h="";e?(h=i(t).replace(s,""),h=h.slice(0,h.length-r.length)):h=c,a.push(c),l[c]=h,console.log("x---",t),o[h]=n(t).default})),a.sort((function(n,r){return parseFloat(n)-parseFloat(r)}));return a.map((function(n){s.push({label:n,value:l[n]})})),console.log("all_components------------",o),console.log("all_modules---------------",s),{all_components:o,all_modules:s}}},"524a":function(n,r,e){"use strict";e.r(r),r["default"]='点击关注[公众号](#公众号)及时获取笔主最新更新文章，并可免费领取本文档配套的《Java 面试突击》以及 Java 工程师必备学习资源。\n\n\n\x3c!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} --\x3e\n\n\x3c!-- code_chunk_output --\x3e\n\n- [1. 从认识操作系统开始](#1-从认识操作系统开始)\n  - [1.1. 操作系统简介](#11-操作系统简介)\n  - [1.2. 操作系统简单分类](#12-操作系统简单分类)\n    - [1.2.1. Windows](#121-windows)\n    - [1.2.2. Unix](#122-unix)\n    - [1.2.3. Linux](#123-linux)\n    - [1.2.4. Mac OS](#124-mac-os)\n  - [1.3. 操作系统的内核（Kernel）](#13-操作系统的内核kernel)\n  - [1.4. 中央处理器（CPU，Central Processing Unit）](#14-中央处理器cpucentral-processing-unit)\n  - [1.5. CPU vs Kernel(内核)](#15-cpu-vs-kernel内核)\n  - [1.6. 系统调用](#16-系统调用)\n- [2. 初探 Linux](#2-初探-linux)\n  - [2.1. Linux 简介](#21-linux-简介)\n  - [2.2. Linux 诞生](#22-linux-诞生)\n  - [2.3. 常见 Linux 发行版本有哪些？](#23-常见-linux-发行版本有哪些)\n- [3. Linux 文件系统概览](#3-linux-文件系统概览)\n  - [3.1. Linux 文件系统简介](#31-linux-文件系统简介)\n  - [3.2. inode 介绍](#32-inode-介绍)\n  - [3.3. Linux 文件类型](#33-linux-文件类型)\n  - [3.4. Linux 目录树](#34-linux-目录树)\n- [4. Linux 基本命令](#4-linux-基本命令)\n  - [4.1. 目录切换命令](#41-目录切换命令)\n  - [4.2. 目录的操作命令(增删改查)](#42-目录的操作命令增删改查)\n  - [4.3. 文件的操作命令(增删改查)](#43-文件的操作命令增删改查)\n  - [4.4. 压缩文件的操作命令](#44-压缩文件的操作命令)\n  - [4.5. Linux 的权限命令](#45-linux-的权限命令)\n  - [4.6. Linux 用户管理](#46-linux-用户管理)\n  - [4.7. Linux 系统用户组的管理](#47-linux-系统用户组的管理)\n  - [4.8. 其他常用命令](#48-其他常用命令)\n- [5. 公众号](#5-公众号)\n\n\x3c!-- /code_chunk_output --\x3e\n\n\n今天这篇文章中简单介绍一下一个 Java 程序员必知的 Linux 的一些概念以及常见命令。\n\n_如果文章有任何需要改善和完善的地方，欢迎在评论区指出，共同进步！笔芯！_\n\n## 1. 从认识操作系统开始\n\n![](linux.assets/image-20200807161118901.png)\n\n正式开始 Linux 之前，简单花一点点篇幅科普一下操作系统相关的内容。\n\n### 1.1. 操作系统简介\n\n我通过以下四点介绍什么是操作系统：\n\n1. **操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。**\n2. **操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。** 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。\n3. **操作系统存在屏蔽了硬件层的复杂性。** 操作系统就像是硬件使用的负责人，统筹着各种相关事项。\n4. **操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理**。\n\n> 内核（Kernel）在后文中会提到。\n\n![Kernel_Layout](linux.assets/Kernel_Layout.png)\n\n### 1.2. 操作系统简单分类\n\n#### 1.2.1. Windows\n\n目前最流行的个人桌面操作系统 ，不做多的介绍，大家都清楚。界面简单易操作，软件生态非常好。\n\n_玩玩电脑游戏还是必须要有 Windows 的，所以我现在是一台 Windows 用于玩游戏，一台 Mac 用于平时日常开发和学习使用。_\n\n\n\n#### 1.2.2. Unix\n\n最早的多用户、多任务操作系统 。后面崛起的 Linux 在很多方面都参考了 Unix。\n\n目前这款操作系统已经逐渐逐渐退出操作系统的舞台。\n\n![unix](linux.assets/unix.png)\n\n#### 1.2.3. Linux\n\n**Linux 是一套免费使用、开源的类 Unix 操作系统。** Linux 存在着许多不同的发行版本，但它们都使用了 **Linux 内核** 。\n\n> 严格来讲，Linux 这个词本身只表示 Linux 内核，在 GNU/Linux 系统中，Linux 实际就是 Linux 内核，而该系统的其余部分主要是由 GNU 工程编写和提供的程序组成。单独的 Linux 内核并不能成为一个可以正常工作的操作系统。\n>\n> **很多人更倾向使用 “GNU/Linux” 一词来表达人们通常所说的 “Linux”。**\n\n![linux](linux.assets/linux.png)\n\n#### 1.2.4. Mac OS\n\n苹果自家的操作系统，编程体验和 Linux 相当，但是界面、软件生态以及用户体验各方面都要比 Linux 操作系统更好。\n\n\n\n### 1.3. 操作系统的内核（Kernel）\n\n我们先来看看维基百科对于内核的解释，我觉得总结的非常好！\n\n> **内核**（英语：Kernel，又称核心）在计算机科学中是一个用来管理软件发出的数据 I/O（输入与输出）要求的电脑程序，将这些要求转译为数据处理的指令并交由中央处理器（CPU）及电脑中其他电子组件进行处理，是现代操作系统中最基本的部分。它是为众多应用程序提供对计算机硬件的安全访问的一部分软件，这种访问是有限的，并由内核决定一个程序在什么时候对某部分硬件操作多长时间。 **直接对硬件操作是非常复杂的。所以内核通常提供一种硬件抽象的方法，来完成这些操作。有了这个，通过进程间通信机制及系统调用，应用进程可间接控制所需的硬件资源（特别是处理器及 IO 设备）。**\n>\n> 早期计算机系统的设计中，还没有操作系统的内核这个概念。随着计算机系统的发展，操作系统内核的概念才渐渐明晰起来了!\n\n简单概括两点：\n\n1. **操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。**\n2. **操作系统的内核是连接应用程序和硬件的桥梁，决定着操作系统的性能和稳定性。**\n\n### 1.4. 中央处理器（CPU，Central Processing Unit）\n\n关于 CPU 简单概括三点：\n\n1. **CPU 是一台计算机的运算核心（Core）+控制核心（ Control Unit），可以称得上是计算机的大脑。**\n2. **CPU 主要包括两个部分：控制器+运算器。**\n3. **CPU 的根本任务就是执行指令，对计算机来说最终都是一串由“0”和“1”组成的序列。**\n\n### 1.5. CPU vs Kernel(内核)\n\n很多人容易无法区分操作系统的内核（Kernel）和中央处理器（CPU），你可以简单从下面两点来区别：\n\n1. 操作系统的内核（Kernel）属于操作系统层面，而 CPU 属于硬件。\n2. CPU 主要提供运算，处理各种指令的能力。内核（Kernel）主要负责系统管理比如内存管理，它屏蔽了对硬件的操作。\n\n下图清晰说明了应用程序、内核、CPU 这三者的关系。\n\n![Kernel_Layout](linux.assets/Kernel_Layout.png)\n\n### 1.6. 系统调用\n\n介绍系统调用之前，我们先来了解一下用户态和系统态。\n\n根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：\n\n1. **用户态(user mode)** : 用户态运行的进程或可以直接读取用户程序的数据。\n2. **系统态(kernel mode)**: 可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。\n\n**说了用户态和系统态之后，那么什么是系统调用呢？**\n\n我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！\n\n也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。\n\n这些系统调用按功能大致可分为如下几类：\n\n- **设备管理** ：完成设备的请求或释放，以及设备启动等功能。\n- **文件管理** ：完成文件的读、写、创建及删除等功能。\n- **进程控制** ：完成进程的创建、撤销、阻塞及唤醒等功能。\n- **进程通信** ：完成进程之间的消息传递或信号传递等功能。\n- **内存管理** ：完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。\n\n我在网上找了一个图，通过这个图可以很清晰的说明用户程序、系统调用、内核和硬件之间的关系。（_太难了~木有自己画_）\n\n![](linux.assets/L181kk2Eou-compress.jpg)\n\n## 2. 初探 Linux\n\n### 2.1. Linux 简介\n\n我们上面已经简单了 Linux，这里只强调三点。\n\n- **类 Unix 系统** ： Linux 是一种自由、开放源码的类似 Unix 的操作系统\n- **Linux 本质是指 Linux 内核** ： 严格来讲，Linux 这个词本身只表示 Linux 内核，单独的 Linux 内核并不能成为一个可以正常工作的操作系统。所以，就有了各种 Linux 发行版。\n- **Linux 之父(林纳斯·本纳第克特·托瓦兹 Linus Benedict Torvalds)** ： 一个编程领域的传奇式人物，真大佬！我辈崇拜敬仰之楷模。他是 **Linux 内核** 的最早作者，随后发起了这个开源项目，担任 Linux 内核的首要架构师。他还发起了 Git 这个开源项目，并为主要的开发者。\n\n\n\n### 2.2. Linux 诞生\n\n1989 年，Linus Torvalds 进入芬兰陆军新地区旅，服 11 个月的国家义务兵役，军衔为少尉，主要服务于计算机部门，任务是弹道计算。服役期间，购买了安德鲁·斯图尔特·塔能鲍姆所著的教科书及 minix 源代码，开始研究操作系统。1990 年，他退伍后回到大学，开始接触 Unix。\n\n> **Minix** 是一个迷你版本的类 Unix 操作系统，由塔能鲍姆教授为了教学之用而创作，采用微核心设计。它启发了 Linux 内核的创作。\n\n1991 年，Linus Torvalds 开源了 Linux 内核。Linux 以一只可爱的企鹅作为标志，象征着敢作敢为、热爱生活。\n\n\n\n### 2.3. 常见 Linux 发行版本有哪些？\n\nLinus Torvalds 开源的只是 Linux 内核，我们上面也提到了操作系统内核的作用。一些组织或厂商将 Linux 内核与各种软件和文档包装起来，并提供系统安装界面和系统配置、设定与管理工具，就构成了 Linux 的发行版本。\n\n> 内核主要负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。\n\nLinux 的发行版本可以大体分为两类：\n\n- 商业公司维护的发行版本，以著名的 Red Hat 为代表，比较典型的有 CentOS 。\n- 社区组织维护的发行版本，以 Debian 为代表，比较典型的有 Ubuntu、Debian。\n\n对于初学者学习 Linux ,推荐选择 CentOS 。\n\n## 3. Linux 文件系统概览\n\n### 3.1. Linux 文件系统简介\n\n**在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。** 也就是说在 Linux 系统中有一个重要的概念：**一切都是文件**。\n\n其实这是 UNIX 哲学的一个体现，在 UNIX 系统中，把一切资源都看作是文件，Linux 的文件系统也是借鉴 UNIX 文件系统而来。\n\n### 3.2. inode 介绍\n\n**inode 是 linux/unix 文件系统的基础。那么，inode 是什么?有什么作用呢?**\n\n硬盘的最小存储单位是扇区(Sector)，块(block)由多个扇区组成。文件数据存储在块中。块的最常见的大小是 4kb，约为 8 个连续的扇区组成（每个扇区存储 512 字节）。一个文件可能会占用多个 block，但是一个块只能存放一个文件。\n\n虽然，我们将文件存储在了块(block)中，但是我们还需要一个空间来存储文件的 **元信息 metadata** ：如某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等。这种 **存储文件元信息的区域就叫 inode**，译为索引节点：**i（index）+node**。 每个文件都有一个 inode，存储文件的元信息。\n\n可以使用 `stat` 命令可以查看文件的 inode 信息。每个 inode 都有一个号码，Linux/Unix 操作系统不使用文件名来区分文件，而是使用 inode 号码区分不同的文件。\n\n简单来说：inode 就是用来维护某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等信息。\n\n简单总结一下：\n\n- **inode** ：记录文件的属性信息，可以使用 stat 命令查看 inode 信息。\n- **block** ：实际文件的内容，如果一个文件大于一个块时候，那么将占用多个 block，但是一个块只能存放一个文件。（因为数据是由 inode 指向的，如果有两个文件的数据存放在同一个块中，就会乱套了）\n\n![文件inode信息](linux.assets/文件inode信息.png)\n\n### 3.3. Linux 文件类型\n\nLinux 支持很多文件类型，其中非常重要的文件类型有: **普通文件**，**目录文件**，**链接文件**，**设备文件**，**管道文件**，**Socket 套接字文件**等。\n\n- **普通文件（-）** ： 用于存储信息和数据， Linux 用户可以根据访问权限对普通文件进行查看、更改和删除。比如：图片、声音、PDF、text、视频、源代码等等。\n- **目录文件（d，directory file）** ：目录也是文件的一种，用于表示和管理系统中的文件，目录文件中包含一些文件名和子目录名。打开目录事实上就是打开目录文件。\n- **符号链接文件（l，symbolic link）** ：保留了指向文件的地址而不是文件本身。\n- **字符设备（c，char）** ：用来访问字符设备比如键盘。\n- **设备文件（b，block）** ： 用来访问块设备比如硬盘、软盘。\n- **管道文件(p,pipe)** : 一种特殊类型的文件，用于进程之间的通信。\n- **套接字(s,socket)** ：用于进程间的网络通信，也可以用于本机之间的非网络通信。\n\n### 3.4. Linux 目录树\n\n所有可操作的计算机资源都存在于目录树这个结构中，对计算资源的访问，可以看做是对这棵目录树的访问。\n\n**Linux 的目录结构如下：**\n\nLinux 文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录：\n![Linux的目录结构](linux.assets/Linux目录树.png)\n\n**常见目录说明：**\n\n- **/bin：** 存放二进制可执行文件(ls、cat、mkdir 等)，常用命令一般都在这里；\n- **/etc：** 存放系统管理和配置文件；\n- **/home：** 存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是/home/user，可以用~user 表示；\n- **/usr ：** 用于存放系统应用程序；\n- **/opt：** 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把 tomcat 等都安装到这里；\n- **/proc：** 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；\n- **/root：** 超级用户（系统管理员）的主目录（特权阶级^o^）；\n- **/sbin:** 存放二进制可执行文件，只有 root 才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如 ifconfig 等；\n- **/dev：** 用于存放设备文件；\n- **/mnt：** 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；\n- **/boot：** 存放用于系统引导时使用的各种文件；\n- **/lib ：** 存放着和系统运行相关的库文件 ；\n- **/tmp：** 用于存放各种临时文件，是公用的临时文件存储点；\n- **/var：** 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；\n- **/lost+found：** 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows 下叫什么.chk）就在这里。\n\n## 4. Linux 基本命令\n\n下面只是给出了一些比较常用的命令。推荐一个 Linux 命令快查网站，非常不错，大家如果遗忘某些命令或者对某些命令不理解都可以在这里得到解决。\n\nLinux 命令大全：[http://man.linuxde.net/](http://man.linuxde.net/)\n\n### 4.1. 目录切换命令\n\n- **`cd usr`：** 切换到该目录下 usr 目录\n- **`cd ..（或cd../）`：** 切换到上一层目录\n- **`cd /`：** 切换到系统根目录\n- **`cd ~`：** 切换到用户主目录\n- **`cd -`：** 切换到上一个操作所在目录\n\n### 4.2. 目录的操作命令(增删改查)\n\n- **`mkdir 目录名称`：** 增加目录。\n- **`ls/ll`**（ll 是 ls -l 的别名，ll 命令可以看到该目录下的所有目录和文件的详细信息）：查看目录信息。\n- **`find 目录 参数`：** 寻找目录（查）。示例：① 列出当前目录及子目录下所有文件和文件夹: `find .`；② 在`/home`目录下查找以.txt 结尾的文件名:`find /home -name "*.txt"` ,忽略大小写: `find /home -iname "*.txt"` ；③ 当前目录及子目录下查找所有以.txt 和.pdf 结尾的文件:`find . \\( -name "*.txt" -o -name "*.pdf" \\)`或`find . -name "*.txt" -o -name "*.pdf"`。\n- **`mv 目录名称 新目录名称`：** 修改目录的名称（改）。注意：mv 的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作。mv 命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到 mv 命令的另一个用法。\n- **`mv 目录名称 目录的新位置`：** 移动目录的位置---剪切（改）。注意：mv 语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外 mv 与 cp 的结果不同，mv 好像文件“搬家”，文件个数并未增加。而 cp 对文件进行复制，文件个数增加了。\n- **`cp -r 目录名称 目录拷贝的目标位置`：** 拷贝目录（改），-r 代表递归拷贝 。注意：cp 命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写-r 递归。\n- **`rm [-rf] 目录` :** 删除目录（删）。注意：rm 不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文件，都直接使用`rm -rf` 目录/文件/压缩包。\n\n### 4.3. 文件的操作命令(增删改查)\n\n- **`touch 文件名称`:** 文件的创建（增）。\n- **`cat/more/less/tail 文件名称`** ：文件的查看（查） 。命令 `tail -f 文件` 可以对某个文件进行动态监控，例如 tomcat 的日志文件， 会随着程序的运行，日志会变化，可以使用 `tail -f catalina-2016-11-11.log` 监控 文 件的变化 。\n- **`vim 文件`：** 修改文件的内容（改）。vim 编辑器是 Linux 中的强大组件，是 vi 编辑器的加强版，vim 编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用 vim 编辑修改文件的方式基本会使用就可以了。在实际开发中，使用 vim 编辑器主要作用就是修改配置文件，下面是一般步骤： `vim 文件------\x3e进入文件-----\x3e命令模式------\x3e按i进入编辑模式-----\x3e编辑文件 -------\x3e按Esc进入底行模式-----\x3e输入：wq/q!` （输入 wq 代表写入内容并退出，即保存；输入 q!代表强制退出不保存）。\n- **`rm -rf 文件`：** 删除文件（删）。\n\n### 4.4. 压缩文件的操作命令\n\n**1）打包并压缩文件：**\n\nLinux 中的打包文件一般是以.tar 结尾的，压缩的命令一般是以.gz 结尾的。而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。\n命令：`tar -zcvf 打包压缩后的文件名 要打包压缩的文件` ，其中：\n\n- z：调用 gzip 压缩命令进行压缩\n- c：打包文件\n- v：显示运行过程\n- f：指定文件名\n\n比如：假如 test 目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我们要打包 test 目录并指定压缩后的压缩包名称为 test.tar.gz 可以使用命令：**`tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt` 或 `tar -zcvf test.tar.gz /test/`**\n\n**2）解压压缩包：**\n\n命令：`tar [-xvf] 压缩文件`\n\n其中：x：代表解压\n\n示例：\n\n- 将 /test 下的 test.tar.gz 解压到当前目录下可以使用命令：**`tar -xvf test.tar.gz`**\n- 将 /test 下的 test.tar.gz 解压到根目录/usr 下:**`tar -xvf test.tar.gz -C /usr`**（- C 代表指定解压的位置）\n\n### 4.5. Linux 的权限命令\n\n操作系统中每个文件都拥有特定的权限、所属用户和所属组。权限是操作系统用来限制资源访问的机制，在 Linux 中权限一般分为读(readable)、写(writable)和执行(excutable)，分为三组。分别对应文件的属主(owner)，属组(group)和其他用户(other)，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。\n\n通过 **`ls -l`** 命令我们可以 查看某个目录下的文件或目录的权限\n\n示例：在随意某个目录下`ls -l`\n\n![](linux.assets/Linux权限命令.png)\n\n第一列的内容的信息解释如下：\n\n![](linux.assets/Linux权限解读.png)\n\n> 下面将详细讲解文件的类型、Linux 中权限以及文件有所有者、所在组、其它组具体是什么？\n\n**文件的类型：**\n\n- d： 代表目录\n- -： 代表文件\n- l： 代表软链接（可以认为是 window 中的快捷方式）\n\n**Linux 中权限分为以下几种：**\n\n- r：代表权限是可读，r 也可以用数字 4 表示\n- w：代表权限是可写，w 也可以用数字 2 表示\n- x：代表权限是可执行，x 也可以用数字 1 表示\n\n**文件和目录权限的区别：**\n\n对文件和目录而言，读写执行表示不同的意义。\n\n对于文件：\n\n| 权限名称 |                  可执行操作 |\n| :------- | --------------------------: |\n| r        | 可以使用 cat 查看文件的内容 |\n| w        |          可以修改文件的内容 |\n| x        |    可以将其运行为二进制文件 |\n\n对于目录：\n\n| 权限名称 |               可执行操作 |\n| :------- | -----------------------: |\n| r        |       可以查看目录下列表 |\n| w        | 可以创建和删除目录下文件 |\n| x        |     可以使用 cd 进入目录 |\n\n需要注意的是： **超级用户可以无视普通用户的权限，即使文件目录权限是 000，依旧可以访问。**\n\n**在 linux 中的每个用户必须属于一个组，不能独立于组外。在 linux 中每个文件有所有者、所在组、其它组的概念。**\n\n- **所有者(u)** ：一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用 `ls ‐ahl` 命令可以看到文件的所有者 也可以使用 chown 用户名 文件名来修改文件的所有者 。\n- **文件所在组(g)** ：当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组用 `ls ‐ahl`命令可以看到文件的所有组也可以使用 chgrp 组名 文件名来修改文件所在的组。\n- **其它组(o)** ：除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组。\n\n> 我们再来看看如何修改文件/目录的权限。\n\n**修改文件/目录的权限的命令：`chmod`**\n\n示例：修改/test 下的 aaa.txt 的权限为文件所有者有全部权限，文件所有者所在的组有读写权限，其他用户只有读的权限。\n\n**`chmod u=rwx,g=rw,o=r aaa.txt`** 或者 **`chmod 764 aaa.txt`**\n\n![](linux.assets/修改文件权限.png)\n\n**补充一个比较常用的东西:**\n\n假如我们装了一个 zookeeper，我们每次开机到要求其自动启动该怎么办？\n\n1. 新建一个脚本 zookeeper\n2. 为新建的脚本 zookeeper 添加可执行权限，命令是:`chmod +x zookeeper`\n3. 把 zookeeper 这个脚本添加到开机启动项里面，命令是：`chkconfig --add zookeeper`\n4. 如果想看看是否添加成功，命令是：`chkconfig --list`\n\n### 4.6. Linux 用户管理\n\nLinux 系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。\n\n用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。\n\n**Linux 用户管理相关命令:**\n\n- `useradd 选项 用户名`:添加用户账号\n- `userdel 选项 用户名`:删除用户帐号\n- `usermod 选项 用户名`:修改帐号\n- `passwd 用户名`:更改或创建用户的密码\n- `passwd -S 用户名` :显示用户账号密码信息\n- `passwd -d 用户名`: 清除用户密码\n\n`useradd` 命令用于 Linux 中创建的新的系统用户。`useradd`可用来建立用户帐号。帐号建好之后，再用`passwd`设定帐号的密码．而可用`userdel`删除帐号。使用`useradd`指令所建立的帐号，实际上是保存在 `/etc/passwd`文本文件中。\n\n`passwd`命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。\n\n### 4.7. Linux 系统用户组的管理\n\n每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同 Linux 系统对用户组的规定有所不同，如 Linux 下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。\n\n用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对`/etc/group`文件的更新。\n\n**Linux 系统用户组的管理相关命令:**\n\n- `groupadd 选项 用户组` :增加一个新的用户组\n- `groupdel 用户组`:要删除一个已有的用户组\n- `groupmod 选项 用户组` : 修改用户组的属性\n\n### 4.8. 其他常用命令\n\n- **`pwd`：** 显示当前所在位置\n\n- `sudo + 其他命令`：以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。\n\n- **`grep 要搜索的字符串 要搜索的文件 --color`：** 搜索命令，--color 代表高亮显示\n\n- **`ps -ef`/`ps -aux`：** 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：**`ps aux|grep redis`** （查看包括 redis 字符串的进程），也可使用 `pgrep redis -a`。\n\n  注意：如果直接用 ps（（Process Status））命令，会显示所有进程的状态，通常结合 grep 命令查看某进程的状态。\n\n- **`kill -9 进程的pid`：** 杀死进程（-9 表示强制终止。）\n\n  先用 ps 查找进程，然后用 kill 杀掉\n\n- **网络通信命令：**\n  - 查看当前系统的网卡信息：ifconfig\n  - 查看与某台机器的连接情况：ping\n  - 查看当前系统的端口使用：netstat -an\n- **net-tools 和 iproute2 ：**\n  `net-tools`起源于 BSD 的 TCP/IP 工具箱，后来成为老版本 LinuxLinux 中配置网络功能的工具。但自 2001 年起，Linux 社区已经对其停止维护。同时，一些 Linux 发行版比如 Arch Linux 和 CentOS/RHEL 7 则已经完全抛弃了 net-tools，只支持`iproute2`。linux ip 命令类似于 ifconfig，但功能更强大，旨在替代它。更多详情请阅读[如何在 Linux 中使用 IP 命令和示例](https://linoxide.com/linux-command/use-ip-command-linux)\n- **`shutdown`：** `shutdown -h now`： 指定现在立即关机；`shutdown +5 "System will shutdown after 5 minutes"`：指定 5 分钟后关机，同时送出警告信息给登入用户。\n\n- **`reboot`：** **`reboot`：** 重开机。**`reboot -w`：** 做个重开机的模拟（只有纪录并不会真的重开机）。\n\n'},"5a01":function(n,r,e){"use strict";e.r(r),r["default"]="大家好，我是 Guide 哥！\n\n很多读者抱怨计算操作系统的知识点比较繁杂，自己也没有多少耐心去看，但是面试的时候又经常会遇到。所以，我带着我整理好的操作系统的常见问题来啦！这篇文章总结了一些我觉得比较重要的操作系统相关的问题比如**进程管理**、**内存管理**、**虚拟内存**等等。\n\n文章形式通过大部分比较喜欢的面试官和求职者之间的对话形式展开。另外，Guide哥 也只是在大学的时候学习过操作系统，不过基本都忘了，为了写这篇文章这段时间看了很多相关的书籍和博客。如果文中有任何需要补充和完善的地方，你都可以在 issue 中指出！\n\n这篇文章只是对一些操作系统比较重要概念的一个概览，深入学习的话，建议大家还是老老实实地去看书。另外， 这篇文章的很多内容参考了《现代操作系统》第三版这本书，非常感谢。\n\n开始本文的内容之前，我们先聊聊为什么要学习操作系统。\n\n- **从对个人能力方面提升来说**  ：操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。比如说我们开发的系统使用的缓存（比如 Redis）和操作系统的高速缓存就很像。CPU 中的高速缓存有很多种，不过大部分都是为了解决 CPU 处理速度和内存处理速度不对等的问题。我们还可以把内存看作外存的高速缓存，程序运行的时候我们把外存的数据复制到内存，由于内存的处理速度远远高于外存，这样提高了处理速度。同样地，我们使用的 Redis 缓存就是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题。高速缓存一般会按照局部性原理（2-8 原则）根据相应的淘汰算法保证缓存中的数据是经常会被访问的。我们平常使用的 Redis 缓存很多时候也会按照 2-8 原则去做，很多淘汰算法都和操作系统中的类似。既说了 2-8 原则，那就不得不提命中率了，这是所有缓存概念都通用的。简单来说也就是你要访问的数据有多少能直接在缓存中直接找到。命中率高的话，一般表明你的缓存设计比较合理，系统处理速度也相对较快。\n- **从面试角度来说** ：尤其是校招，对于操作系统方面知识的考察是非常非常多的。\n\n**简单来说，学习操作系统能够提高自己思考的深度以及对技术的理解力，并且，操作系统方面的知识也是面试必备。**\n\n关于如何学习操作系统，可以看这篇回答：[https://www.zhihu.com/question/270998611/answer/1640198217](https://www.zhihu.com/question/270998611/answer/1640198217)。\n\n## 一 操作系统基础\n\n面试官顶着蓬松的假发向我走来，只见他一手拿着厚重的 Thinkpad ，一手提着他那淡黄的长裙。\n\n### 1.1 什么是操作系统？\n\n👨‍💻**面试官** ： 先来个简单问题吧！**什么是操作系统？**\n\n🙋 **我** ：我通过以下四点向您介绍一下什么是操作系统吧！\n\n1. **操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。**\n2. **操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。**  举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。\n3. **操作系统存在屏蔽了硬件层的复杂性。** 操作系统就像是硬件使用的负责人，统筹着各种相关事项。\n4. **操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理**。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。\n\n![Kernel_Layout](basis.assets/Kernel_Layout.png)\n\n### 1.2 系统调用\n\n👨‍💻**面试官** ：**什么是系统调用呢？** 能不能详细介绍一下。\n\n🙋 **我** ：介绍系统调用之前，我们先来了解一下用户态和系统态。\n\n根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：\n\n1. 用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据。\n2. 系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。\n\n说了用户态和系统态之后，那么什么是系统调用呢？\n\n我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！\n\n也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。\n\n这些系统调用按功能大致可分为如下几类：\n\n- 设备管理。完成设备的请求或释放，以及设备启动等功能。\n- 文件管理。完成文件的读、写、创建及删除等功能。\n- 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。\n- 进程通信。完成进程之间的消息传递或信号传递等功能。\n- 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。\n\n## 二 进程和线程\n\n### 2.1 进程和线程的区别\n\n👨‍💻**面试官**: 好的！我明白了！那你再说一下： **进程和线程的区别**。\n\n🙋 **我：** 好的！ 下图是 Java 内存区域，我们从 JVM 的角度来说一下线程和进程之间的关系吧！\n\n> 如果你对 Java 内存区域 (运行时数据区) 这部分知识不太了解的话可以阅读一下这篇文章：[《可能是把 Java 内存区域讲的最清楚的一篇文章》](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java内存区域)\n\n![](basis.assets/up-cd8ac705f6f004c01e0a1312f1599430ba5.png)\n\n从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的**堆**和**方法区 (JDK1.8 之后的元空间)**资源，但是每个线程有自己的**程序计数器**、**虚拟机栈** 和 **本地方法栈**。\n\n**总结：** 线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。\n\n### 2.2 进程有哪几种状态?\n\n👨‍💻**面试官** ： 那你再说说**进程有哪几种状态?**\n\n🙋 **我** ：我们一般把进程大致分为 5 种状态，这一点和[线程](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/JavaConcurrencyBasicsCommonInterviewQuestionsSummary.md#6-%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81)很像！\n\n- **创建状态(new)** ：进程正在被创建，尚未到就绪状态。\n- **就绪状态(ready)** ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。\n- **运行状态(running)** ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。\n- **阻塞状态(waiting)** ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。\n- **结束状态(terminated)** ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。\n\n> 订正：下图中 running 状态被 interrupt 向 ready 状态转换的箭头方向反了。\n\n![process-state](basis.assets/d38202593012b457debbcd74994c6292.png)\n\n### 2.3 进程间的通信方式\n\n👨‍💻**面试官** ：**进程间的通信常见的的有哪几种方式呢?**\n\n🙋 **我** ：大概有 7 种常见的进程间的通信方式。\n\n> 下面这部分总结参考了:[《进程间通信 IPC (InterProcess Communication)》](https://www.jianshu.com/p/c1015f5ffa74) 这篇文章，推荐阅读，总结的非常不错。\n\n1. **管道/匿名管道(Pipes)** ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。\n1. **有名管道(Names Pipes)** : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。\n1. **信号(Signal)** ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；\n1. **消息队列(Message Queuing)** ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。**消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。**\n1. **信号量(Semaphores)** ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。\n1. **共享内存(Shared memory)** ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。\n1. **套接字(Sockets)** : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。\n\n### 2.4 线程间的同步的方式\n\n👨‍💻**面试官** ：**那线程间的同步的方式有哪些呢?**\n\n🙋 **我** ：线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：\n\n1. **互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。\n1. **信号量(Semphares)** ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量\n1. **事件(Event)** :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操\n\n### 2.5 进程的调度算法\n\n👨‍💻**面试官** ：**你知道操作系统中进程的调度算法有哪些吗?**\n\n🙋 **我** ：嗯嗯！这个我们大学的时候学过，是一个很重要的知识点！\n\n为了确定首先执行哪个进程以及最后执行哪个进程以实现最大 CPU 利用率，计算机科学家已经定义了一些算法，它们是：\n\n- **先到先服务(FCFS)调度算法** : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。\n- **短作业优先(SJF)的调度算法** : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。\n- **时间片轮转调度算法** : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。\n- **多级反馈队列调度算法** ：前面介绍的几种进程调度的算法都有一定的局限性。如**短进程优先的调度算法，仅照顾了短进程而忽略了长进程** 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前**被公认的一种较好的进程调度算法**，UNIX 操作系统采取的便是这种调度算法。\n- **优先级调度** ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。\n\n### 2.6 什么是死锁\n\n👨‍💻**面试官** ：**你知道什么是死锁吗?**\n\n🙋 **我** ：多个进程可以竞争有限数量的资源。当一个进程申请资源时，如果这时没有可用资源，那么这个进程进入等待状态。有时，如果所申请的资源被其他等待进程占有，那么该等待进程有可能再也无法改变状态。这种情况成为**死锁**。\n\n### 2.7 死锁的四个条件\n\n👨‍💻**面试官** ：**产生死锁的四个必要条件是什么?**\n\n🙋 **我** ：如果系统中以下四个条件同时成立，那么就能引起死锁：\n\n- **互斥**：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。\n- **占有并等待**：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。\n- **非抢占**：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。\n- **循环等待**：有一组等待进程 `{P0, P1,..., Pn}`，  `P0` 等待的资源被 `P1` 占有，`P1` 等待的资源被 `P2` 占有，......，`Pn-1` 等待的资源被 `Pn` 占有，`Pn` 等待的资源被 `P0` 占有。\n\n注意，只有四个条件同时成立时，死锁才会出现。\n\n## 三 操作系统内存管理基础\n\n### 3.1 内存管理介绍\n\n👨‍💻 **面试官**: **操作系统的内存管理主要是做什么？**\n\n🙋 **我：** 操作系统的内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。\n\n### 3.2 常见的几种内存管理机制\n\n👨‍💻 **面试官**: **操作系统的内存管理机制了解吗？内存管理有哪几种方式?**\n\n🙋 **我：** 这个在学习操作系统的时候有了解过。\n\n简单分为**连续分配管理方式**和**非连续分配管理方式**这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 **块式管理** 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如**页式管理** 和 **段式管理**。\n\n1. **块式管理** ： 远古时代的计算机操系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。\n2. **页式管理** ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。\n3. **段式管理** ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。但是，最重要的是段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。\n\n👨‍💻**面试官** ： 回答的还不错！不过漏掉了一个很重要的 **段页式管理机制** 。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 **段页式管理机制** 中段与段之间以及段的内部的都是离散的。\n\n🙋 **我** ：谢谢面试官！刚刚把这个给忘记了～\n\n### 3.3 快表和多级页表\n\n👨‍💻**面试官** ： 页表管理机制中有两个很重要的概念：快表和多级页表，这两个东西分别解决了页表管理中很重要的两个问题。你给我简单介绍一下吧！\n\n🙋 **我** ：在分页内存管理中，很重要的两点是：\n\n1. 虚拟地址到物理地址的转换要快。\n2. 解决虚拟地址空间大，页表也会很大的问题。\n\n#### 快表\n\n为了解决虚拟地址到物理地址的转换速度，操作系统在 **页表方案** 基础之上引入了 **快表** 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。\n\n使用快表之后的地址转换流程是这样的：\n\n1. 根据虚拟地址中的页号查快表；\n2. 如果该页在快表中，直接从快表中读取相应的物理地址；\n3. 如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；\n4. 当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。\n\n看完了之后你会发现快表和我们平时经常在我们开发的系统使用的缓存（比如 Redis）很像，的确是这样的，操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。\n\n#### 多级页表\n\n引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景，具体可以查看下面这篇文章\n\n- 多级页表如何节约内存：[https://www.polarxiong.com/archives/多级页表如何节约内存.html](https://www.polarxiong.com/archives/多级页表如何节约内存.html)\n\n#### 总结\n\n为了提高内存的空间性能，提出了多级页表的概念；但是提到空间性能是以浪费时间性能为基础的，因此为了补充损失的时间性能，提出了快表（即 TLB）的概念。 不论是快表还是多级页表实际上都利用到了程序的局部性原理，局部性原理在后面的虚拟内存这部分会介绍到。\n\n### 3.4 分页机制和分段机制的共同点和区别\n\n👨‍💻**面试官** ： **分页机制和分段机制有哪些共同点和区别呢？**\n\n🙋 **我** ：\n\n1. **共同点** ：\n   - 分页机制和分段机制都是为了提高内存利用率，较少内存碎片。\n   - 页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。\n2. **区别** ：\n   - 页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。\n   - 分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。\n\n### 3.5 逻辑(虚拟)地址和物理地址\n\n👨‍💻**面试官** ：你刚刚还提到了**逻辑地址和物理地址**这两个概念，我不太清楚，你能为我解释一下不？\n\n🙋 **我：** em...好的嘛！我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。\n\n### 3.6 CPU 寻址了解吗?为什么需要虚拟地址空间?\n\n👨‍💻**面试官** ：**CPU 寻址了解吗?为什么需要虚拟地址空间?**\n\n🙋 **我** ：这部分我真不清楚！\n\n于是面试完之后我默默去查阅了相关文档！留下了没有技术的泪水。。。\n\n> 这部分内容参考了 Microsoft 官网的介绍，地址：<https://docs.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/virtual-address-spaces?redirectedfrom=MSDN>\n\n现代处理器使用的是一种称为 **虚拟寻址(Virtual Addressing)** 的寻址方式。**使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。** 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 **内存管理单元（Memory Management Unit, MMU）** 的硬件。如下图所示：\n\n![MMU_principle_updated](basis.assets/2b27dac8cc647f8aac989da2d1166db2.png)\n\n**为什么要有虚拟地址空间呢？**\n\n先从没有虚拟地址空间的时候说起吧！没有虚拟地址空间的时候，**程序都是直接访问和操作的都是物理内存** 。但是这样有什么问题呢？\n\n1. 用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。\n2. 想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行。为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。\n\n**总结来说：如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难。**\n\n通过虚拟地址访问内存有以下优势：\n\n- 程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。\n- 程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。\n- 不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。\n\n## 四 虚拟内存\n\n### 4.1 什么是虚拟内存(Virtual Memory)?\n\n👨‍💻**面试官** ：再问你一个常识性的问题！**什么是虚拟内存(Virtual Memory)?**\n\n🙋 **我** ：这个在我们平时使用电脑特别是 Windows 系统的时候太常见了。很多时候我们使用点开了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存。**为什么可以这样呢？** 正是因为 **虚拟内存** 的存在，通过 **虚拟内存** 可以让程序可以拥有超过系统物理内存大小的可用内存空间。另外，**虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）**。这样会更加有效地管理内存并减少出错。\n\n**虚拟内存**是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。**虚拟内存的重要意义是它定义了一个连续的虚拟地址空间**，并且 **把内存扩展到硬盘空间**。推荐阅读：[《虚拟内存的那点事儿》](https://juejin.im/post/59f8691b51882534af254317)\n\n维基百科中有几句话是这样介绍虚拟内存的。\n\n> **虚拟内存** 使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如 RAM）的使用也更有效率。目前，大多数操作系统都使用了虚拟内存，如 Windows 家族的“虚拟内存”；Linux 的“交换空间”等。From:<https://zh.wikipedia.org/wiki/虚拟内存>\n\n### 4.2 局部性原理\n\n👨‍💻**面试官** ：要想更好地理解虚拟内存技术，必须要知道计算机中著名的**局部性原理**。另外，局部性原理既适用于程序结构，也适用于数据结构，是非常重要的一个概念。\n\n🙋 **我** ：局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。\n\n> 以下内容摘自《计算机操作系统教程》 第 4 章存储器管理。\n\n早在 1968 年的时候，就有人指出我们的程序在执行的时候往往呈现局部性规律，也就是说在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。\n\n局部性原理表现在以下两个方面：\n\n1. **时间局部性** ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。\n2. **空间局部性** ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。\n\n时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。\n\n### 4.3 虚拟存储器\n\n> **勘误：虚拟存储器又叫做虚拟内存，都是 Virtual Memory 的翻译，属于同一个概念。**\n\n👨‍💻**面试官** ：~~都说了虚拟内存了。你再讲讲**虚拟存储器**把！~~\n\n🙋 **我** ：\n\n> 这部分内容来自：[王道考研操作系统知识点整理](https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/13.html)。\n\n基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器——**虚拟存储器**。\n\n实际上，我觉得虚拟内存同样是一种时间换空间的策略，你用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。不得不感叹，程序世界几乎不是时间换空间就是空间换时间。\n\n### 4.4 虚拟内存的技术实现\n\n👨‍💻**面试官** ：**虚拟内存技术的实现呢？**\n\n🙋 **我** ：**虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。** 虚拟内存的实现有以下三种方式：\n\n1. **请求分页存储管理** ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。\n2. **请求分段存储管理** ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。\n3. **请求段页式存储管理**\n\n**这里多说一下？很多人容易搞混请求分页与分页存储管理，两者有何不同呢？**\n\n请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。\n\n它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。\n\n不管是上面那种实现方式，我们一般都需要：\n\n1. 一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；\n2. **缺页中断**：如果**需执行的指令或访问的数据尚未在内存**（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段**调入到内存**，然后继续执行程序；\n3. **虚拟地址空间** ：逻辑地址到物理地址的变换。\n\n### 4.5 页面置换算法\n\n👨‍💻**面试官** ：虚拟内存管理很重要的一个概念就是页面置换算法。那你说一下 **页面置换算法的作用?常见的页面置换算法有哪些?**\n\n🙋 **我** ：\n\n> 这个题目经常作为笔试题出现，网上已经给出了很不错的回答，我这里只是总结整理了一下。\n\n地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。\n\n> **缺页中断** 就是要访问的**页**不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。\n\n当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。\n\n- **OPT 页面置换算法（最佳页面置换算法）** ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。\n- **FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）** : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。\n- **LRU （Least Recently Used）页面置换算法（最近最久未使用页面置换算法）** ：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。\n- **LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）** :  该置换算法选择在之前时期使用最少的页面作为淘汰页。\n\n## Reference\n\n- 《计算机操作系统—汤小丹》第四版\n- [《深入理解计算机系统》](https://book.douban.com/subject/1230413/)\n- [https://zh.wikipedia.org/wiki/输入输出内存管理单元](https://zh.wikipedia.org/wiki/输入输出内存管理单元)\n- [https://baike.baidu.com/item/快表/19781679](https://baike.baidu.com/item/快表/19781679)\n- https://www.jianshu.com/p/1d47ed0b46d5\n- <https://www.studytonight.com/operating-system>\n- <https://www.geeksforgeeks.org/interprocess-communication-methods/>\n- <https://juejin.im/post/59f8691b51882534af254317>\n- 王道考研操作系统知识点整理： https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/13.html\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},a85d:function(n,r,e){"use strict";e.r(r),r["default"]="```\r\n      在mac下npm install的错误处理\r\nsudo －s      权限问题\r\n\r\ncommand+shift+G，前往文件夹\r\ncommand+shift+. 显示隐藏文件\r\nopen ~/.bash_profile .  打开文件\r\nsource ~/.bash_profile   立即生效\r\nPATH=$PATH:~/.composer/vendor/bin  添加 path\r\n\r\n\r\nmac 终端 一些命令\r\n\r\nsudo －s      权限问题\r\ncd downloads\r\nmkdir  生成文件夹\r\ncd    进入 \r\ncd ../server\r\nls    列出当前文件夹下的文件夹\r\ntouch js/class/test.js   创建test 文件，并 初始化\r\ntouch views/index.ejs  初始化创建 入口 模板文件\r\n\r\nclear   清空 \r\n    \r\n        mac退出bash-32\r\n        https://blog.csdn.net/qingtian12138/article/details/68065272\r\n\r\n今天准备学Scala，配环境的时候，不知道怎么弄得，晕晕乎乎把终端root了，打开就显示bash-32，不显示当前工作路径了，输入exit也没用，打开还是bash, 搜了一下午解决方案，都不好使，咨询了大神，终于弄好了，下面记录下来。\r\n出现这种情况的原因是进了shell环境，我们首先检查终端是不是一打开就默认进shell环境，\r\n左上角打开终端的偏好设置，将shell的打开方式那一栏选命令\r\n\r\n\r\n然后重启终端，看看问题是不是解决了，如果还是不行，接着下一步\r\n输入vi ~/.bash_profile\r\n打开配置文件，输入i进入编辑页面，在最后一行加入\r\nexport PS1='[\\u@\\h \\w]\\$'\r\n\r\n然后按Esc退出编辑模式，输入大写ZZ保存退出。\r\n然后执行\r\nsource ~/.bash_profile\r\n重启终端，问题解决！\r\n\r\n\r\n其实呢，加进去的那一行是bash可识别的转义序列\r\nbash可识别的转义序列有下面这些：\r\n\\u 用户名\r\n\\h 主机名第一部分\r\n\\H 主机名全称\r\n\\w 当前工作目录（如 “/home/username/mywork”）\r\n\\W 当前工作目录的“基名 (basename)”（如 “mywork”)\r\n\\t 24 小时制时间\r\n\\T 12 小时制时间\r\n\\@ 带有 am/pm 的 12 小时制时间\r\n\\d “Sat Dec 18″ 格式的日期\r\n\\s shell 的名称（如 “bash”)\r\n\\v bash 的版本（如 2.04）\r\n\\V Bash 版本（包括补丁级别）\r\n\\n 换行符\r\n\\r 回车符\r\n\\\\ 反斜杠\r\n\\a ASCII 响铃字符（也可以键入 07）\r\n\\e ASCII 转义字符（也可以键入 33)\r\n这个序列应该出现在不移动光标的字符序列（如颜色转义序列）之前。它使bash能够正确计算自动换行。\r\n这个序列应该出现在非打印字符序列之后。\r\n知道了全部的转义序列，就可以对自己的终端提示符进行定制了。\r\n\r\n\r\n    \r\n```"},ddf5:function(n,r,e){"use strict";e.r(r),r["default"]='CMD命令：开始－>运行－>键入cmd或command（在命令行里可以看到系统版本、文件系统版本）\r\nchcp 修改默认字符集\r\nchcp 936默认中文\r\nchcp 65001\r\n\\1. appwiz.cpl：程序和功能 2. calc：启动计算器\r\n\r\n\\5. chkdsk.exe：Chkdsk磁盘检查（管理员身份运行命令提示符）\r\n\\6. cleanmgr: 打开磁盘清理工具 9. cmd.exe：CMD命令提示符 10. 自动关机命令 　 Shutdown -s -t 600：表示600秒后自动关机 　 shutdown -a ：可取消定时关机 　 Shutdown -r -t 600：表示600秒后自动重启 　\r\n\r\n\\12. CompMgmtLauncher：计算机管理 13. compmgmt.msc：计算机管理 14. credwiz：备份或还原储存的用户名和密码\r\n\\16. control：控制面版 17. dcomcnfg：打开系统组件服务 19. devmgmt.msc：设备管理器 20. desk.cpl：屏幕分辨率 21. dfrgui：优化驱动器 Windows 7→dfrg.msc：磁盘碎片整理程序 22. dialer：电话拨号程序 23. diskmgmt.msc：磁盘管理 24. dvdplay：DVD播放器 25. dxdiag：检查DirectX信息 26. eudcedit：造字程序 27. eventvwr：事件查看器 28. explorer：打开资源管理器 29. Firewall.cpl：Windows防火墙\r\n\\31. fsmgmt.msc：共享文件夹管理器 32. gpedit.msc：组策略 33. hdwwiz.cpl：设备管理器 34. inetcpl.cpl：Internet属性 35. intl.cpl：区域 36. iexpress：木马捆绑工具，系统自带 37. joy.cpl：游戏控制器 38. logoff：注销命令 39. lusrmgr.msc：本地用户和组 40. lpksetup：语言包安装/删除向导，安装向导会提示下载语言包 41. lusrmgr.msc：本机用户和组 42. main.cpl：鼠标属性 43. mmsys.cpl：声音 45. mem.exe：显示内存使用情况（如果直接运行无效，可以先管理员身份运行命令提示符，在命令提示符里输入mem.exe>d:a.txt 即可打开d盘查看a.txt，里面的就是内存使用情况了。当然什么盘什么文件名可自己决定。）\r\n\r\n\r\n\\47. mmc：打开控制台 48. mobsync：同步命令 50. Msconfig.exe：系统配置实用程序 51. msdt：微软支持诊断工具 52. msinfo32：系统信息 53. mspaint：画图 54. Msra：Windows远程协助 55. mstsc：远程桌面连接 56. NAPCLCFG.MSC：客户端配置 57. ncpa.cpl：网络连接 58. narrator：屏幕“讲述人” 59. Netplwiz：高级用户帐户控制面板，设置登陆安全相关的选项 60. netstat : an(TC)命令检查接口 61. notepad：打开记事本 62. Nslookup：IP地址侦测器 63. odbcad32：ODBC数据源管理器\r\n\\64. OptionalFeatures：打开“打开或关闭Windows功能”对话框\r\n\r\n\\65. osk：打开屏幕键盘 66. perfmon.msc：计算机性能监测器 67. perfmon：计算机性能监测器 68. PowerShell：提供强大远程处理能力 69. printmanagement.msc：打印管理 70. powercfg.cpl：电源选项 71. psr：问题步骤记录器 72. Rasphone：网络连接 73. Recdisc：创建系统修复光盘 74. Resmon：资源监视器 75. Rstrui：系统还原 76. regedit.exe：注册表 77. regedt32：注册表编辑器 78. rsop.msc：组策略结果集 79. sdclt：备份状态与配置，就是查看系统是否已备份 80. secpol.msc：本地安全策略 81. services.msc：本地服务设置 82. sfc /scannow：扫描错误并复原/windows文件保护 83. sfc.exe：系统文件检查器 84. shrpubw：创建共享文件夹 85. sigverif：文件签名验证程序 86. slui：Windows激活，查看系统激活信息 87. slmgr.vbs -dlv ：显示详细的许可证信息 　 slmgr.vbs -dli ：显示许可证信息 　 slmgr.vbs -xpr ：当前许可证截止日期 　 slmgr.vbs -dti ：显示安装ID 以进行脱机激 　 slmgr.vbs -ipk ：(Product Key)安装产品密钥 　 slmgr.vbs -ato ：激活Windows 　 slmgr.vbs -cpky ：从注册表中清除产品密钥（防止泄露引起的攻击） 　 slmgr.vbs -ilc ：(License file)安装许可证 　 slmgr.vbs -upk ：卸载产品密钥 　 slmgr.vbs -skms ：(name[ort] )批量授权 88. snippingtool：截图工具，支持无规则截图 89. soundrecorder：录音机，没有录音时间的限制 90. StikyNot：便笺 91. sysdm.cpl：系统属性 92. sysedit：系统配置编辑器 93. syskey：系统加密，一旦加密就不能解开，保护系统的双重密码 94. taskmgr：任务管理器（旧版） 95. TM任务管理器（新版） 96. taskschd.msc：任务计划程序 97. timedate.cpl：日期和时间 98. UserAccountControlSettings用户账户控制设置 99. utilman：辅助工具管理器 100. wf.msc：高级安全Windows防火墙 101. WFS：Windows传真和扫描 102. wiaacmgr：扫描仪和照相机向导 103. winver：关于Windows 104. wmimgmt.msc：打开windows管理体系结构(WMI) 105. write：写字板 106. wscui.cpl：操作中心 107. wscript：windows脚本宿主设置 108. wuapp：Windows更新\r\n\r\n\\1. gpedit.msc-----组策略\r\n\\2. sndrec32-------录音机\r\n\\3. Nslookup-------IP地址侦测器 ，是一个 监测网络中 DNS 服务器是否能正确实现域名解析的命令行工具。 它在 Windows NT/2000/XP 中均可使用 , 但在 Windows 98 中却没有集成这一个工具。\r\n\\4. explorer-------打开资源管理器 5. logoff---------注销命令\r\n\\6. shutdown-------60秒倒计时关机命令\r\n\\7. lusrmgr.msc----本机用户和组\r\n\\8. services.msc---本地服务设置\r\n\\9. oobe/msoobe /a----检查XP是否激活\r\n\\10. notepad--------打开记事本\r\n\r\n\r\n\r\n\\11. cleanmgr-------垃圾整理\r\n\\12. net start messenger----开始信使服务\r\n\\13. compmgmt.msc---计算机管理\r\n\\14. net stop messenger-----停止信使服务\r\n\\15. conf-----------启动netmeeting\r\n\\16. dvdplay--------DVD播放器\r\n\\17. charmap--------启动字符映射表\r\n\\18. diskmgmt.msc---磁盘管理实用程序\r\n\\19. calc-----------启动计算器\r\n\\20. dfrg.msc-------磁盘碎片整理程序\r\n\\21. chkdsk.exe-----Chkdsk磁盘检查\r\n\\22. devmgmt.msc--- 设备管理器 23. regsvr32 /u *.dll----停止dll文件运行\r\n\\24. drwtsn32------ 系统医生\r\n\\25. rononce -p----15秒关机\r\n\\26. dxdiag---------检查DirectX信息\r\n\\27. regedt32-------注册表编辑器 28. Msconfig.exe---系统配置实用程序\r\n\\29. rsop.msc-------组策略结果集\r\n\\30. mem.exe--------显示内存使用情况\r\n\\31. regedit.exe----注册表\r\n\\32. winchat--------XP自带局域网聊天\r\n\\33. progman--------程序管理器\r\n\\34. winmsd---------系统信息\r\n\\35. perfmon.msc----计算机性能监测程序\r\n\\36. winver---------检查Windows版本\r\n\\37. sfc /scannow-----扫描错误并复原\r\n\\38. taskmgr-----任务管理器（2000/xp/2003\r\n\\39. winver---------检查Windows版本\r\n\\40. wmimgmt.msc----打开windows管理体系结构(WMI)\r\n\\41. wupdmgr--------windows更新程序\r\n\\42. wscript--------windows脚本宿主设置\r\n\\43. write----------写字板\r\n\\44. winmsd---------系统信息\r\n\\45. wiaacmgr-------扫描仪和照相机向导\r\n\\46. winchat--------XP自带局域网聊天\r\n\\47. mem.exe--------显示内存使用情况\r\n\\48. Msconfig.exe---系统配置实用程序\r\n\\49. mplayer2-------简易widnows media player\r\n\\50. mspaint--------画图板\r\n\\51. mstsc----------远程桌面连接\r\n\\52. mplayer2-------媒体播放机\r\n\\53. magnify--------放大镜实用程序\r\n\\54. mmc------------打开控制台\r\n\\55. mobsync--------同步命令\r\n\\56. dxdiag---------检查DirectX信息\r\n\\57. iexpress-------木马捆绑工具，系统自带 58. fsmgmt.msc-----共享文件夹管理器\r\n\\59. utilman--------辅助工具管理器\r\n\\60. diskmgmt.msc---磁盘管理实用程序\r\n\\61. dcomcnfg-------打开系统组件服务\r\n\\62. ddeshare-------打开DDE共享设置\r\n\\110. osk------------打开屏幕键盘 111. odbcad32-------ODBC数据源管理器\r\n\\112. oobe/msoobe /a----检查XP是否激活 114. logoff---------注销命令\r\n\\66. notepad--------打开记事本\r\n\\67. nslookup-------网络管理的工具向导\r\n\\68. ntbackup-------系统备份和还原\r\n\\69. narrator-------屏幕“讲述人”\r\n\\70. ntmsmgr.msc----移动存储管理器\r\n\\71. ntmsoprq.msc---移动存储管理员操作请求\r\n\\72. netstat -an----(TC)命令检查接口\r\n\\73. syncapp--------创建一个公文包\r\n\\74. sysedit--------系统配置编辑器\r\n\\75. sigverif-------文件签名验证程序\r\n\\76. ciadv.msc------索引服务程序\r\n\\77. shrpubw--------创建共享文件夹\r\n\\78. secpol.msc-----本地安全策略\r\n\\79. syskey---------系统加密，一旦加密就不能解开，保护windows xp系统的双重密码\r\n\\80. services.msc---本地服务设置\r\n\\81. Sndvol32-------音量控制程序\r\n\\82. sfc.exe--------系统文件检查器\r\n\\83. sfc /scannow---windows文件保护\r\n\\84. ciadv.msc------索引服务程序\r\n\\85. tourstart------xp简介（安装完成后出现的漫游xp程序）\r\n\\86. taskmgr--------任务管理器\r\n\\87. eventvwr-------事件查看器\r\n\\88. eudcedit-------造字程序\r\n\\89. compmgmt.msc---计算机管理\r\n\\90. packager-------对象包装程序\r\n\\91. perfmon.msc----计算机性能监测程序\r\n\\92. charmap--------启动字符映射表\r\n\\93. cliconfg-------SQL SERVER 客户端网络实用程序\r\n\\94. Clipbrd--------剪贴板查看器\r\n\\95. conf-----------启动netmeeting\r\n\\96. certmgr.msc----证书管理实用程序\r\n\\97. regsvr32 /u *.dll----停止dll文件运行\r\n\\98. regsvr32 /u zipfldr.dll------取消ZIP支持\r\n\\99. cmd.exe--------CMD命令提示符\r\n\\100. chkdsk.exe-----Chkdsk磁盘检查\r\n1.磁盘操作，fdisk 隐含 参数 /mbr 重建主引导记录fdisk /mbr 重建主引导记录fdisk 在DOS7.0以后增加了/cmbr参数，可在挂接多个物理硬盘时，重建排序在后面的硬盘的主引导记录，例如：fdisk /cmbr 2，可重写第二个硬盘的主引导记录。（在使用时要十分小心，避免把好的硬盘引导记录损坏）format 参数： /q 快速格式化 /u 不可恢复 /autotest 不提示 /s 创建 MS-DOS 引导盘 format c: /q /u /autotest\r\n2.目录操作DIR [目录名或文件名] [/S][/W][/P][/A] 列出目录 参数: /s 查找子目录/w 只显示文件名 /p 分页/a 显示隐藏文件 DIR format.exe /s查找该盘的format.exe文件并报告位置MD (MKDIR) [目录名] 创建目录 MKDIR HELLOWORLD 创建HELLOWORLD目录 　　CD (CHDIR) [目录名] PS:可以使用相对目录或绝对目录 进入目录 CD AA 进入当前文件夹下的AA目录,cd .. 进入上一个文件夹cd \\返回根目录;cd c:\\windows 进入c:\\windows文件夹RD ( RMDIR) [目录名] 删除目录 RD HELLOWORLD 删除HELLOWORLD目录\r\n3.文件操作删除目录及其文件： rmdir [目录名或文件名] [/S][/W][/P][/A] 。例 rmdir c:\\qqdownload/s 删除C盘的qqdownload目录。del [目录名或文件名] [/f][/s][/q] 删除 参数:/f 删除只读文件/s 删除该目录及其下的所有内容 /q 删除前不确认del c:\\del /s /q 自动删除c盘的del目录。copy [源文件或目录] [目标目录] 复制文件 copy d:\\pwin98\\*.* c:\\presetup 将d盘的pwin98的所有文件复制到c盘的presetup下。attrib [参数][源文件或目录] 文件属性操作命令，attrib命令可以列出或修改磁盘上文件的属性，文件属性包括文档（A）、只读(R)、隐藏(H)、系统(S)，例如：attrib -h -r -s io.sys 执行这一命令后，将把DOS系统文件io.sys文件的只读、隐藏、系统属性去掉，这时将可以直接通过dir命令看到io.sys文件。attrib +h +r +s autoexec.bat将为自动批处理文件增加以上属性。\r\n4.内存操作debug 调试内存 参数 -w [文件名] 写入二进制文件 -o [地址1] [地址2] 输出内存 -q 退出 exp:o 70 10[return] o 71 01[return] 01[return] q[return] DOS下通过写70h/71h PORT改变BIOS密码在CMOS中存放的对应位置的值,用以清除AWARD BIOS密码.debug 还可以破解硬盘保护卡等,但只可以在纯DOS下用。\r\n5.分区操作给磁盘分区，一般都会分成四个区，磁盘分区由主分区、扩展分区、逻辑分区组成。PQ和Acronis Disk Director这两个工具都可以在不丢失数据的情况下对分区进行调整大小，以及合并等操作，XP系统的话你用PQ，WIN7系统的话用Acronis Disk Director 操作基本一样，可以去网上找教程来看看，再不重装系统的情况下都能调整分区大小，但是建议你还是先备份下数据再调整，毕竟对硬盘直接进行的操作有一定的危险性。\r\nnet use ipipc$ " " /user:" " 建立IPC空链接\r\nnet use ipipc$ "密码" /user:"用户名" 建立IPC非空链接\r\nnet use h: ipc$ "密码" /user:"用户名" 直接登陆后映射对方C：到本地为H:\r\nnet use h: ipc$ 登陆后映射对方C：到本地为H:\r\nnet use ipipc$ /del 删除IPC链接\r\nnet use h: /del 删除映射对方到本地的为H:的映射\r\nnet user 用户名　密码　/add 建立用户\r\nnet user guest /active:yes 激活guest用户\r\nnet user 查看有哪些用户\r\nnet user 帐户名 查看帐户的属性\r\nnet localgroup administrators 用户名 /add 把“用户”添加到管理员中使其具有管理员权限\r\nnet start 查看开启了哪些服务\r\nnet start 服务名　开启服务；(如:net start telnet， net start schedule)\r\nnet stop 服务名 停止某服务\r\nnet time 目标ip 查看对方时间\r\nnet time 目标ip /set 设置本地计算机时间与“目标IP”主机的时间同步,加上参数/yes可取消确认信息\r\nnet view 查看本地局域网内开启了哪些共享\r\nnet view ip 查看对方局域网内开启了哪些共享\r\nnet config 显示系统网络设置\r\nnet logoff 断开连接的共享\r\nnet pause 服务名 暂停某服务\r\nnet send ip "文本信息" 向对方发信息\r\nnet ver 局域网内正在使用的网络连接类型和信息\r\nnet share 查看本地开启的共享\r\nnet share ipc$ 开启ipc$共享\r\nnet share ipc$ /del 删除ipc$共享\r\nnet share c$ /del 删除C：共享\r\nnet user guest 12345 用guest用户登陆后用将密码改为12345\r\nnet password 密码 更改系统登陆密码\r\nnetstat -a 查看开启了哪些端口,常用netstat -an\r\nnetstat -n 查看端口的网络连接情况，常用netstat -an\r\nnetstat -v 查看正在进行的工作\r\nnetstat -p 协议名 例：netstat -p tcq/ip 查看某协议使用情况\r\nnetstat -s 查看正在使用的所有协议使用情况\r\nnbtstat -A ip 对方136到139其中一个端口开了的话，就可查看对方最近登陆的用户名\r\ntracert -参数 ip(或计算机名) 跟踪路由（数据包），参数：“-w数字”用于设置超时间隔。\r\nping ip(或域名) 向对方主机发送默认大小为32字节的数据，参数：“-l[空格]数据包大小”；“-n发送数据次数”；“-t”指一直ping。\r\nping -t -l 65550 ip 死亡之ping(发送大于64K的文件并一直ping就成了死亡之ping)\r\nipconfig (winipcfg) 用于windows NT及XP(windows 95 98)查看本地ip地址，ipconfig可用参数“/all”显示全部配置信息\r\ntlist -t 以树行列表显示进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内)\r\nkill -F 进程名 加-F参数后强制结束某进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内)\r\ndel -F 文件名 加-F参数后就可删除只读文件,/AR、/AH、/AS、/AA分别表示删除只读、隐藏、系统、存档文件，\r\n/A-R、/A-H、/A-S、/A-A表示删除除只读、隐藏、系统、存档以外的文件。例如“DEL/AR *.*”表示删除当前目录下所有只读文件，“DEL/A-S *.*”表示删除当前目录下除系统文件以外的所有文件\r\ndel /S /Q 目录 或用：rmdir /s /Q 目录 /S删除目录及目录下的所有子目录和文件。同时使用参数/Q 可取消删除操作时的系统确认就直接删除。（二个命令作用相同）\r\nmove 盘符路径要移动的文件名　存放移动文件的路径移动后文件名 移动文件,用参数/y将取消确认移动目录存在相同文件的提示就直接覆盖\r\nfc one.txt two.txt > 3st.txt 对比二个文件并把不同之处输出到3st.txt文件中，"> "和"> >" 是重定向命令\r\nat id号 开启已注册的某个计划任务\r\nat /delete 停止所有计划任务，用参数/yes则不需要确认就直接停止\r\nat id号 /delete 停止某个已注册的计划任务\r\nat 查看所有的计划任务\r\nat ip time 程序名(或一个命令) /r 在某时间运行对方某程序并重新启动计算机\r\nfinger username @host 查看最近有哪些用户登陆\r\ntelnet ip 端口 远和登陆服务器,默认端口为23\r\nopen ip 连接到IP（属telnet登陆后的命令）\r\ntelnet 在本机上直接键入telnet 将进入本机的telnet\r\ncopy 路径文件名1　路径文件名2 /y 复制文件1到指定的目录为文件2，用参数/y就同时取消确认你要改写一份现存目录文件\r\ncopy c:srv.exe ipadmin$ 复制本地c:srv.exe到对方的admin下\r\ncopy 1st.jpg/b+2st.txt/a 3st.jpg 将2st.txt的内容藏身到1st.jpg中生成3st.jpg新的文件，注：2st.txt文件头要空三排，参数：/b指二进制文件，/a指ASCLL格式文件\r\ncopy ipadmin$svv.exe c: 或:copyipadmin$*.* 复制对方admini$共享下的srv.exe文件（所有文件）至本地C：\r\nxcopy 要复制的文件或目录树　目标地址目录名 复制文件和目录树，用参数/Y将不提示覆盖相同文件\r\n用参数/e才可连目录下的子目录一起复制到目标地址下。\r\ntftp -i 自己IP(用肉机作跳板时这用肉机IP) get server.exec:server.exe 登陆后，\r\n将“IP”的server.exe下载到目标主机c:server.exe 参数：-i指以二进制模式传送，如传送exe文件时用，如不加-i 则以ASCII模式（传送文本文件模式）进行传送\r\ntftp -i 对方IP　put c:server.exe 登陆后，上传本地c:server.exe至主机\r\nftp ip 端口 用于上传文件至服务器或进行文件操作，默认端口为21。bin指用二进制方式传送（可执行文件进）；默认为ASCII格式传送(文本文件时)\r\nroute print 显示出IP路由，将主要显示网络地址Network addres，子网掩码Netmask，网关地址Gateway addres，接口地址Interface\r\narp 查看和处理ARP缓存，ARP是名字解析的意思，负责把一个IP解析成一个物理性的MAC地址。arp -a将显示出全部信息\r\nstart 程序名或命令 /max 或/min 新开一个新窗口并最大化（最小化）运行某程序或命令\r\nmem 查看cpu使用情况\r\nattrib 文件名(目录名) 查看某文件（目录）的属性\r\nattrib 文件名 -A -R -S -H 或 +A +R +S +H 去掉(添加)某文件的 存档，只读，系统，隐藏 属性；用+则是添加为某属性\r\ndir 查看文件，参数：/Q显示文件及目录属系统哪个用户，/T:C显示文件创建时间，/T:A显示文件上次被访问时间，/T:W上次被修改时间\r\ndate /t 、 time /t 使用此参数即“DATE/T”、“TIME/T”将只显示当前日期和时间，而不必输入新日期和时间\r\nset 指定环境变量名称=要指派给变量的字符 设置环境变量\r\nset 显示当前所有的环境变量\r\nset p(或其它字符) 显示出当前以字符p(或其它字符)开头的所有环境变量\r\npause 暂停批处理程序，并显示出：请按任意键继续....\r\nif 在批处理程序中执行条件处理（更多说明见if命令及变量）\r\ngoto 标签 将cmd.exe导向到批处理程序中带标签的行（标签必须单独一行，且以冒号打头，例如：“：start”标签）\r\ncall 路径批处理文件名 从批处理程序中调用另一个批处理程序 （更多说明见call /?）\r\nfor 对一组文件中的每一个文件执行某个特定命令（更多说明见for命令及变量）\r\necho on或off 打开或关闭echo，仅用echo不加参数则显示当前echo设置\r\necho 信息 在屏幕上显示出信息\r\necho 信息 >> pass.txt 将"信息"保存到pass.txt文件中\r\nfindstr "Hello" aa.txt 在aa.txt文件中寻找字符串hello\r\nfind 文件名 查找某文件\r\ntitle 标题名字 更改CMD窗口标题名字\r\ncolor 颜色值 设置cmd控制台前景和背景颜色；0=黑、1=蓝、2=绿、3=浅绿、4=红、5=紫、6=黄、7=白、8=灰、9=淡蓝、A=淡绿、B=淡浅绿、C=淡红、D=淡紫、E=淡黄、F=亮白\r\nprompt 名称 更改cmd.exe的显示的命令提示符(把C:、D:统一改为：EntSky )\r\nver 在DOS窗口下显示版本信息 winver 弹出一个窗口显示版本信息（内存大小、系统版本、补丁版本、计算机名）\r\nformat 盘符 /FS:类型 格式化磁盘,类型:FAT、FAT32、NTFS ,例：Format D: /FS:NTFS\r\nmd　目录名 创建目录\r\nreplace 源文件　要替换文件的目录 替换文件\r\nren 原文件名　新文件名 重命名文件名\r\ntree 以树形结构显示出目录，用参数-f 将列出第个文件夹中文件名称\r\ntype 文件名 显示文本文件的内容\r\nmore 文件名 逐屏显示输出文件\r\ndoskey 要锁定的命令=字符\r\ndoskey 要解锁命令= 为DOS提供的锁定命令(编辑命令行，重新调用win2k命令，并创建宏)。如：锁定dir命令：doskey dir=entsky (不能用doskey dir=dir)；解锁：doskey dir=\r\ntaskmgr 调出任务管理器\r\nchkdsk /F D: 检查磁盘D并显示状态报告；加参数/f并修复磁盘上的错误\r\ntlntadmn telnt服务admn,键入tlntadmn选择3，再选择8,就可以更改telnet服务默认端口23为其它任何端口\r\nexit 退出cmd.exe程序或目前，用参数/B则是退出当前批处理脚本而不是cmd.exe\r\npath 路径可执行文件的文件名 为可执行文件设置一个路径。\r\ncmd 启动一个win2K命令解释窗口。参数：/eff、/en 关闭、开启命令扩展；更我详细说明见cmd /?\r\nregedit /s 注册表文件名 导入注册表；参数/S指安静模式导入，无任何提示；\r\nregedit /e 注册表文件名 导出注册表\r\ncacls 文件名　参数 显示或修改文件访问控制列表（ACL）——针对NTFS格式时。\r\n参数：/D 用户名:设定拒绝某用户访问；/P 用户名:perm 替换指定用户的访问权限；\r\n/G 用户名:perm 赋予指定用户访问权限；Perm 可以是: N 无，R 读取， W 写入， C 更改(写入)，F 完全控制；例：cacls D: est.txt /D pub 设定d: est.txt拒绝pub用户访问。\r\ncacls 文件名 查看文件的访问用户权限列表\r\nREM 文本内容 在批处理文件中添加注解\r\nnetsh 查看或更改本地网络配置情况'},e220:function(n,r,e){"use strict";e.r(r),r["default"]="# Excel 公式和函数\r\n\r\nhttps://support.microsoft.com/zh-CN/excel\r\n\r\n| **函数**              | **说明**                                     |\r\n| --------------------- | -------------------------------------------- |\r\n| BETADIST 函数     | 返回 beta 累积分布函数                       |\r\n| BETAINV 函数      | 返回指定 beta 分布的累积分布函数的反函数     |\r\n| BINOMDIST 函数    | 返回一元二项式分布的概率                     |\r\n| CHIDIST 函数      | 返回 χ2 分布的单尾概率                       |\r\n| CHIINV 函数       | 返回 χ2 分布的单尾概率的反函数               |\r\n| CHITEST 函数      | 返回独立性检验值                             |\r\n| CONCATENATE 函数  | 将 2 个或多个文本字符串联接成 1 个字符串     |\r\n| CONFIDENCE 函数   | 返回总体平均值的置信区间                     |\r\n| COVAR 函数        | 返回协方差（成对偏差乘积的平均值）           |\r\n| CRITBINOM 函数    | 返回使累积二项式分布小于或等于临界值的最小值 |\r\n| EXPONDIST 函数    | 返回指数分布                                 |\r\n| FDIST 函数        | 返回 F 概率分布                              |\r\n| FINV 函数         | 返回 F 概率分布的反函数                      |\r\n| FLOOR 函数        | 向绝对值减小的方向舍入数字                   |\r\n| FORECAST 函数     | 使用现有值来计算或预测未来值。               |\r\n| FTEST 函数        | 返回 F 检验的结果                            |\r\n| GAMMADIST 函数    | 返回 γ 分布                                  |\r\n| GAMMAINV 函数     | 返回 γ 累积分布函数的反函数                  |\r\n| HYPGEOMDIST 函数  | 返回超几何分布                               |\r\n| LOGINV 函数       | 返回对数累积分布函数的反函数                 |\r\n| LOGNORMDIST 函数  | 返回对数累积分布函数                         |\r\n| MODE 函数         | 返回在数据集内出现次数最多的值               |\r\n| NEGBINOMDIST 函数 | 返回负二项式分布                             |\r\n| NORMDIST 函数     | 返回正态累积分布                             |\r\n| NORMINV 函数      | 返回正态累积分布的反函数                     |\r\n| NORMSDIST 函数    | 返回标准正态累积分布                         |\r\n| NORMSINV 函数     | 返回标准正态累积分布函数的反函数             |\r\n| PERCENTILE 函数   | 返回区域中数值的第 k 个百分点的值            |\r\n| PERCENTRANK 函数  | 返回数据集中值的百分比排位                   |\r\n| POISSON 函数      | 返回泊松分布                                 |\r\n| QUARTILE 函数     | 返回一组数据的四分位点                       |\r\n| RANK 函数         | 返回一列数字的数字排位                       |\r\n| STDEV 函数        | 基于样本估算标准偏差                         |\r\n| STDEVP 函数       | 基于整个样本总体计算标准偏差                 |\r\n| TDIST 函数        | 返回学生 t-分布                              |\r\n| TINV 函数         | 返回学生 t-分布的反函数                      |\r\n| TTEST 函数        | 返回与学生 t-检验相关的概率                  |\r\n| VAR 函数          | 基于样本估算方差                             |\r\n| VARP 函数         | 计算基于样本总体的方差                       |\r\n| WEIBULL 函数      | 返回 Weibull 分布                            |\r\n| ZTEST 函数        | 返回 z 检验的单尾概率值                      |\r\n\r\n## 多维数据集函数\r\n\r\n## 数据库函数\r\n\r\n| **函数**          | **说明**                                     |\r\n| ----------------- | -------------------------------------------- |\r\n| DAVERAGE 函数 | 返回所选数据库条目的平均值                   |\r\n| DCOUNT 函数   | 计算数据库中包含数字的单元格的数量           |\r\n| DCOUNTA 函数  | 计算数据库中非空单元格的数量                 |\r\n| DGET 函数     | 从数据库提取符合指定条件的单个记录           |\r\n| DMAX 函数     | 返回所选数据库条目的最大值                   |\r\n| DMIN 函数     | 返回所选数据库条目的最小值                   |\r\n| DPRODUCT 函数 | 将数据库中符合条件的记录的特定字段中的值相乘 |\r\n| DSTDEV 函数   | 基于所选数据库条目的样本估算标准偏差         |\r\n| DSTDEVP 函数  | 基于所选数据库条目的样本总体计算标准偏差     |\r\n| DSUM 函数     | 对数据库中符合条件的记录的字段列中的数字求和 |\r\n| DVAR 函数     | 基于所选数据库条目的样本估算方差             |\r\n| DVARP 函数    | 基于所选数据库条目的样本总体计算方差         |\r\n\r\n## 日期和时间函数\r\n\r\n| **函数**                  | **说明**                                                     |\r\n| ------------------------- | ------------------------------------------------------------ |\r\n| DATE 函数             | 返回特定日期的序列号                                         |\r\n| DATEDIF 函数          | 计算两个日期之间的天数、月数或年数。 此函数在用于计算年龄的公式中很有用。 |\r\n| DATEVALUE 函数        | 将文本格式的日期转换为序列号                                 |\r\n| DAY 函数              | 将序列号转换为月份日期                                       |\r\n| DAYS 函数             | 返回两个日期之间的天数                                       |\r\n| DAYS360 函数          | 以一年 360 天为基准计算两个日期间的天数                      |\r\n| EDATE 函数            | 返回用于表示开始日期之前或之后月数的日期的序列号             |\r\n| EOMONTH 函数          | 返回指定月数之前或之后的月份的最后一天的序列号               |\r\n| HOUR 函数             | 将序列号转换为小时                                           |\r\n| ISOWEEKNUM 函数       | 返回给定日期在全年中的 ISO 周数                              |\r\n| MINUTE 函数           | 将序列号转换为分钟                                           |\r\n| MONTH 函数            | 将序列号转换为月                                             |\r\n| NETWORKDAYS 函数      | 返回两个日期间的完整工作日的天数                             |\r\n| NETWORKDAYS.INTL 函数 | 返回两个日期之间的完整工作日的天数（使用参数指明周末有几天并指明是哪几天） |\r\n| NOW 函数              | 返回当前日期和时间的序列号                                   |\r\n| SECOND 函数           | 将序列号转换为秒                                             |\r\n| TIME 函数             | 返回特定时间的序列号                                         |\r\n| TIMEVALUE 函数        | 将文本格式的时间转换为序列号                                 |\r\n| TODAY 函数            | 返回今天日期的序列号                                         |\r\n| WEEKDAY 函数          | 将序列号转换为星期日期                                       |\r\n| WEEKNUM 函数          | 将序列号转换为代表该星期为一年中第几周的数字                 |\r\n| WORKDAY 函数          | 返回指定的若干个工作日之前或之后的日期的序列号               |\r\n| WORKDAY.INTL 函数     | 返回日期在指定的工作日天数之前或之后的序列号（使用参数指明周末有几天并指明是哪几天） |\r\n| YEAR 函数             | 将序列号转换为年                                             |\r\n| YEARFRAC 函数         | 返回代表 start_date 和 end_date 之间整天天数的年分数         |\r\n\r\n## 工程函数\r\n\r\n| **函数**              | **说明**                                 |\r\n| --------------------- | ---------------------------------------- |\r\n| BESSELI 函数      | 返回修正的贝赛耳函数 In(x)               |\r\n| BESSELJ 函数      | 返回贝赛耳函数 Jn(x)                     |\r\n| BESSELK 函数      | 返回修正的贝赛耳函数 Kn(x)               |\r\n| BESSELY 函数      | 返回贝赛耳函数 Yn(x)                     |\r\n| BIN2DEC 函数      | 将二进制数转换为十进制数                 |\r\n| BIN2HEX 函数      | 将二进制数转换为十六进制数               |\r\n| BIN2OCT 函数      | 将二进制数转换为八进制数                 |\r\n| BITAND 函数       | 返回两个数的“按位与”                     |\r\n| BITLSHIFT 函数    | 返回左移 shift_amount 位的计算值接收数   |\r\n| BITOR 函数        | 返回两个数的“按位或”                     |\r\n| BITRSHIFT 函数    | 返回右移 shift_amount 位的计算值接收数   |\r\n| BITXOR 函数       | 返回两个数的按位“异或”                   |\r\n| COMPLEX 函数      | 将实系数和虚系数转换为复数               |\r\n| CONVERT 函数      | 将数字从一种度量系统转换为另一种度量系统 |\r\n| DEC2BIN 函数      | 将十进制数转换为二进制数                 |\r\n| DEC2HEX 函数      | 将十进制数转换为十六进制数               |\r\n| DEC2OCT 函数      | 将十进制数转换为八进制数                 |\r\n| DELTA 函数        | 检验两个值是否相等                       |\r\n| ERF 函数          | 返回误差函数                             |\r\n| ERF.PRECISE 函数  | 返回误差函数                             |\r\n| ERFC 函数         | 返回互补误差函数                         |\r\n| ERFC.PRECISE 函数 | 返回从 x 到无穷大积分的互补 ERF 函数     |\r\n| GESTEP 函数       | 检验数字是否大于阈值                     |\r\n| HEX2BIN 函数      | 将十六进制数转换为二进制数               |\r\n| HEX2DEC 函数      | 将十六进制数转换为十进制数               |\r\n| HEX2OCT 函数      | 将十六进制数转换为八进制数               |\r\n| IMABS 函数        | 返回复数的绝对值（模数）                 |\r\n| IMAGINARY 函数    | 返回复数的虚系数                         |\r\n| IMARGUMENT 函数   | 返回参数 theta，即以弧度表示的角         |\r\n| IMCONJUGATE 函数  | 返回复数的共轭复数                       |\r\n| IMCOS 函数        | 返回复数的余弦                           |\r\n| IMCOSH 函数       | 返回复数的双曲余弦值                     |\r\n| IMCOT 函数        | 返回复数的余弦值                         |\r\n| IMCSC 函数        | 返回复数的余割值                         |\r\n| IMCSCH 函数       | 返回复数的双曲余割值                     |\r\n| IMDIV 函数        | 返回两个复数的商                         |\r\n| IMEXP 函数        | 返回复数的指数                           |\r\n| IMLN 函数         | 返回复数的自然对数                       |\r\n| IMLOG10 函数      | 返回复数的以 10 为底的对数               |\r\n| IMLOG2 函数       | 返回复数的以 2 为底的对数                |\r\n| IMPOWER 函数      | 返回复数的整数幂                         |\r\n| IMPRODUCT 函数    | 返回从 2 到 255 的复数的乘积             |\r\n| IMREAL 函数       | 返回复数的实系数                         |\r\n| IMSEC 函数        | 返回复数的正切值                         |\r\n| IMSECH 函数       | 返回复数的双曲正切值                     |\r\n| IMSIN 函数        | 返回复数的正弦                           |\r\n| IMSINH 函数       | 返回复数的双曲正弦值                     |\r\n| IMSQRT 函数       | 返回复数的平方根                         |\r\n| IMSUB 函数        | 返回两个复数的差                         |\r\n| IMSUM 函数        | 返回多个复数的和                         |\r\n| IMTAN 函数        | 返回复数的正切值                         |\r\n| OCT2BIN 函数      | 将八进制数转换为二进制数                 |\r\n| OCT2DEC 函数      | 将八进制数转换为十进制数                 |\r\n| OCT2HEX 函数      | 将八进制数转换为十六进制数               |\r\n\r\n## 财务函数\r\n\r\n| **函数**            | **说明**                                                     |\r\n| ------------------- | ------------------------------------------------------------ |\r\n| ACCRINT 函数    | 返回定期支付利息的债券的应计利息                             |\r\n| ACCRINTM 函数   | 返回在到期日支付利息的债券的应计利息                         |\r\n| AMORDEGRC 函数  | 使用折旧系数返回每个记帐期的折旧值                           |\r\n| AMORLINC 函数   | 返回每个记帐期的折旧值                                       |\r\n| COUPDAYBS 函数  | 返回从票息期开始到结算日之间的天数                           |\r\n| COUPDAYS 函数   | 返回包含结算日的票息期天数                                   |\r\n| COUPDAYSNC 函数 | 返回从结算日到下一票息支付日之间的天数                       |\r\n| COUPNCD 函数    | 返回结算日之后的下一个票息支付日                             |\r\n| COUPNUM 函数    | 返回结算日与到期日之间可支付的票息数                         |\r\n| COUPPCD 函数    | 返回结算日之前的上一票息支付日                               |\r\n| CUMIPMT 函数    | 返回两个付款期之间累积支付的利息                             |\r\n| CUMPRINC 函数   | 返回两个付款期之间为贷款累积支付的本金                       |\r\n| DB 函数         | 使用固定余额递减法，返回一笔资产在给定期间内的折旧值         |\r\n| DDB 函数        | 使用双倍余额递减法或其他指定方法，返回一笔资产在给定期间内的折旧值 |\r\n| DISC 函数       | 返回债券的贴现率                                             |\r\n| DOLLARDE 函数   | 将以分数表示的价格转换为以小数表示的价格                     |\r\n| DOLLARFR 函数   | 将以小数表示的价格转换为以分数表示的价格                     |\r\n| DURATION 函数   | 返回定期支付利息的债券的每年期限                             |\r\n| EFFECT 函数     | 返回年有效利率                                               |\r\n| FV 函数         | 返回一笔投资的未来值                                         |\r\n| FVSCHEDULE 函数 | 返回应用一系列复利率计算的初始本金的未来值                   |\r\n| INTRATE 函数    | 返回完全投资型债券的利率                                     |\r\n| IPMT 函数       | 返回一笔投资在给定期间内支付的利息                           |\r\n| IRR 函数        | 返回一系列现金流的内部收益率                                 |\r\n| ISPMT 函数      | 计算特定投资期内要支付的利息                                 |\r\n| MDURATION 函数  | 返回假设面值为 ￥100 的有价证券的 Macauley 修正期限          |\r\n| MIRR 函数       | 返回正和负现金流以不同利率进行计算的内部收益率               |\r\n| NOMINAL 函数    | 返回年度的名义利率                                           |\r\n| NPER 函数       | 返回投资的期数                                               |\r\n| NPV 函数        | 返回基于一系列定期的现金流和贴现率计算的投资的净现值         |\r\n| ODDFPRICE 函数  | 返回每张票面为 ￥100 且第一期为奇数的债券的现价              |\r\n| ODDFYIELD 函数  | 返回第一期为奇数的债券的收益                                 |\r\n| ODDLPRICE 函数  | 返回每张票面为 ￥100 且最后一期为奇数的债券的现价            |\r\n| ODDLYIELD 函数  | 返回最后一期为奇数的债券的收益                               |\r\n| PDURATION 函数  | 返回投资到达指定值所需的期数                                 |\r\n| PMT 函数        | 返回年金的定期支付金额                                       |\r\n| PPMT 函数       | 返回一笔投资在给定期间内偿还的本金                           |\r\n| PRICE 函数      | 返回每张票面为 ￥100 且定期支付利息的债券的现价              |\r\n| PRICEDISC 函数  | 返回每张票面为 ￥100 的已贴现债券的现价                      |\r\n| PRICEMAT 函数   | 返回每张票面为 ￥100 且在到期日支付利息的债券的现价          |\r\n| PV 函数         | 返回投资的现值                                               |\r\n| RATE 函数       | 返回年金的各期利率                                           |\r\n| RECEIVED 函数   | 返回完全投资型债券在到期日收回的金额                         |\r\n| RRI 函数        | 返回某项投资增长的等效利率                                   |\r\n| SLN 函数        | 返回固定资产的每期线性折旧费                                 |\r\n| SYD 函数        | 返回某项固定资产按年限总和折旧法计算的每期折旧金额           |\r\n| TBILLEQ 函数    | 返回国库券的等价债券收益                                     |\r\n| TBILLPRICE 函数 | 返回面值 ￥100 的国库券的价格                                |\r\n| TBILLYIELD 函数 | 返回国库券的收益率                                           |\r\n| VDB 函数        | 使用余额递减法，返回一笔资产在给定期间或部分期间内的折旧值   |\r\n| XIRR 函数       | 返回一组现金流的内部收益率，这些现金流不一定定期发生         |\r\n| XNPV 函数       | 返回一组现金流的净现值，这些现金流不一定定期发生             |\r\n| YIELD 函数      | 返回定期支付利息的债券的收益                                 |\r\n| YIELDDISC 函数  | 返回已贴现债券的年收益；例如，短期国库券                     |\r\n| YIELDMAT 函数   | 返回在到期日支付利息的债券的年收益                           |\r\n\r\n## 信息函数\r\n\r\n| **函数**            | **说明**                                                     |\r\n| ------------------- | ------------------------------------------------------------ |\r\n| CELL 函数       | 返回有关单元格格式、位置或内容的信息                         |\r\n| ERROR.TYPE 函数 | 返回对应于错误类型的数字                                     |\r\n| INFO 函数       | 返回有关当前操作环境的信息注意：此函数在 Excel 网页版 中不可用。 |\r\n| ISBLANK 函数    | 如果值为空，则返回 TRUE                                      |\r\n| ISERR 函数      | 如果值为除 #N/A 以外的任何错误值，则返回 TRUE                |\r\n| ISERROR 函数    | 如果值为任何错误值，则返回 TRUE                              |\r\n| ISEVEN 函数     | 如果数字为偶数，则返回 TRUE                                  |\r\n| ISFORMULA 函数  | 如果有对包含公式的单元格的引用，则返回 TRUE                  |\r\n| ISLOGICAL 函数  | 如果值为逻辑值，则返回 TRUE                                  |\r\n| ISNA 函数       | 如果值为错误值 #N/A，则返回 TRUE                             |\r\n| ISNONTEXT 函数  | 如果值不是文本，则返回 TRUE                                  |\r\n| ISNUMBER 函数   | 如果值为数字，则返回 TRUE                                    |\r\n| ISODD 函数      | 如果数字为奇数，则返回 TRUE                                  |\r\n| ISREF 函数      | 如果值为引用值，则返回 TRUE                                  |\r\n| ISTEXT 函数     | 如果值为文本，则返回 TRUE                                    |\r\n| N 函数          | 返回转换为数字的值                                           |\r\n| NA 函数         | 返回错误值 #N/A                                              |\r\n| SHEET 函数      | 返回引用工作表的工作表编号                                   |\r\n| SHEETS 函数     | 返回引用中的工作表数                                         |\r\n| TYPE 函数       | 返回表示值的数据类型的数字                                   |\r\n\r\n## 逻辑函数\r\n\r\n| **函数**         | **说明**                                                     |\r\n| ---------------- | ------------------------------------------------------------ |\r\n| AND 函数     | 如果其所有参数均为 TRUE，则返回 TRUE                         |\r\n| FALSE 函数   | 返回逻辑值 FALSE                                             |\r\n| IF 函数      | 指定要执行的逻辑检测                                         |\r\n| IFERROR 函数 | 如果公式的计算结果错误，则返回您指定的值；否则返回公式的结果 |\r\n| IFNA 函数    | 如果该表达式解析为 #N/A，则返回指定值；否则返回该表达式的结果 |\r\n| IFS 函数     | 检查是否满足一个或多个条件，且是否返回与第一个 TRUE 条件对应的值。 |\r\n| NOT 函数     | 对其参数的逻辑求反                                           |\r\n| OR 函数      | 如果任一参数为 TRUE，则返回 TRUE                             |\r\n| SWITCH 函数  | 根据值列表计算表达式，并返回与第一个匹配值对应的结果。 如果不匹配，则可能返回可选默认值。 |\r\n| TRUE 函数    | 返回逻辑值 TRUE                                              |\r\n| XOR 函数     | 返回所有参数的逻辑“异或”值                                   |\r\n\r\n## 查找和引用函数\r\n\r\n| **函数**              | **说明**                                                     |\r\n| --------------------- | ------------------------------------------------------------ |\r\n| ADDRESS 函数      | 以文本形式将引用值返回到工作表的单个单元格                   |\r\n| AREAS 函数        | 返回引用中涉及的区域个数                                     |\r\n| CHOOSE 函数       | 从值的列表中选择值                                           |\r\n| COLUMN 函数       | 返回引用的列号                                               |\r\n| COLUMNS 函数      | 返回引用中包含的列数                                         |\r\n| FILTER 函数       | FILTER 函数可以基于定义的条件筛选一系列数据。                |\r\n| FORMULATEXT 函数  | 将给定引用的公式返回为文本                                   |\r\n| GETPIVOTDATA 函数 | 返回存储在数据透视表中的数据                                 |\r\n| HLOOKUP 函数      | 查找数组的首行，并返回指定单元格的值                         |\r\n| HYPERLINK 函数    | 创建快捷方式或跳转，以打开存储在网络服务器、Intranet 或 Internet 上的文档 |\r\n| INDEX 函数        | 使用索引从引用或数组中选择值                                 |\r\n| INDIRECT 函数     | 返回由文本值指定的引用                                       |\r\n| LOOKUP 函数       | 在向量或数组中查找值                                         |\r\n| MATCH 函数        | 在引用或数组中查找值                                         |\r\n| OFFSET 函数       | 从给定引用中返回引用偏移量                                   |\r\n| ROW 函数          | 返回引用的行号                                               |\r\n| ROWS 函数         | 返回引用中的行数                                             |\r\n| RTD 函数          | 从支持 COM 自动化的程序中检索实时数据                        |\r\n| SORT 函数         | 对区域或数组的内容进行排序                                   |\r\n| SORTBY 函数       | 根据相应区域或数组中的值对区域或数组的内容进行排序           |\r\n| TRANSPOSE 函数    | 返回数组的转置                                               |\r\n| UNIQUE 函数       | 返回列表或区域的唯一值列表                                   |\r\n| VLOOKUP 函数      | 在数组第一列中查找，然后在行之间移动以返回单元格的值         |\r\n| XLOOKUP 函数      | 搜索区域或数组，并返回与之找到的第一个匹配项对应的项。 如果不存在匹配项，则 XLOOKUP 可返回最接近（近似值）的匹配项。 |\r\n| XMATCH 函数       | 返回项目在数组或单元格区域中的相对位置。                     |\r\n\r\n## 数学和三角函数\r\n\r\n| **函数**                 | **说明**                                                     |\r\n| ------------------------ | ------------------------------------------------------------ |\r\n| ABS 函数             | 返回数字的绝对值                                             |\r\n| ACOS 函数            | 返回数字的反余弦值                                           |\r\n| ACOSH 函数           | 返回数字的反双曲余弦值                                       |\r\n| ACOT 函数            | 返回一个数的反余切值                                         |\r\n| ACOTH 函数           | 返回一个数的双曲反余切值                                     |\r\n| AGGREGATE 函数       | 返回列表或数据库中的聚合                                     |\r\n| ARABIC 函数          | 将罗马数字转换为阿拉伯数字                                   |\r\n| ASIN 函数            | 返回数字的反正弦值                                           |\r\n| ASINH 函数           | 返回数字的反双曲正弦值                                       |\r\n| ATAN 函数            | 返回数字的反正切值                                           |\r\n| ATAN2 函数           | 返回 X 和 Y 坐标的反正切值                                   |\r\n| ATANH 函数           | 返回数字的反双曲正切值                                       |\r\n| BASE 函数            | 将一个数转换为具有给定基数的文本表示                         |\r\n| CEILING 函数         | 将数字舍入为最接近的整数或最接近的指定基数的倍数             |\r\n| CEILING.MATH 函数    | 将数字向上舍入为最接近的整数或最接近的指定基数的倍数         |\r\n| CEILING.PRECISE 函数 | 将数字舍入为最接近的整数或最接近的指定基数的倍数。 无论该数字的符号如何，该数字都向上舍入。 |\r\n| COMBIN 函数          | 返回给定数目对象的组合数                                     |\r\n| COMBINA 函数         | 返回给定数目对象具有重复项的组合数                           |\r\n| COS 函数             | 返回数字的余弦值                                             |\r\n| COSH 函数            | 返回数字的双曲余弦值                                         |\r\n| COT 函数             | 返回角度的余弦值                                             |\r\n| COTH 函数            | 返回数字的双曲余切值                                         |\r\n| CSC 函数             | 返回角度的余割值                                             |\r\n| CSCH 函数            | 返回角度的双曲余割值                                         |\r\n| DECIMAL 函数         | 将给定基数内的数的文本表示转换为十进制数                     |\r\n| DEGREES 函数         | 将弧度转换为度                                               |\r\n| EVEN 函数            | 将数字向上舍入到最接近的偶数                                 |\r\n| EXP 函数             | 返回 *e* 的 n 次方                                           |\r\n| FACT 函数            | 返回数字的阶乘                                               |\r\n| FACTDOUBLE 函数      | 返回数字的双倍阶乘                                           |\r\n| FLOOR 函数           | 向绝对值减小的方向舍入数字                                   |\r\n| FLOOR.MATH 函数      | 将数字向下舍入为最接近的整数或最接近的指定基数的倍数         |\r\n| FLOOR.PRECISE 函数   | 将数字向下舍入为最接近的整数或最接近的指定基数的倍数。 无论该数字的符号如何，该数字都向下舍入。 |\r\n| GCD 函数             | 返回最大公约数                                               |\r\n| INT 函数             | 将数字向下舍入到最接近的整数                                 |\r\n| ISO.CEILING 函数     | 返回一个数字，该数字向上舍入为最接近的整数或最接近的有效位的倍数 |\r\n| LCM 函数             | 返回最小公倍数                                               |\r\n| LET 函数             | 将名称分配给计算结果，以允许将中间计算、值或定义名称存储在公式内 |\r\n| LN 函数              | 返回数字的自然对数                                           |\r\n| LOG 函数             | 返回数字的以指定底为底的对数                                 |\r\n| LOG10 函数           | 返回数字的以 10 为底的对数                                   |\r\n| MDETERM 函数         | 返回数组的矩阵行列式的值                                     |\r\n| MINVERSE 函数        | 返回数组的逆矩阵                                             |\r\n| MMULT 函数           | 返回两个数组的矩阵乘积                                       |\r\n| MOD 函数             | 返回除法的余数                                               |\r\n| MROUND 函数          | 返回一个舍入到所需倍数的数字                                 |\r\n| MULTINOMIAL 函数     | 返回一组数字的多项式                                         |\r\n| MUNIT 函数           | 返回单位矩阵或指定维度                                       |\r\n| ODD 函数             | 将数字向上舍入为最接近的奇数                                 |\r\n| PI 函数              | 返回 pi 的值                                                 |\r\n| POWER 函数           | 返回数的乘幂                                                 |\r\n| PRODUCT 函数         | 将其参数相乘                                                 |\r\n| QUOTIENT 函数        | 返回除法的整数部分                                           |\r\n| RADIANS 函数         | 将度转换为弧度                                               |\r\n| RAND 函数            | 返回 0 和 1 之间的一个随机数                                 |\r\n| RANDARRAY 函数       | RANDARRAY 函数返回 0 和 1 之间的随机数字数组。 但是，你可以指定要填充的行数和列数、最小值和最大值，以及是否返回整个数字或小数值。 |\r\n| RANDBETWEEN 函数     | 返回位于两个指定数之间的一个随机数                           |\r\n| ROMAN 函数           | 将阿拉伯数字转换为文本式罗马数字                             |\r\n| ROUND 函数           | 将数字按指定位数舍入                                         |\r\n| ROUNDDOWN 函数       | 向绝对值减小的方向舍入数字                                   |\r\n| ROUNDUP 函数         | 向绝对值增大的方向舍入数字                                   |\r\n| SEC 函数             | 返回角度的正割值                                             |\r\n| SECH 函数            | 返回角度的双曲正切值                                         |\r\n| SERIESSUM 函数       | 返回基于公式的幂级数的和                                     |\r\n| SEQUENCE 函数        | SEQUENCE 函数可在数组中生成一系列连续数字，例如，1、2、3、4。 |\r\n| SIGN 函数            | 返回数字的符号                                               |\r\n| SIN 函数             | 返回给定角度的正弦值                                         |\r\n| SINH 函数            | 返回数字的双曲正弦值                                         |\r\n| SQRT 函数            | 返回正平方根                                                 |\r\n| SQRTPI 函数          | 返回某数与 pi 的乘积的平方根                                 |\r\n| SUBTOTAL 函数        | 返回列表或数据库中的分类汇总                                 |\r\n| SUM 函数             | 求参数的和                                                   |\r\n| SUMIF 函数           | 按给定条件对指定单元格求和                                   |\r\n| SUMIFS 函数          | 在区域中添加满足多个条件的单元格                             |\r\n| SUMPRODUCT 函数      | 返回对应的数组元素的乘积和                                   |\r\n| SUMSQ 函数           | 返回参数的平方和                                             |\r\n| SUMX2MY2 函数        | 返回两数组中对应值平方差之和                                 |\r\n| SUMX2PY2 函数        | 返回两数组中对应值的平方和之和                               |\r\n| SUMXMY2 函数         | 返回两个数组中对应值差的平方和                               |\r\n| TAN 函数             | 返回数字的正切值                                             |\r\n| TANH 函数            | 返回数字的双曲正切值                                         |\r\n| TRUNC 函数           | 将数字截尾取整                                               |\r\n\r\n## 统计函数\r\n\r\n| **函数**                          | **说明**                                                     |\r\n| --------------------------------- | ------------------------------------------------------------ |\r\n| AVEDEV 函数                   | 返回数据点与它们的平均值的绝对偏差平均值                     |\r\n| AVERAGE 函数                  | 返回其参数的平均值                                           |\r\n| AVERAGEA 函数                 | 返回其参数的平均值，包括数字、文本和逻辑值                   |\r\n| AVERAGEIF 函数                | 返回区域中满足给定条件的所有单元格的平均值（算术平均值）     |\r\n| AVERAGEIFS 函数               | 返回满足多个条件的所有单元格的平均值（算术平均值）           |\r\n| BETA.DIST 函数                | 返回 beta 累积分布函数                                       |\r\n| BETA.INV 函数                 | 返回指定 beta 分布的累积分布函数的反函数                     |\r\n| BINOM.DIST 函数               | 返回一元二项式分布的概率                                     |\r\n| BINOM.DIST.RANGE 函数         | 使用二项式分布返回试验结果的概率                             |\r\n| BINOM.INV 函数                | 返回使累积二项式分布小于或等于临界值的最小值                 |\r\n| CHISQ.DIST 函数               | 返回累积 beta 概率密度函数                                   |\r\n| CHISQ.DIST.RT 函数            | 返回 χ2 分布的单尾概率                                       |\r\n| CHISQ.INV 函数                | 返回累积 beta 概率密度函数                                   |\r\n| CHISQ.INV.RT 函数             | 返回 χ2 分布的单尾概率的反函数                               |\r\n| CHISQ.TEST 函数               | 返回独立性检验值                                             |\r\n| CONFIDENCE.NORM 函数          | 返回总体平均值的置信区间                                     |\r\n| CONFIDENCE.T 函数             | 返回总体平均值的置信区间（使用学生 t-分布）                  |\r\n| CORREL 函数                   | 返回两个数据集之间的相关系数                                 |\r\n| COUNT 函数                    | 计算参数列表中数字的个数                                     |\r\n| COUNTA 函数                   | 计算参数列表中值的个数                                       |\r\n| COUNTBLANK 函数               | 计算区域内空白单元格的数量                                   |\r\n| COUNTIF 函数                  | 计算区域内符合给定条件的单元格的数量                         |\r\n| COUNTIFS 函数                 | 计算区域内符合多个条件的单元格的数量                         |\r\n| COVARIANCE.P 函数             | 返回协方差（成对偏差乘积的平均值）                           |\r\n| COVARIANCE.S 函数             | 返回样本协方差，即两个数据集中每对数据点的偏差乘积的平均值   |\r\n| DEVSQ 函数                    | 返回偏差的平方和                                             |\r\n| EXPON.DIST 函数               | 返回指数分布                                                 |\r\n| F.DIST 函数                   | 返回 F 概率分布                                              |\r\n| F.DIST.RT 函数                | 返回 F 概率分布                                              |\r\n| F.INV 函数                    | 返回 F 概率分布的反函数                                      |\r\n| F.INV.RT 函数                 | 返回 F 概率分布的反函数                                      |\r\n| F.TEST 函数                   | 返回 F 检验的结果                                            |\r\n| FISHER 函数                   | 返回 Fisher 变换值                                           |\r\n| FISHERINV 函数                | 返回 Fisher 变换的反函数                                     |\r\n| FORECAST 函数]()                 | 返回线性趋势值注意：在 Excel 2016 中，此函数替换为 [FORECAST。LINEAR]() 是新预测 [函数的一部分，但仍可用于与早期版本兼容。 |\r\n| FORECAST.ETS 函数             | 通过使用指数平滑 (ETS) 算法的 AAA 版本，返回基于现有（历史）值的未来值 |\r\n| FORECAST.ETS.CONFINT 函数     | 返回指定目标日期预测值的置信区间                             |\r\n| FORECAST.ETS.SEASONALITY 函数 | 返回 Excel 针对指定时间系列检测到的重复模式的长度            |\r\n| FORECAST.ETS.STAT 函数        | 返回作为时间序列预测的结果的统计值。                         |\r\n| FORECAST.LINEAR 函数          | 返回基于现有值的未来值                                       |\r\n| FREQUENCY 函数                | 以垂直数组的形式返回频率分布                                 |\r\n| GAMMA 函数                    | 返回 γ 函数值                                                |\r\n| GAMMA.DIST 函数               | 返回 γ 分布                                                  |\r\n| GAMMA.INV 函数                | 返回 γ 累积分布函数的反函数                                  |\r\n| GAMMALN 函数                  | 返回 γ 函数的自然对数，Γ(x)                                  |\r\n| GAMMALN.PRECISE 函数          | 返回 γ 函数的自然对数，Γ(x)                                  |\r\n| GAUSS 函数                    | 返回小于标准正态累积分布 0.5 的值                            |\r\n| GEOMEAN 函数                  | 返回几何平均值                                               |\r\n| GROWTH 函数                   | 返回指数趋势值                                               |\r\n| HARMEAN 函数                  | 返回调和平均值                                               |\r\n| HYPGEOM.DIST 函数             | 返回超几何分布                                               |\r\n| INTERCEPT 函数                | 返回线性回归线的截距                                         |\r\n| KURT 函数                     | 返回数据集的峰值                                             |\r\n| LARGE 函数                    | 返回数据集中第 k 个最大值                                    |\r\n| LINEST 函数                   | 返回线性趋势的参数                                           |\r\n| LOGEST 函数                   | 返回指数趋势的参数                                           |\r\n| LOGNORM.DIST 函数             | 返回对数累积分布函数                                         |\r\n| LOGNORM.INV 函数              | 返回对数累积分布的反函数                                     |\r\n| MAX 函数                      | 返回参数列表中的最大值                                       |\r\n| MAXA 函数                     | 返回参数列表中的最大值，包括数字、文本和逻辑值               |\r\n| MAXIFS 函数                   | 返回一组给定条件或标准指定的单元格之间的最大值               |\r\n| MEDIAN 函数                   | 返回给定数值集合的中值                                       |\r\n| MIN 函数                      | 返回参数列表中的最小值                                       |\r\n| MINA 函数                     | 返回参数列表中的最小值，包括数字、文本和逻辑值               |\r\n| MINIFS 函数                   | 返回一组给定条件或标准指定的单元格之间的最小值。             |\r\n| MODE.MULT 函数                | 返回一组数据或数据区域中出现频率最高或重复出现的数值的垂直数组 |\r\n| MODE.SNGL 函数                | 返回在数据集内出现次数最多的值                               |\r\n| NEGBINOM.DIST 函数            | 返回负二项式分布                                             |\r\n| NORM.DIST 函数                | 返回正态累积分布                                             |\r\n| NORM.INV 函数                 | 返回正态累积分布的反函数                                     |\r\n| NORM.S.DIST 函数              | 返回标准正态累积分布                                         |\r\n| NORM.S.INV 函数               | 返回标准正态累积分布函数的反函数                             |\r\n| PEARSON 函数                  | 返回 Pearson 乘积矩相关系数                                  |\r\n| PERCENTILE.EXC 函数           | 返回某个区域中的数值的第 k 个百分点值，此处的 k 的范围为 0 到 1（不含 0 和 1） |\r\n| PERCENTILE.INC 函数           | 返回区域中数值的第 k 个百分点的值                            |\r\n| PERCENTRANK.EXC 函数          | 将某个数值在数据集中的排位作为数据集的百分点值返回，此处的百分点值的范围为 0 到 1（不含 0 和 1） |\r\n| PERCENTRANK.INC 函数          | 返回数据集中值的百分比排位                                   |\r\n| PERMUT 函数                   | 返回给定数目对象的排列数                                     |\r\n| PERMUTATIONA 函数             | 返回可从总计对象中选择的给定数目对象（含重复）的排列数       |\r\n| PHI 函数                      | 返回标准正态分布的密度函数值                                 |\r\n| POISSON.DIST 函数             | 返回泊松分布                                                 |\r\n| PROB 函数                     | 返回区域中的数值落在指定区间内的概率                         |\r\n| QUARTILE.EXC 函数             | 基于百分点值返回数据集的四分位，此处的百分点值的范围为 0 到 1（不含 0 和 1） |\r\n| QUARTILE.INC 函数             | 返回一组数据的四分位点                                       |\r\n| RANK.AVG 函数                 | 返回一列数字的数字排位                                       |\r\n| RANK.EQ 函数                  | 返回一列数字的数字排位                                       |\r\n| RSQ 函数                      | 返回 Pearson 乘积矩相关系数的平方                            |\r\n| SKEW 函数                     | 返回分布的不对称度                                           |\r\n| SKEW.P 函数                   | 返回一个分布的不对称度：用来体现某一分布相对其平均值的不对称程度 |\r\n| SLOPE 函数                    | 返回线性回归线的斜率                                         |\r\n| SMALL 函数                    | 返回数据集中的第 k 个最小值                                  |\r\n| STANDARDIZE 函数              | 返回正态化数值                                               |\r\n| STDEV.P 函数                  | 基于整个样本总体计算标准偏差                                 |\r\n| STDEV.S 函数                  | 基于样本估算标准偏差                                         |\r\n| STDEVA 函数                   | 基于样本（包括数字、文本和逻辑值）估算标准偏差               |\r\n| STDEVPA 函数                  | 基于样本总体（包括数字、文本和逻辑值）计算标准偏差           |\r\n| STEYX 函数                    | 返回通过线性回归法预测每个 x 的 y 值时所产生的标准误差       |\r\n| T.DIST 函数                   | 返回学生 t-分布的百分点（概率）                              |\r\n| T.DIST.2T 函数                | 返回学生 t-分布的百分点（概率）                              |\r\n| T.DIST.RT 函数                | 返回学生 t-分布                                              |\r\n| T.INV 函数                    | 返回作为概率和自由度函数的学生 t 分布的 t 值                 |\r\n| T.INV.2T 函数                 | 返回学生 t-分布的反函数                                      |\r\n| T.TEST 函数                   | 返回与学生 t-检验相关的概率                                  |\r\n| TREND 函数                    | 返回线性趋势值                                               |\r\n| TRIMMEAN 函数                 | 返回数据集的内部平均值                                       |\r\n| VAR.P 函数                    | 计算基于样本总体的方差                                       |\r\n| VAR.S 函数                    | 基于样本估算方差                                             |\r\n| VARA 函数                     | 基于样本（包括数字、文本和逻辑值）估算方差                   |\r\n| VARPA 函数                    | 基于样本总体（包括数字、文本和逻辑值）计算标准偏差           |\r\n| WEIBULL.DIST 函数             | 返回 Weibull 分布                                            |\r\n| Z.TEST 函数                   | 返回 z 检验的单尾概率值                                      |\r\n\r\n## 文本函数\r\n\r\n| **函数**                   | **说明**                                                     |\r\n| -------------------------- | ------------------------------------------------------------ |\r\n| ASC 函数               | 将字符串中的全角（双字节）英文字母或片假名更改为半角（单字节）字符 |\r\n| ARRAYTOTEXT 函数       | ARRAYTOTEXT 函数返回任意指定区域内的文本值的数组。           |\r\n| BAHTTEXT 函数          | 使用 ß（泰铢）货币格式将数字转换为文本                       |\r\n| CHAR 函数              | 返回由代码数字指定的字符                                     |\r\n| CLEAN 函数             | 删除文本中所有非打印字符                                     |\r\n| CODE 函数              | 返回文本字符串中第一个字符的数字代码                         |\r\n| CONCAT 函数            | 将多个区域和/或字符串的文本组合起来，但不提供分隔符或 IgnoreEmpty 参数。 |\r\n| CONCATENATE 函数       | 将几个文本项合并为一个文本项                                 |\r\n| DBCS 函数              | 将字符串中的半角（单字节）英文字母或片假名更改为全角（双字节）字符 |\r\n| DOLLAR 函数            | 使用 ￥（人民币）货币格式将数字转换为文本                    |\r\n| EXACT 函数             | 检查两个文本值是否相同                                       |\r\n| FIND、FINDB 函数       | 在一个文本值中查找另一个文本值（区分大小写）                 |\r\n| FIXED 函数             | 将数字格式设置为具有固定小数位数的文本                       |\r\n| LEFT、LEFTB 函数       | 返回文本值中最左边的字符                                     |\r\n| LEN、LENB 函数         | 返回文本字符串中的字符个数                                   |\r\n| LOWER 函数             | 将文本转换为小写                                             |\r\n| MID、MIDB 函数         | 从文本字符串中的指定位置起返回特定个数的字符                 |\r\n| NUMBERVALUE 函数       | 以与区域设置无关的方式将文本转换为数字                       |\r\n| PHONETIC 函数          | 提取文本字符串中的拼音（汉字注音）字符                       |\r\n| PROPER 函数            | 将文本值的每个字的首字母大写                                 |\r\n| REPLACE、REPLACEB 函数 | 替换文本中的字符                                             |\r\n| REPT 函数              | 按给定次数重复文本                                           |\r\n| RIGHT、RIGHTB 函数     | 返回文本值中最右边的字符                                     |\r\n| SEARCH、SEARCHB 函数   | 在一个文本值中查找另一个文本值（不区分大小写）               |\r\n| SUBSTITUTE 函数        | 在文本字符串中用新文本替换旧文本                             |\r\n| T 函数                 | 将参数转换为文本                                             |\r\n| TEXT 函数              | 设置数字格式并将其转换为文本                                 |\r\n| TEXTJOIN 函数          | 将多个区域和/或字符串的文本组合起来，并包括你在要组合的各文本值之间指定的分隔符。 如果分隔符是空的文本字符串，则此函数将有效连接这些区域。 |\r\n| TRIM 函数              | 删除文本中的空格                                             |\r\n| UNICHAR 函数           | 返回给定数值引用的 Unicode 字符                              |\r\n| UNICODE 函数           | 返回对应于文本的第一个字符的数字（代码点）                   |\r\n| UPPER 函数             | 将文本转换为大写形式                                         |\r\n| VALUE 函数             | 将文本参数转换为数字                                         |\r\n| VALUETOTEXT 函数       | 从任意指定值返回文本                                         |\r\n\r\n## 与加载项一起安装的用户定义的函数\r\n\r\n如果您安装的加载项包含函数，这些加载项或自动化函数将在**“插入函数”**对话框中的**“用户定义的”**类别中可用。\r\n\r\nUDF (用户) 函数在 Excel 网页版 中#x0。\r\n\r\n| **函数**             | **说明**                                                     |\r\n| -------------------- | ------------------------------------------------------------ |\r\n| CALL 函数        | 调用动态链接库或代码源中的过程                               |\r\n| EUROCONVERT 函数 | 用于将数字转换为欧元形式，将数字由欧元形式转换为欧元成员国货币形式，或利用欧元作为中间货币将数字由某一欧元成员国货币转化为另一欧元成员国货币形式（三角转换关系） |\r\n| REGISTER.ID 函数 | 返回已注册过的指定动态链接库 (DLL) 或代码源的注册号          |\r\n\r\n## Web 函数\r\n\r\nWeb 函数在 Excel 网页版 中不可用。\r\n\r\n| **函数**            | **说明**                                        |\r\n| ------------------- | ----------------------------------------------- |\r\n| ENCODEURL 函数  | 返回 URL 编码的字符串                           |\r\n| FILTERXML 函数  | 通过使用指定的 XPath，返回 XML 内容中的特定数据 |\r\n| WEBSERVICE 函数 | 返回 Web 服务中的数据。                         |\r\n\r\n版本标记表示介绍函数的 Excel 版本。 这些函数在早期版本中不可用。\r\n\r\n**重要:** 公式和某些 Excel 工作表函数的计算结果在采用 x86 或 x86-64 架构的 Windows PC 与采用 ARM 架构的 Windows RT PC 之间略有不同。"},fdf5:function(n,r,e){"use strict";e.r(r),r["default"]='\n\x3c!-- MarkdownTOC --\x3e\n\n- [Shell 编程入门](#shell-编程入门)\n  - [走进 Shell 编程的大门](#走进-shell-编程的大门)\n    - [为什么要学Shell？](#为什么要学shell)\n    - [什么是 Shell？](#什么是-shell)\n    - [Shell 编程的 Hello World](#shell-编程的-hello-world)\n  - [Shell 变量](#shell-变量)\n    - [Shell 编程中的变量介绍](#shell-编程中的变量介绍)\n    - [Shell 字符串入门](#shell-字符串入门)\n    - [Shell 字符串常见操作](#shell-字符串常见操作)\n    - [Shell 数组](#shell-数组)\n  - [Shell 基本运算符](#shell-基本运算符)\n    - [算数运算符](#算数运算符)\n    - [关系运算符](#关系运算符)\n    - [逻辑运算符](#逻辑运算符)\n    - [布尔运算符](#布尔运算符)\n    - [字符串运算符](#字符串运算符)\n    - [文件相关运算符](#文件相关运算符)\n  - [shell流程控制](#shell流程控制)\n    - [if 条件语句](#if-条件语句)\n    - [for 循环语句](#for-循环语句)\n    - [while 语句](#while-语句)\n  - [shell 函数](#shell-函数)\n    - [不带参数没有返回值的函数](#不带参数没有返回值的函数)\n    - [有返回值的函数](#有返回值的函数)\n    - [带参数的函数](#带参数的函数)\n\n\x3c!-- /MarkdownTOC --\x3e\n\n# Shell 编程入门\n\n## 走进 Shell 编程的大门\n\n### 为什么要学Shell？\n\n学一个东西，我们大部分情况都是往实用性方向着想。从工作角度来讲，学习 Shell 是为了提高我们自己工作效率，提高产出，让我们在更少的时间完成更多的事情。\n\n很多人会说 Shell 编程属于运维方面的知识了，应该是运维人员来做，我们做后端开发的没必要学。我觉得这种说法大错特错，相比于专门做Linux运维的人员来说，我们对 Shell 编程掌握程度的要求要比他们低，但是shell编程也是我们必须要掌握的！\n\n目前Linux系统下最流行的运维自动化语言就是Shell和Python了。\n\n两者之间，Shell几乎是IT企业必须使用的运维自动化编程语言，特别是在运维工作中的服务监控、业务快速部署、服务启动停止、数据备份及处理、日志分析等环节里，shell是不可缺的。Python 更适合处理复杂的业务逻辑，以及开发复杂的运维软件工具，实现通过web访问等。Shell是一个命令解释器，解释执行用户所输入的命令和程序。一输入命令，就立即回应的交互的对话方式。\n\n另外，了解 shell 编程也是大部分互联网公司招聘后端开发人员的要求。下图是我截取的一些知名互联网公司对于 Shell 编程的要求。\n\n![大型互联网公司对于shell编程技能的要求](Shell.assets/60190220.jpg)\n\n### 什么是 Shell？\n\n简单来说“Shell编程就是对一堆Linux命令的逻辑化处理”。\n\nW3Cschool 上的一篇文章是这样介绍 Shell的，如下图所示。\n![什么是 Shell？](Shell.assets/19456505.jpg)\n\n\n### Shell 编程的 Hello World\n\n学习任何一门编程语言第一件事就是输出HelloWorld了！下面我会从新建文件到shell代码编写来说下Shell 编程如何输出Hello World。\n\n\n(1)新建一个文件 helloworld.sh :`touch helloworld.sh`，扩展名为 sh（sh代表Shell）（扩展名并不影响脚本执行，见名知意就好，如果你用 php 写 shell 脚本，扩展名就用 php 好了）\n\n(2) 使脚本具有执行权限：`chmod +x helloworld.sh`\n\n(3) 使用 vim 命令修改helloworld.sh文件：`vim helloworld.sh`(vim 文件------\x3e进入文件-----\x3e命令模式------\x3e按i进入编辑模式-----\x3e编辑文件 -------\x3e按Esc进入底行模式-----\x3e输入:wq/q! （输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。）)\n\nhelloworld.sh 内容如下：\n\n```shell\n#!/bin/bash\n#第一个shell小程序,echo 是linux中的输出命令。\necho  "helloworld!"\n```\n\nshell中 # 符号表示注释。**shell 的第一行比较特殊，一般都会以#!开始来指定使用的 shell 类型。在linux中，除了bash shell以外，还有很多版本的shell， 例如zsh、dash等等...不过bash shell还是我们使用最多的。**\n\n\n(4) 运行脚本:`./helloworld.sh` 。（注意，一定要写成 `./helloworld.sh` ，而不是 `helloworld.sh` ，运行其它二进制的程序也一样，直接写 `helloworld.sh` ，linux 系统会去 PATH 里寻找有没有叫 helloworld.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 `helloworld.sh` 是会找不到命令的，要用`./helloworld.sh` 告诉系统说，就在当前目录找。）\n\n![shell 编程Hello World](Shell.assets/55296212.jpg)\n\n\n## Shell 变量\n\n### Shell 编程中的变量介绍\n\n\n**Shell编程中一般分为三种变量：**\n\n1. **我们自己定义的变量（自定义变量）:** 仅在当前 Shell 实例中有效，其他 Shell 启动的程序不能访问局部变量。\n2. **Linux已定义的环境变量**（环境变量， 例如：`PATH`, ​`HOME` 等..., 这类变量我们可以直接使用），使用 `env` 命令可以查看所有的环境变量，而set命令既可以查看环境变量也可以查看自定义变量。\n3. **Shell变量** ：Shell变量是由 Shell 程序设置的特殊变量。Shell 变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了 Shell 的正常运行\n\n**常用的环境变量:**\n> PATH 决定了shell将到哪些目录中寻找命令或程序  \nHOME 当前用户主目录  \nHISTSIZE　历史记录数  \nLOGNAME 当前用户的登录名  \nHOSTNAME　指主机的名称  \nSHELL 当前用户Shell类型  \nLANGUAGE 　语言相关的环境变量，多语言可以修改此环境变量  \nMAIL　当前用户的邮件存放目录  \nPS1　基本提示符，对于root用户是#，对于普通用户是$\n\n**使用 Linux 已定义的环境变量：**\n\n比如我们要看当前用户目录可以使用：`echo $HOME`命令；如果我们要看当前用户Shell类型 可以使用`echo $SHELL`命令。可以看出，使用方法非常简单。\n\n**使用自己定义的变量：**\n\n```shell\n#!/bin/bash\n#自定义变量hello\nhello="hello world"\necho $hello\necho  "helloworld!"\n```\n![使用自己定义的变量](Shell.assets/19835037.jpg)\n\n\n**Shell 编程中的变量名的命名的注意事项：**\n\n\n- 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头，但是可以使用下划线（_）开头。\n- 中间不能有空格，可以使用下划线（_）。\n- 不能使用标点符号。\n- 不能使用bash里的关键字（可用help命令查看保留关键字）。\n\n\n### Shell 字符串入门\n\n字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号。这点和Java中有所不同。\n\n**单引号字符串：**\n\n```shell\n#!/bin/bash\nname=\'SnailClimb\'\nhello=\'Hello, I  am \'$name\'!\'\necho $hello\n```\n输出内容：\n\n```\nHello, I am SnailClimb!\n```\n\n**双引号字符串：**\n\n```shell\n#!/bin/bash\nname=\'SnailClimb\'\nhello="Hello, I  am "$name"!"\necho $hello\n```\n\n输出内容：\n\n```\nHello, I am SnailClimb!\n```\n\n\n### Shell 字符串常见操作\n\n**拼接字符串：**\n\n```shell\n#!/bin/bash\nname="SnailClimb"\n# 使用双引号拼接\ngreeting="hello, "$name" !"\ngreeting_1="hello, ${name} !"\necho $greeting  $greeting_1\n# 使用单引号拼接\ngreeting_2=\'hello, \'$name\' !\'\ngreeting_3=\'hello, ${name} !\'\necho $greeting_2  $greeting_3\n```\n\n输出结果：\n\n![输出结果](Shell.assets/51148933.jpg)\n\n\n**获取字符串长度：**\n\n```shell\n#!/bin/bash\n#获取字符串长度\nname="SnailClimb"\n# 第一种方式\necho ${#name} #输出 10\n# 第二种方式\nexpr length "$name";\n```\n\n输出结果:\n```\n10\n10\n```\n\n使用 expr 命令时，表达式中的运算符左右必须包含空格，如果不包含空格，将会输出表达式本身:\n\n```shell\nexpr 5+6    // 直接输出 5+6\nexpr 5 + 6       // 输出 11\n```\n对于某些运算符，还需要我们使用符号`\\`进行转义，否则就会提示语法错误。\n\n```shell\nexpr 5 * 6       // 输出错误\nexpr 5 \\* 6      // 输出30\n```\n\n**截取子字符串:**\n\n简单的字符串截取：\n\n\n```shell\n#从字符串第 1 个字符开始往后截取 10 个字符\nstr="SnailClimb is a great man"\necho ${str:0:10} #输出:SnailClimb\n```\n\n根据表达式截取：\n\n```shell\n#!bin/bash\n#author:amau\n\nvar="https://www.runoob.com/linux/linux-shell-variable.html"\n# %表示删除从后匹配, 最短结果\n# %%表示删除从后匹配, 最长匹配结果\n# #表示删除从头匹配, 最短结果\n# ##表示删除从头匹配, 最长匹配结果\n# 注: *为通配符, 意为匹配任意数量的任意字符\ns1=${var%%t*} #h\ns2=${var%t*}  #https://www.runoob.com/linux/linux-shell-variable.h\ns3=${var%%.*} #http://www\ns4=${var#*/}  #/www.runoob.com/linux/linux-shell-variable.html\ns5=${var##*/} #linux-shell-variable.html\n```\n\n### Shell 数组\n\nbash支持一维数组（不支持多维数组），并且没有限定数组的大小。我下面给了大家一个关于数组操作的 Shell 代码示例，通过该示例大家可以知道如何创建数组、获取数组长度、获取/删除特定位置的数组元素、删除整个数组以及遍历数组。\n\n\n```shell\n#!/bin/bash\narray=(1 2 3 4 5);\n# 获取数组长度\nlength=${#array[@]}\n# 或者\nlength2=${#array[*]}\n#输出数组长度\necho $length #输出：5\necho $length2 #输出：5\n# 输出数组第三个元素\necho ${array[2]} #输出：3\nunset array[1]# 删除下标为1的元素也就是删除第二个元素\nfor i in ${array[@]};do echo $i ;done # 遍历数组，输出： 1 3 4 5 \nunset array; # 删除数组中的所有元素\nfor i in ${array[@]};do echo $i ;done # 遍历数组，数组元素为空，没有任何输出内容\n```\n\n\n## Shell 基本运算符\n\n> 说明：图片来自《菜鸟教程》\n\n Shell 编程支持下面几种运算符\n\n- 算数运算符\n- 关系运算符\n- 布尔运算符\n- 字符串运算符\n- 文件测试运算符\n\n### 算数运算符\n\n![算数运算符](Shell.assets/4937342.jpg)\n\n我以加法运算符做一个简单的示例（注意：不是单引号，是反引号）：\n\n```shell\n#!/bin/bash\na=3;b=3;\nval=`expr $a + $b`\n#输出：Total value : 6\necho "Total value : $val"\n```\n\n\n### 关系运算符\n\n关系运算符只支持数字，不支持字符串，除非字符串的值是数字。\n\n![shell关系运算符](Shell.assets/64391380.jpg)\n\n通过一个简单的示例演示关系运算符的使用，下面shell程序的作用是当score=100的时候输出A否则输出B。\n\n```shell\n#!/bin/bash\nscore=90;\nmaxscore=100;\nif [ $score -eq $maxscore ]\nthen\n   echo "A"\nelse\n   echo "B"\nfi\n```\n\n输出结果：\n\n```\nB\n```\n\n### 逻辑运算符\n\n![逻辑运算符](Shell.assets/60545848.jpg)\n\n示例：\n\n```shell\n#!/bin/bash\na=$(( 1 && 0))\n# 输出：0；逻辑与运算只有相与的两边都是1，与的结果才是1；否则与的结果是0\necho $a;\n```\n\n### 布尔运算符\n\n\n![布尔运算符](Shell.assets/93961425.jpg)\n\n这里就不做演示了，应该挺简单的。\n\n### 字符串运算符\n\n![ 字符串运算符](Shell.assets/309094.jpg)\n\n简单示例：\n\n```shell\n#!/bin/bash\na="abc";\nb="efg";\nif [ $a = $b ]\nthen\n   echo "a 等于 b"\nelse\n   echo "a 不等于 b"\nfi\n```\n输出：\n\n```\na 不等于 b\n```\n\n### 文件相关运算符\n\n![文件相关运算符](Shell.assets/60359774.jpg)\n\n使用方式很简单，比如我们定义好了一个文件路径`file="/usr/learnshell/test.sh"` 如果我们想判断这个文件是否可读，可以这样`if [ -r $file ]` 如果想判断这个文件是否可写，可以这样`-w $file`，是不是很简单。\n\n## shell流程控制\n\n### if 条件语句\n\n简单的 if else-if else 的条件语句示例\n\n```shell\n#!/bin/bash\na=3;\nb=9;\nif [ $a -eq $b ]\nthen\n   echo "a 等于 b"\nelif [ $a -gt $b ]\nthen\n   echo "a 大于 b"\nelse\n   echo "a 小于 b"\nfi\n```\n\n输出结果：\n\n```\na 小于 b\n```\n\n相信大家通过上面的示例就已经掌握了 shell 编程中的 if 条件语句。不过，还要提到的一点是，不同于我们常见的 Java 以及 PHP 中的 if 条件语句，shell  if 条件语句中不能包含空语句也就是什么都不做的语句。\n\n### for 循环语句\n\n通过下面三个简单的示例认识 for 循环语句最基本的使用，实际上 for 循环语句的功能比下面你看到的示例展现的要大得多。\n\n**输出当前列表中的数据：**\n\n```shell\nfor loop in 1 2 3 4 5\ndo\n    echo "The value is: $loop"\ndone\n```\n\n**产生 10 个随机数：**\n\n```shell\n#!/bin/bash\nfor i in {0..9};\ndo \n   echo $RANDOM;\ndone\n```\n\n**输出1到5:**\n\n通常情况下 shell 变量调用需要加 $,但是 for 的 (()) 中不需要,下面来看一个例子：\n\n```shell\n#!/bin/bash\nfor((i=1;i<=5;i++));do\n    echo $i;\ndone;\n```\n\n\n### while 语句\n\n**基本的 while 循环语句：**\n\n```shell\n#!/bin/bash\nint=1\nwhile(( $int<=5 ))\ndo\n    echo $int\n    let "int++"\ndone\n```\n\n**while循环可用于读取键盘信息：**\n\n```shell\necho \'按下 <CTRL-D> 退出\'\necho -n \'输入你最喜欢的电影: \'\nwhile read FILM\ndo\n    echo "是的！$FILM 是一个好电影"\ndone\n```\n\n输出内容:\n\n```\n按下 <CTRL-D> 退出\n输入你最喜欢的电影: 变形金刚\n是的！变形金刚 是一个好电影\n```\n\n**无限循环：**\n\n```shell\nwhile true\ndo\n    command\ndone\n```\n\n## shell 函数\n\n### 不带参数没有返回值的函数\n\n```shell\n#!/bin/bash\nhello(){\n    echo "这是我的第一个 shell 函数!"\n}\necho "-----函数开始执行-----"\nhello\necho "-----函数执行完毕-----"\n```\n\n输出结果：\n\n```\n-----函数开始执行-----\n这是我的第一个 shell 函数!\n-----函数执行完毕-----\n```\n\n\n### 有返回值的函数\n\n**输入两个数字之后相加并返回结果：**\n\n```shell\n#!/bin/bash\nfunWithReturn(){\n    echo "输入第一个数字: "\n    read aNum\n    echo "输入第二个数字: "\n    read anotherNum\n    echo "两个数字分别为 $aNum 和 $anotherNum !"\n    return $(($aNum+$anotherNum))\n}\nfunWithReturn\necho "输入的两个数字之和为 $?"\n```\n\n输出结果：\n\n```\n输入第一个数字: \n1\n输入第二个数字: \n2\n两个数字分别为 1 和 2 !\n输入的两个数字之和为 3\n```\n\n### 带参数的函数\n\n```shell\n#!/bin/bash\nfunWithParam(){\n    echo "第一个参数为 $1 !"\n    echo "第二个参数为 $2 !"\n    echo "第十个参数为 $10 !"\n    echo "第十个参数为 ${10} !"\n    echo "第十一个参数为 ${11} !"\n    echo "参数总数有 $# 个!"\n    echo "作为一个字符串输出所有参数 $* !"\n}\nfunWithParam 1 2 3 4 5 6 7 8 9 34 73\n```\n\n输出结果：\n\n```\n第一个参数为 1 !\n第二个参数为 2 !\n第十个参数为 10 !\n第十个参数为 34 !\n第十一个参数为 73 !\n参数总数有 11 个!\n作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !\n```\n'}}]);