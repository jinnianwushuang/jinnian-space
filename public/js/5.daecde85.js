(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[5],{"012b":function(n,r,e){"use strict";e.r(r),r["default"]="Linux Web运维（Nginx）\r\n\r\nhttps://www.nginx.cn/doc/index.html\r\n\r\n配置模板\r\n\r\nhttps://github.com/jinnianwushuang/server-configs-nginx\r\n\r\n\r\n\r\n1、添加源\r\n\r\n默认情况Centos7中无Nginx的源，最近发现Nginx官网提供了Centos的源地址。因此可以如下执行命令添加源：\r\n\r\nsudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm\r\n\r\n2、安装Nginx\r\n\r\n通过yum search nginx看看是否已经添加源成功。如果成功则执行下列命令安装Nginx。\r\n\r\nsudo yum install -y nginx\r\n\r\n3、启动Nginx并设置开机自动运行\r\n\r\nsudo systemctl start nginx.service\r\nsudo systemctl enable nginx.service\r\n\r\n\r\n4.建立软连接 快捷启动方式  根据实际的路径 建立\r\n ln -s /usr/local/nginx/sbin/nginx   /usr/local/sbin/\r\n\r\nnginx 配置文件 健康检查  语法检查\r\nnginx -t\r\n\r\n重启服务 \r\nservice nginx restart"},"0b8f":function(n,r,e){"use strict";e.r(r),r["default"]="# ***\\*深入理解Kafka的设计思想\\****\r\n\r\n ![img](22.深入理解Kafka的设计思想.assets/wpsE88.tmp.png)\r\n\r\nhi 大家周末好，消息队列是分布式系统中重要的组件，在很多生产环境如商品抢购等需要控制并发量的场景下都需要用到，消息队列主要解决了应用耦合、异步处理、流量削锋等问题，当前使用较多的消息队列有RabbitMQ、RocketMQ、ActiveMQ、Kafka、ZeroMQ、MetaMq等，而部分数据库如Redis，Mysql以及phxsql也可实现消息队列的功能。\r\n\r\n \r\n\r\n消息队列在实际应用场景：\r\n\r\n应用解耦：多应用间通过消息队列对同一消息进行处理，避免调用接口失败导致整个过程失败；\r\n\r\n异步处理：多应用对消息队列中同一消息进行处理，应用间并发处理消息，相比串行处理，减少处理时间；\r\n\r\n限流削峰：广泛应用于秒杀或抢购活动中，避免流量过大导致应用系统挂掉的情况；\r\n\r\n \r\n\r\n今天分享一篇经典的Kafka设计剖析文章给大家，Kafka作为顶级消息中间件，据 Confluent 称， 超过三分之一的财富 500 强公司使用 Apache Kafka，**kafka的性能快，吞吐量大，并且高于其他消息队列一个水平, 即使在消息量巨大的情况下还能保持高性能**, 在互联网公司中非常流行， 希望大家领悟到kafka设计的核心原理。\r\n\r\n \r\n\r\n![img](22.深入理解Kafka的设计思想.assets/wpsE89.tmp.png) \r\n\r\n**Kafka****架构**\r\n\r\n \r\n\r\n**Kafka**是一个被精心设计的东西，我只能这样说。我这里所谓的精心不是说它很完备的实现了某种规范，像个学生那般完成了某个作业，比如JMS，恰恰相反，Kafka突破了类似JMS这种规范性的束缚，它是卓越的，乃yet another JMS。当我用yet…如此称呼一个技术的时候，意味着这玩意儿已经进入了我的视野。好了，现在是Kafka和Storm时间，本文先谈Kafka。\r\n\r\n \r\n\r\n**Kafka是什么？**\r\n\r\n参见官方文档，它是Apache的一个项目。它是一个消息队列。\r\n\r\n \r\n\r\n**消息队列若何**\r\n\r\n消息队列是生产者和消费者之间的信使，避免了二者之间直接的接触。在效果上，它可能和缓存所起的作用一样，平滑了生产者和消费者之间的代谢速率差，但是在其根本目的上，它是为了解除生产者和消费者之间的耦合。如果你觉得有点费解，那么简单点说。\r\n\r\n \r\n\r\n**fire and forget**，这句话的意思再简单点说，就是真男人从不看爆炸，烟头往油箱里一丢，把风衣的领子一竖，手插裤兜里，径直走开，决不不回头。\r\n\r\n \r\n\r\n**消息队列**，以下简称MQ，就是造就这种真男人的。它能让生产者把消息扔进MQ就不管了，然后消费者从MQ里取消息即可，不用和生产者交互。下面的篇幅，我将逐步用我的方式演化出Kafka的原型，为了掌握整体脉络，难免会隐掉很多细节，当然这些细节可以随便在其官方文档以及别人的博客里搜到，**我的目的只是希望能整理出一个脉络，在设计类似的系统的时候，见招拆招以备参考**。\r\n\r\n \r\n\r\n**MQ朝着”正确”方向的演化**\r\n\r\nKafka就一定正确吗？客观讲，肯定不，但是它是本文的主角，所以它就一定正确。\r\n\r\n \r\n\r\n我们先来看看作为通用的MQ，其最简单的形式，一般而言，这是大家在首次接触到MQ后的一个课后作业。\r\n\r\n \r\n\r\n![img](22.深入理解Kafka的设计思想.assets/wpsE8A.tmp.png) \r\n\r\n \r\n\r\n现在有个问题，如果有两个或者多个消费者需要消费消息，怎么办？很简单，广播呗：\r\n\r\n \r\n\r\n![img](22.深入理解Kafka的设计思想.assets/wpsE8B.tmp.png) \r\n\r\n \r\n\r\n消费者是上帝，很难搞的，你推给它们的东西，并不是它们全部都想要的，只要一部分怎么办？\r\n\r\n \r\n\r\n![img](22.深入理解Kafka的设计思想.assets/wpsE8C.tmp.png) \r\n\r\n \r\n\r\n好吧，消费者一定在怪MQ服务不周，然而MQ有什么错，它又不理解消息的语义，面对百般刁难的消费者，它最多只能要求生产者把消息细分一下，因此就出现了多个**Topic**：\r\n\r\n \r\n\r\n![img](22.深入理解Kafka的设计思想.assets/wpsE8D.tmp.png) \r\n\r\n \r\n\r\n这是很显然的想法，就是是在消息入队处区分消息的Topic，然消费者从取自己感兴趣的消息队列取消息即可。\r\n\r\n \r\n\r\n但还是会潜在的多个消费对同一Topic消息感兴趣的情况：\r\n\r\n \r\n\r\n![img](22.深入理解Kafka的设计思想.assets/wpsE8E.tmp.png) \r\n\r\n \r\n\r\n如果采用广播，那么就仍然会出现冗余传播问题，如果单播，那么一个消费者取出消息后，这条消息该不该删除呢？如果删除了，另一个消费者怎么办？广播会浪费带宽，不广播也不行…这貌似进入了一个死循环，必须一劳永逸地从根源解决问题才行。显然的想法是下面的方案(至少我自己设计的话就会这么做)：\r\n\r\n \r\n\r\n![img](22.深入理解Kafka的设计思想.assets/wpsE8F.tmp.png) \r\n\r\n \r\n\r\n问题是解决了，然而我的天啊，仔细想一下先前的架构，把简图画出来后，会发现事情会一发而不可收拾，MQ本身的逻辑太复杂了：\r\n\r\n \r\n\r\n![img](22.深入理解Kafka的设计思想.assets/wpsE90.tmp.png) \r\n\r\n \r\n\r\n回到UNIX哲学，遇到新问题的时候，**要新编一个程序，而不是为已有的程序添加一个功能**。本着这个思路，为什么不把这件因为消费者而导致复杂化的事情完全交给消费者呢？\r\n\r\n \r\n\r\n有点往Kafka上靠了啊。\r\n\r\n \r\n\r\n如果把MQ里面的数据**全部持久化存储**，消费者不就可以各取所需了吗？这是一个根本的转变，如果以前的方式是限量商务套餐-套餐强行推给你，不想要的自己扔掉，那么现在的方式就是无限量自助餐-想要什么自己去拿即可。**消息自取，消息永远都在MQ，消费者随便取，取哪个消息都行，什么时候取都行**。消费者只需要告诉MQ它想要哪个消息就好，因此需要传递一个消息的offset参数：\r\n\r\n \r\n\r\n![img](22.深入理解Kafka的设计思想.assets/wpsEA0.tmp.png) \r\n\r\n \r\n\r\n**(然而自助餐也有打烊的时候，部分也会限制就餐时长，这是Kafka策略化存储的问题，详见文档。)**\r\n\r\n \r\n\r\n简化一下，现在看下图：\r\n\r\n \r\n\r\n![img](22.深入理解Kafka的设计思想.assets/wpsEA1.tmp.png) \r\n\r\n \r\n\r\n一切OK了。嗯，是的，这就是Kafka的原始模型。然而Kafka远不仅此而已。且看下文继续演化。\r\n\r\n \r\n\r\n**集群化，容错**\r\n\r\n先看一下现在的情况：\r\n\r\n \r\n\r\n![img](22.深入理解Kafka的设计思想.assets/wpsEA2.tmp.png) \r\n\r\n \r\n\r\n这是在**逻辑上**一个Kafka类似的MQ应有的结构。但是在物理实现上，它又如何呢？\r\n\r\n \r\n\r\n常听人说，Kafka一开始就是为分布式而生的，这话怎么理解呢？我们只需要先理解它如何扩容，然后再理解它如何将扩容**作用于不同的机器即可**。先看扩容。\r\n\r\n \r\n\r\n类似高速公路，一般当你听到广深高速的时候，我们知道这是从广州到深圳的一条高速公路，这是逻辑上的说法，类似到目前为止我们讨论的MQ的Topic。然而这条高速公路到底长什么样子，沿途怎么路由，这就是物理实现了。此外，所有的道路都会分多个车道用于并行。严格来讲，每一个车道都会被细分，比如小型车道，客车道，大货车道，超车道等等，所有这些车道上的车都是到达同一个目的地(属于同一个Topic)，然而它们确实是细分的不同种类。把一个叫做partition的概念类比为车道，如下图：\r\n\r\n \r\n\r\n![img](22.深入理解Kafka的设计思想.assets/wpsEA3.tmp.png) \r\n\r\n \r\n\r\n注意这个**key hash模块**，这里就是**区分车子要进入哪个车道**的逻辑。在Kafka的术语中，车道就是**partition**，即**分区**。在同一个Topic中分发消息的时候，你要自己设计hash函数，该hash函数就是一个分发策略，决定把消息**按序**放到哪一个分区中去。\r\n\r\n \r\n\r\n温州皮鞋厂老板说类比和举例不好，但这是技术散文，不是技术文档，多半是给自己看，所以还要类比。Topic Routing做的事是决定从哪条高速公路到哪里，而key hash则是决定你是坐轿车，客车还是卡车过去。\r\n\r\n \r\n\r\n值得注意的是，Kafka只保证同一Topic内同一partition内消息的有序性，无法做到全局有序性。这并不是一个缺陷，这是两全不能齐美的。**完全的顺序就需要串行化，然而串行化就无法并行**，这简直就是废话！\r\n\r\n \r\n\r\n现在，在**Topic**之下，我们又有了一个新的单位，叫做**partition**，这个叫做partition的就是Kafka中最基本的部署单位，这一点务必要记住，它关乎到如何组织你的集群。\r\n\r\n \r\n\r\n好了，看一下这些Topic以及其旗下的partition是如何部署在M1和M2两台机器上的吧：\r\n\r\n \r\n\r\n![img](22.深入理解Kafka的设计思想.assets/wpsEA4.tmp.png) \r\n\r\n \r\n\r\n以上是花开两朵，各表一枝，现在该说说消费者了。\r\n\r\n \r\n\r\n消费者面对MQ本身进化到如此细粒度，该如何应对呢？其实消费者也有**横向扩展**的需求，如果说消费者对应partition，那么对应Topic的就是消费者的上级了。因此多加了一个层次，引出**消费组**的概念，解决问题：\r\n\r\n \r\n\r\n![img](22.深入理解Kafka的设计思想.assets/wpsEA5.tmp.png) \r\n\r\n \r\n\r\n从CPU cache到Kafka，设计思路殊途同归，这就是一个典型的全方位组相联结构：\r\n\r\n \r\n\r\n![img](22.深入理解Kafka的设计思想.assets/wpsEA6.tmp.png) \r\n\r\n \r\n\r\n到此为止，全部图景已经完全绘制完毕，是时候展示集群的部署了。我们知道所谓的Kafka集群，就是将各个Topic的partition部署在不同的机器上，达到两个目的，一个是负载均衡，即提供访问的并行性，另一个就是提供高可用性，即做热备份，这两个功能我希望能用一个图展示：\r\n\r\n \r\n\r\n![img](22.深入理解Kafka的设计思想.assets/wpsEA7.tmp.jpg) \r\n\r\n \r\n\r\n总体的一个结构如下：\r\n\r\n \r\n\r\n![img](22.深入理解Kafka的设计思想.assets/wpsEA8.tmp.png) \r\n\r\n \r\n\r\n**持久化存储/查询机制**\r\n\r\n上面的两个小节，我已经展示了Kafka是如何一步一步地肚子里面的勾当内外有别的，虽然我不知道作者怎么去设计，但如果是我自己，我肯定就是上面这个思路了。\r\n\r\n…\r\n\r\n \r\n\r\n\r\n\r\n------\r\n\r\n\r\n\r\n \r\n\r\n前面的叙述终究是概览，不甚过瘾。本节将给出半点细节，瑾阐释一下Kafka存储的半景。\r\n\r\n \r\n\r\n\r\n\r\n------\r\n\r\n\r\n\r\n \r\n\r\n我们知道，Kafka为了卸载MQ本身的复杂性，为了其真正**无状态**的设计，它将状态维护机制这口锅完全甩给了消费者，因此取消息的问题就转化成了消费者拿着一个offset索引来Kafka存储器里取消息的问题，这就涉及到了性能。But 如何能查的更快？How？\r\n\r\n \r\n\r\n还是先给出一个最简单的场景。假设Kafka的每一个partition都一个完整独立的文件，那么如果这个文件非常大，事实上也确实非常大(有可能到达T级别甚至P级别…)，那么在大文件中检索一个特定的消息本身就是一个头疼的问题，并且该文件还在磁盘中，这更是雪上加霜，我们都知道磁盘的随机读写是硬伤，顺序读写也好不到哪去，这怎么办？\r\n\r\n \r\n\r\n遍历？如果每一个partition只是一个独立文件，那么只能遍历：\r\n\r\n![img](22.深入理解Kafka的设计思想.assets/wpsEB9.tmp.png) \r\n\r\n \r\n\r\n面对这个遍历问题，一般的解决方案就是建立索引，并且把索引数据常驻内存，很多数据库就是这么干的，Kafka当然也可以这么干。\r\n\r\n \r\n\r\nKafka比较帅的一点就是它并不借助任何特殊的文件系统，它的数据就存在一般的文件中，然而它把一个partition分成了等大小的一系列小文件，因此在物理上，并不存在一个完整的partition文件，partiotion只是表现为一个目录。我们知道，文件系统管理几个等大的文件是非常方便的：\r\n\r\n \r\n\r\n![img](22.深入理解Kafka的设计思想.assets/wpsEBA.tmp.jpg) \r\n\r\n \r\n\r\n \r\n\r\n以上的例子中，一个partiton被分成了100M大小的文件，这种小文件叫做分段，在Kafka存储的时候，每一个段文件存满为止再开辟下一个，由于消息的长度并不一定统一，因此每一个小段文件里面包含的消息数量并不一定一样多。\r\n\r\n \r\n\r\n但是不管怎样，抽取每一个段文件的首尾消息偏移作为元数据保存起来是一件一劳永逸的事情，这便于建立一个**常驻内存**的索引：\r\n\r\n \r\n\r\n![img](22.深入理解Kafka的设计思想.assets/wpsEBB.tmp.png) \r\n\r\n \r\n\r\n通过这个区间查找树，很快就能定位到特定的段文件，但是事情并没有结束。\r\n\r\n \r\n\r\n在Kafka中，每一个partition的段文件，均配带一个index索引文件，这个文件是做什么的呢？它是段文件内部消息的稀疏索引，见下图：\r\n\r\n \r\n\r\n![img](22.深入理解Kafka的设计思想.assets/wpsEBC.tmp.png) \r\n\r\n \r\n\r\n最终，经过两次区间树查找之后，最多再经历一次简单的遍历即可完成offset定位工作。诚然，最终的遍历可能是少不了的，但是Kafka尽可能地避免了大长段耗时的遍历计算，而是将遍历压缩到一个很小的量级，这是一个权衡！跟谁权衡呢？为什么不把段文件所有消息的索引均建立起来呢？\r\n\r\n \r\n\r\n很简单，建立全部的索引会造成索引非常大，这样如果你还想其常驻内存的话，内存占用会很大，这确实又是一个时间和空间之间的权衡了。\r\n\r\n \r\n\r\n \r\n\r\n**稀疏索引闲谈**\r\n\r\n \r\n\r\n稀疏索引很有用，除了本文列举的Kafka的segment index稀疏索引之外，还有两个更为常见的例子(我不是应用编程的，我是搞内核网络协议栈的，所以在我看来Kafka更不常见！)：\r\n\r\n \r\n\r\n索引整个内存地址空间，稀疏化的做法就是分页，即采用规则的方式将内存划分为等大小的块，叫做内存页，然后索引这些内存页即可，页表而不是地址表稀疏化索引，减小索引的大小。\r\n\r\n \r\n\r\n另外，IP地址具有地域聚集性，因此对于路由器物理设备而言，对于每一个接口引出的方向，其IP地址集在很大程度上是可以聚集的，路由表一开始采用地址分类的方法，后来采用了前缀匹配的方法稀疏化索引，地址分类有点像内存地址分页，只是页面有多种大小而不仅仅是一种，而这里的地址前缀则比较像Kafka使用的两种索引，第一种是段索引，这是规则的，第二种是消息索引，这是不规则的。因为消息并不定长。\r\n\r\n \r\n\r\n两种说法总结如下。\r\n\r\n \r\n\r\n· \r\n\r\n**OS内存页表**\r\n\r\n· \r\n\r\n在从虚拟地址定位物理地址的时候，需要一一对应定位到每一个地址吗？假如真是这样子，那么光页表项这种管理内存就要耗多少你算过吗？虚拟地址和物理地址将会是全相联结构。\r\n\r\n \r\n\r\n采用稀疏索引后，只需要定位一个4K大小的页面即可，这将大大减小内存页表的内存占用。从而更加高效。\r\n\r\n \r\n\r\n**·** \r\n\r\n**路由表**\r\n\r\n**·** \r\n\r\n将每一个IP地址均对应到路由器设备的接口吗？这不现实。解决方案一开始是基于分配机构的分类地址稀疏索引，后来采用了基于使用结构的无类子网的前缀系数索引，无论哪种情况，均大大减少了路由表项的数量。\r\n\r\n \r\n\r\n**UNIX哲学的出路**\r\n\r\n \r\n\r\n没出路了！Why？因为只有复杂才能体现自己的工作量。\r\n\r\n \r\n\r\n人们都希望制造门槛，把程序做的非常复杂，方才体现自己的能力，毕竟简单的东西大家都会，想体现区别，只能让自己的东西更复杂。如果你用几行Bash脚本完成了一项艰巨的工作，经理大概率会觉得你这是奇技淫巧，完全无法和C++的方案相比。Python好一点，Java则更好。\r\n\r\n \r\n\r\n4,5年以前的曾经，我们有个编程道场的活动，有一次的一个题目是拼接字符串，即join操作，当时的经理兼主持者强调尽量用现成的接口，然而…\r\n\r\n \r\n\r\n多少个优秀的极简方案没有被表扬，最后被表扬的方案你们知道其特征是什么吗？其特征就是**复杂**。我记得当时这个方案的作者上台介绍他的方案，上来就说”我这个设计非常简单…”结果呢，唉，用技术术语讲，过度设计了，用白话讲，装逼了。主持者显然也是完全半瓶子晃荡的吧，哈哈。\r\n\r\n \r\n\r\n**事情必须做的尽量复杂，这样才是能力的体现**，2行能搞定的东西，必须凑够30行才算牛逼。UNIX哲学，在我们这，显然不合适吧。\r\n\r\n \r\n\r\n**扩展阅读：**\r\n\r\nhttps://blog.csdn.net/dog250/article/details/79588437\r\n\r\nhttps://www.cloudamqp.com/blog/when-to-use-rabbitmq-or-apache-kafka.html\r\n\r\n "},"105b":function(n,r,e){var t={"./0.Linux Web运维.md":"012b","./Nginx配置文件详解.md":"df9c","./ginx Configuration Snippets.md":"bc61"};function i(n){var r=s(n);return e(r)}function s(n){if(!e.o(t,n)){var r=new Error("Cannot find module '"+n+"'");throw r.code="MODULE_NOT_FOUND",r}return t[n]}i.keys=function(){return Object.keys(t)},i.resolve=s,n.exports=i,i.id="105b"},"1b62":function(n,r,e){"use strict";e.d(r,"d",(function(){return o})),e.d(r,"c",(function(){return d})),e.d(r,"a",(function(){return f})),e.d(r,"b",(function(){return b}));e("4de4"),e("c975");var t=e("448a"),i=e.n(t),s=["/第1阶段-运维基本功（升级7.6版本）/01运维概述与Linux系统安装.pdf","/第1阶段-运维基本功（升级7.6版本）/02Linux基础命令.pdf"],a="linux/heima-Linux云计算",o={name:"Container",data:function(){return{prefix:a,book_options:s,book_options_all:[],show:!0,book:s[0],src:""}},created:function(){this.book_options_all=i()(this.book_options),this.src=this.$utils.compute_book_src(this.prefix+this.book)},watch:{book:function(n,r){n&&this.change_book()}},methods:{change_book:function(){console.log("this.book",this.book),this.src=this.$utils.compute_book_src(this.prefix+this.book)},filterFn:function(n,r){var e=this;r(""!==n?function(){var r=n.toLowerCase();e.book_options=e.book_options_all.filter((function(n){return n.toLowerCase().indexOf(r)>-1}))}:function(){e.book_options=e.book_options_all})}}},l=e("ded3"),p=e.n(l),c=e("2f62"),d={data:function(){return{tab:"",tab_level:1,is_active:!1}},computed:p()({},Object(c["c"])(["get_current_selected_right_menu"])),created:function(){this.is_active=!0,this.fix_right_menu_config()},watch:{tab:function(){this.tab||this.fix_right_menu_config()},get_current_selected_right_menu:function(n,r){this.tab=this.get_current_selected_right_menu["t"+this.tab_level]}},methods:p()(p()({},Object(c["b"])(["set_right_menu_fix_config"])),{},{fix_right_menu_config:function(){this.set_right_menu_fix_config({tl:this.tab_level,tabs:this.tabs||[],tv:this.tab||this.tabs[0]["value"]})}}),beforeDestroy:function(){this.is_active=!1}},u=(e("99af"),e("d81d"),e("fb6a"),e("a434"),e("07ac"),function(){var n=this,r=n.$createElement,e=n._self._c||r;return e("div",{staticClass:"q-my-md q-mx-sm"},[e("div",{staticClass:"q-mb-md row q-gutter-x-md q-gutter-y-sm"},[e("q-select",{staticStyle:{width:"300px"},attrs:{dense:"",filled:"","use-input":"","hide-selected":"","fill-input":"","input-debounce":"0",options:n.topic_options_filtered},on:{filter:n.filterFn,"filter-abort":n.abortFilterFn,input:n.handle_topic_change},scopedSlots:n._u([{key:"before",fn:function(){return[n._v("\n        主题\n      ")]},proxy:!0}]),model:{value:n.topic,callback:function(r){n.topic=r},expression:"topic"}}),e("q-select",{staticStyle:{width:"300px"},attrs:{dense:"",filled:"",options:n.column_options},on:{input:n.handle_column_change},scopedSlots:n._u([{key:"before",fn:function(){return[n._v("\n        列数\n      ")]},proxy:!0}]),model:{value:n.column,callback:function(r){n.column=r},expression:"column"}})],1),e("q-markup-table",{attrs:{dense:""}},[e("thead",[e("tr",[e("th",{staticClass:"text-left text-weight-bolder  ",attrs:{colspan:n.column}},[n._v("\n          "+n._s(n.table_title?n.table_title+"------":"")+"当前词条数量："+n._s(n.word_total)+"\n        ")])])]),e("tbody",[n._l(n.table_data,(function(r,t){return[n.compute_if_show(r)?e("tr",{key:t,class:n.compute_topic_options_style(r)},n._l(n.column,(function(t){return e("td",{key:t,staticClass:"text-left"},[n._v("\n            "+n._s(r[t-1])+"\n          ")])})),0):n._e()]}))],2)])],1)}),m=[],g=(e("caad"),e("a9e3"),e("2532"),{data:function(){return{topic:"全部",column:2,topic_options_filtered:[],topic_options_all:[]}},props:{table_title:{type:String,default:""},word_total:{type:Number,default:0},topic_options:{type:Array,default:function(){return[]}},column_options:{type:Array,default:function(){return[]}},table_data:{type:Array,default:function(){return[]}},show_empty_line:!1},watch:{topic_options:function(n,r){this.init_topic_options_related()},column_options:function(n,r){this.init_column()}},created:function(){this.init_topic_options_related(),this.init_column(),this.handle_column_change(),this.handle_topic_change()},methods:{init_topic_options_related:function(){this.topic_options_all=i()(this.topic_options),this.topic_options_filtered=i()(this.topic_options)},filterFn:function(n,r,e){var t=this;console.log("this.topic_options_all",this.topic_options_all),setTimeout((function(){r((function(){if(""===n)t.topic_options_filtered=i()(t.topic_options_all);else{var r=n.toLowerCase();t.topic_options_filtered=t.topic_options_all.filter((function(n){return n.toLowerCase().indexOf(r)>-1}))}t.$forceUpdate()}),(function(r){""!==n&&r.options.length>0&&(r.setOptionIndex(-1),r.moveOptionSelection(1,!0))}))}),300)},abortFilterFn:function(){},handle_column_change:function(){this.$emit("handle_column_change",this.column)},handle_topic_change:function(){this.$emit("handle_topic_change",this.topic)},init_column:function(){var n=this.$q.platform.is.desktop,r=window.innerWidth;r=n?r-200:r-100,r=r<370?370:r,console.log("ww",r);var e=Math.ceil(r/350);e=e<1?1:e,r<400&&(e=1),e=e>8?8:e,this.column=e},compute_topic_options_style:function(n){var r="",e=1==n.length&&this.topic_options.includes(n[0]);return r=e?"bg-teal-4":"",r},compute_if_show:function(n){if(this.show_empty_line)return!0;var r=n.filter((function(n){return n}));return r.length>0}}}),_=g,h=e("2877"),v=Object(h["a"])(_,u,m,!1,null,"4e74a874",null),x=v.exports,f={components:{excelTable:x},data:function(){return{workSheetsFromFile:[[{data:[]}]],table_title:"",column:8,word_total:0,table_data:[],table_data_all:[],column_options:[1,2,3,4,5,6,7,8],exclude_topic_options:!0,show_empty_line:!1,topic:"",topic_options:[]}},created:function(){this.init_workSheetsFromFile()},methods:{init_workSheetsFromFile:function(){},handle_column_change:function(n){this.column=n,this.init_data()},handle_topic_change:function(n){this.topic=n,console.log("this.topic----",this.topic),this.compute_table_data_show_and_word_total()},rebuild_arr_reduce_empty_line:function(n){var r=[[""]];return n.map((function(n){var e=n.filter((function(n){return n})),t=e.length;if(t)r.push(n);else{var i=r[r.length-1].filter((function(n){return n})).length,s=r[r.length-1].length;s>0&&i>0&&r.push([""])}})),r},init_data:function(){var n=this;console.log("workSheetsFromFile --------",this.workSheetsFromFile);var r=[],e={},t=[];this.workSheetsFromFile.map((function(n){r=r.concat(n["data"])}));var s=this.$lodash.cloneDeep(r[0].filter((function(n){return n})));s.map((function(n,r){e["key_"+r]={title:n,words_raw:[]}})),this.exclude_topic_options&&r.splice(0,1),r.map((function(n,r){n.map((function(n,r){e["key_"+r]["words_raw"].push(n)}))})),console.log("final_obj------------",e);var a=Object.values(e);a.map((function(r,e){t.push([r["title"]]),t=t.concat(n.$lodash.chunk(r["words_raw"],n.column)),t=t.concat([[""]])})),this.topic_options=["全部"].concat(i()(s)),this.table_data_all=this.rebuild_arr_reduce_empty_line(t),this.compute_table_data_show_and_word_total(),console.log("  this.table_data_all   ",this.table_data_all)},compute_table_data_show_and_word_total:function(){var n=[],r=[],e=0;if(r=this.$lodash.cloneDeep(this.table_data_all),console.log(" table_data--------",r),"全部"==this.topic)n=r;else{var t=this.topic_options.indexOf(this.topic),i=t==this.topic_options.length-1,s=i?"":this.topic_options[t+1],a=this.find_topic_index(this.topic),o=s?this.find_topic_index(s):r.length;n=r.slice(a,o)}n.map((function(n){var r=n.filter((function(n){return n})).length;e+=r})),this.word_total=e,this.table_data=n},find_topic_index:function(n){for(var r=0,e=0;e<this.table_data_all.length;e++){var t=this.table_data_all[e];if(1==t.length&&t[0]&&t[0]==n){r=e;break}}return r}}},b=(e("7db0"),e("ac1f"),e("1276"),{data:function(){return{relative_path:"",tab:"",tabs:[],MainComponent:"",img_prefix:"./img/linux/heima-Linux云计算/讲义/"}},methods:{extendMarkdown:function(n){var r=this;console.log(n.renderer.rules);var e=n.renderer.rules.html_block;n.renderer.rules.html_block=function(n,t,i,s,a){var o=n[t];if(console.log("1"),o.content.includes("<img")){console.log("token-- ",o);var l="";l=o.content;var p=l.split('src="'),c="",d=p[1];p[0],r.img_prefix,p[1],c=d.includes("http")?p[0]+' src="'+d:p[0]+' src="'+r.img_prefix+d,o.content=c}return o.attrSet("class","q-markdown--token  "),e(n,t,i,s,a)},n.renderer.rules.image=function(n,e,t,i,s){var a=n[e];console.log("3"),a.attrSet("class","q-markdown--image"),console.log("token--- "+e+"-----",a);var o=a.attrGet("src");return console.log(o),o.includes("http")?a.attrSet("src",o):a.attrSet("src",r.img_prefix+o),s.renderToken(n,e,t)}},compute_img_prefix:function(){var n=this;if(this.MainComponent){var r=this.tabs.find((function(r){return r["value"]==n.tab}));if(r&&r["modules_obj"]){var e=this.relative_path;this.img_prefix="."+e+(r["modules_obj"]["relative_folder"]||"")}else this.img_prefix="."+relative_path}}}})},3686:function(n,r,e){"use strict";e.d(r,"a",(function(){return p}));e("e260"),e("a15b"),e("d81d"),e("fb6a"),e("4e82"),e("d3b7"),e("ac1f"),e("5319"),e("1276"),e("ddb0");var t=e("ded3"),i=e.n(t),s=e("d958"),a=function(n){var r=s(n,{style:s.STYLE_NORMAL}),e="";return r.map((function(n){e+=n[0]})),e},o=function(n){if(!n)return"";var r="",e=n.split("/");return e.shift(),e.pop(),r=e.join("/"),r?"/"+r+"/":""},l=function(n){n=n||"";var r=n.split("/"),e=r.length;return r[e-1]},p=function(n){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"md",e=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],t=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];console.log("当前 require.context---",n),console.log("当前 field_components.keys()---",n.keys());var p=n.keys(),c={},d=[],u={},m=[];return p.map((function(i){var s=/[^\u4E00-\u9FA5A-Za-z]+/g,l=i.slice(2,i.length-r.length-1),p="";e?(p=a(i).replace(s,""),p=p.slice(0,p.length-r.length)):p=l,m.push(l),u[l]={value:p,relative_path:i,relative_folder:o(i)},console.log("x---",i),c[p]=t?"\n            <div>\n            <code>\n              ".concat(n(i).default,"\n            </code>\n            </div>\n            "):n(i).default})),m.sort((function(n,r){return parseFloat(n)-parseFloat(r)})),m.map((function(n){d.push({label:s?l(n):n,value:u[n]["value"],modules_obj:i()({},u[n])})})),console.log("all_components------------",c),console.log("all_modules---------------",d),{all_components:c,all_modules:d}}},"388d":function(n,r,e){"use strict";var t=e("f0ba"),i=e.n(t);i.a},"429e":function(n,r,e){"use strict";e.r(r),r["default"]="# ***\\*Linux调度系统全景指南(上篇)\\****\r\n\r\n \r\n\r\n \r\n\r\n| 导语 本文主要是讲Linux的调度系统, 由于全部内容太多，分三部分来讲，调度可以说是操作系统的灵魂，为了让CPU资源利用最大化，Linux设计了一套非常精细的调度系统，对大多数场景都进行了很多优化，系统扩展性强，我们可以根据业务模型和业务场景的特点，有针对性的去进行性能优化，在保证客户网络带宽前提下，隔离客户互相之间的干扰影响，提高CPU利用率，降低单位运算成本，提高市场竞争力。欢迎大家相互交流学习！\r\n\r\n \r\n\r\n​               **目录**\r\n\r\n![img](9.Linux调度系统全景指南(上篇).assets/wpsAB82.tmp.jpg) \r\n\r\n \r\n\r\n![img](9.Linux调度系统全景指南(上篇).assets/wpsAB83.tmp.png) \r\n\r\n \r\n\r\n \r\n\r\n​               \r\n\r\n​                  CPU\r\n\r\n![img](9.Linux调度系统全景指南(上篇).assets/wpsAB94.tmp.jpg) \r\n\r\n \r\n\r\n \r\n\r\nCPU作为计算资源，一直是云计算厂商比拼的核心竞争力，我们的目标是合理安排好计算任务，充分提高CPU的利用率，预留更多空间容错，增强系统稳定性，让任务更快执行，降低无效功耗，节约成本，从而提高市场竞争力。\r\n\r\n![img](9.Linux调度系统全景指南(上篇).assets/wpsAB95.tmp.jpg) \r\n\r\n \r\n\r\n​                CPU 实现的抽象逻辑图\r\n\r\n\\1. \r\n\r\n首先，我们有一个自动计数器。这个自动计数器会随着时钟主频不断地自增，来作为我们的 PC 寄存器；\r\n\r\n\\2. \r\n\r\n\\3. \r\n\r\n在这个自动计数器的后面，我们连上一个译码器。译码器还要同时连着我们通过大量的 D 触发器组成的内存。\r\n\r\n\\4. \r\n\r\n\\5. \r\n\r\n自动计数器会随着时钟主频不断自增，从译码器当中，找到对应的计数器所表示的内存地址，然后读取出里面的 CPU 指令。\r\n\r\n\\6. \r\n\r\n\\7. \r\n\r\n读取出来的 CPU 指令会通过CPU 时钟的控制，写入到一个由 D 触发器组成的寄存器，也就是指令寄存器当中。\r\n\r\n\\8. \r\n\r\n\\9. \r\n\r\n在指令寄存器后面，我们可以再跟一个译码器。这个译码器的作用不再是用于寻址，而是把拿到的指令解析成opcode 和对应的操作数。\r\n\r\n\\10. \r\n\r\n\\11. \r\n\r\n当我们拿到对应的 opcode 和操作数，对应的输出线路就要连接 ALU，开始进行各种算术和逻辑运算。对应的计算结果，则会再写回到 D 触发器组成的寄存器或者内存当中。\r\n\r\n\\12. \r\n\r\n这里整个过程就大概是CPU的一条指令的执行过程。为了加快CPU指令的执行速度，CPU在发展过程中做了很多优化，例如流水线，分支预测，超标量，Hyper-threading，SIMD，多级cache，NUMA架构等,  这里主要关注Linux的调度系统。\r\n\r\n \r\n\r\n**CPU上下文**\r\n\r\nLinux 是一个多任务操作系统，它支持远大于 CPU 数量的任务同时运行。当然，这些任务实际上并不是真的在同时运行，而是因为系统在很短的时间内，将 CPU 轮流分配给它们，造成多任务同时运行的错觉。\r\n\r\n而在每个任务运行前，CPU 都需要知道任务从哪里加载、又从哪里开始运行，也就是说，需要系统事先帮它设置好 CPU 寄存器和程序计数器(Program Counter，PC)。\r\n\r\nCPU 寄存器，是 CPU 内置的容量小、但速度极快的内存。而程序计数器，则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。它们都是 CPU 在运行任何任务前，必须的依赖环境，因此也被叫做 CPU 上下文（执行环境）：\r\n\r\n \r\n\r\n \r\n\r\n![img](9.Linux调度系统全景指南(上篇).assets/wpsAB96.tmp.png) \r\n\r\n​               \r\n\r\n \r\n\r\n而这些保存下来的上下文，会存储在系统内核中（堆栈），并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。\r\n\r\n在Linux中，内核空间和用户空间是两种工作模式，操作系统运行在内核空间，而用户态应用程序运行在用户空间，它们代表不同的级别，而对系统资源具有不同的访问权限。\r\n\r\n这样代码（指令）执行存在不同的CPU上下文，而进行调度的时候，要进行相应的CPU上下文切换，Linux系统存在不同堆栈来保存CPU上下文，系统中每个进程都会拥有属于自己的内核栈，而系统中每个CPU都将为中断处理准备了两个独立的中断栈，分别是hardirq栈和softirq栈：\r\n\r\n \r\n\r\n![img](9.Linux调度系统全景指南(上篇).assets/wpsAB97.tmp.jpg) \r\n\r\n \r\n\r\nLinux系统调用CPU上下文切换堆栈结构：\r\n\r\n​    \r\n\r\n![img](9.Linux调度系统全景指南(上篇).assets/wpsAB98.tmp.png) \r\n\r\n \r\n\r\n· \r\n\r\n中断上下文：中断代码运行于内核空间，中断上下文即运行中断代码所需要的CPU上下文环境，需要硬件传递过来的这些参数，内核需要保存的一些其他环境（主要是当前被打断执行的进程或其他中断环境），这些一般都保存在中断栈中（x86是独立的，其他可能和内核栈共享，这和具体处理架构密切相关），在中断结束后，进程仍然可以从原来的状态恢复运行。\r\n\r\n· \r\n\r\n· \r\n\r\n进程上下文：进程是由内核来管理和调度的，进程的切换发生在内核态，进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。\r\n\r\n· \r\n\r\n· \r\n\r\n系统调用上下文：进程可以在内核空间和用户空间运行，分别称为进程的用户态和进程的内核态, 从用户态到内核态的转变需要通过系统调用来完成，需要进行CPU上下文切换，在执行系统调用时候，需要保存用户态的CPU上下文（用户态堆栈）到内核堆栈，然后加载内核态的CPU上下文。\r\n\r\n· \r\n\r\n· \r\n\r\nCPU处理器总处于以下状态中的一种：\r\n１、内核态，运行于进程上下文，内核代表进程运行于内核空间；\r\n２、内核态，运行于中断上下文，内核代表硬件运行于内核空间；\r\n３、用户态，运行于用户空间。\r\n\r\n· \r\n\r\n \r\n\r\n \r\n\r\n​               \r\n\r\n#                  **中断**\r\n\r\n![img](9.Linux调度系统全景指南(上篇).assets/wpsAB99.tmp.png) \r\n\r\n \r\n\r\n \r\n\r\n中断是由硬件设备产生的，而它们从物理上说就是电信号，之后，它们通过中断控制器发送给CPU，接着CPU判断收到的中断来自于哪个硬件设备（这定义在内核中），最后，由CPU发送给内核，内核来处理中断。\r\n\r\n \r\n\r\n![img](9.Linux调度系统全景指南(上篇).assets/wpsAB9A.tmp.jpg) \r\n\r\n硬中断简单处理流程：\r\n\r\n![img](9.Linux调度系统全景指南(上篇).assets/wpsAB9B.tmp.png) \r\n\r\n硬中断实现：中断控制器+中断服务程序\r\n\r\n中断框架设计(x86)：\r\n\r\n![img](9.Linux调度系统全景指南(上篇).assets/wpsAB9C.tmp.png) \r\n\r\nX86计算机的 CPU 为中断只提供了两条外接引脚：NMI 和 INTR。其中 NMI 是不可屏蔽中断，它通常用于电源掉电和物理存储器奇偶校验；INTR是可屏蔽中断，可以通过设置中断屏蔽位来进行中断屏蔽，它主要用于接受外部硬件的中断信号，这些信号由中断控制器传递给 CPU。当前x86 SMP架构主流都是采用多级I/O APIC（高级可编程中断控制器）中断系统。\r\n\r\nLocal APIC：主要负责传递中断信号到指定的处理器；\r\n\r\nI/O APIC：主要是收集来自 I/O 装置的 Interrupt 信号且在当那些装置需要中断时发送信号到本地 APIC；\r\n\r\n \r\n\r\n**中断分类**：\r\n\r\n中断可分为同步（**synchronous**）中断和异步（**asynchronous**）中断：\r\n\r\n· \r\n\r\n同步中断是当指令执行时由 CPU 控制单元主动产生，之所以称为同步，是因为只有在一条指令执行完毕后 CPU 才会发出中断，而不是发生在代码指令执行期间，比如系统调用，根据 Intel 官方资料，同步中断称为异常（**exception**），异常可分为故障（**fault**）、陷阱（**trap**）、终止（**abort**）三类。\r\n\r\n· \r\n\r\n· \r\n\r\n异步中断是指由其他硬件设备依照 CPU 时钟信号随机产生，即意味着中断能够在指令之间发生，例如键盘中断，异步中断被称为中断（**interrupt**），中断可分为可屏蔽中断（**Maskable interrupt**）和非屏蔽中断（**Nomaskable interrupt**）。\r\n\r\n· \r\n\r\n\\1. \r\n\r\n非屏蔽中断(Non-maskable interrupts,即NMI）：就像这种中断类型的字面意思一样，这种中断是不可能被CPU忽略或取消的。NMI是在单独的中断线路上进行发送的，它通常被用于关键性硬件发生的错误，如内存错误，风扇故障，温度传感器故障等。\r\n\r\n\\2. \r\n\r\n\\3. \r\n\r\n可屏蔽中断（Maskable interrupts）：这些中断是可以被CPU忽略或延迟处理的。当缓存控制器的外部针脚被触发的时候就会产生这种类型的中断，而中断屏蔽寄存器就会将这样的中断屏蔽掉。我们可以将一个比特位设置为0，来禁用在此针脚触发的中断。\r\n\r\n\\4. \r\n\r\n处理流程：\r\n\r\n![img](9.Linux调度系统全景指南(上篇).assets/wpsAB9D.tmp.jpg) \r\n\r\n区别：\r\n\r\n![img](9.Linux调度系统全景指南(上篇).assets/wpsAB9E.tmp.png) \r\n\r\n相同点：\r\n\r\n1.最后都是由CPU发送给内核，由内核去处理；\r\n\r\n2.处理程序的流程设计上是相似的。\r\n\r\n不同点：\r\n\r\n1.产生源不相同，陷阱、异常是由CPU产生的，而中断是由硬件设备产生的；\r\n\r\n2.内核需要根据是异常，陷阱，还是中断调用不同的处理程序；\r\n\r\n3.中断不是时钟同步的，这意味着中断可能随时到来；陷阱、异常是CPU产生的，所以，它是时钟同步的；\r\n\r\n4.当处理中断时，处于中断上下文中；处理陷阱、异常时，处于进程上下文中。\r\n\r\n \r\n\r\n**中断亲和：**\r\n\r\n· \r\n\r\n在 SMP 体系结构中，我们可以通过系统调用和一组相关的宏来设置 CPU 亲和力（CPU affinity），将一个或多个进程绑定到一个或多个处理器上运行。中断在这方面也毫不示弱，也具有相同的特性。中断亲和力是指将一个或多个中断源绑定到特定的 CPU 上运行；\r\n\r\n· \r\n\r\n· \r\n\r\n在 /proc/irq 目录中，对于已经注册中断处理程序的硬件设备，都会在该目录下存在一个以该中断号命名的目录 IRQ# ，IRQ# 目录下有一个 smp_affinity 文件（SMP 体系结构才有该文件），它是一个 CPU 的位掩码，可以用来设置该中断的亲和力， 默认值为 0xffffffff，表明把中断发送到所有的 CPU 上去处理。如果中断控制器不支持 IRQ affinity，不能改变此默认值，同时也不能关闭所有的 CPU 位掩码，即不能设置成 0x0；\r\n\r\n· \r\n\r\n· \r\n\r\n中断亲和好处是，在大量硬件中断场景，对于文件服务器、高流量 Web 服务器这样的应用来说，把不同的网卡 IRQ 均衡绑定到不同的 CPU 上将会减轻某个 CPU 的负担，提高多个 CPU 整体处理中断的能力；对于数据库服务器这样的应用来说，把磁盘控制器绑到一个 CPU、把网卡绑定到另一个 CPU 将会提高数据库的响应时间，优化性能。合理的根据自己的生产环境和应用的特点来平衡 IRQ 中断有助于提高系统的整体吞吐能力和性能；\r\n\r\n· \r\n\r\n \r\n\r\n**Linux系统常见中断分类**\r\n\r\n**时钟中断**：\r\n\r\n时钟芯片产生，主要工作是处理和时间有关的所有信息，决定是否执行调度程序以及处理下半部分。和时间有关的所有信息包括系统时间、进程的时间片、延时、使用CPU的时间、各种定时器，进程更新后的时间片为进程调度提供依据，然后在时钟中断返回时决定是否要执行调度程序。下半部分处理程序是Linux提供的一种机制，它使一部分工作推迟执行。时钟中断要绝对保证维持系统时间的准确性，“时钟中断”是整个操作系统的脉搏。\r\n\r\n**NMI中断**：\r\n\r\n外部硬件通过CPU的 NMI Pin 去触发（硬件触发），或者软件向CPU系统总线上投递一个NMI类型中断（软件触发），NMI中断的主要用途有两个：\r\n\r\n· \r\n\r\n用来告知操作系统有硬件错误（Hardware Failure），如内存错误，风扇故障，温度传感器故障等；\r\n\r\n· \r\n\r\n· \r\n\r\n用来做看门狗定时器，检测CPU死锁等；\r\n\r\n· \r\n\r\n**硬件IO中断**：\r\n\r\n大多数硬件外设IO中断，比如网卡，键盘，硬盘，鼠标，USB，串口等；\r\n\r\n**虚拟中断**：\r\n\r\nKVM里面一些中断退出和中断注入等，软件模拟中断；\r\n\r\n查看方式：cat /proc/interrupts\r\n\r\n![img](9.Linux调度系统全景指南(上篇).assets/wpsABAF.tmp.jpg) \r\n\r\nLinux系统中断处理\r\n\r\n![img](9.Linux调度系统全景指南(上篇).assets/wpsABB0.tmp.png) \r\n\r\n由于中断会打断内核中进程的正常调度运行，所以要求中断服务程序尽可能的短小精悍；但是在实际系统中，当中断到来时，要完成工作往往需要进行大量的耗时处理。因此期望让中断处理程序运行得快，并想让它完成的工作量多，这两个目标相互制约，诞生顶/底半部机制。\r\n\r\n**中断上半部分：**\r\n\r\n中断处理程序是顶半部——接受中断，它就立即开始执行，但只有做严格时限的工作。能够被允许稍后完成的工作会推迟到底半部去，此后，在合适的时机，底半部会被开终端执行。顶半部简单快速，执行时禁止部分或者全部中断。\r\n\r\n**中断下半部分：**\r\n\r\n底半部稍后执行，而且执行期间可以响应所有的中断。这种设计可以使系统处于中断屏蔽状态的时间尽可能的短，以此来提高系统的响应能力。顶半部只有中断处理程序机制，而底半部的实现有软中断，tasklet和工作队列等实现方式；\r\n\r\n \r\n\r\n**软中断**\r\n\r\n软中断作为下半部机制的代表，是随着SMP（share memory processor）的出现应运而生的，它也是tasklet实现的基础（tasklet实际上只是在软中断的基础上添加了一定的机制）。软中断一般是“可延迟函数”的总称，有时候也包括了tasklet（请读者在遇到的时候根据上下文推断是否包含tasklet）。它的出现就是因为要满足上面所提出的上半部和下半部的区别，使得对时间不敏感的任务延后执行，而且可以在多个CPU上并行执行，使得总的系统效率可以更高。它的特性包括：产生后并不是马上可以执行，必须要等待内核的调度才能执行。软中断不能被自己打断(即单个cpu上软中断不能嵌套执行)，只能被硬件中断打断（上半部）， 可以并发运行在多个CPU上（即使同一类型的也可以）。所以软中断必须设计为可重入的函数（允许多个CPU同时操作），因此也需要使用自旋锁来保护其数据结构。\r\n\r\n\r\n软中断的调度时机:\r\n\r\n\\1. \r\n\r\ndo_irq完成I/O中断时调用irq_exit。\r\n\r\n\\2. \r\n\r\n\\3. \r\n\r\n系统使用I/O APIC，在处理完本地时钟中断时。\r\n\r\n\\4. \r\n\r\n\\5. \r\n\r\nlocal_bh_enable，即开启本地软中断时。\r\n\r\n\\6. \r\n\r\n\\7. \r\n\r\nSMP系统中，cpu处理完被CALL_FUNCTION_VECTOR处理器间中断所触发的函数时。\r\n\r\n\\8. \r\n\r\n\\9. \r\n\r\nksoftirqd/n线程被唤醒时。\r\n\r\n\\10. \r\n\r\n \r\n\r\n\\11. \r\n\r\n \r\n\r\n\\12. \r\n\r\n**软中断内核线程**\r\n\r\n在 Linux 中，中断具有最高的优先级。不论在任何时刻，只要产生中断事件，内核将立即执行相应的中断处理程序，等到所有挂起的中断和软中断处理完毕后才能执行正常的任务，因此有可能造成实时任务得不到及时的处理。中断线程化之后，中断将作为内核线程运行而且被赋予不同的实时优先级，实时任务可以有比中断线程更高的优先级。这样，具有最高优先级的实时任务就能得到优先处理，即使在严重负载下仍有实时性保证。但是，并不是所有的中断都可以被线程化，比如时钟中断，主要用来维护系统时间以及定时器等，其中定时器是操作系统的脉搏，一旦被线程化，就有可能被挂起，后果将不堪设想，所以不应当被线程化。\r\n\r\n软中断优先在 irq_exit() 中执行，如果超过时间等条件转为 softirqd 线程中执行。满足以下任一条件软中断在 softirqd 线程中执行：\r\n\r\n在 irq_exit()->__do_softirq() 中运行，时间超过 2ms。\r\n\r\n在 irq_exit()->__do_softirq() 中运行，轮询软中断超过 10 次。\r\n\r\n在 irq_exit()->__do_softirq() 中运行，本线程需要被调度。\r\n\r\n注：调用 raise_softirq() 唤醒软中断时，不在中断环境中。\r\n\r\n \r\n\r\n**TASKLET**\r\n\r\n由于软中断必须使用可重入函数，这就导致设计上的复杂度变高，作为设备驱动程序的开发者来说，增加了负担。而如果某种应用并不需要在多个CPU上并行执行，那么软中断其实是没有必要的。因此诞生了弥补以上两个要求的tasklet。它具有以下特性：\r\n\r\na）一种特定类型的tasklet只能运行在一个CPU上，不能并行，只能串行执行。\r\n\r\nb）多个不同类型的tasklet可以并行在多个CPU上。\r\n\r\nc）软中断是静态分配的，在内核编译好之后，就不能改变。但tasklet就灵活许多，可以在运行时改变（比如添加模块时）。\r\n\r\ntasklet是在两种软中断类型的基础上实现的，因此如果不需要软中断的并行特性，tasklet就是最好的选择。也就是说tasklet是软中断的一种特殊用法，即延迟情况下的串行执行。\r\n\r\n \r\n\r\ntasklet有两种，**tasklet 和 hi-tasklet：**\r\n\r\n前者对应softirq_vec［TASKLET_SOFTIRQ］；\r\n\r\n后者对应softirq_vec[HI_SOFTIRQ]。只是后者排在softirq_vec[]的第一个，所以更早被执行;\r\n\r\n \r\n\r\n/proc/softirqs 提供了软中断的运行情况\r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n**# cat /proc/softirqs**CPU0         HI:   1  //高优先级TASKLET软中断    TIMER:  12571001  //定时器软中断   NET_TX:   826165  //网卡发送软中断   NET_RX:   6263015  //网卡接收软中断    BLOCK:   1403226  //块设备处理软中断BLOCK_IOPOLL:  0  //块设备处理软中断   TASKLET:  3752  //普通TASKLET软中断    SCHED:   0  //调度软中断   HRTIMER:  0  //当前已经没有使用     RCU:   9729155  //RCU处理软中断，主要是callback函数处理\r\n\r\n \r\n\r\n \r\n\r\n**工作队列**\r\n\r\n \r\n\r\n![img](9.Linux调度系统全景指南(上篇).assets/wpsABB1.tmp.png) \r\n\r\n \r\n\r\n工作队列(work queue)是Linux kernel中将工作推后执行的一种机制。软中断运行在中断上下文中，因此不能阻塞和睡眠，而tasklet使用软中断实现，当然也不能阻塞和睡眠，工作队列可以把工作推后，交由一个内核线程去执行—这个下半部分总是会在进程上下文执行，因此工作队列的优势就在于它允许重新调度甚至睡眠。\r\n\r\n \r\n\r\n![img](9.Linux调度系统全景指南(上篇).assets/wpsABB2.tmp.png) \r\n\r\n \r\n\r\nworkqueue 中几个角色关系：\r\n\r\n \r\n\r\n· \r\n\r\nwork ：工作/任务。\r\n\r\n· \r\n\r\n· \r\n\r\nworkqueue ：工作的集合。workqueue 和 work 是一对多的关系。\r\n\r\n· \r\n\r\n· \r\n\r\nworker ：工人。在代码中 worker 对应一个work_thread() 内核线程。\r\n\r\n· \r\n\r\n· \r\n\r\nworker_pool：工人的集合。worker_pool 和 worker 是一对多的关系。\r\n\r\n· \r\n\r\n· \r\n\r\npwq(pool_workqueue)：中间人 / 中介，负责建立起 workqueue 和 worker_pool 之间的关系。workqueue 和 pwq 是一对多的关系，pwq 和 worker_pool 是一对一的关系。\r\n\r\n· \r\n\r\n \r\n\r\n· \r\n\r\n通常，在工作队列和软中断/tasklet中作出选择，可使用以下规则：\r\n\r\n \r\n\r\n· \r\n\r\n如果推后执行的任务需要睡眠，那么只能选择工作队列。\r\n\r\n· \r\n\r\n· \r\n\r\n如果推后执行的任务需要延时指定的时间再触发，那么使用工作队列，因为其可以利用timer延时(内核定时器实现)。\r\n\r\n· \r\n\r\n· \r\n\r\n如果推后执行的任务需要在一个tick之内处理，则使用软中断或tasklet，因为其可以抢占普通进程和内核线程，同时不可睡眠。\r\n\r\n· \r\n\r\n· \r\n\r\n如果推后执行的任务对延迟的时间没有任何要求，则使用工作队列，此时通常为无关紧要的任务。\r\n\r\n· \r\n\r\n \r\n\r\n实际上，工作队列的本质就是将工作交给内核线程处理，因此其可以用内核线程替换。但是内核线程的创建和销毁对编程者的要求较高，而工作队列实现了内核线程的封装，不易出错，推荐使用工作队列。\r\n\r\n \r\n\r\n**中断上下文**\r\n\r\n中断代码运行于内核空间，中断上下文即运行中断代码所需要CPU上下文环境，需要硬件传递过来的这些参数，内核需要保存的一些其他环境（主要是当前被打断执行的进程或其他中断环境），这些一般都保存在中断栈中（x86是独立的，其他可能和内核栈共享，这和具体处理架构密切相关），在中断结束后，进程仍然可以从原来的状态恢复运行。\r\n\r\n \r\n\r\n是否处于中断中，在Linux中是通过preempt_count来判断的，具体如下：\r\n\r\n![img](9.Linux调度系统全景指南(上篇).assets/wpsABB3.tmp.png) \r\n\r\n\\#define in_irq()   (hardirq_count()) //在处理硬中断中\r\n\r\n\\#define in_softirq()   (softirq_count()) //在处理软中断中\r\n\r\n\\#define in_interrupt()  (irq_count()) //在处理硬中断或软中断中\r\n\r\n\\#define in_atomic()   ((preempt_count() & ~PREEMPT_ACTIVE) != 0) //包含以上所有情况\r\n\r\n \r\n\r\n**总结和注意的点：**\r\n\r\n \r\n\r\n1.Linux kernel的设计者制定了规则：\r\n\r\n· \r\n\r\n中断上下文不是调度实体，task才是【进程（主线程）或者线程】;\r\n\r\n· \r\n\r\n· \r\n\r\n优先级顺序：硬中断上下文 > 软中断上下文 > 进程上下文 ;\r\n\r\n· \r\n\r\n中断上下文（hardirq和softirq context）并不参与调度（暂不考虑中断线程化），它们是异步事件的处理机制，目标就是尽快完成处理，返回现场。因此，所有中断上下文的优先级都是高于进程上下文的。也就是说，对于用户进程（无论内核态还是用户态）或者内核线程，除非disable了CPU的本地中断，否则一旦中断发生，它们是没有任何能力阻挡中断上下文抢占当前进程上下文的执行的。\r\n\r\n \r\n\r\n2.Linux 将中断处理过程分成了两个阶段，也就是上半部和下半部：\r\n\r\n· \r\n\r\n上半部用来快速处理中断，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作，需要快速执行；\r\n\r\n· \r\n\r\n· \r\n\r\n下半部用来延迟处理上半部未完成的工作，通常以软中断方式运行，可以延迟执行。\r\n\r\n· \r\n\r\n \r\n\r\n· \r\n\r\n\\3. 硬中断和软中断（只要是中断上下文）执行的时候都不允许内核抢占（本文后续章节会讲内核抢占）。因为在中断上下文中,唯一能打断当前中断handler的只有更高优先级的中断，它不会被进程打断(这点对于softirq,tasklet也一样,因此这些bottom half也不能睡眠)；如果在中断上下文中睡眠，则没有办法唤醒它，因为所有的wake_up_xxx都是针对某个进程而言的，而在中断上下文中，没有进程的概念，没有相应task_struct(这点对于softirq和tasklet一样)，因此真的睡眠了，比如调用了会导致阻塞的例程，内核几乎会挂。\r\n\r\n \r\n\r\n4.硬中断可以被另一个优先级比自己高的硬中断“中断”，不能被同级（同一种硬中断）或低级的硬中断“中断”，更不能被软中断“中断”。软中断可以被硬中断“中断”，但是不会被另一个软中断“中断”。在一个CPU上，软中断总是串行执行。所以在单处理器上，对软中断的数据结构进行访问不需要加任何同步原语。\r\n\r\n \r\n\r\n5.关中断不会丢失中断，但是对于期间到来的多个相同的中断会合并成一个，即只处理一次；时钟中断中需要更新jieffis计数值，如果多个中断合成一个，为了减少影响jieffis值准确性，需要其他硬件时钟来矫正。\r\n\r\n \r\n\r\n**本期结束，我们下期再见！**\r\n\r\n![img](9.Linux调度系统全景指南(上篇).assets/wpsABB4.tmp.png) \r\n\r\n "},"4b48":function(n,r,e){"use strict";e.r(r),r["default"]='# ***\\*计算机网络硬核指南|网络设计核心思想\\****\r\n\r\n \r\n\r\n大家好，我是Alex，今天分享计算机网络硬核系列的第一篇：计算机网络通信的理解\r\n\r\n \r\n\r\n本篇主要是对计算机网络一些核心思想理解，属于内功心法，初学者适合入门，非初学者可以学习其设计思想，总之希望帮助大家提高对网络的理解；\r\n\r\n \r\n\r\n深入浅出Linux网络硬核指南\r\n\r\n \r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD354.tmp.jpg) \r\n\r\n***\\*本系列从网络通信理解到云计算网络等网络的不同应用角色（场景）入手，深入浅出讨论了网络\\*******\\*设计的核心思想，网络TCP/IP协议栈的设计，网络编程核心技术，网络性能优化，云网络核心技术，网络问题排障等，\\*******\\*计算机网络\\*******\\*是程序员或者IT工程师必须要掌握的技能，本系列目的就是让不同读者都能加深对网络认识，打好坚实的网络基础，不管是面试中遇到的网络问题，还是工作中遇到的网络问题，都能得心应手。\\****\r\n\r\n \r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD355.tmp.png) \r\n\r\n***\\*计算机网络通信的理解\\****\r\n\r\n \r\n\r\n \r\n\r\n1 计算机网络通信的本质\r\n\r\n \r\n\r\n1948年 ***\\*香农\\**** 在 《通信的数学理论》中写道:\r\n\r\n \r\n\r\n"通信的基本问题是在一点精确地或者近似的复现在另一个点所选取的信息"\r\n\r\n \r\n\r\n网络通信的本质是信息的传播：\r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD356.tmp.png) \r\n\r\n \r\n\r\n这里A与B之间的传播介质可以有很多不同层次的理解\r\n\r\n· \r\n\r\n可以是有线的（双绞线、电缆、光纤等）\r\n\r\n· \r\n\r\n· \r\n\r\n可以是无线的（蓝牙，WIFI，2345G等）\r\n\r\n· \r\n\r\n· \r\n\r\n可以是具体的（物理直连）\r\n\r\n· \r\n\r\n· \r\n\r\n可以是间接抽象的（跨网络）\r\n\r\n· \r\n\r\n \r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD357.tmp.png) \r\n\r\n \r\n\r\n我们可以看看计算机网络通信模型：\r\n\r\n \r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD358.tmp.png) \r\n\r\n \r\n\r\n这张图揭示计算机网络通信中的核心元素和要解决的核心问题：\r\n\r\n \r\n\r\n**发送端：数据的生产者**\r\n\r\n \r\n\r\n· \r\n\r\n信息编码\r\n\r\n· \r\n\r\n· \r\n\r\n数据发送\r\n\r\n· \r\n\r\n \r\n\r\n· \r\n\r\n**怎么发送数据？**\r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD359.tmp.png) \r\n\r\n要发送数据，需要借助网卡这种硬件，OS会按照RFC标准格式来封装数据，然后把数据传给网卡，网卡把数据转化为电信号/电磁波传输出去；\r\n\r\n \r\n\r\n**数据：信息载体**\r\n\r\n \r\n\r\n· \r\n\r\n01比特流\r\n\r\n· \r\n\r\n· \r\n\r\n编码格式\r\n\r\n· \r\n\r\n \r\n\r\n· \r\n\r\n**怎么定义数据格式？**\r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD369.tmp.png) \r\n\r\n大家按照标准来封装报文，整个链路所有网络设备都讲相同的“语言”，这样大家才可以自由交流；\r\n\r\n \r\n\r\n**传输通道：数据传输中转站**\r\n\r\n \r\n\r\n· \r\n\r\n数据存储\r\n\r\n· \r\n\r\n· \r\n\r\n数据运输\r\n\r\n· \r\n\r\n \r\n\r\n· \r\n\r\n**怎么转发数据？**\r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD36A.tmp.png) \r\n\r\n由于发送端和接收端：\r\n\r\n\\1. \r\n\r\n一个发送端可能要发给多个接收端，或者多对多场景，发送端端口有限，不能每个都单独通信，而且成本高，不易操作；\r\n\r\n\\2. \r\n\r\n\\3. \r\n\r\n两台设备长距离传输，不可能直接网线相连，性价比太低；\r\n\r\n\\4. \r\n\r\n \r\n\r\n\\5. \r\n\r\n这个时候数据需要中间节点来转发。中转节点一般是从一个网口进转到另外一个网口出，一般都是专有硬件处理，可以达到线速转发（像"直接连线一样速度"）；\r\n\r\n \r\n\r\n**接收端: 数据的消费者**\r\n\r\n \r\n\r\n· \r\n\r\n数据接收\r\n\r\n· \r\n\r\n· \r\n\r\n解码信息\r\n\r\n· \r\n\r\n \r\n\r\n· \r\n\r\n**怎么接收数据？**\r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD36B.tmp.png) \r\n\r\n同样要接收数据，需要借助网卡这种硬件，把电信号/电磁波信号转化为数据传给OS，OS会按照RFC标准格式来解析，最后把真正的数据交给应用；\r\n\r\n \r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD36C.tmp.png) \r\n\r\n \r\n\r\n计算机网络通信原理本质上是比较“简单”的，好理解，如果让你去设计一个全球网络通信系统，类似当今的互联网，你会怎么设计呢？你会考虑下面的问题吗？\r\n\r\n\\1. \r\n\r\n协议要怎么设计？\r\n\r\n\\2. \r\n\r\n\\3. \r\n\r\n报文的转发机制是什么？\r\n\r\n\\4. \r\n\r\n\\5. \r\n\r\n怎么保证系统不会挂掉（不可用）？\r\n\r\n\\6. \r\n\r\n\\7. \r\n\r\n怎么满足不同类型计算机通信要求？\r\n\r\n\\8. \r\n\r\n \r\n\r\n互联网获得的成功显而易见，它已经成为当今全球数字社会最重要的基础设施，改变我们生活方方面面，如今电脑，笔记本，电视，iPad，手机等都可以轻松上网，网络四通八达，信息随处可达，这背后到底是什么核心技术支撑这个世界最大网络通信系统。是不是你也很好奇，不妨让我们来看一看互联网是怎么解决这些问题的。\r\n\r\n \r\n\r\n2 计算机网络通信的核心思想\r\n\r\n \r\n\r\n**网络的复杂性**\r\n\r\n \r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD36D.tmp.jpg) \r\n\r\n \r\n\r\n· \r\n\r\n长距离传输，比如访问国外的网站，数据跨越几千公里，怎么保证数据可达？\r\n\r\n· \r\n\r\n· \r\n\r\n随着设备规模增大，数据流量增大，网络会不会崩溃？\r\n\r\n· \r\n\r\n· \r\n\r\n计算机性能各异，怎么保证网络的公平性？\r\n\r\n· \r\n\r\n· \r\n\r\n... \r\n\r\n· \r\n\r\n \r\n\r\n· \r\n\r\n那计算机网络是如何解决这些问题的呢？\r\n\r\n \r\n\r\n## ***\\*分布式思想--无连接分组交换\\****\r\n\r\n \r\n\r\n在此之前，数据通信是基于电路交换的想法，就像在传统的电话网络一样，在通话前先建立专有线路，时延小，适合电话实时通信场景，电路交换体现了一种集中管理思想，所有通信资源都集中分配管理。但适合计算机网络通信吗？ \r\n\r\n \r\n\r\n \r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD36E.tmp.png) \r\n\r\n数据通信的技术演进\r\n\r\n​                  \r\n\r\n**电路交换**（英语：Circuit Switching）是相对于报文交换（或称分组交换）的一个概念。电路交换要求必须首先在通信双方之间建立连接通道。在连接建立成功之后，双方的通信活动才能开始。通信双方需要传递的信息都是通过已经建立好的连接来进行传递的，而且这个连接也将一直被维持到双方的通信结束。在某次通信活动的整个过程中，这个连接将始终占用着。连接建立开始时，通信系统分配给它的资源（通道、带宽、时隙、码字等等），这也体现了电路交换区别于报文交换的本质特征。\r\n\r\n \r\n\r\n电路交换虽然通信实时性高但不适合计算机网络通信:\r\n\r\n· \r\n\r\n建立专有连接代价高，需要整条链路每个节点分配资源，计算机网络通信场景复杂，高频低流，不好预估资源，资源管理会很复杂；\r\n\r\n· \r\n\r\n· \r\n\r\n电路交换采用时分复用的原理，完全无法应对现代互联网的流量突发，同时将会有大量的能量被空闲时隙浪费，链路资源利用不高，可以说，传统的电信网络是不可扩展的；\r\n\r\n· \r\n\r\n \r\n\r\n报文交换提高了通信线路的利用率，不需要建立连接，但也不适合计算机网络通信:\r\n\r\n· \r\n\r\n报文交换是以报文为数据交换的单位，报文携带有目标地址、源地址等信息，报文整个地发送，一次一跳，在交换结点采用存储转发的传输方式，电报通信采用这种传输技术，由于报文长度没有限制，而每个中间结点都要完整地接收传来的整个报文，当输出线路不空闲时，还可能要存储几个完整报文等待转发，要求网络中每个结点有较大的缓冲区。为了降低成本，减少结点的缓冲存储器的容量，有时要把等待转发的报文存在磁盘上，进一步增加了传送时延；\r\n\r\n· \r\n\r\n \r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD37F.tmp.png) \r\n\r\n \r\n\r\n最终计算机网络采用了分组交换技术：\r\n\r\n· \r\n\r\n基于报文交换，将报文划分为更小的数据单位：报文分组（也称为段、包、分组），分组交换比报文交换的时延小，尤其适合于计算机之间的突发式的数据通信；\r\n\r\n· \r\n\r\n· \r\n\r\n分组交换采用分布式思想，每台电脑都是一个“节点”(node)，每个节点都彼此相联，形成纵横交错的网状结构。此种网络结构中，不存在中央的概念，而且单个节点的重要性大大降低，每个节点只关心与自己相邻节点，不会考虑整个链路，这样新节点更容易加入网络，而新节点加入，增加路径选择，又加强了网络的容错性；\r\n\r\n· \r\n\r\n \r\n\r\n· \r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD380.tmp.png) \r\n\r\n· \r\n\r\n \r\n\r\n· \r\n\r\n \r\n\r\n· \r\n\r\n不需要建立连接，数据报文独立于网络链路之上（每个报文都会携带地址信息），链路可复用，资源利用率高；\r\n\r\n· \r\n\r\n· \r\n\r\n所有转发节点采用存储转发模式，网络节点仅仅负责交换数据包，业务响应的功能则被推送到网络边缘的设备上，由上层来保证数据完整性，这样极大减轻网络节点设计；\r\n\r\n· \r\n\r\n· \r\n\r\n分组交换采用统计复用原则，意味着在一个处理节点，数据包分组的到达的分布是符合泊松分布，再结合存储转发机制，节点可缓存一定量报文，从而有效避免处理不及时导致的丢包，保证了整个网络稳定和平衡。\r\n\r\n· \r\n\r\n \r\n\r\n分组交换（英语：Packet switching）是一种相对于电路交换的通信范例，分组（又称消息、或消息碎片）在节点间单独路由，不需要在传输前先建立通信路径。分组交换是数据通信中一种新的且重要的概念，现在是世界上互联网通讯、数据和语音通信中最重要的基础。在此之前，数据通信是基于电路交换的想法，就像在传统的电话电路一样，在通话前先建立专有线路，通信双方要在电路的两端。分组交换技术是在1960年代末出现的，当时美国高级研究计划局（简称ARPA）为实现远程计算机之间的信息交换，资助建设一个试验性的网络，该网络被称为ARPANET。ARPANET的主要研究成果之一就是开发一种新的网络协议，在ARPANET网络上对话必须使用这种网络协议。该协议采用一种新的网络信息传输技术，这就是分组交换技术。\r\n\r\n \r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD381.tmp.png) \r\n\r\n计算机网络通信\r\n\r\n \r\n\r\n理解分组交换这种设计对我们理解网络有什么好处？\r\n\r\n· \r\n\r\n整个互联网就是一个大型分布式系统，TCP/IP协议就是站在这种视角来设计的, 拥塞控制算法通过自我退让机制（非自私思想，我为人人，人人为我），保障整个网络公平性和稳定性；\r\n\r\n· \r\n\r\n· \r\n\r\n网络设备在转发层面上只关心与它相连节点，节点根据转发规则，按照统一转发机制路由最长匹配，把数据包扔给下一跳设备，而配置是管理员配置或者动态学习的，网络节点只是转发工具，上层控制转发行为；\r\n\r\n· \r\n\r\n· \r\n\r\n网络节点转发行为不是集中控制的，没有上帝视角，但网络最终可以实现数据转发，这里面反映出一些哲学思考，网络可以通过节点周围关系连接任何一个未知节点（六度理论），这或许就是分组交换能够成功的底层理论；\r\n\r\n· \r\n\r\n· \r\n\r\n## ***\\*分层思想--网络协议分层设计\\****\r\n\r\n \r\n\r\n**网络协议要怎么设计？** \r\n\r\n \r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD382.tmp.jpg) \r\n\r\n \r\n\r\n· \r\n\r\n分层好处是降低耦合，上层不关心底层实现，只关心底层提供服务（接口）；\r\n\r\n· \r\n\r\n· \r\n\r\n这样层与层之间通信就可以标准化。标准化意味着层与层之间独立性。，可以独自发展，这样设计带来很大灵活性和扩展性，比如传输层有TCP/UDP/DCCP/STCP等，网络层有IPv4/IPv6等, 数据链路层有以太网，VLAN，WIFI，无线3G，4G，5G协议等；\r\n\r\n· \r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD383.tmp.png) \r\n\r\n· \r\n\r\n· \r\n\r\n网络是异构复杂的，分层可以整合异构网络，向上层提供统一视图，比如中间IP层做了适配，传输层和链路层互不纠缠，可以独立发展；\r\n\r\n· \r\n\r\n· \r\n\r\n分层模式拥有递归特性，该特性允许逻辑意义的任意封装和再封装，比如overlay网络，VPN，各种tunnel等，使网络扩展性大大增强；\r\n\r\n· \r\n\r\n \r\n\r\n理解了计算机网络的分层设计对我们理解网络有什么好处？\r\n\r\n \r\n\r\n\\1. 每一层只关心自己逻辑执行，不会受到其他层的影响\r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD384.tmp.png) \r\n\r\n \r\n\r\n\\2. 网络问题可以从上而下或者从下而上分层分析\r\n\r\n \r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD385.tmp.jpg) \r\n\r\n \r\n\r\n报文分层封装处理：\r\n\r\n​     ![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD386.tmp.png)\r\n\r\n应用层：需要用socket编程接口发送应用数据；\r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD387.tmp.png) \r\n\r\n传输层（四层）：四层采用TCP/UDP等传输协议进行数据传输；\r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD388.tmp.png) \r\n\r\n网络层（三层）：三层主要是实现路由转发；\r\n\r\n路由表主要是存储路由条目，IP层采用最长匹配算法，查询路由再再转发：\r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD399.tmp.png) \r\n\r\n链路层（二层）： \r\n\r\n根据接口对应的链路层协议(如以太网)组装报文：\r\n\r\n邻居表主要是保存目的IP地址对应的mac地址，mac地址是2层以太网节点标识，一般通过ARP协议报文动态学习，也可以静态配置指定：\r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD39A.tmp.png) \r\n\r\n记录在ARP表里面：\r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD39B.tmp.png) \r\n\r\nARP表主要是给报文添加mac头部：\r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD39C.tmp.png) \r\n\r\n二层转发报文：\r\n\r\n主要二层设备（桥，交换机等）用来根据目的mac地址查找转发端口，实现二层转发；\r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD39D.tmp.png) \r\n\r\n物理层： 主要是网卡驱动，网卡芯片处理，把数据转化电或者光信息或者无线信号；\r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD39E.tmp.png) \r\n\r\n网络分层分析可以参考： [云网络丢包故障定位全景指南](#wechat_redirect)\r\n\r\n\r\n\r\n## ***\\*公平思想--传输控制\\****\r\n\r\n \r\n\r\n随着互联网规模越来越大，计算机处理性能提高，大量数据包流向网络，必然会加剧网络拥塞，当网络发生拥塞时，一般会出现数据丢失，时延增加，吞吐量下降，严重时甚至会导致“拥塞崩溃“。\r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD39F.tmp.png) \r\n\r\n拥塞控制需要确保网络能够承载用户提交的通信量，是一个全局性问题，涉及主机、路由器等很多因素：互联网采用TCP拥塞控制算法来控制系统的容量，核心思想是主动退让机制，发现网络拥塞（丢包或者延时加大），就主动减少发包量，我为人人，人人为我，最终解除拥塞，达到共赢局面:![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD3A0.tmp.png)\r\n\r\n在终端系统上通常根据接受到的ACK(Acknowledge character)确认包中包含的信息来调整拥塞控制窗口的大小，进而控制TCP连接的发送速率，譬如：TCP Tahoe, TCP Reno, TCP Vegas, TCP NewReno, TCP BIC, TCP CBIC, BBR等算法；\r\n\r\n \r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD3A1.tmp.png) \r\n\r\n \r\n\r\n在网络中间设备上(路由器、防火墙、交换机等)的拥塞控制算法（AQM-Active Queue Management-主动队列管理）通常根据设备中的缓存队列长度信息对网络拥塞控制程度进行判断，并将拥塞控制信息显示或隐式地告知端点，端点根据获得的拥塞控制信息对自身发送速率进行调整，譬如：FIFO, RED(Random Early Detection), ECN(Explicit Congestion Notification), FQ(Fair Queuing)等算法；\r\n\r\n \r\n\r\n道路交通系统是一个典型的统计复用的分组交换系统，其实早在TCP/IP分组交换网络之前，道路交通系统就已经存在了好几千年了，我们可以用道路交通系统一些问题来类比分析TCP/IP网络中出现的问题，比如道路拥堵类比网络拥塞，可以帮助我们更容易理解网络。\r\n\r\n \r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD3A2.tmp.png) \r\n\r\n \r\n\r\n## ***\\*总结\\****\r\n\r\n \r\n\r\n这里主要提到了互联网通信的三种设计思想：\r\n\r\n \r\n\r\n分布式思想--分组交换：提供足够简单且灵活的分组转发逻辑，实现数据报文在系统中稳定转发，网络节点转发行为不是集中控制的，没有上帝视角，但网络最终可以实现数据转发，反映出网络设计参考一些哲学思想，网络可以通过节点周围关系连接任何一个未知节点（六度理论），这或许就是分组交换能够成功的底层理论。\r\n\r\n \r\n\r\n分层思想--网络协议分层设计：应用层高度可扩展，应用程序爆炸式增长，得益于网络的分层模型；\r\n公平思想--传输控制：TCP的拥塞控制使网络更加公平和稳定，提高系统的容错率，让系统可以持续正常运转；\r\n从技术上看，“无连接分组交换”这一“革命性的创造”为互联网带来了胜利。而TCP/IP分层模型的“系统化和完备化”使得互联网进入了蓬勃发展的商业化发展阶段。互联网的设计原理保证了TCP/IP的成功，使其成为了当今信息社会最重要的基础设施。\r\n\r\n一些应对复杂性设计思想：\r\n\r\n· \r\n\r\n底层实现一套稳定运行的机制（转发机制）: 比如三层路由最长匹配转发机制；二层mac地址转发机制（bridge 转发机制）；\r\n\r\n· \r\n\r\n· \r\n\r\n上层实现可配置策略（各种转发规则）: 比如路由表，邻居表，mac转发表等；\r\n\r\n· \r\n\r\n· \r\n\r\n分层设计经典思想一致延续至今，加一层的思想可以实现解耦，也可以实现关联，增强了设计的扩展性；\r\n\r\n· \r\n\r\n· \r\n\r\n越简单且可扩展的设计越能应对未来的变化；\r\n\r\n· \r\n\r\n \r\n\r\n3 计算机网络技术演进\r\n\r\n \r\n\r\n推动网络不断向前发展的核心诉求：\r\n\r\n \r\n\r\n**网络通信场景不断扩展**\r\n\r\n \r\n\r\n![img](24.计算机网络硬核指南网络设计核心思想.assets/wpsD3A3.tmp.png) \r\n\r\n \r\n\r\n人们不断扩展网络通信场景：局域网，城域网，广域网，无线网络，互联网，移动互联网，工业互联网，云计算网络，物联网，车联网等；\r\n\r\n \r\n\r\n \r\n\r\n**网络容量和用户爆发式增长**\r\n\r\n \r\n\r\n从Web1.0、Web2.0、到移动互联网发展，社交，游戏，短视频，直播等应用流行，互联网流量暴涨几十倍，对网络的支撑能力带来巨大挑战，倒逼网络不断进行向前发展\r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n· \r\n\r\nTCP/IP协议不断发展: 从TCP拥塞控制算法Reno到BBR，从TCP到QUIC，从http1.0到http3.0，从IPv4到IPv6等等；\r\n\r\n· \r\n\r\n· \r\n\r\n网络架构演进：从分布式网络->中心化网络演进，SDN兴起；\r\n\r\n· \r\n\r\n· \r\n\r\n移动网络技术演进：2G->3G->4G->5G->6G...\r\n\r\n· \r\n\r\n· \r\n\r\n传输网络技术演进：PDH→SDH->WDM->OTN\r\n\r\n· \r\n\r\n· \r\n\r\n...\r\n\r\n· \r\n\r\n \r\n\r\n**计算机网络安全问题**\r\n\r\n \r\n\r\n计算机网络安全是当今世界的重要关注点。黑客一直在使用各种创新技术窃取重要信息。现在人们在利用网络空间进行日常活动，对网络空间的依赖性非常高。无论人们被窃取的是业务和技术机密，还是金融系统，威胁性都是致命的。\r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n· \r\n\r\n防火墙技术演进：包防火墙->状态防火墙->应用防火墙->...\r\n\r\n· \r\n\r\n· \r\n\r\n加密技术演进：对称加密->非对称加密->量子加密\r\n\r\n· \r\n\r\n· \r\n\r\n安全领域演进：传统网络安全->移动网络安全->云计算网络安全->云原生网络安全\r\n\r\n· \r\n\r\n· \r\n\r\n...\r\n\r\n· \r\n\r\n \r\n\r\n以上是我对网络的部分理解，主要是核心思想理解，希望能够帮助大家更好理解网络，也为该系列后续文章做一些铺垫，希望大家喜欢\r\n\r\n \r\n\r\n参考：\r\n\r\n***\\*《The design philosophy of the DARPA internet protocols》\\****\r\n\r\n ***\\*https://wikipedia.org\\****\r\n\r\n***\\*《Congestion Avoidance and Control》\\****\r\n\r\n***\\*《网络是怎样连接的》\\****\r\n\r\n '},"4f2c":function(n,r,e){"use strict";e.r(r),r["default"]="# ***\\*深入理解程序的本质\\****\r\n\r\n极客重生 [极客重生](https://mp.weixin.qq.com/javascript:void(0);) 8/23\r\n\r\nhi ,大家好，这篇文章源于知乎一些问题，真正的技术高手，无非是对计算机程序本质的深刻理解，水平高低，取决于你对计算机的理解深度，这句话，大家可以慢慢体会，很多编程问题，写代码有bug，解决bug慢等问题，本质上来说，都是你对计算机理解不够深刻导致的。\r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n**导读**\r\n\r\n \r\n\r\n很久很久以前（其实也没有那么久，毕竟计算机科学的发展也才那么几十年而已），程序员都是用二进制编码的，后来开始用汇编语言，今天，事情发生了很大的变化，人们开始使用高级语言，或者说已经工作在更高的抽象层次上了。你可能会有疑惑：为什么今天我们还要花力气来学习机器级别的编程方式呢？\r\n\r\n \r\n\r\n![img](19.深入理解程序的本质.assets/wps41F9.tmp.png) \r\n\r\n \r\n\r\n \r\n\r\n这里的机器级编程包含了两种含义**，一个是可以直接在机器上运行的二进制指令**，**另一个是汇编语言（就是编译器产生的代码）**，对于我们来说，两者都属于机器级别，两个概念可以互换，它们之所以很重要，因为它们是连接你所编写的高级语言代码和机器之间的纽带，是实实在在的基石，理解这里面的一些底层工作的原理还是很有必要的，实际上这也是CSAPP区别于其他课程的一个显著点，但这并不是要求你徒手写汇编代码（现代编译器可能比你更精通这一点，或许也比你更有耐心），只是希望当你遇到需要阅读一点点汇编代码的时候不至于惊慌无措，当然了，如果你想成为一名系统程序员或者想成为一名黑客，那么这个话题就很重要了。\r\n\r\n \r\n\r\n历史上出现过很多知名的指令集架构，比如Alpha， SPARC，PowerPC，MIPS等，但是今天最流行的指令集架构是**x86(-64)，ARM，RISC-V**，本课程把重点放在了英特尔x86-64上，毕竟讲课的话总是限定在某种处理器上讲起来也相对容易一些嘛，**指令集架构（ISA）的地位非常重要，就是在那里，软件遇见了硬件！**\r\n\r\n \r\n\r\n![img](19.深入理解程序的本质.assets/wps41FA.tmp.png) \r\n\r\n \r\n\r\n \r\n\r\n历史上出现过很多成功的指令集架构，但是时过境迁，当今主流的指令集架构，如下图所示：\r\n\r\n \r\n\r\n![img](19.深入理解程序的本质.assets/wps41FB.tmp.png) \r\n\r\n \r\n\r\n\r\n\r\n------\r\n\r\n\r\n\r\n \r\n\r\n**基本概念**\r\n\r\n \r\n\r\n**Instructure Set Architecture**：指令集架构 (包括指令规格，寄存器等)，简称ISA，它是软硬件之间的“合同”\r\n\r\n**Mircoarchitecture**：指令集架构的具体实现方式 (比如流水线级数，缓存大小等)，它是可变的\r\n\r\n**Machine Code**：机器码，也就是机器可以直接执行的二进制指令\r\n\r\n**Assembly Code**：汇编码，也就是机器码的文本形式 (主要是给人类阅读)\r\n\r\n \r\n\r\n![img](19.深入理解程序的本质.assets/wps420C.tmp.png) \r\n\r\n从汇编码/机器码的角度来看计算机系统\r\n\r\n \r\n\r\n**程序员的角度 vs 微体系结构 （程序员可见 vs 程序员不可见）**，在CPU方面，开放给程序员的编程接口只是PC，寄存器，条件码，其他的内部信息比如CPU内部的Cache对程序员来说都是不可见的，内存角度来讲，大部分的ISA支持字节寻址方式 (即Byte寻址，实际上还有Bit寻址，32-bit寻址，64-bit寻址等，只是比较少见而已)，绝大多数的ISA具有确定的大小端模式 (有些ISA可变)。\r\n\r\n \r\n\r\n**编译过程**\r\n\r\n \r\n\r\n其次，理解C程序的编译过程：源代码 -> 编译 -> 汇编 -> 链接 -> 可执行文件 -> 装载 -> 执行\r\n\r\n \r\n\r\n![img](19.深入理解程序的本质.assets/wps420D.tmp.png) \r\n\r\n \r\n\r\n \r\n\r\n以下是x86-64平台编译后的汇编码和机器码，注意：不同的平台（ISA不同）和不同的编译器会产生完全不同的机器码，但是无论如何大家可以看到最终产生的机器码无非就是0和1的组合，关键在于机器知道该怎样来解释它们。\r\n\r\n \r\n\r\n![img](19.深入理解程序的本质.assets/wps420E.tmp.png) \r\n\r\n \r\n\r\n \r\n\r\n![img](19.深入理解程序的本质.assets/wps420F.tmp.png) \r\n\r\n \r\n\r\n**重要思想**：程序就是一系列（被编码了的）字节序列 （看上去和数据一模一样），这就是所谓的冯诺依曼结构计算机，即程序存储型计算机，冯诺依曼结构由于EDVAC项目的技术报告分发而开始被人们熟知。\r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n**学习方式**\r\n\r\n \r\n\r\n机器级编程-I：基础\r\n\r\n \r\n\r\n**历史**：Intel在开发自己的64位指令集架构 (Itanium) 的时候遭遇了失败，部分原因在于它和之前的 IA32 指令集不兼容，而且性能也达不到预期，最终不得不转而采用AMD的64位指令集x64-86.\r\n\r\n \r\n\r\n**重点提示**：了解 Intel x86-64的寄存器组（下图所示），基础指令集，包括数据传送（包括压栈和出栈），算术和逻辑运算，特别需要留意<源操作数>和<目的操作数>在具体指令中的方向！\r\n\r\n \r\n\r\n学习C语言和x86汇编语言之间的关系的一个绝佳方式就是逆向工程，你可以使用GNU提供的工具例如 **objdump** 或者 **GDB** 查看反汇编代码来学习！\r\n\r\n \r\n\r\n![img](19.深入理解程序的本质.assets/wps4210.tmp.png) \r\n\r\n \r\n\r\n \r\n\r\n机器级编程-II：控制\r\n\r\n \r\n\r\n**重点提示**：理解条件码 (**CF**，ZF，SF，**OF**)，分支（Conditional Move => 分支预测相关），循环\r\n\r\n \r\n\r\n![img](19.深入理解程序的本质.assets/wps4211.tmp.png) \r\n\r\n \r\n\r\n \r\n\r\n**备注**：编译器比你想象的要聪明，例如，你写的switch语句可能会被优化为 jump table，还会消除无用的语句(Dead code elimination)等，汇编代码有时候不仅仅是C代码的直译，也就是说：编译器可以执行不同程度的优化，那么你很有可能会一下子很难理解编译器生成的汇编代码，请不要害怕，多点耐心，试着自己分析看看，说不定你会恍然大悟，赞叹编译器的聪明之处！关于编译器的优化在第5章会有更多的探讨。\r\n\r\n \r\n\r\n![img](19.深入理解程序的本质.assets/wps4212.tmp.png) \r\n\r\n \r\n\r\n机器级编程-III：过程\r\n\r\n \r\n\r\n**重点提示**：函数调用的过程 ：控制权转移 (含返回地址的保存)，参数传递，内存管理 (栈)，控制权返回.\r\n\r\n \r\n\r\n**备注**：无论何种 ISA，函数调用过程大同小异，只是在具体的指令或者在ABI (Application Binary Interface) 层面略有不同而已，比如不同的ISA会有不同的 Calling Convention，也就是调用规则，它是调用者 Caller 和被调者 Callee 之间的某种合约，比如哪些寄存器用来传递参数，哪些寄存器用来存放返回值，哪些寄存器调用者/被调者可以放心使用等 (Caller Saved & Callee Saved)，理解Prologue & Epilogue！\r\n\r\n \r\n\r\n![img](19.深入理解程序的本质.assets/wps4222.tmp.png) \r\n\r\n \r\n\r\n请务必理解对应的投影片中的内容，如果你真的理解了递归函数的调用过程，那么恭喜你，你学会了 !\r\n\r\n \r\n\r\n机器级编程-IV：数据\r\n\r\n \r\n\r\n**Bits, Bytes, and Integers**\r\n\r\n**道生一，一生二，二生三，三生万物****：**\r\n\r\n \r\n\r\n![img](19.深入理解程序的本质.assets/wps4223.tmp.png) \r\n\r\n \r\n\r\n**重点提示**：理解C语言中的数组和指针在机器级是如何表示的，理解字节对齐的作用 （有些指令集架构是强制要求字节对齐的，即使不要求也应该做到字节对齐，不仅能节省空间，更重要的是会影响访问性能）\r\n\r\n \r\n\r\n![img](19.深入理解程序的本质.assets/wps4224.tmp.png) \r\n\r\n \r\n\r\n机器级编程-V：进阶\r\n\r\n \r\n\r\n**重点提示**：理解典型的内存布局 (栈，共享库，堆，代码段，数据段 ...)，如下图所示：\r\n\r\n \r\n\r\n![img](19.深入理解程序的本质.assets/wps4225.tmp.png) \r\n\r\n \r\n\r\n理解缓冲区溢出导致的安全问题，以下是一个简单的示例程序（gcc编译参数：-fno-stack-protector）：\r\n\r\n备注：我们这里讲缓冲区溢出的时候，重点讨论的是**栈**溢出的问题，实际上还有**堆**溢出的漏洞。\r\n\r\n \r\n\r\n![img](19.深入理解程序的本质.assets/wps4226.tmp.png)简单的示例程序（运行gets前的栈）\r\n\r\n \r\n\r\n![img](19.深入理解程序的本质.assets/wps4227.tmp.png) \r\n\r\n简单的示例程序（运行gets后的栈：两种情况）\r\n\r\n \r\n\r\n![img](19.深入理解程序的本质.assets/wps4228.tmp.png) \r\n\r\n \r\n\r\n \r\n\r\n**如何避免缓冲区溢出问题？**\r\n\r\n \r\n\r\n\\1. **程序员层面**，避免调用不安全的函数，比如，fgets代替gets，strncpy代替strcpy\r\n\r\n2**. 操作系统层面**，增加保护机制，例如ASLR (地址空间随机化)，让攻击者难以猜测地址（依然可以攻破）\r\n\r\n实际上，今天的绝大多数系统在默认情况下是启用ASLR的，可以通过以下命令查看**：**\r\n\r\n \r\n\r\n![img](19.深入理解程序的本质.assets/wps4239.tmp.jpg) \r\n\r\n \r\n\r\n· \r\n\r\n0 没有随机化，也就是关闭 ASLR\r\n\r\n· \r\n\r\n· \r\n\r\n1 保留的随机化，其中共享库、栈、mmap 以及 VDSO 将被随机化\r\n\r\n· \r\n\r\n· \r\n\r\n2 完全的随机化，在 1 的基础上，通过 brk() 分配的内存空间也将被随机化\r\n\r\n· \r\n\r\n \r\n\r\n· \r\n\r\n**注意**：在用GDB调试时，可以通过set disable-randomization命令开启或者关闭地址空间随机化，默认是关闭随机化的，也就是on状态，具体参见：https://sourceware.org/gdb/onlinedocs/gdb/Starting.html\r\n\r\n \r\n\r\n![img](19.深入理解程序的本质.assets/wps423A.tmp.png) \r\n\r\n \r\n\r\n \r\n\r\n\\3. **硬件层面**，对栈区增加权限保护：**NX （**No-eXecute**），**gcc编译选项 -z  **execstack**/noexecstack\r\n\r\n \r\n\r\n**思考**：如何绕过NX？一种方式是ROP（就是你在Attack Lab实验中的 Phase4~Phase5），另外一种攻击方式是 **ret2libc**（不能返回到我写的代码，返回libc的代码总可以吧 ... 这种方式需要自己构建栈帧 ...）\r\n\r\n \r\n\r\n![img](19.深入理解程序的本质.assets/wps423B.tmp.png) \r\n\r\n \r\n\r\n \r\n\r\n\\4. **编译器层面**，缓冲区溢出的检测（Stack Guard），又被称作栈“金丝雀”（Canary）,故事：人们发现将金丝雀可以检测一氧化碳的浓度，于是煤矿工人将金丝雀带入煤矿，一旦超标，鸟类会在矿工面前死去或者出现生病的症状，这可以作为有毒气体（要是一氧化碳）的预警信号。\r\n\r\n \r\n\r\n![img](19.深入理解程序的本质.assets/wps423C.tmp.png) \r\n\r\n思考：“金丝雀值” 应该存放在哪里？\r\n\r\n \r\n\r\n还是前面那个简单的示例程序（gcc编译参数：-fstack-protector）：\r\n\r\n \r\n\r\n![img](19.深入理解程序的本质.assets/wps423D.tmp.png) \r\n\r\n缓冲区溢出检测的例子（gcc编译参数：-fstack-protector）\r\n\r\n \r\n\r\n备注：所谓 “道高一尺魔高一丈”，黑客会利用其它的机器级别的特性来进行针对性的攻击，例如，ROP攻击， ROP全称Return-Oriented Programming，就是对栈上的返回地址进行利用的一种攻击方式，ROP的攻击方法是借用代码段里面的多个片段指令拼凑成一段有效的逻辑，从而达到攻击的目的，片段指令一般称之为Gadget，即利用Gadget + retq，我们可以利用多个retq跳到不同的Gadget来实现我们完整的攻击流。\r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n![img](19.深入理解程序的本质.assets/wps423E.tmp.png) \r\n\r\n \r\n\r\nC语言复习\r\n\r\n \r\n\r\n![img](19.深入理解程序的本质.assets/wps423F.tmp.png) \r\n\r\n \r\n\r\n \r\n\r\n**实验解读（*****\\*Bomb Lab\\******）**\r\n\r\n \r\n\r\n提示用户输入正确的字符串来拆掉炸弹，如果任何一个不正确，炸弹就会“爆炸”，你必须通过逆向工程来解除炸弹，这会让你理解汇编语言，学习如何使用GDB来调试程序，设计得很有意思。\r\n\r\n \r\n\r\n实验相关说明（CMU的助教讲解）：**Bomb Lab实验说明**\r\n\r\n \r\n\r\n![img](19.深入理解程序的本质.assets/wps4250.tmp.png) \r\n\r\n \r\n\r\n \r\n\r\n请首先学习和熟悉GDB的使用方法：\r\n\r\nhttp://csapp.cs.cmu.edu/3e/docs/gdbnotes-x86-64.pdf\r\n\r\n然后学习一些汇编的基础知识：\r\n\r\nIntel 64 and IA-32 Architectures Software Developer's Manuals\r\n\r\n经过了6个步骤，拆除炸弹后大概是这个样子（实际上还隐藏了一个彩蛋，这里没有画出）\r\n\r\n \r\n\r\n![img](19.深入理解程序的本质.assets/wps4251.tmp.png) \r\n\r\n \r\n\r\n \r\n\r\n**实验解读（****Attack Lab****）**\r\n\r\n \r\n\r\n要求大家利用Code Injection Attacks （代码注入攻击）和 ROP（返回导向的编程）这两种方法来攻击程序，对现有程序进行控制流劫持，执行非法程序代码，模拟当黑客的感觉，同时学会如何预防这些攻击手段。\r\n\r\n \r\n\r\n实验相关说明（CMU的助教讲解）：Attack Lab实验说明 （前3题是CIA实验，后2题是ROP实验）\r\n\r\n开始实验之前，请仔细阅读实验说明（讲义）：\r\n\r\nhttp://csapp.cs.cmu.edu/3e/labs.html\r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n![img](19.深入理解程序的本质.assets/wps4252.tmp.png) \r\n\r\n \r\n\r\n**温馨提示**：计算机安全中的不少攻击和防御方法表面上看起来不同， 但如果深入研究的话，会发现它们其实是相似的或有关联，反过来，有些内容看起来相似， 本质上却有所不同，这就是知识点的相关性，只有将不同的知识点联系起来， 才能在脑海中形成知识体系，计算机安全知识更新很快，每天都有新的漏洞和攻击出现。有了扎实的知识体系，就不会疲于学习这些新知识，因为很多东西万变不离其宗。\r\n\r\n \r\n\r\n**抽象很重要**，但是作为学生，请不要 “总是” 习惯忽略细节，导致只懂理论，不会实践，从CMU精心设计的实验可以看出，一个细节没搞清楚， 攻击就无法成功，作为一个主动学习者，我们有时候需要多问一个为什么，比如：**怎样让我写的程序不能被GDB追踪调试？**另外一方面，很多时候学生没有兴趣或者学不会，问题可能真的不在学生身上，而是老师没有认真思考如何教，让学生真正有学会的感觉，像是杜文亮教授这样的老师就让我很感动：\r\n\r\nhttps://www.handsonsecurity.net/\r\n\r\n你可以真正学到有价值的东西！\r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n**延伸阅读**\r\n\r\n \r\n\r\n· \r\n\r\n· \r\n\r\n英特尔官方提供的开发者手册：Intel 64 and IA-32 Architectures Software Developer's Manuals\r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n如果你想彻底搞懂C指针，强烈推荐你看看这个视频课程：4小时彻底掌握C指针 - 顶尖程序员图文讲解\r\n\r\n· \r\n\r\n· \r\n\r\n关于C语言和x86汇编语言之间的关系 (含函数调用过程等)，还可以参考印度理工的：C语言和汇编语言\r\n\r\n· \r\n\r\n· \r\n\r\n关于C语言指针和数组的关系以及内存的更多讨论，请参考本人拙作：关于指针，数组，内存的思考\r\n\r\n· \r\n\r\n· \r\n\r\n现代C语言相关的信息可以参考这本书（出自INRIA，在法国的地位相当于我国的中科院）：现代C语言\r\n\r\n· \r\n\r\n· \r\n\r\n文中的视频地址：\r\n\r\n· \r\n\r\nhttps://fengmuzi2003.gitbook.io/csapp3e/di-3-zhang-ji-qi-ji-bian-cheng\r\n\r\n "},"550a":function(n,r,e){"use strict";e.r(r),r["default"]="# ***\\*Linux Kernel TCP/IP Stack|Linux网络硬核系列\\****\r\n\r\n ![img](4.Linux Kernel TCPIP StackLinux网络硬核系列.assets/wps82B5.tmp.png)\r\n\r\n \r\n\r\n大家好，我是Alex，今天给大家介绍Linux网络技术中最核心的部分--TCP/IP协议栈 。    \r\n\r\n \r\n\r\n我们先看一下抽象的网络协议栈模型\r\n\r\n \r\n\r\n***\\*TCP/IP四层（参考）模型\\****\r\n\r\n![img](4.Linux Kernel TCPIP StackLinux网络硬核系列.assets/wps82B6.tmp.png) \r\n\r\n \r\n\r\n再按分层思想看Linux内核协议栈实现框架\r\n\r\n \r\n\r\n**自顶向下**\r\n\r\n**Socket/ L4 TCP layer**\r\n\r\n![img](4.Linux Kernel TCPIP StackLinux网络硬核系列.assets/wps82B7.tmp.png) \r\n\r\n**1. socket layer**\r\n\r\n**socket对象层次结构**\r\n\r\n![img](4.Linux Kernel TCPIP StackLinux网络硬核系列.assets/wps82B8.tmp.png) \r\n\r\n \r\n\r\n**socket框架**![img](4.Linux Kernel TCPIP StackLinux网络硬核系列.assets/wps82B9.tmp.png)\r\n\r\n· \r\n\r\n**socket系统调用（socket，bind，listen，accept，send，recv等）**\r\n\r\n· \r\n\r\n· \r\n\r\n**BSD socket API**\r\n\r\n· \r\n\r\n· \r\n\r\n**协议栈sock抽象适配层**\r\n\r\n· \r\n\r\n· \r\n\r\n**tcp/udp/icmp/raw/packet/netlink/... socket管理**\r\n\r\n· \r\n\r\n· \r\n\r\n**socket选项**\r\n\r\n· \r\n\r\n \r\n\r\n**2. tcp/udp layer**\r\n\r\n![img](4.Linux Kernel TCPIP StackLinux网络硬核系列.assets/wps82CA.tmp.png) \r\n\r\n· \r\n\r\n**TCP报文收发**\r\n\r\n· \r\n\r\n· \r\n\r\n**TCP Socket连接管理**\r\n\r\n· \r\n\r\n· \r\n\r\n**TCP协议状态机，定时器处理**\r\n\r\n· \r\n\r\n· \r\n\r\n**TCP滑动窗口，拥塞控制框架**\r\n\r\n· \r\n\r\n**L3 IP layer**\r\n\r\n![img](4.Linux Kernel TCPIP StackLinux网络硬核系列.assets/wps82CB.tmp.png) \r\n\r\n**1. IP handle**\r\n\r\n![img](4.Linux Kernel TCPIP StackLinux网络硬核系列.assets/wps82CC.tmp.png) \r\n\r\n· \r\n\r\n**报文分片和重组**\r\n\r\n· \r\n\r\n· \r\n\r\n**IP协议字段处理，IP选项，Qos，TTL，校验等处理**\r\n\r\n· \r\n\r\n· \r\n\r\n**报文接收（解封装）和发送(IP协议封装，提供给上层接口）**\r\n\r\n· \r\n\r\n· \r\n\r\n**组播，ICMP协议处理等**\r\n\r\n· \r\n\r\n**2. netlfilter框架**\r\n\r\n![img](4.Linux Kernel TCPIP StackLinux网络硬核系列.assets/wps82CD.tmp.jpg) \r\n\r\n5个HOOK点：\r\n\r\nPREROUTING：数据包进入路由表之前\r\n\r\nINPUT：通过路由表后目的地为本机\r\n\r\nFORWARD：通过路由表后，目的地不为本机\r\n\r\nOUTPUT：由本机产生，向外发送\r\n\r\nPOSTROUTIONG：发送到网卡接口之前。\r\n\r\n \r\n\r\n每个HOOK点都会执行一些函数，大致分为下面几个表：\r\n\r\nNAT表: 用于实现nat功能，端口映射，地址映射等\r\n\r\nmangle表: 用来修改报文，例如更改IP标头的TOS / DSCP / ECN位\r\n\r\nfilter表：用来过滤报文\r\n\r\nraw表：用来提前标记报文不走一些流程（比如不需要建会话)\r\n\r\nconntrack表：连接跟踪表，跟踪连接会话，用来实现状态防火墙，NAT功能的基础，可扩展更多功能。\r\n\r\n \r\n\r\n**核心处理流程**\r\n\r\n \r\n\r\n![img](4.Linux Kernel TCPIP StackLinux网络硬核系列.assets/wps82CE.tmp.png) \r\n\r\n \r\n\r\n主要功能\r\n\r\n· \r\n\r\n**无状态数据包过滤（IPv4和IPv6）**\r\n\r\n· \r\n\r\n· \r\n\r\n**有状态的数据包过滤（IPv4和IPv6）**\r\n\r\n· \r\n\r\n· \r\n\r\n**各种网络地址和端口转换，例如NAT / NAPT（IPv4和IPv6）**\r\n\r\n· \r\n\r\n· \r\n\r\n**灵活可扩展的基础架构**\r\n\r\n· \r\n\r\n· \r\n\r\n**第三方扩展的API**\r\n\r\n· \r\n\r\n**3. 路由系统**\r\n\r\n**协议栈处理位置**\r\n\r\n![img](4.Linux Kernel TCPIP StackLinux网络硬核系列.assets/wps82CF.tmp.png) \r\n\r\n**路由子系统架构**\r\n\r\n![img](4.Linux Kernel TCPIP StackLinux网络硬核系列.assets/wps82D0.tmp.png) \r\n\r\n \r\n\r\n· \r\n\r\n**FIB（The Forwarding Information Base ）**\r\n\r\n· \r\n\r\n· \r\n\r\n**策略路由 Policies**\r\n\r\n· \r\n\r\n· \r\n\r\n**路由匹配HASH，LC-tries等**\r\n\r\n· \r\n\r\n主要功能\r\n\r\n· \r\n\r\n**三层路由转发**\r\n\r\n· \r\n\r\n**4. 邻居系统**\r\n\r\n![img](4.Linux Kernel TCPIP StackLinux网络硬核系列.assets/wps82D1.tmp.png) \r\n\r\n· \r\n\r\n**ARP协议(IPV4),NDP协议（IPV6)**\r\n\r\n· \r\n\r\n· \r\n\r\n**邻居表新建，更新，老化机制，状态转化等**\r\n\r\n· \r\n\r\n· \r\n\r\n**API接口**\r\n\r\n· \r\n\r\n主要功能\r\n\r\n· \r\n\r\n**获取mac地址**\r\n\r\n· \r\n\r\n \r\n\r\n**L2 link layer(driver)**\r\n\r\n![img](4.Linux Kernel TCPIP StackLinux网络硬核系列.assets/wps82E1.tmp.png) \r\n\r\n**1. Link layer**\r\n\r\n**Bridge**\r\n\r\n![img](4.Linux Kernel TCPIP StackLinux网络硬核系列.assets/wps82E2.tmp.png) \r\n\r\n· \r\n\r\n**FDB(mac forwarding database)管理**\r\n\r\n· \r\n\r\n· \r\n\r\n**port，bridge对象管理和报文接收，转发**\r\n\r\n· \r\n\r\n· \r\n\r\n**STP，vlan协议相关处理**\r\n\r\n· \r\n\r\n主要功能\r\n\r\n· \r\n\r\n**实现二层mac转发**\r\n\r\n· \r\n\r\n**链路协议**\r\n\r\n![img](4.Linux Kernel TCPIP StackLinux网络硬核系列.assets/wps82E3.tmp.png) \r\n\r\n· \r\n\r\n**IEEE 802协议族（STP，VLAN，以太网，无线wifi，令牌环等）**\r\n\r\n· \r\n\r\n \r\n\r\n**Packt Type**![img](4.Linux Kernel TCPIP StackLinux网络硬核系列.assets/wps82E4.tmp.png)\r\n\r\n· \r\n\r\n**Protocol handler**\r\n\r\n· \r\n\r\n· \r\n\r\n**Packet_type list**\r\n\r\n· \r\n\r\n主要功能\r\n\r\n· \r\n\r\n**链路层报文协议分发**\r\n\r\n· \r\n\r\n \r\n\r\n**Traffic control**\r\n\r\n![img](4.Linux Kernel TCPIP StackLinux网络硬核系列.assets/wps82E5.tmp.png) \r\n\r\n· \r\n\r\n**qdisc ：通过队列将数据包缓存起来，用来控制网络收发的速度**\r\n\r\n· \r\n\r\n· \r\n\r\n**class ：用来表示控制策略**\r\n\r\n· \r\n\r\n· \r\n\r\n**filter ：用来将数据包划分到具体的控制策略**\r\n\r\n· \r\n\r\n主要功能\r\n\r\n· \r\n\r\n**提供的流量限速、整形和策略控制机制（Qos）**\r\n\r\n· \r\n\r\n \r\n\r\n**2. hardware driver layer**\r\n\r\n![img](4.Linux Kernel TCPIP StackLinux网络硬核系列.assets/wps82E6.tmp.png) \r\n\r\n· \r\n\r\n**网络设备管理**\r\n\r\n· \r\n\r\n· \r\n\r\n**RPS,RFS,XPS,GRO,GSO,TSO等优化特性**\r\n\r\n· \r\n\r\n· \r\n\r\n**网卡软中断收发，NAPI，DMA**\r\n\r\n· \r\n\r\n· \r\n\r\n**支持各种网卡驱动实现**\r\n\r\n· \r\n\r\n· \r\n\r\n**协议栈文件系统**\r\n\r\n**Proc FileSystem**\r\n\r\n· \r\n\r\n**/proc/net**\r\n\r\n· \r\n\r\n· \r\n\r\n**/proc/sys/net**\r\n\r\n· \r\n\r\n **ipv4**\r\n\r\n· \r\n\r\n​     **core**\r\n\r\n**Sys FileSystem**\r\n\r\n· \r\n\r\n**/sys/class/net/ethx**\r\n\r\n· \r\n\r\n主要功能\r\n\r\n· \r\n\r\n**提供协议栈相关配置查询和设置**\r\n\r\n· \r\n\r\n \r\n\r\n**最后**\r\n\r\n**整体架构图**\r\n\r\n![img](4.Linux Kernel TCPIP StackLinux网络硬核系列.assets/wps82F7.tmp.png) \r\n\r\n \r\n\r\n**如果想了解更多细节，请阅读Linux内核源码或者参考下面两本经典著作：**\r\n\r\n**《The Linux Networking Architecture》**\r\n\r\n**《Understanding Linux Network Internals》**\r\n\r\n "},"59ca":function(n,r,e){"use strict";e.r(r),r["default"]="# ***\\*深入理解Linux 的Page Cache\\****\r\n\r\n \r\n\r\nhi，大家好，我是阿荣，本文起源为群里的小伙伴咨询的一个问题：\r\n\r\n \r\n\r\n![img](14.深入理解Linux 的Page Cache.assets/wps9CDF.tmp.png) \r\n\r\n \r\n\r\n图中图片，meminfo字段解释：\r\n\r\n \r\n\r\n![img](14.深入理解Linux 的Page Cache.assets/wps9CE0.tmp.png) \r\n\r\n \r\n\r\n打印meminfo统计信息：\r\n\r\n![img](14.深入理解Linux 的Page Cache.assets/wps9CE1.tmp.png) \r\n\r\n \r\n\r\n \r\n\r\n这里我这边发现一篇好文章，可以回答这个问题，答案在文中，大家仔细看。\r\n\r\n \r\n\r\n作者：Spongecaptain\r\n\r\n原文：https://spongecaptain.cool/SimpleClearFileIO/\r\n\r\n## ***\\*1. Page Cache\\****\r\n\r\n### ***\\*1.1 Page Cache 是什么？\\****\r\n\r\n为了理解 Page Cache，我们不妨先看一下 Linux 的文件 I/O 系统，如下图所示：\r\n\r\n \r\n\r\n![img](14.深入理解Linux 的Page Cache.assets/wps9CE2.tmp.png) \r\n\r\n \r\n\r\nFigure1. Linux 文件 I/O 系统\r\n\r\n上图中，红色部分为 Page Cache。可见 Page Cache 的本质是由 Linux 内核管理的内存区域。我们通过 mmap 以及 buffered I/O 将文件读取到内存空间实际上都是读取到 Page Cache 中。\r\n\r\n### ***\\*1.2 如何查看系统的 Page Cache？\\****\r\n\r\n通过读取 /proc/meminfo 文件，能够实时获取系统内存情况：\r\n\r\n$ cat /proc/meminfo\r\n...\r\nBuffers:       1224 kB\r\nCached:      111472 kB\r\nSwapCached:     36364 kB\r\nActive:      6224232 kB\r\nInactive:     979432 kB\r\nActive(anon):   6173036 kB\r\nInactive(anon):  927932 kB\r\nActive(file):    51196 kB\r\nInactive(file):   51500 kB\r\n...\r\nShmem:       10000 kB\r\n...\r\nSReclaimable:    43532 kB\r\n...\r\n\r\n根据上面的数据，你可以简单得出这样的公式（等式两边之和都是 112696 KB）：\r\n\r\nBuffers + Cached + SwapCached = Active(file) + Inactive(file) + Shmem + SwapCached\r\n\r\n两边等式都是 Page Cache，即：\r\n\r\nPage Cache = Buffers + Cached + SwapCached\r\n\r\n通过阅读 1.4 以及 1.5 小节，就能够理解为什么 SwapCached 与 Buffers 也是 Page Cache 的一部分。\r\n\r\n题外话，小伙伴答案：\r\n\r\n内核计算源码（linux 2.6.19）：\r\n\r\n![img](14.深入理解Linux 的Page Cache.assets/wps9CF3.tmp.png) \r\n\r\n内核算法：Cached  = files - SwapCached - Buffers；\r\n\r\nBuffers + Cached + SwapCached = Active(file) + Inactive(file) + Shmem + SwapCached\r\n\r\n公式推出来的\r\n\r\nCached = Active(file) + Inactive(file) + Shmem - Buffers ；\r\n\r\n由此可见，这个Cached 并不等于Active(file) + Inactive(file) ；\r\n\r\n这个cache包含很多 ：\r\n\r\n\\1. 含有普通文件数据的页‘；\r\n\r\n\\2. 含有目录的页；\r\n\r\n\\3. 含有直接从块设备文件(跳过文件系统)读出的数据的页；\r\n\r\n\\4. 含有用户态进程数据的页；\r\n\r\n\\5. 属于特殊文件系统文件的页，如shm；\r\n\r\n \r\n\r\n### ***\\*1.3 page 与 Page Cache\\****\r\n\r\npage 是内存管理分配的基本单位， Page Cache 由多个 page 构成。page 在操作系统中通常为 4KB 大小（32bits/64bits），而 Page Cache 的大小则为 4KB 的整数倍。\r\n\r\n**另一方面，并不是所有 page 都被组织为 Page Cache**。\r\n\r\nLinux 系统上供用户可访问的内存分为两个类型[2]，即：\r\n\r\n· \r\n\r\nFile-backed pages：文件备份页也就是 Page Cache 中的 page，对应于磁盘上的若干数据块；对于这些页最大的问题是脏页回盘；\r\n\r\n· \r\n\r\n· \r\n\r\nAnonymous pages：匿名页不对应磁盘上的任何磁盘数据块，它们是进程的运行是内存空间（例如方法栈、局部变量表等属性）；\r\n\r\n· \r\n\r\n \r\n\r\n**为什么 Linux 不把 Page Cache 称为 block cache，这不是更好吗？**\r\n\r\n这是因为从磁盘中加载到内存的数据不仅仅放在 Page Cache 中，还放在 buffer cache 中。例如通过 Direct I/O 技术的磁盘文件就不会进入 Page Cache 中。当然，这个问题也有 Linux 历史设计的原因，毕竟这只是一个称呼，含义随着 Linux 系统的演进也逐渐不同。\r\n\r\n\r\n\r\n------\r\n\r\n\r\n\r\n下面比较一下 File-backed pages 与 Anonymous pages 在 Swap 机制下的性能。\r\n\r\n内存是一种珍惜资源，当内存不够用时，内存管理单元（Memory Mangament Unit）需要提供调度算法来回收相关内存空间。内存空间回收的方式通常就是 swap，即交换到持久化存储设备上。\r\n\r\nFile-backed pages（Page Cache）的内存回收代价较低。Page Cache 通常对应于一个文件上的若干顺序块，因此可以通过顺序 I/O 的方式落盘。另一方面，如果 Page Cache 上没有进行写操作（所谓的没有脏页），甚至不会将 Page Cache 回盘，因为数据的内容完全可以通过再次读取磁盘文件得到。\r\n\r\nPage Cache 的主要难点在于脏页回盘，这个内容会在第二节进行详细说明。\r\n\r\nAnonymous pages 的内存回收代价较高。这是因为 Anonymous pages 通常随机地写入持久化交换设备。另一方面，无论是否有更操作，为了确保数据不丢失，Anonymous pages 在 swap 时必须持久化到磁盘。\r\n\r\n### ***\\*1.4 Swap 与缺页中断\\****\r\n\r\nSwap 机制指的是当物理内存不够用，内存管理单元（Memory Mangament Unit）需要提供调度算法来回收相关内存空间，然后将清理出来的内存空间给当前内存申请方。\r\n\r\nSwap 机制存在的本质原因是 Linux 系统提供了虚拟内存管理机制，每一个进程认为其独占内存空间，因此所有进程的内存空间之和远远大于物理内存。所有进程的内存空间之和超过物理内存的部分就需要交换到磁盘上。\r\n\r\n操作系统以 page 为单位管理内存，当进程发现需要访问的数据不在内存时，操作系统可能会将数据以页的方式加载到内存中。上述过程被称为缺页中断，当操作系统发生缺页中断时，就会通过系统调用将 page 再次读到内存中。\r\n\r\n但主内存的空间是有限的，当主内存中不包含可以使用的空间时，操作系统会从选择合适的物理内存页驱逐回磁盘，为新的内存页让出位置，**选择待驱逐页的过程在操作系统中叫做页面替换（Page Replacement）**，替换操作又会触发 swap 机制。\r\n\r\n如果物理内存足够大，那么可能不需要 Swap 机制，但是 Swap 在这种情况下还是有一定优势：对于有发生内存泄漏几率的应用程序（进程），Swap 交换分区更是重要，这可以确保内存泄露不至于导致物理内存不够用，最终导致系统崩溃。但内存泄露会引起频繁的 swap，此时非常影响操作系统的性能。\r\n\r\nLinux 通过一个 swappiness 参数来控制 Swap 机制[2]：这个参数值可为 0-100，控制系统 swap 的优先级：\r\n\r\n· \r\n\r\n高数值：较高频率的 swap，进程不活跃时主动将其转换出物理内存。\r\n\r\n· \r\n\r\n· \r\n\r\n低数值：较低频率的 swap，这可以确保交互式不因为内存空间频繁地交换到磁盘而提高响应延迟。\r\n\r\n· \r\n\r\n \r\n\r\n· \r\n\r\n**最后，为什么 Buffers 也是 Page Cache 的一部分？**\r\n\r\n这是因为当匿名页（Inactive(anon) 以及 Active(anon)）先被交换（swap out）到磁盘上后，然后再加载回（swap in）内存中，由于读入到内存后原来的 Swap File 还在，所以 SwapCached 也可以认为是 File-backed page，即属于 Page Cache。这个过程如 Figure 2 所示。\r\n\r\n![img](14.深入理解Linux 的Page Cache.assets/wps9CF4.tmp.png) \r\n\r\nFigure2. 匿名页的被交换后也是 Page Cache\r\n\r\n### ***\\*1.5 Page Cache 与 buffer cache\\****\r\n\r\n执行 free 命令，注意到会有两列名为 buffers 和 cached，也有一行名为 “-/+ buffers/cache”。\r\n\r\n~ free -m\r\n       total    used    free   shared   buffers   cached\r\nMem:     128956    96440    32515      0    5368    39900\r\n-/+ buffers/cache:    51172    77784\r\nSwap:     16002      0    16001\r\n\r\n \r\n\r\n其中，cached 列表示当前的页缓存（Page Cache）占用量，buffers 列表示当前的块缓存（buffer cache）占用量。用一句话来解释：**Page Cache 用于缓存文件的页数据，buffer cache 用于缓存块设备（如磁盘）的块数据。**页是逻辑上的概念，因此 Page Cache 是与文件系统同级的；块是物理上的概念，因此 buffer cache 是与块设备驱动程序同级的。\r\n\r\nPage Cache）占用量，buffers 列表示当前的块缓存（buffer cache）占用量。用一句话来解释：**Page Cache 用于缓存文件的页数据，buffer cache 用于缓存块设备（如磁盘）的块数据。**页是逻辑上的概念，因此 Page Cache 是与文件系统同级的；块是物理上的概念，因此 buffer cache 是与块设备驱动程序同级的。\r\n\r\nPage Cache 与 buffer cache 的共同目的都是加速数据 I/O：写数据时首先写到缓存，将写入的页标记为 dirty，然后向外部存储 flush，也就是缓存写机制中的 write-back（另一种是 write-through，Linux 默认情况下不采用）；读数据时首先读取缓存，如果未命中，再去外部存储读取，并且将读取来的数据也加入缓存。操作系统总是积极地将所有空闲内存都用作 Page Cache 和 buffer cache，当内存不够用时也会用 LRU 等算法淘汰缓存页。\r\n\r\n在 Linux 2.4 版本的内核之前，Page Cache 与 buffer cache 是完全分离的。但是，块设备大多是磁盘，磁盘上的数据又大多通过文件系统来组织，这种设计导致很多数据被缓存了两次，浪费内存。**所以在 2.4 版本内核之后，两块缓存近似融合在了一起：如果一个文件的页加载到了 Page Cache，那么同时 buffer cache 只需要维护块指向页的指针就可以了**。只有那些没有文件表示的块，或者绕过了文件系统直接操作（如dd命令）的块，才会真正放到 buffer cache 里。因此，我们现在提起 Page Cache，基本上都同时指 Page Cache 和 buffer cache 两者，本文之后也不再区分，直接统称为 Page Cache。\r\n\r\n下图近似地示出 32-bit Linux 系统中可能的一种 Page Cache 结构，其中 block size 大小为 1KB，page size 大小为 4KB。\r\n\r\n![img](14.深入理解Linux 的Page Cache.assets/wps9CF5.tmp.png) \r\n\r\nPage Cache 中的每个文件都是一棵基数树（radix tree，本质上是多叉搜索树），树的每个节点都是一个页。根据文件内的偏移量就可以快速定位到所在的页，如下图所示。关于基数树的原理可以参见英文维基，这里就不细说了。\r\n\r\n![img](14.深入理解Linux 的Page Cache.assets/wps9CF6.tmp.png) \r\n\r\n### ***\\*1.6 Page Cache 与预读\\****\r\n\r\n操作系统为基于 Page Cache 的读缓存机制提供预读机制（PAGE_READAHEAD），一个例子是：\r\n\r\n· \r\n\r\n用户线程仅仅请求读取磁盘上文件 A 的 offset 为 0-3KB 范围内的数据，由于磁盘的基本读写单位为 block（4KB），于是操作系统至少会读 0-4KB 的内容，这恰好可以在一个 page 中装下。\r\n\r\n· \r\n\r\n· \r\n\r\n但是操作系统出于局部性原理[3]会选择将磁盘块 offset [4KB,8KB)、[8KB,12KB) 以及 [12KB,16KB) 都加载到内存，于是额外在内存中申请了 3 个 page；\r\n\r\n· \r\n\r\n \r\n\r\n下图代表了操作系统的预读机制：\r\n\r\n![img](14.深入理解Linux 的Page Cache.assets/wps9CF7.tmp.png) \r\n\r\n操作系统的预读机制\r\n\r\n上图中，应用程序利用 read 系统调动读取 4KB 数据，实际上内核使用 readahead 机制完成了 16KB 数据的读取。\r\n\r\n## ***\\*2. Page Cache 与文件持久化的一致性&可靠性\\****\r\n\r\n现代 Linux 的 Page Cache 正如其名，是对磁盘上 page（页）的内存缓存，同时可以用于读/写操作。一切内存缓存都存在一致性问题：内存中的数据与磁盘中的数据不一致，例如用作分布式中间件缓存的 Redis 就与 MySQL 等数据库中的数据存在不一致。\r\n\r\nLinux 提供多种机制来保证数据一致性，但无论是单机上的内存与磁盘一致性，还是分布式组件中节点 1 与节点 2 、节点 3 的数据一致性问题，理解的关键是 trade-off：吞吐量与数据一致性保证是一对矛盾。\r\n\r\n首先，需要我们理解一下文件的数据。**文件 = 数据 + 元数据**。元数据用来描述文件的各种属性，也必须存储在磁盘上。因此，我们说保证文件一致性其实包含了两个方面：数据一致+元数据一致。\r\n\r\n文件的元数据包括：文件大小、创建时间、访问时间、属主属组等信息。\r\n\r\n我们考虑如下一致性问题：如果发生写操作并且对应的数据在 Page Cache 中，那么写操作就会直接作用于 Page Cache 中，此时如果数据还没刷新到磁盘，那么内存中的数据就领先于磁盘，此时对应 page 就被称为 Dirty page。\r\n\r\n当前 Linux 下以两种方式实现文件一致性：\r\n\r\n\\1. \r\n\r\n**Write Through（写穿）**：向用户层提供特定接口，应用程序可主动调用接口来保证文件一致性；\r\n\r\n\\2. \r\n\r\n\\3. \r\n\r\n**Write back（写回）**：系统中存在定期任务（表现形式为内核线程），周期性地同步文件系统中文件脏数据块，这是默认的 Linux 一致性方案；\r\n\r\n\\4. \r\n\r\n\\5. \r\n\r\n上述两种方式最终都依赖于系统调用，主要分为如下三种系统调用：\r\n\r\n| ***\\*方法\\****        | ***\\*含义\\****                                               |\r\n| --------------------- | ------------------------------------------------------------ |\r\n| **fsync(intfd)**      | fsync(fd)：将 fd 代表的文件的脏数据和脏元数据全部刷新至磁盘中。 |\r\n| **fdatasync(int fd)** | fdatasync(fd)：将 fd 代表的文件的脏数据刷新至磁盘，同时对必要的元数据刷新至磁盘中，这里所说的必要的概念是指：对接下来访问文件有关键作用的信息，如文件大小，而文件修改时间等不属于必要信息 |\r\n| **sync()**            | sync()：则是对系统中所有的脏的文件数据元数据刷新至磁盘中     |\r\n\r\n上述三种系统调用可以分别由用户进程与内核进程发起。下面我们研究一下内核线程的相关特性。\r\n\r\n\\1. \r\n\r\n创建的针对回写任务的内核线程数由系统中持久存储设备决定，为每个存储设备创建单独的刷新线程；\r\n\r\n\\2. \r\n\r\n\\3. \r\n\r\n关于多线程的架构问题，Linux 内核采取了 Lighthttp 的做法，即系统中存在一个管理线程和多个刷新线程（每个持久存储设备对应一个刷新线程）。管理线程监控设备上的脏页面情况，若设备一段时间内没有产生脏页面，就销毁设备上的刷新线程；若监测到设备上有脏页面需要回写且尚未为该设备创建刷新线程，那么创建刷新线程处理脏页面回写。而刷新线程的任务较为单调，只负责将设备中的脏页面回写至持久存储设备中。\r\n\r\n\\4. \r\n\r\n\\5. \r\n\r\n刷新线程刷新设备上脏页面大致设计如下：\r\n\r\n\\6. \r\n\r\na. \r\n\r\n每个设备保存脏文件链表，保存的是该设备上存储的脏文件的 inode 节点。所谓的回写文件脏页面即回写该 inode 链表上的某些文件的脏页面；\r\n\r\nb. \r\n\r\nc. \r\n\r\n系统中存在多个回写时机，第一是应用程序主动调用回写接口（fsync，fdatasync 以及 sync 等），第二管理线程周期性地唤醒设备上的回写线程进行回写，第三是某些应用程序/内核任务发现内存不足时要回收部分缓存页面而事先进行脏页面回写，设计一个统一的框架来管理这些回写任务非常有必要。\r\n\r\nd. \r\n\r\nWrite Through 与 Write back 在持久化的可靠性上有所不同：\r\n\r\n· \r\n\r\nWrite Through 以牺牲系统 I/O 吞吐量作为代价，向上层应用确保一旦写入，数据就已经落盘，不会丢失；\r\n\r\n· \r\n\r\n· \r\n\r\nWrite back 在系统发生宕机的情况下无法确保数据已经落盘，因此存在数据丢失的问题。不过，在程序挂了，例如被 kill -9，Page Cache 中的数据操作系统还是会确保落盘；\r\n\r\n· \r\n\r\n## ***\\*3. 为什么使用 Page Cache 与为什么不使用 Page Cache?\\****\r\n\r\n### ***\\*3.1 Page Cache 的优势\\****\r\n\r\n**1.加快数据访问**\r\n\r\n如果数据能够在内存中进行缓存，那么下一次访问就不需要通过磁盘 I/O 了，直接命中内存缓存即可。\r\n\r\n由于内存访问比磁盘访问快很多，因此加快数据访问是 Page Cache 的一大优势。\r\n\r\n**2.减少 I/O 次数，提高系统磁盘 I/O 吞吐量**\r\n\r\n得益于 Page Cache 的缓存以及预读能力，而程序又往往符合局部性原理，因此通过一次 I/O 将多个 page 装入 Page Cache 能够减少磁盘 I/O 次数， 进而提高系统磁盘 I/O 吞吐量。\r\n\r\n### ***\\*3.2 Page Cache 的劣势\\****\r\n\r\npage cache 也有其劣势，最直接的缺点是需要占用额外物理内存空间，物理内存在比较紧俏的时候可能会导致频繁的 swap 操作，最终导致系统的磁盘 I/O 负载的上升。\r\n\r\nPage Cache 的另一个缺陷是对于应用层并没有提供很好的管理 API，几乎是透明管理。应用层即使想优化 Page Cache 的使用策略也很难进行。因此一些应用选择在用户空间实现自己的 page 管理，例如 MySQL InnoDB 存储引擎以 16KB 的页进行管理。\r\n\r\nPage Cache 最后一个缺陷是在某些应用场景下比 Direct I/O 多一次磁盘读 I/O 以及磁盘写 I/O。这一点可以参考[4]。\r\n\r\n## ***\\*REFERENCE\\****\r\n\r\n· \r\n\r\n[1] Linux内核技术实战课\r\n\r\n· \r\n\r\n· \r\n\r\n[2] Reconsidering swapping\r\n\r\n· \r\n\r\n· \r\n\r\n[3]访问局部性\r\n\r\n· \r\n\r\n· \r\n\r\n[4] DMA 与零拷贝技术\r\n\r\n· \r\n\r\n "},"6a3c":function(n,r,e){"use strict";e.r(r),r["default"]='# ***\\*Linux网络子系统\\****\r\n\r\nxholic [极客重生](https://mp.weixin.qq.com/javascript:void(0);) 8/25\r\n\r\n ![img](7.Linux网络子系统.assets/wpsB583.tmp.png)\r\n\r\n#  \r\n\r\n# ***\\*今天分享一篇经典Linux协议栈文章，主要讲解Linux网络子系统，看完相信大家对协议栈又会加深不少，不光可以了解协议栈处理流程，方便定位问题，还可以学习一下怎么去设计一个可扩展的子系统，屏蔽不同层次的差异。\\****\r\n\r\n# ***\\*目录\\****\r\n\r\n1.Linux网络子系统的分层\r\n\r\n2.TCP/IP分层模型\r\n\r\n3.Linux 网络协议栈\r\n\r\n4.Linux 网卡收包时的中断处理问题\r\n\r\n5.Linux 网络启动的准备工作\r\n\r\n6.Linux网络包：中断到网络层接收\r\n\r\n7.总结\r\n\r\n# ***\\*Linux网络子系统的分层\\****\r\n\r\nLinux网络子系统实现需要：\r\n\r\n· \r\n\r\n支持不同的协议族 ( INET, INET6, UNIX, NETLINK...)\r\n\r\n· \r\n\r\n· \r\n\r\n支持不同的网络设备\r\n\r\n· \r\n\r\n· \r\n\r\n支持统一的BSD socket API\r\n\r\n· \r\n\r\n· \r\n\r\n需要屏蔽协议、硬件、平台(API)的差异，因而采用分层结构：\r\n\r\n· \r\n\r\n ![img](7.Linux网络子系统.assets/wpsB584.tmp.png)\r\n\r\n \r\n\r\n系统调用提供用户的应用程序访问内核的唯一途径。协议无关接口由socket layer来实现的，其提供一组通用功能，以支持各种不同的协议。网络协议层为socket层提供具体协议接口——proto{}，实现具体的协议细节。设备无关接口，提供一组通用函数供底层网络设备驱动程序使用。设备驱动与特定网卡设备相关，定义了具体的协议细节，会分配一个net_device结构，然后用其必需的例程进行初始化。\r\n\r\n \r\n\r\n# ***\\*TCP/IP分层模型\\****\r\n\r\n在TCP/IP网络分层模型里，整个协议栈被分成了物理层、链路层、网络层，传输层和应用层。物理层对应的是网卡和网线，应用层对应的是我们常见的Nginx，FTP等等各种应用。Linux实现的是链路层、网络层和传输层这三层。\r\n\r\n \r\n\r\n在Linux内核实现中，链路层协议靠网卡驱动来实现，内核协议栈来实现网络层和传输层。内核对更上层的应用层提供socket接口来供用户进程访问。我们用Linux的视角来看到的TCP/IP网络分层模型应该是下面这个样子的。\r\n\r\n \r\n\r\n ![img](7.Linux网络子系统.assets/wpsB585.tmp.png)\r\n\r\n \r\n\r\n \r\n\r\n首先我们梳理一下每层模型的职责：\r\n\r\n**链路层**：对0和1进行分组，定义数据帧，确认主机的物理地址，传输数据;\r\n\r\n**网络层**：定义IP地址，确认主机所在的网络位置，并通过IP进行MAC寻址，对外网数据包进行路由转发;\r\n\r\n**传输层**：定义端口，确认主机上应用程序的身份，并将数据包交给对应的应用程序;\r\n\r\n**应用层**：定义数据格式，并按照对应的格式解读数据。\r\n\r\n \r\n\r\n然后再把每层模型的职责串联起来，用一句通俗易懂的话讲就是：\r\n\r\n当你输入一个网址并按下回车键的时候，首先，应用层协议对该请求包做了格式定义;紧接着传输层协议加上了双方的端口号，确认了双方通信的应用程序;然后网络协议加上了双方的IP地址，确认了双方的网络位置;最后链路层协议加上了双方的MAC地址，确认了双方的物理位置，同时将数据进行分组，形成数据帧，采用广播方式，通过传输介质发送给对方主机。而对于不同网段，该数据包首先会转发给网关路由器，经过多次转发后，最终被发送到目标主机。目标机接收到数据包后，采用对应的协议，对帧数据进行组装，然后再通过一层一层的协议进行解析，最终被应用层的协议解析并交给服务器处理。\r\n\r\n# ***\\*Linux 网络协议栈\\****\r\n\r\n![img](7.Linux网络子系统.assets/wpsB586.tmp.png) \r\n\r\n \r\n\r\n基于TCP/IP协议栈的send/recv在应用层，传输层，网络层和链路层中具体函数调用过程已经有很多人研究，本文引用一张比较完善的图如下：\r\n\r\n \r\n\r\n ![img](7.Linux网络子系统.assets/wpsB587.tmp.png)\r\n\r\n \r\n\r\n以上说明基本大致说明了TCP/IP中TCP，UDP协议包在网络子系统中的实现流程。本文主要在链路层中，即关于网卡收报触发中断到进入网络层之间的过程探究。\r\n\r\n \r\n\r\n# ***\\*Linux 网卡收包时的中断处理问题\\****\r\n\r\n中断，一般指硬件中断，多由系统自身或与之链接的外设（如键盘、鼠标、网卡等）产生。中断首先是处理器提供的一种响应外设请求的机制，是处理器硬件支持的特性。一个外设通过产生一种电信号通知中断控制器，中断控制器再向处理器发送相应的信号。处理器检测到了这个信号后就会打断自己当前正在做的工作，转而去处理这次中断（所以才叫中断）。当然在转去处理中断和中断返回时都有保护现场和返回现场的操作，这里不赘述。\r\n\r\n \r\n\r\n那软中断又是什么呢？我们知道在中断处理时CPU没法处理其它事物，对于网卡来说，如果每次网卡收包时中断的时间都过长，那很可能造成丢包的可能性。当然我们不能完全避免丢包的可能性，以太包的传输是没有100%保证的，所以网络才有协议栈，通过高层的协议来保证连续数据传输的数据完整性（比如在协议发现丢包时要求重传）。但是即使有协议保证，那我们也不能肆无忌惮的使用中断，中断的时间越短越好，尽快放开处理器，让它可以去响应下次中断甚至进行调度工作。基于这样的考虑，我们将中断分成了上下两部分，上半部分就是上面说的中断部分，需要快速及时响应，同时需要越快结束越好。而下半部分就是完成一些可以推后执行的工作。对于网卡收包来说，网卡收到数据包，通知内核数据包到了，中断处理将数据包存入内存这些都是急切需要完成的工作，放到上半部完成。而解析处理数据包的工作则可以放到下半部去执行。\r\n\r\n \r\n\r\n软中断就是下半部使用的一种机制，它通过软件模仿硬件中断的处理过程，但是和硬件没有关系，单纯的通过软件达到一种异步处理的方式。其它下半部的处理机制还包括tasklet，工作队列等。依据所处理的场合不同，选择不同的机制，网卡收包一般使用软中断。对应NET_RX_SOFTIRQ这个软中断，软中断的类型如下：\r\n\r\n \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\nenum{     HI_SOFTIRQ=0,     TIMER_SOFTIRQ,     NET_TX_SOFTIRQ,     NET_RX_SOFTIRQ,     BLOCK_SOFTIRQ,     IRQ_POLL_SOFTIRQ,     TASKLET_SOFTIRQ,     SCHED_SOFTIRQ,     HRTIMER_SOFTIRQ,     RCU_SOFTIRQ,   /* Preferable RCU should always be the last softirq */     NR_SOFTIRQS};\r\n\r\n \r\n\r\n通过以上可以了解到，Linux中断注册显然应该包括网卡的硬中断，包处理的软中断两个步骤。\r\n\r\n \r\n\r\n**注册网卡中断**\r\n\r\n我们以一个具体的网卡驱动为例，比如e1000。其模块初始化函数就是：\r\n\r\n \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\nstatic int __init e1000_init_module(void){     int ret;     pr_info("%s - version %s\\n", e1000_driver_string, e1000_driver_version);     pr_info("%s\\n", e1000_copyright);     ret = pci_register_driver(&e1000_driver);...     return ret;\r\n}\r\n\r\n其中e1000_driver这个结构体是一个关键，这个结构体中很主要的一个方法就是.probe方法，也就是e1000_probe()：\r\n\r\n \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n/**                          \r\n \\* e1000_probe - Device Initialization Routine      * @pdev: PCI device information struct           * @ent: entry in e1000_pci_tbl    *                 * Returns 0 on success, negative on failure                                         *                                                         * e1000_probe initializes an adapter identified by a pci_dev structure.                                 * The OS initialization, configuring of the adapter private structure,                                  * and a hardware reset occur.                            **/static int e1000_probe(struct pci_dev *pdev, const struct pci_device_id *ent){......     netdev->netdev_ops = &e1000_netdev_ops;     e1000_set_ethtool_ops(netdev);......}\r\n\r\n \r\n\r\n \r\n\r\n这个函数很长，我们不都列出来，这是e1000主要的初始化函数，即使从注释都能看出来。我们留意其注册了netdev的netdev_ops，用的是e1000_netdev_ops这个结构体：\r\n\r\n \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\nstatic const struct net_device_ops e1000_netdev_ops = {     .ndo_open        = e1000_open,     .ndo_stop        = e1000_close,     .ndo_start_xmit     = e1000_xmit_frame,     .ndo_set_rx_mode     = e1000_set_rx_mode,     .ndo_set_mac_address   = e1000_set_mac,     .ndo_tx_timeout     = e1000_tx_timeout,......};\r\n\r\n这个e1000的方法集里有一个重要的方法，e1000_open，我们要说的中断的注册就从这里开始：\r\n\r\n \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n/**       * e1000_open - Called when a network interface is made active  * @netdev: network interface device structure       *                          * Returns 0 on success, negative value on failure    *    * The open entry point is called when a network interface is made                                                   * active by the system (IFF_UP).  At this point all resources needed                                       * for transmit and receive operations are allocated, the interrupt                            * handler is registered with the OS, the watchdog task is started,                                                    * and the stack is notified that the interface is ready.                                                        **/int e1000_open(struct net_device *netdev){     struct e1000_adapter *adapter = netdev_priv(netdev);     struct e1000_hw *hw = &adapter->hw;......     err = e1000_request_irq(adapter);...}\r\n\r\n \r\n\r\ne1000在这里注册了中断：\r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\nstatic int e1000_request_irq(struct e1000_adapter *adapter){     struct net_device *netdev = adapter->netdev;     irq_handler_t handler = e1000_intr;     int irq_flags = IRQF_SHARED;     int err;     err = request_irq(adapter->pdev->irq, handler, irq_flags, netdev->name,......} \r\n\r\n \r\n\r\n如上所示，这个被注册的中断处理函数，也就是handler，就是e1000_intr()。我们不展开这个中断处理函数看了，我们知道中断处理函数在这里被注册了，在网络包来的时候会触发这个中断函数。\r\n\r\n \r\n\r\n**注册软中断**\r\n\r\n内核初始化期间，softirq_init会注册TASKLET_SOFTIRQ以及HI_SOFTIRQ相关联的处理函数。\r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\nvoid __init softirq_init(void){   ......   open_softirq(TASKLET_SOFTIRQ, tasklet_action);   open_softirq(HI_SOFTIRQ, tasklet_hi_action);\r\n}\r\n\r\n \r\n\r\n网络子系统分两种soft IRQ。NET_TX_SOFTIRQ和NET_RX_SOFTIRQ，分别处理发送数据包和接收数据包。这两个soft IQ在net_dev_init函数（net/core/dev.c）中注册：\r\n\r\n· \r\n\r\n· \r\n\r\n  open_softirq(NET_TX_SOFTIRQ, net_tx_action);  open_softirq(NET_RX_SOFTIRQ, net_rx_action);\r\n\r\n收发数据包的软中断处理函数被注册为net_rx_action和net_tx_action。其中open_softirq实现为：\r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\nvoid open_softirq(int nr, void (*action)(struct softirq_action *)){   softirq_vec[nr].action = action;\r\n}\r\n\r\n \r\n\r\n \r\n\r\n![img](7.Linux网络子系统.assets/wpsB597.tmp.png) \r\n\r\n \r\n\r\n \r\n\r\n![img](7.Linux网络子系统.assets/wpsB598.tmp.png) \r\n\r\n \r\n\r\n· \r\n\r\n**从硬中断到软中断**\r\n\r\n· \r\n\r\n ![img](7.Linux网络子系统.assets/wpsB599.tmp.png)\r\n\r\n \r\n\r\n \r\n\r\n### ***\\*Linux 网络启动的准备工作\\****\r\n\r\n首先在开始收包之前，Linux要做许多的准备工作：\r\n\r\n\\1. 创建ksoftirqd线程，为它设置好它自己的线程函数，后面就指望着它来处理软中断呢。\r\n\r\n\\2. 协议栈注册，linux要实现许多协议，比如arp，icmp，ip，udp，tcp，每一个协议都会将自己的处理函数注册一下，方便包来了迅速找到对应的处理函数\r\n\r\n\\3. 网卡驱动初始化，每个驱动都有一个初始化函数，内核会让驱动也初始化一下。在这个初始化过程中，把自己的DMA准备好，把NAPI的poll函数地址告诉内核\r\n\r\n\\4. 启动网卡，分配RX，TX队列，注册中断对应的处理函数\r\n\r\n \r\n\r\n**创建ksoftirqd内核线程**\r\n\r\nLinux的软中断都是在专门的内核线程（ksoftirqd）中进行的，因此我们非常有必要看一下这些进程是怎么初始化的，这样我们才能在后面更准确地了解收包过程。该进程数量不是1个，而是N个，其中N等于你的机器的核数。\r\n\r\n系统初始化的时候在kernel/smpboot.c中调用了smpboot_register_percpu_thread， 该函数进一步会执行到spawn_ksoftirqd（位于kernel/softirq.c）来创建出softirqd进程。\r\n\r\n ![img](7.Linux网络子系统.assets/wpsB59A.tmp.png)\r\n\r\n \r\n\r\n相关代码如下：\r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n//file: kernel/softirq.cstatic struct smp_hotplug_thread softirq_threads = {   .store      = &ksoftirqd,   .thread_should_run  = ksoftirqd_should_run,   .thread_fn    = run_ksoftirqd,   .thread_comm     = "ksoftirqd/%u",};\r\n\r\n \r\n\r\n![img](7.Linux网络子系统.assets/wpsB59B.tmp.png) \r\n\r\n![img](7.Linux网络子系统.assets/wpsB59C.tmp.png) \r\n\r\n \r\n\r\n当ksoftirqd被创建出来以后，它就会进入自己的线程循环函数ksoftirqd_should_run和run_ksoftirqd了。不停地判断有没有软中断需要被处理。这里需要注意的一点是，软中断不仅仅只有网络软中断，还有其它类型。\r\n\r\n \r\n\r\n**创建ksoftirqd内核线程**\r\n\r\n ![img](7.Linux网络子系统.assets/wpsB59D.tmp.png)\r\n\r\n \r\n\r\nlinux内核通过调用subsys_initcall来初始化各个子系统，在源代码目录里你可以grep出许多对这个函数的调用。这里我们要说的是网络子系统的初始化，会执行到net_dev_init函数。\r\n\r\n ![img](7.Linux网络子系统.assets/wpsB5AE.tmp.png)\r\n\r\n![img](7.Linux网络子系统.assets/wpsB5AF.tmp.png) \r\n\r\n![img](7.Linux网络子系统.assets/wpsB5B0.tmp.png) \r\n\r\n \r\n\r\n在这个函数里，会为每个CPU都申请一个softnet_data数据结构，在这个数据结构里的poll_list是等待驱动程序将其poll函数注册进来，稍后网卡驱动初始化的时候我们可以看到这一过程。\r\n\r\n另外open_softirq注册了每一种软中断都注册一个处理函数。NET_TX_SOFTIRQ的处理函数为net_tx_action，NET_RX_SOFTIRQ的为net_rx_action。继续跟踪open_softirq后发现这个注册的方式是记录在softirq_vec变量里的。后面ksoftirqd线程收到软中断的时候，也会使用这个变量来找到每一种软中断对应的处理函数。\r\n\r\n \r\n\r\n**协议栈注册**\r\n\r\n内核实现了网络层的ip协议，也实现了传输层的tcp协议和udp协议。这些协议对应的实现函数分别是ip_rcv(),tcp_v4_rcv()和udp_rcv()。和我们平时写代码的方式不一样的是，内核是通过注册的方式来实现的。Linux内核中的fs_initcall和subsys_initcall类似，也是初始化模块的入口。fs_initcall调用inet_init后开始网络协议栈注册。通过inet_init，将这些函数注册到了inet_protos和ptype_base数据结构中\r\n\r\n相关代码如下\r\n\r\n \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n**//file: net/ipv4/af_inet.c**\r\nstatic struct packet_type ip_packet_type __read_mostly = {   .type = cpu_to_be16(ETH_P_IP),   .func = ip_rcv,};\r\nstatic const struct net_protocol udp_protocol = {   .handler =  udp_rcv,   .err_handler =  udp_err,   .no_policy =   1,   .netns_ok = 1,};\r\nstatic const struct net_protocol tcp_protocol = {   .early_demux   =  tcp_v4_early_demux,   .handler   =  tcp_v4_rcv,   .err_handler   =  tcp_v4_err,   .no_policy  =  1,   .netns_ok  =  1,};\r\n\r\n \r\n\r\n![img](7.Linux网络子系统.assets/wpsB5B1.tmp.png) \r\n\r\n![img](7.Linux网络子系统.assets/wpsB5B2.tmp.png) \r\n\r\n![img](7.Linux网络子系统.assets/wpsB5B3.tmp.png) \r\n\r\n \r\n\r\n扩展一下，如果看一下ip_rcv和udp_rcv等函数的代码能看到很多协议的处理过程。例如，ip_rcv中会处理netfilter和iptable过滤，如果你有很多或者很复杂的 netfilter 或 iptables 规则，这些规则都是在软中断的上下文中执行的，会加大网络延迟。再例如，udp_rcv中会判断socket接收队列是否满了。对应的相关内核参数是net.core.rmem_max和net.core.rmem_default。如果有兴趣，建议大家好好读一下inet_init这个函数的代码。\r\n\r\n \r\n\r\n**网卡驱动初始化**\r\n\r\n每一个驱动程序（不仅仅只是网卡驱动）会使用 module_init 向内核注册一个初始化函数，当驱动被加载时，内核会调用这个函数。比如igb网卡驱动的代码位于drivers/net/ethernet/intel/igb/igb_main.c\r\n\r\n \r\n\r\n驱动的pci_register_driver调用完成后，Linux内核就知道了该驱动的相关信息，比如igb网卡驱动的igb_driver_name和igb_probe函数地址等等。当网卡设备被识别以后，内核会调用其驱动的probe方法（igb_driver的probe方法是igb_probe）。驱动probe方法执行的目的就是让设备ready，对于igb网卡，其igb_probe位于drivers/net/ethernet/intel/igb/igb_main.c下。主要执行的操作如下：\r\n\r\n ![img](7.Linux网络子系统.assets/wpsB5B4.tmp.png)\r\n\r\n \r\n\r\n第5步中我们看到，网卡驱动实现了ethtool所需要的接口，也在这里注册完成函数地址的注册。当 ethtool 发起一个系统调用之后，内核会找到对应操作的回调函数。对于igb网卡来说，其实现函数都在drivers/net/ethernet/intel/igb/igb_ethtool.c下。相信你这次能彻底理解ethtool的工作原理了吧？这个命令之所以能查看网卡收发包统计、能修改网卡自适应模式、能调整RX 队列的数量和大小，是因为ethtool命令最终调用到了网卡驱动的相应方法，而不是ethtool本身有这个超能力。\r\n\r\n第6步注册的igb_netdev_ops中包含的是igb_open等函数，该函数在网卡被启动的时候会被调用。\r\n\r\n \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n//file: drivers/net/ethernet/intel/igb/igb_main.......static const struct net_device_ops igb_netdev_ops = {  .ndo_open        = igb_open,  .ndo_stop        = igb_close,  .ndo_start_xmit     = igb_xmit_frame,  .ndo_get_stats64     = igb_get_stats64,  .ndo_set_rx_mode     = igb_set_rx_mode,  .ndo_set_mac_address   = igb_set_mac,  .ndo_change_mtu     = igb_change_mtu,  .ndo_do_ioctl      = igb_ioctl,......}\r\n\r\n第7步中，在igb_probe初始化过程中，还调用到了igb_alloc_q_vector。他注册了一个NAPI机制所必须的poll函数，对于igb网卡驱动来说，这个函数就是igb_poll,如下代码所示。\r\n\r\n \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\nstatic int igb_alloc_q_vector(struct igb_adapter *adapter,          int v_count, int v_idx,          int txr_count, int txr_idx,          int rxr_count, int rxr_idx){   ......   /* initialize NAPI */   netif_napi_add(adapter->netdev, &q_vector->napi,        igb_poll, 64);\r\n}\r\n\r\n \r\n\r\n \r\n\r\n**启动网卡**\r\n\r\n当上面的初始化都完成以后，就可以启动网卡了。回忆前面网卡驱动初始化时，我们提到了驱动向内核注册了 structure net_device_ops 变量，它包含着网卡启用、发包、设置mac 地址等回调函数（函数指针）。当启用一个网卡时（例如，通过 ifconfig eth0 up），net_device_ops 中的 igb_open方法会被调用。它通常会做以下事情：\r\n\r\n ![img](7.Linux网络子系统.assets/wpsB5B5.tmp.png)\r\n\r\n \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n//file: drivers/net/ethernet/intel/igb/igb_main.cstatic int __igb_open(struct net_device *netdev, bool resuming){   /* allocate transmit descriptors */   err = igb_setup_all_tx_resources(adapter);   /* allocate receive descriptors */   err = igb_setup_all_rx_resources(adapter);   /* 注册中断处理函数 */   err = igb_request_irq(adapter);   if (err)     goto err_req_irq;   /* 启用NAPI */   for (i = 0; i < adapter->num_q_vectors; i++)     napi_enable(&(adapter->q_vector[i]->napi));   ......}\r\n\r\n \r\n\r\n在上面__igb_open函数调用了igb_setup_all_tx_resources,和igb_setup_all_rx_resources。在igb_setup_all_rx_resources这一步操作中，分配了RingBuffer，并建立内存和Rx队列的映射关系。（Rx Tx 队列的数量和大小可以通过 ethtool 进行配置）。我们再接着看中断函数注册igb_request_irq:\r\n\r\n \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\nstatic int igb_request_irq(struct igb_adapter *adapter){   if (adapter->msix_entries) {     err = igb_request_msix(adapter);     if (!err)       goto request_done;     ......   }}\r\nstatic int igb_request_msix(struct igb_adapter *adapter){   ......   for (i = 0; i < adapter->num_q_vectors; i++) {     ...     err = request_irq(adapter->msix_entries[vector].vector,          igb_msix_ring, 0, q_vector->name,   } \r\n\r\n \r\n\r\n在上面的代码中跟踪函数调用， __igb_open => igb_request_irq => igb_request_msix, 在igb_request_msix中我们看到了，对于多队列的网卡，为每一个队列都注册了中断，其对应的中断处理函数是igb_msix_ring（该函数也在drivers/net/ethernet/intel/igb/igb_main.c下）。我们也可以看到，msix方式下，每个 RX 队列有独立的MSI-X 中断，从网卡硬件中断的层面就可以设置让收到的包被不同的 CPU处理。（可以通过 irqbalance ，或者修改 /proc/irq/IRQ_NUMBER/smp_affinity能够修改和CPU的绑定行为）。\r\n\r\n \r\n\r\n到此准备工作完成。\r\n\r\n \r\n\r\n### **Linux网络包：中断到网络层接收**\r\n\r\n网卡收包从整体上是网线中的高低电平转换到网卡FIFO存储再拷贝到系统主内存（DDR3）的过程，其中涉及到网卡控制器，CPU，DMA，驱动程序，在OSI模型中属于物理层和链路层，如下图所示。\r\n\r\n![img](7.Linux网络子系统.assets/wpsB5B6.tmp.png) \r\n\r\n###  \r\n\r\n### **中断处理**\r\n\r\n \r\n\r\n![img](7.Linux网络子系统.assets/wpsB5C6.tmp.png) \r\n\r\n \r\n\r\n \r\n\r\n物理网卡收到数据包的处理流程如上图左半部分所示，详细步骤如下：\r\n\r\n\\1. 网卡收到数据包，先将高低电平转换到网卡fifo存储，网卡申请ring buffer的描述，根据描述找到具体的物理地址，从fifo队列物理网卡会使用DMA将数据包写到了该物理地址,，其实就是skb_buffer中.\r\n\r\n\\2. 这个时候数据包已经被转移到skb_buffer中，因为是DMA写入，内核并没有监控数据包写入情况，这时候NIC触发一个硬中断，每一个硬件中断会对应一个中断号，且指定一个vCPU来处理，如上图vcpu2收到了该硬件中断.\r\n\r\n\\3. 硬件中断的中断处理程序，调用驱动程序完成，a.启动软中断\r\n\r\n\\4. 硬中断触发的驱动程序会禁用网卡硬中断，其实这时候意思是告诉NIC，再来数据不用触发硬中断了，把数据DMA拷入系统内存即可\r\n\r\n\\5. 硬中断触发的驱动程序会启动软中断，启用软中断目的是将数据包后续处理流程交给软中断慢慢处理，这个时候退出硬件中断了，但是注意和网络有关的硬中断，要等到后续开启硬中断后，才有机会再次被触发\r\n\r\n\\6. NAPI触发软中断，触发napi系统\r\n\r\n\\7. 消耗ringbuffer指向的skb_buffer\r\n\r\n\\8. NAPI循环处理ringbuffer数据，处理完成\r\n\r\n\\9. 启动网络硬件中断，有数据来时候就可以继续触发硬件中断，继续通知CPU来消耗数据包.\r\n\r\n \r\n\r\n其实上述过程过程简单描述为：网卡收到数据包，DMA到内核内存，中断通知内核数据有了，内核按轮次处理消耗数据包，一轮处理完成后，开启硬中断。其核心就是网卡和内核其实是生产和消费模型，网卡生产，内核负责消费，生产者需要通知消费者消费；如果生产过快会产生丢包，如果消费过慢也会产生问题。也就说在高流量压力情况下，只有生产消费优化后，消费能力够快，此生产消费关系才可以正常维持，所以如果物理接口有丢包计数时候，未必是网卡存在问题，也可能是内核消费的太慢。\r\n\r\n \r\n\r\n关于CPU与ksoftirqd的关系可以描述如下：\r\n\r\n ![img](7.Linux网络子系统.assets/wpsB5C7.tmp.png)\r\n\r\n \r\n\r\n \r\n\r\n**网卡收到的数据写入到内核内存**\r\n\r\nNIC在接收到数据包之后，首先需要将数据同步到内核中，这中间的桥梁是rx ring buffer。它是由NIC和驱动程序共享的一片区域，事实上，rx ring buffer存储的并不是实际的packet数据，而是一个描述符，这个描述符指向了它真正的存储地址，具体流程如下：\r\n\r\n\\1. 驱动在内存中分配一片缓冲区用来接收数据包，叫做sk_buffer;\r\n\r\n\\2. 将上述缓冲区的地址和大小（即接收描述符），加入到rx ring buffer。描述符中的缓冲区地址是DMA使用的物理地址;\r\n\r\n\\3. 驱动通知网卡有一个新的描述符;\r\n\r\n\\4. 网卡从rx ring buffer中取出描述符，从而获知缓冲区的地址和大小;\r\n\r\n\\5. 网卡收到新的数据包;\r\n\r\n\\6. 网卡将新数据包通过DMA直接写到sk_buffer中。\r\n\r\n \r\n\r\n![img](7.Linux网络子系统.assets/wpsB5C8.tmp.png) \r\n\r\n \r\n\r\n当驱动处理速度跟不上网卡收包速度时，驱动来不及分配缓冲区，NIC接收到的数据包无法及时写到sk_buffer，就会产生堆积，当NIC内部缓冲区写满后，就会丢弃部分数据，引起丢包。这部分丢包为rx_fifo_errors，在 /proc/net/dev中体现为fifo字段增长，在ifconfig中体现为overruns指标增长。\r\n\r\n \r\n\r\n**中断下半部分**\r\n\r\nksoftirqd内核线程处理软中断，即中断下半部分软中断处理过程：\r\n\r\n1.NAPI（以e1000网卡为例）：net_rx_action() -> e1000_clean() -> e1000_clean_rx_irq() -> e1000_receive_skb() -> netif_receive_skb()\r\n\r\n2.非NAPI（以dm9000网卡为例）：net_rx_action() -> process_backlog() -> netif_receive_skb()\r\n\r\n最后网卡驱动通过netif_receive_skb()将sk_buff上送协议栈。\r\n\r\n ![img](7.Linux网络子系统.assets/wpsB5C9.tmp.png)\r\n\r\n内核线程初始化的时候，我们介绍了ksoftirqd中两个线程函数ksoftirqd_should_run和run_ksoftirqd。其中ksoftirqd_should_run代码如下：\r\n\r\n ![img](7.Linux网络子系统.assets/wpsB5CA.tmp.png)\r\n\r\n \r\n\r\n\\#define local_softirq_pending() \\\r\n\r\n__IRQ_STAT(smp_processor_id(), __softirq_pending)\r\n\r\n \r\n\r\n这里看到和硬中断中调用了同一个函数local_softirq_pending。使用方式不同的是硬中断位置是为了写入标记，这里仅仅只是读取。如果硬中断中设置了NET_RX_SOFTIRQ,这里自然能读取的到。接下来会真正进入线程函数中run_ksoftirqd处理：\r\n\r\n \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\nstatic void run_ksoftirqd(unsigned int cpu){   local_irq_disable();   if (local_softirq_pending()) {     __do_softirq();     rcu_note_context_switch(cpu);     local_irq_enable();     cond_resched();     return;   }   local_irq_enable();}\r\n\r\n \r\n\r\n \r\n\r\n在__do_softirq中，判断根据当前CPU的软中断类型，调用其注册的action方法。\r\n\r\nasmlinkage void __do_softirq(void)\r\n\r\n ![img](7.Linux网络子系统.assets/wpsB5CB.tmp.png)\r\n\r\n在网络子系统初始化小节，我们看到我们为NET_RX_SOFTIRQ注册了处理函数net_rx_action。所以net_rx_action函数就会被执行到了。\r\n\r\n这里需要注意一个细节，硬中断中设置软中断标记，和ksoftirq的判断是否有软中断到达，都是基于smp_processor_id()的。这意味着只要硬中断在哪个CPU上被响应，那么软中断也是在这个CPU上处理的。所以说，如果你发现你的Linux软中断CPU消耗都集中在一个核上的话，做法是要把调整硬中断的CPU亲和性，来将硬中断打散到不通的CPU核上去。\r\n\r\n我们再来把精力集中到这个核心函数net_rx_action上来。\r\n\r\n \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\nstatic void net_rx_action(struct softirq_action *h){   struct softnet_data *sd = &__get_cpu_var(softnet_data);   unsigned long time_limit = jiffies + 2;   int budget = netdev_budget;   void *have;   local_irq_disable();   while (!list_empty(&sd->poll_list)) {     ......     n = list_first_entry(&sd->poll_list, struct napi_struct, poll_list);     work = 0;     if (test_bit(NAPI_STATE_SCHED, &n->state)) {       work = n->poll(n, weight);       trace_napi_poll(n);     }     budget -= work;   }}\r\n\r\n函数开头的time_limit和budget是用来控制net_rx_action函数主动退出的，目的是保证网络包的接收不霸占CPU不放。等下次网卡再有硬中断过来的时候再处理剩下的接收数据包。其中budget可以通过内核参数调整。这个函数中剩下的核心逻辑是获取到当前CPU变量softnet_data，对其poll_list进行遍历, 然后执行到网卡驱动注册到的poll函数。对于igb网卡来说，就是igb驱动力的igb_poll函数了。\r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n**/** \\*  igb_poll - NAPI Rx polling callback \\*  @napi: napi polling structure \\*  @budget: count of how many packets we should handle **/**static int igb_poll(struct napi_struct *napi, int budget){   ...if (q_vector->tx.ring)     clean_complete = igb_clean_tx_irq(q_vector);if (q_vector->rx.ring)     clean_complete &= igb_clean_rx_irq(q_vector, budget);   ...}\r\n\r\n \r\n\r\n在读取操作中，igb_poll的重点工作是对igb_clean_rx_irq的调用。\r\n\r\n \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\nstatic bool igb_clean_rx_irq(struct igb_q_vector *q_vector, const int budget){   ...do {**/\\* retrieve a buffer from the ring \\*/**    skb = igb_fetch_rx_buffer(rx_ring, rx_desc, skb);**/\\* fetch next buffer in frame if non-eop \\*/**if (igb_is_non_eop(rx_ring, rx_desc))continue;     }**/\\* verify the packet layout is correct \\*/**if (igb_cleanup_headers(rx_ring, rx_desc, skb)) {       skb = NULL;continue;     }**/\\* populate checksum, timestamp, VLAN, and protocol \\*/**    igb_process_skb_fields(rx_ring, rx_desc, skb);     napi_gro_receive(&q_vector->napi, skb);}\r\n\r\n \r\n\r\nigb_fetch_rx_buffer和igb_is_non_eop的作用就是把数据帧从RingBuffer上取下来。为什么需要两个函数呢？因为有可能帧要占多多个RingBuffer，所以是在一个循环中获取的，直到帧尾部。获取下来的一个数据帧用一个sk_buff来表示。收取完数据以后，对其进行一些校验，然后开始设置sbk变量的timestamp, VLAN id, protocol等字段。接下来进入到napi_gro_receive中:\r\n\r\n \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n**//file: net/core/dev.c**gro_result_t napi_gro_receive(struct napi_struct *napi, struct sk_buff *skb){   skb_gro_reset_offset(skb);return napi_skb_finish(dev_gro_receive(napi, skb), skb);}\r\n\r\n \r\n\r\ndev_gro_receive这个函数代表的是网卡GRO特性，可以简单理解成把相关的小包合并成一个大包就行，目的是减少传送给网络栈的包数，这有助于减少 CPU 的使用量。我们暂且忽略，直接看napi_skb_finish, 这个函数主要就是调用了netif_receive_skb。\r\n\r\n \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n**//file: net/core/dev.c**static gro_result_t napi_skb_finish(gro_result_t ret, struct sk_buff *skb){switch (ret) {case GRO_NORMAL:if (netif_receive_skb(skb))       ret = GRO_DROP;break;   ......}\r\n\r\n在netif_receive_skb中，数据包将被送到协议栈中，接下来在网络层协议层的处理流程便不再赘述。\r\n\r\n \r\n\r\n# ***\\*总结\\****\r\n\r\n \r\n\r\n**send发包过程**\r\n\r\n \r\n\r\n1、网卡驱动创建tx descriptor ring（一致性DMA内存），将tx descriptor ring的总线地址写入网卡寄存器TDBA\r\n\r\n2、协议栈通过dev_queue_xmit()将sk_buff下送网卡驱动\r\n\r\n3、网卡驱动将sk_buff放入tx descriptor ring，更新TDT\r\n\r\n4、DMA感知到TDT的改变后，找到tx descriptor ring中下一个将要使用的descriptor\r\n\r\n5、DMA通过PCI总线将descriptor的数据缓存区复制到Tx FIFO\r\n\r\n6、复制完后，通过MAC芯片将数据包发送出去\r\n\r\n7、发送完后，网卡更新TDH，启动硬中断通知CPU释放数据缓存区中的数据包\r\n\r\n \r\n\r\n**recv收包过程**\r\n\r\n \r\n\r\n1、网卡驱动创建rx descriptor ring（一致性DMA内存），将rx descriptor ring的总线地址写入网卡寄存器RDBA\r\n\r\n2、网卡驱动为每个descriptor分配sk_buff和数据缓存区，流式DMA映射数据缓存区，将数据缓存区的总线地址保存到descriptor\r\n\r\n3、网卡接收数据包，将数据包写入Rx FIFO\r\n\r\n4、DMA找到rx descriptor ring中下一个将要使用的descriptor\r\n\r\n5、整个数据包写入Rx FIFO后，DMA通过PCI总线将Rx FIFO中的数据包复制到descriptor的数据缓存区\r\n\r\n6、复制完后，网卡启动硬中断通知CPU数据缓存区中已经有新的数据包了，CPU执行硬中断函数：\r\n\r\nNAPI（以e1000网卡为例）：e1000_intr() -> __napi_schedule() -> __raise_softirq_irqoff(NET_RX_SOFTIRQ)\r\n\r\n非NAPI（以dm9000网卡为例）：dm9000_interrupt() -> dm9000_rx() -> netif_rx() -> napi_schedule() -> __napi_schedule() -> __raise_softirq_irqoff(NET_RX_SOFTIRQ)\r\n\r\n7、ksoftirqd执行软中断函数net_rx_action()：\r\n\r\nNAPI（以e1000网卡为例）：net_rx_action() -> e1000_clean() -> e1000_clean_rx_irq() -> e1000_receive_skb() -> netif_receive_skb()\r\n\r\n非NAPI（以dm9000网卡为例）：net_rx_action() -> process_backlog() -> netif_receive_skb()\r\n\r\n8、网卡驱动通过netif_receive_skb()将sk_buff上送协议栈\r\n\r\n ![img](7.Linux网络子系统.assets/wpsB5DC.tmp.png)\r\n\r\n \r\n\r\n# ***\\*Linux网络子系统的分层\\****\r\n\r\nLinux网络子系统实现需要：\r\n\r\n· \r\n\r\n支持不同的协议族 ( INET, INET6, UNIX, NETLINK...)\r\n\r\n· \r\n\r\n· \r\n\r\n支持不同的网络设备\r\n\r\n· \r\n\r\n· \r\n\r\n支持统一的BSD socket API\r\n\r\n· \r\n\r\n· \r\n\r\n需要屏蔽协议、硬件、平台(API)的差异，因而采用分层结构\r\n\r\n· \r\n\r\n \r\n\r\n**系统调用**\r\n\r\n**系统调用**提供用户的应用程序访问内核的唯一途径。协议无关接口由socket layer来实现的，其提供一组通用功能，以支持各种不同的协议。网络协议层为socket层提供具体协议接口——proto{}，实现具体的协议细节。设备无关接口，提供一组通用函数供底层网络设备驱动程序使用。设备驱动与特定网卡设备相关，定义了具体的协议细节，会分配一个net_device结构，然后用其必需的例程进行初始化。\r\n\r\n \r\n\r\n来源：https://www.cnblogs.com/ypholic/p/14337328.html\r\n\r\n '},"80f6":function(n,r,e){"use strict";e.r(r),r["default"]='# ***\\*云网络丢包故障定位全景指南\\****\r\n\r\nOriginal Alex [极客重生](https://mp.weixin.qq.com/javascript:void(0);) 1/14\r\n\r\n \r\n\r\n \r\n\r\n作者简介：冯荣，腾讯云网络高级工程师，腾讯云网络核心开发人员。  \r\n\r\n​          \r\n\r\n\r\n\r\n引言\r\n\r\n本期分享一个比较常见的⽹络问题--丢包。例如我们去ping⼀个⽹站，如果能ping通，且⽹站返回信息全⾯，则说明与⽹站服务器的通信是畅通的，如果ping不通，或者⽹站返回的信息不全等，则很可能是数据被丢包了，类似情况想必⼤家都不陌⽣。针对⽹络丢包，本⽂提供⼀些常见的丢包故障定位⽅法，希望能够帮助⼤家对⽹络丢包有更多的认识，遇到丢包莫要慌，且跟着⼀起来涨姿(知)势(识)···\r\n\r\n \r\n\r\n什么是丢包\r\n\r\n数据在Internet上是以数据包为单位传输的，单位为字节，数据在⽹络上传输，受⽹络设备，⽹络质量等原因的影响，使得接收到的数据⼩于发送出去的数据，造成丢包。\r\n\r\n \r\n\r\n\r\n数据包接收、发送原理\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEDEE.tmp.png) \r\n\r\n**发送数据包：**\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEDEF.tmp.png) \r\n\r\n1.应⽤程序的数据包，在TCP层增加TCP报⽂头，形成可传输的数据包。\r\n2.在IP层增加IP报头，形成IP报⽂。\r\n3.经过数据⽹卡驱动程序将IP包再添加14字节的MAC头，构成frame（暂⽆CRC），frame（暂⽆CRC）中含有发送端和接收端的MAC地址。\r\n4.驱动程序将frame（暂⽆CRC）拷贝到⽹卡的缓冲区，由⽹卡处理。\r\n5.⽹卡为frame（暂⽆CRC）添加头部同步信息和CRC校验，将其封装为可以发送的packet，然后再发送到⽹线上，这样说就完成了⼀个IP报⽂的发送了，所有连接到这个⽹线上的⽹卡都可以看到该packet。\r\n\r\n \r\n\r\n**接收数据包：**\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEDF0.tmp.png) \r\n\r\n1.⽹卡收到⽹线上的packet，⾸先检查packet的CRC校验，保证完整性，然后将packet头去掉，得到frame。（⽹卡会检查MAC包内的⽬的MAC地址是否和本⽹卡的MAC地址⼀样，不⼀样则会丢弃。）\r\n2.⽹卡将frame拷贝到预分配的ring buffer缓冲。\r\n3.⽹卡驱动程序通知内核处理，经过TCP/IP协议栈层层解码处理。\r\n4.应⽤程序从socket buffer 中读取数据。\r\n\r\n \r\n\r\n\r\n核心思路\r\n\r\n了解了收发包的原理，可以了解到丢包原因主要会涉及⽹卡设备、⽹卡驱动、内核协议栈三⼤类。以下我们将遵循“从下到上分层分析（各层可能性出现的丢包场景），然后查看关键信息，最终得出分析结果”的原则展开介绍。\r\n\r\n \r\n\r\n\r\n **目录--网络丢包情形概览**\r\n\r\n**> 硬件网卡丢包**\r\n\r\n**> 网卡驱动丢包**\r\n\r\n**> 以太网链路层丢包**\r\n\r\n**> 网络IP层丢包**\r\n\r\n**> 传输层UDP/TCP丢包**\r\n\r\n**> 应用层socket丢包**\r\n\r\n针对以上6种情形，分别作出如下详述~\r\n\r\n \r\n\r\n \r\n\r\n## **硬件网卡丢包**\r\n\r\n \r\n\r\n**Ring Buffer溢出** \r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEDF1.tmp.png) \r\n\r\n \r\n\r\n如图所示，物理介质上的数据帧到达后首先由NIC（网络适配器）读取，写入设备内部缓冲区Ring Buffer中，再由中断处理程序触发Softirq从中消费，Ring Buffer的大小因网卡设备而异。当网络数据包到达（生产）的速率快于内核处理（消费）的速率时，Ring Buffer很快会被填满，新来的数据包将被丢弃；\r\n\r\n查看：\r\n\r\n通过ethtool或/proc/net/dev可以查看因Ring Buffer满而丢弃的包统计，在统计项中以fifo标识：\r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n$ ethtool -S eth0|grep rx_fiforx_fifo_errors: 0$ cat /proc/net/devInter-|Receive | Transmitface |bytes packets errs drop fifo frame compressed multicast|bytes packets errs drop fifo colls carrier compressedeth0: 17253386680731 42839525880 0 0 0 0 0 244182022 14879545018057 41657801805 0 0 0 0 0 0\r\n\r\n\\# 查看eth0网卡Ring Buffer最大值和当前设置\r\n\r\n· \r\n\r\n$ ethtool -g eth0\r\n\r\n解决方案：修改网卡eth0接收与发送硬件缓存区大小\r\n\r\n· \r\n\r\n$ ethtool -G eth0 rx 4096 tx 4096\r\n\r\n\r\n\r\n------\r\n\r\n\r\n\r\n \r\n\r\n**网卡端口协商丢包**\r\n\r\n \r\n\r\n\\1. 查看网卡丢包统计：ethtool -S eth1/eth0\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEDF2.tmp.png) \r\n\r\n\\2. 查看网卡配置状态：ethtool eth1/eth0\r\n\r\n \r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE03.tmp.png) \r\n\r\n主要查看网卡和上游网络设备协商速率和模式是否符合预期；\r\n\r\n解决方案：\r\n\r\n1  重新自协商： ethtool -r  eth1/eth0;\r\n\r\n2  如果上游不支持自协商，可以强制设置端口速率：\r\n\r\n· \r\n\r\nethtool -s eth1 speed 1000 duplex full autoneg off\r\n\r\n\r\n\r\n------\r\n\r\n\r\n\r\n \r\n\r\n**网卡流控丢包**\r\n\r\n\\1. 查看流控统计：\r\n\r\n· \r\n\r\nethtool -S eth1 | grep control\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE04.tmp.png) \r\n\r\nrx_flow_control_xon是在网卡的RX Buffer满或其他网卡内部的资源受限时，给交换机端口发送的开启流控的pause帧计数。对应的，tx_flow_control_xoff是在资源可用之后发送的关闭流控的pause帧计数。\r\n\r\n \r\n\r\n2 .查看网络流控配置：ethtool -a eth1\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE05.tmp.png) \r\n\r\n解决方案：关闭网卡流控\r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\nethtool -A ethx autoneg off //自协商关闭ethtool -A ethx tx off //发送模块关闭ethtool -A ethx rx off //接收模块关闭\r\n\r\n\r\n\r\n------\r\n\r\n\r\n\r\n###  \r\n\r\n### **报文mac地址丢包**\r\n\r\n一般计算机网卡都工作在非混杂模式下，此时网卡只接受来自网络端口的目的地址指向自己的数据，如果报文的目的mac地址不是对端的接口的mac地址，一般都会丢包，一般这种情况很有可能是源端设置静态arp表项或者动态学习的arp表项没有及时更新，但目的端mac地址已发生变化（换了网卡），没有更新通知到源端（比如更新报文被丢失，中间交换机异常等情况）；\r\n\r\n查看： \r\n\r\n1.目的端抓包，tcpdump可以开启混杂模式，可以抓到对应的报文，然后查看mac地址；\r\n\r\n2.源端查看arp表或者抓包（上一跳设备），看发送的mac地址是否和下一跳目的端的mac地址一致；\r\n\r\n解决方案：\r\n\r\n1.刷新arp表然后发包触发arp重新学习（可能影响其他报文，增加延时，需要小心操作）；\r\n\r\n2.可以在源端手动设置正确的静态的arp表项；\r\n\r\n \r\n\r\n**其他网卡异常丢包**\r\n\r\n这类异常比少见，但如果都不是上面哪些情况，但网卡统计里面任然有丢包计数，可以试着排查一下：\r\n\r\n**网卡firmware版本:**\r\n\r\n排查一下网卡phy芯片firmware是不是有bug，安装的版本是不是符合预期，查看 ethtool -i eth1:\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE06.tmp.png) \r\n\r\n和厂家提case询问是不是已知问题，有没有新版本等；\r\n\r\n \r\n\r\n**网线接触不良：**\r\n\r\n如果网卡统计里面存在crc error 计数增长，很可能是网线接触不良，可以通知网管排查一下：\r\n\r\n· \r\n\r\nethtool -S eth0\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE07.tmp.png) \r\n\r\n解决方案：一般试着重新插拔一下网线，或者换一根网线，排查插口是否符合端口规格等;\r\n\r\n \r\n\r\n**报文长度丢包**\r\n\r\n网卡有接收正确报文长度范围，一般正常以太网报文长度范围：64-1518，发送端正常情况会填充或者分片来适配，偶尔会发生一些异常情况导致发送报文不正常丢包；\r\n\r\n\r\n查看：\r\n\r\n· \r\n\r\nethtool -S eth1|grep length_errors\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE08.tmp.png) \r\n\r\n解决方案：\r\n\r\n1  调整接口MTU配置，是否开启支持以太网巨帧；\r\n\r\n2  发送端开启PATH MTU进行合理分片；\r\n\r\n简单总结一下网卡丢包：\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE09.tmp.png) \r\n\r\n \r\n\r\n \r\n\r\n## **网卡驱动丢包**\r\n\r\n \r\n\r\n查看：ifconfig eth1/eth0 等接口\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE0A.tmp.png) \r\n\r\n \r\n\r\n1.RX errors: 表示总的收包的错误数量，还包括too-long-frames错误，Ring Buffer 溢出错误，crc 校验错误，帧同步错误，fifo overruns 以及 missed pkg 等等。\r\n\r\n2.RX dropped: 表示数据包已经进入了 Ring Buffer，但是由于内存不够等系统原因，导致在拷贝到内存的过程中被丢弃。\r\n\r\n3.RX overruns: 表示了 fifo 的 overruns，这是由于 Ring Buffer(aka Driver Queue) 传输的 IO 大于 kernel 能够处理的 IO 导致的，而 Ring Buffer 则是指在发起 IRQ 请求之前的那块 buffer。很明显，overruns 的增大意味着数据包没到 Ring Buffer 就被网卡物理层给丢弃了，而 CPU 无法即使的处理中断是造成 Ring Buffer 满的原因之一，上面那台有问题的机器就是因为 interruprs 分布的不均匀(都压在 core0)，没有做 affinity 而造成的丢包。\r\n\r\n\\4. RX frame: 表示 misaligned 的 frames。\r\n\r\n\\5. 对于 TX 的来说，出现上述 counter 增大的原因主要包括 aborted transmission, errors due to carrirer, fifo error, heartbeat erros 以及 windown error，而 collisions 则表示由于 CSMA/CD 造成的传输中断。\r\n\r\n \r\n\r\n**驱动溢出丢包**\r\n\r\nnetdev_max_backlog是内核从NIC收到包后，交由协议栈（如IP、TCP）处理之前的缓冲队列。每个CPU核都有一个backlog队列，与Ring Buffer同理，当接收包的速率大于内核协议栈处理的速率时，CPU的backlog队列不断增长，当达到设定的netdev_max_backlog值时，数据包将被丢弃。\r\n\r\n查看:\r\n\r\n通过查看/proc/net/softnet_stat可以确定是否发生了netdev backlog队列溢出：\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE1B.tmp.png) \r\n\r\n \r\n\r\n其中：每一行代表每个CPU核的状态统计，从CPU0依次往下；每一列代表一个CPU核的各项统计：第一列代表中断处理程序收到的包总数；第二列即代表由于netdev_max_backlog队列溢出而被丢弃的包总数。从上面的输出可以看出，这台服务器统计中，并没有因为netdev_max_backlog导致的丢包。\r\n\r\n解决方案：\r\n\r\nnetdev_max_backlog的默认值是1000，在高速链路上，可能会出现上述第二统计不为0的情况，可以通过修改内核参数net.core.netdev_max_backlog来解决：\r\n\r\n· \r\n\r\n$ sysctl -w net.core.netdev_max_backlog=2000\r\n\r\n**单核负载高导致丢包**\r\n\r\n单核CPU软中断占有高, 导致应用没有机会收发或者收包比较慢，即使调整netdev_max_backlog队列大小仍然会一段时间后丢包，处理速度跟不上网卡接收的速度;\r\n\r\n查看：mpstat -P ALL 1\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE1C.tmp.png) \r\n\r\n \r\n\r\n单核软中断占有100%，导致应用没有机会收发或者收包比较慢而丢包；\r\n\r\n \r\n\r\n**解决方案**：\r\n\r\n1.调整网卡RSS队列配置：\r\n\r\n查看：ethtool -x ethx；\r\n\r\n调整：ethtool -X ethx xxxx；\r\n\r\n2.看一下网卡中断配置是否均衡 cat /proc/interrupts\r\n\r\n调整：\r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n1） irqbalance 调整；# 查看当前运行情况service irqbalance status# 终止服务service irqbalance stop2） 中断绑CPU核 echo mask > /proc/irq/xxx/smp_affinity\r\n\r\n \r\n\r\n3.根据CPU和网卡队列个数调整网卡多队列和RPS配置\r\n\r\n-CPU大于网卡队列个数：\r\n\r\n查看网卡队列 ethtool -x ethx；\r\n\r\n协议栈开启RPS并设置RPS；\r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\necho $mask（CPU配置）> /sys/class/net/$eth/queues/rx-$i/rps_cpusecho 4096（网卡buff）> /sys/class/net/$eth/queues/rx-$i/rps_flow_cnt2）CPU小于网卡队列个数，绑中断就可以，可以试着关闭RPS看一下效果：echo 0 > /sys/class/net/<dev>/queues/rx-<n>/rps_cpus\r\n\r\n4.numa CPU调整，对齐网卡位置，可以提高内核处理速度，从而给更多CPU给应用收包，减缓丢包概率；\r\n\r\n查看网卡numa位置：\r\n\r\n· \r\n\r\n· \r\n\r\nethtool -i eth1|grep bus-infolspci -s bus-info -vv|grep node\r\n\r\n上面中断和RPS设置里面mask需要重新按numa CPU分配重新设置;\r\n\r\n \r\n\r\n5.可以试着开启中断聚合（看网卡是否支持）\r\n\r\n查看 : \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n ethtool -c ethxCoalesce parameters for eth1:Adaptive RX: on  TX: onstats-block-usecs: 0sample-interval: 0pkt-rate-low: 0pkt-rate-high: 0\r\nrx-usecs: 25rx-frames: 0rx-usecs-irq: 0rx-frames-irq: 256\r\ntx-usecs: 25tx-frames: 0tx-usecs-irq: 0tx-frames-irq: 256\r\nrx-usecs-low: 0rx-frame-low: 0tx-usecs-low: 0tx-frame-low: 0\r\nrx-usecs-high: 0rx-frame-high: 0tx-usecs-high: 0tx-frame-high: 0\r\n\r\n调整：\r\n\r\n \r\n\r\n· \r\n\r\nethtool -C ethx adaptive-rx on\r\n\r\n \r\n\r\n简单总结一下网卡驱动丢包处理：\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE1D.tmp.png) \r\n\r\n\r\n\r\n------\r\n\r\n\r\n\r\n##  \r\n\r\n \r\n\r\n \r\n\r\n## **内核协议栈丢包**\r\n\r\n\r\n\r\n***\\*以太网链路层丢包\\****\r\n\r\n \r\n\r\n***\\*neighbor系统arp丢包\\****\r\n\r\n**arp_ignore配置丢包**\r\n\r\narp_ignore参数的作用是控制系统在收到外部的arp请求时，是否要返回arp响应。arp_ignore参数常用的取值主要有0，1，2，3~8较少用到；\r\n\r\n查看：sysctl -a|grep arp_ignore\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE1E.tmp.png) \r\n\r\n**解决方案**：根据实际场景设置对应值；\r\n\r\n0：响应任意网卡上接收到的对本机IP地址的arp请求（包括环回网卡上的地址），而不管该目的IP是否在接收网卡上。\r\n\r\n1：只响应目的IP地址为接收网卡上的本地地址的arp请求。\r\n\r\n2：只响应目的IP地址为接收网卡上的本地地址的arp请求，并且arp请求的源IP必须和接收网卡同网段。\r\n\r\n3：如果ARP请求数据包所请求的IP地址对应的本地地址其作用域（scope）为主机（host），则不回应ARP响应数据包，如果作用域为全局（global）或链路（link），则回应ARP响应数据包。\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE1F.tmp.png)![img](8.云网络丢包故障定位全景指南.assets/wpsEE20.tmp.png) \r\n\r\n \r\n\r\n**arp_filter配置丢包**\r\n\r\n在多接口系统里面（比如腾讯云的弹性网卡场景），这些接口都可以回应arp请求，导致对端有可能学到不同的mac地址，后续报文发送可能由于mac地址和接收报文接口mac地址不一样而导致丢包，arp_filter主要是用来适配这种场景；\r\n\r\n查看：\r\n\r\n· \r\n\r\nsysctl -a | grep arp_filter\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE21.tmp.png) \r\n\r\n解决方案： \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n根据实际场景设置对应的值，一般默认是关掉此过滤规则，特殊情况可以打开；0：默认值，表示回应arp请求的时候不检查接口情况；1：表示回应arp请求时会检查接口是否和接收请求接口一致，不一致就不回应；\r\n\r\n \r\n\r\n**arp表满导致丢包**\r\n\r\n比如下面这种情况，由于突发arp表项很多 超过协议栈默认配置，发送报文的时候部分arp创建失败，导致发送失败，从而丢包：\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE22.tmp.png) \r\n\r\n查看：\r\n\r\n· \r\n\r\n查看arp状态：cat /proc/net/stat/arp_cache ，table_fulls统计：\r\n\r\n· \r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE23.tmp.png) \r\n\r\n· \r\n\r\n 查看dmesg消息（内核打印）：\r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\ndmesg|grep neighbourneighbour: arp_cache: neighbor table overflow!\r\n\r\n· \r\n\r\n查看当前arp表大小：ip n|wc -l\r\n\r\n· \r\n\r\n   查看系统配额：\r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\nsysctl -a |grep net.ipv4.neigh.default.gc_threshgc_thresh1：存在于ARP高速缓存中的最少层数，如果少于这个数，垃圾收集器将不会运行。缺省值是128。\r\ngc_thresh2 ：保存在 ARP 高速缓存中的最多的记录软限制。垃圾收集器在开始收集前，允许记录数超过这个数字 5 秒。缺省值是 512。gc_thresh3 ：保存在 ARP 高速缓存中的最多记录的硬限制，一旦高速缓存中的数目高于此，垃圾收集器将马上运行。缺省值是1024。\r\n\r\n一般在内存足够情况下，可以认为gc_thresh3 值是arp 表总大小；\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE24.tmp.png) \r\n\r\n**解决方案**：根据实际arp最大值情况（比如访问其他子机最大个数），调整arp表大小\r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n$ sudo sysctl -w net.ipv4.neigh.default.gc_thresh1=1024$ sudo sysctl -w net.ipv4.neigh.default.gc_thresh2=2048$ sudo sysctl -w net.ipv4.neigh.default.gc_thresh3=4096$ sudo sysctl  -p\r\n\r\n**arp请求缓存队列溢出丢包**\r\n\r\n查看：\r\n\r\n \r\n\r\n· \r\n\r\ncat /proc/net/stat/arp_cache ，unresolved_discards是否有新增计数\r\n\r\n解决方案：根据客户需求调整缓存队列大小unres_qlen_bytes：\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE34.tmp.png) \r\n\r\n \r\n\r\n\r\n\r\n------\r\n\r\n\r\n\r\n#  \r\n\r\n# ***\\*网络IP层丢包\\****\r\n\r\n \r\n\r\n### **接口ip地址配置丢包**\r\n\r\n\\1. 本机服务不通，检查lo接口有没有配置地址是127.0.0.1；\r\n\r\n2 .本机接收失败， 查看local路由表：ip r show table local|grep 子机ip地址；这种丢包一般会出现在多IP场景，子机底层配置多ip失败，导致对应ip收不到包而丢包；\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE35.tmp.png) \r\n\r\n解决方案：\r\n\r\n1.配置正确接口ip地址；比如ip a add 1.1.1.1 dev eth0 \r\n\r\n2.如果发现接口有地址还丢包，可能是local路由表没有对应条目，紧急情况下，可以用手工补上：\r\n\r\n比如ip r add local 本机ip地址 dev eth0 table local ；\r\n\r\n \r\n\r\n\r\n\r\n------\r\n\r\n\r\n\r\n###  \r\n\r\n### **路由丢包**\r\n\r\n**路由配置丢包**\r\n\r\n查看：\r\n\r\n1.查看配置 路由是否设置正确（是否可达），是否配置策略路由（在弹性网卡场景会出现此配置）ip rule：\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE36.tmp.png) \r\n\r\n然后找到对应路由表。查看路由表：\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE37.tmp.png) \r\n\r\n或者直接用 ip r get x.x.x.x，让系统帮你查找是否存在可达路由，接口是否符合预期；\r\n\r\n \r\n\r\n2.查看系统统计信息： \r\n\r\n· \r\n\r\nnetstat -s|grep "dropped because of missing route"\r\n\r\n解决方案：重新配置正确的路由；\r\n\r\n  \r\n\r\n\r\n\r\n------\r\n\r\n\r\n\r\n \r\n\r\n**反向路由过滤丢包**\r\n\r\n反向路由过滤机制是Linux通过反向路由查询，检查收到的数据包源IP是否可路由（Loose mode）、是否最佳路由（Strict mode），如果没有通过验证，则丢弃数据包，设计的目的是防范IP地址欺骗攻击。\r\n\r\n查看：\r\n\r\nrp_filter提供三种模式供配置：\r\n\r\n0 - 不验证\r\n\r\n1 - RFC3704定义的严格模式：对每个收到的数据包，查询反向路由，如果数据包入口和反向路由出口不一致，则不通过\r\n\r\n2 - RFC3704定义的松散模式：对每个收到的数据包，查询反向路由，如果任何接口都不可达，则不通过\r\n\r\n查看当前rp_filter策略配置：\r\n\r\n \r\n\r\n$cat /proc/sys/net/ipv4/conf/eth0/rp_filter\r\n\r\n如果这里设置为1，就需要查看主机的网络环境和路由策略是否可能会导致客户端的入包无法通过反向路由验证了。\r\n\r\n从原理来看这个机制工作在网络层，因此，如果客户端能够Ping通服务器，就能够排除这个因素了。\r\n\r\n解决方案：\r\n\r\n根据实际网络环境将rp_filter设置为0或2：\r\n\r\n· \r\n\r\n· \r\n\r\n$ sysctl -w net.ipv4.conf.all.rp_filter=2或$ sysctl -w net.ipv4.conf.eth0.rp_filter=2\r\n\r\n###  \r\n\r\n### **防火墙丢包**\r\n\r\n**客户设置规则导致丢包**\r\n\r\n查看：\r\n\r\n· \r\n\r\n iptables -nvL |grep DROP ;\r\n\r\n解决方案： 修改防火墙规则；\r\n\r\n \r\n\r\n\r\n\r\n------\r\n\r\n\r\n\r\n \r\n\r\n**连接跟踪导致丢包**\r\n\r\n**连接跟踪表溢出丢包**\r\n\r\nkernel 用 ip_conntrack 模块来记录 iptables 网络包的状态，并把每条记录保存到 table 里（这个 table 在内存里，可以通过/proc/net/ip_conntrack 查看当前已经记录的总数），如果网络状况繁忙，比如高连接，高并发连接等会导致逐步占用这个 table 可用空间，一般这个 table 很大不容易占满并且可以自己清理，table 的记录会一直呆在 table 里占用空间直到源 IP 发一个 RST 包，但是如果出现被攻击、错误的网络配置、有问题的路由/路由器、有问题的网卡等情况的时候，就会导致源 IP 发的这个 RST 包收不到，这样就积累在 table 里，越积累越多直到占满。无论，哪种情况导致table变满，满了以后就会丢包，出现外部无法连接服务器的情况。内核会报如下错误信息：kernel: ip_conntrack: table full, dropping packet；\r\n\r\n查看当前连接跟踪数 :\r\n\r\n· \r\n\r\ncat /proc/sys/net/netfilter/nf_conntrack_max\r\n\r\n解决方案：\r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n增大跟踪的最大条数net.netfilter.nf_conntrack_max  = 3276800减少跟踪连接的最大有效时间net.netfilter.nf_conntrack_tcp_timeout_established = 1200net.netfilter.nf_conntrack_udp_timeout_stream = 180net.netfilter.nf_conntrack_icmp_timeout = 30\r\n\r\n\r\n\r\n------\r\n\r\n\r\n\r\n \r\n\r\n**ct创建冲突失导致丢包**\r\n\r\n查看：当前连接跟踪统计：cat /proc/net/stat/nf_conntrack，可以查各种ct异常丢包统计\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE38.tmp.png) \r\n\r\n \r\n\r\n解决方案：内核热补丁修复或者更新内核版本（合入补丁修改）；\r\n\r\n \r\n\r\n\r\n\r\n------\r\n\r\n\r\n\r\n \r\n\r\n**传输层UDP/TCP丢包**\r\n\r\n \r\n\r\n***\\*tcp 连接跟踪安全检查丢包\\****\r\n\r\n丢包原因：由于连接没有断开，但服务端或者client之前出现过发包异常等情况（报文没有经过连接跟踪模块更新窗口计数），没有更新合法的window范围，导致后续报文安全检查被丢包；协议栈用nf_conntrack_tcp_be_liberal 来控制这个选项：\r\n\r\n1：关闭，只有不在tcp窗口内的rst包被标志为无效；\r\n\r\n0：开启;  所有不在tcp窗口中的包都被标志为无效；\r\n\r\n查看： \r\n\r\n查看配置 ：\r\n\r\n· \r\n\r\n· \r\n\r\nsysctl -a|grep nf_conntrack_tcp_be_liberal net.netfilter.nf_conntrack_tcp_be_liberal = 1\r\n\r\n查看log：\r\n\r\n一般情况下netfiler模块默认没有加载log，需要手动加载;\r\n\r\n \r\n\r\n· \r\n\r\n· \r\n\r\nmodprobe ipt_LOG11sysctl -w net.netfilter.nf_log.2=ipt_LOG\r\n\r\n然后发包后在查看syslog；\r\n\r\n解决方案：根据实际抓包分析情况判断是不是此机制导致的丢包，可以试着关闭试一下；\r\n\r\n \r\n\r\n### **分片重组丢包**\r\n\r\n情况总结：**超时**\r\n\r\n查看：\r\n\r\n· \r\n\r\n· \r\n\r\nnetstat -s|grep timeout601 fragments dropped after timeout\r\n\r\n解决方法：调整超时时间\r\n\r\n· \r\n\r\n· \r\n\r\nnet.ipv4.ipfrag_time = 30sysctl -w net.ipv4.ipfrag_time=60\r\n\r\n**frag_high_thresh, 分片的内存超过一定阈值会导致系统安全检查丢包**\r\n\r\n查看：\r\n\r\n \r\n\r\n· \r\n\r\n· \r\n\r\nnetstat -s|grep reassembles8094 packet reassembles failed\r\n\r\n解决方案：调整大小\r\n\r\n· \r\n\r\n· \r\n\r\nnet.ipv4.ipfrag_high_thresh net.ipv4.ipfrag_low_thresh\r\n\r\n**分片安全距检查离丢包**\r\n\r\n查看：\r\n\r\n· \r\n\r\n· \r\n\r\nnetstat -s|grep reassembles8094 packet reassembles failed\r\n\r\n解决方案： 把ipfrag_max_dist设置为0，就关掉此安全检查\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE39.tmp.png) \r\n\r\npfrag_max_dist特性，在一些场景下其实并不适用：\r\n\r\n1.有大量的网络报文交互\r\n\r\n2.发送端的并发度很高，同时SMP架构，导致很容易造成这种乱序情况；\r\n\r\n \r\n\r\n**分片hash bucket冲突链太长超过系统默认值128**\r\n\r\n查看： \r\n\r\n· \r\n\r\n· \r\n\r\ndmesg|grep “Dropping fragment”inet_frag_find: Fragment hash bucket 128 list length grew over limit. Dropping fragment.\r\n\r\n解决方案：热补丁调整hash大小；\r\n\r\n \r\n\r\n**系统内存不足，创建新分片队列失败**\r\n\r\n查看方法：\r\n\r\n· \r\n\r\n· \r\n\r\nnetstat -s|grep reassembles8094 packet reassembles failed\r\n\r\ndropwatch查看丢包位置 ：\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE3A.tmp.png) \r\n\r\n解决方案：\r\n\r\na.增大系统网络内存：\r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\nnet.core.rmem_default net.core.rmem_max net.core.wmem_default\r\n\r\nb.系统回收内存：\r\n\r\n紧急情况下，可以用 /proc/sys/vm/drop_caches, 去释放一下虚拟内存；\r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\nTo free pagecache:# echo 1 > /proc/sys/vm/drop_cachesTo free dentries and inodes:# echo 2 > /proc/sys/vm/drop_cachesTo free pagecache, dentries and inodes:echo 3 > /proc/sys/vm/drop_caches\r\n\r\n\r\n\r\n------\r\n\r\n\r\n\r\n###  \r\n\r\n### **MTU丢包**\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE3B.tmp.png) \r\n\r\n查看：\r\n\r\n1.检查接口MTU配置，ifconfig eth1/eth0，默认是1500；\r\n\r\n2.进行MTU探测，然后设置接口对应的MTU值；\r\n\r\n解决方案：\r\n\r\n\\1. 根据实际情况，设置正确MTU值；\r\n\r\n\\2. 设置合理的tcp mss，启用TCP MTU Probe:\r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\ncat /proc/sys/net/ipv4/tcp_mtu_probing:tcp_mtu_probing - INTEGER Controls TCP Packetization-Layer Path MTU Discovery.Takes three values:0 - Disabled 1 - Disabled by default, enabled when an ICMP black hole detected2 - Always enabled, use initial MSS of tcp_base_mss.\r\n\r\n# **tcp层丢包**\r\n\r\n**TIME_WAIT过多丢包**\r\n\r\n大量TIMEWAIT出现，并且需要解决的场景，在高并发短连接的TCP服务器上，当服务器处理完请求后立刻按照主动正常关闭连接。。。这个场景下，会出现大量socket处于TIMEWAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上；\r\n\r\n查看：\r\n\r\n查看系统log ：\r\n\r\n· \r\n\r\n· \r\n\r\ndmsgTCP: time wait bucket table overflow；\r\n\r\n查看系统配置：\r\n\r\n· \r\n\r\n· \r\n\r\nsysctl -a|grep tcp_max_tw_bucketsnet.ipv4.tcp_max_tw_buckets = 16384\r\n\r\n解决方案：\r\n\r\n\\1. tw_reuse，tw_recycle 必须在客户端和服务端timestamps 开启时才管用（默认打开）\r\n\r\n\\2. tw_reuse 只对客户端起作用，开启后客户端在1s内回收；\r\n\r\n\\3. tw_recycle对客户端和服务器同时起作用，开启后在3.5*RTO 内回收，RTO 200ms~ 120s具体时间视网络状况。内网状况比tw_reuse稍快，公网尤其移动网络大多要比tw_reuse 慢，优点就是能够回收服务端的TIME_WAIT数量；\r\n\r\n在服务端，如果网络路径会经过NAT节点，不要启用net.ipv4.tcp_tw_recycle，会导致时间戳混乱，引起其他丢包问题；\r\n\r\n\\4. 调整tcp_max_tw_buckets大小，如果内存足够：\r\n\r\n \r\n\r\n· \r\n\r\nsysctl -w net.ipv4.tcp_max_tw_buckets=163840；\r\n\r\n**时间戳异常丢包**\r\n\r\n当多个客户端处于同一个NAT环境时，同时访问服务器，不同客户端的时间可能不一致，此时服务端接收到同一个NAT发送的请求，就会出现时间戳错乱的现象，于是后面的数据包就被丢弃了，具体的表现通常是是客户端明明发送的SYN，但服务端就是不响应ACK。在服务器借助下面的命令可以来确认数据包是否有不断被丢弃的现象。\r\n\r\n检查：\r\n\r\n· \r\n\r\n· \r\n\r\nnetstat -s | grep rejects\r\n\r\n解决方案：\r\n\r\n如果网络路径会经过NAT节点，不要启用net.ipv4.tcp_tw_recycle；\r\n\r\n \r\n\r\n**TCP队列问题导致丢包**\r\n\r\n**原理：**\r\n\r\n**tcp状态机（三次握手）**\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE3C.tmp.jpg) \r\n\r\n **协议处理：**\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE4D.tmp.png) \r\n\r\n**一个是半连接队列（syn queue）：**\r\n\r\n在三次握手协议中，服务器维护一个半连接队列，该队列为每个客户端的SYN包开设一个条目(服务端在接收到SYN包的时候，就已经创建了request_sock结构，存储在半连接队列中)，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包（会进行第二次握手发送SYN＋ACK的包加以确认）。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。该队列为SYN队列，长度为max(64,/proc/sys/net/ipv4/tcp_max_syn_backlog),  机器的tcp_max_syn_backlog值在/proc/sys/net/ipv4/tcp_max_syn_backlog下配置;\r\n\r\n \r\n\r\n**一个是全连接队列（accept queue）：**\r\n\r\n第三次握手时，当server接收到ACK 报之后， 会进入一个新的叫 accept 的队列，该队列的长度为 min(backlog, somaxconn)，默认情况下，somaxconn 的值为 128，表示最多有 129 的 ESTAB 的连接等待 accept()，而 backlog 的值则应该是由 int listen(int sockfd, int backlog) 中的第二个参数指定，listen 里面的 backlog 可以有我们的应用程序去定义的;\r\n\r\n \r\n\r\n查看：\r\n\r\n连接建立失败,syn丢包：\r\n\r\n· \r\n\r\n· \r\n\r\nnetstat -s |grep -i listenSYNs to LISTEN sockets dropped\r\n\r\n也会受到连接满丢包影响\r\n\r\n解决方案： 增加大小 tcp_max_syn_backlog\r\n\r\n连接满丢包\r\n\r\n-xxx times the listen queue of a socket overflowed\r\n\r\n查看：\r\n\r\n· \r\n\r\n查看accept队列大小 ：net.core.somaxconn\r\n\r\n· \r\n\r\n· \r\n\r\nss -lnt查询socket队列 ：LISTEN 状态: Recv-Q 表示的当前等待服务端调用 accept 完成三次握手的 listen backlog 数值，也就是说，当客户端通过 connect() 去连接正在 listen() 的服务端时，这些连接会一直处于这个 queue 里面直到被服务端 accept()；Send-Q 表示的则是最大的 listen backlog 数值，这就就是上面提到的 min(backlog, somaxconn) 的值，\r\n\r\n· \r\n\r\n· \r\n\r\n看一下是不是应用程序设置限制， int listen(int sockfd, int backlog)；\r\n\r\n· \r\n\r\n解决方案：\r\n\r\n· \r\n\r\n Linux内核参进行优化，可以缓解压力 tcp_abort_on_overflow=1\r\n\r\n· \r\n\r\n· \r\n\r\n 调整net.core.somaxconn大小;\r\n\r\n· \r\n\r\n· \r\n\r\n 应用程序设置问题，通知客户程序修改；\r\n\r\n· \r\n\r\n \r\n\r\n· \r\n\r\n**syn flood攻击丢包**\r\n\r\n 目前，Linux下默认会进行5次重发SYN-ACK包，重试的间隔时间从1s开始，下次的重试间隔时间是前一次的双倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s，TCP才会把断开这个连接。由于，SYN超时需要63秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的SYN包给Server(俗称 SYN flood 攻击)，用于耗尽Server的SYN队列。对于应对SYN 过多的问题;\r\n\r\n查看： 查看syslog： kernel: [3649830.269068] TCP: Possible SYN flooding on port xxx. Sending cookies. Check SNMP counters.\r\n\r\n解决方案：\r\n\r\n· \r\n\r\n增大tcp_max_syn_backlog\r\n\r\n· \r\n\r\n· \r\n\r\n减少tcp_synack_retries\r\n\r\n· \r\n\r\n· \r\n\r\n启用tcp_syncookies\r\n\r\n· \r\n\r\n· \r\n\r\n启用tcp_abort_on_overflow， tcp_abort_on_overflow修改成 1，1表示第三步的时候如果全连接队列满了，server发送一个reset包给client，表示废掉这个握手过程和这个连接（本来在server端这个连接就还没建立起来）；\r\n\r\n· \r\n\r\n \r\n\r\n**PAWS机制丢包**\r\n\r\n原理：PAWS(Protect Against Wrapped Sequence numbers)，高带宽下，TCP序列号可能在较短的时间内就被重复使用(recycle/wrapped)\r\n就可能导致同一条TCP流在短时间内出现序号一样的两个合法的数据包及其确认包。\r\n\r\n查看：\r\n\r\n \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n$netstat -s |grep -e "passive connections rejected because of time stamp" -e "packets rejects in established connections because of timestamp” 387158 passive connections rejected because of time stamp825313 packets rejects in established connections because of timestamp\r\n\r\n通过sysctl查看是否启用了tcp_tw_recycle及tcp_timestamp:\r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n$ sysctl net.ipv4.tcp_tw_recyclenet.ipv4.tcp_tw_recycle = 1 $ sysctl net.ipv4.tcp_timestampsnet.ipv4.tcp_timestamps = 1\r\n\r\n \r\n\r\n\\1. tcp_tw_recycle参数。它用来快速回收TIME_WAIT连接，不过如果在NAT环境下会引发问题;\r\n\r\n\\2. 当多个客户端通过NAT方式联网并与服务端交互时，服务端看到的是同一个IP，也就是说对服务端而言这些客户端实际上等同于一个，可惜由于这些客户端的时间戳可能存在差异，于是乎从服务端的视角看，便可能出现时间戳错乱的现象，进而直接导致时间戳小的数据包被丢弃。如果发生了此类问题，具体的表现通常是是客户端明明发送的SYN，但服务端就是不响应ACK。\r\n\r\n解决方案： \r\n\r\n在NAT环境下，清除tcp时间戳选项，或者不开启tcp_tw_recycle参数；\r\n\r\n \r\n\r\n**TLP问题丢包**\r\n\r\nTLP主要是为了解决尾丢包重传效率的问题，TLP能够有效的避免较长的RTO超时，进而提高TCP性能，详细参考文章：\r\n\r\nhttp://perthcharles.github.io/2015/10/31/wiki-network-tcp-tlp/；\r\n\r\n但在低时延场景下（短连接小包量），TLP与延迟ACK组合可能会造成无效重传，导致客户端感发现大量假重传包，加大了响应延迟；\r\n\r\n查看：\r\n\r\n查看协议栈统计：\r\n\r\n· \r\n\r\nnetstat -s |grep TCPLossProbes\r\n\r\n查看系统配置：\r\n\r\n· \r\n\r\n sysctl -a | grep tcp_early_retrans\r\n\r\n \r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE4E.tmp.png) \r\n\r\n解决方案：\r\n\r\n1.关掉延迟ack，打开快速ack；\r\n\r\n2.linux实现nodelay语意不是快速ack，只是关闭nagle算法；\r\n\r\n3.打开快速ack选项，socket里面有个 TCP_QUICKACK 选项， 需要每次recv后再设置一次。\r\n\r\n \r\n\r\n**内存不足导致丢包**\r\n\r\n查看：\r\n\r\n查看log：\r\n\r\n· \r\n\r\ndmesg|grep “out of memory”\r\n\r\n查看系统配置： \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\ncat /proc/sys/net/ipv4/tcp_memcat /proc/sys/net/ipv4/tcp_rmemcat /proc/sys/net/ipv4/tcp_wmem\r\n\r\n解决方案：\r\n\r\n根据TCP业务并发流量，调整系统参数，一般试着增大2倍或者其他倍数来看是否缓解；\r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\nsysclt -w net.ipv4.tcp_mem=sysclt -w net.ipv4.tcp_wmem=sysclt -w net.ipv4.tcp_rmem=sysctl -p\r\n\r\n\r\n\r\n------\r\n\r\n\r\n\r\n \r\n\r\n**TCP超时丢包**\r\n\r\n查看：\r\n\r\n抓包分析一下网络RTT：\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE4F.tmp.png) \r\n\r\n用其他工具测试一下当前端到端网络质量（hping等）；\r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n\\# hping -S 9.199.10.104 -AHPING 9.199.10.104 (bond1 9.199.10.104): SA set, 40 headers + 0 data byteslen=46 ip=9.199.10.104 ttl=53 DF id=47617 sport=0 flags=R seq=0 win=0 rtt=38.3 mslen=46 ip=9.199.10.104 ttl=53 DF id=47658 sport=0 flags=R seq=1 win=0 rtt=38.3 mslen=46 ip=9.199.10.104 ttl=53 DF id=47739 sport=0 flags=R seq=2 win=0 rtt=30.4 mslen=46 ip=9.199.10.104 ttl=53 DF id=47842 sport=0 flags=R seq=3 win=0 rtt=30.4 mslen=46 ip=9.199.10.104 ttl=53 DF id=48485 sport=0 flags=R seq=4 win=0 rtt=38.7 mslen=46 ip=9.199.10.104 ttl=53 DF id=49274 sport=0 flags=R seq=5 win=0 rtt=34.1 mslen=46 ip=9.199.10.104 ttl=53 DF id=49491 sport=0 flags=R seq=6 win=0 rtt=30.3 ms\r\n\r\n解决方案：\r\n\r\n· \r\n\r\n关闭Nagle算法，减少小包延迟；\r\n\r\n· \r\n\r\n· \r\n\r\n关闭延迟ack:\r\n\r\n· \r\n\r\n· \r\n\r\n sysctl -w net.ipv4.tcp_no_delay_ack=1\r\n\r\n \r\n\r\n**TCP乱序丢包**\r\n\r\n此时TCP会无法判断是数据包丢失还是乱序，因为丢包和乱序都会导致接收端收到次序混乱的数据包，造成接收端的数据空洞。TCP会将这种情况暂定为数据包的乱序，因为乱序是时间问题（可能是数据包的迟到），而丢包则意味着重传。当TCP意识到包出现乱序的情况时，会立即ACK，该ACK的TSER部分包含的TSEV值会记录当前接收端收到有序报文段的时刻。这会使得数据包的RTT样本值增大，进一步导致RTO时间延长。这对TCP来说无疑是有益的，因为TCP有充分的时间判断数据包到底是失序还是丢了来防止不必要的数据重传。当然严重的乱序则会让发送端以为是丢包一旦重复的ACK超过TCP的阈值，便会触发超时重传机制，以及时解决这种问题；详细请参考博客：\r\n\r\nhttps://blog.csdn.net/dog250/article/details/78692585\r\n\r\n \r\n\r\n查看：抓包分析是否存在很多乱序报文：\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE50.tmp.png) \r\n\r\n解决方案：如果在多径传输场景或者网络质量不好，可以通过修改下面值来提供系统对TCP无序传送的容错率：\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE51.tmp.png) \r\n\r\n\r\n\r\n------\r\n\r\n\r\n\r\n###  \r\n\r\n### **拥塞控制丢包**\r\n\r\n在互联网发展的过程当中，TCP算法也做出了一定改变，先后演进了\r\n\r\nReno、NewReno、Cubic和Vegas，这些改进算法大体可以分为基于丢包和基于延时的拥塞控制算法。基于丢包的拥塞控制算法以Reno、NewReno为代表，它的主要问题有Buffer bloat和长肥管道两种，基于丢包的协议拥塞控制机制是被动式的，其依据网络中的丢包事件来做网络拥塞判断。即使网络中的负载很高，只要没有产生拥塞丢包，协议就不会主动降低自己的发送速度。最初路由器转发出口的Buffer 是比较小的，TCP在利用时容易造成全局同步，降低带宽利用率，随后路由器厂家由于硬件成本下降不断地增加Buffer，基于丢包反馈的协议在不丢包的情况下持续占用路由器buffer，虽然提高了网络带宽的利用率，但同时也意味着发生拥塞丢包后，网络抖动性加大。另外对于带宽和RTT都很高的长肥管道问题来说，管道中随机丢包的可能性很大，TCP的默认buffer设置比较小加上随机丢包造成的cwnd经常下折，导致带宽利用率依旧很低； BBR（Bottleneck Bandwidth and Round-trip propagation time）是一种基于带宽和延迟反馈的拥塞控制算法。目前已经演化到第二版，是一个典型的封闭反馈系统，发送多少报文和用多快的速度发送这些报文都是在每次反馈中不断调节。在BBR提出之前，拥塞控制都是基于事件的算法，需要通过丢包或延时事件驱动；BBR提出之后，拥塞控制是基于反馈的自主自动控制算法，对于速率的控制是由算法决定，而不由网络事件决定，BBR算法的核心是找到最大带宽（Max BW）和最小延时（Min RTT）这两个参数，最大带宽和最小延时的乘积可以得到BDP(Bandwidth Delay Product), 而BDP就是网络链路中可以存放数据的最大容量。BDP驱动Probing State Machine得到Rate quantum和cwnd，分别设置到发送引擎中就可以解决发送速度和数据量的问题。\r\n\r\n \r\n\r\nLinux 4.9内核首次采用BBR拥塞控制算法第一个版本，BBR抗丢包能力比其他算法要强，但这个版本在某些场景下面有问题（缺点），BBR在实时音视频领域存在的问题，深队列竞争不过Cubic。\r\n\r\n \r\n\r\n问题现象就是：在深队列场景，BBR的ProbeRTT阶段只发4个包，发送速率下降太多会引发延迟加大和卡顿问题。\r\n\r\n查看：\r\n\r\n· \r\n\r\nss -sti //在源端 ss -sti|grep 10.125.42.49:47699 -A 3 （ 10.125.42.49:47699 是目的端地址和端口号）\r\n\r\n \r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE52.tmp.png) \r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE53.tmp.png) \r\n\r\n解决方案：\r\n\r\n· \r\n\r\nProbeRTT并不适用实时音视频领域，因此可以选择直接去除，或者像BBRV2把probe RTT缩短到2.5s一次，使用0.5xBDP发送；\r\n\r\n· \r\n\r\n· \r\n\r\n如果没有特殊需求，切换成稳定的cubic算法；\r\n\r\n· \r\n\r\n \r\n\r\n· \r\n\r\n\r\n\r\n------\r\n\r\n\r\n\r\n· \r\n\r\n \r\n\r\n· \r\n\r\n \r\n\r\n# **UDP层丢包**\r\n\r\n**收发包失败丢包**\r\n\r\n查看：netstat 统计\r\n\r\n如果有持续的 receive buffer errors/send buffer errors 计数；\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE54.tmp.png) \r\n\r\n \r\n\r\n解决方案：\r\n\r\n\\1. \r\n\r\nCPU负载（多核绑核配置），网络负载（软中断优化，调整驱动队列netdev_max_backlog），内存配置（协议栈内存）；\r\n\r\n\\2. \r\n\r\n\\3. \r\n\r\n按峰值在来，增大buffer缓存区大小：\r\n\r\n\\4. \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\nnet.ipv4.udp_mem = xxxnet.ipv4.udp_rmem_min = xxxnet.ipv4.udp_wmem_min = xxx\r\n\r\n   \\3. 调整应用设计：\r\n\r\n· \r\n\r\nUDP本身就是无连接不可靠的协议，适用于报文偶尔丢失也不影响程序状态的场景，比如视频、音频、游戏、监控等。对报文可靠性要求比较高的应用不要使用 UDP，推荐直接使用 TCP。当然，也可以在应用层做重试、去重保证可靠性\r\n\r\n· \r\n\r\n· \r\n\r\n如果发现服务器丢包，首先通过监控查看系统负载是否过高，先想办法把负载降低再看丢包问题是否消失\r\n\r\n· \r\n\r\n· \r\n\r\n如果系统负载过高，UDP丢包是没有有效解决方案的。如果是应用异常导致CPU、memory、IO 过高，请及时定位异常应用并修复；如果是资源不够，监控应该能及时发现并快速扩容\r\n\r\n· \r\n\r\n· \r\n\r\n对于系统大量接收或者发送UDP报文的，可以通过调节系统和程序的 socket buffer size 来降低丢包的概率\r\n\r\n· \r\n\r\n· \r\n\r\n应用程序在处理UDP报文时，要采用异步方式，在两次接收报文之间不要有太多的处理逻辑\r\n\r\n· \r\n\r\n \r\n\r\n\r\n\r\n------\r\n\r\n\r\n\r\n#  \r\n\r\n# **应用层socket丢包**\r\n\r\n \r\n\r\n**socket缓存区接收丢包**\r\n\r\n查看： \r\n\r\n\\1. 抓包分析是否存在丢包情况；\r\n\r\n\\2. 查看统计：\r\n\r\n· \r\n\r\nnetstat -s|grep "packet receive errors"\r\n\r\n解决方案：\r\n\r\n调整socket缓冲区大小：\r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\nsocket配置（所有协议socket）：# Default Socket Receive Buffernet.core.rmem_default = 31457280# Maximum Socket Receive Buffernet.core.rmem_max = 67108864\r\n\r\n具体大小调整原理：\r\n\r\n缓冲区大小没有任何设置值是最佳的，因为最佳大小随具体情况而不同\r\n\r\n缓冲区估算原理：在数据通信中，带宽时延乘积（英语：bandwidth-delay product；或称带宽延时乘积、带宽延时积等）指的是一个数据链路的能力（每秒比特）与来回通信延迟（单位秒）的乘积。[1][2]其结果是以比特（或字节）为单位的一个数据总量，等同在任何特定时间该网络线路上的最大数据量——已发送但尚未确认的数据。\r\n\r\n \r\n\r\n**BDP = 带宽 \\* RTT**\r\n\r\n \r\n\r\n可以通过计算当面节点带宽和统计平均时延来估算BDP，即缓冲区的大小，可以参考下面常见场景估计：\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE64.tmp.png) \r\n\r\n参考：https://docs.oracle.com/cd/E56344_01/html/E53803/gnkor.html\r\n\r\n \r\n\r\n**应用设置tcp连接数大小丢包**\r\n\r\n查看：\r\n\r\n请参考上面TCP连接队列分析；\r\n\r\n解决方案：\r\n\r\n设置合理的连接队列大小，当第三次握手时，当server接收到ACK 报之后， 会进入一个新的叫 accept 的队列，该队列的长度为 min(backlog, somaxconn)，默认情况下，somaxconn 的值为 128，表示最多有 129 的 ESTAB 的连接等待 accept()，而 backlog 的值则应该是由 int listen(int sockfd, int backlog) 中的第二个参数指定，listen 里面的 backlog 可以有我们的应用程序去定义的；\r\n\r\n \r\n\r\n**应用发送太快导致丢包**\r\n\r\n查看统计：\r\n\r\n· \r\n\r\n netstat -s|grep "send buffer errors\r\n\r\n解决方案：\r\n\r\n· \r\n\r\nICMP/UDP没有流控机制，需要应用设计合理发送方式和速度，照顾到底层buff大小和CPU负载以及网络带宽质量；\r\n\r\n· \r\n\r\n· \r\n\r\n 设置合理的sock缓冲区大小：\r\n\r\n· \r\n\r\n· \r\n\r\n  setsockopt(s,SOL_SOCKET,SO_SNDBUF,  i(const char*)&nSendBuf,sizeof(int));\r\n\r\n· \r\n\r\n调整系统socket缓冲区大小：\r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n  \\# Default Socket Send Buffer  net.core.wmem_default = 31457280  # Maximum Socket Send Buffer  net.core.wmem_max = 33554432\r\n\r\n \r\n\r\n\r\n\r\n------\r\n\r\n\r\n\r\n \r\n\r\n**附：简单总结一下内核协议栈丢包：**\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE65.tmp.png) \r\n\r\n \r\n\r\n \r\n\r\n\r\n相关工具介绍\r\n\r\n1.dropwatch工具\r\n\r\n原理： 监听 kfree_skb（把网络报文丢弃时会调用该函数）函数或者事件吗，然后打印对应调用堆栈；想要详细了解 linux 系统在执行哪个函数时丢包的话，可以使用 dropwatch 工具，它监听系统丢包信息，并打印出丢包发生的函数：\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE66.tmp.png) \r\n\r\n \r\n\r\n\\2. tcpdump工具\r\n\r\n原理: tcpdump 是一个Unix下一个功能强大的网络抓包工具，它允许用户拦截和显示发送或收到过网络连接到该计算机的TCP/IP和其他数据包\r\n\r\n![img](8.云网络丢包故障定位全景指南.assets/wpsEE67.tmp.png) \r\n\r\n抓包命令参考：\r\n\r\nhttps://www.tcpdump.org/manpages/tcpdump.1.html\r\n\r\n数据包分析：\r\n\r\n1.用wireshark工具分析 参考：Wireshark数据包分析实战.pdf\r\n\r\n2.可以转化生成CSV数据，用Excel或者shell去分析特定场景报文；\r\n\r\n3.可以在linux上用tshark命令行工具进行分析:\r\n\r\nhttps://www.wireshark.org/docs/man-pages/tshark.html\r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n总结\r\n\r\n本文只是分析大部分可能会丢包节点，提供了单个节点丢包排查和相关的解决方案, 丢包问题牵扯网络链路各个组件，尤其是在云网络时代，网络拓扑复杂多变，涉及运营商网络，IDC网络，专线等underlay网络，边界网关，VPC网络，CLB负载均衡等云上overlay网络，各种丢包问题排障起来非常复杂且困难，但掌握网络通信基本原理后，可以分解网络拓扑，对通信节点进行逐一排查，也可以找到丢包位置，后续会更加深入介绍云计算时代，云上网络丢包排查方法，网络架构解析等，达到任何丢包问题都可以快速排查和定位解决，帮助客户快速恢复业务，下期再会。\r\n\r\n '},"84f7":function(n,r,e){"use strict";e.r(r),r["default"]="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzkyMTIzMTkzNA==&action=getalbum&album_id=1843110025334996995&scene=173&from_msgid=2247551600&from_itemidx=1&count=3&nolastread=1#wechat_redirect\r\n\r\n\r\n\r\nhttps://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzkyMTIzMTkzNA==&action=getalbum&album_id=1843110025334996995&scene=173&from_msgid=2247516378&from_itemidx=1&count=3&nolastread=1#wechat_redirect\r\n\r\n\r\n\r\nhttps://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzkyMTIzMTkzNA==&action=getalbum&album_id=1909790817628569601&scene=173&from_msgid=2247516378&from_itemidx=1&count=3&nolastread=1#wechat_redirect\r\n\r\n\r\n\r\nhttps://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzkyMTIzMTkzNA==&action=getalbum&album_id=1933086393505792001&scene=173&from_msgid=2247516378&from_itemidx=1&count=3&nolastread=1#wechat_redirect\r\n\r\n\r\n\r\nOriginal Alex码农的艺术 [极客重生](https://mp.weixin.qq.com/javascript:void(0);) 6/24\r\n\r\n收录于话题\r\n\r\n\\#深入理解Linux系统22个内容\r\n\r\n\\#原创文章34个内容\r\n\r\n\\#核心突破系列13个内容\r\n\r\n"},"86a8":function(n,r,e){"use strict";e.r(r),r["default"]="# ***\\*深入理解零拷贝技术\\****\r\n\r\n hi，大家好，内存拷贝是比较耗时操作，零拷贝是常用优化手段，今天分享的文章就是Linux系统零拷贝技术，**Kafka**和**MySQL开源组件**都用到这个核心技术，希望大家可以掌握。\r\n\r\n \r\n\r\n# ***\\*DMA 与零拷贝技术\\****\r\n\r\n**注意事项**：除了 Direct I/O，与磁盘相关的文件读写操作都有使用到 page cache 技术。\r\n\r\n作者：Spongecaptain\r\n\r\n原文：https://spongecaptain.cool/SimpleClearFileIO/\r\n\r\n## ***\\*1. 数据的四次拷贝与四次上下文切换\\****\r\n\r\n很多应用程序在面临客户端请求时，可以等价为进行如下的系统调用：\r\n\r\n\\1. \r\n\r\nFile.read(file, buf, len);\r\n\r\n\\2. \r\n\r\n\\3. \r\n\r\nSocket.send(socket, buf, len);\r\n\r\n\\4. \r\n\r\n \r\n\r\n例如消息中间件 Kafka 就是这个应用场景，从磁盘中读取一批消息后原封不动地写入网卡（NIC，Network interface controller）进行发送。\r\n\r\n在没有任何优化技术使用的背景下，操作系统为此会进行 4 次数据拷贝，以及 4 次上下文切换，如下图所示：\r\n\r\n![img](15.深入理解零拷贝技术.assets/wpsE314.tmp.png) \r\n\r\n \r\n\r\n如果没有优化，读取磁盘数据，再通过网卡传输的场景性能比较差：\r\n\r\n4 次 copy：\r\n\r\n\\1. \r\n\r\nCPU 负责将数据从磁盘搬运到内核空间的 Page Cache 中；\r\n\r\n\\2. \r\n\r\n\\3. \r\n\r\nCPU 负责将数据从内核空间的 Socket 缓冲区搬运到的网络中；\r\n\r\n\\4. \r\n\r\n\\5. \r\n\r\nCPU 负责将数据从内核空间的 Page Cache 搬运到用户空间的缓冲区；\r\n\r\n\\6. \r\n\r\n\\7. \r\n\r\nCPU 负责将数据从用户空间的缓冲区搬运到内核空间的 Socket 缓冲区中；\r\n\r\n\\8. \r\n\r\n4 次上下文切换：\r\n\r\n\\1. \r\n\r\nread 系统调用时：用户态切换到内核态；\r\n\r\n\\2. \r\n\r\n\\3. \r\n\r\nread 系统调用完毕：内核态切换回用户态；\r\n\r\n\\4. \r\n\r\n\\5. \r\n\r\nwrite 系统调用时：用户态切换到内核态；\r\n\r\n\\6. \r\n\r\n\\7. \r\n\r\nwrite 系统调用完毕：内核态切换回用户态；\r\n\r\n\\8. \r\n\r\n我们不免发出抱怨：\r\n\r\n\\1. \r\n\r\nCPU 全程负责内存内的数据拷贝还可以接受，因为效率还算可以接受，但是如果要全程负责内存与磁盘、网络的数据拷贝，这将难以接受，因为磁盘、网卡的速度远小于内存，内存又远远小于 CPU；\r\n\r\n\\2. \r\n\r\n\\3. \r\n\r\n4 次 copy 太多了，4 次上下文切换也太频繁了；\r\n\r\n\\4. \r\n\r\n## ***\\*2. DMA 参与下的数据四次拷贝\\****\r\n\r\nDMA 技术很容易理解，本质上，DMA 技术就是我们在主板上放一块独立的芯片。在进行内存和 I/O 设备的数据传输的时候，我们不再通过 CPU 来控制数据传输，而直接通过 DMA 控制器（DMA Controller，简称 DMAC）。这块芯片，我们可以认为它其实就是一个协处理器（Co-Processor）。\r\n\r\nDMAC 最有价值的地方体现在，当我们要传输的数据特别大、速度特别快，或者传输的数据特别小、速度特别慢的时候。\r\n\r\n比如说，我们用千兆网卡或者硬盘传输大量数据的时候，如果都用 CPU 来搬运的话，肯定忙不过来，所以可以选择 DMAC。而当数据传输很慢的时候，DMAC 可以等数据到齐了，再发送信号，给到 CPU 去处理，而不是让 CPU 在那里忙等待。\r\n\r\n注意，这里面的“协”字。DMAC 是在“协助”CPU，完成对应的数据传输工作。在 DMAC 控制数据传输的过程中，我们还是需要 CPU 的进行控制，但是具体数据的拷贝不再由 CPU 来完成。\r\n\r\n原本，计算机所有组件之间的数据拷贝（流动）必须经过 CPU，如下图所示：\r\n\r\n![img](15.深入理解零拷贝技术.assets/wpsE325.tmp.png) \r\n\r\n现在，DMA 代替了 CPU 负责内存与磁盘以及内存与网卡之间的数据搬运，CPU 作为 DMA 的控制者，如下图所示：\r\n\r\n![img](15.深入理解零拷贝技术.assets/wpsE326.tmp.png) \r\n\r\n \r\n\r\n但是 DMA 有其局限性，DMA 仅仅能用于设备之间交换数据时进行数据拷贝，但是设备内部的数据拷贝还需要 CPU 进行，例如 CPU 需要负责内核空间数据与用户空间数据之间的拷贝（内存内部的拷贝），如下图所示：\r\n\r\n![img](15.深入理解零拷贝技术.assets/wpsE327.tmp.png) \r\n\r\n \r\n\r\n上图中的 read buffer 也就是 page cache，socket buffer 也就是 Socket 缓冲区。\r\n\r\n## ***\\*3. 零拷贝技术\\****\r\n\r\n### ***\\*3.1 什么是零拷贝技术？\\****\r\n\r\n零拷贝技术是一个思想[3]，指的是指计算机执行操作时，CPU 不需要先将数据从某处内存复制到另一个特定区域。\r\n\r\n可见，零拷贝的特点是 CPU 不全程负责内存中的数据写入其他组件，CPU 仅仅起到管理的作用。但注意，零拷贝不是不进行拷贝，而是 CPU 不再全程负责数据拷贝时的搬运工作。如果数据本身不在内存中，那么必须先通过某种方式拷贝到内存中（这个过程 CPU 可以不参与），因为数据只有在内存中，才能被转移，才能被 CPU 直接读取计算。\r\n\r\n零拷贝技术的具体实现方式有很多，例如：\r\n\r\n**·** \r\n\r\n**sendfile**\r\n\r\n**·** \r\n\r\n**·** \r\n\r\n**mmap**\r\n\r\n**·** \r\n\r\n**·** \r\n\r\n**splice**\r\n\r\n**·** \r\n\r\n**·** \r\n\r\n**直接 Direct I/O**\r\n\r\n**·** \r\n\r\n \r\n\r\n不同的零拷贝技术适用于不同的应用场景，下面依次进行 sendfile、mmap、Direct I/O 的分析。\r\n\r\n不过出于总结性的目的，我们在这里先对下面的技术做一个前瞻性的总结。\r\n\r\n· \r\n\r\nDMA 技术回顾：DMA 负责内存与其他组件之间的数据拷贝，CPU 仅需负责管理，而无需负责全程的数据拷贝；\r\n\r\n· \r\n\r\n· \r\n\r\n使用 page cache 的 zero copy：\r\n\r\n· \r\n\r\n§ \r\n\r\nsendfile：一次代替 read/write 系统调用，通过使用 DMA 技术以及传递文件描述符，实现了 zero copy\r\n\r\n§ \r\n\r\n§ \r\n\r\nmmap：仅代替 read 系统调用，将内核空间地址映射为用户空间地址，write 操作直接作用于内核空间。通过 DMA 技术以及地址映射技术，用户空间与内核空间无须数据拷贝，实现了 zero copy\r\n\r\n§ \r\n\r\n· \r\n\r\n不使用 page cache 的 Direct I/O：读写操作直接在磁盘上进行，不使用 page cache 机制，通常结合用户空间的用户缓存使用。通过 DMA 技术直接与磁盘/网卡进行数据交互，实现了 zero copy\r\n\r\n· \r\n\r\n### ***\\*3.2 sendfile\\****\r\n\r\nsnedfile 的应用场景是：用户从磁盘读取一些文件数据后不需要经过任何计算与处理就通过网络传输出去。此场景的典型应用是消息队列。\r\n\r\n在传统 I/O 下，正如第一节所示，上述应用场景的一次数据传输需要四次 CPU 全权负责的拷贝与四次上下文切换，正如本文第一节所述。\r\n\r\nsendfile 主要使用到了两个技术：\r\n\r\n\\1. \r\n\r\nDMA 技术；\r\n\r\n\\2. \r\n\r\n\\3. \r\n\r\n传递文件描述符代替数据拷贝；\r\n\r\n\\4. \r\n\r\n下面依次讲解这两个技术的作用。\r\n\r\n**1.利用 DMA 技术**\r\n\r\nsendfile 依赖于 DMA 技术，将四次 CPU 全程负责的拷贝与四次上下文切换减少到两次，如下图所示：\r\n\r\n![img](15.深入理解零拷贝技术.assets/wpsE328.tmp.png)利用 DMA 技术减少 2 次 CPU 全程参与的拷贝\r\n\r\n \r\n\r\nDMA 负责磁盘到内核空间中的 Page cache（read buffer）的数据拷贝以及从内核空间中的 socket buffer 到网卡的数据拷贝。\r\n\r\n**2.传递文件描述符代替数据拷贝**\r\n\r\n传递文件描述可以代替数据拷贝，这是由于两个原因：\r\n\r\n· \r\n\r\npage cache 以及 socket buffer 都在内核空间中；\r\n\r\n· \r\n\r\n· \r\n\r\n数据传输过程前后没有任何写操作；\r\n\r\n· \r\n\r\n![img](15.深入理解零拷贝技术.assets/wpsE329.tmp.png)利用传递文件描述符代替内核中的数据拷贝\r\n\r\n \r\n\r\n**注意事项**：只有网卡支持 SG-DMA（The Scatter-Gather Direct Memory Access）技术才可以通过传递文件描述符的方式避免内核空间内的一次 CPU 拷贝。这意味着此优化取决于 Linux 系统的物理网卡是否支持（Linux 在内核 2.4 版本里引入了 DMA 的 scatter/gather – 分散/收集功能，只要确保 Linux 版本高于 2.4 即可）。\r\n\r\n**3.一次系统调用代替两次系统调用**\r\n\r\n由于 sendfile 仅仅对应一次系统调用，而传统文件操作则需要使用 read 以及 write 两个系统调用。\r\n\r\n正因为如此，sendfile 能够将用户态与内核态之间的上下文切换从 4 次讲到 2 次。\r\n\r\n![img](15.深入理解零拷贝技术.assets/wpsE32A.tmp.png)sendfile 系统调用仅仅需要两次上下文切换\r\n\r\n \r\n\r\n另一方面，我们需要注意 sendfile 系统调用的局限性。如果应用程序需要对从磁盘读取的数据进行写操作，例如解密或加密，那么 sendfile 系统调用就完全没法用。这是因为用户线程根本就不能够通过 sendfile 系统调用得到传输的数据。\r\n\r\n### ***\\*3.3 mmap\\****\r\n\r\nmmap 技术在[4] 中单独展开，请移步阅读。\r\n\r\n### ***\\*3.4 Direct I/O\\****\r\n\r\nDirect I/O 即直接 I/O。其名字中的”直接”二字用于区分使用 page cache 机制的缓存 I/O。\r\n\r\n· \r\n\r\n缓存文件 I/O：用户空间要读写一个文件并**不直接**与磁盘交互，而是中间夹了一层缓存，即 page cache；\r\n\r\n· \r\n\r\n· \r\n\r\n直接文件 I/O：用户空间读取的文件**直接**与磁盘交互，没有中间 page cache 层；\r\n\r\n· \r\n\r\n“直接”在这里还有另一层语义：其他所有技术中，数据至少需要在内核空间存储一份，但是在 Direct I/O 技术中，数据直接存储在用户空间中，绕过了内核。\r\n\r\nDirect I/O 模式如下图所示：\r\n\r\n![img](15.深入理解零拷贝技术.assets/wpsE33A.tmp.jpg)Direct I/O 示意图\r\n\r\n \r\n\r\n此时用户空间直接通过 DMA 的方式与磁盘以及网卡进行数据拷贝。\r\n\r\n**Direct I/O 的读写非常有特点**：\r\n\r\n· \r\n\r\nWrite 操作：由于其不使用 page cache，所以其进行写文件，如果返回成功，数据就真的落盘了（不考虑磁盘自带的缓存）；\r\n\r\n· \r\n\r\n· \r\n\r\nRead 操作：由于其不使用 page cache，每次读操作是真的从磁盘中读取，不会从文件系统的缓存中读取。\r\n\r\n· \r\n\r\n**事实上，即使 Direct I/O 还是可能需要使用操作系统的 fsync 系统调用。为什么？**\r\n\r\n这是因为虽然文件的数据本身没有使用任何缓存，但是文件的元数据仍然需要缓存，包括 VFS 中的 inode cache 和 dentry cache 等。\r\n\r\n在部分操作系统中，在 Direct I/O 模式下进行 write 系统调用能够确保文件数据落盘，但是文件元数据不一定落盘。如果在此类操作系统上，那么还需要执行一次 fsync 系统调用确保文件元数据也落盘。否则，可能会导致文件异常、元数据确实等情况。MySQL 的 O_DIRECT 与 O_DIRECT_NO_FSYNC 配置是一个具体案例[9]。\r\n\r\nDirect I/O 的优缺点：\r\n\r\n**（1）优点**\r\n\r\n\\1. \r\n\r\nLinux 中的直接 I/O 技术省略掉缓存 I/O 技术中操作系统内核缓冲区的使用，数据直接在应用程序地址空间和磁盘之间进行传输，从而使得自缓存应用程序可以省略掉复杂的系统级别的缓存结构，而执行程序自己定义的数据读写管理，从而**降低系统级别的管理对应用程序访问数据的影响**。\r\n\r\n\\2. \r\n\r\n\\3. \r\n\r\n与其他零拷贝技术一样，避免了内核空间到用户空间的数据拷贝，如果要传输的数据量很大，使用直接 I/O 的方式进行数据传输，而不需要操作系统内核地址空间拷贝数据操作的参与，这将会大大提高性能。\r\n\r\n\\4. \r\n\r\n**（2）缺点**\r\n\r\n\\1. \r\n\r\n由于设备之间的数据传输是通过 DMA 完成的，因此**用户空间的数据缓冲区内存页必须进行 page pinning（页锁定）**，这是为了防止其物理页框地址被交换到磁盘或者被移动到新的地址而导致 DMA 去拷贝数据的时候在指定的地址找不到内存页从而引发缺页错误，而页锁定的开销并不比 CPU 拷贝小，所以为了避免频繁的页锁定系统调用，应用程序必须分配和注册一个持久的内存池，用于数据缓冲。\r\n\r\n\\2. \r\n\r\n\\3. \r\n\r\n如果访问的数据不在应用程序缓存中，那么每次数据都会直接从磁盘进行加载，这种直接加载会非常缓慢。\r\n\r\n\\4. \r\n\r\n\\5. \r\n\r\n在应用层引入直接 I/O 需要应用层自己管理，这带来了额外的系统复杂性；\r\n\r\n\\6. \r\n\r\n \r\n\r\n**谁会使用 Direct I/O？**\r\n\r\nIBM[5]的一篇文章指出，自缓存应用程序（ self-caching applications）可以选择使用 Direct I/O。\r\n\r\n自缓存应用程序\r\n\r\n对于某些应用程序来说，它会有它自己的数据缓存机制，比如，它会将数据缓存在应用程序地址空间，这类应用程序完全不需要使用操作系统内核中的高速缓冲存储器，这类应用程序就被称作是自缓存应用程序（ self-caching applications ）。\r\n\r\n例如，应用内部维护一个缓存空间，当有读操作时，首先读取应用层的缓存数据，如果没有，那么就通过 Direct I/O 直接通过磁盘 I/O 来读取数据。缓存仍然在应用，只不过应用觉得自己实现一个缓存比操作系统的缓存更高效。\r\n\r\n**数据库管理系统是这类应用程序的一个代表**。自缓存应用程序倾向于使用数据的逻辑表达方式，而非物理表达方式；当系统内存较低的时候，自缓存应用程序会让这种数据的逻辑缓存被换出，而并非是磁盘上实际的数据被换出。自缓存应用程序对要操作的数据的语义了如指掌，所以它可以采用更加高效的缓存替换算法。自缓存应用程序有可能会在多台主机之间共享一块内存，那么自缓存应用程序就需要提供一种能够有效地将用户地址空间的缓存数据置为无效的机制，从而确保应用程序地址空间缓存数据的一致性。\r\n\r\n另一方面，目前 Linux 上的异步 IO 库，其依赖于文件使用 O_DIRECT 模式打开，它们通常一起配合使用。\r\n\r\n**如何使用 Direct I/O？**\r\n\r\n用户应用需要实现用户空间内的缓存区，读/写操作应当尽量通过此缓存区提供。如果有性能上的考虑，那么尽量避免频繁地基于 Direct I/O 进行读/写操作。\r\n\r\n## ***\\*4. 典型案例\\****\r\n\r\n### ***\\*4.1 Kakfa\\****\r\n\r\nKafka 作为一个消息队列，涉及到磁盘 I/O 主要有两个操作：\r\n\r\n· \r\n\r\nProvider 向 Kakfa 发送消息，Kakfa 负责将消息以日志的方式持久化落盘；\r\n\r\n· \r\n\r\n· \r\n\r\nConsumer 向 Kakfa 进行拉取消息，Kafka 负责从磁盘中读取一批日志消息，然后再通过网卡发送；\r\n\r\n· \r\n\r\nKakfa 服务端接收 Provider 的消息并持久化的场景下使用 mmap 机制[6]，能够基于顺序磁盘 I/O 提供高效的持久化能力，使用的 Java 类为 java.nio.MappedByteBuffer。\r\n\r\nKakfa 服务端向 Consumer 发送消息的场景下使用 sendfile 机制[7]，这种机制主要两个好处：\r\n\r\n· \r\n\r\nsendfile 避免了内核空间到用户空间的 CPU 全程负责的数据移动；\r\n\r\n· \r\n\r\n· \r\n\r\nsendfile 基于 Page Cache 实现，因此如果有多个 Consumer 在同时消费一个主题的消息，那么由于消息一直在 page cache 中进行了缓存，因此只需一次磁盘 I/O，就可以服务于多个 Consumer；\r\n\r\n· \r\n\r\n使用 mmap 来对接收到的数据进行持久化，使用 sendfile 从持久化介质中读取数据然后对外发送是一对常用的组合。但是注意，你无法利用 sendfile 来持久化数据，利用 mmap 来实现 CPU 全程不参与数据搬运的数据拷贝。\r\n\r\n### ***\\*4.2 MySQL\\****\r\n\r\nMySQL 的具体实现比 Kakfa 复杂很多，这是因为支持 SQL 查询的数据库本身比消息队列对复杂很多。\r\n\r\nMySQL 的零拷贝技术使用方式请移步我的另一篇文章[8]。\r\n\r\n## ***\\*5. 总结\\****\r\n\r\nDMA 技术的推出使得内存与其他组件，例如磁盘、网卡进行数据拷贝时，CPU 仅仅需要发出控制信号，而拷贝数据的过程则由 DMA 负责完成。\r\n\r\nLinux 的零拷贝技术有多种实现策略，但根据策略可以分为如下几种类型：\r\n\r\n· \r\n\r\n**减少甚至避免用户空间和内核空间之间的数据拷贝**：在一些场景下，用户进程在数据传输过程中并不需要对数据进行访问和处理，那么数据在 Linux 的 Page Cache 和用户进程的缓冲区之间的传输就完全可以避免，让数据拷贝完全在内核里进行，甚至可以通过更巧妙的方式避免在内核里的数据拷贝。这一类实现一般是是通过增加新的系统调用来完成的，比如 Linux 中的 mmap()，sendfile() 以及 splice() 等。\r\n\r\n· \r\n\r\n· \r\n\r\n**绕过内核的直接 I/O**：允许在用户态进程绕过内核直接和硬件进行数据传输，内核在传输过程中只负责一些管理和辅助的工作。这种方式其实和第一种有点类似，也是试图避免用户空间和内核空间之间的数据传输，只是第一种方式是把数据传输过程放在内核态完成，而这种方式则是直接绕过内核和硬件通信，效果类似但原理完全不同。\r\n\r\n· \r\n\r\n· \r\n\r\n**内核缓冲区和用户缓冲区之间的传输优化**：这种方式侧重于在用户进程的缓冲区和操作系统的页缓存之间的 CPU 拷贝的优化。这种方法延续了以往那种传统的通信方式，但更灵活。\r\n\r\n· \r\n\r\n# ***\\*REFERENCE\\****\r\n\r\n· \r\n\r\n[1]CPU：一个故事看懂DMA\r\n\r\n· \r\n\r\n· \r\n\r\n[2]Linux I/O 原理和 Zero-copy 技术全面揭秘\r\n\r\n· \r\n\r\n· \r\n\r\n[3]零复制 - 维基百科，自由的百科全书\r\n\r\n· \r\n\r\n· \r\n\r\n[4]mmap\r\n\r\n· \r\n\r\n· \r\n\r\n[5]直接 I/O 的动机\r\n\r\n· \r\n\r\n· \r\n\r\n[6]kafka.log.AbstractIndex\r\n\r\n· \r\n\r\n· \r\n\r\n[7]Apache Kafka DOCUMENTATION\r\n\r\n· \r\n\r\n· \r\n\r\n[8]MySQL 的零拷贝技术\r\n\r\n· \r\n\r\n· \r\n\r\n[9]InnoDB Startup Options and System Variables\r\n\r\n· \r\n\r\n "},"9f1b":function(n,r,e){var t={"./0.记录.md":"84f7","./10.Linux调度系统全景指南(中篇).md":"f10a","./11.Linux调度系统全景指南(下篇) .md":"ce01","./12.Linux问题分析与性能优化.md":"f1b8","./14.深入理解Linux 的Page Cache.md":"59ca","./15.深入理解零拷贝技术.md":"86a8","./19.深入理解程序的本质.md":"4f2c","./20.图解Linux内存性能优化核心思想.md":"a642","./21.深入理解 Linux的IO系统.md":"b829","./22.深入理解Kafka的设计思想.md":"0b8f","./23.Redis 多线程网络模型全面揭秘网络硬核系列.md":"b022","./24.计算机网络硬核指南网络设计核心思想.md":"4b48","./4.Linux Kernel TCPIP StackLinux网络硬核系列.md":"550a","./6.深入理解RCU核心原理.md":"cb0c","./7.Linux网络子系统.md":"6a3c","./8.云网络丢包故障定位全景指南.md":"80f6","./9.Linux调度系统全景指南(上篇).md":"429e"};function i(n){var r=s(n);return e(r)}function s(n){if(!e.o(t,n)){var r=new Error("Cannot find module '"+n+"'");throw r.code="MODULE_NOT_FOUND",r}return t[n]}i.keys=function(){return Object.keys(t)},i.resolve=s,n.exports=i,i.id="9f1b"},a642:function(n,r,e){"use strict";e.r(r),r["default"]='# ***\\*经典|图解Linux内存性能优化核心思想\\****\r\n\r\ndog250 [极客重生](https://mp.weixin.qq.com/javascript:void(0);) 5 days ago\r\n\r\n hi，大家好，今天分享一篇**内存性能优化**的文章，文章用了大量精美的图深入浅出地分析了Linux内核slab性能优化的**核心思想**，**slab**是Linux内核小对象内存分配最重要的算法，文章分析了内存分配的各种性能问题（在不同的场景下面），并给出了这些问题的优化方案，这个对我们实现**高性能内存池算法**，或以后遇到内存性能问题的时候，有一定的启发，值得我们学习。\r\n\r\n \r\n\r\n**Linux内核的slab**来自一种很简单的思想，即事先准备好一些会频繁分配，释放的数据结构。然而标准的slab实现太复杂且维护开销巨大，因此便分化出了更加小巧的slub，因此本文讨论的就是slub，后面所有提到slab的地方，指的都是slub。另外又由于本文主要描述内核优化方面的内容，因此想了解slab细节以及代码实现的请查看源码。\r\n\r\n### 单CPU上单纯的slab\r\n\r\n下图给出了单CPU上slab在分配和释放对象时的情景序列：\r\n\r\n \r\n\r\n![img](20.图解Linux内存性能优化核心思想.assets/wpsF0A6.tmp.png) \r\n\r\n \r\n\r\n可以看出，非常之简单，而且完全达到了slab设计之初的目标。\r\n\r\n### 扩展到多核心CPU**‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍**\r\n\r\n现在我们简单的将上面的模型扩展到多核心CPU，同样差不多的分配序列如下图所示：\r\n\r\n![img](20.图解Linux内存性能优化核心思想.assets/wpsF0A7.tmp.png) \r\n\r\n我们看到，在只有单一slab的时候，如果多个CPU同时分配对象，冲突是不可避免的，解决冲突的几乎是唯一的办法就是加锁排队，然而这将大大增加延迟，我们看到，申请单一对象的整个时延从T0开始，到T4结束，这太久了。\r\n\r\n \r\n\r\n多CPU无锁化并行化操作的直接思路-复制给每个CPU一套相同的数据结构。不二法门就是增加“每CPU变量”。对于slab而言，可以扩展成下面的样子：\r\n\r\n \r\n\r\n![img](20.图解Linux内存性能优化核心思想.assets/wpsF0A8.tmp.png) \r\n\r\n如果以为这么简单就结束了，那这就太没有意义了。\r\n\r\n### 问题\r\n\r\n### ***\\*首先，我们来看一个简单的问题，如果单独的某个CPU的slab缓存没有对象可分配了，但是其它CPU的slab缓存仍有大量空闲对象的情况，如下图所示：\\****\r\n\r\n \r\n\r\n![img](20.图解Linux内存性能优化核心思想.assets/wpsF0A9.tmp.png) \r\n\r\n \r\n\r\n这是可能的，因为对单独一种slab的需求是和该CPU上执行的进程/线程紧密相关的，比如如果CPU0只处理网络，那么它就会对skb等数据结构有大量的需求，对于上图最后引出的问题，如果我们选择从伙伴系统中分配一个新的page(或者pages，取决于对象大小以及slab cache的order)，那么久而久之就会造成slab在CPU间分布的不均衡，更可能会因此吃掉大量的物理内存，这都是不希望看到的。\r\n\r\n \r\n\r\n在继续之前，首先要明确的是，我们需要在CPU间均衡slab，并且这些必须靠slab内部的机制自行完成，这个和进程在CPU间负载均衡是完全不同的，对进程而言，拥有一个核心调度机制，比如基于时间片，或者虚拟时钟的步进速率等，但是对于slab，完全取决于使用者自身，只要对象仍然在使用，就不能剥夺使用者继续使用的权利，除非使用者自己释放。因此slab的负载均衡必须设计成合作型的，而不是抢占式的。\r\n\r\n \r\n\r\n好了。现在我们知道，从伙伴系统重新分配一个page(s)并不是一个好主意，它应该是最终的决定，在执行它之前，首先要试一下别的路线。\r\n\r\n \r\n\r\n现在，我们引出第二个问题，如下图所示：\r\n\r\n![img](20.图解Linux内存性能优化核心思想.assets/wpsF0BA.tmp.png) \r\n\r\n \r\n\r\n谁也不能保证分配slab对象的CPU和释放slab对象的CPU是同一个CPU，谁也不能保证一个CPU在一个slab对象的生命周期内没有分配新的page(s)，这期间的复杂操作谁也没有规定。这些问题该怎么解决呢？事实上，理解了这些问题是怎么解决的，一个slab框架就彻底理解了。\r\n\r\n### 问题的解决-分层slab cache\r\n\r\n无级变速总是让人向往。如果一个CPU的slab缓存满了，直接去抢同级别的别的CPU的slab缓存被认为是一种鲁莽且不道义的做法。那么为何不设置另外一个slab缓存，获取它里面的对象不像直接获取CPU的slab缓存那么简单且直接，但是难度却又不大，只是稍微增加一点消耗，这不是很好吗？事实上，**CPU的L1，L2，L3 cache**不就是这个方案设计的吗？这事实上已经成为cache设计的不二法门。这个**设计思想**同样作用于slab，就是Linux内核的slub实现，现在可以给出概念和解释了。\r\n\r\n\\1. **Linux kernel slab cache**：一个分为3层的对象cache模型。\r\n\r\n\\2. **Level 1 slab cache**：一个空闲对象链表，每个CPU一个的独享cache，分配释放对象无需加锁。\r\n\r\n\\3. **Level 2 slab cache**：一个空闲对象链表，每个CPU一个的共享page(s) cache，分配释放对象时仅需要锁住该page(s)，与Level 1 slab cache互斥，不互相包容。\r\n\r\n\\4. **Level 3 slab cache**：一个page(s)链表，每个NUMA NODE的所有CPU共享的cache，单位为page(s)，获取后被提升到对应CPU的Level 1 slab cache，同时该page(s)作为Level 2的共享page(s)存在。\r\n\r\n\\5. **共享page(s)**：该page(s)被一个或者多个CPU占有，每一个CPU在该page(s)上都可以拥有互相不充图的空闲对象链表，该page(s)拥有一个唯一的Level 2 slab cache空闲链表，该链表与上述一个或多个Level 1 slab cache空闲链表亦不冲突，多个CPU获取该Level 2 slab cache时必须争抢，获取后可以将该链表提升成自己的Level 1 slab cache。\r\n\r\n \r\n\r\n该**slab cache**的图示如下：\r\n\r\n \r\n\r\n![img](20.图解Linux内存性能优化核心思想.assets/wpsF0BB.tmp.png) \r\n\r\n其行为如下图所示：\r\n\r\n![img](20.图解Linux内存性能优化核心思想.assets/wpsF0BC.tmp.png) \r\n\r\n### 2个场景**‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍**\r\n\r\n对于常规的对象分配过程，下图展示了其细节：\r\n\r\n![img](20.图解Linux内存性能优化核心思想.assets/wpsF0BD.tmp.png) \r\n\r\n事实上，对于多个CPU共享一个page(s)的情况，还可以有另一种玩法，如下图所示：\r\n\r\n![img](20.图解Linux内存性能优化核心思想.assets/wpsF0CD.tmp.png) \r\n\r\n### 伙伴系统\r\n\r\n前面我们简短的体会了Linux内核的slab设计,不宜过长,太长了不易理解.但是最后,如果Level 3也没有获取page(s)，那么最终会落到终极的伙伴系统，伙伴系统是为了防内存分配碎片化的，所以它尽可能地做两件事：\r\n\r\n\\1. **尽量分配尽可能大的内存**\r\n\r\n\\2. **尽量合并连续的小块内存成一块大内存**\r\n\r\n我们可以通过下面的图解来理解上面的原则：\r\n\r\n![img](20.图解Linux内存性能优化核心思想.assets/wpsF0CE.tmp.png) \r\n\r\n注意，本文是关于优化的，不是伙伴系统的科普，所以我假设大家已经理解了伙伴系统。\r\n\r\n \r\n\r\n鉴于slab缓存对象大多数都是不超过1个页面的小结构(不仅仅slab系统，超过1个页面的内存需求相比1个页面的内存需求，很少)，因此会有大量的针对1个页面的内存分配需求。从伙伴系统的分配原理可知，如果持续大量分配单一页面，会有大量的order大于0的页面分裂成单一页面，在单核心CPU上，这不是问题，但是在多核心CPU上，由于每一个CPU都会进行此类分配，而伙伴系统的分裂，合并操作会涉及大量的链表操作，这个锁开销是巨大的，因此需要优化！\r\n\r\n \r\n\r\nLinux内核对伙伴系统针对单一页面的分配需求采取的批量分配“每CPU单一页面缓存”的方式！每一个CPU拥有一个单一页面缓存池，需要单一页面的时候，可以无需加锁从当前CPU对应的页面池中获取页面。而当池中页面不足时，系统会批量从伙伴系统中拉取一堆页面到池中，反过来，在单一页面释放的时候，会择优将其释放到每CPU的单一页面缓存中。\r\n\r\n \r\n\r\n为了维持“每CPU单一页面缓存”中页面的数量不会太多或太少(太多会影响伙伴系统，太少会影响CPU的需求)，系统保持了两个值，当缓存页面数量低于low值的时候，便从伙伴系统中批量获取页面到池中，而当缓存页面数量大于high的时候，便会释放一些页面到伙伴系统中。\r\n\r\n### **小结****‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍**\r\n\r\n多CPU操作系统内核中，关键的开销就是锁的开销。我认为这是一开始的设计导致的，因为一开始，多核CPU并没有出现，单核CPU上的共享保护几乎都是可以用“禁中断”，“禁抢占”来简单实现的，到了多核时代，操作系统同样简单平移到了新的平台，因此同步操作是在单核的基础上后来添加的。简单来讲，目前的主流操作系统都是在单核年代创造出来的，因此它们都是顺应单核环境的，对于多核环境，可能它们一开始的设计就有问题。\r\n\r\n \r\n\r\n不管怎么说，优化操作的不二法门就是禁止或者尽量减少锁的操作。随之而来的思路就是为共享的关键数据结构创建"**每CPU的缓存**“，而这类缓存分为两种类型：\r\n\r\n**1. 数据通路缓存**\r\n\r\n比如路由表之类的数据结构，你可以用RCU锁来保护，当然如果为每一个CPU都创建一个本地路由表缓存，也是不错的，现在的问题是何时更新它们，因为所有的缓存都是平级的，因此一种批量同步的机制是必须的。\r\n\r\n**2. 管理机制缓存**\r\n\r\n比如slab对象缓存这类，其生命周期完全取决于使用者，因此不存在同步问题，然而却存在管理问题。采用分级cache的思想是好的，这个非常类似于CPU的L1/L2/L3缓存，采用这种平滑的开销逐渐增大，容量逐渐增大的机制，并配合以设计良好的换入/换出等算法，效果是非常明显的。\r\n\r\n '},b022:function(n,r,e){"use strict";e.r(r),r["default"]='# ***\\*Redis 多线程网络模型全面揭秘|网络硬核系列\\****\r\n\r\n \r\n\r\n \r\n\r\n## ***\\*导言\\****\r\n\r\n在目前的技术选型中，Redis 俨然已经成为了系统高性能缓存方案的事实标准，因此现在 Redis 也成为了后端开发的基本技能树之一，Redis 的底层原理也顺理成章地成为了必须学习的知识。\r\n\r\nRedis 从本质上来讲是一个网络服务器，而对于一个网络服务器来说，网络模型是它的精华，搞懂了一个网络服务器的网络模型，你也就搞懂了它的本质。\r\n\r\n本文通过层层递进的方式，介绍了 Redis 网络模型的版本变更历程，剖析了其从单线程进化到多线程的工作原理，此外，还一并分析并解答了 Redis 的网络模型的很多抉择背后的思考，帮助读者能更深刻地理解 Redis 网络模型的设计。\r\n\r\n## ***\\*Redis 有多快？\\****\r\n\r\n根据官方的 benchmark，通常来说，在一台普通硬件配置的 Linux 机器上跑单个 Redis 实例，处理简单命令（时间复杂度 O(N) 或者 O(log(N))），QPS 可以达到 8w+，而如果使用 pipeline 批处理功能，则 QPS 至高能达到 100w。\r\n\r\n仅从性能层面进行评判，Redis 完全可以被称之为高性能缓存方案。\r\n\r\n## ***\\*Redis 为什么快？\\****\r\n\r\nRedis 的高性能得益于以下几个基础：\r\n\r\n![img](23.Redis 多线程网络模型全面揭秘网络硬核系列.assets/wpsC4BA.tmp.png) \r\n\r\n· **C 语言实现**，虽然 C 对 Redis 的性能有助力，但语言并不是最核心因素。\r\n\r\n· **纯内存 I/O**，相较于其他基于磁盘的 DB，Redis 的纯内存操作有着天然的性能优势。\r\n\r\n· **I/O 多路复用**，基于 epoll/select/kqueue 等 I/O 多路复用技术，实现高吞吐的网络 I/O。\r\n\r\n· **单线程模型**，单线程无法利用多核，但是从另一个层面来说则避免了多线程频繁上下文切换，以及同步机制如锁带来的开销。\r\n\r\n## ***\\*Redis 为何选择单线程？\\****\r\n\r\nRedis 的核心网络模型选择用单线程来实现，这在一开始就引起了很多人的不解，Redis 官方的对于此的回答是：\r\n\r\n***\\*\\****\r\n\r\nIt\'s not very frequent that CPU becomes your bottleneck with Redis, as usually Redis is either memory or network bound. For instance, using pipelining Redis running on an average Linux system can deliver even 1 million requests per second, so if your application mainly uses O(N) or O(log(N)) commands, it is hardly going to use too much CPU.\r\n\r\n”\r\n\r\n核心意思就是，对于一个 DB 来说，CPU 通常不会是瓶颈，因为大多数请求不会是 CPU 密集型的，而是 I/O 密集型。具体到 Redis 的话，如果不考虑 RDB/AOF 等持久化方案，Redis 是完全的纯内存操作，执行速度是非常快的，因此这部分操作通常不会是性能瓶颈，Redis 真正的性能瓶颈在于网络 I/O，也就是客户端和服务端之间的网络传输延迟，因此 Redis 选择了单线程的 I/O 多路复用来实现它的核心网络模型。\r\n\r\n上面是比较笼统的官方答案，实际上更加具体的选择单线程的原因可以归纳如下：\r\n\r\n### ***\\*避免过多的上下文切换开销\\****\r\n\r\n多线程调度过程中必然需要在 CPU 之间切换线程上下文 context，而上下文的切换又涉及程序计数器、堆栈指针和程序状态字等一系列的寄存器置换、程序堆栈重置甚至是高速缓存、TLB 快表的汰换，如果是进程内的多线程切换还好一些，因为单一进程内多线程共享进程地址空间，因此线程上下文比之进程上下文要小得多，如果是跨进程调度，则需要切换掉整个进程地址空间。\r\n\r\n如果是单线程则可以规避进程内频繁的线程切换开销，因为程序始终运行在进程中单个线程内，没有多线程切换的场景。\r\n\r\n### ***\\*避免同步机制的开销\\****\r\n\r\n如果 Redis 选择多线程模型，又因为 Redis 是一个数据库，那么势必涉及到底层数据同步的问题，则必然会引入某些同步机制，比如锁，而我们知道 Redis 不仅仅提供了简单的 key-value 数据结构，还有 list、set 和 hash 等等其他丰富的数据结构，而不同的数据结构对同步访问的加锁粒度又不尽相同，可能会导致在操作数据过程中带来很多加锁解锁的开销，增加程序复杂度的同时还会降低性能。\r\n\r\n### ***\\*简单可维护\\****\r\n\r\nRedis 的作者 Salvatore Sanfilippo (别称 antirez) 对 Redis 的设计和代码有着近乎偏执的简洁性理念，你可以在阅读 Redis 的源码或者给 Redis 提交 PR 的之时感受到这份偏执。因此代码的简单可维护性必然是 Redis 早期的核心准则之一，而引入多线程必然会导致代码的复杂度上升和可维护性下降。\r\n\r\n事实上，多线程编程也不是那么尽善尽美，首先多线程的引入会使得程序不再保持代码逻辑上的串行性，代码执行的顺序将变成不可预测的，稍不注意就会导致程序出现各种并发编程的问题；其次，多线程模式也使得程序调试更加复杂和麻烦。网络上有一幅很有意思的图片，生动形象地描述了并发编程面临的窘境。\r\n\r\n你期望的多线程编程 **VS** 实际上的多线程编程：\r\n\r\n![img](23.Redis 多线程网络模型全面揭秘网络硬核系列.assets/wpsC4CB.tmp.png)你期望的多线程VS实际上的多线程\r\n\r\n前面我们提到引入多线程必须的同步机制，如果 Redis 使用多线程模式，那么所有的底层数据结构都必须实现成线程安全的，这无疑又使得 Redis 的实现变得更加复杂。\r\n\r\n总而言之，Redis 选择单线程可以说是多方博弈之后的一种权衡：在保证足够的性能表现之下，使用单线程保持代码的简单和可维护性。\r\n\r\n## ***\\*Redis 真的是单线程？\\****\r\n\r\n在讨论这个问题之前，我们要先明确『单线程』这个概念的边界：它的覆盖范围是核心网络模型，抑或是整个 Redis？如果是前者，那么答案是肯定的，在 Redis 的 v6.0 版本正式引入多线程之前，其网络模型一直是单线程模式的；如果是后者，那么答案则是否定的，Redis 早在 v4.0 就已经引入了多线程。\r\n\r\n因此，当我们讨论 Redis 的多线程之时，有必要对 Redis 的版本划出两个重要的节点：\r\n\r\n\\1. Redis v4.0（引入多线程处理异步任务）\r\n\r\n\\2. Redis v6.0（正式在网络模型中实现 I/O 多线程）\r\n\r\n### ***\\*单线程事件循环\\****\r\n\r\n我们首先来剖析一下 Redis 的核心网络模型，从 Redis 的 v1.0 到 v6.0 版本之前，Redis 的核心网络模型一直是一个典型的单 Reactor 模型：利用 epoll/select/kqueue 等多路复用技术，在单线程的事件循环中不断去处理事件（客户端请求），最后回写响应数据到客户端：\r\n\r\n![img](23.Redis 多线程网络模型全面揭秘网络硬核系列.assets/wpsC4CC.tmp.png) \r\n\r\n这里有几个核心的概念需要学习：\r\n\r\n· **client**：客户端对象，Redis 是典型的 CS 架构（Client <---\x3e Server），客户端通过 **socket** 与服务端建立网络通道然后发送请求命令，服务端执行请求的命令并回复。**Redis** 使用结构体 **client** 存储客户端的所有相关信息，包括但不限于封装的套接字连接 -- *conn，当前选择的数据库指针 -- *db，读入缓冲区 -- querybuf，写出缓冲区 -- buf，写出数据链表 -- reply等。\r\n\r\n· **aeApiPoll**：I/O 多路复用 API，是基于 epoll_wait/select/kevent 等系统调用的封装，监听等待读写事件触发，然后处理，它是事件循环（Event Loop）中的核心函数，是事件驱动得以运行的基础。\r\n\r\n· **acceptTcpHandler**：连接应答处理器，底层使用系统调用 accept 接受来自客户端的新连接，并为新连接注册绑定命令读取处理器，以备后续处理新的客户端 TCP 连接；除了这个处理器，还有对应的 acceptUnixHandler 负责处理 Unix Domain Socket 以及 acceptTLSHandler 负责处理 TLS 加密连接。\r\n\r\n· **readQueryFromClient**：命令读取处理器，解析并执行客户端的请求命令。\r\n\r\n· **beforeSleep**：事件循环中进入 aeApiPoll 等待事件到来之前会执行的函数，其中包含一些日常的任务，比如把 client->buf 或者 client->reply （后面会解释为什么这里需要两个缓冲区）中的响应写回到客户端，持久化 AOF 缓冲区的数据到磁盘等，相对应的还有一个 afterSleep 函数，在 aeApiPoll 之后执行。\r\n\r\n· **sendReplyToClient**：命令回复处理器，当一次事件循环之后写出缓冲区中还有数据残留，则这个处理器会被注册绑定到相应的连接上，等连接触发写就绪事件时，它会将写出缓冲区剩余的数据回写到客户端。\r\n\r\nRedis 内部实现了一个高性能的事件库 --- AE，基于 epoll/select/kqueue/evport 四种事件驱动技术，实现 Linux/MacOS/FreeBSD/Solaris 多平台的高性能事件循环模型。Redis 的核心网络模型正式构筑在 AE 之上，包括 I/O 多路复用、各类处理器的注册绑定，都是基于此才得以运行。\r\n\r\n至此，我们可以描绘出客户端向 Redis 发起请求命令的工作原理：\r\n\r\n\\1. Redis 服务器启动，开启主线程事件循环（Event Loop），注册 acceptTcpHandler 连接应答处理器到用户配置的监听端口对应的文件描述符，等待新连接到来；\r\n\r\n\\2. 客户端和服务端建立网络连接；\r\n\r\n\\3. acceptTcpHandler 被调用，主线程使用 AE 的 API 将 readQueryFromClient 命令读取处理器绑定到新连接对应的文件描述符上，并初始化一个 client 绑定这个客户端连接；\r\n\r\n\\4. 客户端发送请求命令，触发读就绪事件，主线程调用 readQueryFromClient 通过 socket 读取客户端发送过来的命令存入 client->querybuf 读入缓冲区；\r\n\r\n\\5. 接着调用 processInputBuffer，在其中使用 processInlineBuffer 或者 processMultibulkBuffer 根据 Redis 协议解析命令，最后调用 processCommand 执行命令；\r\n\r\n\\6. 根据请求命令的类型（SET, GET, DEL, EXEC 等），分配相应的命令执行器去执行，最后调用 addReply 函数族的一系列函数将响应数据写入到对应 client 的写出缓冲区：client->buf 或者 client->reply ，client->buf 是首选的写出缓冲区，固定大小 16KB，一般来说可以缓冲足够多的响应数据，但是如果客户端在时间窗口内需要响应的数据非常大，那么则会自动切换到 client->reply 链表上去，使用链表理论上能够保存无限大的数据（受限于机器的物理内存），最后把 client 添加进一个 LIFO 队列 clients_pending_write；\r\n\r\n\\7. 在事件循环（Event Loop）中，主线程执行 beforeSleep --\x3e handleClientsWithPendingWrites，遍历 clients_pending_write 队列，调用 writeToClient 把 client 的写出缓冲区里的数据回写到客户端，如果写出缓冲区还有数据遗留，则注册 sendReplyToClient 命令回复处理器到该连接的写就绪事件，等待客户端可写时在事件循环中再继续回写残余的响应数据。\r\n\r\n对于那些想利用多核优势提升性能的用户来说，Redis 官方给出的解决方案也非常简单粗暴：在同一个机器上多跑几个 Redis 实例。事实上，为了保证高可用，线上业务一般不太可能会是单机模式，更加常见的是利用 Redis 分布式集群多节点和数据分片负载均衡来提升性能和保证高可用。\r\n\r\n### ***\\*多线程异步任务\\****\r\n\r\n以上便是 Redis 的核心网络模型，这个单线程网络模型一直到 Redis v6.0 才改造成多线程模式，但这并不意味着整个 Redis 一直都只是单线程。\r\n\r\nRedis 在 v4.0 版本的时候就已经引入了的多线程来做一些异步操作，此举主要针对的是那些非常耗时的命令，通过将这些命令的执行进行异步化，避免阻塞单线程的事件循环。\r\n\r\n我们知道 Redis 的 DEL 命令是用来删除掉一个或多个 key 储存的值，它是一个阻塞的命令，大多数情况下你要删除的 key 里存的值不会特别多，最多也就几十上百个对象，所以可以很快执行完，但是如果你要删的是一个超大的键值对，里面有几百万个对象，那么这条命令可能会阻塞至少好几秒，又因为事件循环是单线程的，所以会阻塞后面的其他事件，导致吞吐量下降。\r\n\r\nRedis 的作者 antirez 为了解决这个问题进行了很多思考，一开始他想的办法是一种渐进式的方案：利用定时器和数据游标，每次只删除一小部分的数据，比如 1000 个对象，最终清除掉所有的数据，但是这种方案有个致命的缺陷，如果同时还有其他客户端往某个正在被渐进式删除的 key 里继续写入数据，而且删除的速度跟不上写入的数据，那么将会无止境地消耗内存，虽然后来通过一个巧妙的办法解决了，但是这种实现使 Redis 变得更加复杂，而多线程看起来似乎是一个水到渠成的解决方案：简单、易理解。于是，最终 antirez 选择引入多线程来实现这一类非阻塞的命令。更多 antirez 在这方面的思考可以阅读一下他发表的博客：Lazy Redis is better Redis。\r\n\r\n于是，在 Redis v4.0 之后增加了一些的非阻塞命令如 UNLINK、FLUSHALL ASYNC、FLUSHDB ASYNC。\r\n\r\n![img](23.Redis 多线程网络模型全面揭秘网络硬核系列.assets/wpsC4CD.tmp.png) \r\n\r\nUNLINK 命令其实就是 DEL 的异步版本，它不会同步删除数据，而只是把 key 从 keyspace 中暂时移除掉，然后将任务添加到一个异步队列，最后由后台线程去删除，不过这里需要考虑一种情况是如果用 UNLINK 去删除一个很小的 key，用异步的方式去做反而开销更大，所以它会先计算一个开销的阀值，只有当这个值大于 64 才会使用异步的方式去删除 key，对于基本的数据类型如 List、Set、Hash 这些，阀值就是其中存储的对象数量。\r\n\r\n## ***\\*Redis 多线程网络模型\\****\r\n\r\n前面提到 Redis 最初选择单线程网络模型的理由是：CPU 通常不会成为性能瓶颈，瓶颈往往是**内存**和**网络**，因此单线程足够了。那么为什么现在 Redis 又要引入多线程呢？很简单，就是 Redis 的网络 I/O 瓶颈已经越来越明显了。\r\n\r\n随着互联网的飞速发展，互联网业务系统所要处理的线上流量越来越大，Redis 的单线程模式会导致系统消耗很多 CPU 时间在网络 I/O 上从而降低吞吐量，要提升 Redis 的性能有两个方向：\r\n\r\n· 优化网络 I/O 模块\r\n\r\n· 提高机器内存读写的速度\r\n\r\n后者依赖于硬件的发展，暂时无解。所以只能从前者下手，网络 I/O 的优化又可以分为两个方向：\r\n\r\n· 零拷贝技术或者 DPDK 技术\r\n\r\n· 利用多核优势\r\n\r\n零拷贝技术有其局限性，无法完全适配 Redis 这一类复杂的网络 I/O 场景，更多网络 I/O 对 CPU 时间的消耗和 Linux 零拷贝技术，可以阅读我的另一篇文章：Linux I/O 原理和 Zero-copy 技术全面揭秘。而 DPDK 技术通过旁路网卡 I/O 绕过内核协议栈的方式又太过于复杂以及需要内核甚至是硬件的支持。\r\n\r\n因此，利用多核优势成为了优化网络 I/O 性价比最高的方案。\r\n\r\n6.0 版本之后，Redis 正式在核心网络模型中引入了多线程，也就是所谓的 **I/O threading**，至此 Redis 真正拥有了多线程模型。前一小节，我们了解了 Redis 在 6.0 版本之前的单线程事件循环模型，实际上就是一个非常经典的 Reactor 模型：\r\n\r\n![img](23.Redis 多线程网络模型全面揭秘网络硬核系列.assets/wpsC4CE.tmp.png) \r\n\r\n目前 Linux 平台上主流的高性能网络库/框架中，大都采用 Reactor 模式，比如 netty、libevent、libuv、POE(Perl)、Twisted(Python)等。\r\n\r\nReactor 模式本质上指的是使用 I/O 多路复用(I/O multiplexing) + 非阻塞 I/O(non-blocking I/O) 的模式。\r\n\r\n更多关于 Reactor 模式的细节可以参考我之前的文章：Go netpoller 原生网络模型之源码全面揭秘，Reactor 网络模型那一小节，这里不再赘述。\r\n\r\nRedis 的核心网络模型在 6.0 版本之前，一直是单 Reactor 模式：所有事件的处理都在单个线程内完成，虽然在 4.0 版本中引入了多线程，但是那个更像是针对特定场景（删除超大 key 值等）而打的补丁，并不能被视作核心网络模型的多线程。\r\n\r\n通常来说，单 Reactor 模式，引入多线程之后会进化为 Multi-Reactors 模式，基本工作模式如下：\r\n\r\n![img](23.Redis 多线程网络模型全面揭秘网络硬核系列.assets/wpsC4CF.tmp.png) \r\n\r\n区别于单 Reactor 模式，这种模式不再是单线程的事件循环，而是有多个线程（Sub Reactors）各自维护一个独立的事件循环，由 Main Reactor 负责接收新连接并分发给 Sub Reactors 去独立处理，最后 Sub Reactors 回写响应给客户端。\r\n\r\nMultiple Reactors 模式通常也可以等同于 Master-Workers 模式，比如 Nginx 和 Memcached 等就是采用这种多线程模型，虽然不同的项目实现细节略有区别，但总体来说模式是一致的。\r\n\r\n### ***\\*设计思路\\****\r\n\r\nRedis 虽然也实现了多线程，但是却不是标准的 Multi-Reactors/Master-Workers 模式，这其中的缘由我们后面会分析，现在我们先看一下 Redis 多线程网络模型的总体设计：\r\n\r\n![img](23.Redis 多线程网络模型全面揭秘网络硬核系列.assets/wpsC4D0.tmp.png) \r\n\r\n\\1. Redis 服务器启动，开启主线程事件循环（Event Loop），注册 acceptTcpHandler 连接应答处理器到用户配置的监听端口对应的文件描述符，等待新连接到来；\r\n\r\n\\2. 客户端和服务端建立网络连接；\r\n\r\n\\3. acceptTcpHandler 被调用，主线程使用 AE 的 API 将 readQueryFromClient 命令读取处理器绑定到新连接对应的文件描述符上，并初始化一个 client 绑定这个客户端连接；\r\n\r\n\\4. 客户端发送请求命令，触发读就绪事件，服务端主线程不会通过 socket 去读取客户端的请求命令，而是先将 client 放入一个 LIFO 队列 clients_pending_read；\r\n\r\n\\5. 在事件循环（Event Loop）中，主线程执行 beforeSleep --\x3ehandleClientsWithPendingReadsUsingThreads，利用 Round-Robin 轮询负载均衡策略，把 clients_pending_read队列中的连接均匀地分配给 I/O 线程各自的本地 FIFO 任务队列 io_threads_list[id] 和主线程自己，I/O 线程通过 socket 读取客户端的请求命令，存入 client->querybuf 并解析第一个命令，**但不执行命令**，主线程忙轮询，等待所有 I/O 线程完成读取任务；\r\n\r\n\\6. 主线程和所有 I/O 线程都完成了读取任务，主线程结束忙轮询，遍历 clients_pending_read 队列，**执行所有客户端连接的请求命令**，先调用 processCommandAndResetClient 执行第一条已经解析好的命令，然后调用 processInputBuffer 解析并执行客户端连接的所有命令，在其中使用 processInlineBuffer 或者 processMultibulkBuffer 根据 Redis 协议解析命令，最后调用 processCommand 执行命令；\r\n\r\n\\7. 根据请求命令的类型（SET, GET, DEL, EXEC 等），分配相应的命令执行器去执行，最后调用 addReply 函数族的一系列函数将响应数据写入到对应 client 的写出缓冲区：client->buf 或者 client->reply ，client->buf 是首选的写出缓冲区，固定大小 16KB，一般来说可以缓冲足够多的响应数据，但是如果客户端在时间窗口内需要响应的数据非常大，那么则会自动切换到 client->reply 链表上去，使用链表理论上能够保存无限大的数据（受限于机器的物理内存），最后把 client 添加进一个 LIFO 队列 clients_pending_write；\r\n\r\n\\8. 在事件循环（Event Loop）中，主线程执行 beforeSleep --\x3e handleClientsWithPendingWritesUsingThreads，利用 Round-Robin 轮询负载均衡策略，把 clients_pending_write 队列中的连接均匀地分配给 I/O 线程各自的本地 FIFO 任务队列 io_threads_list[id] 和主线程自己，I/O 线程通过调用 writeToClient 把 client 的写出缓冲区里的数据回写到客户端，主线程忙轮询，等待所有 I/O 线程完成写出任务；\r\n\r\n\\9. 主线程和所有 I/O 线程都完成了写出任务， 主线程结束忙轮询，遍历 clients_pending_write 队列，如果 client 的写出缓冲区还有数据遗留，则注册 sendReplyToClient 到该连接的写就绪事件，等待客户端可写时在事件循环中再继续回写残余的响应数据。\r\n\r\n这里大部分逻辑和之前的单线程模型是一致的，变动的地方仅仅是把读取客户端请求命令和回写响应数据的逻辑异步化了，交给 I/O 线程去完成，这里需要特别注意的一点是：**I/O 线程仅仅是读取和解析客户端命令而不会真正去执行命令，客户端命令的执行最终还是要回到主线程上完成**。\r\n\r\n### ***\\*源码剖析\\****\r\n\r\n***\\*\\****\r\n\r\n以下所有代码基于目前最新的 Redis v6.0.10 版本。\r\n\r\n”\r\n\r\n#### ***\\*多线程初始化\\****\r\n\r\n***\\*void\\**** ***\\*initThreadedIO\\****(***\\*void\\****) {\r\n  server.io_threads_active = 0; /* We start with threads not active. */\r\n\r\n  // 如果用户只配置了一个 I/O 线程，则不会创建新线程（效率低），直接在主线程里处理 I/O。\r\n  ***\\*if\\**** (server.io_threads_num == 1) ***\\*return\\****;\r\n\r\n  ***\\*if\\**** (server.io_threads_num > IO_THREADS_MAX_NUM) {\r\n    serverLog(LL_WARNING,"Fatal: too many I/O threads configured. "\r\n               "The maximum number is %d.", IO_THREADS_MAX_NUM);\r\n    exit(1);\r\n  }\r\n\r\n  // 根据用户配置的 I/O 线程数，启动线程。\r\n  ***\\*for\\**** (***\\*int\\**** i = 0; i < server.io_threads_num; i++) {\r\n    // 初始化 I/O 线程的本地任务队列。\r\n    io_threads_list[i] = listCreate();\r\n    ***\\*if\\**** (i == 0) ***\\*continue\\****; // 线程 0 是主线程。\r\n\r\n​    // 初始化 I/O 线程并启动。\r\n​    ***\\*pthread_t\\**** tid;\r\n​    // 每个 I/O 线程会分配一个本地锁，用来休眠和唤醒线程。\r\n​    pthread_mutex_init(&io_threads_mutex[i],***\\*NULL\\****);\r\n​    // 每个 I/O 线程分配一个原子计数器，用来记录当前遗留的任务数量。\r\n​    io_threads_pending[i] = 0;\r\n​    // 主线程在启动 I/O 线程的时候会默认先锁住它，直到有 I/O 任务才唤醒它。\r\n​    pthread_mutex_lock(&io_threads_mutex[i]);\r\n​    // 启动线程，进入 I/O 线程的主逻辑函数 IOThreadMain。\r\n​    ***\\*if\\**** (pthread_create(&tid,***\\*NULL\\****,IOThreadMain,(***\\*void\\*****)(***\\*long\\****)i) != 0) {\r\n​      serverLog(LL_WARNING,"Fatal: Can\'t initialize IO thread.");\r\n​      exit(1);\r\n​    }\r\n​    io_threads[i] = tid;\r\n  }\r\n}\r\n\r\ninitThreadedIO 会在 Redis 服务器启动时的初始化工作的末尾被调用，初始化 I/O 多线程并启动。\r\n\r\nRedis 的多线程模式默认是关闭的，需要用户在 redis.conf 配置文件中开启：\r\n\r\nio-threads 4\r\nio-threads-do-reads yes\r\n\r\n#### ***\\*读取请求\\****\r\n\r\n当客户端发送请求命令之后，会触发 Redis 主线程的事件循环，命令处理器 readQueryFromClient 被回调，在以前的单线程模型下，这个方法会直接读取解析客户端命令并执行，但是多线程模式下，则会把 client 加入到 clients_pending_read 任务队列中去，后面主线程再分配到 I/O 线程去读取客户端请求命令：\r\n\r\n***\\*void\\**** ***\\*readQueryFromClient\\****(connection *conn) {\r\n  client *c = connGetPrivateData(conn);\r\n  ***\\*int\\**** nread, readlen;\r\n  ***\\*size_t\\**** qblen;\r\n\r\n  // 检查是否开启了多线程，如果是则把 client 加入异步队列之后返回。\r\n  ***\\*if\\**** (postponeClientRead(c)) ***\\*return\\****;\r\n  \r\n  // 省略代码，下面的代码逻辑和单线程版本几乎是一样的。\r\n  ... \r\n}\r\n\r\n***\\*int\\**** ***\\*postponeClientRead\\****(client *c) {\r\n  // 当多线程 I/O 模式开启、主线程没有在处理阻塞任务时，将 client 加入异步队列。\r\n  ***\\*if\\**** (server.io_threads_active &&\r\n    server.io_threads_do_reads &&\r\n    !ProcessingEventsWhileBlocked &&\r\n    !(c->flags & (CLIENT_MASTER|CLIENT_SLAVE|CLIENT_PENDING_READ)))\r\n  {\r\n    // 给 client 打上 CLIENT_PENDING_READ 标识，表示该 client 需要被多线程处理，\r\n    // 后续在 I/O 线程中会在读取和解析完客户端命令之后判断该标识并放弃执行命令，让主线程去执行。\r\n    c->flags |= CLIENT_PENDING_READ;\r\n    listAddNodeHead(server.clients_pending_read,c);\r\n    ***\\*return\\****1;\r\n  } ***\\*else\\**** {\r\n    ***\\*return\\****0;\r\n  }\r\n}\r\n\r\n接着主线程会在事件循环的 beforeSleep() 方法中，调用 handleClientsWithPendingReadsUsingThreads：\r\n\r\n***\\*int\\**** ***\\*handleClientsWithPendingReadsUsingThreads\\****(***\\*void\\****) {\r\n  ***\\*if\\**** (!server.io_threads_active || !server.io_threads_do_reads) ***\\*return\\****0;\r\n  ***\\*int\\**** processed = listLength(server.clients_pending_read);\r\n  ***\\*if\\**** (processed == 0) ***\\*return\\****0;\r\n\r\n  ***\\*if\\**** (tio_debug) printf("%d TOTAL READ pending clients\\n", processed);\r\n\r\n  // 遍历待读取的 client 队列 clients_pending_read，\r\n  // 通过 RR 轮询均匀地分配给 I/O 线程和主线程自己（编号 0）。\r\n  listIter li;\r\n  listNode *ln;\r\n  listRewind(server.clients_pending_read,&li);\r\n  ***\\*int\\**** item_id = 0;\r\n  ***\\*while\\****((ln = listNext(&li))) {\r\n    client *c = listNodeValue(ln);\r\n    ***\\*int\\**** target_id = item_id % server.io_threads_num;\r\n    listAddNodeTail(io_threads_list[target_id],c);\r\n    item_id++;\r\n  }\r\n\r\n  // 设置当前 I/O 操作为读取操作，给每个 I/O 线程的计数器设置分配的任务数量，\r\n  // 让 I/O 线程可以开始工作：只读取和解析命令，不执行。\r\n  io_threads_op = IO_THREADS_OP_READ;\r\n  ***\\*for\\**** (***\\*int\\**** j = 1; j < server.io_threads_num; j++) {\r\n    ***\\*int\\**** count = listLength(io_threads_list[j]);\r\n    io_threads_pending[j] = count;\r\n  }\r\n\r\n  // 主线程自己也会去执行读取客户端请求命令的任务，以达到最大限度利用 CPU。\r\n  listRewind(io_threads_list[0],&li);\r\n  ***\\*while\\****((ln = listNext(&li))) {\r\n    client *c = listNodeValue(ln);\r\n    readQueryFromClient(c->conn);\r\n  }\r\n  listEmpty(io_threads_list[0]);\r\n\r\n  // 忙轮询，累加所有 I/O 线程的原子任务计数器，直到所有计数器的遗留任务数量都是 0，\r\n  // 表示所有任务都已经执行完成，结束轮询。\r\n  ***\\*while\\****(1) {\r\n    ***\\*unsignedlong\\**** pending = 0;\r\n    ***\\*for\\**** (***\\*int\\**** j = 1; j < server.io_threads_num; j++)\r\n      pending += io_threads_pending[j];\r\n    ***\\*if\\**** (pending == 0) ***\\*break\\****;\r\n  }\r\n  ***\\*if\\**** (tio_debug) printf("I/O READ All threads finshed\\n");\r\n\r\n  // 遍历待读取的 client 队列，清除 CLIENT_PENDING_READ 和 CLIENT_PENDING_COMMAND 标记，\r\n  // 然后解析并执行所有 client 的命令。\r\n  ***\\*while\\****(listLength(server.clients_pending_read)) {\r\n    ln = listFirst(server.clients_pending_read);\r\n    client *c = listNodeValue(ln);\r\n    c->flags &= ~CLIENT_PENDING_READ;\r\n    listDelNode(server.clients_pending_read,ln);\r\n\r\n​    ***\\*if\\**** (c->flags & CLIENT_PENDING_COMMAND) {\r\n​      c->flags &= ~CLIENT_PENDING_COMMAND;\r\n​      // client 的第一条命令已经被解析好了，直接尝试执行。\r\n​      ***\\*if\\**** (processCommandAndResetClient(c) == C_ERR) {\r\n​        /* If the client is no longer valid, we avoid\r\n​         \\* processing the client later. So we just go\r\n​         \\* to the next. */\r\n​        ***\\*continue\\****;\r\n​      }\r\n​    }\r\n​    processInputBuffer(c); // 继续解析并执行 client 命令。\r\n\r\n​    // 命令执行完成之后，如果 client 中有响应数据需要回写到客户端，则将 client 加入到待写出队列 clients_pending_write\r\n​    ***\\*if\\**** (!(c->flags & CLIENT_PENDING_WRITE) && clientHasPendingReplies(c))\r\n​      clientInstallWriteHandler(c);\r\n  }\r\n\r\n  /* Update processed count on server */\r\n  server.stat_io_reads_processed += processed;\r\n\r\n  ***\\*return\\**** processed;\r\n}\r\n\r\n这里的核心工作是：\r\n\r\n· 遍历待读取的 client 队列 clients_pending_read，通过 RR 策略把所有任务分配给 I/O 线程和主线程去读取和解析客户端命令。\r\n\r\n· 忙轮询等待所有 I/O 线程完成任务。\r\n\r\n· 最后再遍历 clients_pending_read，执行所有 client 的命令。\r\n\r\n#### ***\\*写回响应\\****\r\n\r\n完成命令的读取、解析以及执行之后，客户端命令的响应数据已经存入 client->buf 或者 client->reply 中了，接下来就需要把响应数据回写到客户端了，还是在 beforeSleep 中， 主线程调用 handleClientsWithPendingWritesUsingThreads：\r\n\r\n***\\*int\\**** ***\\*handleClientsWithPendingWritesUsingThreads\\****(***\\*void\\****) {\r\n  ***\\*int\\**** processed = listLength(server.clients_pending_write);\r\n  ***\\*if\\**** (processed == 0) ***\\*return\\****0; /* Return ASAP if there are no clients. */\r\n\r\n  // 如果用户设置的 I/O 线程数等于 1 或者当前 clients_pending_write 队列中待写出的 client\r\n  // 数量不足 I/O 线程数的两倍，则不用多线程的逻辑，让所有 I/O 线程进入休眠，\r\n  // 直接在主线程把所有 client 的相应数据回写到客户端。\r\n  ***\\*if\\**** (server.io_threads_num == 1 || stopThreadedIOIfNeeded()) {\r\n    ***\\*return\\**** handleClientsWithPendingWrites();\r\n  }\r\n\r\n  // 唤醒正在休眠的 I/O 线程（如果有的话）。\r\n  ***\\*if\\**** (!server.io_threads_active) startThreadedIO();\r\n\r\n  ***\\*if\\**** (tio_debug) printf("%d TOTAL WRITE pending clients\\n", processed);\r\n\r\n  // 遍历待写出的 client 队列 clients_pending_write，\r\n  // 通过 RR 轮询均匀地分配给 I/O 线程和主线程自己（编号 0）。\r\n  listIter li;\r\n  listNode *ln;\r\n  listRewind(server.clients_pending_write,&li);\r\n  ***\\*int\\**** item_id = 0;\r\n  ***\\*while\\****((ln = listNext(&li))) {\r\n    client *c = listNodeValue(ln);\r\n    c->flags &= ~CLIENT_PENDING_WRITE;\r\n\r\n​    /* Remove clients from the list of pending writes since\r\n​     \\* they are going to be closed ASAP. */\r\n​    ***\\*if\\**** (c->flags & CLIENT_CLOSE_ASAP) {\r\n​      listDelNode(server.clients_pending_write, ln);\r\n​      ***\\*continue\\****;\r\n​    }\r\n\r\n​    ***\\*int\\**** target_id = item_id % server.io_threads_num;\r\n​    listAddNodeTail(io_threads_list[target_id],c);\r\n​    item_id++;\r\n  }\r\n\r\n  // 设置当前 I/O 操作为写出操作，给每个 I/O 线程的计数器设置分配的任务数量，\r\n  // 让 I/O 线程可以开始工作，把写出缓冲区（client->buf 或 c->reply）中的响应数据回写到客户端。\r\n  io_threads_op = IO_THREADS_OP_WRITE;\r\n  ***\\*for\\**** (***\\*int\\**** j = 1; j < server.io_threads_num; j++) {\r\n    ***\\*int\\**** count = listLength(io_threads_list[j]);\r\n    io_threads_pending[j] = count;\r\n  }\r\n\r\n  // 主线程自己也会去执行读取客户端请求命令的任务，以达到最大限度利用 CPU。\r\n  listRewind(io_threads_list[0],&li);\r\n  ***\\*while\\****((ln = listNext(&li))) {\r\n    client *c = listNodeValue(ln);\r\n    writeToClient(c,0);\r\n  }\r\n  listEmpty(io_threads_list[0]);\r\n\r\n  // 忙轮询，累加所有 I/O 线程的原子任务计数器，直到所有计数器的遗留任务数量都是 0。\r\n  // 表示所有任务都已经执行完成，结束轮询。\r\n  ***\\*while\\****(1) {\r\n    ***\\*unsignedlong\\**** pending = 0;\r\n    ***\\*for\\**** (***\\*int\\**** j = 1; j < server.io_threads_num; j++)\r\n      pending += io_threads_pending[j];\r\n    ***\\*if\\**** (pending == 0) ***\\*break\\****;\r\n  }\r\n  ***\\*if\\**** (tio_debug) printf("I/O WRITE All threads finshed\\n");\r\n\r\n  // 最后再遍历一次 clients_pending_write 队列，检查是否还有 client 的中写出缓冲区中有残留数据，\r\n  // 如果有，那就为 client 注册一个命令回复器 sendReplyToClient，等待客户端写就绪再继续把数据回写。\r\n  listRewind(server.clients_pending_write,&li);\r\n  ***\\*while\\****((ln = listNext(&li))) {\r\n    client *c = listNodeValue(ln);\r\n\r\n​    // 检查 client 的写出缓冲区是否还有遗留数据。\r\n​    ***\\*if\\**** (clientHasPendingReplies(c) &&\r\n​        connSetWriteHandler(c->conn, sendReplyToClient) == AE_ERR)\r\n​    {\r\n​      freeClientAsync(c);\r\n​    }\r\n  }\r\n  listEmpty(server.clients_pending_write);\r\n\r\n  /* Update processed count on server */\r\n  server.stat_io_writes_processed += processed;\r\n\r\n  ***\\*return\\**** processed;\r\n}\r\n\r\n这里的核心工作是：\r\n\r\n· 检查当前任务负载，如果当前的任务数量不足以用多线程模式处理的话，则休眠 I/O 线程并且直接同步将响应数据回写到客户端。\r\n\r\n· 唤醒正在休眠的 I/O 线程（如果有的话）。\r\n\r\n· 遍历待写出的 client 队列 clients_pending_write，通过 RR 策略把所有任务分配给 I/O 线程和主线程去将响应数据写回到客户端。\r\n\r\n· 忙轮询等待所有 I/O 线程完成任务。\r\n\r\n· 最后再遍历 clients_pending_write，为那些还残留有响应数据的 client 注册命令回复处理器 sendReplyToClient，等待客户端可写之后在事件循环中继续回写残余的响应数据。\r\n\r\n#### ***\\*I/O 线程主逻辑\\****\r\n\r\n***\\*void\\**** ****\\*IOThreadMain\\****(***\\*void\\**** *myid) {\r\n  /* The ID is the thread number (from 0 to server.iothreads_num-1), and is\r\n   \\* used by the thread to just manipulate a single sub-array of clients. */\r\n  ***\\*long\\**** id = (***\\*unsignedlong\\****)myid;\r\n  ***\\*char\\**** thdname[16];\r\n\r\n  snprintf(thdname, ***\\*sizeof\\****(thdname), "io_thd_%ld", id);\r\n  redis_set_thread_title(thdname);\r\n  // 设置 I/O 线程的 CPU 亲和性，尽可能将 I/O 线程（以及主线程，不在这里设置）绑定到用户配置的\r\n  // CPU 列表上。\r\n  redisSetCpuAffinity(server.server_cpulist);\r\n  makeThreadKillable();\r\n\r\n  ***\\*while\\****(1) {\r\n    // 忙轮询，100w 次循环，等待主线程分配 I/O 任务。\r\n    ***\\*for\\**** (***\\*int\\**** j = 0; j < 1000000; j++) {\r\n      ***\\*if\\**** (io_threads_pending[id] != 0) ***\\*break\\****;\r\n    }\r\n\r\n​    // 如果 100w 次忙轮询之后如果还是没有任务分配给它，则通过尝试加锁进入休眠，\r\n​    // 等待主线程分配任务之后调用 startThreadedIO 解锁，唤醒 I/O 线程去执行。\r\n​    ***\\*if\\**** (io_threads_pending[id] == 0) {\r\n​      pthread_mutex_lock(&io_threads_mutex[id]);\r\n​      pthread_mutex_unlock(&io_threads_mutex[id]);\r\n​      ***\\*continue\\****;\r\n​    }\r\n\r\n​    serverAssert(io_threads_pending[id] != 0);\r\n\r\n​    ***\\*if\\**** (tio_debug) printf("[%ld] %d to handle\\n", id, (***\\*int\\****)listLength(io_threads_list[id]));\r\n\r\n\r\n    // 注意：主线程分配任务给 I/O 线程之时，\r\n    // 会把任务加入每个线程的本地任务队列 io_threads_list[id]，\r\n    // 但是当 I/O 线程开始执行任务之后，主线程就不会再去访问这些任务队列，避免数据竞争。\r\n    listIter li;\r\n    listNode *ln;\r\n    listRewind(io_threads_list[id],&li);\r\n    ***\\*while\\****((ln = listNext(&li))) {\r\n      client *c = listNodeValue(ln);\r\n      // 如果当前是写出操作，则把 client 的写出缓冲区中的数据回写到客户端。\r\n      ***\\*if\\**** (io_threads_op == IO_THREADS_OP_WRITE) {\r\n        writeToClient(c,0);\r\n       // 如果当前是读取操作，则socket 读取客户端的请求命令并解析第一条命令。\r\n      } ***\\*elseif\\**** (io_threads_op == IO_THREADS_OP_READ) {\r\n        readQueryFromClient(c->conn);\r\n      } ***\\*else\\**** {\r\n        serverPanic("io_threads_op value is unknown");\r\n      }\r\n    }\r\n    listEmpty(io_threads_list[id]);\r\n    // 所有任务执行完之后把自己的计数器置 0，主线程通过累加所有 I/O 线程的计数器\r\n    // 判断是否所有 I/O 线程都已经完成工作。\r\n    io_threads_pending[id] = 0;\r\n\r\n​    ***\\*if\\**** (tio_debug) printf("[%ld] Done\\n", id);\r\n  }\r\n}\r\n\r\nI/O 线程启动之后，会先进入忙轮询，判断原子计数器中的任务数量，如果是非 0 则表示主线程已经给它分配了任务，开始执行任务，否则就一直忙轮询一百万次等待，忙轮询结束之后再查看计数器，如果还是 0，则尝试加本地锁，因为主线程在启动 I/O 线程之时就已经提前锁住了所有 I/O 线程的本地锁，因此 I/O 线程会进行休眠，等待主线程唤醒。\r\n\r\n主线程会在每次事件循环中尝试调用 startThreadedIO 唤醒 I/O 线程去执行任务，如果接收到客户端请求命令，则 I/O 线程会被唤醒开始工作，根据主线程设置的 io_threads_op 标识去执行命令读取和解析或者回写响应数据的任务，I/O 线程在收到主线程通知之后，会遍历自己的本地任务队列 io_threads_list[id]，取出一个个 client 执行任务：\r\n\r\n· 如果当前是写出操作，则调用 writeToClient，通过 socket 把 client->buf 或者 client->reply 里的响应数据回写到客户端。\r\n\r\n· 如果当前是读取操作，则调用 readQueryFromClient，通过 socket 读取客户端命令，存入 client->querybuf，然后调用 processInputBuffer 去解析命令，这里最终只会解析到第一条命令，然后就结束，不会去执行命令。\r\n\r\n· 在全部任务执行完之后把自己的原子计数器置 0，以告知主线程自己已经完成了工作。\r\n\r\n***\\*void\\**** ***\\*processInputBuffer\\****(client *c) {\r\n// 省略代码\r\n...\r\n\r\n  ***\\*while\\****(c->qb_pos < sdslen(c->querybuf)) {\r\n    /* Return if clients are paused. */\r\n    ***\\*if\\**** (!(c->flags & CLIENT_SLAVE) && clientsArePaused()) ***\\*break\\****;\r\n\r\n​    /* Immediately abort if the client is in the middle of something. */\r\n​    ***\\*if\\**** (c->flags & CLIENT_BLOCKED) ***\\*break\\****;\r\n\r\n​    /* Don\'t process more buffers from clients that have already pending\r\n​     \\* commands to execute in c->argv. */\r\n​    ***\\*if\\**** (c->flags & CLIENT_PENDING_COMMAND) ***\\*break\\****;\r\n​    /* Multibulk processing could see a <= 0 length. */\r\n​    ***\\*if\\**** (c->argc == 0) {\r\n​      resetClient(c);\r\n​    } ***\\*else\\**** {\r\n​      // 判断 client 是否具有 CLIENT_PENDING_READ 标识，如果是处于多线程 I/O 的模式下，\r\n​      // 那么此前已经在 readQueryFromClient -> postponeClientRead 中为 client 打上该标识，\r\n​      // 则立刻跳出循环结束，此时第一条命令已经解析完成，但是不执行命令。\r\n​      ***\\*if\\**** (c->flags & CLIENT_PENDING_READ) {\r\n​        c->flags |= CLIENT_PENDING_COMMAND;\r\n​        ***\\*break\\****;\r\n​      }\r\n\r\n​      // 执行客户端命令\r\n​      ***\\*if\\**** (processCommandAndResetClient(c) == C_ERR) {\r\n​        /* If the client is no longer valid, we avoid exiting this\r\n​         \\* loop and trimming the client buffer later. So we return\r\n​         \\* ASAP in that case. */\r\n​        ***\\*return\\****;\r\n​      }\r\n​    }\r\n  }\r\n\r\n...\r\n}\r\n\r\n这里需要额外关注 I/O 线程初次启动时会设置当前线程的 CPU 亲和性，也就是绑定当前线程到用户配置的 CPU 上，在启动 Redis 服务器主线程的时候同样会设置 CPU 亲和性，Redis 的核心网络模型引入多线程之后，加上之前的多线程异步任务、多进程（BGSAVE、AOF、BIO、Sentinel 脚本任务等），Redis 现如今的系统并发度已经很大了，而 Redis 本身又是一个对吞吐量和延迟极度敏感的系统，所以用户需要 Redis 对 CPU 资源有更细粒度的控制，这里主要考虑的是两方面：CPU 高速缓存和 NUMA 架构。\r\n\r\n首先是 CPU 高速缓存（这里讨论的是 L1 Cache 和 L2 Cache 都集成在 CPU 中的硬件架构），这里想象一种场景：Redis 主进程正在 CPU-1 上运行，给客户端提供数据服务，此时 Redis 启动了子进程进行数据持久化（BGSAVE 或者 AOF），系统调度之后子进程抢占了主进程的 CPU-1，主进程被调度到 CPU-2 上去运行，导致之前 CPU-1 的高速缓存里的相关指令和数据被汰换掉，CPU-2 需要重新加载指令和数据到自己的本地高速缓存里，浪费 CPU 资源，降低性能。\r\n\r\n![img](23.Redis 多线程网络模型全面揭秘网络硬核系列.assets/wpsC4E0.tmp.png) \r\n\r\n因此，Redis 通过设置 CPU 亲和性，可以将主进程/线程和子进程/线程绑定到不同的核隔离开来，使之互不干扰，能有效地提升系统性能。\r\n\r\n其次是基于 NUMA 架构的考虑，在 NUMA 体系下，内存控制器芯片被集成到处理器内部，形成 CPU 本地内存，访问本地内存只需通过内存通道而无需经过系统总线，访问时延大大降低，而多个处理器之间通过 QPI 数据链路互联，跨 NUMA 节点的内存访问开销远大于本地内存的访问：\r\n\r\n![img](23.Redis 多线程网络模型全面揭秘网络硬核系列.assets/wpsC4E1.tmp.jpg) \r\n\r\n因此，Redis 通过设置 CPU 亲和性，让主进程/线程尽可能在固定的 NUMA 节点上的 CPU 上运行，更多地使用本地内存而不需要跨节点访问数据，同样也能大大地提升性能。\r\n\r\n关于 NUMA 相关知识请读者自行查阅，篇幅所限这里就不再展开，以后有时间我再单独写一篇文章介绍。\r\n\r\n最后还有一点，阅读过源码的读者可能会有疑问，Redis 的多线程模式下，似乎并没有对数据进行锁保护，事实上 Redis 的多线程模型是全程无锁（Lock-free）的，这是通过原子操作+交错访问来实现的，主线程和 I/O 线程之间共享的变量有三个：io_threads_pending 计数器、io_threads_op I/O 标识符和 io_threads_list 线程本地任务队列。\r\n\r\nio_threads_pending 是原子变量，不需要加锁保护，io_threads_op 和 io_threads_list 这两个变量则是通过控制主线程和 I/O 线程交错访问来规避共享数据竞争问题：I/O 线程启动之后会通过忙轮询和锁休眠等待主线程的信号，在这之前它不会去访问自己的本地任务队列 io_threads_list[id]，而主线程会在分配完所有任务到各个 I/O 线程的本地队列之后才去唤醒 I/O 线程开始工作，并且主线程之后在 I/O 线程运行期间只会访问自己的本地任务队列 io_threads_list[0] 而不会再去访问 I/O 线程的本地队列，这也就保证了主线程永远会在 I/O 线程之前访问 io_threads_list 并且之后不再访问，保证了交错访问。io_threads_op 同理，主线程会在唤醒 I/O 线程之前先设置好 io_threads_op 的值，并且在 I/O 线程运行期间不会再去访问这个变量。\r\n\r\n![img](23.Redis 多线程网络模型全面揭秘网络硬核系列.assets/wpsC4E2.tmp.png) \r\n\r\n### ***\\*性能提升\\****\r\n\r\nRedis 将核心网络模型改造成多线程模式追求的当然是最终性能上的提升，所以最终还是要以 benchmark 数据见真章：\r\n\r\n![img](23.Redis 多线程网络模型全面揭秘网络硬核系列.assets/wpsC4F3.tmp.png) \r\n\r\n测试数据表明，Redis 在使用多线程模式之后性能大幅提升，达到了一倍。更详细的性能压测数据可以参阅这篇文章：Benchmarking the experimental Redis Multi-Threaded I/O。\r\n\r\n以下是美图技术团队实测的新旧 Redis 版本性能对比图，仅供参考：\r\n\r\n![img](23.Redis 多线程网络模型全面揭秘网络硬核系列.assets/wpsC4F4.tmp.png)![img](23.Redis 多线程网络模型全面揭秘网络硬核系列.assets/wpsC4F5.tmp.png) \r\n\r\n### ***\\*模型缺陷\\****\r\n\r\n首先第一个就是我前面提到过的，Redis 的多线程网络模型实际上并不是一个标准的 Multi-Reactors/Master-Workers 模型，和其他主流的开源网络服务器的模式有所区别，最大的不同就是在标准的 Multi-Reactors/Master-Workers 模式下，Sub Reactors/Workers 会完成 网络读 -> 数据解析 -> 命令执行 -> 网络写 整套流程，Main Reactor/Master 只负责分派任务，而在 Redis 的多线程方案中，I/O 线程任务仅仅是通过 socket 读取客户端请求命令并解析，却没有真正去执行命令，所有客户端命令最后还需要回到主线程去执行，因此对多核的利用率并不算高，而且每次主线程都必须在分配完任务之后忙轮询等待所有 I/O 线程完成任务之后才能继续执行其他逻辑。\r\n\r\nRedis 之所以如此设计它的多线程网络模型，我认为主要的原因是为了保持兼容性，因为以前 Redis 是单线程的，所有的客户端命令都是在单线程的事件循环里执行的，也因此 Redis 里所有的数据结构都是非线程安全的，现在引入多线程，如果按照标准的 Multi-Reactors/Master-Workers 模式来实现，则所有内置的数据结构都必须重构成线程安全的，这个工作量无疑是巨大且麻烦的。\r\n\r\n所以，在我看来，Redis 目前的多线程方案更像是一个折中的选择：既保持了原系统的兼容性，又能利用多核提升 I/O 性能。\r\n\r\n其次，目前 Redis 的多线程模型中，主线程和 I/O 线程的通信过于简单粗暴：忙轮询和锁，因为通过自旋忙轮询进行等待，导致 Redis 在启动的时候以及运行期间偶尔会有短暂的 CPU 空转引起的高占用率，而且这个通信机制的最终实现看起来非常不直观和不简洁，希望后面 Redis 能对目前的方案加以改进。\r\n\r\n## ***\\*总结\\****\r\n\r\nRedis 作为缓存系统的事实标准，它的底层原理值得开发者去深入学习，Redis 自 2009 年发布第一版之后，其单线程网络模型的选择在社区中从未停止过讨论，多年来一直有呼声希望 Redis 能引入多线程从而利用多核优势，但是作者 antirez 是一个追求大道至简的开发者，对 Redis 加入任何新功能都异常谨慎，所以在 Redis 初版发布的十年后才最终将 Redis 的核心网络模型改造成多线程模式，这期间甚至诞生了一些 Redis 多线程的替代项目。虽然 antirez 一直在推迟多线程的方案，但却从未停止思考多线程的可行性，Redis 多线程网络模型的改造不是一朝一夕的事情，这其中牵扯到项目的方方面面，所以我们可以看到 Redis 的最终方案也并不完美，没有采用主流的多线程模式设计。\r\n\r\n让我们来回顾一下 Redis 多线程网络模型的设计方案：\r\n\r\n· 使用 I/O 线程实现网络 I/O 多线程化，I/O 线程只负责网络 I/O 和命令解析，不执行客户端命令。\r\n\r\n· 利用原子操作+交错访问实现无锁的多线程模型。\r\n\r\n· 通过设置 CPU 亲和性，隔离主进程和其他子进程，让多线程网络模型能发挥最大的性能。\r\n\r\n通读本文之后，相信读者们应该能够了解到一个优秀的网络系统的实现所涉及到的计算机领域的各种技术：设计模式、网络 I/O、并发编程、操作系统底层，甚至是计算机硬件。另外还需要对项目迭代和重构的谨慎，对技术方案的深入思考，绝不仅仅是写好代码这一个难点。\r\n\r\n## ***\\*参考&延伸阅读\\****\r\n\r\n· Redis v5.0.10\r\n\r\n· Redis v6.0.10\r\n\r\n· Lazy Redis is better Redis\r\n\r\n· An update about Redis developments in 2019\r\n\r\n· How fast is Redis?\r\n\r\n· Go netpoller 原生网络模型之源码全面揭秘\r\n\r\n· Linux I/O 原理和 Zero-copy 技术全面揭秘\r\n\r\n· Benchmarking the experimental Redis Multi-Threaded I/O\r\n\r\n· NUMA DEEP DIVE PART 1: FROM UMA TO NUMA\r\n\r\n## ***\\*References\\****\r\n\r\n[1] Lazy Redis is better Redis: **http://antirez.com/news/93**\r\n[2] Linux I/O 原理和 Zero-copy 技术全面揭秘: **https://strikefreedom.top/linux-io-and-zero-copy**\r\n[3] Go netpoller 原生网络模型之源码全面揭秘: **https://strikefreedom.top/go-netpoll-io-multiplexing-reactor**\r\n[4] Redis v6.0.10: **https://github.com/redis/redis/tree/6.0.10**\r\n[5] Benchmarking the experimental Redis Multi-Threaded I/O: **https://itnext.io/benchmarking-the-experimental-redis-multi-threaded-i-o-1bb28b69a314**\r\n[6] Redis v5.0.10: **https://github.com/redis/redis/tree/5.0.10**\r\n[7] Redis v6.0.10: **https://github.com/redis/redis/tree/6.0.10**\r\n[8] Lazy Redis is better Redis: **http://antirez.com/news/93**\r\n[9] An update about Redis developments in 2019: **http://antirez.com/news/126**\r\n[10] How fast is Redis?: **https://redis.io/topics/benchmarks**\r\n[11] Go netpoller 原生网络模型之源码全面揭秘: **https://strikefreedom.top/go-netpoll-io-multiplexing-reactor**\r\n[12] Linux I/O 原理和 Zero-copy 技术全面揭秘: **https://strikefreedom.top/linux-io-and-zero-copy**\r\n[13] Benchmarking the experimental Redis Multi-Threaded I/O: **https://itnext.io/benchmarking-the-experimental-redis-multi-threaded-i-o-1bb28b69a314**\r\n[14] NUMA DEEP DIVE PART 1: FROM UMA TO NUMA: **https://frankdenneman.nl/2016/07/07/numa-deep-dive-part-1-uma-numa/**\r\n\r\n \r\n\r\n '},b829:function(n,r,e){"use strict";e.r(r),r["default"]="# 深入理解 Linux的 I/O 系统\r\n\r\n \r\n\r\n收录于话题#深入理解Linux系统22个内容\r\n\r\n![image-20211102015628864](深入理解 Linux的IO系统.assets/image-20211102015628864.png)\r\n\r\n##  \r\n\r\n\r\n目录\r\n\r\n\r\n\r\n传统的 System Call I/O\r\n\r\n 读操作\r\n\r\n 写操作\r\n\r\n 网络 I/O\r\n\r\n 磁盘 I/O\r\n\r\n高性能优化的 I/O\r\n\r\n存储设备的 I/O 栈\r\n\r\nI/O Buffering\r\n\r\n​                    \r\n\r\n# 传统的 System Call I/O\r\n\r\n在 Linux 系统中，传统的访问方式是通过 write() 和 read() 两个系统调用实现的，通过 read() 函数读取文件到到缓存区中，然后通过 write() 方法把缓存中的数据输出到网络端口。\r\n\r\n- \r\n- \r\n\r\n```\r\nread(file_fd, tmp_buf, len);write(socket_fd, tmp_buf, len);\r\n```\r\n\r\n下图分别对应传统 I/O 操作的数据读写流程，整个过程涉及 2 次 CPU 拷贝、2 次 DMA 拷贝，总共 4 次拷贝，以及 4 次上下文切换。\r\n\r\n- **CPU 拷贝**：\r\n\r\n  由 CPU 直接处理数据的传送，数据拷贝时会一直占用 CPU 的资源。\r\n\r\n- **DMA 拷贝**：\r\n\r\n  由 CPU 向DMA磁盘控制器下达指令，让 DMA 控制器来处理数据的传送，数据传送完毕再把信息反馈给 CPU，从而减轻了 CPU 资源的占有率。\r\n\r\n- **上下文切换**：\r\n\r\n  当用户程序向内核发起系统调用时，CPU 将用户进程从用户态切换到内核态；\r\n\r\n  当系统调用返回时，CPU 将用户进程从内核态切换回用户态。\r\n\r\n\r\n\r\n\r\n\r\n## **读操作**\r\n\r\n当应用程序执行 read 系统调用读取一块数据的时候，如果这块数据已经存在于用户进程的页内存中，就直接从内存中读取数据。\r\n\r\n如果数据不存在，则先将数据从磁盘加载数据到内核空间的读缓存（Read Buffer）中，再从读缓存拷贝到用户进程的页内存中。\r\n\r\n ![image-20211102015707606](深入理解 Linux的IO系统.assets/image-20211102015707606.png)\r\n\r\n\r\n\r\n- \r\n\r\n```\r\nread(file_fd, tmp_buf, len);\r\n```\r\n\r\n基于传统的 I/O 读取方式，read 系统调用会触发 2 次上下文切换，1 次 DMA 拷贝和 1 次 CPU 拷贝。\r\n\r\n发起数据读取的流程如下：\r\n\r\n1. 用户进程通过 read() 函数向 Kernel 发起 System Call，上下文从 user space 切换为 kernel space。\r\n2. CPU 利用 DMA 控制器将数据从主存或硬盘拷贝到 kernel space 的读缓冲区（Read Buffer）。\r\n3. CPU 将读缓冲区（Read Buffer）中的数据拷贝到 user space 的用户缓冲区（User Buffer）。\r\n4. 上下文从 kernel space 切换回用户态（User Space），read 调用执行返回。\r\n\r\n\r\n\r\n## **写操作**\r\n\r\n当应用程序准备好数据，执行 write 系统调用发送网络数据时，先将数据从用户空间的页缓存拷贝到内核空间的网络缓冲区（Socket Buffer）中，然后再将写缓存中的数据拷贝到网卡设备完成数据发送。\r\n\r\n```\r\n\r\n```\r\n\r\n- \r\n\r\n```\r\nwrite(socket_fd, tmp_buf, len);\r\n```\r\n\r\n基于传统的 I/O 写入方式，write() 系统调用会触发 2 次上下文切换，1 次 CPU 拷贝和 1 次 DMA 拷贝。\r\n\r\n用户程序发送网络数据的流程如下：\r\n\r\n1. 用户进程通过 write() 函数向 kernel 发起 System Call，上下文从 user space 切换为 kernel space。\r\n2. CPU 将用户缓冲区（User Buffer）中的数据拷贝到 kernel space 的网络缓冲区（Socket Buffer）。\r\n3. CPU 利用 DMA 控制器将数据从网络缓冲区（Socket Buffer）拷贝到 NIC 进行数据传输。\r\n4. 上下文从 kernel space 切换回 user space，write 系统调用执行返回。\r\n\r\n\r\n\r\n## **网络 I/O**\r\n\r\n![image-20211102015728387](深入理解 Linux的IO系统.assets/image-20211102015728387.png)\r\n\r\n\r\n\r\n## **磁盘 I/O**\r\n\r\n \r\n\r\n![image-20211102015746473](深入理解 Linux的IO系统.assets/image-20211102015746473.png)\r\n\r\n\r\n\r\n# 高性能优化的 I/O\r\n\r\n1. **零拷贝技术。**\r\n2. **多路复用技术。**\r\n3. **页缓存（PageCache）技术。**\r\n\r\n其中，**页缓存（PageCache）**是操作系统对文件的缓存，用来减少对磁盘的 I/O 操作，以页为单位的，内容就是磁盘上的物理块，页缓存能帮助程序对文件进行顺序读写的速度几乎接近于内存的读写速度，主要原因就是由于 OS 使用 PageCache 机制对读写访问操作进行了性能优化。\r\n\r\n**页缓存读取策略**：当进程发起一个读操作 （比如，进程发起一个 read() 系统调用），它首先会检查需要的数据是否在页缓存中：\r\n\r\n- **如果在**，则放弃访问磁盘，而直接从页缓存中读取。\r\n- **如果不在**，则内核调度块 I/O 操作从磁盘去读取数据，并读入紧随其后的少数几个页面（不少于一个页面，通常是三个页面），然后将数据放入页缓存中。\r\n\r\n\r\n\r\n![image-20211102015805062](深入理解 Linux的IO系统.assets/image-20211102015805062.png)\r\n\r\n**页缓存写策略**：当进程发起 write 系统调用写数据到文件中，先写到页缓存，然后方法返回。此时数据还没有真正的保存到文件中去，Linux 仅仅将页缓存中的这一页数据标记为 “脏”，并且被加入到脏页链表中。\r\n\r\n然后，由 flusher 回写线程周期性将脏页链表中的页写到磁盘，让磁盘中的数据和内存中保持一致，最后清理“脏”标识。在以下三种情况下，脏页会被写回磁盘：\r\n\r\n1. 空闲内存低于一个特定阈值。\r\n\r\n2. 脏页在内存中驻留超过一个特定的阈值时。\r\n\r\n3. 当用户进程调用 sync() 和 fsync() 系统调用时。\r\n\r\n   \r\n\r\n# 存储设备的 I/O 栈\r\n\r\n\r\n\r\n![image-20211102020027681](深入理解 Linux的IO系统.assets/image-20211102020027681.png)\r\n\r\n由图可见，从系统调用的接口再往下，Linux 下的 IO 栈致大致有三个层次：\r\n\r\n1. **文件系统层**，以 write 为例，内核拷贝了 write 参数指定的用户态数据到文件系统 Cache 中，并适时向下层同步。\r\n\r\n2. **块层**，管理块设备的 IO 队列，对 IO 请求进行合并、排序（还记得操作系统课程学习过的 IO 调度算法吗？\r\n\r\n   ）。\r\n\r\n3. **设备层**，通过 DMA 与内存直接交互，完成数据和具体设备之间的交互。\r\n\r\n\r\n\r\n结合这个图，想想 Linux 系统编程里用到的 **Buffered IO**、**mmap**、**Direct IO**，这些机制怎么和 **Linux I/O 栈**联系起来呢？上面的图有点复杂，我画一幅简图，把这些机制所在的位置添加进去：\r\n\r\n![image-20211102020115468](深入理解 Linux的IO系统.assets/image-20211102020115468.png)\r\n\r\n**Linux IO系统**\r\n\r\n\r\n\r\n这下一目了然了吧？**传统的 Buffered IO** 使用 read 读取文件的过程什么样的？假设要去读一个冷文件（Cache 中不存在），open 打开文件内核后建立了一系列的数据结构，接下来调用 read，到达文件系统这一层，发现 **Page Cache** 中不存在该位置的磁盘映射，然后创建相应的 Page Cache 并和相关的扇区关联。然后请求继续到达块设备层，在 IO 队列里排队，接受一系列的调度后到达设备驱动层，此时一般使用 **DMA** 方式读取相应的磁盘扇区到 Cache 中，然后 read 拷贝数据到用户提供的**用户态 buffer** 中去（read 的参数指出的）。\r\n\r\n\r\n\r\n**整个过程有几次拷贝？**从磁盘到 Page Cache 算第一次的话，从 Page Cache 到用户态 buffer 就是第二次了。而 mmap 做了什么？mmap 直接把 Page Cache 映射到了用户态的地址空间里了，所以 mmap 的方式读文件是没有第二次拷贝过程的。\r\n\r\n\r\n\r\n**那 Direct IO 做了什么？**这个机制更狠，直接让用户态和块 IO 层对接，直接放弃 Page Cache，从磁盘直接和用户态拷贝数据。好处是什么？写操作直接映射进程的buffer到磁盘扇区，以 DMA 的方式传输数据，减少了原本需要到 Page Cache 层的一次拷贝，提升了写的效率。对于读而言，第一次肯定也是快于传统的方式的，但是之后的读就不如传统方式了（当然也可以在用户态自己做 Cache，有些商用数据库就是这么做的）。\r\n\r\n\r\n\r\n除了传统的 Buffered IO 可以比较自由的用偏移+长度的方式读写文件之外，**mmap** 和 Direct IO 均有数据按页对齐的要求，Direct IO 还限制读写必须是底层存储设备块大小的整数倍（甚至 Linux 2.4 还要求是文件系统逻辑块的整数倍）。所以接口越来越底层，换来表面上的效率提升的背后，需要在应用程序这一层做更多的事情。所以想用好这些高级特性，除了深刻理解其背后的机制之外，也要在系统设计上下一番功夫。\r\n\r\n# I/O Buffering\r\n\r\n![image-20211102020154851](深入理解 Linux的IO系统.assets/image-20211102020154851.png)\r\n\r\n如图，当程序调用各类文件操作函数后，用户数据（User Data）到达磁盘（Disk）的流程如图所示。\r\n\r\n图中描述了 Linux 下文件操作函数的层级关系和内存缓存层的存在位置。中间的黑色实线是用户态和内核态的分界线。\r\n\r\n从上往下分析这张图：\r\n\r\n**1.** 首先是 C 语言 stdio 库定义的相关文件操作函数，这些都是用户态实现的跨平台封装函数。stdio 中实现的文件操作函数有自己的 stdio buffer，这是在用户态实现的缓存。此处使用缓存的原因很简单 — 系统调用总是昂贵的。如果用户代码以较小的 size 不断的读或写文件的话，stdio 库将多次的读或者写操作通过 buffer 进行聚合是可以提高程序运行效率的。stdio 库同时也支持 fflush 函数来主动的刷新 buffer，主动的调用底层的系统调用立即更新 buffer 里的数据。特别地，setbuf 函数可以对 stdio 库的用户态 buffer 进行设置，甚至取消 buffer 的使用。\r\n\r\n**2.** **系统调用的 read/write 和真实的磁盘读写之间也存在一层 buffer**，这里用术语 Kernel buffer cache 来指代这一层缓存。在 Linux 下，文件的缓存习惯性的称之为 Page Cache，而更低一级的设备的缓存称之为 Buffer Cache。这两个概念很容易混淆，这里简单的介绍下概念上的区别：Page Cache 用于缓存文件的内容，和文件系统比较相关。文件的内容需要映射到实际的物理磁盘，这种映射关系由文件系统来完成；Buffer Cache 用于缓存存储设备块（比如磁盘扇区）的数据，而不关心是否有文件系统的存在（文件系统的元数据缓存在 Buffer Cache 中）。\r\n\r\n​        "},bc61:function(n,r,e){"use strict";e.r(r),r["default"]="# Nginx Configuration Snippets\r\nA collection of useful Nginx configuration snippets inspired by\r\n[.htaccess snippets](https://github.com/phanan/htaccess).\r\n\r\n## Table of Contents\r\n- [The Nginx Command](#the-nginx-command)\r\n- [Rewrite and Redirection](#rewrite-and-redirection)\r\n    - [Force www](#force-www)\r\n    - [Force no-www](#force-no-www)\r\n    - [Force HTTPS](#force-https)\r\n    - [Force Trailing Slash](#force-trailing-slash)\r\n    - [Redirect a Single Page](#redirect-a-single-page)\r\n    - [Redirect an Entire Site](#redirect-an-entire-site)\r\n    - [Redirect an Entire Sub Path](#redirect-an-entire-sub-path)\r\n- [Performance](#performance)\r\n    - [Contents Caching](#contents-caching)\r\n    - [Gzip Compression](#gzip-compression)\r\n    - [Open File Cache](#open-file-cache)\r\n    - [SSL Cache](#ssl-cache)\r\n    - [Upstream Keepalive](#upstream-keepalive)\r\n- [Monitoring](#monitoring)\r\n- [Security](#security)\r\n    - [Enable Basic Authentication](#enable-basic-authentication)\r\n    - [Only Allow Access From Localhost](#only-allow-access-from-localhost)\r\n    - [Secure SSL settings](#secure-ssl-settings)\r\n- [Miscellaneous](#miscellaneous)\r\n    - [Sub-Request Upon Completion](#sub-request-upon-completion)\r\n    - [Enable Cross Origin Resource Sharing](#enable-cross-origin-resource-sharing)\r\n- [Links](#links)\r\n\r\n## The Nginx Command\r\nThe `nginx` command can be used to perform some useful actions when Nginx is running.\r\n\r\n- Get current Nginx version and its configured compiling parameters: `nginx -V`\r\n- Test the current Nginx configuration file and / or check its location: `nginx -t`\r\n- Reload the configuration without restarting Nginx: `nginx -s reload`\r\n\r\n\r\n## Rewrite and Redirection\r\n\r\n### Force www\r\nThe [right way](http://nginx.org/en/docs/http/converting_rewrite_rules.html)\r\nis to define a separated server for the naked domain and redirect it.\r\n```nginx\r\nserver {\r\n    listen 80;\r\n    server_name example.org;\r\n    return 301 $scheme://www.example.org$request_uri;\r\n}\r\n\r\nserver {\r\n    listen 80;\r\n    server_name www.example.org;\r\n    ...\r\n}\r\n```\r\n\r\nNote that this also works with HTTPS site.\r\n\r\n### Force no-www\r\nAgain, the right way is to define a separated server for the www domain and redirect it.\r\n```nginx\r\nserver {\r\n    listen 80;\r\n    server_name example.org;\r\n}\r\n\r\nserver {\r\n    listen 80;\r\n    server_name www.example.org;\r\n    return 301 $scheme://example.org$request_uri;\r\n}\r\n```\r\n\r\n### Force HTTPS\r\nThis is also handled by the 2 server blocks approach.\r\n```nginx\r\nserver {\r\n    listen 80;\r\n    return 301 https://$host$request_uri;\r\n}\r\n\r\nserver {\r\n    listen 443 ssl;\r\n\r\n    # let the browsers know that we only accept HTTPS\r\n    add_header Strict-Transport-Security max-age=2592000;\r\n\r\n    ...\r\n}\r\n```\r\n\r\n### Force Trailing Slash\r\nThis configuration only add trailing slash to URL that does not contain a dot because you probably don't want to add that trailing slash to your static files.\r\n[Source](http://stackoverflow.com/questions/645853/add-slash-to-the-end-of-every-url-need-rewrite-rule-for-nginx).\r\n```nginx\r\nrewrite ^([^.]*[^/])$ $1/ permanent;\r\n```\r\n\r\n### Redirect a Single Page\r\n```nginx\r\nserver {\r\n    location = /oldpage.html {\r\n        return 301 http://example.org/newpage.html;\r\n    }\r\n}\r\n```\r\n\r\n### Redirect an Entire Site\r\n```nginx\r\nserver {\r\n    server_name old-site.com\r\n    return 301 $scheme://new-site.com$request_uri;\r\n}\r\n```\r\n\r\n### Redirect an Entire Sub Path\r\n```nginx\r\nlocation /old-site {\r\n    rewrite ^/old-site/(.*) http://example.org/new-site/$1 permanent;\r\n}\r\n```\r\n\r\n\r\n## Performance\r\n\r\n### Contents Caching\r\nAllow browsers to cache your static contents for basically forever. Nginx will set both `Expires` and `Cache-Control` header for you.\r\n```nginx\r\nlocation /static {\r\n    root /data;\r\n    expires max;\r\n}\r\n```\r\n\r\nIf you want to ask the browsers to **never** cache the response (e.g. for tracking requests), use `-1`.\r\n```nginx\r\nlocation = /empty.gif {\r\n    empty_gif;\r\n    expires -1;\r\n}\r\n```\r\n\r\n### Gzip Compression\r\n```nginx\r\ngzip  on;\r\ngzip_buffers 16 8k;\r\ngzip_comp_level 6;\r\ngzip_http_version 1.1;\r\ngzip_min_length 256;\r\ngzip_proxied any;\r\ngzip_vary on;\r\ngzip_types\r\n    text/xml application/xml application/atom+xml application/rss+xml application/xhtml+xml image/svg+xml\r\n    text/javascript application/javascript application/x-javascript\r\n    text/x-json application/json application/x-web-app-manifest+json\r\n    text/css text/plain text/x-component\r\n    font/opentype application/x-font-ttf application/vnd.ms-fontobject\r\n    image/x-icon;\r\ngzip_disable  \"msie6\";\r\n```\r\n\r\n### Open File Cache\r\nIf you have _a lot_ of static files to serve through Nginx then caching of the files' metadata (not the actual files' contents) can save some latency.\r\n```nginx\r\nopen_file_cache max=1000 inactive=20s;\r\nopen_file_cache_valid 30s;\r\nopen_file_cache_min_uses 2;\r\nopen_file_cache_errors on;\r\n```\r\n\r\n### SSL Cache\r\nEnable SSL cache for SSL sessions resumption, so that sub sequent SSL/TLS connection handshakes can be shortened and reduce total SSL overhead.\r\n```nginx\r\nssl_session_cache shared:SSL:10m;\r\nssl_session_timeout 10m;\r\n```\r\n\r\n### Upstream Keepalive\r\nEnable the upstream connection cache for better reuse of connections to upstream servers. [Source](http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive).\r\n```nginx\r\nupstream backend {\r\n    server 127.0.0.1:8080;\r\n    keepalive 32;\r\n}\r\n\r\nserver {\r\n    ...\r\n    location /api/ {\r\n        proxy_pass http://backend;\r\n        proxy_http_version 1.1;\r\n        proxy_set_header Connection \"\";\r\n    }\r\n}\r\n```\r\n\r\n\r\n## Monitoring\r\n\r\nThe [Stub Status](http://nginx.org/en/docs/http/ngx_http_stub_status_module.html), which is not built by default, is a very simple to setup module but only provide basic status of Nginx.\r\n```nginx\r\nlocation /status {\r\n    stub_status on;\r\n    access_log off;\r\n}\r\n```\r\n\r\nIt provides the following status for the whole Nginx server in plain text(!) format:\r\n- Client connections: accepted, handled, active (includes reading, writing and waiting).\r\n- Total number of client requests.\r\n\r\n**[Shameless Plug]** A _better_ way to capture Nginx status can be added by using [Luameter](https://luameter.com) which is a bit more complicated to setup and required the Nginx Lua module (which is awesome). It provides following metrics for each [configurable group](https://luameter.com/configuration) as a JSON API:\r\n- Total number of requests / responses.\r\n- Total number of responses groupped by status code: 1xx, 2xx, 3xx, 4xx, 5xx.\r\n- Total bytes received from / sent to client.\r\n- Sampled latency snapshot for estimation of: mean, max, median, 99th percentile, etc., latency.\r\n- Moving average rate of requests for easier monitoring and predicting.\r\n- And [some more](https://luameter.com/metrics).\r\n\r\n[Here is a sample dashboard built with Luameter's metrics](https://luameter.com/demo).\r\n\r\n[ngxtop](https://github.com/lebinh/ngxtop) is also a good way to check for Nginx status and checking / troubleshooting a live server.\r\n\r\n\r\n## Security\r\n\r\n### Enable Basic Authentication\r\nYou will need a user password file somewhere first.\r\n```\r\nname:{PLAIN}plain-text-password\r\n```\r\n\r\nThen add below config to `server`/`location` block that need to be protected.\r\n```nginx\r\nauth_basic \"This is Protected\";\r\nauth_basic_user_file /path/to/password-file;\r\n```\r\n\r\n### Only Allow Access From Localhost\r\n```nginx\r\nlocation /local {\r\n    allow 127.0.0.1;\r\n    deny all;\r\n    ...\r\n}\r\n```\r\n\r\n### Secure SSL settings\r\n- Disable SSLv3 which is enabled by default. This prevents [POODLE SSL Attack](http://nginx.com/blog/nginx-poodle-ssl/).\r\n- Ciphers that best allow protection from Beast. [Mozilla Server Side TLS and Nginx]( https://wiki.mozilla.org/Security/Server_Side_TLS#Nginx)\r\n```nginx\r\n# don’t use SSLv3 ref: POODLE CVE-2014-356 - http://nginx.com/blog/nginx-poodle-ssl/\r\nssl_protocols  TLSv1 TLSv1.1 TLSv1.2;  \r\n\r\n# Ciphers set to best allow protection from Beast, while providing forwarding secrecy, as defined by Mozilla (Intermediate Set) - https://wiki.mozilla.org/Security/Server_Side_TLS#Nginx\r\n    ssl_ciphers 'ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA';\r\nssl_prefer_server_ciphers  on;\r\n\r\n```\r\n\r\n## Miscellaneous\r\n\r\n### Sub-Request Upon Completion\r\nThere are some cases that you want to pass the request to another backend _in addition to and after_ serving it. One use case is to track the number of completed downloads by calling an API after user completed download a file. Another use case is for tracking request where you want to return as fast as possible (perhaps with an `empty_gif`) and then do the actual recording in background. The [post_action](http://wiki.nginx.org/HttpCoreModule#post_action) that allows you to define a sub-request that will be fired upon completion of the current request are [perfect solution](http://mailman.nginx.org/pipermail/nginx/2008-April/004524.html) for these use cases.\r\n```nginx\r\nlocation = /empty.gif {\r\n    empty_gif;\r\n    expires -1;\r\n    post_action @track; \r\n}\r\n\r\nlocation @track {\r\n    internal;\r\n    proxy_pass http://tracking-backend;\r\n}\r\n```\r\n\r\n### Enable Cross Origin Resource Sharing\r\nSimple, wide-open configuration to allow cross-domain requests to your server.\r\n```nginx\r\nlocation ~* \\.(eot|ttf|woff) {\r\n    add_header Access-Control-Allow-Origin *;\r\n}\r\n```\r\n\r\n\r\n## Links\r\nSome other awesome resources for configuring Nginx:\r\n\r\n- [Nginx Official Guide](http://nginx.com/resources/admin-guide/)\r\n- [HTML 5 Boilerplate's Sample Nginx Configuration](https://github.com/h5bp/server-configs-nginx)\r\n- [Nginx Pitfalls](http://wiki.nginx.org/Pitfalls)"},cb0c:function(n,r,e){"use strict";e.r(r),r["default"]="# ***\\*深入理解RCU|核心原理\\****\r\n\r\nOriginal Alex码农的艺术 [极客重生](https://mp.weixin.qq.com/javascript:void(0);) 6/24\r\n\r\n收录于话题\r\n\r\n\\#深入理解Linux系统22个内容\r\n\r\n\\#原创文章34个内容\r\n\r\n\\#核心突破系列13个内容\r\n\r\nhi，大家好，今天给大家分享并行程序设计中最重要的锁-**RCU锁**，RCU锁本质是用空间换时间，是对读写锁的一种优化加强，但不仅仅是这样简单，RCU体现出来的**垃圾回收思想**，也是值得我们学习和借鉴，各个语言C, C++,Java, go等都有RCU锁实现，同时内核精巧的实现也是学习代码设计好素材，深入理解RCU分为两个部分，第一部分主要是讲**核心原理**，理解其核心设计思想，对RCU会有个宏观的理解；第二部分会分析**源码实现**（本来准备放在一起，由于实现相当精巧，篇幅会很多，就单独成一篇），希望大家喜欢。\r\n\r\n \r\n\r\n \r\n\r\n![img](6.深入理解RCU核心原理.assets/wps489E.tmp.png) \r\n\r\n### 并行程序设计演进\r\n\r\n**如何正确有效的保护共享数据**是编写并行程序必须面临的一个难题，通常的手段就是同步。同步可分为**阻塞型同步**（Blocking Synchronization）和**非阻塞型同步**（ Non-blocking Synchronization）。\r\n\r\n \r\n\r\n**阻塞型同步**是指当一个线程到达临界区时，因另外一个线程已经持有访问该共享数据的锁，从而不能获取锁资源而阻塞（睡眠），直到另外一个线程释放锁。常见的同步原语有 mutex、semaphore 等。如果同步方案采用不当，就会造成死锁（deadlock），活锁（livelock）和优先级反转（priority inversion），以及效率低下等现象。\r\n\r\n \r\n\r\n为了降低风险程度和提高程序运行效率，业界提出了不采用锁的同步方案，依照这种设计思路设计的算法称为**非阻塞型同步**，其本质就是停止一个线程的执行不会阻碍系统中其他执行实体的运行。\r\n\r\n \r\n\r\n## ***\\*先有阻塞型同步\\****\r\n\r\n \r\n\r\n**互斥锁**（英語：Mutual exclusion，缩写**Mutex**）是一种用于多线程编程中，防止两条线程同时对同一公共资源进行读写的机制。该目的通过将代码切片成一个一个的临界区域（critical section）达成。临界区域指的是一块对公共资源进行存取的代码。\r\n\r\n \r\n\r\n**信号量**(Semaphore)，是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用，可以认为mutex是0-1信号量；\r\n\r\n \r\n\r\n**读写锁**是计算机程序的并发控制的一种同步机制，它把对共享资源的访问者划分成读者和**写**者，读者只对共享资源进行**读**访问，**写**者则需要对共享资源进行**写**操作，读操作可并发重入，写操作是互斥的。\r\n\r\n## ***\\*再有非阻塞型同步\\****\r\n\r\n当今比较流行的非阻塞型同步实现方案有三种：\r\n\r\n\\1. \r\n\r\n**Wait-free（****无等待****）**\r\n\r\n\\2. \r\n\r\n**Wait-free** 是指任意线程的任何操作都可以在有限步之内结束，而不用关心其它线程的执行速度。Wait-free 是基于 per-thread 的，可以认为是 starvation-free 的。非常遗憾的是实际情况并非如此，采用 Wait-free 的程序并不能保证 starvation-free，同时内存消耗也随线程数量而线性增长。目前只有极少数的非阻塞算法实现了这一点。\r\n\r\n\\3. \r\n\r\n**简单理解**：任意时刻所有的线程都在干活；\r\n\r\n\\4. \r\n\r\n\\5. \r\n\r\n**Lock-free（无锁）**\r\n\r\n\\6. \r\n\r\n**Lock-Free**是指能够确保执行它的所有线程中至少有一个能够继续往下执行。由于每个线程不是 starvation-free 的，即有些线程可能会被任意地延迟，然而在每一步都至少有一个线程能够往下执行，因此系统作为一个整体是在持续执行的，可以认为是 system-wide 的。所有 Wait-free 的算法都是 Lock-Free 的。\r\n\r\n\\7. \r\n\r\n**简单理解：**任意时刻至少一个线程在干活；\r\n\r\n\\8. \r\n\r\n\\9. \r\n\r\n**Obstruction-free（****无障碍****）**\r\n\r\n\\10. \r\n\r\nObstruction-free 是指在任何时间点，一个孤立运行线程的每一个操作可以在有限步之内结束。只要没有竞争，线程就可以持续运行。一旦共享数据被修改，Obstruction-free 要求中止已经完成的部分操作，并进行回滚。所有 Lock-Free 的算法都是 Obstruction-free 的。\r\n\r\n\\11. \r\n\r\n**简单理解：**只要数据有修改，就会重新获取，并且把已经完成操作回滚重来；\r\n\r\n\\12. \r\n\r\n \r\n\r\n\\13. \r\n\r\n综上所述，不难得出 Obstruction-free 是 Non-blocking synchronization 中性能最差的，而 Wait-free 性能是最好的，但实现难度也是最大的，因此 Lock-free 算法开始被重视，并广泛运用于各种程序设计中，这里主要介绍**Lock_free算法**。\r\n\r\n \r\n\r\n**lock-free（无锁）**往往可以提供更好的性能和伸缩性保证，但实际上其优点不止于此。早期这些概念首先是在操作系统上应用的，因为一个不依赖于锁的算法，可以应用于各种场景下，而无需考虑各种错误，故障，失败等情形。比如死锁，中断，甚至CPU失效。\r\n\r\n \r\n\r\n**主流无锁****技术**\r\n\r\n \r\n\r\n**Atomic operation（原子操作），**在单一、不间断的步骤中读取和更改数据的操作。需要处理器指令支持原子操作：\r\n\r\n● test-and-set (TSR)\r\n\r\n● compare-and-swap (CAS)\r\n\r\n● load-link/store-conditional (ll/sc)\r\n\r\n \r\n\r\n \r\n\r\n**Spin Lock（自旋锁）**是一种轻量级的同步方法，一种非阻塞锁。当 lock 操作被阻塞时，并不是把自己挂到一个等待队列，而是死循环 CPU 空转等待其他线程释放锁。\r\n\r\n![img](6.深入理解RCU核心原理.assets/wps48AE.tmp.png) \r\n\r\n \r\n\r\n \r\n\r\n**Seqlock (顺序锁)** 是Linux 2.6 内核中引入一种新型锁，它与 spin lock 读写锁非常相似，只是它为写者赋予了较高的优先级。也就是说，即使读者正在读的时候也允许写者继续运行，读者会检查数据是否有更新，如果数据有更新就会重试，因为 seqlock 对写者更有利，只要没有其他写者，写锁总能获取成功。\r\n\r\n![img](6.深入理解RCU核心原理.assets/wps48AF.tmp.png) \r\n\r\n \r\n\r\n \r\n\r\n**RCU(Read-Copy Update)，**顾名思义就是读-拷贝修改，它是基于其原理命名的。对于被RCU保护的共享数据结构，读者不需要获得任何锁就可以访问它，但写者在访问它时首先拷贝一个副本，然后对副本进行修改，最后使用一个回调（callback）机制在适当的时机把指向原来数据的指针替换为新的被修改的数据。这个时机就是所有引用该数据的CPU都退出对共享数据的访问。\r\n\r\n \r\n\r\n本文主要讲解**RCU的核心原理****。**\r\n\r\n### 历史背景\r\n\r\n**高性能并行程序**中，数据一致性访问是一个非常重要的部分，一般都是采用锁机制（semaphore、spinlock、rwlock等）进行保护共享数据，根本的思想就是在访问临界资源时，首先访问一个全局的变量（锁），通过全局变量的状态来控制线程对临界资源的访问。但是，这种思想是需要硬件支持的，硬件需要配合实现全局变量（锁）的读-修改-写，现代CPU都会提供这样的原子化指令。\r\n\r\n \r\n\r\n采用锁机制实现数据访问的一致性存在如下两个问题：\r\n\r\n· \r\n\r\n**效率问题**。锁机制的实现需要对内存的原子化访问，这种访问操作会破坏流水线操作，降低了流水线效率，这是影响性能的一个因素。另外，在采用读写锁机制的情况下，写锁是排他锁，无法实现写锁与读锁的并发操作，在某些应用下会降低性能。\r\n\r\n· \r\n\r\n· \r\n\r\n**扩展性问题**。例如，当系统中CPU数量增多的时候，采用锁机制实现数据的同步访问效率偏低。并且随着CPU数量的增多，效率降低，由此可见锁机制实现的数据一致性访问扩展性差。\r\n\r\n· \r\n\r\n \r\n\r\n· \r\n\r\n \r\n\r\n**原始的RCU思想**\r\n\r\n \r\n\r\n在多线程场景下，经常我们需要并发访问一个数据结构，为了保证线程安全我们会考虑使用互斥设施来进行同步，更进一步我们会根据对这个数据结构的读写比例而选用读写锁进行优化。但是读写锁不是唯一的方式，我们可以借助于COW技术来做到写操作不需要加锁，也就是在读的时候正常读，写的时候，先加锁拷贝一份，然后进行写，写完就原子的更新回去，使用COW实现避免了频繁加读写锁本身的性能开销。\r\n\r\n \r\n\r\n**优缺点**\r\n\r\n由于 RCU 旨在最小化读取端开销，因此仅在以更高速率使用同步逻辑进行读取操作时才使用它。如果更新操作超过10%，性能反而会变差，所以应该选择另一种同步方式而不是RCU。\r\n\r\n· \r\n\r\n好处\r\n\r\n· \r\n\r\n§ \r\n\r\n几乎没有读取端开销。零等待，零开销\r\n\r\n§ \r\n\r\n§ \r\n\r\n没有死锁问题\r\n\r\n§ \r\n\r\n§ \r\n\r\n没有优先级倒置问题（优先级倒置和优先级继承）\r\n\r\n§ \r\n\r\n§ \r\n\r\n无限制延迟没有问题\r\n\r\n§ \r\n\r\n§ \r\n\r\n无内存泄漏风险问题\r\n\r\n§ \r\n\r\n· \r\n\r\n缺点\r\n\r\n· \r\n\r\n§ \r\n\r\n使用起来有点复杂\r\n\r\n§ \r\n\r\n§ \r\n\r\n对于写操作，它比其他同步技术稍慢\r\n\r\n§ \r\n\r\n· \r\n\r\n适用场景\r\n\r\n· \r\n\r\n![img](6.深入理解RCU核心原理.assets/wps48B0.tmp.png) \r\n\r\n### 核心原理\r\n\r\n**理论基础-QSBR算法**\r\n\r\n**(Quiescent State-Based Reclamation)**\r\n\r\n \r\n\r\n这个算法的核心思想就是识别出线程的不活动(quiescent)状态，那么什么时候才算是不活动的状态呢？这个状态和临界区状态是相对的，线程离开临界区就是不活动的状态了。识别出不活动状态了，还需要把状态通知出去，让其他线程知道，这整个过程可以用下面的图来描述:\r\n\r\n \r\n\r\n![img](6.深入理解RCU核心原理.assets/wps48B1.tmp.jpg) \r\n\r\n \r\n\r\n上面有四个线程，线程1执行完更新操作后添加了释放内存的callback，此时线程2,3,4都读取的是之前的内容，等他们执行完成后分别回去调用onQuiescentState来表明自己已经不不活动了，等到最后一个线程调用onQuiescentState的时候就可以去调用注册的callback了。要实现上面这个过程其要点就是选择适合的位置执行onQuiescentState，还有就是如何知道谁是最后一个执行onQuiescentState的线程。\r\n\r\n \r\n\r\n \r\n\r\n![img](6.深入理解RCU核心原理.assets/wps48B2.tmp.png) \r\n\r\n \r\n\r\n**批量回收**，如果更新的次数比较多的话，但是每次只回调一个callback，释放一次内存就会导致内存释放跟不上回收的速度，为此需要进行批量回收，每次更新都会注册新的callback，当第一次所有的线程都进入不活动状态的时候就把当前的所有callback保存起来，等待下一次所有线程进入不活动的状态的时候就回调前一次所有的callback。\r\n\r\n \r\n\r\n \r\n\r\n**基本架构**\r\n\r\n \r\n\r\nLinux 内核RCU 参考**QSBR算法**设计一套无锁同步机制。\r\n\r\n \r\n\r\n \r\n\r\n![img](6.深入理解RCU核心原理.assets/wps48B3.tmp.png) \r\n\r\n \r\n\r\n· \r\n\r\n多个读者可以并发访问共享数据，而不需要加锁；\r\n\r\n· \r\n\r\n· \r\n\r\n写者更新共享数据时候，需要先copy副本，在副本上修改，最终，读者只访问原始数据，因此他们可以安全地访问数据，多个写者之间是需要用锁互斥访问的（比如用自旋锁）；\r\n\r\n· \r\n\r\n· \r\n\r\n修改资源后，需要更新共享资源，让后面读者可以访问最新的数据；\r\n\r\n· \r\n\r\n· \r\n\r\n等旧资源上所有的读者都访问完毕后，就可以回收旧资源了；\r\n\r\n· \r\n\r\n \r\n\r\n**RCU 模型**\r\n\r\n \r\n\r\n![img](6.深入理解RCU核心原理.assets/wps48B4.tmp.png) \r\n\r\n· \r\n\r\n**Removal**：在写端临界区部分，读取（Read()），进行复制（Copy），并执行更改（Update）操作；\r\n\r\n· \r\n\r\n \r\n\r\n· \r\n\r\n**Grace Period**：这是一个等待期，以确保所有与执行删除的数据相关的reader访问完毕；\r\n\r\n· \r\n\r\n \r\n\r\n· \r\n\r\n· \r\n\r\n**Reclamation**：回收旧数据；\r\n\r\n· \r\n\r\n \r\n\r\n \r\n\r\n**三个重要概念**\r\n\r\n \r\n\r\n**静止状态QS(Quiescent State):** CPU发生了上下文切换称为经历一个quiescent state；\r\n\r\n \r\n\r\n![img](6.深入理解RCU核心原理.assets/wps48B5.tmp.png) \r\n\r\n \r\n\r\n**宽限期GP(Grace Period):** grace period就是所有CPU都经历一次quiescent state所需要的等待的时间，也即系统中所有的读者完成对共享临界区的访问；\r\n\r\n \r\n\r\n![img](6.深入理解RCU核心原理.assets/wps48B6.tmp.png) \r\n\r\n**GP原理**\r\n\r\n \r\n\r\n**读侧临界部分RCS(Read-Side Critical Section):** 保护禁止其他CPU修改的代码区域，但允许多个CPU同时读；\r\n\r\n![img](6.深入理解RCU核心原理.assets/wps48C7.tmp.png) \r\n\r\n \r\n\r\n \r\n\r\n**三个主要的角色**\r\n\r\n![img](6.深入理解RCU核心原理.assets/wps48C8.tmp.png) \r\n\r\n**读者reader**：\r\n\r\n· \r\n\r\n安全访问临界区资源；\r\n\r\n· \r\n\r\n· \r\n\r\n负责标识进出临界区；\r\n\r\n· \r\n\r\n**写者updater**：\r\n\r\n· \r\n\r\n复制一份数据，然后更新数据；\r\n\r\n· \r\n\r\n· \r\n\r\n用新数据覆盖旧数据，然后进入grace period；\r\n\r\n· \r\n\r\n**回收者reclaimer**：\r\n\r\n· \r\n\r\n等待在grace period之前的读者退出临界区；\r\n\r\n· \r\n\r\n· \r\n\r\n在宽限期结束后，负责回收旧资源；\r\n\r\n· \r\n\r\n \r\n\r\n**三个重要机制**\r\n\r\n \r\n\r\n**发布/订阅机制**\r\n\r\n· \r\n\r\n主要用于更新数据，即使在数据被同时修改时线程也能安全浏览数据。RCU通过发布-订阅机制（Publish-Subscribe Mechanism）实现这种并发的插入操作能力；\r\n\r\n· \r\n\r\n \r\n\r\n· \r\n\r\n**延迟回收机制**：\r\n\r\n· \r\n\r\n实现检查旧数据上所有RCU读者完成，用于安全删除旧数据；\r\n\r\n· \r\n\r\n \r\n\r\n**多版本机制**：\r\n\r\n· \r\n\r\n维护最近更新对象的多个版本，用于允许读者容忍并发的插入和删除新对象的多个版本；\r\n\r\n· \r\n\r\n \r\n\r\n \r\n\r\n![img](6.深入理解RCU核心原理.assets/wps48C9.tmp.jpg) \r\n\r\n###  \r\n\r\n### 最后总结\r\n\r\n最后，总结一下**RCU锁的核心思想**：\r\n\r\n· \r\n\r\n读者无锁访问数据，标记进出临界区；\r\n\r\n· \r\n\r\n· \r\n\r\n写者读取，复制，更新；\r\n\r\n· \r\n\r\n· \r\n\r\n旧数据延迟回收；\r\n\r\n· \r\n\r\n \r\n\r\n· \r\n\r\nRCU核心思想就三句话，产品经理都说简单，但Linux内核实现却不是这么简单。除了要实现基本功能，需要考虑很多复杂情况：\r\n\r\n \r\n\r\n![img](6.深入理解RCU核心原理.assets/wps48CA.tmp.png) \r\n\r\n###  \r\n\r\n### ***\\*内核的\\******RCU系统*****\\*可以说是\\******内核最复杂系统*****\\*之一，为了高性能和多核扩展性，设计了非常精巧的数据结构：\\****\r\n\r\n \r\n\r\n![img](6.深入理解RCU核心原理.assets/wps48CB.tmp.png) \r\n\r\n \r\n\r\n \r\n\r\n同时巧妙实现了很多核心流程：\r\n\r\n· \r\n\r\n检查当前CPU是否度过QS；\r\n\r\n· \r\n\r\n· \r\n\r\nQS report(汇报宽限期度过)；\r\n\r\n· \r\n\r\n· \r\n\r\n宽限期的发起与完成；\r\n\r\n· \r\n\r\n· \r\n\r\nrcu callbacks处理；\r\n\r\n· \r\n\r\n \r\n\r\n其中很多实现都可以说是非常精巧，结合了预处理，批量处理，延后（异步）处理，多核并发，原子操作，异常处理，多场景精细优化等多种技术，性能好，可扩展性强，稳定性强，有一定的学习和参考价值，即使你的工作不是内核编程，里面体现很多编程思想和代码设计思想，也是值得大家学习的。\r\n\r\n \r\n\r\n预知后事如何，且听下回分解，下次会带大家领悟RCU源码实现的美妙。\r\n\r\n### 扩展阅读\r\n\r\nhttp://csng.cs.toronto.edu/publication_files/0000/0159/jpdc07.pdf\r\n\r\nhttp://www.rdrop.com/users/paulmck/rclock/RCUdissertation.2004.07.14e1.pdf\r\n\r\nhttps://lwn.net/Articles/262464/\r\n\r\nhttp://www.wowotech.net/kernel_synchronization/461.html\r\n\r\nhttp://concurrencyfreaks.blogspot.com/2013/05/lock-free-and-wait-free-definition-and.html\r\n\r\n \r\n\r\n\\- END -\r\n\r\n\r\n\r\n "},ce01:function(n,r,e){"use strict";e.r(r),r["default"]="# ***\\*Linux调度系统全景指南(下篇)\\****\r\n\r\n \r\n\r\n \r\n\r\n| 导语本文主要是讲Linux的调度系统, 由于全部内容太多，分三部分来讲，本篇是下篇（主要线程和进程），上篇请看（CPU和中断）：[Linux调度系统全景指南(上篇)](#wechat_redirect)，调度可以说是操作系统的灵魂，为了让CPU资源利用最大化，Linux设计了一套非常精细的调度系统，对大多数场景都进行了很多优化，系统扩展性强，我们可以根据业务模型和业务场景的特点，有针对性的去进行性能优化，在保证客户网络带宽前提下，隔离客户互相之间的干扰影响，提高CPU利用率，降低单位运算成本，提高市场竞争力。欢迎大家相互交流学习！\r\n\r\n \r\n\r\n​               **目录**\r\n\r\n![img](11.Linux调度系统全景指南(下篇) .assets/wps384A.tmp.png) \r\n\r\n \r\n\r\n![img](11.Linux调度系统全景指南(下篇) .assets/wps384B.tmp.png) \r\n\r\n \r\n\r\n上篇请看（CPU和中断）：[Linux调度系统全景指南(上篇)](#wechat_redirect)\r\n\r\n中篇请看（抢占和时钟）：[Linux调度系统全景指南(中篇)](#wechat_redirect)  \r\n\r\n​             \r\n\r\n​                  **进程**\r\n\r\n![img](11.Linux调度系统全景指南(下篇) .assets/wps384C.tmp.jpg) \r\n\r\n \r\n\r\n \r\n\r\n 一般定义是操作系统对一个正在运行的程序的一种抽象， 是运行资源的管理单位（虚拟内存空间，文件句柄，全局变量，信号等运行资源），是操作系统资源分配的最小单位。在linux系统下，无论是进程，还是线程，到了内核里面，我们统一都叫任务（Task），由一个统一的结构 task_struct 进行管理：\r\n\r\n \r\n\r\n![img](11.Linux调度系统全景指南(下篇) .assets/wps384D.tmp.jpg) \r\n\r\n \r\n\r\n详细结构：\r\n\r\n![img](11.Linux调度系统全景指南(下篇) .assets/wps384E.tmp.png) \r\n\r\n \r\n\r\n大体分为下面几类：\r\n\r\n![img](11.Linux调度系统全景指南(下篇) .assets/wps384F.tmp.png) \r\n\r\n \r\n\r\n### **进程运行空间**\r\n\r\nLinux 按照特权等级，把进程的运行空间分为内核空间和用户空间，分别对应着下图中， CPU 特权等级的 Ring 0 和 Ring 3。\r\n\r\n \r\n\r\n![img](11.Linux调度系统全景指南(下篇) .assets/wps3850.tmp.png) \r\n\r\n \r\n\r\n![img](11.Linux调度系统全景指南(下篇) .assets/wps3851.tmp.png) \r\n\r\n \r\n\r\n· \r\n\r\n内核空间（Ring 0）具有最高权限，可以直接访问所有资源；\r\n\r\n· \r\n\r\n· \r\n\r\n用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源；\r\n\r\n· \r\n\r\n· \r\n\r\n进程既可以在用户空间运行，又可以在内核空间中运行。进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。\r\n\r\n· \r\n\r\n· \r\n\r\n## **进程内存空间（****x86_64）**\r\n\r\n \r\n\r\n![img](11.Linux调度系统全景指南(下篇) .assets/wps3852.tmp.png) \r\n\r\n各个分区的意义：\r\n\r\n \r\n\r\n**内核空间：**\r\n\r\n在32位系统中，Linux会留1G空间给内核，用户进程是无法访问的，用来存放进程相关数据和内存数据，内核代码等；在64位系统里面，Linux会采用最低48位来表示虚拟内存，这可通过 /proc/cpuinfo 来查看address sizes :\r\n\r\naddress sizes :\r\n\r\n36 bits physical, 48 bits virtual，总的虚拟地址空间为256TB( 2^48 )，在这256TB的虚拟内存空间中, 0000000000000000 - 00007fffffffffff(128TB)为用户空间，ffff800000000000 - ffffffffffffffff(128TB)为内核空间, 剩下的是用户内存空间：\r\n\r\n**stack栈区：**\r\n\r\n专门用来实现函数调用-栈结构的内存块。相对空间下（可以设置大小，Linux 一般默认是8M，可通过 ulimit –s 查看），系统自动管理，从高地址往低地址，向下生长。\r\n\r\n**内存映射区：**\r\n\r\n包括文件映射和匿名内存映射， 应用程序的所依赖的动态库，会在程序执行时候，加载到内存这个区域，一般包括数据（data）和代码（text）;通过mmap系统调用，可以把特定的文件映射到内存中，然后在相应的内存区域中操作字节来访问文件内容，实现更高效的IO操作；匿名映射，在glibc中malloc分配大内存的时候会用到匿名映射。这里所谓的“大”表示是超过了MMAP_THRESHOLD 设置的字节数，它的缺省值是 128 kB，可以通过 mallopt() 去调整这个设置值。还可以用于进程间通信IPC（共享内存）。\r\n\r\n**heap堆区：**\r\n\r\n主要用于用户动态内存分配，空间大，使用灵活，但需要用户自己管理，通过brk系统调用控制堆的生长，向高地址生长。\r\n\r\n**BBS段和DATA段：**\r\n\r\n用于存放程序全局数据和静态数据，一般未初始化的放在BSS段（统一初始化为0，不占程序文件的空间），初始化的放在data段，只读数据放在rodata段（常量存储区）。\r\n\r\n**text段：**\r\n\r\n主要存放程序二进制代码。\r\n\r\n \r\n\r\n## **进程调度**\r\n\r\n \r\n\r\n### **进程状态机**\r\n\r\n进程是一个动态的概念，是应用程序当前正在运行的一个实例, 在进程的整个生命周期中，它会处于不同的状态，并且在不同状态之间转化：\r\n\r\n \r\n\r\n![img](11.Linux调度系统全景指南(下篇) .assets/wps3853.tmp.png) \r\n\r\n \r\n\r\n**R (TASK_RUNNING)--执行状态**\r\n\r\n只有在该状态的进程才可能在CPU上运行。而同一时刻可能有多个进程处于可执行状态，这些进程的task_struct结构（进程控制块）被放入对 应CPU的可执行队列中（一个task最多只能出现在一个CPU的可执行队列中）。进程调度器的任务就是从各个CPU的可执行队列中分别选择一个task在该 CPU上运行。很多操作系统教科书将正在CPU上执行的进程定义为RUNNING状态，而将可执行但是尚未被调度执行的进程定义为READY状态，这两种状态在linux下统一为 TASK_RUNNING状态。\r\n\r\n \r\n\r\n**S (TASK_INTERRUPTIBLE)--可中断的睡眠状态**\r\n\r\n处于这个状态的进程因为等待某个事件的发生（比如等待socket连接、等待信号量，等待锁），而被挂起。这些进程的task_struct结构被放入对应事件的等待队列中。当这些事件发生时（由外部中断触发、或由其他进程触发），对应的等待队列中的一个或多个进程将被唤醒。通过ps命令我们会看到，一般情况下，进程列表中的绝大多数进程都处于TASK_INTERRUPTIBLE状态（除非机器的负载很高）。毕竟CPU就一两个，进程动辄几十上百个，如果不是绝大多数进程都在睡眠，CPU又怎么响应得过来。\r\n\r\n \r\n\r\n**T (TASK_STOPPED or TASK_TRACED)--暂停状态或跟踪状态**\r\n\r\n向进程发送一个SIGSTOP信号，它就会因响应该信号而进入TASK_STOPPED状态（除非该进程本身处于TASK_UNINTERRUPTIBLE状态而不响应信号）。（SIGSTOP与SIGKILL信号一样，是非常强制的。不允许用户进程通过signal系列的系统调用重新设置对应的信号处理函数。）向进程发送一个SIGCONT信号，可以让其从TASK_STOPPED状态恢复到TASK_RUNNING状态。\r\n\r\n \r\n\r\n**Z (TASK_DEAD - EXIT_ZOMBIE)--退出状态**\r\n\r\n进程成为僵尸进程。当父进程遗漏了用wait()函数等待已终止的子进程时，子进程就会进入一种无父进程的状态，此时子进程就是僵尸进程。\r\n\r\n \r\n\r\n**D (TASK_UNINTERRUPTIBLE)--不可中断的睡眠状态**\r\n\r\nTASK_INTERRUPTIBLE状态类似，进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号。绝大多数情况下，进程处在睡眠状态时，总是应该能够响应异步信号的。否则你将惊奇的发现，kill -9竟然杀不死一个正在睡眠的进程了！于是我们也很好理解，为什么ps命令看到的进程几乎不会出现TASK_UNINTERRUPTIBLE状态，而总是 TASK_INTERRUPTIBLE状态。而TASK_UNINTERRUPTIBLE状态存在的意义就在于，内核的某些处理流程是不能被打断的。如果响应异步信号，程序的执行流程中就会被插入一段用于处理异步信号的流程（这个插入的流程可能只存在于内核态，也可能延伸到用户态），于是原有的流程就被中断了。\r\n\r\n \r\n\r\n### **进程上下文切换**\r\n\r\n上下文切换(有时也称做进程切换或任务切换)：是指CPU从一个进程或线程切换到另一个进程或线程。简洁描述一下，上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行以下的活动：\r\n\r\n\\1. \r\n\r\n挂起一个进程，将这个进程在CPU 中的状态（上下文）存储于内存中的某处；\r\n\r\n\\2. \r\n\r\n\\3. \r\n\r\n在内存中检索下一个进程的上下文并将其在CPU 的寄存器中恢复；\r\n\r\n\\4. \r\n\r\n\\5. \r\n\r\n跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程。\r\n\r\n\\6. \r\n\r\n因此上下文是指某一时间点CPU寄存器和程序计数器的内容，广义上还包括内存中进程的虚拟地址映射信息。上下文切换只能发生在内核态中，上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的CPU时间，事实上，可能是操作系统中时间消耗最大的操作。Linux相比与其他操作系统（包括其他类Unix系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。\r\n\r\n \r\n\r\n### **进程优先级**\r\n\r\n\\1. \r\n\r\n进程的优先级有动态优先级和静态优先级决定;\r\n\r\n\\2. \r\n\r\n\\3. \r\n\r\n它是决定进程在CPU的执行顺序的数字;\r\n\r\n\\4. \r\n\r\n\\5. \r\n\r\n优先级越高被CPU执行的概率越大;\r\n\r\n\\6. \r\n\r\n\\7. \r\n\r\n内核采用启发式算法决定是开启或者关闭动态优先级，可以通过修改nice级别直接修改进程的静态优先级，而获取更多CPU执行时间;\r\n\r\n\\8. \r\n\r\n\\9. \r\n\r\nLinux支持的nice级别从19（最低优先级）到-20（最高优先级），默认只是0。只有root身份的用户才能把进程的nice级别调整为负数（让其具备较高优先级）。\r\n\r\n\\10. \r\n\r\n\\11. \r\n\r\n### **时间片**\r\n\r\n· \r\n\r\n时间片（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”是分时操作系统分配给每个正在运行的进程微观上的一段CPU时间（在抢占内核中是：从进程开始运行直到被抢占的时间）；\r\n\r\n· \r\n\r\n· \r\n\r\n时间片由操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复；\r\n\r\n· \r\n\r\n· \r\n\r\n时间片设得太短会导致过多的进程切换，降低了CPU效率；而设得太长又可能引起对短的交互请求的响应变差，不同调度算法，对时间片管理不一样；\r\n\r\n· \r\n\r\n· \r\n\r\n通常状况下，一个系统中所有的进程被分配到的时间片长短并不是相等的，尽管初始时间片基本相等（在Linux系统中，初始时间片也不相等，而是各自父进程的一半），系统通过测量进程处于“睡眠”和“正在运行”状态的时间长短来计算每个进程的交互性，交互性和每个进程预设的静态优先级（Nice值）的叠加即是动态优先级，动态优先级按比例缩放就是要分配给那个进程时间片的长短。一般地，为了获得较快的响应速度，交互性强的进程（即趋向于IO消耗型）被分配到的时间片要长于交互性弱的（趋向于处理器消耗型）进程。\r\n\r\n· \r\n\r\n \r\n\r\n· \r\n\r\n### **调度框架**\r\n\r\n实际上进程是资源管理的单位，线程才是调度的单位，内核统称为任务调度。操作系统最重要的任务就是把系统中的task调度到各个CPU上去执行， 不同的任务有不同的需求，因此我们需要对任务进行分类：一种是普通进程，另外一种是实时进程。对于实时进程，毫无疑问快速响应的需求是最重要的，而对于普通进程，我们需要兼顾前三点的需求。相信你也发现了，这些需求是互相冲突的，对于这些time-sharing的普通进程如何平衡设计呢？这里需要进一步将普通进程细分为交互式进程（interactive processs）和批处理进程（batch process）。交互式进程需要和用户进行交流，因此对调度延迟比较敏感，而批处理进程属于那种在后台默默干活的，因此它更注重throughput的需求。当然，无论如何，分享时间片的普通进程还是需要兼顾公平，不能有人大鱼大肉，有人连汤都喝不上。为了达到这些设计目标，调度器必须要考虑某些调度因素，比如说“优先级”、“时间片”等。在Linux内核中，优先级就是实时进程调度的主要考虑因素。而对于普通进程，如何细分时间片则是调度器的核心思考点。过大的时间片会严重损伤系统的响应延迟，让用户明显能够感知到延迟，卡顿，从而影响用户体验。较小的时间片虽然有助于减少调度延迟，但是频繁的切换对系统的throughput会造成严重的影响。因为这时候大部分的CPU时间用于进程切换，而忘记了它本来的功能其实就是推动任务的执行。由于Linux是一个通用操作系统，它的目标是星辰大海，既能运行在嵌入式平台上，又能在服务器领域中获得很好的性能表现，此外在桌面应用场景中，也不能让用户有较差的用户体验。Linux任务调度算法核心就是解决调度优化问题：\r\n\r\n \r\n\r\n（1）公平：对于time-sharing的进程，保证每个进程得到合理的CPU时间。\r\n\r\n（2）高效：使CPU保持忙碌状态，即总是有进程在CPU上运行。\r\n\r\n（3）响应时间：使交互用户的响应时间尽可能短。\r\n\r\n（4）周转时间：使批处理用户等待输出的时间尽可能短。\r\n\r\n（5）吞吐量：使单位时间内处理的进程数量尽可能多。\r\n\r\n \r\n\r\nLinux调度器采用了模块化设计的思想，从而把进程调度的软件分成了两个层次，一个是core scheduler layer，另外一个是specific scheduler layer：\r\n\r\n​            \r\n\r\n![img](11.Linux调度系统全景指南(下篇) .assets/wps3863.tmp.png) \r\n\r\n \r\n\r\n从功能层面上看，进程调度仍然分成两个部分，第一个部分是通过负载均衡模块将各个runnable task根据负载情况平均分配到各个CPU runqueue上去。第二部分的功能是在各个CPU的Main scheduler和Tick scheduler的驱动下进行单个CPU上的调度。调度器处理的task各不相同，有RT task，有normal task，有Deal line task，但是无论哪一种task，它们都有共同的逻辑，这部分被抽象成Core scheduler layer，同时各种特定类型的调度器定义自己的sched_class，并以链表的形式加入到系统中。这样的模块化设计可以方便用户根据自己的场景定义specific scheduler，而不需要改动Core scheduler layer的逻辑。\r\n\r\n \r\n\r\n**2个调度器**\r\n\r\n可以用两种方法来激活调度：\r\n\r\n· \r\n\r\n主调度器 ：一种是直接的, 比如进程打算睡眠或出于其他原因放弃CPU；\r\n\r\n· \r\n\r\n· \r\n\r\n周期性调度器：通过周期性的机制, 以固定的频率运行, 不时的检测是否有必要。\r\n\r\n· \r\n\r\n· \r\n\r\n### **调度策略**\r\n\r\nlinux内核目前实现了6种调度策略(即调度算法)，用于对不同类型的进程进行调度， 或者支持某些特殊的功能：\r\n\r\n· \r\n\r\nSCHED_NORMAL和SCHED_BATCH调度普通的非实时进程；\r\n\r\n· \r\n\r\n· \r\n\r\nSCHED_FIFO和SCHED_RR和SCHED_DEADLINE则采用不同的调度策略调度实时进程；\r\n\r\n· \r\n\r\n· \r\n\r\nSCHED_IDLE则在系统空闲时调用idle进程；\r\n\r\n· \r\n\r\n· \r\n\r\nstop任务是系统中优先级最高的任务，它可以抢占所有的进程并且不会被任何进程抢占，其专属调度器类即stop-task；\r\n\r\n· \r\n\r\n· \r\n\r\nidle-task调度器类与CFS里要处理的SCHED_IDLE没有关系；\r\n\r\n· \r\n\r\n· \r\n\r\nidle任务会被任意进程抢占，其专属调度器类为idle-task；\r\n\r\n· \r\n\r\n· \r\n\r\nidle-task和stop-task没有对应的调度策略；\r\n\r\n· \r\n\r\n· \r\n\r\n采用SCHED_IDLE调度策略的任务其调度器类为 **CFS**。\r\n\r\n· \r\n\r\n· \r\n\r\n### **调度器类**\r\n\r\n· \r\n\r\nCFS (Completely_Fair_Scheduler)\r\n\r\n· \r\n\r\n· \r\n\r\nReal-Time Scheduler\r\n\r\n· \r\n\r\n· \r\n\r\nstop-task (sched_class_highest) Scheduler\r\n\r\n· \r\n\r\n· \r\n\r\nDeadline Scheduler: Earliest Deadline First (EDF) + Constant Bandwidth Server (CBS)\r\n\r\n· \r\n\r\n· \r\n\r\nIdle-task Scheduler\r\n\r\n· \r\n\r\n· \r\n\r\n### **调度类顺序**\r\n\r\n· \r\n\r\n优先级顺序：stop-task --\x3e deadline --\x3e real-time --\x3e fair --\x3e idle\r\n\r\n· \r\n\r\n· \r\n\r\n在各调度器类定义的时候通过next指针定义好了下一级调度器类；\r\n\r\n· \r\n\r\n· \r\n\r\nstop-task是通过宏#define sched_class_highest (&stop_sched_class)指定的；\r\n\r\n· \r\n\r\n· \r\n\r\n编译时期就已决定，不能动态扩展。\r\n\r\n· \r\n\r\n· \r\n\r\n### **调度实体**\r\n\r\n这种一般性要求调度器不直接操作进程，而是处理可调度实体， 因此需要一个通用的数据结构描述这个调度实体，即seched_entity结构， 其实际上就代表了一个调度对象，可以是一个进程，也可以是一个进程组，linux中针对当前可调度的实时和非实时进程，定义了类型为seched_entity的3个调度实体:\r\n\r\n· \r\n\r\nsched_dl_entity 采用EDF算法调度的实时调度实体；\r\n\r\n· \r\n\r\n· \r\n\r\nsched_rt_entity 采用Roound-Robin或者FIFO算法调度的实时调度实体；\r\n\r\n· \r\n\r\n· \r\n\r\nsched_entity 采用CFS算法调度的普通非实时进程的调度实体。\r\n\r\n· \r\n\r\n· \r\n\r\n### **调度类算法**\r\n\r\n \r\n\r\n**CFS（Completely Fair Scheduler）算法（完全公平调度器，对于普通进程）**\r\n\r\n· \r\n\r\n设定一个调度周期（sched_latency_ns），目标是让每个进程在这个周期内至少有机会运行一次。就是每个进程等待CPU的时间最长不超过这个调度周期；\r\n\r\n· \r\n\r\n· \r\n\r\n根据进程的数量，大家平分这个调度周期内的CPU使用权，由于进程的优先级即nice值不同，分割调度周期的时候要加权；\r\n\r\n· \r\n\r\n· \r\n\r\n每个进程的经过加权后的累计运行时间保存在自己的vruntime字段里；\r\n\r\n· \r\n\r\n· \r\n\r\n哪个进程的vruntime最小（红黑树pick_next）就获得本轮运行的权利。\r\n\r\n· \r\n\r\n \r\n\r\n**Realtime Scheduler（实时）**\r\n\r\n实时系统是这样的一种计算系统：当事件发生后，它必须在确定的时间范围内做出响应。在实时系统中，产生正确的结果不仅依赖于系统正确的逻辑动作，而且依赖于逻辑动作的时序。换句话说，当系统收到某个请求，会做出相应的动作以响应该请求，想要保证正确地响应该请求，一方面逻辑结果要正确，更重要的是需要在最后期限（deadline）内作出响应。如果系统未能在最后期限内进行响应，那么该系统就会产生错误或者缺陷。在多任务操作系统中（如Linux），实时调度器（realtime scheduler）负责协调实时任务对CPU的访问，以确保系统中所有的实时任务在其deadline内完成，为了满足实时任务的调度需求，Linux提供了两种实时调度器：POSIX realtime scheduler（后文简称RT调度）和deadline scheduler（后文简称DL调度器）。\r\n\r\n· \r\n\r\nLinux 支持SCHED_RR和SCHED_FIFO两种实时调度策略。\r\n\r\n· \r\n\r\n§ \r\n\r\n**先进先出（SCHED_FIFO）：** 没有时间片，被调度器选择后只要不被抢占，阻塞，或者自愿放弃处理器，可以运行任意长的时间。\r\n\r\n§ \r\n\r\n§ \r\n\r\n**轮转调度（SCHED_RR）：** 有时间片，其值在进程运行时会减少。时间片用完后，该值重置，进程置于队列末尾。\r\n\r\n§ \r\n\r\n· \r\n\r\n两种调度策略都是静态优先级，内核不为这两种实时进程计算动态优先级。\r\n\r\n· \r\n\r\n· \r\n\r\n这两种实现都属于 **软实时**。\r\n\r\n· \r\n\r\n· \r\n\r\n实时优先级的范围：**0 ~ MAX_RT_PRIO-1**\r\n\r\n· \r\n\r\n§ \r\n\r\nMAX_RT_PRIO默认值为 **100**\r\n\r\n§ \r\n\r\n§ \r\n\r\n故默认实时优先级范围：**0 ~ 99**。\r\n\r\n§ \r\n\r\n实时进程的优先级范围[0~99]都高于普通进程[100~139]，始终优先于普通进程得到运行，为了防止普通进程饥饿，Linux kernel有一个RealTime Throttling机制，就是为了防止CPU消耗型的实时进程霸占所有的CPU资源而造成整个系统失去控制。它的原理很简单，就是保证无论如何普通进程都能得到一定比例（默认5%）的CPU时间，可以通过两个内核参数来控制：\r\n\r\n· \r\n\r\n/proc/sys/kernel/sched_rt_period_us\r\n缺省值是1,000,000 μs (1秒)，表示实时进程的运行粒度为1秒。（注：修改这个参数请谨慎，太大或太小都可能带来问题）。\r\n\r\n· \r\n\r\n· \r\n\r\n/proc/sys/kernel/sched_rt_runtime_us\r\n缺省值是 950,000 μs (0.95秒)，表示在1秒的运行周期里所有的实时进程一起最多可以占用0.95秒的CPU时间。\r\n如果sched_rt_runtime_us=-1，表示取消限制，意味着实时进程可以占用100%的CPU时间（慎用，有可能使系统失去控制）。\r\n\r\n· \r\n\r\n \r\n\r\n· \r\n\r\n**Deadline Task Scheduling**\r\n\r\n· \r\n\r\nDL调度器是根据任务的deadline来确定调度的优先顺序的：deadline最早到来的那个任务最先调度执行。对于有M个处理器的系统，优先级最高的前M个deadline任务（即deadline最早到来的前M个任务）将被选择在对应M个处理器上运行。\r\n\r\n· \r\n\r\n· \r\n\r\nLinux DL调度器还实现了constant bandwidth server（CBS）算法，该算法是一种CPU资源预留协议。CBS可以保证每个任务在每个period内都能收到完整的runtime时间。在一个周期内，DL进程的“活”来的时候，CBS会重新补充该任务的运行时间。在处理“活”的时候，runtime时间会不断的消耗；如果runtime使用完毕，该任务会被DL调度器调度出局。在这种情况下，该任务无法再次占有CPU资源，只能等到下一次周期到来的时候，runtime重新补充之后才能运行。因此，CBS一方面可以用来保证每个任务的CPU时间按照其定义的runtime参数来分配，另外一方面，CBS也保证任务不会占有超过其runtime的CPU资源，从而防止了DL任务之间的互相影响。\r\n\r\n· \r\n\r\n· \r\n\r\n为了避免DL任务造成系统超负荷运行，DL调度器有一个准入机制，在任务配置好了period、runtime和deadline参数之后并准备加入到系统的时候，DL调度器会对该任务进行评估。这个准入机制保证了DL任务将不会使用超过系统的CPU时间的最大值。这个最大值在sched_rt_runtime_us和kernel.sched_rt_period_us sysctl参数中指定。默认值是950000和1000000，表示在1s的周期内，CPU用于执行实时任务（DL任务和RT任务）的最大时间值是950000µs。对于单个核心系统，这个测试既是必要的，也是充分的。这意味着：既然接受了该DL任务，那么CPU有信心可以保证其在截止日期之前能够分配给它需要的runtime长度的CPU时间。\r\n\r\n· \r\n\r\n· \r\n\r\ndeadline调度器是仅仅根据实时任务的时序约束进行调度的，从而保证实时任务正确的逻辑行为。虽然在多核系统中，全局deadline调度器会面临Dhall效应（把若干个任务分配给若干个处理器执行其实是一个NP-hard问题（本质上是一个装箱问题），由于各种异常场景，很难说一个调度算法会优于任何其他的算法），不过我们仍然可以对系统进行分区来解决这个问题。具体的做法是采用cpusets的方法把CPU利用率高的任务放置到指定的cpuset上。开发人员也可以受益于deadline调度器：他们可以通过设计其应用程序与DL调度器交互，从而简化任务的时序控制行为。\r\n\r\n· \r\n\r\n· \r\n\r\n在linux中，DL任务比实时任务（RR和FIFO）具有更高的优先级。这意味着即使是最高优先级的实时任务也会被DL任务延迟执行。因此，DL任务不需要考虑来自实时任务的干扰，但实时任务必须考虑DL任务的干扰。\r\n\r\n· \r\n\r\n· \r\n\r\n**Stop_Sched_Class**\r\n\r\nstop_sched_class用于停止CPU, 一般在SMP系统上使用， 用以实现负载平衡和CPU热插拔. 这个类有最高的调度优先级,stop调度器类实现了Unix的stop_machine 特性, stop_machine 是一个通信信号 : 在SMP的情况下相当于暂时停止其他的CPU的运行, 它让一个 CPU 继续运行，而让所有其他CPU空闲。在单CPU的情况下这个东西就相当于关中断。一般来说，内核会在如下情况下使用stop_machine技术:\r\n\r\n \r\n\r\n![img](11.Linux调度系统全景指南(下篇) .assets/wps3864.tmp.jpg) \r\n\r\n \r\n\r\n**Idle_Sched_Class**\r\n\r\nidle任务会被任意进程抢占，其专属调度器类为idle-task，当CPU没有任务空闲时，默认的idle实现是hlt指令，hlt指令使CPU处于暂停状态，等待硬件中断发生的时候恢复，从而达到节能的目的。即从处理器C0态变到 C1态(见 ACPI标准)，让CPU置为WFI（Wait for interrupt）低功耗状态，以节省功耗，多cpu系统中每个cpu一个idle进程。\r\n\r\n \r\n\r\n**组调度**\r\n\r\nlinux内核实现了control group功能（cgroup，since linux 2.6.24），可以支持将进程分组，然后按组来划分各种资源。比如：group-1拥有30%的CPU和50%的磁盘IO、group-2拥有10%的CPU和20%的磁盘IO、等等。cgroup支持很多种资源的划分，CPU资源就是其中之一，这就引出了组调度,\r\n\r\nlinux内核中，传统的调度程序是基于进程来调度的, 以进程为单位来瓜分CPU资源，如果我们想把进程进行分组，以进程组进行瓜分CPU资源，Linux实现了组调度架构来实现这个需求：\r\n\r\n \r\n\r\n![img](11.Linux调度系统全景指南(下篇) .assets/wps3865.tmp.jpg) \r\n\r\n​             Linux组调度实现架构\r\n\r\n \r\n\r\n· \r\n\r\n在linux内核中，使用task_group结构来管理组调度的组。所有存在的task_group组成一个树型结构（与cgroup的目录结构相对应），task_group可以包含具有任意调度类别的进程（具体来说是实时进程和普通进程两种类别），于是task_group需要为每一种调度策略提供一组调度结构。这里所说的一组调度结构主要包括两个部分，调度实体和运行队列（两者都是每CPU一份的）。调度实体会被添加到运行队列中，对于一个task_group，它的调度实体会被添加到其父task_group的运行队列，因为被调度的对象有task_group和task两种，所以需要一个抽象的结构来代表它们。如果调度实体代表task_group，则它的my_q字段指向这个调度组对应的运行队列；否则my_q字段为NULL，调度实体代表task。在调度实体中与my_q相对的是X_rq（具体是针对普通进程的cfs_rq和针对实时进程的rt_rq），前者指向这个组自己的运行队列，里面会放入它的子节点；后者指向这个组的父节点的运行队列，也就是这个调度实体应该被放入的运行队列；\r\n\r\n· \r\n\r\n· \r\n\r\n调度发生的时候，调度程序从根task_group的运行队列中选择一个调度实体。如果这个调度实体代表一个task_group，则调度程序需要从这个组对应的运行队列继续选择一个调度实体。如此递归下去，直到选中一个进程。除非根task_group的运行队列为空，否则递归下去一定能找到一个进程。因为如果一个task_group对应的运行队列为空，它对应的调度实体就不会被添加到其父节点对应的运行队列中；\r\n\r\n· \r\n\r\n \r\n\r\n· \r\n\r\n· \r\n\r\n**组的调度策略**\r\n\r\n \r\n\r\n组调度的主要针对rt（实时调度）和cfs（完全公平调度）两种类别：\r\n\r\n \r\n\r\n**实时进程的组调度**\r\n\r\n实时进程是对CPU有着实时性要求的进程，它的优先级是跟具体任务相关的，完全由用户来定义的。调度器总是会选择优先级最高的实时进程来运行，发展到组调度，组的优先级就被定义为“组内最高优先级的进程所拥有的优先级。\r\n\r\n \r\n\r\n**普通进程的组调度支持(Fair Group Scheduling)**\r\n\r\n2.6.23 引入的 CFS 调度器对所有进程完全公平对待。但是依然有个问题：设想当前机器有2个用户，有一个用户跑着9个进程，且都是CPU 密集型进程；另一个用户只跑着一个 X 进程，是交互性进程。从 CFS 的角度看，它将平等对待这 10 个进程，结果导致的是跑 X 进程的用户受到不公平对待，他只能得到约 10% 的 CPU 时间，让他的体验相当差。基于此，组调度的概念被引入[6]。CFS 处理的不再是一个进程的概念，而是调度实体(sched entity)，一个调度实体可以只包含一个进程，也可以包含多个进程。因此，上述例子的困境可以这么解决：分别为每个用户建立一个组，组里放该用户所有进程，从而保证用户间的公平性。该功能是基于控制组(control group, cgroup)的概念，需要内核开启 CGROUP 的支持才可使用。\r\n\r\n \r\n\r\n## **信号处理**\r\n\r\n信号机制是进程之间相互传递消息的一种方法，信号全称为软中断信号，也有人称作软中断。从它的命名可以看出，它的实质和使用很像中断。所以，信号可以说是进程控制的一部分:\r\n\r\n![img](11.Linux调度系统全景指南(下篇) .assets/wps3866.tmp.png) \r\n\r\n \r\n\r\n· \r\n\r\n软中断信号（signal，又简称为信号）用来通知进程发生了异步事件。进程之间可以互相通过系统调用kill发送软中断信号。内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。注意，信号只是用来通知某进程发生了什么事件，并不给该进程传递任何数据；\r\n\r\n· \r\n\r\n· \r\n\r\n当信号发送到某个进程中时，操作系统会中断该进程的正常流程，并进入相应的信号处理函数执行操作，完成后再回到中断的地方继续执行；\r\n\r\n· \r\n\r\n· \r\n\r\n信号分类处理,  第一种是类似中断的处理程序，对于需要处理的信号，进程可以指定处理函数，由该函数来处 理。第二种方法是，忽略某个信号，对该信号不做任何处理，就象未发生过一样。第三种方法是，对该信号的处理保留系统的默认值，这种缺省操作，对大部分的信 号的缺省操作是使得进程终止。进程通过系统调用signal来指定进程对某个信号的处理行为；\r\n\r\n· \r\n\r\n· \r\n\r\n在进程表的表项中有一个软中断信号域，该域中每一位对应一个信号，当有信号发送给进程时，对应位置位。由此可以看出，进程对不同的信号可以同时保留，但对于同一个信号，进程并不知道在处理之前来过多少个；\r\n\r\n· \r\n\r\n· \r\n\r\n \r\n\r\n· \r\n\r\n**信号分类：**\r\n\r\n（1） 与进程终止相关的信号。当进程退出，或者子进程终止时，发出这类信号。 \r\n（2） 与进程例外事件相关的信号。如进程越界，或企图写一个只读的内存区域（如程序正文区），或执行一个特权指令及其他各种硬件错误。 \r\n（3） 与在系统调用期间遇到不可恢复条件相关的信号。如执行系统调用exec时，原有资源已经释放，而目前系统资源又已经耗尽。 \r\n（4） 与执行系统调用时遇到非预测错误条件相关的信号。如执行一个并不存在的系统调用。 \r\n（5） 在用户态下的进程发出的信号。如进程调用系统调用kill向其他进程发送信号。 \r\n（6） 与终端交互相关的信号。如用户关闭一个终端，或按下break键等情况。 \r\n（7） 跟踪进程执行的信号。 \r\n\r\n \r\n\r\n**多线程信号处理：**\r\n\r\n\\1. \r\n\r\n不要在线程的信号掩码中阻塞不能被忽略处理的两个信号 SIGSTOP 和 SIGKILL。\r\n\r\n\\2. \r\n\r\n\\3. \r\n\r\n不要在线程的信号掩码中阻塞 SIGFPE、SIGILL、SIGSEGV、SIGBUS。\r\n\r\n\\4. \r\n\r\n\\5. \r\n\r\n确保 sigwait() 等待的信号集已经被进程中所有的线程阻塞。\r\n\r\n\\6. \r\n\r\n\\7. \r\n\r\n在主线程或其它工作线程产生信号时，必须调用 kill() 将信号发给整个进程，而不能使用 pthread_kill() 发送某个特定的工作线程，否则信号处理线程无法接收到此信号。\r\n\r\n\\8. \r\n\r\n\\9. \r\n\r\n因为 sigwait（）使用了串行的方式处理信号的到来，为避免信号的处理存在滞后，或是非实时信号被丢失的情况，处理每个信号的代码应尽量简洁、快速，避免调用会产生阻塞的库函数。\r\n\r\n\\10. \r\n\r\n​               \r\n\r\n \r\n\r\n#                      **线程**\r\n\r\n![img](11.Linux调度系统全景指南(下篇) .assets/wps3867.tmp.jpg) \r\n\r\n  \r\n\r\n \r\n\r\n线程（英语：thread）是操作系统能够进行运算调度的最小单位。大部分情况下，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。一个进程的组成实体可以分为两大部分：线程集和资源集。进程中的线程是动态的对象；代表了进程指令的执行。资源，包括地址空间、打开的文件、用户信息等等，由进程内的线程共享。\r\n\r\n \r\n\r\n![img](11.Linux调度系统全景指南(下篇) .assets/wps3868.tmp.png) \r\n\r\n​               线程和进程的关系\r\n\r\n根据操作系统内核是否对线程可感知，可以把线程分为**内核线程**和**用户线程**\r\n\r\n \r\n\r\n![img](11.Linux调度系统全景指南(下篇) .assets/wps3869.tmp.png) \r\n\r\n \r\n\r\n**分类的标准主要是线程的调度者在核内还是在核外**。前者更利于并发使用多处理器的资源，而后者则更多考虑的是上下文切换开销。Linux内核只提供了轻量进程的支持，限制了更高效的线程模型的实现，但Linux着重优化了进程的调度开销，一定程度上也弥补了这一缺陷。目前最流行的线程机制LinuxThreads所采用的就是“线程-进程”一对一模型（还存在多对一，多对多模型）用户级实现一个包括信号处理在内的线程管理机制。\r\n\r\n \r\n\r\n![img](11.Linux调度系统全景指南(下篇) .assets/wps386A.tmp.png) \r\n\r\n​    Linux 线程实现采用内核级线程”一对一”模型\r\n\r\n \r\n\r\n在linux系统下，无论是进程，还是线程，到了内核里面，我们统一都叫任务（Task），由一个统一的结构 task_struct 进行管理。一个进程由于其运行空间的不同，从而有内核线程和用户进程的区分。内核线程运行在内核空间，之所以称之为线程是因为它没有虚拟地址空间，只能访问内核的代码和数据； 而用户进程则运行在用户空间， 不能直接访问内核的数据但是可以通过中断，系统调用等方式从用户态陷入内核态，但是内核态只是进程的一种状态， 与内核线程有本质区别，用户进程运行在用户空间上，而一些通过共享资源实现的一组进程我们称之为线程组。Linux下内核其实本质上没有线程的概念，Linux下线程其实上是与其他进程共享某些资源的进程而已。但是我们习惯上还是称它们为线程或者轻量级进程。\r\n\r\n \r\n\r\n## **内核线程**\r\n\r\n \r\n\r\n内核线程是直接由内核本身启动的进程。内核线程实际上是将内核函数委托给独立的进程，它与内核中的其他进程”并行”执行。内核线程经常被称之为内核守护进程，他们执行下列任务：\r\n\r\n· \r\n\r\n周期性地将修改的内存页与页来源块设备同步；\r\n\r\n· \r\n\r\n· \r\n\r\n如果内存页很少使用，则写入交换区；\r\n\r\n· \r\n\r\n· \r\n\r\n管理延时动作,　如２号进程接手内核进程的创建；\r\n\r\n· \r\n\r\n· \r\n\r\n实现文件系统的事务日志；\r\n\r\n· \r\n\r\n· \r\n\r\n…\r\n\r\n· \r\n\r\n内核线程主要有两种类型：\r\n\r\n· \r\n\r\n线程启动后一直等待，直至内核请求线程执行某一特定操作。\r\n\r\n· \r\n\r\n· \r\n\r\n线程启动后按周期性间隔运行，检测特定资源的使用，在用量超出或低于预置的限制时采取行动。\r\n\r\n· \r\n\r\n内核线程由内核自身生成，其特点在于：\r\n\r\n· \r\n\r\n它们在CPU的内核态执行，而不是用户态；\r\n\r\n· \r\n\r\n· \r\n\r\n它们只可以访问虚拟地址空间的内核部分（高于TASK_SIZE的所有地址），但不能访问用户空间。\r\n\r\n· \r\n\r\n· \r\n\r\nLinux在内核线程架构设计中，内核线程建立和销毁都是由操作系统负责、通过系统调用完成的。在内核的支持下运行，无论是用户进程的线程，或者是系统进程的线程，他们的创建、撤销、切换都是依靠内核实现的。线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口. 内核为进程及其内部的每个线程维护上下文信息，调度也是在内核基于线程架构的基础上完成。内核线程驻留在内核空间，它们是内核对象。\r\n\r\n \r\n\r\n内核线程就是内核的分身，一个分身可以处理一件特定事情。Linux内核使用内核线程来将内核分成几个功能模块，像kworker,  kswapd， ksoftirqd,  migration , rcu_bh，rcu_schd, watchdog等(内核线程都用[] 括起来)。这在处理异步事件如异步IO，阻塞任务，延后任务处理时特别有用。内核线程的使用是廉价的，唯一使用的资源就是内核栈和上下文切换时保存寄存器的空间，内核线程只运行在内核态，不受用户态上下文的拖累，在多核系统中，很多内核线程都是per cpu运行粒度。\r\n\r\n \r\n\r\n \r\n\r\n## **用户线程**\r\n\r\n \r\n\r\nLinux内核只提供了轻量级进程(LWP)的方式支持用户线程，限制了更高效的线程模型的实现，但Linux着重优化了进程的调度开销，一定程度上也弥补了这一缺陷。目前最流行的线程机制LinuxThreads所采用的就是线程-进程”一对一”模型，调度交给核心，而在用户级实现一个包括信号处理在内的线程管理机制。轻量级进程由clone()系统调用创建，参数是CLONE_VM，即与父进程是共享进程地址空间和系统资源。\r\n\r\n \r\n\r\nLinuxThreads是用户空间的线程库，所采用的是“线程-进程”1对1模型(即一个用户线程对应一个轻量级进程，而一个轻量级进程对应一个特定的内核线程)，将线程的调度等同于进程的调度，调度交由内核完成， 有了内核线程，每个用户线程被映射或绑定到一个内核线程。用户线程在其生命期内都会绑定到该内核线程。调度器管理、调度并分派这些线程。运行时库为每个用户级线程请求一个内核级线程。而线程的创建、同步、销毁由核外线程库完成（LinuxThtreads已绑定到 GLIBC中发行）。 在LinuxThreads中，由专门的一个管理线程处理所有的线程管理工作。当进程第一次调用pthread_create()创建线程时就会先 创建(clone())并启动管理线程。后续进程pthread_create()创建线程时，都是管理线程作为pthread_create()的调用者的子线程，通过调用clone()来创建用户线程，并记录轻量级进程号和线程id的映射关系，因此用户线程其实是管理线程的子线程。LinuxThreads只支持调度范围为PTHREAD_SCOPE_SYSTEM的调度，默认的调度策略是SCHED_OTHER。 用户线程调度策略也可修改成SCHED_FIFO或SCHED_RR方式，这两种方式支持优先级为0-99,而SCHED_OTHER只支持0。 \r\n\r\n​      \r\n\r\n![img](11.Linux调度系统全景指南(下篇) .assets/wps387B.tmp.png) \r\n\r\n​              Linux 轻量级进程实现\r\n\r\n \r\n\r\nLinuxThtreads的设计存在一些局限性，导致后面Linux实现了新的线程库NPTL，或称为 Native POSIX Thread Library，是 Linux 线程的一个新实现，它克服了 LinuxThreads 的缺点，同时也符合 POSIX 的需求。与 LinuxThreads 相比，它在性能和稳定性方面都提供了重大的改进。与 LinuxThreads 一样，NPTL 也实现了一对一的模型。\r\n\r\n \r\n\r\n**轻量级进程具有局限性：**\r\n\r\n \r\n\r\n· \r\n\r\n首先，大多数LWP的操作，如建立、析构以及同步，都需要进行系统调用。系统调用的代价相对较高：需要在user mode和kernel mode中切换。\r\n\r\n· \r\n\r\n· \r\n\r\n其次，每个LWP都需要有一个内核线程支持，因此LWP要消耗内核资源（内核线程的栈空间）。因此一个系统不能支持大量的LWP。\r\n\r\n· \r\n\r\n· \r\n\r\n优点：\r\n\r\n（1）运行代价：LWP只有一个最小的执行上下文和调度程序所需的统计信息。\r\n\r\n（2）处理器竞争：因与特定内核线程关联，因此可以在全系统范围内竞争处理器资源。\r\n\r\n（3）使用资源：与父进程共享进程地址空间。\r\n\r\n（4）调度：像普通进程一样调度。\r\n\r\n \r\n\r\n## **协程**\r\n\r\n以上描述的不管是中断，进程，线程（内核线程，用户线程（轻量级进程实现））的调度都是由内核掌控，用户并不能直接干预，要在用户态实现对逻辑调度控制，需要实现类似用户级线程，用户级线程是完全建立在用户空间的线程库，用户线程的创建、调度、同步和销毁全部库函数在用户空间完成，不需要内核的帮助。因此这种线程是极其低消耗和高效的。协程本质上也是一种用户级线程实现，在一个线程（内核执行单元）内，协程通过主动放弃时间片交由其他协程执行来协作，故名协程。协程的一些关键点：\r\n\r\n· \r\n\r\n任何代码执行都需要上下文（CPU），协程也有自己的上下文，协程切换只涉及基本的CPU上下文切换, 完全在用户空间进行，没有模式切换，所以比线程切换要小，开源libco 的协程切换的汇编代码，也就是二十来条汇编指令，一般切换代价： 协程 < 线程 < 系统调用 < 进程 ；\r\n\r\n· \r\n\r\n \r\n\r\n· \r\n\r\n· \r\n\r\n在多核多线程系统中，线程切换代价比较高（cache miss等），为了减少线程切换，希望在同一个线程内进行不同逻辑的伪并行（实际上还是串行），这样降低了代码逻辑切换代价，但这样并没有拥有真正并发带来的高性能，选择合适的使用场景；\r\n\r\n· \r\n\r\n \r\n\r\n· \r\n\r\n· \r\n\r\n协程存在兼容性问题，协程分为有栈协程和无栈协程实现，对不同系统和处理器要进行兼容，但不同系统对上下文实现，异常等不一样，这样就可能产生不兼容情况，一般用户态的代码都不关心底层差别，而使用协程后的代码兼容性变差。\r\n\r\n· \r\n\r\n "},df9c:function(n,r,e){"use strict";e.r(r),r["default"]='https://github.com/jinnianwushuang/server-configs-nginx\r\n\r\n\r\n\r\nNginx配置文件详解\r\n\r\n```\r\n—————————————————————————————\r\n1\r\n\r\nNginx 配置文件详解\r\nuser www www;\r\n#程序运行用户和组\r\nworker_processes auto;\r\n#启动进程，指定 nginx 启动的工作进程数量，建议按照 cpu 数目来指定，一般等于 cpu 核心数目\r\nerror_log /home/wwwlogs/nginx_error.log crit;\r\n#全局错误日志\r\npid /usr/local/nginx/logs/nginx.pid;\r\n#主进程 PID 保存文件\r\nworker_rlimit_nofile 51200;\r\n#文件描述符数量\r\nevents \r\n    {\r\n    use epoll; \r\n    #使用 epoll 模型，对于 2.6 以上的内核，建议使用 epoll 模型以提高性能\r\n    worker_connections 51200;\r\n    #工作进程的最大连接数量，根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把 cpu\r\n    跑到 100%就行每个进程允许的最多连接数， 理论上每台 nginx 服务器的最大连接数为\r\n    worker_processes*worker_connections，具体还要看服务器的硬件、带宽等。\r\n    }\r\nhttp \r\n    #整体环境配置--网站配置\r\n    {\r\n    include mime.types;\r\n    default_type application/octet-stream;\r\n    #设定 mime 类型,文件传送类型由 mime.type 文件定义\r\n    server_names_hash_bucket_size 128;\r\n    #保存服务器名字的 hash 表大小\r\n    client_header_buffer_size 32k;\r\n    #客户端请求头部缓冲区大小\r\n    large_client_header_buffers 4 32k;\r\n    #最大客户端头缓冲大小\r\n    \r\n    \r\n    client_max_body_size 50m;\r\n    #客户端最大上传文件大小（M）\r\n    sendfile on;\r\n    #sendfile 指令指定 nginx 是否调用 sendfile 函数来输出文件，对于普通应用，必须设\r\n    为 on。如果用来进行下载等应用磁盘 IO 重负载应用，可设置为 off，以平衡磁盘与网络 I/O 处理速度，\r\n    降低系统的 uptime.\r\n    tcp_nopush on;\r\n    #这个是默认的，结果就是数据包不会马上传送出去，等到数据包最大时，一次性的传\r\n    输出去，这样有助于解决网络堵塞。（只在 sendfile on 时有效）\r\n    keepalive_timeout 60;\r\n    #连接超时时间\r\n    tcp_nodelay on;\r\n    #禁用 nagle 算法，也即不缓存数据。有效解决网络阻塞\r\n    fastcgi_connect_timeout 300;\r\n    fastcgi_send_timeout 300;\r\n    fastcgi_read_timeout 300;\r\n    fastcgi_buffer_size 64k;\r\n    fastcgi_buffers 4 64k;\r\n    fastcgi_busy_buffers_size 128k;\r\n    fastcgi_temp_file_write_size 256k;\r\n    #fastcgi 设置\r\n    gzip on;\r\n    gzip_min_length 1k;\r\n    gzip_buffers 4 16k;\r\n    gzip_http_version 1.1;\r\n    gzip_comp_level 2;\r\n    gzip_types text/plain application/javascript application/x-javascript text/javascript \r\n    text/css application/xml application xml+rss;\r\n    gzip_vary on;\r\n    gzip_proxied expired no-cache no-store private auth;\r\n    gzip_disable "MSIE [1-6]\\.";\r\n    #limit_conn_zone $binary_remote_addr zone=perip:10m;\r\n    ##If enable limit_conn_zone,add "limit_conn perip 10;" to server section.\r\n    server_tokens off;\r\n    #隐藏 nginx 版本号（curl -I 192.168.4.154 可以查看，更加安全）\r\n    #log format\r\n    \r\n    \r\n\r\n    log_format access \'$remote_addr - $remote_user [$time_local] "$request"\'\r\n    \'$status $body_bytes_sent "$http_referer" \'\r\n    \'"$http_user_agent" $http_x_forwarded_for\';\r\n    #定义日志格式\r\n    server\r\n        {\r\n        listen 80 default_server;\r\n        #listen [::]:80 default_server ipv6only=on;\r\n        #监听 80 端口，WEB 服务的监听设置，可以采用"IP 地址:端口"形式\r\n        server_name www.lnmp.org lnmp.org;\r\n        #服务器名，可以写多个域名，用空格分隔\r\n        index index.html index.htm index.php;\r\n        #默认网页文件\r\n        root /home/wwwroot/default;\r\n        #网页主目录\r\n        #error_page 404 /404.html;\r\n        include enable-php.conf;\r\n        \r\n        location /nginx_status\r\n        {\r\n        stub_status on;\r\n        access_log off;\r\n        } #开启 status 状态监测\r\n        location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$\r\n        {\r\n        expires 30d;\r\n        } #静态文件处理，保存期 30 天\r\n        location ~ .*\\.(js|css)?$\r\n        {\r\n        expires 12h;\r\n        }\r\n        #js 和 css 文件处理，保存期 12 小时\r\n        location ~ /\\.\r\n        {\r\n        deny all;\r\n        }\r\n        access_log /home/wwwlogs/access.log access;\r\n        \r\n \r\n\r\n        #正确访问日志\r\n    }\r\n    include vhost/*.conf;\r\n    #vhost/下子配置文件生效\r\n}\r\n```'},e516:function(n,r,e){"use strict";e.r(r);var t=function(){var n=this,r=n.$createElement,e=n._self._c||r;return e("div",[e("div",[e(""+n.tab,{tag:"component"})],1)])},i=[],s=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},a=[function(){var n=this,r=n.$createElement,e=n._self._c||r;return e("div",[e("table",{staticStyle:{width:"1144px","border-collapse":"collapse","table-layout":"fixed"},attrs:{width:"1144",border:"1",cellpadding:"0",cellspacing:"0"}},[e("tr",{attrs:{height:"19"}},[e("td",{staticStyle:{width:"80px"}},[n._v("主题")]),e("td",{staticStyle:{width:"80px"}},[n._v("相关命令")]),e("td",{staticStyle:{width:"180px"}},[n._v("作用")]),e("td",{staticStyle:{width:"280px"}},[n._v("常用参数")]),e("td",{staticStyle:{width:"400px"}},[n._v("备注")])]),e("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[e("td",{attrs:{height:"234",rowspan:"6"}},[n._v("开关机")]),e("td",[n._v("shutdown")]),e("td",[n._v("关机或重启")]),e("td",[n._v("-r 重启"),e("br"),n._v("-h 关机"),e("br"),n._v("-k 警告"),e("br"),n._v("-c 取消")]),e("td",[n._v("\n          shutdown -r now"),e("br"),n._v("shutdown -h now"),e("br"),n._v("shutdown -r +1"),e("br"),n._v("\n          shutdown -h 1 一分钟后关机 "),e("br"),n._v("\n          shutdown -r 11:30 "),e("br"),n._v("\n          shutdown -c 撤销shutdown 命令\n        ")])]),e("tr",[e("td",[n._v("reboot")]),e("td",[n._v("重启")]),e("td"),e("td",[n._v("reboot")])]),e("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[e("td",[n._v("init")]),e("td",[n._v("运行级别")]),e("td",{attrs:{colspan:"2"}},[n._v("\n          systemctl get-default "),e("br"),n._v("\n          CentOS7的运行级别 "),e("br"),n._v("\n          0 shutdown.target 系统关机状态 halt init 0 "),e("br"),n._v("\n          1 emergency.target\n          单用户工作状态(类似Windows的安全模式，Linux忘记密码)"),e("br"),n._v("\n          2 rescure.target "),e("br"),n._v("\n          3 multi-user.target 命令行模式 多用户状态\n          (字符模式,服务基本都是此模式)"),e("br"),n._v("\n          4 无 系统未使用，留给用户"),e("br"),n._v("\n          5 graphical.target 图形模式 (个人计算机都是此模式)"),e("br"),n._v("\n          6 无 "),e("br")])]),e("tr",[e("td",[n._v("halt")]),e("td",[n._v("硬件关机")]),e("td"),e("td",[n._v("halt")])]),e("tr",{attrs:{height:"36"}},[e("td",[n._v("poweroff")]),e("td",[n._v("硬件关机")]),e("td",[n._v("-f 强行关机")]),e("td",[n._v("poweroff"),e("br"),n._v("poweroff -f")])]),e("tr",[e("td",[n._v("sync")]),e("td",[n._v("将内存中数据回填到硬盘")]),e("td"),e("td",[n._v("sync;sync")])]),e("tr",{attrs:{height:"36"}},[e("td",{attrs:{height:"36"}},[n._v("启动X-Windows")]),e("td",[n._v("startx")]),e("td",[n._v("进入X-Window")]),e("td"),e("td",[n._v("进入X-Windows后可以用logout注销回到命令行")])]),e("tr",{attrs:{height:"36"}},[e("td",{attrs:{height:"180",rowspan:"3"}},[n._v("日期/时间")]),e("td",[n._v("cal")]),e("td",[n._v("日历")]),e("td"),e("td",[n._v("cal 2011"),e("br"),n._v("cal 03 2011")])]),e("tr",{staticStyle:{height:"81.00pt"}},[e("td",[n._v("date")]),e("td",[n._v("日期")]),e("td",[n._v("-s 修改日期"),e("br")]),e("td",[n._v("\n          date +%Y/%m/%d 按指定格式显示日期"),e("br"),n._v("date -s 07/13/2011"),e("br"),n._v("date -s\n          11:55:00"),e("br"),n._v("clock --systohc 将时间保存到硬件"),e("br"),n._v("date 071610512011\n          月日时分年"),e("br"),n._v("hwclock -w 写入主板芯片\n        ")])]),e("tr",{attrs:{height:"36"}},[e("td",[n._v("time")]),e("td",[n._v("计算某个命令执行所耗费时间")]),e("td"),e("td",[n._v("\n          time sh myshell.sh"),e("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("  ")]),n._v("运行myshell.sh这个脚本所花的时间\n        ")])]),e("tr",[e("td",[n._v("公告")]),e("td",[n._v("wall")]),e("td",[n._v("广播")]),e("td"),e("td",[n._v("wall hello")])]),e("tr",[e("td",[n._v("清屏")]),e("td",[n._v("clear")]),e("td",[n._v("清屏")]),e("td"),e("td",[n._v("clear")])]),e("tr",[e("td",{attrs:{rowspan:"7"}},[n._v("帮助")]),e("td",[n._v("whatis")]),e("td",[n._v("命令介绍")]),e("td"),e("td",[n._v("whatis ls")])]),e("tr",[e("td",[n._v("apropos")]),e("td",[n._v("帮助一览")]),e("td"),e("td")]),e("tr",[e("td",[n._v("help")]),e("td",[n._v("帮助")]),e("td"),e("td",[n._v("help cd")])]),e("tr",[e("td",[n._v("--help")]),e("td",[n._v("帮助")]),e("td"),e("td",[n._v("ls --help")])]),e("tr",[e("td",[n._v("man")]),e("td",[n._v("参考手册")]),e("td",[n._v("可以像在vi里一样使"),e("span",{},[n._v("用斜杠来查找字符串")])]),e("td",[n._v("man ls | more")])]),e("tr",[e("td",[n._v("info")]),e("td",[n._v("相关信息")]),e("td"),e("td",[n._v("info ls")])]),e("tr",[e("td",[n._v("type")]),e("td",[n._v("查看一个命令是属于内部命令还是外部命令。")]),e("td"),e("td",[n._v("type cd")])]),e("tr",[e("td",{staticStyle:{height:"40.50pt"},attrs:{height:"54",rowspan:"2"}},[n._v("系统设定")]),e("td",[n._v("setup")]),e("td",[n._v("系统设定工具")]),e("td"),e("td",[n._v("修改/etc/sysconfig的内容")])]),e("tr",{attrs:{height:"36"}},[e("td",[n._v("locale")]),e("td",[n._v("显示语系")]),e("td",[n._v("-a 显示所有支持的语系")]),e("td",[n._v("locale -a"),e("br"),n._v("cat /etc/sysconfig/i18n")])]),e("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[e("td",{attrs:{height:"234",rowspan:"6"}},[n._v("网络命令")]),e("td",[n._v("ifconfig")]),e("td",{attrs:{colspan:"2"}},[n._v("\n          ens33 ：是默认的网卡"),e("br"),n._v("\n          lo（loop，循环）：表示回环网卡，代表本机"),e("br"),n._v("\n          virbr0：虚拟网络接口"),e("br"),n._v("\n          # vim /etc/sysconfig/network-scripts/ifcfg-ens33"),e("br"),n._v('\n          TYPE="Ethernet"'),e("br"),n._v('\n          BOOTPROTO="dhcp"'),e("br"),n._v('\n          NAME="ens33"'),e("br"),n._v('\n          UUID="6c809893-d12c-46af-9987-4c05b2773c91"'),e("br"),n._v('\n          DEVICE="ens33"'),e("br"),n._v('\n          ONBOOT="yes"'),e("br"),n._v("\n          参数解析："),e("br"),n._v("\n          TYPE ：网络类型，Ethernet以太网"),e("br"),n._v("\n          BOOTPROTO：IP的获取方式，dhcp代表自动获取，static/none代表手工设置"),e("br"),n._v("\n          NAME ：网卡的名称（名字），ens33"),e("br"),n._v("\n          UUID ：代表网卡的UUID编号（必须是唯一的）"),e("br"),n._v("\n          DEVICE ：设备名称"),e("br"),n._v("\n          ONBOOT：代表网卡是否随计算机开启启动，yes随计算机开机启动，no代表不启动"),e("br")]),e("td",[n._v("\n          查看IP"),e("br"),n._v("设置IP"),e("br"),n._v("启用网卡"),e("br"),n._v("禁用网卡"),e("br"),n._v("\n          ifconfig"),e("br"),n._v("\n          ifconfig eth0 172.168.0.201 netmask 255.255.0.0"),e("br"),n._v("\n          ifconfig ens33 172.168.0.201 netmask 255.255.0.0"),e("br"),n._v("\n          ifconfig eth0 up"),e("br"),n._v("\n          ifconfig eth0 down\n        ")])]),e("tr",[e("td",[n._v("ifup")]),e("td",[n._v("启用网卡")]),e("td"),e("td",[n._v("ifup eth0")])]),e("tr",[e("td",[n._v("ifdown")]),e("td",[n._v("禁用网卡")]),e("td"),e("td",[n._v("ifdown eth0")])]),e("tr",[e("td",[n._v("route")]),e("td",[n._v("路由")]),e("td"),e("td")]),e("tr",{attrs:{height:"90"}},[e("td",[n._v("netstat")]),e("td",[n._v("显示Tcp/IP网络状态")]),e("td",[n._v("\n          -a 显示所有的socket"),e("br"),n._v("-n 以IP地址显示"),e("br"),n._v("-p 显示进程号"),e("br")]),e("td",[n._v("netstat -na")])]),e("tr",[e("td",[n._v("netconfig")]),e("td",[n._v("配置网络")]),e("td"),e("td",[n._v("修改的内容实际在 /etc/sysconfig/network-scripts 中")])]),e("tr",[e("td",{attrs:{height:"216",rowspan:"13"}},[n._v("系统信息查询")]),e("td",[n._v("whoami")]),e("td",[n._v("查看自己是谁")]),e("td"),e("td")]),e("tr",[e("td",[n._v("who am i")]),e("td",[n._v("查看自己账号及登录信息")]),e("td"),e("td",[n._v("通过su可以看到whoami和who am i的不同")])]),e("tr",[e("td",[n._v("who")]),e("td",[n._v("查看当前系统在线用户")]),e("td"),e("td",[n._v("who")])]),e("tr",[e("td",[n._v("w")]),e("td",[n._v("查看当前系统在线用户")]),e("td"),e("td",[n._v("who")])]),e("tr",[e("td",[n._v("last")]),e("td",[n._v("查看这个月的用户登录信息")]),e("td"),e("td",[n._v("last")])]),e("tr",[e("td",[n._v("hostname")]),e("td",[n._v("查看自己的主机名")]),e("td"),e("td",[n._v("hostname")])]),e("tr",[e("td",[n._v("hostnamectl")]),e("td",[n._v("设置自己的主机名")]),e("td"),e("td",[n._v("\n          hostnamectl -- "),e("br"),n._v("\n          静态的（static） "),e("br"),n._v("瞬态的（transient）"),e("br"),n._v("灵活的（pretty）"),e("br"),n._v("\n          hostnamectl --static set-hostname hr01.aa.cn\n        ")])]),e("tr",[e("td",[n._v("uname")]),e("td",[n._v("列出系统信息")]),e("td",[n._v("-a 查询所有")]),e("td",[n._v("uname -a")])]),e("tr",[e("td",[n._v("dmesg")]),e("td",[n._v("查看开机启动信息")]),e("td"),e("td",[n._v("dmesg")])]),e("tr",[e("td",[n._v("uptime")]),e("td",[n._v("查看开机时长")]),e("td"),e("td",[n._v("uptime")])]),e("tr",[e("td",[n._v("id")]),e("td",[n._v("查看自己及所属的组的信息")]),e("td"),e("td",[n._v("id")])]),e("tr",[e("td",[n._v("finger")]),e("td",[n._v("查看用户信息")]),e("td",[n._v("-s 完整列出")]),e("td",[n._v("finger -s username")])]),e("tr",[e("td",[n._v("groups")]),e("td",[n._v("查看自己属于哪些组")]),e("td"),e("td",[n._v("groups root")])]),e("tr",{attrs:{height:"36"}},[e("td",{attrs:{height:"36"}},[n._v("查看历史命令")]),e("td",[n._v("history")]),e("td",[n._v("历史命令")]),e("td"),e("td",[n._v("\n          history | tail -10"),e("br"),n._v("可以用!n执行第n条历史，!!执行最后一条命令\n        ")])]),e("tr",[e("td",{attrs:{height:"324",rowspan:"12"}},[n._v("账号管理")]),e("td",[n._v("newgrp")]),e("td",[n._v("登录另一个组")]),e("td"),e("td",[n._v("类似login动作")])]),e("tr",[e("td",[n._v("groupadd")]),e("td",{attrs:{colspan:"2"}},[n._v("\n          添加组（在/etc/group） "),e("br"),n._v("\n          -g 编号 "),e("br"),n._v("\n          tcpdump:x:72: "),e("br"),n._v("\n          组名:组密码:组编号:组内用户信息 "),e("br"),n._v("\n          自定义组从 1000开始"),e("br")]),e("td",[n._v("groupadd testing")])]),e("tr",[e("td",[n._v("groupdel")]),e("td",[n._v("删除组")]),e("td"),e("td",[n._v("groupdel test")])]),e("tr",[e("td",[n._v("groupmod")]),e("td",[n._v("修改组")]),e("td",[n._v("\n          -g 编号 "),e("br"),n._v("\n          -n 名称 "),e("br")]),e("td",[n._v("\n          groupmod -n test testing"),e("br"),n._v("\n          #groupmod -g 1100 -n bjhr hr"),e("br"),n._v("\n          含义：将hr组的组ID改成1100，组名改成bjhr"),e("br")])]),e("tr",[e("td",[n._v("gpasswd")]),e("td",[n._v("修改组的密码")]),e("td"),e("td")]),e("tr",[e("td",[n._v("useradd")]),e("td",{attrs:{colspan:"2"}},[n._v("\n          添加用户 "),e("br"),n._v("\n          etc/passwd 存储用户信息的文件"),e("br"),n._v("\n          用户：/etc/passwd文件，每创建一个用户，其就会在此文件中追加一行 "),e("br"),n._v("\n          # vim /etc/passwd"),e("br"),n._v("\n          root:x:0:0:root:/root:/bin/bash"),e("br"),n._v("\n          由上图可知，一共拥有7列"),e("br"),n._v("\n          第1列：用户名称"),e("br"),n._v("\n          第2列：用户的密码，使用一个x占位符，真实密码存储在/etc/shadow(1-用户名，2-加密密码)"),e("br"),n._v("\n          第3列：数字，用户的ID编号"),e("br"),n._v("\n          第4列：数字，用户的主组ID编号"),e("br"),n._v('\n          第5列：代表注释信息，useradd -c "备注信息" 用户名称'),e("br"),n._v("\n          第6列：用户的家目录，默认在/home/用户名称"),e("br"),n._v("\n          第7列：用户可以使用的Shell类型，useradd -s /bin/bash或/sbin/nologin\n          用户名称"),e("br")]),e("td",[n._v("\n          # useradd [选项 选项的值] 用户名称"),e("br"),n._v("\n          选项说明："),e("br"),n._v("\n          -g ：指定用户的主组的编号信息"),e("br"),n._v("\n          -s ：指定用户可以使用的Shell类型"),e("br"),n._v("\n          /bin/bash ：给人用的，给运维工程师"),e("br"),n._v("\n          /sbin/nologin ：给软件用的，比如mysql"),e("br"),n._v("\n          -G ：指定附属组的ID编号，如果有多个附属组，可以使用逗号隔开 useradd -G\n          1000,1001 .. 用户名称 会显示在 附加组 组信息后，主组不会"),e("br"),n._v("\n          -d ：指定用户的家，/home/itheima，useradd -d /itheima itheima"),e("br"),n._v("\n          -u ：指定用户的ID编号，默认是自动生成的"),e("br"),n._v("\n          -c ：comment，注释信息，scj:x:uid:gid:宋楚杰的账号"),e("br"),n._v("\n          -n ：取消以用户名称命名的组信息"),e("br"),n._v("\n          注意：不用任何参数，创建用户，系统会默认执行以下操作："),e("br"),n._v("\n          1）在 /etc/passwd 文件中创建一行关于zhangsan用户的数据"),e("br"),n._v("\n          2）在 /etc/shadow 文件中新增了一行关于zhangsan 密码的数据"),e("br"),n._v("\n          3）在 /etc/group 文件中创建一行与用户名相同的组，例如zhangsan"),e("br"),n._v("\n          4）在 /etc/gshadow\n          文件中新增一行与新增群组相关的密码信息，例如zhangsan"),e("br"),n._v("\n          5）自动创建用户的家目录，默认在/home下，与用户名同名"),e("br")])]),e("tr",[e("td",[n._v("userdel")]),e("td",{attrs:{colspan:"2"}},[n._v("\n          删除用户"),e("br"),n._v("\n          -r 连用户主目录一起删除 "),e("br"),n._v("\n          删除用户递归删除该用户所有文件 删除账号流程： "),e("br"),n._v("\n          ① 删除账号 "),e("br"),n._v("\n          ② 确认是否删除用户家 "),e("br"),n._v("\n          ③ 删除用户主组（没有其他用户） "),e("br")]),e("td",[n._v("\n          userdel -r zhangsan "),e("br"),n._v("\n          ps -ef |grep zhangsan"),e("br"),n._v("\n          搜索包含了zhangsan 关键词的所有进程 "),e("br"),n._v("\n          kill [-9] 进程的ID编号 "),e("br")])]),e("tr",{attrs:{height:"36"}},[e("td",[n._v("usermod")]),e("td",{attrs:{colspan:"2"}},[n._v("\n          编辑用户"),e("br"),n._v("\n          # usermod [选项 选项的值] 用户名称 选项说明："),e("br"),n._v("\n          -g ：修改用户所属的主组的编号"),e("br"),n._v("\n          - l：修改用户的名称"),e("br"),n._v("\n          -s ：修改用户可以使用的Shell类型，如/bin/bash => /sbin/nologin"),e("br"),n._v("\n          扩展："),e("br"),n._v("\n          -L：锁定用户，锁定后用户无法登陆系统lock"),e("br"),n._v("\n          -U：解锁用户unlock"),e("br"),n._v("\n          了解："),e("br"),n._v("\n          -G ：修改用户附属组的编号信息"),e("br"),n._v("\n          -d ：修改用户的家目录"),e("br"),n._v("\n          -c ：修改用户的备注信息 "),e("br")]),e("td",[n._v("\n          usermod -g test51 root"),e("br"),n._v("\n          usermod -d /home/lisi zhangsan"),e("br"),n._v("\n          禁止linuxuser账号登录Linux操作系统"),e("br"),n._v("\n          usermod -s /sbin/nologin linuxuser"),e("br")])]),e("tr",{attrs:{height:"90"}},[e("td",[n._v("passwd")]),e("td",[n._v("修改用户的密码")]),e("td"),e("td",[n._v("\n          passwd zhangsan"),e("br"),n._v("\n          备注：如果忘记root密码，可以在开机时按下e进入grub编辑模式，移到kernel所在行，在最后的rhgb\n          quiet后输入 single。"),e("br"),n._v("\n          按回车确定后，按下b进入single模式。然后输入passwd修改密码。\n        ")])]),e("tr",{attrs:{height:"36"}},[e("td",[n._v("chsh")]),e("td",[n._v("修改用户的默认SHELL"),e("br"),n._v("查看SHELL")]),e("td",[n._v("-l"),e("br"),n._v("-s")]),e("td",[n._v("chsh -l 查看shell"),e("br"),n._v("chsh root 修改root的默认shell")])]),e("tr",[e("td",[n._v("chfn")]),e("td",[n._v("更改注释字段")]),e("td"),e("td")]),e("tr",[e("td",[n._v("userconf")]),e("td"),e("td"),e("td")]),e("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[e("td",{attrs:{height:"324",rowspan:"9"}},[n._v("目录与路径")]),e("td",[n._v("cd")]),e("td",[n._v("进入到某个目录下")]),e("td",[n._v("~ 进入指定用户的主目录"),e("br"),n._v("- 返回之前进入的目录")]),e("td",[n._v("cd ~zhangsan"),e("br"),n._v("cd ~"),e("br"),n._v("cd"),e("br"),n._v("cd -")])]),e("tr",[e("td",[n._v("pwd")]),e("td",[n._v("显示当前目录的全路径")]),e("td"),e("td",[n._v("pwd")])]),e("tr",{staticStyle:{height:"94.50pt"},attrs:{height:"126"}},[e("td",[n._v("ls")]),e("td",[n._v("列出当前目录下的文件和目录")]),e("td",[n._v("\n          -l 详细信息"),e("br"),n._v("\n          -m 以逗号分割"),e("br"),n._v("\n          -a 显示隐藏文件"),e("br"),n._v("\n          -r"),e("br"),n._v("\n          -t"),e("br"),n._v("\n          -R 递归显示包含子目录"),e("br"),n._v("\n          -d 显示指定目录"),e("br"),n._v("\n          -x"),e("br"),n._v("\n          -h 人性化显示"),e("br")]),e("td",[n._v("ls -lrt"),e("br"),n._v("ls -la"),e("br"),n._v("ls -R")])]),e("tr",[e("td",[n._v("ll")]),e("td",[n._v("列出当前目录下的文件和目录")]),e("td",[n._v("\n          linux一共有7种文件类型,分别如下:"),e("br"),n._v("\n          -：普通文件"),e("br"),n._v("\n          d：目录文件"),e("br"),n._v("\n          l： 软链接（类似Windows的快捷方式）"),e("br"),n._v("\n          (下面四种是特殊文件)"),e("br"),n._v("\n          b：块设备文件（例如硬盘、光驱等）"),e("br"),n._v("\n          p：管道文件"),e("br"),n._v("\n          c：字符设备文件（例如猫等串口设备）"),e("br"),n._v("\n          s：套接口文件/数据接口文件（例如启动一个MySql服务器时会产生一个mysql.sock文件）"),e("br")]),e("td",[n._v("\n          等价于ls -l --color=tty （有颜色） "),e("br"),n._v("\n          -rw-r--r--. 1 root root 331270 Jul 7 08:25 a "),e("br"),n._v("\n          文件类型， 权限， 链接数， 属主，属组\n          ，文件大下，最后修改时间，文件名"),e("br"),n._v("\n          权限： 自己，组，其他人 "),e("br")])]),e("tr",[e("td",[n._v("vdir")]),e("td",[n._v("列出当前目录下的文件和目录")]),e("td"),e("td",[n._v("等价于ls -l （无颜色）")])]),e("tr",[e("td",[n._v("mkdir")]),e("td",[n._v("新建目录")]),e("td",[n._v("-p 递归创建")]),e("td",[n._v("\n          mkdir -p /dir1/dir2/dir3/dir4 "),e("br"),n._v("\n          mkdir dir1 dir2\n        ")])]),e("tr",[e("td",[n._v("rmdir")]),e("td",[n._v("删除空目录")]),e("td",[n._v("-p 递归删除")]),e("td",[n._v("\n          rmdir dir-path 从右侧向左侧递归删除 空目录"),e("br"),n._v("\n          rmdir dir1 dir2\n        ")])]),e("tr",[e("td",[n._v("basename")]),e("td",[n._v("获取文件名")]),e("td"),e("td",[n._v("basename $0")])]),e("tr",[e("td",[n._v("dirname")]),e("td",[n._v("获取目录名")]),e("td"),e("td",[n._v("dirname $0")])]),e("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[e("td",{attrs:{height:"252",rowspan:"10"}},[n._v("文件的查看")]),e("td",[n._v("cat")]),e("td",[n._v("显示文件内容")]),e("td",[n._v("\n          -n 对输出行编号"),e("br"),n._v("-v 显示控制字符"),e("br"),n._v("\n          -b和-n类似，但空白行不编号"),e("br"),n._v("\n          合并文件\n        ")]),e("td",[n._v("\n          cat /etc/profile"),e("br"),n._v("cat ~/.bash_profile"),e("br"),n._v("\n          cat -b file1 file2 file3"),e("br"),n._v("\n          cat -v file1 DOS下的换行符会以^M显示"),e("br"),n._v("\n          cat a.txt b.txt > d.txt 合并文件\n        ")])]),e("tr",[e("td",[n._v("tac")]),e("td",[n._v("逆向输出文件内容")]),e("td"),e("td",[n._v("tac myfile")])]),e("tr",[e("td",[n._v("nl")]),e("td",[n._v("显示文件内容")]),e("td"),e("td",[n._v("nl myfile")])]),e("tr",[e("td",[n._v("od")]),e("td",[n._v("以八进制显示文件内容")]),e("td"),e("td",[n._v("od myfile")])]),e("tr",[e("td",[n._v("more")]),e("td",[n._v("分页显示内容")]),e("td",[n._v("\n          b 向上 "),e("br"),n._v("\n          d 向下 "),e("br"),n._v("\n          文件整个加载在内存\n        ")]),e("td",[n._v("more myfile")])]),e("tr",[e("td",[n._v("less")]),e("td",[n._v("分页显示内容（可以上下翻页）")]),e("td",[n._v("\n          部分加载在内存 More Actions按键功能回车键向下移动一行"),e("br"),n._v("\n          d向下移动半页"),e("br"),n._v("\n          空格键向下移动一页"),e("br"),n._v("\n          b向上移动一页"),e("br"),n._v("\n          上下方向键向上与向下移动，less命令特有功能键"),e("br"),n._v("\n          less -N 文件名称显示行号/ "),e("br"),n._v("\n          字符串搜索指定的字符串"),e("br")]),e("td",[n._v("less myfile")])]),e("tr",[e("td",[n._v("head")]),e("td",[n._v("显示文件前面几行的内容")]),e("td",[n._v("\n          -n 行 "),e("br"),n._v("\n          -c 字节数 "),e("br")]),e("td",[n._v("head -n 10 /etc/passwd")])]),e("tr",[e("td",[n._v("tail")]),e("td",[n._v("显示文件后面几行的内容")]),e("td",[n._v("\n          -n 行 "),e("br"),n._v("\n          -c 字节数 "),e("br"),n._v("\n          -f 动态查看 "),e("br")]),e("td",[n._v("tail -n 20 /etc/passwd")])]),e("tr",[e("td",[n._v("strings")]),e("td",[n._v("查看二进制文件中的可打印字符")]),e("td"),e("td",[n._v("strings /bin/ls")])]),e("tr",{attrs:{height:"36"}},[e("td",[n._v("touch")]),e("td",[n._v("新建文件"),e("br"),n._v("更新文件时间")]),e("td"),e("td",[n._v("\n          touch myfile1 myfile2"),e("br"),n._v("\n          touch aa{3..8}_test.js 批量创建 "),e("br")])]),e("tr",{attrs:{height:"90"}},[e("td",{attrs:{height:"90"}},[n._v("文件的编辑")]),e("td",[n._v("vi/vim")]),e("td",[n._v("编辑文件内容")]),e("td",[n._v("\n          esc 切换模式 "),e("br"),n._v("\n          编辑模式：a/i/o/A/I/O"),e("br"),n._v("\n          末行模式：冒号或者斜杠或者问号"),e("br"),n._v("\n          命令模式：定位，删剪"),e("br"),n._v("\n          可视化模式： v"),e("br"),n._v("\n          可视化模式 下 ，y 复制 p 粘贴 "),e("br"),n._v("\n          开启着色显示：`:syntax on` "),e("br"),n._v("\n          关闭着色显示：`:syntax off`"),e("br")]),e("td",[n._v("\n          编辑器 保存退出："),e("br"),n._v("\n          :wq 保存并退出 zz ， :x"),e("br"),n._v("\n          :w 文件名 保存到文件名 "),e("br"),n._v("\n          :q! 强制退出 不保存"),e("br"),n._v("\n          :! 暂时离开vi 执行其他命令"),e("br"),e("br"),n._v("\n          编辑器操作："),e("br"),n._v("\n          【[n]x】删除光标位置后面n个字符"),e("br"),n._v("\n          【[n]X】删除光标位置前面n个字符"),e("br"),n._v("\n          【D】删除光标所在位置后面到行尾的所有字符"),e("br"),n._v("\n          【[n]dd】删除光标所在行及下面n行 剪切"),e("br"),n._v("\n          【p|P】在光标【下|上】一行粘贴"),e("br"),n._v("\n          【[n]yy】复制光标所在行及下面n行 "),e("br"),n._v("\n          【dG】删除光标所在行到文件结尾"),e("br"),n._v("\n          【J】合并光标所在行和下一行 中间用空格连接"),e("br"),n._v("\n          【.】执行上一次命令行操作"),e("br"),n._v("\n          【u】撤销 【ctrl +r】 取消撤销"),e("br"),e("br"),n._v("\n          编辑器定位："),e("br"),n._v("\n          【ctrl+[b|u]】上翻页 行号减小"),e("br"),n._v("\n          【ctrl+[f|d]】下翻页 行号增加"),e("br"),n._v("\n          【gg】定位在文件第一行行首"),e("br"),n._v("\n          【G】定位在文件最后一行行首"),e("br"),n._v("\n          【$ 】定位行尾 【n +$】 向下 跳过 n行"),e("br"),n._v("\n          【[n]G | [n]gg】定位在n行"),e("br"),n._v("\n          【[n]L】 定位在倒数第n行"),e("br"),n._v("\n          注意：在查找一些特殊含义的字符时，需要加上转义字符"),e("br"),n._v("\n          【/内容】查找"),e("br"),n._v("\n          【n】查找下一个"),e("br"),n._v("\n          【N】查找上一个"),e("br"),n._v("\n          【?】查找上一次的所搜内容"),e("br"),n._v("\n          【/^word】 查找以word开头的内容"),e("br"),n._v("\n          【/word$】 查找以word结尾的内容"),e("br"),n._v("\n          【/.】查找任意一个字符"),e("br"),n._v("\n          【/*】查找任意多个字符"),e("br"),e("br"),n._v("\n          编辑器替换："),e("br"),n._v("\n          【r】替换光标所在位置的字符"),e("br"),n._v("\n          【:r 文件名】在光标当前行的下一行插入一个文件"),e("br"),n._v("\n          【:s/a/b/g】将光标所在行的a替换为b"),e("br"),n._v("\n          【:g/a/s//b/g】将文件中所有a替换为b"),e("br"),n._v("\n          【:%s/a/b/g】将文件中所有a替换为b"),e("br"),n._v("\n          【:%s#/bin/bash#we666#g】将文件中所有/bin/bash替换为we666"),e("br"),n._v("\n          【:n1,n2 s/a/b/g】将行区间n1到n2的行中所有的a替换为b"),e("br"),e("br"),n._v("\n          编辑器设置："),e("br"),n._v("\n          【:set ic】搜索时不区分大小写"),e("br"),n._v("\n          【:set noic】搜索时区分大小写 "),e("br"),n._v("\n          【:set nu | nonu】 [不]设置 行号 "),e("br"),n._v("\n          【::set paste | nopaste】 [不]设置 粘贴模式 "),e("br"),n._v("\n          【:noh】 不高亮 "),e("br"),e("br"),n._v("\n          可视化模式："),e("br"),n._v("\n          可视化模式下复制"),e("br"),n._v("\n          按键：ctrl + v（可视块）或V（可视行）或v（可视），然后按下↑ ↓ ←\n          →方向键来选中需要"),e("br"),n._v("\n          复制的区块，按下y 键进行复制（不要按下yy），最后按下p 键粘贴"),e("br"),n._v("\n          退出可视模式按下Esc"),e("br"),n._v("\n          1）.添加多行注释：（重点）"),e("br"),n._v("\n          步骤1：首先按esc进入命令行模式下，按下Ctrl +\n          v，进入列（也叫区块）模式;"),e("br"),n._v("\n          步骤2：在行首使用上下键选择需要注释的多行;"),e("br"),n._v("\n          步骤3：按下键盘（大写）“I”键，进入插入模式；"),e("br"),n._v("\n          步骤4：然后输入注释符（“#”）;"),e("br"),n._v("\n          步骤5：最后按 两下“Esc”键。"),e("br"),n._v("\n          2）.删除多行注释：（重点）"),e("br"),n._v("\n          步骤1：首先按esc进入命令行模式下，按下Ctrl + v, 进入列模式;"),e("br"),n._v("\n          步骤2：选定要取消注释的多行的第一列"),e("br"),n._v("\n          步骤3：按del键即可"),e("br")])]),e("tr",[e("td",{attrs:{rowspan:"3"}},[n._v("文件的复制、移动和删除")]),e("td",[n._v("cp")]),e("td",[n._v("拷贝")]),e("td",[n._v("\n          -R 递归 "),e("br"),n._v("\n          -r 复制文件夹\n        ")]),e("td",[n._v("\n          cp hello.txt /opt/test/hello.cp "),e("br"),n._v("\n          cp -r test1 test2\n        ")])]),e("tr",{attrs:{height:"36"}},[e("td",[n._v("mv")]),e("td",[n._v("\n          移动"),e("br"),n._v("重命名"),e("br"),n._v("\n          文件文件夹都可以\n        ")]),e("td",[n._v("-f 连同子目录一起"),e("br"),n._v("-i"),e("br"),n._v("-t 目标目录")]),e("td",[n._v("\n          mv hello.txt /opt/test/ok.txt\n          "),e("br"),n._v("\n          mv -t d a b c\n        ")])]),e("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[e("td",[n._v("rm")]),e("td",[n._v("删除")]),e("td",[n._v("\n          -r 目录 ,递归删除"),e("br"),n._v("\n          -f 强制删除，不提示 "),e("br"),n._v("\n          -i "),e("br")]),e("td",[n._v("rm -rf /* 此命令慎用！")])]),e("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[e("td",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[n._v("链接文件")]),e("td",[n._v("ln")]),e("td",[n._v("连接")]),e("td",[n._v("-s 建立软链接"),e("br"),n._v("-d 建立硬链接（默认，可以不写）")]),e("td",[n._v("ln -s /root/myfile /s_myfile"),e("br"),n._v("ln -d hello.txt dhello")])]),e("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[e("td",{attrs:{height:"90",rowspan:"2"}},[n._v("挂载设备")]),e("td",[n._v("mount")]),e("td"),e("td",[n._v("-t")]),e("td",[n._v("\n          文件系统有vfat/iso9660，装优盘前先用fdisk -l查看"),e("br"),n._v("mount -t vfat\n          /dev/sdb1 /mnt/udisk"),e("br"),n._v("mount -a\n        ")])]),e("tr",{attrs:{height:"36"}},[e("td",[n._v("umount")]),e("td"),e("td",[n._v("-f 强制将该文件系统退出")]),e("td",[n._v("umount -a"),e("br"),n._v("umount /home")])]),e("tr",{attrs:{height:"36"}},[e("td",{attrs:{height:"162",rowspan:"4"}},[n._v("修改文件权限")]),e("td",[n._v("chgrp")]),e("td",[n._v("切换组改变文件的所属组")]),e("td",[n._v("-R 递归")]),e("td",[n._v("\n          chgrp 组名 文件1 文件2 目录1 目录2 "),e("br"),n._v("\n          chgrp mary /opt/test "),e("br"),n._v("\n          chgrp -R mary /opt/test\n        ")])]),e("tr",[e("td",[n._v("chown")]),e("td",[n._v("改变文件的所有者")]),e("td",[n._v("-R 递归")]),e("td",[n._v("\n          chown 用户名 文件1 文件2 目录1 目录2"),e("br"),n._v("\n          chown -R mary /opt/test\n        ")])]),e("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[e("td",[n._v("chmod")]),e("td",{attrs:{colspan:"2"}},[n._v("\n          修改权限 "),e("br"),n._v("\n          -R 递归批量修改 "),e("br"),n._v("\n          拥有者-所属组-其他人"),e("br"),n._v("\n          chmod -u|g|o|a +|-|= rwc 文件1 文件2"),e("br"),n._v("\n          chmod u + x "),e("br"),n._v("\n          r=4 w=2 x=1 "),e("br"),n._v("\n          chmod u=rwx,og=rx .bashrc"),e("br"),n._v("\n          chmod a+w .bashrc"),e("br"),n._v("\n          chmod a-x .bashrc"),e("br"),n._v("\n          chmod -R 777 /home/test"),e("br"),n._v("\n          chmod 372 文件名1 文件名2"),e("br")]),e("td",[n._v("\n          特殊设置位，S位权限 "),e("br"),n._v("\n          作用：为了让一般使用者临时具有该文件所属主/组的执行权限。 "),e("br"),n._v("\n          主要针对二进制文件（命令） "),e("br"),n._v("\n          chmod 0755 文件名1 文件名2 "),e("br"),n._v("\n          去除S位权限 "),e("br"),n._v("\n          # chmod u-s /usr/bin/passwd "),e("br"),n._v("\n          或者 "),e("br"),n._v("\n          # chmod 0755 /usr/bin/passwd "),e("br"),n._v("\n          添加S位权限 # chmod u+s /usr/bin/passwd 或者 "),e("br"),n._v("\n          # chmod 4755 /usr/bin/passwd "),e("br"),e("br"),n._v("\n          沾滞位T（针对文件夹） "),e("br"),n._v("\n          主要功能：只允许文件的创建者和root用户删除文件（防止误删除权限位）==\n          "),e("br"),n._v("\n          移除粘滞位 "),e("br"),n._v("\n          # chmod -R o-t /tmp "),e("br"),n._v("\n          或 "),e("br"),n._v("\n          # chmod -R 0777 /tmp "),e("br"),n._v("\n          添加粘滞位 "),e("br"),n._v("\n          # chmod -R o+t /tmp "),e("br"),n._v("\n          或 "),e("br"),n._v("\n          # chmod -R 1777 /tmp "),e("br")])]),e("tr",{attrs:{height:"36"}},[e("td",[n._v("chattr")]),e("td",[n._v("改变文件的特殊属性")]),e("td",[n._v("+i 属性不可更改"),e("br"),n._v("-i 属性可以更改")]),e("td",[n._v("chattr +i myfile 文件删不掉")])]),e("tr",[e("td",{attrs:{rowspan:"2"}},[n._v("ACL访问控制")]),e("td",[n._v("getfacl")]),e("td",[n._v("获取某个文件的ACL权限")]),e("td"),e("td",[n._v("getfacl 文件或目录名称")])]),e("tr",[e("td",[n._v("setfacl")]),e("td",[n._v("给某个文件设置ACL权限")]),e("td",[n._v("\n          # setfacl [选项] 文件或目录名称 "),e("br"),n._v("\n          选项说明： "),e("br"),e("br"),n._v("\n          -m ： 修改acl策略 "),e("br"),n._v("\n          -x ： 去掉某个用户或者某个组的权限 "),e("br"),n._v("\n          -b ： 删除所有的acl策略 "),e("br"),n._v("\n          -R ：递归,通常用在文件夹 "),e("br")]),e("td",[n._v("\n          案例：针对readme.txt文件给linuxuser设置一个权限=>可读 "),e("br"),n._v("\n          # setfacl -m u:linuxuser:r readme.txt => 针对某个用户开通ACL权限\n          "),e("br"),n._v("\n          案例：针对shop文件夹给itheima组设置一个权限=>可读可写权限rw "),e("br"),n._v("\n          # setfacl -R -m g:itheima:rw shop => 针对某个用户组开通ACL权限 "),e("br"),n._v("\n          案例：把linuxuser用户权限从readme.txt中移除掉 "),e("br"),n._v("\n          # setfacl -x u:linuxuser readme.txt "),e("br"),n._v("\n          案例：把itheima用户组权限从shop中移除掉 "),e("br"),n._v("\n          # setfacl -x -R g:itheima shop "),e("br"),n._v("\n          案例：把readme.txt文件中的所有ACL权限全部移除 "),e("br"),n._v("\n          # setfacl -b readme.txt\n        ")])]),e("tr",[e("td",[n._v("默认权限")]),e("td",[n._v("umask")]),e("td",[n._v("umask")]),e("td",{attrs:{colspan:"2"}},[n._v("\n          umask表示创建文件时的默认权限（即创建文件时不需要设置而天生的权限）\n          "),e("br"),n._v("\n          root用户下，touch a ，文件a的默认权限是644 "),e("br"),n._v("\n          普通用户下，touch b ，文件b的默认权限是664 "),e("br"),n._v("\n          注：0022中第一位0代表特殊权限位，可以不设置。"),e("br"),n._v("\n          umask的默认值，在root和普通用户下是不一样的，分别是022和002"),e("br"),n._v("\n          root : 666 - 022 = 644"),e("br")])]),e("tr",[e("td",{attrs:{height:"414",rowspan:"4"}},[n._v("搜索文件或目录")]),e("td",[n._v("which")]),e("td",[n._v("查看可执行文件的位置")]),e("td"),e("td",[n._v("which ls")])]),e("tr",[e("td",[n._v("whereis")]),e("td",[n._v("查看文件位置")]),e("td"),e("td",[n._v("whereis ls")])]),e("tr",{attrs:{height:"36"}},[e("td",[n._v("locate")]),e("td",[n._v("配合数据库查看文件位置")]),e("td"),e("td",[n._v("locate ls"),e("br"),n._v("首次先要用updatedb初始化一下数据库")])]),e("tr",{staticStyle:{height:"256.50pt"},attrs:{height:"342"}},[e("td",[n._v("find")]),e("td",[n._v("搜索硬盘上的文件")]),e("td",[n._v("\n          -name"),e("br"),n._v("-type d f"),e("br"),n._v("-size"),e("br"),n._v("-newer"),e("br"),n._v("-user"),e("br"),n._v("-group"),e("br"),n._v("-amin"),e("br"),n._v("-atime"),e("br"),n._v("-cmin"),e("br"),n._v("-ctime"),e("br"),n._v("-perm\n        ")]),e("td",[n._v("\n          find / -name man"),e("br"),n._v("\n          find /home -amin -10 十分钟内访问过的文件"),e("br"),n._v("\n          find /home -atime -10 十天内访问过的文件"),e("br"),n._v("\n          find /home -cmin -10 十分中内修改过的文件"),e("br"),n._v("\n          find /home -ctime +10 十天内被改过、新增的文件"),e("br"),n._v("\n          find /home -size +1000c 大于1000bytes的文件"),e("br"),n._v('\n          find /var/log -name "*.log" -mtime +10 |rm -rf '),e("br"),n._v('\n          find /var/log -name "*.log" -mtime +10 |xargs rm -rf'),e("br"),n._v("\n          find . -perm 777 权限是777的所有文件"),e("br"),n._v('\n          find . -path "./test" -prune -o -name "*hello*"'),e("br"),n._v("\n          find . -user mary"),e("br"),n._v("\n          find . -group dev"),e("br"),n._v("\n          find . -newer hello.txt 比hello还要新的文件"),e("br"),n._v("\n          find . ! -newer hello.txt"),e("br"),n._v("\n          find . -type d 找目录"),e("br"),n._v("\n          find . -perm 764 -exec rm {} \\;"),e("br"),n._v("\n          find . -perm 764 -ok rm {} \\;"),e("br"),n._v("\n          find . -perm 764 | xargs rm -f "),e("br"),n._v("\n          find . -name '*a*' -prune 文件名包含a，目录名不包含a"),e("br"),n._v("\n          find . -size +1000c | xargs touch"),e("br"),n._v('\n          find /var -name "boot.log" -type f'),e("br"),n._v('\n          find / -name "ssh" -type d '),e("br"),n._v('\n          find /var/log -name "*.log" -type f'),e("br")])]),e("tr",[e("td",[n._v("命令扩展")]),e("td",[n._v("xargs")]),e("td",[n._v("\n          简单来说，xargs命令就相当于对管道命令进行了一个扩展，让所有命令都支持管道\n        ")]),e("td"),e("td",[n._v('\n          搜索/etc目录下的所有".conf"结尾的文件信息，然后以详细列表形式显示\n          '),e("br"),n._v('\n          find /etc -name "*.conf" | xargs ls -l '),e("br")])]),e("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[e("td",{staticStyle:{height:"81.00pt"},attrs:{rowspan:"3"}},[n._v("查找字符串")]),e("td",[n._v("grep")]),e("td",[n._v("reGulaR ExPression")]),e("td",[n._v("-i 忽略大小写"),e("br"),n._v("-n 显示行号"),e("br"),n._v("-v 取反"),e("br")]),e("td",[n._v("\n          grep 要搜索的关键词 多个文件的名称"),e("br"),n._v('\n          grep "^ma" /etc/passwd'),e("br"),n._v('\n          grep "bash$" /etc/passwd'),e("br"),n._v('\n          grep "^[r|d]" /etc/passwd'),e("br"),n._v('\n          cat redis.conf | grep -v "#" | grep -v "^$"'),e("br"),n._v("\n          grep -n word a.txt | wc -l "),e("br"),n._v("\n          ll -R | grep -n a | wc -l "),e("br")])]),e("tr",[e("td",[n._v("egrep")]),e("td"),e("td"),e("td")]),e("tr",[e("td",[n._v("fgrep")]),e("td"),e("td"),e("td")]),e("tr",{attrs:{height:"36"}},[e("td",{attrs:{height:"36"}},[n._v("显示")]),e("td",[n._v("echo")]),e("td",[n._v("显示、打印")]),e("td",[n._v("-e 使转义符生效")]),e("td",[n._v('\n          echo -e "hello\\tworld"'),e("br"),n._v('echo -e\n          "\\"\\""\n        ')])]),e("tr",[e("td",{staticStyle:{height:"54.00pt"},attrs:{height:"72",rowspan:"3"}},[n._v("用户切换")]),e("td",[n._v("su")]),e("td",[n._v("切换用户")]),e("td",[n._v("- 同时切换目录到用户的家")]),e("td")]),e("tr",[e("td",[n._v("sudo")]),e("td",[n._v("以其他用户的身份执行命令")]),e("td"),e("td",[n._v("只有/etc/sudoers内的用户才有权限执行。用visudo编辑")])]),e("tr",{attrs:{height:"36"}},[e("td",[n._v("visudo")]),e("td",[n._v("用vi编辑/etc/sudoers文件")]),e("td"),e("td",[n._v("\n          在文件中的 root"),e("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("  ")]),n._v("ALL=(ALL)"),e("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("  ")]),n._v("ALL下面加一行："),e("br"),n._v("zhangsan"),e("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("  ")]),n._v("ALL=(ALL)"),e("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("  ")]),n._v("ALL\n        ")])]),e("tr",{attrs:{height:"36"}},[e("td",{staticStyle:{height:"283.50pt"},attrs:{height:"378",rowspan:"7"}},[n._v("进程管理")]),e("td",[n._v("ps")]),e("td",[n._v("查看进程（静态）")]),e("td",[n._v("-e 显示所有进程"),e("br"),n._v("-f 全格式")]),e("td",[n._v("ps -ef")])]),e("tr",[e("td",[n._v("pgrep")]),e("td"),e("td"),e("td",[n._v("类似于ps -ef | grep")])]),e("tr",{staticStyle:{height:"148.50pt"},attrs:{height:"198"}},[e("td",[n._v("top")]),e("td",[n._v("查看进程（动态）")]),e("td",[n._v("\n          -d 指定刷新频率（秒）"),e("br"),n._v("\n          -n 输出n次后退出"),e("br"),n._v("\n          u 显示指定用户进程"),e("br"),n._v("\n          k 杀掉进程"),e("br"),n._v("\n          M（大写）：表示将结果按照内存（MEM）从高到低进行降序排列；"),e("br"),n._v("\n\nP（大写）：，表示将结果按照CPU 使用率从高到低进行降序排列；"),e("br"),n._v("\n\n1 ：当服务器拥有多个cpu 的时候可以使用“1”快捷键来切换是否展示显示各个cpu 的详细信息；"),e("br"),n._v("\n  \nq：退出"),e("br")]),e("td",[n._v("\n           具体参看 07进程检测与控制.pdf  "),e("br"),n._v("\n          第一行的项目依次为当前时间、系统启动时间、当前系统登录用户数目、平均负载（小于0.6较妥,和系统CPU核数相关）。"),e("br"),n._v("\n          第二行为进程情况，依次为进程总数、休眠进程数、运行进程数、僵尸进程数、终止进程数。"),e("br"),n._v("\n          第三行为CPU状态，依次为用户占用、系统占用、优先进程占用、闲置进程占用。"),e("br"),n._v("\n          第四行为内存状态，依次为平均可用内存、已用内存、空闲内存、共享内存、缓存使用内存。"),e("br"),n._v("\n          第五行为交换状态，依次为平均可用交换容量、已用容量、闲置容量、高速缓存容量。"),e("br"),n._v("top\n          -d 1\n        ")])]),e("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[e("td",[n._v("kill")]),e("td",[n._v("杀掉进程")]),e("td",[n._v("-9 强行杀掉进程"),e("br"),n._v("-2 中断进程"),e("br"),n._v("-15 停止进程（默认）")]),e("td",[n._v("kill -9 %1")])]),e("tr",[e("td",[n._v("free")]),e("td",[n._v("查看内存使用情况")]),e("td"),e("td",[n._v("free")])]),e("tr",[e("td",[n._v("nice")]),e("td",[n._v("调整程序的执行优先级")]),e("td"),e("td",[n._v("nice -n -5 find / -name core > /tmp/core")])]),e("tr",[e("td",[n._v("renice")]),e("td",[n._v("调整程序的执行优先级")]),e("td"),e("td",[n._v("通常和ps配合使用")])]),e("tr",[e("td",[n._v("网络")]),e("td",[n._v("ss")]),e("td",[n._v("用于调查套接字的实用程序")]),e("td"),e("td",[n._v("\n          查看ssh 服务运行 的 网络 端口 "),e("br"),n._v("\n          ss -alt | grep ssh\n        ")])]),e("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[e("td",{attrs:{height:"162",rowspan:"5"}},[n._v("硬盘管理")]),e("td",[n._v("df")]),e("td",[n._v("查看磁盘使用情况"),e("br"),n._v("查看目录在哪个分区下")]),e("td",[n._v("-h 以易读方式显示"),e("br"),n._v("-l")]),e("td",[n._v("df"),e("br"),n._v("df /boot/"),e("br"),n._v("df -h")])]),e("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[e("td",[n._v("du")]),e("td",[n._v("查看文件(夹)已有容量")]),e("td",[n._v("\n          -k 以KB输出"),e("br"),n._v("-m 以MB输出"),e("br"),n._v("-s 只列出总量 "),e("br"),n._v("\n          -h ：高可读性\n        ")]),e("td",[n._v("du -m /home"),e("br"),n._v("du -s "),e("br"),n._v("du -sk hello.txt")])]),e("tr",{attrs:{height:"36"}},[e("td",[n._v("fdisk")]),e("td",[n._v("分区"),e("br"),n._v("查看分区的具体情况")]),e("td",[n._v("-l")]),e("td")]),e("tr",[e("td",[n._v("lsblk")]),e("td",[n._v("列出磁盘的使用情况")]),e("td",[n._v(" -f 显示系统信息")]),e("td")]),e("tr",[e("td",[n._v("mke2fs")]),e("td"),e("td"),e("td")]),e("tr",{attrs:{height:"90"}},[e("td",{attrs:{height:"90"}},[n._v("打包")]),e("td",[n._v("tar")]),e("td",[n._v("打包"),e("br"),n._v("解包")]),e("td",[n._v("\n          -z，压缩为.gz格式"),e("br"),n._v("\n          ​ -j，压缩为.bz2格式"),e("br"),n._v("\n          ​ -J，压缩为.xz格式"),e("br"),n._v("\n          ​ -c，create 创建的意思"),e("br"),n._v("\n          ​ -x，解压缩"),e("br"),n._v("\n          ​ -v，显示打包文件过程"),e("br"),n._v("\n          ​ -f，file指定打包的文件名。"),e("br"),n._v("\n          ​ -u，追加更新原打包文件中的文件"),e("br"),n._v("\n          ​ -t，查看打包的文件内容"),e("br"),n._v("\n          ​ -C，指定解压目录"),e("br"),n._v("\n          ​\n        ")]),e("td",[n._v("\n          tar -c mydir > mydir.tar"),e("br"),n._v("tar -cvf test.tar /opt/test"),e("br"),n._v("\n          tar -xvf test.tar"),e("br"),n._v("\n          tar -zcvf hello.tar.gz hello.txt 使用gzip 压缩tar包"),e("br"),n._v("\n          tar -zxvf hello.tar.gz 解压文件"),e("br"),n._v("\n          tar -tf aa.gz 查看aa.gz 内的文件 "),e("br"),n._v("\n          tar -uf aa.gz a.js 追加 文件 "),e("br")])]),e("tr",{attrs:{height:"36"}},[e("td",{attrs:{height:"234",rowspan:"9"}},[n._v("压缩")]),e("td",[n._v("gzip")]),e("td",[n._v("压缩")]),e("td",[n._v("-d 解压缩")]),e("td",[n._v("gzip hello.tar"),e("br"),n._v("gzip -d hello.tar.gz")])]),e("tr",[e("td",[n._v("gunzip")]),e("td",[n._v("解压缩")]),e("td"),e("td",[n._v("gunzip hello.tar.gz")])]),e("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[e("td",[n._v("zip")]),e("td",[n._v("压缩")]),e("td",[n._v("-r 文件夹，递归")]),e("td",[n._v("\n          zip file.zip *"),e("br"),n._v("zip m file.zip to.txt"),e("br"),n._v("zip -r file.zip *\n        ")])]),e("tr",{attrs:{height:"36"}},[e("td",[n._v("unzip")]),e("td",[n._v("解压")]),e("td",[n._v("-d 指定解压目录")]),e("td",[n._v("unzip hello.zip -d /usr/local/aa/zz"),e("br"),n._v("unzip -v hello.zip")])]),e("tr",[e("td",[n._v("zcat")]),e("td",[n._v("显示压缩文件的内容")]),e("td"),e("td")]),e("tr",[e("td",[n._v("zmore")]),e("td",[n._v("显示压缩文件的内容")]),e("td"),e("td")]),e("tr",[e("td",[n._v("zless")]),e("td",[n._v("显示压缩文件的内容")]),e("td"),e("td")]),e("tr",[e("td",[n._v("zgrep")]),e("td",[n._v("查找压缩文件的内容")]),e("td"),e("td")]),e("tr",[e("td",[n._v("zdiff")]),e("td",[n._v("比较压缩文件的不同")]),e("td"),e("td")]),e("tr",{attrs:{height:"36"}},[e("td",{staticStyle:{height:"229.50pt"},attrs:{height:"306",rowspan:"5"}},[n._v("安装")]),e("td",[n._v("gcc")]),e("td",[n._v("编译")]),e("td",[n._v("-o 指定目标文件")]),e("td",[n._v("gcc hello.c"),e("br"),n._v("gcc -o hello.o *.c")])]),e("tr",{attrs:{height:"36"}},[e("td",[n._v("configure")]),e("td",[n._v("生成makefile文件")]),e("td",[n._v("--help"),e("br"),n._v("-h 帮助说明")]),e("td",[n._v("./configure --help")])]),e("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[e("td",[n._v("make")]),e("td",[n._v("编译")]),e("td"),e("td",[n._v("\n          make 编译生成目标文件、可执行文件"),e("br"),n._v("make install 安装程序"),e("br"),n._v("make\n          clean 去除目标文件\n        ")])]),e("tr",{staticStyle:{height:"81.00pt"}},[e("td",[n._v("rpm")]),e("td",[n._v("软件包管理器")]),e("td",[n._v("\n          -ivh 安装"),e("br"),n._v("\n          -Uvh 升级"),e("br"),n._v("\n          -e 卸载"),e("br"),n._v("\n          -a 所有 "),e("br"),n._v("\n          -e --nodeps强卸"),e("br"),n._v("\n          -q 查询"),e("br"),n._v("\n          -i：install，安装"),e("br"),n._v("\n          -v：显示进度条"),e("br"),n._v('\n          -h：表示以"#"形式显示进度条'),e("br"),n._v("\n          -V 验证\n        ")]),e("td",[e("a",{attrs:{href:"http://rpm.pbone.net",target:"_blank",rel:"noopener noreferrer"}},[n._v("http://rpm.pbone.net")]),e("br"),n._v("\n          rpm -qa 列出所有安装过的套件和版本"),e("br"),n._v("\n          rpm -qi 列出这个套件的详细信息"),e("br"),n._v("\n          rpm -ql 列出这个套件安装后的文件和路径"),e("br"),n._v("\n          rpm -qf 查询某文件属于那一个套件\n        ")])]),e("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[e("td",[n._v("yum")]),e("td"),e("td"),e("td",[n._v("\n          yum search raid"),e("br"),n._v("yum info mdadm"),e("br"),n._v("yum list aa*"),e("br"),n._v("yum -y\n          install pam-devel"),e("br")])]),e("tr",[e("td",[n._v("\n          系统控制 "),e("br"),n._v("\n          服务管理\n        ")]),e("td",[n._v("systemctl")]),e("td",{attrs:{colspan:"2"}},[n._v("\n          systemctl list-units --type service --all"),e("br"),n._v("\n          systemctl list-units --type service | grep sshd"),e("br")]),e("td",[n._v("\n          systemctl status network "),e("br"),n._v("\n          systemctl start network "),e("br"),n._v("\n          systemctl stop network "),e("br"),n._v("\n          systemctl restart network "),e("br"),n._v("\n          systemctl reload crond "),e("br"),n._v("\n          systemctl enable crond "),e("br"),n._v("\n          systemctl disable crond "),e("br")])]),e("tr",[e("td",{staticStyle:{height:"135.00pt"},attrs:{height:"180",rowspan:"2"}},[n._v("系统服务")]),e("td",[n._v("chkconfig")]),e("td",[n._v("开机自动启停服务")]),e("td",[n._v("--list 列出所有服务"),e("br"),n._v("--add 添加服务"),e("br"),n._v("--del 删除服务")]),e("td",[n._v("\n          chkconfig vsftpd on"),e("br"),n._v("chkconfig sshd on"),e("br"),n._v("chkconfig iptables\n          off"),e("br"),n._v("chkconfig --add httpd"),e("br"),n._v("chkconfig --del httpd"),e("br"),n._v("chkconfig\n          --level 35 httpd on\n        ")])]),e("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[e("td",[n._v("service")]),e("td",[n._v("立即启停服务")]),e("td",[n._v("start 启动"),e("br"),n._v("stop 停止"),e("br"),n._v("restart 重启"),e("br"),n._v("status 查看")]),e("td",[n._v("\n          service network restart"),e("br"),n._v("service iptables stop"),e("br"),n._v("service vsftpd\n          start"),e("br"),n._v("service iptables status\n        ")])]),e("tr",[e("td",{attrs:{rowspan:"3"}},[n._v("常用自有服务")]),e("td",[n._v("ntp")]),e("td",[n._v("用于同步计算机的系统时间的服务")]),e("td",[n._v("\n          ntpd服务配置文件位置 /etc/ntp.conf "),e("br"),n._v("\n          NTP授时网站： "),e("br"),n._v("\n          http://www.ntp.org.cn/pool.php "),e("br")]),e("td",[n._v("\n          ntpdate NTP服务器的IP地址或域名 "),e("br"),n._v("\n          自动同步 启动ntpd服务 "),e("br"),n._v("\n          #systemctl start ntpd "),e("br"),n._v("\n          #systemctl enable ntpd "),e("br")])]),e("tr",[e("td",[n._v("firewalld")]),e("td",[n._v("防火墙服务")]),e("td",[n._v("\n          区域概念 "),e("br"),n._v("\n          block dmz drop external home internal public trusted work\n        ")]),e("td",[n._v("\n          firewall-cmd 选项"),e("br"),n._v("\n          #firewall-cmd --get-zones"),e("br"),n._v("\n          含义：查看所有可用区域"),e("br"),n._v("\n          #firewall-cmd --get-default-zone"),e("br"),n._v("\n          含义：查看默认使用区域，当前默认使用区域为public"),e("br"),n._v("\n          #firewall-cmd --list-all"),e("br"),n._v("\n          含义：查看所有可用区域"),e("br"),n._v("\n          #firewall-cmd --list-all-zones"),e("br"),n._v("\n          含义：查看所有可用区域"),e("br"),n._v("\n          #firewall-cmd --zone=public --add-port=1024/tcp"),e("br"),n._v("\n          含义:在public区域，添加允许tcp协议的1024端口通过的规则"),e("br"),n._v("\n          #firewall-cmd --zone=public --add-service=ftp"),e("br"),n._v("\n          含义:在public区域，添加允许ftp服务通过的规则"),e("br"),n._v("\n          #firewall-cmd --zone=public --remove-port=1024/tcp"),e("br"),n._v("\n          含义:在public区域，去掉允许tcp协议的1024端口通过的规则"),e("br"),n._v("\n          #firewall-cmd --zone=public --remove-service=ftp"),e("br"),n._v("\n          含义:在public区域，去掉允许ftp服务通过的规则"),e("br"),n._v("\n          #firewall-cmd --permanent --zone=public --add-port=1024/tcp"),e("br"),n._v("\n          含义:在public区域，使用permanent参数，永久添加允许1024端口通过的规则"),e("br"),n._v("\n          #firewall-cmd --reload"),e("br"),n._v("\n          含义:重新加载配置"),e("br")])]),e("tr",[e("td",[n._v("crond")]),e("td",[n._v("计划任务服务")]),e("td"),e("td")]),e("tr",{attrs:{height:"36"}},[e("td",{staticStyle:{height:"202.50pt"},attrs:{height:"270",rowspan:"9"}},[n._v("任务计划")]),e("td",[n._v("tab键")]),e("td",[n._v("命令自动补全")]),e("td"),e("td",[n._v("按一下会自动展开；"),e("br"),n._v("按两下会列出所有命令")])]),e("tr",[e("td",[n._v("nohup")]),e("td",[n._v("不挂断的运行")]),e("td"),e("td")]),e("tr",[e("td",[n._v("&")]),e("td",[n._v("后台运行")]),e("td"),e("td",[n._v("command &")])]),e("tr",[e("td",[n._v("Ctrl+Z")]),e("td",[n._v("后台运行")]),e("td"),e("td")]),e("tr",[e("td",[n._v("jobs")]),e("td",[n._v("列出作业")]),e("td"),e("td")]),e("tr",[e("td",[n._v("fg")]),e("td",[n._v("前台")]),e("td",[n._v("%number 表示jobs的"),e("span",{},[n._v("工作代号")])]),e("td",[n._v("fg %2 后台程序切到前台")])]),e("tr",[e("td",[n._v("bg")]),e("td",[n._v("后台")]),e("td",[n._v("%number 表示jobs的"),e("span",{},[n._v("工作代号")])]),e("td",[n._v("bg %1 将Stopped状态的后台程序改为Running状态")])]),e("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[e("td",[n._v("at")]),e("td",[n._v("一次性运行的任务计划")]),e("td",[n._v("\n          systemctl start atd  "),e("br"),n._v("\n          -f 要提交的脚本"),e("br"),n._v("\n        -r 清除"),e("br"),n._v("\n        -l 罗列"),e("br"),n._v("\n         atq 查看没有执行的计划任务"),e("br"),n._v("\n         atrm 任务号 删除指定的计划任务"),e("br")]),e("td",[n._v("\n          at 3:00pm tomorrow -f /home/wuxh/hello.sh"),e("br"),n._v("\n          at now + 5 minutes\n        ")])]),e("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[e("td",[n._v("crontab")]),e("td",[n._v("循环运行的任务计划")]),e("td",[n._v("\n          -l：list，列出指定用户的计划任务列表 "),e("br"),n._v("\n          -e：edit，编辑指定用户的计划任务列表 "),e("br"),n._v("\n          -u：user，指定的用户名，如果不指定，则表示当前用户 "),e("br"),n._v("\n          -r：remove，删除指定用户的计划任务列表 "),e("br"),n._v("\n          黑名单==配置文件位于：`/etc/cron.deny "),e("br"),n._v("\n          白名单==配置文件位于：/etc/cron.allow  "),e("br"),n._v("\n          日志文件位于`/var/log/cron` "),e("br")]),e("td",[n._v("\n          格式： "),e("br"),n._v("\n          四个符号："),e("br"),n._v("\n          *：表示取值范围中的每一个数字"),e("br"),n._v("\n          -：做连续区间表达式的，要想表示1~7，则可以写成：1-7"),e("br"),n._v("\n          /：表示每多少个，例如：想每 10 分钟一次，则可以在分的位置写：*/10"),e("br"),n._v("\n          ,：表示多个取值，比如想在 1 点，2 点 6\n          点执行，则可以在时的位置写：1,2,6"),e("br"),n._v("\n          分 时 日 月 周 需要执行的命令"),e("br"),n._v("\n          问题1：每月1、10、22 日的4:45 重启network 服务"),e("br"),n._v("\n          问题1：45 4 1,10,22 * * service network restart"),e("br"),n._v("\n          问题2：每周六、周日的1:10 重启network 服务"),e("br"),n._v("\n          问题2：10 1 * * 6,7 service network restart"),e("br"),n._v("\n          问题3：每天18:00 至23:00 之间每隔30 分钟重启network 服务"),e("br"),n._v("\n          问题3：*/30 18-23 * * * service network restart"),e("br"),n._v("\n          问题4：每隔两天的上午8 点到11 点的第3 和第15 分钟执行一次重启"),e("br"),n._v("\n          问题4：3,15 8-11 */2 * * reboot"),e("br")])]),e("tr",{attrs:{height:"36"}},[e("td",{staticStyle:{height:"1458.75pt"},attrs:{height:"1945",rowspan:"45"}},[n._v("\n          Bash\n        ")]),e("td",[n._v("bash")]),e("td",[n._v("执行脚本")]),e("td"),e("td",[n._v("bash helloworld.sh"),e("br"),n._v("./w.sh")])]),e("tr",{attrs:{height:"36"}},[e("td",[n._v("重定向符 >")]),e("td",[n._v("标准输出")]),e("td"),e("td",[n._v("\n          command > out.file 2>&1 &"),e("br"),n._v("command 2> err.txt\n          >&2\n        ")])]),e("tr",[e("td",[n._v("重定向符 >>")]),e("td",[n._v("追加")]),e("td"),e("td",[n._v("cal >> c.txt")])]),e("tr",[e("td",[n._v("重定向符 2>")]),e("td",[n._v("标准错误")]),e("td"),e("td",[n._v("ls ddd 2> /dev/null")])]),e("tr",[e("td",[n._v("重定向符 <")]),e("td"),e("td"),e("td",[n._v("sort < name.txt > name.out")])]),e("tr",[e("td",[n._v("重定向符 <<")]),e("td"),e("td"),e("td")]),e("tr",{attrs:{height:"90"}},[e("td",[n._v("正则表达式")]),e("td",{attrs:{colspan:"2"}},[n._v("\n          . 匹配任意字符"),e("br"),n._v("^ 匹配行首"),e("br"),n._v("$ 匹配文件尾"),e("br"),n._v("[]\n          匹配字符组之一"),e("br"),n._v("* 匹配0到n个字符"),e("br"),n._v("\\{min,max\\}"),e("br"),n._v("\\(…\\)\n        ")]),e("td",[n._v("\n          XXX* 匹配至少两个连续的X"),e("br"),n._v("X\\{1,10\\} 匹配1到10个连续的X"),e("br"),n._v("^\\(.\\)\n          匹配行首的第一个字符（不管是什么）"),e("br"),n._v("^\\(.\\).*\\1$\n          匹配一行中的头一个字符和最后一个字符相同的行\n        ")])]),e("tr",[e("td",[n._v("管道符 |")]),e("td"),e("td"),e("td")]),e("tr",{attrs:{height:"36"}},[e("td",[n._v("双引号")]),e("td",[n._v("引用字符串,但对$,`,\\敏感")]),e("td",[n._v('""')]),e("td",[n._v('echo "$$"'),e("br"),n._v('echo "\\$$"')])]),e("tr",[e("td",[n._v("单引号")]),e("td",[n._v("引用字符串，对特殊字符不敏感")]),e("td",[n._v("''")]),e("td",[n._v("echo '$$'")])]),e("tr",[e("td",[n._v("反引号")]),e("td",[n._v("将反引号内的字符串作为命令")]),e("td",[n._v("``")]),e("td",[n._v("echo `date`")])]),e("tr",{attrs:{height:"90"}},[e("td",[n._v("命令集")]),e("td",[n._v("一行中执行多个命令")]),e("td",[n._v("\n          ; 顺序执行"),e("br"),n._v("&& 前面成功后续才执行"),e("br"),n._v("||\n          前面失败后续才执行\n        ")]),e("td",[n._v("ls;ls"),e("br"),n._v("ls&&ls"),e("br"),n._v("ls||ls")])]),e("tr",{staticStyle:{height:"135.00pt"},attrs:{height:"180"}},[e("td",[n._v("变量")]),e("td",{attrs:{colspan:"2"}},[n._v("\n          位置变量"),e("br"),n._v("$$ 脚本当前进程ID"),e("br"),n._v("$! 后台运行的最后一个进程的ID"),e("br"),n._v("$?\n          命令的退出状态（0表示成功，1表示失败）"),e("br"),n._v("$# 传递到脚本的参数个数"),e("br"),n._v("$*\n          以一个单字符串的形式显示所有向脚本传递的参数"),e("br"),n._v("$@\n          与$*相同，但是使用时加引号，并在引号中返回每个参数"),e("br"),n._v("$_ 就是set命令\n        ")]),e("td",[n._v("\n          观察$*和$@的不同："),e("br"),n._v('for i in "$*"'),e("br"),n._v("do"),e("br"),e("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("  ")]),n._v("echo $i"),e("br"),n._v("done"),e("br"),e("br"),n._v('for i in "$@"'),e("br"),n._v("do"),e("br"),e("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("  ")]),n._v("echo $i"),e("br"),n._v("done\n        ")])]),e("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[e("td",[n._v("wc")]),e("td",[n._v("统计字数")]),e("td",[n._v("\n          -l：表示lines，行数"),e("br"),n._v("\n          -w：表示words，单词数 量"),e("br"),n._v("\n          -c：表示bytes，字节数 "),e("br")]),e("td",[n._v("\n          cat /etc/passwd | wc -l "),e("br"),n._v("\n          wc -lwc ./* "),e("br"),n._v("\n          wc -l a.txt\n        ")])]),e("tr",{attrs:{height:"36"}},[e("td",[n._v("sleep")]),e("td",[n._v("等待")]),e("td"),e("td",[n._v("sleep 5 暂停5秒"),e("br"),n._v("usleep 500 这个单位是纳秒")])]),e("tr",[e("td",[n._v("read")]),e("td",[n._v("从键盘读入信息到变量中")]),e("td"),e("td",[n._v("read name")])]),e("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[e("td"),e("td",[n._v("变量赋值")]),e("td"),e("td",[n._v('\n          PATH="$PATH":/root'),e("br"),n._v("LANG=C"),e("br"),n._v("LANG=zh_CN.gb2312"),e("br"),n._v("PS1='[\\u@\\h\n          \\W]\\$ '\n        ")])]),e("tr",{attrs:{height:"36"}},[e("td",[n._v("set")]),e("td",[n._v("显示当前shell的变量，包括当前用户的变量（即环境变量）")]),e("td"),e("td",[n._v("set")])]),e("tr",[e("td",[n._v("unset")]),e("td",[n._v("删除变量")]),e("td"),e("td",[n._v("unset i")])]),e("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[e("td",[n._v("export")]),e("td",[n._v("\n          把变量即刻导入到当前的用户环境中（被export的变量叫环境变量），这时可以在env中看到\n        ")]),e("td",[n._v("环境变量相当可以被子进程使用，其他变量不行。")]),e("td",[n._v("export LANG=C"),e("br"),n._v("export LC_ALL=en")])]),e("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[e("td",[n._v("env")]),e("td",[n._v("显示当前用户环境的变量（被export的变量可以用env查看到）")]),e("td"),e("td",[n._v("env")])]),e("tr",{attrs:{height:"36"}},[e("td",[n._v("alias")]),e("td",[n._v("命令别名")]),e("td"),e("td",[n._v("alias ll"),e("br"),n._v("alias l=ls -la")])]),e("tr",[e("td",[n._v("unalias")]),e("td",[n._v("取消命令别名")]),e("td"),e("td",[n._v("unlias l")])]),e("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[e("td",[n._v("sort")]),e("td",[n._v("对文件内容做排序")]),e("td",[n._v("-n 以数字排序"),e("br"),n._v("-r 反向排序"),e("br"),n._v("-u 同样的只出现一次")]),e("td",[n._v("sort -n name.txt")])]),e("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[e("td",[n._v("cut")]),e("td",[n._v("提取字符串")]),e("td",[n._v("-c 字符"),e("br"),n._v("-d 分隔符"),e("br"),n._v("-f 字段")]),e("td",[n._v('\n          cat /etc/passwd | cut -d ":" -f1'),e("br"),n._v('last | cut -d "\n          " -f1 列出第一个区块'),e("br"),n._v("who | cut -c1-8,18-\n          每行的1-8个字符和第18行到行尾"),e("br"),n._v("cut -d: -f1,6 /etc/passwd\n        ")])]),e("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[e("td",[n._v("paste")]),e("td",[n._v("和cut相反的命令，合并行")]),e("td",[n._v("-d 指定合并的分隔符"),e("br"),n._v("-s 把文件内的所有行合并为一行")]),e("td",[n._v("\n          paste names numbers 把两个文件的每行都分别合起来"),e("br"),n._v("paste -d'+'\n          names addresses numbers"),e("br"),n._v("paste -s names"),e("br"),n._v("ls | paste -d' ' -s\n        ")])]),e("tr",{attrs:{height:"36"}},[e("td",[n._v("join")]),e("td",[n._v("把两个文件中相同的行连起来")]),e("td"),e("td",[n._v("\n          join -t ':' /etc/passwd /etc/shadow"),e("br"),n._v("join -t ':' -1 4 /etc/passwd\n          -2 3 /etc/group\n        ")])]),e("tr",{staticStyle:{height:"148.50pt"},attrs:{height:"198"}},[e("td",[n._v("sed")]),e("td",[n._v("Stream Editor流编辑器")]),e("td",[n._v("-n")]),e("td",[n._v("\n          sed 's/Unix/UNIX/' myFile\n          把Unix换成UNIX（没改原文件），但只改动每行的第一个改掉"),e("br"),n._v("sed\n          's/Unix/UNIX/g' myfile > temp.txt 把每行的所有Unix都换成UNIX"),e("br"),n._v("sed\n          '1,2d' myfile 删除第1、2行"),e("br"),n._v("sed '/[Tt]est/d'\n          删除含test或Test的行"),e("br"),n._v("sed '/jan/s/fds/abc/'\n          将所有包含了jan的行中第1个fds改为abc"),e("br"),n._v("sed -n '20,25p' text\n          只显示第20到25行"),e("br"),n._v("sed 's/…//' data 删除文件中每行的前3个字符"),e("br"),n._v("sed\n          's/…$//' data 删除文件中每行的最后3个字符\n        ")])]),e("tr",[e("td",[n._v("awk")]),e("td"),e("td"),e("td",[e("span",{staticStyle:{"mso-spacerun":"yes"}}),n._v("通过正则匹配，切割，提取需要的值"),e("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("  ")])])]),e("tr",[e("td",[n._v("diff")]),e("td",[n._v("比较两个文件的不同")]),e("td"),e("td",[n._v("diff file1 file2")])]),e("tr",{attrs:{height:"36"}},[e("td",[n._v("uniq")]),e("td",[n._v("删除重复行从而只显示一个")]),e("td"),e("td",[n._v('\n          last | cut -d " " -f1 | sort | uniq'),e("br"),n._v("查看这个月登录主机的用户都有谁\n        ")])]),e("tr",[e("td",[n._v("source")]),e("td",[n._v("执行脚本")]),e("td"),e("td",[n._v("source helloworld.sh")])]),e("tr",[e("td",[n._v("tee")]),e("td",[n._v("输出到文件的同时显示在屏幕上")]),e("td",[n._v("-a 追加到末尾")]),e("td")]),e("tr",{attrs:{height:"36"}},[e("td",[n._v("tr")]),e("td",[n._v("替换指定内容")]),e("td",[n._v("-d 删除指定串"),e("br"),n._v("-s 替换重复字符")]),e("td",[n._v("\n          cat dostxt | tr -d '\\r' > dostxt-noM "),e("br"),n._v("去掉文件中的DOS下的 ^M\n          断行符\n        ")])]),e("tr",{attrs:{height:"36"}},[e("td",[n._v("split")]),e("td",[n._v("分割文件")]),e("td",[n._v("-b 以文件size分"),e("br"),n._v("-l 以行数分")]),e("td",[n._v("split -l 5 /etc/passwd test")])]),e("tr",[e("td",{attrs:{rowspan:"3"}},[n._v("test")]),e("td",[n._v("测试文件")]),e("td"),e("td")]),e("tr",[e("td",[n._v("测试字符串")]),e("td"),e("td")]),e("tr",[e("td",[n._v("测试数值")]),e("td"),e("td")]),e("tr",{attrs:{height:"36"}},[e("td",[n._v("expr")]),e("td"),e("td"),e("td",[n._v("\n          expr 10 + 10 只算整数，真正的计算要用bc（计算器）"),e("br"),n._v("expr 3 \\* 7\n          乘号要转义\n        ")])]),e("tr",{staticStyle:{height:"108.00pt"},attrs:{height:"144"}},[e("td",[n._v("函数")]),e("td"),e("td"),e("td",[n._v("\n          下例可以看出$*和$@的区别："),e("br"),n._v("function testargs"),e("br"),n._v("{"),e("br"),e("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("        ")]),n._v('echo "There is $# args"'),e("br"),e("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("        ")]),n._v("echo $10"),e("br"),n._v("}"),e("br"),n._v('testargs "$*"'),e("br"),n._v('testargs\n          "$@"\n        ')])]),e("tr",[e("td",{attrs:{rowspan:"2"}},[n._v("条件判断")]),e("td",[n._v("if")]),e("td"),e("td")]),e("tr",[e("td",[n._v("case")]),e("td"),e("td")]),e("tr",[e("td",{attrs:{rowspan:"3"}},[n._v("循环")]),e("td",[n._v("while … do … done")]),e("td"),e("td")]),e("tr",[e("td",[n._v("until … do … done")]),e("td"),e("td")]),e("tr",{staticStyle:{height:"14.25pt"},attrs:{height:"19"}},[e("td",[n._v("for … do … done")]),e("td"),e("td")])])])}],o={data:function(){return{}}},l=o,p=(e("388d"),e("2877")),c=Object(p["a"])(l,s,a,!1,null,"6dc905ba",null),d=c.exports,u=function(){var n=this,r=n.$createElement,e=n._self._c||r;return e("div",[e("div",{},[e("q-markdown",{attrs:{src:n.MainComponent}})],1)])},m=[],g="\x3c!--\r\n * @Date           : 2021-07-10 01:26:52\r\n * @FilePath       : /jinnian-space/src/pages/linux/md/linux-其他.md\r\n * @Description    : \r\n--\x3e\r\n\r\n \r\n\r\n## **CentOS7防火墙firewalld，常见区域及相应策略规则**\r\n\r\n| 区域     | 默认策略                                                     |\r\n| -------- | ------------------------------------------------------------ |\r\n| trusted  | 允许所有数据包                                               |\r\n| home     | 拒绝流入的流量，除非与流出的流量相关，允许ssh,mdns,ippclient,amba-client,dhcpv6-client服务通过 |\r\n| internal | 等同于home                                                   |\r\n| work     | 拒绝流入的流量，除非与流出的流量相关，允许ssh,ipp-client,dhcpv6-client服务通过 |\r\n| public   | 拒绝流入的流量，除非与流出的流量相关，允许ssh,dhcpv6-client服务通过 |\r\n| external | 拒绝流入的流量，除非与流出的流量相关，允许ssh服务通过        |\r\n| dmz      | 拒绝流入的流量，除非与流出的流量相关，允许ssh服务通过        |\r\n| block    | 拒绝流入的流量，除非与流出的流量相关，非法流量采取拒绝操作   |\r\n| drop     | 拒绝流入的流量，除非与流出的流量相关，非法流量采取丢弃操作   |\r\n",_={data:function(){return{MainComponent:g}}},h=_,v=Object(p["a"])(h,u,m,!1,null,"1373d8e8",null),x=v.exports,f=function(){var n=this,r=n.$createElement,e=n._self._c||r;return e("div",{},[e("div",[n._v("SHELL")]),e("pre",[n._v('     shell 中 变量赋值 单引号是 字符 双引号是可以解析变量的  $() 是代表可执行命令 或者 模板插值符号反引号也一样\n     shell 中 0 为 真  1 为假 \n     readonly  只读变量\n     unset 删除变量\n     数组： \n        定义：arr=(1 2  3  4  8) \n        赋值: arr[0]=99\n        获取：${arr[1]}\n        获取长度：${#arr[*]}   ${#arr[@]}\n    num1= `expr 2 + 2`  数学运算表达式  expr\n     自增：  e=1  ;  ((e++))  \n     字符串比较 返回布尔值  0 为真 1 为假的: 前后带空格  中间带空格\n        [ $a = $b ]  [ $a != $b ]  是否为0  [ -z $a ]   是否非0  [ -n "$a" ]  是否为空 [ $a ] \n        [ "${a}" = "${b}" ]  [ $a != $b ]  是否为0  [ -z "${a}" ]   是否非0  [ -n "${a}" ]  是否为空 [ $"{$a}" ] \n     $? 获取 上一条 语句的 执行结果   \n     字符串长度  ${#a}\n     关系运算符 只支持数字 ，不支持字符串，除非字符串的值是数字：\n      \n      [ $a -eq $b]   等于 -eq  不等于  -ne  大于 -gt 小于 -lt 大于等于 -ge  小于等于 -le  \n    shell 布尔运算：\n        ! 求反 [ !false]     [ !  $a -lt 20 ]        返回 true    \n        -o or   或运算  [ $a -lt 20 -o $b -gt 100]\n        -a and  与运算  [ $a -lt 20 -a $b -gt 100]\n        &&  逻辑and    [[ true && true ]]   [[ "${a}" -lt 100 && "${b}" -gt 100 ]]\n        ||  逻辑或者    [[ true || true ]]\n    if[条件];then;语句体；fi       ,,,,  if[] then fi  ,,,,if[] then  elif[] else fi \n\n    if [ $(ps -ef | grep -c "ssh") -gt 1] \n\n\n  ')]),e("q-separator"),e("q-markdown",{attrs:{src:n.MainComponent}})],1)},b=[],w='\x3c!--\r\n * @Date           : 2021-01-29 00:52:36\r\n * @FilePath       : /jinnian-space/src/pages/linux/md/shell.md\r\n * @Description    : \r\n--\x3e\r\n## shell\r\n​\t***\\*S\\*******\\*hell程序设计\\****\t\r\n\r\n一、 什么是shell?\r\n\r\n​\tShell是一个作为用户与Linux系统间接口的程序，它允许用户向操作系统输入需要执行的命令。在一个linux系统中可以安装多个shell，这些shell和其他程序一起环绕在linux内核四周。默认安装的标准是/bin/sh，它是GNU工具集中的bash。使用/bin/bash –version可以查看版本。\r\n\r\nShell 历史版本：sh  csh,、tcsh、 zsh  ksh、pdksh  bash\r\n\r\n二、 shell脚本编写、运行、调试\r\n\r\n\\1. 脚本均以 #!/bin/bash开头。\r\n\r\n\\2. 脚本中的 ‘#’为注释符。\r\n\r\n\\3. 使用exit为脚本设置返回一个退出码，注意 0 表示的是执行成功。\r\n\r\n示例：\r\n\r\n \\#!/bin/bash\r\n\r\n \\# this is my first shell! \r\n\r\n echo  “helloword!”\r\n\r\n exit 0\r\n\r\n \r\n\r\n\\4. 设置脚本为可执行： chmod u+x filename.sh\r\n\r\n\\5. 执行：./filename.sh\r\n\r\n\\6. sh –x ./filename.sh\r\n\r\n三、 shell语法\r\n\r\n**1、** ***\\*变量\\****：无需事先声明，直接使用，在访问时要加$在变量前。\r\n\r\n例如：\r\n\r\nStr=hello\r\n\r\necho  $Str \r\n\r\na.这两行语句将在屏幕输出一个“hello”，shell区别大小写，定义变量时应该注意。\r\n\r\nb.如果为变量所赋的字符串中含有空格，table或换行符应使用“”标示，例如 “hello  word!”\r\n\r\nc.变量在引号中依然有效如echo “this  is  $Str！”依然会输出：this  is  hello！\r\n\r\n练习示例：(注:后续的示例中只有关键部分，练习时补全)\r\n\r\necho “input  password:”\r\n\r\nread pasd\r\n\r\necho “the password is $pasd”\r\n\r\nd.如果需要输出字符$Str可以用单引号 和 \\来处理：\r\n\r\n ‘$Str’ 和\\$Str 输出的都是 $Str不是变量表示的值，shell中的变量一般都是字符串形式。\r\n\r\ne: 环境变量，介绍几种：\r\n\r\n$HOME  当前用户的家目录 \r\n\r\n$PATH   搜索命令的目录列表\r\n\r\n$0\t\t\tshell脚本的名字\r\n\r\n$#\t\t\t传递给脚本的参数个数\r\n\r\n$$\t\t\t脚本的进程号\r\n\r\nf:参数变量：\r\n\r\n$1,$2脚本的程序参数\r\n\r\n$*   列出所有参数\r\n\r\n$@   S*的一种变体，它参数不会挤在一块。\r\n\r\ng:变量做整形数字使用：\r\n\r\na=123\r\n\r\nlet “a +=1”\r\n\r\necho “a = $a”\r\n\r\n**2、** ***\\*条件\\****\r\n\r\n1) 使用 test 或 [ ]\r\n\r\n如  if test –f file.c\r\n\r\nthen\r\n\r\n…..\r\n\r\nfi\r\n\r\n​    以上代码也可写成如下形式(尽量使用这种形式)\r\n\r\n​     if [ -f file.c ]  (注意:if语句和[之间有个空格]\r\n\r\n​    then\r\n\r\n​     ….\r\n\r\n​     fi\r\n\r\n完整示例：\r\n\r\n\\#!/bin/bash\r\n\r\necho  “is  it  morning? Please  answer  yes  or  no”\r\n\r\nread  timeofday\r\n\r\nif [ $timeofday = “yes” ] ;then\r\n\r\n  echo  “good morning”\r\n\r\nelse\r\n\r\n  echo  “good afternoon”\r\n\r\nfi\r\n\r\nexit 0\r\n\r\n2) elif语句，在if，else语句中增加分支判断。如下示例：\r\n\r\n  \\#!/bin/bash\r\n\r\necho  “is  it  morning? Please  answer  yes  or  no”\r\n\r\nread  timeofday\r\n\r\nif [ $timeofday = “yes” ] ;then\r\n\r\n   echo  “good morning”\r\n\r\nelif [ $timeofday = “no” ]\r\n\r\nthen\r\n\r\n  echo “Good afternoon”\r\n\r\nelse\r\n\r\n  echo “sorry ,$timeofday not recognized. Enter yes or no”\r\n\r\n  exit 1\r\n\r\nfi\r\n\r\nexit 0\r\n\r\n**3、** ***\\*一个与变量有关的问题。\\****\r\n\r\n如上程序，如果没有输入Yes和no直接按回车键，会出现什么结果呢？程序会有出错信息。原因是。。。避免该问题产生的方法对变量使用双引号“$Str”\r\n\r\n**4、** ***\\*for语句\\****\r\n\r\n使用for语句可以循环处理一组值，这组值可以是任意字符串的集合。 它的语法形式如下：\r\n\r\n***\\*for\\**** variable  ***\\*in\\**** values\r\n\r\n***\\*do\\****\r\n\r\n  something\r\n\r\n***\\*done\\****\r\n\r\n 示例：\r\n\r\n  \\#!/bin/bash\r\n\r\n  For foo in hello myname 129\r\n\r\n  do\r\n\r\n   echo $foo\r\n\r\n  done\r\n\r\n  exit 0\r\n\r\n使用通配符扩展for循环\r\n\r\n\\#!/bin/sh\r\n\r\nfor file in $(ls  *.sh);do\r\n\r\n echo $file\r\n\r\ndone\r\n\r\nexit 0\r\n\r\n***\\*5、while语句\\****\r\n\r\n语法结构：\r\n\r\n***\\*while\\**** condition ***\\*do\\****\r\n\r\nDosometing\r\n\r\n***\\*done\\****\r\n\r\n示例：一个简陋的密码检查程序\r\n\r\n\\#!/bin/bash\r\n\r\necho  “Enter password”\r\n\r\nread  paword\r\n\r\nwhile  [ “$paword” != “secret” ] \r\n\r\ndo\r\n\r\n  echo “sorry, try again ”\r\n\r\n  read paword \r\n\r\ndone\r\n\r\nexit 0\r\n\r\n字符串比较:\r\n\r\nstring = string  \r\n\r\nstring != string\r\n\r\n-n string\r\n\r\n-z string \r\n\r\n 算数比较\r\n\r\n num1 –eq  num2 \r\n\r\n num1 –ne  num2\r\n\r\n \r\n\r\n***\\*6、until语句,与while循环类似，只是把测试条件反过来了。\\****\r\n\r\n语法形式如下：\r\n\r\n***\\*until\\**** condition\r\n\r\n***\\*do\\****\r\n\r\n  Dosomething\r\n\r\n***\\*done\\****\r\n\r\n***\\*7、case语句\\****\r\n\r\n***\\*语法结构:\\****\r\n\r\n***\\*case\\****  variable ***\\*in\\****\r\n\r\npattern1 [ ***\\*|\\**** pattern] …***\\*)\\****  dosomething ***\\*;;\\****\r\n\r\npattern2 [ ***\\*|\\**** pattern] …***\\*)\\****  dosomething ***\\*;;\\****\r\n\r\n***\\*esac\\****\r\n\r\n该语句 执行 vairable与第一个pattern匹配上的语句。\r\n\r\n例如：\r\n\r\n\\#!/bin/bash\r\n\r\necho “is it morning? Please answer yes or no”\r\n\r\nread  timeofday\r\n\r\ncase “$timeofday” in\r\n\r\n   yes ) echo “good moring”;;\r\n\r\n   no ) echo “good afternoon”;;\r\n\r\ny) echo “good morning”;;\r\n\r\nn) echo “good afternoon”;;\r\n\r\n*)echo “sorry,answer not recognized” ;;\r\n\r\n esac\r\n\r\n exit 0\r\n\r\n 匹配部分语句也可改写为：\r\n\r\n case  “$timeofday” in\r\n\r\n​    yes | y | Yes | YES ) echo “good morning”;;\r\n\r\n​    n* | N* )     echo “good afternoon”;;\r\n\r\n​    *)        echo “sorry, answer not recognized”;;\r\n\r\n esac\r\n\r\n也可以将匹配行改为; [yY]|[Yy][Ee][Ss]\r\n\r\n***\\*8、命令列表\\****\r\n\r\n 有时需要将好几条命令连接成一个序列。如下\r\n\r\n if [ -f this_file ]; then\r\n\r\n   if [ -f that_file ]; then\r\n\r\n​     if [ -f the_other_file ]; then\r\n\r\n​       echo “all  files present, and correct”\r\n\r\n​     fi\r\n\r\n   fi\r\n\r\nfi\r\n\r\n \r\n\r\n***\\*9、AND列表\\****\r\n\r\n  只有在前一条命令执行成功返回true才执行下一条。语法结构：\r\n\r\n Statement1  ***\\*&&\\**** Statement1  ***\\*&&\\**** Statement1  ***\\*&&\\**** ***\\*…\\****\r\n\r\n示例:\r\n\r\n\\#!/bin/bash\r\n\r\ntouch file_one\t\r\n\r\nrm –f file_two\r\n\r\nif [ -f file_one ] && echo “hello” && [ -f file_two ] && echo “there”\r\n\r\nthen\r\n\r\n  echo “in if”\r\n\r\nelse\r\n\r\n  echo “in else”\r\n\r\nfi\r\n\r\nexit 0\r\n\r\n***\\*10、OR列表 ，直到有一条命令执行成功为止。\\****\r\n\r\n 语法结构：\r\n\r\n Statement1 ***\\*||\\**** Statement2 ***\\*||\\**** Statement3 ***\\*||\\**** ***\\*…\\****\r\n\r\n示例：\r\n\r\nif [ -f file_one ] || echo “hello” || echo “there”\r\n\r\nthen\r\n\r\n  echo “in if”\r\n\r\nelse\r\n\r\necho “in else”\r\n\r\nfi\r\n\r\n***\\*11、语句块\\****\r\n\r\n如果想在只允许使用单个语句的地方（如 AND，OR）使用多条语句，可以是花括号{}来构造一个块。如下：\r\n\r\n  Get_confirm && {\r\n\r\n​    echo “hello”\r\n\r\n​    cat $tmp_file > $tracks_file\r\n\r\nadd_record_tracks\r\n\r\n}\r\n\r\n***\\*12、函数\\****\r\n\r\n要定义一个shell函数，只需写出它的名字，加上括弧，再把函数要实现的语句放在一对花括号中，如下所示：\r\n\r\nfunction_name ***\\*() {\\****\r\n\r\n   Statements\r\n\r\n***\\*}\\****\r\n\r\n示例：\r\n\r\n\\#!/bin/bash\r\n\r\nfoo(){\r\n\r\n  echo  “function foo is executing”\r\n\r\n}\r\n\r\necho  “ this is foo… ”\r\n\r\nfoo\r\n\r\necho “foo end!”\r\n\r\nexit 0\r\n\r\n如果在函数中没有return命令指定一个返回值，则函数返回的就是执行的最后一条命令的退出码。\r\n\r\n示例 \r\n\r\n\\#!/bin/bash\r\n\r\n\\# 函数部分\r\n\r\nYes_or_no(){\r\n\r\n  Echo “is your name $* ?”\r\n\r\n while true\r\n\r\ndo\r\n\r\n  echo –n “Enter yes or no: ”\r\n\r\n  read x\r\n\r\n case “$x” in\r\n\r\n  y | yes ) return 0;;\r\n\r\n  n | no ) return 1;;\r\n\r\n  *) echo “please input yes or no”\r\n\r\n esac\r\n\r\ndone\r\n\r\n\\#主程序部分\r\n\r\necho  “original parameters are $*”\r\n\r\nif  yes_or_no “$1”\r\n\r\nthen\r\n\r\n  echo “HI  $1,nice name”\r\n\r\nelse\r\n\r\n  echo “never mind”\r\n\r\nfi\r\n\r\nexit 0\r\n\r\n在函数内部定义的变量，在函数运行后，变量依然有效，如果只想在本函数内使用临时变量，可在变量前加上 ***\\*local\\****\r\n\r\n\\#!/bin/bash\r\n\r\nfoo()\r\n\r\n{\r\n\r\n local  str=aaaa ***\\*#\\*******\\*如果此处无local 则 最后的语句是可以输出aaaa\\*******\\*的\\****\r\n\r\necho "in foo $str"\r\n\r\n}\r\n\r\nfoo\r\n\r\necho "over $str"\r\n\r\n \r\n\r\n$# 表示参数个数，$1为第一个参数依次类推。（$*,$@）\r\n\r\n脚本中无函数的声明，调用某个函数前，该函数需要先被定义，所以函数的定义可以写在脚本的开始。\r\n\r\n \r\n\r\n***\\*13、一些命令\\****\r\n\r\n1）break 命令\r\n\r\n 在控制条件为满足之前，可以跳出 for，while，until循环，后面可带参数值，来表明要跳出的循环层数，但我们不建议这么做。\r\n\r\n2) :命令\r\n\r\n冒号（：）命令是一个空命令。偶尔被运用简化逻辑，相当于true。\r\n\r\n3) continue命令\r\n\r\n类似C语言中的同名语句。可使for，while，until循环跳到下一次循环继续执行，循环变量取循环列表中的下一个。\r\n\r\n如 for x in 1 2 3\r\n\r\ndo \r\n\r\n echo before $x\r\n\r\n continue 1\r\n\r\n echo after $x\r\n\r\ndone\r\n\r\n**4)** ***\\*.\\****命令\r\n\r\n默认情况下，shell脚本程序会在一个新创建的环境中执行，所以当脚本对环境变量所做的任何修改都会丢失，而点(***\\*.\\****)命令允许执行的脚本程序改变当前的环境。\r\n\r\n5) echo命令\r\n\r\n输出一行字符内容并换行，若要使其不换行linux有两种解决方法：echo –n “string to output”\r\n\r\necho –e “string to output\\c”\r\n\r\n(注：-e是确保启用了反斜杠转义字符，\\c代表去掉换行符，\\t代表制表符，\\n代表回车 )\r\n\r\n6) eval命令\r\n\r\neval允许对参数进行求值，如下：\r\n\r\nfoo=10\r\n\r\nx=foo\r\n\r\ny=’$’$x\r\n\r\necho $y  #输出为foo\r\n\r\n当使用 eval命令时，如下\r\n\r\nfoo=10\r\n\r\nx=foo\r\n\r\neval  y=’$’$x\r\n\r\necho $y  #输出为 10\r\n\r\n7) exec命令\r\n\r\n将当前shell替换为一个不同的程序\r\n\r\n如：exec wall “Thanks for the fish”\r\n\r\n脚本中的这个命令会用wall命令替换当前的shell。\r\n\r\n第二种用法是修改当前文件描述符：\r\n\r\nexec 3< afile\r\n\r\n修改文件描述符。\r\n\r\n  \r\n\r\n8) exit n命令\r\n\r\n一般使脚本程序以退出码n结束运行。\r\n\r\n0表示成功，1~125是脚本可以使用的错误代码。\r\n\r\n126表示文件不可执行，127表示命令未找到\r\n\r\n128及以上 出现一个信号\r\n\r\n9) export 命令\r\n\r\nexport 命令可以将变量参数导出到子shell中，子shell中即可访问该变量。如 TESTA=testa；export TESTA\r\n\r\n10)  expr命令\r\n\r\n  expr命令将它的参数当做一个表达式来求值。\r\n\r\n11) printf命令\r\n\r\n  printf “format  string” parameter1 parameter2 \r\n\r\n12)return 命令\r\n\r\n   return命令作用是使函数返回，后面可带返回值，如果没有返回值则默认返回最后一条命令的退出码。\r\n\r\n  13)set命令\r\n\r\n示例：从系统提供的参数date中提取出月份。\r\n\r\n\\#!/bin/bash\r\n\r\necho the date is $(date)\r\n\r\nset $(date)\r\n\r\necho The month is $2\r\n\r\nexit 0\r\n\r\n14)shift命令\r\n\r\nshift命令把所有参数变量左移一个位置，使$2变成$1,$3变成$2,$1被丢弃，$0保持不变。\r\n\r\nwhile [ “$1” != “” ];do\r\n\r\n  echo “$1”\r\n\r\n  shift\r\n\r\ndone\r\n\r\nexit 0\r\n\r\n15)trap命令\r\n\r\n  Trap命令用于指定在接收信号后将要采取的行动。\r\n\r\n语法结构：***\\*trap\\**** command signal\r\n\r\n第一个参数是收到指定信号要采取的行动。\r\n\r\n第二个参数是要处理的信号名称。\r\n\r\n如果要忽略一个信号，则将第一个参数设为空字符串。\r\n\r\n\\#!/bin/bash\r\n\r\ntrap \'rm -f /home/sufeng/my_shell/my_tmp_file_$$\' INT\r\n\r\necho creating file /home/sufeng/my_shell/my_tmp_file_$$\r\n\r\ndate > /home/sufeng/my_shell/my_tmp_file_$$\r\n\r\n \r\n\r\necho "press interrupt (ctrl-c) to interrupt ...."\r\n\r\nwhile [ -f /home/sufeng/my_shell/my_tmp_file_$$ ];do\r\n\r\n  echo File exists\r\n\r\n  sleep 1\r\n\r\ndone\r\n\r\n \r\n\r\necho the file no longer exists\r\n\r\n \r\n\r\ntrap INT\r\n\r\n \r\n\r\necho creating file /home/sufeng/my_shell/my_tmp_file_$$\r\n\r\ndate > /home/sufeng/my_shell/my_tmp_file_$$\r\n\r\necho "press interrupt (control-c) to interrupt ...."\r\n\r\nwhile [ -f /home/sufeng/my_shell/my_tmp_file_$$ ];do\r\n\r\n  echo File exists\r\n\r\n  sleep 1\r\n\r\ndone\r\n\r\necho we never get here\r\n\r\n16)unset命令\r\n\r\n  unset命令的作用是从环境中删除变量或函数。但不能删除shell本身定义的只读变量。\r\n\r\n  \\#!/bin/bash\r\n\r\nfoo="hello world"\r\n\r\necho $foo\r\n\r\nunset foo\r\n\r\necho $foo\r\n\r\n17)find命令\r\n\r\nfind语法结构：\r\n\r\nfind  [path]  [options]  [tests]  [actions]\r\n\r\n***\\*path\\**** 是要搜索的路径。\r\n\r\n***\\*O\\*******\\*ptions\\**** 选项:\r\n\r\n-depth   在查看目录本身之前先搜素目录的内容\r\n\r\n-follow   跟随符号链接\r\n\r\n-maxdepths N  最多搜索N层目录\r\n\r\n-mount(或-xdev)  不搜索其他文件系统中的目录\r\n\r\n***\\*T\\*******\\*ests选项\\****：\r\n\r\n-atime N  文件在N天之前被访问过\r\n\r\n-mtime N  文件在N天之前被修改过\r\n\r\n-name  “pattern” 按文件名称匹配\r\n\r\n-newer otherfile 文件比otherfile要新\r\n\r\n-type  c 文件类型为c\r\n\r\n-user username  文件的拥有者是指定用户。\r\n\r\n***\\*对tests部分的组合\\****：\r\n\r\n！  (-not)   测试取反\r\n\r\n-a   (-and)   两个测试都必须为真\r\n\r\n-o   (-or)   两个测试必须有一个为真 \r\n\r\n \r\n\r\n***\\*动作\\****：\r\n\r\n-exec  command  执行一条命令\r\n\r\n-ok  command    同上，只是处理时回头提示\r\n\r\n-print   打印文件名\r\n\r\n-ls     对当前文件使用命令 ls-dils\r\n\r\n***\\*一个find的示例：\\****\r\n\r\n***\\*sufeng@linux-ecmc:~/my_shell> find \\( -name "\\*1.sh" -o -atime 2 \\) -type f -exec ls -l {} \\;\\****\r\n\r\n***\\*结果如下：\\****\r\n\r\n-rwxrwxrwx 1 sufeng users 91 Sep  5 18:54 ./bb1.sh\r\n\r\n-rwxr--r-- 1 sufeng users 258 Sep  4 20:41 ./t_fun1.sh\r\n\r\n-rwxr--r-- 1 sufeng users 174 Sep  4 18:11 ./tm_case1.sh\r\n\r\n-rwxrwxrwx 1 sufeng users 39 Sep  5 18:35 ./cc1.sh\r\n\r\n-rwxrwxrwx 1 sufeng users 167 Sep  1 11:43 ./tm1.sh\r\n\r\n \r\n\r\n18)grep命令\r\n\r\ngrep语法如下:\r\n\r\ngrep  [options]  PATTERN  [FILES]\r\n\r\n选项            含义\r\n\r\n -c      输出匹配行的数目，而不是输出匹配行\r\n\r\n -i       忽略大小写\r\n\r\n -v       对匹配模式取反\r\n\r\n -l      只列出匹配行的文件名\r\n\r\n -E      启用扩展表达式\r\n\r\n -h      取消输出行普通前缀。\r\n\r\n 示例：\r\n\r\n grep -c -v in bb.sh cc.sh\r\n\r\n grep -c in bb.sh cc.sh\r\n\r\n19)正则表达式\r\n\r\n 字符            含义\r\n\r\n  ^           指向一行的开头\r\n\r\n  $           指向一行的结尾\r\n\r\n  .            任意单个字符\r\n\r\n  []      方括号包含一个字符范围，其中任何一个字符都可以匹配，如a~e，在字符范围前面加^，即不在指定范围内。\r\n\r\n 匹配模式              含义\r\n\r\n [:alnum:]            字母与数字字符\r\n\r\n [:alpha:]            字母\r\n\r\n [:ascii:]             ASCII 字符\r\n\r\n [:blank:]             空格或制表符\r\n\r\n [:cntrl:]             ASCII控制字符\r\n\r\n [:digit:]             数字\r\n\r\n [:graph:]            非控制、非空格字符\r\n\r\n [:lower:]            小写字母\r\n\r\n[:print:]               可打印字符\r\n\r\n[:punct:]              标点符号字符\r\n\r\n[:space:]            空白字符，包括垂直制表符\r\n\r\n[:upper:]               大写字母\r\n\r\n[:xdigit:]               十六进制数字\r\n\r\n \r\n\r\n选项                含义\r\n\r\n ？            匹配是可选的，但最多匹配一次\r\n\r\n​    \\*             必须匹配0次或多次\r\n\r\n​    \\+             必须匹配1次或多次\r\n\r\n   {n}             必须匹配n次\r\n\r\n   {n,}            必须匹配n次或n次以上\r\n\r\n   {n，m}         必须匹配n到m之间，包括n和m\r\n\r\n以上使用的时候需要加’\\’.\r\n\r\n示例：\r\n\r\ngrep  e$  bb.sh      以e结尾\r\n\r\ngrep  a[[:blank:]] bb.sh   以a结尾\r\n\r\ngrep  Th.[[:blank:]] bb.sh  匹配以Th开头的3个字符组成的单词\r\n\r\ngrep  -E [a-z]\\{10\\} bb.sh  匹配只有10个字符常的全由小写字母组成的单词。\r\n\r\n \r\n\r\n \r\n\r\n20)命令的执行\r\n\r\n  $(command)\r\n\r\n \\#!/bin/bash\r\n\r\n whoisthere=$(who)  将who显示的内容给变量\r\n\r\n echo $whoisthere  \r\n\r\n exit 0 \r\n\r\n***\\*算数扩展\\****\r\n\r\n \\#!/bin/bash\r\n\r\n  X=0\r\n\r\n  while [ “$X” –ne 10 ]; do\r\n\r\n   echo  $X\r\n\r\n   x=$(($x+1))\r\n\r\n done\r\n\r\nexit 0\r\n\r\n注意 使用$时，后面有两个括弧和一个括弧是有区别的，一个是赋只给变量，两个是进行算数运算。\r\n\r\n***\\*参数扩展\\****\r\n\r\n示例：\r\n\r\n如果有两个文件 1_tmp和2_tmp\r\n\r\n\\#！/bin/bash\r\n\r\nfor i in 1 2\r\n\r\ndo\r\n\r\n  my_secret_process ***\\*$i_tmp\\****\r\n\r\ndone\r\n\r\n此时，又有错误信息，应该为my_secret_process ***\\*${i}_tmp\\****\r\n\r\n \r\n\r\n***\\*参数扩展              说明\\****\r\n\r\n ${param:-default}        若param为空，则值为default\r\n\r\n ${#param}          给出param的长度\r\n\r\n ${param%word}  从尾部开始删除与word匹配的最小部分\r\n\r\n ${param%%word} 从尾部开始删除与word匹配的最长部分\r\n\r\n ${param#word}   从param的头部开始删除匹配的最小部分\r\n\r\n${param##word}  从param的头部开始删除匹配的最小部分\r\n\r\n21)here文档\r\n\r\n 可以将部分字符内容存储在脚本中，以特定的字符标示起始和结尾。\r\n\r\n示例;\r\n\r\n\\#!/bin/bash\r\n\r\ncat  <<!FUNKY!\r\n\r\nhello\r\n\r\nthis is a here\r\n\r\ndocument\r\n\r\n!FUNKY!\r\n\r\n示例2:  使用ed编辑器\r\n\r\n\\#!/bin/bash\r\n\r\ned  a_text_file  <<!FunkyStuff!\r\n\r\n3\r\n\r\nd\r\n\r\n.,\\$s/is/was/\r\n\r\nw\r\n\r\nq\r\n\r\n!FunkyStuff!\r\n\r\nexit 0\r\n\r\n \r\n\r\n其中 a_text_file 文件中内容如下\r\n\r\nThat is line 1\r\n\r\nThat is line 2\r\n\r\nThat is line 3\r\n\r\nThat is line 4\r\n\r\n ',L={data:function(){return{MainComponent:w}}},C=L,k=Object(p["a"])(C,f,b,!1,null,"e490d1f2",null),y=k.exports,P=function(){var n=this,r=n.$createElement,e=n._self._c||r;return e("div",[e("div",{staticClass:"row  "},[e("q-select",{staticStyle:{width:"500px"},attrs:{"use-input":"","input-debounce":"0",clearable:"",options:n.book_options},on:{filter:n.filterFn},model:{value:n.book,callback:function(r){n.book=r},expression:"book"}},[e("template",{slot:"before"},[e("div")])],2)],1),e("div",{staticClass:"q-pdfviewer-container   "},[e("q-pdfviewer",{attrs:{src:n.src,type:"html5","content-class":" fit   q-pdfviewer-container","inner-content-class":" fit   q-pdfviewer-container"},model:{value:n.show,callback:function(r){n.show=r},expression:"show"}})],1)])},S=[],I=e("1b62"),R=["CDN排坑指南.pdf","DTS控制台一本通.pdf","ECS运维指南-linux诊断.pdf","ECS运维指南-windows诊断.pdf","Linux学习笔记.pdf","OSS运维-进阶手册.pdf","OSS运维u-基础书册.pdf","RDS数据库一本通.pdf","Rocket MQ 使用排查指南.pdf","VOD问题排查与实战手册.pdf","深入浅出K8S.pdf","深入浅出玩转物联网平台.pdf"],U="linux/pdf/",E={mixins:[I["d"]],data:function(){return{prefix:U,book_options:R,show:!0,book:R[0],src:""}}},A=E,M=Object(p["a"])(A,P,S,!1,null,null,null),T=M.exports,D=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},O=[function(){var n=this,r=n.$createElement,e=n._self._c||r;return e("div",{},[e("div",{staticClass:"markdown_views prism-atom-one-dark",attrs:{id:"content_views"}},[e("blockquote",[e("p",[n._v("本文主要是Linux的入门内容，利用40张思维导图从"),e("strong",[n._v("基础、操作、实用指令、组管理和权限管理、crond任务调度、Linux磁盘分区和挂载、Linux网络环境配置、进程管理、服务管理、RPM和YUM、软件安装关键点、Shell编程共十二部分着手")]),n._v("，从而系统的了解一下Linux（基于Centos），本文的定位是前端工程师够用、运维工程师入门。")])]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNDQzMTBjYjU3ZGE.png",alt:""}})]),e("h2",[e("a",{attrs:{name:"t0"}}),e("a",{attrs:{name:"t0"}}),e("a",{attrs:{id:"_6"}}),n._v("一、基础")]),e("blockquote",[e("p",[n._v("主要阐述了什么是Linux、主要发行版有什么、如何在自己利用VM安装自己的Linux系统、Linux树形目录结构及相关目录的用途。")])]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNDQ3OGE2MDQwNzk.png",alt:""}})]),e("h2",[e("a",{attrs:{name:"t1"}}),e("a",{attrs:{name:"t1"}}),e("a",{attrs:{id:"_10"}}),n._v("二、操作")]),e("blockquote",[e("p",[n._v("主要介绍了Xftp5、XShell工具及vi和vim编辑器的使用。")])]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNDRhM2Y2OWFkMzI.png",alt:""}})]),e("h2",[e("a",{attrs:{name:"t2"}}),e("a",{attrs:{name:"t2"}}),e("a",{attrs:{id:"_14"}}),n._v("三、实用指令")]),e("blockquote",[e("p",[n._v("主要阐述了一系列实用指令，包括：关机&重启命令；用户登录和注销；用户管理；切换到指定运行级别；帮助指令；文件目录类；时间日期类；搜索查找类；压缩和解压类。")])]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNGZjNmVhZDYyMDg.png",alt:""}})]),e("h3",[e("a",{attrs:{name:"t3"}}),e("a",{attrs:{name:"t3"}}),e("a",{attrs:{id:"31__18"}}),n._v("3.1 关机&重启命令")]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNGZlNDFlOTRlMzc.png",alt:""}})]),e("h3",[e("a",{attrs:{name:"t4"}}),e("a",{attrs:{name:"t4"}}),e("a",{attrs:{id:"32__20"}}),n._v("3.2 用户登陆和注销")]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNGZmYjQ1MDcwNTE.png",alt:""}})]),e("h3",[e("a",{attrs:{name:"t5"}}),e("a",{attrs:{name:"t5"}}),e("a",{attrs:{id:"33__22"}}),n._v("3.3 用户管理")]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTAwZmJiZGU5MGU.png",alt:""}})]),e("h3",[e("a",{attrs:{name:"t6"}}),e("a",{attrs:{name:"t6"}}),e("a",{attrs:{id:"34__24"}}),n._v("3.4 切换到指令运行级别")]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTAyODdlYmFkZWU.png",alt:""}})]),e("h3",[e("a",{attrs:{name:"t7"}}),e("a",{attrs:{name:"t7"}}),e("a",{attrs:{id:"35__26"}}),n._v("3.5 帮助指令")]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTAzYzI2NGRjODk.png",alt:""}})]),e("h3",[e("a",{attrs:{name:"t8"}}),e("a",{attrs:{name:"t8"}}),e("a",{attrs:{id:"36__28"}}),n._v("3.6 文件目录类")]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTA1M2JkMzZiMzQ.png",alt:""}})]),e("h3",[e("a",{attrs:{name:"t9"}}),e("a",{attrs:{name:"t9"}}),e("a",{attrs:{id:"37__30"}}),n._v("3.7 时间日期类")]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTA3MzVkMDc2YjE.png",alt:""}})]),e("h3",[e("a",{attrs:{name:"t10"}}),e("a",{attrs:{name:"t10"}}),e("a",{attrs:{id:"38__32"}}),n._v("3.8 搜索查找类")]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTA4ODJjZDNlOGY.png",alt:""}})]),e("h3",[e("a",{attrs:{name:"t11"}}),e("a",{attrs:{name:"t11"}}),e("a",{attrs:{id:"39__34"}}),n._v("3.9 压缩和解压类")]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTA5Yzc0NTVlMDg.png",alt:""}})]),e("h2",[e("a",{attrs:{name:"t12"}}),e("a",{attrs:{name:"t12"}}),e("a",{attrs:{id:"_36"}}),n._v("四、组管理和权限管理")]),e("blockquote",[e("p",[n._v("主要阐述了组管理及权限管理相关的内容。")])]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTBmYzU1MTc5NjI.png",alt:""}})]),e("h2",[e("a",{attrs:{name:"t13"}}),e("a",{attrs:{name:"t13"}}),e("a",{attrs:{id:"crond_40"}}),n._v("五、crond任务调度")]),e("blockquote",[e("p",[n._v("主要阐述了crond任务调度，使系统在某个时间执行特定的命令或程序")])]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTEzNzViNDc4MjA.png",alt:""}})]),e("h2",[e("a",{attrs:{name:"t14"}}),e("a",{attrs:{name:"t14"}}),e("a",{attrs:{id:"Linux_44"}}),n._v("六、Linux磁盘分区、挂载")]),e("blockquote",[e("p",[n._v("主要阐述了Linux磁盘分区、挂载，使开发者能够自己增加一块硬盘")])]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTE1NjIwNzAwYzk.png",alt:""}})]),e("h2",[e("a",{attrs:{name:"t15"}}),e("a",{attrs:{name:"t15"}}),e("a",{attrs:{id:"Linux_48"}}),n._v("七、Linux网络环境配置")]),e("blockquote",[e("p",[n._v("主要阐述了Linux网络环境配置中的自动获取IP和指定固定的IP，从而实现网络连接。")])]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTE3NTNiMDYxMjk.png",alt:""}})]),e("h2",[e("a",{attrs:{name:"t16"}}),e("a",{attrs:{name:"t16"}}),e("a",{attrs:{id:"_52"}}),n._v("八、进程管理")]),e("blockquote",[e("p",[n._v("主要阐述了与进程管理相关的内容，包括基本概念、显示执行的进程、查看进程树、终止进程、动态监控进程、查看系统网络情况及进程状态。")])]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWMzMmViYjE3NmY.png",alt:""}})]),e("h3",[e("a",{attrs:{name:"t17"}}),e("a",{attrs:{name:"t17"}}),e("a",{attrs:{id:"81__56"}}),n._v("8.1 基本")]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWM0OGM2NWJhNGU.png",alt:""}})]),e("h3",[e("a",{attrs:{name:"t18"}}),e("a",{attrs:{name:"t18"}}),e("a",{attrs:{id:"82__58"}}),n._v("8.2 显示执行的进程")]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWM1OTQyNmNiNDU.png",alt:""}})]),e("h3",[e("a",{attrs:{name:"t19"}}),e("a",{attrs:{name:"t19"}}),e("a",{attrs:{id:"83__60"}}),n._v("8.3 查看进程树")]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWM2ODQ0YjkxMDg.png",alt:""}})]),e("h3",[e("a",{attrs:{name:"t20"}}),e("a",{attrs:{name:"t20"}}),e("a",{attrs:{id:"84__62"}}),n._v("8.4 终止进程")]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWM3NTRmNDAyYmU.png",alt:""}})]),e("h3",[e("a",{attrs:{name:"t21"}}),e("a",{attrs:{name:"t21"}}),e("a",{attrs:{id:"85__64"}}),n._v("8.5 动态监控进程")]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWM4MzY4ZGMxM2E.png",alt:""}})]),e("h3",[e("a",{attrs:{name:"t22"}}),e("a",{attrs:{name:"t22"}}),e("a",{attrs:{id:"86__66"}}),n._v("8.6 查看系统网络情况")]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWM5MGJjY2ZkMTg.png",alt:""}})]),e("h3",[e("a",{attrs:{name:"t23"}}),e("a",{attrs:{name:"t23"}}),e("a",{attrs:{id:"87__68"}}),n._v("8.7 进程状态")]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWNhMGQxODQ0ZTM.png",alt:""}})]),e("h2",[e("a",{attrs:{name:"t24"}}),e("a",{attrs:{name:"t24"}}),e("a",{attrs:{id:"_70"}}),n._v("九、服务管理")]),e("blockquote",[e("p",[n._v("主要阐述了何为服务以及与服务管理相关的一些列指令。")])]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWQxODhjMWM1ZjE.png",alt:""}})]),e("h2",[e("a",{attrs:{name:"t25"}}),e("a",{attrs:{name:"t25"}}),e("a",{attrs:{id:"RPMYUM_74"}}),n._v("十、RPM和YUM")]),e("blockquote",[e("p",[n._v("主要阐述了Linux系统中软件安装的两种方式：rpm和yum。")])]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWQ4MDQ1YTc1YTU.png",alt:""}})]),e("h2",[e("a",{attrs:{name:"t26"}}),e("a",{attrs:{name:"t26"}}),e("a",{attrs:{id:"_78"}}),n._v("十一、软件安装关键点")]),e("blockquote",[e("p",[n._v("阐述了软件安装中需要注意的关键点：如何配置环境变量及开放对应端口。")])]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWRjMjQ3NDA0N2Y.png",alt:""}})]),e("h2",[e("a",{attrs:{name:"t27"}}),e("a",{attrs:{name:"t27"}}),e("a",{attrs:{id:"Shell_82"}}),n._v("十二、Shell编程")]),e("blockquote",[e("p",[n._v("主要阐述与Linux操作息息相关的Shell编程中的一些基础语法。")])]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjY2MTEwYWNkYjE.png",alt:""}})]),e("h3",[e("a",{attrs:{name:"t28"}}),e("a",{attrs:{name:"t28"}}),e("a",{attrs:{id:"121__86"}}),n._v("12.1 基本介绍")]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjY3NTU4MDZhNmM.png",alt:""}})]),e("h3",[e("a",{attrs:{name:"t29"}}),e("a",{attrs:{name:"t29"}}),e("a",{attrs:{id:"122__88"}}),n._v("12.2 基本使用")]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjY4MTllNWI3N2M.png",alt:""}})]),e("h3",[e("a",{attrs:{name:"t30"}}),e("a",{attrs:{name:"t30"}}),e("a",{attrs:{id:"123_shell_90"}}),n._v("12.3 shell的变量")]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjY4ZWU4NDBiOTE.png",alt:""}})]),e("h3",[e("a",{attrs:{name:"t31"}}),e("a",{attrs:{name:"t31"}}),e("a",{attrs:{id:"124__92"}}),n._v("12.4 注释")]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjY5ZTUwMjEyN2I.png",alt:""}})]),e("h3",[e("a",{attrs:{name:"t32"}}),e("a",{attrs:{name:"t32"}}),e("a",{attrs:{id:"125__94"}}),n._v("12.5 字符串")]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjZhYzM2YWM1M2Y.png",alt:""}})]),e("h3",[e("a",{attrs:{name:"t33"}}),e("a",{attrs:{name:"t33"}}),e("a",{attrs:{id:"126__96"}}),n._v("12.6 数组")]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjZiYTI2MTNkNWM.png",alt:""}})]),e("h3",[e("a",{attrs:{name:"t34"}}),e("a",{attrs:{name:"t34"}}),e("a",{attrs:{id:"127__98"}}),n._v("12.7 运算符")]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjZjZTUwMTUyMjU.png",alt:""}})]),e("h3",[e("a",{attrs:{name:"t35"}}),e("a",{attrs:{name:"t35"}}),e("a",{attrs:{id:"128__100"}}),n._v("12.8 条件判断")]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjZkZWY4MmI1NGI.png",alt:""}})]),e("h3",[e("a",{attrs:{name:"t36"}}),e("a",{attrs:{name:"t36"}}),e("a",{attrs:{id:"129__102"}}),n._v("12.9 流程控制")]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjZlZmQ2Y2RmYmI.png",alt:""}})]),e("h3",[e("a",{attrs:{name:"t37"}}),e("a",{attrs:{name:"t37"}}),e("a",{attrs:{id:"1210_read_104"}}),n._v("12.10 read读取控制台输入")]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjZmZTI2YWYxZGI.png",alt:""}})]),e("h3",[e("a",{attrs:{name:"t38"}}),e("a",{attrs:{name:"t38"}}),e("a",{attrs:{id:"1211__106"}}),n._v("12.11 函数")]),e("p",[e("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjcwZGFjNDhjZmI.png",alt:""}})])])])}],N={data:function(){return{}}},j=N,z=Object(p["a"])(j,D,O,!1,null,"654ef60c",null),$=z.exports,B=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},q=[function(){var n=this,r=n.$createElement,e=n._self._c||r;return e("div",{staticClass:"q-py-md"},[e("div",[e("a",{attrs:{href:"http://rpm.pbone.net",target:"_blank",rel:"noopener noreferrer"}},[n._v("a. 去官网去下载（http://rpm.pbone.net）；")])]),e("div",[n._v("### MobaXterm 官网： "),e("a",{attrs:{href:"https://mobaxterm.mobatek.net/",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://mobaxterm.mobatek.net/")])]),e("div",[n._v("\n      yum 阿里云镜像 源\n      "),e("a",{attrs:{href:"https://developer.aliyun.com/mirror/",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://developer.aliyun.com/mirror/")])]),e("div",[e("a",{attrs:{href:"https://gitee.com/Discuz/DiscuzX",target:"_blank",rel:"noopener noreferrer"}},[n._v(" LAMP --- DiscuzX 开源论坛系统")])]),e("div",[n._v("奇Q工具网 "),e("a",{attrs:{href:"https://qqe2.com/",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://qqe2.com/")])]),e("pre",[n._v("      nodejs  环境安装 \n      cd /usr/local/src/\n\n      官网 找到 linux 包 https://nodejs.org/download/release\n       https://nodejs.org/download/release/v12.20.0/node-v12.20.0-linux-x64.tar.xz\n       \nLinux 上安装 Node.js\nwget https://nodejs.org/dist/v12.18.1/node-v12.18.1-linux-x64.tar.xz    // 下载\ntar xf node-v12.18.1-linux-x64.tar.xz                                   // 解压\ncd node-v12.18.1-linux-x64                                              // 进入解压目录\n解压文件的 bin 目录底下包含了 node、npm 等命令，我们可以修改linux系统的环境变量（profile）来设置直接运行命令：\n\n老规矩先备份，养成修改重要文件之前先备份的好习惯。\n\ncp /etc/profile /etc/profile.bak\n然后 vim /etc/profile，在最下面添加 export PATH=$PATH: 后面跟上 node 下 bin 目录的路径\n\nexport PATH=$PATH:/root/node-v12.18.1-linux-x64/bin\n立即生效\n\nsource /etc/profile\n[root@localhost ~]# node -v\nv12.18.1\nOK！安装成功！\n   \n使用 Linux 服务器集群管理面板 appnode 类似的 工具 可以快速 部署\nyum -y install epel-release\nyum -y install nginx\n         service  nginx  restart\n          systemctl restart nginx.service\n   \n    ")]),e("pre",[n._v("杀死某个用户的 所有进程  kill -9 $(ps -ef | grep username)    或者   killall -u username  \n\n")])])}],F={data:function(){return{}}},H=F,W=Object(p["a"])(H,B,q,!1,null,"29e575de",null),G=W.exports,K=function(){var n=this,r=n.$createElement,e=n._self._c||r;return e("div",{},[e("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}})],1)},Q=[],Y=(e("caad"),e("ac1f"),e("2532"),e("1276"),'\x3c!--\n * @Date           : 2021-07-11 03:48:46\n * @FilePath       : /jinnian-space/src/pages/linux/md/linux-进程检测与控制.md\n * @Description    : \n--\x3e\n# Linux计划任务以及进程检测与控制，优先级\n\n# 一、Linux计划任务\n\n##  Linux中的计划任务\n\n基本语法：\n\n```powershell\n# crontab [选项]\n-l ：list，显示目前已经设置的计划任务\n-e ：使用vim编辑器编辑计划任务的文件\n```\n\n案例：显示当前账号下的计划任务\n\n```powershell\n# crontab -l\nno crontab for root => root账号下没有创建计划任务\n```\n\n案例：编写计划任务\n\n```powershell\n# crontab -e\n```\n\n##  计划任务的编辑\n\ncrontab -e进入计划任务编辑文件\n\n![image-20200323162534378](media/image-20200323162534378.png)\n\n打开计划任务编辑文件后，可以在此文件中编写我们自定义的计划任务：\n\n==计划任务的规则语法格式，以行为单位，一行则为一个计划==\n\n```powershell\n分  时  日  月  周  要执行的命令（要求必须使用命令的完整路径，可以使用which查看）\n\n取值范围（常识）：\n分：0~59\n时：0~23\n日：1~31\n月：1~12\n周：0~7，0 和 7 表示星期天\n\n四个符号：\n*：表示取值范围中的每一个数字\n-：做连续区间表达式的，要想表示1~7，则可以写成：1-7\n/：表示每多少个，例如：想每 10 分钟一次，则可以在分的位置写：*/10\n,：表示多个取值，比如想在 1 点，2 点 6 点执行，则可以在时的位置写：1,2,6\n```\n\n![image-20200323163957324](media/image-20200323163957324.png)\n\n##  几个小案例\n\n问题1：每月1、10、22 日的4:45 重启network 服务\n\n```powershell\n第一步：定制格式\n分  时  日      月   周 /usr/bin/systemctl restart network\n第二步：定制时间\n45  4  1,10,22  *   *  /usr/bin/systemctl restart network\n```\n\n问题2：每周六、周日的1:10 重启network 服务\n\n```powershell\n第一步：定制格式\n分 时 日 月 周 /usr/bin/systemctl restart network\n第二步：定制时间\n10 1  * *  6,7 /usr/bin/systemctl restart network\n```\n\n问题3：每天18:00 至23:00 之间每隔30 分钟重启network 服务\n\n```powershell\n第一步：定制格式\n分 时 日 月 周 /usr/bin/systemctl restart network\n第二步：定制时间\n*/30 18-23 * * * /usr/bin/systemctl restart network\n```\n\n问题4：每隔两天的上午8 点到11 点的第3 和第15 分钟执行一次重启\n\n```powershell\n第一步：定制格式\n分 时 日 月 周 /usr/sbin/reboot\n第二步：定制时间\n3,15  8-11 */2 * * /usr/sbin/reboot\n```\n\n案例：每1 分钟往 root 家目录中的 readme.txt 中输一个1，为了看到效果使用追加输出【输出使用echo 命令，语法：# echo 输出的内容】\n\n```powershell\n# crontab -e\n* * * * * /usr/bin/echo 1 >> /root/readme.txt\n```\n\n提示：为了看到计划任务的效果，你可以单独开一个选项卡，使用tail  -f  /root/readme.txt\n\n##  计划任务\n\n常见的一个操作：定时备份（定时把数据库中的数据导出到某个文件中）\n##  计划任务权限\n\n### ☆ 黑名单\n\ncrontab是任何用户都可以创建的计划任务，但是超级管理员可以通过配置来设置某些用户不允许设置计划任务 。\n\n提出问题：如果我们想限定某个用户（如itheima）使用计划任务，如何处理呢？\n\n答：可以使用计划任务的黑名单，黑名单文件路径 => ==/etc/cron.deny==文件\n\n案例：把普通账号itheima加入到cron.deny黑名单中，禁止其创建计划任务\n\n第一步：切换到超级管理员root\n\n```powershell\n# su - root\n```\n\n第二步：使用vim打开/etc/cron.deny文件\n\n```powershell\n# vim /etc/cron.deny\n```\n\n第三步：把你需要禁止的用户名单，加入此文件（如itheima）\n\n```powershell\nitheima\n```\n\n切换到itheima账号，测试是否可以使用crontab命令\n\n![image-20200324095412933](media/image-20200324095412933.png)\n\n### ☆ 白名单\n\n在Linux的计划任务中，除了拥有黑名单以外，还有白名单。作用：允许哪些用户使用计划任务。\n\n白名单文件的路径 => ==/etc/cron.allow==，但是要特别注意，此文件需要手工创建。\n\n> 注意：白名单优先级高于黑名单，如果一个用户同时存在两个名单文件中，则会被默认允许创建计划任务。\n\n##  查看计划任务的保存文件\n\n问题：计划任务文件具体保存在哪里呢？\n\n答：`/var/spool/cron/用户名称`，如果使用root用户编辑计划任务，则用户文件名为root\n\n```powershell\n# ll /var/spool/cron\ntotal 4\n-rw-------. 1 itheima itheima  0 Mar 24 09:50 itheima\n-rw-------. 1 root    root    40 Mar 24 10:21 root\n```\n\n##  计划任务的日志程序\n\n问题：在实际应用中，我们如何查看定时任务运行情况？\n\n答：通过计划任务日志，日志文件位于`/var/log/cron`\n\n案例：演示计划任务的日志程序\n\n第一步：使用root账号创建一个计划任务\n\n```powershell\n# su - root\n# crontab -e\n* * * * * echo 1 >> ~/readme.txt\n```\n\n第二步：使用tail -f命令监控/var/log/cron日志程序\n\n```powershell\n# tail -f /var/log/cron\n```\n\n##  扩展内容：at命令\n\n在Linux系统下，有两个命令可以实现计划任务：crontab与at（第三方需要额外安装）\n\ncrontab ：每天定时执行计划任务（最小单元分钟）\n\nat ：一次性定时执行任务\n\n### ☆ 安装at命令\n\nCentOS7自带，其他版本可能需要手工安装\n\n```powershell\n# yum install at -y\n```\n\n### ☆ 启动底层服务\n\n```powershell\n# systemctl start atd\n# systemctl enable atd\n```\n\n> atd = at + d = at命令 + daemon缩写\n\n### ☆ 案例演示\n\n案例1：三天后下午5点执行/bin/ls\n\n```powershell\n# at 5pm+3 days\nat>/bin/ls >/root/readme.txt\nat>按Ctrl+D\n```\n\n> am = 上午、pm = 下午、3 days = 3天\n\n案例2：明天17点，输出时间到指定的文件中\n\n```powershell\n# at 17:00 tomorrow\nat>date>/root/readme.txt\nat>按Ctrl+D\n```\n\n> tomorrow = 明天\n\n案例3：使用atq查看没有执行的计划任务\n\n```powershell\n# atq\n```\n\n> atq = at + q = at命令 + query查询\n\n案例4：删除指定的计划任务\n\n```powershell\n# atq\n# atrm 任务号\n```\n\n> atrm = at + rm = at命令 + remove移除\n\n# 二、Linux进程与程序\n\n## 1、了解一下进程与程序的关系\n\n​        **进程**是正在执行的一个程序或命令，每个进程都是一个运行的实体，并占用一定的系统资源。**程序**是人使用计算机语言编写的可以实现特定目标或解决特定问题的代码集合。\n\n​        简单来说，程序是人使用计算机语言编写的，可以实现一定功能，并且可以执行的代码集合。进程是正在执行中的程序。\n\n**举例**：谷歌浏览器是一个程序，当我们打开谷歌浏览器，就会在系统中看到一个浏览器的进程，当程序被执行时，程序的代码都会被加载入内存，操作系统给这个进程分配一个 ID，称为 **PID**（进程 ID）。我们打开多个谷歌浏览器，就有多个浏览器子进程，但是这些进程使用的程序，都是chrome\n\n> PID = Process ID = 进程编号\n\n![image-20200324113209223](media/image-20200324113209223.png)\n\n## 2、Linux下的进程管理工作\n\n进程查看，通过查看，判断健康状态\n\n进程终止\n\n进程优先级控制\n\n# 三、Linux下进程管理命令\n\n## 1、任务背景\n\n工作场景：\n\n​        小黑入职到一家公司，接到的第一项任务，就是监控生产服务器的性能，提到服务器性能，我们首先想到的就是CPU，内存和磁盘。\n\n## 2、使用top命令动态监测CPU信息\n\n基本语法：\n\n```powershell\n# top\n```\n\n![image-20200324114201114](media/image-20200324114201114.png)\n\n## 3、系统的整体情况\n\n### ☆ 第一行\n\n![image-20200324114427942](media/image-20200324114427942.png)\n\n| 内 容                         | 说 明                                                        |\n| ----------------------------- | ------------------------------------------------------------ |\n| 10:12:28                      | 系统当前时间                                                 |\n| up 13:05                      | 系统的运行时间.本机己经运行 13 小时 05 分钟                  |\n| 3 users                       | 当前登录了三个用户                                           |\n| load average: 0.00,0.01，0.05 | 系统在之前 1 分钟、5 分钟、15 分钟的平均负载。如果 CPU 是单核的，则这个数值超过 1 就是高负载：如果 CPU 是四核的，则这个数值超过 4 就是高负载 |\n\n### ☆ 第二行\n\n![image-20200324115718442](media/image-20200324115718442.png)\n\n| Tasks:   230 total | 系统中的进程总数                                 |\n| ------------------ | ------------------------------------------------ |\n| 1 running          | 正在运行的进程数                                 |\n| 229 sleeping       | 睡眠的进程数                                     |\n| 0 stopped          | 正在停止的进程数                                 |\n| 0 zombie           | 僵尸进程数。如果不是   0，则需要手工检查僵尸进程 |\n\n### ☆ 第三行\n\n![image-20200324142002240](media/image-20200324142002240.png)\n\n| 内 容           | 说 明                                                        |\n| --------------- | ------------------------------------------------------------ |\n| Cpu(s): 0.1 %us | 用户模式占用的   CPU 百分比                                  |\n| 0.1%sy          | 系统模式占用的   CPU 百分比                                  |\n| 0.0%ni          | 改变过优先级的用户进程占用的   CPU 百分比                    |\n| 99.7%id         | idle缩写，空闲   CPU 占用的 CPU 百分比                       |\n| 0.1%wa          | 等待输入/输出的进程占用的   CPU 百分比                       |\n| 0.0%hi          | 硬中断请求服务占用的   CPU 百分比                            |\n| 0.1%si          | 软中断请求服务占用的   CPU 百分比                            |\n| 0.0%st          | st（steal   time）意为虚拟时间百分比，就是当有虚拟机时，虚拟 CPU 等待实际 CPU 的时间百分比 |\n\n#### 问题：如果我的机器有4核CPU，我想查看每一核心分别的负载情况怎能办？\n\n答：交换快捷键 “1”\n\n![image-20200324142144911](media/image-20200324142144911.png)\n\n> CPU负载测试 =>  cat  /dev/urandom |md5sum\n\n### ☆ 第四行\n\n![image-20200324143340302](media/image-20200324143340302.png)\n\n| 内 容              | 说 明                                                        |\n| ------------------ | ------------------------------------------------------------ |\n| Mem: 1863252 total | 物理内存的总量，单位为KB                                     |\n| 829960 used        | 己经使用的物理内存数量                                       |\n| 68352 free         | 空闲的物理内存数量。我们使用的是虚拟机，共分配了 628MB内存，所以只有53MB的空闲内存 |\n| 96490 buff/cache   | 作为缓冲的内存数量                                           |\n\n>扩展：真正剩余内存 = free + buff/cache，真正使用内存 = used - buff/cache\n\n### ☆ 第五行\n\n![image-20200324144347040](media/image-20200324144347040.png)\n\n| 内 容               | 说 明                        |\n| ------------------- | ---------------------------- |\n| Swap: 2097148 total | 交换分区（虚拟内存）的总大小 |\n| 3336 used           | 已经使用的交换分区的大小     |\n| 2093812 free        | 空闲交换分区的大小           |\n| 622420 avail Mem    | 可用内存                     |\n\n 在Linux操作系统分区时，最少需要3个分区：\n\n① /boot分区 ： 系统分区\n\n② swap交换分区 ：一般情况下为内存的1~2倍，但是尽量不要超过2G\n\n③ /分区 ：根分区，所有文件都存放于此\n\n> swap分区：就是当计算机的内存不足时，系统会自动从硬盘中划出一块区域充当内存使用。\n\n​       我们通过 top 命令的整体信息部分，就可以判断服务器的健康状态。如果 1 分钟、5 分钟、15 分钟的平均负载高于CPU核数，说明系统压力较大。如果物理内存的空闲内存过小，则也证明系统压力较大。\n\n问题：根据以上信息，目前我们的系统压力如何？\n\n答：看CPU负载及内存的使用情况\n\n\n\n问题：如果我们发现CPU负载过大，接下来怎么办？\n\n答：如果1分钟、5分钟以及15分钟全部超过CPU的总核心数（必须引起警觉），这个时候就要查看底部的进程信息了。\n\n> 经验之谈：如果一个总核数=8核心的CPU，理论上平均负载达到16，也还可以坚持很长一段时间。\n\n## 4、系统的进程信息\n\n![image-20200324151820219](media/image-20200324151820219.png)\n\n| PID     | 进程的 ID。                                                  |\n| ------- | ------------------------------------------------------------ |\n| USER    | 该进程所属的用户。                                           |\n| PR      | 优先级，数值越小优先级越高。                                 |\n| NI      | NICE优先级，数值越小优先级越高，取值范围-20到19，默认都是0   |\n| VIRT    | 该进程使用的虚拟内存的大小，单位为 KB。                      |\n| RES     | 该进程使用的物理内存的大小，单位为 KB。                      |\n| SHR     | 共享内存大小，单位为 KB。计算一个进程实际使用的内存 = 常驻内存（RES）- 共享内存（SHR） |\n| S       | 进程状态。其中S 表示睡眠，R 表示运行                         |\n| %CPU    | 该进程占用 CPU 的百分比。                                    |\n| %MEM    | 该进程占用内存的百分比。                                     |\n| TIME+   | 该进程共占用的 CPU 时间。                                    |\n| COMMAND | 进程名                                                       |\n\n#### 问题：如果我们发现CPU负载过大，接下来怎么办？\n\n答：查看占用CPU最多的进程\n\n\n\n#### 问题：如何查看占用CPU最多的进程？\n\n答：交互操作快捷键P，P（大写）：，表示将结果按照CPU 使用率从高到低进行降序排列\n\n\n\n#### 问题：如果我们发现内存可用量很小，接下来怎么办？\n\n答：查看占用内存最多的进程，使用交互快捷键M（大写）：表示将结果按照内存（MEM）从高到低进行降序排列\n\n![image-20200324154216736](media/image-20200324154216736.png)\n\n\n\n#### 问题：当我们查看完系统状态，需要做什么？\n\n答：退出，使用q，按键盘上的q，就会回到#提示符的状态。\n\n## 5、free查看内存使用情况\n\n基本语法：\n\n```powershell\n# free [选项]  1GB = 1024MB  1MB = 1024KB\n选项说明：\n-m : 以MB的形式显示内存大小\n```\n\n案例：显示计算机的内存使用情况\n\n```powershell\n# free -m\n```\n\n​    和Centos6相比，buffer和cached被合成一组，加入了一个available。\n\n​    关于此available，即系统可用内存，用户不需要去计算buffer/cache，即可以看到还有多少内存可用，更加简单直观\n\n![image-20200324155922424](media/image-20200324155922424.png)\n\n## 6、df查看磁盘剩余空间\n\n基本语法：\n\n```powershell\n# df [选项]\n-h ：以较高的可读性显示磁盘剩余空间大小\n```\n\n> df = disk free = 磁盘 剩余\n\n这几列依次是：\n\n| Filesystem | 磁盘名称                           |\n| ---------- | ---------------------------------- |\n| Size       | 总大小                             |\n| Used       | 被使用的大小                       |\n| Avail      | 剩余大小                           |\n| Use%       | 使用百分比                         |\n| Mounted on | 挂载路径（相当于Windows 的磁盘符） |\n\n## 7、ps查看系统进程信息\n\ntop ： 动态查看系统进程的信息（每隔3s切换一次）\n\nps  ： 静态查看系统进程的信息（只能查询运行ps命令瞬间，系统的进程信息）\n\n基本语法：\n\n```powershell\n# ps [选项]\n选项说明：\n-e : 等价于“-A”，表示列出全部（all）的进程\n-f : 表示full，显示全部的列（显示全字段）\n```\n\n案例：显示当前系统中所有进程的信息\n\n```powershell\n# ps -ef\n```\n\n![image-20200324162137670](media/image-20200324162137670.png)\n\n| UID   | 该进程执行的用户ID                                           |\n| ----- | ------------------------------------------------------------ |\n| PID   | 进程ID                                                       |\n| PPID  | 该进程的父级进程ID，如果找不到，则该进程就被称之为僵尸进程（Parent Process ID） |\n| C     | Cpu的占用率，其形式是百分数                                  |\n| STIME | 进程的启动时间                                               |\n| TTY   | 终端设备，发起该进程的设备识别符号，如果显示“?”则表示该进程并不是由终端设备发起 |\n| TIME  | 进程实际使用CPU的时间                                        |\n| CMD   | 该进程的名称或者对应的路径                                   |\n\n> 经验之谈：我们在实际工作中使用ps命令其实主要用于查询某个进程的PID或PPID\n\n工作场景\n\n​        小黑用学到的命令，发现某个进程占用CPU很高，希望进一步查看这个简称的信息。\n\n​        ps -ef 会列出全部进程，但是我们发现进程非常多，我们很难找到自己想要看的进程。这里需要使用过滤命令grep，来过滤掉我们不需要的信息。\n\n基本语法：\n\n```powershell\n用法：ps -ef |grep 想要看到的进程名\n示例代码：\n# ps -ef |grep crond\n含义：查看crond进程的详细情况\n注意：查询结果中，如果只有一条则表示没查到对应的进程（这1 条表示刚才ps 指令的自身）。只有查到的结果多余1 条，才表示有对应的进程。\n```\n\n案例：查询crond的进程信息\n\n```powershell\n# ps -ef |grep crond\nroot       7102      1  0 Mar23 ?        00:00:04 /usr/sbin/crond -n\nroot      24752  12881  0 16:34 pts/2    00:00:00 grep --color=auto crond\n```\n\n问题：以上信息只有第一行是crond的进程，第二行，实际是管道命令发起时，grep所启动的进程，如何去掉？\n\n```powershell\n# ps -ef |grep crond |grep -v "grep"\nroot       7102      1  0 Mar23 ?        00:00:04 /usr/sbin/crond -n\n```\n\n> grep  -v  需要去除的相关信息 ： 去除包含指定关键词的那一行\n\n扩展：ps  aux命令\n\n```powershell\n# ps aux\n```\n\n> \\# man ps\n>\n> 1   UNIX options, which may be grouped and must be preceded by a dash.     ps  -ef\n> 2   BSD options, which may be grouped and must not be used with a dash.\t ps  aux\n\n![image-20200324165018806](media/image-20200324165018806.png)\n\nUSER：该 process 属于哪个使用者账号\n==PID ：该 process 的ID==\n==%CPU：该 process 使用掉的 CPU 资源百分比==\n==%MEM：该 process 所占用的物理内存百分比==\nVSZ ：该 process 使用掉的虚拟内存量 (Kbytes)\nRSS ：该 process 占用的固定的内存量 (Kbytes)\nTTY ：该 process 是在那个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1-tty6 是本机上面的登入者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序。\n==STAT：该程序目前的状态，主要的状态有==\n    R ：该程序目前正在运作，或者是可被运作\n    S ：该程序目前正在睡眠当中 (可说是 idle 状态)，但可被某些讯号 (signal) 唤醒。\n    T ：该程序目前正在侦测或者是停止了\n   ==Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态==\nSTART：该 process 被触发启动的时间\nTIME ：该 process 实际使用 CPU 运作的时间\nCOMMAND：该程序的实际指令\n\n## 8、netstat/ss查询网络访问信息\n\n基本语法：\n\n```powershell\n# netstat [选项] |grep 进程名称\n选项说明：\n-t：表示只列出tcp 协议的连接（tcp协议与udp协议）\n-n：表示将地址从字母组合转化成ip 地址，将协议转化成端口号来显示  10.1.1.10:80\n-l：表示过滤出"state（状态）"列中其值为LISTEN（监听）的连接\n-p：表示显示发起连接的进程pid 和进程名称\n```\n\n案例：查询Web Server（httpd）服务的端口信息\n\n```powershell\n# netstat -tnlp |grep httpd\n```\n\n\n\n基本语法：\n\n```powershell\n# ss -naltp |grep 进程名称\n```\n\n案例：查询sshd服务的端口信息\n\n```powershell\n# ss -naltp |grep sshd\n```\n\n> netstat与ss区别？① netstat信息比较简洁，ss更加丰富 ② ss执行效率比netstat略高一些\n\n## 9、kill/killall杀死进程\n\n### ☆ 根据pid杀掉进程\n\n```powershell\n命令：kill\n语法：kill [信号] PID\n作用：kill 命令会向操作系统内核发送一个信号（多是终止信号）和目标进程的 PID，然后系统内核根据收到的信号类型，对指定进程进行相应的操作\n\n经验：kill经常结合ps命令一起使用\n```\n\n> kill命令用于杀死某个进程，这其实只是其一个功能。kill命令的实质是向进程发送信号\n\n信号种类：\n\n| 信号编号 | 含义                                     |\n| -------- | ---------------------------------------- |\n| 9        | 杀死进程，即强制结束进程。               |\n| 15       | 正常结束进程，是 kill   命令的默认信号。 |\n\n案例：使用kill命令杀死crond进程\n\n```powershell\n# ps -ef |grep crond\n7102\n# kill 7102\n```\n\n> 备注：在互联网中，经常看到kill  -9  进程PID，强制杀死某个进程，kill -9 pid\n\n### ☆ 根据进程名称杀掉进程\n\n基本语法：\n\n```powershell\n# killall [信号编号] 进程名称\n```\n\n案例：使用killall命令杀死crond进程\n\n```powershell\n# killall crond\n```\n\n案例：使用killall命令杀死httpd进程\n\n```powershell\n# killall httpd\n```\n\n\n# 三、进程的优先级（扩展）\n\n## 1、什么是进程的优先级\n\nLinux是一个多用户、多任务的操作系统，系统中通常运行着非常多的进程。哪些进程先运行，哪些进程后运行，就由进程优先级来控制\n\n思考：什么时候需要用到进程的优先级呢？\n\n答：当CPU负载过高时，如CPU的使用率>=90%以上。这个时候进程的优先级就会起作用。\n\n## 2、查看进程的优先级\n\nPR  优先级，数值越小优先级越高。\nNI  优先级，数值越小优先级越高，可以人为更改。（NI = NICE = Nice）\n\n讲个小故事：Nice值 = 0，Nice值越高，代表这个人越绅士（Nice值越高，优先级越低）\n\n> NI值有一个范围 -20 ~ 19\n\n问题：这两个数值是在哪里看到的？\n\n答：top命令\n\n## 3、调整进程的优先级\n\n### ☆ 使用top调整进程的优先级\n\n第一步：使用top命令获取你要调整的进程信息（PID编号）\n\n```powershell\n# top -bn 1\nPID   \tCOMMAND\n7107\tatd（at命令的底层服务）\n```\n\n第二步：运行top命令，然后按=="r"==，输入要调整进程的PID编号\n\n```powershell\n# top\n按r，输入要调整进程的PID编号,按回车\n```\n\n第三步：根据提示，重置NICE值\n\n```powershell\nRenice PID 7107 to value : -5\n```\n\n第四步：按q退出top模式，然后使用top -p PID编号，只查询某个进程的信息\n\n```powershell\n# top -p 7107\n```\n\n### ☆ 使用renice命令调整进程的优先级\n\n基本语法：\n\n```powershell\n# renice [NI优先级设置的数字] 想调整的进程ID\n```\n\n案例：使用renice调整atd的优先级\n\n```powershell\n第一步：通过ps或top命令获取atd的PID编号\n# ps -ef |grep atd\n7107\n第二步：使用renice命令调整7107的NICE值\n# renice -10 7107\n7107 (process ID) old priority 0, new priority -10\n```\n\n> 注意：NICE值取值范围-20 ~ 19，不能使用小数\n\n### ☆ 使用nice命令调整进程的优先级\n\n基本语法：\n\n```powershell\n# nice [NI优先级设置的数字] 想调整的进程名称\n```\n\n> 注意：nice命令只能调整没有运行的程序\n\nnice实际操作三步走：\n\n第一步：将程序停止\n\n```powershell\n# ps -ef |grep crond\n# kill PID\n或\n# systemctl stop crond\n```\n\n第二步：启动并制定优先级（使用nice）\n\n```powershell\n# nice -n -10 crond\n```\n\n> nice命令包含两个功能：① 启动进程 ② 调整进程的优先级\n\n第三步：确认优先级（查看优先级）\n\n```powershell\n# ps -ef |grep crond\nPID\n# top -p PID\n```\n\n\n\n\n\n\n'),V={data:function(){return{MainComponent:Y,img_prefix:"./img/linux/heima-Linux云计算/进程检测与控制/"}},methods:{extendMarkdown:function(n){var r=this;console.log(n.renderer.rules);var e=n.renderer.rules.html_block;n.renderer.rules.html_block=function(n,t,i,s,a){var o=n[t];if(console.log("1"),o.content.includes("<img")){console.log("token-- ",o);var l="";l=o.content;var p=l.split('src="'),c=p[0]+' src="'+r.img_prefix+p[1];o.content=c}return o.attrSet("class","q-markdown--token  "),e(n,t,i,s,a)},n.renderer.rules.image=function(n,e,t,i,s){var a=n[e];console.log("3"),a.attrSet("class","q-markdown--image"),console.log("token--- "+e+"-----",a);var o=a.attrGet("src");return console.log(o),a.attrSet("src",r.img_prefix+o),s.renderToken(n,e,t)}}}},X=V,Z=Object(p["a"])(X,K,Q,!1,null,"9241284e",null),J=Z.exports,nn=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},rn=[function(){var n=this,r=n.$createElement,e=n._self._c||r;return e("div",[e("pre",[n._v("\n---查看端口占用\nnetstat -ap | grep 8000\n\n---重启nginx\nsudo /usr/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\nsudo nginx -s reload\nSudo service nginx restart\nps -ef | grep nginx\n")])])}],en={},tn=en,sn=Object(p["a"])(tn,nn,rn,!1,null,"4c124315",null),an=sn.exports,on=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},ln=[function(){var n=this,r=n.$createElement,e=n._self._c||r;return e("div",[e("pre",[n._v(" "),e("code",[n._v("     \n一、查看日志和机器相关信息常用命令\n\n1、cat\ncat 命令连接文件并打印到标准输出设备上，cat经常用来显示文件的内容，类似于下的type命令\n注意：当文件较大时，文本在屏幕上迅速闪过（滚屏），用户往往看不清所显示的内容。因此，一般用more等命令分屏显示。为了控制滚屏，可以按Ctrl+S键，停止滚屏；按Ctrl+Q键可以恢复滚屏。按Ctrl+C（中断）键可以终止该命令的执行，并且返回Shell提示符状态。\n\n2、tail \n\ntail命令  用于输入文件中的尾部内容。tail命令默认在屏幕上显示指定文件的末尾10行。如果给定的文件不止一个，则在显示的每个文件前面加一个文件名标题。如果没有指定文件或者文件名为“-”，则读取标准输入。\n\n常用参数：\n\n-f<name/descriptor>或；--follow<nameldescript>：显示文件最新追加的内容。“name”表示以文件名的方式监视文件的变化。“-f”与“-fdescriptor”等效；\n-n<N>或——line=<N>：输出文件的尾部N（N位数字）行内容。\n-s<秒数>或——sleep-interal=<秒数>：与“-f”选项连用，指定监视文件变化时间隔的秒数；　　\n\n\n二、实际操作须知\n\n1、日志文件说明\n\n/var/log/message     //系统启动后的信息和错误日志，是Red Hat Linux中最常用的日志之一\n/var/log/secure      //与安全相关的日志信息\n/var/log/maillog    //与邮件相关的日志信息\n/var/log/cron       //与定时任务相关的日志信息\n/var/log/spooler    //与UUCP和news设备相关的日志信息\n/var/log/boot.log   //守护进程启动和停止相关的日志消息\n2、查看系统信息\n\n# uname -a                # 查看内核/操作系统/CPU信息\n# cat /etc/issue\n# cat /etc/redhat-release # 查看操作系统版本\n# cat /proc/cpuinfo       # 查看CPU信息\n# hostname                # 查看计算机名\n# lspci -tv               # 列出所有PCI设备\n# lsusb -tv               # 列出所有USB设备\n# lsmod                   # 列出加载的内核模块\n# env                     # 查看环境变量\n3、查看系统运行资源　　\n\n# free -m                     # 查看内存使用量和交换区使用量\n# df -h                       # 查看各分区使用情况\n# du -sh <目录名>             # 查看指定目录的大小\n# grep MemTotal /proc/meminfo # 查看内存总量\n# grep MemFree /proc/meminfo  # 查看空闲内存量\n# uptime                      # 查看系统运行时间、用户数、负载\n# cat /proc/loadavg           # 查看系统负载\n4、查看系统磁盘和分区信息\n\n# mount | column -t  # 查看挂接的分区状态\n# fdisk -l                  # 查看所有分区\n# swapon -s             # 查看所有交换分区\n# hdparm -i /dev/hda  # 查看磁盘参数(仅适用于IDE设备)\n# dmesg | grep IDE  # 查看启动时IDE设备检测状况\n5、查看网络信息　　\n\n# ifconfig        # 查看所有网络接口的属性\n# iptables -L     # 查看防火墙设置\n# route -n        # 查看路由表\n# netstat -lntp   # 查看所有监听端口\n# netstat -antp   # 查看所有已经建立的连接\n# netstat -s      # 查看网络统计信息\n6、查看进程　　\n\n# ps -ef   # 查看所有进程\n# top      # 实时显示进程状态\n7、查看用户信息\n\n# w                       # 查看活动用户\n# id <用户名>             # 查看指定用户信息\n# last                    # 查看用户登录日志\n# cut -d: -f1 /etc/passwd # 查看系统所有用户\n# cut -d: -f1 /etc/group  # 查看系统所有组\n# crontab -l              # 查看当前用户的计划任务\n8、查看服务\n\n# chkconfig –list           # 列出所有系统服务\n# chkconfig –list | grep on # 列出所有启动的系统服务\n9、查看系统安装程序　　\n\n# rpm -qa   # 查看所有安装的软件包　　\n\n\n ")]),n._v("\n")])])}],pn={},cn=pn,dn=Object(p["a"])(cn,on,ln,!1,null,"1e61cfb9",null),un=dn.exports,mn=function(){var n=this,r=n.$createElement,e=n._self._c||r;return e("div")},gn=[],_n={},hn=_n,vn=Object(p["a"])(hn,mn,gn,!1,null,"f7c8c224",null),xn=vn.exports,fn=function(){var n=this,r=n.$createElement,e=n._self._c||r;return e("div",[e("div",{},[e("q-markdown",{attrs:{src:n.MainComponent}})],1)])},bn=[],wn="\r\n\r\n\r\n\r\n\x3c!--\r\n\r\n * @Date           : 2021-07-07 02:42:15\r\n * @FilePath       : /jinnian-space/src/pages/linux/md/linux-目录.md\r\n * @Description    : \r\n--\x3e\r\n\r\n\r\n| centos6 运行级别： | 作用                                  |\r\n| ---------- | ------------------------------------- |\r\n| 0          | 表示关机                              |\r\n| 1          | 单用户模式，就是Windows中的“安全模式” |\r\n| 2          | 断网状态下的多用户模式                |\r\n| 3          | 纯命令行模式（强烈推荐使用此模式）    |\r\n| 4          | 还没想好做什么用的模式（保留模式）    |\r\n| 5          | 图形用户界面（X-Window）              |\r\n| 6          | 表示重启（一开机就会重启）            |\r\n\r\n|          | LINUX有四种基本文件系统类型                                  |\r\n| -------- | ------------------------------------------------------------ |\r\n| 普通文件 | 如文本文件、C语言元代码、SHELL脚本、二进制的可执行文件等，可用cat、less、more、vi、emacs来察看内容，用mv来改名。 |\r\n| 目录文件 | 包括文件名、子目录名及其指针。它是LINUX储存文件名的唯一地方，可用ls列出目录文件。 |\r\n| 连接文   | 是指向同一索引节点的那些目录条目。用ls来查看是，连接文件的标志用l开头，而文件面后以”->”指向所连接的文件。 |\r\n| 特殊文件 | LINUX的一些设备如磁盘、终端、打印机等都在文件系统中表示出来，则一类文件就是特殊文件，常放在/dev目录内。例如，软驱A称为/dev/fd0。LINUX无C：的概念，而是用/dev/had来自第一硬盘。 |\r\n\r\n\r\n\r\n| 目录       |                      | 作用                                                         |\r\n| ---------- | -------------------- | ------------------------------------------------------------ |\r\n| bin        | user        binaries | 二进制文件的目录（就是可执行程序的目录） ,存放系统命令，普通用户和 root 都可以执行。放在 /bin 下的命令在单用户模式下也可以执行 |\r\n| boot       | boot loader files    | 系统启动时需要读取的目录 ,系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序（GRUB或LILO）文件等 |\r\n| dev        | device files         | 存放设备文件的目录（device） Linux中，设备分为两种：块设备（block）、字符设备（character）。 硬盘、软驱、光驱都属于“块设备”， 鼠标、键盘都属于“字符设备”。 |\r\n| etc        | configuration  files | 系统的配置文件（系统的信息存放在这里，比如我们的帐号以及密码）,系统内所有采用默认安装方式（rpm 安装）的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等 |\r\n| home       | home                 | 普通用户的主目录，（也称为家目录）。类似于Windows的C:\\Documents and Settings下的目录. 每个用户要有一个默认登录和保存自己数据的位置，就是用户的主目录，所有普通用户的主目录是在 /home/ 下建立一个和用户名相同的目录。如用户 liming 的主目录就是 /home/liming |\r\n| initrd     |                      | 初始化的目录，比如我们希望系统开机的时候配置一下IP           |\r\n| lib        | system libraies      | 库函数的目录（Library），类似“外挂”目录 ,系统调用的函数库保存位置 |\r\n| lib64      |                      | 作用同 lib 目录                                              |\r\n| lost+found |                      | 系统出错时，会存放一些丢失的文件在这个目录里 ，当系统意外崩溃或意外关机时，产生的一些文件碎片会存放在这里。在系统启动的过程中，fsck 工具会检查这里，并修复已经损坏的文件系统。 这个目录只在每个分区中出现，例如，/lost+found 就是根分区的备份恢复目录，/boot/lost+found 就是 /boot 分区的备份恢复目录 |\r\n| media      | removable devices    | 挂载目录。系统建议用来挂载媒体设备，如软盘和光盘 ，存放一些可删除的设备文件 ，光盘，软驱 |\r\n| misc       |                      | 挂载目录。系统建议用来挂载 NFS 服务的共享目录。虽然系统准备了三个默认挂载目录 /media/、/mnt/、/misc/，但是到底在哪个目录中挂载什么设备可以由管理员自己决定。 例如，笔者在接触 Linux 的时候，默认挂载目录只有 /mnt/，所以养成了在 /mnt/ 下建立不同目录挂载不同设备的习惯，如 /mnt/cdrom/ 挂载光盘、/mnt/usb/ 挂载 U 盘，都是可以的 |\r\n| mnt        | mount directory      | 存放一些临时需要挂载（mount）的设备 ,移动硬盘，U盘 ，挂载目录。早期 Linux 中只有这一个挂载目录，并没有细分。系统建议这个目录用来挂载额外的设备，如 U 盘、移动硬盘和其他操作系统的分区。可以参看/etc/fstab的定义。有时我们可以把让系统开机自动挂载文件系统，把挂载点放在这里也是可以的。主要看/etc/fstab中怎 么定义了；比如光驱可以挂载到/mnt/cdrom |\r\n| opt        | optional add-on Apps | 类似于windows的Programfiles目录，一般是用来安装程序的。optional（可选） 第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。不过笔者还是习惯把软件放到 /usr/local/ 目录中，也就是说，/usr/local/ 目录也可以用来安装软件。这里主要存放那些可选的程序。你想尝试最新的firefox测试版吗?那就装到/opt目录下吧，这样，当你尝试完，想删掉firefox的时候，你就可 以直接删除它，而不影响系统其他任何设置。安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。举个例子：刚才装的测试版firefox，就可以装到/opt/firefox_beta目录下，/opt/firefox_beta目录下面就包含了运 行firefox所需要的所有文件、库、数据等等。要删除firefox的时候，你只需删除/opt/firefox_beta目录即可，非常简单。 |\r\n| proc       | process  information | 虚拟文件系统。特殊目录。这里的所有文件都不是在硬盘里的，而是在内存里的。也就是这个目录的文件都是内存的真实映射。 该目录中的数据并不保存在硬盘上，而是保存到内存中。主要保存系统的内核、进程、外部设备状态和网络状态等。操作系统运行时，进程信息及内核信息（比如cpu、硬盘分区、内存信息等）存放在这里。/proc目录伪装的文件系统proc的挂载目录，proc并不是真正的文件系统，它的定义可以参见 /etc/fstab 。 如 /proc/cpuinfo 是保存 CPU 信息的，/proc/devices 是保存设备驱动的列表的，/proc/filesystems 是保存文件系统列表的，/proc/net 是保存网络协议信息的… |\r\n| root       |                      | 超级用户的主目录，也就是root的主目录，类似于C:\\Documents and Settings\\Administrator ,root 的主目录。普通用户主目录在 /home/ 下，root 主目录直接在“/”下 |\r\n| sbin       | system binaries      | 类似于bin目录。区别在于sbin目录的东西都是给superuser的，即superuser’sbin ,保存与系统环境设置相关的命令，只有 root 可以使用这些命令进行系统环境设置，但也有些命令可以允许普通用户查看。大多是涉及系统管理的命令的存放，是超级权限用户root的可执行命令存放地，普通用户无权限执行这个目录下的命令，这个目录和/usr/sbin; /usr/X11R6/sbin或/usr/local/sbin目录是相似的；我们记住就行了，凡是目录sbin中包含的都是root权限才能执行的。 |\r\n| selinux    |                      | SecureLinux关于安全策略的配置                                |\r\n| srv        | service data         | 服务需要取的数据目录 ,服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据 |\r\n| sys        |                      | 虚拟文件系统。和 proc 目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息.同样不占硬盘空间 |\r\n| tmp        |                      | 临时目录temporary 。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。建议此目录中不能保存重要数据，最好每次开机都把该目录清理 |\r\n| usr        | user programs        | 类似于前面的opt目录，但是存放在这个地方的软件都是很重要的。相当于windows里C:\\WINDOWS和C:\\Program Files的综合体。Usr=Unix Software Resource. 在这个目录下，你可以找到那些不适合放在/bin或/etc目录下的额外的工具。比如像游戏阿，一些打印工具拉等等。/usr目录包含了许多子目录： /usr/bin目录用于存放程序;/usr/share用于存放一些共享的数据，比如音乐文件或者图标等等;/usr/lib目录用于存放那些不能直接 运行的，但却是许多程序运行所必需的一些函数库文件。你的软件包管理器(应该是“yum”吧)会自动帮你管理好/usr目录的。 |\r\n| usr/local  |                      | 这里主要存放那些手动安装的软件，即不是通过“yum”或apt-get安装的软件。它和/usr目录具有相类似的目录结构。让软件包管理器来管理/usr目录，而把自定义的脚本(scripts)放到/usr/local目录下面。一般是通过源码包安装的软件，如果没有特别指定安装目录的话，一般是安装在这个目录中。 |\r\n| usr/share  |                      | 系统共用的东西存放地，比如 /usr/share/fonts 是字体目录，/usr/share/doc和/usr/share/man帮助文件。 |\r\n| var        | variable files       | 常态性变动的文件，比如缓存、mysql文件、mail的数据 ，系统日志等 |\r\n| var/log    |                      | 系统日志存放，分析日志要看这个目录的东西                     |\r\n| var/spool  |                      | 打印机、邮件、代理服务器等假脱机目录；                       |\r\n\r\n",Ln={data:function(){return{MainComponent:wn}}},Cn=Ln,kn=Object(p["a"])(Cn,fn,bn,!1,null,"60e64c33",null),yn=kn.exports,Pn=function(){var n=this,r=n.$createElement,e=n._self._c||r;return e("div",{},[e("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}})],1)},Sn=[],In="\x3c!--\r\n * @Date           : 2021-07-15 00:12:03\r\n * @FilePath       : /jinnian-space/src/pages/linux/md/linux-yum+LAMP开源部署.md\r\n * @Description    : \r\n--\x3e\r\n\r\n# YUM+LAMP开源部署 Discuz 论坛\r\n\r\n# YUM\r\n\r\n## 1、什么是YUM\r\n\r\n在CentOS系统中，软件管理方式通常有三种方式：`rpm安装`、`yum安装`以及`编译安装`。\r\n\r\n```powershell\r\n编译安装，从过程上来讲比较麻烦，包需要用户自行下载，下载的是源码包，需要进行编译操作，编译好了才能进行安装，这个过程对于刚接触Linux的人来说比较麻烦，而且还容易出错。好处在于是源码包，对于有需要自定义模块的用户来说非常方便。(就业班会着重讲解)\r\n```\r\n\r\n难度：编译安装 > rpm安装 > yum安装（有网络 + yum源支持）\r\n\r\nYum（全称为 `Yellow dog Updater, Modified`）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。\r\n\r\n基于rpm包管理，能够从**指定的服务器**(yum源）自动下载RPM包并且安装，可以==自动处理依赖性关系==，并且==一次安装所有依赖的软件包==，无须繁琐地一次次下载、安装。\r\n\r\n> rpm和yum区别？答：① yum底层也是基于rpm进行安装的（yum安装的软件，可以通过rpm -qa进行查询） ② yum相对于rpm最大的优势，可以解决依赖关系。\r\n>\r\n> A => B => C\r\n\r\n## 2、YUM源配置\r\n\r\n![image-20200326115612781](media/image-20200326115612781.png)\r\n\r\nYUM源配置文件所在路径 => /etc/yum.repos.d文件夹\r\n\r\n-rw-r--r--. 1 root root 1991 Mar 28  2017 CentOS-Base.repo            网络yum源配置文件\r\n-rw-r--r--. 1 root root  647 Mar 28  2017 CentOS-Debuginfo.repo    内核相关的更新包\r\n-rw-r--r--. 1 root root  289 Mar 28  2017 CentOS-fasttrack.repo       快速通道\r\n-rw-r--r--. 1 root root  630 Mar 28  2017 CentOS-Media.repo           本地yum源配置文件\r\n-rw-r--r--. 1 root root 7989 Mar 28  2017 CentOS-Vault.repo          最近版本加入老本的YUM配置   \r\n\r\n扩展：在YUM镜像源中添加阿里云镜像源\r\n\r\n```powershell\r\n第一步：备份CentOS-Base.repo这个源（更改后缀名.repo => .repo.bak）\r\n# mv CentOS-Base.repo CentOS-Base.repo.bak\r\n\r\n第二步：使用wget命令下载阿里云的镜像文件\r\n# wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo\r\n\r\n选项说明：\r\n-O ：指定文件下载的位置以及名称\r\n第三步：清理YUM缓存\r\n# yum clean all\r\n\r\n第四步：重新建立缓存（让新YUM源生效）\r\n# yum makecache\r\n```\r\n\r\n## 3、yum命令详解\r\n\r\n### ☆ 搜索要安装的软件\r\n\r\n```powershell\r\n# yum search 软件名称的关键词\r\n```\r\n\r\n案例：搜索阿里云仓库中的vim软件\r\n\r\n```powershell\r\n# yum search vim\r\n```\r\n\r\n案例：搜索firefox火狐浏览器\r\n\r\n```powershell\r\n# yum search firefox\r\n```\r\n\r\n### ☆ 使用yum安装软件\r\n\r\n基本语法：\r\n\r\n```powershell\r\n# yum install 软件名称关键词 [选项]\r\n选项：\r\n-y ：yes缩写，确认安装，不提示。\r\n```\r\n\r\n案例：使用yum命令安装vim编辑器\r\n\r\n```powershell\r\n# yum install vim -y\r\n```\r\n\r\n案例：使用yum命令安装firefox浏览器\r\n\r\n```powershell\r\n# yum install firefox -y\r\n```\r\n\r\n### ☆ 使用yum卸载软件\r\n\r\n```powershell\r\n# yum remove 软件名称关键词 [选项]\r\n选项：\r\n-y ：yes缩写，确认卸载，不提示。\r\n```\r\n\r\n案例：把firefox火狐浏览器进行卸载操作\r\n\r\n```powershell\r\n# yum remove firefox -y\r\n```\r\n\r\n案例：把httpd软件进行强制卸载\r\n\r\n```powershell\r\n# yum remove httpd -y\r\n```\r\n\r\n### ☆ 使用yum更新软件\r\n\r\n基本语法：\r\n\r\n```powershell\r\n# yum update 软件名称关键词 [选项]\r\n选项：\r\n-y ：yes缩写，确认更新，不提示\r\n```\r\n\r\n案例：把vim编辑器进行更新操作\r\n\r\n```powershell\r\n# yum update vim -y\r\n```\r\n\r\n案例：把firefox火狐浏览器进行更新操作\r\n\r\n```powershell\r\n# yum update firefox -y\r\n```\r\n\r\n# 三、LAMP概述\r\n\r\n## 1、什么是LAMP\r\n\r\nLAMP：==L==inux + ==A==pache + ==M==ySQL + ==P==HP                        LAMP 架构（组合）\r\n\r\nLNMP：Linux + Nginx + MySQL + php-fpm                             LNMP 架构（组合）\r\n\r\nLNMPA：Linux + Nginx(80) + MySQL + PHP + Apache           Nginx 代理方式\r\n\r\n![image-20200326152052773](media/image-20200326152052773.png)\r\n\r\nApache：Apache是世界使用排名第一的Web服务器软件。\r\n\r\nPHP：一种专门用于Web开发的编程语言。\r\n\r\nMySQL：MySQL是一个关系型数据库管理系统，主要用于永久存储项目数据。\r\n\r\n## 2、AMP三者之间的关系\r\n\r\n![image-20200326152231295](media/image-20200326152231295.png)\r\n\r\nApache：用于接收用户的请求（输入网址，返回网页=>结果）\r\n\r\nPHP：注册、登录、加入购物车、下单、支付等动态功能（有编程语言的支持）\r\n\r\nMySQL：永久保存数据，比如你在网站上注册的用户和密码、你加入购物车的产品、你的产品订单\r\n\r\nLAMP = Linux + APache + PHP + MySQL\r\n\r\n# 四、阿里云详解\r\n\r\n要想部署一个互联网上可以访问到的环境，必须先具备以下内容 ：\r\n\r\n服务器（IP、帐号密码、终端）、相应的软件、域名（备案、解析）、代码等。\r\n\r\n![image-20200326154214921](media/image-20200326154214921.png)\r\n\r\n代码：前端工程师 + 后端工程师进行开发提供的！\r\n\r\n## 1、注册阿里云账号\r\n\r\n阿里云官网：https://www.aliyun.com/\r\n\r\n![image-20200326154527903](media/image-20200326154527903.png)\r\n\r\n> 特别说明：云服务器的厂商特别多，你可以进行任意选择 => 阿里云、百度云、腾讯云、华为云...\r\n\r\n注册时建议使用支付宝，方便快捷。最重要：付款方便\r\n\r\n## 2、实名认证（上传身份证照片）\r\n\r\n第一步：单击账号下方的实名认证（选择个人认证）\r\n\r\n![image-20200326155133047](media/image-20200326155133047.png)\r\n\r\n![image-20200326155146301](media/image-20200326155146301.png)\r\n\r\n第二步：选择支付宝授权认证（及时开通，无需等待）\r\n\r\n![image-20200326155223066](media/image-20200326155223066.png)\r\n\r\n第三步：勾选同意，点击提交\r\n\r\n![image-20200326155308208](media/image-20200326155308208.png)\r\n\r\n第四步：使用手机支付宝扫描二维码，进行授权\r\n\r\n![image-20200326155339781](media/image-20200326155339781.png)\r\n\r\n第五步：填写相关信息（住址）\r\n\r\n![image-20200326155358292](media/image-20200326155358292.png)\r\n\r\n填写完毕，即可完成认证。\r\n\r\n![image-20200326155428202](media/image-20200326155428202.png)\r\n\r\n## 3、购买阿里云的ECS云服务器\r\n\r\n第一步：回到阿里云首页，找到弹性计算 => ECS云服务器\r\n\r\n![image-20200326161759062](media/image-20200326161759062.png)\r\n\r\n第二步：单击立即购买，购买ECS服务器（选区域、选配置）\r\n\r\n![image-20200326161916781](media/image-20200326161916781.png)\r\n\r\n第三步：选择付费模式、选择CPU与内存的配置\r\n\r\n![image-20200326162659403](media/image-20200326162659403.png)\r\n\r\n第四步：选择镜像（CentOS7.6）与云盘（硬盘）\r\n\r\n![image-20200326162845467](media/image-20200326162845467.png)\r\n\r\n第四步：设置网络、公网IP以及安全组（重要）\r\n\r\n![image-20200326163143681](media/image-20200326163143681.png)\r\n\r\n> 用户 =>  阿里云安全组  =>  firewalld防火墙  => Linux服务器\r\n\r\n第五步：设置root账号密码（一定要选择自定义密码）\r\n\r\n![image-20200326163533492](media/image-20200326163533492.png)\r\n\r\n> 8 - 30 个字符，必须同时包含三项（大写字母、小写字母、数字、 ()`~!@#$%^&*_-+=|{}[]:;'<>,.?/ 中的特殊符号），其中 Windows 实例不能以斜线号（/）为首字符\r\n\r\n第六步：设置释放时间 => 什么时候删除这台服务器（不收钱）\r\n\r\n![image-20200326163830484](media/image-20200326163830484.png)\r\n\r\n> 特别说明：只有个人购买的ECS服务器可以设置释放时间，生产环境一定不要设置释放时间，否则后果自负！！！\r\n\r\n第七步：进入管理控制台，找到我们刚才购买的ECS服务器，如下图所示：\r\n\r\n![image-20200326164148544](media/image-20200326164148544.png)\r\n\r\n> 使用MX软件，直接连接公网IP + root账号 + 自定义的密码即可连接\r\n\r\n## 4、使用MX连接ECS服务器\r\n\r\n![image-20200326164519379](media/image-20200326164519379.png)\r\n\r\n## 5、使用yum安装sl小工具\r\n\r\n安装过程：\r\n\r\n```powershell\r\n# yum install sl -y\r\n```\r\n\r\n使用sl命令：\r\n\r\n```powershell\r\n# sl\r\n```\r\n\r\n# LAMP项目部署实战\r\n\r\n# 一、LAMP环境部署\r\n\r\n## 1、回顾LAMP\r\n\r\nLAMP = Linux + Apache + MySQL + PHP\r\n\r\n![image-20200327093726255](media/image-20200327093726255.png)\r\n\r\nApache：主要用于接收用户的请求，处理业务逻辑，返回结果给客户端（浏览器）\r\n\r\nPHP：编程语言的一种，主要应用于Web开发。主要实现注册、登录、加入购物车、下单、支付等功能\r\n\r\nMySQL：数据库，删库到跑路，这里的\"库\"就是指数据库。永久保存数据\r\n\r\n## 2、LAMP部署前期准备\r\n\r\n### ☆ 关闭防火墙\r\n\r\n```powershell\r\n# systemctl stop firewalld\r\n# systemctl disable firewalld\r\n```\r\n\r\n### ☆ 关闭SELinux\r\n\r\n*SELinux*(Security-Enhanced Linux) 是美国国家安全局（NSA）对于强制访问控制的实现，是 Linux历史上最杰出的新安全子系统。\r\n\r\n获取SELinux的状态：\r\n\r\n```powershell\r\n# getenforce\r\n```\r\n\r\n临时关闭SElinux：重启后SELinux还会自动启动\r\n\r\n```powershell\r\n# setenforce 0\r\n```\r\n\r\n永久关闭SELinux：编辑SELinux的配置文件\r\n\r\n```powershell\r\n# vim /etc/selinux/config\r\nSELINUX=disabled\r\n```\r\n\r\n### ☆ 检查系统中是否已安装Apache\r\n\r\n```powershell\r\n# rpm -qa |grep httpd\r\n\r\n# rpm -e httpd-2.4.6-90.el7.centos.x86_64\r\n# rpm -e httpd-tools-2.4.6-90.el7.centos.x86_64\r\n```\r\n\r\n### ☆ 检查系统中是否已安装MySQL\r\n\r\n```powershell\r\n# rpm -qa |grep mysql\r\n```\r\n\r\n### ☆ 检查系统中是否已安装PHP\r\n\r\n```powershell\r\n# rpm -qa |grep php\r\n```\r\n\r\n> AMP安装指南：在Linux中安装AMP必须先安装Apache，在安装MySQL，最后安装PHP\r\n\r\n## 3、LAMP环境之Apache安装\r\n\r\nApache：阿帕奇，Apache基金会\r\n\r\nhttpd软件 => 前身apache，随着时间的推移以及互联网行业的发展，越来越多的软件加入到了Apache的基金会。\r\n\r\n第一步：安装httpd软件\r\n\r\n```powershell\r\n# yum install httpd -y\r\n```\r\n\r\n第二步：配置/etc/httpd/conf/httpd.conf文件\r\n\r\n```powershell\r\n# vim /etc/httpd/conf/httpd.conf\r\n/ServerName => 搜索\r\n96 ServerName localhost:80\r\n```\r\n\r\n> localhost ： 代表本机，对应的IP地址可以使127.0.0.1或本机的公网IP\r\n\r\n第三步：启动httpd服务\r\n\r\n```powershell\r\n# systemctl start httpd\r\n```\r\n\r\n第四步：把httpd服务添加到开机启动项中\r\n\r\n```powershell\r\n# systemctl enable httpd\r\n```\r\n\r\n第五步：使用ss或netstat命令查询httpd占用的端口\r\n\r\n```powershell\r\n# netstat -tnlp |grep httpd\r\n或\r\n# ss -naltp |grep httpd\r\n```\r\n\r\n第六步：在浏览器中，使用公网IP访问阿里云服务器\r\n\r\n![image-20200327104156113](media/image-20200327104156113.png)\r\n\r\n## 4、LAMP环境之MySQL安装\r\n\r\n### ☆ 下载MySQL的官网yum源\r\n\r\n由于yum源上默认没有mysql-server。所以必须去官网下载后在安装\r\n\r\n```powershell\r\n# wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm\r\n```\r\n\r\n### ☆ 安装MySQL的官网镜像源\r\n\r\n```powershell\r\n# rpm -ivh mysql-community-release-el7-5.noarch.rpm\r\n```\r\n\r\n### ☆ 使用yum安装mysql最新版软件\r\n\r\n```powershell\r\n# yum install mysql-community-server -y\r\n```\r\n\r\n> MySQL软件是一个C/S架构的软件，拥有客户端与服务器端。mysql-server服务器端（内部也包含了客户端），community代表社区版（免费开源）\r\n\r\n### ☆ 启动mysql，查看端口占用情况\r\n\r\n```powershell\r\n# systemctl start mysqld\r\n# netstat -tnlp |grep mysqld\r\n```\r\n\r\n### ☆ MySQL数据库初始化（重要）\r\n\r\n默认情况下，数据库没有密码，也没有任何数据，必须要初始化\r\n\r\n#### ① 初始化数据，设置root密码（MySQL管理员）\r\n\r\n```powershell\r\n# mysql_secure_installation\r\n```\r\n\r\n![image-20200327114309107](media/image-20200327114309107.png)\r\n\r\n> 扩展：以上说的root和Linux中的root不是同一个用户，这个root代表MySQL数据库的管理员，只不过这个管理员也叫root。\r\n\r\n![image-20200327114444955](media/image-20200327114444955.png)\r\n\r\n![image-20200327114530976](media/image-20200327114530976.png)\r\n\r\n> 学习环境下，密码越简单越好。生产环境下越复杂越好。\r\n\r\n![image-20200327114717525](media/image-20200327114717525.png)\r\n\r\n![image-20200327114820459](media/image-20200327114820459.png)\r\n\r\n![image-20200327114907975](media/image-20200327114907975.png)\r\n\r\n![image-20200327114951007](media/image-20200327114951007.png)\r\n\r\n#### ② 把mysqld服务添加到开机启动项\r\n\r\n```powershell\r\n# systemctl enable mysqld\r\n```\r\n\r\n默认已经开机启动，这里可以跳过\r\n\r\n#### ③ 连接MySQL数据库，测试\r\n\r\n```powershell\r\n# mysql -u root -p 回车\r\nEnter password:输入刚才设置的密码，如123，回车\r\nmysql> show databases;    =>   代表显示所有数据库\r\nmysql> exit\r\n```\r\n\r\n## 5、LAMP环境之PHP安装\r\n\r\n### ☆ 使用yum命令安装php软件\r\n\r\n```powershell\r\n# yum install php -y\r\n```\r\n\r\n### ☆ 使用systemctl启动php软件（重启Apache）\r\n\r\n```powershell\r\n# systemctl restart httpd\r\n```\r\n\r\n> 为什么启动php就是重启Apache呢？答：因为LAMP架构中，PHP是以模块的形式追加到Apache的内核中，所以启动php就相当于重置Apache软件\r\n\r\n![image-20200327142246747](media/image-20200327142246747.png)\r\n\r\n### ☆ 测试LAMP环境是否可以使用\r\n\r\n第一步：使用cd命令进入/var/www/html目录\r\n\r\n```powershell\r\n# cd /var/www/html\r\nApache的项目目录 => /var/www/html，以后程序员开发的代码都是放置于此目录\r\n```\r\n\r\n第二步：使用vim命令创建demo.php文件\r\n\r\n```powershell\r\n# vim demo.php\r\n```\r\n\r\n第三步：编写php代码\r\n\r\n```php\r\n<?php\r\n\techo 'hello world';\r\n?>\r\n```\r\n\r\n编写完成后，保存退出，然后在浏览器中使用http://公网IP/demo.php\r\n\r\n![image-20200327142839268](media/image-20200327142839268.png)\r\n\r\n# 二、部署Discuz!论坛\r\n\r\n## 1、Discuz!论坛概述\r\n\r\nDiscuz！论坛是基于PHP + MySQL进行开发的一套开源的论坛系统。\r\n\r\n![image-20200327151556113](media/image-20200327151556113.png)\r\n\r\n## 2、下载源代码\r\n\r\n下载地址：https://gitee.com/ComsenzDiscuz/DiscuzX  （码云）\r\n\r\n![image-20200327151754516](media/image-20200327151754516.png)\r\n\r\n## 3、使用MX软件把Discuz源代码上传\r\n\r\n阿里云：\r\n\r\n![image-20200327152029513](media/image-20200327152029513.png)\r\n\r\n本地Linux类似\r\n\r\n## 4、安装unzip解压缩软件\r\n\r\n```powershell\r\n# yum install unzip -y\r\n```\r\n\r\n## 5、使用unzip对discuz.zip压缩包进行解压\r\n\r\n```powershell\r\n# unzip discuz.zip\r\n```\r\n\r\n## 6、复制discuz中的文件到/var/www/html目录\r\n\r\n```powershell\r\n# mv discuz/* /var/www/html/\r\n或\r\n# cp -vRp disczu/* /var/www/html/\r\n```\r\n\r\n## 7、打开浏览器，输入公网IP地址\r\n\r\n![image-20200327153135696](media/image-20200327153135696.png)\r\n\r\n## 8、单击同意许可，继续安装\r\n\r\n![image-20200327154443886](media/image-20200327154443886.png)\r\n\r\n## 9、给/var/www/html目录设置可写权限\r\n\r\n```powershell\r\n# chmod -R a+w /var/www/html\r\n```\r\n\r\n> 注意：以上操作是给所有文件添加一个w权限，但是生产环境尽量针对指定文件添加权限。\r\n\r\n## 10、解决PHP扩展问题\r\n\r\n![image-20200327154906078](media/image-20200327154906078.png)\r\n\r\n以上提示代表，安装PHP时没有安装php-mysqli扩展，所以会出现以上问题。\r\n\r\n```powershell\r\n# yum install php-mysqli -y\r\n# systemctl restart httpd\r\n```\r\n\r\n## 11、设置运行环境\r\n\r\n![image-20200327155142197](media/image-20200327155142197.png)\r\n\r\n## 12、设置MySQL数据库的相关信息\r\n\r\n![image-20200327155441330](media/image-20200327155441330.png)\r\n\r\n## 13、设置管理员账号和密码\r\n\r\n![image-20200327155536618](media/image-20200327155536618.png)\r\n\r\n## 14、安装完成后，访问论坛首页\r\n\r\n![image-20200327155648008](media/image-20200327155648008.png)\r\n\r\n部署后，访问论坛首页，如下图所示：\r\n\r\n![image-20200327155712092](media/image-20200327155712092.png)\r\n\r\n# 三、域名与解析\r\n\r\n## 1、为什么需要域名\r\n\r\n我们现在访问论坛是通过IP地址实现的，但是IP地址比较复杂，更重要的是不方便用户记忆。\r\n\r\n域名 => 代替公网IP地址\r\n\r\n## 2、购买域名\r\n\r\n![image-20200327162641419](media/image-20200327162641419.png)\r\n\r\n登录控制台，然后选择域名菜单：\r\n\r\n![image-20200327162742162](media/image-20200327162742162.png)\r\n\r\n找到域名注册菜单：\r\n\r\n![image-20200327162831242](media/image-20200327162831242.png)\r\n\r\n找到想要注册的域名，然后加入清单，然后进行立即结算：\r\n\r\n![image-20200327163458795](media/image-20200327163458795.png)\r\n\r\n购买完成后，进入域名控制台：\r\n\r\n![image-20200327163713347](media/image-20200327163713347.png)\r\n\r\n## 3、把域名解析到公网IP\r\n\r\n![image-20200327163913091](media/image-20200327163913091.png)\r\n\r\n进入解析菜单，然后添加记录：\r\n\r\n![image-20200327164010354](media/image-20200327164010354.png)\r\n\r\n① 把www.itcast.top解析到公网IP\r\n\r\n![image-20200327164144887](media/image-20200327164144887.png)\r\n\r\n② 把itcast.top解析到公网IP\r\n\r\n![image-20200327164318781](media/image-20200327164318781.png)\r\n\r\n以上记录添加完成后，等待10分钟左右，即可使用域名访问论坛项目了！\r\n\r\n## 4、域名备案\r\n\r\n如果在国内运行项目，我们使用的域名必须要进行备案操作。\r\n\r\n备案就是向工信部提交网站运行的相关资料，比如域名的证书、持有者的身份证号码，以及真人手持身份证照片（背景图）\r\n\r\n由于现在监管比较严格，提交资料后，大概5-7个工作日进行审核，完全备案完成大概2周左右。\r\n\r\n> https://beian.aliyun.com/\r\n\r\n\r\n\r\n如果不想进行域名备案，可以购买中国香港、中国台湾以及国外的服务器，可以免备案。但是其运行速度略慢一些。",Rn={data:function(){return{MainComponent:In,img_prefix:"./img/linux/heima-Linux云计算/YUM+LAMP开源部署/"}},methods:{extendMarkdown:function(n){var r=this;console.log(n.renderer.rules);var e=n.renderer.rules.html_block;n.renderer.rules.html_block=function(n,t,i,s,a){var o=n[t];if(console.log("1"),o.content.includes("<img")){console.log("token-- ",o);var l="";l=o.content;var p=l.split('src="'),c=p[0]+' src="'+r.img_prefix+p[1];o.content=c}return o.attrSet("class","q-markdown--token  "),e(n,t,i,s,a)},n.renderer.rules.image=function(n,e,t,i,s){var a=n[e];console.log("3"),a.attrSet("class","q-markdown--image"),console.log("token--- "+e+"-----",a);var o=a.attrGet("src");return console.log(o),a.attrSet("src",r.img_prefix+o),s.renderToken(n,e,t)}}}},Un=Rn,En=Object(p["a"])(Un,Pn,Sn,!1,null,"59ab09ee",null),An=En.exports,Mn=function(){var n=this,r=n.$createElement,e=n._self._c||r;return e("div",[e("m2")],1)},Tn=[],Dn=function(){var n=this,r=n.$createElement,e=n._self._c||r;return e("div",[e("div",{staticClass:"row  "},[e("q-select",{attrs:{"use-input":"","input-debounce":"0",clearable:"",options:n.book_options},on:{filter:n.filterFn},model:{value:n.book,callback:function(r){n.book=r},expression:"book"}},[e("template",{slot:"before"},[e("div")])],2)],1),e("div",{staticClass:"q-pdfviewer-container  "},[e("q-pdfviewer",{attrs:{src:n.src,type:"html5","content-class":" fit   q-pdfviewer-container","inner-content-class":" fit   q-pdfviewer-container"},model:{value:n.show,callback:function(r){n.show=r},expression:"show"}})],1)])},On=[],Nn=["第1阶段-运维基本功/day01/第1阶段-运维基本功（升级7.6版本）day01课堂讲义.pdf","第1阶段-运维基本功/day01/课堂讲义.pdf","第1阶段-运维基本功/day01/讲义/01运维概述与Linux系统安装.pdf","第1阶段-运维基本功/day02/课堂笔记.pdf","第1阶段-运维基本功/day02/讲义/02Linux基础命令.pdf","第1阶段-运维基本功/day03/课堂笔记.pdf","第1阶段-运维基本功/day03/讲义/03Linux文件管理(上).pdf","第1阶段-运维基本功/day04/课堂笔记.pdf","第1阶段-运维基本功/day05/课堂笔记.pdf","第1阶段-运维基本功/day05/讲义/上/03Linux文件管理(下).pdf","第1阶段-运维基本功/day06/课堂笔记.pdf","第1阶段-运维基本功/day06/讲义/04用户管理.pdf","第1阶段-运维基本功/day07/课堂笔记.pdf","第1阶段-运维基本功/day07/讲义/05权限管理.pdf","第1阶段-运维基本功/day08/课堂笔记.pdf","第1阶段-运维基本功/day09/课堂笔记.pdf","第1阶段-运维基本功/day09/讲义/上/06自有服务及软件包.pdf","第1阶段-运维基本功/day10/课堂笔记.pdf","第1阶段-运维基本功/day10/讲义/07进程检测与控制.pdf","第1阶段-运维基本功/day11/课堂笔记.pdf","第1阶段-运维基本功/day12/课堂笔记.pdf","第1阶段-运维基本功/day12/讲义/08YUM与开源项目实战.pdf","第2阶段-运维系统服务/第二阶段网络基础/计算机网络设备.pdf","第2阶段-运维系统服务/第二阶段网络基础/网络基础1.pdf","第2阶段-运维系统服务/第二阶段网络基础/网络基础2.pdf","第2阶段-运维系统服务/第二阶段网络基础/网络基础3.pdf","第2阶段-运维系统服务/01_磁盘管理.pdf","第2阶段-运维系统服务/02_磁盘阵列之RAID.pdf","第2阶段-运维系统服务/系统服务/day01/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day01/讲义/01_Linux高级命令.pdf","第2阶段-运维系统服务/系统服务/day01/讲义/02_Linux下用户组管理.pdf","第2阶段-运维系统服务/系统服务/day01/讲义/03_Linux下文件权限管理.pdf","第2阶段-运维系统服务/系统服务/day01/讲义/04_Linux下软件包管理.pdf","第2阶段-运维系统服务/系统服务/day02/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day02/讲义/02_Linux下用户组管理.pdf","第2阶段-运维系统服务/系统服务/day02/讲义/03_Linux下文件权限管理.pdf","第2阶段-运维系统服务/系统服务/day03/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day03/讲义/03_Linux下文件权限管理.pdf","第2阶段-运维系统服务/系统服务/day04/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day04/讲义/Linux下yum源配置实战.pdf","第2阶段-运维系统服务/系统服务/day05/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day05/讲义/远程管理SSH服务.pdf","第2阶段-运维系统服务/系统服务/day06/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day06/讲义/01-远程管理SSH服务免密登录解决方案.pdf","第2阶段-运维系统服务/系统服务/day07/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day07/讲义/02-Linux下数据同步RSYNC.pdf","第2阶段-运维系统服务/系统服务/day08/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day08/讲义/02-文件共享服务之FTP.pdf","第2阶段-运维系统服务/系统服务/day09/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day09/讲义/文件共享服务之NFS_SMB.pdf","第2阶段-运维系统服务/系统服务/day10/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day10/讲义/域名管理系统之DNS.pdf","第2阶段-运维系统服务/系统服务/day11/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day11/讲义/源码构建LAMP环境.pdf","第2阶段-运维系统服务/01_SHELL编程前奏_小工具.pdf","第2阶段-运维系统服务/07SSH服务(打卡).pdf","第2阶段-运维系统服务/navicat.pdf","第2阶段-运维系统服务/Percona-XtraBackup-2.4.7-2.pdf","第2阶段-运维系统服务/Percona-XtraDB-Cluster-5.7.18-29.20.pdf","第2阶段-运维系统服务/mysql-dba/day01/讲义/01_MySQL介绍及安装.pdf","第2阶段-运维系统服务/mysql-dba/day02/课堂笔记.pdf","第2阶段-运维系统服务/mysql-dba/day02/讲义/02_MySQL体系结构及数据文件介绍.pdf","第2阶段-运维系统服务/mysql-dba/day02/讲义/03_MySQL基本SQL语句讲解.pdf","第2阶段-运维系统服务/mysql-dba/day03/课堂笔记.pdf","第2阶段-运维系统服务/mysql-dba/day04/讲义/04_MySQL备份与恢复.pdf","第2阶段-运维系统服务/mysql-dba/day05/课堂笔记.pdf","第2阶段-运维系统服务/mysql-dba/day05/讲义/04_MySQL备份与恢复.pdf","第2阶段-运维系统服务/mysql-dba/day06/课堂笔记.pdf","第2阶段-运维系统服务/mysql-dba/day06/讲义/05_MySQL主从复制架构.pdf","第2阶段-运维系统服务/mysql-dba/day07/课堂笔记.pdf","第2阶段-运维系统服务/mysql-dba/day07/讲义/06_MySQL数据库高可用解决方案(MHA).pdf","第2阶段-运维系统服务/shell脚本/01_SHELL编程之变量定义.pdf","第2阶段-运维系统服务/shell脚本/02_SHELL编程之流程控制和循环语句.pdf","第2阶段-运维系统服务/shell脚本/03_SHELL编程之嵌套循环+随机数及综合案例.pdf","第2阶段-运维系统服务/shell脚本/04_SHELL编程之CASE语句+函数+正则.pdf","第2阶段-运维系统服务/shell脚本/05_SHELL编程之文本处理工具SED.pdf","第2阶段-运维系统服务/shell脚本/06_SHELL编程之文本处理工具AWK.pdf","第2阶段-运维系统服务/小工具/01_SHELL编程前奏_小工具.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/10_企业架构NOSQL数据库之MongoDB.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/11_企业架构web服务器文件及时同步.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/12_企业架构之Tomcat部署使用.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/4_企业架构双点服务器HA.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/7_企业架构MySQL读写分离.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/8_企业架构缓存中间件分布式memcached.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/MongoDB权威指南中文版.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/Mycat_V1.6.0.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/企业架构LB-服务器的负载均衡之Haproxy实现.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/企业架构LB-服务器的负载均衡之LVS实现.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/11_企业架构web服务器文件及时同步/01_文档/rsync+sersync/rsync+sersync.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/1_企业架构之LNMP/01_文档/1_企业架构之LNMP.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/2_企业级Nginx使用-day1/01_文档/2_企业级Nginx使用-day1.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/2_企业级Nginx使用-day1/05_资料/ThinkPHP5.0完全开发手册-20180101212957.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/3_企业级Nginx使用-day2/01_文档/3_企业级Nginx使用-day2.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/4_企业架构HA-服务器的高可用/01_文档/4_企业架构双点服务器HA.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/4_企业架构HA-服务器的高可用/05_资料/虚拟机克隆网卡配置/虚拟机克隆IP处理.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/5_企业架构LB-服务器的负载均衡之Nginx实现/01_文档/5_企业架构LNMP高可用负载均衡服务器.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/6_企业架构LB-服务器的负载均衡二/01_文档/haproxy/企业架构LB-服务器的负载均衡之Haproxy实现.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/6_企业架构LB-服务器的负载均衡二/01_文档/lvs/企业架构LB-服务器的负载均衡之LVS实现.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/6_企业架构LB-服务器的负载均衡二/05_资料/heartbeat安装/heartbeat.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/8_企业架构缓存中间件分布式memcached/01_文档/8_企业架构缓存中间件分布式memcached.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/9_企业架构队列缓存中间件分布式Redis/01_文档/9_企业架构队列缓存中间件分布式Redis.pdf","第4阶段-运维线下实战：运维自动化/centos7虚拟机教学环境统一文档.pdf","第4阶段-运维线下实战：运维自动化/CICD/文档/1-git.pdf","第4阶段-运维线下实战：运维自动化/CICD/文档/2-github与gitlab.pdf","第4阶段-运维线下实战：运维自动化/CICD/文档/3-jenkins.pdf","第4阶段-运维线下实战：运维自动化/CICD/文档/windows下Git使用拓展.pdf","第4阶段-运维线下实战：运维自动化/ELK日志分析/文档/ELK1.pdf","第4阶段-运维线下实战：运维自动化/ELK日志分析/文档/ELK2.pdf","第4阶段-运维线下实战：运维自动化/ELK日志分析/文档/logstash插件.pdf","第4阶段-运维线下实战：运维自动化/ELK日志分析/文档/综合案例.pdf","第4阶段-运维线下实战：运维自动化/存储/讲义/1-存储概念与SAN.pdf","第4阶段-运维线下实战：运维自动化/存储/讲义/2-分布式存储之glusterfs.pdf","第4阶段-运维线下实战：运维自动化/存储/讲义/3-分布式存储之Ceph.pdf","第4阶段-运维线下实战：运维自动化/存储/讲义/ceph的osd盘删除操作.pdf","第4阶段-运维线下实战：运维自动化/存储/讲义/iscsi扩展.pdf","第4阶段-运维线下实战：运维自动化/监控/文档/prometheus.pdf","第4阶段-运维线下实战：运维自动化/监控/文档/zabbix1.pdf","第4阶段-运维线下实战：运维自动化/监控/文档/zabbix2.pdf","第4阶段-运维线下实战：运维自动化/监控/文档/zabbix课后练习答案.pdf","第4阶段-运维线下实战：运维自动化/配置自动化/文档/ansible.pdf","第4阶段-运维线下实战：运维自动化/配置自动化/文档/练习答案.pdf","第4阶段-运维线下实战：运维自动化/配置自动化/文档/练习答案2.pdf","第5阶段-运维安全/1_系统安全.pdf","第5阶段-运维安全/2_网络安全.pdf","第5阶段-运维安全/3_服务安全.pdf","第5阶段-运维安全/5_入侵检测.pdf","第6阶段-运维云计算/01_k8s极速入门课程介绍.pdf","第6阶段-运维云计算/02_k8s初识.pdf","第6阶段-运维云计算/03_k8s功能.pdf","第6阶段-运维云计算/04_k8s架构.pdf","第6阶段-运维云计算/05_k8s集群部署.pdf","第6阶段-运维云计算/06_k8s集群客户端工具 kubectl.pdf","第6阶段-运维云计算/07_k8s集群资源清单文件（YAML）书写方法.pdf","第6阶段-运维云计算/1-kubernetes介绍与安装部署.pdf","第6阶段-运维云计算/1_容器技术.pdf","第6阶段-运维云计算/1_虚拟化技术（KVM）.pdf","第6阶段-运维云计算/2-kubernetes应用.pdf","第6阶段-运维云计算/2_代码自动发布-docker.pdf","第6阶段-运维云计算/2_大数据基础平台实施及运维.pdf","第6阶段-运维云计算/阿里云 SLB.pdf","第6阶段-运维云计算/阿里云 对象存储(OSS).pdf","第6阶段-运维云计算/阿里云CDN应用.pdf","第6阶段-运维云计算/01_大数据/day1/01_笔记/1_大数据基础平台实施及运维.pdf","第6阶段-运维云计算/02_虚拟化/day2/01_笔记/2_虚拟化技术（KVM）(1).pdf","第6阶段-运维云计算/03_阿里云/CDN/01_笔记/阿里云CDN应用.pdf","第6阶段-运维云计算/03_阿里云/ECS/01_笔记/阿里云 ECS.pdf","第6阶段-运维云计算/03_阿里云/NAS/01_笔记/阿里云文件存储 NAS.pdf","第6阶段-运维云计算/03_阿里云/OSS/01_笔记/阿里云 对象存储(OSS).pdf","第6阶段-运维云计算/03_阿里云/RDS/01_笔记/阿里云 RDS.pdf","第6阶段-运维云计算/03_阿里云/SLB/01_笔记/阿里云 SLB.pdf","第6阶段-运维云计算/04_私有云/openstack/OpenStack手动分布式部署.pdf","第6阶段-运维云计算/04_私有云/openstack/openstack排错思路.pdf","第6阶段-运维云计算/04_私有云/openstack/OpenStack自动部署.pdf","第6阶段-运维云计算/06_容器编排(k8s)/Paas云平台_docker容器.pdf","第6阶段-运维云计算/06_容器编排(k8s)/rancher.pdf","第6阶段-运维云计算/06_容器编排(k8s)/容器编排之Docker三剑客.pdf","第6阶段-运维云计算/7-k8s极速入门（赠送）/08_k8s极速入门_k8s集群NameSpace(命名空间)/01_笔记/08_k8s集群NameSpace(命名空间).pdf","第6阶段-运维云计算/7-k8s极速入门（赠送）/09_k8s极速入门_k8s集群核心概念 Pod/01_笔记/09_k8s集群核心概念 Pod.pdf","第6阶段-运维云计算/7-k8s极速入门（赠送）/10_k8s极速入门_k8s集群核心概念 Controller(控制器)/01_笔记/10_k8s集群核心概念Controller.pdf","第6阶段-运维云计算/7-k8s极速入门（赠送）/11_k8s极速入门_k8s集群核心概念 Service/01_笔记/11_k8s集群核心概念Service.pdf","第6阶段-运维云计算/7-k8s极速入门（赠送）/12_k8s极速入门_结课/01_笔记/12_k8s极速入门_结课.pdf","第6阶段-运维云计算/8-Kubernetes高级教程营销视频（赠送）/00_环境说明/01_笔记/第6阶段-运维云计算-《Kubernetes快速入门》进阶课程环境说明.pdf","第6阶段-运维云计算/8-Kubernetes高级教程营销视频（赠送）/01_Pod进阶/01_笔记/k8s集群核心概念 Pod进阶.pdf","第6阶段-运维云计算/8-Kubernetes高级教程营销视频（赠送）/02_Controller进阶/01_笔记/kubernetes集群应用 controller进阶.pdf","第6阶段-运维云计算/8-Kubernetes高级教程营销视频（赠送）/03_Service进阶/01_笔记/kubernetes集群应用 service进阶.pdf","第6阶段-运维云计算/8-Kubernetes高级教程营销视频（赠送）/04_kubernetes集群PaaS Rancher/01_笔记/基于kubernetes实现PaaS云平台-rancher.pdf","第6阶段-运维云计算/8-Kubernetes高级教程营销视频（赠送）/05_在kubernetes集群中kubesphere部署/01_笔记/kubernetes集群kubesphere.pdf","第6阶段-运维云计算/8-Kubernetes高级教程营销视频（赠送）/06_kubernetes集群 zookeeper部署/01_笔记/kubernetes集群 应用实践 zookeeper部署.pdf","第6阶段-运维云计算/8-Kubernetes高级教程营销视频（赠送）/07_kubernetes集群应用实践 kafka部署/01_笔记/kubernetes集群 应用实践 kafka部署.pdf","第7阶段-Python运维开发/python基础7天最终版.pdf","第7阶段-Python运维开发/01_Web开发基础之HTML+CSS/文档/01_Web开发基础之HTML+CSS.pdf","第7阶段-Python运维开发/02_Web开发基础之JavaScript/文档/02_Web开发基础之JavaScript.pdf","第7阶段-Python运维开发/03_Web开发基础之综合应用/文档/03_Web开发基础之综合应用.pdf","第7阶段-Python运维开发/04_Web框架之Django一/文档/04_Web框架之Django一.pdf","第7阶段-Python运维开发/05_Web框架之Django二/文档/05_Web框架之Django二.pdf","第7阶段-Python运维开发/06_Web框架之Django三/文档/06_Web框架之Django三.pdf","第7阶段-Python运维开发/07_CMDB系统开发一/文档/07_CMDB系统开发一.pdf","第7阶段-Python运维开发/09_CMDB系统开发三/文档/09_CMDB系统开发三.pdf"],jn="linux/heima-Linux云计算/",zn={mixins:[I["d"]],data:function(){return{prefix:jn,book_options:Nn,show:!0,book:Nn[0],src:""}}},$n=zn,Bn=Object(p["a"])($n,Dn,On,!1,null,null,null),qn=Bn.exports,Fn={components:{m2:qn},data:function(){return{tab:"m2",tabs:[{label:"m2",value:"m2"}]}}},Hn=Fn,Wn=Object(p["a"])(Hn,Mn,Tn,!1,null,"c8afde32",null),Gn=Wn.exports,Kn=function(){var n=this,r=n.$createElement,e=n._self._c||r;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:n.tab,callback:function(r){n.tab=r},expression:"tab"}},n._l(n.tabs,(function(n,r){return e("q-tab",{key:"tabs_"+r,attrs:{name:""+n.value,label:r+1+"."+n.label}})})),1),e(""+n.tab,{tag:"component"})],1)},Qn=[],Yn=function(){var n=this,r=n.$createElement,e=n._self._c||r;return e("div",{},[e("q-markdown",{attrs:{src:n.MainComponent}})],1)},Vn=[],Xn='# Linux-v10.0-01天-课堂笔记\r\n\r\n学习目标\r\n\r\n- 能够知道什么是Linux系统以及它的应用场景\r\n- 能够独立完成安装VMware虚拟机和网络配置\r\n- 能够独立完成安装CentOS以及远程终端SecureCRT\r\n- 能够熟练编写账户管理、用户组的增删改查和添加命令\r\n- 能够熟练编写系统管理的常用命令\r\n- 能够熟练编写目录常用命令\r\n- 能够熟练编写权限常用命令\r\n- 能够知道用户组实际应用场景\r\n\r\n# 1 初识Linux\r\n\r\n```\r\n在前面的课程中，我们无论是开发、测试。部署、存储都在Windwos操作系统的环境中，从今天开始我们一起学习下Linux,Linux系统和Windows系统最大的区别就是图形化界面操作和用途上有所差异，除了这两点，两者有异曲同工之妙，在国内， Linux 系统更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows，也就是说Linux与Windows一样，同样也是操作系统只是在使用以及应用上有所差异，其他都是一样的；\r\n因为Linux也是操作系统\r\n所以在正式进入Linux学习之前，我们先简单的学习操作系统的知识，然后在讲解Linux\r\n```\r\n\r\n## 1.1 操作系统\r\n\r\n操作系统(Operation System, OS)，是管理[计算机](https://baike.baidu.com/item/计算机)[硬件](https://baike.baidu.com/item/硬件)与[软件](https://baike.baidu.com/item/软件)资源的[计算机程序](https://baike.baidu.com/item/计算机程序)，同时也是计算机系统的内核与基石。操作系统需要处理如管理与配置[内存](https://baike.baidu.com/item/内存)、决定[系统资源](https://baike.baidu.com/item/系统资源/974435)供需的优先次序、控制[输入设备](https://baike.baidu.com/item/输入设备/10823368)与[输出设备](https://baike.baidu.com/item/输出设备/10823333)、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。\r\n\r\n操作系统作为接口的示意图:\r\n\r\n![1576199620565](./img/linux/java-linux/Linux-v10-01天-授课/1576199620565.png)\r\n\r\n如上图所示，在操作系统的最上层是用户，中间层是操作系统（里面可能装了很多的应用程序），最下层是硬件的支撑，包含CPU/内存/硬盘等\r\n\r\n这就是一个完成的操作系统结构图\r\n\r\n**主流操作系统按照应用领域的划分**\r\n\r\n**1、桌面操作系统**\r\n\r\n- Window 系列\r\n  - 用户群体大\r\n- macOS\r\n  - 细节处理的更好, 没有windows软件丰富, 价格高\r\n- Linux\r\n  - 应用软件少\r\n\r\n**2、服务器操作系统**\r\n\r\n- Linux\r\n\r\n  - 安全、稳定、免费\r\n  - 占有率高\r\n\r\n- Windows Server\r\n\r\n  - 付费\r\n  - 占有率低\r\n\r\n  ![1558234034446](./img/linux/java-linux/Linux-v10-01天-授课/1558234034446.png)\r\n\r\n**3、嵌入式操作系统**\r\n\r\n​    Linux\r\n\r\n**4、移动设备操作系统**\r\n\r\n ![1560477460567](./img/linux/java-linux/Linux-v10-01天-授课/1560477460567.png)\r\n\r\n- IOS\r\n- Android (基于Linux)\r\n- 华为鸿蒙(基于linux)\r\n\r\n## 1.2 Linux发展历程\r\n\r\n```\r\n引子\r\n在上面，我们学习了操作系统的知识，也知道了主流操作系统按照应用领域划分了四个类型的操作系统，其中Linux操作系统在四个领域都有提名，因为它是至今开源序列最好的操作系统，下面，我们就一起看下Linux的发展历程，看看它是怎么诞生的...\r\n```\r\n\r\n1984年，Andrew S.Tanenbaum 开发了用于教学的Unix系统，命名为Minix，但是仅仅用于教学\r\n1989年，Andrew S.Tanenbaum将Minix系统运行于x86的pc平台\r\n1990年，芬兰赫尔辛基大学学生Linus Torvalds首次接触Minix系统\r\n1991年，Linus Torvalds开始在Minix上编写各种驱动程序等操作系统内核组件\r\n1991年年底，Linus Torvalds公开了Linux内核源码0.02版，仅仅是内核\r\n1994年，Linux 1.0版本发行，Linux转向GPL版权协议\r\n至此，Linux开始盛行开来...\r\n\r\n![1575879660267](./img/linux/java-linux/Linux-v10-01天-授课/1575879660267.png)\r\n\r\nLinux 内核最初是由李纳斯•托瓦兹（Linus Torvalds）在赫尔辛基大学读书时出于个人爱好而编写的，当时他觉得教学用的迷你版 Unix操作系统 Minix 太难用了，于是决定自己开发一个操作系统。\r\n\r\n第 1 版本于 1991 发布，当时仅有 10 000 行代码。\r\n\r\n李纳斯•托瓦兹没有保留 Linux 源代码的版权，公开了代码，并邀请他人一起完善 Linux。与 Windows 及其他有专利权的操作系统不同，Linux 开放源代码，任何人都可以免费使用它。\r\n\r\n据估计，现在只有 2% 的 Linux 核心代码是由李纳斯•托瓦兹自己编写的，虽然他仍然拥有 Linux 内核（操作系统的核心部分），并且保留了选择新代码和需要合并的新方法的最终裁定权。现在大家所使用的 Linux，我更倾向于说是由李纳斯•托瓦兹和后来陆续加入的众多 Linux 好者共同开发完成的。\r\n\r\n> Unix  \r\n>\r\n> Unix  操作系统由肯•汤普森（Ken Thompson）和丹尼斯•里奇（Dennis Ritchie）发明。它的部分技术来源可追溯到从 1965 年开始的 Multics 工程计划，该计划由贝尔实验室、美国麻省理工学院和通用电气公司联合发起，目标是开发一种交互式的、具有多道程序处理能力的分时操作系统，以取代当时广泛使用的批处理操作系统。\r\n>\r\n> Unix是一个强大的多用户、多任务操作系统。于1969年在AT&T的贝尔实验室开发。Unix  的商标权由国际开放标准组织（The Open Group）所拥有。Unix操作系统是商业版，需要收费，价格比Microsoft Windows正版要贵一些。\r\n\r\n## 1.3 Linux简介\r\n\r\n```\r\n引子\r\nLinux和我们常见的Windows一样，都是操作系统，\r\n例如：新浪、百度、淘宝等互联网公司，他们使用的服务器全都是Linux系统；全球500强企业95%的服务器使用的都是Linux系统。\r\n```\r\n\r\n### **1.3.1 什么是 Linux**\r\n\r\nLinux是一套免费使用和自由传播的[类Unix](https://baike.baidu.com/item/类Unix)[操作系统](https://baike.baidu.com/item/操作系统/192)，是一个基于[POSIX](https://baike.baidu.com/item/POSIX)和Unix的多用户、[多任务](https://baike.baidu.com/item/多任务/1011764)、支持[多线程](https://baike.baidu.com/item/多线程/1190404)和多[CPU](https://baike.baidu.com/item/CPU)的操作系统。它能运行主要的Unix工具软件、应用程序和网络协议。它支持[32位](https://baike.baidu.com/item/32位/5812218)和[64位](https://baike.baidu.com/item/64位)硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。\r\n\r\nLinux 的标志和吉祥物是一只名字叫做Tux(它克斯)的企鹅，Linux是基于Unix的。\r\n\r\nLinux是一种自由和开放源码的操作系统，存在着许多不同的Linux版本，但它们都使用了Linux内核。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、台式计算机\r\n\r\n![1575881750752](./img/linux/java-linux/Linux-v10-01天-授课/1575881750752.png)\r\n\r\nLinux不仅系统性能稳定，而且是开源软件。其核心防火墙组件性能高效、配置简单，保证了系统的安全。在很多企业网络中，为了追求速度和安全，Linux操作系统不仅仅是被网络运维人员当作服务器使用，Linux既可以当作[服务器](https://baike.baidu.com/item/服务器/100571)，又可以当作网络防火墙是Linux的 一大亮点。 \r\n\r\nLinux与其他操作系统相比 ，具有[开放源码](https://baike.baidu.com/item/开放源码/7176422)、没有版权、技术社区用户多等特点 ，开放源码使得用户可以自由裁剪，灵活性高，功能强大，成本低。尤其系统中内嵌网络协议栈 ，经过适当的配置就可实现路由器的功能。这些特点使得Linux成为开发路由交换设备的理想开发平台。\r\n\r\n### 1.3.2 Linux的特点\r\n\r\n**基本思想**\r\n\r\nLinux的基本思想有两点：\r\n\r\n第一：一切都是文件\r\n\r\n第二：每个软件都有确定的用途\r\n\r\n其中第一条详细来讲就是系统中的所有都归结为一个文件，包括[命令](https://baike.baidu.com/item/命令)、[硬件](https://baike.baidu.com/item/硬件)和[软件](https://baike.baidu.com/item/软件/12053)设备、[操作系统](https://baike.baidu.com/item/操作系统/192)、[进程](https://baike.baidu.com/item/进程)等等对于操作系统[内核](https://baike.baidu.com/item/内核)而言，都被视为拥有各自特性或类型的文件。至于说Linux是基于Unix的，很大程度上也是因为这两者的基本思想十分相近\r\n\r\n**完全免费**\r\n\r\nLinux是一款免费的操作系统，用户可以通过网络或其他途径免费获得，并可以任意修改其[源代码](https://baike.baidu.com/item/源代码/3969)。这是其他的操作系统所做不到的。正是由于这一点，来自全世界的无数[程序员](https://baike.baidu.com/item/程序员/62748)参与了Linux的修改、编写工作，程序员可以根据自己的兴趣和灵感对其进行改变，这让Linux吸收了无数程序员的精华，不断壮大。\r\n\r\n**完全兼容POSIX1.0标准**\r\n\r\n这使得可以在Linux下通过相应的[模拟器](https://baike.baidu.com/item/模拟器)运行常见的[DOS](https://baike.baidu.com/item/DOS/32025)、[Windows](https://baike.baidu.com/item/Windows)的程序。这为用户从Windows转到Linux奠定了基础。许多用户在考虑使用Linux时，就想到以前在Windows下常见的程序是否能正常运行，这一点就消除了他们的疑虑。\r\n\r\n**多用户、多任务**\r\n\r\nLinux支持多用户，各个用户对于自己的文件设备有自己特殊的权利，保证了各用户之间互不影响。[多任务](https://baike.baidu.com/item/多任务)则是现在电脑最主要的一个特点，Linux可以使多个程序同时并独立地运行。\r\n\r\n**良好的界面**\r\n\r\nLinux同时具有字符界面和[图形界面](https://baike.baidu.com/item/图形界面/8146283)。在字符界面用户可以通过键盘输入相应的指令来进行操作。它同时也提供了类似Windows图形界面的X-Window系统，用户可以使用鼠标对其进行操作。在X-Window环境中就和在Windows中相似，可以说是一个Linux版的Windows。\r\n\r\n**支持多种平台**\r\n\r\nLinux可以运行在多种硬件平台上，如具有[x86](https://baike.baidu.com/item/x86/6150538)、680x0、SPARC、Alpha等处理器的平台。此外Linux还是一种嵌入式操作系统，可以运行在掌上电脑、机顶盒或游戏机上。2001年1月份发布的Linux 2.4版内核已经能够完全支持[Intel](https://baike.baidu.com/item/Intel/125450)64位芯片架构。同时Linux也支持多处理器技术。多个处理器同时工作，使系统性能大大提高。\r\n\r\n**优点**\r\n\r\n1)Linux由众多微内核组成，其源代码完全开源；\r\n\r\n2)Linux继承了Unix的特性，具有非常强大的网络功能，其支持所有的因特网协议，包括TCP/[IPv4](https://baike.baidu.com/item/IPv4/422599)、 [TCP](https://baike.baidu.com/item/TCP/33012)/IPv6和链路层拓扑程序等，且可以利用Unix的网络特性开发出新的协议栈；\r\n\r\n3)Linux系统工具链完整，简单操作就可以配置出合适的开发环境，可以简化开发过程，减少开发中仿真工具的障碍，使系统具有较强的移植性；\r\n\r\n## 1.4 Linux和Unix区别\r\n\r\n**1、开源情况**\r\n\r\nUnix  是商业化的，而 Linux 是开源的，是免费、公开源代码的。\r\n\r\n**2、硬件适用**\r\n\r\nUnix  系统大多是与硬件配套的，也就是说，大多数Unix系统如AIX、HP-UX等是无法安装在 x86 服务器和个人计算机上的，而 Linux则可以运行在多种硬件平台上。\r\n\r\n可以先学习Linux后再学习Unix，因为Linux可以方便的在虚拟机上运行，防止新手的误操作。\r\n\r\n**3、本质不同**\r\n\r\nLinux是开放源代码的自由软件，用户对前者有很高的自主权，在实际的的开发是处在一个完全开放的环境之中；\r\n\r\n而Unix是对源代码实行知识产权保护的传统商业软件，用户的开发完全是处在一个黑箱之中，只有相关的开发人员才能够接触的产品的原型；\r\n\r\n> Unix 诞生于 20 世纪 60 年代末，Windows 诞生于 20 世纪 80 年代中期，Linux 诞生于 20 世纪 90 年代初，可以说 Unix是操作系统中的"老大哥"，后来的 Windows 和 Linux 都参考了 Unix \r\n>\r\n\r\n##  1.5 Linux和Windows区别\r\n\r\n目前国内 Linux 更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows。主要区别如下\r\n\r\n| 比较     | Windows                                                      | Linux                                                        |\r\n| :------- | :----------------------------------------------------------- | :----------------------------------------------------------- |\r\n| 界面     | 界面统一，外壳程序固定所有 Windows 程序菜单几乎一致，快捷键也几乎相同 | 图形界面风格依发布版不同而不同，可能互不兼容。GNU/Linux 的终端机是从 Unix传承下来，基本命令和操作方法也几乎一致。 |\r\n| 驱动程序 | 驱动程序丰富，版本更新频繁。默认安装程序里面一般包含有该版本发布时流行的硬件驱动程序，之后所出的新硬件驱动依赖于硬件厂商提供。对于一些老硬件，如果没有了原配的驱动有时很难支持。另外，有时硬件厂商未提供所需版本的 Windows 下的驱动，也会比较头痛。 | 由志愿者开发，由 Linux 核心开发小组发布，很多硬件厂商基于版权考虑并未提供驱动程序，尽管多数无需手动安装，但是涉及安装则相对复杂，使得新用户面对驱动程序问题（是否存在和安装方法）会一筹莫展。但是在开源开发模式下，许多老硬件尽管在Windows下很难支持的也容易找到驱动。HP、Intel、AMD 等硬件厂商逐步不同程度支持开源驱动，问题正在得到缓解。 |\r\n| 使用     | 使用比较简单，容易入门。图形化界面对没有计算机背景知识的用户使用十分有利。 | 图形界面使用简单，容易入门。文字界面，需要学习才能掌握。     |\r\n| 学习     | 系统构造复杂、变化频繁，且知识、技能淘汰快，深入学习困难。   | 系统构造简单、稳定，且知识、技能传承性好，深入学习相对容易。 |\r\n| 软件     | 每一种特定功能可能都需要商业软件的支持，需要购买相应的授权。 | 大部分软件都可以自由获取，同样功能的软件选择较少。           |\r\n\r\nWindows与Linux在其他方面的不同\r\n\r\n**开放性**\r\n\r\n所谓的开放性就是Linux 操作系统是开放源码系统，可以对其程序进行编辑修改。而微软的Windows 系统是受微软版权保护，就是只能微软内部进行开发及修改。\r\n\r\n**文件格式不同**\r\n\r\nWindows 操作系统内核是NT，而Linux 是 shell；\r\n\r\n另外，windows 硬盘文件格式是fat32或NTFS，而Linux 需要的文件格式是ext2或ext3，该操作系统还多一个SWAP格式的交换分区\r\n\r\n**免费与收费** \r\n\r\n在中国，对个人用户Windows 和Linux 都是免费的，对公用户Windows 需要收费，Linux 是免费的。\r\n\r\n**技术支持** \r\n\r\nWindows 较普及。Linux 需要深度的Linux 版块支持。\r\n\r\n**安全性** \r\n\r\nLinux 相对Windows 来说安全性更高。 \r\n\r\n**开源** \r\n\r\n开源就是指对外部开放软件源代码。Linux 开源，而Windows并不开源。\r\n\r\n**使用习惯** \r\n\r\nWindows 放弃了dos的字符模式，主攻图形界面，让桌面系统更易用。Linux 字符模式运行的更好，图形界面还只是附带品，可有可无。\r\n\r\n**软件与支持** \r\n\r\nWindows 下可以运行绝大部分软件、玩99.999％的游戏、硬件厂商近乎100%的支持。Linux 下可直接运行的软件数量和win下比起来就是1和99的区别，而且目前选择Linux 的人基本不会考虑玩游戏，同时Linux 正期待更多硬件厂商的支持\r\n\r\n## 1.6 Linux发行商和常见发行版\r\n\r\nLinux发行版是由个人，自由组织，以及商业机构和志愿者组织编写。它们通常包括了其他的系统软件和应用软件，以及一个用来简化系统初始安装的安装工具，和让软件安装升级的集成管理器。大多数系统还包括了像提供GUI界面的XFree86之类的曾经运行于BSD的程序。\r\n一个典型的Linux发行版包括：Linux内核，一些GNU程序库和工具，命令行shell，图形界面的桌面环境，如KDE或GNOME，并包含数千种从办公套件，编译器，文本编辑器到科学工具的应用软件\r\n\r\nLinux发行版的某些版本是不需要安装，只需通过CD或者可启动的USB存储设备就能使用的版本，他们称为LiveCD。\r\n\r\n\r\n ![1575879998775](./img/linux/java-linux/Linux-v10-01天-授课/1575879998775.png)\r\n\r\n\r\n\r\n**Linux的版本号分为两部分：内核版本和发行版本**。\r\n\r\n**1．Linux的内核版本**\r\n内核版本指的是在Linus Torvalds领导下的开发小组开发出的系统内核的版本号，通常，内核版本号的第二位是偶数表示是稳定的版本，如2.6.25；是奇数表示有一些新的东西加入，是不稳定的测试版本，如2.5.6。Linux操作系统的核心就是它的内核，Linus Torvalds和他的小组在不断地开发和推出新内核。\r\n\r\n任务：进程调度、内存管理、配置管理虚拟文件系统、提供网络接口以及支持进程间通信。像所有软件一样，Linux的内核也在不断升级。\r\n\r\n**2．Linux的发行版本**\r\n一个完整的操作系统不仅仅只有内核，还包括一系列为用户提供各种服务的外围程序。外围程序包括GNU程序库和工具，命令行shell，图形界面的X Window系统和相应的桌面环境，如KDE或GNOME，并包含数千种从办公套件，编译器，文本编辑器到科学工具的应用软件。所以，许多个人、组织和企业，开发了基于GNU/Linux的Linux发行版，他们将Linux系统的内核与外围应用软件和文档包装起来，并提供一些系统安装界面和系统设置与管理工具， 这样就构成了一个发行版本。\r\n实际上，Linux的发行版本就是Linux内核再加上外围的实用程序组成的一个大软件包而已。相对于操作系统内核版本，发行版本的版本号是随发布者的不同而不同，与Linux系统内核的版本号是相对独立的，例如：RedHat EnterpriseLinux 5.2的操作系统内核是Linux-2.6.18。\r\nLinux的发行版本大体可以分为两类：\r\n\r\n一类是商业公司维护的发行版本\r\n\r\n一类是社区组织维护的发行版本，前者以著名的RedHatLinux为代表，后者以Debian为代表\r\n\r\n以下为Linux的主流版本：\r\n\r\n目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等\r\n\r\n![1575882315996](./img/linux/java-linux/Linux-v10-01天-授课/1575882315996.png)\r\n\r\n\r\n\r\n**以下是主要的发行版本**\r\n\r\n```\r\n需要注意的：\r\n下面的内容主要是介绍了下Linux发行家族以及发行版本的一些详细信息，虽然我们当前的课程讲解的是CentOS,但是其他的一些发行商、主流的发行版本比如Ubuntu、Redhat也需要让学生多多了解下，毕竟这是Linux体系内产品线\r\n注意\r\n下面的文字虽然很多，但是只要让学生知道有这么回事即可\r\n在下面会简单的总结..\r\n```\r\n\r\n**1、Debian 介绍**\r\n\r\nDebian名字的由来----DebianGNU/Linux是由一个叫做伊恩·默多克（IanMurdock）在1993年发起的，他的名字以Ian开头，他太太的名字Debra开头三个字母是Deb。\r\n\r\nDebian是社区类Linux的典范，是迄今为止最遵循GNU规范的Linux系统。Debian最早由 Ian Murdock于1993年创建，分为三个版本分支： stable(服务器版), testing(稳定版) 和unstable(测试版)。\r\n\r\n**2、Ubuntu介绍**\r\n\r\nUbuntu严格来说不能算一个独立的发行版本，Ubuntu是基于Debian的unstable版本加强而来，可以这么说，Ubuntu就是一个拥有Debian所有的优点，以及自己所加强的优点的近乎完美的 Linux桌面系统。\r\n\r\n共分三个版本:\r\n\r\n- 基于Gnome的Ubuntu，\r\n- 基于KDE的Kubuntu以。\r\n- 基于Xfc的 Xubuntu。\r\n\r\n特点是界面非常友好，容易上手，对硬件的支持非常全面，是最适合做桌面系统的Linux发行版本。稳定性，其实都差不多，难易度嘛，\r\n\r\nUbuntu 默认桌面环境采用 GNOME，一个 Unix和 Linux 主流桌面套件和开发平台。\r\n\r\nUbuntu的版本和发布号 \r\nUbuntu的版本号是由该次发布的年份和月份组成，并未反映其实际版本。我们的首次发布是在2004年10月，因此该版本为4.10。当前版本(DapperDrake)于2006年6月发布，因此版本号为6.06 LTS。\r\n\r\n**3、Redhat**\r\n\r\n可能这是最著名的Linux版本了，Red Hat Linux已经创造了自己的品牌，越来越多的人听说过它。Red Hat在1994年创业，当时聘用了全世界500多名员工，他们都致力于开放的源代码体系。\r\nRed Hat Linux是公共环境中表现上佳的服务器。它拥有自己的公司，能向用户提供一套完整的服务，这使得它特别适合在公共网络中使用。这个版本的Linux也使用最新的内核，还拥有大多数人都需要使用的主体软件包。\r\nRed Hat Linux的安装过程也十分简单明了。它的图形安装过程提供简易设置服务器的全部信息。磁盘分区过程可以自动完成，还可以选择GUI工具完成，即使对于 Linux新手来说这些都非常简单。选择软件包的过程也与其他版本类似；用户可以选择软件包种类或特殊的软件包。系统运行起来后，用户可以从Web站点和 Red Hat那里得到充分的技术支持。我发现Red Hat是一个符合大众需求的最优版本。在服务器和桌面系统中它都工作得很好。Red Hat的唯一缺陷是带有一些不标准的内核补丁，这使得它难于按用户的需求进行定制。 Red Hat通过论坛和邮件列表提供广泛的技术支持，它还有自己公司的电话技术支持，后者对要求更高技术支持水平的集团客户更有吸引力\r\n\r\n**4、Fedora**\r\n\r\nFedora和Redhat这两个Linux的发行版放联系很密切。Redhat 自9.0以后，不再发布桌面版的，而是把这个项目与开源社区合作，于是就有了Fedora 这个 Linux 发行版。Fedora项目是由 Red Hat 赞助，由开源社区与 Red Hat 工程师合作开发的项目统称。Fedora 的目标，是推动自由和开源软件更快地进步。\r\n\r\n特点：\r\n１、 Fedora 是一个开放的、创新的、前瞻性的操作系统和平台，基于 Linux。它允许任何人自由地使用、修改和重发布，无论现在还是将来。可运行的体系结构包括x86(即i386),x86_64 和PowerPC！\r\n２、Fedora 可以说是Redhat 桌面版本的延续，只不过是与开源社区合作。\r\n\r\n３、Fedora 是一个独立的inux发行版本的操作系统。\r\n\r\n**5**、**centos**\r\n\r\nCentOS（Community ENTerprise Operating System）是来自于Red Hat Enterprise Linux依照开放源代码规定释出的源代码所编译而成。由于出自同样的源代码，因此有些要求高度稳定性的服务器以CentOS替代商业版的Red Hat Enterprise Linux使用（我会告诉你，以为企业想省钱，运维要靠这个东西来赚钱嘛，国内运维主流是CentOS剩下版本很少）。两者的不同，在于CentOS并不包含封闭源代码软件，CentOS 是一个基于Red Hat Linux 提供的可自由使用源代码的企业级Linux发行版本。每个版本的CentOS都会获得十年的支持（通过安全更新方式）。新版本的 CentOS 大约每两年发行一次，而每个版本的 CentOS 会定期（大概每六个月）更新一次，以便支持新的硬件。这样，建立一个安全、低维护、稳定、高预测性、高重复性的 Linux 环境\r\n\r\n\r\n**6、Slackware介绍**\r\n\r\nSlackware 由PatrickVolkerding(帕特里克.沃克登)创建于1992年。算起来应当是历史最悠久的Linux发行版。尽管如此，Slackware仍然深入人心（大部分都是比较有经验的 Linux老手）。Slackware稳定、安全，所以仍然有大批的忠实用户。由于Slackware尽量采用原版的软件包而不进行任何修改，所以制造新 bug的几率便低了很多。Slackware的版本更新周期较长（大约1年），但是新版本的软件仍然不间断的提供给用户下载。\r\n\r\n**7、openSUSE介绍**\r\n\r\nSUSE是德国最著名的Linux发行版，在全世界范围中也享有较高的声誉。SUSE自主开发的软件包管理系统也大受好评。SUSE于2003年年末被Novell收购。SUSE在收购之后的发布显得比较混乱，比如9.0版本是收费的，而10.0版本（也许由于各种压力）又免费发布。这使得一部分用户感到困惑，也转而使用其它发行版本。最近还跟微软扯到了一起。但是瑕不掩瑜，SUSE仍然是一个非常专业、优秀的发行版。\r\n\r\nopenSUSE 项目是由Novell公司资助的全球性社区计划，旨在推进 Linux 的广泛使用。这个计划提供免费的openSUSE 操作系统。这里是一个由普通用户和开发者共同构成的社区，我们拥有一个共同的目标—创造世界上最好用的 Linux 发行版。openSUSE 是 Novell 公司发行的企业级 Linux 产品的系统基础。\r\n\r\nopenSUSE 项目是由Novell 发起的开源社区计划。 旨在推进 Linux 的广泛使用。提供了自由简单的方法来获得世界上最好用的 Linux 发行版，SUSE Linux。openSUSE 项目为 Linux 开发者和爱好者提供了开始使用 Linux 所需要的一切。\r\n\r\n**8、中国大陆的Linux发行版**\r\n\r\n红旗Linux(RedflagLinux) ，冲浪Linux(Xteam Linux) ，蓝点Linux ， GNU/Linux，OpenDesktop等等 。\r\n\r\n**9、 台湾地区的Linux发行版**\r\n\r\n鸿奇Linux\r\n\r\n**目前最著名的发行版本：Debian，ubuntu、OpenSuse(原Suse)、CentOS、fedora等。国内比较著名的红旗Linux版本**\r\n\r\n\r\n\r\n> 对于上面的知识我们做下重点总结\r\n>\r\n> - **redhat**：目前，全球最大的**linux**发行厂商，功能全面、稳定。\r\n>   - **Redhat** 被 **IBM** 收购!\r\n> - **ubuntu**：目前，是linux桌面操作系统做的最好的。\r\n> - **centos**：免费版的redhat，**centos** 基于 **redhat** 发行版基础之上，再重新编译发布的版本。\r\n>   - 目前 **centos** 已经被 **Redhat** 公司收购，但是依然免费\r\n\r\n\r\n\r\n## 1.7 Linux 应用领域\r\n\r\n今天各种场合都有使用各种 Linux 发行版，从嵌入式设备到超级计算机，并且在服务器领域确定了地位。在企业级开发中，我们通常使用Linux作为我们的服务器。\r\n\r\n比如：服务器系统Web应用服务器、数据库服务器、接口服务器、DNS、FTP等等； \r\n\r\n嵌入式系统路由器、防火墙、手机、PDA、IP 分享器、交换器、家电用品的微电脑控制器等等，高性能运算、计算密集型应用Linux有强大的运算能力。\r\n\r\n**目前 Linux 不仅在家庭与企业中使用，并且在政府中也很受欢迎**。\r\n\r\n- 巴西联邦政府由于支持 Linux 而世界闻名。\r\n- 有新闻报道俄罗斯军队自己制造的 Linux 发布版的，做为 G.H.ost 项目已经取得成果。\r\n- 印度的 Kerala 联邦计划在向全联邦的高中推广使用 Linux。\r\n- 中华人民共和国为取得技术独立，在龙芯处理器中排他性地使用 Linux。\r\n- 在西班牙的一些地区开发了自己的 Linux 发布版，并且在政府与教育领域广泛使用，如 Extremadura 地区的 gnuLinEx 和 Andalusia 地区的 Guadalinex。\r\n- 葡萄牙同样使用自己的 Linux 发布版 Caixa Mágica，用于 Magalh?es 笔记本电脑和 e-escola 政府软件。\r\n- 法国和德国同样开始逐步采用 Linux。\r\n\r\n## **1.8 Linux之CentOS**\r\n\r\n```\r\n前面章节介绍了一些Linux的基本知识，前已经对Linux有了一个初步的认识，也知道了在Linux发行版中有各个家族的发行版本；比如比较知名的ubuntu、CentOS，在今天的Linux课程中我们将采用发行版CentOS作为我们Linux课程的讲解内容。\r\n```\r\n\r\n**CentOS**，是基于 Red Hat Linux 提供的可自由使用源代码的企业级 Linux 发行版本；是一个稳定，可预测，可管理和可复制的免费企业级计算平台\r\n\r\n**主要特点:**\r\n\r\n1.主流： 目前的Linux操作系统主要应用于生产环境，主流企业级Linux系统仍旧是RedHat或者CentOS\r\n2.免费： RedHat 和CentOS差别不大，CentOS是一个基于Red Hat Linux 提供的可自由使用源代码的企业级Linux发行版本\r\n3.更新方便：CentOS独有的yum命令支持在线升级，可以即时更新系统，不像RED HAT那样需要花钱购买支持服务！\r\n\r\n**我们在当前课程中的环境：**\r\n\r\nWindows7 , VMware Workstation15.02, CentOS Linux release 7.6.1810 \r\n\r\n## 1.9 总结\r\n\r\n当前章节主要介绍了Linux发行的主要版本（我们使用的是CentOS Linux release 7.6.1810 ）、以及与Unix、Windows系统的区别；主要让学生了解Linux是基于Unix的以及与Windows一样，Linux也是操作系统即可。\r\n\r\n# 2 系统与设置命令\r\n\r\n```\r\n在前面的两个章节中，我们主要介绍了Linux基本知识和虚拟机的安装，从当前章节开始，我们一起学习下Linux的基本命令，在当前章节，我们先简单的学习下一些系统的基本命令，慢慢的由浅入深，在后面的章节中我们将学习其他的命令比如文件操作、备份压缩等\r\n```\r\n\r\n## 2.1 学习命令的原因\r\n\r\n```\r\n命令我们可以理解成在Windows中我们常常为了查看ip输入的ipconfig，在Linux中也有很多的命令，比如操作目录、文件、网络、磁盘等等命令\r\n```\r\n\r\n- Linux刚面世时并没有图形界面, 所有的操作全靠命令完成, 如 **磁盘操作、文件存取、目录操作、进程管理、文件权限** 设定等\r\n- 在职场中，大量的 **服务器维护工作** 都是在 远程 通过SSH客户端 来完成的， 并没有图形界面， 所有的维护工作都需要通过命令来完成\r\n\r\n![1576225778294](./img/linux/java-linux/Linux-v10-01天-授课/1576225778294.png)\r\n\r\n在职场中， 作为后端程序员或者运维， 必须要或多或少的掌握一些Linux常用的终端命令\r\n\r\n- Linux发行版本的命令大概有200多个， 但是常用的命令只有几十个而已\r\n\r\n```\r\n总结\r\n学习终端命令的技巧：\r\n- 不需要死记硬背， 对于常用命令， 记住语法是关键，在用的时候去查下参数选项，有的很常用的命令，用的多自然就记住了\r\n- 不要尝试一次学会所有的命令， 有些命令是非常不常用的，临时遇到，就去根据语法找参数选项\r\n```\r\n\r\n## 2.2 Linux 用户和用户组管理\r\n\r\n### 2.2.1 Linux账号管理\r\n\r\n```\r\n从当前章节开始，我们正式进入CentOS的学习，我们先从简单的命令开始，比如操作账号、用户组、系统管理等。\r\n在实际使用场景中，用户账号的管理主要涉及到用户账号的添加、修改和删除操作。\r\n现在，我们就通过命令的方式添加用户账号（账号名字可以自定义，但是是要符合书写规范）\r\n在操作前，确保我们的SecureCRT成功连接到了虚拟机.\r\n下面的章节不在赘述SecureCRT，默认已经成功连接。\r\n```\r\n\r\n#### 1) 添加用户\r\n\r\n```\r\n我们在Windows创建账号主要是是控制面板--用户账户--创建一个新账户，这是在Windows创建账户的流程，而在Linux中，我们可以通过命令的方式进行创建账户\r\n```\r\n\r\n**使用者权限：管理员用户**\r\n\r\n```shell\r\nuseradd 选项 用户名\r\n```\r\n\r\n**参数说明：**\r\n\r\n- 选项:\r\n\r\n  - -c comment 指定一段注释性描述。\r\n  - -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。\r\n  - -g 用户组 指定用户所属的用户组。\r\n  - -G 用户组，用户组 指定用户所属的附加组。\r\n  - -s Shell文件 指定用户的登录Shell。\r\n  - -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。\r\n\r\n- 用户名:\r\n\r\n  指定新账号的用户名(后续我们可以使用这个用户名进行系统登录)。\r\n\r\n添加用户czbk（传智播客的首拼）执行\r\n\r\n```shell\r\nuseradd  czbk\r\n```\r\n\r\n我们使用useradd命令创建了一个用户czbk\r\n\r\nuseradd 可用来建立用户帐号。帐号建好之后，再用 passwd 设定帐号的密码。\r\n\r\n执行如下\r\n\r\n![1576043805214](./img/linux/java-linux/Linux-v10-01天-授课/1576043805214.png)\r\n\r\n由上图我们发现，我们在使用useradd新增用户的时候，出现了权限不足，也就是说我们使用用户itcast没有创建用户的权限。\r\n\r\n我们通过管理员账号root进行创建，首先我们从控制台中切换到root\r\n\r\n```shell\r\nsu root\r\n```\r\n\r\n![1576042675759](./img/linux/java-linux/Linux-v10-01天-授课/1576042675759.png)\r\n\r\n在 密码的地方输入我们的root密码【root】即可进入到root用户下。\r\n\r\n我们在root下继续创建czbk用户\r\n\r\n![1576043845543](./img/linux/java-linux/Linux-v10-01天-授课/1576043845543.png)\r\n\r\n以下是useradd常用选项\r\n\r\n![1576049906893](./img/linux/java-linux/Linux-v10-01天-授课/1576049906893.png)\r\n\r\n\r\n\r\n#### 2) 用户口令\r\n\r\n```\r\n引子：\r\n相当于我们在Windows系统中给个用户更改密码，只是我们在CentOS中是更改密码是通过命令完成的。\r\n```\r\n\r\n用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用\r\n\r\n**使用者权限：管理员用户**\r\n\r\n指定和修改用户口令的Shell命令是`passwd`。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：\r\n\r\n```shell\r\npasswd 选项 用户名\r\n```\r\n\r\n可使用的选项：\r\n\r\n- -l 锁定口令，即禁用账号。\r\n- -u 口令解锁。\r\n- -d 使账号无口令。\r\n- -f 强迫用户下次登录时修改口令。\r\n\r\n设置当前用户的口令\r\n\r\n```shell\r\npasswd czbk\r\n```\r\n\r\n此处我们设置密码和itcast账号密码一致，为【Itheima888】\r\n\r\n![1576044108094](./img/linux/java-linux/Linux-v10-01天-授课/1576044108094.png)\r\n\r\n#### 3) 修改用户\r\n\r\n```\r\n相当于我们在Windows系统中修改一个用户，只是我们在CentOS中是修改用户是通过命令完成的。\r\n```\r\n\r\nusermod 命令通过修改系统帐户文件来修改用户账户信息\r\n\r\n修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。\r\n\r\n**使用者权限：管理员用户**\r\n\r\n修改已有用户的信息使用`usermod`命令，其格式如下：\r\n\r\n```shell\r\nusermod 选项 用户名\r\n```\r\n\r\n下面命令将用户czbk用户名修改成czbk2019\r\n\r\n```shell\r\nusermod -l czbk2019  czbk\r\n```\r\n\r\n![1576046509680](./img/linux/java-linux/Linux-v10-01天-授课/1576046509680.png)\r\n\r\n以下是usermod常用选项\r\n\r\n![1576049946335](./img/linux/java-linux/Linux-v10-01天-授课/1576049946335.png)\r\n\r\n#### 4) 删除用户\r\n\r\n```\r\n相当于我们在Windows系统中删除一个用户，只是我们在CentOS中是删除用户是通过命令完成的。\r\n```\r\n\r\n假如我们其中一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。\r\n\r\n**使用者权限：管理员用户**\r\n\r\n删除一个已有的用户账号使用`userdel`命令，其格式如下：\r\n\r\n```shell\r\nuserdel 选项 用户名\r\n```\r\n\r\n-f：强制删除用户，即使用户当前已登录;\r\n\r\n-r：删除用户的同时，删除与用户相关的所有文件\r\n\r\n此命令删除用户czbk2019\r\n\r\n```shell\r\nuserdel czbk2019\r\n```\r\n\r\n![1576047020612](./img/linux/java-linux/Linux-v10-01天-授课/1576047020612.png)\r\n\r\n成功删除用户czbk2019\r\n\r\n以下是userdel常用选项\r\n\r\n![1576049978916](./img/linux/java-linux/Linux-v10-01天-授课/1576049978916.png)\r\n\r\n### 2.2.2 Linux用户组\r\n\r\n**引子：**\r\n\r\n**为了方便用户管理, 提出了 组 的概念, 如下图所示**\r\n\r\n![1576572808687](./img/linux/java-linux/Linux-v10-01天-授课/1576572808687.png)\r\n\r\n**新增一个账户，它默认属于自己（账户）的组**\r\n\r\n**比如新建账户【张三】，那么它默认对应的组就是张三**\r\n\r\n**一个用户可以有一个或者多个组**\r\n\r\n**假如说（如上图），我们在企业级开发过程中，我们有多个组，其中一个开发组对应三个账户，张三、李四、王五、如果就像上面提到的，一个用户默认对应一个组，那么三个账户张三、李四、王五就有了三个不同的组，如果大家都操做一个文件，在进行权限分配的时候，就要对不同的三个组进行授权，显然这样是不合理的，因为太过繁琐。**\r\n\r\n**所以，才有了组（新建组）的概念，我们把张三、李四、王五统一放到【开发组】，在对文件授权的时候，我们只对【开发组】进行授权由此，这样的话【张三、李四、王五】都有相等的权利操作了。**\r\n\r\n#### 1) 增加用户组\r\n\r\n新增一个用户组（组名可见名知意，符合规范即可），然后将用户添加到组中\r\n\r\n**使用者权限：管理员用户** \r\n\r\n```shell\r\ngroupadd 选项 用户组\r\n```\r\n\r\n使用的选项有：\r\n\r\n- -g GID 指定新用户组的组标识号（GID）。\r\n- -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同\r\n\r\n新增用户组czbk-it\r\n\r\n```shell\r\ngroupadd czbk-it\r\n```\r\n\r\n上面的命令向系统中增加了一个新组czbk-it，新组的组标识号是在当前已有的最大组标识号的基础上加1\r\n\r\n以下是groupadd常用选项\r\n\r\n![1576050003979](./img/linux/java-linux/Linux-v10-01天-授课/1576050003979.png)\r\n\r\n#### 2) 修改用户组\r\n\r\n**使用者权限：管理员用户**\r\n\r\n```shell\r\ngroupmod 选项 用户组\r\n```\r\n\r\n常用的选项有：\r\n\r\n- -g GID 为用户组指定新的组标识号。\r\n- -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。\r\n- -n新用户组 将用户组的名字改为新名字\r\n\r\n```shell\r\ngroupmod  -n czbk-it-2019  czbk-it\r\n```\r\n\r\n上面的命令将组czbk-it的组名修改为czbk-it-2019。\r\n\r\n![1576047810973](./img/linux/java-linux/Linux-v10-01天-授课/1576047810973.png)\r\n\r\n以下是groupmod常用选项\r\n\r\n![1576050645612](./img/linux/java-linux/Linux-v10-01天-授课/1576050645612.png)\r\n\r\n#### 3) 查询用户所属组\r\n\r\n在查询用户所属的用户组前，我们先增加一个用户ituser-groups\r\n\r\n```shell\r\nuseradd ituser-groups\r\n```\r\n\r\n![1576050663149](./img/linux/java-linux/Linux-v10-01天-授课/1576050663149.png)\r\n\r\n要查询一个用户属于哪个用户组，使用groups命令，其格式如下\r\n\r\n```shell\r\ngroups 用户名\r\n```\r\n\r\n查询用户ituser-groups属于某个用户组，执行groups命令\r\n\r\n```shell\r\ngroups ituser-groups\r\n```\r\n\r\n![1576050797421](./img/linux/java-linux/Linux-v10-01天-授课/1576050797421.png)\r\n\r\n由此可见，ituser-groups用户属于用户组ituser-groups（用户组默认与用户名一样）\r\n\r\n#### 4) 删除用户组\r\n\r\n**使用者权限：管理员用户**\r\n\r\n要删除一个已有的用户组，使用groupdel命令，其格式如下\r\n\r\n```shell\r\ngroupdel 用户组\r\n```\r\n\r\n删除czbk-it-2019用户组\r\n\r\n```shell\r\ngroupdel czbk-it-2019\r\n```\r\n\r\n![1576051028346](./img/linux/java-linux/Linux-v10-01天-授课/1576051028346.png)\r\n\r\n删除成功\r\n\r\n以下是groupdel常用选项\r\n\r\n![1576050031859](./img/linux/java-linux/Linux-v10-01天-授课/1576050031859.png)\r\n\r\n### 2.2.3 将用户添加到组\r\n\r\n```\r\n引子：\r\n在上面我们学习如何新增用户，也学习了如何新增用户组，在当前的小节中，我们新建一个用户、新建一个用户组、然后把新建的用户添加到新的组中\r\n在实际开发过程中，我们通常把多个用户按照业务需求归并到统一的一个组中，进行有序管理\r\n```\r\n\r\n1、创建一个新的组，并添加组ID（需要切换到root用户）\r\n\r\n```shell\r\ngroupadd -g 8888 itbj2020group\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576137760529](./img/linux/java-linux/Linux-v10-01天-授课/1576137760529.png)\r\n\r\n2、创建3个用户（需要切换到root用户）\r\n\r\n```shell\r\n useradd  itbeijinguser1\r\n useradd  itbeijinguser2\r\n useradd  itbeijinguser3\r\n```\r\n\r\n3、将上面三个用户添加到组itbj2020group\r\n\r\n我们通过passwd命令将三个用户添加到组\r\n\r\n**什么是gpasswd：**\r\n\r\ngpasswd 是 Linux 下工作组文件 /etc/group 和 /etc/gshadow 管理工具，用于将一个用户添加到组或者从组中删除。\r\n\r\n语法\r\n\r\n```shell\r\ngpasswd [可选项] 组名\r\n```\r\n\r\n**将上面的三个用户使用gpasswd添加到组（需要切换到root用户）**\r\n\r\n```shell\r\ngpasswd -a itbeijinguser1 itbj2020group\r\ngpasswd -a itbeijinguser2 itbj2020group\r\ngpasswd -a itbeijinguser3 itbj2020group\r\n```\r\n\r\n**执行如下**\r\n\r\n![1576139901757](./img/linux/java-linux/Linux-v10-01天-授课/1576139901757.png)\r\n\r\n**查看用户组下所有用户（所有用户）**\r\n\r\n> 注意\r\n>\r\n> 此处的grep命令我们将在文件管理章节详细讲解，这里先使用它查看下效果\r\n\r\n```shell\r\ngrep \'itbj2020group\' /etc/group\r\n```\r\n\r\n执行效果如下（或者直接打开/etc/group文件都可以）\r\n\r\n![1576139987480](./img/linux/java-linux/Linux-v10-01天-授课/1576139987480.png)\r\n\r\n由上图可知：三个用户全部都加入到了itbj2020group组。\r\n\r\n## 2.3 系统管理\r\n\r\n```\r\n系统管理，说的就是我们的CentOS系统，它不同于Windwos，CentOS是字符界面，我们需要通过命令进行操作，在当前章节，我们先从基本命令学起，比如创建用户、设置密码、修改用户以及用户组的相关操作。也为我们后面的章节打下基础\r\n```\r\n\r\n### 2.3.1 日期管理\r\n\r\n```\r\n当前日期如果通过date进行设置，在系统重启后不会保存date的设置，常用的只是通过date命令查看日期\r\n```\r\n\r\ndate 可以用来显示或设定系统的日期与时间\r\n\r\n使用者权限：所有用户\r\n\r\n**语法如下：**\r\n\r\n```shell\r\ndate [参数选项]\r\n```\r\n\r\n参数\r\n\r\n-d<字符串>：显示字符串所指的日期与时间。字符串前后必须加上双引号； \r\n-s<字符串>：根据字符串来设置日期与时间。字符串前后必须加上双引号； \r\n-u：显示GMT； \r\n--help：在线帮助； \r\n--version：显示版本信息\r\n\r\n1、设置时间\r\n\r\n用 -s选项可以设置系统时间，如下：\r\n\r\n```shell\r\ndate -s "2019-12-11 16:15:00"\r\n```\r\n\r\n![1576052178420](./img/linux/java-linux/Linux-v10-01天-授课/1576052178420.png)\r\n\r\n2、显示时间\r\n\r\n```shell\r\ndate\r\n```\r\n\r\n![1576052234012](./img/linux/java-linux/Linux-v10-01天-授课/1576052234012.png)\r\n\r\n**（1）UTC** \r\n\r\n协调世界时，又称世界统一时间、世界标准时间、国际协调时间。由于英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称UTC。。\r\n\r\n**（2）GMT**\r\n\r\n即[格林尼治](https://baike.baidu.com/item/格林尼治/3065623) 平太阳时间，是指格林尼治所在地的标准时间，也是表示地球自转速率的一种形式\r\n\r\n**外文名:**Universal Time\r\n\r\n**其他外文名**G.M.T.(Greenwich Mean Time)\r\n\r\n**（3）CST**\r\n\r\n北京时间 （中国国家标准时间）\r\n**北京时间是中国采用国际时区东八时区的区时作为标准时间**。\r\n北京时间并不是北京（东经116.4°）的地方时间，而是东经120°的地方时间，故东经120度地方时比北京的地方时早约14分半钟。因为北京处于国际时区划分中的东八区，同格林尼治时间（世界时）整整相差8小时（即北京时间=世界时+8小时），故命名为“北京时间”。东八区包括的范围从东经112.5°到东经127.5°，以东经120°为中心线，东西各延伸7.5°，总宽度为15°的区域。\r\n**而中国幅员辽阔，东西相跨5个时区（即东五区、东六区、东七区、东八区、东九区5个时区）授时台必须建在地理中心地带，从而也就产生了长短波授。“北京时间”与“北京当地时间”是两个概念，  “北京时间”的发播不在北京，而在陕西蒲城（处于东七区）**\r\n\r\n**（4）东八区**\r\n\r\n东八区（[UTC](https://baike.baidu.com/item/UTC)/[GMT](https://baike.baidu.com/item/GMT/6026868)+08:00）是比[世界协调时间](https://baike.baidu.com/item/世界协调时间/8036498)（UTC）/[格林尼治时间](https://baike.baidu.com/item/格林尼治时间/410004)（GMT）快8小时的时区，理论上的位置是位于[东经](https://baike.baidu.com/item/东经/8661846)112.5度至127.5度之间，是东盟标准的其中一个候选时区。当格林尼治标准时间为0:00时，东八区的标准时间为08:00\r\n\r\n```\r\n总结：\r\n上面提到了很多知识：即UTC/GMT/CST/东八区\r\n总结一下就是，北京时间(中国国家标准时间CST)采用东八区区时，即：\r\n协调世界时(UTC)+8  /   格林尼治时间(GMT)+8\r\n也就是说+8后的时间才是北京时间\r\n```\r\n\r\n### 2.3.2 显示用户\r\n\r\nlogname命令用于显示用户名称。\r\n\r\n执行logname指令，它会显示目前用户的名称\r\n\r\n**语法为如下：**\r\n\r\n```shell\r\nlogname [--help][--version]\r\n```\r\n\r\n**参数**：\r\n\r\n- --help 　在线帮助。\r\n- --vesion 　显示版本信息。\r\n\r\n显示登录账号的信息\r\n\r\n```shell\r\nlogname\r\n```\r\n\r\n![1576053311351](./img/linux/java-linux/Linux-v10-01天-授课/1576053311351.png)\r\n\r\n### 2.3.3 su切换账户\r\n\r\n```\r\n引子：\r\n比如我们在新增用户、修改用户或者操作用户组的时候常常需要切换到管理员账户，这个时候，我们就可以使用su进行快速切换\r\n```\r\n\r\nsu命令用于变更为其他使用者的身份，除 root 外，需要键入该使用者的密码。\r\n\r\n使用权限：所有使用者。\r\n\r\n**语法如下：**\r\n\r\n```shell\r\nsu \r\n```\r\n\r\n变更帐号为 root 并在执行 ls 指令后退出返回原使用者\r\n\r\n```shell\r\n su -c ls root\r\n```\r\n\r\n![1576054831537](./img/linux/java-linux/Linux-v10-01天-授课/1576054831537.png)\r\n\r\n切换到root\r\n\r\n```shell\r\nsu root\r\n```\r\n\r\n![1576054846742](./img/linux/java-linux/Linux-v10-01天-授课/1576054846742.png)\r\n\r\n这样的话，我们就进入到了root用户下。\r\n\r\n### 2.3.4 id命令\r\n\r\n```\r\n我们如果需要查看当前账号详细信息的时候，比如查看它的用户id、群组id以及所属组的时候，我们就可以使用id命令进行查看\r\n```\r\n\r\n id命令用于显示用户的ID，以及所属群组的ID。\r\n\r\nid会显示用户以及所属群组的实际与有效ID。若两个ID相同，则仅显示实际ID。若仅指定用户名称，则显示目前用户的ID。\r\n\r\n使用者权限：所有用户\r\n\r\n**语法**\r\n\r\n```\r\nid [-gGnru][--help][--version][用户名称]\r\n```\r\n\r\n**参数说明：**\r\n\r\n- -g或--group 　显示用户所属群组的ID。\r\n- -G或--groups 　显示用户所属附加群组的ID。\r\n- -n或--name 　显示用户，所属群组或附加群组的名称。\r\n- -r或--real 　显示实际ID。\r\n- -u或--user 　显示用户ID。\r\n- -help 　显示帮助。\r\n- -version 　显示版本信息。\r\n\r\n**显示当前用户信息**\r\n\r\n```shell\r\nid\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576578213110](./img/linux/java-linux/Linux-v10-01天-授课/1576578213110.png)\r\n\r\n> 总结\r\n>\r\n> id命令参数虽然很多\r\n>\r\n> 但是常用的也就是id命令，不带参数的\r\n>\r\n> 主要看他的uid和组信息\r\n\r\n### 2.3.5 sudo执行\r\n\r\n```\r\n比如我们使用普通用户操作用户或者操作用户组、以及修改网卡配置文件的时候，需要切换到root用户才操作，此时我们可以使用sudo命令提高普通用户的操作权限，以达到操作目的\r\n```\r\n\r\nsudo:控制用户对系统命令的使用权限,root允许的操作。\r\n\r\n通过sudo可以提高普通用户的操作权限\r\n\r\n使用者权限：普通用户\r\n\r\n**语法如下：**\r\n\r\nsudo -V\r\nsudo -h\r\nsudo -l\r\nsudo -v\r\nsudo -k\r\nsudo -s\r\nsudo -H\r\nsudo [ -b ] [ -p prompt ] [ -u username/#uid] -s\r\nsudo command\r\n\r\n**参数说明**：\r\n\r\n- -V 显示版本编号\r\n- -h 会显示版本编号及指令的使用方式说明\r\n- -l 显示出自己（执行 sudo 的使用者）的权限\r\n- -v 因为 sudo 在第一次执行时或是在 N 分钟内没有执行（N 预设为五）会问密码，这个参数是重新做一次确认，如果超过 N 分钟，也会问密码\r\n- -k 将会强迫使用者在下一次执行 sudo 时问密码（不论有没有超过 N 分钟）\r\n- -b 将要执行的指令放在背景执行\r\n- -p prompt 可以更改问密码的提示语，其中 %u 会代换为使用者的帐号名称， %h 会显示主机名称\r\n- -u username/#uid 不加此参数，代表要以 root 的身份执行指令，而加了此参数，可以以 username 的身份执行指令（#uid 为该 username 的使用者号码）\r\n- -s 执行环境变数中的 SHELL 所指定的 shell ，或是 /etc/passwd 里所指定的 shell\r\n- -H 将环境变数中的 HOME 指定为要变更身份的使用者HOME目录（如不加 -u 参数就是系统管理者 root ）\r\n- command 要以系统管理者身份（或以 -u 更改为其他人）执行的指令\r\n\r\nsudo命令使用\r\n\r\n```shell\r\nsudo ls\r\n```\r\n\r\n![1576056341831](./img/linux/java-linux/Linux-v10-01天-授课/1576056341831.png)\r\n\r\n指定root用户执行指令\r\n\r\n```shell\r\nsudo -u root ls -l\r\n```\r\n\r\n![1576056180063](./img/linux/java-linux/Linux-v10-01天-授课/1576056180063.png)\r\n\r\n**修改网卡配置文件**\r\n\r\n比如，在下面的例子中，我们使用普通用户修改网卡的配置文件，在进行保存的时候，提示我们【无法打开并写入文件】，那么此时，我们可以通过sudo命令来提升自己的写入权限\r\n\r\n执行：\r\n\r\n```shell\r\n vi /etc/sysconfig/network-scripts/ifcfg-ens33 \r\n```\r\n\r\n执行效果如下（保存）\r\n\r\n![1576494207598](./img/linux/java-linux/Linux-v10-01天-授课/1576494207598.png)\r\n\r\n然后点击回车\r\n\r\n![1576493914410](./img/linux/java-linux/Linux-v10-01天-授课/1576493914410.png)\r\n\r\n那么我们在修改上面的 命令，使用sudo进行修改\r\n\r\n```shell\r\nsudo   vi /etc/sysconfig/network-scripts/ifcfg-ens33 \r\n```\r\n\r\n执行效果如下（键入itcast密码）\r\n\r\n![1576494108199](./img/linux/java-linux/Linux-v10-01天-授课/1576494108199.png)\r\n\r\n执行保存\r\n\r\n![1576494276066](./img/linux/java-linux/Linux-v10-01天-授课/1576494276066.png)\r\n\r\n我们发现此时就不在报错了\r\n\r\n### 2.3.6 top命令\r\n\r\n```\r\n在企业级开发中，开发人员（运维人员也会经常使用）常常为了查看服务器上运行的程序占用的CPU情况以及占用内存情况，目的就是检测我们的程序是否在正常范围内运行\r\n```\r\n\r\ntop命令用于实时显示 process 的动态。\r\n\r\n使用权限：所有使用者。\r\n\r\n**显示进程信息**\r\n\r\n```shell\r\ntop\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576495173035](./img/linux/java-linux/Linux-v10-01天-授课/1576495173035.png)\r\n\r\n**各进程（任务）的状态监控属性解释说明：**\r\nPID — 进程id\r\nUSER — 进程所有者\r\nPR — 进程优先级\r\nNI — nice值。负值表示高优先级，正值表示低优先级\r\nVIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES\r\nRES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA\r\nSHR — 共享内存大小，单位kb\r\nS — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程\r\n%CPU — 上次更新到现在的CPU时间占用百分比\r\n%MEM — 进程使用的物理内存百分比\r\nTIME+ — 进程使用的CPU时间总计，单位1/100秒\r\nCOMMAND — 进程名称（命令名/命令行）\r\n\r\n**显示完整命令，与top命令不同的就是command属性像是进行了命令补全**\r\n\r\n```shell\r\ntop -c\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576544383182](./img/linux/java-linux/Linux-v10-01天-授课/1576544383182.png)\r\n\r\n**显示指定的进程信息，以下显示进程号为6972的进程信息，CPU、内存占用率等**\r\n\r\n```shell\r\n top -p 6972\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576544720729](./img/linux/java-linux/Linux-v10-01天-授课/1576544720729.png)\r\n\r\n\r\n\r\n> top命令的用法很多\r\n>\r\n> 但是常用的就是top（不带参数），有的时候，在进程比较多的时候，我们常常记住进程的pid，然后通过top -p pid进行查看\r\n>\r\n> 也就是说，top+ top -p是经常被用到的\r\n\r\n###  2.3.7 ps命令\r\n\r\n```\r\nps命令类似于我们在Windows中通过任务管理器查看进程信息\r\n```\r\n\r\nLinux ps命令用于显示当前进程 (process) 的状态信息\r\n\r\n使用者权限：所有用户\r\n\r\n**语法如下：**\r\n\r\n```shell\r\nps \r\n```\r\n\r\n显示进程信息\r\n\r\n```shell\r\nps -A \r\n```\r\n\r\n显示指定用户信息\r\n\r\n```powershell\r\n ps -u itcast\r\n```\r\n\r\n显示所有进程信息 \r\n\r\n```shell\r\nps -ef \r\n```\r\n\r\n### 2.3.8 kill命令\r\n\r\n```\r\n引子：\r\n前面，我们刚刚学习完了Windows上开发，比如，我们经常遇到的要给问题就是，我们需要经常的启动或者重启tomcat，有的时候会报端口冲突，这个时候，我们可能就去Windows的任务管理器中去结束这个进程\r\n那么在Linux中我们可以通过kill命令来实现Windwos上手工结束进程的操作\r\n```\r\n\r\nLinux kill命令用于删除执行中的程序或工作(可强制中断)\r\n\r\n使用者权限：所有用户\r\n\r\n**语法如下：**\r\n\r\n```shell\r\nkill [-s <信息名称或编号>][程序]　或　kill [-l <信息编号>]\r\n```\r\n\r\n **参数说明**：\r\n\r\n- -l <信息编号> 　若不加<信息编号>选项，则-l参数会列出全部的信息名称。\r\n- -s <信息名称或编号> 　指定要送出的信息。\r\n- [程序] 　[程序]可以是程序的PID或是PGID，也可以是工作编号。\r\n\r\n杀死一个进程\r\n\r\n```shell\r\n kill 15642\r\n```\r\n\r\n强制杀死进程\r\n\r\n```shell\r\nkill -KILL 15642\r\n```\r\n\r\n彻底杀死进程\r\n\r\n```shell\r\nkill -9 15642\r\n```\r\n\r\n杀死指定用户所有进程\r\n\r\n1.方法一 过滤出itcast用户进程 \r\n\r\n```shell\r\nkill -9 $(ps -ef | grep itcast) \r\n```\r\n\r\n2.方法二，直接杀死\r\n\r\n```shell\r\nkill -u itcast\r\n```\r\n\r\n> 注意\r\n>\r\n> 上面列举了很多kill进程的命令\r\n>\r\n> 但是我们我们常用的就是kill -9命令，我们常常找到进程的pid\r\n>\r\n> 然后通过kill -9进行杀死进程\r\n\r\n### 2.3.9 关机命令\r\n\r\nshutdown命令可以用来进行关闭系统，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机\r\n\r\n使用者权限：管理员用户\r\n\r\n**语法如下：**\r\n\r\n```shell\r\nshutdown [-t seconds] [-rkhncfF] time [message]\r\n```\r\n\r\n**参数说明**：\r\n\r\n- -t seconds : 设定在几秒钟之后进行关机程序。\r\n- -k : 并不会真的关机，只是将警告讯息传送给所有使用者。\r\n- -r : 关机后重新开机。\r\n- -h : 关机后停机。\r\n- -n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。\r\n- -c : 取消目前已经进行中的关机动作。\r\n- -f : 关机时，不做 fcsk 动作(检查 Linux 档系统)。\r\n- -F : 关机时，强迫进行 fsck 动作。\r\n- time : 设定关机的时间。\r\n- message : 传送给所有使用者的警告讯息。\r\n\r\n立即关机\r\n\r\n```shell\r\nshutdown -h now\r\n或者\r\nshudown\r\n```\r\n\r\n指定1分钟后关机，1分钟关机并显示警告信息\r\n\r\n```shell\r\nshutdown +1 “System will shutdown after 1 minutes” \r\n```\r\n\r\n![1576059932470](./img/linux/java-linux/Linux-v10-01天-授课/1576059932470.png)\r\n\r\n指定1分钟后重启，并发出警告信息\r\n\r\n```shell\r\nshutdown –r +1 “1分钟后关机重启”\r\n```\r\n\r\n![1576060232485](./img/linux/java-linux/Linux-v10-01天-授课/1576060232485.png)\r\n\r\n### 2.3.10 重启命令\r\n\r\nreboot命令用于用来重新启动计算机\r\n\r\n使用者权限：管理员、普通（需要验证）用户\r\n\r\n**语法如下：**\r\n\r\n```shell\r\nreboot [-n] [-w] [-d] [-f] [-i]\r\n```\r\n\r\n**参数**：\r\n\r\n- -n : 在重开机前不做将记忆体资料写回硬盘的动作\r\n- -w : 并不会真的重开机，只是把记录写到 /var/log/wtmp 档案里\r\n- -d : 不把记录写到 /var/log/wtmp 档案里（-n 这个参数包含了 -d）\r\n- -f : 强迫重开机，不呼叫 shutdown 这个指令\r\n- -i : 在重开机之前先把所有网络相关的装置先停止\r\n\r\n开始重新启动\r\n\r\n```shell\r\nreboot\r\n```\r\n\r\n重启效果如下\r\n\r\n![1576136722927](./img/linux/java-linux/Linux-v10-01天-授课/1576136722927.png)\r\n\r\n此时我们的虚拟机正在重启**（别忘记使用root用户执行）**\r\n\r\n### 2.3.11 who命令\r\n\r\n```\r\n在企业级开发过程中，我们使用who命令的时候常常需要快速重启服务器，在重启之前需要检测下有没有终端在连接（处理程序），如果有，可能就不会重启（会私下询问何时弄完，弄完后在重启），如果没有其他人连接，将执行快速重启\r\n```\r\n\r\nwho命令用于显示系统中有哪些使用者正在上面，显示的资料包含了使用者 ID、使用的终端机、从哪边连上来的、上线时间、呆滞时间、CPU 使用量、动作等等\r\n\r\n使用者权限：所有使用者都可使用。\r\n\r\n**语法如下：**\r\n\r\n```shell\r\nwho - [husfV] [user]\r\n```\r\n\r\n**参数说明**：\r\n\r\n- -H 或 --heading：显示各栏位的标题信息列；\r\n- -i 或 -u 或 --idle：显示闲置时间，若该用户在前一分钟之内有进行任何动作，将标示成"."号，如果该用户已超过24小时没有任何动作，则标示出"old"字符串；\r\n- -m：此参数的效果和指定"am i"字符串相同；\r\n- -q 或--count：只显示登入系统的帐号名称和总人数；\r\n- -s：此参数将忽略不予处理，仅负责解决who指令其他版本的兼容性问题；\r\n- -w 或-T或--mesg或--message或--writable：显示用户的信息状态栏；\r\n- --help：在线帮助；\r\n- --version：显示版本信息\r\n\r\n显示当前登录系统的用户\r\n\r\n```shell\r\nwho\r\n```\r\n\r\n![1576143161044](./img/linux/java-linux/Linux-v10-01天-授课/1576143161044.png)\r\n\r\n显示明细(标题)信息\r\n\r\n```shell\r\nwho -H\r\n```\r\n\r\n![1576143218612](./img/linux/java-linux/Linux-v10-01天-授课/1576143218612.png)\r\n\r\n由上图可知，截止到现在只有itcast在线。\r\n\r\n### 2.3.12 timedatectl命令\r\n\r\n```\r\n引子：\r\ntimedatectl是用于控制系统时间和日期。可以用来查询和更改系统时钟于设定，同时可以设定和修改时区信息。\r\n\r\n在实际开发过程中，系统时间的显示会和实际出现不同步；我们一般为了校正服务器时间、时区的时候会使用timedatectl命令\r\n```\r\n\r\n使用者权限：所有使用者都可使用，设置时间需要管理员，下面会标注。\r\n\r\n几个常见的概念，进行总结如下：\r\n\r\n![1576550880532](./img/linux/java-linux/Linux-v10-01天-授课/1576550880532.png)\r\n\r\n**显示系统的当前时间和日期，使用命令行中的timedatectl命令**\r\n\r\n```SHELL\r\ntimedatectl status\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576147390352](./img/linux/java-linux/Linux-v10-01天-授课/1576147390352.png)\r\n\r\n在上面的示例中，分别显示时区、CST时间和UTC时间，其中,RTC time就是硬件时钟的时间，硬件时间默认为UTC。\r\n\r\n**查看当前时区**\r\n\r\n```shell\r\ntimedatectl | grep Time\r\n或者\r\ntimedatectl \r\n```\r\n\r\n执行效果如下\r\n\r\n![1576147504533](./img/linux/java-linux/Linux-v10-01天-授课/1576147504533.png)\r\n\r\n上图显示中国时区\r\n\r\n**查看所有可用的时区**\r\n\r\n```\r\ntimedatectl list-timezones\r\n```\r\n\r\n执行效果如下（下面数据没有截全）\r\n\r\n![1576147567622](./img/linux/java-linux/Linux-v10-01天-授课/1576147567622.png)\r\n\r\n**设置本地时区**\r\n\r\n```shell\r\ntimedatectl set-timezone "Asia/Shanghai"\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576147666007](./img/linux/java-linux/Linux-v10-01天-授课/1576147666007.png)\r\n\r\n**禁用时间同步（使用管理员账户）**\r\n\r\n```shell\r\ntimedatectl set-ntp false\r\n在执行\r\ntimedatectl set-time "2019-03-11 20:45:00"\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576148429123](./img/linux/java-linux/Linux-v10-01天-授课/1576148429123.png)\r\n\r\n> 注意: 如果ntp时间同步为true时无法修改时间设定，下面马上介绍\r\n\r\n**打开ntp**\r\n\r\n```shell\r\ntimedatectl set-ntp true\r\n在执行\r\ntimedatectl set-time "2019-03-11 20:45:00"\r\n```\r\n\r\n执行效果如下（ntp时间同步为true时无法修改时间设定）\r\n\r\n报错信息 如下\r\n\r\n![1576226884267](./img/linux/java-linux/Linux-v10-01天-授课/1576226884267.png)\r\n\r\n**启用时间同步**\r\n\r\nNTP即Network Time Protocol（网络时间协议），是一个互联网协议，用于同步计算机之间的系统时钟。timedatectl实用程序可以自动同步你的Linux系统时钟到使用NTP的远程服务器。\r\n\r\n要开始自动时间同步到远程NTP服务器，在终端键入以下命令。\r\n\r\n```shell\r\ntimedatectl set-ntp true\r\n```\r\n\r\n比如，在上面我们使用timedatectl set-time "2019-03-11 20:45:00"，如下图\r\n\r\n![1576229638059](./img/linux/java-linux/Linux-v10-01天-授课/1576229638059.png)\r\n\r\n此时我们执行timedatectl set-ntp true，发现时间正常同步过来了如下图\r\n\r\n![1576229679265](./img/linux/java-linux/Linux-v10-01天-授课/1576229679265.png)\r\n\r\n要禁用NTP时间同步，在终端键入以下命令\r\n\r\n```shell\r\ntimedatectl set-ntp false\r\n```\r\n\r\n执行上面的 命令即可关闭ntp\r\n\r\n> 总结\r\n>\r\n> 在实际使用过程中\r\n>\r\n> 我们经常使用timedatectl进行时区、CST、UTC的设置\r\n\r\n\r\n\r\n### 2.3.13 clear命令\r\n\r\n clear命令用于清除屏幕\r\n\r\n使用者权限：所有使用者都可使用。\r\n\r\n**语法**\r\n\r\n```shell\r\nclear\r\n```\r\n\r\n执行clear前\r\n\r\n![1576230100277](./img/linux/java-linux/Linux-v10-01天-授课/1576230100277.png)\r\n\r\n执行clear后\r\n\r\n![1576230123895](./img/linux/java-linux/Linux-v10-01天-授课/1576230123895.png)\r\n\r\n通过执行clear命令，就可以把缓冲区的命令全部清理干净了\r\n\r\n### **2.3.14 exit命令**\r\n\r\nexit命令用于退出目前的shell。\r\n\r\n执行exit可使shell以指定的状态值退出。若不设置状态值参数，则shell以预设值退出。状态值0代表执行成功，其他值代表执行失败。exit也可用在script，离开正在执行的script，回到shell。\r\n\r\n```\r\n退出码（exit status，或exit code）的约定：\r\n\r\n0表示成功（Zero - Success）\r\n\r\n非0表示失败（Non-Zero  - Failure）\r\n\r\n2表示用法不当（Incorrect Usage）\r\n\r\n127表示命令没有找到（Command Not Found）\r\n\r\n126表示不是可执行的（Not an executable）\r\n\r\n>=128 信号产生\r\n```\r\n\r\n**语法如下**\r\n\r\n```shell\r\nexit [状态值]\r\n```\r\n\r\n退出终端\r\n\r\n```shell\r\n# exit\r\n```\r\n\r\n> exit会被经常在shell中使用\r\n>\r\n> 我们在明天的课程【综合案例】中会使用到exit\r\n\r\n## 2.4 总结\r\n\r\n用户账号管理和用户组是我们在实际使用过程中常用的命令，学习完创建账号、创建组后，需要通过gpasswd命令将用户添加到组，这也是我们学习的最终目的\r\n\r\n系统管理的常用命令都是在开发过程中经常使用到的\r\n\r\n# 3 Linux目录管理\r\n\r\n```\r\n注意：\r\n在下面的讲解中，每个命令都有很多的参数说明（选项），我们只讲其中的几个，关键是让学生掌握命令的语法；学生学习完语法后，就可以自己按照参数书写各种命令，这也是我们最终的目的。常用命令，我们在企业级开发过程中，经常书写的命令。会非常被容易记住，不常用的命令，只要我们学习完了语法之后，在去查找参数手册，会非常容易的解决我们的问题，所以，每个命令不是建立在死记硬背的基础上的，要理解语法+查找参数=解决问题\r\n```\r\n\r\n## 3.1 Linux 文件与目录管理\r\n\r\n```\r\n在Linux系统中，所有的的目录结构为树状结构，最顶级的目录为根目录 /。\r\n在实际开发过程中，文件的操作是非常频繁也是非常重要的\r\n下面的章节我们将学习下Linux系统所有的系统目录和文件通过命令是如何进行管理的 \r\n```\r\n\r\n### 3.1.1 目录常用命令\r\n\r\n- ls:         列出目录\r\n- cd：     切换目录\r\n- pwd：  显示目前的目录\r\n- mkdir：创建一个新的目录\r\n- rmdir：删除一个空的目录\r\n- cp:         复制文件或目录\r\n- rm:        移除文件或目录\r\n- mv:        移动文件与目录或修改文件与目录的名称\r\n\r\n**自动补全**\r\n\r\n- 在敲出 文件/ 目录 / 命令 的前几个字母之后, 按下 `tab`键\r\n- 如果还存在其他 文件 / 目录 / 命令, 再按一下tab键, 系统会提示可能存在的命令\r\n\r\n#### 1) ls (列出目录)\r\n\r\n```\r\nls命令相当于我们在Windows系统中打开磁盘、或者打开文件夹看到的目录以及文件的明细，如下图\r\n```\r\n\r\n【查看磁盘下的目录与文件】\r\n\r\n![1576564124577](./img/linux/java-linux/Linux-v10-01天-授课/1576564124577.png)\r\n\r\n【查看文件夹下的目录与文件】\r\n\r\n![1576564161701](./img/linux/java-linux/Linux-v10-01天-授课/1576564161701.png)\r\n\r\n\r\n\r\n注意：在Linux系统当中， ls 命令算是比较常用的命令\r\n\r\n使用者权限：所有使用者都可使用。\r\n\r\n**语法如下：**\r\n\r\n```\r\nls [选项]  目录名称\r\n```\r\n\r\n**选项与参数：**\r\n\r\n- -a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来(常用)\r\n- -d ：仅列出目录本身，而不是列出目录内的文件数据(常用)\r\n- -l ：长数据串列出，包含文件的属性与权限等等数据；(常用)\r\n\r\n**将根目录下的所有文件列出来(含属性与隐藏档)**\r\n\r\n```\r\n ls -al ~\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576553470716](./img/linux/java-linux/Linux-v10-01天-授课/1576553470716.png)\r\n\r\n```\r\n ls -l\r\n```\r\n\r\n![1576639252612](./img/linux/java-linux/Linux-v10-01天-授课/1576639252612.png)\r\n\r\n`ls -l` 可以查看文件夹下文件的详细信息, 从左到右 依次是:\r\n\r\n- **权限（A区域）**, 第一个字符如果是 `d` 表示目录\r\n- **硬链接数（B区域）**, 通俗的讲就是有多少种方式, 可以访问当前目录和文件\r\n- **属主（C区域）**, 文件是所有者、或是叫做属主\r\n- **属组（D区域）**, 文件属于哪个组\r\n- **大小（E区域）：文件大小**\r\n- **时间（F区域）：最后一次访问时间**\r\n- **名称（G区域）:文件的名称**\r\n\r\n```\r\nls\r\n```\r\n\r\n![1576553646036](./img/linux/java-linux/Linux-v10-01天-授课/1576553646036.png)\r\n\r\n```\r\n总结\r\n以上三种是经常被使用到的命令\r\n它们之间的区别是\r\nls  显示不隐藏的文件与文件夹\r\nls -l 显示不隐藏的文件与文件夹的详细信息\r\nls -al   显示所有文件与文件夹的详细信息\r\n```\r\n\r\n#### 2) pwd显示当前目录\r\n\r\n```\r\n执行pwd命令相当于我们在Windows系统路径导航栏中查看到的当前浏览位置信息\r\n```\r\n\r\n如下图\r\n\r\n![1576564294612](./img/linux/java-linux/Linux-v10-01天-授课/1576564294612.png)\r\n\r\n\r\n\r\npwd 是 **Print Working Directory** 的缩写，也就是显示目前所在当前目录的命令。\r\n\r\n使用者权限：所有使用者都可使用。\r\n\r\n**查看当前所在目录**\r\n\r\n```\r\npwd -P\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576552719245](./img/linux/java-linux/Linux-v10-01天-授课/1576552719245.png)\r\n\r\n#### 3) cd (切换目录)\r\n\r\n```\r\nLinux的cd切换目录，相当于我们在Windows中通过鼠标或者快捷键点开不同的目录\r\n```\r\n\r\n注意：在Linux系统当中， cd 命令算是比较常用的命令\r\n\r\ncd是Change Directory的缩写，这是用来变换工作目录的命令\r\n\r\n使用者权限：所有使用者都可使用。\r\n\r\n**语法如下：**\r\n\r\n```\r\n cd [相对路径或绝对路径]\r\n```\r\n\r\n在正式学习cd命令前面，我们通过下面一个座位图的形式讲解下相对路径和绝对路径是怎么表现的。\r\n\r\n![1576465885337](./img/linux/java-linux/Linux-v10-01天-授课/1576465885337.png)\r\n\r\n\r\n\r\n- **绝对路径：**\r\n  路径的写法，由根目录 / 写起，例如： /usr/share/doc 这个目录。\r\n- **相对路径：**\r\n  路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成： cd ../man 这就是相对路径的写法啦！\r\n\r\n**1、使用相对路径定位目标**\r\n\r\n- 特征:  **相对路径** 输入路径时, 最前面不是以 "/" 开始的, 表示相对 **当前目录** 所在的位置\r\n- 缺点:  参照工作目录 发生变化 相对路径也要发生变化\r\n\r\n```\r\n需求1: 当前工作目录是 /usr, 使用相对路径 切换到 /usr/tmp 目录下 \r\n\r\n需求2: 当前工作目录是 /root, 使用相对路径 切换到 /usr/tmp 目录下 \r\n```\r\n\r\n![1576466126779](./img/linux/java-linux/Linux-v10-01天-授课/1576466126779.png)\r\n\r\n执行效果如下\r\n\r\n```\r\n注意：\r\ncd ~ 表示回到根目录\r\n```\r\n\r\n![1576466284360](./img/linux/java-linux/Linux-v10-01天-授课/1576466284360.png)\r\n\r\n**2、使用绝对路径定位目标**\r\n\r\n- 特征: **绝对路径** 在输入路径时, 最前面是以 `/`  开始的, 表示 从 **根目录** 开始的具体目录位置\r\n- 优点: 定位准确, 不会因为 工作目录变化 而变化\r\n\r\n```\r\n需求1: 当前工作目录是 /usr, 使用绝对路径 切换到 /usr/tmp 目录下 \r\n\r\n需求2: 当前工作目录是 /root, 使用绝对路径 切换到 /usr/tmp 目录下 \r\n```\r\n\r\n![1576466413099](./img/linux/java-linux/Linux-v10-01天-授课/1576466413099.png)\r\n\r\n执行效果如下\r\n\r\n![1576466506750](./img/linux/java-linux/Linux-v10-01天-授课/1576466506750.png)\r\n\r\n> 总结\r\n>\r\n> - **相对路径** 在输入路径时, 最前面不是以 `/` 开始的 , 表示相对 **当前目录** 所在的目录位置\r\n> - **绝对路径** 在输入路径时, 最前面是以 `/`  开始的, 表示 从 **根目录** 开始的具体目录位置\r\n\r\n\r\n\r\n#### 4) mkdir(创建目录)\r\n\r\n```\r\n引子：\r\nLinux的mkdir命令相当于我们在Windows中通过鼠标或者快捷键新建文件夹\r\n```\r\n\r\nmkdir命令用于建立名称为 dirName 之子目录\r\n\r\n使用权限：于目前目录有适当权限的所有使用者\r\n\r\n**语法**\r\n\r\n```\r\nmkdir [-p] dirName\r\n```\r\n\r\n**参数说明：**\r\n\r\n- -p 确保目录名称存在，不存在的就建一个\r\n\r\n建立一个名为jinyanlong 的子目录\r\n\r\n```shell\r\nmkdir jinyanlong\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576553229832](./img/linux/java-linux/Linux-v10-01天-授课/1576553229832.png)\r\n\r\n查看新建的 文件\r\n\r\n![1576553205885](./img/linux/java-linux/Linux-v10-01天-授课/1576553205885.png)\r\n\r\n在工作目录下的 aaa目录中，建立一个名为 bbb的子目录。 若 aaa目录原本不存在，则建立一个。（注：本例若不加 -p，且原本 aaa目录不存在，则产生错误。）\r\n\r\n```shell\r\nmkdir -p aaa/bbb\r\n```\r\n\r\n执行效果如下\r\n\r\n> 这里为了显示更直观，我们使用了tree命令\r\n>\r\n> 后面在讲解到yum的时候，会详细讲解\r\n>\r\n> 此处先使用\r\n\r\n![1576560522053](./img/linux/java-linux/Linux-v10-01天-授课/1576560522053.png)\r\n\r\n由上图我们发现，aaa目录被强制创建，里面包含了bbb文件。\r\n\r\n#### **5) rmdir(删空目录)**\r\n\r\n```\r\nLinux的rmdir命令相当于我们在Windows中通过鼠标或者快捷键删除文件夹。\r\n稍微有点不同的就是在Linux中删除子目录的时候，如果主目录下没有了目录以及文件，会连同主目录同时删除了（需要写Linux带有P的参数）\r\n```\r\n\r\nrmdir命令删除空的目录\r\n\r\n使用权限：于目前目录有适当权限的所有使用者。\r\n\r\n**语法**\r\n\r\n```shell\r\nrmdir [-p] dirName\r\n```\r\n\r\n**参数**：\r\n\r\n- -p 是当子目录被删除后使它也成为空目录的话，则顺便一并删除。\r\n\r\n**将工作目录下，名为 jinyanlong 的子目录删除 :**\r\n\r\n```shell\r\nrmdir jinyanlong\r\n```\r\n\r\n**在工作目录下的 aaa目录中，删除名为 bbb的子目录。若 bbb删除后，aaa目录成为空目录，则 aaa同时也会被删除**\r\n\r\n```shell\r\nrmdir  -p aaa/bbb\r\n```\r\n\r\n> 总结：\r\n>\r\n> rmdir  -p aaa/bbb也就是说\r\n>\r\n> 在删除bbb目录完成后，发现aaa目录也是空目录了，在删除完bbb后aaa也同时被删除了。\r\n\r\n#### 6) cp(文件复制)\r\n\r\n```\r\nLinux的cp命令相当于我们在Windows中通过鼠标或者快捷键复制文件或者目录\r\n```\r\n\r\ncp命令主要用于复制文件或目录。\r\n\r\n使用权限：于目前目录有适当权限的所有使用者\r\n\r\n**语法**\r\n\r\n```shell\r\ncp [options] source dest\r\n```\r\n\r\n或\r\n\r\n```shell\r\ncp [options] source... directory\r\n```\r\n\r\n**参数说明：**\r\n\r\n- -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。\r\n- -d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。\r\n- -f：覆盖已经存在的目标文件而不给出提示。\r\n- -i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答"y"时目标文件将被覆盖。\r\n- -p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。\r\n- -r/R：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。\r\n- -l：不复制文件，只是生成链接文件。\r\n\r\n我们将当前目录"aaa/"下的所有目录以及文件复制到新目录"ccc"下，输入如下命令：\r\n\r\n**1、数据准备**\r\n\r\n创建aaa目录并且aaa下包含bbb目录\r\n\r\n```shell\r\nmkdir -p aaa/bbb\r\nmkdir -p ccc\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576561579056](./img/linux/java-linux/Linux-v10-01天-授课/1576561579056.png)\r\n\r\naaa目录下有bbb\r\n\r\nccc下面没有目录和文件\r\n\r\n**2、执行复制**\r\n\r\n```shell\r\ncp –r aaa/*  ccc  \r\n```\r\n\r\n执行效果如下\r\n\r\n我们将aaa下面的所有文件、目录复制到了目录c下面\r\n\r\n![1576562978352](./img/linux/java-linux/Linux-v10-01天-授课/1576562978352.png)\r\n\r\n> 总结：\r\n>\r\n> 用户使用该指令复制目录时，必须使用参数"-r"或者"-R"。\r\n>\r\n> 如果不加参数"-r"或者"-R",只复制文件，而略过目录\r\n\r\n#### 7) rm(删除目录)\r\n\r\n```\r\nLinux的rm命令相当于我们在Windows中通过鼠标或者快捷键删除文件或者目录\r\n```\r\n\r\nrm命令用于删除一个文件或者目录。\r\n\r\n使用权限：于目前目录有适当权限的所有使用者\r\n\r\n**语法**\r\n\r\n```shell\r\nrm [options] name...\r\n```\r\n\r\n**参数：**\r\n\r\n- -i 删除前逐一询问确认。\r\n- -f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。\r\n- -r 将目录及以下之档案亦逐一删除。\r\n\r\n如果我们要删除文件可以直接使用rm命令，若删除目录则必须配合选项"-r"，例如：\r\n\r\n![1576563524635](./img/linux/java-linux/Linux-v10-01天-授课/1576563524635.png)\r\n\r\n```shell\r\nrm -r  ccc\r\n```\r\n\r\n执行删除，如下图\r\n\r\n![1576563827977](./img/linux/java-linux/Linux-v10-01天-授课/1576563827977.png)\r\n\r\n> 注意\r\n>\r\n> 文件一旦通过rm命令删除，则无法恢复，所以必须格外小心地使用该命令\r\n>\r\n> 如果删除文件（比如.sh 、.txt）\r\n>\r\n> 直接使用rm  name.txt\r\n\r\n#### 8) mv(移动文件)\r\n\r\n```\r\nLinux的mv命令相当于我们在Windows中通过鼠标或者快捷键剪切（+重命名）+粘贴文件或者目录\r\n```\r\n\r\nmv 命令用来为文件或目录改名、或将文件或目录移入其它位置\r\n\r\n**语法**\r\n\r\n```shell\r\nmv [options] source dest\r\nmv [options] source... directory\r\n```\r\n\r\n**参数说明：**\r\n\r\n- -i: 若指定目录已有同名文件，则先询问是否覆盖旧文件;\r\n- -f: 在 mv 操作要覆盖某已有的目标文件时不给任何指示;\r\n\r\n![1576565378463](./img/linux/java-linux/Linux-v10-01天-授课/1576565378463.png)\r\n\r\n将文件 aaa 更名为 bbb :\r\n\r\n![1576565459075](./img/linux/java-linux/Linux-v10-01天-授课/1576565459075.png)\r\n\r\n```shell\r\n1、创建aaa目录、\r\nmkdir  aaa\r\n2、开始重命名\r\nmv aaa bbb\r\n```\r\n\r\n执行后\r\n\r\n![1576565489569](./img/linux/java-linux/Linux-v10-01天-授课/1576565489569.png)\r\n\r\n将ccc目录放入ddd目录中。\r\n\r\n注意，如果ddd目录不存在，则该命令将ccc改名为ddd。\r\n\r\n```shell\r\n创建ccc\r\nmkdir ccc\r\n```\r\n\r\n![1576565710078](./img/linux/java-linux/Linux-v10-01天-授课/1576565710078.png)\r\n\r\n```shell\r\n开始移动\r\nmv ccc/ ddd \r\n```\r\n\r\n![1576565800010](./img/linux/java-linux/Linux-v10-01天-授课/1576565800010.png)\r\n\r\n由上图我们发现，由于ddd目录不存在，所以在mv的时候将ccc目录改名为了ddd。\r\n\r\n## 3.2 Linux 文件基本属性\r\n\r\n```\r\n在Wndows系统中，我们可以选中一个文件，右键属性，可以查看到这个文件的文件类型（基本信息），以及文件的权限信息，在Linux中，它是通过不同字符的排序顺序来表示文件的类型以及权限所属信息的。\r\n```\r\n\r\nLinux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。\r\n\r\n下面我们就一起学习下Linux系统不同权限的文件和目录在怎么表示的\r\n\r\n在Linux中我们可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组，如：\r\n\r\n```shell\r\nls -l\r\n```\r\n\r\n![1576032746450](./img/linux/java-linux/Linux-v10-01天-授课/1576032746450.png)\r\n\r\n实例中，bin文件的第一个属性用"d"表示。"d"在Linux中代表该文件是一个目录文件。\r\n\r\n在Linux中第一个字符代表这个文件是目录、文件或链接文件等等。\r\n\r\n- 当为[ **d** ]则是目录\r\n- 当为[ **-** ]则是文件；\r\n- 若是[ **l** ]则表示为链接文档(link file)；\r\n- 若是[ **b** ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；\r\n- 若是[ **c** ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。\r\n\r\n接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。\r\n\r\n每个文件的属性由左边第一部分的10个字符来确定（如下图）。\r\n\r\n![1576460571985](./img/linux/java-linux/Linux-v10-01天-授课/1576460571985.png)\r\n\r\n从左至右用0-9这些数字来表示。\r\n\r\n第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。\r\n\r\n第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。\r\n\r\n\r\n\r\n其中，第1、4、7位表示读权限，如果用"r"字符表示，则有读权限，如果用"-"字符表示，则没有读权限；\r\n\r\n第2、5、8位表示写权限，如果用"w"字符表示，则有写权限，如果用"-"字符表示没有写权限；第3、6、9位表示可执行权限，如果用"x"字符表示，则有执行权限，如果用"-"字符表示，则没有执行权限。\r\n\r\n## 3.3 Linux文件属主和属组\r\n\r\n```\r\n引子：\r\n对于一个文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。\r\n也就是所谓的属主，它属于哪个用户的意思。\r\n除了属主，还有属组，也就是说，这个文件是属于哪个组的（用户所属的组）。\r\n文件的【属主】有一套【读写执行权限rwx】\r\n文件的【属组】有一套【读写执行权限rwx】\r\n还有它权限，下面我们在介绍\r\n```\r\n\r\n![1576402570345](./img/linux/java-linux/Linux-v10-01天-授课/1576402570345.png)\r\n\r\n在以上实例中，aaa文件是一个目录文件，属主和属组都为 itcast，属主有可读、可写、可执行的权限（rwx）；与属主同组的其他用户有可读可写和可执行的权限（rwx）；其他用户也有可读和可执行的权限（r-x）。\r\n\r\n### **3.3.1 chgrp更改属组**\r\n\r\n```\r\n实际开发中我们经常会创建新建目录和文件，一般情况下，通过命令进行新建，\r\n在创建完成后，使用不同的用户访问，可能就会出现报错，无法访问等等问题。\r\n然后经过一番这查找,发现该有的文件都在，大小写也没问题，路径也没问题\r\n其实并不是这些问题。而是权限问题导致我们无法访问！是因为一个文件默认隶属于一个属组，而使用其他用户访问这个文件肯定无法访问(因为访问用户所属的组和文件所在的不是同一个组)\r\n那么怎么可以正常访问呢？其实就是通过更改用户组（用户组、文件组）来解决这些问题\r\n```\r\n\r\nchgrp命令用于变更文件或目录的所属群组。\r\n\r\n文件或目录权限的的拥有者由所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可\r\n\r\n为了方便初学者记忆，可以将 chgrp 理解为是 "change group" 的缩写\r\n\r\n**语法如下**\r\n\r\n```\r\nchgrp [-cfhRv][--help][--version][所属群组][文件或目录...] 或 chgrp [-cfhRv][--help][--reference=<参考文件或目录>][--version][文件或目录...]\r\n```\r\n\r\n**改变文件的群组属性**\r\n\r\n我们通过root用户进入（如下图），上接上面的例子\r\n\r\n我们的aaa文件的属主和属组都属于itcast（如下图）\r\n\r\n![1576407437975](./img/linux/java-linux/Linux-v10-01天-授课/1576407437975.png)\r\n\r\n我们现在通过chgrp命令将文件aaa的属组更改成root（其他也可以）\r\n\r\n```shell\r\nchgrp -v root aaa\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576407536566](./img/linux/java-linux/Linux-v10-01天-授课/1576407536566.png)\r\n\r\n我们通过下面的命令查询文件aaa的属组是否发生了变化，执行\r\n\r\n```\r\nls -l\r\n```\r\n\r\n![1576407585301](./img/linux/java-linux/Linux-v10-01天-授课/1576407585301.png)\r\n\r\n由上图我们发现，文件aaa的属组由itcast变成了root\r\n\r\n这样的话，文件的属组就发生了变化。\r\n\r\n\r\n\r\n### 3.3.2 chown更改属主和属组**\r\n\r\n```\r\n我们为了让一些用户有权限查看某一文档，比如是一个时间表，而编写时间表的人要具有读写执行的权限(属主)\r\n我们想让一些用户知道这个时间表的内容，而不让他们修改，所以我们可以把这些用户都划到一个组（属组），然后来修改这个文件的权限，让用户组可读，这样用户组下面的每个用户都是可读的\r\n```\r\n\r\nLinux是多任务操作系统，所有的档案皆有拥有者。利用 chown 可以将档案的拥有者加以改变。一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的档案拥有者，也没有权限可以自己的档案拥有者改设为别人。只有系统管理者(root)才有这样的权限\r\n\r\n使用权限 : 管理员账户\r\n\r\n**语法如下**\r\n\r\n```\r\nchown [–R] 属主名 文件名\r\nchown [-R] 属主名：属组名 文件名\r\n```\r\n\r\n我们通过root用户进入（如下图），上接上面的例子\r\n\r\n我们的aaa文件的属主属于itcast、属组属于root\r\n\r\n我们现在通过chgrp命令将文件aaa的属主更改成root，执行\r\n\r\n```\r\n chown  root aaa\r\n```\r\n\r\n效果如下\r\n\r\n![1576407880885](./img/linux/java-linux/Linux-v10-01天-授课/1576407880885.png)\r\n\r\n我们通过下面的命令查询文件aaa的属主是否发生了变化，执行\r\n\r\n```\r\nls -l\r\n```\r\n\r\n![1576407928200](./img/linux/java-linux/Linux-v10-01天-授课/1576407928200.png)\r\n\r\n由上图我们发现，文件aaa的属主和属组都变成了root。\r\n\r\n**我们将aaa文件的拥有者与群组改回为itcast：**\r\n\r\n注意：chown命令可以更改属主和属组\r\n\r\n```\r\nchown itcast:itcast aaa\r\n```\r\n\r\n我们通过下面的命令查询文件aaa的属主是否发生了变化，执行\r\n\r\n```\r\nls -l\r\n```\r\n\r\n![1576408146911](./img/linux/java-linux/Linux-v10-01天-授课/1576408146911.png)\r\n\r\n由上图可知，aaa文件的属主和属组都被更改回来了。\r\n\r\n### 3.3.3 chmod权限命令\r\n\r\nLinux文件属性有两种设置方法，一种是数字，一种是符号\r\n\r\nLinux的文件调用权限分为三级 : 文件属主、属组、其他。利用 chmod 可以控制文件如何被他人所调用。\r\n\r\n**使用权限 : 所有使用者**\r\n\r\n**语法**\r\n\r\n```\r\nchmod [-cfvR] [--help] [--version] mode file...\r\n```\r\n\r\n**参数说明**\r\n\r\n\r\nmode : 权限设定字串，格式如下\r\n\r\n```\r\n[ugoa...][[+-=][rwxX]...][,...]\r\n```\r\n\r\n**解释：**\r\n\r\nu 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。\r\n\r\n+表示增加权限、- 表示取消权限、= 表示唯一设定权限。\r\nr 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。\r\n\r\n#### **1) 数字权限**\r\n\r\nLinux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。\r\n\r\n先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组（owner/group/others就是所说的三个一组 ）的，我们也可以使用数字来代表各个权限，各权限的分数对照表如下\r\n\r\n各权限的数字对照表：[r]:4;[w]:2;[x]:1;[-]:**0**\r\n\r\n![1576571902684](./img/linux/java-linux/Linux-v10-01天-授课/1576571902684.png)\r\n\r\n每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx---] 分数则是：\r\n\r\n- owner = rwx = 4+2+1 = 7\r\n- group = rwx = 4+2+1 = 7\r\n- others= --- = 0+0+0 = 0\r\n\r\n所以等一下我们设定权限的变更时，该文件的权限数字就是770啦,变更权限的指令chmod的语法是这样的\r\n\r\n```\r\nchmod [-R] xyz 文件或目录\r\n```\r\n\r\n选项与参数：\r\n\r\n- xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。\r\n- -R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更\r\n\r\n上面的 可以表示如下\r\n\r\n```shell\r\nchmod  -R 770     档案或目录\r\n```\r\n\r\n> 上面说了这么多，我们举例说明一下：\r\n\r\n我们进入itcast用户创建文件czbk.txt\r\n\r\n```shell\r\ntouch as.txt\r\n```\r\n\r\n然后切换到root\r\n\r\n比如，我们如果要将as.txt这个文件所有的权限都设定启用\r\n\r\n![1576463267777](./img/linux/java-linux/Linux-v10-01天-授课/1576463267777.png)\r\n\r\n那么命令如下：\r\n\r\n```shell\r\nchmod -R 777 as.txt\r\n```\r\n\r\n![1576463303277](./img/linux/java-linux/Linux-v10-01天-授课/1576463303277.png)\r\n\r\n由此可见，as.txt的属主权限、属组权限、其他权限都发生了改变\r\n\r\n由之前的【-rw-rw-r--】变成【-rwxrwxrwx】\r\n\r\n> 根据前面的换算我们已经知道如何将一个文件的属主、属组、其他权限换算成数字了，换算成数字后，我们只需要通过chmod命令即可更改文件的权限\r\n\r\n#### **2) 符号权限**\r\n\r\n还有一个改变权限的方法，就是 符号权限，我们先回顾下之前提到的9个权限\r\n\r\n- (1)user     属主权限\r\n- (2)group  属组权限\r\n- (3)others  其他权限\r\n\r\n那么我们就可以使用 **u, g, o** 来代表三种身份的权限！\r\n\r\n此外， **a** 则代表 **all**，即全部的身份。读写的权限可以写成 **r, w, x**，也就是可以使用下表的方式来看\r\n\r\n![1576464280724](./img/linux/java-linux/Linux-v10-01天-授课/1576464280724.png)\r\n\r\n如果我们需要将文件权限设置为 **-rwxr-xr--** ，可以使用 **chmod u=rwx,g=rx,o=r 文件名** 来设定:\r\n\r\n上接上面的例子，如下图\r\n\r\n我们将as.txt的权限设置为**-rwxr-xr--**\r\n\r\n![1576464462903](./img/linux/java-linux/Linux-v10-01天-授课/1576464462903.png)\r\n\r\n执行\r\n\r\n```shell\r\nchmod u=rwx,g=rx,o=r  as.txt\r\n```\r\n\r\n![1576464626496](./img/linux/java-linux/Linux-v10-01天-授课/1576464626496.png)\r\n\r\n 由上图我们发现，as.txt的权限变成了-rwxr-xr--\r\n\r\n假如我们要将权限去掉而不改变其他已存在的权限呢？举个例子，比如我要拿掉全部人的可读权限，则\r\n\r\n```SHELL\r\n chmod  a-r as.txt\r\n```\r\n\r\n执行如下\r\n\r\n![1576464852969](./img/linux/java-linux/Linux-v10-01天-授课/1576464852969.png)\r\n\r\n由此可见，as.txt的其他权限都没有了，变成了【---】\r\n\r\n## 3.4 综合案例\r\n\r\n```\r\n在前面的章节中我们讲解了用户、用户组、文件属主、属组以及权限，知识点比较零散，下面，我们就通过一个简单小案例把这些知识点串联起来\r\n```\r\n\r\n**需求：**\r\n\r\n比如一个公司的开发团队有三个用户：java、erlang、golang有一个文件目录tmp/work供他们开发，如何实现让这三个用户都对其具有写权限\r\n\r\n**1、首先，我们创建三个账户**（切换到root）\r\n\r\n```shell\r\nadduser java\r\nadduser erlang\r\nadduser golang\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576587867858](./img/linux/java-linux/Linux-v10-01天-授课/1576587867858.png)\r\n\r\n**2、增加用户组**\r\n\r\n```shell\r\ngroupadd -g 8888 dev-group\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576588353612](./img/linux/java-linux/Linux-v10-01天-授课/1576588353612.png)\r\n\r\n**3、创建公共文件并设置权限**\r\n\r\n给文件/tmp/project2019/设置属组为dev-group\r\n\r\n```shell\r\n mkdir /tmp/project2019\r\n \r\n chown -R :dev-group /tmp/project2019/\r\n 或者\r\n chgrp -R dev-group  /tmp/project2019/\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576588480909](./img/linux/java-linux/Linux-v10-01天-授课/1576588480909.png)\r\n\r\n**4、将用户添加到组**\r\n\r\n```shell\r\ngpasswd -a java    dev-group\r\ngpasswd -a erlang  dev-group\r\ngpasswd -a golang  dev-group\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576588553969](./img/linux/java-linux/Linux-v10-01天-授课/1576588553969.png)\r\n\r\n查询dev-group组下所有用户\r\n\r\n```shell\r\n grep \'dev-group\' /etc/group\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576588591503](./img/linux/java-linux/Linux-v10-01天-授课/1576588591503.png)\r\n\r\n**5、切换到java用户**\r\n\r\n切换到java用户看看是否有写入权限\r\n\r\n```shell\r\nsu java\r\n```\r\n\r\n![1576588731114](./img/linux/java-linux/Linux-v10-01天-授课/1576588731114.png)\r\n\r\n新建文件\r\n\r\n在我们上面创建的目录tmp/project2019/下面创建文件\r\n\r\n```shell\r\nmkdir java-files-new\r\n```\r\n\r\n![1576588941546](./img/linux/java-linux/Linux-v10-01天-授课/1576588941546.png)\r\n\r\n由此发现，我们在tmp/project2019/下面创建文件发生了权限不足，我们去查看下tmp/project2019/的文件属性，如下图\r\n\r\n我们在/tmp目录下执行\r\n\r\n```\r\nls -l\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576589157095](./img/linux/java-linux/Linux-v10-01天-授课/1576589157095.png)\r\n\r\n 我们发现目录project2019的文件属性为【drwxr-xr-x】\r\n\r\n根据前面学的知识，我们拆分如下\r\n\r\n【d】:文件类型\r\n\r\n【rwx】：属主\r\n\r\n【r-x】：属组\r\n\r\n【r-x】：其他\r\n\r\n现在答案就出来了，也就是说我们的属组权限是【r-x】，只有读和执行权限，没有写入权限，那么下面我们就给project2019目录增加写入权限。\r\n\r\n**6、增加写入权限**\r\n\r\n给project2019目录增加写入权限，执行下面的命令（前面已经学习过了）\r\n\r\n记得切换到root下执行\r\n\r\n```shell\r\nchmod  -R 770  project2019\r\n```\r\n\r\n执行效果如下![1576589467908](./img/linux/java-linux/Linux-v10-01天-授课/1576589467908.png)\r\n\r\n此时我们发现project2019目录的属组权限变成了【rwx】即可读、可写、可执行\r\n\r\n**7、切换用户，继续写入**\r\n\r\n```shell\r\nsu  java\r\nmkdir java-files-new\r\nls -l\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576589641341](./img/linux/java-linux/Linux-v10-01天-授课/1576589641341.png)\r\n\r\n由此发现，这个时候我们有了写入权限，java-files-new文件被成功写入\r\n\r\n那么，其他两个用户golang、erlang也是和java一个组的，他们能不能正常写入呢，我们试试（从root切换过去）\r\n\r\n```shell\r\nsu\r\nsu erlang\r\nmkdir erlang-files-new\r\n==============================\r\nsu\r\nsu golang\r\nmkdir golang-files-new\r\n\r\nls -l\r\n```\r\n\r\n执行效果（erlang新建文件）\r\n\r\n![1576589820604](./img/linux/java-linux/Linux-v10-01天-授课/1576589820604.png)\r\n\r\n执行效果（golanglang新建文件）\r\n\r\n![1576589856968](./img/linux/java-linux/Linux-v10-01天-授课/1576589856968.png)\r\n\r\n查看所有文件\r\n\r\n![1576589903617](./img/linux/java-linux/Linux-v10-01天-授课/1576589903617.png)\r\n\r\n由此可见，我们组的三个用户都成功创建了文件（拥有了写入权限）\r\n\r\n**8、验证结论**\r\n\r\n为了验证上面的结论，我们新增一个用户itbeijing\r\n\r\n看看能否正常新建文件\r\n\r\n```shell\r\nuseradd   itbeijing\r\nsu itbeijing\r\nmkdir  itbeijing-files-new\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576590031376](./img/linux/java-linux/Linux-v10-01天-授课/1576590031376.png)\r\n\r\n由上图我们发现，我们刚刚新创建的用户在创建文件的时候发现了权限不足。\r\n\r\n由此说明用户itbeijing用户的属组和文件的属组不一样，所以没有权限。\r\n\r\n## 3.5 总结\r\n\r\n在企业级开发过程中，实际操作目录是最经常出现的，对于目录常用命令我们要熟练掌握并能熟练编写\r\n因为Linux是多用户系统，所以权限也是非常核心和重要的，我们要熟练编写权限（属主、属组、其他权限）的常用命令。',Zn={data:function(){return{MainComponent:Xn}}},Jn=Zn,nr=Object(p["a"])(Jn,Yn,Vn,!1,null,"f4fc4986",null),rr=nr.exports,er=function(){var n=this,r=n.$createElement,e=n._self._c||r;return e("div",{},[e("q-markdown",{attrs:{src:n.MainComponent}})],1)},tr=[],ir='# Linux-v10.0-02天-课堂笔记\r\n\r\n学习目标\r\n\r\n- 能够熟练编写文件相关命令\r\n- 能够熟练编写文件解压缩命令\r\n- 能够熟练编写网络查看简单命令\r\n- 能够熟练编写查看磁盘命令、挂载命令\r\n- 能够知道如何使用命令进行分区、格式化\r\n- 能够熟练使用yum进行查找、安装、卸载软件\r\n- 能够熟练使用rpm进行查找、安装、卸载软件\r\n- 能够熟练编写常用的shell脚本\r\n\r\n#  1 Linux文件管理\r\n\r\n## 1.1 touch命令\r\n\r\n```\r\n在Windows系统中，我们如果想创建一个文本文档或者word文件的时候，通常的做法是\r\n鼠标右键---新建---文本文档，这样的话，我们就成功的创建了一个文件，而在Linux中，我们可以通过字符命令的形式进行创建\r\n```\r\n\r\ntouch命令用于创建文件、修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。\r\n\r\nls -l 可以显示档案的时间记录\r\n\r\n**使用者权限：所有权限用户**\r\n\r\n**语法**\r\n\r\n```\r\ntouch [-acfm][-d<日期时间>][-r<参考文件或目录>] [-t<日期时间>][--help][--version][文件或目录…]\r\n```\r\n\r\n- **参数说明**：\r\n- a 改变档案的读取时间记录。\r\n- m 改变档案的修改时间记录。\r\n- c 假如目的档案不存在，不会建立新的档案。与 --no-create 的效果一样。\r\n- f 不使用，是为了与其他 unix 系统的相容性而保留。\r\n- r 使用参考档的时间记录，与 --file 的效果一样。\r\n- d 设定时间与日期，可以使用各种不同的格式。\r\n- t 设定档案的时间记录，格式与 date 指令相同。\r\n- --no-create 不会建立新档案。\r\n- --help 列出指令格式。\r\n- --version 列出版本讯息。\r\n\r\n**使用 touch 创建一个空文件**\r\n\r\n在 Linux 系统上使用 `touch` 命令创建空文件，键入 `touch`，然后输入文件名。如下所示\r\n\r\n```shell\r\ntouch czbk-devops.txt\r\n```\r\n\r\n查看\r\n\r\n```shell\r\nls -l czbk-devops.txt\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576640085716](./img/linux/java-linux/Linux-v10-02天-授课/1576640085716.png)\r\n\r\n**使用 touch 创建批量空文件**\r\n\r\n在实际的开发过程中可能会出现一些情况，我们必须为某些测试创建大量空文件，这可以使用 `touch` 命令轻松实现\r\n\r\n```shell\r\ntouch czbk-{1..10}.txt\r\n```\r\n\r\n在上面的例子中，我们创建了 10 个名为 czbk-1.txt` 到 `czbk-10.txt` 的空文件，你可以根据需要更改名称和数字\r\n\r\n执行查看命令\r\n\r\n```shell\r\nls -l\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576640392259](./img/linux/java-linux/Linux-v10-02天-授课/1576640392259.png)\r\n\r\n由上图我们发现，我们通过批量命令创建了10个txt文件\r\n\r\n**改变/更新文件访问时间**\r\n\r\n假设我们想要改变名为 czbk-devops.txt 文件的访问时间，在 `touch` 命令中使用 `-a` 选项，然后输入文件名。如下所示：\r\n\r\n1、我们先 查看下czbk-devops.txt的时间属性\r\n\r\n```shell\r\nls -l czbk-devops.txt \r\n```\r\n\r\n执行效果如下\r\n\r\n![1576648168657](./img/linux/java-linux/Linux-v10-02天-授课/1576648168657.png)\r\n\r\n我们发现，最后的访问时间是12月 18 11:34\r\n\r\n更新时间属性，如下\r\n\r\n```shell\r\ntouch czbk-devops.txt \r\n```\r\n\r\n执行ls命令查看，如下\r\n\r\n```shell\r\nls -l czbk-devops.txt \r\n```\r\n\r\n![1576648319770](./img/linux/java-linux/Linux-v10-02天-授课/1576648319770.png)\r\n\r\n我们发现，访问时间变成了 12月 18 13:50\r\n\r\n我们也可以使用stat命令进行查看，如下：\r\n\r\n```shell\r\nstat czbk-devops.txt \r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576648420787](./img/linux/java-linux/Linux-v10-02天-授课/1576648420787.png)\r\n\r\n由上图可知：czbk-devops.txt的文件属性、包含访问时间、更改时间、最近改动时间都显示出来了。\r\n\r\n **关于stat命令：**\r\n\r\n**stat命令用于显示inode内容。**\r\n\r\nstat以文字的格式来显示inode的内容。\r\n\r\n**语法**\r\n\r\n```\r\nstat [文件或目录]\r\n```\r\n\r\n## 1.2 vi与vim命令\r\n\r\n### 1.2.1 vi/vim介绍\r\n\r\n```\r\n使用vi/vim其实就相当于我们在Windows系统中创建文件、打开文件、编辑文件、保存文件操作\r\n```\r\n\r\n**1、vi介绍**\r\n\r\nvi是 `visual interface`的简称, 是linux中**最经典**的文本编辑器。\r\n\r\n- vi的特点\r\n  - 只能是编辑 **文本内容**, 不能对 字体 段落进行排版\r\n  - **不支持鼠标操作**\r\n  - **没有菜单**\r\n  - **只有命令**\r\n- vi编辑器在 **系统管理 服务器管理** 编辑文件时, **其功能永远不是图形界面的编辑器能比拟的**\r\n\r\n**2、vim介绍**\r\n\r\n**vim**:是从 vi （系统内置命令）发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。\r\n\r\n简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 \r\n\r\nvim 则可以说是程序开发者的一项很好用的工具。\r\n\r\n### 1.2.2 vi/vim模式\r\n\r\nvi/vim模式主要分为以下三种：\r\n\r\n**命令模式**：在Linux终端中输入“vim 文件名”就进入了命令模式,但不能输入文字。\r\n**编辑模式：**在命令模式下按i就会进入编辑模式，此时就可以写入程式，按Esc可回到命令模式。\r\n**末行模式：**在命令模式下按：进入末行模式，左下角会有一个冒号出现，此时可以敲入命令并执行。\r\n\r\n下面是三种模式的简单分析图：\r\n\r\n![1576653460302](./img/linux/java-linux/Linux-v10-02天-授课/1576653460302.png)\r\n\r\n> 上图总结\r\n>\r\n> 上面的三种模式简单总结下就是：\r\n>\r\n> 1、vim  开始进入时是命令模式\r\n>\r\n> 2、按下I的时候会进入编辑模式\r\n>\r\n> 3、按下ESC然后在按下：的时候是末行模式\r\n\r\n\r\n\r\n###  1.2.3 打开和新建文件\r\n\r\n```\r\n使用vim不但可以打开一个现存的文件；也可以生成（vim后的文件不存在的情况下）一个文件；有点类似于我们在Windows中输入notepad命令一样，我们输入notepad后就会打开一个文本文档，然后进行编辑--另存为。\r\n```\r\n\r\n**使用者权限：当前文件的权限用户**\r\n\r\n- 在终端中输入vim在后面跟上 文件名 即可\r\n\r\n```\r\nvim txtfile.txt\r\n```\r\n\r\n- 如果文件已经存在, 会直接打开该文件\r\n- 如果文件不存在, 保存且退出时 就会新建一个文件\r\n\r\n> 注意\r\n>\r\n> 我们通过下面的三种模式切换详细阐述vim的用法\r\n\r\n###  1.2.4 三种模式切换\r\n\r\n**1、进入命令模式**\r\n\r\n上接上面的例子，我们执行下面的命令其实就是进入了命令模式\r\n\r\n```shell\r\nvim txtfile.txt\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576655123201](./img/linux/java-linux/Linux-v10-02天-授课/1576655123201.png)\r\n\r\n**2、进入编辑模式**\r\n\r\n上接上面的例子，按i进入插入模式\r\n\r\n- 在 vi 中除了常用 `i` 进入**编辑模式** 外, 还提供了一下命令同样可以进入编辑模式\r\n\r\n| 命令 | 英文   | 功能                   | 常用   |\r\n| ---- | ------ | ---------------------- | ------ |\r\n| i    | insert | 在当前字符前插入文本   | 常用   |\r\n| I    | insert | 在行首插入文本         | 较常用 |\r\n| a    | append | 在当前字符后添加文本   |        |\r\n| A    | append | 在行末添加文本         | 较常用 |\r\n| o    |        | 在当前行后面插入一空行 | 常用   |\r\n| O    |        | 在当前行前面插入一空行 | 常用   |\r\n\r\n上图可以表现为以下形式，如下图\r\n\r\n![1576663442969](./img/linux/java-linux/Linux-v10-02天-授课/1576663442969.png)\r\n\r\n执行效果如下图\r\n\r\n![1576655181144](./img/linux/java-linux/Linux-v10-02天-授课/1576655181144.png)\r\n\r\n由上图左下角我们看到【插入】（英文版为INSERT）,说明我们进入了编辑模式\r\n\r\n我们在里面插入数据，如下图\r\n\r\n因为我们是一个空文件，所以使用【I】或者【i】都可以\r\n\r\n如果里面的文本很多，要使用【A】进入编辑模式，即在行末添加文本\r\n\r\n![1576655270283](./img/linux/java-linux/Linux-v10-02天-授课/1576655270283.png)\r\n\r\n**3、进入末行模式**\r\n\r\n编辑模式不能保存文件\r\n必须先推到命令模式\r\n先按Esc键退出到命令模式\r\n然后按小写的**:wq 正常保存退出**\r\n\r\n进入末行模式—》按符号： 鼠标跑到屏幕的最后一行，执行效果如下图\r\n\r\n![1576655879564](./img/linux/java-linux/Linux-v10-02天-授课/1576655879564.png)\r\n\r\n然后按小写的**:wq 正常保存退出**\r\n\r\n![1576655592207](./img/linux/java-linux/Linux-v10-02天-授课/1576655592207.png)\r\n\r\n退出后显示【已写入】\r\n\r\n**以下为其他的退出模式：**\r\n\r\n:q            当vim进入文件没有对文件内容做任何操作可以按"q"退出\r\n\r\n:q!           当vim进入文件对文件内容有操作但不想保存退出\r\n\r\n:wq          正常保存退出\r\n\r\n:wq!         强行保存退出，只针对与root用户或文件所有人生\r\n\r\n> 总结\r\n>\r\n> 三种模式的切换，其实就完成了文件创建、编辑、保存、退出四个步骤\r\n>\r\n> 那么接下来，我们学习下一个命令\r\n>\r\n> 查看刚才新创建的文件\r\n\r\n### 1.2.5 文件查看\r\n\r\n```\r\n比如查看一个txt文档，在windows中，我们通常是打开一个文件，通过鼠标滚动查看文件不同节选的内容，而在Linux中，通过下面的命令，可以减少在Windows中手工查找的步骤，在Linux中通过命令+参数的形式进行定位查看、搜索查看\r\n```\r\n\r\n以下5个为文件查看命令，**我们只讲4个常用的命令，head不在赘述**\r\n\r\n| 序号 | 命令               | 对应英文    | 作用                             |\r\n| ---- | ------------------ | ----------- | -------------------------------- |\r\n| 01   | cat 文件名         | concatenate | 查看小文件内容                   |\r\n| 02   | less -N 文件名     | less        | **分频** 显示大文件内容          |\r\n| 03   | head -n 文件名     |             | 查看文件的**前一**部分           |\r\n| 04   | tail -n 文件名     |             | 查看文件的**最后**部分           |\r\n| 05   | grep 关键字 文件名 | grep        | 根据**关键词**, 搜索文本文件内容 |\r\n\r\n> 总结：\r\n>\r\n> 以上5个命令都可以查询文件的内容，他们的功能如下\r\n>\r\n> 通过 `cat` 会一次显示所有的内容, 适合 **查看内容较少** 的文本文件\r\n>\r\n> `less` 命令适合查看 **内容较多** 的文本文件\r\n>\r\n> 通过 `head` 命令查看文档的前几行内容\r\n>\r\n> 通过 `tail -10f 文件` 命令 查看文档(日志)的后几行内容\r\n>\r\n> 通过 `grep` 命令 搜索存在 **关键字** 的行\r\n\r\n#### **1) cat命令**\r\n\r\n```\r\n使用cat命令类似于我们在Windows中查看小型（太大的时候打开会卡死）的文件，cat常用的功能其实就等价于Windows中的\r\ntxt---打开--查看\r\n```\r\n\r\ncat 是一个文本文件查看和连接工具。查看一个文件的内容，用cat比较简单，就是cat 后面直接接文件名，如cat txtFiles.txt\r\n\r\n**使用者权限：当前文件的权限用户**\r\n\r\n**语法格式**\r\n\r\n```\r\ncat [-AbeEnstTuv] [--help] [--version] fileName\r\n```\r\n\r\n**查看文件名为txtfile.txt的内容**\r\n\r\n```shell\r\ncat txtfile.txt\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576657358085](./img/linux/java-linux/Linux-v10-02天-授课/1576657358085.png)\r\n\r\n**查看文件名为txtfile.txt的内容（加入行号）**\r\n\r\n```shell\r\ncat -n txtfile.txt\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576657409815](./img/linux/java-linux/Linux-v10-02天-授课/1576657409815.png)\r\n\r\n#### 2) grep命令\r\n\r\n```\r\ngrep命令在使用的时候类似于我们的程序中的查询，或者在txt文档中通过ctr+f查找\r\ngrep除了能对文件操作为还可以查看我们的进程信息，类似于我们在Windows系统的任务管理器（任务栏--右键---启动任务管理器--进程）下的进程\r\n```\r\n\r\ngrep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据。\r\n\r\ngrep 命令用于查找文件里符合条件的字符串，语法如下：\r\n\r\n```\r\ngrep [-abcEFGhHilLnqrsvVwxy][-A<显示列数>][-B<显示列数>][-C<显示列数>][-d<进行动作>][-e<范本样式>][-f<范本文件>][--help][范本样式][文件或目录...]\r\n```\r\n\r\n**使用者权限：当前文件的权限用户**\r\n\r\n我们还是使用上面的txtfile.txt文件，如下图\r\n\r\n![1576664862829](./img/linux/java-linux/Linux-v10-02天-授课/1576664862829.png)\r\n\r\n> 为了测试效果，我们新增了其他数据\r\n>\r\n> 增加过程不在赘述\r\n\r\n1、搜索 **存在关键字【eeee】** 的行的文件\r\n\r\n```shell\r\ngrep eeee txtfile.txt \r\n```\r\n\r\n执行效果如下\r\n\r\n![1576664910366](./img/linux/java-linux/Linux-v10-02天-授课/1576664910366.png)\r\n\r\n2、搜索 **存在关键字【eeee】** 的行 且 **显示行号**\r\n\r\n```shell\r\ngrep -n eeee txtfile.txt \r\n```\r\n\r\n![1576665113269](./img/linux/java-linux/Linux-v10-02天-授课/1576665113269.png)\r\n\r\n3、**忽略大小写** 搜索 **存在关键字** 的行\r\n\r\n```shell\r\ngrep -i EEEE txtfile.txt \r\n```\r\n\r\n执行效果如下\r\n\r\n![1576666861596](./img/linux/java-linux/Linux-v10-02天-授课/1576666861596.png)\r\n\r\n4、搜索 **不存在关键字** 的行\r\n\r\n```shell\r\ngrep -v 中国 txtfile.txt \r\n```\r\n\r\n执行效果如下\r\n\r\n![1576666928266](./img/linux/java-linux/Linux-v10-02天-授课/1576666928266.png)\r\n\r\n**5、查找指定的进程信息（包含grep进程）**\r\n\r\n```shell\r\nps -ef | grep  sshd\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577095621215](./img/linux/java-linux/Linux-v10-02天-授课/1577095621215.png)\r\n\r\n> 说明\r\n>\r\n> 除最后一条记录外，其他的都是查找出的进程；最后一条记录结果是grep进程本身，并非真正要找的进程\r\n\r\n**6、查找指定的进程信息（不包含grep进程）**\r\n\r\n```shell\r\nps aux | grep sshd | grep -v "grep"\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577095998308](./img/linux/java-linux/Linux-v10-02天-授课/1577095998308.png)\r\n\r\n**7、查找进程个数**\r\n\r\n```shell\r\n ps -ef|grep -c sshd\r\n```\r\n\r\n 执行效果如下\r\n\r\n![1577096070670](./img/linux/java-linux/Linux-v10-02天-授课/1577096070670.png)\r\n\r\n由上图可知sshd的进程个数为4（包含grep进程本身）\r\n\r\n#### 3) tail命令\r\n\r\n```\r\ntail命令类似于我们在windows中通过鼠标手工查找，比如查看文件最后10行，从第2行一直查看到文件末尾，或者只查看文件末尾的一些信息，这些windows中都是通过人为干预的方式进行查找，在Linux中我们可以通过tail命令实现\r\n```\r\n\r\ntail 命令可用于查看文件的内容，有一个常用的参数 **-f** 常用于查阅正在改变的日志文件。\r\n\r\n**tail -f filename** 会把 filename 文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。\r\n\r\n**使用者权限：当前文件的权限用户**\r\n\r\n**命令格式：**\r\n\r\n```shell\r\ntail [参数] [文件]  \r\n```\r\n\r\n**1、要显示 txtfile.txt  文件的最后 3 行，请输入以下命令：**\r\n\r\n```shell\r\ntail -3 txtfile.txt \r\n```\r\n\r\n原始文件内容如下\r\n\r\n![1576667678964](./img/linux/java-linux/Linux-v10-02天-授课/1576667678964.png)\r\n\r\n最后3行内容如下\r\n\r\n![1576667701796](./img/linux/java-linux/Linux-v10-02天-授课/1576667701796.png)\r\n\r\n**2、动态显示文档的最后内容,一般用来查看日志，请输入以下命令：**\r\n\r\n```shell\r\ntail -f txtfile.txt\r\n```\r\n\r\n执行效果如下：\r\n\r\n![1576667811261](./img/linux/java-linux/Linux-v10-02天-授课/1576667811261.png)\r\n\r\n此命令显示 txtfile.txt 文件的最后 10 行。当将某些行添加至 txtfile.txt 文件时，tail 命令会继续显示这些行。 显示一直继续，直到您按下（Ctrl-C）组合键停止显示。\r\n\r\n如果要显示最后4行，命令如下：\r\n\r\n```shell\r\ntail -4f txtfile.txt\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576719306123](./img/linux/java-linux/Linux-v10-02天-授课/1576719306123.png)\r\n\r\n**3、显示文件txtfile.txt 的内容，从第 2 行至文件末尾**\r\n\r\n```shell\r\ntail  -n +2  txtfile.txt\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576719057889](./img/linux/java-linux/Linux-v10-02天-授课/1576719057889.png)\r\n\r\n**4、显示文件 txtfile.txt的最后 10 个字符:**\r\n\r\n```shell\r\ntail -c 45 txtfile.txt\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576719098586](./img/linux/java-linux/Linux-v10-02天-授课/1576719098586.png)\r\n\r\n> 总结\r\n>\r\n> 在tail使用的过程中，我们使用最多的就是查看文件末尾多多少行\r\n>\r\n> 使用tail -nf txtfile.txt\r\n>\r\n> 通常都是在查看日志信息（报错调试时使用）\r\n\r\n#### 4）less命令\r\n\r\n```\r\nless命令也是查看文件的，只不过它适合查看 内容较多的文本文件，它也可以用于分屏显示文件内容,  每次只显示一页内容，有点类似我们做分页查询\r\n```\r\n\r\nless用于查看文件，但是less 在查看之前不会加载整个文件。\r\n\r\n**使用者权限：当前文件的权限用户**\r\n\r\n**语法**\r\n\r\n```shell\r\nless [参数] 文件 \r\n```\r\n\r\n1、查看txtfile.txt文件\r\n\r\n```shell\r\nless txtfile.txt\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576720622842](./img/linux/java-linux/Linux-v10-02天-授课/1576720622842.png)\r\n\r\n2、查看命令历史使用记录并通过less分页显示\r\n\r\n```shell\r\n[itcast@localhost ~]$  history | less\r\n    1  ifconfig\r\n    2  reboot\r\n    3  ifconfig\r\n    4  reboot\r\n    5  ifconfig\r\n    6  su root\r\n    7  ifconfig\r\n    8  ping  www.baidu.com\r\n    9  \\\r\n   10  ifconfig\r\n   11  date\r\n   12  hwclock --systohc\r\n   13  su root\r\n   \r\n   ......略\r\n```\r\n\r\n我们输入【j】可以前进行\r\n\r\n​        输入【k】可以后退行\r\n\r\n​        输入【G】可以 移动到最后一行\r\n\r\n​\t    输入【g】可以移动到第一行\r\n\r\n​        输入【ctrl + F】 向前移动一屏(类似于我们在浏览器中的数据分页的下一页)\r\n\r\n​        输入【ctrl + B】 向后移动一屏(类似于我们在浏览器中的数据分页的上一页)\r\n\r\n**其他命令**\r\n\r\n1.全屏导航\r\n\r\n- ctrl + F - 向前移动一屏\r\n- ctrl + B - 向后移动一屏\r\n- ctrl + D - 向前移动半屏\r\n- ctrl + U - 向后移动半屏\r\n\r\n2.单行导航\r\n\r\n- j - 向前移动一行\r\n- k - 向后移动一行\r\n\r\n3.其它导航\r\n\r\n- G - 移动到最后一行\r\n- g - 移动到第一行\r\n- q / ZZ - 退出 less 命令\r\n\r\n### 1.2.6  vim定位行\r\n\r\n```\r\n在日常工作中,有可能会遇到打开一个文件,并定位到指定行的情况\r\n例如: 在开发时, 知道某一行代码有错误,可以快速定位到出错误代码的位置\r\n这个时候,可以使用以下命令打开文件\r\n```\r\n\r\n由于我们这里还没有学到上传文件的命令，所以我们这里还是使用上面的txtfile.txt例子，我们打开文件定位到第6行，如下：\r\n\r\n```shell\r\nvim txtfile.txt +6\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576659165723](./img/linux/java-linux/Linux-v10-02天-授课/1576659165723.png)\r\n\r\n### **1.2.7 异常处理**\r\n\r\n- 如果 vim异常退出, 在磁盘上可能会保存有 交换文件\r\n- 下次再使用 vim 编辑文件时, 会看到以下屏幕信息,\r\n\r\n![1576658330514](./img/linux/java-linux/Linux-v10-02天-授课/1576658330514.png)\r\n\r\n解决方案：\r\n\r\n将后缀名为.swp的文件删除即可恢复\r\n\r\n![1576658480811](./img/linux/java-linux/Linux-v10-02天-授课/1576658480811.png)\r\n\r\n再次编辑文件不在出现提示警告！\r\n\r\n\r\n\r\n### 1.2.8 操作扩展\r\n\r\n要熟练使用vi/vim, 首先应该学会怎么在 命令模式下 快速移动光标\r\n编辑操作命令 能够和移动命令一起使用\r\n\r\n**1) 上 下 左 右**\r\n\r\n![1558278451153](./img/linux/java-linux/Linux-v10-02天-授课/1558278451153.png)\r\n\r\n| 命令 | 功能 | 手指   |\r\n| ---- | ---- | ------ |\r\n| h    | 向左 | 食指   |\r\n| j    | 向下 | 食指   |\r\n| k    | 向上 | 中指   |\r\n| l    | 向右 | 无名指 |\r\n\r\n也可以使用键盘上的上下左右箭头，这个更有方向感。\r\n\r\n**2) 行内移动**\r\n\r\n| 命令 | 英文 | 功能                           |\r\n| ---- | ---- | ------------------------------ |\r\n| w    | word | 向后移动一个单词               |\r\n| b    | back | 向前移动一个单词               |\r\n| 0    |      | 行首                           |\r\n| ^    |      | 行首, 第一个不是空白字符的位置 |\r\n| $    |      | 行尾                           |\r\n\r\n**3) 行数移动**\r\n\r\n| 命令   | 英文 | 功能                  |\r\n| ------ | ---- | --------------------- |\r\n| gg     | go   | 文件顶部              |\r\n| G      | go   | 文件末尾              |\r\n| 数字gg | go   | 移动到 数字 对应行数  |\r\n| 数字G  | go   | 移动到 数字 对应行数  |\r\n| : 数字 |      | 移动到数字对应的 行数 |\r\n\r\n**4) 屏幕移动**\r\n\r\n| 命令     | 英文    | 功能     |\r\n| -------- | ------- | -------- |\r\n| Ctrl + b | back    | 向上翻页 |\r\n| Ctrl + f | forward | 向下翻页 |\r\n| H        | Head    | 屏幕顶部 |\r\n| M        | Middle  | 屏幕中间 |\r\n| L        | Low     | 屏幕底部 |\r\n\r\n**5) 选中文本(可视模式)**\r\n\r\n- 学习 复制 命令前, 应该先学会 **怎么样选中 要复制的代码**\r\n- 在 vi/vim 中要选择文本, 需要显示 visual 命令切换到 **可视模式**\r\n- vi/vim 中提供了 **三种** 可视模式, 可以方便程序员的选择 **选中文本的方式**\r\n- 按 ESC 可以放弃选中, 返回到 **命令模式**\r\n\r\n| 命令     | 模式       | 功能                               |\r\n| -------- | ---------- | ---------------------------------- |\r\n| v        | 可视模式   | 从光标位置开始按照正常模式选择文本 |\r\n| V        | 可视化模式 | 选中光标经过的完整行               |\r\n| Ctrl + v | 可是块模式 | 垂直方向选中文本                   |\r\n\r\n**6) 撤销和恢复撤销(保命指令)**\r\n\r\n在学习编辑命令之前,先要知道怎样撤销之前一次 错误的 编辑操作\r\n\r\n| 命令     | 英文  | 功能                     |\r\n| -------- | ----- | ------------------------ |\r\n| u        | undo  | 撤销上次的命令(ctrl + z) |\r\n| Ctrl + r | uredo | 恢复撤销的命令           |\r\n\r\n**7) 删除文本**\r\n\r\n| 命令        | 英文   | 功能                              |\r\n| ----------- | ------ | --------------------------------- |\r\n| x           | cut    | 删除光标所在的字符,或者选中的文字 |\r\n| d(移动命令) | delete | 删除移动命令对应的内容            |\r\n| dd          | delete | 删除光标所在行, 可以删除多行      |\r\n| D           | delete | 删除至行尾                        |\r\n\r\n提示: 如果使用 可视模式 已经选中了一段文本, 那么无论使用 d 还是 x, 都可以删除选中文本\r\n\r\n删除命令可以和移动命令连用, 以下是常见的组合命令(扩展):\r\n\r\n| 命令 | 作用                        |\r\n| ---- | --------------------------- |\r\n| dw   | 从光标位置删除到单词末尾    |\r\n| d}   | 从光标位置删除到段落末尾    |\r\n| ndd  | 从光标位置向下连续删除 n 行 |\r\n\r\n**8) 复制和剪切**\r\n\r\n- vi/vim 中提供有一个 被复制文本的缓冲区\r\n  - 复制 命令会将选中的文字保存在缓冲区\r\n  - 删除 命令删除的文字会被保存在缓冲区\r\n  - 在需要的位置, 使用 粘贴 命令可以将缓冲对的文字插入到光标所在的位置\r\n\r\n| 命令        | 英文   | 功能                       |\r\n| ----------- | ------ | -------------------------- |\r\n| yy          | copy   | 复制行                     |\r\n| d(剪切命令) | delete | 剪切                       |\r\n| dd(剪切)    | delete | 剪切一行, 可以 ndd 剪切n行 |\r\n| p           | paste  | 粘贴                       |\r\n\r\n提示:\r\n\r\n- 命令 d 、x 类似于图形界面的 **剪切操作**  -- ctrl + x\r\n- 命令 y 类似于 图形界面的 **复制操作** -- Ctrl + \r\n- 命令 p 类似于图形界面的 **粘贴操作** -- Ctrl + v\r\n- vi中的文本缓冲区只有一个,如果后续做过 复制、剪切操作, 之前缓冲区中的内容会被替换.\r\n\r\n注意\r\n\r\n- vi中的 **文本缓冲区** 和 系统的 **剪切板** 不是同一个\r\n- 所以在其他软件中使用 `Ctrl + C` 复制的内容, 不能再 `vi` 中通过 `p` 命令粘贴\r\n- 可以在 **编辑模式** 下使用 **鼠标右键粘贴**\r\n\r\n**9) 替换**\r\n\r\n| 命令 | 英文    | 功能                   | 工作模式 |\r\n| ---- | ------- | ---------------------- | -------- |\r\n| r    | replace | 替换当前字符           | 命令模式 |\r\n| R    | replace | 替换当前行光标后的字符 | 替换模式 |\r\n\r\n- `R` 命令可以进入 **替换模式**, 替换完成后, 按下`ESC` , 按下 `ESC` 可以回到 **命令模式**\r\n- **替换命令** 的作用就是不用进入 **编辑模式**, 对文件进行 **轻量级的修改**\r\n\r\n**10) 缩排和重复执行**\r\n\r\n| 命令 | 功能         |\r\n| ---- | ------------ |\r\n| >>   | 向右增加缩进 |\r\n| <<   | 向左减少缩进 |\r\n| .    | 重复上次命令 |\r\n\r\n- **缩进命令** 在开发程序时, **统一增加代码的缩进** 比较有用!\r\n  - 一次性 **在选中代码前增加 4 个空格,**  就叫做 **增加缩进**\r\n  - 一次性 **在选中代码前删除 4 个空格**,  就叫做 **较少缩进**\r\n- 在 **可视模式** 下, 缩排命令 主需要使用 一个 `>` 或者 `<`\r\n\r\n在程序中, **缩进** 通常用来表示代码的归属关系\r\n\r\n- **前面空格越少, 代码的级别越高**\r\n- **前面空格越多, 代码的级别越低**\r\n\r\n**11) 查找**\r\n\r\n常规查找\r\n\r\n| 命令 | 功能    |\r\n| ---- | ------- |\r\n| /str | 查找str |\r\n\r\n- 查找到指定内容之后, 使用 `Next` 查找下一个出现的位置\r\n  - `n` : 查找下一个\r\n  - `N` : 查找上一个\r\n- 如果不想看到高亮显示, 可以随便查找一个文件中不存在的内容即可\r\n\r\n- 单词快速匹配\r\n\r\n| 命令 | 功能                     |\r\n| ---- | ------------------------ |\r\n| *    | 向后查找当前光标所在单词 |\r\n| #    | 向前查找当前光标所在单词 |\r\n\r\n- 在开发中, 通过单词快速匹配, 可以快速看到这个单词在其他位置使用过\r\n\r\n**12) 查找并替换**\r\n\r\n- 在 `vi/vim` 中查找和替换命令需要在 **末行模式** 下执行\r\n- 记忆命令格式\r\n\r\n```\r\n:%s///g\r\n```\r\n\r\n1)  全局替换\r\n\r\n- 一次向 替换文件中的 所有出现的旧文本\r\n\r\n- 命令格式如下\r\n\r\n  ```\r\n  :%s/旧文本/新文本/g\r\n  ```\r\n\r\n2) 可视区域替换\r\n\r\n- **先选中** 要替换文字的 **范围**\r\n- 命令格式如下\r\n\r\n```\r\n:s/旧文本/新文本/g\r\n```\r\n\r\n3) 确认替换：\r\n\r\nc confirm 确认\r\n\r\n- 如果把末尾的 `g` 改成 `gc`  在替换的时候, 会有提示! 推荐使用\r\n\r\n- 命令格式如下\r\n\r\n  ```\r\n  :%s/旧文本/新文本/gc\r\n  ```\r\n\r\n1. `y` - `yes` 替换\r\n2. `n` - `no` 不替换\r\n3. `a` - `all` 替换所有\r\n4. `q` -`quit` 退出替换\r\n5. `l` - `last` 最后一个, 并把光标移动到行首\r\n6. `^E` 向下滚屏\r\n7. `^Y` 向上滚屏\r\n\r\n## 1.3 echo 命令\r\n\r\n```\r\necho命令有点类似于我们在java se阶段学习的 System.out.print("hello")\r\n但是，echo还有一个功能就是追加文件内容到文件，类似于我们在java se阶段学习的append文件流写入一样\r\n```\r\n\r\n**使用者权限：所有用户**\r\n\r\n- `echo string` 将字符串输出到控制台 ,  通常和 **重定向** 联合使用\r\n\r\n```\r\necho hello world\r\n\r\n# 如果字符串有空格, 为了避免歧义 请增加 双引号 或者 单引号\r\necho "hello world"\r\n```\r\n\r\n**6.3 重定向 `>`(覆盖) 和 `>>` (追加)** \r\n\r\n![1558435686066](./img/linux/java-linux/Linux-v10-02天-授课/1558435686066-1576721493121.png)\r\n\r\n- 默认情况下 **命令的结果** 输出到 **控制台**\r\n- 通过 **重定向** 可以将结果 **输出到文件**\r\n\r\n**6.2.3 实现**\r\n\r\n- **第一步: 将命令的成功结果 覆盖 指定文件内容**\r\n\r\n```\r\n echo  传智博客 >czbk-txt.txt\r\n```\r\n\r\n执行结果如下（czbk-txt.txt文件如果没有会自动创建）\r\n\r\n![1576721910460](./img/linux/java-linux/Linux-v10-02天-授课/1576721910460.png)\r\n\r\n| 命令          | 作用                               |\r\n| ------------- | ---------------------------------- |\r\n| 结果 > 文件名 | `>` 表示输出, 会覆盖文件的原有内容 |\r\n\r\n- ##### 第二步: 将**命令的成功结果** **追加**  指定文件的后面\r\n\r\n```\r\necho  黑马程序员 >> czbk-txt.txt\r\n```\r\n\r\n执行结果如下\r\n\r\n![1576721980097](./img/linux/java-linux/Linux-v10-02天-授课/1576721980097.png)\r\n\r\n| 命令           | 作用                                        |\r\n| -------------- | ------------------------------------------- |\r\n| 命令 >> 文件名 | `>>` 表示追加, 会将内容追加到已有文件的末尾 |\r\n\r\n- ##### 第三步: 将**命令的失败结果** **追加** 指定文件的后面\r\n\r\n```\r\ncat 不存在的目录  &>>  error.log\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576722167942](./img/linux/java-linux/Linux-v10-02天-授课/1576722167942.png)\r\n\r\n| 命令             | 作用                                   |\r\n| ---------------- | -------------------------------------- |\r\n| 命令  `&>>` 文件 | `&>>` 表示不区分错误类型 都放到 日志中 |\r\n\r\n> 总结\r\n>\r\n> - 通过 `命令 > 文件`  将**命令的成功结果** **覆盖** 指定文件内容\r\n> - 通过 `命令 >> 文件`   将**命令的成功结果** **追加**  指定文件的后面\r\n> - 通过 `命令 &>> 文件` 将 **命令的失败结果** **追加** 指定文件的后面\r\n\r\n## 1.4 awk命令\r\n\r\nAWK是一种处理文本文件的语言，是一个强大的文本分析工具。\r\n\r\n之所以叫AWK是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符。\r\n\r\n**具体语法如下**\r\n\r\n```shell\r\nawk [选项参数] \'script\' var=value file(s)\r\n或\r\nawk [选项参数] -f scriptfile var=value file(s)\r\n```\r\n\r\n**1、数据准备：czbk-txt.txt文本内容如下：**\r\n\r\n```shell\r\nzhangsan 68 99 26\r\nlisi 98 66 96\r\nwangwu 38 33 86\r\nzhaoliu 78 44 36\r\nmaq 88 22 66\r\nzhouba 98 44 46\r\n```\r\n\r\n **2、搜索含有 zhang  和 li 的学生成绩：**\r\n\r\n```shell\r\ncat czbk-txt.txt | awk \'/zhang|li/\'\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577178031588](./img/linux/java-linux/Linux-v10-02天-授课/1577178031588.png)\r\n\r\n**指定分割符, 根据下标显示内容**\r\n\r\n| 命令                                        | 含义                                                         |\r\n| ------------------------------------------- | ------------------------------------------------------------ |\r\n| awk   -F  \',\'    \'{print $1, $2, $3}\'  文件 | 操作1.txt文件,  根据 逗号 分割, 打印 第一段 第二段 第三段 内容 |\r\n\r\n选项\r\n\r\n| 选项       | 英文            | 含义                     |\r\n| ---------- | --------------- | ------------------------ |\r\n| `-F \',\'`   | field-separator | 使用 **指定字符** 分割   |\r\n| `$ + 数字` |                 | 获取**第几段**内容       |\r\n| `$0`       |                 | 获取 **当前行** 内容     |\r\n| `NF`       | field           | 表示当前行共有多少个字段 |\r\n| `$NF`      |                 | 代表 最后一个字段        |\r\n| `$(NF-1)`  |                 | 代表 倒数第二个字段      |\r\n| `NR`       |                 | 代表 处理的是第几行      |\r\n\r\n```\r\n# 查看文档内容\r\ncat czbk-txt.txt \r\n#直接输出\r\ncat score.txt | awk -F \' \' \'{print $1,$2,$3}\'\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577178523300](./img/linux/java-linux/Linux-v10-02天-授课/1577178523300.png)\r\n\r\n**指定分割符, 根据下标显示内容**\r\n\r\n| 命令                                                    | 含义                                                         |\r\n| ------------------------------------------------------- | ------------------------------------------------------------ |\r\n| awk   -F  \' \'    \'{OFS="==="}{print $1, $2, $3}\'  1.txt | 操作1.txt文件,  根据 逗号 分割, 打印 第一段 第二段 第三段 内容 |\r\n\r\n选项\r\n\r\n| 选项         | 英文                   | 含义                     |\r\n| ------------ | ---------------------- | ------------------------ |\r\n| `OFS="字符"` | output field separator | 向外输出时的段分割字符串 |\r\n\r\n| 转义序列 | 含义   |\r\n| -------- | ------ |\r\n| \\b       | 退格   |\r\n| \\f       | 换页   |\r\n| \\n       | 换行   |\r\n| \\r       | 回车   |\r\n| \\t       | 制表符 |\r\n\r\n```\r\n# 按照 === 进行分割, 打印 第一段 第二段 第三段\r\ncat  czbk-txt.txt | awk -F \' \' \'{OFS="==="}{print $1,$2,$3}\'\r\n# 按照 制表符tab 进行分割, 打印 第一段 第二段 第三段\r\ncat czbk-txt.txt| awk -F \' \' \'{OFS="\\t"}{print $1,$2,$3}\'\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577178563336](./img/linux/java-linux/Linux-v10-02天-授课/1577178563336.png)\r\n\r\n![1577179227699](./img/linux/java-linux/Linux-v10-02天-授课/1577179227699.png)\r\n\r\n**调用 awk 提供的函数**\r\n\r\n| 命令                                           | 含义                                                         |\r\n| ---------------------------------------------- | ------------------------------------------------------------ |\r\n| awk   -F  \',\'    \'{print  toupper($2)}\'  1.txt | 操作1.txt文件,  根据 逗号 分割, 打印 第一段 第二段 第三段 内容 |\r\n\r\n常用函数如下:\r\n\r\n| 函数名    | 含义   | 作用           |\r\n| --------- | ------ | -------------- |\r\n| toupper() | upper  | 字符 转成 大写 |\r\n| tolower() | lower  | 字符 转成小写  |\r\n| length()  | length | 返回 字符长度  |\r\n\r\n```\r\n# 打印第一段内容\r\n cat czbk-txt.txt | awk -F \' \' \'{print $1}\'\r\n# 将第一段内容转成大写 且 显示 \r\n cat czbk-txt.txt | awk -F \' \' \'{print toupper($1)}\'\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577180402362](./img/linux/java-linux/Linux-v10-02天-授课/1577180402362.png)\r\n\r\n**求指定学科平均分**\r\n\r\n| 命令                                                         | 含义                                                         |\r\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\r\n| awk \'BEGIN{初始化操作}{每行都执行} END{结束时操作}\'   文件名 | BEGIN{ 这里面放的是执行前的语句 }<br />{这里面放的是处理每一行时要执行的语句}<br />END {这里面放的是处理完所有的行后要执行的语句 } |\r\n\r\n**查看czbk-txt.txt 文件内容**\r\n\r\n```shell\r\ncat czbk-txt.txt \r\n```\r\n\r\n执行效果如下\r\n\r\n![1577180698120](./img/linux/java-linux/Linux-v10-02天-授课/1577180698120.png)\r\n\r\n**查看总分**\r\n\r\n注意：这里计算的是第4列的总分\r\n\r\n```shell\r\ncat czbk-txt.txt| awk -F \' \' \'BEGIN{}{total=total+$4} END{print total}\'\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577180583110](./img/linux/java-linux/Linux-v10-02天-授课/1577180583110.png)\r\n\r\n**查看总分, 总人数**\r\n\r\n注意：这里计算的是第4列的\r\n\r\n```shell\r\ncat czbk-txt.txt| awk -F \' \' \'BEGIN{}{total=total+$4} END{print total, NR}\'\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577180635136](./img/linux/java-linux/Linux-v10-02天-授课/1577180635136.png)\r\n\r\n**查看总分, 总人数, 平均分**\r\n\r\n注意：这里计算的是第4列的\r\n\r\n```shell\r\n cat czbk-txt.txt | awk -F \' \' \'BEGIN{}{total=total+$4} END{print total, NR, (total/NR)}\'\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577180660454](./img/linux/java-linux/Linux-v10-02天-授课/1577180660454.png)\r\n\r\n> 总结\r\n>\r\n> awk在使用过程中主要用作分析\r\n>\r\n> 简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理\r\n\r\n## 1.5  软连接\r\n\r\n```\r\n软连接其实就类似于我们在Windows中的【快捷方式】\r\n```\r\n\r\n- 在Linux**文件名** 和 **内容** 是两个文件, 分开的!![1558439106175](./img/linux/java-linux/Linux-v10-02天-授课/1558439106175.png)\r\n\r\n\r\n\r\n- 创建软链接的原理, 如下![1558439158250](./img/linux/java-linux/Linux-v10-02天-授课/1558439158250.png)\r\n\r\n  为什么有软连接？\r\n\r\n  因为 某些文件和目录 的 **路径很深**, 所以 需要增加 **软链接(快捷方式)**\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法如下:**\r\n\r\n| 命令                                      | 英文 | 作用                                         |\r\n| ----------------------------------------- | ---- | -------------------------------------------- |\r\n| ln **-s**  目标文件绝对路径  快捷方式路径 | link | 给目标文件增加一个软链接, 通俗讲就是快捷方式 |\r\n\r\n**给home/itcast/txtfile.txt文件增加软连接**\r\n\r\n```shell\r\n ln  -s /home/itcast/txtfile.txt    czbk-txt\r\n```\r\n\r\n上面；我们将/home/itcast/路径下的txtfile.txt文件增加软连接到\r\n\r\nczbk-txt，然后通过cat 访问czbk-txt也是可以正常访问的\r\n\r\n如下图\r\n\r\n![1576723058556](./img/linux/java-linux/Linux-v10-02天-授课/1576723058556.png)\r\n\r\n> 总结\r\n>\r\n> 通过 `ln -s 源文件的绝对路径 其实就是给**目标文件** 增加 **快捷方式**\r\n\r\n## 1.6 find查找\r\n\r\n```\r\n引子\r\nfind命令类似与在Windows中全局查找（如下图）\r\n```\r\n\r\n![1576828863833](./img/linux/java-linux/Linux-v10-02天-授课/1576828863833.png)\r\n\r\n**find概念**\r\n\r\nfind命令用来在指定目录下查找文件。\r\n\r\n任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。\r\n\r\n**语法**\r\n\r\n```shell\r\nfind <指定目录> <指定条件> <指定内容>\r\n```\r\n\r\n**1、将目前目录及其子目录下所有延伸档名是 gz 的文件查询出来** \r\n\r\n```shell\r\nfind . -name "*.gz"\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576829221486](./img/linux/java-linux/Linux-v10-02天-授课/1576829221486.png)\r\n\r\n\r\n\r\n**2、将目前目录及其子目录下所有最近 1天内更新过的文件查询出来**\r\n\r\n```shell\r\nfind . -ctime -1\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576829352063](./img/linux/java-linux/Linux-v10-02天-授课/1576829352063.png)\r\n\r\n**3、全局搜索czbk**\r\n\r\n/代表是全盘搜索,也可以指定目录搜索 \r\n\r\n```shell\r\n find / -name  \'czbk\'\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576829929308](./img/linux/java-linux/Linux-v10-02天-授课/1576829929308.png)\r\n\r\n## 1.7 read命令\r\n\r\n> 注意：\r\n>\r\n> read命令属于文件范畴的命令\r\n>\r\n> 在下面的演示中，会涉及到shell，shell章节在最后一章\r\n>\r\n> 建议：讲解shell的时候在回过来说下read命令的语法\r\n>\r\n> 我们在综合案例中也会降到read\r\n\r\n```\r\n引子：\r\nread命令相当于在java SE阶段我们学习的键盘录入输入Scanner（read命令会比Scanner更强大），开发人员可以动态的与程序交互，\r\n```\r\n\r\nread命令用于从标准输入读取数值。\r\n\r\nread 内部命令被用来从标准输入读取单行数据。这个命令可以用来读取键盘输入，当使用重定向的时候，可以读取文件中的一行数据。\r\n\r\n**语法**\r\n\r\n```\r\nread [-ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]\r\n```\r\n\r\n**1、简单读取**\r\n\r\n```shell\r\n#!/bin/bash\r\necho "请您输入网站名: "  \r\n#读取从键盘的输入  \r\nread website  \r\necho "你输入的网站名是 $website"  \r\nexit 0  #退出\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577409765115](./img/linux/java-linux/Linux-v10-02天-授课/1577409765115.png)\r\n\r\n\r\n\r\n**3、读取文件**\r\n\r\n每次调用 read 命令都会读取文件中的 "一行" 文本。当文件没有可读的行时，read 命令将以非零状态退出。\r\n\r\n我们可以使用 cat 命令将结果直接传送给包含 read 命令的 while 命令。\r\n\r\n测试文件 test.txt 内容如下：\r\n\r\n```\r\nAAAAAAAAAAAAAAAAAAAAAA\r\nBBBBBBBBBBBBBBBBBBBBBB\r\nCCCCCCCCCCCCCCCCCCCCCC\r\nDDDDDDDDDDDDDDDDDDDDDD\r\n================传智播客\r\n```\r\n\r\n脚本如下，可以将脚本放到xxx.sh中进行执行\r\n\r\n```shell\r\n#!/bin/bash\r\ncount=1\r\ncat test.txt | while read line      \r\n# cat 命令的输出作为read命令的输入,read读到>的值放在line中\r\ndo\r\n   echo "Line $count:$line"\r\n   count=$[ $count + 1 ]          # 注意中括号中的空格。\r\ndone\r\necho "finish"\r\nexit 0\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577410272633](./img/linux/java-linux/Linux-v10-02天-授课/1577410272633.png)\r\n\r\n> 总结\r\n>\r\n> 由此可看read命令不仅可以读取键盘输入，而且还可以读取静态文件\r\n\r\n## 1.8 总结\r\n\r\n文件命令是我们在开发过程中最经常使用的到的命令，所以，我们在学习过程中一定要认真学习文件的常用命令，比如文件创建、编写、读取命令。\r\n\r\n# 2 Linux备份压缩\r\n\r\n```\r\n在Windows中我们对于一个大文件进行压缩的时候，通常会使用第三方工具，比如360压缩、快压等工具，把一个文件压缩成.zip格式的压缩文件；而在Linux中我们也可以通过各种命令实现压缩的功能。\r\n```\r\n\r\n## **2.1 gzip命令**\r\n\r\n```\r\n压缩/解压缩文件，不能压缩目录\r\nwindows下接触的压缩文件大多是.rar，.7z格式，Linux下，不能识别这种格式。\r\n.zip格式的文件在Windows和Linux下都能使用。\r\n压缩文件，能节省磁盘空间，传输时能节省网络带宽\r\n```\r\n\r\ngzip命令用于压缩文件。\r\n\r\ngzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出".gz"的扩展名\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法**\r\n\r\n```shell\r\ngzip[参数][文件或者目录]\r\n```\r\n\r\n**1、压缩目录下的所有文件**\r\n\r\n数据准备，新建一个目录，里面随便新建4个文件\r\n\r\n```shell\r\nmkdir  gzipTest\r\ncd gzipTest/\r\ntouch  001\r\ntouch  002\r\ntouch  003\r\ntouch  004\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576736152636](./img/linux/java-linux/Linux-v10-02天-授课/1576736152636.png)\r\n\r\n**1、压缩目录下的所有文件**\r\n\r\n```shell\r\ngzip * \r\n```\r\n\r\n![1576736179025](./img/linux/java-linux/Linux-v10-02天-授课/1576736179025.png)\r\n\r\n**2、 列出详细的信息**\r\n\r\n解压文件并列出详细信息\r\n\r\n```shell\r\ngzip -dv *\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576736286406](./img/linux/java-linux/Linux-v10-02天-授课/1576736286406.png)\r\n\r\n\r\n\r\n## 2.2 gunzip命令\r\n\r\n```\r\ngunzip是个使用广泛的解压缩程序，它用于解开被gzip压缩过的文件\r\n```\r\n\r\ngunzip命令用于解压文件。\r\n\r\n**语法**\r\n\r\n```\r\ngunzip[参数][文件或者目录]\r\n```\r\n\r\n```shell\r\ngunzip 001.gz \r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576738711718](./img/linux/java-linux/Linux-v10-02天-授课/1576738711718.png)\r\n\r\n001为解压后的文件\r\n\r\n## 2.3 tar命令\r\n\r\n```\r\ntar的主要功能是打包、压缩和解压文件。\r\n\r\ntar本身不具有压缩功能。他是调用压缩功能实现的 。\r\n```\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法**\r\n\r\n```shell\r\ntar[必要参数][选择参数][文件] \r\n```\r\n\r\n**1、将 txtfile.txt文件打包（仅打包，不压缩）**\r\n\r\ntxtfile.txt文件为上面章节的例子\r\n\r\n```shell\r\ntar -cvf txt.tar txtfile.txt \r\n```\r\n\r\n执行效果如下\r\n\r\n![1576726937758](./img/linux/java-linux/Linux-v10-02天-授课/1576726937758.png)\r\n\r\n **2、将 txtfile.txt文件打包压缩（打包压缩（gzip））**\r\n\r\n```shell\r\ntar -zcvf txt.tar.gz txtfile.txt \r\n```\r\n\r\n执行效果如下\r\n\r\n![1576727107465](./img/linux/java-linux/Linux-v10-02天-授课/1576727107465.png)\r\n\r\n>  总结\r\n>\r\n> 参数 f 之后的文件档名是自己取的，我们习惯上都用 .tar 来作为辨识。 如果加 z 参数，则以 .tar.gz 或 .tgz 来代表 gzip 压缩过的 tar包\r\n\r\n**3、查看tar中有哪些文件**\r\n\r\n```shell\r\ntar -ztvf txt.tar.gz\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576734505587](./img/linux/java-linux/Linux-v10-02天-授课/1576734505587.png)\r\n\r\n压缩包中的文件有txtfile.txt\r\n\r\n**4、将tar 包解压缩**\r\n\r\n```shell\r\n1.新建目录\r\n mkdir ysFiles\r\n2.复制\r\n cp txt.tar.gz ./ysFiles/\r\n3.解压缩\r\n tar -zxvf /home/itcast/ysFiles/txt.tar.gz\r\n```\r\n\r\n解压后的文件如下\r\n\r\n![1576735062585](./img/linux/java-linux/Linux-v10-02天-授课/1576735062585.png)\r\n\r\n## 2.4 zip命令\r\n\r\n```\r\n引子\r\nzip命令就完全的相当于在Windows下面选中文件右键进行压缩了\r\n```\r\n\r\nzip命令用于压缩文件。\r\n\r\nzip是个使用广泛的压缩程序，文件经它压缩后会另外产生具有".zip"扩展名的压缩文件。\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法**\r\n\r\n```\r\nzip[必要参数][选择参数][文件] \r\n```\r\n\r\n将上面/home/itcast/gzipTest 这个目录下所有文件和文件夹打包为当前目录下的 zFiles.zip：\r\n\r\n```shell\r\n1.在目录下新建一个005目录\r\nmkdir 005\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576736751949](./img/linux/java-linux/Linux-v10-02天-授课/1576736751949.png)\r\n\r\n开始压缩\r\n\r\n```shell\r\n2.压缩\r\nzip -q -r zFiles.zip *\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576736844251](./img/linux/java-linux/Linux-v10-02天-授课/1576736844251.png)zFiles.zip文件就是我们刚刚压缩后的文件\r\n\r\n## 2.5 unzip命令\r\n\r\n```\r\n引子\r\nunzip命令就完全的相当于在Windows下面选中文件右键进行解压缩了\r\n```\r\n\r\nLinux unzip命令用于解压缩zip文件\r\n\r\nunzip为.zip压缩文件的解压缩程序\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法**\r\n\r\n```\r\nunzip[必要参数][选择参数][文件] \r\n```\r\n\r\n**参数**：\r\n\r\n上接上面的zip的例子\r\n\r\n**1、查看压缩文件中包含的文件：**\r\n\r\n```shell\r\n unzip -l zFiles.zip\r\n```\r\n\r\n![1576737168412](./img/linux/java-linux/Linux-v10-02天-授课/1576737168412.png)\r\n\r\n包含了压缩文件里面文件的详细信息\r\n\r\n文件大小  日期 时间  文件名称\r\n\r\n总数量和总大小\r\n\r\n**2、如果要把文件解压到指定的目录下，需要用到-d参数**\r\n\r\n```shell\r\n1.新建目录\r\nunFiles\r\n2.解压缩\r\nunzip -d ./unFiles zFiles.zip\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576737722160](./img/linux/java-linux/Linux-v10-02天-授课/1576737722160.png)\r\n\r\n 查看解压后的文件，如下图\r\n\r\n![1576737744650](./img/linux/java-linux/Linux-v10-02天-授课/1576737744650.png)\r\n\r\n\r\n\r\n## 2.6 bzip2命令\r\n\r\n```\r\n引子\r\n".bz2"格式是 Linux 的另一种压缩格式，从理论上来讲，".bz2"格式的算法更先进、压缩比更好；而 咱们上面学到的".gz"格式相对来讲时间更快\r\n在使用过程中可以根据需求自由选择\r\n```\r\n\r\nbzip2命令是.bz2文件的压缩程序。\r\n\r\nbzip2采用新的压缩演算法，压缩效果比传统的LZ77/LZ78压缩演算法来得好。若没有加上任何参数，bzip2压缩完文件后会产生.bz2的压缩文件，并删除原始的文件。\t\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法**\r\n\r\n```\r\nbzip2 [-cdfhkLstvVz][--repetitive-best][--repetitive-fast][- 压缩等级][要压缩的文件]\r\n```\r\n\r\n**1、压缩文件**\r\n\r\n```\r\n1.创建目录\r\n mkdir  bzFiles\r\n cd ./bzFiles/\r\n2.创建文件\r\ntouch 001\r\n3.压缩\r\nbzip2 001\r\nll\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576742060052](./img/linux/java-linux/Linux-v10-02天-授课/1576742060052.png)\r\n\r\n如上图001.bz2就是压缩后的文件\r\n\r\n## **2.7 bunzip2命令**\r\n\r\n```\r\n引子\r\nLinux bunzip2命令是.bz2文件的解压缩程序。\r\n```\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法**：\r\n\r\n```shell\r\nbunzip2 [-fkLsvV][.bz2压缩文件]\r\n```\r\n\r\n**参数**：\r\n\r\n**解压.bz2文件**\r\n\r\n```shell\r\nbunzip2 -v 001.bz2 \r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576744907366](./img/linux/java-linux/Linux-v10-02天-授课/1576744907366.png)\r\n\r\n001文件即是被解压后的\r\n\r\n## 2.8 总结\r\n\r\ngz：由gzip压缩工具压缩的文件。\r\n\r\n.bz2：由bzip2压缩工具压缩的文件。\r\n\r\n.tar：由tar打包程序打包的文件（tar没有压缩功能，只是把一个 目录合并成一个文件）\r\n\r\n.tar.gz：可理解为先由tar打包，再由gz压缩。\r\n\r\n.zip:可理解为由zip压缩工具直接压缩\r\n\r\n# 3 网络与磁盘管理\r\n\r\n> Tips:\r\n>\r\n> 重点讲解内容\r\n\r\n## **3.1 网络命令**\r\n\r\n### 3.1.1 ifconfig命令\r\n\r\n```\r\n引子：\r\n\r\nifconfig命令有点类似于Windows的ipconfig命令\r\n```\r\n\r\nifconfig是Linux中用于显示或配置网络设备的命令，英文全称是network interfaces configuring\r\n\r\n ifconfig命令用于显示或设置网络设备。\r\n\r\nifconfig可设置网络设备的状态，或是显示目前的设置。\r\n\r\n**使用者权限：所有（设置级别的需要管理员）用户**\r\n\r\n**语法**\r\n\r\n```\r\nifconfig [网络设备][down up -allmulti -arp -promisc][add<地址>][del<地址>][<hw<网络设备类型><硬件地址>][io_addr<I/O地址>][irq<IRQ地址>][media<网络媒介类型>][mem_start<内存地址>][metric<数目>][mtu<字节>][netmask<子网掩码>][tunnel<地址>][-broadcast<地址>][-pointopoint<地址>][IP地址]\r\n```\r\n\r\n**1、显示激活的网卡信息**\r\n\r\n```\r\nifconfig\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576749039798](./img/linux/java-linux/Linux-v10-02天-授课/1576749039798.png)\r\n\r\n![1576749055869](./img/linux/java-linux/Linux-v10-02天-授课/1576749055869.png)\r\n\r\n**ens33（有的是eth0）**表示第一块网卡。\r\n\r\n表示ens33网卡的 IP地址是 192.168.23.129，广播地址，broadcast 192.168.23.255，掩码地址netmask:255.255.255.0 ，inet6对应的是ipv6\r\n\r\n**ens37** 表示第二块网卡\r\n\r\n**lo** 是表示主机的回坏地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口 \r\n\r\n启动关闭指定网卡\r\n\r\n**virbr0**是一种虚拟网络接口\r\n\r\n**2、关闭网卡（需要切换到管理员账户）**\r\n\r\n```shell\r\n ifconfig ens37 down\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576748850255](./img/linux/java-linux/Linux-v10-02天-授课/1576748850255.png)\r\n\r\n**3、启用网卡（需要切换到管理员账户）**\r\n\r\n```shell\r\nifconfig ens37 up\r\n```\r\n\r\n 执行效果如下\r\n\r\n![1576748937884](./img/linux/java-linux/Linux-v10-02天-授课/1576748937884.png)\r\n\r\n**4、配置ip信息**\r\n\r\n```shell\r\n// 配置ip地址\r\nifconfig ens37 192.168.23.199\r\n// 配置ip地址和子网掩码\r\nifconfig ens37 192.168.23.133 netmask 255.255.255.0\r\n```\r\n\r\n执行效果如下，配置ip地址：\r\n\r\n![1576749864267](./img/linux/java-linux/Linux-v10-02天-授课/1576749864267.png)\r\n\r\n查看ip，如下图\r\n\r\n![1576749896757](./img/linux/java-linux/Linux-v10-02天-授课/1576749896757.png)\r\n\r\n配置ip地址和子网掩码，执行效果如下图\r\n\r\n![1576749957171](./img/linux/java-linux/Linux-v10-02天-授课/1576749957171.png)\r\n\r\n这样的话我们就可以通过命令的方式设置网卡的网络信息了。\r\n\r\n### 3.1.2 ping命令\r\n\r\n```\r\n等价于Windows的ping命令\r\n```\r\n\r\nping命令用于检测主机。\r\n\r\n执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法**\r\n\r\n```shell\r\nping [-dfnqrRv][-c<完成次数>][-i<间隔秒数>][-I<网络界面>][-l<前置载入>][-p<范本样式>][-s<数据包大小>][-t<存活数值>][主机名称或IP地址]\r\n```\r\n\r\n**1、检测是否与主机连通**\r\n\r\n```shell\r\n ping www.baidu.com\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576750258293](./img/linux/java-linux/Linux-v10-02天-授课/1576750258293.png)\t\r\n\r\nicmp_seq：ping序列，从1开始\r\n\r\nttl:IP生存时间值\r\n\r\ntime: 响应时间,数值越小，联通速度越快\r\n\r\n**2、指定接收包的次数**\r\n\r\n和上面不同的是：收到两次包后，自动退出\r\n\r\n```shell\r\nping -c 2 www.baidu.com\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576750967595](./img/linux/java-linux/Linux-v10-02天-授课/1576750967595.png)\r\n\r\n> 总结：\r\n>\r\n> ping命令也是我们在开发过程中常用到的命令\r\n>\r\n> 通常使用  ping  xxx.xxx.xxx.xxx命令进行检测本地与目标机器是否连通\r\n\r\n### 3.1.3 netstat命令\r\n\r\n```\r\n利用netstat指令可让你得知整个Linux系统的网络情况\r\n```\r\n\r\nnetstat命令用于显示网络状态。\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法**\r\n\r\n```\r\nnetstat [-acCeFghilMnNoprstuvVwx][-A<网络类型>][--ip]\r\n```\r\n\r\n**1、显示详细的连接状况**\r\n\r\n```shell\r\nnetstat -a\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576751379320](./img/linux/java-linux/Linux-v10-02天-授课/1576751379320.png)\r\n\r\n比如上面的【0 0.0.0.0:ssh】它是远程终端连接Linux的ssh服务，默认使用了22端口，它的状态【State】是处于监听状态，属于正常。\r\n\r\n**2、显示网卡列表**\r\n\r\n```shell\r\nnetstat -i\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576751502980](./img/linux/java-linux/Linux-v10-02天-授课/1576751502980.png)\r\n\r\n上图显示的是我们在介绍【ifconfig】命令的时候看到的网卡信息\r\n\r\n## 3.2 磁盘命令\r\n\r\n### **3.2.1 lsblk命令**\r\n\r\n```\r\n使用lsblk命令可以以tree的形式展示所有设备的信息\r\n```\r\n\r\nlsblk命令的英文是“list block”，即用于列出所有可用块设备的信息，而且还能显示他们之间的依赖关系，但是它不会列出RAM盘的信息。\r\n\r\n**语法格式：**lsblk [参数]\r\n\r\n**使用者权限：所有用户**\r\n\r\n**1、lsblk命令默认情况下将以树状列出所有块设备：**\r\n\r\n```shell\r\nlsblk\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576827840642](./img/linux/java-linux/Linux-v10-02天-授课/1576827840642.png)\r\n\r\nNAME : 这是块设备名。\r\n\r\nMAJ:MIN : 本栏显示主要和次要设备号。\r\n\r\nRM : 本栏显示设备是否可移动设备。注意，在上面设备sr0的RM值等于1，这说明他们是可移动设备。\r\n\r\nSIZE : 本栏列出设备的容量大小信息。\r\n\r\nRO : 该项表明设备是否为只读。在本案例中，所有设备的RO值为0，表明他们不是只读的。\r\n\r\nTYPE :本栏显示块设备是否是磁盘或磁盘上的一个分区。在本例中，sda和sdb是磁盘，而sr0是只读存储（rom）。\r\n\r\nMOUNTPOINT : 本栏指出设备挂载的挂载点。\r\n\r\n**2、默认选项不会列出所有空设备：**\r\n\r\n```shell\r\nlsblk -f\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576828112552](./img/linux/java-linux/Linux-v10-02天-授课/1576828112552.png)\r\n\r\nNAME表示设备名称\r\n\r\nFSTYPE表示文件类型\r\n\r\nLABEL表示设备标签\r\n\r\nUUID设备编号\r\n\r\nMOUNTPOINT表示设备的挂载点\r\n\r\n> 注意\r\n>\r\n> 我们学习这个命令主要是在下面将要学习的fdisk分区中会经常使用到\r\n\r\n### 3.2.2 df命令\r\n\r\n```\r\n引子（如下图）：\r\nLinux的df命令类似于在Windows中的【计算机】--【管理】--【磁盘管理】菜单对磁盘的统计情况查看\r\n```\r\n\r\n![1576751996364](./img/linux/java-linux/Linux-v10-02天-授课/1576751996364.png)\r\n\r\n df命令用于显示目前在Linux系统上的文件系统的磁盘使用情况统计。\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法**\r\n\r\n```\r\ndf [选项]... [FILE]...\r\n```\r\n\r\n**1、显示磁盘使用情况统计情况**\r\n\r\n```\r\ndf  \r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576752158168](./img/linux/java-linux/Linux-v10-02天-授课/1576752158168.png)\r\n\r\n第一列指定文件系统的名称\r\n\r\n第二列指定一个特定的文件系统1K-块1K是1024字节为单位的总容量。\r\n\r\n已用和可用列分别指定的容量。\r\n\r\n最后一个已用列指定使用的容量的百分比\r\n\r\n最后一栏指定的文件系统的挂载点。\r\n\r\n**2、df命令也可以显示磁盘使用的文件系统信息**\r\n\r\n比如我们df下之前创建过的目录gzipTest的使用情况\r\n\r\n```\r\ndf  gzipTest/\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576752596414](./img/linux/java-linux/Linux-v10-02天-授课/1576752596414.png)\r\n\r\n**3、df显示所有的信息**\r\n\r\n```\r\ndf --total \r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576752719226](./img/linux/java-linux/Linux-v10-02天-授课/1576752719226.png)\r\n\r\n我们看到输出的末尾，包含一个额外的行，显示总的每一列。\r\n\r\n 4、df换算后显示\r\n\r\n```shell\r\ndf -h \r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576752819456](./img/linux/java-linux/Linux-v10-02天-授课/1576752819456.png)\r\n\r\n我们可以看到输出显示的数字形式的\'G\'（千兆字节），"M"（兆字节）和"K"（千字节）。\r\n\r\n这使输出容易阅读和理解，从而使显示可读的。请注意，第二列的名称也发生了变化，为了使显示可读的"容量"。\r\n\r\n### 3.2.3 mount命令\r\n\r\n```\r\n在Linux当中所有的存储设备如u盘、光盘、硬盘等，都必须挂载之后才能正常使用。\r\n\r\n其实挂载可以理解为Windows当中的分配盘符（重要），只不过windows当中是以英文字母ABCD等作为盘符，而linux是拿系统目录作为盘符，当然linux当中也不叫盘符，而是称为挂载点，而把为分区或者光盘等存储设备分配一个挂载点的过程称为挂载\r\n```\r\n\r\n mount命令是经常会使用到的命令，它用于挂载Linux系统外的文件。\r\n\r\n**挂载概念**\r\n\r\n在安装linux系统时设立的各个分区，如根分区、/boot分区等都是自动挂载的，也就是说不需要我们人为操作，开机就会自动挂载。但是光盘、u盘等存储设备如果需要使用，就必须人为的进行挂载。\r\n\r\n其实我们在windows下插入U盘也是需要挂载(分配盘符)的，只不过windows下分配盘符是自动的\r\n\r\nLinux中的根目录以外的文件要想被访问，需要将其“关联”到根目录下的某个目录来实现，这种关联操作就是“挂载”，这个目录就是“挂载点”，解除次关联关系的过程称之为“卸载”。\r\n\r\n**注意：“挂载点”的目录需要以下几个要求：**\r\n\r\n（1）目录事先存在，可以用mkdir命令新建目录；\r\n\r\n（2）挂载点目录不可被其他进程使用到；\r\n\r\n（3）挂载点下原有文件将被隐藏。\r\n\r\n**使用者权限：所有用户，设置级别的需要管理员**\r\n\r\n**语法**\r\n\r\n```\r\nmount [-hV]\r\nmount -a [-fFnrsvw] [-t vfstype]\r\nmount [-fnrsvw] [-o options [,...]] device | dir\r\nmount [-fnrsvw] [-t vfstype] [-o options] device dir\r\n```\r\n\r\n需求:\r\n比如现在我们要通过挂载的方式查看Linux CD/DVD光驱里面的内容\r\n\r\n**1、CD/DVD设置**\r\n\r\n进入【虚拟机】--【设置】\r\n\r\n![1576805605263](./img/linux/java-linux/Linux-v10-02天-授课/1576805605263.png)\r\n\r\n\r\n\r\n设置CD/DVD的内容，我们这里使用的是F:\\CentOS-7-x86_64-DVD-1810.iso\r\n\r\n![1576805634085](./img/linux/java-linux/Linux-v10-02天-授课/1576805634085.png)\r\n\r\n查看F:\\CentOS-7-x86_64-DVD-1810.iso；里面的内容\r\n\r\n![1576805690039](./img/linux/java-linux/Linux-v10-02天-授课/1576805690039.png)\r\n\r\n\r\n\r\n**2、创建挂载点**\r\n\r\n注意：一般用户无法挂载cdrom,只有root用户才可以操作\r\n\r\n我们切换到root下创建一个挂载点（其实就是创建一个目录）\r\n\r\n```shell\r\nmkdir  -p mnt/cdrom\r\n```\r\n\r\n**3、开始挂载**\r\n\r\n通过挂载点的方式查看上面的【ISO文件内容】\r\n\r\n```shell\r\nmount -t auto /dev/cdrom /mnt/cdrom\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576807195774](./img/linux/java-linux/Linux-v10-02天-授课/1576807195774.png)\r\n\r\n表示挂载成功\r\n\r\n**4、查看挂载点内容**\r\n\r\n```shell\r\nls -l -a ./mnt/cdrom/\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576807395970](./img/linux/java-linux/Linux-v10-02天-授课/1576807395970.png)\r\n\r\n如上图所示，我们通过挂载点查看CD/DVD的文件个数是14个，和上面的【ISO文件内容】个数一致。\r\n\r\n**5、卸载cdrom**\r\n\r\n在前面我们将CD/DVD挂载到了文件系统，如果我们不用了，就可以将其卸载掉\r\n\r\n```\r\numount ./mnt/cdrom/\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576807774194](./img/linux/java-linux/Linux-v10-02天-授课/1576807774194.png)\r\n\r\n我们发现卸载后，通过挂载点就无法查看CD/DVD里面的数据了。\r\n\r\n## 3.3 总结\r\n\r\n关于挂载：用户**不能**直接访问 硬件设备需要将硬件设备 **挂载** 到 系统目录上,  才可以让用户访问。\r\n\r\n# 4 shell与安装\r\n\r\n> tips\r\n>\r\n> 重点讲解内容\r\n\r\n## 4.1 yum使用\r\n\r\n```\r\n引子：\r\nyum类似于开发工具idea、eclipse中的在线插件安装商店\r\n我们输入一个将要安装的插件名字，进行搜索、安装的过程。\r\n```\r\n\r\n**yum概念**\r\n\r\nyum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。\r\n\r\nyum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。\r\n\r\n**yum原理**\r\n\r\n![1576833281476](./img/linux/java-linux/Linux-v10-02天-授课/1576833281476.png)\r\n\r\n> **注意：必须联网**\r\n>\r\n> 不同的服务通过yum命令连接远程yum源进行查找、下载、安装\r\n\r\n**使用者权限：管理员**\r\n\r\n**语法**\r\n\r\n```shell\r\nyum [options] [command] [package ...]\r\n```\r\n\r\n- **options：**可选，选项包括-h（帮助），-y（当安装过程提示选择全部为"yes"），-q（不显示安装的过程）等等。\r\n- **command：**要进行的操作。\r\n- **package**操作的对象。\r\n\r\n------\r\n\r\n**yum常用命令**\r\n\r\n- 1.列出所有可更新的软件清单命令：yum check-update\r\n- 2.更新所有软件命令：yum update\r\n- 3.仅安装指定的软件命令：yum install <package_name>\r\n- 4.仅更新指定的软件命令：yum update <package_name>\r\n- 5.列出所有可安裝的软件清单命令：yum list\r\n- 6.删除软件包命令：yum remove <package_name>\r\n- 7.查找软件包 命令：yum search <keyword>\r\n- 8.清除缓存命令:\r\n  - yum clean packages: 清除缓存目录下的软件包\r\n  - yum clean headers: 清除缓存目录下的 headers\r\n  - yum clean oldheaders: 清除缓存目录下旧的 headers\r\n  - yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers\r\n\r\n### **4.1.1 安装tree**\r\n\r\n```shell\r\nyum -y install tree   //y当安装过程提示选择全部为"yes"\r\n```\r\n\r\n执行效果如下\r\n\r\n注意：第一次在itcast用户执行的时候\r\n\r\n提示我们【需要管理员权限】\r\n\r\n![1576554600128](./img/linux/java-linux/Linux-v10-02天-授课/1576554600128.png)\r\n\r\n![1576554617660](./img/linux/java-linux/Linux-v10-02天-授课/1576554617660.png)\r\n\r\n安装完执行tree命令\r\n\r\n```shell\r\ntree\r\n```\r\n\r\n![1576832663328](./img/linux/java-linux/Linux-v10-02天-授课/1576832663328.png)\r\n\r\n### **4.1.2 移除tree**\r\n\r\n```shell\r\nyum remove  tree\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576832810922](./img/linux/java-linux/Linux-v10-02天-授课/1576832810922.png)\r\n\r\n此时，我们在执行tree命令\r\n\r\n```shell\r\ntree\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576832843434](./img/linux/java-linux/Linux-v10-02天-授课/1576832843434.png)\r\n\r\n如上图，由于我们移除了tree，在执行tree命令的时候发现找不到这个命令了。\r\n\r\n### **4.1.3 yum查找**\r\n\r\n利用 yum 的功能，找出以 tom 为开头的软件名称有哪些\r\n\r\n```shell\r\nyum list tom*\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576832953119](./img/linux/java-linux/Linux-v10-02天-授课/1576832953119.png)\r\n\r\n### 4.1.4 yum源\r\n\r\n**概述**\r\n\r\nyum需要一个yum库，也就是yum源。\r\n\r\n简单的说，我们安装软件的时候需要下载软件，将很多软件放在一起就是源。软件安装包的来源，所以yum源就是软件安装包来源 \r\n\r\n**yum源分类**\r\n\r\n目前，yum默认使用的是CentOS的yum源，如下\r\n\r\n  ![1576834523252](./img/linux/java-linux/Linux-v10-02天-授课/1576834523252.png)\r\n\r\n![1576834556997](./img/linux/java-linux/Linux-v10-02天-授课/1576834556997.png)\r\n\r\n目前，国内有很多不错的yum源，比如阿里、网易、搜狐等\r\n\r\n**安装阿里yum源**\r\n\r\n因为默认的yum源服务器在国外，我们在安装软件的时候会受到速度的影响，所以安装国内yum源在下载的时候速度、稳定性会比国外的好很多。\r\n\r\n**1) 安装wget**\r\n\r\n```shell\r\nyum install -y wget\r\n```\r\n\r\n 执行效果如下\r\n\r\n![1576834799803](./img/linux/java-linux/Linux-v10-02天-授课/1576834799803.png)\r\n\r\n![1576834824250](./img/linux/java-linux/Linux-v10-02天-授课/1576834824250.png)\r\n\r\n安装成功。\r\n\r\n**2) 备份/etc/yum.repos.d/CentOS-Base.repo文件**\r\n\r\n```shell\r\ncd /etc/yum.repos.d/\r\nmv CentOS-Base.repo CentOS-Base.repo.back\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576834936907](./img/linux/java-linux/Linux-v10-02天-授课/1576834936907.png)\r\n\r\n**3) 下载阿里云的Centos-7.repo文件**\r\n\r\n```shell\r\nwget -O CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo\r\n```\r\n\r\n> 注意\r\n>\r\n> 上面的url中要卸载Centos-7.repo；而不是Centos-6.repo\r\n\r\n 执行效果如下图\r\n\r\n![1576837935001](./img/linux/java-linux/Linux-v10-02天-授课/1576837935001.png)\r\n\r\n查看下载的阿里云的Centos-6.repo文件\r\n\r\n```shell\r\ncat CentOS-Base.repo\r\n```\r\n\r\n执行效果如下\r\n\r\n```SHELL\r\n# CentOS-Base.repo\r\n#\r\n# The mirror system uses the connecting IP address of the client and the\r\n# update status of each mirror to pick mirrors that are updated to and\r\n# geographically close to the client.  You should use this for CentOS updates\r\n# unless you are manually picking other mirrors.\r\n#\r\n# If the mirrorlist= does not work for you, as a fall back you can try the \r\n# remarked out baseurl= line instead.\r\n#\r\n#\r\n \r\n[base]\r\nname=CentOS-$releasever - Base - mirrors.aliyun.com\r\nfailovermethod=priority\r\nbaseurl=http://mirrors.aliyun.com/centos/$releasever/os/$basearch/\r\n        http://mirrors.aliyuncs.com/centos/$releasever/os/$basearch/\r\n        http://mirrors.cloud.aliyuncs.com/centos/$releasever/os/$basearch/\r\ngpgcheck=1\r\ngpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\r\n \r\n#released updates \r\n[updates]\r\nname=CentOS-$releasever - Updates - mirrors.aliyun.com\r\nfailovermethod=priority\r\nbaseurl=http://mirrors.aliyun.com/centos/$releasever/updates/$basearch/\r\n        http://mirrors.aliyuncs.com/centos/$releasever/updates/$basearch/\r\n        http://mirrors.cloud.aliyuncs.com/centos/$releasever/updates/$basearch/\r\ngpgcheck=1\r\ngpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\r\n \r\n#additional packages that may be useful\r\n[extras]\r\nname=CentOS-$releasever - Extras - mirrors.aliyun.com\r\nfailovermethod=priority\r\nbaseurl=http://mirrors.aliyun.com/centos/$releasever/extras/$basearch/\r\n        http://mirrors.aliyuncs.com/centos/$releasever/extras/$basearch/\r\n        http://mirrors.cloud.aliyuncs.com/centos/$releasever/extras/$basearch/\r\ngpgcheck=1\r\ngpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\r\n \r\n#additional packages that extend functionality of existing packages\r\n[centosplus]\r\nname=CentOS-$releasever - Plus - mirrors.aliyun.com\r\nfailovermethod=priority\r\nbaseurl=http://mirrors.aliyun.com/centos/$releasever/centosplus/$basearch/\r\n        http://mirrors.aliyuncs.com/centos/$releasever/centosplus/$basearch/\r\n        http://mirrors.cloud.aliyuncs.com/centos/$releasever/centosplus/$basearch/\r\ngpgcheck=1\r\nenabled=0\r\ngpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\r\n \r\n#contrib - packages by Centos Users\r\n[contrib]\r\nname=CentOS-$releasever - Contrib - mirrors.aliyun.com\r\nfailovermethod=priority\r\nbaseurl=http://mirrors.aliyun.com/centos/$releasever/contrib/$basearch/\r\n        http://mirrors.aliyuncs.com/centos/$releasever/contrib/$basearch/\r\n        http://mirrors.cloud.aliyuncs.com/centos/$releasever/contrib/$basearch/\r\ngpgcheck=1\r\nenabled=0\r\ngpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\r\n```\r\n\r\n如上面的命令，之前是【CentOS】，现在是【aliyun】\r\n\r\n**4) 重新加载yum**\r\n\r\n```shell\r\nyum clean all\r\n```\r\n\r\n清理之前（CentOS）的缓存\r\n\r\n执行效果如下\r\n\r\n![1576838137800](./img/linux/java-linux/Linux-v10-02天-授课/1576838137800.png)\r\n\r\n```shell\r\nyum makecache\r\n```\r\n\r\n就是把服务器的包信息下载到本地电脑缓存起来，makecache建立一个缓存，以后用install时就在缓存中搜索，提高了速度。\r\n\r\n执行效果如下\r\n\r\n![1576838150825](./img/linux/java-linux/Linux-v10-02天-授课/1576838150825.png)\r\n\r\n如上图，元数据缓存已建立,缓存成功。\r\n\r\n**5、验证yum源使用**\r\n\r\n```shell\r\nyum search tomcat\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576836672011](./img/linux/java-linux/Linux-v10-02天-授课/1576836672011.png)\r\n\r\n如上图所示，我们发现，现在查找软件信息使用了上面的yum缓存。\r\n\r\nLoading mirror speeds from cached hostfile(从缓存的主机文件加载镜像速度)\r\n * base: mirrors.aliyun.com\r\n * extras: mirrors.aliyun.com\r\n * updates: mirrors.aliyun.com\r\n\r\n> 总结\r\n>\r\n> yum -y install 软件包\r\n>\r\n> 卸载软件\r\n> yum -y remove 软件包\r\n>\r\n> 查找软件\r\n>\r\n> yum list *\r\n>\r\n> yum源\r\n>\r\n> 版本:\r\n>\r\n> 比如我们使用的是CentOS7，在下载CentOS-Base.repo的时候要注意它的版本。\r\n\r\n## 4.2 rpm使用\r\n\r\n```\r\nRPM包管理类似于windows下的“添加/删除程序”但是功能却比“添加/删除程序”强大很多\r\n```\r\n\r\n**1、rpm介绍**\r\n\r\nrpm(redhat package manager) 原本是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux 易于安装，升级，间接提升了 Linux 的适用度。\r\n\r\n**2、rpm与yum区别**\r\n\r\nrpm 只能安装已经下载到本地机器上的rpm 包. yum能在线下载并安装rpm包,能更新系统,且还能自动处理包与包之间的依赖问题,这个是rpm 工具所不具备的。\r\n\r\n语法如下：\r\n\r\n```shell\r\n用法: rpm [选项...]\r\n```\r\n\r\n**rpm包**\r\n\r\n![1577255859260](./img/linux/java-linux/Linux-v10-02天-授课/1577255859260.png)\r\n\r\n> 注意：\r\n>\r\n> 以上为扩展名为.rpm的包\r\n>\r\n> 可以理解成是Windows中的.exe文件\r\n\r\n**安装rpm软件包**\r\n\r\n```shell\r\nrpm -ivh 软件全包名\r\n```\r\n\r\n**卸载rpm软件包**\r\n\r\n```shell\r\nrpm -e 软件全包名      \r\n```\r\n\r\n**列出所有安装过的包**\r\n\r\n```shell\r\nrpm -qa\r\n```\r\n\r\n**查询软件包信息**\r\n\r\n```shell\r\nrpm -qi 软件全包名\r\n```\r\n\r\n**查看文件安装位置** \r\n\r\n```shell\r\nrpm -ql 软件全包名\r\n```\r\n\r\n## 4.3 shell使用\r\n\r\n```\r\nshell脚本类似于我们在Windows中编写的批处理文件，它的扩展名是.bat，比如我们启动Tomcat（后面的课程我们会详细讲解）的时候经常启动的startup.bat，就是Windows下的批处理文件。\r\n而在Linux中，shell脚本编写的文件是以.sh结尾的。比如Tomcat下我们经常使用startup.sh来启动我们的Tomcat，这个startup.sh文件就是shell编写的。\r\n```\r\n\r\n### 4.3.1 shell入门\r\n\r\n```\r\n通过简单的学习，我们编写一个简单的入门shell程序。\r\n我们通过前面学习的echo命令，在shell脚本中打印出一句话。\r\n```\r\n\r\n**1) 什么是shell**\r\n\r\nShell 脚本（shell script），是一种为 shell 编写的脚本程序。\r\n\r\n[Shell](https://www.leiue.com/tags/shell) [脚本](https://www.leiue.com/tags/脚本)（[Shell Script](https://www.leiue.com/tags/shell-script)）又称 Shell 命令稿、程序化脚本，是一种计算机程序使用的文本文件，内容由一连串的 shell 命令组成，经由 Unix Shell 直译其内容后运作\r\n\r\n![1576838959401](./img/linux/java-linux/Linux-v10-02天-授课/1576838959401.png)\r\n\r\n\r\n\r\nShell 被当成是一种脚本语言来设计，其运作方式与解释型语言相当，由 Unix shell 扮演命令行解释器的角色，在读取 shell 脚本之后，依序运行其中的 shell 命令，之后输出结果。利用 shell 脚本可以进行系统管理，文件操作等。\r\n\r\n在 Unix 及所有的系统中，如 Linux、FreeBSD 等操作系统，都存在 shell 脚本。依照 Unix shell 的各种不同类型，shell 脚本也有各种不同方言。在 DOS、OS/2、Microsoft Windows 中的批处理文件，跟 shell 脚本有类似的功能。\r\n\r\n**2) shell环境**\r\n\r\n```\r\njava需要虚拟机解释器, 同理 shell脚本也需要解释器\r\n```\r\n\r\nShell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。\r\n\r\n**查看解释器**\r\n\r\n```shell\r\ncat /etc/shells\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577068054836](./img/linux/java-linux/Linux-v10-02天-授课/1577068054836.png)\r\n\r\nLinux 的 Shell 种类众多，常见的有：\r\n\r\n- Bourne Shell（/usr/bin/sh或/bin/sh）\r\n- Bourne Again Shell（/bin/bash）\r\n- C Shell（/usr/bin/csh）\r\n- K Shell（/usr/bin/ksh）\r\n- Shell for Root（/sbin/sh）\r\n\r\n- 等等……\r\n\r\n我们当前课程使用的是 Bash，也就是 Bourne Again Shell，由于易用和免费，Bash 在日常工作中被广泛使用。同时，Bash 也是大多数Linux 系统默认的 Shell\r\n\r\n**3) 编写第一个shell**\r\n\r\n现在，我们打开文本编辑器(我们也可以使用 vi/vim 命令来创建文件)，新建一个文件 czbk.sh，扩展名为 sh（sh代表shell）：\r\n\r\n```shell\r\n#!/bin/bash  --- 指定脚本解释器\r\necho "你好，传智播客 !"\r\n```\r\n\r\n//写shell的习惯 第一行指定解释器\r\n\r\n//文件是sh为后缀名\r\n\r\n//括号成对书写\r\n\r\n//注释的时候尽量不用中文注释。不友好。\r\n\r\n//[] 括号两端要要有空格。  [ neirong ]\r\n\r\n//习惯代码索引，增加阅读性\r\n\r\n//写语句的时候，尽量写全了，比如if。。。\r\n\r\n1、创建sh文件**\r\n\r\n```shell\r\nvim czbk.sh\r\n```\r\n\r\n**2、编写并保存**\r\n\r\n![1576839380199](./img/linux/java-linux/Linux-v10-02天-授课/1576839380199.png)\r\n\r\n**3、查看czbk.sh文件**\r\n\r\n```shell\r\nls -l\r\n```\r\n\r\n![1576839550390](./img/linux/java-linux/Linux-v10-02天-授课/1576839550390.png)\r\n\r\n如上图，我们发现刚刚编写的czbk.sh文件的的权限是【-rw-rw-r--】，通过我们之前学过的知识，我们发现这个文件并没有执行的权限\r\n\r\n我们需要将czbk.sh文件设置下它的执行权限【x】，如果不设置有执行权限，当前的文件不具备文件执行的能力。\r\n\r\n**通过chmod设置执行权限**\r\n\r\n```shell\r\nchmod +x ./czbk.sh\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576839765609](./img/linux/java-linux/Linux-v10-02天-授课/1576839765609.png)\r\n\r\n我们发现，czbk.sh拥有了【x】执行权限\r\n\r\n下面，我们就开始执行czbk.sh\r\n\r\n**4、执行czbk.sh文件** --- bash a.sh0\r\n\r\n```shell\r\n ./czbk.sh \r\n```\r\n\r\n执行效果如下：\r\n\r\n![1576839880567](./img/linux/java-linux/Linux-v10-02天-授课/1576839880567.png)\r\n\r\n如上图，我们刚刚编写的shell在执行的时候正常打印出来了，说明czbk.sh具备执行的能力\r\n\r\n> 注意：\r\n>\r\n> **#!** 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。\r\n>\r\n> echo 命令用于向窗口输出文本。\r\n\r\n### 4.3.2 shell注释\r\n\r\n```\r\n引子：\r\n在Java SE课程中，我们也学习了注释\r\n比如单行注释我们使用双斜杠//\r\n   多行注释我们使用/**开头表示注释多行\r\n而在shell编程中，我们同样也要有注释，注释掉程序中不用的脚本\r\n```\r\n\r\n**1、单行注释**\r\n\r\n以 **#** 开头的行就是注释，会被解释器忽略。\r\n\r\n通过每一行加一个 **#** 号设置多行注释，如下：\r\n\r\n```shell\r\n#--------------------------------------------\r\n# 这是一个注释\r\n#--------------------------------------------\r\n##### 开始 #####\r\n#\r\n#\r\n# 这里可以添加脚本描述信息\r\n# \r\n#\r\n##### 结束  #####\r\n```\r\n\r\n如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？\r\n\r\n每一行加个#符号太费力了，此时，我们可以通过EOF进行多行注释，如下：\r\n\r\n**2、多行注释**\r\n\r\n多行注释还可以使用以下格式：\r\n\r\n```shell\r\n:<<EOF\r\n注释内容...\r\n注释内容...\r\n注释内容...\r\nEOF\r\n```\r\n\r\nEOF 也可以使用其他符号:\r\n\r\n```shell\r\n:<<\'\r\n注释内容...\r\n注释内容...\r\n注释内容...\r\n\'\r\n\r\n:<<!\r\n注释内容...\r\n注释内容...\r\n注释内容...\r\n!\r\n```\r\n\r\n> 总结：\r\n>\r\n> 我们将在下面的小章节中使用注释，查看注释效果\r\n\r\n### 4.3.3 shell变量\r\n\r\n```\r\n引子：\r\n这里的变量我们可以理解为我们在Java SE阶段定义的变量，比如在SE中我定义一个字符串类型的变量使用String stringStr="";\r\n\r\n注意：下面的演示我们还是继续沿用test-shell.sh进行测试\r\n```\r\n\r\n**1、定义变量:**\r\n\r\n```\r\nvariable_name="czbk"\r\n```\r\n\r\n变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：\r\n\r\n- 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。\r\n- 中间不能有空格，可以使用下划线（_）。\r\n- 不能使用标点符号。\r\n- 不能使用bash里的关键字（可用help命令查看保留关键字）。\r\n\r\n有效的 Shell 变量名示例如下：\r\n\r\n```shell\r\nRUNOOB\r\nLD_LIBRARY_PATH\r\n_var\r\nvar2\r\n```\r\n\r\n无效的变量命名：\r\n\r\n```shell\r\n?var=123\r\nuser*name=runoob\r\n```\r\n\r\n------\r\n\r\n**2、使用变量**\r\n\r\n使用一个定义过的变量，只要在变量名前面加美元符号即可，如：\r\n\r\n```shell\r\nvariable_name="czbk"\r\necho $variable_name\r\necho ${variable_name}\r\n```\r\n\r\n 执行效果如下\r\n\r\n![1577175492599](./img/linux/java-linux/Linux-v10-02天-授课/1577175492599.png)\r\n\r\n变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：\r\n\r\n```shell\r\n echo "I am good at ${shell-t}Script"\r\n```\r\n\r\n通过上面的脚本我们发现，如果不给shell-t变量加花括号，写成echo "I am good at $shell-tScript"，解释器shell就会把$shell-tScript当成一个变量，由于我们前面没有定义shell-t变量，那么解释器执行执行的结果自然就为空了。这里我们推荐给所有变量加上花括号，这也是一个好的编程习惯。\r\n\r\n已定义的变量，可以被重新定义，如：\r\n\r\n```shell\r\nyour_name="tom"\r\necho $your_name\r\nyour_name="frank"\r\necho $your_name\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1577175655898](./img/linux/java-linux/Linux-v10-02天-授课/1577175655898.png)\r\n\r\n这样写是合法的，但注意，第二次赋值的时候不能写$your_name="frank"，使用变量的时候才加$。\r\n\r\n**3、只读变量**\r\n\r\n```\r\n这里的只读变量其实有点类似于我们在java se阶段课程中定义的final变量，即在程序的上下文中不允许被程序修改\r\n```\r\n\r\n使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。\r\n\r\n下面的例子尝试更改只读变量，结果报错：\r\n\r\n```shell\r\n#!/bin/bash\r\nmyUrl="https://www.baidu.com"\r\nreadonly myUrl\r\nmyUrl="https://cn.bing.com/"\r\n```\r\n\r\n 执行效果如下图\r\n\r\n![1577175714493](./img/linux/java-linux/Linux-v10-02天-授课/1577175714493.png)\r\n\r\n**4、删除变量**\r\n\r\n使用 unset 命令可以删除变量。语法：\r\n\r\n```\r\nunset variable_name\r\n```\r\n\r\n变量被删除后不能再次使用。unset 命令不能删除只读变量。\r\n\r\n**示例如下**\r\n\r\n```shell\r\n#!/bin/sh\r\nmyUrl="https://www.baidu.com"\r\nunset myUrl\r\necho $myUrl\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1577175804257](./img/linux/java-linux/Linux-v10-02天-授课/1577175804257.png)\r\n\r\n如上面的shell脚本，我们定义了一个myUrl变量，通过unset删除这个变量，然后通过echo进行输出，结果是就是为空，没有任何的结果输出。\r\n\r\n------\r\n\r\n**Shell 字符串**\r\n\r\n```\r\n字符串是shell编程中最常用也是最有用的数据类型，字符串可以用单引号，也可以用双引号，也可以不用引号，正如我们开篇提到的，在Java SE中我们定义一个字符串可以通过Stirng  stringStr=“abc" 双引号的形式进行定义，而在shel中也是可以的。\r\n```\r\n\r\n**单引号**\r\n\r\n```shell\r\nstr=\'this is a string variable\'\r\n```\r\n\r\n单引号字符串的限制：\r\n\r\n- 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；\r\n- 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。\r\n\r\n**双引号**\r\n\r\n```shell\r\nyour_name=\'frank\'\r\nstr="Hello,  \\"$your_name\\"! \\n"\r\necho -e $str\r\n```\r\n\r\n输出结果为：\r\n\r\n![1577175850350](./img/linux/java-linux/Linux-v10-02天-授课/1577175850350.png)\r\n\r\n双引号的优点：\r\n\r\n- 双引号里可以有变量\r\n- 双引号里可以出现转义字符\r\n\r\n**拼接字符串**\r\n\r\n```shell\r\nyour_name="frank"\r\n# 使用双引号拼接\r\ngreeting="hello, "$your_name" !"\r\ngreeting_1="hello, ${your_name} !"\r\necho $greeting  $greeting_1\r\n```\r\n\r\n输出结果为：\r\n\r\n![1577175902317](./img/linux/java-linux/Linux-v10-02天-授课/1577175902317.png)\r\n\r\n**获取字符串长度**\r\n\r\n```shell\r\nstring="czbk"\r\necho ${#string}\r\n```\r\n\r\n输出结果：4.表示长度为4\r\n\r\n![1577175975730](./img/linux/java-linux/Linux-v10-02天-授课/1577175975730.png)\r\n\r\n**提取字符串**\r\n\r\n以下实例从字符串第 **2** 个字符开始截取 **4** 个字符：\r\n\r\n```shell\r\nstring="abcdefghijklmn"\r\necho ${string:1:4} \r\n```\r\n\r\n 执行效果如下\r\n\r\n![1577176031872](./img/linux/java-linux/Linux-v10-02天-授课/1577176031872.png)\r\n\r\n输出为【bcde】，通过截取我们发现，它的下标和我们在java中的读取方式是一样的，下标也是从0开始。\r\n\r\n### 4.3.4 shell数组\r\n\r\n```\r\n这里的数组和我们在Java SE阶段的数组结果（或是性质）是一样的，只是定义的过程大同小异\r\n```\r\n\r\nbash支持一维数组（不支持多维数组），并且没有限定数组的大小。\r\n\r\n**定义数组**\r\n\r\n在 Shell 中，用括号来表示数组，数组元素用"空格"符号分割开。如下：\r\n\r\n```shell\r\n数组名=(值1 值2 ... 值n)\r\n```\r\n\r\n例如：\r\n\r\n```shell\r\narray_name=(value0 value1 value2 value3)\r\n```\r\n\r\n或者\r\n\r\n```shell\r\narray_name=(\r\nvalue0\r\nvalue1\r\nvalue2\r\nvalue3\r\n)\r\n```\r\n\r\n通过下标定义数组中的其中一个元素：\r\n\r\n```shell\r\narray_name[0]=value0\r\narray_name[1]=value1\r\narray_name[n]=valuen\r\n```\r\n\r\n可以不使用连续的下标，而且下标的范围没有限制。\r\n\r\n**读取数组**\r\n\r\n读取数组元素值的一般格式是：\r\n\r\n```shell\r\n${数组名[下标]}\r\n```\r\n\r\n例如：\r\n\r\n```shell\r\nvaluen=${array_name[n]}\r\n```\r\n\r\n使用 **@** 符号可以获取数组中的所有元素，例如：\r\n\r\n```shell\r\necho ${array_name[@]}\r\n```\r\n\r\n**获取数组的长度**\r\n\r\n获取数组长度的方法与获取字符串长度的方法相同，例如：\r\n\r\n```shell\r\n# 取得数组元素的个数\r\nlength=${#array_name[@]}\r\n# 或者\r\nlength=${#array_name[*]}\r\n```\r\n\r\n下面，我们通过一个例子，定义数组、提取数组元素的例子来验证下\r\n\r\n```shell\r\n#! /bin/bash\r\ng=(a b c d e f)\r\necho "数组下标为2的数据为:" ${g[2]}\r\necho  "数组所有数据为:"  ${#g[@]}\r\necho  "数组所有数据为:"   ${#g[*]}\r\n```\r\n\r\n如下\r\n\r\n![1577067300329](./img/linux/java-linux/Linux-v10-02天-授课/1577067300329.png)\r\n\r\n 执行效果如下：\r\n\r\n![1577067402285](./img/linux/java-linux/Linux-v10-02天-授课/1577067402285.png)\r\n\r\n### 4.3.5 shell运算符\r\n\r\n```\r\n我们在前面课程中学习Java SE中也学到了运算符，比如算术、关系、布尔等，而在sehll编程中同样也有运算符，虽然表达的方式不一样，但是最终的目的都是一样的，都是为了解决编程中现存问题\r\n```\r\n\r\nShell 和其他编程一样，**支持**包括：算术、关系、布尔、字符串等运算符。\r\n\r\n原生 bash **不支持 **简单的数学运算，但是可以通过其他命令来实现，例如expr。\r\n\r\nexpr 是一款表达式计算工具，使用它能完成表达式的求值操作。\r\n\r\n例如，两个数相加,我们还是利用上面的例子test-shell.sh \r\n\r\n**1、算数运算符**\r\n\r\n```\r\nval=`expr 2 + 2`\r\necho "相加之后的结果为：" $val\r\n```\r\n\r\n 执行效果如下\r\n\r\n![1577068429739](./img/linux/java-linux/Linux-v10-02天-授课/1577068429739.png)\r\n\r\n注意：\r\n\r\n**表达式和运算符之间要有空格**，例如 2+2 是不对的，必须写成 2 + 2。\r\n\r\n完整的表达式要被 **`** 包含，注意不是单引号。\r\n\r\n下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：\r\n\r\n| **运算符** | **说明**                                      | **举例**                      |\r\n| ---------- | --------------------------------------------- | ----------------------------- |\r\n| +          | 加法                                          | `expr $a + $b` 结果为 30。    |\r\n| -          | 减法                                          | `expr $a - $b` 结果为 -10。   |\r\n| *          | 乘法                                          | `expr $a \\* $b` 结果为  200。 |\r\n| /          | 除法                                          | `expr $b / $a` 结果为 2。     |\r\n| %          | 取余                                          | `expr $b % $a` 结果为 0。     |\r\n| =          | 赋值                                          | a=$b 将把变量 b 的值赋给 a。  |\r\n| ==         | 相等。用于比较两个数字，相同则返回 true。     | [ $a == $b ] 返回 false。     |\r\n| !=         | 不相等。用于比较两个数字，不相同则返回 true。 | [ $a != $b ] 返回 true。      |\r\n\r\n**注意：**条件表达式要放在方括号之间，并且要有空格，例如: **[$a==$b]** 是错误的，必须写成 **[ $a == $b ]**。\r\n\r\n下面是运算符shell脚本（还是采用之前的例子test-shell.sh ）w\r\n\r\n```shell\r\n#! /bin/bash\r\n#g=(a b c d e f)\r\n#echo "数组下标为2的数据为:" ${g[2]}\r\n#echo  "数组所有数据为:"  ${#g[@]}\r\n#echo  "数组所有数据为:"   ${#g[*]}\r\n:<<EOF\r\nval= `expr 2 + 2`\r\necho "相加之后的结果为：" $val\r\nEOF\r\n\r\na=4\r\nb=20\r\necho “加法运算”  `expr $a + $b`\r\necho “减法运算”  `expr $a - $b`\r\necho “乘法运算，注意*号前面需要反斜杠” ` expr $a \\* $b`\r\necho “除法运算”  `expr  $b / $a`\r\n((a++))\r\necho "a = $a"\r\nc=$((a + b)) \r\nd=$[a + b]\r\necho "c = $c"\r\necho "d = $d"\r\n```\r\n\r\n**上面的shell命令#开头的为单行注释**\r\n\r\n**:<<EOF 开头和EOF结尾的为多行注释**\r\n\r\n执行效果如下\r\n\r\n![1577152161538](./img/linux/java-linux/Linux-v10-02天-授课/1577152161538.png)\r\n\r\n**2、字符串运算符**\r\n\r\n下表列出了常用的字符串运算符，假定变量 a 为 "abc"，变量 b 为 "efg"：\r\n\r\n| 运算符 | 说明                                      | 举例                     |\r\n| :----- | :---------------------------------------- | :----------------------- |\r\n| =      | 检测两个字符串是否相等，相等返回 true。   | [ $a = $b ] 返回 false。 |\r\n| !=     | 检测两个字符串是否相等，不相等返回 true。 | [ $a != $b ] 返回 true。 |\r\n| -z     | 检测字符串长度是否为0，为0返回 true。     | [ -z $a ] 返回 false。   |\r\n| -n     | 检测字符串长度是否为0，不为0返回 true。   | [ -n "$a" ] 返回 true。  |\r\n| $      | 检测字符串是否为空，不为空返回 true。     | [ $a ] 返回 true。       |\r\n\r\n**字符串运算符实例如下（还是采用之前的例子test-shell.sh ）：**\r\n\r\n```shell\r\na="abc"\r\nb="efg"\r\n\r\nif [ $a = $b ]\r\nthen\r\n   echo "$a = $b : a 等于 b"\r\nelse\r\n   echo "$a = $b: a 不等于 b"\r\nfi\r\nif [ $a != $b ]\r\nthen\r\n   echo "$a != $b : a 不等于 b"\r\nelse\r\n   echo "$a != $b: a 等于 b"\r\nfi\r\n \r\n```\r\n\r\n 执行效果如下\r\n\r\n![1577158474734](./img/linux/java-linux/Linux-v10-02天-授课/1577158474734.png)\r\n\r\n**3、关系运算符**\r\n\r\n关系运算符只支持数字，不支持字符串，除非字符串的值是数字。\r\n\r\n下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：\r\n\r\n| 运算符 | 说明                                                  | 举例                       |\r\n| :----- | :---------------------------------------------------- | :------------------------- |\r\n| -eq    | 检测两个数是否相等，相等返回 true。                   | [ $a -eq $b ] 返回 false。 |\r\n| -ne    | 检测两个数是否不相等，不相等返回 true。               | [ $a -ne $b ] 返回 true。  |\r\n| -gt    | 检测左边的数是否大于右边的，如果是，则返回 true。     | [ $a -gt $b ] 返回 false。 |\r\n| -lt    | 检测左边的数是否小于右边的，如果是，则返回 true。     | [ $a -lt $b ] 返回 true。  |\r\n| -ge    | 检测左边的数是否大于等于右边的，如果是，则返回 true。 | [ $a -ge $b ] 返回 false。 |\r\n| -le    | 检测左边的数是否小于等于右边的，如果是，则返回 true。 | [ $a -le $b ] 返回 true。  |\r\n\r\n**关系运算符（还是采用之前的例子test-shell.sh ）**\r\n\r\n```shell\r\na=10\r\nb=20\r\n\r\nif [ $a -eq $b ]\r\nthen\r\n   echo "$a -eq $b : a 等于 b"\r\nelse\r\n   echo "$a -eq $b: a 不等于 b"\r\nfi\r\nif [ $a -ne $b ]\r\nthen\r\n   echo "$a -ne $b: a 不等于 b"\r\nelse\r\n   echo "$a -ne $b : a 等于 b"\r\nfi\r\nif [ $a -gt $b ]\r\nthen\r\n   echo "$a -gt $b: a 大于 b"\r\nelse\r\n   echo "$a -gt $b: a 不大于 b"\r\nfi\r\nif [ $a -lt $b ]\r\nthen\r\n   echo "$a -lt $b: a 小于 b"\r\nelse\r\n   echo "$a -lt $b: a 不小于 b"\r\nfi\r\nif [ $a -ge $b ]\r\nthen\r\n   echo "$a -ge $b: a 大于或等于 b"\r\nelse\r\n   echo "$a -ge $b: a 小于 b"\r\nfi\r\nif [ $a -le $b ]\r\nthen\r\n   echo "$a -le $b: a 小于或等于 b"\r\nelse\r\n   echo "$a -le $b: a 大于 b"\r\nfi\r\n```\r\n\r\n执行效果如下：\r\n\r\n![1577169772803](./img/linux/java-linux/Linux-v10-02天-授课/1577169772803.png)\r\n\r\n**4、布尔运算符**\r\n\r\n下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：\r\n\r\n| 运算符 | 说明                                                | 举例                                     |\r\n| :----- | :-------------------------------------------------- | :--------------------------------------- |\r\n| !      | 非运算，表达式为 true 则返回 false，否则返回 true。 | [ ! false ] 返回 true。                  |\r\n| -o     | 或运算，有一个表达式为 true 则返回 true。           | [ $a -lt 20 -o $b -gt 100 ] 返回 true。  |\r\n| -a     | 与运算，两个表达式都为 true 才返回 true。           | [ $a -lt 20 -a $b -gt 100 ] 返回 false。 |\r\n\r\n**布尔运算符实例如下（还是采用之前的例子test-shell.sh ）：**\r\n\r\n```shell\r\na=10\r\nb=20\r\n\r\nif [ $a != $b ]\r\nthen\r\n   echo "$a != $b : a 不等于 b"\r\nelse\r\n   echo "$a == $b: a 等于 b"\r\nfi\r\nif [ $a -lt 100 -a $b -gt 15 ]\r\nthen\r\n   echo "$a 小于 100 且 $b 大于 15 : 返回 true"\r\nelse\r\n   echo "$a 小于 100 且 $b 大于 15 : 返回 false"\r\nfi\r\nif [ $a -lt 100 -o $b -gt 100 ]\r\nthen\r\n   echo "$a 小于 100 或 $b 大于 100 : 返回 true"\r\nelse\r\n   echo "$a 小于 100 或 $b 大于 100 : 返回 false"\r\nfi\r\nif [ $a -lt 5 -o $b -gt 100 ]\r\nthen\r\n   echo "$a 小于 5 或 $b 大于 100 : 返回 true"\r\nelse\r\n   echo "$a 小于 5 或 $b 大于 100 : 返回 false"\r\nfi\r\n\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577170810671](./img/linux/java-linux/Linux-v10-02天-授课/1577170810671.png)\r\n\r\n**5、逻辑运算符**\r\n\r\n假定变量 a 为 10，变量 b 为 20:\r\n\r\n| 运算符 | 说明       | 举例                                       |\r\n| :----- | :--------- | :----------------------------------------- |\r\n| &&     | 逻辑的 AND | [[ $a -lt 100 && $b -gt 100 ]] 返回 false  |\r\n| \\|\\|   | 逻辑的 OR  | [[ $a -lt 100 \\|\\| $b -gt 100 ]] 返回 true |\r\n\r\n**逻辑运算符实例如下（还是采用之前的例子test-shell.sh ）：** \r\n\r\n```shell\r\na=10\r\nb=20\r\n\r\nif [[ $a -lt 100 && $b -gt 100 ]]\r\nthen\r\n   echo "返回 true"\r\nelse\r\n   echo "返回 false"\r\nfi\r\n\r\nif [[ $a -lt 100 || $b -gt 100 ]]\r\nthen\r\n   echo "返回 true"\r\nelse\r\n   echo "返回 false"\r\nfi\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577171478166](./img/linux/java-linux/Linux-v10-02天-授课/1577171478166.png)\r\n\r\n\r\n\r\n### 4.3.6 shell流程控制\r\n\r\n```\r\n在前面的Java SE课程中，我们学习了很多的流程控制语句，比如有if-else、if else-if else、switch、for、while等语句；\r\n在shell编程中，我们同样也有这些流程控制，只是语法和java SE有所区别，但是目的是一样的。\r\n```\r\n\r\n**1、if 语句：**\r\n\r\n**主要用于判断，相当于java se中的if，我们还是采用之前的例子test-shell.sh**\r\n\r\n```shell\r\nif condition\r\nthen\r\n    command1 \r\n    command2\r\n    ...\r\n    commandN \r\nfi\r\n```\r\n\r\n 比如，我们现在通过前面学习的知识查找一个进程，如果进程存在就打印true\r\n\r\n```shell\r\nif [ $(ps -ef | grep -c "ssh") -gt 1 ]; then echo "true"; fi\r\n```\r\n\r\n> 注意\r\n>\r\n> 末尾的fi就是if倒过来拼写\r\n\r\n执行效果如下\r\n\r\n![1577174880068](./img/linux/java-linux/Linux-v10-02天-授课/1577174880068.png)\r\n\r\n**2、if else 语句：**\r\n\r\n**主要用于判断，相当于java se中的if else，我们还是采用之前的例子test-shell.sh。**\r\n\r\n```shell\r\nif condition\r\nthen\r\n    command1 \r\n    command2\r\n    ...\r\n    commandN\r\nelse\r\n    command\r\nfi\r\n```\r\n\r\n上接上面的例子，如果找不到sshAAA**（此处可以随便输入一个）**进程，我们就打印false\r\n\r\n```shell\r\nif [ $(ps -ef | grep -c "sshAAA") -gt 1 ]; then echo "true";  else echo "false"; fi\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577175009088](./img/linux/java-linux/Linux-v10-02天-授课/1577175009088.png)\r\n\r\n**3、if else-if else 语句：**\r\n\r\n**主要用于判断，相当于java se中的if else-if else**\r\n\r\n```shell\r\nif condition1\r\nthen\r\n    command1\r\nelif condition2 \r\nthen \r\n    command2\r\nelse\r\n    commandN\r\nfi\r\n```\r\n\r\n以下实例判断两个变量是否相等\r\n\r\n我们继续使用上面的例子（test-shell.sh ）\r\n\r\n```shell\r\na=10\r\nb=20\r\nif [ $a == $b ]\r\nthen\r\n   echo "a 等于 b"\r\nelif [ $a -gt $b ]\r\nthen\r\n   echo "a 大于 b"\r\nelif [ $a -lt $b ]\r\nthen\r\n   echo "a 小于 b"\r\nelse\r\n   echo "没有符合的条件"\r\nfi\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577152946471](./img/linux/java-linux/Linux-v10-02天-授课/1577152946471.png)\r\n\r\n**4、for 循环**\r\n\r\n**主要用于循环，相当于java se中的for循环，我们还是采用之前的例子test-shell.sh**\r\n\r\nfor循环格式为\r\n\r\n```shell\r\nfor var in item1 item2 ... itemN\r\ndo\r\n    command1\r\n    command2\r\n    ...\r\n    commandN\r\ndone\r\n```\r\n\r\n顺序输出当前列表中的字母：\r\n\r\n```shell\r\nfor loop in A B C D E F G \r\ndo\r\n    echo "顺序输出字母为: $loop"\r\ndone\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577153230698](./img/linux/java-linux/Linux-v10-02天-授课/1577153230698.png)\r\n\r\n\r\n\r\n**5、while循环**\r\n\r\n主要用于循环，相当于java se中的while循环\r\n\r\nwhile循环用于不断执行一系列命令，也用于从输入文件中读取数据 \r\n\r\n语法格式为\r\n\r\n```\r\nwhile condition\r\ndo\r\n    command\r\ndone\r\n```\r\n\r\n以下是一个基本的while循环，测试条件是：如果int小于等于10，那么条件返回真。int从0开始，每次循环处理时，int加1。 \r\n\r\n还是采用之前的例子test-shell.sh\r\n\r\n```shell\r\n#!/bin/bash\r\nint=1\r\nwhile(( $int<=10 ))\r\ndo\r\n    echo "输出的值为："$int\r\n    let "int++"\r\ndone\r\n```\r\n\r\n执行效果如下图\r\n\r\n**![1577153468616](./img/linux/java-linux/Linux-v10-02天-授课/1577153468616.png)**\r\n\r\n**6、case ... esac语句**\r\n\r\n**主要用于分支条件选择，相当于java se中的switch case循环**\r\n\r\n**case ... esac** 与其他语言中的 switch ... case 语句类似，是一种多分枝选择结构，每个 case 分支用右圆括号开始，用两个分号 **;;** 表示 break，即执行结束，跳出整个 case ... esac 语句，esac（就是 case 反过来）作为结束标记。\r\n\r\n还是采用之前的例子test-shell.sh\r\n\r\ncase ... esac 语法格式如下：\r\n\r\n```shell\r\ncase 值 in\r\n模式1)\r\n    command1\r\n    command2\r\n    command3\r\n    ;;\r\n模式2）\r\n    command1\r\n    command2\r\n    command3\r\n    ;;\r\n*)\r\n    command1\r\n    command2\r\n    command3\r\n    ;;\r\nesac\r\n```\r\n\r\ncase 后为取值，值可以为变量或常数。\r\n\r\n值后为关键字 in，接下来是匹配的各种模式，每一模式最后必须以右括号结束，模式支持正则表达式。\r\n\r\n下面通过v的值进行case--esac\r\n\r\n```shell\r\nv="czbk"\r\n\r\ncase "$v" in\r\n   "czbk") echo "传智播客"\r\n   ;;\r\n   "baidu") echo "baidu 搜索"\r\n   ;;\r\n   "google") echo "google 搜索"\r\n   ;;\r\nesac\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577153795748](./img/linux/java-linux/Linux-v10-02天-授课/1577153795748.png)\r\n\r\n\r\n\r\n### 4.3.7 shell函数\r\n\r\n```\r\n我们将要学习的shell函数，我们可以理解成在Java SE阶段我们学习的方法，它和shell函数的作用是一样的。\r\n```\r\n\r\n函数语法如下：\r\n\r\n```shell\r\n[ function ] funname [()]\r\n\r\n{\r\n\r\n    action;\r\n\r\n    [return int;]\r\n\r\n}\r\n```\r\n\r\n> 注意：\r\n>\r\n> - 1、可以使用function fun() 定义函数，也可以直接fun() 定义,不带任何参数。\r\n> - 2、函数参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255\r\n\r\n下面我们将定义一个函数，并发生函数调用\r\n\r\n还是采用之前的例子test-shell.sh\r\n\r\n```shell\r\n#!/bin/bash\r\n\r\nczbk(){\r\n    echo "这是第一个函数!"\r\n}\r\necho "-----这里是函数开始执行-----"\r\nczbk\r\necho "-----这里是函数执行完毕-----"\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1577159360606](./img/linux/java-linux/Linux-v10-02天-授课/1577159360606.png)\r\n\r\n下面，我们定义一个带有return语句的函数：\r\n\r\n```shell\r\nfunction czbk(){\r\n    echo "对输入的两个数字进行相加运算..."\r\n    echo "输入第一个数字: "\r\n    read aNum\r\n    echo "输入第二个数字: "\r\n    read anotherNum\r\n    echo "两个数字分别为 $aNum 和 $anotherNum !"\r\n    return $(($aNum+$anotherNum))\r\n}\r\nczbk\r\necho "输入的两个数字之和为 $? !"\r\n```\r\n\r\n> 注意：\r\n>\r\n> 函数返回值在调用该函数后通过 $? 来获得。\r\n>\r\n> 注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。\r\n\r\n### 4.3.8 总结\r\n\r\n在企业级开发过程中，我们（开发人员）学习Linux主要的目的就是在Linux系统中能够熟练的操作目录、文件，还有就是通过所学的命令系统化的编写sh文件，所以，在当前章节中，我们要熟练的编写shell脚本相关命令以及综合案例中的知识点。',sr={data:function(){return{MainComponent:ir}}},ar=sr,or=Object(p["a"])(ar,er,tr,!1,null,"6442f8de",null),lr=or.exports,pr={components:{m1:rr,m2:lr},data:function(){return{tab:"m1",tabs:[{label:"Linux-v10-01天",value:"m1"},{label:"Linux-v10-02天",value:"m2"}]}}},cr=pr,dr=Object(p["a"])(cr,Kn,Qn,!1,null,"2965940c",null),ur=dr.exports,mr=function(){var n=this,r=n.$createElement,e=n._self._c||r;return e("div",[e("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}})],1)},gr=[],_r=e("3686"),hr="/books/linux/other/",vr=Object(_r["a"])(e("9f1b"),"md",!0),xr=vr.all_components,fr=vr.all_modules,br={mixins:[I["c"],I["b"]],data:function(){return{relative_path:hr,img_prefix:"."+hr,tab:fr[0].value,tab_level:2,MainComponent:xr[fr[0].value],tabs:fr}},watch:{tab:function(n,r){this.MainComponent=xr[this.tab],this.compute_img_prefix()}}},wr=br,Lr=Object(p["a"])(wr,mr,gr,!1,null,"c907a934",null),Cr=Lr.exports,kr=function(){var n=this,r=n.$createElement,e=n._self._c||r;return e("div",[n.MainComponent?e("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}}):e(""+n.tab,{tag:"component"})],1)},yr=[],Pr=(e("99af"),e("448a")),Sr=e.n(Pr),Ir=function(){var n=this,r=n.$createElement,e=n._self._c||r;return e("div",[e("div",{staticClass:"row  "},[e("q-select",{attrs:{"use-input":"","input-debounce":"0",clearable:"",options:n.book_options},on:{filter:n.filterFn},model:{value:n.book,callback:function(r){n.book=r},expression:"book"}},[e("template",{slot:"before"},[e("div")])],2)],1),e("div",{staticClass:"q-pdfviewer-container   "},[e("q-pdfviewer",{attrs:{src:n.src,type:"html5","content-class":" fit   q-pdfviewer-container","inner-content-class":" fit   q-pdfviewer-container"},model:{value:n.show,callback:function(r){n.show=r},expression:"show"}})],1)])},Rr=[],Ur=["/020_尚硅谷-Linux云计算-网络服务-Nginx-合并PDF.pdf"],Er="linux/nginx/pdf",Ar={mixins:[I["d"]],data:function(){return{prefix:Er,book_options:Ur,show:!0,book:Ur[0],src:""}}},Mr=Ar,Tr=Object(p["a"])(Mr,Ir,Rr,!1,null,null,null),Dr=Tr.exports,Or="/books/linux/nginx/",Nr=Object(_r["a"])(e("105b"),"md",!0),jr=Nr.all_components,zr=Nr.all_modules,$r={mixins:[I["c"],I["b"]],components:{m1:Dr},data:function(){return{relative_path:Or,img_prefix:"."+Or,tab:zr[0].value,MainComponent:jr[zr[0].value],tab_level:2,tabs:[{label:"nginx-pdf",value:"m1"}].concat(Sr()(zr))}},watch:{tab:function(n,r){this.MainComponent=jr[this.tab],this.compute_img_prefix()}}},Br=$r,qr=Object(p["a"])(Br,kr,yr,!1,null,"7017e976",null),Fr=qr.exports,Hr={mixins:[I["c"]],components:{m1:d,m2:x,m3:y,m4:T,m5:$,m6:G,m7:J,m8:an,m9:un,m10:xn,m13:yn,m16:Gn,m18:ur,m19:An,m99:Cr,m100:Fr},data:function(){return{tab:"m1",tabs:[{label:"笔记",value:"m6"},{label:"linux-目录",value:"m13"},{label:"linux命令",value:"m1"},{label:"调度+进程",value:"m7"},{label:"YUM+LAMP",value:"m19"},{label:"黑马云计算",value:"m16"},{label:"linux-备忘",value:"m2"},{label:"shell-基础",value:"m3"},{label:"运维书籍",value:"m4"},{label:"Linux—前端",value:"m5"},{label:"Linux—java",value:"m18"},{label:"前端运维",value:"m8"},{label:"日常运维",value:"m9"},{label:"Nginx",value:"m100"},{label:"其他",value:"m99"}]}}},Wr=Hr,Gr=Object(p["a"])(Wr,t,i,!1,null,"e207bbd4",null);r["default"]=Gr.exports},f0ba:function(n,r,e){},f10a:function(n,r,e){"use strict";e.r(r),r["default"]='# ***\\*Linux调度系统全景指南(中篇)\\****\r\n\r\n \r\n\r\n \r\n\r\n| 导语本文主要是讲Linux的调度系统, 由于全部内容太多，分三部分来讲，本篇是中篇（主要讲抢占和时钟），上篇请看（CPU和中断）：[Linux调度系统全景指南(上篇)](#wechat_redirect)，调度可以说是操作系统的灵魂，为了让CPU资源利用最大化，Linux设计了一套非常精细的调度系统，对大多数场景都进行了很多优化，系统扩展性强，我们可以根据业务模型和业务场景的特点，有针对性的去进行性能优化，在保证客户网络带宽前提下，隔离客户互相之间的干扰影响，提高CPU利用率，降低单位运算成本，提高市场竞争力。欢迎大家相互交流学习！\r\n\r\n \r\n\r\n​               **目录**\r\n\r\n![img](10.Linux调度系统全景指南(中篇).assets/wps240C.tmp.jpg) \r\n\r\n \r\n\r\n![img](10.Linux调度系统全景指南(中篇).assets/wps241D.tmp.png) \r\n\r\n \r\n\r\n上篇请看（CPU和中断）：[Linux调度系统全景指南(上篇)](#wechat_redirect)\r\n\r\n​               \r\n\r\n​                  **抢占**\r\n\r\n![img](10.Linux调度系统全景指南(中篇).assets/wps241E.tmp.png) \r\n\r\n \r\n\r\n \r\n\r\n早期的Linux核心是不可抢占的。它的调度方法是：一个进程可以通过schedule()函数自愿地启动一次调度。非自愿的强制性调度只能发生在每次从系统调用返回的前夕，以及每次从中断或异常处理返回到用户空间的前夕。但是，如果在系统空间发生中断或异常是不会引起调度的。这种方式使内核实现得以简化。但常存在下面两个问题：\r\n\r\n \r\n\r\n![img](10.Linux调度系统全景指南(中篇).assets/wps241F.tmp.png) \r\n\r\n \r\n\r\n\\1. \r\n\r\n如果这样的中断发生在内核中，本次中断返回是不会引起调度的，而要到最初使CPU从用户空间进入内核空间的那次系统调用或中断(异常)返回时才会发生调度。\r\n\r\n\\2. \r\n\r\n\\3. \r\n\r\n\\4. \r\n\r\n\\5. \r\n\r\n另外一个问题是优先级反转。在Linux中，在核心态运行的任何操作都要优先于用户态进程，这就有可能导致优先级反转问题的出现。例如，一个低优先级的用户进程由于执行软/硬中断等原因而导致一个高优先级的任务得不到及时响应。\r\n\r\n\\6. \r\n\r\n \r\n\r\n\\7. \r\n\r\n当前的Linux内核加入了内核抢占(preempt)机制。内核抢占指用户程序在执行系统调用期间可以被抢占，该进程暂时挂起，使新唤醒的高优先级进程能够运行。这种抢占并非可以在内核中任意位置都能安全进行，比如在临界区中的代码就不能发生抢占。临界区是指同一时间内不可以有超过一个进程在其中执行的指令序列。在Linux内核中这些部分需要用自旋锁保护。\r\n\r\n \r\n\r\n内核抢占要求内核中所有可能为一个以上进程共享的变量和数据结构就都要通过互斥机制加以保护，或者说都要放在临界区中。在抢占式内核中，认为如果内核不是在一个中断处理程序中，并且不在被 spinlock等互斥机制保护的临界代码中，就认为可以"安全"地进行进程切换。\r\n\r\n \r\n\r\nLinux内核将临界代码都加了互斥机制进行保护，同时，还在运行时间过长的代码路径上插入调度检查点，打断过长的执行路径，这样，任务可快速切换进程状态，也为内核抢占做好了准备，抢占分为用户抢占和内核抢占，linux抢占发生的时机：\r\n\r\n \r\n\r\n![img](10.Linux调度系统全景指南(中篇).assets/wps2420.tmp.jpg) \r\n\r\n \r\n\r\n用户抢占在以下情况下产生：\r\n\r\n \r\n\r\n· \r\n\r\n从系统调用返回用户空间\r\n\r\n· \r\n\r\n· \r\n\r\n从中断处理程序返回用户空间\r\n\r\n· \r\n\r\n· \r\n\r\n内核抢占会发生在：\r\n\r\n \r\n\r\n· \r\n\r\n当从中断处理程序返回内核空间的时候，且当时内核具有可抢占性；\r\n\r\n· \r\n\r\n· \r\n\r\n当内核代码再一次具有可抢占性的时候（如:spin_unlock时）；\r\n\r\n· \r\n\r\n· \r\n\r\n如果内核中的任务显式的调用schedule()；\r\n\r\n· \r\n\r\n· \r\n\r\n如果内核中的任务阻塞。\r\n\r\n· \r\n\r\n \r\n\r\n \r\n\r\n​               \r\n\r\n#                  **时钟**\r\n\r\n![img](10.Linux调度系统全景指南(中篇).assets/wps2421.tmp.jpg) \r\n\r\n  \r\n\r\n \r\n\r\n \r\n\r\n计算机最基本的时间单元是时钟周期，例如取指令、执行指令、存取内存等, CPU执行指令需求时钟来同步和推进。时间系统是计算机系统非常重要的组成部分，所有信息包括系统时间、进程的时间片、延时、使用CPU的时间、各种定时器，进程更新后的时间片为进程调度提供依据，也就是驱动进程的调度，任务调度与时钟的关系非常密切。\r\n\r\n \r\n\r\n \r\n\r\n### **时钟芯片**\r\n\r\n \r\n\r\n时钟芯片主要是提供时间源， 一般在一个计算机系统中存在三个时间发生器，一个用于记录日期时间的，它就是利用电池进行供电的一个单独芯片——RTC，第二个是PIT(可编程间隔定时器），第三个是TSC时间戳计数器，而PIT就是产生IRQ0的定时器芯片。而进行校正的就是利用TSC计数器，它在每个clock-cycle就会自动加一，不需要CPU操作，所以每个时钟中断产生时都可以利用一个全局变量记录下TSC的值，在下次时钟中断时再用这个全局变量校正jieffis的值，这样就可以记录精准的时间（TSC计数器是纳秒级的）。\r\n  \r\n\r\n![img](10.Linux调度系统全景指南(中篇).assets/wps2422.tmp.png) \r\n\r\n \r\n\r\n操作系统对可编程定时/计数器进行有关初始化，然后定时/计数器就对输入脉冲进行计数（分频），产生的三个输出脉冲Out0、Out1、Out2各有用途，很多书都介绍了这个问题，我们只看Out0上的输出脉冲，这个脉冲信号接到中断控制器8259A_1的0号管脚，触发一个周期性的中断，我们就把这个中断叫做时钟中断，时钟中断的周期，也就是脉冲信号的周期，我们叫做“滴答”或“时标”（tick）。时钟与 CPU 和系统总线相关的每一个操作都是由一个恒定速率的内部时钟脉冲来进行同步的。机器指令的基本时间单位是机器周期 (machine cycle) 或时钟周期 (clock cycle) 。\r\n\r\n \r\n\r\n \r\n\r\n### **时钟中断**\r\n\r\n \r\n\r\n“时钟中断”是特别重要的一个中断，因为整个操作系统的活动都受到它的激励。系统利用时钟中断维持系统时间、促使环境的切换，以保证所有进程共享CPU；利用时钟中断进行记帐、监督系统工作以及确定未来的调度优先级等工作。可以说，“时钟中断”是整个操作系统的脉搏。\r\n\r\n \r\n\r\n![img](10.Linux调度系统全景指南(中篇).assets/wps2423.tmp.png) \r\n\r\n \r\n\r\n从本质上来说，时钟中断只是一个周期性的信号，完全是硬件行为，该信号触发CPU去执行一个中断服务程序，在Linux的0号中断是一个时钟中断。在固定的时间间隔都发生一次中断，也就是说，每秒发生该中断的频率都是固定的。该频率是常量HZ，该值一般是在100 ~ 1000之间。该中断的作用是为了定时更新系统日期和时间，使系统时间不断地得到跳转。另外该中断的中断处理函数除了更新系统时间外，还需要更新本地CPU统计数。比如更新任务的调度时间片，若递减到0，则被调度出去而放弃CPU使用权。\r\n\r\n \r\n\r\n \r\n\r\n### **时钟框架**\r\n\r\n \r\n\r\n时钟芯片提供节拍（tick），Linux系统设计一套时钟软件系统，满足应用对时间的各种需求：比如时间片调度，系统时间，日期，定时器，睡眠等：\r\n\r\n \r\n\r\n![img](10.Linux调度系统全景指南(中篇).assets/wps2424.tmp.jpg) \r\n\r\n​              Linux中的时间运作机制\r\n\r\n \r\n\r\n \r\n\r\n**Linux时间系统实现**\r\n\r\n   \r\n\r\n![img](10.Linux调度系统全景指南(中篇).assets/wps2425.tmp.jpg) \r\n\r\n \r\n\r\n \r\n\r\n内核对相关的时间硬件设备进行了统一的封装，定义了主要有下面两个结构：\r\n\r\n时钟源设备(closk source device)：抽象那些能够提供计时功能的系统硬件，比如 RTC(Real Time Clock)、TSC(Time Stamp Counter)，HPET，ACPI PM-Timer，PIT等。不同时钟源提供的精度不一样，现在pc大都支持高精度模式(high-resolution mode)，也支持低精度模式(low-resolution mode)。\r\n\r\n时钟事件设备(clock event device)：系统中可以触发 one-shot（单次）或者周期性中断的设备都可以作为时钟事件设备。\r\n\r\n \r\n\r\n**定时Timer**\r\n\r\n \r\n\r\n这类timer每个cpu都有一个独立的，称为local timer。这类timer的中断一般都是PPI（Private Peripheral Interrupt）类型，即每个cpu都有独立一份中断。与PPI对应的是SPI（Shared Peripheral Interrupt，即多个cpu共享同一个中断。\r\n\r\n \r\n\r\n这类timer一般是32bit宽度count，最重要的它会频繁的溢出并产生timer到期中断。\r\n\r\n这类timer服务于tick timer(低精度)或者hrtimer(高精度)。\r\n\r\n \r\n\r\n· \r\n\r\n低精度模式，local timer工作在PERIODIC模式。即timer以tick时间(1/HZ)周期性的产生中断。在tick timer中处理任务调度tick、低精度timer、其他时间更新和统计profile。在这种模式下，所有利用时间的进行的运算，精度都是以tick(1/HZ)为单位的，精度较低。比如HZ=1000，那么tick=1ms。\r\n\r\n· \r\n\r\n \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n高精度模式，local timer工作在ONESHOT模式。即系统可以支持hrtimer(high resolution)高精度timer，精度为local timer的计数clk达到ns级别。这种情况下把tick timer也转换成一种hrtimer。\r\n\r\n· \r\n\r\n \r\n\r\n· \r\n\r\n**时间戳Timer**\r\n\r\n \r\n\r\n![img](10.Linux调度系统全景指南(中篇).assets/wps2436.tmp.png) \r\n\r\n \r\n\r\n· \r\n\r\n这类timer一个系统多个cpu共享一个，称为global timer。\r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n这类timer一般是32bit/64bit宽度count，一般不会溢出产生中断，系统实时的去读取count的值来计算当前的时间戳。\r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n这类timer服务于clocksource/timekeeper。\r\n\r\n· \r\n\r\n \r\n\r\n· \r\n\r\ntimerwheel实现依赖基于系统tick周期性中断，高精度时钟定时器不在依赖系统的tick中断，而是基于事件触发，内核启动后会进行从低精度模式到高精度时钟模式的切换，hrtimer模拟的tick中断将驱动传统的低精度定时器系统（基于时间轮）和内核进程调度。\r\n\r\n \r\n\r\n \r\n\r\n**低精度timer**\r\n\r\n​    \r\n\r\n![img](10.Linux调度系统全景指南(中篇).assets/wps2437.tmp.png) \r\n\r\n​              时间轮算法\r\n\r\n  \r\n\r\n![img](10.Linux调度系统全景指南(中篇).assets/wps2438.tmp.png) \r\n\r\n \r\n\r\n​               Linux 时间轮定时器\r\n\r\n \r\n\r\n· \r\n\r\nLinux定时器时间轮分为5个级别的轮子(tv1 ~ tv5)，如图3所示。每个级别的轮子的刻度值(slot)不同，规律是次级轮子的slot等于上级轮子的slot之和。Linux定时器slot单位为1jiffy，tv1轮子分256个刻度，每个刻度大小为1jiffy。tv2轮子分64个刻度，每个刻度大小为256个jiffy，即tv1整个轮子所能表达的范围。相邻轮子也只有满足这个规律，才能达到“低刻度轮子转一圈，高刻度轮子走一格”的效果。tv3，tv4，tv5也都是分为64个刻度，因此容易算出，最高一级轮子tv5所能表达的slot范围达到了25664646464 = 2^32 jiffies。\r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n基于时间轮 (Timing-Wheel) 方式实现的定时器， timer wheel只能支持ms级别的精度， 虽然大部分时间里，时间轮可以实现O(1)时间复杂度，但是当有进位发生时，不可预测的O(N)定时器级联迁移时间，这对于低分辨率定时器来说问题不大，可是它大大地影响了定时器的精度。低分辨率定时器几乎是为“超时”而设计的，并为此对它进行了大量的优化，对于这些以“超时”未目的而使用定时器，它们大多数期望在超时到来之前获得正确的结果，然后删除定时器，精确时间并不是它们主要的目的，例如网络通信、设备IO等等。\r\n\r\n· \r\n\r\n \r\n\r\n \r\n\r\n**高精度定时器Hrtimer**\r\n\r\n​             \r\n\r\n![img](10.Linux调度系统全景指南(中篇).assets/wps2439.tmp.png) \r\n\r\n \r\n\r\n· \r\n\r\nhrtimer采用红黑树进行高精度定时器的管理， 通过将高精度时钟硬件的下次中断触发时间设置为红黑树中最早到期的 Timer 的时间，时钟到期后从红黑树中得到下一个 Timer 的到期时间，并设置硬件，如此循环反复。\r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n· \r\n\r\n在高精度时钟模式下，操作系统内核仍然需要周期性的tick中断，以便刷新内核的一些任务。前面可以知道， hrtimer是基于事件的，不会周期性出发tick中断，所以为了实现周期性的tick中断(dynamic tick)：系统创建了一个模拟 tick 时钟的特殊 hrtimer，将其超时时间设置为一个tick时长，在超时回来后，完成对应的工作，然后再次设置下一个tick的超时时间，以此达到周期性tick中断的需求。引入了dynamic tick，是为了能够在使用高精度时钟的同时节约能源,，这样在产生tickless 情况下，会跳过一些 tick。\r\n\r\n· \r\n\r\n '},f1b8:function(n,r,e){"use strict";e.r(r),r["default"]='# ***\\*Linux问题分析与性能优化\\****\r\n\r\n极客重生 [极客重生](https://mp.weixin.qq.com/javascript:void(0);) 8/20\r\n\r\n \r\n\r\n## 排查顺序\r\n\r\n整体情况：\r\n\r\n1. `top/htop/atop`命令查看进程/线程、CPU、内存使用情况，CPU使用情况；\r\n2. `dstat 2`查看CPU、磁盘IO、网络IO、换页、中断、切换，系统I/O状态;\r\n3. `vmstat 2`查看内存使用情况，内存状态；\r\n4. `iostat -d -x 2`查看所有磁盘的IO情况，系统I/O状态；\r\n5. `iotop`查看IO靠前的进程，系统的I/O状态；\r\n6. `perf top`查看占用CPU最多的函数，CPU使用情况；\r\n7. `perf record -ag -- sleep 15;perf report`查看CPU事件占比，调用栈，CPU使用情况；\r\n8. `sar -n DEV 2`查看网卡的吞吐，网卡状态；\r\n9. `/usr/share/bcc/tools/filetop -C`查看每个文件的读写情况，系统的I/O状态；\r\n10. `/usr/share/bcc/tools/opensnoop`显示正在被打开的文件，系统的I/O状态；\r\n11. `mpstat -P ALL 1 `单核CPU是否被打爆；\r\n12. `ps aux --sort=-%cpu `按CPU使用率排序，找出CPU消耗最多进程；\r\n13.  `ps -eo pid,comm,rss | awk \'{m=$3/1e6;s["*"]+=m;s[$2]+=m} END{for (n in s) printf"%10.3f GB %s\\n",s[n],n}\' | sort -nr | head -20 `统计前20内存占用`；`\r\n14. `awk \'NF>3{s["*"]+=s[$1]=$3*$4/1e6} END{for (n in s) printf"%10.1f MB  %s\\n",s[n],n}\' /proc/slabinfo | sort -nr | head -20 ` 统计内核前20slab的占用；\r\n\r\n进程分析，进程占用的资源：\r\n\r\n1. `pidstat 2 -p 进程号`查看可疑进程CPU使用率变化情况；\r\n2. `pidstat -w -p 进程号 2`查看可疑进程的上下文切换情况；\r\n3. `pidstat -d -p 进程号 2`查看可疑进程的IO情况；\r\n4. `lsof -p 进程号`查看进程打开的文件；\r\n5. `strace -f -T -tt -p 进程号`显示进程发起的系统调用；\r\n\r\n协议栈分析，连接/协议栈状态：\r\n\r\n1. `ethtool -S `查看网卡硬件情况；\r\n2. `cat /proc/net/softnet_stat/ifconfig eth1 `查看网卡驱动情况；\r\n3. `netstat -nat|awk \'{print awk $NF}\'|sort|uniq -c|sort -n查看连接状态分布；`\r\n4. `ss -ntp`或者`netstat -ntp`查看连接队列；\r\n5. `netstat -s `查看协议栈情况；\r\n\r\n## ***\\*方法论\\****\r\n\r\nRED方法：监控服务的请求数（Rate）、错误数（Errors）、响应时间（Duration）。Weave Cloud在监控微服务性能时提出的思路。\r\n\r\nUSE方法：监控系统资源的使用率（Utilization）、饱和度（Saturation）、错误数（Errors）。\r\n\r\n![img](12.Linux问题分析与性能优化.assets/wpsFEE2.tmp.png) \r\n\r\n## ***\\*性能分析工具\\****\r\n\r\n![img](12.Linux问题分析与性能优化.assets/wpsFEF3.tmp.png) \r\n\r\n \r\n\r\nLinux 内核的各个子系统出发，汇总了对各个子系统进行性能分析时，你可以选择的工具。不过，虽然这个图是性能分析最好的参考资料之一，它其实还不够具体。比如，当你需要查看某个性能指标时，这张图里对应的子系统部分，可能有多个性能工具可供选择。但实际上，并非所有这些工具都适用，具体要用哪个，还需要你去查找每个工具的手册，对比分析做出选择。\r\n\r\n \r\n\r\n## ***\\*CPU分析思路\\****\r\n\r\n首先，从 CPU 的角度来说，主要的性能指标就是 CPU 的使用率、上下文切换以及 CPU Cache 的命中率等。下面这张图就列出了常见的 CPU 性能指标。\r\n\r\n![img](12.Linux问题分析与性能优化.assets/wpsFEF4.tmp.png) \r\n\r\n \r\n\r\n![img](12.Linux问题分析与性能优化.assets/wpsFEF5.tmp.png) \r\n\r\n \r\n\r\n \r\n\r\n![img](12.Linux问题分析与性能优化.assets/wpsFEF6.tmp.png) \r\n\r\n \r\n\r\n## ***\\*内存分析思路\\****\r\n\r\n接着我们来看内存方面。从内存的角度来说，主要的性能指标，就是系统内存的分配和使用、进程内存的分配和使用以及 SWAP 的用量。下面这张图列出了常见的内存性能指标。\r\n\r\n![img](12.Linux问题分析与性能优化.assets/wpsFF07.tmp.png) \r\n\r\n \r\n\r\n![img](12.Linux问题分析与性能优化.assets/wpsFF08.tmp.png) \r\n\r\n \r\n\r\n## ***\\*IO分析思路\\****\r\n\r\n从文件系统和磁盘 I/O 的角度来说，主要性能指标，就是文件系统的使用、缓存和缓冲区的使用，以及磁盘 I/O 的使用率、吞吐量和延迟等。下面这张图列出了常见的 I/O 性能指标。\r\n\r\n \r\n\r\n![img](12.Linux问题分析与性能优化.assets/wpsFF09.tmp.jpg) \r\n\r\n \r\n\r\n \r\n\r\n![img](12.Linux问题分析与性能优化.assets/wpsFF0A.tmp.png) \r\n\r\n \r\n\r\n![img](12.Linux问题分析与性能优化.assets/wpsFF0B.tmp.png) \r\n\r\n## ***\\*网络分析思路\\****\r\n\r\n从网络的角度来说，主要性能指标就是吞吐量、响应时间、连接数、丢包数等。根据 TCP/IP 网络协议栈的原理，我们可以把这些性能指标，进一步细化为每层协议的具体指标。这里我同样用一张图，分别从链路层、网络层、传输层和应用层，列出了各层的主要指标。\r\n\r\n![img](12.Linux问题分析与性能优化.assets/wpsFF1B.tmp.png) \r\n\r\n \r\n\r\n![img](12.Linux问题分析与性能优化.assets/wpsFF1C.tmp.png) \r\n\r\n \r\n\r\n \r\n\r\n![img](12.Linux问题分析与性能优化.assets/wpsFF1D.tmp.png) \r\n\r\n## ***\\*基准测试工具\\****\r\n\r\n除了性能分析外，很多时候，我们还需要对系统性能进行基准测试。比如，\r\n\r\n· \r\n\r\n在文件系统和磁盘 I/O 模块中，我们使用 fio 工具，测试了磁盘 I/O 的性能。\r\n\r\n· \r\n\r\n· \r\n\r\n在网络模块中，我们使用 iperf、pktgen 等，测试了网络的性能。\r\n\r\n· \r\n\r\n· \r\n\r\n而在很多基于 Nginx 的案例中，我们则使用 ab、wrk 等，测试 Nginx 应用的性能。\r\n\r\n· \r\n\r\n![img](12.Linux问题分析与性能优化.assets/wpsFF1E.tmp.png) \r\n\r\n## ***\\*参考\\****\r\n\r\n· \r\n\r\n相当一部分内容来自极客时间出品的倪鹏飞专栏《Linux性能优化》, 这是之前这个专栏的学习笔记。\r\n\r\n· \r\n\r\n· \r\n\r\n另一份资料是IBM红宝书Linux性能调优指南。\r\n\r\n· \r\n\r\n· \r\n\r\n此外，The Linux Documentation Project是一个非常好的资料库。\r\n\r\n· \r\n\r\n· \r\n\r\n将硬件中断的处理任务分配个多个CPU：SMP affinity and proper interrupt handling in Linux\r\n\r\n· \r\n\r\n· \r\n\r\nHidden Costs of Memory Allocation\r\n\r\n· \r\n\r\n· \r\n\r\nhttps://www.lijiaocn.com/soft/linux/\r\n\r\n· \r\n\r\n '}}]);