(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[1],{"1b62":function(n,t,r){"use strict";r.d(t,"d",(function(){return i})),r.d(t,"c",(function(){return u})),r.d(t,"a",(function(){return v})),r.d(t,"b",(function(){return S})),r("4de4"),r("c975");var e=r("448a"),a=r.n(e),o=["/第1阶段-运维基本功（升级7.6版本）/01运维概述与Linux系统安装.pdf","/第1阶段-运维基本功（升级7.6版本）/02Linux基础命令.pdf"],s="linux/heima-Linux云计算",i={name:"Container",data:function(){return{prefix:s,book_options:o,book_options_all:[],show:!0,book:o[0],src:""}},created:function(){this.book_options_all=a()(this.book_options),this.src=this.$utils.compute_book_src(this.prefix+this.book)},watch:{book:function(n,t){n&&this.change_book()}},methods:{change_book:function(){console.log("this.book",this.book),this.src=this.$utils.compute_book_src(this.prefix+this.book)},filterFn:function(n,t){var r=this;t(""!==n?function(){var t=n.toLowerCase();r.book_options=r.book_options_all.filter((function(n){return n.toLowerCase().indexOf(t)>-1}))}:function(){r.book_options=r.book_options_all})}}},l=r("ded3"),c=r.n(l),p=r("2f62"),u={data:function(){return{tab:"",tab_level:1,is_active:!1}},computed:c()({},Object(p["c"])(["get_current_selected_right_menu"])),created:function(){this.is_active=!0,this.fix_right_menu_config()},watch:{tab:function(){this.tab||this.fix_right_menu_config()},get_current_selected_right_menu:function(n,t){this.tab=this.get_current_selected_right_menu["t"+this.tab_level]}},methods:c()(c()({},Object(p["b"])(["set_right_menu_fix_config"])),{},{fix_right_menu_config:function(){this.set_right_menu_fix_config({tl:this.tab_level,tabs:this.tabs||[],tv:this.tab||this.tabs[0]["value"]})}}),beforeDestroy:function(){this.is_active=!1}},m=(r("99af"),r("d81d"),r("fb6a"),r("a434"),r("07ac"),function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{staticClass:"q-my-md q-mx-sm"},[r("div",{staticClass:"q-mb-md row q-gutter-x-md q-gutter-y-sm"},[r("q-select",{staticStyle:{width:"300px"},attrs:{dense:"",filled:"","use-input":"","hide-selected":"","fill-input":"","input-debounce":"0",options:n.topic_options_filtered},on:{filter:n.filterFn,"filter-abort":n.abortFilterFn,input:n.handle_topic_change},scopedSlots:n._u([{key:"before",fn:function(){return[n._v("\n        主题\n      ")]},proxy:!0}]),model:{value:n.topic,callback:function(t){n.topic=t},expression:"topic"}}),r("q-select",{staticStyle:{width:"300px"},attrs:{dense:"",filled:"",options:n.column_options},on:{input:n.handle_column_change},scopedSlots:n._u([{key:"before",fn:function(){return[n._v("\n        列数\n      ")]},proxy:!0}]),model:{value:n.column,callback:function(t){n.column=t},expression:"column"}})],1),r("q-markup-table",{attrs:{dense:""}},[r("thead",[r("tr",[r("th",{staticClass:"text-left text-weight-bolder  ",attrs:{colspan:n.column}},[n._v("\n          "+n._s(n.table_title?n.table_title+"------":"")+"当前词条数量："+n._s(n.word_total)+"\n        ")])])]),r("tbody",[n._l(n.table_data,(function(t,e){return[n.compute_if_show(t)?r("tr",{key:e,class:n.compute_topic_options_style(t)},n._l(n.column,(function(e){return r("td",{key:e,staticClass:"text-left"},[n._v("\n            "+n._s(t[e-1])+"\n          ")])})),0):n._e()]}))],2)])],1)}),d=[],g=(r("caad"),r("a9e3"),r("2532"),{data:function(){return{topic:"全部",column:2,topic_options_filtered:[],topic_options_all:[]}},props:{table_title:{type:String,default:""},word_total:{type:Number,default:0},topic_options:{type:Array,default:function(){return[]}},column_options:{type:Array,default:function(){return[]}},table_data:{type:Array,default:function(){return[]}},show_empty_line:!1},watch:{topic_options:function(n,t){this.init_topic_options_related()},column_options:function(n,t){this.init_column()}},created:function(){this.init_topic_options_related(),this.init_column(),this.handle_column_change(),this.handle_topic_change()},methods:{init_topic_options_related:function(){this.topic_options_all=a()(this.topic_options),this.topic_options_filtered=a()(this.topic_options)},filterFn:function(n,t,r){var e=this;console.log("this.topic_options_all",this.topic_options_all),setTimeout((function(){t((function(){if(""===n)e.topic_options_filtered=a()(e.topic_options_all);else{var t=n.toLowerCase();e.topic_options_filtered=e.topic_options_all.filter((function(n){return n.toLowerCase().indexOf(t)>-1}))}e.$forceUpdate()}),(function(t){""!==n&&t.options.length>0&&(t.setOptionIndex(-1),t.moveOptionSelection(1,!0))}))}),300)},abortFilterFn:function(){},handle_column_change:function(){this.$emit("handle_column_change",this.column)},handle_topic_change:function(){this.$emit("handle_topic_change",this.topic)},init_column:function(){var n=this.$q.platform.is.desktop,t=window.innerWidth;t=n?t-200:t-100,t=t<370?370:t,console.log("ww",t);var r=Math.ceil(t/350);r=r<1?1:r,t<400&&(r=1),r=r>8?8:r,this.column=r},compute_topic_options_style:function(n){var t="",r=1==n.length&&this.topic_options.includes(n[0]);return t=r?"bg-teal-4":"",t},compute_if_show:function(n){if(this.show_empty_line)return!0;var t=n.filter((function(n){return n}));return t.length>0}}}),b=g,h=r("2877"),y=Object(h["a"])(b,m,d,!1,null,"4e74a874",null),f=y.exports,v={components:{excelTable:f},data:function(){return{workSheetsFromFile:[[{data:[]}]],table_title:"",column:8,word_total:0,table_data:[],table_data_all:[],column_options:[1,2,3,4,5,6,7,8],exclude_topic_options:!0,show_empty_line:!1,topic:"",topic_options:[]}},created:function(){this.init_workSheetsFromFile()},methods:{init_workSheetsFromFile:function(){},handle_column_change:function(n){this.column=n,this.init_data()},handle_topic_change:function(n){this.topic=n,console.log("this.topic----",this.topic),this.compute_table_data_show_and_word_total()},rebuild_arr_reduce_empty_line:function(n){var t=[[""]];return n.map((function(n){var r=n.filter((function(n){return n})),e=r.length;if(e)t.push(n);else{var a=t[t.length-1].filter((function(n){return n})).length,o=t[t.length-1].length;o>0&&a>0&&t.push([""])}})),t},init_data:function(){var n=this;console.log("workSheetsFromFile --------",this.workSheetsFromFile);var t=[],r={},e=[];this.workSheetsFromFile.map((function(n){t=t.concat(n["data"])}));var o=this.$lodash.cloneDeep(t[0].filter((function(n){return n})));o.map((function(n,t){r["key_"+t]={title:n,words_raw:[]}})),this.exclude_topic_options&&t.splice(0,1),t.map((function(n,t){n.map((function(n,t){r["key_"+t]["words_raw"].push(n)}))})),console.log("final_obj------------",r);var s=Object.values(r);s.map((function(t,r){e.push([t["title"]]),e=e.concat(n.$lodash.chunk(t["words_raw"],n.column)),e=e.concat([[""]])})),this.topic_options=["全部"].concat(a()(o)),this.table_data_all=this.rebuild_arr_reduce_empty_line(e),this.compute_table_data_show_and_word_total(),console.log("  this.table_data_all   ",this.table_data_all)},compute_table_data_show_and_word_total:function(){var n=[],t=[],r=0;if(t=this.$lodash.cloneDeep(this.table_data_all),console.log(" table_data--------",t),"全部"==this.topic)n=t;else{var e=this.topic_options.indexOf(this.topic),a=e==this.topic_options.length-1,o=a?"":this.topic_options[e+1],s=this.find_topic_index(this.topic),i=o?this.find_topic_index(o):t.length;n=t.slice(s,i)}n.map((function(n){var t=n.filter((function(n){return n})).length;r+=t})),this.word_total=r,this.table_data=n},find_topic_index:function(n){for(var t=0,r=0;r<this.table_data_all.length;r++){var e=this.table_data_all[r];if(1==e.length&&e[0]&&e[0]==n){t=r;break}}return t}}},S=(r("ac1f"),r("1276"),{data:function(){return{tab:"",MainComponent:"",img_prefix:"./img/linux/heima-Linux云计算/讲义/"}},methods:{extendMarkdown:function(n){var t=this;console.log(n.renderer.rules);var r=n.renderer.rules.html_block;n.renderer.rules.html_block=function(n,e,a,o,s){var i=n[e];if(console.log("1"),i.content.includes("<img")){console.log("token-- ",i);var l="";l=i.content;var c=l.split('src="'),p=c[0]+' src="'+t.img_prefix+c[1];i.content=p}return i.attrSet("class","q-markdown--token  "),r(n,e,a,o,s)},n.renderer.rules.image=function(n,r,e,a,o){var s=n[r];console.log("3"),s.attrSet("class","q-markdown--image"),console.log("token--- "+r+"-----",s);var i=s.attrGet("src");return console.log(i),s.attrSet("src",t.img_prefix+i),o.renderToken(n,r,e)}}}})},"5bc4":function(n,t,r){},"740a":function(n,t,r){"use strict";var e=r("5bc4"),a=r.n(e);a.a},7703:function(n,t,r){},"7b7b":function(n,t,r){"use strict";r.r(t);var e=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[r(""+n.tab,{tag:"component"})],1)},a=[],o=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[r("div",[r(""+n.tab,{tag:"component"})],1)])},s=[],i=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},l=[],c="#### 源码阅读很重要，总结也很重要。\r\n\r\n| 主题       | 地址                                                         |                  |\r\n| ---------- | ------------------------------------------------------------ | ---------------- |\r\n| core-js    | https://www.npmjs.com/package/core-js                        | 标准库           |\r\n| @type      | https://www.npmjs.com/package/@types/node                    | 类型检测         |\r\n| typescript | https://www.npmjs.com/package/typescript                     | 超集             |\r\n| lodash     | https://www.npmjs.com/package/lodash                         | lodash           |\r\n| licia      | https://www.npmjs.com/package/licia                          | licia            |\r\n| moment     | https://www.npmjs.com/package/moment                         | moment           |\r\n| immutable  | https://www.npmjs.com/package/immutable                      | immutable        |\r\n| MDN        | https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide | MDN              |\r\n| ES6        | https://es6.ruanyifeng.com                                   |                  |\r\n| Web API    | https://developer.mozilla.org/zh-CN/docs/Web/API             | Web API 接口参考 |\r\n| chrome     | chrome://about/                                              | chrome           |\r\n| devtools   | https://developer.chrome.com/docs/devtools/                  | 谷歌开发者工具   |\r\n| CSS        | https://www.runoob.com/cssref/css-reference.html             | CSS参考手册      |\r\n| ts         | https://www.typescriptlang.org/                              | ts               |\r\n|            |                                                              |                  |\r\n|            |                                                              |                  |\r\n|            |                                                              |                  |\r\n|            |                                                              |                  |\r\n\r\n\r\n\r\n\r\n\r\n",p={data:function(){return{MainComponent:c}},methods:{}},u=p,m=r("2877"),d=Object(m["a"])(u,i,l,!1,null,"67cb3c7e",null),g=d.exports,b=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},h=[],y="# 30 个有用的 Node.js NPM 包\r\n# 一、实用功能\r\n\r\n## 1.  qs\r\n\r\n> 一个简单易用的字符串解析和格式化库\r\n\r\n```javascript\r\nconst qs = require('qs');\r\nconstv assert = require('assert');\r\n\r\nconst obj = qs.parse('a=c');\r\nassert.deepEqual(obj, { a: 'c' });\r\n\r\nconst str = qs.stringify(obj);\r\nassert.equal(str, 'a=c');\r\n\r\n```\r\n\r\n## 2. rxjs\r\n\r\n> RxJS是一组模块化的库，用于使用 JavaScript 中的可观察集合和组合来组合异步和基于事件的程序。\r\n\r\n```javascript\r\nconst { range } = require('rxjs');\r\nconst { map, filter } = require('rxjs/operators');\r\nrange(1, 200).pipe(\r\n  filter(x => x % 2 === 1),\r\n  map(x => x + x)\r\n).subscribe(x => console.log(x));\r\n\r\n```\r\n\r\n## 3.  mitt\r\n\r\n> 微型 200b 功能事件发射器/发布订阅.\r\n\r\n```javascript\r\nimport mitt from 'mitt'\r\nconst emitter = mitt()\r\nemitter.on('foo', e => console.log('foo', e) )\r\nemitter.on('*', (type, e) => console.log(type, e) )\r\nemitter.emit('foo', { a: 'b' })\r\nemitter.all.clear()\r\n\r\nfunction onFoo() {}\r\nemitter.on('foo', onFoo)   // listen\r\nemitter.off('foo', onFoo)  // unlisten\r\n\r\n```\r\n\r\n## 4. Underscore.js\r\n\r\n> Underscore.js是一个用于 JavaScript 的实用程序带库，它在不扩展任何核心 JavaScript 对象的情况下为通常的功能嫌疑人（each、map、reduce、filter 等）提供支持。\r\n\r\n```javascript\r\nconst _ = require(“underscore);\r\nconst list = [[5, 1, 7], [3, 2, 1]];\r\n_.invoke(list, 'sort');\r\n// => [[1, 5, 7], [1, 2, 3]]\r\n\r\n```\r\n\r\n## 5. day.js\r\n\r\n> Day.js是一个极简主义的 JavaScript 库，它为现代浏览器解析、验证、操作和显示日期和时间，并具有很大程度上与 Moment 兼容的 API。\r\n\r\n```javascript\r\nconst dayjs = require(“dayjs”);\r\ndayjs().startOf('month').add(1, 'day').set('year', 2018).format('YYYY-MM-DD HH:mm:ss');\r\n\r\n```\r\n\r\n## 6. Ramda\r\n\r\n> Ramda是一个实用的函数式库，具有可与柯里化组合的无副作用函数。\r\n\r\n```javascript\r\nimport * as R from 'ramda';\r\nconst double = x => x * 2;\r\nR.map(double, [1, 2, 3]); \r\n// => [2, 4, 6]\r\nR.map(double, {x: 1, y: 2, z: 3}); \r\n// => {x: 2, y: 4, z: 6}\r\n\r\n```\r\n\r\n## 7. validator\r\n\r\n> Validator是一个字符串验证器和清理器库。\r\n\r\n```javascript\r\nvar validator = require('validator');\r\nvalidator.isEmail('foo@bar.com'); //=> true\r\n\r\n```\r\n\r\n## 8. yup\r\n\r\n> yup是一个用于复杂的、相互依赖的验证和转换的模式构建器。\r\n\r\n```javascript\r\nimport * as yup from 'yup';\r\nlet schema = yup.object().shape({\r\n  name: yup.string().required(),\r\n  age: yup.number().required().positive().integer(),\r\n  email: yup.string().email(),\r\n  website: yup.string().url(),\r\n  createdOn: yup.date().default(function () {\r\n    return new Date();\r\n  }),\r\n});\r\n// check validity\r\nschema\r\n  .isValid({\r\n    name: 'jimmy',\r\n    age: 24,\r\n  })\r\n  .then(valid => \r\n    console.log(valid) // => true\r\n  );\r\n// you can try and type cast objects to the defined schema\r\nschema.cast({\r\n  name: 'jimmy',\r\n  age: '24',\r\n  createdOn: '2014-09-23T19:25:25Z',\r\n});\r\n// => { name: 'jimmy', age: 24, createdOn: Date }\r\n\r\n```\r\n\r\n## 9. Lodash\r\n\r\n> Lodash是一个实用程序库，通过消除处理数组、数字、对象、字符串等的麻烦，使 JavaScript 变得更容易。\r\n\r\n```javascript\r\nconst _ = require(\"lodash\");\r\nconst nums = _.range(1, 9);\r\n// => [1, 2, 3, 4, 5, 6, 7, 8, 9]\r\nconst chunks = _.chunk(nums, 3);\r\n// => [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\r\nconst right = _.takeRight(nums, 2);\r\n// => [7, 8, 9]\r\n\r\n```\r\n\r\n## 10. date-fns\r\n\r\n> Date-fns提供了最全面、最简单且一致的工具集，用于在浏览器和 Node.js 中操作 JavaScript 日期。\r\n\r\n```javascript\r\nimport { format, formatDistance, formatRelative, subDays } from 'date-fns'\r\nformat(new Date(), '[Today is a] dddd')\r\n//=> \"Today is a Wednesday\"\r\nformatDistance(subDays(new Date(), 3), new Date())\r\n//=> \"3 days ago\"\r\nformatRelative(subDays(new Date(), 3), new Date())\r\n//=> \"last Friday at 7:26 p.m.\"\r\n\r\n```\r\n\r\n## 11. jsonwebtoken\r\n\r\n> Jsonwebtoken是一个用于对 JSON Web 令牌进行签名、验证和解码的库。\r\n\r\n```javascript\r\nconst jwt = require('jsonwebtoken');\r\nconst token = jwt.sign({ foo: 'bar' }, 'shhhhh');\r\n\r\n```\r\n\r\n## 12. uuid\r\n\r\n> UUID 是一个用于创建 RFC4122 通用唯一标识符的库。\r\n\r\n```javascript\r\nconst { v4: uuidv4 } = require('uuid');\r\nuuidv4(); // => '1a68a438-b077-468b-b1e8-dcdd976a0f5b'\r\n\r\n```\r\n\r\n# 二、操作文件系统\r\n\r\n## 1. rimraf\r\n\r\n> Rimraf 为节点提供了与 UNIX rm -rf 命令等效的命令。\r\n\r\n```javascript\r\nconst rimraf = require(“rimraf”);\r\nrimraf('./build', error => {\r\n  if (error) console.error(error);\r\n});\r\n\r\n```\r\n\r\n## 2. fs-extra\r\n\r\n> FS-extra 添加了未包含在本机 fs 模块中的文件系统方法，并为 fs 方法添加了 promise 支持。\r\n\r\n```javascript\r\nconst fs = require(‘fs-extra’);\r\nasync function copyFiles () {\r\n  try {\r\n    await fs.copy('/tmp/myfile', '/tmp/mynewfile');\r\n    console.log('success!');\r\n  } catch (err) {\r\n    console.error(err);\r\n  }\r\n}\r\ncopyFiles();\r\n\r\n```\r\n\r\n## 3. mkdirp\r\n\r\n> 就像 mkdir -p 一样，mkdirp 递归地创建目录和所有必要的子目录。\r\n\r\n```javascript\r\nconst mkdirp = require('mkdirp')\r\n// return value is a Promise resolving to the first directory created\r\nmkdirp('/tmp/foo/bar/baz').then(made =>\r\n  console.log(`made directories, starting with ${made}`));\r\n\r\n```\r\n\r\n## 4. glob\r\n\r\n> Glob 是一个使用多种模式匹配文件的库。\r\n\r\n```javascript\r\nconst glob = require(\"glob\");\r\n// options is optional\r\nglob(\"**/*.js\", options, function (er, files) {\r\n  // files is an array of filenames.\r\n  // If the `nonull` option is set, and nothing\r\n  // was found, then files is [\"**/*.js\"]\r\n  // er is an error object or null.\r\n});\r\n\r\n```\r\n\r\n## 5. shelljs\r\n\r\n> ShellJS 是基于 Node.js API 的 Unix shell 命令的可移植 (Windows/Linux/OS X) 实现。\r\n\r\n```javascript\r\nconst shell = require('shelljs');\r\nif (!shell.which('git')) {\r\n  shell.echo('Sorry, this script requires git');\r\n  shell.exit(1);\r\n}\r\n// Copy files to release dir\r\nshell.rm('-rf', 'out/Release');\r\nshell.cp('-R', 'stuff/', 'out/Release');\r\n// Replace macros in each .js file\r\nshell.cd('lib');\r\nshell.ls('*.js').forEach(function (file) {\r\n  shell.sed('-i', 'BUILD_VERSION', 'v0.1.2', file);\r\n  shell.sed('-i', /^.*REMOVE_THIS_LINE.*$/, '', file);\r\n  shell.sed('-i', /.*REPLACE_LINE_WITH_MACRO.*\\n/, shell.cat('macro.js'), file);\r\n});\r\nshell.cd('..');\r\n// Run external tool synchronously\r\nif (shell.exec('git commit -am \"Auto-commit\"').code !== 0) {\r\n  shell.echo('Error: Git commit failed');\r\n  shell.exit(1);\r\n}\r\n\r\n```\r\n\r\n## 6. js-yaml\r\n\r\n> Js-yaml 是 YAML 的一种实现，YAML 是一种流行的人性化数据序列化语言。\r\n\r\n```javascript\r\nconst yaml = require('js-yaml');\r\nconst fs   = require('fs');\r\n// Get document, or throw exception on error\r\ntry {\r\n  const doc = yaml.load(fs.readFileSync('/home/ixti/example.yml', 'utf8'));\r\n  console.log(doc);\r\n} catch (e) {\r\n  console.log(e);\r\n}\r\n\r\n```\r\n\r\n# 三、Web框架\r\n\r\n## 1.  koa\r\n\r\n> Koa 是由 Express 背后的团队设计的新 Web 框架，旨在成为 Web 应用程序和 API 的更小、更具表现力和更健壮的基础。\r\n\r\n```javascript\r\nconst Koa = require('koa');\r\nconst app = new Koa();\r\n\r\napp.use(async ctx => {\r\n  ctx.body = 'Hello World';\r\n});\r\napp.listen(3000);\r\n\r\n```\r\n\r\n## 2.  express\r\n\r\n> Express.js 是最流行、最快速、最简约的 node.js 后端 Web 框架。\r\n\r\n```javascript\r\nconst express = require('express');\r\nconst app = express();\r\napp.get('/', function (req, res) {\r\n  res.send('Hello World');\r\n});\r\napp.listen(3000);\r\n\r\n```\r\n\r\n## 3.  Fastify\r\n\r\nFastify是最快的可扩展 Web 框架之一，专注于以最少的开销提供最佳的开发人员体验。\r\n\r\n```javascript\r\nconst fastify = require('fastify')({\r\n  logger: true\r\n});\r\nfastify.get('/', async (request, reply) => {\r\n  reply.type('application/json').code(200);\r\n  return { hello: 'world' };\r\n});\r\nfastify.listen(3000, (err, address) => {\r\n  if (err) throw err;\r\n  fastify.log.info(`App listening on ${address}`);\r\n});\r\n\r\n```\r\n\r\n## 4.  socket.io\r\n\r\n> Socket.IO使用长轮询或 WebSockets 启用实时双向基于事件的通信，并具有断开连接检测和自动重新连接支持。\r\n\r\n```javascript\r\nconst server = require('http').createServer();\r\nconst io = require('socket.io')(server);\r\nio.on('connection', client => {\r\n  client.on('event', data => { /* … */ });\r\n  client.on('disconnect', () => { /* … */ });\r\n});\r\nserver.listen(3000);\r\n\r\n```\r\n\r\n\r\n\r\n# 四、辅助开发\r\n\r\n## 1.  jest\r\n\r\n> Jest 已完成并准备好设置 JavaScript 测试解决方案\r\n\r\n```javascript\r\ntest('adds 1 + 2 to equal 3', () => {\r\n  expect(1 + 2).toBe(3);\r\n});\r\n\r\n```\r\n\r\n## 2.  typescript\r\n\r\n> TypeScript 是可扩展的 JavaScript。 它是一种添加可选类型并编译为普通可读 JavaScript 的语言。\r\n\r\n```javascript\r\ninterface User {\r\n  name: string;\r\n  id: number;\r\n}\r\nconst user: User = {\r\n  name: \"Hayes\",\r\n  id: 0,\r\n};\r\n\r\n```\r\n\r\n## 3. winston\r\n\r\n> Winston 是一个简单且通用的日志库，支持多种传输。\r\n\r\n```javascript\r\nconst winston = require('winston');\r\nconst logger = winston.createLogger({\r\n  level: 'info',\r\n  format: winston.format.json(),\r\n  defaultMeta: { service: 'user-service' },\r\n  transports: [\r\n    // Write all logs with level `error` and below to `error.log`\r\n    new winston.transports.File({ filename: 'error.log', level: 'error' }),\r\n    // Write all logs with level `info` and below to `combined.log`\r\n    new winston.transports.File({ filename: 'combined.log' }),\r\n  ],\r\n});\r\nlogger.log({\r\n  level: 'error',\r\n  message: 'Hello distributed log files!'\r\n});\r\nlogger.info('Hello again distributed logs');\r\n\r\n```\r\n\r\n## 4. debug\r\n\r\n> Debug 是一个微型 JavaScript 调试实用程序，模仿 Node.js 核心的调试技术。\r\n\r\n```javascript\r\nconst debug = require('debug')('http')\r\n  , http = require('http')\r\n  , name = 'My App';\r\ndebug('booting %o', name);\r\nhttp.createServer(function(req, res){\r\n  debug(req.method + ' ' + req.url);\r\n  res.end('hello\\n');\r\n}).listen(3000, function(){\r\n  debug('listening');\r\n});\r\n\r\n```\r\n\r\n## 5.  eslint\r\n\r\n> ESLint 是一种用于查找和修复 JavaScript 和 TypeScript 代码中问题的工具。\r\n\r\n```javascript\r\n{\r\n    \"rules\": {\r\n        \"semi\": [\"error\", \"always\"],\r\n        \"quotes\": [\"error\", \"double\"]\r\n    }\r\n}\r\n\r\n```\r\n\r\n## 6.  nodemon\r\n\r\n> Nodemon 是一个工具，它通过在检测到目录中的文件更改时自动重新启动节点应用程序来帮助开发基于 node.js 的应用程序。\r\n\r\n```javascript\r\nnodemon ./server.js \r\n\r\n```\r\n\r\n## 7.  dotenv\r\n\r\n> Dotenv 是一个零依赖模块，可将 .env 文件中的环境变量加载到 process.env 中\r\n\r\n```javascript\r\n.env file:\r\n\r\nDB_HOST=localhost\r\nDB_USER=root\r\nDB_PASS=s1mpl3\r\nrequire('dotenv').config();\r\nconst db = require('db');\r\ndb.connect({\r\n  host: process.env.DB_HOST,\r\n  username: process.env.DB_USER,\r\n  password: process.env.DB_PASS\r\n});\r\n\r\n```\r\n\r\n## 8.  cross-env\r\n\r\n> Cross-env enables scripts to set and use environment variables across platforms.\r\n\r\n```javascript\r\n{\r\n  \"scripts\": {\r\n    \"start-prod\": \"cross-env NODE_ENV=production node ./app.js\"\r\n  }\r\n}\r\n```\r\n\r\n\r\n",f={data:function(){return{MainComponent:y}},methods:{}},v=f,S=Object(m["a"])(v,b,h,!1,null,"0aaea27c",null),_=S.exports,k=r("1b62"),j={mixins:[k["c"]],components:{m1:g,m2:_},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"感悟",value:"m1"},{label:"NPM包",value:"m2"}]}}},w=j,x=Object(m["a"])(w,o,s,!1,null,"25de5760",null),T=x.exports,C=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[r("div",[r(""+n.tab,{tag:"component"})],1)])},M=[],P=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},O=[],E="## 学习前端的一些入门关键词汇\r\n\r\n```\r\n搜索：机器码，电流开关与存储关系，字节码，内存和机械存储（ram，rom），堆栈，内存缓冲区，汇编语言，低级语言，高级语言，解释执行，编译执行，web发展历史，\r\n流程控制语句，数据类型，数据结构，操作系统，虚拟机，浏览器内核区别，webAPP，原生应用，服务器，物理机，集群，cdn，dns，tcp，http，dtd，\r\n\r\n（概念性，不深入。个人接受能力。）\r\n(现阶段，自认为)\r\n学习方法：类比，逻辑思维能力。概观 与 盲人摸象\r\n 技术：\r\nDTD\r\nXml\r\nnode type\r\n浏览器渲染机制\r\n（html tree +  css tree => render tree =>layout =>painting ->{reflow repaint}）\r\n \r\n表现：一切皆为块。（1px -> html 油画，层叠）\r\n结构：树，对象。\r\n \r\n数据结构\r\n树状结构\r\n \r\n消息驱动，事件驱动和数据驱动\r\n \r\n结构，管道\r\n面向结构编程\r\n面向过程编程\r\n面向对象编程\r\n面向接口编程\r\n \r\n适度封装，抽象提取\r\n（插件：预留 API ）\r\n \r\n类数组\r\n （char ,string）(dom)\r\n\r\nES6\r\nhttp://es6.ruanyifeng.com\r\n（set map … 正则 fill object.assign repeat ）\r\n(理解： proxy  iterator 异步 模块) （单线程 和异步 promise）\r\n延伸：（从字节码到高级语言）\r\n\r\n其他：\r\n数据可视化，JQUI, 淘宝移动端适配，VW布局 ，模板，\r\nnginx,sourcetree,filezila\r\n调试 :json  mock e2e ,es6 \r\n \r\n单页应用开发\r\n理解 ： 单文件状态管理  MVC MVVM  \r\n MVC MVVM : 虚拟DOM  节点 diff （angular 脏检查 遍历所有 diff） innerHtml\r\nwatcher\r\n组件 （object.defineproperty getter setter）\r\n 全局注册， 变量挂载， 命名空间 （NG） \r\n订阅  分发 \r\nVuecli+ vueRouter+ vuex  ：  loader,编译， 热刷新，热加载，内存\r\nElementui  mint ui  // vux\r\n讲解：企业级 代码结构\r\n\r\n\r\n最后搜索ansi，utf-8，万国码，mvc，mvvm，api，模板，包管理，懒加载，热刷新，und，pwa，spa，ssr，响应式原理\r\n```\r\n\r\n\r\n\r\n\r\n ",R={data:function(){return{MainComponent:E}}},N=R,A=Object(m["a"])(N,P,O,!1,null,"0b9352be",null),D=A.exports,I=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},J=[],L="# 浏览器数据持久化存储\r\n### WebStorage\r\n\r\n> - 定义与引入原因 - WebStorage 是 HTML5 中本地存储的解决方案之一，在 html5 中的 WebStorage 概念引入并不是为取代 cookie 而制定的标准，cookie 作为 HTTP 协议的一部分用来处理客户端和服务器通信是不可或缺的， session 正是依赖于实现的客户端状态保持。 - WebStorage 的意图在于解决本地本来不应该用 cookie 做，却不得不用 cookie 的本地存储。\r\n>\r\n> - WebStorage 的优势  \r\n>\r\n> ​           （1）从容量上讲 WebStorage 一般浏览器提供 5M 的存储空间。\r\n>\r\n> ​         （2）安全性上 WebStorage 并不作为 HTTP header 发送的浏览器，所以相对安全。  \r\n>\r\n> ​           （3）从流量上讲，因为 WebStorage 不传送到服务器，所以不必要的流量可以节省。\r\n\r\n  ### Local Storage 与 Session Storage 的区别 \r\n\r\n>   Session Storage - 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此 sessionStorage 不是一种长久化的本地存储，仅仅是会话级别的存储。 - Local Storage - 除非主动删除数据，否则数据是永远不会过期的。\r\n\r\n### Cookie\r\n\r\n> - 网站为了辨别用户身份或 Session 跟踪而存储在用户浏览器端的数据\r\n> - Cookie 信息一般会通过 HTTP 请求发送到服务器端\r\n> - 一条 Cookie 记录主要由键、值、域、过期时间和大小组成，一般用于保存用户的网站认证信息\r\n> - 浏览器端通过 document.cookie 来获取 cookie\r\n> - （1）什么是 Cookie？ - （1）cookie 是指某些网站为了辨别用户身份而存储在用户本地终端上的数据（通常经过加密）。 - （2）cookie 是存储于访问者的计算机中的变量。每当同一台计算机通过浏览器请求同一个页面时，就会发送这个 cookie 。 - （3）通俗的说就是当一个用户通过 HTTP 协议访问一个服务器的时候，这个服务器会将一些 key/Value 键值对返回给客户端浏览器，并给这些数据加上一些限制条件，在条件符合时这个用户下次访问这个服务器的时候，数据又被完整的带回给服务器。 - （4）cookie 是浏览器提供的一种机制，可以由 Javascript 对其进行控制，而不是 javascript 本身的性质。\r\n> - （2）HTTP 无状态 - HTTP 协议是无状态的协议。一旦数据交换完毕，客户端与服务器的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。 - 而 cookie 机制采用的是在客户端保持状态的方案，而 session 机制采用的是在服务器端保持状态的方案。\r\n> - （3）Cookie 的不可跨域名性 - cookie 是存于用户硬盘的一个文件，这个文件通常对应于一个域名。cookie 可以跨越同一个域名下的多个网页，但不能跨越多个域名使用。\r\n> - （4）Cookie 的缺点 - 1.Cookie 体积过大会造成请求和响应速度变慢。 - 2.默认浏览器会任何请求都把 cookie 带上去，哪怕是静态资源。 - 3.Cookie 可以在前后端修改，数据容易篡改或伪造。 - 4.Cookie 对于敏感数据的保护基本是无效的。 - 5.有些用户是禁用掉 cookie 的\r\n\r\n### LocalStorage\r\n> - html5 的一种本地缓存方案，主要用于浏览器端保存体积较大的数据\r\n> - 在不同浏览器中有长度限制且各不相同\r\n> - 单个域名下 localStorage 的大小是有限制的，但是可以用 iframe 的方式使用多个域名来突破单个页面下 localtorage 存储数据的最大限制。\r\n> - 使用浏览器多个标签页打开同个域名时，localStorage 内容一般是共享的。\r\n> - 设置 localStorage 存储记录：localStorage.setItem(key, value)\r\n> - 获取 localStorage 存储记录：localStorage.getItem(key)\r\n> - 删除该域名下单条 localStorage 存储记录：localStorage.removeItem(key)\r\n> - 删除该域名下所有 localStorage 存储记录：localStorage.clear()\r\n\r\n### SessionStorage\r\n> - sessionStorage 在浏览器关闭时会自动清空，不能进行客户端的持久化数据存储。\r\n> - sessionStorage 的 API 和 localStorage 完全相同\r\n> - 除了 cookie，web 应用程序中还经常使用 session 来记录客户端的登录状态。不同于 cookie，session 保存在服务器上。session 相当于程序在服务器上建立一份客户档案，客户来访时只需要查询客户档案表就可以了。\r\n\r\n### Cookie 和 Session 的区别\r\n\r\n> - session 保存在服务器，客户端不知道其中的信息；cookie 保存在客户端，服务器能够知道其中的信息。\r\n> - session 中保存的是对象，cookie 中保存的是字符串。\r\n> - session 不能区分路径，同一个用户在访问一个网站期间，所有的 session 在任何地方都可以访问到。而 cookie 中如果设置了路径参数，那么同一个网站不同路径下的 cookie 互相是不可以访问的。\r\n> - cookie 不是很安全，本人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗\r\n> - session 会在一定时间内保存在服务器上。当访问增多，会占用你服务器的性能。考虑到减轻服务器性能方面，应该使用 COOKIE。\r\n> - 单个 cookie 保存的数据不能超过 4k ，很多浏览器都限制一个站点最多保存 20 个 cookie。\r\n> - session 是通过 cookie 来工作的。\r\n\r\n### Cookie 与 Web Storage 的区别\r\n\r\n> - 共同点： - 都是保存在浏览器端，且同源的。\r\n> - 区别： - （1）是否在请求中携带 - cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递。而 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。 - （2）cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下。 - （3）存储大小限制也不同 - cookie 数据不能超过 4k，同时因为每次 http 请求都会携带 cookie，所以 cookie 只适合保存很小的数据，如会话标识。sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。 - （4）数据有效期不同 - sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持； - localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据； - Cookie：只在设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。 - （5）作用域不同 - sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面； - localStorage 在所有同源窗口中都是共享的； - Cookie 也是在所有同源窗口中都是共享的。 - （6）Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。 - （7）Web Storage 的 api 接口使用更方便。\r\n\r\n\r\n\r\n### indexDB\r\n> - 一个可在客户端存储大量结构化数据并且能在这些数据上使用索引进行高性能检索的一套 API\r\n\r\n### WebSQL\r\n> - 浏览器端用于存储较大量数据的缓存机制，只有较新版本的 Chrome 浏览器支持该机制，并以一个独立浏览器端数据存储规范的形式出现。\r\n> - WebSQL 数据库 API 实际上不是 HTML5 规范的组成部分，目前只是一种特定的浏览器特性，而且 WebSQL 在 HTML5 之前就已经存在，是单独的规范。\r\n> - WebSQL 将数据以数据库二维表的形式存储在客户端，可以根据需要使用 JavaScript 去读取。\r\n> - WebSQL 与其他存储方式的区别：localStorage 和 Cookie 以键值对的形式存在，WebSQL 为了更便于检索，允许 SQL 语句的查询。\r\n> - WebSQL 可以让浏览器实现小型数据库存储功能，而且使用的数据库是集成在浏览器里面的。\r\n> - openDatabase()方法可以打开已经存在的数据库，不存在则创建\r\n>   openDatabase()中的五个参数分别为数据库名、版本号、描述、数据库大小、创建回调（即使创建回调为 null 也可以创建数据库）\r\n> - transaction()方法允许根据情况控制执行事务提交或回滚\r\n> - executeSql()用于执行真实的 SQL 查询语句\r\n\r\n\r\n\r\n### CacheStorage\r\n> - cacheStorage 是在 ServiceWorker 规范中定义的，可用于保存每个 ServiceWorker 声明的 Cache 对象，是未来可能用来代替 Application Cache 的离线方案。\r\n> - caches.has()检查如果包含 Cache 对象，则返回一个 promise 对象\r\n> - caches.open() 打开一个 Cache 对象，并返回一个 promise 对象\r\n> - caches.delete()删除 Cache 对象，成功则返回一个 promise 对象，否则返回 false\r\n> - caches.keys()含有 keys 中字符串的任意一个，则返回一个 promise 对象\r\n> - caches.match()匹配 key 中含有该字符串的 cache 对象，返回一个 promise 对象\r\n\r\n### Application Cache\r\n> - Application Cache 是一种允许浏览器通过 manifest 配置文件在本地有选择性地存储 JavaScript、CSS、图片等静态资源的文件级缓存机制。当页面不是首次打开时，通过一个特定的 manifest 文件配置描述来选择读取本地 Application Cache 里面的文件。\r\n> - 离线浏览。通过 manifest 配置描述来读取本地文件，用户可在离线时浏览完整的页面内容。\r\n> - 快速加载。由于缓存资源为本地资源，因此页面加载速度较快。\r\n> - 服务器负载小。只有在文件资源更新时，浏览器才会从服务器端下载，这样就减小了服 务器资源请求的压力\r\n",H={data:function(){return{MainComponent:L}}},F=H,U=Object(m["a"])(F,I,J,!1,null,"0bc7c404",null),q=U.exports,B=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},W=[],V="## 从输入 URL 到获取页面的过程\r\n#### 1. 域名、URL 和 URI\r\n> 首先要搞清楚这两个概念，**域名**，是一台计算机，或一组计算机在**网络上**的名称。**Domain Name**，顾名思义，Domain 代表着你的计算机，或者你的计算机组，**Name** 就代表着名称\r\n> 关于 URL(Uniform Resource Locator) 和 URI(Uniform Resource Identifier)，这两者都是用于定位资源的，区别就是：URI 是统一资源标志符，单凭 URI 就能够精准定位某个资源（比如用身份证号就能够识别中国的每一个居民），而 URL，是统一资源定位符，就是有考虑范围的资源（比如身份证号的前六位，就是根据地区来分的）\r\n> 举个例子：据说全中国有 29 万个张伟，那么，除了用身份证号来确定是哪一个张伟，还能怎么判断呢？这时候就需要划分地区了，比如福建省福州市的张伟，这时候可能还是有好多个张伟，那就加上比如 xxxx 年 xx 月 xx 日出生的张伟，如果这时候还能有重复，那就再加上一些其他条件（学历，政治面貌等等），就能够定位到具体的某一个张伟了，这些条件组合在一起，就是一条 URL\r\n> URL 是 URI 的一个子集，每条 URL 都能够定位到一个独一无二的资源，它符合 URI 的定义，但是 URL != URI，这一点需要记清楚\r\n> 现在回到网页上，域名只是网站的入口（比如说主页），如果你要在这主页上点击一个链接，进行页面跳转，就需要靠 URL 来指定资源的位置，这样才能获取，如果 URL 无效，就会弹出 **404 Not Found**，比如你进入 https://cn.bing.com/  这时候就是依据域名来找到主页，然后你搜索张伟，就会有一条挺长的 URL 来跳转到搜索结果页面\r\n\r\n#### 2. 域名 和 IP 地址\r\n> 前面说到，域名是计算机或计算机组在网络上的名称，但是并不是每一台计算机都有绑定了域名，但是，每一台**接入网络**的计算机都有一个 IP 地址 (Internet Protocol address)，用这个 IP 地址就能够定位到一台服务器，或一组服务器，如果服务器没有绑定域名，只要有它的 IP 地址，还是可以进行访问的\r\n> 我们在上网时，如果要直接访问某个网站，都是输入域名就可以了，但是在定位服务器时，都是要靠 IP 地址来进行的，从域名到 IP 地址，这二者的转换就引出了一个新的概念 —— DNS(Domain Name System)\r\n> 当我们输入域名时，浏览器会根据这个域名在浏览去缓存的 IP 地址中去查找，如果找不到，就到 OS 中去查找缓存的 IP 地址，如果还是找不到，就会去 ISP（Internet service provider），也就是运营商（电信，铁通之类的）的服务器里查找，如果还是找不到，就要去根域名服务器查找\r\n> 关于运营商域名服务器以及根域名服务器的 IP 地址，在你电脑的网络设置里可以看到：\r\n> DNS 服务器里有两个 IP 地址，一个是中国电信的 (ISP)，一个是位于美国的服务器（根域名服务器）\r\n> 另外，关于 DNS 缓存，每一次的查询，都会缓存下来，先说浏览器缓存，这里以 Chrome 为例，输入 **chrome://net-internals/#dns** 就会得到 Chrome 的 DNS 缓存。然后是 OS 的缓存，在命令行中输入 **ipconfig /displaydns** 就会得到 OS 中的缓存：\r\n\r\n#### 3. DNS 查询\r\n> 在说 DNS 查询之前，需要先说一下域名服务器的种类，有根服务器、顶级域名服务器、权威域名服务器和本地域名服务器\r\n> 在 DNS 查询的时候，首先查询本地域名服务器，也就是 ISP 提供的 DNS 服务器，如果找不到，这时候就有两种查询方式：\r\n>\r\n> 1. 递归查询 客户端发出请求，本地 DNS 服务器代替客户端去查询其它 DNS 服务器，然后由本地 DNS 返回最终结果给客户端\r\n> 2. 迭代查询 本地 DNS 服务器并不能返回完整的结果，它只能给你一部分信息（比如它只知道要去 yyy 服务器上才找得到 xxx），然后又带着这个信息去 yyy 服务器上查找\r\n\r\n#### 4. TCP 连接建立\r\n> 在找到目标服务器的 IP 地址之后，就要开始通信了，既然是通信，就要双方消息同步（如果双方说话都不在一个频道，这不能叫通信），这里就要引出另一个应用层协议 —— TCP(Transmission Control Protocol)，传输控制协议\r\n> TCP 是基于连接的 —— 在通信开始之前建立连接，结束时断开连接\r\n\r\n#### 5. HTTP 请求与响应\r\n> 连接建立之后，就可以开始传输了，采用 Http 协议，这里简单分析一下 Http 请求和响应的报文：\r\n>\r\n> **Http 请求报文，一共有 4 个部分（包含一个空行）：**\r\n>\r\n> **1. 请求行 (request-line)**\r\n> 请求行包含了请求的方法，资源的位置，以及协议的版本，举个例子：\r\n>\r\n> ```\r\n> GET /index.html HTTP/1.1\r\n> ```\r\n> 采用 GET 的方式，请求得到 index.html 这个页面，采用 HTTP/1.1 版本的协议\r\n> **2. 请求头部 (headers)**\r\n> 头部是有多个 Key-Value 组成的，常见的有：\r\n> ```\r\n> Accept:xxx （接受的数据类型）\r\n> Accept-Charset:xxx （接受的编码格式）\r\n> Accept-Language:xxx （接受的语言）\r\n> User-Agent:xxx （浏览器类型）\r\n> Cookie:xxx=yyy （所使用的 Cookie）\r\n> Connection:close/keep-alive （连接状态：关闭/保持连接）\r\n> ......\r\n> ```\r\n> **3. 空行 (blank line)**\r\n> 这个空行是一定要有的，它是用来区分请求头部和请求数据的，它代表着不再有头部的 Key-Value 键值对，接下来是请求数据了\r\n> **4. 请求数据 (request-body)**\r\n> 请求主体一般是用于 POST 方法提交数据，例如最常见的表单提交，就是在请求主体写入 `Content-Type= multipart/form-data``\r\n>\r\n> **Http 响应报文，也是分为 4 个部分（包含一个空行）：**\r\n>\r\n> **1. 状态行 (status-line)**\r\n> 状态行中包含着协议版本，状态码以及文本描述，状态码和文本描述就代表了服务器所返回的响应结果是怎样的，这里给出大致的描述：\r\n>\r\n> ```\r\n> 2XX：成功\r\n> 3XX：重定向\r\n> 4XX：客户端错误\r\n> 5XX：服务器错误\r\n> ```\r\n> 最常见的就是：200 (OK) 和 404 (Not Found) 了\r\n> **2. 响应头部 (headers)**\r\n> 与请求头部类似，也是 Key-Value 键值对的组合\r\n> **3. 空行 (blank line)**\r\n> 用来分隔响应头部和响应正文\r\n> **4. 响应正文**\r\n> 响应正文中，如果之前请求的是数据，就返回数据，如果请求的是网页，就返回 HTML 代码\r\n\r\n#### 6. TCP 连接关闭\r\n> 在通信结束之后，需要将连接关闭，这时候就是 TCP 四次挥手的场景了\r\n\r\n\r\n------\r\n## 浏览器渲染原理与过程\r\n#### 浏览器如何渲染网页\r\n> 要了解浏览器渲染页面的过程，首先得知道一个名词——关键渲染路径。关键渲染路径是指浏览器从最初接收请求来的HTML、CSS、javascript等资源，然后解析、构建树、渲染布局、绘制，最后呈现给客户能看到的界面这整个过程。\r\n> 用户看到页面实际上可以分为两个阶段：页面内容加载完成和页面资源加载完成，分别对应于`DOMContentLoaded`和`Load`。\r\n>\r\n> - `DOMContentLoaded`事件触发时，仅当DOM加载完成，不包括样式表，图片等\r\n> - `load`事件触发时，页面上所有的DOM，样式表，脚本，图片都已加载完成\r\n> 浏览器渲染的过程主要包括以下五步：\r\n> 1. 浏览器将获取的HTML文档解析成DOM树。\r\n> 2. 处理CSS标记，构成层叠样式表模型CSSOM(CSS Object Model)。\r\n> 3. 将DOM和CSSOM合并为渲染树(`rendering tree`)将会被创建，代表一系列将被渲染的对象。\r\n> 4. 渲染树的每个元素包含的内容都是计算过的，它被称之为布局`layout`。浏览器使用一种流式处理的方法，只需要一次绘制操作就可以布局所有的元素。\r\n> 5. 将渲染树的各个节点绘制到屏幕上，这一步被称为绘制`painting`。\r\n> 需要注意的是，以上五个步骤并不一定一次性顺序完成，比如DOM或CSSOM被修改时，亦或是哪个过程会重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。而在实际情况中，JavaScript和CSS的某些操作往往会多次修改DOM或者CSSOM。\r\n\r\n#### 浏览器渲染网页的具体流程\r\n#### 构建DOM树\r\n> 当浏览器接收到服务器响应来的HTML文档后，会遍历文档节点，生成DOM树。\r\n> 需要注意以下几点：\r\n>\r\n> - DOM树在构建的过程中可能会被CSS和JS的加载而执行阻塞\r\n> - `display:none`的元素也会在DOM树中\r\n> - 注释也会在DOM树中\r\n> - `script`标签会在DOM树中\r\n> 无论是DOM还是CSSOM，都是要经过`Bytes→characters→tokens→nodes→objectmodel`这个过程。\r\n> 当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。\r\n\r\n#### 构建CSSOM规则树\r\n> 浏览器解析CSS文件并生成CSSOM，每个CSS文件都被分析成一个StyleSheet对象，每个对象都包含CSS规则。CSS规则对象包含对应于CSS语法的选择器和声明对象以及其他对象。\r\n> 在这个过程需要注意的是：\r\n>\r\n> - CSS解析可以与DOM解析同时进行。\r\n> - CSS解析与`script`的执行互斥 。\r\n> - 在Webkit内核中进行了`script`执行优化，只有在JS访问CSS时才会发生互斥。\r\n\r\n#### 构建渲染树（Render Tree）\r\n> 通过DOM树和CSS规则树，浏览器就可以通过它们构建渲染树了。浏览器会先从DOM树的根节点开始遍历每个可见节点，然后对每个可见节点找到适配的CSS样式规则并应用。\r\n> 有以下几点需要注意：\r\n>\r\n> - Render Tree和DOM Tree不完全对应\r\n> - `display: none`的元素不在Render Tree中\r\n> - `visibility: hidden`的元素在Render Tree中\r\n> 渲染树生成后，还是没有办法渲染到屏幕上，渲染到屏幕需要得到各个节点的位置信息，这就需要布局（Layout）的处理了。\r\n\r\n#### 渲染树布局(layout of the render tree)\r\n> 布局阶段会从渲染树的根节点开始遍历，由于渲染树的每个节点都是一个Render Object对象，包含宽高，位置，背景色等样式信息。所以浏览器就可以通过这些样式信息来确定每个节点对象在页面上的确切大小和位置，布局阶段的输出就是我们常说的盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。需要注意的是：\r\n> - `float`元素，`absoulte`元素，`fixed`元素会发生位置偏移。\r\n> - 我们常说的脱离文档流，其实就是脱离Render Tree。\r\n\r\n#### 渲染树绘制（Painting the render tree）\r\n> 在绘制阶段，浏览器会遍历渲染树，调用渲染器的`paint()`方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的UI后端组件完成的。\r\n\r\n## 浏览器渲染网页的那些事儿\r\n#### 浏览器主要组件结构\r\n> 渲染引擎主要有两个：webkit和Gecko\r\n> Firefox使用Geoko，Mozilla自主研发的渲染引擎。Safari和Chrome都使用webkit。Webkit是一款开源渲染引擎，它本来是为linux平台研发的，后来由Apple移植到Mac及Windows上。\r\n> 虽然主流浏览器渲染过程叫法有区别，但是主要流程还是相同的。\r\n\r\n#### 渲染阻塞\r\n> JS可以操作DOM来修改DOM结构，可以操作CSSOM来修改节点样式，这就导致了浏览器在遇到`<script>`标签时，DOM构建将暂停，直至脚本完成执行，然后继续构建DOM。如果脚本是外部的，会等待脚本下载完毕，再继续解析文档。现在可以在`script`标签上增加属性`defer`或者`async`。脚本解析会将脚本中改变DOM和CSS的地方分别解析出来，追加到DOM树和CSSOM规则树上。\r\n> 每次去执行JavaScript脚本都会严重地阻塞DOM树的构建，如果JavaScript脚本还操作了CSSOM，而正好这个CSSOM还没有下载和构建，浏览器甚至会延迟脚本执行和构建DOM，直至完成其CSSOM的下载和构建。所以，`script`标签的位置很重要。\r\n> JS阻塞了构建DOM树，也阻塞了其后的构建CSSOM规则树，整个解析进程必须等待JS的执行完成才能够继续，这就是所谓的JS阻塞页面。\r\n> 由于CSSOM负责存储渲染信息，浏览器就必须保证在合成渲染树之前，CSSOM是完备的，这种完备是指所有的CSS（内联、内部和外部）都已经下载完，并解析完，只有CSSOM和DOM的解析完全结束，浏览器才会进入下一步的渲染，这就是CSS阻塞渲染。\r\n> CSS阻塞渲染意味着，在CSSOM完备前，页面将一直处理白屏状态，这就是为什么样式放在`head`中，仅仅是为了更快的解析CSS，保证更快的首次渲染。\r\n> 需要注意的是，即便你没有给页面任何的样式声明，CSSOM依然会生成，默认生成的CSSOM自带浏览器默认样式。\r\n> 当解析HTML的时候，会把新来的元素插入DOM树里面，同时去查找CSS，然后把对应的样式规则应用到元素上，查找样式表是按照从右到左的顺序去匹配的。\r\n> 例如：`div p {font-size: 16px}`，会先寻找所有`p`标签并判断它的父标签是否为`div`之后才会决定要不要采用这个样式进行渲染）。\r\n> 所以，我们平时写CSS时，尽量用`id`和`class`，千万不要过渡层叠。\r\n\r\n#### reflow（回流）和repaint（重绘） \r\n我们都知道HTML默认是流式布局的，但CSS和JS会打破这种布局，改变DOM的外观样式以及大小和位置。因此我们就需要知道两个概念：`repaint`和`reflow`。\r\n##### reflow（回流）\r\n> 当浏览器发现布局发生了变化，这个时候就需要倒回去重新渲染，大家称这个回退的过程叫`reflow`。`reflow`会从`html`这个`root frame`开始递归往下，依次计算所有的结点几何尺寸和位置，以确认是渲染树的一部分发生变化还是整个渲染树。`reflow`几乎是无法避免的，因为只要用户进行交互操作，就势必会发生页面的一部分的重新渲染，且通常我们也无法预估浏览器到底会`reflow`哪一部分的代码，因为他们会相互影响。\r\n\r\n##### repaint（重绘）\r\n> `repaint`则是当我们改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸和位置没有发生改变。\r\n> 需要注意的是，`display:none`会触发`reflow`，而`visibility: hidden`属性则并不算是不可见属性，它的语义是隐藏元素，但元素仍然占据着布局空间，它会被渲染成一个空框。所以`visibility:hidden`只会触发`repaint`，因为没有发生位置变化。\r\n> 另外有些情况下，比如修改了元素的样式，浏览器并不会立刻`reflow`或`repaint`一次，而是会把这样的操作积攒一批，然后做一次`reflow`，这又叫异步`reflow`或增量异步`reflow`。但是在有些情况下，比如`resize`窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行`reflow`。\r\n\r\n##### 引起reflow（回流）\r\n> 现代浏览器会对回流做优化，它会等到足够数量的变化发生，再做一次批处理回流。\r\n> - 页面第一次渲染（初始化）\r\n> - DOM树变化（如：增删节点）\r\n> - Render树变化（如：`padding`改变）\r\n> - 浏览器窗口`resize`\r\n> - 获取元素的某些属性\r\n> 浏览器为了获得正确的值也会提前触发回流，这样就使得浏览器的优化失效了，这些属性包括`offsetLeft、offsetTop、offsetWidth、offsetHeight、 scrollTop/Left/Width/Height、clientTop/Left/Width/Height`、调用了`getComputedStyle()`。\r\n\r\n##### 引起repaint（重绘）\r\n> `reflow`回流必定引起`repaint`重绘，重绘可以单独触发。\r\n> 背景色、颜色、字体改变（注意：字体大小发生变化时，会触发回流）\r\n\r\n##### 减少reflow（回流）、repaint（重绘）触发次数\r\n> - 用`transform`做形变和位移可以减少`reflow`\r\n> - 避免逐个修改节点样式，尽量一次性修改\r\n> - 使用`DocumentFragment`将需要多次修改的DOM元素缓存，最后一次性`append`到真实DOM中渲染\r\n> - 可以将需要多次修改的DOM元素设置`display:none`，操作完再显示。（因为隐藏元素不在`render`树内，因此修改隐藏元素不会触发回流重绘）\r\n> - 避免多次读取某些属性\r\n> - 通过绝对位移将复杂的节点元素脱离文档流，形成新的Render Layer，降低回流成本\r\n\r\n#### 几条关于优化渲染效率的建议\r\n> 结合上文有以下几点可以优化渲染效率。\r\n> - 合法地去书写HTML和CSS ，且不要忘了文档编码类型。\r\n> - 样式文件应当在`head`标签中，而脚本文件在`body`结束前，这样可以防止阻塞的方式。\r\n> - 简化并优化CSS选择器，尽量将嵌套层减少到最小。\r\n> - DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。\r\n> - 如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。\r\n> - 不要一条条地改变样式，而要通过改变`class`，或者`csstext`属性，一次性地改变样式。\r\n> - 尽量用`transform`来做形变和位移\r\n> - 尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式。比如，操作`Document Fragment`对象，完成后再把这个对象加入DOM。再比如，使用`cloneNode()`方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。\r\n> - 先将元素设为`display: none`（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。\r\n> - `position`属性为`absolute`或`fixed`的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。\r\n> - 只在必要的时候，才将元素的`display`属性为可见，因为不可见的元素不影响重排和重绘。另外，`visibility : hidden`的元素只对重绘有影响，不影响重排。\r\n>   使用`window.requestAnimationFrame()`、`window.requestIdleCallback()`这两个方法调节重新渲染。",G={data:function(){return{MainComponent:V}}},z=G,$=Object(m["a"])(z,B,W,!1,null,"1002e786",null),X=$.exports,K=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div")},Q=[],Y={},Z=Y,nn=Object(m["a"])(Z,K,Q,!1,null,"8219d5e2",null),tn=nn.exports,rn=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div")},en=[],an={},on=an,sn=Object(m["a"])(on,rn,en,!1,null,"26379dc4",null),ln=sn.exports,cn=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},pn=[],un="## 重排和重绘\r\n### （1）写在前面：\r\n> - 浏览器使用流式布局模型 (Flow Based Layout)。\r\n> - 浏览器会把HTML解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就产生了Render Tree。\r\n> - 有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。\r\n> - 由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。\r\n> - 重排（reflow）必将引起重绘（Repaint），重绘不一定会引起重排。\r\n\r\n### （2）重排（reflow）\r\n> - 定义\r\n>   - 当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为重排。\r\n> - 会导致重排的操作：\r\n>   - 页面首次渲染\r\n>   - 浏览器窗口大小发生改变\r\n>   - 元素尺寸或位置发生改变\r\n>   - 元素内容变化（文字数量或图片大小等等）\r\n>   - 元素字体大小变化\r\n>   - 添加或者删除可见的DOM元素\r\n>   - 激活CSS伪类（例如：:hover）\r\n>   - 查询某些属性或调用某些方法\r\n> - 一些常用且会导致重排的属性和方法：\r\n>   - clientWidth、clientHeight、clientTop、clientLeft\r\n>   - offsetWidth、offsetHeight、offsetTop、offsetLeft\r\n>   - scrollWidth、scrollHeight、scrollTop、scrollLeft\r\n>   - scrollIntoView()、scrollIntoViewIfNeeded()\r\n>   - getComputedStyle()\r\n>   - getBoundingClientRect()\r\n>   - scrollTo()\r\n\r\n### （3）重绘 (Repaint)\r\n> - 当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。\r\n### （4）什么情况会触发重排和重绘？\r\n> - 添加、删除、更新 DOM 节点\r\n> - 通过 display: none 隐藏一个 DOM 节点-触发重排和重绘\r\n> - 通过 visibility: hidden 隐藏一个 DOM 节点-只触发重绘，因为没有几何变化\r\n> - 移动或者给页面中的 DOM 节点添加动画\r\n> - 添加一个样式表，调整样式属性\r\n> - 用户行为，例如调整窗口大小，改变字号，或者滚动。\r\n\r\n### （5）性能影响\r\n> - 重排比重绘的代价要更高。\r\n> - 现代浏览器对频繁的重排和重绘进行了优化\r\n>   - 有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。\r\n>   - 浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。\r\n> - 获取布局的操作，会导致队列刷新，浏览器的优化效果也就没有了。要避免在布局信息改变时，获取下列属性\r\n>   - clientWidth、clientHeight、clientTop、clientLeft\r\n>   - offsetWidth、offsetHeight、offsetTop、offsetLeft\r\n>   - scrollWidth、scrollHeight、scrollTop、scrollLeft\r\n>   - width、height\r\n>   - getComputedStyle()\r\n>   - getBoundingClientRect()\r\n\r\n### （6）如何避免\r\n> - CSS\r\n>   - （1）避免使用table布局。\r\n>   - （2）尽可能在DOM树的最末端改变class。\r\n>   - （3）避免设置多层内联样式。\r\n>   - （4）将动画效果应用到position属性为absolute或fixed的元素上。\r\n>   - （5）避免使用CSS表达式（例如：calc()）。\r\n> - JavaScript\r\n>   - 1. 合并多次的DOM操作为单次的DOM操作\r\n>     - （1）避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。\r\n>       - 方案2比方案1稍微有一些性能上的损耗，因为它需要查询CSS类。但方案2的维护性最好，\r\n>       - 类似的操作还有通过innerHTML接口修改DOM元素的内容。不要直接通过此接口来拼接HTML代码，而是以字符串方式拼接好代码后，一次性赋值给DOM元素的innerHTML接口。\r\n>   - 1. 把DOM元素离线或隐藏后修改\r\n>     把DOM元素从页面流中脱离或隐藏，这样处理后，只会在DOM元素脱离和添加时，或者是隐藏和显示时才会造成页面的重绘或回流，对脱离了页面布局流的DOM元素操作就不会导致页面的性能问题。这种方式适合那些需要大批量修改DOM元素的情况。具体的方式主要有三种：\r\n>     - （2）避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。\r\n>       - 文档片段是一个轻量级的document对象，并不会和特定的页面关联。通过在文档片段上进行DOM操作，可以降低DOM操作对页面性能的影响，这 种方式是创建一个文档片段，并在此片段上进行必要的DOM操作，操作完成后将它附加在页面中。对页面性能的影响只存在于最后把文档片段附加到页面的这一步 操作上。\r\n>     - （3）也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。\r\n>       - 这种方式是通过隐藏页面的DOM元素，达到在页面中移除元素的效果，经过大量的DOM操作后恢复元素原来的display样式。对于这类会引起页面重绘或回流的操作，就只有隐藏和显示DOM元素这两个步骤了。\r\n>     - （4）避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。\r\n>       - 这种方式是把页面上的DOM元素克隆一份到内存中，然后再在内存中操作克隆的元素，操作完成后使用此克隆元素替换页面中原来的DOM元素。这样一来，影响性能的操作就只是最后替换元素的这一步操作了，在内存中操作克隆元素不会引起页面上的性能损耗。\r\n>   - 1. 设置具有动画效果的DOM元素的position属性为fixed或absolute\r\n>     - （5）对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。\r\n>       - 把页面中具有动画效果的元素设置为绝对定位，使得元素脱离页面布局流，从而避免了页面频繁的回流，只涉及动画元素自身的回流了。这种做法可以提高动 画效果的展示性能。如果把动画元素设置为绝对定位并不符合设计的要求，则可以在动画开始时将其设置为绝对定位，等动画结束后恢复原始的定位设置。在很多的 网站中，页面的顶部会有大幅的广告展示，一般会动画展开和折叠显示。如果不做性能的优化，这个效果的性能损耗是很明显的。使用这里提到的优化方案，则可以 提高性能。\r\n>   - 1. 谨慎取得DOM元素的布局信息\r\n>     - 获取DOM的布局信息会有性能的损耗，所以如果存在重复调用，最佳的做法是尽量把这些值缓存在局部变量中。\r\n>       - 例如，在一个循环中反复取得一个元素的offsetTop值，事实上，在如果该元素的offsetTop值并不会变更，优化的方案是在循环外部取得元素的offsetTop值，相比循环内读取，只是调用了一遍元素的offsetTop值。\r\n>     - 浏览器会优化连续的DOM操作\r\n>       - 因为取得DOM元素的布局信息会强制浏览器刷新渲染树，并且可能会导致页面的重绘或回流，所以在有大批量DOM操作时，应避免获取DOM元素 的布局信息，使得浏览器针对大批量DOM操作的优化不被破坏。如果需要这些布局信息，最好是在DOM操作之前就取得。\r\n>       - 如果把取得DOM元素的布局信息提前，因为浏览器会优化连续的DOM操作，所以实际上只会有一次的页面回流出现",mn={data:function(){return{MainComponent:un}}},dn=mn,gn=Object(m["a"])(dn,cn,pn,!1,null,"126eade4",null),bn=gn.exports,hn=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},yn=[],fn='# 跨域\r\n## 常见浏览器跨域的解决方式大概6种\r\n> ### 跨域请求\r\n> - 1.jsonp 需要目标服务器配合一个callback函数。\r\n> - 2.CORS 需要服务器设置header ：Access-Control-Allow-Origin。\r\n> - 3.nginx反向代理 这个方法一般很少有人提及，但是他可以不用目标服务器配合，不过需要你搭建一个中转nginx服务器，用于转发请求。\r\n> ### 访问跨域的页面\r\n> - 4.window.name+iframe 需要目标服务器响应window.name。\r\n> - 5.window.location.hash+iframe 同样需要目标服务器作处理。\r\n> - 6.html5的 postMessage+iframe 这个也是需要目标服务器或者说是目标页面写一个postMessage，主要侧重于前端通讯。\r\n\r\n## 浏览器同源政策及其规避方法\r\n\r\n### 同源策略限制范围\r\n> - （1） Cookie、LocalStorage 和 IndexDB 无法读取。\r\n> - （2） DOM 无法获得。\r\n> - （3） AJAX 请求不能发送。\r\n\r\n### Cookie\r\n> - 解决\r\n>   - 两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享 Cookie。\r\n>   - 举例来说，A网页是http://w1.example.com/a.html，B网页是http://w2.example.com/b.html，那么只要设置相同的document.domain，两个网页就可以共享Cookie。\r\n>   - document.domain = \'example.com\'; ----\x3e现在，A网页通过脚本设置一个 Cookie。document.cookie = "test1=hello"; ----\x3eB网页就可以读到这个 Cookie。var allCookie = document.cookie;\r\n> - 注意\r\n>   - 注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。\r\n\r\n### iframe\r\n> - 问题\r\n>   - 如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。\r\n> - 解决\r\n>   - 同源的情况\r\n>     - 如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的document.domain属性，就可以规避同源政策，拿到DOM。\r\n>     - iframe访问父页面可通过window.parent得到父窗口的window对象，通过open打开的可以用window.opener，进而得到父窗口的任何东西；父窗口如果和iframe同源的，那么可通过iframe.contentWindow得到iframe的window对象\r\n>   - 对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。\r\n>     - 片段识别符（fragment identifier）\r\n>       - 定义\r\n>         - 片段标识符（fragment identifier）指的是，URL的#号后面的部分，比如http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。\r\n>     - window.name\r\n>       - 定义\r\n>         - 浏览器窗口有window.name属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。\r\n>       - 优缺点\r\n>         - 这种方法的优点是，window.name容量很大，可以放置非常长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能\r\n>     - 跨文档通信API（Cross-document messaging）\r\n>       - 定义\r\n>         - 这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。\r\n>         - 举例来说，父窗口[http://aaa.com](http://aaa.com/)向子窗口[http://bbb.com](http://bbb.com/)发消息，调用postMessage方法就可以了。\r\n>       - 语法\r\n>         - otherWindow.postMessage(message, targetOrigin);\r\n>       - 基本使用\r\n>         - postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即"协议 + 域名 + 端口"。也可以设为*，表示不限制域名，向所有窗口发送。\r\n>         - 父窗口和子窗口都可以通过message事件，监听对方的消息。\r\n>         - message事件的事件对象event，提供以下三个属性。\r\n>           - event.source：发送消息的窗口\r\n>           - event.origin: 消息发向的网址\r\n>           - event.data: 消息内容\r\n\r\n### AJAX\r\n> - 除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。\r\n> - JSONP\r\n>   - 基本思想\r\n>     - 它的基本思想是，网页通过添加一个script元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。\r\n>   - 应用\r\n>     - 首先，网页动态插入script元素，由它向跨源网址发出请求。\r\n>     - 通过动态添加script元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。\r\n>     - 服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。\r\n>     - 由于script元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。\r\n>   - 优缺点\r\n>     - 优点\r\n>       - 兼容性好，可以在更古老的浏览器中运行\r\n>     - 缺点\r\n>       - 只支持GET\r\n> - WebSocket\r\n>   - 基本思想\r\n>     - WebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。\r\n> - CORS\r\n>   - 简单请求（simple request）\r\n>     - 满足条件\r\n>       - （1) 请求方法是以下三种方法之一：\r\n>         - HEAD\r\n>         - GET\r\n>         - POST\r\n>       - （2）HTTP的头信息不超出以下几种字段：\r\n>         - Accept\r\n>         - Accept-Language\r\n>         - Content-Language\r\n>         - Last-Event-ID\r\n>         - Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain\r\n>     - 基本流程\r\n>       - （1）对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。\r\n>         - 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。\r\n>       - （2）如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。\r\n>       - （3）如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。\r\n>         - 上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。\r\n>           - （1）Access-Control-Allow-Origin\r\n>             - 该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。\r\n>           - （2）Access-Control-Allow-Credentials\r\n>             - 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。\r\n>           - （3）Access-Control-Expose-Headers\r\n>   - 非简单请求（not-so-simple request）\r\n>     - 满足条件\r\n>       - 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。\r\n>     - 基本流程\r\n>       - （1）非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。要求服务器确认可以这样请求。\r\n>       - （2）浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。\r\n>       - "预检"请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。\r\n>   - 关于Node.js对于CORS的后端配置\r\n>   \r\n>     - 请注意，代码与之前的区别就在于相对路径换成了其他域的绝对路径，也就是你要跨域访问的接口地址。\r\n>   \r\n>     \r\n\r\n## 跨域与安全\r\n### 1.两个误区\r\n> - 1.并不是动态请求就会有跨域的问题，跨域只存在于浏览器端，不存在于安卓/ios/Node.js/python/ java等其它环境\r\n> - 2.跨域并不是请求发不出去了，跨域请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了\r\n\r\n### 2.同源策略具体限制些什么呢？\r\n> -  不能向工作在不同源的的服务请求数据（client to server）\r\n> -  无法获取不同源的document/cookie等BOM和DOM，可以说任何有关另外一个源的信息都无法得到 （client to client）\r\n\r\n### 3.为什么会有同源策略呢？\r\n> - 为什么要限制不同源发请求？\r\n>   - 假设用户登陆了bank.com，同时打开了evil.com，如果没有任何限制，evil.com可以向bank.com请求到任何信息，进而就可以在evil.com向bank.com发转账请求等。\r\n> - 为什么限制跨域的DOM读取？\r\n>   - 如果不限制的话，那么很容易就可以伪装其它的网站，如套一个iframe或者通过window.open的方法，从而得到用户的操作和输入，如账户、密码。\r\n\r\n### 4.跨域常用方法【CORS】\r\n> - 定义\r\n>   - 只要浏览器检测到响应头带上了CORS，并且允许的源包括了本网站，那么就不会拦截请求响应。\r\n> - CORS把请求分为两种\r\n>   - 一种是简单请求\r\n>   - 一种是需要触发预检请求\r\n>     - 条件\r\n>       - （1）使用了除GET/POST/HEAD之外的请求方式，如PUT/DELETE\r\n>       - （2）使用了除Content-Type/Accept等几个常用的http头\r\n>     - 预检请求使用OPTIONS方式去检查当前请求是否安全\r\n>       - 代码里面只发了一个请求，但在控制台看到了两个请求，第一个是OPTIONS，服务端返回：\r\n>       - 返回头里面包含了允许的请求头、请求方式、源，以及预检请求的有效期，上图是设置了20天，在这个有效期内就不用再发一个options的请求，实际上浏览器有一个最长时间，如Chrome是5分钟。如果在预检请求检测到当前请求不符合服务端设定的要求，则不会发出去了直接抛异常，这个时候就不用去发“复杂”的请求了。\r\n>       - 如本源不在允许的源范围内，则会抛异常，无法获取返回结果：\r\n>   \r\n>   \r\n\r\n### 5.跨域常用的方法【JSONP】\r\n> - 原理\r\n>   当需要通讯时，本站脚本创建一个script元素，地址指向第三方的API网址，形如： script src="http://www.example.net/api?param1=1"  script 并提供一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。 第三方产生的响应为json数据的包装（故称之为jsonp，即json padding），形如： callback({"name":"hax","gender":"Male"}) 这样浏览器会调用callback函数，并传递解析后json对象作为参数。本站脚本可在callback函数里处理所传入的数据。\r\n>   - JSONP是利用了script标签能够跨域， jsonp本身就是一个get请求，而script节点本身也是一个get请求\r\n>   - 凡是拥有"src"这个属性的标签都拥有跨域的能力，比如script、img、iframe\r\n>   - 代码先定义一个全局函数，然后把这个函数名通过callback参数添加到script标签的src，script的src就是需要跨域的请求，然后这个请求返回可执行的JS文本：\r\n>   - 由于它是一个js，并且已经定义了upldateList函数，所以能正常执行，并且跨域的数据通过传参得到。这就是JSONP的原理。\r\n> - 跨站请求伪造（CSRF）\r\n>   - 原理\r\n>     - 由于script/iframe/img等标签的请求默认是能带上cookie（cookie里面带上了登陆验证的票token），用这些标签发请求是能够绕过同源策略的，因此就可以利用这些标签做跨站请求伪造（CSRF）\r\n>     - 如果相应的网站支持GET请求，或者没有做进一步的防护措施，那么如果用户在另外一个页面登陆过了，再打开一个“有毒”的网站就中招了\r\n\r\n### 6.总结及注意\r\n> - 注意\r\n>   - 1.子域如mail.hello.com要跨hello.com的时候，可以显式地设置子域的document.domain值为父域的domain（或多个子域互相读取cookie）：\r\n>     - 这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。\r\n>   - 2.websocket是不受同源策略限制的，没有跨域的问题。\r\n>   - 3.CSS的字体文件是会有跨域问题，指定CORS就能加载其它源的字体文件（通常是放在cdn上的）。\r\n>   - 4.canvas动态加载的外部image，也是需要指定CORS头才能进行图片处理，否则只能画不能读取。\r\n>   - 5.还可以通过window.name来实现跨域\r\n>     - 在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。\r\n> - 总结\r\n>   - 跨域分为两种，一种是跨域请求，另一种访问跨域的页面，跨域请求可以通过CORS/JSONP等方法进行访问，跨域的页面主要通过postMesssage的方式。由于跨域请求不但能发出去还能带上cookie，所以要规避跨站请求伪造攻击的风险，特别是涉及到钱的那种请求。',vn={data:function(){return{MainComponent:fn}}},Sn=vn,_n=Object(m["a"])(Sn,hn,yn,!1,null,"6dacb625",null),kn=_n.exports,jn=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},wn=[],xn="# BOM浏览器对象模型\r\n### BOM的核心对象：windows对象\r\n- 全局作用域\r\n\t> - 即是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象。\r\n\t> - 所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法\r\n\t> - 全局变量不能通过delete操作符删除，而直接在window对象上定义的属性可以\r\n- 窗口关系及框架\r\n\t> - 如果页面中包含框架，则每个框架都拥有自己的window对象\r\n\t> - 在frames集合中可以通过数值索引（从0开始从左到右从上到下排序）或框架名称来访问window对象\r\n\t> - top对象始终指向最外层的框架，即浏览器窗口\r\n\t> \t- top.frames[ 1]\r\n\t> - window对象指向所在框架的特定实例\r\n\t> \t- window.frame[ 1]\r\n\t> - parent对象指向当前框架的直接上层框架\r\n\t> - self对象始终指向window，可以和window对象互换使用\r\n- 窗口位置\r\n\t > - 确定和修改window对象位置\r\n\t\t> - 跨浏览器取得窗口左边和上边的位置\r\n\t\t> \t- screenLeft和screenRight属性\r\n\t\t> \t\t- IE/Safari/Opera/Chrome\r\n\t\t> \t- screenX和screenY属性\r\n\t\t> \t\t- FireFox/Safari/Chrome\r\n\t\t> - 精确移动窗口位置\r\n\t\t> \t- moveTo()方法\r\n\t\t> \t\t- 新位置的x, y坐标值\r\n\t\t> \t\t\t- window.movwTo(200, 300)\r\n\t\t> \t- moveBy()方法\r\n\t\t> \t\t- 接受在水平和垂直方向上移动的像素值两个参数\r\n\t\t> \t\t\t- window.movwBy(-50, 100)\r\n\t\t> \t- moveBy()和moveTo()都可能被浏览器禁用且不适用于框架，只能对最外层window对象使用\r\n- 窗口大小\r\n\t> - 跨浏览器确定窗口大小\r\n\t> \t- IE9+/FireFox/Safari/Opera/Chrome\r\n\t> \t\t- innerWidth/innerHeight/outerWidth/outerHeight四个属性\r\n\t> \t\t- outerWidth/outerHeight\r\n\t> \t\t\t- IE9+/FireFox/Safari中返回浏览器窗口本身尺寸\r\n\t> \t\t\t- Opera中表示页面视图容器大小\r\n\t> \t\t- innerWidth/innerHeight\r\n\t> \t\t\t- 页面视图区大小（减去边框宽度）\r\n\t> - 调整浏览器窗口大小\r\n\t> \t- resizeTo()方法\r\n\t> \t\t- 接受浏览器窗口的新高度和宽度两个参数\r\n\t> \t- resizeBy()方法\r\n\t> \t\t- 接受浏览器新窗口的高度和宽度之差两个参数\r\n\t> \t- resizeBy()和resizeTo()都可能被浏览器禁用且不适用于框架，只能对最外层window对象使用\r\n- 导航和打开窗口\r\n\t >- window.open()方法\r\n\t\t> - 打开新的浏览器窗口或导航到特定url\r\n\t\t> - 接受四个参数：要加载的URL、窗口目标、一个特性字符串和一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值\r\n\t\t> - 弹出窗口\r\n\t\t> \t- window.open(\"http://……\", \"topFrame\")\r\n\t\t> \t\t- 有名为topFrame的框架或窗口则在其中加载这个URL\r\n\t\t> \t\t- 若无则创建新窗口并命名为topFrame\r\n\t\t> \t\t- 第二个参数可以是 _self/_parent/_top/_blank\r\n\t\t> \t- 第二个参数不是已存在框架或窗口\r\n\t\t> \t\t- 根据第三个参数创建新窗口或标签页\r\n\t\t> \t\t\t- 无第三个参数则打开全部默认设置的新窗口\r\n\t\t> \t\t- 不打开新窗口则忽略第三个参数\r\n\t\t> \t- 有的浏览器默认不允许针对主浏览器窗口调整大小或移动位置，但允许对通过window.open()创建的窗口调整\r\n\t\t> \t- .opener属性保存打开window对象的原始窗口对象\r\n\t\t> \t\t- var wroxWin=window.open('#', 'wropWindow'); alert(wropWin.opener==window;) //true\r\n\t\t> - 安全限制：许多浏览器限制弹出窗口的实现配置\r\n\t\t> - 弹出窗口屏蔽程序\r\n\t\t> \t- 检测是否被屏蔽\r\n- 间歇调用和超时调用\r\n\t> - 超时调用\r\n\t> \t- 指定的时间过后执行代码\r\n\t> \t- 使用window对象的setTimeout()方法\r\n\t> \t\t- 两个参数：要执行的参数，以毫秒表示的时间\r\n\t> \t\t\t- setTimeout(function(){ alert(\"hello\");}, 1000);\r\n\t> \t\t\t- 第二个参数表示过多久把当前任务添加到队列中，若队列不为空则等前面代码执行完了执行\r\n\t> \t\t- 返回一个数值ID表示超时调用，可通过此ID取消超时调用\r\n\t> \t\t\t- ClearTimeout(timeoutId);\r\n\t> - 间歇调用\r\n\t> \t- 按照指定时间间隔重复执行代码\r\n\t> \t- setInterval()方法\r\n\t> \t\t- 使用方法与setTimeout()方法相同\r\n\t> \t- 开发环境下后一个间歇调用可能会在前一个间歇调用结束之前启动。所以一般使用超时调用，很少使用间歇调用\r\n- 系统对话框\r\n\t> - 浏览器调用系统对话框方法：alert()/confirm()/prompt()\r\n\t> \t- 打开的对话框是同步和模态的，打开时代码会停止执行\r\n\t> - 与网页无关，不包含HTML，由操作系统和浏览器设置决定外观\r\n\t> - alert()方法一般显示警告信息，只有确定按钮\r\n\t> - confirm()方法有确认和取消按钮，返回true和false值\r\n\t> - prompt()方法生成提示框，可以输入文本\r\n\t> \t- 接受要显示给用户的文本提示和文本输入域默认值两个参数\r\n\t> \t- 单击ok返回文本输入域值，单击cancel返回null\r\n\t> - 通过javascript可以打开查找和打印对话框\r\n\t> \t- window.print(); window.find();\r\n### location对象\r\n> - 提供与当前窗口中加载文档有关信息和一些导航功能\r\n> - 即是window对象又是document对象\r\n> - 将URL解析为独立片段，开发人员可以通过不同属性访问这些片段\r\n> \t- hash属性\r\n> \t\t- 返回URL中的hash（#后跟0或多个字符）\r\n> \t- host属性\r\n> \t\t- 返回服务器名称和端口号\r\n> \t- hostname属性\r\n> \t\t- 返回不带端口号的服务器名称\r\n> \t- href属性\r\n> \t\t- 返回当前加载页面完整URL\r\n> \t- ……\r\n> - 查询字符串参数\r\n> - 位置操作\r\n> \t- 改变浏览器位置并生成新历史记录\r\n> \t\t- assign()方法\r\n> \t\t\t- location.assign('URL');\r\n> \t\t\t- 将location.href或window.location设置为一个URL也会调用assign()方法\r\n> \t\t- 修改location对象的其他属性也可以改变当前加载页面\r\n> \t\t- 使用replace()方法不会在历史记录中生成新纪录，用户无法回到前一个页面\r\n> \t\t- reload()方法重新加载当前页面\r\n> \t\t\t- location.reload(true); 强制从服务器重新加载\r\n> \t\t\t- 位于reload()方法之后的代码受网络延迟或系统资源因素影响可能不会执行，一般将其放在代码最后一行\r\n\r\n### navigator对象\r\n> - 提供客户端浏览器信息，是识别客户端浏览器的事实标准\r\n> - 检测插件\r\n> \t- 非IE浏览器：使用plugins数组\r\n> \t\t- 数组属性\r\n> \t\t\t- name，插件名字\r\n> \t\t\t- description：插件描述\r\n> \t\t\t- filename：插件文件名\r\n> \t\t\t- length：插件所处理的MIME类型数量\r\n> \t\t- hasPlugin()函数\r\n> \t\t\t- 接受要检测的插件名作为参数\r\n> \t\t\t- 可以在FireFox/Opera/Safari/Chrome中使用这种方法\r\n> \t- IE浏览器\r\n> \t\t- 使用专有ActiveXObject类型并尝试创建一个特定插件的实例\r\n> \t\t\t- IE使用COM对象方式实现插件\r\n> \t\t\t\t- COM对象使用唯一标识符来标识\r\n> \t\t\t- hasIEPlugin()函数\r\n> \t\t\t\t- 接收一个COM标识符为参数\r\n> \t\t\t\t- 在try-catch语句中进行实例化\r\n> \t- 典型做法：针对每个插件分别创建检测函数\r\n> - 注册处理程序\r\n> \t- FireFox2为navigator对象新增registerContentHandler()和registerProtocolHandler()方法\r\n> \t\t- 可以让一个站点指明它可以处理的特定类型的信息\r\n> \t- registerContentHandler()方法\r\n> \t\t- 三个参数：要处理的MIME类型、可以处理该类型的页面的URL、应用程序名称\r\n> \t- registerProtocolHandler()方法\r\n> \t\t- 三个参数：要处理的协议、处理该协议的页面的URL、应用程序名称\r\n\r\n### screen对象\r\n> - 基本上只用于表明客户端的能力\r\n> \t- 包括浏览器窗口外部显示器信息如像素宽度和高度等\r\n> - 每个浏览器中的screen对象包含不同属性\r\n> - 有时用于调整浏览器窗口大小\r\n\r\n### history对象\r\n> - 保存用户上网的历史记录\r\n> \t- 因为history对象是window对象的属性，所以每个浏览器窗口、标签页乃至每个框架都有自己的history对象与特定window对象关联\r\n> \t- 出于安全考虑，开发者无法得知用户浏览过的URL\r\n> - go()方法\r\n> \t- 可以在用户历史记录中任意跳转，向前或向后\r\n> \t- 接受表示向前或向后跳转的页面数的整数值作为一个参数\r\n> \t\t- history.go(-1); 后退一页\r\n> \t\t- history.go(2); 前进两页\r\n> \t- 接受一个字符串作为参数跳转到最近的包含该字符串的位置\r\n> \t\t- history.go('wrox.com'); 可能前进或后退\r\n> \t- back()/forword()方法代替go()，后退或前进一步\r\n> - length属性\r\n> \t- 检测当前页面是不是用户历史记录中第一个页面\r\n> \t\t- if (history.length==0){};\r\n\r\n## BOM\r\n### 说明：window对象上面的属性和方法\r\n> \r\n>\r\n> - 1.onload\r\n> \t- 页面加载完（等在静态资源加载完成），才执行这个函数\r\n> - 2.定时器\r\n> \t- 一次性定时器\r\n> \t\t- 1.setTimeout:（函数，毫秒数）\r\n> \t\t\t- 返回值：返回这个定时器的id\r\n> \t\t- 2 clearTimeout（定时器的id） 停止\r\n> \t- 永久性定时器\r\n> \t\t- 1.setInterval：（函数，毫秒数）\r\n> \t\t\t- 返回值：返回这个定时器的id\r\n> \t\t- 2 clearInterval（定时器的id） 清除永久定时器\r\n> - 3.location\r\n> \t- 负责管理浏览器地址相关的行为和信息的对象\r\n> \t\t- 例：window.location.href = \"http://www.baidu.com\"\r\n> - 4.localStorage\r\n> \t- 实现数据本地化，刷新后还在\r\n> \t- 1.setItem(键，值)\r\n> \t- 2.getItem（键）------没有值，返回null\r\n> \t- 3.removeItem（键）\r\n> \t- 4.clear() 清除全部\r\n> - 5.JSON\r\n> \t- 介绍：\r\n> \t\t- 1.本质是有一定格式的字符串\r\n> \t\t- 2.BOM上的方法\r\n> \t- 方法：\r\n> \t\t- 1.JSON.stringify(对象);\r\n> \t\t\t- 把对象转为字符串\r\n> \t\t- 2.JSON.parse(json格式字符串);\r\n> \t\t\t- JSON格式的字符串转为对象\r\n",Tn={data:function(){return{MainComponent:xn}}},Cn=Tn,Mn=Object(m["a"])(Cn,jn,wn,!1,null,"6deeb381",null),Pn=Mn.exports,On=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},En=[],Rn='# dom\r\n## DOM事件机制\r\n### 事件代理（委托）\r\n > - 由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。\r\n  > - 减少内存消耗，提高性能\r\n  > - 动态绑定事件\r\n### Event对象常见应用\r\n> - event.preventDefault\r\n>   - 默认事件行为将不会触发\r\n> - event.stopPropagation\r\n>   - 阻止事件冒泡到父元素，阻止任何父事件处理程序被执行。\r\n> - stopImmediatePropagation\r\n>   - 既能阻止事件向父元素冒泡，也能阻止元素同事件类型的其它监听器被触发。\r\n> - event.target & event.currentTarget\r\n>   - event.target\r\n>     - 指向引起触发事件的元素\r\n>       - 一个目标元素\r\n>   - event.currentTarget\r\n>     - 返回绑定事件的元素\r\n>       - 目标元素+冒泡经过元素\r\n>   - 包含所有与事件有关的信息\r\n>   - this始终等于currentTarget的值\r\n\r\n### DOM事件模型和事件流\r\n> - 事件模型\r\n>   - 捕获\r\n>   - 冒泡\r\n> - 事件传播\r\n>   - 捕获阶段\r\n>   - 目标阶段\r\n>   - 冒泡阶段\r\n\r\n### DOM事件级别\r\n> - DOM0级事件\r\n>   - 不允许给一个元素绑定多个事件\r\n>   - 事件方法在事件行为的冒泡阶段执行\r\n> - DOM2级事件\r\n>   - IE9以上\r\n>     - addEventListener\r\n>       - event-name\r\n>         - 事件名称\r\n>       - callback\r\n>         - 回调函数，参数为当前事件对象event\r\n>       - useCapture\r\n>         - 默认是false，代表事件句柄在冒泡阶段执行\r\n>     - removeEventListener\r\n>       - 绑定的函数最好是声明函数变量，这样才能将同一个函数传入\r\n>     - 事件程序作用域是依附元素作用域\r\n>   - IE9以下\r\n>     - attachEvent\r\n>     - detachEvent\r\n>       - 绑定的函数最好是声明函数变量，这样才能将同一个函数传入\r\n>     - 第一个事件名称前要加on。\r\n>     - 因为IE9以下是不支持事件捕获的，所以也没有第三个参数。\r\n>     - 事件处理程序的作用域是全局作用域\r\n> - DOM3级事件\r\n>   - UI事件\r\n>     - load\r\n>     - sroll\r\n>   - 焦点事件\r\n>     - blur\r\n>     - focus\r\n>   - 鼠标事件\r\n>     - dblclick\r\n>     - mouseup\r\n>   - 滚轮事件\r\n>     - mousewheel\r\n>   - 文本事件\r\n>     - textInput\r\n>   - 键盘事件\r\n>     - keydown\r\n>     - keypress\r\n>   - 合成事件\r\n>     - compositionstart\r\n>   - 变动事件\r\n>     - DOMsubtreeModified\r\n>   - 自定义事件\r\n\r\n## DOM\r\n### 1.获取DOM\r\n> - 1.节点(元素对象，DOM节点)\r\n>   - 1.返回DOM节点\r\n>     - 1.getElementById("id名")\r\n>     - 2.querySelector("CSS名")\r\n>   - 2.返回伪数组\r\n>     - 1.getElementByTagName("标签名")\r\n>     - 2.getElementByClassName（"类名"）\r\n>     - 3.querySelectorAll("CSS名")\r\n> - 2.DOM样式\r\n>   - 1.dom.style.color\r\n>     - 1.DOM只能操作行内样式\r\n>   - 2.window.getComputedStyle(box)  括号中填写元素对象，DOM节点，\r\n>     - 1.返回的属性值为字符串\r\n>     - 2.返回所有（无论是行内还是非行内）的样式集合/对象\r\n\r\n### 2.注册事件\r\n> - 1.点击事件（元素对象，DOM节点）\r\n>   - click\r\n> - 2.焦点事件\r\n>   - focus\r\n>     - 获取焦点\r\n>       - 注册给有光标的标签\r\n>   - blur\r\n>     - 失去焦点\r\n>       - 注册给有光标的标签\r\n> - 3.鼠标事件\r\n>   - mousedown\r\n>     - 鼠标点下\r\n>   - mousemove\r\n>     - 鼠标移动\r\n>   - mouseup\r\n>     - 鼠标松开\r\n>   - mouseover《==》mouseenter\r\n>     - 鼠标移入，后者不支持冒泡\r\n>   - mouseout《==》mouseleave\r\n>     - 鼠标移除，后者不支持冒泡\r\n> - 4.键盘事件\r\n>   - keydown\r\n>     - 按键按下\r\n>   - keyup\r\n>     - 按键抬起\r\n> - 5.滚动事件\r\n>   - scroll 当元素滚动的时候执行\r\n> - 6.动画结束后触发事件（只能用addEventListener）\r\n>   - 1.transitionend\r\n>     - 元素过度结束时执行\r\n>   - 2.animationed\r\n>     - 元素帧动画结束时执行\r\n> - 7.触摸事件（移动端）\r\n>   - 1.touch（刚刚触摸）\r\n>   - 2.touchmove（手指滑动）\r\n>   - 3.touchend（手指离开）\r\n> - 8.存在多次注册事件，容易被后者覆盖，解决方法：\r\n>   - 例：btn.addEventListener("click",function()\r\n>    console.log(1);\r\n>     )\r\n\r\n### 3.属性\r\n> - 1.自定义属性\r\n>   \r\n>   - 说明：把数据存储到对应元素的身上使用的属性，没有特别功能，仅是需要，返回值是 对象\r\n>   - 1.用法\r\n>     - 1.定义： data-  开头的\r\n>     - 2.取值：例如：console.log(dom_div.dataset.name)\r\n> - 2.相关方法（推荐用于自定义属性操作）\r\n>   - 1.getAttribute("属性名称") -----获取\r\n>   - 2.setAttribute("属性名","属性值")-----设置\r\n>   - 3.removeAttribute("属性名称")------删除\r\n> - 3.标准属性\r\n>   - 说明：html中出现的，具有特别功能的属性\r\n>   - 1.ckecked\r\n>     - 说明：开关属性，只有两种状态的属性\r\n>   - 2.class\r\n>     - 1.className\r\n>     - 2.classList(类名)\r\n>       - 1.add（新增）\r\n>       - 2.remove(移除)\r\n>       - 3.toggle（切换类名）\r\n>   - 3.style\r\n>     - 例如：img-src，a-href，id，class等\r\n>   - 4.value\r\n>   - 5.src\r\n>   - 6.disabled\r\n>     - 按钮是否被禁用\r\n> - 4.获取\r\n>   - 1.父元素.children\r\n>     - 获取子元素：可以得到某个元素之下的所有的子元素的集合，一个伪数组\r\n>   - 2.父元素 childNodes\r\n>     - 获取子元素：可以得到所有的子元素，\r\n>     - 需要注意的是，<ul>\r\n>        <li></li>\r\n>     <ul>\r\n>     会得到 text,li，text\r\n>   - 3.元素.parentNode\r\n>     - 获取父元素：返回一个\r\n>   - 4.元素.firstElementChild\r\n>     - 获取第一个子元素\r\n>   - 5.元素.lastElementChild\r\n>     - 获取最后一个子元素\r\n>   - 6.获取兄弟元素\r\n>     - 1.元素.nextElementSibling  -  得到下一个兄弟元素\r\n>     - 2.元素.previousElementSibling - 得到上一个兄弟元素\r\n\r\n### 4.创建\r\n> - 1.innerHTML\r\n>   - 1.设置html结构    2.会覆盖\r\n> - 2.document.write()\r\n>   - 会覆盖\r\n> - 3.document.createElement()\r\n>   - 创建标签节点\r\n> - 4.document.createAttribute(元素属性)\r\n>   - 创建属性节点\r\n> - 5.document.createTextNode(文本内容)\r\n>   - 创建文本节点\r\n> - 6.insertAdjacentHTML(\'位置\',Html结构)\r\n\r\n### 5.修改\r\n> - 1.innerHTML   结构\r\n> - 2.innerText  文本内容\r\n\r\n### 6.添加\r\n> - 父节点 .appendChild(新DOM节点)：从后添加新的DOM节点\r\n> - 父节点 .insertBefore(新的DOM节点，插入之前的DOM节点)，在某个子元素之前，添加新的DOM节点\r\n\r\n### 7.其他操作\r\n> - 1.替换元素\r\n>   - 父节点.replaceChild(新的节点,旧的子节点)\r\n> - 2.克隆元素\r\n>   - 元素.cloneNode(true或false);  返回一份新的克隆后的元素\r\n\r\n### 8.innerText和textContent比较\r\n> - 相同点：\r\n>   - 获取的都是Text文本\r\n> - 不同点：\r\n>   - 1.innerText基本没有兼容问题/textContent属性在ie低版本中不支持\r\n>   - 2.innerText（野路子，但是兼容性好,推荐使用）/textContent标准属性（官宣）\r\n\r\n## 事件\r\n### 1.事件三要素\r\n> - 1.事件源\r\n>   - 被触发的元素\r\n> - 2.事件类型\r\n>   - 如何触发的事件\r\n> - 3.事件处理程序\r\n>   - 事件发生后的结果\r\n\r\n### 2.事件的三个阶段（事件流）\r\n> - 1.捕获\r\n>   - 从根部往目标DOM节点上，一层一层的找，捕获是用户点击了那个DOM节点。\r\n> - 2.到达目标\r\n> - 3.冒泡\r\n>   - 从目标节点到根节点\r\n> - 冒泡执行\r\n>   - 事件默认是在冒泡阶段执行；当我们目标DOM节点注册了事件，冒泡往上的DOM节点也注册了同样的事件话，也会执行\r\n\r\n### 3.事件对象\r\n> - 说明：一个集合体，用来描述点击的行为(点击位置，点击了谁，注册给谁)\r\n> - 1.clientX/Y 相对于当前窗口\r\n> - 2.pageX/Y 相对于body左上角\r\n> - 3.target 点击了那个DOM节点，返回哪个DOM节点\r\n> - 4.currenTarget 返回事件源（事件源：事件给谁注册了，这就是那个源头）\r\n> - 5.offset系列\r\n>   - 1.offsetLeft\r\n>     - box距左的距离\r\n>       - 找参考的父亲，父辈元素没有定位，继续往上找，直至body\r\n>   - 2.offsetTop\r\n>     - box距上的距离\r\n>       - 找参考的父亲，父辈元素没有定位，继续往上找，直至body\r\n>   - 3.offsetWidth\r\n>     - 获取DOM节点的宽度\r\n>   - 4.offsetHeight\r\n>     - 获取DOM节点的高度\r\n> - 6.可视区域（padding+content）\r\n>   - 1.元素.clientHeight\r\n>   - 2.元素.clientWidth\r\n> - 5.触摸点\r\n>   - 1.对象.touches(屏上面的触摸点)\r\n>   - 2.对象.targetTouches(元素上面的触摸点)\r\n>   - 3.对象.changedTouches（变化的触摸点）\r\n> - 6.阻止冒泡（为了更好的用户体验）\r\n>   - 1.例：btn.addEventListener(\'click\',function(e)){\r\n>   e.stopPropagation();\r\n>   }\r\n>   - 2.canceBubble（） --------只支持IE\r\n> - 7.阻止默认行为：（e.prventDefault()）\r\n>   - 1.禁止鼠标右键  \r\n>   例: document.oncontextmenu = function(e){\r\n>       e.prventDefault()\r\n>   }\r\n>   - 2.a标签跳转等\r\n>     - 1.（也可以使用 return false）\r\n>     - 2. javascript:void(0)\r\n\r\n### 4.事件解绑\r\n> - 1. 例：begin.onclick = null；\r\n> - 2.例：begin.removeEventListener("click",fn)\r\n\r\n### 5.事件委托\r\n> - 1.把事件注册在父级的元素上\r\n> - 2.利用事件冒泡执行，当事件传播到已经注册了事件的父级元素身上\r\n> - 3.判断触发事件DOM(e.target)节点是否是指定的元素 例:e.target.nodeName ==\'li\'\r\n>   - 若是 则继续\r\n>   - 若不是 则什么都不做\r\n\r\n## 【DOM相关】JavaScript获取元素的位置与尺寸\r\n### （1）获取元素的尺寸\r\n> - 0. 【elem.style.width（可写）】CSS写入的宽高\r\n>   - jQuery-【$().width()】\r\n> - 1.【clientHeight】内宽高—— 内边距 + 内容框（如果有滚动条，还需要减去滚动条的宽度）\r\n>   \r\n>   - jQuery-【$().innerwidth()】\r\n> - 2.【offsetHeight】 外宽高—— 边框 + 内边距 + 内容框\r\n>   - jQuery-【$().outerwidth()】\r\n> - 3.【scrollHeight】 用来计算可滚动容器的大小，包括不可见的部分，当然，scrollHeight 的值需要加上 padding 的值。\r\n>   - 例子\r\n>     - 图\r\n>     - 解释\r\n>       - 此时滚动条的宽度是 17px，根据前面的介绍，滚动条时占用 padding 和 content 宽度的，而 17px 大于 padding 的 10px，故还有 7px 会占据 content。\r\n>       - 分析一下，offsetHeight 的值是 124，padding 10px，滚动条虽然存在，但是占了 padding 和内容的空间，offsetHeight 的值是 4+20+76 = 124px。scrollHeight 的值是可滚动的范围加上padding 值，同样不包括滚动条，即 150+20 = 170px。clientHeight 的值是可见区域，但是不包括滚动条的值（滚动条。。。），所以20+100-17 = 79px。\r\n>       - 其实也不是非常复杂。这个时候可以得出滚动条宽度的计算：offsetHeight 减去 border 和 clientHeight 的和就是滚动条宽度。\r\n> - 4.【getComputedStyle】获取元素内容的尺寸（最终计算后的结果）\r\n>   - 使用\r\n>     - window.getComputedStyle(ele， boolean)\r\n>     - document.defaultView.getComputedStyle(ele， boolean)\r\n>     - window.getComputedStyle(elem, null).getPropertyValue("height")\r\n>     - 接受两个参数：要取得计算样式的元素和一个伪元素字符串（例如“:after”）。如果不需要伪元素信息，第二个参数可以是null。getComputerStyle()方法返回一个CSSStyleDeclaration对象，其中包含当前元素的所有计算的样式。\r\n>   - 图\r\n>   - 注意\r\n>     - 在有滚动条的情况下，该属性返回的宽高为，CSS宽高减去滚动条的宽高\r\n>   - 延伸\r\n>     - getComputedStyle会引起回流，因为它需要获取祖先节点的一些信息进行计算（譬如宽高等），所以用的时候慎用，回流会引起性能问题。然后合适的话会将话题引导回流，重绘，浏览器渲染原理等等。当然也可以列举一些其它会引发回流的操作，如offsetXXX，scrollXXX，clientXXX，currentStyle等等\r\n>   - 与elem.style的区别\r\n> - 5.【elem.getBoundingClientRect()】获取元素宽高 等同于 offsetHeight——边框 + 内边距 + 内容框\r\n\r\n### （2）获取元素的位置\r\n> - 1.【elem.getBoundingClientRect()】只读、相对于视口（浏览器窗口）\r\n>   - 方法返回元素的大小及其相对于视口的位置。返回值是一个 DOMRect 对象\r\n>   - DOMRect 对象包含了一组用于描述边框的只读属性——left、top、right和bottom，单位为像素。除了 width 和 height 外的属性都是相对于视口的左上角位置而言的\r\n>   - 图\r\n>   - 绝对位置-相对于当前document元素的位置-jQuery 【$().offset().top】\r\n>     - 再加上滚动距离，就可以得到绝对位置（不管页面怎么滚动永远为元素离文档的距离）\r\n>     - 注意\r\n>       - 页面指定了DTD，即指定了DOCTYPE时，使用document.documentElement。\r\n>       - 页面没有DTD，即没指定DOCTYPE时，使用document.body。\r\n>   - 此处的left与top指的是position的left和top加上元素的margin，即指的是元素的边框距离浏览器窗口的值，如没有定位，那么即为元素margin的值\r\n> - 2.【elem.offsetTop（可写）】子元素距离父元素的距离，即子元素的边框到父元素的边框的距离（子元素的margin + 父元素的padding）\r\n\r\n### （3）获取客户端以及屏幕高度\r\n> - （1）screen.width\r\n>   - 显示器的水平方向的像素时，不随着我们浏览器窗口的变化而变化，是用设备像素衡量的\r\n> - （2）window.innerWidth\r\n>   - window.innerWidth指的是浏览器窗口的宽度，是可以变化的，所以使用的是CSS像素\r\n>   - 100%缩放下\r\n>     - 可以发现在100%缩放情况下，window.innerWidth的值为1192，window.innerHeight的值为455\r\n>   - 200%缩放下\r\n>     - 因为window.innerWidth是用CSS像素衡量的，放大两倍之后，浏览器窗口只能看到之前一半的内容，所以window.innerWidth是之前的一半\r\n> - （3）document.documentElement.clientWidth\r\n>   - 指的是网页可见区域高的宽度，与window.innerWidth的区别就只差了一个滚动条（不包含滚动条）\r\n> - （4）document.documentElement.offsetWidth\r\n>   - 取得html标签的宽度\r\n>   - 与clientwidth的区别\r\n>     - 看到没document.documentElement.offsetHeight此时为0，我打开调试定位了下，发现此时html高度确实是为0，而document.documentElement.clientHeight此时为455，是viewport的高度，只不过此时viewport的高度和window.innerHeight相等\r\n> - （5）document.documentElement.scrollHeight\r\n>   - 网页正文全文高\r\n> - （6）document.documentElement.scrollTop\r\n>   - 网页被卷去的高\r\n\r\n### （4）移动端的三个viewport理论\r\n> - layout viewport\r\n>   - 介绍\r\n>     - 布局layout，和PC端的viewport很像，PC端的viewport的宽由浏览器窗口的宽决定的，用户可以通过拖动窗口或者缩放改变viewport的大小，但是在移动端则不同，在IOS中layout viewport默认大小980px，在android中layout viewport为800px，很明显这两个值都大于我们浏览器的可视区域宽度。我们可以通过document.documentElement.clientWidth来获取layout viewport的宽度\r\n>   - 直观\r\n> - visual viewport\r\n>   - 介绍\r\n>     - 有了layout viewport，我们还需要一个viewport来表示我们浏览器可视区域的大小，这个就是visual viewport。visual viewport的宽度可以通过window.innerWidth获取\r\n>     - 移动端浏览器为了不让用户通过缩放和滑动就能看到整个网页的内容，默认情况下会将visual viewport进行缩放到layout viewport一样大小，这也就解释了为什么PC端设计的网页在手机上浏览会缩小，其实这是跟移动浏览器默认的行为有关系\r\n>   - 直观\r\n> - ideal viewport\r\n>   - 设备理想viewport，有以下几个要求：\r\n>     - 用户不需要缩放和滚动条就能查看所有内容\r\n>     - 文字大小合适，不会因为在高分辨率手机下就显示过小而看不清，图片也一样\r\n>   - 这个viewport就叫做ideal viewport。但是不同的设备的ideal viewport不一样，有320px，有360px的，还有384px的......\r\n>   - 如何获得\r\n>     - （1）layout viewport能被设置成ideal viewport。width=device-width和initial-scale=1指令可以做到。\r\n>     - （2）所有的scale指令都是相对于ideal viewport的。无视layout viewport设置了多少，所以maximum-scale=3意味着最大的缩放值是ideal viewport的300%\r\n',Nn={data:function(){return{MainComponent:Rn}}},An=Nn,Dn=Object(m["a"])(An,On,En,!1,null,"97a5d63a",null),In=Dn.exports,Jn=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},Ln=[],Hn="## 浏览器从输入URL到页面加载的过程\r\n### 多进程的浏览器\r\n> - 浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程）\r\n> 进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等\r\n>   - Browser进程：浏览器的主进程（负责协调、主控），只有一个\r\n>   - 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建\r\n>   - GPU进程：最多一个，用于3D绘制\r\n>   - 浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）\r\n>  \r\n> - 多线程的浏览器内核：每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程\r\n>   - GUI线程\r\n>   - JS引擎线程\r\n>   - 事件触发线程\r\n>   - 定时器线程\r\n>   - 网络请求线程\r\n\r\n### 解析URL\r\n- > 输入URL后，会进行解析（URL的本质就是统一资源定位符）\r\n  > - URL一般包括几大部分：\r\n  >   - protocol，协议头，譬如有http，ftp等\r\n  >   - host，主机域名或IP地址\r\n  >   - port，端口号\r\n  >   - path，目录路径\r\n  >   - query，即查询参数\r\n  >   - fragment，即#后的hash值，一般用来定位到某个位置\r\n  > - 网络请求都是单独的线程\r\n  >   - 每次网络请求时都需要开辟单独的线程进行，譬如如果URL解析到http协议，就会新建一个网络线程去处理资源下载\r\n  >   因此浏览器会根据解析出的协议，开辟一个网络线程，前往请求资源（这里可以理解为是浏览器内核开辟的）\r\n### 开启网络线程到发出一个完整的http请求\r\n> - DNS查询得到IP\r\n>   - 如果输入的是域名，需要进行dns解析成IP，大致流程：\r\n>     - 如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host\r\n>     - 如果本地没有，就向dns域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的IP\r\n> - tcp/ip请求\r\n>   - http的本质就是tcp/ip请求\r\n>     - tcp将http长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输\r\n>       - 三次握手的步骤：（抽象派）\r\n>         - 客户端：hello，你是server么？\r\n>           服务端：hello，我是server，你是client么\r\n>           客户端：yes，我是client\r\n>         - 建立连接成功后，接下来就正式传输数据\r\n>     - 待到断开连接时，需要进行四次挥手（因为是全双工的，所以需要四次挥手）\r\n>       - 四次挥手的步骤：（抽象派）\r\n>         - 主动方：我已经关闭了向你那边的主动通道了，只能被动接收了\r\n>           被动方：收到通道关闭的信息\r\n>           被动方：那我也告诉你，我这边向你的主动通道也关闭了\r\n>           主动方：最后收到数据，之后双方无法通信\r\n>   - tcp/ip的并发限制\r\n>     - 浏览器对同一域名下并发的tcp连接是有限制的（2-10个不等）\r\n>     而且在http1.0中往往一个资源下载就需要对应一个tcp/ip请求\r\n>     所以针对这个瓶颈，又出现了很多的资源优化方案\r\n> \r\n>   - get和post的区别\r\n>     - get和post虽然本质都是tcp/ip，但两者除了在http层面外，在tcp/ip层面也有区别。\r\n>     - get会产生一个tcp数据包，post两个\r\n>     - get请求时，浏览器会把headers和data一起发送出去，服务器响应200（返回数据），\r\n>     - post请求时，浏览器先发送headers，服务器响应100 continue，\r\n>     - 浏览器再发送data，服务器响应200（返回数据）。\r\n> \r\n>  \r\n> - 五层因特网协议栈\r\n>   - 一个概念： 从客户端发出http请求到服务器接收，中间会经过一系列的流程。\r\n>     - 从应用层的发送http请求，到传输层通过三次握手建立tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。\r\n>     当然，服务端的接收就是反过来的步骤\r\n>```html\r\n>      1.应用层(dns,http) DNS解析成IP并发送http请求\r\n>      2.传输层(tcp,udp) 建立tcp连接（三次握手）\r\n>      3.网络层(IP,ARP) IP寻址\r\n>      4.数据链路层(PPP) 封装成帧\r\n>      5.物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）\r\n>```\r\n\r\n### 从服务器接收到请求到对应后台接收到请求\r\n> - 负载均衡\r\n>   - 用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了nginx控制负载均衡），\r\n>     然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的HTTP响应，并将它反馈给用户\r\n> - 后台的处理\r\n>   - 一般后台都是部署到容器中的，所以一般为：\r\n>     - 先是容器接受到请求（如tomcat容器）\r\n>     - 然后对应容器中的后台程序接收到请求（如java程序）\r\n>     - 然后就是后台会有自己的统一处理，处理完后响应响应结果\r\n>   - 概括下：\r\n>     - 一般有的后端是有统一的验证的，如安全拦截，跨域验证\r\n>     - 如果这一步不符合规则，就直接返回了相应的http报文（如拒绝请求等）\r\n>     - 然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）\r\n>     - 等程序执行完毕后，就会返回一个http响应包（一般这一步也会经过多层封装）\r\n>     - 然后就是将这个包从后端发送到前端，完成交互\r\n> - 后台和前台的http交互\r\n>   - http报文结构\r\n>     - 报文一般包括了：通用头部，请求/响应头部，请求/响应体\r\n>       - 通用头部\r\n>         - 这也是开发人员见过的最多的信息，包括如下：\r\n>           - Request Url: 请求的web服务器地址\r\n>           - Request Method: 请求方式（Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）\r\n>             - HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。\r\n>             - HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。\r\n>           - Status Code: 请求的返回状态码，如200代表成功\r\n>             - 200——表明该请求被成功地完成，所请求的资源发送回客户端\r\n>             - 304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存\r\n>             - 400——客户端请求有错（譬如可以是安全模块拦截）\r\n>             - 401——请求未经授权\r\n>             - 403——禁止访问（譬如可以是未登录时禁止）\r\n>             - 404——资源未找到\r\n>             - 500——服务器内部错误\r\n>             - 503——服务不可用\r\n>             - 1xx——指示信息，表示请求已接收，继续处理\r\n>             - 2xx——成功，表示请求已被成功接收、理解、接受\r\n>             - 3xx——重定向，要完成请求必须进行更进一步的操作\r\n>             - 4xx——客户端错误，请求有语法错误或请求无法实现\r\n>             - 5xx——服务器端错误，服务器未能实现合法的请求\r\n>           - Remote Address: 请求的远程服务器地址（会转为IP）\r\n>       - 请求/响应头部\r\n>         - 常用的请求头部（部分）：\r\n>           - Accept: 接收类型，表示浏览器支持的MIME类型\r\n>             （对标服务端返回的Content-Type）\r\n>             Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收\r\n>             Content-Type：客户端发送出去实体内容的类型\r\n>             Cache-Control: 指定请求和响应遵循的缓存机制，如no-cache\r\n>             If-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中\r\n>             Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间\r\n>             Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中\r\n>             If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中\r\n>             Cookie: 有cookie并且同域访问时会自动带上\r\n>             Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive\r\n>             Host：请求的服务器URL\r\n>             Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私\r\n>             Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)\r\n>             User-Agent：用户客户端的一些必要信息，如UA头部等\r\n>         - 常用的响应头部（部分）：\r\n>           - Access-Control-Allow-Headers: 服务器端允许的请求Headers\r\n>             Access-Control-Allow-Methods: 服务器端允许的请求方法\r\n>             Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）\r\n>             Content-Type：服务端返回的实体内容的类型\r\n>             Date：数据从服务器发送的时间\r\n>             Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档\r\n>             Last-Modified：请求资源的最后修改时间\r\n>             Expires：应该在什么时候认为文档已经过期,从而不再缓存它\r\n>             Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效\r\n>             ETag：请求变量的实体标签的当前值\r\n>             Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端\r\n>             Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）\r\n>             Server：服务器的一些相关信息\r\n>       - 请求/响应实体\r\n>         - http请求时，除了头部，还有消息实体，一般来说\r\n>         请求实体中会将一些需要的参数都放入进入（用于post请求）。\r\n>         譬如实体中可以放参数的序列化形式（a=1&b=2这种），或者直接放表单对象（Form Data对象，上传时可以夹杂参数以及文件），等等\r\n>         而一般响应实体中，就是放服务端需要传给客户端的内容\r\n>         一般现在的接口请求时，实体中就是对于的信息的json格式，而像页面请求这种，里面就是直接放了一个html字符串，然后浏览器自己解析并渲染。\r\n> \t    - CRLF\r\n> \t\t   - CRLF（Carriage-Return Line-Feed），意思是回车换行，一般作为分隔符存在\r\n>           请求头和实体消息之间有一个CRLF分隔，响应头部和响应实体之间用一个CRLF分隔\r\n>           一般来说（分隔符类别）：\r\n>           CRLF->Windows-style\r\n>           LF->Unix Style\r\n>           CR->Mac Style\r\n>\r\n> - cookie以及优化\r\n>   - cookie是浏览器的一种本地存储方式，一般用来帮助客户端和服务端通信的，常用来进行身份校验，结合服务端的session使用。\r\n>     - 场景如下（简述）：\r\n>       - 在登陆页面，用户登陆了\r\n>       此时，服务端会生成一个session，session中有对于用户的信息（如用户名、密码等）\r\n>       然后会有一个sessionid（相当于是服务端的这个session对应的key）\r\n>       然后服务端在登录页面中写入cookie，值就是:jsessionid=xxx\r\n>       然后浏览器本地就有这个cookie了，以后访问同域名下的页面时，自动带上cookie，自动检验，在有效时间内无需二次登陆。\r\n> - gzip压缩\r\n>   - 首先，明确gzip是一种压缩格式，需要浏览器支持才有效（不过一般现在浏览器都支持），\r\n>     而且gzip压缩效率很好（高达70%左右）\r\n>     然后gzip一般是由apache、tomcat等web服务器开启\r\n>     当然服务器除了gzip外，也还会有其它压缩格式（如deflate，没有gzip高效，且不流行）\r\n>     所以一般只需要在服务器上开启了gzip压缩，然后之后的请求就都是基于gzip压缩格式的，\r\n>     非常方便。\r\n> - 长连接与短连接\r\n>   - 首先看tcp/ip层面的定义：\r\n>     - 长连接：一个tcp/ip连接上可以连续发送多个数据包，在tcp连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）\r\n>     - 短连接：通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接\r\n>   - 然后在http层面：\r\n>     - http1.0中，默认使用的是短连接，也就是说，浏览器没进行一次http操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接\r\n>     - http1.1起，默认使用长连接，使用长连接会有这一行Connection: keep-alive，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输http的tcp连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接\r\n>   - keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效\r\n> - http 2.0\r\n>   - http2.0不是https，它相当于是http的下一代规范（譬如https的请求可以是http2.0规范的）\r\n>   - 然后简述下http2.0与http1.1的显著不同点：\r\n>     - http1.1中，每请求一个资源，都是需要开启一个tcp/ip连接的，所以对应的结果是，每一个资源对应一个tcp/ip请求，由于tcp/ip本身有并发数限制，所以当资源一多，速度就显著慢下来\r\n>     - http2.0中，一个tcp/ip请求可以请求多个资源，也就是说，只要一次tcp/ip请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。\r\n>   - http2.0的一些特性：\r\n>     - 多路复用（即一个tcp/ip连接可以请求多个资源）\r\n>     - 首部压缩（http头部压缩，减少体积）\r\n>     - 二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）\r\n>     - 服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）\r\n>     - 请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）\r\n> - https\r\n>   - https就是安全版本的http，譬如一些支付等操作基本都是基于https的，因为http请求的安全系数太低了。\r\n>     - 简单来看，https与http的区别就是： 在请求前，会建立ssl链接，确保接下来的通信都是加密的，无法被轻易截取分析\r\n>   - SSL/TLS的握手流程，如下（简述）：\r\n>     - 1. 浏览器请求建立SSL链接，并向服务端发送一个随机数–Client random和客户端支持的加密方法，比如RSA加密，此时是明文传输。\r\n>     - 1. 服务端从中选出一组加密算法与Hash算法，回复一个随机数–Server random，并将自己的身份信息以证书的形式发回给浏览器\r\n>          （证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息）\r\n>     - 1. 浏览器收到服务端的证书后\r\n>       - - 验证证书的合法性（颁发机构是否合法，证书中包含的网址是否和正在访问的一样），如果证书信任，则浏览器会显示一个小锁头，否则会有提示\r\n>       - ```\r\n>         - 用户接收证书后（不管信不信任），浏览会生产新的随机数–Premaster secret，然后证书中的公钥以及指定的加密方法加密`Premaster secret`，发送给服务器。\r\n>         ```\r\n>       - ```\r\n>         - 利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key-`session key`\r\n>         ```\r\n>       - ```\r\n>         - 使用约定好的HASH算法计算握手消息，并使用生成的`session key`对消息进行加密，最后将之前生成的所有信息发送给服务端。\r\n>         ```\r\n>     - 1. 服务端收到浏览器的回复\r\n>       - - 利用已知的加解密方式与自己的私钥进行解密，获取`Premaster secret`\r\n>       - ```\r\n>         - 和浏览器相同规则生成`session key`\r\n>         ```\r\n>       - ```\r\n>         - 使用`session key`解密浏览器发来的握手消息，并验证Hash是否与浏览器发来的一致\r\n>         ```\r\n>       - ```\r\n>         - 使用`session key`加密一段握手消息，发送给浏览器\r\n>         ```\r\n>     - 1. 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，\r\n> - 单独拎出来的缓存问题，http的缓存\r\n>   - 强缓存与弱缓存\r\n>     - 缓存可以简单的划分成两种类型：强缓存（200 from cache）与协商缓存（304）\r\n>       - 区别简述如下：\r\n>         - 强缓存（200 from cache）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求\r\n>           - 但是对于强缓存，在未过期时，必须更新资源路径才能发起新的请求（更改了路径相当于是另一个资源了，这也是前端工程化中常用到的技巧）\r\n>         - 协商缓存（304）时，浏览器会向服务端发起http请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存\r\n>           - 对于协商缓存，使用Ctrl + F5强制刷新可以使得缓存无效\r\n>   - 缓存头部简述\r\n>     - 属于强缓存控制的：\r\n>       - （http1.1）Cache-Control/Max-Age\r\n>       - （http1.0）Pragma/Expires\r\n>     - 属于协商缓存控制的：\r\n>       - （http1.1）If-None-Match/E-tag\r\n>       - （http1.0）If-Modified-Since/Last-Modified\r\n>     - 头部的区别\r\n>       - http1.0中的缓存控制：\r\n>         - Pragma：严格来说，它不属于专门的缓存控制头部，但是它设置no-cache时可以让本地强缓存失效（属于编译控制，来实现特定的指令，主要是因为兼容http1.0，所以以前又被大量应用）\r\n>         - Expires：服务端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires一般对应服务器端时间，如Expires：Fri, 30 Oct 1998 14:19:41\r\n>         - If-Modified-Since/Last-Modified：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-Modified-Since，而服务端的是Last-Modified，它的作用是，在发起请求时，如果If-Modified-Since和Last-Modified匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。Last-Modified，顾名思义，指的是文件最后的修改时间，而且只能精确到1s以内\r\n>       - http1.1中的缓存控制：\r\n>         - Cache-Control：缓存控制头部，有no-cache、max-age等多种取值\r\n>         - Max-Age：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age是Cache-Control头部的值，不是独立的头部，譬如Cache-Control: max-age=3600，而且它值得是绝对时间，由浏览器自己计算\r\n>         - If-None-Match/E-tag：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-None-Match，而服务端的是E-tag，同样，发出请求后，如果If-None-Match和E-tag匹配，则代表内容未变，通知浏览器使用本地缓存，和Last-Modified不同，E-tag更精确，它是类似于指纹一样的东西，基于FileEtag INode Mtime Size生成，也就是说，只要文件变，指纹就会变，而且没有1s精确度的限制。\r\n>       - Max-Age相比Expires？\r\n>         - Expires使用的是服务器端的时间\r\n>           - 客户端时间和服务端不同步\r\n>           那这样，可能就会出问题了，造成了浏览器本地的缓存无用或者一直无法过期\r\n>           所以一般http1.1后不推荐使用Expires\r\n>        - 而Max-Age使用的是客户端本地时间的计算，因此不会有这个问题\r\n>       \t\t- 注意，如果同时启用了Cache-Control与Expires，Cache-Control优先级高。\r\n>       \t- E-tag相比Last-Modified？\r\n>       \t\t- Last-Modified：\r\n>       \t\t\t- 表明服务端的文件最后何时改变的\r\n>       \t\t\t- 它有一个缺陷就是只能精确到1s，\r\n>       \t\t\t- 然后还有一个问题就是有的服务端的文件会周期性的改变，导致缓存失效\r\n>       \t\t- E-tag：\r\n>       \t\t\t- 是一种指纹机制，代表文件相关指纹\r\n>       \t\t\t- 只有文件变才会变，也只要文件变就会变，\r\n>       \t\t\t- 也没有精确时间的限制，只要文件一遍，立马E-tag就不一样了\r\n>       \t\t- 如果同时带有E-tag和Last-Modified，服务端会优先检查E-tag\r\n\r\n### 解析页面流程\r\n> - 流程简述\r\n>   - 浏览器内核拿到内容后，渲染步骤大致可以分为以下几步：\r\n>     -   #### 一：解析HTML，构建DOM树\r\n>\r\n>       - 解析HTML到构建出DOM当然过程可以简述如下：\r\n>         - Bytes → characters → tokens → nodes → DOM\r\n>           - 譬如假设有这样一个HTML页面：\r\n>             - 列举其中的一些重点过程：\r\n>               - 1. Conversion转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符\r\n>               - 1. Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集\r\n>               - 1. Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则\r\n>               - 1. DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样\r\n>               - 例如：body对象的父节点就是HTML对象，然后段略p对象的父节点就是body对象\r\n>             - 最后的DOM树如下：\r\n>     -    #### 二：解析CSS，生成CSS规则树\r\n>\r\n>       - CSS规则树的生成也是类似。简述为：\r\n>         - Bytes → characters → tokens → nodes → CSSOM\r\n>           - style.css内容如下：\r\n>             - body { font-size: 16px }\r\n>               p { font-weight: bold }\r\n>               span { color: red }\r\n>               p span { display: none }\r\n>               img { float: right }\r\n>               - 最终的CSSOM树就是：\r\n>     -   #### 三：合并DOM树和CSS规则，生成render树\r\n>\r\n>       - 当DOM树和CSSOM都有了后，就要开始构建渲染树了\r\n>       一般来说，渲染树和DOM树相对应的，但不是严格意义上的一一对应\r\n>       因为有一些不可见的DOM元素不会插入到渲染树中，如head这种不可见的标签或者display: none等\r\n>   \t-   #### 四：布局render树（Layout/reflow），负责各元素尺寸、位置的计算\r\n>\r\n>   \t\t- 有了render树，接下来就是开始渲染，基本流程如下：\r\n>   \t\t\t\r\n>   \t\t\t- 重要的四个步骤就是：\r\n>   \t\t\t\t- 1. 计算CSS样式\r\n>   \t\t\t\t- 2. 构建渲染树\r\n>   \t\t\t\t- 3. 布局，主要定位坐标和大小，是否换行，各种position overflow z-index属性\r\n>   \t\t\t\t- 4. 绘制，将图像绘制出来\r\n>   \t\t\t- 图中的线与箭头代表通过js动态修改了DOM或CSS，导致了重新布局（Layout）或渲染（Repaint）\r\n>   \t\t\t- Layout和Repaint的概念是有区别的：\r\n>   \t\t\t\t- Layout，也称为Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树\r\n>   \t\t\t\t- Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了\r\n>   \t\t\t- 什么会引起回流？\r\n>   \t\t\t\t- 1.页面渲染初始化\r\n>   \t\t\t\t- 2.DOM结构改变，比如删除了某个节点\r\n>   \t\t\t\t- 3.render树变化，比如减少了padding\r\n>   \t\t\t\t- 4.窗口resize\r\n>   \t\t\t\t- 5.最复杂的一种：获取某些属性，引发回流，\r\n>           \r\n>         \t  很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，\r\n>   \t\t\t但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括\r\n>   \t\t\t\t- (1)offset(Top/Left/Width/Height)  \t\t\t\t\r\n>   \t\t\t\t- (2) scroll(Top/Left/Width/Height)\r\n>   \t\t\t\t- (3) cilent(Top/Left/Width/Height)\r\n>   \t\t\t\t- (4) width,height\r\n>   \t\t\t\t- (5) 调用了getComputedStyle()或者IE的currentStyle\r\n>   \t\t\t\t 回流优化方案\r\n>   \t\t\t - 减少逐项更改样式，最好一次性更改style，或者将样式定义为class并一次性更新\r\n>   \t\t\t - 避免循环操作dom，创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document\r\n>   \t\t\t - 避免多次读取offset等属性。无法避免则将它们缓存到变量\r\n>   \t\t\t - 将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高\r\n>   - #### 五：绘制render树（paint），绘制页面像素信息\r\n>   - #### 六：浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上",Fn={data:function(){return{MainComponent:Hn}}},Un=Fn,qn=Object(m["a"])(Un,Jn,Ln,!1,null,"ea8ae612",null),Bn=qn.exports,Wn={mixins:[k["c"]],components:{m1:D,m2:q,m3:X,m4:tn,m5:ln,m7:bn,m8:kn,m9:Pn,m10:In,m11:Bn},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"基本",value:"m1"},{label:"存储",value:"m2"},{label:"渲染原理",value:"m3"},{label:"渲染原理2",value:"m11"},{label:"重排和重绘 ",value:"m7"},{label:"跨域",value:"m8"},{label:"bom",value:"m9"},{label:"dom",value:"m10"}]}}},Vn=Wn,Gn=Object(m["a"])(Vn,C,M,!1,null,"0f77a8d9",null),zn=Gn.exports,$n=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[r("div",[r(""+n.tab,{tag:"component"})],1)])},Xn=[],Kn=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},Qn=[],Yn="### 分析比较opacity:0、visibility:hidden、display:none的区别、优劣及适用场景\r\n------\r\n#### 三个属性分别是什么？\r\n> 1. #### opacity （filter: alpha（opacity = 0-100））– [MDN详细讲解](https://developer.mozilla.org/zh-CN/docs/Web/CSS/opacity)\r\n>    1. 定义：指定了一个元素的透明度\r\n>    2. 值：number类型的值，0~1，如果超过范围，则按最接近的范围值展示，如值为999的时候，是按1展示。默认为1，同样，值为-999时，是按0展示\r\n>    3. 兼容性：很好。除了IE9之前（详细到各浏览器版本号就看文档\r\n>    4. 关注点：什么是透明，是否还存在文档流中，对子元素影响呢？\r\n> 2. #### visibility – [MDN详细讲解](https://developer.mozilla.org/zh-CN/docs/Web/CSS/visibility)\r\n>    1. 定义：显示或隐藏元素而不更改文档的布局。其中collapse值，还可以隐藏table中的行或列。\r\n>    2. 值：关键值有三个，分别如下。\r\n>       1. ___visible，默认值，正常展示\r\n>       2. ___hidden，隐藏元素，不改变布局，但子元素如果设置为visibility: visible，则该子元素可见（很有意思的一个属性）\r\n>       3. ___collapse，应用于table表格。\r\n>    3. 兼容性：css2的属性，应该都能兼容吧（没Windows\r\n>    4. 关注点：和opacity的透明度有什么区别？\r\n> 3. #### display – [MDN详细讲解](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display#display_none)\r\n>    1. 定义：指定了元素的显示类型，包含两类基础特征，**用于指定元素怎样生成盒模型。****外部显示类型**定义了元素怎么参与流式布局的处理。**内部显示类型**定义了子元素的布局方式， 详细可以看看[语法部分](http://localhost:18080/[https://developer.mozilla.org/zh-CN/docs/Web/CSS/display#语法](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display#语法))\r\n>    2. 值：很多值，其中 none 属于 display-box。被设置成none的元素，将从可访问性树中移除，包括其子元素在内。\r\n>    3. 兼容性：基本支持\r\n>    4. 关注点：对页面重绘有没性能影响？是否可与别的属性连用？\r\n>    \r\n>    \r\n\r\n#### 表格对比\r\n\r\n|                                    | opacity: 0 | visibility: hidden | display:none |\r\n| :--------------------------------: | :--------: | :----------------: | :----------: |\r\n|           是否存在页面中           |    存在    |        存在        |    不存在    |\r\n| 子元素设置该属性其他值是否还能展示 |   不可以   |        可以        |    不可以    |\r\n|      自身绑定的事件是否能触发      |     能     |        不能        |     不能     |\r\n|     是否影响遮挡元素的事件触发     |    影响    |       不影响       |    不影响    |\r\n|     改变属性值是否影响页面重绘     |   不一定   |        一定        |     一定     |\r\n|       改变属性值是否影响回流       |    不会    |         会         |      会      |\r\n|      该属性是否支持transition      |    支持    |        支持        |    不支持    |\r\n#### 三者的优劣和应用场景\r\n\r\n> 1. #### 绑定事件\r\n>    1. opacity：从表格可得知，opacity的隐藏，只是透明度100%，看不见了，但还在页面中且可以通过z-index等方式遮挡其他元素，同时绑在在该元素上的事件依旧能触发。应用场景可以有：移动端使用input、select加div，自定义样式，其中input、select层级在div上面，并设置opacity为0\r\n>    2. visibility：这个属性是隐藏，意味着不能聚焦了还占据页面空间。但其子元素可以设置属性值为visible，就能正常显示。应用场景：父元素隐藏，子元素根据一定条件某些展示某些隐藏。可以做一个闪闪发光的星空？\r\n>    3. display none就不存在页面中了，可以理解为完全的消失。优点即应用场景，如果是流式布局，让一个元素隐藏且不占据空间，就使用这个属性值了。\r\n> 2. #### 性能方面\r\n>    1. opacity由于只是透明度变化，就还好，visibility是元素隐藏，需要重绘，disable是元素消失，也是需要。\r\n>    2. 应用方面，需要频繁切换状态时，在display和opacity中，可以选择后者，不频繁时，none也可以。\r\n",Zn={data:function(){return{MainComponent:Yn}}},nt=Zn,tt=Object(m["a"])(nt,Kn,Qn,!1,null,"cbdfb03e",null),rt=tt.exports,et=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},at=[],ot='# css                                   \r\n## CSS属性\r\n### 定位\r\n> - position\r\n> \t- static                                                                                                                                               \r\n> \t  static：\r\n> \t  对象遵循常规流。此时4个定位偏移属性不会被                                                                                                                                                             应用。\r\n> \t- relative\r\n> \t  对象遵循常规流，并且参照自身在常规流中的位置通过top，right，bottom，left这4个定位偏移属性进行偏移时不会影响常规流中的任何元素。\r\n> \t- absolute\r\n> \t  对象脱离常规流，此时偏移属性参照的是离自身最近的定位祖先元素，如果没有定位的祖先元素，则一直回溯到body元素。盒子的偏移位置不影响常规流中的任何元素，其margin不与其他任何margin折叠。\r\n> \t- fixed\r\n> \t  fixed：\r\n> \t  与absolute一致，但偏移定位是以窗口为参考。当出现滚动条时，对象不会随着滚动。\r\n> \t- sticky\r\n> \t  对象在常态时遵循常规流。它就像是relative和fixed的合体，当在屏幕中时按常规流排版，当卷动到屏幕外时则表现如fixed。该属性的表现是现实中你见到的吸附效果。（CSS3）\r\n> - z-index\r\n> \t- auto\r\n> \t  元素在当前层叠上下文中的层叠级别是0。元素不会创建新的局部层叠上下文，除非它是根元素。\r\n> \t- integer\r\n> \t  用整数值来定义堆叠级别。可以为负值。\r\n\r\n### 布局\r\n> - display\r\n> \t- none\r\n> \t  与visibility属性的hidden值不同，其不为被隐藏的对象保留其物理空间\r\n> \t- inline\r\n> \t  内联元素\r\n> \t- block\r\n> \t  块元素\r\n> \t- inline-block\r\n> \t  内联块元素\r\n> \t- .......\r\n> - float\r\n>   none | left | right\r\n>   当一个元素是绝对定位元素或者定义了display为none时，float定义不生效。\r\n> - clear\r\n>   none(默认) | left | right | both\r\n> - visibility\r\n>   visible(默认) | hidden | collapse\r\n>   collapse：\r\n>   主要用来隐藏表格的行或列。隐藏的行或列能够被其他内容使用。对于表格外的其他对象，其作用等同于hidden。\r\n>   定义了元素是否可见。\r\n>   注意：与display属性不同，visibility会为隐藏的元素保留其占据的物理空间\r\n>   如果希望某个元素为可见，其父元素也必须是可见的。\r\n> - overflow\r\n>   visible | hidden | scroll | auto | clip\r\n>   适用范围：块容器，伸缩盒容器，grid容器\r\n>   visible：\r\n>   对溢出内容不做处理，内容可能会超出容器。\r\n>   hidden：\r\n>   隐藏溢出容器的内容且不出现滚动条。\r\n>   scroll：\r\n>   隐藏溢出容器的内容，溢出的内容可以通过滚动呈现。\r\n>   auto：\r\n>   当内容没有溢出容器时不出现滚动条，当内容溢出容器时出现滚动条，按需出现滚动条。textarea元素的overflow默认值就是auto。\r\n>   clip：\r\n>   与hidden一样，clip也被用来隐藏溢出容器的内容且不出现滚动条。不同的地方在于，clip是一个完全禁止滚动的容器，而hidden仍然可以通过编程机制让内容可以滚动。\r\n>   注意：scroll 与 auto 的区别：scroll 无论溢出如否都存在滚动条\r\n\r\n### 尺寸与补白\r\n> - width\r\n>   <length> | <percentage> | auto(默认)\r\n>   对于img元素来说，若仅指定此属性，其height值将会根据图片源尺寸进行等比例缩放。\r\n> - height\r\n>   定义了元素内容区（Content Area）的高度\r\n>   对于img元素来说，若仅指定此属性，其width值将会根据图片源尺寸进行等比例缩放。\r\n> - padding\r\n>   padding：[ <length> | <percentage> ]{1,4}\r\n> - margin\r\n>   margin折叠常规认知：\r\n>   margin折叠只发生在块级元素上；\r\n>   浮动元素的margin不与任何margin发生折叠；\r\n>   设置了属性overflow且值为非visible的块级元素，将不与它的子元素发生margin折叠；\r\n>   绝对定位元素的margin不与任何margin发生折叠；\r\n>   根元素的margin不与其它任何margin发生折叠；\r\n\r\n### 背景与边框\r\n> - border\r\n> \t- border\r\n> \t  border：<line-width> || <line-style> || <color>\r\n> \t- box-shadow\r\n> \t  语法：\r\n> \t  box-shadow：none | <shadow> [ , <shadow> ]*\r\n> \t  <shadow> = inset? && <length>{2,4} && <color>?\r\n> \t  none：\r\n> \t  无阴影\r\n> \t  <length>①：\r\n> \t  第 1 个长度值定义元素的阴影水平偏移值。正值，阴影出现在元素右侧；负值，则阴影出现在元素左侧\r\n> \t  <length>②：\r\n> \t  第 2 个长度值定义元素的阴影垂直偏移值。正值，阴影出现在元素底部；负值，则阴影出现在元素顶部\r\n> \t  <length>③：\r\n> \t  第 3 个长度值定义元素的阴影模糊值半径（如果提供了）。该值越大阴影边缘越模糊，若该值为0，阴影边缘不出现模糊。不允许负值\r\n> \t  <length>④：\r\n> \t  第 4 个长度值定义元素的阴影外延值（如果提供了）。正值，阴影将向四面扩展；负值，则阴影向里收缩\r\n> \t  <color>：\r\n> \t  定义元素阴影的颜色。如果该值未定义，阴影颜色将默认取当前最近的文本颜色\r\n> \t  inset：\r\n> \t  定义元素的阴影类型为内阴影。该值为空时，则元素的阴影类型为外阴影\r\n> \t- border-radius\r\n> \t  语法：\r\n> \t  border-radius：[ <length> | <percentage> ]{1,4} [ / [ <length> | <percentage> ]{1,4} ]?\r\n> \t  border-radius属性提供 2 个参数，参数间以/分隔，每个参数允许设置 1~4 个参数值，第 1 个参数表示水平半径或半轴，第 2 个参数表示垂直半径或半轴，如第 2 个参数值省略未定义，则直接复制第 1 个参数值。\r\n> \t  注意（对角原则）：水平半径或半轴：如果提供全部四个参数值，将按上左 top-left、上右 top-right、下右 bottom-right、下左 bottom-left的顺序作用于四个角；提供三个，第一个用于top-left，第二个用于top-right和bottom-left，第三个用于bottom-right；提供两个，第一个用于top-left和bottom-right，第二个用于top-right和bottom-left；只提供一个，将用于全部的四个角。\r\n> - background\r\n> \t- background\r\n> \t- ......\r\n\r\n### 颜色与透明度\r\n> - color\r\n> - opacity\r\n\r\n### 字体\r\n> - font\r\n> - font-style\r\n>   font-style：normal | italic | oblique\r\n>   normal：\r\n>   指定文本字体样式为正常的字体\r\n>   italic：\r\n>   指定文本字体样式为斜体。对于没有设计斜体的特殊字体，如果要使用斜体外观将应用oblique\r\n>   oblique：\r\n>   指定文本字体样式为倾斜的字体。人为的使文字倾斜，而不是去选取字体中的斜体字\r\n> - font-weight\r\n>   font-weight：normal | bold | bolder | lighter | <integer>\r\n>   <integer>：\r\n>   用数字表示文本字体粗细。取值范围：100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900\r\n> - font-size\r\n> - font-family\r\n>   font-family：[ <family-name> | <generic-family> ] #\r\n>   <family-name> = arial | georgia | verdana | helvetica | simsun and etc.\r\n>   <generic-family> = cursive | fantasy | monospace | serif | sans-serif\r\n\r\n### 文本\r\n> - line-height\r\n>   语法：\r\n>   line-height：normal | <length> | <percentage> | <number>\r\n>   normal：\r\n>   允许内容顶开或溢出指定的容器边界。\r\n>   <length>：\r\n>   用长度值指定行高。不允许负值。\r\n>   <percentage>：\r\n>   用百分比指定行高，其百分比基于文本的font-size进行换算。不允许负值。\r\n>   <number>：\r\n>   用乘积因子指定行高。不允许负值\r\n> - text-indent\r\n>   语法：\r\n>   text-indent：[ <length> | <percentage> ] && hanging? && each-line?\r\n> - text-align\r\n>   语法：\r\n>   text-align：start | end | left | right | center | justify | match-parent | justify-all\r\n> - text-transform\r\n>   语法：\r\n>   text-transform：none | capitalize | uppercase | lowercase | full-width\r\n> - text-decoration\r\n>   text-decoration：text-decoration-line || text-decoration-style || text-decoration-color\r\n\r\n### 变换\r\n- > transform\r\n  > 语法：\r\n  > transform：none | <transform-function>+\r\n  > transform-function list:\r\n  > 更多信息请参考：\r\n  > http://css.doyoe.com/\r\n## CSS布局\r\n### 页面布局技术细节\r\n- > 浮动、定位、CSS表格、弹性盒子、网格\r\n### 布局分类\r\n> - 正常流布局\r\n> - 浮动float\r\n> \t- 整列浮动的实现\r\n> - 定位技术\r\n> \t- 静态定位\r\n> \t- 相对定位(Relative positioning)：允许我们相对元素在正常的文档流中的位置移动它——包括将两个元素叠放在页面上。\r\n> \t\t- 这对于微调和精准设计(design pinpointing)非常有用\r\n> \t- 绝对定位(Absolute positioning)：将元素完全从页面的正常布局流中移出，类似将它单独放在一个图层中. 我们可以将元素相对于页面的 <html> 元素边缘固定，或者相对于离元素最近的被定位的祖先元素(ancestor element)。\r\n> \t\t- 绝对定位在创建复杂布局效果时非常有用，例如通过标签显示和隐藏的内容面板或者通过按钮控制滑动到屏幕中的信息面板.\r\n> \t- 固定定位(Fixed positioning)与绝对定位非常类似，除了它是将一个元素相对浏览器视口固定，而不是相对另外一个元素。 在创建类似页面滚动总是处于页面上方的导航菜单时非常有用。\r\n> - CSS表格\r\n> - 弹性盒子\r\n> - 网格布局Grid\r\n> \t- 属性\r\n> \t\t- display属性\r\n> \t\t\t- grid\r\n> \t\t\t- inline-grid\r\n> \t\t- grid-template-columns、grid-template-row属性\r\n> \t\t\t- 定义列宽、行高\r\n> \t\t\t- 关键字\r\n> \t\t\t\t- repeat\r\n> \t\t\t\t- auto-fill\r\n> \t\t\t\t- fr\r\n> \t\t\t\t- minmax\r\n> \t\t\t\t- auto\r\n> \t\t\t\t- 设置网格线名称\r\n> \t\t\t- 实例\r\n> \t\t\t\t- 两栏布局\r\n> \t\t\t\t\t- .wrapper{display: grid; grid-template-columns: 70% 30%}\r\n> \t\t\t\t- 12栏布局\r\n> \t\t\t\t\t- .wrapper{display: grid; grid-template-columns: repeat(12, 1fr)}\r\n> \t\t- grid-gap\r\n> \t\t\t- grid-row-gap\r\n> \t\t\t- grid-column-grap\r\n> \t\t- grid-template-areas属性\r\n> \t\t\t- 网格允许指定区域，一个区域由一个或者多个单元格组成，属性用于定义\r\n> \t\t- grid-auto-flow\r\n> \t\t\t- 定义之元素放置顺序\r\n> \t\t- justify-items、align-items属性、place-items属性\r\n> \t\t- justify-content、aligin-content、place-content\r\n> \t\t- grid-auto-column、grid-auto-rows\r\n> \t\t- grid-template属性\r\n> \t- item属性\r\n> \t\t- grid-column-start、grid-column-end、grid-row-start、grid-row-end\r\n> \t\t- grid-column属性、grid-row属性\r\n> \t\t\t- grid-column\r\n> \t\t\t\t- grid-column: 1/4;表示从第一根列线到第四根列线\r\n> \t\t\t- grid-row\r\n> \t\t- grid-area属性\r\n> \t\t\t- 根据grid-area-template的定义确定item的位置\r\n> \t\t\t- <row-start>/<column-start>/<row-end>/<column-end>\r\n> \t\t- justyfy-self、align-self、place-self\r\n> \t\t\t- 用于设置单个单元格内容的位置\r\n\r\n\r\n\r\n## CSS3\r\n###  opicity 和 rgba的区别\r\n- > opacity只能设定整个元素的透明值，而alpha通道可以特定对元素的某个属性设定透明值，比如上面的背景、边框、文字等\r\n### transform变形\r\n> - transform: rotate(angle); 旋转\r\n> \t- 如：transform: rotate(9deg)\r\n> - transform: translate(length); 平移\r\n> \t- transform: translate(100px,50px); 水平垂直同时移动\r\n> \t- transform: translateX(100px); 水平移动\r\n> \t- transform: translateY(50px); 垂直移动\r\n> - transform: scale(number); 缩放\r\n> \t- transform: scale(2,1.5); 水平垂直同时缩放\r\n> \t- transform: scaleX(2); 水平缩放\r\n> \t- transform: scaleY(2); 垂直缩放\r\n> - transform: skew(angle); 扭曲\r\n> \t- transform: skew(30deg,10deg); 水平垂直同时扭曲\r\n> \t- transform: skewX(30deg); 水平扭曲\r\n> \t- transform: skewY(30deg); 垂直扭曲\r\n> - transform: matrix(<number>,<number>,<number>,<number>,<number>,<number>); 矩阵\r\n> - transform-origin(X,Y): length; 改变元素变换基点\r\n\r\n### rem单位\r\n- font size of the root element\r\n\t- px、em、rem的区别\r\n\t\t- px，像素，相对长度单位，相对于屏幕分辨率\r\n\t\t- em，相对长度单位，相对父节点的字体尺寸，如未设置则相对于浏览器默认字体尺寸\r\n\t\t\t- 一般浏览器默认值为16px\r\n\t\t- rem仍然是相对长度单位，但只相对于HTML根元素\r\n\t- 通过修改根元素就可以成比例地调整所有字体尺寸\r\n\t- 设置 html{ font-size: 10px; } 则1rem=10px\r\n### fixed布局\r\n- 任何一个容器都可以指定为Flex布局 display: flex;\r\n- 行内元素也可以指定为Flex布局 display: inline-flex;\r\n- 设置为flex布局后子元素的float、clear、vertical-align属性将失效\r\n- 采用flex布局的元素称为flex container，简称容器，它的所有子元素自动成为容器成员，称为flex item，简称项目\r\n\t- 容器默认存在两根轴\r\n\t\t- 水平的主轴（main axis），开始位置为main start，结束位置为main end\r\n\t\t- 垂直的主轴（cross axis），开始位置为cross start，结束位置为cross end\r\n\t\t- 项目默认按主轴排列\r\n\t\t- 单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size\r\n\t- 可以在容器上设置6种属性\r\n\t\t- flex-direction\r\n\t\t\t- flex-direction决定主轴的方向（即项目的排列方向）\r\n\t\t\t\t- flex-direction: row; 默认值，主轴水平方向，以左端为起点\r\n\t\t\t\t- flex-direction: row-reverse;  主轴水平方向，以右端为起点\r\n\t\t\t\t- flex-direction: column; 主轴垂直方向，以左端为起点\r\n\t\t\t\t- flex-direction: column-reverse; 主轴垂直方向，以右端为起点\r\n\t\t- flex-wrap\r\n\t\t\t- flex-wrap定义如何换行\r\n\t\t\t\t- flex-wrap: nowrap; 默认值，不许换行\r\n\t\t\t\t- flex-wrap: wrap; 换行，第一排在上方\r\n\t\t\t\t- flex-wrap: wrap-reverse; 换行，第一排在下方\r\n\t\t- flex-flow\r\n\t\t\t- flex-direction和flex-wrap的缩写\r\n\t\t\t\t- flex-flow:<flex-direction> <flex-wrap>; 如flex-flow: row-reverse nowrap; \r\n\t\t- justify-content\r\n\t\t\t- justify-content定义在主轴上的对齐方式\r\n\t\t\t\t- justify-content: flex-start; 默认值，左对齐\r\n\t\t\t\t- justify-content: flex-end; 右对齐\r\n\t\t\t\t- justify-content: center; 居中\r\n\t\t\t\t- justify-content: space-between; 两端对齐\r\n\t\t\t\t- justify-content: space-around; 项目之间间隔相等\r\n\t\t- align-items\r\n\t\t\t- align-items定义在交叉轴上的对齐方式\r\n\t\t\t\t- align-items: flex-start; 交叉轴起点对齐\r\n\t\t\t\t- align-items: flex-end; 交叉轴终点对齐\r\n\t\t\t\t- align-items: center; 交叉轴中点对齐\r\n\t\t\t\t- align-items: baseline; 第一行文字的基线对齐\r\n\t\t\t\t- align-items: stretch; 默认值，若项目未设置高度或为auto，将占满整个容器高度\r\n\t\t- align-content\r\n\t\t\t- align-content定义多根轴的对齐方式\r\n\t\t\t\t- flex-start、flex-end、center、space-between、space-around、stretch（默认值）\r\n\t- 可以在项目上设置6种属性\r\n\t\t- order\r\n\t\t\t- order定义项目的排列顺序\r\n\t\t\t\t- order: <integer>; 数值越小排列越靠前，默认值0\r\n\t\t- flex-grow\r\n\t\t\t- flex-grow定义项目的放大比例\r\n\t\t\t\t- flex-grow: <number>; 默认为0\r\n\t\t- flex-shrink\r\n\t\t\t- flex-shrink定义项目的缩小比例\r\n\t\t\t\t- flex-shrink: <number>; 默认为1，负值无效\r\n\t\t- flex-basis\r\n\t\t\t- flex-basis定义在分配空余空间之前项目占据的主轴空间\r\n\t\t\t\t- flex-basis: <length>; ，默认值为auto\r\n\t\t- flex\r\n\t\t\t- flex-grow、flex-shrink和flex-basis的缩写\r\n\t\t\t\t- flex: <flex-grow> <flex-shrink> <flex-basis>; 建议优先使用这个属性\r\n\t\t- align-self\r\n\t\t\t- align-self允许单个项目拥有与其他项目不同的对齐方式，可覆盖align-items\r\n\t\t\t\t- 可取6个值，除了默认值auto都与align-items相同\r\n### animate动画\r\n- animate是一个简写属性，用于设置6大动画属性\r\n\t- animate-name 规定@keyframes动画名称\r\n\t\t- animate-name: keyframename; 动画名称\r\n\t\t- animate-name: none; 无动画效果，可用于覆盖来自级联的动画\r\n\t- animate-duration: time; 一个动画周期持续的时间，默认值为0\r\n\t- animation-timing-function 速度曲线\r\n\t\t- ease，默认值，以低速开始加速，结束前变慢\r\n\t\t- ease-in，以低速开始\r\n\t\t- ease-out，以低速结束\r\n\t\t- ease-in-out，以低速开始结束\r\n\t\t- linear，整个过程速度不变\r\n\t\t- cubic-bezier(n,n,n)，以cubic bezier函数来生成一个速度函数，可能的值是1到0\r\n\t- animation-delay:time; 何时开始，允许负值\r\n\t- animation-iteration-count播放次数\r\n\t\t- n，播放次数，默认值1\r\n\t\t- infinite，无限次播放\r\n\t- animation-direction规定动画在下一周期是否逆向播放\r\n\t\t- normal，默认值，正常播放\r\n\t\t- alternate，轮流反向播放\r\n- animation-play-state规定动画正在运行还是暂停\r\n\t- paused，已暂停\r\n\t- running，正在播放\r\n- @keyframes规则创建动画\r\n\t- @keyframes keyframename{ keyframes-selector{css-styles;}} \r\n\t\t- 如：@keyframes myfirstmove{ 0%{ top:0px; background:red; } 100%{ top:100px; background:yellow; }}\r\n- animation-fill-mode规定动画在播放之前或之后，其动画效果是否可见\r\n\t- none，不改变默认行为\r\n\t- forwards当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）\r\n\t- backwards在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）\r\n### transition过渡\r\n- transition是一个简写属性，用于设置4个过渡属性\r\n\t- transition-property: width; 用于设置产生变形的CSS属性\r\n\t- transition-duration: time; 用于设置过渡时间，是必须设置的，否则不会产生过渡效果\r\n\t- transition-timing-function类似于animate-timing-function\r\n\t- transition-delay: time; 效果开始前需要等待的时间\r\n### media queries\r\n- 工作方式\r\n\t- 直接在link中判断设备尺寸然后引用不同的css文件\r\n\t- link rel="stylesheet" type="text/css" href="#" media="screen and (min-width:400px ) and (max-width:600px)"\r\n\t- 直接写在style标签里\r\n\t- @media screen and (max-width:600px){ } \r\n- media属性中\r\n\t- 十种media type：all、screen、print、tv、handheld等\r\n\t- 关键字：and、only（限定某种媒体）、not（排除某种媒体）\r\n\t- 媒体特性，放在一对（）中，如(min-width:600px)\r\n## 盒模型\r\n### 标准盒模型\r\n- 元素的width、height只包含内容content，不包含border和padding的值；\r\n- 盒子的大小由元素的宽高、边框和内边距决定\r\n### 转换\r\n- box-sizing\r\n\t- content-box\r\n\t- border-box\r\n\t\t- 若想控制元素总宽高保持固定，这个设置很有用。\r\n### IE盒模型\r\n- 元素的width、height不仅包括content，还包括border和padding\r\n- 盒子的大小取决width、height，修改border和padding值不能改变盒子的大小\r\n### 注意\r\n- 元素的宽（width）、高（height）、边框（border）、内边距（padding）、外边距（margin）都是盒子模型的重要组成部分，但是盒子模型的大小只与元素的宽高、边框、内间距有关，外边距只影响盒子所占外围空间的大小。\r\n## 雪碧图优缺点\r\n### 减少图片请求次数\r\n### 提高页面加载速度\r\n- 合成的图片相比不合成图片大小综合要小\r\n### 影响浏览器缩放功能\r\n- 相邻图片会被露出来\r\n- 大图片会有性能下降问题\r\n### css编写困难\r\n### 拼图维护麻烦\r\n### css图片不能被打印\r\n- 除非在@media添加print声明\r\n### 最大问题就是内存的使用\r\n- 图片留有无用的空白\r\n## 元素居中方法汇总\r\n### 水平居中\r\n- 文本、图片\r\n\t- 容器中设置：text-align:center\r\n- 块级元素\r\n\t- ( 如果宽度固定)margin: auto法------margin: 0 auto （对浮动及绝对定位元素无效,另：这里的0 其实可以是任意值）\r\n\t- （如果宽度不固定）新增包裹元素法----设置包裹元素为浮动float:left;position:relative;left:50%,再设置其自身position:relative;left:-50% 或right:50%即可（该50%其实是相对包裹元素的宽度而并非其自身的宽度！另外该方法不适合垂直居中！！！除非高度固定才可以。）\r\n\t- 父元素相对定位，子元素绝对定位法（详见《垂直居中》中的块级元素部分）\r\n\t- （对于多个块级元素） inline-block法 ：其父元素设置text-align:center,其自身设置display:inline-block，使用inline-block注意清除由其带来的空隙及使用 vertical-align属性！\r\n### 垂直居中（或水平垂直居中）\r\n- 单行文本\r\n\t- （如果父元素高度固定）line-height法------父元素的height与父元素的line-height相等\r\n\t- （如果父元素高度不固定）上下padding法------父元素的上下padding相等\r\n- 多行文本\r\n\t- （如果父元素高度固定）vertical-align法------父元素设置display:table-cell;vertical-align:middle\r\n\t- （如果父元素高度不固定）上下padding法------父元素的上下padding相等\r\n- 块级元素\r\n\t- 如果尺寸固定\r\n\t\t- 负margin法------父元素设置position为relative，子元素position为absolute，top,left为：50%，margin-left,margin-top各为其自身宽或高的一半的负数。\r\n\t\t- calc法------同上，父元素设置position为relative，子元素position为absolute，top,left为：50%，采用calc（50%-其自身宽或高的一半）\r\n\t\t- transform法------同上，父元素设置position为relative，子元素position为absolute，top,left为：50%，并使用 transform: translate(-50%, -50%);\r\n\t\t- 4个0法------ 还是父元素设置position为relative，子元素position为absolute，其它见上面的代码\r\n\t- 如果尺寸不固定\r\n\t\t- transform法------父元素设置position为relative，子元素position为absolute，top,left为：50%，并使用 transform: translate(-50%, -50%);\r\n\t\t- display:table-cell法------ 父元素 display:table-cell; vertical-align:middle\r\n\t\t- flex法------父元素align-items:center;justify-content:center\r\n\t\t- 伪类法------在父元素中增加一个高度为100%的空元素，其他详见代码\r\n- 图片\r\n\t- display:table-cell法------display:table-cell;             vertical-align:middle\r\n\t- 伪类法------在父元素中增加一个高度为100%的空元素，其他详见代码\r\n\t- js处理设置上下边距相等\r\n## 网格布局\r\n### CSS网格属性总结\r\n- 网格容器（父元素）\r\n\t- display\r\n\t\t- grid\r\n\t\t- inline-grid\r\n\t\t- subgrid（行列大小会继承父级网格容器）\r\n\t- grid-template-columns、grid-template-rows\r\n\t\t- 网格线名称\r\n\t\t- 长度值、百分比或者fr\r\n\t- grid-template-areas\r\n\t\t- grid-area-name\r\n\t\t- . （点号） 代表一个空的网格单位\r\n\t\t- none 不定义网格区域\r\n\t- grid-template\r\n\t\t- none：将三个属性设为初始值\r\n\t\t- subgrid：将grid-template-columns及grid-template-rows的值设为subgrid，将grid-template-areas设为初始值\r\n\t\t- <grid-template-rows> / <grid-template-columns>将grid-template-rows和grid-template-columns设置为相应的值，并将grid-template-areas设为none\r\n\t- grid-column-gap/grid-row-gap\r\n\t\t- 长度值\r\n\t- grid-gap\r\n\t\t- <grid-row-gap> <grid-column-gap>长度值\r\n\t- justify-items（注意与justify-content的区别）\r\n\t\t- start\r\n\t\t- end\r\n\t\t- center\r\n\t\t- stretch\r\n\t- align-items\r\n\t\t- start\r\n\t\t- end\r\n\t\t- center\r\n\t\t- stretch\r\n\t- justify-content( 注意与flex中的justify-content区别，这里不是表示里面的内容 )\r\n\t\t- start\r\n\t\t- end\r\n\t\t- center\r\n\t\t- stretch\r\n\t\t- space-between\r\n\t\t- space-around\r\n\t\t- space-evenly\r\n\t- align-content\r\n\t\t- start\r\n\t\t- end\r\n\t\t- center\r\n\t\t- stretch\r\n\t\t- space-between\r\n\t\t- space-around\r\n\t\t- space-evenly\r\n\t- grid-auto-columns / grid-auto-rows\r\n\t\t- 长度值/百分比/fr\r\n\t- grid-auto-flow\r\n\t\t- row\r\n\t\t- column\r\n\t\t- row dense\r\n\t\t- column dense\r\n\t- grid\r\n\t\t- none\r\n\t\t\t- 将所有子属性设置为其初始值\r\n\t\t- <grid-template-rows> / <grid-template-columns>\r\n\t\t\t- 将grid-template-rows 和 grid-template-columns分别设置为指定值，将其他子属性设置为其初始值\r\n\t\t\t\t- 例子（上下两个是等效的）\r\n\t\t- <grid-auto-flow> [<grid-auto-rows> [ / <grid-auto-columns>] ] \r\n\t\t\t- 如果省略了grid-auto-columns，则它被设置为由grid-auto-rows指定的值。如果两个都被省略，他们会被设置为初始值\r\n\t\t\t\t- 例子（上下两个是等效的）\r\n\t\t-  <grid-template-areas> <grid-template-rows> / <grid-template-columns>\r\n\t\t\t- 一次性设置所有值，设置后其他属性均为默认值\r\n\t\t\t\t- 例子\r\n- 网格项（子元素）\r\n\t- grid-column-start / grid-column-end / grid-row-start / grid-row-end\r\n\t\t- 网格线名称\r\n\t\t- span <number> 该网格项将跨越所提供的网格轨道数量\r\n\t\t- span <name> 该网格项将跨越到它所提供的名称位置\r\n\t\t- auto：表示自动放置，自动跨度，默认会扩展一个网格轨道的宽度或高度\r\n\t- grid-column / grid-row\r\n\t\t- <start-line> / <end-line>\r\n\t\t\t- 含义\r\n\t\t\t\t- grid-column-start + grid-column-end 和 grid-row-start + grid-row-end的简写\r\n\t\t\t- 语法示范\r\n\t\t\t\t- 示范\r\n\t\t\t- 举例\r\n\t\t\t\t- 例子\r\n\t- grid-area\r\n\t\t- <name> ：自定义的名称，以便被grid-template-areas属性创建的模版所引用\r\n\t\t- <row-start> / <column-start> / <row-end> / <column-end>：数字或网格线名称（其实这里还有 比如  grid-row-start:1 ; grid-column-start:2等价的表达 ）\r\n\t- justify-self\r\n\t\t- start\r\n\t\t- end\r\n\t\t- center\r\n\t\t- stretch（默认值）\r\n\t- align-self\r\n\t\t- start\r\n\t\t- end\r\n\t\t- center\r\n\t\t- stretch（默认值）\r\n### CSS网格布局基本概念（mdn版）\r\n- 网格容器\r\n\t- （父元素）使用 display:grid 或者display:inline-grid\r\n- 网格轨道\r\n\t- （父元素）使用 grid-template-columns 和grid-template-rows属性来定义列和行\r\n\t- 单位：px或者百分比或者fr 如：grid-template-rows:1fr 1fr 1fr\r\n\t- 在轨道清单中使用repeat()来标记重复部分或者整个轨道列表\r\n\t\t- grid-template-rows:1fr 1fr 1fr 可以改写为grid-template-rows: repeat( 3, 1fr )\r\n\t\t- grid-template-rows: 20px 1fr 1fr 20px 可以改写为grid-template-rows:  20px  repeat( 2, 1fr ) 20px\r\n\t\t- 传入轨道列表 ：grid-template-rows: 1fr 2fr  1fr 2fr 1fr 2fr  可以改写为grid-template-rows:  repeat( 3, 1fr 2fr ) \r\n\t- （父元素）隐式和显式网格\r\n\t\t- grid-auto-rows （行  其实它控制的是元素的高度 --别搞混淆了）\r\n\t\t- grid-auto-columns （列 其实它控制的是元素的宽度--别搞混淆了）\r\n\t- 轨道大小和minmax()\r\n\t\t- grid-auto-rows :minmax(100px, auto) （其表示最小高度是100px，最大高度自适应）\r\n- 网格线\r\n\t- （子元素）跨轨道放置网格项目\r\n\t\t- grid-column-start , grid-column-end , grid-row-start ,grid-row-end\r\n\t\t- 比如  列线1-列线4，行线1至行线2  我们可以写成： grid-column-start:1 ; grid-column-end:4 ; grid-row-start:1 ;grid-row-end:2; 或者直接简写成 grid-column: 1/4 ;grid-row:1/2;\r\n- 网格单元\r\n\t- 最小单位\r\n- 网格区域\r\n\t-   （父元素） grid-template-areas\r\n\t- （子元素）grid-areas\r\n- 网格间距\r\n\t- （父元素）grid-column-gap、grid-row-gap 或者合并简写：grid-gap\r\n- 嵌套网格\r\n- 使用z-index控制层级\r\n\t- 原本覆盖的顺序遵循文档流的原始顺序原则即： 后来者居上的原则\r\n## Css2D-3D\r\n### 1.过渡效果transition\r\n- 说明：过渡是从一种状态到另外一种状态, 过渡需要触发条件, 通常过渡都是写在开始状态\r\n- transition-property\r\n\t- 规定哪些属性需要过渡\r\n\tall 默认值 全部属性过渡，多个属性过渡,用逗号隔开\r\n- transition-duration\r\n\t- 过渡的时间 默认值 0s\r\n- transition-timing-function\r\n\t- 过渡的运动曲线\r\n\tease 默认值 逐渐慢下来\r\n\tlinear  均速\r\n- transition-delay\r\n\t- 过渡的延迟\r\n- 连写：transition: all 1s linear 0s\r\n### 2.2D转换\r\n- 1.位移 transform：translate(-50%,-50%)\r\n\t- 优点：对自盒子不用计算向上和向左移动多少\r\n\t- 特点：若仅仅只是识位移，盒子不会脱标，盒子原有的位置还在标准流中\r\n- 2.旋转 transform：rotate(45deg)\r\n\t- 正=>顺时针\r\n\t- 负=>逆时针\r\n- 3.旋转点 transform-origin：水平 垂直\r\n\t- 可以设置方位名称，也可以设置具体数值\r\n- 3.缩放/扩大 transform：scale（number，number）\r\n\t- 1.大于0小于1=>缩放\r\n\t- 2.大于1=>扩大\r\n### 3.动画\r\n- 1.定义动画 @keyframs 名称 {\r\n\t0%{\r\n    }，\r\n\t100%{\r\n    }\r\n\t}\r\n- 2.指定动画名称 animation-name\r\n- 3.完成一个周期所需要的时间 animation-duration\r\n- 4.动画的运动曲线 linear匀速 ease缓冲 steps步长  animation-timing-function: linear\r\n- 5.次数 infinite无线循环 animation-iteration-count:infinite\r\n- 6.是否你想播放，如果想逆向播放的前提是 次数需要大于2次  animation-direction:alternate\r\n- 7.结束之后的状态 在哪里 animation-fill-mode: forwards\r\n- 8.延迟几秒开始 animation-delay: 3s\r\n- 9.暂停 animation-play-state: paused\r\n### 4.3D转换\r\n- 1.位移：transform：translate(x,y,z)\r\n\t- 1.x轴 正值向右，负值向左\r\n\t- 2.y轴 正值向下，负值向上\r\n\t- 3.z轴 正值向前，负值向后 \r\n\t- 注意：如果要设置多个轴时，不要分开设置，要写在同一个transform中\r\n- 2.旋转\r\n\t- transform：- transform: rotateX(角度); \r\n    - transform: rotateY(角度); \r\n    - transform: rotateZ(角度); \r\n- 注意：\r\n\t- 1.视距越大，物体越小，*视距越小，物体越大\r\n\t- 2.translateZ值越大，物体越大，translateZ越小，物体越小\r\n\t- 3.translateZ一定要与perspective 一起使用，近大远小\r\n\t- 4.左手法则\r\n\t\t- 1.X正值=>右\r\n\t\t- 2.Y正值=>下\r\n## 移动端\r\n### 移动端（流式）布局\r\n- 1.移动端相关知识\r\n\t- 1.什么是物理像素\r\n\t\t- 答：屏幕分辨率\r\n\t- 2.什么是开发像素\r\n\t\t- 答：css像素px 就是开发像素\r\n\t- 3.开发像素在PC端和屏幕分辨率比例是一致吗？\r\n\t\t- 答：一致\r\n\t- 4.开发像素在移动端和屏幕分辨率比例一致吗？\r\n\t\t- 答：不一定一致，因为物理像素比可能不一样\r\n\t- 5.什么是物理像素比？\r\n\t\t- 答：1个物理像素=多个开发像素\r\n\t- 6，物理像素比的影响\r\n\t\t- 答：未来图片在移动端，因为物理像素比的存在，图片可能会放大而失真，影响用户体验，所以设计素材人员，在设计图片时，以多倍的方式设置\r\n- 2.盒子模型 box-sizing\r\n\t- 1.传统盒子（content-box）\r\n\t\t- 盒子大小：内容+padding+border\r\n\t\t\t- 缺点：盒子要是保持原来的大小，需要自己计算width 和 height\r\n\t- 2.CSS3盒子（border-box）\r\n\t\t- 盒子大小：内容（内容+padding+border）\r\n\t\t\t- 优点：盒子的内容会自动适应模型的变化\r\n- 3.扩展（H5新增标签）\r\n\t- 1.header 头部标签\r\n\t- 2.footer 底部标签\r\n\t- 3.section 区块标签\r\n\t- 4.article 文本内容标签\r\n\t- 5.aside 侧边标签\r\n\t- 6.nav 导航标签\r\n\t- 注意：以上标签均可用div代替，但是div没有语义\r\n- 4.京东移动端案例：（注意事项）\r\n\t- 1.视口配置-理想视口（记得要写，写在字符编码下方即可）\r\n\t\t-  <meta name="viewport" content="width=device-width, user-scalable=no,initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">\r\n\t- 2.初始化样式\r\n\t\t- normalize.css\r\n### 移动端flex（弹性）布局\r\n- 1.设置主轴方向（flex-direction）\r\n\t- 1.row水平\r\n\t- 2.column垂直\r\n\t- 3.row-reverse 反向/column-reverse 反向\r\n- 2.设置主轴上子元素的排列方式（justify-content）\r\n\t- 1.flex-start 从头开始\r\n\t- 2.flex-end 从尾部开始\r\n\t- 3.center 居中\r\n\t- 4.space-around 平分间距\r\n\t- 5.space-between 两端对齐中间自动填充\r\n- 3.设置子元素是否换行（flex-wrap）\r\n\t- 1.nowrap 不换行（默认）\r\n\t- 2.wrap 换行\r\n- 4.设置侧轴上的子元素排列方式（单行 ）（aligin-items）\r\n\t- 1.flex-start 从上到下\r\n\t- 2.flex-end 从下到上\r\n\t- 3.center 居中\r\n\t- 4.stretch 拉伸（不能设置高度）\r\n- 5.设置侧轴上的子元素的排列方式（多行）（align-content）\r\n\t- 1.flex-start （默认值在侧轴的头部开始）\r\n\t- 2.flex -end （在侧轴的尾部开始排列）\r\n\t- 3.center （在侧轴中间显示）\r\n\t- 4.space-around （子项在侧轴平分剩余部分）\r\n\t- 5.space-between 子项在侧轴先分布在两头，在平分剩余空间\r\n\t- 6.stretch 设置子项元素高度平分父元素高度\r\n- 6.flex属性 \r\n\t- 1.flex 属性定义子项目==分配容器的剩余空间==，用flex来表示占多少==份数==。\r\n\t- 2.align-self 控制子项自己在侧轴上的排列方式\r\n\t- 3.order 属性定义项目的排列顺序/数值越小，排列越靠前，默认为0。\r\n### 移动端（rem布局）\r\n- 1.单位\r\n\t- 1.em\r\n\t\t- 基于父亲的字体的大小\r\n\t- 2.rem\r\n\t\t- 基于Html 字体的大小（绝对唯一控制）\r\n- 2.媒体查询\r\n\t- 作用：查询屏幕，相应屏幕变化\r\n\t- 档位划分 例：@media screen and （min-width）\r\n\t- 等比：在各个挡位下，比例一直不变，变化的是rem后面的值\r\n- 3.less\r\n\t- 是一种css的扩展语言，辅助css计算使用\r\n- 4.flexible.js\r\n\t- 引入此js 可以实现等比变化，不会一抽一抽的\r\n### 响应式布局（PC，手机，pad）\r\n- 1.档位划分\r\n\t- w<768  超小屏幕（xs : extra small）\r\n\t- 768<= w <992  小屏设备\r\n\t- 992<= w <1200  中等屏幕\r\n\t- 1200<=w  大宽屏设备（lg: large）\r\n- 2.bootstrap\r\n\t- 1.栅格系统\r\n\t\t- 1.在各个档位下，控制子元素布局不同；将版心宽度均分为  12份\r\n\t- 2.特点\r\n\t\t- 1.盒子有左右15padding\r\n\t\t- 2.盒子 col-lg：有左右15padding\r\n\t\t- 3.去除15padding：加div.row （左右负 -15px margin 值）\r\n\t- 3.作用：左右偏移，居中\r\n- 3.备注\r\n\t- 1.向下：涉及向下布局，需要手动写媒体查询\r\n\t- 2.只要涉及隐藏，就要用到响应式工具  \r\n\t\t- 例如：hidden-xs 只是xs时隐藏\r\n\t\t- 例如：visible-xs  知识xs时显示\r\n## BFC\r\n### 触发BFC（一个新的BFC可以通过给容器添加任何一个触发BFC的CSS样式来创建）\r\n- float的值不为none\r\n- position的值不为static或者relative\r\n\t- 关于position定位\r\n\t\t- static定位\r\n\t\t\t- 　static定位是HTML元素的默认值，即没有定位，元素出现在正常的流中\r\n\t\t- fixed固定定位\r\n\t\t\t- fixed定位是指元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会滚动，且fixed定位使元素的位置与文档流无关，因此不占据空间，且它会和其他元素发生重叠。\r\n\t\t\t- 兼容性\r\n\t\t- relative相对定位\r\n\t\t\t- 相对定位元素的定位是相对它自己的正常位置的定位。\r\n\t\t\t- 即使相对元素的内容移动了，但是预留空间的元素仍然保存在正常流动\r\n\t\t- absolute绝对定位\r\n\t\t\t- 绝对定位的元素相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于<html>。\r\n\t\t- sticky粘性定位\r\n\t\t\t- 粘性定位是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。\r\n\t\t\t- 实例\r\n\t\t\t\t- 在 viewport 视口滚动到元素 top 距离小于 10px 之前，元素为相对定位。之后，元素将固定在与顶部距离 10px 的位置，直到 viewport 视口回滚到阈值以下。\r\n\t\t\t- 实现条件\r\n\t\t\t\t- 须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。\r\n- display的值为 table-cell, table-caption, inline-block, flex, 或者 inline-flex中的其中一个\r\n- overflow的值不为visible\r\n### BFC的约束规则\r\n- 1，BFC内元素垂直方向的边距会发生重叠（当兄弟元素的外边距不一样时，将以最大的那个外边距为准。）\r\n- 2，BFC的区域不会与浮动元素的BOX重叠（清除浮动）\r\n- 3，BFC在页面上是一个容器，外面的元素不会影响到里面的元素\r\n- 4，计算BFC元素高度时，即使是浮动元素也会参与计算\r\n- 5，每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界）\r\n### BFC应用\r\n- 使用BFC来防止外边距折叠\r\n\t- 毗邻块盒子的垂直外边距折叠只有他们是在同一BFC时才会发生。如果他们属于不同的BFC，他们之间的外边距将不会折叠。所以通过创建一个新的BFC我们可以防止外边距折叠。\r\n- 使用BFC来包含浮动\r\n\t- 很多时候我们会碰到这种情况，一个容器里有浮动元素。由于这个原因，容器元素没有高度，它的浮动孩子将会脱离页面的常规流。我们通常使用清除浮动来解决这个问题，最受欢迎的方法是使用一个clearfix的伪类元素。但我们同样可以通过定义一个BFC来达到这个目的。\r\n- 使用BFC来防止文字环绕\r\n\t- 给p标签创建BFC即可\r\n- 在多列布局中使用BFC\r\n\t- 如果我们正在创建的一个多列布局占满了整个容器的宽度，在某些浏览器中最后一列有时候将会被挤到下一行。会发生这样可能是因为浏览器舍入（取整）了列的宽度使得总和的宽度超过了容器的宽度。然而，如果我们在一个列的布局中建立了一个新的BFC，它将会在前一列填充完之后的后面占据所剩余的空间。\r\n## CSS3新特性\r\n### 文字阴影（text-shadow）\r\n### 边框\r\n- 圆角（border-radius）\r\n\t- 是一个简写属性，用于设置四个 border-*-radius 属性。\r\n- 边框阴影： box-shadow\r\n\t- box-shadow: 水平阴影的位置 垂直阴影的位置 模糊距离 阴影的尺寸 阴影的颜色 内嵌;\r\n### 盒子模型（box-sizing）\r\n### 渐变：linear-gradient、radial-gradient\r\n### 过渡：transition，可实现动画\r\n### 自定义动画\r\n### 在CSS3中唯一引入的伪元素是 ：selection.\r\n- ::selection 选择器匹配被用户选取的选取是部分。\r\n- 只能向 ::selection 选择器应用少量 CSS 属性：color、background、cursor 以及 outline。\r\n### 媒体查询\r\n### 2D转换：transform：translate(x，y) rotate(x，y) skew(x，y) scale(x，y)\r\n### 3D转换\r\n### 新增的伪类\r\n- p:first-of-type 选择属于其父元素的首个 <p> 元素的每个 <p> 元素。\r\n- p:last-of-type 选择属于其父元素的最后 <p> 元素的每个 <p> 元素。\r\n- p:only-of-type 选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。\r\n- p:only-child 选择属于其父元素的唯一子元素的每个 <p> 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 <p> 元素。 :enabled、:disabled 控制表单控件的禁用状态。\r\n- :checked，单选框或复选框被选中。html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？\r\n## 【CSS】内联块元素与<IMG>标签\r\n### display：inline\r\n- 特点\r\n\t- (1)、和其他元素都在一行上；\r\n\t- (2)、元素的高度、宽度、行高及顶部和底部边距不可设置；（仅可设置左右边距）\r\n\t- (3)、元素的宽度就是它包含的文字或图片的宽度，不可改变。\r\n- 示例\r\n### display：block\r\n- 特点\r\n\t- (1)、每个块级元素都从新的一行开始，并且其后的元素也另起一行。（一个块级元素独占一行）;\r\n\t- (2)、元素的高度、宽度、行高以及顶和底边距都可设置;\r\n\t- (3)、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。\r\n- 示例\r\n### display：inline-block\r\n- 特点\r\n\t- (1)、和其他元素都在一行上；\r\n\t- (2)、元素的高度、宽度、行高以及顶和底边距都可设置\r\n- 示例\r\n### 额外\r\n- （1）<img>元素是内联还是块级元素？\r\n\t- img属于行内替换元素。height/width/padding/margin均可用。效果等于块元素。（等同于inline-block）\r\n\t- 行内非替换元素，例如, height/width/padding top、bottom/margin top、bottom均无效果。只能用padding left、right和padding left、right改变宽度。\r\n- （2）插入img下面会有空白\r\n\t- 现象\r\n\t- 解决\r\n\t\t- 1、给图片img标签display:block\r\n\t\t- 2、定义图片img标签vertical-align:bottom，vertical-align:middle，vertical-align:top。\r\n\t\t- 3、定义容器里的字体大小font-size为0。\r\n\t- 原理：img元素底部为何有空白？\r\n\t\t- 要理解CSS对于 display: inline 元素的 vertical-align 各个值的含义。vertical-align 的默认值是 baseline，这是一个西文排版才有的概念\r\n\t\t- 对比一下 vertical-align 的另外两个常见值，top 和 bottom\r\n\t\t\t- 可以看到，baseline 和 bottom 之间有一定的距离。实际上，inline 的图片下面那一道空白正是 baseline 和 bottom 之间的这段距离。即使只有图片没有文字，只要是 inline 的图片这段空白都会存在。\r\n\t\t- 到这里就比较明显了，要去掉这段空白，最直接的办法是将图片的 vertical-align 设置为其他值。如果在同一行里有文字混排的话，那应该是用 bottom 或是 middle 比较好。\r\n\t\t- 另外，top 和 bottom 之间的值即为 line-height。假如把 line-height 设置为0，那么 baseline 与 bottom 之间的距离也变为0，那道空白也就不见了。如果没有设置 line-height，line-height 的默认值是基于 font-size 的，视渲染引擎有所不同，但一般是乘以一个系数（比如1.2）。因此，在没有设置 line-height 的情况下把 font-size 设为0也可以达到同样的效果。当然，这样做的后果就是不能图文混排了。\r\n## Flex布局总结\r\n### Flex之前\r\n### 一种新的布局方式\r\n- 1.块级布局侧重垂直方向、行内布局侧重水平方向，flex布局是与方向无关的\r\n- 2.flex布局可以实现空间自动分配、自动对齐\r\n- 3.flex适用于简单的线性布局，更复杂的布局要交给grid布局\r\n### 基本概念\r\n- flex container 的属性(父元素)\r\n\t- flex-direction\t方向\r\n\t\t- row\t按行排列\r\n\t\t- row-revervse\t  按行反向排列\r\n\t\t- column\t按列排列\r\n\t\t- column-revervse 按列反向排列\r\n\t- flex-wrap\t换行\r\n\t\t- wrap\t折行\r\n\t\t- nowrap\t不折行\r\n\t- flex-flow\t上面两个的简写\r\n\t- justify-content\t主轴方向对齐方式\r\n\t\t- space-between 多余空间放置中间\r\n\t\t- space-around  空间放置周围\r\n\t\t- flex-start  全部向起点靠拢\r\n\t\t- flex-end  全部向终点靠拢\r\n\t\t- center  全部往中间靠拢\r\n\t- align-items\t侧轴对齐方式\r\n\t\t- stretch  在子元素高度不写死的情况下，按最高元素高度对齐\r\n\t\t- flex-start  所有元素按照顶部水平线对齐\r\n\t\t- flex-end  所有元素按照其底部水平线对齐\r\n\t\t- center  所有元素按照中间水平线对齐\r\n\t\t- baseline  项目的第一行文字的基线对齐。（较少使用）\r\n\t- align-content\t多行/列内容对齐方式（用的较少）\r\n\t\t- space-between  行与行之间的空隙平均分配\r\n\t\t- space-around  空间放置两边\r\n\t\t- flex-start  全部向侧轴起点靠拢\r\n\t\t- flex-end  全部向侧轴终点靠拢\r\n\t\t- stretch（默认值）  轴线占满整个侧轴\r\n- flex item的属性（子元素）\r\n\t- flex-grow  增长比例（空间过多时）\r\n\t- flex-shrink  收缩比例（空间不够时）\r\n\t- flex-basis  默认大小时（一般不用）\r\n\t- flex  以上三个的缩写\r\n\t- order  顺序（代替双飞翼）\r\n\t- align-self  自身的对齐方式\r\n### 使用Flex布局\r\n- 1.手机页面布局（tapbar+main+tabs）\r\n- 2.产品列表（ul>li*9）\r\n- 3.PC页面居中\r\n- 4.完美居中\r\n## CSS中的百分数都是相对于谁\r\n### （1）第一类——定位类\r\n- absolute\r\n\t- left、right是相对于参照物的width，top和bottom是相对于参照物的height\r\n- relative\r\n\t- left、right是相对于父元素的width，top和bottom是相对于参照物的height\r\n- fixed\r\n\t- 它是相对于视窗定位的，那么自然%的参照物便是视窗了。\r\n### （2）第二类——盒子模型\r\n- margin&padding\r\n\t- 如果设置了%值，那么他们参照的是父元素的宽度\r\n- border-radius\r\n\t- 盒子自身的宽高\r\n### （3）第三类——背景值\r\n- background-size\r\n\t- 盒子自身的宽高：background-size:100% 100%;\r\n- background-position\r\n\t- 这个属性比较特殊，他不是参照原盒子的宽高值，而是原盒子的宽高值减去背景图片的宽高值所得到的剩余值，更为形象的说，下面这两个属性值是等价的："center center"和"50% 50%"，如果你设置了后者，背景图片会自动居中，不用像定位那样还需要transform偏移了。\r\n### （4）第四类——transform\r\n- translate3d()\r\n\t- 这个属性的含义就是在指定方向上进行2d偏移，它的参照物是自身的宽高。而transform3d()的第三个属性，指的是在z轴上的偏移，因为z-index的默认值是auto，所以%值并不能起作用，也就是说对translateZ()赋予百分比的值是无意义的。\r\n### （5）第五类——字体\r\n- font-size\r\n\t- 和height一样，是参照父盒子的字体大小的\r\n- line-height\r\n\t- 是给定的百分比值乘以元素最后计算出的字体大小\r\n- text-indent\r\n\t- 参照的是父元素的width\r\n### 总结\r\n- 相对于父盒子：\r\n\t- 参照父元素对应属性的有：width、height、font-size\r\n\t- 参照父元素的width的有：padding、margin、text-indent\r\n\t- 【特殊】position：relativeleft、right是相对于父元素的width，top和bottom是相对于参照物的height\r\n- 相对于盒子自身：\r\n\t- 盒子模型中的border-radius；\r\n\t- 背景中的background-size；\r\n\t- 在transform变换中，translate()、transform-origin、scale()还有我们拓展的与transform相似的zoom属性，他们都是参照自身的；\r\n\t- line-height行高与它的字体大小有关，所以参照的就是自身的font-size。\r\n- 相对于定位元素：\r\n\t- position：absolute、position：fixed;\r\n## 【css选择器】css选择器与优先级\r\n### 选择器\r\n- 基本选择器\r\n\t- *\t 通配选择器 \t选择文档中所以HTML元素\r\n\t- E\t 元素选择器\t选择指定类型的HTML元素\r\n\t- #id\t ID选择器\t选择指定ID属性值为“id”的任意类型元素\r\n\t- .class\t 类选择器\t选择指定class属性值为“class”的任意类型的任意多个元素\r\n\t-  div,span,img {color:Red}      群组选择器     即具有相同样式的标签分组显示\r\n- 层次选择器\r\n\t- E  F\t后代选择器\t选择匹配的F元素，且匹配的F元素被包含在匹配的E元素内\r\n\t- E>F\t子选择器\t选择匹配的F元素，且匹配的F元素所匹配的E元素的子元素\r\n\t- E+F\t相邻兄弟选择器\t选择匹配的F元素，且匹配的F元素紧位于匹配的E元素的后面\r\n\t- E~F\t通用选择器\t选择匹配的F元素，且位于匹配的E元素后的所有匹配的F元素\r\n- 动态伪类选择器\r\n\t- E:link\t    链接伪类选择器  选择匹配的E元素，而且匹配元素被定义了超链接并未被访问过。常用于链接描点上\r\n\t- E:visited   链接伪类选择器  选择匹配的E元素，而且匹配元素被定义了超链接并已被访问过。常用于链接描点上\r\n\t- E:active   选择匹配的E元素，且匹配元素被激活。常用于链接描点和按钮上\r\n\t- E:hover\t  选择匹配的E元素，且用户鼠标停留在元素E上。IE6及以下浏览器仅支持a:hover\r\n\t- E:focus    选择匹配的E元素，而且匹配元素获取焦点\r\n- 目标伪类选择器\r\n\t- E:target\t选择匹配E的所有元素，且匹配元素被相关URL指向\r\n- 元素状态伪类选择器\r\n\t- E:checked\t选中状态伪类选择器\t匹配选中的复选按钮或者单选按钮表单元素\r\n\t- E:enabled\t启用状态伪类选择器\t匹配所有启用的表单元素\r\n\t- E:disabled\t不可用状态伪类选择器\t匹配所有禁用的表单元素\r\n- 结构伪类选择器\r\n\t- E:fisrt-child\t作为父元素的第一个子元素的元素E。与E:nth-child(1)等同\r\n\t- E:last-child\t作为父元素的最后一个子元素的元素E。与E:nth-last-child(1)等同\r\n\t- E:root\t选择匹配元素E所在文档的根元素。在HTML文档中，根元素始终是html，此时该选择器与html类型选择器匹配的内容相同\r\n\t- E F:nth-child(n)\t选择父元素E的第n个子元素F。其中n可以是整数（1，2，3）、关键字（even，odd）、可以是公式（2n+1）,而且n值起始值为1，而不是0.\r\n\t- E F:nth-last-child(n)\t选择父元素E的倒数第n个子元素F。此选择器与E:nth-child(n)选择器计算顺序刚好相反，但使用方法都是一样的，其中：nth-last-child(1)始终匹配最后一个元素，与last-child等同\r\n\t- E:nth-of-type(n)\t选择父元素内具有指定类型的第n个E元素\r\n\t- E:nth-last-of-type(n)\t选择父元素内具有指定类型的倒数第n个E元素\r\n\t- E:first-of-type\t选择父元素内具有指定类型的第一个E元素，与E:nth-of-type(1)等同\r\n\t- E:last-of-tye\t选择父元素内具有指定类型的最后一个E元素，与E:nth-last-of-type(1)等同\r\n\t- E:only-child\t选择父元素只包含一个子元素，且该子元素匹配E元素\r\n\t- E:only-of-type\t选择父元素只包含一个同类型子元素，且该子元素匹配E元素\r\n\t- E:empty\t选择没有子元素的元素，而且该元素也不包含任何文本节点\r\n\t- 注意\r\n\t\t- （1），“ul>li:nth-child(3)”表达的并不是一定选择列表ul元素中的第3个子元素li，仅有列表ul中第3个li元素前不存在其他的元素，命题才有意义，否则不会改变列表第3个li元素的样式。\r\n\t\t- （2），:nth-child(n)  中参数只能是n，不可以用其他字母代替。\r\n\t\t- （3），:nth-child(odd) 选择的是奇数项，而使用:nth-last-child(odd) 选择的却是偶数项\r\n- 否定伪类选择器\r\n\t- E:not(F)\t匹配所有除元素F外的E元素\r\n- 属性选择器语法\r\n\t- [attribute]\t用于选取带有指定属性的元素。\r\n\t- [attribute=value]\t用于选取带有指定属性和值的元素。\r\n\t- [attribute~=value]\t用于选取属性值中包含指定词汇的元素。\r\n\t- [attribute|=value]\t用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。\r\n\t- [attribute^=value]\t匹配属性值以指定值开头的每个元素。\r\n\t- [attribute$=value]\t匹配属性值以指定值结尾的每个元素。\r\n\t- [attribute*=value]\t匹配属性值中包含指定值的每个元素。\r\n### 选择器优先级\r\n- 第一优先级：无条件优先的属性只需要在属性后面使用！important。它会覆盖页面内任何位置定义的元素样式。ie6不支持该属性。\r\n- 第二优先级：在html中给元素标签加style，即内联样式。该方法会造成css难以管理，所以不推荐使用。\r\n- 第三优先级：由一个或多个id选择器来定义。例如，#id{margin:0;}会覆盖.classname{margin:3pxl}\r\n- 第四优先级：由一个或多个类选择器、属性选择器、伪类选择器定义。如.classname{margin:3px}会覆盖div{margin:6px;}（伪类选择器 = 属性选择器 > 类选择器）\r\n- 第五优先级：由一个或多个标签选择器定义。如div{marigin:6px;}覆盖*{margin:10px；}\r\n- 第六优先级：通配选择器，如*{marigin:6px;}\r\n### 权重\r\n- 内联样式（1000）\r\n- ID选择符（0100）\r\n- 类、伪类、属性选择符（0010）\r\n- 类型、伪元素选择符（0001）\r\n- 通配符、相邻选择符等（0000）\r\n- 继承（没有权重）\r\n## 【清除浮动】CSS清除浮动的方法\r\n### （1）在浮动元素下添加一个空的div，并且为其设置了样式clear:both;\r\n- 这个规则只能影响使用清除的元素本身，不能影响其他元素,clear了隐藏div的both\r\n- 我们是通过在别的元素上清除浮动来实现撑开高度的， 而不是在浮动元素上\r\n### （2）通过BFC清除浮动引起的高度塌陷，原理是BFC在计算高度的时候会连同浮动元素的高度一起计算\r\n### （3）使用CSS中clearfix的after伪元素\r\n- 关于::after和::before的理解\r\n\t- 概述\r\n\t\t- 这两个伪元素相当于是对当前元素的装潢，他们并不是节点，不会出现在dom树中，但是在显示上具备节点的效果。\r\n\t- 使用\r\n\t\t- （1）::after和::before的使用很简单，可以认为其所在元素上存在一前一后的两个的元素，这两个元素默认是内联元素，但我们可以为其增添样式。\r\n\t\t- （2）必须设置content，否则这两个伪元素是无法显示出来的。而content属性，会作为这两个伪元素的内容嵌入他们中。\r\n\t\t- （3）::after和::before是虚拟元素，不会影响真正元素的所在文档的位置，对:first-child或者:last-child这种伪类选择不会造成影响。\r\n\t- 操作\r\n\t\t- ::after和::before是虚拟节点，而不是正在的节点，不在documont里面找到对应Node对象\r\n\t\t- console.log( document.querySelector("ul").childNodes)；得到的是一个只有3个节点的NodeList对象，而两个伪元素并不在对象中。因为::after和::before不是真正的节点，所以我们取不到他们，也不发设置点击等用户事件。\r\n\t\t- 可以通过css的接口获取其样式属性\r\n\t- ::after和::before使用的经验\r\n\t\t- 1.间隔符用法\r\n\t\t- 2.做border三角图标（常考）\r\n\t\t- 3.字符图标\r\n\t\t- 4.webfont的图标\r\n\t\t- 5.做单位、标签、表单必填标准\r\n\t\t- 7.实现一些标签对placeholder的支持\r\n\t\t- 8.实现文字图片居中对齐\r\n\t\t- 9.清除浮动\r\n\t- 总体可以分为四种用法：\r\n\t\t- 1.用css创建装饰性元素\r\n\t\t- 2.用css创建用于布局的元素，实现特殊布局的特殊需要\r\n\t\t- 3.做显示图标的实现手段\r\n\t\t- 4.配合attr显示属性值\r\n\t- 伪类与伪元素的差异\r\n\t\t- 伪类\r\n\t\t\t- 定义\r\n\t\t\t\t- CSS 伪类用于向某些选择器添加特殊的效果。\r\n\t\t\t- 功能\r\n\t\t\t\t- 获取不存在与DOM树中的信息。比如<a>标签的:link、visited等，这些信息不存在与DOM树结构中，只能通过CSS选择器来获取；\r\n\t\t\t\t- 获取不能被常规CSS选择器获取的信息。比如伪类:target，它的作用是匹配文档(页面)的URI中某个标志符的目标元素，例如我们可以通过如下代码来实现页面内的区域跳转：\r\n\t\t- 伪元素\r\n\t\t\t- 定义\r\n\t\t\t\t- 伪元素在DOM树中创建了一些抽象元素，这些抽象元素是不存在于文档语言里的（可以理解为html源码）\r\n\t\t\t\t- 通俗来说\r\n\t\t\t\t\t- 伪元素创建了一个虚拟容器，这个容器不包含任何DOM元素，但是可以包含内容。\r\n\t\t- 总结一下伪类与伪元素的特性及其区别：\r\n\t\t\t- （1）伪类本质上是为了弥补常规CSS选择器的不足，以便获取到更多信息；\r\n\t\t\t- （2）伪元素本质上是创建了一个有内容的虚拟容器；\r\n\t\t\t- （3）CSS3中伪类和伪元素的语法不同；\r\n\t\t\t- （4）可以同时使用多个伪类，而只能同时使用一个伪元素；\r\n## 【布局】CSS中的左右两栏定宽，中间自适应布局方案\r\n### 浮动布局\r\n  .container .left {         \r\n            float: left;\r\n            width: 200px;\r\n            background-color: orange;        \r\n            }\r\n        .container .main {         \r\n            background-color: rgb(0, 255, 106);           \r\n        }\r\n        .container .right {         \r\n            float: right;\r\n            width: 200px;\r\n            background-color: rgb(76, 0, 255);            \r\n        }\r\n<div class="container">\r\n        <div class=\'left\'>111111</div>\r\n        <div class="right">1111111</div>\r\n        <div class=\'center\'>111111111</div>\r\n    </div>\r\n- 左右浮动，中间不用浮动，DOM上中间要放最后\r\n### 定位布局\r\n        .container>div{\r\n            position: absolute;\r\n        }\r\n        .left{\r\n            left:0;\r\n            width: 300px;\r\n            background: red;\r\n        }\r\n         .center{\r\n            left: 300px;\r\n            right: 300px;\r\n            background: yellow;\r\n        }\r\n        .right{\r\n            right:0;\r\n            width: 300px;\r\n            background: blue;\r\n        }\r\n        <div class="left"></div>\r\n        <div class="center"></div>\r\n        <div class="right"></div>\r\n- 首先三个盒子都得绝对定位，左left：0，右right：0，中left：300px；right：300px，DOM正常\r\n### Flex布局\r\n       .container{\r\n            display: flex;\r\n        }\r\n        .left{\r\n            width: 300px;\r\n            background: red;\r\n        }\r\n        .center{\r\n            flex:1;\r\n            background: yellow;\r\n        }\r\n         .right{\r\n            width: 300px;\r\n            background: blue;\r\n        }\r\n- 父元素display：flex；左右设置宽度，中间flex：1，DOM正常\r\n### Grid布局\r\n.layout.grid .left-center-right{\r\n            width:100%;\r\n            display: grid;\r\n            grid-template-rows: 100px;\r\n            grid-template-columns: 300px auto 300px;\r\n        }\r\n        .layout.grid .left-center-right>div{\r\n        }\r\n        .layout.grid .left{\r\n            background: red;\r\n        }\r\n        .layout.grid .center{\r\n            background: yellow;\r\n        }\r\n        .layout.grid .right{\r\n            background: blue;\r\n        }\r\n### 表格布局\r\n      .container{\r\n            width:100%;\r\n            height: 100px;\r\n            display: table;\r\n        }\r\n        .containter>div{\r\n            display: table-cell;\r\n        }\r\n        .left{\r\n            width: 300px;\r\n            background: red;\r\n        }\r\n       .center{\r\n            background: yellow;\r\n        }\r\n         .right{\r\n            width: 300px;\r\n            background: blue;\r\n        }\r\n- 给父元素设置display：table；三个盒子都设置display：table-cell；左右设置宽度，DOM正常\r\n### 圣杯布局\r\n<template>\r\n<header>header</header>\r\n<section class="wrapper">\r\n    <section class="col main">main</section>\r\n    <aside class="col left">left</aside>\r\n    <aside class="col right">right</aside>\r\n</section>\r\n<footer>footer</footer>\r\n</template>\r\n- 诞生缘由\r\n\t- 希望中部 main 部分优先显示的话，是可以做布局优化的。提前即可优先渲染\r\n- 存在缺陷\r\n\t- 如果将浏览器无限变窄，「圣杯」将会「破碎」掉。当 main 部分的宽小于 left 部分时就会发生布局混乱。\r\n- CSS部分\r\n- 要点\r\n\t- （1）父元素设置左右padding，并创建BFC（设置overflow：hidden或其他）或使用伪元素清除浮动\r\n\t- （2）为三个盒子设置position：relative；float：left\r\n\t- （3）中间盒子宽度100%，左右定宽\r\n\t- （4）为左盒子设置margin-left：-100%，left：-100px；右盒子设置margin-left：-100px，right：-定宽px\r\n### 双飞翼布局\r\n<header>header</header>\r\n<section class="wrapper">\r\n    <section class="col main">\r\n        <section class="main-wrap">main</section>\r\n    </section>\r\n    <aside class="col left">left</aside>\r\n    <aside class="col right">right</aside>\r\n</section>\r\n<footer>footer</footer>\r\n- css部分\r\n- 缺点\r\n\t- 多加一层 dom 树节点，增加了 css 样式规则表和 dom 树合并成布局树的计算量\r\n- 要点\r\n\t- （1）父元素BFC清除浮动\r\n\t- （2）三个盒子全部左浮动\r\n\t- （3）中间main盒子宽度100%，其父盒子左右margin为定宽\r\n\t- （4）左盒子margin-left：-100%，右盒子margin-left：-定宽px\r\n\r\n### 选用情况\r\n',st={data:function(){return{MainComponent:ot}}},it=st,lt=Object(m["a"])(it,et,at,!1,null,"b377bde6",null),ct=lt.exports,pt=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div")},ut=[],mt={},dt=mt,gt=Object(m["a"])(dt,pt,ut,!1,null,"76f4e806",null),bt=(gt.exports,function(){var n=this;return n.$createElement,n._self._c,n._m(0)}),ht=[function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[r("h3",[n._v("var() 变量 ")]),r("pre",[n._v("    var()函数可以代替元素中任何属性中的值的任何部分。\n    var()函数不能作为属性名、选择器或者其他除了属性值之外的值。\n    （这样做通常会产生无效的语法或者一个没有关联到变量的值。）\n\n语法\n方法的第一个参数是要替换的自定义属性的名称。函数的可选第二个参数用作回退值。\n如果第一个参数引用的自定义属性无效，则该函数将使用第二个值。\n\nvar( custom-property-name , declaration-value? )\n\n\n:root {\n  --main-bg-color: pink;\n}\n\nbody {\n  background-color: var(--main-bg-color);\n}\n/* 后备值 */\n\n/* 在父元素样式中 */\n.component {\n  --text-color: #080; /* header-color 并没有被设定 */\n}\n\n/* 在 component 的样式中： */\n.component .header {\n  color: var(--header-color, blue); /* 此处 color 被回退到 blue */\n}\n\n.component .text {\n  color: var(--text-color, black);\n}\n")])])}],yt={},ft=yt,vt=Object(m["a"])(ft,bt,ht,!1,null,"7436dd0f",null),St=vt.exports,_t=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},kt=[],jt="## 1、变量 $ 使用\r\n我们可以通过变量来复用属性值，比如颜色、边框大小、图片路径等，这样可以做到更改一处，从而进行全局更改，从而实现“换肤”的功能。\r\n**实例1：我们的组件库，利用变量配置，进行统一更改组件的颜色、字体大小等（换肤）：**\r\n```\r\n$color-primary: #3ecacb;\r\n$color-success: #4fc48d;\r\n$color-warning: #f3d93f;\r\n$color-danger: #f6588e;\r\n$color-info: #27c6fa;\r\n```\r\n**实例2：图片的配置及全局引入**\r\n`Scss`中图片的使用，可能存在以下2个问题：\r\n（1）如果样式文件和使用该样式文件的`vue`文件不在同一目录会出现图片找不到\r\n（2）如果将图片路径配置变量写在`vue`文件的`style`中，但是该写法导致图片和样式分离\r\n我们可以采用将图片路径写成配置文件，然后进行全局引入，这样可以统一更改图片路径（并且该方法只会在使用相应图片时进行加载，不会导致额外性能问题）：\r\n```\r\n$common-path: './primary/assets/img/';\r\n$icon-see: $common-path+'icon-see.png';\r\n$icon-play: $common-path+'icon-play.png';\r\n$icon-comment: $common-path+'icon-comment.png';\r\n$icon-checkbox: $common-path+'icon-checkbox.png';\r\n```\r\n## 2、[@import]导入Scss文件\r\n（1）`Css`中的`@import`规则，它允许在一个`css`文件中导入其他`css`文件。然而，后果是只有执行到`@import`时，浏览器才会去下载其他`css`文件，这导致页面加载起来特别慢。\r\n（2）`Scss`中的`@import`规则，不同的是，`scss`的`@import`规则在生成`css`文件时就把相关文件导入进来。这意味着所有相关的样式被归纳到了同一个`css`文件中，而无需发起额外的下载请求。\r\n**实例1：组件库中统一将组件的样式文件`import`进`index.sccs`中**，然后如果项目中有使用组件库的地方只需要在项目的入口处，引入`index.scss`文件，如下所示在`index.scss`文件中引入各组件的样式文件：\r\n```\r\n@import \"./base.scss\";\r\n@import \"./webupload.scss\";\r\n@import \"./message-hint.scss\";\r\n```\r\n## 3、局部文件命名的使用\r\n`scss`局部文件的文件名以下划线开头。这样，`scss`就不会在编译时单独编译这个文件输出`css`，而只把这个文件用作导入。在使用`scss`时，混合器`mixins`是最适合的使用场景，因为混合器不需要单独编译输出`css`文件。\r\n**实例1：将混合器的名称写成局部文件命名的方式，如下图所示**\r\n## 4、Scss的嵌套功能和父选择器标识符\r\n我们可以使用嵌套功能和父选择器标识符 & 来缩减重复的代码，特别如果你`CSS`类采用`BEM`命名规范，样式类命名存在冗长的问题。使用此功能，能解决`BEM`命名冗长的问题，且样式可读性更高。\r\n**实例1：嵌套功能和父选择器标识符 & 解决BEM冗长问题：**\r\n```\r\n.tea-assignhw { \r\n &__top {  \r\n  margin: 0;  \r\n} \r\n &__content { \r\n   padding-left: 45px; \r\n }  \r\n&__gradeselect { \r\n   width: 158px;  \r\n }\r\n}\r\n```\r\n**实例2：**嵌套中使用子选择器、兄弟选择器和伪类选择器\r\n**（1）子选择器**\r\n```\r\n&__hint {\r\n  margin: 20px;  \r\n  font-size: 14px;  \r\n  > p:first-child { \r\n     font-weight: bold;  \r\n }\r\n}\r\n```\r\n**（2）兄弟选择器**\r\n```\r\n&__input { \r\n width: 220px; \r\n & + span {   \r\n   margin-left: 10px;  \r\n }\r\n}\r\n```\r\n**（3）伪类选择器**\r\n```\r\n&__browse {\r\n  background: url($btn-search) no-repeat;  \r\n&:hover {   \r\n  background: url($btn-search) -80px 0 no-repeat;  \r\n}  \r\n&:visited {  \r\n  background: url($btn-search) -160px 0 no-repeat; \r\n }\r\n}\r\n```\r\n## 5、[@mixin]  混合器和 [@extend]  指令的使用\r\n变量使你能够复用属性值，但如果想要复用一大段规则呢？传统的做法是，如果在样式表\r\n中发现重复，就会把公共的规则抽离出来放到新的`CSS`类中。\r\n在`Scss`中可以使用混合器`@mixin`和`@extend`继承指令来解决以上提到的复用一大段规则的场景。但两者的使用场景又有啥区别呢？\r\n（1）`@mixin`主要的优势就是它能够接受参数。如果想传递参数，你会很自然地选择`@mixin`而不是[@extend] ，因为`@extend`不能够接受参数\r\n（2）因为混合器规则都混入到其他类中，所以在输出的样式表中不能完全避免重复。选择器继承的意思就是让一个选择器能够复用另一个选择器的所有样式，但又不重复输出这些样式属性；即使用`@extend`产生 [DRY CSS](https://link.juejin.im/?target=http%3A%2F%2Fvanseodesign.com%2Fcss%2Fdry-principles%2F)风格的代码（Don't repeat yourself）\r\n综上所述，如果你需要传参数，只能使用`@mixin`混合器，否则用`@extend`继承来实现更优。\r\n**实例1：[@mixin] 混合器的使用**\r\n```\r\n@mixin paneactive($image, $level, $vertical) { \r\n  background: url($image) no-repeat $level $vertical;  \r\n  height: 100px;  \r\n  width: 30px; \r\n  position: relative;  \r\n  top: 50%;\r\n}\r\n&--left-active {  \r\n  @include paneactive($btn-flip, 0, 0);\r\n}\r\n&--right-active { \r\n  @include paneactive($btn-flip, 0, -105px);\r\n}\r\n```\r\n**实例2：[@extend] 继承的使用**\r\n```\r\n.common-mod {  \r\n  height: 250px;  \r\n  width: 50%;  \r\n  background-color: #fff;  \r\n  text-align: center;\r\n}\r\n&-mod { \r\n  @extend .common-mod;  \r\n  float: right;\r\n}\r\n&-mod2 { \r\n  @extend .common-mod;\r\n}\r\n```\r\n## 6、[@mixin]  混合器默认参数值的使用\r\n在`@include`混合器时不必传入所有的参数，我们可以给参数指定一个默认值，如果所需要传的参数是 默认值，则`@include`时可以省略该参数；如果所需要传的参数不是默认值，则`@include`时则传入新的参数。\r\n**实例1：[@mixin] 混合器默认参数值的使用**\r\n```\r\n@mixin pane($dir: left) {  \r\n  width: 35px; \r\n  display: block;  \r\n  float: $dir;  \r\n  background-color: #f1f1f1;\r\n}\r\n&__paneleft { \r\n  @include pane;\r\n}\r\n&__paneright {\r\n  @include pane(right);\r\n}\r\n```\r\n## 7、#{} 插值的使用\r\n通过 #{} 插值语句可以在选择器或属性名中使用变量。当有两个页面的样式类似时，我们会将类似的样式抽取成页面混合器，但两个不同的页面样式的命名名称根据`BEM`命名规范不能一样，这时我们可使用插值进行动态命名。\r\n**实例1：页面级混合器中的类名利用#{}插值进行动态设置**\r\n```\r\n@mixin home-content($class) { \r\n .#{$class} {   \r\n   position: relative;    \r\n   background-color: #fff;    \r\n   overflow-x: hidden;    \r\n   overflow-y: hidden;    \r\n &--left {     \r\n    margin-left: 160px;  \r\n }    \r\n &--noleft {  \r\n    margin-left: 0;  \r\n } \r\n }\r\n}\r\n```\r\n## 8、运算的使用\r\n`SassScript` 支持数字的加减乘除、取整等运算 (+, -, *, /, %)\r\n**实例1：input组件根据输入框的高度设置左右内边距，如下所示：**\r\n```\r\n.ps-input { \r\n   display: block;  \r\n   &__inner {   \r\n    -webkit-appearance: none;  \r\n     padding-left: #{$--input-height + 10\r\n   };    \r\n     padding-right: #{$--input-height + 10\r\n   };    \r\n  }\r\n}\r\n```\r\n## 9、相关scss自带函数的应用\r\n`scss`自带一些函数，例如`hsl`、`mix`函数等。\r\n**实例1：button组件的点击后颜色是将几种颜色根据一定的比例混合在一起，生成另一种颜色。**如下所示：\r\n```\r\n&:focus { \r\n  color: mix($--color-white, $--color-primary, $--button-hover-tint-percent);  \r\n  border-color: transparent;  \r\n  background-color: transparent;}\r\n&:active {  \r\n  color: mix($--color-black, $--color-primary, $--button-active-shade-percent); \r\n  border-color: transparent;  background-color: transparent;\r\n}\r\n```\r\n## 10、相关scss自带函数的应用\r\n`@for`指令可以在限制的范围内重复输出样式，每次按变量的值对输出结果进行变动。\r\n**实例1：例如项目中需要设置hwicon类底下第2到8个div子节点需设置样式**，如下所示：\r\n```\r\n@for $i from 2 through 8 {  \r\n.com-hwicon {    \r\n > div:nth-child(#{$i}) {   \r\n   position: relative;    \r\n   float: right;   \r\n  }  \r\n }\r\n}\r\n```\r\n## 11、each遍历、map数据类型、@mixin/[@include] 混合器、#{}插值 结合使用\r\n可通过结合`each`遍历、`map`数据类型、`@mixin/@include`混合器、#{}插值，从而生成不同的选择器类，并且每个选择器类中的背景图片不同，如下所示：\r\n```\r\n$img-list: (  \r\n (accessimg, $papers-access),   \r\n (folderimg, $papers-folder),  \r\n (bmpimg, $papers-bmp),   \r\n (xlsimg, $papers-excel),   \r\n (xlsximg, $papers-excel),   \r\n (gifimg, $papers-gif),  \r\n (jpgimg, $papers-jpg),   \r\n (unknownimg, $papers-unknown)\r\n);\r\n@each $label, $value in $img-list { \r\n .com-hwicon__#{$label} {\r\n    @include commonImg($value); \r\n }\r\n}\r\n```\r\n",wt={data:function(){return{MainComponent:jt}}},xt=wt,Tt=Object(m["a"])(xt,_t,kt,!1,null,"f758c71e",null),Ct=Tt.exports,Mt=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[n._v("\n    1\n")])},Pt=[],Ot={},Et=Ot,Rt=Object(m["a"])(Et,Mt,Pt,!1,null,"232157bc",null),Nt=Rt.exports,At=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[n._v("\n    1\n")])},Dt=[],It={},Jt=It,Lt=Object(m["a"])(Jt,At,Dt,!1,null,"7709893a",null),Ht=Lt.exports,Ft=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div")},Ut=[],qt={},Bt=qt,Wt=Object(m["a"])(Bt,Ft,Ut,!1,null,"b6f36ad6",null),Vt=Wt.exports,Gt={mixins:[k["c"]],components:{m1:rt,m2:ct,m4:St,m5:Ct,m6:Nt,m7:Ht,m8:Vt},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"显隐",value:"m1"},{label:"全面梳理",value:"m2"},{label:"var()",value:"m4"},{label:"SASS总结",value:"m5"}]}}},zt=Gt,$t=Object(m["a"])(zt,$n,Xn,!1,null,"86ce5794",null),Xt=$t.exports,Kt=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[r("div",[r(""+n.tab,{tag:"component"})],1)])},Qt=[],Yt=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},Zt=[],nr="#### javascript中的12种循环遍历方法1\r\n\r\n1：for循环\r\n\r\n```javascript\r\nlet arr = [1,2,3];\r\n\r\nfor(let i =0;i<arr.length;i++){\r\n\r\nconsole.log(i,arr[i])\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n//for循环是js中最常用的一个循环工具，经常用来数组的循环遍历，\r\n\r\n2：for in循环\r\n\r\n```\r\nlet obj = {name: 'xiao' ,age:'24'}\r\n\r\nfor(let i in obj){\r\n\r\nconsole.log(i,obj[i]);\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n//for in 循环主要用于遍历普通对象，i 代表对象的 key 值，obj[i] 代表对应的 value,当用它来遍历数组时候，多数情况下也能达到同样的效果，但是你不要这么做，这是有风险的，因为 i 输出为字符串形式，而不是数组需要的数字下标，这意味着在某些情况下，会发生字符串运算，导致数据错误，比如：'52'+1 = '521' 而不是我们需要的 53。另外 for in 循环的时候，不仅遍历自身的属性，还会找到 prototype 上去，所以最好在循环体内加一个判断，就用 obj[i].hasOwnProperty(i)，这样就避免遍历出太多不需要的属性。\r\n\r\n3：while循环\r\n\r\n```\r\nlet cars=[\"BMW\",\"Volvo\",\"Saab\",\"Ford\"];\r\nlet i=0;\r\nwhile(cars[i])\r\n{\r\nconsole.log(cars[i] + \"<br>\")\r\ni++;\r\n};\r\n```\r\n\r\n4：do while循环\r\n\r\n```\r\nlet i = 3;\r\ndo{\r\n console.log(i)\r\n i--;\r\n}\r\nwhile(i>0)\r\n```\r\n\r\n//do while 循环是 while 循环的一个变体，它首先执行一次操作，然后才进行条件判断，是 true 的话再继续执行操作，是 false 的话循环结束。\r\n\r\n5：Array forEach循环\r\n\r\n```\r\nlet arr = [1,2,3];\r\narr.forEach(function(i,index){\r\n console.log(i,index)\r\n})\r\n```\r\n\r\n//forEach循环，循环数组中每一个元素并采取操作， 没有返回值， 可以不用知道数组长度,他有三个参数，只有第一个是必需的，代表当前下标下的 value。\r\n\r\n另外请注意，forEach 循环在所有元素调用完毕之前是不能停止的，它没有 break 语句，如果你必须要停止，可以尝试 try catch 语句，就是在要强制退出的时候，抛出一个 error 给 catch 捕捉到，然后在 catch 里面 return，这样就能中止循环了，如果你经常用这个方法，最好自定义一个这样的 forEach 函数在你的库里。\r\n\r\n6：Array map（)方法\r\n\r\n```\r\nlet arr = [1,2,3];\r\n\r\nlet tt = arr.map(function(i){\r\n\r\nconsole.log(i);\r\n\r\nreturn i*2;\r\n\r\n})\r\n```\r\n\r\n\r\n\r\n//map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。\r\n注意：map 和 forEach 方法都是只能用来遍历数组，不能用来遍历普通对象。\r\n\r\n7:Array filter()方法\r\n\r\n```\r\nlet arr = [1,2,3];\r\n\r\nlet tt= arr.filter(function(i){\r\n\r\nreturn i > 1;\r\n\r\n})\r\n```\r\n\r\n\r\n\r\n//filter 方法是 Array 对象内置方法，它会返回通过过滤的元素，不改变原来的数组。\r\n\r\n8:Array some()方法\r\n\r\n```\r\nlet arr =[1,2,3];\r\n\r\nlet tt = arr.some(function(i){\r\n\r\nreturn i > 1;\r\n\r\n})\r\n```\r\n\r\n\r\n\r\n//some() 方法用于检测数组中的元素是否满足指定条件（函数提供）,返回 boolean 值，不改变原数组。\r\n\r\n9:Array every()方法\r\n\r\n```\r\nlet arr = [1,2,3];\r\n\r\nlet tt = arr.some(function(i){\r\n\r\nreturn i > 1;\r\n\r\n})\r\n```\r\n\r\n\r\n\r\n//every() 方法用于检测数组所有元素是否都符合指定条件（通过函数提供），返回 boolean 值，不改变原数组。\r\n\r\n```\r\n10:Array reduce()方法\r\n\r\nlet arr = [1,2,3];\r\n\r\nlet ad = arr.reduce(function(i,j){\r\n\r\nreturn i + j;\r\n\r\n})\r\n```\r\n\r\n\r\n\r\n//reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。\r\n\r\n11:Array reduceRight()方法\r\n\r\n```\r\nlet arr = [1,2,3];\r\n\r\nlet ad = arr.reduceRight(function(i,j){\r\n\r\nreturn i + j;\r\n\r\n})\r\n```\r\n\r\n\r\n\r\n//reduceRight()方法,和 reduce() 功能是一样的，它是从数组的末尾处向前开始计算。\r\n\r\n12:for of 循环\r\n\r\n```\r\nlet arr = ['name','age'];\r\n\r\nfor(let i of arr){\r\n\r\nconsole.log(i);\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n//for of 循环是 Es6 中新增的语句，用来替代 for in 和 forEach，它允许你遍历 Arrays（数组）, Strings（字符串）, Maps（映射）, Sets（集合）等可迭代(Iterable data)的数据结构,注意它的兼容性。\r\n\r\n",tr={data:function(){return{MainComponent:nr}},methods:{}},rr=tr,er=Object(m["a"])(rr,Yt,Zt,!1,null,"cc57f5ea",null),ar=er.exports,or=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}})],1)},sr=[],ir=(r("caad"),r("ac1f"),r("2532"),r("1276"),"## 什么是Event Loop？\r\n\r\n## 为什么JavaScript是单线程？\r\n\r\n> JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。\r\n>\r\n> JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？\r\n>\r\n> 所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。\r\n>\r\n> 为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。\r\n\r\n## 任务队列\r\n\r\n单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。\r\n\r\n如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。\r\n\r\nJavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。\r\n\r\n于是，所有任务可以分成两种，\r\n\r\n一种是同步任务（synchronous），另一种是异步任务（asynchronous）。\r\n\r\n同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。\r\n\r\n具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）\r\n\r\n1. 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。\r\n2. 主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。\r\n3. 一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。\r\n4. 主线程不断重复上面的第三步。\r\n\r\n下图就是主线程和任务队列的示意图。\r\n\r\n![img](./event-loop/6264932-fa0f7f82a2c23d9e.jpg)\r\n\r\n任务队列\r\n\r\n只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。\r\n\r\n这个过程会不断重复。\r\n\r\n## 事件和回调函数\r\n\r\n> “任务队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。\r\n>\r\n> “任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。\r\n>\r\n> 所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。\r\n>\r\n> “任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。\r\n>\r\n\r\n## Event Loop\r\n\r\n主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。\r\n\r\n为了更好地理解Event Loop，请看下图（转引自Philip Roberts的演讲《Help, I’m stuck in an event-loop》）。\r\n\r\n![img](./event-loop/6264932-f995befec0aa08ac.png)\r\n\r\n上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在”任务队列”中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。\r\n\r\n执行栈中的代码（同步任务），总是在读取”任务队列”（异步任务）之前执行。请看下面这个例子。\r\n\r\n```\r\nvar req = new XMLHttpRequest();\r\nreq.open('GET', url);    \r\nreq.onload = function (){};    \r\nreq.onerror = function (){};    \r\nreq.send();\r\n```\r\n\r\n上面代码中的req.send方法是Ajax操作向服务器发送数据，它是一个异步任务，意味着只有当前脚本的所有代码执行完，系统才会去读取”任务队列”。所以，它与下面的写法等价。\r\n\r\n```\r\nvar req = new XMLHttpRequest();\r\nreq.open('GET', url);\r\nreq.send();\r\nreq.onload = function (){};    \r\nreq.onerror = function (){};   \r\n```\r\n\r\n也就是说，指定回调函数的部分（onload和onerror），在send()方法的前面或后面无关紧要，因为它们属于执行栈的一部分，系统总是执行完它们，才会去读取”任务队列”。\r\n\r\n## 定时器\r\n\r\n除了放置异步任务的事件，”任务队列”还可以放置定时事件，即指定某些代码在多少时间之后执行。这叫做”定时器”（timer）功能，也就是定时执行的代码。\r\n\r\n定时器功能主要由setTimeout()和setInterval()这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行。以下主要讨论setTimeout()。\r\n\r\nsetTimeout()接受两个参数，第一个是回调函数，第二个是推迟执行的毫秒数。\r\n\r\n```\r\nconsole.log(1);\r\nsetTimeout(function(){console.log(2);},1000);\r\nconsole.log(3);\r\n```\r\n\r\n上面代码的执行结果是1，3，2，因为setTimeout()将第二行推迟到1000毫秒之后执行。\r\n\r\n如果将setTimeout()的第二个参数设为0，就表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。\r\n\r\n```\r\nsetTimeout(function(){console.log(1);}, 0);\r\nconsole.log(2);\r\n```\r\n\r\n上面代码的执行结果总是2，1，因为只有在执行完第二行以后，系统才会去执行”任务队列”中的回调函数。\r\n\r\n总之，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。\r\nHTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout()。\r\n\r\n需要注意的是，setTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。\r\n\r\n## Node.js的Event Loop\r\n\r\nNode.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。\r\n请看下面的示意图（作者@BusyRich）。\r\n\r\n![img](./event-loop/6264932-767c51a903ec54e7.png)\r\n\r\nNode.js\r\n\r\n根据上图，Node.js的运行机制如下。\r\n\r\n1. V8引擎解析JavaScript脚本。\r\n2. 解析后的代码，调用Node API。\r\n3. libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。\r\n4. V8引擎再将结果返回给用户。\r\n\r\n除了setTimeout和setInterval这两个方法，Node.js还提供了另外两个与”任务队列”有关的方法：process.nextTick和setImmediate。它们可以帮助我们加深对”任务队列”的理解。\r\n\r\nprocess.nextTick方法可以在当前”执行栈”的尾部—-下一次Event Loop（主线程读取”任务队列”）之前—-触发回调函数。也就是说，它指定的任务总是发生在所有异步任务之前。setImmediate方法则是在当前”任务队列”的尾部添加事件，也就是说，它指定的任务总是在下一次Event Loop时执行，这与setTimeout(fn, 0)很像。请看下面的例子（via StackOverflow）。\r\n\r\n```\r\nprocess.nextTick(function A() {\r\n    console.log(1);\r\n    process.nextTick(function B(){console.log(2);});\r\n});\r\n\r\nsetTimeout(function timeout() {\r\n    console.log('TIMEOUT FIRED');\r\n}, 0)\r\n// 1\r\n// 2\r\n// TIMEOUT FIRED\r\n```\r\n\r\n上面代码中，由于process.nextTick方法指定的回调函数，总是在当前”执行栈”的尾部触发，所以不仅函数A比setTimeout指定的回调函数timeout先执行，而且函数B也比timeout先执行。这说明，如果有多个process.nextTick语句（不管它们是否嵌套），将全部在当前”执行栈”执行。\r\n\r\n现在，再看setImmediate。\r\n\r\n```\r\nsetImmediate(function A() {\r\n    console.log(1);\r\n    setImmediate(function B(){console.log(2);});\r\n});\r\n\r\nsetTimeout(function timeout() {\r\n    console.log('TIMEOUT FIRED');\r\n}, 0);\r\n```\r\n\r\n上面代码中，setImmediate与setTimeout(fn,0)各自添加了一个回调函数A和timeout，都是在下一次Event Loop触发。那么，哪个回调函数先执行呢？答案是不确定。运行结果可能是1–TIMEOUT FIRED–2，也可能是TIMEOUT FIRED–1–2。\r\n\r\n令人困惑的是，Node.js文档中称，setImmediate指定的回调函数，总是排在setTimeout前面。实际上，这种情况只发生在递归调用的时候。\r\n\r\n```\r\nsetImmediate(function (){\r\n    setImmediate(function A() {\r\n    console.log(1);\r\n    setImmediate(function B(){console.log(2);});\r\n});\r\n\r\nsetTimeout(function timeout() {\r\n    console.log('TIMEOUT FIRED');\r\n}, 0);\r\n});\r\n// 1\r\n// TIMEOUT FIRED\r\n// 2\r\n```\r\n\r\n上面代码中，setImmediate和setTimeout被封装在一个setImmediate里面，它的运行结果总是1–TIMEOUT FIRED–2，这时函数A一定在timeout前面触发。至于2排在TIMEOUT FIRED的后面（即函数B在timeout后面触发），是因为setImmediate总是将事件注册到下一轮Event Loop，所以函数A和timeout是在同一轮Loop执行，而函数B在下一轮Loop执行。\r\n\r\n我们由此得到了process.nextTick和setImmediate的一个重要区别：多个process.nextTick语句总是在当前”执行栈”一次执行完，多个setImmediate可能则需要多次loop才能执行完。事实上，这正是Node.js 10.0版添加setImmediate方法的原因，否则像下面这样的递归调用process.nextTick，将会没完没了，主线程根本不会去读取”事件队列”！\r\n\r\n```\r\nprocess.nextTick(function foo() {\r\n    process.nextTick(foo);\r\n});\r\n```\r\n\r\n事实上，现在要是你写出递归的process.nextTick，Node.js会抛出一个警告，要求你改成setImmediate。\r\n\r\n另外，由于process.nextTick指定的回调函数是在本次”事件循环”触发，而setImmediate指定的是在下次”事件循环”触发，所以很显然，前者总是比后者发生得早，而且执行效率也高（因为不用检查”任务队列”）。"),lr={data:function(){return{MainComponent:ir,img_prefix:"./img/web/js/"}},methods:{extendMarkdown:function(n){var t=this;console.log(n.renderer.rules);var r=n.renderer.rules.html_block;n.renderer.rules.html_block=function(n,e,a,o,s){var i=n[e];if(console.log("1"),i.content.includes("<img")){console.log("token-- ",i);var l="";l=i.content;var c=l.split('src="'),p=c[0]+' src="'+t.img_prefix+c[1];i.content=p}return i.attrSet("class","q-markdown--token  "),r(n,e,a,o,s)},n.renderer.rules.image=function(n,r,e,a,o){var s=n[r];console.log("3"),s.attrSet("class","q-markdown--image"),console.log("token--- "+r+"-----",s);var i=s.attrGet("src");return console.log(i),s.attrSet("src",t.img_prefix+i),o.renderToken(n,r,e)}}}},cr=lr,pr=Object(m["a"])(cr,or,sr,!1,null,"24dc2132",null),ur=pr.exports,mr=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},dr=[],gr='# js\r\n\r\n## 作用域\r\n\r\n> ### 执行上下文\r\n>\r\n> - 变量对象 AO\r\n>\r\n> \t- 变量对象是与执行上下文相关的数据作用域\r\n>\r\n> \t\t- 全局上下文\r\n>\r\n> \t\t\t- 变量对象即全局对象\r\n>\r\n> \t\t- 函数上下文\r\n>\r\n> \t\t\t- 活动对象，是由引擎实现的，在执行上下文中被激活\r\n>\r\n> \t\t- AO（活动变量） = VO（变量对象 + function parameters + arguments\r\n>\r\n> \t- 变量对象在执行过程中的变化\r\n>\r\n> \t\t- 进入执行上下文\r\n>\r\n> \t\t\t- 创建变量对象\r\n>\r\n> \t\t- 代码执行\r\n>\r\n> \t\t\t- 顺序执行代码，修改上下文变量的值\r\n>\r\n> \t\t- 执行完毕，上下文弹出\r\n>\r\n> \t- 函数的所有形参\r\n> \t- 函数声明\r\n> \t- 变量声明\r\n>- 作用域链 Scope\r\n> \r\n>\t- 函数被创建，保存函数父作用域到函数[[scope]]属性\r\n> \t- 函数执行，进入上下文吗，函数作用域压入栈\r\n> \t- 复制函数[[scope]]属性，创建作用域链\r\n> \t- 用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明\r\n> \t- 将活动对象压入  函数作用域链顶端\r\n> \t- 开始执行函数，随着函数的执行，修改 AO 的属性值\r\n> \t- 函数执行完毕，函数上下文从执行上下文栈中弹出\r\n> \r\n>- this\r\n> \r\n>\t- 简单的理解 this 为调用函数的对象\r\n> \r\n>- 执行上下文\r\n> \r\n>\t- JavaScript代码被解析和执行时所在环境的抽象概念\r\n> \t- 执行上下文的类型\r\n> \r\n>\t\t- 全局执行上下文\r\n> \r\n>\t\t\t- 只有一个，浏览器中的全局对象window，this执行这个全局对象\r\n> \r\n>\t\t- 函数执行上下文\r\n> \r\n>\t\t\t- 存在无数个，在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文\r\n> \r\n>\t\t- Eval函数执行上下文\r\n> \r\n>\t\t\t- 指运行在eval函数中的代码，不建议使用\r\n> \r\n>\t- 执行栈也叫调用栈\r\n> \r\n>\t\t- 用于存储在代码执行期间创建的所有执行上下文\r\n> \t\t- 首次运行会创建一个全局的执行上下文，push到当前的执行栈中，每当有函数调用，引擎都会为该函数创建一个新的函数执行上下文并push到当前执行栈的栈顶。\r\n> \t\t- 栈顶函数运行完成后，会将其pop出栈，执行下一个栈顶函数\r\n> \r\n>\t- 执行上下文的创建\r\n> \r\n>\t\t- 创建阶段\r\n> \r\n>\t\t\t- 确定this\r\n> \t\t\t- 词法环境\r\n> \r\n>\t\t\t\t- 环境记录\r\n> \r\n>\t\t\t\t\t- 存储变量和函数声明的实际位置\r\n> \r\n>\t\t\t\t- 对外部环境的引用\r\n> \r\n>\t\t\t\t\t- 可以访问的外部词法环境\r\n> \r\n>\t\t\t- 变量环境\r\n> \r\n>\t\t\t\t- 也是一个词法环境\r\n> \r\n>\t\t\t\t\t- 主要区别变量使用var声明、而词法环境用let、const声明\r\n> \r\n>\t\t- 执行阶段\r\n> \r\n>\t\t\t- 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值\r\n> \t\t\t- 在代码执行阶段，会再次修改变量对象的属性值\r\n> \r\n>### 提升\r\n> \r\n>- 提升\r\n> \r\n>\t- 引擎会 在解释 JavaScript 代码之前首先对其进行编译。编译阶段找到所有声明,用合适的作用域将它们关联起来\r\n> \t- var a = 2; 会被拆成两个阶段进行，var a （编译阶段）a=2（执行阶段），这个过程就叫作 提升\r\n> \t- 一个普通块内部的函数声明通常会被提升到所在作用域的顶部\r\n> \t- 每个作用域 都会进行提升操作\r\n> \r\n>- 函数优先\r\n> \r\n>\t- 函数会首先被提升,然后才是变量\r\n> \r\n>### 词法作用域\r\n> \r\n>- 词法阶段\r\n> \r\n>\t- 词法作用域都只由函数被声明时所处的位置决定\r\n> \t- 作用域查找会在找到第一个匹配的标识符时停止（遮蔽效应）\r\n> \r\n>- 欺骗词法\r\n> \r\n>\t- 欺骗词法作用域会导致性能 下降，不是好主意\r\n> \t- eval\r\n> \t- with\r\n> \r\n>### 函数作用域和块作用域\r\n> \r\n>- 隐藏内部实现\r\n> \r\n>\t- 从所写的代码中挑选出一个任意的片段,然后用函数声明对它进行包装（隐藏代码）\r\n> \t- 规避冲突：“隐藏”作用域中的变量和函数所带来的另一个好处,是可以避免同名标识符之间的冲突\r\n> \t- 规避冲突方法\r\n> \r\n>\t\t- 命名空间\r\n> \t\t- 模块管理\r\n> \r\n>- 函数作用域\r\n> \r\n>\t- 匿名函数，最熟悉的场景可能就是回调参数\r\n> \r\n>\t\t- 匿名函数在栈追踪中不会显示出有意义的函数名,使得调试很困难。\r\n> \t\t- 如果没有函数名,当函数需要引用自身时只能使用已经 过期 的 arguments.callee 引用\r\n> \t\t- 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名\r\n> \r\n>\t- 立即执行函数表达式，IIFE\r\n> \r\n>\t\t- 普遍的进阶用法是把它们当作函数调用并传递参数进去\r\n> \t\t- IIFE 还有一种变化的用途是倒置代码的运行顺序\r\n> \r\n>- 块作用域\r\n> \r\n>\t- with 关键字是 块作用域的一 个例子\r\n> \t- try / catch 的 catch 分句会创建一个块作 用域\r\n> \t-  ES6 引入了新的 let 关键字\r\n> \t- ES6 还引入了 const , 同样可以用来创建块作用域变量\r\n> \t- 另一个块作用域非常有用的原因和闭包及回收内存垃圾的回收机制相关\r\n> \r\n>### 作用域\r\n> \r\n>- 能够储存变量当中的值,并且能在之后对这个 值进行访问或修改\r\n> - 编译原理\r\n> \r\n>\t- 分词/词法分析：这个过程会将由字符组成的字符串分解成(对编程语言来说)有意义的代码块\r\n> \t- 解析/语法分析:将词法单元流(数组)转换成一个由元素逐级嵌套所组成的代表了程序语法\r\n> 结构的树(抽象语法树 AST)\r\n> \t- 代码生成:将 AST 转换为可执行代码的过程称被称为代码生成\r\n> \t- javascript 编译过程发生在代码执行前几微妙\r\n> \t- JavaScript 引擎用尽了各种办法(比如 JIT, 可以延 迟编译甚至实施重编译)来保证性能最佳。\r\n> \r\n>- 作用域\r\n> \r\n>\t- 几个概念\r\n> \r\n>\t\t- 编译器\r\n> \t\t- 引擎\r\n> \t\t- 作用域\r\n> \r\n>\t- var a = 2;\r\n> \r\n>\t\t- 编译器会询问作用域是否已经有一个该名称的变量\r\n> \r\n>\t\t\t- 如果是,编译器会忽略该声明\r\n> \t\t\t- 否则,要求作用域在当前集合声明一个新变量 a\r\n> \r\n>\t\t- 接下来编译器会为引擎生成运行时所需的代码，处理 a=2 的赋值操作\r\n> \r\n>\t- 引擎查找变量规则\r\n> \r\n>\t\t- LHS，当变量出现在赋值操作的左侧时进行LHS查询\r\n> \t\t- RHS,出现在右侧时进行RHS查询\r\n> \r\n>\t- 作用域嵌套\r\n> \r\n>\t\t- 引擎从当前的执行作用域开始查找变量,如果找不到, 就向上一级继续查找\r\n> \r\n>### 作用域闭包\r\n> \r\n>- javascript 中闭包无处不在,你只需要能够识别并拥抱它\r\n> - 闭包概念\r\n> \r\n>\t- 闭包：函数是在当前词法作用 域之外执行\r\n> \t- 闭包阻止了引擎有垃圾回收器用来释放不再使用的内存空间\r\n> \t- 函数不在定义词法中执行，但是依然保持对该词法的引用，这个引用叫做闭包\r\n> \r\n>- 模块\r\n> \r\n>\t- 最常见的实现模块模式的方法通常被称为 模块暴露\r\n> \t- 必须有外部的封闭函数,每次调用都会创建一个新的模块 实例\r\n> \t- 封闭函数必须返回至少一个内部函数\r\n> \t- 大多数模块依赖加载器 / 管理器本质上都是将这种模块定义封装进一个友好的 API。\r\n> \t- ES6 会将文件当作独立 的模块来处理\r\n> \r\n>\t\t- 每个模块都可以导入其他模块或特定的 API 成员\r\n> \t\t- 同样也可以导出自己的 API 成员\r\n\r\n## this\r\n\r\n> ### this 的误解\r\n>\r\n> - 隐式传递一个对象的引用\r\n> - this 在任何情况下都不指向函数的词法作用域\r\n> - this 是在函数运行时，创建上下文的时候确定的\r\n>\r\n> ### this 的绑定规则\r\n>\r\n> - 默认绑定\r\n>\r\n> \t- 使用不带任何修饰的函数引用进行调用的\r\n>\r\n> - 隐式绑定\r\n>\r\n> \t- 调用位置是否有上下文对象\r\n> \t- 隐式丢失\r\n>\r\n> \t\t- 通常发生在对象赋值的情况\r\n>\r\n> - 显式绑定\r\n>\r\n> \t- 使用函数的 call(..) 和 apply(..) 方法\r\n> \t- 硬绑定\r\n>\r\n> - new 绑定\r\n>\r\n> \t- 创建(或者说构造)一个全新的对象。\r\n> \t- 这个新对象会被执行[[原型]]连接。\r\n> \t- 这个新对象会绑定到函数调用的 this\r\n> \t- 如果函数没有返回其他对象,那么 new 表达式中的函数调用会自动返回这个新对象\r\n>\r\n> ### 箭头函数 this 指向\r\n>\r\n> - 根据外层(函数或者全局)作用域来决 定 this\r\n\r\n## 原型\r\n\r\n> ###   [[Prototype]]\r\n>\r\n> - JavaScript 中的对象有一个特殊的内置属性，是对于其他对象的引 用\r\n> - 对象访问属性会触发[[Get]]操作，如果无法在本身找到需要的属性\r\n> 如果没有就要使用对象的 [[Prototype]] 链了\r\n> - 任何可以通过原型链访问到的属性都会被枚举\r\n> - 所有 普通 的 [[Prototype]] 链最终都会指向内置的 Object.prototype 。\r\n> - 属性的设置（例如赋值操作）\r\n>\r\n> \t- 属性不存在于原型链上层，新属性会被直接添加到对象上\r\n> \t- （普通访问属性）属性存在于原型链上层，创建（屏蔽属性）新属性\r\n> \t- 标记为只读( writable:false )属性存在于原型链上，不会进行赋值，不发生屏蔽\r\n> \t- 新属性在原型链上以setter 的形式纯在，调用 setter ，不添加新属性，不发生屏蔽\r\n>\r\n> ### “类”\r\n>\r\n> - JavaScript 中 只有 对象。\r\n> - “ 类 ” 函数\r\n>\r\n> \t- 所有的函数默认都会拥有一个 名为 prototype 的公有并且不可枚举的属性,它会指向另一个对象\r\n> \t- javascript 可以创建多个对象，并将他们关联到同一个原型\r\n> \t- function Foo(){...}; var a=new Foo();造成了a.[[prototype]]==Foo.prototype(实例与原型的关联)\r\n> \t- javascript 和传统的面向对象的继承不太一样，不会将“类”复制到“实例”中，而是通过原型链将他们关联起来\r\n>\r\n> - ”构造函数“\r\n>\r\n> \t- Foo.prototype 默认(在代码中第一行声明时!)有一个公有并且不可枚举的属性 .constructor\r\n> \t- 函数本身并不是构造函数，new 关键字，把函数变成“构造函数”\r\n>\r\n> - 技术\r\n>\r\n> \t- constructor 并不表示被构造\r\n> \t- Foo.prototype.constructor === Foo;    a.constructor === Foo\r\n>\r\n> ### （原型）继承\r\n>\r\n> - Object.create(..) 会凭空创建一个“新”对象并把新对象内部的 [[Prototype]] 关联到你指定的对象\r\n> - 通过.__proto__ 属性修改对象关联\r\n> - 判断对象是否委托关联某个函数，instanceof 操作符的左操作数是一个普通的对象,右操作数是一个函数\r\n>\r\n> ### 对象关联\r\n>\r\n> - [[Prototype]] 机制就是存在于对象中的一个内部链接, 它会引用其他 对象。\r\n> - var bar = Object.create( foo );  Object.create(..) 会创建一个新对象( bar )并把它关联到我们指定的对象( foo )\r\n\r\n## 数据类型\r\n\r\n> ### 类型\r\n>\r\n> - Undefined\r\n>\r\n> \t- 只有一个值：undefined，变量不需要显性设置为undefined值\r\n> \t- undefined 指没有值(missing value)，指从未赋值\r\n> \t- void 并不改变表达式的结果,只是让表达式不返回值\r\n> \t- undefined 是一个内置标识符 它的值为 undefined，通过 void 运算符即可得到该值\r\n> \t- 声明但未初始化的变量和未声明的变量都返回undefined\r\n>\r\n> - Null\r\n>\r\n> \t- 空对象指针，只有一个值null\r\n> \t- null 指空值(empty value)，指曾赋过值,但是目前没有值\r\n> \t- typeof 返回"object"，准备用于保存对象的变量初始化时最好为null\r\n> \t- undefined值派生自null值，undefined==null返回true\r\n>\r\n> - Boolean\r\n>\r\n> \t- 两个字面值true和false，ECMAScript中所有类型的值都有与这两个值等价的值\r\n> \t- 不同数据类型转换为Boolean\r\n>\r\n> \t\t- String类型：任何非空字符串可转换为true，""(空字符串)转换为false\r\n> \t\t- Number：任何非零数字值可转换为true，0和NaN转换为false\r\n> \t\t- Object：任何对象可转换为true，null转换为false\r\n> \t\t- Undefined：n/a（not applicable，“不适用”）可转换为true，undefined可转换为false\r\n>\r\n> - Number\r\n>\r\n> \t- 数字语法\r\n>\r\n> \t\t- 包括“整数”和带小数的十进制数\r\n> \t\t- 数字前后的 0 都可以省略\r\n> \t\t- 特别大和特别小的数字默认用指数格式显示\r\n> \t\t- tofixed(..) 方法可指定小数部分的显示位数\r\n> \t\t- toPrecision(..) 方法用来指定 有效数位 的显示位数\r\n> \t\t- 小数点是一种运算符，常见一种数字调用函数方式 42..tofixed(3)\r\n> \t\t- 数字常量还可以用其他格式来表示,如二进制、八进制和十六进制\r\n>\r\n> \t- 较小的数值\r\n>\r\n> \t\t- 0.1 + 0.2 === 0.3; // false\r\n> \t\t- 如何判断 0.1 + 0.2 的值是否和 0.3相等 \r\n> \t\t- 最常见的方法是设置一个误差范围值, 通常称为“机器精度”\r\n>\r\n> \t-  整数的安全范围\r\n>\r\n> \t\t- 能够被“安全”呈现的最大整数是 2^53 - 1\r\n> \t\t- 最小整数是 -（2^53 - 1）\r\n> \t\t- 需 要 处 理 一 些 比 较 大 的 数 字，（转存）保存成字符串\r\n>\r\n> \t- 整数检测\r\n>\r\n> \t\t- 使用 ES6 中的 Number.isInteger(..) 方法\r\n> \t\t- return typeof num == "number" && num % 1 == 0;\r\n> \t\t- 可以使用 ES6 中的 Number.isSafeInteger(..)\r\n> \t\t- return Number.isInteger( num ) && Math.abs( num ) <= Number.MAX_SAFE_INTEGER;\r\n>\r\n> \t- 32 位有符号整数\r\n>\r\n> \t\t- 是有些数字操作(如数位操作)只适用于 32 位数字\r\n>\r\n> \t- 整数\r\n>\r\n> \t\t- 进制表示格式\r\n>\r\n> \t\t\t- 十进制\r\n> \t\t\t- 八进制字面值第一位为0，然后是八进制数字序列（0~7）\r\n> \t\t\t- 十六进制前两位为0x，后面跟十六进制数字（0~f），字母大小写都可以\r\n>\r\n> \t\t- 进行算术计算时所有以八进制和十六进制表示的数值都将被转换为十进制\r\n>\r\n> \t- 浮点数值\r\n>\r\n> \t\t- 浮点数值必须有一个小数点，小数点后必须有至少一位小数，最高精度是17位小数\r\n> \t\t- e表示法（科学记数法）：3.125e7=3.125*10^7=31250000\r\n> \t\t- 浮点数值计算会产生舍入误差如0.1+0.2=0.30000000000000004不等于0.3，所以不要用特定浮点数值进行测试\r\n>\r\n> \t- NaN（非数值）\r\n>\r\n> \t\t- 表示一个本来要返回数值的操作数未返回数值的情况\r\n> \t\t- 任何涉及NaN的操作都会返回NaN，同时NaN与任何数值包括自身都不相等（NaN==NaN返回false）\r\n> \t\t- isNaN()函数：接收一个值后，尝试将其转换为数值。不能被转换为数值的值会导致这个函数返回true\r\n>\r\n> \t- 无穷数 Infinity\r\n> \t- 零值\r\n>\r\n> \t\t- JavaScript 有一个常规的 0 (也叫作 +0 )和一个 -0\r\n>\r\n> \t- 特殊等式\r\n>\r\n> \t\t- NaN 和自身不相等\r\n> \t\t- -0 等于 0\r\n> \t\t- ES6中新加入了一个工具方法 Object.is(..) 来判断两个值是否绝对相等\r\n>\r\n> \t- 数值转换函数\r\n>\r\n> \t\t- parseInt()\r\n> \t\t- Number()\r\n> \t\t- parseFloat()\r\n>\r\n> - String\r\n>\r\n> \t- 以引号（单双引号都可以但是要配对）表示\r\n> \t- 字符串一旦创建，值就不可变\r\n> \t- 字符串和数组的确很相似,它们都是类数组\r\n> \t- JavaScript 中字符串是不可变的, 而数组是可变的\r\n> \t- 通过“借用”数 组的非变更方法来处理字符串\r\n> \t- 转换为字符串\r\n>\r\n> \t\t- toString()方法，适用于数值、布尔值、对象和字符串值\r\n>\r\n> \t\t\t- 调用数值的toString()方法时可以传递一个参数，来输出以二进制、八进制等进制格式表示的字符串\r\n>\r\n> - 数组\r\n>\r\n> \t- 数组可以容纳任何类型的值\r\n> \t- 使用delete删除数组内容，但是数组的长度不会变化\r\n> \t- 字符串键值能够被强制类型转换为十进制数字的话,它 就会被当作数字索引来处理\r\n> \t- 有时需要将类数组转换为真正的数组\r\n>\r\n> - symbol（es6 新增）\r\n>\r\n> ### 引用类型（对象定义）\r\n>\r\n> - Object类型 \r\n>\r\n> \t- 创建方法\r\n>\r\n> \t\t- 使用new操作符跟Object构造函数\r\n>\r\n> \t\t\t- var person=new Object(); person.name="Nick"; person.age=29;\r\n>\r\n> \t\t- 对象字面量表示法\r\n>\r\n> \t\t\t- var person={ name: "Nick", age:29}; 花括号内可以为空，属性名可以使用字符串如"name": "Nick"\r\n>\r\n> \t- 对象的内容（属性）\r\n>\r\n> \t\t- 对象的内容（属性）\r\n> \t\t- 属性名永远都是字符串。\r\n> \t\t- 对象的“方法”：对函数的一种引用\r\n> \t\t- 复制对象\r\n>\r\n> \t\t\t- 深拷贝\r\n> \t\t\t- 浅拷贝\r\n>\r\n> \t\t- 属性描述符\r\n>\r\n> \t\t\t- writable (可写)\r\n> \t\t\t- enumerable (可枚举)\r\n> \t\t\t- configurable (可配置)\r\n>\r\n> \t\t-   [[Get]]\r\n>\r\n> \t\t\t-  myObject.a 在 myObject 上实际上是实现了 [[Get]] 操作\r\n>\r\n> \t\t-   [[Put]]\r\n>\r\n> \t\t\t- 并非在赋值的时候触发，具体逻辑在原型链里做分析\r\n>\r\n> \t\t- 使用 getter 和 setter 部分改写默认操作（运用在单个属性上）\r\n>\r\n> \t\t\t- getter 是一个隐藏函数,会在获取属性值时调用\r\n> \t\t\t- setter 也是一个隐藏 函数,会在设置属性值时调用\r\n>\r\n> \t\t- hasOwnProperty(..) 方法检查属性是否存在\r\n> \t\t- 不可变\r\n>\r\n> \t\t\t- Object.seal(..)\r\n> \t\t\t- Object.preventExtensions(..)\r\n> \t\t\t- Object.freeze(..)\r\n>\r\n> \t\t- 属性遍历\r\n>\r\n> \t- 访问方法\r\n>\r\n> \t\t- 点表示法 person.name\r\n> \t\t- 属性名中包含易导致语法错误的字符或使用变量时可以用方括号表示法 person["first name"]\r\n>\r\n> - Array类型\r\n>\r\n> \t- 数组的每一项可以保存任何类型的数据\r\n> \t- 创建方法\r\n>\r\n> \t\t- 使用Array构造函数\r\n>\r\n> \t\t\t- var colors= new Array(); new操作符可省略，可以给构造函数传递要保存的项目数量，该数量会自动成为length属性的值\r\n>\r\n> \t\t- 数组字面量表示法\r\n>\r\n> \t\t\t- var colors=["red", "blue", "green" ]\r\n>\r\n> \t- 数组的length属性可以修改，通过设置这个属性可以从数组末尾移除或添加项\r\n>\r\n> \t\t- 利用length属性的值也可以方便地添加新项，因为数组最后一项的索引始终是length-1\r\n> \t\t- var colors=["red", "blue", "green" ]; colors[colors.length]= "black"; colors[colors.length]= "brown";\r\n>\r\n> \t- 检测方法\r\n>\r\n> \t\t- Array.isArray()\r\n> \t\t- instanceof只适用于一个全局执行环境\r\n>\r\n> \t- 转换方法\r\n>\r\n> \t\t- toLocaleString()/toString()/valueOf()\r\n>\r\n> \t- 栈方法（Last-In-First-Out后进先出）\r\n>\r\n> \t\t- push()方法：接受任意数量的参数，逐个添加到数组末尾并返回修改后的数组长度\r\n> \t\t- pop()方法：从数组末尾移除最后一项，减少数组的length值并返回移除的项\r\n>\r\n> \t- 队列方法FIFO（先进先出）\r\n>\r\n> \t\t- shift()方法：移除数组中的第一个项，减少数组长度并返回移除的项\r\n> \t\t- shift()方法和push()方法合用可以像使用队列一样使用数组\r\n> \t\t- unshift()方法：在数组前端添加任意个项并返回数组的length\r\n> \t\t- unshift()方法与pop()方法合用可以从反方向模拟队列\r\n>\r\n> \t- 重排序方法\r\n>\r\n> \t\t- reverse()方法：反转数组项的顺序\r\n> \t\t- sort()方法：按升序排列数组项\r\n>\r\n> \t\t\t- 通过调用每个数组项的toString()方法来比较得到的字符串，很多情况下不符合要求\r\n> \t\t\t- 可以接收一个比较函数作为参数，方便指定数组项排序\r\n>\r\n> \t- 操作方法\r\n>\r\n> \t\t- contact()方法基于当前数组所有项创建一个新数组\r\n>\r\n> \t\t\t- var colors2=colors1.concat("yellow", ["black", "brown"]); 返回新构建的数组\r\n>\r\n> \t\t- slice()方法基于当前数组的一个或多个项创建一个新数组\r\n>\r\n> \t\t\t- var colors2=colors1.slice(1);一个参数情况下返回该参数指定位置到当前数组末尾所有项\r\n> \t\t\t-  var colors3=colors1.slice(1, 4); 两个参数情况下返回起始位置和结束位置之间的项，不包括结束位置的项\r\n>\r\n> \t\t- splice()方法\r\n>\r\n> \t\t\t- 删除\r\n>\r\n> \t\t\t\t- 指定2个参数：要删除的第一项的位置和要删除的项数，删除任意数量的项\r\n>\r\n> \t\t\t\t\t- .splice(1, 4);\r\n>\r\n> \t\t\t- 插入\r\n>\r\n> \t\t\t\t- 指定3个参数：起始位置、0（要删除的项数）、要插入的项\r\n>\r\n> \t\t\t\t\t- .splice(2, 0, "yellow", "orange");\r\n>\r\n> \t\t\t- 替换\r\n>\r\n> \t\t\t\t- 指定3个参数：起始位置、要删除的项数、要插入的项\r\n>\r\n> \t- 位置方法\r\n>\r\n> \t\t- indexOf()方法\r\n>\r\n> \t\t\t- 接收两个参数，分别表示要检索的项和索引起始位置\r\n>\r\n> \t\t- LastindexOf()方法\r\n>\r\n> \t\t\t- 同上\r\n>\r\n> \t- 迭代方法\r\n>\r\n> \t\t- every()\r\n> \t\t- filter()\r\n> \t\t- forEach()\r\n> \t\t- map()\r\n> \t\t- some()\r\n>\r\n> \t- 归并方法\r\n>\r\n> - Date类型\r\n>\r\n> \t- 创建方法\r\n>\r\n> \t\t- 使用new操作符和Date构造函数\r\n>\r\n> \t\t\t- var now= new Date();\r\n> \t\t\t- 传参数的方法\r\n>\r\n> \t\t\t\t- Date.parse()方法\r\n>\r\n> \t\t\t\t\t- 接受一个表示日期的字符串，尝试根据字符串返回相应日期的毫秒数，未定义支持的日期格式\r\n> \t\t\t\t\t- var someDate= new Date(Date.parse("May 25, 2004")); 如字符串不能表示日期，返回NaN\r\n> \t\t\t\t\t- var someDate=new Date("May 25, 2004);直接将表示日期的字符串传给Date函数会在后台直接调用Date.parse()方法\r\n>\r\n> \t\t\t\t- Date.UTC()方法\r\n>\r\n> \t\t\t\t\t- var someDate=new Date(Date.UTC(2005,4,5,17,55,55));\r\n> \t\t\t\t\t- 参数分别是年、月、日、小时、分钟、秒、毫秒等，其中月份从0开始\r\n> \t\t\t\t\t- 也可以直接将表示日期的字符串传给Date函数\r\n>\r\n> \t\t- Date.now()返回表示调用这个函数的日期和时间\r\n>\r\n> ### 值和类型\r\n>\r\n> - JavaScript 中的变量是没有类型的, 只有值才有\r\n> - 变量可以随时持有任何类型的值\r\n> - undefi ned 和 undeclared\r\n>\r\n> \t- 变量在未持有值的时候为 undefined\r\n> \t- 还没有在作用域中声明 过的变量,是 undeclared 的\r\n> \t- “undefined”和“is not defined”是两码事\r\n>\r\n> -   typeof  Undeclared\r\n>\r\n> \t- 会检查变量是否已被声明\r\n> \t- 访问不存在的对象属性不会产生 ReferenceError 错误\r\n\r\n## 原生函数\r\n\r\n> ### 常用的原生函数有\r\n>\r\n> - String()\r\n> - Number()\r\n> - Boolean()\r\n> - Array()\r\n> - Object()\r\n> - Function()\r\n> - RegExp()\r\n> - Date()\r\n> - Error()\r\n> - Symbol()——ES6 中新加入的!\r\n>\r\n> ### 内部属性[[class]]\r\n>\r\n> - 所有 typeof 返回值为 "object" 的对象(如数组)都包含一个内部属性 [[Class]]\r\n>\r\n> ### 封装对象包装\r\n>\r\n> - 基 本 类 型 值 没 有 .length 和 .toString() 这样的属性和方法,需要通过封装对象才能访问\r\n> - 封装对象释疑  !new Boolean( false ) //false\r\n>\r\n> ### 拆封\r\n>\r\n> - 如果想要得到封装对象中的基本类型值,可以使用 valueOf() 函数\r\n>\r\n> ### 原生函数作为构造函数\r\n>\r\n> -   Array(..)\r\n>\r\n> \t- Array 构造函数只带一个数字参数的时候,该参数会被作为数组的预设长度\r\n> \t- 包含至少一个“空单元”的数组称为“稀疏数组”\r\n> \t- 可以通过 delete b[1] 在数组 b 中制造出一个空单元\r\n> \t- 永远不要 创建和使用空单元数组\r\n>\r\n> - Object(..)、Function(..) 和 RegExp(..)\r\n>\r\n> \t- 尽量不要使用 Object(..) / Function(..) / RegExp(..)\r\n> \t- 使用 new Object() 来创建对象,必须逐一设置属性\r\n> \t- 构造函数 Function 只在极少数情况下很有用,比如动态定义函数参数和函数体的时候\r\n> \t- 强烈建议使用常量形式(如 /^a*b+/g )来定义正则表达式\r\n>\r\n> - Date(..) 和 Error(..)\r\n>\r\n> \t- Date(..) 可以带参数,用来指定日期和时间,而不带 参数的话则使用当前的日期和时间。\r\n> \t- 创建错误对象(error object)主要是为了获得当前运行栈的上下文\r\n>\r\n> - Symbol(..)\r\n>\r\n> \t- 符号是具有唯一性的特殊值(并 非绝对),用它来命名对象属性不容易导致重名\r\n> \t- 不能带 new 关键 字,否则会出错:\r\n>\r\n> - 原生原型\r\n>\r\n> \t- 原生构造函数有自己的 .prototype 对象,如 Array.prototype 、 String.prototype 等\r\n> \t- 将原型作为默认值，例如：, RegExp.prototype 是一个“空”的正则表达式\r\n\r\n## 强制类型转换\r\n\r\n> ### 值类型转换\r\n>\r\n> - 将值从一种类型转换为另一种类型通常称为 类型转换（显示）\r\n>\r\n> \t- 类型转换发生在静态类型语言的编译阶段\r\n>\r\n> - 隐式的情况称为 强制类型转换\r\n>\r\n> \t- 强制类型转换则发生在动态类型语言的运行时\r\n>\r\n> ### 抽象值操作\r\n>\r\n> - ToString\r\n>\r\n> \t- 它负责处理非字符串到字符串的强制类型转换\r\n> \t- 对普通对象来说, 除非自行定义, 否则 toString() ( Object.prototype.toString() )返回 内部 属性 [[Class]] 的值\r\n> \t- 数组的默认 toString() 方法经过了重新定义, 将所有单元字符串化以后再用 "," 连接起 来\r\n> \t- 工具函数 JSON.stringify(..) 在将JSON对象序列化为字符串时也用到了 ToString\r\n> \t- JSON.stringify(..) 在对象中遇到 undefined 、 function 和 symbol 时会自动将其忽略，在数组中则返回 null\r\n> \t- toJSON() 应该“返回一个能够被字符串化的安全的 JSON 值”, 而不是“返回 一个 JSON 字符串”\r\n> \t- 字符串、数字、布尔值和 null 的 JSON.stringify(..) 规则与 ToString 基本相同\r\n> \t- 如果传递给 JSON.stringify(..) 的对象中定义了 toJSON() 方法, 那么该方法会在字符 串化前调用,以便将对象转换为安全的 JSON 值\r\n>\r\n> - ToNumber\r\n>\r\n> \t- 对象(包括数组)会首先被转换为相应的基本类型值\r\n> \t- 处理失败 时返回 NaN\r\n> \t- 检查该值是否有 valueOf() 方法\r\n>\r\n> \t\t- 如果有\r\n>\r\n> \t\t\t- 使用该值进行强制类型转换\r\n>\r\n> \t\t- 如果没有\r\n>\r\n> \t\t\t- 使用 toString() 的返回值(如果存在)来进行强制类型转换。\r\n>\r\n> - ToBoolean\r\n>\r\n> \t- 可以被强制类型转换为 false 的值\r\n> \t- 其他(被强制类型转换为 true 的值)\r\n> \t- 假值\r\n>\r\n> \t\t- undefined\r\n> \t\t- null\r\n> \t\t- false\r\n> \t\t- +0、-0和 NaN\r\n> \t\t- “ ”\r\n>\r\n> \t- 假值对象\r\n>\r\n> \t\t- document.all \r\n>\r\n> \t- 真值\r\n>\r\n> \t\t- 假值列表之外的值\r\n>\r\n> ### 显式强制类型转换\r\n>\r\n> - 字符串和数字之间转换\r\n>\r\n> \t- 日期显式转换为数字\r\n>\r\n> \t\t- +new Date();\r\n>\r\n> \t- 奇特的 ~ 运算符\r\n>\r\n> \t\t- 字位运算符(如 | 和 ~ )和某些特殊数字一起使用时会产生\r\n> 类似强制类型转换的效果\r\n>\r\n> \t- 字位截除\r\n>\r\n> \t\t- 使用 ~~ 来截除数字值的小数部分\r\n>\r\n> - 显式解析数字字符串\r\n>\r\n> \t- 解析非字符串\r\n>\r\n> \t\t- parseInt(..) 会根据字符串的第一个字符来自行决定基数\r\n>\r\n> - 显式转换为布尔值\r\n>\r\n> \t- 三元运算符\r\n> \t- if 判断\r\n> \t- ！！强制转换\r\n>\r\n> ### 隐式强制类型转换\r\n>\r\n> - 隐式地简化\r\n>\r\n> \t- 隐式强制类 型转换同样可以用来提高代码可读性\r\n>\r\n> - 字符串和数字之间的隐式强制类型转换\r\n>\r\n> \t- 根据 ToPrimitive 抽象操作规则, a + "" 会对 a 调用 valueOf() 方法,然后通过 ToString 抽象 操作将返回值转换为字符串\r\n> \t- - 是数字减法运算符,因此 “3.14” - 0 会将 “3.14” 强制类型转换为数字。\r\n>\r\n> - 布尔值到数字的隐式强制类型转换\r\n>\r\n> \t- 复杂的布尔逻辑转换为数字加法\r\n>\r\n> -  隐式强制类型转换为布尔值\r\n>\r\n> \t- if (..)\r\n> \t- for ( .. ; .. ; .. )\r\n> \t- while (..) 和 do..while(..)\r\n> \t- ? :\r\n> \t- 逻辑运算符 || (逻辑或)和 && (逻辑与)左边的操作数\r\n>\r\n> - || 和 &&\r\n> - 符号的强制类型转换\r\n>\r\n> \t- 从符号到字符串的 显式 强制类型转换,然而 隐式 强制类型转换会产生错误\r\n\r\n### 宽松相等和严格相等\r\n\r\n> - == 允许在相等比较中进行强制类型转换,而 === 不允许\r\n> - 相等比较操作的性能\r\n>\r\n> \t- 然强制类型转换确实要多花点时间, 但仅仅是微秒级 (百万分之一秒)的差别而已\r\n>\r\n> - 抽象相等\r\n>\r\n> \t- NaN 不等于NaN\r\n> \t- +0 等于-0\r\n> \t- == 在比较两个不同类型的值时会发生 隐式 强制类型转换\r\n> \t- true 和 false 与其他类型之间的相等比较\r\n> \t- == 对不同的类型组合处理方式不同 \r\n> \t- 在 == 中 null 和 undefined 相等\r\n> \t- 对象和非对象之间的相等比较\r\n>\r\n> \t\t- 对对象调用 ToPromitive 抽象操作，拆分封装对象\r\n>\r\n> -  比较少见的情况\r\n>\r\n> \t- 返回其他数字\r\n> \t- 假值的相等比较\r\n> \t- 极端情况\r\n> \t- 完整性检查\r\n> \t- 安全运用隐式强制类型转换\r\n>\r\n> ### 抽象关系比较\r\n>\r\n> - 比较双方都是字符串\r\n>\r\n> \t- 则按字母顺序来进行比较\r\n>\r\n> - 和其他情况\r\n>\r\n> \t- 比较双方首先调用 ToPrimitive ,如果结果出现非字符串,就根据 ToNumber 规则将双方强 制类型转换为数字来进行比较。\r\n>\r\n> - 相等比较有严格相等,关系比较却没有“严格关系比较”\r\n\r\n## 语法\r\n\r\n> ### 语句和表达式\r\n>\r\n> - 语句相当于句子, 表达式相当于短语\r\n> - var b = a 称为“声明语句”\r\n> - b = a (不带 var )叫作“赋值表达式”\r\n> - 语句的结果值\r\n>\r\n> \t- 在控制台中输入 var a = 42 会得到结果值 undefined\r\n> \t- 代码中是没有办法获得这个结果值\r\n> \t- 代码块，返回最后一条语句的结果值\r\n> \t- 多个赋值语句串联时 ,赋值表达式(和语句)的结果值就 能派上用场\r\n>\r\n> - 表达式副作用\r\n>\r\n> \t- 递增运算符 ++ 和递减运算符 -- 都是一元运算符\r\n> \t- ++a++ 会产生 ReferenceError 错误, 因为运算符需要将产生的副作用赋值给 一个变量\r\n>\r\n> - 上下文规则\r\n>\r\n> \t- 大括号\r\n> \t- 代码块\r\n> \t- 对象解构\r\n> \t- else if 和可选代码块\r\n>\r\n> ### 运算符优先级\r\n>\r\n> - 短路\r\n>\r\n> \t- && 和 || 运算符的“短路”\r\n> \t- 如果从左边的操作数能够得出结果,就可以忽略右边的操作数\r\n>\r\n> - 更强的绑定\r\n>\r\n> \t- a && b || c ? c || b ? a : c && b : a\r\n>\r\n> - 关联\r\n> - 释疑\r\n>\r\n> \t- 编写程序时要将两者结合起来,既要依赖运算符 优先级 关联规则\r\n> \t- 也要适当使用 ( ) 自行控制方式\r\n>\r\n> ### 自动分号\r\n>\r\n> - 有时 JavaScript 会自动为代码行补上缺失的分号, 即自动分号插入\r\n> - , ASI 只在换行符处起作用,而不会在代码行的中间插入分号\r\n> - ASI 实际上是一个“纠错”(error correction)机制\r\n> - 建议在所有需要的地方加上分号,将对 ASI  的依赖降到最低\r\n>\r\n> ### 错误\r\n>\r\n> - 在编译阶段发现的代码错误叫作“早期错误”\r\n> - 这些错误在代码执行之前是无法用 try..catch 来捕获的，还会导致解析/编译 失败。\r\n> - 非法正则产生早期错误\r\n> - 语法规定赋值对象必须是一个标识符\r\n> - 严格模式中,函数的参数不能重名\r\n> - ES6 规范定义了一个新概念,暂时性死区\r\n>\r\n> ### 函数参数\r\n>\r\n> - 在 ES6 中,如果参数被省略或者值为 undefined ,则取该参数的默认值\r\n> - 如果向参数传递 undefined ，会出现一个undefined 单元，而不是默认值\r\n> - 向函数传递参数时, arguments 数组中的对应单元会和命名参数建立关联\r\n>\r\n> ### try..finally\r\n>\r\n> - finally 中的代码总是会在 try 之后执行,如果有 catch 的话则在 catch 之后执行\r\n> - try 中的 return ，函数执行完毕后悔将函数的返回值设置为 return 的值\r\n> - 如果 finally 中抛出异常(无论是有意还是无意),函数就会在此处终止\r\n>\r\n> ###   switch\r\n>\r\n> - 可以把它看作 if..else if..else.. 的简化版本\r\n\r\n## 回调\r\n\r\n> ### 　continuation\r\n>\r\n> - 回调函数包裹或者说封装了程序的延续（continuation）\r\n> - 代码变得更加难以理解、追踪、调试和维护\r\n>\r\n> ### 顺序的大脑\r\n>\r\n> - 并行执行多个任务时，实际上极有可能是在进行快速的上下文切换\r\n> - 异步事件并发机制很相似\r\n> - JavaScript 程序中总是有很多噪声，使得代码更加杂乱回调地狱理解起来很难\r\n> - 顺序阻塞式的大脑计划行为无法很好地映射到面向回调的异步代码\r\n>\r\n> ### 信任问题\r\n>\r\n> - 控制反转 （inversion of control），也就是把自己程序一部分的执行控制交给某个第三方\r\n> - 对于被传给你无法信任的工具的每个回调，你都将不得不创建大量的混乱逻辑\r\n> - 回调最大的问题是控制反转，它会导致信任链的完全断裂\r\n> - 没有应用某种逻辑来解决所有这些控制反转导致的信任问题\r\n> 那你的代码现在已经有了 bug\r\n>\r\n> ### 省点回调\r\n>\r\n> - 为了更优雅地处理错误，有些 API 设计提供了分离回调 \r\n> - 回调可以实现你想要的功能，但是要付出很多努力，代码也会变得笨重\r\n\r\n## ajax\r\n\r\n### Ajax\r\n\r\n> - 请求\r\n>\r\n> \t- 流程\r\n>\r\n> \t\t- 1.创建浏览器内置的对象 XMLHttpRequest\r\n> \t\t- 2.调用xhr对象的open方法，设置请求方式和请求的url\r\n> \t\t- 3.调用xhr对象的send方法，向服务器发送请求\r\n> \t\t- 4.当请求响应整个过程结束，然后接收服务器响应的结果（返回的数据）\r\n>\r\n> \t\t\t- 使用xhr的response属性来接收服务器响应的结果\r\n>\r\n> \t- 方式\r\n>\r\n> \t\t- get\r\n>\r\n> \t\t\t- 说明：一般用户从服务器获取数据\r\n> \t\t\t- 参数：需要在设置url的时候将参数传递\r\n>\r\n> \t\t\t\t- 例子：?nam=xxx&sex=yyy\r\n>\r\n> \t\t\t- 缓存：\r\n>\r\n> \t\t\t\t- 说明：在get的请求方式下，IE浏览器会出现缓存现象\r\n> \t\t\t\t- 解决办法：接收动态参数\r\n>\r\n> \t\t- post\r\n>\r\n> \t\t\t- 说明：把数据提交给服务器\r\n> \t\t\t- 参数：需要在send发送请求处添加参数\r\n>\r\n> \t\t\t\t- 例子：xhr.send(\'name=zhangsan&age=18\')\r\n>\r\n> \t\t\t- 注意：\r\n>\r\n> \t\t\t\t- post会比get请求多一行代码：xhr.setRequestHeader(\'Content-Type\', \'application/x-www-form-urlencoded\')\r\n>\r\n> - 响应数据格式\r\n>\r\n> \t- JSON\r\n>\r\n> \t\t- 本质：字符串\r\n> \t\t- 注意点：\r\n>\r\n> \t\t\t- 1.JSON 中属性名称必须用“双引号”包裹\r\n> \t\t\t- 2.JSON 中表述字符串（值）必须使用双引号\r\n> \t\t\t- 3.JSON 中不能有注释\r\n> \t\t\t- 4.JSON 没有 undefined 这个值\r\n>\r\n> \t- XML\r\n>\r\n> \t\t-  可扩展标记语言\r\n>\r\n> \t\t\t- 1.只有一个根标签\r\n> \t\t\t- 2.区分大小写\r\n> \t\t\t- 3.标签必须闭合\r\n> \t\t\t- 4.属性值必须加引号\r\n>\r\n> \t- HTML\r\n>\r\n> \t\t- 超文本标记语言\r\n>\r\n> - 模板引擎\r\n>\r\n> \t- 使用的原因：可以更容易更高效的将数据渲染到HTML字符串中\r\n> \t- 使用步骤：\r\n>\r\n> \t\t- 1.引入template-web.js文件\r\n> \t\t- 2.定义模板，一定要指定script的id和type属性\r\n> \t\t- 3.调用template函数，为模板分配数据，template函数有两个参数一个返回值\r\n> \t1）. 参数1：模板的id\r\n> \t2）. 参数2：分配的数据，必须是一个JS对象的形式\r\n> \t3）. 一个返回值：是数据和模板标签组合好的结果\r\n>\r\n> \t- 调用方式：\r\n>\r\n> \t\t- 普通流：var\r\n> \t\t- 条件：if age > 18\r\n> \t\t- 循环：each arr\r\n>\r\n> - 异步&同步\r\n>\r\n> \t- 同步\r\n>\r\n> \t\t- 例：一个人在同一个时刻只能做一件事情，在执行一些耗时的操作的时候，不能去做别的事，只是等待\r\n>\r\n> \t- 异步\r\n>\r\n> \t\t- 例：在执行一些耗时的操作的时候，同时去做别的事，而不是等待\r\n>\r\n> \t- xhr.open（请求参数，请求url，boolean） \r\n>\r\n> \t\t- 第三个参数即为false同步，true异步（默认）\r\n>\r\n> - XHR对象其他API\r\n>\r\n> \t- 1.readyState\r\n>\r\n> \t\t- 状态 xhr.readyState\r\n>\r\n> \t\t\t- 0\r\n>\r\n> \t\t\t\t- 代理（XHR）被创建，但尚未调用 `open()` 方法。\r\n>\r\n> \t\t\t- 1\r\n>\r\n> \t\t\t\t- open()` 方法已经被调用，建立了连接。\r\n>\r\n> \t\t\t- 2\r\n>\r\n> \t\t\t\t- send()` 方法已经被调用，并且已经可以获取状态行和响应头。\r\n>\r\n> \t\t\t- 3\r\n>\r\n> \t\t\t\t- 响应体（服务器返回的数据）下载中， `responseText` 属性可能已经包含部分数据。\r\n>\r\n> \t\t\t- 4\r\n>\r\n> \t\t\t\t- 响应体（服务器返回的数据）下载完成，可以直接使用 `responseText`或response 获取完整的结果。\r\n>\r\n> \t- 2.onreadystatechange\r\n>\r\n> \t\t- 1.每当XHR对象的状态发生变化的时候，就会触发这个事件\r\n> \t\t- 2.xhr对象分块接收数据\r\n>\r\n> \t- 3.progress( 过程，进度)\r\n>\r\n> \t\t- 1.onload -- 当readyState等于4的时候触发。只有请求成功了才触发。\r\n> \t\t- 2.onprogress -- 当readyState等于3的时候触发（数据正在返回途中的时候触发）\r\n> \t\t- 3.onloadstart() -- 当开始发送请求的时候触发，要放到send之前\r\n> \t\t- 4.onloadend() -- 当请求响应过程结束的时候触发。无论成功还是失败都会触发。\r\n>\r\n> \t- XHR对象的兼容方案\r\n>\r\n> \t\t- 解释：XMLHttpRequest 在老版本浏览器（IE5/6）中有兼容问题\r\n> \t\t- 书写：var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(\'Microsoft.XMLHTTP\')\r\n>\r\n> \t- responseType\r\n>\r\n> \t\t- 1.“”  -- 空，表示文本，\r\n> \t\t- 2.text -- 文本\r\n> \t\t- 3.json -- JSON格式数据\r\n> \t\t- 4.document -- 文档对象\r\n>\r\n> - jQuery封装\r\n>\r\n> \t- 格式：\r\n>\r\n> \t\t-     $.ajax({\r\n>      type: \'GET\', // 请求方式\r\n>      url: \'/query-get\',\r\n>      data: {id: 333, age: 666, name: \'zs\'}, // 发送给接口的数据，可以写成对象，jQuery内部会自动将对象转成字符串\r\n>     dataType: \'json\', // 如同 responseType。\r\n>     success: function (res) {\r\n>         console.log(res);\r\n>     }\r\n> });\r\n>\r\n> \t- 常用参数：\r\n>\r\n> \t\t- cache: 设置ie浏览器的缓存问题， cache: false 不缓存\r\n> \t\t- url：请求地址\r\n> \t\t- type：请求方法，默认为 `get\r\n> \t\t- dataType：预期服务端响应数据类型\r\n> \t\t- contentType：请求体内容类型，如果是POST请求，默认 `application/x-www-form-urlencoded\r\n> \t\t- data：（object|string）传递到服务端的数据\r\n> \t\t- timeout：请求超时时间\r\n> \t\t- beforeSend：请求发起之前触发\r\n> \t\t- complete：请求完成触发（不管成功与否）\r\n> \t\t- success：请求成功之后触发（响应状态码 200）\r\n> \t\t- error：请求失败触发\r\n> \t\t- processData：是否让jQuery帮我们将发送给服务器的数据进行处理（默认：true表示将对象处理成字符串）\r\n>\r\n> \t- 快捷方法\r\n>\r\n> \t\t- $.get(url, [data], [callback], [dataType])\r\n> \t\t- $.post(url, [data], [callback], [dataType])\r\n>\r\n> \t- 全局事件处理\r\n>\r\n> \t\t- 语法：\r\n>\r\n> \t\t\t- $.ajaxSetup({事件: 处理函数, 事件:处理函数, ...});\r\n>\r\n> \t\t- 示例\r\n>\r\n> \t\t\t- // 设置全局事件处理\r\n> $.ajaxSetup({\r\n>     // 设置发送请求前的事件\r\n>     beforeSend: function () {\r\n>         // 这里可以提示，玩命加载中...\r\n>     },\r\n>     // 设置完全接收响应数据后的事件\r\n>     complete: function () {\r\n>         // 这里可以去掉“玩命加载中...”\r\n>     }\r\n> });\r\n>\r\n> - FormData对象\r\n>\r\n> \t- 说明：主要用于表单发送数据\r\n> \t- 使用方式：\r\n>\r\n> \t\t- 例如：var form = $(\'form\').get(0);\r\n>           var fd = new FormData(form);\r\n>\r\n> \t- 注意事项：\r\n>\r\n> \t\t- 使用FormData的时候，form表单中的各项必须有name属性。没有name属性是收集不到数据的\r\n>\r\n> - 补充知识点：\r\n>\r\n> \t- 1.?id=457 问怎么可以拿到457\r\n>    答：str.replace(/\\D/g,""); 使用正则将非数字剔除掉\r\n> \t- 2.location.search  返回/设置当前的url的查询部分\r\n> \t- 3.confirm（“你确定么”） 返回boolean\r\n> \t- 4.console.log（）会在浏览器控制台打印出信息\r\n>    console.dir（）可以显示一个对象所有的方法和属性\r\n\r\n## 一些容易混淆的小概念\r\n\r\n> ### undefined 与 not defined\r\n>\r\n> - 例子\r\n>\r\n> \t- 在c语言里面，会去严格区分声明(declared)和定义(defined),而在JS里，is not defined却会让人误以为是声明了没有定义的变量，但是实际上，却是没有声明，这个地方用ReferenceError: b is not declared\r\n>\r\n> - 理解\r\n>\r\n> \t- 某开发者想要声明两个变量，一个值类型为number的A,一个值类型为string的B，他在程序里写了\r\n>\r\n> \t- 这个时候实际上就是变量A去\'继承\'了type为\'undefined\'的值，B没有声明,现在就不知道继承哪种值，称为undeclared\r\n>\r\n> \t- 这个时候这位开发者写入\r\n>\r\n> \t- 那么就变成了\r\n>\r\n> \t- 所以此时typeof A会得到’number’，B目前存在于开发者的脑子里，所以为undeclared\r\n>\r\n> ### 为什么[] == ![]为true？\r\n>\r\n> - （1）首先![] 转换为false，此时比较[] == false\r\n> - （2）[]是对象，false转换为number，就是0，此时比较[] == 0;\r\n> - （3）[] == 0将[]转换为字符串，就是"" == 0，然后""转换为字符串，就是0 == 0，即最终为true\r\n> - == 的转换机制，先调用valueof，不行再调用toString\r\n>\r\n> ### 手写原生Ajax请求\r\n>\r\n> - Ajax请求\r\n>\r\n> \t- 在这里， 我们创建了一个能向服务器发出 HTTP 请求的类的实例。然后调用其 open 方法，其中第一个参数是 HTTP 请求方法，第二个参数是请求页面的 URL。第三个参数是true（异步）或 false（同步）；最后，我们调用参数为 null 的 send 方法。假如使用 POST 请求方法（这里我们使用了 GET），那么 send 方法 的参数应该包含任何你想发送的数据。\r\n>\r\n> - 处理响应\r\n>\r\n> ### Object.create 的模拟实现\r\n>\r\n> - 将传入的对象作为创建的对象的原型\r\n> - 详解Object.create(null)\r\n>\r\n> \t- Object.create()的定义\r\n>\r\n> \t\t- Object.create(proto,[propertiesObject])\r\n> \t\t- proto:新创建对象的原型对象\r\n> \t\t- propertiesObject:可选。要添加到新对象的可枚举（新添加的属性是其自身的属性，而不是其原型链上的属性）的属性。\r\n>\r\n> \t- Object.creat()的使用\r\n>\r\n> \t- Object.create()、{…}的区别\r\n>\r\n> \t\t- 先看看我们经常使用的{}创建的对象是什么样子的\r\n>\r\n> \t\t\t- 在chrome控制台打印如下\r\n>\r\n> \t\t\t- 新创建的对象继承了Object自身的方法，如hasOwnProperty、toString等，在新对象上可以直接使用。\r\n>\r\n> \t\t- 再看看使用Object.create()创建对象\r\n>\r\n> \t\t\t- Object.creat(null)\r\n>\r\n> \t\t\t\t- 在chrome控制台打印如下\r\n>\r\n> \t\t\t\t- 新创建的对象除了自身属性a之外，原型链上没有任何属性，也就是没有继承Object的任何东西，此时如果我们调用o.toString()会报Uncaught TypeError的错误。\r\n>\r\n> \t\t\t- Object.creat({})\r\n>\r\n> \t\t\t\t- 在chrome控制台打印如下\r\n>\r\n> \t\t\t\t- 这样创建的对象和使用{}创建对象已经很相近了，但是还是有一点区别：多了一层proto嵌套。\r\n>\r\n> \t\t\t-  Object.create(Object.prototype)\r\n>\r\n> \t\t\t\t- chrome控制台打印如下\r\n>\r\n> \t- Object.create(null)的使用场景\r\n>\r\n> \t\t- 进一步比较一下Object.create(null)和{}创建控对象的区别\r\n>\r\n> \t\t- 使用场景\r\n>\r\n> \t\t\t- 使用create创建的对象，没有任何属性，显示No properties，我们可以把它当作一个非常纯净的map来使用，我们可以自己定义hasOwnProperty、toString方法，不管是有意还是不小心，我们完全不必担心会将原型链上的同名方法覆盖掉。\r\n>\r\n> \t\t- 举个例子\r\n>\r\n> \t\t- 另一个使用create(null)的理由是，在我们使用for..in循环的时候会遍历对象原型链上的属性，使用create(null)就不必再对属性进行检查了，当然，我们也可以直接使用Object.keys[]。\r\n>\r\n> \t- 总结\r\n>\r\n> \t\t- 你需要一个非常干净且高度可定制的对象当作数据字典的时候；\r\n> \t\t- 想节省hasOwnProperty带来的一丢丢性能损失并且可以偷懒少些一点代码的时候\r\n> \t\t- 其他时候，请用{}\r\n>\r\n> ### New 关键字的内部实现\r\n>\r\n> - 当我们使用 new 操作符时，生成的实例对象拥有了 _proto_属性。在 new 的过程中，新对象被添加了 _proto_ 并且链接到构造函数的原型上。\r\n>\r\n> - New()的过程\r\n>\r\n> \t- （1）新生成了一个对象\r\n> \t- （2）链接到原型\r\n> \t- （3）绑定 this\r\n> \t- （4）返回新对象\r\n>\r\n> - New()的实现\r\n>\r\n> \t- 最初版\r\n>\r\n> \t\t- 代码\r\n>\r\n> \t\t- 理解\r\n>\r\n> \t\t\t- （1）用new Object() 的方式新建了一个对象 obj\r\n> \t\t\t- （2）取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数\r\n> \t\t\t- （3）将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性\r\n> \t\t\t- （4）使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性\r\n> \t\t\t- （5）返回 obj\r\n>\r\n> \t- 完整版\r\n>\r\n> \t\t- 起源\r\n>\r\n> \t\t\t- 如果构造函数有返回值\r\n>\r\n> \t\t\t\t- 返回值是对象\r\n>\r\n> \t\t\t\t\t- 构造函数返回了一个对象，在实例 person 中只能访问返回的对象中的属性。\r\n>\r\n> \t\t\t\t- 返回值是基本类型\r\n>\r\n> \t\t\t\t\t- 结果完全颠倒过来，这次尽管有返回值，但是相当于没有返回值进行处理。\r\n>\r\n> \t\t- 还需要判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么。\r\n>\r\n> ### js 中的 !! 与 ~~\r\n>\r\n> - !!\r\n>\r\n> \t- 将操作数转化为布尔类型。\r\n>\r\n> \t- 实际上等效于 Boolean 被当做函数调用的效果\r\n>\r\n> - ~~\r\n>\r\n> \t- 将操作数转化为 32 位有符号整数。\r\n>\r\n> \t- 如果你需要将一个参数转化为 32 位有符号整数，那么 ~~ 将是最简便的方式。不过要切记，它会损失精度，包括小数和整数部分。\r\n> \t- 按位非操作符~\r\n>\r\n> \t\t- 作用是将数值比特位中的 1 变成 0，0 变成 1。\r\n',br={data:function(){return{MainComponent:gr}}},hr=br,yr=Object(m["a"])(hr,mr,dr,!1,null,"79d73b6a",null),fr=yr.exports,vr=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},Sr=[],_r="# js2\r\n\r\n## JavaScript 高级\r\n\r\n### 编程思想：\r\n\r\n- 面向过程：\r\n\r\n\t- 什么是面向过程？\r\n\r\n\t\t- 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了\r\n\r\n\t- 优缺点：\r\n\r\n\t\t- 优点：性能比面向对象高，步骤练习紧密\r\n\t\t- 缺点：不好维护，不易多次使用及扩展\r\n\r\n- 面向对象：\r\n\r\n\t- 什么是面向对象？\r\n\r\n\t\t- 面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作\r\n\r\n\t- 三大特性：\r\n\r\n\t\t- 1.封装性\r\n\t\t- 2.继承性\r\n\t\t- 3.多态性\r\n\r\n\t- 优缺点：\r\n\r\n\t\t- 优点：易维护，可复用，可扩展，灵活性高\r\n\t\t- 缺点：性能没有面向过程高\r\n\r\n### 类和对象\r\n\r\n- ES6\r\n\r\n\t- 对象\r\n\r\n\t\t- 什么是对象？\r\n\r\n\t\t\t- 对象是具体的\r\n\r\n\t- 类\r\n\r\n\t\t- 什么是类？\r\n\r\n\t\t\t- 类模拟抽象的，泛指的\r\n\r\n\t\t- 创建类\r\n\r\n\t\t\t- 例：class 类名 {\r\n                                                }      类名首字母要大些\r\n\r\n\t\t- constructor构造函数\r\n\r\n\t\t\t- 例：class Star {\r\n\tconstructor (uname,age){\r\n\t\tthis.uname = uname;\r\n\t\tthis.age = age;\r\n\t}\r\n}\r\n\r\n\t\t\t\t- 注意：1.类里面的方法不带function，直接写既可\r\n\t\t\t\t- 2.类中定义属性，调用方法都得用this\r\n\t\t\t\t- 3.方法之间不能加逗号分隔\r\n\r\n\t\t- 继承：\r\n\r\n\t\t\t- extends\r\n\r\n\t\t- super关键字：\r\n\r\n\t\t\t- 用于访问和调用对象父类上的函数\r\n\r\n\t\t\t\t- 注意：子类在构造函数中使用super, 必须放到this 前面(必须先调用父类的构造方法,在使用子类构造方法）\r\n\r\n\t\t- 三个比较重要的注意点：\r\n\r\n\t\t\t- 在ES6中类没有变量提升，所以必须先定义类，才能通过类实例化对象.\r\n\t\t\t- 类里面的共有属性和方法一定要加this使用.\r\n\t\t\t- this指向的问题\r\n\r\n\t\t\t\t- 方法里面的this，谁调用，this就代表谁\r\n\t\t\t\t- 构造方法里面的this，代表当前实例对象\r\n\r\n- ES5\r\n\r\n\t- 成员\r\n\r\n\t\t- 1.静态成员\r\n\r\n\t\t\t- 不需要实例对象调用属性（不需要new）\r\n\r\n\t\t- 2.实例成员\r\n\r\n\t\t\t- 需要实例对象调用属性（需要new）\r\n\r\n\t- 构造函数原型（prototype 原型对象-构造函数的一个属性）\r\n\r\n\t\t- 1.所有的属性都要写在构造函数里面\r\n\t\t- 2.所有的方法都要写在原型对象里面\r\n\r\n\t- 对象原型:简称“原型”（__proto__）\r\n\r\n\t\t- 1.每一个对象都有一个原型\r\n\t\t- 2.作用是指向原型对象prototype\r\n\r\n\t- 构造函数 constructor\r\n\r\n\t\t- 作用：指回原来的构造函数\r\n\r\n\t- 继承：\r\n\r\n\t\t- 属性继承\r\n\r\n\t\t\t- call(this,m,n)-------m,n为不确定参数，参数个数可变\r\n\r\n\t\t- 方法继承\r\n\r\n\t\t\t- 原理：1.子类的原型对象 《=》父类的实例对象\r\n\t\t\t- 2.继承完毕之后，子类的constructor的指向已经不见，需要将子类的custructor手动指回\r\n\r\n### 函数\r\n\r\n- 声明方式\r\n\r\n\t- 1.命名函数\r\n\r\n\t\t- function fn（）{}\r\n\r\n\t- 2.匿名函数\r\n\r\n\t\t- var fn = function(){}\r\n\r\n\t- 3.new function函数\r\n\r\n\t\t- var fn = new Function('a', 'b', 'console.log(a + b)')\r\n\r\n- 调用：\r\n\r\n\t- 1.普通函数\r\n\r\n\t\t- function fn() {\r\n\tconsole.log('人生的巅峰');\r\n}\r\nfn();\r\n\r\n\t- 2.对象的方法\r\n\r\n\t\t- var o = {\r\n  sayHi: function() {\r\n  \tconsole.log('人生的巅峰');\r\n  }\r\n}\r\no.sayHi();\r\n\r\n\t- 3.构造函数\r\n\r\n\t\t- function Star() {};\r\nnew Star();\r\n\r\n\t- 4.绑定事件函数\r\n\r\n\t\t- btn.onclick = function(){}\r\n\r\n\t- 5.定时器函数\r\n\r\n\t\t- setInterval(function() {}, 1000); \r\n\r\n\t\t\t- 注意：非定时器的代码要快于定时器代码（即使定时器代码时间为0）\r\n\r\n\t- 6.立即执行函数(自调用函数)\r\n\r\n\t\t- (function (){\r\n\tconsole.log('自调函数');\r\n})();\r\n\r\n- this\r\n\r\n\t- 指向\r\n\r\n\t\t- 1.普通函数\r\n\r\n\t\t\t- window\r\n\r\n\t\t- 2.对象函数\r\n\r\n\t\t\t- 该方法所属的对象\r\n\r\n\t\t- 3.构造函数\r\n\r\n\t\t\t- new出来的实例对象\r\n\r\n\t\t- 4.绑定事件函数\r\n\r\n\t\t\t- 事件源，绑定时间对象\r\n\r\n\t\t- 5.定时器函数\r\n\r\n\t\t\t- window\r\n\r\n\t\t- 6.立即执行函数（自调用函数）\r\n\r\n\t\t\t- window\r\n\r\n\t- 改变指向\r\n\r\n\t\t- 1.call（this，m，n…………）\r\n\r\n\t\t\t- 参数:\r\n\r\n\t\t\t\t- 参数使用，逗号分隔开\r\n\r\n\t\t\t- 应用场景:\r\n\r\n\t\t\t\t- 父子继承上面\r\n\r\n\t\t- 2.apply（this，[m，n…………]）\r\n\r\n\t\t\t- 参数：\r\n\r\n\t\t\t\t- 参数使用[] 数组包含上\r\n\r\n\t\t\t- 应用场景：\r\n\r\n\t\t\t\t- 常常跟数组有关系，例如：借助Math种的最大值，最小值，求出数组中的最大值，最小值\r\n\r\n\t\t- 3.bind（this，m，n…………）\r\n\r\n\t\t\t- 参数\r\n\r\n\t\t\t\t- 参数使用，逗号分隔开\r\n\r\n\t\t\t- 应用场景\r\n\r\n\t\t\t\t- 不调用函数，并且还想改变this的指向\r\n\r\n- 模式：\r\n\r\n\t- 正常模式：\r\n\t- 严格模式：\r\n\r\n\t\t- 1.声明：\r\n\r\n\t\t\t- “use strict”\r\n\r\n\t\t- 2.使用位置\r\n\r\n\t\t\t- 1.函数的顶端（使当前的函数声明为严格模式）\r\n\t\t\t- 2.脚本的顶端（是脚本声明为严格模式）\r\n\r\n\t\t- 3.注意事项\r\n\r\n\t\t\t- 1.变量\r\n\r\n\t\t\t\t- 1.变量声明中，必须加var\r\n\t\t\t\t- 2.不准删除变量\r\n\r\n\t\t\t- 2.this的指向：\r\n\r\n\t\t\t\t- 正常模式：\r\n\r\n\t\t\t\t\t- 在全局的作用域下，函数中的this，指向的是window\r\n\r\n\t\t\t\t- 严格模式：\r\n\r\n\t\t\t\t\t- 在全局的作用域下，函数中的this，是undefined\r\n\r\n\t\t\t- 3.函数变化\r\n\r\n\t\t\t\t- 1.函数不能有重复函数\r\n\t\t\t\t- 2.非函数体内不能含有函数体\r\n\r\n- 高阶函数：\r\n\r\n\t- 1.将函数当作值传入参数\r\n\t- 2.将函数当作返回值返回\r\n\r\n- 闭包\r\n\r\n\t- 一个作用域访问另一个作用域内的局部变量\r\n\r\n### 递归\r\n\r\n- 什么是？\r\n\r\n\t- 函数调用函数本身\r\n\r\n- 深拷贝与浅拷贝\r\n\r\n\t- 浅拷贝\r\n\r\n\t\t- 第一层：简单数据类型\r\n\r\n\t\t\t- 扩展：ES6新增方法Object.assign(“新的”，“源的”)\r\n\r\n\t- 深拷贝\r\n\r\n\t\t- 实现复杂类型的赋值，切记不能直接赋值，考虑复杂类型地址的问题\r\n\r\n- 补充知识：\r\n\r\n\t- instenceof 判断是不是数组或者对象\r\n\r\n### 正则表达式\r\n\r\n- 什么是？\r\n\r\n\t- 匹配字符串，检索，验证，表单验证\r\n\r\n- 创建方式\r\n\r\n\t- 1.var reg = new RegExp(/abc/)\r\n\t- 2.var reg = /abc/\r\n\r\n- 组成\r\n\r\n\t- 简单字符和特殊字符【元字符】\r\n\r\n- 边界符\r\n\r\n\t- n表示匹配行首的文本\r\n\t- $表示匹配行尾的文本\r\n\r\n- 中括号\r\n\r\n\t- 例：var reg = /^[abc]$/    也可以写成    var reg = /^[a|b|c]$/\r\n\r\n\t\t- a或b或c\r\n\t\t- 多选1\r\n\r\n\t- ^   这个需要注意一下：括号外边是边界符，里面是取反的意思\r\n\r\n- 量词符\r\n\r\n\t- *\r\n\r\n\t\t- 重复0次或者多次\r\n\r\n\t- .\r\n\r\n\t\t- 任意的\r\n\r\n\t- +\r\n\r\n\t\t- 最少一次\r\n\r\n\t- ？\r\n\r\n\t\t- 重复0次或者1次\r\n\r\n\t- {n}\r\n\r\n\t\t- 重复n次\r\n\r\n\t- {n，}\r\n\r\n\t\t- 重复n次或者更多次\r\n\r\n\t- {n，m}\r\n\r\n\t\t- 重复n到m次\r\n\r\n- 括号总结\r\n\r\n\t- 大括号\r\n\r\n\t\t- 量词符\r\n\r\n\t\t\t- 表示重复里面的次数\r\n\r\n\t- 中括号\r\n\r\n\t\t- 匹配括号中的任意字符\r\n\r\n\t- 小括号\r\n\r\n\t\t- 表示优先级\r\n\r\n## 一些重点问题\r\n\r\n### 【ES6】Promise解决了什么问题及使用\r\n\r\n- 【异步】Promise真正解决了什么？\r\n\r\n\t- 解决了回调地狱？\r\n\r\n\t\t- “回调地狱”所说的嵌套其实是指异步的嵌套。它带来了两个问题：可读性的问题和捕获错误问题。\r\n\r\n\t- 回调地狱的真正问题不是缩进\r\n\r\n\t\t- 可读性的问题\r\n\r\n\t\t\t- 代码逻辑书写顺序与执行顺序不一致，不利于阅读与维护。\r\n\t\t\t- 异步操作的顺序变更时，需要大规模的代码重构。\r\n\t\t\t- 回调函数基本都是匿名函数，bug 追踪困难。\r\n\r\n\t\t- 捕获错误问题\r\n\r\n\t\t\t- 控制反转\r\n\r\n\t\t\t\t- 在回调函数中，控制权被交给了第三方，由第三方决定什么时候调用回调以及如何调用回调。\r\n\r\n\t\t\t- 根本问题\r\n\r\n\t\t\t\t- 回调函数真正的问题是剥夺了程序员使用return和throw等捕捉错误和返回值的能力\r\n\t\t\t\t- 程序的执行流程是基于一个函数在执行过程中调用另一个函数时候会产生函数调用栈，而回调函数不是运行在栈上的，因此不能使用return和throw。\r\n\r\n\t\t\t- 代码的脆弱\r\n\r\n\t\t\t\t- 假设是这两个函数有顺序依赖的关系，我们要让A发生后B才执行，我们要把它们连接到一起的话只能手工硬编码\r\n\t\t\t\t- 这种方法会使得代码脆弱，你要在回调中捕获错误，必须在这个回调函数中创建大量逻辑来判断处理这些可能的情况，但这毫无疑问地会严重影响代码的可读性与开发效率。\r\n\r\n\t\t\t- 举例\r\n\r\n\t\t\t\t- 比如Ajax，可能会出现很多问题\r\n\r\n\t\t\t\t\t- 对于回调过早的问题\r\n\t\t\t\t\t- 对于回调过晚或没有调用的问题\r\n\t\t\t\t\t- 对于回调次数太少或太多的问题\r\n\r\n\t\t\t- 业界其他方案\r\n\r\n\t\t\t\t- （1）分离回调\r\n\r\n\t\t\t\t\t- 一个用于成功的处理函数，一个用于错误的处理函数！\r\n\r\n\t\t\t\t- （2）error-first风格，nodejs\r\n\r\n\t\t\t\t\t- 回调第一个参数作为错误对象(if exists)。 如果成功，error为 清空/置假 ，如果失败，if(err)为真。\r\n\r\n\t\t\t\t- 问题\r\n\r\n\t\t\t\t\t- 但这并没有解决 重复调用回调的问题。 你可能同时得到成功或失败的结果！ 或者都没有！ \r\n\t\t\t\t\t- 事实上：你需要额外的写更多的逻辑来处理回调过快或者失败或者太慢的问题， \r\n\r\n\t- 问题的解决\r\n\r\n\t\t- 如何解决可读性的问题\r\n\r\n\t\t\t- 链式调用相当于给了你一张可以把解题思路清晰记录下来的草稿纸，你不在需要用脑子去记忆执行顺序。\r\n\r\n\t\t- 如何解决捕获错误问题\r\n\r\n\t\t\t- Promise并没有取消控制反转，而是把反转出去的控制再反转一次，也就是反转了控制反转。\r\n\t\t\t- 与普通的回调的方式的区别\r\n\r\n\t\t\t\t- 普通的方式\r\n\r\n\t\t\t\t\t- 回调成功之后的操作直接写在了回调函数里面，而这些操作的调用由第三方控制。\r\n\r\n\t\t\t\t- Promise的方式\r\n\r\n\t\t\t\t\t- 回调只负责成功之后的通知，而回调成功之后的操作放在了then的回调里面，由Promise精确控制。\r\n\t\t\t\t\t- 反转控制反转\r\n\r\n\t\t\t\t\t\t- Promise 其实应验了 CS 的名言【所有问题都可以通过加一层中间层来解决】。在解决回调嵌套的问题中，Promise 就充当了一个中间层，用来【把回调造成的控制反转再反转回去】\r\n\r\n\t\t\t\t\t- 异步前后\r\n\r\n\t\t\t\t\t\t- 在使用 Promise 的例子中，控制流分为了两个部分：触发异步前的逻辑通过 new传入 Promise，而异步操作完成后的逻辑则传入 Promise 的 then 接口中。通过这种方式，第一方业务和第三方库的相应逻辑都由 Promise 来调用，进而在 Promise 中解决异步编程中可能出现的各种问题。\r\n\r\n\t\t\t\t\t- 接近观察者模式\r\n\r\n\t\t\t\t\t\t- 这种模式其实和观察者模式是接近的。下面的代码将 resolve / then 换成了 publish / subscribe ，将通过 new Promise 生成的 Promise 换成了通过 observe 生成的 observable 实例。可以发现，这种调用同样做到了回调嵌套的解耦。这就是 Promise 魔法的关键之一。\r\n\r\n\t\t\t- 解决传统回调的问题\r\n\r\n\t\t\t\t- 对于回调过早的问题\r\n\r\n\t\t\t\t\t- Promise不必担心，因为即使是立即完成的promise，对一个promise调用then的时候，即使这个promise已经resolution，提供给then的回调也总是异步调用的\r\n\t\t\t\t\t- 不需要setTimeout(,,0) hack, Promise不会导致竞态。\r\n\r\n\t\t\t\t- 对于回调过晚或没有调用的问题\r\n\r\n\t\t\t\t\t- Promise本身不会回调过晚，只要决议了，它就会按照规定运行。Promise创建对象调用resolve() 或reject() 的时候， 这个promise的then(…)注册的观察回调会被自动调度。 \r\n\t\t\t\t\t- 至于服务器或者网络的问题，并不是Promise能解决的，一般这种情况会使用Promise的竞态APIPromise.race加一个超时的时间\r\n\r\n\t\t\t\t\t\t- race()是一个解决如果Promise永远不能被resolved的解决方法\r\n\r\n\t\t\t\t- 对于回调次数太少或太多的问题\r\n\r\n\t\t\t\t\t- 回调被调用的正确次数应该是1。Promise的定义方式使得它只能被resolved 一次，如果处于某种原因。Promise创建的代码试图call resolve(…) or reject(..)多次， 那这个promise只会接收第一次resolved，并忽略后面的调用。 \r\n\r\n\t\t\t- Promise A+规范\r\n\r\n\t\t\t\t- 1. 如果promise被resolve，它要不是success就是failure，不可能同时存在。\r\n\t\t\t\t- 2. 一旦promise被resolve，它就再也不会被resolve(不会出现重复调用)。\r\n\t\t\t\t- 3. 如果promise返回了成功的信息，那么你绑定在成功事件上的回调会得到这个消息。\r\n\t\t\t\t- 4. 如果发生了错误，promise会收到一个带有错误信息的错误通知。\r\n\t\t\t\t- 5. 无论promise最后的结果是什么(success或者failure)，他就不会改变了，你总是可以获得这个消息只要你不销毁promise。\r\n\r\n- 【异步】Promise的使用以及了解\r\n\r\n\t- （1）了解 Promise 吗？\r\n\r\n\t\t- Promise 是异步编程的一种解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。现已被 ES6 纳入进规范中。\r\n\r\n\t- （2）Promise 解决的痛点是什么？\r\n\r\n\t\t- 在 Promise 出现以前，我们处理一个异步网络请求，大概是这样：\r\n\r\n\t\t\t- 我们基本上还要对每次请求的结果进行一些处理，代码会更加臃肿，在一个团队中，代码 review 以及后续的维护将会是一个很痛苦的过程。\r\n\r\n\t\t- 回调地狱带来的负面作用有以下几点：\r\n\r\n\t\t\t- 代码臃肿。\r\n\t\t\t- 可读性差。\r\n\t\t\t- 耦合度过高，可维护性差。\r\n\t\t\t- 代码复用性差。\r\n\t\t\t- 容易滋生 bug。\r\n\t\t\t- 只能在回调里处理异常。\r\n\r\n\t\t- 出现了问题，自然就会有人去想办法。这时，就有人思考了，能不能用一种更加友好的代码组织方式，解决异步嵌套的问题。\r\n\r\n\t- （3）Promise 解决的痛点还有其他方法可以解决吗？如果有，请列举。\r\n\t- （4）Promise 如何使用？\r\n\r\n\t\t-  Promise 的常规写法：\r\n\r\n\t\t\t- 比较一下这种写法和上面的回调式的写法。我们不难发现，Promise 的写法更为直观，并且能够在外层捕获异步函数的异常信息。\r\n\r\n\t\t- 用法举例\r\n\r\n\t\t\t- 一，需求方法步骤\r\n\r\n\t\t\t\t- 你先去超市买菜。\r\n\t\t\t\t- 用超市买回来的菜做饭。\r\n\t\t\t\t- 将做好的饭菜送到老婆单位。\r\n\t\t\t\t- 送到单位后打电话告诉我。\r\n\r\n\t\t\t- 二，写好函数\r\n\r\n\t\t\t- 三，利用promise实现功能\r\n\r\n\t\t\t- 注意：请一定要谨记：如果我们的后续任务是异步任务的话，必须return 一个 新的 promise 对象。如果后续任务是同步任务，只需 return 一个结果即可。\r\n\r\n我们上面举的例子，除了电话通知我是一个同步任务，其余的都是异步任务，异步任务 return 的是 promise对象。\r\n\r\n\t\t- 使用总结\r\n\r\n\t\t\t- \r\n（1）首先初始化一个 Promise 对象，可以通过两种方式创建， 这两种方式都会返回一个 Promise 对象。\r\n\r\n\t\t\t\t- 1、new Promise(fn)\r\n\t\t\t\t- 2、Promise.resolve(fn)\r\n\r\n\t\t\t- （2）然后调用上一步返回的 promise 对象的 then 方法，注册回调函数。\r\n\r\n\t\t\t\t- then 中的回调函数可以有一个参数，也可以不带参数。如果 then 中的回调函数依赖上一步的返回结果，那么要带上参数。比如\r\n\t\t\t- （3）最后注册 catch 异常处理函数，处理前面回调中可能抛出的异常。\r\n\r\n\t- （5）Promise 常用的方法，方法的作用？\r\n\r\n\t\t- Promise.resolve(value)\r\n\r\n\t\t\t- 有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用。\r\n\r\n\t\t\t\t- Promise.resolve等价于下面的写法。\r\n\r\n\t\t\t- 1、如果这个值是个thenable（即带有then方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态（指 resolved/rejected/pending/settled）\r\n\r\n\t\t\t- 2、如果传入的 value 本身就是 promise 对象，则该对象作为 Promise.resolve 方法的返回值返回。\r\n\r\n\t\t\t- 3、其他情况以该值为成功状态返回一个 promise 对象。\r\n\r\n\t\t- Promise.reject(value)\r\n\r\n\t\t\t- 与 resolve 唯一的不同是，返回的 promise 对象的状态为 rejected。\r\n\r\n\t\t- Promise.then\r\n\r\n\t\t\t- 为 promise 注册回调函数，函数形式：fn(vlaue){}，value 是上一个任务的返回结果，then 中的函数一定要 return 一个结果或者一个新的 Promise 对象，才可以让之后的then 回调接收。\r\n\r\n\t\t- Promise.catch\r\n\r\n\t\t\t- 捕获异常，函数形式：fn(err){}, err 是 catch注册 之前的回调抛出的异常信息。\r\n\r\n\t\t- Promise.race\r\n\r\n\t\t\t- 多个promise 任务同时执行，只返回最先执行完的 Promise 任务的结果。 \r\n\r\n\t\t- Promise.all\r\n\r\n\t\t\t- 多个promise 任务同时执行，返回所有promise 任务的执行结果。\r\n\r\n\t- （6）Promise 在事件循环中的执行过程是怎样的？\r\n\t- （7）Promise 的升级\r\n\r\n\t\t- ES6 出现了 generator 以及 async/await 语法，使异步处理更加接近同步代码写法，可读性更好，同时异常捕获和同步代码的书写趋于一致。\r\n\t- （8）能不能手写一个 Promise 的polyfill。\r\n\r\n### 【ES6】说出你知道的ES6新特性\r\n\r\n- ES6常考问题\r\n\r\n\t- 为什么const定义一个数组与对象，仍然可以对其操作?\r\n\r\n\t\t- const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。\r\n\t\t- 对于简单类型的数据（数值、字符串、布尔值）\r\n\r\n\t\t\t- 值就保存在变量指向的那个内存地址，因此等同于常量。\r\n\r\n\t\t- 对于复合类型的数据（主要是对象和数组）\r\n\r\n\t\t\t- 变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了\r\n\t\t\t- 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。\r\n\r\n\t\t\t- 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。\r\n\r\n\t\t\t- 如果真的想将对象冻结，应该使用Object.freeze方法。\r\n\r\n\t\t\t\t- 上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。\r\n\t\t\t\t- 除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。\r\n\r\n- Promise\r\n\r\n\t- 什么是Promise？\r\n\r\n\t\t- 传统的异步编程最大的特点就是地狱般的回调嵌套，一旦嵌套次数过多，就很容易使我们的代码难以理解和维护。而Promise则可以让我们通过链式调用的方法去解决回调嵌套的问题，使我们的代码更容易理解和维护，而且Promise还增加了许多有用的特性，让我们处理异步编程得心应手。\r\n\t\t- 传统的异步回调函数\r\n\r\n\t\t\t- （1）每个回调函数，都会无法确定另一个回调函数会在何时会被调用，因为这个控制权不在当前这个程序之中。\r\n\t\t\t- （2）每个回调函数，都或多或少的依赖于上一个回调函数执行的时间和数据\r\n\t\t\t- 问题\r\n\r\n\t\t\t\t- 基于这两点，我们就会发现，一旦你需要这样去编写代码，就必须保证你的上一个回调函数在下一个回调函数之前进行。我们还可以发现，它们之间缺乏一种约定，就是一旦上一个发生了，无论是正确还是错误，都会通知对应的回调函数的约定。\r\n\r\n\t- 如何创建Promise？\r\n\r\n\t\t- 代码示例\r\n\r\n\t\t- 代码解释\r\n\r\n\t\t\t- （1）因为Promise是一个构造函数，所以我们使用了new操作符来创建promise。\r\n\t\t\t- （2）构造函数Promise的参数是一个函数（暂时叫它func），这个函数（func）有两个参数resolve和reject，它们分别是两个函数，这两个函数的作用就是将promise的状态从pending（等待）转换为resolved（已解决）或者从pending（等待）转换为rejected（已失败）。\r\n\t\t\t- （3）创建后的promise有一些方法，then和catch。当然我们也可以人为的在Promise函数上添加一些满足我们自己需求的方法，方便每一个promise对象使用。\r\n\r\n\t\t- 理解Promise\r\n\r\n\t\t\t- Promise函数体的内部包裹着一个异步的请求或者操作或者函数；然后我们可以在这个异步的操作完成的时候使用resolve函数将我们获得的结果传递出去，或者使用reject函数将错误的消息传递出去。\r\n\r\n\t- Promise对象的一些方法\r\n\r\n\t\t- then方法\r\n\r\n\t\t\t- 初步了解\r\n\r\n\t\t\t\t- 可以通过使用then方法将上一步返回的结果获取过来（不管是resolved还是rejected）\r\n\r\n\t\t\t- then方法的使用\r\n\r\n\t\t\t\t- 示例1\r\n\r\n\t\t\t\t\t- 也就是说，我们在创建p这个Promise对象的时候，通过函数resolve传递出去的结果可以被p的第一个then方法中的第一个函数捕获然后作为它的参数。通过函数reject传递出去的结果可以被p的第一个then方法中的第二个函数捕获然后作为它的参数。\r\n\r\n\t\t\t\t- （1）then方法可以接受两个函数作为参数，第一个函数是用来处理resolve的结果，第二个是可选的，用来处理reject的结果。\r\n\t\t\t\t- 示例2\r\n\r\n\t\t\t\t\t- 一旦创建一个Promise对象之后，我们就可以使用then方法来进行链式的调用，而且我们可以把每一次的结果都返还给下一个then方法，然后在下一个then方法中对这个值进行处理。每一个then方法中都可以再次新创建一个Promise对象，然后返还给下一个then方法处理。\r\n\r\n\t\t\t\t- （2）还可以在每一个then方法中创建新的Promise，然后将这个Promise对象返回，之后我们就可以在后面的then方法中继续对这个对象进行操作。\r\n\r\n\t\t- catch方法\r\n\r\n\t\t\t- 初步了解\r\n\r\n\t\t\t\t- 这个方法其实是then方法的一种特例，这个特例就是：.then(null, rejection)，相当于我们不使用then方法的第一个函数，只是用第二个函数；catch函数比较简单，就是用来捕获之前的then方法里面的异常\r\n\r\n\t\t- all方法\r\n\r\n\t\t\t- 初步了解\r\n\r\n\t\t\t\t- \r\nPromise.all方法用来包装许多个Promise实例，然后组成了一个新的Promise对象\r\n\t\t\t\t- 新的Promise对象的状态由前面几个被包裹的Promise对象的状态决定，如果前面的Promise都被resolve了，那么新的Promise的状态也是resolve的；只要有一个Promise被reject了，那么组成的新的Promise的状态也是reject的。\r\n\r\n\t\t\t- 方法的使用\r\n\r\n\t\t- race方法\r\n\r\n\t\t\t- 初步了解\r\n\r\n\t\t\t\t- 和上面的Promise.all有点类似，都是包装许多的Promise对象，然后组成了一个新的Promise对象\r\n\t\t\t\t- 但是使用Promise.race的含义是：只要包裹的的Promise对象中有一个的状态发生了改变，那么组成的这个新的Promise对象的状态就是上面那个率先改变的Promise实例的状态。\r\n\r\n\t\t\t- 方法的使用\r\n\r\n\t\t- resolve方法\r\n\r\n\t\t\t- 初步了解\r\n\r\n\t\t\t\t- 主要是将一个值转变为一个Promise对象，然后使它具有Promise的一些方法和特性，为了满足我们一些特殊情况下的要求。\r\n\r\n\t\t\t- 方法的使用\r\n\r\n\t\t- reject方法\r\n\r\n\t\t\t- 初步了解\r\n\r\n\t\t\t\t- 和Promise.resolve方法一样，只不过通过Promise.reject方法产生的Promise对象的状态是rejected的，\r\n\r\n- let与const\r\n\r\n\t- （1）在同一个块级作用域中，不允许重复定义。\r\n\t- （2）const定义的变量不允许二次修改。\r\n\t- （3）let和const定义的变量会形成块级作用域\r\n\t- （4）它们定义的变量不存在变量提升，以及存在暂时性死区\r\n\r\n- 函数的变化——箭头函数，剩余参数，参数默认值\r\n\r\n\t- 箭头函数\r\n\r\n\t\t- 规则\r\n\r\n\t\t\t- （1）变量如果只有一个的时候，可以省略()\r\n\t\t\t- （2）如果是只有一句返回语句时，可以直接省略{return }这一部分\r\n\t\t\t- （3）因为它本身叫做arrow，所以每次都必须带上=>符号\r\n\r\n\t\t- 注意事项\r\n\r\n\t\t\t- （1）箭头函数不能作为构造函数\r\n\r\n\t\t\t- （2）箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域。（取决于箭头函数定义时的作用域，不受apply，call，bind影响）\r\n\r\n\t\t\t- （3）箭头函数没有arguments。\r\n\r\n\t- rest剩余参数\r\n\r\n\t\t- ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。\r\n\t\t- 注意\r\n\r\n\t\t\t- （1）与扩展运算符相反\r\n\r\n\t\t\t\t- 扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。\r\n\r\n\t\t\t- （2）rest 参数之后不能再有其他参数（即只能是最后一个参数）\r\n\t\t\t- （3）arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组\r\n\r\n\t- 参数默认值\r\n\r\n\t\t- ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。\r\n\r\n- 数组——解构赋值、二进制数组\r\n\r\n\t- 解构赋值\r\n\r\n\t\t- 注意\r\n\r\n\t\t\t- （1）必须保证有赋值的过程。\r\n\r\n\t\t\t- （2）左边内容部分的结构必须与右边保持一致。\r\n\r\n\t\t- 使用\r\n\r\n\t\t\t- （1）默认值的使用。\r\n\r\n\t\t\t- （2）在变量中使用解构赋值\r\n\r\n\t- 二进制数组\r\n\r\n- 字符串——模版字符串、startsWith、endsWith\r\n\r\n\t- startWith\r\n\r\n\t\t- 用法\r\n\r\n\t\t\t- 返回值为boolean型，然后去匹配字符串开头的部分\r\n\r\n\t\t- 使用\r\n\r\n\t\t\t- 这个API仅仅在一些场景下起到一定的便捷。比方说，我们需要去匹配一个URL的协议头是什么时，我们往往需要用到这种方式。\r\n\r\n\t- endsWith\r\n\r\n\t\t- 用法\r\n\r\n\t\t\t- 返回值是boolean类型，然后去匹配字符串的结尾。\r\n\r\n\t\t- 使用\r\n\r\n\t\t\t- 这种情况的使用场景是，往往我们需要为上传的文件准备图标，那么我们就可以根据后缀来确定图标。\r\n\r\n- Class和extends\r\n\r\n\t- ES6的class是一种更简洁的语法糖，JS面向对象编程依然是基于原型实现的\r\n\r\n\t\t- ES5中声明类的方式\r\n\r\n\t\t- 利用class语法糖\r\n\r\n\t- extends类的继承，我们可以用extends扩展一个类并继承它的行为，在构造函数中，也可以通过super关键字引用父类的构造函数\r\n\r\n### 【This】JavaScript This 关键字的理解？以及call、apply、bind\r\n\r\n- this\r\n\r\n\t- （1）this的定义\r\n\r\n\t\t- this是在执行上下文创建时确定的一个在执行过程中不可更改的变量。\r\n\t\t- 执行上下文\r\n\r\n\t\t\t- 就是JavaScript引擎在执行一段代码之前将代码内部会用到的一些变量、函数、this提前声明然后保存在变量对象中的过程。\r\n\t\t\t- 这个'代码片段'包括：全局代码(script标签内部的代码)、函数内部代码、eval内部代码。而我们所熟知的作用域链也会在保存在这里，以一个类数组的形式存储在对应函数的[[Scopes]]属性中。\r\n\r\n\t\t- this的多变性\r\n\r\n\t\t\t- this只在函数调用阶段确定，也就是执行上下文创建的阶段进行赋值，保存在变量对象中。这个特性也导致了this的多变性:即当函数在不同的调用方式下都可能会导致this的值不同。\r\n\r\n\t- （2）严格模式与非严格模式下\r\n\r\n\t\t- 当函数独立调用的时候，在严格模式下它的this指向undefined，在非严格模式下，当this指向undefined的时候，自动指向全局对象(浏览器中就是window)\r\n\r\n\t- （3）函数的四种调用方式\r\n\r\n\t\t- 在全局环境或是普通函数中直接调用\r\n\r\n\t\t\t- 需要特别注意的情况\r\n\r\n\t\t\t\t- window, 自执行函数调用时,没有宿主对象,默认是window\r\n\t\t\t\t- 解释，自执行函数需要外部函数调用才会执行\r\n\r\n\t\t\t\t- 与此种情况相同（当函数独立调用的时候，在严格模式下它的this指向undefined，在非严格模式下，当this指向undefined的时候，自动指向全局对象(浏览器中就是window)。）\r\n\r\n\t\t- 作为对象的方法\r\n\r\n\t\t\t- 需要注意隐式丢失\r\n\r\n\t\t\t\t- （1）\r\n\r\n\t\t\t\t- （2）\r\n\r\n\t\t\t\t- obj对象的属性存储的是对该匿名函数的一个引用，可以理解为一个指针。当赋值给其他变量的时候，并没有单独开辟内存空间存储新的函数，而是让其存储了一个指针，此时的obj2就是一个指向匿名函数的指针，调用obj2，相当于直接调用fun，\r\n\r\n\t\t- 使用apply和call\r\n\t\t- 作为构造函数\r\n\r\n\t\t\t- 使用new命令时，它后面的函数调用就不是正常的调用，而是依次执行下面的步骤。\r\n\r\n\t\t\t\t- （1）创建一个空对象，作为将要返回的对象实例\r\n\t\t\t\t- （2）将这个空对象的原型，指向构造函数的prototype属性\r\n\t\t\t\t- （3）将这个空对象赋值给函数内部的this关键字\r\n\t\t\t\t- （4）开始执行构造函数内部的代码，并且返回这个对象\r\n\r\n\t\t\t- 当this碰到return时\r\n\r\n\t\t\t\t- 如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。\r\n\t- （4）箭头函数\r\n\r\n\t\t- （1）箭头函数中的this固定，箭头函数是根据外层（函数或者全局）作用域来决定this\r\n\r\n\t\t\t- 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。this对象的指向是可变的，但是在箭头函数中，它是固定的。\r\n\r\n\t\t- （2）实质上箭头函数没有自己的this，不能作为构造函数\r\n\r\n\t\t\t- this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。\r\n\r\n\t\t- （3）由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。\r\n\t\t- 理解\r\n\r\n\t\t\t- 1.箭头函数作为对象的方法\r\n\r\n\t\t\t\t- 作用域根据外层，即对象所在作用域\r\n\r\n\t\t\t- 2.箭头函数作为函数的返回值或者构造函数的方法\r\n\r\n\t\t\t\t- 作用域根据外层，即其父函数本身的函数作用域\r\n\r\n\t\t\t- 3.箭头函数作为回调函数\r\n\r\n\t\t\t\t- 一层箭头函数\r\n\r\n\t\t\t\t- 多层嵌套的箭头函数\r\n\r\n\t\t\t\t- 复杂情况: 普通函数和箭头函数混杂嵌套\r\n\r\n\t\t\t\t- 严格模式下的情况\r\n\r\n- bind与call，apply的区别\r\n\r\n\t- \r\nbind 返回的是一个函数,并没有执行原函数,只是这个函数的this指向了你给的参数\r\n\t- apply ，call是执行函数,这个函数的this指向了你给的第一个参数\r\n\r\n### 【闭包】什么是闭包及其应用场景\r\n\r\n- 关于闭包的黄金理解\r\n\r\n\t- （1）JavaScript中的闭包，无非就是变量解析的过程。\r\n\r\n\t  每次定义一个函数，都会产生一个作用域链（scope chain）。当JavaScript寻找变量varible时（这个过程称为变量解析），总会优先在当前作用域链的第一个对象中查找属性varible ，如果找到，则直接使用这个属性；否则，继续查找下一个对象的是否存在这个属性；这个过程会持续直至找到这个属性或者最终未找到引发错误为止。\r\n\r\n\t  \r\n\r\n\t- （2）JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。\r\n\r\n- 闭包的形成与变量的作用域以及变量的生存周期密切相关\r\n\r\n\t- 变量的作用域\r\n\r\n\t\t- （1）全局作用域\r\n\t\t- （2）函数作用域\r\n\r\n\t- 变量的生存周期\r\n\r\n\t\t- （1）对于全局作用域来说，生命周期是永久的，除非你主动销毁\r\n\t\t- （2）对于函数内的局部变量来说，随着函数调用的结束而被销毁\r\n\t\t- 当创建闭包时，函数执行完毕，局部变量并没有消失，这是因为在闭包里返回了一个函数的引用，它可以访问调用到原闭包（外层）函数所产生的环境，而局部变量一直处于这个环境之中，既然局部变量所在的函数还能被外界所访问到，这个局部变量就有了不被销毁的理由，在这里产生了一个闭包结构，局部变量的生命看起来被延续了\r\n\r\n- 闭包的应用\r\n\r\n\t- （1）管理私有变量和私有方法，将对变量（状态）的变化封装在安全的环境中\r\n\t- （2）将代码封装成一个闭包形式，等待时机成熟的时候再使用，比如实现柯里化和反柯里化\r\n\r\n\t\t- 函数柯里化\r\n\r\n\t\t\t- 柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。\r\n\r\n- 闭包引发的问题\r\n\r\n\t- \r\n闭包和内存泄露有关系的地方是，使用闭包的同时比较容易造成循环引用，如果闭包的作用域链中保存着一些DOM节点，这时候就有可能造成内存泄漏\r\n\r\n\t\t- 解决：把循环引用中的变量设为null即可，即为切断变量和它此前引用的值之间的连接，当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存\r\n\t\t- 举个例子\r\n\r\n\t\t- 解决\r\n\r\n\t- 关于JS内存泄露\r\n\r\n\t\t- （1）什么是内存泄漏？\r\n\r\n\t\t\t- 程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。\r\n\t\t\t- 对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。\r\n\t\t\t- 不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。\r\n\r\n\t\t- （2）垃圾回收机制\r\n\r\n\t\t\t- 存在理由\r\n\r\n\t\t\t\t- 有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。\r\n\t\t\t\t- 这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为\"垃圾回收机制\"（garbage collector）。\r\n\r\n\t\t\t- JS中的垃圾回收机制\r\n\r\n\t\t\t\t- （1）标记清除（现代浏览器使用）\r\n\r\n\t\t\t\t\t- 通常javascript通过标记变量的状态来判断是否被回收,当变量在函数中被声明时标记进入环境,在函数执行结束时,环境被销毁标记离开环境等待回收.只要不释放进入环境的变量,他在环境中的任何位置任何时刻都可以被访问,就不会被垃圾回收机所回收.\r\n\r\n\t\t\t\t\t- 标记清除算法将“不再使用的对象”定义为“无法达到的对象”\r\n\r\n\t\t\t\t\t\t- 简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。\r\n\r\n\t\t\t\t\t- 问题\r\n\r\n\t\t\t\t\t\t- 对现代浏览器来说，唯一要注意的就是明确切断需要回收的对象与根部的联系。有时候这种联系并不明显，且因为标记清除算法的强壮性，这个问题较少出现。最常见的内存泄露一般都与DOM元素绑定有关：\r\n\r\n\t\t\t\t\t\t\t- div元素已经从DOM树中清除，也就是说从DOM树的根部无法触及该div元素了。但是请注意，div元素同时也绑定了email对象。所以只要email对象还存在，该div元素将一直保存在内存中。\r\n\r\n\t\t\t\t- （2）引用计数（IE）\r\n\r\n\t\t\t\t\t- javascript去维护一张表,存储内存中资源的引用次数,资源被引用+1,结束引用或者函数执行完毕结束作用域,引用次数-1,引用次数由1到0时不会执行,节省开销,直接标记\r\n\r\n\t\t\t\t\t- 问题\r\n\r\n\t\t\t\t\t\t- 这个方式存在一个比较大的问题就是循环引用，就是说A对象包含一个指向B的指针，对象B也包含一个指向A的引用。 这就可能造成大量内存得不到回收（内存泄露），因为它们的引用次数永远不可能是 0 。\r\n\t\t\t\t\t\t- 例子\r\n\r\n\t\t\t\t\t\t\t- 执行这段代码的时候，将匿名函数对象赋值给el的onclick属性；然后匿名函数内部又引用了el对象，存在循环引用，所以不能被回收；\r\n\r\n\t\t\t\t\t\t- 解决方法：\r\n\r\n\t\t- （3）内存泄漏的识别方法\r\n\r\n\t\t\t- 1、经验方法\r\n\r\n\t\t\t\t- 如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。 这要我们实时查看内存占用。\r\n\r\n\t\t\t- 2、浏览器方法\r\n\r\n\t\t\t\t- 1）打开开发者工具，选择 Timeline 面板\r\n\t\t\t\t- 2）在顶部的Capture字段里面勾选 Memory\r\n\t\t\t\t- 3）点击左上角的录制按钮。\r\n\t\t\t\t- 4）在页面上进行各种操作，模拟用户的使用情况。\r\n\t\t\t\t- 4）一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。\r\n\t\t\t\t- 如果内存占用基本平稳，接近水平，就说明不存在内存泄漏。 反之，就是内存泄漏了。\r\n\r\n\t\t\t- 3、命令行方法\r\n\r\n\t\t\t\t- 命令行可以使用 Node 提供的 process.memoryUsage 方法。（判断内存泄漏，以heapUsed字段为准。）\r\n\t\t\t\t\t- rss（resident set size）：所有内存占用，包括指令区和堆栈。\r\n\t\t\t\t\t- heapTotal：\"堆\"占用的内存，包括用到的和没用到的。\r\n\t\t\t\t\t- heapUsed：用到的堆的部分。\r\n\t\t\t\t\t- external： V8 引擎内部的 C++ 对象占用的内存。\r\n\r\n\t\t- （4）WeakMap\r\n\r\n\t\t\t- 问题的提出\r\n\r\n\t\t\t\t- 及时清除引用非常重要。但是，你不可能记得那么多，有时候一疏忽就忘了，所以才有那么多内存泄漏。\r\n\t\t\t\t- 最好能有一种方法，在新建引用的时候就声明，哪些引用必须手动清除，哪些引用可以忽略不计，当其他引用消失以后，垃圾回收机制就可以释放内存。这样就能大大减轻程序员的负担，你只要清除主要引用就可以了。\r\n\r\n\t\t\t- ES6的弱引用\r\n\r\n\t\t\t\t- ES6 考虑到了这一点，推出了两种新的数据结构：WeakSet 和 WeakMap。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个\"Weak\"，表示这是弱引用。\r\n\r\n\t\t\t- 使用\r\n\r\n\t\t\t\t- 解释\r\n\r\n\t\t\t\t\t- 先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。\r\n\t\t\t\t\t- 也就是说，DOM 节点对象的引用计数是1，而不是2。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。\r\n\r\n\t\t\t\t- 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。\r\n\r\n### 【防抖与节流】JS中的函数防抖与节流\r\n\r\n- 函数防抖\r\n\r\n\t- 解释\r\n\r\n\t\t- 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。\r\n\r\n\t- 实现\r\n\r\n- 函数节流\r\n\r\n\t- 解释\r\n\r\n\t\t- 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。\r\n\r\n\t- 实现\r\n\r\n- 区别以及应用场景\r\n\r\n\t- 区别\r\n\r\n\t\t- 假设，我们观察的总时间为10秒钟，规定1秒作为一次事件的最小间隔时间。\r\n\r\n\t\t\t- 如果触发事件的频率是 0.5s/次，那么\r\n\r\n\t\t\t\t- 函数防抖\r\n\r\n\t\t\t\t\t- 因为始终没法等一秒钟就被再次触发了，所以最终没有一次事件是成功的。\r\n\r\n\t\t\t\t- 函数节流\r\n\r\n\t\t\t\t\t- 因为控制了最多一秒一次，频率为0.5s/次，所以每一秒钟就有一次事件作废。最终控制成1s/次\r\n\r\n\t\t\t- 如果触发事件的频率是 2s/次，那么\r\n\r\n\t\t\t\t- 函数防抖\r\n\r\n\t\t\t\t\t- 因为2s/次已经大于了规定的最小时间，所以每计时两秒便触发一次。\r\n\r\n\t\t\t\t- 函数节流\r\n\r\n\t\t\t\t\t- 同样，2s/次 大于了最小时间规定，所以每一次触发都生效。\r\n\r\n\t- 应用场景\r\n\r\n\t\t- 函数防抖（哪些时候对于连续的事件响应我们只需要执行一次回调？）\r\n\r\n\t\t\t- 适合多次事件一次响应的情况\r\n\r\n\t\t\t\t- \r\n（1）文本输入的验证（连续输入文字后发送 AJAX 请求进行验证，验证一次就好）\r\n\t\t\t\t- （2）判断scroll是否滑到底部，滚动事件+函数防抖\r\n\t\t\t\t- （3）调节浏览器size，监听resize()函数\r\n\r\n\t\t\t\t\t- 对于浏览器窗口，每做一次 resize 操作，发送一个请求，很显然，我们需要监听 resize 事件，但是和 mousemove 一样，每缩小（或者放大）一次浏览器，实际上会触发 N 多次的 resize 事件，用节流？节流只能保证定时触发，我们一次就好，这就要用去抖。\r\n\r\n\t\t\t- 简单的说，函数去抖就是对于一定时间段的连续的函数调用，只让其执行一次。\r\n\r\n\t\t- 函数节流（哪些时候我们需要间隔一定时间触发回调来控制函数调用频率？）\r\n\r\n\t\t\t- 适合大量事件按时间做平均分配触发\r\n\r\n\t\t\t\t- （1）DOM 元素的拖拽功能实现（mousemove）\r\n\r\n\t\t\t\t\t- 实现一个原生的拖拽功能（不能用 H5 Drag&Drop API），需要一路监听 mousemove 事件，在回调中获取元素当前位置，然后重置 dom 的位置（样式改变）。如果我们不加以控制，每移动一定像素而触发的回调数量是会非常惊人的，回调中又伴随着 DOM 操作，继而引发浏览器的重排与重绘，性能差的浏览器可能就会直接假死，这样的用户体验是非常糟糕的。我们需要做的是降低触发回调的频率，比如让它 500ms 触发一次，或者 200ms，甚至 100ms，这个阈值不能太大，太大了拖拽就会失真，也不能太小，太小了低版本浏览器可能就会假死，这样的解决方案就是函数节流，英文名字叫「throttle」。\r\n\r\n\t\t\t\t- （2）射击游戏的 mousedown/keydown 事件（单位时间只能发射一颗子弹）\r\n\t\t\t\t- （3）计算鼠标移动的距离（mousemove）\r\n\t\t\t\t- （4）Canvas 模拟画板功能（mousemove）\r\n\t\t\t\t- （5）搜索联想（keyup）\r\n\t\t\t\t- （6）监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次\r\n\r\n\t\t\t- 函数节流的核心是，让一个函数不要执行得太频繁，减少一些过快的调用来节流。\r\n\r\n### 【深浅拷贝】JavaScript 对象的浅拷贝和深拷贝区别？\r\n\r\n- 怎么判断两个对象相等？\r\n\r\n\t- 浅度比较\r\n\r\n\t\t- 使用JSON.stringify序列化一个对象时\r\n\r\n\t\t\t- （1）序列化后的属性出现的顺序是不定的，除了数组中的元素-其按数组中位置顺序序列化\r\n\t\t\t- （2）Boolean/Number/String对象转成其原始值\r\n\t\t\t- （3）如果属性值为undefined、函数对象，symbol(ES6中新类型)，那么这个属性要么在序列化的时候被忽略，要么被转成null（当在数组中出现时）\r\n\t\t\t- （4）以symbol类型为属性key的属性被完全忽略\r\n\t\t\t- （5）不可枚举的属性也被忽略\r\n\r\n\t- 深度比较\r\n\r\n\t\t- underscore中的eq函数源码\r\n\r\n- 浅拷贝\r\n\r\n\t- 定义\r\n\r\n\t\t- 只会将对象的各个属性进行依次复制，并不会进行递归复制，而js存储对象都是存地址的，所以浅复制会导致old.c和new.c 指向同一块内存地址；会导致引用。\r\n\r\n\t- 实现\r\n\r\n\t\t- （1）简单的赋值语句\r\n\r\n\t\t- （2）Object.assign(目标对象，源对象)\r\n\r\n\t\t\t- Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign() 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。\r\n\r\n- 深拷贝\r\n\r\n\t- 定义\r\n\r\n\t\t- 它不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上。这就不会存在上面old和new的c属性指向同一个对象的问题。\r\n\r\n\t- 实现\r\n\r\n\t\t- （1）JSON.parse()方法\r\n\r\n\t\t\t- 使用JSON.stringify进行序列化，JSON.parse进行反序列化，实现\"偷懒版\"的深复制\r\n\t\t\t- 坏处：\r\n\r\n\t\t\t\t- （1）它会抛弃对象的constructor。也就是深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成Object。\r\n\t\t\t\t- （2）这种方法能正确处理的对象只有 Number, String, Boolean, Array, 扁平对象，即那些能够被 json 直接表示的数据结构。RegExp对象是无法通过这种方式深拷贝。\r\n\t\t\t\t- （3）用此法无法深复制对象中的方法\r\n\r\n\t\t\t\t\t- 原因是 一个对象 上可能还有很多其他的无法被转为json string的东西\r\n\r\n\t\t\t\t- （4）通过 deep clone 一般都是有限定复制层次的，一般情况下不会无限层的复制下去。如果使用 JSON 方式来复制，通常不能控制层次。\r\n\r\n\t\t\t- JSON.parse()是怎么实现深拷贝的？\r\n\r\n\t\t\t\t- var a = JSON.stringify(oldObject)  \r\n// a是一个oldObject序列化后得到的字符串 和 oldObject没任何关系的新对象\r\n\t\t\t\t- var b = JSON.parse(a); \r\n// b 是从字符串a反序列化为一个全新的对象 所以 不但和a没关系 和oldObject更没关系\r\n\t\t\t\t- 序列化是一种将对象以一连串的字节描述的过程；反序列化是一种将这些字节重建成一个对象的过程\r\n\r\n\t\t- （2）使用递归拷贝\r\n\r\n\t\t\t- 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况\r\n\r\n\t\t- （3）$.extend()的深拷贝和浅拷贝\r\n\r\n\t\t\t- 用法\r\n\r\n\t\t\t- $.extend()的浅拷贝\r\n\r\n\t\t\t\t- 如果第二个参数对象有的属性第一个参数对象也有，那么不会进行相同参数内部的比较，直接将第一个对象的相同参数覆盖。\r\n\r\n\t\t\t- $.extend()的深拷贝\r\n\r\n\t\t\t\t- ：如果第二个参数对象有的属性第一个参数对象也有，还要继续在这个相同的参数向下一层找，比较相同参数的对象中是否还有不一样的属性，如果有，将其继承到第一个对象，如果没有，则覆盖。\r\n\r\n- 区别？\r\n\r\n\t- \r\n浅复制只复制一层对象的属性，而深复制则递归复制了所有层级。浅复制是对对象地址的复制，而深复制则是让其指向不同的堆内存\r\n\t- 浅拷贝\r\n\r\n\t\t- 深拷贝\r\n\r\n- 堆内存与栈内存\r\n\r\n\t- 为什么会有栈内存和堆内存之分？\r\n\r\n\t\t- 通常与垃圾回收机制有关。为了使程序运行时占用的内存最小。\r\n\t\t- stack为自动分配的内存空间，它由系统自动释放；而heap则是动态分配的内存，大小不定也不会自动释放。　\r\n\r\n\t- 什么存于栈内存？什么存于堆内存？\r\n\r\n\t\t- 当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；\r\n\t\t- 当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。\r\n\r\n\t- 区别\r\n\r\n\t\t- 栈中存储的是基础变量以及一些对象的引用变量，基础变量的值是存储在栈中，而引用变量存储在栈中的是指向堆中的数组或者对象的地址，这就是为何修改引用类型总会影响到其他指向这个地址的引用变量。\r\n\r\n### 【事件流】什么是事件流，事件代理委托原理\r\n\r\n- 事件流\r\n\r\n\t- 定义\r\n\r\n\t\t-  事件流描述的是从页面中接受事件的顺序\r\n\t\t- document.querySelector(）\r\n\r\n\t\t\t- 如果没有找到匹配元素，则返回 null，如果找到多个匹配元素，则返回第一个匹配到的元素。\r\n\r\n\t\t- target.addEventListener(type, listener[, useCapture])\r\n\r\n\t\t\t- 接受三个参数。\r\n\r\n\t\t\t\t- type：事件名称，大小写敏感。\r\n\t\t\t\t- listener：监听函数。事件发生时，会调用该监听函数。\r\n\t\t\t\t- useCapture：布尔值，表示监听函数是否在捕获阶段（capture）触发，默认为false（监听函数只在冒泡阶段被触发）。\r\n\r\n\t- 事件捕获的三个阶段\r\n\r\n\t\t- 事件捕获阶段\r\n\t\t- 目标阶段\r\n\t\t- 事件冒泡阶段\r\n\r\n\t- Event对象的常见应用\r\n\r\n\t\t- 取消事件的默认行为\r\n\r\n\t\t\t- event.preventDefault()\r\n\r\n\t\t- 取消事件的进一步捕获或冒泡\r\n\r\n\t\t\t- event.stopPropagation()\r\n\r\n\t\t- 处理事件响应优先级\r\n\r\n\t\t\t- event.stopImmediatePropagation()\r\n\r\n\t\t- 当前被绑定事件的对象\r\n\r\n\t\t\t- event.currentTarget\r\n\r\n\t\t- 当前被点击的对象\r\n\r\n\t\t\t- event.target\r\n\r\n- 事件的代理\r\n\r\n\t- 原理\r\n\r\n\t\t- 事件代理就是在祖先级DOM元素绑定一个事件，当触发子孙级DOM元素的事件时，利用事件流的原理来触发绑定在祖先级DOM的事件。\r\n\r\n\t- 检查事件源event.target\r\n\r\n### 【面试：JS运行机制】\r\n\r\n- 【面试：JS 执行机制】这一次，彻底弄懂 JavaScript 执行机制\r\n\r\n\t- 关于多线程\r\n\r\n\t\t- 一切javascript版的\"多线程\"都是用单线程模拟出来的\r\n\r\n\t- javascript事件循环\r\n\r\n\t\t- 同步任务\r\n\r\n\t\t\t- 当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。\r\n\r\n\t\t- 异步任务\r\n\r\n\t\t\t- 而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。\r\n\r\n\t\t\t- （1）同步和异步任务分别进入不同的执行\"场所\"，同步的进入主线程，异步的进入Event Table并注册函数。\r\n\t\t\t- （2）当指定的事情完成时，Event Table会将这个函数移入Event Queue（事件队列）。\r\n\t\t\t- （3）主线程内的任务执行完毕为空，会去Event Queue（事件队列）读取对应的回调函数，进入主线程执行。\r\n\t\t\t- （4）上述过程会不断重复，也就是常说的Event Loop(事件循环)。\r\n\r\n\t\t- 怎么知道主线程执行栈为空啊？\r\n\r\n\t\t\t- js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。\r\n\r\n- 【面试：JS 执行机制】从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理\r\n\r\n\t- 区分进程和线程\r\n\r\n\t\t- \r\n- 进程是一个工厂，工厂有它的独立资源 -> 系统分配的内存（独立的一块内存）\r\n\t\t- - 工厂之间相互独立 -> 进程之间相互独立\r\n\t\t- - 线程是工厂中的工人，多个工人协作完成任务 -> 多个线程在进程中协作完成任务\r\n\t\t- - 工厂内有一个或多个工人 -> 一个进程由一个或多个线程组成\r\n\t\t- - 工人之间共享空间 -> 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）\r\n\t\t- 线程与进程\r\n\r\n\t\t\t- \r\n进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）\r\n\t\t\t- 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）\r\n\r\n\t\t- tips\r\n\r\n\t\t\t- \r\n不同进程之间也可以通信，不过代价较大\r\n\t\t\t- 现在，一般通用的叫法：单线程与多线程，都是指在一个进程内的单和多。（所以核心还是得属于一个进程才行）\r\n\r\n\t- 浏览器是多进程的\r\n\r\n\t\t- 初步认知\r\n\r\n\t\t\t- \r\n浏览器是多进程的\r\n\t\t\t- 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）\r\n\t\t\t- 简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。\r\n\r\n\t\t- 浏览器都包含哪些进程？\r\n\r\n\t\t\t- Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有\r\n\r\n\t\t\t\t- 负责浏览器界面显示，与用户交互。如前进，后退等\r\n\t\t\t\t- 负责各个页面的管理，创建和销毁其他进程\r\n\t\t\t\t- 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上\r\n\t\t\t\t- 网络资源的管理，下载等\r\n\r\n\t\t\t- 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建\r\n\t\t\t- GPU进程：最多一个，用于3D绘制等\r\n\t\t\t- 浏览器渲染进程（浏览器内核）（Render进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为页面渲染，脚本执行，事件处理等\r\n\r\n\t\t- 浏览器多进程的优势\r\n\r\n\t\t\t- 避免单个page crash影响整个浏览器\r\n\t\t\t- 避免第三方插件crash影响整个浏览器\r\n\t\t\t- 多进程充分利用多核优势\r\n\t\t\t- 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性\r\n\t\t\t- 简单理解\r\n\r\n\t\t\t\t- 如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。当然，内存等资源消耗也会更大，有点空间换时间的意思。\r\n\r\n\t\t\t\t\t- orw83p\r\n\r\n\t\t- 重点是浏览器内核（Renderer渲染进程）\r\n\r\n\t\t\t- 初步认知\r\n\r\n\t\t\t\t- 对于普通的前端操作来说，最终要的是渲染进程，页面的渲染，JS的执行，事件的循环，都在这个进程内进行\r\n\r\n\t\t\t- 该进程包含线程有：\r\n\r\n\t\t\t\t- GUI渲染线程\r\n\r\n\t\t\t\t\t- 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。\r\n\t\t\t\t\t- 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行\r\n\t\t\t\t\t- 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。\r\n\r\n\t\t\t\t- JS引擎线程\r\n\r\n\t\t\t\t\t- \r\n也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）\r\n\t\t\t\t\t- JS引擎线程负责解析Javascript脚本，运行代码。\r\n\t\t\t\t\t- JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序\r\n\t\t\t\t\t- 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。\r\n\r\n\t\t\t\t- 事件触发线程\r\n\r\n\t\t\t\t\t- \r\n归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）\r\n\t\t\t\t\t- 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中\r\n\t\t\t\t\t- 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理\r\n\t\t\t\t\t- 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）\r\n\r\n\t\t\t\t- 定时触发器线程\r\n\r\n\t\t\t\t\t- \r\n传说中的setInterval与setTimeout所在线程\r\n\t\t\t\t\t- 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）\r\n\t\t\t\t\t- 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）\r\n\t\t\t\t\t- 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。\r\n\r\n\t\t\t\t- 异步http请求线程\r\n\r\n\t\t\t\t\t- \r\n在XMLHttpRequest在连接后是通过浏览器新开一个线程请求\r\n\t\t\t\t\t- 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。\r\n\r\n\t\t- Browser进程和浏览器内核（Renderer进程）的通信过程\r\n\r\n\t\t\t- 初步理解\r\n\r\n\t\t\t\t- \r\n如果自己打开任务管理器，然后打开一个浏览器，就可以看到：任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程）\r\n\r\n\t\t\t- 整个过程\r\n\r\n\t\t\t\t- Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程\r\n\t\t\t\t- Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染\r\n\r\n\t\t\t\t\t- 渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染\r\n\t\t\t\t\t- 当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）\r\n\t\t\t\t\t- 最后Render进程将结果传递给Browser进程\r\n\r\n\t\t\t\t- Browser进程接收到结果并将结果绘制出来\r\n\r\n\t- 梳理浏览器内核中线程之间的关系\r\n\r\n\t\t- GUI渲染线程与JS引擎线程互斥\r\n\r\n\t\t\t- \r\n由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。\r\n\t\t\t- 因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。\r\n\r\n\t\t- JS阻塞页面加载\r\n\r\n\t\t\t- \r\n假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。 然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。\r\n\t\t\t- 所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。\r\n\r\n\t\t- WebWorker，JS的多线程？\r\n\r\n\t\t\t- 初步理解\r\n\r\n\t\t\t\t- 前文中有提到JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？\r\n\r\n\t\t\t- Web Worker\r\n\r\n\t\t\t\t- \r\n创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）\r\n\t\t\t\t- JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）\r\n\t\t\t\t- 所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程，只待计算出结果后，将结果通信给主线程即可，perfect!\r\n\r\n\t\t\t- WebWorker与SharedWorker\r\n\r\n\t\t\t\t- Web Worker\r\n\r\n\t\t\t\t\t- WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享\r\n\t\t\t\t\t- 所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。\r\n\r\n\t\t\t\t- SharedWorker\r\n\r\n\t\t\t\t\t- SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用\r\n\t\t\t\t\t- 所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。\r\n\r\n\t\t\t\t- 本质上就是进程和线程的区别。SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程\r\n\r\n\t- 简单梳理下浏览器渲染流程\r\n\r\n\t\t- 前期工作\r\n\r\n\t\t\t- 浏览器输入url，浏览器主进程接管，开一个下载线程，然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，随后将内容通过RendererHost接口转交给Renderer进程\r\n\r\n- 浏览器渲染流程开始\r\n\r\n\t\t- 浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤\r\n\r\n\t\t\t- 解析html建立dom树\r\n\t\t\t- 解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）\r\n\t\t\t- 布局render树（Layout/reflow），负责各元素尺寸、位置的计算\r\n\t\t\t- 绘制render树（paint），绘制页面像素信息\r\n\t\t\t- 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。\r\n\t\t\t- 渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了\r\n\r\n\t\t- load事件与DOMContentLoaded事件的先后\r\n\r\n\t\t\t- 当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。 (譬如如果有async加载的脚本就不一定完成)\r\n\t\t\t- 当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。 （渲染完毕了）\r\n\t\t\t- 顺序是：DOMContentLoaded -> load\r\n\r\n\t\t- CSS加载（头部引入CSS时）是否会阻塞DOM树渲染？\r\n\r\n\t\t  因为你加载css的时候，可能会修改下面DOM节点的样式，\r\n\r\n\t\t  如果css加载不阻塞render树渲染的话，那么当css加载完之后，\r\n\r\n\t\t  render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。\r\n\r\n\t\t  所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后，\r\n\r\n\t\t  在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。\r\n\r\n\t\t\t- css是由单独的下载线程异步下载的。\r\n\t\t\t- css加载不会阻塞DOM树解析（异步加载时DOM照常构建）\r\n\t\t\t- 但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）\r\n\r\n\t\t- 普通图层和复合图层\r\n\r\n\t\t\t- 浏览器渲染的图层一般包含两大类：普通图层以及复合图层\r\n\t\t\t- 首先，普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中）\r\n\t\t\t- 其次，absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层。\r\n\t\t\t- 然后，可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源 （当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）\r\n\t\t\t- 可以简单理解下：GPU中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒\r\n\t\t\t- 【重点！！！】如何变成复合图层（硬件加速）\r\n\r\n\t\t\t\t- （1）最常用的方式：translate3d、translateZ\r\n\t\t\t\t- （2）opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）\r\n\t\t\t\t- （3）will-chang属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）\r\n\t\t\t\t- （4）<video><iframe><canvas><webgl>等元素\r\n\t\t\t\t- （5）其它，譬如以前的flash插件\r\n\r\n\t\t\t- absolute和硬件加速的区别\r\n\r\n\t\t\t\t- absolute虽然可以脱离普通文档流，但是无法脱离默认复合层。所以，就算absolute中信息改变时不会改变普通文档流中render树，但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。（浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的）\r\n\t\t\t\t- 而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层 （当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）\r\n\r\n\t\t\t- 复合图层的作用？\r\n\r\n\t\t\t\t- 一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能\r\n\t\t\t\t- 但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡\r\n\r\n\t- 从Event Loop谈JS的运行机制\r\n\r\n\t\t- 发生时机\r\n\r\n\t\t\t- 到此时，已经是属于浏览器页面初次渲染完毕后的事情，JS引擎的一些运行机制分析。\r\n\r\n\t\t- Event Loop（事件循环机制的核心是：JS引擎线程和事件触发线程）\r\n\r\n\t\t\t- JS分为同步任务和异步任务\r\n\t\t\t- 同步任务都在主线程上执行，形成一个执行栈\r\n\t\t\t- 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。\r\n\t\t\t- 一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。\r\n\r\n\t\t- 单独说说定时器\r\n\r\n\t\t\t- 为什么需要定时器线程？\r\n\r\n\t\t\t\t- 为什么要单独的定时器线程？因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时。\r\n\r\n\t\t\t- 什么时候会用到定时器线程？\r\n\r\n\t\t\t\t- 当使用setTimeout或setInterval时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。\r\n\r\n\t\t\t- 代码的执行情况\r\n\r\n\t\t\t- setTimeout而不是setInterval\r\n\r\n\t\t\t\t- setTimeout\r\n\r\n\t\t\t\t\t- 每次setTimeout计时到后就会去执行，然后执行一段时间后才会继续setTimeout，中间就多了误差 （误差多少与代码执行时间有关）\r\n\r\n\t\t\t\t- setInterval\r\n\r\n\t\t\t\t\t- setInterval则是每次都精确的隔一段时间推入一个事件 （但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了）\r\n\t\t\t\t\t- JS引擎会对setInterval进行优化，如果当前事件队列中有setInterval的回调，不会重复添加。不过，仍然是有很多问题。。。\r\n\r\n\t\t\t- 事件循环进阶：macrotask与microtask\r\n\r\n\t\t\t\t- 初步认识\r\n\r\n\t\t\t\t\t- \r\nJS中分为两种任务类型：macrotask和microtask，在ECMAScript中，microtask称为jobs，macrotask可称为task\r\n\r\n\t\t\t\t- macrotask（又称之为宏任务）\r\n\r\n\t\t\t\t\t- 可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）\r\n\t\t\t\t\t- 每一个task会从头到尾将这个任务执行完毕，不会执行其它\r\n\t\t\t\t\t- 浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染 （task->渲染->task->...）\r\n\r\n\t\t\t\t- microtask（又称为微任务）\r\n\r\n\t\t\t\t\t- 可以理解是在当前 task 执行结束后立即执行的任务\r\n\t\t\t\t\t- 也就是说，在当前task任务后，下一个task之前，在渲染之前\r\n\t\t\t\t\t- 所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染\r\n\t\t\t\t\t- 也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）\r\n\r\n\t\t\t\t- 什么样的场景会形成macrotask和microtask？\r\n\r\n\t\t\t\t\t- macrotask：主进程，setTimeout，setInterval，setImmediate, I/O, rendering等（可以看到，事件队列中的每一个事件都是一个macrotask）\r\n\t\t\t\t\t- microtask：Promise，process.nextTick，Object.observe, MutationObserver等\r\n\r\n\t\t\t\t- 各自使用时机？\r\n\r\n\t\t\t\t\t- 至于什么时候需要使用 microtask 呢? 我觉得这个问题很好地指出两者(macrotask, microtask)的不同, 在你觉得需要将这个异步任务同步化的时候, 就使用\r\nmicrotask , 否则就使用 macrotask.换种说法, 也就是这个任务你需要尽可能快地执行, 就使用 microtask.\r\n\r\n\t\t\t\t- 补充：在node环境下，process.nextTick的优先级高于Promise，也就是可以简单理解为：在宏任务结束后会先执行微任务队列中的nextTickQueue部分，然后才会执行微任务中的Promise部分。\r\n\t\t\t\t- 小测试加补充：setTimeout触发时机不明，受机器与运行环境影响很大，产生很多不确定的因素。\r\n\r\n### 【异步设计】探寻JavaScript的异步设计（理解性）\r\n\r\n- 开始\r\n\r\n\t- 一切得先从CPU开始讲起，CPU的指令执行速度是远高于硬盘读取速度和主存读取速度的。而I/O操作就会涉及到硬盘存取和主存读取，常见的I/O操作有文件I/O,网络I/O。(I/O = Input / Output)。\r\n\t- 所以，观察以下这一段伪代码：\r\n\r\n\t\t- 在CPU眼中，他会把代码看成这两部分：\r\n\r\n\t\t\t- 绿色部分因为不涉及到I/O操作，所以CPU执行速度超快，但是当运行到红色部分时，却是一个非常耗时的操作，而这段时间，CPU是处于一个’无所事事’的状态（DMA获取总线控制权之后一切I/O与CPU无关），因为文件如果没有读取进来，下面的工作也无法开展。\r\n\r\n\t- 同步在这里的意思，即书写代码的顺序就是代码执行的顺序，如果JavaScript设计成同步的话，那么当执行到openFile这一行的时候，将会等待该I/O操作完成CPU才继续往下执行。\r\n\r\n\t\t- 设想一下，当发送Ajax请求(网络I/O)的时候，整个页面被阻塞无法操作将会是多差的体验。\r\n\t\t- 而诸如鼠标点击事件，滑动事件，失焦事件，在CPU看来，都是处理得特别慢的事件（虽然对我们来说是一瞬间的事情），如果将JavaScript设计成同步，也会特别浪费CPU性能。\r\n\r\n\t- 而阻塞和非阻塞关注CPU在I/O发生时的工作情况\r\n\r\n\t\t- 怎样理解阻塞非阻塞与同步异步的区别？\r\n\r\n\t\t\t- 1.同步与异步\r\n\r\n\t\t\t\t- 概述\r\n\r\n\t\t\t\t\t- 同步和异步关注的是消息通信机制\r\n\r\n\t\t\t\t- 同步\r\n\r\n\t\t\t\t\t- 就是在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了。\r\n\t\t\t\t\t- 换句话说，就是由*调用者*主动等待这个*调用*的结果。\r\n\r\n\t\t\t\t- 异步\r\n\r\n\t\t\t\t\t- 相反，*调用*在发出之后，这个调用就直接返回了，所以没有返回结果。\r\n\t\t\t\t\t- 换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在*调用*发出后，*被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用。\r\n\r\n\t\t\t\t- 举个通俗的例子\r\n\r\n\t\t\t\t\t- 你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下\"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。\r\n\t\t\t\t\t- 而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。\r\n\r\n\t\t\t- 2. 阻塞与非阻塞\r\n\r\n\t\t\t\t- 概述\r\n\r\n\t\t\t\t\t- 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.\r\n\r\n\t\t\t\t- 阻塞\r\n\r\n\t\t\t\t\t- 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。\r\n\r\n\t\t\t\t- 非阻塞\r\n\r\n\t\t\t\t\t- 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。\r\n\r\n\t\t\t\t- 还是上面的例子\r\n\r\n\t\t\t\t\t- 你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果\r\n\t\t\t\t\t- 如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。\r\n\t\t\t\t\t- 在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。\r\n\r\n\t\t\t- 阻塞和非阻塞，应该描述的是一种状态，同步与非同步描述的是行为方式\r\n\r\n\t\t- 阻塞式\r\n\r\n\t\t\t- 在上面这个读取文件的例子中，如果在读取文件的同时，该线程被‘挂起’（可以理解为进程的阻塞态），CPU不在关注这个线程直到结果被返回，属于阻塞式\r\n\r\n\t\t- 非阻塞式\r\n\r\n\t\t\t- 如果在读取文件的同时，CPU会时不时关注并检查一遍结果是否返回，则属于非阻塞式\r\n\r\n\t- 异步则解决了代码被耗时任务阻止其往下执行的缺点\r\n\r\n- 多线程异步有着比较好的解决方案\r\n\r\n\t- （1）给涉及到I/O操作的部分新开一个线程执行\r\n\t- （2）主线程不等待继续往下执行\r\n\t- （3）I/O线程执行完之后将结果写回公共区并通知主线程(也可以是主线程去轮询)\r\n\t- （3）主线程执行其回调\r\n\r\n- JavaScript是一门单线程语言，本身无法提供多线程，那么是通过怎样的机制来实现异步的？\r\n\r\n\t- 先给出答案\r\n\r\n\t\t- JavaScript通过事件循环和浏览器各线程协调共同实现异步\r\n\r\n\t- JavaScript认为任务分为两种\r\n\r\n\t\t- 一种是全由CPU决定完成速度的任务，我们称其为同步任务。\r\n\t\t- 一种是由多种因素（如硬盘读取速度，网速，点击反馈速度）决定完成速度的任务，我们称其为异步任务。\r\n\t\t- 举个简单的例子\r\n\r\n\t\t\t- 函数声明，for循环，变量声明，赋值操作等都可以属于同步任务\r\n\t\t\t- 读取文件，网络请求，网页事件都看做异步任务\r\n\r\n\t- 事件循环\r\n\r\n\t\t- JavaScript将所有的异步任务都会放进一个队列里面，在执行完所有的同步任务之后，会去队列中找到最先进入队列的异步任务执行。\r\n\r\n\t\t- 仔细观察上图，结合浏览器多线程设计：\r\n\r\n\t\t\t- JavaScript线程首先执行同步任务\r\n\t\t\t- 在执行完同步任务之后，会去异步任务队列的队头取出任务执行\r\n\t\t\t- 浏览器各个线程会在事件触发且完成事件之后将回调函数写入异步队列（先进先出队列）\r\n\r\n\t\t- 事件循环\r\n\r\n\t\t\t- 因为诸如事件触发，http请求都是耗时无法直接确定的任务，也就是说JavaScript线程无法得知异步的任务回调函数究竟什么时候会写入异步任务队列，那么这个地方，就需要一个机制，去时刻轮询这个任务队列，这就是事件循环(event loop)\r\n\r\n- 讨论下为什么这样设计\r\n\r\n\t- 因为JavaScript的工作环境是一个典型的异步应用场景：充斥着各种ajax事件和浏览器事件。各个事件的触发时间和得到反馈的时间都不得而知，如果设计成同步语言，将会带来极差的浏览器使用体验。\r\n\t- 浏览器需要做的事情太多了，一手需要负责渲染，一手需要负责http请求，一手还需要执行JavaScript，将JavaScript设计成单线程不仅能够让浏览器更好地控制各个线程，同时对开发者来说也更简单。多线程涉及到锁，临界区，冲突解决的学习成本还是比较高的。\r\n\r\n### 【执行机制】JS执行机制与异步队列\r\n\r\n- Event Loop\r\n\r\n\t- 一个 Event Loop 中，可以有一个或者多个任务队列(task queue)，一个任务队列便是一系列有序任务(task)的集合；每个任务都有一个任务源(task source)，源自同一个任务源的 task 必须放到同一个任务队列，从不同源来的则被添加到不同队列。\r\n\r\n- 每一次循环tick，分为四个关键步骤\r\n\r\n\t- 在此次 tick 中选择最先进入队列的任务(oldest task)，如果有则执行(一次)\r\n\t- 检查是否存在 Microtasks，如果存在则不停地执行，直至清空 Microtasks Queue\r\n\t- 更新 render\r\n\t- 主线程重复执行上述步骤\r\n\r\n- 任务可分为 （macro）task 和 microtask 两类\r\n\r\n\t- 不同的API注册的异步任务会依次进入自身对应的队列中，然后等待 Event Loop 将它们依次压入执行栈中执行。\r\n\t- (marco)task主要包括\r\n\r\n\t\t- script(整体代码)、setTimeout、setInterval、I/O、UI交互事件、setImmediate(Node.js 环境)\r\n\r\n\t- microtask主要包含\r\n\r\n\t\t- Promise、MutaionObserver、process.nextTick(Node.js 环境)\r\n\r\n- 任务源\r\n\r\n\t- setTimeout/Promise 等API便是任务源，而进入任务队列的是他们指定的具体执行任务。来自不同任务源的任务会进入到不同的任务队列。其中setTimeout与setInterval是同源的。\r\n\r\n- 示例\r\n\r\n\t- 代码\r\n\r\n\t- 步骤\r\n\r\n\t\t- （1）事件循环从宏任务(macrotask)队列开始，这个时候，宏任务队列中，只有一个script(整体代码)任务；当遇到任务源(task source)时，则会先分发任务到对应的任务队列中去。\r\n\r\n\t\t- （2）然后遇到了 console 语句，直接输出 script start。输出之后，script 任务继续往下执行，遇到 setTimeout，其作为一个宏任务源，则会先将其任务分发到对应的队列中：\r\n\r\n\t\t- （3）script 任务继续往下执行，遇到 Promise 实例。Promise 构造函数中的第一个参数，是在 new 的时候执行，构造函数执行时，里面的参数进入执行栈执行；而后续的 .then 则会被分发到 microtask 的 Promise 队列中去。所以会先输出 promise1，然后执行 resolve，将 then1 分配到对应队列。\r\n\r\n构造函数继续往下执行，又碰到 setTimeout，然后将对应的任务分配到对应队列：\r\n\r\n\t\t- （4）script任务继续往下执行，最后只有一句输出了 script end，至此，全局任务就执行完毕了。\r\n\r\n根据上述，每次执行完一个宏任务之后，会去检查是否存在 Microtasks；如果有，则执行 Microtasks 直至清空 Microtask Queue。\r\n\r\n因而在script任务执行完毕之后，开始查找清空微任务队列。此时，微任务中，只有 Promise 队列中的一个任务 then1，因此直接执行就行了，执行结果输出 then1。当所有的 microtast 执行完毕之后，表示第一轮的循环就结束了。\r\n\r\n\t\t- （5）这个时候就得开始第二轮的循环。第二轮循环仍然从宏任务 macrotask开始。此时，有两个宏任务：timeout1 和 timeout2。\r\n\r\n取出 timeout1 执行，输出 timeout1。此时微任务队列中已经没有可执行的任务了，直接开始第三轮循环：\r\n\r\n\t\t- （6）第三轮循环依旧从宏任务队列开始。此时宏任务中只有一个 timeout2，取出直接输出即可。\r\n\r\n这个时候宏任务队列与微任务队列中都没有任务了，所以代码就不会再输出其他东西了。那么例子的输出结果就显而易见：\r\n\r\n- Promise的特殊情况\r\n\r\n\t- 代码\r\n\r\n\t- 结果\r\n\r\n\t\t- 4321\r\n\r\n\t- 为什么 t2 会先执行呢？理由如下：\r\n\r\n\t\t- 实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行\r\n\t\t- Promise.resolve 方法允许调用时不带参数，直接返回一个resolved 状态的 Promise 对象。立即 resolved 的 Promise 对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。\r\n\r\n## 生成器\r\n\r\n### 打破完整运行\r\n\r\n- 一个假定：一个函数一旦开始执行,就会运行到结束,期间不会有其他代码能够打断它并插入其间\r\n- ES6 引入了一个新的函数类型,它并不符合这种运行到结 束的特性。这类新的函数被称为生成器\r\n- 生成器就是一类特殊的函数,可以一次或多次启动和停止,并不一定非得要完成\r\n- 除了能够接受参数并提供返回值之外,生成器甚至提供了更强大更引人注目的内建消息输 入输出能力\r\n- :每次构建一个 迭代器 ,实际上就隐式构建了生 成器的一个实例,通过这个 迭代器 来控制的是这个生成器实例\r\n\r\n### 生成器产生值\r\n\r\n- 迭代器 是一个定 义良好的接口, 用于从一个生产者一步步得到一系列值\r\n- 的一个术语是 iterable (可迭代),即指一个包含可以在迭代器的值上迭代的迭代器的对象\r\n- iterable 必须支持一个函数,其名称 是专门的 ES6 符号值 Symbol.iterator 。 调用这个函数时, 它会返回一个迭代器\r\n- 把生成器看作一个值的生产 者,我们通过迭代器接口的 next() 调用一次提取出一个值\r\n- for..of 循环的“异常结束”(也就是“提前终 止”),通常由 break 、 return 或者未捕获异常引起,会向生成器的迭代器发送一个信号使 其终止\r\n- 可以在外部通过 return(..) 手工终止生成器的迭代器实例\r\n\r\n###  异步迭代生成器\r\n\r\n- 异步作为实现细节抽象了出去,使得我们可以以同步顺序的形式追 踪流程控制\r\n- 不仅能够从异步函数调用得到看似同步的返回值,还 可以同步捕获来自这些异步函数调用的错误\r\n\r\n### 生成器 +Promise\r\n\r\n- 获得 Promise 和生成器最大效用的最自然的方法就 是 yield 出来一个 Promise, 然后通过这个 Promise 来控制生成器的迭代器\r\n- await 了一个 Promise, async 函数就会自动获知要做什么,它会暂停这个函数(就 像生成器一样),直到 Promise 决议\r\n- Promise 所有的并发能力在生成器 +Promise 方法中都可以使用\r\n- 使用生成器实现异步的方法的全部要点在于创建简单、顺序、看似同步的代码,将异步的 细节尽可能隐藏起来\r\n\r\n### 生成器委托\r\n\r\n- 从一个生成器调用另一个生成器,使用辅助函数 run()\r\n- yield 委托 的具体语法是: yield * __(注意多出来的 * )\r\n- yield 委托的主要目的是代码组织,以达到与普通函数调用的对称\r\n- 保持生成器分离有助于程序的可读性、可维护性和可调试性\r\n- yield 委托是如何不只用于迭代器控制工作,也用于双向消息传递工 作的呢\r\n- 错误和异常也是双向传递的\r\n-  异步委托\r\n\r\n\t- 调用 yield *function()\r\n\r\n- 递归委托\r\n\r\n\t- 使用 委托实现异步的生成器 递归 ,即一个 yield 委托到它自身的生成器\r\n\r\n### 生成器并发\r\n\r\n- 两个实例 都是各自的响应一回来就取得了数据, 然后每个实例再次 yield , 用于控制传递的目的\r\n- runAll(..) 的工具\r\n\r\n### 形实转换程序\r\n\r\n- JavaScript 中的 thunk 是指一个用于调用另外一个函数的函数,没有任何参数\r\n- 你用一个函数定义封装函数调用,包括需要的任何参数,来定义这个调用的执 行,那么这个封装函数就是一个形实转换程序之后在执行这个 thunk 时,最终就是调用 了原始的函数\r\n\r\n### ES6 之前的生成器\r\n\r\n- 手工转换\r\n\r\n\t- 生成器是如何 工作的推导练习\r\n\r\n- 自动转换\r\n\r\n\t- 自动把 ES6 生成器转化为前面小节中我们推导出来的 结果那样的生成器的代码\r\n\r\n## 混合对象“类”\r\n\r\n### 类理论\r\n\r\n- 数据结构：把数据以及和它相关的行为打包\r\n- 面向对象编程\r\n\r\n\t- 实例化\r\n\t- 继承\r\n\t- 多态\r\n\t- 多态\r\n\r\n### JavaScript中的 “ 类 ”\r\n\r\n-  JavaScript 只有一些近似类的语法元素（语法糖）\r\n\r\n### 类的机制\r\n\r\n- “类”和“实例”\r\n\r\n\t- 建筑蓝图和实际建筑\r\n\r\n- 类的继承\r\n\r\n\t- 继承通用 的特性并根据自身类别修改某些特性\r\n\r\n- 多态\r\n\r\n\t- 多态性取决于你是在哪个类的实例中引用它\r\n\r\n- 多重继承\r\n\r\n### 在继承或者实例化时JavaScript 的对象机制并不会 自动 执行复制行为，它们会被 关联起来\r\n\r\n## 继承\r\n\r\n### 【继承】JavaScript 各种继承方式优缺点对比\r\n\r\n- （1）原型对象\r\n\r\n\t- 1.无论什么时候，只要创建一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性指向 prototype 属性所在的函数。\r\n\r\n\t- 2.当我们用构造函数创建一个实例时，也会为这个实例创建一个 __proto__ 属性，这个__proto__ 属性是一个指针指向构造函数的原型对象\r\n\r\n- （2）重写原型对象\r\n\r\n\t- 我们经常用一个包含所有属性和方法的对象字面量来重写整个原型对象\r\n\t- 如果将 Person.prototype 设置为一个新对象，而这个对象中没有constructor属性，这导致 constructor 属性不再指向 Person，而是指向 Object。\r\n\r\n\t- 所以如果 constructor 的值很重要，我们可以像下面这样特意将它设置回设置回适当的值\r\n\r\n- （3）原型链及原型链继承\r\n\r\n\t- 解释清楚\r\n\r\n\t\t- 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针(constructor)，而实例都包含一个指向原型对象的内部指针(__proto__)。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个构造函数的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。\r\n\r\n\t- 例子\r\n\r\n\t\t- 理解\r\n\r\n\t\t\t- 上面的代码中Sub.prototype = new Super();通过创建Super的实例，并将该实例赋值给Sub.prototype来实现继承。此时存在于Super的实例和原型对象中的所有属性和方法，也都存在于Sub.prototype中。instanse的__proto__属性指向Sub的原型对象Sub.prototype，Sub原型对象的__proto__属性又指向Super的原型对象Super.prototype。\r\n\r\n\t- 1.原型链搜索机制\r\n\r\n\t\t- 当访问一个实例的属性时，首先会在该实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链继承的情况下，搜索过程就得以沿着原型链继续向上查找，直到找到该属性为止，或者搜索到最高级的原型链Object.prototype中，任然没有找到则返回undefined。就拿上面的例子来说，调用instance.getSuperValue()会经历三个搜索步骤：1）搜索实例；2）搜索Sub.prototype;3）搜索Super.prototype，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链的末端才会停下。\r\n\r\n\t- 2.原型链继承的缺陷\r\n\r\n\t\t- 理解\r\n\r\n\t\t\t- 原型链继承最大的问题是来自包含引用类型值的原型。引用类型值的原型属性会被所有实例共享。而这正是为什么要在构造函数中，而不是原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。\r\n\r\n\t\t- 例子\r\n\r\n\t\t\t- 解释\r\n\r\n\t\t\t\t- 上面的代码中，Super 构造函数定义了一个colors 属性，该属性是一个数组。Super 的每个实例都会有各自包含自己数组的colors 属性。当Sub 通过原型链继承了Super之后，Sub.prototype 就变成了Super 的一个实例，因此它也拥有了一个它自己的colors 属性。结果是所有的Sub 实例都会共享这一个colors 属性。\r\n\r\n\t\t- 原型链的第二个问题是没有办法在不影响所有对象实例的情况下，给超类的构造函数传递参数。\r\n\r\n- （4）构造函数继承（经典继承）\r\n\r\n\t- 理解\r\n\r\n\t\t- 即在子类构造函数的中调用父类构造函数，此时当构建一个子类实例时，此实例也会拥有父类实例的属性和方法。\r\n\r\n\t- 例子\r\n\r\n\t\t- 解释\r\n\r\n\t\t\t- 上面的代码，当构建Sub的实例时，也会调用Super 的构造函数，这样就会在新Sub对象上执行Super()函数中定义的所有对象初始化代码。结果，Sub 的每个实例就都会具有自己的colors 属性的副本了。\r\n\r\n\t- 构造函数继承的缺陷\r\n\r\n\t\t- 如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数服用就无从谈起。而且，在超类原型中定义的方法，对子类而已也是不可见的。\r\n\r\n- （5）组合继承\r\n\r\n\t- 原理\r\n\r\n\t\t- 是指将原型链和构造函数的相结合，发挥二者之长的一种继承模式。其思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，即通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。\r\n\r\n\t- 例子\r\n\r\n\t\t- 解释\r\n\r\n\t\t\t- 在上面的例子中，Sup构造函数定义了两个属性：name和colors。Sup的原型定义了一个方法sayName()。Sub构造函数在调用Sup构造函数时传入了name参数，紧接着又定义了它自己的属性age。然后，将Sup的实例赋值给Sub的原型，然后又在该新原型上定义了sayAge()方法。这样就可以让两个不同的Sub 实例即分别拥有自己的属性————包括colors 属性，又可以使用相同的方法了。\r\n\t\t\t- 组合继承避免了原型链和构造函数的缺陷，融合了它们的优点，是JavaScript中最常用的继承模式。\r\n\r\n\t- 美中不足\r\n\r\n\t\t- 上面的代码中调用了两次父类构造函数。Sub.prototype = new Super(); 第一次调用父类构造函数时，将Sup父类构造函数的实例赋值给了Sub子类的原型对象Sub.prototype。此时也会将父类构造函数实例上的属性赋值给子类的原型对象Sub.prototype。而第二次是在子类的构造函数中调用父类的构造函数 Super.call(this)，此时会将父类构造函数实例上的属性赋值给子类的构造函数的实例。根据原型链搜索原则，实例上的属性会屏蔽原型链上的属性。因此我们没有必要将父类构造函数实例的属性赋值给子类的原型对象，这是浪费资源而又没有意义的行为。\r\n\r\n- （6）优化后的组合继承\r\n\r\n\t- 例子一\r\n\r\n\t\t- 解释\r\n\r\n\t\t\t- 上面的例子通过将父类的原型对象直接赋值给一个中间构造函数的原型对象，然后将这个中间构造函数的实例赋值给子类的原型对象Sub.prototype，从而完成原型链继承。它的高效性体现在只调用了一个父类构造函数Super，并且原型链保持不变。\r\n\r\n\t- 例子二\r\n\r\n\t\t- 解释\r\n\r\n\t\t\t- 还有一种简便的写法是采用ES5的Object.create()方法来替代中间构造函数，其实原理都是一样的\r\n\r\n- （7）更简单的继承方式\r\n\r\n\t- 简要理解\r\n\r\n\t\t- 直接将子类的原型对象(prototype)上的__proto__指向父类的的原型对象(prototype)，这种方式没有改变子类的原型对象，所\b以子类原型对象\b上的constructor属性还是\b指向子类的构造函数，而且当子类的实例在子类的原型对象上没有搜索到\b对应的属性或方法时，它会通过子类原型对象上的__proto__属性，继续在父类的\b原型对象上搜索对应的属性或方法\r\n\r\n\t- 例子\r\n\r\n- （8）Object.setPrototypeOf()\r\n\r\n\t- 理解\r\n\r\n\t\t- Object.setPrototypeOf()是ECMAScript 6最新草案中的方法，相对于 Object.prototype.proto ，它被认为是修改对象原型更合适的方法\r\n\r\n\t- 例子\r\n\r\n- （9）类的静态方法继承\r\n\r\n\t- 理解\r\n\r\n\t\t- 上面所有的继承方法都没有实现类的静态方法继承，而在ES6的class继承中，子类是可以继承父类的静态方法的。我们可通过Object.setPrototypeOf()来实现类的静态方法继承，非常简单\r\n\r\n\t- 例子\r\n\r\n### JavaScript8种继承方式\r\n\r\n- 继承需要实现两点\r\n\r\n\t- 父类实例上的属性和方法\r\n\t- 父类原型对象上的属性和方法\r\n\r\n- 原型链继承\r\n\r\n\t- 关键代码\r\n\r\n\t\t- p = new Parent('father');\r\n\t\t- Child.prototype = p;\r\n\r\n\t- 优点\r\n\r\n\t\t- 可以调用原型链上的方法\r\n\t\t- 可以获取父类实例的属性\r\n\t\t- 可以直接修改父类实例属性\r\n\t\t- 可以通过子类实例修改父类上的引用类型\r\n\r\n\t- 缺点\r\n\r\n\t\t- 修改父类实例属性，所有原型链上的对象的属性都会被影响\r\n\t\t- 修改父类实例引用类型，其他对象也会受影响\r\n\t\t- 调用子类构造函数时，不能像父类构造函数传递参数\r\n\r\n- 借用构造函数继承\r\n\r\n\t- 关键代码\r\n\r\n\t\t- function Child(name) {\r\n  Parent.call(this, name)\r\n}\r\n\r\n\t- 关键思路\r\n\r\n\t\t- 把本来父类构造函数中指向父类实例的this，通过在子类构造函数中call(this)把上下文修改为子类实例。也就是把父类实例的属性复制一份给子类实例\r\n\r\n\t- 优点\r\n\r\n\t\t- 可以在call()中向父类构造函数传递参数\r\n\t\t- 可以访问父类实例上的属性，但是是自己的，并不是._proto_指向的。\r\n\t\t- 修改父类属性不会影响其他子类实例\r\n\r\n\t- 缺点\r\n\r\n\t\t- 因为没有原型链，所以子类实例实际上是不能访问到父类原型对象上的属性和方法\r\n\t\t- 每次创建一次实例都会创建一遍构造函数的方法\r\n\t\t- 方法都在构造函数中定义，因此，函数的复用就无从谈起。\r\n\r\n- 组合继承\r\n\r\n\t- 关键代码\r\n\r\n\t\t- 1.借用构造函数\r\n\r\n\t\t\t- function Child1(name) {\r\n  Father.call(this, name)\r\n  // 注意，要先 call 父构造函数，再定义子类实例自己的属性\r\n  // 否则子类实例属性会被父类实例同名属性覆盖\r\n  this.age = 10\r\n}\r\n\r\n\r\n\t\t- 2.添加原型链\r\n\r\n\t\t\t- \r\n// 修改原型对象\r\nChild1.prototype = f\r\n// 修改原型对象的构造函数\r\nChild1.prototype.constructor = Child1\r\n\r\n\t- 关键思想\r\n\r\n\t\t- 复制一份父类实例的属性到子类实例上\r\n\t\t- 将子类实例添加到原型链上\r\n\r\n\t- 优点\r\n\r\n\t\t- 可以向父类构造函数传参\r\n\t\t- 可以通过原型链访问父类属性\r\n\t\t- 可以修改父类属性而不影响其他子类实例\r\n\r\n\t- 缺点\r\n\r\n\t\t- 会调用两次父构造函数。\r\n\t\t- 一个子类实例将会持有两份父类实例的数据。\r\n\r\n- 原型式继承\r\n\r\n\t- 关键思想\r\n\r\n\t\t- 比较原型链继承\r\n\r\n\t\t\t- 原型链继承，是先在子类构造函数定义好了实例属性，再new一个父类实例，把子类构造函数的原型指向该实例\r\n\t\t\t- 原型式继承，已经有了一个父类实例，最后也同样把子类构造函数的原型指向该实例，只不过在中间定义子类构造函数的时候，定义了一个空的函数\r\n\r\n\t- 关键代码\r\n\r\n\t\t- 通过Object.create()来创建子类实例\r\n\r\n\t\t\t- // 为一个对象生成子类实例的函数。其实 Object.create() 就是这样实现的\r\nfunction object(obj){\r\n  // 传入的参数 obj 就相当于是父类实例\r\n  // F 就相当于子类构造函数，不过是空的，啥也没\r\n  function F(){}\r\n  // 把子类构造函数的原型对象设置为父类实例\r\n  F.prototype = obj\r\n  // 调用子类构造函数，创建一个实例并返回\r\n  return new F()\r\n}\r\n\t\t\t- // 为一个对象生成子类实例的函数。其实 Object.create() 就是这样实现的\r\nfunction object(obj){\r\n  // 传入的参数 obj 就相当于是父类实例\r\n  // F 就相当于子类构造函数，不过是空的，啥也没\r\n  function F(){}\r\n  // 把子类构造函数的原型对象设置为父类实例\r\n  F.prototype = obj\r\n  // 调用子类构造函数，创建一个实例并返回\r\n  return new F()\r\n}\r\n\r\n\t- 缺点\r\n\r\n\t\t- 子类修改引用类型，父类的引用属性也会改变\r\n\r\n\t- 优点\r\n\r\n\t\t- 与原型链继承最大的区别就是在定义子类构造函数的时候定义了一个空函数\r\n\t\t- 在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的。\r\n\r\n- 混入式继承mixin\r\n\r\n\t- 说白了就是把一个对象的属性复制到另一个对象上去。\r\n\t- 通过混入的方式为子类实例添加父类原型对象的属性\r\n\r\n\t\t- // 创建一个没有实例属性的 Mother 的实例\r\nm = Object.create(Mother.prototype)\r\n// 修改 Me 的原型对象，现在 Me 位于 Mother 实例的原型链上了\r\nMe.prototype = m\r\n// 修改构造函数\r\nMe.prototype.constructor = Me\r\n// 再把 Father 原型对象上的属性方法复制到 Me 的原型对象 m 上\r\n// 现在，虽然 Me 的实例并不在 Father 实例的原型链上\r\n// 但是也可以访问 Father.prototype 上的属性方法\r\nObject.assign(Me.prototype, Father.prototype)\r\n\r\nme = new Me()\r\nconsole.log(me)\r\n\r\n- ES6 extends\r\n\r\n\t- 实现思路和寄生组合继承是一样的\r\n\r\n- 寄生组合式继承\r\n\r\n\t- 关键思路\r\n\r\n\t\t- 利用Object.create()的“使用现有的对象来提供新建对象的_proto_”特性，来消除组合式继承的子类具有两份父类属性的缺点\r\n\t\t- 这两份数据中，通过 Father.call(this) 复制到子类实例 c 上的这一份是真正需要的，而 c.__proto__ 上的这一份是多余的，是把子类实例放到原型链上时产生的副作用。\r\n\t\t- 让子类实例在原型链上，但是不能让父类实例的属性位于原型链上\r\n\r\n\t- 关键代码\r\n\r\n\t\t- function Parent(name) {\r\n  this.name = name\r\n  this.age = 40\r\n  this.relation = ['grandma', 'grandpa']\r\n}\r\nParent.prototype.say = function () {\r\n  console.log(this.name)\r\n}\r\nfunction Child(name) {\r\n  Parent.call(this, name)\r\n}\r\n\r\n// 开始实现继承\r\n// Object.create 创建没有实例属性的父类实例\r\np = Object.create(Parent.prototype)\r\n// 修改子类构造函数原型对象\r\nChild.prototype = p\r\n// 这里的 p 只是个普通对象，没有 constructor 属性，手动添加一下\r\np.constructor = Child\r\n\r\n- 寄生式继承\r\n\r\n\t- 关键思路\r\n\r\n\t\t- 在原型式继承生成子类实例后，在返回之前处理了子类实例，增加了一些属性或方法\r\n\r\n\t- 代码\r\n\r\n\t\t- 关键代码\r\n\r\n\t\t\t- function createAnother(original){\r\n  // 使用前面的 object 函数，生成了一个子类实例\r\n  var clone = object(original)\r\n  // 先在子类实例上添加一点属性或方法\r\n  clone.sayHi = function(){\r\n    console.log(\"hi\")\r\n  }\r\n  // 再返回\r\n  return clone\r\n}\r\n\r\n### 行为委托（原型继承）\r\n\r\n- 面向委托（原型）的设计\r\n\r\n\t- JavaScript中这个机制（原型继承）的本质就是 对象之间的关联关系 。\r\n\t- 关联风格\r\n\r\n\t\t- 委托中最好把状态保存在委托者（原型）上\r\n\t\t- 避免在原型链的不同级别中使用相同的命名\r\n\t\t- 静止相互委托\r\n\r\n- 类与对象\r\n\r\n\t- 传统的类与对象的开发，需要在父类中定义基础方，然后在子类中重写（丑陋的伪多态）\r\n\t- 委托控件，在对象之间建立关联，定义不同的具有描述性的方法名\r\n\r\n- 提升\r\n\r\n\t- 更简洁的设计\r\n\r\n\t- 内省\r\n\r\n\t\t- 自省就是检查实例的类型\r\n\r\n",kr={data:function(){return{MainComponent:_r}}},jr=kr,wr=Object(m["a"])(jr,vr,Sr,!1,null,"1bd0ab0c",null),xr=wr.exports,Tr=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},Cr=[],Mr="# es6\r\n\r\n## let 和 const 命令\r\n\r\n### let 命令\r\n\r\n- 声明的变量，只在let命令所在的代码块内有效\r\n- for循环的计数器，就很合适使用let命令\r\n- let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错\r\n- 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响\r\n- 如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域\r\n- “暂时性死区”也意味着typeof不再是一个百分之百安全的操作\r\n- let不允许在相同作用域内，重复声明同一个变量\r\n- ES6 引入了块级作用域，明确允许在块级作用域之中声明函数\r\n\r\n### const 命令\r\n\r\n- const声明一个只读的常量。一旦声明，常量的值就不能改变\r\n- const一旦声明变量，就必须立即初始化，不能留到以后赋值\r\n- const的作用域与let命令相同：只在声明所在的块级作用域内有效\r\n- const命令声明的常量也是不提升，同样存在暂时性死区\r\n- const声明的常量，也与let一样不可重复声明\r\n- const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。\r\n- ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令\r\n后面章节还会提到，另外两种声明变量的方法：import命令和class命令\r\n\r\n### 顶级对象属性\r\n\r\n- var命令和function命令声明的全局变量，依旧是顶层对象的属性；\r\n- 另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性\r\n\r\n## 变量的解构赋值\r\n\r\n### 数组的解构赋值\r\n\r\n- ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构\r\n- 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值\r\n- 如果解构不成功，变量的值就等于undefined\r\n- 不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组\r\n- 对于 Set 结构，也可以使用数组的解构赋值\r\n- 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值\r\n- 解构赋值允许指定默认值\r\n\r\n\t- 只有当一个数组成员严格等于undefined，默认值才会生效\r\n\r\n- 默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值\r\n\r\n### 对象的解构赋值\r\n\r\n- 对象的属性没有次序，变量必须与属性同名，才能取到正确的值\r\n- 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量\r\n- 与数组一样，解构也可以用于嵌套结构的对象\r\n- 对象的解构也可以指定默认值\r\n\r\n\t- 默认值生效的条件是，对象的属性值严格等于undefined\r\n\r\n- 如果解构失败，变量的值等于undefined\r\n- 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错\r\n- 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构\r\n\r\n### 字符串的解构赋值\r\n\r\n- 字符串被转换成了一个类似数组的对象\r\n- 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值\r\n\r\n### 数值和布尔值的解构赋值\r\n\r\n- 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象\r\n- 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象\r\n- 由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错\r\n\r\n### 函数参数的解构赋值\r\n\r\n- undefined就会触发函数参数的默认值\r\n\r\n### 圆括号问题\r\n\r\n- ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号\r\n- 建议只要有可能，就不要在模式中放置圆括号\r\n- 可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。\r\n\r\n### 用途\r\n\r\n- 交换变量的值\r\n- 从函数返回多个值\r\n- 函数参数的定义\r\n- 提取 JSON 数据\r\n- 函数参数的默认值\r\n- 遍历 Map 结构\r\n- 输入模块的指定方法\r\n\r\n### 变量的结构赋值\r\n\r\n- 数组\r\n\r\n\t- 解析不成功值就是undefined\r\n\t- 不完全结构，结构依然可以成功\r\n\t- 不是可遍历结构报错\r\n\t- 允许指定默认值、===判断undefined时赋值\r\n\t- 按次序\r\n\r\n- 对象\r\n\r\n\t- 变量名必须与属性名同名\r\n\t- 解构失败时为undefined\r\n\t- 解构赋值可以取到继承的属性\r\n\t- 结构模式时嵌套的对象，子对象所在的父属性不存在，那么将会报错\r\n\t- 对象也可以指定默认值\r\n\t- 以申明的变量用于解构赋值要加圆括号\r\n\t- 数组时特殊的对象，因此可以对数组进行对象的属性的解构\r\n\r\n- 字符串\r\n\r\n\t- 字符串被转换成一个类似的数组对象\r\n\t- 有length属性，可以对这个属性赋值\r\n\r\n- 数值和布尔值\r\n\r\n\t- 如果等号右边是数值和布尔值，则会先转为对象\r\n\r\n\t\t- let {toString: s} = 123;\r\ns === Number.prototype.toString // true\r\n\t\t- let {toString: s} = true;\r\ns === Boolean.prototype.toString // true\r\n\r\n\t- 由于undefined和null无法转为对象，所以对它们进行解构赋值会报错\r\n\r\n- 函数参数\r\n- 圆括号\r\n\r\n\t- 不适用\r\n\r\n\t\t- 变量声明语句\r\n\t\t- 函数参数\r\n\t\t- 赋值语句的模式\r\n\r\n\t- 适用\r\n\r\n\t\t- 赋值语句的非模式部分\r\n\r\n- 用途\r\n\r\n\t- 交换变量的值\r\n\t- 从函数返回多个值\r\n\t- 函数参数的定义\r\n\t- 提取JSON数据\r\n\t- 函数参数的默认值\r\n\t- 遍历Map结构\r\n\r\n\t\t- let [key,value] of map\r\n\r\n\t- 输入模块的指定方法\r\n\r\n## 字符串的扩展\r\n\r\n### 字符的 Unicode 表示法\r\n\r\n- JavaScript 允许采用\\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点\r\n- ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符\r\n\r\n### codePointAt()\r\n\r\n- JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节\r\n- 对于这种4个字节的字符，charAt方法无法读取整个字符，charCodeAt方法只能分别返回前两个字节和后两个字节的值\r\n- ES6 提供了codePointAt方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。\r\n- 对于那些两个字节储存的常规字符，它的返回结果与charCodeAt方法相同\r\n- codePointAt方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString方法转换一下\r\n\r\n### String.fromCodePoint()\r\n\r\n- ES5 提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字符\r\n- ES6 提供了String.fromCodePoint方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode方法的不足\r\n- 如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回\r\n\r\n### 字符串的遍历器接口\r\n\r\n- ES6 为字符串添加了遍历器接口，使得字符串可以被for...of循环遍历\r\n- 这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点\r\n\r\n### at()\r\n\r\n- ES5 对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符\r\n- 有一个提案，提出字符串实例的at方法，可以识别 Unicode 编号大于0xFFFF的字符，返回正确的字符\r\n\r\n### normalize()\r\n\r\n- ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化\r\n\r\n### includes(), startsWith(), endsWith()\r\n\r\n- JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中\r\n- includes()：返回布尔值，表示是否找到了参数字符串\r\n- startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部\r\n- endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部\r\n\r\n### repeat()\r\n\r\n- repeat方法返回一个新字符串，表示将原字符串重复n次\r\n- 参数如果是小数，会被取整\r\n- 如果repeat的参数是负数或者Infinity，会报错\r\n- 如果参数是 0 到-1 之间的小数\r\n\r\n### padStart()，padEnd()\r\n\r\n- 如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全\r\n- padStart和padEnd一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串\r\n- 如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串\r\n- 如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串\r\n- 如果省略第二个参数，默认使用空格补全长度\r\n\r\n### matchAll()\r\n\r\n- matchAll方法返回一个正则表达式在当前字符串的所有匹配\r\n\r\n### 模板字符串\r\n\r\n- 模板字符串（template string）是增强版的字符串，用反引号（`）标识\r\n- 如果在模板字符串中需要使用反引号，则前面要用反斜杠转义\r\n- 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中\r\n- 模板字符串中嵌入变量，需要将变量名写在${}之中\r\n- 模板字符串之中还能调用函数\r\n- 模板字符串甚至还能嵌套。\r\n\r\n### 实例：模板编译\r\n\r\n- 该模板使用<%...%>放置 JavaScript 代码，使用<%= ... %>输出 JavaScript 表达式\r\n\r\n### 标签模板\r\n\r\n- “标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容\r\n\r\n### String.raw()\r\n\r\n- String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）\r\n的字符串，对应于替换变量后的模板字符串\r\n\r\n### 模板字符串的限制\r\n\r\n- 模板字符串默认会将字符串转义，导致无法嵌入其他语言\r\n\r\n## 正则的扩展\r\n\r\n### RegExp 构造函数\r\n\r\n- 第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符\r\n- 第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝\r\n- ES5 不允许此时使用第二个参数添加修饰符，否则会报错\r\n- ES6 改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符\r\n\r\n### 字符串的正则方法\r\n\r\n- 字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()\r\n\r\n### u 修饰符\r\n\r\n- ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\\uFFFF的 Unicode 字符\r\n- 点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符\r\n- 对于码点大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符\r\n- ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词\r\n- 使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的 Unicode 字符\r\n- u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的 Unicode 字符\r\n\r\n### RegExp.prototype.unicode 属性\r\n\r\n- 正则实例对象新增unicode属性，表示是否设置了u修饰符\r\n\r\n### y 修饰符\r\n\r\n- ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符\r\n\r\n### RegExp.prototype.sticky 属性\r\n\r\n- 与y修饰符相匹配，ES6 的正则实例对象多了sticky属性，表示是否设置了y修饰符\r\n\r\n### RegExp.prototype.flags 属性\r\n\r\n- ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符\r\n\r\n### s 修饰符：dotAll 模式\r\n\r\n- 正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外\r\n- 一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符\r\n- 这被称为dotAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式\r\n\r\n### 后行断言\r\n\r\n- ”先行断言“指的是，x只有在y前面才匹配，必须写成/x(?=y)/\r\n- “后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成/(?<=y)x/\r\n\r\n### Unicode 属性类\r\n\r\n- ES2018 引入了一种新的类的写法\\p{...}和\\P{...}，允许正则表达式匹配符合 Unicode 某种属性的所有字符\r\n\r\n### 具名组匹配\r\n\r\n- 正则表达式使用圆括号进行组匹配\r\n- 有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值\r\n- 如果要在正则表达式内部引用某个“具名组匹配”，可以使用\\k<组名>的写法\r\n\r\n### String.prototype.matchAll\r\n\r\n- 如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出\r\n\r\n## 数值的扩展\r\n\r\n### 二进制和八进制表示法\r\n\r\n- ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示\r\n\r\n### Number.isFinite(), Number.isNaN()\r\n\r\n- Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity\r\n- Number.isNaN()用来检查一个值是否为NaN，如果参数类型不是NaN，Number.isNaN一律返回false\r\n- 传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效\r\n- Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false\r\n\r\n### Number.parseInt(), Number.parseFloat()\r\n\r\n- ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变\r\n\r\n### Number.isInteger()\r\n\r\n- Number.isInteger()用来判断一个数值是否为整数\r\n- JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值\r\n\r\n### Number.EPSILON\r\n\r\n- ES6 在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差\r\n- Number.EPSILON实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了\r\n\r\n### 安全整数和 Number.isSafeInteger()\r\n\r\n- JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值\r\n- Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内\r\n\r\n### Math 对象的扩展\r\n\r\n- ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用\r\n- Math.trunc方法用于去除一个数的小数部分，返回整数部分\r\n- Math.sign方法用来判断一个数到底是正数、负数、还是零\r\n- Math.cbrt方法用于计算一个数的立方根\r\n- JavaScript 的整数使用 32 位二进制形式表示，Math.clz32方法返回一个数的 32 位无符号整数形式有多少个前导 0\r\n- Math.imul方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数\r\n- Math.fround方法返回一个数的32位单精度浮点数形式\r\n- Math.hypot方法返回所有参数的平方和的平方根\r\n- Math.expm1(x)返回 ex - 1，即Math.exp(x) - 1\r\n- Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN\r\n- Math.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN\r\n- Math.log2(x)返回以 2 为底的x的对数。如果x小于 0，则返回 NaN\r\n- Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）\r\n- Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）\r\n- Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）\r\n- Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）\r\n- Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）\r\n- Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）\r\n\r\n### 指数运算符\r\n\r\n- ES2016 新增了一个指数运算符（**）\r\n- 指数运算符可以与等号结合，形成一个新的赋值运算符（**=）\r\n\r\n## 函数的扩展\r\n\r\n### 函数参数的默认值\r\n\r\n- ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面\r\n- 参数变量是默认声明的，所以不能用let或const再次声明。\r\n- 使用参数默认值时，函数不能有同名参数\r\n- 参数默认值是惰性求值的\r\n- 参数默认值可以与解构赋值的默认值，结合起来使用\r\n- 默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined\r\n- 如果传入undefined，将触发该参数等于默认值，null则没有这个效果\r\n- 指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数\r\n- 指定了默认值后，length属性将失真\r\n- 利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误\r\n\r\n### rest 参数\r\n\r\n- ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了\r\n- rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用\r\n\r\n### 严格模式\r\n\r\n- ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，\r\n那么函数内部就不能显式设定为严格模式，否则会报错\r\n- 设定全局性的严格模式，这是合法的\r\n- 函数包在一个无参数的立即执行函数里面\r\n\r\n### name 属性\r\n\r\n- 函数的name属性，返回该函数的函数名。\r\n- 如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名\r\n- 如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的name属性都返回这个具名函数原本的名字\r\n- Function构造函数返回的函数实例，name属性的值为anonymous\r\n- bind返回的函数，name属性值会加上bound前缀\r\n\r\n### 箭头函数\r\n\r\n- ES6 允许使用“箭头”（=>）定义函数\r\n- 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分\r\n- 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回\r\n- （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。\r\n- （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。\r\n- （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。\r\n- （4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数\r\n- 箭头函数内部，还可以再使用箭头函数\r\n\r\n### 双冒号运算符\r\n\r\n- 现在有一个提案，提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用\r\n- 函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数\r\n- 该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面\r\n- 如果双冒号运算符的运算结果，还是一个对象，就可以采用链式写法\r\n\r\n### 尾调用优化\r\n\r\n- 尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数\r\n- 尾调用不一定出现在函数尾部，只要是最后一步操作即可\r\n- 如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存\r\n- 函数调用自身，称为递归。如果尾调用自身，就称为尾递归\r\n\r\n### 函数参数的尾逗号\r\n\r\n- ES2017 允许函数的最后一个参数有尾逗号（trailing comma）\r\n\r\n## 数组的扩展\r\n\r\n### 扩展运算符\r\n\r\n- 扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列\r\n- 由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了\r\n- 数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组\r\n- 扩展运算符提供了数组合并的新写法。\r\n- 扩展运算符可以与解构赋值结合起来，用于生成数组\r\n- 扩展运算符还可以将字符串转为真正的数组。\r\n- 任何 Iterator 接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组\r\n- Map 和 Set 结构，Generator 函数\r\n\r\n### Array.from()\r\n\r\n- Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map\r\n- Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组\r\n\r\n### Array.of()\r\n\r\n- Array.of方法用于将一组值，转换为数组\r\n- 这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异\r\n- Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载\r\n\r\n### 数组实例的 copyWithin()\r\n\r\n- 数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组\r\n\r\n### 数组实例的 find() 和 findIndex()\r\n\r\n- 数组实例的find方法，用于找出第一个符合条件的数组成员\r\n- 它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员\r\n- 如果没有符合条件的成员，则返回undefined\r\n- 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1\r\n- 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象\r\n\r\n### 数组实例的 fill()\r\n\r\n- fill方法使用给定值，填充一个数组。\r\n- 如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象\r\n\r\n### 数组实例的 entries()，keys() 和 values()\r\n\r\n- ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组\r\n- 它们都返回一个遍历器对象，可以用for...of循环进行遍历\r\n- 如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历\r\n\r\n### 数组实例的 includes()\r\n\r\n- Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似\r\n- Map 和 Set 数据结构有一个has方法，需要注意与includes区分\r\n\r\n### 数组的空位\r\n\r\n- 数组的空位指，数组的某一个位置没有任何值\r\n- Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位\r\n- 扩展运算符（...）也会将空位转为undefined\r\n- copyWithin()会连空位一起拷贝\r\n- fill()会将空位视为正常的数组位置\r\n- for...of循环也会遍历空位\r\n- entries()、keys()、values()、find()和findIndex()会将空位处理成undefined\r\n\r\n## 对象的扩展\r\n\r\n### 属性的简洁表示法\r\n\r\n- ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。\r\n\r\n### 属性名表达式\r\n\r\n- JavaScript 定义对象的属性，有两种方法\r\n- 方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内\r\n- 注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]\r\n\r\n### 方法的 name 属性\r\n\r\n- 函数的name属性，返回函数名。对象方法也是函数，因此也有name属性\r\n- 如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，\r\n而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set\r\n- bind方法创造的函数，name属性返回bound加上原函数的名字；\r\n- Function构造函数创造的函数，name属性返回anonymous\r\n- 如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述\r\n\r\n### Object.is()\r\n\r\n- 用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致\r\n- 不同之处只有两个：一是+0不等于-0，二是NaN等于自身\r\n\r\n### Object.assign()\r\n\r\n- Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）\r\n- 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性\r\n- 如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过\r\n- 这意味着，如果undefined和null不在首参数，就不会报错\r\n- Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）\r\n- Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用\r\n- 遇到同名属性，Object.assign的处理方法是替换，而不是添加\r\n- Object.assign可以用来处理数组，但是会把数组视为对象\r\n- Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制\r\n- 为对象添加属性\r\n- 为对象添加方法\r\n- 克隆对象\r\n- 合并多个对象\r\n- 为属性指定默认值\r\n\r\n### 属性的可枚举性和遍历\r\n\r\n- 对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为\r\n- Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象\r\n- for...in循环：只遍历对象自身的和继承的可枚举的属性。\r\n- Object.keys()：返回对象自身的所有可枚举的属性的键名。\r\n- JSON.stringify()：只串行化对象自身的可枚举的属性。\r\n- Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性\r\n- 引入“可枚举”（enumerable）这个概念的最初目的，就是让某些属性可以规避掉for...in操作，不然所有内部属性和方法都会被遍历到\r\n- 属性的遍历\r\n\r\n\t- for...in\r\n\t- Object.keys(obj)\r\n\t- Object.getOwnPropertyNames(obj)\r\n\t- Object.getOwnPropertySymbols(obj)\r\n\t- Reflect.ownKeys(obj)\r\n\t- 首先遍历所有数值键，按照数值升序排列。\r\n\t- 其次遍历所有字符串键，按照加入时间升序排列。\r\n\t- 最后遍历所有 Symbol 键，按照加入时间升序排列。\r\n\r\n### Object.getOwnPropertyDescriptors()\r\n\r\n- ES2017 引入了Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象\r\n- 该方法的引入目的，主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题\r\n\r\n### __proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()\r\n\r\n- ES6 规定__proto__只有浏览器要部署，其他环境不用部署\r\n- __proto__属性（前后各两个下划线），用来读取或设置当前对象的prototype对象\r\n- Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的prototype对象，返回参数对象本身\r\n- 该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象\r\n\r\n### super 关键字\r\n\r\n- ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象\r\n- super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错\r\n\r\n### Object.keys()，Object.values()，Object.entries()\r\n\r\n- ES5 引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名\r\n- ES2017 引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for...of循环使用\r\n- Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值\r\n- 返回数组的成员顺序\r\n- Object.values会过滤属性名为 Symbol 值的属性\r\n- Object.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组\r\n\r\n### 对象的扩展运算符\r\n\r\n- 运算符（...）ES2018 将这个运算符引入了对象\r\n- 对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面\r\n- 由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象\r\n- 解构赋值必须是最后一个参数，否则会报错\r\n\r\n## Symbol\r\n\r\n### 概述\r\n\r\n- ES5 的对象属性名都是字符串，这容易造成属性名的冲突\r\n- Symbol的引入，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突\r\n- 它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）\r\n- Symbol函数前不能使用new命令，否则会报错\r\n- Symbol 值不是对象，所以不能添加属性\r\n- Symbol 值不能与其他类型的值进行运算，会报错\r\n- Symbol 值可以显式转为字符串\r\n- Symbol 值也可以转为布尔值，但是不能转为数值\r\n\r\n### 作为属性名的 Symbol\r\n\r\n- 由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性\r\n- Symbol 值作为对象属性名时，不能用点运算符\r\n\r\n### 实例：消除魔术字符串\r\n\r\n- 魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值\r\n- 常用的消除魔术字符串的方法，就是把它写成一个变量。\r\n\r\n### 属性名的遍历\r\n\r\n- Symbol 作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回\r\n- 有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名\r\n- Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和 Symbol 键名\r\n\r\n### Symbol.for()，Symbol.keyFor()\r\n\r\n- 我们希望重新使用同一个 Symbol 值，Symbol.for方法可以做到这一点\r\n- 它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值\r\n- 如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值\r\n- Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值\r\n- Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key\r\n\r\n### 实例：模块的 Singleton 模式\r\n\r\n- Singleton 模式指的是调用一个类，任何时候返回的都是同一个实例\r\n- 如果键名使用Symbol方法生成，那么外部将无法引用这个值，当然也就无法改写。\r\n\r\n### 内置的 Symbol 值\r\n\r\n- 除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法\r\n- 对象的Symbol.hasInstance属性，指向一个内部方法\r\n- 对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开\r\n- 对象的Symbol.species属性，指向一个构造函数。创建衍生对象时，会使用该属性\r\n- 对象的Symbol.match属性，指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值\r\n- 对象的Symbol.replace属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值\r\n- 对象的Symbol.search属性，指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值\r\n- 对象的Symbol.split属性，指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值\r\n- 对象的Symbol.iterator属性，指向该对象的默认遍历器方法。\r\n- 对象的Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值\r\n- 对象的Symbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，\r\n如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型\r\n- 对象的Symbol.unscopables属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除\r\n\r\n## Set 和 Map 数据结构\r\n\r\n### Set\r\n\r\n- ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值\r\n- 上面代码向 Set 实例添加了两个NaN，但是只能加入一个。这表明，在 Set 内部，两个NaN是相等\r\n- Set.prototype.constructor：构造函数，默认就是Set函数。\r\n- Set.prototype.size：返回Set实例的成员总数\r\n- add(value)：添加某个值，返回 Set 结构本身。\r\n- delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。\r\n- has(value)：返回一个布尔值，表示该值是否为Set的成员。\r\n- clear()：清除所有成员，没有返回值。\r\n- keys()：返回键名的遍历器\r\n- values()：返回键值的遍历器\r\n- entries()：返回键值对的遍历器\r\n- forEach()：使用回调函数遍历每个成员\r\n\r\n### WeakSet\r\n\r\n- WeakSet 结构与 Set 类似，也是不重复的值的集合\r\n- WeakSet 的成员只能是对象，而不能是其他类型的值\r\n- WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中\r\n- WeakSet 是一个构造函数，可以使用new命令，创建 WeakSet 数据结构\r\n- WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。\r\n- WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。\r\n- WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。\r\n- WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了\r\n\r\n### Map\r\n\r\n- 它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键\r\n- 事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数\r\n- size属性返回 Map 结构的成员总数。\r\n- set方法设置键名key对应的键值为value，然后返回整个 Map 结构。\r\n- get方法读取key对应的键值，如果找不到key，返回undefined\r\n- has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中\r\n- delete方法删除某个键，返回true。如果删除失败，返回false\r\n- clear方法清除所有成员，没有返回值\r\n- keys()：返回键名的遍历器。\r\n- values()：返回键值的遍历器。\r\n- entries()：返回所有成员的遍历器。\r\n- forEach()：遍历 Map 的所有成员。\r\n\r\n### WeakMap\r\n\r\n- WeakMap结构与Map结构类似，也是用于生成键值对的集合。\r\n- WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名\r\n- WeakMap的键名所指向的对象，不计入垃圾回收机制\r\n- WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有keys()、values()和entries()方法），也没有size属性\r\n- WeakMap只有四个方法可用：get()、set()、has()、delete()\r\n\r\n## Proxy\r\n\r\n### 概述\r\n\r\n- Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程\r\n- ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例\r\n\r\n### Proxy 实例的方法\r\n\r\n- get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy['foo']。\r\n- set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。\r\n- has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。\r\n- deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。\r\n- ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。\r\n- getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。\r\n- defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。\r\n- preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。\r\n- getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。\r\n- isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。\r\n- setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。\r\n- apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。\r\n- construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。\r\n\r\n### Proxy.revocable()\r\n\r\n- Proxy.revocable方法返回一个可取消的 Proxy 实例。\r\n\r\n### this 问题\r\n\r\n- 虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致\r\n\r\n### 实例：Web 服务的客户端\r\n\r\n- Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端\r\n\r\n## Reflect\r\n\r\n### 概述\r\n\r\n- Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API\r\n-  将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上\r\n- 修改某些Object方法的返回结果，让其变得更合理\r\n- 让Object操作都变成函数行为\r\n- Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法\r\n\r\n### 静态方法\r\n\r\n- Reflect.apply(target, thisArg, args)\r\n- Reflect.construct(target, args)\r\n- Reflect.get(target, name, receiver)\r\n- Reflect.set(target, name, value, receiver)\r\n- Reflect.defineProperty(target, name, desc)\r\n- Reflect.deleteProperty(target, name)\r\n- Reflect.has(target, name)\r\n- Reflect.ownKeys(target)\r\n- Reflect.isExtensible(target)\r\n- Reflect.preventExtensions(target)\r\n- Reflect.getOwnPropertyDescriptor(target, name)\r\n- Reflect.getPrototypeOf(target)\r\n- Reflect.setPrototypeOf(target, prototype)\r\n\r\n### 实例：使用 Proxy 实现观察者模式\r\n\r\n- 观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行\r\n\r\n## Promise\r\n\r\n### Promise 的含义\r\n\r\n- Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大\r\n- 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）\r\n- 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected\r\n\r\n### 基本用法\r\n\r\n- ES6 规定，Promise对象是一个构造函数，用来生成Promise实例\r\n\r\n### Promise.prototype.then()\r\n\r\n- Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的\r\n- 可以采用链式写法，即then方法后面再调用另一个then方法\r\n\r\n### Promise.prototype.catch()\r\n\r\n- Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数\r\n- Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止\r\n\r\n### Promise.prototype.finally()\r\n\r\n- finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作\r\n\r\n### Promise.all()\r\n\r\n- Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例\r\n- （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。\r\n- （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。\r\n\r\n### Promise.race()\r\n\r\n- Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例\r\n- 只要其中之中有一个实例率先改变状态，状态就跟着改变\r\n\r\n### Promise.resolve()\r\n\r\n- 有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用\r\n- 参数是一个 Promise 实例\r\n- 参数是一个thenable对象\r\n- 参数不是具有then方法的对象，或根本就不是对象\r\n- 不带有任何参数\r\n\r\n### Promise.reject()\r\n\r\n- Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected\r\n\r\n### 应用\r\n\r\n- 我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。\r\n- 使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。\r\n\r\n### Promise.try()\r\n\r\n- Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码\r\n\r\n## Iterator 和 for...of 循环\r\n\r\n### Iterator（遍历器）的概念\r\n\r\n- 一种统一的接口机制，来处理所有不同的数据结构\r\n- 为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作\r\n- 一是为各种数据结构，提供一个统一的、简便的访问接口；\r\n- 二是使得数据结构的成员能够按某种次序排列；\r\n- 三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费\r\n\r\n### 默认 Iterator 接口\r\n\r\n- Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for...of循环\r\n- 一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”\r\n\r\n### 调用 Iterator 接口的场合\r\n\r\n- 有一些场合会默认调用 Iterator 接口（即Symbol.iterator方法），除了下文会介绍的for...of循环，还有几个别的场合\r\n- 对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法。\r\n- 扩展运算符（...）也会调用默认的 Iterator 接口。\r\n- yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口\r\n- for...of\r\n- Array.from()\r\n- Map(), Set(), WeakMap(), WeakSet()（比如new Map([['a',1],['b',2]])）\r\n- Promise.all()\r\n- Promise.race()\r\n\r\n### 字符串的 Iterator 接口\r\n\r\n- 字符串是一个类似数组的对象，也原生具有 Iterator 接口。\r\n\r\n### Iterator 接口与 Generator 函数\r\n\r\n- Symbol.iterator方法的最简单实现，还是使用下一章要介绍的 Generator 函数\r\n\r\n### 遍历器对象的 return()，throw()\r\n\r\n- 遍历器对象除了具有next方法，还可以具有return方法和throw方法\r\n- return方法的使用场合是，如果for...of循环提前退出\r\n- throw方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法\r\n\r\n### for...of 循环\r\n\r\n- 一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for...of循环遍历它的成员\r\n- for...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串\r\n\r\n## async 函数\r\n\r\n### 含义\r\n\r\n- async 函数是什么？一句话，它就是 Generator 函数的语法糖\r\n- 一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已\r\n- Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器\r\n- async和await，比起星号和yield，语义更清楚了\r\n- co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值\r\n- async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了\r\n\r\n### 基本用法\r\n\r\n- async函数返回一个 Promise 对象，可以使用then方法添加回调函数\r\n- 由于async函数返回的是 Promise 对象，可以作为await命令的参数\r\n\r\n### 语法\r\n\r\n- async函数的语法规则总体上比较简单，难点是错误处理机制。\r\n- async函数返回一个 Promise 对象。\r\n- async函数内部return语句返回的值，会成为then方法回调函数的参数\r\n- async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误\r\n- 正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象\r\n- 如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject\r\n- 如果有多个await命令，可以统一放在try...catch结构中\r\n\r\n### async 函数的实现原理\r\n\r\n- async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里\r\n\r\n## es6函数\r\n\r\n### 函数参数的默认值\r\n\r\n- 判断函数是否赋值是是否全等于undefined\r\n- 简洁，利于阅读，未来代码优化\r\n- 函数体里不能用let或const再次声明\r\n- 参数不能有同名参数\r\n- 不是传值，而是每次都重新计算默认值表达式的值\r\n- 应该是尾参数，非尾参数设置默认值，是没法省略的，除非显示指定undefined\r\n- 函数length属性会失真，rest和默认值参数，以及默认值之后的参数都将不被计算\r\n- 参数形成一个单独的作用域，不设置默认值是不出现。初始化结束后，作用域消失\r\n\r\n### rest参数（...变量名）\r\n\r\n- 是一个真实的参数\r\n- rest参数之后不能再有其他参数，否则报错\r\n- 函数的length属性不包括rest参数\r\n\r\n### 严格模式\r\n\r\n- 使用默认值，解构赋值、扩展运算符的函数内部都不能显示设定为严格模式否则会报错\r\n- 因为先执行函数参数再执行函数体，但是在函数体内才知道是否应该以严格模式执行\r\n- 解决办法\r\n\r\n\t- 全局使用严格模式\r\n\t- 将函数包含在严格模式的无参数立即执行函数里面\r\n\r\n### name属性\r\n\r\n- (new Function).name // \"anonymous\"\r\n- bind返回的函数，name属性值会加上bound前缀。\r\n\r\n### 箭头函数\r\n\r\n- 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象\r\n- 不可以当作构造函数，不可以使用new命令，否则会抛出一个错误\r\n- 不可以使用arguments对象，该对象在函数体内不存在，如果要用可以使用rest参数代替\r\n- 不可以使用yield命令，因此箭头函数不能用作Generator函数\r\n- this在箭头函数中是固定的，并不是因为内部有绑定this的机制，实际原因是箭头函数根本没有自己的this\r\n- arguments、super、new.target也不存在箭头函数之中\r\n- 不能用call、apply、bind去改变this 的指向\r\n- 不适用在对象属性中使用箭头函数的this因为对象不构成单独的作用域\r\n- 不适用需要动态this的时候\r\n\r\n### 尾调用优化\r\n\r\n- 最后一步是调用另一个函数，另个函数不能用到这个函数的变量\r\n- 函数调用会在内存形成一个调用帧，保存调用位置和内部变量等信息，尾调用不需要保留外层函数的调用帧，取代外层函数调用帧，大大节省内存\r\n- 尾调用优化只在严格模式下开启，正常模式下无效\r\n- 因为正常模式下有这两个变量，可以跟踪函数的调用栈。\r\n\r\n\t- arguments\r\n\t- caller\r\n\r\n- 正常模式下可以使用蹦床函数实现优化\r\n\r\n### Function.prototype.toString()返回代码本身，明确要求返回一模一样的原始代码\r\n\r\n### catch命令的参数可以省略\r\n\r\n### es2017允许函数最后一个参数有逗号\r\n\r\n## Event Loop\r\n\r\n### 执行栈\r\n\r\n- JavaScript执行时，同步任务会排好队，在主程序上按照顺序执行，排队的地方叫做执行栈\r\n\r\n### 任务队列\r\n\r\n- JavaScript对异步任务不会停下来等待，而是将其挂起，继续执行执行栈中的同步任务，当异步任务有返回结果（通常是回调函数）时，异步任务会加入与执行栈不一样的队列，即任务队列\r\n- 微任务\r\n\r\n\t- promise.then\r\n\t- process.nextTick\r\n\r\n- 宏任务\r\n\r\n\t- script（整体代码）\r\n\t- setTimeout\r\n\t- setInterval\r\n\t- setImmediate\r\n\t- promise中的executor\r\n\r\n### Event执行顺序\r\n\r\n- 1.主程序\r\n- 2.微任务\r\n- 3.宏任务\r\n\r\n### async/await\r\n\r\n- 仅仅影响函数内的执行\r\n- await的下一个语句相当与执行promise.then\r\n\r\n### promise.then\r\n\r\n- 链式调用会被EventLoop中的其他事件插队\r\n- 分别调用不会，会将then中的回调函数push到一个数组后批量执行\r\n\r\n## Promise\r\n\r\n### Promise\r\n\r\n- 什么是Promise\r\n\r\n\t- Promise 的决议结果可能是拒绝而不是完成\r\n\t- Promise 封装了依赖于时间的状态——等待底层值的完成或拒绝\r\n\r\n- 具有 then 方法的鸭子类型\r\n\r\n\t- 在 Promise 系统中就会被误认为是一个 thenable, 这可能会导 致非常难以追踪的 bug\r\n\t- 这种 类型检查 (type check)一般用术语 鸭子类型 (duck typing)来表示\r\n\t- 对象上有 then(..) 函数，或则他的原型上有 then()函数\r\n\r\n- Promise 信任问题\r\n\r\n\t- 对一个 Promise 调用 then(..) 的时候, 即使这个 Promise 已经决议, 提供给 then(..) 的回调也总会被异步调用\r\n\t- 一个 Promise 决议后, 这个 Promise 上所有的通过 then(..) 注册的回调都会在下一个异步时机点上依次被立即调用\r\n\t-  两个独立Promise 上链接的回调的相对顺序无法可靠预测\r\n\t- 如果 Promise 本身永远不被决议呢，Promise 提供了一个方案：有一个输出信号,防止其永久挂住程序\r\n\t- Promise 的定义方式使得它只能被决议一次\r\n\t- Promise 至多只能有一个决议值(完成或拒绝)\r\n\t- 如果使用多个参数调用 resovle(..) 或者 reject(..) ,第一个参数之 后的所有参数都会被默默忽略\r\n\t- 如果拒绝一个 Promise 并给出一个理由，这个值就会被传给拒绝回调\r\n\t- 如果在 Promise 的创建过程中或在查看其决议 结果过程中的任何时间点上出现了一个 JavaScript 异常错误\r\n\t- 如果向 Promise.resolve(..) 传递一个非 Promise、非 thenable 的立即值,就会得到一个用 这个值填充的 promise\r\n\t- Promise这种模式通过可信任的语义把回调作为参数传递，把控制权放在了一个可信任的系统\r\n\r\n- 链式流\r\n\r\n\t- 我们可以把多个 Promise 连接到一起以表示一系列异步 步骤\r\n\t- Promise 规范化了异步, 并封装了时间相关值的状态,使得我们能够把它们以这种有用的方式链接到一起\r\n\t- 调用Promise的then(..)会自动创建一个新的 Promise 从调用返回\r\n\t- 在完成或拒绝处理函数内部,如果返回一个值或抛出一个异常,新返回的(可链接的)\r\n\r\nPromise 就相应地决议\r\n\t- 如果完成或拒绝处理函数返回一个 值是什么,都会成为当前 then(..)\r\n\r\nPromise, 它将会被展开,这样一来,不管它的决议 返回的链接 Promise 的决议值\r\n\t- 术语 决议 (resolve)、 完成 (fulfill)和 拒绝 (reject),\r\n\r\n- 错误处理\r\n\r\n\t- try..catch 当然很好, 但是无法跨异步操作工作\r\n\t- 模式化的错误处理方式，error-first 回调 风格\r\n\t-  Promise 没有采用 流行的 error-first 回调设计风格,而是使用了分离回调(split-callback)风格。\r\n\t- Promise 错误处理就是一个“绝望的陷阱”设计，它假定你想要 Promise 状态吞掉所有的错误\r\n\t- 浏览器在它被垃圾回收的时候 其中有拒绝,浏览器就能够确保这是一个真正的未捕获错误,进而可以确定应该将其报告 到开发者终端\r\n\t- 如果一个 Promise 被拒绝的话,默认情况下会向开发者终端报告这个事实\r\n\t- 需要等待一段时间才能使用或查看它的拒绝结果, 调用 defer() , 这样就不会有全局报告出现\r\n\r\n- Promise 模式\r\n\r\n\t- 并行执行   Promise.all([ .. ])\r\n\t- 如果这些 promise 中有任何一个被拒绝的话,主 Promise.all([ .. ]) promise 就会立 即被拒绝,并丢弃来自其他所有 promise 的全部结果\r\n\t- “第一个跨过终点线的 Promise” ,而抛弃其他 Promise\r\n\t- 一旦有任何一个 Promise 决议为完成, 就会完成;一旦有任何一个 Promise 决议为拒绝,它就会拒绝。\r\n\t- none([ .. ]) 这个模式类似于 all([ .. ]) ,不过完成和拒绝的情况互换了。所有的 拒绝,即拒绝转化为完成值,反之亦然。\r\n\t- any([ .. ]) Promise 都要被 这个模式与 all([ .. ]) 类似,但是会忽略拒绝,所以只需要完成一个而不是全部\r\n\t- first([ .. ]) 这个模式类似于与 any([ .. 的任何拒绝和完成。\r\n\t- last([ .. ]) 这个模式类似于 first([ .. ]) ,但却是只有最后一个完成胜出\r\n\t- 有些时候会需要在一列 Promise 中迭代, 并对所有 Promise 都执行某个任务,并发迭代，map()\r\n\r\n- Promise API 概述\r\n\r\n\t- new Promise(..) 构造器,接受两个参数，reject(..) 就是拒绝这个 promise;但 resolve(..) 既可能完成 promise\r\n\t- Promise.resolve(..) 和 Promise.reject(..)\r\n\t- then(..) 和 catch(..)\r\n\r\n\t\t- then(..) 接受一个或两个参数:第一个用于完成回调,第二个用于拒绝回调\r\n\t\t- catch(..) 只接受一个拒绝回调作为参数,并自动替换默认完成 回调\r\n\r\n\t- Promise.all([ .. ]) 和 Promise.race([ .. ])\r\n\r\n\t\t- 对 Promise.all([ .. ]) 来说,只有传入的所有 promise 都完成,返回 promise 才能完成\r\n\t\t- 对 Promise.race([ .. ]) 来说,只有第一个决议的 promise(完成或拒绝)取胜, \r\n并且其 决议结果成为返回 promise 的决议。\r\n\r\n- Promise 局限性\r\n\r\n\t-  顺序错误处理\r\n\r\n\t\t- 即 Promise 链中的错误很容易被 无意中默默忽略掉\r\n\t\t- 没有把整个链标识为一个个体的实体,这意味着没有外部方法可以用于观 察可能发生的错误\r\n\r\n\t- 单一值\r\n\r\n\t\t- Promise 只能有一个完成值或一个拒绝理由\r\n\r\n\t- 单决议\r\n\r\n\t\t- :Promise 只能被决议一次(完成或拒绝)\r\n\r\n\t- 惯性\r\n\r\n\t\t- 开发者需要刻意的改变编程习惯,因为 Promise 不会从目前的编码方式中自 然而然地衍生出来\r\n\r\n\t- 无法取消的 Promise\r\n\r\n\t\t- 一旦创建了一个 Promise 并为其注册了完成和 / 或拒绝处理函数,如果出现某种情况使得 这个任务悬而未决的话,\r\n你也没有办法从外部停止它的进程\r\n\r\n\t- Promise 性能\r\n\r\n\t\t- Promise 进行的动作要多一些,这自然意味着它也会稍慢一些。\r\n\r\n### Promise\r\n\r\n- 特点\r\n\r\n\t- 对象状态不受外界影响，只有异步操作的结果可以决定当前的状态\r\n\r\n\t\t- pending\r\n\t\t- fulfilled\r\n\t\t- rejected\r\n\r\n\t- 状态一旦改变，就不会再变\r\n\t- 无法取消Promise，一旦新建就立即执行\r\n\t- 如果不设置回调函数，内部抛出的错误无法反应到外部\r\n\t- 处于pending时，无法得知目前进展到哪一个阶段了（刚刚开始还是即将完成）\r\n\r\n- 含义\r\n\r\n\t- 是一个对象/容器，保存某个未来才会结束事件的结果\r\n\r\n- 基础用法\r\n\r\n\t- new Promise时，需要传递一个executor执行器，执行器立即执行\r\n\t- executor接收两个参数，分别是resolve和reject\r\n\t- promise只能从pending到rejected或者从pending到fulfilled\r\n\t- promise的状态一旦确认，就不会再改变\r\n\t- reject方法的作用，等同于抛出错误\r\n\r\n- then\r\n\r\n\t- 定义在Promise.prototype上\r\n\t- 接收两个参数（可以缺省）\r\n\r\n\t\t- promise成功的回调\r\n\t\t- promise失败的回调\r\n\r\n\t- 如果调用then时，promise已经成功，则执行成功的回调函数，并将promise的值作为参数传递进去\r\n\t- 如果调用then时，promise已经失败，则执行失败的回调函数，并将promise失败的原因作为参数传递进去\r\n\t- 如果promise的状态是pending，则将两个回调函数存放起来，等待状态确定后，再一次将对应的函数执行（发布订阅）\r\n\t- promise可以then多次，promise的then返回一个promise \r\n\t- 如果then返回的是一个结果，那么就会把这个结果作为参数传递给下一个then的成功回调函数\r\n\t- 如果then中抛出了异常，那么就会把这个异常作为参数，传递给下一个then的失败回调函数\r\n\t- 如果then返回的是一个promise，那么需要等待这个promise执行完，如果promise返回成功则进入下一个then的成功，如果失败，就进入下个个then的失败\r\n\r\n- then与catch返回值return不能是promise本身，否则会造成死循环\r\n- catch\r\n\r\n\t- 定义在Promise.prototype上，用于指定发生错误时的回调函数\r\n\t- 如果catch之前的promise抛错错误（包括catch之前的then抛出错误也会被捕获）那么状态就会变为rejected，就会调用catch指定的回调函数，处理这个错误\r\n\t- reject方法的作用，等同于抛出错误\r\n\t- resolve之后再抛出错误是无效的，因为状态一旦改变，变不会再变\r\n\t- Promise对象的错误具有冒泡性质，会一直向后传递，直到被捕获位置\r\n\t- 一般不在then方法里面定义reject状态的回调函数，而是在then的外面使用catch，这样可以捕获then执行中的错误\r\n\t- 如果没有catch方法则promise对象抛出的错误不会传递到外层代码，即不会有任何的反应\r\n\t- catch后接then方法，如果没有抛出错误则会跳过catch直接执行then\r\n\t- catch方法后还可以调用catch\r\n\r\n- finally\r\n\r\n\t- 定义在Promise.prototype上，无论Promise的状态如何，都会执行（es2018）\r\n\t- 不依赖Promise的执行结果，所以不就受任何参数\r\n\r\n- Promise.all()\r\n\r\n\t- 构造函数上的方法，用来将多个Promise的实例，包装成一个新的Promise的实例\r\n\t- 接收（一般为数组）一个具有Iterator接口的参数，参数返回成员都是Promise的实例\r\n\t- 如果参数不是Promise的实例，则会调用Primise.resolve方法，将参数转为Promise的实例\r\n\t- 只有参数实例的状态都变成fulfilled，状态才会变成fulfilled，此时参数的返回值组成一个数组传给实例的回调函数\r\n\t- 只要参数实例有一个状态变成rejected，实例状态就会变成rejected，此时第一个被rejected的参数实例的返回值就会传递给实例的回调函数\r\n\t- 参数实例中有catch方法且执行了的话，该参数实例会变成resolved，Promise.all()的catch方法也不会被执行\r\n\r\n- Promise.race()\r\n\r\n\t- 参数与Promise.all()一样，如果不是Promise实例则会调用Promise.resolve\r\n\t- 只要参数实例之中有一个实例率先改变状态则实例状态就跟着改变，率先改变的参数实例的返回值会传递给实例的回调函数\r\n\r\n- Promise.resolve()\r\n\r\n\t- 将现有对象转为Promise对象\r\n\t- 等价于 new Promise（resolve=>resolve('foo')）\r\n\t- 参数是一个Promise的实例则不做任何修改，原封不动的返回实例\r\n\t- 参数是一个thenable的对象（具有then方法的对象），会将这个对象转为Promise对象，然后立即执行thenable对象的then 方法\r\n\t- 参数不是thenable对象或者不是对象，则返回一个新的Promise对象状态为resolved，Promise.reolved方法的参数会同时传给回调函数\r\n\t- 不带参数，直接返回一个resolved状态的对象，在本轮事件循环结束时执行\r\n\r\n- Promise.reject()\r\n\r\n\t- 返回一个Promise实例，状态为rejected\r\n\t- 参数会原封不动的作为rejected的理由，变成后续方法的参数（不会立即执行thenable对象的then方法）\r\n\r\n- Promise.try()\r\n\r\n\t- 现有的提案还未通过，同步函数同步执行，异步函数异步执行。\r\n\t- 也可以使用立即执行函数里面使用async或者Promise实现\r\n\r\n## Generator\r\n\r\n### Generator\r\n\r\n- 概念\r\n\r\n\t- Generator函数是一个状态机，封装了多个内部状态\r\n\t- 返回一个遍历器对象代表函数的内部指针，可以一次遍历Generator函数内部的每个状态\r\n\t- function与函数名之间有星号*，内部使用yield表达式\r\n\t- yield是暂停执行的标志，next方法可以恢复执行\r\n\t- next()方法返回带有value、done属性的对象\r\n\t- 将Generator赋值给对象的Symbol.iterator属性，从而使对象具有iterator接口\r\n\t- for...of循环可以自动遍历Generator函数运行时生成的iterator对象。\r\n\t- 不是构造函数，所以实例对象拿不到this上的属性，函数绑定在对象上面时候可以使用this：F.call(obj)，两个对象统一的实现是F.call(F.prototype)\r\n\r\n- yield\r\n\r\n\t-  遇到yield表达式，暂停执行后面的操作，yield后面的表达式的值作为返回对象的value属性的值\r\n\t- 下一次掉用next方法再继续往下执行，直到遇到下一个yield表达式\r\n\t- 如果没有yield表达式，就一直运行到函数结束，一直到return\r\n\t- 如果没有return则返回对象的value属性值为undefined\r\n\t- next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值\r\n\t- yield在另一个表达式中必须用圆括号括起来\r\n\r\n- throw\r\n\r\n\t- 每个Generator函数返回的遍历对象都有一个throw方法，可以再函数体外抛出错误，然后再Generator函数体内捕获\r\n\t- 可以接受一个参数，会被catch语句接收，建议抛出Error对象的实例\r\n\t- 如果Generator函数内部没有部署try...catch那么会被外部的try...catch代码块捕获\r\n\t- 如果外部和内部都没有部署try...catch代码块，那么程序会报错，直接中断执行\r\n\t- 如果错误要被捕获，generator对象必须至少执行过一次next方法\r\n\t- 第一次next方法相当于启动执行generator函数的内部代码\r\n\t- throw方法被捕获后，会附带执行下一条的yield表达式，也就是会附带执行一次next方法\r\n\r\n- return\r\n\r\n\t- 可以返回给定的值，并且终结遍历Generator函数\r\n\t- 如果函数内部有try...finally代码块，且正在执行try代码块，那么return会推迟到finally代码块执行完再执行\r\n\t- return、next、throw都是让Generator函数恢复执行，并且使用不同的语句替换yield表达式\r\n\r\n- yield*\r\n\r\n\t- 用来在一个Generator函数里面执行另一个Generator函数，会自动遍历，如果不带星只会返回遍历器对象\r\n\t- 等同于部署了一个for...of循环，会自动遍历有Iterator的对象，比如数组\r\n\r\n- 上下文\r\n\r\n\t- 一般代码运行会产生一个全局上下文环境（context，又称运行环境），包含了当前所有的变量和对象，执行代码是又会在当前上下文环境的上层产生一个运行的上下文，变成当前的上下文，由此形成上下文环境的堆栈，最后产生的上下文环境首先执行完成，退出堆栈，然后在执行完成它下层的上下文，直至所有代码执行完成，堆栈清空\r\n\t- 而Generator函数的上下文一旦遇到yield就会暂时退出堆栈，里面的所有变量和对象会冻结在当前状态，等到next是，上下文环境会重新加入调用栈，冻结的变量和对象恢复执行\r\n\r\n- 协程\r\n\r\n\t- 可以并行执行、交换执行权的线程就称为协程\r\n\t- 子例程只有当前调用子函数完全执行完毕，才会结束执行父函数\r\n\t- Generator函数属于半协程，如果是完全执行的协程，那么任何函数都可以让暂停的协程继续执行\r\n\t- 普通线程是抢先式的，优先由运行环境决定，协程式合作式的，执行权由协程自己分配\r\n\t- 协程好处就是抛出错误的时候可以找到原始的调用栈。\r\n\r\n- 应用\r\n\r\n\t- 异步操作的同步化表达\r\n\t- 状态机\r\n\t- 控制流管理\r\n\t- 部署Iterator接口\r\n\t- 作为数据结构\r\n\r\n- 异步应用\r\n\r\n\t- 传统方法\r\n\r\n\t\t- 回调函数\r\n\t\t- 事件监听\r\n\t\t- 发布/订阅\r\n\r\n\t- 异步\r\n\r\n\t\t- 一个任务不连续完成\r\n\t\t- 先执行第一段，然后转而执行其他任务，等做好了准备在回过头执行第二段\r\n\t\t- 回调函数就是将任务的第二段单独写在一个函数里\r\n\t\t- Promise最大问题是代码冗余\r\n\r\n\t- 协程\r\n\r\n\t\t- 异步任务是A协程\r\n\t\t- 协程A开始执行\r\n\t\t- 协程A执行到一半，进入暂停，执行权转移到协程B\r\n\t\t- 一段时间后，协程B交还执行权\r\n\t\t- 协程A恢复执行\r\n\r\n\t- Thunk函数\r\n\r\n\t\t- 是自动执行Generator函数的一种方法\r\n\t\t- 实现传名调用，即参数用到的时候才求值\r\n\t\t- 将多参数函数替换成一个只接受回调函数作为参数的单参数函数\r\n\r\n### Generator 函数的异步应用\r\n\r\n- 传统方法\r\n\r\n\t- 回调函数\r\n\t- 事件监听\r\n\t- 发布/订阅\r\n\t- Promise 对象\r\n\r\n- 基本概念\r\n\r\n\t- 所谓\"异步\"，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段\r\n\t- 所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数\r\n\t- Promise 对象是一种新的写法，允许将回调函数的嵌套，改成链式调用\r\n\r\n- Generator 函数\r\n\r\n\t- 第一步，协程A开始执行。\r\n\t- 第二步，协程A执行到一半，进入暂停，执行权转移到协程B。\r\n\t- 第三步，（一段时间后）协程B交还执行权。\r\n\t- 第四步，协程A恢复执行。\r\n\t- Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）\r\n\t- Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因\r\n\r\n- Thunk 函数\r\n\r\n\t- Thunk 函数是自动执行 Generator 函数的一种方法\r\n\t- Thunk 函数的定义，它是“传名调用”的一种实现策略，用来替换某个表达式\r\n\t- 生产环境的转换器，建议使用 Thunkify 模块\r\n\r\n- co 模块\r\n\r\n\t- co 模块可以让你不用编写 Generator 函数的执行器\r\n\t- （1）回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。\r\n\t- （2）Promise 对象。将异步操作包装成 Promise 对象，用then方法交回执行权。\r\n\r\n### Generator 函数的语法\r\n\r\n- 简介\r\n\r\n\t- Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同\r\n\t- 语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态\r\n\t- 执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数\r\n\t- 一是，function关键字与函数名之间有一个星号\r\n\t- 二是，函数体内部使用yield表达式，定义不同的内部状态\r\n\t- 总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象\r\n\r\n- next 方法的参数\r\n\r\n\t- yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值\r\n\t- 由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的\r\n\t- 如果想要第一次调用next方法时，就能够输入值，可以在 Generator 函数外面再包一层\r\n\r\n- for...of 循环\r\n\r\n\t- for...of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法\r\n\t- 利用for...of循环，可以写出遍历任意对象（object）的方法\r\n\r\n- Generator.prototype.throw()\r\n\r\n\t- Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获\r\n\t- 不要混淆遍历器对象的throw方法和全局的throw命令\r\n\t- throw方法抛出的错误要被内部捕获，前提是必须至少执行过一次next方法\r\n\r\n- Generator.prototype.return()\r\n\r\n\t- Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数\r\n\t- 如果return方法调用时，不提供参数，则返回值的value属性为undefined\r\n\t- Generator 函数内部有try...finally代码块，那么return方法会推迟到finally代码块执行完再执行\r\n\r\n- next()、throw()、return() 的共同点\r\n\r\n\t- 它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换yield表达式\r\n\t- next()是将yield表达式替换成一个值。\r\n\t- throw()是将yield表达式替换成一个throw语句\r\n\t- return()是将yield表达式替换成一个return语句\r\n\r\n- yield* 表达式\r\n\r\n\t- 如果在 Generator 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的\r\n\t- 用到yield*表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数\r\n\t- 任何数据结构只要有 Iterator 接口，就可以被yield*遍历\r\n\r\n- 作为对象属性的 Generator 函数\r\n\r\n\t- 属性前面有一个星号，表示这个属性是一个 Generator 函数\r\n\r\n- Generator 函数的this\r\n\r\n\t- Generator 函数也不能跟new命令一起用，会报错\r\n\t- 生成一个空对象，使用call方法绑定 Generator 函数内部的this\r\n\r\n- 含义\r\n\r\n\t- Generator 是实现状态机的最佳结构\r\n\t- 。Generator 函数被称为“半协程”（semi-coroutine），意思是只有 Generator 函数的调用者，才能将程序的执行权还给 Generator 函数\r\n\t- Generator 执行产生的上下文环境，一旦遇到yield命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态\r\n\r\n- 应用\r\n\r\n\t- Generator 可以暂停函数执行，返回任意表达式的值\r\n\r\n",Pr={data:function(){return{MainComponent:Mr}}},Or=Pr,Er=Object(m["a"])(Or,Tr,Cr,!1,null,"5bf07dd8",null),Rr=Er.exports,Nr=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},Ar=[],Dr="# es62\r\n\r\n## Iterator 和 for...of 循环\r\n\r\n### JS表示“集合”的数据结构\r\n\r\n- 数组（Array）\r\n- 对象（Object）\r\n- Map\r\n- Set\r\n\r\n### 遍历器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。\r\n\r\n- Iterator 的作用\r\n\r\n\t- 一是为各种数据结构，提供一个统一的、简便的访问接口；\r\n\t- 二是使得数据结构的成员能够按某种次序排列；\r\n\t- 三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费\r\n\r\n- 遍历过程\r\n\r\n\t- （1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。\r\n\t- （2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。\r\n\t- （3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。\r\n\t- （4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。\r\n\t- 每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。\r\n\r\n### 默认 Iterator 接口\r\n\r\n- ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性\r\n\r\n\t- Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名Symbol.iterator，它是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内（参见《Symbol》一章）。\r\n\r\n\t\t- const obj = {\r\n  [Symbol.iterator] : function () {\r\n    return {\r\n      next: function () {\r\n        return {\r\n          value: 1,\r\n          done: true\r\n        };\r\n      }\r\n    };\r\n  }\r\n};\r\n\r\n### 原生具备 Iterator 接口的数据结构如下。\r\n\r\n- Array\r\n\r\n\t- 下面的例子是数组的Symbol.iterator属性\r\n\r\n\t\t- let arr = ['a', 'b', 'c'];\r\nlet iter = arr[Symbol.iterator]();\r\n\r\niter.next() // { value: 'a', done: false }\r\niter.next() // { value: 'b', done: false }\r\niter.next() // { value: 'c', done: false }\r\niter.next() // { value: undefined, done: true }\r\n\r\n- Map\r\n- Set\r\n- String\r\n- TypedArray\r\n- 函数的 arguments 对象\r\n- NodeList 对象\r\n\r\n### 调用 Iterator 接口的场合\r\n\r\n- （1）解构赋值\r\n\r\n\t- 对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法。\r\n\r\n\t\t- let set = new Set().add('a').add('b').add('c');\r\n\r\nlet [x,y] = set;\r\n// x='a'; y='b'\r\n\r\nlet [first, ...rest] = set;\r\n// first='a'; rest=['b','c'];\r\n\r\n- （2）扩展运算符\r\n\r\n\t- 扩展运算符（...）也会调用默认的 Iterator 接口。\r\n\r\n\t\t- // 例一\r\nvar str = 'hello';\r\n[...str] //  ['h','e','l','l','o']\r\n\r\n// 例二\r\nlet arr = ['b', 'c'];\r\n['a', ...arr, 'd']\r\n// ['a', 'b', 'c', 'd']\r\n\r\n\t\t\t- 实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。\r\n也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。\r\n\r\n\t\t\t\t- let arr = [...iterable];\r\n\r\n- （3）yield*\r\n\r\n\t- yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。\r\n\r\n\t\t- let generator = function* () {\r\n  yield 1;\r\n  yield* [2,3,4];\r\n  yield 5;\r\n};\r\n\r\nvar iterator = generator();\r\n\r\niterator.next() // { value: 1, done: false }\r\niterator.next() // { value: 2, done: false }\r\niterator.next() // { value: 3, done: false }\r\niterator.next() // { value: 4, done: false }\r\niterator.next() // { value: 5, done: false }\r\niterator.next() // { value: undefined, done: true }\r\n\r\n- （4）其他场合\r\n\r\n\t- 由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实\r\n都调用了遍历器接口。下面是一些例子。\r\n\r\n\t\t- for...of\r\nArray.from()\r\nMap(), Set(), WeakMap(), WeakSet()（比如new Map([['a',1],['b',2]])）\r\nPromise.all()\r\nPromise.race()\r\n\r\n### 字符串的 Iterator 接口\r\n\r\n- 字符串是一个类似数组的对象，也原生具有 Iterator 接口。\r\n\r\n\t- var someString = \"hi\";\r\ntypeof someString[Symbol.iterator]\r\n// \"function\"\r\n\r\nvar iterator = someString[Symbol.iterator]();\r\n\r\niterator.next()  // { value: \"h\", done: false }\r\niterator.next()  // { value: \"i\", done: false }\r\niterator.next()  // { value: undefined, done: true }\r\n\r\n\t\t- 上面代码中，调用Symbol.iterator方法返回一个遍历器对象，在这个遍历器上可以调用 next 方法，实现对于字符串的遍历。\r\n\r\n可以覆盖原生的Symbol.iterator方法，达到修改遍历器行为的目的。\r\n\r\n\t\t\t- var str = new String(\"hi\");\r\n\r\n[...str] // [\"h\", \"i\"]\r\n\r\nstr[Symbol.iterator] = function() {\r\n  return {\r\n    next: function() {\r\n      if (this._first) {\r\n        this._first = false;\r\n        return { value: \"bye\", done: false };\r\n      } else {\r\n        return { done: true };\r\n      }\r\n    },\r\n    _first: true\r\n  };\r\n};\r\n\r\n[...str] // [\"bye\"]\r\nstr // \"hi\"\r\n\r\n### Iterator 接口与 Generator 函数\r\n\r\n- Symbol.iterator方法的最简单实现，还是使用下一章要介绍的 Generator 函数。\r\n\r\n\t- let myIterable = {\r\n  [Symbol.iterator]: function* () {\r\n    yield 1;\r\n    yield 2;\r\n    yield 3;\r\n  }\r\n}\r\n[...myIterable] // [1, 2, 3]\r\n\r\n// 或者采用下面的简洁写法\r\n\r\nlet obj = {\r\n  * [Symbol.iterator]() {\r\n    yield 'hello';\r\n    yield 'world';\r\n  }\r\n};\r\n\r\nfor (let x of obj) {\r\n  console.log(x);\r\n}\r\n// \"hello\"\r\n// \"world\"\r\n\r\n\t\t- 上面代码中，Symbol.iterator方法几乎不用部署任何代码，只要用 yield 命令\r\n给出每一步的返回值即可。\r\n\r\n### 遍历器对象的 return()，throw()\r\n\r\n- 遍历器对象除了具有next方法，还可以具有return方法和throw方法。如果你自己写遍历器对象生成函数，那么next方法是必须部署的，return方法和throw方法是否部署是可选的。\r\n\r\nreturn方法的使用场合是，如果for...of循环提前退出（通常是因为出错，或者有break语句），就会调用return方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。\r\n\r\n\t- function readLinesSync(file) {\r\n  return {\r\n    [Symbol.iterator]() {\r\n      return {\r\n        next() {\r\n          return { done: false };\r\n        },\r\n        return() {\r\n          file.close();\r\n          return { done: true };\r\n        }\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\n\t\t- 上面代码中，函数readLinesSync接受一个文件对象作为参数，返回一个遍历器对象，其中除了next方法，还部署了return方法。\r\n下面的两种情况，都会触发执行return方法。\r\n\r\n\t\t\t- // 情况一\r\nfor (let line of readLinesSync(fileName)) {\r\n  console.log(line);\r\n  break;\r\n}\r\n\r\n// 情况二\r\nfor (let line of readLinesSync(fileName)) {\r\n  console.log(line);\r\n  throw new Error();\r\n}\r\n\r\n### for...of 循环\r\n\r\n- ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for...of循环，作为遍历所有数据结构的统一的方法。\r\n\r\n一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for...of循环遍历它的成员。也就是说，for...of循环内部调用的是数据结构的Symbol.iterator方法。\r\n\r\nfor...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。\r\n\r\n\t- 数组\r\n\r\n\t\t- 数组原生具备iterator接口（即默认部署了Symbol.iterator属性），for...of循环\r\n本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。\r\n\r\n\t\t\t- const arr = ['red', 'green', 'blue'];\r\n\r\nfor(let v of arr) {\r\n  console.log(v); // red green blue\r\n}\r\n\r\nconst obj = {};\r\nobj[Symbol.iterator] = arr[Symbol.iterator].bind(arr);\r\n\r\nfor(let v of obj) {\r\n  console.log(v); // red green blue\r\n}\r\n\r\n\t\t\t\t- 上面代码中，空对象obj部署了数组arr的Symbol.iterator属性，结果obj的for...of循环，产生了与arr完全一样的结果。\r\n\r\nfor...of循环可以代替数组实例的forEach方法。\r\n\r\n\t\t\t\t\t- const arr = ['red', 'green', 'blue'];\r\n\r\narr.forEach(function (element, index) {\r\n  console.log(element); // red green blue\r\n  console.log(index);   // 0 1 2\r\n});\r\n\r\n\t\t\t\t\t\t- JavaScript 原有的for...in循环，只能获得对象的键名，不能直接获取键值。ES6 提供for...of循环，允许遍历获得键值。\r\n\t\t\t\t\t\t- var arr = ['a', 'b', 'c', 'd'];\r\n\r\nfor (let a in arr) {\r\n  console.log(a); // 0 1 2 3\r\n}\r\n\r\nfor (let a of arr) {\r\n  console.log(a); // a b c d\r\n}\r\n\t\t\t\t\t\t- 上面代码表明，for...in循环读取键名，for...of循环读取键值。如果要通过for...of循环，获取数组的索引，可以借助数组实例的entries方法和keys方法（参见《数组的扩展》一章）。\r\n\r\nfor...of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟for...in循环也不一样。\r\n\t\t\t\t\t\t- let arr = [3, 5, 7];\r\narr.foo = 'hello';\r\n\r\nfor (let i in arr) {\r\n  console.log(i); // \"0\", \"1\", \"2\", \"foo\"\r\n}\r\n\r\nfor (let i of arr) {\r\n  console.log(i); //  \"3\", \"5\", \"7\"\r\n}\r\n\t\t\t\t\t\t- 上面代码中，for...of循环不会返回数组arr的foo属性。\r\n\r\n\t- Set 和 Map 结构\r\n\r\n\t\t- Set 和 Map 结构也原生具有 Iterator 接口，可以直接使用for...of循环。\r\n\r\n\t\t\t- var engines = new Set([\"Gecko\", \"Trident\", \"Webkit\", \"Webkit\"]);\r\nfor (var e of engines) {\r\n  console.log(e);\r\n}\r\n// Gecko\r\n// Trident\r\n// Webkit\r\n\r\nvar es6 = new Map();\r\nes6.set(\"edition\", 6);\r\nes6.set(\"committee\", \"TC39\");\r\nes6.set(\"standard\", \"ECMA-262\");\r\nfor (var [name, value] of es6) {\r\n  console.log(name + \": \" + value);\r\n}\r\n// edition: 6\r\n// committee: TC39\r\n// standard: ECMA-262\r\n\t\t\t- 上面代码演示了如何遍历 Set 结构和 Map 结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值。\r\n\t\t\t- let map = new Map().set('a', 1).set('b', 2);\r\nfor (let pair of map) {\r\n  console.log(pair);\r\n}\r\n// ['a', 1]\r\n// ['b', 2]\r\n\r\nfor (let [key, value] of map) {\r\n  console.log(key + ' : ' + value);\r\n}\r\n// a : 1\r\n// b : 2\r\n\r\n\t- 计算生成的数据结构\r\n\r\n\t\t- 有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。\r\n\r\nentries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用entries方法。\r\nkeys() 返回一个遍历器对象，用来遍历所有的键名。\r\nvalues() 返回一个遍历器对象，用来遍历所有的键值。\r\n这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。\r\n\r\n\t\t\t- let arr = ['a', 'b', 'c'];\r\nfor (let pair of arr.entries()) {\r\n  console.log(pair);\r\n}\r\n// [0, 'a']\r\n// [1, 'b']\r\n// [2, 'c']\r\n\r\n\t- 类似数组的对象\r\n\r\n\t\t- 类似数组的对象包括好几类。下面是for...of循环用于字符串、DOM NodeList 对象、arguments对象的例子。\r\n\r\n\t\t\t- // 字符串\r\nlet str = \"hello\";\r\n\r\nfor (let s of str) {\r\n  console.log(s); // h e l l o\r\n}\r\n\r\n// DOM NodeList对象\r\nlet paras = document.querySelectorAll(\"p\");\r\n\r\nfor (let p of paras) {\r\n  p.classList.add(\"test\");\r\n}\r\n\r\n// arguments对象\r\nfunction printArgs() {\r\n  for (let x of arguments) {\r\n    console.log(x);\r\n  }\r\n}\r\nprintArgs('a', 'b');\r\n// 'a'\r\n// 'b'\r\n\t\t\t- 并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用Array.from方法将其转为数组。\r\n\t\t\t- let arrayLike = { length: 2, 0: 'a', 1: 'b' };\r\n\r\n// 报错\r\nfor (let x of arrayLike) {\r\n  console.log(x);\r\n}\r\n\r\n// 正确\r\nfor (let x of Array.from(arrayLike)) {\r\n  console.log(x);\r\n}\r\n\r\n\t- 对象\r\n\r\n\t\t- 对于普通的对象，for...of结构不能直接使用，会报错，必须部署了 \r\nIterator 接口后才能使用。但是，这样情况下，for...in循环依然可以用来遍历键名。\r\n\r\n\t\t\t- let es6 = {\r\n  edition: 6,\r\n  committee: \"TC39\",\r\n  standard: \"ECMA-262\"\r\n};\r\n\r\nfor (let e in es6) {\r\n  console.log(e);\r\n}\r\n// edition\r\n// committee\r\n// standard\r\n\r\nfor (let e of es6) {\r\n  console.log(e);\r\n}\r\n// TypeError: es6[Symbol.iterator] is not a function\r\n\r\n\t- 与其他遍历语法的比较\r\n\r\n\t\t- 以数组为例，JavaScript 提供多种遍历语法。最原始的写法就是for循环。\r\n\r\n\t\t\t- for (var index = 0; index < myArray.length; index++) {\r\n  console.log(myArray[index]);\r\n}\r\n\r\n\t\t- 这种写法比较麻烦，因此数组提供内置的forEach方法。\r\n\r\n\t\t\t- myArray.forEach(function (value) {\r\n  console.log(value);\r\n});\r\n\t\t\t- 这种写法的问题在于，无法中途跳出forEach循环，break命令或return命令都不能奏效。\r\n\r\n\t\t- for...in循环可以遍历数组的键名。\r\n\r\n\t\t\t- for (var index in myArray) {\r\n  console.log(myArray[index]);\r\n}\r\n\r\n\t\t\t\t- for...in循环有几个缺点。\r\n\r\n\t\t\t\t\t- 数组的键名是数字，但是for...in循环是以字符串作为键名“0”、“1”、“2”等等。\r\n\t\t\t\t\t- for...in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。\r\n\t\t\t\t\t- 某些情况下，for...in循环会以任意顺序遍历键名。\r\n\t\t\t\t\t- 总之，for...in循环主要是为遍历对象而设计的，不适用于遍历数组。\r\n\r\n\t\t- for...of循环相比上面几种做法，有一些显著的优点。\r\n\r\n\t\t\t- for (let value of myArray) {\r\n  console.log(value);\r\n}\r\n\r\n\t\t\t\t- 有着同for...in一样的简洁语法，但是没有for...in那些缺点。\r\n\t\t\t\t- 不同于forEach方法，它可以与break、continue和return配合使用。\r\n\t\t\t\t- 提供了遍历所有数据结构的统一操作接口。\r\n\t\t\t\t- 下面是一个使用 break 语句，跳出for...of循环的例子。\r\n\r\n\t\t\t\t\t- for (var n of fibonacci) {\r\n  if (n > 1000)\r\n    break;\r\n  console.log(n);\r\n}\r\n\r\n\t\t\t\t\t\t- 上面的例子，会输出斐波纳契数列小于等于 1000 的项。如果当前项大于 1000，就会使用break语句跳出for...of循环。\r\n\r\n## Generator 函数的语法\r\n\r\n### 基本概念\r\n\r\n- Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。\r\n\r\nGenerator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。\r\n\r\n执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\r\n\r\n形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。\r\n- function* helloWorldGenerator() {\r\n  yield 'hello';\r\n  yield 'world';\r\n  return 'ending';\r\n}\r\n\r\nvar hw = helloWorldGenerator();\r\n- 上面代码定义了一个 Generator 函数helloWorldGenerator，它内部有两个yield表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。\r\n\r\n下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。\r\n- hw.next()\r\n// { value: 'hello', done: false }\r\n\r\nhw.next()\r\n// { value: 'world', done: false }\r\n\r\nhw.next()\r\n// { value: 'ending', done: true }\r\n\r\nhw.next()\r\n// { value: undefined, done: true }\r\n\r\n- 上面代码一共调用了四次next方法。\r\n\r\n第一次调用，Generator 函数开始执行，直到遇到第一个yield表达式为止。next方法返回一个对象，它的value属性就是当前yield表达式的值hello，done属性的值false，表示遍历还没有结束。\r\n\r\n第二次调用，Generator 函数从上次yield表达式停下的地方，一直执行到下一个yield表达式。next方法返回的对象的value属性就是当前yield表达式的值world，done属性的值false，表示遍历还没有结束。\r\n\r\n第三次调用，Generator 函数从上次yield表达式停下的地方，一直执行到return语句（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），done属性的值true，表示遍历已经结束。\r\n\r\n第四次调用，此时 Generator 函数已经运行完毕，next方法返回对象的value属性为undefined，done属性为true。以后再调用next方法，返回的都是这个值。\r\n\r\n总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。\r\n- function * foo(x, y) { ··· }\r\nfunction *foo(x, y) { ··· }\r\nfunction* foo(x, y) { ··· }\r\nfunction*foo(x, y) { ··· }\r\n由于 Generator 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在function关键字后面。本书也采用这种写法。\r\n\r\n### yield 表达式\r\n\r\n- 由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。\r\n\r\n\r\n\r\n\t- 遍历器对象的next方法的运行逻辑如下。\r\n\r\n\t\t- （1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。\r\n\t\t- （2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。\r\n\t\t- （3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。\r\n\t\t- （4）如果该函数没有return语句，则返回的对象的value属性值为undefined。\r\n\t\t- 需要注意的是，yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。\r\n\t\t- function* gen() {\r\n  yield  123 + 456;\r\n}\r\n\r\n\t\t- 上面代码中，yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值。\r\n\r\nyield表达式与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield表达式。正常函数只能返回一个值，因为只能执行一次return；Generator 函数可以返回一系列的值，因为可以有任意多个yield。从另一个角度看，也可以说 Generator 生成了一系列的值，这也就是它的名称的来历（英语中，generator 这个词是“生成器”的意思）。\r\n\t\t- Generator 函数可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数。\r\n\t\t- function* f() {\r\n  console.log('执行了！')\r\n}\r\n\r\nvar generator = f();\r\n\r\nsetTimeout(function () {\r\n  generator.next()\r\n}, 2000);\r\n\t\t- 上面代码中，函数f如果是普通函数，在为变量generator赋值时就会执行。但是，函数f是一个 Generator 函数，就变成只有调用next方法时，函数f才会执行。\r\n\r\n另外需要注意，yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。\r\n\r\n- 与 Iterator 接口的关系\r\n\r\n\t- 任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。\r\n\r\n由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。\r\n\r\n\t\t- var myIterable = {};\r\nmyIterable[Symbol.iterator] = function* () {\r\n  yield 1;\r\n  yield 2;\r\n  yield 3;\r\n};\r\n\r\n[...myIterable] // [1, 2, 3]\r\n\t\t- 上面代码中，Generator 函数赋值给Symbol.iterator属性，从而使得myIterable对象具有了 Iterator 接口，可以被...运算符遍历了。\r\n\r\n\t- Generator 函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。\r\n\r\n\t\t- function* gen(){\r\n  // some code\r\n}\r\n\r\nvar g = gen();\r\n\r\ng[Symbol.iterator]() === g\r\n// true\r\n\r\n\t\t\t- 上面代码中，gen是一个 Generator 函数，调用它会生成一个遍历器对象g。它的Symbol.iterator属性，也是一个遍历器对象生成函数，执行后返回它自己。\r\n\r\n- next 方法的参数\r\n\r\n\t- yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。\r\n\r\n\t\t- function* f() {\r\n  for(var i = 0; true; i++) {\r\n    var reset = yield i;\r\n    if(reset) { i = -1; }\r\n  }\r\n}\r\n\r\nvar g = f();\r\n\r\ng.next() // { value: 0, done: false }\r\ng.next() // { value: 1, done: false }\r\ng.next(true) // { value: 0, done: false }\r\n\t\t- 上面代码先定义了一个可以无限运行的 Generator 函数f，如果next方法没有参数，每次运行到yield表达式，变量reset的值总是undefined。当next方法带一个参数true时，变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。\r\n\r\n这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。\r\n\t\t- function* foo(x) {\r\n  var y = 2 * (yield (x + 1));\r\n  var z = yield (y / 3);\r\n  return (x + y + z);\r\n}\r\n\r\nvar a = foo(5);\r\na.next() // Object{value:6, done:false}\r\na.next() // Object{value:NaN, done:false}\r\na.next() // Object{value:NaN, done:true}\r\n\r\nvar b = foo(5);\r\nb.next() // { value:6, done:false }\r\nb.next(12) // { value:8, done:false }\r\nb.next(13) // { value:42, done:true }\r\n\t\t- 上面代码中，第二次运行next方法的时候不带参数，导致 y 的值等于2 * undefined（即NaN），除以 3 以后还是NaN，因此返回对象的value属性也等于NaN。第三次运行Next方法的时候不带参数，所以z等于undefined，返回对象的value属性等于5 + NaN + undefined，即NaN。\r\n\r\n如果向next方法提供参数，返回结果就完全不一样了。上面代码第一次调用b的next方法时，返回x+1的值6；第二次调用next方法，将上一次yield表达式的值设为12，因此y等于24，返回y / 3的值8；第三次调用next方法，将上一次yield表达式的值设为13，因此z等于13，这时x等于5，y等于24，所以return语句的值等于42。\r\n\r\n注意，由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。V8 引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。\r\n\r\n- for...of 循环\r\n\r\n\t- for...of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。\r\n\r\n\t\t- function* foo() {\r\n  yield 1;\r\n  yield 2;\r\n  yield 3;\r\n  yield 4;\r\n  yield 5;\r\n  return 6;\r\n}\r\n\r\nfor (let v of foo()) {\r\n  console.log(v);\r\n}\r\n// 1 2 3 4 5\r\n\r\n\t- 利用for...of循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口，\r\n无法使用for...of循环，通过 Generator 函数为它加上这个接口，就可以用了。\r\n\r\n\t\t- function* objectEntries(obj) {\r\n  let propKeys = Reflect.ownKeys(obj);\r\n\r\n  for (let propKey of propKeys) {\r\n    yield [propKey, obj[propKey]];\r\n  }\r\n}\r\n\r\nlet jane = { first: 'Jane', last: 'Doe' };\r\n\r\nfor (let [key, value] of objectEntries(jane)) {\r\n  console.log(`${key}: ${value}`);\r\n}\r\n// first: Jane\r\n// last: Doe\r\n\r\n\t- 除了for...of循环以外，扩展运算符（...）、解构赋值和Array.from方法内部调用的，都是遍历器接口。\r\n这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。\r\n\r\n\t\t- function* numbers () {\r\n  yield 1\r\n  yield 2\r\n  return 3\r\n  yield 4\r\n}\r\n\r\n// 扩展运算符\r\n[...numbers()] // [1, 2]\r\n\r\n// Array.from 方法\r\nArray.from(numbers()) // [1, 2]\r\n\r\n// 解构赋值\r\nlet [x, y] = numbers();\r\nx // 1\r\ny // 2\r\n\r\n// for...of 循环\r\nfor (let n of numbers()) {\r\n  console.log(n)\r\n}\r\n// 1\r\n// 2\r\n\r\n- Generator.prototype.throw() \r\n\r\n\t- Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。\r\n\r\n\t\t- var g = function* () {\r\n  try {\r\n    yield;\r\n  } catch (e) {\r\n    console.log('内部捕获', e);\r\n  }\r\n};\r\n\r\nvar i = g();\r\ni.next();\r\n\r\ntry {\r\n  i.throw('a');\r\n  i.throw('b');\r\n} catch (e) {\r\n  console.log('外部捕获', e);\r\n}\r\n// 内部捕获 a\r\n// 外部捕获 b\r\n\t\t- 上面代码中，遍历器对象i连续抛出两个错误。第一个错误被 Generator 函数体内的catch语句捕获。i第二次抛出错误，由于 Generator 函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的catch语句捕获。\r\n\t\t- throw方法可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象的实例。\r\n\t\t- var g = function* () {\r\n  try {\r\n    yield;\r\n  } catch (e) {\r\n    console.log(e);\r\n  }\r\n};\r\n\r\nvar i = g();\r\ni.next();\r\ni.throw(new Error('出错了！'));\r\n// Error: 出错了！(…)\r\n\r\n## async 函数\r\n\r\n### 含义\r\n\r\n- ES2017 标准引入了 async 函数，使得异步操作变得更加方便。\r\n\r\nasync 函数是什么？一句话，它就是 Generator 函数的语法糖。\r\n\r\n前文有一个 Generator 函数，依次读取两个文件。\r\n\r\n\t- const fs = require('fs');\r\n\r\nconst readFile = function (fileName) {\r\n  return new Promise(function (resolve, reject) {\r\n    fs.readFile(fileName, function(error, data) {\r\n      if (error) return reject(error);\r\n      resolve(data);\r\n    });\r\n  });\r\n};\r\n\r\nconst gen = function* () {\r\n  const f1 = yield readFile('/etc/fstab');\r\n  const f2 = yield readFile('/etc/shells');\r\n  console.log(f1.toString());\r\n  console.log(f2.toString());\r\n};\r\n\t- 写成async函数，就是下面这样。\r\n\t- const asyncReadFile = async function () {\r\n  const f1 = await readFile('/etc/fstab');\r\n  const f2 = await readFile('/etc/shells');\r\n  console.log(f1.toString());\r\n  console.log(f2.toString());\r\n};\r\n\t- 一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。\r\n\r\n### async函数对 Generator 函数的改进，体现在以下四点。\r\n\r\n- （1）内置执行器。\r\n\r\nGenerator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。\r\n\r\n\t- asyncReadFile();\r\n\r\n\t\t- 上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。\r\n\r\n- （2）更好的语义。\r\n\r\nasync和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。\r\n- 3）更广的适用性。\r\n\r\nco模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。\r\n- 4）返回值是 Promise。\r\n\r\nasync函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。\r\n\r\n进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。\r\n\r\n### 基本用法\r\n\r\n- async函数返回一个 Promise 对象，可以使用then方法添加回调函数。\r\n当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。\r\n\r\n\t- async function getStockPriceByName(name) {\r\n  const symbol = await getStockSymbol(name);\r\n  const stockPrice = await getStockPrice(symbol);\r\n  return stockPrice;\r\n}\r\n\r\ngetStockPriceByName('goog').then(function (result) {\r\n  console.log(result);\r\n});\r\n\r\n### 语法\r\n\r\n- 返回 Promise 对象\r\n\r\n\t- async函数返回一个 Promise 对象。\r\n\r\nasync函数内部return语句返回的值，会成为then方法回调函数的参数。\r\n\r\n\t\t- async function f() {\r\n  return 'hello world';\r\n}\r\n\r\nf().then(v => console.log(v))\r\n// \"hello world\"\r\n\r\n\t\t\t- 上面代码中，函数f内部return命令返回的值，会被then方法回调函数接收到。\r\n\r\n- Promise 对象的状态变化\r\n\r\n\t- async function getTitle(url) {\r\n  let response = await fetch(url);\r\n  let html = await response.text();\r\n  return html.match(/<title>([\\s\\S]+)<\\/title>/i)[1];\r\n}\r\ngetTitle('https://tc39.github.io/ecma262/').then(console.log)\r\n// \"ECMAScript 2017 Language Specification\"\r\n\r\n\t\t- 上面代码中，函数getTitle内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行then方法里面的console.log。\r\n\r\n\r\n\r\n- await 命令\r\n\r\n\t- 正常情况下，await命令后面是一个 Promise 对象。如果不是，就返回对应的值。\r\n\r\n\t\t- async function f() {\r\n  // 等同于\r\n  // return 123;\r\n  return await 123;\r\n}\r\n\r\nf().then(v => console.log(v))\r\n// 123\r\n\r\n\t- await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。\r\n\r\n\t\t- async function f() {\r\n  await Promise.reject('出错了');\r\n}\r\n\r\nf()\r\n.then(v => console.log(v))\r\n.catch(e => console.log(e))\r\n// 出错了\r\n\t\t- 注意，上面代码中，await语句前面没有return，但是reject方法的参数依然传入了catch方法的回调函数。这里如果在await前面加上return，效果是一样的。\r\n\t\t- 只要一个await语句后面的 Promise 变为reject，那么整个async函数都会中断执行。\r\n\t\t- async function f() {\r\n  await Promise.reject('出错了');\r\n  await Promise.resolve('hello world'); // 不会执行\r\n}\r\n\t\t- 有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在try...catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。\r\n\t\t- async function f() {\r\n  try {\r\n    await Promise.reject('出错了');\r\n  } catch(e) {\r\n  }\r\n  return await Promise.resolve('hello world');\r\n}\r\n\r\nf()\r\n.then(v => console.log(v))\r\n// hello world\r\n\t\t- 另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。\r\n\t\t- async function f() {\r\n  await Promise.reject('出错了')\r\n    .catch(e => console.log(e));\r\n  return await Promise.resolve('hello world');\r\n}\r\n\r\nf()\r\n.then(v => console.log(v))\r\n// 出错了\r\n// hello world\r\n\r\n- 错误处理\r\n\r\n\t- 如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。\r\n\r\n\t\t- async function f() {\r\n  await new Promise(function (resolve, reject) {\r\n    throw new Error('出错了');\r\n  });\r\n}\r\n\r\nf()\r\n.then(v => console.log(v))\r\n.catch(e => console.log(e))\r\n// Error：出错了\r\n\t\t- 上面代码中，async函数f执行后，await后面的 Promise 对象会抛出一个错误对象，导致catch方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。\r\n\t\t- 防止出错的方法，也是将其放在try...catch代码块之中\r\n\t\t- async function f() {\r\n  try {\r\n    await new Promise(function (resolve, reject) {\r\n      throw new Error('出错了');\r\n    });\r\n  } catch(e) {\r\n  }\r\n  return await('hello world');\r\n}\r\n\t\t- 如果有多个await命令，可以统一放在try...catch结构中。\r\n\t\t- async function main() {\r\n  try {\r\n    const val1 = await firstStep();\r\n    const val2 = await secondStep(val1);\r\n    const val3 = await thirdStep(val1, val2);\r\n\r\n    console.log('Final: ', val3);\r\n  }\r\n  catch (err) {\r\n    console.error(err);\r\n  }\r\n}\r\n\r\n- 使用注意点\r\n\r\n\t- 第一点，前面已经说过，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try...catch代码块中。\r\n\r\n\t\t- async function myFunction() {\r\n  try {\r\n    await somethingThatReturnsAPromise();\r\n  } catch (err) {\r\n    console.log(err);\r\n  }\r\n}\r\n\r\n// 另一种写法\r\n\r\nasync function myFunction() {\r\n  await somethingThatReturnsAPromise()\r\n  .catch(function (err) {\r\n    console.log(err);\r\n  });\r\n}\r\n\r\n\t- 第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。\r\n\r\n\t\t- let foo = await getFoo();\r\nlet bar = await getBar();\r\n\t\t- 上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。\r\n\t\t- // 写法一\r\nlet [foo, bar] = await Promise.all([getFoo(), getBar()]);\r\n\r\n// 写法二\r\nlet fooPromise = getFoo();\r\nlet barPromise = getBar();\r\nlet foo = await fooPromise;\r\nlet bar = await barPromise;\r\n\t\t- 上面两种写法，getFoo和getBar都是同时触发，这样就会缩短程序的执行时间。\r\n\r\n\t- 第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。\r\n\r\n\t\t- async function dbFuc(db) {\r\n  let docs = [{}, {}, {}];\r\n\r\n  // 报错\r\n  docs.forEach(function (doc) {\r\n    await db.post(doc);\r\n  });\r\n}\r\n\t\t- 上面代码会报错，因为await用在普通函数之中了。但是，如果将forEach方法的参数改成async函数，也有问题。\r\n\t\t- function dbFuc(db) { //这里不需要 async\r\n  let docs = [{}, {}, {}];\r\n\r\n  // 可能得到错误结果\r\n  docs.forEach(async function (doc) {\r\n    await db.post(doc);\r\n  });\r\n}\r\n\t\t- 上面代码可能不会正常工作，原因是这时三个db.post操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。\r\n\t\t- async function dbFuc(db) {\r\n  let docs = [{}, {}, {}];\r\n\r\n  for (let doc of docs) {\r\n    await db.post(doc);\r\n  }\r\n}\r\n\r\n### async 函数的实现原理\r\n\r\n- async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。\r\n\r\n\t- async function fn(args) {\r\n  // ...\r\n}\r\n\r\n// 等同于\r\n\r\nfunction fn(args) {\r\n  return spawn(function* () {\r\n    // ...\r\n  });\r\n}\r\n\t- 所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器。\r\n\t- spawn函数的实现，基本就是前文自动执行器的翻版\r\n\t- function spawn(genF) {\r\n  return new Promise(function(resolve, reject) {\r\n    const gen = genF();\r\n    function step(nextF) {\r\n      let next;\r\n      try {\r\n        next = nextF();\r\n      } catch(e) {\r\n        return reject(e);\r\n      }\r\n      if(next.done) {\r\n        return resolve(next.value);\r\n      }\r\n      Promise.resolve(next.value).then(function(v) {\r\n        step(function() { return gen.next(v); });\r\n      }, function(e) {\r\n        step(function() { return gen.throw(e); });\r\n      });\r\n    }\r\n    step(function() { return gen.next(undefined); });\r\n  });\r\n}\r\n\r\n## Class 的基本语法\r\n\r\n### 简介\r\n\r\n- JavaScript 语言中，生成实例对象的传统方法是通过构造函数\r\n\r\n\t- function Point(x, y) {\r\n  this.x = x;\r\n  this.y = y;\r\n}\r\n\r\nPoint.prototype.toString = function () {\r\n  return '(' + this.x + ', ' + this.y + ')';\r\n};\r\n\r\nvar p = new Point(1, 2);\r\n\t- 上面的代码用 ES6 的class改写，就是下面这样。\r\n\t- //定义类\r\nclass Point {\r\n  constructor(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n  }\r\n\r\n  toString() {\r\n    return '(' + this.x + ', ' + this.y + ')';\r\n  }\r\n}\r\n\t- 定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。\r\n\r\n- ES6 的类，完全可以看作构造函数的另一种写法。\r\n\r\n\t- class Point {\r\n  // ...\r\n}\r\n\r\ntypeof Point // \"function\"\r\nPoint === Point.prototype.constructor // true\r\n\t- 上面代码表明，类的数据类型就是函数，类本身就指向构造函数。\r\n\t- 使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。\r\n\t- 构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。\r\n\r\n\t\t- class Point {\r\n  constructor() {\r\n    // ...\r\n  }\r\n\r\n  toString() {\r\n    // ...\r\n  }\r\n\r\n  toValue() {\r\n    // ...\r\n  }\r\n}\r\n\r\n// 等同于\r\n\r\nPoint.prototype = {\r\n  constructor() {},\r\n  toString() {},\r\n  toValue() {},\r\n};\r\n\r\n\t- 在类的实例上面调用方法，其实就是调用原型上的方法。\r\n\r\n\t\t- class B {}\r\nlet b = new B();\r\n\r\nb.constructor === B.prototype.constructor // true\r\n\t\t- 上面代码中，b是B类的实例，它的constructor方法就是B类原型的constructor方法。\r\n\r\n\t- 由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。\r\n\r\n\t\t- class Point {\r\n  constructor(){\r\n    // ...\r\n  }\r\n}\r\n\r\nObject.assign(Point.prototype, {\r\n  toString(){},\r\n  toValue(){}\r\n});\r\n\r\n\t- prototype对象的constructor属性，直接指向“类”的本身，这与 ES5 的行为是一致的。\r\n\r\n\t\t- Point.prototype.constructor === Point // true\r\n\r\n\t- 另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。\r\n\r\n\t\t- class Point {\r\n  constructor(x, y) {\r\n    // ...\r\n  }\r\n\r\n  toString() {\r\n    // ...\r\n  }\r\n}\r\n\r\nObject.keys(Point.prototype)\r\n// []\r\nObject.getOwnPropertyNames(Point.prototype)\r\n// [\"constructor\",\"toString\"]\r\n\t\t- 上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致。\r\n\r\n- 类的属性名，可以采用表达式。\r\n\r\n\t- let methodName = 'getArea';\r\n\r\nclass Square {\r\n  constructor(length) {\r\n    // ...\r\n  }\r\n\r\n  [methodName]() {\r\n    // ...\r\n  }\r\n}\r\n\t- 上面代码中，Square类的方法名getArea，是从表达式得到的。\r\n\r\n### 严格模式\r\n\r\n- 类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。\r\n\r\n考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。\r\n\r\n### constructor 方法\r\n\r\n- constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。\r\n\r\n\t- class Point {\r\n}\r\n\r\n// 等同于\r\nclass Point {\r\n  constructor() {}\r\n}\r\n\r\n- constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。\r\n\r\n\t- class Foo {\r\n  constructor() {\r\n    return Object.create(null);\r\n  }\r\n}\r\n\r\nnew Foo() instanceof Foo\r\n// false\r\n\t- 上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。\r\n\r\n- 类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。\r\n\r\n\t- class Foo {\r\n  constructor() {\r\n    return Object.create(null);\r\n  }\r\n}\r\n\r\nFoo()\r\n// TypeError: Class constructor Foo cannot be invoked without 'new'\r\n\r\n### 类的实例对象\r\n\r\n- 生成类的实例对象的写法，与 ES5 完全一样，也是使用new命令。前面说过，如果忘记加上new，像函数那样调用Class，将会报错。\r\n\r\n\t- class Point {\r\n  // ...\r\n}\r\n\r\n// 报错\r\nvar point = Point(2, 3);\r\n\r\n// 正确\r\nvar point = new Point(2, 3);\r\n\r\n- 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。\r\n\r\n\t- //定义类\r\nclass Point {\r\n\r\n  constructor(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n  }\r\n\r\n  toString() {\r\n    return '(' + this.x + ', ' + this.y + ')';\r\n  }\r\n\r\n}\r\n\r\nvar point = new Point(2, 3);\r\n\r\npoint.toString() // (2, 3)\r\n\r\npoint.hasOwnProperty('x') // true\r\npoint.hasOwnProperty('y') // true\r\npoint.hasOwnProperty('toString') // false\r\npoint.__proto__.hasOwnProperty('toString') // true\r\n\t- 上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与 ES5 的行为保持一致。\r\n\t- 与 ES5 一样，类的所有实例共享一个原型对象。\r\n\r\n\t\t- var p1 = new Point(2,3);\r\nvar p2 = new Point(3,2);\r\n\r\np1.__proto__ === p2.__proto__\r\n//true\r\n\t\t- 上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以__proto__属性是相等的。\r\n\r\n这也意味着，可以通过实例的__proto__属性为“类”添加方法。\r\n\t\t- __proto__ 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。\r\n\t\t- var p1 = new Point(2,3);\r\nvar p2 = new Point(3,2);\r\n\r\np1.__proto__.printName = function () { return 'Oops' };\r\n\r\np1.printName() // \"Oops\"\r\np2.printName() // \"Oops\"\r\n\r\nvar p3 = new Point(4,2);\r\np3.printName() // \"Oops\"\r\n\t\t- 上面代码在p1的原型上添加了一个printName方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。\r\n\r\n### Class 表达式 \r\n\r\n- 与函数一样，类也可以使用表达式的形式定义。\r\n\r\n\t- const MyClass = class Me {\r\n  getClassName() {\r\n    return Me.name;\r\n  }\r\n};\r\n\t- 上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在 Class 的内部代码可用，指代当前类。\r\n\t- let inst = new MyClass();\r\ninst.getClassName() // Me\r\nMe.name // ReferenceError: Me is not defined\r\n\t- 上面代码表示，Me只在 Class 内部有定义。\r\n\r\n如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。\r\n\t- const MyClass = class { /* ... */ };\r\n\r\n- 采用 Class 表达式，可以写出立即执行的 Class。\r\n\r\n\t- let person = new class {\r\n  constructor(name) {\r\n    this.name = name;\r\n  }\r\n\r\n  sayName() {\r\n    console.log(this.name);\r\n  }\r\n}('张三');\r\n\r\nperson.sayName(); // \"张三\"\r\n\r\n### 不存在变量提升\r\n\r\n- 类不存在变量提升（hoist），这一点与 ES5 完全不同。\r\n\r\n\t- new Foo(); // ReferenceError\r\nclass Foo {}\r\n\t- 上面代码中，Foo类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。\r\n\r\n- {\r\n  let Foo = class {};\r\n  class Bar extends Foo {\r\n  }\r\n}\r\n\r\n\t- 上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。\r\n\r\n### 私有方法和私有属性\r\n\r\n- 现有的方法\r\n\r\n\t- 私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。\r\n\r\n一种做法是在命名上加以区别。\r\n\r\n\t\t- class Widget {\r\n\r\n  // 公有方法\r\n  foo (baz) {\r\n    this._bar(baz);\r\n  }\r\n\r\n  // 私有方法\r\n  _bar(baz) {\r\n    return this.snaf = baz;\r\n  }\r\n\r\n  // ...\r\n}\r\n\t\t- 上面代码中，_bar方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。\r\n\t\t- 另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。\r\n\t\t- class Widget {\r\n  foo (baz) {\r\n    bar.call(this, baz);\r\n  }\r\n\r\n  // ...\r\n}\r\n\r\nfunction bar(baz) {\r\n  return this.snaf = baz;\r\n}\r\n\t\t- 上面代码中，foo是公有方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。\r\n\t\t- 还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。\r\n\t\t- const bar = Symbol('bar');\r\nconst snaf = Symbol('snaf');\r\n\r\nexport default class myClass{\r\n\r\n  // 公有方法\r\n  foo(baz) {\r\n    this[bar](baz);\r\n  }\r\n\r\n  // 私有方法\r\n  [bar](baz) {\r\n    return this[snaf] = baz;\r\n  }\r\n\r\n  // ...\r\n};\r\n\t\t- 上面代码中，bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。\r\n\r\n### this 的指向 \r\n\r\n- 类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。\r\n\r\n\t- class Logger {\r\n  printName(name = 'there') {\r\n    this.print(`Hello ${name}`);\r\n  }\r\n\r\n  print(text) {\r\n    console.log(text);\r\n  }\r\n}\r\n\r\nconst logger = new Logger();\r\nconst { printName } = logger;\r\nprintName(); // TypeError: Cannot read property 'print' of undefined\r\n\r\n\t- 上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。\r\n\t- 一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。\r\n\t- class Logger {\r\n  constructor() {\r\n    this.printName = this.printName.bind(this);\r\n  }\r\n\r\n  // ...\r\n}\r\n\t- 另一种解决方法是使用箭头函数。\r\n\t- class Logger {\r\n  constructor() {\r\n    this.printName = (name = 'there') => {\r\n      this.print(`Hello ${name}`);\r\n    };\r\n  }\r\n\r\n  // ...\r\n}\r\n\r\n### name 属性 \r\n\r\n- 由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。\r\n\r\n\t- class Point {}\r\nPoint.name // \"Point\"\r\n\r\n\t\t- name属性总是返回紧跟在class关键字后面的类名。\r\n\r\n### Class 的取值函数（getter）和存值函数（setter）\r\n\r\n- 与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。\r\n\r\n\t- class MyClass {\r\n  constructor() {\r\n    // ...\r\n  }\r\n  get prop() {\r\n    return 'getter';\r\n  }\r\n  set prop(value) {\r\n    console.log('setter: '+value);\r\n  }\r\n}\r\n\r\nlet inst = new MyClass();\r\n\r\ninst.prop = 123;\r\n// setter: 123\r\n\r\ninst.prop\r\n// 'getter'\r\n\t- 上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了\r\n\r\n- 存值函数和取值函数是设置在属性的 Descriptor 对象上的。\r\n\r\n\t- class CustomHTMLElement {\r\n  constructor(element) {\r\n    this.element = element;\r\n  }\r\n\r\n  get html() {\r\n    return this.element.innerHTML;\r\n  }\r\n\r\n  set html(value) {\r\n    this.element.innerHTML = value;\r\n  }\r\n}\r\n\r\nvar descriptor = Object.getOwnPropertyDescriptor(\r\n  CustomHTMLElement.prototype, \"html\"\r\n);\r\n\r\n\"get\" in descriptor  // true\r\n\"set\" in descriptor  // true\r\n\t- 上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与 ES5 完全一致。\r\n\r\n### Class 的 Generator 方法\r\n\r\n- 如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。\r\n\r\n\t- class Foo {\r\n  constructor(...args) {\r\n    this.args = args;\r\n  }\r\n  * [Symbol.iterator]() {\r\n    for (let arg of this.args) {\r\n      yield arg;\r\n    }\r\n  }\r\n}\r\n\r\nfor (let x of new Foo('hello', 'world')) {\r\n  console.log(x);\r\n}\r\n// hello\r\n// world\r\n\t- 上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个 Generator 函数。Symbol.iterator方法返回一个Foo类的默认遍历器，for...of循环会自动调用这个遍历器。\r\n\r\n### Class 的静态方法\r\n\r\n- 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。\r\n\r\n\t- class Foo {\r\n  static classMethod() {\r\n    return 'hello';\r\n  }\r\n}\r\n\r\nFoo.classMethod() // 'hello'\r\n\r\nvar foo = new Foo();\r\nfoo.classMethod()\r\n// TypeError: foo.classMethod is not a function\r\n\t- 上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。\r\n\t- 注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。\r\n\t- class Foo {\r\n  static bar () {\r\n    this.baz();\r\n  }\r\n  static baz () {\r\n    console.log('hello');\r\n  }\r\n  baz () {\r\n    console.log('world');\r\n  }\r\n}\r\n\r\nFoo.bar() // hello\r\n\t- 上面代码中，静态方法bar调用了this.baz，这里的this指的是Foo类，而不是Foo的实例，等同于调用Foo.baz。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。\r\n\t- 父类的静态方法，可以被子类继承。\r\n\t- class Foo {\r\n  static classMethod() {\r\n    return 'hello';\r\n  }\r\n}\r\n\r\nclass Bar extends Foo {\r\n}\r\n\r\nBar.classMethod() // 'hello'\r\n\t- 上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。\r\n\t- 静态方法也是可以从super对象上调用的。\r\n\t- class Foo {\r\n  static classMethod() {\r\n    return 'hello';\r\n  }\r\n}\r\n\r\nclass Bar extends Foo {\r\n  static classMethod() {\r\n    return super.classMethod() + ', too';\r\n  }\r\n}\r\n\r\nBar.classMethod() // \"hello, too\"\r\n\r\n### Class 的静态属性和实例属性\r\n\r\n- 静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。\r\n\r\n\t- class Foo {\r\n}\r\n\r\nFoo.prop = 1;\r\nFoo.prop // 1\r\n\t- 目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。\r\n\t- // 以下两种写法都无效\r\nclass Foo {\r\n  // 写法一\r\n  prop: 2\r\n\r\n  // 写法二\r\n  static prop: 2\r\n}\r\n\r\nFoo.prop // undefined\r\n\r\n- 目前有一个静态属性的提案，对实例属性和静态属性都规定了新的写法。\r\n\r\n\t- （1）类的实例属性\r\n\r\n\t\t- 类的实例属性可以用等式，写入类的定义之中。\r\n\r\n\t\t\t- class MyClass {\r\n  myProp = 42;\r\n\r\n  constructor() {\r\n    console.log(this.myProp); // 42\r\n  }\r\n}\r\n\t\t\t- 上面代码中，myProp就是MyClass的实例属性。在MyClass的实例上，可以读取这个属性。\r\n\t\t\t- 以前，我们定义实例属性，只能写在类的constructor方法里面。\r\n\t\t\t- class ReactCounter extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      count: 0\r\n    };\r\n  }\r\n}\r\n\t\t\t- 有了新的写法以后，可以不在constructor方法里面定义。\r\n\t\t\t- class ReactCounter extends React.Component {\r\n  state = {\r\n    count: 0\r\n  };\r\n}\r\n\r\n\t- 类的静态属性\r\n\r\n\t\t- 类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。\r\n\r\n\t\t\t- class MyClass {\r\n  static myStaticProp = 42;\r\n\r\n  constructor() {\r\n    console.log(MyClass.myStaticProp); // 42\r\n  }\r\n}\r\n\r\n\t\t- 同样的，这个新写法大大方便了静态属性的表达。\r\n\r\n\t\t\t- // 老写法\r\nclass Foo {\r\n  // ...\r\n}\r\nFoo.prop = 1;\r\n\r\n// 新写法\r\nclass Foo {\r\n  static prop = 1;\r\n}\r\n\t\t\t- 上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。\r\n\r\n### new.target 属性\r\n\r\n- new是从构造函数生成实例对象的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。\r\n\r\n\t- function Person(name) {\r\n  if (new.target !== undefined) {\r\n    this.name = name;\r\n  } else {\r\n    throw new Error('必须使用 new 命令生成实例');\r\n  }\r\n}\r\n\r\n// 另一种写法\r\nfunction Person(name) {\r\n  if (new.target === Person) {\r\n    this.name = name;\r\n  } else {\r\n    throw new Error('必须使用 new 命令生成实例');\r\n  }\r\n}\r\n\r\nvar person = new Person('张三'); // 正确\r\nvar notAPerson = Person.call(person, '张三');  // 报错\r\n\t- 上面代码确保构造函数只能通过new命令调用。\r\n\r\n- Class 内部调用new.target，返回当前 Class。\r\n\r\n\t- class Rectangle {\r\n  constructor(length, width) {\r\n    console.log(new.target === Rectangle);\r\n    this.length = length;\r\n    this.width = width;\r\n  }\r\n}\r\n\r\nvar obj = new Rectangle(3, 4); // 输出 true\r\n\r\n- 需要注意的是，子类继承父类时，new.target会返回子类。\r\n\r\n\t- 利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。\r\n\r\n\t\t- class Shape {\r\n  constructor() {\r\n    if (new.target === Shape) {\r\n      throw new Error('本类不能实例化');\r\n    }\r\n  }\r\n}\r\n\r\nclass Rectangle extends Shape {\r\n  constructor(length, width) {\r\n    super();\r\n    // ...\r\n  }\r\n}\r\n\r\nvar x = new Shape();  // 报错\r\nvar y = new Rectangle(3, 4);  // 正确\r\n\t\t- 上面代码中，Shape类不能被实例化，只能用于继承。\r\n\r\n注意，在函数外部，使用new.target会报错。\r\n\r\n## Class 的继承\r\n\r\n### 简介\r\n\r\n- Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。\r\n\r\n\t- class Point {\r\n}\r\n\r\nclass ColorPoint extends Point {\r\n}\r\n\t- 上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。\r\n\t- class ColorPoint extends Point {\r\n  constructor(x, y, color) {\r\n    super(x, y); // 调用父类的constructor(x, y)\r\n    this.color = color;\r\n  }\r\n\r\n  toString() {\r\n    return this.color + ' ' + super.toString(); // 调用父类的toString()\r\n  }\r\n}\r\n\t- 上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。\r\n\t- 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。\r\n\t- class Point { /* ... */ }\r\n\r\nclass ColorPoint extends Point {\r\n  constructor() {\r\n  }\r\n}\r\n\r\nlet cp = new ColorPoint(); // ReferenceError\r\n\t- 上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。\r\n\t- ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。\r\n\t- 如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。\r\n\r\n\t\t- class ColorPoint extends Point {\r\n}\r\n\r\n// 等同于\r\nclass ColorPoint extends Point {\r\n  constructor(...args) {\r\n    super(...args);\r\n  }\r\n}\r\n\r\n\t- 另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。\r\n\r\n\t\t- class Point {\r\n  constructor(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n  }\r\n}\r\n\r\nclass ColorPoint extends Point {\r\n  constructor(x, y, color) {\r\n    this.color = color; // ReferenceError\r\n    super(x, y);\r\n    this.color = color; // 正确\r\n  }\r\n}\r\n\t\t- 上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。\r\n\t\t- 下面是生成子类实例的代码。\r\n\t\t- let cp = new ColorPoint(25, 8, 'green');\r\n\r\ncp instanceof ColorPoint // true\r\ncp instanceof Point // true\r\n\t\t- 上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与 ES5 的行为完全一致。\r\n\t\t- 最后，父类的静态方法，也会被子类继承。\r\n\t\t- class A {\r\n  static hello() {\r\n    console.log('hello world');\r\n  }\r\n}\r\n\r\nclass B extends A {\r\n}\r\n\r\nB.hello()  // hello world\r\n\t\t- 上面代码中，hello()是A类的静态方法，B继承A，也继承了A的静态方法。\r\n\r\n### Object.getPrototypeOf()\r\n\r\n- Object.getPrototypeOf方法可以用来从子类上获取父类。\r\n\r\n\t- Object.getPrototypeOf(ColorPoint) === Point\r\n// true\r\n\t- 因此，可以使用这个方法判断，一个类是否继承了另一个类。\r\n\r\n### super 关键字\r\n\r\n- super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。\r\n\r\n\t- 第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。\r\n\r\n\t\t- class A {}\r\n\r\nclass B extends A {\r\n  constructor() {\r\n    super();\r\n  }\r\n}\r\n\t\t- 上面代码中，子类B的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。\r\n\t\t- 注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。\r\n\t\t- class A {\r\n  constructor() {\r\n    console.log(new.target.name);\r\n  }\r\n}\r\nclass B extends A {\r\n  constructor() {\r\n    super();\r\n  }\r\n}\r\nnew A() // A\r\nnew B() // B\r\n\t\t- 上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。\r\n\t\t- 作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。\r\n\t\t- class A {}\r\n\r\nclass B extends A {\r\n  m() {\r\n    super(); // 报错\r\n  }\r\n}\r\n\r\n\t- 第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。\r\n\r\n\t\t- class A {\r\n  p() {\r\n    return 2;\r\n  }\r\n}\r\n\r\nclass B extends A {\r\n  constructor() {\r\n    super();\r\n    console.log(super.p()); // 2\r\n  }\r\n}\r\n\r\nlet b = new B();\r\n\t\t- 上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。\r\n\t\t- ES6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。\r\n\t\t- class A {\r\n  constructor() {\r\n    this.x = 1;\r\n  }\r\n  print() {\r\n    console.log(this.x);\r\n  }\r\n}\r\n\r\nclass B extends A {\r\n  constructor() {\r\n    super();\r\n    this.x = 2;\r\n  }\r\n  m() {\r\n    super.print();\r\n  }\r\n}\r\n\r\nlet b = new B();\r\nb.m() // 2\r\n\t\t- 上面代码中，super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()内部的this指向子类B的实例，导致输出的是2，而不是1。也就是说，实际上执行的是super.print.call(this)。\r\n\r\n由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。\r\n\t\t- class A {\r\n  constructor() {\r\n    this.x = 1;\r\n  }\r\n}\r\n\r\nclass B extends A {\r\n  constructor() {\r\n    super();\r\n    this.x = 2;\r\n    super.x = 3;\r\n    console.log(super.x); // undefined\r\n    console.log(this.x); // 3\r\n  }\r\n}\r\n\r\nlet b = new B();\r\n\t\t- 上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。\r\n\t\t- 如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。\r\n\t\t- class Parent {\r\n  static myMethod(msg) {\r\n    console.log('static', msg);\r\n  }\r\n\r\n  myMethod(msg) {\r\n    console.log('instance', msg);\r\n  }\r\n}\r\n\r\nclass Child extends Parent {\r\n  static myMethod(msg) {\r\n    super.myMethod(msg);\r\n  }\r\n\r\n  myMethod(msg) {\r\n    super.myMethod(msg);\r\n  }\r\n}\r\n\r\nChild.myMethod(1); // static 1\r\n\r\nvar child = new Child();\r\nchild.myMethod(2); // instance 2\r\n\t\t- 上面代码中，super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。\r\n\t\t- 另外，在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。\r\n\t\t- class A {\r\n  constructor() {\r\n    this.x = 1;\r\n  }\r\n  static print() {\r\n    console.log(this.x);\r\n  }\r\n}\r\n\r\nclass B extends A {\r\n  constructor() {\r\n    super();\r\n    this.x = 2;\r\n  }\r\n  static m() {\r\n    super.print();\r\n  }\r\n}\r\n\r\nB.x = 3;\r\nB.m() // 3\r\n\t\t- 上面代码中，静态方法B.m里面，super.print指向父类的静态方法。这个方法里面的this指向的是B，而不是B的实例。\r\n\t\t- 注意，使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。\r\n\t\t- class A {}\r\n\r\nclass B extends A {\r\n  constructor() {\r\n    super();\r\n    console.log(super); // 报错\r\n  }\r\n}\r\n\t\t- 上面代码中，console.log(super)当中的super，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明super的数据类型，就不会报错。\r\n\t\t- class A {}\r\n\r\nclass B extends A {\r\n  constructor() {\r\n    super();\r\n    console.log(super.valueOf() instanceof B); // true\r\n  }\r\n}\r\n\r\nlet b = new B();\r\n\t\t- 上面代码中，super.valueOf()表明super是一个对象，因此就不会报错。同时，由于super使得this指向B的实例，所以super.valueOf()返回的是一个B的实例。\r\n\t\t- 最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。\r\n\t\t- var obj = {\r\n  toString() {\r\n    return \"MyObject: \" + super.toString();\r\n  }\r\n};\r\n\r\nobj.toString(); // MyObject: [object Object]\r\n\r\n### 类的 prototype 属性和__proto__属性\r\n\r\n- 大多数浏览器的 ES5 实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。\r\n\r\n\t- （1）子类的__proto__属性，表示构造函数的继承，总是指向父类。\r\n\t- （2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。\r\n\r\n\t\t- class A {\r\n}\r\n\r\nclass B extends A {\r\n}\r\n\r\nB.__proto__ === A // true\r\nB.prototype.__proto__ === A.prototype // true\r\n\t\t- 上面代码中，子类B的__proto__属性指向父类A，子类B的prototype属性的__proto__属性指向父类A的prototype属性。\r\n这样的结果是因为，类的继承是按照下面的模式实现的。\r\n\t\t- class A {\r\n}\r\n\r\nclass B {\r\n}\r\n\r\n// B 的实例继承 A 的实例\r\nObject.setPrototypeOf(B.prototype, A.prototype);\r\n\r\n// B 继承 A 的静态属性\r\nObject.setPrototypeOf(B, A);\r\n\r\nconst b = new B();\r\n\t\t- 《对象的扩展》一章给出过Object.setPrototypeOf方法的实现。\r\n\t\t- Object.setPrototypeOf = function (obj, proto) {\r\n  obj.__proto__ = proto;\r\n  return obj;\r\n}\r\n\t\t- 因此，就得到了上面的结果。\r\n\t\t- Object.setPrototypeOf(B.prototype, A.prototype);\r\n// 等同于\r\nB.prototype.__proto__ = A.prototype;\r\n\r\nObject.setPrototypeOf(B, A);\r\n// 等同于\r\nB.__proto__ = A;\r\n\t\t- 这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（__proto__属性）是父类（A）；作为一个构造函数，子类（B）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。\r\n\t\t- Object.create(A.prototype);\r\n// 等同于\r\nB.prototype.__proto__ = A.prototype;\r\n\t\t- extends关键字后面可以跟多种类型的值。\r\n\r\n\t\t\t- class B extends A {\r\n}\r\n\t\t\t- 上面代码的A，只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性（除了Function.prototype函数），因此A可以是任意函数。\r\n\r\n\t\t- 下面，讨论两种情况。第一种，子类继承Object类。\r\n\r\n\t\t\t- class A extends Object {\r\n}\r\n\r\nA.__proto__ === Object // true\r\nA.prototype.__proto__ === Object.prototype // true\r\n\t\t\t- 这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。\r\n\r\n\t\t- 第二种情况，不存在任何继承。\r\n\r\n\t\t\t- class A {\r\n}\r\n\r\nA.__proto__ === Function.prototype // true\r\nA.prototype.__proto__ === Object.prototype // true\r\n\t\t\t- 这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Function.prototype。但是，A调用后返回一个空对象（即Object实例），所以A.prototype.__proto__指向构造函数（Object）的prototype属性。\r\n\r\n\t\t- 实例的 __proto__ 属性 \r\n\r\n\t\t\t- 子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。\r\n\r\n\t\t\t\t- var p1 = new Point(2, 3);\r\nvar p2 = new ColorPoint(2, 3, 'red');\r\n\r\np2.__proto__ === p1.__proto__ // false\r\np2.__proto__.__proto__ === p1.__proto__ // true\r\n\t\t\t\t- 上面代码中，ColorPoint继承了Point，导致前者原型的原型是后者的原型。\r\n\r\n因此，通过子类实例的__proto__.__proto__属性，可以修改父类实例的行为。\r\n\t\t\t\t- p2.__proto__.__proto__.printName = function () {\r\n  console.log('Ha');\r\n};\r\n\r\np1.printName() // \"Ha\"\r\n\t\t\t\t- 上面代码在ColorPoint的实例p2上向Point类添加方法，结果影响到了Point的实例p1。\r\n\r\n### 原生构造函数的继承\r\n\r\n- 原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。\r\n\r\n\t- Boolean()\r\nNumber()\r\nString()\r\nArray()\r\nDate()\r\nFunction()\r\nRegExp()\r\nError()\r\nObject()\r\n\t- 以前，这些原生构造函数是无法继承的，比如，不能自己定义一个Array的子类。\r\n\t- function MyArray() {\r\n  Array.apply(this, arguments);\r\n}\r\n\r\nMyArray.prototype = Object.create(Array.prototype, {\r\n  constructor: {\r\n    value: MyArray,\r\n    writable: true,\r\n    configurable: true,\r\n    enumerable: true\r\n  }\r\n});\r\n\t- 上面代码定义了一个继承 Array 的MyArray类。但是，这个类的行为与Array完全不一致。\r\n\t- var colors = new MyArray();\r\ncolors[0] = \"red\";\r\ncolors.length  // 0\r\n\r\ncolors.length = 0;\r\ncolors[0]  // \"red\"\r\n\t- 之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过Array.apply()或者分配给原型对象都不行。原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。\r\n\t- ES5 是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，Array构造函数有一个内部属性[[DefineOwnProperty]]，用来定义新属性时，更新length属性，这个内部属性无法在子类获取，导致子类的length属性行为不正常。\r\n\t- 下面的例子中，我们想让一个普通对象继承Error对象。\r\n\t- var e = {};\r\n\r\nObject.getOwnPropertyNames(Error.call(e))\r\n// [ 'stack' ]\r\n\r\nObject.getOwnPropertyNames(e)\r\n// []\r\n\t- 上面代码中，我们想通过Error.call(e)这种写法，让普通对象e具有Error对象的实例属性。但是，Error.call()完全忽略传入的第一个参数，而是返回一个新对象，e本身没有任何变化。这证明了Error.call(e)这种写法，无法继承原生构造函数。\r\n\r\n- ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。\r\n\r\n\t- class MyArray extends Array {\r\n  constructor(...args) {\r\n    super(...args);\r\n  }\r\n}\r\n\r\nvar arr = new MyArray();\r\narr[0] = 12;\r\narr.length // 1\r\n\r\narr.length = 0;\r\narr[0] // undefined\r\n\t- 上面代码定义了一个MyArray类，继承了Array构造函数，因此就可以从MyArray生成数组的实例。这意味着，ES6 可以自定义原生数据结构（比如Array、String等）的子类，这是 ES5 无法做到的。\r\n\r\n上面这个例子也说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。\r\n\t- class VersionedArray extends Array {\r\n  constructor() {\r\n    super();\r\n    this.history = [[]];\r\n  }\r\n  commit() {\r\n    this.history.push(this.slice());\r\n  }\r\n  revert() {\r\n    this.splice(0, this.length, ...this.history[this.history.length - 1]);\r\n  }\r\n}\r\n\r\nvar x = new VersionedArray();\r\n\r\nx.push(1);\r\nx.push(2);\r\nx // [1, 2]\r\nx.history // [[]]\r\n\r\nx.commit();\r\nx.history // [[], [1, 2]]\r\n\r\nx.push(3);\r\nx // [1, 2, 3]\r\nx.history // [[], [1, 2]]\r\n\r\nx.revert();\r\nx // [1, 2]\r\n\t- 上面代码中，VersionedArray会通过commit方法，将自己的当前状态生成一个版本快照，存入history属性。revert方法用来将数组重置为最新一次保存的版本。除此之外，VersionedArray依然是一个普通数组，所有原生的数组方法都可以在它上面调用。\r\n\t- 下面是一个自定义Error子类的例子，可以用来定制报错时的行为。\r\n\r\n\t\t- class ExtendableError extends Error {\r\n  constructor(message) {\r\n    super();\r\n    this.message = message;\r\n    this.stack = (new Error()).stack;\r\n    this.name = this.constructor.name;\r\n  }\r\n}\r\n\r\nclass MyError extends ExtendableError {\r\n  constructor(m) {\r\n    super(m);\r\n  }\r\n}\r\n\r\nvar myerror = new MyError('ll');\r\nmyerror.message // \"ll\"\r\nmyerror instanceof Error // true\r\nmyerror.name // \"MyError\"\r\nmyerror.stack\r\n// Error\r\n//     at MyError.ExtendableError\r\n//     ...\r\n\t\t- 注意，继承Object的子类，有一个行为差异。\r\n\t\t- class NewObj extends Object{\r\n  constructor(){\r\n    super(...arguments);\r\n  }\r\n}\r\nvar o = new NewObj({attr: true});\r\no.attr === true  // false\r\n\t\t- 上面代码中，NewObj继承了Object，但是无法通过super方法向父类Object传参。这是因为 ES6 改变了Object构造函数的行为，一旦发现Object方法不是通过new Object()这种形式调用，ES6 规定Object构造函数会忽略参数。\r\n\r\n### Mixin 模式的实现\r\n\r\n- Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。\r\n\r\n\t- const a = {\r\n  a: 'a'\r\n};\r\nconst b = {\r\n  b: 'b'\r\n};\r\nconst c = {...a, ...b}; // {a: 'a', b: 'b'}\r\n\t- 上面代码中，c对象是a对象和b对象的合成，具有两者的接口。\r\n\t- 下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。\r\n\r\n\t\t- function mix(...mixins) {\r\n  class Mix {}\r\n\r\n  for (let mixin of mixins) {\r\n    copyProperties(Mix.prototype, mixin); // 拷贝实例属性\r\n    copyProperties(Mix.prototype, Reflect.getPrototypeOf(mixin)); // 拷贝原型属性\r\n  }\r\n\r\n  return Mix;\r\n}\r\n\r\nfunction copyProperties(target, source) {\r\n  for (let key of Reflect.ownKeys(source)) {\r\n    if ( key !== \"constructor\"\r\n      && key !== \"prototype\"\r\n      && key !== \"name\"\r\n    ) {\r\n      let desc = Object.getOwnPropertyDescriptor(source, key);\r\n      Object.defineProperty(target, key, desc);\r\n    }\r\n  }\r\n}\r\n\t\t- 上面代码的mix函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。\r\n\t\t- class DistributedEdit extends mix(Loggable, Serializable) {\r\n  // ...\r\n}\r\n\r\n## 修饰器\r\n\r\n### 类的修饰\r\n\r\n- 许多面向对象的语言都有修饰器（Decorator）函数，用来修改类的行为。目前，有一个提案将这项功能，引入了 ECMAScript。\r\n\r\n\t- @testable\r\nclass MyTestableClass {\r\n  // ...\r\n}\r\n\r\nfunction testable(target) {\r\n  target.isTestable = true;\r\n}\r\n\r\nMyTestableClass.isTestable // true\r\n\t- 上面代码中，@testable就是一个修饰器。它修改了MyTestableClass这个类的行为，为它加上了静态属性isTestable。testable函数的参数target是MyTestableClass类本身。\r\n\r\n- 基本上，修饰器的行为就是下面这样。\r\n\r\n\t- @decorator\r\nclass A {}\r\n\r\n// 等同于\r\n\r\nclass A {}\r\nA = decorator(A) || A;\r\n\t- 也就是说，修饰器是一个对类进行处理的函数。修饰器函数的第一个参数，就是所要修饰的目标类。\r\n\t- function testable(target) {\r\n  // ...\r\n}\r\n\t- 上面代码中，testable函数的参数target，就是会被修饰的类。\r\n\t- 如果觉得一个参数不够用，可以在修饰器外面再封装一层函数。\r\n\t- function testable(isTestable) {\r\n  return function(target) {\r\n    target.isTestable = isTestable;\r\n  }\r\n}\r\n\r\n@testable(true)\r\nclass MyTestableClass {}\r\nMyTestableClass.isTestable // true\r\n\r\n@testable(false)\r\nclass MyClass {}\r\nMyClass.isTestable // false\r\n\r\n\t\t- 上面代码中，修饰器testable可以接受参数，这就等于可以修改修饰器的行为。\r\n\r\n- 注意，修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。也就是说，修饰器本质就是编译时执行的函数。\r\n- 前面的例子是为类添加一个静态属性，如果想添加实例属性，可以通过目标类的prototype对象操作。\r\n\r\n\t- function testable(target) {\r\n  target.prototype.isTestable = true;\r\n}\r\n\r\n@testable\r\nclass MyTestableClass {}\r\n\r\nlet obj = new MyTestableClass();\r\nobj.isTestable // true\r\n\t- // mixins.js\r\nexport function mixins(...list) {\r\n  return function (target) {\r\n    Object.assign(target.prototype, ...list)\r\n  }\r\n}\r\n\r\n// main.js\r\nimport { mixins } from './mixins'\r\n\r\nconst Foo = {\r\n  foo() { console.log('foo') }\r\n};\r\n\r\n@mixins(Foo)\r\nclass MyClass {}\r\n\r\nlet obj = new MyClass();\r\nobj.foo() // 'foo'\r\n\t- 上面代码中，修饰器函数testable是在目标类的prototype对象上添加属性，因此就可以在实例上调用。\r\n\r\n- 下面是另外一个例子。\r\n\r\n\t- 上面代码通过修饰器mixins，把Foo对象的方法添加到了MyClass的实例上面。可以用Object.assign()模拟这个功能。\r\n\t- const Foo = {\r\n  foo() { console.log('foo') }\r\n};\r\n\r\nclass MyClass {}\r\n\r\nObject.assign(MyClass.prototype, Foo);\r\n\r\nlet obj = new MyClass();\r\nobj.foo() // 'foo'\r\n\t- 实际开发中，React 与 Redux 库结合使用时，常常需要写成下面这样。\r\n\t- class MyReactComponent extends React.Component {}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);\r\n\t- 有了装饰器，就可以改写上面的代码。\r\n\t- @connect(mapStateToProps, mapDispatchToProps)\r\nexport default class MyReactComponent extends React.Component {}\r\n\r\n### 方法的修饰\r\n\r\n- 修饰器不仅可以修饰类，还可以修饰类的属性。\r\n\r\n\t- class Person {\r\n  @readonly\r\n  name() { return `${this.first} ${this.last}` }\r\n}\r\n\t- 上面代码中，修饰器readonly用来修饰“类”的name方法。\r\n\r\n修饰器函数readonly一共可以接受三个参数。\r\n\t- function readonly(target, name, descriptor){\r\n  // descriptor对象原来的值如下\r\n  // {\r\n  //   value: specifiedFunction,\r\n  //   enumerable: false,\r\n  //   configurable: true,\r\n  //   writable: true\r\n  // };\r\n  descriptor.writable = false;\r\n  return descriptor;\r\n}\r\n\r\nreadonly(Person.prototype, 'name', descriptor);\r\n// 类似于\r\nObject.defineProperty(Person.prototype, 'name', descriptor);\r\n\t- 修饰器第一个参数是类的原型对象，上例是Person.prototype，修饰器的本意是要“修饰”类的实例，但是这个时候实例还没生成，所以只能去修饰原型（这不同于类的修饰，那种情况时target参数指的是类本身）；第二个参数是所要修饰的属性名，第三个参数是该属性的描述对象。\r\n\t- 另外，上面代码说明，修饰器（readonly）会修改属性的描述对象（descriptor），然后被修改的描述对象再用来定义属性。\r\n\t- 下面是另一个例子，修改属性描述对象的enumerable属性，使得该属性不可遍历。\r\n\t- class Person {\r\n  @nonenumerable\r\n  get kidCount() { return this.children.length; }\r\n}\r\n\r\nfunction nonenumerable(target, name, descriptor) {\r\n  descriptor.enumerable = false;\r\n  return descriptor;\r\n}\r\n\t- 下面的@log修饰器，可以起到输出日志的作用。\r\n\t- class Math {\r\n  @log\r\n  add(a, b) {\r\n    return a + b;\r\n  }\r\n}\r\n\r\nfunction log(target, name, descriptor) {\r\n  var oldValue = descriptor.value;\r\n\r\n  descriptor.value = function() {\r\n    console.log(`Calling ${name} with`, arguments);\r\n    return oldValue.apply(this, arguments);\r\n  };\r\n\r\n  return descriptor;\r\n}\r\n\r\nconst math = new Math();\r\n\r\n// passed parameters should get logged now\r\nmath.add(2, 4);\r\n\r\n- 修饰器有注释的作用。\r\n\r\n\t- @testable\r\nclass Person {\r\n  @readonly\r\n  @nonenumerable\r\n  name() { return `${this.first} ${this.last}` }\r\n}\r\n\t- 从上面代码中，我们一眼就能看出，Person类是可测试的，而name方法是只读和不可枚举的。\r\n\t- 下面是使用 Decorator 写法的组件，看上去一目了然。\r\n\t- @Component({\r\n  tag: 'my-component',\r\n  styleUrl: 'my-component.scss'\r\n})\r\nexport class MyComponent {\r\n  @Prop() first: string;\r\n  @Prop() last: string;\r\n  @State() isVisible: boolean = true;\r\n\r\n  render() {\r\n    return (\r\n      <p>Hello, my name is {this.first} {this.last}</p>\r\n    );\r\n  }\r\n}\r\n\t- 如果同一个方法有多个修饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。\r\n\t- function dec(id){\r\n  console.log('evaluated', id);\r\n  return (target, property, descriptor) => console.log('executed', id);\r\n}\r\n\r\nclass Example {\r\n    @dec(1)\r\n    @dec(2)\r\n    method(){}\r\n}\r\n// evaluated 1\r\n// evaluated 2\r\n// executed 2\r\n// executed 1\r\n\t- 上面代码中，外层修饰器@dec(1)先进入，但是内层修饰器@dec(2)先执行。\r\n\t- 除了注释，修饰器还能用来类型检查。所以，对于类来说，这项功能相当有用。从长期来看，它将是 JavaScript 代码静态分析的重要工具。\r\n\r\n### 为什么修饰器不能用于函数\r\n\r\n- 修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。\r\n- var counter = 0;\r\n\r\nvar add = function () {\r\n  counter++;\r\n};\r\n\r\n@add\r\nfunction foo() {\r\n}\r\n- 上面的代码，意图是执行后counter等于 1，但是实际上结果是counter等于 0。因为函数提升，使得实际执行的代码是下面这样。\r\n- @add\r\nfunction foo() {\r\n}\r\n\r\nvar counter;\r\nvar add;\r\n\r\ncounter = 0;\r\n\r\nadd = function () {\r\n  counter++;\r\n};\r\n- 下面是另一个例子。\r\n- var readOnly = require(\"some-decorator\");\r\n\r\n@readOnly\r\nfunction foo() {\r\n}\r\n- 上面代码也有问题，因为实际执行是下面这样。\r\n- var readOnly;\r\n\r\n@readOnly\r\nfunction foo() {\r\n}\r\n\r\nreadOnly = require(\"some-decorator\");\r\n- 总之，由于存在函数提升，使得修饰器不能用于函数。类是不会提升的，所以就没有这方面的问题。\r\n\r\n另一方面，如果一定要修饰函数，可以采用高阶函数的形式直接执行。\r\n- function doSomething(name) {\r\n  console.log('Hello, ' + name);\r\n}\r\n\r\nfunction loggingDecorator(wrapped) {\r\n  return function() {\r\n    console.log('Starting');\r\n    const result = wrapped.apply(this, arguments);\r\n    console.log('Finished');\r\n    return result;\r\n  }\r\n}\r\n\r\nconst wrapped = loggingDecorator(doSomething);\r\n\r\n### core-decorators.js\r\n\r\n- core-decorators.js是一个第三方模块，提供了几个常见的修饰器，通过它可以更好地理解修饰器。\r\n\r\n\t- （1）@autobind\r\n\r\n\t\t- autobind修饰器使得方法中的this对象，绑定原始对象。\r\n\r\n\t\t\t- import { autobind } from 'core-decorators';\r\n\r\nclass Person {\r\n  @autobind\r\n  getPerson() {\r\n    return this;\r\n  }\r\n}\r\n\r\nlet person = new Person();\r\nlet getPerson = person.getPerson;\r\n\r\ngetPerson() === person;\r\n// true\r\n\r\n\t- （2）@readonly\r\n\r\n\t\t- readonly修饰器使得属性或方法不可写。\r\n\r\n\t\t\t- import { readonly } from 'core-decorators';\r\n\r\nclass Meal {\r\n  @readonly\r\n  entree = 'steak';\r\n}\r\n\r\nvar dinner = new Meal();\r\ndinner.entree = 'salmon';\r\n// Cannot assign to read only property 'entree' of [object Object]\r\n\r\n\t- （3）@override\r\n\r\n\t\t- override修饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。\r\n\r\n\t\t\t- import { override } from 'core-decorators';\r\n\r\nclass Parent {\r\n  speak(first, second) {}\r\n}\r\n\r\nclass Child extends Parent {\r\n  @override\r\n  speak() {}\r\n  // SyntaxError: Child#speak() does not properly override Parent#speak(first, second)\r\n}\r\n\r\n// or\r\n\r\nclass Child extends Parent {\r\n  @override\r\n  speaks() {}\r\n  // SyntaxError: No descriptor matching Child#speaks() was found on the prototype chain.\r\n  //\r\n  //   Did you mean \"speak\"?\r\n}\r\n\r\n\t- （4）@deprecate (别名@deprecated)\r\n\r\n\t\t- deprecate或deprecated修饰器在控制台显示一条警告，表示该方法将废除。\r\n\r\n\t\t\t- import { deprecate } from 'core-decorators';\r\n\r\nclass Person {\r\n  @deprecate\r\n  facepalm() {}\r\n\r\n  @deprecate('We stopped facepalming')\r\n  facepalmHard() {}\r\n\r\n  @deprecate('We stopped facepalming', { url: 'http://knowyourmeme.com/memes/facepalm' })\r\n  facepalmHarder() {}\r\n}\r\n\r\nlet person = new Person();\r\n\r\nperson.facepalm();\r\n// DEPRECATION Person#facepalm: This function will be removed in future versions.\r\n\r\nperson.facepalmHard();\r\n// DEPRECATION Person#facepalmHard: We stopped facepalming\r\n\r\nperson.facepalmHarder();\r\n// DEPRECATION Person#facepalmHarder: We stopped facepalming\r\n//\r\n//     See http://knowyourmeme.com/memes/facepalm for more details.\r\n//\r\n\r\n\t- （5）@suppressWarnings\r\n\r\n\t\t- suppressWarnings修饰器抑制deprecated修饰器导致的console.warn()调用。但是，异步代码发出的调用除外。\r\n\r\n\t\t\t- import { suppressWarnings } from 'core-decorators';\r\n\r\nclass Person {\r\n  @deprecated\r\n  facepalm() {}\r\n\r\n  @suppressWarnings\r\n  facepalmWithoutWarning() {\r\n    this.facepalm();\r\n  }\r\n}\r\n\r\nlet person = new Person();\r\n\r\nperson.facepalmWithoutWarning();\r\n// no warning is logged\r\n\r\n### 使用修饰器实现自动发布事件\r\n\r\n- 我们可以使用修饰器，使得对象的方法被调用时，自动发出一个事件。\r\n\r\n\t- const postal = require(\"postal/lib/postal.lodash\");\r\n\r\nexport default function publish(topic, channel) {\r\n  const channelName = channel || '/';\r\n  const msgChannel = postal.channel(channelName);\r\n  msgChannel.subscribe(topic, v => {\r\n    console.log('频道: ', channelName);\r\n    console.log('事件: ', topic);\r\n    console.log('数据: ', v);\r\n  });\r\n\r\n  return function(target, name, descriptor) {\r\n    const fn = descriptor.value;\r\n\r\n    descriptor.value = function() {\r\n      let value = fn.apply(this, arguments);\r\n      msgChannel.publish(topic, value);\r\n    };\r\n  };\r\n}\r\n\t- 上面代码定义了一个名为publish的修饰器，它通过改写descriptor.value，使得原方法被调用时，会自动发出一个事件。它使用的事件“发布/订阅”库是Postal.js。\r\n\t- 它的用法如下。\r\n\t- // index.js\r\nimport publish from './publish';\r\n\r\nclass FooComponent {\r\n  @publish('foo.some.message', 'component')\r\n  someMethod() {\r\n    return { my: 'data' };\r\n  }\r\n  @publish('foo.some.other')\r\n  anotherMethod() {\r\n    // ...\r\n  }\r\n}\r\n\r\nlet foo = new FooComponent();\r\n\r\nfoo.someMethod();\r\nfoo.anotherMethod();\r\n\t- 以后，只要调用someMethod或者anotherMethod，就会自动发出一个事件。\r\n\t- $ bash-node index.js\r\n频道:  component\r\n事件:  foo.some.message\r\n数据:  { my: 'data' }\r\n\r\n频道:  /\r\n事件:  foo.some.other\r\n数据:  undefined\r\n\r\n### Mixin \r\n\r\n- 在修饰器的基础上，可以实现Mixin模式。所谓Mixin模式，就是对象继承的一种替代方案，中文译为“混入”（mix in），意为在一个对象之中混入另外一个对象的方法。\r\n\r\n\t- 请看下面的例子。\r\n\r\n\t\t- const Foo = {\r\n  foo() { console.log('foo') }\r\n};\r\n\r\nclass MyClass {}\r\n\r\nObject.assign(MyClass.prototype, Foo);\r\n\r\nlet obj = new MyClass();\r\nobj.foo() // 'foo'\r\n\t\t- 上面代码之中，对象Foo有一个foo方法，通过Object.assign方法，可以将foo方法“混入”MyClass类，导致MyClass的实例obj对象都具有foo方法。这就是“混入”模式的一个简单实现。\r\n\r\n\t- 下面，我们部署一个通用脚本mixins.js，将 Mixin 写成一个修饰器。\r\n\r\n\t\t- export function mixins(...list) {\r\n  return function (target) {\r\n    Object.assign(target.prototype, ...list);\r\n  };\r\n}\r\n\t\t- 然后，就可以使用上面这个修饰器，为类“混入”各种方法。\r\n\t\t- import { mixins } from './mixins';\r\n\r\nconst Foo = {\r\n  foo() { console.log('foo') }\r\n};\r\n\r\n@mixins(Foo)\r\nclass MyClass {}\r\n\r\nlet obj = new MyClass();\r\nobj.foo() // \"foo\"\r\n\t\t- 通过mixins这个修饰器，实现了在MyClass类上面“混入”Foo对象的foo方法。\r\n\t\t- 不过，上面的方法会改写MyClass类的prototype对象，如果不喜欢这一点，也可以通过类的继承实现 Mixin。\r\n\t\t- class MyClass extends MyBaseClass {\r\n  /* ... */\r\n}\r\n\t\t- 上面代码中，MyClass继承了MyBaseClass。如果我们想在MyClass里面“混入”一个foo方法，一个办法是在MyClass和MyBaseClass之间插入一个混入类，这个类具有foo方法，并且继承了MyBaseClass的所有方法，然后MyClass再继承这个类。\r\n\t\t- let MyMixin = (superclass) => class extends superclass {\r\n  foo() {\r\n    console.log('foo from MyMixin');\r\n  }\r\n};\r\n\t\t- 上面代码中，MyMixin是一个混入类生成器，接受superclass作为参数，然后返回一个继承superclass的子类，该子类包含一个foo方法。\r\n\t\t- 接着，目标类再去继承这个混入类，就达到了“混入”foo方法的目的。\r\n\t\t- class MyClass extends MyMixin(MyBaseClass) {\r\n  /* ... */\r\n}\r\n\r\nlet c = new MyClass();\r\nc.foo(); // \"foo from MyMixin\"\r\n\t\t- 如果需要“混入”多个方法，就生成多个混入类。\r\n\t\t- class MyClass extends Mixin1(Mixin2(MyBaseClass)) {\r\n  /* ... */\r\n}\r\n\t\t- 这种写法的一个好处，是可以调用super，因此可以避免在“混入”过程中覆盖父类的同名方法\r\n\r\n\t\t\t- let Mixin1 = (superclass) => class extends superclass {\r\n  foo() {\r\n    console.log('foo from Mixin1');\r\n    if (super.foo) super.foo();\r\n  }\r\n};\r\n\r\nlet Mixin2 = (superclass) => class extends superclass {\r\n  foo() {\r\n    console.log('foo from Mixin2');\r\n    if (super.foo) super.foo();\r\n  }\r\n};\r\n\r\nclass S {\r\n  foo() {\r\n    console.log('foo from S');\r\n  }\r\n}\r\n\r\nclass C extends Mixin1(Mixin2(S)) {\r\n  foo() {\r\n    console.log('foo from C');\r\n    super.foo();\r\n  }\r\n}\r\n\t\t\t- 上面代码中，每一次混入发生时，都调用了父类的super.foo方法，导致父类的同名方法没有被覆盖，行为被保留了下来。\r\n\t\t\t- new C().foo()\r\n// foo from C\r\n// foo from Mixin1\r\n// foo from Mixin2\r\n// foo from S\r\n\r\n### Trait\r\n\r\n- Trait 也是一种修饰器，效果与 Mixin 类似，但是提供更多功能，比如防止同名方法的冲突、排除混入某些方法、为混入的方法起别名等等。\r\n\r\n下面采用traits-decorator这个第三方模块作为例子。这个模块提供的traits修饰器，不仅可以接受对象，还可以接受 ES6 类作为参数。\r\n\r\n\t- import { traits } from 'traits-decorator';\r\n\r\nclass TFoo {\r\n  foo() { console.log('foo') }\r\n}\r\n\r\nconst TBar = {\r\n  bar() { console.log('bar') }\r\n};\r\n\r\n@traits(TFoo, TBar)\r\nclass MyClass { }\r\n\r\nlet obj = new MyClass();\r\nobj.foo() // foo\r\nobj.bar() // bar\r\n\t- 上面代码中，通过traits修饰器，在MyClass类上面“混入”了TFoo类的foo方法和TBar对象的bar方法。\r\n\r\n- Trait 不允许“混入”同名方法。\r\n\r\n\t- import { traits } from 'traits-decorator';\r\n\r\nclass TFoo {\r\n  foo() { console.log('foo') }\r\n}\r\n\r\nconst TBar = {\r\n  bar() { console.log('bar') },\r\n  foo() { console.log('foo') }\r\n};\r\n\r\n@traits(TFoo, TBar)\r\nclass MyClass { }\r\n// 报错\r\n// throw new Error('Method named: ' + methodName + ' is defined twice.');\r\n//        ^\r\n// Error: Method named: foo is defined twice.\r\n\t- 上面代码中，TFoo和TBar都有foo方法，结果traits修饰器报错。\r\n\t- 一种解决方法是排除TBar的foo方法。\r\n\t- import { traits, excludes } from 'traits-decorator';\r\n\r\nclass TFoo {\r\n  foo() { console.log('foo') }\r\n}\r\n\r\nconst TBar = {\r\n  bar() { console.log('bar') },\r\n  foo() { console.log('foo') }\r\n};\r\n\r\n@traits(TFoo, TBar::excludes('foo'))\r\nclass MyClass { }\r\n\r\nlet obj = new MyClass();\r\nobj.foo() // foo\r\nobj.bar() // bar\r\n\t- 上面代码使用绑定运算符（::）在TBar上排除foo方法，混入时就不会报错了。\r\n\t- 另一种方法是为TBar的foo方法起一个别名。\r\n\t- import { traits, alias } from 'traits-decorator';\r\n\r\nclass TFoo {\r\n  foo() { console.log('foo') }\r\n}\r\n\r\nconst TBar = {\r\n  bar() { console.log('bar') },\r\n  foo() { console.log('foo') }\r\n};\r\n\r\n@traits(TFoo, TBar::alias({foo: 'aliasFoo'}))\r\nclass MyClass { }\r\n\r\nlet obj = new MyClass();\r\nobj.foo() // foo\r\nobj.aliasFoo() // foo\r\nobj.bar() // bar\r\n\t- alias和excludes方法，可以结合起来使用。\r\n\t- @traits(TExample::excludes('foo','bar')::alias({baz:'exampleBaz'}))\r\nclass MyClass {}\r\n\r\n### Babel 转码器的支持\r\n\r\n- 目前，Babel 转码器已经支持 Decorator。\r\n\r\n\t- 首先，安装babel-core和babel-plugin-transform-decorators。由于后者包括在babel-preset-stage-0之中，所以改为安装babel-preset-stage-0亦可。\r\n\t- $ npm install babel-core babel-plugin-transform-decorators\r\n\t- 然后，设置配置文件.babelrc。\r\n\t- {\r\n  \"plugins\": [\"transform-decorators\"]\r\n}\r\n\t- 这时，Babel 就可以对 Decorator 转码了。\r\n\r\n## Module 的语法\r\n\r\n### 概述\r\n\r\n- 历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。\r\n\r\n在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。\r\n\r\nES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。\r\n- // CommonJS模块\r\nlet { stat, exists, readFile } = require('fs');\r\n\r\n// 等同于\r\nlet _fs = require('fs');\r\nlet stat = _fs.stat;\r\nlet exists = _fs.exists;\r\nlet readfile = _fs.readfile;\r\n- 上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。\r\n- ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。\r\n- // ES6模块\r\nimport { stat, exists, readFile } from 'fs';\r\n- 上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。\r\n- 由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。\r\n- 除了静态加载带来的各种好处，ES6 模块还有以下好处。\r\n\r\n\t- 不再需要UMD模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。\r\n\t- 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性。\r\n\t- 不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。\r\n\r\n### 严格模式\r\n\r\n- ES6 的模块自动采用严格模式，不管你有没有在模块头部加上\"use strict\";。\r\n- 严格模式主要有以下限制。\r\n\r\n\t- 变量必须声明后再使用\r\n\t- 函数的参数不能有同名属性，否则报错\r\n\t- 不能使用with语句\r\n\t- 不能对只读属性赋值，否则报错\r\n\t- 不能使用前缀 0 表示八进制数，否则报错\r\n\t- 不能删除不可删除的属性，否则报错\r\n\t- 不能删除变量delete prop，会报错，只能删除属性delete global[prop]\r\n\t- eval不会在它的外层作用域引入变量\r\n\t- eval和arguments不能被重新赋值\r\n\t- arguments不会自动反映函数参数的变化\r\n\t- 不能使用arguments.callee\r\n\t- 不能使用arguments.caller\r\n\t- 禁止this指向全局对象\r\n\t- 不能使用fn.caller和fn.arguments获取函数调用的堆栈\r\n\t- 增加了保留字（比如protected、static和interface）\r\n\r\n### export 命令\r\n\r\n- 模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。\r\n- 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个 JS 文件，里面使用export命令输出变量。\r\n- // profile.js\r\nexport var firstName = 'Michael';\r\nexport var lastName = 'Jackson';\r\nexport var year = 1958;\r\n- 上面代码是profile.js文件，保存了用户信息。ES6 将其视为一个模块，里面用export命令对外部输出了三个变量。\r\n- export的写法，除了像上面这样，还有另外一种。\r\n- // profile.js\r\nvar firstName = 'Michael';\r\nvar lastName = 'Jackson';\r\nvar year = 1958;\r\n\r\nexport {firstName, lastName, year};\r\n- 上面代码在export命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在var语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。\r\n- export命令除了输出变量，还可以输出函数或类（class）。\r\n\r\n\t- export function multiply(x, y) {\r\n  return x * y;\r\n};\r\n\t- 上面代码对外输出一个函数multiply。\r\n\r\n- 通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。\r\n\r\n\t- function v1() { ... }\r\nfunction v2() { ... }\r\n\r\nexport {\r\n  v1 as streamV1,\r\n  v2 as streamV2,\r\n  v2 as streamLatestVersion\r\n};\r\n\t- 上面代码使用as关键字，重命名了函数v1和v2的对外接口。重命名后，v2可以用不同的名字输出两次。\r\n\r\n- 需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。\r\n\r\n\t- // 报错\r\nexport 1;\r\n\r\n// 报错\r\nvar m = 1;\r\nexport m;\r\n\t- 上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量m，还是直接输出 1。1只是一个值，不是接口。正确的写法是下面这样。\r\n\t- // 写法一\r\nexport var m = 1;\r\n\r\n// 写法二\r\nvar m = 1;\r\nexport {m};\r\n\r\n// 写法三\r\nvar n = 1;\r\nexport {n as m};\r\n\t- 上面三种写法都是正确的，规定了对外的接口m。其他脚本可以通过这个接口，取到值1。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。\r\n\t- 同样的，function和class的输出，也必须遵守这样的写法。\r\n\t- // 报错\r\nfunction f() {}\r\nexport f;\r\n\r\n// 正确\r\nexport function f() {};\r\n\r\n// 正确\r\nfunction f() {}\r\nexport {f};\r\n\t- 另外，export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。\r\n\t- export var foo = 'bar';\r\nsetTimeout(() => foo = 'baz', 500);\r\n\t- 这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新\r\n\t- 最后，export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的import命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。\r\n\t- function foo() {\r\n  export default 'bar' // SyntaxError\r\n}\r\nfoo()\r\n\t- 上面代码中，export语句放在函数之中，结果报错。\r\n\r\n### import 命令\r\n\r\n- 使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。\r\n\r\n\t- // main.js\r\nimport {firstName, lastName, year} from './profile.js';\r\n\r\nfunction setName(element) {\r\n  element.textContent = firstName + ' ' + lastName;\r\n}\r\n\t- 上面代码的import命令，用于加载profile.js文件，并从中输入变量。import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。\r\n\t- 如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。\r\n\t- import { lastName as surname } from './profile.js';\r\n\t- import命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。\r\n\t- import {a} from './xxx.js'\r\n\r\na = {}; // Syntax Error : 'a' is read-only;\r\n\t- 上面代码中，脚本加载了变量a，对其重新赋值就会报错，因为a是一个只读的接口。但是，如果a是一个对象，改写a的属性是允许的。\r\n\t- import {a} from './xxx.js'\r\n\r\na.foo = 'hello'; // 合法操作\r\n\t- 上面代码中，a的属性可以成功改写，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，轻易不要改变它的属性。\r\n\t- import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。\r\n\t- import {myMethod} from 'util';\r\n\t- 上面代码中，util是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。\r\n\t- 注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。\r\n\t- foo();\r\n\r\nimport { foo } from 'my_module';\r\n\t- 上面的代码不会报错，因为import的执行早于foo的调用。这种行为的本质是，import命令是编译阶段执行的，在代码运行之前。\r\n\t- 由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。\r\n\t- // 报错\r\nimport { 'f' + 'oo' } from 'my_module';\r\n\r\n// 报错\r\nlet module = 'my_module';\r\nimport { foo } from module;\r\n\r\n// 报错\r\nif (x === 1) {\r\n  import { foo } from 'module1';\r\n} else {\r\n  import { foo } from 'module2';\r\n}\r\n\t- 上面三种写法都会报错，因为它们用到了表达式、变量和if结构。在静态分析阶段，这些语法都是没法得到值的。\r\n\r\n- 最后，import语句会执行所加载的模块，因此可以有下面的写法。\r\n\r\n\t- import 'lodash';\r\n\t- 上面代码仅仅执行lodash模块，但是不输入任何值。\r\n\t- 如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。\r\n\t- import 'lodash';\r\nimport 'lodash';\r\n\t- 上面代码加载了两次lodash，但是只会执行一次。\r\n\t- import { foo } from 'my_module';\r\nimport { bar } from 'my_module';\r\n\r\n// 等同于\r\nimport { foo, bar } from 'my_module';\r\n\t- 上面代码中，虽然foo和bar在两个语句中加载，但是它们对应的是同一个my_module实例。也就是说，import语句是 Singleton 模式。\r\n\r\n目前阶段，通过 Babel 转码，CommonJS 模块的require命令和 ES6 模块的import命令，可以写在同一个模块里面，但是最好不要这样做。因为import在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。\r\n\r\n### 模块的整体加载\r\n\r\n- 除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。\r\n\r\n\t- 下面是一个circle.js文件，它输出两个方法area和circumference。\r\n\r\n\t\t- // circle.js\r\n\r\nexport function area(radius) {\r\n  return Math.PI * radius * radius;\r\n}\r\n\r\nexport function circumference(radius) {\r\n  return 2 * Math.PI * radius;\r\n}\r\n\t\t- 现在，加载这个模块。\r\n\t\t- // main.js\r\n\r\nimport { area, circumference } from './circle';\r\n\r\nconsole.log('圆面积：' + area(4));\r\nconsole.log('圆周长：' + circumference(14));\r\n\t\t- 上面写法是逐一指定要加载的方法，整体加载的写法如下。\r\n\t\t- import * as circle from './circle';\r\n\r\nconsole.log('圆面积：' + circle.area(4));\r\nconsole.log('圆周长：' + circle.circumference(14));\r\n\t\t- 注意，模块整体加载所在的那个对象（上例是circle），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。\r\n\t\t- import * as circle from './circle';\r\n\r\n// 下面两行都是不允许的\r\ncircle.foo = 'hello';\r\ncircle.area = function () {};\r\n\r\n### export default 命令\r\n\r\n- 从前面的例子可以看出，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。\r\n为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。\r\n- // export-default.js\r\nexport default function () {\r\n  console.log('foo');\r\n}\r\n- 上面代码是一个模块文件export-default.js，它的默认输出是一个函数。\r\n- 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。\r\n- // import-default.js\r\nimport customName from './export-default';\r\ncustomName(); // 'foo'\r\n- 上面代码的import命令，可以用任意名称指向export-default.js输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时import命令后面，不使用大括号。\r\n- export default命令用在非匿名函数前，也是可以的。\r\n\r\n\t- // export-default.js\r\nexport default function foo() {\r\n  console.log('foo');\r\n}\r\n\r\n// 或者写成\r\n\r\nfunction foo() {\r\n  console.log('foo');\r\n}\r\n\r\nexport default foo;\r\n\t- 上面代码中，foo函数的函数名foo，在模块外部是无效的。加载的时候，视同匿名函数加载。\r\n\r\n- 下面比较一下默认输出和正常输出。\r\n\r\n\t- // 第一组\r\nexport default function crc32() { // 输出\r\n  // ...\r\n}\r\n\r\nimport crc32 from 'crc32'; // 输入\r\n\r\n// 第二组\r\nexport function crc32() { // 输出\r\n  // ...\r\n};\r\n\r\nimport {crc32} from 'crc32'; // 输入\r\n\t- 上面代码的两组写法，第一组是使用export default时，对应的import语句不需要使用大括号；第二组是不使用export default时，对应的import语句需要使用大括号。\r\n\t- export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应export default命令。\r\n\t- 本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。\r\n\t- // modules.js\r\nfunction add(x, y) {\r\n  return x * y;\r\n}\r\nexport {add as default};\r\n// 等同于\r\n// export default add;\r\n\r\n// app.js\r\nimport { default as foo } from 'modules';\r\n// 等同于\r\n// import foo from 'modules';\r\n\r\n### export 与 import 的复合写法\r\n\r\n- 如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。\r\n\r\n\t- export { foo, bar } from 'my_module';\r\n\r\n// 可以简单理解为\r\nimport { foo, bar } from 'my_module';\r\nexport { foo, bar };\r\n\t- 上面代码中，export和import语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，foo和bar实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用foo和bar。\r\n\t- 模块的接口改名和整体输出，也可以采用这种写法。\r\n\r\n\t\t- // 接口改名\r\nexport { foo as myFoo } from 'my_module';\r\n\r\n// 整体输出\r\nexport * from 'my_module';\r\n\r\n\t- 默认接口的写法如下。\r\n\r\n\t\t- export { default } from 'foo';\r\n\r\n\t- 具名接口改为默认接口的写法如下。\r\n\r\n\t\t- export { es6 as default } from './someModule';\r\n\r\n// 等同于\r\nimport { es6 } from './someModule';\r\nexport default es6;\r\n\r\n\t- 同样地，默认接口也可以改名为具名接口。\r\n\r\n\t\t- export { default as es6 } from './someModule';\r\n\r\n\t- 下面三种import语句，没有对应的复合写法。\r\n\r\n\t\t- import * as someIdentifier from \"someModule\";\r\nimport someIdentifier from \"someModule\";\r\nimport someIdentifier, { namedIdentifier } from \"someModule\";\r\n\r\n\t\t- 为了做到形式的对称，现在有提案，提出补上这三种复合写法。\r\n\t\t- export * as someIdentifier from \"someModule\";\r\nexport someIdentifier from \"someModule\";\r\nexport someIdentifier, { namedIdentifier } from \"someModule\";\r\n\r\n### 模块的继承\r\n\r\n- 模块之间也可以继承。\r\n\r\n\t- 假设有一个circleplus模块，继承了circle模块。\r\n\r\n\t\t- // circleplus.js\r\n\r\nexport * from 'circle';\r\nexport var e = 2.71828182846;\r\nexport default function(x) {\r\n  return Math.exp(x);\r\n}\r\n\t\t- 上面代码中的export *，表示再输出circle模块的所有属性和方法。注意，export *命令会忽略circle模块的default方法。然后，上面代码又输出了自定义的e变量和默认方法。\r\n\r\n这时，也可以将circle的属性或方法，改名后再输出。\r\n\t\t- // circleplus.js\r\n\r\nexport { area as circleArea } from 'circle';\r\n\t\t- 上面代码表示，只输出circle模块的area方法，且将其改名为circleArea。\r\n\r\n加载上面模块的写法如下。\r\n\t\t- // main.js\r\n\r\nimport * as math from 'circleplus';\r\nimport exp from 'circleplus';\r\nconsole.log(exp(math.e));\r\n\r\n\t\t- 上面代码中的import exp表示，将circleplus模块的默认方法加载为exp方法。\r\n\r\n### 跨模块常量\r\n\r\n- 本书介绍const命令的时候说过，const声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。\r\n\r\n\t- // constants.js 模块\r\nexport const A = 1;\r\nexport const B = 3;\r\nexport const C = 4;\r\n\r\n// test1.js 模块\r\nimport * as constants from './constants';\r\nconsole.log(constants.A); // 1\r\nconsole.log(constants.B); // 3\r\n\r\n// test2.js 模块\r\nimport {A, B} from './constants';\r\nconsole.log(A); // 1\r\nconsole.log(B); // 3\r\n\r\n- 如果要使用的常量非常多，可以建一个专门的constants目录，将各种常量写在不同的文件里面，保存在该目录下。\r\n\r\n\t- // constants/db.js\r\nexport const db = {\r\n  url: 'http://my.couchdbserver.local:5984',\r\n  admin_username: 'admin',\r\n  admin_password: 'admin password'\r\n};\r\n\r\n// constants/user.js\r\nexport const users = ['root', 'admin', 'staff', 'ceo', 'chief', 'moderator'];\r\n\t- 然后，将这些文件输出的常量，合并在index.js里面。\r\n\t- // constants/index.js\r\nexport {db} from './db';\r\nexport {users} from './users';\r\n\t- 使用的时候，直接加载index.js就可以了。\r\n\t- // script.js\r\nimport {db, users} from './constants/index';\r\n\r\n### import()\r\n\r\n- 简介\r\n\r\n\t- 前面介绍过，import命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（import命令叫做“连接” binding 其实更合适）。所以，下面的代码会报错。\r\n\r\n// 报错\r\nif (x === 2) {\r\n  import MyModual from './myModual';\r\n}\r\n上面代码中，引擎处理import语句是在编译时，这时不会去分析或执行if语句，所以import语句放在if代码块之中毫无意义，因此会报句法错误，而不是执行时错误。也就是说，import和export命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中）。\r\n\r\n这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果import命令要取代 Node 的require方法，这就形成了一个障碍。因为require是运行时加载模块，import命令无法取代require的动态加载功能。\r\n\r\nconst path = './' + fileName;\r\nconst myModual = require(path);\r\n上面的语句就是动态加载，require到底加载哪一个模块，只有运行时才知道。import命令做不到这一点。\r\n\t- 因此，有一个提案，建议引入import()函数，完成动态加载。\r\n\r\n\t\t- import(specifier)\r\n\t\t- 上面代码中，import函数的参数specifier，指定所要加载的模块的位置。import命令能够接受什么参数，import()函数就能接受什么参数，两者区别主要是后者为动态加载。\r\n\r\nimport()返回一个 Promise 对象。下面是一个例子。\r\n\t\t- const main = document.querySelector('main');\r\n\r\nimport(`./section-modules/${someVariable}.js`)\r\n  .then(module => {\r\n    module.loadPageInto(main);\r\n  })\r\n  .catch(err => {\r\n    main.textContent = err.message;\r\n  });\r\n\t\t- import()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，import()函数与所加载的模块没有静态连接关系，这点也是与import语句不相同。import()类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载。\r\n\t\t- 适用场合\r\n\r\n\t\t\t- （1）按需加载。\r\n\r\n\t\t\t\t- import()可以在需要的时候，再加载某个模块。\r\n\r\n\t\t\t\t\t- button.addEventListener('click', event => {\r\n  import('./dialogBox.js')\r\n  .then(dialogBox => {\r\n    dialogBox.open();\r\n  })\r\n  .catch(error => {\r\n    /* Error handling */\r\n  })\r\n});\r\n\t\t\t\t\t- 上面代码中，import()方法放在click事件的监听函数之中，只有用户点击了按钮，才会加载这个模块\r\n\r\n\t\t\t- （2）条件加载\r\n\r\n\t\t\t\t- import()可以放在if代码块，根据不同的情况，加载不同的模块。\r\n\r\n\t\t\t\t\t- if (condition) {\r\n  import('moduleA').then(...);\r\n} else {\r\n  import('moduleB').then(...);\r\n}\r\n\t\t\t\t\t- 上面代码中，如果满足条件，就加载模块 A，否则加载模块 B。\r\n\r\n\t\t\t- 3）动态的模块路径\r\n\r\n\t\t\t\t- import()允许模块路径动态生成。\r\n\r\n\t\t\t\t\t- import(f())\r\n.then(...);\r\n\t\t\t\t\t- 上面代码中，根据函数f的返回结果，加载不同的模块。\r\n\r\n\t\t- 注意点\r\n\r\n\t\t\t- import()加载模块成功以后，这个模块会作为一个对象，当作then方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口。\r\n\r\n\t\t\t\t- import('./myModule.js')\r\n.then(({export1, export2}) => {\r\n  // ...·\r\n});\r\n\t\t\t\t- 上面代码中，export1和export2都是myModule.js的输出接口，可以解构获得。\r\n\r\n\t\t\t- 如果模块有default输出接口，可以用参数直接获得。\r\n\r\n\t\t\t\t- import('./myModule.js')\r\n.then(myModule => {\r\n  console.log(myModule.default);\r\n});\r\n\t\t\t\t- 上面的代码也可以使用具名输入的形式。\r\n\t\t\t\t- import('./myModule.js')\r\n.then(({default: theDefault}) => {\r\n  console.log(theDefault);\r\n});\r\n\t\t\t\t- 如果想同时加载多个模块，可以采用下面的写法。\r\n\t\t\t\t- Promise.all([\r\n  import('./module1.js'),\r\n  import('./module2.js'),\r\n  import('./module3.js'),\r\n])\r\n.then(([module1, module2, module3]) => {\r\n   ···\r\n});\r\n\t\t\t\t- import()也可以用在 async 函数之中。\r\n\t\t\t\t- async function main() {\r\n  const myModule = await import('./myModule.js');\r\n  const {export1, export2} = await import('./myModule.js');\r\n  const [module1, module2, module3] =\r\n    await Promise.all([\r\n      import('./module1.js'),\r\n      import('./module2.js'),\r\n      import('./module3.js'),\r\n    ]);\r\n}\r\nmain();\r\n\r\n- 自由主题\r\n\r\n- 自由主题\r\n\r\n- 自由主题\r\n\r\n## Module 的加载实现\r\n\r\n### 浏览器加载\r\n\r\n- 传统方法 \r\n\r\n\t- HTML 网页中，浏览器通过script标签加载 JavaScript 脚本。\r\n\r\n\t\t- \x3c!-- 页面内嵌的脚本 --\x3e\r\n&lt;script type=\"application/javascript\">\r\n  // module code\r\n&lt;/script&amp;gt; 标签加载\r\n\r\n\x3c!-- 外部脚本 --\x3e\r\n&lt;script type=\"application/javascript\" src=\"path/to/myModule.js\">\r\n&lt;/script&amp;gt;\r\n\t\t- 上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此type=\"application/javascript\"可以省略。\r\n\r\n\t\t\t- 默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到&lt;script&gt;标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。\r\n\r\n如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。\r\n\t\t\t- &lt;script src=\"path/to/myModule.js\" defer>&lt;/script&amp;gt;\r\n&lt;script src=\"path/to/myModule.js\" async>&lt;/script&amp;gt;\r\n\t\t\t- 上面代码中，&lt;script&gt;标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。\r\n\r\ndefer与async的区别是：defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。\r\n\r\n- 加载规则\r\n\r\n\t- 浏览器加载 ES6 模块，也使用&lt;script&gt;标签，但是要加入type=\"module\"属性。\r\n\r\n\t\t- &lt;script type=\"module\" src=\"./foo.js\">&lt;/script&amp;gt;\r\n\t\t- 上面代码在网页中插入一个模块foo.js，由于type属性设为module，所以浏览器知道这是一个 ES6 模块\r\n\t\t- 浏览器对于带有type=\"module\"的&lt;script&gt;，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了&lt;script&gt;标签的defer属性。\r\n\t\t- &lt;script type=\"module\" src=\"./foo.js\">&lt;/script&amp;gt;\r\n\x3c!-- 等同于 --\x3e\r\n&lt;script type=\"module\" src=\"./foo.js\" defer>&lt;/script&amp;gt;\r\n\t\t- 如果网页有多个&lt;script type=\"module\">，它们会按照在页面出现的顺序依次执行。\r\n\t\t- &lt;script&gt;标签的async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。\r\n\t\t- &lt;script type=\"module\" src=\"./foo.js\" async>&lt;/script&amp;gt;\r\n\t\t- 一旦使用了async属性，&lt;script type=\"module\">就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。\r\n\t\t- ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。\r\n\t\t- &lt;script type=\"module\">\r\n  import utils from \"./utils.js\";\r\n\r\n  // other code\r\n&lt;/script&amp;gt;\r\n\t\t- 对于外部的模块脚本（上例是foo.js），有几点需要注意。\r\n\r\n\t\t\t- 代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。\r\n\t\t\t- 模块脚本自动采用严格模式，不管有没有声明use strict。\r\n\t\t\t- 模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。\r\n\t\t\t- 模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。\r\n\t\t\t- 同一个模块如果加载多次，将只执行一次。\r\n\r\n\t\t- 下面是一个示例模块。\r\n\r\n\t\t\t- import utils from 'https://example.com/js/utils.js';\r\n\r\nconst x = 1;\r\n\r\nconsole.log(x === window.x); //false\r\nconsole.log(this === undefined); // true\r\n\t\t\t- 利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中。\r\n\t\t\t- const isNotModuleScript = this !== undefined;\r\n\r\n### ES6 模块与 CommonJS 模块的差异\r\n\r\n- ES6 模块与 CommonJS 模块有两个重大差异。\r\n\r\n\t- CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。\r\n\t- CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。\r\n\r\n- 第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。\r\n- 下面重点解释第一个差异。\r\n\r\n\t- CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件lib.js的例子。\r\n\r\n\t\t- // lib.js\r\nvar counter = 3;\r\nfunction incCounter() {\r\n  counter++;\r\n}\r\nmodule.exports = {\r\n  counter: counter,\r\n  incCounter: incCounter,\r\n};\r\n\t\t- 上面代码输出内部变量counter和改写这个变量的内部方法incCounter。然后，在main.js里面加载这个模块。\r\n\t\t- // main.js\r\nvar mod = require('./lib');\r\n\r\nconsole.log(mod.counter);  // 3\r\nmod.incCounter();\r\nconsole.log(mod.counter); // 3\r\n\t\t- 上面代码说明，lib.js模块加载以后，它的内部变化就影响不到输出的mod.counter了。这是因为mod.counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。\r\n\t\t- // lib.js\r\nvar counter = 3;\r\nfunction incCounter() {\r\n  counter++;\r\n}\r\nmodule.exports = {\r\n  get counter() {\r\n    return counter\r\n  },\r\n  incCounter: incCounter,\r\n};\r\n\t\t- 上面代码中，输出的counter属性实际上是一个取值器函数。现在再执行main.js，就可以正确读取内部变量counter的变动了。\r\n\t\t- $ node main.js\r\n3\r\n4\r\n\r\n\t- ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。\r\n\r\n\t\t- 还是举上面的例子。\r\n\r\n\t\t\t- // lib.js\r\nexport let counter = 3;\r\nexport function incCounter() {\r\n  counter++;\r\n}\r\n\r\n// main.js\r\nimport { counter, incCounter } from './lib';\r\nconsole.log(counter); // 3\r\nincCounter();\r\nconsole.log(counter); // 4\r\n\t\t\t- 上面代码说明，ES6 模块输入的变量counter是活的，完全反应其所在模块lib.js内部的变化。\r\n\r\n\t\t- 再举一个出现在export一节中的例子。\r\n\r\n\t\t\t- // m1.js\r\nexport var foo = 'bar';\r\nsetTimeout(() => foo = 'baz', 500);\r\n\r\n// m2.js\r\nimport {foo} from './m1.js';\r\nconsole.log(foo);\r\nsetTimeout(() => console.log(foo), 500);\r\n\t\t\t- 上面代码中，m1.js的变量foo，在刚加载时等于bar，过了 500 毫秒，又变为等于baz。\r\n\t\t\t- 让我们看看，m2.js能否正确读取这个变化。\r\n\t\t\t- $ babel-node m2.js\r\n\r\nbar\r\nbaz\r\n\t\t\t- 上面代码表明，ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。\r\n\r\n\t\t- 由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。\r\n\r\n\t\t\t- // lib.js\r\nexport let obj = {};\r\n\r\n// main.js\r\nimport { obj } from './lib';\r\n\r\nobj.prop = 123; // OK\r\nobj = {}; // TypeError\r\n\t\t\t- 上面代码中，main.js从lib.js输入变量obj，可以对obj添加属性，但是重新赋值就会报错。因为变量obj指向的地址是只读的，不能重新赋值，这就好比main.js创造了一个名为obj的const变量。\r\n\t\t\t- 最后，export通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。\r\n\t\t\t- // mod.js\r\nfunction C() {\r\n  this.sum = 0;\r\n  this.add = function () {\r\n    this.sum += 1;\r\n  };\r\n  this.show = function () {\r\n    console.log(this.sum);\r\n  };\r\n}\r\n\r\nexport let c = new C();\r\n\t\t\t- 上面的脚本mod.js，输出的是一个C的实例。不同的脚本加载这个模块，得到的都是同一个实例。\r\n\t\t\t- // x.js\r\nimport {c} from './mod';\r\nc.add();\r\n\r\n// y.js\r\nimport {c} from './mod';\r\nc.show();\r\n\r\n// main.js\r\nimport './x';\r\nimport './y';\r\n\t\t\t- 现在执行main.js，输出的是1。\r\n\t\t\t- $ babel-node main.js\r\n1\r\n\t\t\t- 这就证明了x.js和y.js加载的都是C的同一个实例。\r\n\r\n### Node 加载\r\n\r\n- 概述\r\n\r\n\t- Node 对 ES6 模块的处理比较麻烦，因为它有自己的 CommonJS 模块格式，与 ES6 模块格式是不兼容的。目前的解决方案是，将两者分开，ES6 模块和 CommonJS 采用各自的加载方案。\r\n\r\nNode 要求 ES6 模块采用.mjs后缀文件名。也就是说，只要脚本文件里面使用import或者export命令，那么就必须采用.mjs后缀名。require命令不能加载.mjs文件，会报错，只有import命令才可以加载.mjs文件。反过来，.mjs文件里面也不能使用require命令，必须使用import。\r\n\r\n目前，这项功能还在试验阶段。安装 Node v8.5.0 或以上版本，要用--experimental-modules参数才能打开该功能。\r\n\t- $ node --experimental-modules my-app.mjs\r\n\t- 为了与浏览器的import加载规则相同，Node 的.mjs文件支持 URL 路径。\r\n\t- import './foo?query=1'; // 加载 ./foo 传入参数 ?query=1\r\n\t- 上面代码中，脚本路径带有参数?query=1，Node 会按 URL 规则解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有:、%、#、?等特殊字符，最好对这些字符进行转义。\r\n\r\n目前，Node 的import命令只支持加载本地模块（file:协议），不支持加载远程模块。\r\n\t- 如果模块名不含路径，那么import命令会去node_modules目录寻找这个模块。\r\n\t- import 'baz';\r\nimport 'abc/123';\r\n\t- 如果模块名包含路径，那么import命令会按照路径去寻找这个名字的脚本文件。\r\n\t- import 'file:///etc/config/app.json';\r\nimport './foo';\r\nimport './foo?search';\r\nimport '../bar';\r\nimport '/baz';\r\n\t- 如果脚本文件省略了后缀名，比如import './foo'，Node 会依次尝试四个后缀名：./foo.mjs、./foo.js、./foo.json、./foo.node。如果这些脚本文件都不存在，Node 就会去加载./foo/package.json的main字段指定的脚本。如果./foo/package.json不存在或者没有main字段，那么就会依次加载./foo/index.mjs、./foo/index.js、./foo/index.json、./foo/index.node。如果以上四个文件还是都不存在，就会抛出错误。\r\n\r\n最后，Node 的import命令是异步加载，这一点与浏览器的处理方法相同。\r\n\r\n- 内部变量 \r\n\r\n\t- ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。\r\n\r\n\t\t- 首先，就是this关键字。ES6 模块之中，顶层的this指向undefined；CommonJS 模块的顶层this指向当前模块，这是两者的一个重大差异。\r\n\t\t- 其次，以下这些顶层变量在 ES6 模块之中都是不存在的。\r\n\r\n\t\t\t- arguments\r\n\t\t\t- require\r\n\t\t\t- module\r\n\t\t\t- exports\r\n\t\t\t- __filename\r\n\t\t\t- __dirname\r\n\r\n\t\t- 如果你一定要使用这些变量，有一个变通方法，就是写一个 CommonJS 模块输出这些变量，然后再用 ES6 模块加载这个 CommonJS 模块。但是这样一来，该 ES6 模块就不能直接用于浏览器环境了，所以不推荐这样做。\r\n\r\n\t\t\t- // expose.js\r\nmodule.exports = {__dirname};\r\n\r\n// use.mjs\r\nimport expose from './expose.js';\r\nconst {__dirname} = expose;\r\n\t\t\t- 上面代码中，expose.js是一个 CommonJS 模块，输出变量__dirname，该变量在 ES6 模块之中不存在。ES6 模块加载expose.js，就可以得到__dirname。\r\n\r\n- ES6 模块加载 CommonJS 模块\r\n\r\n\t- CommonJS 模块的输出都定义在module.exports这个属性上面。Node 的import命令加载 CommonJS 模块，Node 会自动将module.exports属性，当作模块的默认输出，即等同于export default xxx。\r\n\r\n\t\t- 下面是一个 CommonJS 模块。\r\n\r\n\t\t\t- // a.js\r\nmodule.exports = {\r\n  foo: 'hello',\r\n  bar: 'world'\r\n};\r\n\r\n// 等同于\r\nexport default {\r\n  foo: 'hello',\r\n  bar: 'world'\r\n};\r\n\t\t\t- import命令加载上面的模块，module.exports会被视为默认输出，即import命令实际上输入的是这样一个对象{ default: module.exports }。\r\n\t\t\t- 所以，一共有三种写法，可以拿到 CommonJS 模块的module.exports。\r\n\t\t\t- // 写法一\r\nimport baz from './a';\r\n// baz = {foo: 'hello', bar: 'world'};\r\n\r\n// 写法二\r\nimport {default as baz} from './a';\r\n// baz = {foo: 'hello', bar: 'world'};\r\n\r\n// 写法三\r\nimport * as baz from './a';\r\n// baz = {\r\n//   get default() {return module.exports;},\r\n//   get foo() {return this.default.foo}.bind(baz),\r\n//   get bar() {return this.default.bar}.bind(baz)\r\n// }\r\n\t\t\t- 上面代码的第三种写法，可以通过baz.default拿到module.exports。foo属性和bar属性就是可以通过这种方法拿到了module.exports。\r\n\r\n\t\t- 下面是一些例子\r\n\r\n\t\t\t- // b.js\r\nmodule.exports = null;\r\n\r\n// es.js\r\nimport foo from './b';\r\n// foo = null;\r\n\r\nimport * as bar from './b';\r\n// bar = { default:null };\r\n\r\n\t\t\t\t- 上面代码中，es.js采用第二种写法时，要通过bar.default这样的写法，才能拿到module.exports。\r\n\r\n\t\t\t- // c.js\r\nmodule.exports = function two() {\r\n  return 2;\r\n};\r\n\r\n// es.js\r\nimport foo from './c';\r\nfoo(); // 2\r\n\r\nimport * as bar from './c';\r\nbar.default(); // 2\r\nbar(); // throws, bar is not a function\r\n\r\n\t\t\t\t- 上面代码中，bar本身是一个对象，不能当作函数调用，只能通过bar.default调用。\r\n\r\n\t\t\t- CommonJS 模块的输出缓存机制，在 ES6 加载方式下依然有效。\r\n\r\n\t\t\t\t- // foo.js\r\nmodule.exports = 123;\r\nsetTimeout(_ => module.exports = null);\r\n\r\n\t\t\t\t\t- 上面代码中，对于加载foo.js的脚本，module.exports将一直是123，而不会变成null。\r\n\r\n\t\t\t- 由于 ES6 模块是编译时确定输出接口，CommonJS 模块是运行时确定输出接口，所以采用import命令加载 CommonJS 模块时，不允许采用下面的写法。\r\n\r\n\t\t\t\t- // 不正确\r\nimport { readFile } from 'fs';\r\n\r\n\t\t\t\t\t- 上面的写法不正确，因为fs是 CommonJS 格式，只有在运行时才能确定readFile接口，而import命令要求编译时就确定这个接口。解决方法就是改为整体输入。\r\n\t\t\t\t\t- // 正确的写法一\r\nimport * as express from 'express';\r\nconst app = express.default();\r\n\r\n// 正确的写法二\r\nimport express from 'express';\r\nconst app = express();\r\n\r\n- CommonJS 模块加载 ES6 模块\r\n\r\n\t- CommonJS 模块加载 ES6 模块，不能使用require命令，而要使用import()函数。ES6 模块的所有输出接口，会成为输入对象的属性。\r\n\r\n\t\t- // es.mjs\r\nlet foo = { bar: 'my-default' };\r\nexport default foo;\r\n\r\n// cjs.js\r\nconst es_namespace = await import('./es.mjs');\r\n// es_namespace = {\r\n//   get default() {\r\n//     ...\r\n//   }\r\n// }\r\nconsole.log(es_namespace.default);\r\n// { bar:'my-default' }\r\n\t\t- 上面代码中，default接口变成了es_namespace.default属性。\r\n\t\t- 下面是另一个例子。\r\n\t\t- // es.js\r\nexport let foo = { bar:'my-default' };\r\nexport { foo as bar };\r\nexport function f() {};\r\nexport class c {};\r\n\r\n// cjs.js\r\nconst es_namespace = await import('./es');\r\n// es_namespace = {\r\n//   get foo() {return foo;}\r\n//   get bar() {return foo;}\r\n//   get f() {return f;}\r\n//   get c() {return c;}\r\n// }\r\n\r\n### 循环加载\r\n\r\n- “循环加载”（circular dependency）指的是，a脚本的执行依赖b脚本，而b脚本的执行又依赖a脚本。\r\n\r\n\t- // a.js\r\nvar b = require('b');\r\n\r\n// b.js\r\nvar a = require('a');\r\n\t- 通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。\r\n\r\n但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现a依赖b，b依赖c，c又依赖a这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。\r\n\r\n对于 JavaScript 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。\r\n\r\n- CommonJS 模块的加载原理\r\n\r\n\t- CommonJS 的一个模块，就是一个脚本文件。require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。\r\n\r\n\t\t- {\r\n  id: '...',\r\n  exports: { ... },\r\n  loaded: true,\r\n  ...\r\n}\r\n\t\t- 上面代码就是 Node 内部加载模块后生成的一个对象。该对象的id属性是模块名，exports属性是模块输出的各个接口，loaded属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。\r\n\t\t- 以后需要用到这个模块的时候，就会到exports属性上面取值。即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。\r\n\r\n- CommonJS 模块的循环加载\r\n\r\n\t- CommonJS 模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被\"循环加载\"，就只输出已经执行的部分，还未执行的部分不会输出\r\n\r\n\t\t- 让我们来看，Node 官方文档里面的例子。脚本文件a.js代码如下。\r\n\r\n\t\t\t- exports.done = false;\r\nvar b = require('./b.js');\r\nconsole.log('在 a.js 之中，b.done = %j', b.done);\r\nexports.done = true;\r\nconsole.log('a.js 执行完毕');\r\n\t\t\t- 上面代码之中，a.js脚本先输出一个done变量，然后加载另一个脚本文件b.js。注意，此时a.js代码就停在这里，等待b.js执行完毕，再往下执行。\r\n\t\t\t- 再看b.js的代码。\r\n\t\t\t- exports.done = false;\r\nvar a = require('./a.js');\r\nconsole.log('在 b.js 之中，a.done = %j', a.done);\r\nexports.done = true;\r\nconsole.log('b.js 执行完毕');\r\n\t\t\t- 上面代码之中，b.js执行到第二行，就会去加载a.js，这时，就发生了“循环加载”。系统会去a.js模块对应对象的exports属性取值，可是因为a.js还没有执行完，从exports属性只能取回已经执行的部分，而不是最后的值。\r\n\t\t\t- a.js已经执行的部分，只有一行。\r\n\t\t\t- exports.done = false;\r\n\t\t\t- 因此，对于b.js来说，它从a.js只输入一个变量done，值为false。\r\n\r\n然后，b.js接着往下执行，等到全部执行完毕，再把执行权交还给a.js。于是，a.js接着往下执行，直到执行完毕。我们写一个脚本main.js，验证这个过程。\r\n\t\t\t- var a = require('./a.js');\r\nvar b = require('./b.js');\r\nconsole.log('在 main.js 之中, a.done=%j, b.done=%j', a.done, b.done);\r\n\t\t\t- 执行main.js，运行结果如下。\r\n\r\n\t\t\t\t- $ node main.js\r\n\r\n在 b.js 之中，a.done = false\r\nb.js 执行完毕\r\n在 a.js 之中，b.done = true\r\na.js 执行完毕\r\n在 main.js 之中, a.done=true, b.done=true\r\n\r\n\t\t\t- 上面的代码证明了两件事。一是，在b.js之中，a.js没有执行完毕，只执行了第一行。二是，main.js执行到第二行时，不会再次执行b.js，而是输出缓存的b.js的执行结果，即它的第四行。\r\n\t\t\t- exports.done = true;\r\n\t\t\t- 总之，CommonJS 输入的是被输出值的拷贝，不是引用。\r\n\r\n另外，由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。\r\n\r\n\t\t\t\t- var a = require('a'); // 安全的写法\r\nvar foo = require('a').foo; // 危险的写法\r\n\r\nexports.good = function (arg) {\r\n  return a.foo('good', arg); // 使用的是 a.foo 的最新值\r\n};\r\n\r\nexports.bad = function (arg) {\r\n  return foo('bad', arg); // 使用的是一个部分加载时的值\r\n};\r\n\t\t\t\t- 上面代码中，如果发生循环加载，require('a').foo的值很可能后面会被改写，改用require('a')会更保险一点。\r\n\r\n- ES6 模块的循环加载 \r\n\r\n\t- ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用import从一个模块加载变量（即import foo from 'foo'），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。\r\n\r\n\t\t- 请看下面这个例子。\r\n\r\n\t\t\t- // a.mjs\r\nimport {bar} from './b';\r\nconsole.log('a.mjs');\r\nconsole.log(bar);\r\nexport let foo = 'foo';\r\n\r\n// b.mjs\r\nimport {foo} from './a';\r\nconsole.log('b.mjs');\r\nconsole.log(foo);\r\nexport let bar = 'bar';\r\n\t\t\t- 上面代码中，a.mjs加载b.mjs，b.mjs又加载a.mjs，构成循环加载。执行a.mjs，结果如下。\r\n\t\t\t- $ node --experimental-modules a.mjs\r\nb.mjs\r\nReferenceError: foo is not defined\r\n\t\t\t- 上面代码中，执行a.mjs以后会报错，foo变量未定义，这是为什么？\r\n\r\n让我们一行行来看，ES6 循环加载是怎么处理的。首先，执行a.mjs以后，引擎发现它加载了b.mjs，因此会优先执行b.mjs，然后再执行a.mjs。接着，执行b.mjs的时候，已知它从a.mjs输入了foo接口，这时不会去执行a.mjs，而是认为这个接口已经存在了，继续往下执行。执行到第三行console.log(foo)的时候，才发现这个接口根本没定义，因此报错。\r\n\r\n解决这个问题的方法，就是让b.mjs运行的时候，foo已经有定义了。这可以通过将foo写成函数来解决。\r\n\t\t\t- // a.mjs\r\nimport {bar} from './b';\r\nconsole.log('a.mjs');\r\nconsole.log(bar());\r\nfunction foo() { return 'foo' }\r\nexport {foo};\r\n\r\n// b.mjs\r\nimport {foo} from './a';\r\nconsole.log('b.mjs');\r\nconsole.log(foo());\r\nfunction bar() { return 'bar' }\r\nexport {bar};\r\n\r\n\t\t\t\t- 这时再执行a.mjs就可以得到预期结果。\r\n\r\n\t\t\t\t\t- $ node --experimental-modules a.mjs\r\nb.mjs\r\nfoo\r\na.mjs\r\nbar\r\n\r\n\t\t\t- 这是因为函数具有提升作用，在执行import {bar} from './b'时，函数foo就已经有定义了，所以b.mjs加载的时候不会报错。这也意味着，如果把函数foo改写成函数表达式，也会报错。\r\n\r\n\t\t\t\t- // a.mjs\r\nimport {bar} from './b';\r\nconsole.log('a.mjs');\r\nconsole.log(bar());\r\nconst foo = () => 'foo';\r\nexport {foo};\r\n\t\t\t\t- 上面代码的第四行，改成了函数表达式，就不具有提升作用，执行就会报错。\r\n\r\n## 编程风格\r\n\r\n### 块级作用域\r\n\r\n- （1）let 取代 var\r\n- （2）全局常量和线程安全\r\n\r\n\t- 在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。\r\n\r\n\t\t- const优于let有几个原因。\r\n\r\n\t\t\t- 一个是const可以提醒阅读程序的人，这个变量不应该改变\r\n\t\t\t- 另一个是const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算\r\n\t\t\t- 最后一个原因是 JavaScript 编译器会对const进行优化，所以多使用const，有利于提高程序的运行效率，也就是说let和const的本质区别，其实是编译器内部的处理不同。\r\n\r\n\t\t- // bad\r\nvar a = 1, b = 2, c = 3;\r\n\r\n// good\r\nconst a = 1;\r\nconst b = 2;\r\nconst c = 3;\r\n\r\n// best\r\nconst [a, b, c] = [1, 2, 3];\r\n\t\t- const声明常量还有两个好处\r\n\r\n\t\t\t- 一是阅读代码的人立刻会意识到不应该修改这个值\r\n\t\t\t- 二是防止了无意间修改变量值所导致的错误。\r\n\r\n\t\t- 所有的函数都应该设置为常量。\r\n\r\n### 字符串\r\n\r\n- 静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。\r\n\r\n\t- // bad\r\nconst a = \"foobar\";\r\nconst b = 'foo' + a + 'bar';\r\n\r\n// acceptable\r\nconst c = `foobar`;\r\n\r\n// good\r\nconst a = 'foobar';\r\nconst b = `foo${a}bar`;\r\n\r\n### 解构赋值\r\n\r\n- 使用数组成员对变量赋值时，优先使用解构赋值。\r\n\r\n\t- const arr = [1, 2, 3, 4];\r\n\r\n// bad\r\nconst first = arr[0];\r\nconst second = arr[1];\r\n\r\n// good\r\nconst [first, second] = arr;\r\n\r\n- 函数的参数如果是对象的成员，优先使用解构赋值。\r\n\r\n\t- // bad\r\nfunction getFullName(user) {\r\n  const firstName = user.firstName;\r\n  const lastName = user.lastName;\r\n}\r\n\r\n// good\r\nfunction getFullName(obj) {\r\n  const { firstName, lastName } = obj;\r\n}\r\n\r\n// best\r\nfunction getFullName({ firstName, lastName }) {\r\n}\r\n\r\n- 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。\r\n\r\n\t- // bad\r\nfunction processInput(input) {\r\n  return [left, right, top, bottom];\r\n}\r\n\r\n// good\r\nfunction processInput(input) {\r\n  return { left, right, top, bottom };\r\n}\r\n\r\nconst { left, right } = processInput(input);\r\n\r\n### 对象\r\n\r\n- 单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。\r\n\r\n\t- // bad\r\nconst a = { k1: v1, k2: v2, };\r\nconst b = {\r\n  k1: v1,\r\n  k2: v2\r\n};\r\n\r\n// good\r\nconst a = { k1: v1, k2: v2 };\r\nconst b = {\r\n  k1: v1,\r\n  k2: v2,\r\n};\r\n\r\n- 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。\r\n\r\n\t- // bad\r\nconst a = {};\r\na.x = 3;\r\n\r\n// if reshape unavoidable\r\nconst a = {};\r\nObject.assign(a, { x: 3 });\r\n\r\n// good\r\nconst a = { x: null };\r\na.x = 3;\r\n\r\n- 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。\r\n\r\n\t- // bad\r\nconst obj = {\r\n  id: 5,\r\n  name: 'San Francisco',\r\n};\r\nobj[getKey('enabled')] = true;\r\n\r\n// good\r\nconst obj = {\r\n  id: 5,\r\n  name: 'San Francisco',\r\n  [getKey('enabled')]: true,\r\n};\r\n\t- 上面代码中，对象obj的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建obj的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。\r\n\r\n- 另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。\r\n\r\n\t- var ref = 'some value';\r\n\r\n// bad\r\nconst atom = {\r\n  ref: ref,\r\n\r\n  value: 1,\r\n\r\n  addValue: function (value) {\r\n    return atom.value + value;\r\n  },\r\n};\r\n\r\n// good\r\nconst atom = {\r\n  ref,\r\n\r\n  value: 1,\r\n\r\n  addValue(value) {\r\n    return atom.value + value;\r\n  },\r\n};\r\n\r\n### 数组\r\n\r\n- 使用扩展运算符（...）拷贝数组。\r\n\r\n\t- // bad\r\nconst len = items.length;\r\nconst itemsCopy = [];\r\nlet i;\r\n\r\nfor (i = 0; i < len; i++) {\r\n  itemsCopy[i] = items[i];\r\n}\r\n\r\n// good\r\nconst itemsCopy = [...items];\r\n\r\n- 使用 Array.from 方法，将类似数组的对象转为数组。\r\n\r\n\t- const foo = document.querySelectorAll('.foo');\r\nconst nodes = Array.from(foo);\r\n\r\n### Map 结构\r\n\r\n- 注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要key: value的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。\r\n\r\n\t- let map = new Map(arr);\r\n\r\nfor (let key of map.keys()) {\r\n  console.log(key);\r\n}\r\n\r\nfor (let value of map.values()) {\r\n  console.log(value);\r\n}\r\n\r\nfor (let item of map.entries()) {\r\n  console.log(item[0], item[1]);\r\n}\r\n\r\n### Class\r\n\r\n- 总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解。\r\n\r\n\t- // bad\r\nfunction Queue(contents = []) {\r\n  this._queue = [...contents];\r\n}\r\nQueue.prototype.pop = function() {\r\n  const value = this._queue[0];\r\n  this._queue.splice(0, 1);\r\n  return value;\r\n}\r\n\r\n// good\r\nclass Queue {\r\n  constructor(contents = []) {\r\n    this._queue = [...contents];\r\n  }\r\n  pop() {\r\n    const value = this._queue[0];\r\n    this._queue.splice(0, 1);\r\n    return value;\r\n  }\r\n}\r\n\r\n- 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。\r\n\r\n\t- // bad\r\nconst inherits = require('inherits');\r\nfunction PeekableQueue(contents) {\r\n  Queue.apply(this, contents);\r\n}\r\ninherits(PeekableQueue, Queue);\r\nPeekableQueue.prototype.peek = function() {\r\n  return this._queue[0];\r\n}\r\n\r\n// good\r\nclass PeekableQueue extends Queue {\r\n  peek() {\r\n    return this._queue[0];\r\n  }\r\n}\r\n\r\n### 模块\r\n\r\n- 首先，Module 语法是 JavaScript 模块的标准写法，坚持使用这种写法。使用import取代require。\r\n\r\n\t- // bad\r\nconst moduleA = require('moduleA');\r\nconst func1 = moduleA.func1;\r\nconst func2 = moduleA.func2;\r\n\r\n// good\r\nimport { func1, func2 } from 'moduleA';\r\n\r\n- 使用export取代module.exports。\r\n\r\n\t- // commonJS的写法\r\nvar React = require('react');\r\n\r\nvar Breadcrumbs = React.createClass({\r\n  render() {\r\n    return <nav />;\r\n  }\r\n});\r\n\r\nmodule.exports = Breadcrumbs;\r\n\r\n// ES6的写法\r\nimport React from 'react';\r\n\r\nclass Breadcrumbs extends React.Component {\r\n  render() {\r\n    return <nav />;\r\n  }\r\n};\r\n\r\nexport default Breadcrumbs;\r\n\t- 如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，export default与普通的export不要同时使用。\r\n\r\n- 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。\r\n\r\n\t- // bad\r\nimport * as myObject from './importModule';\r\n\r\n// good\r\nimport myObject from './importModule';\r\n\r\n- 如果模块默认输出一个函数，函数名的首字母应该小写。\r\n\r\n\t- function makeStyleGuide() {\r\n}\r\n\r\nexport default makeStyleGuide;\r\n\r\n- 如果模块默认输出一个对象，对象名的首字母应该大写。\r\n\r\n\t- const StyleGuide = {\r\n  es6: {\r\n  }\r\n};\r\n\r\nexport default StyleGuide;\r\n\r\n### ESLint 的使用\r\n\r\n- ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。\r\n\r\n\t- 首先，安装 ESLint。\r\n\r\n\t\t- $ npm i -g eslint\r\n\r\n\t- 然后，安装 Airbnb 语法规则，以及 import、a11y、react 插件。\r\n\r\n\t\t- $ npm i -g eslint-config-airbnb\r\n$ npm i -g eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react\r\n\r\n\t- 最后，在项目的根目录下新建一个.eslintrc文件，配置 ESLint。\r\n\r\n\t\t- {\r\n  \"extends\": \"eslint-config-airbnb\"\r\n}\r\n\r\n\t- 现在就可以检查，当前项目的代码是否符合预设的规则。\r\n\r\n\t\t- index.js文件的代码如下。\r\n\r\n\t\t\t- var unusued = 'I have no purpose!';\r\n\r\nfunction greet() {\r\n    var message = 'Hello, World!';\r\n    alert(message);\r\n}\r\n\r\ngreet();\r\n\t\t\t- 使用 ESLint 检查这个文件，就会报出错误。\r\n\t\t\t- $ eslint index.js\r\nindex.js\r\n  1:1  error  Unexpected var, use let or const instead          no-var\r\n  1:5  error  unusued is defined but never used                 no-unused-vars\r\n  4:5  error  Expected indentation of 2 characters but found 4  indent\r\n  4:5  error  Unexpected var, use let or const instead          no-var\r\n  5:5  error  Expected indentation of 2 characters but found 4  indent\r\n\r\n✖ 5 problems (5 errors, 0 warnings)\r\n\t\t\t- 上面代码说明，原文件有五个错误，其中两个是不应该使用var命令，而要使用let或const；一个是定义了变量，却没有使用；另外两个是行首缩进为 4 个空格，而不是规定的 2 个空格。\r\n\r\n### 函数\r\n\r\n- 立即执行函数可以写成箭头函数的形式。\r\n\r\n\t- (() => {\r\n  console.log('Welcome to the Internet.');\r\n})();\r\n\r\n- 那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 this。\r\n\r\n\t- // bad\r\n[1, 2, 3].map(function (x) {\r\n  return x * x;\r\n});\r\n\r\n// good\r\n[1, 2, 3].map((x) => {\r\n  return x * x;\r\n});\r\n\r\n// best\r\n[1, 2, 3].map(x => x * x);\r\n\r\n- 箭头函数取代Function.prototype.bind，不应再用 self/_this/that 绑定 this。\r\n\r\n\t- // bad\r\nconst self = this;\r\nconst boundMethod = function(...params) {\r\n  return method.apply(self, params);\r\n}\r\n\r\n// acceptable\r\nconst boundMethod = method.bind(this);\r\n\r\n// best\r\nconst boundMethod = (...params) => method.apply(this, params);\r\n\t- 简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。\r\n\r\n- 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。\r\n\r\n\t- // bad\r\nfunction divide(a, b, option = false ) {\r\n}\r\n\r\n// good\r\nfunction divide(a, b, { option = false } = {}) {\r\n}\r\n\r\n- 不要在函数体内使用 arguments 变量，使用 rest 运算符（...）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。\r\n\r\n\t- // bad\r\nfunction concatenateAll() {\r\n  const args = Array.prototype.slice.call(arguments);\r\n  return args.join('');\r\n}\r\n\r\n// good\r\nfunction concatenateAll(...args) {\r\n  return args.join('');\r\n}\r\n\r\n- 使用默认值语法设置函数参数的默认值。\r\n\r\n\t- // bad\r\nfunction handleThings(opts) {\r\n  opts = opts || {};\r\n}\r\n\r\n// good\r\nfunction handleThings(opts = {}) {\r\n  // ...\r\n}\r\n\r\n",Ir={data:function(){return{MainComponent:Dr}}},Jr=Ir,Lr=Object(m["a"])(Jr,Nr,Ar,!1,null,"7cd51b2f",null),Hr=Lr.exports,Fr=function(){var n=this;return n.$createElement,n._self._c,n._m(0)},Ur=[function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[r("div",{staticClass:"line number1 index0 alt2"},[r("code",{staticClass:"javascript plain"},[n._v("str.replace(/")]),r("code",{staticClass:"javascript keyword"},[n._v("class")]),r("code",{staticClass:"javascript plain"},[n._v('=[\\"|')]),r("code",{staticClass:"javascript string"},[n._v("'](.*?)[\\\"|'")]),r("code",{staticClass:"javascript plain"},[n._v("].*?/g, ")]),r("code",{staticClass:"javascript string"},[n._v("''")]),r("code",{staticClass:"javascript plain"},[n._v(")")])])])}],qr={},Br=qr,Wr=Object(m["a"])(Br,Fr,Ur,!1,null,"ffe97eb4",null),Vr=Wr.exports,Gr=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},zr=[],$r="# Jquery\r\n\r\n## 1.优点\r\n\r\n### 1.隐私迭代\r\n\r\n- 自动遍历元素\r\n\r\n### 2.链式编程\r\n\r\n- 用白话说：可以一直点下去\r\n\r\n## 2.入口函数（如果写在html的上面，一定要有入口函数）\r\n\r\n### 1.$（function () { } ）\r\n\r\n### 2.$(document).ready（function（）{ } ）\r\n\r\n## 3.顶级对象\r\n\r\n### $\r\n\r\n## 4.相互转换\r\n\r\n### 1.DOM对象==>jQuery对象\r\n\r\n- 例如：$(btn)\r\n\r\n\t- 注意（）括号里面直接使用DOM对象，不用加‘’引号\r\n\r\n### 2.jQuery==>DOM对象\r\n\r\n- 1.$('input')[0]\r\n- 2.$('input').get[0]\r\n\r\n## 5.方法\r\n\r\n### 1.获取索引\r\n\r\n- index()\r\n\r\n\t- 可以获取当前伪数组的索引\r\n\r\n### 2.属性操作\r\n\r\n- 1.基本（固有）属性\r\n\r\n\t- prop();\r\n\r\n\t\t- 1.一个值伪获取\r\n\t\t- 2.二个值伪设置\r\n\r\n- 2.自定义属性\r\n\r\n\t- attr();\r\n\r\n\t\t- 1.一个值伪获取\r\n\t\t- 2.二个值伪设置\r\n\r\n### 3.内容文本值\r\n\r\n- 1.html() \r\n\r\n\t- 大多数 双标签使用\r\n\r\n- 2.text()\r\n\r\n\t- 大多数 双标签使用\r\n\r\n- 3.val()\r\n\r\n\t- 大多数 表单使用\r\n\r\n### 4.获取祖先元素\r\n\r\n- parents()\r\n\r\n### 5.遍历\r\n\r\n- 1.遍历元素\r\n\r\n\t- jQuery对象.each(function(参数1，参数2){\r\n})\r\n参数1：每个元素的索引号\r\n参数2：这里是DOM的元素对象，需要转为JQ的对象\r\n\r\n- 2.遍历数据\r\n\r\n\t- $.each（遍历谁，function(){\r\n}）\r\n参数1：是每个元素的索引号;   \r\n参数2：遍历内容\r\n\r\n### 6.元素操作\r\n\r\n- 1.创建元素\r\n\r\n\t- $(\"<li></li>\")\r\n\r\n- 2.添加元素（父子关系）\r\n\r\n\t- append();\r\n\t- prepend();\r\n\r\n- 3.外部添加（兄弟关系）\r\n\r\n\t- after();\r\n\t- before();\r\n\r\n- 4.删除元素\r\n\r\n\t- remove（）把整个元素i清空\r\n\t- empty（）把内容i清空\r\n\t- html('')=>添加空的字符串\r\n\r\n## 6.选择器\r\n\r\n### 1.基本\r\n\r\n- 1.标签名 $('div')\r\n- 2.id名$('#div')\r\n- 3.* $('*')\r\n- 4.class名 $('.box')\r\n- 5.获取多个 $('p,img')\r\n- 6.交集 $('p.c1')\r\n- 7.子代 $('p>span')\r\n- 8.后代 $('p span')\r\n\r\n### 2.筛选选择器\r\n\r\n- 1.第一个元素 $('li:first')\r\n- 2.最后一个元素 $('li:last')\r\n- 3.\"索引\"为2的元素 $('li:eq(2)')\r\n- 4.索引为奇数 $('li:odd')\r\n- 5.索引为偶数 $('li:even')\r\n\r\n### 3.筛选方法\r\n\r\n- 1.父级 \r\n\r\n\t- $('li.parent()')\r\n\r\n- 2.子级\r\n\r\n\t- $(’li‘).children()\r\n\t- 一个儿子 $(’li‘).children(‘p’)\r\n\r\n- 3.后代级\r\n\r\n\t- $('li').find('p')\r\n\r\n- 4.兄弟\r\n\r\n\t- $('li').siblings()\r\n\r\n- 5.前面兄弟\r\n\r\n\t- $('li c4').nextAll()\r\n\r\n- 6.后面兄弟\r\n\r\n\t- $('li c4').prveAll()\r\n\r\n- 7.判断某个元素是否有哪个类名(返回值booleqan)\r\n\r\n\t-  $('li').hasClass('c2')   \r\n\r\n- 8.指定索引方法【推荐】\r\n\r\n\t- $('li').eq(2)\r\n\r\n## 7.样式操作\r\n\r\n### 1.直接操作\r\n\r\n- 单一操作\r\n\r\n\t- $(‘div’).css('width',100)\r\n\r\n- 多种样式一起改变（传入对象）\r\n\r\n\t- $('div').css({\r\n\twidth:200,\r\n\theight:200,\r\n})\r\n\r\n### 2.类名操作\r\n\r\n- 1.添加\r\n\r\n\t- $('div').addCLass(‘类名’)\r\n\r\n- 2.删除\r\n\r\n\t- $('div').removeCLass(‘类名’)\r\n\r\n- 3.切换\r\n\r\n\t- $('div').toggleClassCLass(‘类名’)\r\n\r\n## 8.效果\r\n\r\n### 1.显示隐藏（三个参数均可以省略）\r\n\r\n- 1.显示\r\n\r\n\t- show('时间','切换效果','回调函数')\r\n\r\n- 2.隐藏\r\n\r\n\t- hide('时间','切换效果','回调函数')\r\n\r\n- 3.切换\r\n\r\n\t- toggle('时间','切换效果','回调函数')\r\n\r\n### 2.滑动效果（三个参数均可以省略）\r\n\r\n- 1.向下滑\r\n\r\n\t- slideDown('时间','切换效果','回调函数')\r\n\r\n- 2.向上滑\r\n\r\n\t- slideUp('时间','切换效果','回调函数')\r\n\r\n- 3.切换\r\n\r\n\t- slideToggle('时间','切换效果','回调函数')\r\n\r\n### 3.事件切换\r\n\r\n- hover（function（），function（））\r\n\r\n\t- 1.第一个参数，鼠标进入\r\n\t- 2.第二个参数，鼠标移除\r\n\t- 注意：如果参数只写一个，则鼠标进入和离开的时候都会触发他\r\n\t- (不支持冒泡)mouseencter <==> mouseover（支持冒泡）\r\n\t- （不支持冒泡）mouseleave <==> mouseout（支持冒泡）\r\n\r\n### 4.淡入淡出效果\r\n\r\n- 1.淡入\r\n\r\n\t- fadeIn('时间','切换效果','回调函数')\r\n\r\n- 2.淡出\r\n\r\n\t- fadeOut('时间','切换效果','回调函数')\r\n\r\n- 3.切换\r\n\r\n\t- fadeToggle('时间','切换效果','回调函数')\r\n\r\n- 4.淡入/出到某个程度\r\n\r\n\t- fadeTo('时间','透明度','切换效果','回调函数')  ====>前两个参数必须写\r\n\r\n### 5.自定义动画\r\n\r\n- animate('params','速度','切换效果','回调函数')\r\n\r\n\t- params(更改的样式)\r\n\r\n\t\t- 1.必须写\r\n\t\t- 2.对象形式\r\n\t\t- 3.不可以设置颜色\r\n\r\n### 6.动画队列及其停止排队方法\r\n\r\n- stop()\r\n\r\n## 9.jQuery尺寸\r\n\r\n### width（）；\r\n\r\n### height （）；\r\n\r\n### innerWidth（）；\r\n\r\n### innerHeight();\r\n\r\n### outerWidth();\r\n\r\n### outerHeight();\r\n\r\n### outerWidth(true);\r\n\r\n### outerHeight(true);\r\n\r\n## 10.jQuery位置\r\n\r\n### 1.offset（）；\r\n\r\n- 1.距离文档的距离\r\n- 2.返回值是一个对象\r\n- 3.可以设置\r\n\r\n### 2.position（）\r\n\r\n- 1.距离带有定位父元素的距离\r\n- 2.返回值是一个对象\r\n- 3.不可以设置\r\n\r\n### 3.scrollTop();\r\n\r\n- 卷起上部分的距离\r\n\r\n### 4.scrollLeft();\r\n\r\n- 卷据做部分的距离\r\n\r\n## 11.jQuery事件\r\n\r\n### 1.事件注册\r\n\r\n- element.事件（function(){}）\r\n\r\n### 2.绑定事件\r\n\r\n- on的方式\r\n\r\n\t- 1.element.on（‘事件’，‘元素’，‘fn’）\r\n\t- 2.element.on（{\r\n\tclick:function(){},\r\n    mouseover:function(){}\r\n}）\r\n\r\n\t\t- 优势:1.可以绑定多个事件，多个处理事件处理程序\r\n       2.可以完成事件委派（委托）\r\n       3.动态添加的元素也享有事件，需要事件委派\r\n\r\n\t- 3.element.one('click','fn')\r\n\r\n\t\t- 事件只完成1次\r\n\r\n### 2.解绑事件\r\n\r\n- 1.$('div').off();\r\n\r\n\t- div身上的全部事件解绑\r\n\r\n- 2.$('div').off('click')\r\n\r\n\t- div身上的click事件解绑\r\n\r\n- 3.$('div').off('click','li')\r\n\r\n\t- 解绑事件委托\r\n\r\n### 3.自动触发事件\r\n\r\n- 1.element.click();\r\n- 2.element.tigger('click')\r\n\r\n\t- 自动触发，不需要点击\r\n\r\n- 3.element.tiggerHandler('click');\r\n\r\n\t- 不会触发元素的默认行为\r\n\r\n## 13.事件对象\r\n\r\n### 1.阻止默认行为：\r\n\r\n- 1.event.preventDefault()\r\n- 2.return  false \r\n\r\n### 2.阻止冒泡：\r\n\r\n-  event.stopPropagation()\r\n\r\n",Xr={data:function(){return{MainComponent:$r}}},Kr=Xr,Qr=Object(m["a"])(Kr,Gr,zr,!1,null,"08ba9b72",null),Yr=Qr.exports,Zr=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},ne=[],te="# 阮一峰JavaScript基础总结\r\n\r\n## 阮一峰·JS基 础语法部分\r\n\r\n### 基本语法\r\n\r\n- switch不进行类型转换\r\n\r\n- 三元运算符\r\n\r\n- break与continue语句\r\n\r\n- 标签：Label\r\n\r\n### 数据类型\r\n\r\n- 六种主要数据类型\r\n\r\n\t- 字符串，数值，布尔值，null，undefined，对象\r\n\t- ES6新增Symbol\r\n\r\n- JavaScript确定值类型的三种方法\r\n\r\n\t- typeof运算符\r\n\r\n\t\t- 一共六种类型，注意6，7。对于Array,Null等特殊对象使用typeof一律返回object，这正是typeof的局限性，typeof只能区分值类型的，不能区分引用类型\r\n\t\t- 注意使用typeof得到的六种结果为：number，function，object，string，undefined，boolean\r\n\r\n\t- instanceof运算符\r\n\r\n\t\t- instanceof：用于判断 引用类型 属于哪个构造函数的方法\r\n\t- Object.prototype.toString方法\r\n\r\n- null与undefined\r\n\r\n\t- 区别：null是一个表示“空”的对象，转为数值时为0；undefined是一个表示”此处无定义”的原始值，转为数值时为NaN。\r\n\r\n\t- 用法与含义\r\n\r\n- 布尔值\r\n\r\n\t- 哪些运算符会返回布尔值？\r\n\r\n\t\t- 两元逻辑运算符： && (And)，|| (Or)\r\n\t\t- 前置逻辑运算符： ! (Not)\r\n\t\t- 相等运算符：===，!==，==，!=\r\n\t\t- 比较运算符：>，>=，<，<=\r\n\r\n\t- 转换规则\r\n\r\n\t\t- 除了下面六个值被转为false，其他值都视为true。\r\n\t\t- undefined，null，false，0，NaN，\"\"或''（空字符串）\r\n\r\n### 数值\r\n\r\n- 整数和浮点数\r\n\r\n\t- JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。\r\n\r\n\t- JavaScript语言底层没有整数\r\n\t- 涉及到小数的比较与运算要特别小心\r\n\r\n- 数值范围\r\n\r\n\t-  JavaScript 能够表示的数值范围为2的1024次方到2的-1023次方（开区间），超出这个范围的数无法表示\r\n\t- 正向溢出\r\n\r\n\t- 负向溢出\r\n\r\n\t- JavaScript 提供Number对象的MAX_VALUE和MIN_VALUE属性，返回可以表示的具体的最大值和最小值。\r\n\r\n\t\t- Number.MAX_VALUE // 1.7976931348623157e+308\r\n\t\t- Number.MIN_VALUE // 5e-324\r\n\r\n- 数值进制\r\n\r\n\t- 十进制：没有前导0的数值。\r\n\t- 八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。\r\n\t- 十六进制：有前缀0x或0X的数值。\r\n\t- 二进制：有前缀0b或0B的数值。\r\n\r\n- 正负零的唯一区别\r\n\r\n- NaN\r\n\r\n\t- 含义\r\n\r\n\t\t- 数据类型依然属于Number，主要出现在将字符串解析成数字出错的场合。另外，一些数学函数的运算结果会出现NaN。0除以0也会得到NaN。\r\n\r\n\t- 运算规则\r\n\r\n\t\t- NaN不等于任何值，包括它本身。\r\n\t\t- 数组的indexOf方法内部使用的是严格相等运算符，所以该方法对NaN不成立。\r\n\r\n\t\t- NaN在布尔运算时被当作false。\r\n\t\t- NaN与任何数（包括它自己）的运算，得到的都是NaN。\r\n\r\n- 相关方法\r\n\r\n\t- parseInt()\r\n\r\n\t\t- \r\n该方法用于将字符串转为整数。返回值只有两种可能，要么是一个十进制整数，要么是NaN。\r\n\r\n1）如果字符串头部有空格，空格会被自动去除。\r\n\r\n2）如果parseInt的参数不是字符串，则会先转为字符串再转换。\r\n\r\n3）字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。\r\n\t\t- 对于自动转科学计数法的情况\r\n\r\n\t\t- 进制转换\r\n\r\n\t\t\t- parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。\r\n\t\t\t- 第一个参数自转字符串引发进制转换的错误\r\n\r\n\t- parseFloat()\r\n\r\n\t\t- \r\n该方法用于将一个字符串转为浮点数。\r\n\t\t- parseFloat()在转化NaN不同于Number()，如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN。尤其注意！parseFloat会将空字符串转为NaN。\r\n\r\n\t- isNaN()\r\n\r\n\t\t- \r\nisNaN方法可以用来判断一个值是否为NaN。\r\n\t\t- 可以令isNaN()返回true的情况：NaN、字符串、对象、数组\r\n\r\n\t\t- 使用\r\n\r\n\t\t\t- 使用isNaN之前，最好判断一下数据类型。\r\n\r\n\t\t\t\t- function myIsNaN(value) {\r\n  return typeof value === 'number' && isNaN(value);\r\n}\r\n\r\n\t\t- 替代\r\n\r\n\t\t\t- 判断isNaN更可靠的方法是，利用NaN为唯一不等于自身的值的这个特点，进行判断。\r\n\r\n\t\t\t\t- function myIsNaN(value) {\r\n  return value !== value;\r\n}\r\n\r\n\t- isFinite()\r\n\r\n\t\t- isFinite方法返回一个布尔值，表示某个值是否为正常的数值。\r\n\t\t- 除了Infinity、-Infinity和NaN这三个值会返回false，isFinite对于其他的数值都会返回true。\r\n\r\n\t\t\t- isFinite(Infinity) // false\r\n\t\t\t- isFinite(-Infinity) // false\r\n\t\t\t- isFinite(NaN) // false\r\n\t\t\t- isFinite(-1) // true\r\n\r\n### 字符串\r\n\r\n- 定义\r\n\r\n\t- 字符串默认只能写在一行内，分成多行将会报错。\r\n\r\n\t- 如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。\r\n\r\n- 转义\r\n\r\n\t- 反斜杠的特殊用法\r\n\r\n- 字符串与数组的相似性\r\n\r\n\t- 字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。\r\n\t- 如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。\r\n\r\n- length属性\r\n\r\n\t- length属性返回字符串的长度，该属性也是无法改变的。\r\n\r\n- 字符集\r\n\r\n\t- JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。\r\n\r\nJavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成\\uxxxx的形式，其中xxxx代表该字符的 Unicode 码点。比如，\\u00A9代表版权符号。\r\n\t- 对于码点在U+10000到U+10FFFF之间的字符，JavaScript 总是认为它们是两个字符（length属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是不正确的。\r\n\r\n- Base64转码\r\n\r\n  有时，文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。\r\n\r\n\t- 定义\r\n\r\n\t\t- \r\n一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符\r\n\r\n\t- 使用目的\r\n\r\n\t\t- 不是为了加密，而是为了不出现特殊字符，简化程序的处理。\r\n\r\n\t- JavaScript 原生提供两个 Base64 相关的方法。\r\n\r\n\t\t- btoa()：任意值转为 Base64 编码\r\n\t\t- atob()：Base64 编码转为原来的值\r\n\t- 注意\r\n\r\n\t\t- 这两个方法不适合非 ASCII 码的字符\r\n\t\t- 要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。\r\n\r\n### 对象\r\n\r\n- 键名\r\n\r\n\t- \r\n如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。\r\n\r\n- 对象的引用\r\n\r\n\t- 如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。\r\n\r\n\t- 此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。\r\n\r\n- 表达式还是语句\r\n\r\n\t- 如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。\r\n\r\n- 属性的操作\r\n\r\n\t- 属性读取\r\n\r\n\t\t- \r\n请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。\r\n\r\n\t\t- 注意，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。\r\n\r\n\t- 查看所有属性\r\n\r\n\t\t- 查看一个对象本身的所有属性，可以使用Object.keys方法。\r\n\r\n\t- delete 命令\r\n\r\n\t\t- delete命令用于删除对象的属性，删除成功后返回true。\r\n\r\n\t\t- 注意，删除一个不存在的属性，delete不报错，而且返回true。不能根据delete命令的结果，认定某个属性是存在的。\r\n\r\n\t\t- 只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。\r\n\r\n\t\t- 需要注意的是，delete命令只能删除对象本身的属性，无法删除继承的属性\r\n\r\n\t- in 运算符\r\n\r\n\t\t- \r\nin运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true\r\n\t\t- in运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。\r\n\r\n\t- for…in 循环\r\n\r\n\t\t- for...in循环用来遍历一个对象的全部属性。\r\n\r\n\t\t- 注意点\r\n\r\n\t\t\t- 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。\r\n\t\t\t- 它不仅遍历对象自身的属性，还遍历继承的属性。\r\n\r\n\t\t- 使用\r\n\r\n\t\t\t- 使用for...in的时候，应该结合使用hasOwnProperty方法，在循环内部判断一下，某个属性是否为对象自身的属性。\r\n\r\n\t- with 语句\r\n\r\n\t\t- 作用\r\n\r\n\t\t\t- 操作同一个对象的多个属性时，提供一些书写的方便。\r\n\r\n\t\t- 注意\r\n\r\n\t\t\t- 如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。\r\n\r\n### 数组\r\n\r\n- 定义\r\n\r\n\t- 任何类型的数据，都可以放入数组。\r\n\r\n- length 属性\r\n\r\n\t- length属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。清空数组的一个有效方法，就是将length属性设为0。\r\n\t- 如果人为设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。当length属性设为大于数组个数时，读取新增的位置都会返回undefined\r\n\t- 注意\r\n\r\n\t\t- 由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响length属性的值。\r\n\r\n- in 运算符\r\n\r\n\t- \r\n检查某个键名是否存在的运算符in，适用于对象，也适用于数组。\r\n\r\n- for…in 循环和数组的遍历\r\n\r\n\t- for...in不仅会遍历数组所有的数字键，还会遍历非数字键。\r\n\t- 不推荐使用for...in遍历数组。数组的遍历可以考虑使用for循环或while循环。\r\n\r\n\t- foreach方法\r\n\r\n\t\t- 数组的forEach方法，也可以用来遍历数组\r\n\r\n- 数组的空位\r\n\r\n\t- 数组的空位在length属性中有体现，并且是可以读取的，返回undefined。\r\n\t- 注意\r\n\r\n\t\t- 数组的某个位置是空位，与某个位置是undefined，是不一样的。如果是空位，使用数组的forEach方法、for...in结构、以及Object.keys方法进行遍历，空位都会被跳过。\r\n\t\t- 如果某个位置是undefined，遍历的时候就不会被跳过。\r\n\r\n- “类似数组的对象”使用数组方法\r\n\r\n\t- 1）数组的slice方法可以将“类似数组的对象”变成真正的数组。\r\n\r\n\t\t- var arr = Array.prototype.slice.call(arrayLike);\r\n\r\n\t- 2）就是通过call()把数组的方法放到对象上面。\r\n\r\n\t  注意，这种方法比直接使用数组原生的forEach要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的forEach方法。\r\n\r\n### 函数\r\n\r\n- 递归\r\n\r\n\t- 函数可以调用自身，这就是递归（recursion）\r\n\r\n- 变量提升\r\n\r\n\t- 如果同时采用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义。\r\n\r\n- 不能在条件语句中声明函数\r\n\r\n\t- 根据 ES5 的规范，不得在非函数的代码块中声明函数，最常见的情况就是if和try语句。\r\n- 函数的属性和方法\r\n\r\n\t- name 属性\r\n\r\n\t\t- 函数的name属性返回函数的名字。\r\n\t\t- 用处\r\n\r\n\t\t\t- name属性的一个用处，就是获取参数函数的名字。\r\n\r\n\t- length 属性\r\n\r\n\t\t- \r\n函数的length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。\r\n\t\t- length属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的”方法重载“\r\n\r\n\t- toString()\r\n\r\n\t\t- \r\n函数的toString方法返回一个字符串，内容是函数的源码。\r\n\r\n- 函数的参数\r\n\r\n\t- 参数的省略\r\n\r\n\t\t- 需要注意的是，函数的length属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。\r\n\t\t- 没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入undefined。\r\n\r\n\t- 参数的传递\r\n\r\n\t\t- 原始类型的值（数值、字符串、布尔值），传递方式是传值传递（在函数体内修改参数值，不会影响到函数外部。）\r\n\t\t- 参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（内部修改参数，将会影响到原始值。）\r\n\r\n\t\t- 注意！如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。\r\n\r\n- arguments 对象\r\n\r\n\t- 定义\r\n\r\n\t\t- \r\n这个对象只有在函数体内部，才可以使用。\r\n\r\n\t- argument.length\r\n\r\n\t\t- 通过arguments对象的length属性，可以判断函数调用时到底带几个参数。\r\n\r\n\t- 与数组的关系\r\n\r\n\t\t- 虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。\r\n\t\t- 让argument对象使用数组方法\r\n\r\n\t\t\t- 如果要让arguments对象使用数组方法，真正的解决方法是将arguments转为真正的数组。下面是两种常用的转换方法：slice方法和逐一填入新数组。\r\n\r\n\t- callee 属性\r\n\r\n\t\t- arguments对象带有一个callee属性，返回它所对应的原函数。\r\n- 闭包\r\n\r\n\t- 闭包的作用\r\n\r\n\t\t- 1.读取函数内部的变量，并让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。\r\n\r\n\t\t- 2.封装对象的私有属性和私有方法。\r\n\r\n\t- 注意\r\n\r\n\t\t- 注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。\r\n\r\n- eval 命令\r\n\r\n\t- 定义\r\n\r\n\t\t- eval命令的作用是，将字符串当作语句执行。\r\n\r\n\t- 性质\r\n\r\n\t\t- 放在eval中的字符串，应该有独自存在的意义，不能用来与eval以外的命令配合使用。\r\n\t\t- eval没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。\r\n\r\n\t- 与eval()相类似的\r\n\r\n### 运算符\r\n\r\n- 数值运算符\r\n\r\n\t- 数值运算符的作用在于可以将任何值转为数值（与Number函数的作用相同）。\r\n\r\n- 指数运算符\r\n\r\n- 字符串的比较\r\n\r\n\t- JavaScript 引擎内部首先比较字符串中首字符的 Unicode 码点。如果相等，再比较第二个字符的 Unicode 码点，以此类推。\r\n\r\n- 非字符串的比较\r\n\r\n\t- （1）原始类型的值\r\n\r\n\t\t- 先转成数值再比较。\r\n\r\n\t- （2）对象\r\n\r\n\t\t- 如果运算子是对象，会转为原始类型的值，再进行比较。\r\n\t\t- 对象转换成原始类型的值，算法是先调用valueOf方法；如果返回的还是对象，再接着调用toString方法，\r\n\r\n\t- （3）undefined == null // true;  undefined === null //false\r\n\r\n- 且运算符（&&）\r\n\r\n\t- 运算规则\r\n\r\n\t\t- 如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。\r\n\r\n\t- 取代if结构\r\n\r\n\t- 多个连用\r\n\r\n\t\t- 且运算符可以多个连用，这时返回第一个布尔值为false的表达式的值。\r\n- 或运算符（||）\r\n\r\n\t- 或运算符常用于为一个变量设置默认值。\r\n- 逗号运算符\r\n\r\n\t- 逗号运算符用于对两个表达式求值，并返回后一个表达式的值。\r\n### 数据类型转换\r\n\r\n- 强制转换\r\n\r\n\t- Number()\r\n\r\n\t\t- 定义\r\n\r\n\t\t\t- 使用Number函数，可以将任意类型的值转化成数值。\r\n\r\n\t\t- 参数为原始类型的值\r\n\r\n\t\t\t- 只要有一个字符无法转成数值，整个字符串就会被转为NaN。\r\n\t\t- 参数为对象\r\n\r\n\t\t\t- Number方法的参数是对象时，将返回NaN，除非是包含单个数值的数组。\r\n\r\n\t- String()\r\n\r\n\t\t- （1）原始类型值\r\n\r\n\t\t\t- 数值：转为相应的字符串。\r\n\t\t\t- 字符串：转换后还是原来的值。\r\n\t\t\t- 布尔值：true转为字符串\"true\"，false转为字符串\"false\"。\r\n\t\t\t- undefined：转为字符串\"undefined\"。\r\n\t\t\t- null：转为字符串\"null\"。\r\n\r\n\t\t- （2）对象\r\n\r\n\t\t\t- String方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。\r\n\r\n\t- Boolean()\r\n\r\n\t\t- 除了以下五个值的转换结果为false，其他的值全部为true。\r\n\r\n\t\t\t- undefined\r\n\t\t\t- null\r\n\t\t\t- -0或+0\r\n\t\t\t- NaN\r\n\t\t\t- ''（空字符串）\r\n\r\n\t\t- 注意\r\n\r\n\t\t\t- 所有对象（包括空对象）的转换结果都是true，甚至连false对应的布尔对象new Boolean(false)也是true\r\n- 自动转换\r\n\r\n\t- !! expression\r\n\r\n- 对象类型转换\r\n\r\n\t- valueOf（）\r\n\r\n\t- toString（）\r\n\r\n### 错误处理机制\r\n\r\n- Error 实例对象\r\n\r\n\t- message属性：错误提示信息\r\n\t- name属性：错误名称（非标准属性）\r\n\t- stack属性：错误的堆栈（非标准属性）\r\n\r\n- Error的6个派生对象\r\n\r\n\t- SyntaxError 对象\r\n\r\n\t\t- SyntaxError对象是解析代码时发生的语法错误。\r\n\r\n\t- ReferenceError 对象\r\n\r\n\t\t- ReferenceError对象是引用一个不存在的变量时发生的错误。\r\n\t\t- 另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值。\r\n\r\n\t- RangeError 对象\r\n\r\n\t\t- RangeError对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。\r\n\r\n\t- TypeError 对象\r\n\r\n\t\t- TypeError对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。\r\n\r\n\t- URIError 对象\r\n\r\n\t\t- URIError对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。\r\n\r\n\t- EvalError 对象\r\n\r\n\t\t- eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。\r\n\r\n- throw 语句\r\n\r\n\t- 定义\r\n\r\n\t\t- throw语句的作用是手动中断程序执行，抛出一个错误。实际上，throw可以抛出任何类型的值。也就是说，它的参数可以是任何值\r\n\r\n- try…catch 结构\r\n\r\n\t- 定义\r\n\r\n\t\t- try代码块抛出错误（上例用的是throw语句），JavaScript 引擎就立即把代码的执行，转到catch代码块，或者说错误被catch代码块捕获了。catch接受一个参数，表示try代码块抛出的值。\r\n\r\n## 阮一峰·JS标 准库\r\n\r\n### Object对象\r\n\r\n- 概述\r\n\r\n\t- JavaScript 的所有其他对象都继承自Object对象，即那些对象都是Object的实例。\r\n\t- Object对象的原生方法\r\n\r\n\t\t- Object本身的方法（静态方法）\r\n\r\n\t\t- Object的实例方法。\r\n\r\n- Object作为函数的用法：Object()\r\n\r\n\t- Object作为工具函数\r\n\r\n\t\t- 如果参数是原始类型的值，Object方法将其转为对应的包装对象的实例\r\n\r\n\t\t- 如果Object方法的参数是一个对象，它总是返回该对象，即不用转换。\r\n\r\n\t\t\t- 利用这一点，可以写一个判断变量是否为对象的函数。\r\n\t- Object 作为构造函数\r\n\r\n\t\t- Object构造函数的首要用途，是直接通过它来生成新对象，通过var obj = new Object()的写法生成新对象，与字面量的写法var obj = {}是等价的。\r\n\t\t- 与其作为工具函数的用法相似，但是Object(value)与new Object(value)两者的语义是不同的，Object(value)表示将value转成一个对象，new Object(value)则表示新生成一个对象，它的值是value。\r\n\r\n- Object 的静态方法\r\n\r\n\t- （0）遍历对象的属性的两种方法\r\n\r\n\t\t- Object.keys方法只返回可枚举的属性，Object.getOwnPropertyNames方法还返回不可枚举的属性名。\r\n\r\n\t- （1）对象属性模型的相关方法\r\n\r\n\t\t- Object.getOwnPropertyDescriptor()：获取某个属性的描述对象。\r\n\t\t- Object.defineProperty()：通过描述对象，定义某个属性。\r\n\t\t- Object.defineProperties()：通过描述对象，定义多个属性。\r\n\r\n\t- （2）控制对象状态的方法\r\n\r\n\t\t- Object.preventExtensions()：防止对象扩展。\r\n\t\t- Object.isExtensible()：判断对象是否可扩展。\r\n\t\t- Object.seal()：禁止对象配置。\r\n\t\t- Object.isSealed()：判断一个对象是否可配置。\r\n\t\t- Object.freeze()：冻结一个对象。\r\n\t\t- Object.isFrozen()：判断一个对象是否被冻结。\r\n\r\n\t- （3）原型链相关方法\r\n\r\n\t\t- Object.create()：该方法可以指定原型对象和属性，返回一个新的对象。\r\n\t\t- Object.getPrototypeOf()：获取对象的Prototype对象。\r\n\r\n- Object 的实例方法\r\n\r\n\t- Object.prototype.valueOf()：返回当前对象对应的值。\r\n\r\n\t\t- valueOf方法的作用是返回一个对象的“值”，默认情况下返回对象本身。\r\n\t- Object.prototype.toString()：返回当前对象对应的字符串形式。\r\n\r\n\t\t- toString方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串。\r\n\r\n\t\t- 数组、字符串、函数、Date 对象都分别部署了自定义的toString方法，覆盖了Object.prototype.toString方法。\r\n\r\n\t\t- toString() 的应用：判断数据类型\r\n\r\n\t\t\t- 概述\r\n\r\n\t\t\t- 应用\r\n\r\n\t\t\t- 不同数据类型的Object.prototype.toString方法返回值如下。即利用这个特性可以做一个准确的类型判断。\r\n\r\n\t\t\t\t- 数值：返回[object Number]。\r\n\t\t\t\t- 字符串：返回[object String]。\r\n\t\t\t\t- 布尔值：返回[object Boolean]。\r\n\t\t\t\t- undefined：返回[object Undefined]。\r\n\t\t\t\t- null：返回[object Null]。\r\n\t\t\t\t- 数组：返回[object Array]。\r\n\t\t\t\t- arguments 对象：返回[object Arguments]。\r\n\t\t\t\t- 函数：返回[object Function]。\r\n\t\t\t\t- Error 对象：返回[object Error]。\r\n\t\t\t\t- Date 对象：返回[object Date]。\r\n\t\t\t\t- RegExp 对象：返回[object RegExp]。\r\n\t\t\t\t- 其他对象：返回[object Object]。\r\n\r\n\t- Object.prototype.toLocaleString()：返回当前对象对应的本地字符串形式。\r\n\r\n\t\t- Array.prototype.toLocaleString()\r\n\t\t- Number.prototype.toLocaleString()\r\n\t\t- Date.prototype.toLocaleString()\r\n\r\n\t- Object.prototype.hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。\r\n\r\n\t\t- Object.prototype.hasOwnProperty方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。\r\n\t- Object.prototype.isPrototypeOf()：判断当前对象是否为另一个对象的原型。\r\n\t- Object.prototype.propertyIsEnumerable()：判断某个属性是否可枚举。\r\n\r\n### Array 对象\r\n\r\n- 作为构造函数\r\n\r\n\t- Array构造函数有一个很大的缺陷，就是不同的参数，会导致它的行为不一致。\r\n\r\n\t- 不建议使用它生成新数组，直接使用数组字面量是更好的做法。\r\n\r\n\t\t- var arr = new Array(1, 2); // bad\r\n\t\t- var arr = [1, 2]; // good\r\n\r\n- 静态方法\r\n\r\n\t- Array.isArray()\r\n\r\n\t\t- Array.isArray方法返回一个布尔值，表示参数是否为数组。它可以弥补typeof运算符的不足\r\n- 实例方法\r\n\r\n\t- valueOf()，toString()\r\n\t- push()，pop()\r\n\r\n\t\t- push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。\r\n\r\n\t\t- pop方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组\r\n\r\n\t\t- 对空数组使用pop方法，不会报错，而是返回undefined。\r\n\r\n\t\t- push和pop结合使用，就构成了“后进先出”的栈结构（stack）。\r\n\r\n\t- shift()，unshift()\r\n\r\n\t\t- shift方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。\r\n\r\n\t\t- shift方法可以遍历并清空一个数组。\r\n\r\n\t\t- push和shift结合使用，就构成了“先进先出”的队列结构（queue）。\r\n\t\t- unshift方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。\r\n\r\n\t- join()\r\n\r\n\t\t- join方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。\r\n\r\n\t\t- 如果数组成员是undefined或null或空位，会被转成空字符串。\r\n\r\n\t\t- 通过call方法，这个方法也可以用于字符串或类似数组的对象。\r\n\r\n\t- concat()\r\n\r\n\t\t- concat方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。\r\n\r\n\t\t- 除了数组作为参数，concat也接受其他类型的值作为参数，添加到目标数组尾部。\r\n\r\n\t\t- 如果数组成员包括对象，concat方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是新数组拷贝的是对象的引用。\r\n\r\n\t- reverse()\r\n\r\n\t\t- reverse方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。\r\n\t- slice()\r\n\r\n\t\t- slice方法用于提取目标数组的一部分，返回一个新数组，原数组不变。\r\n\t\t- 它的第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。\r\n\r\n\t\t- 如果slice方法的参数是负数，则表示倒数计算的位置。\r\n\r\n\t\t- slice方法的一个重要应用，是将类似数组的对象转为真正的数组。\r\n\r\n\t- splice()\r\n\r\n\t\t- splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。\r\n\t\t- splice的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。\r\n\r\n\t\t\t- arr.splice(start, count, addElement1, addElement2, ...);\r\n\t\t- 起始位置如果是负数，就表示从倒数位置开始删除。\r\n\t\t- 如果只是单纯地插入元素，splice方法的第二个参数可以设为0。\r\n\r\n\t\t- 如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。\r\n\r\n\t- sort()\r\n\r\n\t\t- sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。\r\n\t\t- sort方法不是按照大小排序，而是按照字典顺序。也就是说，数值会被先转成字符串，再按照字典顺序进行比较，所以101排在11的前面。\r\n\r\n\t\t- 如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数。\r\n\r\n\t- map()\r\n\r\n\t\t- map方法对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。\r\n\r\n\t\t- map方法接受一个函数作为参数。该函数调用时，map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。\r\n\r\n\t\t- map方法不仅可以用于数组，还可以用于字符串，用来遍历字符串的每个字符。但是，不能直接使用，而要通过函数的call方法间接使用，或者先将字符串转为数组，然后使用。\r\n\r\n\t\t- map方法还可以接受第二个参数，表示回调函数执行时this所指向的对象。\r\n\r\n\t\t- 如果数组有空位，map方法的回调函数在这个位置不会执行，不会跳过undefined和null，但是会跳过数组的空位。\r\n\r\n\t- forEach()\r\n\r\n\t\t- forEach方法与map方法很相似，也是遍历数组的所有成员，执行某种操作，但是forEach方法一般不返回值，只用来操作数据。如果需要有返回值，一般使用map方法。\r\n\t\t- forEach方法的参数与map方法一致，也是一个函数，数组的所有成员会依次执行该函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。\r\n\r\n\t\t- forEach方法也可以接受第二个参数，用来绑定回调函数的this关键字。\r\n\r\n\t\t- 注意，forEach方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用for循环。\r\n\t\t- forEach方法不会跳过undefined和null，但会跳过空位。\r\n\t\t- forEach方法也可以用于类似数组的对象和字符串。\r\n\r\n\t- filter()\r\n\r\n\t\t- filter方法的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。\r\n\r\n\t\t- filter方法的参数函数可以接受三个参数，第一个参数是当前数组成员的值，这是必需的，后两个参数是可选的，分别是当前数组成员的位置和整个数组。\r\n\r\n\t\t- filter方法还可以接受第二个参数，指定测试函数所在的上下文对象（即this对象）。\r\n\r\n\t- some()，every()\r\n\r\n\t\t- 这两个方法类似“断言”（assert），用来判断数组成员是否符合某种条件。\r\n\t\t- 它们接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。\r\n\t\t- some()\r\n\r\n\t\t\t- some方法是只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。\r\n\r\n\t\t- every()\r\n\r\n\t\t\t- every方法则是所有数组成员的返回值都是true，才返回true，否则false。\r\n\r\n\t\t- 注意，对于空数组，some方法返回false，every方法返回true，回调函数都不会执行。\r\n\t\t- some和every方法还可以接受第二个参数，用来绑定函数中的this关键字。\r\n\r\n\t- reduce()，reduceRight()\r\n\r\n\t\t- 定义\r\n\r\n\t\t\t- reduce方法和reduceRight方法依次处理数组的每个成员，最终累计为一个值。\r\n\r\n\t\t- 差别\r\n\r\n\t\t\t- 它们的差别是，reduce是从左到右处理（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。\r\n\r\n\t\t- 参数\r\n\r\n\t\t\t- 这两个方法的第一个参数都是一个函数。该函数接受以下四个参数。这四个参数之中，只有前两个是必须的，后两个则是可选的。\r\n\r\n\t\t\t\t- 累积变量，默认为数组的第一个成员\r\n\t\t\t\t- 当前变量，默认为数组的第二个成员\r\n\t\t\t\t- 当前位置（从0开始）\r\n\t\t\t\t- 原数组\r\n\r\n\t\t- 示例\r\n\r\n\t\t\t- 求数组成员之和。\r\n\r\n\t\t\t- 利用reduce方法，可以写一个数组求和的sum方法。\r\n\r\n\t\t- 如果要对累积变量指定初值，可以把它放在reduce方法和reduceRight方法的第二个参数。第二个参数相当于设定了默认值，处理空数组时尤其有用。\r\n\r\n\t\t- 由于reduce方法依次处理每个元素，所以实际上还可以用它来搜索某个元素。比如，下面代码是找出长度最长的数组元素。\r\n\r\n\t- indexOf()，lastIndexOf()\r\n\r\n\t\t- indexOf()\r\n\r\n\t\t\t- indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。\r\n\r\n\t\t\t- indexOf方法还可以接受第二个参数，表示搜索的开始位置。\r\n\r\n\t\t- lastIndexOf()\r\n\r\n\t\t\t- lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。\r\n\r\n\t\t- 注意，如果数组中包含NaN，这两个方法不适用，即无法确定数组成员是否包含NaN。\r\n\r\n\t- 链式使用\r\n\r\n\t\t- 上面这些数组方法之中，有不少返回的还是数组，所以可以链式使用。\r\n### 包装对象\r\n\r\n- 包装对象的定义\r\n\r\n\t- 有人说，JavaScript 语言“一切皆对象”。这是因为数组和函数本质上都是对象，就连三种原始类型的值——数值、字符串、布尔值——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”。\r\n\r\n\t- 所谓“包装对象”，就是分别与数值、字符串、布尔值相对应的Number、String、Boolean三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。\r\n\t- 这三个对象作为构造函数使用（带有new）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有new），可以将任意类型的值，转为原始类型的值。\r\n\r\n- 包装对象实例的方法\r\n\r\n\t- 包装对象实例可以使用Object对象提供的原生方法，主要是valueOf方法和toString方法。\r\n\r\n\t\t- valueOf()\r\n\r\n\t\t- toString()\r\n\r\n- 原始类型的自动转换\r\n\r\n\t- 定义\r\n\r\n\t\t- 原始类型的值，可以自动当作对象调用，即调用各种对象的方法和参数。这时，JavaScript引擎会自动将原始类型的值转为包装对象，在使用后立刻销毁。\r\n\r\n\t\t\t- 上面代码中，abc是一个字符串，本身不是对象，不能调用length属性。JavaScript引擎自动将其转为包装对象，在这个对象上调用length属性。调用结束后，这个临时对象就会被销毁。这就叫原始类型的自动转换。\r\n\r\n\t- 内部属性[[PrimitiveValue]]\r\n\r\n\t\t- 上面代码中，字符串abc的包装对象有每个位置的值、有length属性、还有一个内部属性[[PrimitiveValue]]保存字符串的原始值。这个[[PrimitiveValue]]内部属性，外部是无法调用，仅供ValueOf或toString这样的方法内部调用。\r\n\r\n\t- 这个临时对象是只读的，无法修改。所以，字符串无法添加新属性。\r\n\r\n\t- 另一方面，调用结束后，临时对象会自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。如果想要为字符串添加属性，只有在它的原型对象String.prototype上定义\r\n\t- 这种原始类型值可以直接调用的方法还有很多（详见后文对各包装对象的介绍），除了前面介绍过的valueOf和toString方法，还包括三个包装对象各自定义在原型上的方法。。\r\n\r\n- 自定义方法\r\n\r\n\t- 三种包装对象还可以在原型上添加自定义方法和属性，供原始类型的值直接调用。\r\n\r\n- 注意\r\n\r\n\t- 注意，false对应的包装对象实例，布尔运算结果也是true。是因为false对应的包装对象实例是一个对象，进行逻辑运算时，被自动转化成布尔值true（因为所有对象对应的布尔值都是true）\r\n\r\n### Number对象\r\n\r\n- 概述\r\n\r\n\t- Number对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。\r\n\t- 作为构造函数时，它用于生成值为数值的对象。\r\n\r\n\t\t- var n = new Number(1);\r\ntypeof n // \"object\"\r\n\r\n\t- 作为工具函数时，它可以将任何类型的值转为数值。\r\n\r\n\t\t- Number(true) // 1\r\n\r\n- Number对象的属性\r\n\r\n\t- Number对象拥有以下一些属性。\r\n\r\n\t\t- Number.POSITIVE_INFINITY：正的无限，指向Infinity。\r\n\t\t- Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。\r\n\t\t- Number.NaN：表示非数值，指向NaN。\r\n\t\t- Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。\r\n\t\t- Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。\r\n\t\t- Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。\r\n\t\t- Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。\r\n\r\n- Number 对象实例的方法\r\n\r\n\t- Number.prototype.toString()\r\n\r\n\t\t- 将一个数值转为字符串形式。toString方法可以接受一个参数，表示输出的进制。\r\n\r\n\t- Number.prototype.toFixed()\r\n\r\n\t\t- toFixed方法用于将一个数转为指定位数的小数，返回这个小数对应的字符串。\r\n\r\n\t- Number.prototype.toExponential()\r\n\r\n\t\t- toExponential方法用于将一个数转为科学计数法形式。\r\n\r\n\t- Number.prototype.toPrecision()\r\n\r\n\t\t- toPrecision方法用于将一个数转为指定位数的有效数字。\r\n\r\n- 自定义方法\r\n\r\n\t- 与其他对象一样，Number.prototype对象上面可以自定义方法，被Number的实例继承。\r\n### String对象\r\n\r\n- 概述\r\n\r\n\t- \r\nString对象是JavaScript原生提供的三个包装对象之一，用来生成字符串的包装对象。\r\n\t- 实际上，字符串的包装对象是一个类似数组的对象（即很像数组，但是实质上不是数组）。\r\n\t- 当做构造函数使用\r\n\t- 还可以当作工具方法使用，将任意类型的值转为字符串。\r\n\r\n- 静态方法\r\n\r\n\t- \r\nString.fromCharCode()\r\n\r\n\t\t- 该方法的参数是一系列Unicode码点，返回对应的字符串。\r\n\t\t- 注意，该方法不支持Unicode码点大于0xFFFF的字符，即传入的参数不能大于0xFFFF。\r\n\r\n- 实例对象的属性和方法\r\n\r\n\t- length属性返回字符串的长度。\r\n\r\n\t\t- 'abc'.length // 3\r\n\r\n\t- charAt()\r\n\r\n\t\t- charAt方法返回指定位置的字符，参数是从0开始编号的位置。\r\n\r\n\t\t- 这个方法完全可以用数组下标替代。\r\n\t\t- 如果参数为负数，或大于等于字符串的长度，charAt返回空字符串。\r\n\r\n\t- charCodeAt()\r\n\r\n\t\t- charCodeAt方法返回给定位置字符的Unicode码点（十进制表示），相当于String.fromCharCode()的逆操作。\r\n\r\n\t- concat()\r\n\r\n\t\t- concat方法用于连接两个字符串，返回一个新字符串，不改变原字符串。\r\n\r\n\t\t- 该方法可以接受多个参数。\r\n\r\n\t\t\t- 'a'.concat('b', 'c') // \"abc\"\r\n\r\n\t\t- 如果参数不是字符串，concat方法会将其先转为字符串，然后再连接。\r\n\r\n\t- slice()\r\n\r\n\t\t- slice方法用于从原字符串取出子字符串并返回，不改变原字符串。\r\n\t\t- 它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。\r\n\r\n\t\t\t- 'JavaScript'.slice(0, 4) // \"Java\"\r\n\r\n\t\t- 如果省略第二个参数，则表示子字符串一直到原字符串结束。\r\n\r\n\t\t\t- 'JavaScript'.slice(4) // \"Script\"\r\n\r\n\t\t- 如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。\r\n\t\t- 如果第一个参数大于第二个参数，slice方法返回一个空字符串。\r\n\r\n\t- substring()\r\n\r\n\t\t- substring方法用于从原字符串取出子字符串并返回，不改变原字符串。它与slice作用相同，但有一些奇怪的规则，因此不建议使用这个方法，优先使用slice。\r\n\t\t- 如果第二个参数大于第一个参数，substring方法会自动更换两个参数的位置。\r\n\t\t- 如果参数是负数，substring方法会自动将负数转为0。\r\n\r\n\t- substr()\r\n\r\n\t\t- substr方法用于从原字符串取出子字符串并返回，不改变原字符串。\r\n\t\t- substr方法的第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。\r\n\t\t- 如果省略第二个参数，则表示子字符串一直到原字符串的结束。\r\n\t\t- 如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。\r\n\r\n\t- indexOf()，lastIndexOf()\r\n\r\n\t\t- 这两个方法用于确定一个字符串在另一个字符串中的位置，都返回一个整数，表示匹配开始的位置。如果返回-1，就表示不匹配。两者的区别在于，indexOf从字符串头部开始匹配，lastIndexOf从尾部开始匹配。\r\n\r\n\t\t- 它们还可以接受第二个参数，对于indexOf方法，第二个参数表示从该位置开始向后匹配；对于lastIndexOf，第二个参数表示从该位置起向前匹配。\r\n\r\n\t- trim()\r\n\r\n\t\t- trim方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。该方法去除的不仅是空格，还包括制表符（\\t、\\v）、换行符（\\n）和回车符（\\r）。\r\n\r\n\t\t\t- '\\r\\nabc \\t'.trim() // 'abc'\r\n\r\n\t- toLowerCase()，toUpperCase()\r\n\r\n\t\t- \r\ntoLowerCase方法用于将一个字符串全部转为小写，toUpperCase则是全部转为大写。它们都返回一个新字符串，不改变原字符串。\r\n\t\t- 这个方法也可以将布尔值或数组转为大写字符串，但是需要通过call方法使用。\r\n\r\n\t- localeCompare()\r\n\r\n\t\t- localeCompare方法用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。\r\n\r\n\t- match()\r\n\r\n\t\t- match方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。\r\n\r\n\t\t- 返回数组还有index属性和input属性，分别表示匹配字符串开始的位置和原始字符串。\r\n\r\n\t\t- match方法还可以使用正则表达式作为参数\r\n\r\n\t- search()\r\n\r\n\t\t- search方法的用法等同于match，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。\r\n\r\n\t\t\t- 'cat, bat, sat, fat'.search('at') // 1\r\n\r\n\t\t- search方法还可以使用正则表达式作为参数\r\n\r\n\t- replace()\r\n\r\n\t\t- replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。\r\n\t- split()\r\n\r\n\t\t- split方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。\r\n\r\n\t\t\t- 'a|b|c'.split('|') // [\"a\", \"b\", \"c\"]\r\n\r\n\t\t- 如果分割规则为空字符串，则返回数组的成员是原字符串的每一个字符。\r\n\r\n\t\t\t- 'a|b|c'.split('') // [\"a\", \"|\", \"b\", \"|\", \"c\"]\r\n\r\n\t\t- 如果省略参数，则返回数组的唯一成员就是原字符串。\r\n\r\n\t\t- 如果满足分割规则的两个部分紧邻着（即中间没有其他字符），则返回数组之中会有一个空字符串。\r\n\r\n\t\t- split方法还可以接受第二个参数，限定返回数组的最大成员数。\r\n\r\n### Math对象\r\n\r\n- 概述\r\n\r\n\t- Math是JavaScript的内置对象，提供一系列数学常数和数学方法。该对象不是构造函数，不能生成实例，所有的属性和方法都必须在Math对象上调用。\r\n\r\n- 属性\r\n\r\n\t- Math.E：常数e。\r\n\t- Math.LN2：2的自然对数。\r\n\t- Math.LN10：10的自然对数。\r\n\t- Math.LOG2E：以2为底的e的对数。\r\n\t- Math.LOG10E：以10为底的e的对数。\r\n\t- Math.PI：常数Pi。\r\n\t- Math.SQRT1_2：0.5的平方根。\r\n\t- Math.SQRT2：2的平方根。\r\n\r\n- 方法\r\n\r\n\t- Math.abs()：绝对值\r\n\r\n\t\t- Math.abs方法返回参数值的绝对值。\r\n\r\n\t- Math.ceil()：向上取整\r\n\r\n\t\t- Math.ceil方法接受一个参数，返回大于该参数的最小整数。\r\n\r\n\t- Math.floor()：向下取整\r\n\r\n\t\t- Math.floor方法接受一个参数，返回小于该参数的最大整数。\r\n\r\n\t- Math.max()：最大值\r\nMath.min()：最小值\r\n\r\n\t\t- Math.max方法和Math.min方法都可以接受多个参数，Math.max返回其中最大的参数，Math.min返回最小的参数。有趣的是, Math.min 不传参数返回 Infinity, Math.max 不传参数返回 -Infinity。\r\n\r\n\t- Math.pow()：指数运算\r\n\r\n\t\t- Math.pow方法返回以第一个参数为底数、第二个参数为幂的指数值。\r\n\r\n\t- Math.sqrt()：平方根\r\n\r\n\t\t- Math.sqrt方法返回参数值的平方根。如果参数是一个负值，则返回NaN。\r\n\r\n\t- Math.log()：自然对数\r\n\r\n\t\t- Math.log方法返回以e为底的自然对数值。\r\n\r\n\t- Math.exp()：e的指数\r\n\r\n\t\t- Math.exp方法返回常数e的参数次方。\r\n\r\n\t- Math.round()：四舍五入\r\n\r\n\t\t- Math.round方法用于四舍五入。\r\n\t\t- 注意，它对负数的处理（主要是对0.5的处理）。\r\n\r\n\t- Math.random()：随机数\r\n\r\n\t\t- Math.random()返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。\r\n\r\n\t- 三角函数方法\r\n\r\n\t\t- Math.sin()：返回参数的正弦\r\n\t\t- Math.cos()：返回参数的余弦\r\n\t\t- Math.tan()：返回参数的正切\r\n\t\t- Math.asin()：返回参数的反正弦（弧度值）\r\n\t\t- Math.acos()：返回参数的反余弦（弧度值）\r\n\t\t- Math.atan()：返回参数的反正切（弧度值）\r\n\r\n### Date对象\r\n\r\n- 概述\r\n\r\n\t- \r\nDate对象是JavaScript提供的日期和时间的操作接口。它可以表示的时间范围是，1970年1月1日00:00:00前后的各1亿天（单位为毫秒）。\r\n\t- Date对象可以作为普通函数直接调用，无论有没有参数，总是返回一个代表当前时间的字符串。\r\n\r\n- 作为构造函数使用\r\n\r\n\t- 不传参数\r\n\r\n\t\t- 对它使用new命令，会返回一个Date对象的实例。如果不加参数，生成的就是代表当前时间的对象。\r\n\t- 传参数\r\n\r\n\t\t- （1）new Date(milliseconds)\r\n\r\n\t\t\t- Date对象接受从1970年1月1日00:00:00 UTC开始计算的毫秒数作为参数。这意味着如果将Unix时间戳（单位为秒）作为参数，必须将Unix时间戳乘以1000。\r\n\r\n\t\t- （2）new Date(datestring)\r\n\r\n\t\t\t- Date对象还接受一个日期字符串作为参数，返回所对应的时间。所有可以被Date.parse()方法解析的日期字符串，都可以当作Date对象的参数。\r\n\t\t\t- 注意\r\n\r\n\t\t\t\t- 在ES5之中，如果日期采用连词线（-）格式分隔，且具有前导0（即YYYY-MM-DD），JavaScript会认为这是一个ISO格式的日期字符串，导致返回的时间是以UTC时区计算的。\r\n\r\n\t\t- （3）new Date(year, month [, day, hours, minutes, seconds, ms])\r\n\r\n\t\t\t- Date对象还可以接受多个整数作为参数，依次表示年、月、日、小时、分钟、秒和毫秒。如果采用这种格式，最少需要提供两个参数（年和月），其他参数都是可选的，默认等于0。因为如果只使用“年”这一个参数，Date对象会将其解释为毫秒数。\r\n\r\n- 日期的运算\r\n\r\n\t- 类型转换时，Date对象的实例如果转为数值，则等于对应的毫秒数；如果转为字符串，则等于对应的日期字符串。所以，两个日期对象进行减法运算，返回的就是它们间隔的毫秒数；进行加法运算，返回的就是连接后的两个字符串。\r\n\r\n- Date对象的静态方法\r\n\r\n\t- Date.now()\r\n\r\n\t\t- Date.now方法返回当前距离1970年1月1日 00:00:00 UTC的毫秒数（Unix时间戳乘以1000）。\r\n\r\n\t- Date.parse()\r\n\r\n\t\t- Date.parse方法用来解析日期字符串，返回距离1970年1月1日 00:00:00的毫秒数。\r\n\t\t- 其解析的参数最好为YYYY-MM-DDTHH:mm:ss.sssZ格式\r\n\t\t- 如果解析失败，返回NaN。\r\n\r\n\t- Date.UTC()\r\n\r\n\t\t- 默认情况下，Date对象返回的都是当前时区的时间。Date.UTC方法可以返回UTC时间（世界标准时间）。该方法接受年、月、日等变量作为参数，返回当前距离1970年1月1日 00:00:00 UTC的毫秒数。\r\n\r\n- Date实例对象的方法\r\n\r\n\t- to类：从Date对象返回一个字符串，表示指定的时间。\r\n\t- get类：获取Date对象的日期和时间。\r\n\r\n\t- set类：设置Date对象的日期和时间。\r\n\r\n### RegExp对象\r\n\r\n- 概述\r\n\r\n\t- 新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束。\r\n\r\n\t- 另一种是使用 RegExp 构造函数。\r\n\r\n\t- 它们的主要区别是：第一种方法在编译时新建正则表达式，第二种方法在运行时新建正则表达式。\r\n\t- RegExp 构造函数还可以接受第二个参数，表示修饰符\r\n\r\n\t- 正则对象生成以后，有两种使用方式：\r\n\r\n\t\t- 正则对象的方法：将字符串作为参数，比如regex.test(string)。\r\n\t\t- 字符串对象的方法：将正则对象作为参数，比如string.match(regex)。\r\n\r\n- 正则对象的属性和方法\r\n\r\n\t- 属性\r\n\r\n\t\t- 正则对象的属性分成两类。\r\n\t\t- 一类是修饰符相关，返回一个布尔值，表示对应的修饰符是否设置。\r\n\r\n\t\t\t- ignoreCase：返回一个布尔值，表示是否设置了i修饰符，该属性只读。\r\n\t\t\t- global：返回一个布尔值，表示是否设置了g修饰符，该属性只读。\r\n\t\t\t- multiline：返回一个布尔值，表示是否设置了m修饰符，该属性只读。\r\n\r\n\t\t- 另一类是与修饰符无关的属性，主要是下面两个。\r\n\r\n\t\t\t- lastIndex：返回下一次开始搜索的位置。该属性可读写，但是只在设置了g修饰符时有意义。\r\n\t\t\t- source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。\r\n\r\n\t- test()\r\n\r\n\t\t- 正则对象的test方法返回一个布尔值，表示当前模式是否能匹配参数字符串。\r\n\r\n\t\t- 如果正则表达式带有g修饰符，则每一次test方法都从上一次结束的位置开始向后匹配。\r\n\r\n\t\t- 如果正则模式是一个空字符串，则匹配所有字符串。\r\n\r\n\t- exec()\r\n\r\n\t\t- 正则对象的exec方法，可以返回匹配结果。如果发现匹配，就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null。\r\n\r\n\t\t- 圆括号，组匹配\r\n\r\n\t\t\t- 如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的length属性等于组匹配的数量再加1。\r\n\r\n\t\t- exec方法的返回数组还包含以下两个属性：\r\n\r\n\t\t\t- input：整个原字符串。\r\n\t\t\t- index：整个模式匹配成功的开始位置（从0开始计数）\r\n\r\n\t\t- 如果正则表达式加上g修饰符，则可以使用多次exec方法，下一次搜索的位置从上一次匹配成功结束的位置开始。\r\n\r\n\t\t- 利用g修饰符允许多次匹配的特点，可以用一个循环完成全部匹配。\r\n\r\n\t\t- 正则对象的lastIndex属性不仅可读，还可写。一旦手动设置了lastIndex的值，就会从指定位置开始匹配。但是，这只在设置了g修饰符的情况下，才会有效。\r\n\r\n\t\t- 如果正则对象是一个空字符串，则exec方法会匹配成功，但返回的也是空字符串。\r\n\r\n- 字符串对象的方法\r\n\r\n\t- 字符串对象的方法之中，有4种与正则对象有关。\r\n\r\n\t\t- match()：返回一个数组，成员是所有匹配的子字符串。\r\n\t\t- search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。\r\n\t\t- replace()：按照给定的正则表达式进行替换，返回替换后的字符串。\r\n\t\t- split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。\r\n\r\n\t- String.prototype.match()\r\n\r\n\t\t- 字符串对象的match方法对字符串进行正则匹配，返回匹配结果。\r\n\r\n\t\t- 如果正则表达式带有g修饰符，则该方法与正则对象的exec方法行为不同，会一次性返回所有匹配成功的结果。\r\n\r\n\t- String.prototype.search()\r\n\r\n\t\t- 字符串对象的search方法，返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1。\r\n\r\n\t\t- 该方法会忽略g修饰符。\r\n\r\n\t- String.prototype.replace()\r\n\r\n\t\t- 字符串对象的replace方法可以替换匹配的值。它接受两个参数，第一个是搜索模式，第二个是替换的内容。\r\n\r\n\t\t\t- str.replace(search, replacement)\r\n\r\n\t\t- 搜索模式如果不加g修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。\r\n\r\n\t\t- replace方法的一个应用，就是消除字符串首尾两端的空格。\r\n\r\n\t\t- 参数\r\n\r\n\t\t\t- replace方法的第二个参数可以使用美元符号$，用来指代所替换的内容。\r\n\r\n\t\t\t\t- $& 指代匹配的子字符串。\r\n\t\t\t\t- $` 指代匹配结果前面的文本。\r\n\t\t\t\t- $' 指代匹配结果后面的文本。\r\n\t\t\t\t- $n 指代匹配成功的第n组内容，n是从1开始的自然数。\r\n\t\t\t\t- $$ 指代美元符号$。\r\n\r\n\t\t\t- replace方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值。\r\n\r\n\t- String.prototype.split()\r\n\r\n\t\t- 字符串对象的split方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。\r\n\r\n\t\t\t- str.split(separator, [limit])\r\n\r\n\t\t- 该方法接受两个参数，第一个参数是分隔规则，第二个参数是返回数组的最大成员数。\r\n\r\n- 匹配规则\r\n\r\n\t- 字面量字符和元字符\r\n\r\n\t\t- 大部分字符在正则表达式中，就是字面的含义，比如/a/匹配a，/b/匹配b。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的a和b），那么它们就叫做“字面量字符”\r\n\t\t- 除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”（metacharacters），主要有以下几个。\r\n\r\n\t\t\t- （1）点字符（.)\r\n\r\n\t\t\t\t- 点字符（.）匹配除回车（\\r）、换行(\\n) 、行分隔符（\\u2028）和段分隔符（\\u2029）以外的所有字符。\r\n\t\t\t- （2）位置字符\r\n\r\n\t\t\t\t- 位置字符用来提示字符所处的位置，主要有两个字符。\r\n\r\n\t\t\t\t\t- ^ 表示字符串的开始位置\r\n\t\t\t\t\t- $ 表示字符串的结束位置\r\n\r\n\t\t\t- （3）选择符（|）\r\n\r\n\t\t\t\t- 竖线符号（|）在正则表达式中表示“或关系”（OR），即cat|dog表示匹配cat或dog。\r\n\r\n\t\t\t\t- 多个选择符可以联合使用。\r\n\t\t\t\t- 选择符会包括它前后的多个字符，比如/ab|cd/指的是匹配ab或者cd，而不是指匹配b或者c。如果想修改这个行为，可以使用圆括号。\r\n\r\n\t\t\t- 其他的元字符还包括\\\\、\\*、+、?、()、[]、{}等，将在下文解释。\r\n\r\n\t- 转义符\r\n\r\n\t\t- 正则表达式中那些有特殊含义的字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配加号，就要写成\\+。\r\n\t\t- 正则模式中，需要用斜杠转义的，一共有12个字符：^、.、[、$、(、)、|、*、+、?、{和\\\\。需要特别注意的是，如果使用RegExp方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。\r\n\r\n\t- 字符类\r\n\r\n\t\t- 定义\r\n\r\n\t\t\t- 字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[xyz] 表示x、y、z之中任选一个匹配。\r\n\r\n\t\t- 有两个字符在字符类中有特殊含义。\r\n\r\n\t\t\t- （1）脱字符（^）\r\n\r\n\t\t\t\t- 如果方括号内的第一个字符是[^]，则表示除了字符类之中的字符，其他字符都可以匹配。比如，[^xyz]表示除了x、y、z之外都可以匹配。\r\n\t\t\t\t- 如果方括号内没有其他字符，即只有[^]，就表示匹配一切字符，其中包括换行符，而点号（.）是不包括换行符的。\r\n\t\t\t\t- 注意，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。\r\n\r\n\t\t\t- （2）连字符（-）\r\n\r\n\t\t\t\t- 某些情况下，对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。比如，[abc]可以写成[a-c]，[0123456789]可以写成[0-9]，同理[A-Z]表示26个大写字母。\r\n\t- 预定义模式\r\n\r\n\t\t- 预定义模式指的是某些常见模式的简写方式。\r\n\r\n\t\t\t- \\d 匹配0-9之间的任一数字，相当于[0-9]。\r\n\t\t\t- \\D 匹配所有0-9以外的字符，相当于[^0-9]。\r\n\t\t\t- \\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。\r\n\t\t\t- \\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。\r\n\t\t\t- \\s 匹配空格（包括制表符、空格符、断行符等），相等于[\\t\\r\\n\\v\\f]。\r\n\t\t\t- \\S 匹配非空格的字符，相当于[^\\t\\r\\n\\v\\f]。\r\n\t\t\t- \\b 匹配词的边界。\r\n\t\t\t- \\B 匹配非词边界，即在词的内部。\r\n\r\n\t- 重复类\r\n\r\n\t\t- 模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。\r\n\t- 量词符\r\n\r\n\t\t- 量词符用来设定某个模式出现的次数。\r\n\r\n\t\t\t- ? 问号表示某个模式出现0次或1次，等同于{0, 1}。\r\n\t\t\t- * 星号表示某个模式出现0次或多次，等同于{0,}。\r\n\t\t\t- + 加号表示某个模式出现1次或多次，等同于{1,}。\r\n\r\n\t- 贪婪模式\r\n\r\n\t\t- 定义\r\n\r\n\t\t\t- 默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。\r\n\t\t- 如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。\r\n\r\n\t\t- 除了非贪婪模式的加号，还有非贪婪模式的星号（*）。\r\n\r\n\t\t\t- *?：表示某个模式出现0次或多次，匹配时采用非贪婪模式。\r\n\t\t\t- +?：表示某个模式出现1次或多次，匹配时采用非贪婪模式。\r\n\r\n\t- 修饰符\r\n\r\n\t\t- 修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。可以单个使用，也可以多个一起使用。\r\n\t\t- （1）g修饰符\r\n\r\n\t\t\t- 默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。g修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。\r\n\r\n\t\t- （2）i修饰符\r\n\r\n\t\t\t- 默认情况下，正则对象区分字母的大小写，加上i修饰符以后表示忽略大小写（ignorecase）。\r\n\r\n\t\t- （3）m修饰符\r\n\r\n\t\t\t- m修饰符表示多行模式（multiline），会修改^和$的行为。默认情况下（即不加m修饰符时），^和$匹配字符串的开始处和结尾处，加上m修饰符以后，^和$还会匹配行首和行尾，即^和$会识别换行符（\\n）。\r\n\r\n\t- 组匹配\r\n\r\n\t\t- （1）概述\r\n\r\n\t\t\t- \r\n正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。\r\n\t\t- 在正则表达式内部，可以用\\n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号。\r\n\t\t- （2）非捕获组\r\n\r\n\t\t\t- (?:x)称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。\r\n\t\t\t- 非捕获组的作用请考虑这样一个场景，假定需要匹配foo或者foofoo，正则表达式就应该写成/(foo){1, 2}/，但是这样会占用一个组匹配。这时，就可以使用非捕获组，将正则表达式改为/(?:foo){1, 2}/，它的作用与前一个正则是一样的，但是不会单独输出括号内部的内容。\r\n\r\n\t\t- （3）先行断言\r\n\r\n\t\t\t- x(?=y)称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成/\\d+(?=%)/。\r\n\r\n\t\t- （4）先行否定断言\r\n\r\n\t\t\t- x(?!y)称为先行否定断言（Negative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成/\\d+(?!%)/。\r\n\r\n### JSON对象\r\n\r\n- JSON.stringify()\r\n\r\n\t- 基本用法\r\n\r\n\t\t- JSON.stringify方法用于将一个值转为字符串。该字符串符合 JSON 格式，并且可以被JSON.parse方法还原。\r\n\t\t- 需要注意的是，对于原始类型的字符串，转换结果会带双引号。\r\n\t\t- 如果原始对象中，有一个成员的值是undefined、函数或 XML 对象，这个成员会被过滤。\r\n\t\t- 如果数组的成员是undefined、函数或 XML 对象，则这些值被转成null。\r\n\t\t- 正则对象会被转成空对象。\r\n\r\n\t- 第二个参数\r\n\r\n\t\t- JSON.stringify方法还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。这个类似“白名单”的数组，只对对象的属性有效，对数组无效。\r\n\r\n\t\t- 第二个参数还可以是一个函数，用来更改JSON.stringify的默认行为。\r\n\r\n\t- 第三个参数\r\n\r\n\t\t- JSON.stringify还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。\r\n\r\n\t- toJSON 方法\r\n\r\n\t\t- 如果对象有自定义的toJSON方法，那么JSON.stringify会使用这个方法的返回值作为参数，而忽略原对象的其他属性。\r\n\r\n- JSON.parse()\r\n\r\n\t- JSON.parse方法用于将JSON字符串转化成对象。\r\n\r\n\t- JSON.parse方法可以接受一个处理函数，用法与JSON.stringify方法类似。\r\n\r\n### console对象\r\n\r\n### 属性描述对象\r\n\r\n- 概述\r\n\r\n\t- JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为“属性描述对象”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。\r\n\t- 属性描述对象提供6个元属性。\r\n\r\n\t\t- （1）value\r\n\r\n\t\t\t- value是该属性的属性值，默认为undefined。\r\n\r\n\t\t- （2）writable\r\n\r\n\t\t\t- writable是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为true。\r\n\r\n\t\t- （3）enumerable\r\n\r\n\t\t  具体来说，如果一个属性的enumerable为false，下面三个操作不会取到该属性。\r\n\r\n\t\t  \r\n\r\n\t\t  for..in循环\r\n\r\n\t\t  Object.keys方法\r\n\r\n\t\t  JSON.stringify方法\r\n\r\n\t\t\t- enumerable是一个布尔值，表示该属性是否可遍历，默认为true。如果设为false，会使得某些操作（比如for...in循环、Object.keys()）跳过该属性。\r\n\r\n\t\t- （4）configurable\r\n\r\n\t\t\t- configurable是一个布尔值，表示可配置性，默认为true。如果设为false，将阻止某些操作改写该属性，比如无法删除该属性，也不得改变该属性的属性描述对象（value属性除外）。也就是说，configurable属性控制了属性描述对象的可写性。\r\n\r\n\t\t\t\t- 可配置性决定了目标属性是否可以被删除（delete）。\r\n\r\n\t\t- （5）get\r\n\r\n\t\t\t- get是一个函数，表示该属性的取值函数（getter），默认为undefined。\r\n\r\n\t\t- （6）set\r\n\r\n\t\t\t- set是一个函数，表示该属性的存值函数（setter），默认为undefined。\r\n\r\n- Object.getOwnPropertyDescriptor()\r\n\r\n\t- Object.getOwnPropertyDescriptor方法可以获取属性描述对象。它的第一个参数是一个对象，第二个参数是一个字符串，对应该对象的某个属性名。\r\n\t- 注意，Object.getOwnPropertyDescriptor方法只能用于对象自身的属性，不能用于继承的属性。\r\n\r\n- Object.getOwnPropertyNames()\r\n\r\n\t- Object.getOwnPropertyNames方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。\r\n- Object.defineProperty()，Object.defineProperties()\r\n\r\n\t- Object.defineProperty方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象，它的用法如下。\r\n\t- Object.defineProperty方法接受三个参数，依次如下。\r\n\r\n\t\t- 属性所在的对象\r\n\t\t- 属性名（它应该是一个字符串）\r\n\t\t- 属性描述对象\r\n\r\n\t- 如果属性已经存在，Object.defineProperty方法相当于更新该属性的属性描述对象。\r\n\t- 注意，一旦定义了取值函数get（或存值函数set），就不能将writable属性设为true，或者同时定义value属性，否则会报错。\r\n\r\n- Object.prototype.propertyIsEnumerable()\r\n\r\n\t- 实例对象的propertyIsEnumerable方法返回一个布尔值，用来判断某个属性是否可遍历。\r\n- 存取器\r\n\r\n\t- 定义\r\n\r\n\t\t- 除了直接定义以外，属性还可以用存取器（accessor）定义。其中，存值函数称为setter，使用属性描述对象的set属性；取值函数称为getter，使用属性描述对象的get属性。\r\n\r\n\t- 一旦对目标属性定义了存取器，那么存取的时候，都将执行对应的函数。利用这个功能，可以实现许多高级特性，比如某个属性禁止赋值。\r\n\r\n\t- JavaScript 还提供了存取器的另一种写法。\r\n\r\n\t- 注意，取值函数get不能接受参数，存值函数set只能接受一个参数（即属性的值）。\r\n\t- 存取器往往用于，属性的值依赖对象内部数据的场合。\r\n\r\n- 对象的拷贝\r\n- 控制对象状态\r\n\r\n\t- 概述\r\n\r\n\t\t- 有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供了三种冻结方法，最弱的一种是Object.preventExtensions，其次是Object.seal，最强的是Object.freeze。\r\n\r\n\t- Object.preventExtensions()\r\n\r\n\t\t- Object.preventExtensions方法可以使得一个对象无法再添加新的属性。\r\n\r\n\t\t- Object.isExtensible()\r\n\r\n\t\t\t- Object.isExtensible方法用于检查一个对象是否使用了Object.preventExtensions方法。也就是说，检查是否可以为一个对象添加属性。\r\n\r\n\t- Object.seal()\r\n\r\n\t\t- Object.seal方法使得一个对象既无法添加新属性，也无法删除旧属性。Object.seal只是禁止新增或删除属性，并不影响修改某个属性的值。\r\n\r\n\t\t- Object.isSealed()\r\n\r\n\t\t\t- Object.isSealed方法用于检查一个对象是否使用了Object.seal方法。\r\n\r\n\t- Object.freeze()\r\n\r\n\t\t- Object.freeze方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。\r\n\r\n\t\t- Object.isFrozen()\r\n\r\n\t\t\t- Object.isFrozen方法用于检查一个对象是否使用了Object.freeze方法。\r\n\r\n\t- 局限性\r\n\r\n\t\t- 上面的三个方法锁定对象的可写性有一个漏洞：可以通过改变原型对象，来为对象增加属性。\r\n\r\n\t\t- 另外一个局限是，如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容。\r\n\r\n## 阮一峰·JS面向对 象编程\r\n\r\n### 构造函数与 new 命令\r\n\r\n- 对象是什么\r\n\r\n\t- （1）对象是单个实物的抽象。\r\n\t- （2）对象是一个容器，封装了属性（property）和方法（method）。\r\n\r\n- 构造函数\r\n\r\n\t- 典型的面向对象编程语言（比如 C++ 和 Java），存在“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。\r\n\t- JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成对象的函数。它提供模板，描述对象的基本结构。一个构造函数，可以生成多个对象，这些对象都有相同的结构。\r\n\t- 构造函数的特点有两个。\r\n\r\n\t\t- 函数体内部使用了this关键字，代表了所要生成的对象实例。\r\n\t\t- 生成对象的时候，必需用new命令，调用Vehicle函数。\r\n\r\n- new 命令\r\n\r\n\t- 基本用法\r\n\r\n\t\t- new命令的作用，就是执行构造函数，返回一个实例对象。\r\n\r\n\t\t\t- new命令执行时，构造函数内部的this，就代表了新生成的实例对象\r\n\r\n\t\t- 使用new命令时，根据需要，构造函数也可以接受参数。\r\n\r\n\t\t- new命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。\r\n\t\t- 如果忘了使用new命令，直接调用构造函数会发生什么事？\r\n\r\n\t\t\t- 这种情况下，构造函数就变成了普通函数，并不会生成实例对象。而且由于后面会说到的原因，this这时代表全局对象，将造成一些意想不到的结果。\r\n\r\n\t\t\t- 解决方法\r\n\r\n\t\t\t\t- 一个解决办法是，在构造函数内部使用严格模式，即第一行加上use strict。\r\n\t\t\t\t- 另一个解决办法，是在构造函数内部判断是否使用new命令，如果发现没有使用，则直接返回一个实例对象。\r\n\r\n\t- new 命令的原理\r\n\r\n\t\t- 概述\r\n\r\n\t\t\t- 使用new命令时，它后面的函数调用就不是正常的调用，而是依次执行下面的步骤。\r\n\t\t\t- （1）创建一个空对象，作为将要返回的对象实例\r\n\t\t\t- （2）将这个空对象的原型，指向构造函数的prototype属性\r\n\t\t\t- （3）将这个空对象赋值给函数内部的this关键字\r\n\t\t\t- （4）开始执行构造函数内部的代码\r\n\r\n\t\t- 原理\r\n\r\n\t\t\t- 构造函数内部，this指的是一个新生成的空对象，所有针对this的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即this对象），将其“构造”为需要的样子。\r\n\r\n\t\t- 构造函数有return的情况\r\n\r\n\t\t\t- 如果构造函数内部有return语句，而且return后面跟着一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。\r\n\r\n\t\t- 构造函数没有this而使用new来构造的情况\r\n\r\n\t\t\t- 如果对普通函数（内部没有this关键字的函数）使用new命令，则会返回一个空对象。\r\n\r\n\t\t- new命令简化的内部流程\r\n\r\n\t- new.target\r\n\r\n\t\t- 定义\r\n\r\n\t\t\t- 函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined。\r\n\r\n\t\t- 使用\r\n\r\n\t\t\t- 使用这个属性，可以判断函数调用的时候，是否使用new命令。\r\n\r\n\t- 使用 Object.create() 创建实例对象\r\n\r\n\t\t- 使用Object.create()方法，直接以某个实例对象作为模板，生成一个新的实例对象。\r\n### this 关键字\r\n\r\n- 使用场合\r\n\r\n\t- （1）全局环境\r\n\r\n\t\t- 在全局环境使用this，它指的就是顶层对象window。\r\n\r\n\t- （2）构造函数\r\n\r\n\t\t- 构造函数中的this，指的是实例对象。\r\n\r\n\t- （3）对象的方法\r\n\r\n\t\t- 当 A 对象的方法被赋予 B 对象，该方法中的this就从指向 A 对象变成了指向 B 对象。所以要特别小心，将某个对象的方法赋值给另一个对象，会改变this的指向。\r\n\r\n- 使用注意点\r\n\r\n\t- （1）避免多层 this\r\n\r\n\t\t- 一个解决方法是在第二层改用一个指向外层this的变量。\r\n\r\n\t\t- JavaScript 提供了严格模式，也可以硬性避免这种问题。在严格模式下，如果函数内部的this指向顶层对象，就会报错。\r\n\r\n\t- （2）避免数组处理方法中的this\r\n\r\n\t\t- 数组的map和foreach方法，允许提供一个函数作为参数。这个函数内部不应该使用this。\r\n\r\n\t\t\t- 解决这个问题的一种方法，是使用中间变量。\r\n\r\n\t\t\t- 另一种方法是将this当作foreach方法的第二个参数，固定它的运行环境。\r\n\r\n\t- （3）避免回调函数中的this\r\n\r\n\t\t- 回调函数中的this往往会改变指向，最好避免使用。\r\n\r\n- 绑定 this 的方法\r\n\r\n\t- 概述\r\n\r\n\t\t- JavaScript提供了call、apply、bind这三个方法，来切换/固定this的指向。\r\n\r\n\t- function.prototype.call()\r\n\r\n\t\t- 函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。\r\n\t\t- call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。\r\n\r\n\t\t- call的第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数。\r\n\t\t- 应用\r\n\r\n\t\t\t- call方法的一个应用是调用对象的原生方法。\r\n\r\n\t- function.prototype.apply()\r\n\r\n\t\t- apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。func.apply(thisValue, [arg1, arg2, ...])\r\n\t\t- 应用\r\n\r\n\t\t\t- （1）找出数组最大元素\r\n\r\n\t\t\t  var a = [10, 2, 4, 15, 9];\r\n\r\n\t\t\t  \r\n\r\n\t\t\t  Math.max.apply(null, a)\r\n\r\n\t\t\t  // 15\r\n\r\n\t\t\t\t- JavaScript不提供找出数组最大元素的函数。结合使用apply方法和Math.max方法，就可以返回数组的最大元素。\r\n\r\n\t\t\t- （2）将数组的空元素变为undefined\r\n\r\n\t\t\t  Array.apply(null, [\"a\",,\"b\"])\r\n\r\n\t\t\t  // [ 'a', undefined, 'b' ]\r\n\r\n\t\t\t\t- 空元素与undefined的差别在于，数组的forEach方法会跳过空元素，但是不会跳过undefined。因此，遍历内部元素的时候，会得到不同的结果。\r\n\r\n\t\t\t- （3）转换类似数组的对象\r\n\r\n\t\t\t  Array.prototype.slice.apply({0:1,length:1})\r\n\r\n\t\t\t  // [1]\r\n\r\n\t\t\t  \r\n\r\n\t\t\t  Array.prototype.slice.apply({0:1})\r\n\r\n\t\t\t  // []\r\n\r\n\t\t\t  \r\n\r\n\t\t\t  Array.prototype.slice.apply({0:1,length:2})\r\n\r\n\t\t\t  // [1, undefined]\r\n\r\n\t\t\t  \r\n\r\n\t\t\t  Array.prototype.slice.apply({length:1})\r\n\r\n\t\t\t  // [undefined]\r\n\r\n\t\t\t\t- 上面代码的apply方法的参数都是对象，但是返回结果都是数组，这个方法起作用的前提是，被处理的对象必须有length属性，以及相对应的数字键。\r\n\r\n\t\t\t- （4）绑定回调函数的对象\r\n\r\n\t\t\t  var o = new Object();\r\n\r\n\t\t\t  \r\n\r\n\t\t\t  o.f = function () {\r\n\r\n\t\t\t    console.log(this === o);\r\n\r\n\t\t\t  }\r\n\r\n\t\t\t  \r\n\r\n\t\t\t  var f = function (){\r\n\r\n\t\t\t    o.f.apply(o);\r\n\r\n\t\t\t    // 或者 o.f.call(o);\r\n\r\n\t\t\t  };\r\n\r\n\t\t\t  \r\n\r\n\t\t\t  $('#button').on('click', f);\r\n\r\n\t- function.prototype.bind()\r\n\r\n\t\t- 概述\r\n\r\n\t\t\t- bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。\r\n\r\n\t\t- bind比call方法和apply方法更进一步的是，除了绑定this以外，还可以绑定原函数的参数。\r\n\r\n\t\t- 如果bind方法的第一个参数是null或undefined，等于将this绑定到全局对象，函数运行时this指向顶层对象（在浏览器中为window）。\r\n\t\t- bind方法有一些使用注意点。\r\n\r\n\t\t\t- （1）每一次返回一个新函数\r\n\r\n\t\t\t\t- 监听事件的时候，不能写成下面这样。element.addEventListener('click', o.m.bind(o));\r\nclick事件绑定bind方法生成的一个匿名函数。这样会导致无法取消绑定\r\n\t\t\t\t- 正确的方法是写成下面这样：\r\n\r\n\t\t\t\t\t- var listener = o.m.bind(o);\r\nelement.addEventListener('click', listener);\r\n//  ...\r\nelement.removeEventListener('click', listener);\r\n\r\n\t\t\t- （2）结合回调函数使用\r\n\r\n\t\t\t\t- 回调函数是JavaScript最常用的模式之一，但是一个常见的错误是，将包含this的方法直接当作回调函数。\r\n\t\t\t\t- 还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。这些函数内部的this指向，很可能也会出错。\r\n\r\n\t\t\t- （3）结合call方法使用\r\n\r\n\t\t\t\t- 利用bind方法，可以改写一些JavaScript原生方法的使用形式，以数组的slice方法为例。\r\n\r\n\t\t\t- （4）与call，apply的区别\r\n\r\n\t\t\t\t- call和apply都是改变上下文中的this并立即执行这个函数，bind方法可以让对应的函数想什么时候调就什么时候调用，并且可以将参数在执行的时候添加，这是它们的区别\r\n\r\n### prototype 对象\r\n\r\n- 概述\r\n\r\n\t- 通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。\r\n\r\n- prototype 属性的作用\r\n\r\n\t- JavaScript 的每个对象都继承另一个对象，后者称为“原型”（prototype）对象\r\n\t- 原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在所有实例对象上。\r\n\r\n\t\t- 当实例对象本身没有某个属性或方法的时候，它会到构造函数的prototype属性指向的对象，去寻找该属性或方法。这就是原型对象的特殊之处。\r\n\t\t- 如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。\r\n\r\n\t- 总结\r\n\r\n\t\t- 原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象。\r\n\r\n- 原型链\r\n\r\n\t- 原型链的作用\r\n\r\n\t\t- “原型链”的作用是，读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的Object.prototype还是找不到，则返回undefined。\r\n\r\n\t- 对于性能的影响\r\n\r\n\t\t- 需要注意的是，一级级向上，在原型链寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。\r\n\r\n\t- 举例\r\n\r\n\t\t- 如果让某个函数的prototype属性指向一个数组，就意味着该函数可以当作数组的构造函数，因为它生成的实例对象都可以通过prototype属性调用数组方法。\r\n\r\n- constructor 属性\r\n\r\n\t- prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。\r\n\r\n\t- 由于constructor属性定义在prototype对象上面，意味着可以被所有实例对象继承。\r\n\t- 作用\r\n\r\n\t\t- constructor属性的作用，是分辨原型对象到底属于哪个构造函数。\r\n\r\n\t- 应用\r\n\r\n\t\t- 有了constructor属性，就可以从实例新建另一个实例。\r\n\r\n\t\t- 这使得在实例方法中，调用自身的构造函数成为可能。\r\n\r\n\t\t\t- Constr.prototype.createCopy = function () {\r\n  return new this.constructor();\r\n};\r\n\r\n\t- 注意\r\n\r\n\t\t- 修改原型对象时，一般要同时校正constructor属性的指向。\r\n\r\n- instanceof 运算符\r\n\r\n\t- instanceof运算符返回一个布尔值，表示某个对象是否为指定的构造函数的实例。\r\n\r\n\t- 它会检查右边构建函数的原型对象（prototype），是否在左边对象的原型链上。\r\n\r\n\t- 由于instanceof对整个原型链上的对象都有效，因此同一个实例对象，可能会对多个构造函数都返回true。\r\n\r\n\t- 注意\r\n\r\n\t\t- instanceof运算符在判断类型的值时只能用于对象，不适用原始类型的值。\r\n\t\t- 对于undefined和null，instanceOf运算符总是返回false。\r\n\r\n- Object.getPrototypeOf()\r\n\r\n\t- Object.getPrototypeOf方法返回一个对象的原型。这是获取原型对象的标准方法。\r\n\r\n- Object.setPrototypeOf()\r\n\r\n\t- Object.setPrototypeOf方法可以为现有对象设置原型，返回一个新对象。\r\n\t- Object.setPrototypeOf方法接受两个参数，第一个是现有对象，第二个是原型对象。\r\n\r\n- Object.create()\r\n\r\n\t- 由来\r\n\r\n\t\t- 生成实例对象的常用方法，就是使用new命令，让构造函数返回一个实例。但是很多时候，只能拿到一个实例对象，它可能根本不是由构建函数生成的，那么能不能从一个实例对象，生成另一个实例对象呢？\r\n\r\n\t- 概述\r\n\r\n\t\t- JavaScript 提供了Object.create方法，用来满足这种需求。该方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。该实例完全继承原型对象的属性。\r\n\r\n\t- 手动实现Object.create()\r\n\r\n\t\t\t- Object.create方法的实质是新建一个构造函数F，然后让F.prototype属性指向参数对象obj，最后返回一个F的实例，从而实现让该实例继承obj的属性。\r\n\r\n\t- 注意\r\n\r\n\t\t- 如果想要生成一个不继承任何属性（比如没有toString和valueOf方法）的对象，可以将Object.create的参数设为null。\r\n\r\n\t\t- 使用Object.create方法的时候，必须提供对象原型，即参数不能为空，或者不是对象，否则会报错。\r\n\t\t- Object.create方法生成的对象，继承了它的原型对象的构造函数。\r\n\r\n- Object.prototype.isPrototypeOf()\r\n\r\n\t- 对象实例的isPrototypeOf方法，用来判断一个对象是否是另一个对象的原型。\r\n\r\n\t- 只要某个对象处在原型链上，isPrototypeOf都返回true。\r\n\r\n- Object.prototype.__proto__\r\n\r\n\t- 概述\r\n\r\n\t\t- __proto__属性（前后各两个下划线）可以改写某个对象的原型对象。\r\n\r\n\t- 注意事项\r\n\r\n\t\t- 根据语言标准，__proto__属性只有浏览器才需要部署，其他环境可以没有这个属性，而且前后的两根下划线，表示它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用Object.getPrototypeof()（读取）和Object.setPrototypeOf()（设置），进行原型对象的读写操作。\r\n\r\n- 获取原型对象方法的比较\r\n\r\n\t- 获取实例对象obj的原型对象，有三种方法。\r\n\r\n\t\t- obj.__proto__\r\n\t\t- obj.constructor.prototype\r\n\t\t- Object.getPrototypeOf(obj)\r\n\r\n\t- 上面三种方法之中，前两种都不是很可靠。最新的ES6标准规定，__proto__属性只有浏览器才需要部署，其他环境可以不部署。而obj.constructor.prototype在手动改变原型对象时，可能会失效。\r\n\t- 推荐使用第三种Object.getPrototypeOf方法，获取原型对象。\r\n\r\n### Object 对象与继承\r\n\r\n- Object.getOwnPropertyNames()\r\n\r\n\t- 定义\r\n\r\n\t\t- Object.getOwnPropertyNames方法返回一个数组，成员是对象本身的所有属性的键名，不包含继承的属性键名。\r\n\r\n\t- 与Object.keys()对比\r\n\r\n\t\t- 对象本身的属性之中，有的是可以枚举的（enumerable），有的是不可以枚举的，Object.getOwnPropertyNames方法返回所有键名。只获取那些可以枚举的属性，使用Object.keys方法。\r\n\r\n- Object.prototype.hasOwnProperty()\r\n\r\n\t- 定义\r\n\r\n\t\t- 对象实例的hasOwnProperty方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上。\r\n\r\n\t- 特点\r\n\r\n\t\t- hasOwnProperty方法是JavaScript之中唯一一个处理对象属性时，不会遍历原型链的方法。\r\n\r\n- 对象的拷贝\r\n\r\n\t- 初步认识\r\n\r\n\t\t- 如果要拷贝一个对象，需要做到下面两件事情。\r\n\r\n\t\t\t- 确保拷贝后的对象，与原对象具有同样的prototype原型对象。\r\n\t\t\t- 确保拷贝后的对象，与原对象具有同样的属性。\r\n\r\n\t- ES5版本\r\n\r\n\t  function copyObject(orig) {\r\n\r\n\t  -  var copy = Object.create(Object.getPrototypeOf(orig));\r\n\r\n\t   -  copyOwnPropertiesFrom(copy, orig);\r\n\r\n\t   -  return copy;\r\n\r\n\t  }\r\n\r\n\t  \r\n\r\n\t  function copyOwnPropertiesFrom(target, source) {\r\n\r\n\t    Object\r\n\r\n\t    .getOwnPropertyNames(source)\r\n\r\n\t    .forEach(function(propKey) {\r\n\r\n\t      var desc = Object.getOwnPropertyDescriptor(source, propKey);\r\n\r\n\t      Object.defineProperty(target, propKey, desc);\r\n\r\n\t    });\r\n\r\n\t    return target;\r\n\r\n\t  }\r\n\r\n\t- 另一种更简单的写法，是利用 ES2017 才引入标准的Object.getOwnPropertyDescriptors方法。\r\n\r\n\t  function copyObject(orig) {\r\n\r\n\t    return Object.create(\r\n\r\n\t      Object.getPrototypeOf(orig),\r\n\r\n\t      Object.getOwnPropertyDescriptors(orig)\r\n\r\n\t    );\r\n\r\n\t  }\r\n\r\n### 面向对象编程的模式\r\n\r\n- 构造函数的继承（注意是构造函数之间的继承，和构造函数通过new关键字生成实例是不一样的）\r\n\r\n\t- 写法一：让一个构造函数继承另一个构造函数，是非常常见的需求。这可以分成两步实现。\r\n\r\n\t\t- 第一步是在子类的构造函数中，调用父类的构造函数。（注意没有new，相当于普通函数，借用了他的属性而已，这一步相当于拷贝了父构造函数的属性且this为子构造函数下的this）\r\n\r\n\t\t\t\t- 第一步为复制属性\r\n\r\n\t\t- 第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型（使用creat是为了不让子构造函数的原型对象影响到父构造函数的原型对象，后两行是指定修改子构造函数为其实例的构造函数，修改原型对象时，一般要同时校正constructor属性的指向。以及自定义方法）\r\n\r\n\t\t\t\t- 第二步为继承父构造函数原型对象上的方法\r\n\r\n\t- 写法二：直接让Sub.prototype等于一个父类实例。\r\n\r\n\t\t- Sub.prototype = new Super();\r\n\t\t- 上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以不推荐使用这种写法。\r\n\r\n\t- 举例说明\r\n\r\n\t\t- 整体继承\r\n\r\n\t\t- 单个方法的继承\r\n\r\n- 多重继承（Mixin混入）\r\n\r\n\t- 概述\r\n\r\n\t\t- JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。\r\n\t\t- Object.assign({},obj,obj1);\r\n\r\n\t\t\t- 花括号叫目标对象，后面的obj、obj1是源对象。对象合并是指：将源对象里面的属性添加到目标对象中去，若两者的属性名有冲突，后面的将会覆盖前面的\r\n\r\n\t- 实例\r\n\r\n\t\t\t- 子类S同时继承了父类M1和M2。这种模式又称为 Mixin（混入）。\r\n\r\n- 模块\r\n\r\n\t- 基本的实现方法\r\n\r\n\t\t- 概述\r\n\r\n\t\t\t- 模块是实现特定功能的一组属性和方法的封装。\r\n\r\n\t\t- 可以把模块写成一个对象，所有的模块成员都放到这个对象里面。\r\n\r\n\t\t\t- 上面的函数m1和m2，都封装在module1对象里。使用的时候，就是调用这个对象的属性。\r\n\r\n\t\t\t\t- module1.m1();\r\n\r\n\t\t\t- 但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。\r\n\r\n\t\t\t\t- module1._count = 5;\r\n\r\n\t- 封装私有变量：构造函数的写法\r\n\r\n\t\t- 可以利用构造函数，封装私有变量。\r\n\r\n\t\t\t- 这种方法将私有变量封装在构造函数中，违反了构造函数与实例对象相分离的原则。并且，非常耗费内存。\r\n\t\t\t- 这种方法将私有变量放入实例对象中，好处是看上去更自然，但是它的私有变量可以从外部读写，不是很安全。\r\n\r\n\t- 封装私有变量：立即执行函数的写法\r\n\r\n\t\t- 使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。\r\n\r\n\t\t\t- 使用上面的写法，外部代码无法读取内部的_count变量。\r\n\r\n\t- 模块的扩展模式\r\n\r\n\t\t- 如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）。\r\n\r\n\t\t\t- 上面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。\r\n\r\n\t\t- 在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽扩展模式”（Loose augmentation）。\r\n\r\n\t\t\t- 与”扩展模式”相比，“宽扩展模式”就是“立即执行函数”的参数可以是空对象。\r\n\r\n\t- 输入全局变量\r\n\r\n\t\t- 独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。\r\n\t\t- 为了在模块内部调用全局变量，必须显式地将其他变量输入模块。\r\n\r\n\t\t\t- 上面的module1模块需要使用jQuery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module1。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。\r\n\r\n## 阮一峰·JS语法 专题\r\n\r\n### 定时器\r\n\r\n- setTimeout()\r\n\r\n  过了一定时间执行一次，只执行一次。比如隔一秒后执行一次，过了十万八千秒后也只在第一秒执行了一次，仅有的一次\r\n\r\n\t- 参数\r\n\r\n\t\t- 除了前两个参数，setTimeout还允许添加更多的参数。它们将被传入推迟执行的函数（回调函数）。\r\n\r\n\t- 需要注意的地方\r\n\r\n\t\t- 如果被setTimeout推迟执行的回调函数是某个对象的方法，那么该方法中的this关键字将指向全局环境，而不是定义时所在的那个对象。\r\n\r\n- setInterval()\r\n\r\n  每间隔一定时间执行一次，循环往复。比如每隔一秒执行一次，六十秒过后执行了60次\r\n\r\n\t- 应用\r\n\r\n\t\t- 一个通过setInterval方法实现网页动画的例子\r\n\r\n\t\t- setInterval的一个常见用途是实现轮询。下面是一个轮询URL的Hash值是否发生变化的例子。\r\n\r\n\t- 注意\r\n\r\n\t\t- setInterval指定的是“开始执行”之间的间隔，并不考虑每次任务执行本身所消耗的时间。因此实际上，两次执行之间的间隔会小于指定的时间。比如，setInterval指定每100ms执行一次，每次执行需要5ms，那么第一次执行结束后95毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要105毫秒，那么它结束后，下一次执行就会立即开始。\r\n\r\n\t- 用setTimeOut代替\r\n\r\n\t\t- 为了确保两次执行之间有固定的间隔，可以不用setInterval，而是每次执行结束后，使用setTimeout指定下一次执行的具体时间。\r\n\r\n- clearTimeout()，clearInterval()\r\n\r\n\t- 函数防抖\r\n\r\n\t\t- 就是如果用户连续击键，就会连续触发keydown事件，造成大量的Ajax通信。这是不必要的，而且很可能会发生性能问题。正确的做法应该是，设置一个门槛值，表示两次Ajax通信的最小间隔时间。如果在设定的时间内，发生新的keydown事件，则不触发Ajax通信，并且重新开始计时。如果过了指定时间，没有发生新的keydown事件，将进行Ajax通信将数据发送出去。\r\n\t\t- 这种做法叫做debounce（防抖动）方法，用来返回一个新函数。只有当两次触发之间的时间间隔大于事先设定的值，这个新函数才会运行实际的任务。假定两次Ajax通信的间隔不小于2500毫秒，上面的代码可以改写成下面这样。\r\n\r\n\t\t\t- $('textarea').on('keydown', ajaxAction);\r\n\t\t\t- $('textarea').on('keydown', debounce(ajaxAction, 2500))\r\n\t\t- 注意\r\n\r\n\t\t\t- 现实中，最好不要设置太多个setTimeout和setInterval，它们耗费CPU。比较理想的做法是，将要推迟执行的代码都放在一个函数里，然后只对这个函数使用setTimeout或setInterval。\r\n\r\n- 应用\r\n\r\n\t- 它的一大应用是，可以调整事件的发生顺序。比如，网页开发中，某个事件先发生在子元素，然后冒泡到父元素，即子元素的事件回调函数，会早于父元素的事件回调函数触发。如果，我们先让父元素的事件回调函数先发生，就要用到setTimeout(f, 0)。\r\n\r\n\t- 用户自定义的回调函数，通常在浏览器的默认动作之前触发。比如，用户在输入框输入文本，keypress事件会在浏览器接收文本之前触发。因此，下面的回调函数是达不到目的的。\r\n\r\n\t- 由于setTimeout(f,0)实际上意味着，将任务放到浏览器最早可得的空闲时段执行，所以那些计算量大、耗时长的任务，常常会被放到几个小部分，分别放到setTimeout(f,0)里面执行。\r\n\r\n\t\t\t- 上面代码有两种写法，都是改变一个网页元素的背景色。写法一会造成浏览器“堵塞”，因为JavaScript执行速度远高于DOM，会造成大量DOM操作“堆积”，而写法二就不会，这就是setTimeout(f, 0)的好处。\r\n\t\t\t- 另一个使用这种技巧的例子是代码高亮的处理。如果代码块很大，一次性处理，可能会对性能造成很大的压力，那么将其分成一个个小块，一次处理一块，比如写成setTimeout(highlightNext, 50)的样子，性能压力就会减轻。\r\n\r\n### Promise对象\r\n\r\n- JavaScript的异步执行\r\n\r\n\t- 概述\r\n\r\n\t\t- JavaScript 语言本身并不慢，慢的是读写外部数据，比如等待 Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。\r\n\t\t- 异步模式\r\n\r\n\t\t\t- “异步模式”中，每一个任务分成两段，第一段代码包含对外部数据的请求，第二段代码被写成一个回调函数，包含了对外部数据的处理。第一段代码执行完，不是立刻执行第二段代码，而是将程序的执行权交给第二个任务。等到外部数据返回了，再由系统通知执行第二段代码。所以，程序的执行顺序与任务的排列顺序是不一致的、异步的。\r\n\r\n\t- 回调函数\r\n\r\n\t\t- 定义\r\n\r\n\t\t\t- 假定有两个函数f1和f2，后者必须等到前者执行完成，才能执行。这时，可以考虑改写f1，把f2写成f1的回调函数。\r\n\r\n\t\t- 优缺点\r\n\r\n\t\t\t- 回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），使得程序结构混乱、流程难以追踪（尤其是回调函数嵌套的情况），而且每个任务只能指定一个回调函数。\r\n\r\n\t- 事件监听\r\n\r\n\t\t- 定义\r\n\r\n\t\t\t- \r\n另一种思路是采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。\r\n\r\n\t\t- 做法\r\n\r\n\t\t\t- 还是以f1和f2为例。首先，为f1绑定一个事件（这里采用的jQuery的写法）。\r\n\r\n\t\t\t\t- f1.on('done', f2);\r\n\r\n\t\t\t- 上面这行代码的意思是，当f1发生done事件，就执行f2。然后，对f1进行改写：\r\n\r\n\t\t\t\t- function f1(){\r\n  setTimeout(function () {\r\n    // f1的任务代码\r\n    f1.trigger('done');\r\n  }, 1000);\r\n}\r\n\r\n\t\t\t- 上面代码中，f1.trigger('done')表示，执行完成后，立即触发done事件，从而开始执行f2。\r\n\r\n\t\t- 优缺点\r\n\r\n\t\t\t- 这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合“（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。\r\n\r\n\t- 发布/订阅\r\n\r\n\t\t- 定义\r\n\r\n\t\t\t- “事件”完全可以理解成”信号”，如果存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式“，又称”观察者模式“。\r\n\r\n\t\t- 实现（采用一个插件来实现）\r\n\r\n\t\t\t- 首先，f2向”信号中心”jQuery订阅”done”信号。\r\n\r\n\t\t\t- 然后，f1进行如下改写：\r\n\r\n\t\t\t- f2完成执行后，也可以取消订阅（unsubscribe）。\r\n\r\n\t\t- 优缺点\r\n\r\n\t\t\t- 这种方法的性质与”事件监听”类似，但是明显优于后者。因为我们可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。\r\n\r\n- 异步操作的流程控制\r\n\r\n\t- 初步认识\r\n\r\n\t\t- 如果有多个异步操作，就存在一个流程控制的问题：确定操作执行的顺序，以后如何保证遵守这种顺序。\r\n\t\t- 回调函数的嵌套\r\n\r\n\t\t\t- async函数是一个异步任务，非常耗时，每次执行需要1秒才能完成，然后再调用回调函数。\r\n\r\n\t\t\t- 如果有6个这样的异步任务，需要全部完成后，才能执行下一步的final函数。\r\n\r\n\t\t\t- 只能采用6个回调函数的嵌套，不仅写起来麻烦，易出错，且难维护\r\n\r\n\t- 串行执行\r\n\r\n\t\t- 我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。\r\n\t\t\t- 此处定义的async第一个参数是异步任务的参数，第二个参数是异步任务的回调函数，这里回调函数直接在调用的时候才定义\r\n\r\n\t\t- 上面代码中，函数series就是串行函数，它会依次执行异步任务，所有任务都完成后，才会执行final函数。items数组保存每一个异步任务的参数，results数组保存每一个异步任务的运行结果。\r\n\r\n\t- 并行执行\r\n\r\n\t\t- 流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行final函数。\r\n\t\t- 上面代码中，forEach方法会同时发起6个异步任务，等到它们全部完成以后，才会执行final函数。\r\n\t\t- 优缺点\r\n\r\n\t\t\t- 并行执行的好处是效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。\r\n\r\n\r\n\r\n\t\t- 所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行n个异步任务。这样就避免了过分占用系统资源。\r\n\t\t- 上面代码中，最多只能同时运行两个异步任务。变量running记录当前正在运行的任务数，只要低于门槛值，就再启动一个新的任务，如果等于0，就表示所有任务都执行完了，这时就执行final函数。\r\n\r\n- Promise对象\r\n\r\n\t- 简介\r\n\r\n\t\t- Promise 对象是 CommonJS 工作组提出的一种规范，目的是为异步操作提供统一接口。\r\n\t\t- 初步认识\r\n\r\n\t\t\t- 首先，它是一个对象，也就是说与其他JavaScript对象的用法，没有什么两样；其次，它起到代理作用（proxy），充当异步操作与回调函数之间的中介。它使得异步操作具备同步操作的接口，使得程序具备正常的同步运行的流程，回调函数不必再一层层嵌套。\r\n\r\n\t\t- 三种状态\r\n\r\n\t\t\t- 异步操作未完成（pending）\r\n\t\t\t- 异步操作成功（fulfilled）\r\n\t\t\t- 异步操作失败（rejected）\r\n\r\n\t\t- 使用\r\n\r\n\t\t\t- 它的思想是，每一个异步任务立刻返回一个Promise对象，由于是立刻返回，所以可以采用同步操作的流程。这个Promises对象有一个then方法，允许指定回调函数，在异步任务完成后调用。\r\n\r\n\t\t\t\t- 比如，异步操作f1返回一个Promise对象，它的回调函数f2写法如下。\r\n\r\n\t\t\t\t- 这种写法对于多层嵌套的回调函数尤其方便。\r\n\r\n\t\t- 总结\r\n\r\n\t\t\t- 总的来说，传统的回调函数写法使得代码混成一团，变得横向发展而不是向下发展。Promises规范就是为了解决这个问题而提出的，目标是使用正常的程序流程（同步），来处理异步操作。它先返回一个Promise对象，后面的操作以同步的方式，寄存在这个对象上面。等到异步操作有了结果，再执行前期寄放在它上面的其他操作。\r\n\r\n\t- Promise接口\r\n\r\n\t\t- Promise接口的基本思想是，异步任务返回一个Promise对象。\r\n\t\t- Promise对象的最终结果只有两种。\r\n\r\n\t\t\t- 异步操作成功，Promise对象传回一个值，状态变为resolved。\r\n\t\t\t- 异步操作失败，Promise对象抛出一个错误，状态变为rejected。\r\n\r\n\t\t- 回调函数then\r\n\r\n\t\t\t- Promise对象使用then方法添加回调函数。then方法可以接受两个回调函数，第一个是异步操作成功时（变为resolved状态）时的回调函数，第二个是异步操作失败（变为rejected）时的回调函数（可以省略）。一旦状态改变，就调用相应的回调函数。\r\n\r\n\t\t\t- then方法可以链式使用。\r\n\r\n- Promise的应用\r\n\r\n",re={data:function(){return{MainComponent:te}}},ee=re,ae=Object(m["a"])(ee,Zr,ne,!1,null,"759ae5ee",null),oe=ae.exports,se={mixins:[k["c"]],components:{m1:ar,m2:ur,m3:fr,m4:xr,m5:Rr,m6:Hr,m7:Vr,m8:Yr,m9:oe},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"循环遍历",value:"m1"},{label:"Event Loop",value:"m2"},{label:"js基础",value:"m3"},{label:"js高阶",value:"m4"},{label:"es6归纳1",value:"m5"},{label:"es6归纳2",value:"m6"},{label:"阮一峰JS总结",value:"m9"},{label:"jquery",value:"m8"},{label:"正则",value:"m7"}]}}},ie=se,le=Object(m["a"])(ie,Kt,Qt,!1,null,"a1dd99c8",null),ce=le.exports,pe=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[r("div",[r(""+n.tab,{tag:"component"})],1)])},ue=[],me=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},de=[],ge="# http\r\n\r\n## Web 及网络协议基础\r\n\r\n### 网络基础TCP/IP\r\n\r\n- 通常使用的网络是在TCP/IP协议族的基础上运作的，HTTP属于他内部的一个子集\r\n- 把与互联网相关联的协议集合起来总称为 TCP/IP\r\n- TCP/IP 协议族按层次分别分为以下 4 层:应用层、传输层、网络层和数据链路层\r\n- 发送端在层与层之间传输数据时,每经过一层时必定会被打上一个该层所属的首部信息。\r\n反之,接收端在层 与层传输数据时,每经过一层时会把对应的首部消去\r\n\r\n### 与 HTTP 关系密切的协议：IP、TCP和DNS\r\n\r\n- IP 协议的作用是把各种数据包传送给对方\r\n- IP 地址指明了节点被分配到的地址,MAC 地址是指网卡所属的固定地址。\r\n- 在进行中转时,会利用下一站中转设备的 MAC 地址来搜索下一 个中转目标。这时,会采用 ARP 协议\r\n- 无论哪台计算机、哪台网络设备,它们都无法全面掌握互联网中的细节\r\n- 按层次分,TCP 位于传输层,提供可靠的字节流服务。\r\n- 将大块数据分割成以报文段为单位的数据包进行管理\r\n- TCP 协 议为了更容易传送大数据才把数据分割\r\n- TCP 协议采用了三次握手(three-way handshaking)策略\r\n\r\n\t-  若在握手过程中某个阶段莫名中断，TCP 协议\r\n会再次以相同的顺序发送相同的数据包\r\n\r\n- DNS 协议提供通过域名查找 IP 地址,或逆向从 IP 地址反查域名 的服务\r\n\r\n### URL 和 URL\r\n\r\n- URL 正是使用 Web 浏览器等访问 Web 页面时需要输入的网页地址\r\n- URI 就是由某个协议方案表示的资源的定位标识符\r\n\r\n## 构建 Web 内容的技术\r\n\r\n### HTML\r\n\r\n- HTML5 标准不仅解决了浏览器之间的兼容性问题,并且可把文本作为数据对待,更容易复用,动画等效果也 变得更生动。\r\n- CSS(Cascading Style Sheets,层叠样式表)可以指定如何展现 HTML 内的各种元素,属于样式表标准之一\r\n- 所谓动态 HTML(Dynamic HTML),是指使用客户端脚本语言将静态的 HTML 内容变成动态的技术的总 称。\r\n- DOM 是用以操作 HTML 文档和 XML 文档的 API(\r\n\r\n### Web 应用\r\n\r\n- Web 应用是指通过 Web 功能提供的应用程序\r\n- CGI(Common Gateway Interface,通用网关接口)是指 Web 服务器在接收到客户端发送过来的请求后转发 给程序的一组机制\r\n- 随着 CGI 的普及,每次请求都要启动新 CGI 程序的 CGI 运行机制逐渐变成了性能瓶颈,\r\n所以之后 Servlet 和 mod_perl 等可直接在 Web 服务器上运行的程序才得以开发、普及\r\n\r\n### 数据发布的格式及语言\r\n\r\n- XML(eXtensible Markup Language,可扩展标记语言)是一种可按应用目标进行扩展的通用标记语言\r\n- RSS(简易信息聚合,也叫聚合内容)和 Atom 都是发布新闻或博客日志等更新信息文档的格式的总称\r\n- JSON(JavaScript Object Notation)是一种以 JavaScript(ECMAScript)的对象表示法为基础的轻量级数据 标记语言\r\n\r\n## 基于 HTTP 的功能追加协议\r\n\r\n### 消除HTTP 瓶颈的 SPDY\r\n\r\n- 其开发目标旨在解决 HTTP 的性能瓶颈,缩短 Web 页面的加载时间(50%)\r\n- 一条连接上只可发送一个请求。\r\n-  请求只能从客户端开始。 客户端不可以接收除响应以外的指令。\r\n-  请求 / 响应首部未经压缩就发送。 首部信息越多延迟越大。\r\n-  发送冗长的首部。 每次互相发送相同的首部造成的浪费较多。\r\n-  可任意选择数据压缩格式。 非强制压缩发送。\r\n- SPDY 没有完全改写 HTTP 协议,而是在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作\r\n- 多路复用流\r\n\r\n\t- 通过单一的 TCP 连接,可以无限制处理多个 HTTP 请求\r\n\r\n- 赋予请求优先级\r\n\r\n\t- SPDY 不仅可以无限制地并发处理请求,还可以给请求逐个分配优先级顺序\r\n\r\n- 压缩 HTTP 首部\r\n\r\n\t- 压缩 HTTP 请求和响应的首部\r\n\r\n- 推送功能\r\n\r\n\t- 支持服务器主动向客户端推送数据的功能\r\n\r\n- 服务器提示功能\r\n\r\n\t- 服务器可以主动提示客户端请求所需的资源\r\n\r\n- SPDY 的确是一种可有效消除 HTTP 瓶颈的技术,但很多 Web 网站存在的问题并非仅仅是由 HTTP 瓶颈所 导致\r\n\r\n### 使用浏览器进行全双工通信的WebSocket\r\n\r\n- 一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接,之后所有的通信都依靠这个专用协议进 行。\r\n- 连接的发起方仍是客户端,而一旦确立 WebSocket 通信连接,不 论服务器还是客户端,任意一方都可直接向对方发送报文\r\n- 支持由服务器向客户端推送数据的推送功能。\r\n- 和 HTTP 相比,不但每次连接时的总开销减少, 而且由于 WebSocket 的首部信息很小,通信量也相应减少了\r\n\r\n### 期盼已久的HTTP/2.0\r\n\r\n- HTTP/2.0 的目标是改善用户在使用 Web 时的速度体验。\r\n\r\n### Web 服务器管理文件的 WebDAV\r\n\r\n- 一 个可对 Web 服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统\r\n\r\n## HTTP 报文内的 HTTP信息\r\n\r\n### HTTP 报文\r\n\r\n- 用于 HTTP 协议交互的信息被称为 HTTP 报文\r\n- HTTP 报文大致可分为报文首部和报文主体两块\r\n\r\n### 报文结构\r\n\r\n- 请求行\r\n- 状态行\r\n- 首部字段\r\n- 其他\r\n\r\n### 编码提升传输速率\r\n\r\n- 通过在传 输时编码,能有效地处理大量的访问请求。但是,编码的操作需要计算机来完成,因此会消耗更多的 CPU 等 资源\r\n- 报文\r\n\r\n\t- 是 HTTP 通信中的基本单位,由 8 位组字节流(octet sequence,其中 octet 为 8 个比特)组成,通过 HTTP 通信传输\r\n\r\n- 实体\r\n\r\n\t- 作为请求或响应的有效载荷数据(补充项)被传输,其内容由实体首部和实体主体组成\r\n\r\n- 向待发送邮件内增加附件时,为了使邮件容量变小,我们会先用 ZIP 压缩文件之后再添加附件发送\r\n- 常用的内容编码有以下几种\r\n\r\n\t- gzip( GNU zip)\r\n\t- compress( UNIX 系统的标准压缩)\r\n\t- deflate ( zlib)\r\n\t- identity(不进行编码)\r\n\r\n- 在 HTTP 通信过程中,请求的编码实体资源尚未全部传输完成之前,浏览器无法显示请求页面。\r\n\r\n### 发送多种数据的多部分对象集合\r\n\r\n- 在 MIME 扩展中会使用一种称为多部分对象集合(Multipart)的方法,来容纳多份不同类型的数据\r\n- 多部分对象集合包含的对象\r\n\r\n\t- multipart/form-data\r\n\t- multipart/byteranges\r\n\t- multipart/form-data\r\n\t- multipart/byteranges\r\n\r\n- 在 HTTP 报文中使用多部分对象集合时,需要在首部字段里加上 Content-type\r\n\r\n### 获取部分内容的范围请求\r\n\r\n- 执行范围请求时,会用到首部字段 Range 来指定资源的 byte 范围。\r\n\r\n### 内容协商返回最合适的内容\r\n\r\n- 当浏览器的默认语言为英语或中文,访问相同 URI 的 Web 页面时,则会显示对应的英语版或中文版的 Web 页面。这样的机制称为内容协商(\r\n- 内容协商机制是指客户端和服务器端就响应的资源内容进行交涉,然后提供给客户端最为适合的资源\r\n- 由服务器端进行内容协商。以请求的首部字段为参考,在服务器端自动处理\r\n- 由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择\r\n- 是服务器驱动和客户端驱动的结合体,是由服务器端和客户端各自进行内容协商的一种方法\r\n- Accept Accept-Charset Accept-Encoding Accept-Language Content-Language\r\n\r\n## 与 HTTP 协作的 Web 服务器\r\n\r\n### 用单台虚拟主机实现多个域名\r\n\r\n- HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点\r\n\r\n### 通信数据转发程序 :代理、网关、隧道\r\n\r\n- 代理\r\n\r\n\t- 代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器\r\n\t- 缓存代理\r\n\t- 透明代理\r\n\r\n- 网关\r\n\r\n\t- 利用网关可以由 HTTP 请求转化为其他协议通信\r\n\r\n- 隧道\r\n\r\n\t- 隧道的目的是确保 客户端能与服务器进行安全的通信\r\n\r\n### 保存资源的缓存\r\n\r\n- 代理服务器\r\n\r\n\t- 缓存是指代理服务器或客户端本地磁盘内保存的资源副本\r\n\r\n- 缓存的有效期限\r\n\r\n\t- 即使存在缓存,也会因为客户端的要求、缓存的有效期等因素,向源服务器确认资源的有效性\r\n\r\n- 客户端的缓存\r\n\r\n\t- 浏览器缓存如果有效,就不必再向服务器请求相同的资源了,可以直接从本地磁盘内读取\r\n\r\n## HTTP 头部\r\n\r\n###   HTTP 报文的结构\r\n\r\n- 在请求中,HTTP 报文由方法、URI、HTTP 版本、HTTP 首部字段等部分构成。\r\n- 在响应中,HTTP 报文由 HTTP 版本、状态码(数字和原因短语)、HTTP 首部字段 3 部分构成\r\n\r\n### HTTP 首部字段\r\n\r\n- HTTP 首部字段是由首部字段名和字段值构成的,中间用冒号“:” 分隔。\r\n- 字段值对应单个 HTTP 首部字段可以有多个值\r\n- 4 种 HTTP 首部字段类型\r\n\r\n\t- 通用首部字段( General Header Fields)\r\n\t- 请求首部字段( Request Header Fields)\r\n\t- 响应首部字段( Response Header Fields)\r\n\t- 实体首部字段( Entity Header Fields)\r\n\r\n### HTTP/1.1 首部字段一览\r\n\r\n- Cache-Control\r\n\r\n\t- 控制缓存行为\r\n\r\n- Connection\r\n\r\n\t- 逐跳首部、连接的管理\r\n\r\n- Date\r\n\r\n\t- 创建报文的日期时间\r\n\r\n- Pragma\r\n\r\n\t- 报文指令\r\n\r\n- Trailer\r\n\r\n\t- 报文末端的首部一览\r\n\r\n- Transfer-Encoding\r\n\r\n\t- 指定报文主体的传输编码方式\r\n\r\n- Upgrade\r\n\r\n\t- 升级为其他协议\r\n\r\n- Via\r\n\r\n\t- 代理服务器的相关信息\r\n\r\n- Warning\r\n\r\n\t- 错误通知\r\n\r\n- Accept\r\n\r\n\t- 用户代理可处理的媒体类型\r\n\r\n- Accept-Charset\r\n\r\n\t- 优先的字符集\r\n\r\n- Accept-Encoding\r\n\r\n\t- 优先的内容编码\r\n\r\n- Accept-Language\r\n\r\n\t- 优先的语言(自然语言)\r\n\r\n- Authorization\r\n\r\n\t- Web认证信息\r\n\r\n- Expect\r\n\r\n\t- 期待服务器的特定行为\r\n\r\n- From\r\n\r\n\t- 用户的电子邮箱地址\r\n\r\n- Host\r\n\r\n\t- 请求资源所在服务器\r\n\r\n- If-Match\r\n\r\n\t- 比较实体标记(ETag)\r\n\r\n- If-Modified-Since\r\n\r\n\t- 比较资源的更新时间\r\n\r\n- If-None-Match\r\n\r\n\t- 比较实体标记(与 If-Match 相反)\r\n\r\n- If-Range\r\n\r\n\t- 资源未更新时发送实体 Byte 的范围请求\r\n\r\n- If-Unmodified-Since\r\n\r\n\t- 比较资源的更新时间(与If-Modified-Since相反)\r\n\r\n- Max-Forwards\r\n\r\n\t- 最大传输逐跳数\r\n\r\n- Proxy-Authorization\r\n\r\n\t- 代理服务器要求客户端的认证信息\r\n\r\n- Range\r\n\r\n\t- 实体的字节范围请求\r\n\r\n- Referer\r\n\r\n\t- 对请求中 URI 的原始获取方\r\n\r\n- TE\r\n\r\n\t- 传输编码的优先级\r\n\r\n- User-Agent\r\n\r\n\t- HTTP 客户端程序的信息\r\n\r\n- Accept-Ranges\r\n\r\n\t- 是否接受字节范围请求\r\n\r\n- Age\r\n\r\n\t- 推算资源创建经过时间\r\n\r\n- ETag\r\n\r\n\t- 资源的匹配信息\r\n\r\n- Location\r\n\r\n\t- 令客户端重定向至指定URI\r\n\r\n- Proxy-Authenticate\r\n\r\n\t- 代理服务器对客户端的认证信息\r\n\r\n- Retry-After\r\n\r\n\t- 对再次发起请求的时机要求\r\n\r\n- Server\r\n\r\n\t- HTTP服务器的安装信息\r\n\r\n- Vary\r\n\r\n\t- 代理服务器缓存的管理信息\r\n\r\n- WWW-Authenticate\r\n\r\n\t- 服务器对客户端的认证信息\r\n\r\n- Allow\r\n\r\n\t- 资源可支持的HTTP方法\r\n\r\n- Content-Encoding\r\n\r\n\t- 实体主体适用的编码方式\r\n\r\n- Content-Language\r\n\r\n\t- 实体主体的自然语言\r\n\r\n- Content-Length\r\n\r\n\t- 实体主体的大小(单位:字节)\r\n\r\n- Content-Location\r\n\r\n\t- 替代对应资源的URI\r\n\r\n- Content-MD5\r\n\r\n\t- 实体主体的报文摘要\r\n\r\n- Content-Range\r\n\r\n\t- 实体主体的位置范围\r\n\r\n- Content-Type\r\n\r\n\t- 实体主体的媒体类型\r\n\r\n- Expires\r\n\r\n\t- 实体主体过期的日期时间\r\n\r\n- Last-Modified\r\n\r\n\t- 资源的最后修改日期时间\r\n\r\n- 还有 Cookie、 Set-Cookie 和 Content-Disposition 等在其他 RFC 中定义的首部字段,它们的使用频率也很高\r\n\r\n### End-to-end 首部和 Hop-by-hop 首部\r\n\r\n- 端到端首部( End-to-end Header)\r\n- 逐跳首部( Hop-by-hop Header)\r\n\r\n## 确保 Web 安全的 HTTPS\r\n\r\n### HTTP 的缺点\r\n\r\n- 通信使用明文(不加密), 内容可能会被窃听\r\n- 不验证通信方的身份, 因此有可能遭遇伪装\r\n- 无法证明报文的完整性, 所以有可能已遭篡改\r\n\r\n### HTTP+ 加密 + 认证 + 完整性保护 =HTTPS\r\n\r\n- 我们把添加了加密及认证机制 的 HTTP 称为 HTTPS\r\n- 只是 HTTP 通信接口部分用 SSL(Secure Socket Layer)和TLS(Transport Layer Security)协议代替而已\r\n- SSL 是独立于 HTTP 的协议,所以不光是 HTTP 协议,其他运行在应用层的 SMTP 和 Telnet 等协议均可配 合 SSL 协议使用\r\n- SSL 采用一种叫做公开密钥加密(Public-key cryptography)的加密处理方式\r\n- 加密和解密都会用到密钥。没有密钥就无法对密码解密,反过来说,任何人只要持有密钥就能解密了\r\n- 加密和解密同用一个密钥的方式称为共享密钥加密(Common key crypto system),也被叫做对称密钥 加密\r\n- 公开密钥加密使用一对非对称的密钥。一把叫做私有密钥(private key),另一把叫做公开密钥(public key)\r\n- HTTPS 采用混合加密机制\r\n- 数字证书认证机构(CA,Certificate Authority)和其相关机关颁发的公开密 钥证书\r\n\r\n## 返回结果的 HTTP 状态码\r\n\r\n### 状态码的职责\r\n\r\n- 当客户端向服务器端发送请求时,描述返回的请求结果\r\n\r\n### 状态码的大致分类\r\n\r\n- 1XX\r\n\r\n\t- 信息性状态码\r\n\r\n\t\t- 接收的请求正在处理\r\n\r\n- 2XX\r\n\r\n\t- 成功状态码\r\n\r\n\t\t- 请求正常处理完毕\r\n\r\n- 3XX\r\n\r\n\t- 重定向状态码\r\n\r\n\t\t- 需要进行附加操作以完成请求\r\n\r\n- 4XX\r\n\r\n\t- 客户端错误状态码\r\n\r\n\t\t- 服务器无法处理请求\r\n\r\n- 5XX\r\n\r\n\t- 服务器错误状态码\r\n\r\n\t\t- 服务器处理请求出错\r\n\r\n### 2XX 成功\r\n\r\n- 200 OK\r\n\r\n\t- 表示从客户端发来的请求在服务器端被正常处理了\r\n\r\n- 204 No Content\r\n\r\n\t- 该状态码代表服务器接收的请求已成功处理,但在返回的响应报文中不含实体的主体部分\r\n\r\n- 206 Partial Content\r\n\r\n\t- 该状态码表示客户端进行了范围请求,而服务器成功执行了这部分的 GET 请求\r\n\r\n### 3XX 重定向\r\n\r\n- 301 Moved Permanently\r\n\r\n\t- 永久性重定向。该状态码表示请求的资源已被分配了新的 URI,以后应使用资源现在所指的 URI。\r\n\r\n- 302 Found\r\n\r\n\t- 临时性重定向。该状态码表示请求的资源已被分配了新的 URI,希望用户(本次)能使用新的 URI 访问\r\n\r\n- 303 See Other\r\n\r\n\t- 该状态码表示由于请求对应的资源存在着另一个 URI,应使用 GET 方法定向获取请求的资源\r\n\t- 303 状态码和 302 Found 状态码有着相同的功能,但 303 状态码明确表示客户端应当采用 GET 方法获取资 源\r\n\r\n- 304 Not Modified\r\n\r\n\t- 该状态码表示客户端发送附带条件的请求 2 时,服务器端允许请求访问资源,但未满足条件的情况\r\n\r\n- 307 Temporary Redirect\r\n\r\n\t- 临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET\r\n\r\n### 4XX 客户端错误\r\n\r\n- 400 Bad Request\r\n\r\n\t- 该状态码表示请求报文中存在语法错误\r\n\r\n- 401 Unauthorized\r\n\r\n\t- 该状态码表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息\r\n\r\n- 403 Forbidden\r\n\r\n\t- 该状态码表明对请求资源的访问被服务器拒绝了\r\n\r\n- 404 Not Found\r\n\r\n\t- 该状态码表明服务器上无法找到请求的资源\r\n\r\n### 5XX 服务器错误\r\n\r\n- 500 Internal Server Error\r\n\r\n\t- 该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障\r\n\r\n- 503 Service Unavailable\r\n\r\n\t- 该状态码表明服务器暂时处于超负载或正在进行停机维护,现在无法处理请求\r\n\r\n## 确认访问用户身份的认证\r\n\r\n### 何为认证\r\n\r\n- 密码:只有本人才会知道的字符串信息。\r\n- 动态令牌:仅限本人持有的设备内显示的一次性密码\r\n- 数字证书:仅限本人(终端)持有的信息\r\n- 生物认证:指纹和虹膜等本人的生理信息。\r\n- IC 卡等:仅限本人持有的信息\r\n- BASIC 认证(基本认证)\r\n- DIGEST 认证(摘要认证)\r\n- SSL 客户端认证\r\n- FormBase 认证(基于表单认证)\r\n\r\n### BASIC 认证\r\n\r\n- BASIC 认证(基本认证)是从 HTTP/1.0 就定义的认证方式。\r\n- BASIC 认证使用上不够便捷灵活,且达不到多数 Web 网站期望的安全性等级,因此它并不常用。\r\n- 步骤 1: 当请求的资源需要 BASIC 认证时,服务器会随状态码 401 Authorization Required,返回带 WWW-Authenticate 首部字段的响应\r\n- 步骤 2: 接收到状态码 401 的客户端为了通过 BASIC 认证,需要将用户 ID 及密码发送给服务器\r\n- 步骤3：接收到包含首部字段 Authorization 请求的服务器,会对认证信息的正确性进行验证\r\n\r\n### DIGEST 认证\r\n\r\n- DIGEST 认证同样使用质询 / 响应的 方式(challenge/response),但不会像 BASIC 认证那样直接发送明文密码。\r\n- 步骤 1: 请求需认证的资源时,服务器会随着状态码 401 Authorization Required,返 回带 WWW-Authenticate 首部字段的响应\r\n- 步骤 2: 接收到 401 状态码的客户端,返回的响应中包含 DIGEST 认证必须的首部字段 Authorization 信 息。\r\n- 步骤 3: 接收到包含首部字段 Authorization 请求的服务器,会确认认证信息的正确性。\r\n\r\n### SSL 客户端认证\r\n\r\n- SSL 客户端认证是借由 HTTPS 的客户端证书完成认证的方式。\r\n- 步骤 1: 接收到需要认证资源的请求,服务器会发送 Certificate Request 报文,要求客户端提供客户端证 书。\r\n- 步骤 2: 用户选择将发送的客户端证书后,客户端会把客户端证书信息以 Client Certificate 报文方式发送给 服务器。\r\n- 步骤 3: 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥,然后开始 HTTPS 加密通 信。\r\n\r\n###  基于表单认证\r\n\r\n- 认证多半为基于表单认证\r\n- 基于表单认证的标准规范尚未有定论,一般会使用 Cookie 来管理 Session(会话)\r\n- 步骤 1: 客户端把用户 ID 和密码等登录信息放入报文的实体部分,通常是以 POST 方法把请求发送给服务 器。\r\n- 步骤 2: 服务器会发放用以识别用户的 Session ID。会在首部字段 Set-Cookie 内写入 Session ID\r\n- 步骤 3: 客户端接收到从服务器端发来的 Session ID 后,会将其作为 Cookie 保存在本地\r\n\r\n## TCP/IP协议族\r\n\r\n### 是互联网相关的各类协议族的总称\r\n\r\n- 协议就是计算机与网络设备之间互相同通信的规则\r\n- http属于他内部的一个子集\r\n\r\n### 通信传输流\r\n\r\n- 发送端从应用层往下走，接收端从链路层往上走\r\n- 发送端在层与层之间传输数据时，每经过一层必定会被打上一个该层所属的首部信息\r\n- 接收端在层与层之间传输数据时，每经过一层会把对应的首部去掉\r\n- 这种数据信息包装的做法称为封装\r\n\r\n### 负责传输的IP协议\r\n\r\n- 把各种数据包传送给对方（两个重要的条件）\r\n\r\n\t- IP地址（节点被分配的地址）\r\n\t- MAC地址（网卡所属的固定地址）\r\n\r\n### 确保可靠性的TCP协议\r\n\r\n- 提供可靠的字节流服务，把数据准确可靠的传给对方\r\n- 为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理（为了传输大的数据）\r\n- 三次握手\r\n\r\n\t- 客户端发送SYN给服务端，（同步请求）\r\n\t- 服务端发送SYN/ACK（同步请求和确认）\r\n\t- 客户端发送ACK（确认）\r\n\t- 若在某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包\r\n\r\n### DNS域名解析服务\r\n\r\n- 通过域名查找IP地址或逆向从IP查找域名的服务\r\n\r\n### URI与URL\r\n\r\n- URI统一资源标识符，标识资源\r\n- URL统一资源定位符、是URI的子集，标识资源地址\r\n\r\n###  分层管理\r\n\r\n- 链路层\r\n\r\n\t- 用来处理网络连接的硬件部分\r\n\r\n- 传输层\r\n\r\n\t- 为应用层提供网络连接中的两台计算机之间的数据传输\r\n\t- TCP传输控制协议\r\n\t- UDP用户数据报协议\r\n\t- 将应用层的数据进行分割，并在各个报文打上标记序号及端口号后发给网络层\r\n\r\n- 网络层\r\n\r\n\t- 处理在网络上流动的数据包，数据包是网路传输协议的最小数据单位，规定通过怎么的路径到达目的地。\r\n\t- 增加作为通信目的地的MAC地址后转发给链路层\r\n\r\n- 应用层\r\n\r\n\t- 决定了向用户提供的应用服务时通信的活动\r\n\t- FTP文件传输协议\r\n\t- DNS域名系统\r\n\r\n- 分层次的好处\r\n\r\n\t- 应变不同需求\r\n\r\n\t\t- 当需求不同的时候不需要改变所有整体、只需要修改相应的层次就行了。\r\n\r\n\t- 分工明确\r\n\r\n\t\t- 只需要考虑分配给自己的任务\r\n\r\n## 简单HTTP协议\r\n\r\n### 客户端与服务端通讯\r\n\r\n- 在两台计算机之间使用 HTTP 协议通信时,在一条通信线路上必定有一端是客户端,另一端则是服务器端\r\n- 请求必定由客户端发出, 而服务器端回复响应\r\n- 请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的\r\n- 响应报文基本上由协议版本、状态码(表示请求成功或失败的数字代码)、用以解释状态码的原因短语、可 选的响应首部字段以及实体主体构成\r\n\r\n### 请求报文的构成\r\n\r\n- 方法/URI/协议版本\r\n- 请求首部字段\r\n- 内容实体\r\n\r\n### HTTP是不保存状态的协议\r\n\r\n- 协议自身不具备保存之前发送过的请求或相应的功能\r\n- HTTP/1.1虽然无状态协议，但是引入Cookies之后可以管理状态了\r\n- 无状态的优点是可以减少服务器的CPU以及内存资源的消耗\r\n- Cookies技术通过在请求和响应报文中写入Cookies来控制客户端的状态\r\n- 在服务端发送的响应报文内添加Set-Cookies的首部字段信息，通知客户端保存Cookies。当下次客户端发送请求时，客户端会自动在请求报文中加入Cookies值后发送出去\r\n\r\n### 告知服务器意图的HTTP方法\r\n\r\n- GET：获取资源\r\n\r\n\t- 使用GET方法请求访问已被URI识别的资源\r\n\r\n- POST：传输实体的主体\r\n\r\n\t- 虽然GET也可以但是一般不使用GET，POST的主要目的不是获取响应的主体内容\r\n\r\n- PUT：传输文件\r\n\r\n\t- 像FTP协议的文件上传一样，要求在请求的报文 主体中包含文件内容，然后保存到请求URI指定的位置，\r\n\r\n- HEAD：获取报文首部\r\n\r\n\t- 用于确认URI的有效性和资源更新的日期时间等\r\n\t- 和GET一样但是不返回报文主体\r\n\r\n- DELETE删除文件\r\n\r\n\t- 请求删除URI指定的资源\r\n\r\n- OPTIONS：询问支持的方法\r\n\r\n\t- 用来查询针对请求URI指定资源支持的方法\r\n\r\n- TRACE：追踪路径\r\n\r\n\t- 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服 务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最 后接收到请求的服务器端则返回状态码 200 OK 的响应。 \r\n\t- 客户端通过TRACE方法查询发送出去的请求是怎么样被加工修改的。\r\n\t- 请求想要连接到源目标服务器可能会通过代理中转，TRACES方法就是用来确认连接过程中发生的一系列操作\r\n\t- 容易引发XST扩展追踪攻击\r\n\r\n- CONNECT：要求用隧道协议连接代理\r\n\r\n\t- 要求与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信\r\n\t- 主要使用SSL安全套接层和TLS传输安全协议把通信内容加密后经网络隧道传输\r\n\t- CONNECT 代理服务器名：端口号 HTTP版本\r\n\r\n### 持久连接节省通信量\r\n\r\n- HTTP/1.1新增keep-alive方法\r\n- 特点：只要任意一端没有明确提出断开连接，则保持TCP连接状态\r\n- HTTP 协议的初始版本中,每进行一次 HTTP 通信就要断开一次 TCP 连接\r\n- 持久连接的特点是,只要任意 一端没有明确提出断开连接,则保持 TCP 连接状态\r\n- 持久连接使得多数请求以管线化(pipelining)方式发送成为可能\r\n- 减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务端的负载\r\n- HTTP/1.1中所有的连接默认都是持久连接\r\n\r\n### 使用 Cookie 的状态管理\r\n\r\n- HTTP 是无状态协议,它不对之前发生过的请求和响应的状态进行管理\r\n- Cookie 技术通过在请 求和响应报文中写入 Cookie 信息来控制客户端的状态\r\n- Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息,通知客户端保存 Cookie\r\n- 当下次客户端再往该服务器发送请求时,客户端会自动在请求报文中加入 Cookie 值后发送出去\r\n\r\n### 管线化\r\n\r\n- 持久连接使得多数请求以管线化方式发送成为可能\r\n- 能够做到同时并行发送多个请求，不需要一个接一个地等待响应了\r\n\r\n## WebSocket与HTTP\r\n\r\n### 相同点\r\n\r\n- 基于TCP的可靠传输\r\n- 都是应用层协议\r\n\r\n### 不同点\r\n\r\n- WebSocket\r\n\r\n\t- 双向通信协议，模拟Socket协议\r\n\t- 可以双向发送或接受信息\r\n\r\n- HTTP\r\n\r\n\t- 单向发送信息或接受信息\r\n\t- 浏览器向服务器发起连接\r\n\t- 服务器预先不知道这个连接\r\n\r\n### 联系\r\n\r\n- web Socket建立握手时，数据是通过HTTP传输的\r\n- 建立之后不需要HTTP协议\r\n\r\n### Socket\r\n\r\n- 应用层与TCP/IP协议族通信的中间软件抽象层\r\n- 它是一组接口，提供一套调用TCP/IP协议的API\r\n- Socket是传输控制层接口，WebSocket是应用层协议。\r\n\r\n## DNS原理\r\n\r\n### 递归查询\r\n\r\n- 客户端问本地DNS服务器\r\n- 本地DNS服务器问根域名服务器\r\n- 根域名服务器问顶级域名服务器\r\n- 顶级域名服务器问主域名服务器\r\n\r\n### 迭代查询\r\n\r\n- 客户端询问本地DNS服务器\r\n- 客户端问根域名服务器\r\n- 客户端问顶级域名服务器\r\n- 客户端问主域名服务器\r\n\r\n### 域名系统\r\n\r\n- DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议\r\n\r\n\t- 区域传送时使用TCP\r\n\r\n\t\t- 辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动\r\n\t\t- 如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。\r\n\r\n\t- 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可\r\n\r\n### 查找顺序\r\n\r\n- 浏览器缓存\r\n\r\n\t- 根据本地DNS服务器的设置，采用递归或者迭代查询，直至解析完成。\r\n\r\n- 系统缓存\r\n\r\n\t- 检查自己本地的hosts文件是否有这个网址映射关系\r\n\r\n-  路由器缓存\r\n\r\n\t- 进入路由器缓存中检查\r\n\r\n- 本地DNS解析器缓存，是否有这个网址映射关系\r\n- 根据本地DNS服务器的设置，采用递归或者迭代查询，直至解析完成。\r\n\r\n## http/http2\r\n\r\n### http1.x缺点\r\n\r\n- 对同一个域名的并发连接最多只能2个，而平均一个页面有40个资源\r\n- 线头阻塞，同一个连接请求，需要一个接一个串行发送和接受\r\n- 请求和响应的头部信息大，无法压缩\r\n- 不能控制响应的优先级\r\n- 只能单项请求\r\n\r\n### http2\r\n\r\n- 传输内容使用二进制协议，在应用层和传输层之间增加了二进制分帧层\r\n- 使用帧作为最小传输单位\r\n\r\n\t- 所有的帧以固定的9个八位字节头部开头，随后是一个可变长的的有效载荷\r\n\r\n- 多路复用\r\n- 服务器推送\r\n- 优先级与依赖性\r\n- 可重置\r\n\r\n\t- RST_STREAM 帧来中断\r\n\r\n- 流量控制\r\n\r\n## HTTP与HTTPS的区别\r\n\r\n### HTTP\r\n\r\n- 运行在TCP上\r\n- 明文传输\r\n- 端口80\r\n- 工作在应用层\r\n\r\n### 证书+数字签名\r\n\r\n- 网站信息加密后通过第三方机构的私钥再次加密生成数字签名\r\n- 数字证书=网站信息+数字签名\r\n- 因为数字签名的存在，会导致客户端验证签名不匹配，这样就防止了中间人替换公钥的问题\r\n- 安全拿到服务器的公钥之后，使用公钥对随机生成的对称密钥进行加密传输给服务器，此后的数据将使用对称加密的方式进行传输\r\n\r\n### 对称加密\r\n\r\n- 加密和解密用同一个密钥的加密方式\r\n- 传输的密钥会被劫持\r\n\r\n### HTTPS\r\n\r\n- CA证书\r\n\r\n\t- 免费证书少\r\n\r\n- SSL/TLS加密\r\n\r\n\t- 加密后运行在TCP上\r\n\r\n- 端口443\r\n- 防止运营商劫持\r\n- 工作在传输层\r\n\r\n### 非对称加密\r\n\r\n- 私钥加密的内容，公钥可以解开\r\n- 公钥加密的内容，只有私钥可以解开\r\n- 私钥存在服务端，公钥发送到客户端，客户端用公钥加密\r\n- 这样的传输方式公钥容易被中间人篡改\r\n\r\n## 面向前端的CDN原理\r\n\r\n### （1）为什么需要CDN\r\n\r\n- 根本上的原因是\r\n\r\n\t- 网站需要提高访问速度，HTTP传输时延对web的访问速度的影响很大，在绝大多数情况下是起决定性作用的，这是由TCP/IP协议的一些特点决定的。物理层上的原因是光速有限、信道有限，协议上的原因有丢包、慢启动、拥塞控制等。\r\n\r\n- 最简单的做法\r\n\r\n\t- 当然就是多设置几个服务器，让终端用户离服务器“更近”。典型的例子是各类下载网站在不同地域不同运营商设置镜像站，或者是像Google那样设置多个数据中心。\r\n\t- 问题\r\n\r\n\t\t- 一是多地部署时的困难\r\n\t\t- 二是一致性没法保障\r\n\t\t- 三则是管理困难、成本很高\r\n\t\t- 实际上，在排除多地容灾等特殊需求的情况下，对大多数公司这种做法是不太可取的。\r\n\r\n- CDN\r\n\r\n\t- CDN是一种公共服务，他本身有很多台位于不同地域、接入不同运营商的服务器，而所谓的使用CDN实质上就是让CDN作为网站的门面，用户访问到的是CDN服务器，而不是直接访问到网站。由于CDN内部对TCP的优化、对静态资源的缓存、预取，加上用户访问CDN时，会被智能地分配到最近的节点，降低大量延迟，让访问速度可以得到很大提升。\r\n\r\n### （2）CDN的原理\r\n\r\n- CDN做了什么？\r\n\r\n\t- CDN做了两件事，一是让用户访问最近的节点，二是从缓存或者源站获取资源\r\n\r\n- 访问 CDN的过程\r\n\r\n\t- 流程图\r\n\r\n\t- 1.首先访问本地的 DNS ，如果没有命中，继续递归或者迭代查找，直到命中拿到对应的 IP 地址。 \r\n\r\n\t\t- 这个过程中，有一个 CNAME 的过程，我们访问 CDN 资源的地址一般是 a.cloud.com 或者类似的地址，是一个公司的访问 CDN 的专用地址。但是我们用的 cdn 的服务却是第三方的，即其实资源在他们的地址上比如 tencent.cdn。这时候就需要在 dns 查询的时候，需要把我们访问 a.cloud.com的地址映射到 tencent.cdn 的地址上，然后拿着映射后的地址再去走一遍 DNS 解析，成功之后才获取到第三方提供的全局负载均衡系统的 IP。再继续走后面的流程。\r\n\r\n\t- 2.拿到对应的 IP 地址之后服务器端发送请求到目的地址。注意这里返回的不直接是 cdn 服务器的 IP 地址，而是全局负载均衡系统的 IP 地址\r\n\t- 4.全局负载均衡系统会根据客户端的 IP地址和请求的 url 和相应的区域负载均衡系统通信\r\n\t- 5.区域负载均衡系统拿着这两个东西获取距离客户端最近且有相应资源的cdn 缓存服务器的地址，返回给全局负载均衡系统 \r\n\t- 6.全局负载均衡系统返回确定的 cdn 缓存服务器的地址给客户端。\r\n\t- 7.客户端请求缓存服务器上的文件\r\n\r\n- 通俗理解\r\n\r\n\t- 其实 CDN就是个放服务端资源的一个仓库。康师傅的泡面如果不是有家门口的小卖部，我们就得去人家的工厂门口拿。有了小卖部，我们只需要去一个卖康师傅或者有货的小卖部拿，就是这个道理。\r\n\r\n- 回源\r\n\r\n\t- 当 CDN 缓存服务器中没有符合客户端要求的资源的时候，缓存服务器会请求上一级缓存服务器，以此类推，直到获取到。最后如果还是没有，就会回到我们自己的服务器去获取资源。 那都有哪些时候会回源呢？没有资源，资源过期，访问的资源是不缓存资源等都会导致回源。\r\n\t- 专业术语\r\n\r\n\t\t- 边缘节点：指距离最终用户接入具有较少的中间环节的网络节点\r\n\r\n### （3）资源的过期如何判定？cdn 是如何更新数据的？\r\n\r\n- 资源过期时间就是根据我们老生常谈的请求头部来判定。\r\n- CDN更新数据分两种，主动（PUSH）和被动（PULL）。被动刚才我们已经提到过了，利用回源就可以被动在途经的 CDN 节点缓存数据。 而主动指的是，我们从服务器主动往 CDN 推送数据。\r\n\r\n## 【HTTPS】HTTPS与HTTP的区别，以及HTTP2\r\n\r\n### HTTP与HTTPS的区别\r\n\r\n- （1）HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。\r\n- （2）HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。\r\n- （3）HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。\r\n- （4）HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。\r\n\r\n### HTTPS中的对称加密与非对称加密\r\n\r\n- 非对称加密，XX网站生成公钥和私钥，公钥发给别人进行信息传输加密，私钥留在本地进行获取信息解码。公钥用于信息发送，私钥用于信息接收\r\n- 对称加密与非对称加密\r\n\r\n\t- 对称加密就是加密与解密的秘钥是相同的。而非对称加密就是公钥加密的内容，必须用私钥才能解密，私钥加密的内容，必须用公钥才能解密。\r\n\r\n- 加密图解\r\n\r\n- 加密过程\r\n\r\n\t- （1）server生成一个公钥和私钥，把公钥发送给第三方认证机构（CA）；\r\n\t- （2）CA把公钥进行MD5加密，生成数字签名；再把数字签名用CA的私钥进行加密，生成数字证书。CA会把这个数字证书返回给server；\r\n\t- （3）server拿到数字证书之后，就把它传送给浏览器；\r\n\t- （4）浏览器会对数字证书进行验证，首先，浏览器本身会内置CA的公钥，会用这个公钥对数字证书解密，验证是否是受信任的CA生成的数字证书；\r\n\t- （5）验证成功后，浏览器会随机生成对称秘钥，用server的公钥加密这个对称秘钥，再把加密的对称秘钥传送给server；\r\n\t- （6）server收到对称秘钥，会用自己的私钥进行解密，之后，它们之间的通信就用这个对称秘钥进行加密，来维持通信。\r\n\r\n### 谷歌2012年提出SPDY方案\r\n\r\n- SPDY可以说是综合了HTTPS和HTTP两者有点于一体的传输协议，主要解决：\r\n- （1）降低延迟\r\n\r\n\t- 针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。\r\n\t- 多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。\r\n\r\n- （2）请求优先级\r\n\r\n\t- 多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。\r\n\t- SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。\r\n\r\n- （3）header压缩\r\n\r\n\t- HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。\r\n\r\n- （4）基于HTTPS的加密协议传输\r\n- （5）服务端推送（server push）\r\n\r\n\t- 采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。\r\n\r\n- SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。\r\n\r\n### HTTP2：SPDY的升级版\r\n\r\n- 基于SPDY设计，与其不同之处\r\n\r\n\t- HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS\r\n\t- HTTP2.0 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE\r\n\r\n- HTTP2 新特性\r\n\r\n\t- 新的二进制格式（Binary Format）\r\n\r\n\t\t- HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。\r\n\r\n\t- 多路复用（MultiPlexing）\r\n\r\n\t\t- 即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。\r\n\t\t- 原理图\r\n\r\n\t- header压缩\r\n\r\n\t\t- HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。\r\n\r\n\t- 服务端推送（server push）\r\n\r\n## 【TCP、UDP】互联网协议\r\n\r\n### TCP 三次握手和四次挥手\r\n\r\n- 定义\r\n\r\n\t- 三次握手与四次挥手分别对应TCP连接建立过程与断开过程，先上TCP报文格式\r\n\r\n- 字段介绍\r\n\r\n\t- （1）序号\r\n\r\n\t\t- Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。\r\n\r\n\t- （2）确认序号\r\n\r\n\t\t- Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。\r\n\r\n\t- （3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等\r\n\r\n\t\t- （A）URG：紧急指针（urgent pointer）有效。\r\n\t\t- （B）ACK：确认序号有效。\r\n\t\t- （C）PSH：接收方应该尽快将这个报文交给应用层。\r\n\t\t- （D）RST：重置连接。\r\n\t\t- （E）SYN：发起一个新连接。\r\n\t\t- （F）FIN：释放一个连接。\r\n\r\n- 三次握手\r\n\r\n\t- 简明理解\r\n\r\n\t\t- 第一次握手：Client什么都不能确认；Server确认了对方发送正常\r\n\t\t- 第二次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：自己接收正常，对方发送正常\r\n\t\t- 第三次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：自己发送、接收正常，对方发送接收正常\r\n\r\n\t- 实际过程\r\n\r\n\t\t- A对B说：我的序号是x，我要向你请求连接；（第一次握手，发送SYN包，然后进入SYN-SEND状态）\r\n\t\t- B听到之后对A说：我收到你的序号x了，我给你返回一个x+1，我的序号是y，期待你下一句序号是y+1的话（意思就是收到了序号为y的话，即ack=y+1），同意建立连接。（第二次握手，发送ACK-SYN包，然后进入SYN-RCVD状态）\r\n\t\t- A听到B说同意建立连接之后，对B说：与确认你同意与我连接（ack=y+1,ACK=1,seq=x+1）。（第三次握手，A已进入ESTABLISHED状态）\r\n\t\t- B听到A的确认之后，也进入ESTABLISHED状态。\r\n\r\n\t- 为什么要有三次握手？\r\n\r\n\t\t- 两次握手的问题\r\n\r\n\t\t\t- 两次握手的问题在于服务器端不知道一个SYN是否是无效的\r\n\t\t\t- 假设只有两次握手，比如图中的1，2步，当A想要建立连接时发送一个SYN，然后等待ACK，结果这个SYN因为网络问题没有及时到达B，所以A在一段时间内没收到ACK后，在发送一个SYN，B也成功收到，然后A也收到ACK，这时A发送的第一个SYN终于到了B，对于B来说这是一个新连接请求，然后B又为这个连接申请资源，返回ACK，然而这个SYN是个无效的请求，A收到这个SYN的ACK后也并不会理会它，而B却不知道，B会一直为这个连接维持着资源，造成资源的浪费\r\n\r\n\t\t- 三次握手可以保证任何一次握手出现问题，都是可以被发现或补救的\r\n\r\n\t\t\t- 因为客户端会给服务器回复第二次握手，也意味着服务器会等待客户端的第三次握手，如果第三次握手迟迟不来，服务器便会认为这个SYN是无效的，释放相关资源。\r\n\r\n\t\t- 一句话：“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”\r\n\r\n- 四次挥手\r\n\r\n\t- 实际过程\r\n\r\n\t\t- 1.A与B交谈结束之后，A要结束此次会话，对B说：我要关闭连接了（seq=u,FIN=1）。（第一次挥手，A进入FIN-WAIT-1）\r\n\t\t- 2.B收到A的消息后说：确认，你要关闭连接了。（seq=v,ack=u+1,ACK=1）（第二次挥手，B进入CLOSE-WAIT）\r\n\t\t- 3.A收到B的确认后,等了一段时间，因为B可能还有话要对他说。（此时A进入FIN-WAIT-2）\r\n\t\t- 4.B说完了他要说的话（只是可能还有话说）之后，对A说，我要关闭连接了。（seq=w, ack=u+1,FIN=1，ACK=1）(第三次挥手)\r\n\t\t- 5.A收到B要结束连接的消息后说：已收到你要关闭连接的消息。（seq=u+1,ack=w+1,ACK=1）(第四次挥手，然后A进入CLOSED)\r\n\t\t- 6.B收到A的确认后，也进入CLOSED。\r\n\r\n\t-  为什么要四次挥手？\r\n\r\n\t\t- 根本原因是，一方发送FIN只表示自己发完了所有要发的数据，但还允许对方继续把没发完的数据发过来。\r\n\r\n### TCP、UDP协议区别\r\n\r\n- 1，TCP是面向连接的协议，UDP是无连接协议； \r\n\r\n\t- 对于面向连接的： 两个人打电话时，双方确认并建立连接后才能进行通信。 \r\n\t- 对于面向无连接的：在邮局寄信时，你只需要将信放在邮筒里，不需要给收件人通知，收件人也不知道你给他寄信了\r\n\r\n- 2，TCP无界，UDP有界； \r\n\r\n\t- TCP通过字节流传输，即TCP将应用程序看成是一连串的无结构的字节流。每个TCP套接口有一个发送缓冲区，如果字节流太长时，TCP会将其拆分进行发送。当字节流太短时，TCP会等待缓冲区中的字节流达到一定程度时再构成报文发送出去，TCP发给对方的数据，对方在收到数据时必须给矛确认，只有在收到对方的确认时，本方TCP才会把TCP发送缓冲区中的数据删除。 \r\n\t- 而UDP传输报文的方式是由应用程序控制的，应用层交给UDP多长的报文，UDP照样发送，既不拆分，也不合并，而是保留这些报文的边界，即一次发送一个报文。 \r\n\r\n- 3，TCP可靠，UDP不可靠； \r\n- 4，TCP有序，UDP无序； \r\n\r\n\t- 消息在传输过程中可能会乱序，后发送的消息可能会先到达，TCP会对其进行重排序，UDP不会。\r\n\r\n- 5，TCP有流量控制（以及拥塞处理），UDP没有； \r\n\r\n\t- 流量控制\r\n\r\n\t\t- TCP利用滑动窗口机制在TCP连接上实现对发送方的流量控制， 如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。 \r\n\t\t- 滑动窗口\r\n\r\n\t- 拥塞处理\r\n\r\n\t\t- 防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。 \r\n\r\n\t- 拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接受数据。而前者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。\r\n\t- 当出现网络抖动时，TCP会自觉降低发送速度，他会努力维护次序，但udp依然保持速度不变\r\n\r\n- 应用场景\r\n\r\n\t- TCP应用场景\r\n\r\n\t\t- 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。\r\n\r\n\t- UDP应用场景\r\n\r\n\t\t- 效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。\r\n\r\n## WEBSOCKET \r\n\r\n### （1）基于 HTTP 协议的方案的本质缺陷\r\n\r\n- 在浏览器与服务器通信间，传统的 HTTP 请求在某些场景下并不理想，比如实时聊天、实时性的小游戏等等，其面临主要两个缺点：\r\n\r\n\t- 无法做到消息的「实时性\r\n\t- 服务端无法主动推送信息\r\n\r\n- 其基于 HTTP 的主要解决方案有：\r\n\r\n\t- 基于 ajax 的轮询：客户端定时或者动态相隔短时间内不断向服务端请求接口，询问服务端是否有新信息；其缺点也很明显：多余的空请求（浪费资源）、数据获取有延时；\r\n\t- Long Poll：其采用的是阻塞性的方案，客户端向服务端发起 ajax 请求，服务端挂起该请求不返回数据直到有新的数据，客户端接收到数据之后再次执行 Long Poll；该方案中每个请求都挂起了服务器资源，在大量连接的场景下是不可接受的；\r\n\r\n- 本质缺陷即「被动性」，服务端无法下推消息，仅能由客户端发起请求不断询问是否有新的消息，同时对于客户端与服务端都存在性能消耗。\r\n\r\n### （2）WebSocket 是 HTML5 中提出的新的网络协议标准\r\n\r\n- 初步了解\r\n\r\n\t- WebSocket 是 HTML5 开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。 \r\n\t-  在 WebSocket API 中，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。\r\n\r\n- 特点\r\n\r\n\t- （1）建立于 TCP 协议之上的应用层；\r\n\t- （2）一旦建立连接（直到断开或者出错），服务端与客户端握手后则一直保持连接状态，是持久化连接；\r\n\t- （3）服务端可通过实时通道主动下发消息；\r\n\t- （4）数据接收的「实时性（相对）」与「时序性」；\r\n\r\n### （3）Websocket实践\r\n\r\n- 浏览器提供原生对象\r\n\r\n\t- 在浏览器中使用 Websocket 非常简单，在支持 Websocket 的浏览器中提供了原生的 WebSocekt 对象，其中对于消息的接收与数据帧处理在浏览器中已经封装好了。\r\n\r\n- 服务端实现\r\n\r\n\t- 使用 Websocket 需要服务端与客户端都提供相应能力，这里基于 Node.js 和 ws 简单建立一个服务端 Websocket 接口：\r\n\r\n\t- （1）在 8080 端口中监听了 express 的请求与 Websocket 请求，因为他们本身协议（http(s):// 与 ws(s)://）不同，因此不会冲突。\r\n\t- （2）同时在代码中可以看到其首先监听了 connection 事件（建立连接触发），在其回调中监听 message 事件（接收到消息）并立即 send 一条数据。\r\n\r\n- 浏览器实现\r\n\r\n\t- Websocket API\r\n\r\n\t\t- 浏览器中提供了原生类 WebSocket ，使用 new 关键字实例化它：\r\n\r\n\t\t\t- new  WebSocket(String url,optional String | [] protocols);\r\n\r\n\t\t- （1）接收两个参数：\r\n\r\n\t\t\t- url 表示需要连接的地址，比如：ws://localhost:8080；\r\n\t\t\t- protocols 可选参数，可以是一个字符串或者一个数组，用来表示子协议，这样做可以让一个服务器实现多种 WebSocket 子协议；\r\n\r\n\t\t- （2）实例化对象提供两个方法：\r\n\r\n\t\t\t- send 接收一个 String|ArrayBuffer|Blob 数据，作为数据发送到服务端；\r\n\t\t\t- close 接收一个（可选）的 code（关闭状态号，默认为 1000） 与一个（可选）的字符串（表示断开原因），客户端主动断开连接；\r\n\r\n\t\t- （3）连接状态：\r\n\r\n\t\t\t- WebSocket 类提供了一些常量表示连接状态：\r\n\r\n\t\t\t\t- WebSocket.CONNECTING 0 连接还没开启；\r\n\t\t\t\t- WebSocket.OPEN 1 连接已开启并准备好进行通信；\r\n\t\t\t\t- WebSocket.CLOSING 3 连接正在关闭的过程中；\r\n\t\t\t\t- WebSocket.CLOSED 4 连接已经关闭，或者连接无法建立；\r\n\r\n\t\t\t- WebSocket 的实例对象中提供了 readyState 属性来判断当前状态；\r\n\r\n\t\t- （4）实例化对象中可以监听到以下事件：\r\n\r\n\t\t\t- open 连接打开的回调事件，这时 readyState 变为 OPEN；\r\n\t\t\t- message 收到消息的回调事件，同时回调函数接收到一个 MessageEvent 数据；\r\n\t\t\t- close 连接关闭的回调事件，这时 readyState 变为 CLOSED；\r\n\t\t\t- error 建立与连接过程发生错误的回调事件；\r\n\r\n\t- 具体代码\r\n\r\n\t- 控制台中可以看到：\r\n\r\n\t\t- 首先触发 open 事件，之后每次发送数据服务端都会回复数据，因此触发了 message 事件，当发送 10 次之后浏览器主动断开连接，因此触发 close 事件；这里最后一次发送之后未收到服务端回复也是因为客户端立即断开了连接；\r\n\r\n- 事件与数据\r\n\r\n\t- 对 WebSocket 实例监听事件有两种方式，这里以 message 事件为例：\r\n\r\n\t\t- 对 onmessage 属性直接赋值，正如以上：ws.onmessage = function () {};；\r\n\t\t- 使用 addEventListener 监听事件，如：ws.addEventListener('message', function () {})；\r\n\r\n\t- 在 message 回调函数中得到 MessageEvent 类型参数 e ，我们需要的数据可以通过 e.data 获取；\r\n\t- 需要注意的一点是：\r\n\r\n\t\t- 不论服务端与客户端，其接受到的数据都是序列化后的字符串（当然也有 ArrayBuffer|Blob 类型数据），很多时候我们需要解析处理数据，比如 JSON.parse(e.data)；\r\n\r\n- 连接稳定性\r\n\r\n\t- 由于网络环境复杂，某些情况会出现断开连接或者连接出错，需要我们在 close 或者 error 事件中监听非正常断开并重连；\r\n\t- 由于一些原因在 error 时浏览器并不会响应回调事件，因此稳妥的做法还需要在 open 之后开启一个定时任务去判断当前的连接状态 readyState ，在出现异常情况下尝试重连；\r\n\r\n- 心跳\r\n\r\n\t- websocket规范定义了心跳机制，一方可以通过发送ping（opcode 0x9）消息给另一方，另一方收到ping后应该尽可能快的返回pong（0xA）。\r\n\t- 心跳机制是用于检测连接的对方在线状态，因此如果没有心跳，那么无法判断一方还在连接状态中，一些网络层比如 nginx 或者浏览器层会主动断开连接，\r\n\t- 在 JavaScript 中，WebSocket 并没有开放 ping/pong 的 API ，虽然浏览器自带了心跳处理，然而不同厂商的实现也不尽相同，因此需要在我们开发时候与服务端约定好一个自实现的心跳机制；\r\n\t- 比如浏览器中，检测到 open 事件后，启动一个定时任务，每次发送数据 0x9 给服务端，而服务端返回 0xA 作为响应；\r\n\t- 实践下来，心跳的定时任务一般是相隔 15-20 秒发送一次。\r\n\r\n### （4）网络协议\r\n\r\n- WebSocket与网络协议的关系\r\n\r\n\t- 前文说到，Websocket 是建立与 TCP 之上，那么其与 HTTP 协议有和关系呢？\r\n\t- Websocket 连接分为建连阶段与连接阶段，在建立连接阶段借助于 HTTP ，而在连接阶段则与 HTTP 无关。\r\n\r\n- 建立连接阶段\r\n\r\n\t- 从浏览器的 Network 中，找到 ws 连接，可以看到：\r\n\r\n\t- 这是一个标准的 HTTP 请求，相比于我们常见的 HTTP 请求协议，请求头中多了几个字段：\r\n\r\n\t\t- Connection 为 Upgrade ，Upgrade 为 websocket ，表示告知 Nginx 与 Apache 等服务器该次连接并非为 HTTP 连接，实质上是一个 websocket ，因此服务器会转发到相应的 websocket 任务处理；\r\n\t\t- Sec-WebSocket-Key 是一个 Base64 encode 的值，由浏览器随机生成的，用于验证服务器连接的正确性；\r\n\t\t- Sec-WebSocket-Versio 表示为使用的 websocket 服务版本；\r\n\r\n\t- 响应头中：\r\n\r\n\t\t- 可以看到其返回状态码为 101 ，表示切换协议；\r\n\t\t- Upgrade 与 Connection 用于回复客户端表示已经切换协议成功；\r\n\t\t- Sec-WebSocket-Accept 字段与 Sec-WebSocket-Key 相对应，用于验证服务的正确性；\r\n\r\n- 连接阶段\r\n\r\n\t- 当通过 HTTP 建立连接握手后，接下来则是真正的 Websocket 连接了，其基于 TCP 收发数据，Websocket 封装并开放接口。\r\n\r\n- WSS\r\n\r\n\t- 在 HTTP 协议中，很多时候为了加密与安全需要使用 HTTPS 请求（HTTP + TCL）；相应的，在 Websocket 协议中，也是可以使用加密传输的 —— wss ，比如 wss://localhost:8080。\r\n\t- 使用的也是与 HTTPS 一样的证书，在这里一般是交由 Nginx 等服务层去做证书处理。\r\n\r\n",be={data:function(){return{MainComponent:ge}}},he=be,ye=Object(m["a"])(he,me,de,!1,null,"386b2e07",null),fe=ye.exports,ve=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},Se=[],_e="# 前后端通信\r\n## 常用请求方法\r\n### HTTP 0.9\r\n- GET\r\n### HTTP1.0\r\n- POST\r\n- HEAD\r\n\t- 描述\r\n\t\t- HEAD方法和GET方法一样，知识不返回豹纹的主体部分，用于确认URI的有效性及资源更新的日期时间等。\r\n\t- 具体\r\n\t\t- （1）可以在不获取资源的情况下很快地就能了解到资源的情况，比如其类型，其文件大小，\r\n\t\t- （2）也可以通过响应码查看是否存在该资源，\r\n\t\t- （3）也可以检测资源是否被修改了。\r\n\t- HEAD方法和GET方法的区别： GET方法有实体，HEAD方法无实体。\r\n### HTTP1.1\r\n- PUT\r\n\t- 描述\r\n\t\t- PUT方法用来传输文件，就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存在请求URI指定的位置。但是HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全问题，故一般不用。\r\n\t- 什么时候用POST或PUT？\r\n\t\t- 取决于这个REST服务的行为是否是idempotent（等幂）的（一个方法重复执行多次，产生的效果是一样的）\r\n\t\t- 假如我们发送两个http://superblogging/blogs/post/Sample请求，服务器端是什么样的行为？如果产生了两个博客帖子，那就说明这个服务不是idempotent的，因为多次使用产生了副作用了嘛；如果后一个请求把第一个请求覆盖掉了，那这个服务就是idempotent的。前一种情况，应该使用POST方法，后一种情况，应该使用PUT方法。\r\n- DELETE\r\n\t- 描述\r\n\t\t-  指明客户端想让服务器删除某个资源，与PUT方法相反，按URI删除指定资源\r\n\t- 响应\r\n\t\t- （1）如果响应里包含描述成功的实体，响应应该是200（Ok）\r\n\t\t- （2）如果DELETE动作没有通过，应该以202（已接受）响应\r\n\t\t- （3）如果DELETE方法请求已经通过了，但响应不包含实体，那么应该以204（无内容）响应。\r\n- CONNECT\r\n\t- 描述\r\n\t\t- \r\nCONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。\r\n- OPTIONS\r\n\t- 描述\r\n\t\t- OPTIONS 方法请求 Web 服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法。(有些服务器可能只支持对一些特殊类型的对象使用特定的操作)。\r\n\t\t- 通过使用 OPTIONS，客户端可以在与服务器进行交互之前，确定服务器的能力，这样它就可以更方便地与具备不同特性的代理和服务器进行互操作了。\r\n\t\t- 这为客户端应用程序提供了一种手段，使其不用实际访问那些资源就能判定访问各种资源的最优方式。\r\n- TRACE\r\n\t- 描述\r\n\t\t- \r\nTRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。\r\n\t\t- TRACE 响应的 Content-Type 为 message/http，状态为 200 OK。\r\n\t- 原理\r\n\t\t- \r\nTRACE 请求会在目的服务器端发起一个 环回 诊断。行程最后一站的服务器会弹回一条 TRACE 响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看在所有中间 HTTP 应用程序组成的请求 / 响应链上，原始报文是否，以及如何被毁坏或修改过。\r\n### HTTP1.1 扩展\r\n- PATCH\r\n\t- 描述\r\n\t\t- PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：\r\n\t\t\t- PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。\r\n\t\t\t- 当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。\r\n## GET、POST方法区别\r\n### （1）GET在浏览器回退时是无害的，而POST会再次提交请求。\r\n### （2）GET产生的URL地址可以被Bookmark，而POST不可以。\r\n### （3）GET请求会被浏览器主动cache，而POST不会，除非手动设置。\r\n### （4）GET请求只能进行url编码，而POST支持多种编码方式。\r\n### （5）GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。\r\n### （6）GET请求在URL中传送的参数是有长度限制的，而POST么有。\r\n### （7）对参数的数据类型，GET只接受ASCII字符，而POST没有限制。\r\n### （8）GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。\r\n### （9）GET参数通过URL传递，POST放在Request body中。\r\n### （10）GET产生一个TCP数据包；POST产生两个TCP数据包。\r\n- 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；\r\n- 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。\r\n## 常用content-type类型\r\n### （1）application/x-www-form-urlencoded \r\n- 描述\r\n\t- 1）浏览器的原生form表单\r\n\t- 2） 提交的数据按照 key1=val1&key2=val2 的方式进行编码，key和val都进行了URL转码\r\n- 具体\r\n### （2）multipart/form-data\r\n- 描述\r\n\t- 主要用于上传文件。（使用表单上传文件时，必须让 form 的 enctype 等于这个值。）\r\n首先生成一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。\r\n\t- 消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 --boundary 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。\r\n\t- 如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 --boundary-- 标示结束。\r\n- 具体\r\n### （3）application/json\r\n- 描述\r\n\t- Json格式⽀支持比键值对复杂地多的数据，适合restful的接⼝口。\r\n- 具体\r\n### （4）text/html、text/plain、text/xml\r\n- HTML格式、纯文本格式、XML格式\r\n## 常见状态码含义\r\n### 1xx\r\n- 100（Continue/继续）\r\n\t- 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。\r\n- 101（Switching Protocols/切换协议）\r\n\t- 请求者已要求服务器切换协议，服务器已确认并准备切换。主要用于websocket，也可以用于http2的升级。\r\n### 2xx\r\n- 200（OK/正常）\r\n\t- 服务器已经成功处理了请求。通常，这表示服务器提供了请求的网页。\r\n- 201（Created/已创建）\r\n\t- 请求成功并且服务器创建了新的资源\r\n- 202（Accepted/已接受）\r\n\t- 服务器已接受请求，但尚未处理\r\n- 203 (Non-Authoritative Information/非官方信息)\r\n\t- 服务器已经成功处理了请求，但返回的信息可能来自另一来源\r\n- 204（NO Content/无内容）\r\n\t- 服务器成功处理了请求，但没有返回任何内容\r\n- 205 (Reset Content/重置内容)\r\n\t- 服务器成功处理了请求，但没有返回任何内容\r\n- 206 (Partial Content/局部内容)\r\n\t- 该状态码表示客户端进行了请求，请求资源的某一部分，而服务器成功执行了这部分的 GET 请求，响应报文中包含由 Content-Range 指定范围的实体内容\r\n### 3xx\r\n- 300（Multiple Choices/多重选择）\r\n\t-  针对请求，服务器可执行多种操作。服务器可根据请求者（user agent）选择一项操作，或提供操作列表供请求者选择。\r\n- 301（Moved Permanently/永久重定向）\r\n\t- 永久性重定向\r\n- 302（Found/临时重定向）\r\n\t- 临时性重定向\r\n- 303 （See Other/参见其他信息）\r\n\t- 该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。\r\n\t- 303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。 \r\n- 304（Not Modified/未修改）\r\n\t- 自动上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页的内容（协商缓存）\r\n- 305（Use Proxy/使用代理）\r\n\t- 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理\r\n- 307（Temporary Redirect /临时重定向）\r\n\t- 用于HSTS跳转。全称HTTP严格传输安全（HTTP Strict Transport Security，縮寫：HSTS）。功能是要求浏览器下次访问该站点时使用HTTPS来访问，而不再需要先是HTTP再转HTTPS。这样可以避免SSL剥离攻击，具体使用方法是在服务器响应头中添加 Strict-Transport-Security，可以设置 max-age\r\n\t- SSL剥离攻击（攻击HTTPS）\r\n\t\t- 描述\r\n\t\t\t- 即攻击者在用户使用http访问的过程中进行攻击，对服务器冒充自己是用户，在攻击者和服务器中使用https访问，在用户和服务器中使用http访问。\r\n\t\t- 另一种攻击号称安全的HTTPS的方法是：SSL挟持\r\n\t\t\t- 大概就是信任第三方的安全证书，这点被利用于代理软件监听https。\r\n### 4xx\r\n- 400（Bad Request/错误请求）\r\n\t- 服务器不理解请求的语法\r\n- 401（Unauthorized/未验证）\r\n\t- 请求要求身份验证。对于需要登录的网页，服务器可能返回此响应\r\n- 403（Forbidden/禁止）\r\n\t- 没有权限请求，表示除非拥有授权，否则服务器拒绝提供所请求的资源。\r\n- 404（Not Found/未找到）\r\n\t- 服务器找不到请求的网页\r\n- 405 (Method Not Allowed/方法未允许)\r\n\t- 禁用请求中指定的方法\r\n- 406 (Not Acceptable/无法访问)\r\n\t- 表示请求资源的MIME类型与客户端中Accept头信息中指定的类型不一致，无法使用请求的内容特性响应请求的网页\r\n- 407 (Proxy Authentication Required/代理服务器认证要求)\r\n\t- 与401状态有些相似，只是这个状态用于代理服务器。该状态指出客户端必须通过代理服务器的认证。代理服务器返回一个Proxy-Authenticate响应头信息给客户端，这会引起客户端使用带有Proxy-Authorization请求的头信息重新连接。\r\n- 408 (Request Timeout/请求超时)\r\n\t- 是指服务端等待客户端发送请求的时间过长。\r\n- 409 (Conflict/冲突)：\r\n\t- 该状态通常与PUT请求一同使用，常被用于试图上传版本不正确的文件时。\r\n- 410 (Gone/已经不存在)\r\n\t- 告诉客户端所请求的文档已经不存在并且没有更新的地址。410状态不同于404，410是在指导文档已被移走的情况下使用，而404则用于未知原因的无法访问。\r\n- 411 (Length Required/需要数据长度)\r\n\t- 服务器不接受不含有效内容长度标头字段的请求，除非客户端发送Content-Length头信息指出发送给服务器的数据的大小。\r\n- 412 (Precondition Failed/未满足前提条件)\r\n\t- 服务器未满足请求者在请求者设置的其中一个前提条件\r\n- 413 (Request Entity Too Large/请求实体过大)\r\n\t- 服务器无法处理请求，因为请求实体过大，超出了服务器的处理能力\r\n- 414 (Request URI Too Long/请求URI过长)\r\n\t- 请求的URI（通常为网址）过长，服务器无法处理\r\n- 415 (Unsupported Media Type/不支持的媒体类型)\r\n\t- 请求的格式不受请求页面的支持\r\n- 416 (Requested Range Not Satisfiable/请求范围无法满足)\r\n\t- 表示客户端包含了一个服务器无法满足的Range头信息的请求，如果页面无法提供请求的范围，则服务器会返回此状态码\r\n- 417 (Expectation Failed/期望失败)\r\n\t- 如果服务器得到一个带有100-continue值的Expect请求头信息，这是指客户端正在询问是否可以在后面的请求中发送附件。在这种情况下，服务器也会用该状态(417)告诉浏览器服务器不接收该附件或用100 (SC_CONTINUE)状态告诉客户端可以继续发送附件\r\n### 5xx\r\n- 500 (Internal Server Error/服务器内部错误)\r\n\t- 服务器遇到错误，无法完成请求\r\n- 501 (Not Implemented/未实现)\r\n\t- 服务器不具备完成此请求中要求的功能。例如，服务器无法识别请求方法时可能会返回此代码，或者客户端执行了如PUT这样的服务器并不支持的命令。\r\n- 502 (Bad Gateway/错误的网关)\r\n\t- 服务器作为网关或代理，从上游服务器无法收到无效响应\r\n- 503 (Service Unavailable/服务器不可用)\r\n\t- 服务器目前无法使用（由于超载或者停机维护）。通常，这只是暂时状态\r\n- 504 (Gateway Timeout/网关超时)\r\n\t- 服务器作为网关代理，但是没有及时从上游服务器收到请求\r\n- 505 (HTTP Version Not Supported/不支持的 HTTP 版本)\r\n\t- 服务器并不支持在请求中所标明 HTTP 版本\r\n",ke={data:function(){return{MainComponent:_e}}},je=ke,we=Object(m["a"])(je,ve,Se,!1,null,"05cbc232",null),xe=we.exports,Te=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[n._v("\n    1\n")])},Ce=[],Me={},Pe=Me,Oe=Object(m["a"])(Pe,Te,Ce,!1,null,"0742bb52",null),Ee=Oe.exports,Re=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[n._v("\n    1\n")])},Ne=[],Ae={},De=Ae,Ie=Object(m["a"])(De,Re,Ne,!1,null,"4562bada",null),Je=Ie.exports,Le=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[n._v("\n    1\n")])},He=[],Fe={},Ue=Fe,qe=Object(m["a"])(Ue,Le,He,!1,null,"994aec58",null),Be=qe.exports,We=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[n._v("\n    1\n")])},Ve=[],Ge={},ze=Ge,$e=Object(m["a"])(ze,We,Ve,!1,null,"ed331dd6",null),Xe=$e.exports,Ke=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[n._v("\n    1\n")])},Qe=[],Ye={},Ze=Ye,na=Object(m["a"])(Ze,Ke,Qe,!1,null,"5f725856",null),ta=na.exports,ra=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[n._v("\n    1\n")])},ea=[],aa={},oa=aa,sa=Object(m["a"])(oa,ra,ea,!1,null,"357e3f97",null),ia=sa.exports,la={mixins:[k["c"]],components:{m1:fe,m2:xe,m3:Ee,m4:Je,m5:Be,m6:Xe,m7:ta,m8:ia},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"http基本",value:"m1"},{label:"前后端通信",value:"m2"}]}}},ca=la,pa=Object(m["a"])(ca,pe,ue,!1,null,"25404097",null),ua=pa.exports,ma=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[r("div",[r(""+n.tab,{tag:"component"})],1)])},da=[],ga=function(){var n=this;return n.$createElement,n._self._c,n._m(0)},ba=[function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[r("div",[r("a",{attrs:{href:"https://blog.csdn.net/aSuncat/article/details/88674643",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://blog.csdn.net/aSuncat/article/details/88674643")]),r("br"),r("a",{attrs:{href:"https://www.cnblogs.com/chenwenhao/p/11258895.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://www.cnblogs.com/chenwenhao/p/11258895.html")])]),r("div",{staticClass:"htmledit_views"},[r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("1、")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("v-model是什么？ vue中标签怎么绑定事件？")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("答：")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("v-model这个指令只能用在表单元素上，可以用他进行双向数据绑定。")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("<input @click=doLog() />")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[n._v("2"),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("mvvm框架是什么？")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("说说对双向数据绑定的理解？")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("jquery）的区别是什么？哪些场景适合？")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("mvvm")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("的")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("m")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("v经过数据改变后的html、")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vm")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("就是")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("连接数据和视图，")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("用来实现双向绑定")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(":一个变了另外一个跟着变了，例如：视图一个绑定了模型的节点有变化，模型对应的值会跟着变")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vue数据驱动，通过数据来显示视图层而不是节点操作。")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("场景：数据操作比较多的场景，更加便捷")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("3、自定义指令")]),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vue对象的directive方法里面有两个参数，一个是指令名称，另外一个是函数。组件内定义指令（局部定义指令）：directives")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("bind（绑定事件触发）、inserted(节点插入的时候触发)、update（组件内相关更新）、")]),r("span",{staticStyle:{color:"rgb(85,85,85)"}},[n._v("componentUpdated")]),r("span",{staticStyle:{color:"rgb(85,85,85)"}},[n._v("（")]),r("span",{staticStyle:{color:"rgb(85,85,85)"}},[n._v("被绑定元素所在模板完成一次更新周期时调用")]),r("span",{staticStyle:{color:"rgb(85,85,85)"}},[n._v("）、")]),r("span",{staticStyle:{color:"rgb(85,85,85)"}},[n._v("unbind")]),r("span",{staticStyle:{color:"rgb(85,85,85)"}},[n._v("（")]),r("span",{staticStyle:{color:"rgb(85,85,85)"}},[n._v("只调用一次，指令与元素解绑时调用")]),r("span",{staticStyle:{color:"rgb(85,85,85)"}},[n._v("）")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("el、binding")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("4、")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("4种vue当中的指令和它的用法？")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("答：")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("v-if：判断是否隐藏；v-for：数据循环出来；v-bind:class：绑定一个属性；v-model：实现双向绑定")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("5、")]),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("vue生命周期的理解？")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("/后：\n        在beforeCreated阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("/后：当data变化时，会触发beforeUpdate和updated方法。")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("6、")]),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("\n          vue 组件")]),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("答：首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("使用")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("Vue")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(".component")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("方法注册组件。子组件需要数据，可以在")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("props")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("emit")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("方法。")])]),r("p",[r("strong",[n._v("7、"),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("Vue.js内置的指令，用什么开头？")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("v-开头的")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[n._v("8、CSS隐藏元素的几种方法？说出他们的区别")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}}),r("p",{staticStyle:{background:"rgb(255,255,255)"}}),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("\n      opacity:0 透明度为0，占物理位置\n    ")]),r("p",{staticStyle:{background:"rgb(255,255,255)"}}),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("\n      9、"),r("strong",[n._v("CSS清除浮动的几种方法（至少两种）")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("clear属性的空元素")]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("CSS的overflow属性；")]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("\n      CSS的:after伪元素"),r("span",{staticStyle:{color:"rgb(44,44,44)"}}),n._v("；\n    ")]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[n._v("10、例举3种强制类型转换?")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("parseInt,parseFloat,number")]),r("h4",[r("strong",[n._v("11、")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("pop")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("()")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}}),r("span",{staticStyle:{color:"rgb(51,51,51)"}}),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("push")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}}),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("shift")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("()")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}}),r("span",{staticStyle:{color:"rgb(51,51,51)"}}),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("unshift")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("() ")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("有什么区别")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("?")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}}),r("p",{staticStyle:{background:"rgb(255,255,255)"}}),r("p",{staticStyle:{background:"rgb(255,255,255)"}}),r("p",[n._v("12、"),r("strong",[n._v("提交表单，有几种方式")])]),r("p",[r("span",{staticStyle:{color:"rgb(75,75,75)",background:"rgb(255,255,255)"}},[n._v("submit")]),n._v("提交，"),r("span",{staticStyle:{color:"rgb(75,75,75)",background:"rgb(255,255,255)"}},[n._v("Ajax提交form表单")])]),r("p",[r("strong")]),r("p",[r("strong",[n._v("13、定义一个div，让其在页面中，垂直居中显示")])]),r("p"),r("p"),r("p"),r("p"),r("p"),r("p",[n._v("height:200px;")]),r("p",[n._v("margin-left:-250px;")]),r("p",[n._v("margin-top:-100px;")]),r("p",[n._v("background:red;")]),r("p",[n._v("}")]),r("p"),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("1")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("4")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("active-class是哪个组件的属性？嵌套路由怎么定义？")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vue-router模块的router-")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("link")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("组件。")]),r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("children数组来定义子路由")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("15")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vue-router的动态路由？怎么获取传过来的动态参数？")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("router目录下的index.js文件中，对path属性加上/:")]),r("span",{staticStyle:{color:"rgb(0,134,179)"}},[n._v("id")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("router对象的params.")]),r("span",{staticStyle:{color:"rgb(0,134,179)"}},[n._v("id")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("16")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vue-router有哪几种导航钩子？")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("router.beforeEach(")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("to")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(",")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("from")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(",")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("next")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(")，")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("作用：跳转前进行判断拦截。第二种：组件内的钩子；第三种：单独路由独享组件")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("1")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("7")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vue-router是什么？它有哪些组件？")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vue用来写路由一个插件。router-link、router-")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("view")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("18、")]),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("vuex的？")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vuex可以理解为一种")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("状态管理的")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("开发模式或")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("者")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("框架")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("，")]),r("span",{staticStyle:{color:"rgb(85,85,85)",background:"rgb(255,255,255)"}},[n._v("data中的属性需要共享给其他vue组件使用")]),r("span",{staticStyle:{color:"rgb(85,85,85)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(51,51,51)"}}),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[r("span",{staticStyle:{"font-family":"'华文仿宋'"}},[n._v("为")]),n._v("state")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("store中； 改变状态的方式是提交mutations，这是个同步的事物；\n        异步逻辑应该封装在action中")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("。")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("19、")]),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("vuex有哪几种属性？")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(" State、 Getter、Mutation 、")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("Action")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}}),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("Module")])])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}},[n._v("state => 基本数据")]),r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}},[n._v("(")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("数据源存放地")]),r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}},[n._v(")")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[r("br")]),r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}},[n._v("getters => 从基本数据派生")]),r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[r("br")]),r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[r("br")]),r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[r("br")]),r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}},[n._v("modules => 模块化Vuex")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}},[n._v("20、")]),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("5、Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vuex 的")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("state")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("里。")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("action里，方便复用")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("21")]),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("axios是什么？怎么使用？")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("npm install axios -")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("-save")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("装好，")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("js中使用")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("import")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(".")]),r("span",{staticStyle:{color:"rgb(0,134,179)"}},[n._v("get")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(".post。返回在.then函数中如果成功，失败则是在.")]),r("span",{staticStyle:{color:"rgb(0,134,179)"}},[n._v("catch")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("函数中")])]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}})])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("22")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("axios+tp5进阶中，调用axios.post(‘api/user’)是进行的什么操作？axios.put(‘api/user/8′)呢？")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("答：添加用户操作，更新操作。")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("23")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("RESTful API？怎么使用?")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("api的标准，无状态请求。请求的路由地址是固定的，")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("tp5则先路由配置中把资源路由配置好。标准有：")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}}),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(".post")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}}),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(".put")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}}),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(".delete")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("24")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vuex是什么？怎么使用？哪种功能场景使用它？")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vue框架中状态管理。在main.js引入store，注入。")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("store")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(".js")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("….. ")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("export")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("25")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("、")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("webpack?")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}})])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("答：")]),r("span",{staticStyle:{color:"rgb(47,47,47)",background:"rgb(255,255,255)"}},[n._v("WebPack可以看做是")]),r("strong",[r("span",{staticStyle:{color:"rgb(47,47,47)",background:"rgb(255,255,255)"}})]),r("span",{staticStyle:{color:"rgb(47,47,47)",background:"rgb(255,255,255)"}},[n._v("JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(".vue文件的一个加载器，")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("将")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("template/")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("js")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("/style转换成")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("js")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("模块。")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("用途：")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("js")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("es6、style样式可以scss或less、template可以加jade等")])]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}})])]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}})])]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("26、说几个ajax返回error的原因")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("1、")]),r("span",{staticStyle:{color:"rgb(75,75,75)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("dataType")]),r("span",{staticStyle:{color:"rgb(75,75,75)",background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("dataType类型和前台写的不一致会跳入error")])]),r("p",[r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("jquery1.4之后对json的格式要求非常严格，json格式错误也会跳入error")])]),r("p",[r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("2、")]),r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("data不能不写")])]),r("p",[r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v('data为空也一定要传"{}"；不然返回的是xml格式的。')])]),r("p",[r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("3")]),r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v(".")]),r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("、")]),r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("传递的参数")])]),r("p",[r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("ajax支持的编码格式")])]),r("p",[r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("4、")]),r("span",{staticStyle:{color:"rgb(75,75,75)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("路径不能有中文")])]),r("p",[r("span",{staticStyle:{color:"rgb(75,75,75)",background:"rgb(255,255,255)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("27、")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("XMLHttpRequest")]),r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("XMLHttpRequest.readyState: 状态码的意思")])])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("0 － （未初始化）还没有调用send()方法")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("1 － （载入）已调用send()方法，正在发送请求")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("2 － （载入完成）send()方法执行完成，已经接收到全部响应内容")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("3 － （交互）正在解析响应内容")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("4 － （完成）响应内容解析完成，可以在客户端调用了")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(75,75,75)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("28、")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vue.cli项目中src目录每个文件夹和文件的用法？")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("答：")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("assets")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("文件夹是放静态资源；")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("components")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("是放组件；")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("router")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(";")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}})]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(".vue")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("是一个应用主组件；")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("main")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(".js")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("是入口文件")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("29、")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("components目录新建你的组件文件（")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("smithButton.vue），script一定要export\n        ")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("default {")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("第二步：在需要用的页面（组件）中导入：")]),r("strong",[r("span",{staticStyle:{color:"rgb(153,153,153)"}},[n._v("import")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}}),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("smithButton ")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("from ‘../components/")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("smithButton.vue’")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vue的子组件的components属性上面,components:{")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("smithButton}")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("template视图view中使用，<")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("smith-button> ")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}}),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("smith-button>")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("问题有：")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("smithButton命名，使用的时候则smith-button。")])])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("30、")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("element.ui吗？说下它其中两个组件的使用方法？")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("答：使用过")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("；")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("用过一个布局的，它是由")]),r("span",{staticStyle:{color:"rgb(0,128,128)"}},[n._v("24")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(":span后面带的数字它占")]),r("span",{staticStyle:{color:"rgb(0,128,128)"}},[n._v("24")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(":offset是它的间距，后面也是跟数字，也是从")]),r("span",{staticStyle:{color:"rgb(0,128,128)"}},[n._v("24")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("份里面取的。")])]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("input")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("el-")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("input")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("，后面")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("type")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("跟上一个属性就是显示不同按钮的类型，有默认的")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("default")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("success（成功的）、warning（警告）、danger（危险）、info（）、primary（）")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("31、")]),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("vue框架？")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("答：")]),r("span",{staticStyle:{color:"rgb(0,128,128)"}},[n._v("1")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("、数据信息量比较多的。")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,128,128)"}},[n._v("2")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("web和app应用多端共用一套界面的项目，因为使用vue.cli+webpack后的前端目录，非常有利于项目的跨平台部署。")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("32、")]),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("PC端项目你会在哪些场景使用Vue框架？")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vue为什么解决这些问题呢？")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("dom操作")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("js和html都会有列表的html布局，迭代很困难。再一个dom节点的大面积添加会影响性能。")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("v-for在view层一个地方遍历数据即可")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("。")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vue通过Virtual Dom就是在")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("js中模拟DOM对象树来优化DOM操作。")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(75,75,75)"}})])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("33、call（） 和 apply（） 的作用和区别？")])])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("答：")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("blackCat.say.call(whiteDog)")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}})]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("call(thisObj，arg1,arg2)")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(51,51,51)"}}),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("A")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("pply(thisObj，[arg1,arg2])")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(51,51,51)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("34、举例说ES6有哪些的新功能？")])])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(75,75,75)"}})])]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("35")]),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[n._v("ajax请求的时候get 和post方式的区别")])])]),r("p",[r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("G")]),r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("et 一般用于获取信息")])]),r("p",[r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("URL传递参数")])]),r("p",[r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("2000字符")])]),r("p",[r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("P")]),r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("ost 一般用于修改服务器资源（新建，或者 修改）")])]),r("p",[r("span",{staticStyle:{background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{background:"rgb(255,255,255)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("36、")]),r("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[n._v("JavaScript中如何检测一个变量是一个String类型？请写出函数实现\n        ")])])]),r("p",[r("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[n._v("return typeof(obj) == ")]),r("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[n._v("“")]),r("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[n._v("string")]),r("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[n._v("”")]),r("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[n._v(";\n      ")])]),r("p",[r("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[n._v("}")])]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[n._v("37、")]),r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("JSON 的了解？")])]),r("br"),r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("JSON(JavaScript Object Notation)\n        是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单,\n        易于读写, 占用带宽小。")]),r("br"),r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("{'age':'12', 'name':'back'}")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(44,44,44)"}},[n._v("38")]),n._v("如何阻止事件冒泡和默认事件")])]),r("p",[r("strong",[n._v("阻止事件冒泡：")]),r("span",{staticStyle:{background:"rgb(248,248,255)"}},[n._v("event.stopPropagation();\n      ")])]),r("p",[r("span",{staticStyle:{background:"rgb(248,248,255)"}}),r("strong",[n._v("默认事件：")]),r("span",{staticStyle:{background:"rgb(248,248,255)"}},[n._v("event.preventDefault();")])]),r("p",[r("span",{staticStyle:{background:"rgb(248,248,255)"}}),r("strong",[r("span",{staticStyle:{background:"rgb(248,248,255)"}},[n._v("return")]),r("span",{staticStyle:{background:"rgb(248,248,255)"}}),r("span",{staticStyle:{background:"rgb(248,248,255)"}},[n._v("false")])]),r("span",{staticStyle:{background:"rgb(248,248,255)"}})]),r("p",[r("span",{staticStyle:{background:"rgb(248,248,255)"}})]),r("p",{attrs:{align:"justify"}},[r("strong",[r("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[n._v("39、")]),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("A")]),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("jax数据格式")])])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}},[n._v("HTML、XML 或 JSON")]),r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}})]),r("p",{attrs:{align:"justify"}},[r("strong",[r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("40、")]),n._v("window.load和$(document).ready()的区别")])]),r("p"),r("p",[n._v("Dom就绪就可以访问，但并不意味着，元素所有的关联文件已经下载完毕。")]),r("p"),r("p",[r("strong",[n._v("41、"),r("span",{staticStyle:{color:"rgb(44,44,44)"}},[n._v("css定义")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("@media ")]),r("span",{staticStyle:{color:"rgb(44,44,44)"}},[n._v("screen")]),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(44,44,44)"}},[n._v("@media")]),r("span",{staticStyle:{color:"rgb(44,44,44)"}}),r("span",{staticStyle:{color:"rgb(44,44,44)"}},[n._v("(min-width:768px) and (max-width:979px)")])]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(44,44,44)"}})])]),r("p",[n._v("42"),r("strong",[n._v("$this 和this区别")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("this，表示当前的上下文对象是一个html对象，可以调用html对象所拥有的属性和方法。")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[r("br")]),r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("$(this),代表的上下文对象是一个jquery的上下文对象，可以调用jquery的方法和属性值。")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("h4",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("43、")]),r("br")]),n._v("CSS"),r("br"),n._v("JS"),r("br"),n._v("\n      CSS 表达式（Expression）"),r("br"),n._v("\n      JavaScript 和 CSS"),r("br"),n._v("\n      JavaScript 和 CSS"),r("br"),n._v("\n      <link> 代替 @import"),r("br"),r("br"),n._v("DOM访问\n    ")]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("\n      优化图像css定位，图片全部保存在一张PNG8格式上）"),r("br"),n._v("favicon.ico要小而且可缓存\n    ")]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[n._v("44、ajax请求时，如何解析json数据")])]),r("p",[n._v("eval parse,鉴于安全性考虑 使用parse更靠谱")]),r("p",[r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("JSON.parse(jsonstr); //可以将JSON字符串反序列化成JSON对象")])]),r("p",[r("span",{staticStyle:{background:"rgb(255,255,255)"}}),r("strong")]),r("p"),r("h4",[r("strong",[n._v("45、"),r("span",{staticStyle:{color:"rgb(44,48,51)"}},[n._v("CSS实现三栏自适应布局（两边宽度固定，中间自适应）")])])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(153,51,0)"}}),r("strong",[r("span",{staticStyle:{color:"rgb(153,51,0)"}},[n._v("<div")])]),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("id")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v('"box"')]),r("strong",[r("span",{staticStyle:{color:"rgb(153,51,0)"}},[n._v(">")])]),r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",{staticStyle:{background:"rgb(248,248,248)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("strong",[r("span",{staticStyle:{color:"rgb(153,51,0)"}},[n._v("<div")])]),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("id")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v('"left_box"')]),r("strong",[r("span",{staticStyle:{color:"rgb(153,51,0)"}},[n._v("></div>")])]),r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("strong",[r("span",{staticStyle:{color:"rgb(153,51,0)"}},[n._v("<div")])]),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("id")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v('"center_box"')]),r("strong",[r("span",{staticStyle:{color:"rgb(153,51,0)"}},[n._v("></div>")])]),r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",{staticStyle:{background:"rgb(248,248,248)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("strong",[r("span",{staticStyle:{color:"rgb(153,51,0)"}},[n._v("<div")])]),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("id")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v('"right_box"')]),r("strong",[r("span",{staticStyle:{color:"rgb(153,51,0)"}},[n._v("></div>")])]),r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("strong",[r("span",{staticStyle:{color:"rgb(153,51,0)"}},[n._v("</div>")])]),r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(92,92,92)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("#box")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("{")]),r("strong",[r("span",{staticStyle:{color:"rgb(0,102,153)"}},[n._v("width")])]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v(":")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("100%")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v(";")]),r("strong",[r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("display")])]),r("span",{staticStyle:{color:"rgb(255,0,0)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("strong",[r("span",{staticStyle:{color:"rgb(0,102,153)"}},[n._v("height")])]),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("100px")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",{staticStyle:{background:"rgb(248,248,248)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("#left")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("_box,")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("#right")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("_box{")]),r("strong",[r("span",{staticStyle:{color:"rgb(0,102,153)"}},[n._v("width")])]),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("200px")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v(";")]),r("strong",[r("span",{staticStyle:{color:"rgb(0,102,153)"}},[n._v("height")])]),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("100px")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("#center")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("flex:")]),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("1")]),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v(";")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("strong",[r("span",{staticStyle:{color:"rgb(0,102,153)"}},[n._v("height")])]),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("100px")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("h4",[r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("46、")]),r("span",{staticStyle:{color:"rgb(44,48,51)"}},[n._v("CSS3中各个浏览器内核兼容的设置")])])]),r("p",{staticStyle:{background:"rgb(248,248,248)"}},[r("span",{staticStyle:{color:"rgb(255,0,0)"}}),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("-moz-")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(255,0,0)"}}),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("-ms-")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",{staticStyle:{background:"rgb(248,248,248)"}},[r("span",{staticStyle:{color:"rgb(255,0,0)"}}),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("-webkit-")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(255,0,0)"}}),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("-o-")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",[n._v("\n      IE9以下的浏览器不支持HTML5标签，所以需要导入一个html5.js补丁，原理是通过JS来生成HTML5新标签对象。\n    ")]),r("p",[n._v("\n      CSS都会用media query（响应式设计），IE8以下的浏览器不支持media\n      query，这会导致@media\n      声明的CSS不能生效，因此要导入一个css3-mediaqueries.js补丁。\n    ")]),r("p",[n._v("如下：")]),r("p",[r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("\x3c!--[if lte IE 8]> ")])]),r("p",[r("span",{staticStyle:{color:"rgb(255,0,0)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(255,0,0)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(255,0,0)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("<![endif]--\x3e")])]),r("p",[n._v("\n      /*\n      因为条件注释只对IE10以下版本有效（IE11已经取消支持），所以在其他现代浏览器里面会自动忽略，不会加载，因此不会有性能问题\n      */\n    ")]),r("p",[n._v("\n      /*\n      因为IE9以下浏览器不支持CSS3，IE9支持一部分，因此不能显示一些CSS3的过渡效果，对此有两种办法，一种是忽略，也就是降级或者是差异化设计。\n    ")]),r("p",[n._v("\n      jquery的动画替代，引入方法可以是条件注释，也可以通过检测Navigator来判断IE版本\n      */\n    ")]),r("h4",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[r("strong",[r("br"),n._v("47、"),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("什么是层叠顺序")])])]),r("p"),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(248,248,248)"}},[n._v("border")]),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("/")]),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(248,248,248)"}},[n._v("background")]),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",[r("strong",[n._v("48、三角形的绘制")])]),r("p",[r("strong")]),r("p",{staticStyle:{background:"rgb(221,237,251)"}},[r("br"),n._v("#triangle-up {"),r("br"),r("br"),r("br"),r("br"),r("br"),r("br"),n._v("}\n    ")]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[n._v("49、CSS3有哪些新特性？")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("\n      CSS3实现圆角（border-radius:8px），阴影（box-shadow:10px），"),r("br"),n._v("text-shadow），线性渐变（gradient），变换（transform）\n    ")]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("\n      Transform： rotate(9deg) //旋转\n    ")]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("scale(0.85,0.90) //缩放")]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("translate(0px,-30px) //定位")]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("skew(-9deg,0deg) //倾斜")]),r("p",{staticStyle:{background:"rgb(255,255,255)"}}),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("50、")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("什么是响应式设计？")])])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("它是关于网页制作的过程中让不同的设备有不同的尺寸和不同的功能。响应式设计是让所有的人能在这些设备上让网站运行正常")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("51、写一段css3动画，在5s内，div背景色从red变为blue")])])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("div")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("{")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("width:100px;")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("height:100px;")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("background:red;")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("animation:myfirst 5s;")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("}")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("@keyframes myfirst")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("{")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("from {background:red;}")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("to {background:yellow;}")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("}")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",{attrs:{align:"justify"}},[r("strong",[n._v("52、Bootstrap的特性")])]),r("p",[n._v("响应式设计")]),r("p",[n._v("栅格布局")]),r("p",[n._v("完整的类库")]),r("p",[n._v("jQuery插件")]),r("p",[r("strong",[n._v("html5和css3,所以对浏览器有要求，IE必须9以上。")])]),r("p",[r("strong")]),r("p",{attrs:{align:"justify"}},[r("strong",[n._v("53、什么是boostrap")])]),r("p",[n._v("\n      Bootstrap是基于html、css、javascript的前端框架，为实现应用程序迅速开发的一套前端框架包\n    ")]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("54")])]),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("strong",[r("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v("div+css的布局较table布局有什么优点？")])])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v(" css文件。")]),r("span",{staticStyle:{color:"rgb(34,34,34)"}},[r("br")]),r("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v("页面加载速度更快、结构化清晰、页面显示简洁。")]),r("span",{staticStyle:{color:"rgb(34,34,34)"}},[r("br")]),r("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v("表现与结构相分离。")]),r("span",{staticStyle:{color:"rgb(34,34,34)"}},[r("br")]),r("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v("seo）搜索引擎更友好，排名更容易靠前。")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("55、")]),r("strong",[r("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v("一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。")])])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v("1、")]),r("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v("图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v("2、")]),r("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v("如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v("3、")]),r("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v("css图片，可以使用CSSsprite，SVGsprite，Iconfont、Base64等技术。")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v("4、")]),r("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v("如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v("5、")]),r("span",{staticStyle:{color:"rgb(34,34,34)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("55")])]),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("CSS3")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("新增伪类有那些？")])])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}},[n._v("\n        p 元素")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("。")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}},[n._v("\n        p 元素")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("。")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}},[n._v("\n        p 元素")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("。")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v(":checked，单选框或复选框被选中。")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("56、")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("Cookie, LocalStorage 与 SessionStorage")])]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("三者的异同")])]),r("table",{attrs:{border:"1",cellspacing:"0"}},[r("tbody",[r("tr",[r("td",{staticStyle:{background:"rgb(241,241,241)"}},[r("p",{attrs:{align:"center"}},[r("strong",[r("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("特性")])])])]),r("td",{staticStyle:{background:"rgb(241,241,241)"}},[r("p",{attrs:{align:"center"}},[r("strong",[r("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("Cookie")])])])]),r("td",{staticStyle:{background:"rgb(241,241,241)"}},[r("p",{attrs:{align:"center"}},[r("strong",[r("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("localStorage")])])])]),r("td",{staticStyle:{background:"rgb(241,241,241)"}},[r("p",{attrs:{align:"center"}},[r("strong",[r("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("sessionStorage")])])])])]),r("tr",[r("td",{staticStyle:{background:"rgb(255,255,255)"}},[r("p",[r("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("数据的生命期")])])]),r("td",{staticStyle:{background:"rgb(255,255,255)"}},[r("p",[r("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效")])])]),r("td",{staticStyle:{background:"rgb(255,255,255)"}},[r("p",[r("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("除非被清除，否则永久保存")])])]),r("td",{staticStyle:{background:"rgb(255,255,255)"}},[r("p",[r("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("仅在当前会话下有效，关闭页面或浏览器后被清除")])])])]),r("tr",[r("td",[r("p",[r("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("存放数据大小")])])]),r("td",[r("p",[r("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("4K左右")])])]),r("td",{attrs:{width:"342",colspan:"2"}},[r("p",[r("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("一般为5MB")])])])]),r("tr",[r("td",{staticStyle:{background:"rgb(255,255,255)"}},[r("p",[r("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("与服务器端通信")])])]),r("td",{staticStyle:{background:"rgb(255,255,255)"}},[r("p",[r("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题")])])]),r("td",{staticStyle:{background:"rgb(255,255,255)"},attrs:{width:"342",colspan:"2"}},[r("p",[r("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("仅在客户端（即浏览器）中保存，不参与和服务器的通信")])])])])])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("57、")]),r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("高度坍塌产生的原因？如何解决？")])])]),r("p",[r("span",{staticStyle:{color:"rgb(75,75,75)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(75,75,75)"}},[r("br")]),r("span",{staticStyle:{color:"rgb(75,75,75)",background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(75,75,75)",background:"rgb(255,255,255)"}},[n._v("overflow: hidden;")])]),r("p",[r("span",{staticStyle:{color:"rgb(75,75,75)",background:"rgb(255,255,255)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("58、http状态码")])])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("200 - 请求成功")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("301 - 资源（网页等）被永久转移到其它URL")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("404 - 请求的资源（网页等）不存在")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("500 - 内部服务器错误")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",[r("strong",[n._v("59、px和em，rem的区别")])]),r("p",[n._v("\n      px是一个绝对字体大小，"),r("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}},[n._v("em是根据其父元素的字体大小来设置")]),n._v("1em=16px。那么12px=0.75em,\n      10px=0.625em，但是用em计算相对复杂；CSS3提供了rem，它也是个相对单位，"),r("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}},[n._v("rem只相对跟节点<html>计算")]),r("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",{staticStyle:{background:"rgb(248,248,248)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("16")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("=")]),r("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("62")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",{staticStyle:{background:"rgb(248,248,248)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",{staticStyle:{background:"rgb(248,248,248)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("10")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("=")]),r("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("1")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",[r("strong")]),r("p",[r("strong")]),r("p",[r("strong",[n._v("60、div垂直居中")])]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}},[n._v("<")]),r("span",{staticStyle:{color:"rgb(86,156,214)"}},[n._v("style")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}}),r("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("type")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v("=")]),r("span",{staticStyle:{color:"rgb(206,145,120)"}},[n._v('"text/css"')]),r("span",{staticStyle:{color:"rgb(212,212,212)"}}),r("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("rel")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v("=")]),r("span",{staticStyle:{color:"rgb(206,145,120)"}},[n._v('"stylesheet"')]),r("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v(">")])]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(215,186,125)"}},[n._v(".table")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}})]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("display")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(": ")]),r("span",{staticStyle:{color:"rgb(206,145,120)"}},[n._v("table")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(";")])]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("margin")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(": ")]),r("span",{staticStyle:{color:"rgb(181,206,168)"}},[n._v("5px")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(";")])]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("width")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(": ")]),r("span",{staticStyle:{color:"rgb(181,206,168)"}},[n._v("500px")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(";")])]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("height")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(": ")]),r("span",{staticStyle:{color:"rgb(181,206,168)"}},[n._v("300px")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(";")])]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("background-color")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(": ")]),r("span",{staticStyle:{color:"rgb(206,145,120)"}},[n._v("#ccc")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(";")])]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}})]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}})]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(215,186,125)"}},[n._v(".cell")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}})]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("display")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(": ")]),r("span",{staticStyle:{color:"rgb(206,145,120)"}},[n._v("table-cell")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(";")])]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("padding")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(": ")]),r("span",{staticStyle:{color:"rgb(181,206,168)"}},[n._v("10px")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(";")])]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("vertical-align")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(": ")]),r("span",{staticStyle:{color:"rgb(206,145,120)"}},[n._v("middle")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(";")])]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(96,139,78)"}},[n._v("/*该属性是定义行内元素垂直对齐的，只有行内元素会生效。在表单元格中，这个属性会设置单元格框中的单元格内容的对齐方式。*/")])]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}})]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v("</")]),r("span",{staticStyle:{color:"rgb(86,156,214)"}},[n._v("style")]),r("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v(">")])]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v("<")]),r("span",{staticStyle:{color:"rgb(86,156,214)"}},[n._v("div")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}}),r("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("class")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v("=")]),r("span",{staticStyle:{color:"rgb(206,145,120)"}},[n._v('"table"')]),r("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v(">")])]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v("<")]),r("span",{staticStyle:{color:"rgb(86,156,214)"}},[n._v("div")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}}),r("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("class")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v("=")]),r("span",{staticStyle:{color:"rgb(206,145,120)"}},[n._v('"cell"')]),r("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v(">")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v("内容内容内容内容内容内内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容")]),r("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v("</")]),r("span",{staticStyle:{color:"rgb(86,156,214)"}},[n._v("div")]),r("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v(">")])]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v("</")]),r("span",{staticStyle:{color:"rgb(86,156,214)"}},[n._v("div")]),r("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v(">")])]),r("p",[r("strong")]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",[r("strong",[r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("61、")]),r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("html5有哪些新特性？如何区分 HTML 和 HTML5？")])]),r("span",{staticStyle:{background:"rgb(255,255,255)"}}),r("br"),r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("HTML5 现在已经不是 SGML\n        的子集，主要是关于图像，位置，存储，多任务等功能的增加。")]),r("br"),r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("(1)绘画 canvas;")]),r("br"),r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("(2)用于媒介回放的 video 和 audio 元素;")]),r("br"),r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("(3)本地离线存储 localStorage\n        长期存储数据，浏览器关闭后数据不丢失;")]),r("br"),r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("(4)sessionStorage 的数据在浏览器关闭后自动删除;")]),r("br"),r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("(5)语意化更好的内容元素，比如\n        article、footer、header、nav、section;")]),r("br"),r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("(6)表单控件，calendar、date、time、email、url、search;")])]),r("p",[n._v("\n      区别："),r("strong",[r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("<!DOCTYPE html")]),r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v(">")])])]),r("p",[r("strong",[r("span",{staticStyle:{background:"rgb(255,255,255)"}})])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[n._v("62、"),r("span",{staticStyle:{color:"rgb(44,44,44)"}},[n._v("CSS选择符CSS选择符有哪些？")])])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(57,57,57)",background:"rgb(250,247,239)"}}),r("span",{staticStyle:{color:"rgb(57,57,57)",background:"rgb(250,247,239)"}}),r("span",{staticStyle:{color:"rgb(57,57,57)",background:"rgb(250,247,239)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}}),r("p",[r("strong",[r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("63、")]),n._v("如何消除一个数组里面重复的元素？")])]),r("table",{attrs:{border:"0",cellspacing:"2"}},[r("tbody",[r("tr",[r("td",[r("p"),r("p"),r("p"),r("p"),r("p"),r("p"),r("p"),r("p"),r("p"),r("p")]),r("td",[r("p",[n._v("// 方法一：")]),r("p",[n._v("var arr1 =[1,2,2,2,3,3,3,4,5,6],")]),r("p",[n._v("var arr2 = [];")]),r("p",[n._v("var len = arr1.length;")]),r("p",[n._v("for(var i = 0;i<len; i++){")]),r("p"),r("p"),r("p"),r("p",[n._v("}")]),r("p",[n._v("document.write(arr2); // 1,2,3,4,5,6")]),r("p")])])])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[n._v("64、"),r("span",{staticStyle:{color:"rgb(44,44,44)"}})])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("js中有六种数据类型，包括五种基本数据类型（Number,String,Boolean,Undefined,Null）,和一种复杂数据类型（Object）。")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("65、")]),n._v("ajax的优点")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("1")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("、最大的一点是页面无刷新，在页面内与服务器通信，给用户的体验非常好。")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("2")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("、使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("3")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("、可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("ajax")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("的原则是")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("“")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("按需取数据")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("”")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("，可以最大程度的减少冗余请求，和响应对服务器造成的负担。")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("66、")]),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("XMLhttprequest对象")]),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("ajax工作原理、核心思想）")])]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[r("br")]),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("Ajax的核心是JavaScript对象XmlHttpRequest。它是一种支持异步请求的技术。简而言之，XmlHttpRequest使您可以使用JavaScript向服务器提出请求并处理响应，而不阻塞用户。通过XMLHttpRequest对象，Web开发人员可以在页面加载以后进行页面的局部更新。")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("67、npm是什么？\n        ")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("NPM是随同NodeJS一起安装的包管理工具")]),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("NPM服务器下载别人编写的第三方包到本地使用")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("B")]),r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("ower用法相同")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("68、css省略号怎么写")])])]),r("p",[r("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("单行")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(75,75,75)"}}),r("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("overflow")]),r("span",{staticStyle:{color:"rgb(43,145,175)"}},[n._v(":hidden;")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(43,145,175)"}}),r("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("text-overflow")]),r("span",{staticStyle:{color:"rgb(43,145,175)"}},[n._v(":ellipsis;")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(43,145,175)"}}),r("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("white-space")]),r("span",{staticStyle:{color:"rgb(43,145,175)"}},[n._v(":nowrap")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("<")]),r("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("div")]),r("span",{staticStyle:{color:"rgb(0,0,255)"}}),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("id=")]),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v('"con"')]),r("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v(">")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,255)"}}),r("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("span")]),r("span",{staticStyle:{color:"rgb(0,0,255)"}}),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("id=")]),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v('"txt"')]),r("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v(">文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略</")]),r("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("span>")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,255)"}}),r("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("<")]),r("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("span")]),r("span",{staticStyle:{color:"rgb(0,0,255)"}}),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("class=")]),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v('"t"')]),r("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("></")]),r("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("span>")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("</")]),r("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("div>")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("<")]),r("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("style>")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("#txt")]),r("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("{")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,255)"}}),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("display:")]),r("span",{staticStyle:{color:"rgb(163,21,21)"}}),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("inline-block")]),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v(";")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(163,21,21)"}}),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("height:")]),r("span",{staticStyle:{color:"rgb(163,21,21)"}}),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("40px")]),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v(";")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(163,21,21)"}}),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("width:")]),r("span",{staticStyle:{color:"rgb(163,21,21)"}}),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("250px")]),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v(";")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(163,21,21)"}}),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("line-height:")]),r("span",{staticStyle:{color:"rgb(163,21,21)"}}),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("20px")]),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v(";")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(163,21,21)"}}),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("overflow:")]),r("span",{staticStyle:{color:"rgb(163,21,21)"}}),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("hidden")]),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v(";")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(163,21,21)"}}),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("font-size:")]),r("span",{staticStyle:{color:"rgb(163,21,21)"}}),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("16px")]),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v(";")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("}")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v(".t")]),r("span",{staticStyle:{color:"rgb(43,145,175)"}},[n._v(":after")]),r("span",{staticStyle:{color:"rgb(43,145,175)"}},[n._v("{")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(43,145,175)"}}),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("display:")]),r("span",{staticStyle:{color:"rgb(163,21,21)"}}),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("inline")]),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v(";")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(163,21,21)"}}),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("content:")]),r("span",{staticStyle:{color:"rgb(163,21,21)"}}),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v('"..."')]),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v(";")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(163,21,21)"}}),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("font-size:")]),r("span",{staticStyle:{color:"rgb(163,21,21)"}}),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("16px")]),r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v(";")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(163,21,21)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("}")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("</")]),r("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("style>")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("69、什么是闭包")])])]),r("p",[r("span",{staticStyle:{color:"rgb(26,26,26)",background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(26,26,26)",background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v('<button type="button"\n        onclick="myFunction()">计数!</button>')])]),r("p",[r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v('<p id="demo">0</p>')])]),r("p",[r("span",{staticStyle:{color:"rgb(255,0,0)",background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("<script>")])]),r("p",[r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("var add = (function () {")])]),r("p",[r("span",{staticStyle:{background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("return function () { ")])]),r("p",[r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("return counter += 1;")])]),r("p",[r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("}")])]),r("p",[r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("})();")])]),r("p",[r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("function myFunction(){")])]),r("p",[r("span",{staticStyle:{background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("}")])]),r("p",[r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("<\/script>")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("70、less用过吗？用哪些特性")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("mixin）、")]),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("71")])]),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),r("strong",[r("span",{staticStyle:{color:"rgb(57,57,57)",background:"rgb(250,247,239)"}})])]),r("p",[r("span",{staticStyle:{color:"rgb(57,57,57)",background:"rgb(250,247,239)"}},[n._v("CSS")]),r("span",{staticStyle:{color:"rgb(57,57,57)",background:"rgb(250,247,239)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(57,57,57)",background:"rgb(250,247,239)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(57,57,57)",background:"rgb(250,247,239)"}},[n._v("72、")]),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("css的预编译。")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("使用步骤：")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("npm 下三个loader（sass-loader、css-loader、node-sass）")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("build目录找到webpack")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(".base.config.js")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("extends属性中加一个拓展")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(".scss")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("module属性")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("style标签加上lang属性 ，例如：lang=”scss”")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(":")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,128,128)"}},[n._v("1")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("$变量名称=值）；")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,128,128)"}},[n._v("2")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("、可以用混合器，例如（）")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,128,128)"}},[n._v("3")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("、可以嵌套")])]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("73、SVN是什么？")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("74、怎么理解前后端分离？")])])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("前后端分离的核心：后台提供数据，前端负责显示")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("75、")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("Ajax处理跨域的方式有三种：代理、jsonp、XHR2")])])]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("76、什么是node.js？")])])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("JavaScript")]),n._v("，具有超强的高并发能力\n    ")]),r("p",[r("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程。而每个线程需要耗费大约2MB内存。也就是说，理论上，一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。")])]),r("p",[r("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("77、http协议")])])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}}),r("a",{attrs:{href:"http://www.abc.com:8080",rel:"nofollow"}},[r("u",[r("span",{staticStyle:{color:"rgb(0,0,255)",background:"rgb(255,255,255)"}},[n._v("http://www.abc.com:8080")])])])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",[r("a",{attrs:{href:"http://www.abc.com",rel:"nofollow"}},[r("u",[r("span",{staticStyle:{color:"rgb(0,0,255)",background:"rgb(255,255,255)"}},[n._v("www.abc.com")])])]),r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("78、字符串插值")])])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",[r("strong",[r("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("79、")]),n._v("字符串常用方法")])]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v("slice方法返回字符串的片段")])]),r("span",{staticStyle:{color:"rgb(34,34,34)"}},[r("br")]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v('var str = "ABCDEF";')]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(34,34,34)"}},[r("br")]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v("str.slice(2,4);")]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(34,34,34)"}},[r("br")]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v("CD")]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v("substring方法返回位于String对象中指定位置的子字符串。")])]),r("span",{staticStyle:{color:"rgb(34,34,34)"}},[r("br")]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v('var str = "ABCDEF";')]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(34,34,34)"}},[r("br")]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v("str.substring(2,4); // 或 str.substring(4,2);")]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(34,34,34)"}},[r("br")]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v("CD")]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v("Split")])]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),r("strong",[r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}})]),r("span",{staticStyle:{color:"rgb(34,34,34)"}},[r("br")]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v('var str = "AA BB CC DD EE FF";')]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(34,34,34)"}},[r("br")]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v('alert(str.split(" "，3));')]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(34,34,34)"}},[r("br")]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(34,34,34)"}},[r("br")]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v("AA,BB,CC")]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v("concat方法返回字符串值")])]),r("span",{staticStyle:{color:"rgb(34,34,34)"}},[r("br")]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v('var str = "ABCDEF";')]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(34,34,34)"}},[r("br")]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v('str.concat("ABCDEF","ABC");')]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(34,34,34)"}},[r("br")]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v("ABCDEFABCDEFABC")]),r("strong")]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v("indexOf方法放回String对象内第一次出现子字符串位置")])]),r("span",{staticStyle:{color:"rgb(34,34,34)"}},[r("br")]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v('var str = "ABCDECDF";')]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(34,34,34)"}},[r("br")]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v('str.indexOf("CD"，1); // 由1位置从左向右查找 123...')]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(34,34,34)"}},[r("br")]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v("2")]),r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v("80、")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v(" (BOM)")])])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("BOM 的方法和属性")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v(" window 对象的属性。")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v(" window 对象的方法。")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("Window 子对象")])])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("document 对象")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("frames 对象")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("history 对象")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("location 对象")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("navigator 对象")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("screen 对象")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}},[n._v("81、DOM")]),r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}}),r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}},[n._v("HTML 文档对象模型")])]),r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}},[n._v("\n        DOM，可以访问所有的 HTML 元素，连同它们所包含的文本和属性")])]),r("p",[r("span",{staticStyle:{color:"rgb(102,102,102)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[n._v("82、js 定时器有以下两个方法：")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("setInterval()\n        ：按照指定的周期（以毫秒计）来调用函数或计算表达式。方法会不停地调用函数，直到\n        clearInterval() 被调用或窗口被关闭。")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("setTimeout() ：在指定的毫秒数后调用函数或计算表达式。")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(51,51,51)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("83、MVVM和MVC的区别")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("MVVM中的View 和 ViewModel可以互相通信。也就是可以互相调用。")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[r("br")]),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("MVC中的是单向通信。也就是View跟Model，必须通过Controller来承上启下")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("84、服务端渲染，英文缩写")]),r("span",{staticStyle:{color:"rgb(85,85,85)",background:"rgb(255,255,255)"}},[n._v("SSR")])])]),r("p",[r("span",{staticStyle:{color:"rgb(85,85,85)",background:"rgb(255,255,255)"}},[n._v("Vue.js原来是开发SPA（单页应用）的，但是随着技术的普及，很多人想用Vue开发多页应用，并在服务端完成渲染。可以用Nuxt.js实现，她简化了SSR的开发难度。还可以直接用命令把我们制作的vue项目生成为静态html。")])]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(85,85,85)",background:"rgb(255,255,255)"}})])]),r("p",[r("span",{staticStyle:{color:"rgb(85,85,85)",background:"rgb(255,255,255)"}},[n._v("SPA（单页应用）不利于搜索引擎的SEO操作。比如你作一个新闻网站，流量的一个主要来源是通过百度、谷歌、bing这些搜索引擎，但是它们对SPA的抓取并不好，特别是百度根本没法抓取到SPA的内容页面，所以我们必须把我们的应用在服务端渲染成适合搜索引擎抓取的页面，再下载到客户端。那Nuxt.js适合作新闻、博客、电影、咨询这样的需要搜索引擎提供流量的项目。")])]),r("p",[r("span",{staticStyle:{color:"rgb(85,85,85)",background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(85,85,85)",background:"rgb(255,255,255)"}},[n._v("85、")]),r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})])]),r("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[n._v("\n      webapp就一个HTML文件，里面的各个功能页面是JavaScript通过hash或者history\n      api来进行路由，并通过ajax 拉取数据实现响应功能。\n    ")]),r("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[r("strong",[n._v("优点")]),n._v("：\n    ")]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("分离前后端关注点，前端负责界面显示，后端负责数据存储和计算，各司其职，不会把前后端的逻辑混杂在一起；")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("减轻服务器压力，服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍；")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("Web界面、手机、平板等多种客户端；")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[r("strong",[n._v("缺点")]),n._v("：\n    ")]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("SEO问题，现在可以通过Prerender等技术解决一部分；")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("前进、后退、地址栏等，需要程序进行管理；")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("书签，需要程序来提供支持；")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("86 、ES6定义类和继承")])])]),r("p",{staticStyle:{background:"rgb(246,246,246)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("class")])]),r("span",{staticStyle:{color:"rgb(26,26,26)"}}),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("//")]),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("定义类")])]),r("p",{staticStyle:{background:"rgb(246,246,246)"}},[r("span",{staticStyle:{color:"rgb(26,26,26)"}}),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("//")]),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("构造函数")])]),r("p",{staticStyle:{background:"rgb(246,246,246)"}},[r("span",{staticStyle:{color:"rgb(26,26,26)"}}),r("strong",[r("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("this")])]),r("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v(".name ")]),r("strong",[r("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("=")])]),r("span",{staticStyle:{color:"rgb(26,26,26)"}})]),r("p",{staticStyle:{background:"rgb(246,246,246)"}},[r("span",{staticStyle:{color:"rgb(26,26,26)"}})]),r("p",{staticStyle:{background:"rgb(246,246,246)"}},[r("span",{staticStyle:{color:"rgb(26,26,26)"}})]),r("p",{staticStyle:{background:"rgb(246,246,246)"}},[r("span",{staticStyle:{color:"rgb(26,26,26)"}})]),r("p",{staticStyle:{background:"rgb(246,246,246)"}},[r("span",{staticStyle:{color:"rgb(26,26,26)"}}),r("strong",[r("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("return")])]),r("span",{staticStyle:{color:"rgb(26,26,26)"}}),r("strong",[r("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("this")])]),r("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v(".name;")])]),r("p",{staticStyle:{background:"rgb(246,246,246)"}},[r("span",{staticStyle:{color:"rgb(26,26,26)"}})]),r("p",{staticStyle:{background:"rgb(246,246,246)"}},[r("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("}")])]),r("p",{staticStyle:{background:"rgb(246,246,246)"}},[r("span",{staticStyle:{color:"rgb(26,26,26)"}})]),r("p",{staticStyle:{background:"rgb(246,246,246)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("class")])]),r("span",{staticStyle:{color:"rgb(26,26,26)"}}),r("strong",[r("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("extends")])]),r("span",{staticStyle:{color:"rgb(26,26,26)"}}),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("//")]),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("继承")])]),r("p",{staticStyle:{background:"rgb(246,246,246)"}},[r("span",{staticStyle:{color:"rgb(26,26,26)"}})]),r("p",{staticStyle:{background:"rgb(246,246,246)"}},[r("span",{staticStyle:{color:"rgb(26,26,26)"}}),r("strong",[r("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("this")])]),r("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v(".grade ")]),r("strong",[r("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("=")])]),r("span",{staticStyle:{color:"rgb(26,26,26)"}}),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("// ReferenceError")]),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("：如果没有")]),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("super")]),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("直接调用")]),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("this. Grade,")]),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("会报错")])]),r("p",{staticStyle:{background:"rgb(246,246,246)"}},[r("span",{staticStyle:{color:"rgb(26,26,26)"}}),r("strong",[r("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("super")])]),r("span",{staticStyle:{color:"rgb(26,26,26)"}}),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("//")]),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("子类必须在")]),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("constructor")]),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("方法中调用")]),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("super")]),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("，否则新建实例会报错，因为子类没有自己的")]),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("this")]),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("对象")])]),r("p",{staticStyle:{background:"rgb(246,246,246)"}},[r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("super ")]),r("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("作为函数调用时代表父类的构造函数")])]),r("p",{staticStyle:{background:"rgb(246,246,246)"}},[r("span",{staticStyle:{color:"rgb(26,26,26)"}}),r("strong",[r("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("this")])]),r("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v(".grade ")]),r("strong",[r("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("=")])]),r("span",{staticStyle:{color:"rgb(26,26,26)"}})]),r("p",{staticStyle:{background:"rgb(246,246,246)"}},[r("span",{staticStyle:{color:"rgb(26,26,26)"}})]),r("p",{staticStyle:{background:"rgb(246,246,246)"}},[r("span",{staticStyle:{color:"rgb(26,26,26)"}})]),r("p",{staticStyle:{background:"rgb(246,246,246)"}},[r("span",{staticStyle:{color:"rgb(26,26,26)"}}),r("strong",[r("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("return")])]),r("span",{staticStyle:{color:"rgb(26,26,26)"}}),r("strong",[r("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("this")])]),r("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v(".grade;")])]),r("p",{staticStyle:{background:"rgb(246,246,246)"}},[r("span",{staticStyle:{color:"rgb(26,26,26)"}})]),r("p",{staticStyle:{background:"rgb(246,246,246)"}},[r("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("}")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("Student(“Bill” , 5)")])]),r("p",[r("span",{staticStyle:{color:"rgb(26,26,26)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("87、样式权重")])])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(": style=””，权值为1000。")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("ID选择器，如：#content，权值为100。")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(".content，权值为10。")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("div p，权值为1。")])]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}},[n._v("<")]),r("span",{staticStyle:{color:"rgb(86,156,214)"}},[n._v("style")]),r("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v(">")])]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(215,186,125)"}},[n._v("#aaa")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}})]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("color")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(": ")]),r("span",{staticStyle:{color:"rgb(206,145,120)"}},[n._v("red")])]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}})]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(215,186,125)"}},[n._v(".bbb")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}})]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("color")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(": ")]),r("span",{staticStyle:{color:"rgb(206,145,120)"}},[n._v("blue")])]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}})]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(215,186,125)"}},[n._v("div p")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}})]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("color")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(": #")]),r("span",{staticStyle:{color:"rgb(206,145,120)"}},[n._v("pink")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(";")])]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}})]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v("</")]),r("span",{staticStyle:{color:"rgb(86,156,214)"}},[n._v("style")]),r("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v(">")])]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}},[n._v("</")]),r("span",{staticStyle:{color:"rgb(86,156,214)"}},[n._v("head")]),r("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v(">")])]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}},[n._v("<")]),r("span",{staticStyle:{color:"rgb(86,156,214)"}},[n._v("body")]),r("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v(">")])]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v("<")]),r("span",{staticStyle:{color:"rgb(86,156,214)"}},[n._v("div")]),r("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v(">")])]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v("<")]),r("span",{staticStyle:{color:"rgb(86,156,214)"}},[n._v("p")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}}),r("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("id")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v("=")]),r("span",{staticStyle:{color:"rgb(206,145,120)"}},[n._v('"aaa"')]),r("span",{staticStyle:{color:"rgb(212,212,212)"}}),r("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("class")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v("=")]),r("span",{staticStyle:{color:"rgb(206,145,120)"}},[n._v('"bbb"')]),r("span",{staticStyle:{color:"rgb(212,212,212)"}}),r("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("style")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v("=")]),r("span",{staticStyle:{color:"rgb(206,145,120)"}},[n._v('"color:green"')]),r("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v(">")]),r("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v("我的大学生活")]),r("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v("</")]),r("span",{staticStyle:{color:"rgb(86,156,214)"}},[n._v("p")]),r("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v(">")])]),r("p",{staticStyle:{background:"rgb(30,30,30)"}},[r("span",{staticStyle:{color:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v("</")]),r("span",{staticStyle:{color:"rgb(86,156,214)"}},[n._v("div")]),r("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v(">")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("3个规则,：")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("1，如果样式上加有!important标记，例如：")])]),r("table",{attrs:{border:"0",cellspacing:"0"}},[r("tbody",[r("tr",[r("td",[r("p")]),r("td",[r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}})])])])])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("那么始终采用这个标记的样式。")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("2，匹配的内容按照CSS权重排序，权重大的优先；")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("3，如果权重也一样，按照它在CSS样式表里声明的顺序，后声明的优先，例如：")])]),r("table",{attrs:{border:"0",cellspacing:"0"}},[r("tbody",[r("tr",[r("td",[r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}})])]),r("td",[r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)"}})])])])])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("color: red。")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("88、undefined和null区别")])])]),r("p",{staticStyle:{background:"rgb(245,245,213)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(17,17,17)"}},[n._v('null表示"没有对象"，即该处不应该有值。')])]),r("span",{staticStyle:{color:"rgb(17,17,17)"}},[n._v("典型用法是：")])]),r("p",{staticStyle:{background:"rgb(245,242,240)"}},[r("span",{staticStyle:{color:"rgb(17,17,17)"}},[n._v("1） 作为函数的参数，表示该函数的参数不是对象。")])]),r("p",{staticStyle:{background:"rgb(245,245,213)"}},[r("strong",[r("span",{staticStyle:{color:"rgb(17,17,17)"}},[n._v('undefined表示"缺少值"，就是此处应该有一个值，但是还没有定义。')])]),r("span",{staticStyle:{color:"rgb(17,17,17)"}},[n._v("典型用法是：")])]),r("p",{staticStyle:{background:"rgb(245,242,240)"}},[r("span",{staticStyle:{color:"rgb(17,17,17)"}},[n._v("1）变量被声明了，但没有赋值时，就等于undefined。")])]),r("p",{staticStyle:{background:"rgb(245,242,240)"}},[r("span",{staticStyle:{color:"rgb(17,17,17)"}},[n._v("2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。")])]),r("p",{staticStyle:{background:"rgb(245,242,240)"}},[r("span",{staticStyle:{color:"rgb(17,17,17)"}},[n._v("3）对象没有赋值的属性，该属性的值为undefined。")])]),r("p",{staticStyle:{background:"rgb(245,242,240)"}},[r("span",{staticStyle:{color:"rgb(17,17,17)"}},[n._v("4）函数没有返回值时，默认返回undefined。")])]),r("p",{staticStyle:{background:"rgb(245,242,240)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",{staticStyle:{background:"rgb(245,242,240)"}},[r("span",{staticStyle:{color:"rgb(0,119,170)"}},[n._v("var")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(153,153,153)"}},[n._v(";")])]),r("p",{staticStyle:{background:"rgb(245,242,240)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("i")]),r("span",{staticStyle:{color:"rgb(112,128,144)"}})]),r("p",{staticStyle:{background:"rgb(245,242,240)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",{staticStyle:{background:"rgb(245,242,240)"}},[r("span",{staticStyle:{color:"rgb(0,119,170)"}},[n._v("function")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(17,17,17)"}},[n._v("f")]),r("span",{staticStyle:{color:"rgb(153,153,153)"}},[n._v("(")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("x")]),r("span",{staticStyle:{color:"rgb(153,153,153)"}},[n._v("){")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("console")]),r("span",{staticStyle:{color:"rgb(153,153,153)"}},[n._v(".")]),r("span",{staticStyle:{color:"rgb(17,17,17)"}},[n._v("log")]),r("span",{staticStyle:{color:"rgb(153,153,153)"}},[n._v("(")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("x")]),r("span",{staticStyle:{color:"rgb(153,153,153)"}},[n._v(")}")])]),r("p",{staticStyle:{background:"rgb(245,242,240)"}},[r("span",{staticStyle:{color:"rgb(17,17,17)"}},[n._v("f")]),r("span",{staticStyle:{color:"rgb(153,153,153)"}},[n._v("()")]),r("span",{staticStyle:{color:"rgb(112,128,144)"}})]),r("p",{staticStyle:{background:"rgb(245,242,240)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",{staticStyle:{background:"rgb(245,242,240)"}},[r("span",{staticStyle:{color:"rgb(0,119,170)"}},[n._v("var")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(166,127,89)"}},[n._v("=")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(0,119,170)"}},[n._v("new")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(17,17,17)"}},[n._v("Object")]),r("span",{staticStyle:{color:"rgb(153,153,153)"}},[n._v("();")])]),r("p",{staticStyle:{background:"rgb(245,242,240)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("o")]),r("span",{staticStyle:{color:"rgb(153,153,153)"}},[n._v(".")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("p")]),r("span",{staticStyle:{color:"rgb(112,128,144)"}})]),r("p",{staticStyle:{background:"rgb(245,242,240)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",{staticStyle:{background:"rgb(245,242,240)"}},[r("span",{staticStyle:{color:"rgb(0,119,170)"}},[n._v("var")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(166,127,89)"}},[n._v("=")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}}),r("span",{staticStyle:{color:"rgb(17,17,17)"}},[n._v("f")]),r("span",{staticStyle:{color:"rgb(153,153,153)"}},[n._v("();")])]),r("p",{staticStyle:{background:"rgb(245,242,240)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("x")]),r("span",{staticStyle:{color:"rgb(112,128,144)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("89、")]),r("span",{staticStyle:{background:"rgb(204,255,255)"}},[n._v("HTML")])]),r("span",{staticStyle:{background:"rgb(204,255,255)"}},[n._v("HTML元素标记的内容。")])]),r("p",[r("strong",[n._v("<header></header>")]),r("span",{staticStyle:{background:"rgb(204,255,255)"}})]),r("p",[r("strong",[n._v("<nav></nav>")]),r("span",{staticStyle:{background:"rgb(204,255,255)"}})]),r("p",[r("strong",[n._v("<section></section>")]),r("span",{staticStyle:{background:"rgb(204,255,255)"}})]),r("p",[r("strong",[n._v("<footer></footer>")]),r("span",{staticStyle:{background:"rgb(204,255,255)"}},[n._v("body时，才是整个页面的页脚。")])]),r("h4",{staticStyle:{background:"rgb(255,255,255)"}},[r("strong",[r("span",{staticStyle:{background:"rgb(204,255,255)"}},[n._v("90、")])]),r("a",{attrs:{href:"http://www.cnblogs.com/sunhe/p/4994058.html",rel:"nofollow"}},[r("u",[r("span",{staticStyle:{color:"rgb(33,117,155)"}},[n._v("Doctype作用，标准模式与兼容模式的区别")])])])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("<!DOCTYPE>声明位于位于HTML文档中的第一行，处于 <html>\n        标签之前。告知浏览器的解析器用什么文档标准解析这个文档。")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("标")]),r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("\n        JS运作模式都是以该浏览器支持的最高标准运行。")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"}},[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v(",模拟老式浏览器的行为以防止站点无法工作。")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",{attrs:{align:"justify"}},[r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("91、各种浏览器内核")])])]),r("p",{attrs:{align:"justify"}},[r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("Trident")])]),r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("Internet\n        Explorer，又称其为IE内核。（IE、傲游、世界之窗浏览器、腾讯TT）")])]),r("p",{attrs:{align:"justify"}},[r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("Gecko")])]),r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("Firefox")])]),r("p",{attrs:{align:"justify"}},[r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("WebKit")])]),r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("Safari、Chrome")])]),r("p",{attrs:{align:"justify"}},[r("strong",[r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("Presto")])]),r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("OperaPresto")])]),r("p",[r("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}},[n._v("92")]),r("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}})])]),r("p",[r("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}},[r("br")]),r("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}}),r("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}},[r("br")]),r("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}},[n._v("a. ")]),r("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}},[n._v("b. ")]),r("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}},[n._v("c. ")]),r("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)"}})]),r("p",[r("strong",[n._v("93、attr()和prop()的区别")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),r("p",[r("strong",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("94、")]),r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}},[n._v("data-*")]),r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}})])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("H")]),r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("tml5的自定义属性，")]),r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}})]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}},[n._v("\n        JavaScript 中利用，以创建更好的用户体验")])]),r("p",[r("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[r("strong",[r("span",{staticStyle:{color:"rgb(88,88,88)",background:"rgb(253,252,248)"}},[n._v("95、")]),r("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("Quirks(怪癖）模式是什么？它和Standards（标准）模式有什么区别")])]),r("span",{staticStyle:{color:"rgb(88,88,88)"}},[n._v("区别：")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[r("span",{staticStyle:{color:"rgb(88,88,88)"}},[n._v("总体会有布局、样式解析和脚本执行三个方面的区别。")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[r("span",{staticStyle:{color:"rgb(88,88,88)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[r("span",{staticStyle:{color:"rgb(88,88,88)"}})]),r("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[r("span",{staticStyle:{color:"rgb(88,88,88)"}},[n._v("Standards模式下，给<span>等行内元素设置wdith和height都不会生效，而在quirks模式下，则会生效。")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[r("span",{staticStyle:{color:"rgb(88,88,88)"}},[n._v("standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的")])]),r("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[r("span",{staticStyle:{color:"rgb(88,88,88)"}})])])])}],ha={},ya=ha,fa=Object(m["a"])(ya,ga,ba,!1,null,"fe2c7aa4",null),va=(fa.exports,function(){var n=this;return n.$createElement,n._self._c,n._m(0)}),Sa=[function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[r("h2",[n._v("【Vue】双向数据绑定原理")]),r("h3",[n._v("单向绑定与双向绑定")]),r("ul",[r("li",[n._v("单向绑定非常简单，就是把Model绑定到View，当我们用JavaScript代码更新Model时，View就会自动更新。")]),r("li",[n._v("如果用户更新了View，Model的数据也自动被更新了，这种情况就是双向绑定")])]),r("h3",[n._v("几种实现双向绑定的做法")]),r("ul",[r("li",[r("p",[n._v("发布者-订阅者模式（backbone.js）")])]),r("li",[r("p",[n._v("脏值检查（angular.js）")]),r("ul",[r("li",[r("p",[n._v("通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下")]),r("ul",[r("li",[n._v("DOM事件，譬如用户输入文本，点击按钮等。( ng-click )")]),r("li",[n._v("XHR响应事件 ( $http )")]),r("li",[n._v("浏览器Location变更事件 ( $location )")]),r("li",[n._v("Timer事件( $timeout , $interval )")]),r("li",[n._v("执行 $digest() 或 $apply()")])])])])]),r("li",[r("p",[n._v("数据劫持（vue.js）")]),r("ul",[r("li",[n._v("vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。")])])])]),r("h3",[n._v("Vue双向数据绑定实现思路")]),r("ul",[r("li",[r("p",[n._v("1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者 ")])]),r("li",[r("p",[n._v("2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 ")])]),r("li",[r("p",[n._v("3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图 ")])]),r("li",[r("p",[n._v("4、mvvm入口函数，整合以上三者")])]),r("li",[r("p",[n._v("另一种解释")]),r("ul",[r("li",[n._v("首先，需要利用Object.defineProperty，将要观察的对象，转化成getter/setter，以便拦截对象赋值与取值操作，称之为Observer；")]),r("li",[n._v("需要将DOM解析，提取其中的指令与占位符，并赋与不同的操作，称之为Compiler；")]),r("li",[n._v("需要将Compile的解析结果，与Observer所观察的对象连接起来，建立关系，在Observer观察到对象数据变化时，接收通知，同时更新DOM，称之为Watcher；")]),r("li",[n._v("最后，需要一个公共入口对象，接收配置，协调上述三者，称为Vue;")])])]),r("li",[r("p",[n._v("条件")]),r("ul",[r("li",[n._v("把一个普通对象传给 Vue 实例作为它的 data 选项，Vue.js 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。这是 ES5 特性，不能打补丁实现，这便是为什么 Vue.js 不支持 IE8 及更低版本。")])])])]),r("h3",[n._v("具体实现")]),r("ul",[r("li",[r("p",[n._v("（1）实现Observer")]),r("p",[n._v("利用Obeject.defineProperty()来监听属性变动 那么将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上\tsetter和getter 这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。")]),r("ul",[r("li",[n._v("（1）将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter，这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。")]),r("li",[n._v("（2）监听到变化之后就是怎么通知订阅者了，所以接下来我们需要实现一个消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发notify，再调用订阅者的update方法，")]),r("li",[n._v("（3）那么问题来了，谁是订阅者？怎么往订阅器添加订阅者？ 没错，上面的思路整理中我们已经明确订阅者应该是Watcher, 而且var dep = new Dep();是在 defineReactive方法内部定义的，所以想通过dep添加订阅者，就必须要在闭包内操作，所以我们可以在getter里面动手脚")])])]),r("li",[r("p",[n._v("（2）实现Compile")]),r("p",[n._v("compile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图，")]),r("p",[n._v(" ")]),r("ul",[r("li",[r("p",[n._v("思路")]),r("ul",[r("li",[n._v("compile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图，")])])]),r("li",[r("p",[n._v("（1）因为遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将跟节点el转换成文档碎片fragment进行解析编译操作，解析完成，再将fragment添加回原来的真实dom节点中")])]),r("li",[r("p",[n._v("（2）compileElement方法将遍历所有节点及其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定")])]),r("li",[r("p",[n._v('这里通过递归遍历保证了每个节点及子节点都会解析编译到，包括了{{}}表达式声明的文本节点。指令的声明规定是通过特定前缀的节点属性来标记，如<span v-text="content" other-attr中v-text便是指令，而other-attr不是指令，只是普通的属性。 监听数据、绑定更新函数的处理是在compileUtil.bind()这个方法中，通过new Watcher()添加回调来接收数据变化的通知')])])])]),r("li",[r("p",[n._v("（3）实现Watcher")]),r("ul",[r("li",[r("p",[n._v("Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是")]),r("ul",[r("li",[n._v("1、在自身实例化时往属性订阅器(dep)里面添加自己 ")]),r("li",[n._v("2、自身必须有一个update()方法 ")]),r("li",[n._v("3、待属性变动dep.notify()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。 ")])])]),r("li",[r("p",[n._v("实例化Watcher的时候，调用get()方法，通过Dep.target = watcherInstance标记订阅者是当前watcher实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep添加当前watcher实例，从而在属性值有变化的时候，watcherInstance就能收到更新通知。")])])])]),r("li",[r("p",[n._v("（4）实现MVVM")]),r("ul",[r("li",[n._v("MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。")]),r("li",[n._v("一个简单的MVVM构造器是这样子")])])])]),r("h3",[n._v("用Object.defineProperty()简易实现一个双向绑定")])])}],_a={},ka=_a,ja=Object(m["a"])(ka,va,Sa,!1,null,"8b8b7768",null),wa=ja.exports,xa=function(){var n=this;return n.$createElement,n._self._c,n._m(0)},Ta=[function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[r("h2",[n._v("【Vue监听缺陷】Vue数组下标以及增删对象属性无法响应式")]),r("h3",[n._v("对于数组的监听")]),r("ul",[r("li",[r("p",[n._v("首先，Vue.js是基于Object.defineProperty对对象实现“响应式化”，而对于数组，Vue.js提供的方法是重写push、pop、shift、unshift、splice、sort、reverse这七个数组方法。")]),r("ul",[r("li",[n._v("直接重写数组")]),r("li",[n._v("def的作用就是重新定义对象属性的value值")]),r("li",[n._v("理解版，即在使用原生数组方法结果之后，发布改变与观察新增的元素，再返回值")]),r("li",[n._v("理解版中的dosomething在源码中的代码")])])]),r("li",[r("p",[n._v("Vue 不能检测以下变动的数组")]),r("ul",[r("li",[r("p",[n._v("（1）当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue，")])]),r("li",[r("p",[n._v("（2）当你修改数组的长度时，例如：vm.items.length = newLength")])]),r("li",[r("p",[n._v("解释")]),r("ul",[r("li",[n._v("Vue不能检测到对象的添加或者删除。然而Vue在初始化实例时就对属性执行了setter/getter转化过程，所以属性必须开始就在对象上，这样才能让Vue转化它。 ")]),r("li",[n._v("数组中index都可以看做是属性，当我们添加属性并赋值时，Vue并不能检测到对象中属性的添加或者删除，但是其的确是添加或删除了，故我们可以通过console看到变化，所以就没有办法做到响应式；")])])])])]),r("li",[r("p",[n._v("解决")]),r("ul",[r("li",[n._v("数组索引设置")]),r("li",[n._v("修改数组长度")])])])]),r("h3",[n._v("Vue 不能检测对象属性的添加或删除")]),r("ul",[r("li",[r("p",[n._v("现象")]),r("ul",[r("li",[n._v("对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。")])])]),r("li",[r("p",[n._v("解决")]),r("ul",[r("li",[r("p",[n._v("为已有对象赋予单个新属性")]),r("ul",[r("li",[n._v("可以使用 Vue.set(object, key, value) 方法向嵌套对象添加响应式属性。")])])]),r("li",[r("p",[n._v("为已有对象赋予多个新属性")]),r("ul",[r("li",[n._v("用两个对象的属性创建一个新的对象")])])])])])]),r("h3",[n._v("Vue.set()原理")]),r("ul",[r("li",[r("p",[n._v("作用")]),r("ul",[r("li",[n._v("Vue.set()向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 (比如 this.myObject.newProperty = 'hi')")])])]),r("li",[r("p",[n._v("实现原理")]),r("ul",[r("li",[r("p",[n._v("Vue.set()和this.$set()这两个api的实现原理基本一模一样，都是使用了set函数。set函数是从 ../observer/index 文件中导出的，区别在于Vue.set()是将set函数绑定在Vue构造函数上，this.$set()是将set函数绑定在Vue原型上。")])]),r("li",[r("p",[n._v("关键代码分析")]),r("ul",[r("li",[r("p",[n._v("数组的实现原理")]),r("ul",[r("li",[r("p",[n._v("Vue中的数组与普通的JS数组")]),r("ul",[r("li",[r("p",[n._v("Vue")])]),r("li",[r("p",[n._v("普通")])]),r("li",[r("p",[n._v("区别")]),r("ul",[r("li",[n._v("普通JS中数组的原型是指向Array.prototype，也就是说 arrJs."),r("strong",[n._v("proto")]),n._v(" == Array.prototype。")]),r("li",[n._v("Vue中数组的原型指向的一个对象，这个对象上面只有7个push、pop等方法，并且这个对象上的原型才是指向的Array.prototype。所以我们在vue中调用数组的push、pop等方法时其实不是直接调用的数组原型给我们提供的push、pop等方法，而是调用的arrayMethods给我们提供的push、pop等方法。这里你可以理解成vue在arrayMethods对象中做过了特殊处理，如果你调用了arrayMethods提供的push、pop等7个方法，那么它会触发当前收集的依赖（这里收集的依赖可以暂时理解成渲染函数），导致页面重新渲染。")])])])])]),r("li",[r("p",[n._v("实现原理")]),r("ul",[r("li",[n._v("其实Vue.set()对于数组的处理其实就是调用了splice方法……我倒")])])])])]),r("li",[r("p",[n._v("对象的实现原理")]),r("ul",[r("li",[n._v("defineReactive(ob.value, key, val)的意思是给新加的属性添加依赖，以后再直接修改这个新的属性的时候就会触发页面渲染。")]),r("li",[n._v("ob.dep.notify()这句代码的意思是触发当前的依赖（这里的依赖依然可以理解成渲染函数），所以页面就会进行重新渲染。")])])])])])])])])])}],Ca={},Ma=Ca,Pa=Object(m["a"])(Ma,xa,Ta,!1,null,"a55f2256",null),Oa=Pa.exports,Ea=function(){var n=this;return n.$createElement,n._self._c,n._m(0)},Ra=[function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[r("h2",[n._v("【Vue】对于Virtual Dom的理解")]),r("h3",[n._v("虚拟DOM与真实DOM的区别")]),r("ul",[r("li",[r("p",[n._v("1.虚拟DOM不会进行排版与重绘操作")])]),r("li",[r("p",[n._v("2.虚拟DOM进行频繁修改，然后一次性比较并修改真实DOM中需要改的部分（注意！），最后并在真实DOM中进行排版与重绘，减少过多DOM节点排版与重绘损耗")])]),r("li",[r("p",[n._v("3.真实DOM频繁排版与重绘的效率是相当低的")])]),r("li",[r("p",[n._v("4.虚拟DOM有效降低大面积（真实DOM节点）的重绘与排版，因为最终与真实DOM比较差异，可以只渲染局部（同2）")])]),r("li",[r("p",[n._v("损耗计算")]),r("ul",[r("li",[r("p",[n._v("使用虚拟DOM的损耗计算：")]),r("ul",[r("li",[n._v("总损耗 = 虚拟DOM增删改 + （与Diff算法效率有关）真实DOM差异增删改 + （较少的节点）排版与重绘")])])]),r("li",[r("p",[n._v("直接使用真实DOM的损耗计算：")]),r("ul",[r("li",[n._v("总损耗 = 真实DOM完全增删改 + （可能较多的节点）排版与重绘")])])])])]),r("li",[r("p",[n._v("总之，一切为了减弱频繁的大面积重绘引发的性能问题，不同框架不一定需要虚拟DOM，关键看框架是否频繁会引发大面积的DOM操作")])])]),r("h3",[n._v("Virtual DOM算法")]),r("ul",[r("li",[r("p",[n._v("初步了解")]),r("ul",[r("li",[r("p",[n._v("（1）真实DOM是很慢的")]),r("ul",[r("li",[n._v("如果我们把一个简单的div元素的属性都打印出来，你会看到：")]),r("li",[n._v("而这仅仅是第一层。真正的 DOM 元素非常庞大，这是因为标准就是这么设计的。而且操作它们的时候你要小心翼翼，轻微的触碰可能就会导致页面重排，这可是杀死性能的罪魁祸首。")])])]),r("li",[r("p",[n._v("（2）相对于 DOM 对象，原生的 JavaScript 对象处理起来更快，而且更简单。DOM 树上的结构、属性信息我们都可以很容易地用 JavaScript 对象表示出来：")])])])]),r("li",[r("p",[n._v("Virtual DOM 算法几个步骤")]),r("ul",[r("li",[r("p",[n._v("（1）用 JavaScript 对象结构表示 DOM 树的结构；然后用这个对象树构建一个真正的 DOM 树，插到文档当中")])]),r("li",[r("p",[n._v("（2）当状态变更的时候，重新构造一棵新的对象树。然后用新的对象树和旧的对象树进行比较，记录两棵对象树差异")])]),r("li",[r("p",[n._v("（3）把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了")])]),r("li",[r("p",[n._v("总结理解")]),r("ul",[r("li",[n._v("Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。")])])])])])]),r("h3",[n._v("【diff算法】Virtual Dom以及Diff算法")]),r("ul",[r("li",[r("p",[n._v("（1）创建真实Dom的代价很大")]),r("ul",[r("li",[n._v("使用document.CreateElement 和 document.CreateTextNode创建的就是真实节点。")]),r("li",[n._v("我们可以做个试验。打印出一个空元素的第一层属性，可以看到标准让元素实现的东西太多了。如果每次都重新生成新的元素，对性能是巨大的浪费。")])])]),r("li",[r("p",[n._v("（2）Virtual Dom的解决思路")]),r("ul",[r("li",[r("p",[n._v("通俗易懂的来说就是用一个简单的对象去代替复杂的dom对象。")])]),r("li",[r("p",[n._v("举例")]),r("ul",[r("li",[n._v("我们在body里插入一个class为a的div。")]),r("li",[n._v("对于这个div我们可以用一个简单的对象mydivVirtual代表它，它存储了对应dom的一些重要参数，在改变dom之前，会先比较相应虚拟dom的数据，如果需要改变，才会将改变应用到真实dom上。")])])])])]),r("li",[r("p",[n._v("（3）为什么不直接修改Dom而需要加一层Virtual Dom呢？")]),r("ul",[r("li",[n._v("很多时候手工优化dom确实会比virtual dom效率高，对于比较简单的dom结构用手工优化没有问题，但当页面结构很庞大，结构很复杂时，手工优化会花去大量时间，而且可维护性也不高，不能保证每个人都有手工优化的能力。至此，virtual dom的解决方案应运而生，")]),r("li",[n._v("virtual dom很多时候都不是最优的操作，但它具有普适性，在效率、可维护性之间达平衡。")]),r("li",[n._v("virtual dom 另一个重大意义就是提供一个中间层，js去写ui，ios安卓之类的负责渲染，就像reactNative一样。")])])]),r("li",[r("p",[n._v("（4）分析Diff")]),r("ul",[r("li",[r("p",[n._v("Vue和React的虚拟DOM的Diff算法大致相同，其核心是基于两个简单的假设：")]),r("ul",[r("li",[r("ol",{attrs:{start:""}},[r("li",[n._v("两个相同的组件产生类似的DOM结构，不同的组件产生不同的DOM结构。")])])]),r("li",[r("ol",{attrs:{start:"2"}},[r("li",[n._v("同一层级的一组节点，他们可以通过唯一的id进行区分。")])])])])]),r("li",[r("p",[n._v("Diff算法特点：当页面的数据发生变化时，Diff算法只会比较同一层级的节点：")]),r("ul",[r("li",[n._v("1.如果节点类型不同，直接干掉前面的节点，再创建并插入新的节点，不会再比较这个节点以后的子节点了。")]),r("li",[n._v("2.如果节点类型相同，则会重新设置该节点的属性，从而实现节点的更新。")])])])])]),r("li",[r("p",[n._v("（5）传统Diff算法与Vue中的Diff算法")]),r("ul",[r("li",[r("p",[n._v("传统的Diff算法")]),r("ul",[r("li",[n._v("传统算法就是对每个节点一一对比，循环遍历所有的子节点，然后判断子节点的更新状态，分别为remove、add、change。如果before的子节点仍有子节点依旧顺次执行。")])])]),r("li",[r("p",[n._v("Vue中的Diff算法")]),r("ul",[r("li",[n._v("传统 diff 算法的复杂度为 O(n^3)，单纯从demo看，复杂度不到n3，但实际上。React 通过制定大胆的策略，将 O(n^3) 复杂度的问题转换成 O(n) 复杂度的问题。")])])])])])])])}],Na={},Aa=Na,Da=Object(m["a"])(Aa,Ea,Ra,!1,null,"5571d7eb",null),Ia=Da.exports,Ja=function(){var n=this;return n.$createElement,n._self._c,n._m(0)},La=[function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[r("h2",[n._v("vue-router")]),r("h3",[n._v("基础")]),r("ul",[r("li",[r("p",[n._v("Vue.router基础")]),r("ul",[r("li",[r("p",[n._v("开始")]),r("ul",[r("li",[r("p",[n._v("作用：创建单页应用")])]),r("li",[r("p",[n._v("例子")]),r("ul",[r("li",[n._v("实例1（简单）")]),r("li",[n._v("实例2（复杂但有说明--命名路由中的例子）")])])])])]),r("li",[r("p",[n._v("动态路由匹配")]),r("ul",[r("li",[r("p",[n._v("基本知识")]),r("ul",[r("li",[r("p",[n._v("说明")]),r("ul",[r("li",[n._v("动态路由以冒号开头；通过$route.params可以访问相对应的值")])])]),r("li",[r("p",[n._v("例子")]),r("ul",[r("li",[n._v("实例")])])])])]),r("li",[r("p",[n._v("响应路由参数的变化")]),r("ul",[r("li",[r("p",[n._v("想对路由变化（从预设的路由A切换值预设的路由B）做出反应，可采用watch")])]),r("li",[r("p",[n._v("例子")]),r("ul",[r("li",[n._v("实例")])])])])]),r("li",[r("p",[n._v("高级匹配模式")])]),r("li",[r("p",[n._v("匹配优先级")]),r("ul",[r("li",[n._v("有时一个路径会有多个路由，这时以最先定义的路由优先级最高的原则来处理")])])])])]),r("li",[r("p",[n._v("嵌套路由")]),r("ul",[r("li",[r("p",[n._v("例子")]),r("ul",[r("li",[n._v("实例")])])])])]),r("li",[r("p",[n._v("编程式导航")]),r("ul",[r("li",[n._v("router.push(location)")]),r("li",[n._v("router.replace(location)")]),r("li",[n._v("router.go(n)")])])]),r("li",[r("p",[n._v("命名路由")]),r("ul",[r("li",[r("p",[n._v("注意事项")]),r("ul",[r("li",[n._v("1、需要命名（to及routes里都要有name属性）")]),r("li",[n._v("2、router-link 里的to 需要加v-bind")])])]),r("li",[r("p",[n._v("例子")]),r("ul",[r("li",[n._v("实例")])])])])]),r("li",[r("p",[n._v("命名视图")]),r("ul",[r("li",[r("p",[n._v("作用")]),r("ul",[r("li",[n._v("可以在界面中拥有多个单独命名的视图router-view ,而不是只有一个单独的出口")])])]),r("li",[r("p",[n._v("注意事项")]),r("ul",[r("li",[n._v("1、如果router-view没有设置名字，那么默认为default")]),r("li",[n._v("2、此时的component应该为复数即components")])])]),r("li",[r("p",[n._v("例子")]),r("ul",[r("li",[n._v("实例")])])])])]),r("li",[r("p",[n._v("重定向和别名")]),r("ul",[r("li",[r("p",[n._v("重定向")]),r("ul",[r("li",[r("p",[n._v("类型")]),r("ul",[r("li",[r("p",[n._v("参数为单纯的一个链接")]),r("ul",[r("li",[n._v("实例")])])]),r("li",[r("p",[n._v("参数为一个命名的路由")])]),r("li",[r("p",[n._v("参数为一个方法")])])])])])]),r("li",[r("p",[n._v("别名")]),r("ul",[r("li",[r("p",[n._v("例子")]),r("ul",[r("li",[n._v("实例")])])])])])])]),r("li",[r("p",[n._v("HTML5 History模式")]),r("ul",[r("li",[r("p",[n._v("好处")]),r("ul",[r("li",[n._v("vue-router默认使用的是hash模式，如果不想觉得hash模式（#）丑陋可以使用history模式；")])])]),r("li",[r("p",[n._v("注意事项")]),r("ul",[r("li",[r("p",[n._v("需要后台配置支持，否则可能会返回404了")]),r("ul",[r("li",[r("p",[n._v("后台配置例子")]),r("ul",[r("li",[n._v("实例")])])])])])])]),r("li",[r("p",[n._v("用法举例")]),r("ul",[r("li",[n._v("实例")])])]),r("li",[r("p",[n._v("其它建议")]),r("ul",[r("li",[r("p",[n._v("为了不让服务器给出404错误，可以给个警告。")]),r("ul",[r("li",[r("p",[n._v("非node.js后台")]),r("ul",[r("li",[n._v("实例")])])]),r("li",[r("p",[n._v("node.js后台")]),r("ul",[r("li",[n._v("可以在后台匹配路由，没匹配到时给出404，从而实现fallback")])])])])])])])])])])])]),r("h3",[n._v("进阶")]),r("ul",[r("li",[r("p",[n._v("导航钩子")]),r("ul",[r("li",[r("p",[n._v("作用")]),r("ul",[r("li",[n._v("用来拦截导航，让它完成跳转或取消")])])]),r("li",[r("p",[n._v("执行钩子的方式")]),r("ul",[r("li",[r("p",[n._v("全局钩子（beforeEach）")]),r("ul",[r("li",[r("p",[n._v("使用方法")]),r("ul",[r("li",[n._v("说明")])])]),r("li",[r("p",[n._v("例子")]),r("ul",[r("li",[n._v("实例--代码")]),r("li",[n._v("实例--运行结果")])])])])]),r("li",[r("p",[n._v("某个路由独享的钩子（beforeEnter）")]),r("ul",[r("li",[r("p",[n._v("与全局before钩子的方法参数一样")])]),r("li",[r("p",[n._v("使用方法")]),r("ul",[r("li",[r("p",[n._v("官网简介")])]),r("li",[r("p",[n._v("例子")]),r("ul",[r("li",[n._v("实例")])])])])])])]),r("li",[r("p",[n._v("组件内的钩子（beforeRouteEnter/Update/Leave）")]),r("ul",[r("li",[r("p",[n._v("使用方法")]),r("ul",[r("li",[n._v("官网例子")])])]),r("li",[r("p",[n._v("注意事项")]),r("ul",[r("li",[n._v("使用beforeRouteEnter无法访问组件实例this；不过可以通过传一个回调给next来访问组件实例")])])])])])])])])])])])}],Ha={},Fa=Ha,Ua=Object(m["a"])(Fa,Ja,La,!1,null,"38020d37",null),qa=Ua.exports,Ba=function(){var n=this;return n.$createElement,n._self._c,n._m(0)},Wa=[function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[r("h2",[n._v("前后端路由及前端路由的实现")]),r("h3",[n._v("前后端路由")]),r("ul",[r("li",[r("p",[n._v("传统的服务端路由")]),r("ul",[r("li",[r("p",[n._v("根据客户端请求的不同网址，返回不同的网页内容")])]),r("li",[r("p",[n._v("现象")]),r("ul",[r("li",[n._v("1、会造成服务器压力增加")]),r("li",[n._v("2、每次都重新请求，响应较慢、用户体验下降")])])])])]),r("li",[r("p",[n._v("前端路由")]),r("ul",[r("li",[n._v("在URL地址改变的过程中，通过JS来实现不同UI之间的切换（JS对DOM的操作），而不再向服务器重新请求页面，只通过AJAX向服务端请求数据，对用户来说这种无刷新的、即时响应是更好的体验。")]),r("li",[n._v("路由是映射关系，URL与处理函数的对应关系")])])])]),r("h3",[n._v("前端路由的实现方式")]),r("ul",[r("li",[r("p",[n._v("方法一：基于hash（location.hash+hashchange事件）")]),r("ul",[r("li",[r("p",[n._v("（1）hash满足以下几个特性，才使得其可以实现前端路由")]),r("ul",[r("li",[n._v("（1）url中hash值的变化并不会重新加载页面，因为hash是用来指导浏览器行为的，对服务端是无用的，所以不会包括在http请求中。")]),r("li",[n._v("（2）hash值的改变，都会在浏览器的访问历史中增加一个记录，也就是能通过浏览器的回退、前进按钮控制hash的切换")]),r("li",[n._v("（3）我们可以通过hashchange事件，监听到hash值的变化，从而响应不同路径的逻辑处理。")]),r("li",[n._v("如此一来，我们就可以在hashchange事件里，根据hash值来更新对应的视图，但不会去重新请求页面，同时呢，也在history里增加了一条访问记录，用户也仍然可以通过前进后退键实现UI的切换。")])])]),r("li",[r("p",[n._v("（2）触发hash值的变化有两种方法")]),r("ul",[r("li",[r("p",[n._v("1、通过a标签，设置href属性，当标签点击之后，地址栏会改变，同时会触发hashchange事件")]),r("ul",[r("li",[r("a",{attrs:{href:"#kaola"}},[n._v("to KAOLA")])])])]),r("li",[r("p",[n._v("2、通过JS直接赋值给location.hash，也会改变URL，触发hashchange事件")]),r("ul",[r("li",[n._v('location.hash="#kaola"')])])])])]),r("li",[r("p",[n._v("（3）hash实现简易Router代码")]),r("ul",[r("li",[r("p",[n._v("route")]),r("ul",[r("li",[n._v("route是一条路由，是将一个URL路径和一个处理函数相关联，是一条url和函数的映射规则，如上面代码中通过原型上的route可以设置一条路由规则，将一个path和其callback关联起来。")])])]),r("li",[r("p",[n._v("routes")]),r("ul",[r("li",[n._v("router则更像是一个容器，或者说一种机制，它管理了一组route。简单来说，route只是进行了URL和函数的映射，而在当接收到一个URL之后，去路由映射表中查找相应的函数，这个过程是由router来处理的，如上面代码，Router管理传入的route，并且在hash改变的时候，根据当前的url响应其对应的函数。")])])])])])])]),r("li",[r("p",[n._v("方法二：基于History新API（history.pushState()+popState事件）")]),r("ul",[r("li",[r("p",[n._v("History对象")]),r("ul",[r("li",[r("p",[n._v("history.pushState")]),r("ul",[r("li",[r("p",[n._v("用于在浏览历史中添加历史记录,但是并不触发跳转,此方法接受三个参数")]),r("ul",[r("li",[n._v("state:一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数。如果不需要这个对象，可以填null。")]),r("li",[n._v("title：新页面的标题，但是所有浏览器目前都忽略这个值，填空字符串l。")]),r("li",[n._v("url：新的URL不一定是绝对路径；如果是相对路径，它将以当前URL为基准；传入的URL与当前URL应该是同源的，否则，pushState()会抛出异常。")])])])])]),r("li",[r("p",[n._v("history.replaceState")]),r("ul",[r("li",[n._v("方法的参数与pushState方法一模一样，区别是它修改浏览历史中当前纪录,而非添加记录,同样不触发跳转。")])])]),r("li",[r("p",[n._v("popstate事件")]),r("ul",[r("li",[n._v("每当同一个文档的浏览历史（即history对象）出现变化时，就会触发popstate事件。")]),r("li",[n._v("注意，仅仅调用pushState()方法或replaceState()方法 ，并不会触发该事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用History.back()、History.forward()、History.go()方法时才会触发。另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。")])])])])]),r("li",[r("p",[n._v("代码")]),r("ul",[r("li",[n._v("当我们在历史记录中切换时就会触发 popstate 事件，可以在事件中还原当前state对应的UI。")])])])])])]),r("h3",[n._v("监听浏览器的后退按钮事件")]),r("ul",[r("li",[r("p",[n._v("（1）如果后退是跳转到另一个全新的页面")]),r("ul",[r("li",[n._v("实际上有很多事件都会触发 onbeforeunload，比如刷新、点击链接前往新的页面等。这里应该还是在页面加载完成比如 window.onload 事件里使用 history.pushState 推一条记录进栈，同时监听 window.onpopstate 事件")])])]),r("li",[r("p",[n._v("（2）如果整个页面是一个SPA，History API模式")]),r("ul",[r("li",[n._v("使用的是 pushState/replaceState 来实现的导航，那么当浏览器回退的时候会触发 window 上的 popstate 事件。这时需要监听 window.onpopstate 事件;")])])]),r("li",[r("p",[n._v("（3）如果整个页面是一个SPA，Hash模式")]),r("ul",[r("li",[r("p",[n._v("使用的是基于 hashChange 实现的导航，那么这个时候就比较麻烦。因为页面根据 hash 正常变化跳转（导航）的时候也会触发 popstate 事件，所以不能简单的监听 popstate 事件来做出判断。")])]),r("li",[r("p",[n._v("思路")]),r("ul",[r("li",[n._v("因为后退按钮属于浏览器的UI，并不属于任何一个页面，所以如果当鼠标在当前页面外时，监听的 popstate 事件被触发，那么认为用户点击了浏览器的后退按钮 (这里的判断鼠标是否在当前页面里是通过监听 document.onmouseleave 和 document.onmouseenter事件)；另外答案里还绑定了对 Backspace 键的监听，因为某些浏览器默认当页面焦点不属于输入域时触发的是后退操作。这个方法基本可以满足大多数情况，但是如果用户是通过鼠标侧键 (常见于游戏鼠标) 来实现的后退操作，那么可能就无法监听了。")])])]),r("li",[r("p",[n._v("Location对象")]),r("ul",[r("li",[r("p",[n._v("Location.reload([bForceGet]) - 刷新当前页面")]),r("ul",[r("li",[n._v('bForceGet为可选参数， 默认为 false，从浏览器的缓存里取当前页。true，从服务端取最新的页面, 相当于客户端点击 F5("刷新") 。')])])]),r("li",[r("p",[n._v("Location.replace(url) - 当前页面跳转到指定的URL")]),r("ul",[r("li",[n._v("并且用该URL替换当前的历史纪录，这样浏览历史记录中就只有一个页面，后退按钮永远处于失效状态，用户也就无法进行后退了。")])])]),r("li",[r("p",[n._v("Location.assign(url) - 当前页面跳转到指定的URL")]),r("ul",[r("li",[n._v("和使用location.href=URL是一样的。会产生历史记录。")])])])])])])]),r("li",[r("p",[n._v("考虑前进/后退的差别")]),r("ul",[r("li",[n._v("其实前进按钮也会触发 popstate 事件。如果是使用了 HTML5 的 history api 的单页应用，可以在 pushState 的时候给要入栈的状态对象加上一个字段来区分历史栈中每个状态的先后顺序，比如 pushState({s: 'a.html', index: 0}, '', 'a.html') 和 pushState({s: 'b.html', index: 1}, '', 'b.html')，这样当点击浏览器前进后退按钮的时候我们可以通过比较 e.state.index 和当前 history.state.index 的值来判断具体是入栈还是出栈")])])])])])}],Va={},Ga=Va,za=Object(m["a"])(Ga,Ba,Wa,!1,null,"223e72ab",null),$a=za.exports,Xa=function(){var n=this;return n.$createElement,n._self._c,n._m(0)},Ka=[function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[r("h2",[n._v("Vue的diff算法")]),r("h3",[n._v("以对象的形式模拟树形结构")]),r("h3",[n._v("diff过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的dom打补丁")]),r("h3",[n._v("比较新旧节点的时候，只会在同层级进行")]),r("h3",[n._v("5种节点比较情况")]),r("ul",[r("li",[n._v("oldVnode===vnode，引用一致，认为没有变化")]),r("li",[n._v("新旧节点text不为空，且不相等则将Node.textContent = vnode.text")]),r("li",[n._v("只有新的节点有子节点则在老节点中添加子节点")]),r("li",[n._v("新节点没有子节点，老节点有子节点则删除")]),r("li",[n._v("子节点不为空且不相等则updateChildren")])]),r("h3",[n._v("updateChild")]),r("ul",[r("li",[r("p",[n._v("将旧节点的子节点和新节点的子节点提取出来")])]),r("li",[r("p",[n._v("新旧节点头尾各有两个指针，变量相互比较，四种比较方式")]),r("ul",[r("li",[n._v("oldS、oldE、S、E两两做sameVnode比较，有四种比较方式，当其中两个能匹配上那么真实dom中的相应节点会移到Vnode相应的位置")]),r("li",[n._v("匹配成功后，指针往中间移动")])])]),r("li",[r("p",[n._v("上一步比较没有匹配，有key的话会用key进行比较")]),r("ul",[r("li",[n._v("根据就节点的key生成一张hash表")]),r("li",[n._v("新节点的头尾与hash表做匹配判断是都相等")]),r("li",[n._v("如果匹配成功将就节点匹配的节点移到相应的位置")]),r("li",[n._v("如果匹配不成功则直接生成新节点插入")]),r("li",[n._v("如果没有key只会进行四种比较，指针中间的节点就做不到复用了")])])]),r("li",[r("p",[n._v("结束条件")]),r("ul",[r("li",[n._v("旧节点的头指针大于尾指针则将多余的新节点根据index添加到dom中")]),r("li",[n._v("新节点的头指针大于尾指针，那么将旧节点的头尾指针之间的节点删除")])])])]),r("h3",[n._v("sameVnode")]),r("ul",[r("li",[r("p",[n._v("比较两个节点是否相同")]),r("ul",[r("li",[n._v("key相同")]),r("li",[n._v("tag（当前节点的标签名）相同")]),r("li",[n._v("isComment（是否为注释节点）相同")]),r("li",[n._v("当标签是"),r("input"),n._v("的时候，type必须相同")]),r("li",[n._v("是否data（当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息）都有定义")])])])])])}],Qa={},Ya=Qa,Za=Object(m["a"])(Ya,Xa,Ka,!1,null,"580ec856",null),no=Za.exports,to=function(){var n=this;return n.$createElement,n._self._c,n._m(0)},ro=[function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[r("h4",[n._v("关于前端高级工程师面试")]),r("br"),r("pre",[n._v("\r\n"),r("h5",[n._v(" 一：基础知识")]),n._v("\r\nVue 基本的双向绑定实现原理"),r("br"),n._v("\r\nvue 生命周期 每个状态差别。"),r("br"),n._v("\r\n生命周期中何时能操作提取 DOM 样式属性？何时请求 API 渲染？为什么？ 销毁之前一般要处理哪些东西？"),r("br"),n._v("\r\n为什么要处理？到底是什么原因导致这种弊端存在？"),r("br"),n._v("\r\nVue 自定义指令实现基本底层原理？"),r("br"),n._v("\r\nVue mixin 原理 你是如何使用的 ？"),r("br"),n._v("\r\n如何做到路由无改变情况下点击菜单栏，当前页面局部刷新？\r\nInject 是否用过？Observe 是否用过？（这两个问题 牵扯高级部分，水平一般的也不会问。）\r\nVue 父子，兄弟组件传参问题。有哪些方法可以实现？你能说出几种？ 跨多个打开页面数据共享呢？\r\n说出几种实现途径。不论前后端都可以说 Vue 中如何监听调用原生 window 事件？ \r\n你是如何使用 VUE，UMD？还是 cli 方式？ Cli?2.x?3.x?常用配置?差别？\r\nVuex 的根本实现原理？\r\n你说熟悉 jquery，那你能否解释一下：事件派发，事件委托的原理？\r\nVue-router 的两种模式，深度解释一下。和 H5 新的 API 有何关联？ Vue-router 的路由拦截 或者叫 守护。\r\n你在项目中如何使用？全局的，局部的，权限的。\r\nVue-router 本质上是一种什么东西？（个人认为是哈希参照表,jJSON 配置文件）\r\n你们的前后端交互数据传输，使用的什么？是否做过封装？\r\nAxios,前后拦截封装，如何发送 formdata ，文件类型数据？\r\nES6 你开发中常用的一些方法，详细解释一下。\r\nES6 和 ES5 本质底层差别不大，大部分是语法糖。你对于语法糖怎么看？\r\n闭包原理？实际开发中你是如何使用？一般用来做什么？\r\n存储问题，几种存储的区别。\r\n跨域问题，解决方案，每种方案原理？ \r\nBootstrap 等 UI 框架栅栏布局原理。\r\nFlex 几个重要属性，或者讲出来可以对实现什么？\r\n数组的常用操作？\r\nObject.assign 是深拷贝还是浅拷贝？\r\n作用域链\r\n")]),r("pre",[n._v("\r\n"),r("h5",[n._v("二扩展层面")]),n._v("\r\nJs 本身存在一定局限性，在实际开法中，可能需要自己做一些常用工具函数的封装。 \r\n你是否用过插件，或者 js 扩展库，或者讲一讲自己的常用封装。 \r\n如果让你现在写一个常用的，对象的深层拷贝，讲一讲你的思路。\r\n如果让你现在写一个常用的，对象的深层合并（并去重），讲一讲你的思路。\r\n递归，如何跳出递归？你是否用过？ 运行种换肤问题。\r\nVuecli 多入口。 一般不问。\r\nVuecli webpack 你是逗深入了解 过？ 图片压缩，代码压缩， 文件名，等，这些一般略过。\r\n目前前端开发面向终端较多，各种设备，你是否有使用过跨多端开发框架。\r\n讲一讲 （跨多端框架很重要，跨多端输出工具其次） 和你配合开发过项目的前后端交互的后台开发语言有哪些？ \r\n你们的项目如何部署的？ \r\n你是否掌握其他后端可开发语言，如果会，讲一讲你的前后端独立开发怎么进行。\r\n也会稍微问一些语言的共通性，也就是相似的地方。 \r\n（一般的中上等以上的工程师，都基本会一些其他语言）\r\n"),r("h5",[n._v("三架构层次")]),n._v("\r\n你是否有过中大型项目独立开发经验？讲一讲，你是如何进行架构设计的。\r\n代码规范层次。 你做过这么多项目，是否有过封装，有哪些方向的封装，讲一讲。\r\n如果现在让你写一套样式库，你打算如何入手。\r\n超大型项目，运行种换肤问题。\r\n页面防抖问题，说根本。\r\n你是否写过通用函数封装，讲一讲都做过哪些？功用是什么，为什么需要这种封装？ \r\n你是都对你所使用的的 UI 框架二次优化过，讲一讲。 \r\n多个项目开发，你是否认为多数项目在操作层面的代码方面上有一定的相似性，你是逗做过 抽离封装，可以跨多个项目使用。深入讲一讲。 \r\n模块化开发，狭义上来讲是说组件。深层来理解，很多东西都可以分为模块，而大型项目 不进行模块化开发，几乎不可能。\r\n请从各个方面讲一讲，如果让你负责开发超大型项目，技 术架构方面你会如何处理？或者有什么想法都可以说说。\r\n前端静态化部署。 \r\n伪静态\r\n如果一套代码 应对一百个网站，每个网站存在一定差异性，如何规划？如何同步上新？\r\nSSR 问题。  \r\n首屏优化。网络很差的情况下如何首屏优化。 \r\nCDN 加速问题。 分布式问题 如果项目需要你用前端来写爬虫，你如何规划？\r\n"),r("h5",[n._v("四工作流和管理问题")]),n._v("\r\n这个也就是聊一聊谈谈，一般很少能到这一块的。\r\n工作流和管理，一部分是你是否有过协作 开发经验、大公司开发经验、管理多人负责项目经验。\r\n"),r("h5",[n._v("五技术主管和总监")]),n._v("\r\n技术主管和总监根本和以上这些都不在一个层次，属于管理层，但是基本都是可开发出身。\r\n技术能力基本肯定是真正的全栈，多语言精通的。还要能把握方向，懂得各部分沟通交流，熟悉工作和管理流程。 \r\n小公司的 就不谈这个问题了，没那么多要求。\r\n")])])}],eo={},ao=eo,oo=Object(m["a"])(ao,to,ro,!1,null,"d77512dc",null),so=oo.exports,io=function(){var n=this;return n.$createElement,n._self._c,n._m(0)},lo=[function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[r("h3",[n._v("nextTick")]),r("ul",[r("li",[r("p",[n._v("（1）为什么要有nextTick？")]),r("ul",[r("li",[r("p",[n._v("现象")]),r("ul",[r("li",[n._v("这段脚本执行我们猜测会依次打印：1、2、3。但是实际效果中，只会输出一次：3。")])])]),r("li",[r("p",[n._v("原因")]),r("ul",[r("li",[n._v("现在有这样的一种情况，mounted的时候test的值会被++循环执行1000次。 每次++时，都会根据响应式触发setter->Dep->Watcher->update->run。 如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。")]),r("li",[n._v("所以Vue实现了一个queue队列，在下一个Tick（或者是当前Tick的微任务阶段）的时候会统一执行queue中Watcher的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行1000次Watcher的run。最终更新视图只会直接将test对应的DOM的0变成1000。 保证更新视图操作DOM的动作是在当前栈执行完以后下一个Tick（或者是当前Tick的微任务阶段）的时候调用，大大优化了性能。")])])])])]),r("li",[r("p",[n._v("（2）nextTick用法示例")]),r("ul",[r("li",[n._v("模板")]),r("li",[n._v("Vue实例")]),r("li",[n._v("结果")]),r("li",[n._v("msg1和msg3显示的内容还是变换之前的，而msg2显示的内容是变换之后的。其根本原因是因为Vue中DOM更新是异步的")])])]),r("li",[r("p",[n._v("（3）nextTick的应用场景")]),r("ul",[r("li",[r("p",[n._v("1.在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中")]),r("ul",[r("li",[n._v("在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted()钩子函数，因为该钩子函数执行时所有的DOM挂载和渲染都已完成，此时在该钩子函数中进行任何DOM操作都不会有问题 。")])])]),r("li",[r("p",[n._v("2.在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。")])])])]),r("li",[r("p",[n._v("（4）nextTick的版本区别")]),r("ul",[r("li",[n._v("在 Vue 2.4 之前的版本，nextTick 几乎都是基于 micro task 实现的，但由于 micro task 的执行优先级非常高，在某些场景下它甚至要比事件冒泡还要快，就会导致一些诡异的问题，如 issue #4521、#6690、#6566；但是如果全部都改成 macro task，对一些有重绘和动画的场景也会有性能影响，如 issue #6813。所以最终 nextTick 采取的策略是默认走 micro task，对于一些 DOM 交互事件，如 v-on 绑定的事件回调函数的处理，会强制走 macro task。")])])])])])}],co={},po=co,uo=Object(m["a"])(po,io,lo,!1,null,"5541a092",null),mo=uo.exports,go=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},bo=[],ho="# mv*\r\n\r\n## MVC\r\n\r\n### MVC表面概念\r\n\r\n- Model（模型）---\x3e数据层（数据保存）\r\n\r\n\t- 需要运算的数据（以计算器为例）\r\n\r\n- View（视图）---\x3e视图层（用户界面）\r\n\r\n\t- 按钮及显示屏（以计算器为例）\r\n\r\n- Controller（控制）---\x3e控制层（业务逻辑）\r\n\r\n\t- 处理加减乘除内部的运算步骤 （以计算器为例）\r\n\r\n### 好处\r\n\r\n- 三者之间紧密联系但又相互独立，一个层面进行重构时不影响其他层面\r\n\r\n### 示意图\r\n\r\n- 从view接受指令\r\n- 从controller接受指令\r\n\r\n### 通信特点\r\n\r\n- 所有通信都是单向的\r\n\r\n## MVP\r\n\r\n### MVP表面概念\r\n\r\n- Model（模型）---\x3e数据层（数据保存）\r\n- View（视图）---\x3e视图层（用户界面）\r\n- Presenter（主持）---\x3e主持层\r\n\r\n### 示意图\r\n\r\n### 通信特点\r\n\r\n- 各部分通信都是双向的\r\n- view和model不发生关系，都是通过presenter\r\n- view非常薄，不部署任何业务逻辑，因此称为“被动视图”，即没有任何主动性。presenter非常厚，所有逻辑都部署在那里\r\n\r\n## MVVM\r\n\r\n### MVVM表面概念\r\n\r\n- Model（模型）---\x3e数据层（数据保存）\r\n- View（视图）---\x3e视图层（用户界面）\r\n- ViewModel\r\n\r\n### 示意图\r\n\r\n### 通信特点\r\n\r\n- 与MVP基本一致，唯一的区别就是MVVM采用了双向数据绑定，view的变化会自动反映在ViewModel上，反之亦然。\r\n\r\n",yo={data:function(){return{MainComponent:ho}}},fo=yo,vo=Object(m["a"])(fo,go,bo,!1,null,"50f98ff4",null),So=(vo.exports,{mixins:[k["c"]],components:{m2:wa,m3:Oa,m4:Ia,m5:qa,m6:$a,m7:no,m8:so,m9:mo},data:function(){return{tab:"m2",tab_level:2,tabs:[{label:"双向绑定原理",value:"m2"},{label:"监听缺陷",value:"m3"},{label:"Virtual Dom",value:"m4"},{label:"vue-router",value:"m5"},{label:"前后端路由",value:"m6"},{label:"diff算法",value:"m7"},{label:"nextTick",value:"m9"},{label:"面试",value:"m8"}]}}}),_o=So,ko=Object(m["a"])(_o,ma,da,!1,null,"6b4d3635",null),jo=ko.exports,wo=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[r(""+n.tab,{tag:"component"})],1)},xo=[],To=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},Co=[],Mo="# react\r\n\r\n## React\r\n\r\n### 概述\r\n\r\n- React 是一个用于构建用户界面的 JAVASCRIPT 库。\r\n- React主要用于构建UI，很人多认为 React 是 MVC 中的 V（视图）。\r\n- React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。\r\n- React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。\r\n\r\n### 特点\r\n\r\n- 1.声明式设计 −React采用声明范式，可以轻松描述应用。\r\n- 2.高效 −React通过对DOM的模拟，最大限度地减少与DOM的交互。\r\n- 3.灵活 −React可以与已知的库或框架很好地配合。\r\n- 4.JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。\r\n- 5.组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。\r\n- 6.单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。\r\n\r\n### React JSX\r\n\r\n- JSX 是 React 的核心组成部分，它使用 XML 标记的方式去直接声明界面，界面组件之间可以互相嵌套\r\n- 优点：\r\n\r\n\t- JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化。\r\n\t- 它是类型安全的，在编译过程中就能发现错误。\r\n\t- 使用 JSX 编写模板更加简单快速。\r\n\r\n- 用法\r\n\r\n\t- JSX 看起来类似 HTML ，我们可以看下实例:\r\n\r\n\t\t- ReactDOM.render(\r\n\t<h1>Hello, world!</h1>,\r\n\tdocument.getElementById('example')\r\n);\r\n\r\n\t- 独立文件\r\n\t- JavaScript 表达式\r\n\r\n\t\t- 我们可以在 JSX 中使用 JavaScript 表达式。表达式写在花括号 {} 中。实例如下：\r\n\r\n\t\t\t- ReactDOM.render(\r\n\t<div>\r\n\t  <h1>{1+1}</h1>\r\n\t</div>\r\n\t,\r\n\tdocument.getElementById('example')\r\n);\r\n\r\n\t- 在 JSX 中不能使用 if else 语句，单可以使用 conditional (三元运算) 表达式来替代。\r\n\t- 样式\r\n\r\n\t\t- React 推荐使用内联样式。我们可以使用 camelCase 语法来设置内联样式. React 会在指定元素数字后自动添加 px 。以下实例演示了为 h1 元素添加 myStyle 内联样式：\r\n\r\n\t\t\t- var myStyle = {\r\n\tfontSize: 100,\r\n\tcolor: '#FF0000'\r\n};\r\nReactDOM.render(\r\n\t<h1 style = {myStyle}>W3Cschool教程</h1>,\r\n\tdocument.getElementById('example')\r\n);\r\n\r\n\t- 注释\r\n\r\n\t\t- 注释需要写在花括号中\r\n\r\n\t\t\t- ReactDOM.render(\r\n\t<div>\r\n    <h1>W3Cschool教程</h1>\r\n    {/*注释...*/}\r\n \t</div>,\r\n\tdocument.getElementById('example')\r\n);\r\n\r\n\t- 数组\r\n\r\n\t\t- JSX 允许在模板中插入数组，数组会自动展开所有成员：\r\n\r\n\t\t\t- var arr = [\r\n  <h1>W3Cschool教程</h1>,\r\n  <h2>从W3Cschool开始！</h2>,\r\n];\r\nReactDOM.render(\r\n  <div>{arr}</div>,\r\n  document.getElementById('example')\r\n);\r\n\r\n### State(状态)\r\n\r\n- React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。\r\n\r\n\t- 当用户点击组件，导致状态变化，this.setState 方法就修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件\r\n\r\n### Props\r\n\r\n- state 和 props 主要的区别在于 props 是不可变的，而 state 可以根据与用户交互来改变。\r\n- State 和 Props\r\n\r\n\t- 我们可以在父组件中设置 state， 并通过在子组件上使用 props 将其传递到子组件上。\r\n\r\n- Props 验证\r\n\r\n\t- Props 验证使用 propTypes，它可以保证我们的应用组件被正确使用，React.PropTypes 提供很多验证器 (validator) 来验证传入数据是否有效。当向 props 传入无效数据时，JavaScript 控制台会抛出警告。\r\n\r\n\t\t- var title = \"W3Cschool教程\";\r\n// var title = 123;\r\nvar MyTitle = React.createClass({\r\n  propTypes: {\r\n    title: React.PropTypes.string.isRequired,\r\n  },\r\n\r\n  render: function() {\r\n     return <h1> {this.props.title} </h1>;\r\n   }\r\n});\r\nReactDOM.render(\r\n    <MyTitle title={title} />,\r\n    document.getElementById('example')\r\n);\r\n\r\n\t- 更多验证器说明如下：\r\n\r\n\t\t- propTypes: {\r\n    // 可以声明 prop 为指定的 JS 基本数据类型，默认情况，这些数据是可选的\r\n   optionalArray: React.PropTypes.array,\r\n    optionalBool: React.PropTypes.bool,\r\n    optionalFunc: React.PropTypes.func,\r\n    optionalNumber: React.PropTypes.number,\r\n    optionalObject: React.PropTypes.object,\r\n    optionalString: React.PropTypes.string,\r\n\r\n    // 可以被渲染的对象 numbers, strings, elements 或 array\r\n    optionalNode: React.PropTypes.node,\r\n\r\n    //  React 元素\r\n    optionalElement: React.PropTypes.element,\r\n\r\n    // 用 JS 的 instanceof 操作符声明 prop 为类的实例。\r\n    optionalMessage: React.PropTypes.instanceOf(Message),\r\n\r\n    // 用 enum 来限制 prop 只接受指定的值。\r\n    optionalEnum: React.PropTypes.oneOf(['News', 'Photos']),\r\n\r\n    // 可以是多个对象类型中的一个\r\n    optionalUnion: React.PropTypes.oneOfType([\r\n      React.PropTypes.string,\r\n      React.PropTypes.number,\r\n      React.PropTypes.instanceOf(Message)\r\n    ]),\r\n\r\n    // 指定类型组成的数组\r\n    optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number),\r\n\r\n    // 指定类型的属性构成的对象\r\n    optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number),\r\n\r\n    // 特定 shape 参数的对象\r\n    optionalObjectWithShape: React.PropTypes.shape({\r\n      color: React.PropTypes.string,\r\n      fontSize: React.PropTypes.number\r\n    }),\r\n\r\n    // 任意类型加上 `isRequired` 来使 prop 不可空。\r\n    requiredFunc: React.PropTypes.func.isRequired,\r\n\r\n    // 不可空的任意类型\r\n    requiredAny: React.PropTypes.any.isRequired,\r\n\r\n    // 自定义验证器。如果验证失败需要返回一个 Error 对象。不要直接使用 `console.warn` 或抛异常，因为这样 `oneOfType` 会失效。\r\n    customProp: function(props, propName, componentName) {\r\n      if (!/matchme/.test(props[propName])) {\r\n        return new Error('Validation failed!');\r\n      }\r\n    }\r\n  },\r\n\r\n### React 组件 API\r\n\r\n- 设置状态：setState\r\n\r\n\t- setState(object nextState[, function callback])\r\n\r\n\t\t- nextState，将要设置的新状态，该状态会和当前的state合并\r\n\t\t- callback，可选参数，回调函数。该函数会在setState设置成功，且组件重新渲染后调用。\r\n\t\t- 合并nextState和当前state，并重新渲染组件。setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法。\r\n\t\t- 关于setState\r\n\r\n\t\t\t- 不能在组件内部通过this.state修改状态，因为该状态会在调用setState()后被替换。\r\n\t\t\t- setState()并不会立即改变this.state，而是创建一个即将处理的state。setState()并不一定是同步的，为了提升性能React会批量执行state和DOM渲染。\r\n\t\t\t- setState()总是会触发一次组件重绘，除非在shouldComponentUpdate()中实现了一些条件渲染逻辑。\r\n\r\n- 替换状态：replaceState\r\n\r\n\t- replaceState(object nextState[, function callback])\r\n\r\n\t\t- nextState，将要设置的新状态，该状态会替换当前的state。\r\n\t\t- callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。\r\n\t\t- replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。\r\n\r\n- 设置属性：setProps\r\n\r\n\t- setProps(object nextProps[, function callback])\r\n\r\n\t\t- nextProps，将要设置的新属性，该状态会和当前的props合并\r\n\t\t- callback，可选参数，回调函数。该函数会在setProps设置成功，且组件重新渲染后调用。\r\n\t\t- props相当于组件的数据流，它总是会从父组件向下传递至所有的子组件中。\r\n\t\t- 当和一个外部的JavaScript应用集成时，我们可能会需要向组件传递数据或通知React.render()组件需要重新渲染，可以使用setProps()。\r\n\r\n更新组件，我可以在节点上再次调用React.render()，也可以通过setProps()方法改变组件属性，触发组件重新渲染。\r\n\r\n- 替换属性：replaceProps\r\n\r\n\t- replaceProps(object nextProps[, function callback])\r\n\r\n\t\t- nextProps，将要设置的新属性，该属性会替换当前的props。\r\n\t\t- callback，可选参数，回调函数。该函数会在replaceProps设置成功，且组件重新渲染后调用。\r\n\t\t- replaceProps()方法与setProps类似，但它会删除原有props\r\n\r\n- 强制更新：forceUpdate\r\n\r\n\t- forceUpdate([function callback])\r\n\r\n\t\t- callback，可选参数，回调函数。该函数会在组件render()方法调用后调用。\r\n\t\t- forceUpdate()方法会使组件调用自身的render()方法重新渲染组件，组件的子组件也会调用自己的render()。但是，组件重新渲染时，依然会读取this.props和this.state，如果状态没有改变，那么React只会更新DOM。\r\n\r\nforceUpdate()方法适用于this.props和this.state之外的组件重绘（如：修改了this.state后），通过该方法通知React需要调用render()\r\n\r\n一般来说，应该尽量避免使用forceUpdate()，而仅从this.props和this.state中读取状态并由React触发render()调用。\r\n\r\n- 获取DOM节点：findDOMNode\r\n\r\n\t- DOMElement findDOMNode()\r\n\r\n\t\t- 返回值：DOM元素DOMElement\r\n\r\n\t\t\t- 如果组件已经挂载到DOM中，该方法返回对应的本地浏览器 DOM 元素。当render返回null 或 false时，\r\nthis.findDOMNode()也会返回null。从DOM 中读取值的时候，该方法很有用，如：获取表单字段的值和做一些 DOM 操作。\r\n\r\n- 判断组件挂载状态：isMounted\r\n\r\n\t- bool isMounted()\r\n\r\n\t\t- 返回值：true或false，表示组件是否已挂载到DOM中\r\n\r\n\t\t\t- isMounted()方法用于判断组件是否已挂载到DOM中。可以使用该方法保证了setState()和forceUpdate()在异步场景下的调用不会出错。\r\n\r\n### React 组件生命周期\r\n\r\n- React 组件的生命周期函数，又叫钩子函数，它能响应不同的状态。\r\n\r\n\t- 组件的生命周期可分成三个状态：\r\n\r\n\t\t- Mounting：已插入真实 DOM\r\n\t\t- Updating：正在被重新渲染\r\n\t\t- Unmounting：已移出真实 DOM\r\n\r\n\t- 生命周期的方法有：\r\n\r\n\t\t- componentWillMount 在渲染前调用,在客户端也在服务端。\r\n\t\t- componentDidMount : 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。\r\n 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异部操作阻塞UI)。\r\n\t\t- componentWillReceiveProps 在组件接收到一个新的prop时被调用。这个方法在初始化render时不会被调用。\r\n\t\t- shouldComponentUpdate 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。 \r\n可以在你确认不需要更新组件时使用。\r\n\t\t- componentWillUpdate在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。\r\n\t\t- componentDidUpdate 在组件完成更新后立即调用。在初始化时不会被调用。\r\n\t\t- componentWillUnmount在组件从 DOM 中移除的时候立刻被调用。\r\n\r\n### React AJAX\r\n\r\n- React 组件的数据可以通过 componentDidMount 方法中的 Ajax 来获取，当从服务端获取数据库可以将数据存储在 state 中，再用 this.setState 方法重新渲染 UI。\r\n- 当使用异步加载数据时，在组件卸载前使用 componentWillUnmount 来取消未完成的请求。\r\n\r\n### React Refs\r\n\r\n- React 支持一种非常特殊的属性 Ref ，你可以用来绑定到 render() 输出的任何组件上。\r\n- 这个特殊的属性允许你引用 render() 返回的相应的支撑实例（ backing instance ）。这样就可以确保在任何时间总是拿到正确的实例。\r\n- ref 属性的值可以是一个字符串也可以是一个函数。\r\n- 使用方法\r\n\r\n\t- 绑定一个 ref 属性到 render 的返回值上：\r\n\r\n\t\t- <input ref=\"myInput\" />\r\n\r\n\t\t\t- 在其它代码中，通过 this.refs 获取支撑实例:\r\n\r\n\t\t\t\t- var input = this.refs.myInput;\r\nvar inputValue = input.value;\r\nvar inputRect = input.getBoundingClientRect();\r\n\r\n## Redux\r\n\r\n### 三个基本原则\r\n\r\n- 整个应用只有唯一一个可信数据源，也就是只有一个 Store\r\n- State 只能通过触发 Action 来更改\r\n- State 的更改必须写成纯函数，也就是每次更改总是返回一个新的 State，在 Redux 里这种函数称为 Reducer\r\n\r\n### Actions\r\n\r\n- Action 很简单，就是一个单纯的包含 { type, payload } 的对象，type 是一个常量用来标示动作类型，payload 是这个动作携带的数据。Action 需要通过 store.dispatch() 方法来发送。\r\n\r\n\t- 比如一个最简单的 action：\r\n\r\n\t\t- {\r\n  type: 'ADD_TODO',\r\n  text: 'Build my first Redux app'\r\n}\r\n\r\n\t- 一般来说，会使用函数（Action Creators）来生成 action，这样会有更大的灵活性，Action Creators 是一个 pure function，它最后会返回一个 action 对象：\r\n\r\n\t\t- function addTodo(text) {\r\n  return {\r\n    type: 'ADD_TODO',\r\n    text\r\n  }\r\n}\r\n\t\t- 所以现在要触发一个动作只要调用 dispatch: dispatch(addTodo(text))\r\n稍后会讲到如何拿到 store.dispatch\r\n\r\n### Reducers\r\n\r\n- Reducer 用来处理 Action 触发的对状态树的更改。\r\n- 所以一个 reducer 函数会接受 oldState 和 action 两个参数，返回一个新的 state：(oldState, action) => newState。一个简单的 reducer 可能类似这样：\r\n\r\n\t- const initialState = {\r\n  a: 'a',\r\n  b: 'b'\r\n};\r\n\r\nfunction someApp(state = initialState, action) {\r\n  switch (action.type) {\r\n    case 'CHANGE_A':\r\n      return { ...state, a: 'Modified a' };\r\n    case 'CHANGE_B':\r\n      return { ...state, b: action.payload };\r\n    default:\r\n      return state\r\n  }\r\n}\r\n\t- 值得注意的有两点：\r\n\r\n\t\t- 我们用到了 object spread 语法 确保不会更改到 oldState 而是返回一个 newState\r\n\t\t- 对于不需要处理的 action，直接返回 oldState\r\n\r\n- Reducer 也是 pure function，这点非常重要，所以绝对不要在 reducer 里面做一些引入 side-effects 的事情，比如：\r\n\r\n\t- 直接修改 state 参数对象\r\n\t- 请求 API\r\n\t- 调用不纯的函数，比如 Data.now() Math.random()\r\n\r\n- 因为 Redux 里面只有一个 Store，对应一个 State 状态，所以整个 State 对象就是由一个 reducer 函数管理，但是如果所有的状态更改逻辑都放在这一个 reducer 里面，显然会变得越来越巨大，越来越难以维护。得益于纯函数的实现，我们只需要稍微变通一下，让状态树上的每个字段都有一个 reducer 函数来管理就可以拆分成很小的 reducer 了：\r\n\r\n\t- function someApp(state = {}, action) {\r\n  return {\r\n    a: reducerA(state.a, action),\r\n    b: reducerB(state.b, action)\r\n  };\r\n}\r\n\t- Redux 提供了一个工具函数 combineReducers 来简化这种 reducer 合并：\r\n\r\n\t\t- import { combineReducers } from 'redux';\r\n\r\nconst someApp = combineReducers({\r\n  a: reducerA,\r\n  b: reducerB\r\n});\r\n\r\n### Store\r\n\r\n- 现在有了 Action 和 Reducer，Store 的作用就是连接这两者，Store 的作用有这么几个：\r\n\r\n\t- Hold 住整个应用的 State 状态树\r\n\t- 提供一个 getState() 方法获取 State\r\n\t- 提供一个 dispatch() 方法发送 action 更改 State\r\n\t- 提供一个 subscribe() 方法注册回调函数监听 State 的更改\r\n\r\n- 创建一个 Store 很容易，将 root reducer 函数传递给 createStore 方法即可：\r\n\r\n\t- import { createStore } from 'redux';\r\nimport someApp from './reducers';\r\nlet store = createStore(someApp);\r\n\r\n// 你也可以额外指定一个初始 State（initialState），这对于服务端渲染很有用\r\n// let store = createStore(someApp, window.STATE_FROM_SERVER);\r\n\r\n\t\t- 现在我们就拿到了 store.dispatch，可以用来分发 action 了：\r\n\r\n\t\t\t- let unsubscribe = store.subscribe(() => console.log(store.getState()));\r\n\r\n// Dispatch\r\nstore.dispatch({ type: 'CHANGE_A' });\r\nstore.dispatch({ type: 'CHANGE_B', payload: 'Modified b' });\r\n\r\n// Stop listening to state updates\r\nunsubscribe();\r\n\r\n### Data Flow\r\n\r\n- 以上提到的 store.dispatch(action) -> reducer(state, action) -> store.getState() 其实就构成了一个“单向数据流”，我们再来总结一下。\r\n\r\n\t- 1. 调用 store.dispatch(action)\r\n\r\n\t\t- Action 是一个包含 { type, payload } 的对象，它描述了“发生了什么”，比如：\r\n\r\n\t\t\t- { type: 'LIKE_ARTICLE', articleID: 42 }\r\n{ type: 'FETCH_USER_SUCCESS', response: { id: 3, name: 'Mary' } }\r\n{ type: 'ADD_TODO', text: 'Read the Redux docs.' }\r\n\r\n\t\t- 你可以在任何地方调用 store.dispatch(action)，比如组件内部，Ajax 回调函数里面等等。\r\n\r\n\t- 2. Action 会触发给 Store 指定的 root reducer\r\n\r\n\t\t- root reducer 会返回一个完整的状态树，State 对象上的各个字段值可以由各自的 reducer 函数处理并返回新的值。\r\n\r\n\t\t\t- reducer 函数接受 (state, action) 两个参数\r\n\t\t\t- reducer 函数判断 action.type 然后处理对应的 action.payload 数据来更新并返回一个新的 state\r\n\r\n\t- 3. Store 会保存 root reducer 返回的状态树\r\n\r\n\t\t- 新的 State 会替代旧的 State，然后所有 store.subscribe(listener) 注册的回调函数会被调用，在回调函数里面可以通过 store.getState() 拿到新的 State。\r\n\r\n### 在 React 应用中使用 Redux\r\n\r\n- 和 Flux 类似，Redux 也是需要注册一个回调函数 store.subscribe(listener) 来获取 State 的更新，然后我们要在 listener 里面调用 setState() 来更新 React 组件。\r\nRedux 官方提供了 react-redux 来简化 React 和 Redux 之间的绑定，不再需要像 Flux 那样手动注册／解绑回调函数。\r\n- <Provider>\r\n\r\n\t- <Provider> 作为一个容器组件，用来接受 Store，并且让 Store 对子组件可用，用法如下：\r\n\r\n\t\t- import { render } from 'react-dom';\r\nimport { Provider } from 'react-redux';\r\nimport App from './app';\r\n\r\nrender(\r\n  <Provider store={store}>\r\n    <App />\r\n  </Provider>,\r\n  document.getElementById('root')\r\n);\r\n\t\t- 这时候 <Provider> 里面的子组件 <App /> 才可以使用 connect 方法关联 store。\r\n\t\t- <Provider> 的实现很简单，他利用了 React 一个（暂时）隐藏的特性 Contexts，Context 用来传递一些父容器的属性对所有子孙组件可见，在某些场景下面避免了用 props 传递多层组件的繁琐，\r\n\r\n- Connect\r\n\r\n\t- connect() 这个方法略微复杂一点，主要是因为它的用法非常灵活：connect([mapStateToProps], mapDispatchToProps], [mergeProps], [options])，它最多接受4个参数，都是可选的，并且这个方法调用会返回另一个函数，这个返回的函数来接受一个组件类作为参数，最后才返回一个和 Redux store 关联起来的新组件，类似这样：\r\n\r\n\t\t- class App extends Component { ... }\r\n\r\nexport default connect()(App);\r\n\r\n\t\t\t- 这样就可以在 App 这个组件里面通过 props 拿到 Store 的 dispatch 方法，但是注意现在的 App 没有监听 Store 的状态更改，如果要监听 Store 的状态更改，必须要指定 mapStateToProps 参数。\r\n\r\n\t\t\t\t- [mapStateToProps(state, [ownProps]): stateProps]: 第一个可选参数是一个函数，只有指定了这个参数，这个关联（connected）组件才会监听 Redux Store 的更新，每次更新都会调用 mapStateToProps 这个函数，返回一个字面量对象将会合并到组件的 props 属性。 ownProps 是可选的第二个参数，它是传递给组件的 props，当组件获取到新的 props 时，ownProps 都会拿到这个值并且执行 mapStateToProps 这个函数。\r\n\t\t\t\t- [mapDispatchProps(dispatch, [ownProps]): dispatchProps]: 这个函数用来指定如何传递 dispatch 给组件，在这个函数里面直接 dispatch action creator，返回一个字面量对象将会合并到组件的 props 属性，这样关联组件可以直接通过 props 调用到 action， Redux 提供了一个 bindActionCreators() 辅助函数来简化这种写法。 如果省略这个参数，默认直接把 dispatch 作为 props 传入。ownProps 作用同上。\r\n\r\n",Po={data:function(){return{MainComponent:Mo}}},Oo=Po,Eo=Object(m["a"])(Oo,To,Co,!1,null,"38db8563",null),Ro=Eo.exports,No=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent1}}),r("q-markdown",{attrs:{src:n.MainComponent2}})],1)},Ao=[],Do="\x3c!--\n * @Date           : 2021-05-05 03:45:03\n * @FilePath       : /jinnian-space/src/pages/web/react/md/react基础Day01-React概述&脚手架搭建&JSX&组件.md\n * @Description    : \n--\x3e\n\n\n# React基础知识点\n\n## 目标\n\n- 能够说出React是什么\n- 能够说出React的特点\n- 能够掌握React的基本使用\n- 能够使用React脚手架\n\n## 什么是React （★★★）\n\nReact是一个用于构建用户界面的javaScript库，起源于facebook的内部项目，后续在13年开源了出来\n\n### 特点\n\n- 声明式\n\n你只需要描述UI看起来是什么样式，就跟写HTML一样，React负责渲染UI\n\n- 基于组件\n\n组件时React最重要的内容，组件表示页面中的部分内容\n\n- 学习一次，随处使用\n\n使用React可以开发Web应用，使用React可以开发移动端，可以开发VR应用\n\n## React基本使用\n\n### React的安装\n\nnpm i react react-dom \n\n- react 包是核心，提供创建元素，组件等功能\n- react-dom 包提供DOM相关功能\n\n### React的使用\n\n- 引入react和react-dom的两个js文件\n\n```html\n<script src=\"./node_modules/react/umd/react.development.js\"><\/script>\n<script src=\"./node_modules/react-dom/umd/react-dom.development.js\"><\/script>\n```\n\n- 创建React元素\n\n```javascript\n// 创建元素节点\n// 1. 元素名称\n// 2. 元素属性 传递的是个对象\n// 3. 元素内容\nlet title = React.createElement('li', null, 'hellow react');\n```\n\n- 渲染到页面\n\n```javascript\n// 渲染到页面\nReactDOM.render(title, root)\n```\n\n## React脚手架（★★★）\n\n### React脚手架意义\n\n- 脚手架是开发现代Web应用的必备\n- 充分利用 Webpack，Babel，ESLint等工具辅助项目开发\n- 零配置，无需手动配置繁琐的工具即可使用\n- 关注业务，而不是工具配置\n\n### 使用React脚手架初始化项目\n\n- 初始化项目，命令： npx create-react-app my-pro\n  - npx 目的：提升包内提供的命令行工具的使用体验\n  - 原来：先安装脚手架包，再使用这个包中提供的命令\n  - 现在：无需安装脚手架包，就可以直接使用这个包提供的命令\n  - create-react-app  这个是脚手架名称 不能随意更改\n  - my-pro  自己定义的项目名称\n- 启动项目，在项目根目录执行命令： npm start\n\nyarn命令简介\n\n- yarn 是Facebook发布的包管理器，可以看做是npm的替代品，功能与npm相同\n- yarn具有快速，可靠和安全的特点\n- 初始化新项目：yarn init\n- 安装包： yarn add 包名称\n- 安装项目依赖： yarn\n\n### 脚手架中使用React\n\n- 导入react和react-dom两个包\n\n```react\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n```\n\n- 创建元素\n\n```react\nlet h1 = React.createElement('h1',null,'我是标题')\n```\n\n- 渲染到页面\n\n```react\nReactDOM.render(h1,document.getElementById('root'))\n```\n\n# JSX的使用\n\n## 目标\n\n- 知道什么是JSX\n- 能够使用JSX创建React元素\n- 能够在JSX中使用JavaScript表达式\n- 能够使用JSX的条件渲染和列表渲染\n- 能够给JSX添加样式\n\n## 概述\n\n#### JSX产生的原因\n\n由于通过createElement()方法创建的React元素有一些问题，代码比较繁琐，结构不直观，无法一眼看出描述的结构，不优雅，用户体验不爽\n\n#### JSX的概述\n\nJSX是JavaScript XML 的简写，表示在JavaScript代码中写HTML格式的代码\n\n优势：声明式语法更加直观，与HTML结构相同，降低了学习成本，提升开发效率\n\n## 简单入门使用（★★★）\n\n#### 使用步骤\n\n- 使用JSX语法创建react元素\n\n```react\nlet h1 = <h1>我是通过JSX创建的元素</h1>\n```\n\n- 使用ReactDOM来渲染元素\n\n```react\nReactDOM.render(h1,document.getElementById('root'))\n```\n\n#### 为什么在脚手架中可以使用JSX语法\n\n- JSX 不是标准的ECMAScript语法，它是ECMAScript的语法拓展\n- 需要使用babel编译处理后，才能在浏览器环境中使用\n- create-react-app脚手架中已经默认有该配置，无需手动配置\n- 编译JSX语法的包： @bable/preset-react\n\n#### 注意点\n\n- React元素的属性名使用驼峰命名法\n- 特殊属性名：class -> className，for -> htmlFor，tabindex -> tabIndex\n- 如果没有子节点的React元素可以用 `/>` 来结束\n- 推荐：使用 小括号包裹JSX，从而避免JS中自动插入分号报错\n\n## JSX语法（★★★）\n\nJSX是来描述页面的结构，我们一般在编写业务逻辑渲染页面的时候，需要涉及到传递值，调用函数，判断条件，循环等，这一些在JSX中都能得到支持\n\n#### 嵌入JS表达式\n\n语法：{JavaScritp表达式}\n\n \n\n##### 注意点\n\n- 只要是合法的js表达式都可以进行嵌入\n- JSX自身也是js表达式\n- 注意：js中的对象是一个例外，一般只会出现在style属性中\n- 注意：在{}中不能出现语句\n\n#### 条件渲染\n\n根据不同的条件来渲染不同的JSX结构\n\n```react\nlet isLoading = true\nlet loading = ()=>{\n    if(isLoading){\n        return <div>Loading...</div>\n    }\n    return <div>加载完成</div>\n}\n```\n\n可以发现，写JSX的条件渲染与我们之前编写代码的逻辑是差不多的，根据不同的判断逻辑，返回不同的 JSX结构，然后渲染到页面中\n\n#### 列表渲染\n\n- 如果需要渲染一组数据，我们应该使用数组的 map () 方法\n- 注意：渲染列表的时候需要添加key属性，key属性的值要保证唯一\n- 原则：map()遍历谁，就给谁添加key属性\n- 注意：尽量避免使用索引号作为key\n\n```react\nlet arr = [{\n    id:1,\n    name:'三国演义'\n},{\n    id:2,\n    name:'水浒传'\n},{\n    id:3,\n    name:'西游记'\n},{\n    id:4,\n    name:'红楼梦'\n}]\nlet ul = (<ul>\n    {arr.map(item => <li key={item.id}>{item.name}</li>)}\n</ul>)\nReactDOM.render(ul,document.getElementById('root'))\n```\n\n#### 样式处理\n\n##### 行内样式 -style\n\n在style里面我们通过对象的方式传递数据\n\n```react\n<li key={item.id} style={{'color': 'red',\"backgroundColor\": 'pink'}}>{item.name}</li>\n```\n\n这种方式比较的麻烦，不方便进行阅读，而且还会导致代码比较的繁琐\n\n##### 类名 -className\n\n创建CSS文件编写样式代码\n\n```css\n.container {\n    text-align: center\n}\n```\n\n在js中进行引入，然后设置类名即可\n\n```react\nimport './css/index.css'\n\n<li className='container' key={item.id} style={{'color': 'red',\"backgroundColor\": 'pink'}}>{item.name}</li>\n```\n\n### 小结\n\n\n \n\n```react\n/*\n * @Date           : 2021-05-05 04:14:10\n * @FilePath       : /app-demo-1/src/view/view1.js\n * @Description    : \n */\nimport React from \"react\"\nimport Tset1 from  \"../components/Test1\"\nconst classes666={\n    root:{\n    },\n    red:{\n        color:\"red\",\n        backgroundColor:\"#ccc\"\n    }\n}\nconst name1='66sxsx999999'\nconst div2= <h3>KKKKKKKKKKKKKK</h3>\nconst list1=[\n    { label: \"react\", value: \"m1\" },\n    { label: \"基础\", value: \"m2\" },\n]\n// {} 中 不能写 对象表达式 if 等表达式\nconst nn=5\nconst  say1 = ()=>{\n    if(nn>5){\n        return (  <div> 大于5</div> )\n    }else{\n        return (  <div> 小于等于5</div> )  \n    }\n}\n\n\nclass Hello extends React.Component{\n    render(){\n        return <div> HELLO   类方法 组件</div>\n    }\n}\n\nfunction View1(){\n    return (\n        <div>\n            <h1 className=\"classesxsx666\">我 {name1} 带你.......{classes666.red.color}...........</h1>\n            <div>{say1()}</div>\n            <div>{div2}</div>\n            <Tset1/>\n            <div  style={classes666.red}>\n                {  list1.map(x=><div key={x.label}>{x.label}----------{x.value}</div>)}\n            </div>\n            <div><Hello/></div>\n        </div>\n    )\n}\nexport default View1;\n```\n\n- JSX是React的核心内容\n- JSX表示在JS代码中写HTML结构，是React声明式的体现\n- 使用JSX配合嵌入的JS表达式、条件渲染、列表渲染、可以描述任意UI结构\n- 推荐使用className的方式给JSX添加样式\n- React完全利用JS语言自身的能力来编写UI，而不是造轮子增强HTML功能\n\n# React组件\n\n## 目标\n\n- 能够使用函数创建组件\n- 能够使用class创建组件\n- 能够给React元素绑定事件\n- 能够使用state和setState()\n- 能够处理事件中的this指向问题\n\n## React组件介绍\n\n- 组件是React的一等公民，使用React就是在用组件\n- 组件表示页面中的部分功能\n- 组合多个组件实现完整的页面功能\n- 特点：可复用、独立、可组合\n\n![](./img/web/react/react基础Day01-React概述&脚手架搭建&JSX&组件/组件.png)\n\n## 组件的创建方式\n\n### 函数创建组件\n\n- 函数组件：使用JS的函数创建组件\n- **约定1：**函数名称必须以大写字母开头\n- **约定2：**函数组件必须有返回值，表示该组件的结构\n- 如果返回值为null，表示不渲染任何内容\n\n#### 示例demo\n\n编写函数组件\n\n```react\nfunction Hello() {\n    return (\n        <div>这是第一个函数组件</div>\n    )\n}\n```\n\n利用ReactDOM.render()进行渲染\n\n```react\nReactDOM.render(<Hello />,document.getElementById('root'))\n```\n\n### 类组件（★★★）\n\n- 使用ES6语法的class创建的组件\n- 约定1：类名称也必须要大写字母开头\n- 约定2：类组件应该继承React.Component父类，从而可以使用父类中提供的方法或者属性\n- 约定3：类组件必须提供 render 方法\n- 约定4：render方法中必须要有return返回值\n\n#### 示例demo\n\n创建class类，继承React.Component，在里面提供render方法，在return里面返回内容\n\n```react\nclass Hello extends React.Component{\n    render(){\n        return (\n            <div>这是第一个类组件</div>\n        )\n    }\n}\n```\n\n通过ReactDOM进行渲染\n\n```react\nReactDOM.render(<Hello />,document.getElementById('root'))\n```\n\n### 抽离成单独的JS文件（★★★）\n\n- 思考：项目中组件多了之后，该如何组织这些组件？\n- 选择一：将所有的组件放在同一个JS文件中\n- 选择二：将每个组件放到单独的JS文件中\n- **组件作为一个独立的个体，一般都会放到一个单独的JS文件中**\n\n#### 示例demo\n\n- 创建Hello.js\n- 在Hello.js 中导入React，创建组件，在Hello.js中导出\n\n```react\nimport React from 'react'\n\nexport default class extends React.Component {\n    render(){\n        return (\n            <div>单独抽离出来的 Hello</div>\n        )\n    }\n}\n```\n\n- 在index.js中导入Hello组件，渲染到页面\n\n```react\nimport Hello from './js/Hello'\nReactDOM.render(<Hello />,document.getElementById('root'))\n```\n\n## React事件处理（★★★）\n\n### 事件绑定\n\n- React事件绑定语法与DOM事件语法相似\n- 语法：on+事件名称=事件处理函数，比如  onClick = function(){}\n- 注意：React事件采用驼峰命名法\n\n#### 示例demo\n\n```react\nexport default class extends React.Component {\n    clickHandle(e){\n        console.log('点了')\n    }\n    render(){\n        return (\n            <div><button onClick = {this.clickHandle}>点我点我点我</button></div>\n        )\n    }\n}\n```\n\n#### 小结\n\n- 在React中绑定事件与原生很类似\n- 需要注意点在于，在React绑定事件需要遵循驼峰命名法\n- 类组件与函数组件绑定事件是差不多的，只是在类组件中绑定事件函数的时候需要用到this，代表指向当前的类的引用，在函数中不需要调用this\n\n### 事件对象\n\n- 可以通过事件处理函数的参数获取到事件对象\n- React中的事件对象叫做：合成事件\n- 合成事件：兼容所有浏览器，无需担心跨浏览器兼容问题\n- 除兼容所有浏览器外，它还拥有和浏览器原生事件相同的接口，包括 `stopPropagation()`和 `preventDefault()`\n- 如果你想获取到原生事件对象，可以通过 `nativeEvent` 属性来进行获取\n\n#### 示例demo\n\n```react\nexport default class extends React.Component {\n    clickHandle(e){\n        // 获取原生事件对象\n        console.log(e.nativeEvent)\n    }\n    render(){\n        return (\n            <div><button onClick = {this.clickHandle}>点我点我点我</button></div>\n        )\n    }\n}\n```\n\n### 支持的事件（有兴趣的课下去研究）\n\n- Clipboard Events  剪切板事件\n\n  - 事件名 ：onCopy onCut onPaste\n  - 属性     ：DOMDataTransfer clipboardData\n\n- compositionEvent  复合事件\n\n  - 事件名： onCompositionEnd onCompositionStart onCompositionUpdate\n  - 属性： string data\n\n- Keyboard Events  键盘事件\n\n  - 事件名：onKeyDown onKeyPress onKeyUp\n  - 属性： 例如 number keyCode  太多就不一一列举\n\n- Focus Events  焦点事件  （这些焦点事件在 React DOM 上的所有元素都有效，不只是表单元素）\n\n  - 事件名： onFocus onBlur\n  - 属性： DOMEventTarget relatedTarget\n\n- Form Events  表单事件\n\n  - 事件名： onChange onInput onInvalid onSubmit\n\n- Mouse Events  鼠标事件\n\n  - 事件名：\n\n    ```react\n    onClick onContextMenu onDoubleClick onDrag onDragEnd onDragEnter onDragExit\n    onDragLeave onDragOver onDragStart onDrop onMouseDown onMouseEnter onMouseLeave\n    onMouseMove onMouseOut onMouseOver onMouseUp\n    ```\n\n- Pointer Events  指针事件\n\n  - 事件名：\n\n    ```react\n    onPointerDown onPointerMove onPointerUp onPointerCancel onGotPointerCapture\n    onLostPointerCapture onPointerEnter onPointerLeave onPointerOver onPointerOut\n    ```\n\n- Selection Events  选择事件\n\n  - 事件名：onSelect\n\n- Touch Events  触摸事件\n\n  - 事件名：onTouchCancel onTouchEnd onTouchMove onTouchStart\n\n- UI Events  UI 事件\n\n  - 事件名： onScroll\n\n- Wheel Events  滚轮事件\n\n  - 事件名：onWheel\n\n  - 属性： \n\n    ```react\n    number deltaMode\n    number deltaX\n    number deltaY\n    number deltaZ\n    ```\n\n- Media Events  媒体事件\n\n  - 事件名：\n\n    ```react\n    onAbort onCanPlay onCanPlayThrough onDurationChange onEmptied onEncrypted\n    onEnded onError onLoadedData onLoadedMetadata onLoadStart onPause onPlay\n    onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend\n    onTimeUpdate onVolumeChange onWaiting\n    ```\n\n- Image Events 图像事件\n\n  - 事件名：onLoad onError\n\n- Animation Events 动画事件\n\n  - 事件名：onAnimationStart onAnimationEnd onAnimationIteration\n\n- Transition Events 过渡事件\n\n  - 事件名：onTransitionEnd\n\n- Other Events  其他事件\n\n  - 事件名： onToggle\n\n## 有状态组件和无状态组件\n\n- 函数组件又叫做 无状态组件，类组件又叫做 有状态组件\n- 状态(state) 即数据\n- 函数组件没有自己的状态，只负责数据展示\n- 类组件有自己的状态，负责更新UI，让页面动起来\n\n![](./img/web/react/react基础Day01-React概述&脚手架搭建&JSX&组件/状态.png)\n\n## State和SetState（★★★）\n\n### state基本使用\n\n- 状态(state)即数据，是组件内部的私有数据，只能在组件内部使用\n- state的值是对象，表示一个组件中可以有多个数据\n- 通过this.state来获取状态\n\n#### 示例demo\n\n```react\nexport default class extends React.Component {\n    constructor(){\n        super()\n\n        // 第一种初始化方式\n        this.state = {\n            count : 0\n        }\n    }\n    // 第二种初始化方式\n    state = {\n        count:1\n    }\n    render(){\n        return (\n            <div>计数器 :{this.state.count}</div>\n        )\n    }\n}\n```\n\n### setState() 修改状态\n\n- 状态是可变的\n- 语法：this.setState({要修改的数据})\n- **注意：不要直接修改state中的值，这是错误的**\n- setState() 作用：1.修改 state 2.更新UI\n- 思想：数据驱动视图\n\n![](./img/web/react/react基础Day01-React概述&脚手架搭建&JSX&组件/修改状态.png)\n\n#### 示例demo\n\n```react\nexport default class extends React.Component {\n    // 第二种初始化方式\n    state = {\n        count:1\n    }\n    render(){\n        return (\n            <div>\n                <div>计数器 :{this.state.count}</div>\n                <button onClick={() => {\n                     this.setState({\n            \t \t\tcount: this.state.count+1\n           \t\t\t  })   \n                }}>+1</button>\n            </div>\n        )\n    }\n}\n```\n\n#### 小结\n\n- 修改state里面的值我们需要通过 this.setState() 来进行修改\n- React底层会有监听，一旦我们调用了setState导致了数据的变化，就会重新调用一次render方法，重新渲染当前组件\n\n### 抽取事件处理函数\n\n- 当我们把上面代码的事件处理程序抽取出来后，会报错，找不到this\n\n![](./img/web/react/react基础Day01-React概述&脚手架搭建&JSX&组件/this找不到.png)\n\n#### 原因\n\n- 在JSX中我们写的事件处理函数可以找到this，原因在于在JSX中我们利用箭头函数，箭头函数是不会绑定this，所以会向外一层去寻找，外层是render方法，在render方法里面的this刚好指向的是当前实例对象\n\n## 事件绑定this指向\n\n### 箭头函数\n\n- 利用箭头函数自身不绑定this的特点\n\n![](./img/web/react/react基础Day01-React概述&脚手架搭建&JSX&组件/箭头函数.png)\n\n### 利用bind方法（★★★）\n\n利用原型bind方法是可以更改函数里面this的指向的，所以我们可以在构造中调用bind方法，然后把返回的值赋值给我们的函数即可\n\n```react\nclass App extends React.Component {\n  constructor() {\n    super()\n\t...\n    // 通过bind方法改变了当前函数中this的指向\n    this.onIncrement = this.onIncrement.bind(this)\n  }\n  // 事件处理程序\n  onIncrement() {\n    ...\n  }\n\n  render() {\n    ...\n  }\n}\n```\n\n### class的实例方法（★★★）\n\n- 利用箭头函数形式的class实例方法\n- 注意：该语法是实验性语法，但是，由于babel的存在可以使用\n\n```react\n  // 事件处理程序\n  onIncrement = () => {\n    console.log('事件处理程序中的this：', this)\n    this.setState({\n      count: this.state.count + 1\n    })\n  }\n```\n\n### 小结\n\n- 推荐：使用class的实例方法，也是依赖箭头函数不绑定this的原因",Io="\x3c!--\n * @Date           : 2021-05-05 03:56:51\n * @FilePath       : /jinnian-space/src/pages/web/react/md/react基础Day02-受控组件&评论案例&props&context.md\n * @Description    : \n--\x3e\n# React组件\n\n## 目标\n\n- 能够知道受控组件是什么\n- 能够写出受控组件\n- 了解非受控组件\n\n## 表单处理\n\n### 受控组件（★★★）\n\n- HTML中的表单元素是可输入的，也就是有自己的可变状态\n- 而React中可变状态通常保存在state中，并且只能通过`setState()` 方法来修改\n- React讲state与表单元素值value绑定在一起，有state的值来控制表单元素的值\n- 受控组件：值受到react控制的表单元素\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/受控组件.png)\n\n#### 使用步骤\n\n- 在state中添加一个状态，作为表单元素的value值\n- 给表单元素绑定change事件，将表单元素的值设置为state的值\n\n#### 示例demo\n\n```react\nclass App extends React.Component {\n    constructor(){\n        super()\n        this.inputChange = this.inputChange.bind(this)\n    }\n    state = {\n        txt : ''\n    }\n    inputChange(e){\n       this.setState({\n           txt: e.target.value\n       })\n    }\n    render(){\n        console.log(this.state);\n        \n        return (\n            <div>\n                {/* 把state的值设置给输入框的value，绑定change事件，这样用户在输入内容的时候调用相应函数，在函数里面把当前设置的值赋值给state，从而达到数据的统一 */}\n                <input type=\"text\" value={this.state.txt} onChange={this.inputChange}/>\n            </div>\n        )\n    }\n}\nReactDOM.render(<App />,document.getElementById('root'))\n```\n\n#### 多表单元素优化\n\n- 问题：每个表单元素都有一个单独的事件处理函数，这样太繁琐\n- 优化：使用一个事件处理程序同时处理多个表单元素\n\n##### 步骤\n\n- 给表单元素添加name属性（用来区分是哪一个表单），名称与state相同（用来更新数据的）\n- 根据表单内容来获取对应值\n- 在change事件处理程序中通过 [name] 来修改对应的state\n\n##### 示例demo\n\n```react\ninputChange(e){\n   let target = e.target;\n   let value = target.type == 'checkbox' ? target.checked : target.value;\n   this.setState({\n       [e.target.name]: value\n   })\n}\n<input type=\"text\" value={this.state.txt} name=\"txt\" onChange={this.inputChange}/>\n<input type=\"checkbox\" value={this.state.isChecked} name=\"isChecked\" onChange={this.inputChange}/>\n```\n\n### 非受控组件 （了解）\n\n- 说明：借助于ref，使用元素DOM方式获取表单元素值\n- ref的作用：获取DOM或者组件\n\n#### 使用步骤\n\n- 调用 `React.createRef()` 方法创建ref对象\n- 将创建好的 ref 对象添加到文本框中\n- 通过ref对象获取到文本框的值\n\n```react\nclass App extends React.Component {\n    constructor(){\n        super()\n        \n        //创建 ref\n        this.txtRef = React.createRef()\n    }\n    // 获取文本框的值\n    getTxt =() => {\n        console.log(this.txtRef.current.value)\n    }\n    render(){\n        return (\n          <div>\n            <input type =\"text\" ref={this.txtRef} />\n            <button onClick ={this.getTxt}>获取值</button>\n          </div>\n        )\n    }\n}\n```\n\n# React组件综合案例（★★★）\n\n## 需求分析\n\n- 渲染评论列表（列表渲染）\n- 没有评论数据时渲染：暂无评论（条件渲染）\n- 获取评论信息，包括评论人和评论内容（受控组件）\n- 发表评论，更新评论列表（`setState()`）\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/综合案例.png)\n\n## 搭建评论列表的模板\n\n- 结构\n\n```react\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n\n/* \n  评论列表案例\n\n  comments: [\n    { id: 1, name: 'jack', content: '沙发！！！' },\n    { id: 2, name: 'rose', content: '板凳~' },\n    { id: 3, name: 'tom', content: '楼主好人' }\n  ]\n*/\n\nimport './index.css'\n\nclass App extends React.Component {\n  render() {\n    return (\n      <div className=\"app\">\n        <div>\n          <input className=\"user\" type=\"text\" placeholder=\"请输入评论人\" />\n          <br />\n          <textarea\n            className=\"content\"\n            cols=\"30\"\n            rows=\"10\"\n            placeholder=\"请输入评论内容\"\n          />\n          <br />\n          <button>发表评论</button>\n        </div>\n\n        <div className=\"no-comment\">暂无评论，快去评论吧~</div>\n        <ul>\n          <li>\n            <h3>评论人：jack</h3>\n            <p>评论内容：沙发！！！</p>\n          </li>\n        </ul>\n      </div>\n    )\n  }\n}\n\n// 渲染组件\nReactDOM.render(<App />, document.getElementById('root'))\n```\n\n- 样式\n\n```css\n.app {\n  width: 300px;\n  padding: 10px;\n  border: 1px solid #999;\n}\n\n.user {\n  width: 100%;\n  box-sizing: border-box;\n  margin-bottom: 10px;\n}\n\n.content {\n  width: 100%;\n  box-sizing: border-box;\n  margin-bottom: 10px;\n}\n\n.no-comment {\n  text-align: center;\n  margin-top: 30px;\n}\n```\n\n## 渲染评论列表\n\n- 在state中初始化评论列表数据\n\n```react\n  state = {\n    comments: [\n      { id: 1, name: 'jack', content: '沙发！！！' },\n      { id: 2, name: 'rose', content: '板凳~' },\n      { id: 3, name: 'tom', content: '楼主好人' }\n    ]\n  }\n```\n\n- 使用数组的map方法遍历state中的列表数据\n- 给每一个被遍历的li元素添加key属性\n- 在render方法里的ul节点下嵌入表达式\n\n```react\n{\n  this.state.comments.map(item => {\n    return (\n       <li key={item.id}>\n          <h3>{item.name}</h3>\n          <p>{item.content}</p>\n       </li>\n    )\n  })\n}\n```\n\n## 渲染暂无评论\n\n- 判断列表数据的长度是否为0\n- 如果为0，则渲染暂无评论\n- 如果不为0，那么渲染列表数据\n\n- 在jsx中大量写逻辑会导致很臃肿，所以我们可以把条件渲染的逻辑抽取成一个函数\n\n```react\n/**\n * 条件渲染，这里抽取出来了，这样在结构中不会很混乱\n */\nrenderList(){\n  if (this.state.comments.length === 0) {\n    return (<div className=\"no-comment\">暂无评论，快去评论吧~</div>)\n  } else {\n    return (\n      <ul> {\n        this.state.comments.map(item => {\n          return (\n            <li key={item.id}>\n              <h3>{item.name}</h3>\n              <p>{item.content}</p>\n            </li>\n          )\n        })\n      }\n      </ul>\n    )\n  }\n}\n```\n\n- 在render的return方法里面调用这个函数即可\n\n```react\nrender() {\n  return (\n    <div>\n      ...\n      {/* 通过条件渲染来判断是否显示暂无评论 */}\n      {this.renderList()}\n    </div>\n  )\n}\n```\n\n## 获取评论信息\n\n- 通过受控组件来获取内容\n- 初始化用户名和用户内容的state\n\n```react\nuserName: '',\nuserContent: ''\n```\n\n- 在结构中，把表单元素的value与state进行绑定，还需要绑定name属性和onChange属性\n\n```react\n<input className=\"user\" type=\"text\" placeholder=\"请输入评论人\" value={this.state.userName} name=\"userName\" onChange={this.handleForm}/>\n<br />\n<textarea\n  className=\"content\"\n  cols=\"30\"\n  rows=\"10\"\n  placeholder=\"请输入评论内容\"\n  value={this.state.userContent}\n  name=\"userContent\"\n  onChange={this.handleForm}\n/>\n```\n\n- 在`handleFrom`函数中利用`setState`来让数据保持一致\n\n```react\n  handleForm = (e) => {\n     this.setState({\n       [e.target.name] : e.target.value\n     })\n  }\n```\n\n## 发表评论\n\n- 给按钮绑定事件\n- 在事件处理程序中，通过state获取评论信息\n- 将评论信息添加到state中，利用setState来更新页面\n- 添加评论前需要判断用户是否输入内容\n- 添加评论后，需要情况文本框用户输入的值\n\n```react\nhandleClick = (e) => {\n  // 拿到用户输入的内容\n  let {userName,userContent} = this.state\n  if(userName.trim()==='' || userContent.trim() === ''){\n      alert('请输入内容')\n      return\n  }\n  // 利用数组拓展运算符来进行数据的拼接，把用户输入的存放在数组的第一个位置\n  let newComments = [{\n    id: this.state.comments.length+1,\n    name: userName,\n    content: userContent\n  },...this.state.comments]\n  this.setState({\n    comments: newComments,\n    userName:'',\n    userContent: ''\n  })\n}\n```\n\n# React组件进阶\n\n## 目标\n\n- 能够使用props接收数据\n- 能够实现父子组件之间的通讯\n- 能够实现兄弟组件之间的通讯\n- 能够给组件添加props校验\n\n## 组件通讯介绍\n\n组件是独立且封闭的单元，默认情况下，只能使用组件自己的数据。在组件化过程中，我们将一个完整的功能拆分成多个组件，以更好的完成整个应用的功能。而在这个过程中，多个组件之间不可避免的要共享某些数据。为了实现这些功能，就需要打破组件的独立封闭性，让其与外界沟通，这个过程就是组件通讯\n\n## 组件的props（★★★）\n\n### 基本使用\n\n- 组件时封闭的，要接受外部数据应该通过props来实现\n- props的作用：接收传递给组件的数据\n- 传递数据：给组件标签添加属性\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/props-设置.png)\n\n- 接收数据：函数组件通过 参数 props接收数据，类组件通过 this.props接收数据\n\n  - 函数组件获取\n\n    ![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/函数组件获取.png)\n\n  - 类组件获取\n\n    ![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/类组件获取.png)\n\n\n​    \n\n### 特点\n\n- 可以给组件传递任意类型的数据 ： 字符串  数字 数组  对象  函数  jsx 组件\n- props是只读属性，不能对值进行修改\n- 注意：使用类组件时，如果写了构造函数，应该将props传递给super(),否则，无法在构造函数中获取到props，其他的地方是可以拿到的\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/类组件注意点.png)\n\n## 组件通讯的三种方式（★★★）\n\n### 父组件传递数据给子组件\n\n- 父组件提供要传递的state数据\n- 给子组件标签添加属性，值为state中的数据\n- 子组件中通过props接收父组件中传递的数据\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/父传子.png)\n\n### 子组件传递数据给父组件\n\n- 利用回调函数，父组件提供回调，子组件调用，将要传递的数据作为回调函数的参数\n- 父组件提供一个回调函数，用来接收数据\n- 将该函数作为属性的值，传递给子组件\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/子传父-父亲设置回调.png)\n\n- 子组件通过props调用回调函数\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/子传父-调用回调.png)\n\n### 兄弟组件传递\n\n- 将共享状态(数据)提升到最近的公共父组件中，由公共父组件管理这个状态\n- 这个称为状态提升\n- 公共父组件职责：1. 提供共享状态 2.提供操作共享状态的方法\n- 要通讯的子组件只需要通过props接收状态或操作状态的方法\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/兄弟传递.png)\n\n#### 示例demo\n\n- 定义布局结构，一个Counter里面包含两个子组件，一个是计数器的提示，一个是按钮\n\n```react\nclass Counter extends React.Component {\n    render() {\n        return (<div>\n            <Child1 />\n            <Child2 />\n        </div>\n        )\n    }\n}\nclass Child1 extends React.Component {\n    render() {\n        return (\n            <h1>计数器：</h1>\n        )\n    }\n}\nclass Child2 extends React.Component {\n    render() {\n        return (\n            <button>+1</button>\n        )\n    }\n}\n```\n\n- 在父组件里定义共享状态，把这个状态传递给第一个子组件\n\n```react\nclass Counter extends React.Component {\n    // 提供共享的状态\n    state = {\n        count: 0\n    }\n    render() {\n        return (<div>\n            {/* 把状态提供给第一个子组件 */}\n            <Child1 count={this.state.count}/>\n            <Child2 />\n        </div>\n        )\n    }\n}\n```\n\n- 在第一个子组件里面就能通过props获取到\n\n```react\nclass Child1 extends React.Component {\n    render() {\n        return (\n            <h1>计数器：{this.props.count}</h1>\n        )\n    }\n}\n```\n\n- 在父组件中提供共享方法，通过属性传递给第二个子组件，方便第二个子组件来进行调用\n\n```react\n    // 提供共享方法\n    onIncrement = (res) => {\n        // 只要第二个子组件调用了这个函数，就会执行里面代码\n        this.setState({\n            count: this.state.count + res\n        })\n    }\n    render() {\n        return (<div>\n            ...\n            {/* 把共享方法提供给第二个子组件 */}\n            <Child2 onIncrement={this.onIncrement} />\n        </div>\n        )\n    }\n```\n\n- 在第二个子组件里面通过props来获取到对应函数，然后进行调用\n\n```react\nclass Child2 extends React.Component {\n    handleClick = () => {\n        // 这里一旦调用，就会执行父组件里面 onIncrement函数\n        this.props.onIncrement(2)\n    }\n    render() {\n        return (\n            <button onClick={this.handleClick}>+</button>\n        )\n    }\n}\n```\n\n## Context（★★★）\n\n如果出现层级比较多的情况下（例如：爷爷传递数据给孙子），我们会使用Context来进行传递\n\n作用： 跨组件传递数据\n\n### 使用步骤\n\n- 调用 `React.createContext()` 创建 Provider(提供数据) 和 Consumer(消费数据) 两个组件\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/创建Context.png)\n\n- 使用Provider 组件作为父节点\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/provider.png)\n\n- 设置value属性，表示要传递的数据\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/设置value属性.png)\n\n- 哪一层想要接收数据，就用Consumer进行包裹，在里面回调函数中的参数就是传递过来的值\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/Comsumer.png)\n\n### 小结\n\n- 如果两个组件相隔层级比较多，可以使用Context实现组件通讯\n- Context提供了两个组件：Provider 和 Consumer\n- Provider组件： 用来提供数据\n- Consumer组件： 用来消费数据\n\n## props进阶\n\n### children属性\n\n- children属性： 表示组件标签的子节点，当组件标签有子节点时，props就会有该属性\n- children属性与普通的props一样，值可以使任意值（文本、react元素、组件、甚至是函数）\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/props-children.png)\n\n\n\n### props校验（★★★）\n\n- 对于组件来说，props是外来的，无法保证组件使用者传入什么格式的数据，简单来说就是组件调用者可能不知道组件封装着需要什么样的数据\n- 如果传入的数据不对，可能会导致报错\n- 关键问题：组件的使用者不知道需要传递什么样的数据\n- props校验：允许在创建组件的时候，指定props的类型、格式等\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/props-校验.png)\n\n- 作用：捕获使用组件时因为props导致的错误，给出明确的错误提示，增加组件的健壮性\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/props-错误提示.png)\n\n#### 使用步骤\n\n- 安装包  `prop-types (yarn add prop-types | npm i prop-types)`\n- 导入prop-types 包\n- 使用`组件名.propTypes={}` 来给组件的props添加校验规则\n- 校验规则通过PropTypes对象来指定\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/propsTypes.png)\n\n\n\n#### 常见的约束规则\n\n- 创建的类型： `array、bool、func、number、object、string`\n- React元素类型：`element`\n- 必填项：`isRequired`\n- 特定结构的对象： `shape({})`\n- 更多的[约束规则](<https://zh-hans.reactjs.org/docs/typechecking-with-proptypes.html#proptypes>)\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/props-约束规则.png)\n\n### props的默认值\n\n- 场景：分页组件 -> 每页显示条数\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/props默认值.png)",Jo={data:function(){return{MainComponent1:Do,MainComponent2:Io}},methods:{extendMarkdown:function(n){n.renderer.rules.image=function(n,t,r,e,a){var o=n[t];return o.attrSet("class","q-markdown--image"),a.renderToken(n,t,r)}}}},Lo=Jo,Ho=Object(m["a"])(Lo,No,Ao,!1,null,"7d0f5d0a",null),Fo=Ho.exports,Uo=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}}),r("q-markdown",{attrs:{src:n.MainComponent1}})],1)},qo=[],Bo="\x3c!--\n * @Date           : 2021-05-05 07:12:53\n * @FilePath       : /jinnian-space/src/pages/web/react/md/react基础Day03-生命周期&render props模式&高阶组件&原理揭秘.md\n * @Description    : \n--\x3e\n# 组件生命周期（★★★）\n\n## 目标\n\n- 说出组件生命周期对应的钩子函数\n- 钩子函数调用的时机\n\n## 概述\n\n意义：组件的生命周期有助于理解组件的运行方式，完成更复杂的组件功能、分析组件错误原因等\n\n组件的生命周期： 组件从被创建到挂载到页面中运行，再到组件不在时卸载的过程\n\n生命周期的每个阶段总是伴随着一些方法调用，这些方法就是生命周期的钩子函数\n\n构造函数的作用：为开发人员在不同阶段操作组件提供了时机\n\n## 生命周期阶段\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/生命周期.png)\n\n### 创建时（挂载阶段）\n\n- 执行时机：组件创建时（页面加载时）\n- 执行顺序\n \n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/创建时-函数执行顺序.png)\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/创建时-函数的作用.png)\n\n### 更新时\n\n执行时机：`setState()、 forceUpdate()、 组件接收到新的props`\n\n说明：以上三者任意一种变化，组件就会重新渲染\n\n执行顺序：\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/更新时.png)\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/更新时-函数作用.png)\n\n### 卸载时\n\n执行时机：组件从页面中消失\n\n作用：用来做清理操作  清理 定时器 以及一些 特殊的绑定 回调  window.addEventListene\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/卸载时.png)\n\n### 不常用的钩子函数\n\n#### 旧版的生命周期钩子函数\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/旧版生命周期函数.png)\n\n#### 新版完整生命会走棋钩子函数\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/新版生命周期函数.png)\n\n##### `getDerivedStateFromProps()`\n\n- **`getDerivedStateFromProps`** 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容\n- 不管原因是什么，都会在*每次*渲染前触发此方法\n\n##### `shouldComponentUpdate()`\n\n- 根据 **`shouldComponentUpdate()`** 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。默认行为是 state 每次发生变化组件都会重新渲染\n- 当 props 或 state 发生变化时，**`shouldComponentUpdate()`** 会在渲染执行之前被调用。返回值默认为 true\n\n##### `getSnapshotBeforeUpdate()`\n\n- **`getSnapshotBeforeUpdate()`** 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 **`componentDidUpdate()`**\n- 此用法并不常见，但它可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等\n\n# render-props模式 （★★★）\n\n## 目标\n\n- 知道render-props模式有什么作用\n- 能够说出render-props的使用步骤\n\n## React组件复用概述\n\n- 思考：如果两个组件中的部分功能相似或相同，该如何处理？\n- 处理方式：复用相似的功能\n- 复用什么？\n  - state\n  - 操作state的方法\n- 两种方式：\n  - render props模式\n  - 高阶组件（HOC）\n- 注意： 这两种方式不是新的API，而是利用React自身特点的编码技巧，演化而成的固定模式\n\n## 思路分析\n\n- 思路：将要复用的state和操作state的方法封装到一个组件中\n\n- 如何拿到该组件中复用的state\n\n  - 在使用组件时，添加一个值为函数的prop，通过函数参数来获取\n\n    ![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/render-props-01.png)\n\n- 如何渲染到任意的UI\n\n  - 使用该函数的返回值作为要渲染的UI内容\n\n    ![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/render-props-02.png)\n\n## 使用步骤\n\n- 创建Mouse组件，在组件中提供复用的逻辑代码\n- 将要复用的状态作为 props.render(state)方法的参数，暴露到组件外部\n- 使用props.render() 的返回值作为要渲染的内容\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/render-props模式-01.png)\n\n#### 示例demo\n\n```react\nclass Mouse extends React.Component {\n    // 鼠标位置状态\n    state = {\n        x: 0,\n        y: 0\n    }\n\n    // 监听鼠标移动事件\n    componentDidMount(){\n        window.addEventListener('mousemove',this.handleMouseMove)\n    }\n    handleMouseMove = e => {\n        this.setState({\n            x: e.clientX,\n            y: e.clientY\n        })\n    }\n    render(){\n        // 向外界提供当前子组件里面的数据\n        return this.props.render(this.state)\n    }\n}\nclass App extends React.Component {\n    render() {\n        return (\n            <div>\n                App\n                <Mouse render={mouse => {\n                    return <p>X{mouse.x}Y{mouse.y}</p>\n                }}/>\n            </div>\n        )\n    }\n}\nReactDOM.render(<App />,document.getElementById('root'))\n```\n\n## children代替render属性\n\n- 注意：并不是该模式叫 render props就必须使用名为render的prop，实际上可以使用任意名称的prop\n- 把prop是一个函数并且告诉组件要渲染什么内容的技术叫做： render props模式\n- 推荐：使用childre代替render属性\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/render-props-children模式.png)\n\n## 优化代码\n\n- 推荐给render props模式添加props校验\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/优化-添加校验.png)\n\n-  \n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/优化-移除事件绑定.png)\n\n\n\n# 高阶组件 （★★★）\n\n## 目标\n\n- 知道高阶组件的作用\n- 能够说出高阶的使用步骤\n\n## 概述\n\n- 目的：实现状态逻辑复用\n- 采用 包装模式\n- 手机：获取保护功能\n- 手机壳：提供保护功能\n- 高阶组件就相当于手机壳，通过包装组件，增强组件功能\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/手机壳.png)\n\n## 思路分析\n\n- 高阶组件(HOC、Higher-Order Component) 是一个函数，接收要包装的组件，返回增强后的组件\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/高阶组件-函数.png)\n\n- 高阶组件内部创建了一个类组件，在这个类组件中提供复用的状态逻辑代码，通过prop将复用的状态传递给被包装组件`WrappedComponent`\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/高阶组件-类组件内部实现.png)\n\n## 使用步骤\n\n- 创建一个函数，名称约定以with开头\n- 指定函数参数，参数应该以大写字母开头\n- 在函数内部创建一个类组件，提供复用的状态逻辑代码，并返回\n- 在该组件中，渲染参数组件，同时将状态通过prop传递给参数组件\n- 调用该高阶组件，传入要增强的组件，通过返回值拿到增强后的组件，并将其渲染到页面\n\n**包装函数**\n\n```react\n// 定义一个函数，在函数内部创建一个相应类组件\nfunction withMouse(WrappedComponent) {\n    // 该组件提供复用状态逻辑\n    class Mouse extends React.Component {\n        state = {\n            x: 0,\n            y: 0\n        }\n        // 事件的处理函数\n        handleMouseMove = (e) => {\n            this.setState({\n                x: e.clientX,\n                y: e.clientY\n            })\n        }\n        // 当组件挂载的时候进行事件绑定\n        componentDidMount() {\n            window.addEventListener('mousemove', this.handleMouseMove)\n        }\n        // 当组件移除时候解绑事件\n        componentWillUnmount() {\n            window.removeEventListener('mousemove', this.handleMouseMove)\n        }\n        render() {\n            // 在render函数里面返回传递过来的组件，把当前组件的状态设置进去\n            return <WrappedComponent {...this.state} />\n        }\n    }\n    return Mouse\n}\n```\n\n**哪个组件需要加强，通过调用`withMouse`这个函数，然后把返回的值设置到父组件中即可**\n\n```react\nfunction Position(props) {\n    return (\n        <p>\n            X:{props.x}\n            Y:{props.y}\n        </p>\n    )\n}\n// 把position 组件来进行包装\nlet MousePosition = withMouse(Position)\n\nclass App extends React.Component {\n    constructor(props) {\n        super(props)\n    }\n    render() {\n        return (\n            <div>\n                高阶组件\n                <MousePosition></MousePosition>\n            </div>\n        )\n    }\n}\n```\n\n## 设置`displayName`\n\n- 使用高阶组件存在的问题：得到两个组件的名称相同\n- 原因：默认情况下，React使用组件名称作为`displayName`\n- 解决方式：为高阶组件设置`displayName`，便于调试时区分不同的组件\n- `displayName的作用：用于设置调试信息(React Developer Tools信息)`\n- 设置方式：\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/高阶组件-displayName.png)\n\n## 传递props\n\n- 问题：如果没有传递props，会导致props丢失问题\n- 解决方式： 渲染`WrappedComponent`时，将state和props一起传递给组件\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/传递props.png)\n\n## 小结\n\n- 组件通讯是构建React应用必不可少的一环\n- props的灵活性让组件更加强大\n- 状态提升是React组件的常用模式\n- 组件生命周期有助于理解组件的运行过程\n- 钩子函数让开发者可以在特定的时机执行某些功能\n- `render props` 模式和高阶组件都可以实现组件状态逻辑的复用\n- 组件极简模型： `(state,props) => UI`\n\n# React原理\n\n## 目标\n\n- 能够知道`setState()`更新数据是异步的\n- 能够知道JSX语法的转化过程\n\n## `setState()`说明 （★★★）\n\n### 更新数据\n\n- `setState()`更新数据是异步的\n- 注意：使用该语法，后面的`setState`不要依赖前面`setState`的值\n- 多次调用`setState`，只会触发一次render\n\n### 推荐语法 \n\n- 推荐：使用 `setState((state,props) => {})` 语法\n- 参数state： 表示最新的state\n- 参数props： 表示最新的props\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/推荐语法.png)\n\n\n\n### 第二个参数\n\n- 场景：在状态更新(页面完成重新渲染)后立即执行某个操作\n- 语法：`setState(update[,callback])`\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/第二个参数.png)\n\n## JSX语法的转化过程 （★★★）\n\n- JSX仅仅是`createElement()` 方法的语法糖(简化语法)\n- JSX语法被 @babel/preset-react 插件编译为`createElement()` 方法\n- React 元素： 是一个对象，用来描述你希望在屏幕上看到的内容\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/语法糖.png)",Wo="\x3c!--\n * @Date           : 2021-05-05 07:16:13\n * @FilePath       : /jinnian-space/src/pages/web/react/md/react基础Day04-React原理揭秘&React路由基础.md\n * @Description    : \n--\x3e\n# React原理揭秘\n\n## 目标\n\n- 能够说出React组件的更新机制\n- 能够对组件进行性能优化\n- 能够说出虚拟DOM和DIff算法\n\n## 组件更新机制\n\n- setState() 的两个作用\n  - 修改state\n  - 更新组件\n\n- 过程：父组件重新渲染时，也会重新渲染子组件，但只会渲染当前组件子树（当前组件以其所有子组件）\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/组件更新.png)\n\n## 组件性能优化\n\n### 减轻state\n\n- 减轻state：只存储跟组件渲染相关的数据（比如：count/ 列表数据 /loading等）\n- 注意：不用做渲染的数据不要放在state中\n- 对于这种需要在多个方法中用到的数据，应该放到this中\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/减轻state.png)\n\n### 避免不必要的重新渲染\n\n- 组件更新机制：父组件更新会引起子组件也被更新，这种思路很清晰\n- 问题：子组件没有任何变化时也会重新渲染\n- 如果避免不必要的重新渲染？\n- 解决方式：使用钩子函数 shouldComponentUpdate(nextProps, nextState)\n  - 在这个函数中，nextProps和nextState是最新的状态以及属性\n- 作用：这个函数有返回值，如果返回true，代表需要重新渲染，如果返回false，代表不需要重新渲染\n- 触发时机：更新阶段的钩子函数，组件重新渲染前执行(shouldComponentUpdate => render)\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/shouldComponentUpdata.png)\n\n#### 随机数案例\n\n需求：随机生成数字，显示在页面，如果生成的数字与当前显示的数字相同，那么就不需要更新UI，反之更新UI。\n\n利用nextState参数来判断当前组件是否需要更新\n\n```react\nclass App extends React.Component {\n    state = {\n        number: 0\n    }\n    // 点击事件，每次点击生成一个随机数\n    hanldeBtn = () => {\n        this.setState({\n            number: Math.floor(Math.random() * 3)\n        })\n    }\n    // 将要更新UI的时候会执行这个钩子函数\n    shouldComponentUpdate(nextProps,nextState) {\n         // 判断一下当前生成的 值是否与页面的值相等\n         if(nextState.number !== this.state.number){\n             return true\n         }\n         return false\n    }\n    render() {\n        return (\n            <div>\n                随机数：{this.state.number} <br />\n                <button onClick={this.hanldeBtn}>生成随机数</button>\n            </div>\n        )\n    }\n}\n```\n\n利用props参数来判断是否需要进行更新\n\n```react\nclass App extends React.Component {\n    state = {\n        number: 0\n    }\n    // 点击事件，每次点击生成一个随机数\n    hanldeBtn = () => {\n        this.setState({\n            number: Math.floor(Math.random() * 3)\n        })\n    }\n\n    render() {\n        return (\n            <div>\n                <NumberBox number={this.state.number} />\n                <button onClick={this.hanldeBtn}>生成随机数</button>\n            </div>\n        )\n    }\n}\nclass NumberBox extends React.Component {\n    // 将要更新UI的时候会执行这个钩子函数\n    shouldComponentUpdate(nextProps, nextState) {\n        // 判断一下当前生成的 值是否与页面的值相等\n        if (nextProps.number !== this.props.number) {\n            return true\n        }\n        return false\n    }\n    render() {\n        return (\n            <h1>随机数：{this.props.number} </h1>\n        )\n    }\n}\n```\n\n### 纯组件\n\n#### 作用以及使用\n\n- 纯组件： PureComponent 与 React.Component 功能相似\n- 区别： PureComponent 内部自动实现了 shouldComponentUpdate钩子，不需要手动比较\n- 原理：纯组件内部通过分别比对前后两次 props和state的值，来决定是否重新渲染组件\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/PureComponent.png)\n\n#### 实现原理\n\n- 说明：纯组件内部的对比是 shallow compare（浅层对比）\n- 对于值类型来说：比较两个值是否相同\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/值类型比对.png)\n\n- 引用类型：只比对对象的引用地址是否相同\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/引用类型比对.png)\n\n- 注意：state 或 props 中属性值为引用类型时，应该创建新数据，不要直接修改原数据\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/注意点.png)\n\n## 虚拟DOM和Diff算法\n\n- React更新视图的思想是：只要state变化就重新渲染视图\n- 特点：思路非常清晰\n- 问题：组件中只有一个DOM元素需要更新时，也得把整个组件的内容重新渲染吗？ 不是这样的\n- 理想状态：部分更新，只更新变化的地方\n- React运用的核心点就是 虚拟DOM 配合 Diff 算法\n\n### 虚拟DOM\n\n本质上就是一个JS对象，用来描述你希望在屏幕上看到的内容\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/虚拟DOM.png)\n\n### Diff算法\n\n执行过程\n\n- 初次渲染时，React会根据初始化的state（model），创建一个虚拟DOM对象（树）\n- 根据虚拟DOM生成真正的DOM，渲染到页面\n- 当数据变化后(setState())，会重新根据新的数据，创建新的虚拟DOM对象（树）\n- 与上一次得到的虚拟DOM对象，使用Diff算法比对（找不同），得到需要更新的内容\n- 最终，React只将变化的内容更新（patch）到DOM中，重新渲染到页面\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/diff算法.png)\n\n### 代码演示\n\n- 组件render()调用后，根据状态和JSX结构生成虚拟DOM对象(render()方法的调用并不意味着浏览器进行渲染，render方法调用时意味着Diff算法开始比对了)\n- 示例中，只更新p元素的文本节点内容\n- 初次渲染的DOM对象\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/初次的虚拟DOM对象.png)\n\n- 数据更新之后的虚拟DOM对象\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/更新后的虚拟DOM对象.png)\n\n## 小结\n\n- 工作角度：应用第一，原理第二\n- 原理有助于更好的理解React的自身运行机制\n- setState() 异步更新数据\n- 父组件更新导致子组件更新，纯组件提升性能\n- 思路清晰简单为前提，虚拟DOM和Diff保效率（渲染变化的组件）\n- 虚拟DOM -> state + JSX\n- 虚拟DOM最大的特点是 脱离了浏览器的束缚，也就是意味着只要是能支持js的地方都可以用到react，所以为什么说react是可以进行跨平台的开发\n\n# React路由基础\n\n## 目标\n\n- 能够说出React路由的作用\n- 能够掌握-react-router-dom的基本使用\n- 能够使用编程式导航跳转路由\n- 能够知道React路由的匹配模式\n\n## React路由介绍\n\n现代的前端应用大多数是SPA（单页应用程序），也就是只有一个HTML页面的应用程序。因为它的用户体验更好、对服务器压力更小，所以更受欢迎。为了有效的使用单个页面来管理多页面的功能，前端路由应运而生。\n\n- 前端路由功能：让用户从一个视图（页面）导航到另一个视图（页面）\n- 前端路由是一套映射规则，在React中，是URL路径与组件的对应关系\n- 使用React路由简单来说，就是配置路径和组件\n\n## 路由的基本使用\n\n### 使用步骤\n\n- 安装： yarn add react-router-dom\n  - 如果没有安装yarn工具的，需要先全局安装一下yarn：npm install -g yarn\n\n- 导入路由的三个核心组件： Router / Route / Link\n\n  ```react\n  import {BrowserRouter as Router, Route, Link} from 'react-router-dom'\n  ```\n\n- 使用Router 组件包裹整个应用\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/Router.png)\n\n- 使用Link组件作为导航菜单（路由入口）\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/link入口.png)\n\n- 使用Route组件配置路由规则和要展示的组件（路由出口）\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/route.png)\n\n### 常用组件说明\n\n- **Router组件：**包裹整个应用，一个React应用只需要使用一次\n  - 两种常用的Router： HashRouter和BrowserRouter\n  - HashRouter： 使用URL的哈希值实现 （localhost:3000/#/first）\n  - 推荐 BrowserRouter：使用H5的history API实现（localhost3000/first）\n- **Link组件：**用于指定导航链接（a标签）\n  - 最终Link会编译成a标签，而to属性会被编译成 a标签的href属性\n- **Route组件：**指定路由展示组件相关信息\n  - path属性：路由规则，这里需要跟Link组件里面to属性的值一致\n  - component属性：展示的组件\n  - Route写在哪，渲染出来的组件就在哪\n\n### 路由的执行过程\n\n- 当我们点击Link组件的时候，修改了浏览器地址栏中的url\n- React路由监听地址栏url的变化\n- React路由内部遍历所有的Route组件，拿着Route里面path规则与pathname进行匹配\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/route匹配.png)\n\n- 当路由规则（path）能够匹配地址栏中的pathname时，就展示该Route组件的内容\n\n### 编程式导航\n\n- **场景：**点击登陆按钮，登陆成功后，通过代码跳转到后台首页，如何实现？\n- **编程式导航：**通过JS代码来实现页面跳转\n- history是React路由提供的，用于获取浏览器历史记录的相关信息\n- **push(path)：**跳转到某个页面，参数path表示要跳转的路径\n- go(n)：前进或后退功能，参数n表示前进或后退页面数量\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/编程式导航.png)\n\n### 默认路由\n\n- 现在的路由都是通过点击导航菜单后展示的，如果进入页面的时候就主动触发路由呢\n- 默认路由：表示进入页面时就会匹配的路由\n- 默认路由：只需要把path设置为 `'/'`\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/默认路由.png)\n\n### 匹配模式\n\n#### 模糊匹配模式\n\n- 当Link组件的to属性值为 '/login' 时候，为什么默认路由也被匹配成功？\n- 默认情况下，React路由是模糊匹配模式\n- 模糊匹配规则：只要pathname以path开头就会匹配成功\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/模糊匹配模式.png)\n\n#### 精准匹配\n\n- 默认路由认可情况下都会展示，如果避免这种问题？\n- 给Route组件添加exact属性，让其变为**精准匹配模式**\n- 精确匹配：只有当path和pathname完全匹配时才会展示改路由\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/精确匹配.png)\n\n### 小结\n\n- React路由可以有效的管理多个视图实现 SPA\n- 路由先需要通过安装\n- Router组件包裹整个应用，只需要使用一次\n- Link组件是入口，Route组件是出口\n- 通过props.history实现编程式导航\n- 默认是模糊匹配，添加exact编程精确匹配\n- React路由的一切都是组件，可以像思考组件一样思考路由",Vo={data:function(){return{MainComponent:Bo,MainComponent1:Wo}}},Go=Vo,zo=Object(m["a"])(Go,Uo,qo,!1,null,"29523873",null),$o=zo.exports,Xo=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},Ko=[],Qo='\x3c!--\r\n * @Date           : 2021-05-05 14:01:15\r\n * @FilePath       : /jinnian-space/src/pages/web/react/md/react-base-demo.md\r\n * @Description    : \r\n--\x3e\r\n# react 基础 demo\r\n\r\n```react\r\n\r\n/*\r\n * @Date           : 2021-05-05 04:14:10\r\n * @FilePath       : /app-demo-1/src/view/view1.js\r\n * @Description    :\r\n */\r\nimport React from "react";\r\nimport PropTypes from "prop-types";\r\nconst { Provider, Consumer } = React.createContext();\r\nconst el = (\r\n  <div>\r\n    {" "}\r\n    <div>未来很美好 </div>{" "}\r\n  </div>\r\n);\r\nconst Test1 = () => {\r\n  return el;\r\n};\r\nconst classes666 = {\r\n  root: {},\r\n  red: {\r\n    color: "red",\r\n    backgroundColor: "#ccc",\r\n  },\r\n};\r\nconst name1 = "66sxsx999999";\r\nconst div2 = <h3>KKKKKKKKKKKKKK</h3>;\r\nconst list1 = [\r\n  { label: "react", value: "m1" },\r\n  { label: "基础", value: "m2" },\r\n];\r\n// {} 中 不能写 对象表达式 if 等表达式\r\nconst nn = 5;\r\nconst Say1 = (props) => {\r\n  if (nn > 5) {\r\n    return (\r\n      <div>\r\n        大于5 ---- {props.name} ----{props.age}\r\n      </div>\r\n    );\r\n  } else {\r\n    return (\r\n      <div>\r\n        小于等于5 ---- {props.name} ----{props.age}\r\n      </div>\r\n    );\r\n  }\r\n};\r\n// hello 组件\r\nclass Hello extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n  }\r\n  state = {\r\n    num: 1,\r\n    text: "xsx",\r\n  };\r\n  handleClick = () => {\r\n    this.setState({\r\n      num: this.state.num + 1,\r\n    });\r\n    console.log("点击了  class Hello extends React.Component");\r\n  };\r\n  inputChange = (e) => {\r\n    console.log("e", e);\r\n    this.setState({\r\n      text: e.target.value,\r\n    });\r\n  };\r\n  render() {\r\n    return (\r\n      <div>\r\n        <h2 onClick={this.handleClick}> HELLO 类方法 组件 {this.state.num}</h2>\r\n        <div>\r\n          ---- {this.props.name} ----{this.props.age}-----{this.props.age2}----\r\n        </div>\r\n        <div>兄弟组件之间 回调父级传值 {this.props.show_num}</div>\r\n        <input\r\n          type="text"\r\n          value={this.state.text}\r\n          onChange={this.inputChange}\r\n        />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n//类型检测\r\nHello.propTypes = {\r\n  age: PropTypes.number,\r\n};\r\n// 默认值\r\nHello.defaultProps = {\r\n  age2: 188,\r\n};\r\n// hello2 子组件\r\nconst Hello2SubChild = (props) => {\r\n  return (\r\n    <div>\r\n      <div>Hello2 组件的子组件---</div>\r\n      <Consumer>{(data) => <span>跨多级传值 接收到的{data}</span>}</Consumer>\r\n      <div>{props.children}</div>\r\n    </div>\r\n  );\r\n};\r\n// hello2 组件\r\nclass Hello2 extends React.Component {\r\n  handleClick() {\r\n    console.log("点击了");\r\n  }\r\n  render() {\r\n    return (\r\n      <div>\r\n        <div onClick={this.handleClick}>单独抽离出来的 Hello</div>\r\n        <button onClick={this.props.change_father_num}>\r\n          兄弟组件之间传值 调用父级 传入得函数 ，改变父级的state\r\n        </button>\r\n        <div>\r\n          <Hello2SubChild>\r\n            {" "}\r\n            <h3>Hello2SubChild 组件 通过 children 传递的 子节点</h3>{" "}\r\n          </Hello2SubChild>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nclass Hello3 extends React.Component{\r\n  constructor(props){\r\n    super(props)\r\n  }\r\n  state={\r\n    name:\'HELLO3 组件 render props 共享值，高阶组件复用\'\r\n  }\r\n  render(){\r\n    return this.props.render(this.state)\r\n\r\n  }\r\n}\r\n\r\nconst handleClick2 = (e) => {\r\n  console.log("e", e);\r\n  console.log("点击了函数组件 事件");\r\n};\r\nclass View1 extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    console.log("生命周期  constructor");\r\n  }\r\n  componentWillUnmount() {\r\n    console.log("生命周期  componentWillUnmount");\r\n  }\r\n  componentDidUpdate() {\r\n    console.log("生命周期  componentDidUpdate");\r\n  }\r\n  componentWillUnmount() {\r\n    console.log("生命周期  componentWillUnmount");\r\n  }\r\n  state = {\r\n    father_num: 6,\r\n  };\r\n  handleChangeFatherNum = () => {\r\n    this.setState({\r\n      father_num: this.state.father_num + 1,\r\n    });\r\n  };\r\n  render() {\r\n    console.log("生命周期    render");\r\n    return (\r\n      <Provider value="跨多级 子节点 传递 数值">\r\n        <div>\r\n          <h1 className="classesxsx666" onClick={handleClick2}>\r\n            我 {name1} 带你.......{classes666.red.color}...........\r\n          </h1>\r\n          <div>\r\n            <Say1 name="今年" age={89} />\r\n          </div>\r\n          <div>{div2}</div>\r\n          <Test1 />\r\n          <div style={classes666.red}>\r\n            {list1.map((x) => (\r\n              <div key={x.label}>\r\n                {x.label}----------{x.value}\r\n              </div>\r\n            ))}\r\n          </div>\r\n          <div>\r\n            <Hello name="明天" age={39} show_num={this.state.father_num} />\r\n            <Hello2 change_father_num={this.handleChangeFatherNum} />\r\n            <Hello3 render={ data=><p>拿到的复用数据----- {data.name} </p>} />\r\n          </div>\r\n          \r\n         \r\n        </div>\r\n      </Provider>\r\n    );\r\n  }\r\n}\r\nexport default View1;\r\n\r\n\r\n\r\n```\r\n\r\n## 高阶组件\r\n\r\n```react\r\n/*\r\n * @Date           : 2021-05-05 22:49:51\r\n * @FilePath       : /app-demo-1/src/view/Demo.js\r\n * @Description    : \r\n */\r\nimport React from \'react\'\r\nimport ReactDOM from \'react-dom\'\r\n/* \r\n  高阶组件\r\n*/\r\n// 创建高阶组件\r\nfunction withMouse(WrappedComponent) {\r\n  // 该组件提供复用的状态逻辑\r\n  class Mouse extends React.Component {\r\n    // 鼠标状态\r\n    state = {\r\n      x: 0,\r\n      y: 0\r\n    }\r\n    handleMouseMove = e => {\r\n      this.setState({\r\n        x: e.clientX,\r\n        y: e.clientY\r\n      })\r\n    }\r\n    // 控制鼠标状态的逻辑\r\n    componentDidMount() {\r\n      window.addEventListener(\'mousemove\', this.handleMouseMove)\r\n    }\r\n    componentWillUnmount() {\r\n      window.removeEventListener(\'mousemove\', this.handleMouseMove)\r\n    }\r\n    render() {\r\n      console.log(\'Mouse:\', this.props)\r\n      return <WrappedComponent {...this.state} {...this.props} />\r\n    }\r\n  }\r\n  // 设置displayName\r\n  Mouse.displayName = `WithMouse${getDisplayName(WrappedComponent)}`\r\n  return Mouse\r\n}\r\nfunction getDisplayName(WrappedComponent) {\r\n  return WrappedComponent.displayName || WrappedComponent.name || \'Component\'\r\n}\r\n// 用来测试高阶组件\r\nconst Position = props => {\r\n  console.log(\'Position:\', props)\r\n  return (\r\n    <p>\r\n      鼠标当前位置：(x: {props.x}, y: {props.y})\r\n    </p>\r\n  )\r\n}\r\n// 获取增强后的组件：\r\nconst MousePosition = withMouse(Position)\r\nclass App extends React.Component {\r\n  render() {\r\n    return (\r\n      <div>\r\n        <h1>高阶组件</h1>\r\n        <MousePosition a="1" />\r\n      </div>\r\n    )\r\n  }\r\n}\r\nReactDOM.render(<App />, document.getElementById(\'root\'))\r\n\r\n\r\n```',Yo={data:function(){return{MainComponent:Qo}}},Zo=Yo,ns=Object(m["a"])(Zo,Xo,Ko,!1,null,"98ecbc0c",null),ts=ns.exports,rs=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[r("div",{staticClass:"row   "},[r("q-select",{attrs:{"use-input":"","input-debounce":"0",clearable:"",options:n.book_options},on:{filter:n.filterFn},model:{value:n.book,callback:function(t){n.book=t},expression:"book"}},[r("template",{slot:"before"},[r("div")])],2)],1),r("div",{staticClass:"q-pdfviewer-container  "},[r("q-pdfviewer",{attrs:{src:n.src,type:"html5","content-class":" fit   q-pdfviewer-container","inner-content-class":" fit   q-pdfviewer-container"},model:{value:n.show,callback:function(t){n.show=t},expression:"show"}})],1)])},es=[],as=["01_.pdf","02_03_04_JSX核心语法.pdf","05_React脚手架.pdf","06_07_08__09_10_React组件化开发.pdf","11_React的CSS.pdf","12_AntDesignUI库.pdf","13_axios的使用.pdf","14_React过渡动画.pdf","15_16_17_Redux的使用.pdf","18_19_React-router的使用.pdf","20_21_22_React-Hooks.pdf","23_24_网易云项目实战.pdf","30_React-SSR.pdf","项目自动化部署.pdf"],os="react/react核心精讲/",ss={mixins:[k["d"]],data:function(){return{prefix:os,book_options:as,show:!0,book:as[0],src:""}}},is=ss,ls=Object(m["a"])(is,rs,es,!1,null,null,null),cs=ls.exports,ps={mixins:[k["c"]],components:{m1:Ro,m2:Fo,m3:$o,m4:ts,m5:cs},data:function(){return{tab:"m3",tab_level:2,tabs:[{label:"react",value:"m1"},{label:"基础",value:"m2"},{label:"基础",value:"m3"},{label:"基础demo",value:"m4"},{label:"核心精讲",value:"m5"}]}}},us=ps,ms=Object(m["a"])(us,wo,xo,!1,null,"47814e99",null),ds=ms.exports,gs=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[r("div",[r(""+n.tab,{tag:"component"})],1)])},bs=[],hs=function(){var n=this;return n.$createElement,n._self._c,n._m(0)},ys=[function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[r("article",{staticClass:"post"},[r("header",{staticClass:"post-header"},[r("h4",{staticClass:"post-title"},[n._v("\n        前端测试、性能监测、自动化集成方案\n      ")])]),r("div",{staticClass:"post-body"},[r("h5",{attrs:{id:"一、前端性能监测方案"}},[r("a",{staticClass:"headerlink",attrs:{href:"#一、前端性能监测方案",title:"一、前端性能监测方案"}}),n._v("一、前端性能监测方案\n      ")]),r("p",[r("strong",[n._v("性能监测：")])]),r("ol",[r("li",[r("p",[r("strong",[n._v("chrome 的 performance：")]),r("br"),n._v("DNS 查询耗时\n            ：domainLookupEnd - domainLookupStart"),r("br"),n._v("TCP 链接耗时\n            ：connectEnd - connectStart\n          ")]),r("p",[n._v("\n            request 请求耗时 ：responseEnd - responseStart"),r("br"),n._v("解析 dom\n            树耗时 ： domComplete - domInteractive"),r("br"),n._v("白屏时间\n            ：responseStart - navigationStart"),r("br"),n._v("domready\n            时间(用户可操作时间节点) ：domContentLoadedEventEnd -\n            navigationStart"),r("br"),n._v("onload 时间(总下载时间) ：loadEventEnd -\n            navigationStart"),r("br"),n._v("获取所有资源请求的时间数据,这个函数返回一个按\n            startTime 排序的对象数组 getEntries: ƒ getEntries()\n          ")])]),r("li",[r("p",[r("strong",[n._v("Google 的 Lighthouse 插件")])])]),r("li",[r("p",[r("strong",[n._v("网页性能测试分析工具-PageSpeed Insights （插件）、Page Speed\n              Online（网页）")]),r("br"),n._v("Pagespeed 测试工具出自\n            google，通过分析网页的内容来提供网站加载速度优化建议。PageSpeed\n            Insights 是一款可以分析网页打开速度的谷歌浏览器插件，通过\n            PageSpeed Insights\n            插件的分析并给出相应的优化建议，网站开发人员可以找出网站速度的瓶颈所在，并相应的网站优化，带给用户更好的用户体验。\n          ")])]),r("li",[r("p",[r("strong",[n._v("Yslow")])])]),r("li",[r("p",[r("strong",[n._v("Pingdom：")]),n._v("测试网站所有对象的加载时间（HTML，images，JavaScript，CSS，嵌入式框架等）。\n            您还可以检查网站每个元素的加载速度并改善加载缓慢的项目。\n            在测试结果中，可以看到网站每个元素的加载时间报告，元素的大小和元素的总数量。\n          ")])]),r("li",[r("p",[r("strong",[n._v("GTmetrix：")]),n._v("结合了最流行的 Firefox 性能组件 YSlow\n            的和谷歌网页速度测试工具。 Gtmetrix\n            给你提供改进网站速度的建议，虽然 YSlow\n            的和谷歌网页的速度测试的建议是针对 Firefox\n            的，也可以适用于其他浏览器。\n          ")])]),r("li",[r("p",[r("strong",[n._v("Light Speed Now")]),r("br"),n._v("测试你的网站的速度性能，并把测试报告发送给到你的邮箱。\n          ")])]),r("li",[r("p",[r("strong",[n._v("Load Impact")]),r("br"),n._v("Loadimpact\n            对于一个每天有成千上万的游客访问的大型网站来说是个非常重要的工具。\n            一个免费帐户允许你模拟 50\n            个用户访问的压力测试，还要更多的话你就必须升级高级账号。\n          ")])]),r("li",[r("p",[r("strong",[n._v("Site-Perf")]),r("br"),n._v("它模拟浏览器下载图片，CSS，JS\n            和其他文件，在报告中你可以看到先加载网站的哪些页以及加载时间。\n            这是十分有用的性能报告，可以用来查找到提高你的网站的载入速度需要改善的元素。\n          ")])])]),r("h5",{attrs:{id:"二、前端单元测试和持续集成"}},[r("a",{staticClass:"headerlink",attrs:{href:"#二、前端单元测试和持续集成",title:"二、前端单元测试和持续集成"}}),n._v("二、前端单元测试和持续集成\n      ")]),r("p",[n._v("一个测试体系大体应该包含四部分")]),r("ul",[r("li",[n._v("测试运行器 Test Runner: edp-test karma")]),r("li",[n._v("测试框架 Testing Framework: jasmine mocha qunit Jest")]),r("li",[n._v("断言库 Assertion library: expect.js should chai")]),r("li",[n._v("覆盖率 Coverage library: istanbul")])]),r("p",[r("strong",[n._v("Mocha/Karma+Travis.CI 的前端测试工作流")])]),r("ol",[r("li",[r("strong",[n._v("mocha")]),n._v("\n          是一个功能丰富的前端测试框架。所谓”测试框架”，就是运行测试的工具。通过它，可以为\n          JavaScript 应用添加测试，从而保证代码的质量。mocha 既可以基于\n          Node.js 环境运行\n          也可以在浏览器环境运行。欲了解更多可去官方网站进行学习。\n        ")]),r("li",[r("strong",[n._v("Karma")]),n._v("：一个基于 Node.js 的 JavaScript\n          测试执行过程管理工具（Test Runner）。该工具可用于测试所有主流 Web\n          浏览器，也可集成到 CI（Continuous\n          integration）工具，也可和其他代码编辑器一起使用。这个测试工具的一个强大特性就是，它可以监控文件的变化，然后自行执行，通过\n          console.log 显示测试结果。Karma\n          的一个强大特性就是，它可以监控一套文件的变换，并立即开始测试已保存的文件，用户无需离开文本编辑器。测试结果通常显示在命令行中，而非代码编辑器。这也就让\n          Karma 基本可以和任何 JS 编辑器一起使用。\n        ")]),r("li",[r("strong",[n._v("Travis.CI:")]),n._v(" 提供的是持续集成服务（Continuous\n          Integration，简称 CI）。它绑定 Github\n          上面的项目，只要有新的代码，就会自动抓取。然后，提供一个运行环境，执行测试，完成构建，还能部署到服务器。\n        ")])])]),r("footer",{staticClass:"post-footer"},[r("div",{staticClass:"post-tags"}),r("div",{staticClass:"post-nav"},[r("div",{staticClass:"post-nav-next post-nav-item"},[r("i",{staticClass:"fa fa-chevron-left"}),r("a",{attrs:{href:"https://www.dazhuanlan.com/2019/11/03/5dbe6b5ecbdd4/",rel:"next"}},[n._v("Hexo")])]),r("div",{staticClass:"post-nav-prev post-nav-item"},[r("a",{attrs:{href:"https://www.dazhuanlan.com/2019/11/03/5dbe6b271cc66/",rel:"prev"}},[n._v("源码看JAVA【二十九】AtomicLong")]),r("i",{staticClass:"fa fa-chevron-right"})])])]),r("div",{attrs:{id:"crp_related"}})])])}],fs={},vs=fs,Ss=Object(m["a"])(vs,hs,ys,!1,null,"39a79fd2",null),_s=Ss.exports,ks=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},js=[],ws='# 算法\r\n\r\n## 什么是时间复杂度\r\n\r\n### （1）语句频度\r\n\r\n- 算法就是你解决问题的方法，而你用这个方法解决这个问题所执行的语句次数，称为语句频度或者时间频度，记为T(n)。\r\n- 在上面提到的时间频度T(n)中，n是指算法的规模，n不断的变化，T(n)就会不断的变化，而这些变化的规律是怎样的呢？于是我们引入了时间复杂度的概念。\r\n\r\n### （2）时间复杂度\r\n\r\n- 算法中某个函数有n次基本操作重复执行，用T(n)表示，现在有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。通俗一点讲，其实所谓的时间复杂度，就是找了一个同样曲线类型的函数f(n)来表示这个算法的在n不断变大时的趋势 。当输入量n逐渐加大时，时间复杂性的极限情形称为算法的“渐近时间复杂性”。 \r\n\r\n### （3）大O记法\r\n\r\n- 在这种描述中使用的基本参数是 n，即问题实例的规模，把复杂性或运行时间表达为n的函数。这里的“O”表示量级 (order)，比如说“二分检索是 O(logn)的”,也就是说它需要“通过logn量级的步骤去检索一个规模为n的数组”记法 O ( f(n) )表示当 n增大时，运行时间至多将以正比于 f(n)的速度增长。 \r\n\r\n### （4）简单算法的时间复杂度举例\r\n\r\n- O(1)的算法是一些运算次数为常数的算法。\r\n\r\n\t- 例如：temp=a;a=b;b=temp;\r\n\t- 上面语句共三条操作，单条操作的频度为1，即使他有成千上万条操作，也只是个较大常数，这一类的时间复杂度为O(1)。\r\n\r\n- O(n)的算法是一些线性算法。\r\n\r\n\t- sum=0；                 \r\nfor(i=0;i<n;i++)       \r\nsum++；\r\n\t- 上面代码中第一行频度1，第二行频度为n，第三行频度为n，所以f(n)=n+n+1=2n+1。所以时间复杂度O(n)。这一类算法中操作次数和n正比线性增长。\r\n\r\n- O(logn) 一个算法如果能在每个步骤去掉一半数据元素，如二分检索，通常它就取 O(logn)时间。\r\n\r\n\t- int i=1; \r\nwhile (i<=n) \r\ni=i*2; \r\n\t- 上面代码设第三行的频度是f(n),   则：2的f(n)次方<=n;f(n)<=log₂n，取最大值f(n)= log₂n，所以T(n)=O(log₂n ) 。\r\n\r\n- O(n²)（n的k次方的情况）最常见的就是平时的对数组进行排序的各种简单算法都是O(n²)，例如直接插入排序的算法。而像矩阵相乘算法运算则是O(n³)。\r\n\r\n\t- sum=0；                \r\nfor(i=0;i<n;i++)  \r\n  for(j=0;j<n;j++) \r\n    sum++；\r\n\t- 第一行频度1，第二行n，第三行n²，第四行n²，T(n)=2n²+n+1 =O(n²)\r\n\r\n- O(2的n次方) 比如求具有n个元素集合的所有子集的算法 \r\n- O(n!) 比如求具有N个元素的全排列的算法\r\n\r\n### （5）时间复杂度按n越大算法越复杂来排\r\n\r\n- 常数阶O(1)、对数阶O(logn)、线性阶O(n)、线性对数阶O(nlogn)、平方阶O(n²)、立方阶O(n³)、……k次方阶O(n的k次方)、指数阶O(2的n次方)。\r\n\r\n### （6）最坏情况的时间和期望时间\r\n\r\n- 比如说快速排序，最坏情况运行时间是 O(n²)，但期望时间是O(nlogn)。但是我们只要通过一些手段，可以避免最坏情况发生，所以在实际情况中，精心设计的快速排序都能以期望时间运行。\r\n\r\n## 【栈，队列，链表】用JavaScript实现\r\n\r\n### 栈\r\n\r\n- 栈的特点是只能在某一端添加或删除数据，遵循先进后出的原则\r\n- 实现\r\n\r\n### 队列\r\n\r\n- 队列一个线性结构，特点是在某一端添加数据，在另一端删除数据，遵循先进先出的原则。\r\n- 实现\r\n\r\n\t- 单链队列\r\n\r\n\t- 循环队列\r\n\r\n\t\t- 因为单链队列在出队操作的时候需要 O(n) 的时间复杂度，所以引入了循环队列。循环队列的出队操作平均是 O(1) 的时间复杂度。\r\n### 链表\r\n\r\n- 头节点\r\n\r\n- 插入节点\r\n\r\n- 删除节点\r\n\r\n- 链表的设计（简易版）\r\n\r\n\t- 单向链表\r\n\r\n\t\t- 我们设计链表包含两个类，一个是 Node 类用来表示节点，另一个事 LinkedList 类提供插入节点、删除节点等一些操作。\r\n\t\t- Node类\r\n\r\n\t\t\t- Node类包含两个属性： element 用来保存节点上的数据，next 用来保存指向下一个节点的链接\r\n\t\t- LinkedList类\r\n\r\n\t\t\t- LinkedList类提供了对链表进行操作的方法，包括插入删除节点，查找给定的值等。值得注意的是，它只有一个 属性，那就是使用一个 Node 对象来保存该链表的头节点。\r\n\t\t- 具体方法的实现\r\n\r\n\t\t\t- find：查找给定节点\r\n\r\n\t\t\t- insert：向链表插入一个节点\r\n\r\n\t\t\t- display：显示链表\r\n\r\n\t\t\t- remove：从链表中删除一个节点\r\n\r\n\t\t\t\t- 从链表中删除节点时，我们先要找个待删除节点的前一个节点，找到后，我们修改它的 next 属性，使其不在指向待删除的节点，而是待删除节点的下一个节点。那么，我们就得需要定义一个 findPrevious 方法遍历链表，检查每一个节点的下一个节点是否存储待删除的数据。如果找到，返回该节点，这样就可以修改它的 next 属性了。 \r\n\t- 双向链表\r\n\r\n\t- 循环链表\r\n\r\n\t\t- 循环链表和单链表相似，节点类型都是一样，唯一的区别是，在创建循环链表的时候，让其头节点的 next 属性执行它本身，即，head.next = head;\r\n\t\t- 这种行为会导致链表中每个节点的 next 属性都指向链表的头节点，换句话说，也就是链表的尾节点指向了头节点，形成了一个循环链表\r\n## 【排序算法】优雅的 JAVASCRIPT 排序算法（ES6）\r\n\r\n### 总结\r\n\r\n- 名词解释\r\n\r\n\t- n: 数据规模\r\n\t- k:“桶”的个数\r\n\t- In-place: 占用常数内存，不占用额外内存\r\n\t- Out-place: 占用额外内存\r\n\t- 稳定性：排序后2个相等键值的顺序和排序之前它们的顺序相同\r\n\r\n\t\t- 1、堆排序、快速排序、希尔排序、直接选择排序不是稳定的排序算法；\r\n\t\t- 2、基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法。\r\n\t\t- 稳定排序在给定相同输入时具有确定性输出，这对于调试和测试可能很重要。\r\n\r\n### 冒泡排序（Bubble Sort）\r\n\r\n- 须知\r\n\r\n\t- 还有一种优化算法，就是立一个flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。\r\n\r\n- 工作原理\r\n\r\n\t- （1）比较相邻的元素。如果第一个比第二个大，就交换他们两个。\r\n\t- （2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\r\n\t- （3）针对所有的元素重复以上的步骤，除了最后一个。\r\n\t- （4）持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\r\n\r\n- 什么时候最快（Best Cases）：\r\n\r\n\t- 当输入的数据已经是正序时\r\n\r\n- 什么时候最慢（Worst Cases）：\r\n\r\n\t- 当输入的数据是反序时\r\n\r\n- JavaScript代码\r\n\r\n### 选择排序（Selection Sort）\r\n\r\n- 须知\r\n\r\n\t- 在时间复杂度上表现最稳定的排序算法之一，因为无论什么数据进去都是O(n²)的时间复杂度。。。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。\r\n\r\n- 工作原理\r\n\r\n\t- 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\r\n\r\n- JavaScript代码\r\n\r\n### 插入排序（Insertion Sort）\r\n\r\n- 须知\r\n\r\n\t- 插入排序的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。\r\n\t- 插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。\r\n\r\n- 工作原理\r\n\r\n\t- （1）从第一个元素开始，该元素可以认为已经被排序\r\n\t- （2）取出下一个元素，在已经排序的元素序列中从后向前扫描\r\n\t- （3）如果该元素（已排序）大于新元素，将该元素移到下一位置\r\n\t- （4）重复步骤3，直到找到已排序的元素小于或者等于新元素的位置\r\n\t- （5）将新元素插入到该位置后\r\n\t- （6）重复步骤2~5\r\n\r\n- JavaScript代码\r\n\r\n### 快速排序（Quick Sort）\r\n\r\n- 须知\r\n\r\n\t- 又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。\r\n\r\n- 原理\r\n\r\n\t- （1）在数据集之中，选择一个元素作为"基准"（pivot）。\r\n\t- （2）所有小于"基准"的元素，都移到"基准"的左边；所有大于"基准"的元素，都移到"基准"的右边。\r\n\t- （3）对"基准"左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。\r\n\t- 理解此版本的核心函数（分区并返回基准下标的函数）\r\n\r\n\t\t- 即除首项（left先做基准值）后面的所有项依次与首项基准值作比较，注意如果不大于基准值的话，i会持续增加，而index不会，所以找到比基准值小的项时，就让它的位置i与之前记录的index（此时index为最早发现的大于基准值的下标）交换，以此操作遍历完数组，最后在将，基准值与大小区分界的小数交换，即可完成分区\r\n\r\n- JavaScript代码\r\n\r\n',xs={data:function(){return{MainComponent:ws}}},Ts=xs,Cs=Object(m["a"])(Ts,ks,js,!1,null,"0a186b81",null),Ms=Cs.exports,Ps=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},Os=[],Es="# 调试\r\n\r\n## 调试9法\r\n\r\n### 1、理解系统\r\n\r\n- 阅读手册\r\n\r\n\t- 除草机温度过高，未通读手册\r\n\r\n- 逐字逐句阅读 整个手册\r\n\r\n\t- 因为有的关键信息正好可能被你遗漏了\r\n\r\n- 查阅手册\r\n\r\n\t- 有些东西不要凭自己的记忆，要翻阅资料进行确认\r\n\r\n- 知道什么是正常的\r\n\r\n\t- 知道什么是正常的 会帮助你注意什么不是正常的   还有基础知识很关键，手册是假定你知道某些基础知识的\r\n\r\n- 知道工作流程\r\n\r\n\t- 知道系统的整个架构及各个模块或环节的工作流程\r\n\r\n- 了解你的工具，包括工具的局限性\r\n\r\n\t- 调试工具\r\n\t- 开发工具\r\n\t- 编译器和链接器等\r\n\r\n### 2、制造失败\r\n\r\n- 原因\r\n\r\n\t- 可以观察失败时的具体情况\r\n\t- 可以专心查找原因，准确地知道问题在什么条件下发生\r\n\r\n\t\t- 应从各个因素考虑\r\n\r\n\t- 可以判断bug是否已经被修复\r\n\r\n- 注意点\r\n\r\n\t- 从头开始\r\n\r\n\t\t- 因为有的bug 仅仅在某个复杂的状态下才发生，因此必须仔细注意机器在执行各个步骤时的状态\r\n\r\n\t- 不要模拟失败（也就是模拟失败机理本身，如书中写的保存文档丢失图片的例子），而是引发失败（也就是模拟发生失败的条件，如放大效果法---书中提到的窗户喷水 或者自动化(过程/测试)法---书中提到的自动移动仪器的例子）\r\n\t- 在引发失败时不要画蛇添足\r\n\t- 不要 轻易说出“那不可能发生”\r\n\r\n\t\t- 汽车启动 和冰淇淋的例子\r\n\r\n\t- 永远不要丢掉调试（测试）工具\r\n\r\n- 如何处理间歇性bug\r\n\r\n\t- 出现间歇性bug的原因\r\n\r\n\t\t- 存在你没注意到或者无法控制的因素，如初始条件、输入数据等（没完全弄清楚失败是如何发生的，不知道完整的、准确的条件）\r\n\t\t- 测试者是否清醒\r\n\r\n\t- 找到那些你没有注意到或者不可控的可能的影响因子，并大量测试这些影响因子的不同状态或条件\r\n\t- （1、查找不受你控制的条件；2、记录每一件事情，并找到间歇性bug的特征）\r\n\r\n- 如果做了所有尝试，间歇性bug还存在\r\n\r\n\t- 仔细观察失败\r\n\t- 不要盲目的相信统计数据\r\n\t- 是bug已经修复了 还是运气好导致它暂时没有发生\r\n\r\n### 3、不要想（猜测），而要看\r\n\r\n- 观察失败\r\n\r\n\t- 一定要亲眼看到bug发生的实际情况，而不是靠猜测，观察往往比猜测更快的找到答案；猜测虽然看起来是个捷径，但它不会带你找到问题的根源\r\n\r\n\t\t- 楼栋管理员把插座拔掉的例子\r\n\t\t- 换新水泵的例子\r\n\r\n- 查看细节\r\n\r\n\t- 一直观察，直到把问题的原因锁定在几种可能性之内\r\n\r\n- 问题忽隐忽现\r\n\r\n\t- 在调试间歇性bug时，观察底层的失败细节有一个好处就是 看到底层的失败细节后，当你认为已修复bug时，很容易证明确实已修复，你不必依靠统计数据就可以看到错误不再发生。\r\n\r\n- 对系统进行插装\r\n\r\n\t- 设计插装工具（测试点）\r\n\r\n\t\t- 调试模式编译的情况下\r\n\r\n\t\t\t- 源代码调试器来观察程序的运行\r\n\r\n\t\t- 发布模式编译的情况下\r\n\r\n\t\t\t- 在性能监视器中输入各种有意义的变量，以便在运行时观察它们\r\n\r\n\t- 过后构建插装\r\n\t- 不要害怕深入研究\r\n\t- 添加外部插装\r\n\t- 日常生活中的插装\r\n\r\n\t\t- 体温计\r\n\t\t- X光透视\r\n\t\t- 水温计、压力计\r\n\r\n- 海森堡 测不准原理\r\n\r\n\t- 测量一个粒子的位置和测量它向哪个位置运动，这两者当中有一个测量得越精确，另一个就越测不准\r\n\t- 不要让仪器影响了系统\r\n\r\n- 猜测只是为了确定搜索的重点目标\r\n\r\n\t- 不要想，而要看并不是真的意味着不能做任何猜想\r\n\t- 不要过分相信你的猜测，它们往往偏离了方向\r\n\t- 例外的情况：如果某些问题比其他问题更容易出现（出现的概率大）或者比其他问题更易于修复，则应该首先检查这些问题；（易发生且易修复，则可以直接尝试修复它，而不需要真正看到失败的细节）\r\n\r\n\t\t- 灯不亮的例子\r\n\r\n\t\t\t- 灯或者开关坏了\r\n\r\n\t\t- 电热水器的例子\r\n\r\n\t\t\t- 内部保险丝或者跳闸了\r\n\r\n### 4、分而治之\r\n\r\n- 缩小搜索范围\r\n\r\n\t- 确定范围\r\n\t- 确定你位于bug的哪一侧\r\n\r\n\t\t- 如果你所在的位置有排放物。则排放管就在上游，如果没有，则在下游\r\n\r\n- 插入易于识别的模式\r\n\r\n\t- 从干净、清澈的水开始，以便当排放物进入河流中时很容易看到它\r\n\r\n- 从有问题的分支开始查找问题\r\n\r\n\t- 如果从正确的部分开始验证，那么需要验证的地方太多了\r\n\r\n- 修复已知的bug\r\n\r\n\t- bug相互保护，相互隐藏\r\n\r\n- 首先消除噪音干扰\r\n\r\n### 5、一次只改一个地方\r\n\r\n- 使用步枪而不是用散弹枪（控制变量法）\r\n- 用双手抓住黄铜杆（核潜艇）\r\n\r\n\t- 如果不清楚具体发生了什么问题就试图修复bug，会很危险！\r\n\r\n- 一次只改变一个测试\r\n\r\n\t- 如果所做的更改没有起到预期作用 应该把它改回去（  汽车不启动的例子--N档 P档 钥匙没有转到位 ）\r\n\r\n- 与正常系统进行对比\r\n- 确定自从上次正常工作以来你改变了什么\r\n\r\n\t- 不一定是最近一次的修改导致的，有可能很早就影响了\r\n\t- 唱片机 唱头的例子\r\n\r\n### 6、跟踪记录(保持审计跟踪)\r\n\r\n- 记下你的每次操作、顺序和结果\r\n\r\n\t- 要描述的非常清楚，以实物过敏为例，什么时候吃了什么有什么反应等\r\n\r\n- 魔鬼隐藏在细节中\r\n\r\n\t- 没穿鞋子 感到电击 的例子\r\n\t- 视频压缩芯片崩溃是由于格子寸衫造成的例子\r\n\r\n- 把事件关联到一起\r\n\r\n\t- 将某些症状与其他症状或调试信息关联起来是非常有用的\r\n\r\n- 用于设计的 审计跟踪（指源代码版本管理工具） 在测试中也非常有用\r\n- 好记性不如烂笔头\r\n\r\n### 7、检查是否犯了哪些低级错误 (检查插头)\r\n\r\n- 怀疑自己的假设\r\n\r\n\t- 通常，问题发生在较低的层次上，也就是你可能犯了低级错误，如汽车启动不了 可能是没油了，而不是化油器的问题\r\n\r\n- 从头开始检查\r\n\r\n\t- 如 使用除草机之前，你是否按了3次primer\r\n\r\n- 对工具进行测试\r\n\r\n\t- 编译器是否是二进制的例子\r\n\t- 燃料油表是否被粘住了的例子\r\n\r\n### 8、 求助( 获取全新观点)\r\n\r\n- 寻求帮助\r\n\r\n\t- 获得全新观点\r\n\r\n\t\t- 有时候向别人解释问题也会使你有全新的认识，因为对事件进行组织的过程迫使你跳出你原来的思维模式（（这里有点类似 小黄鸭调试法））\r\n\r\n\t- 询问专家\r\n\t- 听取别人的经验\r\n\r\n\t\t- 刹车灯保险丝断掉 跟车顶灯线露出的例子\r\n\t\t- 维修机器，敲击方法的例子\r\n\r\n- 到哪里寻求帮助\r\n\r\n\t- 同事\r\n\t- 供应商\r\n\t- 网络\r\n\t- 书店\r\n\r\n- 放下面子\r\n\r\n\t- 专家也可能出错\r\n\t- 以除掉bug为自豪，而不要非得以自己除掉bug才为自豪\r\n\r\n- 报名症状而不是理论\r\n\r\n\t- 不要把理论告诉帮助你的人而是现象，否则他可能被你拉到你的思维定势中，导致有些关键的细节被忽略了\r\n\r\n- 把症状的每个细节也描述清楚并别遗漏了\r\n- 让帮助你的人复现bug\r\n- 即使不十分肯定也可以提出来\r\n\r\n### 9、如果你不修复bug，它将依然存在\r\n\r\n- 检查问题确实已经被修复\r\n\r\n\t- 汽车低档位熄火的例子---原因是滤油器而不是线路问题\r\n\r\n- 检查确实是修复措施解决了问题\r\n\r\n\t- 检查方法是 你修复了问题后，取消这个修复，看bug是否再现，如果再现了，再把修复加上，再次验证问题是否已被修复\r\n\r\n- bug从来不会自己消失\r\n- 从根本上解决问题\r\n\r\n\t- 收音机变压器的例子\r\n\r\n- 对过程进行修复\r\n\r\n\t- 不要只是擦掉地上的油，而是要纠正设计机器的方式（四个螺钉而不是两个）\r\n\r\n",Rs={data:function(){return{MainComponent:Es}}},Ns=Rs,As=Object(m["a"])(Ns,Ps,Os,!1,null,"2c8612ee",null),Ds=As.exports,Is=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},Js=[],Ls='# 性能\r\n\r\n## 程序性能\r\n\r\n### Web Worker\r\n\r\n- JavaScript 当前并没有任何支持多线程执行的功能。\r\n- 程序中每一个这样的独立的多线程部分被称为一个（Web）Worker\r\n- Worker 之间以及它们和主程序之间，不会共享任何作用域或资源\r\n- 专用 Worker 和创建它的程序之间是一对一的关系，通过 meaasge 通信\r\n- 在 Worker 内部是无法访问主程序的任何资源的\r\n- 以执行网络操 作（Ajax、WebSockets）以及设定定时 器\r\n- 可以访问几个重要的全局变量和功能的本地复 本\r\n- 需要在线程之间通过事件机制传递大量的信息，可能是双向的\r\n- SharedWorker 可以共享的中心 worker\r\n- 在共享 Worker 内部，必须要处理额外的一个事件："connect"\r\n\r\n### 　SIMD\r\n\r\n- 单指令多数据（SIMD）是一种数据并行 （data parallelism）方式\r\n- SIMD JavaScript 计划向 JavaScript 代码暴露短向量类型和 API\r\n\r\n### asm.js\r\n\r\n- asm.js（http://asmjs.org ）这个标签是指 JavaScript 语言中可以高度优化的一个子集。\r\n- 现有的程序可以从asm.js 风格的优化得益而无需特意做什么\r\n- 关于 asm.js 优化，首先要理解的是类型和强制类型转换\r\n- var a= 42；var b = a | 0;\r\n- 对 JavaScript 性能影响最大的因素是内存分配、垃圾收集和作用域访问。\r\n- 对特定的任务处理提供一种优化方法，比如数学运算\r\n\r\n## 性能测试与调优\r\n\r\n### 性能测试\r\n\r\n- 简单的数学平均值绝对不足以对你要外推到整个应用范围的性能作出判断\r\n- 一个统计学上有效的性能测试工具，名为 Benchmark.js\r\n\r\n### 　环境为王\r\n\r\n- 现代引擎要比我们凭直觉进行的推导复杂得多\r\n- 引擎可能不会优化这样无关紧要的代码，但是在系统已经在运行更复杂的程序时可能会\r\n- 倾向于激进的优化。\r\n\r\n### jsPerf.com\r\n\r\n- 交叉引用多个浏览器上的测试运行结果\r\n- 测试结果就会被收集并持久化，累积的测试结果会被图形化\r\n\r\n### 写好测试\r\n\r\n- 要写好测试，需要认真分析和思考两个测试用例之间有什么区别，以及这些区别是有意 还是无意 的\r\n- 编写更好更清晰的测试\r\n- 不要试图窄化到真实代码的微小片段\r\n\r\n### 微性能\r\n\r\n- 有时候编译器可能会决定执行与你所写的不同的代码，不只是顺序不同，实际内容也会不同\r\n- 花费在优化关键路径上的时间不是浪费，不管节省的时间多么少\r\n- 而花在非关键路径优化上的时间都不值得，不管节省的时间多么多\r\n\r\n### 尾调用优化\r\n\r\n- 尾调用就是一个出现在另一个函数“结尾”处的函数调用\r\n- 调用一个新的函数需要额外的一块预留内存来管理调用栈，称为栈帧，尾部调用可以使用上一个函数的栈帧\r\n- 有了 TCO，尾调用的递归函数本质上就可以任意运行，因为再也不需要使用额外的内存！\r\n\r\n## JavaScript性能\r\n\r\n### 脚本阻塞\r\n\r\n- 减少JavaScript文件大小并限制HTTP请求数量\r\n- 将外链JavaScript放置页面底部加载\r\n- defer: 本元素所含的脚本不会修改,因此代码能安全地延迟执行，页面加载完成后执行\r\n- async：下载完成后自动执行，采用并行下载，下载过程中不会发生阻塞（同defer）\r\n- 动态脚本加载：操作DOM添加 script，所有的外链都是非阻塞加载，且加载完后会立即执行（FireFox和Opera会等所有动态脚本元素加载完后再执行）\r\n- IE中的script标签加载生命周期,只需监测带星号的状态\r\n\r\n\t- uninitialized\r\n\t- loading\r\n\t- loaded(*)\r\n\t- interactive\r\n\t- complete(*)\r\n\r\n### 数据存取\r\n\r\n- 作用域\r\n\r\n\t- 全局作用域\r\n\t- 局部作用域\r\n\r\n\t\t- 函数作用域\r\n\r\n\t\t\t- 创建函数时，它的作用域链插入了一个对象变量，这个对象变量包含该作用域下声明的所有的变量\r\n\t\t\t- 执行函数时，创建一个执行环境（执行上下文），执行结束执行环境就被销毁。（call stack）\r\n\r\n\t\t- 块状语句\r\n\r\n\t- 作用域链\r\n\r\n\t\t- 每个执行环境都有自己的作用域链，用解析标识符，如果当前作用域没有该标识符，则在上一级作用域查询，直到全局作用域。查询结束后，会创建一个活动对象（作为函数运行时的变量对象，然后此对象被推入作用域链最前端；执行环境被销毁，活动对象也随之销毁），正是这个查询过程影响了性能。\r\n\r\n\t- 改变作用域链\r\n\r\n\t\t- try...catch\r\n\r\n\t\t\t- catch语句会把错误对象推入作用域链最前端\r\n\r\n\t\t- with\r\n\r\n\t\t\t- 创建一个新的变量对象并将其推入作用域链最前端\r\n\r\n\t\t- eval\r\n\r\n\t\t\t- 动态作用域\r\n\r\n- 闭包\r\n\r\n\t- 闭包的[[scope]]属性包含了与执行环境作用域链相同的对象引用。函数的活动对象会随着执行环境一起销毁，但引入闭包后，由于引用仍然存在于闭包的[[scope]]属性中，所以此活动对象无法被销毁。\r\n\r\n- 原型\r\n\r\n\t- 原型、原型链可参照作用域链，表现和原理极其类似。\r\n\r\n### 算法和流程控制\r\n\r\n- 循环\r\n\r\n\t- 过程式\r\n\r\n\t\t- for in（也会遍历原型属性，bad）\r\n\t\t- for\r\n\t\t- while\r\n\t\t- do while\r\n\t\t- for of（ES6）\r\n\r\n\t- 基于函数的迭代普遍慢于过程式迭代\r\n\t- 避免for in，减少每次迭代处理的事务，减少迭代的次数\r\n\r\n- 条件语句和查找表\r\n\r\n\t- 根据场景需要，选择合适的方案。通常switch优于ifelsel，当判断条件很多时，使用查找表更优。\r\n\r\n- 递归和迭代\r\n\r\n\t- 大多数浏览器有调用栈限制，考虑用迭代替代一些递归\r\n\t- 缓存前一个计算结果供后续计算使用\r\n\r\n### 管理JavaScript运行时间\r\n\r\n- 浏览器UI线程（单线程）\r\n\r\n\t- 执行JavaScript代码\r\n\t- 更新用户界面（重排重绘）\r\n\r\n- 定时器\r\n\r\n\t- 用定时器将执行JavaScript代码的时间让给浏览器更新UI，然后再执行JavaScript代码\r\n\t- 注意事项\r\n\r\n\t\t- 设置的时间只是说明，在那个时间后 定时器绑定的事件才加入任务队列，并非是执行该事件。\r\n\r\n\t- 将耗时长的任务分割为一堆子任务\r\n\r\n- Web Workers\r\n\r\n\t- 未绑定UI线程，所以可在UI线程外执行特定的代码\r\n\t- 通过postMessage message来进行页面与Web Workers的通信\r\n\r\n- 注意事项\r\n\r\n\t- JavaScript脚本运行时间不应超过100ms\r\n\r\n### 事件循环\r\n\r\n- https://geniusfunny.github.io/2018/06/27/event-loop/\r\n\r\n### Ajax\r\n\r\n- 数据传输\r\n\r\n\t- 请求数据\r\n\r\n\t\t- 动态脚本注入\r\n\t\t- XMLHttpRequest\r\n\t\t- Multipart XHR\r\n\r\n\t\t\t- 无法缓存\r\n\t\t\t- 通过readystate为3来进行XHR流式处理\r\n\r\n\t- 发送数据\r\n\r\n\t\t- XHR\r\n\t\t- 信标（Beancons）\r\n\r\n- 数据格式\r\n\r\n\t- XML\r\n\t- Xpath\r\n\t- JSON\r\n\t- JSON-P\r\n\t- HTML\r\n\t- 自定义格式\r\n\r\n- 性能指南\r\n\r\n\t- 数据缓存\r\n\r\n\t\t- 设置HTTP头信息\r\n\t\t- 本地数据存储\r\n\r\n### 编程实践\r\n\r\n- 双重求值\r\n\r\n\t- 在程序中提取一个包含代码的字符串，然后动态执行它。\r\n\r\n- 使用Object/Array直接量\r\n- 延迟加载\r\n\r\n\t- 当一个函数在页面不会立刻调用时\r\n\r\n- 条件预加载\r\n\r\n\t- 当一个函数马上就要用到并且整个页面周期中频繁出现\r\n\r\n- 使用语言中快速的一部分\r\n\r\n\t- 位操作\r\n\t- 原生方法\r\n\r\n###  构建及部署\r\n\r\n- 合并多个JavaScript文件以减少HTTP请求\r\n- JavaScript压缩（剥离与运行无关的代码）\r\n- 在服务器端压缩JavaScript文件（Gzip）\r\n- 设置HTTP响应头来缓存JavaScript文件（协商缓存、强制缓存）\r\n- 使用CDN（内容分发网络）提供JavaScript文件\r\n\r\n## 前端性能指南\r\n\r\n### 减少HTTP请求\r\n\r\n- 图片\r\n\r\n\t- 图片地图（合并图片，一张图片上关联多个url，目标url取决于用户点击图片位置，常见于导航栏）\r\n\t- CSS Sprites（合并图片，然后使用background-position将HTML元素放到背景图片中期望的位置）\r\n\t- 内联图片（data:URL，有大小限制且比转化后比占据空间比原图大1/3，内联在页面时不会被缓存，但可缓存在样式表内部）\r\n\r\n- 合并脚本和样式表\r\n\r\n\t- 多个脚本合并为1个脚本，多个样式表合并为1个样式表\r\n\r\n### 使用内容分发网络（CDN）\r\n\r\n- CDN是一组分布在多个不同地理位置的Web服务器\r\n- 就近访问、全局负载均衡流量\r\n- 其目的是通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络"边缘"，使用户可以就近取得所需的内容，解决Internet网络拥塞状况，提高用户访问网站的响应速度。\r\n\r\n### 使用浏览器缓存(Cache-Control/Expires)\r\n\r\n### 压缩\r\n\r\n- Accept-Encoding: gzip, deflate\r\n- 考虑代理缓存及浏览器压缩支持\r\n\r\n### 将样式表放置顶部\r\n\r\n- 在样式表还在加载中时，浏览器不会构建呈现树。（详情见页面构建流程）\r\n\r\n### 将脚本放在底部\r\n\r\n- HTTP1.1规范建议一个主机名只能并行下载2个资源（除脚本），所以将资源分布到多个主机名（建议2个，更多的并行下载会消耗更多的CPU、网络）。\r\n- 脚本可能会使用document.write等方法修改页面内容，所以浏览器会等待，确保页面能够适当的布局。\r\n\r\n### 避免CSS表达式\r\n\r\n### 使用外部JavaScript和CSS\r\n\r\n- 外部JavaScript和CSS可以被浏览器缓存\r\n- 左右因素：页面浏览量、空缓存vs完整缓存、组件重用\r\n- 加载后下载：页面加载后，通过创建对应的DOM元素并赋予指定的URL来实现\r\n- 动态内联：通过cookie来反馈浏览器中的缓存给服务端，供其智能匹配内联/外部\r\n\r\n### 通过使用Keep-Alive和较少的域名来减少DNS查询\r\n\r\n### 精简JavaScript代码（删除空白字符、注释）、混淆JavaScript代码（除此之外会修改原代码）\r\n\r\n### 避免重定向（redirect会阻塞所有请求）\r\n\r\n### 去除重复的JavaScript脚本\r\n\r\n## 只有10%～20%的最终用户响应时间花在接受所请求的HTML文档上，剩余80%～90%的时间花在为HTML文档所引用的所有组件（图片、脚本、样式表、Flash等）\r\n\r\n',Hs={data:function(){return{MainComponent:Ls}}},Fs=Hs,Us=Object(m["a"])(Fs,Is,Js,!1,null,"3217204f",null),qs=Us.exports,Bs=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},Ws=[],Vs="## 现代前端技术解析\r\n\r\n### 前端与协议\r\n\r\n- HTTP协议\r\n- 前端实时协议\r\n\r\n\t- WebSocket通信机制\r\n\t- Poll(轮询)和Long-poll(长轮询)\r\n\r\n\t\t- Poll即浏览器采用定时向服务器发送请求轮询的方法不断发送或拉取消息。\r\n\t\t- HTTP请求可以设置一个较长的Timeout等待时间，这样网络轮询请求就可以维持一段较长的时间后返回结果，这也就是Long-poll（长轮询）的基本思路。服务器只要在这段长轮询时间内进行响应，请求便会立即返回结果；如果这段时间服务器没有返回，浏览器端将自动响应超时并重新发起一个长轮询请求。\r\n\r\n\t- 前端DDP协议\r\n\r\n\t\t- DDP（Distributed Data Protocol，分布式数据协议）是一种新型的客户端与服务器端的实时通信协议，由于兼容性的原因，目前使用还不广泛。\r\n\r\n- RESTful数据协议规范\r\n\r\n\t- REST（Representational State Transfer，表述性状态转化）并不是某一种具体的协议，而是定义了一种网络应用软件之间的架构关系并提出了一套与之对应的网络之间交互调用的规则。\r\n\t- 换种方式理解，RESTful是一种软件架构之间交互调用数据的协议风格规范，它建议以一种通用的方式来定义和管理数据交互调用接口。\r\n\r\n- 与Native交互协议\r\n\r\n### 前端三层结构与应用\r\n\r\n- HTML结构层基础\r\n\r\n\t- Web语义化标签\r\n\r\n\t\t- 用正确的标签做正确的事情。\r\n\t\t- HTML语义化能让页面内容更具结构化且更加清晰，便于浏览器和搜索引擎进行解析，因此在兼容条件下，要尽量使用带有语义化结构标签。\r\n\t\t- 即使在没有样式CSS的情况下，网页内容也应该是有序的文档格式显示，并且是容易阅读的。\r\n\t\t- 使项目维护人员更容易对网站进行分块，便于阅读理解。语义化的标签使用，能让开发者更容易区分标签元素中的内容\r\n\r\n\t- HTML糟糕的部分\r\n\r\n\t\t- Web语义化规范并不是在任何时候都需要严格遵守的，有时直接使用甚至会产生一些副作用。\r\n\r\n\t- AMP HTML\r\n\r\n\t\t- 流动网页提速（Accelerated Mobile Pages，AMP）是google推行的一个提升页面资源载入效率的HTML提议规范。基本思路有两点：使用严格受限的高效HTML标签以及使用静态网页缓存技术来提高网络访问静态资源的性能和用户体验。\r\n\r\n- 前端结构层演进\r\n\r\n\t- XML与HTML简述\r\n\r\n\t\t- 可扩展标记语言（Extentsible Markup Language，XML）是用来描述网络上存储数据的一种特殊文本标记格式。\r\n\t\t- HTML则是从SGML的基础上演化而来的另一种文本标记语言，一般用于网络上数据的展示。\r\n\r\n\t- HTML5标准\r\n\t- HTML Web Component\r\n\r\n- 浏览器脚本演进历史\r\n\r\n\t- CoffeeScript时代 --\x3e ECMAScript标准概述 --\x3e TypeScript概述 --\x3e JavaScript衍生脚本\r\n\r\n- JavaScript标准实践\r\n\r\n\t- ES5\r\n\t- ES6\r\n\r\n\t\t- let和const使用场景：模块内不变的引用和常量，一般使用const定义；可变的变量或引用使用let声明；var仅用于声明函数整个作用域内需要使用的变量。\r\n\t\t- 字符串模板\r\n\t\t- 解构赋值\r\n\t\t- 数组新特性\r\n\t\t- 函数参数\r\n\r\n\t\t\t- 默认参数\r\n\t\t\t- 不定参数\r\n\t\t\t- 扩展参数\r\n\r\n\t\t- 箭头函数\r\n\t\t- 增强对象\r\n\t\t- 类\r\n\t\t- 模块module\r\n\t\t- 循环与迭代器Iterator\r\n\r\n\t\t\t- for...of\r\n\t\t\t- Iterator\r\n\r\n\t\t- 生成器Generator\r\n\t\t- 集合类型Map+Set+WeakMap+WeakSet\r\n\t\t- Promise、Symbol、Proxy增强类型\r\n\t\t- 统一码\r\n\t\t- 进制数支持\r\n\r\n\t\t\t- 二进制（b）\r\n\t\t\t- 八进制（o）\r\n\r\n\t\t- Reflect对象和tail calls尾调用\r\n\r\n\t- ES7+\r\n\r\n\t\t- 幂指数操作符**\r\n\t\t- Array.prototype.includes\r\n\t\t- 异步函数async/await\r\n\t\t- SIMD\r\n\r\n\t- TypeScript\r\n\r\n\t\t- 强类型支持\r\n\t\t- Decorator装饰器特性\r\n\r\n- 前端表现层基础\r\n\r\n\t- CSS选择器与属性\r\n\r\n\t\t- CSS选择器\r\n\r\n\t\t\t- CSS中选择器属性优先级顺序为！important>内联样式（权重1000）> id选择器（权重100）>类选择器（权重10）>元素选择器（权重1）\r\n\t\t\t- 伪元素：::before，::after\r\n\t\t\t- 伪类：visited、:hover、:first-child、:nth-child、:enable、:checked\r\n\r\n\t\t- CSS属性\r\n\r\n\t\t\t- 布局类属性：position类、弹性布局fex、浮动float、对齐align\r\n\t\t\t- 几何类属性：盒模型相关（margin、padding、width、heigh、border）、box-shadow、渐变gradient、backgroud类、transform类\r\n\t\t\t- 文本类属性：font类、line-height、color类、text类（text-decoration、text-indent、textoverflow）、white-space、user-select、text-shawdow等\r\n\t\t\t- 动画类属性：以css3为主的transition、animation等\r\n\t\t\t- 查询类：Media query和IE Hack等\r\n\r\n- 前端界面技术\r\n\r\n\t- CSS样式统一化\r\n\r\n\t\t- reset：将不同浏览器中标签元素的默认样式全部清除，消除不同浏览器下默认样式的差异性\r\n\t\t- normalize：在整站样式基本确定的情况下对标签元素统一使用同一个默认样式规则\r\n\t\t- neat\r\n\r\n\t- css预处理\r\n\r\n\t\t- 预处理技术\r\n\r\n\t\t\t- sass\r\n\t\t\t- less\r\n\t\t\t- stylus\r\n\t\t\t- postCss：是一个用 JavaScript 工具和插件转换 CSS 代码的工具\r\n\r\n\t\t- 预处理工具特性\r\n\r\n\t\t\t- 变量声明和计算。方便一次赋值和随处使用，并能进行简单运算，提高开发管理效率。\r\n\t\t\t- 语法表达式。例如if-else条件语句、for循环等简单语法的设计能让页面CSS规则的生成更加灵活。\r\n\t\t\t- 函数处理。方便多次计算的地方能统一复用，例如函数处理和Mixin等特性。\r\n\t\t\t- 属性的继承。元素类属性的继承在开发样式相似但略微不同的多个模块的过程中非常有用，可以减少大量重复代码。\r\n\t\t\t- 兼容性补全。类似autoprefixer这种功能，让开发者不用过多关注不同浏览器的兼容问题，处理多个浏览器兼容性的代码能在预处理阶段自动生成补全，让一些问题的处理方式对开发者透明。\r\n\r\n\t- 表现层动画实现\r\n\r\n\t\t- JavaScript直接实现动画：其主要思想是通过JavaScript的setInterval方法或setTimeout方法的回调函数来持续调用改变某个元素的CSS样式以达到元素样式持续变化的结果\r\n\t\t- 可伸缩矢量图形（Scalable Vector Graphics，SVG）动画\r\n\t\t- CSS3 transition\r\n\t\t- CSS3 animation\r\n\t\t- Canvas动画\r\n\t\t- requestAnimationFrame\r\n\r\n- 响应式网站开发技术\r\n\r\n\t- 响应式页面实现概述\r\n\r\n\t\t- 实现方法\r\n\r\n\t\t\t- 通过前端或后端判断userAgent来跳转不同的页面完成不同设备浏览器的适配，也就是维护两个不同的站点来根据用户设备进行对应的跳转\r\n\t\t\t- 使用media query媒体查询等手段，让页面根据不同设备浏览器自动改变页面的布局和显示，但不做跳转\r\n\r\n\t- 结构层响应式\r\n\r\n\t\t- 结构层数据内容响应式：根据不同平台浏览器的情况加载不同的异步静态JavaScript，然后异步渲染不同的模块内容，生成不同的表现层结构来实现\r\n\t\t- 后端数据渲染响应式\r\n\t\t- 结构层媒体响应式\r\n\r\n\t- 表现层响应式\r\n\r\n\t\t- 响应式布局：\r\n\r\n\t\t\t- 一种是桌面端浏览器优先，扩展到移动端浏览器适配\r\n\t\t\t- 另一种则是以移动端浏览器优先，扩展到桌面端浏览器适配\r\n\r\n\t\t- 屏幕适配布局：在移动端解决内容按照不同屏幕大小自动等比例缩放的一种布局计算方式\r\n\r\n\t- 行为层响应式\r\n\r\n### 现代前端交互框架\r\n\r\n- 直接DOM操作时代\r\n\r\n\t- 节点查询型：getElementById、getElementsByName、getElementsByClassName、getElementsByTagName、querySelector、querySelectorAll\r\n\t- 节点创建型：createElement、createDocumentFragment、createTextNode、cloneNode\r\n\t- 节点修改型：appendChild、replaceChild、removeChild、insertBefore、innerHTML\r\n\t- 节点关系型：parentNode、previousSibling、childNodes\r\n\t- 节点属性型：innerHTML、attributes、getAttribute、setAttribute、getComputedStyle\r\n\t- 内容加载型：XMLHttpRequest、ActiveX\r\n\r\n- MV*交互模式\r\n\r\n\t- 前端MVC模式\r\n\t- 前端MVP模式\r\n\t- 前端MVVM模式\r\n\t- 数据变更检测示例\r\n\r\n\t\t- 手动触发绑定\r\n\t\t- 脏检测机制\r\n\t\t- 前端数据对象劫持(Hijacking)\r\n\t\t- ECMAScript 6 Proxy\r\n\r\n- Virtual DOM交互模式\r\n\r\n\t- Virtual DOM设计理念\r\n\t- Virtual DOM的核心实现\r\n\r\n\t\t- 创建Virtual DOM：把一段HTML字符串文本解析成一个能够描述它的JavaScript对象\r\n\t\t- 对比两个Virtual DOM生成差异化Virtual DOM\r\n\t\t- 将差异化Virtual DOM渲染到页面上\r\n\r\n- 前端MNV*时代\r\n\r\n\t- MNV*模式简介：这种使用JavaScript调用原生控件或事件绑定来生成应用程序的交互模式称为前端MNV＊开发模式\r\n\t- MNV*模式实现原理\r\n\r\n### 前端项目与技术实践\r\n\r\n- 前端开发规范\r\n- 前端组件规范\r\n\r\n\t- UI组件规范\r\n\r\n\t\t- UI层风格统一化。UI层风格统一化避免了不同页面的差异化设计风格，能让用户使用Web站点的不同网页外观风格是一致的。\r\n\t\t- 增加UI层复用性。使用UI规范的情况下，UI层代码复用性增强，可以提高开发效率，相同功能的结构和样式不用重复实现。\r\n\t\t- 更符合用户的体验习惯。例如红色按钮统一用来表示警告，绿色按钮统一表示安全或成功操作等。\r\n\t\t- 增加了开发规范的统一性。遵循统一的规范，避免重复开发，避免产生多种风格的代码。\r\n\r\n\t- 模块化规范\r\n\r\n\t\t- AMD（异步模块定义）：AMD是运行在浏览器端的模块化异步加载规范，主要以requireJS为代表，基本原理是定义define和require方法异步请求对应的javascript模块文件到浏览器端运行。模块执行导出时可以使用函数中的return返回结果。\r\n\t\t- CMD（通用模块定义）：CMD是Seajs提出的一种模块化规范，在浏览器端调用类似CommonJS的书写方式来进行模块引用，但却不是完全的CommonJS规范。\r\nCMD遵循按需执行依赖的原则\r\n\t\t- CommonJS：CommonJS是Node端使用的JavaScript模块化规范，使用require进行模块引入，并使用modules.exports来定义模块导出。\r\n\t\t- import/export\r\n\r\n\t- 项目组件化设计规范\r\n\r\n\t\t- Web Component组件化\r\n\t\t- MVVM框架组件化\r\n\t\t- Virtual DOM的组件化方案\r\n\t\t- 基于目录管理的通用组件化实践\r\n\r\n- 自动化构建\r\n\r\n\t- 自动化构建的目的：对文件进行模块化引入、依赖分析、资源合并、压缩优化、文件嵌入、路径替换、生成资源包等多种操作，这样就能完成很多原本需要手动完成的事情，极大地提高开发效率\r\n\t- 自动化构建原理：读取入口文件→分析模块引用→按照引用加载模块→模块文件编译处理→模块文件合并→文件优化处理→写入生成目录\r\n\t- 构建工具设计的问题\r\n\r\n\t\t- 模块分析引入\r\n\t\t- 模块化规范支持\r\n\t\t- CSS编译、自动合并图片\r\n\t\t- HTML、JavaScript、CSS资源压缩优化\r\n\t\t- HTML路径分析替换\r\n\t\t- 区分开发和上线目录环境\r\n\t\t- 异步文件打包方案\r\n\t\t- 文件目录白名单设置\r\n\r\n- 前端性能优化\r\n\r\n\t- 前端性能测试\r\n\t- 桌面浏览器前端优化策略\r\n\t- 移动端浏览器前端优化\r\n\r\n- 前端用户数据分析\r\n\r\n\t- 用户访问统计\r\n\t- 用户行为分析\r\n\t- 前端日志上报\r\n\t- 前端性能分析上报\r\n\r\n- 前端搜索引擎优化基础\r\n- 前端协作\r\n\r\n## 高效的组件化规范\r\n\r\n### 组件之间独立、松耦合。组件之间的HTML、JavaScript、CSS之间相互独立，尽量不重复，相同部分通过父级或基础组件来实现，最大限度减少重复代码。\r\n\r\n### 组件间嵌套使用。组件可以嵌套使用，但嵌套后仍然是独立、松耦合的。\r\n\r\n### 组件间通信。主要指组件之间的函数调用或通信，例如A组件完成某个操作后希望B组件执行某个行为，这种情况就可以使用监听或观察者模式在B组件中注册该行为的事件监听或加入观察者，然后选择合适的时机在A组件中触发这个事件监听或通知观察者来触发B组件中的行为操作，而不是在A组件中直接拿到B组件的引用并直接进 行操作，因为这样组件之间的行为就会产生耦合。\r\n\r\n### 组件公用部分设计。组件的公用部分应该被抽离出来形成基础库，用来增加代码的复用性。\r\n\r\n### 组件的构建打包。构建工具能够自动解析和打包组件内容。\r\n\r\n### 异步组件的加载模式。在移动端，通常考虑到页面首屏，异步的场景应用非常广泛，所有异步组件不能和同步组件一起处理。这时可以将异步组件区别于普通组件的目录存放，并在打包构建时进行异步打包处理。\r\n\r\n### 组件继承与复用性。对于类似的组件要做到基础组件复用来减少重复编码。\r\n\r\n### 私有组件的统一管理。为了提高协作效率，可以通过搭建私有源的方式来统一管理组件库，例如使用包管理工具等。但这点即使在大的团队里面也很难实施，因为业务组件的实现常常需要定制化而且经常变更，这样维护组件库成本反而更大，目前可以做的是将公用的组件模块使用私有源管理起来。\r\n\r\n### 根据特定场景进行扩展或自定义。如果当前的组件框架不能满足需求，我们应该能够很便捷地拓展新的框架和样式，这样就能适应更多的场景需求。比如在通过目录管理组件的方案下，既可以使用MVVM框架进行开发，也可以使用Virtual DOM框架进行开发，但要保持基本的规范结构不变。\r\n\r\n",Gs={data:function(){return{MainComponent:Vs}}},zs=Gs,$s=Object(m["a"])(zs,Bs,Ws,!1,null,"0e3ebb3f",null),Xs=$s.exports,Ks=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},Qs=[],Ys='# 安全\r\n\r\n## Web安全\r\n\r\n### XSS\r\n\r\n- 危害\r\n\r\n\t- Cookie劫持\r\n\t- 构造POST、GET请求\r\n\t- XSS钓鱼\r\n\t- 识别用户浏览器、识别用户安装的软件\r\n\t- CSS History Hack\r\n\t- 获取用户真实IP\r\n\t- XSS Worm\r\n\r\n- 构造\r\n\r\n\t- 利用字符编码\r\n\t- 绕过长度限制\r\n\t- base标签\r\n\t- window.name\r\n\r\n- 防御\r\n\r\n\t- HttpOnly\r\n\t- 输入检查\r\n\t- 输出检查\r\n\r\n### CSRF\r\n\r\n- 危害\r\n\r\n\t- 伪造请求\r\n\t- CSRF Worm\r\n\r\n- 防御\r\n\r\n\t- 验证码\r\n\t- Referer Check\r\n\t- Anti CSRF Token\r\n\r\n### ClickJacking\r\n\r\n- 危害\r\n\r\n\t- 视觉欺骗，诱导用户在该网页上操作\r\n\t- 图片覆盖攻击\r\n\t- 拖拽劫持和数据窃取\r\n\t- 触屏劫持\r\n\r\n- 构造\r\n\r\n\t- 调整iframe页面的位置，是用户恰好点击在iframe页面的一些功能性按钮上\r\n\r\n- 防御\r\n\r\n\t- frame busting\r\n\t- X-Frame-Options(优)\r\n\r\n### 注入攻击\r\n\r\n- SQL注入\r\n- 数据库攻击技巧\r\n- 正确防御SQL注入\r\n- 其他注入攻击\r\n\r\n### 文件上传漏洞\r\n\r\n- 一般场景\r\n\r\n\t- 上传Web脚本能够被服务器解析\r\n\r\n- 解决方案\r\n\r\n\t- 文件上传目录设置为不可执行\r\n\t- 判断文件类型\r\n\t- 使用随机数改写文件名和文件路径\r\n\t- 单独设置文件服务器的域名\r\n\r\n### 认证与会话\r\n\r\n### 拒绝服务攻击\r\n\r\n### 浏览器\r\n\r\n- 同源策略\r\n\r\n\t- 端口号、IP地址、子域名、协议必须相同的两个origin才为同源。\r\n\t- 跨域\r\n\r\n\t\t- window.name\r\n\t\t- jsonp\r\n\t\t- nginx转发\r\n\t\t- Node中间层\r\n\t\t- 配置CORS\r\n\t\t- websocket\r\n\r\n- Cookie策略\r\n\r\n\t- Cookie种类\r\n\r\n\t\t- Session Cookie\r\n\r\n\t\t\t- 存于浏览器进程的内存空间里（服务端不设置Expire和max-age时触发）\r\n\r\n\t\t- Third-party Cookie\r\n\r\n\t\t\t- 存于本地\r\n\r\n\t\t- 浏览器从一个域的页面加载另外一个域的资源，部分浏览器会阻止Third-party Cookie的发送\r\n\r\n### HTML5安全\r\n\r\n- 新标签、新事件可能带来新XSS攻击\r\n\r\n\t- 例如vedio的onloadedmetadata、ondurationchange等\r\n\r\n- 设置iframe的sandbox属性来增强应用使用iframe安全性\r\n\r\n\t- allow-same-origin\r\n\t- allow-top-navigation\r\n\t- allow-forms\r\n\t- allow-scripts\r\n\r\n- Link Type: noreferrer\r\n\r\n\t- 给link标签设置rel=\'noreferrer\'后，浏览器请求时将不再发送referrer\r\n\r\n- Canvas\r\n\r\n\t- 可以识别图片验证码\r\n\r\n- CORS\r\n- postMessage\r\n\r\n\t- postMessage允许每一个window对象向其他窗口发送文本消息，从而实现跨窗口的消息传递。\r\n\r\n- Web Storage\r\n\r\n## JWT(Json Web token)\r\n\r\n### （1）认识JWT\r\n\r\n- jwt是为了在网络应用环境传递声明而执行的一种基于json的开放标准。\r\n- jwt被用来在身份提供者和服务提供者间传递被认证的用户身份信息，简单来说，就是用来验证身份的手段，例如登录校验，像我们之前用的cookie。\r\n- jwt可以使用HMAC算法或者是RSA的公私秘钥对来进行签名，来保证信息的可靠性。\r\n\r\n### （2）应用场景\r\n\r\n- 在例如身份验证场景中，用户一旦登录，接下来的每个请求都会包含jwt，用来验证身份信息。由于通信双方使用jwt对数据进行编码，它的信息是经过签名的，所以可以确保信息的安全性。\r\n\r\n### （3）JWT对比cookie\r\n\r\n- Cookie缺点\r\n\r\n\t- 客户端发请求给服务器，服务器种植cookie后，每次请求都会带上cookie，浪费带宽\r\n\t- cookie不能跨服务器访问，不支持跨域\r\n\t- 服务器要对登录的用户对象进行存储，浪费服务器内存\r\n\r\n- JWT优点\r\n\r\n\t- （1）jwt是不基于状态的，不需要每次请求都带上token，节约流量\r\n\t- （2）可以跨服务端，可以共用\r\n\t- （3）体积小，因而传输速度快\r\n\t- （4）传输方式多样，可以通过 URL/POST 参数/HTTP 头部 等方式传输\r\n\t- （4）严谨的结构化。它自身（在 payload 中）就包含了所有与用户相关的验证消息，如用户可访问路由、访问有效期等信息，服务器无需再去连接数据库验证信息的有效性，并且 payload 支持为你的应用而定制化\r\n\t- （5）支持跨域验证，多应用于单点登录。\r\n\r\n\t\t- 单点登录（Single Sign On）：在多个应用系统中，用户只需登陆一次，就可以访问所有相互信任的应用。\r\n\t\t- 用户登陆之后，服务器会返回给他一个 token，由他保存在本地，在这之后的对服务器的访问都要带上这串 JWT ,来获得访问服务器相关路由、服务及资源的权限。比如单点登录就比较多地使用了 JWT，因为它的体积小，并且简单处理（使用 HTTP 头带上 Bearer 属性 + token ）就可以支持跨域操作。\r\n\r\n\t- （6）比 cookie 更支持原生移动端应用\r\n\r\n\t\t- 原生的移动应用对 cookie 与 session 的支持不够好，而对 token 的方式支持较好。\r\n\r\n\t- （7）验证解耦，无需使用特定的身份验证方案， token 可以在任何地方生成\r\n\r\n\t\t- 只要拥有生成 token 所需的验证信息，在何处都可以调用 token 生成接口，无需繁琐的耦合的验证操作，可谓是一次生成，永久使用。\r\n\r\n\t- （8）充分依赖无状态 API ，契合 RESTful 设计原则\r\n\r\n\t\t- 有状态\r\n\r\n\t\t\t- server 保存了 client 的请求状态， server 会通过 client 传递的 sessionID 在其 session 作用域内找到之前交互的信息并应答。\r\n\r\n\t\t- 无状态\r\n\r\n\t\t\t- 无状态是 RESTful 架构设计的一个非常主要的原则。无状态 API 的每一个请求都是独立的，它要求由客户端保存所有需要的认证信息，每次发请求都要带上自己的状态\r\n\r\n\t- （9）易于实现 CDN，将静态资源分布式管理\r\n\r\n\t\t- 在传统的 session 验证中，服务端必须保存 session ID，用于与用户传过来的 cookie 验证。而在一开始保存 session ID 时， 只会保存在一台服务器上，所以只能由一个 server 应答，就算其他服务器有空闲也无法应答，因此也利用不到分布式服务器的优点。\r\n\t\t- 而 JWT 依赖的是在客户端本地保存验证信息，不需要利用服务器保存的信息来验证，所以任意一台服务器都可以应答，服务器的资源也被较好地利用。\r\n\r\n### （4）JWT结构\r\n\r\n- Header头部\r\n\r\n\t- { typ:\'jwt\' ,alg:\'HS256\' }\r\n alg:当前用的什么算法加密的；使用Base64Url编码组成了JWT结构的第一部分\r\n\r\n- PlyLoad负载\r\n\r\n\t- 存放有效信息的地方\r\n\r\n- Signature签名\r\n\r\n\t- 创建签名需要使用编码后的header和payload以及一个秘钥；例如如果希望使用HMAC SHA256算法，那么签名应该使用下列方式创建\r\n\t- HMACSHA256( base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)\r\n\r\n- 完整的jwt格式的输出是以 . 分隔的三段Base64编码 密钥secret是保存在服务端的，服务端会根据这个密钥进行生成token和验证，所以需要保护好。\r\n\r\n### （5）例子\r\n\r\n- 流程图\r\n\r\n- 流程\r\n\r\n\t- （1）首先，拥有某网站账号的某 client 使用自己的账号密码发送 post 请求 login\r\n\t- （2）由于这是首次接触，server 会校验账号与密码是否合法，如果一致，则根据密钥生成一个 token 并返回\r\n\t- （3）client 收到这个 token 并保存在本地的 localStorage。\r\n\t- （4）在这之后，需要访问一个受保护的路由或资源时，而只要附加上你保存在本地的 token（通常使用 Bearer 属性放在 Header 的 Authorization 属性中），server 会检查这个 token 是否仍有效，以及其中的校验信息是否正确，再做出相应的响应。\r\n\r\n### 理解 JSON Web Tokens (JWT) 的 5 个简单步骤\r\n\r\n- JWT的定义\r\n\r\n\t- JSON Web令牌（JWT）是一种 JSON 对象（双引号字符串被认为是有效的 JSON 对象），是一套开放的标准定义的两方之间表示一组信息的安全方式。 JWT 由头部（header），负载（payload）和签名（signature）组成。\r\n\t- 简单地说，JWT只是一个具有以下格式的字符串：\r\n\r\n- 实际场景\r\n\r\n\t- 此示例中的三个不同的实体是用户，应用程序服务器和身份验证服务器。 验证服务器将向用户提供 JWT。 使用 JWT，用户可以安全地与应用程序通信。\r\n\r\n\t\t- 在该示例中，用户首先使用认证服务器的登录系统登录认证服务器（例如，用户名和密码，Facebook登录，Google登录等）。 然后，身份验证服务器创建 JWT并将其发送给用户。 当用户对应用程序进行 API 调用时，用户将传递 JWT 以及 API 调用。 在这个实例中，应用程序服务器将可以验证传入的 JWT 是否是由身份验证服务器创建的（验证过程将在稍后更详细地说明）。当用户使用附加的 JWT 进行API 调用时，应用程序可以使用 JWT 来验证该 API 调用是否来自经过身份验证的用户。\r\n\r\n- 构建JWT\r\n\r\n\t- Step 1. 创建 Header\r\n\r\n\t\t- JWT 的 Header 部分包含有关如何计算 JWT 签名的信息，是一个以下形式的 JSON 对象\r\n\r\n\t\t- 在上面的 JSON 中，“typ”键的值指定对象是JWT，“alg”键的值指定用于创建 JWT 签名的算法。 在示例中，我们使用 HMAC-SHA256算法（一种使用密钥的散列算法）来计算签名\r\n\r\n\t- Step 2. 创建 Payload\r\n\r\n\t\t- JWT 的 payload 部分时是存储在 JWT 内的数据。在我们的示例中，身份验证服务器创建一个JWT，其中存储有用户信息，特别是用户ID。\r\n\r\n\t\t- 在我们的示例中，我们只将一个声明放入 payload 中。 你可以根据需要添加任意数量的声明。JWT 规定了7个官方字段，供选用。\r\n\r\n\t\t\t- iss (issuer)：签发人\r\n\t\t\t- exp (expiration time)：过期时间\r\n\t\t\t- sub (subject)：主题\r\n\t\t\t- aud (audience)：受众\r\n\t\t\t- nbf (Not Before)：生效时间\r\n\t\t\t- iat (Issued At)：签发时间\r\n\t\t\t- jti (JWT ID)：编号\r\n\r\n\t\t- 除了官方字段，你还可以在这个部分定义私有字段。请记住，数据的大小将影响JWT的总体大小，这通常不是问题，但过大的 JWT 可能会对性能产生负面影响并导致延迟。\r\n\r\n\t- Step 3. 创建 Signature\r\n\r\n\t\t- 使用某算法，其所做的是 base64url 对在步骤1和2中创建的header和payload进行编码。然后，算法将得到的编码字符串用“点”（.）连在一起。\r\n\r\n\t\t- 在示例中，header 和 payload 被 base64url 编码，然后，在加入周期的编码头和编码有效载荷上应用带有密钥的指定签名算法，我们得到签名所需的散列数据。 在我们的例子中，这意味着在数据字符串上应用 HS256 算法，并将密钥设置为字符串“secret”，以获取 hashedData字符串。 之后，通过base64url 编码 hashedData 字符串\r\n\r\n\t- Step 4. 把 JWT 的三个部分组合在一起\r\n\r\n\t\t- 我们只需要组合以上的三个部分，用点（.）分隔它们。\r\n\r\n\t\t\t- // JWT Token\r\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ.-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM\r\n\r\n\t- Step 5. 校验 JWT\r\n\r\n\t\t- 在我们的示例中，我们使用的是由 HS256 算法签名的JWT，其中只有身份验证服务器和应用服务器知道密钥。当应用程序设置其身份验证过程时，应用程序服务器从身份验证服务器接收密钥。由于应用程序知道密钥，当用户对应用程序进行带有 JWT 附加的 API 调用时，应用程序可以执行与 JWT 上的步骤3相同的签名算法。然后，应用程序可以验证从其自己的哈希操作获得的签名是否与 JWT 本身上的签名匹配（即，它与由认证服务器创建的 JWT 签名匹配）。如果签名匹配，则表示 JWT 有效，表示 API 调用来自可信源。否则，如果签名不匹配，则表示收到的 JWT 无效，这可能是对应用程序的潜在攻击的指示。因此，通过验证 JWT，应用程序在其自身和用户之间添加了一层信任。\r\n\r\n- JWT 如何保护我们的数据？\r\n\r\n\t- 要理解使用 JWT 的目的不是以任何方式隐藏或模糊数据，而是为了证明发送的数据是由真实的来源创建的。\r\n\t- 由于 JWT 仅被签名和编码，并且由于 JWT 未加密，因此 JWT 不能保证敏感数据的安全性。\r\n\r\n## Web 的攻击技术\r\n\r\n### 针对 Web 的攻击技术\r\n\r\n- 简单的 HTTP 协议本身并不存在安全性问题,因此协议本身几乎不会成为攻击的对象\r\n- 在运作的 Web 应用背后却隐藏着各种容易被攻击者滥 用的安全漏洞的 Bug\r\n- 在 Web 应用中,从浏览器那接收到的 HTTP 请求的全部内容,都可以在客户端自由地变更、篡改\r\n- 在 HTTP 请求报文内加载攻击代码,就能发起对 Web 应用的攻击\r\n- 主动攻击(active attack)是指攻击者通过直接访问 Web 应用,把攻击代码传入的攻击模式\r\n- 被动攻击(passive attack)是指利用圈套策略执行攻击代码的攻击模式。\r\n\r\n### 因输出值转义不完全引发的安全漏洞\r\n\r\n- 跨站脚本攻击(Cross-Site Scripting,XSS)是指通过存在安全漏洞的 Web 网站注册用户的浏览器内运行非 法的 HTML 标签或 JavaScript 进行的一种攻击\r\n- 利用虚假输入表单骗取用户个人信息。\r\n- 利用脚本窃取用户的 Cookie 值, 被害者在不知情的情况下, 帮助攻击者发送恶意请求。\r\n- 显示伪造的文章或图片\r\n- 跨站脚本攻击案例\r\n- 在动态生成 HTML 处发生\r\n- 对用户 Cookie 的窃取攻击\r\n- SQL 注入(SQL Injection)是指针对 Web 应用使用的数据库,通过运行非法的 SQL 而产生的攻击。\r\n- 非法查看或篡改数据库内的数据\r\n- 规避认证\r\n- 执行和数据库服务器业务关联的程序等\r\n- OS 命令注入攻击(OS Command Injection)是指通过 Web 应用,执行非法的操作系统命令达到攻击的目 的\r\n- HTTP 首部注入攻击(HTTP Header Injection)是指攻击者通过在响应首部字段内插入换行,添加任意响应首部或主体的一种攻击。\r\n- 设置任何 Cookie 信息\r\n- 重定向至任意 URL\r\n- 显示任意的主体( HTTP 响应截断攻击)\r\n- HTTP 首部注入攻击案例\r\n- 邮件首部注入(Mail Header Injection)是指 Web 应用中的邮件发送功能,攻击者通过向邮件首部 To 或 Subject 内任意添加非法内容发起的攻击\r\n- 目录遍历(Directory Traversal)攻击是指对本无意公开的文件目录,通过非法截断其目录路径后,达成访问 目的的一种攻击\r\n- 远程文件包含漏洞(Remote File Inclusion)是指当部分脚本内容需要从其他文件读入时,攻击者利用指定外 部服务器的 URL充当依赖文件,让脚本读取之后,就可运行任意脚本的一种攻击\r\n\r\n### 因设置或设计上的缺陷引发的安全漏洞\r\n\r\n- 强制浏览\r\n\r\n\t- 强制浏览(Forced Browsing)安全漏洞是指,从安置在 Web 服务器的公开目录下的文件中,浏览那些原本 非自愿公开的文件\r\n\t- 泄露顾客的个人信息等重要情报\r\n\t- 泄露原本需要具有访问权限的用户才可查阅的信息内容\r\n\t- 泄露未外连到外界的文件\r\n\r\n- 不正确的错误消息处理\r\n\r\n\t- Web 应用不必在用户的浏览画面上展现详细的错误消息。对攻击者来说,详细的错误消息有可能给他们下一 次攻击以提示\r\n\r\n- 开放重定向\r\n\r\n\t- 开放重定向(Open Redirect)是一种对指定的任意 URL 作重定向跳转的功能。\r\n\r\n### 因会话管理疏忽引发的安全漏洞\r\n\r\n- 会话劫持(Session Hijack)是指攻击者通过某种手段拿到了用户的会话 ID,并非法使用此会话 ID 伪装成用 户,达到攻击的目的\r\n- 对以窃取目标会话 ID 为主动攻击手段的会话劫持而言,会话固定攻击(Session Fixation)攻击会强制用户 使用攻击者指定的会话 ID,属于被动攻击。\r\n- 跨站点请求伪造(Cross-Site Request Forgeries,CSRF)攻击是指攻击者通过设置好的陷阱,强制对已完 成认证的用户进行非预期的个人信息或设定信息等某些状态更新,属于被动攻击。\r\n\r\n### 其他安全漏洞\r\n\r\n- 密码破解攻击(Password Cracking)即算出密码,突破认证\r\n- 通过网络的密码试错\r\n\r\n\t- 穷举法\r\n\t- 字典攻击\r\n\r\n- 对已加密密码的破解(指攻击者入侵系统, 已获得加密或散列处理的密码数据的情况)\r\n- 点击劫持(Clickjacking)是指利用透明的按钮或链接做成陷阱,覆盖在 Web 页面之上。然后诱使用户在不 知情的情况下,点击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装(UI Redressing)。\r\n- DoS 攻击(Denial of Service attack)是一种让运行中的服务呈停止状态的攻击\r\n- 后门程序(Backdoor)是指开发设置的隐藏入口,可不按正常步骤使用受限功能\r\n\r\n## web安全机制\r\n\r\n### 基础安全知识\r\n\r\n- XSS(跨站脚本攻击)\r\n\r\n\t- XSS通常是由带有页面可解析内容的数据未经处理直接插入到页面上解析导致的。\r\n\t- 存储型XSS的攻击脚本常常是由前端提交的数据未经处理直接存储到数据库然后从数据库中读取出来后又直接插入到页面中所导致的\r\n\t- 反射型XSS可能是在网页URL参数中注入了可解析内容的数据而导致的，如果直接获取URL中不合法的并插入页面中则可能出现页面上的XSS攻击\r\n\t- MXSS（也叫DOM XSS）则是在渲染DOM属性时将攻击脚本插入DOM属性中被解析而导致的\r\n\t- XSS主要的防范方法是验证输入到页面上所有内容来源数据是否安全，如果可能含有脚本标签等内容则需要进行必要的转义。\r\n\r\n- SQL(结构化查询语言)注入\r\n\r\n\t- SQL注入攻击主要是因为页面提交数据到服务器端后，在服务器端未进行数据验证就将数据直接拼接到SQL语句中执行，因此产生执行与预期不同的现象。\r\n\t- 主要防范措施是对前端网页提交的数据内容进行严格的检查校验。\r\n\r\n- CSRF(跨站请求伪造)\r\n\r\n\t- CSRF是指非源站点按照源站点的数据请求格式提交非法数据给源站点服务器的一种攻击方法。\r\n\t- 非源站点在取到用户登录验证信息的情况下，可以直接对源站点的某个数据接口进行提交，如果源站点对该提交请求的数据来源未经验证，该请求可能被成功执行，这其实并不合理。通常比较安全的是通过页面Token（令牌）提交验证的方式来验证请求是否为源站点页面提交的，来阻止跨站伪请求的发生。\r\n\r\n### 请求劫持与HTTPS\r\n\r\n- DNS劫持\r\n\r\n\t- DNS劫持通常是指攻击者劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致用户对该域名地址的访问由原IP地址转入到修改后的指定IP地址的现象，其结果就是让正确的网址不能解析或被解析指向另一网站IP，实现获取用户资料或者破坏原有网站正常服务的目的。DNS劫持一般通过篡改DNS服务器上的域名解析记录，来返回给用户一个错误的DNS查询结果实现。\r\n\t- DNS劫持症状可能为在某些地区的用户在成功连接宽带网络后，访问域名为www.a.com的网站，出现的却是www.b.com网站的内容，因为DNS服务器www.a.com域名的解析结果被修改指向了www.b.com网站指向的IP地址。\r\n\r\n- HTTP劫持\r\n\r\n\t- HTTP劫持是指，在用户浏览器与访问的目的服务器之间所建立的网络数据传输通道中从网关或防火墙层上监视特定数据信息，当满足一定的条件时，就会在正常的数据包中插入或修改成为攻击者设计的网络数据包，目的是让用户浏览器解释“错误”的数据，或者以弹出新窗 口的形式在使用者浏览器界面上展示宣传性广告或者直接显示某块其他的内容。\r\n\t- 这种情况下一般用户请求源网站的IP地址及网站加载的内容和脚本都是正确的，但是在网站内容请求返回的过程中，可能被ISP（Internet Service Provider，互联网服务提供商）劫持修改，最终在浏览器页面上添加显示一些广告等内容信息。\r\n\r\n- 对于这些情况，网站开发者常常就无法通过修改网站代码程序等手段来进行防范了。请求劫持唯一可行的预防方法就是尽量使用HTTPS协议来访问目标网站。\r\n\r\n### HTTPS协议通信过程\r\n\r\n- HTTPS协议是通过加入SSL（Secure Sockets Layer）层来加密HTTP数据进行安全传输的HTTP协议，同时启用默认的443端口进行数据传输。\r\n- 公钥（Public Key）与私钥（Private Key）是通过一种加密算法得到的密钥对（即一个公钥和一个与之匹配的私钥），公钥是密钥对中公开的部分，私钥则是非公开的部分。公钥通常用于会话加密、验证数字签名或者加密可以用相应私钥解密的数据。通过这种算法得到的密钥对保证是唯一的。使用这个密钥对的时候，如果用其中一个密钥加密一段数据，则必须用另一个密钥解密。\r\n\r\n### HTTPS协议解析\r\n\r\n- HTTPS请求报文和HTTP的请求报文区别不大，但是在请求的头部域字段多了upgrade-insecure-requests，该头部字段指令很关键，它可以用于让页面打开的后续请求自动从 HTTP请求升级到HTTPS请求。否则如果使用HTTPS来加载HTML文件，而HTML中加载的是HTTP链接的资源文件，则会产生Mixed Content类型的错误，并且无法加载资源。\r\n- 在服务器端响应头域中也要加入下面的头域来返回给浏览器，否则浏览器默认安全显示策略会阻塞内容并提示block-all-mixed-content类型的错误。\r\nheader("Content-Security-Policy: upgrade-insecure-requests") ;\r\n\r\n### 浏览器Web安全控制\r\n\r\n- X-XSS-Protection\r\n\r\n\t- 这个head消息头设置主要是用来防止浏览器中的反射性XSS问题的发生，通过这种方式可以在浏览器层面增加前端网页的安全性。\r\n\t- X-XSS-Protection通常设置如下。\r\n\r\nX-XSS-Protection: 1;\r\nmode=block 0 –关闭对浏览器的xss防护；1 –开启xss防护\r\nmode=block可以开启XSS防护并通知浏览器阻止而不是过滤用户注入的XSS脚本\r\n\r\n- Strict-Transport-Security\r\n\r\n\t- Strict Transport Security（STS）是一种用来配置浏览器和服务器之间安全通信的机制，主要用来防止中间者攻击，因为它强制所有的通信都使用HTTPS，在普通的HTTP报文请求中配置STS是没有作用的，而且攻击者也能更改这些值。\r\n\t- 为了防止这样的现象发生，很多浏览器内置了一个配置STS的站点列表，在Chrome浏览器下可以通过访问chrome://net-internals/#hsts查看浏览器中站点的STS列表，一般STS的配置实现如下。\r\n\r\nmax-age=31536000 –告诉浏览器将域名缓存到STS列表中，只有这些特定域名下的资源内容才允许被加载，时\r\n间是一年\r\nmax-age=31536000;\r\nincludeSubDomains;\r\npreload; –告诉浏览器将域名缓存到STS列表里面并且包含所有的子域名，并可支持预加载，时间是一年\r\nmax-age= 0 –告诉浏览器移除在STS缓存里的域名，或者不保存当前域名\r\n\r\n- Content-Security-Policy\r\n\r\n\t- 我们简称它为CSP，这是一种由开发者定义的安全策略性声明，通过CSP所约束的的规则设定，浏览器只可以加载指定可信的域名来源的内容（这里的内容可以是脚本、图片、iframe、font、style等等远程资源）。通过CSP协定，Web只能加载指定安全域名下的资源文件，保证运行时的内容总处于一个安全的环境中。\r\n\r\n- Access-Control-Allow-Origin\r\n\r\n\t- Access-Control-Allow-Origin是从Cross Origin Resource Sharing（CORS）中分离出来的。这个头部设置是决定哪些网站可以访问当前服务器资源的设置，通过定义一个通配符或域名来决定是单一的网站还是所有网站可以访问服务器的资源。\r\n\t- 需要注意的是，如果服务器端定义了通配符“＊”，那么服务端的Access-Control-Allow-Credentials（是否允许请求时携带验证信息）选项就无效了，此时用户浏览器中的不同域Cookie信息将默认不会在服务器请求里发送（即如果需要实现带Cookie进行跨域请求，则要明确地配置允许来源的域，使用任意域的配置是不合法的）。\r\n\r\nAccess-Control-Allow-Origin : * *– 通配符允许任何远程资源来访问 Access-Control-Allow-Origin\r\n的内容  \r\nhttp://www.domain.com – 只允许特定站点才能访问当前资源\r\n\t- Access-Control-Allow-Origin常常作为跨域共享设置的一种实现方式，其他常用的跨域手段还有： JSONP(JSON with Padding)、 script标签跨域、 window.postMessage、修改 document.domain跨子域、 window.name跨域和 WebSocket跨域等。\r\n\r\n##  XSS\r\n\r\n### 跨站脚本攻击(Cross Site Scripting)，缩写为XSS\r\n\r\n- （1）XSS的定义：跨域脚本注入，攻击者通过某种方式将恶意代码注入到网页上，然后其他用户观看到被注入的页面内容后会受到特定攻击\r\n\r\n\t- 恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。\r\n\r\n- （2）XSS的原理\r\n\r\n\t- 1.攻击者对含有漏洞的服务器发起XSS攻击（注入JS代码）。\r\n\t- 2.诱使受害者打开受到攻击的服务器URL。\r\n\t- 3.受害者在Web浏览器中打开URL，恶意脚本执行。\r\n\r\n- （3）XSS的攻击方式\r\n\r\n\t- 1.反射型：（直接通过URL注入，而且很多浏览器都自带防御）\r\n\r\n\t\t- 发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS随响应内容一起返回给浏览器，最后浏览器解析执行XSS代码，这个过程就像一次发射，所以叫反射型XSS\r\n\t\t- 反射型XSS漏洞的攻击步骤\r\n\r\n\t\t\t- （1） 用户正常登录Web应用程序，登录成功会得到一个会话信息的cookie：\r\n\r\n\t\t\t- （2） 攻击者将含有攻击代码的URL发送给被攻击人；\r\n\r\n\t\t\t- （3） 用户打开攻击者发送过来的ULR；\r\n\t\t\t- （4） Web应用程序执行用户发出的请求；\r\n\t\t\t- （5） 后台对URL参数未做任何过滤处理，返回给客户端，前端直接从url上获取参数，会导致URL上的js代码执行\r\n\t\t\t- （6） 例子中攻击者使用的攻击代码作用是将用户的cookie信息发送到cookie_save.php这个文件来记录下来；\r\n\t\t\t- （7） 攻击者在得到用户的cookie信息后，将可以利用这些信息来劫持用户的会话。以该用户的身份进行登录。\r\n\r\n\t- 2.存储型：（存储到DB后读取时注入）\r\n\r\n\t\t- 存储型XSS和反射型的XSS差别就在于，存储型的XSS提交的代码会存储在服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交XSS代码。\r\n\r\n\t- 3. DOM-based XSS\r\n\r\n\t\t- 代码\r\n\r\n\t\t- 理解\r\n\r\n- （4）XSS的防御措施\r\n\r\n\t- （1）输出进行编码：\r\n\r\n\t\t- HTML实体编码\r\n\r\n\t\t\t- 在 HTML 中，某些字符是预留的，比如不能使用小于号（<）和大于号（>），这是因为浏览器会误认为它们是标签。如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。当然还另一个重要原因，有些字符在 ASCII 字符集中没有定义，因此需要使用字符实体来表示，比如中文。\r\n\t\t\t- 最常见的五种实体编码\r\n\r\n\t\t- 和输入过滤类似，不过是从输出上着手，数据输出到页面时，经过HtmlEncoder等工具编码，这样就不会存在直接输出可执行的脚本了\r\n\r\n\t- （2）输入过滤：\r\n\r\n\t\t- 不信任用户的任何输入，过滤其中的“<”、“>”、“/”等可能导致脚本注入的特殊字符， 或者过滤“script”、“javascript”等脚本关键字，或者对输入数据的长度进行限制等等， 还得考虑攻击者使用十六进制编码来输入脚本的方式。\r\n\t\t- 而在一些前端框架中，都会有一份 decodingMap， 用于对用户输入所包含的特殊字符或标签进行编码或过滤，如 <，>，script，防止 XSS 攻击：\r\n\r\n\t- （3）Cookie设置http-only（防止劫取 Cookie）：\r\n\r\n\t\t- HttpOnly 最早由微软提出，至今已经成为一个标准。浏览器将禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。\r\n\t\t- 上文有说到，攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。\r\n\r\n\t- （4）Cookie防盗：\r\n\r\n\t\t- 在 Cookie 中防止放入用户名和密码，对 Cookie 信息进行 MD5 等算法进行多次散列存放，必要时还要对 ip 和 cookie 进行绑定，一旦检测异常，立马让用户重新登录；\r\n\r\n## CSRF\r\n\r\n### CSRF（跨站请求伪造）（cross-site request forgery）\r\n\r\n- （1）CSRF的定义：冒用用户身份，进行恶意操作\r\n\r\n\t-  攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。\r\n\r\n- （2）CSRF的原理\r\n\r\n\t- 1. 用户打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；\r\n\t- 2.在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；\r\n\t- 3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；\r\n\t- 4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；\r\n\t- 5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 \r\n\t- CSRF攻击的本质原因 ：CSRF 攻击时源于 WEB 的隐式身份验证机制！WEB 的身份验证机制虽然可以保证一个请求是来自某个用户的浏览器，但无法保证该请求是经过用户批准发送的。\r\n\r\n- （3）CSRF的攻击手段\r\n\r\n\t-  1.譬如在网站内的图片资源中潜入恶意的转账操作\r\n\r\n\t-  2.构建恶意的隐藏表单，并通过脚本提交恶意请求\r\n\r\n\t- 【注意】\r\n\r\n\t\t- 从头到尾，攻击网站都没有获取到过 cookie，都是通过浏览器间接实现（利用Web的cookie隐式身份验证机制），所以HttpOnly并不会影响这个攻击\r\n\r\n\t- 【例子】（必看）\r\n\r\n\t\t- （1）假设有一个 bbs 站点：http://www.c.com，当登录后的用户发起如下 GET 请求时，会删除 ID 指定的帖子\r\n\r\n\t\t\t- 如发起 http://www.c.com:8002/content/delete/87343 请求时，会删除 id 为 87343 的帖子。当用户登录之后，会设置如下 cookie\r\n\r\n\t\t- （2）然后构造一个页面 A\r\n\r\n\t\t- （3）页面 A 使用了一个 img 标签，其地址指向了删除用户帖子的链接\r\n\r\n\t\t- （4）可以看到，当登录用户访问攻击者的网站时，会向 www.c.com 发起一个删除用户帖子的请求。此时若用户在切换到 www.c.com 的帖子页面刷新，会发现ID 为 87343 的帖子已经被删除。\r\n\t\t- 深刻理解\r\n\r\n\t\t\t- 由于 Cookie 中包含了用户的认证信息，当用户访问攻击者准备的攻击环境时，攻击者就可以对服务器发起 CSRF 攻击。在这个攻击过程中，攻击者借助受害者的 Cookie 骗取服务器的信任，但并不能拿到 Cookie，也看不到 Cookie 的内容。而对于服务器返回的结果，由于浏览器同源策略的限制，攻击者也无法进行解析。因此，攻击者无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。\r\n\r\n- （4）常见的CSRF防御手段\r\n\r\n\t- 1.利用Token来防御\r\n\r\n\t  CSRF 攻击之所以能够成功，是因为攻击者可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 Cookie 中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的 Cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求\r\n\r\n\t\t- 当客户端请求页面时，服务器会生成一个随机数Token，并且将Token放置到session当中，然后将Token发给客户端（一般通过构造hidden表单）。下次客户端提交请求时，Token会随着表单一起提交到服务器端。 \r\n\t\t- 然后，如果应用于"anti csrf攻击"，则服务器端会对Token值进行验证，判断是否和session中的Token值相等，若相等，则可以证明请求有效，不是伪造的。 \r\n\r\n\t- 2.检测referer\r\n\r\n\t\t- referer是什么？\r\n\r\n\t\t\t- 根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。通过 Referer Check，可以检查请求是否来自合法的"源"。\r\n\r\n\t\t- 场景\r\n\r\n\t\t\t- 比如，如果用户要删除自己的帖子，那么先要登录 www.c.com，然后找到对应的页面，发起删除帖子的请求。此时，Referer 的值是 http://www.c.com；当请求是从 www.a.com 发起时，Referer 的值是 http://www.a.com 了。因此，要防御 CSRF 攻击，只需要对于每一个删帖请求验证其 Referer 值，如果是以 www.c.com 开头的域名，则说明该请求是来自网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是 CSRF 攻击，可以拒绝该请求。\r\n\r\n\t\t- 代码\r\n\r\n\t\t\t- 针对上文的例子，可以在服务端增加如下代码：\r\n\r\n\t\t- 存在问题\r\n\r\n\t\t\t- 后台在进行删除操作之前先判断referer，如果不是本域的请求，则直接拒绝，这种做法很有效。但是，想想这样一个场景：如果博客允许评论里面插图，攻击者完全可以将 img插入到原网站中，这样refer还是在当下域名，博客依然会被删除。所有可能引入链接的html标签都是不可信的，如script、link，后台过滤策略一定要考虑到。\r\n\r\n\t- CSRF 防御主要是过滤那些非法伪造的请求来源。\r\n\r\n- （5）CSRF与AJAX的关系\r\n\r\n\t- 分析AJAX中带cookie验证的情况：\r\n\r\n\t\t- 1. AJAX受到浏览器的同源策略限制\r\n\t\t- 2. AJAX默认无法请求跨域的接口（当然后台可以配置`Access-Control-Allow-Origin: *`之类的允许所有的跨域请求）\r\n\t\t- 3. AJAX请求无法携带跨域cookie（如果强行开启withCredentials，必须服务端配合认证，无法用作攻击）\r\n\r\n\t- CSRF与AJAX无关\r\n\r\n',Zs={data:function(){return{MainComponent:Ys}}},ni=Zs,ti=Object(m["a"])(ni,Ks,Qs,!1,null,"45da2251",null),ri=ti.exports,ei=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},ai=[],oi="# 缓存\r\n## 缓存详解\r\n### （1）缓存的好处\r\n- 缓解服务器压力(不用每次去请求资源)；\r\n- 提升性能(打开本地资源速度当然比请求回来再打开要快得多)；\r\n- 减少带宽消耗；\r\n### （2）缓存的种类\r\n- 宏观分类\r\n\t- 私有缓存\r\n\t\t- 私有缓存就是用户专享的，各级代理不能缓存的缓存\r\n\t- 共享缓存\r\n\t\t- 共享缓存就是那些能被各级代理缓存的缓存\r\n- 微观分类\r\n\t- 1. 浏览器缓存\r\n\t\t- 浏览器缓存存在的意义就是当用户点击back按钮或是再次去访问某个页面的时候能够更快的响应。尤其是在多页应用的网站中，如果你在多个页面使用了一张相同的图片，那么缓存这张图片就变得特别的有用。\r\n\t- 2. 代理服务器缓存\r\n\t\t- 代理服务器缓存原理和浏览器端类似，但规模要大得多，因为是为成千上万的用户提供缓存机制，大公司和大型的ISP提供商通常会将它们设立在防火墙上或是作为一个独立的设备来运营。\r\n\t- 3. 网关缓存\r\n\t  CDNS(网络内容分发商)分布网关缓存到整个（或部分）互联网上，并出售缓存服务给需要的网站，比如国内的七牛云、又拍云都有这种服务。\r\n\t\t- 也被称为代理缓存或反向代理缓存，网关也是一个中间服务器，网关缓存一般是网站管理员自己部署，从让网站拥有更好的性能\r\n### （3）浏览器的缓存策略\r\n- 缓存的目标：\r\n\t- （1）一个检索请求的成功响应: \r\n\t\t- 对于 GET请求，响应状态码为：200，则表示为成功。一个包含例如HTML文档，图片，或者文件的响应；\r\n\t- （2）不变的重定向: \r\n\t\t- 响应状态码：301；\r\n\t- （3）可用缓存响应：响应状态码：\r\n\t\t- 304，这个存在疑问，Chrome会缓存304中的缓存设置，Firefox；\r\n\t- （4）错误响应: \r\n\t\t- 响应状态码：404 的一个页面；\r\n\t- （5）不完全的响应: \r\n\t\t- 响应状态码 206，只返回局部的信息；\r\n\t- （6）除了 GET 请求外，如果匹配到作为一个已被定义的cache键名的响应；\r\n- 浏览器怎么确定一个资源该不该缓存？\r\n\t- 浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。\r\n\t- 响应头！响应头！响应头！\r\n- 1.强缓存阶段\r\n\t- 浏览器第一次请求时\r\n\t\t- 这就是强缓存阶段，当浏览器再次试图访问这个CSS文件，发现有这个文件的缓存，那么就判断根据上一次的响应判断是否过期，如果没过期，使用缓存。加载文件，OVER！\r\n\t\t- 浏览器表现\r\n\t\t\t- Firefox浏览器表现为一个灰色的200状态码。Chrome浏览器状态码表现为:200 (from disk cache)或是200 OK (from memory cache)\r\n\t- 浏览器在请求某一资源时，会先获取该资源缓存的header信息，判断是否命中强缓存（cache-control和expires信息），若命中直接从缓存中获取资源信息，包括缓存header信息；本次请求根本就不会与服务器进行通信；\r\n\t- 强缓存如何重新加载缓存缓存过的资源\r\n\t  使用强缓存时，浏览器不会发送请求到服务端，根据设置的缓存时间浏览器一直从缓存中获取资源，在这期间若资源产生了变化，浏览器就在缓存期内就一直得不到最新的资源，那么如何防止这种事情发生呢？\r\n\t\t- 通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源。\r\n- 2.协商缓存阶段\r\n\t- 浏览器后续在进行请求时\r\n\t\t- 当响应过期了，ETag和Last-Modified就该闪亮登场了。Last-Modified，这个字段是文件最后一次修改的时间；ETag呢？ETag是对文件的一个标记\r\n\t- 利用这两个字段浏览器可以进入协商缓存阶段，当浏览器再次试图访问这个CSS文件，发现缓存过期，于是会在本次请求的请求头里携带If-Moified-Since和If-None-Match这两个字段（前者的值为上次响应的Last-Modified的时间，后者的值为上一次返回的ETag的值），服务器通过这两个字段来判断资源是否有修改，如果有修改则返回状态码200和新的内容，如果没有修改返回状态码304，浏览器收到200状态码，该咋处理就咋处理(相当于首次访问这个文件了)，发现返回304，于是知道了本地缓存虽然过期但仍然可以用，于是加载本地缓存。然后根据新的返回的响应头来设置缓存。\r\n\t- 注意：304和缓存的区别\r\n\t\t- 缓存不会发起请求了，直接从内存或者硬盘中获得\r\n\t\t- 304依然会发起请求与响应，只不过响应的第四部分不用再次下载了，因为没有更改，所以还是第一次下载的资源。\r\n## HTTP缓存\r\n### 前端缓存主要是分为HTTP缓存和浏览器缓存。其中HTTP缓存是在HTTP请求传输时用到的缓存，主要在服务器代码上设置；而浏览器缓存则主要由前端开发在前端js上进行设置。\r\n### 三 强制缓存\r\n- 强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种，如下：\r\n  > **①不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致），如下图：**\r\n  > **②存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存，如下图**\r\n  > **③存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果，如下图**\r\n  > **那么强制缓存的缓存规则是什么？**\r\n- 当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。\r\n- Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。\r\n- 到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义。\r\n- ①HTTP响应报文中expires的时间值，是一个绝对值\r\n- ②HTTP响应报文中Cache-Control为max-age=600，是相对值\r\n- 由于Cache-Control的优先级比expires高，那么直接根据Cache-Control的值进行缓存，意思就是说在600秒内再次发起该请求，则会直接使用缓存结果，强制缓存生效。\r\n- 在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于expires是更好的选择，所以同时存在时，只有Cache-Control生效。\r\n- from memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –> disk –> 服务器请求。\r\n- 那么接下来我们一起详细分析一下缓存读取问题，这里仍让以我的博客为例进行分析：\r\n- 在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。\r\n### 缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。\r\n### 四 协商缓存\r\n- ①协商缓存生效，返回304，\r\n- ②协商缓存失效，返回200和请求结果结果，\r\n- 同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。\r\n- Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间，如下。\r\n- If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件，如下。\r\n- Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，如下。\r\n- If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200，如下。\r\n- 注：Etag / If-None-Match优先级高于Last-Modified / If-Modified-Since，同时存在则只有Etag / If-None-Match生效。对于协商缓存，使用 Ctrl+F5强制刷新可以使得缓存无效。但是对于强缓存，在未过期时，必须更新资源路径才能发起新的请求（更改了路径相当于是另一个资源了，这也是前端工程化中常用到的技巧）。\r\n- 强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存，主要过程如下：\r\n### 二、缓存过程分析\r\n- 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识\r\n- 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中\r\n### 对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。\r\n缓存类型图解\r\n## https://www.jianshu.com/p/256d0873c398\r\n## 浏览器缓存 \r\n### 就是本地存储\r\n",si={data:function(){return{MainComponent:oi}}},ii=si,li=Object(m["a"])(ii,ei,ai,!1,null,"6c38415e",null),ci=li.exports,pi=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[n._v("\n   \n===\n  ")])},ui=[],mi={components:{},data:function(){return{}}},di=mi,gi=Object(m["a"])(di,pi,ui,!1,null,"99be2f7a",null),bi=gi.exports,hi={mixins:[k["c"]],components:{m1:_s,m2:Ms,m3:Ds,m4:qs,m5:Xs,m6:ri,m7:ci,m8:bi},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"前端性能监测方案",value:"m1"},{label:"算法",value:"m2"},{label:"调试",value:"m3"},{label:"性能",value:"m4"},{label:"现代前端技术解析",value:"m5"},{label:"安全",value:"m6"},{label:"缓存",value:"m7"}]}}},yi=hi,fi=Object(m["a"])(yi,gs,bs,!1,null,"71dc6027",null),vi=fi.exports,Si=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[r("div",[r(""+n.tab,{tag:"component"})],1)])},_i=[],ki=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}})],1)},ji=[],wi=' \r\n\r\n\r\n\r\n|                                                              |      |\r\n| ------------------------------------------------------------ | ---- |\r\n| [GitHub for Developers](https://githubtraining.github.io/training-manual/) |      |\r\n| [所有命令](https://git-scm.com/docs/git#_git_commands)       |      |\r\n|                                                              |      |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 安装\r\n\r\n### GitHub Desktop\r\n\r\n[desktop.github.com](https://desktop.github.com/)\r\n\r\n### Git 全平台版\r\n\r\n[git-scm.com](https://git-scm.com/)\r\n\r\n## 配置工具\r\n\r\n对所有本地仓库的用户信息进行配置\r\n\r\n```\r\n$ git config --global user.name "[name]"\r\n```\r\n\r\n对你的commit操作设置关联的用户名\r\n\r\n```\r\n$ git config --global user.email "[email address]"\r\n```\r\n\r\n对你的commit操作设置关联的邮箱地址\r\n\r\n```\r\n$ git config --global color.ui auto\r\n```\r\n\r\n启用有帮助的彩色命令行输出\r\n\r\n## 分支\r\n\r\n分支是使用 Git 工作的一个重要部分。你做的任何提交都会发生在当前“checked out”到的分支上。使用 `git status` 查看那是哪个分支。\r\n\r\n```\r\n$ git branch [branch-name]\r\n```\r\n\r\n创建一个新分支\r\n\r\n```\r\n$ git checkout [branch-name]\r\n```\r\n\r\n切换到指定分支并更新工作目录(working directory)\r\n\r\n```\r\n$ git merge [branch]\r\n```\r\n\r\n将指定分支的历史合并到当前分支。这通常在拉取请求(PR)中完成，但也是一个重要的 Git 操作。\r\n\r\n```\r\n$ git branch -d [branch-name]\r\n```\r\n\r\n删除指定分支\r\n\r\n## 创建仓库\r\n\r\n当着手于一个新的仓库时，你只需创建一次。要么在本地创建，然后推送到 GitHub；要么通过 clone 一个现有仓库。\r\n\r\n```\r\n$ git init\r\n```\r\n\r\n在使用过 `git init` 命令后，使用以下命令将本地仓库与一个 GitHub 上的空仓库连接起来：\r\n\r\n```\r\n$ git remote add origin [url]\r\n```\r\n\r\n将现有目录转换为一个 Git 仓库\r\n\r\n```\r\n$ git clone [url]\r\n```\r\n\r\nClone（下载）一个已存在于 GitHub 上的仓库，包括所有的文件、分支和提交(commits)\r\n\r\n## .gitignore 文件\r\n\r\n有时一些文件最好不要用 Git 跟踪。这通常在名为 `.gitignore` 的特殊文件中完成。你可以在 [github.com/github/gitignore](https://github.com/github/gitignore) 找到有用的 `.gitignore` 文件模板。\r\n\r\n## 同步更改\r\n\r\n将你本地仓库与 GitHub.com 上的远端仓库同步\r\n\r\n```\r\n$ git fetch\r\n```\r\n\r\n下载远端跟踪分支的所有历史\r\n\r\n```\r\n$ git merge\r\n```\r\n\r\n将远端跟踪分支合并到当前本地分支\r\n\r\n```\r\n$ git push\r\n```\r\n\r\n将所有本地分支提交上传到 GitHub\r\n\r\n```\r\n$ git pull\r\n```\r\n\r\n使用来自 GitHub 的对应远端分支的所有新提交更新你当前的本地工作分支。`git pull` 是 `git fetch` 和 `git merge` 的结合\r\n\r\n## 进行更改\r\n\r\n浏览并检查项目文件的发展\r\n\r\n```\r\n$ git log\r\n```\r\n\r\n列出当前分支的版本历史\r\n\r\n```\r\n$ git log --follow [file]\r\n```\r\n\r\n列出文件的版本历史，包括重命名\r\n\r\n```\r\n$ git diff [first-branch]...[second-branch]\r\n```\r\n\r\n展示两个分支之间的内容差异\r\n\r\n```\r\n$ git show [commit]\r\n```\r\n\r\n输出指定commit的元数据和内容变化\r\n\r\n```\r\n$ git add [file]\r\n```\r\n\r\n将文件进行快照处理用于版本控制\r\n\r\n```\r\n$ git commit -m "[descriptive message]"\r\n```\r\n\r\n将文件快照永久地记录在版本历史中\r\n\r\n## 重做提交\r\n\r\n清除错误和构建用于替换的历史\r\n\r\n```\r\n$ git reset [commit]\r\n```\r\n\r\n撤销所有 `[commit]` 后的的提交，在本地保存更改\r\n\r\n```\r\n$ git reset --hard [commit]\r\n```\r\n\r\n放弃所有历史，改回指定提交。',xi={data:function(){return{MainComponent:wi,img_prefix:"./img/linux/heima-Linux云计算/讲义/"}},methods:{extendMarkdown:function(n){var t=this;console.log(n.renderer.rules);var r=n.renderer.rules.html_block;n.renderer.rules.html_block=function(n,e,a,o,s){var i=n[e];if(console.log("1"),i.content.includes("<img")){console.log("token-- ",i);var l="";l=i.content;var c=l.split('src="'),p=c[0]+' src="'+t.img_prefix+c[1];i.content=p}return i.attrSet("class","q-markdown--token  "),r(n,e,a,o,s)},n.renderer.rules.image=function(n,r,e,a,o){var s=n[r];console.log("3"),s.attrSet("class","q-markdown--image"),console.log("token--- "+r+"-----",s);var i=s.attrGet("src");return console.log(i),s.attrSet("src",t.img_prefix+i),o.renderToken(n,r,e)}}}},Ti=xi,Ci=Object(m["a"])(Ti,ki,ji,!1,null,"0a636dcc",null),Mi=Ci.exports,Pi=function(){var n=this;return n.$createElement,n._self._c,n._m(0)},Oi=[function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[r("h1",[n._v("webpack")]),r("h2",[n._v("Webpack4.0")]),r("h3",[n._v("Webpack初探")]),r("ul",[r("li",[r("p",[n._v("webpack安装方式")]),r("ul",[r("li",[n._v("全局安装：npm install webpack -g")]),r("li",[n._v("局部安装：npm instatll webpack -D")]),r("li",[n._v("安装指定版本：npm intatll webpack@版本号")])])]),r("li",[r("p",[n._v("webpack配置")]),r("ul",[r("li",[r("p",[n._v("默认配置文件webpack.config.js")]),r("ul",[r("li",[n._v("node核心模块path")]),r("li",[n._v("局部安装运行打包，npx webpack")]),r("li",[n._v("// 文件内容\nconst path = require('path');\nmodule.exports = {\nentry: './index.js',\noutput: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'bundle')\n}\n}")])])]),r("li",[r("p",[n._v("以webpackconfig.js为配置文件进行打包： npx webpack --config webpackconfig.js")])]),r("li",[r("p",[n._v("运行webpack")]),r("ul",[r("li",[n._v("全局安装时，webpack index.js")]),r("li",[n._v("局部安装时，npx webpack index.js")]),r("li",[n._v("在package.json的scripts中简化打包命令后，npm run bundle -> webpack")])])]),r("li",[r("p",[n._v("webpack-cli作用：在命令行中使用webpack")])])])]),r("li",[r("p",[n._v("浅析webpack打包输出内容")]),r("ul",[r("li",[r("p",[n._v("在配置文件中，增加mode配置")]),r("ul",[r("li",[n._v("mode为production时，打包文件压缩")]),r("li",[n._v("mode为development时，打包文件不压缩")]),r("li",[n._v("mode默认为production，配置文件中没有mode配置，打包代码时会出现警告")])])])])])]),r("h3",[n._v("Webpack的核心概念")]),r("ul",[r("li",[r("p",[n._v("loader预处理文件，可以打包除js之外的任何静态资源")]),r("ul",[r("li",[r("p",[n._v("打包图片资源")]),r("ul",[r("li",[r("p",[n._v("file-loader")]),r("ul",[r("li",[r("p",[n._v("配置项：options")]),r("ul",[r("li",[n._v("name")]),r("li",[n._v("outputPath")])])]),r("li",[r("p",[n._v("占位符：placeholders")]),r("ul",[r("li",[n._v("文件名称：[name]")]),r("li",[n._v("文件后缀：[ext]")]),r("li",[n._v("hash值：[hash]")])])])])]),r("li",[r("p",[n._v("url-loader")]),r("ul",[r("li",[n._v("与file-loader功能类似")]),r("li",[n._v("比file-loader多一个limit配置项，大于limit值，与file-loader功能一样单独打包；小于limit值，以base64形式打包进js文件")])])])])]),r("li",[r("p",[n._v("打包样式资源")]),r("ul",[r("li",[r("p",[n._v("style-loader")]),r("ul",[r("li",[n._v("将JS字符串生成为style节点")])])]),r("li",[r("p",[n._v("css-loader")]),r("ul",[r("li",[r("p",[n._v("作用：将CSS转化成CommonJS模块")])]),r("li",[r("p",[n._v("options")]),r("ul",[r("li",[n._v("局部作用域css：modules")]),r("li",[n._v("在css-loader前应用的loader的数量：importLoaders")])])])])]),r("li",[r("p",[n._v("postcss-loader")])]),r("li",[r("p",[n._v("sass-loader")]),r("ul",[r("li",[n._v("将Sass编译成CSS")])])]),r("li",[r("p",[n._v("less-loader")]),r("ul",[r("li",[n._v("将Less编译成CSS")])])])])]),r("li",[r("p",[n._v("打包字体资源")]),r("ul",[r("li",[n._v("file-loader")])])])])]),r("li",[r("p",[n._v("plugins可以在webpack运行到某个时刻的时候，帮你做一些事情")]),r("ul",[r("li",[n._v("htmlWebpackPlugin会在打包结束后，自动生成一个html文件，并把打包生成的js自动引入到这个html文件中")]),r("li",[n._v("cleanWebpackPlugin在打包之前删除打包输出文件夹（dist）")]),r("li",[n._v("学习plugin：谷歌或百度所需功能需要使用plugin，查找相关api学习使用")])])]),r("li",[r("p",[n._v("entry与output")]),r("ul",[r("li",[r("p",[n._v("entry")]),r("ul",[r("li",[n._v("{\nmain: './src/index.js',\nsub: './src/index.js'\n}")])])]),r("li",[r("p",[n._v("output")]),r("ul",[r("li",[n._v("filename：'[name].js'，占位符[name]表示输出文件名称与entry的key值一致")]),r("li",[n._v("publicPath：指定在浏览器中引用时输出目录的公共url，如"),r("a",{staticClass:"url",attrs:{href:"http://www.cdn.com/main.js",target:"_blank"}},[n._v("http://www.cdn.com/main.js")]),n._v("，"),r("a",{staticClass:"url",attrs:{href:"http://www.cdn.com/sub.js",target:"_blank"}},[n._v("http://www.cdn.com/sub.js")])])])])])]),r("li",[r("p",[n._v("sourceMap映射打包文件与原始文件关系")]),r("ul",[r("li",[n._v("devtool: 'none'，有错误信息时显示在dist文件夹下文件中的报错位置")]),r("li",[n._v("devtool: 'source-map'，生成映射关系文件，有错误信息时显示在源文件中的报错位置")]),r("li",[n._v("devtool: 'inline-source-map'，在打包文件最后生成映射关系字符串")]),r("li",[n._v("devtool: 'cheap-module-eval-source-map'（devlopment环境使用）")]),r("li",[n._v("devtool: 'cheap-module-source-map'（production环境使用）")])])]),r("li",[r("p",[n._v("WebpackDevServer提升开发效率")]),r("ul",[r("li",[r("p",[n._v("webpack --watch   监控到webpack打包代码变化，自动执行打包过程，不会起一个服务器，不能进行ajax调试，不能自动打开浏览器")])]),r("li",[r("p",[n._v("安装webpack-dev-server模块")])]),r("li",[r("p",[n._v("webpack-dev-server --open     启动服务器，监听代码变化，自动刷新浏览器")])]),r("li",[r("p",[n._v("不用WebpackDevServer，使用webpack-dev-middleware配合express自己写WebpackDevServer")])]),r("li",[r("p",[n._v("使用webpack的两种方式")]),r("ul",[r("li",[n._v("在node中使用webpack")]),r("li",[n._v("在命令行中使用webpack")])])])])]),r("li",[r("p",[n._v("Hot Module Replacement")]),r("ul",[r("li",[n._v("在devServer中设置hot，hotOnly")]),r("li",[n._v("在plugins中引入HotModuleReplacementPlugin")]),r("li",[n._v("要通过import引入文件，通过require引入文件HMR失效")]),r("li",[n._v("module.hot.accept")])])]),r("li",[r("p",[n._v("使用Babel处理ES6语法")]),r("ul",[r("li",[r("p",[n._v("babel官网："),r("a",{staticClass:"url",attrs:{href:"https://babeljs.io",target:"_blank"}},[n._v("https://babeljs.io")])])]),r("li",[r("p",[n._v("Setup中查找webpack，参照文档在webpack中使用babel")])]),r("li",[r("p",[n._v("将ES6转成ES5")]),r("ul",[r("li",[r("p",[n._v("业务代码引入polyfill")]),r("ul",[r("li",[n._v("在Docs中找到polyfill，参照文档引入polyfill")]),r("li",[n._v("在presets中使用配置useBuiltIns: 'usage'，根据需要引入polyfill内容")])])]),r("li",[r("p",[n._v("在库项目代码/类库中使用transform-runtime，避免polyfill问题，polyfill污染全局环境，plugin-transform-runtime以闭包形式注入/间接帮助组件引入对应内容，不存在全局污染概念")])])])])])])]),r("h3",[n._v("Webpack的高级概念")]),r("ul",[r("li",[r("p",[n._v("Tree Shaking")]),r("ul",[r("li",[r("p",[n._v("引入模块时，不引入所有代码，只引入需要代码")])]),r("li",[r("p",[n._v("只支持ES Module引入")])]),r("li",[r("p",[n._v("模式")]),r("ul",[r("li",[r("p",[n._v("development")]),r("ul",[r("li",[n._v("// webpack.config.js中配置\noptimization: {\nusedExports: true\n}")]),r("li",[n._v('// pacakge.js中配置\n"sideEffects": false')])])]),r("li",[r("p",[n._v("production")]),r("ul",[r("li",[n._v("// webpack.config.js中修改配置\ndevtool: 'cheap-module-source-map'")]),r("li",[n._v('// pacakge.js中配置\n"sideEffects": false')])])])])])])]),r("li",[r("p",[n._v("Development和Production模式的区分打包")]),r("ul",[r("li",[n._v("根据开发环境与生产环境创建不同配置文件，提取公共文件")]),r("li",[n._v("webpack-merge模块合并公共配置文件与不同模式文件")])])]),r("li",[r("p",[n._v("Webpack 和Code Splitting")]),r("ul",[r("li",[r("p",[n._v("同步代码分割：optimization配置")])]),r("li",[r("p",[n._v("异步代码分割")]),r("ul",[r("li",[n._v("安装模块：babel-plugin-dynamic-import-webpack")]),r("li",[n._v('.babelrc中配置：plugins: ["dynamic-import-webpack"]')])])])])]),r("li",[r("p",[n._v("SplitChunksPlugin配置参数详解")])]),r("li",[r("p",[n._v("Lazy Loading懒加载")])])]),r("h2",[n._v("Webpack 4.0基本配置")]),r("h3",[n._v("entry")]),r("ul",[r("li",[r("p",[n._v("作用：指示webpack应该使用哪个模块，来作为构建其内部依赖图的开始")])]),r("li",[r("p",[n._v("配置")]),r("ul",[r("li",[r("p",[n._v("单入口")])]),r("li",[r("p",[n._v("多入口")]),r("ul",[r("li",[n._v("entry")]),r("li",[n._v("new HtmlWebpackPlugin()")])])])])])]),r("h3",[n._v("output")]),r("ul",[r("li",[r("p",[n._v("作用：output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件")])]),r("li",[r("p",[n._v("配置")]),r("ul",[r("li",[r("p",[n._v("path : 想要bundle生成到哪里")]),r("ul",[r("li",[n._v("原理：path模块是一个Node.js核心模块，用于操作文件路径")])])]),r("li",[r("p",[n._v("filename:告诉webpack bundle的名称")])])])]),r("li",[r("p",[n._v("常见使用场景")]),r("ul",[r("li",[r("p",[n._v("自动生成引用所有打包完的output JS的HTML入口文件")]),r("ul",[r("li",[n._v("html-webpack-plugin")])])]),r("li",[r("p",[n._v("清除打包文件")]),r("ul",[r("li",[n._v("clean-webpack-plugin")])])])])])]),r("h3",[n._v("loader")]),r("ul",[r("li",[r("p",[n._v("作用：让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）")])]),r("li",[r("p",[n._v("配置")]),r("ul",[r("li",[n._v("test：用于标识出应该被对应的 loader 进行转换的某个或某些文件")]),r("li",[n._v("use : 表示进行转换时，应该使用哪个 loader")])])]),r("li",[r("p",[n._v("常见使用场景")]),r("ul",[r("li",[r("p",[n._v("加载 CSS")]),r("ul",[r("li",[r("p",[n._v("style-loader")]),r("ul",[r("li",[n._v("将所有的样式嵌入到dom的style属性当中")])])]),r("li",[r("p",[n._v("css-loader")]),r("ul",[r("li",[n._v("将css当中的 @import 和 url(...) 解析成 import / require 引入")])])]),r("li",[r("p",[n._v("sass-loader")]),r("ul",[r("li",[n._v("将代码sass编译成css")])])])])]),r("li",[r("p",[n._v("加载图片/字体")]),r("ul",[r("li",[n._v("file-loader")])])]),r("li",[r("p",[n._v("加载数据文件（(JSON, CSV, TSV, XML）")]),r("ul",[r("li",[n._v("csv-loader（csv|tsv）")]),r("li",[n._v("xml-loader（xml）")])])])])])]),r("h3",[n._v("plugins")]),r("ul",[r("li",[r("p",[n._v("作用：插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。")])]),r("li",[r("p",[n._v("配置")]),r("ul",[r("li",[r("p",[n._v("plugins：想使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中")]),r("ul",[r("li",[n._v("new : 通过new操作符来创建一个插件的实例  如 ： new HtmlWebpackPlugin({template: './src/index.html'})")]),r("li",[n._v("option : 多数插件可以通过选项(option)来自定义   如：new webpack.optimize.UglifyJsPlugin()")])])])])])]),r("h3",[n._v("mode")]),r("ul",[r("li",[r("p",[n._v("作用：设置mode参数，来启用相应模式下的webpack内置的优化")])]),r("li",[r("p",[n._v("配置")]),r("ul",[r("li",[n._v("development")]),r("li",[n._v("production")])])])]),r("h3",[n._v("devtool")]),r("ul",[r("li",[r("p",[n._v("常见使用场景")]),r("ul",[r("li",[r("p",[n._v("找到报错源文件的位置")]),r("ul",[r("li",[n._v("inline-source-map")])])]),r("li",[r("p",[n._v("webpack自动重新编译修改后的模块,但是要手动刷新页面")]),r("ul",[r("li",[n._v("webpack --watch")])])]),r("li",[r("p",[n._v("实时重新加载(live reloading)")]),r("ul",[r("li",[n._v("webpack-dev-server")])])])])])]),r("h3",[n._v("devServer")]),r("h2",[n._v("Webpack核心概念")]),r("h3",[n._v("核心概念")]),r("ul",[r("li",[r("p",[n._v("Webpack 启动后会从 Entry 里配置的 Module 开始递归解析 Entry 依赖的所有 Module。 每找到一个 Module， 就会根据配置的Loader去找出对应的转换规则，对 Module 进行转换后，再解析出当前 Module 依赖的 Module。 这些模块会以 Entry 为单位进行分组，一个 Entry 和其所有依赖的 Module 被分到一个组也就是一个 Chunk。最后 Webpack 会把所有 Chunk 转换成文件输出。 在整个流程中 Webpack 会在恰当的时机执行 Plugin 里定义的逻辑。")])]),r("li",[r("p",[n._v("Entry")]),r("ul",[r("li",[n._v("入口，webpack执行构建的第一步将从Entry开始，可抽象理解为输入")])])]),r("li",[r("p",[n._v("Module")]),r("ul",[r("li",[n._v("模块，在webpacl中一切皆为模块，一个模块对应一个文件，webpack会从配置的Entry开始递归找出所有依赖的模块")])])]),r("li",[r("p",[n._v("Chunk")]),r("ul",[r("li",[n._v("代码块，一个chunk由多个模块组合而成，用于将代码合并和分割")])])]),r("li",[r("p",[n._v("Loader")]),r("ul",[r("li",[n._v("模块转换器，用于把模块原内容按照需求转换为需要的新内容")])])]),r("li",[r("p",[n._v("Plugin")]),r("ul",[r("li",[n._v("扩展插件，在webpack构建流程中的特定时机注入扩展逻辑来改变构建结果和想要做的事情")])])]),r("li",[r("p",[n._v("Output")]),r("ul",[r("li",[n._v("输入结果，在webpack经过一系列处理并得到最终想要的代码然后输出结果")])])])]),r("h3",[n._v("详细拆分")]),r("ul",[r("li",[r("p",[n._v("1.Entry")]),r("ul",[r("li",[r("p",[n._v("context")]),r("ul",[r("li",[n._v("用来解决配置文件和入口文件不再同一层结构，列如我们配置文件在config，入口文件在根目录，则如下配置")])])]),r("li",[r("p",[n._v("单页面(SPA)Entry入口")]),r("ul",[r("li",[n._v("最简单的单页面(SPA)Entry入口，将main.js引入，并根据main.js中引用和依赖的模块开始解析")])])]),r("li",[r("p",[n._v("多页面(MPA)Entry入口")]),r("ul",[r("li",[n._v("多页面(MPA)Entry入口，将多个文件引入，当然一般是读取指定文件夹内的入口文件，然后引入")]),r("li",[n._v("如果是单页面(传入的是字符串或字符串数组)，则chunk会被命名为main，如果是多页面(传入一个对象)，则每个键(key)会是chunk的名称，描述了chunk的入口起点")])])])])]),r("li",[r("p",[n._v("2.Output")]),r("ul",[r("li",[r("p",[n._v("初步了解")]),r("ul",[r("li",[n._v("Object类型， 指示webpack如何去输出，以及在哪里输出你的bundle、asset 和其他你所打包或使用 webpack 载入的任何内容")])])]),r("li",[r("p",[n._v("path")]),r("ul",[r("li",[n._v("输出目录对应一个绝对路径")])])]),r("li",[r("p",[n._v("pathinfo")]),r("ul",[r("li",[n._v("boolean类型， 默认false，作用是告诉webpack在bundle中引入所包含模块信息的相关注释，不应用于生产环境(production)，对开发环境(development)极其有用")])])]),r("li",[r("p",[n._v("publicPath")]),r("ul",[r("li",[n._v("主要作用是针对打包后的文件里面的静态文件路径处理")])])]),r("li",[r("p",[n._v("filename")]),r("ul",[r("li",[r("p",[n._v("定义每个输出bundle的名称，这些bundle将写入output.path选项指定的目录下")])]),r("li",[r("p",[n._v("（1）单入口")]),r("ul",[r("li",[n._v("对于单入口Entry，filename是一个静态名称")])])]),r("li",[r("p",[n._v("（2）多入口")]),r("ul",[r("li",[n._v("但是在webpack中我们会用到代码拆分、各种插件plugin或多入口Entry创建多个bundle，这样我们就应该给每个bundle一个唯一的名称")])])]),r("li",[r("p",[n._v("（3）使用内部chunk id")])]),r("li",[r("p",[n._v("（4）唯一hash生成")])]),r("li",[r("p",[n._v("（5）使用基于每个 chunk 内容的 hash")])])])])])]),r("li",[r("p",[n._v("3.Module模块")]),r("ul",[r("li",[r("p",[n._v("初步了解")]),r("ul",[r("li",[n._v("处理项目中应用的不同模块，主要配置皆在Rules中，匹配到请求的规则数组，这些规则能够对模块应用loader，或者修改解析器parser")])])]),r("li",[r("p",[n._v("Module.noParse")]),r("ul",[r("li",[n._v("防止webpack解析的时候，将规则匹配成功的文件进行解析和忽略大型的library来对性能的优化，在被忽略的文件中不应该含有import、require和define的调用")])])]),r("li",[r("p",[n._v("Rules")]),r("ul",[r("li",[r("p",[n._v("创建模块时，匹配请求的规则数组")])]),r("li",[r("p",[n._v("Rule条件")]),r("ul",[r("li",[r("p",[n._v("resource(请求文件的绝对路径)、issuer(被请求资源的模块文件的绝对路径，导入时的位置)，比如一个文件A导入文件B，resource是/B，issuer是/A是导入文件时的位置，而不是真正的位置，在规则中，test/include/exclude/resource对resource匹配，而issuer只对issuer匹配")])]),r("li",[r("p",[n._v("Test/include/exclude/resource/issuer的用法和区别")]),r("ul",[r("li",[n._v("代码")]),r("li",[n._v("test：一般是提供一个正则表达式或正则表达式的数组，绝对路径符合这个正则的则意味着满足这个条件")]),r("li",[n._v("include：是一个字符串或者字符串数组，指定目录中的文件需要走这个规则")]),r("li",[n._v("exclude：同样是一个字符串或者字符串数组，指定目录中的文件不需要走这个规则")]),r("li",[n._v("resource：就是对text/include/exclude的一个对象包装，和他们单独写没有区别")]),r("li",[n._v("issuer：和resource有异曲同工的作用，不过区别在于它是将这个rule应用于哪个文件以及这个文件所导入的所有依赖文件")])])])])]),r("li",[r("p",[n._v("额外选项")]),r("ul",[r("li",[r("p",[n._v("resourceQuery")]),r("ul",[r("li",[n._v("和resource用法一样，不过针对的是匹配结果'?'后面的路径参数，可以调用resource中的text等")])])]),r("li",[r("p",[n._v("oneOf")]),r("ul",[r("li",[n._v("表示对该资源只应用第一个匹配的规则，一般结合resourceQuery")]),r("li",[n._v("path/to/foo.png?inline: 会匹配url-loader")]),r("li",[n._v("path/to/foo.png?other:会匹配file-loader")]),r("li",[n._v("path/to/foo.png: 会匹配file-loader")])])]),r("li",[r("p",[n._v("useEntry")]),r("ul",[r("li",[n._v("object类型，包含着每一个loader并且对应loader的配置文件")]),r("li",[n._v("options会传入loader，可以理解为loader的选项")])])]),r("li",[r("p",[n._v("use")]),r("ul",[r("li",[n._v("是对useEntry的集合，并且对每一个入口指定使用一个loader")])])])])])])])])]),r("li",[r("p",[n._v("4.Resolve解析")]),r("ul",[r("li",[r("p",[n._v("初步了解")]),r("ul",[r("li",[n._v("主要用来模块如何被解析，给webpack提供默认值")])])]),r("li",[r("p",[n._v("alias")]),r("ul",[r("li",[n._v("object类型，主要用来让import和require调用更方便，设置初始路径")])])]),r("li",[r("p",[n._v("enforceExtension")]),r("ul",[r("li",[n._v("Boolean类型， 默认false，表示引用不需要扩展名，为true时，import、require中引用必须加扩展名")])])]),r("li",[r("p",[n._v("extensions")]),r("ul",[r("li",[n._v("Array 自动解析不需要扩展名")])])]),r("li",[r("p",[n._v("modules")]),r("ul",[r("li",[n._v("Array webpack解析模块的时候需要搜索的目录，一般用于优先搜索和非node_modules文件中的自定义模块")])])])])]),r("li",[r("p",[n._v("5.Loader")]),r("ul",[r("li",[r("p",[n._v("概述")]),r("ul",[r("li",[n._v("通过使用不同的Loader，Webpack可以要把不同的文件都转成JS文件,比如CSS、ES6/7、JSX等，一般用于module的use中")])])])])]),r("li",[r("p",[n._v("6.Plugin插件")]),r("ul",[r("li",[n._v("Array 扩展webpack，在webpack构建流程中的特定时机注入扩展逻辑来改变构建结果和想要做的事情")])])]),r("li",[r("p",[n._v("7.webpack-dev-server")]),r("ul",[r("li",[n._v("开发中的server，webpack-dev-server可以快速搭建起本地服务，具体使用查看 webpack-dev-server")])])]),r("li",[r("p",[n._v("8.Devtool")]),r("ul",[r("li",[n._v("此选项控制是否生成，以及如何生成，官方推荐 SourceMapDevToolPlugin 和 source-map-loader 建议看官方文档 Devtool 主要用来控制打包品质和在dev环境的调试便捷度和编译的快慢")])])]),r("li",[r("p",[n._v("9.Watch")]),r("ul",[r("li",[n._v("webpack 可以监听文件变化，当它们修改后会重新编译和 HotModuleReplacementPlugin 有相似之处，监听文件变动热启动")])])])]),r("h2",[n._v("Webpack深入执行原理")]),r("h3",[n._v("（1）Webpack运行机制")]),r("ul",[r("li",[r("p",[n._v("运行过程")]),r("ul",[r("li",[n._v("初始化配置参数 -> 绑定事件钩子回调 -> 确定Entry逐一遍历 -> 使用loader编译文件 -> 输出文件")])])]),r("li",[r("p",[n._v("Webpack事件流")]),r("ul",[r("li",[r("p",[n._v("生产线")]),r("ul",[r("li",[n._v("Webpack 通过 Tapable 来组织这条复杂的生产线。 Webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条生产线中，去改变生产线的运作。 Webpack 的事件流机制保证了插件的有序性，使得整个系统扩展性很好。")]),r("li",[n._v("Webpack 就像一条生产线，要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的，多个流程之间有存在依赖关系，只有完成当前处理后才能交给下一个流程去处理。 插件就像是一个插入到生产线中的一个功能，在特定的时机对生产线上的资源做处理。")])])]),r("li",[r("p",[n._v("事件流")]),r("ul",[r("li",[n._v("我们将webpack事件流理解为webpack构建过程中的一系列事件，他们分别表示着不同的构建周期和状态，我们可以像在浏览器上监听click事件一样监听事件流上的事件，并且为它们挂载事件回调。我们也可以自定义事件并在合适时机进行广播，这一切都是使用了webpack自带的模块 Tapable 进行管理的。我们不需要自行安装 Tapable ，在webpack被安装的同时它也会一并被安装，如需使用，我们只需要在文件里直接 require 即可。")])])]),r("li",[r("p",[n._v("Tapable")]),r("ul",[r("li",[n._v("Tapable的原理其实就是我们在前端进阶过程中都会经历的EventEmit，通过发布者-订阅者模式实现")])])])])]),r("li",[r("p",[n._v("Webpack运行流程详解")]),r("ul",[r("li",[r("p",[n._v("总结图")])]),r("li",[r("p",[n._v("（1）初始化参数，绑定回调")]),r("ul",[r("li",[n._v("首先，webpack会读取你在命令行传入的配置以及项目里的 webpack.config.js 文件，初始化本次构建的配置参数，并且执行配置文件中的插件实例化语句，生成Compiler传入plugin的apply方法，为webpack事件流挂上自定义钩子。")])])]),r("li",[r("p",[n._v("（2）遍历入口")]),r("ul",[r("li",[n._v("webpack开始读取配置的Entries，递归遍历所有的入口文件")])])]),r("li",[r("p",[n._v("（3）使用loader编译文件")]),r("ul",[r("li",[n._v("Webpack进入其中一个入口文件，开始compilation过程。先使用用户配置好的loader对文件内容进行编译（buildModule），我们可以从传入事件回调的compilation上拿到module的resource（资源路径）、loaders（经过的loaders）等信息；之后，再将编译好的文件内容使用acorn解析生成AST静态语法树（normalModuleLoader），分析文件的依赖关系逐个拉取依赖模块并重复上述过程，最后将所有模块中的require语法替换成"),r("strong",[n._v("webpack_require")]),n._v("来模拟模块化操作。")])])]),r("li",[r("p",[n._v("（4）输出文件")]),r("ul",[r("li",[n._v("emit阶段，所有文件的编译及转化都已经完成，包含了最终输出的资源，我们可以在传入事件回调的compilation.assets 上拿到所需数据，其中包括即将输出的资源、代码块Chunk等等信息。")])])]),r("li",[r("p",[n._v("【AST】什么是AST？")]),r("ul",[r("li",[r("p",[n._v("定义")]),r("ul",[r("li",[n._v("是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。比如，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现；而类似于 if-condition-then 这样的条件跳转语句，可以使用带有两个分支的节点来表示。")])])]),r("li",[r("p",[n._v("例子")])]),r("li",[r("p",[n._v("目的")]),r("ul",[r("li",[n._v("转换成AST的目的就是将我们书写的字符串文件转换成计算机更容易识别的数据结构，这样更容易提取其中的关键信息，而这棵树在计算机上的表现形式，其实就是一个单纯的Object。")])])]),r("li",[r("p",[n._v("计算机眼中的语句")]),r("ul",[r("li",[n._v("示例是一个简单的声明赋值语句，经过AST转化后各部分内容的含义就更为清晰明了了。")])])])])])])]),r("li",[r("p",[n._v("webpack输出结果解析")]),r("ul",[r("li",[r("p",[n._v("未设置splitChuck")]),r("ul",[r("li",[n._v("如果我们没有设置splitChunk，我们只会在dist目录下看到一个main.js输出文件，过滤掉没用的注释还有一些目前不需要去考虑的Funciton，得到的代码大概是这样")]),r("li",[n._v("我们都知道其实webpack在浏览器实现模块化的本质就是将所有的代码都注入到同一个JS文件里，现在我们可以清晰明了地看出webpack最后生成的也不过只是一个IIFE，我们引入的所有模块都被一个function给包起来组装成一个对象，这个对象作为IIFE的实参被传递进去。")])])]),r("li",[r("p",[n._v("设置splitChuck")]),r("ul",[r("li",[n._v("如果我们配置了splitChunk，这时候输出的文件就和你的Chunk挂钩了")]),r("li",[n._v("这时候，IIFE的形参也变成了摆设，所有我们的模块都被放在了一个名为 webpackJsonp 的全局数组上，通过IIFE里的 webpackJsonpCallback 来处理数据。")])])])])]),r("li",[r("p",[n._v("总结")]),r("ul",[r("li",[n._v("纵观webpack构建流程，我们可以发现整个构建过程主要花费时间的部分也就是递归遍历各个entry然后寻找依赖逐个编译的过程，每次递归都需要经历 String->AST->String 的流程，经过loader还需要处理一些字符串或者执行一些JS脚本，介于node.js单线程的壁垒，webpack构建慢一直成为它饱受诟病的原因。")]),r("li",[n._v("利用了node.js原生的cluster模块去开辟多进程执行构建，不过在4之后大家就可以不用去纠结这一问题了，多进程构建已经被集成在webpack本身上了，除了增量编译，这也是4之所以能大幅度提升构建效率的原因之一。")])])])]),r("h3",[n._v("（2）编写自定义webpack loader")]),r("ul",[r("li",[r("p",[n._v("在Webpack中起编译作用的是loader")]),r("ul",[r("li",[n._v("在你不知道loader的本质之前你一定会觉得这是个很高大上的东西，正如计算机学科里的编译原理一样，里面一定有许多繁杂的操作。但实际上，loader只是一个普通的funciton，他会传入匹配到的文件内容(String)，你只需要对这些字符串做些处理就好了。")])])]),r("li",[r("p",[n._v("一个最简单的loader实例")]),r("ul",[r("li",[r("p",[n._v("代码")])]),r("li",[r("p",[n._v("使用")]),r("ul",[r("li",[n._v("使用它的方式和babel-loader一样，只需要在webpack.config.js的module.rules数组里加上这么一个对象就好了")])])]),r("li",[r("p",[n._v("效果")]),r("ul",[r("li",[n._v("这样，loader会去匹配所有以.js后缀结尾的文件并在内容前追加{};这样一段代码，我们可以在输出文件中看到效果")]),r("li",[n._v("所以，拿到了文件内容，你想对字符串进行怎样得处理都由你自定义～你可以引入babel库加个 babel(content) ，这样就实现了编译，也可以引入uglifyjs对文件内容进行字符串压缩，一切工作都由你自己定义。")])])])])])]),r("h3",[n._v("（3）编写自定义webpack plugin")]),r("ul",[r("li",[r("p",[n._v("Webpack plugin起到的作用，就是为Webpack Hook事件挂载回调，或者执行指定脚本。它实际上和webpack loader一样简单，其实它只是一个带有apply方法的class。")])]),r("li",[r("p",[n._v("一个简单的plugin实例")]),r("ul",[r("li",[r("p",[n._v("代码")])]),r("li",[r("p",[n._v("使用")]),r("ul",[r("li",[n._v("只需要在webpack.config.js 里 require 并实例化就可以了")])])]),r("li",[r("p",[n._v("理解")]),r("ul",[r("li",[n._v("每次我们需要使用某个plugin的时候都需要new一下实例化，自然，实例过程中传递的参数，也就成为了我们的构造函数里拿到的options了")]),r("li",[n._v("而实例化所有plugin的时机，便是在webpack初始化所有参数的时候，也就是事件流开始的时候。所以，如果配合 shell.js 等工具库，我们就可以在这时候执行文件操作等相关脚本，这就是webpack plugin所做的事情。")]),r("li",[n._v("如果你想在指定时机执行某些脚本，自然可以使用在webpack事件流上挂载回调的方法，在回调里执行你所需的操作。")])])])])])])])}],Ei={},Ri=Ei,Ni=Object(m["a"])(Ri,Pi,Oi,!1,null,"9a34df30",null),Ai=Ni.exports,Di=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent}})],1)},Ii=[],Ji="# nginx\r\n\r\n## 正向代理与反向代理\r\n\r\n### 同域的要求\r\n\r\n- 1.协议相同\r\n- 2.域名相同\r\n- 3.端口相同\r\n\r\n### 正向代理与反向代理\r\n\r\n- 正向代理\r\n\r\n\t- 解释\r\n\r\n\t\t- 意思是一个位于客户端和目标服务器(target server)之间的服务器，为了从目标服务器取得内容，客户端向代理发送一个请求并指定目标(目标服务器)，然后代理向目标服务器转交请求并将获得的内容返回给客户端。\r\n\r\n\t- 通俗地说\r\n\r\n\t\t- 「客户端」可以看作一个黑社会大佬，「目标服务器」可以看作一家饭店，「代理服务器」可以看作小弟。\r\n\t\t- 「老大」想吃饭店的酱排骨饭，就让「小弟」去买，「小弟」跑到「饭店」要个酱排骨饭。\r\n\t\t- 「饭店」酱排骨饭做好，送到「小弟」手上，「小弟」最后再把酱排骨饭拿给「大佬」。\r\n\t\t- 说白了，小弟就是个跑腿的，代理大佬的需求。\r\n\r\n\t- 数据流程\r\n\r\n\t\t- 数据请求过程：浏览器 -> 代理服务器 -> 目标服务器\r\n\t\t- 数据返回过程：目标服务器 -> 代理服务器 -> 浏览器\r\n\r\n\t- 应用\r\n\r\n\t\t- 最经典的应用就是科学上网：我是一个国内用户，我访问不了google，但是我能访问一个香港的某个代理服务器。这个香港的代理服务器可以访问google，于是我先把请求发送到那个代理服务器，告诉他我需要访问google，代理服务器去取内容，最后返回给我。\r\n\r\n- 反向代理\r\n\r\n\t- 解释\r\n\r\n\t\t- 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。\r\n\r\n\t- 数据流程\r\n\r\n\t\t- 数据请求过程：浏览器 ->【反向代理服务器 -> 处理数据的服务器】\r\n\t\t- 数据返回过程：【处理数据的服务器 -> 反向代理服务器】-> 浏览器\r\n\r\n\t- 通俗地说\r\n\r\n\t\t- 「浏览器」可以看作食客，「【反向代理服务器-》处理数据的服务器】」这一个整体可以看作饭店，其中「反向代理服务」相当于点单的服务员。「处理数据的服务器」可以理解为是厨师。\r\n\t\t- 「食客」向来到「饭店」向「服务员」点菜，但服务员并不会真正去做菜，他是下达命令让「厨师」去做菜。\r\n\t\t- 「厨师」把菜做好了给「服务员」，「服务员」再把菜端给「食客」。\r\n\t\t- 在外部看来，「代理服务器」和「处理数据的服务器」是一个整体。就好比，食客只会去饭店吃饭，而不是去找厨师吃饭（即对于浏览器来说，到达反向代理服务器已经完成任务了，后面的操作则由反向代理服务器负责）。具体饭店怎么操作，对食客是透明的。有可能某个服务员即当服务器也当厨师（即反向代理服务器和处理数据的服务器是同一台PC机）。\r\n\r\n- 比较\r\n\r\n\t- 从用途上来讲\r\n\r\n\t\t- 正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。\r\n\t\t- 反向代理的典型用途是为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。\r\n\r\n\t- 从安全性来讲\r\n\r\n\t\t- 正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。\r\n\t\t- 反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。\r\n\r\n\t- 从使用方来看\r\n\r\n\t\t- 正向代理是浏览器端进行配置的，与服务器端无关，甚至可以对服务端隐藏。\r\n\t\t- 反向代理是服务器端配置的，对浏览器端是透明的。\r\n\r\n- 总结\r\n\r\n\t- 正向代理代理客户端，反向代理代理服务器\r\n\r\n### 利用代理实现跨域\r\n\r\n- 正向代理\r\n\r\n\t- 对正向代理服务器进行配置，当获取非接口数据时，让代理服务器指向开发者本机的资源。当访问接口时，访问后端接口数据。\r\n\t- Charles、Fiddler\r\n\r\n- 反向代理\r\n\r\n\t- Nginx\r\n\r\n\t\t- 用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。\r\n\t\t- 原理\r\n\r\n\t\t\t- 只需要配置nginx，在一个服务器上配置多个前缀来转发http/https请求到多个真实的服务器即可。这样，这个服务器上所有url都是相同的域名、协议和端口。因此，对于浏览器来说，这些url都是同源的，没有跨域限制。而实际上，这些url实际上由物理服务器提供服务。这些服务器内的javascript可以跨域调用所有这些服务器上的url。\r\n\r\n\t\t- 使用\r\n\r\n\t\t\t- server {\r\n        listen       9000;  #配置第一台服务器\r\n        server_name  localhost;\r\n\r\n        #charset koi8-r;\r\n\r\n        #access_log  logs/host.access.log  main;\r\n\r\n        location / {\r\n            #alias D:\\\\develop\\\\project1dir\\\\app\\\\; #配置别名到项目源代码目录，那么访问http://localhost:9000/即访问此目录\r\n            # Frontend Server\r\n            proxy_pass http://localhost:8001/;  #更聪明的做法是代理到前端服务器地址，比如gulp+browser-sync开启的服务器，能看到代码实时更新效果\r\n        }\r\n\r\n        location /api/ {\r\n            rewrite ^/api/(.*)$ /$1 break;   #所有对后端的请求加一个api前缀方便区分，真正访问的时候移除这个前缀\r\n            # API Server\r\n            proxy_pass http://www.serverA.com;  #将真正的请求代理到serverA,即真实的服务器地址，ajax的url为/api/user/1的请求将会访问http://www.serverA.com/user/1\r\n        }\r\n}\r\n",Li={data:function(){return{MainComponent:Ji}}},Hi=Li,Fi=Object(m["a"])(Hi,Di,Ii,!1,null,"d5606a0c",null),Ui=Fi.exports,qi=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[n._v("\n    1\n")])},Bi=[],Wi={},Vi=Wi,Gi=Object(m["a"])(Vi,qi,Bi,!1,null,"6626a3a3",null),zi=Gi.exports,$i=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[n._v("\n    1\n")])},Xi=[],Ki={},Qi=Ki,Yi=Object(m["a"])(Qi,$i,Xi,!1,null,"3c328ae4",null),Zi=Yi.exports,nl=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[n._v("\n    1\n")])},tl=[],rl={},el=rl,al=Object(m["a"])(el,nl,tl,!1,null,"123e7225",null),ol=al.exports,sl=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[n._v("\n    1\n")])},il=[],ll={},cl=ll,pl=Object(m["a"])(cl,sl,il,!1,null,"2f6b4d34",null),ul=pl.exports,ml=function(){var n=this;return n.$createElement,n._self._c,n._m(0)},dl=[function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[r("p",[n._v("综合类")]),r("p",[n._v("综合类 地址")]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/sb19871023/p/3894452.html",target:"_blank"}},[n._v("前端知识体系")])]),r("p",[r("a",{attrs:{href:"https://github.com/JacksonTian/fks",target:"_blank"}},[n._v("前端知识结构")])]),r("p",[r("a",{attrs:{href:"https://github.com/unruledboy/WebFrontEndStack",target:"_blank"}},[n._v("Web前端开发大系概览")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/unruledboy/p/WebFrontEndStack.html",target:"_blank"}},[n._v("Web前端开发大系概览-中文版")])]),r("p",[n._v("Web Front-end Stack v2.2 Web Front-end Stack v2.2")]),r("p",[r("a",{attrs:{href:"https://github.com/justjavac/free-programming-books-zh_CN",target:"_blank"}},[n._v("免费的编程中文书籍索引")])]),r("p",[r("a",{attrs:{href:"https://github.com/dypsilon/frontend-dev-bookmarks",target:"_blank"}},[n._v("前端书籍")])]),r("p",[r("a",{attrs:{href:"https://github.com/vhf/free-programming-books",target:"_blank"}},[n._v("前端免费书籍大全")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/sb19871023/p/3894452.html",target:"_blank"}},[n._v("前端知识体系")])]),r("p",[r("a",{attrs:{href:"https://github.com/justjavac/free-programming-books-zh_CN",target:"_blank"}},[n._v("免费的编程中文书籍索引")])]),r("p",[r("a",{attrs:{href:"http://study.163.com/course/introduction/224014.htm",target:"_blank"}},[n._v("智能社 - 精通JavaScript开发")])]),r("p",[r("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript",target:"_blank"}},[n._v("重新介绍 JavaScript（JS 教程）")])]),r("p",[r("a",{attrs:{href:"http://v.163.com/special/opencourse/bianchengdaolun.html",target:"_blank"}},[n._v("麻省理工学院公开课：计算机科学及编程导论")])]),r("p",[r("a",{attrs:{href:"http://segmentfault.com/a/1190000002640298",target:"_blank"}},[n._v("JavaScript中的this陷阱的最全收集--没有之一")])]),r("p",[r("a",{attrs:{href:"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.html",target:"_blank"}},[n._v("JS函数式编程指南")])]),r("p",[r("a",{attrs:{href:"http://liubin.github.io/promises-book",target:"_blank"}},[n._v("JavaScript Promise迷你书（中文版）")])]),r("p",[r("a",{attrs:{href:"https://github.com/AlloyTeam/Mars",target:"_blank"}},[n._v("腾讯移动Web前端知识库")])]),r("p",[r("a",{attrs:{href:"https://github.com/Front-End-Developers-Hunan/Front-End-Develop-Guide",target:"_blank"}},[n._v("Front-End-Develop-Guide 前端开发指南")])]),r("p",[r("a",{attrs:{href:"https://li-xinyang.gitbooks.io/frontend-notebook/content",target:"_blank"}},[n._v("前端开发笔记本")])]),r("p",[r("a",{attrs:{href:"https://github.com/nieweidong/fetool",target:"_blank"}},[n._v("大前端工具集 - 聂微东")])]),r("p",[r("a",{attrs:{href:"https://dwqs.gitbooks.io/frontenddevhandbook/content",target:"_blank"}},[n._v("前端开发者手册")])]),r("p",[n._v("入门类")]),r("p",[n._v("入门类 地址")]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/jikey/p/3613082.html",target:"_blank"}},[n._v("前端入门教程")])]),r("p",[r("a",{attrs:{href:"http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000",target:"_blank"}},[n._v("瘳雪峰的Javascript教程")])]),r("p",[r("a",{attrs:{href:"http://www.imooc.com/view/11",target:"_blank"}},[n._v("jQuery基础教程")])]),r("p",[r("a",{attrs:{href:"http://www.imooc.com/view/506",target:"_blank"}},[n._v("前端工程师必备的PS技能——切图篇")])]),r("p",[r("a",{attrs:{href:"https://github.com/qiu-deqing/FE-learning",target:"_blank"}},[n._v("结合个人经历总结的前端入门方法")])]),r("p",[n._v("工具类")]),r("p",[n._v("工具类 地址")]),r("p",[r("a",{attrs:{href:"http://f2er.club/",target:"_blank"}},[n._v("前端人的俱乐部")])]),r("p",[r("a",{attrs:{href:"http://www.jeffjade.com/2015/12/15/2015-04-17-toss-sublime-text/#",target:"_blank"}},[n._v("如何优雅地使用Sublime\n                    Text")])]),r("p",[r("a",{attrs:{href:"http://www.jeffjade.com/2016/03/03/2016-03-02-how-to-use-atom/",target:"_blank"}},[n._v("新编码神器Atom使用纪要")])]),r("p",[r("a",{attrs:{href:"http://www.imooc.com/learn/93",target:"_blank"}},[n._v("css sprite 雪碧图制作")])]),r("p",[r("a",{attrs:{href:"http://www.imooc.com/learn/390",target:"_blank"}},[n._v("版本控制入门 – 搬进 Github")])]),r("p",[r("a",{attrs:{href:"http://www.imooc.com/learn/30",target:"_blank"}},[n._v("Grunt-beginner前端自动化工具")])]),r("p",[r("a",{attrs:{href:"https://github.com/judasn/IntelliJ-IDEA-Tutorial",target:"_blank"}},[n._v("IntelliJ IDEA 简体中文专题教程")])]),r("p",[r("a",{attrs:{href:"http://t.cn/8kZZ1Uy",target:"_blank"}},[n._v("Webstorm,InterllIdea,Phpstorm")])]),r("p",[r("a",{attrs:{href:"https://github.com/jikeytang/sublime-text",target:"_blank"}},[n._v("SublimeText")])]),r("p",[r("a",{attrs:{href:"https://atom.io",target:"_blank"}},[n._v("Atom")])]),r("p",[r("a",{attrs:{href:"https://code.visualstudio.com",target:"_blank"}},[n._v("visual studio code")])]),r("p",[n._v("综合效果搜索平台")]),r("p",[n._v("综合效果搜索平台 地址")]),r("p",[r("a",{attrs:{href:"http://zoommyapp.com/",target:"_blank"}},[n._v("zoommyapp.com")])]),r("p",[r("a",{attrs:{href:"https://unsplash.com/",target:"_blank"}},[n._v("unsplash.com")])]),r("p",[r("a",{attrs:{href:"https://www.pinterest.com/",target:"_blank"}},[n._v("www.pinterest.com")])]),r("p",[r("a",{attrs:{href:"http://nos.twnsnd.co",target:"_blank"}},[n._v("New Old Stock")])]),r("p",[r("a",{attrs:{href:"http://www.jq22.com",target:"_blank"}},[n._v("效果网")])]),r("p",[r("a",{attrs:{href:"http://huaban.com/",target:"_blank"}},[n._v("花瓣网")])]),r("p",[r("a",{attrs:{href:"http://www.topit.me/",target:"_blank"}},[n._v("优美图")])]),r("p",[r("a",{attrs:{href:"http://codepen.io/",target:"_blank"}},[n._v("codepen")])]),r("p",[r("a",{attrs:{href:"http://www.17sucai.com",target:"_blank"}},[n._v("17素材")])]),r("p",[r("a",{attrs:{href:"http://699pic.com/",target:"_blank"}},[n._v("摄图网")])]),r("p",[r("a",{attrs:{href:"http://microjs.com",target:"_blank"}},[n._v("常用的JavaScript代码片段")])]),r("p",[n._v("周报类")]),r("p",[n._v("周报类 地址")]),r("p",[r("a",{attrs:{href:"http://old.75team.com/weekly/",target:"_blank"}},[n._v("奇舞周刊")])]),r("p",[r("a",{attrs:{href:"http://weekly.manong.io",target:"_blank"}},[n._v("码农周刊")])]),r("p",[r("a",{attrs:{href:"http://www.kancloud.cn/jsfront/month/82796",target:"_blank"}},[n._v("JS前端开发群月报")])]),r("p",[r("a",{attrs:{href:"http://www.css88.com",target:"_blank"}},[n._v("WEB前端开发")])]),r("p",[r("a",{attrs:{href:"http://www.jstips.co",target:"_blank"}},[n._v("A JS tip per day!")])]),r("p",[r("a",{attrs:{href:"https://github.com/PaicHyperionDev/MobileDevWeekly",target:"_blank"}},[n._v("平安科技移动开发二队技术周报")])]),r("p",[n._v("开发中心")]),r("p",[n._v("开发中心 地址")]),r("p",[r("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript",target:"_blank"}},[n._v("mozilla js参考")])]),r("p",[r("a",{attrs:{href:"https://developer.chrome.com/extensions/api_index.html",target:"_blank"}},[n._v("chrome开发中心（chrome的内核已转向blink）")])]),r("p",[r("a",{attrs:{href:"https://developer.apple.com/library/safari/navigation",target:"_blank"}},[n._v("safari开发中心")])]),r("p",[r("a",{attrs:{href:"https://msdn.microsoft.com/zh-cn/library/d1et7k7c",target:"_blank"}},[n._v("microsoft js参考")])]),r("p",[r("a",{attrs:{href:"http://sanshi.me/articles/JavaScript-Garden-CN/html/index.html",target:"_blank"}},[n._v("js秘密花园")])]),r("p",[r("a",{attrs:{href:"http://bonsaiden.github.io/JavaScript-Garden/zh",target:"_blank"}},[n._v("js秘密花园")])]),r("p",[r("a",{attrs:{href:"http://www.w3help.org",target:"_blank"}},[n._v("w3help")])]),r("p",[n._v("Nodejs")]),r("p",[n._v("Nodejs 地址")]),r("p",[r("a",{attrs:{href:"http://liuqing.pw",target:"_blank"}},[n._v("nodejs 篇幅比较巨大")])]),r("p",[r("a",{attrs:{href:"https://github.com/alsotang/node-lessons",target:"_blank"}},[n._v("Node.js 包教不包会")])]),r("p",[r("a",{attrs:{href:"http://www.rainweb.cn/article/category/Nodejs",target:"_blank"}},[n._v("篇幅比较少")])]),r("p",[r("a",{attrs:{href:"http://www.w3cfuns.com/article-5598538-1-1.html",target:"_blank"}},[n._v("node express 入门教程")])]),r("p",[r("a",{attrs:{href:"http://my.oschina.net/u/568264/blog/193773",target:"_blank"}},[n._v("nodejs定时任务")])]),r("p",[r("a",{attrs:{href:"http://60sky.com",target:"_blank"}},[n._v("一个nodejs博客")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/yexiaochai/p/3536547.html",target:"_blank"}},[n._v("【NodeJS 学习笔记04】新闻发布系统")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/qqloving/p/3541099.html",target:"_blank"}},[n._v("过年7天乐，学nodejs 也快乐")])]),r("p",[r("a",{attrs:{href:"https://github.com/nqdeng/7-days-nodejs",target:"_blank"}},[n._v("七天学会NodeJS")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/zhongweiv/p/nodejs_events.html",target:"_blank"}},[n._v("Nodejs学习笔记（二）--- 事件模块")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/liusuqi/p/3735491.html",target:"_blank"}},[n._v("nodejs入门")])]),r("p",[r("a",{attrs:{href:"https://github.com/zensh/jsgen",target:"_blank"}},[n._v("angularjs nodejs")])]),r("p",[r("a",{attrs:{href:"http://blog.fens.me/series-nodejs",target:"_blank"}},[n._v("从零开始nodejs系列文章")])]),r("p",[r("a",{attrs:{href:"http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb",target:"_blank"}},[n._v("理解nodejs")])]),r("p",[r("a",{attrs:{href:"http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop",target:"_blank"}},[n._v("nodejs事件轮询")])]),r("p",[r("a",{attrs:{href:"http://www.nodebeginner.org/index-zh-cn.html",target:"_blank"}},[n._v("node入门")])]),r("p",[r("a",{attrs:{href:"http://ourjs.com/detail/53e1f281c5910a9806000001",target:"_blank"}},[n._v("nodejs cms")])]),r("p",[r("a",{attrs:{href:"http://ourjs.com/detail/529ca5950cb6498814000005",target:"_blank"}},[n._v("Node初学者入门，一本全面的NodeJS教程")])]),r("p",[r("a",{attrs:{href:"http://www.barretlee.com/blog/2015/10/07/debug-nodejs-in-command-line",target:"_blank"}},[n._v("NodeJS的代码调试和性能调优")])]),r("p",[n._v("综合API")]),r("p",[n._v("综合API 地址")]),r("p",[r("a",{attrs:{href:"http://www.javascripting.com",target:"_blank"}},[n._v("javascripting")])]),r("p",[r("a",{attrs:{href:"http://microjs.com",target:"_blank"}},[n._v("各种流行库搜索")])]),r("p",[r("a",{attrs:{href:"http://www.runoob.com",target:"_blank"}},[n._v("runoob.com-包含各种API集合")])]),r("p",[r("a",{attrs:{href:"http://tool.oschina.net/apidocs",target:"_blank"}},[n._v("开源中国在线API文档合集")])]),r("p",[r("a",{attrs:{href:"http://devdocs.io",target:"_blank"}},[n._v("devdocs")])]),r("p",[n._v("Ecmascript")]),r("p",[n._v("Ecmascript 地址")]),r("p",[r("a",{attrs:{href:"https://leanpub.com/understandinges6/read",target:"_blank"}},[n._v("Understanding ECMAScript 6 - Nicholas C.\n                    Zakas")])]),r("p",[r("a",{attrs:{href:"https://leanpub.com/exploring-es6/read",target:"_blank"}},[n._v("exploring-es6")])]),r("p",[r("a",{attrs:{href:"https://github.com/es6-org/exploring-es6",target:"_blank"}},[n._v("exploring-es6翻译")])]),r("p",[r("a",{attrs:{href:"http://es6-org.github.io/exploring-es6",target:"_blank"}},[n._v("exploring-es6翻译后预览")])]),r("p",[r("a",{attrs:{href:"http://es6.ruanyifeng.com",target:"_blank"}},[n._v("阮一峰 es6")])]),r("p",[r("a",{attrs:{href:"http://javascript.ruanyifeng.com",target:"_blank"}},[n._v("阮一峰 Javascript")])]),r("p",[r("a",{attrs:{href:"http://yanhaijing.com/es5",target:"_blank"}},[n._v("ECMA-262，第 5 版")])]),r("p",[r("a",{attrs:{href:"http://es5.github.io",target:"_blank"}},[n._v("es5")])]),r("p",[n._v("Js template")]),r("p",[n._v("Js template 地址")]),r("p",[r("a",{attrs:{href:"http://garann.github.io/template-chooser",target:"_blank"}},[n._v("template-chooser")])]),r("p",[r("a",{attrs:{href:"https://github.com/aui/artTemplate",target:"_blank"}},[n._v("artTemplate")])]),r("p",[r("a",{attrs:{href:"https://github.com/aui/tmodjs/blob/master/README.md",target:"_blank"}},[n._v("tomdjs")])]),r("p",[r("a",{attrs:{href:"http://juicer.name/docs/docs_zh_cn.html",target:"_blank"}},[n._v("淘宝模板juicer模板")])]),r("p",[r("a",{attrs:{href:"http://koen301.github.io/fxtpl",target:"_blank"}},[n._v("Fxtpl v1.0 繁星前端模板引擎")])]),r("p",[r("a",{attrs:{href:"http://laytpl.layui.com",target:"_blank"}},[n._v("laytpl")])]),r("p",[r("a",{attrs:{href:"https://github.com/mozilla/nunjucks",target:"_blank"}},[n._v("mozilla - nunjucks")])]),r("p",[r("a",{attrs:{href:"https://github.com/PaulGuo/Juicer",target:"_blank"}},[n._v("Juicer")])]),r("p",[r("a",{attrs:{href:"http://akdubya.github.io/dustjs",target:"_blank"}},[n._v("dustjs")])]),r("p",[r("a",{attrs:{href:"http://ecomfe.github.io/etpl",target:"_blank"}},[n._v("etpl")])]),r("p",[n._v("CSS")]),r("p",[n._v("CSS 地址")]),r("p",[r("a",{attrs:{href:"http://tympanus.net/codrops/css_reference",target:"_blank"}},[n._v("CSS 语法参考")])]),r("p",[r("a",{attrs:{href:"http://isux.tencent.com/css3/index.html",target:"_blank"}},[n._v("CSS3动画手册")])]),r("p",[r("a",{attrs:{href:"http://isux.tencent.com/css3/tools.html",target:"_blank"}},[n._v("腾讯css3动画制作工具")])]),r("p",[r("a",{attrs:{href:"http://linxz.github.io/tianyizone",target:"_blank"}},[n._v("志爷css小工具集合")])]),r("p",[r("a",{attrs:{href:"http://www.note12.com/category/blog/2014-6-5/538fe0a9f786f1b7019a4dfb",target:"_blank"}},[n._v("css3 js\n                    移动大杂烩")])]),r("p",[r("a",{attrs:{href:"http://bouncejs.com",target:"_blank"}},[n._v("bouncejs 触摸库")])]),r("p",[r("a",{attrs:{href:"http://fian.my.id/Waves",target:"_blank"}},[n._v("css3 按钮动画")])]),r("p",[r("a",{attrs:{href:"http://daneden.github.io/animate.css",target:"_blank"}},[n._v("animate.css")])]),r("p",[r("a",{attrs:{href:"http://www.alloyteam.com/2015/10/8536",target:"_blank"}},[n._v("全局CSS的终结(狗带 [译]")])]),r("p",[r("a",{attrs:{href:"http://browserhacks.com",target:"_blank"}},[n._v("browserhacks")])]),r("p",[n._v("Angularjs")]),r("p",[n._v("Angularjs 地址")]),r("p",[r("a",{attrs:{href:"https://github.com/dolymood/AngularLearning",target:"_blank"}},[n._v("Angular.js 的一些学习资源")])]),r("p",[r("a",{attrs:{href:"http://angularjs.cn",target:"_blank"}},[n._v("angularjs中文社区")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/xuwenmin888/p/3739096.html",target:"_blank"}},[n._v("Angularjs源码学习")])]),r("p",[r("a",{attrs:{href:"http://www.ifeenan.com/?c=AngularJS",target:"_blank"}},[n._v("Angularjs源码学习")])]),r("p",[r("a",{attrs:{href:"http://angular-ui.github.io/bootstrap",target:"_blank"}},[n._v("angular对bootstrap的封装")])]),r("p",[r("a",{attrs:{href:"https://cnodejs.org/topic/51404e0f069911196d2e3923",target:"_blank"}},[n._v("angularjs + nodejs")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/lvdabao/tag/AngularJs",target:"_blank"}},[n._v("吕大豹 Angularjs")])]),r("p",[r("a",{attrs:{href:"http://www.infoq.com/cn/news/2013/02/angular-web-app",target:"_blank"}},[n._v("AngularJS 最佳实践")])]),r("p",[r("a",{attrs:{href:"http://www.lovelucy.info/angularjs-best-practices.html",target:"_blank"}},[n._v("Angular的一些扩展指令")])]),r("p",[r("a",{attrs:{href:"https://github.com/Pasvaz/bindonce",target:"_blank"}},[n._v("Angular数据绑定原理")])]),r("p",[r("a",{attrs:{href:"https://github.com/angular-ui",target:"_blank"}},[n._v("一些扩展Angular UI组件")])]),r("p",[r("a",{attrs:{href:"http://voidcanvas.com/emberjs-vs-angularjs-performance-testing",target:"_blank"}},[n._v("Ember和AngularJS的性能测试")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/powertoolsteam/p/angularjs-introdection.html",target:"_blank"}},[n._v("带你走近AngularJS -\n                    基本功能介绍")])]),r("p",[r("a",{attrs:{href:"http://angular.duapp.com/docs/guide",target:"_blank"}},[n._v("Angularjs开发指南")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/amosli/p/3710648.html",target:"_blank"}},[n._v("Angularjs学习")])]),r("p",[r("a",{attrs:{href:"http://www.rainweb.cn/article/angularjs-jquery.html",target:"_blank"}},[n._v("不要带着jQuery的思维去学习AngularJS")])]),r("p",[r("a",{attrs:{href:"http://wangjiatao.diandian.com/?tag=angularjs",target:"_blank"}},[n._v("angularjs 学习笔记")])]),r("p",[r("a",{attrs:{href:"http://www.angularjs.cn/T008",target:"_blank"}},[n._v("angularjs 开发指南")])]),r("p",[r("a",{attrs:{href:"https://github.com/jmcunningham/AngularJS-Learning",target:"_blank"}},[n._v("angularjs 英文资料")])]),r("p",[r("a",{attrs:{href:"http://angular-ui.github.io/bootstrap",target:"_blank"}},[n._v("angular bootstrap")])]),r("p",[r("a",{attrs:{href:"https://github.com/opitzconsulting/jquery-mobile-angular-adapter",target:"_blank"}},[n._v("angular jq\n                    mobile")])]),r("p",[r("a",{attrs:{href:"http://mgcrea.github.io/angular-strap",target:"_blank"}},[n._v("angular ui")])]),r("p",[r("a",{attrs:{href:"http://www.tuicool.com/articles/7ZZVr2",target:"_blank"}},[n._v("整合jQuery Mobile+AngularJS经验谈")])]),r("p",[r("a",{attrs:{href:"http://blog.jobbole.com/46589/",target:"_blank"}},[n._v("有jQuery背景，该如何用AngularJS编程思想")])]),r("p",[r("a",{attrs:{href:"http://each.sinaapp.com/angular",target:"_blank"}},[n._v("AngularJS在线教程")])]),r("p",[r("a",{attrs:{href:"http://www.zouyesheng.com/angular.html",target:"_blank"}},[n._v("angular学习笔记")])]),r("p",[n._v("React")]),r("p",[n._v("React 地址")]),r("p",[r("a",{attrs:{href:"http://www.react-china.org",target:"_blank"}},[n._v("react.js 中文论坛")])]),r("p",[r("a",{attrs:{href:"https://facebook.github.io/react/index.html",target:"_blank"}},[n._v("react.js 官方网址")])]),r("p",[r("a",{attrs:{href:"https://facebook.github.io/react/docs/getting-started.html",target:"_blank"}},[n._v("react.js 官方文档")])]),r("p",[r("a",{attrs:{href:"http://material-ui.com/#",target:"_blank"}},[n._v("react.js material UI")])]),r("p",[r("a",{attrs:{href:"http://touchstonejs.io",target:"_blank"}},[n._v("react.js TouchstoneJS UI")])]),r("p",[r("a",{attrs:{href:"http://amazeui.org/react",target:"_blank"}},[n._v("react.js amazeui UI")])]),r("p",[r("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2015/03/react.html",target:"_blank"}},[n._v("React 入门实例教程 - 阮一峰")])]),r("p",[r("a",{attrs:{href:"http://wiki.jikexueyuan.com/project/react-native",target:"_blank"}},[n._v("React Native 中文版")])]),r("p",[r("a",{attrs:{href:"http://www.html-js.com/article/Fakefish%203053",target:"_blank"}},[n._v("Webpack 和 React 小书 - 前端乱炖")])]),r("p",[r("a",{attrs:{href:"https://fakefish.github.io/react-webpack-cookbook",target:"_blank"}},[n._v("Webpack 和 React 小书 - gitbook")])]),r("p",[r("a",{attrs:{href:"https://github.com/webpack/webpack",target:"_blank"}},[n._v("webpack")])]),r("p",[r("a",{attrs:{href:"http://html-js.com/article/3009",target:"_blank"}},[n._v("Webpack，101入门体验")])]),r("p",[r("a",{attrs:{href:"http://html-js.com/article/3113",target:"_blank"}},[n._v("webpack入门教程")])]),r("p",[r("a",{attrs:{href:"http://segmentfault.com/a/1190000003499526",target:"_blank"}},[n._v("基于webpack搭建前端工程解决方案探索")])]),r("p",[r("a",{attrs:{href:"http://www.piliyu.com",target:"_blank"}},[n._v("React原创实战视频教程")])]),r("p",[n._v("vue")]),r("p",[n._v("vue 地址")]),r("p",[r("a",{attrs:{href:"http://cn.vuejs.org",target:"_blank"}},[n._v("Vue")])]),r("p",[r("a",{attrs:{href:"http://forum.vuejs.org",target:"_blank"}},[n._v("Vue 论坛")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/aaronjs/p/3660102.html",target:"_blank"}},[n._v("Vue 入门指南")])]),r("p",[r("a",{attrs:{href:"http://segmentfault.com/a/1190000000411057",target:"_blank"}},[n._v("Vue 的一些资源索引")])]),r("p",[r("a",{attrs:{href:"https://github.com/vuejs/awesome-vue",target:"_blank"}},[n._v("awesome-vue")])]),r("p",[n._v("移动端API")]),r("p",[n._v("移动端API 地址")]),r("p",[r("a",{attrs:{href:"https://github.com/jtyjty99999/mobileTech",target:"_blank"}},[n._v("99移动端知识集合")])]),r("p",[r("a",{attrs:{href:"https://github.com/AlloyTeam/Mars",target:"_blank"}},[n._v("移动端前端开发知识库")])]),r("p",[r("a",{attrs:{href:"http://caibaojian.com/mobile-web-bug.html",target:"_blank"}},[n._v("移动前端的一些坑和解决方法（外观表现）")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/PeunZhang/p/3407453.html",target:"_blank"}},[n._v("【原】移动web资源整理")])]),r("p",[r("a",{attrs:{href:"http://mweb.baidu.com/zeptoapi",target:"_blank"}},[n._v("zepto 1.0 中文手册")])]),r("p",[r("a",{attrs:{href:"http://www.html-5.cn/Manual/Zepto",target:"_blank"}},[n._v("zepto 1.0 中文手册")])]),r("p",[r("a",{attrs:{href:"http://www.css88.com/doc/zeptojs_api",target:"_blank"}},[n._v("zepto 1.1.2")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/sky000/archive/2013/03/29/2988952.html",target:"_blank"}},[n._v("zepto 中文注释")])]),r("p",[r("a",{attrs:{href:"http://app-framework-software.intel.com/api.php",target:"_blank"}},[n._v("jqmobile 手册")])]),r("p",[r("a",{attrs:{href:"https://github.com/maxzhang/maxzhang.github.com/issues",target:"_blank"}},[n._v("移动浏览器开发集合")])]),r("p",[r("a",{attrs:{href:"https://github.com/hoosin/mobile-web-favorites",target:"_blank"}},[n._v("移动开发大杂烩")])]),r("p",[n._v("jQuery")]),r("p",[n._v("jQuery 地址")]),r("p",[r("a",{attrs:{href:"http://www.jquery123.com",target:"_blank"}},[n._v("jQuery API 中文文档")])]),r("p",[r("a",{attrs:{href:"http://hemin.cn/jq",target:"_blank"}},[n._v("hemin 在线版")])]),r("p",[r("a",{attrs:{href:"http://www.css88.com/jqapi-1.9/on",target:"_blank"}},[n._v("css88 jq api")])]),r("p",[r("a",{attrs:{href:"http://www.css88.com/jquery-ui-api",target:"_blank"}},[n._v("css88 jqui api")])]),r("p",[r("a",{attrs:{href:"http://learn.jquery.com",target:"_blank"}},[n._v("学习jquery")])]),r("p",[r("a",{attrs:{href:"http://james.padolsey.com/jquery",target:"_blank"}},[n._v("jquery 源码查找")])]),r("p",[n._v("D3")]),r("p",[n._v("D3 地址")]),r("p",[r("a",{attrs:{href:"https://github.com/mbostock/d3/wiki/Tutorials",target:"_blank"}},[n._v("d3 Tutorials")])]),r("p",[r("a",{attrs:{href:"https://github.com/mbostock/d3/wiki/Gallery",target:"_blank"}},[n._v("Gallery")])]),r("p",[r("a",{attrs:{href:"http://datavisual.lofter.com/post/40cf3a_188e535",target:"_blank"}},[n._v("lofter")])]),r("p",[r("a",{attrs:{href:"http://alanland.iteye.com/blog/1878595",target:"_blank"}},[n._v("iteye")])]),r("p",[r("a",{attrs:{href:"http://javascript.ruanyifeng.com/library/d3.html",target:"_blank"}},[n._v("ruanyifeng")])]),r("p",[n._v("Requriejs")]),r("p",[n._v("Requriejs 地址")]),r("p",[r("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2012/10/javascript_module.html",target:"_blank"}},[n._v("Javascript模块化编程（一）：模块的写法")])]),r("p",[r("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html",target:"_blank"}},[n._v("Javascript模块化编程（二）：AMD规范")])]),r("p",[r("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2012/11/require_js.html",target:"_blank"}},[n._v("Javascript模块化编程（三）：require.js的用法")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/snandy/archive/2012/05/22/2513652.html",target:"_blank"}},[n._v("RequireJS入门（一）")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/snandy/archive/2012/05/23/2513712.html",target:"_blank"}},[n._v("RequireJS入门（二）")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/snandy/archive/2012/06/08/2538001.html",target:"_blank"}},[n._v("RequireJS进阶（三）")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/yexiaochai/p/3632580.html",target:"_blank"}},[n._v("requrie源码学习")])]),r("p",[r("a",{attrs:{href:"http://www.oschina.net/translate/getting-started-with-the-requirejs-library",target:"_blank"}},[n._v("requrie\n                    入门指南")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/yexiaochai/p/3214926.html",target:"_blank"}},[n._v("requrieJS 学习笔记")])]),r("p",[r("a",{attrs:{href:"http://cyj.me/why-seajs/requirejs/",target:"_blank"}},[n._v("requriejs 其一")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/yexiaochai/p/3221081.html",target:"_blank"}},[n._v("require backbone结合")])]),r("p",[n._v("Seajs")]),r("p",[n._v("Seajs 地址")]),r("p",[r("a",{attrs:{href:"http://seajs.org",target:"_blank"}},[n._v("seajs")])]),r("p",[r("a",{attrs:{href:"http://cyj.me/why-seajs/zh",target:"_blank"}},[n._v("seajs 中文手册")])]),r("p",[n._v("Less,sass")]),r("p",[n._v("Less,sass 地址")]),r("p",[r("a",{attrs:{href:"http://www.w3cplus.com/sassguide",target:"_blank"}},[n._v("sass")])]),r("p",[r("a",{attrs:{href:"http://www.sass.hk",target:"_blank"}},[n._v("sass教程-sass中国")])]),r("p",[r("a",{attrs:{href:"http://sass.bootcss.com",target:"_blank"}},[n._v("Sass 中文文档")])]),r("p",[r("a",{attrs:{href:"http://less.bootcss.com",target:"_blank"}},[n._v("less")])]),r("p",[n._v("Markdown")]),r("p",[n._v("Markdown 地址")]),r("p",[r("a",{attrs:{href:"http://wowubuntu.com/markdown",target:"_blank"}},[n._v("Markdown 语法说明 (简体中文版")])]),r("p",[r("a",{attrs:{href:"https://github.com/LearnShare/Learning-Markdown/blob/master/README.md",target:"_blank"}},[n._v("markdown入门参考")])]),r("p",[r("a",{attrs:{href:"https://www.gitbook.com",target:"_blank"}},[n._v("gitbook")])]),r("p",[r("a",{attrs:{href:"https://www.zybuluo.com/mdeditor",target:"_blank"}},[n._v("mdeditor")])]),r("p",[r("a",{attrs:{href:"https://stackedit.io",target:"_blank"}},[n._v("stackedit")])]),r("p",[r("a",{attrs:{href:"http://bh-lay.github.io/mditor",target:"_blank"}},[n._v("mditor")])]),r("p",[r("a",{attrs:{href:"https://github.com/lepture/editor",target:"_blank"}},[n._v("lepture-editor")])]),r("p",[r("a",{attrs:{href:"https://github.com/jbt/markdown-editor",target:"_blank"}},[n._v("markdown-editor")])]),r("p",[r("a",{attrs:{href:"https://www.zybuluo.com",target:"_blank"}},[n._v("作业部落")])]),r("p",[n._v("兼容性")]),r("p",[n._v("兼容性 地址")]),r("p",[r("a",{attrs:{href:"http://kangax.github.io/compat-table/es6",target:"_blank"}},[n._v("esma 兼容列表")])]),r("p",[r("a",{attrs:{href:"http://jigsaw.w3.org/css-validator/validator.html.zh-cn",target:"_blank"}},[n._v("W3C CSS验证服务")])]),r("p",[r("a",{attrs:{href:"http://caniuse.com/#index",target:"_blank"}},[n._v("caniuse")])]),r("p",[r("a",{attrs:{href:"http://csscreator.com/properties",target:"_blank"}},[n._v("csscreator")])]),r("p",[r("a",{attrs:{href:"https://msdn.microsoft.com/zh-cn/library/cc351024",target:"_blank"}},[n._v("microsoft")])]),r("p",[r("a",{attrs:{href:"http://www.responsinator.com",target:"_blank"}},[n._v("在线测兼容-移动端")])]),r("p",[r("a",{attrs:{href:"https://www.manymo.com/emulators",target:"_blank"}},[n._v("emulators")])]),r("p",[n._v("UI相关")]),r("p",[n._v("UI相关 地址")]),r("p",[r("a",{attrs:{href:"http://v3.bootcss.com",target:"_blank"}},[n._v("bootcss")])]),r("p",[r("a",{attrs:{href:"http://www.w3cplus.com/MetroUICSS",target:"_blank"}},[n._v("MetroUICSS")])]),r("p",[r("a",{attrs:{href:"http://semantic-ui.com",target:"_blank"}},[n._v("semantic")])]),r("p",[r("a",{attrs:{href:"http://alexwolfe.github.io/Buttons",target:"_blank"}},[n._v("Buttons")])]),r("p",[r("a",{attrs:{href:"http://hiloki.github.io/kitecss",target:"_blank"}},[n._v("kitecss")])]),r("p",[r("a",{attrs:{href:"http://www.pintuer.com",target:"_blank"}},[n._v("pintuer")])]),r("p",[r("a",{attrs:{href:"http://amazeui.org",target:"_blank"}},[n._v("amazeui")])]),r("p",[r("a",{attrs:{href:"http://www.worldhello.net/gotgithub/index.html",target:"_blank"}},[n._v("worldhello")])]),r("p",[r("a",{attrs:{href:"http://igit.linuxtoy.org/contents.html",target:"_blank"}},[n._v("linuxtoy")])]),r("p",[r("a",{attrs:{href:"http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn",target:"_blank"}},[n._v("gitmagic")])]),r("p",[r("a",{attrs:{href:"http://rogerdudler.github.io/git-guide/index.zh.html",target:"_blank"}},[n._v("rogerdudler")])]),r("p",[r("a",{attrs:{href:"http://gitref.justjavac.com",target:"_blank"}},[n._v("gitref")])]),r("p",[r("a",{attrs:{href:"http://git-scm.com/book/zh",target:"_blank"}},[n._v("book")])]),r("p",[r("a",{attrs:{href:"http://gogojimmy.net/2012/01/17/how-to-use-git-1-git-basic",target:"_blank"}},[n._v("gogojimmy")])]),r("p",[n._v("其它API")]),r("p",[n._v("其它API 地址")]),r("p",[r("a",{attrs:{href:"http://segmentfault.com/bookmark/1230000002521721",target:"_blank"}},[n._v("HTTP API 设计指南")])]),r("p",[n._v("javascript流行库汇总 javascriptoo")]),r("p",[r("a",{attrs:{href:"http://niceue.com/validator/demo/index.php",target:"_blank"}},[n._v("验证api")])]),r("p",[r("a",{attrs:{href:"http://www.css88.com/doc/underscore",target:"_blank"}},[n._v("underscore 中文手册")])]),r("p",[r("a",{attrs:{href:"http://www.html-js.com/article/Underscorejs-source-code-analysis-of-underscorejs-source-code-analysis%203031",target:"_blank"}},[n._v("underscore源码分析")])]),r("p",[r("a",{attrs:{href:"http://yalishizhude.github.io/tags/underscore",target:"_blank"}},[n._v("underscore源码分析-亚里士朱德的博客")])]),r("p",[r("a",{attrs:{href:"http://underscorejs.org",target:"_blank"}},[n._v("underscrejs en api")])]),r("p",[r("a",{attrs:{href:"https://lodash.com",target:"_blank"}},[n._v("lodash - underscore的代替品")])]),r("p",[r("a",{attrs:{href:"http://extjs-doc-cn.github.io/ext4api",target:"_blank"}},[n._v("ext4api")])]),r("p",[r("a",{attrs:{href:"http://www.csser.com/tools/backbone/backbone.js.html",target:"_blank"}},[n._v("backbone 中文手册")])]),r("p",[r("a",{attrs:{href:"http://dev.qwrap.com/resource/js/_docs/_youa/#/qw/base/loadJs_.htm",target:"_blank"}},[n._v("qwrap手册")])]),r("p",[r("a",{attrs:{href:"http://easings.net/zh-cn",target:"_blank"}},[n._v("缓动函数")])]),r("p",[r("a",{attrs:{href:"http://www.w3school.com.cn/svg/svg_reference.asp",target:"_blank"}},[n._v("svg 中文参考")])]),r("p",[r("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/SVG",target:"_blank"}},[n._v("svg mdn参考")])]),r("p",[r("a",{attrs:{href:"https://github.com/gabelerner/canvg",target:"_blank"}},[n._v("svg 导出 canvas")])]),r("p",[r("a",{attrs:{href:"https://github.com/exupero/saveSvgAsPng",target:"_blank"}},[n._v("svg 导出 png")])]),r("p",[r("a",{attrs:{href:"http://www.zamzar.com/convert/ai-to-svg",target:"_blank"}},[n._v("ai-to-svg")])]),r("p",[r("a",{attrs:{href:"https://github.com/machao/localStorage",target:"_blank"}},[n._v("localStorage 库")])]),r("p",[n._v("图表类")]),r("p",[n._v("图表类 地址")]),r("p",[r("a",{attrs:{href:"http://www.hcharts.cn/api/index.php",target:"_blank"}},[n._v("Highcharts 中文API")])]),r("p",[r("a",{attrs:{href:"http://api.highcharts.com/highcharts",target:"_blank"}},[n._v("Highcharts 英文API")])]),r("p",[r("a",{attrs:{href:"http://echarts.baidu.com/",target:"_blank"}},[n._v("ECharts 百度的图表软件")])]),r("p",[r("a",{attrs:{href:"http://lbs.amap.com/api",target:"_blank"}},[n._v("高德地图")])]),r("p",[r("a",{attrs:{href:"http://paperjs.org",target:"_blank"}},[n._v("开源的矢量图脚本框架")])]),r("p",[r("a",{attrs:{href:"http://jvectormap.com",target:"_blank"}},[n._v("svg 地图")])]),r("p",[n._v("正则")]),r("p",[n._v("正则 地址")]),r("p",[r("a",{attrs:{href:"http://segmentfault.com/a/1190000002471140",target:"_blank"}},[n._v("JS正则表达式元字符")])]),r("p",[r("a",{attrs:{href:"http://deerchao.net/tutorials/regex/regex.htm",target:"_blank"}},[n._v("正则表达式30分钟入门教程")])]),r("p",[r("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions",target:"_blank"}},[n._v("MDN-正则表达式")])]),r("p",[r("a",{attrs:{href:"http://javascript.ruanyifeng.com/stdlib/regexp.html",target:"_blank"}},[n._v("ruanyifeng - RegExp对象")])]),r("p",[r("a",{attrs:{href:"http://div.io/topic/764?page=1",target:"_blank"}},[n._v("小胡子哥 - 进阶正则表达式")])]),r("p",[r("a",{attrs:{href:"https://github.com/Cedriking/is.js/blob/master/is.js",target:"_blank"}},[n._v("is.js")])]),r("p",[r("a",{attrs:{href:"http://regexper.com",target:"_blank"}},[n._v("正则在线测试")])]),r("p",[n._v("前端")]),r("p",[n._v("前端 地址")]),r("p",[r("a",{attrs:{href:"http://alloyteam.github.io/CodeGuide",target:"_blank"}},[n._v("通过分析github代码库总结出来的工程师代码书写习惯")])]),r("p",[r("a",{attrs:{href:"http://codeguide.bootcss.com",target:"_blank"}},[n._v("HTML&CSS编码规范 by @mdo")])]),r("p",[r("a",{attrs:{href:"http://www.alloyteam.com/2011/10/css-on-team-naming/",target:"_blank"}},[n._v("团队合作的css命名规范-腾讯AlloyTeam前端团队")])]),r("p",[r("a",{attrs:{href:"http://yuwenhui.github.io",target:"_blank"}},[n._v("前端编码规范之js - by yuwenhui")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/hustskyking/p/javascript-spec.html",target:"_blank"}},[n._v("前端编码规范之js - by 李靖")])]),r("p",[r("a",{attrs:{href:"http://zhibimo.com/read/Ashu/front-end-style-guide",target:"_blank"}},[n._v("前端开发规范手册")])]),r("p",[r("a",{attrs:{href:"https://github.com/yuche/javascript#table-of-contents",target:"_blank"}},[n._v("Airbnb JavaScript\n                    编码规范（简体中文版）")])]),r("p",[r("a",{attrs:{href:"http://www.zhihu.com/question/20351507",target:"_blank"}},[n._v("AMD与CMD规范的区别")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/tugenhua0707/p/3507957.html",target:"_blank"}},[n._v("AMD与CMD规范的区别")])]),r("p",[r("a",{attrs:{href:"http://docs.kissyui.com/1.4/docs/html/tutorials/style-guide/kissy-source-style.html",target:"_blank"}},[n._v("KISSY 源码规范")])]),r("p",[r("a",{attrs:{href:"http://codeguide.bootcss.com",target:"_blank"}},[n._v("bt编码规范")])]),r("p",[r("a",{attrs:{href:"https://github.com/Suxiaogang/Code_Guide",target:"_blank"}},[n._v("规范加强版")])]),r("p",[r("a",{attrs:{href:"http://blog.jobbole.com/79075",target:"_blank"}},[n._v("前端代码规范 及 最佳实践")])]),r("p",[r("a",{attrs:{href:"http://coderlmn.github.io/code-standards",target:"_blank"}},[n._v("百度前端规范")])]),r("p",[r("a",{attrs:{href:"http://isobar-idev.github.io/code-standards",target:"_blank"}},[n._v("百度前端规范")])]),r("p",[r("a",{attrs:{href:"http://zhuanlan.zhihu.com/fuyun/19884834",target:"_blank"}},[n._v("百度前端规范")])]),r("p",[r("a",{attrs:{href:"https://github.com/gf-rd/es6-coding-style",target:"_blank"}},[n._v("ECMAScript6 编码规范--广发证券前端团队")])]),r("p",[r("a",{attrs:{href:"http://blog.jobbole.com/79484",target:"_blank"}},[n._v("JavaScript 风格指南/编码规范（Airbnb公司版）")])]),r("p",[r("a",{attrs:{href:"http://nec.netease.com/standard",target:"_blank"}},[n._v("网易前端开发规范")])]),r("p",[r("a",{attrs:{href:"http://www.75team.com/archives/1049",target:"_blank"}},[n._v("css模块")])]),r("p",[r("a",{attrs:{href:"https://github.com/ecomfe/spec",target:"_blank"}},[n._v("前端规范资源列表")])]),r("p",[n._v("PHP")]),r("p",[n._v("PHP 地址")]),r("p",[r("a",{attrs:{href:"http://segmentfault.com/a/1190000000443795",target:"_blank"}},[n._v("最流行的PHP 代码规范")])]),r("p",[r("a",{attrs:{href:"https://github.com/hfcorriez/fig-standards/blob/zh_CN/%E6%8E%A5%E5%8F%97/PSR-2-coding-style-guide.md",target:"_blank"}},[n._v("最流行的PHP 代码规范")])]),r("p",[n._v("各大公司开源项目")]),r("p",[n._v("各大公司开源项目 地址")]),r("p",[r("a",{attrs:{href:"https://code.facebook.com/projects/web",target:"_blank"}},[n._v("Facebook Projects")])]),r("p",[r("a",{attrs:{href:"http://fex.baidu.com",target:"_blank"}},[n._v("百度web前端研发部")])]),r("p",[r("a",{attrs:{href:"http://efe.baidu.com",target:"_blank"}},[n._v("百度EFE")])]),r("p",[r("a",{attrs:{href:"https://github.com/fex-team",target:"_blank"}},[n._v("百度github")])]),r("p",[r("a",{attrs:{href:"http://www.alloyteam.com",target:"_blank"}},[n._v("alloyteam")])]),r("p",[r("a",{attrs:{href:"http://alloyteam.github.io",target:"_blank"}},[n._v("alloyteam-github")])]),r("p",[r("a",{attrs:{href:"https://github.com/AlloyTeam/AlloyGameEngine",target:"_blank"}},[n._v("alloyteam-AlloyGameEngine")])]),r("p",[r("a",{attrs:{href:"http://alloyteam.github.io/AlloyDesigner",target:"_blank"}},[n._v("AlloyDesigner")])]),r("p",[r("a",{attrs:{href:"http://www.alloyteam.com/2015/06/h5-jiao-hu-ye-bian-ji-qi-aeditor-jie-shao",target:"_blank"}},[n._v("H5交互页编辑器AEditor介绍")])]),r("p",[r("a",{attrs:{href:"http://aeditor.alloyteam.com",target:"_blank"}},[n._v("AEditor")])]),r("p",[r("a",{attrs:{href:"http://forum.maka.im/wordpress",target:"_blank"}},[n._v("maka")])]),r("p",[r("a",{attrs:{href:"https://github.com/fenbility/weekly-feed",target:"_blank"}},[n._v("值得订阅的weekly")])]),r("p",[r("a",{attrs:{href:"http://cube.qq.com",target:"_blank"}},[n._v("腾讯html5")])]),r("p",[r("a",{attrs:{href:"http://75team.github.io",target:"_blank"}},[n._v("奇舞团开源项目")])]),r("p",[r("a",{attrs:{href:"http://ued.qunar.com",target:"_blank"}},[n._v("Qunar UED")])]),r("p",[r("a",{attrs:{href:"http://scrat.io",target:"_blank"}},[n._v("Scrat")])]),r("p",[n._v("常用")]),r("p",[n._v("常用 地址")]),r("p",[r("a",{attrs:{href:"http://www.zhangxinxu.com/wordpress/2013/12/iebetter-js-make-ie6-ie8-like-modern-browser-ie9-chrome",target:"_blank"}},[n._v("ieBetter.js-让IE6-IE8拥有IE9+,Chrome等浏览器特性")])]),r("p",[r("a",{attrs:{href:"http://mottie.github.io/Keyboard",target:"_blank"}},[n._v("模拟键盘")])]),r("p",[r("a",{attrs:{href:"https://github.com/hotoo/pinyin",target:"_blank"}},[n._v("拼音")])]),r("p",[r("a",{attrs:{href:"https://github.com/mc-zone/IDValidator",target:"_blank"}},[n._v("中国个人身份证号验证")])]),r("p",[n._v("算法")]),r("p",[n._v("算法 地址")]),r("p",[r("a",{attrs:{href:"https://github.com/Ralph-Wang/algorithm.in.js",target:"_blank"}},[n._v("数据结构与算法 JavaScript 描述. 章节练习")])]),r("p",[r("a",{attrs:{href:"https://github.com/twobin/twobinSort",target:"_blank"}},[n._v("常见排序算法（JS版）")])]),r("p",[r("a",{attrs:{href:"https://github.com/luofei2011/jsAgm/blob/master/js/sort.js",target:"_blank"}},[n._v("经典排序")])]),r("p",[r("a",{attrs:{href:"https://github.com/hechangmin/jssort",target:"_blank"}},[n._v("常见排序算法-js版本")])]),r("p",[r("a",{attrs:{href:"https://github.com/lightningtgc/JavaScript-Algorithms",target:"_blank"}},[n._v("JavaScript 算法与数据结构 精华集")])]),r("p",[r("a",{attrs:{href:"http://www.nowcoder.com/live/courses",target:"_blank"}},[n._v("面试常考算法题精讲")])]),r("p",[n._v("移动端")]),r("p",[n._v("移动端 地址")]),r("p",[r("a",{attrs:{href:"https://github.com/ftlabs/fastclick",target:"_blank"}},[n._v("fastclick")])]),r("p",[r("a",{attrs:{href:"https://github.com/mmastrac/jquery-noclickdelay",target:"_blank"}},[n._v("no-click-delay")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/lcw/p/3619181.html",target:"_blank"}},[n._v("【敏捷开发】Android团队开发规范")])]),r("p",[r("a",{attrs:{href:"http://www.jianshu.com/p/4390f4fe19b3",target:"_blank"}},[n._v("Android 开发规范与应用")])]),r("p",[r("a",{attrs:{href:"https://github.com/ychow/ionic-guide",target:"_blank"}},[n._v("ionic")])]),r("p",[n._v("JSON")]),r("p",[n._v("JSON 地址")]),r("p",[r("a",{attrs:{href:"http://beta.json-generator.com",target:"_blank"}},[n._v("模拟生成JSON数据")])]),r("p",[r("a",{attrs:{href:"http://jsonp.afeld.me",target:"_blank"}},[n._v("返回跨域JSONAPI")])]),r("p",[n._v("焦点图")]),r("p",[n._v("焦点图 地址")]),r("p",[r("a",{attrs:{href:"https://github.com/koen301/myfocus",target:"_blank"}},[n._v("myfocus")])]),r("p",[r("a",{attrs:{href:"http://www.chhua.com/myfocus",target:"_blank"}},[n._v("myfocus-官方演示站")])]),r("p",[r("a",{attrs:{href:"http://www.superslide2.com",target:"_blank"}},[n._v("SuperSlidev2.1 -- 大话主席")])]),r("p",[r("a",{attrs:{href:"http://www.bujichong.com/sojs/soChange/index.html",target:"_blank"}},[n._v("soChange")])]),r("p",[n._v("Ext, EasyUI, J-UI 及其它各种UI方案")]),r("p",[n._v("Ext, EasyUI, J-UI 及其它各种UI方案 地址")]),r("p",[r("a",{attrs:{href:"https://www.sencha.com/products/extjs",target:"_blank"}},[n._v("extjs")])]),r("p",[r("a",{attrs:{href:"http://docs.sencha.com/extjs/4.0.7",target:"_blank"}},[n._v("ext4英文api")])]),r("p",[r("a",{attrs:{href:"http://extjs-doc-cn.github.io/ext4api",target:"_blank"}},[n._v("ext4中文api")])]),r("p",[r("a",{attrs:{href:"http://jquery-easyui.googlecode.com/svn/trunk/src",target:"_blank"}},[n._v("jquery easyui 未压缩源代码")])]),r("p",[r("a",{attrs:{href:"http://jui.org",target:"_blank"}},[n._v("J-UI")])]),r("p",[r("a",{attrs:{href:"http://dcloudio.github.io/mui",target:"_blank"}},[n._v("MUI-最接近原生APP体验的高性能前端框架")])]),r("p",[n._v("Amaze UI 中国首个开源 HTML5 跨屏前端框架")]),r("p",[r("a",{attrs:{href:"http://m.sui.taobao.org",target:"_blank"}},[n._v("淘宝 HTML5 前端框架")])]),r("p",[r("a",{attrs:{href:"http://docs.kissyui.com",target:"_blank"}},[n._v("KISSY - 阿里前端JavaScript库")])]),r("p",[r("a",{attrs:{href:"http://nej.netease.com",target:"_blank"}},[n._v("网易Nej - Nice Easy Javascript")])]),r("p",[r("a",{attrs:{href:"http://demos.telerik.com/kendo-ui/mvvm/index",target:"_blank"}},[n._v("Kendo UI MVVM Demo")])]),r("p",[r("a",{attrs:{href:"http://www.bootcss.com",target:"_blank"}},[n._v("Bootstrap")])]),r("p",[r("a",{attrs:{href:"http://smartui.chinamzz.com",target:"_blank"}},[n._v("Smart UI")])]),r("p",[r("a",{attrs:{href:"http://developer.yahoo.com/yui/grids",target:"_blank"}},[n._v("雅虎UI - CSS UI")])]),r("p",[n._v("页面 社会化 分享功能")]),r("p",[n._v("页面 社会化 分享功能 地址")]),r("p",[r("a",{attrs:{href:"http://share.baidu.com",target:"_blank"}},[n._v("百度分享")])]),r("p",[r("a",{attrs:{href:"http://jiathis.com",target:"_blank"}},[n._v("JiaThis")])]),r("p",[r("a",{attrs:{href:"http://developer.baidu.com/soc/share",target:"_blank"}},[n._v("社会化分享组件")])]),r("p",[r("a",{attrs:{href:"http://www.mob.com/#/index",target:"_blank"}},[n._v("ShareSDK 轻松实现社会化功能")])]),r("p",[r("a",{attrs:{href:"http://dev.umeng.com/social/android/quick-integration",target:"_blank"}},[n._v("友盟分享")])]),r("p",[n._v("富文本编辑器")]),r("p",[n._v("富文本编辑器 地址")]),r("p",[r("a",{attrs:{href:"https://www.tinymce.com",target:"_blank"}},[n._v("功能齐全 tinymce")])]),r("p",[r("a",{attrs:{href:"http://ueditor.baidu.com/website",target:"_blank"}},[n._v("百度 ueditor")])]),r("p",[r("a",{attrs:{href:"http://ckeditor.com",target:"_blank"}},[n._v("经典的ckeditor")])]),r("p",[r("a",{attrs:{href:"http://kindeditor.net",target:"_blank"}},[n._v("经典的kindeditor")])]),r("p",[r("a",{attrs:{href:"http://www.bootcss.com/p/bootstrap-wysiwyg",target:"_blank"}},[n._v("wysiwyg")])]),r("p",[r("a",{attrs:{href:"http://integ.github.io/BachEditor",target:"_blank"}},[n._v("一个有情怀的编辑器。Bach's Editor")])]),r("p",[r("a",{attrs:{href:"https://github.com/mycolorway/simditor",target:"_blank"}},[n._v("tower用的编辑器")])]),r("p",[r("a",{attrs:{href:"https://github.com/summernote/summernote",target:"_blank"}},[n._v("summernote 编辑器")])]),r("p",[r("a",{attrs:{href:"http://neilj.github.io/Squire",target:"_blank"}},[n._v("html5编辑器")])]),r("p",[r("a",{attrs:{href:"http://lab.hustlzp.com/XEditor",target:"_blank"}},[n._v("XEditor")])]),r("p",[r("a",{attrs:{href:"https://github.com/wangfupeng1988/wangEditor",target:"_blank"}},[n._v("wangEditor")])]),r("p",[n._v("前端概述")]),r("p",[n._v("前端概述 地址")]),r("p",[r("a",{attrs:{href:"http://www.awesomes.cn",target:"_blank"}},[n._v("前端工具大全")])]),r("p",[r("a",{attrs:{href:"https://github.com/fouber/blog/issues/10?from=timeline&isappinstalled=0#",target:"_blank"}},[n._v("什么是前端工程化")])]),r("p",[n._v("Gulp")]),r("p",[n._v("Gulp 地址")]),r("p",[r("a",{attrs:{href:"http://gulpjs.com",target:"_blank"}},[n._v("Gulp官网")])]),r("p",[r("a",{attrs:{href:"http://www.gulpjs.com.cn",target:"_blank"}},[n._v("Gulp中文网")])]),r("p",[r("a",{attrs:{href:"https://github.com/Platform-CUF/use-gulp",target:"_blank"}},[n._v("gulp资料收集")])]),r("p",[r("a",{attrs:{href:"http://javascript.ruanyifeng.com/tool/gulp.html",target:"_blank"}},[n._v("Gulp：任务自动管理工具 - ruanyifeng")])]),r("p",[r("a",{attrs:{href:"http://gulpjs.com/plugins",target:"_blank"}},[n._v("Gulp插件")])]),r("p",[r("a",{attrs:{href:"http://www.jeffjade.com/2015/11/25/2015-11-25-toss-gulp/",target:"_blank"}},[n._v("Gulp探究折腾之路(I)")])]),r("p",[r("a",{attrs:{href:"http://www.jeffjade.com/2016/01/19/2016-01-19-toss-gulp/",target:"_blank"}},[n._v("Gulp折腾之路(II)")])]),r("p",[r("a",{attrs:{href:"http://www.ido321.com/1622.html",target:"_blank"}},[n._v("Gulp不完全入门教程")])]),r("p",[r("a",{attrs:{href:"https://github.com/hjzheng/CUF_meeting_knowledge_share/issues/33",target:"_blank"}},[n._v("为什么使用gulp?")])]),r("p",[r("a",{attrs:{href:"http://www.dbpoo.com/getting-started-with-gulp",target:"_blank"}},[n._v("Gulp安装及配合组件构建前端开发一体化")])]),r("p",[r("a",{attrs:{href:"https://github.com/nimojs/gulp-book",target:"_blank"}},[n._v("Gulp 入门指南")])]),r("p",[r("a",{attrs:{href:"https://github.com/nimojs/blog/issues/19",target:"_blank"}},[n._v("Gulp 入门指南 - nimojs")])]),r("p",[r("a",{attrs:{href:"http://www.imooc.com/video/5692",target:"_blank"}},[n._v("Gulp in Action")])]),r("p",[r("a",{attrs:{href:"http://www.w3ctech.com/topic/134",target:"_blank"}},[n._v("Gulp开发教程（翻译）")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/2050/p/4198792.html",target:"_blank"}},[n._v("前端构建工具gulpjs的使用介绍及技巧")])]),r("p",[n._v("Grunt")]),r("p",[n._v("Grunt 地址")]),r("p",[r("a",{attrs:{href:"http://gruntjs.com",target:"_blank"}},[n._v("gruntjs")])]),r("p",[r("a",{attrs:{href:"http://www.gruntjs.net",target:"_blank"}},[n._v("Grunt中文网")])]),r("p",[n._v("Fis")]),r("p",[n._v("Fis 地址")]),r("p",[r("a",{attrs:{href:"http://fex-team.github.io/fis-site/index.html",target:"_blank"}},[n._v("fis 官网")])]),r("p",[r("a",{attrs:{href:"http://fis.baidu.com",target:"_blank"}},[n._v("fis")])]),r("p",[n._v("pc图轮")]),r("p",[n._v("pc图轮 地址")]),r("p",[r("a",{attrs:{href:"http://www.jsfoot.com/jquery/demo/2011-09-20/192.html",target:"_blank"}},[n._v("单屏轮播sochange")])]),r("p",[r("a",{attrs:{href:"http://bxslider.com/examples/carousel-demystified",target:"_blank"}},[n._v("左右按钮多图切换")])]),r("p",[r("a",{attrs:{href:"https://github.com/alvarotrigo/fullPage.js",target:"_blank"}},[n._v("fullpage全屏轮播")])]),r("p",[n._v("移动端图轮")]),r("p",[n._v("移动端图轮 地址")]),r("p",[r("a",{attrs:{href:"http://www.swipejs.com",target:"_blank"}},[n._v("无缝切换")])]),r("p",[r("a",{attrs:{href:"http://www.idangero.us/swiper",target:"_blank"}},[n._v("滑屏效果")])]),r("p",[r("a",{attrs:{href:"https://github.com/peunzhang/fullpage",target:"_blank"}},[n._v("全屏fullpage")])]),r("p",[r("a",{attrs:{href:"https://github.com/qiqiboy/touchslider",target:"_blank"}},[n._v("单个图片切换")])]),r("p",[r("a",{attrs:{href:"https://github.com/peunzhang/slip.js",target:"_blank"}},[n._v("单个全屏切换")])]),r("p",[r("a",{attrs:{href:"http://touch.code.baidu.com/examples.html?qq-pf-to=pcqq.group",target:"_blank"}},[n._v("百度的切换库")])]),r("p",[r("a",{attrs:{href:"https://github.com/peunzhang/iSlider",target:"_blank"}},[n._v("单个全屏切换")])]),r("p",[r("a",{attrs:{href:"https://github.com/saw/touch-interfaces",target:"_blank"}},[n._v("滑屏效果")])]),r("p",[r("a",{attrs:{href:"http://baijs.com/tinycircleslider",target:"_blank"}},[n._v("旋转拖动设置")])]),r("p",[r("a",{attrs:{href:"http://touchslider.com",target:"_blank"}},[n._v("类似于swipe切换")])]),r("p",[r("a",{attrs:{href:"http://www.swiper.com.cn/demo/index.html",target:"_blank"}},[n._v("支持多种形式的触摸滑动")])]),r("p",[r("a",{attrs:{href:"https://github.com/joker-ye/main/blob/master/wap/index.html",target:"_blank"}},[n._v("滑屏效果")])]),r("p",[r("a",{attrs:{href:"http://www.superslide2.com",target:"_blank"}},[n._v("大话主席pc移动图片轮换")])]),r("p",[r("a",{attrs:{href:"https://github.com/hahnzhu/parallax.js",target:"_blank"}},[n._v("滑屏效果")])]),r("p",[r("a",{attrs:{href:"https://github.com/yanhaijing/zepto.fullpage",target:"_blank"}},[n._v("基于zepto的fullpage")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/plums/archive/2013/01/10/WebApp-fixed-width-layout-of-multi-terminal-adapter-since.html",target:"_blank"}},[n._v("[WebApp]定宽网页设计下，固定宽度布局开发WebApp并实现多终端下WebApp布局自适应")])]),r("p",[r("a",{attrs:{href:"http://loo2k.com/blog/detecting-wechat-client",target:"_blank"}},[n._v("判断微信客户端的那些坑")])]),r("p",[r("a",{attrs:{href:"https://github.com/JefferyWang/nativeShare.js",target:"_blank"}},[n._v("可以通过javascript直接调用原生分享的工具")])]),r("p",[r("a",{attrs:{href:"http://www.jiathis.com/help/html/weixin-share-code",target:"_blank"}},[n._v("JiaThis 分享到微信代码")])]),r("p",[r("a",{attrs:{href:"http://fex.baidu.com/blog/2015/05/cross-mobile",target:"_blank"}},[n._v("聊聊移动端跨平台开发的各种技术")])]),r("p",[r("a",{attrs:{href:"http://www.zhihu.com/question/29922082",target:"_blank"}},[n._v("前端自动化测试")])]),r("p",[r("a",{attrs:{href:"http://ajccom.github.io/niceslider",target:"_blank"}},[n._v("多种轮换图片")])]),r("p",[r("a",{attrs:{href:"https://mango.github.io/slideout",target:"_blank"}},[n._v("滑动侧边栏")])]),r("p",[n._v("文件上传")]),r("p",[n._v("文件上传 地址")]),r("p",[r("a",{attrs:{href:"http://fex.baidu.com/webuploader",target:"_blank"}},[n._v("百度上传组件")])]),r("p",[r("a",{attrs:{href:"https://blueimp.github.io/jQuery-File-Upload",target:"_blank"}},[n._v("上传")])]),r("p",[r("a",{attrs:{href:"http://www.hdfu.net",target:"_blank"}},[n._v("flash 头像上传")])]),r("p",[r("a",{attrs:{href:"http://www.dropzonejs.com",target:"_blank"}},[n._v("图片上传预览")])]),r("p",[r("a",{attrs:{href:"http://elemefe.github.io/image-cropper",target:"_blank"}},[n._v("图片裁剪")])]),r("p",[r("a",{attrs:{href:"http://www.shearphoto.com",target:"_blank"}},[n._v("图片裁剪-shearphoto")])]),r("p",[r("a",{attrs:{href:"http://www.oschina.net/project/tag/284/jquery-image-tools?lang=0&os=0&sort=view&p=2",target:"_blank"}},[n._v("jQuery图片处理")])]),r("p",[n._v("模拟select")]),r("p",[n._v("模拟select 地址")]),r("p",[r("a",{attrs:{href:"http://aui.github.io/popupjs/doc/selectbox.html",target:"_blank"}},[n._v("糖饼 select")])]),r("p",[r("a",{attrs:{href:"https://github.com/rmm5t/jquery-flexselect",target:"_blank"}},[n._v("flexselect")])]),r("p",[r("a",{attrs:{href:"http://loudev.com",target:"_blank"}},[n._v("双select")])]),r("p",[r("a",{attrs:{href:"http://select2.github.io",target:"_blank"}},[n._v("select2")])]),r("p",[n._v("取色插件")]),r("p",[n._v("取色插件 地址")]),r("p",[r("a",{attrs:{href:"http://www.jq22.com/plugin/367",target:"_blank"}},[n._v("类似 Photoshop 的界面取色插件")])]),r("p",[r("a",{attrs:{href:"https://github.com/jquery/jquery-color",target:"_blank"}},[n._v("jquery color")])]),r("p",[r("a",{attrs:{href:"http://www.oschina.net/project/tag/287/color-picker",target:"_blank"}},[n._v("取色插件集合")])]),r("p",[r("a",{attrs:{href:"https://github.com/mattfarina/farbtastic",target:"_blank"}},[n._v("farbtastic 圆环＋正方形")])]),r("p",[n._v("城市联动")]),r("p",[n._v("城市联动 地址")]),r("p",[r("a",{attrs:{href:"http://www.ijquery.cn/?p=360",target:"_blank"}},[n._v("jquery.cityselect.js基于jQuery+JSON的省市或自定义联动效果")])]),r("p",[n._v("剪贴板")]),r("p",[n._v("剪贴板 地址")]),r("p",[r("a",{attrs:{href:"https://github.com/zeroclipboard/zeroclipboard",target:"_blank"}},[n._v("剪贴板")])]),r("p",[r("a",{attrs:{href:"http://zenorocha.github.io/clipboard.js",target:"_blank"}},[n._v("clipboard 最新的剪切方案")])]),r("p",[r("a",{attrs:{href:"https://github.com/zenorocha/clipboard.js",target:"_blank"}},[n._v("不是Flash的剪贴板")])]),r("p",[n._v("简繁转换")]),r("p",[n._v("简繁转换 地址")]),r("p",[r("a",{attrs:{href:"https://github.com/BYVoid/OpenCC",target:"_blank"}},[n._v("简繁转换")])]),r("p",[n._v("表格 Grid")]),r("p",[n._v("表格 Grid 地址")]),r("p",[r("a",{attrs:{href:"http://facebook.github.io/fixed-data-table",target:"_blank"}},[n._v("facebook表格")])]),r("p",[r("a",{attrs:{href:"http://handsontable.com",target:"_blank"}},[n._v("类似于Excel编辑表格-handsontable")])]),r("p",[r("a",{attrs:{href:"http://bootstrap-table.wenzhixin.net.cn",target:"_blank"}},[n._v("bootstrap-table插件")])]),r("p",[r("a",{attrs:{href:"https://www.datatables.net",target:"_blank"}},[n._v("datatables")])]),r("p",[n._v("在线演示")]),r("p",[n._v("在线演示 地址")]),r("p",[r("a",{attrs:{href:"http://runjs.cn",target:"_blank"}},[n._v("js 在线编辑 - runjs")])]),r("p",[r("a",{attrs:{href:"http://jsbin.com",target:"_blank"}},[n._v("js 在线编辑 - jsbin")])]),r("p",[r("a",{attrs:{href:"http://codepen.io",target:"_blank"}},[n._v("js 在线编辑 - codepen")])]),r("p",[r("a",{attrs:{href:"http://jsfiddle.net",target:"_blank"}},[n._v("js 在线编辑 - jsfiddle")])]),r("p",[r("a",{attrs:{href:"http://ideone.com",target:"_blank"}},[n._v("java 在线编辑 - runjs")])]),r("p",[r("a",{attrs:{href:"http://code.hcharts.cn",target:"_blank"}},[n._v("js 在线编辑 - hcharts")])]),r("p",[r("a",{attrs:{href:"http://jsdm.com",target:"_blank"}},[n._v("js 在线编辑 - jsdm")])]),r("p",[r("a",{attrs:{href:"http://sqlfiddle.com",target:"_blank"}},[n._v("sql 在线编辑 - sqlfiddle")])]),r("p",[r("a",{attrs:{href:"https://thimble.mozilla.org",target:"_blank"}},[n._v("mozilla 在线编辑器")])]),r("p",[n._v("常规优化")]),r("p",[n._v("常规优化 地址")]),r("p",[r("a",{attrs:{href:"http://www.infoq.com/cn/articles/javascript-high-performance-animation-and-page-rendering",target:"_blank"}},[n._v("Javascript高性能动画与页面渲染")])]),r("p",[r("a",{attrs:{href:"http://isux.tencent.com/h5-performance.html",target:"_blank"}},[n._v("移动H5前端性能优化指南")])]),r("p",[r("a",{attrs:{href:"http://ued.5173.com/?p=1731",target:"_blank"}},[n._v("5173首页前端性能优化实践")])]),r("p",[r("a",{attrs:{href:"http://www.uisdc.com/front-end-performance-for-web-designers-and-front-end-developers",target:"_blank"}},[n._v("给网页设计师和前端开发者看的前端性能优化")])]),r("p",[r("a",{attrs:{href:"http://www.orzpoint.com/profiling-css-and-optimization-notes",target:"_blank"}},[n._v("复杂应用的 CSS\n                    性能分析和优化建议")])]),r("p",[n._v("张鑫旭——前端性能 张鑫旭——前端性能")]),r("p",[r("a",{attrs:{href:"http://www.xiaoqiang.org/javascript/font-end-performance-monitor.html",target:"_blank"}},[n._v("前端性能监控总结")])]),r("p",[n._v("网站性能优化之CSS无图片技术 网站性能优化之CSS无图片技术")]),r("p",[n._v("web前端性能优化进阶路 web前端性能优化进阶路")]),r("p",[r("a",{attrs:{href:"http://my.eoe.cn/tuwandou/archive/4544.html",target:"_blank"}},[n._v("前端技术：网站性能优化之CSS无图片技术")])]),r("p",[r("a",{attrs:{href:"http://www.baiduux.com/blog/2011/02/15/browser-loading",target:"_blank"}},[n._v("浏览器的加载与页面性能优化")])]),r("p",[r("a",{attrs:{href:"http://www.w3ctech.com/p/1503",target:"_blank"}},[n._v("页面加载中的图片性能优化")])]),r("p",[n._v("Hey——前端性能 Hey——前端性能")]),r("p",[n._v("html优化 html优化")]),r("p",[n._v("99css——性能 99css——性能")]),r("p",[r("a",{attrs:{href:"http://www.yslow.net/category.php?cid=20",target:"_blank"}},[n._v("Yslow——性能优化")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/yslow",target:"_blank"}},[n._v("YSLOW中文介绍")])]),r("p",[r("a",{attrs:{href:"http://www.360ito.com/article/40.html",target:"_blank"}},[n._v("转一篇Yahoo关于网站性能优化的文章，兼谈本站要做的优化")])]),r("p",[r("a",{attrs:{href:"http://www.360doc.com/content/10/0928/09/2588264_56971287.shtml",target:"_blank"}},[n._v("Yahoo!团队实践分享：网站性能")])]),r("p",[r("a",{attrs:{href:"http://blog.jiasule.com/i/153",target:"_blank"}},[n._v("网站性能优化指南：什么使我们的网站变慢？")])]),r("p",[r("a",{attrs:{href:"http://www.powereasy.net/helpyou/knowledge/ecommerce/9593.html",target:"_blank"}},[n._v("网站性能优化实践，减少加载时间，提高用户体验")])]),r("p",[r("a",{attrs:{href:"http://www.umtry.com/archives/747.html",target:"_blank"}},[n._v("浅谈网站性能优化 前端篇")])]),r("p",[r("a",{attrs:{href:"http://www.adinnet.cn/blog/designview/2012-7-12/678.html",target:"_blank"}},[n._v("前端重构实践之如何对网站性能优化？")])]),r("p",[r("a",{attrs:{href:"http://www.gbin1.com/technology/javascript/20130708-front-end-performance-optimization-9",target:"_blank"}},[n._v("前端性能优化：使用媒体查询加载指定大小的背景图片")])]),r("p",[r("a",{attrs:{href:"http://www.mykuer.com/post/factors-that-affect-the-speed-of-web-site-open.html",target:"_blank"}},[n._v("网站性能系列博文")])]),r("p",[r("a",{attrs:{href:"http://tgideas.qq.com/webplat/info/news_version3/804/808/811/m579/201109/41355.shtml",target:"_blank"}},[n._v("加载，不只是少一点点")])]),r("p",[r("a",{attrs:{href:"http://mzhou.me/article/95310",target:"_blank"}},[n._v("前端性能的测试与优化")])]),r("p",[r("a",{attrs:{href:"http://www.gbin1.com/technology/html/20130217-tips-for-speed-up-page-loading",target:"_blank"}},[n._v("分享网页加载速度优化的一些技巧？")])]),r("p",[r("a",{attrs:{href:"http://www.f2es.com/images-bytes-opt",target:"_blank"}},[n._v("页面加载中的图片性能优化")])]),r("p",[r("a",{attrs:{href:"http://www.tcreator.info/webSchool/website/Front-end-Opt-Yslow.html",target:"_blank"}},[n._v("web前端优化(基于Yslow")])]),r("p",[r("a",{attrs:{href:"https://www.qianduan.net/website-performance-optimization-tool.html",target:"_blank"}},[n._v("网站性能优化工具大全")])]),r("p",[r("a",{attrs:{href:"http://www.alloyteam.com/2012/10/high-performance-html",target:"_blank"}},[n._v("【高性能前端1】高性能HTML")])]),r("p",[r("a",{attrs:{href:"http://www.alloyteam.com/2012/10/high-performance-css",target:"_blank"}},[n._v("【高性能前端2】高性能CSS")])]),r("p",[r("a",{attrs:{href:"http://coolshell.cn/articles/6470.html",target:"_blank"}},[n._v("由12306谈谈网站前端性能和后端性能优化")])]),r("p",[n._v("AlloyTeam——前端优化 AlloyTeam——前端优化")]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/developersupport/p/3248695.html",target:"_blank"}},[n._v("毫秒必争，前端网页性能最佳实践")])]),r("p",[r("a",{attrs:{href:"http://blog.sina.com.cn/s/blog_6e9d2e0701017kvu.html",target:"_blank"}},[n._v("网站性能工具Yslow的使用方法")])]),r("p",[r("a",{attrs:{href:"http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part1",target:"_blank"}},[n._v("前端工程与性能优化（上）：静态资源版本更新与缓存")])]),r("p",[r("a",{attrs:{href:"http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part2",target:"_blank"}},[n._v("前端工程与性能优化（下）：静态资源管理与模板框架")])]),r("p",[r("a",{attrs:{href:"http://blog.jobbole.com/48369",target:"_blank"}},[n._v("HTTPS连接的前几毫秒发生了什么")])]),r("p",[r("a",{attrs:{href:"http://uicss.cn/yslow/#more-12319",target:"_blank"}},[n._v("Yslow")])]),r("p",[r("a",{attrs:{href:"http://blog.smartbear.com/web-performance/essential-web-performance-metrics-a-primer-part-1",target:"_blank"}},[n._v("Essential Web Performance Metrics — A Primer, Part 1")])]),r("p",[r("a",{attrs:{href:"http://blog.smartbear.com/performance/essential-web-performance-metrics-part-2",target:"_blank"}},[n._v("Essential Web Performance Metrics — Part 2")])]),r("p",[r("a",{attrs:{href:"http://jayli.github.io/blog/data/2011/12/23/yuislide.html",target:"_blank"}},[n._v("YUISlide,针对移动设备的动画性能优化")])]),r("p",[r("a",{attrs:{href:"http://joelglovier.com/improving-site-performance",target:"_blank"}},[n._v("Improving Site Performance")])]),r("p",[r("a",{attrs:{href:"http://segmentfault.com/a/1190000000367899",target:"_blank"}},[n._v("让网站提速的最佳前端实践")])]),r("p",[r("a",{attrs:{href:"http://sixrevisions.com/web-development/why-website-speed-is-important",target:"_blank"}},[n._v("Why Website\n                    Speed is Important")])]),r("p",[r("a",{attrs:{href:"https://www.devbridge.com/articles/need-for-speed-how-to-improve-your-website-performance",target:"_blank"}},[n._v("Need for Speed – How to Improve your Website Performance")])]),r("p",[r("a",{attrs:{href:"https://github.com/amfe/article/issues/1",target:"_blank"}},[n._v("阿里无线前端性能优化指南 (Pt.1 加载期优化")])]),r("p",[n._v("优化工具")]),r("p",[n._v("优化工具 地址")]),r("p",[r("a",{attrs:{href:"http://www.html-js.com/article/3083",target:"_blank"}},[n._v("JavaScript 性能分析新工具 OneProfile")])]),r("p",[r("a",{attrs:{href:"http://www.html-js.com/article/3091",target:"_blank"}},[n._v("JavaScript 堆内存分析新工具 OneHeap")])]),r("p",[n._v("在线工具")]),r("p",[n._v("在线工具 地址")]),r("p",[r("a",{attrs:{href:"https://developers.google.com/speed/pagespeed/insights",target:"_blank"}},[n._v("google在线工具")])]),r("p",[r("a",{attrs:{href:"http://www.alibench.com",target:"_blank"}},[n._v("阿里测")])]),r("p",[r("a",{attrs:{href:"http://itest.aliyun.com",target:"_blank"}},[n._v("阿里-免费测试服务")])]),r("p",[r("a",{attrs:{href:"https://github.com/alibaba/f2etest",target:"_blank"}},[n._v("阿里-F2etest多浏览器兼容性测试解决方案")])]),r("p",[r("a",{attrs:{href:"http://jsperf.com",target:"_blank"}},[n._v("js性能测试")])]),r("p",[n._v("前端架构")]),r("p",[n._v("前端架构 地址")]),r("p",[r("a",{attrs:{href:"http://www.zhihu.com/topic/19612641",target:"_blank"}},[n._v("技术架构")])]),r("p",[r("a",{attrs:{href:"http://saito.im/note/The-Architecture-of-F2E",target:"_blank"}},[n._v("前端架构")])]),r("p",[r("a",{attrs:{href:"http://www.zhihu.com/question/24092572",target:"_blank"}},[n._v("如何成为前端架构师")])]),r("p",[r("a",{attrs:{href:"http://hikejun.com/sharing/2010webrebuild/?file=fe-infrastructure.html",target:"_blank"}},[n._v("关于前端架构-张克军")])]),r("p",[r("a",{attrs:{href:"http://www.zhihu.com/question/25583350",target:"_blank"}},[n._v("百度腾讯offer比较（腾讯游戏VS百度基础架构）")])]),r("p",[n._v("推荐作品")]),r("p",[n._v("推荐作品 地址")]),r("p",[r("a",{attrs:{href:"https://gist.github.com/wintercn",target:"_blank"}},[n._v("winter代码片段需要FQ")])]),r("p",[r("a",{attrs:{href:"http://www.fgm.cc/learn",target:"_blank"}},[n._v("fgm")])]),r("p",[r("a",{attrs:{href:"https://github.com/hongru/hongru.github.com",target:"_blank"}},[n._v("岑安作品集")])]),r("p",[r("a",{attrs:{href:"http://kmdjs.github.io",target:"_blank"}},[n._v("当耐特demo集合")])]),r("p",[r("a",{attrs:{href:"http://www.laoshu133.com/Lab",target:"_blank"}},[n._v("米空格 js作品")])]),r("p",[r("a",{attrs:{href:"http://koen301.github.io",target:"_blank"}},[n._v("myFocus")])]),r("p",[r("a",{attrs:{href:"http://panxuepeng.github.io/seajslib",target:"_blank"}},[n._v("SeaJS组件库")])]),r("p",[r("a",{attrs:{href:"http://yanhaijing.com/myProject",target:"_blank"}},[n._v("颜海镜作品")])]),r("p",[r("a",{attrs:{href:"http://jo2.org/category/myworks",target:"_blank"}},[n._v("脚儿网作品")])]),r("p",[r("a",{attrs:{href:"http://www.cnitblog.com/yemoo/category/3107.html",target:"_blank"}},[n._v("javascript个人作品")])]),r("p",[r("a",{attrs:{href:"http://bbs.miaov.com/forum.php?mod=viewthread&tid=7790",target:"_blank"}},[n._v("妙味的雷东升游戏作品")])]),r("p",[r("a",{attrs:{href:"http://bbs.csdn.net/topics/380227212",target:"_blank"}},[n._v("javascript作品集")])]),r("p",[r("a",{attrs:{href:"https://github.com/TooBug/works",target:"_blank"}},[n._v("云五笔，灰度产生生成工具")])]),r("p",[r("a",{attrs:{href:"http://koen301.github.io",target:"_blank"}},[n._v("项目主页")])]),r("p",[r("a",{attrs:{href:"http://zaole.net",target:"_blank"}},[n._v("个性的作品主页")])]),r("p",[r("a",{attrs:{href:"http://static.tingall.com/v2/player",target:"_blank"}},[n._v("播放器")])]),r("p",[r("a",{attrs:{href:"http://ucren.com/blog/demos",target:"_blank"}},[n._v("ucren js demos 集")])]),r("p",[r("a",{attrs:{href:"http://www.zhinengshe.com/works_list.html",target:"_blank"}},[n._v("智能社")])]),r("p",[r("a",{attrs:{href:"http://demos.shizuwu.cn",target:"_blank"}},[n._v("实例陈列架")])]),r("p",[r("a",{attrs:{href:"http://zoye.sinaapp.com/demo",target:"_blank"}},[n._v("zoye demo")])]),r("p",[r("a",{attrs:{href:"http://lab.yuanwai.wang",target:"_blank"}},[n._v("王员外")])]),r("p",[r("a",{attrs:{href:"http://pingfan1990.sinaapp.com",target:"_blank"}},[n._v("平凡")])]),r("p",[r("a",{attrs:{href:"http://www.lovewebgames.com",target:"_blank"}},[n._v("jyg 游戏案例")])]),r("p",[r("a",{attrs:{href:"http://www.helloweba.com/list.html",target:"_blank"}},[n._v("很多jquery插件")])]),r("p",[r("a",{attrs:{href:"http://www.bujichong.com/sojs/api/index.html",target:"_blank"}},[n._v("不羁虫 - soJs 作品系列")])]),r("p",[r("a",{attrs:{href:"http://frozenui.github.io/case.html",target:"_blank"}},[n._v("frozenui")])]),r("p",[r("a",{attrs:{href:"http://js-game.github.io/othello",target:"_blank"}},[n._v("黑白棋")])]),r("p",[r("a",{attrs:{href:"http://yansm.github.io/fromone/index.html",target:"_blank"}},[n._v("fromone")])]),r("p",[r("a",{attrs:{href:"http://pazguille.me",target:"_blank"}},[n._v("pazguille")])]),r("p",[r("a",{attrs:{href:"https://github.com/zmmbreeze/DeadSimpleVideoPlayer",target:"_blank"}},[n._v("Html5 VideoPlayer")])]),r("p",[r("a",{attrs:{href:"http://a-jie.github.io/Proton/#example",target:"_blank"}},[n._v("Proton 烟花")])]),r("p",[n._v("简历模板")]),r("p",[n._v("简历模板 地址")]),r("p",[r("a",{attrs:{href:"http://learnshare.github.io/about/index.html",target:"_blank"}},[n._v("不错的个人简历")])]),r("p",[r("a",{attrs:{href:"http://hcy2367.github.io/resume",target:"_blank"}},[n._v("简历")])]),r("p",[r("a",{attrs:{href:"http://ncuey.sinaapp.com/CrispElite/",target:"_blank"}},[n._v("张伦")])]),r("p",[r("a",{attrs:{href:"https://github.com/hacke2/ResumeSample",target:"_blank"}},[n._v("简历")])]),r("p",[r("a",{attrs:{href:"http://blog.dandyweng.com/2013/07/how-my-website-was-created",target:"_blank"}},[n._v("翁天信")])]),r("p",[r("a",{attrs:{href:"http://www.webhek.com/misc/interactive-resume",target:"_blank"}},[n._v("动画方式的简历")])]),r("p",[r("a",{attrs:{href:"http://www.linqing07.com/resume.html",target:"_blank"}},[n._v("组件丰富简历")])]),r("p",[r("a",{attrs:{href:"http://www.mojianli.com/resume/view",target:"_blank"}},[n._v("简历池")])]),r("p",[r("a",{attrs:{href:"http://www.haorooms.com/about",target:"_blank"}},[n._v("haorooms博客")])]),r("p",[r("a",{attrs:{href:"http://cv.youngdze.com",target:"_blank"}},[n._v("Justin Young")])]),r("p",[n._v("面试题")]),r("p",[n._v("面试题 地址")]),r("p",[r("a",{attrs:{href:"http://www.nowcoder.com/discuss/3196",target:"_blank"}},[n._v("那几个月在找工作（百度，网易游戏）")])]),r("p",[r("a",{attrs:{href:"http://www.html-js.com/article/1743",target:"_blank"}},[n._v("2014最新面试题")])]),r("p",[r("a",{attrs:{href:"http://www.w3cfuns.com/thread-5598563-2-1.html",target:"_blank"}},[n._v("阿里前端面试题")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/imwtr/p/4685546.html",target:"_blank"}},[n._v("2016校招内推 -- 阿里巴巴前端 -- 三面面试经历")])]),r("p",[r("a",{attrs:{href:"http://www.w3cfuns.com/article-5599657-1-1.html",target:"_blank"}},[n._v("腾讯面试题")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/lvdabao/p/3660707.html",target:"_blank"}},[n._v("年后跳槽那点事：乐视+金山+360面试之行")])]),r("p",[r("a",{attrs:{href:"http://fatesinger.com/2722.html",target:"_blank"}},[n._v("阿里前端面试题上线")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/52cik/p/js-question-lg.html",target:"_blank"}},[n._v("拉勾网js面试题")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/allenxing/p/3724382.html",target:"_blank"}},[n._v("前端面试")])]),r("p",[r("a",{attrs:{href:"http://mianshiti.diandian.com",target:"_blank"}},[n._v("Web开发笔试面试题 大全")])]),r("p",[r("a",{attrs:{href:"http://segmentfault.com/a/1190000000465431",target:"_blank"}},[n._v("前端开发面试题")])]),r("p",[r("a",{attrs:{href:"https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions",target:"_blank"}},[n._v("2014最新前端面试题")])]),r("p",[r("a",{attrs:{href:"https://github.com/fex-team/interview-questions",target:"_blank"}},[n._v("百度面试")])]),r("p",[r("a",{attrs:{href:"http://www.w3cfuns.com/forum.php?mod=forumdisplay&fid=51&filter=typeid&typeid=177",target:"_blank"}},[n._v("面试题")])]),r("p",[r("a",{attrs:{href:"https://github.com/darcyclarke/Front-end-Developer-Interview-Questions/tree/master/Chinese",target:"_blank"}},[n._v("前端工作面试问题")])]),r("p",[r("a",{attrs:{href:"http://segmentfault.com/a/1190000000465431",target:"_blank"}},[n._v("前端开发面试题")])]),r("p",[n._v("5个经典的前端面试问题 5个经典的前端面试问题")]),r("p",[r("a",{attrs:{href:"http://segmentfault.com/a/1190000002562454",target:"_blank"}},[n._v("最全前端面试问题及答案总结")])]),r("p",[r("a",{attrs:{href:"http://www.html-js.com/article/Large-search-front-team-column%202961",target:"_blank"}},[n._v("如何面试一名前端开发工程师？")])]),r("p",[r("a",{attrs:{href:"https://github.com/hawx1993/Front-end-Interview-questions",target:"_blank"}},[n._v("史上最全 前端开发面试问题及答案整理")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/xiaoruo/p/4665163.html",target:"_blank"}},[n._v("前端实习生面试总结")])]),r("p",[r("a",{attrs:{href:"https://github.com/hawx1993/Front-end-Interview-questions",target:"_blank"}},[n._v("史上最全 前端开发面试问题及答案整理")])]),r("p",[r("a",{attrs:{href:"http://blog.jobbole.com/78738",target:"_blank"}},[n._v("BAT及各大互联网公司2014前端笔试面试题：JavaScript篇")])]),r("p",[r("a",{attrs:{href:"https://github.com/paddingme/Front-end-Web-Development-Interview-Question",target:"_blank"}},[n._v("前端开发面试题大收集")])]),r("p",[r("a",{attrs:{href:"https://github.com/qiu-deqing/FE-interview",target:"_blank"}},[n._v("收集的前端面试题和答案")])]),r("p",[r("a",{attrs:{href:"http://www.zhihu.com/question/19568008",target:"_blank"}},[n._v("如何面试前端工程师")])]),r("p",[r("a",{attrs:{href:"https://github.com/markyun/My-blog/blob/master/Front-end-Developer-Questions/Questions-and-Answers/README.md",target:"_blank"}},[n._v("前端开发面试题")])]),r("p",[r("a",{attrs:{href:"http://www.nowcoder.com/discuss?type=2",target:"_blank"}},[n._v("牛客网-笔试面经")])]),r("p",[n._v("iconfont")]),r("p",[n._v("iconfont 地址")]),r("p",[r("a",{attrs:{href:"http://www.zhihu.com/question/21253343",target:"_blank"}},[n._v("中文字体")])]),r("p",[r("a",{attrs:{href:"http://iconfont.cn",target:"_blank"}},[n._v("淘宝字库")])]),r("p",[r("a",{attrs:{href:"http://mux.alimama.com/fonts",target:"_blank"}},[n._v("字体")])]),r("p",[r("a",{attrs:{href:"http://iconfont.cn/help/platform.html",target:"_blank"}},[n._v("制作教程")])]),r("p",[r("a",{attrs:{href:"http://www.zhangxinxu.com/wordpress/?s=icomoon",target:"_blank"}},[n._v("zhangxinxu-icommon")])]),r("p",[r("a",{attrs:{href:"https://icomoon.io/app",target:"_blank"}},[n._v("icommon")])]),r("p",[r("a",{attrs:{href:"http://imooc.com/learn/243",target:"_blank"}},[n._v("用字体在网页中画ICON图标(推荐教程")])]),r("p",[r("a",{attrs:{href:"http://font-spider.org",target:"_blank"}},[n._v("字体压缩工具")])]),r("p",[n._v("Fiddler")]),r("p",[n._v("Fiddler 地址")]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/tugenhua0707/p/4623317.html",target:"_blank"}},[n._v("Fiddler调式使用知多少(一深入研究")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/strick/p/4570006.html",target:"_blank"}},[n._v("微信fiddle")])]),r("p",[r("a",{attrs:{href:"http://gaoboy.com/article/26.html",target:"_blank"}},[n._v("微信fiddle")])]),r("p",[n._v("Chrome")]),r("p",[n._v("Chrome 地址")]),r("p",[r("a",{attrs:{href:"https://developer.chrome.com/devtools",target:"_blank"}},[n._v("Google Chrome 官方")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/constantince/p/4565261.html",target:"_blank"}},[n._v("Chrome - 基础")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/constantince/p/4579121.html",target:"_blank"}},[n._v("Chrome - 进阶")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/constantince/p/4585983.html",target:"_blank"}},[n._v("Chrome - 性能")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/constantince/p/4607497.html",target:"_blank"}},[n._v("Chrome - 性能进阶")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/constantince/p/4624241.html",target:"_blank"}},[n._v("Chrome - 移动")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/liyunhua/p/4544738.html",target:"_blank"}},[n._v("Chrome - 使用技巧")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/Wayou/p/chrome-console-tips-and-tricks.html",target:"_blank"}},[n._v("Chrome -\n                    Console控制台不完全指南")])]),r("p",[r("a",{attrs:{href:"http://c7sky.com/chrome-devtools-workspace.html",target:"_blank"}},[n._v("Chrome - Workspace使浏览器变成IDE")])]),r("p",[r("a",{attrs:{href:"http://www.html-js.com/article/Nothing-blind%202975",target:"_blank"}},[n._v("network面板")])]),r("p",[r("a",{attrs:{href:"http://anti-code.com/devtools-cheatsheet",target:"_blank"}},[n._v("chrome开发工具快捷键")])]),r("p",[r("a",{attrs:{href:"http://www.html-js.com/article/2327",target:"_blank"}},[n._v("chrome调试工具常用功能整理")])]),r("p",[r("a",{attrs:{href:"http://www.iinterest.net/2014/05/09/chrome-dev-tool-workspace",target:"_blank"}},[n._v("Chrome 开发工具 Workspace\n                    使用")])]),r("p",[r("a",{attrs:{href:"http://www.cppblog.com/deercoder/archive/2011/10/22/158886.html",target:"_blank"}},[n._v("Chrome神器Vimium快捷键学习记录")])]),r("p",[r("a",{attrs:{href:"http://www.w3cplus.com/sassguide/debug.html",target:"_blank"}},[n._v("sass调试-w3cplus")])]),r("p",[r("a",{attrs:{href:"http://www.w3cplus.com/tools/how-to-use-chrome-devtools-like-a-pro.html",target:"_blank"}},[n._v("如何更专业的使用Chrome开发者工具-w3cplus")])]),r("p",[r("a",{attrs:{href:"http://sentsin.com/web/253.html",target:"_blank"}},[n._v("chrome调试canvas")])]),r("p",[r("a",{attrs:{href:"https://developer.chrome.com/devtools/index",target:"_blank"}},[n._v("chrome profiles1")])]),r("p",[r("a",{attrs:{href:"http://h5dev.uc.cn/article-25-1.html",target:"_blank"}},[n._v("chrome profiles2")])]),r("p",[r("a",{attrs:{href:"http://www.oschina.net/translate/performance-optimisation-with-timeline-profiles",target:"_blank"}},[n._v("chrome profiles3")])]),r("p",[r("a",{attrs:{href:"https://developer.chrome.com/devtools/docs/mobile-emulation",target:"_blank"}},[n._v("chrome移动版调试")])]),r("p",[r("a",{attrs:{href:"http://ued.taobao.org/blog/2012/06/debug-with-chrome-dev-tool",target:"_blank"}},[n._v("chrome调试")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/QLeelulu/archive/2011/08/28/2156402.html",target:"_blank"}},[n._v("chrome的调试")])]),r("p",[r("a",{attrs:{href:"https://developer.chrome.com/devtools/docs/commandline-api",target:"_blank"}},[n._v("chrome console 命令详解")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/leonkao/p/3809655.html",target:"_blank"}},[n._v("查看事件绑定1")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/xiaoyao2011/p/3447421.html",target:"_blank"}},[n._v("查看事件绑定2")])]),r("p",[r("a",{attrs:{href:"http://segmentfault.com/a/1190000000683599",target:"_blank"}},[n._v("神器——Chrome开发者工具(一")])]),r("p",[r("a",{attrs:{href:"https://xinranliu.me/2015-05-22-qiqu-performance",target:"_blank"}},[n._v("奇趣百科性能优化(Chrome DevTools 中的\n                    Timeline Profils 等工具使用介绍")])]),r("p",[r("a",{attrs:{href:"http://frontenddev.org/link/15-tips-of-chrome-developer-tools.html",target:"_blank"}},[n._v("chrome 开发者工具的 15\n                    个小技巧")])]),r("p",[r("a",{attrs:{href:"http://1ke.co/course/361",target:"_blank"}},[n._v("Chrome开发者工具不完全指南")])]),r("p",[r("a",{attrs:{href:"http://segmentfault.com/a/1190000003882567",target:"_blank"}},[n._v("Chrome 开发者工具使用技巧")])]),r("p",[n._v("Firebug")]),r("p",[n._v("Firebug 地址")]),r("p",[r("a",{attrs:{href:"http://www.imooc.com/learn/137",target:"_blank"}},[n._v("firebug视频教程")])]),r("p",[r("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Tools/WebIDE",target:"_blank"}},[n._v("firefox 模拟器")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/ctriphire/p/4116207.html",target:"_blank"}},[n._v("console.log 命令详解")])]),r("p",[r("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2008/06/firebug_tutorial.html",target:"_blank"}},[n._v("Firebug入门指南")])]),r("p",[r("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2011/03/firebug_console_tutorial.html",target:"_blank"}},[n._v("Firebug控制台详解")])]),r("p",[n._v("移动,微信调试")]),r("p",[n._v("移动,微信调试 地址")]),r("p",[r("a",{attrs:{href:"https://openstf.github.io",target:"_blank"}},[n._v("浏览器端调试安卓")])]),r("p",[r("a",{attrs:{href:"http://yujiangshui.com/multidevice-frontend-debug",target:"_blank"}},[n._v("移动端前端开发调试")])]),r("p",[r("a",{attrs:{href:"https://github.com/yujiangshui/CN-Chrome-DevTools/blob/remote-debugging/md/Use-Tools/remote-debugging.md",target:"_blank"}},[n._v("使用 Chrome 远程调试 Android 设备")])]),r("p",[r("a",{attrs:{href:"http://plus.uc.cn/document/webapp/doc5.html",target:"_blank"}},[n._v("mac移动端调试")])]),r("p",[r("a",{attrs:{href:"http://www.mihtool.com",target:"_blank"}},[n._v("mac移动端调试")])]),r("p",[r("a",{attrs:{href:"http://thx.github.io/mobile/debugging-in-mobile",target:"_blank"}},[n._v("无线调试攻略")])]),r("p",[r("a",{attrs:{href:"http://yanhaijing.com/mobile/2014/12/17/web-debug-for-mobile",target:"_blank"}},[n._v("无线调试攻略")])]),r("p",[r("a",{attrs:{href:"http://www.jianshu.com/p/ccf124f1f74b",target:"_blank"}},[n._v("屌爆了,完美调试 微信webview(x5")])]),r("p",[n._v("微信调试的那些事 微信调试的那些事")]),r("p",[r("a",{attrs:{href:"http://jsconsole.com",target:"_blank"}},[n._v("远程console")])]),r("p",[r("a",{attrs:{href:"http://blog.qqbrowser.cc",target:"_blank"}},[n._v("微信调试工具")])]),r("p",[r("a",{attrs:{href:"https://github.com/jieyou/remote_inspect_web_on_real_device",target:"_blank"}},[n._v("各种真机远程调试方法汇总")])]),r("p",[n._v("iOS Simulator")]),r("p",[n._v("iOS Simulator 地址")]),r("p",[n._v("Simulator iOS_Simulator_Guide-Introduction")]),r("p",[r("a",{attrs:{href:"http://www.crifan.com/intro_ios_simulator_in_xcode_and_usage_summary",target:"_blank"}},[n._v("iOS\n                    Simulator的介绍和使用心得")])]),r("p",[n._v("img")]),r("p",[n._v("img 地址")]),r("p",[r("a",{attrs:{href:"http://preloaders.net/en/circular",target:"_blank"}},[n._v("loading img")])]),r("p",[r("a",{attrs:{href:"http://zhitu.isux.us",target:"_blank"}},[n._v("智图-图片优化平台")])]),r("p",[r("a",{attrs:{href:"https://tinypng.com",target:"_blank"}},[n._v("在线png优化")])]),r("p",[n._v("生成二维码")]),r("p",[n._v("生成二维码 地址")]),r("p",[r("a",{attrs:{href:"http://cli.im",target:"_blank"}},[n._v("生成二维码")])]),r("p",[n._v("浏览器同步")]),r("p",[n._v("浏览器同步 地址")]),r("p",[r("a",{attrs:{href:"https://github.com/leeluolee/puer",target:"_blank"}},[n._v("puer")])]),r("p",[r("a",{attrs:{href:"http://livereload.com",target:"_blank"}},[n._v("liveReload")])]),r("p",[r("a",{attrs:{href:"http://getf5.com",target:"_blank"}},[n._v("f5")])]),r("p",[r("a",{attrs:{href:"http://geek100.com/2608",target:"_blank"}},[n._v("File Watchers")])]),r("p",[n._v("在线PPT制作")]),r("p",[n._v("在线PPT制作 地址")]),r("p",[n._v("nodePPT nodePPT")]),r("p",[r("a",{attrs:{href:"http://www.jeffjade.com/2015/10/15/2015-10-16-cleaver-make-ppt/",target:"_blank"}},[n._v("Cleaver快速制作网页PPT")])]),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/Darren_code/archive/2013/01/04/impressjs.html",target:"_blank"}},[n._v("impress.js")])]),r("p",[r("a",{attrs:{href:"https://github.com/ksky521/nodePPT",target:"_blank"}},[n._v("PPT")])]),r("p",[r("a",{attrs:{href:"https://github.com/hakimel/reveal.js",target:"_blank"}},[n._v("reveal")])]),r("p",[r("a",{attrs:{href:"https://github.com/Seldaek/slippy",target:"_blank"}},[n._v("slippy")])]),r("p",[n._v("前端导航网站")]),r("p",[n._v("前端导航网站 地址")]),r("p",[r("a",{attrs:{href:"http://uxbees.com/index.html",target:"_blank"}},[n._v("界面清爽的前端导航")])]),r("p",[r("a",{attrs:{href:"http://whycss.com",target:"_blank"}},[n._v("前端导航")])]),r("p",[r("a",{attrs:{href:"http://www.daqianduan.com/nav",target:"_blank"}},[n._v("前端网址导航")])]),r("p",[r("a",{attrs:{href:"http://sentsin.com/daohang",target:"_blank"}},[n._v("前端名录")])]),r("p",[r("a",{attrs:{href:"http://123.jser.us",target:"_blank"}},[n._v("前端导航")])]),r("p",[r("a",{attrs:{href:"http://www.css88.com/nav",target:"_blank"}},[n._v("前端开发资源")])]),r("p",[r("a",{attrs:{href:"http://www.haourl.cn",target:"_blank"}},[n._v("网址导航")])]),r("p",[r("a",{attrs:{href:"http://code.ciaoca.com",target:"_blank"}},[n._v("前端开发仓库 - 众多效果的收集地")])]),r("p",[r("a",{attrs:{href:"https://github.com/jnoodle/f2e-collect",target:"_blank"}},[n._v("前端资源导航")])]),r("p",[r("a",{attrs:{href:"http://f2e.im/static/pages/nav/index.html",target:"_blank"}},[n._v("F2E 前端导航")])]),r("p",[n._v("常用CDN")])])}],gl={},bl=gl,hl=(r("740a"),Object(m["a"])(bl,ml,dl,!1,null,"49488d6a",null)),yl=hl.exports,fl={mixins:[k["c"]],components:{m1:Mi,m2:Ai,m3:Ui,m4:zi,m5:Zi,m6:ol,m7:ul,m8:yl},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"git",value:"m1"},{label:"webpack",value:"m2"},{label:"nginx",value:"m3"},{label:"基本",value:"m4"},{label:"基本",value:"m5"},{label:"基本",value:"m6"},{label:"基本",value:"m7"},{label:"基本",value:"m8"}]}}},vl=fl,Sl=Object(m["a"])(vl,Si,_i,!1,null,"2d28d51c",null),_l=Sl.exports,kl=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[r(""+n.tab,{tag:"component"})],1)},jl=[],wl=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent1}}),r("q-markdown",{attrs:{src:n.MainComponent2}}),r("q-markdown",{attrs:{src:n.MainComponent3}}),r("q-markdown",{attrs:{src:n.MainComponent4}}),r("q-markdown",{attrs:{src:n.MainComponent5}}),r("q-markdown",{attrs:{src:n.MainComponent6}}),r("q-markdown",{attrs:{src:n.MainComponent7}})],1)},xl=[],Tl='# 基础类型\n\n## 介绍\n\n为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。\n\n## Boolean\n\n最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做`boolean`（其它语言中也一样）。\n\n```typescript\nlet isDone: boolean = false;\n```\n\n## Number\n\n和JavaScript一样，TypeScript里的所有数字都是浮点数或者大整数 。 这些浮点数的类型是`number`， 而大整数的类型则是 `bigint`。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。\n\n```typescript\nlet decLiteral: number = 6;\nlet hexLiteral: number = 0xf00d;\nlet binaryLiteral: number = 0b1010;\nlet octalLiteral: number = 0o744;\nlet bigLiteral: bigint = 100n;\n```\n\n## String\n\nJavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用`string`表示文本数据类型。 和JavaScript一样，可以使用双引号（`"`）或单引号（`\'`）表示字符串。\n\n```typescript\nlet name: string = "bob";\nname = "smith";\n```\n\n你还可以使用_模版字符串_，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（````` ），并且以`${ expr }`这种形式嵌入表达式\n\n```typescript\nlet name: string = `Gene`;\nlet age: number = 37;\nlet sentence: string = `Hello, my name is ${ name }.\n\nI\'ll be ${ age + 1 } years old next month.`;\n```\n\n这与下面定义`sentence`的方式效果相同：\n\n```typescript\nlet sentence: string = "Hello, my name is " + name + ".\\n\\n" +\n    "I\'ll be " + (age + 1) + " years old next month.";\n```\n\n## Array\n\nTypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上`[]`，表示由此类型元素组成的一个数组：\n\n```typescript\nlet list: number[] = [1, 2, 3];\n```\n\n第二种方式是使用数组泛型，`Array<元素类型>`：\n\n```typescript\nlet list: Array<number> = [1, 2, 3];\n```\n\n## Tuple\n\n元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。比如，你可以定义一对值分别为`string`和`number`类型的元组。\n\n```typescript\n// Declare a tuple type\nlet x: [string, number];\n// Initialize it\nx = [\'hello\', 10]; // OK\n// Initialize it incorrectly\nx = [10, \'hello\']; // Error\n```\n\n当访问一个已知索引的元素，会得到正确的类型：\n\n```typescript\nconsole.log(x[0].substr(1)); // OK\nconsole.log(x[1].substr(1)); // Error, \'number\' does not have \'substr\'\n```\n\n当访问一个越界的元素会报错。\n\n```typescript\nx[3] = "world"; // Error, Property \'3\' does not exist on type \'[string, number]\'.\n\nconsole.log(x[5].toString()); // Error, Property \'5\' does not exist on type \'[string, number]\'.\n```\n\n## Enum\n\n`enum`类型是对JavaScript标准数据类型的一个补充。 像C\\#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。\n\n```typescript\nenum Color {Red, Green, Blue}\nlet c: Color = Color.Green;\n```\n\n默认情况下，从`0`开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从`1`开始编号：\n\n```typescript\nenum Color {Red = 1, Green, Blue}\nlet c: Color = Color.Green;\n```\n\n或者，全部都采用手动赋值：\n\n```typescript\nenum Color {Red = 1, Green = 2, Blue = 4}\nlet c: Color = Color.Green;\n```\n\n枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：\n\n```typescript\nenum Color {Red = 1, Green, Blue}\nlet colorName: string = Color[2];\n\nconsole.log(colorName);  // 显示\'Green\'因为上面代码里它的值是2\n```\n\n## Unknown\n\n当我们在写应用的时候可能会需要描述一个我们还不知道其类型的变量。这些值可以来自动态内容，例如从用户获得，或者我们想在我们的 API 中接收所有可能类型的值。在这些情况下，我们想要让编译器以及未来的用户知道这个变量可以是任意类型。这个时候我们会对它使用 `unknown` 类型。\n\n```typescript\nlet notSure: unknown = 4;\nnotSure = "maybe a string instead";\n\n// OK, definitely a boolean\nnotSure = false;\n```\n\n如果你有一个 `unknwon` 类型的变量，你可以通过进行 `typeof` 、比较或者更高级的类型检查来将其的类型范围缩小，这些方法会在后续章节中进一步讨论：\n\n```typescript\n// @errors: 2322 2322 2322\ndeclare const maybe: unknown;\n// \'maybe\' could be a string, object, boolean, undefined, or other types\nconst aNumber: number = maybe;\n\nif (maybe === true) {\n  // TypeScript knows that maybe is a boolean now\n  const aBoolean: boolean = maybe;\n  // So, it cannot be a string\n  const aString: string = maybe;\n}\n\nif (typeof maybe === "string") {\n  // TypeScript knows that maybe is a string\n  const aString: string = maybe;\n  // So, it cannot be a boolean\n  const aBoolean: boolean = maybe;\n}\n```\n\n## Any\n\n有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用`any`类型来标记这些变量：\n\n```typescript\nlet notSure: any = 4;\nnotSure = "maybe a string instead";\nnotSure = false; // okay, definitely a boolean\n```\n\n在对现有代码进行改写的时候，`any`类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为`Object`有相似的作用，就像它在其它语言中那样。 但是`Object`类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：\n\n```typescript\nlet notSure: any = 4;\nnotSure.ifItExists(); // okay, ifItExists might exist at runtime\nnotSure.toFixed(); // okay, toFixed exists (but the compiler doesn\'t check)\n\nlet prettySure: Object = 4;\nprettySure.toFixed(); // Error: Property \'toFixed\' doesn\'t exist on type \'Object\'.\n```\n\n> 注意：应避免使用`Object`，而是使用非原始`object`类型，正如[Do\'s and Don\'ts](../doc/handbook/declaration%20files/Do\'s%20and%20Don\'ts.md)里所讲的那样。\n\n当你只知道一部分数据的类型时，`any`类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：\n\n```typescript\nlet list: any[] = [1, true, "free"];\n\nlist[1] = 100;\n```\n\n## Void\n\n某种程度上来说，`void`类型像是与`any`类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是`void`：\n\n```typescript\nfunction warnUser(): void {\n    console.log("This is my warning message");\n}\n```\n\n声明一个`void`类型的变量没有什么大用，因为你只能为它赋予`null`（只在`--strictNullChecks`未指定时）和`undefined`：\n\n```typescript\nlet unusable: void = undefined;\n```\n\n## Null 和 Undefined\n\nTypeScript里，`undefined`和`null`两者各自有自己的类型分别叫做`undefined`和`null`。 和`void`相似，它们的本身的类型用处不是很大：\n\n```typescript\n// Not much else we can assign to these variables!\nlet u: undefined = undefined;\nlet n: null = null;\n```\n\n默认情况下`null`和`undefined`是所有类型的子类型。 就是说你可以把`null`和`undefined`赋值给`number`类型的变量。\n\n然而，当你指定了`--strictNullChecks`标记，`null`和`undefined`只能赋值给`any`和它们各自的类型（有一个例外是`undefined`还可以赋值给`void`类型）。 这能避免_很多_常见的问题。 也许在某处你想传入一个`string`或`null`或`undefined`，你可以使用联合类型`string | null | undefined`。\n\n联合类型是高级主题，我们会在以后的章节里讨论它。\n\n> 注意：我们鼓励尽可能地使用`--strictNullChecks`，但在本手册里我们假设这个标记是关闭的。\n\n## Never\n\n`never`类型表示的是那些永不存在的值的类型。 例如，`never`类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是`never`类型，当它们被永不为真的类型保护所约束时。\n\n`never`类型是任何类型的子类型，也可以赋值给任何类型；然而，_没有_类型是`never`的子类型或可以赋值给`never`类型（除了`never`本身之外）。 即使`any`也不可以赋值给`never`。\n\n下面是一些返回`never`类型的函数：\n\n```typescript\n// 返回never的函数必须存在无法达到的终点\nfunction error(message: string): never {\n    throw new Error(message);\n}\n\n// 推断的返回值类型为never\nfunction fail() {\n    return error("Something failed");\n}\n\n// 返回never的函数必须存在无法达到的终点\nfunction infiniteLoop(): never {\n    while (true) {\n    }\n}\n```\n\n## Object\n\n`object`表示非原始类型，也就是除`number`，`string`，`boolean`，`bigint`，`symbol`，`null`或`undefined`之外的类型。\n\n使用`object`类型，就可以更好的表示像`Object.create`这样的API。例如：\n\n```typescript\ndeclare function create(o: object | null): void;\n\ncreate({ prop: 0 }); // OK\ncreate(null); // OK\n\ncreate(42); // Error\ncreate("string"); // Error\ncreate(false); // Error\ncreate(undefined); // Error\n```\n\n## 类型断言\n\n有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。\n\n通过_类型断言_这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。\n\n类型断言有两种形式。 其一是“尖括号”语法：\n\n```typescript\nlet someValue: any = "this is a string";\n\nlet strLength: number = (<string>someValue).length;\n```\n\n另一个为`as`语法：\n\n```typescript\nlet someValue: any = "this is a string";\n\nlet strLength: number = (someValue as string).length;\n```\n\n两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有`as`语法断言是被允许的。\n\n## 关于`let`\n\n你可能已经注意到了，我们使用`let`关键字来代替大家所熟悉的JavaScript关键字`var`。 `let`是ES2015引入的关键字，它比`var`更加安全，因此被看做是声明变量的标准方式。 我们会在以后详细介绍它，很多常见的问题都可以通过使用`let`来解决，所以尽可能地使用`let`来代替`var`吧。\n\n## 关于 Number, String, Boolean, Symbol 和 Object\n\n我们很容易会认为 `Number`、 `String`、 `Boolean`、`Symbol` 以及 `Object` 这些类型和我们以上推荐的小写版本的类型是一样的。但这些类型不属于语言的基本类型，并且几乎在任何时候都不应该被用作一个类型：\n\n```typescript\n// @errors: 2339\nfunction reverse(s: String): String {\n  return s.split("").reverse().join("");\n}\n\nreverse("hello world");\n```\n\n相对地，我们应该使用 `number`、`string`、`boolean`、`object` 和 `symbol`\n\n```typescript\nfunction reverse(s: string): string {\n  return s.split("").reverse().join("");\n}\n\nreverse("hello world");\n```\n\n',Cl='# 类\n\n## 介绍\n\n传统的JavaScript程序使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员来讲就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从ECMAScript 2015，也就是ECMAScript 6开始，JavaScript程序员将能够使用基于类的面向对象的方式。 使用TypeScript，我们允许开发者现在就使用这些特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，而不需要等到下个JavaScript版本。\n\n## 类\n\n下面看一个使用类的例子：\n\n```typescript\nclass Greeter {\n    greeting: string;\n    constructor(message: string) {\n        this.greeting = message;\n    }\n    greet() {\n        return "Hello, " + this.greeting;\n    }\n}\n\nlet greeter = new Greeter("world");\n```\n\n如果你使用过C\\#或Java，你会对这种语法非常熟悉。 我们声明一个`Greeter`类。这个类有3个成员：一个叫做`greeting`的属性，一个构造函数和一个`greet`方法。\n\n你会注意到，我们在引用任何一个类成员的时候都用了`this`。 它表示我们访问的是类的成员。\n\n最后一行，我们使用`new`构造了`Greeter`类的一个实例。 它会调用之前定义的构造函数，创建一个`Greeter`类型的新对象，并执行构造函数初始化它。\n\n## 继承\n\n在TypeScript里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。\n\n看下面的例子：\n\n```typescript\nclass Animal {\n    move(distanceInMeters: number = 0) {\n        console.log(`Animal moved ${distanceInMeters}m.`);\n    }\n}\n\nclass Dog extends Animal {\n    bark() {\n        console.log(\'Woof! Woof!\');\n    }\n}\n\nconst dog = new Dog();\ndog.bark();\ndog.move(10);\ndog.bark();\n```\n\n这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里，`Dog`是一个_派生类_，它派生自`Animal`_基类_，通过`extends`关键字。 派生类通常被称作_子类_，基类通常被称作_超类_。\n\n因为`Dog`继承了`Animal`的功能，因此我们可以创建一个`Dog`的实例，它能够`bark()`和`move()`。\n\n下面我们来看个更加复杂的例子。\n\n```typescript\nclass Animal {\n    name: string;\n    constructor(theName: string) { this.name = theName; }\n    move(distanceInMeters: number = 0) {\n        console.log(`${this.name} moved ${distanceInMeters}m.`);\n    }\n}\n\nclass Snake extends Animal {\n    constructor(name: string) { super(name); }\n    move(distanceInMeters = 5) {\n        console.log("Slithering...");\n        super.move(distanceInMeters);\n    }\n}\n\nclass Horse extends Animal {\n    constructor(name: string) { super(name); }\n    move(distanceInMeters = 45) {\n        console.log("Galloping...");\n        super.move(distanceInMeters);\n    }\n}\n\nlet sam = new Snake("Sammy the Python");\nlet tom: Animal = new Horse("Tommy the Palomino");\n\nsam.move();\ntom.move(34);\n```\n\n这个例子展示了一些上面没有提到的特性。 这一次，我们使用`extends`关键字创建了`Animal`的两个子类：`Horse`和`Snake`。\n\n与前一个例子的不同点是，派生类包含了一个构造函数，它_必须_调用`super()`，它会执行基类的构造函数。 而且，在构造函数里访问`this`的属性之前，我们_一定_要调用`super()`。 这个是TypeScript强制执行的一条重要规则。\n\n这个例子演示了如何在子类里可以重写父类的方法。 `Snake`类和`Horse`类都创建了`move`方法，它们重写了从`Animal`继承来的`move`方法，使得`move`方法根据不同的类而具有不同的功能。 注意，即使`tom`被声明为`Animal`类型，但因为它的值是`Horse`，调用`tom.move(34)`时，它会调用`Horse`里重写的方法：\n\n```text\nSlithering...\nSammy the Python moved 5m.\nGalloping...\nTommy the Palomino moved 34m.\n```\n\n## 公共，私有与受保护的修饰符\n\n### 默认为`public`\n\n在上面的例子里，我们可以自由的访问程序里定义的成员。 如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用`public`来做修饰；例如，C\\#要求必须明确地使用`public`指定成员是可见的。 在TypeScript里，成员都默认为`public`。\n\n你也可以明确的将一个成员标记成`public`。 我们可以用下面的方式来重写上面的`Animal`类：\n\n```typescript\nclass Animal {\n    public name: string;\n    public constructor(theName: string) { this.name = theName; }\n    public move(distanceInMeters: number) {\n        console.log(`${this.name} moved ${distanceInMeters}m.`);\n    }\n}\n```\n\n### 理解`private`\n\n当成员被标记成`private`时，它就不能在声明它的类的外部访问。比如：\n\n```typescript\nclass Animal {\n    private name: string;\n    constructor(theName: string) { this.name = theName; }\n}\n\nnew Animal("Cat").name; // 错误: \'name\' 是私有的.\n```\n\nTypeScript使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。\n\n然而，当我们比较带有`private`或`protected`成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个`private`成员，那么只有当另外一个类型中也存在这样一个`private`成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于`protected`成员也使用这个规则。\n\n下面来看一个例子，更好地说明了这一点：\n\n```typescript\nclass Animal {\n    private name: string;\n    constructor(theName: string) { this.name = theName; }\n}\n\nclass Rhino extends Animal {\n    constructor() { super("Rhino"); }\n}\n\nclass Employee {\n    private name: string;\n    constructor(theName: string) { this.name = theName; }\n}\n\nlet animal = new Animal("Goat");\nlet rhino = new Rhino();\nlet employee = new Employee("Bob");\n\nanimal = rhino;\nanimal = employee; // 错误: Animal 与 Employee 不兼容.\n```\n\n这个例子中有`Animal`和`Rhino`两个类，`Rhino`是`Animal`类的子类。 还有一个`Employee`类，其类型看上去与`Animal`是相同的。 我们创建了几个这些类的实例，并相互赋值来看看会发生什么。 因为`Animal`和`Rhino`共享了来自`Animal`里的私有成员定义`private name: string`，因此它们是兼容的。 然而`Employee`却不是这样。当把`Employee`赋值给`Animal`的时候，得到一个错误，说它们的类型不兼容。 尽管`Employee`里也有一个私有成员`name`，但它明显不是`Animal`里面定义的那个。\n\n### 理解`protected`\n\n`protected`修饰符与`private`修饰符的行为很相似，但有一点不同，`protected`成员在派生类中仍然可以访问。例如：\n\n```typescript\nclass Person {\n    protected name: string;\n    constructor(name: string) { this.name = name; }\n}\n\nclass Employee extends Person {\n    private department: string;\n\n    constructor(name: string, department: string) {\n        super(name)\n        this.department = department;\n    }\n\n    public getElevatorPitch() {\n        return `Hello, my name is ${this.name} and I work in ${this.department}.`;\n    }\n}\n\nlet howard = new Employee("Howard", "Sales");\nconsole.log(howard.getElevatorPitch());\nconsole.log(howard.name); // 错误\n```\n\n注意，我们不能在`Person`类外使用`name`，但是我们仍然可以通过`Employee`类的实例方法访问，因为`Employee`是由`Person`派生而来的。\n\n构造函数也可以被标记成`protected`。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如，\n\n```typescript\nclass Person {\n    protected name: string;\n    protected constructor(theName: string) { this.name = theName; }\n}\n\n// Employee 能够继承 Person\nclass Employee extends Person {\n    private department: string;\n\n    constructor(name: string, department: string) {\n        super(name);\n        this.department = department;\n    }\n\n    public getElevatorPitch() {\n        return `Hello, my name is ${this.name} and I work in ${this.department}.`;\n    }\n}\n\nlet howard = new Employee("Howard", "Sales");\nlet john = new Person("John"); // 错误: \'Person\' 的构造函数是被保护的.\n```\n\n## readonly修饰符\n\n你可以使用`readonly`关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。\n\n```typescript\nclass Octopus {\n    readonly name: string;\n    readonly numberOfLegs: number = 8;\n    constructor (theName: string) {\n        this.name = theName;\n    }\n}\nlet dad = new Octopus("Man with the 8 strong legs");\ndad.name = "Man with the 3-piece suit"; // 错误! name 是只读的.\n```\n\n### 参数属性\n\n在上面的例子中，我们不得不在在`Person`类里定义一个只读成员`name`和一个构造函数参数`theName`。这样做是为了在`Octopus`构造函数被执行后，就可以访问`theName`的值。 这种情况经常会遇到。_参数属性_可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前`Animal`类的修改版，使用了参数属性：\n\n```typescript\nclass Animal {\n    constructor(private name: string) { }\n    move(distanceInMeters: number) {\n        console.log(`${this.name} moved ${distanceInMeters}m.`);\n    }\n}\n```\n\n注意看我们是如何舍弃了`theName`，仅在构造函数里使用`private name: string`参数来创建和初始化`name`成员。 我们把声明和赋值合并至一处。\n\n参数属性通过给构造函数参数添加一个访问限定符来声明。 使用`private`限定一个参数属性会声明并初始化一个私有成员；对于`public`和`protected`来说也是一样。\n\n## 存取器\n\nTypeScript支持通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。\n\n下面来看如何把一个简单的类改写成使用`get`和`set`。 首先，我们从一个没有使用存取器的例子开始。\n\n```typescript\nclass Employee {\n    fullName: string;\n}\n\nlet employee = new Employee();\nemployee.fullName = "Bob Smith";\nif (employee.fullName) {\n    console.log(employee.fullName);\n}\n```\n\n允许随意设置`fullName`虽然方便，但是我们仍想在设置`fullName`强制执行某些约束。\n\n在这个版本里，我们添加一个`setter`来检查`newName`的长度，以确保它满足数据库字段的最大长度限制。若它不满足，那么我们就抛一个错误来告诉客户端出错了。\n\n为保留原有的功能，我们同时添加一个`getter`用来读取`fullName`。\n\n```typescript\nconst fullNameMaxLength = 10;\n\nclass Employee {\n    private _fullName: string;\n\n    get fullName(): string {\n        return this._fullName;\n    }\n\n    set fullName(newName: string) {\n        if (newName && newName.length > fullNameMaxLength) {\n            throw new Error("fullName has a max length of " + fullNameMaxLength);\n        }\n\n        this._fullName = newName;\n    }\n}\n\nlet employee = new Employee();\nemployee.fullName = "Bob Smith";\nif (employee.fullName) {\n    alert(employee.fullName);\n}\n```\n\n为证明我们写的存取器现在能检查长度，我们可以给名字赋一个长度大于`10`字符的值，并验证是否得到一个错误。\n\n对于存取器有下面几点需要注意的：\n\n首先，存取器要求你将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3。 其次，只带有`get`不带有`set`的存取器自动被推断为`readonly`。 这在从代码生成`.d.ts`文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。\n\n## 静态属性\n\n到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用`static`定义`origin`，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在`origin`前面加上类名。 如同在实例属性上使用`this.`前缀来访问属性一样，这里我们使用`Grid.`来访问静态属性。\n\n```typescript\nclass Grid {\n    static origin = {x: 0, y: 0};\n    calculateDistanceFromOrigin(point: {x: number; y: number;}) {\n        let xDist = (point.x - Grid.origin.x);\n        let yDist = (point.y - Grid.origin.y);\n        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;\n    }\n    constructor (public scale: number) { }\n}\n\nlet grid1 = new Grid(1.0);  // 1x scale\nlet grid2 = new Grid(5.0);  // 5x scale\n\nconsole.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));\nconsole.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10}));\n```\n\n## 抽象类\n\n抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节（抽象类中除抽象函数之外，其他函数可以包含具体实现）。 `abstract`关键字是用于定义抽象类和在抽象类内部定义抽象方法。\n\n```typescript\nabstract class Animal {\n    abstract makeSound(): void;\n    move(): void {\n        console.log("roaming the earth...");\n    }\n}\n```\n\n抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含`abstract`关键字并且可以包含访问修饰符。\n\n```typescript\nabstract class Department {\n\n    constructor(public name: string) {\n    }\n\n    printName(): void {\n        console.log(\'Department name: \' + this.name);\n    }\n\n    abstract printMeeting(): void; // 必须在派生类中实现\n}\n\nclass AccountingDepartment extends Department {\n\n    constructor() {\n        super(\'Accounting and Auditing\'); // 在派生类的构造函数中必须调用 super()\n    }\n\n    printMeeting(): void {\n        console.log(\'The Accounting Department meets each Monday at 10am.\');\n    }\n\n    generateReports(): void {\n        console.log(\'Generating accounting reports...\');\n    }\n}\n\nlet department: Department; // 允许创建一个对抽象类型的引用\ndepartment = new Department(); // 错误: 不能创建一个抽象类的实例\ndepartment = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值\ndepartment.printName();\ndepartment.printMeeting();\ndepartment.generateReports(); // 错误: 方法在声明的抽象类中不存在\n```\n\n## 高级技巧\n\n### 构造函数\n\n当你在TypeScript里声明了一个类的时候，实际上同时声明了很多东西。 首先就是类的_实例_的类型。\n\n```typescript\nclass Greeter {\n    greeting: string;\n    constructor(message: string) {\n        this.greeting = message;\n    }\n    greet() {\n        return "Hello, " + this.greeting;\n    }\n}\n\nlet greeter: Greeter;\ngreeter = new Greeter("world");\nconsole.log(greeter.greet());\n```\n\n这里，我们写了`let greeter: Greeter`，意思是`Greeter`类的实例的类型是`Greeter`。 这对于用过其它面向对象语言的程序员来讲已经是老习惯了。\n\n我们也创建了一个叫做_构造函数_的值。 这个函数会在我们使用`new`创建类实例的时候被调用。 下面我们来看看，上面的代码被编译成JavaScript后是什么样子的：\n\n```typescript\nlet Greeter = (function () {\n    function Greeter(message) {\n        this.greeting = message;\n    }\n    Greeter.prototype.greet = function () {\n        return "Hello, " + this.greeting;\n    };\n    return Greeter;\n})();\n\nlet greeter;\ngreeter = new Greeter("world");\nconsole.log(greeter.greet());\n```\n\n上面的代码里，`let Greeter`将被赋值为构造函数。 当我们调用`new`并执行了这个函数后，便会得到一个类的实例。 这个构造函数也包含了类的所有静态属性。 换个角度说，我们可以认为类具有_实例部分_与_静态部分_这两个部分。\n\n让我们稍微改写一下这个例子，看看它们之间的区别：\n\n```typescript\nclass Greeter {\n    static standardGreeting = "Hello, there";\n    greeting: string;\n    greet() {\n        if (this.greeting) {\n            return "Hello, " + this.greeting;\n        }\n        else {\n            return Greeter.standardGreeting;\n        }\n    }\n}\n\nlet greeter1: Greeter;\ngreeter1 = new Greeter();\nconsole.log(greeter1.greet());\n\nlet greeterMaker: typeof Greeter = Greeter;\ngreeterMaker.standardGreeting = "Hey there!";\n\nlet greeter2: Greeter = new greeterMaker();\nconsole.log(greeter2.greet());\n```\n\n这个例子里，`greeter1`与之前看到的一样。 我们实例化`Greeter`类，并使用这个对象。 与我们之前看到的一样。\n\n再之后，我们直接使用类。 我们创建了一个叫做`greeterMaker`的变量。 这个变量保存了这个类或者说保存了类构造函数。 然后我们使用`typeof Greeter`，意思是取Greeter类的类型，而不是实例的类型。 或者更确切的说，"告诉我`Greeter`标识符的类型"，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。 之后，就和前面一样，我们在`greeterMaker`上使用`new`，创建`Greeter`的实例。\n\n### 把类当做接口使用\n\n如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。\n\n```typescript\nclass Point {\n    x: number;\n    y: number;\n}\n\ninterface Point3d extends Point {\n    z: number;\n}\n\nlet point3d: Point3d = {x: 1, y: 2, z: 3};\n```\n\n',Ml="# 枚举\n\n## 枚举\n\n使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript支持数字的和基于字符串的枚举。\n\n### 数字枚举\n\n首先我们看看数字枚举，如果你使用过其它编程语言应该会很熟悉。\n\n```typescript\nenum Direction {\n    Up = 1,\n    Down,\n    Left,\n    Right\n}\n```\n\n如上，我们定义了一个数字枚举，`Up`使用初始化为`1`。 其余的成员会从`1`开始自动增长。 换句话说，`Direction.Up`的值为`1`，`Down`为`2`，`Left`为`3`，`Right`为`4`。\n\n我们还可以完全不使用初始化器：\n\n```typescript\nenum Direction {\n    Up,\n    Down,\n    Left,\n    Right,\n}\n```\n\n现在，`Up`的值为`0`，`Down`的值为`1`等等。 当我们不在乎成员的值的时候，这种自增长的行为是很有用处的，但是要注意每个枚举成员的值都是不同的。\n\n使用枚举很简单：通过枚举的属性来访问枚举成员，和枚举的名字来访问枚举类型：\n\n```typescript\nenum Response {\n    No = 0,\n    Yes = 1,\n}\n\nfunction respond(recipient: string, message: Response): void {\n    // ...\n}\n\nrespond(\"Princess Caroline\", Response.Yes)\n```\n\n数字枚举可以被混入到[计算过的和常量成员（如下所示）](enums.md#computed-and-constant-members)。 简短地说，没有初始化器的成员要么在首位，要么必须在用数值常量或其他常量枚举成员初始化的数值枚举之后。 换句话说，下面的情况是不被允许的：\n\n```typescript\nenum E {\n    A = getSomeValue(),\n    B, // Error! Enum member must have initializer.\n}\n```\n\n### 字符串枚举\n\n字符串枚举的概念很简单，但是有细微的[运行时的差别](enums.md#enums-at-runtime)。 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。\n\n```typescript\nenum Direction {\n    Up = \"UP\",\n    Down = \"DOWN\",\n    Left = \"LEFT\",\n    Right = \"RIGHT\",\n}\n```\n\n由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。 换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的 - 它并不能表达有用的信息（尽管[反向映射](enums.md#enums-at-runtime)会有所帮助），字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字。\n\n### 异构枚举（Heterogeneous enums）\n\n从技术的角度来说，枚举可以混合字符串和数字成员，但是似乎你并不会这么做：\n\n```typescript\nenum BooleanLikeHeterogeneousEnum {\n    No = 0,\n    Yes = \"YES\",\n}\n```\n\n除非你真的想要利用JavaScript运行时的行为，否则我们不建议这样做。\n\n### 计算的和常量成员\n\n每个枚举成员都带有一个值，它可以是_常量_或_计算出来的_。 当满足如下条件时，枚举成员被当作是常量：\n\n* 它是枚举的第一个成员且没有初始化器，这种情况下它被赋予值`0`：\n\n  ```typescript\n  // E.X is constant:\n  enum E { X }\n  ```\n\n* 它不带有初始化器且它之前的枚举成员是一个_数字_常量。 这种情况下，当前枚举成员的值为它上一个枚举成员的值加1。\n\n  ```typescript\n  // All enum members in 'E1' and 'E2' are constant.\n\n  enum E1 { X, Y, Z }\n\n  enum E2 {\n      A = 1, B, C\n  }\n  ```\n\n* 枚举成员使用_常量枚举表达式_初始化。 常量枚举表达式是TypeScript表达式的子集，它可以在编译阶段求值。 当一个表达式满足下面条件之一时，它就是一个常量枚举表达式：\n\n  1. 一个枚举表达式字面量（主要是字符串字面量或数字字面量）\n  2. 一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的）\n  3. 带括号的常量枚举表达式\n  4. 一元运算符`+`, `-`, `~`其中之一应用在了常量枚举表达式\n  5. 常量枚举表达式做为二元运算符`+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `>>>`, `&`, `|`, `^`的操作对象。\n\n  若常量枚举表达式求值后为`NaN`或`Infinity`，则会在编译阶段报错。\n\n所有其它情况的枚举成员被当作是需要计算得出的值。\n\n```typescript\nenum FileAccess {\n    // constant members\n    None,\n    Read    = 1 << 1,\n    Write   = 1 << 2,\n    ReadWrite  = Read | Write,\n    // computed member\n    G = \"123\".length\n}\n```\n\n### 联合枚举与枚举成员的类型\n\n存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员。 字面量枚举成员是指不带有初始值的常量枚举成员，或者是值被初始化为\n\n* 任何字符串字面量（例如：`\"foo\"`，`\"bar\"`，`\"baz\"`）\n* 任何数字字面量（例如：`1`, `100`）\n* 应用了一元`-`符号的数字字面量（例如：`-1`, `-100`）\n\n当所有枚举成员都拥有字面量枚举值时，它就带有了一种特殊的语义。\n\n首先，枚举成员成为了类型！ 例如，我们可以说某些成员_只能_是枚举成员的值：\n\n```typescript\nenum ShapeKind {\n    Circle,\n    Square,\n}\n\ninterface Circle {\n    kind: ShapeKind.Circle;\n    radius: number;\n}\n\ninterface Square {\n    kind: ShapeKind.Square;\n    sideLength: number;\n}\n\nlet c: Circle = {\n    kind: ShapeKind.Square, // Error! Type 'ShapeKind.Square' is not assignable to type 'ShapeKind.Circle'.\n    radius: 100,\n}\n```\n\n另一个变化是枚举类型本身变成了每个枚举成员的_联合_。 虽然我们还没有讨论[联合类型](advanced-types.md#union-types)，但你只要知道通过联合枚举，类型系统能够利用这样一个事实，它可以知道枚举里的值的集合。 因此，TypeScript能够捕获在比较值的时候犯的愚蠢的错误。 例如：\n\n```typescript\nenum E {\n    Foo,\n    Bar,\n}\n\nfunction f(x: E) {\n    if (x !== E.Foo || x !== E.Bar) {\n        //             ~~~~~~~~~~~\n        // Error! This condition will always return 'true' since the types 'E.Foo' and 'E.Bar' have no overlap.\n    }\n}\n```\n\n这个例子里，我们先检查`x`是否不是`E.Foo`。 如果通过了这个检查，然后`||`会发生短路效果，`if`语句体里的内容会被执行。 然而，这个检查没有通过，那么`x`则_只能_为`E.Foo`，因此没理由再去检查它是否为`E.Bar`。\n\n### 运行时的枚举\n\n枚举是在运行时真正存在的对象。 例如下面的枚举：\n\n```typescript\nenum E {\n    X, Y, Z\n}\n```\n\n可以传递给函数\n\n```typescript\nfunction f(obj: { X: number }) {\n    return obj.X;\n}\n\n// 没问题，因为 'E'包含一个数值型属性'X'。\nf(E);\n```\n\n### 编译时的枚举\n\n尽管一个枚举是在运行时真正存在的对象，但`keyof`关键字的行为与其作用在对象上时有所不同。应该使用`keyof typeof`来获取一个表示枚举里所有字符串`key`的类型。\n\n```typescript\nenum LogLevel {\n    ERROR, WARN, INFO, DEBUG\n}\n\n/**\n * 等同于：\n * type LogLevelStrings = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG';\n */\ntype LogLevelStrings = keyof typeof LogLevel;\n\nfunction printImportant(key: LogLevelStrings, message: string) {\n    const num = LogLevel[key];\n    if (num <= LogLevel.WARN) {\n       console.log('Log level key is: ', key);\n       console.log('Log level value is: ', num);\n       console.log('Log level message is: ', message);\n    }\n}\nprintImportant('ERROR', 'This is a message');\n```\n\n#### 反向映射\n\n除了创建一个以属性名做为对象成员的对象之外，数字枚举成员还具有了_反向映射_，从枚举值到枚举名字。 例如，在下面的例子中：\n\n```typescript\nenum Enum {\n    A\n}\nlet a = Enum.A;\nlet nameOfA = Enum[a]; // \"A\"\n```\n\nTypeScript可能会将这段代码编译为下面的JavaScript：\n\n```javascript\nvar Enum;\n(function (Enum) {\n    Enum[Enum[\"A\"] = 0] = \"A\";\n})(Enum || (Enum = {}));\nvar a = Enum.A;\nvar nameOfA = Enum[a]; // \"A\"\n```\n\n生成的代码中，枚举类型被编译成一个对象，它包含了正向映射（`name` -&gt; `value`）和反向映射（`value` -&gt; `name`）。 引用枚举成员总会生成为对属性访问并且永远也不会内联代码。\n\n要注意的是_不会_为字符串枚举成员生成反向映射。\n\n#### `const`枚举\n\n大多数情况下，枚举是十分有效的方案。 然而在某些情况下需求很严格。 为了避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问，我们可以使用`const`枚举。 常量枚举通过在枚举上使用`const`修饰符来定义。\n\n```typescript\nconst enum Enum {\n    A = 1,\n    B = A * 2\n}\n```\n\n常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。\n\n```typescript\nconst enum Directions {\n    Up,\n    Down,\n    Left,\n    Right\n}\n\nlet directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]\n```\n\n生成后的代码为：\n\n```javascript\nvar directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];\n```\n\n## 外部枚举\n\n外部枚举用来描述已经存在的枚举类型的形状。\n\n```typescript\ndeclare enum Enum {\n    A = 1,\n    B,\n    C = 2\n}\n```\n\n外部枚举和非外部枚举之间有一个重要的区别，在正常的枚举里，没有初始化方法的成员被当成常量成员。 对于非常量的外部枚举而言，没有初始化方法时被当做需要经过计算的。\n\n",Pl='# 函数\n\n## 介绍\n\n函数是JavaScript应用程序的基础。 它帮助你实现抽象层，模拟类，信息隐藏和模块。 在TypeScript里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义_行为_的地方。 TypeScript为JavaScript函数添加了额外的功能，让我们可以更容易地使用。\n\n## 函数\n\n和JavaScript一样，TypeScript函数可以创建有名字的函数和匿名函数。 你可以随意选择适合应用程序的方式，不论是定义一系列API函数还是只使用一次的函数。\n\n通过下面的例子可以迅速回想起这两种JavaScript中的函数：\n\n```typescript\n// Named function\nfunction add(x, y) {\n    return x + y;\n}\n\n// Anonymous function\nlet myAdd = function(x, y) { return x + y; };\n```\n\n在JavaScript里，函数可以使用函数体外部的变量。 当函数这么做时，我们说它‘捕获’了这些变量。 至于为什么可以这样做以及其中的利弊超出了本文的范围，但是深刻理解这个机制对学习JavaScript和TypeScript会很有帮助。\n\n```typescript\nlet z = 100;\n\nfunction addToZ(x, y) {\n    return x + y + z;\n}\n```\n\n## 函数类型\n\n### 为函数定义类型\n\n让我们为上面那个函数添加类型：\n\n```typescript\nfunction add(x: number, y: number): number {\n    return x + y;\n}\n\nlet myAdd = function(x: number, y: number): number { return x + y; };\n```\n\n我们可以给每个参数添加类型之后再为函数本身添加返回值类型。 TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它。\n\n### 书写完整函数类型\n\n现在我们已经为函数指定了类型，下面让我们写出函数的完整类型。\n\n```typescript\nlet myAdd: (x:number, y:number) => number =\n    function(x: number, y: number): number { return x + y; };\n```\n\n函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。 我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。 这个名字只是为了增加可读性。 我们也可以这么写：\n\n```typescript\nlet myAdd: (baseValue: number, increment: number) => number =\n    function(x: number, y: number): number { return x + y; };\n```\n\n只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。\n\n第二部分是返回值类型。 对于返回值，我们在函数和返回值类型之前使用\\(`=>`\\)符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为`void`而不能留空。\n\n函数的类型只是由参数类型和返回值组成的。 函数中使用的捕获变量不会体现在类型里。 实际上，这些变量是函数的隐藏状态并不是组成API的一部分。\n\n### 推断类型\n\n尝试这个例子的时候，你会注意到，就算仅在等式的一侧带有类型，TypeScript编译器仍可正确识别类型：\n\n```typescript\n// myAdd has the full function type\nlet myAdd = function(x: number, y: number): number { return x + y; };\n\n// The parameters `x` and `y` have the type number\nlet myAdd: (baseValue: number, increment: number) => number =\n    function(x, y) { return x + y; };\n```\n\n这叫做“按上下文归类”，是类型推论的一种。 它帮助我们更好地为程序指定类型。\n\n## 可选参数和默认参数\n\nTypeScript里的每个函数参数都是必须的。 这不是指不能传递`null`或`undefined`作为参数，而是说编译器检查用户是否为每个参数都传入了值。 编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。\n\n```typescript\nfunction buildName(firstName: string, lastName: string) {\n    return firstName + " " + lastName;\n}\n\nlet result1 = buildName("Bob");                  // error, too few parameters\nlet result2 = buildName("Bob", "Adams", "Sr.");  // error, too many parameters\nlet result3 = buildName("Bob", "Adams");         // ah, just right\n```\n\nJavaScript里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是undefined。 在TypeScript里我们可以在参数名旁使用`?`实现可选参数的功能。 比如，我们想让last name是可选的：\n\n```typescript\nfunction buildName(firstName: string, lastName?: string) {\n    if (lastName)\n        return firstName + " " + lastName;\n    else\n        return firstName;\n}\n\nlet result1 = buildName("Bob");  // works correctly now\nlet result2 = buildName("Bob", "Adams", "Sr.");  // error, too many parameters\nlet result3 = buildName("Bob", "Adams");  // ah, just right\n```\n\n可选参数必须跟在必须参数后面。 如果上例我们想让first name是可选的，那么就必须调整它们的位置，把first name放在后面。\n\n在TypeScript里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是`undefined`时。 它们叫做有默认初始化值的参数。 让我们修改上例，把last name的默认值设置为`"Smith"`。\n\n```typescript\nfunction buildName(firstName: string, lastName = "Smith") {\n    return firstName + " " + lastName;\n}\n\nlet result1 = buildName("Bob");                  // works correctly now, returns "Bob Smith"\nlet result2 = buildName("Bob", undefined);       // still works, also returns "Bob Smith"\nlet result3 = buildName("Bob", "Adams", "Sr.");  // error, too many parameters\nlet result4 = buildName("Bob", "Adams");         // ah, just right\n```\n\n在所有必须参数后面的带默认初始化的参数都是可选的，与可选参数一样，在调用函数的时候可以省略。 也就是说可选参数与末尾的默认参数共享参数类型。\n\n```typescript\nfunction buildName(firstName: string, lastName?: string) {\n    // ...\n}\n```\n\n和\n\n```typescript\nfunction buildName(firstName: string, lastName = "Smith") {\n    // ...\n}\n```\n\n共享同样的类型`(firstName: string, lastName?: string) => string`。 在函数类型中，默认参数的默认值不会显示，而只会显示它是一个可选参数。\n\n与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入`undefined`值来获得默认值。 例如，我们重写最后一个例子，让`firstName`是带默认值的参数：\n\n```typescript\nfunction buildName(firstName = "Will", lastName: string) {\n    return firstName + " " + lastName;\n}\n\nlet result1 = buildName("Bob");                  // error, too few parameters\nlet result2 = buildName("Bob", "Adams", "Sr.");  // error, too many parameters\nlet result3 = buildName("Bob", "Adams");         // okay and returns "Bob Adams"\nlet result4 = buildName(undefined, "Adams");     // okay and returns "Will Adams"\n```\n\n## 剩余参数\n\n必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在JavaScript里，你可以使用`arguments`来访问所有传入的参数。\n\n在TypeScript里，你可以把所有参数收集到一个变量里：\n\n```typescript\nfunction buildName(firstName: string, ...restOfName: string[]) {\n  return firstName + " " + restOfName.join(" ");\n}\n\nlet employeeName = buildName("Joseph", "Samuel", "Lucas", "MacKinzie");\n```\n\n剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（`...`）后面给定的名字，你可以在函数体内使用这个数组。\n\n这个省略号也会在带有剩余参数的函数类型定义上使用到：\n\n```typescript\nfunction buildName(firstName: string, ...restOfName: string[]) {\n  return firstName + " " + restOfName.join(" ");\n}\n\nlet buildNameFun: (fname: string, ...rest: string[]) => string = buildName;\n```\n\n## `this`\n\n学习如何在JavaScript里正确使用`this`就好比一场成年礼。 由于TypeScript是JavaScript的超集，TypeScript程序员也需要弄清`this`工作机制并且当有bug的时候能够找出错误所在。 幸运的是，TypeScript能通知你错误地使用了`this`的地方。 如果你想了解JavaScript里的`this`是如何工作的，那么首先阅读Yehuda Katz写的[Understanding JavaScript Function Invocation and "this"](http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/)。 Yehuda的文章详细的阐述了`this`的内部工作原理，因此我们这里只做简单介绍。\n\n### `this`和箭头函数\n\nJavaScript里，`this`的值在函数被调用的时候才会指定。 这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。 但众所周知，这不是一件很简单的事，尤其是在返回一个函数或将函数当做参数传递的时候。\n\n下面看一个例子：\n\n```typescript\nlet deck = {\n    suits: ["hearts", "spades", "clubs", "diamonds"],\n    cards: Array(52),\n    createCardPicker: function() {\n        return function() {\n            let pickedCard = Math.floor(Math.random() * 52);\n            let pickedSuit = Math.floor(pickedCard / 13);\n\n            return {suit: this.suits[pickedSuit], card: pickedCard % 13};\n        }\n    }\n}\n\nlet cardPicker = deck.createCardPicker();\nlet pickedCard = cardPicker();\n\nalert("card: " + pickedCard.card + " of " + pickedCard.suit);\n```\n\n可以看到`createCardPicker`是个函数，并且它又返回了一个函数。 如果我们尝试运行这个程序，会发现它并没有弹出对话框而是报错了。 因为`createCardPicker`返回的函数里的`this`被设置成了`window`而不是`deck`对象。 因为我们只是独立的调用了`cardPicker()`。 顶级的非方法式调用会将`this`视为`window`。 （注意：在严格模式下，`this`为`undefined`而不是`window`）。\n\n为了解决这个问题，我们可以在函数被返回时就绑好正确的`this`。 这样的话，无论之后怎么使用它，都会引用绑定的‘deck’对象。 我们需要改变函数表达式来使用ECMAScript 6箭头语法。 箭头函数能保存函数创建时的`this`值，而不是调用时的值：\n\n```typescript\nlet deck = {\n    suits: ["hearts", "spades", "clubs", "diamonds"],\n    cards: Array(52),\n    createCardPicker: function() {\n        // NOTE: the line below is now an arrow function, allowing us to capture \'this\' right here\n        return () => {\n            let pickedCard = Math.floor(Math.random() * 52);\n            let pickedSuit = Math.floor(pickedCard / 13);\n\n            return {suit: this.suits[pickedSuit], card: pickedCard % 13};\n        }\n    }\n}\n\nlet cardPicker = deck.createCardPicker();\nlet pickedCard = cardPicker();\n\nalert("card: " + pickedCard.card + " of " + pickedCard.suit);\n```\n\n更好事情是，TypeScript会警告你犯了一个错误，如果你给编译器设置了`--noImplicitThis`标记。 它会指出`this.suits[pickedSuit]`里的`this`的类型为`any`。\n\n### `this`参数\n\n不幸的是，`this.suits[pickedSuit]`中的`this`的类型依旧为`any`。 这是因为`this`来自对象字面量里的函数表达式。 修改的方法是，提供一个显式的`this`参数。 `this`参数是个假的参数，它出现在参数列表的最前面：\n\n```typescript\nfunction f(this: void) {\n    // make sure `this` is unusable in this standalone function\n}\n```\n\n让我们往例子里添加一些接口，`Card` 和 `Deck`，让类型重用能够变得清晰简单些：\n\n```typescript\ninterface Card {\n    suit: string;\n    card: number;\n}\ninterface Deck {\n    suits: string[];\n    cards: number[];\n    createCardPicker(this: Deck): () => Card;\n}\nlet deck: Deck = {\n    suits: ["hearts", "spades", "clubs", "diamonds"],\n    cards: Array(52),\n    // NOTE: The function now explicitly specifies that its callee must be of type Deck\n    createCardPicker: function(this: Deck) {\n        return () => {\n            let pickedCard = Math.floor(Math.random() * 52);\n            let pickedSuit = Math.floor(pickedCard / 13);\n\n            return {suit: this.suits[pickedSuit], card: pickedCard % 13};\n        }\n    }\n}\n\nlet cardPicker = deck.createCardPicker();\nlet pickedCard = cardPicker();\n\nalert("card: " + pickedCard.card + " of " + pickedCard.suit);\n```\n\n现在TypeScript知道`createCardPicker`期望在某个`Deck`对象上调用。 也就是说`this`是`Deck`类型的，而非`any`，因此`--noImplicitThis`不会报错了。\n\n#### 回调函数里的`this`参数\n\n当你将一个函数传递到某个库函数里在稍后被调用时，你可能也见到过回调函数里的`this`会报错。 因为当回调函数被调用时，它会被当成一个普通函数调用，`this`将为`undefined`。 稍做改动，你就可以通过`this`参数来避免错误。 首先，库函数的作者要指定`this`的类型：\n\n```typescript\ninterface UIElement {\n    addClickListener(onclick: (this: void, e: Event) => void): void;\n}\n```\n\n`this: void`意味着`addClickListener`期望`onclick`是一个函数且它不需要一个`this`类型。 然后，为调用代码里的`this`添加类型注解：\n\n```typescript\nclass Handler {\n    info: string;\n    onClickBad(this: Handler, e: Event) {\n        // oops, used this here. using this callback would crash at runtime\n        this.info = e.message;\n    }\n}\nlet h = new Handler();\nuiElement.addClickListener(h.onClickBad); // error!\n```\n\n指定了`this`类型后，你显式声明`onClickBad`必须在`Handler`的实例上调用。 然后TypeScript会检测到`addClickListener`要求函数带有`this: void`。 改变`this`类型来修复这个错误：\n\n```typescript\nclass Handler {\n    info: string;\n    onClickGood(this: void, e: Event) {\n        // can\'t use this here because it\'s of type void!\n        console.log(\'clicked!\');\n    }\n}\nlet h = new Handler();\nuiElement.addClickListener(h.onClickGood);\n```\n\n因为`onClickGood`指定了`this`类型为`void`，因此传递`addClickListener`是合法的。 当然了，这也意味着不能使用`this.info`. 如果你两者都想要，你不得不使用箭头函数了：\n\n```typescript\nclass Handler {\n    info: string;\n    onClickGood = (e: Event) => { this.info = e.message }\n}\n```\n\n这是可行的因为箭头函数使用外层的`this`，所以你总是可以把它们传给期望`this: void`的函数。 缺点是每个`Handler`对象都会创建一个箭头函数。 另一方面，方法只会被创建一次，添加到`Handler`的原型链上。 它们在不同`Handler`对象间是共享的。\n\n## 重载\n\nJavaScript本身是个动态语言。 JavaScript里函数根据传入不同的参数而返回不同类型的数据是很常见的。\n\n```typescript\nlet suits = ["hearts", "spades", "clubs", "diamonds"];\n\nfunction pickCard(x): any {\n    // Check to see if we\'re working with an object/array\n    // if so, they gave us the deck and we\'ll pick the card\n    if (typeof x == "object") {\n        let pickedCard = Math.floor(Math.random() * x.length);\n        return pickedCard;\n    }\n    // Otherwise just let them pick the card\n    else if (typeof x == "number") {\n        let pickedSuit = Math.floor(x / 13);\n        return { suit: suits[pickedSuit], card: x % 13 };\n    }\n}\n\nlet myDeck = [{ suit: "diamonds", card: 2 }, { suit: "spades", card: 10 }, { suit: "hearts", card: 4 }];\nlet pickedCard1 = myDeck[pickCard(myDeck)];\nalert("card: " + pickedCard1.card + " of " + pickedCard1.suit);\n\nlet pickedCard2 = pickCard(15);\nalert("card: " + pickedCard2.card + " of " + pickedCard2.suit);\n```\n\n`pickCard`方法根据传入参数的不同会返回两种不同的类型。 如果传入的是代表纸牌的对象，函数作用是从中抓一张牌。 如果用户想抓牌，我们告诉他抓到了什么牌。 但是这怎么在类型系统里表示呢。\n\n方法是为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用。 下面我们来重载`pickCard`函数。\n\n```typescript\nlet suits = ["hearts", "spades", "clubs", "diamonds"];\n\nfunction pickCard(x: {suit: string; card: number; }[]): number;\nfunction pickCard(x: number): {suit: string; card: number; };\nfunction pickCard(x): any {\n    // Check to see if we\'re working with an object/array\n    // if so, they gave us the deck and we\'ll pick the card\n    if (typeof x == "object") {\n        let pickedCard = Math.floor(Math.random() * x.length);\n        return pickedCard;\n    }\n    // Otherwise just let them pick the card\n    else if (typeof x == "number") {\n        let pickedSuit = Math.floor(x / 13);\n        return { suit: suits[pickedSuit], card: x % 13 };\n    }\n}\n\nlet myDeck = [{ suit: "diamonds", card: 2 }, { suit: "spades", card: 10 }, { suit: "hearts", card: 4 }];\nlet pickedCard1 = myDeck[pickCard(myDeck)];\nalert("card: " + pickedCard1.card + " of " + pickedCard1.suit);\n\nlet pickedCard2 = pickCard(15);\nalert("card: " + pickedCard2.card + " of " + pickedCard2.suit);\n```\n\n这样改变后，重载的`pickCard`函数在调用的时候会进行正确的类型检查。\n\n为了让编译器能够选择正确的检查类型，它与JavaScript里的处理流程相似。 它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。 因此，在定义重载的时候，一定要把最精确的定义放在最前面。\n\n注意，`function pickCard(x): any`并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象另一个接收数字。 以其它参数调用`pickCard`会产生错误。\n\n',Ol="# 泛型\n\n## 介绍\n\n软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。\n\n在像C\\#和Java这样的语言中，可以使用`泛型`来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。\n\n## 泛型之Hello World\n\n下面来创建第一个使用泛型的例子：identity函数。 这个函数会返回任何传入它的值。 你可以把这个函数当成是`echo`命令。\n\n不用泛型的话，这个函数可能是下面这样：\n\n```typescript\nfunction identity(arg: number): number {\n    return arg;\n}\n```\n\n或者，我们使用`any`类型来定义函数：\n\n```typescript\nfunction identity(arg: any): any {\n    return arg;\n}\n```\n\n使用`any`类型会导致这个函数可以接收任何类型的`arg`参数，这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。 如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。\n\n因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。 这里，我们使用了_类型变量_，它是一种特殊的变量，只用于表示类型而不是值。\n\n```typescript\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n```\n\n我们给identity添加了类型变量`T`。 `T`帮助我们捕获用户传入的类型（比如：`number`），之后我们就可以使用这个类型。 之后我们再次使用了`T`当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。 这允许我们跟踪函数里使用的类型的信息。\n\n我们把这个版本的`identity`函数叫做泛型，因为它可以适用于多个类型。 不同于使用`any`，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。\n\n我们定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数：\n\n```typescript\nlet output = identity<string>(\"myString\");  // type of output will be 'string'\n```\n\n这里我们明确的指定了`T`是`string`类型，并做为一个参数传给函数，使用了`<>`括起来而不是`()`。\n\n第二种方法更普遍。利用了_类型推论_ -- 即编译器会根据传入的参数自动地帮助我们确定T的类型：\n\n```typescript\nlet output = identity(\"myString\");  // type of output will be 'string'\n```\n\n注意我们没必要使用尖括号（`<>`）来明确地传入类型；编译器可以查看`myString`的值，然后把`T`设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入T的类型，在一些复杂的情况下，这是可能出现的。\n\n## 使用泛型变量\n\n使用泛型创建像`identity`这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。\n\n看下之前`identity`例子：\n\n```typescript\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n```\n\n如果我们想同时打印出`arg`的长度。 我们很可能会这样做：\n\n```typescript\nfunction loggingIdentity<T>(arg: T): T {\n    console.log(arg.length);  // Error: T doesn't have .length\n    return arg;\n}\n```\n\n如果这么做，编译器会报错说我们使用了`arg`的`.length`属性，但是没有地方指明`arg`具有这个属性。 记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有`.length`属性的。\n\n现在假设我们想操作`T`类型的数组而不直接是`T`。由于我们操作的是数组，所以`.length`属性是应该存在的。 我们可以像创建其它数组一样创建这个数组：\n\n```typescript\nfunction loggingIdentity<T>(arg: T[]): T[] {\n    console.log(arg.length);  // Array has a .length, so no more error\n    return arg;\n}\n```\n\n你可以这样理解`loggingIdentity`的类型：泛型函数`loggingIdentity`，接收类型参数`T`和参数`arg`，它是个元素类型是`T`的数组，并返回元素类型是`T`的数组。 如果我们传入数字数组，将返回一个数字数组，因为此时`T`的的类型为`number`。 这可以让我们把泛型变量T当做类型的一部分使用，而不是整个类型，增加了灵活性。\n\n我们也可以这样实现上面的例子：\n\n```typescript\nfunction loggingIdentity<T>(arg: Array<T>): Array<T> {\n    console.log(arg.length);  // Array has a .length, so no more error\n    return arg;\n}\n```\n\n使用过其它语言的话，你可能对这种语法已经很熟悉了。 在下一节，会介绍如何创建自定义泛型像`Array<T>`一样。\n\n## 泛型类型\n\n上一节，我们创建了identity通用函数，可以适用于不同的类型。 在这节，我们研究一下函数本身的类型，以及如何创建泛型接口。\n\n泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样：\n\n```typescript\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\nlet myIdentity: <T>(arg: T) => T = identity;\n```\n\n我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。\n\n```typescript\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\nlet myIdentity: <U>(arg: U) => U = identity;\n```\n\n我们还可以使用带有调用签名的对象字面量来定义泛型函数：\n\n```typescript\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\nlet myIdentity: {<T>(arg: T): T} = identity;\n```\n\n这引导我们去写第一个泛型接口了。 我们把上面例子里的对象字面量拿出来做为一个接口：\n\n```typescript\ninterface GenericIdentityFn {\n    <T>(arg: T): T;\n}\n\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\nlet myIdentity: GenericIdentityFn = identity;\n```\n\n一个相似的例子，我们可能想把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型（比如：`Dictionary<string>而不只是Dictionary`）。 这样接口里的其它成员也能知道这个参数的类型了。\n\n```typescript\ninterface GenericIdentityFn<T> {\n    (arg: T): T;\n}\n\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\nlet myIdentity: GenericIdentityFn<number> = identity;\n```\n\n注意，我们的示例做了少许改动。 不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。 当我们使用`GenericIdentityFn`的时候，还得传入一个类型参数来指定泛型类型（这里是：`number`），锁定了之后代码里使用的类型。 对于描述哪部分类型属于泛型部分来说，理解何时把参数放在调用签名里和何时放在接口上是很有帮助的。\n\n除了泛型接口，我们还可以创建泛型类。 注意，无法创建泛型枚举和泛型命名空间。\n\n## 泛型类\n\n泛型类看上去与泛型接口差不多。 泛型类使用（`<>`）括起泛型类型，跟在类名后面。\n\n```typescript\nclass GenericNumber<T> {\n    zeroValue: T;\n    add: (x: T, y: T) => T;\n}\n\nlet myGenericNumber = new GenericNumber<number>();\nmyGenericNumber.zeroValue = 0;\nmyGenericNumber.add = function(x, y) { return x + y; };\n```\n\n`GenericNumber`类的使用是十分直观的，并且你可能已经注意到了，没有什么去限制它只能使用`number`类型。 也可以使用字符串或其它更复杂的类型。\n\n```typescript\nlet stringNumeric = new GenericNumber<string>();\nstringNumeric.zeroValue = \"\";\nstringNumeric.add = function(x, y) { return x + y; };\n\nconsole.log(stringNumeric.add(stringNumeric.zeroValue, \"test\"));\n```\n\n与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。\n\n我们在[类](classes.md)那节说过，类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。\n\n## 泛型约束\n\n你应该会记得之前的一个例子，我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。 在`loggingIdentity`例子中，我们想访问`arg`的`length`属性，但是编译器并不能证明每种类型都有`length`属性，所以就报错了。\n\n```typescript\nfunction loggingIdentity<T>(arg: T): T {\n    console.log(arg.length);  // Error: T doesn't have .length\n    return arg;\n}\n```\n\n相比于操作any所有类型，我们想要限制函数去处理任意带有`.length`属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。 为此，我们需要列出对于T的约束要求。\n\n为此，我们定义一个接口来描述约束条件。 创建一个包含`.length`属性的接口，使用这个接口和`extends`关键字来实现约束：\n\n```typescript\ninterface Lengthwise {\n    length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n    console.log(arg.length);  // Now we know it has a .length property, so no more error\n    return arg;\n}\n```\n\n现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：\n\n```typescript\nloggingIdentity(3);  // Error, number doesn't have a .length property\n```\n\n我们需要传入符合约束类型的值，必须包含必须的属性：\n\n```typescript\nloggingIdentity({length: 10, value: 3});\n```\n\n### 在泛型约束中使用类型参数\n\n你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象`obj`上，因此我们需要在这两个类型之间使用约束。\n\n```typescript\nfunction getProperty<T, K extends keyof T>(obj: T, key: K) {\n    return obj[key];\n}\n\nlet x = { a: 1, b: 2, c: 3, d: 4 };\n\ngetProperty(x, \"a\"); // okay\ngetProperty(x, \"m\"); // error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'.\n```\n\n### 在泛型里使用类类型\n\n在TypeScript使用泛型创建工厂函数时，需要引用构造函数的类类型。比如，\n\n```typescript\nfunction create<T>(c: {new(): T; }): T {\n    return new c();\n}\n```\n\n一个更高级的例子，使用原型属性推断并约束构造函数与类实例的关系。\n\n```typescript\nclass BeeKeeper {\n    hasMask: boolean;\n}\n\nclass ZooKeeper {\n    nametag: string;\n}\n\nclass Animal {\n    numLegs: number;\n}\n\nclass Bee extends Animal {\n    keeper: BeeKeeper;\n}\n\nclass Lion extends Animal {\n    keeper: ZooKeeper;\n}\n\nfunction createInstance<A extends Animal>(c: new () => A): A {\n    return new c();\n}\n\ncreateInstance(Lion).keeper.nametag;  // typechecks!\ncreateInstance(Bee).keeper.hasMask;   // typechecks!\n```\n\n",El='# 接口\n\n## 介绍\n\nTypeScript 的核心原则之一是对值所具有的_结构_进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。\n\n## 接口初探\n\n下面通过一个简单示例来观察接口是如何工作的：\n\n```typescript\nfunction printLabel(labeledObj: { label: string }) {\n  console.log(labeledObj.label);\n}\n\nlet myObj = { size: 10, label: "Size 10 Object" };\nprintLabel(myObj);\n```\n\n类型检查器会查看`printLabel`的调用。 `printLabel`有一个参数，并要求这个对象参数有一个名为`label`类型为`string`的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。 然而，有些时候 TypeScript 却并不会这么宽松，我们下面会稍做讲解。\n\n下面我们重写上面的例子，这次使用接口来描述：必须包含一个`label`属性且类型为`string`：\n\n```typescript\ninterface LabeledValue {\n  label: string;\n}\n\nfunction printLabel(labeledObj: LabeledValue) {\n  console.log(labeledObj.label);\n}\n\nlet myObj = { size: 10, label: "Size 10 Object" };\nprintLabel(myObj);\n```\n\n`LabeledValue`接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个`label`属性且类型为`string`的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给`printLabel`的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。\n\n还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。\n\n## 可选属性\n\n接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。\n\n下面是应用了“option bags”的例子：\n\n```typescript\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n}\n\nfunction createSquare(config: SquareConfig): { color: string; area: number } {\n  let newSquare = { color: "white", area: 100 };\n  if (config.color) {\n    newSquare.color = config.color;\n  }\n  if (config.width) {\n    newSquare.area = config.width * config.width;\n  }\n  return newSquare;\n}\n\nlet mySquare = createSquare({ color: "black" });\n```\n\n带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个`?`符号。\n\n可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将`createSquare`里的`color`属性名拼错，就会得到一个错误提示：\n\n```typescript\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n}\n\nfunction createSquare(config: SquareConfig): { color: string; area: number } {\n  let newSquare = { color: "white", area: 100 };\n  if (config.clor) {\n    // Error: Property \'clor\' does not exist on type \'SquareConfig\'\n    newSquare.color = config.clor;\n  }\n  if (config.width) {\n    newSquare.area = config.width * config.width;\n  }\n  return newSquare;\n}\n\nlet mySquare = createSquare({ color: "black" });\n```\n\n## 只读属性\n\n一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用`readonly`来指定只读属性:\n\n```typescript\ninterface Point {\n  readonly x: number;\n  readonly y: number;\n}\n```\n\n你可以通过赋值一个对象字面量来构造一个`Point`。 赋值后，`x`和`y`再也不能被改变了。\n\n```typescript\nlet p1: Point = { x: 10, y: 20 };\np1.x = 5; // error!\n```\n\nTypeScript 具有`ReadonlyArray<T>`类型，它与`Array<T>`相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：\n\n```typescript\nlet a: number[] = [1, 2, 3, 4];\nlet ro: ReadonlyArray<number> = a;\nro[0] = 12; // error!\nro.push(5); // error!\nro.length = 100; // error!\na = ro; // error!\n```\n\n上面代码的最后一行，可以看到就算把整个`ReadonlyArray`赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：\n\n```typescript\na = ro as number[];\n```\n\n### `readonly` vs `const`\n\n最简单判断该用`readonly`还是`const`的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用`const`，若做为属性则使用`readonly`。\n\n## 额外的属性检查\n\n我们在第一个例子里使用了接口，TypeScript 让我们传入`{ size: number; label: string; }`到仅期望得到`{ label: string; }`的函数里。 我们已经学过了可选属性，并且知道他们在“option bags”模式里很有用。\n\n然而，天真地将这两者结合的话就会像在 JavaScript 里那样搬起石头砸自己的脚。比如，拿`createSquare`例子来说：\n\n```typescript\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n}\n\nfunction createSquare(config: SquareConfig): { color: string; area: number } {\n  // ...\n}\n\nlet mySquare = createSquare({ colour: "red", width: 100 });\n```\n\n注意传入`createSquare`的参数拼写为`colour`而不是`color`。 在 JavaScript 里，这会默默地失败。\n\n你可能会争辩这个程序已经正确地类型化了，因为`width`属性是兼容的，不存在`color`属性，而且额外的`colour`属性是无意义的。\n\n然而，TypeScript 会认为这段代码可能存在 bug。 对象字面量会被特殊对待而且会经过_额外属性检查_，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。\n\n```typescript\n// error: Object literal may only specify known properties, but \'colour\' does not exist in type \'SquareConfig\'. Did you mean to write \'color\'?\nlet mySquare = createSquare({ colour: "red", width: 100 });\n```\n\n绕开这些检查非常简单。 最简便的方法是使用类型断言：\n\n```typescript\nlet mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);\n```\n\n然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果`SquareConfig`带有上面定义的类型的`color`和`width`属性，并且_还会_带有任意数量的其它属性，那么我们可以这样定义它：\n\n```typescript\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n  [propName: string]: any;\n}\n```\n\n我们稍后会讲到索引签名，但在这我们要表示的是`SquareConfig`可以有任意数量的属性，并且只要它们不是`color`和`width`，那么就无所谓它们的类型是什么。\n\n还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为`squareOptions`不会经过额外属性检查，所以编译器不会报错。\n\n```typescript\nlet squareOptions = { colour: "red", width: 100 };\nlet mySquare = createSquare(squareOptions);\n```\n\n上面的方法只在`squareOptions`和`SquareConfig`之间有共同的属性时才好用。 在这个例子中，这个属性为`width`。如果变量间不存在共同的对象属性将会报错。例如：\n\n```typescript\nlet squareOptions = { colour: "red" };\nlet mySquare = createSquare(squareOptions);\n```\n\n要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大部额外属性检查错误是真正的 bug。 就是说你遇到了额外类型检查出的错误，比如“option bags”，你应该去审查一下你的类型声明。 在这里，如果支持传入`color`或`colour`属性到`createSquare`，你应该修改`SquareConfig`定义来体现出这一点。\n\n## 函数类型\n\n接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。\n\n为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。\n\n```typescript\ninterface SearchFunc {\n  (source: string, subString: string): boolean;\n}\n```\n\n这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。\n\n```typescript\nlet mySearch: SearchFunc;\nmySearch = function(source: string, subString: string) {\n  let result = source.search(subString);\n  return result > -1;\n};\n```\n\n对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：\n\n```typescript\nlet mySearch: SearchFunc;\nmySearch = function(src: string, sub: string): boolean {\n  let result = src.search(sub);\n  return result > -1;\n};\n```\n\n函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript 的类型系统会推断出参数类型，因为函数直接赋值给了`SearchFunc`类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是`false`和`true`）。\n\n```typescript\nlet mySearch: SearchFunc;\nmySearch = function(src, sub) {\n  let result = src.search(sub);\n  return result > -1;\n};\n```\n\n如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与`SearchFunc`接口中的定义不匹配。\n\n```typescript\nlet mySearch: SearchFunc;\n\n// error: Type \'(src: string, sub: string) => string\' is not assignable to type \'SearchFunc\'.\n// Type \'string\' is not assignable to type \'boolean\'.\nmySearch = function(src, sub) {\n  let result = src.search(sub);\n  return "string";\n};\n```\n\n## 可索引的类型\n\n与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如`a[10]`或`ageMap["daniel"]`。 可索引类型具有一个_索引签名_，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：\n\n```typescript\ninterface StringArray {\n  [index: number]: string;\n}\n\nlet myArray: StringArray;\nmyArray = ["Bob", "Fred"];\n\nlet myStr: string = myArray[0];\n```\n\n上面例子里，我们定义了`StringArray`接口，它具有索引签名。 这个索引签名表示了当用`number`去索引`StringArray`时会得到`string`类型的返回值。\n\nTypescript 支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用`number`来索引时，JavaScript 会将它转换成`string`然后再去索引对象。 也就是说用`100`（一个`number`）去索引等同于使用`"100"`（一个`string`）去索引，因此两者需要保持一致。\n\n```typescript\nclass Animal {\n  name: string;\n}\nclass Dog extends Animal {\n  breed: string;\n}\n\n// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!\ninterface NotOkay {\n  [x: number]: Animal;\n  [x: string]: Dog;\n}\n```\n\n字符串索引签名能够很好的描述`dictionary`模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了`obj.property`和`obj["property"]`两种形式都可以。 下面的例子里，`name`的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：\n\n```typescript\ninterface NumberDictionary {\n  [index: string]: number;\n  length: number; // 可以，length是number类型\n  name: string; // 错误，`name`的类型与索引类型返回值的类型不匹配\n}\n```\n\n但如果索引签名是包含属性类型的联合类型，那么使用不同类型的属性就是允许的。\n\n```typescript\ninterface NumberOrStringDictionary {\n   [index: string]: number | string;\n   length: number;    // ok, length is a number\n   name: string;      // ok, name is a string\n}\n```\n\n最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：\n\n```typescript\ninterface ReadonlyStringArray {\n  readonly [index: number]: string;\n}\nlet myArray: ReadonlyStringArray = ["Alice", "Bob"];\nmyArray[2] = "Mallory"; // error!\n```\n\n你不能设置`myArray[2]`，因为索引签名是只读的。\n\n## 类类型\n\n### 实现接口\n\n与 C\\#或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。\n\n```typescript\ninterface ClockInterface {\n  currentTime: Date;\n}\n\nclass Clock implements ClockInterface {\n  currentTime: Date = new Date();\n  constructor(h: number, m: number) {}\n}\n```\n\n你也可以在接口中描述一个方法，在类里实现它，如同下面的`setTime`方法一样：\n\n```typescript\ninterface ClockInterface {\n  currentTime: Date;\n  setTime(d: Date): void;\n}\n\nclass Clock implements ClockInterface {\n  currentTime: Date = new Date();\n  setTime(d: Date) {\n    this.currentTime = d;\n  }\n  constructor(h: number, m: number) {}\n}\n```\n\n接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。\n\n### 类静态部分与实例部分的区别\n\n当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：\n\n```typescript\ninterface ClockConstructor {\n  new (hour: number, minute: number);\n}\n\nclass Clock implements ClockConstructor {\n  currentTime: Date;\n  constructor(h: number, m: number) {}\n}\n```\n\n这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor 存在于类的静态部分，所以不在检查的范围内。\n\n因此，我们应该直接操作类的静态部分。 看下面的例子，我们定义了两个接口，`ClockConstructor`为构造函数所用和`ClockInterface`为实例方法所用。 为了方便我们定义一个构造函数`createClock`，它用传入的类型创建实例。\n\n```typescript\ninterface ClockConstructor {\n  new (hour: number, minute: number): ClockInterface;\n}\ninterface ClockInterface {\n  tick(): void;\n}\n\nfunction createClock(\n  ctor: ClockConstructor,\n  hour: number,\n  minute: number\n): ClockInterface {\n  return new ctor(hour, minute);\n}\n\nclass DigitalClock implements ClockInterface {\n  constructor(h: number, m: number) {}\n  tick() {\n    console.log("beep beep");\n  }\n}\nclass AnalogClock implements ClockInterface {\n  constructor(h: number, m: number) {}\n  tick() {\n    console.log("tick tock");\n  }\n}\n\nlet digital = createClock(DigitalClock, 12, 17);\nlet analog = createClock(AnalogClock, 7, 32);\n```\n\n因为`createClock`的第一个参数是`ClockConstructor`类型，在`createClock(AnalogClock, 7, 32)`里，会检查`AnalogClock`是否符合构造函数签名。\n\n另一种简单方式是使用类表达式：\n\n```typescript\ninterface ClockConstructor {\n  new (hour: number, minute: number);\n}\n\ninterface ClockInterface {\n  tick();\n}\n\nconst Clock: ClockConstructor = class Clock implements ClockInterface {\n  constructor(h: number, m: number) {}\n  tick() {\n    console.log("beep beep");\n  }\n};\n```\n\n## 继承接口\n\n和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。\n\n```typescript\ninterface Shape {\n  color: string;\n}\n\ninterface Square extends Shape {\n  sideLength: number;\n}\n\nlet square = {} as Square;\nsquare.color = "blue";\nsquare.sideLength = 10;\n```\n\n一个接口可以继承多个接口，创建出多个接口的合成接口。\n\n```typescript\ninterface Shape {\n  color: string;\n}\n\ninterface PenStroke {\n  penWidth: number;\n}\n\ninterface Square extends Shape, PenStroke {\n  sideLength: number;\n}\n\nlet square = {} as Square;\nsquare.color = "blue";\nsquare.sideLength = 10;\nsquare.penWidth = 5.0;\n```\n\n## 混合类型\n\n先前我们提过，接口能够描述 JavaScript 里丰富的类型。 因为 JavaScript 其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。\n\n一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。\n\n```typescript\ninterface Counter {\n  (start: number): string;\n  interval: number;\n  reset(): void;\n}\n\nfunction getCounter(): Counter {\n  let counter = function(start: number) {} as Counter;\n  counter.interval = 123;\n  counter.reset = function() {};\n  return counter;\n}\n\nlet c = getCounter();\nc(10);\nc.reset();\nc.interval = 5.0;\n```\n\n在使用 JavaScript 第三方库的时候，你可能需要像上面那样去完整地定义类型。\n\n## 接口继承类\n\n当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的 private 和 protected 成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。\n\n当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 除了继承自基类，子类之间不必相关联。 例：\n\n```typescript\nclass Control {\n  private state: any;\n}\n\ninterface SelectableControl extends Control {\n  select(): void;\n}\n\nclass Button extends Control implements SelectableControl {\n  select() {}\n}\n\nclass TextBox extends Control {\n  select() {}\n}\n\nclass ImageControl implements SelectableControl {\n// Error: Class \'ImageControl\' incorrectly implements interface \'SelectableControl\'.\n//  Types have separate declarations of a private property \'state\'.\n  private state: any;\n  select() {}\n}\n```\n\n在上面的例子里，`SelectableControl`包含了`Control`的所有成员，包括私有成员`state`。 因为`state`是私有成员，所以只能够是`Control`的子类们才能实现`SelectableControl`接口。 因为只有`Control`的子类才能够拥有一个声明于`Control`的私有成员`state`，这对私有成员的兼容性是必需的。\n\n在`Control`类内部，是允许通过`SelectableControl`的实例来访问私有成员`state`的。 实际上，`SelectableControl`就像`Control`一样，并拥有一个`select`方法。 `Button`和`TextBox`类是`SelectableControl`的子类（因为它们都继承自`Control`并有`select`方法）。而对于 `ImageControl` 类，它有自身的私有成员 `state` 而不是通过继承 `Control` 得来的，所以它不可以实现 `SelectableControl` 。\n\n',Rl='# 字面量类型\n\n## 介绍\n\n一个字面量是一个集体类型中更为具体的一种子类型。意思是：`"Hello World"` 是一个 `string`，但是一个 `string` 不是类型系统中的 `"Hello World"`。\n\n目前 TypeScript 中有三种可用的字面量类型集合，分别是：字符串、数字和布尔值。通过使用字面量类型，你可以规定一个字符串、数字或布尔值必须含有的确定值。\n\n## 字面量收窄\n\n当你通过 `var` 或 `let` 来声明一个变量时，实际上你在告诉编译器这个变量中的内容有可能会被改变。与之相对地，用 `const` 来声明对象会让 TypeScript 知道这个对象永远不会被改变。\n\n```TypeScript\n// We\'re making a guarantee that this variable\n// helloWorld will never change, by using const.\n\n// So, TypeScript sets the type to be "Hello World" not string\nconst helloWorld = "Hello World";\n\n// On the other hand, a let can change, and so the compiler declares it a string\nlet hiWorld = "Hi World";\n```\n\n从无穷多种可能的例子（`string` 变量的值有无穷多种）到一个更小、确定数量的例子（在上述例子中，`"Hello Wrold"` 的可能值只有一种）的过程就叫收窄。\n\n## 字符串字面量类型\n\n字面量类型可以通过联合联系、类型守卫、类型别名来结合实际字符串值。通过这些特性，我们可以获取一种字符串并使其有类似枚举（enum）的行为。\n\n```TypeScript\ntype Easing = "ease-in" | "ease-out" | "ease-in-out";\n\nclass UIElement {\n  animate(dx: number, dy: number, easing: Easing) {\n    if (easing === "ease-in") {\n      // ...\n    } else if (easing === "ease-out") {\n    } else if (easing === "ease-in-out") {\n    } else {\n      // It\'s possible that someone could reach this\n      // by ignoring your types though.\n    }\n  }\n}\n\nlet button = new UIElement();\nbutton.animate(0, 0, "ease-in");\nbutton.animate(0, 0, "uneasy");\n// Error: Argument of type \'"uneasy"\' is not assignable to parameter of type \'Easing\'.\n```\n\n你可以传递三种允许的字符串，但是如果传递其他的字符串会收到如下错误：\n\n```TypeScript\nArgument of type \'"uneasy"\' is not assignable to parameter of type \'"ease-in" | "ease-out" | "ease-in-out"\'\n```\n\n字符串字面可以通过相同的方式用来分别重载：\n\n```TypeScript\nfunction createElement(tagName: "img"): HTMLImageElement;\nfunction createElement(tagName: "input"): HTMLInputElement;\n// ... more overloads ...\nfunction createElement(tagName: string): Element {\n  // ... code goes here ...\n}\n```\n\n## 数字字面量类型\n\nTypeScript 还有数字字面量类型，它的行为和上述字符串字面量类型相同。\n\n```TypeScript\nfunction rollDice(): 1 | 2 | 3 | 4 | 5 | 6 {\n  return (Math.floor(Math.random() * 6) + 1) as 1 | 2 | 3 | 4 | 5 | 6;\n}\n\nconst result = rollDice();\n```\n\n数字字面量类型经常用来描述配置值：\n\n```TypeScript\ninterface MapConfig {\n  lng: number;\n  lat: number;\n  tileSize: 8 | 16 | 32;\n}\n\nsetupMap({ lng: -73.935242, lat: 40.73061, tileSize: 16 });\n```\n\n## 布尔字面量类型\n\nTypeScript 还有布尔值字面量类型，你可以通过他们来约束某些属性之间互有关联的对象。\n\n```TypeScript\ninterface ValidationSuccess {\n  isValid: true;\n  reason: null;\n};\n\ninterface ValidationFailure {\n  isValid: false;\n  reason: string;\n};\n\ntype ValidationResult =\n  | ValidationSuccess\n  | ValidationFailure;\n```\n\n',Nl={data:function(){return{MainComponent1:Tl,MainComponent2:Cl,MainComponent3:Ml,MainComponent4:Pl,MainComponent5:Ol,MainComponent6:El,MainComponent7:Rl}}},Al=Nl,Dl=Object(m["a"])(Al,wl,xl,!1,null,"6c441751",null),Il=Dl.exports,Jl=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent1}}),r("q-markdown",{attrs:{src:n.MainComponent2}}),r("q-markdown",{attrs:{src:n.MainComponent3}}),r("q-markdown",{attrs:{src:n.MainComponent4}}),r("q-markdown",{attrs:{src:n.MainComponent5}}),r("q-markdown",{attrs:{src:n.MainComponent6}}),r("q-markdown",{attrs:{src:n.MainComponent7}}),r("q-markdown",{attrs:{src:n.MainComponent8}}),r("q-markdown",{attrs:{src:n.MainComponent9}}),r("q-markdown",{attrs:{src:n.MainComponent10}}),r("q-markdown",{attrs:{src:n.MainComponent11}}),r("q-markdown",{attrs:{src:n.MainComponent12}}),r("q-markdown",{attrs:{src:n.MainComponent13}}),r("q-markdown",{attrs:{src:n.MainComponent14}}),r("q-markdown",{attrs:{src:n.MainComponent15}}),r("q-markdown",{attrs:{src:n.MainComponent16}})],1)},Ll=[],Hl='# 高级类型\n\n## 交叉类型（Intersection Types）\n\n交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如，`Person & Serializable & Loggable`同时是`Person`_和_`Serializable`_和_`Loggable`。 就是说这个类型的对象同时拥有了这三种类型的成员。\n\n我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在JavaScript里发生这种情况的场合很多！） 下面是如何创建混入的一个简单例子\\("target": "es5"\\)：\n\n```typescript\nfunction extend<First, Second>(first: First, second: Second): First & Second {\n    const result: Partial<First & Second> = {};\n    for (const prop in first) {\n        if (first.hasOwnProperty(prop)) {\n            (result as First)[prop] = first[prop];\n        }\n    }\n    for (const prop in second) {\n        if (second.hasOwnProperty(prop)) {\n            (result as Second)[prop] = second[prop];\n        }\n    }\n    return result as First & Second;\n}\n\nclass Person {\n    constructor(public name: string) { }\n}\n\ninterface Loggable {\n    log(name: string): void;\n}\n\nclass ConsoleLogger implements Loggable {\n    log(name) {\n        console.log(`Hello, I\'m ${name}.`);\n    }\n}\n\nconst jim = extend(new Person(\'Jim\'), ConsoleLogger.prototype);\njim.log(jim.name);\n```\n\n## 联合类型（Union Types）\n\n联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入`number`或`string`类型的参数。 例如下面的函数：\n\n```typescript\n/**\n * Takes a string and adds "padding" to the left.\n * If \'padding\' is a string, then \'padding\' is appended to the left side.\n * If \'padding\' is a number, then that number of spaces is added to the left side.\n */\nfunction padLeft(value: string, padding: any) {\n    if (typeof padding === "number") {\n        return Array(padding + 1).join(" ") + value;\n    }\n    if (typeof padding === "string") {\n        return padding + value;\n    }\n    throw new Error(`Expected string or number, got \'${padding}\'.`);\n}\n\npadLeft("Hello world", 4); // returns "    Hello world"\n```\n\n`padLeft`存在一个问题，`padding`参数的类型指定成了`any`。 这就是说我们可以传入一个既不是`number`也不是`string`类型的参数，但是TypeScript却不报错。\n\n```typescript\nlet indentedString = padLeft("Hello world", true); // 编译阶段通过，运行时报错\n```\n\n在传统的面向对象语言里，我们可能会将这两种类型抽象成有层级的类型。 这么做显然是非常清晰的，但同时也存在了过度设计。 `padLeft`原始版本的好处之一是允许我们传入原始类型。 这样做的话使用起来既简单又方便。 如果我们就是想使用已经存在的函数的话，这种新的方式就不适用了。\n\n代替`any`， 我们可以使用_联合类型_做为`padding`的参数：\n\n```typescript\n/**\n * Takes a string and adds "padding" to the left.\n * If \'padding\' is a string, then \'padding\' is appended to the left side.\n * If \'padding\' is a number, then that number of spaces is added to the left side.\n */\nfunction padLeft(value: string, padding: string | number) {\n    // ...\n}\n\nlet indentedString = padLeft("Hello world", true); // errors during compilation\n```\n\n联合类型表示一个值可以是几种类型之一。 我们用竖线（`|`）分隔每个类型，所以`number | string | boolean`表示一个值可以是`number`，`string`，或`boolean`。\n\n如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。\n\n```typescript\ninterface Bird {\n    fly();\n    layEggs();\n}\n\ninterface Fish {\n    swim();\n    layEggs();\n}\n\nfunction getSmallPet(): Fish | Bird {\n    // ...\n}\n\nlet pet = getSmallPet();\npet.layEggs(); // okay\npet.swim();    // errors\n```\n\n这里的联合类型可能有点复杂，但是你很容易就习惯了。 如果一个值的类型是`A | B`，我们能够_确定_的是它包含了`A`_和_`B`中共有的成员。 这个例子里，`Bird`具有一个`fly`成员。 我们不能确定一个`Bird | Fish`类型的变量是否有`fly`方法。 如果变量在运行时是`Fish`类型，那么调用`pet.fly()`就出错了。\n\n## 类型守卫与类型区分（Type Guards and Differentiating Types）\n\n联合类型适合于那些值可以为不同类型的情况。 但当我们想确切地了解是否为`Fish`时怎么办？ JavaScript里常用来区分2个可能值的方法是检查成员是否存在。 如之前提及的，我们只能访问联合类型中共同拥有的成员。\n\n```typescript\nlet pet = getSmallPet();\n\n// 每一个成员访问都会报错\nif (pet.swim) {\n    pet.swim();\n}\nelse if (pet.fly) {\n    pet.fly();\n}\n```\n\n为了让这段代码工作，我们要使用类型断言：\n\n```typescript\nlet pet = getSmallPet();\n\nif ((pet as Fish).swim) {\n    (pet as Fish).swim();\n} else if ((pet as Bird).fly) {\n    (pet as Bird).fly();\n}\n```\n\n### 用户自定义的类型守卫\n\n这里可以注意到我们不得不多次使用类型断言。 假若我们一旦检查过类型，就能在之后的每个分支里清楚地知道`pet`的类型的话就好了。\n\nTypeScript里的_类型守卫_机制让它成为了现实。 类型守卫就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。\n\n#### 使用类型判定\n\n要定义一个类型守卫，我们只要简单地定义一个函数，它的返回值是一个_类型谓词_：\n\n```typescript\nfunction isFish(pet: Fish | Bird): pet is Fish {\n    return (pet as Fish).swim !== undefined;\n}\n```\n\n在这个例子里，`pet is Fish`就是类型谓词。 谓词为`parameterName is Type`这种形式，`parameterName`必须是来自于当前函数签名里的一个参数名。\n\n每当使用一些变量调用`isFish`时，TypeScript会将变量缩减为那个具体的类型，只要这个类型与变量的原始类型是兼容的。\n\n```typescript\n// \'swim\' 和 \'fly\' 调用都没有问题了\n\nif (isFish(pet)) {\n    pet.swim();\n}\nelse {\n    pet.fly();\n}\n```\n\n注意TypeScript不仅知道在`if`分支里`pet`是`Fish`类型； 它还清楚在`else`分支里，一定_不是_`Fish`类型，一定是`Bird`类型。\n\n#### 使用`in`操作符\n\n`in`操作符可以作为类型细化表达式来使用。\n\n对于`n in x`表达式，其中`n`是字符串字面量或字符串字面量类型且`x`是个联合类型，那么`true`分支的类型细化为有一个可选的或必须的属性`n`，`false`分支的类型细化为有一个可选的或不存在属性`n`。\n\n```typescript\nfunction move(pet: Fish | Bird) {\n    if ("swim" in pet) {\n        return pet.swim();\n    }\n    return pet.fly();\n}\n```\n\n### `typeof`类型守卫\n\n现在我们回过头来看看怎么使用联合类型书写`padLeft`代码。 我们可以像下面这样利用类型断言来写：\n\n```typescript\nfunction isNumber(x: any): x is number {\n    return typeof x === "number";\n}\n\nfunction isString(x: any): x is string {\n    return typeof x === "string";\n}\n\nfunction padLeft(value: string, padding: string | number) {\n    if (isNumber(padding)) {\n        return Array(padding + 1).join(" ") + value;\n    }\n    if (isString(padding)) {\n        return padding + value;\n    }\n    throw new Error(`Expected string or number, got \'${padding}\'.`);\n}\n```\n\n然而，必须要定义一个函数来判断类型是否是原始类型，这太痛苦了。 幸运的是，现在我们不必将`typeof x === "number"`抽象成一个函数，因为TypeScript可以将它识别为一个类型守卫。 也就是说我们可以直接在代码里检查类型了。\n\n```typescript\nfunction padLeft(value: string, padding: string | number) {\n    if (typeof padding === "number") {\n        return Array(padding + 1).join(" ") + value;\n    }\n    if (typeof padding === "string") {\n        return padding + value;\n    }\n    throw new Error(`Expected string or number, got \'${padding}\'.`);\n}\n```\n\n这些_`typeof`类型守卫_只有两种形式能被识别：`typeof v === "typename"`和`typeof v !== "typename"`，`"typename"`必须是`"number"`，`"string"`，`"boolean"`或`"symbol"`。 但是TypeScript并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型守卫。\n\n### `instanceof`类型守卫\n\n如果你已经阅读了`typeof`类型守卫并且对JavaScript里的`instanceof`操作符熟悉的话，你可能已经猜到了这节要讲的内容。\n\n_`instanceof`类型守卫_是通过构造函数来细化类型的一种方式。 比如，我们借鉴一下之前字符串填充的例子：\n\n```typescript\ninterface Padder {\n    getPaddingString(): string\n}\n\nclass SpaceRepeatingPadder implements Padder {\n    constructor(private numSpaces: number) { }\n    getPaddingString() {\n        return Array(this.numSpaces + 1).join(" ");\n    }\n}\n\nclass StringPadder implements Padder {\n    constructor(private value: string) { }\n    getPaddingString() {\n        return this.value;\n    }\n}\n\nfunction getRandomPadder() {\n    return Math.random() < 0.5 ?\n        new SpaceRepeatingPadder(4) :\n        new StringPadder("  ");\n}\n\n// 类型为SpaceRepeatingPadder | StringPadder\nlet padder: Padder = getRandomPadder();\n\nif (padder instanceof SpaceRepeatingPadder) {\n    padder; // 类型细化为\'SpaceRepeatingPadder\'\n}\nif (padder instanceof StringPadder) {\n    padder; // 类型细化为\'StringPadder\'\n}\n```\n\n`instanceof`的右侧要求是一个构造函数，TypeScript将细化为：\n\n1. 此构造函数的`prototype`属性的类型，如果它的类型不为`any`的话\n2. 构造签名所返回的类型的联合\n\n以此顺序。\n\n## 可以为`null`的类型\n\nTypeScript具有两种特殊的类型，`null`和`undefined`，它们分别具有值`null`和`undefined`. 我们在[基础类型](basic-types.md)一节里已经做过简要说明。 默认情况下，类型检查器认为`null`与`undefined`可以赋值给任何类型。 `null`与`undefined`是所有其它类型的一个有效值。 这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。 `null`的发明者，Tony Hoare，称它为[价值亿万美金的错误](https://en.wikipedia.org/wiki/Null_pointer#History)。\n\n`--strictNullChecks`标记可以解决此错误：当你声明一个变量时，它不会自动地包含`null`或`undefined`。 你可以使用联合类型明确的包含它们：\n\n```typescript\nlet s = "foo";\ns = null; // 错误, \'null\'不能赋值给\'string\'\nlet sn: string | null = "bar";\nsn = null; // 可以\n\nsn = undefined; // error, \'undefined\'不能赋值给\'string | null\'\n```\n\n注意，按照JavaScript的语义，TypeScript会把`null`和`undefined`区别对待。 `string | null`，`string | undefined`和`string | undefined | null`是不同的类型。\n\n### 可选参数和可选属性\n\n使用了`--strictNullChecks`，可选参数会被自动地加上`| undefined`:\n\n```typescript\nfunction f(x: number, y?: number) {\n    return x + (y || 0);\n}\nf(1, 2);\nf(1);\nf(1, undefined);\nf(1, null); // error, \'null\' is not assignable to \'number | undefined\'\n```\n\n可选属性也会有同样的处理：\n\n```typescript\nclass C {\n    a: number;\n    b?: number;\n}\nlet c = new C();\nc.a = 12;\nc.a = undefined; // error, \'undefined\' is not assignable to \'number\'\nc.b = 13;\nc.b = undefined; // ok\nc.b = null; // error, \'null\' is not assignable to \'number | undefined\'\n```\n\n### 类型守卫和类型断言\n\n由于可以为`null`的类型是通过联合类型实现，那么你需要使用类型守卫来去除`null`。 幸运地是这与在JavaScript里写的代码一致：\n\n```typescript\nfunction f(sn: string | null): string {\n    if (sn == null) {\n        return "default";\n    }\n    else {\n        return sn;\n    }\n}\n```\n\n这里很明显地去除了`null`，你也可以使用短路运算符：\n\n```typescript\nfunction f(sn: string | null): string {\n    return sn || "default";\n}\n```\n\n如果编译器不能够去除`null`或`undefined`，你可以使用类型断言手动去除。 语法是添加`!`后缀：`identifier!`从`identifier`的类型里去除了`null`和`undefined`：\n\n```typescript\nfunction broken(name: string | null): string {\n  function postfix(epithet: string) {\n    return name.charAt(0) + \'.  the \' + epithet; // error, \'name\' is possibly null\n  }\n  name = name || "Bob";\n  return postfix("great");\n}\n\nfunction fixed(name: string | null): string {\n  function postfix(epithet: string) {\n    return name!.charAt(0) + \'.  the \' + epithet; // ok\n  }\n  name = name || "Bob";\n  return postfix("great");\n}\n```\n\n本例使用了嵌套函数，因为编译器无法去除嵌套函数的`null`（除非是立即调用的函数表达式）。 因为它无法跟踪所有对嵌套函数的调用，尤其是你将内层函数做为外层函数的返回值。 如果无法知道函数在哪里被调用，就无法知道调用时`name`的类型。\n\n## 类型别名\n\n类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。\n\n```typescript\ntype Name = string;\ntype NameResolver = () => string;\ntype NameOrResolver = Name | NameResolver;\nfunction getName(n: NameOrResolver): Name {\n    if (typeof n === \'string\') {\n        return n;\n    }\n    else {\n        return n();\n    }\n}\n```\n\n起别名不会新建一个类型 - 它创建了一个新_名字_来引用那个类型。 给原始类型起别名通常没什么用，尽管可以做为文档的一种形式使用。\n\n同接口一样，类型别名也可以是泛型 - 我们可以添加类型参数并且在别名声明的右侧传入：\n\n```typescript\ntype Container<T> = { value: T };\n```\n\n我们也可以使用类型别名来在属性里引用自己：\n\n```typescript\ntype Tree<T> = {\n    value: T;\n    left: Tree<T>;\n    right: Tree<T>;\n}\n```\n\n与交叉类型一起使用，我们可以创建出一些十分稀奇古怪的类型。\n\n```typescript\ntype LinkedList<T> = T & { next: LinkedList<T> };\n\ninterface Person {\n    name: string;\n}\n\nvar people: LinkedList<Person>;\nvar s = people.name;\nvar s = people.next.name;\nvar s = people.next.next.name;\nvar s = people.next.next.next.name;\n```\n\n然而，类型别名不能出现在声明右侧的任何地方。\n\n```typescript\ntype Yikes = Array<Yikes>; // error\n```\n\n### 接口 vs. 类型别名\n\n像我们提到的，类型别名可以像接口一样；然而，仍有一些细微差别。\n\n其一，接口创建了一个新的名字，可以在其它任何地方使用。 类型别名并不创建新名字—比如，错误信息就不会使用别名。 在下面的示例代码里，在编译器中将鼠标悬停在`interfaced`上，显示它返回的是`Interface`，但悬停在`aliased`上时，显示的却是对象字面量类型。\n\n```typescript\ntype Alias = { num: number }\ninterface Interface {\n    num: number;\n}\ndeclare function aliased(arg: Alias): Alias;\ndeclare function interfaced(arg: Interface): Interface;\n```\n\n在旧版本的TypeScript里，类型别名不能被继承和实现（它们也不能继承和实现其它类型）。从TypeScript 2.7开始，类型别名可以被继承并生成新的交叉类型。例如：`type Cat = Animal & { purrs: true }`。\n\n因为[软件中的对象应该对于扩展是开放的，但是对于修改是封闭的](https://en.wikipedia.org/wiki/Open/closed_principle)，你应该尽量去使用接口代替类型别名。\n\n另一方面，如果你无法通过接口来描述一个类型并且需要使用联合类型或元组类型，这时通常会使用类型别名。\n\n## 字符串字面量类型\n\n字符串字面量类型允许你指定字符串必须的固定值。 在实际应用中，字符串字面量类型可以与联合类型，类型守卫和类型别名很好的配合。 通过结合使用这些特性，你可以实现类似枚举类型的字符串。\n\n```typescript\ntype Easing = "ease-in" | "ease-out" | "ease-in-out";\nclass UIElement {\n    animate(dx: number, dy: number, easing: Easing) {\n        if (easing === "ease-in") {\n            // ...\n        }\n        else if (easing === "ease-out") {\n        }\n        else if (easing === "ease-in-out") {\n        }\n        else {\n            // error! should not pass null or undefined.\n        }\n    }\n}\n\nlet button = new UIElement();\nbutton.animate(0, 0, "ease-in");\nbutton.animate(0, 0, "uneasy"); // error: "uneasy" is not allowed here\n```\n\n你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。\n\n```text\nArgument of type \'"uneasy"\' is not assignable to parameter of type \'"ease-in" | "ease-out" | "ease-in-out"\'\n```\n\n字符串字面量类型还可以用于区分函数重载：\n\n```typescript\nfunction createElement(tagName: "img"): HTMLImageElement;\nfunction createElement(tagName: "input"): HTMLInputElement;\n// ... more overloads ...\nfunction createElement(tagName: string): Element {\n    // ... code goes here ...\n}\n```\n\n## 数字字面量类型\n\nTypeScript还具有数字字面量类型。\n\n```typescript\nfunction rollDice(): 1 | 2 | 3 | 4 | 5 | 6 {\n    // ...\n}\n```\n\n我们很少直接这样使用，但它们可以用在缩小范围调试bug的时候：\n\n```typescript\nfunction foo(x: number) {\n    if (x !== 1 || x !== 2) {\n        //         ~~~~~~~\n        // Operator \'!==\' cannot be applied to types \'1\' and \'2\'.\n    }\n}\n```\n\n换句话说，当`x`与`2`进行比较的时候，它的值必须为`1`，这就意味着上面的比较检查是非法的。\n\n## 枚举成员类型\n\n如我们在[枚举](enums.md#union-enums-and-enum-member-types)一节里提到的，当每个枚举成员都是用字面量初始化的时候枚举成员是具有类型的。\n\n在我们谈及“单例类型”的时候，多数是指枚举成员类型和数字/字符串字面量类型，尽管大多数用户会互换使用“单例类型”和“字面量类型”。\n\n## 可辨识联合（Discriminated Unions）\n\n你可以合并单例类型，联合类型，类型守卫和类型别名来创建一个叫做_可辨识联合_的高级模式，它也称做_标签联合_或_代数数据类型_。 可辨识联合在函数式编程里很有用处。 一些语言会自动地为你辨识联合；而TypeScript则基于已有的JavaScript模式。 它具有3个要素：\n\n1. 具有普通的单例类型属性—_可辨识的特征_。\n2. 一个类型别名包含了那些类型的联合—_联合_。\n3. 此属性上的类型守卫。\n\n```typescript\ninterface Square {\n    kind: "square";\n    size: number;\n}\ninterface Rectangle {\n    kind: "rectangle";\n    width: number;\n    height: number;\n}\ninterface Circle {\n    kind: "circle";\n    radius: number;\n}\n```\n\n首先我们声明了将要联合的接口。 每个接口都有`kind`属性但有不同的字符串字面量类型。 `kind`属性称做_可辨识的特征_或_标签_。 其它的属性则特定于各个接口。 注意，目前各个接口间是没有联系的。 下面我们把它们联合到一起：\n\n```typescript\ntype Shape = Square | Rectangle | Circle;\n```\n\n现在我们使用可辨识联合:\n\n```typescript\nfunction area(s: Shape) {\n    switch (s.kind) {\n        case "square": return s.size * s.size;\n        case "rectangle": return s.height * s.width;\n        case "circle": return Math.PI * s.radius ** 2;\n    }\n}\n```\n\n### 完整性检查\n\n当没有涵盖所有可辨识联合的变化时，我们想让编译器可以通知我们。 比如，如果我们添加了`Triangle`到`Shape`，我们同时还需要更新`area`:\n\n```typescript\ntype Shape = Square | Rectangle | Circle | Triangle;\nfunction area(s: Shape) {\n    switch (s.kind) {\n        case "square": return s.size * s.size;\n        case "rectangle": return s.height * s.width;\n        case "circle": return Math.PI * s.radius ** 2;\n    }\n    // should error here - we didn\'t handle case "triangle"\n}\n```\n\n有两种方式可以实现。 首先是启用`--strictNullChecks`并且指定一个返回值类型：\n\n```typescript\nfunction area(s: Shape): number { // error: returns number | undefined\n    switch (s.kind) {\n        case "square": return s.size * s.size;\n        case "rectangle": return s.height * s.width;\n        case "circle": return Math.PI * s.radius ** 2;\n    }\n}\n```\n\n因为`switch`没有包含所有情况，所以TypeScript认为这个函数有时候会返回`undefined`。 如果你明确地指定了返回值类型为`number`，那么你会看到一个错误，因为实际上返回值的类型为`number | undefined`。 然而，这种方法存在些微妙之处且`--strictNullChecks`对旧代码支持不好。\n\n第二种方法使用`never`类型，编译器用它来进行完整性检查：\n\n```typescript\nfunction assertNever(x: never): never {\n    throw new Error("Unexpected object: " + x);\n}\nfunction area(s: Shape) {\n    switch (s.kind) {\n        case "square": return s.size * s.size;\n        case "rectangle": return s.height * s.width;\n        case "circle": return Math.PI * s.radius ** 2;\n        default: return assertNever(s); // error here if there are missing cases\n    }\n}\n```\n\n这里，`assertNever`检查`s`是否为`never`类型—即为除去所有可能情况后剩下的类型。 如果你忘记了某个case，那么`s`将具有一个真实的类型并且你会得到一个错误。 这种方式需要你定义一个额外的函数，但是在你忘记某个case的时候也更加明显。\n\n## 多态的`this`类型\n\n多态的`this`类型表示的是某个包含类或接口的_子类型_。 这被称做_F_-bounded多态性。 它能很容易的表现连贯接口间的继承，比如。 在计算器的例子里，在每个操作之后都返回`this`类型：\n\n```typescript\nclass BasicCalculator {\n    public constructor(protected value: number = 0) { }\n    public currentValue(): number {\n        return this.value;\n    }\n    public add(operand: number): this {\n        this.value += operand;\n        return this;\n    }\n    public multiply(operand: number): this {\n        this.value *= operand;\n        return this;\n    }\n    // ... other operations go here ...\n}\n\nlet v = new BasicCalculator(2)\n            .multiply(5)\n            .add(1)\n            .currentValue();\n```\n\n由于这个类使用了`this`类型，你可以继承它，新的类可以直接使用之前的方法，不需要做任何的改变。\n\n```typescript\nclass ScientificCalculator extends BasicCalculator {\n    public constructor(value = 0) {\n        super(value);\n    }\n    public sin() {\n        this.value = Math.sin(this.value);\n        return this;\n    }\n    // ... other operations go here ...\n}\n\nlet v = new ScientificCalculator(2)\n        .multiply(5)\n        .sin()\n        .add(1)\n        .currentValue();\n```\n\n如果没有`this`类型，`ScientificCalculator`就不能够在继承`BasicCalculator`的同时还保持接口的连贯性。 `multiply`将会返回`BasicCalculator`，它并没有`sin`方法。 然而，使用`this`类型，`multiply`会返回`this`，在这里就是`ScientificCalculator`。\n\n## 索引类型（Index types）\n\n使用索引类型，编译器就能够检查使用了动态属性名的代码。 例如，一个常见的JavaScript模式是从对象中选取属性的子集。\n\n```javascript\nfunction pluck(o, propertyNames) {\n    return propertyNames.map(n => o[n]);\n}\n```\n\n下面是如何在TypeScript里使用此函数，通过**索引类型查询**和**索引访问**操作符：\n\n```typescript\nfunction pluck<T, K extends keyof T>(o: T, propertyNames: K[]): T[K][] {\n  return propertyNames.map(n => o[n]);\n}\n\ninterface Car {\n    manufacturer: string;\n    model: string;\n    year: number;\n}\nlet taxi: Car = {\n    manufacturer: \'Toyota\',\n    model: \'Camry\',\n    year: 2014\n};\n\n// Manufacturer and model are both of type string,\n// so we can pluck them both into a typed string array\nlet makeAndModel: string[] = pluck(taxi, [\'manufacturer\', \'model\']);\n\n// If we try to pluck model and year, we get an\n// array of a union type: (string | number)[]\nlet modelYear = pluck(taxi, [\'model\', \'year\'])\n```\n\n编译器会检查`manufacturer`和`model`是否真的是`Car`上的一个属性。 本例还引入了几个新的类型操作符。 首先是`keyof T`，**索引类型查询操作符**。 对于任何类型`T`，`keyof T`的结果为`T`上已知的公共属性名的联合。 例如：\n\n```typescript\nlet carProps: keyof Car; // the union of (\'manufacturer\' | \'model\' | \'year\')\n```\n\n`keyof Car`是完全可以与`\'manufacturer\' | \'model\' | \'year\'`互相替换的。 不同的是如果你添加了其它的属性到`Car`，例如`ownersAddress: string`，那么`keyof Car`会自动变为`\'manufacturer\' | \'model\' | \'year\' | \'ownersAddress\'`。 你可以在像`pluck`函数这类上下文里使用`keyof`，因为在使用之前你并不清楚可能出现的属性名。 但编译器会检查你是否传入了正确的属性名给`pluck`：\n\n```typescript\n// error, \'unknown\' is not in \'manufacturer\' | \'model\' | \'year\'\npluck(taxi, [\'year\', \'unknown\']);\n```\n\n第二个操作符是`T[K]`，**索引访问操作符**。 在这里，类型语法反映了表达式语法。 这意味着`person[\'name\']`具有类型`Person[\'name\']` — 在我们的例子里则为`string`类型。 然而，就像索引类型查询一样，你可以在普通的上下文里使用`T[K]`，这正是它的强大所在。 你只要确保类型变量`K extends keyof T`就可以了。 例如下面`getProperty`函数的例子：\n\n```typescript\nfunction getProperty<T, K extends keyof T>(o: T, propertyName: K): T[K] {\n    return o[propertyName]; // o[propertyName] is of type T[K]\n}\n```\n\n`getProperty`里的`o: T`和`propertyName: K`，意味着`o[propertyName]: T[K]`。 当你返回`T[K]`的结果，编译器会实例化键的真实类型，因此`getProperty`的返回值类型会随着你需要的属性改变。\n\n```typescript\nlet name: string = getProperty(taxi, \'manufacturer\');\nlet year: number = getProperty(taxi, \'year\');\n\n// error, \'unknown\' is not in \'manufacturer\' | \'model\' | \'year\'\nlet unknown = getProperty(taxi, \'unknown\');\n```\n\n### 索引类型和字符串索引签名\n\n`keyof`和`T[K]`与字符串索引签名进行交互。索引签名的参数类型必须为`number`或`string`。 如果你有一个带有字符串索引签名的类型，那么`keyof T`会是`string | number`。 \\(并非只有`string`，因为在JavaScript里，你可以使用字符串`object[\'42\'`或 数字`object[42]`索引来访问对象属性\\)。 并且`T[string]`为索引签名的类型：\n\n```typescript\ninterface Dictionary<T> {\n    [key: string]: T;\n}\nlet keys: keyof Dictionary<number>; // string | number\nlet value: Dictionary<number>[\'foo\']; // number\n```\n\n如果一个类型带有数字索引签名，那么`keyof T`为`number`。\n\n```typescript\ninterface Dictionary<T> {\n    [key: number]: T;\n}\nlet keys: keyof Dictionary<number>; // number\nlet value: Dictionary<number>[\'foo\']; // Error, Property \'foo\' does not exist on type \'Dictionary<number>\'.\nlet value: Dictionary<number>[42]; // number\n```\n\n## 映射类型\n\n一个常见的任务是将一个已知的类型每个属性都变为可选的：\n\n```typescript\ninterface PersonPartial {\n    name?: string;\n    age?: number;\n}\n```\n\n或者我们想要一个只读版本：\n\n```typescript\ninterface PersonReadonly {\n    readonly name: string;\n    readonly age: number;\n}\n```\n\n这在JavaScript里经常出现，TypeScript提供了从旧类型中创建新类型的一种方式 — **映射类型**。 在映射类型里，新类型以相同的形式去转换旧类型里每个属性。 例如，你可以令每个属性成为`readonly`类型或可选的。 下面是一些例子：\n\n```typescript\ntype Readonly<T> = {\n    readonly [P in keyof T]: T[P];\n}\ntype Partial<T> = {\n    [P in keyof T]?: T[P];\n}\n```\n\n像下面这样使用：\n\n```typescript\ntype PersonPartial = Partial<Person>;\ntype ReadonlyPerson = Readonly<Person>;\n```\n\n需要注意的是这个语法描述的是类型而非成员。 若想添加成员，则可以使用交叉类型：\n\n```typescript\n// 这样使用\ntype PartialWithNewMember<T> = {\n  [P in keyof T]?: T[P];\n} & { newMember: boolean }\n// 不要这样使用\n// 这会报错！\ntype PartialWithNewMember<T> = {\n  [P in keyof T]?: T[P];\n  newMember: boolean;\n}\n```\n\n下面来看看最简单的映射类型和它的组成部分：\n\n```typescript\ntype Keys = \'option1\' | \'option2\';\ntype Flags = { [K in Keys]: boolean };\n```\n\n它的语法与索引签名的语法类型，内部使用了`for .. in`。 具有三个部分：\n\n1. 类型变量`K`，它会依次绑定到每个属性。\n2. 字符串字面量联合的`Keys`，它包含了要迭代的属性名的集合。\n3. 属性的结果类型。\n\n在个简单的例子里，`Keys`是硬编码的属性名列表并且属性类型永远是`boolean`，因此这个映射类型等同于：\n\n```typescript\ntype Flags = {\n    option1: boolean;\n    option2: boolean;\n}\n```\n\n在真正的应用里，可能不同于上面的`Readonly`或`Partial`。 它们会基于一些已存在的类型，且按照一定的方式转换字段。 这就是`keyof`和索引访问类型要做的事情：\n\n```typescript\ntype NullablePerson = { [P in keyof Person]: Person[P] | null }\ntype PartialPerson = { [P in keyof Person]?: Person[P] }\n```\n\n但它更有用的地方是可以有一些通用版本。\n\n```typescript\ntype Nullable<T> = { [P in keyof T]: T[P] | null }\ntype Partial<T> = { [P in keyof T]?: T[P] }\n```\n\n在这些例子里，属性列表是`keyof T`且结果类型是`T[P]`的变体。 这是使用通用映射类型的一个好模版。 因为这类转换是[同态](https://en.wikipedia.org/wiki/Homomorphism)的，映射只作用于`T`的属性而没有其它的。 编译器知道在添加任何新属性之前可以拷贝所有存在的属性修饰符。 例如，假设`Person.name`是只读的，那么`Partial<Person>.name`也将是只读的且为可选的。\n\n下面是另一个例子，`T[P]`被包装在`Proxy<T>`类里：\n\n```typescript\ntype Proxy<T> = {\n    get(): T;\n    set(value: T): void;\n}\ntype Proxify<T> = {\n    [P in keyof T]: Proxy<T[P]>;\n}\nfunction proxify<T>(o: T): Proxify<T> {\n   // ... wrap proxies ...\n}\nlet proxyProps = proxify(props);\n```\n\n注意`Readonly<T>`和`Partial<T>`用处不小，因此它们与`Pick`和`Record`一同被包含进了TypeScript的标准库里：\n\n```typescript\ntype Pick<T, K extends keyof T> = {\n    [P in K]: T[P];\n}\ntype Record<K extends keyof any, T> = {\n    [P in K]: T;\n}\n```\n\n`Readonly`，`Partial`和`Pick`是同态的，但`Record`不是。 因为`Record`并不需要输入类型来拷贝属性，所以它不属于同态：\n\n```typescript\ntype ThreeStringProps = Record<\'prop1\' | \'prop2\' | \'prop3\', string>\n```\n\n非同态类型本质上会创建新的属性，因此它们不会从它处拷贝属性修饰符。\n\n### 由映射类型进行推断\n\n现在你了解了如何包装一个类型的属性，那么接下来就是如何拆包。 其实这也非常容易：\n\n```typescript\nfunction unproxify<T>(t: Proxify<T>): T {\n    let result = {} as T;\n    for (const k in t) {\n        result[k] = t[k].get();\n    }\n    return result;\n}\n\nlet originalProps = unproxify(proxyProps);\n```\n\n注意这个拆包推断只适用于同态的映射类型。 如果映射类型不是同态的，那么需要给拆包函数一个明确的类型参数。\n\n### 有条件类型\n\nTypeScript 2.8引入了_有条件类型_，它能够表示非统一的类型。 有条件的类型会以一个条件表达式进行类型关系检测，从而在两种类型中选择其一：\n\n```typescript\nT extends U ? X : Y\n```\n\n上面的类型意思是，若`T`能够赋值给`U`，那么类型是`X`，否则为`Y`。\n\n有条件的类型`T extends U ? X : Y`或者_解析_为`X`，或者_解析_为`Y`，再或者_延迟_解析，因为它可能依赖一个或多个类型变量。 若`T`或`U`包含类型参数，那么是否解析为`X`或`Y`或推迟，取决于类型系统是否有足够的信息来确定`T`总是可以赋值给`U`。\n\n下面是一些类型可以被立即解析的例子：\n\n```typescript\ndeclare function f<T extends boolean>(x: T): T extends true ? string : number;\n\n// Type is \'string | number\nlet x = f(Math.random() < 0.5)\n```\n\n另外一个例子涉及`TypeName`类型别名，它使用了嵌套了有条件类型：\n\n```typescript\ntype TypeName<T> =\n    T extends string ? "string" :\n    T extends number ? "number" :\n    T extends boolean ? "boolean" :\n    T extends undefined ? "undefined" :\n    T extends Function ? "function" :\n    "object";\n\ntype T0 = TypeName<string>;  // "string"\ntype T1 = TypeName<"a">;  // "string"\ntype T2 = TypeName<true>;  // "boolean"\ntype T3 = TypeName<() => void>;  // "function"\ntype T4 = TypeName<string[]>;  // "object"\n```\n\n下面是一个有条件类型被推迟解析的例子:\n\n```typescript\ninterface Foo {\n    propA: boolean;\n    propB: boolean;\n}\n\ndeclare function f<T>(x: T): T extends Foo ? string : number;\n\nfunction foo<U>(x: U) {\n    // Has type \'U extends Foo ? string : number\'\n    let a = f(x);\n\n    // This assignment is allowed though!\n    let b: string | number = a;\n}\n```\n\n这里，`a`变量含有未确定的有条件类型。 当有另一段代码调用`foo`，它会用其它类型替换`U`，TypeScript将重新计算有条件类型，决定它是否可以选择一个分支。\n\n与此同时，我们可以将有条件类型赋值给其它类型，只要有条件类型的每个分支都可以赋值给目标类型。 因此在我们的例子里，我们可以将`U extends Foo ? string : number`赋值给`string | number`，因为不管这个有条件类型最终结果是什么，它只能是`string`或`number`。\n\n#### 分布式有条件类型\n\n如果有条件类型里待检查的类型是`naked type parameter`，那么它也被称为“分布式有条件类型”。 分布式有条件类型在实例化时会自动分发成联合类型。 例如，实例化`T extends U ? X : Y`，`T`的类型为`A | B | C`，会被解析为`(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)`。\n\n**例子**\n\n```typescript\ntype T10 = TypeName<string | (() => void)>;  // "string" | "function"\ntype T12 = TypeName<string | string[] | undefined>;  // "string" | "object" | "undefined"\ntype T11 = TypeName<string[] | number[]>;  // "object"\n```\n\n在`T extends U ? X : Y`的实例化里，对`T`的引用被解析为联合类型的一部分（比如，`T`指向某一单个部分，在有条件类型分布到联合类型之后）。 此外，在`X`内对`T`的引用有一个附加的类型参数约束`U`（例如，`T`被当成在`X`内可赋值给`U`）。\n\n**例子**\n\n```typescript\ntype BoxedValue<T> = { value: T };\ntype BoxedArray<T> = { array: T[] };\ntype Boxed<T> = T extends any[] ? BoxedArray<T[number]> : BoxedValue<T>;\n\ntype T20 = Boxed<string>;  // BoxedValue<string>;\ntype T21 = Boxed<number[]>;  // BoxedArray<number>;\ntype T22 = Boxed<string | number[]>;  // BoxedValue<string> | BoxedArray<number>;\n```\n\n注意在`Boxed<T>`的`true`分支里，`T`有个额外的约束`any[]`，因此它适用于`T[number]`数组元素类型。同时也注意一下有条件类型是如何分布成联合类型的。\n\n有条件类型的分布式的属性可以方便地用来_过滤_联合类型：\n\n```typescript\ntype Diff<T, U> = T extends U ? never : T;  // Remove types from T that are assignable to U\ntype Filter<T, U> = T extends U ? T : never;  // Remove types from T that are not assignable to U\n\ntype T30 = Diff<"a" | "b" | "c" | "d", "a" | "c" | "f">;  // "b" | "d"\ntype T31 = Filter<"a" | "b" | "c" | "d", "a" | "c" | "f">;  // "a" | "c"\ntype T32 = Diff<string | number | (() => void), Function>;  // string | number\ntype T33 = Filter<string | number | (() => void), Function>;  // () => void\n\ntype NonNullable<T> = Diff<T, null | undefined>;  // Remove null and undefined from T\n\ntype T34 = NonNullable<string | number | undefined>;  // string | number\ntype T35 = NonNullable<string | string[] | null | undefined>;  // string | string[]\n\nfunction f1<T>(x: T, y: NonNullable<T>) {\n    x = y;  // Ok\n    y = x;  // Error\n}\n\nfunction f2<T extends string | undefined>(x: T, y: NonNullable<T>) {\n    x = y;  // Ok\n    y = x;  // Error\n    let s1: string = x;  // Error\n    let s2: string = y;  // Ok\n}\n```\n\n有条件类型与映射类型结合时特别有用：\n\n```typescript\ntype FunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T];\ntype FunctionProperties<T> = Pick<T, FunctionPropertyNames<T>>;\n\ntype NonFunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? never : K }[keyof T];\ntype NonFunctionProperties<T> = Pick<T, NonFunctionPropertyNames<T>>;\n\ninterface Part {\n    id: number;\n    name: string;\n    subparts: Part[];\n    updatePart(newName: string): void;\n}\n\ntype T40 = FunctionPropertyNames<Part>;  // "updatePart"\ntype T41 = NonFunctionPropertyNames<Part>;  // "id" | "name" | "subparts"\ntype T42 = FunctionProperties<Part>;  // { updatePart(newName: string): void }\ntype T43 = NonFunctionProperties<Part>;  // { id: number, name: string, subparts: Part[] }\n```\n\n与联合类型和交叉类型相似，有条件类型不允许递归地引用自己。比如下面的错误。\n\n**例子**\n\n```typescript\ntype ElementType<T> = T extends any[] ? ElementType<T[number]> : T;  // Error\n```\n\n#### 有条件类型中的类型推断\n\n现在在有条件类型的`extends`子语句中，允许出现`infer`声明，它会引入一个待推断的类型变量。 这个推断的类型变量可以在有条件类型的true分支中被引用。 允许出现多个同类型变量的`infer`。\n\n例如，下面代码会提取函数类型的返回值类型：\n\n```typescript\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;\n```\n\n有条件类型可以嵌套来构成一系列的匹配模式，按顺序进行求值：\n\n```typescript\ntype Unpacked<T> =\n    T extends (infer U)[] ? U :\n    T extends (...args: any[]) => infer U ? U :\n    T extends Promise<infer U> ? U :\n    T;\n\ntype T0 = Unpacked<string>;  // string\ntype T1 = Unpacked<string[]>;  // string\ntype T2 = Unpacked<() => string>;  // string\ntype T3 = Unpacked<Promise<string>>;  // string\ntype T4 = Unpacked<Promise<string>[]>;  // Promise<string>\ntype T5 = Unpacked<Unpacked<Promise<string>[]>>;  // string\n```\n\n下面的例子解释了在协变位置上，同一个类型变量的多个候选类型会被推断为联合类型：\n\n```typescript\ntype Foo<T> = T extends { a: infer U, b: infer U } ? U : never;\ntype T10 = Foo<{ a: string, b: string }>;  // string\ntype T11 = Foo<{ a: string, b: number }>;  // string | number\n```\n\n相似地，在抗变位置上，同一个类型变量的多个候选类型会被推断为交叉类型：\n\n```typescript\ntype Bar<T> = T extends { a: (x: infer U) => void, b: (x: infer U) => void } ? U : never;\ntype T20 = Bar<{ a: (x: string) => void, b: (x: string) => void }>;  // string\ntype T21 = Bar<{ a: (x: string) => void, b: (x: number) => void }>;  // string & number\n```\n\n当推断具有多个调用签名（例如函数重载类型）的类型时，用_最后_的签名（大概是最自由的包含所有情况的签名）进行推断。 无法根据参数类型列表来解析重载。\n\n```typescript\ndeclare function foo(x: string): number;\ndeclare function foo(x: number): string;\ndeclare function foo(x: string | number): string | number;\ntype T30 = ReturnType<typeof foo>;  // string | number\n```\n\n无法在正常类型参数的约束子语句中使用`infer`声明：\n\n```typescript\ntype ReturnType<T extends (...args: any[]) => infer R> = R;  // 错误，不支持\n```\n\n但是，可以这样达到同样的效果，在约束里删掉类型变量，用有条件类型替换：\n\n```typescript\ntype AnyFunction = (...args: any[]) => any;\ntype ReturnType<T extends AnyFunction> = T extends (...args: any[]) => infer R ? R : any;\n```\n\n#### 预定义的有条件类型\n\nTypeScript 2.8在`lib.d.ts`里增加了一些预定义的有条件类型：\n\n* `Exclude<T, U>` -- 从`T`中剔除可以赋值给`U`的类型。\n* `Extract<T, U>` -- 提取`T`中可以赋值给`U`的类型。\n* `NonNullable<T>` -- 从`T`中剔除`null`和`undefined`。\n* `ReturnType<T>` -- 获取函数返回值类型。\n* `InstanceType<T>` -- 获取构造函数类型的实例类型。\n\n**Example**\n\n```typescript\ntype T00 = Exclude<"a" | "b" | "c" | "d", "a" | "c" | "f">;  // "b" | "d"\ntype T01 = Extract<"a" | "b" | "c" | "d", "a" | "c" | "f">;  // "a" | "c"\n\ntype T02 = Exclude<string | number | (() => void), Function>;  // string | number\ntype T03 = Extract<string | number | (() => void), Function>;  // () => void\n\ntype T04 = NonNullable<string | number | undefined>;  // string | number\ntype T05 = NonNullable<(() => string) | string[] | null | undefined>;  // (() => string) | string[]\n\nfunction f1(s: string) {\n    return { a: 1, b: s };\n}\n\nclass C {\n    x = 0;\n    y = 0;\n}\n\ntype T10 = ReturnType<() => string>;  // string\ntype T11 = ReturnType<(s: string) => void>;  // void\ntype T12 = ReturnType<(<T>() => T)>;  // {}\ntype T13 = ReturnType<(<T extends U, U extends number[]>() => T)>;  // number[]\ntype T14 = ReturnType<typeof f1>;  // { a: number, b: string }\ntype T15 = ReturnType<any>;  // any\ntype T16 = ReturnType<never>;  // never\ntype T17 = ReturnType<string>;  // Error\ntype T18 = ReturnType<Function>;  // Error\n\ntype T20 = InstanceType<typeof C>;  // C\ntype T21 = InstanceType<any>;  // any\ntype T22 = InstanceType<never>;  // never\ntype T23 = InstanceType<string>;  // Error\ntype T24 = InstanceType<Function>;  // Error\n```\n\n> 注意：`Exclude`类型是[建议的](https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458)`Diff`类型的一种实现。我们使用`Exclude`这个名字是为了避免破坏已经定义了`Diff`的代码，并且我们感觉这个名字能更好地表达类型的语义。\n\n',Fl='# 声明合并\n\n## 介绍\n\nTypeScript中有些独特的概念可以在类型层面上描述JavaScript对象的模型。 这其中尤其独特的一个例子是“声明合并”的概念。 理解了这个概念，将有助于操作现有的JavaScript代码。 同时，也会有助于理解更多高级抽象的概念。\n\n对本文件来讲，“声明合并”是指编译器将针对同一个名字的两个独立声明合并为单一声明。 合并后的声明同时拥有原先两个声明的特性。 任何数量的声明都可被合并；不局限于两个声明。\n\n## 基础概念\n\nTypeScript中的声明会创建以下三种实体之一：命名空间，类型或值。 创建命名空间的声明会新建一个命名空间，它包含了用（.）符号来访问时使用的名字。 创建类型的声明是：用声明的模型创建一个类型并绑定到给定的名字上。 最后，创建值的声明会创建在JavaScript输出中看到的值。\n\n| Declaration Type | Namespace | Type | Value |\n| :--- | :---: | :---: | :---: |\n| Namespace | X |  | X |\n| Class |  | X | X |\n| Enum |  | X | X |\n| Interface |  | X |  |\n| Type Alias |  | X |  |\n| Function |  |  | X |\n| Variable |  |  | X |\n\n理解每个声明创建了什么，有助于理解当声明合并时有哪些东西被合并了。\n\n## 合并接口\n\n最简单也最常见的声明合并类型是接口合并。 从根本上说，合并的机制是把双方的成员放到一个同名的接口里。\n\n```typescript\ninterface Box {\n    height: number;\n    width: number;\n}\n\ninterface Box {\n    scale: number;\n}\n\nlet box: Box = {height: 5, width: 6, scale: 10};\n```\n\n接口的非函数的成员应该是唯一的。 如果它们不是唯一的，那么它们必须是相同的类型。 如果两个接口中同时声明了同名的非函数成员且它们的类型不同，则编译器会报错。\n\n对于函数成员，每个同名函数声明都会被当成这个函数的一个重载。 同时需要注意，当接口`A`与后来的接口`A`合并时，后面的接口具有更高的优先级。\n\n如下例所示：\n\n```typescript\ninterface Cloner {\n    clone(animal: Animal): Animal;\n}\n\ninterface Cloner {\n    clone(animal: Sheep): Sheep;\n}\n\ninterface Cloner {\n    clone(animal: Dog): Dog;\n    clone(animal: Cat): Cat;\n}\n```\n\n这三个接口合并成一个声明：\n\n```typescript\ninterface Cloner {\n    clone(animal: Dog): Dog;\n    clone(animal: Cat): Cat;\n    clone(animal: Sheep): Sheep;\n    clone(animal: Animal): Animal;\n}\n```\n\n注意每组接口里的声明顺序保持不变，但各组接口之间的顺序是后来的接口重载出现在靠前位置。\n\n这个规则有一个例外是当出现特殊的函数签名时。 如果签名里有一个参数的类型是_单一_的字符串字面量（比如，不是字符串字面量的联合类型），那么它将会被提升到重载列表的最顶端。\n\n比如，下面的接口会合并到一起：\n\n```typescript\ninterface Document {\n    createElement(tagName: any): Element;\n}\ninterface Document {\n    createElement(tagName: "div"): HTMLDivElement;\n    createElement(tagName: "span"): HTMLSpanElement;\n}\ninterface Document {\n    createElement(tagName: string): HTMLElement;\n    createElement(tagName: "canvas"): HTMLCanvasElement;\n}\n```\n\n合并后的`Document`将会像下面这样：\n\n```typescript\ninterface Document {\n    createElement(tagName: "canvas"): HTMLCanvasElement;\n    createElement(tagName: "div"): HTMLDivElement;\n    createElement(tagName: "span"): HTMLSpanElement;\n    createElement(tagName: string): HTMLElement;\n    createElement(tagName: any): Element;\n}\n```\n\n## 合并命名空间\n\n与接口相似，同名的命名空间也会合并其成员。 命名空间会创建出命名空间和值，我们需要知道这两者都是怎么合并的。\n\n对于命名空间的合并，模块导出的同名接口进行合并，构成单一命名空间内含合并后的接口。\n\n对于命名空间里值的合并，如果当前已经存在给定名字的命名空间，那么后来的命名空间的导出成员会被加到已经存在的那个模块里。\n\n`Animals`声明合并示例：\n\n```typescript\nnamespace Animals {\n    export class Zebra { }\n}\n\nnamespace Animals {\n    export interface Legged { numberOfLegs: number; }\n    export class Dog { }\n}\n```\n\n等同于：\n\n```typescript\nnamespace Animals {\n    export interface Legged { numberOfLegs: number; }\n\n    export class Zebra { }\n    export class Dog { }\n}\n```\n\n除了这些合并外，你还需要了解非导出成员是如何处理的。 非导出成员仅在其原有的（合并前的）命名空间内可见。这就是说合并之后，从其它命名空间合并进来的成员无法访问非导出成员。\n\n下例提供了更清晰的说明：\n\n```typescript\nnamespace Animal {\n    let haveMuscles = true;\n\n    export function animalsHaveMuscles() {\n        return haveMuscles;\n    }\n}\n\nnamespace Animal {\n    export function doAnimalsHaveMuscles() {\n        return haveMuscles;  // Error, because haveMuscles is not accessible here\n    }\n}\n```\n\n因为`haveMuscles`并没有导出，只有`animalsHaveMuscles`函数共享了原始未合并的命名空间可以访问这个变量。 `doAnimalsHaveMuscles`函数虽是合并命名空间的一部分，但是访问不了未导出的成员。\n\n## 命名空间与类和函数和枚举类型合并\n\n命名空间可以与其它类型的声明进行合并。 只要命名空间的定义符合将要合并类型的定义。合并结果包含两者的声明类型。 TypeScript使用这个功能去实现一些JavaScript里的设计模式。\n\n### 合并命名空间和类\n\n这让我们可以表示内部类。\n\n```typescript\nclass Album {\n    label: Album.AlbumLabel;\n}\nnamespace Album {\n    export class AlbumLabel { }\n}\n```\n\n合并规则与上面`合并命名空间`小节里讲的规则一致，我们必须导出`AlbumLabel`类，好让合并的类能访问。 合并结果是一个类并带有一个内部类。 你也可以使用命名空间为类增加一些静态属性。\n\n除了内部类的模式，你在JavaScript里，创建一个函数稍后扩展它增加一些属性也是很常见的。 TypeScript使用声明合并来达到这个目的并保证类型安全。\n\n```typescript\nfunction buildLabel(name: string): string {\n    return buildLabel.prefix + name + buildLabel.suffix;\n}\n\nnamespace buildLabel {\n    export let suffix = "";\n    export let prefix = "Hello, ";\n}\n\nconsole.log(buildLabel("Sam Smith"));\n```\n\n相似的，命名空间可以用来扩展枚举型：\n\n```typescript\nenum Color {\n    red = 1,\n    green = 2,\n    blue = 4\n}\n\nnamespace Color {\n    export function mixColor(colorName: string) {\n        if (colorName == "yellow") {\n            return Color.red + Color.green;\n        }\n        else if (colorName == "white") {\n            return Color.red + Color.green + Color.blue;\n        }\n        else if (colorName == "magenta") {\n            return Color.red + Color.blue;\n        }\n        else if (colorName == "cyan") {\n            return Color.green + Color.blue;\n        }\n    }\n}\n```\n\n## 非法的合并\n\nTypeScript并非允许所有的合并。 目前，类不能与其它类或变量合并。 想要了解如何模仿类的合并，请参考[TypeScript的混入](mixins.md)。\n\n## 模块扩展\n\n虽然JavaScript不支持合并，但你可以为导入的对象打补丁以更新它们。让我们考察一下这个玩具性的示例：\n\n```typescript\n// observable.ts\nexport class Observable<T> {\n    // ... implementation left as an exercise for the reader ...\n}\n\n// map.ts\nimport { Observable } from "./observable";\nObservable.prototype.map = function (f) {\n    // ... another exercise for the reader\n}\n```\n\n它也可以很好地工作在TypeScript中， 但编译器对 `Observable.prototype.map`一无所知。 你可以使用扩展模块来将它告诉编译器：\n\n```typescript\n// observable.ts\nexport class Observable<T> {\n    // ... implementation left as an exercise for the reader ...\n}\n\n// map.ts\nimport { Observable } from "./observable";\ndeclare module "./observable" {\n    interface Observable<T> {\n        map<U>(f: (x: T) => U): Observable<U>;\n    }\n}\nObservable.prototype.map = function (f) {\n    // ... another exercise for the reader\n}\n\n\n// consumer.ts\nimport { Observable } from "./observable";\nimport "./map";\nlet o: Observable<number>;\no.map(x => x.toFixed());\n```\n\n模块名的解析和用`import`/`export`解析模块标识符的方式是一致的。 更多信息请参考 [Modules](modules.md)。 当这些声明在扩展中合并时，就如同在原始位置被声明一样。 但是，有两点限制需要注意：\n\n1. 你不能在扩展中声明新的顶级声明－仅可以扩展模块中已经存在的声明。\n2. 默认导出也不能扩展，只有命名的导出才可以（因为你需要使用导出的名字来进行扩展，并且`default`是保留关键字 - 详情查看[\\#14080](https://github.com/Microsoft/TypeScript/issues/14080)）\n\n### 全局扩展\n\n你也以在模块内部添加声明到全局作用域中。\n\n```typescript\n// observable.ts\nexport class Observable<T> {\n    // ... still no implementation ...\n}\n\ndeclare global {\n    interface Array<T> {\n        toObservable(): Observable<T>;\n    }\n}\n\nArray.prototype.toObservable = function () {\n    // ...\n}\n```\n\n全局扩展与模块扩展的行为和限制是相同的。\n\n',Ul='# Decorators\n\n## 介绍\n\n随着TypeScript和ES6里引入了类，在一些场景下我们需要额外的特性来支持标注或修改类及其成员。 装饰器（Decorators）为我们在类的声明及成员上通过元编程语法添加标注提供了一种方式。 Javascript里的装饰器目前处在[建议征集的第二阶段](https://github.com/tc39/proposal-decorators)，但在TypeScript里已做为一项实验性特性予以支持。\n\n> 注意  装饰器是一项实验性特性，在未来的版本中可能会发生改变。\n\n若要启用实验性的装饰器特性，你必须在命令行或`tsconfig.json`里启用`experimentalDecorators`编译器选项：\n\n**命令行**:\n\n```text\ntsc --target ES5 --experimentalDecorators\n```\n\n**tsconfig.json**:\n\n```javascript\n{\n    "compilerOptions": {\n        "target": "ES5",\n        "experimentalDecorators": true\n    }\n}\n```\n\n## 装饰器\n\n_装饰器_是一种特殊类型的声明，它能够被附加到[类声明](decorators.md#class-decorators)，[方法](decorators.md#method-decorators)，[访问符](decorators.md#accessor-decorators)，[属性](decorators.md#property-decorators)或[参数](decorators.md#parameter-decorators)上。 装饰器使用`@expression`这种形式，`expression`求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。\n\n例如，有一个`@sealed`装饰器，我们会这样定义`sealed`函数：\n\n```typescript\nfunction sealed(target) {\n    // do something with "target" ...\n}\n```\n\n> 注意  后面[类装饰器](decorators.md#class-decorators)小节里有一个更加详细的例子。\n\n### 装饰器工厂\n\n如果我们要定制一个修饰器如何应用到一个声明上，我们得写一个装饰器工厂函数。 _装饰器工厂_就是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。\n\n我们可以通过下面的方式来写一个装饰器工厂函数：\n\n```typescript\nfunction color(value: string) { // 这是一个装饰器工厂\n    return function (target) { //  这是装饰器\n        // do something with "target" and "value"...\n    }\n}\n```\n\n> 注意  下面[方法装饰器](decorators.md#method-decorators)小节里有一个更加详细的例子。\n\n### 装饰器组合\n\n多个装饰器可以同时应用到一个声明上，就像下面的示例：\n\n* 书写在同一行上：\n\n```typescript\n@f @g x\n```\n\n* 书写在多行上：\n\n```typescript\n@f\n@g\nx\n```\n\n当多个装饰器应用于一个声明上，它们求值方式与[复合函数](http://en.wikipedia.org/wiki/Function_composition)相似。在这个模型下，当复合_f_和_g_时，复合的结果\\(_f_ ∘ _g_\\)\\(_x_\\)等同于_f_\\(_g_\\(_x_\\)\\)。\n\n同样的，在TypeScript里，当多个装饰器应用在一个声明上时会进行如下步骤的操作：\n\n1. 由上至下依次对装饰器表达式求值。\n2. 求值的结果会被当作函数，由下至上依次调用。\n\n如果我们使用[装饰器工厂](decorators.md#decorator-factories)的话，可以通过下面的例子来观察它们求值的顺序：\n\n```typescript\nfunction f() {\n    console.log("f(): evaluated");\n    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {\n        console.log("f(): called");\n    }\n}\n\nfunction g() {\n    console.log("g(): evaluated");\n    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {\n        console.log("g(): called");\n    }\n}\n\nclass C {\n    @f()\n    @g()\n    method() {}\n}\n```\n\n在控制台里会打印出如下结果：\n\n```text\nf(): evaluated\ng(): evaluated\ng(): called\nf(): called\n```\n\n### 装饰器求值\n\n类中不同声明上的装饰器将按以下规定的顺序应用：\n\n1. _参数装饰器_，然后依次是_方法装饰器_，_访问符装饰器_，或_属性装饰器_应用到每个实例成员。\n2. _参数装饰器_，然后依次是_方法装饰器_，_访问符装饰器_，或_属性装饰器_应用到每个静态成员。\n3. _参数装饰器_应用到构造函数。\n4. _类装饰器_应用到类。\n\n### 类装饰器\n\n_类装饰器_在类声明之前被声明（紧靠着类声明）。 类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。 类装饰器不能用在声明文件中\\(`.d.ts`\\)，也不能用在任何外部上下文中（比如`declare`的类）。\n\n类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。\n\n如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。\n\n> 注意  如果你要返回一个新的构造函数，你必须注意处理好原来的原型链。 在运行时的装饰器调用逻辑中_不会_为你做这些。\n\n下面是使用类装饰器\\(`@sealed`\\)的例子，应用在`Greeter`类：\n\n```typescript\n@sealed\nclass Greeter {\n    greeting: string;\n    constructor(message: string) {\n        this.greeting = message;\n    }\n    greet() {\n        return "Hello, " + this.greeting;\n    }\n}\n```\n\n我们可以这样定义`@sealed`装饰器：\n\n```typescript\nfunction sealed(constructor: Function) {\n    Object.seal(constructor);\n    Object.seal(constructor.prototype);\n}\n```\n\n当`@sealed`被执行的时候，它将密封此类的构造函数和原型。\\(注：参见[Object.seal](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/seal)\\)\n\n下面是一个重载构造函数的例子。\n\n```typescript\nfunction classDecorator<T extends {new(...args:any[]):{}}>(constructor:T) {\n    return class extends constructor {\n        newProperty = "new property";\n        hello = "override";\n    }\n}\n\n@classDecorator\nclass Greeter {\n    property = "property";\n    hello: string;\n    constructor(m: string) {\n        this.hello = m;\n    }\n}\n\nconsole.log(new Greeter("world"));\n```\n\n### 方法装饰器\n\n_方法装饰器_声明在一个方法的声明之前（紧靠着方法声明）。 它会被应用到方法的_属性描述符_上，可以用来监视，修改或者替换方法定义。 方法装饰器不能用在声明文件\\(`.d.ts`\\)，重载或者任何外部上下文（比如`declare`的类）中。\n\n方法装饰器表达式会在运行时当作函数被调用，传入下列3个参数：\n\n1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n2. 成员的名字。\n3. 成员的_属性描述符_。\n\n> 注意  如果代码输出目标版本小于`ES5`，_属性描述符_将会是`undefined`。\n\n如果方法装饰器返回一个值，它会被用作方法的_属性描述符_。\n\n> 注意  如果代码输出目标版本小于`ES5`返回值会被忽略。\n\n下面是一个方法装饰器（`@enumerable`）的例子，应用于`Greeter`类的方法上：\n\n```typescript\nclass Greeter {\n    greeting: string;\n    constructor(message: string) {\n        this.greeting = message;\n    }\n\n    @enumerable(false)\n    greet() {\n        return "Hello, " + this.greeting;\n    }\n}\n```\n\n我们可以用下面的函数声明来定义`@enumerable`装饰器：\n\n```typescript\nfunction enumerable(value: boolean) {\n    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n        descriptor.enumerable = value;\n    };\n}\n```\n\n这里的`@enumerable(false)`是一个[装饰器工厂](decorators.md#decorator-factories)。 当装饰器`@enumerable(false)`被调用时，它会修改属性描述符的`enumerable`属性。\n\n### 访问器装饰器\n\n_访问器装饰器_声明在一个访问器的声明之前（紧靠着访问器声明）。 访问器装饰器应用于访问器的_属性描述符_并且可以用来监视，修改或替换一个访问器的定义。 访问器装饰器不能用在声明文件中（.d.ts），或者任何外部上下文（比如`declare`的类）里。\n\n> 注意  TypeScript不允许同时装饰一个成员的`get`和`set`访问器。取而代之的是，一个成员的所有装饰的必须应用在文档顺序的第一个访问器上。这是因为，在装饰器应用于一个_属性描述符_时，它联合了`get`和`set`访问器，而不是分开声明的。\n\n访问器装饰器表达式会在运行时当作函数被调用，传入下列3个参数：\n\n1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n2. 成员的名字。\n3. 成员的_属性描述符_。\n\n> 注意  如果代码输出目标版本小于`ES5`，_Property Descriptor_将会是`undefined`。\n\n如果访问器装饰器返回一个值，它会被用作方法的_属性描述符_。\n\n> 注意  如果代码输出目标版本小于`ES5`返回值会被忽略。\n\n下面是使用了访问器装饰器（`@configurable`）的例子，应用于`Point`类的成员上：\n\n```typescript\nclass Point {\n    private _x: number;\n    private _y: number;\n    constructor(x: number, y: number) {\n        this._x = x;\n        this._y = y;\n    }\n\n    @configurable(false)\n    get x() { return this._x; }\n\n    @configurable(false)\n    get y() { return this._y; }\n}\n```\n\n我们可以通过如下函数声明来定义`@configurable`装饰器：\n\n```typescript\nfunction configurable(value: boolean) {\n    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n        descriptor.configurable = value;\n    };\n}\n```\n\n### 属性装饰器\n\n_属性装饰器_声明在一个属性声明之前（紧靠着属性声明）。 属性装饰器不能用在声明文件中（.d.ts），或者任何外部上下文（比如`declare`的类）里。\n\n属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数：\n\n1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n2. 成员的名字。\n\n> 注意  _属性描述符_不会做为参数传入属性装饰器，这与TypeScript是如何初始化属性装饰器的有关。 因为目前没有办法在定义一个原型对象的成员时描述一个实例属性，并且没办法监视或修改一个属性的初始化方法。返回值也会被忽略。 因此，属性描述符只能用来监视类中是否声明了某个名字的属性。\n\n如果访问符装饰器返回一个值，它会被用作方法的_属性描述符_。\n\n我们可以用它来记录这个属性的元数据，如下例所示：\n\n```typescript\nclass Greeter {\n    @format("Hello, %s")\n    greeting: string;\n\n    constructor(message: string) {\n        this.greeting = message;\n    }\n    greet() {\n        let formatString = getFormat(this, "greeting");\n        return formatString.replace("%s", this.greeting);\n    }\n}\n```\n\n然后定义`@format`装饰器和`getFormat`函数：\n\n```typescript\nimport "reflect-metadata";\n\nconst formatMetadataKey = Symbol("format");\n\nfunction format(formatString: string) {\n    return Reflect.metadata(formatMetadataKey, formatString);\n}\n\nfunction getFormat(target: any, propertyKey: string) {\n    return Reflect.getMetadata(formatMetadataKey, target, propertyKey);\n}\n```\n\n这个`@format("Hello, %s")`装饰器是个 [装饰器工厂](decorators.md#decorator-factories)。 当`@format("Hello, %s")`被调用时，它添加一条这个属性的元数据，通过`reflect-metadata`库里的`Reflect.metadata`函数。 当`getFormat`被调用时，它读取格式的元数据。\n\n> 注意  这个例子需要使用`reflect-metadata`库。 查看[元数据](decorators.md#metadata)了解`reflect-metadata`库更详细的信息。\n\n### 参数装饰器\n\n_参数装饰器_声明在一个参数声明之前（紧靠着参数声明）。 参数装饰器应用于类构造函数或方法声明。 参数装饰器不能用在声明文件（.d.ts），重载或其它外部上下文（比如`declare`的类）里。\n\n参数装饰器表达式会在运行时当作函数被调用，传入下列3个参数：\n\n1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n2. 成员的名字。\n3. 参数在函数参数列表中的索引。\n\n> 注意  参数装饰器只能用来监视一个方法的参数是否被传入。\n\n参数装饰器的返回值会被忽略。\n\n下例定义了参数装饰器（`@required`）并应用于`Greeter`类方法的一个参数：\n\n```typescript\nclass Greeter {\n    greeting: string;\n\n    constructor(message: string) {\n        this.greeting = message;\n    }\n\n    @validate\n    greet(@required name: string) {\n        return "Hello " + name + ", " + this.greeting;\n    }\n}\n```\n\n然后我们使用下面的函数定义 `@required` 和 `@validate` 装饰器：\n\n```typescript\nimport "reflect-metadata";\n\nconst requiredMetadataKey = Symbol("required");\n\nfunction required(target: Object, propertyKey: string | symbol, parameterIndex: number) {\n    let existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];\n    existingRequiredParameters.push(parameterIndex);\n    Reflect.defineMetadata(requiredMetadataKey, existingRequiredParameters, target, propertyKey);\n}\n\nfunction validate(target: any, propertyName: string, descriptor: TypedPropertyDescriptor<Function>) {\n    let method = descriptor.value;\n    descriptor.value = function () {\n        let requiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName);\n        if (requiredParameters) {\n            for (let parameterIndex of requiredParameters) {\n                if (parameterIndex >= arguments.length || arguments[parameterIndex] === undefined) {\n                    throw new Error("Missing required argument.");\n                }\n            }\n        }\n\n        return method.apply(this, arguments);\n    }\n}\n```\n\n`@required`装饰器添加了元数据实体把参数标记为必需的。 `@validate`装饰器把`greet`方法包裹在一个函数里在调用原先的函数前验证函数参数。\n\n> 注意  这个例子使用了`reflect-metadata`库。 查看[元数据](decorators.md#metadata)了解`reflect-metadata`库的更多信息。\n\n### 元数据\n\n一些例子使用了`reflect-metadata`库来支持[实验性的metadata API](https://github.com/rbuckton/ReflectDecorators)。 这个库还不是ECMAScript \\(JavaScript\\)标准的一部分。 然而，当装饰器被ECMAScript官方标准采纳后，这些扩展也将被推荐给ECMAScript以采纳。\n\n你可以通过npm安装这个库：\n\n```text\nnpm i reflect-metadata --save\n```\n\nTypeScript支持为带有装饰器的声明生成元数据。 你需要在命令行或`tsconfig.json`里启用`emitDecoratorMetadata`编译器选项。\n\n**Command Line**:\n\n```text\ntsc --target ES5 --experimentalDecorators --emitDecoratorMetadata\n```\n\n**tsconfig.json**:\n\n```javascript\n{\n    "compilerOptions": {\n        "target": "ES5",\n        "experimentalDecorators": true,\n        "emitDecoratorMetadata": true\n    }\n}\n```\n\n当启用后，只要`reflect-metadata`库被引入了，设计阶段添加的类型信息可以在运行时使用。\n\n如下例所示：\n\n```typescript\nimport "reflect-metadata";\n\nclass Point {\n    x: number;\n    y: number;\n}\n\nclass Line {\n    private _p0: Point;\n    private _p1: Point;\n\n    @validate\n    set p0(value: Point) { this._p0 = value; }\n    get p0() { return this._p0; }\n\n    @validate\n    set p1(value: Point) { this._p1 = value; }\n    get p1() { return this._p1; }\n}\n\nfunction validate<T>(target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<T>) {\n    let set = descriptor.set;\n    descriptor.set = function (value: T) {\n        let type = Reflect.getMetadata("design:type", target, propertyKey);\n        if (!(value instanceof type)) {\n            throw new TypeError("Invalid type.");\n        }\n        set.call(target, value);\n    }\n}\n```\n\nTypeScript编译器可以通过`@Reflect.metadata`装饰器注入设计阶段的类型信息。 你可以认为它相当于下面的TypeScript：\n\n```typescript\nclass Line {\n    private _p0: Point;\n    private _p1: Point;\n\n    @validate\n    @Reflect.metadata("design:type", Point)\n    set p0(value: Point) { this._p0 = value; }\n    get p0() { return this._p0; }\n\n    @validate\n    @Reflect.metadata("design:type", Point)\n    set p1(value: Point) { this._p1 = value; }\n    get p1() { return this._p1; }\n}\n```\n\n> 注意  装饰器元数据是个实验性的特性并且可能在以后的版本中发生破坏性的改变（breaking changes）。\n\n',ql='# Iterators 和 Generators\n\n当一个对象实现了[`Symbol.iterator`](symbols.md#symboliterator)属性时，我们认为它是可迭代的。 一些内置的类型如`Array`，`Map`，`Set`，`String`，`Int32Array`，`Uint32Array`等都已经实现了各自的`Symbol.iterator`。 对象上的`Symbol.iterator`函数负责返回供迭代的值。\n\n## `for..of` 语句\n\n`for..of`会遍历可迭代的对象，调用对象上的`Symbol.iterator`方法。 下面是在数组上使用`for..of`的简单例子：\n\n```typescript\nlet someArray = [1, "string", false];\n\nfor (let entry of someArray) {\n    console.log(entry); // 1, "string", false\n}\n```\n\n### `for..of` vs. `for..in` 语句\n\n`for..of`和`for..in`均可迭代一个列表；但是用于迭代的值却不同，`for..in`迭代的是对象的 _键_ 的列表，而`for..of`则迭代对象的键对应的值。\n\n下面的例子展示了两者之间的区别：\n\n```typescript\nlet list = [4, 5, 6];\n\nfor (let i in list) {\n    console.log(i); // "0", "1", "2",\n}\n\nfor (let i of list) {\n    console.log(i); // "4", "5", "6"\n}\n```\n\n另一个区别是`for..in`可以操作任何对象；它提供了查看对象属性的一种方法。 但是`for..of`关注于迭代对象的值。内置对象`Map`和`Set`已经实现了`Symbol.iterator`方法，让我们可以访问它们保存的值。\n\n```typescript\nlet pets = new Set(["Cat", "Dog", "Hamster"]);\npets["species"] = "mammals";\n\nfor (let pet in pets) {\n    console.log(pet); // "species"\n}\n\nfor (let pet of pets) {\n    console.log(pet); // "Cat", "Dog", "Hamster"\n}\n```\n\n### 代码生成\n\n#### 目标为 ES5 和 ES3\n\n当生成目标为ES5或ES3，迭代器只允许在`Array`类型上使用。 在非数组值上使用`for..of`语句会得到一个错误，就算这些非数组值已经实现了`Symbol.iterator`属性。\n\n编译器会生成一个简单的`for`循环做为`for..of`循环，比如：\n\n```typescript\nlet numbers = [1, 2, 3];\nfor (let num of numbers) {\n    console.log(num);\n}\n```\n\n生成的代码为：\n\n```javascript\nvar numbers = [1, 2, 3];\nfor (var _i = 0; _i < numbers.length; _i++) {\n    var num = numbers[_i];\n    console.log(num);\n}\n```\n\n#### 目标为 ECMAScript 2015 或更高\n\n当目标为兼容ECMAScipt 2015的引擎时，编译器会生成相应引擎的`for..of`内置迭代器实现方式。\n\n',Bl='# JSX\n\n## 介绍\n\n[JSX](https://facebook.github.io/jsx/)是一种嵌入式的类似XML的语法。 它可以被转换成合法的JavaScript，尽管转换的语义是依据不同的实现而定的。 JSX因[React](https://reactjs.org/)框架而流行，但也存在其它的实现。 TypeScript支持内嵌，类型检查以及将JSX直接编译为JavaScript。\n\n## 基本用法\n\n想要使用JSX必须做两件事：\n\n1. 给文件一个`.tsx`扩展名\n2. 启用`jsx`选项\n\nTypeScript具有三种JSX模式：`preserve`，`react`和`react-native`。 这些模式只在代码生成阶段起作用 - 类型检查并不受影响。 在`preserve`模式下生成代码中会保留JSX以供后续的转换操作使用（比如：[Babel](https://babeljs.io/)）。 另外，输出文件会带有`.jsx`扩展名。 `react`模式会生成`React.createElement`，在使用前不需要再进行转换操作了，输出文件的扩展名为`.js`。 `react-native`相当于`preserve`，它也保留了所有的JSX，但是输出文件的扩展名是`.js`。\n\n| 模式 | 输入 | 输出 | 输出文件扩展名 |\n| :--- | :--- | :--- | :--- |\n| `preserve` | `<div />` | `<div />` | `.jsx` |\n| `react` | `<div />` | `React.createElement("div")` | `.js` |\n| `react-native` | `<div />` | `<div />` | `.js` |\n\n你可以通过在命令行里使用`--jsx`标记或[tsconfig.json](../project-config/tsconfig.json.md)里的选项来指定模式。\n\n> \\*注意：当输出目标为`react JSX`时，你可以使用`--jsxFactory`指定JSX工厂函数（默认值为`React.createElement`）\n\n## `as`操作符\n\n回想一下怎么写类型断言：\n\n```typescript\nvar foo = <foo>bar;\n```\n\n这里断言`bar`变量是`foo`类型的。 因为TypeScript也使用尖括号来表示类型断言，在结合JSX的语法后将带来解析上的困难。因此，TypeScript在`.tsx`文件里禁用了使用尖括号的类型断言。\n\n由于不能够在`.tsx`文件里使用上述语法，因此我们应该使用另一个类型断言操作符：`as`。 上面的例子可以很容易地使用`as`操作符改写：\n\n```typescript\nvar foo = bar as foo;\n```\n\n`as`操作符在`.ts`和`.tsx`里都可用，并且与尖括号类型断言行为是等价的。\n\n## 类型检查\n\n为了理解JSX的类型检查，你必须首先理解固有元素与基于值的元素之间的区别。 假设有这样一个JSX表达式`<expr />`，`expr`可能引用环境自带的某些东西（比如，在DOM环境里的`div`或`span`）或者是你自定义的组件。 这是非常重要的，原因有如下两点：\n\n1. 对于React，固有元素会生成字符串（`React.createElement("div")`），然而由你自定义的组件却不会生成（`React.createElement(MyComponent)`）。\n2. 传入JSX元素里的属性类型的查找方式不同。\n\n   固有元素属性_本身_就支持，然而自定义的组件会自己去指定它们具有哪个属性。\n\nTypeScript使用[与React相同的规范](http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components) 来区别它们。 固有元素总是以一个小写字母开头，基于值的元素总是以一个大写字母开头。\n\n### 固有元素\n\n固有元素使用特殊的接口`JSX.IntrinsicElements`来查找。 默认地，如果这个接口没有指定，会全部通过，不对固有元素进行类型检查。 然而，如果这个接口存在，那么固有元素的名字需要在`JSX.IntrinsicElements`接口的属性里查找。 例如：\n\n```typescript\ndeclare namespace JSX {\n    interface IntrinsicElements {\n        foo: any\n    }\n}\n\n<foo />; // 正确\n<bar />; // 错误\n```\n\n在上例中，`<foo />`没有问题，但是`<bar />`会报错，因为它没在`JSX.IntrinsicElements`里指定。\n\n> 注意：你也可以在`JSX.IntrinsicElements`上指定一个用来捕获所有字符串索引：\n\n```typescript\ndeclare namespace JSX {\n    interface IntrinsicElements {\n        [elemName: string]: any;\n    }\n}\n```\n\n### 基于值的元素\n\n基于值的元素会简单的在它所在的作用域里按标识符查找。\n\n```typescript\nimport MyComponent from "./myComponent";\n\n<MyComponent />; // 正确\n<SomeOtherComponent />; // 错误\n```\n\n有两种方式可以定义基于值的元素：\n\n1. 函数组件 \\(FC\\)\n2. 类组件\n\n由于这两种基于值的元素在JSX表达式里无法区分，因此TypeScript首先会尝试将表达式做为函数组件进行解析。如果解析成功，那么TypeScript就完成了表达式到其声明的解析操作。如果按照函数组件解析失败，那么TypeScript会继续尝试以类组件的形式进行解析。如果依旧失败，那么将输出一个错误。\n\n#### 函数组件\n\n正如其名，组件被定义成JavaScript函数，它的第一个参数是`props`对象。 TypeScript会强制它的返回值可以赋值给`JSX.Element`。\n\n```typescript\ninterface FooProp {\n  name: string;\n  X: number;\n  Y: number;\n}\n\ndeclare function AnotherComponent(prop: {name: string});\nfunction ComponentFoo(prop: FooProp) {\n  return <AnotherComponent name={prop.name} />;\n}\n\nconst Button = (prop: {value: string}, context: { color: string }) => <button>\n```\n\n由于函数组件是简单的JavaScript函数，所以我们还可以利用函数重载。\n\n```typescript\ninterface ClickableProps {\n  children: JSX.Element[] | JSX.Element\n}\n\ninterface HomeProps extends ClickableProps {\n  home: JSX.Element;\n}\n\ninterface SideProps extends ClickableProps {\n  side: JSX.Element | string;\n}\n\nfunction MainButton(prop: HomeProps): JSX.Element;\nfunction MainButton(prop: SideProps): JSX.Element {\n  ...\n}\n```\n\n> 注意：函数组件之前叫做无状态函数组件（SFC）。由于在当前React版本里，函数组件不再被当作是无状态的，因此类型`SFC`和它的别名`StatelessComponent`被废弃了。\n\n#### 类组件\n\n我们可以定义类组件的类型。 然而，我们首先最好弄懂两个新的术语：_元素类的类型_和_元素实例的类型_。\n\n现在有`<Expr />`，_元素类的类型_为`Expr`的类型。 所以在上面的例子里，如果`MyComponent`是ES6的类，那么类类型就是类的构造函数和静态部分。 如果`MyComponent`是个工厂函数，类类型为这个函数。\n\n一旦建立起了类类型，实例类型由类构造器或调用签名（如果存在的话）的返回值的联合构成。 再次说明，在ES6类的情况下，实例类型为这个类的实例的类型，并且如果是工厂函数，实例类型为这个函数返回值类型。\n\n```typescript\nclass MyComponent {\n  render() {}\n}\n\n// 使用构造签名\nvar myComponent = new MyComponent();\n\n// 元素类的类型 => MyComponent\n// 元素实例的类型 => { render: () => void }\n\nfunction MyFactoryFunction() {\n  return {\n    render: () => {\n    }\n  }\n}\n\n// 使用调用签名\nvar myComponent = MyFactoryFunction();\n\n// 元素类的类型 => MyFactoryFunction\n// 元素实例的类型 => { render: () => void }\n```\n\n元素的实例类型很有趣，因为它必须赋值给`JSX.ElementClass`或抛出一个错误。 默认的`JSX.ElementClass`为`{}`，但是它可以被扩展用来限制JSX的类型以符合相应的接口。\n\n```typescript\ndeclare namespace JSX {\n  interface ElementClass {\n    render: any;\n  }\n}\n\nclass MyComponent {\n  render() {}\n}\nfunction MyFactoryFunction() {\n  return { render: () => {} }\n}\n\n<MyComponent />; // 正确\n<MyFactoryFunction />; // 正确\n\nclass NotAValidComponent {}\nfunction NotAValidFactoryFunction() {\n  return {};\n}\n\n<NotAValidComponent />; // 错误\n<NotAValidFactoryFunction />; // 错误\n```\n\n### 属性类型检查\n\n属性类型检查的第一步是确定_元素属性类型_。 这在固有元素和基于值的元素之间稍有不同。\n\n对于固有元素，这是`JSX.IntrinsicElements`属性的类型。\n\n```typescript\ndeclare namespace JSX {\n  interface IntrinsicElements {\n    foo: { bar?: boolean }\n  }\n}\n\n// `foo`的元素属性类型为`{bar?: boolean}`\n<foo bar />;\n```\n\n对于基于值的元素，就稍微复杂些。 它取决于先前确定的在元素实例类型上的某个属性的类型。 至于该使用哪个属性来确定类型取决于`JSX.ElementAttributesProperty`。 它应该使用单一的属性来定义。 这个属性名之后会被使用。 TypeScript 2.8，如果未指定`JSX.ElementAttributesProperty`，那么将使用类元素构造函数或函数组件调用的第一个参数的类型。\n\n```typescript\ndeclare namespace JSX {\n  interface ElementAttributesProperty {\n    props; // 指定用来使用的属性名\n  }\n}\n\nclass MyComponent {\n  // 在元素实例类型上指定属性\n  props: {\n    foo?: string;\n  }\n}\n\n// `MyComponent`的元素属性类型为`{foo?: string}`\n<MyComponent foo="bar" />\n```\n\n元素属性类型用于的JSX里进行属性的类型检查。 支持可选属性和必须属性。\n\n```typescript\ndeclare namespace JSX {\n  interface IntrinsicElements {\n    foo: { requiredProp: string; optionalProp?: number }\n  }\n}\n\n<foo requiredProp="bar" />; // 正确\n<foo requiredProp="bar" optionalProp={0} />; // 正确\n<foo />; // 错误, 缺少 requiredProp\n<foo requiredProp={0} />; // 错误, requiredProp 应该是字符串\n<foo requiredProp="bar" unknownProp />; // 错误, unknownProp 不存在\n<foo requiredProp="bar" some-unknown-prop />; // 正确, `some-unknown-prop`不是个合法的标识符\n```\n\n> 注意：如果一个属性名不是个合法的JS标识符（像`data-*`属性），并且它没出现在元素属性类型里时不会当做一个错误。\n\n另外，JSX还会使用`JSX.IntrinsicAttributes`接口来指定额外的属性，这些额外的属性通常不会被组件的props或arguments使用 - 比如React里的`key`。还有，`JSX.IntrinsicClassAttributes<T>`泛型类型也可以用来为类组件（非函数组件）指定相同种类的额外属性。这里的泛型参数表示类实例类型。在React里，它用来允许`Ref<T>`类型上的`ref`属性。通常来讲，这些接口上的所有属性都是可选的，除非你想要用户在每个JSX标签上都提供一些属性。\n\n延展操作符也可以使用：\n\n```jsx\nvar props = { requiredProp: \'bar\' };\n<foo {...props} />; // 正确\n\nvar badProps = {};\n<foo {...badProps} />; // 错误\n```\n\n### 子孙类型检查\n\n从TypeScript 2.3开始，我们引入了_children_类型检查。_children_是_元素属性\\(attribute\\)类型_的一个特殊属性\\(property\\)，子_JSXExpression_将会被插入到属性里。 与使用`JSX.ElementAttributesProperty`来决定_props_名类似，我们可以利用`JSX.ElementChildrenAttribute`来决定_children_名。 `JSX.ElementChildrenAttribute`应该被声明在单一的属性\\(property\\)里。\n\n```typescript\ndeclare namespace JSX {\n  interface ElementChildrenAttribute {\n    children: {};  // specify children name to use\n  }\n}\n```\n\n如不特殊指定子孙的类型，我们将使用[React typings](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react)里的默认类型。\n\n```typescript\n<div>\n  <h1>Hello</h1>\n</div>;\n\n<div>\n  <h1>Hello</h1>\n  World\n</div>;\n\nconst CustomComp = (props) => <div>{props.children}</div>\n<CustomComp>\n  <div>Hello World</div>\n  {"This is just a JS expression..." + 1000}\n</CustomComp>\n```\n\n```typescript\ninterface PropsType {\n  children: JSX.Element\n  name: string\n}\n\nclass Component extends React.Component<PropsType, {}> {\n  render() {\n    return (\n      <h2>\n        {this.props.children}\n      </h2>\n    )\n  }\n}\n\n// OK\n<Component name="foo">\n  <h1>Hello World</h1>\n</Component>\n\n// Error: children is of type JSX.Element not array of JSX.Element\n<Component name="bar">\n  <h1>Hello World</h1>\n  <h2>Hello World</h2>\n</Component>\n\n// Error: children is of type JSX.Element not array of JSX.Element or string.\n<Component name="baz">\n  <h1>Hello</h1>\n  World\n</Component>\n```\n\n## JSX结果类型\n\n默认地JSX表达式结果的类型为`any`。 你可以自定义这个类型，通过指定`JSX.Element`接口。 然而，不能够从接口里检索元素，属性或JSX的子元素的类型信息。 它是一个黑盒。\n\n## 嵌入的表达式\n\nJSX允许你使用`{ }`标签来内嵌表达式。\n\n```jsx\nvar a = <div>\n  {[\'foo\', \'bar\'].map(i => <span>{i / 2}</span>)}\n</div>\n```\n\n上面的代码产生一个错误，因为你不能用数字来除以一个字符串。 输出如下，若你使用了`preserve`选项：\n\n```jsx\nvar a = <div>\n  {[\'foo\', \'bar\'].map(function (i) { return <span>{i / 2}</span>; })}\n</div>\n```\n\n## React整合\n\n要想一起使用JSX和React，你应该使用[React类型定义](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react)。 这些类型声明定义了`JSX`合适命名空间来使用React。\n\n```typescript\n/// <reference path="react.d.ts" />\n\ninterface Props {\n  foo: string;\n}\n\nclass MyComponent extends React.Component<Props, {}> {\n  render() {\n    return <span>{this.props.foo}</span>\n  }\n}\n\n<MyComponent foo="bar" />; // 正确\n<MyComponent foo={0} />; // 错误\n```\n\n## 工厂函数\n\n`jsx: react`编译选项使用的工厂函数是可以配置的。可以使用`jsxFactory`命令行选项，或内联的`@jsx`注释指令在每个文件上设置。比如，给`createElement`设置`jsxFactory`，`<div />`会使用`createElement("div")`来生成，而不是`React.createElement("div")`。\n\n注释指令可以像下面这样使用（在TypeScript 2.8里）：\n\n```typescript\nimport preact = require("preact");\n/* @jsx preact.h */\nconst x = <div />;\n```\n\n生成：\n\n```typescript\nconst preact = require("preact");\nconst x = preact.h("div", null);\n```\n\n工厂函数的选择同样会影响`JSX`命名空间的查找（类型检查）。如果工厂函数使用`React.createElement`定义（默认），编译器会先检查`React.JSX`，之后才检查全局的`JSX`。如果工厂函数定义为`h`，那么在检查全局的`JSX`之前先检查`h.JSX`。\n\n',Wl='# 混入\n\n## Table of contents\n\n[介绍](mixins.md#introduction)\n\n[混入示例](mixins.md#mixin-sample)\n\n[理解示例](mixins.md#understanding-the-sample)\n\n## 介绍\n\n[**↥ 回到顶端**](mixins.md#table-of-contents)\n\n除了传统的面向对象继承方式，还流行一种通过可重用组件创建类的方式，就是联合另一个简单类的代码。 你可能在Scala等语言里对mixins及其特性已经很熟悉了，但它在JavaScript中也是很流行的。\n\n## 混入示例\n\n[**↥ 回到顶端**](mixins.md#table-of-contents)\n\n下面的代码演示了如何在TypeScript里使用混入。 后面我们还会解释这段代码是怎么工作的。\n\n```typescript\n// Disposable Mixin\nclass Disposable {\n    isDisposed: boolean;\n    dispose() {\n        this.isDisposed = true;\n    }\n\n}\n\n// Activatable Mixin\nclass Activatable {\n    isActive: boolean;\n    activate() {\n        this.isActive = true;\n    }\n    deactivate() {\n        this.isActive = false;\n    }\n}\n\nclass SmartObject {\n    constructor() {\n        setInterval(() => console.log(this.isActive + " : " + this.isDisposed), 500);\n    }\n\n    interact() {\n        this.activate();\n    }\n}\n\ninterface SmartObject extends Disposable, Activatable {}\napplyMixins(SmartObject, [Disposable, Activatable]);\n\nlet smartObj = new SmartObject();\nsetTimeout(() => smartObj.interact(), 1000);\n\n////////////////////////////////////////\n// In your runtime library somewhere\n////////////////////////////////////////\n\nfunction applyMixins(derivedCtor: any, baseCtors: any[]) {\n    baseCtors.forEach(baseCtor => {\n        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n            Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));\n        });\n    });\n}\n```\n\n## 理解示例\n\n[**↥ 回到顶端**](mixins.md#table-of-contents)\n\n代码里首先定义了两个类，它们将做为mixins。 可以看到每个类都只定义了一个特定的行为或功能。 稍后我们使用它们来创建一个新类，同时具有这两种功能。\n\n```typescript\n// Disposable Mixin\nclass Disposable {\n    isDisposed: boolean;\n    dispose() {\n        this.isDisposed = true;\n    }\n\n}\n\n// Activatable Mixin\nclass Activatable {\n    isActive: boolean;\n    activate() {\n        this.isActive = true;\n    }\n    deactivate() {\n        this.isActive = false;\n    }\n}\n```\n\n下面创建一个类，结合了这两个mixins。 下面来看一下具体是怎么操作的：\n\n```typescript\nclass SmartObject {\n    ...\n}\n\ninterface SmartObject extends Disposable, Activatable {}\n```\n\n首先注意到的是，我们没有在`SmartObject`类里面继承`Disposable`和`Activatable`，而是在`SmartObject`接口里面继承的。由于[声明合并](declaration-merging.md)的存在，`SmartObject`接口会被混入到`SmartObject`类里面。\n\n它将类视为接口，且只会混入Disposable和Activatable背后的类型到SmartObject类型里，不会混入实现。也就是说，我们要在类里面去实现。 这正是我们想要在混入时避免的行为。\n\n最后，我们将混入融入到了类的实现中去。\n\n```typescript\n// Disposable\nisDisposed: boolean = false;\ndispose: () => void;\n// Activatable\nisActive: boolean = false;\nactivate: () => void;\ndeactivate: () => void;\n```\n\n最后，把mixins混入定义的类，完成全部实现部分。\n\n```typescript\napplyMixins(SmartObject, [Disposable, Activatable]);\n```\n\n最后，创建这个帮助函数，帮我们做混入操作。 它会遍历mixins上的所有属性，并复制到目标上去，把之前的占位属性替换成真正的实现代码。\n\n```typescript\nfunction applyMixins(derivedCtor: any, baseCtors: any[]) {\n    baseCtors.forEach(baseCtor => {\n        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n            Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));\n        })\n    });\n}\n```\n\n',Vl='# 模块解析\n\n> 这节假设你已经了解了模块的一些基本知识 请阅读[模块](modules.md)文档了解更多信息。\n\n_模块解析_是指编译器在查找导入模块内容时所遵循的流程。 假设有一个导入语句`import { a } from "moduleA"`; 为了去检查任何对`a`的使用，编译器需要准确的知道它表示什么，并且需要检查它的定义`moduleA`。\n\n这时候，编译器会有个疑问“`moduleA`的结构是怎样的？” 这听上去很简单，但`moduleA`可能在你写的某个`.ts`/`.tsx`文件里或者在你的代码所依赖的`.d.ts`里。\n\n首先，编译器会尝试定位表示导入模块的文件。 编译器会遵循以下二种策略之一：[Classic](module-resolution.md#classic)或[Node](module-resolution.md#node)。 这些策略会告诉编译器到_哪里_去查找`moduleA`。\n\n如果上面的解析失败了并且模块名是非相对的（且是在`"moduleA"`的情况下），编译器会尝试定位一个[外部模块声明](modules.md#ambient-modules)。 我们接下来会讲到非相对导入。\n\n最后，如果编译器还是不能解析这个模块，它会记录一个错误。 在这种情况下，错误可能为`error TS2307: Cannot find module \'moduleA\'.`\n\n## 相对 vs. 非相对模块导入\n\n根据模块引用是相对的还是非相对的，模块导入会以不同的方式解析。\n\n_相对导入_是以`/`，`./`或`../`开头的。 下面是一些例子：\n\n* `import Entry from "./components/Entry";`\n* `import { DefaultHeaders } from "../constants/http";`\n* `import "/mod";`\n\n所有其它形式的导入被当作_非相对_的。 下面是一些例子：\n\n* `import * as $ from "jQuery";`\n* `import { Component } from "@angular/core";`\n\n相对导入在解析时是相对于导入它的文件，并且_不能_解析为一个外部模块声明。 你应该为你自己写的模块使用相对导入，这样能确保它们在运行时的相对位置。\n\n非相对模块的导入可以相对于`baseUrl`或通过下文会讲到的路径映射来进行解析。 它们还可以被解析成[外部模块声明](modules.md#ambient-modules)。 使用非相对路径来导入你的外部依赖。\n\n## 模块解析策略\n\n共有两种可用的模块解析策略：[Node](module-resolution.md#node)和[Classic](module-resolution.md#classic)。 你可以使用`--moduleResolution`标记来指定使用哪种模块解析策略。 若未指定，那么在使用了`--module AMD | System | ES2015`时的默认值为[Classic](module-resolution.md#classic)，其它情况时则为[Node](module-resolution.md#node)。\n\n### Classic\n\n这种策略在以前是TypeScript默认的解析策略。 现在，它存在的理由主要是为了向后兼容。\n\n相对导入的模块是相对于导入它的文件进行解析的。 因此`/root/src/folder/A.ts`文件里的`import { b } from "./moduleB"`会使用下面的查找流程：\n\n1. `/root/src/folder/moduleB.ts`\n2. `/root/src/folder/moduleB.d.ts`\n\n对于非相对模块的导入，编译器则会从包含导入文件的目录开始依次向上级目录遍历，尝试定位匹配的声明文件。\n\n比如：\n\n有一个对`moduleB`的非相对导入`import { b } from "moduleB"`，它是在`/root/src/folder/A.ts`文件里，会以如下的方式来定位`"moduleB"`：\n\n1. `/root/src/folder/moduleB.ts`\n2. `/root/src/folder/moduleB.d.ts`\n3. `/root/src/moduleB.ts`\n4. `/root/src/moduleB.d.ts`\n5. `/root/moduleB.ts`\n6. `/root/moduleB.d.ts`\n7. `/moduleB.ts`\n8. `/moduleB.d.ts`\n\n### Node\n\n这个解析策略试图在运行时模仿[Node.js](https://nodejs.org/)模块解析机制。 完整的Node.js解析算法可以在[Node.js module documentation](https://nodejs.org/api/modules.html#modules_all_together)找到。\n\n#### Node.js如何解析模块\n\n为了理解TypeScript编译依照的解析步骤，先弄明白Node.js模块是非常重要的。 通常，在Node.js里导入是通过`require`函数调用进行的。 Node.js会根据`require`的是相对路径还是非相对路径做出不同的行为。\n\n相对路径很简单。 例如，假设有一个文件路径为`/root/src/moduleA.js`，包含了一个导入`var x = require("./moduleB");` Node.js以下面的顺序解析这个导入：\n\n1. 检查`/root/src/moduleB.js`文件是否存在。\n2. 检查`/root/src/moduleB`目录是否包含一个`package.json`文件，且`package.json`文件指定了一个`"main"`模块。 在我们的例子里，如果Node.js发现文件`/root/src/moduleB/package.json`包含了`{ "main": "lib/mainModule.js" }`，那么Node.js会引用`/root/src/moduleB/lib/mainModule.js`。\n3. 检查`/root/src/moduleB`目录是否包含一个`index.js`文件。 这个文件会被隐式地当作那个文件夹下的"main"模块。\n\n你可以阅读Node.js文档了解更多详细信息：[file modules](https://nodejs.org/api/modules.html#modules_file_modules) 和 [folder modules](https://nodejs.org/api/modules.html#modules_folders_as_modules)。\n\n但是，[非相对模块名](module-resolution.md#relative-vs-non-relative-module-imports)的解析是个完全不同的过程。 Node会在一个特殊的文件夹`node_modules`里查找你的模块。 `node_modules`可能与当前文件在同一级目录下，或者在上层目录里。 Node会向上级目录遍历，查找每个`node_modules`直到它找到要加载的模块。\n\n还是用上面例子，但假设`/root/src/moduleA.js`里使用的是非相对路径导入`var x = require("moduleB");`。 Node则会以下面的顺序去解析`moduleB`，直到有一个匹配上。\n\n1. `/root/src/node_modules/moduleB.js`\n2. `/root/src/node_modules/moduleB/package.json` \\(如果指定了`"main"`属性\\)\n3. `/root/src/node_modules/moduleB/index.js`\n4. `/root/node_modules/moduleB.js`\n5. `/root/node_modules/moduleB/package.json` \\(如果指定了`"main"`属性\\)\n6. `/root/node_modules/moduleB/index.js`\n7. `/node_modules/moduleB.js`\n8. `/node_modules/moduleB/package.json` \\(如果指定了`"main"`属性\\)\n9. `/node_modules/moduleB/index.js`\n\n注意Node.js在步骤（4）和（7）会向上跳一级目录。\n\n你可以阅读Node.js文档了解更多详细信息：[loading modules from `node_modules`](https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders)。\n\n#### TypeScript如何解析模块\n\nTypeScript是模仿Node.js运行时的解析策略来在编译阶段定位模块定义文件。 因此，TypeScript在Node解析逻辑基础上增加了TypeScript源文件的扩展名（`.ts`，`.tsx`和`.d.ts`）。 同时，TypeScript在`package.json`里使用字段`"types"`来表示类似`"main"`的意义 - 编译器会使用它来找到要使用的"main"定义文件。\n\n比如，有一个导入语句`import { b } from "./moduleB"`在`/root/src/moduleA.ts`里，会以下面的流程来定位`"./moduleB"`：\n\n1. `/root/src/moduleB.ts`\n2. `/root/src/moduleB.tsx`\n3. `/root/src/moduleB.d.ts`\n4. `/root/src/moduleB/package.json` \\(如果指定了`"types"`属性\\)\n5. `/root/src/moduleB/index.ts`\n6. `/root/src/moduleB/index.tsx`\n7. `/root/src/moduleB/index.d.ts`\n\n回想一下Node.js先查找`moduleB.js`文件，然后是合适的`package.json`，再之后是`index.js`。\n\n类似地，非相对的导入会遵循Node.js的解析逻辑，首先查找文件，然后是合适的文件夹。 因此`/root/src/moduleA.ts`文件里的`import { b } from "moduleB"`会以下面的查找顺序解析：\n\n1. `/root/src/node_modules/moduleB.ts`\n2. `/root/src/node_modules/moduleB.tsx`\n3. `/root/src/node_modules/moduleB.d.ts`\n4. `/root/src/node_modules/moduleB/package.json` \\(如果指定了`"types"`属性\\)\n5. `/root/src/node_modules/@types/moduleB.d.ts`\n6. `/root/src/node_modules/moduleB/index.ts`\n7. `/root/src/node_modules/moduleB/index.tsx`\n8. `/root/src/node_modules/moduleB/index.d.ts`\n9. `/root/node_modules/moduleB.ts`\n10. `/root/node_modules/moduleB.tsx`\n11. `/root/node_modules/moduleB.d.ts`\n12. `/root/node_modules/moduleB/package.json` \\(如果指定了`"types"`属性\\)\n13. `/root/node_modules/@types/moduleB.d.ts`\n14. `/root/node_modules/moduleB/index.ts`\n15. `/root/node_modules/moduleB/index.tsx`\n16. `/root/node_modules/moduleB/index.d.ts`\n17. `/node_modules/moduleB.ts`\n18. `/node_modules/moduleB.tsx`\n19. `/node_modules/moduleB.d.ts`\n20. `/node_modules/moduleB/package.json` \\(如果指定了`"types"`属性\\)\n21. `/node_modules/@types/moduleB.d.ts`\n22. `/node_modules/moduleB/index.ts`\n23. `/node_modules/moduleB/index.tsx`\n24. `/node_modules/moduleB/index.d.ts`\n\n不要被这里步骤的数量吓到 - TypeScript只是在步骤（9）和（17）向上跳了两次目录。 这并不比Node.js里的流程复杂。\n\n## 附加的模块解析标记\n\n有时工程源码结构与输出结构不同。 通常是要经过一系统的构建步骤最后生成输出。 它们包括将`.ts`编译成`.js`，将不同位置的依赖拷贝至一个输出位置。 最终结果就是运行时的模块名与包含它们声明的源文件里的模块名不同。 或者最终输出文件里的模块路径与编译时的源文件路径不同了。\n\nTypeScript编译器有一些额外的标记用来_通知_编译器在源码编译成最终输出的过程中都发生了哪个转换。\n\n有一点要特别注意的是编译器_不会_进行这些转换操作； 它只是利用这些信息来指导模块的导入。\n\n### Base URL\n\n在利用AMD模块加载器的应用里使用`baseUrl`是常见做法，它要求在运行时模块都被放到了一个文件夹里。 这些模块的源码可以在不同的目录下，但是构建脚本会将它们集中到一起。\n\n设置`baseUrl`来告诉编译器到哪里去查找模块。 所有非相对模块导入都会被当做相对于`baseUrl`。\n\n_baseUrl_的值由以下两者之一决定：\n\n* 命令行中_baseUrl_的值（如果给定的路径是相对的，那么将相对于当前路径进行计算）\n* ‘tsconfig.json’里的_baseUrl_属性（如果给定的路径是相对的，那么将相对于‘tsconfig.json’路径进行计算）\n\n注意相对模块的导入不会被设置的`baseUrl`所影响，因为它们总是相对于导入它们的文件。\n\n阅读更多关于`baseUrl`的信息[RequireJS](http://requirejs.org/docs/api.html#config-baseUrl)和[SystemJS](https://github.com/systemjs/systemjs/blob/master/docs/config-api.md#baseurl)。\n\n### 路径映射\n\n有时模块不是直接放在_baseUrl_下面。 比如，充分`"jquery"`模块地导入，在运行时可能被解释为`"node_modules/jquery/dist/jquery.slim.min.js"`。 加载器使用映射配置来将模块名映射到运行时的文件，查看[RequireJs documentation](http://requirejs.org/docs/api.html#config-paths)和[SystemJS documentation](https://github.com/systemjs/systemjs/blob/master/docs/config-api.md#paths)。\n\nTypeScript编译器通过使用`tsconfig.json`文件里的`"paths"`来支持这样的声明映射。 下面是一个如何指定`jquery`的`"paths"`的例子。\n\n```javascript\n{\n  "compilerOptions": {\n    "baseUrl": ".", // This must be specified if "paths" is.\n    "paths": {\n      "jquery": ["node_modules/jquery/dist/jquery"] // 此处映射是相对于"baseUrl"\n    }\n  }\n}\n```\n\n请注意`"paths"`是相对于`"baseUrl"`进行解析。 如果`"baseUrl"`被设置成了除`"."`外的其它值，比如`tsconfig.json`所在的目录，那么映射必须要做相应的改变。 如果你在上例中设置了`"baseUrl": "./src"`，那么jquery应该映射到`"../node_modules/jquery/dist/jquery"`。\n\n通过`"paths"`我们还可以指定复杂的映射，包括指定多个回退位置。 假设在一个工程配置里，有一些模块位于一处，而其它的则在另个的位置。 构建过程会将它们集中至一处。 工程结构可能如下：\n\n```text\nprojectRoot\n├── folder1\n│   ├── file1.ts (imports \'folder1/file2\' and \'folder2/file3\')\n│   └── file2.ts\n├── generated\n│   ├── folder1\n│   └── folder2\n│       └── file3.ts\n└── tsconfig.json\n```\n\n相应的`tsconfig.json`文件如下：\n\n```javascript\n{\n  "compilerOptions": {\n    "baseUrl": ".",\n    "paths": {\n      "*": [\n        "*",\n        "generated/*"\n      ]\n    }\n  }\n}\n```\n\n它告诉编译器所有匹配`"*"`（所有的值）模式的模块导入会在以下两个位置查找：\n\n1. `"*"`： 表示名字不发生改变，所以映射为`<moduleName>` =&gt; `<baseUrl>/<moduleName>`\n2. `"generated/*"`表示模块名添加了“generated”前缀，所以映射为`<moduleName>` =&gt; `<baseUrl>/generated/<moduleName>`\n\n按照这个逻辑，编译器将会如下尝试解析这两个导入：\n\n* 导入\'folder1/file2\'\n  1. 匹配\'\\*\'模式且通配符捕获到整个名字。\n  2. 尝试列表里的第一个替换：\'\\*\' -&gt; `folder1/file2`。\n  3. 替换结果为非相对名 - 与_baseUrl_合并 -&gt; `projectRoot/folder1/file2.ts`。\n  4. 文件存在。完成。\n* 导入\'folder2/file3\'\n  1. 匹配\'\\*\'模式且通配符捕获到整个名字。\n  2. 尝试列表里的第一个替换：\'\\*\' -&gt; `folder2/file3`。\n  3. 替换结果为非相对名 - 与_baseUrl_合并 -&gt; `projectRoot/folder2/file3.ts`。\n  4. 文件不存在，跳到第二个替换。\n  5. 第二个替换：\'generated/\\*\' -&gt; `generated/folder2/file3`。\n  6. 替换结果为非相对名 - 与_baseUrl_合并 -&gt; `projectRoot/generated/folder2/file3.ts`。\n  7. 文件存在。完成。\n\n### 利用`rootDirs`指定虚拟目录\n\n有时多个目录下的工程源文件在编译时会进行合并放在某个输出目录下。 这可以看做一些源目录创建了一个“虚拟”目录。\n\n利用`rootDirs`，可以告诉编译器生成这个虚拟目录的_roots_； 因此编译器可以在“虚拟”目录下解析相对模块导入，就_好像_它们被合并在了一起一样。\n\n比如，有下面的工程结构：\n\n```text\n src\n └── views\n     └── view1.ts (imports \'./template1\')\n     └── view2.ts\n\n generated\n └── templates\n         └── views\n             └── template1.ts (imports \'./view2\')\n```\n\n`src/views`里的文件是用于控制UI的用户代码。 `generated/templates`是UI模版，在构建时通过模版生成器自动生成。 构建中的一步会将`/src/views`和`/generated/templates/views`的输出拷贝到同一个目录下。 在运行时，视图可以假设它的模版与它同在一个目录下，因此可以使用相对导入`"./template"`。\n\n可以使用`"rootDirs"`来告诉编译器。 `"rootDirs"`指定了一个_roots_列表，列表里的内容会在运行时被合并。 因此，针对这个例子，`tsconfig.json`如下：\n\n```javascript\n{\n  "compilerOptions": {\n    "rootDirs": [\n      "src/views",\n      "generated/templates/views"\n    ]\n  }\n}\n```\n\n每当编译器在某一`rootDirs`的子目录下发现了相对模块导入，它就会尝试从每一个`rootDirs`中导入。\n\n`rootDirs`的灵活性不仅仅局限于其指定了要在逻辑上合并的物理目录列表。它提供的数组可以包含任意数量的任何名字的目录，不论它们是否存在。这允许编译器以类型安全的方式处理复杂捆绑\\(bundles\\)和运行时的特性，比如条件引入和工程特定的加载器插件。\n\n设想这样一个国际化的场景，构建工具自动插入特定的路径记号来生成针对不同区域的捆绑，比如将`#{locale}`做为相对模块路径`./#{locale}/messages`的一部分。在这个假定的设置下，工具会枚举支持的区域，将抽像的路径映射成`./zh/messages`，`./de/messages`等。\n\n假设每个模块都会导出一个字符串的数组。比如`./zh/messages`可能包含：\n\n```typescript\nexport default [\n    "您好吗",\n    "很高兴认识你"\n];\n```\n\n利用`rootDirs`我们可以让编译器了解这个映射关系，从而也允许编译器能够安全地解析`./#{locale}/messages`，就算这个目录永远都不存在。比如，使用下面的`tsconfig.json`：\n\n```javascript\n{\n  "compilerOptions": {\n    "rootDirs": [\n      "src/zh",\n      "src/de",\n      "src/#{locale}"\n    ]\n  }\n}\n```\n\n编译器现在可以将`import messages from \'./#{locale}/messages\'`解析为`import messages from \'./zh/messages\'`用做工具支持的目的，并允许在开发时不必了解区域信息。\n\n## 跟踪模块解析\n\n如之前讨论，编译器在解析模块时可能访问当前文件夹外的文件。 这会导致很难诊断模块为什么没有被解析，或解析到了错误的位置。 通过`--traceResolution`启用编译器的模块解析跟踪，它会告诉我们在模块解析过程中发生了什么。\n\n假设我们有一个使用了`typescript`模块的简单应用。 `app.ts`里有一个这样的导入`import * as ts from "typescript"`。\n\n```text\n│   tsconfig.json\n├───node_modules\n│   └───typescript\n│       └───lib\n│               typescript.d.ts\n└───src\n        app.ts\n```\n\n使用`--traceResolution`调用编译器。\n\n```text\ntsc --traceResolution\n```\n\n输出结果如下：\n\n```text\n======== Resolving module \'typescript\' from \'src/app.ts\'. ========\nModule resolution kind is not specified, using \'NodeJs\'.\nLoading module \'typescript\' from \'node_modules\' folder.\nFile \'src/node_modules/typescript.ts\' does not exist.\nFile \'src/node_modules/typescript.tsx\' does not exist.\nFile \'src/node_modules/typescript.d.ts\' does not exist.\nFile \'src/node_modules/typescript/package.json\' does not exist.\nFile \'node_modules/typescript.ts\' does not exist.\nFile \'node_modules/typescript.tsx\' does not exist.\nFile \'node_modules/typescript.d.ts\' does not exist.\nFound \'package.json\' at \'node_modules/typescript/package.json\'.\n\'package.json\' has \'types\' field \'./lib/typescript.d.ts\' that references \'node_modules/typescript/lib/typescript.d.ts\'.\nFile \'node_modules/typescript/lib/typescript.d.ts\' exist - use it as a module resolution result.\n======== Module name \'typescript\' was successfully resolved to \'node_modules/typescript/lib/typescript.d.ts\'. ========\n```\n\n#### 需要留意的地方\n\n* 导入的名字及位置\n\n  > ======== Resolving module **\'typescript\'** from **\'src/app.ts\'**. ========\n\n* 编译器使用的策略\n\n  > Module resolution kind is not specified, using **\'NodeJs\'**.\n\n* 从npm加载types\n\n  > \'package.json\' has **\'types\'** field \'./lib/typescript.d.ts\' that references \'node\\_modules/typescript/lib/typescript.d.ts\'.\n\n* 最终结果\n\n  > ======== Module name \'typescript\' was **successfully resolved** to \'node\\_modules/typescript/lib/typescript.d.ts\'. ========\n\n## 使用`--noResolve`\n\n正常来讲编译器会在开始编译之前解析模块导入。 每当它成功地解析了对一个文件`import`，这个文件被会加到一个文件列表里，以供编译器稍后处理。\n\n`--noResolve`编译选项告诉编译器不要添加任何不是在命令行上传入的文件到编译列表。 编译器仍然会尝试解析模块，但是只要没有指定这个文件，那么它就不会被包含在内。\n\n比如\n\n#### app.ts\n\n```typescript\nimport * as A from "moduleA" // OK, moduleA passed on the command-line\nimport * as B from "moduleB" // Error TS2307: Cannot find module \'moduleB\'.\n```\n\n```text\ntsc app.ts moduleA.ts --noResolve\n```\n\n使用`--noResolve`编译`app.ts`：\n\n* 可能正确找到`moduleA`，因为它在命令行上指定了。\n* 找不到`moduleB`，因为没有在命令行上传递。\n\n## 常见问题\n\n### 为什么在`exclude`列表里的模块还会被编译器使用\n\n`tsconfig.json`将文件夹转变一个“工程” 如果不指定任何`“exclude”`或`“files”`，文件夹里的所有文件包括`tsconfig.json`和所有的子目录都会在编译列表里。 如果你想利用`“exclude”`排除某些文件，甚至你想指定所有要编译的文件列表，请使用`“files”`。\n\n有些是被`tsconfig.json`自动加入的。 它不会涉及到上面讨论的模块解析。 如果编译器识别出一个文件是模块导入目标，它就会加到编译列表里，不管它是否被排除了。\n\n因此，要从编译列表中排除一个文件，你需要在排除它的同时，还要排除所有对它进行`import`或使用了`/// <reference path="..." />`指令的文件。\n\n',Gl='# 模块\n\n> **关于术语的一点说明:** 请务必注意一点，TypeScript 1.5里术语名已经发生了变化。 “内部模块”现在称做“命名空间”。 “外部模块”现在则简称为“模块”，这是为了与[ECMAScript 2015](http://www.ecma-international.org/ecma-262/6.0/)里的术语保持一致，\\(也就是说 `module X {` 相当于现在推荐的写法 `namespace X {`\\)。\n\n## 介绍\n\n从ECMAScript 2015开始，JavaScript引入了模块的概念。TypeScript也沿用这个概念。\n\n模块在其自身的作用域里执行，而不是在全局作用域里；这意味着定义在一个模块里的变量，函数，类等等在模块外部是不可见的，除非你明确地使用[`export`形式](modules.md#export)之一导出它们。 相反，如果想使用其它模块导出的变量，函数，类，接口等的时候，你必须要导入它们，可以使用[`import`形式](modules.md#import)之一。\n\n模块是自声明的；两个模块之间的关系是通过在文件级别上使用imports和exports建立的。\n\n模块使用模块加载器去导入其它的模块。 在运行时，模块加载器的作用是在执行此模块代码前去查找并执行这个模块的所有依赖。 众所周知的JavaScript模块加载器有：作用于[CommonJS](https://en.wikipedia.org/wiki/CommonJS)模块的Node.js加载器和在Web应用里作用于[AMD](https://github.com/amdjs/amdjs-api/blob/master/AMD.md)模块的[RequireJS](http://requirejs.org/)加载器。\n\nTypeScript与ECMAScript 2015一样，任何包含顶级`import`或者`export`的文件都被当成一个模块。 相反地，如果一个文件不带有顶级的`import`或者`export`声明，那么它的内容被视为全局可见的（因此对模块也是可见的）。\n\n## 导出\n\n### 导出声明\n\n任何声明（比如变量，函数，类，类型别名或接口）都能够通过添加`export`关键字来导出。\n\n**StringValidator.ts**\n\n```typescript\nexport interface StringValidator {\n    isAcceptable(s: string): boolean;\n}\n```\n\n**ZipCodeValidator.ts**\n\n```typescript\nimport { StringValidator } from "./StringValidator";\n\nexport const numberRegexp = /^[0-9]+$/;\n\nexport class ZipCodeValidator implements StringValidator {\n    isAcceptable(s: string) {\n        return s.length === 5 && numberRegexp.test(s);\n    }\n}\n```\n\n### 导出语句\n\n导出语句很便利，因为我们可能需要对导出的部分重命名，所以上面的例子可以这样改写：\n\n```typescript\nclass ZipCodeValidator implements StringValidator {\n    isAcceptable(s: string) {\n        return s.length === 5 && numberRegexp.test(s);\n    }\n}\nexport { ZipCodeValidator };\nexport { ZipCodeValidator as mainValidator };\n```\n\n### 重新导出\n\n我们经常会去扩展其它模块，并且只导出那个模块的部分内容。 重新导出功能并不会在当前模块导入那个模块或定义一个新的局部变量。\n\n**ParseIntBasedZipCodeValidator.ts**\n\n```typescript\nexport class ParseIntBasedZipCodeValidator {\n    isAcceptable(s: string) {\n        return s.length === 5 && parseInt(s).toString() === s;\n    }\n}\n\n// 导出原先的验证器但做了重命名\nexport {ZipCodeValidator as RegExpBasedZipCodeValidator} from "./ZipCodeValidator";\n```\n\n或者一个模块可以包裹多个模块，并把他们导出的内容联合在一起通过语法：`export * from "module"`。\n\n**AllValidators.ts**\n\n```typescript\nexport * from "./StringValidator"; // exports \'StringValidator\' interface\nexport * from "./ZipCodeValidator";  // exports \'ZipCodeValidator\' and const \'numberRegexp\' class\nexport * from "./ParseIntBasedZipCodeValidator"; //  exports the \'ParseIntBasedZipCodeValidator\' class\n                                                 // and re-exports \'RegExpBasedZipCodeValidator\' as alias\n                                                 // of the \'ZipCodeValidator\' class from \'ZipCodeValidator.ts\'\n```\n\n## 导入\n\n模块的导入操作与导出一样简单。 可以使用以下`import`形式之一来导入其它模块中的导出内容。\n\n### 导入一个模块中的某个导出内容\n\n```typescript\nimport { ZipCodeValidator } from "./ZipCodeValidator";\n\nlet myValidator = new ZipCodeValidator();\n```\n\n可以对导入内容重命名\n\n```typescript\nimport { ZipCodeValidator as ZCV } from "./ZipCodeValidator";\nlet myValidator = new ZCV();\n```\n\n### 将整个模块导入到一个变量，并通过它来访问模块的导出部分\n\n```typescript\nimport * as validator from "./ZipCodeValidator";\nlet myValidator = new validator.ZipCodeValidator();\n```\n\n### 具有副作用的导入模块\n\n尽管不推荐这么做，一些模块会设置一些全局状态供其它模块使用。 这些模块可能没有任何的导出或用户根本就不关注它的导出。 使用下面的方法来导入这类模块：\n\n```typescript\nimport "./my-module.js";\n```\n\n## 默认导出\n\n每个模块都可以有一个`default`导出。 默认导出使用`default`关键字标记；并且一个模块只能够有一个`default`导出。 需要使用一种特殊的导入形式来导入`default`导出。\n\n`default`导出十分便利。 比如，像jQuery这样的类库可能有一个默认导出`jQuery`或`$`，并且我们基本上也会使用同样的名字`jQuery`或`$`导出jQuery。\n\n**jQuery.d.ts**\n\n```typescript\ndeclare let $: jQuery;\nexport default $;\n```\n\n**App.ts**\n\n```typescript\nimport $ from "jQuery";\n\n$("button.continue").html( "Next Step..." );\n```\n\n类和函数声明可以直接被标记为默认导出。 标记为默认导出的类和函数的名字是可以省略的。\n\n**ZipCodeValidator.ts**\n\n```typescript\nexport default class ZipCodeValidator {\n    static numberRegexp = /^[0-9]+$/;\n    isAcceptable(s: string) {\n        return s.length === 5 && ZipCodeValidator.numberRegexp.test(s);\n    }\n}\n```\n\n**Test.ts**\n\n```typescript\nimport validator from "./ZipCodeValidator";\n\nlet myValidator = new validator();\n```\n\n或者\n\n**StaticZipCodeValidator.ts**\n\n```typescript\nconst numberRegexp = /^[0-9]+$/;\n\nexport default function (s: string) {\n    return s.length === 5 && numberRegexp.test(s);\n}\n```\n\n**Test.ts**\n\n```typescript\nimport validate from "./StaticZipCodeValidator";\n\nlet strings = ["Hello", "98052", "101"];\n\n// Use function validate\nstrings.forEach(s => {\n  console.log(`"${s}" ${validate(s) ? "matches" : "does not match"}`);\n});\n```\n\n`default`导出也可以是一个值\n\n**OneTwoThree.ts**\n\n```typescript\nexport default "123";\n```\n\n**Log.ts**\n\n```typescript\nimport num from "./OneTwoThree";\n\nconsole.log(num); // "123"\n```\n\n## `export =` 和 `import = require()`\n\nCommonJS和AMD的环境里都有一个`exports`变量，这个变量包含了一个模块的所有导出内容。\n\nCommonJS和AMD的`exports`都可以被赋值为一个`对象`, 这种情况下其作用就类似于 es6 语法里的默认导出，即 `export default`语法了。虽然作用相似，但是 `export default` 语法并不能兼容CommonJS和AMD的`exports`。\n\n为了支持CommonJS和AMD的`exports`, TypeScript提供了`export =`语法。\n\n`export =`语法定义一个模块的导出`对象`。 这里的`对象`一词指的是类，接口，命名空间，函数或枚举。\n\n若使用`export =`导出一个模块，则必须使用TypeScript的特定语法`import module = require("module")`来导入此模块。\n\n**ZipCodeValidator.ts**\n\n```typescript\nlet numberRegexp = /^[0-9]+$/;\nclass ZipCodeValidator {\n    isAcceptable(s: string) {\n        return s.length === 5 && numberRegexp.test(s);\n    }\n}\nexport = ZipCodeValidator;\n```\n\n**Test.ts**\n\n```typescript\nimport zip = require("./ZipCodeValidator");\n\n// Some samples to try\nlet strings = ["Hello", "98052", "101"];\n\n// Validators to use\nlet validator = new zip();\n\n// Show whether each string passed each validator\nstrings.forEach(s => {\n  console.log(`"${ s }" - ${ validator.isAcceptable(s) ? "matches" : "does not match" }`);\n});\n```\n\n## 生成模块代码\n\n根据编译时指定的模块目标参数，编译器会生成相应的供Node.js \\([CommonJS](http://wiki.commonjs.org/wiki/CommonJS)\\)，Require.js \\([AMD](https://github.com/amdjs/amdjs-api/wiki/AMD)\\)，[UMD](https://github.com/umdjs/umd), [SystemJS](https://github.com/systemjs/systemjs)或[ECMAScript 2015 native modules](http://www.ecma-international.org/ecma-262/6.0/#sec-modules) \\(ES6\\)模块加载系统使用的代码。 想要了解生成代码中`define`，`require` 和 `register`的意义，请参考相应模块加载器的文档。\n\n下面的例子说明了导入导出语句里使用的名字是怎么转换为相应的模块加载器代码的。\n\n**SimpleModule.ts**\n\n```typescript\nimport m = require("mod");\nexport let t = m.something + 1;\n```\n\n**AMD / RequireJS SimpleModule.js**\n\n```javascript\ndefine(["require", "exports", "./mod"], function (require, exports, mod_1) {\n    exports.t = mod_1.something + 1;\n});\n```\n\n**CommonJS / Node SimpleModule.js**\n\n```javascript\nlet mod_1 = require("./mod");\nexports.t = mod_1.something + 1;\n```\n\n**UMD SimpleModule.js**\n\n```javascript\n(function (factory) {\n    if (typeof module === "object" && typeof module.exports === "object") {\n        let v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === "function" && define.amd) {\n        define(["require", "exports", "./mod"], factory);\n    }\n})(function (require, exports) {\n    let mod_1 = require("./mod");\n    exports.t = mod_1.something + 1;\n});\n```\n\n**System SimpleModule.js**\n\n```javascript\nSystem.register(["./mod"], function(exports_1) {\n    let mod_1;\n    let t;\n    return {\n        setters:[\n            function (mod_1_1) {\n                mod_1 = mod_1_1;\n            }],\n        execute: function() {\n            exports_1("t", t = mod_1.something + 1);\n        }\n    }\n});\n```\n\n**Native ECMAScript 2015 modules SimpleModule.js**\n\n```javascript\nimport { something } from "./mod";\nexport let t = something + 1;\n```\n\n## 简单示例\n\n下面我们来整理一下前面的验证器实现，每个模块只有一个命名的导出。\n\n为了编译，我们必需要在命令行上指定一个模块目标。对于Node.js来说，使用`--module commonjs`； 对于Require.js来说，使用`--module amd`。比如：\n\n```text\ntsc --module commonjs Test.ts\n```\n\n编译完成后，每个模块会生成一个单独的`.js`文件。 好比使用了reference标签，编译器会根据`import`语句编译相应的文件。\n\n**Validation.ts**\n\n```typescript\nexport interface StringValidator {\n    isAcceptable(s: string): boolean;\n}\n```\n\n**LettersOnlyValidator.ts**\n\n```typescript\nimport { StringValidator } from "./Validation";\n\nconst lettersRegexp = /^[A-Za-z]+$/;\n\nexport class LettersOnlyValidator implements StringValidator {\n    isAcceptable(s: string) {\n        return lettersRegexp.test(s);\n    }\n}\n```\n\n**ZipCodeValidator.ts**\n\n```typescript\nimport { StringValidator } from "./Validation";\n\nconst numberRegexp = /^[0-9]+$/;\n\nexport class ZipCodeValidator implements StringValidator {\n    isAcceptable(s: string) {\n        return s.length === 5 && numberRegexp.test(s);\n    }\n}\n```\n\n**Test.ts**\n\n```typescript\nimport { StringValidator } from "./Validation";\nimport { ZipCodeValidator } from "./ZipCodeValidator";\nimport { LettersOnlyValidator } from "./LettersOnlyValidator";\n\n// Some samples to try\nlet strings = ["Hello", "98052", "101"];\n\n// Validators to use\nlet validators: { [s: string]: StringValidator; } = {};\nvalidators["ZIP code"] = new ZipCodeValidator();\nvalidators["Letters only"] = new LettersOnlyValidator();\n\n// Show whether each string passed each validator\nstrings.forEach(s => {\n    for (let name in validators) {\n        console.log(`"${ s }" - ${ validators[name].isAcceptable(s) ? "matches" : "does not match" } ${ name }`);\n    }\n});\n```\n\n## 可选的模块加载和其它高级加载场景\n\n有时候，你只想在某种条件下才加载某个模块。 在TypeScript里，使用下面的方式来实现它和其它的高级加载场景，我们可以直接调用模块加载器并且可以保证类型完全。\n\n编译器会检测是否每个模块都会在生成的JavaScript中用到。 如果一个模块标识符只在类型注解部分使用，并且完全没有在表达式中使用时，就不会生成`require`这个模块的代码。 省略掉没有用到的引用对性能提升是很有益的，并同时提供了选择性加载模块的能力。\n\n这种模式的核心是`import id = require("...")`语句可以让我们访问模块导出的类型。 模块加载器会被动态调用（通过`require`），就像下面`if`代码块里那样。 它利用了省略引用的优化，所以模块只在被需要时加载。 为了让这个模块工作，一定要注意`import`定义的标识符只能在表示类型处使用（不能在会转换成JavaScript的地方）。\n\n为了确保类型安全性，我们可以使用`typeof`关键字。 `typeof`关键字，当在表示类型的地方使用时，会得出一个类型值，这里就表示模块的类型。\n\n**示例：Node.js里的动态模块加载**\n\n```typescript\ndeclare function require(moduleName: string): any;\n\nimport { ZipCodeValidator as Zip } from "./ZipCodeValidator";\n\nif (needZipValidation) {\n    let ZipCodeValidator: typeof Zip = require("./ZipCodeValidator");\n    let validator = new ZipCodeValidator();\n    if (validator.isAcceptable("...")) { /* ... */ }\n}\n```\n\n**示例：require.js里的动态模块加载**\n\n```typescript\ndeclare function require(moduleNames: string[], onLoad: (...args: any[]) => void): void;\n\nimport * as Zip from "./ZipCodeValidator";\n\nif (needZipValidation) {\n    require(["./ZipCodeValidator"], (ZipCodeValidator: typeof Zip) => {\n        let validator = new ZipCodeValidator.ZipCodeValidator();\n        if (validator.isAcceptable("...")) { /* ... */ }\n    });\n}\n```\n\n**示例：System.js里的动态模块加载**\n\n```typescript\ndeclare const System: any;\n\nimport { ZipCodeValidator as Zip } from "./ZipCodeValidator";\n\nif (needZipValidation) {\n    System.import("./ZipCodeValidator").then((ZipCodeValidator: typeof Zip) => {\n        var x = new ZipCodeValidator();\n        if (x.isAcceptable("...")) { /* ... */ }\n    });\n}\n```\n\n## 使用其它的JavaScript库\n\n要想描述非TypeScript编写的类库的类型，我们需要声明类库所暴露出的API。\n\n我们叫它声明因为它不是“外部程序”的具体实现。 它们通常是在`.d.ts`文件里定义的。 如果你熟悉C/C++，你可以把它们当做`.h`文件。 让我们看一些例子。\n\n### 外部模块\n\n在Node.js里大部分工作是通过加载一个或多个模块实现的。 我们可以使用顶级的`export`声明来为每个模块都定义一个`.d.ts`文件，但最好还是写在一个大的`.d.ts`文件里。 我们使用与构造一个外部命名空间相似的方法，但是这里使用`module`关键字并且把名字用引号括起来，方便之后`import`。 例如：\n\n**node.d.ts \\(simplified excerpt\\)**\n\n```typescript\ndeclare module "url" {\n    export interface Url {\n        protocol?: string;\n        hostname?: string;\n        pathname?: string;\n    }\n\n    export function parse(urlStr: string, parseQueryString?, slashesDenoteHost?): Url;\n}\n\ndeclare module "path" {\n    export function normalize(p: string): string;\n    export function join(...paths: any[]): string;\n    export let sep: string;\n}\n```\n\n现在我们可以`/// <reference>` `node.d.ts`并且使用`import url = require("url");`或`import * as URL from "url"`加载模块。\n\n```typescript\n/// <reference path="node.d.ts"/>\nimport * as URL from "url";\nlet myUrl = URL.parse("http://www.typescriptlang.org");\n```\n\n#### 外部模块简写\n\n假如你不想在使用一个新模块之前花时间去编写声明，你可以采用声明的简写形式以便能够快速使用它。\n\n**declarations.d.ts**\n\n```typescript\ndeclare module "hot-new-module";\n```\n\n简写模块里所有导出的类型将是`any`。\n\n```typescript\nimport x, {y} from "hot-new-module";\nx(y);\n```\n\n#### 模块声明通配符\n\n某些模块加载器如[SystemJS](https://github.com/systemjs/systemjs/blob/master/docs/overview.md#plugin-syntax) 和[AMD](https://github.com/amdjs/amdjs-api/blob/master/LoaderPlugins.md)支持导入非JavaScript内容。 它们通常会使用一个前缀或后缀来表示特殊的加载语法。 模块声明通配符可以用来表示这些情况。\n\n```typescript\ndeclare module "*!text" {\n    const content: string;\n    export default content;\n}\n// Some do it the other way around.\ndeclare module "json!*" {\n    const value: any;\n    export default value;\n}\n```\n\n现在你可以就导入匹配`"*!text"`或`"json!*"`的内容了。\n\n```typescript\nimport fileContent from "./xyz.txt!text";\nimport data from "json!http://example.com/data.json";\nconsole.log(data, fileContent);\n```\n\n#### UMD模块\n\n有些模块被设计成兼容多个模块加载器，或者不使用模块加载器（全局变量）。 它们以[UMD](https://github.com/umdjs/umd)模块为代表。 这些库可以通过导入的形式或全局变量的形式访问。 例如：\n\n**math-lib.d.ts**\n\n```typescript\nexport function isPrime(x: number): boolean;\nexport as namespace mathLib;\n```\n\n之后，这个库可以在某个模块里通过导入来使用：\n\n```typescript\nimport { isPrime } from "math-lib";\nisPrime(2);\nmathLib.isPrime(2); // ERROR: can\'t use the global definition from inside a module\n```\n\n它同样可以通过全局变量的形式使用，但只能在某个脚本里。 （脚本是指一个不带有导入或导出的文件。）\n\n```typescript\nmathLib.isPrime(2);\n```\n\n## 创建模块结构指导\n\n### 尽可能地在顶层导出\n\n用户应该更容易地使用你模块导出的内容。 嵌套层次过多会变得难以处理，因此仔细考虑一下如何组织你的代码。\n\n从你的模块中导出一个命名空间就是一个增加嵌套的例子。 虽然命名空间有时候有它们的用处，在使用模块的时候它们额外地增加了一层。 这对用户来说是很不便的并且通常是多余的。\n\n导出类的静态方法也有同样的问题 - 这个类本身就增加了一层嵌套。 除非它能方便表述或便于清晰使用，否则请考虑直接导出一个辅助方法。\n\n#### 如果仅导出单个 `class` 或 `function`，使用 `export default`\n\n就像“在顶层上导出”帮助减少用户使用的难度，一个默认的导出也能起到这个效果。 如果一个模块就是为了导出特定的内容，那么你应该考虑使用一个默认导出。 这会令模块的导入和使用变得些许简单。 比如：\n\n**MyClass.ts**\n\n```typescript\nexport default class SomeType {\n  constructor() { ... }\n}\n```\n\n**MyFunc.ts**\n\n```typescript\nexport default function getThing() { return \'thing\'; }\n```\n\n**Consumer.ts**\n\n```typescript\nimport t from "./MyClass";\nimport f from "./MyFunc";\nlet x = new t();\nconsole.log(f());\n```\n\n对用户来说这是最理想的。他们可以随意命名导入模块的类型（本例为`t`）并且不需要多余的（.）来找到相关对象。\n\n#### 如果要导出多个对象，把它们放在顶层里导出\n\n**MyThings.ts**\n\n```typescript\nexport class SomeType { /* ... */ }\nexport function someFunc() { /* ... */ }\n```\n\n相反地，当导入的时候：\n\n#### 明确地列出导入的名字\n\n**Consumer.ts**\n\n```typescript\nimport { SomeType, SomeFunc } from "./MyThings";\nlet x = new SomeType();\nlet y = someFunc();\n```\n\n#### 使用命名空间导入模式当你要导出大量内容的时候\n\n**MyLargeModule.ts**\n\n```typescript\nexport class Dog { ... }\nexport class Cat { ... }\nexport class Tree { ... }\nexport class Flower { ... }\n```\n\n**Consumer.ts**\n\n```typescript\nimport * as myLargeModule from "./MyLargeModule.ts";\nlet x = new myLargeModule.Dog();\n```\n\n### 使用重新导出进行扩展\n\n你可能经常需要去扩展一个模块的功能。 JS里常用的一个模式是jQuery那样去扩展原对象。 如我们之前提到的，模块不会像全局命名空间对象那样去_合并_。 推荐的方案是_不要_去改变原来的对象，而是导出一个新的实体来提供新的功能。\n\n假设`Calculator.ts`模块里定义了一个简单的计算器实现。 这个模块同样提供了一个辅助函数来测试计算器的功能，通过传入一系列输入的字符串并在最后给出结果。\n\n**Calculator.ts**\n\n```typescript\nexport class Calculator {\n    private current = 0;\n    private memory = 0;\n    private operator: string;\n\n    protected processDigit(digit: string, currentValue: number) {\n        if (digit >= "0" && digit <= "9") {\n            return currentValue * 10 + (digit.charCodeAt(0) - "0".charCodeAt(0));\n        }\n    }\n\n    protected processOperator(operator: string) {\n        if (["+", "-", "*", "/"].indexOf(operator) >= 0) {\n            return operator;\n        }\n    }\n\n    protected evaluateOperator(operator: string, left: number, right: number): number {\n        switch (this.operator) {\n            case "+": return left + right;\n            case "-": return left - right;\n            case "*": return left * right;\n            case "/": return left / right;\n        }\n    }\n\n    private evaluate() {\n        if (this.operator) {\n            this.memory = this.evaluateOperator(this.operator, this.memory, this.current);\n        }\n        else {\n            this.memory = this.current;\n        }\n        this.current = 0;\n    }\n\n    public handleChar(char: string) {\n        if (char === "=") {\n            this.evaluate();\n            return;\n        }\n        else {\n            let value = this.processDigit(char, this.current);\n            if (value !== undefined) {\n                this.current = value;\n                return;\n            }\n            else {\n                let value = this.processOperator(char);\n                if (value !== undefined) {\n                    this.evaluate();\n                    this.operator = value;\n                    return;\n                }\n            }\n        }\n        throw new Error(`Unsupported input: \'${char}\'`);\n    }\n\n    public getResult() {\n        return this.memory;\n    }\n}\n\nexport function test(c: Calculator, input: string) {\n    for (let i = 0; i < input.length; i++) {\n        c.handleChar(input[i]);\n    }\n\n    console.log(`result of \'${input}\' is \'${c.getResult()}\'`);\n}\n```\n\n下面使用导出的`test`函数来测试计算器。\n\n**TestCalculator.ts**\n\n```typescript\nimport { Calculator, test } from "./Calculator";\n\n\nlet c = new Calculator();\ntest(c, "1+2*33/11="); // prints 9\n```\n\n现在扩展它，添加支持输入其它进制（十进制以外），让我们来创建`ProgrammerCalculator.ts`。\n\n**ProgrammerCalculator.ts**\n\n```typescript\nimport { Calculator } from "./Calculator";\n\nclass ProgrammerCalculator extends Calculator {\n    static digits = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"];\n\n    constructor(public base: number) {\n        super();\n        const maxBase = ProgrammerCalculator.digits.length;\n        if (base <= 0 || base > maxBase) {\n            throw new Error(`base has to be within 0 to ${maxBase} inclusive.`);\n        }\n    }\n\n    protected processDigit(digit: string, currentValue: number) {\n        if (ProgrammerCalculator.digits.indexOf(digit) >= 0) {\n            return currentValue * this.base + ProgrammerCalculator.digits.indexOf(digit);\n        }\n    }\n}\n\n// Export the new extended calculator as Calculator\nexport { ProgrammerCalculator as Calculator };\n\n// Also, export the helper function\nexport { test } from "./Calculator";\n```\n\n新的`ProgrammerCalculator`模块导出的API与原先的`Calculator`模块很相似，但却没有改变原模块里的对象。 下面是测试ProgrammerCalculator类的代码：\n\n**TestProgrammerCalculator.ts**\n\n```typescript\nimport { Calculator, test } from "./ProgrammerCalculator";\n\nlet c = new Calculator(2);\ntest(c, "001+010="); // prints 3\n```\n\n### 模块里不要使用命名空间\n\n当初次进入基于模块的开发模式时，可能总会控制不住要将导出包裹在一个命名空间里。 模块具有其自己的作用域，并且只有导出的声明才会在模块外部可见。 记住这点，命名空间在使用模块时几乎没什么价值。\n\n在组织方面，命名空间对于在全局作用域内对逻辑上相关的对象和类型进行分组是很便利的。 例如，在C\\#里，你会从`System.Collections`里找到所有集合的类型。 通过将类型有层次地组织在命名空间里，可以方便用户找到与使用那些类型。 然而，模块本身已经存在于文件系统之中，这是必须的。 我们必须通过路径和文件名找到它们，这已经提供了一种逻辑上的组织形式。 我们可以创建`/collections/generic/`文件夹，把相应模块放在这里面。\n\n命名空间对解决全局作用域里命名冲突来说是很重要的。 比如，你可以有一个`My.Application.Customer.AddForm`和`My.Application.Order.AddForm` -- 两个类型的名字相同，但命名空间不同。 然而，这对于模块来说却不是一个问题。 在一个模块里，没有理由两个对象拥有同一个名字。 从模块的使用角度来说，使用者会挑出他们用来引用模块的名字，所以也没有理由发生重名的情况。\n\n> 更多关于模块和命名空间的资料查看[命名空间和模块](namespaces-and-modules.md)\n\n### 危险信号\n\n以下均为模块结构上的危险信号。重新检查以确保你没有在对模块使用命名空间：\n\n* 文件的顶层声明是`export namespace Foo { ... }` （删除`Foo`并把所有内容向上层移动一层）©\n* 多个文件的顶层具有同样的`export namespace Foo {` （不要以为这些会合并到一个`Foo`中！）\n\n',zl='# 命名空间和模块\n\n> **关于术语的一点说明:** 请务必注意一点，TypeScript 1.5里术语名已经发生了变化。 “内部模块”现在称做“命名空间”。 “外部模块”现在则简称为“模块”，这是为了与[ECMAScript 2015](http://www.ecma-international.org/ecma-262/6.0/)里的术语保持一致，\\(也就是说 `module X {` 相当于现在推荐的写法 `namespace X {`\\)。\n\n## 介绍\n\n这篇文章将概括介绍在TypeScript里使用模块与命名空间来组织代码的方法。 我们也会谈及命名空间和模块的高级使用场景，和在使用它们的过程中常见的陷阱。\n\n查看[模块](modules.md)章节了解关于模块的更多信息。 查看[命名空间](namespaces.md)章节了解关于命名空间的更多信息。\n\n## 使用命名空间\n\n命名空间是位于全局命名空间下的一个普通的带有名字的JavaScript对象。 这令命名空间十分容易使用。 它们可以在多文件中同时使用，并通过`--outFile`结合在一起。 命名空间是帮你组织Web应用不错的方式，你可以把所有依赖都放在HTML页面的`<script>`标签里。\n\n但就像其它的全局命名空间污染一样，它很难去识别组件之间的依赖关系，尤其是在大型的应用中。\n\n## 使用模块\n\n像命名空间一样，模块可以包含代码和声明。 不同的是模块可以_声明_它的依赖。\n\n模块会把依赖添加到模块加载器上（例如CommonJs / Require.js）。 对于小型的JS应用来说可能没必要，但是对于大型应用，这一点点的花费会带来长久的模块化和可维护性上的便利。 模块也提供了更好的代码重用，更强的封闭性以及更好的使用工具进行优化。\n\n对于Node.js应用来说，模块是默认并推荐的组织代码的方式。\n\n从ECMAScript 2015开始，模块成为了语言内置的部分，应该会被所有正常的解释引擎所支持。 因此，对于新项目来说推荐使用模块做为组织代码的方式。\n\n## 命名空间和模块的陷阱\n\n这部分我们会描述常见的命名空间和模块的使用陷阱和如何去避免它们。\n\n### 对模块使用`/// <reference>`\n\n一个常见的错误是使用`/// <reference>`引用模块文件，应该使用`import`。 要理解这之间的区别，我们首先应该弄清编译器是如何根据`import`路径（例如，`import x from "...";`或`import x = require("...")`里面的`...`，等等）来定位模块的类型信息的。\n\n编译器首先尝试去查找相应路径下的`.ts`，`.tsx`再或者`.d.ts`。 如果这些文件都找不到，编译器会查找_外部模块声明_。 回想一下，它们是在`.d.ts`文件里声明的。\n\n* `myModules.d.ts`\n\n```typescript\n// In a .d.ts file or .ts file that is not a module:\ndeclare module "SomeModule" {\n    export function fn(): string;\n}\n```\n\n* `myOtherModule.ts`\n\n```typescript\n/// <reference path="myModules.d.ts" />\nimport * as m from "SomeModule";\n```\n\n这里的引用标签指定了外来模块的位置。 这就是一些TypeScript例子中引用`node.d.ts`的方法。\n\n### 不必要的命名空间\n\n如果你想把命名空间转换为模块，它可能会像下面这个文件：\n\n* `shapes.ts`\n\n```typescript\nexport namespace Shapes {\n    export class Triangle { /* ... */ }\n    export class Square { /* ... */ }\n}\n```\n\n顶层的模块`Shapes`包裹了`Triangle`和`Square`。 对于使用它的人来说这是令人迷惑和讨厌的：\n\n* `shapeConsumer.ts`\n\n```typescript\nimport * as shapes from "./shapes";\nlet t = new shapes.Shapes.Triangle(); // shapes.Shapes?\n```\n\nTypeScript里模块的一个特点是不同的模块永远也不会在相同的作用域内使用相同的名字。 因为使用模块的人会为它们命名，所以完全没有必要把导出的符号包裹在一个命名空间里。\n\n再次重申，不应该对模块使用命名空间，使用命名空间是为了提供逻辑分组和避免命名冲突。 模块文件本身已经是一个逻辑分组，并且它的名字是由导入这个模块的代码指定，所以没有必要为导出的对象增加额外的模块层。\n\n下面是改进的例子：\n\n* `shapes.ts`\n\n```typescript\nexport class Triangle { /* ... */ }\nexport class Square { /* ... */ }\n```\n\n* `shapeConsumer.ts`\n\n```typescript\nimport * as shapes from "./shapes";\nlet t = new shapes.Triangle();\n```\n\n### 模块的取舍\n\n就像每个JS文件对应一个模块一样，TypeScript里模块文件与生成的JS文件也是一一对应的。 这会产生一种影响，根据你指定的目标模块系统的不同，你可能无法连接多个模块源文件。 例如当目标模块系统为`commonjs`或`umd`时，无法使用`outFile`选项，但是在TypeScript 1.8以上的版本[能够](../doc/handbook/release%20notes/TypeScript%201.8.md#concatenate-amd-and-system-modules-with---outfile)使用`outFile`当目标为`amd`或`system`。\n\n',$l='# 命名空间\n\n> **关于术语的一点说明:** 请务必注意一点，TypeScript 1.5里术语名已经发生了变化。 “内部模块”现在称做“命名空间”。 “外部模块”现在则简称为“模块”，这是为了与[ECMAScript 2015](http://www.ecma-international.org/ecma-262/6.0/)里的术语保持一致，\\(也就是说 `module X {` 相当于现在推荐的写法 `namespace X {`\\)。\n\n## 介绍\n\n这篇文章描述了如何在TypeScript里使用命名空间（之前叫做“内部模块”）来组织你的代码。 就像我们在术语说明里提到的那样，“内部模块”现在叫做“命名空间”。 另外，任何使用`module`关键字来声明一个内部模块的地方都应该使用`namespace`关键字来替换。 这就避免了让新的使用者被相似的名称所迷惑。\n\n## 第一步\n\n我们先来写一段程序并将在整篇文章中都使用这个例子。 我们定义几个简单的字符串验证器，假设你会使用它们来验证表单里的用户输入或验证外部数据。\n\n### 所有的验证器都放在一个文件里\n\n```typescript\ninterface StringValidator {\n    isAcceptable(s: string): boolean;\n}\n\nlet lettersRegexp = /^[A-Za-z]+$/;\nlet numberRegexp = /^[0-9]+$/;\n\nclass LettersOnlyValidator implements StringValidator {\n    isAcceptable(s: string) {\n        return lettersRegexp.test(s);\n    }\n}\n\nclass ZipCodeValidator implements StringValidator {\n    isAcceptable(s: string) {\n        return s.length === 5 && numberRegexp.test(s);\n    }\n}\n\n// Some samples to try\nlet strings = ["Hello", "98052", "101"];\n\n// Validators to use\nlet validators: { [s: string]: StringValidator; } = {};\nvalidators["ZIP code"] = new ZipCodeValidator();\nvalidators["Letters only"] = new LettersOnlyValidator();\n\n// Show whether each string passed each validator\nfor (let s of strings) {\n    for (let name in validators) {\n        let isMatch = validators[name].isAcceptable(s);\n        console.log(`\'${ s }\' ${ isMatch ? "matches" : "does not match" } \'${ name }\'.`);\n    }\n}\n```\n\n## 命名空间\n\n随着更多验证器的加入，我们需要一种手段来组织代码，以便于在记录它们类型的同时还不用担心与其它对象产生命名冲突。 因此，我们把验证器包裹到一个命名空间内，而不是把它们放在全局命名空间下。\n\n下面的例子里，把所有与验证器相关的类型都放到一个叫做`Validation`的命名空间里。 因为我们想让这些接口和类在命名空间之外也是可访问的，所以需要使用`export`。 相反的，变量`lettersRegexp`和`numberRegexp`是实现的细节，不需要导出，因此它们在命名空间外是不能访问的。 在文件末尾的测试代码里，由于是在命名空间之外访问，因此需要限定类型的名称，比如`Validation.LettersOnlyValidator`。\n\n### 使用命名空间的验证器\n\n```typescript\nnamespace Validation {\n    export interface StringValidator {\n        isAcceptable(s: string): boolean;\n    }\n\n    const lettersRegexp = /^[A-Za-z]+$/;\n    const numberRegexp = /^[0-9]+$/;\n\n    export class LettersOnlyValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return lettersRegexp.test(s);\n        }\n    }\n\n    export class ZipCodeValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return s.length === 5 && numberRegexp.test(s);\n        }\n    }\n}\n\n// Some samples to try\nlet strings = ["Hello", "98052", "101"];\n\n// Validators to use\nlet validators: { [s: string]: Validation.StringValidator; } = {};\nvalidators["ZIP code"] = new Validation.ZipCodeValidator();\nvalidators["Letters only"] = new Validation.LettersOnlyValidator();\n\n// Show whether each string passed each validator\nfor (let s of strings) {\n    for (let name in validators) {\n        console.log(`"${ s }" - ${ validators[name].isAcceptable(s) ? "matches" : "does not match" } ${ name }`);\n    }\n}\n```\n\n## 分离到多文件\n\n当应用变得越来越大时，我们需要将代码分离到不同的文件中以便于维护。\n\n### 多文件中的命名空间\n\n现在，我们把`Validation`命名空间分割成多个文件。 尽管是不同的文件，它们仍是同一个命名空间，并且在使用的时候就如同它们在一个文件中定义的一样。 因为不同文件之间存在依赖关系，所以我们加入了引用标签来告诉编译器文件之间的关联。 我们的测试代码保持不变。\n\n#### Validation.ts\n\n```typescript\nnamespace Validation {\n    export interface StringValidator {\n        isAcceptable(s: string): boolean;\n    }\n}\n```\n\n#### LettersOnlyValidator.ts\n\n```typescript\n/// <reference path="Validation.ts" />\nnamespace Validation {\n    const lettersRegexp = /^[A-Za-z]+$/;\n    export class LettersOnlyValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return lettersRegexp.test(s);\n        }\n    }\n}\n```\n\n#### ZipCodeValidator.ts\n\n```typescript\n/// <reference path="Validation.ts" />\nnamespace Validation {\n    const numberRegexp = /^[0-9]+$/;\n    export class ZipCodeValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return s.length === 5 && numberRegexp.test(s);\n        }\n    }\n}\n```\n\n#### Test.ts\n\n```typescript\n/// <reference path="Validation.ts" />\n/// <reference path="LettersOnlyValidator.ts" />\n/// <reference path="ZipCodeValidator.ts" />\n\n// Some samples to try\nlet strings = ["Hello", "98052", "101"];\n\n// Validators to use\nlet validators: { [s: string]: Validation.StringValidator; } = {};\nvalidators["ZIP code"] = new Validation.ZipCodeValidator();\nvalidators["Letters only"] = new Validation.LettersOnlyValidator();\n\n// Show whether each string passed each validator\nfor (let s of strings) {\n    for (let name in validators) {\n        console.log(`"${ s }" - ${ validators[name].isAcceptable(s) ? "matches" : "does not match" } ${ name }`);\n    }\n}\n```\n\n当涉及到多文件时，我们必须确保所有编译后的代码都被加载了。 我们有两种方式。\n\n第一种方式，把所有的输入文件编译为一个输出文件，需要使用`--outFile`标记：\n\n```text\ntsc --outFile sample.js Test.ts\n```\n\n编译器会根据源码里的引用标签自动地对输出进行排序。你也可以单独地指定每个文件。\n\n```text\ntsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts\n```\n\n第二种方式，我们可以编译每一个文件（默认方式），那么每个源文件都会对应生成一个JavaScript文件。 然后，在页面上通过`<script>`标签把所有生成的JavaScript文件按正确的顺序引进来，比如：\n\n#### MyTestPage.html \\(excerpt\\)\n\n```markup\n    <script src="Validation.js" type="text/javascript" />\n    <script src="LettersOnlyValidator.js" type="text/javascript" />\n    <script src="ZipCodeValidator.js" type="text/javascript" />\n    <script src="Test.js" type="text/javascript" />\n```\n\n## 别名\n\n另一种简化命名空间操作的方法是使用`import q = x.y.z`给常用的对象起一个短的名字。 不要与用来加载模块的`import x = require(\'name\')`语法弄混了，这里的语法是为指定的符号创建一个别名。 你可以用这种方法为任意标识符创建别名，也包括导入的模块中的对象。\n\n```typescript\nnamespace Shapes {\n    export namespace Polygons {\n        export class Triangle { }\n        export class Square { }\n    }\n}\n\nimport polygons = Shapes.Polygons;\nlet sq = new polygons.Square(); // Same as "new Shapes.Polygons.Square()"\n```\n\n注意，我们并没有使用`require`关键字，而是直接使用导入符号的限定名赋值。 这与使用`var`相似，但它还适用于类型和导入的具有命名空间含义的符号。 重要的是，对于值来讲，`import`会生成与原始符号不同的引用，所以改变别名的`var`值并不会影响原始变量的值。\n\n## 使用其它的JavaScript库\n\n为了描述不是用TypeScript编写的类库的类型，我们需要声明类库导出的API。 由于大部分程序库只提供少数的顶级对象，命名空间是用来表示它们的一个好办法。\n\n我们称其为声明是因为它不是外部程序的具体实现。 我们通常在`.d.ts`里写这些声明。 如果你熟悉C/C++，你可以把它们当做`.h`文件。 让我们看一些例子。\n\n### 外部命名空间\n\n流行的程序库D3在全局对象`d3`里定义它的功能。 因为这个库通过一个`<script>`标签加载（不是通过模块加载器），它的声明文件使用内部模块来定义它的类型。 为了让TypeScript编译器识别它的类型，我们使用外部命名空间声明。 比如，我们可以像下面这样写：\n\n#### D3.d.ts \\(部分摘录\\)\n\n```typescript\ndeclare namespace D3 {\n    export interface Selectors {\n        select: {\n            (selector: string): Selection;\n            (element: EventTarget): Selection;\n        };\n    }\n\n    export interface Event {\n        x: number;\n        y: number;\n    }\n\n    export interface Base extends Selectors {\n        event: Event;\n    }\n}\n\ndeclare var d3: D3.Base;\n```\n\n',Xl='# Symbols\n\n## 介绍\n\n自ECMAScript 2015起，`symbol`成为了一种新的原生类型，就像`number`和`string`一样。\n\n`symbol`类型的值是通过`Symbol`构造函数创建的。\n\n```typescript\nlet sym1 = Symbol();\n\nlet sym2 = Symbol("key"); // 可选的字符串key\n```\n\nSymbols是不可改变且唯一的。\n\n```typescript\nlet sym2 = Symbol("key");\nlet sym3 = Symbol("key");\n\nsym2 === sym3; // false, symbols是唯一的\n```\n\n像字符串一样，symbols也可以被用做对象属性的键。\n\n```typescript\nconst sym = Symbol();\n\nlet obj = {\n    [sym]: "value"\n};\n\nconsole.log(obj[sym]); // "value"\n```\n\nSymbols也可以与计算出的属性名声明相结合来声明对象的属性和类成员。\n\n```typescript\nconst getClassNameSymbol = Symbol();\n\nclass C {\n    [getClassNameSymbol](){\n       return "C";\n    }\n}\n\nlet c = new C();\nlet className = c[getClassNameSymbol](); // "C"\n```\n\n## 众所周知的Symbols\n\n除了用户定义的symbols，还有一些已经众所周知的内置symbols。 内置symbols用来表示语言内部的行为。\n\n以下为这些symbols的列表：\n\n### `Symbol.hasInstance`\n\n方法，会被`instanceof`运算符调用。构造器对象用来识别一个对象是否是其实例。\n\n### `Symbol.isConcatSpreadable`\n\n布尔值，表示当在一个对象上调用`Array.prototype.concat`时，这个对象的数组元素是否可展开。\n\n### `Symbol.iterator`\n\n方法，被`for-of`语句调用。返回对象的默认迭代器。\n\n### `Symbol.match`\n\n方法，被`String.prototype.match`调用。正则表达式用来匹配字符串。\n\n### `Symbol.replace`\n\n方法，被`String.prototype.replace`调用。正则表达式用来替换字符串中匹配的子串。\n\n### `Symbol.search`\n\n方法，被`String.prototype.search`调用。正则表达式返回被匹配部分在字符串中的索引。\n\n### `Symbol.species`\n\n函数值，为一个构造函数。用来创建派生对象。\n\n### `Symbol.split`\n\n方法，被`String.prototype.split`调用。正则表达式来用分割字符串。\n\n### `Symbol.toPrimitive`\n\n方法，被`ToPrimitive`抽象操作调用。把对象转换为相应的原始值。\n\n### `Symbol.toStringTag`\n\n方法，被内置方法`Object.prototype.toString`调用。返回创建对象时默认的字符串描述。\n\n### `Symbol.unscopables`\n\n对象，它自己拥有的属性会被`with`作用域排除在外。\n\n',Kl='# 三斜线指令\n\n三斜线指令是包含单个XML标签的单行注释。 注释的内容会做为编译器指令使用。\n\n三斜线指令_仅_可放在包含它的文件的最顶端。 一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。 如果它们出现在一个语句或声明之后，那么它们会被当做普通的单行注释，并且不具有特殊的涵义。\n\n## `/// <reference path="..." />`\n\n`/// <reference path="..." />`指令是三斜线指令中最常见的一种。 它用于声明文件间的_依赖_。\n\n三斜线引用告诉编译器在编译过程中要引入的额外的文件。\n\n当使用`--out`或`--outFile`时，它也可以做为调整输出内容顺序的一种方法。 文件在输出文件内容中的位置与经过预处理后的输入顺序一致。\n\n### 预处理输入文件\n\n编译器会对输入文件进行预处理来解析所有三斜线引用指令。 在这个过程中，额外的文件会加到编译过程中。\n\n这个过程会以一些_根文件_开始； 它们是在命令行中指定的文件或是在`tsconfig.json`中的`"files"`列表里的文件。 这些根文件按指定的顺序进行预处理。 在一个文件被加入列表前，它包含的所有三斜线引用都要被处理，还有它们包含的目标。 三斜线引用以它们在文件里出现的顺序，使用深度优先的方式解析。\n\n一个三斜线引用路径是相对于包含它的文件的，如果不是根文件。\n\n### 错误\n\n引用不存在的文件会报错。 一个文件用三斜线指令引用自己会报错。\n\n### 使用 `--noResolve`\n\n如果指定了`--noResolve`编译选项，三斜线引用会被忽略；它们不会增加新文件，也不会改变给定文件的顺序。\n\n## `/// <reference types="..." />`\n\n与`/// <reference path="..." />`指令相似（用于声明_依赖_），`/// <reference types="..." />`指令声明了对某个包的依赖。\n\n对这些包的名字的解析与在`import`语句里对模块名的解析类似。 可以简单地把三斜线类型引用指令当做`import`声明的包。\n\n例如，把`/// <reference types="node" />`引入到声明文件，表明这个文件使用了`@types/node/index.d.ts`里面声明的名字； 并且，这个包需要在编译阶段与声明文件一起被包含进来。\n\n仅当在你需要写一个`d.ts`文件时才使用这个指令。\n\n对于那些在编译阶段生成的声明文件，编译器会自动地添加`/// <reference types="..." />`； _当且仅当_结果文件中使用了引用的包里的声明时才会在生成的声明文件里添加`/// <reference types="..." />`语句。\n\n若要在`.ts`文件里声明一个对`@types`包的依赖，使用`--types`命令行选项或在`tsconfig.json`里指定。 查看[在`tsconfig.json`里使用`@types`，`typeRoots`和`types`](../project-config/tsconfig.json.md#types-typeroots-and-types)了解详情。\n\n## `/// <reference no-default-lib="true"/>`\n\n这个指令把一个文件标记成_默认库_。 你会在`lib.d.ts`文件和它不同的变体的顶端看到这个注释。\n\n这个指令告诉编译器在编译过程中_不要_包含这个默认库（比如，`lib.d.ts`）。 这与在命令行上使用`--noLib`相似。\n\n还要注意，当传递了`--skipDefaultLibCheck`时，编译器只会忽略检查带有`/// <reference no-default-lib="true"/>`的文件。\n\n## `/// <amd-module />`\n\n默认情况下生成的AMD模块都是匿名的。 但是，当一些工具需要处理生成的模块时会产生问题，比如`r.js`。\n\n`amd-module`指令允许给编译器传入一个可选的模块名：\n\n#### amdModule.ts\n\n```typescript\n///<amd-module name=\'NamedModule\'/>\nexport class C {\n}\n```\n\n这会将`NamedModule`传入到AMD `define`函数里：\n\n#### amdModule.js\n\n```javascript\ndefine("NamedModule", ["require", "exports"], function (require, exports) {\n    var C = (function () {\n        function C() {\n        }\n        return C;\n    })();\n    exports.C = C;\n});\n```\n\n## `/// <amd-dependency />`\n\n> **注意**：这个指令被废弃了。使用`import "moduleName";`语句代替。\n\n`/// <amd-dependency path="x" />`告诉编译器有一个非TypeScript模块依赖需要被注入，做为目标模块`require`调用的一部分。\n\n`amd-dependency`指令也可以带一个可选的`name`属性；它允许我们为amd-dependency传入一个可选名字：\n\n```typescript\n/// <amd-dependency path="legacy/moduleA" name="moduleA"/>\ndeclare var moduleA:MyType\nmoduleA.callStuff()\n```\n\n生成的JavaScript代码：\n\n```javascript\ndefine(["require", "exports", "legacy/moduleA"], function (require, exports, moduleA) {\n    moduleA.callStuff()\n});\n```\n\n',Ql="# 类型兼容性\n\n## 介绍\n\nTypeScript里的类型兼容性是基于结构子类型的。 结构类型是一种只使用其成员来描述类型的方式。 它正好与名义（nominal）类型形成对比。（译者注：在基于名义类型的类型系统中，数据类型的兼容性或等价性是通过明确的声明和/或类型的名称来决定的。这与结构性类型系统不同，它是基于类型的组成结构，且不要求明确地声明。） 看下面的例子：\n\n```typescript\ninterface Named {\n    name: string;\n}\n\nclass Person {\n    name: string;\n}\n\nlet p: Named;\n// OK, because of structural typing\np = new Person();\n```\n\n在使用基于名义类型的语言，比如C\\#或Java中，这段代码会报错，因为Person类没有明确说明其实现了Named接口。\n\nTypeScript的结构性子类型是根据JavaScript代码的典型写法来设计的。 因为JavaScript里广泛地使用匿名对象，例如函数表达式和对象字面量，所以使用结构类型系统来描述这些类型比使用名义类型系统更好。\n\n### 关于可靠性的注意事项\n\nTypeScript的类型系统允许某些在编译阶段无法确认其安全性的操作。当一个类型系统具此属性时，被当做是“不可靠”的。TypeScript允许这种不可靠行为的发生是经过仔细考虑的。通过这篇文章，我们会解释什么时候会发生这种情况和其有利的一面。\n\n## 开始\n\nTypeScript结构化类型系统的基本规则是，如果`x`要兼容`y`，那么`y`至少具有与`x`相同的属性。比如：\n\n```typescript\ninterface Named {\n    name: string;\n}\n\nlet x: Named;\n// y's inferred type is { name: string; location: string; }\nlet y = { name: 'Alice', location: 'Seattle' };\nx = y;\n```\n\n这里要检查`y`是否能赋值给`x`，编译器检查`x`中的每个属性，看是否能在`y`中也找到对应属性。 在这个例子中，`y`必须包含名字是`name`的`string`类型成员。`y`满足条件，因此赋值正确。\n\n检查函数参数时使用相同的规则：\n\n```typescript\nfunction greet(n: Named) {\n    console.log('Hello, ' + n.name);\n}\ngreet(y); // OK\n```\n\n注意，`y`有个额外的`location`属性，但这不会引发错误。 只有目标类型（这里是`Named`）的成员会被一一检查是否兼容。\n\n这个比较过程是递归进行的，检查每个成员及子成员。\n\n## 比较两个函数\n\n相对来讲，在比较原始类型和对象类型的时候是比较容易理解的，问题是如何判断两个函数是兼容的。 下面我们从两个简单的函数入手，它们仅是参数列表略有不同：\n\n```typescript\nlet x = (a: number) => 0;\nlet y = (b: number, s: string) => 0;\n\ny = x; // OK\nx = y; // Error\n```\n\n要查看`x`是否能赋值给`y`，首先看它们的参数列表。 `x`的每个参数必须能在`y`里找到对应类型的参数。 注意的是参数的名字相同与否无所谓，只看它们的类型。 这里，`x`的每个参数在`y`中都能找到对应的参数，所以允许赋值。\n\n第二个赋值错误，因为`y`有个必需的第二个参数，但是`x`并没有，所以不允许赋值。\n\n你可能会疑惑为什么允许`忽略`参数，像例子`y = x`中那样。 原因是忽略额外的参数在JavaScript里是很常见的。 例如，`Array#forEach`给回调函数传3个参数：数组元素，索引和整个数组。 尽管如此，传入一个只使用第一个参数的回调函数也是很有用的：\n\n```typescript\nlet items = [1, 2, 3];\n\n// Don't force these extra arguments\nitems.forEach((item, index, array) => console.log(item));\n\n// Should be OK!\nitems.forEach((item) => console.log(item));\n```\n\n下面来看看如何处理返回值类型，创建两个仅是返回值类型不同的函数：\n\n```typescript\nlet x = () => ({name: 'Alice'});\nlet y = () => ({name: 'Alice', location: 'Seattle'});\n\nx = y; // OK\ny = x; // Error, because x() lacks a location property\n```\n\n类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型。\n\n### 函数参数双向协变\n\n当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。 这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候却使用了不是那么精确的类型信息。 实际上，这极少会发生错误，并且能够实现很多JavaScript里的常见模式。例如：\n\n```typescript\nenum EventType { Mouse, Keyboard }\n\ninterface Event { timestamp: number; }\ninterface MouseEvent extends Event { x: number; y: number }\ninterface KeyEvent extends Event { keyCode: number }\n\nfunction listenEvent(eventType: EventType, handler: (n: Event) => void) {\n    /* ... */\n}\n\n// Unsound, but useful and common\nlistenEvent(EventType.Mouse, (e: MouseEvent) => console.log(e.x + ',' + e.y));\n\n// Undesirable alternatives in presence of soundness\nlistenEvent(EventType.Mouse, (e: Event) => console.log((e as MouseEvent).x + \",\" + (e as MouseEvent).y));\nlistenEvent(EventType.Mouse, ((e: MouseEvent) => console.log(e.x + \",\" + e.y)) as (e: Event) => void);\n\n// Still disallowed (clear error). Type safety enforced for wholly incompatible types\nlistenEvent(EventType.Mouse, (e: number) => console.log(e));\n```\n\n你可以使用`strictFunctionTypes`编译选项，使TypeScript在这种情况下报错。\n\n### 可选参数及剩余参数\n\n比较函数兼容性的时候，可选参数与必须参数是可互换的。 源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误。\n\n当一个函数有剩余参数时，它被当做无限个可选参数。\n\n这对于类型系统来说是不稳定的，但从运行时的角度来看，可选参数一般来说是不强制的，因为对于大多数函数来说相当于传递了一些`undefinded`。\n\n有一个好的例子，常见的函数接收一个回调函数并用对于程序员来说是可预知的参数但对类型系统来说是不确定的参数来调用：\n\n```typescript\nfunction invokeLater(args: any[], callback: (...args: any[]) => void) {\n    /* ... Invoke callback with 'args' ... */\n}\n\n// Unsound - invokeLater \"might\" provide any number of arguments\ninvokeLater([1, 2], (x, y) => console.log(x + ', ' + y));\n\n// Confusing (x and y are actually required) and undiscoverable\ninvokeLater([1, 2], (x?, y?) => console.log(x + ', ' + y));\n```\n\n### 函数重载\n\n对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名。 这确保了目标函数可以在所有源函数可调用的地方调用。\n\n## 枚举\n\n枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的。比如，\n\n```typescript\nenum Status { Ready, Waiting };\nenum Color { Red, Blue, Green };\n\nlet status = Status.Ready;\nstatus = Color.Green;  // Error\n```\n\n## 类\n\n类与对象字面量和接口差不多，但有一点不同：类有静态部分和实例部分的类型。 比较两个类类型的对象时，只有实例的成员会被比较。 静态成员和构造函数不在比较的范围内。\n\n```typescript\nclass Animal {\n    feet: number;\n    constructor(name: string, numFeet: number) { }\n}\n\nclass Size {\n    feet: number;\n    constructor(numFeet: number) { }\n}\n\nlet a: Animal;\nlet s: Size;\n\na = s;  // OK\ns = a;  // OK\n```\n\n### 类的私有成员和受保护成员\n\n类的私有成员和受保护成员会影响兼容性。 当检查类实例的兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。 同样地，这条规则也适用于包含受保护成员实例的类型检查。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。\n\n## 泛型\n\n因为TypeScript是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型。比如，\n\n```typescript\ninterface Empty<T> {\n}\nlet x: Empty<number>;\nlet y: Empty<string>;\n\nx = y;  // OK, because y matches structure of x\n```\n\n上面代码里，`x`和`y`是兼容的，因为它们的结构使用类型参数时并没有什么不同。 把这个例子改变一下，增加一个成员，就能看出是如何工作的了：\n\n```typescript\ninterface NotEmpty<T> {\n    data: T;\n}\nlet x: NotEmpty<number>;\nlet y: NotEmpty<string>;\n\nx = y;  // Error, because x and y are not compatible\n```\n\n在这里，泛型类型在使用时就好比不是一个泛型类型。\n\n对于没指定泛型类型的泛型参数时，会把所有泛型参数当成`any`比较。 然后用结果类型进行比较，就像上面第一个例子。\n\n比如，\n\n```typescript\nlet identity = function<T>(x: T): T {\n    // ...\n}\n\nlet reverse = function<U>(y: U): U {\n    // ...\n}\n\nidentity = reverse;  // OK, because (x: any) => any matches (y: any) => any\n```\n\n## 高级主题\n\n### 子类型与赋值\n\n目前为止，我们使用了“兼容性”，它在语言规范里没有定义。 在TypeScript里，有两种兼容性：子类型和赋值。 它们的不同点在于，赋值扩展了子类型兼容性，增加了一些规则，允许和`any`来回赋值，以及`enum`和对应数字值之间的来回赋值。\n\n语言里的不同地方分别使用了它们之中的机制。 实际上，类型兼容性是由赋值兼容性来控制的，即使在`implements`和`extends`语句也不例外。\n\n更多信息，请参阅[TypeScript语言规范](https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md).\n\n",Yl="# 类型推论\n\n## 介绍\n\n这节介绍TypeScript里的类型推论。即，类型是在哪里如何被推断的。\n\n## 基础\n\nTypeScript里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。如下面的例子\n\n```typescript\nlet x = 3;\n```\n\n变量`x`的类型被推断为数字。 这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。\n\n大多数情况下，类型推论是直截了当地。 后面的小节，我们会浏览类型推论时的细微差别。\n\n## 最佳通用类型\n\n当需要从几个表达式中推断类型时候，会使用这些表达式的类型来推断出一个最合适的通用类型。例如，\n\n```typescript\nlet x = [0, 1, null];\n```\n\n为了推断`x`的类型，我们必须考虑所有元素的类型。 这里有两种选择：`number`和`null`。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。\n\n由于最终的通用类型取自候选类型，有些时候候选类型共享相同的通用类型，但是却没有一个类型能做为所有候选类型的类型。例如：\n\n```typescript\nlet zoo = [new Rhino(), new Elephant(), new Snake()];\n```\n\n这里，我们想让zoo被推断为`Animal[]`类型，但是这个数组里没有对象是`Animal`类型的，因此不能推断出这个结果。 为了更正，当候选类型不能使用的时候我们需要明确的指出类型：\n\n```typescript\nlet zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];\n```\n\n如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，`(Rhino | Elephant | Snake)[]`。\n\n## 上下文归类\n\nTypeScript类型推论也可能按照相反的方向进行。 这被叫做“上下文归类”。按上下文归类会发生在表达式的类型与所处的位置相关时。比如：\n\n```typescript\nwindow.onmousedown = function(mouseEvent) {\n    console.log(mouseEvent.button);   //<- OK\n    console.log(mouseEvent.kangaroo); //<- Error!\n};\n```\n\n在这个例子里，TypeScript类型检查器会使用`Window.onmousedown`函数的类型来推断右边函数表达式的类型。 所以它能够推断出`mouseEvent`参数的[类型](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent)中包含了`button`属性而不包含`kangaroo`属性。\n\nTypeScript还能够很好地推断出其它上下文中的类型。\n\n```typescript\nwindow.onscroll = function(uiEvent) {\n    console.log(uiEvent.button); //<- Error!\n}\n```\n\n上面的函数被赋值给`window.onscroll`，`TypeScript`能够知道`uiEvent`是[UIEvent](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent)，而不是[MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent)。`UIEvent`对象不包含`button`属性，因此TypeScript会报错。\n\n如果这个函数不是在上下文归类的位置上，那么这个函数的参数类型将隐式的成为`any`类型，而且也不会报错（除非你开启了`--noImplicitAny`选项）：\n\n```typescript\nconst handler = function(uiEvent) {\n    console.log(uiEvent.button); //<- OK\n}\n```\n\n我们也可以明确地为函数参数类型赋值来覆写上下文类型：\n\n```typescript\nwindow.onscroll = function(uiEvent: any) {\n    console.log(uiEvent.button);  //<- Now, no error is given\n};\n```\n\n但这段代码会打印`undefined`，因为`uiEvent`并不包含`button`属性。\n\n上下文归类会在很多情况下使用到。 通常包含函数的参数，赋值表达式的右边，类型断言，对象成员和数组字面量和返回值语句。 上下文类型也会做为最佳通用类型的候选类型。比如：\n\n```typescript\nfunction createZoo(): Animal[] {\n    return [new Rhino(), new Elephant(), new Snake()];\n}\n```\n\n这个例子里，最佳通用类型有4个候选者：`Animal`，`Rhino`，`Elephant`和`Snake`。 当然，`Animal`会被做为最佳通用类型。\n\n",Zl="# 实用工具类型\n\nTypeScript 提供一些工具类型来帮助常见的类型转换。这些类型是全局可见的。\n\n## 目录\n\n-   [`Partial<T>`，TypeScript 2.1](#partialtype)\n-   [`Readonly<Type>`，TypeScript 2.1](#readonlytype)\n-   [`Record<Keys, Type>`，TypeScript 2.1](#recordkeys-type)\n-   [`Pick<Type, Keys>`，TypeScript 2.1](#picktype-keys)\n-   [`Omit<Type, Keys>`，TypeScript 3.5](#omittype-keys)\n-   [`Exclude<Type, ExcludedUnion>`，TypeScript 2.8](#excludetype-excludedunion)\n-   [`Extract<Type, Union>`，TypeScript 2.8](#extracttype-union)\n-   [`NonNullable<Type>`，TypeScript 2.8](#nonnullabletype)\n-   [`Parameters<Type>`](#parameterstype)\n-   [`ConstructorParameters<Type>`](#constructorparameterstype)\n-   [`ReturnType<Type>`，TypeScript 2.8](#returntypetype)\n-   [`InstanceType<Type>`，TypeScript 2.8](#instancetypetype)\n-   [`Required<Type>`，TypeScript 2.8](#requiredtype)\n-   [`ThisParameterType<Type>`](#thisparametertypetype)\n-   [`OmitThisParameter<Type>`](#omitthisparametertype)\n-   [`ThisType<Type>`，TypeScript 2.8](#thistypetype)\n-   [操作字符串的类型](#操作字符串的类型)\n\n## `Partial<Type>`\n\n构造类型`Type`，并将它所有的属性设置为可选的。它的返回类型表示输入类型的所有子类型。\n\n### 例子\n\n```typescript\ninterface Todo {\n    title: string;\n    description: string;\n}\n\nfunction updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {\n    return { ...todo, ...fieldsToUpdate };\n}\n\nconst todo1 = {\n    title: 'organize desk',\n    description: 'clear clutter',\n};\n\nconst todo2 = updateTodo(todo1, {\n    description: 'throw out trash',\n});\n```\n\n## `Readonly<Type>`\n\n构造类型`Type`，并将它所有的属性设置为`readonly`，也就是说构造出的类型的属性不能被再次赋值。\n\n### 例子\n\n```typescript\ninterface Todo {\n    title: string;\n}\n\nconst todo: Readonly<Todo> = {\n    title: 'Delete inactive users',\n};\n\ntodo.title = 'Hello'; // Error: cannot reassign a readonly property\n```\n\n这个工具可用来表示在运行时会失败的赋值表达式（比如，当尝试给[冻结对象](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)的属性再次赋值时）。\n\n### `Object.freeze`\n\n```typescript\nfunction freeze<T>(obj: T): Readonly<T>;\n```\n\n## `Record<Keys, Type>`\n\n构造一个类型，其属性名的类型为`K`，属性值的类型为`T`。这个工具可用来将某个类型的属性映射到另一个类型上。\n\n### 例子\n\n```typescript\ninterface PageInfo {\n    title: string;\n}\n\ntype Page = 'home' | 'about' | 'contact';\n\nconst x: Record<Page, PageInfo> = {\n    about: { title: 'about' },\n    contact: { title: 'contact' },\n    home: { title: 'home' },\n};\n```\n\n## `Pick<Type, Keys>`\n\n从类型`Type`中挑选部分属性`Keys`来构造类型。\n\n### 例子\n\n```typescript\ninterface Todo {\n    title: string;\n    description: string;\n    completed: boolean;\n}\n\ntype TodoPreview = Pick<Todo, 'title' | 'completed'>;\n\nconst todo: TodoPreview = {\n    title: 'Clean room',\n    completed: false,\n};\n```\n\n## `Omit<Type, Keys>`\n\n从类型`Type`中获取所有属性，然后从中剔除`Keys`属性后构造一个类型。\n\n### 例子\n\n```typescript\ninterface Todo {\n    title: string;\n    description: string;\n    completed: boolean;\n}\n\ntype TodoPreview = Omit<Todo, 'description'>;\n\nconst todo: TodoPreview = {\n    title: 'Clean room',\n    completed: false,\n};\n```\n\n## `Exclude<Type, ExcludedUnion>`\n\n从类型`Type`中剔除所有可以赋值给`ExcludedUnion`的属性，然后构造一个类型。\n\n### 例子\n\n```typescript\ntype T0 = Exclude<'a' | 'b' | 'c', 'a'>; // \"b\" | \"c\"\ntype T1 = Exclude<'a' | 'b' | 'c', 'a' | 'b'>; // \"c\"\ntype T2 = Exclude<string | number | (() => void), Function>; // string | number\n```\n\n## `Extract<Type, Union>`\n\n从类型`Type`中提取所有可以赋值给`Union`的类型，然后构造一个类型。\n\n### 例子\n\n```typescript\ntype T0 = Extract<'a' | 'b' | 'c', 'a' | 'f'>; // \"a\"\ntype T1 = Extract<string | number | (() => void), Function>; // () => void\n```\n\n## `NonNullable<Type>`\n\n从类型`Type`中剔除`null`和`undefined`，然后构造一个类型。\n\n### 例子\n\n```typescript\ntype T0 = NonNullable<string | number | undefined>; // string | number\ntype T1 = NonNullable<string[] | null | undefined>; // string[]\n```\n\n## `Parameters<Type>`\n\n由函数类型`Type`的参数类型来构建出一个元组类型。\n\n### 例子\n\n```ts\ndeclare function f1(arg: { a: number; b: string }): void;\n\ntype T0 = Parameters<() => string>;\n//    []\ntype T1 = Parameters<(s: string) => void>;\n//    [s: string]\ntype T2 = Parameters<<T>(arg: T) => T>;\n//    [arg: unknown]\ntype T3 = Parameters<typeof f1>;\n//    [arg: { a: number; b: string; }]\ntype T4 = Parameters<any>;\n//    unknown[]\ntype T5 = Parameters<never>;\n//    never\ntype T6 = Parameters<string>;\n//   never\n//   Type 'string' does not satisfy the constraint '(...args: any) => any'.\ntype T7 = Parameters<Function>;\n//   never\n//   Type 'Function' does not satisfy the constraint '(...args: any) => any'.\n```\n\n## `ConstructorParameters<Type>`\n\n由构造函数类型来构建出一个元组类型或数组类型。\n由构造函数类型`Type`的参数类型来构建出一个元组类型。（若`Type`不是构造函数类型，则返回`never`）。\n\n### 例子\n\n```ts\ntype T0 = ConstructorParameters<ErrorConstructor>;\n//    [message?: string | undefined]\ntype T1 = ConstructorParameters<FunctionConstructor>;\n//    string[]\ntype T2 = ConstructorParameters<RegExpConstructor>;\n//    [pattern: string | RegExp, flags?: string | undefined]\ntype T3 = ConstructorParameters<any>;\n//   unknown[]\n\ntype T4 = ConstructorParameters<Function>;\n//    never\n// Type 'Function' does not satisfy the constraint 'new (...args: any) => any'.\n```\n\n## `ReturnType<Type>`\n\n由函数类型`Type`的返回值类型构建一个新类型。\n\n### 例子\n\n```\ntype T0 = ReturnType<() => string>;  // string\ntype T1 = ReturnType<(s: string) => void>;  // void\ntype T2 = ReturnType<(<T>() => T)>;  // {}\ntype T3 = ReturnType<(<T extends U, U extends number[]>() => T)>;  // number[]\ntype T4 = ReturnType<typeof f1>;  // { a: number, b: string }\ntype T5 = ReturnType<any>;  // any\ntype T6 = ReturnType<never>;  // any\ntype T7 = ReturnType<string>;  // Error\ntype T8 = ReturnType<Function>;  // Error\n```\n\n## `InstanceType<Type>`\n\n由构造函数类型`Type`的实例类型来构建一个新类型。\n\n### 例子\n\n```typescript\nclass C {\n    x = 0;\n    y = 0;\n}\n\ntype T0 = InstanceType<typeof C>; // C\ntype T1 = InstanceType<any>; // any\ntype T2 = InstanceType<never>; // any\ntype T3 = InstanceType<string>; // Error\ntype T4 = InstanceType<Function>; // Error\n```\n\n## `Required<Type>`\n\n构建一个类型，使类型`Type`的所有属性为`required`。\n与此相反的是[`Partial`](#partialtype)。\n\n### 例子\n\n```typescript\ninterface Props {\n    a?: number;\n    b?: string;\n}\n\nconst obj: Props = { a: 5 }; // OK\n\nconst obj2: Required<Props> = { a: 5 }; // Error: property 'b' missing\n```\n\n## `ThisParameterType<Type>`\n\n从函数类型中提取 [this](../handbook/functions.md#this参数) 参数的类型。\n若函数类型不包含 `this` 参数，则返回 [unknown](../handbook/basic-types.md#unknown) 类型。\n\n### 例子\n\n```ts\nfunction toHex(this: Number) {\n    return this.toString(16);\n}\n\nfunction numberToString(n: ThisParameterType<typeof toHex>) {\n    return toHex.apply(n);\n}\n```\n\n## `OmitThisParameter<Type>`\n\n从`Type`类型中剔除 [`this`](../handbook/functions.md#this参数) 参数。\n若未声明 `this` 参数，则结果类型为 `Type` 。\n否则，由`Type`类型来构建一个不带`this`参数的类型。\n泛型会被忽略，并且只有最后的重载签名会被采用。\n\n### 例子\n\n```ts\nfunction toHex(this: Number) {\n    return this.toString(16);\n}\n\nconst fiveToHex: OmitThisParameter<typeof toHex> = toHex.bind(5);\n\nconsole.log(fiveToHex());\n```\n\n## `ThisType<Type>`\n\n这个工具不会返回一个转换后的类型。\n它做为上下文的[`this`](../handbook/functions.md#this)类型的一个标记。\n注意，若想使用此类型，必须启用`--noImplicitThis`。\n\n### 例子\n\n```typescript\n// Compile with --noImplicitThis\n\ntype ObjectDescriptor<D, M> = {\n    data?: D;\n    methods?: M & ThisType<D & M>; // Type of 'this' in methods is D & M\n};\n\nfunction makeObject<D, M>(desc: ObjectDescriptor<D, M>): D & M {\n    let data: object = desc.data || {};\n    let methods: object = desc.methods || {};\n    return { ...data, ...methods } as D & M;\n}\n\nlet obj = makeObject({\n    data: { x: 0, y: 0 },\n    methods: {\n        moveBy(dx: number, dy: number) {\n            this.x += dx; // Strongly typed this\n            this.y += dy; // Strongly typed this\n        },\n    },\n});\n\nobj.x = 10;\nobj.y = 20;\nobj.moveBy(5, 5);\n```\n\n上面例子中，`makeObject`参数里的`methods`对象具有一个上下文类型`ThisType<D & M>`，因此`methods`对象的方法里`this`的类型为`{ x: number, y: number } & { moveBy(dx: number, dy: number): number }`。\n\n在`lib.d.ts`里，`ThisType<T>`标识接口是个简单的空接口声明。除了在被识别为对象字面量的上下文类型之外，这个接口与一般的空接口没有什么不同。\n\n## 操作字符串的类型\n\n为了便于操作模版字符串字面量，TypeScript 引入了一些能够操作字符串的类型。\n更多详情，请阅读[模版字面量类型](../handbook-v2/type-manipulation/template-literal-types.md#固有字符串操作类型)。\n",nc='# 变量声明\n\n## 变量声明\n\n`let`和`const`是JavaScript里相对较新的变量声明方式。 [像我们之前提到过的](basic-types.md#a-note-about-let)，`let`在很多方面与`var`是相似的，但是可以帮助大家避免在JavaScript里常见一些问题。 `const`是对`let`的一个增强，它能阻止对一个变量再次赋值。\n\n因为TypeScript是JavaScript的超集，所以它本身就支持`let`和`const`。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替`var`。\n\n如果你之前使用JavaScript时没有特别在意，那么这节内容会唤起你的回忆。 如果你已经对`var`声明的怪异之处了如指掌，那么你可以轻松地略过这节。\n\n## `var` 声明\n\n一直以来我们都是通过`var`关键字定义JavaScript变量。\n\n```typescript\nvar a = 10;\n```\n\n大家都能理解，这里定义了一个名为`a`值为`10`的变量。\n\n我们也可以在函数内部定义变量：\n\n```typescript\nfunction f() {\n    var message = "Hello, world!";\n\n    return message;\n}\n```\n\n并且我们也可以在其它函数内部访问相同的变量。\n\n```typescript\nfunction f() {\n    var a = 10;\n    return function g() {\n        var b = a + 1;\n        return b;\n    }\n}\n\nvar g = f();\ng(); // returns 11;\n```\n\n上面的例子里，`g`可以获取到`f`函数里定义的`a`变量。 每当`g`被调用时，它都可以访问到`f`里的`a`变量。 即使当`g`在`f`已经执行完后才被调用，它仍然可以访问及修改`a`。\n\n```typescript\nfunction f() {\n    var a = 1;\n\n    a = 2;\n    var b = g();\n    a = 3;\n\n    return b;\n\n    function g() {\n        return a;\n    }\n}\n\nf(); // returns 2\n```\n\n### 作用域规则\n\n对于熟悉其它语言的人来说，`var`声明有些奇怪的作用域规则。 看下面的例子：\n\n```typescript\nfunction f(shouldInitialize: boolean) {\n    if (shouldInitialize) {\n        var x = 10;\n    }\n\n    return x;\n}\n\nf(true);  // returns \'10\'\nf(false); // returns \'undefined\'\n```\n\n有些读者可能要多看几遍这个例子。 变量`x`是定义在_`if`语句里面_，但是我们却可以在语句的外面访问它。 这是因为`var`声明可以在包含它的函数，模块，命名空间或全局作用域内部任何位置被访问（我们后面会详细介绍），包含它的代码块对此没有什么影响。 有些人称此为_`var`作用域_或_函数作用域_。 函数参数也使用函数作用域。\n\n这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：\n\n```typescript\nfunction sumMatrix(matrix: number[][]) {\n    var sum = 0;\n    for (var i = 0; i < matrix.length; i++) {\n        var currentRow = matrix[i];\n        for (var i = 0; i < currentRow.length; i++) {\n            sum += currentRow[i];\n        }\n    }\n\n    return sum;\n}\n```\n\n这里很容易看出一些问题，里层的`for`循环会覆盖变量`i`，因为所有`i`都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。\n\n### 捕获变量怪异之处\n\n快速的猜一下下面的代码会返回什么：\n\n```typescript\nfor (var i = 0; i < 10; i++) {\n    setTimeout(function() { console.log(i); }, 100 * i);\n}\n```\n\n介绍一下，`setTimeout`会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）。\n\n好吧，看一下结果：\n\n```text\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n```\n\n很多JavaScript程序员对这种行为已经很熟悉了，但如果你很不解，你并不是一个人。 大多数人期望输出结果是这样：\n\n```text\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n\n还记得我们上面提到的捕获变量吗？ 我们传给`setTimeout`的每一个函数表达式实际上都引用了相同作用域里的同一个`i`。\n\n让我们花点时间思考一下这是为什么。 `setTimeout`在若干毫秒后执行一个函数，并且是在`for`循环结束后。 `for`循环结束后，`i`的值为`10`。 所以当函数被调用的时候，它会打印出`10`！\n\n一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时`i`的值：\n\n```typescript\nfor (var i = 0; i < 10; i++) {\n    // capture the current state of \'i\'\n    // by invoking a function with its current value\n    (function(i) {\n        setTimeout(function() { console.log(i); }, 100 * i);\n    })(i);\n}\n```\n\n这种奇怪的形式我们已经司空见惯了。 参数`i`会覆盖`for`循环里的`i`，但是因为我们起了同样的名字，所以我们不用怎么改`for`循环体里的代码。\n\n## `let` 声明\n\n现在你已经知道了`var`存在一些问题，这恰好说明了为什么用`let`语句来声明变量。 除了名字不同外，`let`与`var`的写法一致。\n\n```typescript\nlet hello = "Hello!";\n```\n\n主要的区别不在语法上，而是语义，我们接下来会深入研究。\n\n### 块作用域\n\n当用`let`声明一个变量，它使用的是_词法作用域_或_块作用域_。 不同于使用`var`声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或`for`循环之外是不能访问的。\n\n```typescript\nfunction f(input: boolean) {\n    let a = 100;\n\n    if (input) {\n        // Still okay to reference \'a\'\n        let b = a + 1;\n        return b;\n    }\n\n    // Error: \'b\' doesn\'t exist here\n    return b;\n}\n```\n\n这里我们定义了2个变量`a`和`b`。 `a`的作用域是`f`函数体内，而`b`的作用域是`if`语句块里。\n\n在`catch`语句里声明的变量也具有同样的作用域规则。\n\n```typescript\ntry {\n    throw "oh no!";\n}\ncatch (e) {\n    console.log("Oh well.");\n}\n\n// Error: \'e\' doesn\'t exist here\nconsole.log(e);\n```\n\n拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于_暂时性死区_。 它只是用来说明我们不能在`let`语句之前访问它们，幸运的是TypeScript可以告诉我们这些信息。\n\n```typescript\na++; // illegal to use \'a\' before it\'s declared;\nlet a;\n```\n\n注意一点，我们仍然可以在一个拥有块作用域变量被声明前_获取_它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为ES2015，现代的运行时会抛出一个错误；然而，现今TypeScript是不会报错的。\n\n```typescript\nfunction foo() {\n    // okay to capture \'a\'\n    return a;\n}\n\n// 不能在\'a\'被声明前调用\'foo\'\n// 运行时应该抛出错误\nfoo();\n\nlet a;\n```\n\n关于_暂时性死区_的更多信息，查看这里[Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let).\n\n### 重声明及屏蔽\n\n我们提过使用`var`声明时，它不在乎你声明多少次；你只会得到1个。\n\n```typescript\nfunction f(x) {\n    var x;\n    var x;\n\n    if (true) {\n        var x;\n    }\n}\n```\n\n在上面的例子里，所有`x`的声明实际上都引用一个_相同_的`x`，并且这是完全有效的代码。 这经常会成为bug的来源。 好的是，`let`声明就不会这么宽松了。\n\n```typescript\nlet x = 10;\nlet x = 20; // 错误，不能在1个作用域里多次声明`x`\n```\n\n并不是要求两个均是块级作用域的声明TypeScript才会给出一个错误的警告。\n\n```typescript\nfunction f(x) {\n    let x = 100; // error: interferes with parameter declaration\n}\n\nfunction g() {\n    let x = 100;\n    var x = 100; // error: can\'t have both declarations of \'x\'\n}\n```\n\n并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。\n\n```typescript\nfunction f(condition, x) {\n    if (condition) {\n        let x = 100;\n        return x;\n    }\n\n    return x;\n}\n\nf(false, 0); // returns 0\nf(true, 0);  // returns 100\n```\n\n在一个嵌套作用域里引入一个新名字的行为称做_屏蔽_。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用`let`重写之前的`sumMatrix`函数。\n\n```typescript\nfunction sumMatrix(matrix: number[][]) {\n    let sum = 0;\n    for (let i = 0; i < matrix.length; i++) {\n        var currentRow = matrix[i];\n        for (let i = 0; i < currentRow.length; i++) {\n            sum += currentRow[i];\n        }\n    }\n\n    return sum;\n}\n```\n\n这个版本的循环能得到正确的结果，因为内层循环的`i`可以屏蔽掉外层循环的`i`。\n\n_通常_来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好打算一下。\n\n### 块级作用域变量的获取\n\n在我们最初谈及获取用`var`声明的变量时，我们简略地探究了一下在获取到了变量之后它的行为是怎样的。 直观地讲，每次进入一个作用域时，它创建了一个变量的_环境_。 就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。\n\n```typescript\nfunction theCityThatAlwaysSleeps() {\n    let getCity;\n\n    if (true) {\n        let city = "Seattle";\n        getCity = function() {\n            return city;\n        }\n    }\n\n    return getCity();\n}\n```\n\n因为我们已经在`city`的环境里获取到了`city`，所以就算`if`语句执行结束后我们仍然可以访问它。\n\n回想一下前面`setTimeout`的例子，我们最后需要使用立即执行的函数表达式来获取每次`for`循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在TypeScript里这样做了。\n\n当`let`声明出现在循环体里时拥有完全不同的行为。 不仅是在循环里引入了一个新的变量环境，而是针对_每次迭代_都会创建这样一个新作用域。 这就是我们在使用立即执行的函数表达式时做的事，所以在`setTimeout`例子里我们仅使用`let`声明就可以了。\n\n```typescript\nfor (let i = 0; i < 10 ; i++) {\n    setTimeout(function() {console.log(i); }, 100 * i);\n}\n```\n\n会输出与预料一致的结果：\n\n```text\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n\n## `const` 声明\n\n`const` 声明是声明变量的另一种方式。\n\n```typescript\nconst numLivesForCat = 9;\n```\n\n它们与`let`声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与`let`相同的作用域规则，但是不能对它们重新赋值。\n\n这很好理解，它们引用的值是_不可变的_。\n\n```typescript\nconst numLivesForCat = 9;\nconst kitty = {\n    name: "Aurora",\n    numLives: numLivesForCat,\n}\n\n// Error\nkitty = {\n    name: "Danielle",\n    numLives: numLivesForCat\n};\n\n// all "okay"\nkitty.name = "Rory";\nkitty.name = "Kitty";\nkitty.name = "Cat";\nkitty.numLives--;\n```\n\n除非你使用特殊的方法去避免，实际上`const`变量的内部状态是可修改的。 幸运的是，TypeScript允许你将对象的成员设置成只读的。 [接口](interfaces.md)一章有详细说明。\n\n## `let` vs. `const`\n\n现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。 与大多数泛泛的问题一样，答案是：依情况而定。\n\n使用[最小特权原则](https://en.wikipedia.org/wiki/Principle_of_least_privilege)，所有变量除了你计划去修改的都应该使用`const`。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。 使用`const`也可以让我们更容易的推测数据的流动。\n\n跟据你的自己判断，如果合适的话，与团队成员商议一下。\n\n这个手册大部分地方都使用了`let`声明。\n\n## 解构\n\nTypeScript 包含的另一个 ECMAScript 2015 特性就是解构。完整列表请参见 [the article on the Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)。 本章，我们将给出一个简短的概述。\n\n### 解构数组\n\n最简单的解构莫过于数组的解构赋值了：\n\n```typescript\nlet input = [1, 2];\nlet [first, second] = input;\nconsole.log(first); // outputs 1\nconsole.log(second); // outputs 2\n```\n\n这创建了2个命名变量 `first` 和 `second`。 相当于使用了索引，但更为方便：\n\n```typescript\nfirst = input[0];\nsecond = input[1];\n```\n\n解构也可以作用于已声明的变量：\n\n```typescript\n// swap variables\n[first, second] = [second, first];\n```\n\n类似地，也可以作用于函数参数：\n\n```typescript\nfunction f([first, second]: [number, number]) {\n    console.log(first);\n    console.log(second);\n}\nf([1, 2]);\n```\n\n你可以在数组里使用`...`语法创建剩余变量：\n\n```typescript\nlet [first, ...rest] = [1, 2, 3, 4];\nconsole.log(first); // outputs 1\nconsole.log(rest); // outputs [ 2, 3, 4 ]\n```\n\n当然，由于是JavaScript, 你可以忽略你不关心的尾随元素：\n\n```typescript\nlet [first] = [1, 2, 3, 4];\nconsole.log(first); // outputs 1\n```\n\n或其它元素：\n\n```typescript\nlet [, second, , fourth] = [1, 2, 3, 4];\nconsole.log(second); // outputs 2\nconsole.log(fourth); // outputs 4\n```\n\n### 解构元组\n\n元组可以像数组一样解构；解构后的变量获得对应元组元素的类型：\n\n```typescript\nlet tuple: [number, string, boolean] = [7, "hello", true];\n\nlet [a, b, c] = tuple; // a: number, b: string, c: boolean\n```\n\n当解构元组时，若超出元组索引范围将报错：\n\n```typescript\nlet [a, b, c, d] = tuple; // 错误，没有索引为3的元素\n```\n\n与数组一样，可以作用`...`来解构元组的剩余元素，从而得到一个短的元组：\n\n```typescript\nlet [a, ...bc] = tuple; // bc: [string, boolean]\nlet [a, b, c, ...d] = tuple; // d: [], the empty tuple\n```\n\n或者，忽略末尾元素或其它元素：\n\n```typescript\nlet [a] = tuple; // a: number\nlet [, b] = tuple; // b: string\n```\n\n### 对象解构\n\n你也可以解构对象：\n\n```typescript\nlet o = {\n    a: "foo",\n    b: 12,\n    c: "bar"\n};\nlet { a, b } = o;\n```\n\n这通过 `o.a` and `o.b` 创建了 `a` 和 `b` 。 注意，如果你不需要 `c` 你可以忽略它。\n\n就像数组解构，你可以用没有声明的赋值：\n\n```typescript\n({ a, b } = { a: "baz", b: 101 });\n```\n\n注意，我们需要用括号将它括起来，因为Javascript通常会将以 `{` 起始的语句解析为一个块。\n\n你可以在对象里使用`...`语法创建剩余变量：\n\n```typescript\nlet { a, ...passthrough } = o;\nlet total = passthrough.b + passthrough.c.length;\n```\n\n#### 属性重命名\n\n你也可以给属性以不同的名字：\n\n```typescript\nlet { a: newName1, b: newName2 } = o;\n```\n\n这里的语法开始变得混乱。 你可以将 `a: newName1` 读做 "`a` 作为 `newName1`"。 方向是从左到右，好像你写成了以下样子：\n\n```typescript\nlet newName1 = o.a;\nlet newName2 = o.b;\n```\n\n令人困惑的是，这里的冒号_不是_指示类型的。 如果你想指定它的类型， 仍然需要在其后写上完整的模式。\n\n```typescript\nlet {a, b}: {a: string, b: number} = o;\n```\n\n#### 默认值\n\n我们可以为属性指定一个默认值，当属性值为`undefined`时，将使用该默认值：\n\n```typescript\nfunction keepWholeObject(wholeObject: { a: string, b?: number }) {\n    let { a, b = 1001 } = wholeObject;\n}\n```\n\n此例中，`b?`表明`b`是可选的，因此它可能为`undefined`。 现在，即使 `b` 为 undefined ， `keepWholeObject` 函数的变量 `wholeObject` 的属性 `a` 和 `b` 都会有值。\n\n### 函数声明\n\n解构也能用于函数声明。 看以下简单的情况：\n\n```typescript\ntype C = { a: string, b?: number }\nfunction f({ a, b }: C): void {\n    // ...\n}\n```\n\n但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。\n\n```typescript\nfunction f({ a="", b=0 } = {}): void {\n    // ...\n}\nf();\n```\n\n> 上面的代码是一个类型推断的例子，将在本手册后文介绍。\n\n其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 `C` 的定义有一个 `b` 可选属性：\n\n```typescript\nfunction f({ a, b = 0 } = { a: "" }): void {\n    // ...\n}\nf({ a: "yes" }); // ok, default b = 0\nf(); // ok, default to {a: ""}, which then defaults b = 0\nf({}); // error, \'a\' is required if you supply an argument\n```\n\n要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。 你自己也可以直接使用解构将会生成的赋值表达式。\n\n### 展开\n\n展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如：\n\n```typescript\nlet first = [1, 2];\nlet second = [3, 4];\nlet bothPlus = [0, ...first, ...second, 5];\n```\n\n这会令`bothPlus`的值为`[0, 1, 2, 3, 4, 5]`。 展开操作创建了`first`和`second`的一份浅拷贝。 它们不会被展开操作所改变。\n\n你还可以展开对象：\n\n```typescript\nlet defaults = { food: "spicy", price: "$$", ambiance: "noisy" };\nlet search = { ...defaults, food: "rich" };\n```\n\n`search`的值为`{ food: "rich", price: "$$", ambiance: "noisy" }`。 对象的展开比数组的展开要复杂的多。 像数组展开一样，它是从左至右进行处理，但结果仍为对象。 这就意味着出现在展开对象后面的属性会覆盖前面的属性。 因此，如果我们修改上面的例子，在结尾处进行展开的话：\n\n```typescript\nlet defaults = { food: "spicy", price: "$$", ambiance: "noisy" };\nlet search = { food: "rich", ...defaults };\n```\n\n那么，`defaults`里的`food`属性会重写`food: "rich"`，在这里这并不是我们想要的结果。\n\n对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 [自身的可枚举属性](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties)。 大体上是说当你展开一个对象实例时，你会丢失其方法：\n\n```typescript\nclass C {\n  p = 12;\n  m() {\n  }\n}\nlet c = new C();\nlet clone = { ...c };\nclone.p; // ok\nclone.m(); // error!\n```\n\n其次，TypeScript编译器不允许展开泛型函数上的类型参数。 这个特性会在TypeScript的未来版本中考虑实现。\n\n',tc={data:function(){return{MainComponent1:Hl,MainComponent2:Fl,MainComponent3:Ul,MainComponent4:ql,MainComponent5:Bl,MainComponent6:Wl,MainComponent7:Vl,MainComponent8:Gl,MainComponent9:zl,MainComponent10:$l,MainComponent11:Xl,MainComponent12:Kl,MainComponent13:Ql,MainComponent14:Yl,MainComponent15:Zl,MainComponent16:nc}}},rc=tc,ec=Object(m["a"])(rc,Jl,Ll,!1,null,"6a0fbfd5",null),ac=ec.exports,oc=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent1}}),r("q-markdown",{attrs:{src:n.MainComponent2}}),r("q-markdown",{attrs:{src:n.MainComponent3}}),r("q-markdown",{attrs:{src:n.MainComponent4}}),r("q-markdown",{attrs:{src:n.MainComponent5}}),r("q-markdown",{attrs:{src:n.MainComponent6}}),r("q-markdown",{attrs:{src:n.MainComponent7}})],1)},sc=[],ic="# global-modifying-module.d.ts\n\n## 修改了全局作用域的模块\n\n对于修改了全局作用域的模块来讲，在导入它们时，会对全局作用域中的值进行修改。\n比如存在某个代码库，当导入它时，它会向`String.prototype`上添加新的成员。\n该模式存在危险，因为它有导致运行时冲突的可能性，\n但我们仍然可以为其编写声明文件。\n\n## 识别出修改了全局作用域的模块\n\n我们可以通过文档来识别修改了全局作用域的模块。\n通常来讲，它们与全局插件类似，但是需要`require`语句来激活。\n\n你可能看到过如下的文档：\n\n```js\n// 'require' call that doesn't use its return value\nvar unused = require('magic-string-time');\n/* or */\nrequire('magic-string-time');\n\nvar x = 'hello, world';\n// Creates new methods on built-in types\nconsole.log(x.startsWithHello());\n\nvar y = [1, 2, 3];\n// Creates new methods on built-in types\nconsole.log(y.reverseAndSort());\n```\n\n以下是一个示例：\n\n```ts\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ This is the global-modifying module template file. You should rename it to index.d.ts\n *~ and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */\n\n/*~ Note: If your global-modifying module is callable or constructable, you'll\n *~ need to combine the patterns here with those in the module-class or module-function\n *~ template files\n */\ndeclare global {\n    /*~ Here, declare things that go in the global namespace, or augment\n     *~ existing declarations in the global namespace\n     */\n    interface String {\n        fancyFormat(opts: StringFormatOptions): string;\n    }\n}\n\n/*~ If your module exports types or values, write them as usual */\nexport interface StringFormatOptions {\n    fancinessLevel: number;\n}\n\n/*~ For example, declaring a method on the module (in addition to its global side effects) */\nexport function doSomething(): void;\n\n/*~ If your module exports nothing, you'll need this line. Otherwise, delete it */\nexport {};\n```\n",lc="# global-plugin.d.ts\n\n## UMD\n\n一个 UMD 模块既可以用作 ES 模块（使用导入语句），也可以用作全局变量（在缺少模块加载器的环境中使用）。\n许多流行的代码库，如[Moment.js](http://momentjs.com/)，都是使用这模式发布的。\n例如，在 Node.js 中或使用了 RequireJS 时，你可以这样使用：\n\n```ts\nimport moment = require('moment');\nconsole.log(moment.format());\n```\n\n在纯浏览器环境中，你可以这样使用：\n\n```js\nconsole.log(moment.format());\n```\n\n### 识别 UMD 代码库\n\n[UMD 模块](https://github.com/umdjs/umd)会检查运行环境中是否存在模块加载器。\n这是一种常见模式，示例如下：\n\n```js\n(function (root, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        define([\"libName\"], factory);\n    } else if (typeof module === \"object\" && module.exports) {\n        module.exports = factory(require(\"libName\"));\n    } else {\n        root.returnExports = factory(root.libName);\n    }\n}(this, function (b) {\n```\n\n如果你看到代码库中存在类如`typeof define`，`typeof window`或`typeof module`的检测代码，尤其是在文件的顶端，那么它大概率是 UMD 代码库。\n\n在 UMD 模块的文档中经常会提供在 Node.js 中结合`require`使用的示例，以及在浏览器中结合`<script>`标签使用的示例。\n\n### UMD 代码库的示例\n\n大多数流行的代码库均提供了 UMD 格式的包。\n例如，[jQuery](https://jquery.com/)，[Moment.js](http://momentjs.com/)和[lodash](https://lodash.com/)等。\n\n### 模版\n\n针对模块，共存在三个模版。它们是：\n\n-   [`module.d.ts`](./templates/module.d.ts.md)\n-   [`module-class.d.ts`](./templates/module-class.d.ts.md)\n-   [`module-function.d.ts`](./templates/module-function.d.ts.md)\n\n若一个模块可以当作函数调用，则使用[`module-function.d.ts`](./templates/module-function.d.ts.md)。\n\n```js\nvar x = require('foo');\n// Note: calling 'x' as a function\nvar y = x(42);\n```\n\n请务必阅读[脚注：\"ES6 对模块调用签名的影响\"](#es6-对模块调用签名的影响)。\n\n如果一个模块可以使用`new`来构造，则使用[`module-class.d.ts`](./templates/module-class.d.ts.md)。\n\n```js\nvar x = require('bar');\n// Note: using 'new' operator on the imported variable\nvar y = new x('hello');\n```\n\n请务必阅读[脚注：\"ES6 对模块调用签名的影响\"](#es6-对模块调用签名的影响)，它同样适用于这类模块。\n\n如果一个模块既不可以调用，又不可以构造，那么就使用[`module.d.ts`](./templates/module.d.ts.md)。\n\n## 模块插件或 UMD 插件\n\n模块插件会改变其它模块的结构（包含 UMD 或 ES 模块）。\n例如，在 Moment.js 中，`moment-range`会将`range`方法添加到`moment`对象上。\n\n对于编写声明文件而言，无论是 ES 模块还是 UMD 模块，你都可以使用相同的代码。\n\n### 模版\n\n使用[`module-plugin.d.ts`](./templates/module-plugin.d.ts.md)模版。\n\n## 全局插件\n\n全局插件是一段全局代码，它会改变某个全局变量。\n对于修改了全局作用域的模块，它会增加出现运行时冲突的可能性。\n\n例如，有些库会向`Array.prototype`或`String.prototype`中增加新的函数。\n\n### 识别全局插件\n\n全局插件通常可以根据其文档来识别。\n\n你会看到如下示例：\n\n```js\nvar x = 'hello, world';\n// Creates new methods on built-in types\nconsole.log(x.startsWithHello());\n\nvar y = [1, 2, 3];\n// Creates new methods on built-in types\nconsole.log(y.reverseAndSort());\n```\n\n### 模版\n\n使用[`global-plugin.d.ts`](./templates/global-plugin.d.ts.md)模版。\n\n## 修改了全局作用域的模块\n\n对于修改了全局作用域的模块来讲，在导入它们时，会对全局作用域中的值进行修改。\n比如存在某个代码库，当导入它时，它会向`String.prototype`上添加新的成员。\n该模式存在危险，因为它有导致运行时冲突的可能性，\n但我们仍然可以为其编写声明文件。\n\n### 识别出修改了全局作用域的模块\n\n我们可以通过文档来识别修改了全局作用域的模块。\n通常来讲，它们与全局插件类似，但是需要`require`语句来激活对全局作用域的修改。\n\n你可能看到过如下的文档：\n\n```js\n// 'require' call that doesn't use its return value\nvar unused = require('magic-string-time');\n/* or */\nrequire('magic-string-time');\n\nvar x = 'hello, world';\n// Creates new methods on built-in types\nconsole.log(x.startsWithHello());\n\nvar y = [1, 2, 3];\n// Creates new methods on built-in types\nconsole.log(y.reverseAndSort());\n```\n\n### 模版\n\n使用[`global-modifying-module.d.ts`](./templates/global-modifying-module.d.ts.md)模版。\n\n## 利用依赖\n\n你的代码库可能会有若干种依赖。\n本节会介绍如何在声明文件中导入它们。\n\n### 对全局库的依赖\n\n如果你的代码库依赖于某个全局代码库，则使用`/// <reference types=\"...\" />`指令：\n\n```ts\n/// <reference types=\"someLib\" />\n\nfunction getThing(): someLib.thing;\n```\n\n### 对模块的依赖\n\n如果你的代码库依赖于某个模块，则使用`import`语句：\n\n```ts\nimport * as moment from 'moment';\n\nfunction getThing(): moment;\n```\n\n### 对 UMD 模块的依赖\n\n#### 全局代码库\n\n如果你的全局代码库依赖于某个 UMD 模块，则使用`/// <reference types`指令：\n\n```ts\n/// <reference types=\"moment\" />\n\nfunction getThing(): moment;\n```\n\n#### ES 模块或 UMD 模块代码库\n\n如果你的模块或 UMD 代码库依赖于某个 UMD 代码库，则使用`import`语句：\n\n```ts\nimport * as someLib from 'someLib';\n```\n\n不要使用`/// <reference`指令来声明对 UMD 代码库的依赖。\n\n## 脚注\n\n### 防止命名冲突\n\n注意，虽说可以在全局作用域内定义许多类型。\n但我们强烈建议不要这样做，因为当一个工程中存在多个声明文件时，它可能会导致难以解决的命名冲突。\n\n可以遵循的一个简单规则是使用代码库提供的某个全局变量来声明拥有命名空间的类型。\n例如，如果代码库提供了全局变量`cats`，那么可以这样写：\n\n```ts\ndeclare namespace cats {\n    interface KittySettings {}\n}\n```\n\n而不是：\n\n```ts\n// at top-level\ninterface CatsKittySettings {}\n```\n\n这样做会保证代码库可以被转换成 UMD 模块，且不会影响声明文件的使用者。\n\n### ES6 对模块插件的影响\n\n一些插件会对已有模块的顶层导出进行添加或修改。\n这在 CommonJS 以及其它模块加载器里是合法的，但 ES6 模块是不可改变的，因此该模式是不可行的。\n因为，TypeScript 是模块加载器无关的，所以在编译时不会对该行为加以限制，但是开发者若想要转换到 ES6 模块加载器则需要注意这一点。\n\n### ES6 对模块调用签名的影响\n\n许多代码库，如 Express，将自身导出为可调用的函数。\n例如，Express 的典型用法如下：\n\n```ts\nimport exp = require('express');\nvar app = exp();\n```\n\n在 ES6 模块加载器中，顶层对象（此例中就`exp`）只能拥有属性；\n顶层的模块对象永远不能够被调用。\n最常见的解决方案是为可调用的/可构造的对象定义一个`default`导出；\n有些模块加载器会自动检测这种情况并且将顶层对象替换为`default`导出。\n\n## 代码库文件结构\n\n声明文件的结构应该反映代码库源码的结构。\n\n一个代码库可以包含多个模块，比如：\n\n```\nmyLib\n  +---- index.js\n  +---- foo.js\n  +---- bar\n         +---- index.js\n         +---- baz.js\n```\n\n它们可以通过如下方式导入：\n\n```js\nvar a = require('myLib');\nvar b = require('myLib/foo');\nvar c = require('myLib/bar');\nvar d = require('myLib/bar/baz');\n```\n\n声明文件如下：\n\n```\n@types/myLib\n  +---- index.d.ts\n  +---- foo.d.ts\n  +---- bar\n         +---- index.d.ts\n         +---- baz.d.ts\n```\n\n```ts\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ This template shows how to write a global plugin. */\n\n/*~ Write a declaration for the original type and add new members.\n *~ For example, this adds a 'toBinaryString' method with overloads to\n *~ the built-in number type.\n */\ninterface Number {\n    toBinaryString(opts?: MyLibrary.BinaryFormatOptions): string;\n\n    toBinaryString(\n        callback: MyLibrary.BinaryFormatCallback,\n        opts?: MyLibrary.BinaryFormatOptions\n    ): string;\n}\n\n/*~ If you need to declare several types, place them inside a namespace\n *~ to avoid adding too many things to the global namespace.\n */\ndeclare namespace MyLibrary {\n    type BinaryFormatCallback = (n: number) => string;\n    interface BinaryFormatOptions {\n        prefix?: string;\n        padding: number;\n    }\n}\n```\n",cc="## 全局代码库\n\n全局代码库可以通过全局作用域来访问（例如，不使用任何形式的`import`语句）。\n许多代码库只是简单地导出一个或多个供使用的全局变量。\n比如，如果你使用[jQuery](https://jquery.com/)，那么可以使用`$`变量来引用它。\n\n```ts\n$(() => {\n    console.log('hello!');\n});\n```\n\n你通常能够在文档里看到如何在 HTML 的 script 标签里引用代码库：\n\n```html\n<script src=\"http://a.great.cdn.for/someLib.js\"><\/script>\n```\n\n目前，大多数流行的全局代码库都以 UMD 代码库发布。\nUMD 代码库与全局代码库很难通过文档来识别。\n在编写全局代码库的声明文件之前，确保代码库不是 UMD 代码库。\n\n## 从代码来识别全局代码库\n\n通常，全局代码库的代码十分简单。\n一个全局的“Hello, world”代码库可以如下：\n\n```js\nfunction createGreeting(s) {\n    return 'Hello, ' + s;\n}\n```\n\n或者这样：\n\n```js\nwindow.createGreeting = function (s) {\n    return 'Hello, ' + s;\n};\n```\n\n在阅读全局代码库的代码时，你会看到：\n\n-   顶层的`var`语句或`function`声明\n-   一个或多个`window.someName`赋值语句\n-   假设 DOM 相关的原始值`document`或`window`存在\n\n你不会看到：\n\n-   检查或使用了模块加载器，如`require`或`define`\n-   CommonJS/Node.js 风格的导入语句，如`var fs = require(\"fs\");`\n-   `define(...)`调用\n-   描述`require`或导入代码库的文档\n\n## 全局代码库的示例\n\n由于将全局代码库转换为 UMD 代码库十分容易，因此很少有代码库仍然使用全局代码库风格。\n然而，小型的代码库以及需要使用 DOM 的代码库仍然可以是全局的。\n\n## 全局代码库模版\n\n你可以看到如下声明文件的示例：\n\n```ts\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ If this library is callable (e.g. can be invoked as myLib(3)),\n *~ include those call signatures here.\n *~ Otherwise, delete this section.\n */\ndeclare function myLib(a: string): string;\ndeclare function myLib(a: number): number;\n\n/*~ If you want the name of this library to be a valid type name,\n *~ you can do so here.\n *~\n *~ For example, this allows us to write 'var x: myLib';\n *~ Be sure this actually makes sense! If it doesn't, just\n *~ delete this declaration and add types inside the namespace below.\n */\ninterface myLib {\n    name: string;\n    length: number;\n    extras?: string[];\n}\n\n/*~ If your library has properties exposed on a global variable,\n *~ place them here.\n *~ You should also place types (interfaces and type alias) here.\n */\ndeclare namespace myLib {\n    //~ We can write 'myLib.timeout = 50;'\n    let timeout: number;\n\n    //~ We can access 'myLib.version', but not change it\n    const version: string;\n\n    //~ There's some class we can create via 'let c = new myLib.Cat(42)'\n    //~ Or reference e.g. 'function f(c: myLib.Cat) { ... }\n    class Cat {\n        constructor(n: number);\n\n        //~ We can read 'c.age' from a 'Cat' instance\n        readonly age: number;\n\n        //~ We can invoke 'c.purr()' from a 'Cat' instance\n        purr(): void;\n    }\n\n    //~ We can declare a variable as\n    //~   'var s: myLib.CatSettings = { weight: 5, name: \"Maru\" };'\n    interface CatSettings {\n        weight: number;\n        name: string;\n        tailLength?: number;\n    }\n\n    //~ We can write 'const v: myLib.VetID = 42;'\n    //~  or 'const v: myLib.VetID = \"bob\";'\n    type VetID = string | number;\n\n    //~ We can invoke 'myLib.checkCat(c)' or 'myLib.checkCat(c, v);'\n    function checkCat(c: Cat, s?: VetID);\n}\n```\n",pc="\x3c!--\nTODO:\n\n1. Not clear why UMD is thrown in here.\n2. Give both commonjs and ES module examples.\n--\x3e\n\n示例，当你想要处理如下的 JavaScriptr 的代码时：\n\n```ts\nconst Greeter = require('super-greeter');\n\nconst greeter = new Greeter();\ngreeter.greet();\n```\n\n能够同时处理UMD导入和模块导入：\n\n```ts\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ This is the module template file for class modules.\n *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */\n\n// Note that ES6 modules cannot directly export class objects.\n// This file should be imported using the CommonJS-style:\n//   import x = require('[~THE MODULE~]');\n//\n// Alternatively, if --allowSyntheticDefaultImports or\n// --esModuleInterop is turned on, this file can also be\n// imported as a default import:\n//   import x from '[~THE MODULE~]';\n//\n// Refer to the TypeScript documentation at\n// https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require\n// to understand common workarounds for this limitation of ES6 modules.\n\n/*~ If this module is a UMD module that exposes a global variable 'myClassLib' when\n *~ loaded outside a module loader environment, declare that global here.\n *~ Otherwise, delete this declaration.\n */\nexport as namespace myClassLib;\n\n/*~ This declaration specifies that the class constructor function\n *~ is the exported object from the file\n */\nexport = MyClass;\n\n/*~ Write your module's methods and properties in this class */\ndeclare class MyClass {\n    constructor(customGreeting?: string);\n\n    greet: void;\n\n    myMethod(opts: MyClass.MyClassMethodOptions): number;\n}\n\n/*~ If you want to expose types from your module as well, you can\n *~ place them in this block.\n *~\n *~ Note that if you decide to include this namespace, the module can be\n *~ incorrectly imported as a namespace object, unless\n *~ --esModuleInterop is turned on:\n *~   import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS!\n */\ndeclare namespace MyClass {\n    export interface MyClassMethodOptions {\n        width?: number;\n        height?: number;\n    }\n}\n```\n",uc="```ts\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ This is the module template file for function modules.\n *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */\n\n// Note that ES6 modules cannot directly export class objects.\n// This file should be imported using the CommonJS-style:\n//   import x = require('[~THE MODULE~]');\n//\n// Alternatively, if --allowSyntheticDefaultImports or\n// --esModuleInterop is turned on, this file can also be\n// imported as a default import:\n//   import x from '[~THE MODULE~]';\n//\n// Refer to the TypeScript documentation at\n// https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require\n// to understand common workarounds for this limitation of ES6 modules.\n\n/*~ If this module is a UMD module that exposes a global variable 'myFuncLib' when\n *~ loaded outside a module loader environment, declare that global here.\n *~ Otherwise, delete this declaration.\n */\nexport as namespace myFuncLib;\n\n/*~ This declaration specifies that the function\n *~ is the exported object from the file\n */\nexport = MyFunction;\n\n/*~ This example shows how to have multiple overloads for your function */\ndeclare function MyFunction(name: string): MyFunction.NamedReturnType;\ndeclare function MyFunction(length: number): MyFunction.LengthReturnType;\n\n/*~ If you want to expose types from your module as well, you can\n *~ place them in this block. Often you will want to describe the\n *~ shape of the return type of the function; that type should\n *~ be declared in here, as this example shows.\n *~\n *~ Note that if you decide to include this namespace, the module can be\n *~ incorrectly imported as a namespace object, unless\n *~ --esModuleInterop is turned on:\n *~   import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS!\n */\ndeclare namespace MyFunction {\n    export interface LengthReturnType {\n        width: number;\n        height: number;\n    }\n    export interface NamedReturnType {\n        firstName: string;\n        lastName: string;\n    }\n\n    /*~ If the module also has properties, declare them here. For example,\n     *~ this declaration says that this code is legal:\n     *~   import f = require('myFuncLibrary');\n     *~   console.log(f.defaultName);\n     */\n    export const defaultName: string;\n    export let defaultLength: number;\n}\n```\n",mc="```ts\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ This is the module plugin template file. You should rename it to index.d.ts\n *~ and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */\n\n/*~ On this line, import the module which this module adds to */\nimport * as m from 'someModule';\n\n/*~ You can also import other modules if needed */\nimport * as other from 'anotherModule';\n\n/*~ Here, declare the same module as the one you imported above */\ndeclare module 'someModule' {\n    /*~ Inside, add new function, classes, or variables. You can use\n     *~ unexported types from the original module if needed. */\n    export function theNewMethod(x: m.foo): other.bar;\n\n    /*~ You can also add new properties to existing interfaces from\n     *~ the original module by writing interface augmentations */\n    export interface SomeModuleOptions {\n        someModuleSetting?: string;\n    }\n\n    /*~ New types can also be declared and will appear as if they\n     *~ are in the original module */\n    export interface MyModulePluginOptions {\n        size: number;\n    }\n}\n```",dc="```ts\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ This is the module template file. You should rename it to index.d.ts\n *~ and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */\n\n/*~ If this module is a UMD module that exposes a global variable 'myLib' when\n *~ loaded outside a module loader environment, declare that global here.\n *~ Otherwise, delete this declaration.\n */\nexport as namespace myLib;\n\n/*~ If this module has methods, declare them as functions like so.\n */\nexport function myMethod(a: string): string;\nexport function myOtherMethod(a: number): number;\n\n/*~ You can declare types that are available via importing the module */\nexport interface someType {\n    name: string;\n    length: number;\n    extras?: string[];\n}\n\n/*~ You can declare properties of the module using const, let, or var */\nexport const myField: number;\n\n/*~ If there are types, properties, or methods inside dotted names\n *~ of the module, declare them inside a 'namespace'.\n */\nexport namespace subProp {\n    /*~ For example, given this definition, someone could write:\n     *~   import { subProp } from 'yourModule';\n     *~   subProp.foo();\n     *~ or\n     *~   import * as yourMod from 'yourModule';\n     *~   yourMod.subProp.foo();\n     */\n    export function foo(): void;\n}\n```",gc={data:function(){return{MainComponent1:ic,MainComponent2:lc,MainComponent3:cc,MainComponent4:pc,MainComponent5:uc,MainComponent6:mc,MainComponent7:dc}}},bc=gc,hc=Object(m["a"])(bc,oc,sc,!1,null,"84c7327c",null),yc=hc.exports,fc=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{},[r("q-markdown",{attrs:{src:n.MainComponent1}}),r("q-markdown",{attrs:{src:n.MainComponent2}})],1)},vc=[],Sc="# 模版字面量类型\n\n> 从 TypeScript 4.1 开始支持\n\n模版字面量类型以[字符串字面量类型](../../handbook/literal-types.md)为基础，且可以展开为多个字符串类型的联合类型。\n\n其语法与 [JavaScript 中的模版字面量](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)是一致的，但是是用在类型的位置上。\n当与某个具体的字面量类型一起使用时，模版字面量会将文本连接从而生成一个新的字符串字面量类型。\n\n```ts\ntype World = 'world';\n\ntype Greeting = `hello ${World}`;\n//   'hello world'\n```\n\n如果在替换字符串的位置是联合类型，那么结果类型是由每个联合类型成员构成的字符串字面量的集合：\n\n```ts\ntype EmailLocaleIDs = 'welcome_email' | 'email_heading';\ntype FooterLocaleIDs = 'footer_title' | 'footer_sendoff';\n\ntype AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;\n// \"welcome_email_id\" | \"email_heading_id\" | \"footer_title_id\" | \"footer_sendoff_id\"\n```\n\n多个替换字符串的位置上的多个联合类型会进行交叉相乘：\n\n```ts\ntype EmailLocaleIDs = 'welcome_email' | 'email_heading';\ntype FooterLocaleIDs = 'footer_title' | 'footer_sendoff';\n\ntype AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;\ntype Lang = 'en' | 'ja' | 'pt';\n\ntype LocaleMessageIDs = `${Lang}_${AllLocaleIDs}`;\n//   type EmailLocaleIDs = \"welcome_email\" | \"email_heading\";\ntype FooterLocaleIDs = 'footer_title' | 'footer_sendoff';\n\ntype AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;\ntype Lang = 'en' | 'ja' | 'pt';\n\ntype LocaleMessageIDs = `${Lang}_${AllLocaleIDs}`;\n//   \"en_welcome_email_id\" | \"en_email_heading_id\" | \"en_footer_title_id\" | \"en_footer_sendoff_id\" | \"ja_welcome_email_id\" | \"ja_email_heading_id\" | \"ja_footer_title_id\" | \"ja_footer_sendoff_id\" | \"pt_welcome_email_id\" | \"pt_email_heading_id\" | \"pt_footer_title_id\" | \"pt_footer_sendoff_id\"\n```\n\n我们还是建议开发者要提前生成数量巨大的字符串联合类型，但如果数量较少，那么上面介绍的方法会有所帮助。\n\n### 类型中的字符串联合类型\n\n模版字面量的强大之处在于它能够基于给定的字符串来创建新的字符串。\n\n例如，JavaScript 中有一个常见的模式是基于对象的现有属性来扩展它。\n下面我们定义一个函数类型`on`，它用于监听值的变化。\n\n```ts\ndeclare function makeWatchedObject(obj: any): any;\n\nconst person = makeWatchedObject({\n    firstName: 'Saoirse',\n    lastName: 'Ronan',\n    age: 26,\n});\n\nperson.on('firstNameChanged', (newValue) => {\n    console.log(`firstName was changed to ${newValue}!`);\n});\n```\n\n注意，`on`会监听`\"firstNameChanged\"`事件，而不是`\"firstName\"`。\n模版字面量提供了操作字符串类型的能力：\n\n```ts\ntype PropEventSource<Type> = {\n    on(\n        eventName: `${string & keyof Type}Changed`,\n        callback: (newValue: any) => void\n    ): void;\n};\n\n/// Create a \"watched object\" with an 'on' method\n/// so that you can watch for changes to properties.\ndeclare function makeWatchedObject<Type>(\n    obj: Type\n): Type & PropEventSource<Type>;\n```\n\n这样做之后，当传入了错误的属性名会产生一个错误：\n\n```ts\ntype PropEventSource<Type> = {\n    on(\n        eventName: `${string & keyof Type}Changed`,\n        callback: (newValue: any) => void\n    ): void;\n};\n\ndeclare function makeWatchedObject<T>(obj: T): T & PropEventSource<T>;\n\nconst person = makeWatchedObject({\n    firstName: 'Saoirse',\n    lastName: 'Ronan',\n    age: 26,\n});\n\nperson.on('firstNameChanged', () => {});\n\n// 以下存在拼写错误\nperson.on('firstName', () => {});\nperson.on('frstNameChanged', () => {});\n```\n\n### 模版字面量类型推断\n\n注意，上例中没有使用原属性值的类型，在回调函数中仍使用`any`类型。\n模版字面量类型能够从替换字符串的位置推断出类型。\n\n下面，我们将上例修改成泛型，它会从`eventName`字符串来推断出属性名。\n\n```ts\ntype PropEventSource<Type> = {\n    on<Key extends string & keyof Type>(\n        eventName: `${Key}Changed`,\n        callback: (newValue: Type[Key]) => void\n    ): void;\n};\n\ndeclare function makeWatchedObject<Type>(\n    obj: Type\n): Type & PropEventSource<Type>;\n\nconst person = makeWatchedObject({\n    firstName: 'Saoirse',\n    lastName: 'Ronan',\n    age: 26,\n});\n\nperson.on('firstNameChanged', (newName) => {\n    //                        string\n    console.log(`new name is ${newName.toUpperCase()}`);\n});\n\nperson.on('ageChanged', (newAge) => {\n    //                  number\n    if (newAge < 0) {\n        console.warn('warning! negative age');\n    }\n});\n```\n\n这里，我们将`on`改为泛型方法。\n\n当用户使用字符串`\"firstNameChanged'`来调用时，TypeScript 会尝试推断`K`的类型。\n为此，TypeScript 尝试将`Key`与`\"Changed\"`之前的部分进行匹配，并且推断出字符串`\"firstName\"`。\n当 TypeScript 推断出了类型后，`on`方法就能够获取`firstName`属性的类型，即`string`类型。\n相似的，当使用`\"ageChanged\"`调用时，TypeScript 能够知道`age`属性的类型是`number`。\n\n类型推断可以以多种方式组合，例如拆解字符串然后以其它方式重新构造字符串。\n\n## 操作固有字符串的类型\n\n为了方便字符串操作，TypeScript 提供了一系列操作字符串的类型。\n这些类型内置于编译器之中，以便提高性能。\n它们不存在于 TypeScript 提供的`.d.ts`文件中。\n\n### `Uppercase<StringType>`\n\n将字符串中的每个字符转换为大写字母。\n\n##### Example\n\n```ts\ntype Greeting = 'Hello, world';\ntype ShoutyGreeting = Uppercase<Greeting>;\n//   \"HELLO, WORLD\"\n\ntype ASCIICacheKey<Str extends string> = `ID-${Uppercase<Str>}`;\ntype MainID = ASCIICacheKey<'my_app'>;\n//   \"ID-MY_APP\"\n```\n\n### `Lowercase<StringType>`\n\n将字符串中的每个字符转换为小写字母。\n\n```ts\ntype Greeting = 'Hello, world';\ntype QuietGreeting = Lowercase<Greeting>;\n//   \"hello, world\"\n\ntype ASCIICacheKey<Str extends string> = `id-${Lowercase<Str>}`;\ntype MainID = ASCIICacheKey<'MY_APP'>;\n//   \"id-my_app\"\n```\n\n### `Capitalize<StringType>`\n\n将字符串中的首字母转换为大写字母。\n\n##### Example\n\n```ts\ntype LowercaseGreeting = 'hello, world';\ntype Greeting = Capitalize<LowercaseGreeting>;\n//   \"Hello, world\"\n```\n\n### `Uncapitalize<StringType>`\n\n将字符串中的首字母转换为小写字母。\n\n##### Example\n\n```ts twoslash\ntype UppercaseGreeting = 'HELLO WORLD';\ntype UncomfortableGreeting = Uncapitalize<UppercaseGreeting>;\n//   \"hELLO WORLD\"\n```\n\n<details>\n    <summary>固有字符串操作类型的技术细节</summary>\n    <p>在TypeScript 4.1中会直接使用JavaScript中的字符串操作函数来操作固有字符串，且不会考虑本地化字符。</p>\n    <code><pre>\nfunction applyStringMapping(symbol: Symbol, str: string) {\n    switch (intrinsicTypeKinds.get(symbol.escapedName as string)) {\n        case IntrinsicTypeKind.Uppercase: return str.toUpperCase();\n        case IntrinsicTypeKind.Lowercase: return str.toLowerCase();\n        case IntrinsicTypeKind.Capitalize: return str.charAt(0).toUpperCase() + str.slice(1);\n        case IntrinsicTypeKind.Uncapitalize: return str.charAt(0).toLowerCase() + str.slice(1);\n    }\n    return str;\n}</pre></code>\n</details>\n",_c='# JavaScript文件里的类型检查\n\nTypeScript 2.3以后的版本支持使用`--checkJs`对`.js`文件进行类型检查和错误提示。\n\n你可以通过添加`// @ts-nocheck`注释来忽略类型检查；相反，你可以通过去掉`--checkJs`设置并添加一个`// @ts-check`注释来选则检查某些`.js`文件。 你还可以使用`// @ts-ignore`来忽略本行的错误。 如果你使用了`tsconfig.json`，JS检查将遵照一些严格检查标记，如`noImplicitAny`，`strictNullChecks`等。 但因为JS检查是相对宽松的，在使用严格标记时可能会有些出乎意料的情况。\n\n对比`.js`文件和`.ts`文件在类型检查上的差异，有如下几点需要注意：\n\n### 用JSDoc类型表示类型信息\n\n`.js`文件里，类型可以和在`.ts`文件里一样被推断出来。 同样地，当类型不能被推断时，它们可以通过JSDoc来指定，就好比在`.ts`文件里那样。 如同TypeScript，`--noImplicitAny`会在编译器无法推断类型的位置报错。 （除了对象字面量的情况；后面会详细介绍）\n\nJSDoc注解修饰的声明会被设置为这个声明的类型。比如：\n\n```javascript\n/** @type {number} */\nvar x;\n\nx = 0;      // OK\nx = false;  // Error: boolean is not assignable to number\n```\n\n你可以在这里找到所有JSDoc支持的模式，[JSDoc文档](type-checking-javascript-files.md#supported-jsdoc)。\n\n### 属性的推断来自于类内的赋值语句\n\nES2015没提供声明类属性的方法。属性是动态赋值的，就像对象字面量一样。\n\n在`.js`文件里，编译器从类内部的属性赋值语句来推断属性类型。 属性的类型是在构造函数里赋的值的类型，除非它没在构造函数里定义或者在构造函数里是`undefined`或`null`。 若是这种情况，类型将会是所有赋的值的类型的联合类型。 在构造函数里定义的属性会被认为是一直存在的，然而那些在方法，存取器里定义的属性被当成可选的。\n\n```javascript\nclass C {\n    constructor() {\n        this.constructorOnly = 0\n        this.constructorUnknown = undefined\n    }\n    method() {\n        this.constructorOnly = false // error, constructorOnly is a number\n        this.constructorUnknown = "plunkbat" // ok, constructorUnknown is string | undefined\n        this.methodOnly = \'ok\'  // ok, but methodOnly could also be undefined\n    }\n    method2() {\n        this.methodOnly = true  // also, ok, methodOnly\'s type is string | boolean | undefined\n    }\n}\n```\n\n如果一个属性从没在类内设置过，它们会被当成未知的。\n\n如果类的属性只是读取用的，那么就在构造函数里用JSDoc声明它的类型。 如果它稍后会被初始化，你甚至都不需要在构造函数里给它赋值：\n\n```javascript\nclass C {\n    constructor() {\n        /** @type {number | undefined} */\n        this.prop = undefined;\n        /** @type {number | undefined} */\n        this.count;\n    }\n}\n\nlet c = new C();\nc.prop = 0;          // OK\nc.count = "string";  // Error: string is not assignable to number|undefined\n```\n\n### 构造函数等同于类\n\nES2015以前，Javascript使用构造函数代替类。 编译器支持这种模式并能够将构造函数识别为ES2015的类。 属性类型推断机制和上面介绍的一致。\n\n```javascript\nfunction C() {\n    this.constructorOnly = 0\n    this.constructorUnknown = undefined\n}\nC.prototype.method = function() {\n    this.constructorOnly = false // error\n    this.constructorUnknown = "plunkbat" // OK, the type is string | undefined\n}\n```\n\n### 支持CommonJS模块\n\n在`.js`文件里，TypeScript能识别出CommonJS模块。 对`exports`和`module.exports`的赋值被识别为导出声明。 相似地，`require`函数调用被识别为模块导入。例如：\n\n```javascript\n// same as `import module "fs"`\nconst fs = require("fs");\n\n// same as `export function readFile`\nmodule.exports.readFile = function(f) {\n  return fs.readFileSync(f);\n}\n```\n\n对JavaScript文件里模块语法的支持比在TypeScript里宽泛多了。 大部分的赋值和声明方式都是允许的。\n\n### 类，函数和对象字面量是命名空间\n\n`.js`文件里的类是命名空间。 它可以用于嵌套类，比如：\n\n```javascript\nclass C {\n}\nC.D = class {\n}\n```\n\nES2015之前的代码，它可以用来模拟静态方法：\n\n```javascript\nfunction Outer() {\n  this.y = 2\n}\nOuter.Inner = function() {\n  this.yy = 2\n}\n```\n\n它还可以用于创建简单的命名空间：\n\n```javascript\nvar ns = {}\nns.C = class {\n}\nns.func = function() {\n}\n```\n\n同时还支持其它的变化：\n\n```javascript\n// 立即调用的函数表达式\nvar ns = (function (n) {\n  return n || {};\n})();\nns.CONST = 1\n\n// defaulting to global\nvar assign = assign || function() {\n  // code goes here\n}\nassign.extra = 1\n```\n\n### 对象字面量是开放的\n\n`.ts`文件里，用对象字面量初始化一个变量的同时也给它声明了类型。 新的成员不能再被添加到对象字面量中。 这个规则在`.js`文件里被放宽了；对象字面量具有开放的类型，允许添加并访问原先没有定义的属性。例如：\n\n```javascript\nvar obj = { a: 1 };\nobj.b = 2;  // Allowed\n```\n\n对象字面量的表现就好比具有一个默认的索引签名`[x:string]: any`，它们可以被当成开放的映射而不是封闭的对象。\n\n与其它JS检查行为相似，这种行为可以通过指定JSDoc类型来改变，例如：\n\n```javascript\n/** @type {{a: number}} */\nvar obj = { a: 1 };\nobj.b = 2;  // Error, type {a: number} does not have property b\n```\n\n### null，undefined，和空数组的类型是any或any\\[\\]\n\n任何用`null`，`undefined`初始化的变量，参数或属性，它们的类型是`any`，就算是在严格`null`检查模式下。 任何用`[]`初始化的变量，参数或属性，它们的类型是`any[]`，就算是在严格`null`检查模式下。 唯一的例外是像上面那样有多个初始化器的属性。\n\n```javascript\nfunction Foo(i = null) {\n    if (!i) i = 1;\n    var j = undefined;\n    j = 2;\n    this.l = [];\n}\nvar foo = new Foo();\nfoo.l.push(foo.i);\nfoo.l.push("end");\n```\n\n### 函数参数是默认可选的\n\n由于在ES2015之前无法指定可选参数，因此`.js`文件里所有函数参数都被当做是可选的。 使用比预期少的参数调用函数是允许的。\n\n需要注意的一点是，使用过多的参数调用函数会得到一个错误。\n\n例如：\n\n```javascript\nfunction bar(a, b) {\n  console.log(a + " " + b);\n}\n\nbar(1);       // OK, second argument considered optional\nbar(1, 2);\nbar(1, 2, 3); // Error, too many arguments\n```\n\n使用JSDoc注解的函数会被从这条规则里移除。 使用JSDoc可选参数语法来表示可选性。比如：\n\n```javascript\n/**\n * @param {string} [somebody] - Somebody\'s name.\n */\nfunction sayHello(somebody) {\n    if (!somebody) {\n        somebody = \'John Doe\';\n    }\n    console.log(\'Hello \' + somebody);\n}\n\nsayHello();\n```\n\n### 由`arguments`推断出的var-args参数声明\n\n如果一个函数的函数体内有对`arguments`的引用，那么这个函数会隐式地被认为具有一个var-arg参数（比如:`(...arg: any[]) => any`\\)）。使用JSDoc的var-arg语法来指定`arguments`的类型。\n\n```javascript\n/** @param {...number} args */\nfunction sum(/* numbers */) {\n    var total = 0\n    for (var i = 0; i < arguments.length; i++) {\n      total += arguments[i]\n    }\n    return total\n}\n```\n\n### 未指定的类型参数默认为`any`\n\n由于JavaScript里没有一种自然的语法来指定泛型参数，因此未指定的参数类型默认为`any`。\n\n#### 在extends语句中：\n\n例如，`React.Component`被定义成具有两个类型参数，`Props`和`State`。 在一个`.js`文件里，没有一个合法的方式在extends语句里指定它们。默认地参数类型为`any`：\n\n```javascript\nimport { Component } from "react";\n\nclass MyComponent extends Component {\n    render() {\n        this.props.b; // Allowed, since this.props is of type any\n    }\n}\n```\n\n使用JSDoc的`@augments`来明确地指定类型。例如：\n\n```javascript\nimport { Component } from "react";\n\n/**\n * @augments {Component<{a: number}, State>}\n */\nclass MyComponent extends Component {\n    render() {\n        this.props.b; // Error: b does not exist on {a:number}\n    }\n}\n```\n\n#### 在JSDoc引用中：\n\nJSDoc里未指定的类型参数默认为`any`：\n\n```javascript\n/** @type{Array} */\nvar x = [];\n\nx.push(1);        // OK\nx.push("string"); // OK, x is of type Array<any>\n\n/** @type{Array.<number>} */\nvar y = [];\n\ny.push(1);        // OK\ny.push("string"); // Error, string is not assignable to number\n```\n\n#### 在函数调用中\n\n泛型函数的调用使用`arguments`来推断泛型参数。有时候，这个流程不能够推断出类型，大多是因为缺少推断的源；在这种情况下，类型参数类型默认为`any`。例如：\n\n```javascript\nvar p = new Promise((resolve, reject) => { reject() });\n\np; // Promise<any>;\n```\n\n## 支持的JSDoc <a id="supported-jsdoc"></a>\n\n下面的列表列出了当前所支持的JSDoc注解，你可以用它们在JavaScript文件里添加类型信息。\n\n注意，没有在下面列出的标记（例如`@async`）都是还不支持的。\n\n* `@type`\n* `@param` \\(or `@arg` or `@argument`\\)\n* `@returns` \\(or `@return`\\)\n* `@typedef`\n* `@callback`\n* `@template`\n* `@class` \\(or `@constructor`\\)\n* `@this`\n* `@extends` \\(or `@augments`\\)\n* `@enum`\n\n它们代表的意义与usejsdoc.org上面给出的通常是一致的或者是它的超集。 下面的代码描述了它们的区别并给出了一些示例。\n\n### `@type`\n\n可以使用`@type`标记并引用一个类型名称（原始类型，TypeScript里声明的类型，或在JSDoc里`@typedef`标记指定的） 可以使用任何TypeScript类型和大多数JSDoc类型。\n\n```javascript\n/**\n * @type {string}\n */\nvar s;\n\n/** @type {Window} */\nvar win;\n\n/** @type {PromiseLike<string>} */\nvar promisedString;\n\n// You can specify an HTML Element with DOM properties\n/** @type {HTMLElement} */\nvar myElement = document.querySelector(selector);\nelement.dataset.myData = \'\';\n```\n\n`@type`可以指定联合类型—例如，`string`和`boolean`类型的联合。\n\n```javascript\n/**\n * @type {(string | boolean)}\n */\nvar sb;\n```\n\n注意，括号是可选的。\n\n```javascript\n/**\n * @type {string | boolean}\n */\nvar sb;\n```\n\n有多种方式来指定数组类型：\n\n```javascript\n/** @type {number[]} */\nvar ns;\n/** @type {Array.<number>} */\nvar nds;\n/** @type {Array<number>} */\nvar nas;\n```\n\n还可以指定对象字面量类型。 例如，一个带有`a`（字符串）和`b`（数字）属性的对象，使用下面的语法：\n\n```javascript\n/** @type {{ a: string, b: number }} */\nvar var9;\n```\n\n可以使用字符串和数字索引签名来指定`map-like`和`array-like`的对象，使用标准的JSDoc语法或者TypeScript语法。\n\n```javascript\n/**\n * A map-like object that maps arbitrary `string` properties to `number`s.\n *\n * @type {Object.<string, number>}\n */\nvar stringToNumber;\n\n/** @type {Object.<number, object>} */\nvar arrayLike;\n```\n\n这两个类型与TypeScript里的`{ [x: string]: number }`和`{ [x: number]: any }`是等同的。编译器能识别出这两种语法。\n\n可以使用TypeScript或Closure语法指定函数类型。\n\n```javascript\n/** @type {function(string, boolean): number} Closure syntax */\nvar sbn;\n/** @type {(s: string, b: boolean) => number} Typescript syntax */\nvar sbn2;\n```\n\n或者直接使用未指定的`Function`类型：\n\n```javascript\n/** @type {Function} */\nvar fn7;\n/** @type {function} */\nvar fn6;\n```\n\nClosure的其它类型也可以使用：\n\n```javascript\n/**\n * @type {*} - can be \'any\' type\n */\nvar star;\n/**\n * @type {?} - unknown type (same as \'any\')\n */\nvar question;\n```\n\n#### 转换\n\nTypeScript借鉴了Closure里的转换语法。 在括号表达式前面使用`@type`标记，可以将一种类型转换成另一种类型\n\n```javascript\n/**\n * @type {number | string}\n */\nvar numberOrString = Math.random() < 0.5 ? "hello" : 100;\nvar typeAssertedNumber = /** @type {number} */ (numberOrString)\n```\n\n#### 导入类型\n\n可以使用导入类型从其它文件中导入声明。 这个语法是TypeScript特有的，与JSDoc标准不同：\n\n```javascript\n/**\n * @param p { import("./a").Pet }\n */\nfunction walk(p) {\n    console.log(`Walking ${p.name}...`);\n}\n```\n\n导入类型也可以使用在类型别名声明中：\n\n```javascript\n/**\n * @typedef { import("./a").Pet } Pet\n */\n\n/**\n * @type {Pet}\n */\nvar myPet;\nmyPet.name;\n```\n\n导入类型可以用在从模块中得到一个值的类型。\n\n```javascript\n/**\n * @type {typeof import("./a").x }\n */\nvar x = require("./a").x;\n```\n\n### `@param`和`@returns`\n\n`@param`语法和`@type`相同，但增加了一个参数名。 使用`[]`可以把参数声明为可选的：\n\n```javascript\n// Parameters may be declared in a variety of syntactic forms\n/**\n * @param {string}  p1 - A string param.\n * @param {string=} p2 - An optional param (Closure syntax)\n * @param {string} [p3] - Another optional param (JSDoc syntax).\n * @param {string} [p4="test"] - An optional param with a default value\n * @return {string} This is the result\n */\nfunction stringsStringStrings(p1, p2, p3, p4){\n  // TODO\n}\n```\n\n函数的返回值类型也是类似的：\n\n```javascript\n/**\n * @return {PromiseLike<string>}\n */\nfunction ps(){}\n\n/**\n * @returns {{ a: string, b: number }} - May use \'@returns\' as well as \'@return\'\n */\nfunction ab(){}\n```\n\n### `@typedef`, `@callback`, 和 `@param`\n\n`@typedef`可以用来声明复杂类型。 和`@param`类似的语法。\n\n```javascript\n/**\n * @typedef {Object} SpecialType - creates a new type named \'SpecialType\'\n * @property {string} prop1 - a string property of SpecialType\n * @property {number} prop2 - a number property of SpecialType\n * @property {number=} prop3 - an optional number property of SpecialType\n * @prop {number} [prop4] - an optional number property of SpecialType\n * @prop {number} [prop5=42] - an optional number property of SpecialType with default\n */\n/** @type {SpecialType} */\nvar specialTypeObject;\n```\n\n可以在第一行上使用`object`或`Object`。\n\n```javascript\n/**\n * @typedef {object} SpecialType1 - creates a new type named \'SpecialType1\'\n * @property {string} prop1 - a string property of SpecialType1\n * @property {number} prop2 - a number property of SpecialType1\n * @property {number=} prop3 - an optional number property of SpecialType1\n */\n/** @type {SpecialType1} */\nvar specialTypeObject1;\n```\n\n`@param`允许使用相似的语法。 注意，嵌套的属性名必须使用参数名做为前缀：\n\n```javascript\n/**\n * @param {Object} options - The shape is the same as SpecialType above\n * @param {string} options.prop1\n * @param {number} options.prop2\n * @param {number=} options.prop3\n * @param {number} [options.prop4]\n * @param {number} [options.prop5=42]\n */\nfunction special(options) {\n  return (options.prop4 || 1001) + options.prop5;\n}\n```\n\n`@callback`与`@typedef`相似，但它指定函数类型而不是对象类型：\n\n```javascript\n/**\n * @callback Predicate\n * @param {string} data\n * @param {number} [index]\n * @returns {boolean}\n */\n/** @type {Predicate} */\nconst ok = s => !(s.length % 2);\n```\n\n当然，所有这些类型都可以使用TypeScript的语法`@typedef`在一行上声明：\n\n```javascript\n/** @typedef {{ prop1: string, prop2: string, prop3?: number }} SpecialType */\n/** @typedef {(data: string, index?: number) => boolean} Predicate */\n```\n\n### `@template`\n\n使用`@template`声明泛型：\n\n```javascript\n/**\n * @template T\n * @param {T} x - A generic parameter that flows through to the return type\n * @return {T}\n */\nfunction id(x){ return x }\n```\n\n用逗号或多个标记来声明多个类型参数：\n\n```javascript\n/**\n * @template T,U,V\n * @template W,X\n */\n```\n\n还可以在参数名前指定类型约束。 只有列表的第一项类型参数会被约束：\n\n```javascript\n/**\n * @template {string} K - K must be a string or string literal\n * @template {{ serious(): string }} Seriousalizable - must have a serious method\n * @param {K} key\n * @param {Seriousalizable} object\n */\nfunction seriousalize(key, object) {\n  // ????\n}\n```\n\n### `@constructor`\n\n编译器通过`this`属性的赋值来推断构造函数，但你可以让检查更严格提示更友好，你可以添加一个`@constructor`标记：\n\n```javascript\n/**\n * @constructor\n * @param {number} data\n */\nfunction C(data) {\n  this.size = 0;\n  this.initialize(data); // Should error, initializer expects a string\n}\n/**\n * @param {string} s\n */\nC.prototype.initialize = function (s) {\n  this.size = s.length\n}\n\nvar c = new C(0);\nvar result = C(1); // C should only be called with new\n```\n\n通过`@constructor`，`this`将在构造函数`C`里被检查，因此你在`initialize`方法里得到一个提示，如果你传入一个数字你还将得到一个错误提示。如果你直接调用`C`而不是构造它，也会得到一个错误。\n\n不幸的是，这意味着那些既能构造也能直接调用的构造函数不能使用`@constructor`。\n\n### `@this`\n\n编译器通常可以通过上下文来推断出`this`的类型。但你可以使用`@this`来明确指定它的类型：\n\n```javascript\n/**\n * @this {HTMLElement}\n * @param {*} e\n */\nfunction callbackForLater(e) {\n    this.clientHeight = parseInt(e) // should be fine!\n}\n```\n\n### `@extends`\n\n当JavaScript类继承了一个基类，无处指定类型参数的类型。而`@extends`标记提供了这样一种方式：\n\n```javascript\n/**\n * @template T\n * @extends {Set<T>}\n */\nclass SortableSet extends Set {\n  // ...\n}\n```\n\n注意`@extends`只作用于类。当前，无法实现构造函数继承类的情况。\n\n### `@enum`\n\n`@enum`标记允许你创建一个对象字面量，它的成员都有确定的类型。不同于JavaScript里大多数的对象字面量，它不允许添加额外成员。\n\n```javascript\n/** @enum {number} */\nconst JSDocState = {\n  BeginningOfLine: 0,\n  SawAsterisk: 1,\n  SavingComments: 2,\n}\n```\n\n注意`@enum`与TypeScript的`@enum`大不相同，它更加简单。然而，不同于TypeScript的枚举，`@enum`可以是任何类型：\n\n```javascript\n/** @enum {function(number): number} */\nconst Math = {\n  add1: n => n + 1,\n  id: n => -n,\n  sub1: n => n - 1,\n}\n```\n\n### 更多示例\n\n```javascript\nvar someObj = {\n  /**\n   * @param {string} param1 - Docs on property assignments work\n   */\n  x: function(param1){}\n};\n\n/**\n * As do docs on variable assignments\n * @return {Window}\n */\nlet someFunc = function(){};\n\n/**\n * And class methods\n * @param {string} greeting The greeting to use\n */\nFoo.prototype.sayHi = (greeting) => console.log("Hi!");\n\n/**\n * And arrow functions expressions\n * @param {number} x - A multiplier\n */\nlet myArrow = x => x * x;\n\n/**\n * Which means it works for stateless function components in JSX too\n * @param {{a: string, b: number}} test - Some param\n */\nvar fc = (test) => <div>{test.a.charAt(0)}</div>;\n\n/**\n * A parameter can be a class constructor, using Closure syntax.\n *\n * @param {{new(...args: any[]): object}} C - The class to register\n */\nfunction registerClass(C) {}\n\n/**\n * @param {...string} p1 - A \'rest\' arg (array) of strings. (treated as \'any\')\n */\nfunction fn10(p1){}\n\n/**\n * @param {...string} p1 - A \'rest\' arg (array) of strings. (treated as \'any\')\n */\nfunction fn9(p1) {\n  return p1.join();\n}\n```\n\n### 已知不支持的模式\n\n在值空间中将对象视为类型是不可以的，除非对象创建了类型，如构造函数。\n\n```javascript\nfunction aNormalFunction() {\n\n}\n/**\n * @type {aNormalFunction}\n */\nvar wrong;\n/**\n * Use \'typeof\' instead:\n * @type {typeof aNormalFunction}\n */\nvar right;\n```\n\n对象字面量属性上的`=`后缀不能指定这个属性是可选的：\n\n```javascript\n/**\n * @type {{ a: string, b: number= }}\n */\nvar wrong;\n/**\n * Use postfix question on the property name instead:\n * @type {{ a: string, b?: number }}\n */\nvar right;\n```\n\n`Nullable`类型只在启用了`strictNullChecks`检查时才启作用：\n\n```javascript\n/**\n * @type {?number}\n * With strictNullChecks: true -- number | null\n * With strictNullChecks: off  -- number\n */\nvar nullable;\n```\n\n`Non-nullable`类型没有意义，以其原类型对待：\n\n```javascript\n/**\n * @type {!number}\n * Just has type number\n */\nvar normal;\n```\n\n不同于JSDoc类型系统，TypeScript只允许将类型标记为包不包含`null`。 没有明确的`Non-nullable` -- 如果启用了`strictNullChecks`，那么`number`是非`null`的。 如果没有启用，那么`number`是可以为`null`的。\n\n',kc={data:function(){return{MainComponent1:Sc,MainComponent2:_c}}},jc=kc,wc=Object(m["a"])(jc,fc,vc,!1,null,"0e0b00f5",null),xc=wc.exports,Tc={mixins:[k["c"]],components:{m1:Il,m2:ac,m3:yc,m4:xc},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"基础",value:"m1"},{label:"高级",value:"m2"},{label:"模板",value:"m3"},{label:"其他",value:"m4"}]}}},Cc=Tc,Mc=Object(m["a"])(Cc,kl,jl,!1,null,"565a8060",null),Pc=Mc.exports,Oc=function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",{staticClass:"q-my-md q-mx-sm"},[r("q-markup-table",{attrs:{dense:""}},[r("thead",[r("tr",[r("th",{staticClass:"text-left text-weight-bolder text "},[r("div",{staticClass:"text-weight-bolder"},[n._v("\n            当前面试题目主题： "+n._s(n.table_title)+"---------- 总条目数：\n            "+n._s(n.totol)+"\n          ")])])])]),r("tbody",[n._l(n.table_data,(function(t,e){return[r("tr",{key:n.tab+"---"+e},[r("td",{staticClass:"text-left "},[r("div",[n._v(n._s(e)+".   "+n._s(t[0]||""))])])])]}))],2)])],1)},Ec=[],Rc=(r("7db0"),r("b0c0"),r("fa16")),Nc=r.n(Rc),Ac={mixins:[k["c"]],data:function(){return{tab:"js",tab_level:2,tabs:[{label:"html",value:"html"},{label:"css",value:"css"},{label:"js",value:"js"},{label:"jquery",value:"jquery"},{label:"vue",value:"vue"},{label:"react",value:"react"},{label:"nodejs",value:"nodejs"},{label:"webpack",value:"webpack"},{label:"微信小程序",value:"wxxcx"},{label:"软技能",value:"other"}],table_title:"",table_data:[],column:1,totol:"",workSheetsFromFile:[[{data:[]}]],all_data:[]}},created:function(){this.init_workSheetsFromFile(),this.init_data()},watch:{tab:function(n,t){this.init_data(),console.log(" table_data: [],",this.table_data)}},methods:{init_workSheetsFromFile:function(){console.log(" this.workSheetsFromFile = workSheetsFromFile; ",Nc.a),this.workSheetsFromFile=Nc.a},compute_width:function(n){var t=250;t=1==n?60:t,t=2==n?100:t;var r="min-width: ".concat(t,"px");return 2==n&&(r="min-width: ".concat(t,"px")),r},init_data:function(){var n=this;console.log("workSheetsFromFile --------",this.workSheetsFromFile);var t=this.workSheetsFromFile.find((function(t){return t.name==n.tab}))||{};this.table_data=t["data"]||[],this.totol=this.table_data.length;var r=this.tabs.find((function(t){return t.value==n.tab}))||{};this.table_title=r.value}}},Dc=Ac,Ic=(r("8dbb"),Object(m["a"])(Dc,Oc,Ec,!1,null,"d10c81fe",null)),Jc=Ic.exports,Lc={mixins:[k["c"]],components:{interview:Jc,inspiration:T,basics:zn,css:Xt,js:ce,http:ua,vue:jo,other:vi,tool:_l,react:ds,ts:Pc},data:function(){return{tab:"inspiration",tabs:[{label:"inspiration",value:"inspiration"},{label:"interview",value:"interview"},{label:"basics",value:"basics"},{label:"css",value:"css"},{label:"js",value:"js"},{label:"http",value:"http"},{label:"vue",value:"vue"},{label:"react",value:"react"},{label:"ts",value:"ts"},{label:"other",value:"other"},{label:"tool",value:"tool"}]}}},Hc=Lc,Fc=Object(m["a"])(Hc,e,a,!1,null,"ec81bc3a",null);t["default"]=Fc.exports},"8dbb":function(n,t,r){"use strict";var e=r("7703"),a=r.n(e);a.a},fa16:function(n,t){n.exports=[{name:"html",data:[["[html] 使用H5画出几个月饼"],["[html] 使用css画一个动态的彩带"],["[html] html5中的meta标签window-target有什么作用？"],["[html] html5中的meta标签pragma有什么作用？"],["[html] 你有使用过bgsound标签吗？说说它的作用"],["[html] html5中的meta标签scheme有什么作用？"],["[html] html5中的meta标签revised有什么作用？"],["[html] html5中的meta标签keywords有什么作用？"],["[html] html5中的meta标签description有什么作用？"],["[html] html5中的meta标签author有什么作用？"],["[html] meta标签的哪个属性是必须的？"],["[html] 你知道html标签meta中的Content-Security-Policy有什么作用吗？"],["[html] cookie的存储如果超过了最大限制将会发生什么事情？如何解决？"],["[html] 在高分辨率下写页面，应该注意什么？"],["[html] html列表共有几种？有什么区别？"],["[html] 在线的编辑器你都使用过哪些？"],["[html] 如何修改textarea内容的字体大小及字体颜色？"],["[html] 微信打开的h5页面如何调用微信的方法？"],["[html] 小程序web-view嵌入H5页面能不能调用微信的API？"],["[html] 微信小程序如何主动与H5通信？"],["[html] 前端如何在h5页面调用微信支付？"],["[html] h5页面如何与微信通信？"],["[html] webGL和svg有什么区别？"],["[html] 使用webgl画一张贺卡"],["[html] 说说webGL和canvas的区别"],["[html] 前端可以绘制图形有哪几种方法？"],["[html] html代码中混合php或者其它后台语言代码，你觉得好维护吗？为什么？"],["[html] 你有使用过ContentEditable属性吗？说说你对它的理解"],["[html] 写一个吸附布局"],["[html] 使用HTML5+CSS3实现一个轮胎滚动的特效"],["[html] 使用HTML5绘制一个高脚杯"],["[html] 使用HTML5绘制一个发光的灯泡"],["[html] 使用HTML5绘制一道闪电"],["[html] 使用HTML5绘制一个经典“旺仔”的头像"],["[html] 使用HTML5绘制一个IE的Logo"],["[html] 使用HTML5绘制一个指南针"],["[html] 使用HTML5绘制一个大西瓜"],["[html] 使用HTML5绘制一只小蜜蜂"],["[html] 使用HTML5绘制一支铅笔"],["[html] 使用HTML5绘制一副乒乓球拍"],["[html] 使用HTML5绘制一个正反面的硬币"],["[html] 使用HTML5绘制一个Android的Logo"],["[html] 使用HTML5自定义一个下拉框"],["[html] 使用HTML5自定义一个复选框"],["[html] 使用HTML5自定义一个单选框"],["[html] 使用HTML5绘制一只甲壳虫"],["[html] 使用HTML5绘制一个灯塔"],["[html] 使用HTML5绘制一只梅花鹿"],["[html] 使用HTML5绘制一只乌龟"],["[html] 使用HTML5绘制一个汉堡"],["[html] 使用HTML5绘制一只卡通版米老鼠"],["[html] 使用HTML5绘制一把雨伞"],["[html] 使用HTML5制作一个多层的生日蛋糕"],["[html] 使用HTML5制作一个刻度温度计"],["[html] 制作一个晶莹剔透的水晶球布局"],["[html] 使用HTML5写一个打地鼠的小游戏"],["[html] 使用HTML5制作一个大哥大布局"],["[html] 使用HTML5制作一个圣诞老人"],["[html] 使用HTML5制作一些微信常用的表情包"],["[html] 使用HTML5制作一个弹簧的效果"],["[html] 使用HTML5制作一个遥控器的效果"],["[html] 使用HTML5制作一个啤酒瓶的效果"],["[html] 使用HTML5制作一个逼真的钻石效果"],["[html] 使用HTML5仿PC端微信聊天界面"],["[html] 使用HTML5模拟苹果系统桌面布局"],["[html] 使用HTML5实现3D立体星星动画效果"],["[html] 使用HTML5实现一个倾斜的图片增效果"],["[html] 使用HTML5实现窗户玻璃雨滴的逼真效果"],["[html] 使用canvas实现一个贪吃蛇小游戏"],["[html] 使用canvas画一个军棋的棋盘"],["[html] 使用canvas画一个github的LOGO图案"],["[html] 使用canvas画一个喜洋洋的图案"],["[html] 使用canvas画一个灰太狼的图案"],["[html] 使用html5模拟鲨鱼动画效果"],["[html] 写一个模拟微信拆红包摇晃的动画效果"],["[html] 使用HTML5制作一个可以旋转的太极图案交互特效"],["[html] 写一个移动端悬浮框效果"],["[html] 写一个大转盘抽奖的交互"],["[html] html5制作仪器圆表盘转动动画效果"],["[html] 使用canvas制作一个圆形进度条 "],["[html] 画一只小猫的布局"],["[html] 如何使用HTML5打造本地桌面应用？"],["[html] 使用HTML5制作一个螺旋的动画特效"],["[html] 制作一个吊扇的布局"],["[html] 使用Canvas画出头发飘逸的动画"],["[html] 画一个显示器的布局"],["[html] js 生成文字游戏地图"],["[html] 使用html画一个音乐播放器的布局"],["[html] 在html页面如何引入另外一个html页面？有哪些方法？"],["[html] 如果要在页面上放一个广告位，你是如何考虑的？"],["[html] 制作一个ipone的手机布局"],["[html] 请说下你对html的发展历史的了解及认知"],["[html] 至今为止你写过最最复杂的布局是什么？怎么个复杂法？"],["[html] 浏览器如何渲染inline元素中空格的？"],["[html] 页面中如何使用MathML？"],["[html] 如何在页面上显示LaTeX数学公式"],["[html] 如果没有设计稿，只有原型，让你写页面，你该怎么办？"],["[html] 你有主动去学习了解过HTML的标准规范吗？"],["[html] 写一个输入框搜索时联想的布局"],["[html] 写一个布局,你认为最关键的地方是什么？"],["[html] 畅想下HTML6"],["[html] 使用html画一个热气球"],["[html] 写出一个可滚动的区域，但要隐藏滚动条"],["[html] 使用html画一颗爱情树的布局"],["[html] 你有使用过datagrid标签吗？说说它的用途"],["[html] 使用html画出一对会转的眼睛"],["[html] 在HTML5允许在元素名中使用混合大小写字母吗？"],["[html] 你认为一个门户类的网站应该有哪些布局？为什么？"],["[html] 如果一个页面的html代码量很大你该怎么办？"],["[html] 写一个可拖动的布局"],["[html] 你有去研究过哪些网站布局呢？"],["[html] 使用html画两支羽毛球拍"],["[html] 写一个书本翻页的特效"],["[html] 使用html+css画出你心中冬天的感觉"],["[html] 使用html+css画出你心中秋天的感觉"],["[html] 使用html+css画出你心中夏天的感觉"],["[html] 使用html+css画出你心中春天的感觉"],["[html] 写一个微信运动排行榜页面的布局"],["[html] 写一个点击从左侧滑出的布局"],["[html] 一个页面你觉得有多少种颜色搭配比较合理？为什么？"],["[html] 写一句“五一节日快乐”闪烁的动画效果"],["[html] 在移动端写一个左滑删除的功能"],["[html] 如何显示上传文件的进度？"],["[html] 如何实现目录的上传？"],["[html] 如何阻止页面的字体自动调整大小？"],["[html] 说说你对HTML Entry的理解"],["[html] 你觉得html5可以做什么有意思的事情？"],["[html] 使用html简单画一个里面放有笔的笔筒"],["[html] 在H5中，如何解决长按二维码图片识别不出或者错误的问题？"],["[html] 在移动端如何解决点击前进或者后退按钮不刷新的问题？"],["[html] 接口返回字段包含\\n或<br>，如何识别文本换行？"],["[html] H5的input输入框如何对齐输入占位？"],["[html] H5如何禁止动画闪屏？"],["[html] H5如何禁止高亮显示？"],["[html] H5如何禁止旋转屏幕时的字体调整？"],["[html] H5如何支持弹性滚动？"],["[html] H5如何禁止滚动传播？"],["[html] H5如何禁止长按？"],["[html] H5如何禁止屏幕抖动？"],["[html] 如何启用360浏览器的极速模式？"],["[html] 怎么设置才能让:active有效，让:hover无效？"],["[html] 如何强制浏览器全屏？"],["[html] 在H5中，你了解到的ios系统有哪些专用特性？"],["[html] h5页面如何打开微信APP？"],["[html] h5页面如何打开支付宝APP？"],["[html] 在移动端页面如何忽略自动识别电话和邮箱？"],["[html] 说说你对URL Scheme的理解"],["[html] 文件选择框如何选择指定后缀的文件？"],["[html] 文件选择框如何多选文件？"],["[html] 在移动端中H5的输入框弹起键盘遮挡，有哪些解决方案呢？"],["[html] 使用SVG画一个小米的logo"],["[html] 如何禁止字母大写？"],["[html] H5如何只弹出数字键盘？"],["[html] 你是如何测试写的页面兼容性的？"],["[html] Html5页面设计稿的尺寸有哪些？为什么？"],["[html] 写一跳动的音符"],["[html] 写一个可以编辑列的表格布局"],["[html] 写一个块状可以拖动的布局"],["[html] 只使用一个div,画一个圆,里面有个水平垂直居中的加号"],["[html] 根据下面Object.create创建出的对象，下面的题分别输出的结果是什么？"],["[html] 实现一个雷达扫描的动画效果"],["[html] 如果不写标准的html标签，浏览器可以正常解析出来吗？"],["[html] 在页面中能打开.doc或者.xlsx后缀的文件吗？如果可以应该怎么做？"],["[html] 在微信的H5页面不能下载如何解决？"],["[html] 分别实现1-16宫格的布局"],["[html] 请说出几条关于HTML的W3C标准规范"],["[html] 写一个select下拉分组的组件"],["[html] 移动端picker和select有什么区别？"],["[html] 如何隐藏元素的滚动条？"],["[html] 写一个中间固定，两边自适应的布局（使用多种方法）"],["[html] 如何禁止HTML页面滚动？"],["[html] 说说你认为的html黑科技有哪些？"],["[html] html中是如何调出QQ会话的？说说你的理解"],["[html] 写一个鼠标滚动图片时放大或缩小图片"],["[html] picture有哪些优点？picture标签可以替代img标签吗？"],["[html] 画一个ipad的页面布局"],["[html] 你有分析过哪些知名网站的布局？有哪些收获？"],["[html] 网页的布局风格有哪些？你有了解过吗？"],["[html] 写一个始终固定在右侧浮动的工具条"],["[html] 如何在页面上引用百度、腾讯地图？"],["[html] 你是如何格式化HTML代码的？"],["[html] 写一个上拉加载的布局"],["[html] 制作一个水杯的布局（任意想象一个水杯的形状）"],["[html] 请写一个压窗屏的交互布局"],["[html] 写H5和小程序有什么相同及不同的地方吗？"],["[html] 你喜欢哪种布局风格？说说你的理由"],["[html] 移动端如何让页面强制横屏显示？"],["[html] 制作一个多选的下拉框"],["[html] 如何实现标题栏闪烁、滚动的效果"],["[html] 在页面中如何实现触发某一场景时有声音提醒"],["[html] 如果让你实现一个网页版的办公表格（类似excel），你觉得是否可行？如果可行应该怎么做？"],["[html] 写一个搜索框，聚焦时搜索框向左拉长并有动画效果"],["[html] 画一个五层楼的布局"],["[html] 给“测试投影”几个字添加立体投影的效果"],["[html] 说说你对Gzip压缩的了解"],["[html] html5中的meta标签http-equiv属性有什么作用？"],["[html] html5中的meta标签robots有什么作用？"],["[html] html5中的meta标签generator有什么作用？"],["[html] html5中的meta标签renderer有什么作用？"],["[html] 在HTML5中，用于获得用户的当前位置是哪个方法？"],["[html] html5中的meta标签itemprop属性有什么作用？"],["[html] 请实现一个微信炸弹的效果"],["[html] 请使用flex和grid两种方式实现9宫格布局"],["[html] 页面的重绘和回流是什么？"],["[html] 你最喜欢H5的哪些功能？为什么？"],["[html] 你觉得新开发一个网站最困难的是哪些部分？"],["[html] 写html代码时，怎样才加速写代码的速度呢？你有什么方法？"],["[html] 写一个标签云的布局"],["[html] 你认为Html的术难点在哪？"],["[html] 说说你认为有没有你做不出来的布局？有哪些？为什么？"],["[html] 如何让img自动适应div容器大小？"],["[html] 写一个带遮罩层的弹窗，并把内容锁定没有滚动条"],["[html] 页面上如何显示特殊字符？"],["[html] 怎样计算首屏和白屏的时间？"],["[html] 如何在不同的端口间共享cookie？"],["[html] 如何在页面打开PDF文件？"],["[html] 使用svg画一个微信的logo"],["[html] 使用svg画一个百度的logo"],["[html] 如何阻止屏幕旋转时自动调整字体的大小？"],["[html] 你认为HTML5出现后，它的商业模式会有哪些变化呢？"],["[html] 说说你对HTML5中“一次编写，全体使用”的理解"],["[html] 为什么我们要使用web workers？"],["[html] 本地存储和cookie之间的区别是什么？"],["[html] 什么是本地存储的有效期？"],["[html] 使用svg画出一个矩形"],["[html] 对于写一个页面布局，html/css/js这三者你是先写哪个后写哪个？"],["[html] 你觉得写Html难吗？难在哪？为什么？"],["[html] HTML5的Server-Sent和WebSocket如何选择哪一个？"],["[html] HTML5的Server-Sent和WebSocket有什么区别？"],["[html] HTML5的Geolocation不允许定位后如何于次让它弹起授权定位？"],["[html] html5的geolocation定位误差大如何解决？"],["[html] 如何更改浏览器左上角标题旁的图标？"],["[html] 制作一个金字塔布局"],["[html] 写一个类似刮刮卡效果的交互，即鼠标划过时显示号码"],["[html] 如何实现多行文字梯形排版？"],["[html] h5页面如何传递参数给小程序？"],["[html] HTML5如何播放ts视频流？"],["[html] 实现两列等宽布局的方式有哪些？"],["[html] 写一个滚动吸顶的布局"],["[html] 写一个垂直的三栏布局，第一栏固定顶部，中间铺满，第三栏固定底部"],["[html] 移动端布局的自适应如何做？"],["[html] 写一个水平竖直居中的弹窗，带遮罩层的布局"],["[html] H5如何与APP交互？有哪些方式？"],["[html] 使用button当按钮和使用div当按钮有什么区别？"],["[html] 写一个windows phone风格的布局"],["[html] 说说你对H标签在布局中的重要性的理解"],["[html] 百度、淘宝、京东移动端首页秒开是如何做到的？"],["[html] 写页面布局时需要考虑哪些方面的因素？"],["[html] 你认为写出什么样的html代码才是好代码呢？"],["[html] 简述下W3C标准都有哪些？如何才能做出符合标准的网页？"],["[html] 你是怎样检测网页是否遵循W3C标准的？"],["[html] 说说js代码写到html里还是单独写到js文件里哪个好？为什么？"],["[html] 如何在select控件中使用a链接？"],["[html] 如何在网页可见区域的正中间画一条横线（要考虑有滚动条的情况）"],["[html] 如何使用H5实现录屏的功能？请说说你的思路"],["[html] 如何使用H5实现电子签名？请说说你的思路"],["[html] 你认为HTML标签有什么不好的地方吗？为什么？"],["[html] 写一个布局，它的宽度是不固定的100%，如果让它的宽度始终是高度的一半呢？"],["[html] 你有使用过H5的Web Audio API吗？说说它的用途"],["[html] 微信公众号的文章如何做到点击图片查看答案？"],["[html] 如果要开发一个在超级大屏上显示的可视化页面，你首先要考虑什么？"],["[html] 如何给table中的某一列设置固定宽度"],["[html] html中表格的width和height的值为什么没有单位？它的的默认单位是像素吗？"],["[html] 如何解决微信浏览器中video标签z-index过高遮挡页面问题？"],["[html] 如何解决微信浏览器视频点击自动全屏的问题？"],["[html] H5播放的video视频，如何实现对视频截图？"],["[html] 说说你对H5媒体捕获的理解，它有什么用途？"],["[html] 前端需要注意哪些SEO?"],["[html] HTML5拖拽事件的顺序是什么？"],["[html] 你有使用过del标签吗？说说它的用途"],["[html] 你有使用过kbd标签吗？说说它的用途"],["[html] 你有使用过ins标签吗？说说它的用途"],["[html] 你有使用过summary标签吗？说说它的用途"],["[html] 如何动态修改<title>的标题名称？"],["[html] 如何对一个页面进行重构？"],["[html] 为什么说cookie不可以滥用？"],["[html] 如何给<video>视频添加字幕(WebVTT)？"],["[html] 一个标签上同时出现三个或多个class属性，请问它的渲染顺序是怎样的？"],["[html] 要减少DOM的数量有什么办法吗？"],["[html] svg可以转为png吗？怎么转？"],["[html] 使用canvas画一个军棋的棋盘"],["[html] 使用canvas画一个中国象棋的棋盘"],["[html] 使用canvas画一个五子棋的棋盘"],["[html] 使用svg能实现哪些复杂的功能？"],["[html] 使用canvas能实现哪些复杂的功能？"],["[html] 使用svg画出“前端每日3+1”的几个字"],["[html] 使用svg画一个爱心"],["[html] 使用svg画出一个时钟"],["[html] 使用svg画一个平行四边形"],["[html] 使用svg画一个腾讯的logo"],["[html] 使用svg画一个三角形"],["[html] 使用svg画一条折线图"],["[html] 为什么要优先选择html5开发移动应用？"],["[html] 说说你对HTML5中pattern属性的理解"],["[html] tabindex属性有什么作用？"],["[html] 你是如何区分HTML和HTML5的？"],["[html] 怎样处理HTML5新标签在浏览器中兼容的问题？"],["[html] HTML5语义化更好的标签有哪些？"],["[html] XHTML有哪些强制的要求？"],["[html] html的属性值有规定要使用单引号还是双引号吗？"],["[html] HTML5是SGML的子集吗？"],["[html] 你觉得html的标签（包括html5）总共有多少个？它们是如何分类的？"],["[html] 你有使用过samp标签吗？说说它的应用场景"],["[html] 请说说h1-h6它们的默认字体大小是多少吗？"],["[html] 直接使用b标签和使用css的font-weight有什么区别？"],["[html] 你有使用过bdi标签吗？它有什么应用场景？"],["[html] HTML5布局的页面结构和HTML4有什么不同？"],["[html] HTML5的var标签有什么应用场景？"],["[html] 说说你对object标签的理解，它有什么应用场景？"],["[html] 说说你对abbr标签的理解，它有什么含义？"],["[html] HTML5的触屏事件与鼠标事件有什么区别？"],["[html] HTML5的触屏事件有哪些？"],["[html] html实现页面跳转都有哪些方法？"],["[html] 如何在页面引用外部的html页面？"],["[html] a标签的默认事件禁用后，如何实现跳转？"],["[html] 如何禁用掉a标签的默认事件？"],["[html] 写出不定宽度的子级div，在相对于固定宽度的父级元素水平居中的布局"],["[html] 写一个三栏布局，中间固定，两边自适应（平均）"],["[html] 说说你对移动优先布局的理解"],["[html] 如果浏览器支持的功能受限，如何更好的提供页面呢？"],["[html] 响应式设计的有哪些技巧？有哪些好处？"],["[html] 请使用一个div写出有三条横线的小图标"],["[html] 使用div+css进行布局有什么好处？"],["[html] 如何根据设备尺寸做页面自适应？"],["[html] 说说你对制表符的理解，它有什么作用？"],["[html] canvas生成图片有没有跨域问题？如果有如何解决？"],["[html] 如何垂直居中<img>？"],["[html] 如何解决在移动端1px渲染成2px的问题？"],["[html] 如何禁止手机端页面缩放？"],["[html] 实现中国五星红旗国旗的布局"],["[html] 你能否画出一个0.5px的直线？"],["[html] 制作一个页面时，需要兼容PC端和手机端，你是要分别做两个页面还是只做一个页面自适应？为什么？说说你的理由"],["[html] 如何实现页面背景图固定不动，不跟随滚动条滚动？"],["[html] 如何实现默认显示git的第一帧图片，当鼠标经过时，播放完整的gif动画"],["[html] html页面中如何实现gif图片重新播放？"],["[html] 请说说你在写布局时对于浏览器兼容性的感受或总结"],["[html] H5的video可以播放哪些类型的文件？可以播放rtsp流吗？"],["[html] 写一个布局，满足当页面滚动时，左侧固定不动，右侧的最小高度与左侧一样"],["[html] 写一个方法计算出页面中HTML使用最多的标签是哪一个"],["[html] 如何让pre标签中的元素自动换行？"],["[html] 你知道什么是反向链接吗？它有什么应用场景呢？"],["[html] 网页中的友情链接有什么作用？"],["[html] 你知道短链接的生成原理吗？"],["[html] 说说你对短链接的理解，它有什么应用场景呢？"],["[html] 微信H5页面如何更新缓存？"],["[html] H5页面在微信中如何禁止分享给好友和朋友圈？"],["[html] 如果src或者href为空时，将会伴随着哪些问题的出现？"],["[html] 举例说明只用html和css如何使得一个列表编号倒序？"],["[html] http中的301、302、307、308有什么区别？"],["[html] 如何给input的右上角加个清除的按钮？"],["[html] 进入编辑页面时，如何把光标聚焦到第一个input？"],["[html] html中在span标签里面可以放那些标签？"],["[html] const nums1 = [1, 2, 2, 1], nums2 = [2] 交集是什么？"],["[html] H5中video的事件的触发顺序是怎样的？"],["[html] 你有使用过MediaRecorder吗？说说它的运用场景有哪些？"],["[html] 说说你对H5的ServiceWorker的理解，它有什么运用场景？"],["[html] 说说你对H5的SharedWorker的理解，它有什么运用场景？"],["[html] 在head标签中必不少的是什么？"],["[html] 如何优化大数据列表（10万+）的性能？说说你的方案"],["[html] 请写一个正则获取html源码中所有img标签的src地址"],["[html] 如何使用纯HTML实现跑马灯的效果？"],["[html] 给你一个参考网站，你能快速下载它的模板吗？用哪些方法？"],["[html] HTML采用的是RGB颜色还是CMYK颜色？为什么？"],["[html] 如果列表元素li的兄弟元素为div，会产生什么情况？"],["[html] html的开始与结束标签嵌套错误会导致哪些问题？"],["[html] 写一个密码默认星号，但可以查看密码的输入框"],["[html] 制作一个不规则形状有哪些方法可以实现？"],["[html] 跨域通信有哪些方式？"],["[html] 说下cookie的优点和使用场景是什么？"],["[html] html哪个标签属性可以通过预解析DNS？"],["[html] 如何优化页面的渲染过程？"],["[html] html的哪个标签可以预渲染？"],["[html] html的哪个标签可以预加载？"],["[html] 在a标签中，怎样防止链接跳转？"],['[html] 说说如果a链接href=""（空）时点击时会有什么表现？'],["[html] 使用canvas时你有遇到过哪些坑？是如何解决的？"],["[html] 如何在IOS下启用WebApp全屏模式？"],["[html] 你最喜欢html的哪个标签？为什么？"],["[html] 举例说明使用data-有什么优点？"],["[html] 可替换元素和不可替换元素有什么不同的特点？"],["[html] html元素哪些标签是不可替换元素？哪些是可替换元素？"],["[html] 写一个三栏布局，两边固定，中间自适应"],["[html] 你写一个页面需要多长时间？"],["[html] 页面需要支持多语言，如果是你该怎么做？"],["[html] 你认为一个好的布局应该是什么样的？有哪些需要注意的地方？"],["[html] 怎样写出优雅的HTML结构？"],["[html] button标签的type默认值是什么呢？"],["[html] H5的哪些特性需要https支持呢？"],["[html] 请使用canvas画一个渐变的长方形"],["[html] 请使用canvas画一个椭圆"],["[html] 在H5中如何预加载音频？"],["[html] 一般习惯把js写在</body>前，但有例外的情况吗？说说看"],["[html] 当页面中使用application/xhtml+xml会出现什么问题吗？"],["[html] H5的Web Storage带来什么好处？"],["[html] 把H5看成一个开放的平台，那构建它的模块有哪些？"],["[html] 什么是空元素？常用的空元素有哪些？"],["[html] HTML为什么要语义化？语义化有什么好处？"],["[html] 制作页面时，前端如何适应各种异形屏？"],["[html] 做好的页面，你是如何获取更好的搜索引擎优化？"],["[html] 如何关闭HTML页面在IOS下的键盘首字母自动大写？"],["[html] 写一个左中右的满屏布局，左右固定220px,中间自适应并且要优先加载"],["[html] 说说如果meta标签没有写charset属性，将会如何？"],["[html] html标签中的lang属性有什么作用？"],["[html] 说说base标签有什么作用？"],["[html] 写一个布局，当页面滚动一定高时，导航始终固定在顶部，反之恢复原位"],["[html] HTML5如何监听video的全屏和退出全屏？"],["[html] 举例说明HTML5出来后，有哪些HTML标签被弃用了？"],["[html] HTML5的video在手机端如何实现进来页面时就自动播放？"],["[html] H5怎么禁用长按复制的功能？"],["[html] 如果一个标签元素同时出现两个class属性，两个class都会生效吗？为什么？"],["[html] 写一个鼠标跟随的特效"],["[html] 写一个网页点击的特效"],["[html] 如何使用H5唤起原生地图APP（百度、高德、腾讯地图等）"],["[html] p标签里面嵌套img标签会出现向上高3像素是什么原因？如何处理？"],["[html] 表单可以跨域吗？"],["[html] 对于rtl网站的适配有哪些方案？"],["[html] 404页面有什么作用？"],["[html] 在主框架下引入的iframe，如果检测这个iframe是否能打开，如果打不开则跳到404页面"],['[html] 通过设置表单的target="_blank"来下载文件会被浏览器拦截吗？如何解决？'],["[html] 如何通过表单下载文件？"],["[html] 使用a标签的download属性下载文件会有跨域问题吗？如何解决？"],["[html] 页面刷新时sessionStroage会变（会清空）吗？"],["[html] canvas透明度是0.6的矩形和透明度是0.2的矩形叠加到一起，透明度是多少？"],["[html] 请实现一个文章阅读的进度条"],["[html] 请实现一个网站加载进度条"],["[html] 开发静态页面时，不依赖node相关的工具，如何提取出公共部分并引入？"],["[html] 怎样禁用页面中的右键、打印、另存为、复制等功能？"],["[html] 能否做到禁止打印页面？如果可以那要怎么做？"],["[html] 实现一个页面锁屏的功能"],["[html] 如何判断用户正在操作页面？当页面一个小时没有操作时跳转到指定页面如何做？"],["[html] 如何给页面添加追加右键菜单（原右键菜单功能保持不变）"],["[html] 请问60*80的canvas占多少内存？你是怎么计算的？"],["[html] 精确获取页面元素位置的方式有哪些？"],["[html] 跨标签页的通讯方式有哪些"],["[html] websocket和http2有什么区别？http2能取代websocket吗？为什么？"],["[html] websocket如何区分不同的客户端？"],["[html] websocket可以携带cookie吗？为什么？如果可以，怎样做到呢？"],["[html] websocket握手成功会返回一个干什么状态吗？是200吗？"],["[html] websocket握手阶段是通过什么协议传输的？"],["[html] websocket是如何做心跳检测、数据加密、身份验证的？"],["[html] http和websocket能共用一个端口吗？为什么？"],["[html] websocket和socket有什么区别？"],["[html] websocket和http有什么区别？"],["[html] 图片上传时实现本地预览功能的原理是什么？"],["[html] 你有使用过HTML5 Boilerplate吗？说说你对它的理解"],["[html] 切页面时，每次都动手刷新看效果很麻烦，如果要让你写一个实时刷新预览的工具你该怎么写？"],["[html] 说说你对Media Source Extensions(MSE)的理解，它解决了什么问题呢？"],["[html] 浏览器是怎么对HTML5的离线储存资源进行管理和加载的"],["[html] input如何在各个浏览器下保持UI统一？"],["[html] 使用H5实现一个手势密码"],["[html] 如何让table的边框双线变单线？"],["[html] svg如何转为字体图标？"],["[html] webp与jpg、png比较，它有什么优劣势？如何选择？"],["[html] 你有使用过webp的图片格式吗？"],["[html] html中如何使用svg？"],["[html] html5的video如何附带字幕？"],["[html] 你有使用过html5的rt标签吗？它有什么应用场景？"],["[html] 网页打印与标准纸张换算时，cm和px是如何换算的？"],["[html] pre与xmp标签有什么区别？"],["[html] 怎样在<pre>标签内不转义<和>符号（原样输出html标签）？"],["[html] 页面布局时你使用最多的标签是什么？div吗？在什么情况下会使用到div？"],["[html] 如何在网页中打开腾讯QQ？"],["[html] 如何在网页中嵌入公司地址的地图？"],["[html] 如何扩大CheckBox点击区域"],["[html] 如何放大点击的区域？"],["[html] 微信公众号如何打开关联的小程序？"],["[html] DOM节点的种类有哪些？"],["[html] DOM节点的根节点是不是body？"],["[html] android手机能同时播放两个video音频吗？"],["[html] 你有使用过output标签吗？说说它的用途有哪些？"],["[html] 如何使用纯html制作一个进度条？"],["[html] 你有使用过template标签吗？说说它的用途有哪些？"],["[html] 你有使用过meter标签吗？说说它的用途有哪些？"],["[html] 你有使用过blockquote标签吗？说说它的用途有哪些？"],["[html] 你有使用过time标签吗？说说它的用途有哪些？"],["[html] 如何实现前端代码实时预览效果？"],["[html] html如何启动本地的exe应用？"],["[html] 浏览器是如何解析html的？"],["[html] 举例说明图片懒加载的方案有哪些？"],["[html] 请说说input的inputmode属性有什么应用场景？"],["[html] html5的游戏引擎你了解多少？都有哪些比较好用的引擎呢？"],["[html] html5的Notification桌面通知如何请求权限？"],["[html] 使用history路由方式时，你有自己动手配置过服务器端吗？为什么要配服务器端？怎么配？"],["[html] history和hash两种路由方式的最大区别是什么？"],["[html] 举例说明原生的html组件有哪些？"],["[html] 说说html5手势检测原理是什么？"],["[html] 怎样在文本框中禁用中文输入法？"],["[html] 如何让<p>测试 空格</p>这两个词之间的空格变大？"],["[html] 在网格布局中都有哪些概念呢？比如：网格线"],["[html] 实现一个面包屑导航的效果"],["[html] 如何使用普通元素拥有像textarea元素一样缩放？"],["[html] 字体图标加载出来成了小方块，是什么原因呢？如何解决？"],["[html] 当网页放大或者缩小后如何让页面布局不乱？"],["[html] 实现一个全屏布局"],["[html] 你有使用过IE的条件注释吗？"],["[html] 实现九宫格布局"],["[html] 说说元素上下层叠关系及七阶层叠关系"],["[html] 说说你对这几个概念的理解：层叠上下文、层叠等级、层叠顺序"],["[html] 实现一个stick-footer布局"],["[html] 实现一个居中半透明的模态窗"],["[html] 说说你对网格布局的理解"],["[html] 写页面布局时你有考虑过分辨率因素吗？还要考虑哪些因素呢？"],["[html] div等元素如何阻止点击穿透和实现点击穿透？"],["[html] 浏览器的默认字体大小是多少？怎么设计它的基准？"],["[html] 打印页面时怎样自定义打印页眉页脚或者去掉眉页脚？"],["[html] link标签的属性media有哪些值？都有什么作用？"],["[html] 如何设置打印尺寸？"],["[html] 打印网页的时候，如何让指定的元素另起一页（打印分页）？"],["[html] 说下你对组件、模块、元素的理解，它们的区别在哪里？"],["[html] 给一个元素加下划线的方法有哪些？"],["[html] input元素size属性和width 的区别是什么？"],["[html] noscript标签有什么作用？"],["[html] 隐藏div内文字的方法有哪些？"],["[html] 列举几种多列等高布局的方法"],["[html] 列举几种瀑布流布局的方法"],["[html] 说说页面中字体渲染规则是怎样的？会有哪些因素影响字体的渲染？"],["[html] 你知道什么是粘性布局吗？"],["[html] 如何构建“弱网络环境”友好的项目？"],["[html] 使用canvas制作一个印章"],["[html] 后缀.html和.htm有什么区别？"],["[html] html6即将到来，你最期待的是什么特性呢？"],["[html] 举例说明锚点定位有什么作用？"],["[html] 什么是表单域？它有哪些运用场景？"],["[html] 你是如何理解html与css分离的？"],["[html] 编写html时，你有没有用过Emmet插件呢？说说它的优点及规则有哪些？"],["[html] 编写一个布局，让文字环绕在图片的周围"],["[html] android手机的微信H5弹出的软键盘挡住了文本框，如何解决？"],["[html] input上传图片怎样触发默认拍照功能？"],["[html] input上传文件可以同时选择多张吗？怎么设置？"],["[html] 如何禁止input输入的历史记录？"],["[html] 举例说明Shadow DOM的应用场景有哪些？"],["[html] 当html中使用map标签时,area中coords值如何精确定位呢？"],["[html] 你有用过图片热区吗？它有什么运用场景？"],["[html] html如何创建图片热区（img usemap）？"],["[html] 当img标签中的src图片加载失败时，怎么让它变得更美观呢？"],["[html] 举例说明当我们在写布局时，都有哪些边界的情况需要关注的？"],["[html] 如何去除标签<i>默认斜体？"],["[html] 怎样避免让用户看到长时间的白屏？"],["[html] 如何使用html5进行图片压缩上传？"],["[html] 你知道<a>标签的target属性规定在何处打开链接文档吗？"],["[html] 如何禁止移动端的左右划动手势？"],["[html] html5点击返回键怎样不让它返回上一页？"],["[html] 在普通网页中如何调用html5+的plus对象？"],["[html] 你知道什么是html5plus吗？"],["[html] 在两个iframe之间传递参数的方法有哪些？"],["[html] 怎样使用iframe刷新父级页面？"],["[html] 为什么移动端页面的设计稿一般是750px/640px呢？"],["[html] iframe可以使用父页面中的资源吗（如：css、js等）？"],["[html] iframe在更改了src之后，不出现后退或者前进按钮怎么解决？"],["[html] iframe父页面如何获取子页面的元素？"],["[html] iframe如何自动调整高度？"],["[html] 如何禁止web端的页面缩放？"],["[html] 微软雅黑是有版权的，在页面中使用font-family:Microsoft YaHei会不会有版权问题呢？"],["[html] 对一个元素设置浮动后，它的特征是什么？"],["[html] IE6文字溢出BUG（别名：多出来的猪、谍影重重）怎么解决呢？"],["[html] 你知道著名的3像素Bug指的是什么吗？怎么解决呢？"],["[html] 可以给内联元素设置宽和高吗？为什么？"],["[html] 如何解决input在Firefox和Chrome中高度不一致的问题？"],["[html] 给内联元素加float与给块元素加float有什么区别？"],["[html] 怎么去除img之间存在的间隔缝隙？"],["[html] table中给td设置宽度无效怎么解决？"],["[html] 块级元素不能包含其他块级元素有那些？"],["[html] html的img标签为什么要添加alt属性呢？"],["[html] 说说你对html的嵌套规范的理解，都有哪些规范呢？"],["[html] a标签可以再嵌套a标签吗？为什么？如果不行，那又想要嵌套效果怎么解决呢？"],["[html] html5有哪些应用场景？"],["[html] html5应该注意哪些安全的问题？"],["[html] 如何在页面上显示Emoji表情？"],["[html] 如何在桌面上生成网站的快捷方式图标？"],["[html] 举例说明实现文字贯穿线的方法有哪些？"],["[html] html标签的属性值是否可以省略引号？为什么？"],["[html] HTML5中的article和section有什么区别？"],["[html] 怎样去除iOS和Android中的输入URL地址的控件条呢？"],["[html] img中的src加载失败时如何用默认图片来替换呢？"],["[html] 页面上的登录表单记住了密码（显示星号），但我又忘了密码，如何找回这个密码呢？"],["[html] 举例说明写一个button的按钮的方法有哪些？"],["[html] 你知道微信端的浏览器内核是什么吗？"],["[html] 移动端如何实现长按保存图片（图片上的二维码是动态的）？"],["[html] 你有了解video的x5-video-player-type这个属性吗？它的作用是什么呢？"],["[html] IOS在播放视频时，有可能会出现短暂的黑屏，如何解决呢？"],["[html] 移动端如何使页面横、竖屏？"],["[html] iOS下页面如何启动加载时显示画面图片？如何设置大小？它有什么好处？"],["[html] 移动端如何设置页面以全屏模式运行？"],["[html] 解释下什么是CDATA？"],["[html] 写html代码时，如果缺少了结束标签，你如何检测及如何预防？"],["[html] 写个布局，当页面高度不够时，底部固定在下面，反之不固定"],["[html] 使用递归时应该注意哪些问题？"],["[html] canvas有哪些渲染上下文？"],["[html] 如何禁止html页面缓存？"],["[html] 举例说明html的修饰元素有哪些？"],["[html] html的标签元素分为哪几大类？分别有什么作用？"],["[html] 网站如何自适应手机屏幕？"],["[html] 列举下哪些块元素里面不能放哪些块元素呢？"],["[html] html中p标签内为何不能嵌套div标签？"],["[html] 移动端如何禁止用户手动缩放页面？"],["[html] HTML5的video怎样预加载（支持全量加载）？"],["[html] HTML5的video怎么取消自动播放？"],["[html] HTML5如何隐藏video元素的控制栏、全屏按钮？"],["[html] 如果要你实现一个代码（多种语言）高亮的组件，你的思路是什么？"],["[html] 关于iframe的跨域你有了解多少？"],["[html] https页面加载http的资源会导致页面报错的原因是什么？怎么解决？"],["[html] html5怎么判断是否在wifi环境？"],["[html] 举例说明html5怎么判断网络状态？"],["[html] html5怎么判断app是否安装？"],["[html] 移动端滚动穿透是什么原因？有哪些解决方案？"],["[html] 你知道移动端的尺寸都有哪些吗？"],["[html] 目前移动端的最小点击区域是多少呢？"],["[html] html5怎样和Native App进行交互？"],["[html] 网站上怎么实现分享到各大平台呢？"],["[html] 使用canvas生成一张分享图"],["[html] canvas画出来的图是位图还是矢量图？"],["[html] 在svg和canvas中你该如何选择？依据是什么？"],["[html] canvas的应用场景有哪些？"],["[html] 如何将图片画到canvas上？都有哪些方法？"],["[html] canvas怎么兼容IE9以下版本？"],["[html] 在使用canvas的arc绘制图像时应注意什么？"],["[html] 请说说canvas的closePath()与lineTo()的区别是什么？"],["[html] 在开发canvas时，你知道什么是非零环绕原则(nonzZero rule) 吗？"],["[html] canvas有哪些可以提升性能的优化方法？"],["[html] 怎么让整个页面从iframe中跳出来？"],["[html] 怎么让table的thead 不动，tbody出现滚动条呢？"],["[html] 如何能防止网页禁止被iframe嵌入呢？ "],["[html] HTML5图像相关的标签有哪些？"],["[html] 用什么代替html5中不再支持table的cellspacing和cellpadding属性？"],["[html] 如何防止cookie被盗用？"],["[html] html的标签<a>除了用作跳转链接外，还有哪些用途？"],["[html] 请说说什么是分区响应图？"],["[html] table由哪几部分组成？"],["[html] 浏览器怪异模式的怪异主要体现在哪方面呢？"],["[html] 说说你对IE特有的数据存储userData的理解"],["[html] 说说你对iframe属性sandbox的理解，它有什么作用呢？"],['[html] 请解释下href="javascript:void(0)"和href="#"的区别是什么？'],["[html] 怎样实现每次页面打开时都清除本页缓存？"],["[html] 说说你是怎么实现页面阻尼效果的？"],["[html] 网站的响应式和自适应有什么区别？"],["[html] 解释下为什么说html嵌套级别不宜过多？"],["[html] 说出至少十条你理解的html规范"],["[html] 如果让你带一个什么都不懂的人入门学前端，你应该怎么带他？"],["[html] 你觉得html简单吗？说说你的理由"],["[html] 说说你认为html在前端的地位怎么样？"],["[html] 当写一个复杂页面的时候，你是怎么布局的？有什么方法论吗？"],["[html] 用一句话来描述下你对html的理解"],["[html] 关于缓存你了解多少？"],["[html] 适配刘海屏的方案有哪些呢？"],["[html] HTML5对元素内容进行拼写检查用的是什么属性呢？"],["[html] wbr和br标签的区别是什么？"],["[html] 在使用HTML5时有哪些规则需要遵守？"],["[html] HTML5相比于HTML4有哪些优势？"],["[html] canvas怎么解决图片和文字模糊的问题？"],["[html] 页面加载后，表单的第一个文本框如何自动获得焦点？"],["[html] 你有了解过Applet（Java小程序）吗？"],["[html] 你有使用过marquee吗？"],["[html] HTML5中required属性有什么应用场景？"],["[html] 给单个表格的单元格设置背景色有什么方法？"],["[html] 如何自动转移到新的页面？"],["[html] 如何防止他人窃取我的源代码或图片？"],["[html] HTML的标签这么多，我要全部记住吗？如果不要怎么办？"],["[html] 如果在写HTML时漏写了闭合标签，怎么办呢？"],["[html] 举例说明表格中如何再嵌套表格"],["[html] 你是如何组织html代码的？"],["[html] 移动端点击300ms的延迟出现的原因是什么？你的解决方案是什么？"],["[html] 你有使用过picture标签吗？说说它有哪些运用场景"],["[html] 说下你对DOM树的理解"],["[html] canvas的width与height属性的值可不可以带单位？"],["[html] 你有使用过HTML5的dialog标签吗？说说看，它有什么特点？"],["[html] 解释下为什么<p> </p>会换两行？"],["[html] 你知道p标签和br标签两者的区别是什么吗？"],["[html] 如何在页面中插入TAB符号（制表符）"],["[html] 说下cookie都有哪些缺点？"],["[html] 举例说明a标签的作用都有哪些？"],["[html] 请举例说明关于html的引用标签有哪些？"],["[html] 请举例说明html支持的数学符号有哪些？"],['[html] html的标签属性bgcolor支持简写吗？如：bgcolor="#F00"'],["[html] 举例说明ul、dl、ol三个标签的区别？"],['[html] html的a标签属性rel="noopener"有什么作用？'],["[html] 怎么使用HTML5实现录音的功能？"],["[html] 主框架如何与iframe通信？如何解决跨域？"],["[html] 有哪些方法可以将图片和文字显示在同一行上呢？"],["[html] png8和png24有什么区别呢？"],["[html] placeholder如何在兼容IE？"],["[html] 举例说明如何实现浏览器桌面通知？"],["[html] HTML5如何唤醒APP？"],["[html] 如何给一个下拉选项进行分组？"],["[html] HTML5的output是非常棒的一个标签，你对它有了解吗？"],["[html] 举例说明HTML5的标签meter的用法"],["[html] 请使用纯HTML制作一个进度条"],["[html] 你有用过HTML5的track标签吗？说说它的运用场景有哪些？"],["[html] htm、html、shtml三者有什么区别呢？"],["[html] 你有用过HTML5的requestAnimationFrame吗？它运用的场景有哪些呢？"],["[html] 网站首页有大量的图片，加载很慢，要是你，你该怎么去优化呢？"],["[html] 做好的页面都有在哪些浏览器上测过？"],["[html] HTML5的哪些新特性是令你最兴奋的？"],["[html] img、input标签它们是行内元素还是块级元素？"],["[html] HTML的标签区分大小写吗？属性名区分大小写吗？"],["[html] HTML的注释有几种写法？有什么规范吗？"],["[html] 怎样给radio分组呢？"],["[html] 你知道HTML什么是单闭合标签和双闭合标签吗？为何要分为这两种呢？"],["[html] 什么是Data URI？"],["[html] 你知道有哪些常见的视频（音频）编码格式和视频（音频）格式吗？"],["[html] Shadow DOM和Virtual DOM有什么区别？"],["[html] meta的属性有哪些组成？说说它们的分别有什么作用？"],["[html] 为什么HTML5里面我们不需要DTD？"],["[html] 前端路由指的是什么？它有什么好处？它有哪些方式可以实现呢？"],["[html] xpath和dom有什么区别？"],["[html] 你有使用过HTML5的output吗？说说它的作用是什么？"],["[html] HTML5如何调用摄像头？"],["[html] 怎么检测浏览器是否支持HTML5特性？"],["[html] 举例说明如何使用纯html怎么实现下拉提示的功能？"],["[html] 你有使用过figure标签吗？说说你对它的认识，有哪些应用场景？"],["[html] 你有用过bdo标签吗？举例说明它的作用是什么？"],["[html] HTML5的video在有的移动端设备无法自动播放？怎么解决？"],["[html] HTML5有哪些存储类型？它们之间有什么区别？"],["[html] 不用h标签、css和js怎么实现多个字的字体连续放大的效果？"],["[html] 使用标签怎样对一个单词标志缩写呢？"],["[html] 说说你对small标签的认识，有哪些应用场景？"],["[html] 举例说明如何在页面中添加数学公式？"],["[html] HTML5如何使某个页面元素或整个页面可编辑？"],["[html] 怎样把整个页面中的内容设置成只读，不可编辑的状态？"],["[html] input的onblur和onchange事件区别是什么？"],["[html] 本地存储的生命周期是什么？"],["[html] 请说说viewport是什么？在什么时候下使用？有什么作用？"],['[html] 说说你对表单属性type="hidden"的理解，它的运用场景有哪些？'],["[html] SGML（标准通用标记语言）和HTML（超文本标记语言），XML（可扩展标记语言）和HTML的之间有什么关系？"],["[html] 请说说 <pre> 和 <code> 标签的区别？"],["[html] 如何实现应用缓存？说说你对manifest的理解"],["[html] form标签定义请求类型和请求地址分别是哪个属性？"],["[html] 说说你对HTML5的keygen标签的理解，它的作用是什么？"],["[html] 如何让textarea标签中的内容原格式输出？"],["[html] 请说说应用缓存中的回退和网络分别是什么？"],["[html] 如何让textarea高度自适应呢？"],["[html] HTML5的服务器(server-sent event)发送事件有什么应用场景？"],["[html] 如何刷新浏览器的应用缓存？"],["[html] Web Worker线程的限制是什么？"],["[html] canvas默认画布的尺寸是多大？怎样设置才能不会变形？"],["[html] 触发form表单自动提交的方式有哪些？"],["[html] table去除边框的方法有哪些？"],["[html] 你知道什么是锚点吗？它的作用是什么？怎么创建一个锚点？"],["[html] 请问WebSql是HTML5的一个规范吗？"],["[html] 精灵图和base64如何选择呢？"],["[html] html的button中的reset有什么作用？"],["[html] 请说说Canvas和SVG图形的区别是什么？"],["[html] 举例说明table怎么合并行和列的？"],["[html] HTML5规范将元素分为哪几个大类？分别说说它们的特点"],["[html] 使用canvas画出一个矩形"],["[html] 说说form-data、x-www-form-urlencoded、raw、binary的区别是什么？"],["[html] 请描述下application cache的更新过程？"],["[html] 你知道富文本编辑器的实现原理吗？"],["[html] 说说你对富文本的理解，你有用过哪些富文本编辑器呢？"],["[html] 有使用过HTML5的跟踪元素吗？说说你对它的理解"],["[html] frame和iframe有什么区别？"],["[html] 页面布局中的结构与表现分离，那么什么是结构？什么是表现呢？"],["[html] 怎样去除html标签之间换行产生的空格？"],["[html] 举例说明HTML5的Canvas元素有什么用途？"],["[html] 在HTML5中如何组合标题？用哪个元素？"],["[html] 你知道checkbox有几种状态吗？它们分别用来表示什么？"],["[html] HTML如何创建分区响应图？"],["[html] 什么是svg？说说svg有什么运用场景？"],["[html] 有好多网站不常用table和iframe这两个元素，知道原因吗？"],["[html] 在默认的情况下，使用h1标签呈现出什么效果？"],["[html] 网站的TDK该怎么设置？它有什么作用？"],["[html] 除了音频和视频，HTML5还支持哪些媒体标签？"],["[html] 如何在HTML5页面中嵌入音频和视频？"],["[html] 说说HTML中的<html>标签有什么作用？"],["[html] 请描述一下cookies、sessionStorage和localStorage的区别？"],["[html] 行内元素、块级元素、空(void)元素分别有哪些？"],["[html] 说说你对accesskey的理解，举例说明它有什么运用场景？"],["[html] HTML5怎么为输入框添加语音输入的功能呢？"],["[html] HTML5的页面可见性（Page Visibility）有哪些应用场景？"],["[html] 列举出你最常用的meta标签的写法和作用"],["[html] Doctype有什么作用？你知道有多少种Doctype文档类型吗？"],["[html] 写出以下几个HTML标签：字体、居中、文字加粗、下标"],["[html] HTML5标准提供了哪些新的API？你有用过哪些？"],["[html] 使用HTML5需要遵守哪些设计原则？"],["[html] 有使用过svg吗？请用svg画一个圆"],["[html] 请说说你对ISISO8859-2字符集的认识"],["[html] 请描述下元素的href和src有什么区别？"],["[html] 举例说明你对ol和ul标签的区别？它们的运用场景分别是什么呢？"],["[html] a标签的href和onclick属性同时存在时哪个先触发？"],["[html] 怎么使用HTML5来获取定位？定位不准怎么解决？"],["[html] 举例说明如何原样输出HTML代码，不被浏览器解析？"],["[html] 举例说明你对HTML5的ruby标签的理解，都有哪些应用场景？"],["[html] iframe的使用场景有哪些？"],['[html] a标签下的href="javascript:void(0)"起到了什么作用？说说你对javascript:void(0)的理解？'],["[html] 在新窗口打开链接的方法是什么？那怎么设置全站链接都在新窗口打开？"],["[html] 用HTML5实现手机摇一摇功能你有做过吗？你知道它的原理吗？"],["[html] 你有用过HTML5的Device API吗？说说它都有哪些应用场景？"],["[html] 简述下HTML的快捷键属性是哪个？并举例说明有什么用？"],["[html] HTML5的应用程序缓存与浏览器缓存有什么不同？"],["[html] 你有用过HTML5中的datalist标签吗？说说你对它的理解"],["[html] 说说你对HTML5的img标签属性srcset和sizes的理解？都有哪些应用场景？"],["[html] HTML5如何识别语音读出的内容和朗读指定的内容？"],["[html] 移动web页面如何自动探测电话号码？"],["[html] 在a标签上的四个伪类执行顺序是什么？"],["[html] favicon.ico有什么作用？怎么在页面中引用？常用尺寸有哪些？可以修改后缀名吗？"],["[html] video和audio分别支持哪些格式？"],["[html] 怎么在IE8及以下实现HTML5的兼容？"],["[html] html的a标签属性rel='nofollow'有什么作用？"],["[html] 怎样禁止表单记住密码自动填充？"],["[html] 写个例子说明HTML5在移动端如何打开APP？"],["[html] 请写出唤醒拔打电话、发送邮件、发送短信的例子"],["[html] HTML5如果不写<! DOCTYPE html> ，页面还会正常工作么？"],["[html] html直接输入多个空格为什么只能显示一个空格？"],["[html] 写出html提供的几种空格实体（5种以上）"],["[html] 什么是html的字符实体？版权符号代码怎么写？"],["[html] 有使用过HTML5的拖放API吗？说说你对它的理解"],["[html] 有用过HTML5的webSQL和IndexedDB吗？说说你对它们的理解"],["[html] src、href、link的区别是什么？"],["[html] 有用过WebGL吗？说说你对它的理解"],["[html] HTML5相对于HTML4有哪些优势？"],["[html] 你了解HTML5的download属性吗？"],["[html] 渐进式渲染是什么？"],["[html] HTML5中新添加的表单属性有哪些？"],["[html] 你有了解HTML5的地理定位吗？怎么使用？"],["[html] web workers有用过吗？能帮我们解决哪些问题？"],["[html] From表单提交时为什么会刷新页面？怎么预防刷新？"],["[html] Form表单是怎么上传文件的？你了解它的原理吗？"],["[html] Ajax与Flash的优缺点分别是什么？"],['[html] 说说你对target="_blank"的理解？有啥安全性问题？如何防范？'],["[html] 说说你对WEB标准和W3C的理解与认识？"],["[html] HTML5如何使用音频和视频？"],["[html] 页面中怎么嵌入Flash？有哪些方法？写出来"],["[html] xml与html有什么区别？"],["[html] 说说video标签中预加载视频用到的属性是什么？"],["[html] 如何让元素固定在页面底部？有哪些比较好的实践？"],["[html] 解释下什么是ISISO8859-2字符集？"],["[html] webSocket怎么做兼容处理？"],["[html] html5都有哪些新的特性？移除了哪些元素？"],["[html] title与h1、b与strong、i与em的区别分别是什么？"],["[html] 说说你对cookie和session的理解"],["[html] html5哪些标签可以优化SEO?"],["[html] HTML与XHTML二者有不同"],["[html] 用一个div模拟textarea的实现"],["[html] Standards模式和Quirks模式有什么区别？"],["[html] html和html5有什么区别呢？"],["[html] 说说你对HTML元素的显示优先级的理解"],["[html] DOM和BOM有什么区别？"],["[html] 网页上的验证码是为了解决什么问题？说说你了解的验证码种类有哪些"],["[html] 你了解什么是无障碍web（WAI）吗？在开发过程中要怎么做呢？"],["[html] 说说你对<meta>标签的理解"],["[html] 说说你对影子(Shadow)DOM的了解"],["[html] 解释下你对GBK和UTF-8的理解？并说说页面上产生乱码的可能原因"],["[html] 请说说<script>、<script async>和<script defer>的区别"],["[html] 说说你对属性data-的理解"],["[html] 关于<form>标签的enctype属性你有哪些了解？"],["[html] js放在html的<body>和<head>有什么区别？"],["[html] 谈谈你对input元素中readonly和disabled属性的理解"],["[html] 请描述HTML元素的显示优先级"],["[html] 说说你对html中的置换元素和非置换元素的理解"],["[html] 怎样在页面上实现一个圆形的可点击区域？"],["[html] 你认为table的作用和优缺点是什么呢？"],["[html] 元素的alt和title有什么区别？"],["[html] title与h1的区别、b与strong的区别、i与em的区别？"],["[html] 为什么HTML5只需要写<!DOCTYPE HTML>就可以？"],["[html] html5中的form怎么关闭自动完成？"],["[html] 常见的浏览器内核都有哪些？并介绍下你对内核的理解"],["[html] 你对标签语义化的理解是什么？"],["[html] viewport常见设置都有哪些？"],["[html] 浏览器内多个标签页之间的通信方式有哪些？"],["[html] 简述下html5的离线存储原理，同时说明如何使用？"],["[html] iframe框架都有哪些优缺点？"],["[html] label都有哪些作用？并举相应的例子说明"],["[html] 简述超链接target属性的取值和作用"],["[html] HTML5的文件离线存储怎么使用，工作原理是什么？"],["[html] HTML全局属性(global attribute)有哪些（包含H5）？"],["[html] html的元素有哪些（包含H5）？"],["[html] 页面导入样式时，使用link和@import有什么区别？"]]},{name:"css",data:[["[css] 使用纯CSS3将图片反转"],["[css] CSS中怎样把“【】”左右倒立，变为上下呢？"],["[css] 使用css画一个抖音的logo"],["[css] 使用纯css制作一个签名板"],["[css] 你有使用过resize属性吗？它有什么用途？"],["[css] 使用css实现一个曲线路径动画"],["[css] 使用css实现一个条纹边框"],["[css] 实现一个左边竖条"],["[css] 什么是 CSS Motion Path 运动路径？"],["[css] css的属性@Property有什么用途？"],["[css] 你有使用过伪元素::marker吗？它有什么用途"],["[css] 引用第三方的css安不安全？为什么？"],["[css] 使用CSS将列表的项使用逗号分隔显示"],["[css] 隐藏元素的background-image会加载吗？"],["[css] 使用css3画一个26个英文字母的旋转动画特效"],["[css] 说说你对css特指度的理解"],["[css] 为什么要初始化CSS样式？"],["[css] 使用css画一个梯形"],["[css] 使用css3画一个小火车动画"],["[css] 使用flex布局实现一左一右对齐"],["[css] 使用CSS3实现电影投影仪动画"],["[css] 写一个加入购物车时的飞行动画特效"],["[css] 使用CSS制作一个音阶动画特效"],["[css] 使用CSS3+SVG绘制一只哆啦a梦机器猫头像"],["[css] 使用CSS3+SVG绘制一只唐老鸭"],["[css] 使用CSS3+SVG绘制时间沙漏动画特效"],["[css] 使用CSS3绘制天狗食月日食动画特效"],["[css] 使用CSS3+SVG绘制沿固定路径飞行的纸飞机"],["[css] 使用CSS3绘制一杯冒热气的咖啡动画"],["[css] 使用CSS3绘制一只愤怒的小鸟卡通形象"],["[css] 使用CSS3绘制一只卡通小蜜蜂的动画特效"],["[css] 使用CSS3绘制一辆可以运动的自行车动画"],["[css] 使用CSS3实现柱状图效果"],["[css] 使用CSS3实现折线图效果"],["[css] 使用CSS3实现饼形图效果"],["[css] 使用CSS3实现星系轨道旋转特效"],["[css] 使用CSS3实现文字带轮廓边框特效"],["[css] 使用CSS3实现立体文字重叠特效"],["[css] 使用CSS3实现牛顿摇摆球动画"],["[css] 使用CSS3实现空中飘动的云朵动画"],["[css] 使用CSS3实现一只在飞的蝴蝶"],["[css] 使用CSS3实现星系轨道旋转特效"],["[css] 使用CSS3+SVG实现点火发射的动画"],["[css] 使用css3绘制一颗仙人掌"],["[css] 使用CSS3实现一个复古播放电影倒计时的特效"],["[css] 使用css3实现一个开关灯按钮的动画特效"],["[css] 使用css3实现一个大白的特效"],["[css] 使用css3实现一个奶油雪糕的图形特效"],["[css] 使用css3绘制转动磁带的复古录音机特效"],["[css] 使用css3绘制冒热气的杯子动画特效"],["[css] 使用css3实绘制3D骰子多角度翻转特效"],["[css] 使用css3绘制卡通雪人特效代码"],["[css] 使用css3绘制在道路上行驶的汽车动画特效"],["[css] 使用css3绘制一只招财猫动画特效"],["[css] 使用css3绘制企业人员管理树形组织架构图特效"],["[css] 使用CSS3实现的湖面上日出动画特效"],["[css] 使用CSS3外星飞船UFO动画"],["[css] 使用CSS3实现摩天轮动画特效"],["[css] 使用CSS3实现萤火虫发光动画效果"],["[css] 使用CSS实现月亮围着地球转动的特效"],["[css] 使用CSS3实现一个随机粒子动画效果"],["[css] 使用CSS3实现一个齿轮动画效果"],["[css] 使用CSS3实现下红包雨的特效"],["[css] 使用CSS3实现波浪式图片墙"],["[css] 使用CSS3实现百叶窗效果"],["[css] 使用CSS3实现不规则排列lightbox效果"],["[css] 使用CSS3实现动态信封折叠效果"],["[css] 使用CSS3实现响应式win8 metro风格的页面"],["[css] 使用CSS3实现照片左右飞入滑出切换"],["[css] 使用CSS3实现3D小球动画效果"],["[css] 使用CSS3实现一个仿相机快门闪动的效果"],["[css] 使用CSS3实现模拟雷达波向外发散的动画效果"],["[css] 使用CSS3实现立体图片旋转的特效"],["[css] 使用CSS3实现模拟扑克牌切换的效果"],["[css] 使用CSS3实现全屏颗粒的动画效果"],["[css] 使用CSS3实现图片放大镜动画效果"],["[css] 使用SVG+CSS3制作一个圆形倒计时滚动条效果"],["[css] 使用CSS3制作立体式3D旋转的动画效果"],["[css] 使用CSS3模拟太阳、地球、月球旋转的特效"],["[css] 纯CSS实现一个梅花图案"],["[css] 使用纯CSS制作一个右上角倾斜四十五度封页角效果"],["[css] 使用Canvas制作一个火焰跟随鼠标的动画"],["[css] 使用纯CSS3实现大象走路的动画"],["[css] 使用CSS3写一个图片左右切换的弹性动画"],["[css] 写一个风扇的动画"],["[css] CSS的auto是什么意思？"],["[css] css的动画库你有哪过哪些？哪个比较好？为什么？"],["[css] css中如何定义及使用变量？"],["[css] 使用纯CSS3实现圆圈加载的动画"],["[css] 你用css写过最酷的特效是什么？"],["[css] 实现一个车辆雨刮器的特效"],["[css] 使用css实现文字抖动"],["[css] 绘制一个树木的年轮"],["[css] 解释下transform-style的用途"],["[css] 把鼠标指针放到某div元素上，其宽度会从50px逐渐变为200px"],["[css] 轮廓outline占不占用空间？"],["[css] 如何使用css实现背景虚化？"],["[css] css4你有听说过吗？你最期待的css4拥有什么样的新特性？"],["[css] 写一个鼠标经过头像时，头像旋转180度并放大2位，离开时恢复原样的特效"],["[css] 写一个隔行变色的样式"],["[css] 实现一个动态的星空特效"],["[css] 使用纯CSS实现多行文本展开收起效果"],["[css] 说说在Grid布局中grid-template-columns与grid-template-row中auto的解释"],["[css] 你有使用过grid-template-columns属性吗？说说它的用途"],["[css] flex中align-content与align-items有什么区别？"],["[css] 你有使用过stop-color属性吗？说说它的用途"],["[css] 你有使用过outline-color属性吗？说说它的用途"],["[css] 你有使用过lighting-color属性吗？说说它的用途"],["[css] 你有使用过flood-color属性吗？说说它的用途"],["[css] 你有使用过caret-color属性吗？说说它的用途"],["[css] 使用纯css画一副碗筷"],["[css] 使用纯css画一束玫瑰花"],["[css] 如果一个交互有多种方法可以做到，你是基于什么原因选择哪种方法的？"],["[css] 请问Render Tree和CSSOM Tree有何区别？"],["[css] css中父元素高度塌陷是什么？如何解决？"],["[css] 在Less中,命名空间和访问器有什么作用？"],["[css] css3的动画你觉得难吗？为什么？"],["[css] 写一个方法将多个数组合并成一个数组"],["[css] 如何使用position:relative内的absolute元素水平和垂直居中？"],["[css] 画一只飞行中的小鸟"],["[css] 使用css制作一个龙卷风的动画效果"],["[css] z-index默认值为多少呢？"],["[css] 写一个小球上下跳动的动画"],["[css] 对非可点击元素如(span)的click事件在有些手机上不触发如何解决？"],["[css] 使用css画一个椭圆"],["[css] 如何去除ios下的input框的内阴影？"],["[css] padding-top、padding-bottom值设置为百分比时，依据的是父级的height吗？"],["[css] 说说字体图标的三种方式有什么区别？（unicode/font-class/symbol）"],["[css] flex:1表示什么？"],["[css] 使用flex实现一行显示固定几块，强制换行且均匀分布"],["[css] 使用css写一个套娃的动画"],["[css] 使用css画一个旋转的风车"],["[css] 你喜欢用flex吗？为什么？"],["[css] 使用css写一个水滴下落的动画"],["[css] 用css画一把带刻度的尺寸"],["[css] 用css简画一个行走的人动画效果"],["[css] 写一个输入框聚焦时，边框不停地渐变的动画效果"],["[css] 使用CSS3写一个下划线跟随动画菜单的动画效果"],["[css] 使用css实现圆形的头像的效果（注：要考虑正方形、长方形情况）"],["[css] 使用css画一个旗帜"],["[css] CSS如何将彩色图片变为黑白图片？"],["[css] 使用css的哪些方法可以提高页面的渲染速度？"],["[css] 说说你对CSS Painting API的理解"],["[css] 使用css画一个半透明的吸管"],["[css] 写一个风扇转动的动画"],["[css] 你有用过appearance属性吗？说说你对它的理解"],["[css] css如何监听屏幕的旋转？"],["[css] rem和px的换算规则是怎样的？"],["[css] 画一个不停发出不同光的球"],["[css] 请说说哪种交互特效是用纯CSS做不到的？"],["[css] 给一段文字自动定时变色"],["[css] px、em、rem、rpx区别和为什么使用62.5%；"],["[css] css的高级选择器有哪些？"],["[css] 书写css时为什么要先写position,width, height的大小位置的属性， 后写color, bgcolor等之类的属性"],["[css] 多行文本在固定高度的div中如何做到垂直居中？"],["[css] css如何实现滚动条隐藏但鼠标仍然可以滚动？"],["[css] 为什么在Calc()方法中必须用或者包含空格？"],["[css] 画一个爱心逐渐放大再缩小的循环的特效"],["[css] 举例说明css中负值有哪些好玩的特性"],["[css] 请说说z-index最大值和最小值分别可以设置为多少？为什么？"],["[css] 使用css实现一个毛玻璃效果"],["[css] 说说你对text-transform属性的理解"],["[css] 说说你对transition-timing-function属性的理解"],["[css] word-spacing有什么作用？"],["[css] 说说你对-webkit-touch-callout属性的理解"],["[css] 说说你对-webkit-overflow-scrolling属性的理解"],["[css] 说说你对:-webkit-autofill的理解"],["[css] 使用css写一个获取ul下的第3到第15个li的元素"],["[css] border-radius是多可以赋多少个值？"],["[css] 你有使用过supports吗？说说它的用途"],["[css] 你有使用过css的all属性吗？它有什么好处及使用场景？"],["[css] 说说你认为的css黑科技有哪些？"],["[css] 你有使用过padding-bottom属性吗？说说它的用途"],["[css] 使用@keyframes加载图片首次循环时出现白色间隙的问题如何解决？"],["[css] 写一个边框闪烁呼吸的样式"],["[css] 使用css使得一个元素一闪一闪的"],["[css] 使用css实现类似苹果手机的暗黑模式"],["[css] 写一个烟花的特效"],["[css] 你有使用过display:box属性吗？说说它的作用"],["[css] 使用css制作一个手机充电黏黏球效果"],["[css] 使用css制作一个手机充电的动画特效"],["[css] 你有使用过aspect-ratio的新属性吗？说说你对它的理解"],["[css] border-image-slice属性有什么作用？"],["[css] 如何使用border-image给边框添加图片"],["[css] 你有使用过mask属性吗？请说说它的用途"],["[css] 你有使用过css-doodle吗？说说它的作用是什么？"],["[css] 使用纯css使得两个背景叠加"],["[css] 使用纯css画一个角向渐变的背景"],["[css] 如何让IE6支持PNG透明？"],["[css] 使用纯css画一个径向渐变的背景"],["[css] 使用纯css画一个线性渐变的背景"],["[css] 使用css画个动态的泳池特效"],["[css] 设置元素为display:flex后，哪些属性会失效呢？为什么？"],["[css] flex是哪些属性的简写呢？"],["[css] 说说display:flex和display:inline-flex有什么区别？"],["[css] input标签改变高度的同时如何使光标定位在左上角（不使用textarea）"],["[css] 使用css画一个羽毛球场地图"],["[css] css和wxss有什么区别？"],["[css] 如何让span在div中垂直居中？"],["[css] 使用绝对定位position:absolute;后，就不能使用margin: 0 auto;实现居中，为什么呢？如何解决？"],["[css] ::before和::after它们的使用场是什么？"],["[css] 如何给字体设置阴影效果？"],["[css] 如何将数字设为等宽？"],["[css] 如何将文字设为等宽？"],["[css] 使用css实现导航栏左右滑动"],["[css] 请使用纯css画出一条虚线，并设置虚线的间隙（不能使用图片）"],["[css] 使用css制作一个圣诞树"],["[css] 使用纯的css如何定义变量？请举例说明"],["[css] 用css画一个篮球场地图"],["[css] 用css画一个羽毛球场地图"],["[css] 用css画一个足球场地图"],["[css] 如何隐藏鼠标在某个区域内的光标？"],["[css] 用css隐藏input的光标"],["[css] 用纯CSS实现判断鼠标进入的方向"],["[css] 写的css样式是否能被js所读到？如果可以如何读取？"],["[css] 你有使用过css的clamp函数吗？说说它有什么用途？"],["[css] 你有写过Less的插件吗？"],["[css] 在LESS中如何定义变量上下文中的范围？"],["[css] 在Less中命令行里编译的命令是什么？"],["[css] 在Less中“Source Map Less Inline”选项代表什么？"],["[css] 在Less中数据URI的作用是什么？"],["[css] 如何在Less中创建循环结构？"],["[css] 在Less中有哪些不同类型的函数？"],["[css] 在Less中有哪些注释方式？"],["[css] 在Less中支持运算符吗？"],["[css] 在Less中什么是＆combinator？"],["[css] 在Less中使用extend有什么用？"],["[css] 在Less中是如何导入的？"],["[css] 在Less中e()函数的目的是什么？"],["[css] 在Less中使用命名空间和访问器有什么作用？"],["[css] 把Less编译为CSS的最佳方法是什么？"],["[css] 在Less中的颜色通道功能是什么？"],["[css] Less可以不通过编译直接在浏览器中使用吗？如何使用？"],["[css] 在Less中有哪些常用的函数？"],["[css] 在Less中转义有什么作用？"],["[css] 在Less中的Mixins有什么作用？"],["[css] 在Less中的嵌套作用是什么？"],["[css] Less变量的种类有哪些？"],["[css] 在Less中怎样使用变量？如何定义？"],["[css] 使用Less有哪些方式？"],["[css] Less的原理是什么？"],["[css] Less文件的扩展名是什么？"],["[css] Less现在最新的版本是使用的是什么语言编写的？"],["[css] 你知道Less刚出来时是用哪种语言编写的吗？"],["[css] Sass和Less有什么相同点？"],["[css] Sass脚本支持哪些数据类型？"],["[css] 在Sass中Mixin有什么应用场景？"],["[css] 怎样使用Sass的Mixin功能？"],["[css] Sass中什么是括号运算？"],["[css] 在Sass中如何执行布尔运算？"],["[css] Sass的色彩操作是什么？"],["[css] Sass的数字操作是什么？"],["[css] Sass中的@import函数有什么作用？"],["[css] Sass中如何编写占位符选择器？"],["[css] 如何定义一个Sass变量？"],["[css] 用于检测Sass中的错误是哪个指令？"],["[css] Sass中的@extend指令有什么作用？"],["[css] Sass中的@media指令有什么作用？"],["[css] Sass中的at-root指令有什么作用？"],["[css] 请解释下Sass中的嵌套规则是什么？"],["[css] Sass的注释和css注释之间有什么区别？"],["[css] Scss和Sass有什么区别？"],["[css] 你喜欢Sass还是Less？为什么？"],["[css] 你最喜欢Sass的原因是什么？"],["[css] css3的属性transfrom的值preserve-3d和perspective有什么区别？"],["[css] 你是如何检查css语法是否正确的？有哪些方法？"],["[css] css变量有哪些浏览器支持？"],["[css] 怎样在SVG中使用css变量？"],["[css] 怎样在@keyframes中使用CSS变量"],["[css] css变量区分大小写吗？"],["[css] css变量受哪些影响？"],["[css] css变量和预处理器中的变量有什么不同？"],["[css] css变量属性有什么用途？有什么优缺点？"],["[css] 说说你对css变量（自定义属性）的理解？"],["[css] css的属性list-style-position的值outside和inside有什么区别？"],["[css] 如何去掉em的默认样式？"],["[css] 说说你对screen.width伪响应式的理解"],["[css] 移动端开发时你了解淘宝的lib-flexible方案吗？它的原理是什么？"],["[css] pc端和移动端使用两套布局和使用一套自适应布局分别有哪些优缺点？"],["[css] 要开发一个pc端和移动端的自适应布局网站，说说你的方案是什么？"],["[css] 解释下使用2倍图片，有什么优缺点？"],["[css] 解释下为什么在移动端切图时会有使用到2倍图片呢？"],["[css] 请使用css column写一个多列布局"],["[css] 说说你对css3属性column的理解"],["[css] 如何判断dpr的倍数？"],["[css] css中如何获取dpr值？"],["[css] 元素包含块有什么作用？"],["[css] 如何确定元素的包含块？"],["[css] 说说你对css包含块的理解"],["[css] 你知道css压缩的方法和原理是什么吗？请描述一下"],["[css] 你觉得在css中如果值是0时写单位好还是不写好呢？为什么？"],["[css] 解释下为什么css中值为0时可以不写单位吗？"],["[css] css unicode字符集使用时要注意哪些问题？"],["[css] css unicode字符集有哪些分类？"],["[css] 如何去掉button的点击样式？"],["[css] 如何让子元素不继承父元素的:hover效果？"],["[css] 如何清除input元素聚焦时的边框"],["[css] 如果设置一个元素的字体为：font-size:18，没有写单位px，那么会默认有px的单位吗？"],["[css] 为什么有时候给元素设置宽度不起作用呢？"],["[css] 举例说明哪些css属性可以简写？"],["[css] 如果元素宽度不够时，如何使得长串单词不会被截断？"],["[css] 举例说明如何控制中文不换行？"],["[css] 控制换行的属性有哪些？"],["[css] 你感觉css哪块的知识点最难掌握？为什么？"],["[css] 如何垂直居中一个浮动的元素？"],["[css] 通过CSS的定位有几种，分别相对于什么定位？"],["[css] 如何创建块级格式化上下文(block formatting context),BFC有什么用"],["[css] 你有使用过touch-action属性吗？说说它的用途"],["[css] 你自认为自己的css水平如何？还有哪些是用css实现不了的？"],["[css] 请使用css实现一个小波纹的效果"],["[css] 你是如何对 CSS 和 JavaScript 代码组织的？有哪些原则？"],["[css] font-weight的默认值是多少？"],["[css] 使用css实现模糊的效果"],["[css] 使用css实现描边效果"],["[css] 使用css实现浮雕效果"],["[css] css中定义class时，中间有空格和没空格的区别是什么？"],["[css] 写一个特效：鼠标经过文字时，文字旋转360度"],["[css] 以前我们都提倡把css通过外部引入，但现在使用webpack时往往会和html打包在一起？这是为什么呢？"],["[css] 在什么情况下，用translate()而不用绝对定位？反之呢？请说明理由"],["[css] css预处理器的优点和缺点是什么？"],["[css] 请问下，居中为什么尽量用transform，而不用margin+left(top)？"],["[css] 请解释下float的工作原理"],["[css] 请描述一下网页的层叠等级(z-index)？"],["[css] 请解释下outline-offset属性有什么作用？"],["[css] 如何清除li列表的符号，改成图片背景"],["[css] 说说你对Bootstrap网格系统的工作原理的理解"],["[css] 合并CSS的方法有哪些？"],["[css] 可以改变页面布局的属性有哪些？"],["[css] 行内元素float:left后是否变为块级元素？"],["[css] 使用css3制作一个鼠标经过文本时，显示出边框的动画特效"],["[css] 使用css制作出一个星星"],["[css] 解释下1px、1rem、1em、1vh代表的含义分别是什么？"],["[css] 你有使用过@support吗？说说你对它的理解"],["[css] 你在使用calc过程中遇到过哪些坑？如何解决？"],["[css] 简述下Flex的容器和项目的概念"],["[css] 如何实现gif动图的暂停和播放？"],["[css] 请说说width: auto和width: 100%有什么区别？"],["[css] 伪类选择器和伪元素选择器有什么区别？"],["[css] 解释下为什么说通配符选择器要慎用？"],["[css] 给兄弟元素的标签设置红色"],["[css] 举例说明BFC有什么应用场景"],["[css] 使用纯css布局中一个“王”字"],["[css] 解释下BFC、IFC、GFC、FFC的区别是什么？"],["[css] 怎样解决float元素无法撑起父级容器的高度？"],["[css] 使用了float的标签，如何避免左侧贴边重叠？"],["[css] 使用flex实现一行有多个不等的标签元素宽度平均分配"],["[css] 怎么让position:fixed相对于父元素定位？"],["[css] 为什么代码中两个display属性为inline-block的元素之间有多余字符（包括换行、制表符等）会造成页面中这两个元素之间有空隙？解决方案是什么？替代方案又都有哪些？"],["[css] justify-content的space-between与around有什么区别？"],["[css] css如何去掉i标签默认的斜体？"],["[css] fixed定位脱离文档流与float有什么区别？"],["[css] 哪些方式使得position:fixed定位的基准元素改变？"],["[css] Fixed定位如果脱离Viewport会产生什么样的bug？如何解决？"],["[css] 如何创建stacking context？"],["[css] 分离图层做动画有什么优点？"],["[css] 使用css3动画代替js的动画有什么好处？"],["[css] 如何取消同级li的最后一个li标签的右边距？"],["[css] 请说说css常用的单位和不常用的单位分别有哪些？"],["[css] flex:1与flex:auto有什么区别？"],["[css] 简写的flex:1的完整写法是什么？"],["[css] 使用css实现一个弹幕的效果"],["[css] grid布局和flex布局有什么区别？"],["[css] 你有使用过grid布局吗？说说你对它的理解"],["[css] 使用css制作鼠标经过图片时，放大图片1.5倍"],["[css] 使用css制作吊扇转动的效果"],["[css] 使用css3实现小车行驶的动画效果"],["[css] 使用css实现闪光的霓虹灯文字效果"],["[css] 说说CSS对元素属性赋值的详细过程？"],["[css] 使用css3制作雪花效果"],["[css] 你最不喜欢css的哪些特性是什么？为什么？"],["[css] 在工作中有没有遇到过哪些前端样式你是用css做不出来的？做不出来怎么办？"],["[css] 当你忘记某个css时，你是如何解决的？"],["[css] 你现在还会经常学习css的新知识吗？"],["[css] 你觉得css高级的特性有哪些？"],["[css] 你是怎么学习css的？说说你的学习方法"],["[css] 你最喜欢的是哪个css特性？为什么？"],["[css] 你现在还经常写css代码吗？"],["[css] 使用css3制作下雨动画的效果"],["[css] 在不可替换元素上使用width/height/margin/padding会有什么样的表现？"],["[css] 我们使用第三方的css安全吗？为什么？"],["[css] 使用display: table-cell有什么应用场景呢？"],["[css] 如何优化打印样式？"],["[css] css加载会阻塞js运行吗？"],["[css] css加载会阻塞DOM树渲染吗？"],["[css] css加载会阻塞DOM树解析吗？"],["[css] 什么情况下会出现css阻塞？"],["[css] position的relative和absolute分别是相对谁进行定位的？"],["[css] 请说说position:absolute和float有什么不同？"],["[css] 当css中background或background-image的值为url()或url(#)时，会发生什么情况？为什么？如何解决？"],["[css] 请举例说明width:fit-conten有什么使用场景"],["[css] margin属性的负值  在inline-block元素下是如何表现的？"],["[css] 使用flex实现一个自适应的九官格"],["[css] rem的弊端是什么？"],["[css] 举例说明pointer-events有什么实际用途？"],["[css] css穿透属性有哪些？"],["[css] css中的fill有什么应用场景？"],["[css] 解释下z-index最大值和最小值可以设置为多少呢？"],["[css] z-index可以是负数吗？"],["[css] 不加class和id使得倒数三个li背景色为红色"],["[css] 在css中哪个属性会影响DOM读取文档流的顺序？"],["[css] css在页面上画一个正方形，边长为页面宽度的一半"],["[css] 举例说明photoshop中的设置与css哪些属性是对应的呢？"],["[css] 如何实现css隔离？"],["[css] 使用text-align: justify怎么让单行也起作用？"],["[css] 用css实现两端对齐text-align: justify有什么不足之处？"],["[css] 如何设置字体之间的间隙？"],["[css] 说说你对在web端图片清晰和模糊的理解"],["[css] 如何使两张图片叠加？"],["[css] 1in等于多少mm？1mm等于多少px？"],["[css] @media print可以用来控制web打印样式吗？"],["[css] page-break-before和page-break-after属性有什么应用场景？"],["[css] 有使用过css的images-set吗？它能解决什么问题？"],["[css] css variable的使用方法和好处有哪些？"],["[css] 请说说css的三大特性是什么？"],["[css] css子元素会继承父元素的font-size吗？请解释下面父子元素各字体的大小[代码]"],["[css] 你有用到以pt为单位过吗？pt单位有什么应用场景呢？"],["[css] 如何设置字体的左右间距？"],["[css] 使用css如何拉伸字体？"],["[css] 写出固定子容器在固定的父容器下水平垂直居中的布局"],["[css] 在固定宽度的div下，怎么让字体自适应大小，不超出宽度，也不要换行"],["[css] 怎样把单位cm转换成px呢（在打印时有时会用到）？"],["[css] flex与其他有什么不同，用它有什么好处？"],["[css] pseudo-class与pseudo-element有什么区别？"],["[css] 行内元素可以设置padding和margin吗？"],["[css] 如果要你自己设计一个css框架，说说你的思路"],["[css] 使用css3画个旋转的立方体"],["[css] translate3D有什么作用？"],["[css] BFC与IFC有什么区别？"],["[css] 举例说明BFC会与float元素相互覆盖吗？为什么？"],["[css] 如何形成BFC？"],["[css] 为什么float会导致父元素塌陷？"],["[css] 什么是逐帧动画？"],["[css] 什么是关键帧动画？"],["[css] 实现一个下拉不到底的橡皮筋效果"],["[css] 如何取消页面中选中的文字？"],["[css] 为什么伪类的content不能被选中？"],["[css] 举例说说你对white-space属性的理解"],["[css] ::first-letter有什么应用场景？"],["[css] 使用css画一个饼图的效果"],["[css] 使用css如何设置背景虚化？"],["[css] 举例说明background-repeat的新属性值：round和space的作用是什么？"],["[css] 举例说明with属性的fill-available有什么应用场景？"],["[css] width属性的min-content和max-content有什么作用？"],["[css] 你用过outline属性吗？它有什么运用场景？"],["[css] 为什么说css的选择器一般不要超过三级？"],["[css] 使用纯CSS实现3D按钮效果"],["[css] 使用css实现太阳自转同时地球围着太阳公转的效果"],["[css] 你有用过animation-fill-mode属性吗？它有什么应用场景？"],["[css] 当display:flex遇到white-space nowrap会对布局有什么样的影响？如何解决？"],["[css] 用css实现一个等腰三角形的小图标"],["[css] 使用css实现蒙版的效果"],["[css] 使用css实现手风琴的效果"],["[css] 父元素下有子元素，子元素也有高度但父元素的高度为何为0呢？分析下可能出现的原因及解决方法"],["[css] 假如css的分号写在声明块之外，将会发生什么呢？解释下原因[代码]"],["[css] 如何阻止:hover、:active等鼠标行为状态的触发？"],["[css] 在响应式布局中，如何使用纯css使得块元素等比缩放？"],["[css] 用css画一个平行四边形"],["[css] H5如何禁止显示系统菜单？"],["[css] 如何让表格单元格等宽显示？"],["[css] 固定的外框尺寸，里面的图片尺寸不固定，如何让图像自适应外框呢？"],["[css] 不用换行的标签，怎么伪元素实现换行的效果？"],["[css] 给一个图片设置透明有哪些方式呢？"],["[css] box-sizing的宽度包含了哪些？"],["[css] 判断如下边框的颜色，并解释为什么[代码]？"],["[css] 如何使用伪元素实现增大点击热区来增加用户体验？"],["[css] 怎么给手持设备添加特殊样式？"],["[css] 如何使用css显示a链接的url？"],["[css] css中的url()要不要加引号？说说你的理解"],["[css] 使用css写一个垂直翻转图片的效果"],["[css] 请写出font属性的快捷写法"],["[css] 举例说明与打印有关的属性有哪些？"],["[css] 如何让背景图片固定不随滚动条滚动？"],["[css] 你用过css的tab-size属性吗？浏览器默认显示tab为几个空格？"],["[css] clear属性只对块级元素有效么？为何无法应用于行内元素？"],["[css] css的负边距有哪些应用场景？"],["[css] 你了解CSS Houdini吗？说说它的运用场景有哪些？"],["[css] 使用css画个镰刀形的月亮"],["[css] 使用css写一个红绿灯交替的动画效果"],["[css] 除了可以用js跟踪用户信息外，如果不用js，使用纯css怎么做呢？"],["[css] 当拿到一个新的项目，让你对这个项目的css做下架构设计，你该如何下手？"],["[css] 表列举一些你认为最“昂贵”的css属性并解释为什么"],["[css] 为什么说css的选择器是从右向左匹配？"],["[css] 使用css实现霓虹灯效果"],["[css] :placeholder-shown和:focus-within这两个伪类你有使用过吗？说说看"],["[css] 使用css实现气泡框的效果"],["[css] 说说sroll-snap-type属性的运用场景有哪些？相关联的属性还有哪些？"],["[css] 使用css实现一个loading的效果"],["[css] 你有使用过css的混合模式mix-blend-mode和background-blend-mode吗？"],["[css] 使用负文本缩进text-indent: -9999px时有没有遇到过什么奇怪的问题呢？怎么解决？"],["[css] 你会经常用到伪元素吗？一般都用在哪方面？"],["[css] 用css画出一把刻度尺"],["[css] 说说position:sticky有什么应用场景？"],["[css] 如何使用css给一个正方形添加一条对角斜线？"],["[css] 举例说明CSS特性检测的方式有哪些？"],["[css] 你们团队中css的class命名采用的是什么方式呢？下划线还是横线还是驼峰？"],["[css] 使用纯css画出一个右侧滚动顶部进度条的效果"],["[css] 一个项目中有很多无用的css代码，怎么找到并清除这些无用的代码？"],["[css] 写出在不固定宽高的元素在固定高度的情况下水平垂直居中的方法"],["[css] 使用css画一根燃烧中的蜡烛"],["[css] 使用css画个鸡蛋"],["[css] CSS content属性特殊字符有哪些？"],["[css] 用css画出一个圆圈，里面有个叉号（不能用英文字母x）"],["[css] 用css画出一个圆圈，里面有个对号"],["[css] 用css画出两个大圆相交，可以在各自圆及相交部分输入文字"],["[css] 用css画出中间一个大圆，四周有12个小圆环绕并和大圆是同心"],["[css] 如何解决html设置height：100%无效的问题？"],["[css] css的height:100%和height:inherit有什么区别？"],["[css] css如何让height:100%起作用？"],["[css] 用css3实现伪3D的文字效果"],["[css] 用css3实现文字发光的效果"],["[css] 你有使用过css的属性background-blend-mode吗？说说它的运用场景有哪些？"],["[css] 如何使用css实现鼠标跟随？"],["[css] 能不能使用纯css使你的浏览器卡死？怎么实现？"],["[css] 为什么说对opacity进行动画要比box-shadow进行动画性能更好呢？"],["[css] 请问class与[class=xxx]的区别是什么？两者是否等价？"],["[css] 请使用纯css实现波浪效果"],["[css] 有哪些标签是不支持伪元素的？"],["[css] 如何重写行内样式？方法有哪些（至少两种）？"],["[css] 用css3画出一个立体魔方"],["[css] 举例说明shape-outside的属性的用途有哪些？"],["[css] ui设计中px、pt、ppi、dpi、dp、sp之间的关系？"],["[css] 使用css画个钟表的时间刻度"],["[css] 请使用css3实现图片的平滑转换"],["[css] 使用纯css能否监控到用户的一些信息？怎么实现？"],["[css] 在一个项目里，你是如何组织(架构)css代码的？"],["[css] 为了减小css文件的大小，怎么去除无用css呢？有哪些方法？"],["[css] css的加载会阻塞js运行吗？为什么？"],["[css] css的加载会阻塞DOM树解析和渲染吗？为什么？"],["[css] 异步加载CSS的方式有哪些？"],["[css] 举例说明如何从html元素继承box-sizing？"],["[css] 使用css的attr()写一个类似a标签title的提示框"],["[css] 鼠标事件css的:hover和js的mouseover有什么区别？"],["[css] 举例说明你对指针事件（pointer-events）的理解"],["[css] 如何用css实现把“我不爱996”变成“699爱不我”？"],["[css] scroll-snap-align属性的应用场景是什么？"],["[css] css中Scroll-behavior属性有什么应用场景？"],["[css] 你有使用过css的writing-mode属性吗？说说它有哪些应用场景？"],["[css] 使用css实现对话气泡的效果"],["[css] 如何隐藏没有静音、自动播放的音视频？"],["[css] 怎么使用css选择空链接？"],["[css] 说说你对table-layout的理解，它有什么运用场景？"],["[css] 颜色hsla的字母分别表示什么？"],["[css] 如何禁用移动的选择高亮？"],["[css] 使用css实现悬浮提示文本"],["[css] 怎么设置可点击的元素上强制手型？"],["[css] 如何使用css实现跨浏览器的最小高度？"],["[css] 使用css3实现一个斑马线的效果"],["[css] 使用纯css来创建一个滑块"],["[css] 用css画一个五边形和一个六边形"],["[css] 你有没有使用过“形似猫头鹰”（例：* + *{ ... }） 的选择器？"],["[css] 为什么说css中能用子代选择器的时候不要用后代选择器？"],["[css] 如何给文字的color设置渐变"],["[css] 如何在白天和黑夜自动切换页面的颜色？"],["[css] CSS中哪些属性会引起GPU渲染，会增加耗电吗？"],["[css] flex布局的缺点有哪些？（除兼容性外）"],["[css] OOCSS有哪些好处？对应的库有哪些？"],["[css] 你知道什么是面向对象的css（oocss）吗？有没有实践过？"],["[css] 如何解决IE6浮动时产生双倍边距的BUG？"],["[css] 如何让IE6支持min-width和max-width？"],["[css] 什么是hack？css的hack有哪些？"],["[css] padding会影响到元素的大小，那不想让它影响到元素的宽度应该怎么办？"],["[css] 说说你对相对定位、绝对定位、固定定位的理解"],["[css] css中的选择器、属性、属性值区分大小写吗？"],["[css] img标签是行内元素，为什么却能设置宽高？"],["[css] 如何禁止长按保存或复制图像？"],["[css] css的height:100%和height:inherit之间有什么区别呢？"],["[css] css的哪个属性可以把所有元素或其父元素的属性重置呢？"],["[css] 如何取消从父级元素继承下来的CSS样式呢？"],["[css] 说下你对css样式的这几个属性值initial、inherit、unset、revert的理解"],["[css] 如何解决css加载字体跨域的问题？"],["[css] 当使用@font-face的时候，为什么src中要加入local呢？"],["[css] 你有使用过font-size-adjust属性吗？说说它的作用是什么？"],["[css] body{height:100%}和html,body{height:100%}有什么区别？为什么html要设置height:100%呢，html不就是整个窗口吗？"],["[css] 你所理解的css高级技巧有哪些？"],["[css] 举例说明跟字体相关的属性有哪些？"],["[css] 你知道字体所拥有的字重的数量和font-weight的数值字重是什么对应关系吗？"],["[css] 字体的粗细的属性是用哪一个？它有哪些属性值？"],["[css] 用CSS实现一个轮播图"],["[css] 用CSS实现tab切换"],["[css] 移动端1px像素的问题及解决方案是什么？"],["[css] 如何将元素的所有css属性恢复为初始化状态？"],["[css] 使用纯css实现一个rate评分的功能"],["[css] css中的baseline，你知道吗？"],["[css] 你知道什么是动态伪类吗？"],["[css] 使用css3绘制一个QQ小企鹅的LOGO"],["[css] 使用css3画一个扇形"],["[css] 请使用css3来模拟中/英文打字的效果"],["[css] 使用css3绘制一个圆形动态的时钟"],["[css] 使用css将图片转换成黑白的效果"],["[css] 说说你对css的合成与混合模式的理解"],["[css] 一个页面引用多个文件，如何防止样式冲突？"],["[css] 如何清除在项目中无用的css代码呢？"],["[css] css图片缩放失真出现锯齿的如何解决呢？"],["[css] css如何消除字体的锯齿？"],["[css] 请使用CSS画一个带锯齿形边框圆圈"],["[css] sass是如何导入模块的"],["[css] 使用sass里，你是怎么组织你的sass文件的？"],["[css] 说说sass有哪些你认为很棒的特性"],["[css] 在sass中可以执行布尔运算吗？"],["[css] 你有用过sass中的Mixin功能吗？它有哪些作用？"],["[css] 检测sass中错误的指令是哪个？"],["[css] 说说你对sass的嵌套规则的理解？"],["[css] 你认为sass和less的最大区别是什么呢？你喜欢哪个？为什么？"],["[css] sass是怎么定义变量的？"],["[css] 使用sass的方式有哪些？"],["[css] 为什么要使用sass/less？"],["[css] 你对伪类了解多少？分为几大类？"],["[css] 分析比较opacity: 0、visibility: hidden、display: none三者的优劣和适用场景"],["[css] 你知道什么是CSS-in-JS吗？说说你对它的了解"],["[css] 你知道什么是聚焦环吗？怎么解决呢？"],["[css] 如何让一个块元素绝对居中？"],["[css] css的user-select:all 有什么用处？"],["[css] 说说display:none和visibility:hidden的区别"],["[css] 如何使用CSS绘制一个汉堡式菜单"],["[css] 你是如何压缩字体的？"],["[css] 如何修改美化radio、checkbox的默认样式？"],["[css] 你有使用过postcss吗？它和less/scss/stylus有什么区别？"],["[css] 解释下什么是PPI和DP？"],["[css] 头部设置meta也可以做到自适应为啥还要用rem？"],["[css] 在rem下如何实现1像素？"],["[css] rem是如何实现自适应布局的？"],["[css] 使用rem的优缺点是什么？和使用百分比有什么区别？"],["[css] 当页面采用rem布局时，如何解决用户设置字体大小造成的页面布局错位？"],["[css] 使用rem时应该注意什么？"],["[css] 使用rem布局时怎样合理设置根标签字体大小？"],["[css] 解释下css3的flexbox（弹性盒布局模型），以及它应用场景有哪些？"],["[css] 你有使用过vmax和vmin吗？说说你对它们的理解"],["[css] 如何设置背景图片不随着文本内容的滚动而滚动？"],["[css] css中兼容ie浏览器的前缀是什么? "],["[css] 请问触发hasLayout的后果是什么？"],["[css] css中class和id选择器有什么区别？"],["[css] 移动端页面不满一屏时如何实现满屏背景？"],["[css] 写一个高度从0到auto的transition动画"],["[css] 如何使用CSS3的属性设置模拟边框跟border效果一样？"],["[css] 怎么IE6下在使用margin:0 auto;无法使其居中？"],["[css] 使用css实现彩虹的效果"],["[css] css中padding和margin是相对于父元素还是子元素呢？"],["[css] 当使用opacity时会使得元素的子元素也透明，此时不想要子元素也跟着透明怎么办？"],["[css] 在css中为什么说不建议使用@import？"],["[css] 写一个动画，向上匀速移动100px，向下以1.5倍速度移动200px，一直反复循环"],["[css] 说出至少十条你理解的css规范"],["[css] 使用css画出一个五角星"],["[css] 使用overflow: scroll时不能平滑滚动怎样解决？"],["[css] 请说下你对css对象模型(CSSOM)的理解"],["[css] 用css实现倒影的效果"],["[css] 用css实现饼图效果"],["[css] 怎么使用纯css实现左右拉伸拖动？"],["[css] 举例说明attr()的使用场景"],["[css] 你有使用:valid和:invalid来校验表单吗？"],["[css] 使用css写一个水平翻转文字的效果"],["[css] 举例说明:not()的使用场景有哪些"],["[css] 怎么让div中的图片和文字同时上下居中？"],["[css] 怎么使图片宽度自适应呢？"],["[css] 实现文本的竖向排版"],["[css] 你有用过vw布局吗？和使用rem有什么区别？"],["[css] 举例说明常用的cursor取值有哪些？"],["[css] 举例说明clear取值有哪些？"],["[css] 请写出:link、:visited、:hover、:active的执行顺序"],["[css] 实现一个上下固定，中间自动填满的布局"],["[css] 怎样用纯CSS实现禁止鼠标点击事件？"],["[css] 当全国哀悼日时，怎么让整个网站变成灰色呢？"],["[css] 如果给一个元素设置background-color,它的颜色会填充哪些区域呢？"],["[css] 使用css3做一个魔方旋转的效果"],["[css] 手写一个使用css3旋转硬币的效果"],["[css] height和line-height的区别是什么呢？"],["[css] 请用css写一个扫码的加载动画图"],["[css] 举例说明伪类:focus-within的用法"],["[css] 如何用css自定义滚动条？能做到所有浏览器兼容吗？想要做兼容怎么办呢？"],["[css] border-radius:50%和border-radius:100%有什么区别？"],["[css] 如何使用CSS实现段落首字母或首字放大效果？"],["[css] 如何给段落的首行缩进？"],["[css] 你有去看过或者了解过css的标准文档吗？"],["[css] 你知道CSS的标准发布流程吗？"],["[css] 你最希望css拥有什么样的特性？（目前没有的）"],["[css] 解释下为什么css的reset不建议直接这么写：*{ margin:0; padding:0;}？"],["[css] 为什么说不提倡用1px的小尺寸图片做背景平铺？"],["[css] 举例说明css有哪些简写的属性和属性值？"],["[css] 请说说颜色中#F00的每一位分别表示什么？为什么会有三位和六位的表示呢？"],["[css] 请使用css写一个多级的下拉菜单"],["[css] 用css给一个元素加边框有哪些方法？"],["[css] 相邻兄弟选择器、后代选择器和子选择器三者有什么区别？"],["[css] 举例说明你对相邻兄弟选择器的理解"],["[css] 你是怎么设计css sprites（精灵图）的？有哪些技巧？"],["[css] 请描述下你对translate()方法的理解"],["[css] 怎样去除图片自带的边距？"],["[css] 让你手写一个reset的文件，你应该怎么写？要考虑哪些方面呢？"],["[css] 你知道css的预处理器和后处理器都有哪些吗？它们有什么区别呢？"],["[css] 请使用css画一个圆，方法可以多种"],["[css] css中最常用的字体有哪些？你是怎么选择字体的？"],["[css] 请举例说明css有哪些不可继承的属性？"],["[css] 你有使用过preload、preconnect、prefetch这些属性吗？说说它们都有什么作用？"],["[css] 你是怎样对css文件进行压缩合并的？"],["[css] 如果css文件过大时，如何异步加载它？"],["[css] css3和css2的区别是什么？"],["[css] 你有使用过字体图标吗？它有什么好处？"],["[css] 你知道什么是流体排版吗？说说它的原理是什么？"],["[css] 请说说你对vh、vw的理解以及它们的运用场景是什么？"],["[css] css怎么更改表单的单选框或下拉框的默认样式？"],["[css] 你了解css3的currentColor吗？举例说明它的作用是什么？"],["[css] 怎么去掉点击a链接或者图片出现的边框？"],["[css] css的linear-gradient有什么作用呢？"],["[css] 会引起Reflow和Repaint的操作有哪些？"],["[css] 你有用过clip-path吗？说说你对它的理解和它都有哪些运用场景？"],["[css] 你是怎么选择resetting和normalizing的？为什么？"],["[css] position跟margin collapse这些特性相互叠加后会怎么样？"],["[css] 移动端的布局用过媒体查询吗？写一个试试"],["[css] 举例说明你知道的css技巧有哪些？"],["[css] 判断第一行和第二行的颜色分别是什么？并解释为什么？[代码]"],["[css] 用css怎么实现两端对齐？"],["[css] 你有用过弹性布局吗？说说你对它的理解"],["[css] 外边距重叠是什么？重叠的结果是什么？怎么防止外边距重叠？"],["[css] css中的border:none和border:0px有什么区别？"],["[css] 如何写高效的CSS？"],["[css] 如何做图片预览，如何放大一个图片？"],["[css] 举例说明在css3中怎么实现背景裁剪？"],["[css] 如何使用CSS的多列布局？"],["[css] 请说说CSS3实现文本效果的属性有哪些？"],["[css] 请说说在什么时候用transition？什么时候使用animation？"],["[css] 说说响应式设计(responsive design)和自适应设计(adaptive design)的区别？"],["[css] 什么是脱离文档流？有什么办法可以让元素脱离标准的文档流？"],["[css] 请问background-attachmentn属性有什么用途？"],["[css] 移动页面底部工具条有3个图标，如何平分？在设置边框后最后一个图标掉下去了怎么办？"],["[css] css怎样使每个字符宽度一样？"],["[css] 说下你对background-size的理解，它有什么运用场景？"],["[css] 如何自定义radio按钮的样式"],["[css] word-wrap、word-break和white-space有什么区别？"],['[css] 说说你对字母"X"在CSS中有什么作用？'],["[css] CSS3中的transition是否可以过渡opacity和display？"],["[css] 说下background-color:transparent和opacity:0的区别是什么？"],["[css] 你有用过IE css的expression表达式吗？说说你对它的理解和它有什么作用呢？"],["[css] z-index有时不起作用的原因是什么？怎么解决？"],["[css] 你有了解css计数器（序列数字字符自动递增）吗？如何通过css的content属性实现呢？"],["[css] 说说你对css的will-change属性的理解，它有什么作用呢？"],["[css] transition、animation、transform三者有什么区别？"],["[css] 如何使用css3实现一个div设置多张背景图片？"],["[css] 有哪些方式可以对一个DOM设置它的CSS样式？"],["[css] 举例说明实现圆角的方式有哪些？"],["[css] 有用过scss和sass吗？说说它们之间的区别是什么？"],["[css] absolute的containing block（容器块）计算方式和正常流有什么区别？"],["[css] 说说visibility属性的collapse属性值有什么作用？在不同浏览器下有什么区别？"],["[css] 说说你对min-width和max-width的理解，它们有什么运用场景？"],["[css] 说说你对hasLayout的理解，触发hasLayout的方式有哪些？"],["[css] 使用纯CSS代码实现动画的暂停与播放"],["[css] 举例说明伪类:nth-child、:first-child与:first-of-type这三者有什么不同？"],["[css] 什么是zoom？它有什么作用？"],["[css] 举例说明微信端兼容问题有哪些？"],["[css] 请举例说明伪元素 (pseudo-elements) 有哪些用途？"],["[css] 设置字体时为什么建议设置替换字体？"],["[css] 你有没有自己写过一套UI库？说下遇到哪些难点？"],["[css] 说说你对GPU的理解，举例说明哪些元素能触发GPU硬件加速？"],['[css] 你知道CSS中的字母"C"代表什么吗？'],["[css] 怎么自定义鼠标指针的图案？"],["[css] Reset CSS和Normalize CSS的区别是什么？"],["[css] 为什么要使用css sprites？"],["[css] 标签、class和id选择器三者的区别是什么？分别在什么时候用？"],["[css] 举例说明时间、频率、角度、弧度、百分度的单位分别是哪些？"],["[css] 你有用过table布局吗？说说你的感受"],["[css] 说说你对设备像素比的理解"],["[css] 说下你对cursor属性的理解"],["[css] position的relative和absolute定位原点是哪里？"],["[css] 过渡和动画的区别是什么？"],["[css] CSS中的calc()有什么作用？"],["[css] 怎么实现移动端的边框0.5px？"],["[css] 行内元素和块级元素有什么区别，如何相互转换？"],["[css] 说说你对低版本IE的盒子模型的理解"],["[css] 你是如何规划响应式布局的？"],["[css] 说说你对前端二倍图的理解？移动端使用二倍图比一倍图有什么好处？"],["[css] 如何让大小不同的图片等比缩放不变形显示在固定大小的div里？写个例子"],["[css] 你对视网膜(Retina)分辨率有了解吗？有没有在实际中使用过？"],["[css] 移动端微信页面有哪些兼容性问题及解决方案是什么？"],["[css] 如何更改placeholder的字体颜色和大小？"],["[css] 行内css和important哪个优先级高？"],["[css] 当一个元素被设置为浮动后，它的display值变为什么呢？"],["[css] 为什么会出现浮动？在什么时候需要清除浮动呢？"],["[css] 写出div在不固定高度的情况下水平垂直居中的方法？"],["[css] 移动端的布局用过媒体查询吗？写出例子看看"],["[css] CSS的伪类和伪对象有什么不同？"],["[css] CSS的overflow属性定义溢出元素内容区的内容会如何处理呢"],["[css] 外层有一个自适应高度的div，里面有两个div，一个高度固定300px，另一个怎么填满剩余的高度？"],["[css] 说说你对CSS样式覆盖规则的理解"],["[css] 写出几个初始化CSS的样式，并解释说明为什么要这样写"],["[css] display有哪些值？分别说明他们的作用是什么？"],["[css] 怎么让body高度自适应屏幕？为什么？"],["[css] font-style的属性有Italic和oblique，两者有什么区别呢"],["[css] IE(6/7/8/9/10/11/Edge)下的hack写法分别有哪些？"],["[css] 写出你遇到过IE6/7/8/9的BUG及解决方法"],["[css] 举例说明css的基本语句构成是什么呢？"],["[css] 写例子说明如何强制（自动）中、英文换行与不换行"],["[css] 说说你对BEM规范的理解，同时举例说明常见的CSS规范有哪些？"],["[css] 遇到overflow: scroll不能平滑滚动怎么解决？"],["[css] 请问display:inline-block在什么时候会显示间隙？"],["[css] 用CSS画出一个任意角度的扇形，可以写多种实现的方法"],["[css] 请你解释下什么是浮动和它的工作原理是什么？同时浮动会引起什么问题？"],["[css] 说说你对!important的理解，一般在哪些场景使用？"],["[css] 在实际编写css中你有遇到过哪些浏览器兼容性的问题？怎么解决的？"],["[css] 怎么改变选中文本的文字颜色和背景色？"],["[css] 你对响应式设计的理解是什么？知道它基本的原理是吗？要想兼容低版本的IE怎么做呢？"],["[css] 你有使用过哪些栅格系统？都有什么区别呢？"],["[css] 请说说*{box-sizing: border-box;}的作用及好处有哪些？"],["[css] 说说你对jpg、png、gif的理解，分别在什么场景下使用？有使用过webp吗？"],["[css] 如何消除transition闪屏？"],["[css] 元素竖向的百分比设置是相对容器的高度吗？"],["[css] 用CSS绘制一个红色的爱心"],["[css] 举例说明css中颜色的表示方法有几种"],["[css] 说说position的absolute和fixed共同与不同点分别是什么？"],["[css] 手动写动画最小时间间隔是多少，为什么？"],["[css] 怎样把一个div居中？怎样把一个浮动元素居中？怎样把绝对定位的div居中？"],["[css] 用css画一个太阳"],["[css] 你有用过哪些css框架？说说它们的特点"],["[css] box-sizing常用的属性有哪些？分别有什么作用？"],["[css] inline、block、inline-block这三个属性值有什么区别？"],["[css] margin和padding使用的场景有哪些？"],["[css] 什么是视差滚动？如何实现视差滚动的效果？"],["[css] css3的:nth-child和:nth-of-type的区别是什么？"],["[css] 怎么使用自定义字体？有什么注意事项？"],["[css] 要是position跟display、overflow、float这些特性相互叠加后会怎么样？"],["[css] 有用过Flex吗？简要说下你对它的了解"],["[css] 列举CSS优化、提高性能的方法"],["[css] 假如设计稿使用了非标准的字体，你该如何去实现它？"],["[css] 你知道全屏滚动的原理是什么吗？它用到了CSS的哪些属性？"],["[css] 你是怎样抽离样式模块的？"],["[css] 说说你对媒体查询的理解"],["[css] 你知道的等高布局有多少种？写出来"],["[css] 手写一个满屏品字布局的方案"],["[css] span与span之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"],["[css] 重置（初始化）css的作用是什么？"],["[css] 怎么让英文单词的首字母大写？"],["[css] 怎么才能让图文不可复制？"],["[css] 写出你知道的CSS水平和垂直居中的方法"],['[css] 实现单行文本居中和多行文本左对齐并超出显示"..."'],["[css] 不使用border画出1px高的线，在不同浏览器的标准和怪异模式下都能保持效果一样"],["[css] 写出主流浏览器内核私有属性的css前缀"],["[css] 使用flex实现三栏布局，两边固定，中间自适应"],["[css] 浏览器是怎样判断元素是否和某个CSS选择器匹配？"],["[css] 用CSS绘制一个三角形"],["[css] 说下line-height三种赋值方式有何区别？"],["[css] 让网页的字体变得清晰，变细用CSS怎么做？"],["[css] 描述下你所了解的图片格式及使用场景"],["[css] 请描述css的权重计算规则"],["[css] rgba()和opacity这两个的透明效果有什么区别呢？"],["[css] 怎样修改chrome记住密码后自动填充表单的黄色背景？"],["[css] 说说你对z-index的理解"],["[css] 在页面中的应该使用奇数还是偶数的字体？为什么呢？"],["[css] 你有用过CSS预处理器吗？喜欢用哪个？原理是什么？"],["[css] 说说CSS的优先级是如何计算的？"],["[css] 说说浏览器解析CSS选择器的过程？"],["[css] 说说你对line-height是如何理解的？"],["[css] 要让Chrome支持小于12px的文字怎么做？"],["[css] css的属性content有什么作用呢？有哪些场景可以用到？"],["[css] 什么是FOUC？你是如何避免FOUC的？"],["[css] 解释下 CSS sprites的原理和优缺点分别是什么？"],["[css] 请描述margin边界叠加是什么及解决方案"],["[css] style标签写在body前和body后的区别是什么？"],["[css] position:fixed;在ios下无效该怎么办？"],["[css] ::before和:after中单冒号和双冒号的区别是什么，这两个伪元素有什么作用？"],["[css] 说说你对css盒子模型的理解"],["[css] css常用的布局方式有哪些？"],["[css] 对比下px、em、rem有什么不同？"],["[css] 简述下你理解的优雅降级和渐进增强"],["[css] 清除浮动的方式有哪些及优缺点？"],["[css] 简述你对BFC规范的理解"],["[css] 用css创建一个三角形，并简述原理"],["[css] CSS3新增伪类有哪些并简要描述"],["[css] CSS选择器有哪些？哪些属性可以继承？"],["[css] 在页面上隐藏元素的方法有哪些？"],["[css] CSS3有哪些新增的特性？"],["[css] 圣杯布局和双飞翼布局的理解和区别，并用代码实现"]]},{name:"js",data:[["[js]了解元编程吗？说说你对ES6中的元编程的理解"],["[js]ECMAScript比ES5新添加了哪两种原始数据类型？解决了哪些问题？"],["[js]export和export default有什么区别？"],["[js]使用Map和Object的场景分别是什么呢？"],["[js]import后面加上大括号{}和不带大括号有什么区别？"],["[js]let在switch中的多个case中定义多个相同的变量会报什么错？为什么？[代码]"],["[js]说说set和map有什么区别？"],["[js]举例说明Symbol.hasInstance有什么运用场景？"],["[js]class可以多继承吗？怎么实现多继承呢？"],["[js]Reflect.ownKeys()与Object.keys()区别是什么？"],["[js]请使用ES6的Proxy实现一个数据绑定实例"],["[js]你知道es7新增了哪些新的特性吗？"],["[js]请分析如下promise执行的结果并解释原因[代码]"],["[js]举例说明setImmediate有什么作用？"],["[js]使用箭头函数应该需要注意什么？"],["[js]说下var、let和const有什么区别？"],["[js]es6新增了哪些数据类型？"],["[js]for…of和for…in有什么区别？"],["[js]Symbol有什么作用？"],["[js]如何让一个对象具有私有属性？"],["[js]Map和WeakMap有什么区别？"],["[js]Set和WeakSet有什么区别？"],["[js]TypedArray有什么应用场景？"],["[js]使用es6怎么快速给一个数组去重？"],["[js]es6的模板字符串有什么新的特性？"],["[js]举例说明拓展运算符有什么用途？"],["[js]你喜欢es6的哪些特性？"],["[js]举例说明你对es6的class的理解"],["[js]举例说明你对es6的extends的理解"],["[js]es6对es5有哪些方面的优化呢？"],["[js]Proxy是什么，有什么应用场景？"],["[js]Reflect是什么，有什么应用场景？"],["[js]说说你对Iterator的理解"],['[js]Object.is()和比较操作符"="的区别是什么？'],["[js]Generator函数是什么？它有什么应用场景？"],["[js]说说你对async/await的理解？"],["[js]es6对函数做了哪些优化？"],["[js]箭头函数与普通函数有什么区别？它有哪些新的特性？"],["[js]let和const的区别是什么"],["[js]说说你对set数据结构的理解"],["[js]说说你对class的理解"],["[js]es6函数的rest参数你有了解吗？"],["[js]说说你对Babel的了解？"],["[js]module、export、import分别有什么作用？"],["[js]谈谈你对es6的module体系的理解"],["[js] 写一个方法在指定数组对象中查找匹配的对象的值"],["[js] 解释下Delete操作符的作用"],["[js] 使用canvas生成验证码"],["[js] 使用js实现沿贝塞尔曲线运动"],["[js] js如何阻止默认事件？"],["[js] 如何用js实现VR的功能"],["[js] 解释下({} + [] == [] + {})的结果"],["[js] 解释下{} + [] == [] + {}的结果"],["[js] 写个方法获取数组任意个不重复的随机数组元素"],["[js] 写一个方法，将2N个元素的数组随机两两组合"],["[js] 写一个方法获取数组的最大值和最小值"],["[js] js如何进行特性检测？"],["[js] 你使用过哪些数学函数？说下它们的作用"],['[js] 写一个方法去掉最后一个字符串","'],["[js] JS如何设置获取盒模型的宽和高？"],["[js] js中有哪些类型的弹出框？"],["[js] 未声明和未定义的变量有什么区别？"],["[js] 写一个方法找出在一个数组中和为目标值的两个整数"],["[js] 函数的fn.length和arguments.length有什么区别？"],["[js] 说说你对Memoization的了解及它有什么用途？"],["[js] 写一个防止重复请求接口的方法"],["[js] 把一个数组置空有哪些方法？"],["[js] 请解释下reduce方法有哪些用法"],["[js] 写一个方法，找出最接近当前的数的2的指数的数"],["[js] 写一个方法计算给定时间的倒计时"],["[js] 你是如何自学js这门语言的？"],["[js] 写一个方法判断字符串是否符合USD的格式"],["[js] 写个方法求出数组中每个元素的二次方，返回新的数组"],["[js] 写一个方法获取url中hash路径的参数"],["[js] typeof undefined的结果是什么？"],["[js] typeof Symbol()的结果是什么？"],["[js] 请问哪些语句会放入异步任务队列中？"],["[js] 使用js写个方法截取视频的第一帧"],["[js] 请分析5 == [[[5]]]的结果"],["[js] 使用js封装一个ajax方法"],["[js] 写一个方法验证国内车牌号是否正确"],["[js] BOM常用属性有哪些？"],["[js] DOM是哪种基本的数据结构？"],["[js] 异步任务从开始执行到调用回调函数这段时间放到哪边？"],["[js] 为什么会有宏任务和微任务之分？"],["[js] js语句放入异步队列的时机是哪个？"],["[js] 为什么会有同源策略？"],["[js] 写一个方法将一个未排序的数组中找出任意两数之和等于给定的数"],["[js] 写一个方法将一个1到1000的未排序数组中找到缺失的数"],["[js] 写一个方法将句子中颠倒单词"],["[js] 写一个方法找出两个数的最小公倍数"],["[js] 写一个方法找出两个数的最大公约数"],["[js] 写一个方法求出一个数的所有素数因子"],["[js] 写一个方法验证给定的数是否为素数"],["[js] js预解析顺序（优先级）是什么？"],["[js] 写一个方法计算只有加法和乘法的表达式，如:2+3*9+6"],["[js] 写一个方法找到给定数组中任意两个数的最大总和"],["[js]  写一个方法将把true和false转为1和0"],["[js] 如何可靠地测试一个值是否为NaN？"],['[js] 使用typeof test === "object"来判定test是否是对象有什么缺陷？如何避免？'],["[js] 编号为1到100的一百个人围成一圈，以123123的方式进行报数，数到3的人自动退出圈子，剩下的人继续报数，问最后剩下的人编号为几？"],["[js] 数组的原型是什么？"],["[js] 使用new一个构造函数，如果函数返回return 1、return {}、return null、return true会发生什么情况？"],["[js] 如何定义一个防篡改对象？"],["[js] 什么是惰性载入函数？"],["[js] 写一个方法获取中文的首字母"],["[js] 写一个多级地点选择组件，说说你的思路"],["[js] 使用let声明的变量可以先使用再声明吗？"],["[js] js中splice()和slice()方法有什么区别？"],["[js] 使用promise实现一个带延时功能的链式调用"],["[js] 请写一个单链表查找倒数第k个节点"],["[js] 请实现一个jsonp"],["[js] js如何做单元测试？步骤是什么？"],["[js] 写一个方法统计给定数组中重复元素的次数"],["[js] 使用原生js绑定两个onclick事件"],["[js] if有作用域吗？"],["[js] 什么是负无穷大？"],["[js] 手写一个base64解码的方法"],["[js] 手写一个base64编码的方法"],["[js] 写一个方法反转给定的字符串"],["[js] 请描述下js中click和onclick的区别？"],["[js] 判断Number.MIN_VALUE > 0的结果"],["[js] 写一个计算页面可视化范围的方法"],["[js] 使用js写一个数字动态累加的方法"],["[js] 写一个上传裁剪图片的功能"],["[js] 实现一个数组的pop方法"],["[js] 实现一个数组的push方法"],["[js] 写一个方法将多个对象进行合并"],["[js] 元编程的应用场景有哪些？"],["[js] 写一个在移动端长按删除的方法"],["[js] 当页面刷新时，JS请求哪些地方有缓存处理？"],["[js] localStorage如何实现定时（非永久）存储"],["[js] new构造函数执行和普通函数执行的区别是什么？"],["[js] 写一个方法，间隙调换数组的元素的位置，如[1,2,3,4]换成[2,1,4,3]"],["[js] 写一个方法将数组分割成等长数组"],["[js] 写一个方法从数组中取出来数组的一半让他们的和最接近整个数组的和的一半"],["[js] 如何使用reverse使数组倒序但不影响原数组？"],["[js] 如果使用js处理2千万条数据的排序并且页面不卡顿，说说你的方法"],["[js] 写一个方法根据屏幕分辨率改变背景宽高"],["[js] 说说你对js运行环境的理解"],["[js] 写一个方法判断两个数组中的元素是否完全相同"],["[js] 数组[1,2,3,4,5]有5个元素，直接给它的length属性赋值结果会怎么样？"],["[js] 你认为哪些功能是js做不到的？"],["[js] 封装一个类似jquery的$功能的方法"],["[js] 给定一个数,计算出它们任意3个数组合有多少种"],["[js] 你有使用过scrollIntoView这个方法吗？说说它的用途"],["[js] 你有了解过javaScript Debugger的原理吗？"],["[js] require如何同步加载模块？"],["[js] 请使用ES5实现类的继承"],["[js] 请实现一个符合Promise/A+规范的Promise"],["[js] 匿名函数和命名函数的区别？"],["[js] 在JS中的主要有哪几类错误？"],["[js] 写一个俄罗斯方块的主逻辑"],["[js] js如何动态设置对象的key？"],["[js] 写一个方法计算两个给定的时间差"],["[js] 写一个方法在一个指定的日期上面加上几小时/几分钟/几秒"],["[js] 写一个方法将时间戳转换为指定的时间格式"],["[js] 写一个方法将2021-05-07 04:30:21转换为时间戳"],["[js] 如何判断模块间的循环引用？"],["[js] RegExp修饰符有哪些？"],["[js] RegExp如何做到不区分大小写？"],["[js] 要下载一个大文件如何并行下载？"],["[js] 写一个方法，给定AB两个数，判断A是否包含于B"],["[js] 写一个方法，点击任意除弹窗外的位置关闭当前弹窗"],["[js] 请解释下1<2<3 和3>2>1的运算结果和思路"],["[js] 写一个方法将对象转成用&拼接的请求参数"],["[js] 写一个方法获取身份证中的性别"],["[js] 请解释下什么是js的装箱和拆箱？"],["[js] ~~和Math.floor有什么区别？"],["[js] 如何深度冻结对象？度冻结对象有什么作用？"],["[js] 写一个方法把字符串转txt文件（blob）并下载"],["[js] 一元运算符有哪些？"],["[js] 不安全的JSON值有哪些？"],["[js] 什么是抽象渗漏？"],["[js] 什么是哨位值？"],["[js] 函数的length属性表示什么？"],["[js] 写一个方法根据日期获取当月有多少天"],["[js] 说说你对void的理解"],["[js] 请问假值对象是什么？"],["[js] 说说你对hasOwnProperty的理解"],["[js] 不同进制数字如何表示？"],["[js] ~的操作符有什么作用？"],["[js] []和{}的toString和valueOf的结果分别是什么？"],["[js] js哪些方法可以获取原型？"],["[js] 写一个方法获取文件的扩展名"],["[js] Symbol强制类型转换的方法及规则是什么？"],["[js] JS中把其它类型转成字符串的方法及规则是什么？"],["[js] JS中把其它类型转成布尔的方法及规则是什么？"],["[js] JS中把其它类型转成数字的方法及规则是什么？"],["[js] 解释下toPrimitive()函数是如何执行的？"],["[js] 实现一个数组的fill方法"],["[js] Array构造函数传入的参数有哪些情况？"],["[js] 在js中整数超出安全范围怎么办？"],["[js] 在js中整数的安全范围是多少？"],["[js] Number.isNaN和isNaN有什么区别？"],["[js] 举例说明DOM常用的操作方法有哪些？"],["[js] requireJS是如何缓存、动态加载、避免多次加载的？"],["[js] requireJS的核心原理是什么？"],["[js] 说说JS模块加载器加载原理"],["[js] 说说new操作符的执行过程"],["[js] 实现一个函数柯里化"],["[js] 哪些场景下会使用闭包？"],["[js] ['520', '888', '168', '66.6'].map(parseInt)执行结果是多少？"],["[js] 说说==操作符的转换规则"],["[js] 在哪些情况下会发生隐式强制类型转换？"],["[js] 写一个方法，传入一个整数参数，返回和参数一样长度且不重复的数组"],["[js] js如何遵循开放封闭原则？"],["[js] 写一个方法在一定时间内无任何操作时执行某个事件"],["[js] 怎样能才更安全地获取undefined的值？"],["[js] [请说说js的内部属性[[Class]]是什么？]"],["[js] 写一个方法判断浏览器的标签是否在当前页面"],["[js] 下列哪个是Javascript做不到的"],["[js] 说说你认为js的黑科技有哪些？"],["[js] js中什么情况下应该使用with?"],["[js] 判断以下两个正则表达式是否相等:/abc/ === /abc/"],["[js] 分析3 < 2 < 1返回的结果"],["[js] 分析这个2 + - + + + - + 3表达式返回的结果"],["[js] 如何监听静态资源加载异常？"],["[js] 箭头函数能当构造函数吗？"],["[js] 写一个方法判断给定的数据是否为空对象"],["[js] 请问下，闭包产生的本质是什么？"],["[js] 如何解决异步请求的竞态问题？"],["[js] 写一个方法删除数组中重复的项"],["[js] 以下时间处理在IOS上会遇到什么问题？如何解决？"],["[js] 写一个方法验证中国公民身份证格式是否正确"],["[js] 写一个js方法根据生日计算出年龄"],["[js] 写一个js方法两个对象求交集"],["[js] 如何检测一个数是否为无穷大？"],["[js] infinity代表什么数据？"],["[js] 请解释下面题目输出的结果"],["[js] 如何计算动画的帧率（FPS）？"],["[js] 如何排查页面中CPU占用高的情况？"],["[js] 如何把10.36四舍五入为最接近的整数？"],["[js] 写一个方法探测CPU占比情况"],["[js] javascript什么时候会占CPU？"],["[js] 写一个方法获取手机电池的信息，如：电量、充电状态等"],["[js] 请解释以下题目会输出的结果（类型转换）"],['[js] 请说说new String("A")和String("A")分别返回的结果，请解释为什么？'],["[js] 请说说IEEE 754规定了哪些标准？"],["[js] 请说说IEEE 754标准指的是什么？"],["[js] 写个方法找出页面中除了数字和英文字母外的所有特殊特号"],["[js] 写一个方法，让数组里的元素上移一格/下移一格"],["[js] 写一个方法找到一维数组里，有且只有两个连续相等的所有元素"],["[js] 请使用js写个方法解析emoji表情"],["[js] 请通过reduce函数实现一维数组的求和"],["[js] 请通过代码来解释下new和instanceof的内部机制"],["[js] 在严格模式下，全局作用域中函数中this的值是什么？"],["[js] 请说说严格模式下的this指向"],["[js] 分别解释下js中默认绑定、隐式绑定、显式绑定、new绑定的区别"],["[js] 浏览器中的剪切板是如何监听复制事件的？"],["[js] 请使用js实现一个无限累加的函数"],["[js] js中Iterable对象和Array有什么区别？"],["[js] 请实现一个Promise.race"],["[js] 写一个方法实现选中复制的功能"],["[js] 请解释下什么是softbind，并实现一个softbind"],["[js] 说下你对map方法的理解，并解释下面代码返回的结果"],["[js] js的作用域有哪些？"],["[js] 说说你对函数是一等公民的理解"],["[js] setTimeout(fn,0)，延迟执行吗？"],["[js] 添加原生事件如果不移除为什么会内存泄露？"],["[js] Promise和setTimeout执行先后有什么区别？"],["[js] 解释下什么是暂时性死区？"],["[js] 如何判断链表是否有环？"],["[js] 使用原生js给一个按钮绑定两个onclick事件"],["[js] 写一个方法判断在一个一维数组里，有且只有一个数等于给定的值"],["[js] 写一个方法生成不重复的用户ID"],["[js] 写一个JS方法，判断元素是否在可视区域"],["[js] 写一个函数时，如果有多个参数，如何传才比较好？"],["[js] 如何区分返回内容是文件流还是json数据？"],["[js] 写一个方法判断js的方法是内置的还是自定义的"],["[js] 写一个方法将一个html字符串变成JSON树的形式"],["[js] 如何监听浏览器窗口大小变化？"],["[js] 使用JavaScript拖拽盒子跟着鼠标动的效果"],["[js] 请问，javascript可以读取本地的文件吗？为什么？"],["[js] 写一个方法将ArrayBuffer转为字符串"],["[js] 请说说html、body、document、window四者的区别是什么？"],["[js] 实现一个批量请求函数 multiRequest(urls, maxNum)"],["[js] 写个方法将base64的数据流装换为二进制流"],["[js] 以下方法调用call输出的结果是什么？请解释下？"],["[js] 写一个算法找到数组中两个元素相加等于指定数的所有组合"],["[js] 写一个方法将一个数组中的元素，从前到后依次两两组合，最后一个与第一个组合"],["[js] 写一个方法实现指定开始的数字增加到指定的结束数字，步长默认为1"],["[js] 写一个方法监听指定cookie的变化"],["[js] 写一个方法，实现修改当前的URL链接但页面不跳转的功能"],["[js] 在非函数内写return语句，会有什么问题？"],["[js] 写一个方法动态同步加载script文件"],["[js] 使用js写一个方法操作css变量"],["[js] 如何创建视频文件的blob？"],['[js] 解释下3 + "2" - 5的值为多少？'],["[js] 写一个方法js将数组对象中某个属性值相同的对象合并成一个新对象"],["[js] js能够保证object属性的输出顺序吗？如果可以怎么做？"],["[js] 写个方法获取浏览器的唯一标识"],["[js] 写一个方法记录函数运行的时间"],["[js] 给定下面伪代码，请说出程序运行多少秒后会输出“Hello World!”（不考虑其它干扰因素）？并解释下为什么？"],["[js] 请解释下setTimeout的运行机制"],["[js] 哈希表的原理是什么？"],["[js] 如果要让你去实现一个散列函数，你将从哪些方面考虑？"],["[js] 什么是散列函数？它有什么特征？"],["[js] 对象的键可以重复吗？为什么？如果可以重复将会又什么样的表现？"],["[js] 举例说明createDocumentFragment和createElement有什么区别？"],["[js] null是对象吗？"],["[js] 解释下JavaScript并发模型"],["[js] 请问typeof typeof 168的结果是什么？"],["[js] 实现一个isNaN的方法"],["[js] 解释下点击一个input输入框，依次会触发哪些事件？"],["[js] 说说你对稀疏数组的理解"],["[js] 举例说明你对尾递归的理解，它有什么应用场景？"],["[js] 如果使用JSON.stringify进行深拷贝有什么弊端？如何解决？"],["[js] 请说说你对内置对象和宿主对象的理解"],["[js] 为什么js里定义的数组可以不定长且数据类型可以不固定呢？"],["[js] js最大支持多少长度的数组？为什么？"],["[js] 与一个方法将origin转化为tree，要求支持无限级和性能"],["[js] 请解释下为什么下面第一种方式会报错而第二种不会？"],["[js] promise有哪几种状态？是如何变化的？"],["[js] 写一个方法将虚拟Dom转化为真实DOM"],["[js] 使用js实现一个并发限制的promise，并保证最多同时运行三个任务"],["[js] 写出js各类型转化为Boolean的值分别是什么？及转化的规则是什么？"],["[js] 你是如何做前端性能分析的？从哪些方面入手？有哪些指标？"],["[js] 遍历一个树结构，除了可以用递归外还能用哪些方法？"],["[js] for(;;)循环里如果省略第二个条件，则需要注意什么问题？"],["[js] 分析下sum = n * (n - 1) / 2的时间复杂度是什么？"],["[js] 一个好的算法都应包含哪些要素？"],["[js] 请解释下算法有什么特征（基本要素）？"],["[js] 请解释下数据结构与算法的关系"],["[js] 说说你对数据结构和数据类型的理解"],["[js] 解释如下代码的输出结果，并改造代码使得按顺序输出i"],["[js] js函数调用方式有哪些？"],["[js] js函数定义方式有哪些？"],["[js] 请解释下执行栈有哪些特点？"],["[js] 请解释下为什么我们可以在声明函数前使用它？"],["[js] 写一个方法代替eval"],["[js] 举例说明哪些场景会遇到超大计算量的问题？"],["[js] 写一个方法求给定1485个元素中取33个元素的组合有多少种（大数据处理，小心CPU爆炸）"],["[js] 写一个方法检测指定的数组是否有重复的元素"],["[js] 为什么eval要添加括号呢？"],["[js] 写一个方法将字符串中的制表符全部替换为逗号"],["[js] url链接中如果有两个问号会出现什么问题？如果通过js获取url的参数时能正常获取到吗？"],["[js] 写一个方法，批量删除指定索引的数组元素"],["[js] 写一个方法将汉字转换成拼音首字母"],["[js] 字符串从哪里来的split方法和length属性？"],["[js] 是否所有的循环都能用递归代替？为什么？如果不可以，请举例说明"],["[js] 你觉得递归好写吗？"],["[js] 闭包是如何形成的？"],["[js] 请说说你对活动对象的理解"],["[js] 请说说你对变量对象的理解"],["[js] 如果给你一段代码，你能画出执行过程的上下文堆栈的变化吗？"],["[js] 如何激活一个上下文？"],["[js] 一个函数调用会产生多少个上下文环境？"],["[js] map和forEach有什么区别？"],["[js] 一次JS的请求哪些地方会有缓存处理？"],["[js] 使用js写一个羽毛球16个队抽签随机队伍编号的方法"],["[js] 深拷贝里的循环引用如何解决？"],["[js] 使用递归实现指定最小值和最大值之间的所有整数求和"],["[js] 使用原生js实现给定节点的父节点下所有子节点的元素"],["[js] 使用js如何改变url参数值，并且页面不刷新？"],["[js] 使用js按贝格尔编排算法生成单循环对阵表"],["[js] 使用js写一个方法，使得数组的某个元素置顶"],["[js] 使用js写个方法，使得数组的两个元素互换，要求高性能"],["[js] 使用js写个方法，把下列数组对象按多字段排序，name升序，age降序"],["[js] 使用js实现一个数组flat()的方法"],["[js] 写一个方法计算N年时农场里有几只羊（见下文描述）？"],["[js] 举例说明把一个数组扁平化的方法有哪些？"],["[js] 请问css/html/js/img的下载顺序是怎样的？都是并发执行的吗？"],["[js] 现在有一个宏任务，又有一个微任务两者同一层级，在微任务里面又有一个宏任务和一个微任务，请问执行顺序是什么,为什么？"],["[js] 写一个方法，判断给定的几个数字是否相等，如[1,1,1,1]相等"],["[js] 写一个方法判断一组数字是连值"],["[js] 写一个方法将UTC时间和北京时间换算"],["[js] 计算从一个大数组中(如1万条数据)取出第一数据和最后一条数据的时间分别是多少？"],["[js] new Function有什么应用场景？"],["[js] 写一个方法获取指定两个日期之间相隔的所有日期"],["[js] 写一个ASCII与Unicode码的互转的方法"],["[js] 使用js写一个方法将数字转换为float,并取N位小数"],["[js] 举例说明你对TypedArray的理解，它的运用场景有哪些？"],["[js] 什么时候在JS中使用Float32Array而不是Array？"],["[js] Float32Array有几种构造方式？"],["[js] js如何实现函数缓存？函数缓存有什么运用场景？"],["[js] 用js写个算法算出筐里最少有多少个鸡蛋？"],["[js] 说说你对堆栈跟踪的理解"],["[js] 函数的调用栈是怎么工作的？"],["[js] 数组元素全倒排列并去重"],["[js] 写个方法获取给定开始和结束时间的所有日期和月份"],["[js] 接口请求时需要做哪些安全处理？怎么做？"],["[js] 举例说明判断浏览器是否支持某个事件的方法有哪些？"],["[js] 请说说focus、blur与focusin、focusout的区别是什么？"],["[js] 举例说明+运算符的运行机制"],["[js] 写一个方法获取滚动条距离窗口顶部的距离"],["[js] 写一个方法获取指定窗口的尺寸大小"],["[js] 请举例说明比较运算符>,>=,<,<=的比较规则"],["[js] 把对象转换到字符串类型是如何转换的？"],["[js] 把对象转换到数字类型是如何转换的？"],["[js] 请说说以下两种原型的区别"],["[js] requestIdleCallback在EventLoop的什么阶段执行？如何执行？"],["[js] EventLoop有优点但也有缺点，请说说它的缺点是什么？"],["[js] 你知道什么是空闲回调(requestIdleCallback)吗？"],["[js] requestAnimationFrame在EventLoop的什么阶段执行？"],["[js] 假设要在UI渲染之前处理一些事情你该怎么办？"],["[js] js的请求一般情况下在哪些地方会有缓存的处理？"],["[js] 请说说DOM节点的操作如何优化？"],["[js] 说说你对RAIL性能评估模型的了解"],["[js] 实现一个寄生式组合继承"],["[js] 如何设计一个pageAPI？说说你的方法"],["[js] 如何设计一个JS SDK？说说你的方法"],["[js] SeaJS和RequireJS有什么区别？"],["[js] 如果要你自己实现一个requireJS库，你该怎么做？"],["[js] 写个方法，实现对某个节点的拖拽"],["[js] 写一个代理console.log的方法"],["[js] 写一个js方法，输入指定类型的选择器(id，class，tagName)可以返回匹配的DOM节，要求兼容和性能"],["[js] class和普通构造函数有什么区别？"],["[js] Math.min() < Math.max() 返回结果是什么？为什么？"],["[js] js的哪些操作可以改变作用域链？"],["[js] 请说说JS中的索引数组、关联数组和静态数组、动态数组的定义与区别"],["[js] 在js中undefined和not defined的区别是什么？"],["[js] js中的数字在电脑内存储为多少Byte？"],["[js] 列举出JS的全局函数"],["[js] 输入一个四则混合运算的表达式，请写个方法求它的值"],["[js] 使用js如何创建一个private方法？"],["[js] 举例说明json的标准格式"],["[js] 给定特定的字符串，写个方法判断是否以元字母结尾"],["[js] 写一个方法，实现树的路径查询[代码]"],["[js] 实现一个函数sum, 满足以下需求:"],["[js] 写一个方法，计算有N个数（可重复），分别放到M个位置中，有多少种排列？"],["[js] 如何取消promise？"],["[js] 使用js写一个多文件上传的组件"],["[js] 使用js写方法把0123456789生成每组4个数，共有多少个组合和多少个排列？"],["[js] 写一个方法对对象中的key进行排序"],["[js] 在多个页面之间需要传递参数，你是如何传递这些参数的？"],["[js] 写一个方法，当复制页面中的内容时，同时把版权信息也复制上"],["[js] 怎样做到js无阻塞加载？"],["[js] 什么情况下会出现js阻塞？"],["[js] cookie的值可以设置为中文吗？为什么？如果可以怎么设置？"],["[js] 你有用过哪些模板引擎？你觉得哪个好用？为什么？"],["[js] 使用js实现变态跳台阶"],["[js] 浏览器中window.length的结果是什么？为什么？"],["[js] 随机生成一个指定长度的验证码"],["[js] 使用js写一个批量上传文件的组件"],["[js] Array(3)和Array(3, 4)的区别是什么？"],["[js] ArrayBuffer和Blob有什么区别？"],["[js] 动态加载的li如何绑定事件？"],["[js] 使用js写一个方法生成0000-9999一万个数字（4位数）"],["[js] getComputedStyle和element.style有什么不同？"],["[js] 说说MutationObserver的应用场景有哪些？"],["[js] 写一个方法监听DOM宽高的变化"],["[js] 下文Promise的执行顺序是怎样的？"],["[js] 使用canvas画一个小球自由落体的效果"],["[js] 使用try catch哪些异常是捕获不到的？哪些能捕获到？捕获不到的要怎样才能捕获到？"],["[js] 使用js写一个图片压缩的小工具"],["[js] 为什么jsonp不支持post的方法？"],["[js] 使用js动态创建一个有不少于10万个节点的树"],["[js] 前端下载文件的方式有哪些？"],["[js] 使用window.open(url)下载文件时为什么会被浏览器拦截？如何解决？"],["[js] sessionStrorage也可以使用onstorage事件吗?"],["[js] 解释下隐式全局变量和外部函数作用域"],["[js] async属性诞生的初衷是什么？"],["[js] 你能用js模拟出右键的复制和粘贴功能吗？如果可以说下是如何操作的？如果不可以请说明下理由"],["[js] js延迟加载的方式中，只有IE浏览器支持的是哪一种方式"],["[js] 当用户打开一个网页时，想一直停留在当前打开的页面，如何禁止页面前进和后退"],["[js] 前端如何保持与服务器时间同步（如何解决客户端与服务端时间不对称的问题）？"],["[js] 客户端与服务端时间为什么会不对称？不对称将会出现哪些问题？"],["[js] 给你一个页面，找出该页面使用最多的前三个标签以及他们的数量"],["[js] 如何使用js实现撤消和重做并写出伪代码"],["[js] 你用过Navigator.sendBeacon()吗？说说它有什么应用场景？"],["[js] 请使用js实现一个秒表计时器的程序"],["[js] 模拟 localStorage 时如何实现过期时间功能"],["[js] 用函数实现扑克牌排序"],["[js] 写一个单向链数据结构的 js 实现并标注复杂度"],["[js] 请使用js实现vue的diff算法"],["[js] 请使用js实现商品的sku，并说说你的思路"],["[js] js中的undefined和 ReferenceError: xxx is not defined 有什么区别？"],["[js] 获取浏览器当前页面的滚动条高度的兼容写法"],["[js] 一道变态题 Number.call.call(Number, undefined, 0) 等于什么？"],["[js] ReferenceError和TypeError有什么区别？"],["[js] 如何避免JS浮点运算的精度问题（例：0.1+0.7=0.7999999999999999）"],["[js] 举例说明js立即执行函数的写法有哪些？"],["[js] ajax请求地址只支持http/https吗？能做到让它支持rtmp://等其它自定义协议吗 ？"],["[js] 微信小程序实现轨迹回放，微信原生小程序，基于uniapp的小程序？"],["[js] 写一个方法实现promise失败后自动重试"],["[js] for in 和 for of 的区别？"],["[js] 异步请求重试策略有哪些呢？"],["[js] 写一个方法判断数组内元素是否全部相同"],["[js] 说说防止重复发送ajax请求的方法有哪些？各自有什么优缺点？"],["[js] 请使用 js 实现一个双向链表"],["[js] 实现多张图片合成一张的效果"],["[js] ajax如何接收后台传来的图片？"],["[js] js源代码压缩都有哪些方法？它们的压缩原理分别是什么？"],["[js] 不用 + eval Function 实现加法"],["[js] 写一个 document.querySelector 的逆方法"],["[js] 说说你对js沙箱的理解，它有什么应用场景？"],["[js] 纯函数和函数式编程有什么关系？"],["[js] 为什么要用纯函数？"],["[js] 使用js实现一个图片剪裁的功能"],["[js] 使用for-in语句能保证遍历对象的顺序吗？如果不能那为什么？如果可以那又如何保证？"],["[js] 写个方法获取屏幕的DPI"],["[js] promise的构造函数是同步执行还是异步执行，它的then方法呢？"],["[js] 内存泄漏和内存溢出有什么区别"],["[js] 写一个方法把科学计数法转换成数字或者字符串"],["[js] js怎样避免原型链上的对象共享？"],["[js] 写一个方法，实时验证input输入的值是否满足金额如：3.56(最多只有两位小数且只能数字和小数点)的格式，其它特殊字符禁止输入"],["[js] 使用delete删除数组，其长度会改变吗？"],["[js] 代码中如果遇到未定义的变量，会抛出异常吗？程序还会不会继续往下走？"],["[js] 说说你对JSBridge的理解"],["[js] 写一个方法粘贴复制的图片并显示出来"],["[js] js循环中调用异步的方法，如何确保执行结果的顺序是正确的？"],["[js] 写一个方法遍历指定对象的所有属性"],["[js] 实现一个函数记忆的方法"],["[js] 手写一个trim()的方法"],["[js] 你是如何比较js函数的执行速度的？"],["[js] axios拦截器原理是什么？"],["[js] axios为什么可以使用对象和函数两种方式调用？是如何实现的？"],["[js] fetch和axios请求的原理都是基于XMLHttpRerequst吗？"],["[js] 举例说明面向对象编程有什么缺点？"],["[js] 使用js实现一个循环队列"],["[js] 一个api接口从请求数据到请求结束共与服务器进行了几次交互？"],["[js] Number()的存储空间是多大？假如接口返回一个超过最大字节的数字怎么办？"],["[js] alert如何让文本换行？"],["[js] 在不支持js的浏览器中如何隐藏JavaScript代码？"],["[js] js的循环结构有哪些？"],["[js] 字符串拼接有哪些方式？哪种性能好？"],["[js] innerHTML有什么缺点？"],["[js] 举例说明js中什么是尾调用优化？"],["[js] 如何判断两个对象相等？"],["[js] localStorage什么时候过期？"],["[js] 写一个获取非行间样式的方法"],["[js] 写一个获取页面中所有checkbox的方法"],["[js] XML与JSON有什么的区别？"],["[js] flash如何与js交互？"],["[js] 写一个格式化时间的方法"],["[js] 说说你对js对象生命周期的理解"],["[js] js操作节点的方法有哪些？"],["[js] 如何判断对象是否属于某个类？"],["[js] 在DOM上同时绑定两个点击事件（一个用捕获，一个用冒泡），事件总共会执行几次，先执行哪个事件？"],["[js] json和对象有什么区别？"],["[js] js怎么实现一个类并实例化这个类？"],["[js] script所在的位置会影响首屏显示时间吗？"],["[js] callee和caller的区别和作用是什么？"],["[js] 写一个方法实现自定义右键菜单的功能"],["[js] AudioContext有什么应用场景？"],["[js] 如何按回车自动提交表单"],["[js] 写一个方法获取图片的exif信息"],["[js] 写一个方法获取图片的方向"],["[js] 在设置keyup监听事件后按F5刷新和按浏览器中刷新键刷新有什么区别？"],["[js] 用js写一个方法检测浏览器是否支持css3的属性"],["[js] 对a == ('1'||'2'||'3') ? false : true写法进行改进，写出你优化后的方法"],["[js] Geolocation.getCurrentPosition()用来做什么的？在什么浏览器不受兼容？"],["[js] setTimeout的第三个参数有什么用？"],["[js] 解释下深度优先遍历和广度优先遍历的区别及如何实现"],["[js] 你认为es5的设计缺陷有哪些？"],["[js] innerHTML与outerHTML有什么区别？"],["[js] 构造一个自定义二维 NN 矩阵，从左上角第一个单元格依次填入1 - NN的数字，从矩阵中指定单元格出发，经过相邻的单元格(不可重复)，走 X 步，输出所有可能的路径和每条路径单元格对应的数字。"],["[js] 使用ajax轮询接口有什么优缺点？"],["[js] 如何提升JSON.stringify的性能？"],["[js] 写一个方法，当给定数字位数不足8位时，则在左边补充0以补足8位数的方法"],["[js] 说说你对JS中暂性死区的理解，它有什么运用场景？"],["[js] 微信的JSSDK都有哪些内容？如何接入？"],["[js] 举例说明Object.defineProperty会在什么情况下造成循环引用导致栈溢出？"],["[js] document.domain的作用是什么？它有什么限制？"],["[js] 根据元素ID遍历树形结构，查找到所有父元素ID [代码]"],["[js] 实现一个ajax的队列请求"],["[js] pjax和ajax的区别是什么？"],["[js] 你有使用过pjax吗？它的原理是什么？"],["[js] 使用ajax请求真的不安全吗？为什么？"],["[js] 请写一个性能最好的深度克隆对象的方法"],["[js] Math.ceil()、Math.round()、Math.floor()三者的区别是什么？"],["[js] ajax请求中为何会出现OPTIONS请求？"],["[js] 用js怎么实现图片马赛克效果？"],["[js] 写一个方法把分钟转化为时分，例如：150->02:30"],["[js] 写一个方法获取指定数组中间的值（一个或者两个）"],["[js] 你是如何排查js内存泄漏的？"],["[js] 使用js生成1-10000的数组"],["[js] 在chrome中js的数组占用了多少内存？"],["[js] 判断[].proto.proto === {}.proto结果并解释为什么[代码]"],["[js] js的数组/对象在内存中分别是如何存储的？"],["[js] 写个方法判断数组对象中是否存在某个对象"],["[js] 写个方法近似计算指定数组或对象占用内存的大小"],["[js] js可以用中文作为变量命名吗？为什么？"],["[js] 解释下如下代码的意图：Array.prototype.slice.apply(arguments)"],["[js] 如何判断一个元素文本是否换行？"],["[js] 举例说明js鼠标事件有哪些？"],["[js] 请举例说明JSON.stringify()有哪些特性？"],["[js] 用js实现typeof的功能"],["[js] 用js实现一个HashMap，不可以使用Object"],["[js] 日常开发中写JS循环时应该注意哪些情况？"],["[js] js循环的数据量很大（例如100W+）时会出现什么情况？如何进行性能优化？"],["[js] 举例说明什么是响应式编程？"],["[js] 你知道什么是纯函数吗？"],["[js] 什么是函数式编程？它有什么优缺点？"],["[js] 举例说明为什么说ES模块比commonJS模块还优秀？"],["[js] 请说说commonJS模块与ES模块的差异有哪些？"],["[js] 说下你对IoC的理解，它有什么运用场景？"],["[js] 说说你对js中的依赖注入的理解，它的实现方式有哪些呢？"],["[js] 用js写一个绑定事件检测窗口大小"],["[js] 有用过Handlebars模板引擎吗？它的工作原理是怎样的？"],["[js] 在axios中怎样添加授权验证？"],["[js] 什么是UUID？它有什么作用？用js写一个生成UUID的方法"],["[js] 用js实现一个加法的方法"],["[js] js如何解决数字精度丢失的问题？"],["[js] 切换标签窗口后js定时器自动停止了，如何在激活标签后又继续呢？"],["[js] 说说你对HTML5中video blob的理解"],["[js] 看下面代码，判断a和b的类型是否为true？为什么？什么是基本包装类型？[代码]"],["[js] 如何用jst获取DOM元素在页面中的绝对位置？"],["[js] W3C的事件处理和IE的事件处理有哪些区别？"],["[js] DOM0、DOM2、DOM3事件处理方式的区别是什么？"],["[js] 说下js的parseInt()和Number()有什么区别？"],["[js] 请解释下如下js代码对数组排序后的输出结果[代码]"],["[js] js如何监听页面缩放？"],["[js] 写一个方法把对象和字符串互转"],["[js] 表达式和语句有什么区别？如何把语句转换为表达式？"],["[js] 用js写一个方法检测指定的函数体是否为空"],["[js] 写一个方法检查给定的函数是否为js运行时环境的内置函数"],["[js] 如何让js的filter方法支持大小写？"],["[js] 写一个方法删除字符串中所有相邻重复的项"],["[js] axios相比原生ajax的优点有哪些呢？"],["[js] axios为什么能在浏览器中环境运行又能在node中环境运行？"],["[js] 根据下面代码：说出执行结果，并解释为何是会是这样的结果？[代码]"],["[js] 这两种展开运算符的方式有什么区别呢？"],["[js] axios如何一次发送多个并发请求？"],["[js] setTimeout和setInterval有什么区别呢？"],["[js] 写一个方法，实现使用canvas播放视频？"],["[js] js如何检测当前页面是否以全屏模式显示？"],["[js] 阅读下面关于setTimeout和Promise的代码，判断结果会输出什么？为什么？"],["[js] 你觉得虚拟DOM快吗？还有没有比它还快的方式？"],["[js] js对象如何深比较？"],["[js] 如何判断一个对象是否为空？"],["[js] 说说你对postMessage的理解，它有什么运用场景呢？"],["[js] 用js封装一个前端分页的库，说说你的思路"],["[js] 写一个汉字与Unicode码的互转的方法"],["[js] 列举下获取指定日期的毫秒数的方法有哪些？"],["[js] pageshow和pageshide有什么应用场景呢？"],["[js] 写一个方法监听某个div滚动"],["[js] 有了解过getSelectionAPI吗？怎么使用，有哪些场景？"],["[js] 使用js写一个时钟的程序"],["[js] 写一个任意进制转换的程序"],["[js] 使用js写一个计算字符串的字节数的方法"],["[js] 用代码实现游戏应用中连续按键触发必杀技的监测方法"],["[js] 写一个方法判断一个数字是否为整数"],["[js] 页面上的DOM有多个相同的ID，用js获取时结果会是怎么样的？"],["[js] 如何在用户刷新、跳转、关闭浏览器时向服务端发送统计的数据？"],["[js] 说下你对alert的理解，它有哪些特性呢？及使用它时要注意些什么？"],["[js] 你知道js的可选链是什么吗？说说你对它的理解，它有什么应用场景？"],["[js] js的sort方法运用场景有哪些？"],["[js] 用不同的方法改装下面的代码，使它的结果输出为0-4[代码]"],["[js] 请分析!+[]+!![]+!![]+!![]+!![]+!![]的结果"],["[js] 请分析020-088=?的过程及结果"],["[js] 写一个让一句话随着鼠标移动的小插件"],["[js] 如果让你把把html页面导出为pdf，不用插件的话，你该怎么做？"],["[js] 用js实现一个导航吸顶效果"],["[js] window.console.log()和console .log()有区别吗？体现在哪里？"],["[js] getelementbyId和queryselect平时经常使用哪一个？说说你的看法"],["[js] 箭头函数的this值继承于哪里"],["[js] 举例说明object.freeze有哪些用途呢？"],["[js] 微任务和宏任务有什么区别？"],["[js] 请比较下for、forEach、for of的性能的性能"],["[js] 你有使用过BackboneJS吗？说说它和vue有什么区别？"],["[js] 你有使用过ExtJs吗？说说它的优缺点是什么？"],["[js] 写例子说明js中自定义事件的使用与触发"],["[js] js事件中currentTarget和target的区别是什么？"],["[js] 说说js跳出循环return、break、continue的区别？"],["[js] 说说你对异常处理和错误处理的理解"],["[js] 用js实现动态改变根元素字体大小的方法"],["[js] js依赖注入的实现思路是什么？它有什么优缺点呢？"],["[js] 使用js获取鼠标坐标"],["[js] 举例说明什么是短路求值？"],["[js] 写一个方法判断大括号{}是否闭合"],["[js] 从一个无序的整数数组中，找出最小和最大数之间缺失的数字，要求最小的时间复杂度"],["[js] 写一个方法实现“基数排序算法”，并解释下时间复杂度和空间复杂度"],["[js] 写一个方法实现“桶排序算法”，并解释下时间复杂度和空间复杂度"],["[js] 写一个方法实现“归并排序算法”，并解释下时间复杂度和空间复杂度"],["[js] 写一个方法实现“插入排序算法”，并解释下时间复杂度和空间复杂度"],["[js] 写一个方法实现“交换排序算法”，并解释下时间复杂度和空间复杂度"],["[js] 写一个方法实现“选择排序算法”，并解释下时间复杂度和空间复杂度"],["[js] 说说你对js排序的理解，你有了解哪些算法呢？"],["[js] 请说说你对try/catch的理解，平时有在哪些场景会用到呢？"],["[js] 请实现一个计算器的功能"],["[js] 写一个方法从数组中随机抽取N个不重复的元素"],["[js] 遍历数组和对象的方法都有哪些？"],["[js] 举例说明这三种方法map、reduce和filter的区别是什么？"],["[js] 写一个方法找出指定一维数组所有不重复的元素和个数"],["[js] 请写出几种匿名自执行的写法（至少三种）"],["[js] 你知道js的函数重载是什么吗？"],["[js] 写一个方法获取div的宽高"],["[js] 举例说明constructor和instanceof的区别是什么？"],["[js] 写一个方法来获取div到浏览器窗口的高度"],["[js] 写一个方法判断页面滚动方向"],["[js] 前端异步的使用场景有哪些？"],["[js] 说出至少十条你理解的js规范"],["[js] 如何禁止IOS移动端网页橡皮筋的效果？"],["[js] 各浏览器的事件机制有什么不同？ 如何阻止事件冒泡？"],["[js] 解释下offsetWidth、clientWidth、scrollWidth这三者的区别是什么？"],["[js] 请解释下NaN表示什么呢？typeof NaN结果是什么？"],["[js] 举例说明你对事件代理的理解"],["[js] 异步加载和延迟加载有什么区别？"],["[js] js垃圾回收的方式有哪些？"],["[js] 你对window的属性devicePixelRatio有了解吗？说说它有什么实际应用场景？"],["[js] 写一个网络不通时则提醒用户的方法"],["[js] 用js封装一个对cookie操作的方法"],["[js] 举例说明js创建数组有哪些方法？"],["[js] 举例说明什么是匿名函数？它有什么优缺点呢？"],["[js] 用js实现最大化和最小化窗口"],["[js] js如何实现打印指定的区域（局部打印）？"],["[js] 写一个方法检测页面中的所有标签是否正确闭合"],["[js] 举例说明常用的BOM属性和方法有哪些？"],["[js] 写个方法判断当前脚本运行在浏览器还是node环境中"],["[js] 写一个方法，传入数字x，从一个一维数组里找到两个数字符合“n1 + n2 ＝ x”"],["[js] 你知道什么是PAJAX吗？它和AJAX有什么区别？它的应用场景有哪些？"],["[js] js的控制台输出，平时除了用console.log外，你还知道哪些？使用console.log应该注意什么？"],["[js] 平时调试用console.log的输出结果可信吗？为什么？"],["[js] 用原生js获取DOM元素的方法有哪些？"],["[js] getElementById和querySelector方法的区别是什么？"],["[js] 举例说明document.execCommand有哪些用途"],["[js] 你平时是怎么调试js的？会断点调试吗？断点调试有什么技巧呢？"],["[js] 如何使用js获取当前的url和来源的url？"],["[js] 你有用过哪些3D渲染的库？"],["[js] 页面的编码和被请求的资源编码不一致时如何处理？"],["[js] ajax的请求状态有哪几种？"],["[js] 请介绍下js的数据类型"],["[js] 写一个方法找出一段话里面出现频率最多的词"],["[js] 请使用js实现一个省市县级联的效果"],["[js] 用js实现一个轮播图，并简述有哪些实现的方法"],["[js] 请使用纯js实现一个横向或纵向的无缝滚动效果"],["[js] 请写一个获取颜色的正则"],["[js] 请用js实现一个简单的小区楼的电梯运行程序"],["[js] 举例说明atob和btoa的用法"],["[js] 用原生js实现类似getElementsByClassName的方法，不能使用querySelectorAll"],["[js] 写一个方法将html页面生成为图片"],["[js] stopPropagation()和preventDefault()这两个方法有什么区别？"],["[js] 你有使用过FileReader吗？说说它有哪些应用场景？"],["[js] 当用户刷新网页时，js的请求有哪些地方会有缓存处理呢？"],["[js] onload事件和domcontentloaded哪个先执行呢？"],["[js] 说下你对面向对象的理解"],["[js] 在js中函数返回多个值有哪些方法？"],["[js] 为什么说js是弱类型语言，它的优缺点分别是什么？"],["[js] 写一个密码生成器，并同时写一个密码强度校验的方法"],["[js] 有什么方案可以提高无限滚动列表的性能？"],["[js] js如何把网页加入收藏夹功能？"],["[js] 你知道什么是三元表达式吗？“三元” 表示什么意思？使用三元表达式应该注意些什么问题？"],["[js] 说下你对函数的形参与实参的理解"],["[js] 请用js实现一个promise的方法"],["[js] 请说说你对promise的理解"],["[js] 你知道断点续传的原理吗？用js怎么实现？"],["[js] 清空一个数组的方式有哪些？它们有什么区别？"],["[js] ES5和ES6、ES7有什么区别？"],["[js] 写一个根据xpath获取元素的方法"],["[js] 用js实现一个复制粘贴的功能"],["[js] 说说你对ArrayBuffer的理解！它和Array有什么区别？"],["[js] 如何解决在手机上长时间点击会选中图片？"],["[js] 你了解什么是AOP吗？它的作用是什么？举个例子"],["[js] 怎么下载一个zip文件？"],["[js] 举例说明如何使用WebSQL？"],["[js] 举例说明js如何拖拽排序？"],["[js] 怎样在JavaScript中创建一个worker线程？"],["[js] 写个给图片加水印的方法"],["[js] 说说你对执行上下文的理解"],["[js] 有些js库习惯在代码开头处添加分号有什么作用呢？除了分号还可以换成别的吗？"],["[js] 在js中attribute和property的区别是什么？"],["[js] 举例说明数组的排序方法有哪些？"],["[js] 举例说明js拖拽用到的事件有哪些？"],["[js] 用原生JS封装插件的方式有哪些？"],["[js] 用js模拟实现微信抢红包的算法，并说明你的思路"],["[js] 如何实现锁定网页、密码解锁的效果？说说你的方法和步骤是什么？"],["[js] 你知道1和Number(1)的区别是什么吗？"],["[js] 说说CORS为何要区分预检请求和简单请求呢？"],["[js] 实现异步编程有哪些方式？推荐用哪种？"],["[js] 请为什么说js是单线程，而不是多线程呢？"],["[js] 使用js实现摩斯密码的加密和解密"],["[js] 请使用原生的js实现斐波那契数列"],["[js] 阻止事件的默认行为有哪些？说说它们之间的区别是什么？"],["[js] 请举例说明动态操作DOM的方法有哪些？"],["[js] 原生Math的方法有哪些？请列举并描述其功能"],["[js] 什么是词法分析？请描述下js词法分析的过程？"],["[js] 自己实现数组的 map、filter、find 方法"],["[js] 请描述下函数的执行过程"],["[js] 写一个洗扑克牌的方法"],["[js] 说说用原生js实现封装一个选项卡的功能"],["[js] 说下你对柯里化函数(currying)的理解，它有什么运用场景？"],["[js] 请描述下ajax的请求都有哪些步骤？"],["[js] 用js实现页面局部打印和预览原理是什么呢？同时在IE上有什么不同？"],["[js] 用js实现小写金额转大写的方法"],["[js] 请解释下NaN === NaN的结果"],["[js] 请写出如下代码运行的结果并解释为什么？[代码]"],["[js] 写一个方法，将字符串中的单词倒转后输出，如：my love -> ym evol"],["[js] 原生的字符串操作方法有哪些？请列举并描述其功能"],["[js] JSON.stringify有什么局限性和哪些技巧？"],["[js] 如何实现一个全屏的功能？"],["[js] 举例说明js关闭当前窗口有哪些方法？"],["[js] 说说你对js包装对象的理解"],["[js] JavaScript有几种类型值？能否画出它们的内存图？"],["[js] 保护js代码的方式有哪些？分别说说他们的原理是什么？"],["[js] 你有用过webRTC吗？它有什么运用场景？"],["[js] 如何实现文件拖动上传？"],["[js] 分析('b' + 'a' + +'a' + 'a').toLowerCase()返回的结果"],["[js] 能否正确获取本地上传的文件路径？如果可以怎么做？如果不可以解释下为什么？"],["[js] 请说说escape、encodeURI、decodeURI、encodeURIComponent和decodeURIComponent的区别？"],["[js] 如何终止WebWork？"],["[js] 写一个方法把多维数组降维"],["[js] 使用正则去掉html中标签与标签之间的空格"],["[js] document.write和innerHTML有什么区别？"],["[js] 如何使用js来截图？怎样截可见区域和整个页面？"],["[js] 分别写出防抖和节流的两个函数，并描述它们分别有什么运用场景？"],["[js] 写一个把数字转成中文的方法，例如：101转成一百零一"],["[js] 用js写一个事件侦听器的方法"],["[js] 函数声明与函数表达式有什么区别？"],["[js] 请用js编写一个红绿灯程序"],["[js] 请详细描述AJAX的工作原理"],["[js] 请描述下什么是原型模式？它主要运用在哪些场景？"],["[js] 请描述下js的原型和原型链的理解以及它们之间的关系"],["[js] 写一个方法判断给定的字符串是否同态(isomorphic)"],["[js] 说说你对作用域链的理解"],["[js] 写个方法，找出指定字符串中重复最多的字符及其长度"],["[js] 请说说json和jsonp的区别？"],["[js] 你是如何更好地处理Async/Await的异常的？"],["[js] 准确说出'1,2,3,4'.split()的结果是什么（包括类型和值）？"],["[js] 不依赖第三方库，说下如何使用js读取pdf？"],["[js] 分别封装精确运算的加减乘除四个方法"],["[js] 不用第三方库，说说纯js怎么实现读取和导出excel？"],["[js] 说说你理解的同步和异步的区别是什么？"],["[js] 写例子说明如何给li绑定事件（ul下有1000+个li）？"],["[js] 要实现一个js的持续动画，你有什么比较好的方法？"],["[js] 分别写出数组的交集、并集、差集、补集这四个方法"],["[js] 用js写出死循环的方法有哪些？"],["[js] js的函数有哪几种调用形式？"],["[js] 解释下为什么{} + [] === 0为true？"],["[js] 请描述下null和undefined的区别是什么？这两者分别运用在什么场景？"],["[js] 写个方法随机打乱一个数组"],["[js] js异步加载有哪些方案？"],["[js] 判断instanceof的结果并解释原因 [代码]"],["[js] 请写一个sleep（暂停）函数"],["[js] 把Script标签放在页面最底部的</body>之前和之后有什么区别？浏览器会如何解析它们？"],["[js] js延迟加载的方式有哪些？"],["[js] 请描述你对浏览器同源策略的理解"],["[js] 举例说明js如何实现继承？"],["[js] 用js实现一个九九乘法口诀表"],["[js] 在js中怎么捕获异常？写出来看看？应该在哪些场景下采用呢？"],["[js] 举例说明什么是decodeURI()和encodeURI()是什么？"],["[js] 举例说明什么是IIFEs？它有什么好处？"],["[js] 举例说明数组和对象的迭代方法分别有哪些？"],["[js] 请快速答出此题的答案并解释：var x, y = 1; x + y = ?"],["[js] 说说instanceof和typeof的实现原理并自己模拟实现一个instanceof"],["[js] js中=、==、===三个的区别是什么？并说明它们各自的工作过程"],["[js] 写一个方法随机生成指定位数的字符串"],["[js] 移动端点击事件为什么会有延迟？延迟多长时间？有哪些方法可以解决？"],["[js] 写一个字符串重复的repeat函数"],["[js] 说说你对深浅拷贝的理解？并实现一个对数组和对象深拷贝的方法"],["[js] Ajax请求中get和post方式有什么区别呢？分别在哪些场景下使用？"],["[js] 说说你对base64的理解，它的使用场景有哪些？"],["[js] formData主要是用来做什么的？它的操作方法有哪些？"],["[js] 举例子说说你对js隐式类型转换的理解"],["[js] 请解释下什么是cookie隔离？为什么要隔离？如何隔离？"],["[js] 说说你对数据类型转换的理解是什么？类型转换的方法有哪些？"],['[js] 如何让(a==1 && a==2 && a==3)的值为true，把"=="换成"==="后还能为true吗？'],["[js] 举例子说明javascript的变量声明提升和函数声明提升"],["[js] 有用过HTML5的WebWork吗？它主要解决了什么问题？"],["[js] 写一个方法获取图片的原始宽高"],["[js] 请实现一个flattenDeep函数，把多维数组扁平化"],["[js] 写一个格式化金额的方法"],["[js] 请说下你对proto和prototype的理解"],["[js] 写一个方法，使得sum(x)(y)和sum(x,y)返回的结果相同"],["[js] JSONP的原理是什么？解决什么问题？"],["[js] 写出4个使用this的典型例子"],["[js] 写一个函数找出给定数组中的最大差值"],["[js] document的load 和ready有什么区别？"],["[js] 什么是事件委托？它有什么好处？能简单的写一个例子吗？"],["[js] 字符串相连有哪些方式？哪种最好？为什么？"],["[js] 请写出一个函数求出N的阶乘（即N!）"],["[js] 写个还剩下多少天过年的倒计时"],["[js] 你对事件循环有了解吗？说说看！"],["[js] 请说说你对事件冒泡机制的理解？"],["[js] 写一个使两个整数进行交换的方法（不能使用临时变量）"],["[js] 写出几种创建对象的方式，并说说他们的区别是什么？"],["[js] 深度克隆对象的方法有哪些，并把你认为最好的写出来"],["[js] JQuery的源码看过吗？能不能简单概括一下它的实现原理？"],["[js] window对象和document对象有什么区别？"],["[js] 说说你对IIFE的理解"],["[js] 为什么会有跨域问题？怎么解决跨域？"],["[js] 说说你对模块化的理解"],["[js] 说说你对eval的理解"],["[js] 找到字符串中最长的单词，并返回它的长度"],["[js] 请手写一个幻灯片的效果"],["[js] 请你解释一个为什么10.toFixed(10)会报错？"],["[js] 请用canvas写一个关于520浪漫表白的代码"],["[js] 说说你对this的理解"],["[js] 造成内存泄漏的操作有哪些？"],["[js] 写一个方法把0和1互转（0置1，1置0）"],["[js] 写一个方法判断字符串是否为回文字符串"],["[js] 写一个获取数组的最大值、最小值的方法"],["[js] 解释下这段代码的意思！"],["[js] 说说你对arguments的理解，它是数组吗？"],["[js] 说说bind、call、apply的区别？并手写实现一个bind的方法"],["[js] 写一个判断设备来源的方法"],["[js] 如何快速让一个数组乱序，写出来"],["[js] 0.1 + 0.2、0.1 + 0.3和0.1 * 0.2分别等于多少？并解释下为什么？"],["[js] 你对new操作符的理解是什么？手动实现一个new方法"],["[js] 写一个方法验证是否为中文"],["[js] 写一个验证身份证号的方法"],['[js] "attribute"和"property"有什么不同？'],['[js] 你理解的"use strict";是什么?使用它有什么优缺点？'],["[js] typeof('abc')和typeof 'abc'都是string, 那么typeof是操作符还是函数？"],["[js] 返回到顶部的方法有哪些？把其中一个方法出来"],["[js] 写一个数组去重的方法（支持多维数组）"],["[js] 什么是闭包？优缺点分别是什么？"],["[js] 说说你对javascript的作用域的理解"],["[js] 写一个获取当前url查询字符串中的参数的方法"],["[js] 简要描述下JS有哪些内置的对象"],["[js] 简要描述下什么是回调函数并写一个例子出来"],["[js] 写一个判断数据类型的方法"],["[js] 写一个加密字符串的方法"],["[js] 统计某一字符或字符串在另一个字符串中出现的次数"],["[js] 写一个去除制表符和换行符的方法"],["[js] 写一个把字符串大小写切换的方法"],["[js] 写一个方法把下划线命名转成大驼峰命名"],["[js] 去除字符串中最后一个指定的字符"],["[js] 写一个方法去掉字符串中的空格"],["[js] 用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值"]]},{name:"jquery",data:[["[jQuery]请说明jquery的data()有什么作用？"],["[jQuery]jquery的ready方法的原理是什么？"],["[jQuery]jQuery的attr和prop方法有什么区别？"],["[jQuery]jQuery是如何链式调用的？"],["[jQuery]说说看jQuery的选择器有哪些？"],["[jQuery]你有写过jQuery的扩展吗？都有哪些写法？"],["[jQuery]jQuery.fn的init方法返回的this指的是什么对象？为什么要返回this？"],["[jQuery]jQuery的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？"],["[jQuery]jquery.extend与jquery.fn.extend的区别？"],["[jQuery]jQuery的队列是如何实现的？队列可以用在哪些地方？"],["[jQuery]谈一下Jquery中的bind(),live(),delegate(),on()的区别？"],["[jQuery]你知道自定义事件吗？jQuery里的fire函数是什么意思，什么时候用？"],["[jQuery]你知道js和jQuery是什么关系吗？"],["[jQuery]jQuery是通过哪个方法和Sizzle选择器结合的？"],["[jQuery]针对jQuery性能的优化方法有哪些？"],["[jQuery]jQuery与jQuery UI有啥区别？"],["[jQuery]jQuery中如何将数组转化为json字符串，然后再转化回来？"],["[jQuery]jQuery和Zepto的区别？各自的使用场景？"],["[jQuery]针对jQuery的优化方法有哪些？"],["[jQuery]Zepto的点透问题如何解决？"],["[jQuery]jQuery UI怎样自定义组件？"],["[jQuery]JQuery一个对象可以同时绑定多个事件，这是如何实现的？"]]},{name:"vue",data:[["[vue]在vue中watch和created哪个先执行？为什么？"],["[vue]vue中mixins和extends有什么区别？"],["[vue]vue中mixins有什么使用场景？"],["[vue]在vue中created与activated有什么区别？"],["[vue]在vue项目如何引入异步组件？"],["[vue]在vue项目中scss scoped穿透符>>>无效的解决方案有哪些？"],["[vue]为什么在v-for中的key不推荐使用随机数或者index呢？那要怎么使用才比较好呢？"],["[vue]vue-loader在webpack编译流程中的哪个阶段？"],["[vue]预渲染和SSR(服务端渲染)有什么区别？"],["[vue]你有用过预渲染技术吗？怎么做的？"],["[vue]使用vue如何判断页面是否编辑及编辑页面未保存离开时，给出弹窗提示"],["[vue]vue的.sync修饰符可以用表达式吗？为什么？"],["[vue]v-if和v-show哪个优先级更高？"],["[vue]如何批量引入组件？"],["[vue]vue的v-for如何倒序输出？"],["[vue]如何在全局使用axios的实例呢？"],["[vue]v-show指令算是重排吗？"],["[vue]axios同时请求多个接口，如果当token过期时，怎么取消后面的请求？"],["[vue]从0到1自己构架一个vue项目，说说有哪些步骤、哪些重要插件、目录结构你会怎么组织"],["[vue]你知道vue的模板语法用的是哪个web模板引擎的吗？说说你对这模板引擎的理解"],["[vue]你知道v-model的原理吗？说说看"],["[vue]你有使用过vue开发多语言项目吗？说说你的做法？"],["[vue]在使用计算属性的时，函数名和data数据源中的数据可以同名吗？"],["[vue]vue中data的属性可以和methods中的方法同名吗？为什么？"],["[vue]怎么给vue定义全局的方法？"],["[vue]vue2.0不再支持v-html中使用过滤器了怎么办？"],["[vue]怎么解决vue打包后静态资源图片失效的问题？"],["[vue]怎么解决vue动态设置img的src不生效的问题？"],["[vue]使用vue后怎么针对搜索引擎做SEO优化？"],["[vue]跟keep-alive有关的生命周期是哪些？描述下这些生命周期"],["[vue]如果现在让你从vue/react/angularjs三个中选择一个，你会选哪个？说说你的理由"],["[vue]你知道vue2.0兼容IE哪个版本以上吗？"],["[vue]使用vue开发一个todo小应用，谈下你的思路"],["[vue]你有看过vue推荐的风格指南吗？列举出你知道的几条"],["[vue]你是从vue哪个版本开始用的？你知道1.x和2.x有什么区别吗？"],["[vue]你知道vue中key的原理吗？说说你对它的理解"],["[vue]vue中怎么重置data？"],["[vue]vue渲染模板时怎么保留模板中的HTML注释呢？"],["[vue]Vue.observable你有了解过吗？说说看"],["[vue]你知道style加scoped属性的用途和原理吗？"],["[vue]你期待vue3.0有什么功能或者改进的地方？"],["[vue]vue边界情况有哪些？"],["[vue]如何在子组件中访问父组件的实例？"],["[vue]watch的属性用箭头函数定义结果会怎么样？"],["[vue]在vue项目中如果methods的方法用箭头函数定义结果会怎么样？"],["[vue]在vue项目中如何配置favicon？"],["[vue]你有使用过babel-polyfill模块吗？主要是用来做什么的？"],["[vue]说说你对vue的错误处理的了解？"],["[vue]在vue事件中传入$event，使用e.target和e.currentTarget有什么区别？"],["[vue]在.vue文件中style是必须的吗？那script是必须的吗？为什么？"],["[vue]vue怎么实现强制刷新组件？"],["[vue]vue自定义事件中父组件怎么接收子组件的多个参数？"],["[vue]实际工作中，你总结的vue最佳实践有哪些？"],["[vue]vue给组件绑定自定义事件无效怎么解决？"],["[vue]vue的属性名称与method的方法名称一样时会发生什么问题？"],["[vue]vue变量名如果以_、$开头的属性会发生什么问题？怎么访问到它们的值？"],["[vue]vue使用v-for遍历对象时，是按什么顺序遍历的？如何保证顺序？"],["[vue]vue如果想扩展某个现有的组件时，怎么做呢？"],["[vue]说下$attrs和$listeners的使用场景"],["[vue]分析下vue项目本地开发完成后部署到服务器后报404是什么原因呢？"],["[vue]v-once的使用场景有哪些？"],["[vue]说说你对vue的表单修饰符.lazy的理解"],["[vue]vue为什么要求组件模板只能有一个根元素？"],["[vue]EventBus注册在全局上时，路由切换时会重复触发事件，如何解决呢？"],["[vue]怎么修改vue打包后生成文件路径？"],["[vue]你有使用做过vue与原生app交互吗？说说vue与ap交互的方法"],["[vue]使用vue写一个tab切换"],["[vue]vue中什么是递归组件？举个例子说明下？"],["[vue]怎么访问到子组件的实例或者子元素？"],["[vue]在子组件中怎么访问到父组件的实例？"],["[vue]在组件中怎么访问到根实例？"],["[vue]说说你对Object.defineProperty的理解"],["[vue]vue组件里写的原生addEventListeners监听事件，要手动去销毁吗？为什么？"],["[vue]vue组件里的定时器要怎么销毁？"],["[vue]vue组件会在什么时候下被销毁？"],["[vue]使用vue渲染大量数据时应该怎么优化？说下你的思路！"],["[vue]在vue中使用this应该注意哪些问题？"],["[vue]你有使用过JSX吗？说说你对JSX的理解"],["[vue]说说组件的命名规范"],["[vue]怎么配置使vue2.0+支持TypeScript写法？"],["[vue]<template></template>有什么用？"],["[vue]vue的is这个特性你有用过吗？主要用在哪些方面？"],["[vue]vue的:class和:style有几种表示方式？"],["[vue]你了解什么是函数式组件吗？"],["[vue]vue怎么改变插入模板的分隔符？"],["[vue]组件中写name选项有什么作用？"],["[vue]说说你对provide和inject的理解"],["[vue]开发过程中有使用过devtools吗？"],["[vue]说说你对slot的理解有多少？slot使用场景有哪些？"],["[vue]你有使用过动态组件吗？说说你对它的理解"],["[vue]prop验证的type类型有哪几种？"],["[vue]prop是怎么做验证的？可以设置默认值吗？"],["[vue]怎么缓存当前打开的路由组件，缓存后想更新当前组件怎么办呢？"],["[vue]说说你对vue组件的设计原则的理解"],["[vue]你了解vue的diff算法吗？"],["[vue]vue如何优化首页的加载速度？"],["[vue]vue打包成最终的文件有哪些？"],["[vue]ajax、fetch、axios这三都有什么区别？"],["[vue]vue能监听到数组变化的方法有哪些？为什么这些方法能监听到呢？"],["[vue]vue中是如何使用event对象的？"],["[vue]vue首页白屏是什么问题引起的？如何解决呢？"],["[vue]说说你对单向数据流和双向数据流的理解"],["[vue]移动端ui你用的是哪个ui库？有遇到过什么问题吗？"],["[vue]你知道nextTick的原理吗？"],["[vue]说说你对v-clock和v-pre指令的理解"],["[vue]写出你知道的表单修饰符和事件修饰符"],["[vue]说说你对proxy的理解"],["[vue]你有自己用vue写过UI组件库吗？"],["[vue]用vue怎么实现一个换肤的功能？"],["[vue]有在vue中使用过echarts吗？踩过哪些坑？如何解决的？"],["[vue]如果让你教一个2-3年经验前端经验的同事使用vue，你该怎么教？"],["[vue]vue性能的优化的方法有哪些？"],["[vue]SSR解决了什么问题？有做过SSR吗？你是怎么做的？"],["[vue]说说你觉得认为的vue开发规范有哪些？"],["[vue]vue部署上线前需要做哪些准备工作？"],["[vue]vue过渡动画实现的方式有哪些？"],["[vue]vue在created和mounted这两个生命周期中请求数据有什么区别呢？"],["[vue]vue父子组件双向绑定的方法有哪些？"],["[vue]vue怎么获取DOM节点？"],["[vue]vue项目有做过单元测试吗？"],["[vue]vue项目有使用过npm run build --report吗？"],["[vue]如何解决vue打包vendor过大的问题？"],["[vue]webpack打包vue速度太慢怎么办？"],["[vue]vue在开发过程中要同时跟N个不同的后端人员联调接口（请求的url不一样）时你该怎么办？"],["[vue]vue要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？"],["[vue]说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？"],["[vue]在移动端使用vue，你觉得最佳实践有哪些？"],["[vue]你们项目为什么会选vue而不选择其它的框架呢？"],["[vue]对于即将到来的vue3.0特性你有什么了解的吗？"],["[vue]vue开发过程中你有使用什么辅助工具吗？"],["[vue]vue和微信小程序写法上有什么区别？"],["[vue]怎么缓存当前的组件？缓存后怎么更新？"],["[vue]你了解什么是高阶组件吗？可否举个例子说明下？"],["[vue]为什么我们写组件的时候可以写在.vue里呢？可以是别的文件名后缀吗？"],["[vue]vue-loader是什么？它有什么作用？"],["[vue]说说你对vue的extend（构造器）的理解，它主要是用来做什么的？"],["[vue]如果将axios异步请求同步化处理？"],["[vue]怎么捕获组件vue的错误信息？"],["[vue]为什么vue使用异步更新组件？"],["[vue]如何实现一个虚拟DOM？说说你的思路"],["[vue]写出多种定义组件模板的方法"],["[vue]SPA单页面的实现方式有哪些？"],["[vue]说说你对SPA单页面的理解，它的优缺点分别是什么？"],["[vue]说说你都用vue做过哪些类型的项目？"],["[vue]在vue项目中如何引入第三方库（比如jQuery）？有哪些方法可以做到？"],["[vue]使用vue手写一个过滤器"],["[vue]你有使用过render函数吗？有什么好处？"],["[vue]写出你常用的指令有哪些？"],["[vue]手写一个自定义指令及写出如何调用"],["[vue]组件进来请求接口时你是放在哪个生命周期？为什么？"],["[vue]你有用过事件总线(EventBus)吗？说说你的理解"],["[vue]说说vue的优缺点分别是什么？"],["[vue]DOM渲染在哪个周期中就已经完成了？"],["[vue]第一次加载页面时会触发哪几个钩子？"],["[vue]vue生命周期总共有几个阶段？"],["[vue]vue生命周期的作用是什么？"],["[vue]vue和angular有什么区别呢？"],["[vue]如何引入scss？引入后如何使用？"],["[vue]使用vue开发过程你是怎么做接口管理的？"],["[vue]为何官方推荐使用axios而不用vue-resource？"],["[vue]你了解axios的原理吗？有看过它的源码吗？"],["[vue]你有封装过axios吗？主要是封装哪方面的？"],["[vue]如何中断axios的请求？"],["[vue]axios是什么？怎样使用它？怎么解决跨域的问题？"],["[vue]说说你对vue的template编译的理解？"],["[vue]v-on可以绑定多个方法吗？"],["[vue]vue常用的修饰符有哪些？列举并说明"],["[vue]你认为vue的核心是什么？"],["[vue]v-model是什么？有什么用呢？"],["[vue]说说你对vue的mixin的理解，有什么应用场景？"],["[vue]SPA首屏加载速度慢的怎么解决？"],["[vue]删除数组用delete和Vue.delete有什么区别？"],["[vue]动态给vue的data添加一个新的属性时会发生什么？怎样解决？"],["[vue]组件和插件有什么区别？"],["[vue]说说你使用vue过程中遇到的问题（坑）有哪些，你是怎么解决的？"],["[vue]说说你对选项el,template,render的理解"],["[vue]vue实例挂载的过程是什么？"],["[vue]vue在组件中引入插件的方法有哪些？"],["[vue]v-if和v-for的优先级是什么？如果这两个同时出现时，那应该怎么优化才能得到更好的性能？"],["[vue]分别说说vue能监听到数组或对象变化的场景，还有哪些场景是监听不到的？无法监听时有什么解决方案？"],["[vue]$nextTick有什么作用？"],["[vue]为什么data属性必须声明为返回一个初始数据对应的函数呢？"],["[vue]怎么在watch监听开始之后立即被调用？"],["[vue]watch怎么深度监听对象变化？"],["[vue]watch和计算属性有什么区别？"],["[vue]vue如何监听键盘事件？"],["[vue]v-for循环中key有什么作用？"],["[vue]怎么在vue中使用插件？"],["[vue]你有写过自定义组件吗？"],["[vue]说说你对keep-alive的理解是什么？"],["[vue]怎么使css样式只在当前组件中生效？"],["[vue]你有看过vue的源码吗？如果有那就说说看"],["[vue]你有写过自定义指令吗？自定义指令的生命周期（钩子函数）有哪些？"],["[vue]v-show和v-if有什么区别？使用场景分别是什么？"],["[vue]说说你对MVC、MVP、MVVM模式的理解"],["[vue]说下你对指令的理解？"],["[vue]请描述下vue的生命周期是什么？"],["[vue]vue组件之间的通信都有哪些？"],["[vue]什么是虚拟DOM？"],["[vue]什么是双向绑定？原理是什么？"],["[vue]vue和react有什么不同？使用场景是什么？"],["[vue]说说vue的优缺点"],["[vue]有使用过vue吗？说说你对vue的理解"],["[vue]vue-cli提供了的哪几种脚手架模板？"],["[vue]vue-cli工程中常用的npm命令有哪些？"],["[vue]在使用vue-cli开发vue项目时，自动刷新页面的原理你了解吗？"],["[vue]vue-cli3插件有写过吗？怎么写一个代码生成插件？"],["[vue]vue-cli生成的项目可以使用es6、es7的语法吗？为什么？"],["[vue]vue-cli怎么解决跨域的问题？"],["[vue]vue-cli中你经常的加载器有哪些？"],["[vue]你知道什么是脚手架吗？"],["[vue]说下你了解的vue-cli原理？你可以自己实现个类vue-cli吗？"],["[vue]怎么使用vue-cli3创建一个项目？"],["[vue]vue-cli3你有使用过吗？它和2.x版本有什么区别？"],["[vue]vue-cli默认是单页面的，那要弄成多页面该怎么办呢？"],["[vue]不用vue-cli，你自己有搭建过vue的开发环境吗？流程是什么？"],["[vue]vue-router怎么重定向页面？"],["[vue]vue-router怎么配置404页面？"],["[vue]切换路由时，需要保存草稿的功能，怎么实现呢？"],["[vue]vue-router路由有几种模式？说说它们的区别？"],["[vue]vue-router有哪几种导航钩子（ 导航守卫 ）？"],["[vue]说说你对router-link的了解"],["[vue]vue-router如何响应路由参数的变化？"],["[vue]你有看过vue-router的源码吗？说说看"],["[vue]切换到新路由时，页面要滚动到顶部或保持原先的滚动位置怎么做呢？"],["[vue]在什么场景下会用到嵌套路由？"],["[vue]如何获取路由传过来的参数？"],["[vue]说说active-class是哪个组件的属性？"],["[vue]在vue组件中怎么获取到当前的路由信息？"],["[vue]vur-router怎么重定向？"],["[vue]怎样动态加载路由？"],["[vue]怎么实现路由懒加载呢？"],["[vue]如果让你从零开始写一个vue路由，说说你的思路"],["[vue]说说vue-router完整的导航解析流程是什么？"],["[vue]路由之间是怎么跳转的？有哪些方式？"],["[vue]如果vue-router使用history模式，部署时要注意什么？"],["[vue]route和router有什么区别？"],["[vue]vue-router钩子函数有哪些？都有哪些参数？"],["[vue]vue-router是用来做什么的？它有哪些组件？"],["[vue]你有写过vuex中store的插件吗？"],["[vue]你有使用过vuex的module吗？主要是在什么场景下使用？"],["[vue]vuex中actions和mutations有什么区别？"],["[vue]vuex使用actions时不支持多参数传递怎么办？"],["[vue]你觉得vuex有什么缺点？"],["[vue]你觉得要是不用vuex的话会带来哪些问题？"],["[vue]vuex怎么知道state是通过mutation修改还是外部直接修改的？"],["[vue]请求数据是写在组件的methods中还是在vuex的action中？"],["[vue]怎么监听vuex数据的变化？"],["[vue]vuex的action和mutation的特性是什么？有什么区别？"],["[vue]页面刷新后vuex的state数据丢失怎么解决？"],["[vue]vuex的state、getter、mutation、action、module特性分别是什么？"],["[vue]vuex的store有几个属性值？分别讲讲它们的作用是什么？"],["[vue]你理解的vuex是什么呢？哪些场景会用到？不用会有问题吗？有哪些特性？"],["[vue]使用vuex的优势是什么？"],["[vue]有用过vuex吗？它主要解决的是什么问题？推荐在哪些场景用？"],["[vue]ElementUI是怎么做表单验证的？在循环里对每个input验证怎么做呢？"],["[vue]你有二次封装过ElementUI组件吗？"],["[vue]ElementUI怎么修改组件的默认样式？"],["[vue]ElementUI的穿梭组件如果数据量大会变卡怎么解决不卡的问题呢？"],["[vue]ElementUI表格组件如何实现动态表头？"],["[vue]ElementUI使用表格组件时有遇到过问题吗？"],["[vue]有阅读过ElementUI的源码吗？"],["[vue]项目中有使用过ElementUI吗？有遇到过哪些问题？它的使用场景主要是哪些？"],["[vue]有用过哪些vue的ui？说说它们的优缺点？"],["[vue]watch怎么深度监听对象变化"],["[vue]vue和react有什么不同？使用场景分别是什么？"]]},{name:"react",data:[["[react]什么时候使用状态管理器？"],["[react]render函数中return如果没有使用()会有什么问题？"],["[react]componentWillUpdate可以直接修改state的值吗？"],["[react]说说你对React的渲染原理的理解"],["[react]什么渲染劫持？"],["[react]React Intl是什么原理？"],["[react]你有使用过React Intl吗？"],["[react]怎么实现React组件的国际化呢？"],["[react]说说Context有哪些属性？"],["[react]怎么使用Context开发组件？"],["[react]为什么React并不推荐我们优先考虑使用Context？"],["[react]除了实例的属性可以获取Context外哪些地方还能直接获取Context呢？"],["[react]childContextTypes是什么？它有什么用？"],["[react]contextType是什么？它有什么用？"],["[react]Consumer向上找不到Provider的时候怎么办？"],["[react]有使用过Consumer吗？"],["[react]在React怎么使用Context？"],["[react]React15和16别支持IE几以上？"],["[react]说说你对windowing的了解"],["[react]举例说明React的插槽有哪些运用场景？"],["[react]你有用过React的插槽(Portals)吗？怎么用？"],["[react]React的严格模式有什么用处？"],["[react]React如何进行代码拆分？拆分的原则是什么？"],["[react]React组件的构造函数有什么作用？"],["[react]React组件的构造函数是必须的吗？"],["[react]React中在哪捕获错误？"],["[react]React怎样引入svg的文件？"],["[react]说说你对Relay的理解"],["[react]在React中你有经常使用常量吗？"],["[react]为什么说React中的props是只读的？"],["[react]你有使用过formik库吗？说说它的优缺点"],["[react]你有用过哪些React的表单库吗？说说它们的优缺点"],["[react]如果组件的属性没有传值，那么它的默认值是什么？"],["[react]可以使用TypeScript写React应用吗？怎么操作？"],["[react]super()和super(props)有什么区别？"],["[react]你有使用过loadable组件吗？它帮我们解决了什么问题？"],["[react]你有使用过suspense组件吗？它帮我们解决了什么问题？"],["[react]怎样动态导入组件？"],["[react]如何给非控组件设置默认的值？"],["[react]怎么在React中引入其它的UI库，例如Bootstrap"],["[react]怎样将事件传递给子组件？"],["[react]怎样使用Hooks获取服务端数据？"],["[react]使用Hooks要遵守哪些原则？"],["[react]render方法的原理你有了解吗？它返回的数据类型是什么？"],["[react]useEffect和useLayoutEffect有什么区别？"],["[react]在React项目中你用过哪些动画的包？"],["[react]React必须使用JSX吗？"],["[react]自定义组件时render是可选的吗？为什么？"],["[react]需要把keys设置为全局唯一吗？"],["[react]怎么定时更新一个组件？"],["[react]React根据不同的环境打包不同的域名？"],["[react]使用webpack打包React项目，怎么减小生成的js大小？"],["[react]在React中怎么使用async/await？"],["[react]你阅读了几遍React的源码？都有哪些收获？你是怎么阅读的？"],["[react]什么是React.forwardRef？它有什么作用？"],["[react]写个例子说明什么是JSX的内联条件渲染"],["[react]在React中怎么将参数传递给事件？"],["[react]React的事件和普通的HTML事件有什么不同？"],["[react]在React中怎么阻止事件的默认行为？"],["[react]你最喜欢React的哪一个特性（说一个就好）？"],["[react]在React中什么时候使用箭头函数更方便呢？"],["[react]你最不喜欢React的哪一个特性（说一个就好）？"],["[react]说说你对React的reconciliation（一致化算法）的理解"],["[react]使用PropTypes和Flow有什么区别？"],["[react]怎样有条件地渲染组件？"],["[react]在JSX中如何写注释？"],["[react]constructor和getInitialState有不同？"],["[react]写例子说明React如何在JSX中实现for循环"],["[react]为什么建议Fragment包裹元素？它的简写是什么？"],["[react]你有用过React.Fragment吗？说说它有什么用途？"],["[react]在React中你有遇到过安全问题吗？怎么解决？"],["[react]React中如何监听state的变化？"],["[react]React什么是有状态组件？"],["[react]React v15中怎么处理错误边界？"],["[react]React Fiber它的目的是解决什么问题？"],["[react]React为什么不要直接修改state？如果想修改怎么做？"],["[react]create-react-app有什么好处？"],["[react]装饰器(Decorator)在React中有什么应用？"],["[react]使用高阶组件(HOC)实现一个loading组件"],["[react]如何用React实现滚动动画？"],["[react]说出几点你认为的React最佳实践"],["[react]你是如何划分React组件的？"],["[react]举例说明如何在React创建一个事件"],["[react]如何更新组件的状态？"],["[react]怎样将多个组件嵌入到一个组件中？"],["[react]React的render中可以写{if else}这样的判断吗？"],["[react]React为什么要搞一个Hooks？"],["[react]React Hooks帮我们解决了哪些问题？"],["[react]使用React的memo和forwardRef包装的组件为什么提示children类型不对？"],["[react]有在项目中使用过Antd吗？说说它的好处"],["[react]在React中如果去除生产环境上的sourcemap？"],["[react]在React中怎么引用sass或less？"],["[react]组件卸载前，加在DOM元素的监听事件和定时器要不要手动清除？为什么？"],["[react]为什么标签里的for要写成htmlFor呢？"],["[react]状态管理器解决了什么问题？什么时候用状态管理器？"],["[react]状态管理器它精髓是什么？"],["[react]函数式组件有没有生命周期？为什么？"],["[react]在React中怎么引用第三方插件？比如说jQuery等"],["[react]React的触摸事件有哪几种？"],["[react]路由切换时同一组件无法重新渲染的有什么方法可以解决？"],["[react]React16新特性有哪些？"],["[react]你有用过哪些React的UI库？它们的优缺点分别是什么？"],["[react]<div onClick={handlerClick}>单击</div>和<div onClick={handlerClick(1)}>单击</div>有什么区别？"],["[react]在React中如何引入图片？哪种方式更好？"],["[react]在React中怎么使用字体图标？"],["[react]React的应用如何打包发布？它的步骤是什么？"],["[react]ES6的语法'...'在React中有哪些应用？"],["[react]如何封装一个React的全局公共组件？"],["[react]在React中组件的props改变时更新组件的有哪些方法？"],["[react]immutable的原理是什么？"],["[react]你对immutable有了解吗？它有什么作用？"],["[react]如何提高组件的渲染效率呢？"],["[react]在React中如何避免不必要的render？"],["[react]render在什么时候会被触发？"],["[react]写出React动态改变class切换组件样式"],["[react]React中怎么操作虚拟DOM的Class属性？"],["[react]为什么属性使用className而不是class呢？"],["[react]请说下react组件更新的机制是什么？"],["[react]怎么在JSX里属性可以被覆盖吗？覆盖的原则是什么？"],["[react]怎么在JSX里使用自定义属性？"],["[react]怎么防止HTML被转义？"],["[react]经常用React，你知道React的核心思想是什么吗？"],["[react]在React中我们怎么做静态类型检测？都有哪些方法可以做到？"],["[react]在React中组件的state和setState有什么区别？"],["[react]React怎样跳过重新渲染？"],["[react]React怎么判断什么时候重新渲染组件呢？"],["[react]什么是React的实例？函数式组件有没有实例？"],["[react]在React中如何判断点击元素属于哪一个组件？"],["[react]在React中组件和元素有什么区别？"],["[react]在React中声明组件时组件名的第一个字母必须是大写吗？为什么？"],["[react]举例说明什么是高阶组件(HOC)的反向继承？"],["[react]有用过React Devtools吗？说说它的优缺点分别是什么？"],["[react]举例说明什么是高阶组件(HOC)的属性代理？"],["[react]React的isMounted有什么作用？"],["[react]React组件命名推荐的方式是哪个？为什么不推荐使用displayName？"],["[react]React的displayName有什么作用？"],["[react]说说你对React的组件命名规范的理解"],["[react]说说你对React的项目结构的理解"],["[react]React16废弃了哪些生命周期？为什么？"],["[react]怎样在React中开启生产模式？"],["[react]React中getInitialState方法的作用是什么？"],["[react]React中你知道creatClass的原理吗？"],["[react]React中验证props的目的是什么？"],["[react]React中你有使用过getDefaultProps吗？它有什么作用？"],["[react]React中你有使用过propType吗？它有什么作用？"],["[react]React中怎么检验props？"],["[react]React.createClass和extends Component的区别有哪些？"],["[react]高阶组件(HOC)有哪些优点和缺点？"],["[react]给组件设置很多属性时不想一个个去设置有什么办法可以解决这问题呢？"],["[react]React16跟之前的版本生命周期有哪些变化？"],["[react]怎样实现React组件的记忆？原理是什么？"],["[react]创建React动画有哪些方式？"],["[react]为什么建议不要过渡使用Refs？"],["[react]在React使用高阶组件(HOC)有遇到过哪些问题？如何解决？"],["[react]在使用React过程中什么时候用高阶组件(HOC)？"],["[react]说说React diff的原理是什么？"],["[react]React怎么提高列表渲染的性能？"],["[react]使用ES6的class定义的组件不支持mixins了，那用什么可以替代呢？"],["[react]为何说虚拟DOM会提高性能？"],["[react]React的性能优化在哪个生命周期？它优化的原理是什么？"],["[react]你知道的React性能优化有哪些方法？"],["[react]举例说明在React中怎么使用样式？"],["[react]React有哪几种方法来处理表单输入？"],["[react]什么是浅层渲染？"],["[react]你有做过React的单元测试吗？如果有，用的是哪些工具？怎么做的？"],["[react]在React中什么是合成事件？有什么用？"],["[react]使用React写一个todo应用，说说你的思路"],["[react]React16的reconciliation和commit分别是什么？"],["[react]React的函数式组件有没有生命周期？"],["[react]useState和this.state的区别是什么？"],["[react]请说说什么是useImperativeHandle？"],["[react]请说说什么是useReducer？"],["[react]请说说什么是useRef？"],["[react]请说说什么是useEffect？"],["[react]举例说明useState"],["[react]请说说什么是useState？为什么要使用useState？"],["[react]请描述下你对React的新特性Hooks的理解？它有哪些应用场景？"],["[react]说说你对Error Boundaries的理解"],["[react]说说你对Fiber架构的理解"],["[react]说说你是怎么理解React的业务组件和技术组件的？"],["[react]为什么建议setState的第一个参数是callback而不是一个对象呢？"],["[react]展示组件和容器组件有什么区别？"],["[react]Mern和Yeoman脚手架有什么区别？"],["[react]你有在项目中使用过Yeoman脚手架吗？"],["[react]你有在项目中使用过Mern脚手架吗？"],["[react]shouldComponentUpdate方法是做什么的？"],["[react]怎样在React中使用innerHTML？"],["[react]你有写过React的中间件插件吗？"],["[react]React的中间件机制是怎么样的？这种机制有什么作用？"],["[react]React中你用过哪些第三方的中间件？"],["[react]不用脚手架，你会手动搭建React项目吗？"],["[react]请说说React中Portal是什么？"],["[react]React中修改prop引发的生命周期有哪几个？"],["[react]React多个setState调用的原理是什么？"],["[react]React中调用setState会更新的生命周期有哪几个？"],["[react]React中setState的第二个参数作用是什么呢？"],["[react]React中的setState是同步还是异步的呢？为什么state并不一定会同步更新？"],["[react]React中的setState批量更新的过程是什么？"],["[react]React中的setState执行机制是什么呢？"],["[react]在React中遍历的方法有哪些？它们有什么区别呢？"],["[react]请说说你对React的render方法的理解"],["[react]props.children.map和js的map有什么区别？为什么优先选择React的？"],["[react]有用过React的严格模式吗？"],["[react]React中的setState和replaceState的区别是什么？"],["[react]React中的setState缺点是什么呢？"],["[react]有用过React的Fragment吗？它的运用场景是什么？"],["[react]React组件间共享数据方法有哪些？"],["[react]React的状态提升是什么？使用场景有哪些？"],["[react]简单描述下你有做过哪些React项目？"],["[react]在构造函数中调用super(props)的目的是什么？"],["[react]你是如何学习React的？"],["[react]从旧版本的React升级到新版本的React有做过吗？有遇到过什么坑？"],["[react]你用过React版本有哪些？"],["[react]有用过React的服务端渲染吗？怎么做的？"],["[react]React的mixins有什么作用？适用于什么场景？"],["[react]React怎么拿到组件对应的DOM元素？"],["[react]请描述下事件在React中的处理方式是什么？"],["[react]JSX和HTML有什么区别？"],["[react]React的书写规范有哪些？"],["[react]create-react-app创建新运用怎么解决卡的问题？"],["[react]使用React的方式有哪几种？"],["[react]说说你对reader的context的理解"],["[react]同时引用这三个库React.js、React-dom.js和babel.js它们都有什么作用？"],["[react]你知道Virtual DOM的工作原理吗？"],["[react]你阅读过React的源码吗？简要说下它的执行流程"],["[react]React中怎样阻止组件渲染？"],["[react]React非兄弟组件如何通信？"],["[react]React兄弟组件如何通信？"],["[react]React非父子组件如何通信？"],["[react]React父子组件如何通信？"],["[react]React组件间的通信有哪些？"],["[react]类组件和函数式组件有什么区别？"],["[react]React自定义组件你写过吗？说说看都写过哪些？"],["[react]React组件的state和props两者有什么区别？"],["[react]React有几种构建组件的方式？可以写出来吗？"],["[react]React中遍历时为什么不用索引作为唯一的key值？"],["[react]React中的key有什么作用？"],["[react]React中除了在构造函数中绑定this,还有别的方式吗？"],["[react]在React中页面重新加载时怎样保留数据？"],["[react]请描述下React的事件机制"],["[react]怎样在React中创建一个事件？"],["[react]在React中无状态组件有什么运用场景？"],["[react]描述下在React中无状态组件和有状态组件的区别是什么？"],["[react]写一个React的高阶组件(HOC)并说明你对它的理解"],["[react]React中可以在render访问refs吗？为什么？"],["[react]React中refs的作用是什么？有哪些应用场景？"],["[react]请描述你对纯函数的理解？"],["[react]受控组件和非受控组件有什么区别？"],["[react]React中什么是非控组件？"],["[react]React中什么是受控组件？"],["[react]React中发起网络请求应该在哪个生命周期中进行？为什么？"],["[react]说说React的生命周期有哪些？"],["[react]说说你对“在React中，一切都是组件”的理解"],["[react]写React你是用es6还是es5的语法？有什么区别？"],["[react]浏览器为什么无法直接JSX？怎么解决呢？"],["[react]在使用React过程中你都踩过哪些坑？你是怎么填坑的？"],["[react]说说你喜欢React的原因是什么？它有什么优缺点？"],["[react]如何解决引用类型在pureComponent下修改值的时候，页面不渲染的问题？"],["[react]createElement与cloneElement两者有什么区别？"],["[react]解释下React中Element 和Component两者的区别是什么？"],["[react]解释下React中component和pureComponent两者的区别是什么？"],["[react]React的虚拟DOM和vue的虚拟DOM有什么区别？"],["[react]你觉得React上手快不快？它有哪些限制？"],["[react]说说你对声明式编程的理解？"],["[react]React与angular、vue有什么区别？"],["[react]React是哪个公司开发的？"],["[react]React是什么？它的主要特点是什么？"],["[react]简要描述下你知道的React工作原理是什么？"],["[react]在React中怎样改变组件状态，以及状态改变的过程是什么？"],["[react]在React中你是怎么进行状态管理的？"],["[react]React声明组件有哪几种方法，各有什么不同？"],["[react]如何在React Native中设置环境变量？"],["[react]请描述下Code Push的原理是什么？"],["[react]React Native怎样查看日记？"],["[react]React Native怎样测试？"],["[react]React Native怎样调试？"],["[react]React Native和React有什么区别？"],["[react]有做过React Native项目吗？"],["[react]React-Router怎么获取历史对象？"],["[react]React-Router怎么获取URL的参数？"],["[react]在history模式中push和replace有什么区别？"],["[react]React-Router怎么设置重定向？"],["[react]React-Router 4中<Router>组件有几种类型？"],["[react]React-Router 3和React-Router 4有什么变化？添加了什么好的特性？"],["[react]React-Router的实现原理是什么？"],["[react]React-Router 4的switch有什么用？"],["[react]React-Router的路由有几种模式？"],["[react]React-Router 4怎样在路由变化时重新渲染同一个组件？"],["[react]React-Router的<Link>标签和<a>标签有什么区别？"],["[react]React的路由和普通路由有什么区别？"],["[react]请你说说React的路由的优缺点？"],["[react]请你说说React的路由是什么？"],["[react]你有了解Rxjs是什么吗？它是做什么的？"],["[react]在Redux中怎么发起网络请求？"],["[react]Redux怎样重置状态？"],["[react]Redux怎样设置初始状态？"],["[react]Context api可以取代Redux吗？为什么？"],["[react]推荐在reducer中触发Action吗？为什么？"],["[react]Redux怎么添加新的中间件？"],["[react]redux-saga和redux-thunk有什么本质的区别？"],["[react]在React中你是怎么对异步方案进行选型的？"],["[react]你知道redux-saga的原理吗？"],["[react]你有使用过redux-saga中间件吗？它是干什么的？"],["[react]Redux中异步action和同步action最大的区别是什么？"],["[react]Redux和vuex有什么区别？"],["[react]Redux的中间件是什么？你有用过哪些Redux的中间件？"],["[react]说说Redux的实现流程"],["[react]Mobx的设计思想是什么？"],["[react]Redux由哪些组件构成？"],["[react]Mobx和Redux有什么区别？"],["[react]在React项目中你是如何选择Redux和Mobx的？说说你的理解"],["[react]你有在React中使用过Mobx吗？它的运用场景有哪些？"],["[react]Redux的thunk作用是什么？"],["[react]Redux的数据存储和本地储存有什么区别？"],["[react]在Redux中，什么是reducer？它有什么作用？"],["[react]举例说明怎么在Redux中定义action？"],["[react]在Redux中，什么是action？"],["[react]在Redux中，什么是store？"],["[react]为什么Redux能做到局部渲染呢？"],["[react]说说Redux的优缺点分别是什么？"],["[react]Redux和Flux的区别是什么？"],["[react]Redux它的三个原则是什么？"],["[react]什么是单一数据源？"],["[react]什么是Redux？说说你对Redux的理解？有哪些运用场景？"],["[react]请说说点击按钮触发到状态更改，数据的流向？"],["[react]请描述下Flux的思想"],["[react]什么是Flux？说说你对Flux的理解？有哪些运用场景？"],["[react]redux-saga和mobx有什么区别？"],["[react]redux实现异步的时期可以在哪些阶段？"],["[react]redux是如何实现异步的？"],["[react]为什么使用jsx的组件中没有看到使用react却需要引入react？"],["[react]你最喜欢react的哪些特性？"],["[react]一个新的react项目如果让你组织目录结构，你该如何组织？"],["[react]React如何拆分组件？原则是什么？"],["[react]如果直接修改this.state会触发渲染吗？为什么？"],["[react]如果不使用JSX,react可以正常工作吗？"],["[react]说说preact和react的区别有哪些？"],["[react]在 React 里，Component, Element, Instance 之间有什么区别和联系？"],["[react]react 为什么要提出 Expiration Time，并废弃 ReactPriorityLevel 模块（注意没有废弃 priority 这个概念）？"],["[react]请简述React中VirtualDOM的原理"],["[react]`super()`和`super(props)`有什么区别？"],["[react]`<div onClick={handlerClick}>单击</div>`和`<div onClick={handlerClick(1)}>单击</div>`有什么区别？"],["[react]描述下Code Push的原理是什么？"],["[react]React-Router 4中`<Router>`组件有几种类型？"],["[react]React-Router的`<Link>`标签和`<a>`标签有什么区别？"],["[react]react16跟之前的版本生命周期有哪些变化？"],["[react]怎样实现react组件的记忆？原理是什么？"],["[react]创建react动画有哪些方式？"],["[react]在react使用HOC有遇到过哪些问题？如何解决？"],["[react]在使用react过程中什么时候用HOC？"],["[react]请描述下flux的思想"],["[react]什么是flux？说说你对flux的理解？有哪些运用场景？"],["[react]redux的thunk作用是什么？"],["[react]redux的数据存储和本地储存有什么区别？"],["[react]在redux中，什么是reducer？它有什么作用？"],["[react]举例说明怎么在redux中定义action？"],["[react]在redux中，什么是action？"],["[react]在redux中，什么是store？"],["[react]为什么redux能做到局部渲染呢？"],["[react]说说redux的优缺点分别是什么？"],["[react]redux和flux的区别是什么？"],["[react]redux它的三个原则是什么？"],["[react]什么是redux？说说你对redux的理解？有哪些运用场景？"],["[react]react的路由和普通路由有什么区别？"],["[react]请你说说react的路由的优缺点？"],["[react]请你说说react的路由是什么？"],["[react]有做过react native项目吗？"],["[react]说说react diff的原理是什么？"],["[react]react怎么提高列表渲染的性能？"],["[react]react的性能优化在哪个生命周期？它优化的原理是什么？"],["[react]你知道的react性能优化有哪些方法？"],["[react]举例说明在react中怎么使用样式？"],["[react]react有哪几种方法来处理表单输入？"],["[react]在react中什么是合成事件？有什么用？"],["[react]使用react写一个todo应用，说说你的思路"],["[react]react16的reconciliation和commit分别是什么？"],["[react]react的函数式组件有没有生命周期？"],["[react]请描述下你对react的新特性Hooks的理解？它有哪些应用场景？"],["[react]说说你是怎么理解react的业务组件和技术组件的？"],["[react]怎样在react中使用innerHTML？"],["[react]你有写过react的中间件插件吗？"],["[react]react的中间件机制是怎么样的？这种机制有什么作用？"],["[react]react中你用过哪些第三方的中间件？"],["[react]不用脚手架，你会手动搭建react项目吗？"],["[react]请说说react中Portal是什么？"],["[react]react中修改prop引发的生命周期有哪几个？"],["[react]react多个setState调用的原理是什么？"],["[react]react中调用setState会更新的生命周期有哪几个？"],["[react]react中setState的第二个参数作用是什么呢？"],["[react]react中的setState是同步还是异步的呢？为什么state并不一定会同步更新？"],["[react]react中的setState批量更新的过程是什么？"],["[react]react中的setState执行机制是什么呢？"],["[react]在react中遍历的方法有哪些？它们有什么区别呢？"],["[react]请说说你对react的render方法的理解"],["[react]props.children.map和js的map有什么区别？为什么优先选择react的？"],["[react]有用过react的严格模式吗？"],["[react]react中的setState和replaceState的区别是什么？"],["[react]react中的setState缺点是什么呢？"],["[react]有用过react的Fragment吗？它的运用场景是什么？"],["[react]react组件间共享数据方法有哪些？"],["[react]react的状态提升是什么？使用场景有哪些？"],["[react]简单描述下你有做过哪些react项目？"],["[react]你是如何学习react的？"],["[react]从旧版本的react升级到新版本的react有做过吗？有遇到过什么坑？"],["[react]你用过react版本有哪些？"],["[react]有用过react的服务端渲染吗？怎么做的？"],["[react]react的mixins有什么作用？适用于什么场景？"],["[react]react怎么拿到组件对应的DOM元素？"],["[react]请描述下事件在react中的处理方式是什么？"],["[react]react的书写规范有哪些？"],["[react]使用react的方式有哪几种？"],["[react]同时引用这三个库react.js、react-dom.js和babel.js它们都有什么作用？"],["[react]你阅读过react的源码吗？简要说下它的执行流程"],["[react]react中怎样阻止组件渲染？"],["[react]react非兄弟组件如何通信？"],["[react]react兄弟组件如何通信？"],["[react]react非父子组件如何通信？"],["[react]react父子组件如何通信？"],["[react]react组件间的通信有哪些？"],["[react]react自定义组件你写过吗？说说看都写过哪些？"],["[react]react组件的state和props两者有什么区别？"],["[react]react有几种构建组件的方式？可以写出来吗？"],["[react]react中遍历时为什么不用索引作为唯一的key值？"],["[react]react中的key有什么作用？"],["[react]react中除了在构造函数中绑定this,还有别的方式吗？"],["[react]在react中页面重新加载时怎样保留数据？"],["[react]请描述下react的事件机制"],["[react]怎样在react中创建一个事件？"],["[react]在react中无状态组件有什么运用场景？"],["[react]描述下在react中无状态组件和有状态组件的区别是什么？"],["[react]写一个react的高阶组件并说明你对高阶组件的理解"],["[react]react中可以在render访问refs吗？为什么？"],["[react]react中refs的作用是什么？有哪些应用场景？"],["[react]react中什么是非控组件？"],["[react]react中什么是受控组件？"],["[react]react中发起网络请求应该在哪个生命周期中进行？为什么？"],["[react]说说react的生命周期有哪些？"],["[react]说说你对“在react中，一切都是组件”的理解"],["[react]写react你是用es6还是es5的语法？有什么区别？"],["[react]在使用react过程中你都踩过哪些坑？你是怎么填坑的？"],["[react]说说你喜欢react的原因是什么？它有什么优缺点？"],["[react]和Component两者的区别是什么？"],["[react]解释下react中component和pureComponent两者的区别是什么？"],["[react]react的虚拟DOM和vue的虚拟DOM有什么区别？"],["[react]你觉得react上手快不快？它有哪些限制？"],["[react]react与angular、vue有什么区别？"],["[react]react是哪个公司开发的？"],["[react]react是什么？它的主要特点是什么？"],["[react]简要描述下你知道的react工作原理是什么？"],["[react]在react中怎样改变组件状态，以及状态改变的过程是什么？"],["[react]在react中你是怎么进行状态管理的？"],["[react]react声明组件有哪几种方法，各有什么不同？"]]},{name:"nodejs",data:[["[NodeJs]请问package-lock.json和yarn.lock有什么区别？"],["[NodeJs]怎样加快npm install的安装速度？"],["[NodeJs]请解释下Semver是什么？"],["[NodeJs]npm i与npm ci有什么区别？"],["[NodeJs]说说你对nodejs中http parser流程的理解"],["[NodeJs]如何使用nodejs对base64进行编解码？"],["[NodeJs]如何获取项目的根路径？"],["[NodeJs]如果发现node_modules中有个模块代码有bug，你该怎么办？"],["[NodeJs]你有使用过npx吗？它主要解决什么问题？"],["[NodeJs]npm提供了哪些钩子？各有什么作用？"],["[NodeJs]如何使用Consul进行服务注册与服务发现？"],["[NodeJs]使用Consul解决了哪些问题？"],["[NodeJs]Consul的四大核心特性是什么？"],["[NodeJs]你了解Consul吗？说说它的运用场景有哪些？"],["[NodeJs]使用nodejs可以获取客户端连接的真实IP吗？为什么？如何获取？"],["[NodeJs]pm2的cluster和fork两种模块有什么区别？如何选择？"],["[NodeJs]koa中如果一个中间件没有调用await next()，结果会怎样？"],["[NodeJs]koa中next()的原理是什么？"],["[NodeJs]koa2相比koa1有什么改进呢？"],["[NodeJs]请说说koa的app.use()执行流程"],["[NodeJs]在开发nodejs的时候如何做到多版本共存？"],["[NodeJs]说说你对BFF的理解"],["[NodeJs]说说npm在使用过程中有什么不足的地方"],["[NodeJs]编写nodejs代码时为什么没法实时生效？"],["[NodeJs]require和import有什么区别？"],["[NodeJs]nodejs如何热部署（热更新）？"],["[NodeJs]使用npm安装模块时，如何选择--save和--save-dev？"],["[NodeJs]devDependencies和dependencies有区别？怎么选择用哪一个呢？"],["[NodeJs]npm i和npm install有什么区别？"],["[NodeJs]yarn模块中的yarn.lock文件有什么作用？"],["[NodeJs]你了解什么是集群吗？"],["[NodeJs]你知道什么是ORM吗？"],["[NodeJs]你有用过Node的哪些模板引擎呢？说下它们的区别"],["[NodeJs]你有写过定时任务吗？是用第三方模块吗？"],["[NodeJs]Mongodb如何批量更新文档？"],["[NodeJs]你对Mongodb有了解吗？"],["[NodeJs]如何构建一个简单的生产者与消费者模型？"],["[NodeJs]如何安装、启动一个 RabbitMQ 服务？"],["[NodeJs]MQ 的空间与时间解耦是什么？"],["[NodeJs]RabbitMQ的应用场景有哪些？"],["[NodeJs]为什么要使用RabbitMQ？"],["[NodeJs]yarn和npm有什么区别？"],["[NodeJs]你会搭建私有的npm仓库吗？怎么搭建？"],["[NodeJs]你有发布过自己的npm包吗？流程是怎样的？"],["[NodeJs].npmrc配置文件有什么用途？"],["[NodeJs]发布一个npm包如何忽略不需要发布的文件？"],["[NodeJs]nodejs中require方法是同步还是异步操作？为什么？"],["[NodeJs]你在Nodejs项目中使用过哪些数据库？"],["[NodeJs]常用的主流消息中间件都有哪些？"],["[NodeJs]你知道egg.js和thinkjs吗？说说它们的区别是什么？"],["[NodeJs]在Node项目中你有使用过哪些常用的中间件？"],["[NodeJs]你用过哪些Node的web框架？"],["[NodeJs]Node项目中，你是怎么记录日志的？"],["[NodeJs]I/O多路复用轮询技术select和epoll的区别是什么？"],["[NodeJs]说说你对EventLoop的理解"],["[NodeJs]说说你对线程模型的理解"],["[NodeJs]你有用过哪些断言库？"],["[NodeJs]nodejs如何高精度计时(纳秒)？"],["[NodeJs]如何高效地写入大文件（3G以上）？"],["[NodeJs]如何高效地读取大文件（3G以上）？"],["[NodeJs]写一个读取文件和文件的方法"],["[NodeJs]module.exports与exports的区别是什么？"],["[NodeJs]假设有a.js、b.js 两个模块相互引用，会有什么问题？是否为陷入死循环？"],["[NodeJs]Node的模块缓存在哪？"],["[NodeJs]Node的模块加载机制是什么？"],["[NodeJs]说说你对Node模块的理解"],["[NodeJs]你是如何选择Node.js的版本的？"],["[NodeJs]说说koa洋葱模型有什么优点？它是如何实现洋葱模型的？"],["[NodeJs]你自己有写过koa的中间件吗？"],["[NodeJs]你知道koa的中间件原理吗？"],["[NodeJs]koa是如何解决跨域的？"],["[NodeJs]你有使用过express和koa吗？它俩有什么区别？"],["[NodeJs]你有使用过NodeJs吗？说说你对它的理解，它的运用场景有哪些呢？"],["[NodeJs]你用NodeJs做过什么项目？"],["[NodeJs]你了解NodeJs的子进程吗？"],["[NodeJs]说说你对package.json的理解，它都有哪些作用？"],["[NodeJs]npm是干什么用的？它有什么优缺点？有没有类似的方案？"],["[NodeJs]你知道什么是REPL吗？"],["[NodeJs]请解释下你对EventEmitter的理解"],["[NodeJs]怎样在NodeJs中加载HTML文件？"],["[NodeJs]Node的全局对象有哪些？"],["[NodeJs]Node的全局变量有哪些？"],["[NodeJs]NodeJs的回调有什么用吗？"],["[NodeJs]NodeJs是基于单线程的吗？为什么？"],["[NodeJs]NodeJs和V8引擎是什么关系？"],["[NodeJs]你知道NodeJs是如何工作的吗？"],["[NodeJs]你是怎么调试NodeJs呢？有哪些方法？"],["[NodeJs]NodeJs适用于哪些场景开发？"],["[NodeJs]NodeJs的特性主要有哪些？"]]},{name:"webpack",data:[["[webpack]如何提高webpack的构建速度？"],["[webpack]webpack的构建流程是怎样的？"],["[webpack]如何选择是使用webpack还是rollup？"],["[webpack]webpack的loader和plugin的区别是什么？"],["[webpack]你有自己写过loader（加载器）或插件吗？"],["[webpack]说说你认为webpack的核心功能是什么？"],["[webpack]webpack中的resolve.modules和resolve.alias有什么区别？"],["[webpack]webpack如何解析代码路径的？"],["[webpack]在什么情况下选择webpack？在什么情况下选择rollup？"],["[webpack]webpack是如何处理模块化的？"],["[webpack]webpack的核心思想是什么？"],["[webpack]webpack和rollup有什么区别？"],["[webpack]webpack有gulp有什么区别？"],["[webpack]webpack有什么优劣势？"],["[webpack]你有用过webpack吗？"]]},{name:"wxxcx",data:[["[小程序]H5能否直接打开小程序？"],["[小程序]说说小程序的版本更新机制是什么"],["[小程序]你了解小程序的mp协议吗？"],["[小程序]如何获取软键盘的高度？"],["[小程序]如何解决小程序内嵌H5的缓存问题？"],["[小程序]小程序开发流程是什么样的？"],["[小程序]uniapp和微信小程序的生命周期有什么区别？"],["[小程序]说说你对微信小程序的生命周期的理解"],["[小程序]微信小程序first-child和last-child 失效如何解决？"],["[小程序]微信小程序如何跳转到不同的tabBar？"],["[小程序]微信小程序页面跳转导航wx.navigateTo和wx.redirectTo有什么区别？"],["[小程序]小程序中的onLoad和onShow有什么区别？"],["[小程序]uni-app开发中vue和nvue有什么区别？"],["[小程序]微信小程序的耗时主要体现在哪方面？如何优化？"],["[小程序]微信小程序rpx与px如何换算？"],["[小程序]微信公众号网页授权获取用户openId和微信公众号内获取的openId是否一样？"],["[小程序]微信公众号可以通过授权获取到用户的手机号吗？如果可以怎么做？"],["[小程序]微信小程序至少有几个文件？"],["[小程序]小程序关联微信公众号是如何确定用户的唯一性的？"],["[小程序]微信小程序和vue有什么区别？"],["[小程序]小程序的wxss和css有什么区别？"],["[小程序]你自己有开发过微信小程序吗？"]]},{name:"other",data:[["[软技能] 你有阅读过哪些类库的源码吗？你是如何阅读的？"],["[软技能] 你喜欢爬山吗？"],["[软技能] 你喜欢跑步吗？"],["[软技能] 你有参加过前端相关的线上或者线下大型会议吗？"],["[软技能] 你有经常参加同学或朋友聚会吗？"],["[软技能] 你所在的部门会经常聚餐吗？"],["[软技能] 你了解超分辨率吗？"],["[软技能] 你是如何自我提升的？"],["[软技能] 你是如何做到自我管理的？"],["[软技能] 你觉得哪些是伪程序员？"],["[软技能] 你知道显示器的刷新率是什么吗？"],["[软技能] 你使用过显示器的分辨率最高是多少？"],["[软技能] 你觉得人与人沟通的基本准则是什么？你自己认可哪一种？"],["[软技能] 你觉得前端程序员如何自我修练？"],["[软技能] 你是如何定义程序员的？"],["[软技能] 你觉得人工智能会取代前端吗？为什么？"],["[软技能] 你喜欢在线上视频学习吗？为什么？"],["[软技能] 你觉得哪些会议是无效的？"],["[软技能] 你喜欢哪个省市？为什么？"],["[软技能] 你会拒绝开什么样的会议？"],["[软技能] 在公司加班，你觉得公司应该给予什么样的福利？"],["[软技能] 公司加班到几点能你接受？为什么？"],["[软技能] 电脑连不上网，你知道怎么解决吗？"],["[软技能] 你对网络通信有了解吗？"],["[软技能] 前端如何预防羊毛党呢？有什么手段措施？"],["[软技能] 作为部门领导，你是如何计算投入产出比的？"],["[软技能] 薅羊毛的原理你知道吗？"],["[软技能] 你薅过羊毛吗？"],["[软技能] 站点超多图时，如何做图片优化？"],["[软技能] 如何调查用户的需求、痛点？"],["[软技能] 如何做用户画像分析？"],["[软技能] 用户画像都有哪些应用场景？"],["[软技能] 说说你对用户画像的理解"],["[软技能] 如何进行用户分析？"],["[软技能] 什么样的体验才是好的用户体验？"],["[软技能] 举例说明你体验最好的用户体验（可以是生活场景）？"],["[软技能] 你觉得你上学时哪门课程学得最好？为什么？"],["[软技能] 请说说你对用户体验的理解"],["[软技能] 你觉得你住的地方离公司远吗？"],["[软技能] 使用新技术在团队内推广是如何落地？"],["[软技能] 你们有自己的部署平台吗？流程是怎样的？"],["[软技能] 如何实现VR看房？"],["[软技能] 你有了解过VR吗？"],["[软技能] 你觉得工作中是否要学会“偷懒”？"],["[软技能] 你有算过团队的人力成本吗？"],["[软技能] git如何切换远程分支到本地？"],["[软技能] 说下你对内卷的个人理解"],["[软技能] 你认为3+1项目有答案好还是没答案好？为什么？"],["[软技能] 你有报名参加过哪些IT培训吗？"],["[软技能] 说说你是如何看待市面上的IT培训机构的？"],["[软技能] 你会经常出去旅游吗？"],["[软技能] 你有参加过什么类型的比赛吗？说说你的感受"],["[软技能] 你会厌倦工作吗？说说你的感受"],["[软技能] 说说你对多道批处理系统的理解"],["[软技能] 说说你对图片位深的理解"],["[软技能] 你觉得做编程这行需要高智商吗？为什么？"],["[软技能] 说说你对自测的理解及自测的方法有哪些?"],["[软技能] 你如何看待加班没有加班费的？"],["[软技能] 你能接受同一个岗位新来的同事工资给你高吗？"],["[软技能] 你被分配了一个几乎不可能完成的任务时，你会怎么做？"],["[软技能] 你有自己的自检清单吗？"],["[软技能] 你自己有整理过前端的知识图谱吗？"],["[软技能] 你认为到公司上班迟到会有什么影响？"],["[软技能] 写一个方法生成指定位数的数字，前面位数不够则补0"],["[软技能] 如何才写出好的前端代码呢？"],["[软技能] 你认为什么样的前端代码才是最好的？"],["[软技能] 说说你对前端数据层的理解"],["[软技能] 你有做过基于地图的应用吗？"],["[软技能] 你觉得网上视频教程怎么讲你才会比较容易接受？"],["[软技能] 你喜欢看哪类的网上视频教程？"],["[软技能] 如果你连续几天熬夜，你会怎么样？"],["[软技能] 说说你对家庭和谐的理解"],["[软技能] 说说你对Hash加密的理解"],["[软技能] 说说你对md5的理解"],["[软技能] 远程办公如何提高工作效率？"],["[软技能] 你有远程办公的经历吗？说说看"],["[软技能] 你是如何看待自由职业的？"],["[软技能] 页面写好了，接口还没好你该怎么办？"],["[软技能] 当你的工作被上级质疑时，你该怎么办？"],["[软技能] 长这么大，说说对你有影响的经历有哪些？"],["[软技能] 支持彩色字体有哪些格式？"],["[软技能] 什么是彩色字体？"],["[软技能] 你你说对成长的理解"],["[软技能] 作为一个前端工程师如何才能做到不焦虑？"],["[软技能] 你了解后端的知识体系吗？说说看"],["[软技能] 公司接了个项目，当甲方需求不明确你该怎么办？"],["[软技能] 你觉得在公司涨工资的条件是什么才是比较合理的？"],["[软技能] 你对你上家工作的薪资满意吗？"],["[软技能] 在工作中你有过焦虑吗？如何解决的？"],["[软技能] 你有写过从mysql中读取数据吗？"],["[软技能] 请说下你对“机遇”的理解"],["[软技能] 你工作中有记笔记的习惯吗？是如何记的？"],["[软技能] 分享下你或身边朋友自律的例子"],["[软技能] 引入的字体文件太大，如何优化？"],["[软技能] 面对突如其来的疫情，你怎么看？"],["[软技能] 前端如何实现低代码开发？"],["[软技能] 你有了解过低代码开发吗？说说你的理解"],["[软技能] 当大数据看板使用大量静态数据时，如何优化性能？"],["[软技能] 开发大数据看板时，使用的数据是静态的还是实时渲染的？"],["[软技能] 关于颜色的知识你了解多少？"],["[软技能] 做为前端开发，你有尝试过哪些深度思考？"],["[软技能] 你如何看待一句话需求？如何应对一句话需求？"],["[软技能] 你有使用过HBuilder吗？你喜欢它还是vs code？为什么？"],["[软技能] 做webAR你一般用哪些框架？"],["[软技能] 你有做过webAR吗？说说你的理解"],["[软技能] 说说你对全端、多端的理解"],["[软技能] 有多个任务时，你是如何管理这些任务的？"],["[软技能] 你有自己安装过虚拟机吗？主要是用来做什么？"],["[软技能] 你会配置nginx吗？"],["[软技能] 你会画原型吗？用什么工具？"],["[软技能] 你认为前端工程师有必要懂UI设计吗？"],["[软技能] 你认为前端开发的方向有哪些？"],["[软技能] 你有自己的个人网站吗？"],["[软技能] 你有开发过物联网系统吗？说说你的理解"],["[软技能] 你有开发过电商系统吗？说说你的理解"],["[软技能] 你理解的职场软技能有哪些？"],["[软技能] 你认为优秀的前端工程师需要具备哪些软技能？"],["[软技能] 你自己有封装过哪些组件吗？说说看"],["[软技能] 作为管理，你招聘前端的标准是什么？"],["[软技能] 你有经常和同事们组织户外活动吗？比如爬山，游泳等"],["[软技能] 有新的需求过来，你有拒绝过吗？"],["[软技能] 你会开车吗？"],["[软技能] 作为管理者，你是如何帮助团队成长呢？"],["[软技能] windows下的命令行你常用哪些命令？"],["[软技能] 你开发的web站点有处理网络断开的机制吗？"],["[软技能] 如果有一个项目要让你使用敏捷开发，你该如何做？"],["[软技能] 来这面试之前，你有没有看过哪些面试题？"],["[软技能] 你会经常参加户外运动吗？"],["[软技能] 你开发出的产品，你有去过第一现场看别人是怎么使用的吗？"],["[软技能] 现在的技术文章很多，你是如何做阅读过滤的？"],["[软技能] 你喜欢程序员这行业吗？为什么？"],["[软技能] 你平时写代码时重复的工作量多吗？主要在哪些方面？"],["[软技能] 你有想过做架构师吗？"],["[软技能] 你认为开发人员和测试人员怎样才能做到更好的平衡？"],["[软技能] 你认为开发人员和产品人员怎样才能做到更好的平衡？"],["[软技能] 说说你对冰山理论的理解"],["[软技能] 除了专业技能外，你觉得你还需具备什么样的软技能？"],["[软技能] 在工作中，你有过哪些方面的压力？"],["[软技能] 物联网将会对日常生活起到什么作用？"],["[软技能] 如接到紧急的任务，你该如何协调人员？"],["[软技能] 你喜欢早睡还是晚睡？为什么？"],["[软技能] 图片地址状态码返回200， 一定能请求的到图片么？"],["[软技能] 你上班一般是准时到还是提前到呢？"],["[软技能] 说说你学到的这些计算机技能除了做网站外还用这些技能做过什么有意义的事吗？"],["[软技能] 说下你了解的前端发展史"],["[软技能] 如何优化关键渲染路径？"],["[软技能] 如果有几本技术书籍，你只想买一本，你是如何选择的？"],["[软技能] 你读完一本书会写读后感吗？如何写呢？"],["[软技能] 说说你对原码、反码和补码的理解"],["[软技能] 中台和后台有什么不同？"],["[软技能] 说说你对中台的理解"],["[软技能] 说说你对微信抢红包技术的理解"],["[软技能] 你希望公司能给你什么样的帮助？为什么？"],["[软技能] 你的规划中，前端要学到什么样的程度？"],["[软技能] 请说说浏览器是如何加载资源的？"],["[软技能] 2021年，你最想学到的是一个技能是什么？"],["[软技能] 说说你对H5、小程序、APP三者之间区别的理解？"],["[软技能] 你认为领导和管理有什么区别？"],["[软技能] HTTP请求中的form data和request payload有什么区别？"],["[软技能] 你自己有哪些好的习惯？哪些坏的习惯？"],["[软技能] 你有午休习惯吗？"],["[软技能] 说说你对推荐算法的理解，它有哪些运用场景？你认为它的优缺点是什么？"],["[软技能] 为什么在chrome浏览器中打开多个标签页，其中一个崩溃了不会影响其它的标签页呢？"],["[软技能] 你有自己写过bash脚本吗？都有写过哪些脚本？"],["[软技能] Wi-Fi 6和5G相比哪个更快？为什么？"],["[软技能] 你最想在未来几年内接触哪些类型的项目？"],["[软技能] 在线版的代码编辑器，你觉得如何？"],["[软技能] 请解释下utf8和utf8mb4的区别"],["[软技能] 什么是文件的BOM头？"],["[软技能] 说说你对CSP的理解"],["[软技能] 你有洁癖吗？举例说说看"],["[软技能] 通过刚才的聊天，说说你对我的了解"],["[软技能] 你觉得你今天的面试表现如何？"],["[软技能] 你有用过哪些linux的命令？"],["[软技能] 你接手了一个老的项目，看到代码很烂，你是要重构它还是怎么办？"],["[软技能] 如何带领团队做代码走读？如果有5万行的代码，要如何走读？用哪些方法论？"],["[软技能] 如果要你实现一个秒杀的页面，前端方面应该考虑哪些问题？"],["[软技能] 你有看过三维立体画吗？知道是怎么制作出来的吗？"],["[软技能] WebSocket为什么可以实现持久连接？"],["[软技能] 说下SwiftUI和Flutter的比较"],["[软技能] 你期待我问你哪些方面的问题？"],["[软技能] 你知道2020年前端最火的技术是什么吗？"],["[软技能] 你认为前端未来的发展是怎样的？"],["[软技能] 说说你对前端领域模型的理解"],["[软技能] 请说说使用iconfont图标的优点和缺点"],["[软技能] png-8和png-24有什么区别？"],["[软技能] 你认为计算专业和非计算机专业的差别在哪？为什么？"],["[软技能] 如何实现记录用户的操作轨迹并还原？"],["[软技能] 现如今面对如层出不穷的类库，说说你的感受"],["[软技能] 如何在浏览器中播放pcm裸流音频？"],["[软技能] 在前后端分离项目里，请说说前端传递的token的流程？"],["[软技能] 在前后端分离的项目里，请说说前端跳转微信授权的流程是什么？"],["[软技能] 网站加载Waiting (TTFB)时间过长的原因是什么？如何解决？"],["[软技能] 女童鞋前端er，你是怎样做职业规划的？"],["[软技能] 你认为优秀的前端工程师要具体哪些素质？"],["[软技能] 你知道什么是短域名吗？说说它的原理"],["[软技能] 有新同事入职时，作为部门领导，你是如何向同事们介绍他的？"],["[软技能] 5G的卡出来后，卖的很便宜，流量又多，对我们公司的业务有影响嘛？"],["[软技能] 你平时有关注系DAU（日活跃用户数量）吗？觉得前端有必要关注吗？"],["[软技能] 如果要你设计一套公共组件，你应该怎么做？需要考虑哪些问题？"],["[软技能] 说说你对自律的理解"],["[软技能] 你觉得应该如何写好一个简历？都有哪些原则？"],["[软技能] 引导用户关注公众号的方式有哪些？"],["[软技能] 举例说明前端多线程开发在哪些场景下会适应到？"],["[软技能] 你觉得前端有必要学习数据结构和算法吗？为什么？"],["[软技能] 说说你对程序员都会修电脑的理解"],["[软技能] 来这面试前你有做过哪些准备吗？"],["[软技能] 涉及到用户隐私的操作有哪些？"],["[软技能] 前端性能的提升可以分为哪些类？"],["[软技能] 谈谈你对统计图表和分析图表的理解"],["[软技能] 图表有哪些应用场景？什么样的数据用什么样的图表展示？"],["[软技能] 图表有哪些分类？"],["[软技能] 说说你对前端图表应用的理解"],["[软技能] 你有做过大数据报表开发吗？都有哪些展现的形式？"],["[软技能] 大数据的到来对前端有什么影响？"],["[软技能] 说说你对大数据的理解"],["[软技能] 上拉加载和下拉刷新会遇到什么性能问题？"],["[软技能] 前端如何做单元测试？"],["[软技能] 你觉得前端有必要做单元测试吗？"],["[软技能] 与后端联调接口时，你总结下会出现哪些问题及如何解决？"],["[软技能] 你是如何保证你的网站可访问性？"],["[软技能] 你是如何设计前端缓存策略的？"],["[软技能] 说说你对3分钟热情和持续热情的理解"],["[软技能] 总结一下你写了这么久的代码的心得体会"],["[软技能] 培训编程思维的方法有哪些？"],["[软技能] 说说你对编程思维的理解"],["[软技能] 一个很重要的功能要上线，除了充分的测试外，还要如何把握好风险？"],["[软技能] 修改了文件并已commit，如何撤消？"],["[软技能] 修改了文件并已提交到暂存区（即已经add），如何撤消？"],["[软技能] 修改了文件，但并未提交到暂存区（即并没有add），如何撤消？"],["[软技能] 请说下V8、chrome、chromium三者之间的关系"],["[软技能] 什么是泛域名？如何做泛域名解析？"],["[软技能] 请说说你对鲁棒性的理解"],["[软技能] 说说你对自顶向下的编程方法的理解？"],["[软技能] 你是从哪些维度来评估代码的质量？"],["[软技能] 什么是流量劫持？如何防止流量劫持？"],["[软技能] 你希望通过这份工作获得什么？"],["[软技能] 你有什么爱好？"],["[软技能] 上传文件能使用GET请求吗？为什么？"],["[软技能] 如何把团队的工作经验沉淀下来？有哪些方法？"],["[软技能] 说说你对DNS劫持的理解"],["[软技能] UTC时间和GMT有什么区别？"],["[软技能] 什么是UTC时间？"],["[软技能] 说说你对图片压缩比的理解"],["[软技能] 你会装系统吗？都有哪些方法？"],["[软技能] 浏览器缓存什么时候会出现如下情况：from disk、from memory？"],["[软技能] 说说你理解的HTTP response 报文结构是怎样的？"],["[软技能] 说说你理解的HTTP request 报文结构是怎样的？"],["[软技能] 什么是GraphicLayer？"],["[软技能] 你学习的方法有哪些？有方法论吗？"],["[软技能] 你认为高级前端工程师应该具备哪些技能？"],["[软技能] 你认为中级前端工程师和高级前端工程师的差异在哪里？"],["[软技能] 如果把前端的知识做个体系分类，你是如何划分的？"],["[软技能] 如果让你的工作效率提升两倍，你会用什么方法？"],["[软技能] 你认为团队间哪种协同方式比较好？为什么？"],["[软技能] 埋点时，说说你上报数据的机制是什么？你是如何设计的？"],["[软技能] 你了解什么是冷启动吗？"],["[软技能] 请说说你对用以致学的理解？它和学以致用有什么不同？"],["[软技能] 给你一个目标网站，你是如何对它进行技术分析的？都从哪方面分析？"],["[软技能] 请说说浏览器都有哪些容错机制？"],["[软技能] 请说说你对DOM Parse的理解"],["[软技能] 在前端开发中，你有使用过二进制方面的知识吗？在哪些场景会用到？"],["[软技能] 你能手画出CSRF的攻击原理图吗？"],["[软技能] 请描述下XSS是如何攻击的？"],["[软技能] 说说你对前端缓存策略的理解"],["[软技能] 谈下你对裸职的看法"],["[软技能] 你平时喜欢看书吗？电子书还是实体书？为什么？"],["[软技能] 说说你在做开发的过程中，擅长的技术是什么？"],["[软技能] 你自己做过哪些完整项目，说说看"],["[软技能] 除了工作外，你为团队还做过哪些贡献？"],["[软技能] 你有自己或者为公司写过专利吗？"],["[undefined] undefined"],["[软技能] 说说你对专利的了解"],["[软技能] 你是如何评估工作量的？"],["[软技能] 你知道什么是破窗效应吗？它能指导我们什么？"],["[软技能] 你知道什么是脱敏吗？什么情况下要脱敏呢？"],["[软技能] 说说你对ASCII码的了解，它有什么用途？"],["[软技能] 说说纯前端目前还有哪些做不到的需求？为什么？"],["[软技能] 说说你是如何对做技术评审的，都要评审哪些方面呢？为什么？"],["[软技能] 浏览器缓存中的memory cache和disk cache有什么区别？"],["[软技能] 前端如何优化Content Download耗时太久的问题？"],["[undefined] undefined"],["[软技能] 说说你认为程序员要不要会修电脑？"],["[软技能] 如果有两个项目，要进行代码比较差异，你该如何操作？"],["[软技能] 你了解什么是无界画布吗？"],["[软技能] 在https站点下如何加载http的资源文件？"],["[undefined] undefined"],["[软技能] 有多个紧急任务同时到来，但人少又不够时，你要如何决策先做哪个？为什么？"],["[软技能] 如果要在页面上放一组图片轮播图，你认为多长时间播放一次比较好，为什么？"],["[软技能] 在css中汉字和英文字母的行高不同如何解决？"],["[软技能] 举例说明学习数据结构和算法有什么用？"],["[软技能] 说说你对我（面试官）的评价"],["[软技能] 你今年比去年最大的成长是什么（或想在哪方面有成长）？"],["[软技能] 说说你对上家公司的评价"],["[软技能] 你认为你在别人的眼里是一个什么样的人（别人如何评价你）？"],["[软技能] 你是如何做兼容性检测的？"],["[软技能] 为什么我们以0.0.0.0:80不能直接访问本地项目？"],["[软技能] 需要从前端上传一个大文件（如500M）到服务器，你是如何考虑的？"],["[软技能] 1.1版本http协议中的管道机制和非管道情况下处理差别体现在哪里？"],["[软技能] 1.1版本单个tcp连接下的http请求为什么只能同步处理？"],["[软技能] 为什么浏览器要限制tcp的连接最大个数？"],["[软技能] 301跳转和302跳转有什么区别？"],["[软技能] 说说你对单体应用的理解？单体应用有什么优缺点？"],["[软技能] 网站正在开发测试阶段，不想让百度抓取怎么办？"],["[软技能] 假如没有同源限制将会怎么样？"],["[软技能] 为什么要有同源限制？"],["[软技能] 请举例说明，你认为优秀的人身上会有哪些特质？"],["[软技能] 请说说你对DevOps的理解"],["[软技能] 说说你对alpha/beta/RC/Release各版本的理解"],["[软技能] 请解释下windows和linux中换行和回车的区别，以后在编码中应该注意什么？"],["[软技能] 说下你对json schema的理解"],["[软技能] 说说使用base64存储图片的优缺点"],["[软技能] 你对量子计算机有了解吗？说说当量子计算机普及时，对前端会有哪些改变？"],["[软技能] 你听过边缘计算吗？说说你对它的理解"],["[软技能] 说说你对3D打印的理解"],["[软技能] 你有完整看过微信公众平台开发的文档吗？说说你的感受"],["[软技能] 你有做过web端的压力测试吗？做压力测试有什么好处？怎么做？"],["[软技能] 你有考虑过当网络断时，页面将会有什么变化吗？如何做到断线重连？"],["[软技能] 你上家公司开发的系统（页面）是给谁用的？给他们解决了什么问题？他们是怎么用的？"],["[软技能] 你开发出的一个页面，在服务器下运行，请算下它的并发量（服务器配置自己假设）"],["[软技能] 你有做过数据分析吗？如何做的？"],["[软技能] 你有看过哪些框架或者类库的源码吗？通过看源码可以收获什么？"],["[软技能] svn仓库的提交记录能迁移到git吗？如何迁移？"],["[软技能] 有同事离职，你是如何让他交接的？都要交接哪些内容呢？"],["[软技能] 当团队有人遇到能力边界时，你做为他的主管你该怎么办？"],["[软技能] 说说你对http的报文字段upgrade的理解，它有什么作用？"],["[软技能] 开源等于免费吗？"],["[软技能] 说说你对开源协议的理解"],["[软技能] 说说你对跨域存储的理解，跨域存储存储的方案有哪些？"],["[软技能] 开发多个系统时如何共享组件化？有哪些方案？"],["[软技能] ws协议与http协议的不同？"],["[软技能] 说说你对serverless的理解，它对前端有什么影响？"],["[软技能] 你认为前端传输过程的参数需要加密吗？为什么？怎么加密更安全？"],["[软技能] 解释一下PRPL模式"],["[软技能] 项目工作量的评估中，“人天”指的是什么？它有什么作用？"],["[软技能] url的长度限制是多少呢？为什么会有这种限制？"],["[软技能] 你认为沟通和技术哪个更为重要？"],["[软技能] 你之前公司有做前端的基础建设吗？都有哪些方面？"],["[软技能] git区分大小写吗？如果不区分，那要如何设置？"],["[软技能] git怎样忽略已加入版本库的文件？"],["[软技能] 如何进行网站性能优化？"],["[软技能] 你知道什么是约定优于配置吗？说说你对它的理解"],["[软技能] 编程中经常会提到副作用，那副作用指的是什么？"],["[软技能] 你每天的工作是谁给你安排的？"],["[软技能] 说说你了解的前端代码评审Checklist有哪些项？"],["[软技能] 你是如何预估工作量的？有什么理论依据吗？"],["[软技能] 作为管理者，如果如何管理进度的？"],["[软技能] 作为管理者，要你设计一个日报（周报）的excel模板，你是如何？有什么原则？要查看哪些信息呢？"],["[软技能] 作为管理者，你觉得管理日常化的事情有哪些？"],["[软技能] 模块热替换(HMR)的原理是什么？"],["[软技能] 前端是如何监控性能的？"],["[软技能] 假如今天是你和你老婆结婚10周年重要的日子并已约好，公司突然有紧急的事情需要你亲自处理，你如何选择？"],["[软技能] 作为管理者，你是如何处理组织内部的矛盾？"],["[软技能] 当业务与技术冲突时你作为管理者你该如何决择？"],["[软技能] 你觉得团队管理，人的方面重要还事的方面重要？说说你的理由？"],["[软技能] 如果让你空降去管理团队，你如何让团队成员信服？"],["[软技能] 你认为管理团队有哪些核心的要素？"],["[软技能] 作为管理岗位，说下你带团队的经验吧"],["[软技能] 作为技术的Leader，你是如何管理好你的团队？"],["[软技能] 作为技术的Leader，带团队和提升开发能力的平衡点你是如何把握的？"],["[软技能] 你在web端实现过批量打印吗？如何实现？"],["[软技能] 如何解决android键盘回落后留白问题？"],["[软技能] 说说你对http3的理解，它主要解决了哪些问题？"],["[软技能] 为什么V8引擎这么快？"],["[软技能] 你知道什么是webAssembly吗？它的运用场景有哪些？"],["[软技能] websocket是如何实现握手？"],["[软技能] 说说你对覆盖率的理解，它解决什么问题？"],["[软技能] 说说你对持续集成的理解，它解决什么问题以及如何在前端中运用？"],["[软技能] 说说你对人脸识别的理解或者对原理的理解"],["[软技能] 你比去年的这个时候有哪些成长呢？"],["[软技能] 同步和异步什么区别？它们各有什么应用场景？"],["[软技能] web缓存需要后台或者运维怎么配合呢？"],["[软技能] 做为管理者，你是喜欢能说会道的还是喜欢安静做事的人呢？为什么？"],["[软技能] 功能上线后，发布报告要怎么写？你有写过吗？或者你有看过吗？"],["[软技能] 说说你对端到端交付的理解"],["[软技能] https是如何保证数据传输的安全的？"],["[软技能] 本地开发时如何不用修改hosts可以绑定域名开发？"],["[软技能] 请说说扫码登录的原理及流程"],["[软技能] 第三方网站使用QQ登录时，QQ是怎么检测到用户本地是否有QQ登录的？"],["[软技能] 举例说下主流手机的分辨率有哪些？"],["[软技能] 有ios和android两个下载链接，如何把它们合并成一个二维码？"],["[软技能] URL和URI有什么区别？"],["[软技能] 为什么nodejs更新代码后要重启进程，而PHP却不用呢？"],["[软技能] 你了解什么是像素追踪吗？它是用来做什么的？它的实现原理是什么？"],["[软技能] 前端是如何收集用户行为信息的？都有哪些方法呢？"],["[软技能] 请解释下dpr和dpi"],["[软技能] 一般情况下，大图片需要压缩到什么程度呢？"],["[软技能] 你是如何压缩图片的？用的什么工具？"],["[软技能] 解释下内网IP和公网IP是什么？"],["[软技能] 我们会经常用到ping命令，你知道它的作用和原理吗？"],["[软技能] 127.0.0.1和0.0.0.0的区别是什么？"],["[软技能] 你知道什么是硬编码吗？什么时候会用到硬编码呢？"],["[软技能] 对于2K、4K屏的逐渐流行，对于前端来说将会有哪些改变呢？"],["[软技能] 前端的错误有哪些分类？如果捕获这些错误？"],["[软技能] 你是专科学历，你将如何提升你的竞争力？"],["[软技能] 你是如何看待IT行业学历与经验间的关系？"],["[软技能] 全角字符和半角字符有什么区别？"],["[软技能] markdown文件如何实现页面内跳转？"],["[软技能] 说说你所在公司的git或svn提交注释的规范有哪些？"],["[软技能] 一般与git服务器连接有http/ssh等，你用的是哪种方式？为什么？"],["[软技能] 当需求不饱和时，多余的时间你会怎么利用？"],["[软技能] 当人手忙不过来时，你还会做代码测试吗？"],["[软技能] 你有自己做过外包吗？你对外包有什么看法？"],["[软技能] 你知道什么是伪静态吗？它有什么作用？如何实现伪静态呢？"],["[软技能] 前端代码你是如何做抽象的？"],["[软技能] 你喜欢用svn还是git？为什么？"],["[软技能] 说说你对端口的理解，端口号的范围是多少呢？"],["[软技能] 你是如何管理前端配置文件的？"],["[软技能] 如果同事编程能力比你低，你是如何与他合作的？反之呢？"],["[软技能] 你是如何看待男程序员的？"],["[软技能] 说说你对时间戳的理解"],["[软技能] 说说你对代码可移植性的理解"],["[软技能] 代码里为什么换行要使用\\r\\n？"],["[软技能] 如何让https和http切换时能共用cookie和localStorage？"],["[软技能] 开发H5时，你都用哪些真机测试呢？"],["[软技能] 位、字节、字符有什么区别？如何换算？"],["[软技能] 你能看懂时序图吗？有画过时序图吗？"],["[软技能] 都说前后端分离好，那重构前后端分离的目的是什么？"],["[软技能] 你有写过软件概要设计文档吗？都包括哪些内容？"],["[软技能] 如果给你配台新电脑，你需要什么样的配置？说说你的理由？"],["[软技能] 说下JWT的认证过程"],["[软技能] 说下你学习前端的历程吧"],["[软技能] 你喜欢在大公司工作还是小公司（创业公司）工作？为什么？"],["[软技能] 5G即将到来，你觉得对前端将面临什么挑战和机遇呢？"],["[软技能] 你有参与过哪些开源项目吗？有给项目提交过PR吗？"],["[软技能] 你喜欢在大城市工作还是小城市？为什么？"],["[软技能] 你想当全栈工程师吗？"],["[软技能] 做项目复盘时，是如何复盘的？都复盘哪些内容呢？"],["[软技能] 你对颜色的搭配有了解吗？你觉得红、绿、蓝分别搭配什么颜色比较好看呢？"],["[软技能] 如何确保TCP包的有序传输？"],["[软技能] TCP为什么是有状态的？"],["[软技能] 说说你对脚本语言的理解"],["[软技能] 上线后什么情况下会回滚呢？回滚的流程是怎样的？"],["[软技能] LF和CRLF的区别是什么？"],["[软技能] 做移动端开发时，你是如何调试的？"],["[软技能] 如何保证前端项目的质量？"],["[软技能] 什么是物理像素和逻辑像素？"],["[软技能] 当你拿到设计稿后，你首先要做的是什么呢？"],["[软技能] 你办公软件用得熟练吗？都有哪些技巧呢？"],["[软技能] 对于用户的隐私你是如何看待的？"],["[软技能] 让你去重构一个很老旧但很重要的系统，你的方法论是什么？"],["[软技能] 对于前端项目，你是如何做架构设计的？"],["[软技能] 你设计好的规范文档，团队人员不按照要求去执行怎么办？如何才能让大家认可并执行？"],["[软技能] 你认为微信或支付宝的哪些功能用户体验做得是非常好的？为什么？"],["[软技能] 你是怎么平衡及处理工作，学习，生活三者的关系？"],["[软技能] 说下你对噪声的理解，它在前端中有哪些应用场景呢？"],["[软技能] 登录时的验证码是纯数字的话，你觉得用4位数好还是6位数好？说说你的看法？"],["[软技能] 你知道什么是末位淘汰吗？说说你对它的理解"],["[软技能] 你喜欢弹性工作制吗？为什么？"],["[软技能] 后台接口返回的数据可信吗？如果不可信，那么前端应该怎么做？"],["[软技能] 你上家公司的组织架构是怎么样的？你觉得那里的组织架构有什么优缺点？"],["[软技能] 你有考虑过研发团队的整体支出情况吗？"],["[软技能] 你所在的公司有晋升体系吗？如果有那你有晋升过吗？如果没有，说说你心目中的晋升应该是什么样的？"],["[软技能] 如果给你接手团队的管理，团队内部的流程很乱你该怎么办？"],["[软技能] 说说你对UML的理解"],["[软技能] 对于网站的风格，你能说说在国内与国外的区别有哪些吗？"],["[软技能] 什么是cookie伪造？如何防止伪造？"],["[软技能] 举例说明恶意代码都有哪些？"],["[软技能] 127.0.0.1和localhost区别是什么？"],["[软技能] 发现了一个严重的bug，需跨多个部门协作定位并修改问题时，如何提升协作的效率？"],["[软技能] 如果你是Leader，如何提升团队的战斗力呢？"],["[软技能] 工作中如何高效沟通？"],["[软技能] 说说你对代码的可维护性的理解"],["[软技能] 你上家公司做的项目你有没有关注过qps？qps是多少呢？"],["[软技能] node的事件循环和浏览器的事件循环有什么区别？"],["[软技能] 你的数学学得怎么样？举例说明有哪些场景会用到很强的数学知识"],["[软技能] 有新同事入职，你是要安排他先做新项目还是老项目？为什么？"],["[软技能] 你有对接过微信支付吗？说说微信支付的流程"],["[软技能] 你上家公司对于前端部门的验收标准有吗？都规范了哪些标准呢？"],["[软技能] 为什么会有ipv6的出现？它的出现将会带动哪些产业的发展"],["[软技能] 二维码会不会重复？如果重复怎么办？"],["[软技能] 如果要你实现下拉刷新和下拉加载，说说你的技术方案"],["[软技能] 你知道什么是单点登录吗？说说单点登录的流程"],["[软技能] 说说你对“管理”职位的理解"],["[软技能] 你们平时怎么学习的效率最高？"],["[软技能] 周末，你在和朋友聚会喝酒吃饭，中途其他同事打电话让去公司解决紧急bug，这时你该怎么办？"],["[软技能] 你会沉迷于玩手机吗？对于微信的使用你是怎么看待的？"],["[软技能] 你认为企业内部协同工具最重要的功能是什么？"],["[软技能] 你上家公司内部用的是什么协同工具（企业微信、钉钉、QQ、RTX等）？"],["[软技能] 你有没有看过哪些开源项目的源码？说说你看源码的流程"],["[软技能] 你认为前端工程师需要很好的审美吗？"],["[软技能] 你知道什么是“银弹”吗？它指的是什么？"],["[软技能] 说说你对WASM的了解"],["[软技能] 如果HTTP2、5G普及了，浏览器也支持es module了，Webpack、Rollup这种打包工具还有意义吗？"],["[软技能] 你觉得自己的性格是内向还是外向的？"],["[软技能] 你会喝酒吗？平时没事时有没有小喝点？"],["[软技能] 你知道什么是RIA吗？"],["[软技能] 你知道什么是防御性编程吗？如何进行防御性编程？"],["[软技能] 怎样在HTTP1.1的基础上实现多路复用？"],["[软技能] 怎么让接口只能调用一次，再次刷新时就失效呢？"],["[软技能] 接口调用频率太高，如何做好接口的限制呢？"],["[软技能] 你一般用什么工具测试前端代码的性能？"],["[软技能] 请解释下http请求头中Referer的含义和作用是什么？"],["[软技能] 说说你对版权的理解，前端开发的过程中应该注意哪些版权相关的问题呢？"],["[软技能] 你认为做为前端开发是要自己切图好还是让美工来切图好呢？"],["[软技能] 你会自己切图吗？还是让设计员给你切呢？"],["[软技能] 怎么禁止爬虫对网站信息的抓取？"],["[软技能] 要你写一个手机端的图形解锁的工具，你的思路是什么？"],["[软技能] 你知道pass、sass、lass的区别是什么吗？"],["[软技能] 前端报错，你是怎么上报错误的？有哪些方法？"],["[软技能] 你还有什么问题想问我们的？"],["[软技能] 你知道什么是后端套模板吗？他们是怎么操作的知道吗？"],["[软技能] 你知道短网址是什么吗？知不知道它的实现原理？"],["[软技能] 你知道你开发好的页面，测试人员是从哪些方面来测的吗？"],["[软技能] QPS和TPS有什么区别？"],["[软技能] 说说你对请求数和并发数的理解"],["[软技能] WEB开发中的会话跟踪方法有哪些？"],["[软技能] 屏幕坐标、客户区域（可视窗口）坐标、页面坐标分别是什么？"],["[软技能] 你认为PC端开发和移动端开发主要有什么区别呢？"],["[软技能] 你知道什么是TC39吗？它们的工作流程是怎样的？"],["[软技能] 作为团队的Leader，最近发现你手下有位同事工作状态比较消极，你该怎么办？"],["[软技能] 如果只能选一个，工作和家庭你认为哪个更重要？说说你的理由？"],["[软技能] 你每天（周）会制定一天（周）的计划吗？是如何定的？"],["[软技能] 你知道什么是伪代码吗？如何编写伪代码呢？"],["[软技能] 如何做用户身份验证？"],["[软技能] 相同的内容生成的二维码是一样的吗？不同内容的二维码会不会重复？"],["[软技能] 什么是补间动画？它分为哪几种类型？"],["[软技能] 说说你对文件后缀的理解，为什么会有这么多种类型的后缀呢？"],["[软技能] 说说扫码登陆和扫码支付的原理及流程是什么？"],["[软技能] 如果要你定义一个版本号的规则，你该定义成什么样的？说说你的理由？"],["[软技能] 你上家公司是怎么管理版本的？"],["[软技能] 如何迁移仓库，同时保留原有的提交记录和分支？"],["[软技能] git pull 报错怎么解决？"],["[软技能] 如何禁止百度爬虫抓取网站？"],["[软技能] 你知道什么是中间人攻击吗？它产生的原因是什么？有什么危害？如何避免？"],["[软技能] 说说你遇到过最大的bug是什么？怎么解决的？"],["[软技能] 你认为一个友好的错误处理机制应该满足哪些条件？"],["[软技能] 现有几名候选人，说说你认为你的最大优势是什么？"],["[软技能] 你有使用过2k屏或4k屏吗？说说你对它们的理解"],["[软技能] 说说你对Retina高清屏的理解，它和2k屏有什么区别？"],["[软技能] 你为什么希望到我们公司工作？"],["[软技能] 举例说明前端的代码是如何解耦的？"],["[软技能] 前端做单元测试时基本原则有哪些？"],["[软技能] 解释下后端渲染与前端渲染有什么区别呢？"],["[软技能] 你们前端项目是怎么做监控（埋点）的？都监控哪些维度的数据呢？"],["[软技能] 你了解什么是极限编程吗？"],["[软技能] PWA如何改变我们的移动体验？"],["[软技能] 说说你对PWA的理解"],["[软技能] 请问单元测试和集成测试有什么区别？"],["[软技能] 举例说明你对时间复杂度和空间复杂度的理解"],["[软技能] 你觉得一线城市和三四线城市的区别在哪？你比较喜欢哪个？"],["[软技能] 你最近在忙什么？"],["[软技能] 你英语怎么样？不用全文翻译能正常阅读外文文档吗？"],["[软技能] 前端资源发布路径怎么实现非覆盖式发布（平滑升级）？"],["[软技能] 说说轮询、长轮询、长连接、socket连接、WebSocket的区别"],["[软技能] 图片是不是越小越好？如何优化图片呢？"],["[软技能] 你觉得前端有必要写文档吗？"],["[软技能] 长链接在http2中与http/1.1协议中有什么区别？"],["[软技能] 你知道网站运营的指标有哪些吗？"],["[软技能] 你知道网站的PV、UV、IP分别代表什么吗？"],["[软技能] Chrome浏览器允许的一次性最大TCP并发链接"],["[软技能] 在页面中引入静态资源文件，为什么静态资源文件改变后，再次发起请求还是之前的内容，没有变化呢？"],["[undefined] undefined"],["[软技能] 你知道PMP证书吗？"],["[软技能] 你认为作为一个管理岗位，最重要的是什么？请说出三点"],["[软技能] 如果让你去管理一个10人的前端团队，你该怎么管理？第一步先干嘛？"],["[软技能] 你知道什么是微服务吗？"],["[软技能] 你是怎样对首屏进行优化的呢？"],["[软技能] 你是如何看待女程序员的？"],["[软技能] 你觉得前端有必要懂后端语言吗？"],["[软技能] 把html、css、js这三个分别做个比喻，你会把它们比喻成什么呢？"],["[软技能] 开发触摸屏的页面时应该注意些什么问题？"],["[软技能] 你了解什么是物联网吗？"],["[软技能] 你有考过相关的技能证书吗？"],["[软技能] post和get有什么区别？它们分别在什么时候用到？"],["[软技能] 你是如何测试代码的性能的？都有用到哪些工具？"],["[软技能] 说下你对沉浸式体验的理解"],["[软技能] TCP和UDP属于计算机网络中的哪一层？"],["[软技能] OSI七层模型指的是哪七层？"],["[软技能] 说说你对304缓存的理解"],["[软技能] git pull和git fetch有什么区别呢？"],["[软技能] 说说你对前端架构师职位的理解，你觉得前端架构师应具备什么样的技能呢？"],["[软技能] 请问ie和chrome可以并行下载多少个资源？"],["[软技能] 说说栈和队列的区别是什么？"],["[软技能] ETag有什么运用场景呢？"],["[软技能] 请解释下Expires和Cache-Control有什么区别？"],["[软技能] 你认为前端工程师真正的价值体现在哪里？"],["[软技能] 常遇到的浏览器兼容性有哪些？你是怎样解决的？"],["[软技能] 举例说明你对前端自动化的理解 "],["[软技能] 举例说明你对前端工程化的理解 "],["[软技能] 有IT行业的实际工作中，有哪些操作是属于违法的呢？"],["[软技能] 你知道Nginx吗，知道如何利用Nginx反向代理吗？"],["[软技能] 用户在浏览器中禁用了js脚本时该怎么办？"],["[软技能] 你知道什么是RSS订阅吗？说说它的原理是什么？"],["[软技能] 做表单验证时主要是验证哪些内容呢？"],["[软技能] 说说你对相对路径和绝对路径的理解"],["[软技能] 请描述处TCP的三次握手和四次挥手"],["[软技能] 当网站遇到性能问题时，你是如何一步步解决的？说说你的方法"],["[软技能] 请说说协商缓存和强缓存的区别？"],["[软技能] HTTP的请求头有什么作用？它的应用场景有哪些？"],["[软技能] HTTP的请求除了get和post外还有哪些呢？说下你对它们的理解"],["[软技能] 你知道TCP和UTP的区别是什么吗？说说你对它们的理解"],["[软技能] 说说你对前端架构的理解"],["[软技能] 你当初为什么选择了前端？"],["[软技能] 资源加载失败，你是如何排查它的原因并解决呢？"],["[软技能] 你自己制作过字体吗？你知道字体是怎么制作出来的吗？"],["[软技能] 备案指的是域名备案还是空间备案呢？"],["[软技能] 你对“属于自己的时间”这句话是怎么理解的？你有属于自己的时间吗？"],["[软技能] 如何让大脑保持高速运行？"],["[软技能] 请举例说明你对MIME的理解"],["[软技能] 你认为全栈工程师应该具体什么样的条件（技能、素质等）？"],["[软技能] SEO是什么？TDK要怎么写才是最优的呢？"],["[软技能] 举例说明IE和chrome有哪些不一样的特性"],["[软技能] 说说你对TDD和BDD的理解"],["[软技能] 说说你对冒烟测试的理解"],["[软技能] 如何快速定位线上出现的问题？"],["[软技能] 如果有些地区的用户反应网站很卡很慢，可能是什么原因造成的呢？怎么样去解决？"],["[软技能] 你写的前端代码有做过单元测试吗？使用什么工具？怎么测试的？"],["[软技能] 你开发过程中，都有用过哪些虚拟机？"],["[软技能] 在实际中Git规范有哪些？"],["[软技能] 你对算法和数据结构有了解吗？说说看"],["[软技能] 为什么要在项目中使用CDN？"],["[软技能] 你有开发过chrome插件吗？说说你的开发过程"],["[软技能] 你是如何看待chrome将在2020年彻底放弃Flash？"],["[软技能] 你上家公司是做什么的？"],["[软技能] 如果你是上级领导，如何让团队中的成员成长起来呢？"],["[软技能] 你了解你的团队吗？说说你对他们的了解"],["[软技能] 你有新的想法或者学到了新的技术，你会应用到实际的项目中吗？"],["[软技能] 如果你是上级领导，有人不服你，你该怎么办？"],["[软技能] 举例说明你都会哪些与人沟通的技巧？"],["[软技能] 如果你是上级领导，你底下有个兄弟工作状态不是很好，你该怎么办？"],["[软技能] 你是如何管理你的下属的？"],["[软技能] 跟你聊了这么多，觉得挺投缘的，那你来说说你对我的初步认识吧"],["[软技能] 说下你对程序员中年危机的理解"],["[软技能] 有回老家发展的打算吗？"],["[软技能] 你怎么和你身边的急性子或慢性子同事沟通？"],["[软技能] 你有女朋友吗？你结婚了吗？有小孩吗？"],["[软技能] 说说你对开源项目的理解，它的意义何在？你有参与过开源项目吗？"],["[软技能] 你之前的公司有组织过分享会或者知识讲堂的活动吗？你有没有给同事分享过？"],["[软技能] 你有参加过技术讨论会或者座谈会相关的活动吗？"],["[软技能] 说下你对感染力的理解"],["[软技能] 你是如何与空降领导相处的？"],["[软技能] 上班时你会经常看手机吗？"],["[软技能] 在你专心写代码时，经常会有人在聊天工具上打扰你怎么办？"],["[软技能] 你觉得你每天最佳的工作时间是什么时候？"],["[软技能] 现在前后端分离，作为前端的你是怎么与其它部门合作的？"],["[软技能] 你是怎么理解团队合作的？"],["[软技能] 现在公司有好几个侯选人，用一句话突出你的竞争力吧"],["[软技能] 上级领导安排的任务过多无法完成，这时你该怎么办？"],["[软技能] 你最喜欢什么样的团队及团队氛围？"],["[软技能] 你心中认为最成功（最认可）的一个人是谁？说说你对他的评价"],["[软技能] 在工作中，你会有犹豫的时候吗？举个例子说明下"],["[软技能] 你最期望公司给你什么样的福利？"],["[软技能] 让你去攻破一个难题，你愿意接受挑战吗？"],["[软技能] 你现在手头上有其他公司的offer吗？"],["[软技能] 你上家公司的工资是多少呢？"],["[软技能] 如果一个团队里勾心斗角比较严重，你该怎么办？如果你是管理层你又该怎么办？"],["[软技能] 你觉得影响团队的战斗力有哪些方面的因素？"],["[软技能] 如果我们决定录用你，但薪资达不到你的要求，你愿意吗？最大幅度能接受降多少？"],["[软技能] 你喜欢什么样的领导？"],["[软技能] 你之前的工作有出过差吗？如果公司要求出差，你该怎么办？"],["[软技能] 你对工作环境有什么要求吗？"],["[软技能] 如果你来后接手的项目有很多问题，你该怎么办？"],["[软技能] 我们公司平时有组织羽毛球活动，你喜欢打羽毛球吗？打得如何？"],["[软技能] 你了解我们公司吗？说说你对我们公司的了解"],["[软技能] 你知道二进制、八进制、十进制、十六进制的区别吗？它们分别有什么应用场景？"],["[软技能] 你所在的公司里的项目有用过敏捷开发吗？请说说你对敏捷开发的理解"],["[软技能] 除了前端以外还了解什么其它技术么？你自己最最厉害的技能是什么？"],["[软技能] 说说你对自我认识边界的理解"],["[软技能] 在平时开发的时候，你有考虑过边界问题吗？说说你对边界的理解！"],["[软技能] 说说你对绩效的理解？"],["[软技能] 你平时有玩游戏吗？都玩什么游戏呢？玩得如何？"],["[软技能] 你平时熬夜吗？"],["[软技能] 前端如何预防SQL注入？"],["[软技能] 你知道什么是区块链吗？"],["[软技能] 前端如何防止XSS攻击？"],["[软技能] 你有想过创业的打算吗？"],["[软技能] 你知道什么是内网穿透吗？有没有玩过？"],["[软技能] 你要是在家时，公司网站出问题了你是怎么解决的？"],["[软技能] 假设有一个场景，需要前端自己计算十万级别或更多的数据，你有解决什么方案呢？"],["[软技能] 你有做过H5的游戏开发吗？说说它的开发步骤"],["[软技能] 你有做过Hybrid APP开发吗？说说你的经验"],["[软技能] 你是计算机专业的吗？你们上学都学了哪些内容？"],["[软技能] 你知道开发好的功能要自测吗？你一般是怎么自测的呢？"],["[软技能] 你有给自己制定过计划吗？怎么去落实的？"],["[软技能] 在工作中，你对开发环境有什么要求吗？"],["[软技能] 你有在linux下编程过吗？有使用过mac系统吗？说下它和win系统的区别？"],["[软技能] 你有用记事本来写过代码吗？说说你的感受！"],["[软技能] 强类型和弱类型语言的区别是什么？"],["[软技能] 你觉得该不该写注释？你写注释的原则是什么？"],["[软技能] 你有听说过“分词”吗？说说你对它的理解"],["[软技能] 你知道什么是人工智能和机器学习吗？说说你对它们的理解认知"],["[软技能] 你知道什么是PDCA吗？要怎么运用好它呢？"],["[软技能] 你知道什么是域名备案吗？备案有什么用？可以不备案吗？"],["[软技能] 你上家公司的接口是怎么管理的？"],["[软技能] 说说你对AMD、CMD和CommonJS的理解"],["[软技能] 你知道什么是ECMAScript吗？"],["[软技能] 你有自己写过爬虫的程序吗？说说你对爬虫和反爬虫的理解？"],["[软技能] 举例缓存头都有哪些？并说明它们的用处"],["[软技能] 说下你对可视化开发的理解"],["[软技能] 当线上代码出现问题了，你该怎么排查呢？"],["[软技能] 当接到一个新的需求时，你的第一反应是什么？"],["[软技能] 在工作中，你觉得如何提高幸福指数呢？"],["[软技能] 你对“技术服务于生活”的理解是什么？"],["[软技能] 你想当技术总监吗？你觉得技术总监应具备什么样的技能？"],["[软技能] 从你的角度上来说下你对“产品经理”这个岗位的理解"],["[软技能] 请解释下单线程与多线程之间的区别？"],["[软技能] 浏览器本地存储和服务器端存储有区别呢？"],["[软技能] 说下你对预加载的理解？"],["[软技能] 你有做过直播相关开发吗？知道它的原理吗？"],["[软技能] 写js代码时你喜欢哪种命名方式？"],["[软技能] 这么多年来，你值得骄傲坚持的是什么？"],["[软技能] 如何对前端资源进行优化？"],["[软技能] 说说你对前端工程师日常的开发流程的理解"],["[软技能] 你平时是如何管理项目的？"],["[软技能] 移动端的性能优化有哪些方法？"],["[软技能] 你知道什么是BLOB URL吗？为什么要使用它？"],["[软技能] 你知道时间四象限吗？说说你对它的理解"],["[软技能] 你知道什么是二、三级域名吗？举例说明下"],["[软技能] 你上家公司有写日报、周报或者月报吗？说说你对写日（周、月）这事的理解"],["[软技能] 你有做过PHP开发？说说你自己对“PHP是世界上最好的语言”这句话的理解"],["[软技能] 说说你们的项目上线流程是怎样的？"],["[软技能] 如何让你做一个文件无刷新上传的功能，你有哪些方法可以做到？"],["[软技能] 你有做过扫码枪的开发吗？知道它的原理吗？"],["[软技能] 请解释下你理解的并行和并发、同步和异步、阻塞和非阻塞之间有什么区别？"],["[软技能] 你有使用过FTP吗？你知道FTP它的作用是什么吗？"],["[软技能] 内存和缓存有什么区别？"],["[软技能] 客户投诉说网站有些功能用不了，你该怎么办？"],["[软技能] 说说你对堆和栈的理解，它们之间有什么区别？"],["[软技能] 说说你对矢量图和位图的理解，它们分别有什么运用场景？"],["[软技能] 你知道什么是AST吗？说说你对AST的理解，它的运用场景有哪些？"],["[软技能] 前端的性能统计有哪些指标？"],["[软技能] 移动端的用户体验有哪些优化的方法？"],["[软技能] 为什么提倡利用多个域名来存储网站的资源？"],["[软技能] W3C是什么？请说说你对它的理解"],["[软技能] 你有自己的博客吗？维护的频率是多久呢？"],["[软技能] 在选择框架时应该考虑哪些因素？"],["[软技能] 你觉得你上家公司的前端开发流程有什么地方要优化的吗？怎么优化呢？"],["[软技能] 你会PHP、JAVA、Python或GO吗？都有做过哪些应用呢？"],["[软技能] 你知道Jenkins吗？有没有用过？说说你对它的理解"],["[软技能] 你期望的薪资是多少呢？"],["[软技能] 你有玩过Docker吗？你知道它有哪些运用场景吗？"],["[软技能] 你知道什么是微格式(microformat)吗？说说你的理解，它有什么运用场景？"],["[软技能] 你了解什么是微前端吗？说说你对它的理解"],["[软技能] 你在工作中有用到过websocket吗？用它来解决什么问题？"],["[软技能] 说说你是怎么安排你工作外的时间的？"],["[软技能] 你会nodejs吗？说说你运用它的场景"],["[软技能] 你知道产品经理一般画的原型是用什么工具吗？有没有自己玩过？"],["[软技能] 说说你对重构的理解"],["[软技能] 关于重复造轮子这件事你是怎么理解的？"],["[软技能] 知道为何有些网站访不需要端口号？说说你对端口的理解？"],["[软技能] 说说你对移动端和web前端开发的主要区别是什么？"],["[软技能] 你有了解opengl吗？它有哪些作用？"],["[软技能] 说说你对Web App 、Hybrid App和Native App这三者的理解？"],["[软技能] 你有开发过弹幕吗？知道它的原理吗？说说看"],["[软技能] 你了解雅虎前端优化的35条军规吗？你能说上几条？"],["[软技能] 如果一个项目要你重构成前后端分离，你的方法论是什么？"],["[软技能] 用哪种格式可以存储包含Alpha通道的图像？Alpha通道是指什么？"],["[软技能] 你有签过保密协议吗？说说你对保密协议的理解"],["[软技能] 你对jsfuck有了解吗？它的原理是什么？请举例说明"],["[软技能] 你有做过骨架屏吗？它的原理是什么知道吗？"],["[软技能] 你今年多大了？请说说看你认为你的程序员生涯能做到多少岁？"],["[软技能] 对于前后端分离，你是怎么理解的？"],["[软技能] 说下你是如何从PS切出图的，有什么技巧？"],["[软技能] 你知道什么是B/S和C/S架构吗？说说它们的区别"],["[软技能] shim和polyfill有什么区别？它们分别有什么用？"],["[软技能] 在实际工作中，要是你的想法被反对时你该怎么办？"],["[软技能] 淘宝、京东、百度他们的网站首页秒开是如何做到的呢？"],["[软技能] 前端页面有哪三层构成？分别有什么作用？"],["[软技能] 你知道什么是图床吗？它有什么好处？"],["[软技能] 要你做一个国外的web页面，你需要考虑哪些问题？"],["[软技能] 你上家公司前端团队有多少人？是怎么分工的？"],["[软技能] Web安全色所能够显示的颜色种类有多少种？"],["[软技能] 域名解析它有哪几种方式？"],["[软技能] 描述下什么是域名解析？简述它的基本过程"],["[软技能] 请列举出多种减少页面加载时间的方法"],["[软技能] 进程与线程有什么区别？JS的单线程带来哪些好处？"],["[软技能] 你有自己买过服务器和域名用来搭建博客或者网站吗？"],["[软技能] 你有画过流程图吗？用过什么软件？开始和判定分别用什么图形表示？"],["[软技能] 你有用过单例模式吗？主要运用场景有哪些？"],["[软技能] 不查资料，你会手写正则吗？"],["[软技能] 你认为前端工程师应该分为哪些级别呢？说说你的看法"],["[软技能] 说说你对Git的branch, diff, merge的理解？"],["[软技能] 你知道什么是图片防盗链吗？防盗链怎么实现呢？说说你的方法"],["[软技能] 说说你对emoji表情的理解，前端如何处理emoji表情？它的运用场景有哪些？"],["[软技能] 简要描述下什么是DNS？它有什么用？"],["[软技能] 浏览器在什么情况下会出现“已拦截弹窗式窗口”？怎么解决？"],["[软技能] 你所在的团队有规范吗？举例说明都定义了哪些规范？"],["[软技能] 当项目准备上线前，你有做过哪些性能优化吗？"],["[软技能] 说说你对robots文件的理解，它有什么作用？"],["[软技能] 说说你对hosts文件的理解，它都有哪些作用？"],["[软技能] 你平常都看哪些方面的书？你看书的方法是怎样的？"],["[软技能] Git的reset和revert有什么区别？它们分别适用于什么场景？"],["[软技能] 你平时开发是用mac还是windows系统？至少举三个例子说明两者的区别？"],["[软技能] 刷新和强制刷新有什么区别？说说你对两者的理解"],["[软技能] 你会抓https和移动端的包吗？分别描述下这两种包要怎么抓？"],["[软技能] 说下你平时是怎么自学的？怎么安排时间的？"],["[软技能] 你申请的这个职位，你觉得你还欠缺什么呢？"],["[软技能] 你知道什么是websocket吗？它有什么应用场景？"],["[软技能] 一个项目写很多的纯静态页面，有公共的部分（例如头和尾）你是怎么提取公用的？"],["[软技能] 你有使用过JWT吗？说说你对它的理解"],["[软技能] 你会抓包吗？都有用过哪些抓包工具？"],["[软技能] 你对web服务器软件有了解吗？都使用过哪些？各有哪些优缺点呢？"],["[软技能] 说说你做过让你觉得最满意的项目是什么？为什么？"],["[软技能] 说下你对互联网行业及前端技术发展趋势的看法"],["[软技能] 说说你对RESTful的理解"],["[软技能] 你知道二维码的原理是什么吗？要把android和ios的下载地址合成一个二维码怎么做呢？"],["[软技能] 做了这么多年开发，说说你最大的感悟是什么？"],["[软技能] 本地git与远程仓库连接的方式有哪些？"],["[软技能] 为什么浏览器会有兼容的问题呢？"],["[软技能] js动画和css动画有什么区别？"],["[软技能] 你觉得你自己最大的优点和缺点分别是什么？能否举例说明一下？"],["[软技能] 如果面试官让你说说下你的家庭？你会从哪些方面说呢？"],["[软技能] 最后如果技术面和HR面问你：你还有什么问题吗？你分别会问些什么？"],["[软技能] 如果面试官让你先自我介绍下，然后说下你的工作经历，你该怎么说？"],["[软技能] 说说什么是设计模式，你最常用的设计模式有哪些？"],["[软技能] 说说你对同构和SSR的理解"],["[软技能] 知道IPV6是什么吗？说说它和IPV4的区别是什么？"],["[软技能] 如何预防掉头发？"],["[软技能] 对于让你接手一个你觉得很烂的老项目，你该怎么办？"],["[软技能] 对于5G的到来，你是怎么看的？说说你的想法"],["[软技能] 说说你对浏览器的关键渲染路径的理解"],["[软技能] 说说你对域名收敛和域名发散的理解？分别在什么场景下使用？"],["[软技能] 网站被劫持植入广告该怎么办？如何防止？"],["[软技能] 和你的上级领导意见不一致时你该怎么办？"],["[软技能] 有用过本地存储吗？有什么限制？有没有考虑过超出了限制怎么办？"],["[软技能] 说说你对CDN的理解，使用过程中有没有遇到过问题？"],["[软技能] 你写文档一般用什么工具？Markdown有用过吗？"],["[软技能] 说说你对http、https的理解"],["[软技能] 你有遇到过字体侵权的事吗？如何解决？"],["[软技能] 最近996一词很火，谈谈你对996的看法"],["[软技能] 如果HR说要做背调，还要你给出近三个月的银行流水，你该怎么办？"],["[软技能] 说说你对本项目的看法及建议"],["[软技能] 从你的角度上来讲，你觉得如何管理前端团队？"],["[软技能] 说说你对http、https、http2的理解"],["[软技能] 最近在学什么？能谈谈你未来3，5年给自己的规划吗？"],["[软技能] 你现在在团队是什么角色，有起到了什么显著的作用吗？"],["[软技能] 你有自己的博客吗？平时自己有写一些技术文章吗？"],["[软技能] 说说你对NodeJs的理解及用途"],["[软技能] 公钥加密和私钥加密是什么？"],["[软技能] 你知道网页三剑客指的是什么吗？你有用过Dreamwear吗？"],["[软技能] 如果让你快速使用一门你不熟悉的新技术，你该怎么办？"],["[软技能] 对于前端安全，你了解多少？说说你对XSS和CSRF的理解"],["[软技能] 谈一谈你知道的前端性能优化方案有哪些？"],["[软技能] 你了解什么是技术债务吗？"],["[软技能] 你对全栈工程师的理解是什么？"],["[软技能] 你在上一家公司工作流程是怎么样的，如何与其他人协作的？是怎样跨部门合作的？"],["[软技能] 对于有压力时，你是怎么抗压的？"],["[软技能] 解释下CRLF是什么？"],["[软技能] 在工作中能让你最有成就感的是什么？并介绍下你最得意的作品吧"],["[软技能] 在浏览器中输入url到页面显示出来的过程发生了什么？"],["[软技能] 你为什么离职呢？"],["[软技能] 你对Git的branch及工作流的理解是什么？"],["[软技能] 说说你工作中遇到过比较难的技术问题是什么？是如何解决的？"],["[软技能] 你经历过老板要求兼容IE吗？IE几？有什么感悟？"],["[软技能] 说说一件或几件（介绍下除了工作外）你觉得能为你面试加分的事"],["[软技能] 前端工程师这个职位你是怎么样理解的？聊聊它的前景？"],["[软技能] 来说说你对重绘和重排的理解，以及如何优化？"],["[软技能] 你会手写原生js代码吗？"],["[软技能] 最近都流行些什么？你经常会浏览哪些网站？"],["[软技能] 你如何看待团建的？你们团建一般都怎么实施？"],["[软技能] 说说你对SVN和GIT的理解和区别"],["[软技能] 你在的公司有没有做代码审查（CodeReview）？如果有是怎么做的？如果没有你觉得应该怎么做才更好？"],["[软技能] 对于加班你是怎么看的？"],["[软技能] 你最喜欢用哪些编辑器？喜欢它的理由是什么？"],["[软技能] http都有哪些状态码？"],["[软技能] 网页应用从服务器主动推送到客户端有那些方式？"]]}]}}]);