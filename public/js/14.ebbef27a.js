(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[14],{"0ad4":function(n,e,t){var o={"./0.概述笔记.md":"92fc","./1.node全栈项目依赖.md":"e52a","./2.node-schedule增加定时任务.md":"e68a"};function a(n){var e=s(n);return t(e)}function s(n){if(!t.o(o,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return o[n]}a.keys=function(){return Object.keys(o)},a.resolve=s,n.exports=a,a.id="0ad4"},"92fc":function(n,e,t){"use strict";t.r(e),e["default"]="# 一些散乱笔记\n\nnode 项目 遇到的坑\n\n- linux 部署 node 项目 后台运行 需要两次回车 ，第一次 退出 node 项目界面 ，第二次 才是背后运行\n- nohup , 后缀 $ ， forever start xxxxx, node ./server.js  \n- \n\n"},bbaf:function(n,e,t){"use strict";t.r(e);var o=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[t("q-markdown",{attrs:{"no-heading-anchor-links":"",extend:n.extendMarkdown,src:n.MainComponent}})],1)},a=[],s=t("3686"),i=t("1b62"),r="/books/node/",d=Object(s["a"])(t("0ad4"),"md",!0),l=d.all_components,c=d.all_modules,u={mixins:[i["c"],i["b"]],data:function(){return{relative_path:r,img_prefix:"."+r,tab:c[0].value,tab_level:1,MainComponent:l[c[0].value],tabs:c}},watch:{tab:function(n,e){this.MainComponent=l[this.tab],this.compute_img_prefix()}}},m=u,p=t("2877"),v=Object(p["a"])(m,o,a,!1,null,"86873e20",null);e["default"]=v.exports},e52a:function(n,e,t){"use strict";t.r(e),e["default"]='# node全栈项目的几套依赖参照\n\n```json\n{\n  "name": "node-web-fullstack",\n  "version": "0.0.1",\n  "description": "锦年node全栈学习项目",\n  "productName": "锦年fullstack",\n  "author": "jinnianwushuang ",\n  "private": true,\n  "main": "server.js",\n  "apidoc":{\n    "name": "锦年node全栈学习项目API",\n    "version": "0.1.0",\n    "description": "明日复明日，万事成蹉跎。",\n    "title": "锦年node全栈学习项目API",\n    "url": "http://192.168.0.36:19090"\n  },\n  "scripts": {\n    "test": "echo \\"No test specified\\" && exit 0",\n    "start-makedoc": "apidoc -i app/ -o apidoc/",\n    "start-docpage": " http-server ./apidoc -a 192.168.0.36 -p 19092 -s -o ",\n    "start-docpage-b": "http-server ./apidoc -a 192.168.0.36 -p 19092 -s -o ",\n    "start-server": "nodemon --harmony  server.js",\n    "start-webpage": "quasar dev",\n    "start-doc-s": "run-s start-makedoc start-docpage",\n    "start-fullstack-p": "run-p  start-server  start-webpage",\n    "init-env": "node init.js",\n    "start": "run-s  init-env   start2",\n    "start2": "run-p   start-fullstack-p start-doc-s"\n  },\n  "dependencies": {\n    "@quasar/extras": "^1.0.0",\n    "axios": "^0.18.1",\n    "body-parser": "^1.19.0",\n    "core-js": "^3.6.5",\n    "cors": "^2.8.5",\n    "express": "^4.17.1",\n    "lodash": "^4.17.20",\n    "log4js": "^6.3.0",\n    "md5": "^2.3.0",\n    "mongoose": "^5.8.10",\n    "mongoose-paginate-v2": "^1.3.9",\n    "quasar": "^1.0.0",\n    "vue-i18n": "^8.0.0"\n  },\n  "devDependencies": {\n    "@quasar/app": "^2.0.0",\n    "apidoc": "^0.25.0",\n    "http-server": "^0.12.3",\n    "nodemon": "^2.0.4",\n    "npm-run-all": "^4.1.5"\n  },\n  "browserslist": [\n    "ie >= 11",\n    "last 10 Chrome versions",\n    "last 10 Firefox versions",\n    "last 4 Edge versions",\n    "last 7 Safari versions",\n    "last 8 Android versions",\n    "last 8 ChromeAndroid versions",\n    "last 8 FirefoxAndroid versions",\n    "last 10 iOS versions",\n    "last 5 Opera versions"\n  ],\n  "engines": {\n    "node": ">= 10.18.1",\n    "npm": ">= 6.13.4",\n    "yarn": ">= 1.21.1"\n  }\n}\n```\n\n'},e68a:function(n,e,t){"use strict";t.r(e),e["default"]="# 从零开始在NodeJs中使用node-schedule增加定时任务\n\n## 简介\n\njava中直接使用定时器类就行了，但是在node中就没有这么简单了，只能使用setInterval或者setTimeout两个方法来实现，但是太繁琐了，搜索了之后发现`node-schedule`这个包，特意试用一下\n\n## 版本\n\nnode版本12.16.2\n\nkoa2版> 2.7.0\n\n## 1. 安装\n\n```javascript\nnpm insatll node-schedule -S\n\n```\n\n## 2. 使用方法\n\n### 2-1. 调用格式\n\n```javascript\n// 任务名称可以用中文，也可以用英文，但必须唯一\nschedule.scheduleJob(`任务名称`, `时间`, () => {\n});\n\n```\n\n### 2-2. 时间格式\n\n- 每分钟的第30秒触发： '30 * * * * *'\n- 每小时的1分30秒触发 ：'30 1 * * * *'\n- 每天的凌晨1点1分30秒触发 ：'30 1 1 * * *'\n- 每月的1日1点1分30秒触发 ：'30 1 1 1 * *'\n- 2016年的1月1日1点1分30秒触发 ：'30 1 1 1 2016 *'\n- 每周1的1点1分30秒触发 ：'30 1 1 * * 1'\n\n## 3. 在项目中使用\n\n### 3-1. 建立schedule.js\n\n```javascript\nconst schedule = require('node-schedule');\n\n// 生成新的定时任务\nlet interval = async (options) => {\n  return new Promise((resolve) => {\n    \n    // 这里设定14天为一个循环周期\n    // 假如设定的日期是2020-06-08, 返回就是{year: 2020, month: 6, day: 22, hour: 8, min: 0}\n    let time14 = GetDateStr(options.maintain_time, 14)\n    console.log(`${options.unit_name}_${time14.year}-${time14.month}-${time14.day}`, `1-2 1 1 ${time14.day} ${time14.month} *`)\n    \n    // 终止之前的定时任务\n    editMaintainTime(options)\n    \n    // 按照固定格式，设定定时任务，这里使用每条数据的唯一字段+定时任务时间，作为任务名称\n    // 任务名称就是'名字_2020-6-22'\n    // 任务时间就是'1-2 1 1 22 6 *' ，意思是每年的6月22日的1点1分的1秒~10秒触发，触发10次\n    schedule.scheduleJob(`${options.unit_name}_${time14.year}-${time14.month < 10 ? \"0\" + time14.month: time14.month}-${time14.day < 10 ? \"0\" + time14.day: time14.day}`, `1-10 * * ${time14.day} ${time14.month} *`, () => {\n        console.log(options,'The world is going to end today.' +  new Date())\n\n      // 写入你自己想在定时任务触发的时候，想要执行的函数\n    });\n}\n\n// 删除定时任务\nlet editMaintainTime = async (options) => {\n    console.log('options', options)\n  \n    // 查看所有的定时任务\n    for (let i in schedule.scheduledJobs) {\n      console.error(\"任务删除前：\"+i);\n    }\n    // 终止之前的定时任务\n    console.log('终止的任务', `${options.alarm14}`)\n    if (schedule.scheduledJobs[`${options.alarm14}`]) {\n      schedule.scheduledJobs[`${options.alarm14}`].cancel();\n    }\n    \n    // 查看剩下的定时任务\n    for (let i in schedule.scheduledJobs) {\n      console.error(\"任务删除后：\"+i);\n    }\n    // time.cancel()\n    \n     console.log('删除成功')\n}\n\n\n// 时间选择\nlet GetDateStr = (maintain_time, AddDayCount) => {\n  var dd = new Date(`${maintain_time}`);\n  dd.setDate(dd.getDate() + AddDayCount); // 获取AddDayCount天后的日期\n  var y = dd.getFullYear(); \n  var m = dd.getMonth() + 1\n  var d = dd.getDate()\n  var h = dd.getHours()\n  var min = dd.getMinutes()\n  return {\n    year: y,\n    month: m,\n    day: d,\n    hour: h,\n    min: min,\n  }\n}\n\nconst intervalControl = {\n  interval: interval\n}\n\nmodule.exports = intervalControl\n\n```\n\n### 3-2. 调用该方法\n\n```javascript\nconst intervalControl = require('../util/schedule')\n\n// options传入{unit_name: '名字', maintain_time: '自己选择的开始时间', alarm14: '上一次定时任务的任务名称'}\n// unit_name，无格式\n// maintain_time：2020-06-08\n// alarm14: 2020-06-22\nintervalControl.interval(options)\n```"}}]);