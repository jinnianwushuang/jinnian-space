(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[4],{"1b62":function(n,r,t){"use strict";t.d(r,"c",(function(){return l})),t.d(r,"b",(function(){return p})),t.d(r,"a",(function(){return b})),t("4de4"),t("c975");var e=t("448a"),i=t.n(e),a=["/第1阶段-运维基本功（升级7.6版本）/01运维概述与Linux系统安装.pdf","/第1阶段-运维基本功（升级7.6版本）/02Linux基础命令.pdf"],s="linux/heima-Linux云计算",l={name:"Container",data:function(){return{prefix:s,book_options:a,book_options_all:[],show:!0,book:a[0],src:""}},created:function(){this.book_options_all=i()(this.book_options),this.src=this.$utils.compute_book_src(this.prefix+this.book)},watch:{book:function(n,r){n&&this.change_book()}},methods:{change_book:function(){console.log("this.book",this.book),this.src=this.$utils.compute_book_src(this.prefix+this.book)},filterFn:function(n,r){var t=this;r(""!==n?function(){var r=n.toLowerCase();t.book_options=t.book_options_all.filter((function(n){return n.toLowerCase().indexOf(r)>-1}))}:function(){t.book_options=t.book_options_all})}}},o=t("ded3"),d=t.n(o),u=t("2f62"),p={data:function(){return{tab:"",tab_level:1,is_active:!1}},computed:d()({},Object(u["c"])(["get_current_selected_right_menu"])),created:function(){this.is_active=!0,this.fix_right_menu_config()},watch:{tab:function(){this.tab||this.fix_right_menu_config()},get_current_selected_right_menu:function(n,r){this.tab=this.get_current_selected_right_menu["t"+this.tab_level]}},methods:d()(d()({},Object(u["b"])(["set_right_menu_fix_config"])),{},{fix_right_menu_config:function(){this.set_right_menu_fix_config({tl:this.tab_level,tabs:this.tabs||[],tv:this.tab||this.tabs[0]["value"]})}}),beforeDestroy:function(){this.is_active=!1}},v=(t("99af"),t("d81d"),t("fb6a"),t("a434"),t("07ac"),function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{staticClass:"q-my-md q-mx-sm"},[t("div",{staticClass:"q-mb-md row q-gutter-x-md"},[t("q-select",{staticStyle:{width:"200px"},attrs:{dense:"",filled:"",options:n.column_options},on:{input:n.handle_column_change},scopedSlots:n._u([{key:"before",fn:function(){return[n._v("\n        列数\n      ")]},proxy:!0}]),model:{value:n.column,callback:function(r){n.column=r},expression:"column"}}),t("q-select",{staticStyle:{width:"300px"},attrs:{dense:"",filled:"",options:n.topic_options},on:{input:n.handle_topic_change},scopedSlots:n._u([{key:"before",fn:function(){return[n._v("\n      主题\n      ")]},proxy:!0}]),model:{value:n.topic,callback:function(r){n.topic=r},expression:"topic"}})],1),t("q-markup-table",{attrs:{dense:""}},[t("thead",[t("tr",[t("th",{staticClass:"text-left text-weight-bolder  ",attrs:{colspan:n.column}},[n._v("\n          "+n._s(n.table_title?n.table_title+"------":"")+"当前词条数量："+n._s(n.word_total)+"\n        ")])])]),t("tbody",[n._l(n.table_data,(function(r,e){return[n.compute_if_show(r)?t("tr",{key:e,class:n.compute_thead_data_style(r)},n._l(n.column,(function(e){return t("td",{key:e,staticClass:"text-left"},[n._v("\n            "+n._s(r[e-1])+"\n          ")])})),0):n._e()]}))],2)])],1)}),c=[],m=(t("caad"),t("a9e3"),t("2532"),{data:function(){return{topic:"",column:2}},props:{table_title:{type:String,default:""},word_total:{type:Number,default:0},topic_options:{type:Array,default:function(){return[]}},column_options:{type:Array,default:function(){return[]}},table_data:{type:Array,default:function(){return[]}},thead_data:{type:Array,default:function(){return[]}},show_empty_line:!1},created:function(){this.init_column(),this.handle_column_change(),this.handle_topic_change()},methods:{handle_column_change:function(){this.$emit("handle_column_change",this.column)},handle_topic_change:function(){this.$emit("handle_topic_change",this.topic)},init_column:function(){var n=this.$q.platform.is.desktop,r=window.innerWidth;r=n?r-200:r,r=r<370?370:r,console.log("ww",r);var t=Math.ceil(r/350);t=1==t?2:t,t=t>8?8:t,this.column=t},compute_thead_data_style:function(n){var r="",t=1==n.length&&this.thead_data.includes(n[0]);return r=t?"bg-teal-4":"",r},compute_if_show:function(n){if(this.show_empty_line)return!0;var r=n.filter((function(n){return n}));return r.length>0}}}),h=m,_=t("2877"),g=Object(_["a"])(h,v,c,!1,null,"9cfa5cf4",null),x=g.exports,b={components:{excelTable:x},data:function(){return{workSheetsFromFile:[[{data:[]}]],table_title:"",column:8,word_total:0,table_data:[],table_data_all:[],thead_data:[],column_options:[2,3,4,5,6,7,8],exclude_thead_data:!0,show_empty_line:!1,topic:"",topic_options:[]}},created:function(){this.init_workSheetsFromFile()},methods:{init_workSheetsFromFile:function(){},handle_column_change:function(n){this.column=n,this.init_data()},handle_topic_change:function(n){this.topic=n,console.log("this.topic----",this.topic),this.topic&&this.compute_table_data_show_and_word_total()},rebuild_arr_reduce_empty_line:function(n){var r=[[""]];return n.map((function(n){var t=n.filter((function(n){return n})),e=t.length;if(e)r.push(n);else{var i=r[r.length-1].filter((function(n){return n})).length,a=r[r.length-1].length;a>0&&i>0&&r.push([""])}})),r},init_data:function(){var n=this;console.log("workSheetsFromFile --------",this.workSheetsFromFile);var r=[],t={},e=[];this.workSheetsFromFile.map((function(n){r=r.concat(n["data"])}));var a=this.$lodash.cloneDeep(r[0].filter((function(n){return n})));a.map((function(n,r){t["key_"+r]={title:n,words_raw:[]}})),this.exclude_thead_data&&r.splice(0,1),r.map((function(n,r){n.map((function(n,r){t["key_"+r]["words_raw"].push(n)}))})),console.log("final_obj------------",t);var s=Object.values(t);s.map((function(r,t){e.push([r["title"]]),e=e.concat(n.$lodash.chunk(r["words_raw"],n.column)),e=e.concat([[""]])})),this.thead_data=i()(a),this.topic_options=i()(a),this.table_data_all=this.rebuild_arr_reduce_empty_line(e),this.compute_table_data_show_and_word_total(),console.log("  this.table_data  ",this.table_data)},compute_table_data_show_and_word_total:function(){var n=[],r=[],t=0;if(r=this.$lodash.cloneDeep(this.table_data_all),console.log(" table_data--------",r),this.topic){var e=this.topic_options.indexOf(this.topic),i=e==this.topic_options.length-1,a=i?"":this.topic_options[e+1],s=this.find_topic_index(this.topic),l=a?this.find_topic_index(a):r.length;n=r.slice(s,l)}else n=r;n.map((function(n){var r=n.filter((function(n){return n})).length;t+=r})),this.word_total=t,this.table_data=n},find_topic_index:function(n){for(var r=0,t=0;t<this.table_data_all.length;t++){var e=this.table_data_all[t];if(1==e.length&&e[0]&&e[0]==n){r=t;break}}return r}}}},"388d":function(n,r,t){"use strict";var e=t("f0ba"),i=t.n(e);i.a},e516:function(n,r,t){"use strict";t.r(r);var e=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",[t(""+n.tab,{tag:"component"})],1)])},i=[],a=function(){var n=this;return n.$createElement,n._self._c,n._m(0)},s=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("table",{staticStyle:{width:"1144px","border-collapse":"collapse","table-layout":"fixed"},attrs:{width:"1144",border:"1",cellpadding:"0",cellspacing:"0"}},[t("tr",{attrs:{height:"19"}},[t("td",{staticStyle:{width:"80px"}},[n._v("主题")]),t("td",{staticStyle:{width:"80px"}},[n._v("相关命令")]),t("td",{staticStyle:{width:"180px"}},[n._v("作用")]),t("td",{staticStyle:{width:"280px"}},[n._v("常用参数")]),t("td",{staticStyle:{width:"400px"}},[n._v("备注")])]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td",{attrs:{height:"234",rowspan:"6"}},[n._v("开关机")]),t("td",[n._v("shutdown")]),t("td",[n._v("关机或重启")]),t("td",[n._v("-r 重启"),t("br"),n._v("-h 关机"),t("br"),n._v("-k 警告"),t("br"),n._v("-c 取消")]),t("td",[n._v("\n          shutdown -r now"),t("br"),n._v("shutdown -h now"),t("br"),n._v("shutdown -r +1"),t("br"),n._v("\n          shutdown -h 1 一分钟后关机 "),t("br"),n._v("\n          shutdown -r 11:30 "),t("br"),n._v("\n          shutdown -c 撤销shutdown 命令\n        ")])]),t("tr",[t("td",[n._v("reboot")]),t("td",[n._v("重启")]),t("td"),t("td",[n._v("reboot")])]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td",[n._v("init")]),t("td",[n._v("运行级别")]),t("td",{attrs:{colspan:"2"}},[n._v("\n          systemctl get-default "),t("br"),n._v("\n          CentOS7的运行级别 "),t("br"),n._v("\n          0 shutdown.target 系统关机状态 halt init 0 "),t("br"),n._v("\n          1 emergency.target\n          单用户工作状态(类似Windows的安全模式，Linux忘记密码)"),t("br"),n._v("\n          2 rescure.target "),t("br"),n._v("\n          3 multi-user.target 命令行模式 多用户状态\n          (字符模式,服务基本都是此模式)"),t("br"),n._v("\n          4 无 系统未使用，留给用户"),t("br"),n._v("\n          5 graphical.target 图形模式 (个人计算机都是此模式)"),t("br"),n._v("\n          6 无 "),t("br")])]),t("tr",[t("td",[n._v("halt")]),t("td",[n._v("硬件关机")]),t("td"),t("td",[n._v("halt")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("poweroff")]),t("td",[n._v("硬件关机")]),t("td",[n._v("-f 强行关机")]),t("td",[n._v("poweroff"),t("br"),n._v("poweroff -f")])]),t("tr",[t("td",[n._v("sync")]),t("td",[n._v("将内存中数据回填到硬盘")]),t("td"),t("td",[n._v("sync;sync")])]),t("tr",{attrs:{height:"36"}},[t("td",{attrs:{height:"36"}},[n._v("启动X-Windows")]),t("td",[n._v("startx")]),t("td",[n._v("进入X-Window")]),t("td"),t("td",[n._v("进入X-Windows后可以用logout注销回到命令行")])]),t("tr",{attrs:{height:"36"}},[t("td",{attrs:{height:"180",rowspan:"3"}},[n._v("日期/时间")]),t("td",[n._v("cal")]),t("td",[n._v("日历")]),t("td"),t("td",[n._v("cal 2011"),t("br"),n._v("cal 03 2011")])]),t("tr",{staticStyle:{height:"81.00pt"}},[t("td",[n._v("date")]),t("td",[n._v("日期")]),t("td",[n._v("-s 修改日期"),t("br")]),t("td",[n._v("\n          date +%Y/%m/%d 按指定格式显示日期"),t("br"),n._v("date -s 07/13/2011"),t("br"),n._v("date -s\n          11:55:00"),t("br"),n._v("clock --systohc 将时间保存到硬件"),t("br"),n._v("date 071610512011\n          月日时分年"),t("br"),n._v("hwclock -w 写入主板芯片\n        ")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("time")]),t("td",[n._v("计算某个命令执行所耗费时间")]),t("td"),t("td",[n._v("\n          time sh myshell.sh"),t("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("  ")]),n._v("运行myshell.sh这个脚本所花的时间\n        ")])]),t("tr",[t("td",[n._v("公告")]),t("td",[n._v("wall")]),t("td",[n._v("广播")]),t("td"),t("td",[n._v("wall hello")])]),t("tr",[t("td",[n._v("清屏")]),t("td",[n._v("clear")]),t("td",[n._v("清屏")]),t("td"),t("td",[n._v("clear")])]),t("tr",[t("td",{attrs:{rowspan:"7"}},[n._v("帮助")]),t("td",[n._v("whatis")]),t("td",[n._v("命令介绍")]),t("td"),t("td",[n._v("whatis ls")])]),t("tr",[t("td",[n._v("apropos")]),t("td",[n._v("帮助一览")]),t("td"),t("td")]),t("tr",[t("td",[n._v("help")]),t("td",[n._v("帮助")]),t("td"),t("td",[n._v("help cd")])]),t("tr",[t("td",[n._v("--help")]),t("td",[n._v("帮助")]),t("td"),t("td",[n._v("ls --help")])]),t("tr",[t("td",[n._v("man")]),t("td",[n._v("参考手册")]),t("td",[n._v("可以像在vi里一样使"),t("span",{},[n._v("用斜杠来查找字符串")])]),t("td",[n._v("man ls | more")])]),t("tr",[t("td",[n._v("info")]),t("td",[n._v("相关信息")]),t("td"),t("td",[n._v("info ls")])]),t("tr",[t("td",[n._v("type")]),t("td",[n._v("查看一个命令是属于内部命令还是外部命令。")]),t("td"),t("td",[n._v("type cd")])]),t("tr",[t("td",{staticStyle:{height:"40.50pt"},attrs:{height:"54",rowspan:"2"}},[n._v("系统设定")]),t("td",[n._v("setup")]),t("td",[n._v("系统设定工具")]),t("td"),t("td",[n._v("修改/etc/sysconfig的内容")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("locale")]),t("td",[n._v("显示语系")]),t("td",[n._v("-a 显示所有支持的语系")]),t("td",[n._v("locale -a"),t("br"),n._v("cat /etc/sysconfig/i18n")])]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td",{attrs:{height:"234",rowspan:"6"}},[n._v("网络命令")]),t("td",[n._v("ifconfig")]),t("td",{attrs:{colspan:"2"}},[n._v("\n          ens33 ：是默认的网卡"),t("br"),n._v("\n          lo（loop，循环）：表示回环网卡，代表本机"),t("br"),n._v("\n          virbr0：虚拟网络接口"),t("br"),n._v("\n          # vim /etc/sysconfig/network-scripts/ifcfg-ens33"),t("br"),n._v('\n          TYPE="Ethernet"'),t("br"),n._v('\n          BOOTPROTO="dhcp"'),t("br"),n._v('\n          NAME="ens33"'),t("br"),n._v('\n          UUID="6c809893-d12c-46af-9987-4c05b2773c91"'),t("br"),n._v('\n          DEVICE="ens33"'),t("br"),n._v('\n          ONBOOT="yes"'),t("br"),n._v("\n          参数解析："),t("br"),n._v("\n          TYPE ：网络类型，Ethernet以太网"),t("br"),n._v("\n          BOOTPROTO：IP的获取方式，dhcp代表自动获取，static/none代表手工设置"),t("br"),n._v("\n          NAME ：网卡的名称（名字），ens33"),t("br"),n._v("\n          UUID ：代表网卡的UUID编号（必须是唯一的）"),t("br"),n._v("\n          DEVICE ：设备名称"),t("br"),n._v("\n          ONBOOT：代表网卡是否随计算机开启启动，yes随计算机开机启动，no代表不启动"),t("br")]),t("td",[n._v("\n          查看IP"),t("br"),n._v("设置IP"),t("br"),n._v("启用网卡"),t("br"),n._v("禁用网卡"),t("br"),n._v("\n          ifconfig"),t("br"),n._v("\n          ifconfig eth0 172.168.0.201 netmask 255.255.0.0"),t("br"),n._v("\n          ifconfig ens33 172.168.0.201 netmask 255.255.0.0"),t("br"),n._v("\n          ifconfig eth0 up"),t("br"),n._v("\n          ifconfig eth0 down\n        ")])]),t("tr",[t("td",[n._v("ifup")]),t("td",[n._v("启用网卡")]),t("td"),t("td",[n._v("ifup eth0")])]),t("tr",[t("td",[n._v("ifdown")]),t("td",[n._v("禁用网卡")]),t("td"),t("td",[n._v("ifdown eth0")])]),t("tr",[t("td",[n._v("route")]),t("td",[n._v("路由")]),t("td"),t("td")]),t("tr",{attrs:{height:"90"}},[t("td",[n._v("netstat")]),t("td",[n._v("显示Tcp/IP网络状态")]),t("td",[n._v("\n          -a 显示所有的socket"),t("br"),n._v("-n 以IP地址显示"),t("br"),n._v("-p 显示进程号"),t("br")]),t("td",[n._v("netstat -na")])]),t("tr",[t("td",[n._v("netconfig")]),t("td",[n._v("配置网络")]),t("td"),t("td",[n._v("修改的内容实际在 /etc/sysconfig/network-scripts 中")])]),t("tr",[t("td",{attrs:{height:"216",rowspan:"13"}},[n._v("系统信息查询")]),t("td",[n._v("whoami")]),t("td",[n._v("查看自己是谁")]),t("td"),t("td")]),t("tr",[t("td",[n._v("who am i")]),t("td",[n._v("查看自己账号及登录信息")]),t("td"),t("td",[n._v("通过su可以看到whoami和who am i的不同")])]),t("tr",[t("td",[n._v("who")]),t("td",[n._v("查看当前系统在线用户")]),t("td"),t("td",[n._v("who")])]),t("tr",[t("td",[n._v("w")]),t("td",[n._v("查看当前系统在线用户")]),t("td"),t("td",[n._v("who")])]),t("tr",[t("td",[n._v("last")]),t("td",[n._v("查看这个月的用户登录信息")]),t("td"),t("td",[n._v("last")])]),t("tr",[t("td",[n._v("hostname")]),t("td",[n._v("查看自己的主机名")]),t("td"),t("td",[n._v("hostname")])]),t("tr",[t("td",[n._v("hostnamectl")]),t("td",[n._v("设置自己的主机名")]),t("td"),t("td",[n._v("\n          hostnamectl -- "),t("br"),n._v("\n          静态的（static） "),t("br"),n._v("瞬态的（transient）"),t("br"),n._v("灵活的（pretty）"),t("br"),n._v("\n          hostnamectl --static set-hostname hr01.aa.cn\n        ")])]),t("tr",[t("td",[n._v("uname")]),t("td",[n._v("列出系统信息")]),t("td",[n._v("-a 查询所有")]),t("td",[n._v("uname -a")])]),t("tr",[t("td",[n._v("dmesg")]),t("td",[n._v("查看开机启动信息")]),t("td"),t("td",[n._v("dmesg")])]),t("tr",[t("td",[n._v("uptime")]),t("td",[n._v("查看开机时长")]),t("td"),t("td",[n._v("uptime")])]),t("tr",[t("td",[n._v("id")]),t("td",[n._v("查看自己及所属的组的信息")]),t("td"),t("td",[n._v("id")])]),t("tr",[t("td",[n._v("finger")]),t("td",[n._v("查看用户信息")]),t("td",[n._v("-s 完整列出")]),t("td",[n._v("finger -s username")])]),t("tr",[t("td",[n._v("groups")]),t("td",[n._v("查看自己属于哪些组")]),t("td"),t("td",[n._v("groups root")])]),t("tr",{attrs:{height:"36"}},[t("td",{attrs:{height:"36"}},[n._v("查看历史命令")]),t("td",[n._v("history")]),t("td",[n._v("历史命令")]),t("td"),t("td",[n._v("\n          history | tail -10"),t("br"),n._v("可以用!n执行第n条历史，!!执行最后一条命令\n        ")])]),t("tr",[t("td",{attrs:{height:"324",rowspan:"12"}},[n._v("账号管理")]),t("td",[n._v("newgrp")]),t("td",[n._v("登录另一个组")]),t("td"),t("td",[n._v("类似login动作")])]),t("tr",[t("td",[n._v("groupadd")]),t("td",{attrs:{colspan:"2"}},[n._v("\n          添加组（在/etc/group） "),t("br"),n._v("\n          -g 编号 "),t("br"),n._v("\n          tcpdump:x:72: "),t("br"),n._v("\n          组名:组密码:组编号:组内用户信息 "),t("br"),n._v("\n          自定义组从 1000开始"),t("br")]),t("td",[n._v("groupadd testing")])]),t("tr",[t("td",[n._v("groupdel")]),t("td",[n._v("删除组")]),t("td"),t("td",[n._v("groupdel test")])]),t("tr",[t("td",[n._v("groupmod")]),t("td",[n._v("修改组")]),t("td",[n._v("\n          -g 编号 "),t("br"),n._v("\n          -n 名称 "),t("br")]),t("td",[n._v("\n          groupmod -n test testing"),t("br"),n._v("\n          #groupmod -g 1100 -n bjhr hr"),t("br"),n._v("\n          含义：将hr组的组ID改成1100，组名改成bjhr"),t("br")])]),t("tr",[t("td",[n._v("gpasswd")]),t("td",[n._v("修改组的密码")]),t("td"),t("td")]),t("tr",[t("td",[n._v("useradd")]),t("td",{attrs:{colspan:"2"}},[n._v("\n          添加用户 "),t("br"),n._v("\n          etc/passwd 存储用户信息的文件"),t("br"),n._v("\n          用户：/etc/passwd文件，每创建一个用户，其就会在此文件中追加一行 "),t("br"),n._v("\n          # vim /etc/passwd"),t("br"),n._v("\n          root:x:0:0:root:/root:/bin/bash"),t("br"),n._v("\n          由上图可知，一共拥有7列"),t("br"),n._v("\n          第1列：用户名称"),t("br"),n._v("\n          第2列：用户的密码，使用一个x占位符，真实密码存储在/etc/shadow(1-用户名，2-加密密码)"),t("br"),n._v("\n          第3列：数字，用户的ID编号"),t("br"),n._v("\n          第4列：数字，用户的主组ID编号"),t("br"),n._v('\n          第5列：代表注释信息，useradd -c "备注信息" 用户名称'),t("br"),n._v("\n          第6列：用户的家目录，默认在/home/用户名称"),t("br"),n._v("\n          第7列：用户可以使用的Shell类型，useradd -s /bin/bash或/sbin/nologin\n          用户名称"),t("br")]),t("td",[n._v("\n          # useradd [选项 选项的值] 用户名称"),t("br"),n._v("\n          选项说明："),t("br"),n._v("\n          -g ：指定用户的主组的编号信息"),t("br"),n._v("\n          -s ：指定用户可以使用的Shell类型"),t("br"),n._v("\n          /bin/bash ：给人用的，给运维工程师"),t("br"),n._v("\n          /sbin/nologin ：给软件用的，比如mysql"),t("br"),n._v("\n          -G ：指定附属组的ID编号，如果有多个附属组，可以使用逗号隔开 useradd -G\n          1000,1001 .. 用户名称 会显示在 附加组 组信息后，主组不会"),t("br"),n._v("\n          -d ：指定用户的家，/home/itheima，useradd -d /itheima itheima"),t("br"),n._v("\n          -u ：指定用户的ID编号，默认是自动生成的"),t("br"),n._v("\n          -c ：comment，注释信息，scj:x:uid:gid:宋楚杰的账号"),t("br"),n._v("\n          -n ：取消以用户名称命名的组信息"),t("br"),n._v("\n          注意：不用任何参数，创建用户，系统会默认执行以下操作："),t("br"),n._v("\n          1）在 /etc/passwd 文件中创建一行关于zhangsan用户的数据"),t("br"),n._v("\n          2）在 /etc/shadow 文件中新增了一行关于zhangsan 密码的数据"),t("br"),n._v("\n          3）在 /etc/group 文件中创建一行与用户名相同的组，例如zhangsan"),t("br"),n._v("\n          4）在 /etc/gshadow\n          文件中新增一行与新增群组相关的密码信息，例如zhangsan"),t("br"),n._v("\n          5）自动创建用户的家目录，默认在/home下，与用户名同名"),t("br")])]),t("tr",[t("td",[n._v("userdel")]),t("td",{attrs:{colspan:"2"}},[n._v("\n          删除用户"),t("br"),n._v("\n          -r 连用户主目录一起删除 "),t("br"),n._v("\n          删除用户递归删除该用户所有文件 删除账号流程： "),t("br"),n._v("\n          ① 删除账号 "),t("br"),n._v("\n          ② 确认是否删除用户家 "),t("br"),n._v("\n          ③ 删除用户主组（没有其他用户） "),t("br")]),t("td",[n._v("\n          userdel -r zhangsan "),t("br"),n._v("\n          ps -ef |grep zhangsan"),t("br"),n._v("\n          搜索包含了zhangsan 关键词的所有进程 "),t("br"),n._v("\n          kill [-9] 进程的ID编号 "),t("br")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("usermod")]),t("td",{attrs:{colspan:"2"}},[n._v("\n          编辑用户"),t("br"),n._v("\n          # usermod [选项 选项的值] 用户名称 选项说明："),t("br"),n._v("\n          -g ：修改用户所属的主组的编号"),t("br"),n._v("\n          - l：修改用户的名称"),t("br"),n._v("\n          -s ：修改用户可以使用的Shell类型，如/bin/bash => /sbin/nologin"),t("br"),n._v("\n          扩展："),t("br"),n._v("\n          -L：锁定用户，锁定后用户无法登陆系统lock"),t("br"),n._v("\n          -U：解锁用户unlock"),t("br"),n._v("\n          了解："),t("br"),n._v("\n          -G ：修改用户附属组的编号信息"),t("br"),n._v("\n          -d ：修改用户的家目录"),t("br"),n._v("\n          -c ：修改用户的备注信息 "),t("br")]),t("td",[n._v("\n          usermod -g test51 root"),t("br"),n._v("\n          usermod -d /home/lisi zhangsan"),t("br"),n._v("\n          禁止linuxuser账号登录Linux操作系统"),t("br"),n._v("\n          usermod -s /sbin/nologin linuxuser"),t("br")])]),t("tr",{attrs:{height:"90"}},[t("td",[n._v("passwd")]),t("td",[n._v("修改用户的密码")]),t("td"),t("td",[n._v("\n          passwd zhangsan"),t("br"),n._v("\n          备注：如果忘记root密码，可以在开机时按下e进入grub编辑模式，移到kernel所在行，在最后的rhgb\n          quiet后输入 single。"),t("br"),n._v("\n          按回车确定后，按下b进入single模式。然后输入passwd修改密码。\n        ")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("chsh")]),t("td",[n._v("修改用户的默认SHELL"),t("br"),n._v("查看SHELL")]),t("td",[n._v("-l"),t("br"),n._v("-s")]),t("td",[n._v("chsh -l 查看shell"),t("br"),n._v("chsh root 修改root的默认shell")])]),t("tr",[t("td",[n._v("chfn")]),t("td",[n._v("更改注释字段")]),t("td"),t("td")]),t("tr",[t("td",[n._v("userconf")]),t("td"),t("td"),t("td")]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td",{attrs:{height:"324",rowspan:"9"}},[n._v("目录与路径")]),t("td",[n._v("cd")]),t("td",[n._v("进入到某个目录下")]),t("td",[n._v("~ 进入指定用户的主目录"),t("br"),n._v("- 返回之前进入的目录")]),t("td",[n._v("cd ~zhangsan"),t("br"),n._v("cd ~"),t("br"),n._v("cd"),t("br"),n._v("cd -")])]),t("tr",[t("td",[n._v("pwd")]),t("td",[n._v("显示当前目录的全路径")]),t("td"),t("td",[n._v("pwd")])]),t("tr",{staticStyle:{height:"94.50pt"},attrs:{height:"126"}},[t("td",[n._v("ls")]),t("td",[n._v("列出当前目录下的文件和目录")]),t("td",[n._v("\n          -l 详细信息"),t("br"),n._v("\n          -m 以逗号分割"),t("br"),n._v("\n          -a 显示隐藏文件"),t("br"),n._v("\n          -r"),t("br"),n._v("\n          -t"),t("br"),n._v("\n          -R 递归显示包含子目录"),t("br"),n._v("\n          -d 显示指定目录"),t("br"),n._v("\n          -x"),t("br"),n._v("\n          -h 人性化显示"),t("br")]),t("td",[n._v("ls -lrt"),t("br"),n._v("ls -la"),t("br"),n._v("ls -R")])]),t("tr",[t("td",[n._v("ll")]),t("td",[n._v("列出当前目录下的文件和目录")]),t("td",[n._v("\n          linux一共有7种文件类型,分别如下:"),t("br"),n._v("\n          -：普通文件"),t("br"),n._v("\n          d：目录文件"),t("br"),n._v("\n          l： 软链接（类似Windows的快捷方式）"),t("br"),n._v("\n          (下面四种是特殊文件)"),t("br"),n._v("\n          b：块设备文件（例如硬盘、光驱等）"),t("br"),n._v("\n          p：管道文件"),t("br"),n._v("\n          c：字符设备文件（例如猫等串口设备）"),t("br"),n._v("\n          s：套接口文件/数据接口文件（例如启动一个MySql服务器时会产生一个mysql.sock文件）"),t("br")]),t("td",[n._v("\n          等价于ls -l --color=tty （有颜色） "),t("br"),n._v("\n          -rw-r--r--. 1 root root 331270 Jul 7 08:25 a "),t("br"),n._v("\n          文件类型， 权限， 链接数， 属主，属组\n          ，文件大下，最后修改时间，文件名"),t("br"),n._v("\n          权限： 自己，组，其他人 "),t("br")])]),t("tr",[t("td",[n._v("vdir")]),t("td",[n._v("列出当前目录下的文件和目录")]),t("td"),t("td",[n._v("等价于ls -l （无颜色）")])]),t("tr",[t("td",[n._v("mkdir")]),t("td",[n._v("新建目录")]),t("td",[n._v("-p 递归创建")]),t("td",[n._v("\n          mkdir -p /dir1/dir2/dir3/dir4 "),t("br"),n._v("\n          mkdir dir1 dir2\n        ")])]),t("tr",[t("td",[n._v("rmdir")]),t("td",[n._v("删除空目录")]),t("td",[n._v("-p 递归删除")]),t("td",[n._v("\n          rmdir dir-path 从右侧向左侧递归删除 空目录"),t("br"),n._v("\n          rmdir dir1 dir2\n        ")])]),t("tr",[t("td",[n._v("basename")]),t("td",[n._v("获取文件名")]),t("td"),t("td",[n._v("basename $0")])]),t("tr",[t("td",[n._v("dirname")]),t("td",[n._v("获取目录名")]),t("td"),t("td",[n._v("dirname $0")])]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td",{attrs:{height:"252",rowspan:"10"}},[n._v("文件的查看")]),t("td",[n._v("cat")]),t("td",[n._v("显示文件内容")]),t("td",[n._v("\n          -n 对输出行编号"),t("br"),n._v("-v 显示控制字符"),t("br"),n._v("\n          -b和-n类似，但空白行不编号"),t("br"),n._v("\n          合并文件\n        ")]),t("td",[n._v("\n          cat /etc/profile"),t("br"),n._v("cat ~/.bash_profile"),t("br"),n._v("\n          cat -b file1 file2 file3"),t("br"),n._v("\n          cat -v file1 DOS下的换行符会以^M显示"),t("br"),n._v("\n          cat a.txt b.txt > d.txt 合并文件\n        ")])]),t("tr",[t("td",[n._v("tac")]),t("td",[n._v("逆向输出文件内容")]),t("td"),t("td",[n._v("tac myfile")])]),t("tr",[t("td",[n._v("nl")]),t("td",[n._v("显示文件内容")]),t("td"),t("td",[n._v("nl myfile")])]),t("tr",[t("td",[n._v("od")]),t("td",[n._v("以八进制显示文件内容")]),t("td"),t("td",[n._v("od myfile")])]),t("tr",[t("td",[n._v("more")]),t("td",[n._v("分页显示内容")]),t("td",[n._v("\n          b 向上 "),t("br"),n._v("\n          d 向下 "),t("br"),n._v("\n          文件整个加载在内存\n        ")]),t("td",[n._v("more myfile")])]),t("tr",[t("td",[n._v("less")]),t("td",[n._v("分页显示内容（可以上下翻页）")]),t("td",[n._v("\n          部分加载在内存 More Actions按键功能回车键向下移动一行"),t("br"),n._v("\n          d向下移动半页"),t("br"),n._v("\n          空格键向下移动一页"),t("br"),n._v("\n          b向上移动一页"),t("br"),n._v("\n          上下方向键向上与向下移动，less命令特有功能键"),t("br"),n._v("\n          less -N 文件名称显示行号/ "),t("br"),n._v("\n          字符串搜索指定的字符串"),t("br")]),t("td",[n._v("less myfile")])]),t("tr",[t("td",[n._v("head")]),t("td",[n._v("显示文件前面几行的内容")]),t("td",[n._v("\n          -n 行 "),t("br"),n._v("\n          -c 字节数 "),t("br")]),t("td",[n._v("head -n 10 /etc/passwd")])]),t("tr",[t("td",[n._v("tail")]),t("td",[n._v("显示文件后面几行的内容")]),t("td",[n._v("\n          -n 行 "),t("br"),n._v("\n          -c 字节数 "),t("br"),n._v("\n          -f 动态查看 "),t("br")]),t("td",[n._v("tail -n 20 /etc/passwd")])]),t("tr",[t("td",[n._v("strings")]),t("td",[n._v("查看二进制文件中的可打印字符")]),t("td"),t("td",[n._v("strings /bin/ls")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("touch")]),t("td",[n._v("新建文件"),t("br"),n._v("更新文件时间")]),t("td"),t("td",[n._v("\n          touch myfile1 myfile2"),t("br"),n._v("\n          touch aa{3..8}_test.js 批量创建 "),t("br")])]),t("tr",{attrs:{height:"90"}},[t("td",{attrs:{height:"90"}},[n._v("文件的编辑")]),t("td",[n._v("vi/vim")]),t("td",[n._v("编辑文件内容")]),t("td",[n._v("\n          esc 切换模式 "),t("br"),n._v("\n          编辑模式：a/i/o/A/I/O"),t("br"),n._v("\n          末行模式：冒号或者斜杠或者问号"),t("br"),n._v("\n          命令模式：定位，删剪"),t("br"),n._v("\n          可视化模式： v"),t("br"),n._v("\n          可视化模式 下 ，y 复制 p 粘贴 "),t("br"),n._v("\n          开启着色显示：`:syntax on` "),t("br"),n._v("\n          关闭着色显示：`:syntax off`"),t("br")]),t("td",[n._v("\n          编辑器 保存退出："),t("br"),n._v("\n          :wq 保存并退出 zz ， :x"),t("br"),n._v("\n          :w 文件名 保存到文件名 "),t("br"),n._v("\n          :q! 强制退出 不保存"),t("br"),n._v("\n          :! 暂时离开vi 执行其他命令"),t("br"),t("br"),n._v("\n          编辑器操作："),t("br"),n._v("\n          【[n]x】删除光标位置后面n个字符"),t("br"),n._v("\n          【[n]X】删除光标位置前面n个字符"),t("br"),n._v("\n          【D】删除光标所在位置后面到行尾的所有字符"),t("br"),n._v("\n          【[n]dd】删除光标所在行及下面n行 剪切"),t("br"),n._v("\n          【p|P】在光标【下|上】一行粘贴"),t("br"),n._v("\n          【[n]yy】复制光标所在行及下面n行 "),t("br"),n._v("\n          【dG】删除光标所在行到文件结尾"),t("br"),n._v("\n          【J】合并光标所在行和下一行 中间用空格连接"),t("br"),n._v("\n          【.】执行上一次命令行操作"),t("br"),n._v("\n          【u】撤销 【ctrl +r】 取消撤销"),t("br"),t("br"),n._v("\n          编辑器定位："),t("br"),n._v("\n          【ctrl+[b|u]】上翻页 行号减小"),t("br"),n._v("\n          【ctrl+[f|d]】下翻页 行号增加"),t("br"),n._v("\n          【gg】定位在文件第一行行首"),t("br"),n._v("\n          【G】定位在文件最后一行行首"),t("br"),n._v("\n          【$ 】定位行尾 【n +$】 向下 跳过 n行"),t("br"),n._v("\n          【[n]G | [n]gg】定位在n行"),t("br"),n._v("\n          【[n]L】 定位在倒数第n行"),t("br"),n._v("\n          注意：在查找一些特殊含义的字符时，需要加上转义字符"),t("br"),n._v("\n          【/内容】查找"),t("br"),n._v("\n          【n】查找下一个"),t("br"),n._v("\n          【N】查找上一个"),t("br"),n._v("\n          【?】查找上一次的所搜内容"),t("br"),n._v("\n          【/^word】 查找以word开头的内容"),t("br"),n._v("\n          【/word$】 查找以word结尾的内容"),t("br"),n._v("\n          【/.】查找任意一个字符"),t("br"),n._v("\n          【/*】查找任意多个字符"),t("br"),t("br"),n._v("\n          编辑器替换："),t("br"),n._v("\n          【r】替换光标所在位置的字符"),t("br"),n._v("\n          【:r 文件名】在光标当前行的下一行插入一个文件"),t("br"),n._v("\n          【:s/a/b/g】将光标所在行的a替换为b"),t("br"),n._v("\n          【:g/a/s//b/g】将文件中所有a替换为b"),t("br"),n._v("\n          【:%s/a/b/g】将文件中所有a替换为b"),t("br"),n._v("\n          【:%s#/bin/bash#we666#g】将文件中所有/bin/bash替换为we666"),t("br"),n._v("\n          【:n1,n2 s/a/b/g】将行区间n1到n2的行中所有的a替换为b"),t("br"),t("br"),n._v("\n          编辑器设置："),t("br"),n._v("\n          【:set ic】搜索时不区分大小写"),t("br"),n._v("\n          【:set noic】搜索时区分大小写 "),t("br"),n._v("\n          【:set nu | nonu】 [不]设置 行号 "),t("br"),n._v("\n          【::set paste | nopaste】 [不]设置 粘贴模式 "),t("br"),n._v("\n          【:noh】 不高亮 "),t("br"),t("br"),n._v("\n          可视化模式："),t("br"),n._v("\n          可视化模式下复制"),t("br"),n._v("\n          按键：ctrl + v（可视块）或V（可视行）或v（可视），然后按下↑ ↓ ←\n          →方向键来选中需要"),t("br"),n._v("\n          复制的区块，按下y 键进行复制（不要按下yy），最后按下p 键粘贴"),t("br"),n._v("\n          退出可视模式按下Esc"),t("br"),n._v("\n          1）.添加多行注释：（重点）"),t("br"),n._v("\n          步骤1：首先按esc进入命令行模式下，按下Ctrl +\n          v，进入列（也叫区块）模式;"),t("br"),n._v("\n          步骤2：在行首使用上下键选择需要注释的多行;"),t("br"),n._v("\n          步骤3：按下键盘（大写）“I”键，进入插入模式；"),t("br"),n._v("\n          步骤4：然后输入注释符（“#”）;"),t("br"),n._v("\n          步骤5：最后按 两下“Esc”键。"),t("br"),n._v("\n          2）.删除多行注释：（重点）"),t("br"),n._v("\n          步骤1：首先按esc进入命令行模式下，按下Ctrl + v, 进入列模式;"),t("br"),n._v("\n          步骤2：选定要取消注释的多行的第一列"),t("br"),n._v("\n          步骤3：按del键即可"),t("br")])]),t("tr",[t("td",{attrs:{rowspan:"3"}},[n._v("文件的复制、移动和删除")]),t("td",[n._v("cp")]),t("td",[n._v("拷贝")]),t("td",[n._v("\n          -R 递归 "),t("br"),n._v("\n          -r 复制文件夹\n        ")]),t("td",[n._v("\n          cp hello.txt /opt/test/hello.cp "),t("br"),n._v("\n          cp -r test1 test2\n        ")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("mv")]),t("td",[n._v("\n          移动"),t("br"),n._v("重命名"),t("br"),n._v("\n          文件文件夹都可以\n        ")]),t("td",[n._v("-f 连同子目录一起"),t("br"),n._v("-i"),t("br"),n._v("-t 目标目录")]),t("td",[n._v("\n          mv hello.txt /opt/test/ok.txt\n          "),t("br"),n._v("\n          mv -t d a b c\n        ")])]),t("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[t("td",[n._v("rm")]),t("td",[n._v("删除")]),t("td",[n._v("\n          -r 目录 ,递归删除"),t("br"),n._v("\n          -f 强制删除，不提示 "),t("br"),n._v("\n          -i "),t("br")]),t("td",[n._v("rm -rf /* 此命令慎用！")])]),t("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[t("td",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[n._v("链接文件")]),t("td",[n._v("ln")]),t("td",[n._v("连接")]),t("td",[n._v("-s 建立软链接"),t("br"),n._v("-d 建立硬链接（默认，可以不写）")]),t("td",[n._v("ln -s /root/myfile /s_myfile"),t("br"),n._v("ln -d hello.txt dhello")])]),t("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[t("td",{attrs:{height:"90",rowspan:"2"}},[n._v("挂载设备")]),t("td",[n._v("mount")]),t("td"),t("td",[n._v("-t")]),t("td",[n._v("\n          文件系统有vfat/iso9660，装优盘前先用fdisk -l查看"),t("br"),n._v("mount -t vfat\n          /dev/sdb1 /mnt/udisk"),t("br"),n._v("mount -a\n        ")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("umount")]),t("td"),t("td",[n._v("-f 强制将该文件系统退出")]),t("td",[n._v("umount -a"),t("br"),n._v("umount /home")])]),t("tr",{attrs:{height:"36"}},[t("td",{attrs:{height:"162",rowspan:"4"}},[n._v("修改文件权限")]),t("td",[n._v("chgrp")]),t("td",[n._v("切换组改变文件的所属组")]),t("td",[n._v("-R 递归")]),t("td",[n._v("\n          chgrp 组名 文件1 文件2 目录1 目录2 "),t("br"),n._v("\n          chgrp mary /opt/test "),t("br"),n._v("\n          chgrp -R mary /opt/test\n        ")])]),t("tr",[t("td",[n._v("chown")]),t("td",[n._v("改变文件的所有者")]),t("td",[n._v("-R 递归")]),t("td",[n._v("\n          chown 用户名 文件1 文件2 目录1 目录2"),t("br"),n._v("\n          chown -R mary /opt/test\n        ")])]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td",[n._v("chmod")]),t("td",{attrs:{colspan:"2"}},[n._v("\n          修改权限 "),t("br"),n._v("\n          -R 递归批量修改 "),t("br"),n._v("\n          拥有者-所属组-其他人"),t("br"),n._v("\n          chmod -u|g|o|a +|-|= rwc 文件1 文件2"),t("br"),n._v("\n          chmod u + x "),t("br"),n._v("\n          r=4 w=2 x=1 "),t("br"),n._v("\n          chmod u=rwx,og=rx .bashrc"),t("br"),n._v("\n          chmod a+w .bashrc"),t("br"),n._v("\n          chmod a-x .bashrc"),t("br"),n._v("\n          chmod -R 777 /home/test"),t("br"),n._v("\n          chmod 372 文件名1 文件名2"),t("br")]),t("td",[n._v("\n          特殊设置位，S位权限 "),t("br"),n._v("\n          作用：为了让一般使用者临时具有该文件所属主/组的执行权限。 "),t("br"),n._v("\n          主要针对二进制文件（命令） "),t("br"),n._v("\n          chmod 0755 文件名1 文件名2 "),t("br"),n._v("\n          去除S位权限 "),t("br"),n._v("\n          # chmod u-s /usr/bin/passwd "),t("br"),n._v("\n          或者 "),t("br"),n._v("\n          # chmod 0755 /usr/bin/passwd "),t("br"),n._v("\n          添加S位权限 # chmod u+s /usr/bin/passwd 或者 "),t("br"),n._v("\n          # chmod 4755 /usr/bin/passwd "),t("br"),t("br"),n._v("\n          沾滞位T（针对文件夹） "),t("br"),n._v("\n          主要功能：只允许文件的创建者和root用户删除文件（防止误删除权限位）==\n          "),t("br"),n._v("\n          移除粘滞位 "),t("br"),n._v("\n          # chmod -R o-t /tmp "),t("br"),n._v("\n          或 "),t("br"),n._v("\n          # chmod -R 0777 /tmp "),t("br"),n._v("\n          添加粘滞位 "),t("br"),n._v("\n          # chmod -R o+t /tmp "),t("br"),n._v("\n          或 "),t("br"),n._v("\n          # chmod -R 1777 /tmp "),t("br")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("chattr")]),t("td",[n._v("改变文件的特殊属性")]),t("td",[n._v("+i 属性不可更改"),t("br"),n._v("-i 属性可以更改")]),t("td",[n._v("chattr +i myfile 文件删不掉")])]),t("tr",[t("td",{attrs:{rowspan:"2"}},[n._v("ACL访问控制")]),t("td",[n._v("getfacl")]),t("td",[n._v("获取某个文件的ACL权限")]),t("td"),t("td",[n._v("getfacl 文件或目录名称")])]),t("tr",[t("td",[n._v("setfacl")]),t("td",[n._v("给某个文件设置ACL权限")]),t("td",[n._v("\n          # setfacl [选项] 文件或目录名称 "),t("br"),n._v("\n          选项说明： "),t("br"),t("br"),n._v("\n          -m ： 修改acl策略 "),t("br"),n._v("\n          -x ： 去掉某个用户或者某个组的权限 "),t("br"),n._v("\n          -b ： 删除所有的acl策略 "),t("br"),n._v("\n          -R ：递归,通常用在文件夹 "),t("br")]),t("td",[n._v("\n          案例：针对readme.txt文件给linuxuser设置一个权限=>可读 "),t("br"),n._v("\n          # setfacl -m u:linuxuser:r readme.txt => 针对某个用户开通ACL权限\n          "),t("br"),n._v("\n          案例：针对shop文件夹给itheima组设置一个权限=>可读可写权限rw "),t("br"),n._v("\n          # setfacl -R -m g:itheima:rw shop => 针对某个用户组开通ACL权限 "),t("br"),n._v("\n          案例：把linuxuser用户权限从readme.txt中移除掉 "),t("br"),n._v("\n          # setfacl -x u:linuxuser readme.txt "),t("br"),n._v("\n          案例：把itheima用户组权限从shop中移除掉 "),t("br"),n._v("\n          # setfacl -x -R g:itheima shop "),t("br"),n._v("\n          案例：把readme.txt文件中的所有ACL权限全部移除 "),t("br"),n._v("\n          # setfacl -b readme.txt\n        ")])]),t("tr",[t("td",[n._v("默认权限")]),t("td",[n._v("umask")]),t("td",[n._v("umask")]),t("td",{attrs:{colspan:"2"}},[n._v("\n          umask表示创建文件时的默认权限（即创建文件时不需要设置而天生的权限）\n          "),t("br"),n._v("\n          root用户下，touch a ，文件a的默认权限是644 "),t("br"),n._v("\n          普通用户下，touch b ，文件b的默认权限是664 "),t("br"),n._v("\n          注：0022中第一位0代表特殊权限位，可以不设置。"),t("br"),n._v("\n          umask的默认值，在root和普通用户下是不一样的，分别是022和002"),t("br"),n._v("\n          root : 666 - 022 = 644"),t("br")])]),t("tr",[t("td",{attrs:{height:"414",rowspan:"4"}},[n._v("搜索文件或目录")]),t("td",[n._v("which")]),t("td",[n._v("查看可执行文件的位置")]),t("td"),t("td",[n._v("which ls")])]),t("tr",[t("td",[n._v("whereis")]),t("td",[n._v("查看文件位置")]),t("td"),t("td",[n._v("whereis ls")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("locate")]),t("td",[n._v("配合数据库查看文件位置")]),t("td"),t("td",[n._v("locate ls"),t("br"),n._v("首次先要用updatedb初始化一下数据库")])]),t("tr",{staticStyle:{height:"256.50pt"},attrs:{height:"342"}},[t("td",[n._v("find")]),t("td",[n._v("搜索硬盘上的文件")]),t("td",[n._v("\n          -name"),t("br"),n._v("-type d f"),t("br"),n._v("-size"),t("br"),n._v("-newer"),t("br"),n._v("-user"),t("br"),n._v("-group"),t("br"),n._v("-amin"),t("br"),n._v("-atime"),t("br"),n._v("-cmin"),t("br"),n._v("-ctime"),t("br"),n._v("-perm\n        ")]),t("td",[n._v("\n          find / -name man"),t("br"),n._v("\n          find /home -amin -10 十分钟内访问过的文件"),t("br"),n._v("\n          find /home -atime -10 十天内访问过的文件"),t("br"),n._v("\n          find /home -cmin -10 十分中内修改过的文件"),t("br"),n._v("\n          find /home -ctime +10 十天内被改过、新增的文件"),t("br"),n._v("\n          find /home -size +1000c 大于1000bytes的文件"),t("br"),n._v('\n          find /var/log -name "*.log" -mtime +10 |rm -rf '),t("br"),n._v('\n          find /var/log -name "*.log" -mtime +10 |xargs rm -rf'),t("br"),n._v("\n          find . -perm 777 权限是777的所有文件"),t("br"),n._v('\n          find . -path "./test" -prune -o -name "*hello*"'),t("br"),n._v("\n          find . -user mary"),t("br"),n._v("\n          find . -group dev"),t("br"),n._v("\n          find . -newer hello.txt 比hello还要新的文件"),t("br"),n._v("\n          find . ! -newer hello.txt"),t("br"),n._v("\n          find . -type d 找目录"),t("br"),n._v("\n          find . -perm 764 -exec rm {} \\;"),t("br"),n._v("\n          find . -perm 764 -ok rm {} \\;"),t("br"),n._v("\n          find . -perm 764 | xargs rm -f "),t("br"),n._v("\n          find . -name '*a*' -prune 文件名包含a，目录名不包含a"),t("br"),n._v("\n          find . -size +1000c | xargs touch"),t("br"),n._v('\n          find /var -name "boot.log" -type f'),t("br"),n._v('\n          find / -name "ssh" -type d '),t("br"),n._v('\n          find /var/log -name "*.log" -type f'),t("br")])]),t("tr",[t("td",[n._v("命令扩展")]),t("td",[n._v("xargs")]),t("td",[n._v("\n          简单来说，xargs命令就相当于对管道命令进行了一个扩展，让所有命令都支持管道\n        ")]),t("td"),t("td",[n._v('\n          搜索/etc目录下的所有".conf"结尾的文件信息，然后以详细列表形式显示\n          '),t("br"),n._v('\n          find /etc -name "*.conf" | xargs ls -l '),t("br")])]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td",{staticStyle:{height:"81.00pt"},attrs:{rowspan:"3"}},[n._v("查找字符串")]),t("td",[n._v("grep")]),t("td",[n._v("reGulaR ExPression")]),t("td",[n._v("-i 忽略大小写"),t("br"),n._v("-n 显示行号"),t("br"),n._v("-v 取反"),t("br")]),t("td",[n._v("\n          grep 要搜索的关键词 多个文件的名称"),t("br"),n._v('\n          grep "^ma" /etc/passwd'),t("br"),n._v('\n          grep "bash$" /etc/passwd'),t("br"),n._v('\n          grep "^[r|d]" /etc/passwd'),t("br"),n._v('\n          cat redis.conf | grep -v "#" | grep -v "^$"'),t("br"),n._v("\n          grep -n word a.txt | wc -l "),t("br"),n._v("\n          ll -R | grep -n a | wc -l "),t("br")])]),t("tr",[t("td",[n._v("egrep")]),t("td"),t("td"),t("td")]),t("tr",[t("td",[n._v("fgrep")]),t("td"),t("td"),t("td")]),t("tr",{attrs:{height:"36"}},[t("td",{attrs:{height:"36"}},[n._v("显示")]),t("td",[n._v("echo")]),t("td",[n._v("显示、打印")]),t("td",[n._v("-e 使转义符生效")]),t("td",[n._v('\n          echo -e "hello\\tworld"'),t("br"),n._v('echo -e\n          "\\"\\""\n        ')])]),t("tr",[t("td",{staticStyle:{height:"54.00pt"},attrs:{height:"72",rowspan:"3"}},[n._v("用户切换")]),t("td",[n._v("su")]),t("td",[n._v("切换用户")]),t("td",[n._v("- 同时切换目录到用户的家")]),t("td")]),t("tr",[t("td",[n._v("sudo")]),t("td",[n._v("以其他用户的身份执行命令")]),t("td"),t("td",[n._v("只有/etc/sudoers内的用户才有权限执行。用visudo编辑")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("visudo")]),t("td",[n._v("用vi编辑/etc/sudoers文件")]),t("td"),t("td",[n._v("\n          在文件中的 root"),t("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("  ")]),n._v("ALL=(ALL)"),t("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("  ")]),n._v("ALL下面加一行："),t("br"),n._v("zhangsan"),t("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("  ")]),n._v("ALL=(ALL)"),t("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("  ")]),n._v("ALL\n        ")])]),t("tr",{attrs:{height:"36"}},[t("td",{staticStyle:{height:"283.50pt"},attrs:{height:"378",rowspan:"7"}},[n._v("进程管理")]),t("td",[n._v("ps")]),t("td",[n._v("查看进程（静态）")]),t("td",[n._v("-e 显示所有进程"),t("br"),n._v("-f 全格式")]),t("td",[n._v("ps -ef")])]),t("tr",[t("td",[n._v("pgrep")]),t("td"),t("td"),t("td",[n._v("类似于ps -ef | grep")])]),t("tr",{staticStyle:{height:"148.50pt"},attrs:{height:"198"}},[t("td",[n._v("top")]),t("td",[n._v("查看进程（动态）")]),t("td",[n._v("\n          -d 指定刷新频率（秒）"),t("br"),n._v("\n          -n 输出n次后退出"),t("br"),n._v("\n          u 显示指定用户进程"),t("br"),n._v("\n          k 杀掉进程"),t("br"),n._v("\n          M（大写）：表示将结果按照内存（MEM）从高到低进行降序排列；"),t("br"),n._v("\n\nP（大写）：，表示将结果按照CPU 使用率从高到低进行降序排列；"),t("br"),n._v("\n\n1 ：当服务器拥有多个cpu 的时候可以使用“1”快捷键来切换是否展示显示各个cpu 的详细信息；"),t("br"),n._v("\n  \nq：退出"),t("br")]),t("td",[n._v("\n           具体参看 07进程检测与控制.pdf  "),t("br"),n._v("\n          第一行的项目依次为当前时间、系统启动时间、当前系统登录用户数目、平均负载（小于0.6较妥,和系统CPU核数相关）。"),t("br"),n._v("\n          第二行为进程情况，依次为进程总数、休眠进程数、运行进程数、僵尸进程数、终止进程数。"),t("br"),n._v("\n          第三行为CPU状态，依次为用户占用、系统占用、优先进程占用、闲置进程占用。"),t("br"),n._v("\n          第四行为内存状态，依次为平均可用内存、已用内存、空闲内存、共享内存、缓存使用内存。"),t("br"),n._v("\n          第五行为交换状态，依次为平均可用交换容量、已用容量、闲置容量、高速缓存容量。"),t("br"),n._v("top\n          -d 1\n        ")])]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td",[n._v("kill")]),t("td",[n._v("杀掉进程")]),t("td",[n._v("-9 强行杀掉进程"),t("br"),n._v("-2 中断进程"),t("br"),n._v("-15 停止进程（默认）")]),t("td",[n._v("kill -9 %1")])]),t("tr",[t("td",[n._v("free")]),t("td",[n._v("查看内存使用情况")]),t("td"),t("td",[n._v("free")])]),t("tr",[t("td",[n._v("nice")]),t("td",[n._v("调整程序的执行优先级")]),t("td"),t("td",[n._v("nice -n -5 find / -name core > /tmp/core")])]),t("tr",[t("td",[n._v("renice")]),t("td",[n._v("调整程序的执行优先级")]),t("td"),t("td",[n._v("通常和ps配合使用")])]),t("tr",[t("td",[n._v("网络")]),t("td",[n._v("ss")]),t("td",[n._v("用于调查套接字的实用程序")]),t("td"),t("td",[n._v("\n          查看ssh 服务运行 的 网络 端口 "),t("br"),n._v("\n          ss -alt | grep ssh\n        ")])]),t("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[t("td",{attrs:{height:"162",rowspan:"5"}},[n._v("硬盘管理")]),t("td",[n._v("df")]),t("td",[n._v("查看磁盘使用情况"),t("br"),n._v("查看目录在哪个分区下")]),t("td",[n._v("-h 以易读方式显示"),t("br"),n._v("-l")]),t("td",[n._v("df"),t("br"),n._v("df /boot/"),t("br"),n._v("df -h")])]),t("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[t("td",[n._v("du")]),t("td",[n._v("查看文件(夹)已有容量")]),t("td",[n._v("\n          -k 以KB输出"),t("br"),n._v("-m 以MB输出"),t("br"),n._v("-s 只列出总量 "),t("br"),n._v("\n          -h ：高可读性\n        ")]),t("td",[n._v("du -m /home"),t("br"),n._v("du -s "),t("br"),n._v("du -sk hello.txt")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("fdisk")]),t("td",[n._v("分区"),t("br"),n._v("查看分区的具体情况")]),t("td",[n._v("-l")]),t("td")]),t("tr",[t("td",[n._v("lsblk")]),t("td",[n._v("列出磁盘的使用情况")]),t("td",[n._v(" -f 显示系统信息")]),t("td")]),t("tr",[t("td",[n._v("mke2fs")]),t("td"),t("td"),t("td")]),t("tr",{attrs:{height:"90"}},[t("td",{attrs:{height:"90"}},[n._v("打包")]),t("td",[n._v("tar")]),t("td",[n._v("打包"),t("br"),n._v("解包")]),t("td",[n._v("\n          -z，压缩为.gz格式"),t("br"),n._v("\n          ​ -j，压缩为.bz2格式"),t("br"),n._v("\n          ​ -J，压缩为.xz格式"),t("br"),n._v("\n          ​ -c，create 创建的意思"),t("br"),n._v("\n          ​ -x，解压缩"),t("br"),n._v("\n          ​ -v，显示打包文件过程"),t("br"),n._v("\n          ​ -f，file指定打包的文件名。"),t("br"),n._v("\n          ​ -u，追加更新原打包文件中的文件"),t("br"),n._v("\n          ​ -t，查看打包的文件内容"),t("br"),n._v("\n          ​ -C，指定解压目录"),t("br"),n._v("\n          ​\n        ")]),t("td",[n._v("\n          tar -c mydir > mydir.tar"),t("br"),n._v("tar -cvf test.tar /opt/test"),t("br"),n._v("\n          tar -xvf test.tar"),t("br"),n._v("\n          tar -zcvf hello.tar.gz hello.txt 使用gzip 压缩tar包"),t("br"),n._v("\n          tar -zxvf hello.tar.gz 解压文件"),t("br"),n._v("\n          tar -tf aa.gz 查看aa.gz 内的文件 "),t("br"),n._v("\n          tar -uf aa.gz a.js 追加 文件 "),t("br")])]),t("tr",{attrs:{height:"36"}},[t("td",{attrs:{height:"234",rowspan:"9"}},[n._v("压缩")]),t("td",[n._v("gzip")]),t("td",[n._v("压缩")]),t("td",[n._v("-d 解压缩")]),t("td",[n._v("gzip hello.tar"),t("br"),n._v("gzip -d hello.tar.gz")])]),t("tr",[t("td",[n._v("gunzip")]),t("td",[n._v("解压缩")]),t("td"),t("td",[n._v("gunzip hello.tar.gz")])]),t("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[t("td",[n._v("zip")]),t("td",[n._v("压缩")]),t("td",[n._v("-r 文件夹，递归")]),t("td",[n._v("\n          zip file.zip *"),t("br"),n._v("zip m file.zip to.txt"),t("br"),n._v("zip -r file.zip *\n        ")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("unzip")]),t("td",[n._v("解压")]),t("td",[n._v("-d 指定解压目录")]),t("td",[n._v("unzip hello.zip -d /usr/local/aa/zz"),t("br"),n._v("unzip -v hello.zip")])]),t("tr",[t("td",[n._v("zcat")]),t("td",[n._v("显示压缩文件的内容")]),t("td"),t("td")]),t("tr",[t("td",[n._v("zmore")]),t("td",[n._v("显示压缩文件的内容")]),t("td"),t("td")]),t("tr",[t("td",[n._v("zless")]),t("td",[n._v("显示压缩文件的内容")]),t("td"),t("td")]),t("tr",[t("td",[n._v("zgrep")]),t("td",[n._v("查找压缩文件的内容")]),t("td"),t("td")]),t("tr",[t("td",[n._v("zdiff")]),t("td",[n._v("比较压缩文件的不同")]),t("td"),t("td")]),t("tr",{attrs:{height:"36"}},[t("td",{staticStyle:{height:"229.50pt"},attrs:{height:"306",rowspan:"5"}},[n._v("安装")]),t("td",[n._v("gcc")]),t("td",[n._v("编译")]),t("td",[n._v("-o 指定目标文件")]),t("td",[n._v("gcc hello.c"),t("br"),n._v("gcc -o hello.o *.c")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("configure")]),t("td",[n._v("生成makefile文件")]),t("td",[n._v("--help"),t("br"),n._v("-h 帮助说明")]),t("td",[n._v("./configure --help")])]),t("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[t("td",[n._v("make")]),t("td",[n._v("编译")]),t("td"),t("td",[n._v("\n          make 编译生成目标文件、可执行文件"),t("br"),n._v("make install 安装程序"),t("br"),n._v("make\n          clean 去除目标文件\n        ")])]),t("tr",{staticStyle:{height:"81.00pt"}},[t("td",[n._v("rpm")]),t("td",[n._v("软件包管理器")]),t("td",[n._v("\n          -ivh 安装"),t("br"),n._v("\n          -Uvh 升级"),t("br"),n._v("\n          -e 卸载"),t("br"),n._v("\n          -a 所有 "),t("br"),n._v("\n          -e --nodeps强卸"),t("br"),n._v("\n          -q 查询"),t("br"),n._v("\n          -i：install，安装"),t("br"),n._v("\n          -v：显示进度条"),t("br"),n._v('\n          -h：表示以"#"形式显示进度条'),t("br"),n._v("\n          -V 验证\n        ")]),t("td",[t("a",{attrs:{href:"http://rpm.pbone.net",target:"_blank",rel:"noopener noreferrer"}},[n._v("http://rpm.pbone.net")]),t("br"),n._v("\n          rpm -qa 列出所有安装过的套件和版本"),t("br"),n._v("\n          rpm -qi 列出这个套件的详细信息"),t("br"),n._v("\n          rpm -ql 列出这个套件安装后的文件和路径"),t("br"),n._v("\n          rpm -qf 查询某文件属于那一个套件\n        ")])]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td",[n._v("yum")]),t("td"),t("td"),t("td",[n._v("\n          yum search raid"),t("br"),n._v("yum info mdadm"),t("br"),n._v("yum list aa*"),t("br"),n._v("yum -y\n          install pam-devel"),t("br")])]),t("tr",[t("td",[n._v("\n          系统控制 "),t("br"),n._v("\n          服务管理\n        ")]),t("td",[n._v("systemctl")]),t("td",{attrs:{colspan:"2"}},[n._v("\n          systemctl list-units --type service --all"),t("br"),n._v("\n          systemctl list-units --type service | grep sshd"),t("br")]),t("td",[n._v("\n          systemctl status network "),t("br"),n._v("\n          systemctl start network "),t("br"),n._v("\n          systemctl stop network "),t("br"),n._v("\n          systemctl restart network "),t("br"),n._v("\n          systemctl reload crond "),t("br"),n._v("\n          systemctl enable crond "),t("br"),n._v("\n          systemctl disable crond "),t("br")])]),t("tr",[t("td",{staticStyle:{height:"135.00pt"},attrs:{height:"180",rowspan:"2"}},[n._v("系统服务")]),t("td",[n._v("chkconfig")]),t("td",[n._v("开机自动启停服务")]),t("td",[n._v("--list 列出所有服务"),t("br"),n._v("--add 添加服务"),t("br"),n._v("--del 删除服务")]),t("td",[n._v("\n          chkconfig vsftpd on"),t("br"),n._v("chkconfig sshd on"),t("br"),n._v("chkconfig iptables\n          off"),t("br"),n._v("chkconfig --add httpd"),t("br"),n._v("chkconfig --del httpd"),t("br"),n._v("chkconfig\n          --level 35 httpd on\n        ")])]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td",[n._v("service")]),t("td",[n._v("立即启停服务")]),t("td",[n._v("start 启动"),t("br"),n._v("stop 停止"),t("br"),n._v("restart 重启"),t("br"),n._v("status 查看")]),t("td",[n._v("\n          service network restart"),t("br"),n._v("service iptables stop"),t("br"),n._v("service vsftpd\n          start"),t("br"),n._v("service iptables status\n        ")])]),t("tr",[t("td",{attrs:{rowspan:"3"}},[n._v("常用自有服务")]),t("td",[n._v("ntp")]),t("td",[n._v("用于同步计算机的系统时间的服务")]),t("td",[n._v("\n          ntpd服务配置文件位置 /etc/ntp.conf "),t("br"),n._v("\n          NTP授时网站： "),t("br"),n._v("\n          http://www.ntp.org.cn/pool.php "),t("br")]),t("td",[n._v("\n          ntpdate NTP服务器的IP地址或域名 "),t("br"),n._v("\n          自动同步 启动ntpd服务 "),t("br"),n._v("\n          #systemctl start ntpd "),t("br"),n._v("\n          #systemctl enable ntpd "),t("br")])]),t("tr",[t("td",[n._v("firewalld")]),t("td",[n._v("防火墙服务")]),t("td",[n._v("\n          区域概念 "),t("br"),n._v("\n          block dmz drop external home internal public trusted work\n        ")]),t("td",[n._v("\n          firewall-cmd 选项"),t("br"),n._v("\n          #firewall-cmd --get-zones"),t("br"),n._v("\n          含义：查看所有可用区域"),t("br"),n._v("\n          #firewall-cmd --get-default-zone"),t("br"),n._v("\n          含义：查看默认使用区域，当前默认使用区域为public"),t("br"),n._v("\n          #firewall-cmd --list-all"),t("br"),n._v("\n          含义：查看所有可用区域"),t("br"),n._v("\n          #firewall-cmd --list-all-zones"),t("br"),n._v("\n          含义：查看所有可用区域"),t("br"),n._v("\n          #firewall-cmd --zone=public --add-port=1024/tcp"),t("br"),n._v("\n          含义:在public区域，添加允许tcp协议的1024端口通过的规则"),t("br"),n._v("\n          #firewall-cmd --zone=public --add-service=ftp"),t("br"),n._v("\n          含义:在public区域，添加允许ftp服务通过的规则"),t("br"),n._v("\n          #firewall-cmd --zone=public --remove-port=1024/tcp"),t("br"),n._v("\n          含义:在public区域，去掉允许tcp协议的1024端口通过的规则"),t("br"),n._v("\n          #firewall-cmd --zone=public --remove-service=ftp"),t("br"),n._v("\n          含义:在public区域，去掉允许ftp服务通过的规则"),t("br"),n._v("\n          #firewall-cmd --permanent --zone=public --add-port=1024/tcp"),t("br"),n._v("\n          含义:在public区域，使用permanent参数，永久添加允许1024端口通过的规则"),t("br"),n._v("\n          #firewall-cmd --reload"),t("br"),n._v("\n          含义:重新加载配置"),t("br")])]),t("tr",[t("td",[n._v("crond")]),t("td",[n._v("计划任务服务")]),t("td"),t("td")]),t("tr",{attrs:{height:"36"}},[t("td",{staticStyle:{height:"202.50pt"},attrs:{height:"270",rowspan:"9"}},[n._v("任务计划")]),t("td",[n._v("tab键")]),t("td",[n._v("命令自动补全")]),t("td"),t("td",[n._v("按一下会自动展开；"),t("br"),n._v("按两下会列出所有命令")])]),t("tr",[t("td",[n._v("nohup")]),t("td",[n._v("不挂断的运行")]),t("td"),t("td")]),t("tr",[t("td",[n._v("&")]),t("td",[n._v("后台运行")]),t("td"),t("td",[n._v("command &")])]),t("tr",[t("td",[n._v("Ctrl+Z")]),t("td",[n._v("后台运行")]),t("td"),t("td")]),t("tr",[t("td",[n._v("jobs")]),t("td",[n._v("列出作业")]),t("td"),t("td")]),t("tr",[t("td",[n._v("fg")]),t("td",[n._v("前台")]),t("td",[n._v("%number 表示jobs的"),t("span",{},[n._v("工作代号")])]),t("td",[n._v("fg %2 后台程序切到前台")])]),t("tr",[t("td",[n._v("bg")]),t("td",[n._v("后台")]),t("td",[n._v("%number 表示jobs的"),t("span",{},[n._v("工作代号")])]),t("td",[n._v("bg %1 将Stopped状态的后台程序改为Running状态")])]),t("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[t("td",[n._v("at")]),t("td",[n._v("一次性运行的任务计划")]),t("td",[n._v("\n          systemctl start atd  "),t("br"),n._v("\n          -f 要提交的脚本"),t("br"),n._v("\n        -r 清除"),t("br"),n._v("\n        -l 罗列"),t("br"),n._v("\n         atq 查看没有执行的计划任务"),t("br"),n._v("\n         atrm 任务号 删除指定的计划任务"),t("br")]),t("td",[n._v("\n          at 3:00pm tomorrow -f /home/wuxh/hello.sh"),t("br"),n._v("\n          at now + 5 minutes\n        ")])]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td",[n._v("crontab")]),t("td",[n._v("循环运行的任务计划")]),t("td",[n._v("\n          -l：list，列出指定用户的计划任务列表 "),t("br"),n._v("\n          -e：edit，编辑指定用户的计划任务列表 "),t("br"),n._v("\n          -u：user，指定的用户名，如果不指定，则表示当前用户 "),t("br"),n._v("\n          -r：remove，删除指定用户的计划任务列表 "),t("br"),n._v("\n          黑名单==配置文件位于：`/etc/cron.deny "),t("br"),n._v("\n          白名单==配置文件位于：/etc/cron.allow  "),t("br"),n._v("\n          日志文件位于`/var/log/cron` "),t("br")]),t("td",[n._v("\n          格式： "),t("br"),n._v("\n          四个符号："),t("br"),n._v("\n          *：表示取值范围中的每一个数字"),t("br"),n._v("\n          -：做连续区间表达式的，要想表示1~7，则可以写成：1-7"),t("br"),n._v("\n          /：表示每多少个，例如：想每 10 分钟一次，则可以在分的位置写：*/10"),t("br"),n._v("\n          ,：表示多个取值，比如想在 1 点，2 点 6\n          点执行，则可以在时的位置写：1,2,6"),t("br"),n._v("\n          分 时 日 月 周 需要执行的命令"),t("br"),n._v("\n          问题1：每月1、10、22 日的4:45 重启network 服务"),t("br"),n._v("\n          问题1：45 4 1,10,22 * * service network restart"),t("br"),n._v("\n          问题2：每周六、周日的1:10 重启network 服务"),t("br"),n._v("\n          问题2：10 1 * * 6,7 service network restart"),t("br"),n._v("\n          问题3：每天18:00 至23:00 之间每隔30 分钟重启network 服务"),t("br"),n._v("\n          问题3：*/30 18-23 * * * service network restart"),t("br"),n._v("\n          问题4：每隔两天的上午8 点到11 点的第3 和第15 分钟执行一次重启"),t("br"),n._v("\n          问题4：3,15 8-11 */2 * * reboot"),t("br")])]),t("tr",{attrs:{height:"36"}},[t("td",{staticStyle:{height:"1458.75pt"},attrs:{height:"1945",rowspan:"45"}},[n._v("\n          Bash\n        ")]),t("td",[n._v("bash")]),t("td",[n._v("执行脚本")]),t("td"),t("td",[n._v("bash helloworld.sh"),t("br"),n._v("./w.sh")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("重定向符 >")]),t("td",[n._v("标准输出")]),t("td"),t("td",[n._v("\n          command > out.file 2>&1 &"),t("br"),n._v("command 2> err.txt\n          >&2\n        ")])]),t("tr",[t("td",[n._v("重定向符 >>")]),t("td",[n._v("追加")]),t("td"),t("td",[n._v("cal >> c.txt")])]),t("tr",[t("td",[n._v("重定向符 2>")]),t("td",[n._v("标准错误")]),t("td"),t("td",[n._v("ls ddd 2> /dev/null")])]),t("tr",[t("td",[n._v("重定向符 <")]),t("td"),t("td"),t("td",[n._v("sort < name.txt > name.out")])]),t("tr",[t("td",[n._v("重定向符 <<")]),t("td"),t("td"),t("td")]),t("tr",{attrs:{height:"90"}},[t("td",[n._v("正则表达式")]),t("td",{attrs:{colspan:"2"}},[n._v("\n          . 匹配任意字符"),t("br"),n._v("^ 匹配行首"),t("br"),n._v("$ 匹配文件尾"),t("br"),n._v("[]\n          匹配字符组之一"),t("br"),n._v("* 匹配0到n个字符"),t("br"),n._v("\\{min,max\\}"),t("br"),n._v("\\(…\\)\n        ")]),t("td",[n._v("\n          XXX* 匹配至少两个连续的X"),t("br"),n._v("X\\{1,10\\} 匹配1到10个连续的X"),t("br"),n._v("^\\(.\\)\n          匹配行首的第一个字符（不管是什么）"),t("br"),n._v("^\\(.\\).*\\1$\n          匹配一行中的头一个字符和最后一个字符相同的行\n        ")])]),t("tr",[t("td",[n._v("管道符 |")]),t("td"),t("td"),t("td")]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("双引号")]),t("td",[n._v("引用字符串,但对$,`,\\敏感")]),t("td",[n._v('""')]),t("td",[n._v('echo "$$"'),t("br"),n._v('echo "\\$$"')])]),t("tr",[t("td",[n._v("单引号")]),t("td",[n._v("引用字符串，对特殊字符不敏感")]),t("td",[n._v("''")]),t("td",[n._v("echo '$$'")])]),t("tr",[t("td",[n._v("反引号")]),t("td",[n._v("将反引号内的字符串作为命令")]),t("td",[n._v("``")]),t("td",[n._v("echo `date`")])]),t("tr",{attrs:{height:"90"}},[t("td",[n._v("命令集")]),t("td",[n._v("一行中执行多个命令")]),t("td",[n._v("\n          ; 顺序执行"),t("br"),n._v("&& 前面成功后续才执行"),t("br"),n._v("||\n          前面失败后续才执行\n        ")]),t("td",[n._v("ls;ls"),t("br"),n._v("ls&&ls"),t("br"),n._v("ls||ls")])]),t("tr",{staticStyle:{height:"135.00pt"},attrs:{height:"180"}},[t("td",[n._v("变量")]),t("td",{attrs:{colspan:"2"}},[n._v("\n          位置变量"),t("br"),n._v("$$ 脚本当前进程ID"),t("br"),n._v("$! 后台运行的最后一个进程的ID"),t("br"),n._v("$?\n          命令的退出状态（0表示成功，1表示失败）"),t("br"),n._v("$# 传递到脚本的参数个数"),t("br"),n._v("$*\n          以一个单字符串的形式显示所有向脚本传递的参数"),t("br"),n._v("$@\n          与$*相同，但是使用时加引号，并在引号中返回每个参数"),t("br"),n._v("$_ 就是set命令\n        ")]),t("td",[n._v("\n          观察$*和$@的不同："),t("br"),n._v('for i in "$*"'),t("br"),n._v("do"),t("br"),t("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("  ")]),n._v("echo $i"),t("br"),n._v("done"),t("br"),t("br"),n._v('for i in "$@"'),t("br"),n._v("do"),t("br"),t("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("  ")]),n._v("echo $i"),t("br"),n._v("done\n        ")])]),t("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[t("td",[n._v("wc")]),t("td",[n._v("统计字数")]),t("td",[n._v("\n          -l：表示lines，行数"),t("br"),n._v("\n          -w：表示words，单词数 量"),t("br"),n._v("\n          -c：表示bytes，字节数 "),t("br")]),t("td",[n._v("\n          cat /etc/passwd | wc -l "),t("br"),n._v("\n          wc -lwc ./* "),t("br"),n._v("\n          wc -l a.txt\n        ")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("sleep")]),t("td",[n._v("等待")]),t("td"),t("td",[n._v("sleep 5 暂停5秒"),t("br"),n._v("usleep 500 这个单位是纳秒")])]),t("tr",[t("td",[n._v("read")]),t("td",[n._v("从键盘读入信息到变量中")]),t("td"),t("td",[n._v("read name")])]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td"),t("td",[n._v("变量赋值")]),t("td"),t("td",[n._v('\n          PATH="$PATH":/root'),t("br"),n._v("LANG=C"),t("br"),n._v("LANG=zh_CN.gb2312"),t("br"),n._v("PS1='[\\u@\\h\n          \\W]\\$ '\n        ")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("set")]),t("td",[n._v("显示当前shell的变量，包括当前用户的变量（即环境变量）")]),t("td"),t("td",[n._v("set")])]),t("tr",[t("td",[n._v("unset")]),t("td",[n._v("删除变量")]),t("td"),t("td",[n._v("unset i")])]),t("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[t("td",[n._v("export")]),t("td",[n._v("\n          把变量即刻导入到当前的用户环境中（被export的变量叫环境变量），这时可以在env中看到\n        ")]),t("td",[n._v("环境变量相当可以被子进程使用，其他变量不行。")]),t("td",[n._v("export LANG=C"),t("br"),n._v("export LC_ALL=en")])]),t("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[t("td",[n._v("env")]),t("td",[n._v("显示当前用户环境的变量（被export的变量可以用env查看到）")]),t("td"),t("td",[n._v("env")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("alias")]),t("td",[n._v("命令别名")]),t("td"),t("td",[n._v("alias ll"),t("br"),n._v("alias l=ls -la")])]),t("tr",[t("td",[n._v("unalias")]),t("td",[n._v("取消命令别名")]),t("td"),t("td",[n._v("unlias l")])]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td",[n._v("sort")]),t("td",[n._v("对文件内容做排序")]),t("td",[n._v("-n 以数字排序"),t("br"),n._v("-r 反向排序"),t("br"),n._v("-u 同样的只出现一次")]),t("td",[n._v("sort -n name.txt")])]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td",[n._v("cut")]),t("td",[n._v("提取字符串")]),t("td",[n._v("-c 字符"),t("br"),n._v("-d 分隔符"),t("br"),n._v("-f 字段")]),t("td",[n._v('\n          cat /etc/passwd | cut -d ":" -f1'),t("br"),n._v('last | cut -d "\n          " -f1 列出第一个区块'),t("br"),n._v("who | cut -c1-8,18-\n          每行的1-8个字符和第18行到行尾"),t("br"),n._v("cut -d: -f1,6 /etc/passwd\n        ")])]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td",[n._v("paste")]),t("td",[n._v("和cut相反的命令，合并行")]),t("td",[n._v("-d 指定合并的分隔符"),t("br"),n._v("-s 把文件内的所有行合并为一行")]),t("td",[n._v("\n          paste names numbers 把两个文件的每行都分别合起来"),t("br"),n._v("paste -d'+'\n          names addresses numbers"),t("br"),n._v("paste -s names"),t("br"),n._v("ls | paste -d' ' -s\n        ")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("join")]),t("td",[n._v("把两个文件中相同的行连起来")]),t("td"),t("td",[n._v("\n          join -t ':' /etc/passwd /etc/shadow"),t("br"),n._v("join -t ':' -1 4 /etc/passwd\n          -2 3 /etc/group\n        ")])]),t("tr",{staticStyle:{height:"148.50pt"},attrs:{height:"198"}},[t("td",[n._v("sed")]),t("td",[n._v("Stream Editor流编辑器")]),t("td",[n._v("-n")]),t("td",[n._v("\n          sed 's/Unix/UNIX/' myFile\n          把Unix换成UNIX（没改原文件），但只改动每行的第一个改掉"),t("br"),n._v("sed\n          's/Unix/UNIX/g' myfile > temp.txt 把每行的所有Unix都换成UNIX"),t("br"),n._v("sed\n          '1,2d' myfile 删除第1、2行"),t("br"),n._v("sed '/[Tt]est/d'\n          删除含test或Test的行"),t("br"),n._v("sed '/jan/s/fds/abc/'\n          将所有包含了jan的行中第1个fds改为abc"),t("br"),n._v("sed -n '20,25p' text\n          只显示第20到25行"),t("br"),n._v("sed 's/…//' data 删除文件中每行的前3个字符"),t("br"),n._v("sed\n          's/…$//' data 删除文件中每行的最后3个字符\n        ")])]),t("tr",[t("td",[n._v("awk")]),t("td"),t("td"),t("td",[t("span",{staticStyle:{"mso-spacerun":"yes"}}),n._v("通过正则匹配，切割，提取需要的值"),t("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("  ")])])]),t("tr",[t("td",[n._v("diff")]),t("td",[n._v("比较两个文件的不同")]),t("td"),t("td",[n._v("diff file1 file2")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("uniq")]),t("td",[n._v("删除重复行从而只显示一个")]),t("td"),t("td",[n._v('\n          last | cut -d " " -f1 | sort | uniq'),t("br"),n._v("查看这个月登录主机的用户都有谁\n        ")])]),t("tr",[t("td",[n._v("source")]),t("td",[n._v("执行脚本")]),t("td"),t("td",[n._v("source helloworld.sh")])]),t("tr",[t("td",[n._v("tee")]),t("td",[n._v("输出到文件的同时显示在屏幕上")]),t("td",[n._v("-a 追加到末尾")]),t("td")]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("tr")]),t("td",[n._v("替换指定内容")]),t("td",[n._v("-d 删除指定串"),t("br"),n._v("-s 替换重复字符")]),t("td",[n._v("\n          cat dostxt | tr -d '\\r' > dostxt-noM "),t("br"),n._v("去掉文件中的DOS下的 ^M\n          断行符\n        ")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("split")]),t("td",[n._v("分割文件")]),t("td",[n._v("-b 以文件size分"),t("br"),n._v("-l 以行数分")]),t("td",[n._v("split -l 5 /etc/passwd test")])]),t("tr",[t("td",{attrs:{rowspan:"3"}},[n._v("test")]),t("td",[n._v("测试文件")]),t("td"),t("td")]),t("tr",[t("td",[n._v("测试字符串")]),t("td"),t("td")]),t("tr",[t("td",[n._v("测试数值")]),t("td"),t("td")]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("expr")]),t("td"),t("td"),t("td",[n._v("\n          expr 10 + 10 只算整数，真正的计算要用bc（计算器）"),t("br"),n._v("expr 3 \\* 7\n          乘号要转义\n        ")])]),t("tr",{staticStyle:{height:"108.00pt"},attrs:{height:"144"}},[t("td",[n._v("函数")]),t("td"),t("td"),t("td",[n._v("\n          下例可以看出$*和$@的区别："),t("br"),n._v("function testargs"),t("br"),n._v("{"),t("br"),t("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("        ")]),n._v('echo "There is $# args"'),t("br"),t("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("        ")]),n._v("echo $10"),t("br"),n._v("}"),t("br"),n._v('testargs "$*"'),t("br"),n._v('testargs\n          "$@"\n        ')])]),t("tr",[t("td",{attrs:{rowspan:"2"}},[n._v("条件判断")]),t("td",[n._v("if")]),t("td"),t("td")]),t("tr",[t("td",[n._v("case")]),t("td"),t("td")]),t("tr",[t("td",{attrs:{rowspan:"3"}},[n._v("循环")]),t("td",[n._v("while … do … done")]),t("td"),t("td")]),t("tr",[t("td",[n._v("until … do … done")]),t("td"),t("td")]),t("tr",{staticStyle:{height:"14.25pt"},attrs:{height:"19"}},[t("td",[n._v("for … do … done")]),t("td"),t("td")])])])}],l={data:function(){return{}}},o=l,d=(t("388d"),t("2877")),u=Object(d["a"])(o,a,s,!1,null,"6dc905ba",null),p=u.exports,v=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)])},c=[],m="\x3c!--\r\n * @Date           : 2021-07-10 01:26:52\r\n * @FilePath       : /jinnian-space/src/pages/linux/md/linux-其他.md\r\n * @Description    : \r\n--\x3e\r\n\r\n \r\n\r\n## **CentOS7防火墙firewalld，常见区域及相应策略规则**\r\n\r\n| 区域     | 默认策略                                                     |\r\n| -------- | ------------------------------------------------------------ |\r\n| trusted  | 允许所有数据包                                               |\r\n| home     | 拒绝流入的流量，除非与流出的流量相关，允许ssh,mdns,ippclient,amba-client,dhcpv6-client服务通过 |\r\n| internal | 等同于home                                                   |\r\n| work     | 拒绝流入的流量，除非与流出的流量相关，允许ssh,ipp-client,dhcpv6-client服务通过 |\r\n| public   | 拒绝流入的流量，除非与流出的流量相关，允许ssh,dhcpv6-client服务通过 |\r\n| external | 拒绝流入的流量，除非与流出的流量相关，允许ssh服务通过        |\r\n| dmz      | 拒绝流入的流量，除非与流出的流量相关，允许ssh服务通过        |\r\n| block    | 拒绝流入的流量，除非与流出的流量相关，非法流量采取拒绝操作   |\r\n| drop     | 拒绝流入的流量，除非与流出的流量相关，非法流量采取丢弃操作   |\r\n",h={data:function(){return{MainComponent:m}}},_=h,g=Object(d["a"])(_,v,c,!1,null,"1373d8e8",null),x=g.exports,b=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("div",[n._v("SHELL")]),t("pre",[n._v('     shell 中 变量赋值 单引号是 字符 双引号是可以解析变量的  $() 是代表可执行命令 或者 模板插值符号反引号也一样\n     shell 中 0 为 真  1 为假 \n     readonly  只读变量\n     unset 删除变量\n     数组： \n        定义：arr=(1 2  3  4  8) \n        赋值: arr[0]=99\n        获取：${arr[1]}\n        获取长度：${#arr[*]}   ${#arr[@]}\n    num1= `expr 2 + 2`  数学运算表达式  expr\n     自增：  e=1  ;  ((e++))  \n     字符串比较 返回布尔值  0 为真 1 为假的: 前后带空格  中间带空格\n        [ $a = $b ]  [ $a != $b ]  是否为0  [ -z $a ]   是否非0  [ -n "$a" ]  是否为空 [ $a ] \n        [ "${a}" = "${b}" ]  [ $a != $b ]  是否为0  [ -z "${a}" ]   是否非0  [ -n "${a}" ]  是否为空 [ $"{$a}" ] \n     $? 获取 上一条 语句的 执行结果   \n     字符串长度  ${#a}\n     关系运算符 只支持数字 ，不支持字符串，除非字符串的值是数字：\n      \n      [ $a -eq $b]   等于 -eq  不等于  -ne  大于 -gt 小于 -lt 大于等于 -ge  小于等于 -le  \n    shell 布尔运算：\n        ! 求反 [ !false]     [ !  $a -lt 20 ]        返回 true    \n        -o or   或运算  [ $a -lt 20 -o $b -gt 100]\n        -a and  与运算  [ $a -lt 20 -a $b -gt 100]\n        &&  逻辑and    [[ true && true ]]   [[ "${a}" -lt 100 && "${b}" -gt 100 ]]\n        ||  逻辑或者    [[ true || true ]]\n    if[条件];then;语句体；fi       ,,,,  if[] then fi  ,,,,if[] then  elif[] else fi \n\n    if [ $(ps -ef | grep -c "ssh") -gt 1] \n\n\n  ')]),t("q-separator"),t("q-markdown",{attrs:{src:n.MainComponent}})],1)},f=[],L='\x3c!--\r\n * @Date           : 2021-01-29 00:52:36\r\n * @FilePath       : /jinnian-space/src/pages/linux/md/shell.md\r\n * @Description    : \r\n--\x3e\r\n## shell\r\n​\t***\\*S\\*******\\*hell程序设计\\****\t\r\n\r\n一、 什么是shell?\r\n\r\n​\tShell是一个作为用户与Linux系统间接口的程序，它允许用户向操作系统输入需要执行的命令。在一个linux系统中可以安装多个shell，这些shell和其他程序一起环绕在linux内核四周。默认安装的标准是/bin/sh，它是GNU工具集中的bash。使用/bin/bash –version可以查看版本。\r\n\r\nShell 历史版本：sh  csh,、tcsh、 zsh  ksh、pdksh  bash\r\n\r\n二、 shell脚本编写、运行、调试\r\n\r\n\\1. 脚本均以 #!/bin/bash开头。\r\n\r\n\\2. 脚本中的 ‘#’为注释符。\r\n\r\n\\3. 使用exit为脚本设置返回一个退出码，注意 0 表示的是执行成功。\r\n\r\n示例：\r\n\r\n \\#!/bin/bash\r\n\r\n \\# this is my first shell! \r\n\r\n echo  “helloword!”\r\n\r\n exit 0\r\n\r\n \r\n\r\n\\4. 设置脚本为可执行： chmod u+x filename.sh\r\n\r\n\\5. 执行：./filename.sh\r\n\r\n\\6. sh –x ./filename.sh\r\n\r\n三、 shell语法\r\n\r\n**1、** ***\\*变量\\****：无需事先声明，直接使用，在访问时要加$在变量前。\r\n\r\n例如：\r\n\r\nStr=hello\r\n\r\necho  $Str \r\n\r\na.这两行语句将在屏幕输出一个“hello”，shell区别大小写，定义变量时应该注意。\r\n\r\nb.如果为变量所赋的字符串中含有空格，table或换行符应使用“”标示，例如 “hello  word!”\r\n\r\nc.变量在引号中依然有效如echo “this  is  $Str！”依然会输出：this  is  hello！\r\n\r\n练习示例：(注:后续的示例中只有关键部分，练习时补全)\r\n\r\necho “input  password:”\r\n\r\nread pasd\r\n\r\necho “the password is $pasd”\r\n\r\nd.如果需要输出字符$Str可以用单引号 和 \\来处理：\r\n\r\n ‘$Str’ 和\\$Str 输出的都是 $Str不是变量表示的值，shell中的变量一般都是字符串形式。\r\n\r\ne: 环境变量，介绍几种：\r\n\r\n$HOME  当前用户的家目录 \r\n\r\n$PATH   搜索命令的目录列表\r\n\r\n$0\t\t\tshell脚本的名字\r\n\r\n$#\t\t\t传递给脚本的参数个数\r\n\r\n$$\t\t\t脚本的进程号\r\n\r\nf:参数变量：\r\n\r\n$1,$2脚本的程序参数\r\n\r\n$*   列出所有参数\r\n\r\n$@   S*的一种变体，它参数不会挤在一块。\r\n\r\ng:变量做整形数字使用：\r\n\r\na=123\r\n\r\nlet “a +=1”\r\n\r\necho “a = $a”\r\n\r\n**2、** ***\\*条件\\****\r\n\r\n1) 使用 test 或 [ ]\r\n\r\n如  if test –f file.c\r\n\r\nthen\r\n\r\n…..\r\n\r\nfi\r\n\r\n​    以上代码也可写成如下形式(尽量使用这种形式)\r\n\r\n​     if [ -f file.c ]  (注意:if语句和[之间有个空格]\r\n\r\n​    then\r\n\r\n​     ….\r\n\r\n​     fi\r\n\r\n完整示例：\r\n\r\n\\#!/bin/bash\r\n\r\necho  “is  it  morning? Please  answer  yes  or  no”\r\n\r\nread  timeofday\r\n\r\nif [ $timeofday = “yes” ] ;then\r\n\r\n  echo  “good morning”\r\n\r\nelse\r\n\r\n  echo  “good afternoon”\r\n\r\nfi\r\n\r\nexit 0\r\n\r\n2) elif语句，在if，else语句中增加分支判断。如下示例：\r\n\r\n  \\#!/bin/bash\r\n\r\necho  “is  it  morning? Please  answer  yes  or  no”\r\n\r\nread  timeofday\r\n\r\nif [ $timeofday = “yes” ] ;then\r\n\r\n   echo  “good morning”\r\n\r\nelif [ $timeofday = “no” ]\r\n\r\nthen\r\n\r\n  echo “Good afternoon”\r\n\r\nelse\r\n\r\n  echo “sorry ,$timeofday not recognized. Enter yes or no”\r\n\r\n  exit 1\r\n\r\nfi\r\n\r\nexit 0\r\n\r\n**3、** ***\\*一个与变量有关的问题。\\****\r\n\r\n如上程序，如果没有输入Yes和no直接按回车键，会出现什么结果呢？程序会有出错信息。原因是。。。避免该问题产生的方法对变量使用双引号“$Str”\r\n\r\n**4、** ***\\*for语句\\****\r\n\r\n使用for语句可以循环处理一组值，这组值可以是任意字符串的集合。 它的语法形式如下：\r\n\r\n***\\*for\\**** variable  ***\\*in\\**** values\r\n\r\n***\\*do\\****\r\n\r\n  something\r\n\r\n***\\*done\\****\r\n\r\n 示例：\r\n\r\n  \\#!/bin/bash\r\n\r\n  For foo in hello myname 129\r\n\r\n  do\r\n\r\n   echo $foo\r\n\r\n  done\r\n\r\n  exit 0\r\n\r\n使用通配符扩展for循环\r\n\r\n\\#!/bin/sh\r\n\r\nfor file in $(ls  *.sh);do\r\n\r\n echo $file\r\n\r\ndone\r\n\r\nexit 0\r\n\r\n***\\*5、while语句\\****\r\n\r\n语法结构：\r\n\r\n***\\*while\\**** condition ***\\*do\\****\r\n\r\nDosometing\r\n\r\n***\\*done\\****\r\n\r\n示例：一个简陋的密码检查程序\r\n\r\n\\#!/bin/bash\r\n\r\necho  “Enter password”\r\n\r\nread  paword\r\n\r\nwhile  [ “$paword” != “secret” ] \r\n\r\ndo\r\n\r\n  echo “sorry, try again ”\r\n\r\n  read paword \r\n\r\ndone\r\n\r\nexit 0\r\n\r\n字符串比较:\r\n\r\nstring = string  \r\n\r\nstring != string\r\n\r\n-n string\r\n\r\n-z string \r\n\r\n 算数比较\r\n\r\n num1 –eq  num2 \r\n\r\n num1 –ne  num2\r\n\r\n \r\n\r\n***\\*6、until语句,与while循环类似，只是把测试条件反过来了。\\****\r\n\r\n语法形式如下：\r\n\r\n***\\*until\\**** condition\r\n\r\n***\\*do\\****\r\n\r\n  Dosomething\r\n\r\n***\\*done\\****\r\n\r\n***\\*7、case语句\\****\r\n\r\n***\\*语法结构:\\****\r\n\r\n***\\*case\\****  variable ***\\*in\\****\r\n\r\npattern1 [ ***\\*|\\**** pattern] …***\\*)\\****  dosomething ***\\*;;\\****\r\n\r\npattern2 [ ***\\*|\\**** pattern] …***\\*)\\****  dosomething ***\\*;;\\****\r\n\r\n***\\*esac\\****\r\n\r\n该语句 执行 vairable与第一个pattern匹配上的语句。\r\n\r\n例如：\r\n\r\n\\#!/bin/bash\r\n\r\necho “is it morning? Please answer yes or no”\r\n\r\nread  timeofday\r\n\r\ncase “$timeofday” in\r\n\r\n   yes ) echo “good moring”;;\r\n\r\n   no ) echo “good afternoon”;;\r\n\r\ny) echo “good morning”;;\r\n\r\nn) echo “good afternoon”;;\r\n\r\n*)echo “sorry,answer not recognized” ;;\r\n\r\n esac\r\n\r\n exit 0\r\n\r\n 匹配部分语句也可改写为：\r\n\r\n case  “$timeofday” in\r\n\r\n​    yes | y | Yes | YES ) echo “good morning”;;\r\n\r\n​    n* | N* )     echo “good afternoon”;;\r\n\r\n​    *)        echo “sorry, answer not recognized”;;\r\n\r\n esac\r\n\r\n也可以将匹配行改为; [yY]|[Yy][Ee][Ss]\r\n\r\n***\\*8、命令列表\\****\r\n\r\n 有时需要将好几条命令连接成一个序列。如下\r\n\r\n if [ -f this_file ]; then\r\n\r\n   if [ -f that_file ]; then\r\n\r\n​     if [ -f the_other_file ]; then\r\n\r\n​       echo “all  files present, and correct”\r\n\r\n​     fi\r\n\r\n   fi\r\n\r\nfi\r\n\r\n \r\n\r\n***\\*9、AND列表\\****\r\n\r\n  只有在前一条命令执行成功返回true才执行下一条。语法结构：\r\n\r\n Statement1  ***\\*&&\\**** Statement1  ***\\*&&\\**** Statement1  ***\\*&&\\**** ***\\*…\\****\r\n\r\n示例:\r\n\r\n\\#!/bin/bash\r\n\r\ntouch file_one\t\r\n\r\nrm –f file_two\r\n\r\nif [ -f file_one ] && echo “hello” && [ -f file_two ] && echo “there”\r\n\r\nthen\r\n\r\n  echo “in if”\r\n\r\nelse\r\n\r\n  echo “in else”\r\n\r\nfi\r\n\r\nexit 0\r\n\r\n***\\*10、OR列表 ，直到有一条命令执行成功为止。\\****\r\n\r\n 语法结构：\r\n\r\n Statement1 ***\\*||\\**** Statement2 ***\\*||\\**** Statement3 ***\\*||\\**** ***\\*…\\****\r\n\r\n示例：\r\n\r\nif [ -f file_one ] || echo “hello” || echo “there”\r\n\r\nthen\r\n\r\n  echo “in if”\r\n\r\nelse\r\n\r\necho “in else”\r\n\r\nfi\r\n\r\n***\\*11、语句块\\****\r\n\r\n如果想在只允许使用单个语句的地方（如 AND，OR）使用多条语句，可以是花括号{}来构造一个块。如下：\r\n\r\n  Get_confirm && {\r\n\r\n​    echo “hello”\r\n\r\n​    cat $tmp_file > $tracks_file\r\n\r\nadd_record_tracks\r\n\r\n}\r\n\r\n***\\*12、函数\\****\r\n\r\n要定义一个shell函数，只需写出它的名字，加上括弧，再把函数要实现的语句放在一对花括号中，如下所示：\r\n\r\nfunction_name ***\\*() {\\****\r\n\r\n   Statements\r\n\r\n***\\*}\\****\r\n\r\n示例：\r\n\r\n\\#!/bin/bash\r\n\r\nfoo(){\r\n\r\n  echo  “function foo is executing”\r\n\r\n}\r\n\r\necho  “ this is foo… ”\r\n\r\nfoo\r\n\r\necho “foo end!”\r\n\r\nexit 0\r\n\r\n如果在函数中没有return命令指定一个返回值，则函数返回的就是执行的最后一条命令的退出码。\r\n\r\n示例 \r\n\r\n\\#!/bin/bash\r\n\r\n\\# 函数部分\r\n\r\nYes_or_no(){\r\n\r\n  Echo “is your name $* ?”\r\n\r\n while true\r\n\r\ndo\r\n\r\n  echo –n “Enter yes or no: ”\r\n\r\n  read x\r\n\r\n case “$x” in\r\n\r\n  y | yes ) return 0;;\r\n\r\n  n | no ) return 1;;\r\n\r\n  *) echo “please input yes or no”\r\n\r\n esac\r\n\r\ndone\r\n\r\n\\#主程序部分\r\n\r\necho  “original parameters are $*”\r\n\r\nif  yes_or_no “$1”\r\n\r\nthen\r\n\r\n  echo “HI  $1,nice name”\r\n\r\nelse\r\n\r\n  echo “never mind”\r\n\r\nfi\r\n\r\nexit 0\r\n\r\n在函数内部定义的变量，在函数运行后，变量依然有效，如果只想在本函数内使用临时变量，可在变量前加上 ***\\*local\\****\r\n\r\n\\#!/bin/bash\r\n\r\nfoo()\r\n\r\n{\r\n\r\n local  str=aaaa ***\\*#\\*******\\*如果此处无local 则 最后的语句是可以输出aaaa\\*******\\*的\\****\r\n\r\necho "in foo $str"\r\n\r\n}\r\n\r\nfoo\r\n\r\necho "over $str"\r\n\r\n \r\n\r\n$# 表示参数个数，$1为第一个参数依次类推。（$*,$@）\r\n\r\n脚本中无函数的声明，调用某个函数前，该函数需要先被定义，所以函数的定义可以写在脚本的开始。\r\n\r\n \r\n\r\n***\\*13、一些命令\\****\r\n\r\n1）break 命令\r\n\r\n 在控制条件为满足之前，可以跳出 for，while，until循环，后面可带参数值，来表明要跳出的循环层数，但我们不建议这么做。\r\n\r\n2) :命令\r\n\r\n冒号（：）命令是一个空命令。偶尔被运用简化逻辑，相当于true。\r\n\r\n3) continue命令\r\n\r\n类似C语言中的同名语句。可使for，while，until循环跳到下一次循环继续执行，循环变量取循环列表中的下一个。\r\n\r\n如 for x in 1 2 3\r\n\r\ndo \r\n\r\n echo before $x\r\n\r\n continue 1\r\n\r\n echo after $x\r\n\r\ndone\r\n\r\n**4)** ***\\*.\\****命令\r\n\r\n默认情况下，shell脚本程序会在一个新创建的环境中执行，所以当脚本对环境变量所做的任何修改都会丢失，而点(***\\*.\\****)命令允许执行的脚本程序改变当前的环境。\r\n\r\n5) echo命令\r\n\r\n输出一行字符内容并换行，若要使其不换行linux有两种解决方法：echo –n “string to output”\r\n\r\necho –e “string to output\\c”\r\n\r\n(注：-e是确保启用了反斜杠转义字符，\\c代表去掉换行符，\\t代表制表符，\\n代表回车 )\r\n\r\n6) eval命令\r\n\r\neval允许对参数进行求值，如下：\r\n\r\nfoo=10\r\n\r\nx=foo\r\n\r\ny=’$’$x\r\n\r\necho $y  #输出为foo\r\n\r\n当使用 eval命令时，如下\r\n\r\nfoo=10\r\n\r\nx=foo\r\n\r\neval  y=’$’$x\r\n\r\necho $y  #输出为 10\r\n\r\n7) exec命令\r\n\r\n将当前shell替换为一个不同的程序\r\n\r\n如：exec wall “Thanks for the fish”\r\n\r\n脚本中的这个命令会用wall命令替换当前的shell。\r\n\r\n第二种用法是修改当前文件描述符：\r\n\r\nexec 3< afile\r\n\r\n修改文件描述符。\r\n\r\n  \r\n\r\n8) exit n命令\r\n\r\n一般使脚本程序以退出码n结束运行。\r\n\r\n0表示成功，1~125是脚本可以使用的错误代码。\r\n\r\n126表示文件不可执行，127表示命令未找到\r\n\r\n128及以上 出现一个信号\r\n\r\n9) export 命令\r\n\r\nexport 命令可以将变量参数导出到子shell中，子shell中即可访问该变量。如 TESTA=testa；export TESTA\r\n\r\n10)  expr命令\r\n\r\n  expr命令将它的参数当做一个表达式来求值。\r\n\r\n11) printf命令\r\n\r\n  printf “format  string” parameter1 parameter2 \r\n\r\n12)return 命令\r\n\r\n   return命令作用是使函数返回，后面可带返回值，如果没有返回值则默认返回最后一条命令的退出码。\r\n\r\n  13)set命令\r\n\r\n示例：从系统提供的参数date中提取出月份。\r\n\r\n\\#!/bin/bash\r\n\r\necho the date is $(date)\r\n\r\nset $(date)\r\n\r\necho The month is $2\r\n\r\nexit 0\r\n\r\n14)shift命令\r\n\r\nshift命令把所有参数变量左移一个位置，使$2变成$1,$3变成$2,$1被丢弃，$0保持不变。\r\n\r\nwhile [ “$1” != “” ];do\r\n\r\n  echo “$1”\r\n\r\n  shift\r\n\r\ndone\r\n\r\nexit 0\r\n\r\n15)trap命令\r\n\r\n  Trap命令用于指定在接收信号后将要采取的行动。\r\n\r\n语法结构：***\\*trap\\**** command signal\r\n\r\n第一个参数是收到指定信号要采取的行动。\r\n\r\n第二个参数是要处理的信号名称。\r\n\r\n如果要忽略一个信号，则将第一个参数设为空字符串。\r\n\r\n\\#!/bin/bash\r\n\r\ntrap \'rm -f /home/sufeng/my_shell/my_tmp_file_$$\' INT\r\n\r\necho creating file /home/sufeng/my_shell/my_tmp_file_$$\r\n\r\ndate > /home/sufeng/my_shell/my_tmp_file_$$\r\n\r\n \r\n\r\necho "press interrupt (ctrl-c) to interrupt ...."\r\n\r\nwhile [ -f /home/sufeng/my_shell/my_tmp_file_$$ ];do\r\n\r\n  echo File exists\r\n\r\n  sleep 1\r\n\r\ndone\r\n\r\n \r\n\r\necho the file no longer exists\r\n\r\n \r\n\r\ntrap INT\r\n\r\n \r\n\r\necho creating file /home/sufeng/my_shell/my_tmp_file_$$\r\n\r\ndate > /home/sufeng/my_shell/my_tmp_file_$$\r\n\r\necho "press interrupt (control-c) to interrupt ...."\r\n\r\nwhile [ -f /home/sufeng/my_shell/my_tmp_file_$$ ];do\r\n\r\n  echo File exists\r\n\r\n  sleep 1\r\n\r\ndone\r\n\r\necho we never get here\r\n\r\n16)unset命令\r\n\r\n  unset命令的作用是从环境中删除变量或函数。但不能删除shell本身定义的只读变量。\r\n\r\n  \\#!/bin/bash\r\n\r\nfoo="hello world"\r\n\r\necho $foo\r\n\r\nunset foo\r\n\r\necho $foo\r\n\r\n17)find命令\r\n\r\nfind语法结构：\r\n\r\nfind  [path]  [options]  [tests]  [actions]\r\n\r\n***\\*path\\**** 是要搜索的路径。\r\n\r\n***\\*O\\*******\\*ptions\\**** 选项:\r\n\r\n-depth   在查看目录本身之前先搜素目录的内容\r\n\r\n-follow   跟随符号链接\r\n\r\n-maxdepths N  最多搜索N层目录\r\n\r\n-mount(或-xdev)  不搜索其他文件系统中的目录\r\n\r\n***\\*T\\*******\\*ests选项\\****：\r\n\r\n-atime N  文件在N天之前被访问过\r\n\r\n-mtime N  文件在N天之前被修改过\r\n\r\n-name  “pattern” 按文件名称匹配\r\n\r\n-newer otherfile 文件比otherfile要新\r\n\r\n-type  c 文件类型为c\r\n\r\n-user username  文件的拥有者是指定用户。\r\n\r\n***\\*对tests部分的组合\\****：\r\n\r\n！  (-not)   测试取反\r\n\r\n-a   (-and)   两个测试都必须为真\r\n\r\n-o   (-or)   两个测试必须有一个为真 \r\n\r\n \r\n\r\n***\\*动作\\****：\r\n\r\n-exec  command  执行一条命令\r\n\r\n-ok  command    同上，只是处理时回头提示\r\n\r\n-print   打印文件名\r\n\r\n-ls     对当前文件使用命令 ls-dils\r\n\r\n***\\*一个find的示例：\\****\r\n\r\n***\\*sufeng@linux-ecmc:~/my_shell> find \\( -name "\\*1.sh" -o -atime 2 \\) -type f -exec ls -l {} \\;\\****\r\n\r\n***\\*结果如下：\\****\r\n\r\n-rwxrwxrwx 1 sufeng users 91 Sep  5 18:54 ./bb1.sh\r\n\r\n-rwxr--r-- 1 sufeng users 258 Sep  4 20:41 ./t_fun1.sh\r\n\r\n-rwxr--r-- 1 sufeng users 174 Sep  4 18:11 ./tm_case1.sh\r\n\r\n-rwxrwxrwx 1 sufeng users 39 Sep  5 18:35 ./cc1.sh\r\n\r\n-rwxrwxrwx 1 sufeng users 167 Sep  1 11:43 ./tm1.sh\r\n\r\n \r\n\r\n18)grep命令\r\n\r\ngrep语法如下:\r\n\r\ngrep  [options]  PATTERN  [FILES]\r\n\r\n选项            含义\r\n\r\n -c      输出匹配行的数目，而不是输出匹配行\r\n\r\n -i       忽略大小写\r\n\r\n -v       对匹配模式取反\r\n\r\n -l      只列出匹配行的文件名\r\n\r\n -E      启用扩展表达式\r\n\r\n -h      取消输出行普通前缀。\r\n\r\n 示例：\r\n\r\n grep -c -v in bb.sh cc.sh\r\n\r\n grep -c in bb.sh cc.sh\r\n\r\n19)正则表达式\r\n\r\n 字符            含义\r\n\r\n  ^           指向一行的开头\r\n\r\n  $           指向一行的结尾\r\n\r\n  .            任意单个字符\r\n\r\n  []      方括号包含一个字符范围，其中任何一个字符都可以匹配，如a~e，在字符范围前面加^，即不在指定范围内。\r\n\r\n 匹配模式              含义\r\n\r\n [:alnum:]            字母与数字字符\r\n\r\n [:alpha:]            字母\r\n\r\n [:ascii:]             ASCII 字符\r\n\r\n [:blank:]             空格或制表符\r\n\r\n [:cntrl:]             ASCII控制字符\r\n\r\n [:digit:]             数字\r\n\r\n [:graph:]            非控制、非空格字符\r\n\r\n [:lower:]            小写字母\r\n\r\n[:print:]               可打印字符\r\n\r\n[:punct:]              标点符号字符\r\n\r\n[:space:]            空白字符，包括垂直制表符\r\n\r\n[:upper:]               大写字母\r\n\r\n[:xdigit:]               十六进制数字\r\n\r\n \r\n\r\n选项                含义\r\n\r\n ？            匹配是可选的，但最多匹配一次\r\n\r\n​    \\*             必须匹配0次或多次\r\n\r\n​    \\+             必须匹配1次或多次\r\n\r\n   {n}             必须匹配n次\r\n\r\n   {n,}            必须匹配n次或n次以上\r\n\r\n   {n，m}         必须匹配n到m之间，包括n和m\r\n\r\n以上使用的时候需要加’\\’.\r\n\r\n示例：\r\n\r\ngrep  e$  bb.sh      以e结尾\r\n\r\ngrep  a[[:blank:]] bb.sh   以a结尾\r\n\r\ngrep  Th.[[:blank:]] bb.sh  匹配以Th开头的3个字符组成的单词\r\n\r\ngrep  -E [a-z]\\{10\\} bb.sh  匹配只有10个字符常的全由小写字母组成的单词。\r\n\r\n \r\n\r\n \r\n\r\n20)命令的执行\r\n\r\n  $(command)\r\n\r\n \\#!/bin/bash\r\n\r\n whoisthere=$(who)  将who显示的内容给变量\r\n\r\n echo $whoisthere  \r\n\r\n exit 0 \r\n\r\n***\\*算数扩展\\****\r\n\r\n \\#!/bin/bash\r\n\r\n  X=0\r\n\r\n  while [ “$X” –ne 10 ]; do\r\n\r\n   echo  $X\r\n\r\n   x=$(($x+1))\r\n\r\n done\r\n\r\nexit 0\r\n\r\n注意 使用$时，后面有两个括弧和一个括弧是有区别的，一个是赋只给变量，两个是进行算数运算。\r\n\r\n***\\*参数扩展\\****\r\n\r\n示例：\r\n\r\n如果有两个文件 1_tmp和2_tmp\r\n\r\n\\#！/bin/bash\r\n\r\nfor i in 1 2\r\n\r\ndo\r\n\r\n  my_secret_process ***\\*$i_tmp\\****\r\n\r\ndone\r\n\r\n此时，又有错误信息，应该为my_secret_process ***\\*${i}_tmp\\****\r\n\r\n \r\n\r\n***\\*参数扩展              说明\\****\r\n\r\n ${param:-default}        若param为空，则值为default\r\n\r\n ${#param}          给出param的长度\r\n\r\n ${param%word}  从尾部开始删除与word匹配的最小部分\r\n\r\n ${param%%word} 从尾部开始删除与word匹配的最长部分\r\n\r\n ${param#word}   从param的头部开始删除匹配的最小部分\r\n\r\n${param##word}  从param的头部开始删除匹配的最小部分\r\n\r\n21)here文档\r\n\r\n 可以将部分字符内容存储在脚本中，以特定的字符标示起始和结尾。\r\n\r\n示例;\r\n\r\n\\#!/bin/bash\r\n\r\ncat  <<!FUNKY!\r\n\r\nhello\r\n\r\nthis is a here\r\n\r\ndocument\r\n\r\n!FUNKY!\r\n\r\n示例2:  使用ed编辑器\r\n\r\n\\#!/bin/bash\r\n\r\ned  a_text_file  <<!FunkyStuff!\r\n\r\n3\r\n\r\nd\r\n\r\n.,\\$s/is/was/\r\n\r\nw\r\n\r\nq\r\n\r\n!FunkyStuff!\r\n\r\nexit 0\r\n\r\n \r\n\r\n其中 a_text_file 文件中内容如下\r\n\r\nThat is line 1\r\n\r\nThat is line 2\r\n\r\nThat is line 3\r\n\r\nThat is line 4\r\n\r\n ',w={data:function(){return{MainComponent:L}}},y=w,k=Object(d["a"])(y,b,f,!1,null,"e490d1f2",null),S=k.exports,$=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",{staticClass:"row  "},[t("q-select",{staticStyle:{width:"500px"},attrs:{"use-input":"","input-debounce":"0",clearable:"",options:n.book_options},on:{filter:n.filterFn},model:{value:n.book,callback:function(r){n.book=r},expression:"book"}},[t("template",{slot:"before"},[t("div")])],2)],1),t("div",{staticClass:"q-pdfviewer-container   "},[t("q-pdfviewer",{attrs:{src:n.src,type:"html5","content-class":" fit   q-pdfviewer-container","inner-content-class":" fit   q-pdfviewer-container"},model:{value:n.show,callback:function(r){n.show=r},expression:"show"}})],1)])},j=[],z=t("1b62"),M=["CDN排坑指南.pdf","DTS控制台一本通.pdf","ECS运维指南-linux诊断.pdf","ECS运维指南-windows诊断.pdf","Linux学习笔记.pdf","OSS运维-进阶手册.pdf","OSS运维u-基础书册.pdf","RDS数据库一本通.pdf","Rocket MQ 使用排查指南.pdf","VOD问题排查与实战手册.pdf","深入浅出K8S.pdf","深入浅出玩转物联网平台.pdf"],C="linux/pdf/",P={mixins:[z["c"]],data:function(){return{prefix:C,book_options:M,show:!0,book:M[0],src:""}}},R=P,E=Object(d["a"])(R,$,j,!1,null,null,null),D=E.exports,U=function(){var n=this;return n.$createElement,n._self._c,n._m(0)},N=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("div",{staticClass:"markdown_views prism-atom-one-dark",attrs:{id:"content_views"}},[t("blockquote",[t("p",[n._v("本文主要是Linux的入门内容，利用40张思维导图从"),t("strong",[n._v("基础、操作、实用指令、组管理和权限管理、crond任务调度、Linux磁盘分区和挂载、Linux网络环境配置、进程管理、服务管理、RPM和YUM、软件安装关键点、Shell编程共十二部分着手")]),n._v("，从而系统的了解一下Linux（基于Centos），本文的定位是前端工程师够用、运维工程师入门。")])]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNDQzMTBjYjU3ZGE.png",alt:""}})]),t("h2",[t("a",{attrs:{name:"t0"}}),t("a",{attrs:{name:"t0"}}),t("a",{attrs:{id:"_6"}}),n._v("一、基础")]),t("blockquote",[t("p",[n._v("主要阐述了什么是Linux、主要发行版有什么、如何在自己利用VM安装自己的Linux系统、Linux树形目录结构及相关目录的用途。")])]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNDQ3OGE2MDQwNzk.png",alt:""}})]),t("h2",[t("a",{attrs:{name:"t1"}}),t("a",{attrs:{name:"t1"}}),t("a",{attrs:{id:"_10"}}),n._v("二、操作")]),t("blockquote",[t("p",[n._v("主要介绍了Xftp5、XShell工具及vi和vim编辑器的使用。")])]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNDRhM2Y2OWFkMzI.png",alt:""}})]),t("h2",[t("a",{attrs:{name:"t2"}}),t("a",{attrs:{name:"t2"}}),t("a",{attrs:{id:"_14"}}),n._v("三、实用指令")]),t("blockquote",[t("p",[n._v("主要阐述了一系列实用指令，包括：关机&重启命令；用户登录和注销；用户管理；切换到指定运行级别；帮助指令；文件目录类；时间日期类；搜索查找类；压缩和解压类。")])]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNGZjNmVhZDYyMDg.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t3"}}),t("a",{attrs:{name:"t3"}}),t("a",{attrs:{id:"31__18"}}),n._v("3.1 关机&重启命令")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNGZlNDFlOTRlMzc.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t4"}}),t("a",{attrs:{name:"t4"}}),t("a",{attrs:{id:"32__20"}}),n._v("3.2 用户登陆和注销")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNGZmYjQ1MDcwNTE.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t5"}}),t("a",{attrs:{name:"t5"}}),t("a",{attrs:{id:"33__22"}}),n._v("3.3 用户管理")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTAwZmJiZGU5MGU.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t6"}}),t("a",{attrs:{name:"t6"}}),t("a",{attrs:{id:"34__24"}}),n._v("3.4 切换到指令运行级别")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTAyODdlYmFkZWU.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t7"}}),t("a",{attrs:{name:"t7"}}),t("a",{attrs:{id:"35__26"}}),n._v("3.5 帮助指令")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTAzYzI2NGRjODk.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t8"}}),t("a",{attrs:{name:"t8"}}),t("a",{attrs:{id:"36__28"}}),n._v("3.6 文件目录类")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTA1M2JkMzZiMzQ.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t9"}}),t("a",{attrs:{name:"t9"}}),t("a",{attrs:{id:"37__30"}}),n._v("3.7 时间日期类")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTA3MzVkMDc2YjE.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t10"}}),t("a",{attrs:{name:"t10"}}),t("a",{attrs:{id:"38__32"}}),n._v("3.8 搜索查找类")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTA4ODJjZDNlOGY.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t11"}}),t("a",{attrs:{name:"t11"}}),t("a",{attrs:{id:"39__34"}}),n._v("3.9 压缩和解压类")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTA5Yzc0NTVlMDg.png",alt:""}})]),t("h2",[t("a",{attrs:{name:"t12"}}),t("a",{attrs:{name:"t12"}}),t("a",{attrs:{id:"_36"}}),n._v("四、组管理和权限管理")]),t("blockquote",[t("p",[n._v("主要阐述了组管理及权限管理相关的内容。")])]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTBmYzU1MTc5NjI.png",alt:""}})]),t("h2",[t("a",{attrs:{name:"t13"}}),t("a",{attrs:{name:"t13"}}),t("a",{attrs:{id:"crond_40"}}),n._v("五、crond任务调度")]),t("blockquote",[t("p",[n._v("主要阐述了crond任务调度，使系统在某个时间执行特定的命令或程序")])]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTEzNzViNDc4MjA.png",alt:""}})]),t("h2",[t("a",{attrs:{name:"t14"}}),t("a",{attrs:{name:"t14"}}),t("a",{attrs:{id:"Linux_44"}}),n._v("六、Linux磁盘分区、挂载")]),t("blockquote",[t("p",[n._v("主要阐述了Linux磁盘分区、挂载，使开发者能够自己增加一块硬盘")])]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTE1NjIwNzAwYzk.png",alt:""}})]),t("h2",[t("a",{attrs:{name:"t15"}}),t("a",{attrs:{name:"t15"}}),t("a",{attrs:{id:"Linux_48"}}),n._v("七、Linux网络环境配置")]),t("blockquote",[t("p",[n._v("主要阐述了Linux网络环境配置中的自动获取IP和指定固定的IP，从而实现网络连接。")])]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTE3NTNiMDYxMjk.png",alt:""}})]),t("h2",[t("a",{attrs:{name:"t16"}}),t("a",{attrs:{name:"t16"}}),t("a",{attrs:{id:"_52"}}),n._v("八、进程管理")]),t("blockquote",[t("p",[n._v("主要阐述了与进程管理相关的内容，包括基本概念、显示执行的进程、查看进程树、终止进程、动态监控进程、查看系统网络情况及进程状态。")])]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWMzMmViYjE3NmY.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t17"}}),t("a",{attrs:{name:"t17"}}),t("a",{attrs:{id:"81__56"}}),n._v("8.1 基本")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWM0OGM2NWJhNGU.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t18"}}),t("a",{attrs:{name:"t18"}}),t("a",{attrs:{id:"82__58"}}),n._v("8.2 显示执行的进程")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWM1OTQyNmNiNDU.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t19"}}),t("a",{attrs:{name:"t19"}}),t("a",{attrs:{id:"83__60"}}),n._v("8.3 查看进程树")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWM2ODQ0YjkxMDg.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t20"}}),t("a",{attrs:{name:"t20"}}),t("a",{attrs:{id:"84__62"}}),n._v("8.4 终止进程")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWM3NTRmNDAyYmU.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t21"}}),t("a",{attrs:{name:"t21"}}),t("a",{attrs:{id:"85__64"}}),n._v("8.5 动态监控进程")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWM4MzY4ZGMxM2E.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t22"}}),t("a",{attrs:{name:"t22"}}),t("a",{attrs:{id:"86__66"}}),n._v("8.6 查看系统网络情况")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWM5MGJjY2ZkMTg.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t23"}}),t("a",{attrs:{name:"t23"}}),t("a",{attrs:{id:"87__68"}}),n._v("8.7 进程状态")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWNhMGQxODQ0ZTM.png",alt:""}})]),t("h2",[t("a",{attrs:{name:"t24"}}),t("a",{attrs:{name:"t24"}}),t("a",{attrs:{id:"_70"}}),n._v("九、服务管理")]),t("blockquote",[t("p",[n._v("主要阐述了何为服务以及与服务管理相关的一些列指令。")])]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWQxODhjMWM1ZjE.png",alt:""}})]),t("h2",[t("a",{attrs:{name:"t25"}}),t("a",{attrs:{name:"t25"}}),t("a",{attrs:{id:"RPMYUM_74"}}),n._v("十、RPM和YUM")]),t("blockquote",[t("p",[n._v("主要阐述了Linux系统中软件安装的两种方式：rpm和yum。")])]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWQ4MDQ1YTc1YTU.png",alt:""}})]),t("h2",[t("a",{attrs:{name:"t26"}}),t("a",{attrs:{name:"t26"}}),t("a",{attrs:{id:"_78"}}),n._v("十一、软件安装关键点")]),t("blockquote",[t("p",[n._v("阐述了软件安装中需要注意的关键点：如何配置环境变量及开放对应端口。")])]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWRjMjQ3NDA0N2Y.png",alt:""}})]),t("h2",[t("a",{attrs:{name:"t27"}}),t("a",{attrs:{name:"t27"}}),t("a",{attrs:{id:"Shell_82"}}),n._v("十二、Shell编程")]),t("blockquote",[t("p",[n._v("主要阐述与Linux操作息息相关的Shell编程中的一些基础语法。")])]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjY2MTEwYWNkYjE.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t28"}}),t("a",{attrs:{name:"t28"}}),t("a",{attrs:{id:"121__86"}}),n._v("12.1 基本介绍")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjY3NTU4MDZhNmM.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t29"}}),t("a",{attrs:{name:"t29"}}),t("a",{attrs:{id:"122__88"}}),n._v("12.2 基本使用")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjY4MTllNWI3N2M.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t30"}}),t("a",{attrs:{name:"t30"}}),t("a",{attrs:{id:"123_shell_90"}}),n._v("12.3 shell的变量")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjY4ZWU4NDBiOTE.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t31"}}),t("a",{attrs:{name:"t31"}}),t("a",{attrs:{id:"124__92"}}),n._v("12.4 注释")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjY5ZTUwMjEyN2I.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t32"}}),t("a",{attrs:{name:"t32"}}),t("a",{attrs:{id:"125__94"}}),n._v("12.5 字符串")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjZhYzM2YWM1M2Y.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t33"}}),t("a",{attrs:{name:"t33"}}),t("a",{attrs:{id:"126__96"}}),n._v("12.6 数组")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjZiYTI2MTNkNWM.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t34"}}),t("a",{attrs:{name:"t34"}}),t("a",{attrs:{id:"127__98"}}),n._v("12.7 运算符")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjZjZTUwMTUyMjU.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t35"}}),t("a",{attrs:{name:"t35"}}),t("a",{attrs:{id:"128__100"}}),n._v("12.8 条件判断")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjZkZWY4MmI1NGI.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t36"}}),t("a",{attrs:{name:"t36"}}),t("a",{attrs:{id:"129__102"}}),n._v("12.9 流程控制")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjZlZmQ2Y2RmYmI.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t37"}}),t("a",{attrs:{name:"t37"}}),t("a",{attrs:{id:"1210_read_104"}}),n._v("12.10 read读取控制台输入")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjZmZTI2YWYxZGI.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t38"}}),t("a",{attrs:{name:"t38"}}),t("a",{attrs:{id:"1211__106"}}),n._v("12.11 函数")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjcwZGFjNDhjZmI.png",alt:""}})])])])}],I={data:function(){return{}}},A=I,W=Object(d["a"])(A,U,N,!1,null,"654ef60c",null),H=W.exports,O=function(){var n=this;return n.$createElement,n._self._c,n._m(0)},T=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{staticClass:"q-py-md"},[t("div",[t("a",{attrs:{href:"http://rpm.pbone.net",target:"_blank",rel:"noopener noreferrer"}},[n._v("a. 去官网去下载（http://rpm.pbone.net）；")])]),t("div",[n._v("### MobaXterm 官网： "),t("a",{attrs:{href:"https://mobaxterm.mobatek.net/",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://mobaxterm.mobatek.net/")])]),t("div",[n._v("\n      yum 阿里云镜像 源\n      "),t("a",{attrs:{href:"https://developer.aliyun.com/mirror/",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://developer.aliyun.com/mirror/")])]),t("div",[t("a",{attrs:{href:"https://gitee.com/Discuz/DiscuzX",target:"_blank",rel:"noopener noreferrer"}},[n._v(" LAMP --- DiscuzX 开源论坛系统")])]),t("div",[n._v("奇Q工具网 "),t("a",{attrs:{href:"https://qqe2.com/",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://qqe2.com/")])]),t("pre",[n._v("      nodejs  环境安装 \n      cd /usr/local/src/\n\n      官网 找到 linux 包 https://nodejs.org/download/release\n       https://nodejs.org/download/release/v12.20.0/node-v12.20.0-linux-x64.tar.xz\n       \nLinux 上安装 Node.js\nwget https://nodejs.org/dist/v12.18.1/node-v12.18.1-linux-x64.tar.xz    // 下载\ntar xf node-v12.18.1-linux-x64.tar.xz                                   // 解压\ncd node-v12.18.1-linux-x64                                              // 进入解压目录\n解压文件的 bin 目录底下包含了 node、npm 等命令，我们可以修改linux系统的环境变量（profile）来设置直接运行命令：\n\n老规矩先备份，养成修改重要文件之前先备份的好习惯。\n\ncp /etc/profile /etc/profile.bak\n然后 vim /etc/profile，在最下面添加 export PATH=$PATH: 后面跟上 node 下 bin 目录的路径\n\nexport PATH=$PATH:/root/node-v12.18.1-linux-x64/bin\n立即生效\n\nsource /etc/profile\n[root@localhost ~]# node -v\nv12.18.1\nOK！安装成功！\n   \n使用 Linux 服务器集群管理面板 appnode 类似的 工具 可以快速 部署\nyum -y install epel-release\nyum -y install nginx\n         service  nginx  restart\n          systemctl restart nginx.service\n   \n    ")]),t("pre",[n._v("杀死某个用户的 所有进程  kill -9 $(ps -ef | grep username)    或者   killall -u username  \n\n")])])}],q={data:function(){return{}}},G=q,Y=Object(d["a"])(G,O,T,!1,null,"29e575de",null),F=Y.exports,B=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}})],1)},Q=[],V=(t("caad"),t("ac1f"),t("2532"),t("1276"),'\x3c!--\n * @Date           : 2021-07-11 03:48:46\n * @FilePath       : /jinnian-space/src/pages/linux/md/linux-进程检测与控制.md\n * @Description    : \n--\x3e\n# Linux计划任务以及进程检测与控制，优先级\n\n# 一、Linux计划任务\n\n##  Linux中的计划任务\n\n基本语法：\n\n```powershell\n# crontab [选项]\n-l ：list，显示目前已经设置的计划任务\n-e ：使用vim编辑器编辑计划任务的文件\n```\n\n案例：显示当前账号下的计划任务\n\n```powershell\n# crontab -l\nno crontab for root => root账号下没有创建计划任务\n```\n\n案例：编写计划任务\n\n```powershell\n# crontab -e\n```\n\n##  计划任务的编辑\n\ncrontab -e进入计划任务编辑文件\n\n![image-20200323162534378](media/image-20200323162534378.png)\n\n打开计划任务编辑文件后，可以在此文件中编写我们自定义的计划任务：\n\n==计划任务的规则语法格式，以行为单位，一行则为一个计划==\n\n```powershell\n分  时  日  月  周  要执行的命令（要求必须使用命令的完整路径，可以使用which查看）\n\n取值范围（常识）：\n分：0~59\n时：0~23\n日：1~31\n月：1~12\n周：0~7，0 和 7 表示星期天\n\n四个符号：\n*：表示取值范围中的每一个数字\n-：做连续区间表达式的，要想表示1~7，则可以写成：1-7\n/：表示每多少个，例如：想每 10 分钟一次，则可以在分的位置写：*/10\n,：表示多个取值，比如想在 1 点，2 点 6 点执行，则可以在时的位置写：1,2,6\n```\n\n![image-20200323163957324](media/image-20200323163957324.png)\n\n##  几个小案例\n\n问题1：每月1、10、22 日的4:45 重启network 服务\n\n```powershell\n第一步：定制格式\n分  时  日      月   周 /usr/bin/systemctl restart network\n第二步：定制时间\n45  4  1,10,22  *   *  /usr/bin/systemctl restart network\n```\n\n问题2：每周六、周日的1:10 重启network 服务\n\n```powershell\n第一步：定制格式\n分 时 日 月 周 /usr/bin/systemctl restart network\n第二步：定制时间\n10 1  * *  6,7 /usr/bin/systemctl restart network\n```\n\n问题3：每天18:00 至23:00 之间每隔30 分钟重启network 服务\n\n```powershell\n第一步：定制格式\n分 时 日 月 周 /usr/bin/systemctl restart network\n第二步：定制时间\n*/30 18-23 * * * /usr/bin/systemctl restart network\n```\n\n问题4：每隔两天的上午8 点到11 点的第3 和第15 分钟执行一次重启\n\n```powershell\n第一步：定制格式\n分 时 日 月 周 /usr/sbin/reboot\n第二步：定制时间\n3,15  8-11 */2 * * /usr/sbin/reboot\n```\n\n案例：每1 分钟往 root 家目录中的 readme.txt 中输一个1，为了看到效果使用追加输出【输出使用echo 命令，语法：# echo 输出的内容】\n\n```powershell\n# crontab -e\n* * * * * /usr/bin/echo 1 >> /root/readme.txt\n```\n\n提示：为了看到计划任务的效果，你可以单独开一个选项卡，使用tail  -f  /root/readme.txt\n\n##  计划任务\n\n常见的一个操作：定时备份（定时把数据库中的数据导出到某个文件中）\n##  计划任务权限\n\n### ☆ 黑名单\n\ncrontab是任何用户都可以创建的计划任务，但是超级管理员可以通过配置来设置某些用户不允许设置计划任务 。\n\n提出问题：如果我们想限定某个用户（如itheima）使用计划任务，如何处理呢？\n\n答：可以使用计划任务的黑名单，黑名单文件路径 => ==/etc/cron.deny==文件\n\n案例：把普通账号itheima加入到cron.deny黑名单中，禁止其创建计划任务\n\n第一步：切换到超级管理员root\n\n```powershell\n# su - root\n```\n\n第二步：使用vim打开/etc/cron.deny文件\n\n```powershell\n# vim /etc/cron.deny\n```\n\n第三步：把你需要禁止的用户名单，加入此文件（如itheima）\n\n```powershell\nitheima\n```\n\n切换到itheima账号，测试是否可以使用crontab命令\n\n![image-20200324095412933](media/image-20200324095412933.png)\n\n### ☆ 白名单\n\n在Linux的计划任务中，除了拥有黑名单以外，还有白名单。作用：允许哪些用户使用计划任务。\n\n白名单文件的路径 => ==/etc/cron.allow==，但是要特别注意，此文件需要手工创建。\n\n> 注意：白名单优先级高于黑名单，如果一个用户同时存在两个名单文件中，则会被默认允许创建计划任务。\n\n##  查看计划任务的保存文件\n\n问题：计划任务文件具体保存在哪里呢？\n\n答：`/var/spool/cron/用户名称`，如果使用root用户编辑计划任务，则用户文件名为root\n\n```powershell\n# ll /var/spool/cron\ntotal 4\n-rw-------. 1 itheima itheima  0 Mar 24 09:50 itheima\n-rw-------. 1 root    root    40 Mar 24 10:21 root\n```\n\n##  计划任务的日志程序\n\n问题：在实际应用中，我们如何查看定时任务运行情况？\n\n答：通过计划任务日志，日志文件位于`/var/log/cron`\n\n案例：演示计划任务的日志程序\n\n第一步：使用root账号创建一个计划任务\n\n```powershell\n# su - root\n# crontab -e\n* * * * * echo 1 >> ~/readme.txt\n```\n\n第二步：使用tail -f命令监控/var/log/cron日志程序\n\n```powershell\n# tail -f /var/log/cron\n```\n\n##  扩展内容：at命令\n\n在Linux系统下，有两个命令可以实现计划任务：crontab与at（第三方需要额外安装）\n\ncrontab ：每天定时执行计划任务（最小单元分钟）\n\nat ：一次性定时执行任务\n\n### ☆ 安装at命令\n\nCentOS7自带，其他版本可能需要手工安装\n\n```powershell\n# yum install at -y\n```\n\n### ☆ 启动底层服务\n\n```powershell\n# systemctl start atd\n# systemctl enable atd\n```\n\n> atd = at + d = at命令 + daemon缩写\n\n### ☆ 案例演示\n\n案例1：三天后下午5点执行/bin/ls\n\n```powershell\n# at 5pm+3 days\nat>/bin/ls >/root/readme.txt\nat>按Ctrl+D\n```\n\n> am = 上午、pm = 下午、3 days = 3天\n\n案例2：明天17点，输出时间到指定的文件中\n\n```powershell\n# at 17:00 tomorrow\nat>date>/root/readme.txt\nat>按Ctrl+D\n```\n\n> tomorrow = 明天\n\n案例3：使用atq查看没有执行的计划任务\n\n```powershell\n# atq\n```\n\n> atq = at + q = at命令 + query查询\n\n案例4：删除指定的计划任务\n\n```powershell\n# atq\n# atrm 任务号\n```\n\n> atrm = at + rm = at命令 + remove移除\n\n# 二、Linux进程与程序\n\n## 1、了解一下进程与程序的关系\n\n​        **进程**是正在执行的一个程序或命令，每个进程都是一个运行的实体，并占用一定的系统资源。**程序**是人使用计算机语言编写的可以实现特定目标或解决特定问题的代码集合。\n\n​        简单来说，程序是人使用计算机语言编写的，可以实现一定功能，并且可以执行的代码集合。进程是正在执行中的程序。\n\n**举例**：谷歌浏览器是一个程序，当我们打开谷歌浏览器，就会在系统中看到一个浏览器的进程，当程序被执行时，程序的代码都会被加载入内存，操作系统给这个进程分配一个 ID，称为 **PID**（进程 ID）。我们打开多个谷歌浏览器，就有多个浏览器子进程，但是这些进程使用的程序，都是chrome\n\n> PID = Process ID = 进程编号\n\n![image-20200324113209223](media/image-20200324113209223.png)\n\n## 2、Linux下的进程管理工作\n\n进程查看，通过查看，判断健康状态\n\n进程终止\n\n进程优先级控制\n\n# 三、Linux下进程管理命令\n\n## 1、任务背景\n\n工作场景：\n\n​        小黑入职到一家公司，接到的第一项任务，就是监控生产服务器的性能，提到服务器性能，我们首先想到的就是CPU，内存和磁盘。\n\n## 2、使用top命令动态监测CPU信息\n\n基本语法：\n\n```powershell\n# top\n```\n\n![image-20200324114201114](media/image-20200324114201114.png)\n\n## 3、系统的整体情况\n\n### ☆ 第一行\n\n![image-20200324114427942](media/image-20200324114427942.png)\n\n| 内 容                         | 说 明                                                        |\n| ----------------------------- | ------------------------------------------------------------ |\n| 10:12:28                      | 系统当前时间                                                 |\n| up 13:05                      | 系统的运行时间.本机己经运行 13 小时 05 分钟                  |\n| 3 users                       | 当前登录了三个用户                                           |\n| load average: 0.00,0.01，0.05 | 系统在之前 1 分钟、5 分钟、15 分钟的平均负载。如果 CPU 是单核的，则这个数值超过 1 就是高负载：如果 CPU 是四核的，则这个数值超过 4 就是高负载 |\n\n### ☆ 第二行\n\n![image-20200324115718442](media/image-20200324115718442.png)\n\n| Tasks:   230 total | 系统中的进程总数                                 |\n| ------------------ | ------------------------------------------------ |\n| 1 running          | 正在运行的进程数                                 |\n| 229 sleeping       | 睡眠的进程数                                     |\n| 0 stopped          | 正在停止的进程数                                 |\n| 0 zombie           | 僵尸进程数。如果不是   0，则需要手工检查僵尸进程 |\n\n### ☆ 第三行\n\n![image-20200324142002240](media/image-20200324142002240.png)\n\n| 内 容           | 说 明                                                        |\n| --------------- | ------------------------------------------------------------ |\n| Cpu(s): 0.1 %us | 用户模式占用的   CPU 百分比                                  |\n| 0.1%sy          | 系统模式占用的   CPU 百分比                                  |\n| 0.0%ni          | 改变过优先级的用户进程占用的   CPU 百分比                    |\n| 99.7%id         | idle缩写，空闲   CPU 占用的 CPU 百分比                       |\n| 0.1%wa          | 等待输入/输出的进程占用的   CPU 百分比                       |\n| 0.0%hi          | 硬中断请求服务占用的   CPU 百分比                            |\n| 0.1%si          | 软中断请求服务占用的   CPU 百分比                            |\n| 0.0%st          | st（steal   time）意为虚拟时间百分比，就是当有虚拟机时，虚拟 CPU 等待实际 CPU 的时间百分比 |\n\n#### 问题：如果我的机器有4核CPU，我想查看每一核心分别的负载情况怎能办？\n\n答：交换快捷键 “1”\n\n![image-20200324142144911](media/image-20200324142144911.png)\n\n> CPU负载测试 =>  cat  /dev/urandom |md5sum\n\n### ☆ 第四行\n\n![image-20200324143340302](media/image-20200324143340302.png)\n\n| 内 容              | 说 明                                                        |\n| ------------------ | ------------------------------------------------------------ |\n| Mem: 1863252 total | 物理内存的总量，单位为KB                                     |\n| 829960 used        | 己经使用的物理内存数量                                       |\n| 68352 free         | 空闲的物理内存数量。我们使用的是虚拟机，共分配了 628MB内存，所以只有53MB的空闲内存 |\n| 96490 buff/cache   | 作为缓冲的内存数量                                           |\n\n>扩展：真正剩余内存 = free + buff/cache，真正使用内存 = used - buff/cache\n\n### ☆ 第五行\n\n![image-20200324144347040](media/image-20200324144347040.png)\n\n| 内 容               | 说 明                        |\n| ------------------- | ---------------------------- |\n| Swap: 2097148 total | 交换分区（虚拟内存）的总大小 |\n| 3336 used           | 已经使用的交换分区的大小     |\n| 2093812 free        | 空闲交换分区的大小           |\n| 622420 avail Mem    | 可用内存                     |\n\n 在Linux操作系统分区时，最少需要3个分区：\n\n① /boot分区 ： 系统分区\n\n② swap交换分区 ：一般情况下为内存的1~2倍，但是尽量不要超过2G\n\n③ /分区 ：根分区，所有文件都存放于此\n\n> swap分区：就是当计算机的内存不足时，系统会自动从硬盘中划出一块区域充当内存使用。\n\n​       我们通过 top 命令的整体信息部分，就可以判断服务器的健康状态。如果 1 分钟、5 分钟、15 分钟的平均负载高于CPU核数，说明系统压力较大。如果物理内存的空闲内存过小，则也证明系统压力较大。\n\n问题：根据以上信息，目前我们的系统压力如何？\n\n答：看CPU负载及内存的使用情况\n\n\n\n问题：如果我们发现CPU负载过大，接下来怎么办？\n\n答：如果1分钟、5分钟以及15分钟全部超过CPU的总核心数（必须引起警觉），这个时候就要查看底部的进程信息了。\n\n> 经验之谈：如果一个总核数=8核心的CPU，理论上平均负载达到16，也还可以坚持很长一段时间。\n\n## 4、系统的进程信息\n\n![image-20200324151820219](media/image-20200324151820219.png)\n\n| PID     | 进程的 ID。                                                  |\n| ------- | ------------------------------------------------------------ |\n| USER    | 该进程所属的用户。                                           |\n| PR      | 优先级，数值越小优先级越高。                                 |\n| NI      | NICE优先级，数值越小优先级越高，取值范围-20到19，默认都是0   |\n| VIRT    | 该进程使用的虚拟内存的大小，单位为 KB。                      |\n| RES     | 该进程使用的物理内存的大小，单位为 KB。                      |\n| SHR     | 共享内存大小，单位为 KB。计算一个进程实际使用的内存 = 常驻内存（RES）- 共享内存（SHR） |\n| S       | 进程状态。其中S 表示睡眠，R 表示运行                         |\n| %CPU    | 该进程占用 CPU 的百分比。                                    |\n| %MEM    | 该进程占用内存的百分比。                                     |\n| TIME+   | 该进程共占用的 CPU 时间。                                    |\n| COMMAND | 进程名                                                       |\n\n#### 问题：如果我们发现CPU负载过大，接下来怎么办？\n\n答：查看占用CPU最多的进程\n\n\n\n#### 问题：如何查看占用CPU最多的进程？\n\n答：交互操作快捷键P，P（大写）：，表示将结果按照CPU 使用率从高到低进行降序排列\n\n\n\n#### 问题：如果我们发现内存可用量很小，接下来怎么办？\n\n答：查看占用内存最多的进程，使用交互快捷键M（大写）：表示将结果按照内存（MEM）从高到低进行降序排列\n\n![image-20200324154216736](media/image-20200324154216736.png)\n\n\n\n#### 问题：当我们查看完系统状态，需要做什么？\n\n答：退出，使用q，按键盘上的q，就会回到#提示符的状态。\n\n## 5、free查看内存使用情况\n\n基本语法：\n\n```powershell\n# free [选项]  1GB = 1024MB  1MB = 1024KB\n选项说明：\n-m : 以MB的形式显示内存大小\n```\n\n案例：显示计算机的内存使用情况\n\n```powershell\n# free -m\n```\n\n​    和Centos6相比，buffer和cached被合成一组，加入了一个available。\n\n​    关于此available，即系统可用内存，用户不需要去计算buffer/cache，即可以看到还有多少内存可用，更加简单直观\n\n![image-20200324155922424](media/image-20200324155922424.png)\n\n## 6、df查看磁盘剩余空间\n\n基本语法：\n\n```powershell\n# df [选项]\n-h ：以较高的可读性显示磁盘剩余空间大小\n```\n\n> df = disk free = 磁盘 剩余\n\n这几列依次是：\n\n| Filesystem | 磁盘名称                           |\n| ---------- | ---------------------------------- |\n| Size       | 总大小                             |\n| Used       | 被使用的大小                       |\n| Avail      | 剩余大小                           |\n| Use%       | 使用百分比                         |\n| Mounted on | 挂载路径（相当于Windows 的磁盘符） |\n\n## 7、ps查看系统进程信息\n\ntop ： 动态查看系统进程的信息（每隔3s切换一次）\n\nps  ： 静态查看系统进程的信息（只能查询运行ps命令瞬间，系统的进程信息）\n\n基本语法：\n\n```powershell\n# ps [选项]\n选项说明：\n-e : 等价于“-A”，表示列出全部（all）的进程\n-f : 表示full，显示全部的列（显示全字段）\n```\n\n案例：显示当前系统中所有进程的信息\n\n```powershell\n# ps -ef\n```\n\n![image-20200324162137670](media/image-20200324162137670.png)\n\n| UID   | 该进程执行的用户ID                                           |\n| ----- | ------------------------------------------------------------ |\n| PID   | 进程ID                                                       |\n| PPID  | 该进程的父级进程ID，如果找不到，则该进程就被称之为僵尸进程（Parent Process ID） |\n| C     | Cpu的占用率，其形式是百分数                                  |\n| STIME | 进程的启动时间                                               |\n| TTY   | 终端设备，发起该进程的设备识别符号，如果显示“?”则表示该进程并不是由终端设备发起 |\n| TIME  | 进程实际使用CPU的时间                                        |\n| CMD   | 该进程的名称或者对应的路径                                   |\n\n> 经验之谈：我们在实际工作中使用ps命令其实主要用于查询某个进程的PID或PPID\n\n工作场景\n\n​        小黑用学到的命令，发现某个进程占用CPU很高，希望进一步查看这个简称的信息。\n\n​        ps -ef 会列出全部进程，但是我们发现进程非常多，我们很难找到自己想要看的进程。这里需要使用过滤命令grep，来过滤掉我们不需要的信息。\n\n基本语法：\n\n```powershell\n用法：ps -ef |grep 想要看到的进程名\n示例代码：\n# ps -ef |grep crond\n含义：查看crond进程的详细情况\n注意：查询结果中，如果只有一条则表示没查到对应的进程（这1 条表示刚才ps 指令的自身）。只有查到的结果多余1 条，才表示有对应的进程。\n```\n\n案例：查询crond的进程信息\n\n```powershell\n# ps -ef |grep crond\nroot       7102      1  0 Mar23 ?        00:00:04 /usr/sbin/crond -n\nroot      24752  12881  0 16:34 pts/2    00:00:00 grep --color=auto crond\n```\n\n问题：以上信息只有第一行是crond的进程，第二行，实际是管道命令发起时，grep所启动的进程，如何去掉？\n\n```powershell\n# ps -ef |grep crond |grep -v "grep"\nroot       7102      1  0 Mar23 ?        00:00:04 /usr/sbin/crond -n\n```\n\n> grep  -v  需要去除的相关信息 ： 去除包含指定关键词的那一行\n\n扩展：ps  aux命令\n\n```powershell\n# ps aux\n```\n\n> \\# man ps\n>\n> 1   UNIX options, which may be grouped and must be preceded by a dash.     ps  -ef\n> 2   BSD options, which may be grouped and must not be used with a dash.\t ps  aux\n\n![image-20200324165018806](media/image-20200324165018806.png)\n\nUSER：该 process 属于哪个使用者账号\n==PID ：该 process 的ID==\n==%CPU：该 process 使用掉的 CPU 资源百分比==\n==%MEM：该 process 所占用的物理内存百分比==\nVSZ ：该 process 使用掉的虚拟内存量 (Kbytes)\nRSS ：该 process 占用的固定的内存量 (Kbytes)\nTTY ：该 process 是在那个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1-tty6 是本机上面的登入者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序。\n==STAT：该程序目前的状态，主要的状态有==\n    R ：该程序目前正在运作，或者是可被运作\n    S ：该程序目前正在睡眠当中 (可说是 idle 状态)，但可被某些讯号 (signal) 唤醒。\n    T ：该程序目前正在侦测或者是停止了\n   ==Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态==\nSTART：该 process 被触发启动的时间\nTIME ：该 process 实际使用 CPU 运作的时间\nCOMMAND：该程序的实际指令\n\n## 8、netstat/ss查询网络访问信息\n\n基本语法：\n\n```powershell\n# netstat [选项] |grep 进程名称\n选项说明：\n-t：表示只列出tcp 协议的连接（tcp协议与udp协议）\n-n：表示将地址从字母组合转化成ip 地址，将协议转化成端口号来显示  10.1.1.10:80\n-l：表示过滤出"state（状态）"列中其值为LISTEN（监听）的连接\n-p：表示显示发起连接的进程pid 和进程名称\n```\n\n案例：查询Web Server（httpd）服务的端口信息\n\n```powershell\n# netstat -tnlp |grep httpd\n```\n\n\n\n基本语法：\n\n```powershell\n# ss -naltp |grep 进程名称\n```\n\n案例：查询sshd服务的端口信息\n\n```powershell\n# ss -naltp |grep sshd\n```\n\n> netstat与ss区别？① netstat信息比较简洁，ss更加丰富 ② ss执行效率比netstat略高一些\n\n## 9、kill/killall杀死进程\n\n### ☆ 根据pid杀掉进程\n\n```powershell\n命令：kill\n语法：kill [信号] PID\n作用：kill 命令会向操作系统内核发送一个信号（多是终止信号）和目标进程的 PID，然后系统内核根据收到的信号类型，对指定进程进行相应的操作\n\n经验：kill经常结合ps命令一起使用\n```\n\n> kill命令用于杀死某个进程，这其实只是其一个功能。kill命令的实质是向进程发送信号\n\n信号种类：\n\n| 信号编号 | 含义                                     |\n| -------- | ---------------------------------------- |\n| 9        | 杀死进程，即强制结束进程。               |\n| 15       | 正常结束进程，是 kill   命令的默认信号。 |\n\n案例：使用kill命令杀死crond进程\n\n```powershell\n# ps -ef |grep crond\n7102\n# kill 7102\n```\n\n> 备注：在互联网中，经常看到kill  -9  进程PID，强制杀死某个进程，kill -9 pid\n\n### ☆ 根据进程名称杀掉进程\n\n基本语法：\n\n```powershell\n# killall [信号编号] 进程名称\n```\n\n案例：使用killall命令杀死crond进程\n\n```powershell\n# killall crond\n```\n\n案例：使用killall命令杀死httpd进程\n\n```powershell\n# killall httpd\n```\n\n\n# 三、进程的优先级（扩展）\n\n## 1、什么是进程的优先级\n\nLinux是一个多用户、多任务的操作系统，系统中通常运行着非常多的进程。哪些进程先运行，哪些进程后运行，就由进程优先级来控制\n\n思考：什么时候需要用到进程的优先级呢？\n\n答：当CPU负载过高时，如CPU的使用率>=90%以上。这个时候进程的优先级就会起作用。\n\n## 2、查看进程的优先级\n\nPR  优先级，数值越小优先级越高。\nNI  优先级，数值越小优先级越高，可以人为更改。（NI = NICE = Nice）\n\n讲个小故事：Nice值 = 0，Nice值越高，代表这个人越绅士（Nice值越高，优先级越低）\n\n> NI值有一个范围 -20 ~ 19\n\n问题：这两个数值是在哪里看到的？\n\n答：top命令\n\n## 3、调整进程的优先级\n\n### ☆ 使用top调整进程的优先级\n\n第一步：使用top命令获取你要调整的进程信息（PID编号）\n\n```powershell\n# top -bn 1\nPID   \tCOMMAND\n7107\tatd（at命令的底层服务）\n```\n\n第二步：运行top命令，然后按=="r"==，输入要调整进程的PID编号\n\n```powershell\n# top\n按r，输入要调整进程的PID编号,按回车\n```\n\n第三步：根据提示，重置NICE值\n\n```powershell\nRenice PID 7107 to value : -5\n```\n\n第四步：按q退出top模式，然后使用top -p PID编号，只查询某个进程的信息\n\n```powershell\n# top -p 7107\n```\n\n### ☆ 使用renice命令调整进程的优先级\n\n基本语法：\n\n```powershell\n# renice [NI优先级设置的数字] 想调整的进程ID\n```\n\n案例：使用renice调整atd的优先级\n\n```powershell\n第一步：通过ps或top命令获取atd的PID编号\n# ps -ef |grep atd\n7107\n第二步：使用renice命令调整7107的NICE值\n# renice -10 7107\n7107 (process ID) old priority 0, new priority -10\n```\n\n> 注意：NICE值取值范围-20 ~ 19，不能使用小数\n\n### ☆ 使用nice命令调整进程的优先级\n\n基本语法：\n\n```powershell\n# nice [NI优先级设置的数字] 想调整的进程名称\n```\n\n> 注意：nice命令只能调整没有运行的程序\n\nnice实际操作三步走：\n\n第一步：将程序停止\n\n```powershell\n# ps -ef |grep crond\n# kill PID\n或\n# systemctl stop crond\n```\n\n第二步：启动并制定优先级（使用nice）\n\n```powershell\n# nice -n -10 crond\n```\n\n> nice命令包含两个功能：① 启动进程 ② 调整进程的优先级\n\n第三步：确认优先级（查看优先级）\n\n```powershell\n# ps -ef |grep crond\nPID\n# top -p PID\n```\n\n\n\n\n\n\n'),X={data:function(){return{MainComponent:V,img_prefix:"./img/linux/heima-Linux云计算/进程检测与控制/"}},methods:{extendMarkdown:function(n){var r=this;console.log(n.renderer.rules);var t=n.renderer.rules.html_block;n.renderer.rules.html_block=function(n,e,i,a,s){var l=n[e];if(console.log("1"),l.content.includes("<img")){console.log("token-- ",l);var o="";o=l.content;var d=o.split('src="'),u=d[0]+' src="'+r.img_prefix+d[1];l.content=u}return l.attrSet("class","q-markdown--token  "),t(n,e,i,a,s)},n.renderer.rules.image=function(n,t,e,i,a){var s=n[t];console.log("3"),s.attrSet("class","q-markdown--image"),console.log("token--- "+t+"-----",s);var l=s.attrGet("src");return console.log(l),s.attrSet("src",r.img_prefix+l),a.renderToken(n,t,e)}}}},K=X,Z=Object(d["a"])(K,B,Q,!1,null,"9241284e",null),J=Z.exports,nn=function(){var n=this;return n.$createElement,n._self._c,n._m(0)},rn=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("pre",[n._v("\n---查看端口占用\nnetstat -ap | grep 8000\n\n---重启nginx\nsudo /usr/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\nsudo nginx -s reload\nSudo service nginx restart\nps -ef | grep nginx\n")])])}],tn={},en=tn,an=Object(d["a"])(en,nn,rn,!1,null,"4c124315",null),sn=an.exports,ln=function(){var n=this;return n.$createElement,n._self._c,n._m(0)},on=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("pre",[n._v(" "),t("code",[n._v("     \n一、查看日志和机器相关信息常用命令\n\n1、cat\ncat 命令连接文件并打印到标准输出设备上，cat经常用来显示文件的内容，类似于下的type命令\n注意：当文件较大时，文本在屏幕上迅速闪过（滚屏），用户往往看不清所显示的内容。因此，一般用more等命令分屏显示。为了控制滚屏，可以按Ctrl+S键，停止滚屏；按Ctrl+Q键可以恢复滚屏。按Ctrl+C（中断）键可以终止该命令的执行，并且返回Shell提示符状态。\n\n2、tail \n\ntail命令  用于输入文件中的尾部内容。tail命令默认在屏幕上显示指定文件的末尾10行。如果给定的文件不止一个，则在显示的每个文件前面加一个文件名标题。如果没有指定文件或者文件名为“-”，则读取标准输入。\n\n常用参数：\n\n-f<name/descriptor>或；--follow<nameldescript>：显示文件最新追加的内容。“name”表示以文件名的方式监视文件的变化。“-f”与“-fdescriptor”等效；\n-n<N>或——line=<N>：输出文件的尾部N（N位数字）行内容。\n-s<秒数>或——sleep-interal=<秒数>：与“-f”选项连用，指定监视文件变化时间隔的秒数；　　\n\n\n二、实际操作须知\n\n1、日志文件说明\n\n/var/log/message     //系统启动后的信息和错误日志，是Red Hat Linux中最常用的日志之一\n/var/log/secure      //与安全相关的日志信息\n/var/log/maillog    //与邮件相关的日志信息\n/var/log/cron       //与定时任务相关的日志信息\n/var/log/spooler    //与UUCP和news设备相关的日志信息\n/var/log/boot.log   //守护进程启动和停止相关的日志消息\n2、查看系统信息\n\n# uname -a                # 查看内核/操作系统/CPU信息\n# cat /etc/issue\n# cat /etc/redhat-release # 查看操作系统版本\n# cat /proc/cpuinfo       # 查看CPU信息\n# hostname                # 查看计算机名\n# lspci -tv               # 列出所有PCI设备\n# lsusb -tv               # 列出所有USB设备\n# lsmod                   # 列出加载的内核模块\n# env                     # 查看环境变量\n3、查看系统运行资源　　\n\n# free -m                     # 查看内存使用量和交换区使用量\n# df -h                       # 查看各分区使用情况\n# du -sh <目录名>             # 查看指定目录的大小\n# grep MemTotal /proc/meminfo # 查看内存总量\n# grep MemFree /proc/meminfo  # 查看空闲内存量\n# uptime                      # 查看系统运行时间、用户数、负载\n# cat /proc/loadavg           # 查看系统负载\n4、查看系统磁盘和分区信息\n\n# mount | column -t  # 查看挂接的分区状态\n# fdisk -l                  # 查看所有分区\n# swapon -s             # 查看所有交换分区\n# hdparm -i /dev/hda  # 查看磁盘参数(仅适用于IDE设备)\n# dmesg | grep IDE  # 查看启动时IDE设备检测状况\n5、查看网络信息　　\n\n# ifconfig        # 查看所有网络接口的属性\n# iptables -L     # 查看防火墙设置\n# route -n        # 查看路由表\n# netstat -lntp   # 查看所有监听端口\n# netstat -antp   # 查看所有已经建立的连接\n# netstat -s      # 查看网络统计信息\n6、查看进程　　\n\n# ps -ef   # 查看所有进程\n# top      # 实时显示进程状态\n7、查看用户信息\n\n# w                       # 查看活动用户\n# id <用户名>             # 查看指定用户信息\n# last                    # 查看用户登录日志\n# cut -d: -f1 /etc/passwd # 查看系统所有用户\n# cut -d: -f1 /etc/group  # 查看系统所有组\n# crontab -l              # 查看当前用户的计划任务\n8、查看服务\n\n# chkconfig –list           # 列出所有系统服务\n# chkconfig –list | grep on # 列出所有启动的系统服务\n9、查看系统安装程序　　\n\n# rpm -qa   # 查看所有安装的软件包　　\n\n\n ")]),n._v("\n")])])}],dn={},un=dn,pn=Object(d["a"])(un,ln,on,!1,null,"1e61cfb9",null),vn=pn.exports,cn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div")},mn=[],hn={},_n=hn,gn=Object(d["a"])(_n,cn,mn,!1,null,"f7c8c224",null),xn=gn.exports,bn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)])},fn=[],Ln="\r\n\r\n\r\n\r\n\x3c!--\r\n\r\n * @Date           : 2021-07-07 02:42:15\r\n * @FilePath       : /jinnian-space/src/pages/linux/md/linux-目录.md\r\n * @Description    : \r\n--\x3e\r\n\r\n\r\n| centos6 运行级别： | 作用                                  |\r\n| ---------- | ------------------------------------- |\r\n| 0          | 表示关机                              |\r\n| 1          | 单用户模式，就是Windows中的“安全模式” |\r\n| 2          | 断网状态下的多用户模式                |\r\n| 3          | 纯命令行模式（强烈推荐使用此模式）    |\r\n| 4          | 还没想好做什么用的模式（保留模式）    |\r\n| 5          | 图形用户界面（X-Window）              |\r\n| 6          | 表示重启（一开机就会重启）            |\r\n\r\n|          | LINUX有四种基本文件系统类型                                  |\r\n| -------- | ------------------------------------------------------------ |\r\n| 普通文件 | 如文本文件、C语言元代码、SHELL脚本、二进制的可执行文件等，可用cat、less、more、vi、emacs来察看内容，用mv来改名。 |\r\n| 目录文件 | 包括文件名、子目录名及其指针。它是LINUX储存文件名的唯一地方，可用ls列出目录文件。 |\r\n| 连接文   | 是指向同一索引节点的那些目录条目。用ls来查看是，连接文件的标志用l开头，而文件面后以”->”指向所连接的文件。 |\r\n| 特殊文件 | LINUX的一些设备如磁盘、终端、打印机等都在文件系统中表示出来，则一类文件就是特殊文件，常放在/dev目录内。例如，软驱A称为/dev/fd0。LINUX无C：的概念，而是用/dev/had来自第一硬盘。 |\r\n\r\n\r\n\r\n| 目录       |                      | 作用                                                         |\r\n| ---------- | -------------------- | ------------------------------------------------------------ |\r\n| bin        | user        binaries | 二进制文件的目录（就是可执行程序的目录） ,存放系统命令，普通用户和 root 都可以执行。放在 /bin 下的命令在单用户模式下也可以执行 |\r\n| boot       | boot loader files    | 系统启动时需要读取的目录 ,系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序（GRUB或LILO）文件等 |\r\n| dev        | device files         | 存放设备文件的目录（device） Linux中，设备分为两种：块设备（block）、字符设备（character）。 硬盘、软驱、光驱都属于“块设备”， 鼠标、键盘都属于“字符设备”。 |\r\n| etc        | configuration  files | 系统的配置文件（系统的信息存放在这里，比如我们的帐号以及密码）,系统内所有采用默认安装方式（rpm 安装）的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等 |\r\n| home       | home                 | 普通用户的主目录，（也称为家目录）。类似于Windows的C:\\Documents and Settings下的目录. 每个用户要有一个默认登录和保存自己数据的位置，就是用户的主目录，所有普通用户的主目录是在 /home/ 下建立一个和用户名相同的目录。如用户 liming 的主目录就是 /home/liming |\r\n| initrd     |                      | 初始化的目录，比如我们希望系统开机的时候配置一下IP           |\r\n| lib        | system libraies      | 库函数的目录（Library），类似“外挂”目录 ,系统调用的函数库保存位置 |\r\n| lib64      |                      | 作用同 lib 目录                                              |\r\n| lost+found |                      | 系统出错时，会存放一些丢失的文件在这个目录里 ，当系统意外崩溃或意外关机时，产生的一些文件碎片会存放在这里。在系统启动的过程中，fsck 工具会检查这里，并修复已经损坏的文件系统。 这个目录只在每个分区中出现，例如，/lost+found 就是根分区的备份恢复目录，/boot/lost+found 就是 /boot 分区的备份恢复目录 |\r\n| media      | removable devices    | 挂载目录。系统建议用来挂载媒体设备，如软盘和光盘 ，存放一些可删除的设备文件 ，光盘，软驱 |\r\n| misc       |                      | 挂载目录。系统建议用来挂载 NFS 服务的共享目录。虽然系统准备了三个默认挂载目录 /media/、/mnt/、/misc/，但是到底在哪个目录中挂载什么设备可以由管理员自己决定。 例如，笔者在接触 Linux 的时候，默认挂载目录只有 /mnt/，所以养成了在 /mnt/ 下建立不同目录挂载不同设备的习惯，如 /mnt/cdrom/ 挂载光盘、/mnt/usb/ 挂载 U 盘，都是可以的 |\r\n| mnt        | mount directory      | 存放一些临时需要挂载（mount）的设备 ,移动硬盘，U盘 ，挂载目录。早期 Linux 中只有这一个挂载目录，并没有细分。系统建议这个目录用来挂载额外的设备，如 U 盘、移动硬盘和其他操作系统的分区。可以参看/etc/fstab的定义。有时我们可以把让系统开机自动挂载文件系统，把挂载点放在这里也是可以的。主要看/etc/fstab中怎 么定义了；比如光驱可以挂载到/mnt/cdrom |\r\n| opt        | optional add-on Apps | 类似于windows的Programfiles目录，一般是用来安装程序的。optional（可选） 第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。不过笔者还是习惯把软件放到 /usr/local/ 目录中，也就是说，/usr/local/ 目录也可以用来安装软件。这里主要存放那些可选的程序。你想尝试最新的firefox测试版吗?那就装到/opt目录下吧，这样，当你尝试完，想删掉firefox的时候，你就可 以直接删除它，而不影响系统其他任何设置。安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。举个例子：刚才装的测试版firefox，就可以装到/opt/firefox_beta目录下，/opt/firefox_beta目录下面就包含了运 行firefox所需要的所有文件、库、数据等等。要删除firefox的时候，你只需删除/opt/firefox_beta目录即可，非常简单。 |\r\n| proc       | process  information | 虚拟文件系统。特殊目录。这里的所有文件都不是在硬盘里的，而是在内存里的。也就是这个目录的文件都是内存的真实映射。 该目录中的数据并不保存在硬盘上，而是保存到内存中。主要保存系统的内核、进程、外部设备状态和网络状态等。操作系统运行时，进程信息及内核信息（比如cpu、硬盘分区、内存信息等）存放在这里。/proc目录伪装的文件系统proc的挂载目录，proc并不是真正的文件系统，它的定义可以参见 /etc/fstab 。 如 /proc/cpuinfo 是保存 CPU 信息的，/proc/devices 是保存设备驱动的列表的，/proc/filesystems 是保存文件系统列表的，/proc/net 是保存网络协议信息的… |\r\n| root       |                      | 超级用户的主目录，也就是root的主目录，类似于C:\\Documents and Settings\\Administrator ,root 的主目录。普通用户主目录在 /home/ 下，root 主目录直接在“/”下 |\r\n| sbin       | system binaries      | 类似于bin目录。区别在于sbin目录的东西都是给superuser的，即superuser’sbin ,保存与系统环境设置相关的命令，只有 root 可以使用这些命令进行系统环境设置，但也有些命令可以允许普通用户查看。大多是涉及系统管理的命令的存放，是超级权限用户root的可执行命令存放地，普通用户无权限执行这个目录下的命令，这个目录和/usr/sbin; /usr/X11R6/sbin或/usr/local/sbin目录是相似的；我们记住就行了，凡是目录sbin中包含的都是root权限才能执行的。 |\r\n| selinux    |                      | SecureLinux关于安全策略的配置                                |\r\n| srv        | service data         | 服务需要取的数据目录 ,服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据 |\r\n| sys        |                      | 虚拟文件系统。和 proc 目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息.同样不占硬盘空间 |\r\n| tmp        |                      | 临时目录temporary 。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。建议此目录中不能保存重要数据，最好每次开机都把该目录清理 |\r\n| usr        | user programs        | 类似于前面的opt目录，但是存放在这个地方的软件都是很重要的。相当于windows里C:\\WINDOWS和C:\\Program Files的综合体。Usr=Unix Software Resource. 在这个目录下，你可以找到那些不适合放在/bin或/etc目录下的额外的工具。比如像游戏阿，一些打印工具拉等等。/usr目录包含了许多子目录： /usr/bin目录用于存放程序;/usr/share用于存放一些共享的数据，比如音乐文件或者图标等等;/usr/lib目录用于存放那些不能直接 运行的，但却是许多程序运行所必需的一些函数库文件。你的软件包管理器(应该是“yum”吧)会自动帮你管理好/usr目录的。 |\r\n| usr/local  |                      | 这里主要存放那些手动安装的软件，即不是通过“yum”或apt-get安装的软件。它和/usr目录具有相类似的目录结构。让软件包管理器来管理/usr目录，而把自定义的脚本(scripts)放到/usr/local目录下面。一般是通过源码包安装的软件，如果没有特别指定安装目录的话，一般是安装在这个目录中。 |\r\n| usr/share  |                      | 系统共用的东西存放地，比如 /usr/share/fonts 是字体目录，/usr/share/doc和/usr/share/man帮助文件。 |\r\n| var        | variable files       | 常态性变动的文件，比如缓存、mysql文件、mail的数据 ，系统日志等 |\r\n| var/log    |                      | 系统日志存放，分析日志要看这个目录的东西                     |\r\n| var/spool  |                      | 打印机、邮件、代理服务器等假脱机目录；                       |\r\n\r\n",wn={data:function(){return{MainComponent:Ln}}},yn=wn,kn=Object(d["a"])(yn,bn,fn,!1,null,"60e64c33",null),Sn=kn.exports,$n=function(){var n=this;return n.$createElement,n._self._c,n._m(0)},jn=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",{staticClass:"text-h3"},[n._v("Linux Web运维（Nginx）")]),t("pre",[n._v("    1、添加源\n\n默认情况Centos7中无Nginx的源，最近发现Nginx官网提供了Centos的源地址。因此可以如下执行命令添加源：\n\nsudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm\n\n2、安装Nginx\n\n通过yum search nginx看看是否已经添加源成功。如果成功则执行下列命令安装Nginx。\n\nsudo yum install -y nginx\n\n3、启动Nginx并设置开机自动运行\n\nsudo systemctl start nginx.service\nsudo systemctl enable nginx.service\n \n\n4.建立软连接 快捷启动方式  根据实际的路径 建立\n ln -s /usr/local/nginx/sbin/nginx   /usr/local/sbin/\n \nnginx 配置文件 健康检查  语法检查\nnginx -t\n\n重启服务 \nservice nginx restart\n\n")])])}],zn={},Mn=zn,Cn=Object(d["a"])(Mn,$n,jn,!1,null,"199827d2",null),Pn=Cn.exports,Rn=function(){var n=this;return n.$createElement,n._self._c,n._m(0)},En=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",{staticClass:"text-h3"},[n._v("Nginx配置文件详解")]),t("pre",[n._v('  \n—————————————————————————————\n1\n\nNginx 配置文件详解\nuser www www;\n#程序运行用户和组\nworker_processes auto;\n#启动进程，指定 nginx 启动的工作进程数量，建议按照 cpu 数目来指定，一般等于 cpu 核心数目\nerror_log /home/wwwlogs/nginx_error.log crit;\n#全局错误日志\npid /usr/local/nginx/logs/nginx.pid;\n#主进程 PID 保存文件\nworker_rlimit_nofile 51200;\n#文件描述符数量\nevents \n    {\n    use epoll; \n    #使用 epoll 模型，对于 2.6 以上的内核，建议使用 epoll 模型以提高性能\n    worker_connections 51200;\n    #工作进程的最大连接数量，根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把 cpu\n    跑到 100%就行每个进程允许的最多连接数， 理论上每台 nginx 服务器的最大连接数为\n    worker_processes*worker_connections，具体还要看服务器的硬件、带宽等。\n    }\nhttp \n    #整体环境配置--网站配置\n    {\n    include mime.types;\n    default_type application/octet-stream;\n    #设定 mime 类型,文件传送类型由 mime.type 文件定义\n    server_names_hash_bucket_size 128;\n    #保存服务器名字的 hash 表大小\n    client_header_buffer_size 32k;\n    #客户端请求头部缓冲区大小\n    large_client_header_buffers 4 32k;\n    #最大客户端头缓冲大小\n    \n    \n    client_max_body_size 50m;\n    #客户端最大上传文件大小（M）\n    sendfile on;\n    #sendfile 指令指定 nginx 是否调用 sendfile 函数来输出文件，对于普通应用，必须设\n    为 on。如果用来进行下载等应用磁盘 IO 重负载应用，可设置为 off，以平衡磁盘与网络 I/O 处理速度，\n    降低系统的 uptime.\n    tcp_nopush on;\n    #这个是默认的，结果就是数据包不会马上传送出去，等到数据包最大时，一次性的传\n    输出去，这样有助于解决网络堵塞。（只在 sendfile on 时有效）\n    keepalive_timeout 60;\n    #连接超时时间\n    tcp_nodelay on;\n    #禁用 nagle 算法，也即不缓存数据。有效解决网络阻塞\n    fastcgi_connect_timeout 300;\n    fastcgi_send_timeout 300;\n    fastcgi_read_timeout 300;\n    fastcgi_buffer_size 64k;\n    fastcgi_buffers 4 64k;\n    fastcgi_busy_buffers_size 128k;\n    fastcgi_temp_file_write_size 256k;\n    #fastcgi 设置\n    gzip on;\n    gzip_min_length 1k;\n    gzip_buffers 4 16k;\n    gzip_http_version 1.1;\n    gzip_comp_level 2;\n    gzip_types text/plain application/javascript application/x-javascript text/javascript \n    text/css application/xml application xml+rss;\n    gzip_vary on;\n    gzip_proxied expired no-cache no-store private auth;\n    gzip_disable "MSIE [1-6]\\.";\n    #limit_conn_zone $binary_remote_addr zone=perip:10m;\n    ##If enable limit_conn_zone,add "limit_conn perip 10;" to server section.\n    server_tokens off;\n    #隐藏 nginx 版本号（curl -I 192.168.4.154 可以查看，更加安全）\n    #log format\n    \n    \n\n    log_format access \'$remote_addr - $remote_user [$time_local] "$request"\'\n    \'$status $body_bytes_sent "$http_referer" \'\n    \'"$http_user_agent" $http_x_forwarded_for\';\n    #定义日志格式\n    server\n        {\n        listen 80 default_server;\n        #listen [::]:80 default_server ipv6only=on;\n        #监听 80 端口，WEB 服务的监听设置，可以采用"IP 地址:端口"形式\n        server_name www.lnmp.org lnmp.org;\n        #服务器名，可以写多个域名，用空格分隔\n        index index.html index.htm index.php;\n        #默认网页文件\n        root /home/wwwroot/default;\n        #网页主目录\n        #error_page 404 /404.html;\n        include enable-php.conf;\n        \n        location /nginx_status\n        {\n        stub_status on;\n        access_log off;\n        } #开启 status 状态监测\n        location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$\n        {\n        expires 30d;\n        } #静态文件处理，保存期 30 天\n        location ~ .*\\.(js|css)?$\n        {\n        expires 12h;\n        }\n        #js 和 css 文件处理，保存期 12 小时\n        location ~ /\\.\n        {\n        deny all;\n        }\n        access_log /home/wwwlogs/access.log access;\n        \n \n\n        #正确访问日志\n    }\n    include vhost/*.conf;\n    #vhost/下子配置文件生效\n}\n\n')])])}],Dn={},Un=Dn,Nn=Object(d["a"])(Un,Rn,En,!1,null,"aa01b01e",null),In=Nn.exports,An=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}})],1)},Wn=[],Hn="\x3c!--\r\n * @Date           : 2021-07-15 00:12:03\r\n * @FilePath       : /jinnian-space/src/pages/linux/md/linux-yum+LAMP开源部署.md\r\n * @Description    : \r\n--\x3e\r\n\r\n# YUM+LAMP开源部署 Discuz 论坛\r\n\r\n# YUM\r\n\r\n## 1、什么是YUM\r\n\r\n在CentOS系统中，软件管理方式通常有三种方式：`rpm安装`、`yum安装`以及`编译安装`。\r\n\r\n```powershell\r\n编译安装，从过程上来讲比较麻烦，包需要用户自行下载，下载的是源码包，需要进行编译操作，编译好了才能进行安装，这个过程对于刚接触Linux的人来说比较麻烦，而且还容易出错。好处在于是源码包，对于有需要自定义模块的用户来说非常方便。(就业班会着重讲解)\r\n```\r\n\r\n难度：编译安装 > rpm安装 > yum安装（有网络 + yum源支持）\r\n\r\nYum（全称为 `Yellow dog Updater, Modified`）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。\r\n\r\n基于rpm包管理，能够从**指定的服务器**(yum源）自动下载RPM包并且安装，可以==自动处理依赖性关系==，并且==一次安装所有依赖的软件包==，无须繁琐地一次次下载、安装。\r\n\r\n> rpm和yum区别？答：① yum底层也是基于rpm进行安装的（yum安装的软件，可以通过rpm -qa进行查询） ② yum相对于rpm最大的优势，可以解决依赖关系。\r\n>\r\n> A => B => C\r\n\r\n## 2、YUM源配置\r\n\r\n![image-20200326115612781](media/image-20200326115612781.png)\r\n\r\nYUM源配置文件所在路径 => /etc/yum.repos.d文件夹\r\n\r\n-rw-r--r--. 1 root root 1991 Mar 28  2017 CentOS-Base.repo            网络yum源配置文件\r\n-rw-r--r--. 1 root root  647 Mar 28  2017 CentOS-Debuginfo.repo    内核相关的更新包\r\n-rw-r--r--. 1 root root  289 Mar 28  2017 CentOS-fasttrack.repo       快速通道\r\n-rw-r--r--. 1 root root  630 Mar 28  2017 CentOS-Media.repo           本地yum源配置文件\r\n-rw-r--r--. 1 root root 7989 Mar 28  2017 CentOS-Vault.repo          最近版本加入老本的YUM配置   \r\n\r\n扩展：在YUM镜像源中添加阿里云镜像源\r\n\r\n```powershell\r\n第一步：备份CentOS-Base.repo这个源（更改后缀名.repo => .repo.bak）\r\n# mv CentOS-Base.repo CentOS-Base.repo.bak\r\n\r\n第二步：使用wget命令下载阿里云的镜像文件\r\n# wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo\r\n\r\n选项说明：\r\n-O ：指定文件下载的位置以及名称\r\n第三步：清理YUM缓存\r\n# yum clean all\r\n\r\n第四步：重新建立缓存（让新YUM源生效）\r\n# yum makecache\r\n```\r\n\r\n## 3、yum命令详解\r\n\r\n### ☆ 搜索要安装的软件\r\n\r\n```powershell\r\n# yum search 软件名称的关键词\r\n```\r\n\r\n案例：搜索阿里云仓库中的vim软件\r\n\r\n```powershell\r\n# yum search vim\r\n```\r\n\r\n案例：搜索firefox火狐浏览器\r\n\r\n```powershell\r\n# yum search firefox\r\n```\r\n\r\n### ☆ 使用yum安装软件\r\n\r\n基本语法：\r\n\r\n```powershell\r\n# yum install 软件名称关键词 [选项]\r\n选项：\r\n-y ：yes缩写，确认安装，不提示。\r\n```\r\n\r\n案例：使用yum命令安装vim编辑器\r\n\r\n```powershell\r\n# yum install vim -y\r\n```\r\n\r\n案例：使用yum命令安装firefox浏览器\r\n\r\n```powershell\r\n# yum install firefox -y\r\n```\r\n\r\n### ☆ 使用yum卸载软件\r\n\r\n```powershell\r\n# yum remove 软件名称关键词 [选项]\r\n选项：\r\n-y ：yes缩写，确认卸载，不提示。\r\n```\r\n\r\n案例：把firefox火狐浏览器进行卸载操作\r\n\r\n```powershell\r\n# yum remove firefox -y\r\n```\r\n\r\n案例：把httpd软件进行强制卸载\r\n\r\n```powershell\r\n# yum remove httpd -y\r\n```\r\n\r\n### ☆ 使用yum更新软件\r\n\r\n基本语法：\r\n\r\n```powershell\r\n# yum update 软件名称关键词 [选项]\r\n选项：\r\n-y ：yes缩写，确认更新，不提示\r\n```\r\n\r\n案例：把vim编辑器进行更新操作\r\n\r\n```powershell\r\n# yum update vim -y\r\n```\r\n\r\n案例：把firefox火狐浏览器进行更新操作\r\n\r\n```powershell\r\n# yum update firefox -y\r\n```\r\n\r\n# 三、LAMP概述\r\n\r\n## 1、什么是LAMP\r\n\r\nLAMP：==L==inux + ==A==pache + ==M==ySQL + ==P==HP                        LAMP 架构（组合）\r\n\r\nLNMP：Linux + Nginx + MySQL + php-fpm                             LNMP 架构（组合）\r\n\r\nLNMPA：Linux + Nginx(80) + MySQL + PHP + Apache           Nginx 代理方式\r\n\r\n![image-20200326152052773](media/image-20200326152052773.png)\r\n\r\nApache：Apache是世界使用排名第一的Web服务器软件。\r\n\r\nPHP：一种专门用于Web开发的编程语言。\r\n\r\nMySQL：MySQL是一个关系型数据库管理系统，主要用于永久存储项目数据。\r\n\r\n## 2、AMP三者之间的关系\r\n\r\n![image-20200326152231295](media/image-20200326152231295.png)\r\n\r\nApache：用于接收用户的请求（输入网址，返回网页=>结果）\r\n\r\nPHP：注册、登录、加入购物车、下单、支付等动态功能（有编程语言的支持）\r\n\r\nMySQL：永久保存数据，比如你在网站上注册的用户和密码、你加入购物车的产品、你的产品订单\r\n\r\nLAMP = Linux + APache + PHP + MySQL\r\n\r\n# 四、阿里云详解\r\n\r\n要想部署一个互联网上可以访问到的环境，必须先具备以下内容 ：\r\n\r\n服务器（IP、帐号密码、终端）、相应的软件、域名（备案、解析）、代码等。\r\n\r\n![image-20200326154214921](media/image-20200326154214921.png)\r\n\r\n代码：前端工程师 + 后端工程师进行开发提供的！\r\n\r\n## 1、注册阿里云账号\r\n\r\n阿里云官网：https://www.aliyun.com/\r\n\r\n![image-20200326154527903](media/image-20200326154527903.png)\r\n\r\n> 特别说明：云服务器的厂商特别多，你可以进行任意选择 => 阿里云、百度云、腾讯云、华为云...\r\n\r\n注册时建议使用支付宝，方便快捷。最重要：付款方便\r\n\r\n## 2、实名认证（上传身份证照片）\r\n\r\n第一步：单击账号下方的实名认证（选择个人认证）\r\n\r\n![image-20200326155133047](media/image-20200326155133047.png)\r\n\r\n![image-20200326155146301](media/image-20200326155146301.png)\r\n\r\n第二步：选择支付宝授权认证（及时开通，无需等待）\r\n\r\n![image-20200326155223066](media/image-20200326155223066.png)\r\n\r\n第三步：勾选同意，点击提交\r\n\r\n![image-20200326155308208](media/image-20200326155308208.png)\r\n\r\n第四步：使用手机支付宝扫描二维码，进行授权\r\n\r\n![image-20200326155339781](media/image-20200326155339781.png)\r\n\r\n第五步：填写相关信息（住址）\r\n\r\n![image-20200326155358292](media/image-20200326155358292.png)\r\n\r\n填写完毕，即可完成认证。\r\n\r\n![image-20200326155428202](media/image-20200326155428202.png)\r\n\r\n## 3、购买阿里云的ECS云服务器\r\n\r\n第一步：回到阿里云首页，找到弹性计算 => ECS云服务器\r\n\r\n![image-20200326161759062](media/image-20200326161759062.png)\r\n\r\n第二步：单击立即购买，购买ECS服务器（选区域、选配置）\r\n\r\n![image-20200326161916781](media/image-20200326161916781.png)\r\n\r\n第三步：选择付费模式、选择CPU与内存的配置\r\n\r\n![image-20200326162659403](media/image-20200326162659403.png)\r\n\r\n第四步：选择镜像（CentOS7.6）与云盘（硬盘）\r\n\r\n![image-20200326162845467](media/image-20200326162845467.png)\r\n\r\n第四步：设置网络、公网IP以及安全组（重要）\r\n\r\n![image-20200326163143681](media/image-20200326163143681.png)\r\n\r\n> 用户 =>  阿里云安全组  =>  firewalld防火墙  => Linux服务器\r\n\r\n第五步：设置root账号密码（一定要选择自定义密码）\r\n\r\n![image-20200326163533492](media/image-20200326163533492.png)\r\n\r\n> 8 - 30 个字符，必须同时包含三项（大写字母、小写字母、数字、 ()`~!@#$%^&*_-+=|{}[]:;'<>,.?/ 中的特殊符号），其中 Windows 实例不能以斜线号（/）为首字符\r\n\r\n第六步：设置释放时间 => 什么时候删除这台服务器（不收钱）\r\n\r\n![image-20200326163830484](media/image-20200326163830484.png)\r\n\r\n> 特别说明：只有个人购买的ECS服务器可以设置释放时间，生产环境一定不要设置释放时间，否则后果自负！！！\r\n\r\n第七步：进入管理控制台，找到我们刚才购买的ECS服务器，如下图所示：\r\n\r\n![image-20200326164148544](media/image-20200326164148544.png)\r\n\r\n> 使用MX软件，直接连接公网IP + root账号 + 自定义的密码即可连接\r\n\r\n## 4、使用MX连接ECS服务器\r\n\r\n![image-20200326164519379](media/image-20200326164519379.png)\r\n\r\n## 5、使用yum安装sl小工具\r\n\r\n安装过程：\r\n\r\n```powershell\r\n# yum install sl -y\r\n```\r\n\r\n使用sl命令：\r\n\r\n```powershell\r\n# sl\r\n```\r\n\r\n# LAMP项目部署实战\r\n\r\n# 一、LAMP环境部署\r\n\r\n## 1、回顾LAMP\r\n\r\nLAMP = Linux + Apache + MySQL + PHP\r\n\r\n![image-20200327093726255](media/image-20200327093726255.png)\r\n\r\nApache：主要用于接收用户的请求，处理业务逻辑，返回结果给客户端（浏览器）\r\n\r\nPHP：编程语言的一种，主要应用于Web开发。主要实现注册、登录、加入购物车、下单、支付等功能\r\n\r\nMySQL：数据库，删库到跑路，这里的\"库\"就是指数据库。永久保存数据\r\n\r\n## 2、LAMP部署前期准备\r\n\r\n### ☆ 关闭防火墙\r\n\r\n```powershell\r\n# systemctl stop firewalld\r\n# systemctl disable firewalld\r\n```\r\n\r\n### ☆ 关闭SELinux\r\n\r\n*SELinux*(Security-Enhanced Linux) 是美国国家安全局（NSA）对于强制访问控制的实现，是 Linux历史上最杰出的新安全子系统。\r\n\r\n获取SELinux的状态：\r\n\r\n```powershell\r\n# getenforce\r\n```\r\n\r\n临时关闭SElinux：重启后SELinux还会自动启动\r\n\r\n```powershell\r\n# setenforce 0\r\n```\r\n\r\n永久关闭SELinux：编辑SELinux的配置文件\r\n\r\n```powershell\r\n# vim /etc/selinux/config\r\nSELINUX=disabled\r\n```\r\n\r\n### ☆ 检查系统中是否已安装Apache\r\n\r\n```powershell\r\n# rpm -qa |grep httpd\r\n\r\n# rpm -e httpd-2.4.6-90.el7.centos.x86_64\r\n# rpm -e httpd-tools-2.4.6-90.el7.centos.x86_64\r\n```\r\n\r\n### ☆ 检查系统中是否已安装MySQL\r\n\r\n```powershell\r\n# rpm -qa |grep mysql\r\n```\r\n\r\n### ☆ 检查系统中是否已安装PHP\r\n\r\n```powershell\r\n# rpm -qa |grep php\r\n```\r\n\r\n> AMP安装指南：在Linux中安装AMP必须先安装Apache，在安装MySQL，最后安装PHP\r\n\r\n## 3、LAMP环境之Apache安装\r\n\r\nApache：阿帕奇，Apache基金会\r\n\r\nhttpd软件 => 前身apache，随着时间的推移以及互联网行业的发展，越来越多的软件加入到了Apache的基金会。\r\n\r\n第一步：安装httpd软件\r\n\r\n```powershell\r\n# yum install httpd -y\r\n```\r\n\r\n第二步：配置/etc/httpd/conf/httpd.conf文件\r\n\r\n```powershell\r\n# vim /etc/httpd/conf/httpd.conf\r\n/ServerName => 搜索\r\n96 ServerName localhost:80\r\n```\r\n\r\n> localhost ： 代表本机，对应的IP地址可以使127.0.0.1或本机的公网IP\r\n\r\n第三步：启动httpd服务\r\n\r\n```powershell\r\n# systemctl start httpd\r\n```\r\n\r\n第四步：把httpd服务添加到开机启动项中\r\n\r\n```powershell\r\n# systemctl enable httpd\r\n```\r\n\r\n第五步：使用ss或netstat命令查询httpd占用的端口\r\n\r\n```powershell\r\n# netstat -tnlp |grep httpd\r\n或\r\n# ss -naltp |grep httpd\r\n```\r\n\r\n第六步：在浏览器中，使用公网IP访问阿里云服务器\r\n\r\n![image-20200327104156113](media/image-20200327104156113.png)\r\n\r\n## 4、LAMP环境之MySQL安装\r\n\r\n### ☆ 下载MySQL的官网yum源\r\n\r\n由于yum源上默认没有mysql-server。所以必须去官网下载后在安装\r\n\r\n```powershell\r\n# wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm\r\n```\r\n\r\n### ☆ 安装MySQL的官网镜像源\r\n\r\n```powershell\r\n# rpm -ivh mysql-community-release-el7-5.noarch.rpm\r\n```\r\n\r\n### ☆ 使用yum安装mysql最新版软件\r\n\r\n```powershell\r\n# yum install mysql-community-server -y\r\n```\r\n\r\n> MySQL软件是一个C/S架构的软件，拥有客户端与服务器端。mysql-server服务器端（内部也包含了客户端），community代表社区版（免费开源）\r\n\r\n### ☆ 启动mysql，查看端口占用情况\r\n\r\n```powershell\r\n# systemctl start mysqld\r\n# netstat -tnlp |grep mysqld\r\n```\r\n\r\n### ☆ MySQL数据库初始化（重要）\r\n\r\n默认情况下，数据库没有密码，也没有任何数据，必须要初始化\r\n\r\n#### ① 初始化数据，设置root密码（MySQL管理员）\r\n\r\n```powershell\r\n# mysql_secure_installation\r\n```\r\n\r\n![image-20200327114309107](media/image-20200327114309107.png)\r\n\r\n> 扩展：以上说的root和Linux中的root不是同一个用户，这个root代表MySQL数据库的管理员，只不过这个管理员也叫root。\r\n\r\n![image-20200327114444955](media/image-20200327114444955.png)\r\n\r\n![image-20200327114530976](media/image-20200327114530976.png)\r\n\r\n> 学习环境下，密码越简单越好。生产环境下越复杂越好。\r\n\r\n![image-20200327114717525](media/image-20200327114717525.png)\r\n\r\n![image-20200327114820459](media/image-20200327114820459.png)\r\n\r\n![image-20200327114907975](media/image-20200327114907975.png)\r\n\r\n![image-20200327114951007](media/image-20200327114951007.png)\r\n\r\n#### ② 把mysqld服务添加到开机启动项\r\n\r\n```powershell\r\n# systemctl enable mysqld\r\n```\r\n\r\n默认已经开机启动，这里可以跳过\r\n\r\n#### ③ 连接MySQL数据库，测试\r\n\r\n```powershell\r\n# mysql -u root -p 回车\r\nEnter password:输入刚才设置的密码，如123，回车\r\nmysql> show databases;    =>   代表显示所有数据库\r\nmysql> exit\r\n```\r\n\r\n## 5、LAMP环境之PHP安装\r\n\r\n### ☆ 使用yum命令安装php软件\r\n\r\n```powershell\r\n# yum install php -y\r\n```\r\n\r\n### ☆ 使用systemctl启动php软件（重启Apache）\r\n\r\n```powershell\r\n# systemctl restart httpd\r\n```\r\n\r\n> 为什么启动php就是重启Apache呢？答：因为LAMP架构中，PHP是以模块的形式追加到Apache的内核中，所以启动php就相当于重置Apache软件\r\n\r\n![image-20200327142246747](media/image-20200327142246747.png)\r\n\r\n### ☆ 测试LAMP环境是否可以使用\r\n\r\n第一步：使用cd命令进入/var/www/html目录\r\n\r\n```powershell\r\n# cd /var/www/html\r\nApache的项目目录 => /var/www/html，以后程序员开发的代码都是放置于此目录\r\n```\r\n\r\n第二步：使用vim命令创建demo.php文件\r\n\r\n```powershell\r\n# vim demo.php\r\n```\r\n\r\n第三步：编写php代码\r\n\r\n```php\r\n<?php\r\n\techo 'hello world';\r\n?>\r\n```\r\n\r\n编写完成后，保存退出，然后在浏览器中使用http://公网IP/demo.php\r\n\r\n![image-20200327142839268](media/image-20200327142839268.png)\r\n\r\n# 二、部署Discuz!论坛\r\n\r\n## 1、Discuz!论坛概述\r\n\r\nDiscuz！论坛是基于PHP + MySQL进行开发的一套开源的论坛系统。\r\n\r\n![image-20200327151556113](media/image-20200327151556113.png)\r\n\r\n## 2、下载源代码\r\n\r\n下载地址：https://gitee.com/ComsenzDiscuz/DiscuzX  （码云）\r\n\r\n![image-20200327151754516](media/image-20200327151754516.png)\r\n\r\n## 3、使用MX软件把Discuz源代码上传\r\n\r\n阿里云：\r\n\r\n![image-20200327152029513](media/image-20200327152029513.png)\r\n\r\n本地Linux类似\r\n\r\n## 4、安装unzip解压缩软件\r\n\r\n```powershell\r\n# yum install unzip -y\r\n```\r\n\r\n## 5、使用unzip对discuz.zip压缩包进行解压\r\n\r\n```powershell\r\n# unzip discuz.zip\r\n```\r\n\r\n## 6、复制discuz中的文件到/var/www/html目录\r\n\r\n```powershell\r\n# mv discuz/* /var/www/html/\r\n或\r\n# cp -vRp disczu/* /var/www/html/\r\n```\r\n\r\n## 7、打开浏览器，输入公网IP地址\r\n\r\n![image-20200327153135696](media/image-20200327153135696.png)\r\n\r\n## 8、单击同意许可，继续安装\r\n\r\n![image-20200327154443886](media/image-20200327154443886.png)\r\n\r\n## 9、给/var/www/html目录设置可写权限\r\n\r\n```powershell\r\n# chmod -R a+w /var/www/html\r\n```\r\n\r\n> 注意：以上操作是给所有文件添加一个w权限，但是生产环境尽量针对指定文件添加权限。\r\n\r\n## 10、解决PHP扩展问题\r\n\r\n![image-20200327154906078](media/image-20200327154906078.png)\r\n\r\n以上提示代表，安装PHP时没有安装php-mysqli扩展，所以会出现以上问题。\r\n\r\n```powershell\r\n# yum install php-mysqli -y\r\n# systemctl restart httpd\r\n```\r\n\r\n## 11、设置运行环境\r\n\r\n![image-20200327155142197](media/image-20200327155142197.png)\r\n\r\n## 12、设置MySQL数据库的相关信息\r\n\r\n![image-20200327155441330](media/image-20200327155441330.png)\r\n\r\n## 13、设置管理员账号和密码\r\n\r\n![image-20200327155536618](media/image-20200327155536618.png)\r\n\r\n## 14、安装完成后，访问论坛首页\r\n\r\n![image-20200327155648008](media/image-20200327155648008.png)\r\n\r\n部署后，访问论坛首页，如下图所示：\r\n\r\n![image-20200327155712092](media/image-20200327155712092.png)\r\n\r\n# 三、域名与解析\r\n\r\n## 1、为什么需要域名\r\n\r\n我们现在访问论坛是通过IP地址实现的，但是IP地址比较复杂，更重要的是不方便用户记忆。\r\n\r\n域名 => 代替公网IP地址\r\n\r\n## 2、购买域名\r\n\r\n![image-20200327162641419](media/image-20200327162641419.png)\r\n\r\n登录控制台，然后选择域名菜单：\r\n\r\n![image-20200327162742162](media/image-20200327162742162.png)\r\n\r\n找到域名注册菜单：\r\n\r\n![image-20200327162831242](media/image-20200327162831242.png)\r\n\r\n找到想要注册的域名，然后加入清单，然后进行立即结算：\r\n\r\n![image-20200327163458795](media/image-20200327163458795.png)\r\n\r\n购买完成后，进入域名控制台：\r\n\r\n![image-20200327163713347](media/image-20200327163713347.png)\r\n\r\n## 3、把域名解析到公网IP\r\n\r\n![image-20200327163913091](media/image-20200327163913091.png)\r\n\r\n进入解析菜单，然后添加记录：\r\n\r\n![image-20200327164010354](media/image-20200327164010354.png)\r\n\r\n① 把www.itcast.top解析到公网IP\r\n\r\n![image-20200327164144887](media/image-20200327164144887.png)\r\n\r\n② 把itcast.top解析到公网IP\r\n\r\n![image-20200327164318781](media/image-20200327164318781.png)\r\n\r\n以上记录添加完成后，等待10分钟左右，即可使用域名访问论坛项目了！\r\n\r\n## 4、域名备案\r\n\r\n如果在国内运行项目，我们使用的域名必须要进行备案操作。\r\n\r\n备案就是向工信部提交网站运行的相关资料，比如域名的证书、持有者的身份证号码，以及真人手持身份证照片（背景图）\r\n\r\n由于现在监管比较严格，提交资料后，大概5-7个工作日进行审核，完全备案完成大概2周左右。\r\n\r\n> https://beian.aliyun.com/\r\n\r\n\r\n\r\n如果不想进行域名备案，可以购买中国香港、中国台湾以及国外的服务器，可以免备案。但是其运行速度略慢一些。",On={data:function(){return{MainComponent:Hn,img_prefix:"./img/linux/heima-Linux云计算/YUM+LAMP开源部署/"}},methods:{extendMarkdown:function(n){var r=this;console.log(n.renderer.rules);var t=n.renderer.rules.html_block;n.renderer.rules.html_block=function(n,e,i,a,s){var l=n[e];if(console.log("1"),l.content.includes("<img")){console.log("token-- ",l);var o="";o=l.content;var d=o.split('src="'),u=d[0]+' src="'+r.img_prefix+d[1];l.content=u}return l.attrSet("class","q-markdown--token  "),t(n,e,i,a,s)},n.renderer.rules.image=function(n,t,e,i,a){var s=n[t];console.log("3"),s.attrSet("class","q-markdown--image"),console.log("token--- "+t+"-----",s);var l=s.attrGet("src");return console.log(l),s.attrSet("src",r.img_prefix+l),a.renderToken(n,t,e)}}}},Tn=On,qn=Object(d["a"])(Tn,An,Wn,!1,null,"59ab09ee",null),Gn=qn.exports,Yn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("m2")],1)},Fn=[],Bn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",{staticClass:"row  "},[t("q-select",{attrs:{"use-input":"","input-debounce":"0",clearable:"",options:n.book_options},on:{filter:n.filterFn},model:{value:n.book,callback:function(r){n.book=r},expression:"book"}},[t("template",{slot:"before"},[t("div")])],2)],1),t("div",{staticClass:"q-pdfviewer-container  "},[t("q-pdfviewer",{attrs:{src:n.src,type:"html5","content-class":" fit   q-pdfviewer-container","inner-content-class":" fit   q-pdfviewer-container"},model:{value:n.show,callback:function(r){n.show=r},expression:"show"}})],1)])},Qn=[],Vn=["第1阶段-运维基本功/day01/第1阶段-运维基本功（升级7.6版本）day01课堂讲义.pdf","第1阶段-运维基本功/day01/课堂讲义.pdf","第1阶段-运维基本功/day01/讲义/01运维概述与Linux系统安装.pdf","第1阶段-运维基本功/day02/课堂笔记.pdf","第1阶段-运维基本功/day02/讲义/02Linux基础命令.pdf","第1阶段-运维基本功/day03/课堂笔记.pdf","第1阶段-运维基本功/day03/讲义/03Linux文件管理(上).pdf","第1阶段-运维基本功/day04/课堂笔记.pdf","第1阶段-运维基本功/day05/课堂笔记.pdf","第1阶段-运维基本功/day05/讲义/上/03Linux文件管理(下).pdf","第1阶段-运维基本功/day06/课堂笔记.pdf","第1阶段-运维基本功/day06/讲义/04用户管理.pdf","第1阶段-运维基本功/day07/课堂笔记.pdf","第1阶段-运维基本功/day07/讲义/05权限管理.pdf","第1阶段-运维基本功/day08/课堂笔记.pdf","第1阶段-运维基本功/day09/课堂笔记.pdf","第1阶段-运维基本功/day09/讲义/上/06自有服务及软件包.pdf","第1阶段-运维基本功/day10/课堂笔记.pdf","第1阶段-运维基本功/day10/讲义/07进程检测与控制.pdf","第1阶段-运维基本功/day11/课堂笔记.pdf","第1阶段-运维基本功/day12/课堂笔记.pdf","第1阶段-运维基本功/day12/讲义/08YUM与开源项目实战.pdf","第2阶段-运维系统服务/第二阶段网络基础/计算机网络设备.pdf","第2阶段-运维系统服务/第二阶段网络基础/网络基础1.pdf","第2阶段-运维系统服务/第二阶段网络基础/网络基础2.pdf","第2阶段-运维系统服务/第二阶段网络基础/网络基础3.pdf","第2阶段-运维系统服务/01_磁盘管理.pdf","第2阶段-运维系统服务/02_磁盘阵列之RAID.pdf","第2阶段-运维系统服务/系统服务/day01/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day01/讲义/01_Linux高级命令.pdf","第2阶段-运维系统服务/系统服务/day01/讲义/02_Linux下用户组管理.pdf","第2阶段-运维系统服务/系统服务/day01/讲义/03_Linux下文件权限管理.pdf","第2阶段-运维系统服务/系统服务/day01/讲义/04_Linux下软件包管理.pdf","第2阶段-运维系统服务/系统服务/day02/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day02/讲义/02_Linux下用户组管理.pdf","第2阶段-运维系统服务/系统服务/day02/讲义/03_Linux下文件权限管理.pdf","第2阶段-运维系统服务/系统服务/day03/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day03/讲义/03_Linux下文件权限管理.pdf","第2阶段-运维系统服务/系统服务/day04/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day04/讲义/Linux下yum源配置实战.pdf","第2阶段-运维系统服务/系统服务/day05/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day05/讲义/远程管理SSH服务.pdf","第2阶段-运维系统服务/系统服务/day06/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day06/讲义/01-远程管理SSH服务免密登录解决方案.pdf","第2阶段-运维系统服务/系统服务/day07/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day07/讲义/02-Linux下数据同步RSYNC.pdf","第2阶段-运维系统服务/系统服务/day08/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day08/讲义/02-文件共享服务之FTP.pdf","第2阶段-运维系统服务/系统服务/day09/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day09/讲义/文件共享服务之NFS_SMB.pdf","第2阶段-运维系统服务/系统服务/day10/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day10/讲义/域名管理系统之DNS.pdf","第2阶段-运维系统服务/系统服务/day11/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day11/讲义/源码构建LAMP环境.pdf","第2阶段-运维系统服务/01_SHELL编程前奏_小工具.pdf","第2阶段-运维系统服务/07SSH服务(打卡).pdf","第2阶段-运维系统服务/navicat.pdf","第2阶段-运维系统服务/Percona-XtraBackup-2.4.7-2.pdf","第2阶段-运维系统服务/Percona-XtraDB-Cluster-5.7.18-29.20.pdf","第2阶段-运维系统服务/mysql-dba/day01/讲义/01_MySQL介绍及安装.pdf","第2阶段-运维系统服务/mysql-dba/day02/课堂笔记.pdf","第2阶段-运维系统服务/mysql-dba/day02/讲义/02_MySQL体系结构及数据文件介绍.pdf","第2阶段-运维系统服务/mysql-dba/day02/讲义/03_MySQL基本SQL语句讲解.pdf","第2阶段-运维系统服务/mysql-dba/day03/课堂笔记.pdf","第2阶段-运维系统服务/mysql-dba/day04/讲义/04_MySQL备份与恢复.pdf","第2阶段-运维系统服务/mysql-dba/day05/课堂笔记.pdf","第2阶段-运维系统服务/mysql-dba/day05/讲义/04_MySQL备份与恢复.pdf","第2阶段-运维系统服务/mysql-dba/day06/课堂笔记.pdf","第2阶段-运维系统服务/mysql-dba/day06/讲义/05_MySQL主从复制架构.pdf","第2阶段-运维系统服务/mysql-dba/day07/课堂笔记.pdf","第2阶段-运维系统服务/mysql-dba/day07/讲义/06_MySQL数据库高可用解决方案(MHA).pdf","第2阶段-运维系统服务/shell脚本/01_SHELL编程之变量定义.pdf","第2阶段-运维系统服务/shell脚本/02_SHELL编程之流程控制和循环语句.pdf","第2阶段-运维系统服务/shell脚本/03_SHELL编程之嵌套循环+随机数及综合案例.pdf","第2阶段-运维系统服务/shell脚本/04_SHELL编程之CASE语句+函数+正则.pdf","第2阶段-运维系统服务/shell脚本/05_SHELL编程之文本处理工具SED.pdf","第2阶段-运维系统服务/shell脚本/06_SHELL编程之文本处理工具AWK.pdf","第2阶段-运维系统服务/小工具/01_SHELL编程前奏_小工具.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/10_企业架构NOSQL数据库之MongoDB.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/11_企业架构web服务器文件及时同步.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/12_企业架构之Tomcat部署使用.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/4_企业架构双点服务器HA.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/7_企业架构MySQL读写分离.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/8_企业架构缓存中间件分布式memcached.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/MongoDB权威指南中文版.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/Mycat_V1.6.0.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/企业架构LB-服务器的负载均衡之Haproxy实现.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/企业架构LB-服务器的负载均衡之LVS实现.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/11_企业架构web服务器文件及时同步/01_文档/rsync+sersync/rsync+sersync.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/1_企业架构之LNMP/01_文档/1_企业架构之LNMP.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/2_企业级Nginx使用-day1/01_文档/2_企业级Nginx使用-day1.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/2_企业级Nginx使用-day1/05_资料/ThinkPHP5.0完全开发手册-20180101212957.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/3_企业级Nginx使用-day2/01_文档/3_企业级Nginx使用-day2.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/4_企业架构HA-服务器的高可用/01_文档/4_企业架构双点服务器HA.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/4_企业架构HA-服务器的高可用/05_资料/虚拟机克隆网卡配置/虚拟机克隆IP处理.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/5_企业架构LB-服务器的负载均衡之Nginx实现/01_文档/5_企业架构LNMP高可用负载均衡服务器.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/6_企业架构LB-服务器的负载均衡二/01_文档/haproxy/企业架构LB-服务器的负载均衡之Haproxy实现.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/6_企业架构LB-服务器的负载均衡二/01_文档/lvs/企业架构LB-服务器的负载均衡之LVS实现.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/6_企业架构LB-服务器的负载均衡二/05_资料/heartbeat安装/heartbeat.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/8_企业架构缓存中间件分布式memcached/01_文档/8_企业架构缓存中间件分布式memcached.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/9_企业架构队列缓存中间件分布式Redis/01_文档/9_企业架构队列缓存中间件分布式Redis.pdf","第4阶段-运维线下实战：运维自动化/centos7虚拟机教学环境统一文档.pdf","第4阶段-运维线下实战：运维自动化/CICD/文档/1-git.pdf","第4阶段-运维线下实战：运维自动化/CICD/文档/2-github与gitlab.pdf","第4阶段-运维线下实战：运维自动化/CICD/文档/3-jenkins.pdf","第4阶段-运维线下实战：运维自动化/CICD/文档/windows下Git使用拓展.pdf","第4阶段-运维线下实战：运维自动化/ELK日志分析/文档/ELK1.pdf","第4阶段-运维线下实战：运维自动化/ELK日志分析/文档/ELK2.pdf","第4阶段-运维线下实战：运维自动化/ELK日志分析/文档/logstash插件.pdf","第4阶段-运维线下实战：运维自动化/ELK日志分析/文档/综合案例.pdf","第4阶段-运维线下实战：运维自动化/存储/讲义/1-存储概念与SAN.pdf","第4阶段-运维线下实战：运维自动化/存储/讲义/2-分布式存储之glusterfs.pdf","第4阶段-运维线下实战：运维自动化/存储/讲义/3-分布式存储之Ceph.pdf","第4阶段-运维线下实战：运维自动化/存储/讲义/ceph的osd盘删除操作.pdf","第4阶段-运维线下实战：运维自动化/存储/讲义/iscsi扩展.pdf","第4阶段-运维线下实战：运维自动化/监控/文档/prometheus.pdf","第4阶段-运维线下实战：运维自动化/监控/文档/zabbix1.pdf","第4阶段-运维线下实战：运维自动化/监控/文档/zabbix2.pdf","第4阶段-运维线下实战：运维自动化/监控/文档/zabbix课后练习答案.pdf","第4阶段-运维线下实战：运维自动化/配置自动化/文档/ansible.pdf","第4阶段-运维线下实战：运维自动化/配置自动化/文档/练习答案.pdf","第4阶段-运维线下实战：运维自动化/配置自动化/文档/练习答案2.pdf","第5阶段-运维安全/1_系统安全.pdf","第5阶段-运维安全/2_网络安全.pdf","第5阶段-运维安全/3_服务安全.pdf","第5阶段-运维安全/5_入侵检测.pdf","第6阶段-运维云计算/01_k8s极速入门课程介绍.pdf","第6阶段-运维云计算/02_k8s初识.pdf","第6阶段-运维云计算/03_k8s功能.pdf","第6阶段-运维云计算/04_k8s架构.pdf","第6阶段-运维云计算/05_k8s集群部署.pdf","第6阶段-运维云计算/06_k8s集群客户端工具 kubectl.pdf","第6阶段-运维云计算/07_k8s集群资源清单文件（YAML）书写方法.pdf","第6阶段-运维云计算/1-kubernetes介绍与安装部署.pdf","第6阶段-运维云计算/1_容器技术.pdf","第6阶段-运维云计算/1_虚拟化技术（KVM）.pdf","第6阶段-运维云计算/2-kubernetes应用.pdf","第6阶段-运维云计算/2_代码自动发布-docker.pdf","第6阶段-运维云计算/2_大数据基础平台实施及运维.pdf","第6阶段-运维云计算/阿里云 SLB.pdf","第6阶段-运维云计算/阿里云 对象存储(OSS).pdf","第6阶段-运维云计算/阿里云CDN应用.pdf","第6阶段-运维云计算/01_大数据/day1/01_笔记/1_大数据基础平台实施及运维.pdf","第6阶段-运维云计算/02_虚拟化/day2/01_笔记/2_虚拟化技术（KVM）(1).pdf","第6阶段-运维云计算/03_阿里云/CDN/01_笔记/阿里云CDN应用.pdf","第6阶段-运维云计算/03_阿里云/ECS/01_笔记/阿里云 ECS.pdf","第6阶段-运维云计算/03_阿里云/NAS/01_笔记/阿里云文件存储 NAS.pdf","第6阶段-运维云计算/03_阿里云/OSS/01_笔记/阿里云 对象存储(OSS).pdf","第6阶段-运维云计算/03_阿里云/RDS/01_笔记/阿里云 RDS.pdf","第6阶段-运维云计算/03_阿里云/SLB/01_笔记/阿里云 SLB.pdf","第6阶段-运维云计算/04_私有云/openstack/OpenStack手动分布式部署.pdf","第6阶段-运维云计算/04_私有云/openstack/openstack排错思路.pdf","第6阶段-运维云计算/04_私有云/openstack/OpenStack自动部署.pdf","第6阶段-运维云计算/06_容器编排(k8s)/Paas云平台_docker容器.pdf","第6阶段-运维云计算/06_容器编排(k8s)/rancher.pdf","第6阶段-运维云计算/06_容器编排(k8s)/容器编排之Docker三剑客.pdf","第6阶段-运维云计算/7-k8s极速入门（赠送）/08_k8s极速入门_k8s集群NameSpace(命名空间)/01_笔记/08_k8s集群NameSpace(命名空间).pdf","第6阶段-运维云计算/7-k8s极速入门（赠送）/09_k8s极速入门_k8s集群核心概念 Pod/01_笔记/09_k8s集群核心概念 Pod.pdf","第6阶段-运维云计算/7-k8s极速入门（赠送）/10_k8s极速入门_k8s集群核心概念 Controller(控制器)/01_笔记/10_k8s集群核心概念Controller.pdf","第6阶段-运维云计算/7-k8s极速入门（赠送）/11_k8s极速入门_k8s集群核心概念 Service/01_笔记/11_k8s集群核心概念Service.pdf","第6阶段-运维云计算/7-k8s极速入门（赠送）/12_k8s极速入门_结课/01_笔记/12_k8s极速入门_结课.pdf","第6阶段-运维云计算/8-Kubernetes高级教程营销视频（赠送）/00_环境说明/01_笔记/第6阶段-运维云计算-《Kubernetes快速入门》进阶课程环境说明.pdf","第6阶段-运维云计算/8-Kubernetes高级教程营销视频（赠送）/01_Pod进阶/01_笔记/k8s集群核心概念 Pod进阶.pdf","第6阶段-运维云计算/8-Kubernetes高级教程营销视频（赠送）/02_Controller进阶/01_笔记/kubernetes集群应用 controller进阶.pdf","第6阶段-运维云计算/8-Kubernetes高级教程营销视频（赠送）/03_Service进阶/01_笔记/kubernetes集群应用 service进阶.pdf","第6阶段-运维云计算/8-Kubernetes高级教程营销视频（赠送）/04_kubernetes集群PaaS Rancher/01_笔记/基于kubernetes实现PaaS云平台-rancher.pdf","第6阶段-运维云计算/8-Kubernetes高级教程营销视频（赠送）/05_在kubernetes集群中kubesphere部署/01_笔记/kubernetes集群kubesphere.pdf","第6阶段-运维云计算/8-Kubernetes高级教程营销视频（赠送）/06_kubernetes集群 zookeeper部署/01_笔记/kubernetes集群 应用实践 zookeeper部署.pdf","第6阶段-运维云计算/8-Kubernetes高级教程营销视频（赠送）/07_kubernetes集群应用实践 kafka部署/01_笔记/kubernetes集群 应用实践 kafka部署.pdf","第7阶段-Python运维开发/python基础7天最终版.pdf","第7阶段-Python运维开发/01_Web开发基础之HTML+CSS/文档/01_Web开发基础之HTML+CSS.pdf","第7阶段-Python运维开发/02_Web开发基础之JavaScript/文档/02_Web开发基础之JavaScript.pdf","第7阶段-Python运维开发/03_Web开发基础之综合应用/文档/03_Web开发基础之综合应用.pdf","第7阶段-Python运维开发/04_Web框架之Django一/文档/04_Web框架之Django一.pdf","第7阶段-Python运维开发/05_Web框架之Django二/文档/05_Web框架之Django二.pdf","第7阶段-Python运维开发/06_Web框架之Django三/文档/06_Web框架之Django三.pdf","第7阶段-Python运维开发/07_CMDB系统开发一/文档/07_CMDB系统开发一.pdf","第7阶段-Python运维开发/09_CMDB系统开发三/文档/09_CMDB系统开发三.pdf"],Xn="linux/heima-Linux云计算/",Kn={mixins:[z["c"]],data:function(){return{prefix:Xn,book_options:Vn,show:!0,book:Vn[0],src:""}}},Zn=Kn,Jn=Object(d["a"])(Zn,Bn,Qn,!1,null,null,null),nr=Jn.exports,rr={components:{m2:nr},data:function(){return{tab:"m2",tabs:[{label:"m2",value:"m2"}]}}},tr=rr,er=Object(d["a"])(tr,Yn,Fn,!1,null,"c8afde32",null),ir=er.exports,ar=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:n.tab,callback:function(r){n.tab=r},expression:"tab"}},n._l(n.tabs,(function(n,r){return t("q-tab",{key:"tabs_"+r,attrs:{name:""+n.value,label:r+1+"."+n.label}})})),1),t(""+n.tab,{tag:"component"})],1)},sr=[],lr=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},or=[],dr='# Linux-v10.0-01天-课堂笔记\r\n\r\n学习目标\r\n\r\n- 能够知道什么是Linux系统以及它的应用场景\r\n- 能够独立完成安装VMware虚拟机和网络配置\r\n- 能够独立完成安装CentOS以及远程终端SecureCRT\r\n- 能够熟练编写账户管理、用户组的增删改查和添加命令\r\n- 能够熟练编写系统管理的常用命令\r\n- 能够熟练编写目录常用命令\r\n- 能够熟练编写权限常用命令\r\n- 能够知道用户组实际应用场景\r\n\r\n# 1 初识Linux\r\n\r\n```\r\n在前面的课程中，我们无论是开发、测试。部署、存储都在Windwos操作系统的环境中，从今天开始我们一起学习下Linux,Linux系统和Windows系统最大的区别就是图形化界面操作和用途上有所差异，除了这两点，两者有异曲同工之妙，在国内， Linux 系统更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows，也就是说Linux与Windows一样，同样也是操作系统只是在使用以及应用上有所差异，其他都是一样的；\r\n因为Linux也是操作系统\r\n所以在正式进入Linux学习之前，我们先简单的学习操作系统的知识，然后在讲解Linux\r\n```\r\n\r\n## 1.1 操作系统\r\n\r\n操作系统(Operation System, OS)，是管理[计算机](https://baike.baidu.com/item/计算机)[硬件](https://baike.baidu.com/item/硬件)与[软件](https://baike.baidu.com/item/软件)资源的[计算机程序](https://baike.baidu.com/item/计算机程序)，同时也是计算机系统的内核与基石。操作系统需要处理如管理与配置[内存](https://baike.baidu.com/item/内存)、决定[系统资源](https://baike.baidu.com/item/系统资源/974435)供需的优先次序、控制[输入设备](https://baike.baidu.com/item/输入设备/10823368)与[输出设备](https://baike.baidu.com/item/输出设备/10823333)、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。\r\n\r\n操作系统作为接口的示意图:\r\n\r\n![1576199620565](./img/linux/java-linux/Linux-v10-01天-授课/1576199620565.png)\r\n\r\n如上图所示，在操作系统的最上层是用户，中间层是操作系统（里面可能装了很多的应用程序），最下层是硬件的支撑，包含CPU/内存/硬盘等\r\n\r\n这就是一个完成的操作系统结构图\r\n\r\n**主流操作系统按照应用领域的划分**\r\n\r\n**1、桌面操作系统**\r\n\r\n- Window 系列\r\n  - 用户群体大\r\n- macOS\r\n  - 细节处理的更好, 没有windows软件丰富, 价格高\r\n- Linux\r\n  - 应用软件少\r\n\r\n**2、服务器操作系统**\r\n\r\n- Linux\r\n\r\n  - 安全、稳定、免费\r\n  - 占有率高\r\n\r\n- Windows Server\r\n\r\n  - 付费\r\n  - 占有率低\r\n\r\n  ![1558234034446](./img/linux/java-linux/Linux-v10-01天-授课/1558234034446.png)\r\n\r\n**3、嵌入式操作系统**\r\n\r\n​    Linux\r\n\r\n**4、移动设备操作系统**\r\n\r\n ![1560477460567](./img/linux/java-linux/Linux-v10-01天-授课/1560477460567.png)\r\n\r\n- IOS\r\n- Android (基于Linux)\r\n- 华为鸿蒙(基于linux)\r\n\r\n## 1.2 Linux发展历程\r\n\r\n```\r\n引子\r\n在上面，我们学习了操作系统的知识，也知道了主流操作系统按照应用领域划分了四个类型的操作系统，其中Linux操作系统在四个领域都有提名，因为它是至今开源序列最好的操作系统，下面，我们就一起看下Linux的发展历程，看看它是怎么诞生的...\r\n```\r\n\r\n1984年，Andrew S.Tanenbaum 开发了用于教学的Unix系统，命名为Minix，但是仅仅用于教学\r\n1989年，Andrew S.Tanenbaum将Minix系统运行于x86的pc平台\r\n1990年，芬兰赫尔辛基大学学生Linus Torvalds首次接触Minix系统\r\n1991年，Linus Torvalds开始在Minix上编写各种驱动程序等操作系统内核组件\r\n1991年年底，Linus Torvalds公开了Linux内核源码0.02版，仅仅是内核\r\n1994年，Linux 1.0版本发行，Linux转向GPL版权协议\r\n至此，Linux开始盛行开来...\r\n\r\n![1575879660267](./img/linux/java-linux/Linux-v10-01天-授课/1575879660267.png)\r\n\r\nLinux 内核最初是由李纳斯•托瓦兹（Linus Torvalds）在赫尔辛基大学读书时出于个人爱好而编写的，当时他觉得教学用的迷你版 Unix操作系统 Minix 太难用了，于是决定自己开发一个操作系统。\r\n\r\n第 1 版本于 1991 发布，当时仅有 10 000 行代码。\r\n\r\n李纳斯•托瓦兹没有保留 Linux 源代码的版权，公开了代码，并邀请他人一起完善 Linux。与 Windows 及其他有专利权的操作系统不同，Linux 开放源代码，任何人都可以免费使用它。\r\n\r\n据估计，现在只有 2% 的 Linux 核心代码是由李纳斯•托瓦兹自己编写的，虽然他仍然拥有 Linux 内核（操作系统的核心部分），并且保留了选择新代码和需要合并的新方法的最终裁定权。现在大家所使用的 Linux，我更倾向于说是由李纳斯•托瓦兹和后来陆续加入的众多 Linux 好者共同开发完成的。\r\n\r\n> Unix  \r\n>\r\n> Unix  操作系统由肯•汤普森（Ken Thompson）和丹尼斯•里奇（Dennis Ritchie）发明。它的部分技术来源可追溯到从 1965 年开始的 Multics 工程计划，该计划由贝尔实验室、美国麻省理工学院和通用电气公司联合发起，目标是开发一种交互式的、具有多道程序处理能力的分时操作系统，以取代当时广泛使用的批处理操作系统。\r\n>\r\n> Unix是一个强大的多用户、多任务操作系统。于1969年在AT&T的贝尔实验室开发。Unix  的商标权由国际开放标准组织（The Open Group）所拥有。Unix操作系统是商业版，需要收费，价格比Microsoft Windows正版要贵一些。\r\n\r\n## 1.3 Linux简介\r\n\r\n```\r\n引子\r\nLinux和我们常见的Windows一样，都是操作系统，\r\n例如：新浪、百度、淘宝等互联网公司，他们使用的服务器全都是Linux系统；全球500强企业95%的服务器使用的都是Linux系统。\r\n```\r\n\r\n### **1.3.1 什么是 Linux**\r\n\r\nLinux是一套免费使用和自由传播的[类Unix](https://baike.baidu.com/item/类Unix)[操作系统](https://baike.baidu.com/item/操作系统/192)，是一个基于[POSIX](https://baike.baidu.com/item/POSIX)和Unix的多用户、[多任务](https://baike.baidu.com/item/多任务/1011764)、支持[多线程](https://baike.baidu.com/item/多线程/1190404)和多[CPU](https://baike.baidu.com/item/CPU)的操作系统。它能运行主要的Unix工具软件、应用程序和网络协议。它支持[32位](https://baike.baidu.com/item/32位/5812218)和[64位](https://baike.baidu.com/item/64位)硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。\r\n\r\nLinux 的标志和吉祥物是一只名字叫做Tux(它克斯)的企鹅，Linux是基于Unix的。\r\n\r\nLinux是一种自由和开放源码的操作系统，存在着许多不同的Linux版本，但它们都使用了Linux内核。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、台式计算机\r\n\r\n![1575881750752](./img/linux/java-linux/Linux-v10-01天-授课/1575881750752.png)\r\n\r\nLinux不仅系统性能稳定，而且是开源软件。其核心防火墙组件性能高效、配置简单，保证了系统的安全。在很多企业网络中，为了追求速度和安全，Linux操作系统不仅仅是被网络运维人员当作服务器使用，Linux既可以当作[服务器](https://baike.baidu.com/item/服务器/100571)，又可以当作网络防火墙是Linux的 一大亮点。 \r\n\r\nLinux与其他操作系统相比 ，具有[开放源码](https://baike.baidu.com/item/开放源码/7176422)、没有版权、技术社区用户多等特点 ，开放源码使得用户可以自由裁剪，灵活性高，功能强大，成本低。尤其系统中内嵌网络协议栈 ，经过适当的配置就可实现路由器的功能。这些特点使得Linux成为开发路由交换设备的理想开发平台。\r\n\r\n### 1.3.2 Linux的特点\r\n\r\n**基本思想**\r\n\r\nLinux的基本思想有两点：\r\n\r\n第一：一切都是文件\r\n\r\n第二：每个软件都有确定的用途\r\n\r\n其中第一条详细来讲就是系统中的所有都归结为一个文件，包括[命令](https://baike.baidu.com/item/命令)、[硬件](https://baike.baidu.com/item/硬件)和[软件](https://baike.baidu.com/item/软件/12053)设备、[操作系统](https://baike.baidu.com/item/操作系统/192)、[进程](https://baike.baidu.com/item/进程)等等对于操作系统[内核](https://baike.baidu.com/item/内核)而言，都被视为拥有各自特性或类型的文件。至于说Linux是基于Unix的，很大程度上也是因为这两者的基本思想十分相近\r\n\r\n**完全免费**\r\n\r\nLinux是一款免费的操作系统，用户可以通过网络或其他途径免费获得，并可以任意修改其[源代码](https://baike.baidu.com/item/源代码/3969)。这是其他的操作系统所做不到的。正是由于这一点，来自全世界的无数[程序员](https://baike.baidu.com/item/程序员/62748)参与了Linux的修改、编写工作，程序员可以根据自己的兴趣和灵感对其进行改变，这让Linux吸收了无数程序员的精华，不断壮大。\r\n\r\n**完全兼容POSIX1.0标准**\r\n\r\n这使得可以在Linux下通过相应的[模拟器](https://baike.baidu.com/item/模拟器)运行常见的[DOS](https://baike.baidu.com/item/DOS/32025)、[Windows](https://baike.baidu.com/item/Windows)的程序。这为用户从Windows转到Linux奠定了基础。许多用户在考虑使用Linux时，就想到以前在Windows下常见的程序是否能正常运行，这一点就消除了他们的疑虑。\r\n\r\n**多用户、多任务**\r\n\r\nLinux支持多用户，各个用户对于自己的文件设备有自己特殊的权利，保证了各用户之间互不影响。[多任务](https://baike.baidu.com/item/多任务)则是现在电脑最主要的一个特点，Linux可以使多个程序同时并独立地运行。\r\n\r\n**良好的界面**\r\n\r\nLinux同时具有字符界面和[图形界面](https://baike.baidu.com/item/图形界面/8146283)。在字符界面用户可以通过键盘输入相应的指令来进行操作。它同时也提供了类似Windows图形界面的X-Window系统，用户可以使用鼠标对其进行操作。在X-Window环境中就和在Windows中相似，可以说是一个Linux版的Windows。\r\n\r\n**支持多种平台**\r\n\r\nLinux可以运行在多种硬件平台上，如具有[x86](https://baike.baidu.com/item/x86/6150538)、680x0、SPARC、Alpha等处理器的平台。此外Linux还是一种嵌入式操作系统，可以运行在掌上电脑、机顶盒或游戏机上。2001年1月份发布的Linux 2.4版内核已经能够完全支持[Intel](https://baike.baidu.com/item/Intel/125450)64位芯片架构。同时Linux也支持多处理器技术。多个处理器同时工作，使系统性能大大提高。\r\n\r\n**优点**\r\n\r\n1)Linux由众多微内核组成，其源代码完全开源；\r\n\r\n2)Linux继承了Unix的特性，具有非常强大的网络功能，其支持所有的因特网协议，包括TCP/[IPv4](https://baike.baidu.com/item/IPv4/422599)、 [TCP](https://baike.baidu.com/item/TCP/33012)/IPv6和链路层拓扑程序等，且可以利用Unix的网络特性开发出新的协议栈；\r\n\r\n3)Linux系统工具链完整，简单操作就可以配置出合适的开发环境，可以简化开发过程，减少开发中仿真工具的障碍，使系统具有较强的移植性；\r\n\r\n## 1.4 Linux和Unix区别\r\n\r\n**1、开源情况**\r\n\r\nUnix  是商业化的，而 Linux 是开源的，是免费、公开源代码的。\r\n\r\n**2、硬件适用**\r\n\r\nUnix  系统大多是与硬件配套的，也就是说，大多数Unix系统如AIX、HP-UX等是无法安装在 x86 服务器和个人计算机上的，而 Linux则可以运行在多种硬件平台上。\r\n\r\n可以先学习Linux后再学习Unix，因为Linux可以方便的在虚拟机上运行，防止新手的误操作。\r\n\r\n**3、本质不同**\r\n\r\nLinux是开放源代码的自由软件，用户对前者有很高的自主权，在实际的的开发是处在一个完全开放的环境之中；\r\n\r\n而Unix是对源代码实行知识产权保护的传统商业软件，用户的开发完全是处在一个黑箱之中，只有相关的开发人员才能够接触的产品的原型；\r\n\r\n> Unix 诞生于 20 世纪 60 年代末，Windows 诞生于 20 世纪 80 年代中期，Linux 诞生于 20 世纪 90 年代初，可以说 Unix是操作系统中的"老大哥"，后来的 Windows 和 Linux 都参考了 Unix \r\n>\r\n\r\n##  1.5 Linux和Windows区别\r\n\r\n目前国内 Linux 更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows。主要区别如下\r\n\r\n| 比较     | Windows                                                      | Linux                                                        |\r\n| :------- | :----------------------------------------------------------- | :----------------------------------------------------------- |\r\n| 界面     | 界面统一，外壳程序固定所有 Windows 程序菜单几乎一致，快捷键也几乎相同 | 图形界面风格依发布版不同而不同，可能互不兼容。GNU/Linux 的终端机是从 Unix传承下来，基本命令和操作方法也几乎一致。 |\r\n| 驱动程序 | 驱动程序丰富，版本更新频繁。默认安装程序里面一般包含有该版本发布时流行的硬件驱动程序，之后所出的新硬件驱动依赖于硬件厂商提供。对于一些老硬件，如果没有了原配的驱动有时很难支持。另外，有时硬件厂商未提供所需版本的 Windows 下的驱动，也会比较头痛。 | 由志愿者开发，由 Linux 核心开发小组发布，很多硬件厂商基于版权考虑并未提供驱动程序，尽管多数无需手动安装，但是涉及安装则相对复杂，使得新用户面对驱动程序问题（是否存在和安装方法）会一筹莫展。但是在开源开发模式下，许多老硬件尽管在Windows下很难支持的也容易找到驱动。HP、Intel、AMD 等硬件厂商逐步不同程度支持开源驱动，问题正在得到缓解。 |\r\n| 使用     | 使用比较简单，容易入门。图形化界面对没有计算机背景知识的用户使用十分有利。 | 图形界面使用简单，容易入门。文字界面，需要学习才能掌握。     |\r\n| 学习     | 系统构造复杂、变化频繁，且知识、技能淘汰快，深入学习困难。   | 系统构造简单、稳定，且知识、技能传承性好，深入学习相对容易。 |\r\n| 软件     | 每一种特定功能可能都需要商业软件的支持，需要购买相应的授权。 | 大部分软件都可以自由获取，同样功能的软件选择较少。           |\r\n\r\nWindows与Linux在其他方面的不同\r\n\r\n**开放性**\r\n\r\n所谓的开放性就是Linux 操作系统是开放源码系统，可以对其程序进行编辑修改。而微软的Windows 系统是受微软版权保护，就是只能微软内部进行开发及修改。\r\n\r\n**文件格式不同**\r\n\r\nWindows 操作系统内核是NT，而Linux 是 shell；\r\n\r\n另外，windows 硬盘文件格式是fat32或NTFS，而Linux 需要的文件格式是ext2或ext3，该操作系统还多一个SWAP格式的交换分区\r\n\r\n**免费与收费** \r\n\r\n在中国，对个人用户Windows 和Linux 都是免费的，对公用户Windows 需要收费，Linux 是免费的。\r\n\r\n**技术支持** \r\n\r\nWindows 较普及。Linux 需要深度的Linux 版块支持。\r\n\r\n**安全性** \r\n\r\nLinux 相对Windows 来说安全性更高。 \r\n\r\n**开源** \r\n\r\n开源就是指对外部开放软件源代码。Linux 开源，而Windows并不开源。\r\n\r\n**使用习惯** \r\n\r\nWindows 放弃了dos的字符模式，主攻图形界面，让桌面系统更易用。Linux 字符模式运行的更好，图形界面还只是附带品，可有可无。\r\n\r\n**软件与支持** \r\n\r\nWindows 下可以运行绝大部分软件、玩99.999％的游戏、硬件厂商近乎100%的支持。Linux 下可直接运行的软件数量和win下比起来就是1和99的区别，而且目前选择Linux 的人基本不会考虑玩游戏，同时Linux 正期待更多硬件厂商的支持\r\n\r\n## 1.6 Linux发行商和常见发行版\r\n\r\nLinux发行版是由个人，自由组织，以及商业机构和志愿者组织编写。它们通常包括了其他的系统软件和应用软件，以及一个用来简化系统初始安装的安装工具，和让软件安装升级的集成管理器。大多数系统还包括了像提供GUI界面的XFree86之类的曾经运行于BSD的程序。\r\n一个典型的Linux发行版包括：Linux内核，一些GNU程序库和工具，命令行shell，图形界面的桌面环境，如KDE或GNOME，并包含数千种从办公套件，编译器，文本编辑器到科学工具的应用软件\r\n\r\nLinux发行版的某些版本是不需要安装，只需通过CD或者可启动的USB存储设备就能使用的版本，他们称为LiveCD。\r\n\r\n\r\n ![1575879998775](./img/linux/java-linux/Linux-v10-01天-授课/1575879998775.png)\r\n\r\n\r\n\r\n**Linux的版本号分为两部分：内核版本和发行版本**。\r\n\r\n**1．Linux的内核版本**\r\n内核版本指的是在Linus Torvalds领导下的开发小组开发出的系统内核的版本号，通常，内核版本号的第二位是偶数表示是稳定的版本，如2.6.25；是奇数表示有一些新的东西加入，是不稳定的测试版本，如2.5.6。Linux操作系统的核心就是它的内核，Linus Torvalds和他的小组在不断地开发和推出新内核。\r\n\r\n任务：进程调度、内存管理、配置管理虚拟文件系统、提供网络接口以及支持进程间通信。像所有软件一样，Linux的内核也在不断升级。\r\n\r\n**2．Linux的发行版本**\r\n一个完整的操作系统不仅仅只有内核，还包括一系列为用户提供各种服务的外围程序。外围程序包括GNU程序库和工具，命令行shell，图形界面的X Window系统和相应的桌面环境，如KDE或GNOME，并包含数千种从办公套件，编译器，文本编辑器到科学工具的应用软件。所以，许多个人、组织和企业，开发了基于GNU/Linux的Linux发行版，他们将Linux系统的内核与外围应用软件和文档包装起来，并提供一些系统安装界面和系统设置与管理工具， 这样就构成了一个发行版本。\r\n实际上，Linux的发行版本就是Linux内核再加上外围的实用程序组成的一个大软件包而已。相对于操作系统内核版本，发行版本的版本号是随发布者的不同而不同，与Linux系统内核的版本号是相对独立的，例如：RedHat EnterpriseLinux 5.2的操作系统内核是Linux-2.6.18。\r\nLinux的发行版本大体可以分为两类：\r\n\r\n一类是商业公司维护的发行版本\r\n\r\n一类是社区组织维护的发行版本，前者以著名的RedHatLinux为代表，后者以Debian为代表\r\n\r\n以下为Linux的主流版本：\r\n\r\n目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等\r\n\r\n![1575882315996](./img/linux/java-linux/Linux-v10-01天-授课/1575882315996.png)\r\n\r\n\r\n\r\n**以下是主要的发行版本**\r\n\r\n```\r\n需要注意的：\r\n下面的内容主要是介绍了下Linux发行家族以及发行版本的一些详细信息，虽然我们当前的课程讲解的是CentOS,但是其他的一些发行商、主流的发行版本比如Ubuntu、Redhat也需要让学生多多了解下，毕竟这是Linux体系内产品线\r\n注意\r\n下面的文字虽然很多，但是只要让学生知道有这么回事即可\r\n在下面会简单的总结..\r\n```\r\n\r\n**1、Debian 介绍**\r\n\r\nDebian名字的由来----DebianGNU/Linux是由一个叫做伊恩·默多克（IanMurdock）在1993年发起的，他的名字以Ian开头，他太太的名字Debra开头三个字母是Deb。\r\n\r\nDebian是社区类Linux的典范，是迄今为止最遵循GNU规范的Linux系统。Debian最早由 Ian Murdock于1993年创建，分为三个版本分支： stable(服务器版), testing(稳定版) 和unstable(测试版)。\r\n\r\n**2、Ubuntu介绍**\r\n\r\nUbuntu严格来说不能算一个独立的发行版本，Ubuntu是基于Debian的unstable版本加强而来，可以这么说，Ubuntu就是一个拥有Debian所有的优点，以及自己所加强的优点的近乎完美的 Linux桌面系统。\r\n\r\n共分三个版本:\r\n\r\n- 基于Gnome的Ubuntu，\r\n- 基于KDE的Kubuntu以。\r\n- 基于Xfc的 Xubuntu。\r\n\r\n特点是界面非常友好，容易上手，对硬件的支持非常全面，是最适合做桌面系统的Linux发行版本。稳定性，其实都差不多，难易度嘛，\r\n\r\nUbuntu 默认桌面环境采用 GNOME，一个 Unix和 Linux 主流桌面套件和开发平台。\r\n\r\nUbuntu的版本和发布号 \r\nUbuntu的版本号是由该次发布的年份和月份组成，并未反映其实际版本。我们的首次发布是在2004年10月，因此该版本为4.10。当前版本(DapperDrake)于2006年6月发布，因此版本号为6.06 LTS。\r\n\r\n**3、Redhat**\r\n\r\n可能这是最著名的Linux版本了，Red Hat Linux已经创造了自己的品牌，越来越多的人听说过它。Red Hat在1994年创业，当时聘用了全世界500多名员工，他们都致力于开放的源代码体系。\r\nRed Hat Linux是公共环境中表现上佳的服务器。它拥有自己的公司，能向用户提供一套完整的服务，这使得它特别适合在公共网络中使用。这个版本的Linux也使用最新的内核，还拥有大多数人都需要使用的主体软件包。\r\nRed Hat Linux的安装过程也十分简单明了。它的图形安装过程提供简易设置服务器的全部信息。磁盘分区过程可以自动完成，还可以选择GUI工具完成，即使对于 Linux新手来说这些都非常简单。选择软件包的过程也与其他版本类似；用户可以选择软件包种类或特殊的软件包。系统运行起来后，用户可以从Web站点和 Red Hat那里得到充分的技术支持。我发现Red Hat是一个符合大众需求的最优版本。在服务器和桌面系统中它都工作得很好。Red Hat的唯一缺陷是带有一些不标准的内核补丁，这使得它难于按用户的需求进行定制。 Red Hat通过论坛和邮件列表提供广泛的技术支持，它还有自己公司的电话技术支持，后者对要求更高技术支持水平的集团客户更有吸引力\r\n\r\n**4、Fedora**\r\n\r\nFedora和Redhat这两个Linux的发行版放联系很密切。Redhat 自9.0以后，不再发布桌面版的，而是把这个项目与开源社区合作，于是就有了Fedora 这个 Linux 发行版。Fedora项目是由 Red Hat 赞助，由开源社区与 Red Hat 工程师合作开发的项目统称。Fedora 的目标，是推动自由和开源软件更快地进步。\r\n\r\n特点：\r\n１、 Fedora 是一个开放的、创新的、前瞻性的操作系统和平台，基于 Linux。它允许任何人自由地使用、修改和重发布，无论现在还是将来。可运行的体系结构包括x86(即i386),x86_64 和PowerPC！\r\n２、Fedora 可以说是Redhat 桌面版本的延续，只不过是与开源社区合作。\r\n\r\n３、Fedora 是一个独立的inux发行版本的操作系统。\r\n\r\n**5**、**centos**\r\n\r\nCentOS（Community ENTerprise Operating System）是来自于Red Hat Enterprise Linux依照开放源代码规定释出的源代码所编译而成。由于出自同样的源代码，因此有些要求高度稳定性的服务器以CentOS替代商业版的Red Hat Enterprise Linux使用（我会告诉你，以为企业想省钱，运维要靠这个东西来赚钱嘛，国内运维主流是CentOS剩下版本很少）。两者的不同，在于CentOS并不包含封闭源代码软件，CentOS 是一个基于Red Hat Linux 提供的可自由使用源代码的企业级Linux发行版本。每个版本的CentOS都会获得十年的支持（通过安全更新方式）。新版本的 CentOS 大约每两年发行一次，而每个版本的 CentOS 会定期（大概每六个月）更新一次，以便支持新的硬件。这样，建立一个安全、低维护、稳定、高预测性、高重复性的 Linux 环境\r\n\r\n\r\n**6、Slackware介绍**\r\n\r\nSlackware 由PatrickVolkerding(帕特里克.沃克登)创建于1992年。算起来应当是历史最悠久的Linux发行版。尽管如此，Slackware仍然深入人心（大部分都是比较有经验的 Linux老手）。Slackware稳定、安全，所以仍然有大批的忠实用户。由于Slackware尽量采用原版的软件包而不进行任何修改，所以制造新 bug的几率便低了很多。Slackware的版本更新周期较长（大约1年），但是新版本的软件仍然不间断的提供给用户下载。\r\n\r\n**7、openSUSE介绍**\r\n\r\nSUSE是德国最著名的Linux发行版，在全世界范围中也享有较高的声誉。SUSE自主开发的软件包管理系统也大受好评。SUSE于2003年年末被Novell收购。SUSE在收购之后的发布显得比较混乱，比如9.0版本是收费的，而10.0版本（也许由于各种压力）又免费发布。这使得一部分用户感到困惑，也转而使用其它发行版本。最近还跟微软扯到了一起。但是瑕不掩瑜，SUSE仍然是一个非常专业、优秀的发行版。\r\n\r\nopenSUSE 项目是由Novell公司资助的全球性社区计划，旨在推进 Linux 的广泛使用。这个计划提供免费的openSUSE 操作系统。这里是一个由普通用户和开发者共同构成的社区，我们拥有一个共同的目标—创造世界上最好用的 Linux 发行版。openSUSE 是 Novell 公司发行的企业级 Linux 产品的系统基础。\r\n\r\nopenSUSE 项目是由Novell 发起的开源社区计划。 旨在推进 Linux 的广泛使用。提供了自由简单的方法来获得世界上最好用的 Linux 发行版，SUSE Linux。openSUSE 项目为 Linux 开发者和爱好者提供了开始使用 Linux 所需要的一切。\r\n\r\n**8、中国大陆的Linux发行版**\r\n\r\n红旗Linux(RedflagLinux) ，冲浪Linux(Xteam Linux) ，蓝点Linux ， GNU/Linux，OpenDesktop等等 。\r\n\r\n**9、 台湾地区的Linux发行版**\r\n\r\n鸿奇Linux\r\n\r\n**目前最著名的发行版本：Debian，ubuntu、OpenSuse(原Suse)、CentOS、fedora等。国内比较著名的红旗Linux版本**\r\n\r\n\r\n\r\n> 对于上面的知识我们做下重点总结\r\n>\r\n> - **redhat**：目前，全球最大的**linux**发行厂商，功能全面、稳定。\r\n>   - **Redhat** 被 **IBM** 收购!\r\n> - **ubuntu**：目前，是linux桌面操作系统做的最好的。\r\n> - **centos**：免费版的redhat，**centos** 基于 **redhat** 发行版基础之上，再重新编译发布的版本。\r\n>   - 目前 **centos** 已经被 **Redhat** 公司收购，但是依然免费\r\n\r\n\r\n\r\n## 1.7 Linux 应用领域\r\n\r\n今天各种场合都有使用各种 Linux 发行版，从嵌入式设备到超级计算机，并且在服务器领域确定了地位。在企业级开发中，我们通常使用Linux作为我们的服务器。\r\n\r\n比如：服务器系统Web应用服务器、数据库服务器、接口服务器、DNS、FTP等等； \r\n\r\n嵌入式系统路由器、防火墙、手机、PDA、IP 分享器、交换器、家电用品的微电脑控制器等等，高性能运算、计算密集型应用Linux有强大的运算能力。\r\n\r\n**目前 Linux 不仅在家庭与企业中使用，并且在政府中也很受欢迎**。\r\n\r\n- 巴西联邦政府由于支持 Linux 而世界闻名。\r\n- 有新闻报道俄罗斯军队自己制造的 Linux 发布版的，做为 G.H.ost 项目已经取得成果。\r\n- 印度的 Kerala 联邦计划在向全联邦的高中推广使用 Linux。\r\n- 中华人民共和国为取得技术独立，在龙芯处理器中排他性地使用 Linux。\r\n- 在西班牙的一些地区开发了自己的 Linux 发布版，并且在政府与教育领域广泛使用，如 Extremadura 地区的 gnuLinEx 和 Andalusia 地区的 Guadalinex。\r\n- 葡萄牙同样使用自己的 Linux 发布版 Caixa Mágica，用于 Magalh?es 笔记本电脑和 e-escola 政府软件。\r\n- 法国和德国同样开始逐步采用 Linux。\r\n\r\n## **1.8 Linux之CentOS**\r\n\r\n```\r\n前面章节介绍了一些Linux的基本知识，前已经对Linux有了一个初步的认识，也知道了在Linux发行版中有各个家族的发行版本；比如比较知名的ubuntu、CentOS，在今天的Linux课程中我们将采用发行版CentOS作为我们Linux课程的讲解内容。\r\n```\r\n\r\n**CentOS**，是基于 Red Hat Linux 提供的可自由使用源代码的企业级 Linux 发行版本；是一个稳定，可预测，可管理和可复制的免费企业级计算平台\r\n\r\n**主要特点:**\r\n\r\n1.主流： 目前的Linux操作系统主要应用于生产环境，主流企业级Linux系统仍旧是RedHat或者CentOS\r\n2.免费： RedHat 和CentOS差别不大，CentOS是一个基于Red Hat Linux 提供的可自由使用源代码的企业级Linux发行版本\r\n3.更新方便：CentOS独有的yum命令支持在线升级，可以即时更新系统，不像RED HAT那样需要花钱购买支持服务！\r\n\r\n**我们在当前课程中的环境：**\r\n\r\nWindows7 , VMware Workstation15.02, CentOS Linux release 7.6.1810 \r\n\r\n## 1.9 总结\r\n\r\n当前章节主要介绍了Linux发行的主要版本（我们使用的是CentOS Linux release 7.6.1810 ）、以及与Unix、Windows系统的区别；主要让学生了解Linux是基于Unix的以及与Windows一样，Linux也是操作系统即可。\r\n\r\n# 2 系统与设置命令\r\n\r\n```\r\n在前面的两个章节中，我们主要介绍了Linux基本知识和虚拟机的安装，从当前章节开始，我们一起学习下Linux的基本命令，在当前章节，我们先简单的学习下一些系统的基本命令，慢慢的由浅入深，在后面的章节中我们将学习其他的命令比如文件操作、备份压缩等\r\n```\r\n\r\n## 2.1 学习命令的原因\r\n\r\n```\r\n命令我们可以理解成在Windows中我们常常为了查看ip输入的ipconfig，在Linux中也有很多的命令，比如操作目录、文件、网络、磁盘等等命令\r\n```\r\n\r\n- Linux刚面世时并没有图形界面, 所有的操作全靠命令完成, 如 **磁盘操作、文件存取、目录操作、进程管理、文件权限** 设定等\r\n- 在职场中，大量的 **服务器维护工作** 都是在 远程 通过SSH客户端 来完成的， 并没有图形界面， 所有的维护工作都需要通过命令来完成\r\n\r\n![1576225778294](./img/linux/java-linux/Linux-v10-01天-授课/1576225778294.png)\r\n\r\n在职场中， 作为后端程序员或者运维， 必须要或多或少的掌握一些Linux常用的终端命令\r\n\r\n- Linux发行版本的命令大概有200多个， 但是常用的命令只有几十个而已\r\n\r\n```\r\n总结\r\n学习终端命令的技巧：\r\n- 不需要死记硬背， 对于常用命令， 记住语法是关键，在用的时候去查下参数选项，有的很常用的命令，用的多自然就记住了\r\n- 不要尝试一次学会所有的命令， 有些命令是非常不常用的，临时遇到，就去根据语法找参数选项\r\n```\r\n\r\n## 2.2 Linux 用户和用户组管理\r\n\r\n### 2.2.1 Linux账号管理\r\n\r\n```\r\n从当前章节开始，我们正式进入CentOS的学习，我们先从简单的命令开始，比如操作账号、用户组、系统管理等。\r\n在实际使用场景中，用户账号的管理主要涉及到用户账号的添加、修改和删除操作。\r\n现在，我们就通过命令的方式添加用户账号（账号名字可以自定义，但是是要符合书写规范）\r\n在操作前，确保我们的SecureCRT成功连接到了虚拟机.\r\n下面的章节不在赘述SecureCRT，默认已经成功连接。\r\n```\r\n\r\n#### 1) 添加用户\r\n\r\n```\r\n我们在Windows创建账号主要是是控制面板--用户账户--创建一个新账户，这是在Windows创建账户的流程，而在Linux中，我们可以通过命令的方式进行创建账户\r\n```\r\n\r\n**使用者权限：管理员用户**\r\n\r\n```shell\r\nuseradd 选项 用户名\r\n```\r\n\r\n**参数说明：**\r\n\r\n- 选项:\r\n\r\n  - -c comment 指定一段注释性描述。\r\n  - -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。\r\n  - -g 用户组 指定用户所属的用户组。\r\n  - -G 用户组，用户组 指定用户所属的附加组。\r\n  - -s Shell文件 指定用户的登录Shell。\r\n  - -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。\r\n\r\n- 用户名:\r\n\r\n  指定新账号的用户名(后续我们可以使用这个用户名进行系统登录)。\r\n\r\n添加用户czbk（传智播客的首拼）执行\r\n\r\n```shell\r\nuseradd  czbk\r\n```\r\n\r\n我们使用useradd命令创建了一个用户czbk\r\n\r\nuseradd 可用来建立用户帐号。帐号建好之后，再用 passwd 设定帐号的密码。\r\n\r\n执行如下\r\n\r\n![1576043805214](./img/linux/java-linux/Linux-v10-01天-授课/1576043805214.png)\r\n\r\n由上图我们发现，我们在使用useradd新增用户的时候，出现了权限不足，也就是说我们使用用户itcast没有创建用户的权限。\r\n\r\n我们通过管理员账号root进行创建，首先我们从控制台中切换到root\r\n\r\n```shell\r\nsu root\r\n```\r\n\r\n![1576042675759](./img/linux/java-linux/Linux-v10-01天-授课/1576042675759.png)\r\n\r\n在 密码的地方输入我们的root密码【root】即可进入到root用户下。\r\n\r\n我们在root下继续创建czbk用户\r\n\r\n![1576043845543](./img/linux/java-linux/Linux-v10-01天-授课/1576043845543.png)\r\n\r\n以下是useradd常用选项\r\n\r\n![1576049906893](./img/linux/java-linux/Linux-v10-01天-授课/1576049906893.png)\r\n\r\n\r\n\r\n#### 2) 用户口令\r\n\r\n```\r\n引子：\r\n相当于我们在Windows系统中给个用户更改密码，只是我们在CentOS中是更改密码是通过命令完成的。\r\n```\r\n\r\n用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用\r\n\r\n**使用者权限：管理员用户**\r\n\r\n指定和修改用户口令的Shell命令是`passwd`。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：\r\n\r\n```shell\r\npasswd 选项 用户名\r\n```\r\n\r\n可使用的选项：\r\n\r\n- -l 锁定口令，即禁用账号。\r\n- -u 口令解锁。\r\n- -d 使账号无口令。\r\n- -f 强迫用户下次登录时修改口令。\r\n\r\n设置当前用户的口令\r\n\r\n```shell\r\npasswd czbk\r\n```\r\n\r\n此处我们设置密码和itcast账号密码一致，为【Itheima888】\r\n\r\n![1576044108094](./img/linux/java-linux/Linux-v10-01天-授课/1576044108094.png)\r\n\r\n#### 3) 修改用户\r\n\r\n```\r\n相当于我们在Windows系统中修改一个用户，只是我们在CentOS中是修改用户是通过命令完成的。\r\n```\r\n\r\nusermod 命令通过修改系统帐户文件来修改用户账户信息\r\n\r\n修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。\r\n\r\n**使用者权限：管理员用户**\r\n\r\n修改已有用户的信息使用`usermod`命令，其格式如下：\r\n\r\n```shell\r\nusermod 选项 用户名\r\n```\r\n\r\n下面命令将用户czbk用户名修改成czbk2019\r\n\r\n```shell\r\nusermod -l czbk2019  czbk\r\n```\r\n\r\n![1576046509680](./img/linux/java-linux/Linux-v10-01天-授课/1576046509680.png)\r\n\r\n以下是usermod常用选项\r\n\r\n![1576049946335](./img/linux/java-linux/Linux-v10-01天-授课/1576049946335.png)\r\n\r\n#### 4) 删除用户\r\n\r\n```\r\n相当于我们在Windows系统中删除一个用户，只是我们在CentOS中是删除用户是通过命令完成的。\r\n```\r\n\r\n假如我们其中一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。\r\n\r\n**使用者权限：管理员用户**\r\n\r\n删除一个已有的用户账号使用`userdel`命令，其格式如下：\r\n\r\n```shell\r\nuserdel 选项 用户名\r\n```\r\n\r\n-f：强制删除用户，即使用户当前已登录;\r\n\r\n-r：删除用户的同时，删除与用户相关的所有文件\r\n\r\n此命令删除用户czbk2019\r\n\r\n```shell\r\nuserdel czbk2019\r\n```\r\n\r\n![1576047020612](./img/linux/java-linux/Linux-v10-01天-授课/1576047020612.png)\r\n\r\n成功删除用户czbk2019\r\n\r\n以下是userdel常用选项\r\n\r\n![1576049978916](./img/linux/java-linux/Linux-v10-01天-授课/1576049978916.png)\r\n\r\n### 2.2.2 Linux用户组\r\n\r\n**引子：**\r\n\r\n**为了方便用户管理, 提出了 组 的概念, 如下图所示**\r\n\r\n![1576572808687](./img/linux/java-linux/Linux-v10-01天-授课/1576572808687.png)\r\n\r\n**新增一个账户，它默认属于自己（账户）的组**\r\n\r\n**比如新建账户【张三】，那么它默认对应的组就是张三**\r\n\r\n**一个用户可以有一个或者多个组**\r\n\r\n**假如说（如上图），我们在企业级开发过程中，我们有多个组，其中一个开发组对应三个账户，张三、李四、王五、如果就像上面提到的，一个用户默认对应一个组，那么三个账户张三、李四、王五就有了三个不同的组，如果大家都操做一个文件，在进行权限分配的时候，就要对不同的三个组进行授权，显然这样是不合理的，因为太过繁琐。**\r\n\r\n**所以，才有了组（新建组）的概念，我们把张三、李四、王五统一放到【开发组】，在对文件授权的时候，我们只对【开发组】进行授权由此，这样的话【张三、李四、王五】都有相等的权利操作了。**\r\n\r\n#### 1) 增加用户组\r\n\r\n新增一个用户组（组名可见名知意，符合规范即可），然后将用户添加到组中\r\n\r\n**使用者权限：管理员用户** \r\n\r\n```shell\r\ngroupadd 选项 用户组\r\n```\r\n\r\n使用的选项有：\r\n\r\n- -g GID 指定新用户组的组标识号（GID）。\r\n- -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同\r\n\r\n新增用户组czbk-it\r\n\r\n```shell\r\ngroupadd czbk-it\r\n```\r\n\r\n上面的命令向系统中增加了一个新组czbk-it，新组的组标识号是在当前已有的最大组标识号的基础上加1\r\n\r\n以下是groupadd常用选项\r\n\r\n![1576050003979](./img/linux/java-linux/Linux-v10-01天-授课/1576050003979.png)\r\n\r\n#### 2) 修改用户组\r\n\r\n**使用者权限：管理员用户**\r\n\r\n```shell\r\ngroupmod 选项 用户组\r\n```\r\n\r\n常用的选项有：\r\n\r\n- -g GID 为用户组指定新的组标识号。\r\n- -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。\r\n- -n新用户组 将用户组的名字改为新名字\r\n\r\n```shell\r\ngroupmod  -n czbk-it-2019  czbk-it\r\n```\r\n\r\n上面的命令将组czbk-it的组名修改为czbk-it-2019。\r\n\r\n![1576047810973](./img/linux/java-linux/Linux-v10-01天-授课/1576047810973.png)\r\n\r\n以下是groupmod常用选项\r\n\r\n![1576050645612](./img/linux/java-linux/Linux-v10-01天-授课/1576050645612.png)\r\n\r\n#### 3) 查询用户所属组\r\n\r\n在查询用户所属的用户组前，我们先增加一个用户ituser-groups\r\n\r\n```shell\r\nuseradd ituser-groups\r\n```\r\n\r\n![1576050663149](./img/linux/java-linux/Linux-v10-01天-授课/1576050663149.png)\r\n\r\n要查询一个用户属于哪个用户组，使用groups命令，其格式如下\r\n\r\n```shell\r\ngroups 用户名\r\n```\r\n\r\n查询用户ituser-groups属于某个用户组，执行groups命令\r\n\r\n```shell\r\ngroups ituser-groups\r\n```\r\n\r\n![1576050797421](./img/linux/java-linux/Linux-v10-01天-授课/1576050797421.png)\r\n\r\n由此可见，ituser-groups用户属于用户组ituser-groups（用户组默认与用户名一样）\r\n\r\n#### 4) 删除用户组\r\n\r\n**使用者权限：管理员用户**\r\n\r\n要删除一个已有的用户组，使用groupdel命令，其格式如下\r\n\r\n```shell\r\ngroupdel 用户组\r\n```\r\n\r\n删除czbk-it-2019用户组\r\n\r\n```shell\r\ngroupdel czbk-it-2019\r\n```\r\n\r\n![1576051028346](./img/linux/java-linux/Linux-v10-01天-授课/1576051028346.png)\r\n\r\n删除成功\r\n\r\n以下是groupdel常用选项\r\n\r\n![1576050031859](./img/linux/java-linux/Linux-v10-01天-授课/1576050031859.png)\r\n\r\n### 2.2.3 将用户添加到组\r\n\r\n```\r\n引子：\r\n在上面我们学习如何新增用户，也学习了如何新增用户组，在当前的小节中，我们新建一个用户、新建一个用户组、然后把新建的用户添加到新的组中\r\n在实际开发过程中，我们通常把多个用户按照业务需求归并到统一的一个组中，进行有序管理\r\n```\r\n\r\n1、创建一个新的组，并添加组ID（需要切换到root用户）\r\n\r\n```shell\r\ngroupadd -g 8888 itbj2020group\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576137760529](./img/linux/java-linux/Linux-v10-01天-授课/1576137760529.png)\r\n\r\n2、创建3个用户（需要切换到root用户）\r\n\r\n```shell\r\n useradd  itbeijinguser1\r\n useradd  itbeijinguser2\r\n useradd  itbeijinguser3\r\n```\r\n\r\n3、将上面三个用户添加到组itbj2020group\r\n\r\n我们通过passwd命令将三个用户添加到组\r\n\r\n**什么是gpasswd：**\r\n\r\ngpasswd 是 Linux 下工作组文件 /etc/group 和 /etc/gshadow 管理工具，用于将一个用户添加到组或者从组中删除。\r\n\r\n语法\r\n\r\n```shell\r\ngpasswd [可选项] 组名\r\n```\r\n\r\n**将上面的三个用户使用gpasswd添加到组（需要切换到root用户）**\r\n\r\n```shell\r\ngpasswd -a itbeijinguser1 itbj2020group\r\ngpasswd -a itbeijinguser2 itbj2020group\r\ngpasswd -a itbeijinguser3 itbj2020group\r\n```\r\n\r\n**执行如下**\r\n\r\n![1576139901757](./img/linux/java-linux/Linux-v10-01天-授课/1576139901757.png)\r\n\r\n**查看用户组下所有用户（所有用户）**\r\n\r\n> 注意\r\n>\r\n> 此处的grep命令我们将在文件管理章节详细讲解，这里先使用它查看下效果\r\n\r\n```shell\r\ngrep \'itbj2020group\' /etc/group\r\n```\r\n\r\n执行效果如下（或者直接打开/etc/group文件都可以）\r\n\r\n![1576139987480](./img/linux/java-linux/Linux-v10-01天-授课/1576139987480.png)\r\n\r\n由上图可知：三个用户全部都加入到了itbj2020group组。\r\n\r\n## 2.3 系统管理\r\n\r\n```\r\n系统管理，说的就是我们的CentOS系统，它不同于Windwos，CentOS是字符界面，我们需要通过命令进行操作，在当前章节，我们先从基本命令学起，比如创建用户、设置密码、修改用户以及用户组的相关操作。也为我们后面的章节打下基础\r\n```\r\n\r\n### 2.3.1 日期管理\r\n\r\n```\r\n当前日期如果通过date进行设置，在系统重启后不会保存date的设置，常用的只是通过date命令查看日期\r\n```\r\n\r\ndate 可以用来显示或设定系统的日期与时间\r\n\r\n使用者权限：所有用户\r\n\r\n**语法如下：**\r\n\r\n```shell\r\ndate [参数选项]\r\n```\r\n\r\n参数\r\n\r\n-d<字符串>：显示字符串所指的日期与时间。字符串前后必须加上双引号； \r\n-s<字符串>：根据字符串来设置日期与时间。字符串前后必须加上双引号； \r\n-u：显示GMT； \r\n--help：在线帮助； \r\n--version：显示版本信息\r\n\r\n1、设置时间\r\n\r\n用 -s选项可以设置系统时间，如下：\r\n\r\n```shell\r\ndate -s "2019-12-11 16:15:00"\r\n```\r\n\r\n![1576052178420](./img/linux/java-linux/Linux-v10-01天-授课/1576052178420.png)\r\n\r\n2、显示时间\r\n\r\n```shell\r\ndate\r\n```\r\n\r\n![1576052234012](./img/linux/java-linux/Linux-v10-01天-授课/1576052234012.png)\r\n\r\n**（1）UTC** \r\n\r\n协调世界时，又称世界统一时间、世界标准时间、国际协调时间。由于英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称UTC。。\r\n\r\n**（2）GMT**\r\n\r\n即[格林尼治](https://baike.baidu.com/item/格林尼治/3065623) 平太阳时间，是指格林尼治所在地的标准时间，也是表示地球自转速率的一种形式\r\n\r\n**外文名:**Universal Time\r\n\r\n**其他外文名**G.M.T.(Greenwich Mean Time)\r\n\r\n**（3）CST**\r\n\r\n北京时间 （中国国家标准时间）\r\n**北京时间是中国采用国际时区东八时区的区时作为标准时间**。\r\n北京时间并不是北京（东经116.4°）的地方时间，而是东经120°的地方时间，故东经120度地方时比北京的地方时早约14分半钟。因为北京处于国际时区划分中的东八区，同格林尼治时间（世界时）整整相差8小时（即北京时间=世界时+8小时），故命名为“北京时间”。东八区包括的范围从东经112.5°到东经127.5°，以东经120°为中心线，东西各延伸7.5°，总宽度为15°的区域。\r\n**而中国幅员辽阔，东西相跨5个时区（即东五区、东六区、东七区、东八区、东九区5个时区）授时台必须建在地理中心地带，从而也就产生了长短波授。“北京时间”与“北京当地时间”是两个概念，  “北京时间”的发播不在北京，而在陕西蒲城（处于东七区）**\r\n\r\n**（4）东八区**\r\n\r\n东八区（[UTC](https://baike.baidu.com/item/UTC)/[GMT](https://baike.baidu.com/item/GMT/6026868)+08:00）是比[世界协调时间](https://baike.baidu.com/item/世界协调时间/8036498)（UTC）/[格林尼治时间](https://baike.baidu.com/item/格林尼治时间/410004)（GMT）快8小时的时区，理论上的位置是位于[东经](https://baike.baidu.com/item/东经/8661846)112.5度至127.5度之间，是东盟标准的其中一个候选时区。当格林尼治标准时间为0:00时，东八区的标准时间为08:00\r\n\r\n```\r\n总结：\r\n上面提到了很多知识：即UTC/GMT/CST/东八区\r\n总结一下就是，北京时间(中国国家标准时间CST)采用东八区区时，即：\r\n协调世界时(UTC)+8  /   格林尼治时间(GMT)+8\r\n也就是说+8后的时间才是北京时间\r\n```\r\n\r\n### 2.3.2 显示用户\r\n\r\nlogname命令用于显示用户名称。\r\n\r\n执行logname指令，它会显示目前用户的名称\r\n\r\n**语法为如下：**\r\n\r\n```shell\r\nlogname [--help][--version]\r\n```\r\n\r\n**参数**：\r\n\r\n- --help 　在线帮助。\r\n- --vesion 　显示版本信息。\r\n\r\n显示登录账号的信息\r\n\r\n```shell\r\nlogname\r\n```\r\n\r\n![1576053311351](./img/linux/java-linux/Linux-v10-01天-授课/1576053311351.png)\r\n\r\n### 2.3.3 su切换账户\r\n\r\n```\r\n引子：\r\n比如我们在新增用户、修改用户或者操作用户组的时候常常需要切换到管理员账户，这个时候，我们就可以使用su进行快速切换\r\n```\r\n\r\nsu命令用于变更为其他使用者的身份，除 root 外，需要键入该使用者的密码。\r\n\r\n使用权限：所有使用者。\r\n\r\n**语法如下：**\r\n\r\n```shell\r\nsu \r\n```\r\n\r\n变更帐号为 root 并在执行 ls 指令后退出返回原使用者\r\n\r\n```shell\r\n su -c ls root\r\n```\r\n\r\n![1576054831537](./img/linux/java-linux/Linux-v10-01天-授课/1576054831537.png)\r\n\r\n切换到root\r\n\r\n```shell\r\nsu root\r\n```\r\n\r\n![1576054846742](./img/linux/java-linux/Linux-v10-01天-授课/1576054846742.png)\r\n\r\n这样的话，我们就进入到了root用户下。\r\n\r\n### 2.3.4 id命令\r\n\r\n```\r\n我们如果需要查看当前账号详细信息的时候，比如查看它的用户id、群组id以及所属组的时候，我们就可以使用id命令进行查看\r\n```\r\n\r\n id命令用于显示用户的ID，以及所属群组的ID。\r\n\r\nid会显示用户以及所属群组的实际与有效ID。若两个ID相同，则仅显示实际ID。若仅指定用户名称，则显示目前用户的ID。\r\n\r\n使用者权限：所有用户\r\n\r\n**语法**\r\n\r\n```\r\nid [-gGnru][--help][--version][用户名称]\r\n```\r\n\r\n**参数说明：**\r\n\r\n- -g或--group 　显示用户所属群组的ID。\r\n- -G或--groups 　显示用户所属附加群组的ID。\r\n- -n或--name 　显示用户，所属群组或附加群组的名称。\r\n- -r或--real 　显示实际ID。\r\n- -u或--user 　显示用户ID。\r\n- -help 　显示帮助。\r\n- -version 　显示版本信息。\r\n\r\n**显示当前用户信息**\r\n\r\n```shell\r\nid\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576578213110](./img/linux/java-linux/Linux-v10-01天-授课/1576578213110.png)\r\n\r\n> 总结\r\n>\r\n> id命令参数虽然很多\r\n>\r\n> 但是常用的也就是id命令，不带参数的\r\n>\r\n> 主要看他的uid和组信息\r\n\r\n### 2.3.5 sudo执行\r\n\r\n```\r\n比如我们使用普通用户操作用户或者操作用户组、以及修改网卡配置文件的时候，需要切换到root用户才操作，此时我们可以使用sudo命令提高普通用户的操作权限，以达到操作目的\r\n```\r\n\r\nsudo:控制用户对系统命令的使用权限,root允许的操作。\r\n\r\n通过sudo可以提高普通用户的操作权限\r\n\r\n使用者权限：普通用户\r\n\r\n**语法如下：**\r\n\r\nsudo -V\r\nsudo -h\r\nsudo -l\r\nsudo -v\r\nsudo -k\r\nsudo -s\r\nsudo -H\r\nsudo [ -b ] [ -p prompt ] [ -u username/#uid] -s\r\nsudo command\r\n\r\n**参数说明**：\r\n\r\n- -V 显示版本编号\r\n- -h 会显示版本编号及指令的使用方式说明\r\n- -l 显示出自己（执行 sudo 的使用者）的权限\r\n- -v 因为 sudo 在第一次执行时或是在 N 分钟内没有执行（N 预设为五）会问密码，这个参数是重新做一次确认，如果超过 N 分钟，也会问密码\r\n- -k 将会强迫使用者在下一次执行 sudo 时问密码（不论有没有超过 N 分钟）\r\n- -b 将要执行的指令放在背景执行\r\n- -p prompt 可以更改问密码的提示语，其中 %u 会代换为使用者的帐号名称， %h 会显示主机名称\r\n- -u username/#uid 不加此参数，代表要以 root 的身份执行指令，而加了此参数，可以以 username 的身份执行指令（#uid 为该 username 的使用者号码）\r\n- -s 执行环境变数中的 SHELL 所指定的 shell ，或是 /etc/passwd 里所指定的 shell\r\n- -H 将环境变数中的 HOME 指定为要变更身份的使用者HOME目录（如不加 -u 参数就是系统管理者 root ）\r\n- command 要以系统管理者身份（或以 -u 更改为其他人）执行的指令\r\n\r\nsudo命令使用\r\n\r\n```shell\r\nsudo ls\r\n```\r\n\r\n![1576056341831](./img/linux/java-linux/Linux-v10-01天-授课/1576056341831.png)\r\n\r\n指定root用户执行指令\r\n\r\n```shell\r\nsudo -u root ls -l\r\n```\r\n\r\n![1576056180063](./img/linux/java-linux/Linux-v10-01天-授课/1576056180063.png)\r\n\r\n**修改网卡配置文件**\r\n\r\n比如，在下面的例子中，我们使用普通用户修改网卡的配置文件，在进行保存的时候，提示我们【无法打开并写入文件】，那么此时，我们可以通过sudo命令来提升自己的写入权限\r\n\r\n执行：\r\n\r\n```shell\r\n vi /etc/sysconfig/network-scripts/ifcfg-ens33 \r\n```\r\n\r\n执行效果如下（保存）\r\n\r\n![1576494207598](./img/linux/java-linux/Linux-v10-01天-授课/1576494207598.png)\r\n\r\n然后点击回车\r\n\r\n![1576493914410](./img/linux/java-linux/Linux-v10-01天-授课/1576493914410.png)\r\n\r\n那么我们在修改上面的 命令，使用sudo进行修改\r\n\r\n```shell\r\nsudo   vi /etc/sysconfig/network-scripts/ifcfg-ens33 \r\n```\r\n\r\n执行效果如下（键入itcast密码）\r\n\r\n![1576494108199](./img/linux/java-linux/Linux-v10-01天-授课/1576494108199.png)\r\n\r\n执行保存\r\n\r\n![1576494276066](./img/linux/java-linux/Linux-v10-01天-授课/1576494276066.png)\r\n\r\n我们发现此时就不在报错了\r\n\r\n### 2.3.6 top命令\r\n\r\n```\r\n在企业级开发中，开发人员（运维人员也会经常使用）常常为了查看服务器上运行的程序占用的CPU情况以及占用内存情况，目的就是检测我们的程序是否在正常范围内运行\r\n```\r\n\r\ntop命令用于实时显示 process 的动态。\r\n\r\n使用权限：所有使用者。\r\n\r\n**显示进程信息**\r\n\r\n```shell\r\ntop\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576495173035](./img/linux/java-linux/Linux-v10-01天-授课/1576495173035.png)\r\n\r\n**各进程（任务）的状态监控属性解释说明：**\r\nPID — 进程id\r\nUSER — 进程所有者\r\nPR — 进程优先级\r\nNI — nice值。负值表示高优先级，正值表示低优先级\r\nVIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES\r\nRES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA\r\nSHR — 共享内存大小，单位kb\r\nS — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程\r\n%CPU — 上次更新到现在的CPU时间占用百分比\r\n%MEM — 进程使用的物理内存百分比\r\nTIME+ — 进程使用的CPU时间总计，单位1/100秒\r\nCOMMAND — 进程名称（命令名/命令行）\r\n\r\n**显示完整命令，与top命令不同的就是command属性像是进行了命令补全**\r\n\r\n```shell\r\ntop -c\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576544383182](./img/linux/java-linux/Linux-v10-01天-授课/1576544383182.png)\r\n\r\n**显示指定的进程信息，以下显示进程号为6972的进程信息，CPU、内存占用率等**\r\n\r\n```shell\r\n top -p 6972\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576544720729](./img/linux/java-linux/Linux-v10-01天-授课/1576544720729.png)\r\n\r\n\r\n\r\n> top命令的用法很多\r\n>\r\n> 但是常用的就是top（不带参数），有的时候，在进程比较多的时候，我们常常记住进程的pid，然后通过top -p pid进行查看\r\n>\r\n> 也就是说，top+ top -p是经常被用到的\r\n\r\n###  2.3.7 ps命令\r\n\r\n```\r\nps命令类似于我们在Windows中通过任务管理器查看进程信息\r\n```\r\n\r\nLinux ps命令用于显示当前进程 (process) 的状态信息\r\n\r\n使用者权限：所有用户\r\n\r\n**语法如下：**\r\n\r\n```shell\r\nps \r\n```\r\n\r\n显示进程信息\r\n\r\n```shell\r\nps -A \r\n```\r\n\r\n显示指定用户信息\r\n\r\n```powershell\r\n ps -u itcast\r\n```\r\n\r\n显示所有进程信息 \r\n\r\n```shell\r\nps -ef \r\n```\r\n\r\n### 2.3.8 kill命令\r\n\r\n```\r\n引子：\r\n前面，我们刚刚学习完了Windows上开发，比如，我们经常遇到的要给问题就是，我们需要经常的启动或者重启tomcat，有的时候会报端口冲突，这个时候，我们可能就去Windows的任务管理器中去结束这个进程\r\n那么在Linux中我们可以通过kill命令来实现Windwos上手工结束进程的操作\r\n```\r\n\r\nLinux kill命令用于删除执行中的程序或工作(可强制中断)\r\n\r\n使用者权限：所有用户\r\n\r\n**语法如下：**\r\n\r\n```shell\r\nkill [-s <信息名称或编号>][程序]　或　kill [-l <信息编号>]\r\n```\r\n\r\n **参数说明**：\r\n\r\n- -l <信息编号> 　若不加<信息编号>选项，则-l参数会列出全部的信息名称。\r\n- -s <信息名称或编号> 　指定要送出的信息。\r\n- [程序] 　[程序]可以是程序的PID或是PGID，也可以是工作编号。\r\n\r\n杀死一个进程\r\n\r\n```shell\r\n kill 15642\r\n```\r\n\r\n强制杀死进程\r\n\r\n```shell\r\nkill -KILL 15642\r\n```\r\n\r\n彻底杀死进程\r\n\r\n```shell\r\nkill -9 15642\r\n```\r\n\r\n杀死指定用户所有进程\r\n\r\n1.方法一 过滤出itcast用户进程 \r\n\r\n```shell\r\nkill -9 $(ps -ef | grep itcast) \r\n```\r\n\r\n2.方法二，直接杀死\r\n\r\n```shell\r\nkill -u itcast\r\n```\r\n\r\n> 注意\r\n>\r\n> 上面列举了很多kill进程的命令\r\n>\r\n> 但是我们我们常用的就是kill -9命令，我们常常找到进程的pid\r\n>\r\n> 然后通过kill -9进行杀死进程\r\n\r\n### 2.3.9 关机命令\r\n\r\nshutdown命令可以用来进行关闭系统，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机\r\n\r\n使用者权限：管理员用户\r\n\r\n**语法如下：**\r\n\r\n```shell\r\nshutdown [-t seconds] [-rkhncfF] time [message]\r\n```\r\n\r\n**参数说明**：\r\n\r\n- -t seconds : 设定在几秒钟之后进行关机程序。\r\n- -k : 并不会真的关机，只是将警告讯息传送给所有使用者。\r\n- -r : 关机后重新开机。\r\n- -h : 关机后停机。\r\n- -n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。\r\n- -c : 取消目前已经进行中的关机动作。\r\n- -f : 关机时，不做 fcsk 动作(检查 Linux 档系统)。\r\n- -F : 关机时，强迫进行 fsck 动作。\r\n- time : 设定关机的时间。\r\n- message : 传送给所有使用者的警告讯息。\r\n\r\n立即关机\r\n\r\n```shell\r\nshutdown -h now\r\n或者\r\nshudown\r\n```\r\n\r\n指定1分钟后关机，1分钟关机并显示警告信息\r\n\r\n```shell\r\nshutdown +1 “System will shutdown after 1 minutes” \r\n```\r\n\r\n![1576059932470](./img/linux/java-linux/Linux-v10-01天-授课/1576059932470.png)\r\n\r\n指定1分钟后重启，并发出警告信息\r\n\r\n```shell\r\nshutdown –r +1 “1分钟后关机重启”\r\n```\r\n\r\n![1576060232485](./img/linux/java-linux/Linux-v10-01天-授课/1576060232485.png)\r\n\r\n### 2.3.10 重启命令\r\n\r\nreboot命令用于用来重新启动计算机\r\n\r\n使用者权限：管理员、普通（需要验证）用户\r\n\r\n**语法如下：**\r\n\r\n```shell\r\nreboot [-n] [-w] [-d] [-f] [-i]\r\n```\r\n\r\n**参数**：\r\n\r\n- -n : 在重开机前不做将记忆体资料写回硬盘的动作\r\n- -w : 并不会真的重开机，只是把记录写到 /var/log/wtmp 档案里\r\n- -d : 不把记录写到 /var/log/wtmp 档案里（-n 这个参数包含了 -d）\r\n- -f : 强迫重开机，不呼叫 shutdown 这个指令\r\n- -i : 在重开机之前先把所有网络相关的装置先停止\r\n\r\n开始重新启动\r\n\r\n```shell\r\nreboot\r\n```\r\n\r\n重启效果如下\r\n\r\n![1576136722927](./img/linux/java-linux/Linux-v10-01天-授课/1576136722927.png)\r\n\r\n此时我们的虚拟机正在重启**（别忘记使用root用户执行）**\r\n\r\n### 2.3.11 who命令\r\n\r\n```\r\n在企业级开发过程中，我们使用who命令的时候常常需要快速重启服务器，在重启之前需要检测下有没有终端在连接（处理程序），如果有，可能就不会重启（会私下询问何时弄完，弄完后在重启），如果没有其他人连接，将执行快速重启\r\n```\r\n\r\nwho命令用于显示系统中有哪些使用者正在上面，显示的资料包含了使用者 ID、使用的终端机、从哪边连上来的、上线时间、呆滞时间、CPU 使用量、动作等等\r\n\r\n使用者权限：所有使用者都可使用。\r\n\r\n**语法如下：**\r\n\r\n```shell\r\nwho - [husfV] [user]\r\n```\r\n\r\n**参数说明**：\r\n\r\n- -H 或 --heading：显示各栏位的标题信息列；\r\n- -i 或 -u 或 --idle：显示闲置时间，若该用户在前一分钟之内有进行任何动作，将标示成"."号，如果该用户已超过24小时没有任何动作，则标示出"old"字符串；\r\n- -m：此参数的效果和指定"am i"字符串相同；\r\n- -q 或--count：只显示登入系统的帐号名称和总人数；\r\n- -s：此参数将忽略不予处理，仅负责解决who指令其他版本的兼容性问题；\r\n- -w 或-T或--mesg或--message或--writable：显示用户的信息状态栏；\r\n- --help：在线帮助；\r\n- --version：显示版本信息\r\n\r\n显示当前登录系统的用户\r\n\r\n```shell\r\nwho\r\n```\r\n\r\n![1576143161044](./img/linux/java-linux/Linux-v10-01天-授课/1576143161044.png)\r\n\r\n显示明细(标题)信息\r\n\r\n```shell\r\nwho -H\r\n```\r\n\r\n![1576143218612](./img/linux/java-linux/Linux-v10-01天-授课/1576143218612.png)\r\n\r\n由上图可知，截止到现在只有itcast在线。\r\n\r\n### 2.3.12 timedatectl命令\r\n\r\n```\r\n引子：\r\ntimedatectl是用于控制系统时间和日期。可以用来查询和更改系统时钟于设定，同时可以设定和修改时区信息。\r\n\r\n在实际开发过程中，系统时间的显示会和实际出现不同步；我们一般为了校正服务器时间、时区的时候会使用timedatectl命令\r\n```\r\n\r\n使用者权限：所有使用者都可使用，设置时间需要管理员，下面会标注。\r\n\r\n几个常见的概念，进行总结如下：\r\n\r\n![1576550880532](./img/linux/java-linux/Linux-v10-01天-授课/1576550880532.png)\r\n\r\n**显示系统的当前时间和日期，使用命令行中的timedatectl命令**\r\n\r\n```SHELL\r\ntimedatectl status\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576147390352](./img/linux/java-linux/Linux-v10-01天-授课/1576147390352.png)\r\n\r\n在上面的示例中，分别显示时区、CST时间和UTC时间，其中,RTC time就是硬件时钟的时间，硬件时间默认为UTC。\r\n\r\n**查看当前时区**\r\n\r\n```shell\r\ntimedatectl | grep Time\r\n或者\r\ntimedatectl \r\n```\r\n\r\n执行效果如下\r\n\r\n![1576147504533](./img/linux/java-linux/Linux-v10-01天-授课/1576147504533.png)\r\n\r\n上图显示中国时区\r\n\r\n**查看所有可用的时区**\r\n\r\n```\r\ntimedatectl list-timezones\r\n```\r\n\r\n执行效果如下（下面数据没有截全）\r\n\r\n![1576147567622](./img/linux/java-linux/Linux-v10-01天-授课/1576147567622.png)\r\n\r\n**设置本地时区**\r\n\r\n```shell\r\ntimedatectl set-timezone "Asia/Shanghai"\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576147666007](./img/linux/java-linux/Linux-v10-01天-授课/1576147666007.png)\r\n\r\n**禁用时间同步（使用管理员账户）**\r\n\r\n```shell\r\ntimedatectl set-ntp false\r\n在执行\r\ntimedatectl set-time "2019-03-11 20:45:00"\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576148429123](./img/linux/java-linux/Linux-v10-01天-授课/1576148429123.png)\r\n\r\n> 注意: 如果ntp时间同步为true时无法修改时间设定，下面马上介绍\r\n\r\n**打开ntp**\r\n\r\n```shell\r\ntimedatectl set-ntp true\r\n在执行\r\ntimedatectl set-time "2019-03-11 20:45:00"\r\n```\r\n\r\n执行效果如下（ntp时间同步为true时无法修改时间设定）\r\n\r\n报错信息 如下\r\n\r\n![1576226884267](./img/linux/java-linux/Linux-v10-01天-授课/1576226884267.png)\r\n\r\n**启用时间同步**\r\n\r\nNTP即Network Time Protocol（网络时间协议），是一个互联网协议，用于同步计算机之间的系统时钟。timedatectl实用程序可以自动同步你的Linux系统时钟到使用NTP的远程服务器。\r\n\r\n要开始自动时间同步到远程NTP服务器，在终端键入以下命令。\r\n\r\n```shell\r\ntimedatectl set-ntp true\r\n```\r\n\r\n比如，在上面我们使用timedatectl set-time "2019-03-11 20:45:00"，如下图\r\n\r\n![1576229638059](./img/linux/java-linux/Linux-v10-01天-授课/1576229638059.png)\r\n\r\n此时我们执行timedatectl set-ntp true，发现时间正常同步过来了如下图\r\n\r\n![1576229679265](./img/linux/java-linux/Linux-v10-01天-授课/1576229679265.png)\r\n\r\n要禁用NTP时间同步，在终端键入以下命令\r\n\r\n```shell\r\ntimedatectl set-ntp false\r\n```\r\n\r\n执行上面的 命令即可关闭ntp\r\n\r\n> 总结\r\n>\r\n> 在实际使用过程中\r\n>\r\n> 我们经常使用timedatectl进行时区、CST、UTC的设置\r\n\r\n\r\n\r\n### 2.3.13 clear命令\r\n\r\n clear命令用于清除屏幕\r\n\r\n使用者权限：所有使用者都可使用。\r\n\r\n**语法**\r\n\r\n```shell\r\nclear\r\n```\r\n\r\n执行clear前\r\n\r\n![1576230100277](./img/linux/java-linux/Linux-v10-01天-授课/1576230100277.png)\r\n\r\n执行clear后\r\n\r\n![1576230123895](./img/linux/java-linux/Linux-v10-01天-授课/1576230123895.png)\r\n\r\n通过执行clear命令，就可以把缓冲区的命令全部清理干净了\r\n\r\n### **2.3.14 exit命令**\r\n\r\nexit命令用于退出目前的shell。\r\n\r\n执行exit可使shell以指定的状态值退出。若不设置状态值参数，则shell以预设值退出。状态值0代表执行成功，其他值代表执行失败。exit也可用在script，离开正在执行的script，回到shell。\r\n\r\n```\r\n退出码（exit status，或exit code）的约定：\r\n\r\n0表示成功（Zero - Success）\r\n\r\n非0表示失败（Non-Zero  - Failure）\r\n\r\n2表示用法不当（Incorrect Usage）\r\n\r\n127表示命令没有找到（Command Not Found）\r\n\r\n126表示不是可执行的（Not an executable）\r\n\r\n>=128 信号产生\r\n```\r\n\r\n**语法如下**\r\n\r\n```shell\r\nexit [状态值]\r\n```\r\n\r\n退出终端\r\n\r\n```shell\r\n# exit\r\n```\r\n\r\n> exit会被经常在shell中使用\r\n>\r\n> 我们在明天的课程【综合案例】中会使用到exit\r\n\r\n## 2.4 总结\r\n\r\n用户账号管理和用户组是我们在实际使用过程中常用的命令，学习完创建账号、创建组后，需要通过gpasswd命令将用户添加到组，这也是我们学习的最终目的\r\n\r\n系统管理的常用命令都是在开发过程中经常使用到的\r\n\r\n# 3 Linux目录管理\r\n\r\n```\r\n注意：\r\n在下面的讲解中，每个命令都有很多的参数说明（选项），我们只讲其中的几个，关键是让学生掌握命令的语法；学生学习完语法后，就可以自己按照参数书写各种命令，这也是我们最终的目的。常用命令，我们在企业级开发过程中，经常书写的命令。会非常被容易记住，不常用的命令，只要我们学习完了语法之后，在去查找参数手册，会非常容易的解决我们的问题，所以，每个命令不是建立在死记硬背的基础上的，要理解语法+查找参数=解决问题\r\n```\r\n\r\n## 3.1 Linux 文件与目录管理\r\n\r\n```\r\n在Linux系统中，所有的的目录结构为树状结构，最顶级的目录为根目录 /。\r\n在实际开发过程中，文件的操作是非常频繁也是非常重要的\r\n下面的章节我们将学习下Linux系统所有的系统目录和文件通过命令是如何进行管理的 \r\n```\r\n\r\n### 3.1.1 目录常用命令\r\n\r\n- ls:         列出目录\r\n- cd：     切换目录\r\n- pwd：  显示目前的目录\r\n- mkdir：创建一个新的目录\r\n- rmdir：删除一个空的目录\r\n- cp:         复制文件或目录\r\n- rm:        移除文件或目录\r\n- mv:        移动文件与目录或修改文件与目录的名称\r\n\r\n**自动补全**\r\n\r\n- 在敲出 文件/ 目录 / 命令 的前几个字母之后, 按下 `tab`键\r\n- 如果还存在其他 文件 / 目录 / 命令, 再按一下tab键, 系统会提示可能存在的命令\r\n\r\n#### 1) ls (列出目录)\r\n\r\n```\r\nls命令相当于我们在Windows系统中打开磁盘、或者打开文件夹看到的目录以及文件的明细，如下图\r\n```\r\n\r\n【查看磁盘下的目录与文件】\r\n\r\n![1576564124577](./img/linux/java-linux/Linux-v10-01天-授课/1576564124577.png)\r\n\r\n【查看文件夹下的目录与文件】\r\n\r\n![1576564161701](./img/linux/java-linux/Linux-v10-01天-授课/1576564161701.png)\r\n\r\n\r\n\r\n注意：在Linux系统当中， ls 命令算是比较常用的命令\r\n\r\n使用者权限：所有使用者都可使用。\r\n\r\n**语法如下：**\r\n\r\n```\r\nls [选项]  目录名称\r\n```\r\n\r\n**选项与参数：**\r\n\r\n- -a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来(常用)\r\n- -d ：仅列出目录本身，而不是列出目录内的文件数据(常用)\r\n- -l ：长数据串列出，包含文件的属性与权限等等数据；(常用)\r\n\r\n**将根目录下的所有文件列出来(含属性与隐藏档)**\r\n\r\n```\r\n ls -al ~\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576553470716](./img/linux/java-linux/Linux-v10-01天-授课/1576553470716.png)\r\n\r\n```\r\n ls -l\r\n```\r\n\r\n![1576639252612](./img/linux/java-linux/Linux-v10-01天-授课/1576639252612.png)\r\n\r\n`ls -l` 可以查看文件夹下文件的详细信息, 从左到右 依次是:\r\n\r\n- **权限（A区域）**, 第一个字符如果是 `d` 表示目录\r\n- **硬链接数（B区域）**, 通俗的讲就是有多少种方式, 可以访问当前目录和文件\r\n- **属主（C区域）**, 文件是所有者、或是叫做属主\r\n- **属组（D区域）**, 文件属于哪个组\r\n- **大小（E区域）：文件大小**\r\n- **时间（F区域）：最后一次访问时间**\r\n- **名称（G区域）:文件的名称**\r\n\r\n```\r\nls\r\n```\r\n\r\n![1576553646036](./img/linux/java-linux/Linux-v10-01天-授课/1576553646036.png)\r\n\r\n```\r\n总结\r\n以上三种是经常被使用到的命令\r\n它们之间的区别是\r\nls  显示不隐藏的文件与文件夹\r\nls -l 显示不隐藏的文件与文件夹的详细信息\r\nls -al   显示所有文件与文件夹的详细信息\r\n```\r\n\r\n#### 2) pwd显示当前目录\r\n\r\n```\r\n执行pwd命令相当于我们在Windows系统路径导航栏中查看到的当前浏览位置信息\r\n```\r\n\r\n如下图\r\n\r\n![1576564294612](./img/linux/java-linux/Linux-v10-01天-授课/1576564294612.png)\r\n\r\n\r\n\r\npwd 是 **Print Working Directory** 的缩写，也就是显示目前所在当前目录的命令。\r\n\r\n使用者权限：所有使用者都可使用。\r\n\r\n**查看当前所在目录**\r\n\r\n```\r\npwd -P\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576552719245](./img/linux/java-linux/Linux-v10-01天-授课/1576552719245.png)\r\n\r\n#### 3) cd (切换目录)\r\n\r\n```\r\nLinux的cd切换目录，相当于我们在Windows中通过鼠标或者快捷键点开不同的目录\r\n```\r\n\r\n注意：在Linux系统当中， cd 命令算是比较常用的命令\r\n\r\ncd是Change Directory的缩写，这是用来变换工作目录的命令\r\n\r\n使用者权限：所有使用者都可使用。\r\n\r\n**语法如下：**\r\n\r\n```\r\n cd [相对路径或绝对路径]\r\n```\r\n\r\n在正式学习cd命令前面，我们通过下面一个座位图的形式讲解下相对路径和绝对路径是怎么表现的。\r\n\r\n![1576465885337](./img/linux/java-linux/Linux-v10-01天-授课/1576465885337.png)\r\n\r\n\r\n\r\n- **绝对路径：**\r\n  路径的写法，由根目录 / 写起，例如： /usr/share/doc 这个目录。\r\n- **相对路径：**\r\n  路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成： cd ../man 这就是相对路径的写法啦！\r\n\r\n**1、使用相对路径定位目标**\r\n\r\n- 特征:  **相对路径** 输入路径时, 最前面不是以 "/" 开始的, 表示相对 **当前目录** 所在的位置\r\n- 缺点:  参照工作目录 发生变化 相对路径也要发生变化\r\n\r\n```\r\n需求1: 当前工作目录是 /usr, 使用相对路径 切换到 /usr/tmp 目录下 \r\n\r\n需求2: 当前工作目录是 /root, 使用相对路径 切换到 /usr/tmp 目录下 \r\n```\r\n\r\n![1576466126779](./img/linux/java-linux/Linux-v10-01天-授课/1576466126779.png)\r\n\r\n执行效果如下\r\n\r\n```\r\n注意：\r\ncd ~ 表示回到根目录\r\n```\r\n\r\n![1576466284360](./img/linux/java-linux/Linux-v10-01天-授课/1576466284360.png)\r\n\r\n**2、使用绝对路径定位目标**\r\n\r\n- 特征: **绝对路径** 在输入路径时, 最前面是以 `/`  开始的, 表示 从 **根目录** 开始的具体目录位置\r\n- 优点: 定位准确, 不会因为 工作目录变化 而变化\r\n\r\n```\r\n需求1: 当前工作目录是 /usr, 使用绝对路径 切换到 /usr/tmp 目录下 \r\n\r\n需求2: 当前工作目录是 /root, 使用绝对路径 切换到 /usr/tmp 目录下 \r\n```\r\n\r\n![1576466413099](./img/linux/java-linux/Linux-v10-01天-授课/1576466413099.png)\r\n\r\n执行效果如下\r\n\r\n![1576466506750](./img/linux/java-linux/Linux-v10-01天-授课/1576466506750.png)\r\n\r\n> 总结\r\n>\r\n> - **相对路径** 在输入路径时, 最前面不是以 `/` 开始的 , 表示相对 **当前目录** 所在的目录位置\r\n> - **绝对路径** 在输入路径时, 最前面是以 `/`  开始的, 表示 从 **根目录** 开始的具体目录位置\r\n\r\n\r\n\r\n#### 4) mkdir(创建目录)\r\n\r\n```\r\n引子：\r\nLinux的mkdir命令相当于我们在Windows中通过鼠标或者快捷键新建文件夹\r\n```\r\n\r\nmkdir命令用于建立名称为 dirName 之子目录\r\n\r\n使用权限：于目前目录有适当权限的所有使用者\r\n\r\n**语法**\r\n\r\n```\r\nmkdir [-p] dirName\r\n```\r\n\r\n**参数说明：**\r\n\r\n- -p 确保目录名称存在，不存在的就建一个\r\n\r\n建立一个名为jinyanlong 的子目录\r\n\r\n```shell\r\nmkdir jinyanlong\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576553229832](./img/linux/java-linux/Linux-v10-01天-授课/1576553229832.png)\r\n\r\n查看新建的 文件\r\n\r\n![1576553205885](./img/linux/java-linux/Linux-v10-01天-授课/1576553205885.png)\r\n\r\n在工作目录下的 aaa目录中，建立一个名为 bbb的子目录。 若 aaa目录原本不存在，则建立一个。（注：本例若不加 -p，且原本 aaa目录不存在，则产生错误。）\r\n\r\n```shell\r\nmkdir -p aaa/bbb\r\n```\r\n\r\n执行效果如下\r\n\r\n> 这里为了显示更直观，我们使用了tree命令\r\n>\r\n> 后面在讲解到yum的时候，会详细讲解\r\n>\r\n> 此处先使用\r\n\r\n![1576560522053](./img/linux/java-linux/Linux-v10-01天-授课/1576560522053.png)\r\n\r\n由上图我们发现，aaa目录被强制创建，里面包含了bbb文件。\r\n\r\n#### **5) rmdir(删空目录)**\r\n\r\n```\r\nLinux的rmdir命令相当于我们在Windows中通过鼠标或者快捷键删除文件夹。\r\n稍微有点不同的就是在Linux中删除子目录的时候，如果主目录下没有了目录以及文件，会连同主目录同时删除了（需要写Linux带有P的参数）\r\n```\r\n\r\nrmdir命令删除空的目录\r\n\r\n使用权限：于目前目录有适当权限的所有使用者。\r\n\r\n**语法**\r\n\r\n```shell\r\nrmdir [-p] dirName\r\n```\r\n\r\n**参数**：\r\n\r\n- -p 是当子目录被删除后使它也成为空目录的话，则顺便一并删除。\r\n\r\n**将工作目录下，名为 jinyanlong 的子目录删除 :**\r\n\r\n```shell\r\nrmdir jinyanlong\r\n```\r\n\r\n**在工作目录下的 aaa目录中，删除名为 bbb的子目录。若 bbb删除后，aaa目录成为空目录，则 aaa同时也会被删除**\r\n\r\n```shell\r\nrmdir  -p aaa/bbb\r\n```\r\n\r\n> 总结：\r\n>\r\n> rmdir  -p aaa/bbb也就是说\r\n>\r\n> 在删除bbb目录完成后，发现aaa目录也是空目录了，在删除完bbb后aaa也同时被删除了。\r\n\r\n#### 6) cp(文件复制)\r\n\r\n```\r\nLinux的cp命令相当于我们在Windows中通过鼠标或者快捷键复制文件或者目录\r\n```\r\n\r\ncp命令主要用于复制文件或目录。\r\n\r\n使用权限：于目前目录有适当权限的所有使用者\r\n\r\n**语法**\r\n\r\n```shell\r\ncp [options] source dest\r\n```\r\n\r\n或\r\n\r\n```shell\r\ncp [options] source... directory\r\n```\r\n\r\n**参数说明：**\r\n\r\n- -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。\r\n- -d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。\r\n- -f：覆盖已经存在的目标文件而不给出提示。\r\n- -i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答"y"时目标文件将被覆盖。\r\n- -p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。\r\n- -r/R：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。\r\n- -l：不复制文件，只是生成链接文件。\r\n\r\n我们将当前目录"aaa/"下的所有目录以及文件复制到新目录"ccc"下，输入如下命令：\r\n\r\n**1、数据准备**\r\n\r\n创建aaa目录并且aaa下包含bbb目录\r\n\r\n```shell\r\nmkdir -p aaa/bbb\r\nmkdir -p ccc\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576561579056](./img/linux/java-linux/Linux-v10-01天-授课/1576561579056.png)\r\n\r\naaa目录下有bbb\r\n\r\nccc下面没有目录和文件\r\n\r\n**2、执行复制**\r\n\r\n```shell\r\ncp –r aaa/*  ccc  \r\n```\r\n\r\n执行效果如下\r\n\r\n我们将aaa下面的所有文件、目录复制到了目录c下面\r\n\r\n![1576562978352](./img/linux/java-linux/Linux-v10-01天-授课/1576562978352.png)\r\n\r\n> 总结：\r\n>\r\n> 用户使用该指令复制目录时，必须使用参数"-r"或者"-R"。\r\n>\r\n> 如果不加参数"-r"或者"-R",只复制文件，而略过目录\r\n\r\n#### 7) rm(删除目录)\r\n\r\n```\r\nLinux的rm命令相当于我们在Windows中通过鼠标或者快捷键删除文件或者目录\r\n```\r\n\r\nrm命令用于删除一个文件或者目录。\r\n\r\n使用权限：于目前目录有适当权限的所有使用者\r\n\r\n**语法**\r\n\r\n```shell\r\nrm [options] name...\r\n```\r\n\r\n**参数：**\r\n\r\n- -i 删除前逐一询问确认。\r\n- -f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。\r\n- -r 将目录及以下之档案亦逐一删除。\r\n\r\n如果我们要删除文件可以直接使用rm命令，若删除目录则必须配合选项"-r"，例如：\r\n\r\n![1576563524635](./img/linux/java-linux/Linux-v10-01天-授课/1576563524635.png)\r\n\r\n```shell\r\nrm -r  ccc\r\n```\r\n\r\n执行删除，如下图\r\n\r\n![1576563827977](./img/linux/java-linux/Linux-v10-01天-授课/1576563827977.png)\r\n\r\n> 注意\r\n>\r\n> 文件一旦通过rm命令删除，则无法恢复，所以必须格外小心地使用该命令\r\n>\r\n> 如果删除文件（比如.sh 、.txt）\r\n>\r\n> 直接使用rm  name.txt\r\n\r\n#### 8) mv(移动文件)\r\n\r\n```\r\nLinux的mv命令相当于我们在Windows中通过鼠标或者快捷键剪切（+重命名）+粘贴文件或者目录\r\n```\r\n\r\nmv 命令用来为文件或目录改名、或将文件或目录移入其它位置\r\n\r\n**语法**\r\n\r\n```shell\r\nmv [options] source dest\r\nmv [options] source... directory\r\n```\r\n\r\n**参数说明：**\r\n\r\n- -i: 若指定目录已有同名文件，则先询问是否覆盖旧文件;\r\n- -f: 在 mv 操作要覆盖某已有的目标文件时不给任何指示;\r\n\r\n![1576565378463](./img/linux/java-linux/Linux-v10-01天-授课/1576565378463.png)\r\n\r\n将文件 aaa 更名为 bbb :\r\n\r\n![1576565459075](./img/linux/java-linux/Linux-v10-01天-授课/1576565459075.png)\r\n\r\n```shell\r\n1、创建aaa目录、\r\nmkdir  aaa\r\n2、开始重命名\r\nmv aaa bbb\r\n```\r\n\r\n执行后\r\n\r\n![1576565489569](./img/linux/java-linux/Linux-v10-01天-授课/1576565489569.png)\r\n\r\n将ccc目录放入ddd目录中。\r\n\r\n注意，如果ddd目录不存在，则该命令将ccc改名为ddd。\r\n\r\n```shell\r\n创建ccc\r\nmkdir ccc\r\n```\r\n\r\n![1576565710078](./img/linux/java-linux/Linux-v10-01天-授课/1576565710078.png)\r\n\r\n```shell\r\n开始移动\r\nmv ccc/ ddd \r\n```\r\n\r\n![1576565800010](./img/linux/java-linux/Linux-v10-01天-授课/1576565800010.png)\r\n\r\n由上图我们发现，由于ddd目录不存在，所以在mv的时候将ccc目录改名为了ddd。\r\n\r\n## 3.2 Linux 文件基本属性\r\n\r\n```\r\n在Wndows系统中，我们可以选中一个文件，右键属性，可以查看到这个文件的文件类型（基本信息），以及文件的权限信息，在Linux中，它是通过不同字符的排序顺序来表示文件的类型以及权限所属信息的。\r\n```\r\n\r\nLinux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。\r\n\r\n下面我们就一起学习下Linux系统不同权限的文件和目录在怎么表示的\r\n\r\n在Linux中我们可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组，如：\r\n\r\n```shell\r\nls -l\r\n```\r\n\r\n![1576032746450](./img/linux/java-linux/Linux-v10-01天-授课/1576032746450.png)\r\n\r\n实例中，bin文件的第一个属性用"d"表示。"d"在Linux中代表该文件是一个目录文件。\r\n\r\n在Linux中第一个字符代表这个文件是目录、文件或链接文件等等。\r\n\r\n- 当为[ **d** ]则是目录\r\n- 当为[ **-** ]则是文件；\r\n- 若是[ **l** ]则表示为链接文档(link file)；\r\n- 若是[ **b** ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；\r\n- 若是[ **c** ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。\r\n\r\n接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。\r\n\r\n每个文件的属性由左边第一部分的10个字符来确定（如下图）。\r\n\r\n![1576460571985](./img/linux/java-linux/Linux-v10-01天-授课/1576460571985.png)\r\n\r\n从左至右用0-9这些数字来表示。\r\n\r\n第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。\r\n\r\n第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。\r\n\r\n\r\n\r\n其中，第1、4、7位表示读权限，如果用"r"字符表示，则有读权限，如果用"-"字符表示，则没有读权限；\r\n\r\n第2、5、8位表示写权限，如果用"w"字符表示，则有写权限，如果用"-"字符表示没有写权限；第3、6、9位表示可执行权限，如果用"x"字符表示，则有执行权限，如果用"-"字符表示，则没有执行权限。\r\n\r\n## 3.3 Linux文件属主和属组\r\n\r\n```\r\n引子：\r\n对于一个文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。\r\n也就是所谓的属主，它属于哪个用户的意思。\r\n除了属主，还有属组，也就是说，这个文件是属于哪个组的（用户所属的组）。\r\n文件的【属主】有一套【读写执行权限rwx】\r\n文件的【属组】有一套【读写执行权限rwx】\r\n还有它权限，下面我们在介绍\r\n```\r\n\r\n![1576402570345](./img/linux/java-linux/Linux-v10-01天-授课/1576402570345.png)\r\n\r\n在以上实例中，aaa文件是一个目录文件，属主和属组都为 itcast，属主有可读、可写、可执行的权限（rwx）；与属主同组的其他用户有可读可写和可执行的权限（rwx）；其他用户也有可读和可执行的权限（r-x）。\r\n\r\n### **3.3.1 chgrp更改属组**\r\n\r\n```\r\n实际开发中我们经常会创建新建目录和文件，一般情况下，通过命令进行新建，\r\n在创建完成后，使用不同的用户访问，可能就会出现报错，无法访问等等问题。\r\n然后经过一番这查找,发现该有的文件都在，大小写也没问题，路径也没问题\r\n其实并不是这些问题。而是权限问题导致我们无法访问！是因为一个文件默认隶属于一个属组，而使用其他用户访问这个文件肯定无法访问(因为访问用户所属的组和文件所在的不是同一个组)\r\n那么怎么可以正常访问呢？其实就是通过更改用户组（用户组、文件组）来解决这些问题\r\n```\r\n\r\nchgrp命令用于变更文件或目录的所属群组。\r\n\r\n文件或目录权限的的拥有者由所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可\r\n\r\n为了方便初学者记忆，可以将 chgrp 理解为是 "change group" 的缩写\r\n\r\n**语法如下**\r\n\r\n```\r\nchgrp [-cfhRv][--help][--version][所属群组][文件或目录...] 或 chgrp [-cfhRv][--help][--reference=<参考文件或目录>][--version][文件或目录...]\r\n```\r\n\r\n**改变文件的群组属性**\r\n\r\n我们通过root用户进入（如下图），上接上面的例子\r\n\r\n我们的aaa文件的属主和属组都属于itcast（如下图）\r\n\r\n![1576407437975](./img/linux/java-linux/Linux-v10-01天-授课/1576407437975.png)\r\n\r\n我们现在通过chgrp命令将文件aaa的属组更改成root（其他也可以）\r\n\r\n```shell\r\nchgrp -v root aaa\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576407536566](./img/linux/java-linux/Linux-v10-01天-授课/1576407536566.png)\r\n\r\n我们通过下面的命令查询文件aaa的属组是否发生了变化，执行\r\n\r\n```\r\nls -l\r\n```\r\n\r\n![1576407585301](./img/linux/java-linux/Linux-v10-01天-授课/1576407585301.png)\r\n\r\n由上图我们发现，文件aaa的属组由itcast变成了root\r\n\r\n这样的话，文件的属组就发生了变化。\r\n\r\n\r\n\r\n### 3.3.2 chown更改属主和属组**\r\n\r\n```\r\n我们为了让一些用户有权限查看某一文档，比如是一个时间表，而编写时间表的人要具有读写执行的权限(属主)\r\n我们想让一些用户知道这个时间表的内容，而不让他们修改，所以我们可以把这些用户都划到一个组（属组），然后来修改这个文件的权限，让用户组可读，这样用户组下面的每个用户都是可读的\r\n```\r\n\r\nLinux是多任务操作系统，所有的档案皆有拥有者。利用 chown 可以将档案的拥有者加以改变。一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的档案拥有者，也没有权限可以自己的档案拥有者改设为别人。只有系统管理者(root)才有这样的权限\r\n\r\n使用权限 : 管理员账户\r\n\r\n**语法如下**\r\n\r\n```\r\nchown [–R] 属主名 文件名\r\nchown [-R] 属主名：属组名 文件名\r\n```\r\n\r\n我们通过root用户进入（如下图），上接上面的例子\r\n\r\n我们的aaa文件的属主属于itcast、属组属于root\r\n\r\n我们现在通过chgrp命令将文件aaa的属主更改成root，执行\r\n\r\n```\r\n chown  root aaa\r\n```\r\n\r\n效果如下\r\n\r\n![1576407880885](./img/linux/java-linux/Linux-v10-01天-授课/1576407880885.png)\r\n\r\n我们通过下面的命令查询文件aaa的属主是否发生了变化，执行\r\n\r\n```\r\nls -l\r\n```\r\n\r\n![1576407928200](./img/linux/java-linux/Linux-v10-01天-授课/1576407928200.png)\r\n\r\n由上图我们发现，文件aaa的属主和属组都变成了root。\r\n\r\n**我们将aaa文件的拥有者与群组改回为itcast：**\r\n\r\n注意：chown命令可以更改属主和属组\r\n\r\n```\r\nchown itcast:itcast aaa\r\n```\r\n\r\n我们通过下面的命令查询文件aaa的属主是否发生了变化，执行\r\n\r\n```\r\nls -l\r\n```\r\n\r\n![1576408146911](./img/linux/java-linux/Linux-v10-01天-授课/1576408146911.png)\r\n\r\n由上图可知，aaa文件的属主和属组都被更改回来了。\r\n\r\n### 3.3.3 chmod权限命令\r\n\r\nLinux文件属性有两种设置方法，一种是数字，一种是符号\r\n\r\nLinux的文件调用权限分为三级 : 文件属主、属组、其他。利用 chmod 可以控制文件如何被他人所调用。\r\n\r\n**使用权限 : 所有使用者**\r\n\r\n**语法**\r\n\r\n```\r\nchmod [-cfvR] [--help] [--version] mode file...\r\n```\r\n\r\n**参数说明**\r\n\r\n\r\nmode : 权限设定字串，格式如下\r\n\r\n```\r\n[ugoa...][[+-=][rwxX]...][,...]\r\n```\r\n\r\n**解释：**\r\n\r\nu 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。\r\n\r\n+表示增加权限、- 表示取消权限、= 表示唯一设定权限。\r\nr 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。\r\n\r\n#### **1) 数字权限**\r\n\r\nLinux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。\r\n\r\n先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组（owner/group/others就是所说的三个一组 ）的，我们也可以使用数字来代表各个权限，各权限的分数对照表如下\r\n\r\n各权限的数字对照表：[r]:4;[w]:2;[x]:1;[-]:**0**\r\n\r\n![1576571902684](./img/linux/java-linux/Linux-v10-01天-授课/1576571902684.png)\r\n\r\n每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx---] 分数则是：\r\n\r\n- owner = rwx = 4+2+1 = 7\r\n- group = rwx = 4+2+1 = 7\r\n- others= --- = 0+0+0 = 0\r\n\r\n所以等一下我们设定权限的变更时，该文件的权限数字就是770啦,变更权限的指令chmod的语法是这样的\r\n\r\n```\r\nchmod [-R] xyz 文件或目录\r\n```\r\n\r\n选项与参数：\r\n\r\n- xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。\r\n- -R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更\r\n\r\n上面的 可以表示如下\r\n\r\n```shell\r\nchmod  -R 770     档案或目录\r\n```\r\n\r\n> 上面说了这么多，我们举例说明一下：\r\n\r\n我们进入itcast用户创建文件czbk.txt\r\n\r\n```shell\r\ntouch as.txt\r\n```\r\n\r\n然后切换到root\r\n\r\n比如，我们如果要将as.txt这个文件所有的权限都设定启用\r\n\r\n![1576463267777](./img/linux/java-linux/Linux-v10-01天-授课/1576463267777.png)\r\n\r\n那么命令如下：\r\n\r\n```shell\r\nchmod -R 777 as.txt\r\n```\r\n\r\n![1576463303277](./img/linux/java-linux/Linux-v10-01天-授课/1576463303277.png)\r\n\r\n由此可见，as.txt的属主权限、属组权限、其他权限都发生了改变\r\n\r\n由之前的【-rw-rw-r--】变成【-rwxrwxrwx】\r\n\r\n> 根据前面的换算我们已经知道如何将一个文件的属主、属组、其他权限换算成数字了，换算成数字后，我们只需要通过chmod命令即可更改文件的权限\r\n\r\n#### **2) 符号权限**\r\n\r\n还有一个改变权限的方法，就是 符号权限，我们先回顾下之前提到的9个权限\r\n\r\n- (1)user     属主权限\r\n- (2)group  属组权限\r\n- (3)others  其他权限\r\n\r\n那么我们就可以使用 **u, g, o** 来代表三种身份的权限！\r\n\r\n此外， **a** 则代表 **all**，即全部的身份。读写的权限可以写成 **r, w, x**，也就是可以使用下表的方式来看\r\n\r\n![1576464280724](./img/linux/java-linux/Linux-v10-01天-授课/1576464280724.png)\r\n\r\n如果我们需要将文件权限设置为 **-rwxr-xr--** ，可以使用 **chmod u=rwx,g=rx,o=r 文件名** 来设定:\r\n\r\n上接上面的例子，如下图\r\n\r\n我们将as.txt的权限设置为**-rwxr-xr--**\r\n\r\n![1576464462903](./img/linux/java-linux/Linux-v10-01天-授课/1576464462903.png)\r\n\r\n执行\r\n\r\n```shell\r\nchmod u=rwx,g=rx,o=r  as.txt\r\n```\r\n\r\n![1576464626496](./img/linux/java-linux/Linux-v10-01天-授课/1576464626496.png)\r\n\r\n 由上图我们发现，as.txt的权限变成了-rwxr-xr--\r\n\r\n假如我们要将权限去掉而不改变其他已存在的权限呢？举个例子，比如我要拿掉全部人的可读权限，则\r\n\r\n```SHELL\r\n chmod  a-r as.txt\r\n```\r\n\r\n执行如下\r\n\r\n![1576464852969](./img/linux/java-linux/Linux-v10-01天-授课/1576464852969.png)\r\n\r\n由此可见，as.txt的其他权限都没有了，变成了【---】\r\n\r\n## 3.4 综合案例\r\n\r\n```\r\n在前面的章节中我们讲解了用户、用户组、文件属主、属组以及权限，知识点比较零散，下面，我们就通过一个简单小案例把这些知识点串联起来\r\n```\r\n\r\n**需求：**\r\n\r\n比如一个公司的开发团队有三个用户：java、erlang、golang有一个文件目录tmp/work供他们开发，如何实现让这三个用户都对其具有写权限\r\n\r\n**1、首先，我们创建三个账户**（切换到root）\r\n\r\n```shell\r\nadduser java\r\nadduser erlang\r\nadduser golang\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576587867858](./img/linux/java-linux/Linux-v10-01天-授课/1576587867858.png)\r\n\r\n**2、增加用户组**\r\n\r\n```shell\r\ngroupadd -g 8888 dev-group\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576588353612](./img/linux/java-linux/Linux-v10-01天-授课/1576588353612.png)\r\n\r\n**3、创建公共文件并设置权限**\r\n\r\n给文件/tmp/project2019/设置属组为dev-group\r\n\r\n```shell\r\n mkdir /tmp/project2019\r\n \r\n chown -R :dev-group /tmp/project2019/\r\n 或者\r\n chgrp -R dev-group  /tmp/project2019/\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576588480909](./img/linux/java-linux/Linux-v10-01天-授课/1576588480909.png)\r\n\r\n**4、将用户添加到组**\r\n\r\n```shell\r\ngpasswd -a java    dev-group\r\ngpasswd -a erlang  dev-group\r\ngpasswd -a golang  dev-group\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576588553969](./img/linux/java-linux/Linux-v10-01天-授课/1576588553969.png)\r\n\r\n查询dev-group组下所有用户\r\n\r\n```shell\r\n grep \'dev-group\' /etc/group\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576588591503](./img/linux/java-linux/Linux-v10-01天-授课/1576588591503.png)\r\n\r\n**5、切换到java用户**\r\n\r\n切换到java用户看看是否有写入权限\r\n\r\n```shell\r\nsu java\r\n```\r\n\r\n![1576588731114](./img/linux/java-linux/Linux-v10-01天-授课/1576588731114.png)\r\n\r\n新建文件\r\n\r\n在我们上面创建的目录tmp/project2019/下面创建文件\r\n\r\n```shell\r\nmkdir java-files-new\r\n```\r\n\r\n![1576588941546](./img/linux/java-linux/Linux-v10-01天-授课/1576588941546.png)\r\n\r\n由此发现，我们在tmp/project2019/下面创建文件发生了权限不足，我们去查看下tmp/project2019/的文件属性，如下图\r\n\r\n我们在/tmp目录下执行\r\n\r\n```\r\nls -l\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576589157095](./img/linux/java-linux/Linux-v10-01天-授课/1576589157095.png)\r\n\r\n 我们发现目录project2019的文件属性为【drwxr-xr-x】\r\n\r\n根据前面学的知识，我们拆分如下\r\n\r\n【d】:文件类型\r\n\r\n【rwx】：属主\r\n\r\n【r-x】：属组\r\n\r\n【r-x】：其他\r\n\r\n现在答案就出来了，也就是说我们的属组权限是【r-x】，只有读和执行权限，没有写入权限，那么下面我们就给project2019目录增加写入权限。\r\n\r\n**6、增加写入权限**\r\n\r\n给project2019目录增加写入权限，执行下面的命令（前面已经学习过了）\r\n\r\n记得切换到root下执行\r\n\r\n```shell\r\nchmod  -R 770  project2019\r\n```\r\n\r\n执行效果如下![1576589467908](./img/linux/java-linux/Linux-v10-01天-授课/1576589467908.png)\r\n\r\n此时我们发现project2019目录的属组权限变成了【rwx】即可读、可写、可执行\r\n\r\n**7、切换用户，继续写入**\r\n\r\n```shell\r\nsu  java\r\nmkdir java-files-new\r\nls -l\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576589641341](./img/linux/java-linux/Linux-v10-01天-授课/1576589641341.png)\r\n\r\n由此发现，这个时候我们有了写入权限，java-files-new文件被成功写入\r\n\r\n那么，其他两个用户golang、erlang也是和java一个组的，他们能不能正常写入呢，我们试试（从root切换过去）\r\n\r\n```shell\r\nsu\r\nsu erlang\r\nmkdir erlang-files-new\r\n==============================\r\nsu\r\nsu golang\r\nmkdir golang-files-new\r\n\r\nls -l\r\n```\r\n\r\n执行效果（erlang新建文件）\r\n\r\n![1576589820604](./img/linux/java-linux/Linux-v10-01天-授课/1576589820604.png)\r\n\r\n执行效果（golanglang新建文件）\r\n\r\n![1576589856968](./img/linux/java-linux/Linux-v10-01天-授课/1576589856968.png)\r\n\r\n查看所有文件\r\n\r\n![1576589903617](./img/linux/java-linux/Linux-v10-01天-授课/1576589903617.png)\r\n\r\n由此可见，我们组的三个用户都成功创建了文件（拥有了写入权限）\r\n\r\n**8、验证结论**\r\n\r\n为了验证上面的结论，我们新增一个用户itbeijing\r\n\r\n看看能否正常新建文件\r\n\r\n```shell\r\nuseradd   itbeijing\r\nsu itbeijing\r\nmkdir  itbeijing-files-new\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576590031376](./img/linux/java-linux/Linux-v10-01天-授课/1576590031376.png)\r\n\r\n由上图我们发现，我们刚刚新创建的用户在创建文件的时候发现了权限不足。\r\n\r\n由此说明用户itbeijing用户的属组和文件的属组不一样，所以没有权限。\r\n\r\n## 3.5 总结\r\n\r\n在企业级开发过程中，实际操作目录是最经常出现的，对于目录常用命令我们要熟练掌握并能熟练编写\r\n因为Linux是多用户系统，所以权限也是非常核心和重要的，我们要熟练编写权限（属主、属组、其他权限）的常用命令。',ur={data:function(){return{MainComponent:dr}}},pr=ur,vr=Object(d["a"])(pr,lr,or,!1,null,"f4fc4986",null),cr=vr.exports,mr=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},hr=[],_r='# Linux-v10.0-02天-课堂笔记\r\n\r\n学习目标\r\n\r\n- 能够熟练编写文件相关命令\r\n- 能够熟练编写文件解压缩命令\r\n- 能够熟练编写网络查看简单命令\r\n- 能够熟练编写查看磁盘命令、挂载命令\r\n- 能够知道如何使用命令进行分区、格式化\r\n- 能够熟练使用yum进行查找、安装、卸载软件\r\n- 能够熟练使用rpm进行查找、安装、卸载软件\r\n- 能够熟练编写常用的shell脚本\r\n\r\n#  1 Linux文件管理\r\n\r\n## 1.1 touch命令\r\n\r\n```\r\n在Windows系统中，我们如果想创建一个文本文档或者word文件的时候，通常的做法是\r\n鼠标右键---新建---文本文档，这样的话，我们就成功的创建了一个文件，而在Linux中，我们可以通过字符命令的形式进行创建\r\n```\r\n\r\ntouch命令用于创建文件、修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。\r\n\r\nls -l 可以显示档案的时间记录\r\n\r\n**使用者权限：所有权限用户**\r\n\r\n**语法**\r\n\r\n```\r\ntouch [-acfm][-d<日期时间>][-r<参考文件或目录>] [-t<日期时间>][--help][--version][文件或目录…]\r\n```\r\n\r\n- **参数说明**：\r\n- a 改变档案的读取时间记录。\r\n- m 改变档案的修改时间记录。\r\n- c 假如目的档案不存在，不会建立新的档案。与 --no-create 的效果一样。\r\n- f 不使用，是为了与其他 unix 系统的相容性而保留。\r\n- r 使用参考档的时间记录，与 --file 的效果一样。\r\n- d 设定时间与日期，可以使用各种不同的格式。\r\n- t 设定档案的时间记录，格式与 date 指令相同。\r\n- --no-create 不会建立新档案。\r\n- --help 列出指令格式。\r\n- --version 列出版本讯息。\r\n\r\n**使用 touch 创建一个空文件**\r\n\r\n在 Linux 系统上使用 `touch` 命令创建空文件，键入 `touch`，然后输入文件名。如下所示\r\n\r\n```shell\r\ntouch czbk-devops.txt\r\n```\r\n\r\n查看\r\n\r\n```shell\r\nls -l czbk-devops.txt\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576640085716](./img/linux/java-linux/Linux-v10-02天-授课/1576640085716.png)\r\n\r\n**使用 touch 创建批量空文件**\r\n\r\n在实际的开发过程中可能会出现一些情况，我们必须为某些测试创建大量空文件，这可以使用 `touch` 命令轻松实现\r\n\r\n```shell\r\ntouch czbk-{1..10}.txt\r\n```\r\n\r\n在上面的例子中，我们创建了 10 个名为 czbk-1.txt` 到 `czbk-10.txt` 的空文件，你可以根据需要更改名称和数字\r\n\r\n执行查看命令\r\n\r\n```shell\r\nls -l\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576640392259](./img/linux/java-linux/Linux-v10-02天-授课/1576640392259.png)\r\n\r\n由上图我们发现，我们通过批量命令创建了10个txt文件\r\n\r\n**改变/更新文件访问时间**\r\n\r\n假设我们想要改变名为 czbk-devops.txt 文件的访问时间，在 `touch` 命令中使用 `-a` 选项，然后输入文件名。如下所示：\r\n\r\n1、我们先 查看下czbk-devops.txt的时间属性\r\n\r\n```shell\r\nls -l czbk-devops.txt \r\n```\r\n\r\n执行效果如下\r\n\r\n![1576648168657](./img/linux/java-linux/Linux-v10-02天-授课/1576648168657.png)\r\n\r\n我们发现，最后的访问时间是12月 18 11:34\r\n\r\n更新时间属性，如下\r\n\r\n```shell\r\ntouch czbk-devops.txt \r\n```\r\n\r\n执行ls命令查看，如下\r\n\r\n```shell\r\nls -l czbk-devops.txt \r\n```\r\n\r\n![1576648319770](./img/linux/java-linux/Linux-v10-02天-授课/1576648319770.png)\r\n\r\n我们发现，访问时间变成了 12月 18 13:50\r\n\r\n我们也可以使用stat命令进行查看，如下：\r\n\r\n```shell\r\nstat czbk-devops.txt \r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576648420787](./img/linux/java-linux/Linux-v10-02天-授课/1576648420787.png)\r\n\r\n由上图可知：czbk-devops.txt的文件属性、包含访问时间、更改时间、最近改动时间都显示出来了。\r\n\r\n **关于stat命令：**\r\n\r\n**stat命令用于显示inode内容。**\r\n\r\nstat以文字的格式来显示inode的内容。\r\n\r\n**语法**\r\n\r\n```\r\nstat [文件或目录]\r\n```\r\n\r\n## 1.2 vi与vim命令\r\n\r\n### 1.2.1 vi/vim介绍\r\n\r\n```\r\n使用vi/vim其实就相当于我们在Windows系统中创建文件、打开文件、编辑文件、保存文件操作\r\n```\r\n\r\n**1、vi介绍**\r\n\r\nvi是 `visual interface`的简称, 是linux中**最经典**的文本编辑器。\r\n\r\n- vi的特点\r\n  - 只能是编辑 **文本内容**, 不能对 字体 段落进行排版\r\n  - **不支持鼠标操作**\r\n  - **没有菜单**\r\n  - **只有命令**\r\n- vi编辑器在 **系统管理 服务器管理** 编辑文件时, **其功能永远不是图形界面的编辑器能比拟的**\r\n\r\n**2、vim介绍**\r\n\r\n**vim**:是从 vi （系统内置命令）发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。\r\n\r\n简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 \r\n\r\nvim 则可以说是程序开发者的一项很好用的工具。\r\n\r\n### 1.2.2 vi/vim模式\r\n\r\nvi/vim模式主要分为以下三种：\r\n\r\n**命令模式**：在Linux终端中输入“vim 文件名”就进入了命令模式,但不能输入文字。\r\n**编辑模式：**在命令模式下按i就会进入编辑模式，此时就可以写入程式，按Esc可回到命令模式。\r\n**末行模式：**在命令模式下按：进入末行模式，左下角会有一个冒号出现，此时可以敲入命令并执行。\r\n\r\n下面是三种模式的简单分析图：\r\n\r\n![1576653460302](./img/linux/java-linux/Linux-v10-02天-授课/1576653460302.png)\r\n\r\n> 上图总结\r\n>\r\n> 上面的三种模式简单总结下就是：\r\n>\r\n> 1、vim  开始进入时是命令模式\r\n>\r\n> 2、按下I的时候会进入编辑模式\r\n>\r\n> 3、按下ESC然后在按下：的时候是末行模式\r\n\r\n\r\n\r\n###  1.2.3 打开和新建文件\r\n\r\n```\r\n使用vim不但可以打开一个现存的文件；也可以生成（vim后的文件不存在的情况下）一个文件；有点类似于我们在Windows中输入notepad命令一样，我们输入notepad后就会打开一个文本文档，然后进行编辑--另存为。\r\n```\r\n\r\n**使用者权限：当前文件的权限用户**\r\n\r\n- 在终端中输入vim在后面跟上 文件名 即可\r\n\r\n```\r\nvim txtfile.txt\r\n```\r\n\r\n- 如果文件已经存在, 会直接打开该文件\r\n- 如果文件不存在, 保存且退出时 就会新建一个文件\r\n\r\n> 注意\r\n>\r\n> 我们通过下面的三种模式切换详细阐述vim的用法\r\n\r\n###  1.2.4 三种模式切换\r\n\r\n**1、进入命令模式**\r\n\r\n上接上面的例子，我们执行下面的命令其实就是进入了命令模式\r\n\r\n```shell\r\nvim txtfile.txt\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576655123201](./img/linux/java-linux/Linux-v10-02天-授课/1576655123201.png)\r\n\r\n**2、进入编辑模式**\r\n\r\n上接上面的例子，按i进入插入模式\r\n\r\n- 在 vi 中除了常用 `i` 进入**编辑模式** 外, 还提供了一下命令同样可以进入编辑模式\r\n\r\n| 命令 | 英文   | 功能                   | 常用   |\r\n| ---- | ------ | ---------------------- | ------ |\r\n| i    | insert | 在当前字符前插入文本   | 常用   |\r\n| I    | insert | 在行首插入文本         | 较常用 |\r\n| a    | append | 在当前字符后添加文本   |        |\r\n| A    | append | 在行末添加文本         | 较常用 |\r\n| o    |        | 在当前行后面插入一空行 | 常用   |\r\n| O    |        | 在当前行前面插入一空行 | 常用   |\r\n\r\n上图可以表现为以下形式，如下图\r\n\r\n![1576663442969](./img/linux/java-linux/Linux-v10-02天-授课/1576663442969.png)\r\n\r\n执行效果如下图\r\n\r\n![1576655181144](./img/linux/java-linux/Linux-v10-02天-授课/1576655181144.png)\r\n\r\n由上图左下角我们看到【插入】（英文版为INSERT）,说明我们进入了编辑模式\r\n\r\n我们在里面插入数据，如下图\r\n\r\n因为我们是一个空文件，所以使用【I】或者【i】都可以\r\n\r\n如果里面的文本很多，要使用【A】进入编辑模式，即在行末添加文本\r\n\r\n![1576655270283](./img/linux/java-linux/Linux-v10-02天-授课/1576655270283.png)\r\n\r\n**3、进入末行模式**\r\n\r\n编辑模式不能保存文件\r\n必须先推到命令模式\r\n先按Esc键退出到命令模式\r\n然后按小写的**:wq 正常保存退出**\r\n\r\n进入末行模式—》按符号： 鼠标跑到屏幕的最后一行，执行效果如下图\r\n\r\n![1576655879564](./img/linux/java-linux/Linux-v10-02天-授课/1576655879564.png)\r\n\r\n然后按小写的**:wq 正常保存退出**\r\n\r\n![1576655592207](./img/linux/java-linux/Linux-v10-02天-授课/1576655592207.png)\r\n\r\n退出后显示【已写入】\r\n\r\n**以下为其他的退出模式：**\r\n\r\n:q            当vim进入文件没有对文件内容做任何操作可以按"q"退出\r\n\r\n:q!           当vim进入文件对文件内容有操作但不想保存退出\r\n\r\n:wq          正常保存退出\r\n\r\n:wq!         强行保存退出，只针对与root用户或文件所有人生\r\n\r\n> 总结\r\n>\r\n> 三种模式的切换，其实就完成了文件创建、编辑、保存、退出四个步骤\r\n>\r\n> 那么接下来，我们学习下一个命令\r\n>\r\n> 查看刚才新创建的文件\r\n\r\n### 1.2.5 文件查看\r\n\r\n```\r\n比如查看一个txt文档，在windows中，我们通常是打开一个文件，通过鼠标滚动查看文件不同节选的内容，而在Linux中，通过下面的命令，可以减少在Windows中手工查找的步骤，在Linux中通过命令+参数的形式进行定位查看、搜索查看\r\n```\r\n\r\n以下5个为文件查看命令，**我们只讲4个常用的命令，head不在赘述**\r\n\r\n| 序号 | 命令               | 对应英文    | 作用                             |\r\n| ---- | ------------------ | ----------- | -------------------------------- |\r\n| 01   | cat 文件名         | concatenate | 查看小文件内容                   |\r\n| 02   | less -N 文件名     | less        | **分频** 显示大文件内容          |\r\n| 03   | head -n 文件名     |             | 查看文件的**前一**部分           |\r\n| 04   | tail -n 文件名     |             | 查看文件的**最后**部分           |\r\n| 05   | grep 关键字 文件名 | grep        | 根据**关键词**, 搜索文本文件内容 |\r\n\r\n> 总结：\r\n>\r\n> 以上5个命令都可以查询文件的内容，他们的功能如下\r\n>\r\n> 通过 `cat` 会一次显示所有的内容, 适合 **查看内容较少** 的文本文件\r\n>\r\n> `less` 命令适合查看 **内容较多** 的文本文件\r\n>\r\n> 通过 `head` 命令查看文档的前几行内容\r\n>\r\n> 通过 `tail -10f 文件` 命令 查看文档(日志)的后几行内容\r\n>\r\n> 通过 `grep` 命令 搜索存在 **关键字** 的行\r\n\r\n#### **1) cat命令**\r\n\r\n```\r\n使用cat命令类似于我们在Windows中查看小型（太大的时候打开会卡死）的文件，cat常用的功能其实就等价于Windows中的\r\ntxt---打开--查看\r\n```\r\n\r\ncat 是一个文本文件查看和连接工具。查看一个文件的内容，用cat比较简单，就是cat 后面直接接文件名，如cat txtFiles.txt\r\n\r\n**使用者权限：当前文件的权限用户**\r\n\r\n**语法格式**\r\n\r\n```\r\ncat [-AbeEnstTuv] [--help] [--version] fileName\r\n```\r\n\r\n**查看文件名为txtfile.txt的内容**\r\n\r\n```shell\r\ncat txtfile.txt\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576657358085](./img/linux/java-linux/Linux-v10-02天-授课/1576657358085.png)\r\n\r\n**查看文件名为txtfile.txt的内容（加入行号）**\r\n\r\n```shell\r\ncat -n txtfile.txt\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576657409815](./img/linux/java-linux/Linux-v10-02天-授课/1576657409815.png)\r\n\r\n#### 2) grep命令\r\n\r\n```\r\ngrep命令在使用的时候类似于我们的程序中的查询，或者在txt文档中通过ctr+f查找\r\ngrep除了能对文件操作为还可以查看我们的进程信息，类似于我们在Windows系统的任务管理器（任务栏--右键---启动任务管理器--进程）下的进程\r\n```\r\n\r\ngrep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据。\r\n\r\ngrep 命令用于查找文件里符合条件的字符串，语法如下：\r\n\r\n```\r\ngrep [-abcEFGhHilLnqrsvVwxy][-A<显示列数>][-B<显示列数>][-C<显示列数>][-d<进行动作>][-e<范本样式>][-f<范本文件>][--help][范本样式][文件或目录...]\r\n```\r\n\r\n**使用者权限：当前文件的权限用户**\r\n\r\n我们还是使用上面的txtfile.txt文件，如下图\r\n\r\n![1576664862829](./img/linux/java-linux/Linux-v10-02天-授课/1576664862829.png)\r\n\r\n> 为了测试效果，我们新增了其他数据\r\n>\r\n> 增加过程不在赘述\r\n\r\n1、搜索 **存在关键字【eeee】** 的行的文件\r\n\r\n```shell\r\ngrep eeee txtfile.txt \r\n```\r\n\r\n执行效果如下\r\n\r\n![1576664910366](./img/linux/java-linux/Linux-v10-02天-授课/1576664910366.png)\r\n\r\n2、搜索 **存在关键字【eeee】** 的行 且 **显示行号**\r\n\r\n```shell\r\ngrep -n eeee txtfile.txt \r\n```\r\n\r\n![1576665113269](./img/linux/java-linux/Linux-v10-02天-授课/1576665113269.png)\r\n\r\n3、**忽略大小写** 搜索 **存在关键字** 的行\r\n\r\n```shell\r\ngrep -i EEEE txtfile.txt \r\n```\r\n\r\n执行效果如下\r\n\r\n![1576666861596](./img/linux/java-linux/Linux-v10-02天-授课/1576666861596.png)\r\n\r\n4、搜索 **不存在关键字** 的行\r\n\r\n```shell\r\ngrep -v 中国 txtfile.txt \r\n```\r\n\r\n执行效果如下\r\n\r\n![1576666928266](./img/linux/java-linux/Linux-v10-02天-授课/1576666928266.png)\r\n\r\n**5、查找指定的进程信息（包含grep进程）**\r\n\r\n```shell\r\nps -ef | grep  sshd\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577095621215](./img/linux/java-linux/Linux-v10-02天-授课/1577095621215.png)\r\n\r\n> 说明\r\n>\r\n> 除最后一条记录外，其他的都是查找出的进程；最后一条记录结果是grep进程本身，并非真正要找的进程\r\n\r\n**6、查找指定的进程信息（不包含grep进程）**\r\n\r\n```shell\r\nps aux | grep sshd | grep -v "grep"\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577095998308](./img/linux/java-linux/Linux-v10-02天-授课/1577095998308.png)\r\n\r\n**7、查找进程个数**\r\n\r\n```shell\r\n ps -ef|grep -c sshd\r\n```\r\n\r\n 执行效果如下\r\n\r\n![1577096070670](./img/linux/java-linux/Linux-v10-02天-授课/1577096070670.png)\r\n\r\n由上图可知sshd的进程个数为4（包含grep进程本身）\r\n\r\n#### 3) tail命令\r\n\r\n```\r\ntail命令类似于我们在windows中通过鼠标手工查找，比如查看文件最后10行，从第2行一直查看到文件末尾，或者只查看文件末尾的一些信息，这些windows中都是通过人为干预的方式进行查找，在Linux中我们可以通过tail命令实现\r\n```\r\n\r\ntail 命令可用于查看文件的内容，有一个常用的参数 **-f** 常用于查阅正在改变的日志文件。\r\n\r\n**tail -f filename** 会把 filename 文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。\r\n\r\n**使用者权限：当前文件的权限用户**\r\n\r\n**命令格式：**\r\n\r\n```shell\r\ntail [参数] [文件]  \r\n```\r\n\r\n**1、要显示 txtfile.txt  文件的最后 3 行，请输入以下命令：**\r\n\r\n```shell\r\ntail -3 txtfile.txt \r\n```\r\n\r\n原始文件内容如下\r\n\r\n![1576667678964](./img/linux/java-linux/Linux-v10-02天-授课/1576667678964.png)\r\n\r\n最后3行内容如下\r\n\r\n![1576667701796](./img/linux/java-linux/Linux-v10-02天-授课/1576667701796.png)\r\n\r\n**2、动态显示文档的最后内容,一般用来查看日志，请输入以下命令：**\r\n\r\n```shell\r\ntail -f txtfile.txt\r\n```\r\n\r\n执行效果如下：\r\n\r\n![1576667811261](./img/linux/java-linux/Linux-v10-02天-授课/1576667811261.png)\r\n\r\n此命令显示 txtfile.txt 文件的最后 10 行。当将某些行添加至 txtfile.txt 文件时，tail 命令会继续显示这些行。 显示一直继续，直到您按下（Ctrl-C）组合键停止显示。\r\n\r\n如果要显示最后4行，命令如下：\r\n\r\n```shell\r\ntail -4f txtfile.txt\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576719306123](./img/linux/java-linux/Linux-v10-02天-授课/1576719306123.png)\r\n\r\n**3、显示文件txtfile.txt 的内容，从第 2 行至文件末尾**\r\n\r\n```shell\r\ntail  -n +2  txtfile.txt\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576719057889](./img/linux/java-linux/Linux-v10-02天-授课/1576719057889.png)\r\n\r\n**4、显示文件 txtfile.txt的最后 10 个字符:**\r\n\r\n```shell\r\ntail -c 45 txtfile.txt\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576719098586](./img/linux/java-linux/Linux-v10-02天-授课/1576719098586.png)\r\n\r\n> 总结\r\n>\r\n> 在tail使用的过程中，我们使用最多的就是查看文件末尾多多少行\r\n>\r\n> 使用tail -nf txtfile.txt\r\n>\r\n> 通常都是在查看日志信息（报错调试时使用）\r\n\r\n#### 4）less命令\r\n\r\n```\r\nless命令也是查看文件的，只不过它适合查看 内容较多的文本文件，它也可以用于分屏显示文件内容,  每次只显示一页内容，有点类似我们做分页查询\r\n```\r\n\r\nless用于查看文件，但是less 在查看之前不会加载整个文件。\r\n\r\n**使用者权限：当前文件的权限用户**\r\n\r\n**语法**\r\n\r\n```shell\r\nless [参数] 文件 \r\n```\r\n\r\n1、查看txtfile.txt文件\r\n\r\n```shell\r\nless txtfile.txt\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576720622842](./img/linux/java-linux/Linux-v10-02天-授课/1576720622842.png)\r\n\r\n2、查看命令历史使用记录并通过less分页显示\r\n\r\n```shell\r\n[itcast@localhost ~]$  history | less\r\n    1  ifconfig\r\n    2  reboot\r\n    3  ifconfig\r\n    4  reboot\r\n    5  ifconfig\r\n    6  su root\r\n    7  ifconfig\r\n    8  ping  www.baidu.com\r\n    9  \\\r\n   10  ifconfig\r\n   11  date\r\n   12  hwclock --systohc\r\n   13  su root\r\n   \r\n   ......略\r\n```\r\n\r\n我们输入【j】可以前进行\r\n\r\n​        输入【k】可以后退行\r\n\r\n​        输入【G】可以 移动到最后一行\r\n\r\n​\t    输入【g】可以移动到第一行\r\n\r\n​        输入【ctrl + F】 向前移动一屏(类似于我们在浏览器中的数据分页的下一页)\r\n\r\n​        输入【ctrl + B】 向后移动一屏(类似于我们在浏览器中的数据分页的上一页)\r\n\r\n**其他命令**\r\n\r\n1.全屏导航\r\n\r\n- ctrl + F - 向前移动一屏\r\n- ctrl + B - 向后移动一屏\r\n- ctrl + D - 向前移动半屏\r\n- ctrl + U - 向后移动半屏\r\n\r\n2.单行导航\r\n\r\n- j - 向前移动一行\r\n- k - 向后移动一行\r\n\r\n3.其它导航\r\n\r\n- G - 移动到最后一行\r\n- g - 移动到第一行\r\n- q / ZZ - 退出 less 命令\r\n\r\n### 1.2.6  vim定位行\r\n\r\n```\r\n在日常工作中,有可能会遇到打开一个文件,并定位到指定行的情况\r\n例如: 在开发时, 知道某一行代码有错误,可以快速定位到出错误代码的位置\r\n这个时候,可以使用以下命令打开文件\r\n```\r\n\r\n由于我们这里还没有学到上传文件的命令，所以我们这里还是使用上面的txtfile.txt例子，我们打开文件定位到第6行，如下：\r\n\r\n```shell\r\nvim txtfile.txt +6\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576659165723](./img/linux/java-linux/Linux-v10-02天-授课/1576659165723.png)\r\n\r\n### **1.2.7 异常处理**\r\n\r\n- 如果 vim异常退出, 在磁盘上可能会保存有 交换文件\r\n- 下次再使用 vim 编辑文件时, 会看到以下屏幕信息,\r\n\r\n![1576658330514](./img/linux/java-linux/Linux-v10-02天-授课/1576658330514.png)\r\n\r\n解决方案：\r\n\r\n将后缀名为.swp的文件删除即可恢复\r\n\r\n![1576658480811](./img/linux/java-linux/Linux-v10-02天-授课/1576658480811.png)\r\n\r\n再次编辑文件不在出现提示警告！\r\n\r\n\r\n\r\n### 1.2.8 操作扩展\r\n\r\n要熟练使用vi/vim, 首先应该学会怎么在 命令模式下 快速移动光标\r\n编辑操作命令 能够和移动命令一起使用\r\n\r\n**1) 上 下 左 右**\r\n\r\n![1558278451153](./img/linux/java-linux/Linux-v10-02天-授课/1558278451153.png)\r\n\r\n| 命令 | 功能 | 手指   |\r\n| ---- | ---- | ------ |\r\n| h    | 向左 | 食指   |\r\n| j    | 向下 | 食指   |\r\n| k    | 向上 | 中指   |\r\n| l    | 向右 | 无名指 |\r\n\r\n也可以使用键盘上的上下左右箭头，这个更有方向感。\r\n\r\n**2) 行内移动**\r\n\r\n| 命令 | 英文 | 功能                           |\r\n| ---- | ---- | ------------------------------ |\r\n| w    | word | 向后移动一个单词               |\r\n| b    | back | 向前移动一个单词               |\r\n| 0    |      | 行首                           |\r\n| ^    |      | 行首, 第一个不是空白字符的位置 |\r\n| $    |      | 行尾                           |\r\n\r\n**3) 行数移动**\r\n\r\n| 命令   | 英文 | 功能                  |\r\n| ------ | ---- | --------------------- |\r\n| gg     | go   | 文件顶部              |\r\n| G      | go   | 文件末尾              |\r\n| 数字gg | go   | 移动到 数字 对应行数  |\r\n| 数字G  | go   | 移动到 数字 对应行数  |\r\n| : 数字 |      | 移动到数字对应的 行数 |\r\n\r\n**4) 屏幕移动**\r\n\r\n| 命令     | 英文    | 功能     |\r\n| -------- | ------- | -------- |\r\n| Ctrl + b | back    | 向上翻页 |\r\n| Ctrl + f | forward | 向下翻页 |\r\n| H        | Head    | 屏幕顶部 |\r\n| M        | Middle  | 屏幕中间 |\r\n| L        | Low     | 屏幕底部 |\r\n\r\n**5) 选中文本(可视模式)**\r\n\r\n- 学习 复制 命令前, 应该先学会 **怎么样选中 要复制的代码**\r\n- 在 vi/vim 中要选择文本, 需要显示 visual 命令切换到 **可视模式**\r\n- vi/vim 中提供了 **三种** 可视模式, 可以方便程序员的选择 **选中文本的方式**\r\n- 按 ESC 可以放弃选中, 返回到 **命令模式**\r\n\r\n| 命令     | 模式       | 功能                               |\r\n| -------- | ---------- | ---------------------------------- |\r\n| v        | 可视模式   | 从光标位置开始按照正常模式选择文本 |\r\n| V        | 可视化模式 | 选中光标经过的完整行               |\r\n| Ctrl + v | 可是块模式 | 垂直方向选中文本                   |\r\n\r\n**6) 撤销和恢复撤销(保命指令)**\r\n\r\n在学习编辑命令之前,先要知道怎样撤销之前一次 错误的 编辑操作\r\n\r\n| 命令     | 英文  | 功能                     |\r\n| -------- | ----- | ------------------------ |\r\n| u        | undo  | 撤销上次的命令(ctrl + z) |\r\n| Ctrl + r | uredo | 恢复撤销的命令           |\r\n\r\n**7) 删除文本**\r\n\r\n| 命令        | 英文   | 功能                              |\r\n| ----------- | ------ | --------------------------------- |\r\n| x           | cut    | 删除光标所在的字符,或者选中的文字 |\r\n| d(移动命令) | delete | 删除移动命令对应的内容            |\r\n| dd          | delete | 删除光标所在行, 可以删除多行      |\r\n| D           | delete | 删除至行尾                        |\r\n\r\n提示: 如果使用 可视模式 已经选中了一段文本, 那么无论使用 d 还是 x, 都可以删除选中文本\r\n\r\n删除命令可以和移动命令连用, 以下是常见的组合命令(扩展):\r\n\r\n| 命令 | 作用                        |\r\n| ---- | --------------------------- |\r\n| dw   | 从光标位置删除到单词末尾    |\r\n| d}   | 从光标位置删除到段落末尾    |\r\n| ndd  | 从光标位置向下连续删除 n 行 |\r\n\r\n**8) 复制和剪切**\r\n\r\n- vi/vim 中提供有一个 被复制文本的缓冲区\r\n  - 复制 命令会将选中的文字保存在缓冲区\r\n  - 删除 命令删除的文字会被保存在缓冲区\r\n  - 在需要的位置, 使用 粘贴 命令可以将缓冲对的文字插入到光标所在的位置\r\n\r\n| 命令        | 英文   | 功能                       |\r\n| ----------- | ------ | -------------------------- |\r\n| yy          | copy   | 复制行                     |\r\n| d(剪切命令) | delete | 剪切                       |\r\n| dd(剪切)    | delete | 剪切一行, 可以 ndd 剪切n行 |\r\n| p           | paste  | 粘贴                       |\r\n\r\n提示:\r\n\r\n- 命令 d 、x 类似于图形界面的 **剪切操作**  -- ctrl + x\r\n- 命令 y 类似于 图形界面的 **复制操作** -- Ctrl + \r\n- 命令 p 类似于图形界面的 **粘贴操作** -- Ctrl + v\r\n- vi中的文本缓冲区只有一个,如果后续做过 复制、剪切操作, 之前缓冲区中的内容会被替换.\r\n\r\n注意\r\n\r\n- vi中的 **文本缓冲区** 和 系统的 **剪切板** 不是同一个\r\n- 所以在其他软件中使用 `Ctrl + C` 复制的内容, 不能再 `vi` 中通过 `p` 命令粘贴\r\n- 可以在 **编辑模式** 下使用 **鼠标右键粘贴**\r\n\r\n**9) 替换**\r\n\r\n| 命令 | 英文    | 功能                   | 工作模式 |\r\n| ---- | ------- | ---------------------- | -------- |\r\n| r    | replace | 替换当前字符           | 命令模式 |\r\n| R    | replace | 替换当前行光标后的字符 | 替换模式 |\r\n\r\n- `R` 命令可以进入 **替换模式**, 替换完成后, 按下`ESC` , 按下 `ESC` 可以回到 **命令模式**\r\n- **替换命令** 的作用就是不用进入 **编辑模式**, 对文件进行 **轻量级的修改**\r\n\r\n**10) 缩排和重复执行**\r\n\r\n| 命令 | 功能         |\r\n| ---- | ------------ |\r\n| >>   | 向右增加缩进 |\r\n| <<   | 向左减少缩进 |\r\n| .    | 重复上次命令 |\r\n\r\n- **缩进命令** 在开发程序时, **统一增加代码的缩进** 比较有用!\r\n  - 一次性 **在选中代码前增加 4 个空格,**  就叫做 **增加缩进**\r\n  - 一次性 **在选中代码前删除 4 个空格**,  就叫做 **较少缩进**\r\n- 在 **可视模式** 下, 缩排命令 主需要使用 一个 `>` 或者 `<`\r\n\r\n在程序中, **缩进** 通常用来表示代码的归属关系\r\n\r\n- **前面空格越少, 代码的级别越高**\r\n- **前面空格越多, 代码的级别越低**\r\n\r\n**11) 查找**\r\n\r\n常规查找\r\n\r\n| 命令 | 功能    |\r\n| ---- | ------- |\r\n| /str | 查找str |\r\n\r\n- 查找到指定内容之后, 使用 `Next` 查找下一个出现的位置\r\n  - `n` : 查找下一个\r\n  - `N` : 查找上一个\r\n- 如果不想看到高亮显示, 可以随便查找一个文件中不存在的内容即可\r\n\r\n- 单词快速匹配\r\n\r\n| 命令 | 功能                     |\r\n| ---- | ------------------------ |\r\n| *    | 向后查找当前光标所在单词 |\r\n| #    | 向前查找当前光标所在单词 |\r\n\r\n- 在开发中, 通过单词快速匹配, 可以快速看到这个单词在其他位置使用过\r\n\r\n**12) 查找并替换**\r\n\r\n- 在 `vi/vim` 中查找和替换命令需要在 **末行模式** 下执行\r\n- 记忆命令格式\r\n\r\n```\r\n:%s///g\r\n```\r\n\r\n1)  全局替换\r\n\r\n- 一次向 替换文件中的 所有出现的旧文本\r\n\r\n- 命令格式如下\r\n\r\n  ```\r\n  :%s/旧文本/新文本/g\r\n  ```\r\n\r\n2) 可视区域替换\r\n\r\n- **先选中** 要替换文字的 **范围**\r\n- 命令格式如下\r\n\r\n```\r\n:s/旧文本/新文本/g\r\n```\r\n\r\n3) 确认替换：\r\n\r\nc confirm 确认\r\n\r\n- 如果把末尾的 `g` 改成 `gc`  在替换的时候, 会有提示! 推荐使用\r\n\r\n- 命令格式如下\r\n\r\n  ```\r\n  :%s/旧文本/新文本/gc\r\n  ```\r\n\r\n1. `y` - `yes` 替换\r\n2. `n` - `no` 不替换\r\n3. `a` - `all` 替换所有\r\n4. `q` -`quit` 退出替换\r\n5. `l` - `last` 最后一个, 并把光标移动到行首\r\n6. `^E` 向下滚屏\r\n7. `^Y` 向上滚屏\r\n\r\n## 1.3 echo 命令\r\n\r\n```\r\necho命令有点类似于我们在java se阶段学习的 System.out.print("hello")\r\n但是，echo还有一个功能就是追加文件内容到文件，类似于我们在java se阶段学习的append文件流写入一样\r\n```\r\n\r\n**使用者权限：所有用户**\r\n\r\n- `echo string` 将字符串输出到控制台 ,  通常和 **重定向** 联合使用\r\n\r\n```\r\necho hello world\r\n\r\n# 如果字符串有空格, 为了避免歧义 请增加 双引号 或者 单引号\r\necho "hello world"\r\n```\r\n\r\n**6.3 重定向 `>`(覆盖) 和 `>>` (追加)** \r\n\r\n![1558435686066](./img/linux/java-linux/Linux-v10-02天-授课/1558435686066-1576721493121.png)\r\n\r\n- 默认情况下 **命令的结果** 输出到 **控制台**\r\n- 通过 **重定向** 可以将结果 **输出到文件**\r\n\r\n**6.2.3 实现**\r\n\r\n- **第一步: 将命令的成功结果 覆盖 指定文件内容**\r\n\r\n```\r\n echo  传智博客 >czbk-txt.txt\r\n```\r\n\r\n执行结果如下（czbk-txt.txt文件如果没有会自动创建）\r\n\r\n![1576721910460](./img/linux/java-linux/Linux-v10-02天-授课/1576721910460.png)\r\n\r\n| 命令          | 作用                               |\r\n| ------------- | ---------------------------------- |\r\n| 结果 > 文件名 | `>` 表示输出, 会覆盖文件的原有内容 |\r\n\r\n- ##### 第二步: 将**命令的成功结果** **追加**  指定文件的后面\r\n\r\n```\r\necho  黑马程序员 >> czbk-txt.txt\r\n```\r\n\r\n执行结果如下\r\n\r\n![1576721980097](./img/linux/java-linux/Linux-v10-02天-授课/1576721980097.png)\r\n\r\n| 命令           | 作用                                        |\r\n| -------------- | ------------------------------------------- |\r\n| 命令 >> 文件名 | `>>` 表示追加, 会将内容追加到已有文件的末尾 |\r\n\r\n- ##### 第三步: 将**命令的失败结果** **追加** 指定文件的后面\r\n\r\n```\r\ncat 不存在的目录  &>>  error.log\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576722167942](./img/linux/java-linux/Linux-v10-02天-授课/1576722167942.png)\r\n\r\n| 命令             | 作用                                   |\r\n| ---------------- | -------------------------------------- |\r\n| 命令  `&>>` 文件 | `&>>` 表示不区分错误类型 都放到 日志中 |\r\n\r\n> 总结\r\n>\r\n> - 通过 `命令 > 文件`  将**命令的成功结果** **覆盖** 指定文件内容\r\n> - 通过 `命令 >> 文件`   将**命令的成功结果** **追加**  指定文件的后面\r\n> - 通过 `命令 &>> 文件` 将 **命令的失败结果** **追加** 指定文件的后面\r\n\r\n## 1.4 awk命令\r\n\r\nAWK是一种处理文本文件的语言，是一个强大的文本分析工具。\r\n\r\n之所以叫AWK是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符。\r\n\r\n**具体语法如下**\r\n\r\n```shell\r\nawk [选项参数] \'script\' var=value file(s)\r\n或\r\nawk [选项参数] -f scriptfile var=value file(s)\r\n```\r\n\r\n**1、数据准备：czbk-txt.txt文本内容如下：**\r\n\r\n```shell\r\nzhangsan 68 99 26\r\nlisi 98 66 96\r\nwangwu 38 33 86\r\nzhaoliu 78 44 36\r\nmaq 88 22 66\r\nzhouba 98 44 46\r\n```\r\n\r\n **2、搜索含有 zhang  和 li 的学生成绩：**\r\n\r\n```shell\r\ncat czbk-txt.txt | awk \'/zhang|li/\'\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577178031588](./img/linux/java-linux/Linux-v10-02天-授课/1577178031588.png)\r\n\r\n**指定分割符, 根据下标显示内容**\r\n\r\n| 命令                                        | 含义                                                         |\r\n| ------------------------------------------- | ------------------------------------------------------------ |\r\n| awk   -F  \',\'    \'{print $1, $2, $3}\'  文件 | 操作1.txt文件,  根据 逗号 分割, 打印 第一段 第二段 第三段 内容 |\r\n\r\n选项\r\n\r\n| 选项       | 英文            | 含义                     |\r\n| ---------- | --------------- | ------------------------ |\r\n| `-F \',\'`   | field-separator | 使用 **指定字符** 分割   |\r\n| `$ + 数字` |                 | 获取**第几段**内容       |\r\n| `$0`       |                 | 获取 **当前行** 内容     |\r\n| `NF`       | field           | 表示当前行共有多少个字段 |\r\n| `$NF`      |                 | 代表 最后一个字段        |\r\n| `$(NF-1)`  |                 | 代表 倒数第二个字段      |\r\n| `NR`       |                 | 代表 处理的是第几行      |\r\n\r\n```\r\n# 查看文档内容\r\ncat czbk-txt.txt \r\n#直接输出\r\ncat score.txt | awk -F \' \' \'{print $1,$2,$3}\'\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577178523300](./img/linux/java-linux/Linux-v10-02天-授课/1577178523300.png)\r\n\r\n**指定分割符, 根据下标显示内容**\r\n\r\n| 命令                                                    | 含义                                                         |\r\n| ------------------------------------------------------- | ------------------------------------------------------------ |\r\n| awk   -F  \' \'    \'{OFS="==="}{print $1, $2, $3}\'  1.txt | 操作1.txt文件,  根据 逗号 分割, 打印 第一段 第二段 第三段 内容 |\r\n\r\n选项\r\n\r\n| 选项         | 英文                   | 含义                     |\r\n| ------------ | ---------------------- | ------------------------ |\r\n| `OFS="字符"` | output field separator | 向外输出时的段分割字符串 |\r\n\r\n| 转义序列 | 含义   |\r\n| -------- | ------ |\r\n| \\b       | 退格   |\r\n| \\f       | 换页   |\r\n| \\n       | 换行   |\r\n| \\r       | 回车   |\r\n| \\t       | 制表符 |\r\n\r\n```\r\n# 按照 === 进行分割, 打印 第一段 第二段 第三段\r\ncat  czbk-txt.txt | awk -F \' \' \'{OFS="==="}{print $1,$2,$3}\'\r\n# 按照 制表符tab 进行分割, 打印 第一段 第二段 第三段\r\ncat czbk-txt.txt| awk -F \' \' \'{OFS="\\t"}{print $1,$2,$3}\'\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577178563336](./img/linux/java-linux/Linux-v10-02天-授课/1577178563336.png)\r\n\r\n![1577179227699](./img/linux/java-linux/Linux-v10-02天-授课/1577179227699.png)\r\n\r\n**调用 awk 提供的函数**\r\n\r\n| 命令                                           | 含义                                                         |\r\n| ---------------------------------------------- | ------------------------------------------------------------ |\r\n| awk   -F  \',\'    \'{print  toupper($2)}\'  1.txt | 操作1.txt文件,  根据 逗号 分割, 打印 第一段 第二段 第三段 内容 |\r\n\r\n常用函数如下:\r\n\r\n| 函数名    | 含义   | 作用           |\r\n| --------- | ------ | -------------- |\r\n| toupper() | upper  | 字符 转成 大写 |\r\n| tolower() | lower  | 字符 转成小写  |\r\n| length()  | length | 返回 字符长度  |\r\n\r\n```\r\n# 打印第一段内容\r\n cat czbk-txt.txt | awk -F \' \' \'{print $1}\'\r\n# 将第一段内容转成大写 且 显示 \r\n cat czbk-txt.txt | awk -F \' \' \'{print toupper($1)}\'\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577180402362](./img/linux/java-linux/Linux-v10-02天-授课/1577180402362.png)\r\n\r\n**求指定学科平均分**\r\n\r\n| 命令                                                         | 含义                                                         |\r\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\r\n| awk \'BEGIN{初始化操作}{每行都执行} END{结束时操作}\'   文件名 | BEGIN{ 这里面放的是执行前的语句 }<br />{这里面放的是处理每一行时要执行的语句}<br />END {这里面放的是处理完所有的行后要执行的语句 } |\r\n\r\n**查看czbk-txt.txt 文件内容**\r\n\r\n```shell\r\ncat czbk-txt.txt \r\n```\r\n\r\n执行效果如下\r\n\r\n![1577180698120](./img/linux/java-linux/Linux-v10-02天-授课/1577180698120.png)\r\n\r\n**查看总分**\r\n\r\n注意：这里计算的是第4列的总分\r\n\r\n```shell\r\ncat czbk-txt.txt| awk -F \' \' \'BEGIN{}{total=total+$4} END{print total}\'\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577180583110](./img/linux/java-linux/Linux-v10-02天-授课/1577180583110.png)\r\n\r\n**查看总分, 总人数**\r\n\r\n注意：这里计算的是第4列的\r\n\r\n```shell\r\ncat czbk-txt.txt| awk -F \' \' \'BEGIN{}{total=total+$4} END{print total, NR}\'\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577180635136](./img/linux/java-linux/Linux-v10-02天-授课/1577180635136.png)\r\n\r\n**查看总分, 总人数, 平均分**\r\n\r\n注意：这里计算的是第4列的\r\n\r\n```shell\r\n cat czbk-txt.txt | awk -F \' \' \'BEGIN{}{total=total+$4} END{print total, NR, (total/NR)}\'\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577180660454](./img/linux/java-linux/Linux-v10-02天-授课/1577180660454.png)\r\n\r\n> 总结\r\n>\r\n> awk在使用过程中主要用作分析\r\n>\r\n> 简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理\r\n\r\n## 1.5  软连接\r\n\r\n```\r\n软连接其实就类似于我们在Windows中的【快捷方式】\r\n```\r\n\r\n- 在Linux**文件名** 和 **内容** 是两个文件, 分开的!![1558439106175](./img/linux/java-linux/Linux-v10-02天-授课/1558439106175.png)\r\n\r\n\r\n\r\n- 创建软链接的原理, 如下![1558439158250](./img/linux/java-linux/Linux-v10-02天-授课/1558439158250.png)\r\n\r\n  为什么有软连接？\r\n\r\n  因为 某些文件和目录 的 **路径很深**, 所以 需要增加 **软链接(快捷方式)**\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法如下:**\r\n\r\n| 命令                                      | 英文 | 作用                                         |\r\n| ----------------------------------------- | ---- | -------------------------------------------- |\r\n| ln **-s**  目标文件绝对路径  快捷方式路径 | link | 给目标文件增加一个软链接, 通俗讲就是快捷方式 |\r\n\r\n**给home/itcast/txtfile.txt文件增加软连接**\r\n\r\n```shell\r\n ln  -s /home/itcast/txtfile.txt    czbk-txt\r\n```\r\n\r\n上面；我们将/home/itcast/路径下的txtfile.txt文件增加软连接到\r\n\r\nczbk-txt，然后通过cat 访问czbk-txt也是可以正常访问的\r\n\r\n如下图\r\n\r\n![1576723058556](./img/linux/java-linux/Linux-v10-02天-授课/1576723058556.png)\r\n\r\n> 总结\r\n>\r\n> 通过 `ln -s 源文件的绝对路径 其实就是给**目标文件** 增加 **快捷方式**\r\n\r\n## 1.6 find查找\r\n\r\n```\r\n引子\r\nfind命令类似与在Windows中全局查找（如下图）\r\n```\r\n\r\n![1576828863833](./img/linux/java-linux/Linux-v10-02天-授课/1576828863833.png)\r\n\r\n**find概念**\r\n\r\nfind命令用来在指定目录下查找文件。\r\n\r\n任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。\r\n\r\n**语法**\r\n\r\n```shell\r\nfind <指定目录> <指定条件> <指定内容>\r\n```\r\n\r\n**1、将目前目录及其子目录下所有延伸档名是 gz 的文件查询出来** \r\n\r\n```shell\r\nfind . -name "*.gz"\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576829221486](./img/linux/java-linux/Linux-v10-02天-授课/1576829221486.png)\r\n\r\n\r\n\r\n**2、将目前目录及其子目录下所有最近 1天内更新过的文件查询出来**\r\n\r\n```shell\r\nfind . -ctime -1\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576829352063](./img/linux/java-linux/Linux-v10-02天-授课/1576829352063.png)\r\n\r\n**3、全局搜索czbk**\r\n\r\n/代表是全盘搜索,也可以指定目录搜索 \r\n\r\n```shell\r\n find / -name  \'czbk\'\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576829929308](./img/linux/java-linux/Linux-v10-02天-授课/1576829929308.png)\r\n\r\n## 1.7 read命令\r\n\r\n> 注意：\r\n>\r\n> read命令属于文件范畴的命令\r\n>\r\n> 在下面的演示中，会涉及到shell，shell章节在最后一章\r\n>\r\n> 建议：讲解shell的时候在回过来说下read命令的语法\r\n>\r\n> 我们在综合案例中也会降到read\r\n\r\n```\r\n引子：\r\nread命令相当于在java SE阶段我们学习的键盘录入输入Scanner（read命令会比Scanner更强大），开发人员可以动态的与程序交互，\r\n```\r\n\r\nread命令用于从标准输入读取数值。\r\n\r\nread 内部命令被用来从标准输入读取单行数据。这个命令可以用来读取键盘输入，当使用重定向的时候，可以读取文件中的一行数据。\r\n\r\n**语法**\r\n\r\n```\r\nread [-ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]\r\n```\r\n\r\n**1、简单读取**\r\n\r\n```shell\r\n#!/bin/bash\r\necho "请您输入网站名: "  \r\n#读取从键盘的输入  \r\nread website  \r\necho "你输入的网站名是 $website"  \r\nexit 0  #退出\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577409765115](./img/linux/java-linux/Linux-v10-02天-授课/1577409765115.png)\r\n\r\n\r\n\r\n**3、读取文件**\r\n\r\n每次调用 read 命令都会读取文件中的 "一行" 文本。当文件没有可读的行时，read 命令将以非零状态退出。\r\n\r\n我们可以使用 cat 命令将结果直接传送给包含 read 命令的 while 命令。\r\n\r\n测试文件 test.txt 内容如下：\r\n\r\n```\r\nAAAAAAAAAAAAAAAAAAAAAA\r\nBBBBBBBBBBBBBBBBBBBBBB\r\nCCCCCCCCCCCCCCCCCCCCCC\r\nDDDDDDDDDDDDDDDDDDDDDD\r\n================传智播客\r\n```\r\n\r\n脚本如下，可以将脚本放到xxx.sh中进行执行\r\n\r\n```shell\r\n#!/bin/bash\r\ncount=1\r\ncat test.txt | while read line      \r\n# cat 命令的输出作为read命令的输入,read读到>的值放在line中\r\ndo\r\n   echo "Line $count:$line"\r\n   count=$[ $count + 1 ]          # 注意中括号中的空格。\r\ndone\r\necho "finish"\r\nexit 0\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577410272633](./img/linux/java-linux/Linux-v10-02天-授课/1577410272633.png)\r\n\r\n> 总结\r\n>\r\n> 由此可看read命令不仅可以读取键盘输入，而且还可以读取静态文件\r\n\r\n## 1.8 总结\r\n\r\n文件命令是我们在开发过程中最经常使用的到的命令，所以，我们在学习过程中一定要认真学习文件的常用命令，比如文件创建、编写、读取命令。\r\n\r\n# 2 Linux备份压缩\r\n\r\n```\r\n在Windows中我们对于一个大文件进行压缩的时候，通常会使用第三方工具，比如360压缩、快压等工具，把一个文件压缩成.zip格式的压缩文件；而在Linux中我们也可以通过各种命令实现压缩的功能。\r\n```\r\n\r\n## **2.1 gzip命令**\r\n\r\n```\r\n压缩/解压缩文件，不能压缩目录\r\nwindows下接触的压缩文件大多是.rar，.7z格式，Linux下，不能识别这种格式。\r\n.zip格式的文件在Windows和Linux下都能使用。\r\n压缩文件，能节省磁盘空间，传输时能节省网络带宽\r\n```\r\n\r\ngzip命令用于压缩文件。\r\n\r\ngzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出".gz"的扩展名\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法**\r\n\r\n```shell\r\ngzip[参数][文件或者目录]\r\n```\r\n\r\n**1、压缩目录下的所有文件**\r\n\r\n数据准备，新建一个目录，里面随便新建4个文件\r\n\r\n```shell\r\nmkdir  gzipTest\r\ncd gzipTest/\r\ntouch  001\r\ntouch  002\r\ntouch  003\r\ntouch  004\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576736152636](./img/linux/java-linux/Linux-v10-02天-授课/1576736152636.png)\r\n\r\n**1、压缩目录下的所有文件**\r\n\r\n```shell\r\ngzip * \r\n```\r\n\r\n![1576736179025](./img/linux/java-linux/Linux-v10-02天-授课/1576736179025.png)\r\n\r\n**2、 列出详细的信息**\r\n\r\n解压文件并列出详细信息\r\n\r\n```shell\r\ngzip -dv *\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576736286406](./img/linux/java-linux/Linux-v10-02天-授课/1576736286406.png)\r\n\r\n\r\n\r\n## 2.2 gunzip命令\r\n\r\n```\r\ngunzip是个使用广泛的解压缩程序，它用于解开被gzip压缩过的文件\r\n```\r\n\r\ngunzip命令用于解压文件。\r\n\r\n**语法**\r\n\r\n```\r\ngunzip[参数][文件或者目录]\r\n```\r\n\r\n```shell\r\ngunzip 001.gz \r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576738711718](./img/linux/java-linux/Linux-v10-02天-授课/1576738711718.png)\r\n\r\n001为解压后的文件\r\n\r\n## 2.3 tar命令\r\n\r\n```\r\ntar的主要功能是打包、压缩和解压文件。\r\n\r\ntar本身不具有压缩功能。他是调用压缩功能实现的 。\r\n```\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法**\r\n\r\n```shell\r\ntar[必要参数][选择参数][文件] \r\n```\r\n\r\n**1、将 txtfile.txt文件打包（仅打包，不压缩）**\r\n\r\ntxtfile.txt文件为上面章节的例子\r\n\r\n```shell\r\ntar -cvf txt.tar txtfile.txt \r\n```\r\n\r\n执行效果如下\r\n\r\n![1576726937758](./img/linux/java-linux/Linux-v10-02天-授课/1576726937758.png)\r\n\r\n **2、将 txtfile.txt文件打包压缩（打包压缩（gzip））**\r\n\r\n```shell\r\ntar -zcvf txt.tar.gz txtfile.txt \r\n```\r\n\r\n执行效果如下\r\n\r\n![1576727107465](./img/linux/java-linux/Linux-v10-02天-授课/1576727107465.png)\r\n\r\n>  总结\r\n>\r\n> 参数 f 之后的文件档名是自己取的，我们习惯上都用 .tar 来作为辨识。 如果加 z 参数，则以 .tar.gz 或 .tgz 来代表 gzip 压缩过的 tar包\r\n\r\n**3、查看tar中有哪些文件**\r\n\r\n```shell\r\ntar -ztvf txt.tar.gz\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576734505587](./img/linux/java-linux/Linux-v10-02天-授课/1576734505587.png)\r\n\r\n压缩包中的文件有txtfile.txt\r\n\r\n**4、将tar 包解压缩**\r\n\r\n```shell\r\n1.新建目录\r\n mkdir ysFiles\r\n2.复制\r\n cp txt.tar.gz ./ysFiles/\r\n3.解压缩\r\n tar -zxvf /home/itcast/ysFiles/txt.tar.gz\r\n```\r\n\r\n解压后的文件如下\r\n\r\n![1576735062585](./img/linux/java-linux/Linux-v10-02天-授课/1576735062585.png)\r\n\r\n## 2.4 zip命令\r\n\r\n```\r\n引子\r\nzip命令就完全的相当于在Windows下面选中文件右键进行压缩了\r\n```\r\n\r\nzip命令用于压缩文件。\r\n\r\nzip是个使用广泛的压缩程序，文件经它压缩后会另外产生具有".zip"扩展名的压缩文件。\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法**\r\n\r\n```\r\nzip[必要参数][选择参数][文件] \r\n```\r\n\r\n将上面/home/itcast/gzipTest 这个目录下所有文件和文件夹打包为当前目录下的 zFiles.zip：\r\n\r\n```shell\r\n1.在目录下新建一个005目录\r\nmkdir 005\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576736751949](./img/linux/java-linux/Linux-v10-02天-授课/1576736751949.png)\r\n\r\n开始压缩\r\n\r\n```shell\r\n2.压缩\r\nzip -q -r zFiles.zip *\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576736844251](./img/linux/java-linux/Linux-v10-02天-授课/1576736844251.png)zFiles.zip文件就是我们刚刚压缩后的文件\r\n\r\n## 2.5 unzip命令\r\n\r\n```\r\n引子\r\nunzip命令就完全的相当于在Windows下面选中文件右键进行解压缩了\r\n```\r\n\r\nLinux unzip命令用于解压缩zip文件\r\n\r\nunzip为.zip压缩文件的解压缩程序\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法**\r\n\r\n```\r\nunzip[必要参数][选择参数][文件] \r\n```\r\n\r\n**参数**：\r\n\r\n上接上面的zip的例子\r\n\r\n**1、查看压缩文件中包含的文件：**\r\n\r\n```shell\r\n unzip -l zFiles.zip\r\n```\r\n\r\n![1576737168412](./img/linux/java-linux/Linux-v10-02天-授课/1576737168412.png)\r\n\r\n包含了压缩文件里面文件的详细信息\r\n\r\n文件大小  日期 时间  文件名称\r\n\r\n总数量和总大小\r\n\r\n**2、如果要把文件解压到指定的目录下，需要用到-d参数**\r\n\r\n```shell\r\n1.新建目录\r\nunFiles\r\n2.解压缩\r\nunzip -d ./unFiles zFiles.zip\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576737722160](./img/linux/java-linux/Linux-v10-02天-授课/1576737722160.png)\r\n\r\n 查看解压后的文件，如下图\r\n\r\n![1576737744650](./img/linux/java-linux/Linux-v10-02天-授课/1576737744650.png)\r\n\r\n\r\n\r\n## 2.6 bzip2命令\r\n\r\n```\r\n引子\r\n".bz2"格式是 Linux 的另一种压缩格式，从理论上来讲，".bz2"格式的算法更先进、压缩比更好；而 咱们上面学到的".gz"格式相对来讲时间更快\r\n在使用过程中可以根据需求自由选择\r\n```\r\n\r\nbzip2命令是.bz2文件的压缩程序。\r\n\r\nbzip2采用新的压缩演算法，压缩效果比传统的LZ77/LZ78压缩演算法来得好。若没有加上任何参数，bzip2压缩完文件后会产生.bz2的压缩文件，并删除原始的文件。\t\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法**\r\n\r\n```\r\nbzip2 [-cdfhkLstvVz][--repetitive-best][--repetitive-fast][- 压缩等级][要压缩的文件]\r\n```\r\n\r\n**1、压缩文件**\r\n\r\n```\r\n1.创建目录\r\n mkdir  bzFiles\r\n cd ./bzFiles/\r\n2.创建文件\r\ntouch 001\r\n3.压缩\r\nbzip2 001\r\nll\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576742060052](./img/linux/java-linux/Linux-v10-02天-授课/1576742060052.png)\r\n\r\n如上图001.bz2就是压缩后的文件\r\n\r\n## **2.7 bunzip2命令**\r\n\r\n```\r\n引子\r\nLinux bunzip2命令是.bz2文件的解压缩程序。\r\n```\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法**：\r\n\r\n```shell\r\nbunzip2 [-fkLsvV][.bz2压缩文件]\r\n```\r\n\r\n**参数**：\r\n\r\n**解压.bz2文件**\r\n\r\n```shell\r\nbunzip2 -v 001.bz2 \r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576744907366](./img/linux/java-linux/Linux-v10-02天-授课/1576744907366.png)\r\n\r\n001文件即是被解压后的\r\n\r\n## 2.8 总结\r\n\r\ngz：由gzip压缩工具压缩的文件。\r\n\r\n.bz2：由bzip2压缩工具压缩的文件。\r\n\r\n.tar：由tar打包程序打包的文件（tar没有压缩功能，只是把一个 目录合并成一个文件）\r\n\r\n.tar.gz：可理解为先由tar打包，再由gz压缩。\r\n\r\n.zip:可理解为由zip压缩工具直接压缩\r\n\r\n# 3 网络与磁盘管理\r\n\r\n> Tips:\r\n>\r\n> 重点讲解内容\r\n\r\n## **3.1 网络命令**\r\n\r\n### 3.1.1 ifconfig命令\r\n\r\n```\r\n引子：\r\n\r\nifconfig命令有点类似于Windows的ipconfig命令\r\n```\r\n\r\nifconfig是Linux中用于显示或配置网络设备的命令，英文全称是network interfaces configuring\r\n\r\n ifconfig命令用于显示或设置网络设备。\r\n\r\nifconfig可设置网络设备的状态，或是显示目前的设置。\r\n\r\n**使用者权限：所有（设置级别的需要管理员）用户**\r\n\r\n**语法**\r\n\r\n```\r\nifconfig [网络设备][down up -allmulti -arp -promisc][add<地址>][del<地址>][<hw<网络设备类型><硬件地址>][io_addr<I/O地址>][irq<IRQ地址>][media<网络媒介类型>][mem_start<内存地址>][metric<数目>][mtu<字节>][netmask<子网掩码>][tunnel<地址>][-broadcast<地址>][-pointopoint<地址>][IP地址]\r\n```\r\n\r\n**1、显示激活的网卡信息**\r\n\r\n```\r\nifconfig\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576749039798](./img/linux/java-linux/Linux-v10-02天-授课/1576749039798.png)\r\n\r\n![1576749055869](./img/linux/java-linux/Linux-v10-02天-授课/1576749055869.png)\r\n\r\n**ens33（有的是eth0）**表示第一块网卡。\r\n\r\n表示ens33网卡的 IP地址是 192.168.23.129，广播地址，broadcast 192.168.23.255，掩码地址netmask:255.255.255.0 ，inet6对应的是ipv6\r\n\r\n**ens37** 表示第二块网卡\r\n\r\n**lo** 是表示主机的回坏地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口 \r\n\r\n启动关闭指定网卡\r\n\r\n**virbr0**是一种虚拟网络接口\r\n\r\n**2、关闭网卡（需要切换到管理员账户）**\r\n\r\n```shell\r\n ifconfig ens37 down\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576748850255](./img/linux/java-linux/Linux-v10-02天-授课/1576748850255.png)\r\n\r\n**3、启用网卡（需要切换到管理员账户）**\r\n\r\n```shell\r\nifconfig ens37 up\r\n```\r\n\r\n 执行效果如下\r\n\r\n![1576748937884](./img/linux/java-linux/Linux-v10-02天-授课/1576748937884.png)\r\n\r\n**4、配置ip信息**\r\n\r\n```shell\r\n// 配置ip地址\r\nifconfig ens37 192.168.23.199\r\n// 配置ip地址和子网掩码\r\nifconfig ens37 192.168.23.133 netmask 255.255.255.0\r\n```\r\n\r\n执行效果如下，配置ip地址：\r\n\r\n![1576749864267](./img/linux/java-linux/Linux-v10-02天-授课/1576749864267.png)\r\n\r\n查看ip，如下图\r\n\r\n![1576749896757](./img/linux/java-linux/Linux-v10-02天-授课/1576749896757.png)\r\n\r\n配置ip地址和子网掩码，执行效果如下图\r\n\r\n![1576749957171](./img/linux/java-linux/Linux-v10-02天-授课/1576749957171.png)\r\n\r\n这样的话我们就可以通过命令的方式设置网卡的网络信息了。\r\n\r\n### 3.1.2 ping命令\r\n\r\n```\r\n等价于Windows的ping命令\r\n```\r\n\r\nping命令用于检测主机。\r\n\r\n执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法**\r\n\r\n```shell\r\nping [-dfnqrRv][-c<完成次数>][-i<间隔秒数>][-I<网络界面>][-l<前置载入>][-p<范本样式>][-s<数据包大小>][-t<存活数值>][主机名称或IP地址]\r\n```\r\n\r\n**1、检测是否与主机连通**\r\n\r\n```shell\r\n ping www.baidu.com\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576750258293](./img/linux/java-linux/Linux-v10-02天-授课/1576750258293.png)\t\r\n\r\nicmp_seq：ping序列，从1开始\r\n\r\nttl:IP生存时间值\r\n\r\ntime: 响应时间,数值越小，联通速度越快\r\n\r\n**2、指定接收包的次数**\r\n\r\n和上面不同的是：收到两次包后，自动退出\r\n\r\n```shell\r\nping -c 2 www.baidu.com\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576750967595](./img/linux/java-linux/Linux-v10-02天-授课/1576750967595.png)\r\n\r\n> 总结：\r\n>\r\n> ping命令也是我们在开发过程中常用到的命令\r\n>\r\n> 通常使用  ping  xxx.xxx.xxx.xxx命令进行检测本地与目标机器是否连通\r\n\r\n### 3.1.3 netstat命令\r\n\r\n```\r\n利用netstat指令可让你得知整个Linux系统的网络情况\r\n```\r\n\r\nnetstat命令用于显示网络状态。\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法**\r\n\r\n```\r\nnetstat [-acCeFghilMnNoprstuvVwx][-A<网络类型>][--ip]\r\n```\r\n\r\n**1、显示详细的连接状况**\r\n\r\n```shell\r\nnetstat -a\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576751379320](./img/linux/java-linux/Linux-v10-02天-授课/1576751379320.png)\r\n\r\n比如上面的【0 0.0.0.0:ssh】它是远程终端连接Linux的ssh服务，默认使用了22端口，它的状态【State】是处于监听状态，属于正常。\r\n\r\n**2、显示网卡列表**\r\n\r\n```shell\r\nnetstat -i\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576751502980](./img/linux/java-linux/Linux-v10-02天-授课/1576751502980.png)\r\n\r\n上图显示的是我们在介绍【ifconfig】命令的时候看到的网卡信息\r\n\r\n## 3.2 磁盘命令\r\n\r\n### **3.2.1 lsblk命令**\r\n\r\n```\r\n使用lsblk命令可以以tree的形式展示所有设备的信息\r\n```\r\n\r\nlsblk命令的英文是“list block”，即用于列出所有可用块设备的信息，而且还能显示他们之间的依赖关系，但是它不会列出RAM盘的信息。\r\n\r\n**语法格式：**lsblk [参数]\r\n\r\n**使用者权限：所有用户**\r\n\r\n**1、lsblk命令默认情况下将以树状列出所有块设备：**\r\n\r\n```shell\r\nlsblk\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576827840642](./img/linux/java-linux/Linux-v10-02天-授课/1576827840642.png)\r\n\r\nNAME : 这是块设备名。\r\n\r\nMAJ:MIN : 本栏显示主要和次要设备号。\r\n\r\nRM : 本栏显示设备是否可移动设备。注意，在上面设备sr0的RM值等于1，这说明他们是可移动设备。\r\n\r\nSIZE : 本栏列出设备的容量大小信息。\r\n\r\nRO : 该项表明设备是否为只读。在本案例中，所有设备的RO值为0，表明他们不是只读的。\r\n\r\nTYPE :本栏显示块设备是否是磁盘或磁盘上的一个分区。在本例中，sda和sdb是磁盘，而sr0是只读存储（rom）。\r\n\r\nMOUNTPOINT : 本栏指出设备挂载的挂载点。\r\n\r\n**2、默认选项不会列出所有空设备：**\r\n\r\n```shell\r\nlsblk -f\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576828112552](./img/linux/java-linux/Linux-v10-02天-授课/1576828112552.png)\r\n\r\nNAME表示设备名称\r\n\r\nFSTYPE表示文件类型\r\n\r\nLABEL表示设备标签\r\n\r\nUUID设备编号\r\n\r\nMOUNTPOINT表示设备的挂载点\r\n\r\n> 注意\r\n>\r\n> 我们学习这个命令主要是在下面将要学习的fdisk分区中会经常使用到\r\n\r\n### 3.2.2 df命令\r\n\r\n```\r\n引子（如下图）：\r\nLinux的df命令类似于在Windows中的【计算机】--【管理】--【磁盘管理】菜单对磁盘的统计情况查看\r\n```\r\n\r\n![1576751996364](./img/linux/java-linux/Linux-v10-02天-授课/1576751996364.png)\r\n\r\n df命令用于显示目前在Linux系统上的文件系统的磁盘使用情况统计。\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法**\r\n\r\n```\r\ndf [选项]... [FILE]...\r\n```\r\n\r\n**1、显示磁盘使用情况统计情况**\r\n\r\n```\r\ndf  \r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576752158168](./img/linux/java-linux/Linux-v10-02天-授课/1576752158168.png)\r\n\r\n第一列指定文件系统的名称\r\n\r\n第二列指定一个特定的文件系统1K-块1K是1024字节为单位的总容量。\r\n\r\n已用和可用列分别指定的容量。\r\n\r\n最后一个已用列指定使用的容量的百分比\r\n\r\n最后一栏指定的文件系统的挂载点。\r\n\r\n**2、df命令也可以显示磁盘使用的文件系统信息**\r\n\r\n比如我们df下之前创建过的目录gzipTest的使用情况\r\n\r\n```\r\ndf  gzipTest/\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576752596414](./img/linux/java-linux/Linux-v10-02天-授课/1576752596414.png)\r\n\r\n**3、df显示所有的信息**\r\n\r\n```\r\ndf --total \r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576752719226](./img/linux/java-linux/Linux-v10-02天-授课/1576752719226.png)\r\n\r\n我们看到输出的末尾，包含一个额外的行，显示总的每一列。\r\n\r\n 4、df换算后显示\r\n\r\n```shell\r\ndf -h \r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576752819456](./img/linux/java-linux/Linux-v10-02天-授课/1576752819456.png)\r\n\r\n我们可以看到输出显示的数字形式的\'G\'（千兆字节），"M"（兆字节）和"K"（千字节）。\r\n\r\n这使输出容易阅读和理解，从而使显示可读的。请注意，第二列的名称也发生了变化，为了使显示可读的"容量"。\r\n\r\n### 3.2.3 mount命令\r\n\r\n```\r\n在Linux当中所有的存储设备如u盘、光盘、硬盘等，都必须挂载之后才能正常使用。\r\n\r\n其实挂载可以理解为Windows当中的分配盘符（重要），只不过windows当中是以英文字母ABCD等作为盘符，而linux是拿系统目录作为盘符，当然linux当中也不叫盘符，而是称为挂载点，而把为分区或者光盘等存储设备分配一个挂载点的过程称为挂载\r\n```\r\n\r\n mount命令是经常会使用到的命令，它用于挂载Linux系统外的文件。\r\n\r\n**挂载概念**\r\n\r\n在安装linux系统时设立的各个分区，如根分区、/boot分区等都是自动挂载的，也就是说不需要我们人为操作，开机就会自动挂载。但是光盘、u盘等存储设备如果需要使用，就必须人为的进行挂载。\r\n\r\n其实我们在windows下插入U盘也是需要挂载(分配盘符)的，只不过windows下分配盘符是自动的\r\n\r\nLinux中的根目录以外的文件要想被访问，需要将其“关联”到根目录下的某个目录来实现，这种关联操作就是“挂载”，这个目录就是“挂载点”，解除次关联关系的过程称之为“卸载”。\r\n\r\n**注意：“挂载点”的目录需要以下几个要求：**\r\n\r\n（1）目录事先存在，可以用mkdir命令新建目录；\r\n\r\n（2）挂载点目录不可被其他进程使用到；\r\n\r\n（3）挂载点下原有文件将被隐藏。\r\n\r\n**使用者权限：所有用户，设置级别的需要管理员**\r\n\r\n**语法**\r\n\r\n```\r\nmount [-hV]\r\nmount -a [-fFnrsvw] [-t vfstype]\r\nmount [-fnrsvw] [-o options [,...]] device | dir\r\nmount [-fnrsvw] [-t vfstype] [-o options] device dir\r\n```\r\n\r\n需求:\r\n比如现在我们要通过挂载的方式查看Linux CD/DVD光驱里面的内容\r\n\r\n**1、CD/DVD设置**\r\n\r\n进入【虚拟机】--【设置】\r\n\r\n![1576805605263](./img/linux/java-linux/Linux-v10-02天-授课/1576805605263.png)\r\n\r\n\r\n\r\n设置CD/DVD的内容，我们这里使用的是F:\\CentOS-7-x86_64-DVD-1810.iso\r\n\r\n![1576805634085](./img/linux/java-linux/Linux-v10-02天-授课/1576805634085.png)\r\n\r\n查看F:\\CentOS-7-x86_64-DVD-1810.iso；里面的内容\r\n\r\n![1576805690039](./img/linux/java-linux/Linux-v10-02天-授课/1576805690039.png)\r\n\r\n\r\n\r\n**2、创建挂载点**\r\n\r\n注意：一般用户无法挂载cdrom,只有root用户才可以操作\r\n\r\n我们切换到root下创建一个挂载点（其实就是创建一个目录）\r\n\r\n```shell\r\nmkdir  -p mnt/cdrom\r\n```\r\n\r\n**3、开始挂载**\r\n\r\n通过挂载点的方式查看上面的【ISO文件内容】\r\n\r\n```shell\r\nmount -t auto /dev/cdrom /mnt/cdrom\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576807195774](./img/linux/java-linux/Linux-v10-02天-授课/1576807195774.png)\r\n\r\n表示挂载成功\r\n\r\n**4、查看挂载点内容**\r\n\r\n```shell\r\nls -l -a ./mnt/cdrom/\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576807395970](./img/linux/java-linux/Linux-v10-02天-授课/1576807395970.png)\r\n\r\n如上图所示，我们通过挂载点查看CD/DVD的文件个数是14个，和上面的【ISO文件内容】个数一致。\r\n\r\n**5、卸载cdrom**\r\n\r\n在前面我们将CD/DVD挂载到了文件系统，如果我们不用了，就可以将其卸载掉\r\n\r\n```\r\numount ./mnt/cdrom/\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576807774194](./img/linux/java-linux/Linux-v10-02天-授课/1576807774194.png)\r\n\r\n我们发现卸载后，通过挂载点就无法查看CD/DVD里面的数据了。\r\n\r\n## 3.3 总结\r\n\r\n关于挂载：用户**不能**直接访问 硬件设备需要将硬件设备 **挂载** 到 系统目录上,  才可以让用户访问。\r\n\r\n# 4 shell与安装\r\n\r\n> tips\r\n>\r\n> 重点讲解内容\r\n\r\n## 4.1 yum使用\r\n\r\n```\r\n引子：\r\nyum类似于开发工具idea、eclipse中的在线插件安装商店\r\n我们输入一个将要安装的插件名字，进行搜索、安装的过程。\r\n```\r\n\r\n**yum概念**\r\n\r\nyum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。\r\n\r\nyum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。\r\n\r\n**yum原理**\r\n\r\n![1576833281476](./img/linux/java-linux/Linux-v10-02天-授课/1576833281476.png)\r\n\r\n> **注意：必须联网**\r\n>\r\n> 不同的服务通过yum命令连接远程yum源进行查找、下载、安装\r\n\r\n**使用者权限：管理员**\r\n\r\n**语法**\r\n\r\n```shell\r\nyum [options] [command] [package ...]\r\n```\r\n\r\n- **options：**可选，选项包括-h（帮助），-y（当安装过程提示选择全部为"yes"），-q（不显示安装的过程）等等。\r\n- **command：**要进行的操作。\r\n- **package**操作的对象。\r\n\r\n------\r\n\r\n**yum常用命令**\r\n\r\n- 1.列出所有可更新的软件清单命令：yum check-update\r\n- 2.更新所有软件命令：yum update\r\n- 3.仅安装指定的软件命令：yum install <package_name>\r\n- 4.仅更新指定的软件命令：yum update <package_name>\r\n- 5.列出所有可安裝的软件清单命令：yum list\r\n- 6.删除软件包命令：yum remove <package_name>\r\n- 7.查找软件包 命令：yum search <keyword>\r\n- 8.清除缓存命令:\r\n  - yum clean packages: 清除缓存目录下的软件包\r\n  - yum clean headers: 清除缓存目录下的 headers\r\n  - yum clean oldheaders: 清除缓存目录下旧的 headers\r\n  - yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers\r\n\r\n### **4.1.1 安装tree**\r\n\r\n```shell\r\nyum -y install tree   //y当安装过程提示选择全部为"yes"\r\n```\r\n\r\n执行效果如下\r\n\r\n注意：第一次在itcast用户执行的时候\r\n\r\n提示我们【需要管理员权限】\r\n\r\n![1576554600128](./img/linux/java-linux/Linux-v10-02天-授课/1576554600128.png)\r\n\r\n![1576554617660](./img/linux/java-linux/Linux-v10-02天-授课/1576554617660.png)\r\n\r\n安装完执行tree命令\r\n\r\n```shell\r\ntree\r\n```\r\n\r\n![1576832663328](./img/linux/java-linux/Linux-v10-02天-授课/1576832663328.png)\r\n\r\n### **4.1.2 移除tree**\r\n\r\n```shell\r\nyum remove  tree\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576832810922](./img/linux/java-linux/Linux-v10-02天-授课/1576832810922.png)\r\n\r\n此时，我们在执行tree命令\r\n\r\n```shell\r\ntree\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576832843434](./img/linux/java-linux/Linux-v10-02天-授课/1576832843434.png)\r\n\r\n如上图，由于我们移除了tree，在执行tree命令的时候发现找不到这个命令了。\r\n\r\n### **4.1.3 yum查找**\r\n\r\n利用 yum 的功能，找出以 tom 为开头的软件名称有哪些\r\n\r\n```shell\r\nyum list tom*\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576832953119](./img/linux/java-linux/Linux-v10-02天-授课/1576832953119.png)\r\n\r\n### 4.1.4 yum源\r\n\r\n**概述**\r\n\r\nyum需要一个yum库，也就是yum源。\r\n\r\n简单的说，我们安装软件的时候需要下载软件，将很多软件放在一起就是源。软件安装包的来源，所以yum源就是软件安装包来源 \r\n\r\n**yum源分类**\r\n\r\n目前，yum默认使用的是CentOS的yum源，如下\r\n\r\n  ![1576834523252](./img/linux/java-linux/Linux-v10-02天-授课/1576834523252.png)\r\n\r\n![1576834556997](./img/linux/java-linux/Linux-v10-02天-授课/1576834556997.png)\r\n\r\n目前，国内有很多不错的yum源，比如阿里、网易、搜狐等\r\n\r\n**安装阿里yum源**\r\n\r\n因为默认的yum源服务器在国外，我们在安装软件的时候会受到速度的影响，所以安装国内yum源在下载的时候速度、稳定性会比国外的好很多。\r\n\r\n**1) 安装wget**\r\n\r\n```shell\r\nyum install -y wget\r\n```\r\n\r\n 执行效果如下\r\n\r\n![1576834799803](./img/linux/java-linux/Linux-v10-02天-授课/1576834799803.png)\r\n\r\n![1576834824250](./img/linux/java-linux/Linux-v10-02天-授课/1576834824250.png)\r\n\r\n安装成功。\r\n\r\n**2) 备份/etc/yum.repos.d/CentOS-Base.repo文件**\r\n\r\n```shell\r\ncd /etc/yum.repos.d/\r\nmv CentOS-Base.repo CentOS-Base.repo.back\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576834936907](./img/linux/java-linux/Linux-v10-02天-授课/1576834936907.png)\r\n\r\n**3) 下载阿里云的Centos-7.repo文件**\r\n\r\n```shell\r\nwget -O CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo\r\n```\r\n\r\n> 注意\r\n>\r\n> 上面的url中要卸载Centos-7.repo；而不是Centos-6.repo\r\n\r\n 执行效果如下图\r\n\r\n![1576837935001](./img/linux/java-linux/Linux-v10-02天-授课/1576837935001.png)\r\n\r\n查看下载的阿里云的Centos-6.repo文件\r\n\r\n```shell\r\ncat CentOS-Base.repo\r\n```\r\n\r\n执行效果如下\r\n\r\n```SHELL\r\n# CentOS-Base.repo\r\n#\r\n# The mirror system uses the connecting IP address of the client and the\r\n# update status of each mirror to pick mirrors that are updated to and\r\n# geographically close to the client.  You should use this for CentOS updates\r\n# unless you are manually picking other mirrors.\r\n#\r\n# If the mirrorlist= does not work for you, as a fall back you can try the \r\n# remarked out baseurl= line instead.\r\n#\r\n#\r\n \r\n[base]\r\nname=CentOS-$releasever - Base - mirrors.aliyun.com\r\nfailovermethod=priority\r\nbaseurl=http://mirrors.aliyun.com/centos/$releasever/os/$basearch/\r\n        http://mirrors.aliyuncs.com/centos/$releasever/os/$basearch/\r\n        http://mirrors.cloud.aliyuncs.com/centos/$releasever/os/$basearch/\r\ngpgcheck=1\r\ngpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\r\n \r\n#released updates \r\n[updates]\r\nname=CentOS-$releasever - Updates - mirrors.aliyun.com\r\nfailovermethod=priority\r\nbaseurl=http://mirrors.aliyun.com/centos/$releasever/updates/$basearch/\r\n        http://mirrors.aliyuncs.com/centos/$releasever/updates/$basearch/\r\n        http://mirrors.cloud.aliyuncs.com/centos/$releasever/updates/$basearch/\r\ngpgcheck=1\r\ngpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\r\n \r\n#additional packages that may be useful\r\n[extras]\r\nname=CentOS-$releasever - Extras - mirrors.aliyun.com\r\nfailovermethod=priority\r\nbaseurl=http://mirrors.aliyun.com/centos/$releasever/extras/$basearch/\r\n        http://mirrors.aliyuncs.com/centos/$releasever/extras/$basearch/\r\n        http://mirrors.cloud.aliyuncs.com/centos/$releasever/extras/$basearch/\r\ngpgcheck=1\r\ngpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\r\n \r\n#additional packages that extend functionality of existing packages\r\n[centosplus]\r\nname=CentOS-$releasever - Plus - mirrors.aliyun.com\r\nfailovermethod=priority\r\nbaseurl=http://mirrors.aliyun.com/centos/$releasever/centosplus/$basearch/\r\n        http://mirrors.aliyuncs.com/centos/$releasever/centosplus/$basearch/\r\n        http://mirrors.cloud.aliyuncs.com/centos/$releasever/centosplus/$basearch/\r\ngpgcheck=1\r\nenabled=0\r\ngpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\r\n \r\n#contrib - packages by Centos Users\r\n[contrib]\r\nname=CentOS-$releasever - Contrib - mirrors.aliyun.com\r\nfailovermethod=priority\r\nbaseurl=http://mirrors.aliyun.com/centos/$releasever/contrib/$basearch/\r\n        http://mirrors.aliyuncs.com/centos/$releasever/contrib/$basearch/\r\n        http://mirrors.cloud.aliyuncs.com/centos/$releasever/contrib/$basearch/\r\ngpgcheck=1\r\nenabled=0\r\ngpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\r\n```\r\n\r\n如上面的命令，之前是【CentOS】，现在是【aliyun】\r\n\r\n**4) 重新加载yum**\r\n\r\n```shell\r\nyum clean all\r\n```\r\n\r\n清理之前（CentOS）的缓存\r\n\r\n执行效果如下\r\n\r\n![1576838137800](./img/linux/java-linux/Linux-v10-02天-授课/1576838137800.png)\r\n\r\n```shell\r\nyum makecache\r\n```\r\n\r\n就是把服务器的包信息下载到本地电脑缓存起来，makecache建立一个缓存，以后用install时就在缓存中搜索，提高了速度。\r\n\r\n执行效果如下\r\n\r\n![1576838150825](./img/linux/java-linux/Linux-v10-02天-授课/1576838150825.png)\r\n\r\n如上图，元数据缓存已建立,缓存成功。\r\n\r\n**5、验证yum源使用**\r\n\r\n```shell\r\nyum search tomcat\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576836672011](./img/linux/java-linux/Linux-v10-02天-授课/1576836672011.png)\r\n\r\n如上图所示，我们发现，现在查找软件信息使用了上面的yum缓存。\r\n\r\nLoading mirror speeds from cached hostfile(从缓存的主机文件加载镜像速度)\r\n * base: mirrors.aliyun.com\r\n * extras: mirrors.aliyun.com\r\n * updates: mirrors.aliyun.com\r\n\r\n> 总结\r\n>\r\n> yum -y install 软件包\r\n>\r\n> 卸载软件\r\n> yum -y remove 软件包\r\n>\r\n> 查找软件\r\n>\r\n> yum list *\r\n>\r\n> yum源\r\n>\r\n> 版本:\r\n>\r\n> 比如我们使用的是CentOS7，在下载CentOS-Base.repo的时候要注意它的版本。\r\n\r\n## 4.2 rpm使用\r\n\r\n```\r\nRPM包管理类似于windows下的“添加/删除程序”但是功能却比“添加/删除程序”强大很多\r\n```\r\n\r\n**1、rpm介绍**\r\n\r\nrpm(redhat package manager) 原本是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux 易于安装，升级，间接提升了 Linux 的适用度。\r\n\r\n**2、rpm与yum区别**\r\n\r\nrpm 只能安装已经下载到本地机器上的rpm 包. yum能在线下载并安装rpm包,能更新系统,且还能自动处理包与包之间的依赖问题,这个是rpm 工具所不具备的。\r\n\r\n语法如下：\r\n\r\n```shell\r\n用法: rpm [选项...]\r\n```\r\n\r\n**rpm包**\r\n\r\n![1577255859260](./img/linux/java-linux/Linux-v10-02天-授课/1577255859260.png)\r\n\r\n> 注意：\r\n>\r\n> 以上为扩展名为.rpm的包\r\n>\r\n> 可以理解成是Windows中的.exe文件\r\n\r\n**安装rpm软件包**\r\n\r\n```shell\r\nrpm -ivh 软件全包名\r\n```\r\n\r\n**卸载rpm软件包**\r\n\r\n```shell\r\nrpm -e 软件全包名      \r\n```\r\n\r\n**列出所有安装过的包**\r\n\r\n```shell\r\nrpm -qa\r\n```\r\n\r\n**查询软件包信息**\r\n\r\n```shell\r\nrpm -qi 软件全包名\r\n```\r\n\r\n**查看文件安装位置** \r\n\r\n```shell\r\nrpm -ql 软件全包名\r\n```\r\n\r\n## 4.3 shell使用\r\n\r\n```\r\nshell脚本类似于我们在Windows中编写的批处理文件，它的扩展名是.bat，比如我们启动Tomcat（后面的课程我们会详细讲解）的时候经常启动的startup.bat，就是Windows下的批处理文件。\r\n而在Linux中，shell脚本编写的文件是以.sh结尾的。比如Tomcat下我们经常使用startup.sh来启动我们的Tomcat，这个startup.sh文件就是shell编写的。\r\n```\r\n\r\n### 4.3.1 shell入门\r\n\r\n```\r\n通过简单的学习，我们编写一个简单的入门shell程序。\r\n我们通过前面学习的echo命令，在shell脚本中打印出一句话。\r\n```\r\n\r\n**1) 什么是shell**\r\n\r\nShell 脚本（shell script），是一种为 shell 编写的脚本程序。\r\n\r\n[Shell](https://www.leiue.com/tags/shell) [脚本](https://www.leiue.com/tags/脚本)（[Shell Script](https://www.leiue.com/tags/shell-script)）又称 Shell 命令稿、程序化脚本，是一种计算机程序使用的文本文件，内容由一连串的 shell 命令组成，经由 Unix Shell 直译其内容后运作\r\n\r\n![1576838959401](./img/linux/java-linux/Linux-v10-02天-授课/1576838959401.png)\r\n\r\n\r\n\r\nShell 被当成是一种脚本语言来设计，其运作方式与解释型语言相当，由 Unix shell 扮演命令行解释器的角色，在读取 shell 脚本之后，依序运行其中的 shell 命令，之后输出结果。利用 shell 脚本可以进行系统管理，文件操作等。\r\n\r\n在 Unix 及所有的系统中，如 Linux、FreeBSD 等操作系统，都存在 shell 脚本。依照 Unix shell 的各种不同类型，shell 脚本也有各种不同方言。在 DOS、OS/2、Microsoft Windows 中的批处理文件，跟 shell 脚本有类似的功能。\r\n\r\n**2) shell环境**\r\n\r\n```\r\njava需要虚拟机解释器, 同理 shell脚本也需要解释器\r\n```\r\n\r\nShell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。\r\n\r\n**查看解释器**\r\n\r\n```shell\r\ncat /etc/shells\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577068054836](./img/linux/java-linux/Linux-v10-02天-授课/1577068054836.png)\r\n\r\nLinux 的 Shell 种类众多，常见的有：\r\n\r\n- Bourne Shell（/usr/bin/sh或/bin/sh）\r\n- Bourne Again Shell（/bin/bash）\r\n- C Shell（/usr/bin/csh）\r\n- K Shell（/usr/bin/ksh）\r\n- Shell for Root（/sbin/sh）\r\n\r\n- 等等……\r\n\r\n我们当前课程使用的是 Bash，也就是 Bourne Again Shell，由于易用和免费，Bash 在日常工作中被广泛使用。同时，Bash 也是大多数Linux 系统默认的 Shell\r\n\r\n**3) 编写第一个shell**\r\n\r\n现在，我们打开文本编辑器(我们也可以使用 vi/vim 命令来创建文件)，新建一个文件 czbk.sh，扩展名为 sh（sh代表shell）：\r\n\r\n```shell\r\n#!/bin/bash  --- 指定脚本解释器\r\necho "你好，传智播客 !"\r\n```\r\n\r\n//写shell的习惯 第一行指定解释器\r\n\r\n//文件是sh为后缀名\r\n\r\n//括号成对书写\r\n\r\n//注释的时候尽量不用中文注释。不友好。\r\n\r\n//[] 括号两端要要有空格。  [ neirong ]\r\n\r\n//习惯代码索引，增加阅读性\r\n\r\n//写语句的时候，尽量写全了，比如if。。。\r\n\r\n1、创建sh文件**\r\n\r\n```shell\r\nvim czbk.sh\r\n```\r\n\r\n**2、编写并保存**\r\n\r\n![1576839380199](./img/linux/java-linux/Linux-v10-02天-授课/1576839380199.png)\r\n\r\n**3、查看czbk.sh文件**\r\n\r\n```shell\r\nls -l\r\n```\r\n\r\n![1576839550390](./img/linux/java-linux/Linux-v10-02天-授课/1576839550390.png)\r\n\r\n如上图，我们发现刚刚编写的czbk.sh文件的的权限是【-rw-rw-r--】，通过我们之前学过的知识，我们发现这个文件并没有执行的权限\r\n\r\n我们需要将czbk.sh文件设置下它的执行权限【x】，如果不设置有执行权限，当前的文件不具备文件执行的能力。\r\n\r\n**通过chmod设置执行权限**\r\n\r\n```shell\r\nchmod +x ./czbk.sh\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576839765609](./img/linux/java-linux/Linux-v10-02天-授课/1576839765609.png)\r\n\r\n我们发现，czbk.sh拥有了【x】执行权限\r\n\r\n下面，我们就开始执行czbk.sh\r\n\r\n**4、执行czbk.sh文件** --- bash a.sh0\r\n\r\n```shell\r\n ./czbk.sh \r\n```\r\n\r\n执行效果如下：\r\n\r\n![1576839880567](./img/linux/java-linux/Linux-v10-02天-授课/1576839880567.png)\r\n\r\n如上图，我们刚刚编写的shell在执行的时候正常打印出来了，说明czbk.sh具备执行的能力\r\n\r\n> 注意：\r\n>\r\n> **#!** 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。\r\n>\r\n> echo 命令用于向窗口输出文本。\r\n\r\n### 4.3.2 shell注释\r\n\r\n```\r\n引子：\r\n在Java SE课程中，我们也学习了注释\r\n比如单行注释我们使用双斜杠//\r\n   多行注释我们使用/**开头表示注释多行\r\n而在shell编程中，我们同样也要有注释，注释掉程序中不用的脚本\r\n```\r\n\r\n**1、单行注释**\r\n\r\n以 **#** 开头的行就是注释，会被解释器忽略。\r\n\r\n通过每一行加一个 **#** 号设置多行注释，如下：\r\n\r\n```shell\r\n#--------------------------------------------\r\n# 这是一个注释\r\n#--------------------------------------------\r\n##### 开始 #####\r\n#\r\n#\r\n# 这里可以添加脚本描述信息\r\n# \r\n#\r\n##### 结束  #####\r\n```\r\n\r\n如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？\r\n\r\n每一行加个#符号太费力了，此时，我们可以通过EOF进行多行注释，如下：\r\n\r\n**2、多行注释**\r\n\r\n多行注释还可以使用以下格式：\r\n\r\n```shell\r\n:<<EOF\r\n注释内容...\r\n注释内容...\r\n注释内容...\r\nEOF\r\n```\r\n\r\nEOF 也可以使用其他符号:\r\n\r\n```shell\r\n:<<\'\r\n注释内容...\r\n注释内容...\r\n注释内容...\r\n\'\r\n\r\n:<<!\r\n注释内容...\r\n注释内容...\r\n注释内容...\r\n!\r\n```\r\n\r\n> 总结：\r\n>\r\n> 我们将在下面的小章节中使用注释，查看注释效果\r\n\r\n### 4.3.3 shell变量\r\n\r\n```\r\n引子：\r\n这里的变量我们可以理解为我们在Java SE阶段定义的变量，比如在SE中我定义一个字符串类型的变量使用String stringStr="";\r\n\r\n注意：下面的演示我们还是继续沿用test-shell.sh进行测试\r\n```\r\n\r\n**1、定义变量:**\r\n\r\n```\r\nvariable_name="czbk"\r\n```\r\n\r\n变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：\r\n\r\n- 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。\r\n- 中间不能有空格，可以使用下划线（_）。\r\n- 不能使用标点符号。\r\n- 不能使用bash里的关键字（可用help命令查看保留关键字）。\r\n\r\n有效的 Shell 变量名示例如下：\r\n\r\n```shell\r\nRUNOOB\r\nLD_LIBRARY_PATH\r\n_var\r\nvar2\r\n```\r\n\r\n无效的变量命名：\r\n\r\n```shell\r\n?var=123\r\nuser*name=runoob\r\n```\r\n\r\n------\r\n\r\n**2、使用变量**\r\n\r\n使用一个定义过的变量，只要在变量名前面加美元符号即可，如：\r\n\r\n```shell\r\nvariable_name="czbk"\r\necho $variable_name\r\necho ${variable_name}\r\n```\r\n\r\n 执行效果如下\r\n\r\n![1577175492599](./img/linux/java-linux/Linux-v10-02天-授课/1577175492599.png)\r\n\r\n变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：\r\n\r\n```shell\r\n echo "I am good at ${shell-t}Script"\r\n```\r\n\r\n通过上面的脚本我们发现，如果不给shell-t变量加花括号，写成echo "I am good at $shell-tScript"，解释器shell就会把$shell-tScript当成一个变量，由于我们前面没有定义shell-t变量，那么解释器执行执行的结果自然就为空了。这里我们推荐给所有变量加上花括号，这也是一个好的编程习惯。\r\n\r\n已定义的变量，可以被重新定义，如：\r\n\r\n```shell\r\nyour_name="tom"\r\necho $your_name\r\nyour_name="frank"\r\necho $your_name\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1577175655898](./img/linux/java-linux/Linux-v10-02天-授课/1577175655898.png)\r\n\r\n这样写是合法的，但注意，第二次赋值的时候不能写$your_name="frank"，使用变量的时候才加$。\r\n\r\n**3、只读变量**\r\n\r\n```\r\n这里的只读变量其实有点类似于我们在java se阶段课程中定义的final变量，即在程序的上下文中不允许被程序修改\r\n```\r\n\r\n使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。\r\n\r\n下面的例子尝试更改只读变量，结果报错：\r\n\r\n```shell\r\n#!/bin/bash\r\nmyUrl="https://www.baidu.com"\r\nreadonly myUrl\r\nmyUrl="https://cn.bing.com/"\r\n```\r\n\r\n 执行效果如下图\r\n\r\n![1577175714493](./img/linux/java-linux/Linux-v10-02天-授课/1577175714493.png)\r\n\r\n**4、删除变量**\r\n\r\n使用 unset 命令可以删除变量。语法：\r\n\r\n```\r\nunset variable_name\r\n```\r\n\r\n变量被删除后不能再次使用。unset 命令不能删除只读变量。\r\n\r\n**示例如下**\r\n\r\n```shell\r\n#!/bin/sh\r\nmyUrl="https://www.baidu.com"\r\nunset myUrl\r\necho $myUrl\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1577175804257](./img/linux/java-linux/Linux-v10-02天-授课/1577175804257.png)\r\n\r\n如上面的shell脚本，我们定义了一个myUrl变量，通过unset删除这个变量，然后通过echo进行输出，结果是就是为空，没有任何的结果输出。\r\n\r\n------\r\n\r\n**Shell 字符串**\r\n\r\n```\r\n字符串是shell编程中最常用也是最有用的数据类型，字符串可以用单引号，也可以用双引号，也可以不用引号，正如我们开篇提到的，在Java SE中我们定义一个字符串可以通过Stirng  stringStr=“abc" 双引号的形式进行定义，而在shel中也是可以的。\r\n```\r\n\r\n**单引号**\r\n\r\n```shell\r\nstr=\'this is a string variable\'\r\n```\r\n\r\n单引号字符串的限制：\r\n\r\n- 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；\r\n- 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。\r\n\r\n**双引号**\r\n\r\n```shell\r\nyour_name=\'frank\'\r\nstr="Hello,  \\"$your_name\\"! \\n"\r\necho -e $str\r\n```\r\n\r\n输出结果为：\r\n\r\n![1577175850350](./img/linux/java-linux/Linux-v10-02天-授课/1577175850350.png)\r\n\r\n双引号的优点：\r\n\r\n- 双引号里可以有变量\r\n- 双引号里可以出现转义字符\r\n\r\n**拼接字符串**\r\n\r\n```shell\r\nyour_name="frank"\r\n# 使用双引号拼接\r\ngreeting="hello, "$your_name" !"\r\ngreeting_1="hello, ${your_name} !"\r\necho $greeting  $greeting_1\r\n```\r\n\r\n输出结果为：\r\n\r\n![1577175902317](./img/linux/java-linux/Linux-v10-02天-授课/1577175902317.png)\r\n\r\n**获取字符串长度**\r\n\r\n```shell\r\nstring="czbk"\r\necho ${#string}\r\n```\r\n\r\n输出结果：4.表示长度为4\r\n\r\n![1577175975730](./img/linux/java-linux/Linux-v10-02天-授课/1577175975730.png)\r\n\r\n**提取字符串**\r\n\r\n以下实例从字符串第 **2** 个字符开始截取 **4** 个字符：\r\n\r\n```shell\r\nstring="abcdefghijklmn"\r\necho ${string:1:4} \r\n```\r\n\r\n 执行效果如下\r\n\r\n![1577176031872](./img/linux/java-linux/Linux-v10-02天-授课/1577176031872.png)\r\n\r\n输出为【bcde】，通过截取我们发现，它的下标和我们在java中的读取方式是一样的，下标也是从0开始。\r\n\r\n### 4.3.4 shell数组\r\n\r\n```\r\n这里的数组和我们在Java SE阶段的数组结果（或是性质）是一样的，只是定义的过程大同小异\r\n```\r\n\r\nbash支持一维数组（不支持多维数组），并且没有限定数组的大小。\r\n\r\n**定义数组**\r\n\r\n在 Shell 中，用括号来表示数组，数组元素用"空格"符号分割开。如下：\r\n\r\n```shell\r\n数组名=(值1 值2 ... 值n)\r\n```\r\n\r\n例如：\r\n\r\n```shell\r\narray_name=(value0 value1 value2 value3)\r\n```\r\n\r\n或者\r\n\r\n```shell\r\narray_name=(\r\nvalue0\r\nvalue1\r\nvalue2\r\nvalue3\r\n)\r\n```\r\n\r\n通过下标定义数组中的其中一个元素：\r\n\r\n```shell\r\narray_name[0]=value0\r\narray_name[1]=value1\r\narray_name[n]=valuen\r\n```\r\n\r\n可以不使用连续的下标，而且下标的范围没有限制。\r\n\r\n**读取数组**\r\n\r\n读取数组元素值的一般格式是：\r\n\r\n```shell\r\n${数组名[下标]}\r\n```\r\n\r\n例如：\r\n\r\n```shell\r\nvaluen=${array_name[n]}\r\n```\r\n\r\n使用 **@** 符号可以获取数组中的所有元素，例如：\r\n\r\n```shell\r\necho ${array_name[@]}\r\n```\r\n\r\n**获取数组的长度**\r\n\r\n获取数组长度的方法与获取字符串长度的方法相同，例如：\r\n\r\n```shell\r\n# 取得数组元素的个数\r\nlength=${#array_name[@]}\r\n# 或者\r\nlength=${#array_name[*]}\r\n```\r\n\r\n下面，我们通过一个例子，定义数组、提取数组元素的例子来验证下\r\n\r\n```shell\r\n#! /bin/bash\r\ng=(a b c d e f)\r\necho "数组下标为2的数据为:" ${g[2]}\r\necho  "数组所有数据为:"  ${#g[@]}\r\necho  "数组所有数据为:"   ${#g[*]}\r\n```\r\n\r\n如下\r\n\r\n![1577067300329](./img/linux/java-linux/Linux-v10-02天-授课/1577067300329.png)\r\n\r\n 执行效果如下：\r\n\r\n![1577067402285](./img/linux/java-linux/Linux-v10-02天-授课/1577067402285.png)\r\n\r\n### 4.3.5 shell运算符\r\n\r\n```\r\n我们在前面课程中学习Java SE中也学到了运算符，比如算术、关系、布尔等，而在sehll编程中同样也有运算符，虽然表达的方式不一样，但是最终的目的都是一样的，都是为了解决编程中现存问题\r\n```\r\n\r\nShell 和其他编程一样，**支持**包括：算术、关系、布尔、字符串等运算符。\r\n\r\n原生 bash **不支持 **简单的数学运算，但是可以通过其他命令来实现，例如expr。\r\n\r\nexpr 是一款表达式计算工具，使用它能完成表达式的求值操作。\r\n\r\n例如，两个数相加,我们还是利用上面的例子test-shell.sh \r\n\r\n**1、算数运算符**\r\n\r\n```\r\nval=`expr 2 + 2`\r\necho "相加之后的结果为：" $val\r\n```\r\n\r\n 执行效果如下\r\n\r\n![1577068429739](./img/linux/java-linux/Linux-v10-02天-授课/1577068429739.png)\r\n\r\n注意：\r\n\r\n**表达式和运算符之间要有空格**，例如 2+2 是不对的，必须写成 2 + 2。\r\n\r\n完整的表达式要被 **`** 包含，注意不是单引号。\r\n\r\n下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：\r\n\r\n| **运算符** | **说明**                                      | **举例**                      |\r\n| ---------- | --------------------------------------------- | ----------------------------- |\r\n| +          | 加法                                          | `expr $a + $b` 结果为 30。    |\r\n| -          | 减法                                          | `expr $a - $b` 结果为 -10。   |\r\n| *          | 乘法                                          | `expr $a \\* $b` 结果为  200。 |\r\n| /          | 除法                                          | `expr $b / $a` 结果为 2。     |\r\n| %          | 取余                                          | `expr $b % $a` 结果为 0。     |\r\n| =          | 赋值                                          | a=$b 将把变量 b 的值赋给 a。  |\r\n| ==         | 相等。用于比较两个数字，相同则返回 true。     | [ $a == $b ] 返回 false。     |\r\n| !=         | 不相等。用于比较两个数字，不相同则返回 true。 | [ $a != $b ] 返回 true。      |\r\n\r\n**注意：**条件表达式要放在方括号之间，并且要有空格，例如: **[$a==$b]** 是错误的，必须写成 **[ $a == $b ]**。\r\n\r\n下面是运算符shell脚本（还是采用之前的例子test-shell.sh ）w\r\n\r\n```shell\r\n#! /bin/bash\r\n#g=(a b c d e f)\r\n#echo "数组下标为2的数据为:" ${g[2]}\r\n#echo  "数组所有数据为:"  ${#g[@]}\r\n#echo  "数组所有数据为:"   ${#g[*]}\r\n:<<EOF\r\nval= `expr 2 + 2`\r\necho "相加之后的结果为：" $val\r\nEOF\r\n\r\na=4\r\nb=20\r\necho “加法运算”  `expr $a + $b`\r\necho “减法运算”  `expr $a - $b`\r\necho “乘法运算，注意*号前面需要反斜杠” ` expr $a \\* $b`\r\necho “除法运算”  `expr  $b / $a`\r\n((a++))\r\necho "a = $a"\r\nc=$((a + b)) \r\nd=$[a + b]\r\necho "c = $c"\r\necho "d = $d"\r\n```\r\n\r\n**上面的shell命令#开头的为单行注释**\r\n\r\n**:<<EOF 开头和EOF结尾的为多行注释**\r\n\r\n执行效果如下\r\n\r\n![1577152161538](./img/linux/java-linux/Linux-v10-02天-授课/1577152161538.png)\r\n\r\n**2、字符串运算符**\r\n\r\n下表列出了常用的字符串运算符，假定变量 a 为 "abc"，变量 b 为 "efg"：\r\n\r\n| 运算符 | 说明                                      | 举例                     |\r\n| :----- | :---------------------------------------- | :----------------------- |\r\n| =      | 检测两个字符串是否相等，相等返回 true。   | [ $a = $b ] 返回 false。 |\r\n| !=     | 检测两个字符串是否相等，不相等返回 true。 | [ $a != $b ] 返回 true。 |\r\n| -z     | 检测字符串长度是否为0，为0返回 true。     | [ -z $a ] 返回 false。   |\r\n| -n     | 检测字符串长度是否为0，不为0返回 true。   | [ -n "$a" ] 返回 true。  |\r\n| $      | 检测字符串是否为空，不为空返回 true。     | [ $a ] 返回 true。       |\r\n\r\n**字符串运算符实例如下（还是采用之前的例子test-shell.sh ）：**\r\n\r\n```shell\r\na="abc"\r\nb="efg"\r\n\r\nif [ $a = $b ]\r\nthen\r\n   echo "$a = $b : a 等于 b"\r\nelse\r\n   echo "$a = $b: a 不等于 b"\r\nfi\r\nif [ $a != $b ]\r\nthen\r\n   echo "$a != $b : a 不等于 b"\r\nelse\r\n   echo "$a != $b: a 等于 b"\r\nfi\r\n \r\n```\r\n\r\n 执行效果如下\r\n\r\n![1577158474734](./img/linux/java-linux/Linux-v10-02天-授课/1577158474734.png)\r\n\r\n**3、关系运算符**\r\n\r\n关系运算符只支持数字，不支持字符串，除非字符串的值是数字。\r\n\r\n下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：\r\n\r\n| 运算符 | 说明                                                  | 举例                       |\r\n| :----- | :---------------------------------------------------- | :------------------------- |\r\n| -eq    | 检测两个数是否相等，相等返回 true。                   | [ $a -eq $b ] 返回 false。 |\r\n| -ne    | 检测两个数是否不相等，不相等返回 true。               | [ $a -ne $b ] 返回 true。  |\r\n| -gt    | 检测左边的数是否大于右边的，如果是，则返回 true。     | [ $a -gt $b ] 返回 false。 |\r\n| -lt    | 检测左边的数是否小于右边的，如果是，则返回 true。     | [ $a -lt $b ] 返回 true。  |\r\n| -ge    | 检测左边的数是否大于等于右边的，如果是，则返回 true。 | [ $a -ge $b ] 返回 false。 |\r\n| -le    | 检测左边的数是否小于等于右边的，如果是，则返回 true。 | [ $a -le $b ] 返回 true。  |\r\n\r\n**关系运算符（还是采用之前的例子test-shell.sh ）**\r\n\r\n```shell\r\na=10\r\nb=20\r\n\r\nif [ $a -eq $b ]\r\nthen\r\n   echo "$a -eq $b : a 等于 b"\r\nelse\r\n   echo "$a -eq $b: a 不等于 b"\r\nfi\r\nif [ $a -ne $b ]\r\nthen\r\n   echo "$a -ne $b: a 不等于 b"\r\nelse\r\n   echo "$a -ne $b : a 等于 b"\r\nfi\r\nif [ $a -gt $b ]\r\nthen\r\n   echo "$a -gt $b: a 大于 b"\r\nelse\r\n   echo "$a -gt $b: a 不大于 b"\r\nfi\r\nif [ $a -lt $b ]\r\nthen\r\n   echo "$a -lt $b: a 小于 b"\r\nelse\r\n   echo "$a -lt $b: a 不小于 b"\r\nfi\r\nif [ $a -ge $b ]\r\nthen\r\n   echo "$a -ge $b: a 大于或等于 b"\r\nelse\r\n   echo "$a -ge $b: a 小于 b"\r\nfi\r\nif [ $a -le $b ]\r\nthen\r\n   echo "$a -le $b: a 小于或等于 b"\r\nelse\r\n   echo "$a -le $b: a 大于 b"\r\nfi\r\n```\r\n\r\n执行效果如下：\r\n\r\n![1577169772803](./img/linux/java-linux/Linux-v10-02天-授课/1577169772803.png)\r\n\r\n**4、布尔运算符**\r\n\r\n下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：\r\n\r\n| 运算符 | 说明                                                | 举例                                     |\r\n| :----- | :-------------------------------------------------- | :--------------------------------------- |\r\n| !      | 非运算，表达式为 true 则返回 false，否则返回 true。 | [ ! false ] 返回 true。                  |\r\n| -o     | 或运算，有一个表达式为 true 则返回 true。           | [ $a -lt 20 -o $b -gt 100 ] 返回 true。  |\r\n| -a     | 与运算，两个表达式都为 true 才返回 true。           | [ $a -lt 20 -a $b -gt 100 ] 返回 false。 |\r\n\r\n**布尔运算符实例如下（还是采用之前的例子test-shell.sh ）：**\r\n\r\n```shell\r\na=10\r\nb=20\r\n\r\nif [ $a != $b ]\r\nthen\r\n   echo "$a != $b : a 不等于 b"\r\nelse\r\n   echo "$a == $b: a 等于 b"\r\nfi\r\nif [ $a -lt 100 -a $b -gt 15 ]\r\nthen\r\n   echo "$a 小于 100 且 $b 大于 15 : 返回 true"\r\nelse\r\n   echo "$a 小于 100 且 $b 大于 15 : 返回 false"\r\nfi\r\nif [ $a -lt 100 -o $b -gt 100 ]\r\nthen\r\n   echo "$a 小于 100 或 $b 大于 100 : 返回 true"\r\nelse\r\n   echo "$a 小于 100 或 $b 大于 100 : 返回 false"\r\nfi\r\nif [ $a -lt 5 -o $b -gt 100 ]\r\nthen\r\n   echo "$a 小于 5 或 $b 大于 100 : 返回 true"\r\nelse\r\n   echo "$a 小于 5 或 $b 大于 100 : 返回 false"\r\nfi\r\n\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577170810671](./img/linux/java-linux/Linux-v10-02天-授课/1577170810671.png)\r\n\r\n**5、逻辑运算符**\r\n\r\n假定变量 a 为 10，变量 b 为 20:\r\n\r\n| 运算符 | 说明       | 举例                                       |\r\n| :----- | :--------- | :----------------------------------------- |\r\n| &&     | 逻辑的 AND | [[ $a -lt 100 && $b -gt 100 ]] 返回 false  |\r\n| \\|\\|   | 逻辑的 OR  | [[ $a -lt 100 \\|\\| $b -gt 100 ]] 返回 true |\r\n\r\n**逻辑运算符实例如下（还是采用之前的例子test-shell.sh ）：** \r\n\r\n```shell\r\na=10\r\nb=20\r\n\r\nif [[ $a -lt 100 && $b -gt 100 ]]\r\nthen\r\n   echo "返回 true"\r\nelse\r\n   echo "返回 false"\r\nfi\r\n\r\nif [[ $a -lt 100 || $b -gt 100 ]]\r\nthen\r\n   echo "返回 true"\r\nelse\r\n   echo "返回 false"\r\nfi\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577171478166](./img/linux/java-linux/Linux-v10-02天-授课/1577171478166.png)\r\n\r\n\r\n\r\n### 4.3.6 shell流程控制\r\n\r\n```\r\n在前面的Java SE课程中，我们学习了很多的流程控制语句，比如有if-else、if else-if else、switch、for、while等语句；\r\n在shell编程中，我们同样也有这些流程控制，只是语法和java SE有所区别，但是目的是一样的。\r\n```\r\n\r\n**1、if 语句：**\r\n\r\n**主要用于判断，相当于java se中的if，我们还是采用之前的例子test-shell.sh**\r\n\r\n```shell\r\nif condition\r\nthen\r\n    command1 \r\n    command2\r\n    ...\r\n    commandN \r\nfi\r\n```\r\n\r\n 比如，我们现在通过前面学习的知识查找一个进程，如果进程存在就打印true\r\n\r\n```shell\r\nif [ $(ps -ef | grep -c "ssh") -gt 1 ]; then echo "true"; fi\r\n```\r\n\r\n> 注意\r\n>\r\n> 末尾的fi就是if倒过来拼写\r\n\r\n执行效果如下\r\n\r\n![1577174880068](./img/linux/java-linux/Linux-v10-02天-授课/1577174880068.png)\r\n\r\n**2、if else 语句：**\r\n\r\n**主要用于判断，相当于java se中的if else，我们还是采用之前的例子test-shell.sh。**\r\n\r\n```shell\r\nif condition\r\nthen\r\n    command1 \r\n    command2\r\n    ...\r\n    commandN\r\nelse\r\n    command\r\nfi\r\n```\r\n\r\n上接上面的例子，如果找不到sshAAA**（此处可以随便输入一个）**进程，我们就打印false\r\n\r\n```shell\r\nif [ $(ps -ef | grep -c "sshAAA") -gt 1 ]; then echo "true";  else echo "false"; fi\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577175009088](./img/linux/java-linux/Linux-v10-02天-授课/1577175009088.png)\r\n\r\n**3、if else-if else 语句：**\r\n\r\n**主要用于判断，相当于java se中的if else-if else**\r\n\r\n```shell\r\nif condition1\r\nthen\r\n    command1\r\nelif condition2 \r\nthen \r\n    command2\r\nelse\r\n    commandN\r\nfi\r\n```\r\n\r\n以下实例判断两个变量是否相等\r\n\r\n我们继续使用上面的例子（test-shell.sh ）\r\n\r\n```shell\r\na=10\r\nb=20\r\nif [ $a == $b ]\r\nthen\r\n   echo "a 等于 b"\r\nelif [ $a -gt $b ]\r\nthen\r\n   echo "a 大于 b"\r\nelif [ $a -lt $b ]\r\nthen\r\n   echo "a 小于 b"\r\nelse\r\n   echo "没有符合的条件"\r\nfi\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577152946471](./img/linux/java-linux/Linux-v10-02天-授课/1577152946471.png)\r\n\r\n**4、for 循环**\r\n\r\n**主要用于循环，相当于java se中的for循环，我们还是采用之前的例子test-shell.sh**\r\n\r\nfor循环格式为\r\n\r\n```shell\r\nfor var in item1 item2 ... itemN\r\ndo\r\n    command1\r\n    command2\r\n    ...\r\n    commandN\r\ndone\r\n```\r\n\r\n顺序输出当前列表中的字母：\r\n\r\n```shell\r\nfor loop in A B C D E F G \r\ndo\r\n    echo "顺序输出字母为: $loop"\r\ndone\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577153230698](./img/linux/java-linux/Linux-v10-02天-授课/1577153230698.png)\r\n\r\n\r\n\r\n**5、while循环**\r\n\r\n主要用于循环，相当于java se中的while循环\r\n\r\nwhile循环用于不断执行一系列命令，也用于从输入文件中读取数据 \r\n\r\n语法格式为\r\n\r\n```\r\nwhile condition\r\ndo\r\n    command\r\ndone\r\n```\r\n\r\n以下是一个基本的while循环，测试条件是：如果int小于等于10，那么条件返回真。int从0开始，每次循环处理时，int加1。 \r\n\r\n还是采用之前的例子test-shell.sh\r\n\r\n```shell\r\n#!/bin/bash\r\nint=1\r\nwhile(( $int<=10 ))\r\ndo\r\n    echo "输出的值为："$int\r\n    let "int++"\r\ndone\r\n```\r\n\r\n执行效果如下图\r\n\r\n**![1577153468616](./img/linux/java-linux/Linux-v10-02天-授课/1577153468616.png)**\r\n\r\n**6、case ... esac语句**\r\n\r\n**主要用于分支条件选择，相当于java se中的switch case循环**\r\n\r\n**case ... esac** 与其他语言中的 switch ... case 语句类似，是一种多分枝选择结构，每个 case 分支用右圆括号开始，用两个分号 **;;** 表示 break，即执行结束，跳出整个 case ... esac 语句，esac（就是 case 反过来）作为结束标记。\r\n\r\n还是采用之前的例子test-shell.sh\r\n\r\ncase ... esac 语法格式如下：\r\n\r\n```shell\r\ncase 值 in\r\n模式1)\r\n    command1\r\n    command2\r\n    command3\r\n    ;;\r\n模式2）\r\n    command1\r\n    command2\r\n    command3\r\n    ;;\r\n*)\r\n    command1\r\n    command2\r\n    command3\r\n    ;;\r\nesac\r\n```\r\n\r\ncase 后为取值，值可以为变量或常数。\r\n\r\n值后为关键字 in，接下来是匹配的各种模式，每一模式最后必须以右括号结束，模式支持正则表达式。\r\n\r\n下面通过v的值进行case--esac\r\n\r\n```shell\r\nv="czbk"\r\n\r\ncase "$v" in\r\n   "czbk") echo "传智播客"\r\n   ;;\r\n   "baidu") echo "baidu 搜索"\r\n   ;;\r\n   "google") echo "google 搜索"\r\n   ;;\r\nesac\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577153795748](./img/linux/java-linux/Linux-v10-02天-授课/1577153795748.png)\r\n\r\n\r\n\r\n### 4.3.7 shell函数\r\n\r\n```\r\n我们将要学习的shell函数，我们可以理解成在Java SE阶段我们学习的方法，它和shell函数的作用是一样的。\r\n```\r\n\r\n函数语法如下：\r\n\r\n```shell\r\n[ function ] funname [()]\r\n\r\n{\r\n\r\n    action;\r\n\r\n    [return int;]\r\n\r\n}\r\n```\r\n\r\n> 注意：\r\n>\r\n> - 1、可以使用function fun() 定义函数，也可以直接fun() 定义,不带任何参数。\r\n> - 2、函数参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255\r\n\r\n下面我们将定义一个函数，并发生函数调用\r\n\r\n还是采用之前的例子test-shell.sh\r\n\r\n```shell\r\n#!/bin/bash\r\n\r\nczbk(){\r\n    echo "这是第一个函数!"\r\n}\r\necho "-----这里是函数开始执行-----"\r\nczbk\r\necho "-----这里是函数执行完毕-----"\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1577159360606](./img/linux/java-linux/Linux-v10-02天-授课/1577159360606.png)\r\n\r\n下面，我们定义一个带有return语句的函数：\r\n\r\n```shell\r\nfunction czbk(){\r\n    echo "对输入的两个数字进行相加运算..."\r\n    echo "输入第一个数字: "\r\n    read aNum\r\n    echo "输入第二个数字: "\r\n    read anotherNum\r\n    echo "两个数字分别为 $aNum 和 $anotherNum !"\r\n    return $(($aNum+$anotherNum))\r\n}\r\nczbk\r\necho "输入的两个数字之和为 $? !"\r\n```\r\n\r\n> 注意：\r\n>\r\n> 函数返回值在调用该函数后通过 $? 来获得。\r\n>\r\n> 注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。\r\n\r\n### 4.3.8 总结\r\n\r\n在企业级开发过程中，我们（开发人员）学习Linux主要的目的就是在Linux系统中能够熟练的操作目录、文件，还有就是通过所学的命令系统化的编写sh文件，所以，在当前章节中，我们要熟练的编写shell脚本相关命令以及综合案例中的知识点。',gr={data:function(){return{MainComponent:_r}}},xr=gr,br=Object(d["a"])(xr,mr,hr,!1,null,"6442f8de",null),fr=br.exports,Lr={components:{m1:cr,m2:fr},data:function(){return{tab:"m1",tabs:[{label:"Linux-v10-01天",value:"m1"},{label:"Linux-v10-02天",value:"m2"}]}}},wr=Lr,yr=Object(d["a"])(wr,ar,sr,!1,null,"2965940c",null),kr=yr.exports,Sr={mixins:[z["b"]],components:{m1:p,m2:x,m3:S,m4:D,m5:H,m6:F,m7:J,m8:sn,m9:vn,m10:xn,m13:Sn,m14:Pn,m15:In,m16:ir,m18:kr,m19:Gn},data:function(){return{tab:"m1",tabs:[{label:"笔记",value:"m6"},{label:"linux-目录",value:"m13"},{label:"linux命令",value:"m1"},{label:"调度+进程",value:"m7"},{label:"YUM+LAMP",value:"m19"},{label:"黑马云计算",value:"m16"},{label:"linux-备忘",value:"m2"},{label:"shell-基础",value:"m3"},{label:"运维书籍",value:"m4"},{label:"Linux—前端",value:"m5"},{label:"Linux—java",value:"m18"},{label:"前端运维",value:"m8"},{label:"日常运维",value:"m9"},{label:"Nginx",value:"m14"},{label:"Nginx 配置",value:"m15"}]}}},$r=Sr,jr=Object(d["a"])($r,e,i,!1,null,"7b1fa3b7",null);r["default"]=jr.exports},f0ba:function(n,r,t){}}]);