(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[6],{"1b62":function(n,e,t){"use strict";t.d(e,"d",(function(){return o})),t.d(e,"c",(function(){return u})),t.d(e,"a",(function(){return y})),t.d(e,"b",(function(){return f})),t("4de4"),t("c975");var r=t("448a"),a=t.n(r),i=["/第1阶段-运维基本功（升级7.6版本）/01运维概述与Linux系统安装.pdf","/第1阶段-运维基本功（升级7.6版本）/02Linux基础命令.pdf"],s="linux/heima-Linux云计算",o={name:"Container",data:function(){return{prefix:s,book_options:i,book_options_all:[],show:!0,book:i[0],src:""}},created:function(){this.book_options_all=a()(this.book_options),this.src=this.$utils.compute_book_src(this.prefix+this.book)},watch:{book:function(n,e){n&&this.change_book()}},methods:{change_book:function(){console.log("this.book",this.book),this.src=this.$utils.compute_book_src(this.prefix+this.book)},filterFn:function(n,e){var t=this;e(""!==n?function(){var e=n.toLowerCase();t.book_options=t.book_options_all.filter((function(n){return n.toLowerCase().indexOf(e)>-1}))}:function(){t.book_options=t.book_options_all})}}},l=t("ded3"),c=t.n(l),p=t("2f62"),u={data:function(){return{tab:"",tab_level:1,is_active:!1}},computed:c()({},Object(p["c"])(["get_current_selected_right_menu"])),created:function(){this.is_active=!0,this.fix_right_menu_config()},watch:{tab:function(){this.tab||this.fix_right_menu_config()},get_current_selected_right_menu:function(n,e){this.tab=this.get_current_selected_right_menu["t"+this.tab_level]}},methods:c()(c()({},Object(p["b"])(["set_right_menu_fix_config"])),{},{fix_right_menu_config:function(){this.set_right_menu_fix_config({tl:this.tab_level,tabs:this.tabs||[],tv:this.tab||this.tabs[0]["value"]})}}),beforeDestroy:function(){this.is_active=!1}},m=(t("99af"),t("d81d"),t("fb6a"),t("a434"),t("07ac"),function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"q-my-md q-mx-sm"},[t("div",{staticClass:"q-mb-md row q-gutter-x-md q-gutter-y-sm"},[t("q-select",{staticStyle:{width:"300px"},attrs:{dense:"",filled:"","use-input":"","hide-selected":"","fill-input":"","input-debounce":"0",options:n.topic_options_filtered},on:{filter:n.filterFn,"filter-abort":n.abortFilterFn,input:n.handle_topic_change},scopedSlots:n._u([{key:"before",fn:function(){return[n._v("\n        主题\n      ")]},proxy:!0}]),model:{value:n.topic,callback:function(e){n.topic=e},expression:"topic"}}),t("q-select",{staticStyle:{width:"300px"},attrs:{dense:"",filled:"",options:n.column_options},on:{input:n.handle_column_change},scopedSlots:n._u([{key:"before",fn:function(){return[n._v("\n        列数\n      ")]},proxy:!0}]),model:{value:n.column,callback:function(e){n.column=e},expression:"column"}})],1),t("q-markup-table",{attrs:{dense:""}},[t("thead",[t("tr",[t("th",{staticClass:"text-left text-weight-bolder  ",attrs:{colspan:n.column}},[n._v("\n          "+n._s(n.table_title?n.table_title+"------":"")+"当前词条数量："+n._s(n.word_total)+"\n        ")])])]),t("tbody",[n._l(n.table_data,(function(e,r){return[n.compute_if_show(e)?t("tr",{key:r,class:n.compute_topic_options_style(e)},n._l(n.column,(function(r){return t("td",{key:r,staticClass:"text-left"},[n._v("\n            "+n._s(e[r-1])+"\n          ")])})),0):n._e()]}))],2)])],1)}),d=[],g=(t("caad"),t("a9e3"),t("2532"),{data:function(){return{topic:"全部",column:2,topic_options_filtered:[],topic_options_all:[]}},props:{table_title:{type:String,default:""},word_total:{type:Number,default:0},topic_options:{type:Array,default:function(){return[]}},column_options:{type:Array,default:function(){return[]}},table_data:{type:Array,default:function(){return[]}},show_empty_line:!1},watch:{topic_options:function(n,e){this.init_topic_options_related()},column_options:function(n,e){this.init_column()}},created:function(){this.init_topic_options_related(),this.init_column(),this.handle_column_change(),this.handle_topic_change()},methods:{init_topic_options_related:function(){this.topic_options_all=a()(this.topic_options),this.topic_options_filtered=a()(this.topic_options)},filterFn:function(n,e,t){var r=this;console.log("this.topic_options_all",this.topic_options_all),setTimeout((function(){e((function(){if(""===n)r.topic_options_filtered=a()(r.topic_options_all);else{var e=n.toLowerCase();r.topic_options_filtered=r.topic_options_all.filter((function(n){return n.toLowerCase().indexOf(e)>-1}))}r.$forceUpdate()}),(function(e){""!==n&&e.options.length>0&&(e.setOptionIndex(-1),e.moveOptionSelection(1,!0))}))}),300)},abortFilterFn:function(){},handle_column_change:function(){this.$emit("handle_column_change",this.column)},handle_topic_change:function(){this.$emit("handle_topic_change",this.topic)},init_column:function(){var n=this.$q.platform.is.desktop,e=window.innerWidth;e=n?e-200:e-100,e=e<370?370:e,console.log("ww",e);var t=Math.ceil(e/350);t=t<1?1:t,e<400&&(t=1),t=t>8?8:t,this.column=t},compute_topic_options_style:function(n){var e="",t=1==n.length&&this.topic_options.includes(n[0]);return e=t?"bg-teal-4":"",e},compute_if_show:function(n){if(this.show_empty_line)return!0;var e=n.filter((function(n){return n}));return e.length>0}}}),S=g,v=t("2877"),b=Object(v["a"])(S,m,d,!1,null,"4e74a874",null),h=b.exports,y={components:{excelTable:h},data:function(){return{workSheetsFromFile:[[{data:[]}]],table_title:"",column:8,word_total:0,table_data:[],table_data_all:[],column_options:[1,2,3,4,5,6,7,8],exclude_topic_options:!0,show_empty_line:!1,topic:"",topic_options:[]}},created:function(){this.init_workSheetsFromFile()},methods:{init_workSheetsFromFile:function(){},handle_column_change:function(n){this.column=n,this.init_data()},handle_topic_change:function(n){this.topic=n,console.log("this.topic----",this.topic),this.compute_table_data_show_and_word_total()},rebuild_arr_reduce_empty_line:function(n){var e=[[""]];return n.map((function(n){var t=n.filter((function(n){return n})),r=t.length;if(r)e.push(n);else{var a=e[e.length-1].filter((function(n){return n})).length,i=e[e.length-1].length;i>0&&a>0&&e.push([""])}})),e},init_data:function(){var n=this;console.log("workSheetsFromFile --------",this.workSheetsFromFile);var e=[],t={},r=[];this.workSheetsFromFile.map((function(n){e=e.concat(n["data"])}));var i=this.$lodash.cloneDeep(e[0].filter((function(n){return n})));i.map((function(n,e){t["key_"+e]={title:n,words_raw:[]}})),this.exclude_topic_options&&e.splice(0,1),e.map((function(n,e){n.map((function(n,e){t["key_"+e]["words_raw"].push(n)}))})),console.log("final_obj------------",t);var s=Object.values(t);s.map((function(e,t){r.push([e["title"]]),r=r.concat(n.$lodash.chunk(e["words_raw"],n.column)),r=r.concat([[""]])})),this.topic_options=["全部"].concat(a()(i)),this.table_data_all=this.rebuild_arr_reduce_empty_line(r),this.compute_table_data_show_and_word_total(),console.log("  this.table_data_all   ",this.table_data_all)},compute_table_data_show_and_word_total:function(){var n=[],e=[],t=0;if(e=this.$lodash.cloneDeep(this.table_data_all),console.log(" table_data--------",e),"全部"==this.topic)n=e;else{var r=this.topic_options.indexOf(this.topic),a=r==this.topic_options.length-1,i=a?"":this.topic_options[r+1],s=this.find_topic_index(this.topic),o=i?this.find_topic_index(i):e.length;n=e.slice(s,o)}n.map((function(n){var e=n.filter((function(n){return n})).length;t+=e})),this.word_total=t,this.table_data=n},find_topic_index:function(n){for(var e=0,t=0;t<this.table_data_all.length;t++){var r=this.table_data_all[t];if(1==r.length&&r[0]&&r[0]==n){e=t;break}}return e}}},f=(t("ac1f"),t("1276"),{data:function(){return{tab:"",MainComponent:"",img_prefix:"./img/linux/heima-Linux云计算/讲义/"}},methods:{extendMarkdown:function(n){var e=this;console.log(n.renderer.rules);var t=n.renderer.rules.html_block;n.renderer.rules.html_block=function(n,r,a,i,s){var o=n[r];if(console.log("1"),o.content.includes("<img")){console.log("token-- ",o);var l="";l=o.content;var c=l.split('src="'),p=c[0]+' src="'+e.img_prefix+c[1];o.content=p}return o.attrSet("class","q-markdown--token  "),t(n,r,a,i,s)},n.renderer.rules.image=function(n,t,r,a,i){var s=n[t];console.log("3"),s.attrSet("class","q-markdown--image"),console.log("token--- "+t+"-----",s);var o=s.attrGet("src");return console.log(o),s.attrSet("src",e.img_prefix+o),i.renderToken(n,t,r)}}}})},"20e7":function(n,e,t){var r={"./JAVA核心知识点最详细版.md":"fd4e"};function a(n){var e=i(n);return t(e)}function i(n){if(!t.o(r,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return r[n]}a.keys=function(){return Object.keys(r)},a.resolve=i,n.exports=a,a.id="20e7"},"2cff":function(n,e,t){"use strict";t.r(e);var r=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[t(""+n.tab,{tag:"component"})],1)},a=[],i=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[n.MainComponent?t("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}}):t(""+n.tab,{tag:"component"})],1)},s=[],o=(t("99af"),t("448a")),l=t.n(o),c=function(){var n=this;return n.$createElement,n._self._c,n._m(0)},p=[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[t("div",{staticClass:"text-h5"},[n._v("JAVA 基础")]),t("div",{staticClass:"text-h6"},[n._v(" 基本环境 ")]),t("pre",[n._v("    java SE ME  EE \n    跨平台  -- jvm 虚拟机  jvm 虚拟机本身 不能跨平台 java 程序在 不同平台的不同的 jvm 虚拟机  运行\n    JRE JDK JVM 作用 \n    开发java : 编写代码 编译代码  运行代码 \n    JRE : JAVA  Runtime Enviroment   包含 JVM 虚拟机 和 JAVA 核心 类库  \n    类= java 文件 ，每个 java 文件是一个 Java 类 \n    核心类库：  java 已写好的 非常核心的 代码仓库  ，很多个java  核心 类 文件 \n    代码中 会用到 java 存放在 JRE 中 写好的 核心 java 文件 比如： System   String Number \n    java 文件的 编译 是使用 java JDK 中的  编译工具 进行编译 ，编译为 jvm 能够识别运行的 程序文件 \n    JDK : JAVA development Kit  Java 语言的 软件开发工具包 ，内部包含了 代码的 编译工具和 运行工具 \n    流程：1.使用JDK中的编译工具编译 .java  文件到      .class 字节码文件，\n          2.使用JDK中的运行工具 将  .class 文件运行在  JVM 虚拟机当中  \n    总结：1. 编写代码 需要使用 JRE 中 java 已经写好的 代码 （核心类库）\n          2. 编译代码 需要使用 JDK 中 的 编译工具\n          3. 运行代码 需要使用 JDK 中 的  运行工具\n          4. 代码运行在  JVM 虚拟机当中  \n     JDK=( JRE=(JVM 虚拟机 + 核心类库)  + 开发工具=（编译工具 + 运行工具） )    \n     系统环境变量 添加变量 Java_Home  D:\\Program Files\\Java\\jdk1.8.0_91\n                   path 编辑 新建    %Java_Home%\\bin    %Java_Home%\\jre\\bin           \n    javac  AAA.java  执行生成 AAA.class 文件 \n    java  AAA    执行 AAA.class 文件 \n    main 方法 程序的 入口点\n    public static void main(String[] args ){\n    }\n    public 确保 文件名称和 类名 必须 同名         \n    java 关键字  基本  都是小写的\n   ")]),t("div",{staticClass:"text-h6"},[n._v(" 数据类型 ")]),t("pre",[n._v("       java 有字符串 和 字符 区别  字符串 双引号 任意个字符    字符 单引号 且只能1个字符 \n      不同数据类型  占用内存空间\n      byte 1 short 2 int 4 long 8     float 4 double 8  char 2 boolean 1 \n      引用数据类型： class interface  array\n      基本数据类型  整数 浮点数 字符  布尔 \n      int a = 1;\n      float b = 1.36F; float 类型 不加 F 标识， 则默认 double 类型转换 会报错 丢失精度\n      long c = 556188L; long 类型  后面加 L 标识\n    数据范围关系 从小到大\n    byte, (short=char) , int ,long ,float ,double \n    隐式转换 小的直接变大的\n    运算过程中，小的会先提升为大的，当类型统一之后，再进行运算 。 同类型 运算\n    byte short char 三种数据类型在运算的时候，不管是否有更高的数据类型，都会提升为 int 然后再运算\n    也就是 最低隐士转换为 int 类型 ， 结果 最低是 int 类型\n    强制转换  大的转小的 强转格式 ： int a=10; byte b= (byte)a;   强转可能丢失精度\n    byte d =3+4 ; java 中存在常量优化机制：\n     根据常量计算的结果 判定是否在类型范围内，在就编译通过，不在就报错\n        java 变量作用域： 只在 变量所在的大括号内有用 \n     java 整数相除 结果是整数  10/3 = 3    10/3.0 = 3.333333...\n     \t char b = 'a';\t int c= b +20;  结果  c = 117 ; 字节 a 对应的 ASCII 码表 97 \n          1+99+“年” = \"100年\"\n           &  并且 |  或者 ！ 非 ^ 异或      && || 短路 效果\n           &  |无论如何 左右都会执行 && || 有短路效果 左边值能确定结果 则 右边不执行\n    break continue 只能跳出自己所在的那一层关系。\n    如果想要跳出跳过置顶一层，可以加入标号。\n    IDEA 目录层级关系： project - module - package - class \n    快捷键：\n    ctrl+shirt+a    ctrl+alt+v   ctrl+alt+m 包裹方法\n    psvm ，sout , alt+1，alt+4 ,ctrl+alt+l ,alt+enter   ,ctrl+b 跟进源码\n    数组 int[] arr= new int[30]  初始化定义一个长度是30的数组\n         int arr[] =new int[30]\n    sout 输出 数组 变量 输出的是 数组的 内存地址 \n    java 内存分配： \n    栈内存 ： 方法运行时，进入的内存，局部变量都存放于这块内存中，\n    堆内存 ： new 出来的内容都会进入堆内存，并且会有对应的地址值\n    方法区 ： 字节码文件 .class 加载时进入的内存 \n    本地方法栈 ：调用操作系统相关的资源\n    寄存器： 交给CPU 去使用\n    类的加载过程：\n    1.类的字节码文件加载进方法区 main 方法存放在自己吗文件中\n    2.main方法被jvm 自动调用进入栈内存中执行\n    3. 因为main 方法在 栈内存 ，创建变量 也在 栈内存\n    4.new 方法创建的实例放在堆内存中 ， 有 内存地址，并且有默认初始化值。\n      把地址值给到 变量。（因此打印数组，打印出来的是内存地址）\n    java 数组默认值\n    整数型 0  浮点数 0.0 布尔 false 字符  空字符  引用数据类型 null  \n    int[] arr=new int[]{5,7,8,999};    \n    int[] arr={5,7,8,999};     arr[0]   \n    方法定义：\n    格式：\n     public static void aaa(int num){  //方法体 }\n     public static int aaa(int num){   return 100; //方法体 }  int bb = aaa(30);\n     public static int[] aaa(int[] arr){   int[] b={1,2,3}    return b //方法体 }  int[] cc = aaa(arr) \n    方法和方法之间 是平级 关系 ，不能嵌套定义\n    栈内存： 手枪弹夹  先进后出\n    方法参数类型 和个数 必须匹配 \n    方法的形参，相当于一个局部变量\n    方法重载： java 允许 多个个相同方法名，但是形参不同的方法存在。（个数，类型，顺序）\n               Java jvm 会通过 参数去匹配调用哪个方法  \n    方法参数传递：\n            基本数据类型 ，传递的是值本身，改变传入值，是改变的这个值 ，对其他无影响。不影响原始值\n            引用数据类型 ，传递的是 内存地址 。 改变的是堆内存内的数据。会改变传入的数据本身\n     原码 反码 补码\n     计算机中的数据都是以二进制补码的形式在运算，而补码则是通过反码和原码推算出来的。 \n     原码： 看数据 ，反码：转数据 ，补码：运算数据\n     原码 ：\n     二进制的定点表示法。最高位是符号位。 0 代表正 1代表负值 其余位数表示值的大小\n     一个字节等于8个比特位 ，也就是 8个二进制位\n     byte b1 = 7  ;   0(符号位)0000111    byte b2 = -7 ; 1(符号位) 0000111\n     反码：\n     正数的反码与其原码相同 ； 负数的反码与其原码逐位取反（0变1 ， 1 变 0），符号位除外\n     补码：\n     正数的补码与其原码相同 ； 负数的补码是在其 反码  的末位 加 1 得到的 \n     二维数组\n     int[][] arr 或者   int arr[][]   或者    int[] arr[]  \n      int[][] arr = mew int[30][10];  30个一维数组 ，每个一维数组有10个元素\n    ")]),t("div",{staticClass:"text-red"},[n._v("\n        方法执行完成 弹栈消失\n    ")]),t("pre",[n._v("       类文件在方法区 ，对象实例在堆内存 ， \n       对象实例的方法地址指向方法区的类文件内的方法\n      变量在栈内存，地址指向堆内存中的类的实例对象\n       方法的调用， 类的实例对象的方法的调用 会进栈 \n      类的主方法 main 方法 会被 jvm 主动调用 ，然后 main 方法 进栈\n       代码由上往下执行， 方法顺序进栈  ， 栈内 方法 先进后出。\n       最后调用的方法完成执行后 最先消失 \n       当方法 执行完成 弹栈 消失\n       ")]),t("div",{staticClass:"text-h6"},[n._v("基础")]),t("pre",[n._v(" \n       单个实例对象的 实例在 堆内存中 ，实例的  成员属性在堆内存，\n      成员方法 在方法区 ，但是堆内存中存有 成员方法的内存地址\n      成员变量： \n      类中方法外的变量 ，有初始默认值 ，堆内存 ，随对象GC 消失\n      局部变量：\n      类中方法内的变量 ，无初始默认值， 栈内存 ，随着方法的执行完成弹栈消失\n      private 权限修饰符 \n      私有 保证数据安全 ，需要根基需求提供 set 和 get 方法 获取 和设置 私有 成员属性 \n      java 类的 构造方法\n      1.方法名称和类名相同，大小写一致\n      2.没有返回值类型，连 void 也没有\n      3.没有具体的返回值 ，不能 由 return 带回 结果数据\n\n      java 类的 构造方法 可以通过 方法的 重载 通过不同的参数 进行 不同 的 初始化\n   ")]),t("div",[n._v("String")]),t("pre",[n._v('     "" 创建的字符串  存在 字符串常量池   （在  堆内存 存储 ） 存在则不再创建  ,不可改变\n     s1 = "123"  s2 = "123"  s1==s2 结果是true \n     new 创建的 每次都是不同的 内存地址 放在 堆内存中 new 创建的  不可能相等\n     字符串的加号拼接 ：系统底层会自动创建一个 stringBuilder 对象 ，\n     再调用其append 方法完成拼接 。拼接后，再调用toString 方法 转换为 String 类型\n     因此  s1="abc"  s2="ab"  s3=s2+"c"   s1==s3   s3 是变量计算拼接 不是常量拼接  返回  false  \n     "abc" == "a" + "b" + "c"  返回 true 原因 ：\n      a,b,c 都是常量 java 的 常量优化机制 在编译的时候 就把右侧直接计算了\n      equals 方法 比较 值是否相等\n      String 类型 + 常量字符串 的 字符串拼接每次都会创建 两个对象 ，一个 stringBuilder 一个 string \n   ')]),t("div",[n._v("StringBuilder   一个可变的字符串类   append toString  reverce")]),t("div",[n._v("打印string  stringBuilder 集合 类  都不会出现内存地址。  打印数组  会出现 ")]),t("div",[n._v(" 集合 ArrayList")]),t("pre",[n._v("       Student[] arr = new Student[3]  \n\n    集合和数组 对比\n    集合类 ：  提供一种存储空间可变的存储模型，容量可变\n    数组类 ：   容量是固定的 不可变的 \n    ArrayList  list = new ArrayList();\n    集合内 可以放任意类型数据      \n    泛型\n    ArrayList<String>  list = new ArrayList <>();\n    集合内 只能放 字符串 String 数据   \n    集合常用API :   add remove  set  get size        \n   ")]),t("div",[n._v(" 高级面向对象 ")]),t("pre",[n._v("        业务对象类  本身  \n        DAO  访问存储数据的数组 或者集合  data access object\n        Service  用来 处理业务逻辑 ，服务器内部的 逻辑\n        Controller  用来 处理     用户  和网页 的相关 逻辑  \n        业务逻辑流程：\n        controller 的 addItem 调用 service  的 addItem , service  的 addItem 调用 dao 的 addItem\n       与试图打交道的 类 调用 与数据库打交道的类 ，与数据库打交道的类 调用 数据库类\n\n        private  static  ， static 修饰的  静态成员属性 在内存中 所有这个类的实例中共享\n         一般 存在于方法区中 \n   ")]),t("div",[n._v("继承")]),t("pre",[n._v("       继承： 让类鱼类之间产生 父子类关系 ， 子类可以直接使用 父类的非私有的成员  \n              例如 你可以用你爸爸的车 ，但你不能用他的内裤 \n              父类 ： 基类 超类   子类 ： 派生类 \n              public class ZI extends FU { }\n        继承好处：复用性，维护性，让类之间产生关系是多态的前台\n        继承弊端：继承是侵入性的 ，不灵活 ，子类   必须拥有父类的非私有属性和方法\n                  耦合性强   父类中 非私有的东西 不能随便改 随便删除 \n        JAVA 只支持 单继承 ，不支持 多继承 ，但是 支持多层继承  \n         一个儿子不能 有两个亲爹 ，但是可以 有 爷爷 ， 有十八辈祖宗    \n         this  自己的 当前类的  super  父级的   父类的 \n         this() 访问本类的构造方法  super()访问父类的构造方法\n        子父类同名属性或者方法：    可以通过 this.  读取 自己的 属性方法   ，super. 读取 父级的 属性方法\n        \n        方法 重写  ， 注解  @Override 检查 是否 正确重写 （必须一模一样）\n        "),t("div",{staticClass:"text-red"},[n._v("\n            "),t("div",[n._v("父类的静态方法，个非静态方法 ， 子类必须一摸一样的名字才能重写 ")]),n._v("\n            \n            "),t("div",[n._v("静态方法不能重写，父子类静态方法同名 ，只是子类将父类中的同名方法隐藏起来了。  就近原则")]),n._v("\n        ")]),n._v("\n        子类 重写 父类 方法 ， 权限必须大于等于 父类 权限 \n        java  四个 权限修饰符   private  小于 默认 小于 protected  小于 public \n        private  同一个类中\n        默认     同一个包中 子类 无关类\n        protected 不同包的子类\n        public   不同包的 无关类\n\n        子类的  构造方法 会默认调用 super() ；即便是不写 ，也会默认加上。不然子类没办法拿到继承而来的东西\n\n        其实每一个类  都继承与 Objiect  类 如果没 指定继承则该类的构造方法 默认 继承自 Object 默认调用 super()\n\n        抽象类   abstract\n        抽象方法： 将共性的方法 抽取到父类之中后，发现该方法的实现逻辑无法确定，该方法就要可以定义为抽象方法\n        抽象类： 如果一个类中 存在 抽象方法 ，那么这个类 就必须 声明为 抽象类\n        public  abstract void aa();  \n        public  abstract class  A1{}\n        public  class A99  extends A1{}\n        抽象类 只能被 继承 实现 。 不能创建 实例对象。因为 没有方法体的方法 不能调用。\n        抽象类的 子类 必须 重写 父类的  抽象方法 ， 但是 子类也可以把自己变成 抽象类。\n        抽象类 不一定有抽象方法， 有抽象方法的类 必定是抽象方法 \n\n        抽象类  体现的是 一种  模板设计模式  \n        final 关键字 可以修饰 属性 方法 类名   ，final 修饰的 属性方法 将不能重写 ，类不能  继承 ，一般用于  属性 和方法  禁止重写 \n        局部代码块 在 方法中定义，限定变量的 生命周期，快速释放，提高内存利用率\n         { }  构造代码块 在 类的 构造方法执行之前执行 ，  可以放  构造方法的 公用代码 \n         static {}  静态代码块 随着 类的加载而加载，只执行一次， 一般用于数据初始化 ，只在类文件加载的时候执行。和构造方法调用无关\n                \n   ")]),t("div",[n._v("接口")]),t("pre",[n._v("       抽象类 可以制定 模板 ，制定一定规则 去让子类去实现\n       但是如果某个抽象类的所有方法都是抽象方法的时候，我们就可以将其定义为接口\n       接口也是一种引用数据类型， 比抽象类 更加抽象 \n       接口的存在有两个重要意义： 1. 规则的定义  2. 程序的扩展性\n       public interface AA {}\n       接口本身 和 抽象方法一样不能实例化 \n       public class AA_ZI implements AA{} \n       类不能多继承 ，但是 类 可以实现 多个接口 \n       接口 因为是定义规则  ， 接口中的 属性 变量  默认是 final 修饰的 不能被修改 静态的 \n       全部的修饰符 是  public static final \n       接口没有构造方法 \n       接口中可以 使用 default 定义修饰 默认方法 ，默认方法 只要是用于 接口的迭代升级\n       类 实现多个接口 ，如果多个接口中有重名的 默认方法 ，  子类 必须重写 这个 方法 \n       接口中可以 使用 static 定义修饰 静态 方法  通过 接口名.静态方法名 来调用  \n       接口中 可以有  静态 方法  默认方法 私有方法  抽象方法   \n\n        继承亲爹 实现干爹  \n\n        类和类之间       继承关系   只能 单继承  但是可以 多层继承    你-- 你爹  -你爷爷  - 你十八辈子祖宗\n        类和接口之间     实现关系   可以单实现也可以多实现 ，还可以在继承一个类的时候 同时实现多个接口\n        接口和接口之间   继承关系   可以单继承也可以多继承            \n\n       \n   ")]),t("div",[n._v(" 多态")]),t("pre",[n._v("       通用对象类型  ，例如 全球 70 亿人 实例 都是 人类 \n       多态的前提是  要有 继承 或者实现关系  ，要有方法重写 ，要有父类引用 指向子类对象\n\n       Animal a = new Cat();\n       多态中的 成员访问 特点\n       构造方法：  同继承一样 ，子类会通过  super 访问 父类 构造器\n       成员变量： 编译看左边 父类  ， 执行 看左边父类\n       成员方法：  编译看左边父类，   执行 看 右边子类\n        多态 弊端：  不能调用子类特有 方法 属性\n       多态中的 转型\n       向上转型  父类引用  指向子类对象     把一个 子类类型  转换为 一个 父类类型   小的转大的  不用强制转换\n       向下转型  子类引用  指向父类对象     把一个 父类类型  转换为 一个 子类类型    大的转小的  需要强制类型转换\n       instanceof  \n       \n   ")]),t("div",[n._v(" 内部类")]),t("pre",[n._v('       Outer.Inner i = new Outer().new Inner();\n       匿名内部类\n       函数式编程思想\n       lambda   箭头 函数   是将 匿名 内部类 的  一个  优化 \n       doaaaa( AA a){ a.nn(); }\n        doaaaa(new AA(){\n            public void nn(){\n                sout("Niubi ")\n            }\n        })\n       doaaaa(()->{  sout("Niubi ") })\n       匿名内部类 ，必须 实现一个接口 ，生产 一个实现类的对象 ，重写方法 ，读取重写的方法 ，执行方法  \n       这个方法 根本的阐述    传递的是一个函数 ， 箭头函数方式 我们直接传入 的 是 方法的 实体 ，\n       把原本的关注点 转到方法的具体实现\n       lambda 使用前提：  必须有一个接口  接口中 有且仅有一个 抽象方法 \n       这种 根本上 传入的  还是一个 匿名对象，实例的 匿名实现类的 一个具体的 对象\n   ')]),t("div"),t("pre",[n._v("        collection  map   list  arraylist  linkedlist set hashset treeset   HashMap   TreeMap\n        数组长度固定， 集合 会自动扩缩容 每次 1.5倍数，长度小于10  是 10\n        栈  压栈 弹栈\n        队列  入队列             出队列    前端  后端   \n        数组   查询快 增删慢   因为 增删 需要 把后面的 每个都平移一位 \n        链表    增删快 查询慢  必须 从  头开始查  单向链表\n        链表   结点   头结点（地址）数据地址数据地址。。。。。^ 结束  火车一样，每一个结点 都由 数据 和地址组成  \n                链表有头有尾  尾巴 是 一个空地址   ，前一个结点 记录后一个结点的地址值\n        双向链表      前一个结点的地址+值+下一个结点的地址   \n        linkedlist 链表  增删方法比较特殊 ， 有一些特殊方法 \n\n        泛型  \n        不写 默认 Object,,提供 编译时候 安全检测机制   \n        \n        collection  单列集合   list set \n        set 没有索引 只能用迭代器  iterator 进行迭代    或者 增强 for 进行魂环 \n        hashset  treeset\n        treeset 可以对 内部元素 进行 排序 要想使用 treeset 必须 指定 排序规则   自然排序\n          内部的 元素 必须 实现 comparable 接口  并且重写 compareTo 方法 \n          compareTo  返回 0 则 不存储 ， 大于存右边 ，小于存左边\n          字符串也有 compareTo 方法 \n          comparator  比较器 类 实现 compare 方法  抽象类\n        \n\n        数据结构 树   结点\n          二叉树    结点  父节点+当前节点值+左子节点+右子节点 \n          二叉树的查询都是从根节点进行查询\n          度： 每一个节点的子节点的 数量\n          高度， 二叉树的 根节点 到最 末梢结点的 最长层级 ，也就是 分叉 分了 几次+1\n\n          普通二叉树     二叉查找树，二叉搜索树\n          普通二叉树     左右子节点 大小没关系\n          二叉查找树     左子节点小于右边子节点  ，一样的 不存储  ，\n          二叉查找树     每一次存储一个值 都要从根节点 开始找路径 进行比较，找到自己的位置 ，\n                         可能出现 左右子树高度差的很远\n          平衡二叉树     任意左右节点 的 两个子树都是一棵平衡二叉树 ，左右高度相差不超过1\n                         左右 旋转 ， 变化根节点，根节点 会变化，普通二叉树 不会变根节点\n                         左旋 ，原本根节点的右节点 升为根节点 \n                                新的根节点的 原本的左节点 倒向左侧， 链接旧的的根节点作为右侧，做为右弦\n                         右旋 ：和上面的左旋 处处相反\n                         左左插入--右旋 ， \n                         左右插入--失衡区域左旋，然后整体右旋 ，两次旋转\n                         右右插入--左旋\n                         右左插入--失衡区域右旋，然后整体左旋\n          红黑树         一种自平衡的二叉查找树 ，但不是高度平衡，不是每次都去计算是否平衡，有自己的红黑规则\n                         每一个节点 都是 红色 或者黑色\n                         根节点必须黑色\n                         如果一个节点没有子节点或者父节点，则这个节点相应的值为Nil，被称为叶节点，都是黑色的\n                         如果一个节点是红色的，那么它的子节点必须是黑色的，不能出现两个红色的节点相连\n                         每一个节点，从该节点到它所有的后代叶节点的简单路径上，都包含相同数目的黑色节点\n                         红黑树多了一个颜色属性\n                         添加三个默认黑色 调整两次\n                         添加三个默认红色 调整1次数\n                         红黑树为了提升性能，默认添加数据颜色为红色\n                         红黑树  ---旋转 区域小，只旋转了父节点 祖父节点， 把父节点提升祖父节点下降作为父节点的右子节点 ，或者左子节点\n                         红黑树 添加数据 需要变色 ，只有在父节点红色，叔叔节点黑色，才会旋转\n        \n        hashset  \n          \n              a.hashCode() 计算 哈希值， 同一个对象的 哈希值 一样的\n              0.75 扩展因子， 满容量的 0.75  则扩容 2倍数\n              集合 ，每个位置 一个哈希 ，如果 相同哈希，则存在同一个位置， 同一个位置总数小于8 采用 链表 ，大于等于8 采用 红黑树\n           hashset  必须重写 hashcode 和 equals 方法   \n            \n        MAP\n        Interface Map K,V     \n        键值对 ，entry 对象\n        hashmap  底层 还是 数组 和 红黑树 ，也有 扩展因子  和 hashset 很类似 \n        terrmap  底层 是根据key 排序的 treeset 类似的 原理 \n\n        可变参数  （int ...a）  类似 js 的 数组解构， 底层是一个数组，是一种  简便写法\n        \n        stream  流\n        流 操作 可以 过滤 和js 的  过滤一样  相当于读数据中 每个去过滤 执行\n        流水线 ，每次操作一波，  流水线 ，准备物料 --\x3e 各种一次次操作加工 --\x3e出货  . 获取流--\x3e 中间方法--\x3e 终结方法\n        list1.stream().filter(()->{ }).filter(()->{ }).filter(()->{ }).filter(()->{ }).filter(()->{ }).forEach(()->{})\n        list1.stream().filter(()->{ }).filter(()->{ }).filter(()->{ }).filter(()->{ }).filter(()->{ }).xollect(Collectors.toList())\n        stream.of()\n        limit()  skip() \n        \n        \n        \n        \n                   \n   ")]),t("div",[n._v("IO")]),t("pre",[n._v("        字节流 写 各种文件类型 \n        字符流 写  记事本 txt 文件 \n        释放资 源 close     捕获错误\n        FileOutputStream   FileInputStream \n        字节缓冲流  BufferedOutputStream   BufferedInputStream\n        字符输出流   FileWriter   \n        字符缓冲流  BufferedWriter   BufferedReader\n        转换流\n        对象操作流   ObjectOutputStream   ObjectInputStream  \n                       对象需要实现 可序列化接口 ，需要抛出各种异常  需要看 demo\n                       transient  路过的  序列化跳过字段  例如密码\n        properties  \n                    MAP       双列集合的操作流  \n                    put   setProperty \n                    load  加载.property 文件\n                    store  存储.property 文件      \n                    等号 形式 ，键值对 ，一般作为配置文件  .property 文件\n                    搜索  .property 文件 读取   需要关闭 IO 流 \n                    \n        apche-commons-io\n        \n        \n    ")]),t("div",[n._v(" 多线程")]),t("pre",[n._v("        cpu 在 多个 进程中 高速切换， 表征是 同时运行 ，例如电脑 同时 执行很多个软件\n        并行： 同一时刻，有多个指令 在多个 CPU 上 同时执行    三个人同时做三件事\n        并发： 在同一时刻， 有多个指令 在单个CPU 上交替执行   一个人同时做三件事\n\n        进程 线程\n        进程： 正在 运行的 软件   ，独立 动态 并发\n        线程： 单个进程中的单个顺序控制流 ，一条执行 路径\n               单线程： 一个进程  只有一条执行路径\n               多线程： 一个进程  有多条执行路径 \n        多线程的 实现方案\n         1.继承 Thread 类   2.实现 Runable 接口 ，调用 Thread 类  3. 利用 callable 和 future 接口实现  ，调用 Thread 类 \n         继承 Thread 类   \n         继承 线程类 重写 run 方法  创建一个线程对象 ，开启多个线程  t1.start()\n         run 方法 没有开启线程 ，只是一般的方法 ， start 方法 开启线程\n         实现 Runable 接口\n         定义xx类 实现 Runable 接口  重写 run 方法  创建对象 xxa\n         创建 Thread 类对象 把  xxa对象 作为构造方法的参数 启动线程\n         类 可执行 run 方法      线程 可执行 start 方法   \n         琼东一个线程 去 执行 可执行类的 run 方法 \n         利用 callable 和 future 接口实现 \n         定义一个类 实现 callable 接口  重写 call 方法  创建 aa 对象\n         创建 future 接口 的 实现类 ff对象  把aa对象 作为 ff构造方法的参数  FutureTask\n         创建 Thread 类对象 ，把 ff对象 作为 构造方法的参数  启动线程\n         这种 方式 可以有返回值\n\n        传递给 thread 的 参数 必须 实现了  runable 接口\n        线程的  get 方法 可以 获取 线程执行完的 返回结果 \n        线程 可以自定义  线程名字   setName  getName\n        线程   可以  sleep  休眠  时常  \n\n        线程调度\n        计算机中的 CPU  在任意时刻只能执行一条机器命令。每个线程只有在 获得CPU 的使用权才能执行代码\n        各个线程轮流获得CPU的 使用权 ，分别执行各自的任务 \n        分时调度模型   ，抢占式调度模型 \n        java 使用的是 抢占调度模式  ，每个线程可以 设置 优先级 (10-1)   setPriority\n        \n        后台线程  守护线程    普通线程执行完成后，守护线程不再执行\n        setDaemon   设置为守护线程\n\n        线程 安全问题\n        三个窗口卖100张电影票 ， 相同票买了很多次 ，出现 负数票号\n        执行每一行代码的时候 ，CPU  执行权力 都可能被别的线程 抢走。 \n        多线程安全问题是因为多线程操作共享数据造成的\n        加锁----------------加锁      \n        十个人抢着上一个厕所，抢到的上厕所就立即锁门 ，免得别人进厕所  ，同步执行的代码块，只能单线程，别的只能等 \n        多线程安全问题的解决方案基本思想： 让程序没有安全问题的环境\n        解决方法：\n                把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可\n                java 提供了同步代码块的方式 来解决\n        synchronized(任意锁对象（类的静态成员属性，全部类实例公用的）){多条线程操作的共享数据的代码块} \n                              代码执行会去改变和还原这个锁对象， 锁对象 必须唯一\n        synchronized 会自动上锁\n                    好处： 线程安全\n                    坏处： 线程很多的时候，每个线程都会去判断同步上的锁，很消耗资源，会降低程序的运行效率\n        同步方法和同步代码块：\n                同步代码块可以锁住指定的代码，同步方法是锁住方法中的所有代码\n                同步代码块可以指定锁对象，同步方法不能指定锁对象\n                同步方法 的锁对象 是锁定的  this  对象本身\n        Lock 锁接口       lock  unlock    自定义 锁定 和解锁方法 ， 方便\n        死锁：是指两个或者多个线程相互之间持有对方所需要的 资源，相互等待，无法继续执行。 叉号\n             死锁是多个锁的 嵌套导致\n         生产者，消费者     \n        wait  notify  notifyAll    等待 通知 唤醒  ，使用 锁对象 去 等待和唤醒\n            等待和唤醒机制，需要中间参照    厨师 ，餐桌，顾客\n        阻塞队列    \n        queue    BlockingQueue    一根管子  通道 ， 一头生产者一头消费者 ， 消息队列\n        ArrayBlockingQueue   底层 数组 ，有界限\n        LinkedBlockingQueue  底层 链表 ，无界限   最大为 int 的最大 值\n        阻塞队列 设置最大值  while 循环 无线 添加  无线读取 ， 超限 报警\n        线程池 volatile  threadpool  线程池    executor    submit 提交任务\n        线程 生命周期：创建 new： start---就绪 runnable： 有执行资格，无执行权限---运行：抢到执行权 run----结束 死亡 垃圾回收  \n        线程  其他状态： 阻塞（有锁 lock blocked） ， 等待（wait） ，计时等待(sleep) ，唤起 就绪 notify  \n        线程的每次创建，等待创建和销毁以及等待销毁 都消耗系统资源，因此 线程池 很重要， 就好比碗柜，吃饭拿碗，吃碗放回去\n        线程池 执行原理 和 100人食堂吃饭，使用可循环的碗筷一样 ，只不过 这个放碗的碗柜 可以自己制造碗 \n        Executors 可以创建 线程池  ，  \n        ExecutorService 可以管理线程池 定量或者不限量   poll-1-thread-1  线程池子内的线程的 getName 返回的 样子\n        Thread.currentThread().getName()\n        ThreadPoolExector  \n        核心线程数，最大线程数，空闲线程最大存活时间，时间单位，任务队列，创建线程工厂，任务的拒绝策略\n        任务的拒绝策略：1.丢弃并抛异常 2.丢弃不抛异常 3.抛弃队列中等待最久的任务，添加当前任务 4.调用任务的run方法跳过线程池直接执行\n         修改了共享数据 ，某些线程不知道修改 ，消息不同步  反复无常 ，不稳定\n        共享数据的修改并不能 通知告知 哥哥线程 自己修改了 ， 每个线程也没有每次都去都最新的 ，而是从自己的变量副本读取\n        每个线程有自己的独立的线程栈  ，共享数据 ，多个线程共享、  共享数据在每个线程内是变量副本 ，不是时时刻刻从共享数据读取\n        volatile  ： 强制要求 每次线程执行的时候 去读取 最新的 共享数据 ，在变量前面 加上 volatile 这个关键字  （不稳定的）\n        public static volatile int money = 100000;\n        加了 volatile 之后：  同步代码块 synchronized 执行步骤：\n         1.线程获得锁 2.清空变量副本 3.拷贝共享变量最新的值到变量副本 4.执行代码 5.将修改后的变量副本中的值赋值给共享数据  6. 释放锁 \n\n        原子性： 是指在一次操作或者多次操作中，必须所有的操作全部完整执行才可以，否则所有的操作都不执行，多个操作是一个不可分割的整体\n        原子性 ： 比如 银行转账  扣款和到账必须 是一体的 \n        volatile  只能保证 最新 ，不能保证原子性     volatile   +   synchronized锁  可以保证 原子性  ， 但是 性能较差\n        Atomic 接口  原子类 接口  实现保证原子性，更新 数据  AtomicInterger   以 原子的方式 对值进行修改\n        把共享数据  使用 原子类来实现 ， 共享数据的改变使用  使用原子类来操作    ac.incrementAndGet\n        原子类 原理 ：  自旋锁 + CAS算法 \n                       CAS 算法 有三个操作数 ： 内存值V 旧的预期值A 要修改的值B \n                       自旋操作： 当 A==V 修改成功，把V 赋值为B ， 当 A!=V 修改失败 不做任何操作V还是原来的，并且重新获取现在的最新值\n                              这个重新获取的动作就是自旋。  自旋以后重新去执行CAS算法 ，执行运算\n                               \n         volatile   +   synchronized锁 与 Atomic  CAS  的区别\n            相同点： 多线程情况下都能保证共享数据的安全\n            不同点： （悲观锁）synchronized锁 总是从最坏的角度出发 ，认为每次获取的数据的时候别人都可能修改了，因此每次读取共享数据之前都上锁\n                     （乐观锁）CAS 从乐观的角度出发，假设每次获取数据别人都不会修改，所以不上同步锁，\n                     只不过在每次修改共享数据的时候都会检查一下，别人有没有修改过数据。 （旧的期望值 等不等于  当前的内存值（变量副本中的值））\n         hashmap 是线程不安全的 ，多线程环境下存在问题。为了保证数据安全可以使用 hashTable 但是 hashTable 效率低下 \n                   hashTable  是 悲观锁 实现 数据安全性 ， 只要有数据改变 ，就锁表\n         ConcurrentHashMap 既可以保证线程安全，数据安全 ，又可以保证执行效率    （并发的 hash 双列表 结构） \n         ConcurrentHashMap JDK1.7\n                    二次哈希 ，也会锁表，但是锁的是单个地址位置上的 hashentry数组 ,不影响其他位置使用\n                    第一次会根据 键的哈希值来计算出 在大数组中的应存入的位置，  \n                    如果为null ，创建小数组，二次哈希，计算出小数组的存储位置， 存入。 \n                    如果不为null,先找到小数组，再计算出小数组中的位置，没有就存，有就比较后存储，\n\n         ConcurrentHashMap JDK1.8\n                    数组 链表 红黑树  CAS 原子锁  ，只锁 单个位置上的链表或者红黑树\n         CountDownLatch (倒数计秒 取插销)  传递需要等待的线程数   很奇怪 的 东西  ， 线程数 ，等待 ，以及通知 。某个线程 干完事说一声\n                    CountDownLatch  可以传递给每一个线程， 用于几个线程之间通知 线程执行完毕的状态\n                    每个线程执行完 要调用  countdown 方法   ，再等待的线程 wait 等待 ，等它等待的几条线程全部执行完毕，会被自动唤起开始继续执行\n                    例如 要等待 三个线程 ，等三个线程都完成了 则 再等待的线程开始执行 ， 底层原理 是一个计数器\n        Semaphore     信号标， 通行证 ，令牌 ， 一段时间内 只能去允许 几个线程执行 ， 当某一个执行完成，释放信号，归还通行证， \n                     别的等待的就能领取通行证，开始执行。 原理就跟 限定10辆车进入园区一样， 进去拿通行证，出去交还通行证，最多十辆\n                     多个线程 共同找同一个管理员：   获取通行证 ， 拿到通行证开始执行 方法块代码，执行完了 ， 归还通行证\n                     \n        \n    ")]),t("div",[n._v(" 网络编程  UDP TCP")]),t("pre",[n._v("        三要素： IP地址  端口  协议     ，服务运行的 IP , 程序跑的端口 ， 约定的协议\n        ping 域名  可以取到 这个域名 的 IP \n        IPV4 本身 是 32bit  4个8bit 位置的数组组成   点分 十进制 表示法   127.23.36.23  256 的4次方  42亿个地址左右\n        IPV6 是  128个bit 位置  每16个一组 ，分为8组  冒分 十六进制 表示法   2404:3c00:484d:b300:84ff:c8e3:999c:ecf2   \n        InetAddress  可以获取 电脑的 相关的 名字属性等  网络相关的  地址 协议 等\n        \n        UDP 协议  面向无连接的协议 ，不管对方是否建立连接 ，   速度快 最多64K 不安全 容易丢失数据\n        TCP 协议  面向有连接的协议 ，速度慢 ，没有大小限制 ，数据安全  \n\n        UDP 通讯程序\n            DatagramSocket   数据程序通信    指定端口收发数据 。 发送的都是 字节码  接收 可以指定接收容器大小\n            发送端：  步骤： 新建socket对象， 新的接收消息存放箱子，  消息打包  ，发送出去 ，释放资源 \n            接收端：  步骤： 新建socket对象， 新的接收消息存放箱子，  消息打包  ，从箱子获取消息 ，释放资源 \n        UDP 三种通讯形式： 单播， 组播 （局域网） ，广播     \n            单播 发送端 指定 接收端 ip 和端口   接收端 接收 指定的 IP端口\n            组播 在 224.1.x.x  号段 端口  组播 需要 发送端 和接收端约定 组播地址 ip 和端口\n            广播 在 255.255.255.255  号段  端口  接收端 接收指定 端口  ， 广播针对 当前路由器链接的所有电脑\n            无论如何  接收端 都需要订阅  或者固定 IP端口  或者是 号段\n        TCP 通讯程序\n            在客户端和 服务端 各自建立一个 socket 对象\n            TCP 发送数据通讯之前 必须保证 连接建立\n            客户端    发送数据步骤：\n                    1.创建 客户端的 Socket 对象 与指定的 服务端 链接  Socket( host ,port)\n                    2.获取输出流 ，写数据   OutputStream \n                    3.释放资源  close \n            服务端    接收数据步骤：  \n                    1.创建服务器端的Socket 对象  ServerSocket(port)\n                    2.监听客户端链接，  accept()  如果收到数据则返回一个Socket 对象 ，  死等 阻塞形式的等待\n                    3.获取输入流，读数据，并把数据显示在控制台   InputStream \n                    4.释放资源   close \n\n            注意点：不论是 客户端还是服务器端，有至少有一个写入或者写出流 和 一个 socket 需要 关闭 释放资源 \n                    如果是建立链接后多次写入写出 ，则需要使用 socket 去 关闭写入写出流，并且对socket 没有影响 ，不会关闭自己 \n                    如果传输中文，需要把字节流转换为 字符缓冲流\n                    1. accept 方法是阻塞的 ，作用是等待客户端 链接\n                    2. 客户端创建对象并链接服务器，此时是通过三次握手协议保证跟服务器之间的连接\n                    3.和UDP 相反， TCP 针对客户端来讲，是往外写，是输出流。 针对服务端来讲，是往里读，是输入流\n                    4.服务器 读数据也是阻塞的 ，一直读取\n                    5.在客户端关闭输出流的时候， 还会向服务器发送一个结束标记 的动作 信息\n                    6.客户端断开链接，通过四次挥手协议保证链接终止\n            三次握手： 1.客户端向服务器端发出链接请求 ，等待服务器确认是否可以链接\n                       2.服务器端向客户端返回一个相应，告诉客户端收到了请求，你可以链接/或者不能链接\n                       3.客户端向服务器端再次发出确认信息， 建立链接  去索要东西\n            四次挥手： 1.客户端向服务器发出取消连接请求\n                       2.服务器向客户端返回一个响应，表示收到客户端的取消请求\n                        中间这里，服务器将最后的数据处理完毕\n                       3.服务器向客户端发出确认取消的消息\n                       4.客户端再次发送确认消息 ，取消链接      \n            文件上传要使用 线程池  多线程 实现\n                             \n\n\n    ")]),t("div",[n._v("类加载器和 反射")]),t("pre",[n._v('        classLoader   类加载器     \n        启动类加载器  平台类加载器  系统类加载器  自定义类加载器\n        双亲委派模型  默认先由 父加载器加载类文件 \n        类加载器，可以去加载文件 返回 字节流 \n\n        java的 反射机制   reflect\n               是指再 java 运行状态中，对于任意一个类，都能知道这个类的所有属性和方法\n               对于任意一个对象，都能够调用它的任意属性和方法\n               这种动态获取信息以及动态调用对象的功能称为 java 语言的反射机制\n            通过配置文件 动态的加载类名 和方法名字， 进行调用   \n        获得 class 对象的三种形式   Student.getClass()  Class.forName(类的全类名)   Student.class  \n         使用 反射 获取 类的  constructor field   method  单个对象 的  实例\n        利用反射创建对象实例步骤：\n            1.forName 获取 class 对象\n            2.获取构造方法对象\n            3.利用newInstance  创建 类 的 对象\n            被 private 修饰的 成员 是不能直接使用的，如果使用反射强行获取并且使用，需要临时取消访问检查\n            setAccessible  暴力反射  强行使用\n            field  get  set 设置值 必须指定对象 \n            method  invoke 运行方法\n\n        XML \n            小于  <  大于 > 和号 & 单引号 \' 双引号 "\n            <![CDATA[内容]]>\n            XML 解析 ： jaxp   jdom dom4j  pull  \n            add as libary\n            使用 解析插件  解析xml  获得  document 对象\n        DTD  schema\n        自定义dtd    自定义 文档定义类型\n        !DOCTYPE 跟标签 SYSTEM 本地文件路径\n        !DOCTYPE 跟标签 PUBLIC  文件名  文件网络上的路径\n        ELEMENT ATTLIST \n        schema  .xsd  文件     schema 文档约束文件   更加灵活\n        名称空间 约定  顺序 类型\n\n        枚举  ENUM \n            通过枚举类名.枚举项名称 方式去访问指定的枚举项\n            每一个枚举项其实就是该枚举的一个对象\n            枚举也是一个类，可以去定义成员变量、\n            第一行必须是枚举项\n            枚举类可以有构造器 ，必须是 private 的\n            枚举类也可以有抽象方法，但是枚举项必须重写这个方法\n\n        注解\n            deprecated 过时的   suppressWarning 压制警告  retention 注解存活保留时间 生命周期\n            注解是给编译器看的 ，代表一些特殊功能\n            自定义注解 \n            public @interface 注解名称{\n                    public 属性类型 属性名() default 默认值;\n            }\n            自定义注解的 属性 类型 可是是 基本类型， class 类型 注解类型  枚举类型 ，或者这些可选类型的一维数组类型\n            在使用注解的时候，如果注解里面的属性没有指定默认值，就需要我们手动给出注解属性的默认值\n            @anni(name="但是此时") 针对 value 这个特殊的注解属性，如果只需要给这个属性赋值则可以@ann("杀杀杀")\n            利用反射 获取到类的 方法 ，方法是 method 类的 实例 method 有方法判定是否自身有注解\n            method 注解包内有 方法判定是否预设了指定的注解 ，从而来判断一个方法是否添加了注解 \n            retention  默认 是 只在Java 文件内有效，在 字节码文件  运行时 无效\n        元注解 \n            描述注解的注解      \n                常用元注解：retention 生命周期  target 使用范围  inherited  可被继承  documented   会出现在API文档\n        单元测试 Junit \n            @Test   @before  @after  \n        日志技术 log4j\n            日志体系结构 两套接口 ： JCL slf4j\n            可以直接使用 log4j\n            也可以使用 slf4j 里面的 api 来获取日志对象，使用 log4j 来实现 slf4j\n            好处是 以后更换日志的实现类 代码 基本不用改什么\n            log4j 组成：\n                1.loggers 记录器 日志的级别\n                2.appenders 输出源 日志要输出的地方\n                3.layouts 布局 日志输出的格式 \n\n    ')])])}],u={},m=u,d=t("2877"),g=Object(d["a"])(m,c,p,!1,null,"38f9d7bc",null),S=g.exports,v=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent1}}),t("q-markdown",{attrs:{src:n.MainComponent2}}),t("q-markdown",{attrs:{src:n.MainComponent3}}),t("q-markdown",{attrs:{src:n.MainComponent4}}),t("q-markdown",{attrs:{src:n.MainComponent5}}),t("q-markdown",{attrs:{src:n.MainComponent6}})],1)},b=[],h="## 1. Java概述\r\n\r\n### 1.1 Java语言背景介绍（了解）\r\n\r\n语言：人与人交流沟通的表达方式\r\n\r\n计算机语言：人与计算机之间进行信息交流沟通的一种特殊语言\r\n\r\nJava语言是美国Sun公司（Stanford University Network）在1995年推出的计算机语言\r\n\r\nJava之父：詹姆斯·高斯林（James Gosling）\r\n\r\n2009年，Sun公司被甲骨文公司收购，所以我们现在访问oracle官网即可：[https://www.oracle.com](https://www.oracle.com/) \r\n\r\njava语言的三个版本：\r\n\r\n​\tJavaSE:  Java 语言的（标准版），用于桌面应用的开发，是其他两个版本的基础\r\n\r\n​\tJavaME: Java 语言的（小型版），用于嵌入式消费类电子设备\r\n\r\n​\tJavaEE: Java 语言的（企业版），用于 Web 方向的网站开发\r\n\r\n### 1.2 Java语言跨平台原理（理解）\r\n\r\nJava程序并非是直接运行的，Java编译器将Java源程序编译成与平台无关的字节码文件(class文件)，然后由Java虚拟机（JVM）对字节码文件解释执行。所以在不同的操作系统下，只需安装不同的Java虚拟机即可实现java程序的跨平台。\r\n\r\n### 1.3 JRE和JDK（记忆）\r\n\r\nJVM（Java Virtual Machine），Java虚拟机\r\n\r\nJRE（Java Runtime Environment），Java运行环境，包含了JVM和Java的核心类库（Java API）\r\n\r\nJDK（Java Development Kit）称为Java开发工具，包含了JRE和开发工具\r\n\r\n总结：我们只需安装JDK即可，它包含了java的运行环境和虚拟机。\r\n\r\n### 1.4 JDK的下载和安装（应用）\r\n\r\n#### 1.4.1 下载\r\n\r\n通过官方网站获取JDK\r\n\r\n[http://www.oracle.com](http://www.oracle.com/)\r\n\r\n**注意**：针对不同的操作系统，需要下载对应版本的JDK。\r\n\r\n#### 1.4.2 安装\r\n\r\n傻瓜式安装，下一步即可。但默认的安装路径是在C:\\Program Files下，为方便统一管理建议修改安装路径，将与开发相关的软件都安装到一个目录下，例如：E:\\develop。\r\n\r\n**注意**：安装路径不要包含中文或者空格等特殊字符（使用纯英文目录）。\r\n\r\n#### 1.4.3 JDK的安装目录介绍\r\n\r\n| 目录名称 | 说明                                                         |\r\n| -------- | ------------------------------------------------------------ |\r\n| bin      | 该路径下存放了JDK的各种工具命令。javac和java就放在这个目录。 |\r\n| conf     | 该路径下存放了JDK的相关配置文件。                            |\r\n| include  | 该路径下存放了一些平台特定的头文件。                         |\r\n| jmods    | 该路径下存放了JDK的各种模块。                                |\r\n| legal    | 该路径下存放了JDK各模块的授权文档。                          |\r\n| lib      | 该路径下存放了JDK工具的一些补充JAR包。                       |\r\n\r\n\r\n\r\n## 2. 第一个演示程序\r\n\r\n### 2.1 常用DOS命令（应用）\r\n\r\n在接触集成开发环境之前，我们需要使用命令行窗口对java程序进行编译和运行，所以需要知道一些常用DOS命令。\r\n\r\n1、打开命令行窗口的方式：win + r打开运行窗口，输入cmd，回车。\r\n\r\n2、常用命令及其作用\r\n\r\n| 操作               | 说明                              |\r\n| ------------------ | --------------------------------- |\r\n| 盘符名称:          | 盘符切换。E:回车，表示切换到E盘。 |\r\n| dir                | 查看当前路径下的内容。            |\r\n| cd 目录            | 进入单级目录。cd itheima          |\r\n| cd ..              | 回退到上一级目录。                |\r\n| cd 目录1\\目录2\\... | 进入多级目录。cd itheima\\JavaSE   |\r\n| cd \\               | 回退到盘符目录。                  |\r\n| cls                | 清屏。                            |\r\n| exit               | 退出命令提示符窗口。              |\r\n\r\n### 2.2 Path环境变量的配置（应用）\r\n\r\n#### 2.2.1 为什么配置环境变量\r\n\r\n开发Java程序，需要使用JDK提供的开发工具（比如javac.exe、java.exe等命令），而这些工具在JDK的安装目录的bin目录下，如果不配置环境变量，那么这些命令只可以在该目录下执行。我们不可能把所有的java文件都放到JDK的bin目录下，所以配置环境变量的作用就是可以使bin目录下的java相关命令可以在任意目录下使用。    \r\n\r\n### 2.3 HelloWorld案例（应用）\r\n\r\nHelloWorld案例是指在计算机屏幕上输出“HelloWorld”这行文字。\r\n\r\n各种计算机语言都习惯使用该案例作为第一个演示案例。\r\n\r\n#### 2.3.1 Java程序开发运行流程\r\n\r\n开发Java程序，需要三个步骤：编写程序，编译程序，运行程序。\r\n\r\n#### 2.3.2 HelloWorld案例的编写\r\n\r\n1、新建文本文档文件，修改名称为HelloWorld.java。\r\n\r\n2、用记事本打开HelloWorld.java文件，输写程序内容。\r\n\r\n~~~java\r\npublic class HelloWorld {\r\n\tpublic static void main(String[] args) {\r\n\t\tSystem.out.println(\"HelloWorld\");\r\n\t}\r\n}\r\n~~~\r\n\r\n#### 2.3.3 HelloWorld案例的编译和运行\r\n\r\n存文件，打开命令行窗口，将目录切换至java文件所在目录，编译java文件生成class文件，运行class文件。\r\n\r\n> 编译：javac 文件名.java\r\n>\r\n> 范例：javac HelloWorld.java\r\n>\r\n> 执行：java 类名\r\n>\r\n> 范例：java HelloWorld\r\n\r\n### 2.4 HelloWorld案例详解（理解）\r\n\r\n![](./img/java/basics/day01-java基础语法.img/图片1.jpg)\r\n\r\n### 2.5 HelloWorld案例常见问题（理解）\r\n\r\n#### 2.5.1 BUG\r\n\r\n在电脑系统或程序中，隐藏着的一些未被发现的缺陷或问题统称为bug（漏洞）。\r\n\r\n#### 2.5.2 BUG的解决\r\n\r\n1、具备识别BUG的能力：多看\r\n\r\n2、具备分析BUG的能力：多思考，多查资料\r\n\r\n3、具备解决BUG的能力：多尝试，多总结\r\n\r\n#### 2.5.3 HelloWorld案例常见问题\r\n\r\n1、非法字符问题。Java中的符号都是英文格式的。\r\n\r\n2、大小写问题。Java语言对大小写敏感（区分大小写）。\r\n\r\n3、在系统中显示文件的扩展名，避免出现HelloWorld.java.txt文件。\r\n\r\n4、编译命令后的java文件名需要带文件后缀.java\r\n\r\n5、运行命令后的class文件名（类名）不带文件后缀\r\n\r\n### 2.6 Notepad++软件的安装和使用（应用）\r\n\r\n#### 2.6.1 什么要使用Notepad++软件\r\n\r\nNotepad++功能比windows中的自带记事本功能强大，除了可以用来制作一般的纯文字说明文件，也十分适合编写计算机程序代码。Notepad++有行号，能够快速定位问题位置，还有语法高亮度显示、代码折叠等功能。而且它是免费的。\r\n\r\n#### 2.6.2 Notepad++软件安装\r\n\r\n安装：傻瓜式安装，一直下一步即可。建议也安装到统一的开发软件目录下，比如E:\\develop。\r\n\r\n#### 2.6.3Notepad++软件配置\r\n\r\n安装完毕之后，为了使用方便，做一个简单的配置：修改默认语言和编码。\r\n\r\n## 3. java基础语法\r\n\r\n### 3.1 注释（理解）\r\n\r\n注释是对代码的解释和说明文字，可以提高程序的可读性，因此在程序中添加必要的注释文字十分重要。Java中的注释分为三种：\r\n\r\n单行注释。单行注释的格式是使用//，从//开始至本行结尾的文字将作为注释文字。\r\n\r\n~~~java\r\n// 这是单行注释文字\r\n~~~\r\n\r\n多行注释。多行注释的格式是使用/* 和 */将一段较长的注释括起来。\r\n\r\n~~~java\r\n/*\r\n这是多行注释文字\r\n这是多行注释文字\r\n这是多行注释文字\r\n*/\r\n注意：多行注释不能嵌套使用。\r\n~~~\r\n\r\n文档注释。文档注释以`/**`开始，以`*/`结束。（以后讲）\r\n\r\n### 3.2 关键字（理解）\r\n\r\n关键字是指被java语言赋予了特殊含义的单词。\r\n\r\n关键字的特点：\r\n\r\n​\t关键字的字母全部小写。\r\n\r\n​\t常用的代码编辑器对关键字都有高亮显示，比如现在我们能看到的public、class、static等。\r\n\r\n### 3.3 常量（应用）\r\n\r\n常量：在程序运行过程中，其值不可以发生改变的量。\r\n\r\nJava中的常量分类：\r\n\r\n​\t字符串常量  用双引号括起来的多个字符（可以包含0个、一个或多个），例如\"a\"、\"abc\"、\"中国\"等\r\n\r\n​\t整数常量  整数，例如：-10、0、88等\r\n\r\n​\t小数常量  小数，例如：-5.5、1.0、88.88等\r\n\r\n​\t字符常量  用单引号括起来的一个字符，例如：'a'、'5'、'B'、'中'等\r\n\r\n​\t布尔常量  布尔值，表示真假，只有两个值true和false\r\n\r\n​\t空常量  一个特殊的值，空值，值为null\r\n\r\n除空常量外，其他常量均可使用输出语句直接输出。\r\n\r\n~~~java\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        System.out.println(10); // 输出一个整数\r\n        System.out.println(5.5); // 输出一个小数\r\n        System.out.println('a'); // 输出一个字符\r\n        System.out.println(true); // 输出boolean值true\r\n        System.out.println(\"欢迎来到黑马程序员\"); // 输出字符串\r\n    }\r\n}\r\n~~~\r\n\r\n### 3.4 变量的介绍(理解)\r\n\r\n变量的定义格式：\r\n\r\n​\t数据类型 变量名 = 数据值；\r\n\r\n​\t数据类型：为空间中存储的数据加入类型限制。整数？小数？\r\n\r\n​\t变量名：自己要为空间起的名字，没有难度\r\n\r\n​\t数据值： 空间中要存储的数值，没有难度\r\n\r\n### 3.5 数据类型（应用）\r\n\r\n#### 3.5.1 计算机存储单元\r\n\r\n我们知道计算机是可以用来存储数据的，但是无论是内存还是硬盘，计算机存储设备的最小信息单元叫“位（bit）”，我们又称之为“比特位”，通常用小写的字母”b”表示。而计算机中最基本的存储单元叫“字节（byte）”，\r\n\r\n通常用大写字母”B”表示，字节是由连续的8个位组成。\r\n\r\n除了字节外还有一些常用的存储单位，其换算单位如下：\r\n\r\n1B（字节） = 8bit\r\n\r\n1KB = 1024B\r\n\r\n1MB = 1024KB\r\n\r\n1GB = 1024MB\r\n\r\n1TB = 1024GB\r\n\r\n#### 3.5.2 Java中的数据类型\r\n\r\nJava是一个强类型语言，Java中的数据必须明确数据类型。在Java中的数据类型包括基本数据类型和引用数据类型两种。\r\n\r\nJava中的基本数据类型：\r\n\r\n| 数据类型 | 关键字       | 内存占用 | 取值范围                                                     |\r\n| :------- | ------------ | -------- | :----------------------------------------------------------- |\r\n| 整数类型 | byte         | 1        | -128~127                                                     |\r\n|          | short        | 2        | -32768~32767                                                 |\r\n|          | int(默认)    | 4        | -2的31次方到2的31次方-1                                      |\r\n|          | long         | 8        | -2的63次方到2的63次方-1                                      |\r\n| 浮点类型 | float        | 4        | 负数：-3.402823E+38到-1.401298E-45                                                             正数：   1.401298E-45到3.402823E+38 |\r\n|          | double(默认) | 8        | 负数：-1.797693E+308到-4.9000000E-324                                              正数：4.9000000E-324   到1.797693E+308 |\r\n| 字符类型 | char         | 2        | 0-65535                                                      |\r\n| 布尔类型 | boolean      | 1        | true，false                                                  |\r\n\r\n说明：\r\n\r\n​\te+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方。\r\n\r\n​\t在java中整数默认是int类型，浮点数默认是double类型。\r\n\r\n### 3.6 变量（应用）\r\n\r\n#### 3.6.1 变量的定义\r\n\r\n变量：在程序运行过程中，其值可以发生改变的量。\r\n\r\n从本质上讲，变量是内存中的一小块区域，其值可以在一定范围内变化。\r\n\r\n变量的定义格式：\r\n\r\n```java\r\n数据类型 变量名 = 初始化值; // 声明变量并赋值\r\nint age = 18;\r\nSystem.out.println(age);\r\n```\r\n\r\n或者(扩展)\r\n\r\n```java\r\n// 先声明，后赋值（使用前赋值即可）\r\n数据类型 变量名;\r\n变量名 = 初始化值;\r\ndouble money;\r\nmoney = 55.5;\r\nSystem.out.println(money);\r\n```\r\n\r\n还可以(扩展)\r\n\r\n在同一行定义多个同一种数据类型的变量，中间使用逗号隔开。但不建议使用这种方式，降低程序的可读性。\r\n\r\n```java\r\nint a = 10, b = 20; // 定义int类型的变量a和b，中间使用逗号隔开\r\nSystem.out.println(a);\r\nSystem.out.println(b);\r\n\r\nint c,d; // 声明int类型的变量c和d，中间使用逗号隔开\r\nc = 30;\r\nd = 40;\r\nSystem.out.println(c);\r\nSystem.out.println(d);\r\n```\r\n\r\n#### 3.6.2 变量的修改\r\n\r\n```java\r\nint a = 10;\r\na = 30;  //修改变量的值\r\nSystem.out.println(a);\r\n```\r\n\r\n变量前面不加数据类型时，表示修改已存在的变量的值。\r\n\r\n### 3.7 变量的注意事项(理解)\r\n\r\n1. 在同一对花括号中，变量名不能重复。\r\n2. 变量在使用之前，必须初始化（赋值）。\r\n3. 定义long类型的变量时，需要在整数的后面加L（大小写均可，建议大写）。因为整数默认是int类型，整数太大可能超出int范围。\r\n4. 定义float类型的变量时，需要在小数的后面加F（大小写均可，建议大写）。因为浮点数的默认类型是double， double的取值范围是大于float的，类型不兼容。\r\n\r\n### 3.8 键盘录入（理解）\r\n\r\n我们可以通过 Scanner 类来获取用户的输入。使用步骤如下：\r\n\r\n1、导包。Scanner 类在java.util包下，所以需要将该类导入。导包的语句需要定义在类的上面。\r\n\r\n```java\r\nimport java.util.Scanner; \r\n```\r\n\r\n2、创建Scanner对象。\r\n\r\n```java\r\nScanner sc = new Scanner(System.in);// 创建Scanner对象，sc表示变量名，其他均不可变\r\n```\r\n\r\n3、接收数据\r\n\r\n```java\r\nint i = sc.nextInt(); // 表示将键盘录入的值作为int数返回。\r\n```\r\n\r\n示例：\r\n\r\n```java\r\nimport java.util.Scanner;\r\npublic class ScannerDemo {\r\n\tpublic static void main(String[] args) {\r\n\t\t//创建对象\r\n\t\tScanner sc = new Scanner(System.in);\r\n\t\t//接收数据\r\n\t\tint a = sc.nextInt();\r\n\t\t//输出数据\r\n\t\tSystem.out.println(a);\r\n\t}\r\n}\r\n```\r\n\r\n### 3.9 标识符（理解）\r\n\r\n标识符是用户编程时使用的名字，用于给类、方法、变量、常量等命名。\r\n\r\nJava中标识符的组成规则：\r\n\r\n​\t由字母、数字、下划线“_”、美元符号“$”组成，第一个字符不能是数字。\r\n\r\n​\t不能使用java中的关键字作为标识符。\t\r\n\r\n​\t标识符对大小写敏感（区分大小写）。\r\n\r\nJava中标识符的命名约定：\r\n\r\n​\t小驼峰式命名：变量名、方法名\r\n\r\n​\t\t首字母小写，从第二个单词开始每个单词的首字母大写。\r\n\r\n​\t大驼峰式命名：类名\r\n\r\n​\t\t每个单词的首字母都大写。\r\n\r\n​\t另外，标识符的命名最好可以做到见名知意\r\n\r\n​\t\t例如：username、studentNumber等。\r\n\r\n",y='# Java基础语法\r\n\r\n## 1 类型转换\r\n\r\n在Java中，一些数据类型之间是可以相互转换的。分为两种情况：自动类型转换和强制类型转换。\r\n\r\n### 1.1 隐式转换(理解)\r\n\r\n​\t把一个表示数据范围小的数值或者变量赋值给另一个表示数据范围大的变量。这种转换方式是自动的，直接书写即可。例如：\r\n\r\n```java\r\ndouble num = 10; // 将int类型的10直接赋值给double类型\r\nSystem.out.println(num); // 输出10.0\r\n```\r\n\r\n​\t类型从小到大关系图：\r\n\r\n​\t![](./img/java/basics/day02-Java基础语法.img/图片1.png)\r\n\r\n说明：\r\n\r\n1. 整数默认是int类型，byte、short和char类型数据参与运算均会自动转换为int类型。\r\n\r\n```java\r\nbyte b1 = 10;\r\nbyte b2 = 20;\r\nbyte b3 = b1 + b2; \r\n// 第三行代码会报错，b1和b2会自动转换为int类型，计算结果为int，int赋值给byte需要强制类型转换。\r\n// 修改为:\r\nint num = b1 + b2;\r\n// 或者：\r\nbyte b3 = (byte) (b1 + b2);\r\n```\r\n\r\n2. boolean类型不能与其他基本数据类型相互转换。\r\n\r\n### 1.2 强制转换(理解)\r\n\r\n​\t把一个表示数据范围大的数值或者变量赋值给另一个表示数据范围小的变量。\r\n\r\n​\t强制类型转换格式：目标数据类型 变量名 = (目标数据类型)值或者变量;\r\n\r\n​\t例如：\r\n\r\n```java\r\ndouble num1 = 5.5;\r\nint num2 = (int) num1; // 将double类型的num1强制转换为int类型\r\nSystem.out.println(num2); // 输出5（小数位直接舍弃）\r\n```\r\n\r\n### 1.3 类型转换案例(理解)\r\n\r\n案例代码：\r\n\r\n```java\r\nbyte a = 3;\r\nbyte b = 4;\r\nbyte c = a + b; //错误。因为两个byte变量相加，会先提升为int类型\r\nbyte d = 3 + 4; //正确。常量优化机制\r\n```\r\n\r\n常量优化机制：\r\n\r\n​\t在编译时，整数常量的计算会直接算出结果，并且会自动判断该结果是否在byte取值范围内，\r\n\r\n​\t\t在：编译通过\r\n\r\n  \t\t不在：编译失败\r\n\r\n## 2. 运算符\r\n\r\n### 2.1 算术运算符\r\n\r\n#### 2.1.1 运算符和表达式（了解）\r\n\r\n运算符：对常量或者变量进行操作的符号\r\n\r\n表达式：用运算符把常量或者变量连接起来符合java语法的式子就可以称为表达式。\r\n\r\n​                    不同运算符连接的表达式体现的是不同类型的表达式。\r\n\r\n举例说明：\r\n\r\n```java\r\nint a = 10;\r\nint b = 20;\r\nint c = a + b;\r\n```\r\n\r\n  +：是运算符，并且是算术运算符。\r\n\r\n  a + b：是表达式，由于+是算术运算符，所以这个表达式叫算术表达式。\r\n\r\n####  2.1.2 算术运算符(应用)\r\n\r\n| 符号 | 作用 | 说明                         |\r\n| ---- | ---- | ---------------------------- |\r\n| +    | 加   | 参看小学一年级               |\r\n| -    | 减   | 参看小学一年级               |\r\n| *    | 乘   | 参看小学二年级，与“×”相同    |\r\n| /    | 除   | 参看小学二年级，与“÷”相同    |\r\n| %    | 取余 | 获取的是两个数据做除法的余数 |\r\n\r\n注意：\r\n\r\n1. /和%的区别：两个数据做除法，/取结果的商，%取结果的余数。\r\n\r\n2. 整数操作只能得到整数，要想得到小数，必须有浮点数参与运算。\r\n\r\n~~~java\r\nint a = 10;\r\nint b = 3;\r\nSystem.out.println(a / b); // 输出结果3\r\nSystem.out.println(a % b); // 输出结果1\r\n~~~\r\n\r\n#### 2.1.3 字符的“+”操作（理解）\r\n\r\nchar类型参与算术运算，使用的是计算机底层对应的十进制数值。需要我们记住三个字符对应的数值：\r\n\r\n\'a\'  --  97\t\ta-z是连续的，所以\'b\'对应的数值是98，\'c\'是99，依次递加\r\n\r\n\'A\'  --  65\t\tA-Z是连续的，所以\'B\'对应的数值是66，\'C\'是67，依次递加\r\n\r\n\'0\'  --  48\t\t0-9是连续的，所以\'1\'对应的数值是49，\'2\'是50，依次递加\r\n\r\n~~~java\r\n// 可以通过使用字符与整数做算术运算，得出字符对应的数值是多少\r\nchar ch1 = \'a\';\r\nSystem.out.println(ch1 + 1); // 输出98，97 + 1 = 98\r\n\r\nchar ch2 = \'A\';\r\nSystem.out.println(ch2 + 1); // 输出66，65 + 1 = 66\r\n\r\nchar ch3 = \'0\';\r\nSystem.out.println(ch3 + 1); // 输出49，48 + 1 = 49\r\n~~~\r\n\r\n算术表达式中包含不同的基本数据类型的值的时候，整个算术表达式的类型会自动进行提升。\r\n\r\n提升规则：\r\n\r\nbyte类型，short类型和char类型将被提升到int类型，不管是否有其他类型参与运算。\r\n\r\n整个表达式的类型自动提升到与表达式中最高等级的操作数相同的类型\r\n\r\n​       等级顺序：byte,short,char --\x3e int --\x3e long --\x3e float --\x3e double\r\n\r\n例如：\r\n\r\n~~~java\r\nbyte b1 = 10;\r\nbyte b2 = 20;\r\n// byte b3 = b1 + b2; // 该行报错，因为byte类型参与算术运算会自动提示为int，int赋值给byte可能损失精度\r\nint i3 = b1 + b2; // 应该使用int接收\r\nbyte b3 = (byte) (b1 + b2); // 或者将结果强制转换为byte类型\r\n-------------------------------\r\nint num1 = 10;\r\ndouble num2 = 20.0;\r\ndouble num3 = num1 + num2; // 使用double接收，因为num1会自动提升为double类型\r\n~~~\r\n\r\n#### 2.1.4 字符串的“+”操作（理解）\r\n\r\n当“+”操作中出现字符串时，这个”+”是字符串连接符，而不是算术运算。\r\n\r\n~~~java\r\nSystem.out.println("itheima"+ 666); // 输出：itheima666\r\n~~~\r\n\r\n在”+”操作中，如果出现了字符串，就是连接运算符，否则就是算术运算。当连续进行“+”操作时，从左到右逐个执行。\r\n\r\n~~~java\r\nSystem.out.println(1 + 99 + "年黑马");            // 输出：100年黑马\r\nSystem.out.println(1 + 2 + "itheima" + 3 + 4);   // 输出：3itheima34\r\n// 可以使用小括号改变运算的优先级 \r\nSystem.out.println(1 + 2 + "itheima" + (3 + 4)); // 输出：3itheima7\r\n~~~\r\n\r\n#### 2.1.5 数值拆分（应用）\r\n\r\n需求：\r\n\r\n​\t键盘录入一个三位数，将其拆分为个位，十位，百位，打印在控制台\r\n\r\n示例代码：\r\n\r\n```java\r\nimport java.util.Scanner;\r\npublic class Test {\r\n\tpublic static void main(String[] args) {\r\n\t\t// 1：使用Scanner键盘录入一个三位数\r\n\t\tScanner sc = new Scanner(System.in);\r\n\t\tSystem.out.println("请输入一个三位数");\r\n\t\tint num = sc.nextInt();\r\n\t\t// 2：个位的计算：数值 % 10\r\n\t\tint ge = num % 10;\t\t\r\n\t\t// 3：十位的计算：数值 / 10 % 10\r\n\t\tint shi = num / 10 % 10;\t\r\n\t\t// 4：百位的计算：数值 / 100\r\n\t\tint bai = num / 100;\r\n\t\t// 5：将个位, 十位, 百位拼接上正确的字符串, 打印即可\r\n\t\tSystem.out.println("整数"+num+"个位为:" + ge);\r\n\t\tSystem.out.println("整数"+num+"十位为:" + shi);\r\n\t\tSystem.out.println("整数"+num+"百位为:" + bai);\r\n\t\t\r\n\t}\r\n}\r\n```\r\n\r\n### 2.2 自增自减运算符（理解）\r\n\r\n| 符号 | 作用 | 说明        |\r\n| ---- | ---- | ----------- |\r\n| ++   | 自增 | 变量的值加1 |\r\n| --   | 自减 | 变量的值减1 |\r\n\r\n注意事项：\r\n\r\n​\t++和-- 既可以放在变量的后边，也可以放在变量的前边。\r\n\r\n​\t单独使用的时候， ++和-- 无论是放在变量的前边还是后边，结果是一样的。\r\n\r\n​\t参与操作的时候，如果放在变量的后边，先拿变量参与操作，后拿变量做++或者--。\r\n\r\n​\t参与操作的时候，如果放在变量的前边，先拿变量做++或者--，后拿变量参与操作。\r\n\r\n​\t最常见的用法：单独使用。\r\n\r\n```java\r\nint i = 10;\r\ni++; // 单独使用\r\nSystem.out.println("i:" + i); // i:11\r\n\r\nint j = 10;\r\n++j; // 单独使用\r\nSystem.out.println("j:" + j); // j:11\r\n\r\nint x = 10;\r\nint y = x++; // 赋值运算，++在后边，所以是使用x原来的值赋值给y，x本身自增1\r\nSystem.out.println("x:" + x + ", y:" + y); // x:11，y:10\r\n\r\nint m = 10;\r\nint n = ++m; // 赋值运算，++在前边，所以是使用m自增后的值赋值给n，m本身自增1\r\nSystem.out.println("m:" + m + ", m:" + m); // m:11，m:11\r\n```\r\n\r\n练习：\r\n\r\n```java\r\nint x = 10;\r\nint y = x++ + x++ + x++;\r\nSystem.out.println(y); // y的值是多少？\r\n/*\r\n解析，三个表达式都是++在后，所以每次使用的都是自增前的值，但程序自左至右执行，所以第一次自增时，使用的是10进行计算，但第二次自增时，x的值已经自增到11了，所以第二次使用的是11，然后再次自增。。。\r\n所以整个式子应该是：int y = 10 + 11 + 12;\r\n输出结果为33。\r\n*/\r\n注意：通过此练习深刻理解自增和自减的规律，但实际开发中强烈建议不要写这样的代码！小心挨打！\r\n```\r\n\r\n### 2.3 赋值运算符（应用）\r\n\r\n赋值运算符的作用是将一个表达式的值赋给左边，左边必须是可修改的，不能是常量。\r\n\r\n| 符号 | 作用       | 说明                  |\r\n| ---- | ---------- | --------------------- |\r\n| =    | 赋值       | a=10，将10赋值给变量a |\r\n| +=   | 加后赋值   | a+=b，将a+b的值给a    |\r\n| -=   | 减后赋值   | a-=b，将a-b的值给a    |\r\n| *=   | 乘后赋值   | a*=b，将a×b的值给a    |\r\n| /=   | 除后赋值   | a/=b，将a÷b的商给a    |\r\n| %=   | 取余后赋值 | a%=b，将a÷b的余数给a  |\r\n\r\n注意：\r\n\r\n扩展的赋值运算符隐含了强制类型转换。\r\n\r\n~~~java\r\nshort s = 10;\r\ns = s + 10; // 此行代码报出，因为运算中s提升为int类型，运算结果int赋值给short可能损失精度\r\n\r\ns += 10; // 此行代码没有问题，隐含了强制类型转换，相当于 s = (short) (s + 10);\r\n~~~\r\n\r\n### 2.4 关系运算符（应用）\r\n\r\n关系运算符有6种关系，分别为小于、小于等于、大于、等于、大于等于、不等于。\r\n\r\n| 符号 | 说明                                                    |\r\n| ---- | ------------------------------------------------------- |\r\n| ==   | a==b，判断a和b的值是否相等，成立为true，不成立为false   |\r\n| !=   | a!=b，判断a和b的值是否不相等，成立为true，不成立为false |\r\n| >    | a>b，判断a是否大于b，成立为true，不成立为false          |\r\n| >=   | a>=b，判断a是否大于等于b，成立为true，不成立为false     |\r\n| <    | a<b，判断a是否小于b，成立为true，不成立为false          |\r\n| <=   | a<=b，判断a是否小于等于b，成立为true，不成立为false     |\r\n\r\n注意事项：\r\n\r\n​\t关系运算符的结果都是boolean类型，要么是true，要么是false。\r\n\r\n​\t千万不要把“==”误写成“=”，"=="是判断是否相等的关系，"="是赋值。\r\n\r\n~~~java\r\nint a = 10;\r\nint b = 20;\r\nSystem.out.println(a == b); // false\r\nSystem.out.println(a != b); // true\r\nSystem.out.println(a > b); // false\r\nSystem.out.println(a >= b); // false\r\nSystem.out.println(a < b); // true\r\nSystem.out.println(a <= b); // true\r\n\r\n// 关系运算的结果肯定是boolean类型，所以也可以将运算结果赋值给boolean类型的变量\r\nboolean flag = a > b;\r\nSystem.out.println(flag); // 输出false\r\n~~~\r\n\r\n### 2.5 逻辑运算符（应用）\r\n\r\n逻辑运算符把各个运算的关系表达式连接起来组成一个复杂的逻辑表达式，以判断程序中的表达式是否成立，判断的结果是 true 或 false。\r\n\r\n| 符号 | 作用     | 说明                                         |\r\n| ---- | -------- | -------------------------------------------- |\r\n| &    | 逻辑与   | a&b，a和b都是true，结果为true，否则为false   |\r\n| \\|   | 逻辑或   | a\\|b，a和b都是false，结果为false，否则为true |\r\n| ^    | 逻辑异或 | a^b，a和b结果不同为true，相同为false         |\r\n| !    | 逻辑非   | !a，结果和a的结果正好相反                    |\r\n\r\n~~~java\r\n//定义变量\r\nint i = 10;\r\nint j = 20;\r\nint k = 30;\r\n\r\n//& “与”，并且的关系，只要表达式中有一个值为false，结果即为false\r\nSystem.out.println((i > j) & (i > k)); //false & false,输出false\r\nSystem.out.println((i < j) & (i > k)); //true & false,输出false\r\nSystem.out.println((i > j) & (i < k)); //false & true,输出false\r\nSystem.out.println((i < j) & (i < k)); //true & true,输出true\r\nSystem.out.println("--------");\r\n\r\n//| “或”，或者的关系，只要表达式中有一个值为true，结果即为true\r\nSystem.out.println((i > j) | (i > k)); //false | false,输出false\r\nSystem.out.println((i < j) | (i > k)); //true | false,输出true\r\nSystem.out.println((i > j) | (i < k)); //false | true,输出true\r\nSystem.out.println((i < j) | (i < k)); //true | true,输出true\r\nSystem.out.println("--------");\r\n\r\n//^ “异或”，相同为false，不同为true\r\nSystem.out.println((i > j) ^ (i > k)); //false ^ false,输出false\r\nSystem.out.println((i < j) ^ (i > k)); //true ^ false,输出true\r\nSystem.out.println((i > j) ^ (i < k)); //false ^ true,输出true\r\nSystem.out.println((i < j) ^ (i < k)); //true ^ true,输出false\r\nSystem.out.println("--------");\r\n\r\n//! “非”，取反\r\nSystem.out.println((i > j)); //false\r\nSystem.out.println(!(i > j)); //!false，,输出true\r\n~~~\r\n\r\n### 2.6 短路逻辑运算符（理解）\r\n\r\n| 符号 | 作用   | 说明                         |\r\n| ---- | ------ | ---------------------------- |\r\n| &&   | 短路与 | 作用和&相同，但是有短路效果  |\r\n| \\|\\| | 短路或 | 作用和\\|相同，但是有短路效果 |\r\n\r\n在逻辑与运算中，只要有一个表达式的值为false，那么结果就可以判定为false了，没有必要将所有表达式的值都计算出来，短路与操作就有这样的效果，可以提高效率。同理在逻辑或运算中，一旦发现值为true，右边的表达式将不再参与运算。\r\n\r\n- 逻辑与&，无论左边真假，右边都要执行。\r\n\r\n- 短路与&&，如果左边为真，右边执行；如果左边为假，右边不执行。\r\n\r\n- 逻辑或|，无论左边真假，右边都要执行。\r\n\r\n- 短路或||，如果左边为假，右边执行；如果左边为真，右边不执行。\r\n\r\n~~~java\r\nint x = 3;\r\nint y = 4;\r\nSystem.out.println((x++ > 4) & (y++ > 5)); // 两个表达都会运算\r\nSystem.out.println(x); // 4\r\nSystem.out.println(y); // 5\r\n\r\nSystem.out.println((x++ > 4) && (y++ > 5)); // 左边已经可以确定结果为false，右边不参与运算\r\nSystem.out.println(x); // 4\r\nSystem.out.println(y); // 4\r\n~~~\r\n\r\n### 2.7 三元运算符（理解）\r\n\r\n三元运算符语法格式：\r\n\r\n~~~java\r\n关系表达式 ? 表达式1 : 表达式2;\r\n~~~\r\n\r\n解释：问号前面的位置是判断的条件，判断结果为boolean型，为true时调用表达式1，为false时调用表达式2。其逻辑为：如果条件表达式成立或者满足则执行表达式1，否则执行第二个。\r\n\r\n举例：\r\n\r\n~~~java\r\nint a = 10;\r\nint b = 20;\r\nint c = a > b ? a : b; // 判断 a>b 是否为真，如果为真取a的值，如果为假，取b的值\r\n~~~\r\n\r\n### 2.8 三元运算符案例(应用)\r\n\r\n需求：\r\n\r\n​\t一座寺庙里住着三个和尚，已知他们的身高分别为150cm、210cm、165cm，请用程序实现获取这三个和尚的最高身高。\r\n\r\n~~~java\r\npublic class OperatorTest02 {\r\n\tpublic static void main(String[] args) {\r\n\t\t//1：定义三个变量用于保存和尚的身高，单位为cm，这里仅仅体现数值即可。\r\n\t\tint height1 = 150;\r\n\t\tint height2 = 210;\r\n\t\tint height3 = 165;\t\r\n\t\t//2：用三元运算符获取前两个和尚的较高身高值，并用临时身高变量保存起来。\r\n\t\tint tempHeight = height1 > height2 ? height1 : height2;\t\t\r\n\t\t//3：用三元运算符获取临时身高值和第三个和尚身高较高值，并用最大身高变量保存。\r\n\t\tint maxHeight = tempHeight > height3 ? tempHeight : height3;\t\r\n\t\t//4：输出结果\r\n\t\tSystem.out.println("maxHeight:" + maxHeight);\r\n\t}\r\n}\r\n~~~\r\n\r\n## 3. 流程控制语句\r\n\r\n在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。所以，我们必须清楚每条语句的执行流程。而且，很多时候要通过控制语句的执行顺序来实现我们想要的功能。\r\n\r\n### 3.1 流程控制语句分类(了解)\r\n\r\n​\t顺序结构\r\n\r\n​\t分支结构(if, switch)\r\n\r\n​\t循环结构(for, while, do…while)\r\n\r\n### 3.2 顺序结构(了解)\r\n\r\n顺序结构是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。\r\n\r\n顺序结构执行流程图：\r\n\r\n![1545615769372](./img/java/basics/day02-Java基础语法.img/图片2.png)\r\n\r\n### 3.3 分支结构之if语句\r\n\r\n#### 3.3.1 if语句格式1（理解）\r\n\r\n~~~java\r\n格式：\r\nif (关系表达式) {\r\n    语句体;\t\r\n}\r\n~~~\r\n\r\n执行流程：\r\n\r\n①首先计算关系表达式的值\r\n\r\n②如果关系表达式的值为true就执行语句体\r\n\r\n③如果关系表达式的值为false就不执行语句体\r\n\r\n④继续执行后面的语句内容\r\n\r\n![1545616039363](./img/java/basics/day02-Java基础语法.img/图片3.png)\r\n\r\n示例：\r\n\r\n~~~java\r\npublic class IfDemo {\r\n\tpublic static void main(String[] args) {\r\n\t\tSystem.out.println("开始");\r\n        \r\n\t\t// 如果年龄大于18岁, 就可以上网吧\r\n\t\tint age = 17;\r\n\t\t\r\n\t\tif(age >= 18){\r\n\t\t\t// int a = 10;\r\n\t\t\tSystem.out.println("可以上网吧");\r\n\t\t}\r\n\t\t\t\r\n\t\tSystem.out.println("结束");\r\n\t}\r\n}\r\n~~~\r\n\r\n#### 3.3.2 if语句格式2（理解）\r\n\r\n~~~java\r\n格式：\r\nif (关系表达式) {\r\n    语句体1;\t\r\n} else {\r\n    语句体2;\t\r\n}\r\n~~~\r\n\r\n执行流程：\r\n\r\n①首先计算关系表达式的值\r\n\r\n②如果关系表达式的值为true就执行语句体1\r\n\r\n③如果关系表达式的值为false就执行语句体2\r\n\r\n④继续执行后面的语句内容\r\n\r\n![1545616221283](./img/java/basics/day02-Java基础语法.img/图片4.png)\r\n\r\n示例：奇偶数\r\n\r\n​\t任意给出一个整数，请用程序实现判断该整数是奇数还是偶数，并在控制台输出该整数是奇数还是偶数。\r\n\r\n~~~java\r\npublic class Demo2If {\r\n\tpublic static void main(String[] args) {\r\n\t\t// 程序判断一个数, 是奇数还是偶数\r\n\t\tint num = 9;\r\n\t\t\r\n\t\tif(num % 2 == 0){\r\n\t\t\tSystem.out.println("偶数");\r\n\t\t}else{\r\n\t\t\tSystem.out.println("奇数");\r\n\t\t}\r\n\t}\r\n}\r\n~~~\r\n\r\n#### 3.3.3 if语句格式3（理解）\r\n\r\n~~~java\r\n格式：\r\nif (关系表达式1) {\r\n    语句体1;\t\r\n} else if (关系表达式2) {\r\n    语句体2;\t\r\n} \r\n…\r\nelse {\r\n    语句体n+1;\r\n}\r\n~~~\r\n\r\n执行流程：\r\n\r\n①首先计算关系表达式1的值\r\n\r\n②如果值为true就执行语句体1；如果值为false就计算关系表达式2的值\r\n\r\n③如果值为true就执行语句体2；如果值为false就计算关系表达式3的值\r\n\r\n④…\r\n\r\n⑤如果没有任何关系表达式为true，就执行语句体n+1。\r\n\r\n![1545616667104](./img/java/basics/day02-Java基础语法.img/图片5.png)\r\n\r\n示例：\r\n\r\n​\t定义一个在0~100之间的变量a, 90~100优秀，80~89良好，70~79中等，60~69及格，0~59请努力加油！\r\n\r\n~~~java\r\npublic class Demo3If {\r\n\tpublic static void main(String[] args){\r\n\t\tint score = 65;\r\n\t\tif(score >= 90 && score <= 100){\r\n\t\t\tSystem.out.println("优秀");\r\n\t\t}else if (score >= 80 && score <= 89){\r\n\t\t\tSystem.out.println("良好");\r\n\t\t}else if (score >= 70 && score <= 79){\r\n\t\t\tSystem.out.println("中等");\r\n\t\t}else if (score >= 60 && score <= 69){\r\n\t\t\tSystem.out.println("及格");\r\n\t\t}else if (score >= 0 && score <= 59){\r\n\t\t\tSystem.out.println("请努力加油");\r\n\t\t}else{\r\n\t\t\tSystem.out.println("成绩有误!");\r\n\t\t}\r\n\t}\r\n}\r\n~~~\r\n\r\n#### 3.3.4 if语句格式3案例（应用）\r\n\r\n需求：小明快要期末考试了，小明爸爸对他说，会根据他不同的考试成绩，送他不同的礼物，假如你可以控制小明的得分，请用程序实现小明到底该获得什么样的礼物，并在控制台输出。\r\n\r\n分析：\r\n\r\n​\t①小明的考试成绩未知，可以使用键盘录入的方式获取值\r\n\r\n​\t②由于奖励种类较多，属于多种判断，采用if...else...if格式实现\r\n\r\n​\t③为每种判断设置对应的条件\r\n\r\n​\t④为每种判断设置对应的奖励\r\n\r\n~~~java\r\nimport java.util.Scanner;\r\npublic class IfTest02 {\r\n\tpublic static void main(String[] args){\r\n\t\t// 1. 使用Scanner录入考试成绩\r\n\t\tScanner sc = new Scanner(System.in);\r\n\t\tSystem.out.println("请输入您的成绩:");\r\n\t\tint score = sc.nextInt();\r\n\t\t// 2. 判断成绩是否在合法范围内 0~100\r\n\t\tif(score >=0 && score <= 100){\r\n\t\t\t// 合法成绩\r\n\t\t\t// 3. 在合法的语句块中判断成绩范围符合哪一个奖励\r\n\t\t\tif(score >= 95 && score <= 100){\r\n\t\t\t\tSystem.out.println("自行车一辆");\r\n\t\t\t}else if(score >= 90 && score <= 94){\r\n\t\t\t\tSystem.out.println("游乐场一次");\r\n\t\t\t}else if(score >= 80 && score <= 89){\r\n\t\t\t\tSystem.out.println("变形金刚一个");\r\n\t\t\t}else {\r\n\t\t\t\tSystem.out.println("挨顿揍, 这座城市又多了一个伤心的人~");\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\t// 非法的话, 给出错误提示\r\n\t\t\tSystem.out.println("您的成绩输入有误!");\r\n\t\t}\r\n\t}\r\n}\r\n~~~',f='## 1. switch语句\r\n\r\n### 1.1 分支语句switch语句\r\n\r\n* 格式\r\n\r\n  ```java\r\n  switch (表达式) {\r\n  \tcase 1:\r\n  \t\t语句体1;\r\n  \t\tbreak;\r\n  \tcase 2:\r\n  \t\t语句体2;\r\n  \t\tbreak;\r\n  \t...\r\n  \tdefault:\r\n  \t\t语句体n+1;\r\n  \t\tbreak;\r\n  }\r\n  ```\r\n\r\n* 执行流程：\r\n\r\n  * 首先计算出表达式的值 \r\n  * 其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结 束。 \r\n  * 最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。 \r\n\r\n### 1.2 switch案例-减肥计划\r\n\r\n* 需求：键盘录入星期数，显示今天的减肥活动\r\n\r\n```\r\n周一：跑步  \r\n周二：游泳  \r\n周三：慢走  \r\n周四：动感单车\r\n周五：拳击  \r\n周六：爬山  \r\n周日：好好吃一顿 \r\n```\r\n\r\n* 示例代码：\r\n\r\n```java\r\npublic static void main(String[] args){\r\n\t\t// 1. 键盘录入星期数据，使用变量接收\r\n\t\tScanner sc = new Scanner(System.in);\r\n\t\tSystem.out.println("请输入");\r\n\t\tint week = sc.nextInt();\r\n\t\t// 2. 多情况判断，采用switch语句实现\r\n\t\tswitch(week){\r\n\t\t\t// 3. 在不同的case中，输出对应的减肥计划\r\n\t\t\tcase 1:\r\n\t\t\t\tSystem.out.println("跑步");\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tSystem.out.println("游泳");\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tSystem.out.println("慢走");\r\n\t\t\t\tbreak;\r\n\t\t\tcase 4:\r\n\t\t\t\tSystem.out.println("动感单车");\r\n\t\t\t\tbreak;\r\n\t\t\tcase 5:\r\n\t\t\t\tSystem.out.println("拳击");\r\n\t\t\t\tbreak;\r\n\t\t\tcase 6:\r\n\t\t\t\tSystem.out.println("爬山");\r\n\t\t\t\tbreak;\r\n\t\t\tcase 7:\r\n\t\t\t\tSystem.out.println("好好吃一顿");\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tSystem.out.println("您的输入有误");\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n### 1.3 switch语句case穿透\r\n\r\n- 概述 : 如果switch语句中,case省略了break语句, 就会开始case穿透\r\n- 需求 : 键盘录入星期数，输出工作日、休息日 (1-5)工作日，(6-7)休息日\r\n- 示例代码：\r\n\r\n```java\r\n/*\r\ncase穿透是如何产生的?\r\n\t\t\r\n\t\t如果switch语句中,case省略了break语句, 就会开始case穿透.\r\n\t\t\r\n\t\t现象：\r\n\t\t\t当开始case穿透，后续的case就不会具有匹配效果，内部的语句都会执行\r\n\t\t\t直到看见break，或者将整体switch语句执行完毕，才会结束。\r\n*/\r\npublic static void main(String[] args){\r\n\t\tScanner sc = new Scanner(System.in);\r\n\t\tSystem.out.println("请输入星期数:");\r\n\t\tint week = sc.nextInt();\r\n\t\t\r\n\t\tswitch(week){\r\n\t\t\tcase 1:\r\n\t\t\tcase 2:\r\n\t\t\tcase 3:\r\n\t\t\tcase 4:\r\n\t\t\tcase 5:\r\n\t\t\t\tSystem.out.println("工作日");\r\n\t\t\t\tbreak;\r\n\t\t\tcase 6:\r\n\t\t\tcase 7:\r\n\t\t\t\tSystem.out.println("休息日");\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tSystem.out.println("您的输入有误");\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\t\r\n}\r\n```\r\n## 2. for循环\r\n\r\n### 2.1 循环语句-for循环\r\n\r\n* 循环：\r\n\r\n  循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复 执行这个循环体时，需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形 成死循环。 \r\n\r\n* for循环格式：\r\n\r\n```java\r\nfor (初始化语句;条件判断语句;条件控制语句) {\r\n\t循环体语句;\r\n}\r\n```\r\n\r\n* 格式解释：\r\n\r\n  * 初始化语句：  用于表示循环开启时的起始状态，简单说就是循环开始的时候什么样\r\n  * 条件判断语句：用于表示循环反复执行的条件，简单说就是判断循环是否能一直执行下去\r\n  * 循环体语句：  用于表示循环反复执行的内容，简单说就是循环反复执行的事情\r\n  * 条件控制语句：用于表示循环执行中每次变化的内容，简单说就是控制循环是否能执行下去\r\n\r\n* 执行流程：\r\n\r\n  ①执行初始化语句\r\n\r\n  ②执行条件判断语句，看其结果是true还是false\r\n\r\n  ​             如果是false，循环结束\r\n\r\n  ​             如果是true，继续执行\r\n\r\n  ③执行循环体语句\r\n\r\n  ④执行条件控制语句\r\n\r\n  ⑤回到②继续\r\n\r\n### 2.2 for循环案例-输出数据1-5和5-1\r\n\r\n* 需求：在控制台输出1-5和5-1的数据 \r\n* 示例代码：\r\n\r\n```java\r\npublic class ForTest01 {\r\n    public static void main(String[] args) {\r\n\t\t//需求：输出数据1-5\r\n        for(int i=1; i<=5; i++) {\r\n\t\t\tSystem.out.println(i);\r\n\t\t}\r\n\t\tSystem.out.println("--------");\r\n\t\t//需求：输出数据5-1\r\n\t\tfor(int i=5; i>=1; i--) {\r\n\t\t\tSystem.out.println(i);\r\n\t\t}\r\n    }\r\n}\r\n```\r\n\r\n### 2.3 for循环案例-求1-5数据和\r\n\r\n* 需求：求1-5之间的数据和，并把求和结果在控制台输出 \r\n* 示例代码：\r\n\r\n```java\r\npublic class ForTest02 {\r\n    public static void main(String[] args) {\r\n\t\t//求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0\r\n\t\tint sum = 0;\r\n\t\t//从1开始到5结束的数据，使用循环结构完成\r\n\t\tfor(int i=1; i<=5; i++) {\r\n\t\t\t//将反复进行的事情写入循环结构内部\r\n             // 此处反复进行的事情是将数据 i 加到用于保存最终求和的变量 sum 中\r\n\t\t\tsum += i;\r\n\t\t\t/*\r\n\t\t\t\tsum += i;\tsum = sum + i;\r\n\t\t\t\t第一次：sum = sum + i = 0 + 1 = 1;\r\n\t\t\t\t第二次：sum = sum + i = 1 + 2 = 3;\r\n\t\t\t\t第三次：sum = sum + i = 3 + 3 = 6;\r\n\t\t\t\t第四次：sum = sum + i = 6 + 4 = 10;\r\n\t\t\t\t第五次：sum = sum + i = 10 + 5 = 15;\r\n\t\t\t*/\r\n\t\t}\r\n\t\t//当循环执行完毕时，将最终数据打印出来\r\n\t\tSystem.out.println("1-5之间的数据和是：" + sum);\r\n    }\r\n}\r\n```\r\n\r\n* 本题要点：\r\n  * 今后遇到的需求中，如果带有求和二字，请立即联想到求和变量\r\n  * 求和变量的定义位置，必须在循环外部，如果在循环内部则计算出的数据将是错误的\r\n\r\n### 2.4 for循环案例-求1-100偶数和\r\n\r\n* 需求：求1-100之间的偶数和，并把求和结果在控制台输出 }\r\n* 示例代码：\r\n\r\n```java\r\npublic class ForTest03 {\r\n    public static void main(String[] args) {\r\n\t\t//求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0\r\n\t\tint sum = 0;\r\n\t\t//对1-100的数据求和与1-5的数据求和几乎完全一样，仅仅是结束条件不同\r\n\t\tfor(int i=1; i<=100; i++) {\r\n\t\t\t//对1-100的偶数求和，需要对求和操作添加限制条件，判断是否是偶数\r\n\t\t\tif(i%2 == 0) {\r\n\t\t\t\tsum += i;\r\n\t\t\t}\r\n\t\t}\r\n\t\t//当循环执行完毕时，将最终数据打印出来\r\n\t\tSystem.out.println("1-100之间的偶数和是：" + sum);\r\n    }\r\n}\r\n```\r\n\r\n### 2.5 for循环案例-水仙花数\r\n\r\n* 需求：在控制台输出所有的“水仙花数” \r\n* 解释：什么是水仙花数？\r\n  * 水仙花数，指的是一个三位数，个位、十位、百位的数字立方和等于原数\r\n    * 例如`153  3*3*3 + 5*5*5 + 1*1*1 = 153`\r\n* 思路：\r\n  1. 获取所有的三位数，准备进行筛选，最小的三位数为100，最大的三位数为999，使用for循环获取\r\n  2. 获取每一个三位数的个位，十位，百位，做if语句判断是否是水仙花数\r\n* 示例代码\r\n\r\n```java\r\npublic class ForTest04 {\r\n    public static void main(String[] args) {\r\n\t\t//输出所有的水仙花数必然要使用到循环，遍历所有的三位数，三位数从100开始，到999结束\r\n\t\tfor(int i=100; i<1000; i++) {\r\n\t\t\t//在计算之前获取三位数中每个位上的值\r\n\t\t\tint ge = i%10;\r\n\t\t\tint shi = i/10%10;\r\n\t\t\tint bai = i/10/10%10;\r\n\t\t\t\r\n\t\t\t//判定条件是将三位数中的每个数值取出来，计算立方和后与原始数字比较是否相等\r\n\t\t\tif(ge*ge*ge + shi*shi*shi + bai*bai*bai == i) {\r\n\t\t\t\t//输出满足条件的数字就是水仙花数\r\n\t\t\t\tSystem.out.println(i);\r\n\t\t\t}\r\n\t\t}\r\n    }\r\n}\r\n```\r\n\r\n### 2.6 for循环案例-每行打印2个水仙花数(统计)\r\n\r\n* 需求：在控制台输出所有的“水仙花数”，要求每行打印2个\r\n* 示例代码：\r\n\r\n```java\r\npublic class Demo6For {\r\n\t/*\r\n\t\t需求：在控制台输出所有的“水仙花数”，要求每行打印2个\r\n\r\n\t\tSystem.out.print (打印内容);\t打印后不换行\r\n\t\tSystem.out.println(打印内容);\t打印后换行\r\n\r\n\t\t分析:\r\n\t\t\t\r\n\t\t\t1. 定义变量count，用于保存“打印过”的数量，初始值为0\r\n\t\t\t2. 在判定和打印水仙花数的过程中，拼接空格, 但不换行，并在打印后让count变量+1，记录打印过的数量\r\n\t\t\t3. 在每一次count变量+1后，判断是否到达了2的倍数，是的话，换行。\r\n\r\n\t*/\r\n\tpublic static void main(String[] args){\r\n\t\t// 1. 定义变量count，用于保存“打印过”的数量，初始值为0\r\n\t\tint count = 0;\r\n\t\tfor(int i = 100; i <= 999; i++){\r\n\t\t\tint ge = i % 10;\r\n\t\t\tint shi = i / 10 % 10;\r\n\t\t\tint bai = i / 10 / 10 % 10;\r\n\t\t\t\r\n\t\t\tif(\t(ge*ge*ge + shi*shi*shi + bai*bai*bai) == i){\r\n\t\t\t\t//  2. 在判定和打印水仙花数的过程中，拼接空格, 但不换行，并在打印后让count变量+1，记录打印过的数量\r\n\t\t\t\tSystem.out.print(i + " ");\r\n\t\t\t\tcount++;\r\n\t\t\t\t// 3. 在每一次count变量+1后，判断是否到达了2的倍数，是的话，换行\r\n\t\t\t\tif(count % 2 == 0){\r\n\t\t\t\t\tSystem.out.println();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n* 本题要点：\r\n  * 今后如果需求带有统计xxx，请先想到计数器变量\r\n  * 计数器变量定义的位置，必须在循环外部\r\n\r\n## 3. while循环\r\n\r\n### 3.1 循环语句-while循环\r\n\r\n* while循环完整格式：\r\n\r\n  ```java\r\n  初始化语句;\r\n  while (条件判断语句) {\r\n  \t循环体语句;\r\n      条件控制语句;\r\n  }\r\n  ```\r\n\r\n* while循环执行流程：\r\n\r\n  ①执行初始化语句\r\n\r\n  ②执行条件判断语句，看其结果是true还是false\r\n\r\n  ​             如果是false，循环结束\r\n\r\n  ​             如果是true，继续执行\r\n\r\n  ③执行循环体语句\r\n\r\n  ④执行条件控制语句\r\n\r\n  ⑤回到②继续\r\n\r\n* 示例代码：\r\n\r\n```java\r\npublic class WhileDemo {\r\n    public static void main(String[] args) {\r\n        //需求：在控制台输出5次"HelloWorld"\r\n\t\t//for循环实现\r\n\t\tfor(int i=1; i<=5; i++) {\r\n\t\t\tSystem.out.println("HelloWorld");\r\n\t\t}\r\n\t\tSystem.out.println("--------");\r\n\t\t//while循环实现\r\n\t\tint j = 1;\r\n\t\twhile(j<=5) {\r\n\t\t\tSystem.out.println("HelloWorld");\r\n\t\t\tj++;\r\n\t\t}\r\n    }\r\n}\r\n```\r\n\r\n### 3.2 while循环案例-珠穆朗玛峰\r\n\r\n* 需求：世界最高山峰是珠穆朗玛峰(8844.43米=8844430毫米)，假如我有一张足够大的纸，它的厚度是0.1毫米。请问，我折叠多少次，可以折成珠穆朗玛峰的高度?\r\n* 示例代码：\r\n\r\n```java\r\npublic class WhileTest {\r\n    public static void main(String[] args) {\r\n\t\t//定义一个计数器，初始值为0\r\n\t\tint count = 0;\r\n\t\t//定义纸张厚度\r\n\t\tdouble paper = 0.1;\r\n\t\t//定义珠穆朗玛峰的高度\r\n\t\tint zf = 8844430;\r\n\t\t//因为要反复折叠，所以要使用循环，但是不知道折叠多少次，这种情况下更适合使用while循环\r\n\t\t//折叠的过程中当纸张厚度大于珠峰就停止了，因此继续执行的要求是纸张厚度小于珠峰高度\r\n\t\twhile(paper <= zf) {\r\n\t\t\t//循环的执行过程中每次纸张折叠，纸张的厚度要加倍\r\n\t\t\tpaper *= 2;\r\n\t\t\t//在循环中执行累加，对应折叠了多少次\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\t//打印计数器的值\r\n\t\tSystem.out.println("需要折叠：" + count + "次");\r\n    }\r\n}\r\n```\r\n\r\n## 4. 循环细节\r\n\r\n### 4.1 循环语句-dowhile循环\r\n\r\n* 完整格式：\r\n\r\n  ```java\r\n  初始化语句;\r\n  do {\r\n  \t循环体语句;\r\n  \t条件控制语句;\r\n  }while(条件判断语句);\r\n  ```\r\n\r\n* 执行流程：\r\n\r\n  ① 执行初始化语句\r\n\r\n  ② 执行循环体语句\r\n\r\n  ③ 执行条件控制语句\r\n\r\n  ④ 执行条件判断语句，看其结果是true还是false\r\n\r\n  如果是false，循环结束\r\n\r\n  如果是true，继续执行\r\n\r\n  ⑤ 回到②继续\r\n\r\n* 示例代码：\r\n\r\n```java\r\npublic class DoWhileDemo {\r\n    public static void main(String[] args) {\r\n        //需求：在控制台输出5次"HelloWorld"\r\n\t\t//for循环实现\r\n\t\tfor(int i=1; i<=5; i++) {\r\n\t\t\tSystem.out.println("HelloWorld");\r\n\t\t}\r\n\t\tSystem.out.println("--------");\r\n\t\t//do...while循环实现\r\n\t\tint j = 1;\r\n\t\tdo {\r\n\t\t\tSystem.out.println("HelloWorld");\r\n\t\t\tj++;\r\n\t\t}while(j<=5);\r\n    }\r\n}\r\n```\r\n\r\n### 4.2 三种循环的区别\r\n\r\n* 三种循环的区别\r\n  * for循环和while循环先判断条件是否成立，然后决定是否执行循环体（先判断后执行）\r\n  * do...while循环先执行一次循环体，然后判断条件是否成立，是否继续执行循环体（先执行后判断）\r\n* for循环和while的区别\r\n  * 条件控制语句所控制的自增变量，因为归属for循环的语法结构中，在for循环结束后，就不能再次被访问到了\r\n  * 条件控制语句所控制的自增变量，对于while循环来说不归属其语法结构中，在while循环结束后，该变量还可以继续使用\r\n* 死循环（无限循环）的三种格式\r\n  1. for(;;){}\r\n  2. while(true){}\r\n  3. do {} while(true);\r\n\r\n### 4.3 死循环\r\n\r\n- 死循环格式\t\t\r\n\r\n  ```\r\n  for死循环格式 :\r\n  for(;;){\r\n  \r\n  }\r\n  \r\n  while死循环格式 :\r\n  \r\n  while(true){\r\n  \r\n  }\r\n  \r\n  do..while死循环格式 :\r\n  \r\n  do{\r\n  \r\n  }while(true);\r\n  ```\r\n\r\n- 死循环案例\r\n\r\n```java\r\n/*\r\n\t问题: 死循环有应用场景吗?\r\n\t\t\r\n\t\t\t\t例如: 键盘录入一个1-100之间的整数\r\n\t\t\t\t\r\n\t\t\t\t顾虑: 键盘录入是用户操作的, 用户就可能会出现一些误操作的现象\r\n\t\t\r\n*/\r\npublic static void main(String[] args) {\r\n    /*\r\n\t\tfor(;;){\r\n\t\t\tSystem.out.println("我停不下来了~");\r\n\t\t}\r\n\t\t*/\r\n\r\n    /*\r\n\t\twhile(true){\r\n\t\t\tSystem.out.println("我停不下来了~");\r\n\t\t}\r\n\t\t*/\r\n\r\n    do{\r\n        System.out.println("我停不下来了~");\t\r\n    }while(true);\r\n\r\n    System.out.println("看看我能被执行吗?~");\t// 无法访问的语句\r\n}\r\n}\r\n```\r\n\r\n\r\n\r\n### 4.4 跳转控制语句\r\n\r\n* 跳转控制语句（break）\r\n  * 跳出循环，结束循环\r\n* 跳转控制语句（continue）\r\n  * 跳过本次循环，继续下次循环\r\n* 注意： continue只能在循环中进行使用！\r\n\r\n```java\r\npublic class Demo1Continue {\r\n\t/*\r\n\t\tcontinue : 跳过某次循环体内容的执行\r\n\t\t\r\n\t\t注意：使用是基于条件控制, 在循环内部使用.\r\n\t\t\r\n\t\t需求: 模拟电梯上行的过程 1-24层, 4层不停.\r\n\t*/\r\n\tpublic static void main(String[] args){\r\n\t\tfor(int i = 1; i <= 24; i++){\r\n\t\t\tif(i == 4){\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tSystem.out.println(i + "层到了~");\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\n```\r\n\r\n```java\r\npublic class Demo2Break {\r\n\t/*\r\n\t\tbreak : 终止循环体内容的执行\r\n\t\t注意：使用是基于条件控制的\r\n\t\t\t\tbreak语句只能在循环和switch中进行使用.\r\n\t\t\t\t\r\n\t\t需求: 模拟20岁工作到80岁, 60岁退休.\r\n\t*/\r\n\tpublic static void main(String[] args){\r\n\t\tfor(int i = 20; i <= 80; i++){\r\n\t\t\tif(i == 60){\r\n\t\t\t\tbreak;\t\t// 结束整个循环\r\n\t\t\t}\r\n\t\t\tSystem.out.println(i + "岁正在上班");\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\n```\r\n\r\n```java\r\nimport java.util.Scanner;\r\n\r\npublic class Test {\r\n\t/*\r\n\t\t需求：程序运行后，用户可多次查询星期对应的减肥计划，直到输入0，程序结束\r\n\t\t\r\n\t\t步骤:\r\n\t\t\t\r\n\t\t\t1. 不明确用户操作几次, 使用死循环包裹业务逻辑\r\n\t\t\t2. 匹配到0的时候，使用break结束循环死循环\r\n\r\n\t*/\r\n\tpublic static void main (String[] args){\r\n\t\t\r\n\t\tlo:while(true){\r\n\t\t\tSystem.out.println("请输入您要查看的星期数:");\r\n\t\t\tSystem.out.println("(如无需继续查看,请输入0退出程序)");\r\n\t\t\t\r\n\t\t\t// 1. 键盘录入星期数据，使用变量接收\r\n\t\t\tScanner sc = new Scanner(System.in);\r\n\t\t\tint week = sc.nextInt();\r\n\t\t\t// 2. 多情况判断，采用switch语句实现\r\n\t\t\tswitch(week){\r\n\t\t\t\t// 3. 在不同的case中，输出对应的减肥计划\r\n\t\t\t\tcase 0:\r\n\t\t\t\t\tSystem.out.println("感谢您的使用");\r\n\t\t\t\t\tbreak lo;\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\tSystem.out.println("跑步");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\tSystem.out.println("游泳");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 3:\r\n\t\t\t\t\tSystem.out.println("慢走");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 4:\r\n\t\t\t\t\tSystem.out.println("动感单车");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 5:\r\n\t\t\t\t\tSystem.out.println("拳击");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 6:\r\n\t\t\t\t\tSystem.out.println("爬山");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 7:\r\n\t\t\t\t\tSystem.out.println("好好吃一顿");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tSystem.out.println("您的输入有误");\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t}\r\n}\r\n```\r\n\r\n\r\n\r\n## 5. Random\r\n\r\n### 5.1 Random产生随机数（掌握）\r\n\r\n* 概述：\r\n\r\n  * Random类似Scanner，也是Java提供好的API，内部提供了产生随机数的功能\r\n    * API后续课程详细讲解，现在可以简单理解为Java已经写好的代码\r\n\r\n* 使用步骤：\r\n\r\n  1. 导入包\r\n\r\n     import java.util.Random;\r\n\r\n  2. 创建对象\r\n\r\n     Random r = new Random();\r\n\r\n  3. 产生随机数\r\n\r\n     int num = r.nextInt(10);\r\n\r\n     解释： 10代表的是一个范围，如果括号写10，产生的随机数就是0-9，括号写20，参数的随机数则是0-19\r\n\r\n* 示例代码：\r\n\r\n```java\r\nimport java.util.Random;\r\n\r\npublic class Demo1Random {\r\n\t/*\r\n\t\tRandom : 产生随机数\r\n\t\t\r\n\t\t1. 导包\t: import java.util.Random;\r\n\t\t\t\t    导包的动作必须出现在类定义的上面\r\n\r\n\t\t2. 创建对象 : Random r = new Random();\r\n\t\t\t\t\t上面这个格式里面，r 是变量名，可以变，其他的都不允许变\r\n\r\n\t\t3. 获取随机数 : int number = r.nextInt(10);\t//获取数据的范围：[0,10) 包括0,不包括10\r\n\t\t\t\t\t上面这个格式里面，number是变量名，可以变，数字10可以变。其他的都不允许变\r\n\t\t\r\n\t\t需求: 产生随机数1-10之间的\r\n\t*/\r\n\tpublic static void main(String[] args){\r\n\t\t// 2. 创建对象\r\n\t\tRandom r = new Random();\r\n\t\t\r\n\t\tfor(int i = 1; i <= 10; i++){\r\n\t\t\t// 3. 获取随机数\r\n\t\t\tint num = r.nextInt(10) + 1;\t\t// 1-10\r\n\t\t\tSystem.out.println(num);\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t}\r\n}\r\n```\r\n\r\n### 5.3 Random练习-猜数字（应用）\r\n\r\n* 需求：\r\n\r\n  程序自动生成一个1-100之间的数字，使用程序实现猜出这个数字是多少？\r\n\r\n  当猜错的时候根据不同情况给出相应的提示\r\n\r\n  A. 如果猜的数字比真实数字大，提示你猜的数据大了\r\n\r\n  B. 如果猜的数字比真实数字小，提示你猜的数据小了\r\n\r\n  C. 如果猜的数字与真实数字相等，提示恭喜你猜中了\r\n\r\n* 示例代码：\r\n\r\n```java\r\nimport java.util.Scanner;\r\nimport java.util.Random;\r\n\r\npublic class Test {\r\n\t/*\r\n\t\t需求：程序自动生成一个1-100之间的数字，使用程序实现猜出这个数字是多少？\r\n\t\t\t当猜错的时候根据不同情况给出相应的提示\r\n\t\t\t如果猜的数字比真实数字大，提示你猜的数据大了\r\n\t\t\t如果猜的数字比真实数字小，提示你猜的数据小了\r\n\t\t\t如果猜的数字与真实数字相等，提示恭喜你猜中了\r\n\t\t\r\n\t\t1. 准备Random和Scanner对象, 分别用于产生随机数和键盘录入\r\n\t\t2. 使用Random产生一个1-100之间的数, 作为要猜的数\r\n\t\t3. 键盘录入用户猜的的数据\r\n\t\t4. 使用录入的数据(用户猜的数据)和随机数(要猜的数据)进行比较, 并给出提示\r\n\t\t\r\n\t\t5. 以上内容需要多次进行, 但无法预估用户输入几次可以猜测正确, 使用while(true)死循环包裹\r\n\t\t6. 猜对之后, break结束.\r\n\r\n\t*/\r\n\tpublic static void main(String[] args){\r\n\t\t// 1. 准备Random和Scanner对象, 分别用于产生随机数和键盘录入\r\n\t\tRandom r = new Random();\r\n\t\tScanner sc = new Scanner(System.in);\r\n\t\t// 2. 使用Random产生一个1-100之间的数, 作为要猜的数\r\n\t\tint randomNum = r.nextInt(100) + 1;\r\n\t\t\r\n\t\t// 5. 以上内容需要多次进行, 但无法预估用户输入几次可以猜测正确, 使用while(true)死循环包裹\r\n\t\twhile(true){\r\n\t\t\t// 3. 键盘录入用户猜的的数据\r\n\t\t\tSystem.out.println("请输入您猜的数据:");\r\n\t\t\tint num = sc.nextInt();\r\n\t\t\t// 4. 使用录入的数据(用户猜的数据)和随机数(要猜的数据)进行比较, 并给出提示\r\n\t\t\tif(num > randomNum){\r\n\t\t\t\tSystem.out.println("猜大了");\r\n\t\t\t}else if(num < randomNum){\r\n\t\t\t\tSystem.out.println("猜小了");\r\n\t\t\t}else{\r\n\t\t\t\t// 6. 猜对之后, break结束.\r\n\t\t\t\tSystem.out.println("恭喜,猜中了");\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println("感谢您的使用");\r\n\t\t\r\n\t}\r\n}\r\n```\r\n\r\n',x='## 第一部分 : IDEA开发工具\r\n\r\n**参见 ：IEDA的安装请参考文件夹PPT中的 04_IDEA.ppt**\r\n\r\n## 1.数组\r\n\r\n### 1.1 数组介绍\r\n\r\n​\t数组就是存储数据长度固定的容器，存储多个数据的数据类型要一致。 \r\n\r\n### 1.2 数组的定义格式\r\n\r\n#### 1.2.1 第一种格式\r\n\r\n​\t数据类型[] 数组名\r\n\r\n​\t示例：\r\n\r\n```java\r\nint[] arr;        \r\ndouble[] arr;      \r\nchar[] arr;\r\n```\r\n\r\n#### 1.2.2 第二种格式\r\n\r\n​\t数据类型 数组名[]\r\n\r\n​\t示例：\r\n\r\n```java\r\nint arr[];\r\ndouble arr[];\r\nchar arr[];\r\n```\r\n\r\n### 1.3 数组的动态初始化\r\n\r\n#### 1.3.1 什么是动态初始化\r\n\r\n​\t数组动态初始化就是只给定数组的长度，由系统给出默认初始化值\r\n\r\n#### 1.3.2 动态初始化格式\r\n\r\n```java\r\n数据类型[] 数组名 = new 数据类型[数组长度];\r\n```\r\n\r\n```java\r\nint[] arr = new int[3];\r\n```\r\n\r\n#### 1.3.3 动态初始化格式详解\r\n\r\n- 等号左边：\r\n\r\n  -  int:数组的数据类型\r\n\r\n  -  []:代表这是一个数组\r\n\r\n  -   arr:代表数组的名称\r\n\r\n- 等号右边：\r\n\r\n    -   new:为数组开辟内存空间\r\n    -   int:数组的数据类型\r\n    -   []:代表这是一个数组\r\n    -   5:代表数组的长度\r\n\r\n**代码 :** \r\n\r\n```java\r\npackage com.itheima.array;\r\n\r\npublic class Demo2Array {\r\n    /*\r\n        数组的动态初始化:\r\n                        在初始化的时候, 需要手动指定数组的长度, 系统会为数组容器分配初始值.\r\n\r\n        动态初始化格式:\r\n                        数据类型[] 数组名 = new 数据类型[数组的长度];\r\n\r\n        注意:\r\n                        打印数组变量的时候, 会打印出数组的内存地址\r\n\r\n        [I@10f87f48 :\r\n\r\n                        @ : 分隔符\r\n                        [ : 当前的空间是一个数组类型\r\n                        I : 当前数组容器中所存储的数据类型\r\n                        10f87f48 : 十六进制内存地址\r\n\r\n                                0 1 2 3 4 5 6 7 8 9 a b c d e f\r\n     */\r\n    public static void main(String[] args) {\r\n        // 数据类型[] 数组名 = new 数据类型[数组的长度];\r\n        // 通过new关键字创建了一个int类型的数组容器, 该容器可以存储5个int类型的整数, 该容器被arr数组变量所记录\r\n        int[] arr = new int[5];\r\n        // [I@10f87f48\r\n        System.out.println(arr);\r\n\r\n        byte[] bArr = new byte[3];\r\n        // [B@b4c966a\r\n        System.out.println(bArr);\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n### 1.4 数组元素访问\r\n\r\n#### 1.4.1 什么是索引\r\n\r\n​\t每一个存储到数组的元素，都会自动的拥有一个编号，从0开始。\r\n\r\n​\t这个自动编号称为数组索引(index)，可以通过数组的索引访问到数组中的元素。 \t\r\n\r\n#### 1.4.2访问数组元素格式\r\n\r\n```java\r\n数组名[索引];\r\n```\r\n\r\n#### 1.4.3示例代码\r\n\r\n```java\r\npackage com.itheima.array;\r\n\r\npublic class Demo3ArrayIndex {\r\n    /*\r\n        数组动态初始化:\r\n                初始化的时候, 手动指定数组长度, 系统会为数组容器分配初始值.\r\n\r\n        数组的元素访问格式:\r\n                数组名[索引]\r\n\r\n                索引: 数组中数据的编号方式, 编号从0开始\r\n                作用: 访问数组容器中的空间位置\r\n\r\n        注意:\r\n                数组在创建完毕后, 即使没有赋值, 也可以取出, 但取出的元素都是默认初始化值.\r\n\r\n     */\r\n    public static void main(String[] args) {\r\n        int[] arr = new int[3];         // 0 1 2\r\n        System.out.println(arr);        // 数组的内存地址  [I@10f87f48\r\n\r\n        // 数组名[索引]  访问数组容器中的空间位置\r\n        System.out.println(arr[0]);     // 0  系统自动分配的默认初始化值\r\n        System.out.println(arr[1]);\r\n        System.out.println(arr[2]);\r\n\r\n        System.out.println("--------------");\r\n\r\n        // 数组名[索引]\r\n        arr[0] = 11;\r\n        arr[1] = 22;\r\n        arr[2] = 33;\r\n\r\n        System.out.println(arr[0]);\r\n        System.out.println(arr[1]);\r\n        System.out.println(arr[2]);\r\n    }\r\n}\r\n```\r\n\r\n### 1.5 内存分配\r\n\r\n#### 1.5.1 内存概述\r\n\r\n​\t内存是计算机中的重要原件，临时存储区域，作用是运行程序。\r\n\r\n​\t我们编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的。\r\n\r\n​\t必须放进内存中才能运行，运行完毕后会清空内存。 \r\n\r\n​\tJava虚拟机要运行程序，必须要对内存进行空间的分配和管理。 \r\n\r\n#### 1.5.2 java中的内存分配\r\n\r\n- 目前我们只需要记住两个内存，分别是：栈内存和堆内存\r\n\r\n| 区域名称   | 作用                                                       |\r\n| ---------- | ---------------------------------------------------------- |\r\n| 寄存器     | 给CPU使用，和我们开发无关。                                |\r\n| 本地方法栈 | JVM在使用操作系统功能的时候使用，和我们开发无关。          |\r\n| 方法区     | 存储可以运行的class文件。                                  |\r\n| 堆内存     | 存储对象或者数组，new来创建的，都存储在堆内存。            |\r\n| 方法栈     | 方法运行时使用的内存，比如main方法运行，进入方法栈中执行。 |\r\n\r\n### 1.6 Java内存分配-一个数组内存图\r\n\r\n![1591007817165](./img/java/basics/day04-IDEA&数组.img/1591007817165.png)\r\n\r\n### 1.7 两个数组内存图\r\n\r\n![1591007925899](./img/java/basics/day04-IDEA&数组.img/1591007925899.png)\r\n\r\n### 1.8 多个数组指向相同内存图\r\n\r\n![1591007957052](./img/java/basics/day04-IDEA&数组.img/1591007957052.png)\r\n\r\n### 1.9 数组的静态初始化\r\n\r\n#### 1.9.1 什么是静态初始化\r\n\r\n​\t在创建数组时，直接将元素确定\t\r\n\r\n#### 1.9.2 静态初始化格式\r\n\r\n- 完整版格式\r\n\r\n  ```java\r\n  数据类型[] 数组名 = new 数据类型[]{元素1,元素2,...};\r\n  ```\r\n\r\n- 简化版格式\r\n\r\n  ```java\r\n  数据类型[] 数组名 = {元素1,元素2,...};\r\n  ```\r\n\r\n#### 1.9.3示例代码\r\n\r\n```java\r\npackage com.itheima.array2;\r\n\r\npublic class Demo1Array {\r\n    /*\r\n        数组静态初始化 : 初始化时指定每个数组元素的初始值，由系统决定数组长度\r\n\r\n        完整格式:\r\n                    数据类型[] 数组名 = new 数据类型[]{数据1,数据2,数据3...};\r\n        简化格式:\r\n                    数据类型[] 数组名 = {数据1,数据2,数据3...};\r\n     */\r\n    public static void main(String[] args) {\r\n        // 数据类型[] 数组名 = new 数据类型[]{数据1,数据2,数据3...};\r\n        int[] arr = new int[]{11,22,33};\r\n        System.out.println(arr[0]);\r\n        System.out.println(arr[1]);\r\n        System.out.println(arr[2]);\r\n\r\n        // 数据类型[] 数组名 = {数据1,数据2,数据3...};\r\n        int[] arr2 = {44,55,66};\r\n        System.out.println(arr2);\r\n        System.out.println(arr2[0]);\r\n        System.out.println(arr2[1]);\r\n        System.out.println(arr2[2]);\r\n\r\n    }\r\n}\r\n```\r\n\r\n### 1.10 数组操作的两个常见问题\r\n\r\n#### 1.10.1 索引越界异常\r\n\r\n- 出现原因\r\n\r\n  ```java\r\n  public class ArrayDemo {\r\n      public static void main(String[] args) {\r\n          int[] arr = new int[3];\r\n          System.out.println(arr[3]);\r\n      }\r\n  }\r\n  ```\r\n\r\n  数组长度为3，索引范围是0~2，但是我们却访问了一个3的索引。\r\n\r\n  程序运行后，将会抛出ArrayIndexOutOfBoundsException 数组越界异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。 \r\n\r\n- 解决方案\r\n\r\n  将错误的索引修改为正确的索引范围即可！\r\n\r\n#### 1.10.2 空指针异常\r\n\r\n- 出现原因\r\n\r\n  ```java\r\n  public class ArrayDemo {\r\n      public static void main(String[] args) {\r\n          int[] arr = new int[3];\r\n  \r\n          //把null赋值给数组\r\n          arr = null;\r\n          System.out.println(arr[0]);\r\n      }\r\n  }\r\n  ```\r\n\r\n  arr = null 这行代码，意味着变量arr将不会在保存数组的内存地址，也就不允许再操作数组了，因此运行的时候会抛出 NullPointerException 空指针异常。在开发中，空指针异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。\r\n\r\n- 解决方案\r\n\r\n  给数组一个真正的堆内存空间引用即可！\r\n\r\n### 1.11 数组遍历\r\n\r\n- 数组遍历：就是将数组中的每个元素分别获取出来，就是遍历。遍历也是数组操作中的基石。\r\n\r\n  ```java\r\n  public class ArrayTest01 {\r\n  \tpublic static void main(String[] args) {\r\n  \t\tint[] arr = { 1, 2, 3, 4, 5 };\r\n  \t\tSystem.out.println(arr[0]);\r\n  \t\tSystem.out.println(arr[1]);\r\n  \t\tSystem.out.println(arr[2]);\r\n  \t\tSystem.out.println(arr[3]);\r\n  \t\tSystem.out.println(arr[4]);\r\n  \t}\r\n  }\r\n  ```\r\n\r\n   以上代码是可以将数组中每个元素全部遍历出来，但是如果数组元素非常多，这种写法肯定不行，因此我们需要改造成循环的写法。数组的索引是 0 到 lenght-1 ，可以作为循环的条件出现。 \r\n\r\n  ```java\r\n  public class ArrayTest01 {\r\n      public static void main(String[] args) {\r\n          //定义数组\r\n          int[] arr = {11, 22, 33, 44, 55};\r\n  \r\n          //使用通用的遍历格式\r\n          for(int x=0; x<arr.length; x++) {\r\n              System.out.println(arr[x]);\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n### 1.12 数组获取最大值\r\n\r\n- 最大值获取：从数组的所有元素中找出最大值。\r\n\r\n- 实现思路：\r\n\r\n  - 定义变量，保存数组0索引上的元素\r\n  - 遍历数组，获取出数组中的每个元素\r\n  - 将遍历到的元素和保存数组0索引上值的变量进行比较\r\n  - 如果数组元素的值大于了变量的值，变量记录住新的值\r\n  - 数组循环遍历结束，变量保存的就是数组中的最大值 \r\n\r\n- 代码实现：\r\n\r\n  ```java\r\n  package com.itheima.test;\r\n  \r\n  import java.util.Scanner;\r\n  \r\n  public class Test2Array {\r\n      /*\r\n          需求: 从数组中查找最大值\r\n  \r\n                  int[] arr = {12,45,98,73,60};\r\n  \r\n          实现步骤:\r\n                  1. 假设数组中的第一个元素为最大值\r\n                  2. 遍历数组, 获取每一个元素, 准备进行比较\r\n                  3. 如果比较的过程中, 出现了比max更大的, 让max记录更大的值\r\n                  4. 循环结束后, 打印最大值.\r\n       */\r\n      public static void main(String[] args) {\r\n          int[] arr = {12,45,98,73,60};\r\n          // 1. 假设数组中的第一个元素为最大值\r\n          int max = arr[0];\r\n          // 2. 遍历数组, 获取每一个元素, 准备进行比较\r\n          for(int i = 1; i < arr.length; i++){\r\n              // 3. 如果比较的过程中, 出现了比max更大的, 让max记录更大的值\r\n              if(arr[i] > max){\r\n                  max = arr[i];\r\n              }\r\n          }\r\n          //  4. 循环结束后, 打印最大值.\r\n          System.out.println("max:" + max);\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n### 1.13 数组元素求和\r\n\r\n- 需求：键盘录入5个整数，存储到数组中，并对数组求和\r\n\r\n- 思路：\r\n      1.创建键盘录入对象，准备键盘录入\r\n      2.定义一个求和变量，准备记录累加后的结果\r\n      3.动态初始化一个长度为5的int数组，准备存储键盘录入的数值\r\n      4.将键盘录入的数值存储到数组中\r\n      5.遍历数组，取出每一个元素，并求和\r\n      6.输出总和\r\n\r\n- 代码实现：\r\n\r\n  ```java\r\n  package com.itheima.test;\r\n  \r\n  import java.util.Scanner;\r\n  \r\n  public class Test3Array {\r\n      /*\r\n          需求：键盘录入5个整数，存储到数组中，并对数组求和\r\n  \r\n          思路：\r\n              1.创建键盘录入对象，准备键盘录入\r\n              2.定义一个求和变量，准备记录累加后的结果\r\n              3.动态初始化一个长度为5的int数组，准备存储键盘录入的数值\r\n              4.将键盘录入的数值存储到数组中\r\n              5.遍历数组，取出每一个元素，并求和\r\n              6.输出总和\r\n       */\r\n      public static void main(String[] args) {\r\n          // 1.创建键盘录入对象，准备键盘录入\r\n          Scanner sc = new Scanner(System.in);\r\n          // 2.定义一个求和变量，准备记录累加后的结果\r\n          int sum = 0;\r\n          // 3.动态初始化一个长度为5的int数组，准备存储键盘录入的数值\r\n          int[] arr = new int[5];\r\n          // 4.将键盘录入的数值存储到数组中\r\n          for(int i = 0; i < arr.length; i++){\r\n              System.out.println("请输入第" + (i+1) + "个整数:");\r\n              //arr[i] = 10;\r\n              arr[i] = sc.nextInt();\r\n          }\r\n  \r\n          // 5.遍历数组，取出每一个元素，并求和\r\n          for (int i = 0; i < arr.length; i++) {\r\n              sum += arr[i];\r\n          }\r\n  \r\n          // 6.输出总和\r\n          System.out.println("sum:" + sum);\r\n  \r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n### 1.14 数组基本查找【应用】\r\n\r\n- 需求：\r\n              已知一个数组 arr = {19, 28, 37, 46, 50}; 键盘录入一个数据，查找该数据在数组中的索引，并在控\r\n              制台输出找到的索引值。\r\n\r\n- 思路：\r\n          1.定义一个数组，用静态初始化完成数组元素的初始化\r\n          2.键盘录入要查找的数据，用一个变量接收\r\n          3.定义一个索引变量，初始值为-1\r\n          4.遍历数组，获取到数组中的每一个元素\r\n          5.拿键盘录入的数据和数组中的每一个元素进行比较，如果值相同，就把该值对应的索引赋值给索引变量，并结束循环\r\n          6.输出索引变量\r\n\r\n- 代码实现：\r\n\r\n  ```java\r\n  public static void main(String[] args) {\r\n          // 1.定义一个数组，用静态初始化完成数组元素的初始化\r\n          int[] arr = {19, 28, 37, 46, 50};\r\n          // 2.键盘录入要查找的数据，用一个变量接收\r\n          Scanner sc = new Scanner(System.in);\r\n          System.out.println("请输入您要查找的元素:");\r\n          int num = sc.nextInt();\r\n          // 3.定义一个索引变量，初始值为-1\r\n          // 假设要查找的数据, 在数组中就是不存在的\r\n          int index = -1;\r\n          // 4.遍历数组，获取到数组中的每一个元素\r\n          for (int i = 0; i < arr.length; i++) {\r\n              // 5.拿键盘录入的数据和数组中的每一个元素进行比较，如果值相同，就把该值对应的索引赋值给索引变量，并结束循环\r\n              if(num == arr[i]){\r\n                  // 如果值相同，就把该值对应的索引赋值给索引变量，并结束循环\r\n                  index = i;\r\n                  break;\r\n              }\r\n          }\r\n          //  6.输出索引变量\r\n          System.out.println(index);\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n### 1.15 评委打分【应用】\r\n\r\n-   需求：在编程竞赛中，有6个评委为参赛的选手打分，分数为0-100的整数分。\r\n                  选手的最后得分为：去掉一个最高分和一个最低分后 的4个评委平均值 (不考虑小数部分)。\r\n\r\n- 思路：\r\n          1.定义一个数组，用动态初始化完成数组元素的初始化，长度为6\r\n          2.键盘录入评委分数\r\n          3.由于是6个评委打分，所以，接收评委分数的操作，用循环\r\n          4.求出数组最大值\r\n          5.求出数组最小值\r\n          6.求出数组总和\r\n          7.按照计算规则进行计算得到平均分\r\n          8.输出平均分\r\n\r\n- 代码实现：\r\n\r\n  ```java\r\n      public static void main(String[] args) {\r\n          // 1.定义一个数组，用动态初始化完成数组元素的初始化，长度为6\r\n          int[] arr = new int[6];\r\n          // 2.键盘录入评委分数\r\n          Scanner sc = new Scanner(System.in);\r\n          //  3.由于是6个评委打分，所以，接收评委分数的操作，用循环\r\n          for (int i = 0; i < arr.length; i++) {\r\n              System.out.println("请输入第" + (i+1) + "个评委的打分:");\r\n              int score = sc.nextInt();\r\n              if(score >= 0 && score <= 100){\r\n                  // 合法的分值\r\n                  arr[i] = score;\r\n              }else{\r\n                  // 非法的分值\r\n                  System.out.println("您的打分输入有误, 请检查是否是0-100之间的");\r\n                  i--;\r\n              }\r\n          }\r\n  \r\n          // 4.求出数组最大值\r\n          int max = arr[0];\r\n          for (int i = 1; i < arr.length; i++) {\r\n              if(max < arr[i]){\r\n                  max = arr[i];\r\n              }\r\n          }\r\n  \r\n          // 5.求出数组最小值\r\n          int min = arr[0];\r\n          for (int i = 1; i < arr.length; i++) {\r\n              if(min > arr[i]){\r\n                  min = arr[i];\r\n              }\r\n          }\r\n  \r\n          // 6.求出数组总和\r\n          int sum = 0;\r\n          for (int i = 0; i < arr.length; i++) {\r\n              sum += arr[i];\r\n          }\r\n  \r\n          // 7.按照计算规则进行计算得到平均分\r\n          int avg = (sum - max - min ) / 4;\r\n  \r\n          // 8.输出平均分\r\n          System.out.println(avg);\r\n      }\r\n  }\r\n  ```\r\n\r\n',w='## 1. 方法概述\r\n\r\n### 1.1 方法的概念\r\n\r\n​\t方法（method）是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集\r\n\r\n* 注意：\r\n  * 方法必须先创建才可以使用，该过程成为方法定义\r\n  * 方法创建后并不是直接可以运行的，需要手动使用后，才执行，该过程成为方法调用\r\n\r\n## 2. 方法的定义和调用\r\n\r\n### 2.1 无参数方法定义和调用\r\n\r\n* 定义格式：\r\n\r\n  ```java\r\n  public static void 方法名 (   ) {\r\n  \t// 方法体;\r\n  }\r\n  ```\r\n\r\n* 范例：\r\n\r\n  ```java\r\n  public static void method (    ) {\r\n  \t// 方法体;\r\n  }\r\n  ```\r\n\r\n* 调用格式：\r\n\r\n  ```java\r\n  方法名();\r\n  ```\r\n\r\n* 范例：\r\n\r\n  ```java\r\n  method();\r\n  ```\r\n\r\n* 注意：\r\n\r\n  ​\t方法必须先定义，后调用，否则程序将报错\r\n\r\n### 2.2 方法的调用过程\r\n\r\n* 总结：每个方法在被调用执行的时候，都会进入栈内存，并且拥有自己独立的内存空间，方法内部代码调用完毕之后，会从栈内存中弹栈消失。\r\n\r\n  \r\n\r\n### 2.3 方法练习-奇偶数判断\r\n\r\n* 需求：判断一个数是奇数还是偶数\r\n* 代码：\r\n\r\n```java\r\npublic class Demo1Method {\r\n    /*\r\n\r\n        带参数方法的定义格式:\r\n                public static void 方法名  ( 参数 )  { … … }\r\n                public static void 方法名  ( 数据类型 变量名 )  { … … }\r\n\r\n        带参数方法的调用格式:\r\n                方法名 ( 参数 ) ;\r\n                方法名 ( 变量名/常量值 ) ;\r\n\r\n        tips: 参数可以是一个, 也可以是多个.\r\n\r\n        需求: 判断一个数是奇数还是偶数\r\n     */\r\n    public static void main(String[] args) {\r\n        isEvenNumber(10);\r\n    }\r\n\r\n    public static void isEvenNumber(int num){\r\n        if(num % 2 == 0){\r\n            System.out.println("偶数");\r\n        }else{\r\n            System.out.println("奇数");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 3. 带参数方法的定义和调用\r\n\r\n### 3.1 带参数方法定义和调用\r\n\r\n* 定义格式：\r\n\r\n  参数：由数据类型和变量名组成 -  数据类型 变量名\r\n\r\n  参数范例：int a\r\n\r\n  ```java\r\n  public static void 方法名 (参数1) {\r\n  \t方法体;\r\n  }\r\n  \r\n  public static void 方法名 (参数1, 参数2, 参数3...) {\r\n  \t方法体;\r\n  }\r\n  ```\r\n\r\n* 范例：\r\n\r\n  ```java\r\n  public static void isEvenNumber(int number){\r\n      ...\r\n  }\r\n  public static void getMax(int num1, int num2){\r\n      ...\r\n  }\r\n  ```\r\n\r\n  * 注意：\r\n\r\n  \t\t方法定义时，参数中的数据类型与变量名都不能缺少，缺少任意一个程序将报错\r\n\r\n  \t\t方法定义时，多个参数之间使用逗号( ，)分隔\r\n\r\n* 调用格式：\r\n\r\n  ```java\r\n  方法名(参数)；\r\n  \r\n  方法名(参数1,参数2);\r\n  ```\r\n\r\n* 范例：\r\n\r\n  ```java\r\n  isEvenNumber(10);\r\n  \r\n  getMax(10,20);\r\n  ```\r\n\r\n  * 方法调用时，参数的数量与类型必须与方法定义中的设置相匹配，否则程序将报错 \r\n\r\n### 3.2 形参和实参\r\n\r\n1. 形参：方法定义中的参数\r\n\r\n​          等同于变量定义格式，例如：int number\r\n\r\n2. 实参：方法调用中的参数\r\n\r\n​          等同于使用变量或常量，例如： 10  number\r\n\r\n### 3.3 带参数方法的练习-打印n-m之间所有的奇数\r\n\r\n* 需求：设计一个方法（print） 用于打印 n 到 m 之间所有的奇数\r\n* 思路：\r\n\r\n  ​\t1：定义方法，名称为print\r\n          2：为方法添加两个int类型的形参，准备接受调用者传递过来的实参\r\n          3：方法中设计for循环，循环从n开始，到m结束\r\n          4：循环中加入if判断，是奇数，则打印\r\n          5：main方法中调用print方法，传入两个实际参数\r\n* 代码：\r\n\r\n```java\r\npackage com.itheima.method2;\r\n\r\npublic class Demo2Method {\r\n    public static void main(String[] args) {\r\n        // 5：main方法中调用print方法，传入两个实际参数\r\n        print(20,10);\r\n    }\r\n\r\n    //1：定义方法，名称为print\r\n    // 2：为方法添加两个int类型的形参，准备接受调用者传递过来的实参\r\n    public static void print(int n, int m){\r\n        System.out.println(n + "到" + m + "之间的奇数为:");\r\n        // 3：方法中设计for循环，循环从n开始，到m结束\r\n        for(int i = 20; i <= 10; i++){\r\n            // 4：循环中加入if判断，是奇数，则打印\r\n            if(i % 2 == 1){\r\n                System.out.println(i);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n## 4. 带返回值方法的定义和调用\r\n\r\n### 4.1 带返回值方法定义和调用（掌握）\r\n\r\n* 定义格式\r\n\r\n  ```java\r\n  public static 数据类型 方法名 ( 参数 ) { \r\n  \treturn 数据 ;\r\n  }\r\n  ```\r\n\r\n* 范例\r\n\r\n  ```java\r\n  public static boolean isEvenNumber( int number ) {           \r\n  \treturn true ;\r\n  }\r\n  public static int getMax( int a, int b ) {\r\n  \treturn  100 ;\r\n  }\r\n  ```\r\n\r\n  * 注意：\r\n    * 方法定义时return后面的返回值与方法定义上的数据类型要匹配，否则程序将报错\r\n\r\n* 调用格式\r\n\r\n  ```java\r\n  方法名 ( 参数 ) ;\r\n  数据类型 变量名 = 方法名 ( 参数 ) ;\r\n  ```\r\n\r\n* 范例\r\n\r\n  ```java\r\n  isEvenNumber ( 5 ) ;\r\n  boolean  flag =  isEvenNumber ( 5 ); \r\n  ```\r\n\r\n  * 注意：\r\n    * 方法的返回值通常会使用变量接收，否则该返回值将无意义\r\n\r\n### 4.2 带返回值方法的练习-求两个数的最大值(应用)\r\n\r\n* 需求：设计一个方法可以获取两个数的较大值，数据来自于参数\r\n\r\n* 思路：\r\n\r\n  1. 定义一个方法，声明两个形参接收计算的数值，求出结果并返回\r\n  2. 使用 if 语句 得出 a 和 b 之间的最大值，根据情况return具体结果\r\n  3. 在main()方法中调用定义好的方法并使用 【 变量保存 】\r\n\r\n* 代码：\r\n\r\n  ```java\r\n   /*\r\n          需求：设计一个方法可以获取两个数的较大值，数据来自于参数\r\n  \r\n          1. 定义一个方法，声明两个形参接收计算的数值，求出结果并返回\r\n          2. 使用 if 语句 得出 a 和 b 之间的最大值，根据情况return具体结果\r\n          3. 在main()方法中调用定义好的方法并使用 【 变量保存 】\r\n       */\r\n      public static void main(String[] args) {\r\n          // 3. 在main()方法中调用定义好的方法并使用 【 变量保存 】\r\n          System.out.println(getMax(10,20));  // 输出调用\r\n  \r\n          int result = getMax(10,20);\r\n          System.out.println(result);\r\n  \r\n          for(int i = 1; i <= result; i++){\r\n              System.out.println("HelloWorld");\r\n          }\r\n  \r\n      }\r\n  \r\n      // 方法可以获取两个数的较大值\r\n      public static int getMax(int a, int b){\r\n          if(a > b){\r\n              return a;\r\n          }else{\r\n              return b;\r\n          }\r\n      }\r\n  \r\n  }\r\n  \r\n  ```\r\n\r\n## 5. 方法的注意事项\r\n\r\n### 5.1 方法的通用格式（掌握）\r\n\r\n- 格式：\r\n\r\n  ```java\r\n  public static 返回值类型 方法名(参数) {\r\n     方法体; \r\n     return 数据 ;\r\n  }\r\n  ```\r\n\r\n- 解释：\r\n\r\n  - public static \t修饰符，目前先记住这个格式\r\n\r\n    返回值类型\t方法操作完毕之后返回的数据的数据类型\r\n\r\n    ​\t\t\t如果方法操作完毕，没有数据返回，这里写void，而且方法体中一般不写return\r\n\r\n     方法名\t\t调用方法时候使用的标识\r\n\r\n     参数\t\t由数据类型和变量名组成，多个参数之间用逗号隔开\r\n\r\n     方法体\t\t完成功能的代码块\r\n\r\n     return\t\t如果方法操作完毕，有数据返回，用于把数据返回给调用者\r\n\r\n- 定义方法时，要做到两个明确\r\n\r\n  - 明确返回值类型：主要是明确方法操作完毕之后是否有数据返回，如果没有，写void；如果有，写对应的数据类型\r\n  - 明确参数：主要是明确参数的类型和数量\r\n\r\n- 调用方法时的注意：\r\n\r\n  - void类型的方法，直接调用即可\r\n  - 非void类型的方法，推荐用变量接收调用\r\n\r\n\r\n\r\n### 5.2 方法的注意事项\r\n\r\n* 方法不能嵌套定义\r\n\r\n  * 示例代码：\r\n\r\n    ```java\r\n    public class MethodDemo {\r\n        public static void main(String[] args) {\r\n    \r\n        }\r\n    \r\n        public static void methodOne() {\r\n    \t\tpublic static void methodTwo() {\r\n           \t\t// 这里会引发编译错误!!!\r\n        \t}\r\n        }\r\n    }\r\n    ```\r\n\r\n* void表示无返回值，可以省略return，也可以单独的书写return，后面不加数据\r\n\r\n  * 示例代码：\r\n\r\n    ```java\r\n    public class MethodDemo {\r\n        public static void main(String[] args) {\r\n    \r\n        }\r\n        public static void methodTwo() {\r\n            //return 100; 编译错误，因为没有具体返回值类型\r\n            return;\t\r\n            //System.out.println(100); return语句后面不能跟数据或代码\r\n        }\r\n    }\r\n    ```\r\n\r\n## 6. 方法重载\r\n\r\n### 6.1 方法重载\r\n\r\n* 方法重载概念\r\n\r\n  方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载\r\n\r\n  * 多个方法在同一个类中\r\n  * 多个方法具有相同的方法名\r\n  * 多个方法的参数不相同，类型不同或者数量不同\r\n\r\n* 注意：\r\n\r\n  * 重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式\r\n  * 重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载\r\n\r\n* 正确范例：\r\n\r\n  ```java\r\n  public class MethodDemo {\r\n  \tpublic static void fn(int a) {\r\n      \t//方法体\r\n      }\r\n      public static int fn(double a) {\r\n      \t//方法体\r\n      }\r\n  }\r\n  \r\n  public class MethodDemo {\r\n  \tpublic static float fn(int a) {\r\n      \t//方法体\r\n      }\r\n      public static int fn(int a , int b) {\r\n      \t//方法体\r\n      }\r\n  }\r\n  ```\r\n\r\n* 错误范例：\r\n\r\n  ```java\r\n  public class MethodDemo {\r\n  \tpublic static void fn(int a) {\r\n      \t//方法体\r\n      }\r\n      public static int fn(int a) { \t/*错误原因：重载与返回值无关*/\r\n      \t//方法体\r\n      }\r\n  }\r\n  \r\n  public class MethodDemo01 {\r\n      public static void fn(int a) {\r\n          //方法体\r\n      }\r\n  } \r\n  public class MethodDemo02 {\r\n      public static int fn(double a) { /*错误原因：这是两个类的两个fn方法*/\r\n          //方法体\r\n      }\r\n  }\r\n  ```\r\n\r\n### 6.2 方法重载练习\r\n\r\n* 需求：使用方法重载的思想，设计比较两个整数是否相同的方法，兼容全整数类型（byte,short,int,long） \r\n\r\n* 思路：\r\n\r\n  ​\t①定义比较两个数字的是否相同的方法compare()方法，参数选择两个int型参数\r\n\r\n  ​\t②定义对应的重载方法，变更对应的参数类型，参数变更为两个long型参数\r\n\r\n  ​\t③定义所有的重载方法，两个byte类型与两个short类型参数 \r\n\r\n  ​\t④完成方法的调用，测试运行结果 \r\n\r\n* 代码：\r\n\r\n  ```java\r\n  public class MethodTest {\r\n      public static void main(String[] args) {\r\n          //调用方法\r\n          System.out.println(compare(10, 20));\r\n          System.out.println(compare((byte) 10, (byte) 20));\r\n          System.out.println(compare((short) 10, (short) 20));\r\n          System.out.println(compare(10L, 20L));\r\n      }\r\n  \r\n      //int\r\n      public static boolean compare(int a, int b) {\r\n          System.out.println("int");\r\n          return a == b;\r\n      }\r\n  \r\n      //byte\r\n      public static boolean compare(byte a, byte b) {\r\n          System.out.println("byte");\r\n          return a == b;\r\n      }\r\n  \r\n      //short\r\n      public static boolean compare(short a, short b) {\r\n          System.out.println("short");\r\n          return a == b;\r\n      }\r\n  \r\n      //long\r\n      public static boolean compare(long a, long b) {\r\n          System.out.println("long");\r\n          return a == b;\r\n      }\r\n  \r\n  }\r\n  ```\r\n\r\n## 7. 方法的参数传递\r\n\r\n### 7.1 方法参数传递基本类型（理解）\r\n\r\n* 测试代码：\r\n\r\n  ```java\r\n  package com.itheima.param;\r\n  \r\n  public class Test1 {\r\n      /*\r\n           方法参数传递为基本数据类型 :\r\n  \r\n                  传入方法中的, 是具体的数值.\r\n       */\r\n      public static void main(String[] args) {\r\n          int number = 100;\r\n          System.out.println("调用change方法前:" + number);\r\n          change(number);\r\n          System.out.println("调用change方法后:" + number);\r\n      }\r\n  \r\n      public static void change(int number) {\r\n          number = 200;\r\n      }\r\n  }\r\n  \r\n  \r\n  ```\r\n\r\n* 结论：\r\n\r\n  * 基本数据类型的参数，形式参数的改变，不影响实际参数 \r\n\r\n* 结论依据：\r\n\r\n  * 每个方法在栈内存中，都会有独立的栈空间，方法运行结束后就会弹栈消失\r\n\r\n\r\n### 7.2 方法参数传递引用类型\r\n\r\n* 测试代码：\r\n\r\n  ```java\r\n  package com.itheima.param;\r\n  \r\n  public class Test2 {\r\n      /*\r\n           方法参数传递为引用数据类型 :\r\n  \r\n                  传入方法中的, 是内存地址.\r\n       */\r\n      public static void main(String[] args) {\r\n          int[] arr = {10, 20, 30};\r\n          System.out.println("调用change方法前:" + arr[1]);\r\n          change(arr);\r\n          System.out.println("调用change方法后:" + arr[1]);\r\n      }\r\n  \r\n      public static void change(int[] arr) {\r\n          arr[1] = 200;\r\n      }\r\n  }\r\n  ```\r\n\r\n* 结论：\r\n\r\n  * 对于引用类型的参数，形式参数的改变，影响实际参数的值 \r\n\r\n* 结论依据：\r\n\r\n  * 引用数据类型的传参，传入的是地址值，内存中会造成两个引用指向同一个内存的效果，所以即使方法弹栈，堆内存中的数据也已经是改变后的结果 \r\n\r\n\r\n### 7.3 数组遍历\r\n\r\n* 需求：设计一个方法用于数组遍历，要求遍历的结果是在一行上的。例如：[11, 22, 33, 44, 55] \r\n\r\n* 思路：\r\n\r\n  * 因为要求结果在一行上输出，所以这里需要在学习一个新的输出语句System.out.print(“内容”);\r\n\r\n    System.out.println(“内容”); 输出内容并换行\r\n\r\n    System.out.print(“内容”); 输出内容不换行\r\n\r\n    System.out.println(); 起到换行的作用\r\n\r\n  * 定义一个数组，用静态初始化完成数组元素初始化\r\n\r\n  * 定义一个方法，用数组遍历通用格式对数组进行遍历\r\n\r\n  * 用新的输出语句修改遍历操作\r\n\r\n  * 调用遍历方法\r\n\r\n* 代码：\r\n\r\n  ```java\r\n  package com.itheima.test;\r\n  \r\n  public class Test1 {\r\n      /*\r\n          需求：设计一个方法用于数组遍历，要求遍历的结果是在一行上的。例如：[11, 22, 33, 44, 55]\r\n          思路：\r\n              1.定义一个数组，用静态初始化完成数组元素初始化\r\n              2.定义一个方法，对数组进行遍历\r\n              3.遍历打印的时候，数据不换行\r\n              4.调用遍历方法\r\n       */\r\n      public static void main(String[] args) {\r\n          // 1.定义一个数组，用静态初始化完成数组元素初始化\r\n          int[] arr = {11, 22, 33, 44, 55};\r\n          // 4.调用遍历方法\r\n          printArray(arr);\r\n  \r\n          System.out.println("另外一段代码逻辑 ");\r\n      }\r\n  \r\n      /*\r\n          2.定义一个方法，对数组进行遍历\r\n  \r\n          1, 参数           int[] arr\r\n          2, 返回值类型      void\r\n       */\r\n      public static void printArray(int[] arr){\r\n  \r\n          System.out.print("[");\r\n  \r\n          for (int i = 0; i < arr.length; i++) {\r\n  \r\n              if(i == arr.length -1){\r\n                  // 如果满足条件, 说明是最后一个元素, 最后一个元素, 特殊处理\r\n                  System.out.println(arr[i] + "]");\r\n              }else{\r\n                  // 3.遍历打印的时候，数据不换行\r\n                  System.out.print(arr[i] + ", ");\r\n              }\r\n  \r\n  \r\n          }\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n### 7.4 数组最大值\r\n\r\n* 需求：设计一个方法用于获取数组中元素的最大值 \r\n\r\n* 思路：\r\n\r\n  * ①定义一个数组，用静态初始化完成数组元素初始化\r\n  * ②定义一个方法，用来获取数组中的最大值，最值的认知和讲解我们在数组中已经讲解过了\r\n  * ③调用获取最大值方法，用变量接收返回结果\r\n  * ④把结果输出在控制台\r\n\r\n* 代码：\r\n\r\n  ```java\r\n  package com.itheima.test;\r\n  \r\n  public class Test2 {\r\n      /*\r\n          需求：设计一个方法用于获取数组中元素的最大值\r\n  \r\n          思路：\r\n              1.定义一个数组，用静态初始化完成数组元素初始化\r\n              2.定义一个方法，用来获取数组中的最大值\r\n              3.调用获取最大值方法，用变量接收返回结果\r\n              4.把结果输出在控制台\r\n       */\r\n      public static void main(String[] args) {\r\n          // 1.定义一个数组，用静态初始化完成数组元素初始化\r\n          int[] arr = {11, 55, 22, 44, 33};\r\n          // 3.调用获取最大值方法，用变量接收返回结果\r\n          int max = getMax(arr);\r\n          //  4.把结果输出在控制台\r\n          System.out.println(max);\r\n      }\r\n  \r\n      /*\r\n          2.定义一个方法，用来获取数组中的最大值\r\n  \r\n          1, 参数       int[] arr\r\n          2, 返回值类型  int\r\n       */\r\n      public static int getMax(int[] arr){\r\n          int max = arr[0];\r\n          for (int i = 1; i < arr.length; i++) {\r\n              if(max < arr[i]){\r\n                  max = arr[i];\r\n              }\r\n          }\r\n          return max;\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n\r\n\r\n### 7.5 方法同时获取数组最大值和最小值\r\n\r\n- 需求：设计一个方法，该方法能够同时获取数组的最大值，和最小值\r\n\r\n- 注意: return语句, 只能带回一个结果.\r\n\r\n- 代码：\r\n\r\n  ```java\r\n  public class Test3 {\r\n      /*\r\n          需求：设计一个方法，该方法能够同时获取数组的最大值，和最小值\r\n  \r\n          注意: return语句, 只能带回一个结果.\r\n       */\r\n      public static void main(String[] args) {\r\n  \r\n          int[] arr = {11,55,33,22,44};\r\n  \r\n          int[] maxAndMin = getMaxAndMin(arr);\r\n  \r\n          System.out.println(maxAndMin[0]);\r\n          System.out.println(maxAndMin[1]);\r\n  \r\n      }\r\n  \r\n      public static int[] getMaxAndMin(int[] arr){\r\n          int max = arr[0];\r\n          for (int i = 1; i < arr.length; i++) {\r\n              if(max < arr[i]){\r\n                  max = arr[i];\r\n              }\r\n          }\r\n  \r\n          int min = arr[0];\r\n          for (int i = 1; i < arr.length; i++) {\r\n              if(min > arr[i]){\r\n                  min = arr[i];\r\n              }\r\n          }\r\n  \r\n          int[] maxAndMin = {min, max};\r\n  \r\n          return maxAndMin;\r\n      }\r\n  }\r\n  \r\n  ```',j='## 1.Debug模式\r\n\r\n### 1.1 什么是Debug模式\r\n\r\n是供程序员使用的程序调试工具，它可以用于查看程序的执行流程，也可以用于追踪程序执行过程来调试程序。\r\n\r\n### 1.2 Debug介绍与操作流程\r\n\r\n- 如何加断点\r\n\r\n  - 选择要设置断点的代码行，在行号的区域后面单击鼠标左键即可\r\n\r\n- 如何运行加了断点的程序\r\n\r\n  - 在代码区域右键Debug执行\r\n\r\n- 看哪里\r\n\r\n  - 看Debugger窗口\r\n\r\n  - 看Console窗口\r\n\r\n- 点哪里\r\n\r\n  - 点Step Into (F7)这个箭头，也可以直接按F7\r\n\r\n- 如何删除断点\r\n\r\n  - 选择要删除的断点，单击鼠标左键即可\r\n\r\n  - 如果是多个断点，可以每一个再点击一次。也可以一次性全部删除\r\n\r\n\r\n## 2. 进制的介绍与书写格式\r\n\r\n### 2.1 进制的介绍与书写格式\r\n\r\n代码 : \r\n\r\n```java\r\npublic class Demo1 {\r\n    /*\r\n        十进制：Java中，数值默认都是10进制，不需要加任何修饰。\r\n        二进制：数值前面以0b开头，b大小写都可以。\r\n        八进制：数值前面以0开头。\r\n        十六进制：数值前面以0x开头，x大小写都可以。\r\n\r\n        注意: 书写的时候, 虽然加入了进制的标识, 但打印在控制台展示的都是十进制数据.\r\n     */\r\n    public static void main(String[] args) {\r\n        System.out.println(10);\r\n        System.out.println("二进制数据0b10的十进制表示为:" + 0b10);\r\n        System.out.println("八进制数据010的十进制表示为:" + 010);\r\n        System.out.println("十六进制数据0x10的十进制表示为:" + 0x10);\r\n    }\r\n}\r\n```\r\n\r\n### 2.2 任意进制到十进制的转换\r\n\r\n![1590937009286](./img/java/basics/day06-Debug&基础练习.img/1590937009286.png)\r\n\r\n![1590937024104](./img/java/basics/day06-Debug&基础练习.img/1590937024104.png) \r\n\r\n\r\n\r\n\r\n\r\n### 2.3 进制转换-十进制到任意进制转换\r\n\r\n​\t**2.3.1 : 十进制到二进制的转换**\r\n\r\n​\t公式：除基取余使用源数据，不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着拼起来即可。\r\n\r\n​\t需求：将十进制数字11，转换为2进制。\r\n\r\n​\t实现方式：源数据为11，使用11不断的除以基数，也就是2，直到商为0。\r\n\r\n![1590936221838](./img/java/basics/day06-Debug&基础练习.img/1590936221838.png)\r\n\r\n​\t**2.3.2 : 十进制到十六进制的转换**\r\n\r\n​\t公式：除基取余使用源数据，不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着拼起来即可。\r\n\r\n​\t需求：将十进制数字60，转换为16进制。\r\n\r\n​\t实现方式：源数据为60，使用60不断的除以基数，也就是16，直到商为0。\r\n\r\n![1590936342865](./img/java/basics/day06-Debug&基础练习.img/1590936342865.png)\r\n\r\n​\t结论：十进制到任意进制的转换\r\n\r\n​\t公式：除基取余使用源数据，不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着\t拼起来即可\r\n\r\n### 2.4  快速进制转换法\r\n\r\n​\t8421码：\r\n\r\n​\t8421码又称BCD码，是BCD代码中最常用的一种BCD： (Binary-Coded Decimal‎) 二进制码十进制数在这种编码方式中，每一位二进制值的1都是代表一个固定数值，把每一位的1代表的十进制数加起来得到的结果就是它所代表的十进制数。\r\n\r\n​\t![1590936493344](./img/java/basics/day06-Debug&基础练习.img/1590936493344.png)\r\n\r\n\r\n\r\n![1590936529957](./img/java/basics/day06-Debug&基础练习.img/1590936529957.png)\r\n\r\n![1590936548060](./img/java/basics/day06-Debug&基础练习.img/1590936548060.png)\r\n\r\n### 2.5  原码反码补码\r\n\r\n前言 : 计算机中的数据，都是以二进制补码的形式在运算，而补码则是通过反码和原码推算出来的\r\n\r\n**原码 **:（可直观看出数据大小）\r\n\r\n就是二进制定点表示法，即最高位为符号位，【0】表示正，【1】表示负，其余位表示数值的大小。\r\n\r\n通过一个字节表示+7和-7，代码：byte b1 = 7;   byte b2 = -7;一个字节等于8个比特位，也就是8个二进制位\t\r\n\r\n0(符号位)\t0000111 \t\r\n\r\n1(符号位)\t0000111\r\n\r\n**反码 :** 正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。\r\n\r\n**补码 :** （数据以该状态进行运算）正数的补码与其原码相同；负数的补码是在其反码的末位加1。\r\n\r\n\r\n\r\n![1590936726746](./img/java/basics/day06-Debug&基础练习.img/1590936726746.png)\r\n\r\n![1590936745245](./img/java/basics/day06-Debug&基础练习.img/1590936745245.png)\r\n\r\n\r\n\r\n### 2.6 位运算-基本位运算符\r\n\r\n```java\r\npackage com.itheima.demo;\r\n\r\npublic class Demo2 {\r\n    /*\r\n        位运算:\r\n\r\n            位运算符指的是二进制位的运算，先将十进制数转成二进制后再进行运算。\r\n            在二进制位运算中，1表示true，0表示false。\r\n\r\n             & 位与 : 遇false则false, 遇0则0\r\n\r\n                        00000000 00000000 00000000 00000110     // 6的二进制\r\n                     &  00000000 00000000 00000000 00000010     // 2的二进制\r\n                    -----------------------------------------\r\n                        00000000 00000000 00000000 00000010     // 结果: 2\r\n\r\n             | 位或 : 遇true则true, 遇1则1\r\n\r\n             ^ 位异或 : 相同为false, 不同为true\r\n\r\n             ~ 取反 : 全部取反, 0变1, 1变0  (也包括符号位)\r\n\r\n                    00000000 00000000 00000000 00000110         // 6的二进制补码\r\n                  ~ 11111111 11111111 11111111 11111001\r\n\r\n                  -                                   1         // -1求反码\r\n                   ------------------------------------\r\n                    11111111 11111111 11111111 11111000         // 反码推原码\r\n\r\n                    10000000 00000000 00000000 00000111         // -7\r\n     */\r\n    public static void main(String[] args) {\r\n        System.out.println(6 & 2);\r\n        System.out.println(~6);\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n### 2.7 位运算-位移运算符\r\n\r\n**位运算概述 :**  位运算符指的是二进制位的运算，先将十进制数转成二进制后再进行运算。在二进制位运算中，1表示true，0表示false。\r\n\r\n**位运算符介绍 :** ![1590937235620](./img/java/basics/day06-Debug&基础练习.img/1590937235620.png)\r\n\r\n**代码 :** \r\n\r\n```java\r\npackage com.itheima.demo;\r\n\r\npublic class Demo3 {\r\n    /*\r\n       位移运算符:\r\n\r\n               << 有符号左移运算，二进制位向左移动, 左边符号位丢弃, 右边补齐0\r\n                        运算规律: 向左移动几位, 就是乘以2的几次幂\r\n\r\n                                12 << 2\r\n\r\n                                (0)0000000 00000000 00000000 000011000  // 12的二进制\r\n\r\n       -----------------------------------------------------------------------------\r\n               >> 有符号右移运算，二进制位向右移动, 使用符号位进行补位\r\n                        运算规律: 向右移动几位, 就是除以2的几次幂\r\n\r\n                                000000000 00000000 00000000 0000001(1)  // 3的二进制\r\n\r\n       -----------------------------------------------------------------------------\r\n\r\n                >>> 无符号右移运算符,  无论符号位是0还是1，都补0\r\n\r\n                                010000000 00000000 00000000 00000110  // -6的二进制\r\n\r\n     */\r\n    public static void main(String[] args) {\r\n        System.out.println(12 << 1);  // 24\r\n        System.out.println(12 << 2);  // 48\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n```java\r\npackage com.itheima.demo;\r\n\r\npublic class Demo4 {\r\n    /*\r\n        ^ 运算符的特点\r\n\r\n                一个数, 被另外一个数, 异或两次, 该数本身不变\r\n     */\r\n    public static void main(String[] args) {\r\n        System.out.println(10 ^ 5 ^ 10);\r\n    }\r\n}\r\n\r\n```\r\n\r\n## 3.基础练习\r\n\r\n### 3.1 数据交换\r\n\r\n**案例需求**\r\n\r\n​\t已知两个整数变量a = 10，b = 20，使用程序实现这两个变量的数据交换\r\n        最终输出a = 20，b = 10;\r\n\r\n**代码实现**\r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\npublic class Test1 {\r\n    /*\r\n        需求：已知两个整数变量a = 10，b = 20，使用程序实现这两个变量的数据交换\r\n        最终输出a = 20，b = 10;\r\n\r\n\r\n        思路：\r\n        1. 定义一个三方变量temp，将a原本记录的值，交给temp记录 （a的值，不会丢了）\r\n        2. 使用 a 变量记录 b 的值，（第一步交换完毕，b的值也丢不了了）\r\n        3. 使用 b 变量记录 temp的值，也就是a原本的值 （交换完毕）\r\n        4. 输出 a 和 b 变量即可\r\n     */\r\n    /*\r\n        动态初始化格式：\r\n\r\n            数据类型[][] 变量名 = new 数据类型[m][n];\r\n            m表示这个二维数组，可以存放多少个一维数组\r\n            n表示每一个一维数组，可以存放多少个元素\r\n     */\r\n    public static void main(String[] args) {\r\n        int a = 10;\r\n        int b = 20;\r\n\r\n        // 将a原本记录的值，交给temp记录 （a的值，不会丢了）\r\n        int temp = a;\r\n        // 用 a 变量记录 b 的值，（第一步交换完毕，b的值也丢不了了）\r\n        a = b;\r\n        // 使用 b 变量记录 temp的值，也就是a原本的值 （交换完毕）\r\n        b = temp;\r\n\r\n        // 输出 a 和 b 变量即可\r\n        System.out.println("a=" + a);\r\n        System.out.println("b=" + b);\r\n    }\r\n}\r\n```\r\n\r\n### 3.2 数组反转【应用】\r\n\r\n**案例需求 :** \r\n\r\n​\t已知一个数组 arr = {19, 28, 37, 46, 50}; 用程序实现把数组中的元素值交换，\r\n\r\n​\t交换后的数组 arr = {50, 46, 37, 28, 19}; 并在控制台输出交换后的数组元素\r\n\r\n**实现步骤 :** \r\n\r\n \t1. 定义两个变量, start和end来表示开始和结束的指针.          \r\n\r\n2. 确定交换条件, start < end 允许交换          \r\n3. 循环中编写交换逻辑代码         \r\n4. 每一次交换完成, 改变两个指针所指向的索引 start++, end--          \r\n5. 循环结束后, 遍历数组并打印, 查看反转后的数组\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\npublic class Test2 {\r\n    /*\r\n        需求：已知一个数组 arr = {19, 28, 37, 46, 50}; 用程序实现把数组中的元素值交换，\r\n          交换后的数组 arr = {50, 46, 37, 28, 19}; 并在控制台输出交换后的数组元素。\r\n\r\n        步骤:\r\n              1. 定义两个变量, start和end来表示开始和结束的指针.\r\n              2. 确定交换条件, start < end 允许交换\r\n              3. 循环中编写交换逻辑代码\r\n              4. 每一次交换完成, 改变两个指针所指向的索引 start++, end--\r\n              5. 循环结束后, 遍历数组并打印, 查看反转后的数组\r\n     */\r\n    public static void main(String[] args) {\r\n        int[] arr = {19, 28, 37, 46, 50};\r\n        //  1. 定义两个变量, start和end来表示开始和结束的指针.\r\n        int start = 0;\r\n        int end = arr.length -1;\r\n        //  2. 确定交换条件, start < end 允许交换\r\n        // 4. 每一次交换完成, 改变两个指针所指向的索引 start++, end--\r\n        // for(int start = 0, end = arr.length -1; start < end; start++, end--)\r\n        for( ; start < end; start++, end--){\r\n            // 3. 循环中编写交换逻辑代码\r\n            int temp = arr[start];\r\n            arr[start] = arr[end];\r\n            arr[end] = temp;\r\n        }\r\n\r\n        for (int i = 0; i < arr.length; i++) {\r\n            System.out.println(arr[i]);\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 3.3 二维数组概述\r\n\r\n​\t**概述 :**  二维数组也是一种容器，不同于一维数组，该容器存储的都是一维数组容器\r\n\r\n### 3.4 二维数组动态初始化\r\n\r\n```java\r\n动态初始化格式：\r\n\r\n数据类型[][] 变量名 = new 数据类型[m][n];\r\nm表示这个二维数组，可以存放多少个一维数组\r\nn表示每一个一维数组，可以存放多少个元素\r\n```\r\n\r\n```java\r\npackage com.itheima.demo;\r\n\r\npublic class Demo1Array {\r\n    /*\r\n        动态初始化格式：\r\n\r\n            数据类型[][] 变量名 = new 数据类型[m][n];\r\n            m表示这个二维数组，可以存放多少个一维数组\r\n            n表示每一个一维数组，可以存放多少个元素\r\n     */\r\n    public static void main(String[] args) {\r\n        // 数据类型[][] 变量名 = new 数据类型[m][n];\r\n        int[][] arr = new int[3][3];\r\n        /*\r\n            [[I@10f87f48\r\n\r\n            @ : 分隔符\r\n            10f87f48 : 十六进制内存地址\r\n            I : 数组中存储的数据类型\r\n            [[ : 几个中括号就代表的是几维数组\r\n         */\r\n        System.out.println(arr);\r\n\r\n        /*\r\n            二维数组存储一维数组的时候, 存储的是一维数组的内存地址\r\n         */\r\n        System.out.println(arr[0]);\r\n        System.out.println(arr[1]);\r\n        System.out.println(arr[2]);\r\n\r\n        System.out.println(arr[0][0]);\r\n        System.out.println(arr[1][1]);\r\n        System.out.println(arr[2][2]);\r\n\r\n        // 向二维数组中存储元素\r\n        arr[0][0] = 11;\r\n        arr[0][1] = 22;\r\n        arr[0][2] = 33;\r\n\r\n        arr[1][0] = 11;\r\n        arr[1][1] = 22;\r\n        arr[1][2] = 33;\r\n\r\n        arr[2][0] = 11;\r\n        arr[2][1] = 22;\r\n        arr[2][2] = 33;\r\n\r\n        // 从二维数组中取出元素并打印\r\n        System.out.println(arr[0][0]);\r\n        System.out.println(arr[0][1]);\r\n        System.out.println(arr[0][2]);\r\n        System.out.println(arr[1][0]);\r\n        System.out.println(arr[1][1]);\r\n        System.out.println(arr[1][2]);\r\n        System.out.println(arr[2][0]);\r\n        System.out.println(arr[2][1]);\r\n        System.out.println(arr[2][2]);\r\n    }\r\n}\r\n```\r\n\r\n### 3.5  二维数组访问元素的细节问题\r\n\r\n问题 :  二维数组中存储的是一维数组, 那能不能存入 [提前创建好的一维数组] 呢 ?\r\n\r\n答 : 可以的\r\n\r\n#### 代码实现\r\n\r\n```java\r\npackage com.itheima.demo;\r\n\r\npublic class Demo2Array {\r\n    /*\r\n        问题: 二维数组中存储的是一维数组, 那能不能存入 [提前创建好的一维数组] 呢 ?\r\n        答 : 可以的\r\n     */\r\n    public static void main(String[] args) {\r\n        int[] arr1 = {11,22,33};\r\n        int[] arr2 = {44,55,66};\r\n        int[] arr3 = {77,88,99,100};\r\n\r\n        int[][] arr = new int[3][3];\r\n\r\n        arr[2][3] = 100;\r\n\r\n        arr[0] = arr1;\r\n        arr[1] = arr2;\r\n        arr[2] = arr3;\r\n\r\n        System.out.println(arr[1][2]);\r\n        System.out.println(arr[2][3]);\r\n    }\r\n}\r\n```\r\n\r\n### 3.6 二维数组静态初始化\r\n\r\n \t**完整格式 :** 数据类型[][] 变量名 = new 数据类型[][]{ {元素1, 元素2...} , {元素1, 元素2...} \r\n\r\n \t**简化格式 :**  数据类型[][] 变量名 = { {元素1, 元素2...} , {元素1, 元素2...} ...};\r\n\r\n**代码实现 : **\r\n\r\n```java\r\npackage com.itheima.demo;\r\n\r\npublic class Demo3Array {\r\n    /*\r\n        完整格式：数据类型[][] 变量名 = new 数据类型[][]{ {元素1, 元素2...} , {元素1, 元素2...} ...};\r\n\r\n        简化格式: 数据类型[][] 变量名 = { {元素1, 元素2...} , {元素1, 元素2...} ...};\r\n     */\r\n    public static void main(String[] args) {\r\n        int[] arr1 = {11,22,33};\r\n        int[] arr2 = {44,55,66};\r\n\r\n        int[][] arr = {{11,22,33}, {44,55,66}};\r\n        System.out.println(arr[0][2]);\r\n\r\n        int[][] array = {arr1,arr2};\r\n        System.out.println(array[0][2]);\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 3.7 二维数组遍历\r\n\r\n**需求 :**   \r\n\r\n​\t已知一个二维数组 arr = {{11, 22, 33}, {33, 44, 55}};\r\n\r\n​\t遍历该数组，取出所有元素并打印\r\n\r\n**步骤 :** \r\n\r\n \t1. 遍历二维数组，取出里面每一个一维数组\r\n \t2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\npublic class Test1 {\r\n    /*\r\n        需求:\r\n\r\n            已知一个二维数组 arr = {{11, 22, 33}, {33, 44, 55}};\r\n            遍历该数组，取出所有元素并打印\r\n\r\n        步骤:\r\n            1. 遍历二维数组，取出里面每一个一维数组\r\n            2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素\r\n     */\r\n    public static void main(String[] args) {\r\n        int[][] arr = {{11, 22, 33}, {33, 44, 55}};\r\n\r\n        // 1. 遍历二维数组，取出里面每一个一维数组\r\n        for (int i = 0; i < arr.length; i++) {\r\n            //System.out.println(arr[i]);\r\n            // 2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素\r\n            //int[] temp = arr[i];\r\n            for (int j = 0; j < arr[i].length; j++) {\r\n                System.out.println(arr[i][j]);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 3.8 二维数组求和\r\n\r\n**需求 :**\r\n\r\n \t某公司季度和月份统计的数据如下：单位(万元)\r\n\t第一季度：22,66,44\r\n\t第二季度：77,33,88\r\n\t第三季度：25,45,65\r\n\t第四季度：11,66,99\r\n\r\n **步骤 :**\t\r\n\r\n1. 定义求和变量，准备记录最终累加结果\r\n2. 使用二维数组来存储数据，每个季度是一个一维数组，再将4个一维数组装起来\r\n3. 遍历二维数组，获取所有元素，累加求和\r\n4. 输出最终结果\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\npublic class Test2 {\r\n    /*\r\n        需求:\r\n            某公司季度和月份统计的数据如下：单位(万元)\r\n            第一季度：22,66,44\r\n            第二季度：77,33,88\r\n            第三季度：25,45,65\r\n            第四季度：11,66,99\r\n\r\n        步骤:\r\n            1. 定义求和变量，准备记录最终累加结果\r\n            2. 使用二维数组来存储数据，每个季度是一个一维数组，再将4个一维数组装起来\r\n            3. 遍历二维数组，获取所有元素，累加求和\r\n            4. 输出最终结果\r\n     */\r\n    public static void main(String[] args) {\r\n        // 1. 定义求和变量，准备记录最终累加结果\r\n        int sum = 0;\r\n        // 2. 使用二维数组来存储数据，每个季度是一个一维数组，再将4个一维数组装起来\r\n        int[][] arr = { {22,66,44} , {77,33,88} , {25,45,65} , {11,66,99}};\r\n        // 3. 遍历二维数组，获取所有元素，累加求和\r\n        for (int i = 0; i < arr.length; i++) {\r\n            for(int j = 0; j < arr[i].length; j++){\r\n                sum += arr[i][j];\r\n            }\r\n        }\r\n        // 4. 输出最终结果\r\n        System.out.println(sum);\r\n    }\r\n}\r\n```\r\n',C={data:function(){return{MainComponent1:h,MainComponent2:y,MainComponent3:f,MainComponent4:x,MainComponent5:w,MainComponent6:j}}},T=C,E=Object(d["a"])(T,v,b,!1,null,"637c6057",null),I=E.exports,D=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},R=[],M='\x3c!--\r\n * @Date           : 2021-04-27 00:23:17\r\n * @FilePath       : /jinnian-space/src/pages/java/module/basics/md/day07-面向对象.md\r\n * @Description    : \r\n--\x3e\r\n## 1. 类和对象\r\n\r\n**面向对象和面向过程的思想对比 : **\r\n\r\n​\t**面向过程 ：**是一种以过程为中心的编程思想，实现功能的每一步，都是自己实现的\r\n\r\n​\t**面向对象 ：**是一种以对象为中心的编程思想，通过指挥对象实现具体的功能\r\n\r\n### 1.1 类和对象的关系\r\n\r\n客观存在的事物皆为对象 ，所以我们也常常说万物皆对象。\r\n\r\n* 类\r\n  * 类的理解\r\n    * 类是对现实生活中一类具有共同属性和行为的事物的抽象\r\n    * 类是对象的数据类型，类是具有相同属性和行为的一组对象的集合\r\n    * 简单理解：类就是对现实事物的一种描述\r\n  * 类的组成\r\n    * 属性：指事物的特征，例如：手机事物（品牌，价格，尺寸）\r\n    * 行为：指事物能执行的操作，例如：手机事物（打电话，发短信）\r\n* 类和对象的关系\r\n  * 类：类是对现实生活中一类具有共同属性和行为的事物的抽象\r\n  * 对象：是能够看得到摸的着的真实存在的实体\r\n  * 简单理解：**类是对事物的一种描述，对象则为具体存在的事物**\r\n\r\n### 1.2 类的定义【应用】\r\n\r\n类的组成是由属性和行为两部分组成\r\n\r\n* **属性：**在类中通过成员变量来体现（类中方法外的变量）\r\n* **行为：**在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可）\r\n\r\n**类的定义步骤：**\r\n\r\n​\t① 定义类\r\n\r\n​\t② 编写类的成员变量\r\n\r\n​\t③ 编写类的成员方法\r\n\r\n```java\r\npublic class Student {\r\n    // 属性 : 姓名, 年龄\r\n    // 成员变量: 跟之前定义变量的格式一样, 只不过位置发生了改变, 类中方法外\r\n    String name;\r\n    int age;\r\n\r\n    // 行为 : 学习\r\n    // 成员方法: 跟之前定义方法的格式一样, 只不过去掉了static关键字.\r\n    public void study(){\r\n        System.out.println("学习");\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 1.3 对象的创建和使用\r\n\r\n* **创建对象的格式：**\r\n  * 类名 对象名 = new 类名();\r\n* **调用成员的格式：**\r\n  * 对象名.成员变量\r\n  * 对象名.成员方法();\r\n* **示例代码 : **\r\n\r\n```java\r\npackage com.itheima.object1;\r\n\r\npublic class TestStudent {\r\n    /*\r\n        创建对象的格式:\r\n                类名 对象名 = new 类名();\r\n        调用成员变量的格式:\r\n                对象名.变量名\r\n        调用成员方法的格式:\r\n                对象名.方法名();\r\n     */\r\n    public static void main(String[] args) {\r\n        // 类名 对象名 = new 类名();\r\n        Student stu = new Student();\r\n        // 对象名.变量名\r\n        // 默认初始化值\r\n        System.out.println(stu.name);  // null\r\n        System.out.println(stu.age);   // 0\r\n\r\n        stu.name = "张三";\r\n        stu.age = 23;\r\n\r\n        System.out.println(stu.name);  // 张三\r\n        System.out.println(stu.age);   // 23\r\n\r\n        // 对象名.方法名();\r\n        stu.study();\r\n        // com.itheima.object1.Student@b4c966a\r\n        // 全类名(包名 + 类名)\r\n        System.out.println(stu);\r\n    }\r\n}\r\n```\r\n\r\n### 1.4 案例-手机类的创建和使用\r\n\r\n**需求 ：**首先定义一个手机类，然后定义一个手机测试类，在手机测试类中通过对象完成成员变量和成员方法的使用\r\n\r\n**分析 ：**\r\n* 成员变量：品牌, 价格\r\n* 成员方法：打电话, 发短信\r\n\r\n* 示例代码：\r\n\r\n```java\r\npackage com.itheima.test1;\r\n\r\npublic class Phone {\r\n    // 品牌, 价格\r\n    String brand;\r\n    int price;\r\n\r\n    // 打电话, 发短信\r\n    public void call(String name){\r\n        System.out.println("给"+name+"打电话");\r\n    }\r\n\r\n    public void sendMessage(){\r\n        System.out.println("群发短信");\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npackage com.itheima.test1;\r\n\r\npublic class TestPhone {\r\n    public static void main(String[] args) {\r\n        // 1. 创建对象\r\n        Phone p = new Phone();\r\n        // 2. 给成员变量进行赋值\r\n        p.brand = "大米";\r\n        p.price = 2999;\r\n        // 3. 打印赋值后的成员变量\r\n        System.out.println(p.brand + "..." + p.price);\r\n        // 4. 调用成员方法\r\n        p.call("阿强");\r\n        p.sendMessage();\r\n    }\r\n}\r\n```\r\n\r\n## 2. 对象内存图\r\n\r\n### 2.1 单个对象内存图【理解】\r\n\r\n* ![1590938666222](./img/java/basics/day07-面向对象.img/1590938666222.png)\r\n\r\n\r\n\r\n### 2.2 多个对象内存图【理解】\r\n\r\n* ![1590938693756](./img/java/basics/day07-面向对象.img/1590938693756.png)\r\n\r\n* **总结：**\r\n\r\n  多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自的内存区域中，成员方法多个对象共用的一份\r\n\r\n### 2.3 多个对象指向相同内存图【理解】\r\n\r\n![1590938711726](./img/java/basics/day07-面向对象.img/1590938711726.png)\r\n\r\n* **总结 :** \r\n\r\n  当多个对象的引用指向同一个内存空间（变量所记录的地址值是一样的）\r\n\r\n  只要有任何一个对象修改了内存中的数据，随后，无论使用哪一个对象进行数据获取，都是修改后的数据。\r\n\r\n\r\n\r\n## 3. 成员变量和局部变量\r\n\r\n### 3.1 成员变量和局部变量的区别\r\n\r\n* **类中位置不同：**成员变量（类中方法外）局部变量（方法内部或方法声明上）\r\n* **内存中位置不同：**成员变量（堆内存）局部变量（栈内存）\r\n* **生命周期不同：**成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，醉着方法的调用完毕而消失）\r\n* **初始化值不同：**成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用）\r\n\r\n## 4. 封装\r\n\r\n### 4.1 private关键字\r\n\r\n​\t**概述 :** private是一个修饰符，可以用来修饰成员（成员变量，成员方法）\r\n\r\n​\t**特点 :** 被private修饰的成员，只能在本类进行访问，针对private修饰的成员变量，如果需要被其他类使用，\t提供相应的操作\r\n\r\n​\t\t提供“get变量名()”方法，用于获取成员变量的值，方法用public修饰\r\n\r\n​\t\t提供“set变量名(参数)”方法，用于设置成员变量的值，方法用public修饰\r\n\r\n​\t**示例代码：**\r\n\r\n```java\r\n/*\r\n    学生类\r\n */\r\nclass Student {\r\n    //成员变量\r\n    String name;\r\n    private int age;\r\n\r\n    //提供get/set方法\r\n    public void setAge(int a) {\r\n        if(a<0 || a>120) {\r\n            System.out.println("你给的年龄有误");\r\n        } else {\r\n            age = a;\r\n        }\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    //成员方法\r\n    public void show() {\r\n        System.out.println(name + "," + age);\r\n    }\r\n}\r\n/*\r\n    学生测试类\r\n */\r\npublic class StudentDemo {\r\n    public static void main(String[] args) {\r\n        //创建对象\r\n        Student s = new Student();\r\n        //给成员变量赋值\r\n        s.name = "林青霞";\r\n        s.setAge(30);\r\n        //调用show方法\r\n        s.show();\r\n    }\r\n}\r\n```\r\n### 4.2 private关键字的使用\r\n\r\n* **需求：**\r\n\r\n  * 定义标准的学生类，要求name和age使用private修饰\r\n  * 并提供set和get方法以及便于显示数据的show方法\r\n  * 测试类中创建对象并使用，最终控制台输出  林青霞，30 \r\n\r\n* **示例代码：**\r\n\r\n  ```java\r\n  /*\r\n      学生类\r\n   */\r\n  class Student {\r\n      //成员变量\r\n      private String name;\r\n      private int age;\r\n  \r\n      //get/set方法\r\n      public void setName(String n) {\r\n          name = n;\r\n      }\r\n  \r\n      public String getName() {\r\n          return name;\r\n      }\r\n  \r\n      public void setAge(int a) {\r\n          age = a;\r\n      }\r\n  \r\n      public int getAge() {\r\n          return age;\r\n      }\r\n  \r\n      public void show() {\r\n          System.out.println(name + "," + age);\r\n      }\r\n  }\r\n  /*\r\n      学生测试类\r\n   */\r\n  public class StudentDemo {\r\n      public static void main(String[] args) {\r\n          //创建对象\r\n          Student s = new Student();\r\n  \r\n          //使用set方法给成员变量赋值\r\n          s.setName("林青霞");\r\n          s.setAge(30);\r\n  \r\n          s.show();\r\n  \r\n          //使用get方法获取成员变量的值\r\n          System.out.println(s.getName() + "---" + s.getAge());\r\n          System.out.println(s.getName() + "," + s.getAge());\r\n  \r\n      }\r\n  }\r\n  ```\r\n\r\n### 4.3 this关键字【应用】\r\n\r\n**概述 :** this修饰的变量用于指代成员变量，其主要作用是（区分局部变量和成员变量的重名问题）\r\n* 方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量\r\n* 方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npublic class Student {\r\n    private String name;\r\n    private int age;\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void show() {\r\n        System.out.println(name + "," + age);\r\n    }\r\n}\r\n```\r\n\r\n### 4.4 this内存原理【理解】\r\n\r\n* **注意 :** this代表当前调用方法的引用，哪个对象调用的方法，this就代表哪一个对象\r\n\r\n* **图解 ：**\r\n\r\n* ![1590938942838](./img/java/basics/day07-面向对象.img/1590938942838.png)\r\n\r\n  ![1590938969305](./img/java/basics/day07-面向对象.img/1590938969305.png)\r\n\r\n### 4.5 封装思想\r\n\r\n1. **封装概述**\r\n    是面向对象三大特征之一（封装，继承，多态）\r\n    是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的\r\n2. **封装原则**\r\n    将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问\r\n    成员变量private，提供对应的getXxx()/setXxx()方法\r\n3. **封装好处**\r\n    通过方法来控制成员变量的操作，提高了代码的安全性\r\n    把代码用方法进行封装，提高了代码的复用性\r\n\r\n## 5. 构造方法\r\n\r\n### 5.1 构造方法的格式和执行时机\r\n\r\n* **格式注意 :**\r\n  *  方法名与类名相同，大小写也要一致\r\n  * 没有返回值类型，连void都没有\r\n  * 没有具体的返回值（不能由retrun带回结果数据）\r\n* **执行时机 ：**\r\n  * 创建对象的时候调用，每创建一次对象，就会执行一次构造方法\r\n  * 不能手动调用构造方法\r\n* **示例代码：**\r\n\r\n```java\r\nclass Student {\r\n    private String name;\r\n    private int age;\r\n\r\n    //构造方法\r\n    public Student() {\r\n        System.out.println("无参构造方法");\r\n    }\r\n\r\n    public void show() {\r\n        System.out.println(name + "," + age);\r\n    }\r\n}\r\n/*\r\n    测试类\r\n */\r\npublic class StudentDemo {\r\n    public static void main(String[] args) {\r\n        //创建对象\r\n        Student s = new Student();\r\n        s.show();\r\n    }\r\n}\r\n```\r\n\r\n### 5.2 构造方法的作用\r\n\r\n* 用于给对象的数据（属性）进行初始化\r\n\r\n```java\r\npackage com.itheima.constructor;\r\n\r\npublic class Student {\r\n    /*\r\n        格式:\r\n\r\n               1. 方法名需要跟类名相同, 大小写也要一致\r\n               2. 没有返回值类型, 连void都没有\r\n               3. 没有具体的返回值(不能由return带回具体的结果)\r\n     */\r\n\r\n    private String name;\r\n    private int age;\r\n\r\n    // 1. 如果一个类中没有编写任何构造方法, 系统将会提供一个默认的无参数构造方法\r\n    public Student(){}\r\n\r\n    // 2. 如果手动编写了构造方法, 系统就不会再提供默认的无参数构造方法了\r\n    public Student(String name, int age){\r\n        this.name = name;\r\n        this.age = age;\r\n        System.out.println("我是Student类的构造方法");\r\n    }\r\n\r\n    public void show(){\r\n        System.out.println(name + "..." + age);\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npackage com.itheima.constructor;\r\n\r\npublic class TestStudent {\r\n    public static void main(String[] args) {\r\n        Student stu1 = new Student("张三",23);\r\n        stu1.show();\r\n\r\n        Student stu2 = new Student();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 5.3 构造方法的注意事项\r\n\r\n**构造方法的创建 :** \r\n\r\n​\t如果没有定义构造方法，系统将给出一个默认的无参数构造方法\r\n\r\n​\t如果定义了构造方法，系统将不再提供默认的构造方法\r\n\r\n**构造方法的创建 :** \r\n\r\n​\t如果没有定义构造方法，系统将给出一个默认的无参数构造方法如果定义了构造方法，系统将不再提供默认的构造方法\r\n\r\n**推荐的使用方式 :** \r\n\r\n​\t无论是否使用，都手动书写无参数构造方法，和带参数构造方法\r\n\r\n\r\n\r\n### 5.4 标准类的代码编写和使用\r\n\r\n**代码 :** \r\n\r\n```java\r\npackage com.itheima.test3;\r\n\r\n/*\r\n    JavaBean类: 封装数据\r\n */\r\npublic class Student {\r\n    private String name;\r\n    private int age;\r\n\r\n    public Student() {\r\n    }\r\n\r\n    public Student(String name, int age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public void show(){\r\n        System.out.println(name + "..." + age);\r\n    }\r\n}\r\n\r\n```\r\n\r\n```java\r\npackage com.itheima.test3;\r\n\r\npublic class TestStudent {\r\n    public static void main(String[] args) {\r\n        // 1. 无参数构造方法创建对象, 通过setXxx方法给成员变量进行赋值\r\n        Student stu1 = new Student();\r\n        stu1.setName("张三");\r\n        stu1.setAge(23);\r\n        stu1.show();\r\n\r\n        // 2. 通过带参数构造方法, 直接给属性进行赋值\r\n        Student stu2 = new Student("李四",24);\r\n        stu2.show();\r\n    }\r\n}\r\n\r\n```\r\n\r\n',A={data:function(){return{MainComponent:M}}},O=A,P=Object(d["a"])(O,D,R,!1,null,"8449ef60",null),L=P.exports,q=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},k=[],B='## 1.API\r\n\r\n### 1.1 API概述-帮助文档的使用\r\n\r\n- 什么是API\r\n\r\n  ​\tAPI (Application Programming Interface) ：应用程序编程接口\r\n\r\n- java中的API\r\n\r\n  ​\t指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。\r\n\r\n**如何使用API帮助文档 :** \r\n\r\n- 打开帮助文档\r\n\r\n- 找到索引选项卡中的输入框\r\n\r\n- 在输入框中输入Random\r\n\r\n- 看类在哪个包下\r\n\r\n- 看类的描述\r\n\r\n- 看构造方法\r\n\r\n- 看成员方法\r\n\r\n\r\n\r\n### 1.2 键盘录入字符串\r\n\r\n**Scanner类 :**\r\n\r\n​\tnext() : 遇到了空格, 就不再录入数据了 , 结束标记: 空格, tab键\r\n\r\n​\tnextLine() : 可以将数据完整的接收过来 , 结束标记: 回车换行符       \r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.api;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class Demo1Scanner {\r\n    /*\r\n        next() : 遇到了空格, 就不再录入数据了\r\n\r\n                结束标记: 空格, tab键\r\n\r\n        nextLine() : 可以将数据完整的接收过来\r\n\r\n                结束标记: 回车换行符\r\n     */\r\n    public static void main(String[] args) {\r\n        // 1. 创建Scanner对象\r\n        Scanner sc = new Scanner(System.in);\r\n        System.out.println("请输入:");\r\n        // 2. 调用nextLine方法接收字符串\r\n        // ctrl + alt + v : 快速生成方法的返回值\r\n        String s = sc.nextLine();\r\n\r\n        System.out.println(s);\r\n    }\r\n}\r\n\r\n```\r\n\r\n```java\r\npackage com.itheima.api;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class Demo2Scanner {\r\n    /*\r\n        nextInt和nextLine方法配合使用的时候, nextLine方法就没有键盘录入的机会了\r\n\r\n        建议: 今后键盘录入数据的时候, 如果是字符串和整数一起接受, 建议使用next方法接受字符串.\r\n     */\r\n    public static void main(String[] args) {\r\n        Scanner sc = new Scanner(System.in);\r\n        System.out.println("请输入整数:");\r\n        int num = sc.nextInt(); // 10 + 回车换行\r\n        System.out.println("请输入字符串:");\r\n        String s = sc.nextLine();\r\n\r\n\r\n        System.out.println(num);\r\n        System.out.println(s);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## 2. String类\r\n\r\n### 2.1 String概述\r\n\r\n​\t1 String 类在 java.lang 包下，所以使用的时候不需要导包\r\n\r\n​\t2 String 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例也就是说，Java 程序中所有的双引号字符串，都是 String 类的对象\r\n\r\n​\t3 字符串不可变，它们的值在创建后不能被更改\r\n\r\n### 2.2 String类的构造方法\r\n\r\n**常用的构造方法**\r\n\r\n![1590939947722](./img/java/basics/day08-常用API.img/1590939947722.png)\r\n\r\n**示例代码**\r\n\r\n```java\r\npackage com.itheima.string;\r\n\r\npublic class Demo2StringConstructor {\r\n    /*\r\n        String类常见构造方法:\r\n\r\n            public String() : 创建一个空白字符串对象，不含有任何内容\r\n            public String(char[] chs) : 根据字符数组的内容，来创建字符串对象\r\n            public String(String original) : 根据传入的字符串内容，来创建字符串对象\r\n            String s = “abc”;  直接赋值的方式创建字符串对象，内容就是abc\r\n\r\n         注意:\r\n                String这个类比较特殊, 打印其对象名的时候, 不会出现内存地址\r\n                而是该对象所记录的真实内容.\r\n\r\n                面向对象-继承, Object类\r\n     */\r\n    public static void main(String[] args) {\r\n        // public String() : 创建一个空白字符串对象，不含有任何内容\r\n        String s1 = new String();\r\n        System.out.println(s1);\r\n\r\n        // public String(char[] chs) : 根据字符数组的内容，来创建字符串对象\r\n        char[] chs = {\'a\',\'b\',\'c\'};\r\n        String s2 = new String(chs);\r\n        System.out.println(s2);\r\n\r\n        // public String(String original) : 根据传入的字符串内容，来创建字符串对象\r\n        String s3 = new String("123");\r\n        System.out.println(s3);\r\n    }\r\n}\r\n```\r\n### 2.4 创建字符串对象的区别对比\r\n\r\n- **通过构造方法创建**\r\n\r\n  ​\t通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同\r\n\r\n- **直接赋值方式创建**\r\n\r\n  ​\t以“”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护\r\n\r\n### 2.5 字符串的比较 \r\n\r\n#### 2.5.1 字符串的比较\r\n\r\n- == 比较基本数据类型：比较的是具体的值\r\n- == 比较引用数据类型：比较的是对象地址值\r\n\r\n**String类 :  public boolean equals(String s)     比较两个字符串内容是否相同、区分大小写**\r\n\r\n**代码 :**\r\n\r\n```java\r\npackage com.itheima.stringmethod;\r\n\r\npublic class Demo1Equals {\r\n    public static void main(String[] args) {\r\n        String s1 = "abc";\r\n        String s2 = "ABC";\r\n        String s3 = "abc";\r\n\r\n        // equals : 比较字符串内容, 区分大小写\r\n        System.out.println(s1.equals(s2));\r\n        System.out.println(s1.equals(s3));\r\n\r\n        // equalsIgnoreCase : 比较字符串内容, 忽略大小写\r\n        System.out.println(s1.equalsIgnoreCase(s2));\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 2.6 用户登录案例【应用】\r\n\r\n**案例需求 :** \r\n\r\n​\t已知用户名和密码，请用程序实现模拟用户登录。总共给三次机会，登录之后，给出相应的提示\r\n\r\n**实现步骤 : **\r\n\r\n1. 已知用户名和密码，定义两个字符串表示即可\r\n2. 键盘录入要登录的用户名和密码，用 Scanner 实现\r\n3. 拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。\r\n4. 字符串的内容比较，用equals() 方法实现\r\n5. 用循环实现多次机会，这里的次数明确，采用for循环实现，并在登录成功的时候，使用break结束循\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class Test1 {\r\n    /*\r\n        需求：已知用户名和密码，请用程序实现模拟用户登录。\r\n              总共给三次机会，登录之后，给出相应的提示\r\n\r\n        思路：\r\n        1. 已知用户名和密码，定义两个字符串表示即可\r\n        2. 键盘录入要登录的用户名和密码，用 Scanner 实现\r\n        3. 拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。\r\n            字符串的内容比较，用equals() 方法实现\r\n        4. 用循环实现多次机会，这里的次数明确，采用for循环实现，并在登录成功的时候，使用break结束循环\r\n\r\n     */\r\n    public static void main(String[] args) {\r\n        // 1. 已知用户名和密码，定义两个字符串表示即可\r\n        String username = "admin";\r\n        String password = "123456";\r\n        // 2. 键盘录入要登录的用户名和密码，用 Scanner 实现\r\n        Scanner sc = new Scanner(System.in);\r\n        // 4. 用循环实现多次机会，这里的次数明确，采用for循环实现\r\n        for(int i = 1; i <= 3; i++){\r\n            System.out.println("请输入用户名:");\r\n            String scUsername = sc.nextLine();\r\n            System.out.println("请输入密码:");\r\n            String scPassword = sc.nextLine();\r\n            // 3. 拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。\r\n            if(username.equals(scUsername) && password.equals(scPassword)){\r\n                System.out.println("登录成功");\r\n                break;\r\n            }else{\r\n                if(i == 3){\r\n                    System.out.println("您的登录次数已达到今日上限, 请明天再来");\r\n                }else{\r\n                    System.out.println("登录失败,您还剩余" + (3-i) +"次机会");\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\n```\r\n\r\n### 2.7 遍历字符串案例【应用】\r\n\r\n**案例需求 :** \r\n\r\n​\t键盘录入一个字符串，使用程序实现在控制台遍历该字符串\r\n\r\n**实现步骤 :** \r\n\r\n1. 键盘录入一个字符串，用 Scanner 实现\r\n2. 遍历字符串，首先要能够获取到字符串中的每一个字符, public char charAt(int index)：返回指定索引处的char值，字符串的索引也是从0开始的\r\n3.  遍历字符串，其次要能够获取到字符串的长度,   public int length()：返回此字符串的长度\r\n4. 遍历打印\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class Test2 {\r\n    /*\r\n        需求：键盘录入一个字符串，使用程序实现在控制台遍历该字符串\r\n\r\n        思路：\r\n        1. 键盘录入一个字符串，用 Scanner 实现\r\n        2. 遍历字符串，首先要能够获取到字符串中的每一个字符\r\n            public char charAt(int index)：返回指定索引处的char值，字符串的索引也是从0开始的\r\n        3. 遍历字符串，其次要能够获取到字符串的长度\r\n            public int length()：返回此字符串的长度\r\n        4. 遍历打印\r\n9\r\n     */\r\n    public static void main(String[] args) {\r\n        //  1. 键盘录入一个字符串，用 Scanner 实现\r\n        Scanner sc = new Scanner(System.in);\r\n        System.out.println("请输入:");\r\n        String s = sc.nextLine();\r\n        // 2. 遍历字符串，首先要能够获取到字符串中的每一个字符\r\n        for(int i = 0; i < s.length(); i++){\r\n            // i : 字符串的每一个索引\r\n            char c = s.charAt(i);\r\n            System.out.println(c);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 2.8 统计字符次数案例【应用】\r\n\r\n**案例需求 :** \r\n\r\n​\t键盘录入一个字符串，使用程序实现在控制台遍历该字符串\r\n\r\n**实现步骤 :** \r\n\r\n1. 键盘录入一个字符串，用 Scanner 实现\r\n2. 将字符串拆分为字符数组 , public char[] toCharArray( )：将当前字符串拆分为字符数组并返回\r\n3. 遍历字符数\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class Test3 {\r\n    /*\r\n       需求：键盘录入一个字符串，使用程序实现在控制台遍历该字符串\r\n\r\n       思路：\r\n       1. 键盘录入一个字符串，用 Scanner 实现\r\n       2. 将字符串拆分为字符数组\r\n                public char[] toCharArray( )：将当前字符串拆分为字符数组并返回\r\n       3. 遍历字符数组\r\n\r\n    */\r\n    public static void main(String[] args) {\r\n        //  1. 键盘录入一个字符串，用 Scanner 实现\r\n        Scanner sc = new Scanner(System.in);\r\n        System.out.println("请输入:");\r\n        String s = sc.nextLine();\r\n        // 2. 将字符串拆分为字符数组\r\n        char[] chars = s.toCharArray();\r\n        // 3. 遍历字符数组\r\n        for (int i = 0; i < chars.length; i++) {\r\n            System.out.println(chars[i]);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 2.9 手机号屏蔽-字符串截取\r\n\r\n**案例需求 :** \r\n\r\n​\t以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽\r\n        最终效果为：156****1234\r\n\r\n**实现步骤 :** \r\n\r\n1. 键盘录入一个字符串，用 Scanner 实现\r\n2. 截取字符串前三位\r\n3. 截取字符串后四位\r\n4. 将截取后的两个字符串，中间加上****进行拼接，输出结果\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class Test5 {\r\n    /*\r\n        需求：以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽\r\n        最终效果为：156****1234\r\n\r\n        思路：\r\n        1. 键盘录入一个字符串，用 Scanner 实现\r\n        2. 截取字符串前三位\r\n        3. 截取字符串后四位\r\n        4. 将截取后的两个字符串，中间加上****进行拼接，输出结果\r\n\r\n     */\r\n    public static void main(String[] args) {\r\n        // 1. 键盘录入一个字符串，用 Scanner 实现\r\n        Scanner sc = new Scanner(System.in);\r\n        System.out.println("请输入手机号:");\r\n        String telString = sc.nextLine();\r\n        // 2. 截取字符串前三位\r\n        String start = telString.substring(0,3);\r\n        // 3. 截取字符串后四位\r\n        String end = telString.substring(7);\r\n        // 4. 将截取后的两个字符串，中间加上****进行拼接，输出结果\r\n        System.out.println(start + "****" + end);\r\n    }\r\n}\r\n```\r\n\r\n### 2.10 敏感词替换-字符串替换\r\n\r\n**案例需求 :** \r\n\r\n​\t键盘录入一个 字符串，如果字符串中包含（TMD），则使用***替换\r\n\r\n**实现步骤 :** \r\n\r\n1. 键盘录入一个字符串，用 Scanner 实现\r\n2. 替换敏感词\r\n               String replace(CharSequence target, CharSequence replacement)\r\n               将当前字符串中的target内容，使用replacement进行替换，返回新的字符串\r\n3. 输出结果\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class Test6 {\r\n    /*\r\n        需求：键盘录入一个 字符串，如果字符串中包含（TMD），则使用***替换\r\n\r\n        思路：\r\n        1. 键盘录入一个字符串，用 Scanner 实现\r\n        2. 替换敏感词\r\n                String replace(CharSequence target, CharSequence replacement)\r\n                将当前字符串中的target内容，使用replacement进行替换，返回新的字符串\r\n        3. 输出结果\r\n\r\n     */\r\n    public static void main(String[] args) {\r\n        // 1. 键盘录入一个字符串，用 Scanner 实现\r\n        Scanner sc = new Scanner(System.in);\r\n        System.out.println("请输入:");\r\n        String s = sc.nextLine();\r\n        // 2. 替换敏感词\r\n        String result = s.replace("TMD","***");\r\n        // 3. 输出结果\r\n        System.out.println(result);\r\n    }\r\n}\r\n```\r\n\r\n### 2.11 切割字符串\r\n\r\n**案例需求 :** \r\n\r\n​\t以字符串的形式从键盘录入学生信息，例如：“张三 , 23”\r\n\r\n​\t从该字符串中切割出有效数据,封装为Student学生对象\r\n\r\n**实现步骤 :** \r\n\r\n1. 编写Student类，用于封装数据\r\n\r\n2. 键盘录入一个字符串，用 Scanner 实现\r\n\r\n3. 根据逗号切割字符串，得到（张三）（23）\r\n\r\n   String[] split(String regex) ：根据传入的字符串作为规则进行切割\r\n   将切割后的内容存入字符串数组中，并将字符串数组返回\r\n\r\n4. 从得到的字符串数组中取出元素内容，通过Student类的有参构造方法封装为对象\r\n\r\n5. 调用对象getXxx方法，取出数据并打印。\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\nimport com.itheima.domain.Student;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class Test7 {\r\n    /*\r\n         需求：以字符串的形式从键盘录入学生信息，例如：“张三 , 23”\r\n                从该字符串中切割出有效数据,封装为Student学生对象\r\n         思路：\r\n            1. 编写Student类，用于封装数据\r\n            2. 键盘录入一个字符串，用 Scanner 实现\r\n            3. 根据逗号切割字符串，得到（张三）（23）\r\n                    String[] split(String regex) ：根据传入的字符串作为规则进行切割\r\n                    将切割后的内容存入字符串数组中，并将字符串数组返回\r\n            4. 从得到的字符串数组中取出元素内容，通过Student类的有参构造方法封装为对象\r\n            5. 调用对象getXxx方法，取出数据并打印。\r\n\r\n     */\r\n    public static void main(String[] args) {\r\n        // 2. 键盘录入一个字符串，用 Scanner 实现\r\n        Scanner sc = new Scanner(System.in);\r\n        System.out.println("请输入学生信息:");\r\n        String stuInfo = sc.nextLine();\r\n        // stuInfo = "张三,23";\r\n        // 3. 根据逗号切割字符串，得到（张三）（23）\r\n        String[] sArr = stuInfo.split(",");\r\n\r\n//        System.out.println(sArr[0]);\r\n//        System.out.println(sArr[1]);\r\n\r\n        // 4. 从得到的字符串数组中取出元素内容，通过Student类的有参构造方法封装为对象\r\n        Student stu = new Student(sArr[0],sArr[1]);\r\n\r\n        // 5. 调用对象getXxx方法，取出数据并打印。\r\n        System.out.println(stu.getName() + "..." + stu.getAge());\r\n    }\r\n}\r\n```\r\n\r\n### 2.12 String方法小结\r\n\r\n**String类的常用方法 :** \r\n\r\n​\tpublic boolean equals(Object anObject)  比较字符串的内容，严格区分大小写\r\n\r\n​\tpublic boolean equalsIgnoreCase(String anotherString)  比较字符串的内容，忽略大小写\r\n\r\n​\tpublic int length()  返回此字符串的长度\r\n\r\n​\tpublic char charAt(int index)  返回指定索引处的 char 值\r\n\r\n​\tpublic char[] toCharArray()  将字符串拆分为字符数组后返回\r\n\r\n​\tpublic String substring(int beginIndex, int endIndex)  根据开始和结束索引进行截取，得到新的字符串（包含头，不包含尾）\r\n\r\n​\tpublic String substring(int beginIndex)  从传入的索引处截取，截取到末尾，得到新的字符串\r\n\r\n​\tpublic String replace(CharSequence target, CharSequence replacement)  使用新值，将字符串中的旧值替换，得到新的字符串\r\n\r\n​\tpublic String[] split(String regex)  根据传入的规则切割字符串，得到字符串数组\r\n\r\n## 3 StringBuilder类\r\n\r\n### 3.1 StringBuilder类概述\r\n\r\n​\t**概述 :** StringBuilder 是一个可变的字符串类，我们可以把它看成是一个容器，这里的可变指的是 StringBuilder 对象中的内容是可变的\r\n\r\n### 3.2 StringBuilder类和String类的区别\r\n\r\n- **String类：**内容是不可变的\r\n- **StringBuilder类：**内容是可变的\r\n\r\n### 3.3StringBuilder类的构造方法\r\n\r\n**常用的构造方法**\r\n\r\n| 方法名                             | 说明                                       |\r\n| ---------------------------------- | ------------------------------------------ |\r\n| public StringBuilder()             | 创建一个空白可变字符串对象，不含有任何内容 |\r\n| public StringBuilder(String   str) | 根据字符串的内容，来创建可变字符串对象     |\r\n\r\n**示例代码**\r\n\r\n```java\r\npublic class StringBuilderDemo01 {\r\n    public static void main(String[] args) {\r\n        //public StringBuilder()：创建一个空白可变字符串对象，不含有任何内容\r\n        StringBuilder sb = new StringBuilder();\r\n        System.out.println("sb:" + sb);\r\n        System.out.println("sb.length():" + sb.length());\r\n\r\n        //public StringBuilder(String str)：根据字符串的内容，来创建可变字符串对象\r\n        StringBuilder sb2 = new StringBuilder("hello");\r\n        System.out.println("sb2:" + sb2);\r\n        System.out.println("sb2.length():" + sb2.length());\r\n    }\r\n}\r\n```\r\n\r\n### 3.4 StringBuilder常用的成员方法\r\n\r\n- **添加和反转方法**\r\n\r\n  | 方法名                                  | 说明                     |\r\n  | --------------------------------------- | ------------------------ |\r\n  | public StringBuilder   append(任意类型) | 添加数据，并返回对象本身 |\r\n  | public StringBuilder   reverse()        | 返回相反的字符序列       |\r\n\r\n- **示例代码**\r\n\r\n```java\r\npublic class StringBuilderDemo01 {\r\n    public static void main(String[] args) {\r\n        //创建对象\r\n        StringBuilder sb = new StringBuilder();\r\n\r\n        //public StringBuilder append(任意类型)：添加数据，并返回对象本身\r\n//        StringBuilder sb2 = sb.append("hello");\r\n//\r\n//        System.out.println("sb:" + sb);\r\n//        System.out.println("sb2:" + sb2);\r\n//        System.out.println(sb == sb2);\r\n\r\n//        sb.append("hello");\r\n//        sb.append("world");\r\n//        sb.append("java");\r\n//        sb.append(100);\r\n\r\n        //链式编程\r\n        sb.append("hello").append("world").append("java").append(100);\r\n\r\n        System.out.println("sb:" + sb);\r\n\r\n        //public StringBuilder reverse()：返回相反的字符序列\r\n        sb.reverse();\r\n        System.out.println("sb:" + sb);\r\n    }\r\n}\r\n```\r\n\r\n### 3.5StringBuilder和String相互转换【应用】\r\n\r\n- **StringBuilder转换为String**\r\n\r\n  ​        public String toString()：通过 toString() 就可以实现把 StringBuilder 转换为 String\r\n\r\n- **String转换为StringBuilder**\r\n\r\n  ​        public StringBuilder(String s)：通过构造方法就可以实现把 String 转换为 StringBuilder\r\n\r\n- **示例代码**\r\n\r\n```java\r\npublic class StringBuilderDemo02 {\r\n    public static void main(String[] args) {\r\n        /*\r\n        //StringBuilder 转换为 String\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append("hello");\r\n\r\n        //String s = sb; //这个是错误的做法\r\n\r\n        //public String toString()：通过 toString() 就可以实现把 StringBuilder 转换为 String\r\n        String s = sb.toString();\r\n        System.out.println(s);\r\n        */\r\n\r\n        //String 转换为 StringBuilder\r\n        String s = "hello";\r\n\r\n        //StringBuilder sb = s; //这个是错误的做法\r\n\r\n        //public StringBuilder(String s)：通过构造方法就可以实现把 String 转换为 StringBuilder\r\n        StringBuilder sb = new StringBuilder(s);\r\n\r\n        System.out.println(sb);\r\n    }\r\n}\r\n```\r\n\r\n### 3.6 StringBuilder拼接字符串案例\r\n\r\n**案例需求 :** \r\n\r\n​\t定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回，调用该方法，\r\n\r\n​\t并在控制台输出结果。例如，数组为int[] arr = {1,2,3}; ，执行方法后的输出结果为：[1, 2, 3]\r\n\r\n**实现步骤 :** \r\n\r\n1. 定义一个 int 类型的数组，用静态初始化完成数组元素的初始化\r\n2. 定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回。\r\n             返回值类型 String，参数列表 int[] arr\r\n3. 在方法中用 StringBuilder 按照要求进行拼接，并把结果转成 String 返回\r\n4. 调用方法，用一个变量接收结果\r\n5. 输出结果\r\n\r\n**代码实现 :** \r\n\r\n```java\r\n/*\r\n    思路：\r\n        1:定义一个 int 类型的数组，用静态初始化完成数组元素的初始化\r\n        2:定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回。\r\n          返回值类型 String，参数列表 int[] arr\r\n        3:在方法中用 StringBuilder 按照要求进行拼接，并把结果转成 String 返回\r\n        4:调用方法，用一个变量接收结果\r\n        5:输出结果\r\n */\r\npublic class StringBuilderTest01 {\r\n    public static void main(String[] args) {\r\n        //定义一个 int 类型的数组，用静态初始化完成数组元素的初始化\r\n        int[] arr = {1, 2, 3};\r\n\r\n        //调用方法，用一个变量接收结果\r\n        String s = arrayToString(arr);\r\n\r\n        //输出结果\r\n        System.out.println("s:" + s);\r\n\r\n    }\r\n\r\n    //定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回\r\n    /*\r\n        两个明确：\r\n            返回值类型：String\r\n            参数：int[] arr\r\n     */\r\n    public static String arrayToString(int[] arr) {\r\n        //在方法中用 StringBuilder 按照要求进行拼接，并把结果转成 String 返回\r\n        StringBuilder sb = new StringBuilder();\r\n\r\n        sb.append("[");\r\n\r\n        for(int i=0; i<arr.length; i++) {\r\n            if(i == arr.length-1) {\r\n                sb.append(arr[i]);\r\n            } else {\r\n                sb.append(arr[i]).append(", ");\r\n            }\r\n        }\r\n\r\n        sb.append("]");\r\n\r\n        String s = sb.toString();\r\n\r\n        return  s;\r\n    }\r\n}\r\n```\r\n\r\n',_={data:function(){return{MainComponent:B}}},F=_,H=Object(d["a"])(F,q,k,!1,null,"8651277e",null),N=H.exports,J=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},U=[],G='## 1.ArrayList\r\n\r\n**集合和数组的区别 :** \r\n\r\n​\t共同点：都是存储数据的容器\r\n\r\n​\t不同点：数组的容量是固定的，集合的容量是可变的\r\n\r\n### 1.1 -ArrayList的构造方法和添加方法\r\n\r\n| public ArrayList()                   | 创建一个空的集合对象               |\r\n| ------------------------------------ | ---------------------------------- |\r\n| public boolean add(E e)              | 将指定的元素追加到此集合的末尾     |\r\n| public void add(int index,E element) | 在此集合中的指定位置插入指定的元素 |\r\n\r\n**ArrayList<E> ：** \r\n\r\n​\t可调整大小的数组实现 \r\n\r\n​\t<E> : 是一种特殊的数据类型，泛型。\r\n\r\n**怎么用呢 ?**\t\r\n\r\n​\t在出现E的地方我们使用引用数据类型替换即可\t\r\n\r\n​\t举例：ArrayList<String>, ArrayList<Student>\r\n\r\n### 1.2ArrayList类常用方法【应用】\r\n\r\n**成员方法 : **\r\n\r\n| public boolean remove(Object o)   | 删除指定的元素，返回删除是否成功       |\r\n| --------------------------------- | -------------------------------------- |\r\n| public E remove(int index)        | 删除指定索引处的元素，返回被删除的元素 |\r\n| public E set(int index,E element) | 修改指定索引处的元素，返回被修改的元素 |\r\n| public E get(int index)           | 返回指定索引处的元素                   |\r\n| public int size()                 | 返回集合中的元素的个数                 |\r\n\r\n**示例代码 :** \r\n\r\n```java\r\npublic class ArrayListDemo02 {\r\n    public static void main(String[] args) {\r\n        //创建集合\r\n        ArrayList<String> array = new ArrayList<String>();\r\n\r\n        //添加元素\r\n        array.add("hello");\r\n        array.add("world");\r\n        array.add("java");\r\n\r\n        //public boolean remove(Object o)：删除指定的元素，返回删除是否成功\r\n//        System.out.println(array.remove("world"));\r\n//        System.out.println(array.remove("javaee"));\r\n\r\n        //public E remove(int index)：删除指定索引处的元素，返回被删除的元素\r\n//        System.out.println(array.remove(1));\r\n\r\n        //IndexOutOfBoundsException\r\n//        System.out.println(array.remove(3));\r\n\r\n        //public E set(int index,E element)：修改指定索引处的元素，返回被修改的元素\r\n//        System.out.println(array.set(1,"javaee"));\r\n\r\n        //IndexOutOfBoundsException\r\n//        System.out.println(array.set(3,"javaee"));\r\n\r\n        //public E get(int index)：返回指定索引处的元素\r\n//        System.out.println(array.get(0));\r\n//        System.out.println(array.get(1));\r\n//        System.out.println(array.get(2));\r\n        //System.out.println(array.get(3)); //？？？？？？ 自己测试\r\n\r\n        //public int size()：返回集合中的元素的个数\r\n        System.out.println(array.size());\r\n\r\n        //输出集合\r\n        System.out.println("array:" + array);\r\n    }\r\n}\r\n```\r\n\r\n### 1.3 ArrayList存储字符串并遍历\r\n\r\n**案例需求 :** \r\n\r\n​\t创建一个存储字符串的集合，存储3个字符串元素，使用程序实现在控制台遍历该集合\r\n\r\n**实现步骤 :** \r\n\r\n \t1:创建集合对象\r\n        2:往集合中添加字符串对象\r\n        3:遍历集合，首先要能够获取到集合中的每一个元素，这个通过get(int index)方法实现\r\n        4:遍历集合，其次要能够获取到集合的长度，这个通过size()方法实现\r\n        5:遍历集合的通用格式\r\n\r\n**代码实现 :** \r\n\r\n```java\r\n/*\r\n    思路：\r\n        1:创建集合对象\r\n        2:往集合中添加字符串对象\r\n        3:遍历集合，首先要能够获取到集合中的每一个元素，这个通过get(int index)方法实现\r\n        4:遍历集合，其次要能够获取到集合的长度，这个通过size()方法实现\r\n        5:遍历集合的通用格式\r\n */\r\npublic class ArrayListTest01 {\r\n    public static void main(String[] args) {\r\n        //创建集合对象\r\n        ArrayList<String> array = new ArrayList<String>();\r\n\r\n        //往集合中添加字符串对象\r\n        array.add("刘正风");\r\n        array.add("左冷禅");\r\n        array.add("风清扬");\r\n\r\n        //遍历集合，其次要能够获取到集合的长度，这个通过size()方法实现\r\n//        System.out.println(array.size());\r\n\r\n        //遍历集合的通用格式\r\n        for(int i=0; i<array.size(); i++) {\r\n            String s = array.get(i);\r\n            System.out.println(s);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 1.4 ArrayList存储学生对象并遍历\r\n\r\n**案例需求 :** \r\n\r\n​\t创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合\r\n\r\n**实现步骤 : ** \r\n\r\n​\t1:定义学生类    \r\n\r\n​\t2:创建集合对象    \r\n\r\n​\t3:创建学生对象    \r\n\r\n​\t4:添加学生对象到集合中    \r\n\r\n​\t5:遍历集合，采用通用遍历格式实现\r\n\r\n**代码实现 :**\r\n\r\n```java\r\n/*\r\n    思路：\r\n        1:定义学生类\r\n        2:创建集合对象\r\n        3:创建学生对象\r\n        4:添加学生对象到集合中\r\n        5:遍历集合，采用通用遍历格式实现\r\n */\r\npublic class ArrayListTest02 {\r\n    public static void main(String[] args) {\r\n        //创建集合对象\r\n        ArrayList<Student> array = new ArrayList<>();\r\n\r\n        //创建学生对象\r\n        Student s1 = new Student("林青霞", 30);\r\n        Student s2 = new Student("风清扬", 33);\r\n        Student s3 = new Student("张曼玉", 18);\r\n\r\n        //添加学生对象到集合中\r\n        array.add(s1);\r\n        array.add(s2);\r\n        array.add(s3);\r\n\r\n        //遍历集合，采用通用遍历格式实现\r\n        for (int i = 0; i < array.size(); i++) {\r\n            Student s = array.get(i);\r\n            System.out.println(s.getName() + "," + s.getAge());\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 1.5 键盘录入学生信息到集合\r\n\r\n**案例需求 :** \r\n\r\n​\t创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合\r\n\r\n​        学生的姓名和年龄来自于键盘录入\r\n\r\n**实现步骤 :**\r\n\r\n​\t1:定义学生类，为了键盘录入数据方便，把学生类中的成员变量都定义为String类型    \r\n\r\n​\t2:创建集合对象    \r\n\r\n​\t3:键盘录入学生对象所需要的数据    \r\n\r\n​\t4:创建学生对象，把键盘录入的数据赋值给学生对象的成员变量    \r\n\r\n​\t5:往集合中添加学生对象    \r\n\r\n​\t6:遍历集合，采用通用遍历格式实现\r\n\r\n**代码实现 :** \r\n\r\n```java\r\n/*\r\n    思路：\r\n        1:定义学生类，为了键盘录入数据方便，把学生类中的成员变量都定义为String类型\r\n        2:创建集合对象\r\n        3:键盘录入学生对象所需要的数据\r\n        4:创建学生对象，把键盘录入的数据赋值给学生对象的成员变量\r\n        5:往集合中添加学生对象\r\n        6:遍历集合，采用通用遍历格式实现\r\n */\r\npublic class ArrayListTest {\r\n    public static void main(String[] args) {\r\n        //创建集合对象\r\n        ArrayList<Student> array = new ArrayList<Student>();\r\n\r\n        //为了提高代码的复用性，我们用方法来改进程序\r\n        addStudent(array);\r\n        addStudent(array);\r\n        addStudent(array);\r\n\r\n        //遍历集合，采用通用遍历格式实现\r\n        for (int i = 0; i < array.size(); i++) {\r\n            Student s = array.get(i);\r\n            System.out.println(s.getName() + "," + s.getAge());\r\n        }\r\n    }\r\n\r\n    /*\r\n        两个明确：\r\n            返回值类型：void\r\n            参数：ArrayList<Student> array\r\n     */\r\n    public static void addStudent(ArrayList<Student> array) {\r\n        //键盘录入学生对象所需要的数据\r\n        Scanner sc = new Scanner(System.in);\r\n\r\n        System.out.println("请输入学生姓名:");\r\n        String name = sc.nextLine();\r\n\r\n        System.out.println("请输入学生年龄:");\r\n        String age = sc.nextLine();\r\n\r\n        //创建学生对象，把键盘录入的数据赋值给学生对象的成员变量\r\n        Student s = new Student();\r\n        s.setName(name);\r\n        s.setAge(age);\r\n\r\n        //往集合中添加学生对象\r\n        array.add(s);\r\n    }\r\n}\r\n```\r\n\r\n## 2. 学生管理系统\r\n\r\n### 2.1 学生管理系统实现步骤\r\n\r\n- **案例需求**\r\n\r\n  ​\t针对目前我们的所学内容，完成一个综合案例：学生管理系统！该系统主要功能如下：\r\n\r\n  ​\t添加学生：通过键盘录入学生信息，添加到集合中\r\n\r\n  ​\t删除学生：通过键盘录入要删除学生的学号，将该学生对象从集合中删除\r\n\r\n  ​\t修改学生：通过键盘录入要修改学生的学号，将该学生对象其他信息进行修改\r\n\r\n  ​\t查看学生：将集合中的学生对象信息进行展示\r\n\r\n  ​\t退出系统：结束程序\r\n\r\n- **实现步骤**\r\n\r\n  1. 定义学生类，包含以下成员变量\r\n\r\n     学生类：\tStudent成员变量：\t\r\n\r\n     ​\t学号：sid\t\r\n\r\n     ​\t姓名：name\t\r\n\r\n     ​\t年龄：age\t\r\n\r\n     ​\t生日：birthday\r\n\r\n     ​\t构造方法：\t\r\n\r\n     ​\t\t无参构造\t\r\n\r\n     ​\t\t带四个参数的构造成员方法：\t\r\n\r\n     ​\t每个成员变量对应给出get/set方法\r\n\r\n  2. 学生管理系统主界面的搭建步骤\r\n\r\n     2.1 用输出语句完成主界面的编写\r\n\r\n     2.2 用Scanner实现键盘录入数据\r\n\r\n     2.3 用switch语句完成操作的选择\r\n\r\n     2.4 用循环完成再次回到主界面\r\n\r\n  3. 学生管理系统的添加学生功能实现步骤\r\n\r\n     3.1 用键盘录入选择添加学生\r\n\r\n     3.2 定义一个方法，用于添加学生\r\n\r\n     ​\t显示提示信息，提示要输入何种信息\r\n\r\n     ​\t键盘录入学生对象所需要的数据\r\n\r\n     ​\t创建学生对象，把键盘录入的数据赋值给学生对象的成员变量\r\n\r\n     ​\t将学生对象添加到集合中（保存）\r\n\r\n     ​\t给出添加成功提示\r\n\r\n     3.3 调用方法\r\n\r\n  4. 学生管理系统的查看学生功能实现步骤\r\n\r\n     4.1 用键盘录入选择查看所有学生信息\r\n\r\n     4.2 定义一个方法，用于查看学生信息\r\n\r\n     ​\t显示表头信息\r\n\r\n     ​\t将集合中数据取出按照对应格式显示学生信息，年龄显示补充“岁”\r\n\r\n     4.3 调用方法\r\n\r\n  5. 学生管理系统的删除学生功能实现步骤\r\n\r\n     5.1 用键盘录入选择删除学生信息\r\n\r\n     5.2 定义一个方法，用于删除学生信息\r\n\r\n     ​\t显示提示信息\r\n\r\n     ​\t键盘录入要删除的学生学号\r\n\r\n     ​\t调用getIndex方法，查找该学号在集合的索引\r\n\r\n     ​\t如果索引为-1，提示信息不存在\r\n\r\n     ​\t如果索引不是-1，调用remove方法删除并提示删除成功\r\n\r\n     5.3 调用方法\r\n\r\n  6. 学生管理系统的修改学生功能实现步骤\r\n\r\n     6.1 用键盘录入选择修改学生信息\r\n\r\n     6.2 定义一个方法，用于修改学生信息\r\n\r\n     ​\t显示提示信息\r\n\r\n     ​\t键盘录入要修改的学生学号\r\n\r\n     ​\t调用getIndex方法，查找该学号在集合的索引\r\n\r\n     ​\t如果索引为-1，提示信息不存在\r\n\r\n     ​\t如果索引不是-1，键盘录入要修改的学生信息\r\n\r\n     ​\t集合修改对应的学生信息\r\n\r\n     ​\t给出修改成功提示\r\n\r\n     6.3 调用方法\r\n\r\n  7. 退出系统\r\n\r\n     使用System.exit(0);退出JVM\r\n\r\n### 2.2 学生类的定义\r\n\r\n```java\r\npackage com.itheima.domain;\r\n\r\npublic class Student {\r\n    private String sid; // 学号\r\n    private String name; // 姓名\r\n    private int age; // 年龄\r\n    private String birthday; // 生日\r\n\r\n    public Student() {\r\n    }\r\n\r\n    public Student(String sid, String name, int age, String birthday) {\r\n        this.sid = sid;\r\n        this.name = name;\r\n        this.age = age;\r\n        this.birthday = birthday;\r\n    }\r\n\r\n    public String getSid() {\r\n        return sid;\r\n    }\r\n\r\n    public void setSid(String sid) {\r\n        this.sid = sid;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public String getBirthday() {\r\n        return birthday;\r\n    }\r\n\r\n    public void setBirthday(String birthday) {\r\n        this.birthday = birthday;\r\n    }\r\n}\r\n```\r\n\r\n### 2.3 测试类的定义\r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\nimport com.itheima.domain.Student;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Scanner;\r\n\r\npublic class StudentManager {\r\n    public static void main(String[] args) {\r\n\r\n        Scanner sc = new Scanner(System.in);\r\n\r\n        // 创建集合容器对象\r\n        ArrayList<Student> list = new ArrayList<>();\r\n\r\n        lo:\r\n        while (true) {\r\n            // 1. 搭建主界面菜单\r\n            System.out.println("--------欢迎来到学生管理系统--------");\r\n            System.out.println("1 添加学生");\r\n            System.out.println("2 删除学生");\r\n            System.out.println("3 修改学生");\r\n            System.out.println("4 查看学生");\r\n            System.out.println("5 退出");\r\n            System.out.println("请输入您的选择:");\r\n\r\n            String choice = sc.next();\r\n\r\n            switch (choice) {\r\n                case "1":\r\n                    //System.out.println("添加学生");\r\n                    addStudent(list);\r\n                    break;\r\n                case "2":\r\n                    //System.out.println("删除学生");\r\n                    deleteStudent(list);\r\n                    break;\r\n                case "3":\r\n                    //System.out.println("修改学生");\r\n                    updateStudent(list);\r\n                    break;\r\n                case "4":\r\n                    // System.out.println("查看学生");\r\n                    queryStudents(list);\r\n                    break;\r\n                case "5":\r\n                    System.out.println("感谢您的使用");\r\n                    break lo;\r\n                default:\r\n                    System.out.println("您的输入有误");\r\n                    break;\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    // 修改学生的方法\r\n    public static void updateStudent(ArrayList<Student> list) {\r\n        System.out.println("请输入您要修改的学生学号:");\r\n        Scanner sc = new Scanner(System.in);\r\n        String updateSid = sc.next();\r\n        // 3. 调用getIndex方法, 查找该学号在集合中出现的索引位置\r\n        int index = getIndex(list,updateSid);\r\n        // 4. 根据索引判断, 学号在集合中是否存在\r\n        if(index == -1){\r\n            // 不存在: 给出提示\r\n            System.out.println("查无信息, 请重新输入");\r\n        }else{\r\n            // 存在: 接收新的学生信息\r\n            System.out.println("请输入新的学生姓名:");\r\n            String name = sc.next();\r\n            System.out.println("请输入新的学生年龄:");\r\n            int age = sc.nextInt();\r\n            System.out.println("请输入新的学生生日:");\r\n            String birthday = sc.next();\r\n            // 封装为新的学生对象\r\n            Student stu = new Student(updateSid, name, age, birthday);\r\n            // 调用集合的set方法, 完成修改\r\n            list.set(index, stu);\r\n            System.out.println("修改成功!");\r\n        }\r\n    }\r\n\r\n    // 删除学生的方法\r\n    public static void deleteStudent(ArrayList<Student> list) {\r\n        // 1. 给出提示信息 (请输入您要删除的学号)\r\n        System.out.println("请输入您要删除的学生学号:");\r\n        // 2. 键盘接收要删除的学号\r\n        Scanner sc = new Scanner(System.in);\r\n        String deleteSid = sc.next();\r\n        // 3. 调用getIndex方法, 查找该学号在集合中出现的索引位置\r\n        int index = getIndex(list,deleteSid);\r\n        // 4. 根据索引判断, 学号在集合中是否存在\r\n        if(index == -1){\r\n            // 不存在: 给出提示\r\n            System.out.println("查无信息, 请重新输入");\r\n        }else{\r\n            // 存在:删除\r\n            list.remove(index);\r\n            System.out.println("删除成功!");\r\n        }\r\n    }\r\n\r\n    // 查看学生的方法\r\n    public static void queryStudents(ArrayList<Student> list) {\r\n        // 1. 判断集合中是否存在数据, 如果不存在直接给出提示\r\n        if(list.size() == 0){\r\n            System.out.println("无信息, 请添加后重新查询");\r\n            return;\r\n        }\r\n        // 2. 存在: 展示表头数据\r\n        System.out.println("学号\\t\\t姓名\\t年龄\\t生日");\r\n        // 3. 遍历集合, 获取每一个学生对象的信息, 打印在控制台\r\n        for (int i = 0; i < list.size(); i++) {\r\n            Student stu = list.get(i);\r\n            System.out.println(stu.getSid() + "\\t" + stu.getName() + "\\t" + stu.getAge() + "\\t\\t" + stu.getBirthday());\r\n        }\r\n    }\r\n\r\n    // 添加学生的方法\r\n    public static void addStudent(ArrayList<Student> list) {\r\n        Scanner sc = new Scanner(System.in);\r\n        // 1. 给出录入的提示信息\r\n\r\n        String sid;\r\n\r\n        while(true){\r\n            System.out.println("请输入学号:");\r\n            sid = sc.next();\r\n\r\n            int index = getIndex(list, sid);\r\n\r\n            if(index == -1){\r\n                // sid不存在, 学号可以使用\r\n                break;\r\n            }\r\n        }\r\n\r\n        System.out.println("请输入姓名:");\r\n        String name = sc.next();\r\n        System.out.println("请输入年龄:");\r\n        int age = sc.nextInt();\r\n        System.out.println("请输入生日:");\r\n        String birthday = sc.next();\r\n        // 2. 将键盘录入的信息封装为学生对象\r\n        Student stu = new Student(sid,name,age,birthday);\r\n        // 3. 将封装好的学生对象, 添加到集合容器当中\r\n        list.add(stu);\r\n        // 4. 给出添加成功的提示信息\r\n        System.out.println("添加成功!");\r\n    }\r\n\r\n    /*\r\n        getIndex : 接收一个集合对象, 接收一个学生学号\r\n\r\n        查找这个学号, 在集合中出现的索引位置\r\n     */\r\n    public static int getIndex(ArrayList<Student> list, String sid){\r\n        // 1. 假设传入的学号, 在集合中不存在\r\n        int index = -1;\r\n        // 2. 遍历集合, 获取每一个学生对象, 准备进行查找\r\n        for (int i = 0; i < list.size(); i++) {\r\n            Student stu = list.get(i);\r\n            // 3. 获取每一个学生对象的学号\r\n            String id = stu.getSid();\r\n            // 4. 使用获取出的学生学号, 和传入的学号(查找的学号)进行比对\r\n            if(id.equals(sid)){\r\n                // 存在: 让index变量记录正确的索引位置\r\n                index = i;\r\n            }\r\n        }\r\n\r\n        return index;\r\n    }\r\n}\r\n```\r\n',V={data:function(){return{MainComponent:G}}},z=V,W=Object(d["a"])(z,J,U,!1,null,"4ecdf366",null),Q=W.exports,K=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},$=[],X="## 1.Git介绍 \n\n### 1.1版本控制(理解)\n\n无论是代码编写，还是文档编写，我们都会遇到对文档内容反复修改的情况\n\n![01_版本控制介绍](./img/java/basics/day10-Git.img/01_版本控制介绍.png)\n\n### 1.2开发中存在的问题(理解)\n\n+ 程序员小明负责的模块就要完成了，就在即将提交发布之前的一瞬间，电脑突然蓝屏，硬盘光荣下岗！\n\n几个月来的努力付之东流\n\n​\t![02_开发中的麻烦](./img/java/basics/day10-Git.img/02_开发中的麻烦.png)\n\n+ 老王需要在项目中加入一个很复杂的功能，一边尝试，一边修改代码，就这样摸索了一个星期。\n  可是这被改得面目全非的代码已经回不到从前了。\n\n  ![03_开发中的麻烦](./img/java/basics/day10-Git.img/03_开发中的麻烦.png)\n\n+ 小明和老王先后从文件服务器上下载了同一个文件\n\n  ![04_开发中的麻烦](./img/java/basics/day10-Git.img/04_开发中的麻烦.png)\n\n+ 因项目中Bug过多，导致项目进度拖延，项目经理老徐因此被骂，但不清楚Bug是手下哪一个程序员写的\n\n  ![05_开发中的麻烦](./img/java/basics/day10-Git.img/05_开发中的麻烦.png)\n\n+ 开发中要解决的问题\n\n  + 代码备份\n  + 版本控制\n  + 协同工作\n  + 责任追溯\n\n### 1.3SVN版本控制(理解)\n\nSVN是集中式版本控制系统，版本库是集中放在中央服务器的，而开发人员工作的时候，用的都是自己的电脑，\n所以首先要从中央服务器下载最新的版本，然后开发，开发完后，需要把自己开发的代码提交到中央服务器。\n\n+ 服务器单点故障\n\n  将会导致所有人员无法工作\n\n+ 而服务器硬盘损坏\n\n  这意味着，你可能失去了该项目的所有历史记录，这是毁灭性的。\n\n  ![06_svn和git的对比](./img/java/basics/day10-Git.img/06_svn和git的对比.png)\n\n### 1.4Git版本控制(理解)\n\nGit是在2005年，Linux系统的创建者Linus Torvalds,为了帮助全球的开发者，维护Linux系统内核的开发\n而开发了自己的开源分布式版本控制工具,分为两种类型的仓库：本地仓库和远程仓库。\n\n+ 每一个客户端都保存了完整的历史记录\n\n  服务器的故障，都可以通过客户端的记录得以恢复。\n\n  ![07_svn和git的对比](./img/java/basics/day10-Git.img/07_svn和git的对比.png)\n\n## 2.Git下载和安装 \n\n### 2.1Git的下载(应用)\n\n官网下载地址：https://git-scm.com/downloads\n\n![08_Git的下载](./img/java/basics/day10-Git.img/08_Git的下载.png)\n\n### 2.2Git的安装(应用)\n\n1. 双击安装包，进入安装向导界面\n\n   ![09_Git的安装01](./img/java/basics/day10-Git.img/09_Git的安装01.png)\n\n2. 指定安装目录\n\n   ![10_Git的安装02](./img/java/basics/day10-Git.img/10_Git的安装02.png)\n\n3. 一路next下一步\n\n   ![11_Git的安装03](./img/java/basics/day10-Git.img/11_Git的安装03.png)\n\n4. 等待安装\n\n   ![12_Git的安装04](./img/java/basics/day10-Git.img/12_Git的安装04.png)\n\n5. 安装完成\n\n   ![13_Git的安装05](./img/java/basics/day10-Git.img/13_Git的安装05.png)\n\n6. 安装完成后在电脑桌面（也可以是其他目录）点击右键，如果能够看到如下两个菜单则说明Git安装成功。\n\n   ![14_Git的安装06](./img/java/basics/day10-Git.img/14_Git的安装06.png)\n\n7. 运行Git命令客户端，使用git --version 命令，可以查看git版本\n\n   ![15_Git的安装07](./img/java/basics/day10-Git.img/15_Git的安装07.png)\n\n### 2.3TortoiseGit的安装(应用)\n\n1. 双击安装包，进入安装向导界面\n\n   ![16_TortiseGit的安装](./img/java/basics/day10-Git.img/16_TortiseGit的安装.png)\n\n2. 一路next下一步\n\n   ![17_TortiseGit的安装](./img/java/basics/day10-Git.img/17_TortiseGit的安装.png)\n\n3. 指定安装目录\n   ![18_TortiseGit的安装](./img/java/basics/day10-Git.img/18_TortiseGit的安装.png)\n\n4. 安装\n\n   ![19_TortiseGit的安装](./img/java/basics/day10-Git.img/19_TortiseGit的安装.png)\n\n5. 配置\n\n   ![20_TortiseGit的安装](./img/java/basics/day10-Git.img/20_TortiseGit的安装.png)\n\n   ![21_TortiseGit的安装](./img/java/basics/day10-Git.img/21_TortiseGit的安装.png)\n\n   ![22_TortiseGit的安装](./img/java/basics/day10-Git.img/22_TortiseGit的安装.png)\n\n   ![23_TortiseGit的安装](./img/java/basics/day10-Git.img/23_TortiseGit的安装.png)\n\n   ![24_TortiseGit的安装](./img/java/basics/day10-Git.img/24_TortiseGit的安装.png)\n\n   ![25_TortiseGit的安装](./img/java/basics/day10-Git.img/25_TortiseGit的安装.png)\n\n6. 安装TortoiseGit中文语言包,一路next即可\n\n![26_TortiseGit的安装](./img/java/basics/day10-Git.img/26_TortiseGit的安装.png)\n\n7. 配置TortoiseGit中文语言\n\n   ![27_TortiseGit的安装](./img/java/basics/day10-Git.img/27_TortiseGit的安装.png)\n\n   ![28_TortiseGit的安装](./img/java/basics/day10-Git.img/28_TortiseGit的安装.png)\n\n   ![29_TortiseGit的安装](./img/java/basics/day10-Git.img/29_TortiseGit的安装.png)\n\n   ![30_TortiseGit的安装](./img/java/basics/day10-Git.img/30_TortiseGit的安装.png)\n\n## 3.Git操作入门 \n\n### 3.1Git基本工作流程(理解)\n\n本地仓库\n\n![31_Git基本工作流程](./img/java/basics/day10-Git.img/31_Git基本工作流程.png)\n\n### 3.2Git命令行操作(应用)\n\n+ git常用命令\n\n  | 命令                   | 作用                         |\n  | -------------------- | -------------------------- |\n  | git init             | 初始化，创建 git 仓库              |\n  | git status           | 查看 git 状态 （文件是否进行了添加、提交操作） |\n  | git add 文件名          | 添加，将指定文件添加到暂存区             |\n  | git commit -m '提交信息' | 提交，将暂存区文件提交到历史仓库           |\n  | git log              | 查看日志（ git 提交的历史日志）         |\n\n+ 操作步骤\n\n  1. 创建工作目录、初始化本地 git 仓库\n\n     ![32_Git工作流程](./img/java/basics/day10-Git.img/32_Git工作流程.png)\n\n  2. 新建一个 test.txt 文件（暂不执行添加操作）\n\n  3. 使用 status 命令，查看状态\n\n     ![33_Git工作流程](./img/java/basics/day10-Git.img/33_Git工作流程.png)\n\n  4. 使用 add 命令添加，并查看状态\n\n     ![34_Git工作流程](./img/java/basics/day10-Git.img/34_Git工作流程.png)\n\n  5. 使用 commit 命令，提交到本地历史仓库\n\n     ![35_Git工作流程](./img/java/basics/day10-Git.img/35_Git工作流程.png)\n\n  6. 使用 log 命令，查看日志\n\n     ![36_Git工作流程](./img/java/basics/day10-Git.img/36_Git工作流程.png)\n\n  7. 修改 test.txt 文件\n\n     ![37_Git工作流程](./img/java/basics/day10-Git.img/37_Git工作流程.png)\n\n  8. 添加并提交，查看日志\n\n     ![38_Git工作流程](./img/java/basics/day10-Git.img/38_Git工作流程.png)\n\n### 3.3Git图形化工具操作(理解)\n\n1. 创建工作目录、初始化本地 git 仓库\n\n   ![39_Git工作流程](./img/java/basics/day10-Git.img/39_Git工作流程.png)\n\n   ![40_Git工作流程](./img/java/basics/day10-Git.img/40_Git工作流程.png)\n\n2. 新建一个 test.txt 文件（暂不执行添加操作）\n\n3. 选中文件右键，选择TortoiseGit，之后选择添加\n\n   ![41_Git工作流程](./img/java/basics/day10-Git.img/41_Git工作流程.png)\n\n4. 空白处右键,Git提交,提交到本地历史仓库\n\n   ![42_Git工作流程](./img/java/basics/day10-Git.img/42_Git工作流程.png)\n\n5. 空白处右键,TortoiseGit,显示日志,可以产看日志信息\n\n   ![43_Git工作流程](./img/java/basics/day10-Git.img/43_Git工作流程.png)\n\n6. 修改 test.txt 文件\n\n7. 添加并提交，查看日志\n\n## 4.Git版本管理 \n\n### 4.1历史版本切换(理解)\n\n![44_历史版本切换](./img/java/basics/day10-Git.img/44_历史版本切换.png)\n\n+ 准备动作\n\n  1. 查看 my_project 的 log 日志\n     git reflog ：可以查看所有分支的所有操作记录（包括已经被删除的 commit 记录的操作）\n  2. 增加一次新的修改记录\n\n+ 需求: 将代码切换到第二次修改的版本\n\n  指令：git reset --hard 版本唯一索引值\n\n### 4.2分支管理介绍(理解)\n\n+ 分支\n  + 由每次提交的代码，串成的一条时间线\n  + 使用分支意味着你可以把你的工作从开发主线上分离开来,以免影响开发主线\n+ 分支的使用场景\n  1. 周期较长的模块开发\n     假设你准备开发一个新功能，但是需要一个月才能完成\n     第一周写了20%的代码，突然发现原来已经写好的功能出现了一个严重的Bug\n     那现在就需要放下手中的新功能，去修复Bug\n     但这20%的代码不能舍弃，并且也担心丢失，这就需要开启一个新的版本控制。\n  2. 尝试性的模块开发\n     业务人员给我们提出了一个需求，经过我们的思考和分析\n     该需求应该可以使用技术手段进行实现。\n     但是我们还不敢确定，我们就可以去创建一个分支基于分支进行尝试性开发。\n\n\n+ 分支工作流程\n\n  + Master: 指向提交的代码版本\n\n  + Header: 指向当前所使用的的分支\n\n    ![45_分支工作流程介绍](./img/java/basics/day10-Git.img/45_分支工作流程介绍.png)\n\n### 4.3分支管理操作(应用)\n\n+ 创建和切换\n\n  创建命令：git branch 分支名\n  切换命令：git checkout 分支名\n\n+ 新分支添加文件\n\n  查看文件命令：ls\n\n  总结：不同分支之间的关系是平行的关系，不会相互影响\n\n+ 合并分支\n\n  合并命令：git merge 分支名\n\n+ 删除分支\n\n  删除命令：git branch -d 分支名\n\n+ 查看分支列表\n\n  查看命令：git branch\n\n## 5.远程仓库\n\n### 5.1远程仓库工作流程(理解)\n\n![46_远程仓库](./img/java/basics/day10-Git.img/46_远程仓库.png)\n\n### 5.2远程仓库平台介绍(理解)\n\n+ GitHub\n\n  域名：https://github.com\n  介绍：GitHub是全球最大的开源项目托管平台，俗称大型程序员社区化交友网站\n\n  ​\t    各类好玩有趣的开源项目，只有想不到，没有找不到。\n\n+ 码云\n\n  域名：https://gitee.com\n  介绍：码云是全国最大的开源项目托管平台，良心平台，速度快，提供免费私有库\n\n### 5.3码云的注册(应用)\n\n![47_码云的注册](./img/java/basics/day10-Git.img/47_码云的注册.png)\n\n![48_码云的注册](./img/java/basics/day10-Git.img/48_码云的注册.png)\n\n![49_码云的注册](./img/java/basics/day10-Git.img/49_码云的注册.png)\n\n### 5.4先有本地项目,远程为空(应用)\n\n+ 步骤\n\n  1. 创建本地仓库\n  2. 创建或修改文件，添加（add）文件到暂存区，提交（commit）到本地仓库\n  3. 创建远程仓库\n  4. 推送到远程仓库\n\n+ 创建远程仓库\n\n  ![50_创建远程仓库](./img/java/basics/day10-Git.img/50_创建远程仓库.png)\n\n  ![51_创建远程仓库](./img/java/basics/day10-Git.img/51_创建远程仓库.png)\n\n+ 生成SSH公钥\n\n  + 推送代码之前，需要先配置SSH公钥\n\n    ![52_配置SSH公钥](./img/java/basics/day10-Git.img/52_配置SSH公钥.png)\n\n  + 生成SSH公钥步骤\n\n    1. 设置Git账户\n\n       + git config user.name（查看git账户）\n       + git config user.email（查看git邮箱）\n       + git config --global user.name “账户名”（设置全局账户名）\n       + git config --global user.email “邮箱”（设置全局邮箱）\n       + cd ~/.ssh（查看是否生成过SSH公钥）\n\n       ![53_配置SSH公钥](./img/java/basics/day10-Git.img/53_配置SSH公钥.png)\n\n    2. 生成SSH公钥\n\n       + 生成命令: ssh-keygen –t rsa –C “邮箱” ( 注意：这里需要敲3次回车)\n\n       ![54_配置SSH公钥](./img/java/basics/day10-Git.img/54_配置SSH公钥.png)\n\n       + 查看命令: cat ~/.ssh/id-rsa.pub\n\n       ![55_配置SSH公钥](./img/java/basics/day10-Git.img/55_配置SSH公钥.png)\n\n    3. 设置账户公钥\n\n       ![56_配置SSH公钥](./img/java/basics/day10-Git.img/56_配置SSH公钥.png)\n\n       ![57_配置SSH公钥](./img/java/basics/day10-Git.img/57_配置SSH公钥.png)\n\n    4. 公钥测试\n\n       + 命令: ssh -T git@gitee.com\n\n       ![58_配置SSH公钥](./img/java/basics/day10-Git.img/58_配置SSH公钥.png)\n\n+  推送到远程仓库\n\n  + 步骤\n\n    1. 为远程仓库的URL（网址），自定义仓库名称\n    2. 推送\n\n  + 命令\n       git remote add 远程名称 远程仓库URL\n       git push -u 仓库名称 分支名\n\n    ![59_配置SSH公钥](./img/java/basics/day10-Git.img/59_配置SSH公钥.png)\n\n    ![60_配置SSH公钥](./img/java/basics/day10-Git.img/60_配置SSH公钥.png)\n\n### 5.5先有远程仓库,本地为空(应用)\n\n+ 步骤\n  1. 将远程仓库的代码，克隆到本地仓库\n    克隆命令：git clone 仓库地址\n  2. 创建新文件，添加并提交到本地仓库\n  3. 推送至远程仓库\n  4. 项目拉取更新\n    拉取命令：git pull 远程仓库名 分支名\n\n### 5.6代码冲突(应用)\n\n+ 产生原因:\n\n  两个程序员操作同一个文件,其中一个程序员在修改文件后,push到远程仓库,另一个程序员应该先pull将最新的代码更新到本地仓库后,在修改代码,之后push到远程仓库,结果他没有先pull将最新的代码更新到本地仓库,而是直接将自己的代码push到远程仓库,这样就可能会导致代码冲突\n\n![61_代码冲突](./img/java/basics/day10-Git.img/61_代码冲突.png)\n\n\n\n![62_代码冲突](./img/java/basics/day10-Git.img/62_代码冲突.png)\n\n![63_代码冲突](./img/java/basics/day10-Git.img/63_代码冲突.png)\n\n+ 如何解决冲突\n\n  <<<<<<<和>>>>>>>中间的内容,就是冲突部分\n\n  1. 修改冲突行，保存，即可解决冲突。\n  2. 重新add冲突文件并commit到本地仓库，重新push到远程\n\n## 6.IDEA集成Git \n\n### 6.1IDEA中配置Git(应用)\n\n1. File -> Settings\n\n![64_IDEA中配置Git](./img/java/basics/day10-Git.img/64_IDEA中配置Git.png)\n\n2. Version Control -> Git -> 指定git.exe存放目录\n\n![65_IDEA中配置Git](./img/java/basics/day10-Git.img/65_IDEA中配置Git.png)\n\n3. 点击Test测试\n\n![66_IDEA中配置Git](./img/java/basics/day10-Git.img/66_IDEA中配置Git.png)\n\n### 6.2创建本地仓库(应用)\n\n1. VCS->Import into Version Control->Create Git Repository\n\n   ![67_创建本地仓库](./img/java/basics/day10-Git.img/67_创建本地仓库.png)\n\n2. 选择工程所在的目录,这样就创建好本地仓库了\n\n   ![68_创建本地仓库](./img/java/basics/day10-Git.img/68_创建本地仓库.png)\n\n3. 点击git后边的对勾,将当前项目代码提交到本地仓库\n\n   注意: 项目中的配置文件不需要提交到本地仓库中,提交时,忽略掉即可\n\n   ![69_创建本地仓库](./img/java/basics/day10-Git.img/69_创建本地仓库.png)\n\n### 6.3版本切换(应用)\n\n+ 方式一: 控制台Version Control->Log->Reset Current Branch...->Reset\n\n  这种切换的特点是会抛弃原来的提交记录\n\n  ![70_版本切换](./img/java/basics/day10-Git.img/70_版本切换.png)\n\n+ 方式二:控制台Version Control->Log->Revert Commit->Merge->处理代码->commit\n\n  这种切换的特点是会当成一个新的提交记录,之前的提交记录也都保留\n\n  ![71_版本切换](./img/java/basics/day10-Git.img/71_版本切换.png)\n\n  ![72_版本切换](./img/java/basics/day10-Git.img/72_版本切换.png)\n\n  ​\t\t![73_版本切换](./img/java/basics/day10-Git.img/73_版本切换.png)\n\n\n\n### 6.4分支管理(应用)\n\n+ 创建分支\n\n  VCS->Git->Branches->New Branch->给分支起名字->ok\n\n  ![74_创建分支](./img/java/basics/day10-Git.img/74_创建分支.png)\n\n+ 切换分支\n\n  idea右下角Git->选择要切换的分支->checkout\n\n  ![75_切换分支](./img/java/basics/day10-Git.img/75_切换分支.png)\n\n+ 合并分支\n\n  VCS->Git->Merge changes->选择要合并的分支->merge\n\n  ![76_合并分支](./img/java/basics/day10-Git.img/76_合并分支.png)\n\n  处理分支中的代码\n\n  ![77_合并分支](./img/java/basics/day10-Git.img/77_合并分支.png)\n\n  ![78_合并分支](./img/java/basics/day10-Git.img/78_合并分支.png)\n\n  ![79_合并分支](./img/java/basics/day10-Git.img/79_合并分支.png)\n\n+ 删除分支\n\n  idea右下角->选中要删除的分支->Delete\n\n  ![80_删除分支](./img/java/basics/day10-Git.img/80_删除分支.png)\n\n### 6.5本地仓库推送到远程仓库(应用)\n\n1. VCS->Git->Push->点击master Define remote\n\n   ![81_本地仓库推送到远程仓库](./img/java/basics/day10-Git.img/81_本地仓库推送到远程仓库.png)\n\n2. 将远程仓库的路径复制过来->Push\n\n   ![82_本地仓库推送到远程仓库](./img/java/basics/day10-Git.img/82_本地仓库推送到远程仓库.png)\n\n### 6.6远程仓库克隆到本地仓库(应用)\n\nFile->Close Project->Checkout from Version Control->Git->指定远程仓库的路径->指定本地存放的路径->clone\n\n![83_远程仓库克隆到本地仓库](./img/java/basics/day10-Git.img/83_远程仓库克隆到本地仓库.png)\n\n\n\n\n\n\n\n\n\n",Y={data:function(){return{MainComponent:X}}},Z=Y,nn=Object(d["a"])(Z,K,$,!1,null,"2139937c",null),en=nn.exports,tn=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent1}}),t("q-markdown",{attrs:{src:n.MainComponent2}}),t("q-markdown",{attrs:{src:n.MainComponent3}})],1)},rn=[],an='## 1.案例驱动模式\n\n### 1.1案例驱动模式概述 (理解)\n\n通过我们已掌握的知识点,先实现一个案例,然后找出这个案例中,存在的一些问题,在通过新知识点解决问题\n\n### 1.2案例驱动模式的好处 (理解)\n\n+ 解决重复代码过多的冗余,提高代码的复用性\n+ 解决业务逻辑聚集紧密导致的可读性差,提高代码的可读性\n+ 解决代码可维护性差,提高代码的维护性\n\n## 2.分类思想 \n\n### 2.1分类思想概述 (理解) \n\n分工协作,专人干专事\n\n### 2.2黑马信息管理系统 (理解)\n\n+ Student类  标准学生类,封装键盘录入的学生信息(id , name , age , birthday)\n\n+ StudentDao类  Dao : (Data Access Object 缩写) 用于访问存储数据的数组或集合\n\n+ StudentService类  用来进行业务逻辑的处理(例如: 判断录入的id是否存在)\n\n+ StudentController类  和用户打交道(接收用户需求,采集用户信息,打印数据到控制台)\n\n  ![01_黑马信息管理系统分类](./img/java/basics/day11-分类和static.img/01_黑马信息管理系统分类.png)\n\n## 3.分包思想\n\n### 3.1分包思想概述 (理解)\n\n如果将所有的类文件都放在同一个包下,不利于管理和后期维护,所以,对于不同功能的类文件,可以放在不同的包下进行管理\n\n### 3.2包的概述 (记忆)\n\n+ 包\n\n  本质上就是文件夹\n\n+ 创建包\n\n  多级包之间使用 " . " 进行分割\n  多级包的定义规范：公司的网站地址翻转(去掉www)\n  比如：黑马程序员的网站址为www.itheima.com\n  后期我们所定义的包的结构就是：com.itheima.其他的包名\n\n+ 包的命名规则\n\n  字母都是小写\n\n### 3.3包的注意事项 (理解) \n\n+ package语句必须是程序的第一条可执行的代码 \n+ package语句在一个java文件中只能有一个 \n+ 如果没有package,默认表示无包名 \n\n### 3.4类与类之间的访问 (理解) \n\n+ 同一个包下的访问\n\n  不需要导包，直接使用即可\n\n+ 不同包下的访问\n\n  1.import 导包后访问\n\n  2.通过全类名（包名 + 类名）访问\n\n+ 注意：import 、package 、class 三个关键字的摆放位置存在顺序关系\n\n  package 必须是程序的第一条可执行的代码\n\n  import 需要写在 package 下面\n\n  class 需要在 import 下面\n\n## 4.黑马信息管理系统\n\n### 4.1系统介绍 (理解) \n\n![02_黑马信息管理系统介绍](./img/java/basics/day11-分类和static.img/02_黑马信息管理系统介绍.png)\n\n### 4.2学生管理系统 (应用) \n\n#### 4.2.1需求说明\n\n+ 添加学生: 键盘录入学生信息(id，name，age，birthday)\n\n  使用数组存储学生信息,要求学生的id不能重复\n\n+ 删除学生: 键盘录入要删除学生的id值,将该学生从数组中移除,如果录入的id在数组中不存在,需要重新录入\n\n+ 修改学生: 键盘录入要修改学生的id值和修改后的学生信息\n\n  将数组中该学生的信息修改,如果录入的id在数组中不存在,需要重新录入\n\n+ 查询学生: 将数组中存储的所有学生的信息输出到控制台\n\n#### 4.2.2实现步骤\n\n+ 环境搭建实现步骤 \n  | 包                                       | 存储的类                   | 作用                   |\n  | --------------------------------------- | ---------------------- | -------------------- |\n  | com.itheima.edu.info.manager.domain     | Student.java           | 封装学生信息               |\n  | com.itheima.edu.info.manager.dao        | StudentDao.java        | 访问存储数据的数组，进行赠删改查（库管） |\n  | com.itheima.edu.info.manager.service    | StudentService.java    | 业务的逻辑处理（业务员）         |\n  | com.itheima.edu.info.manager.controller | StudentController.java | 和用户打交道（客服接待）         |\n  | com.itheima.edu.info.manager.entry      | InfoManagerEntry.java  | 程序的入口类，提供一个main方法    |\n\n+ 菜单搭建实现步骤 \n\n  + 需求\n    + 黑马管理系统菜单搭建\n    + 学生管理系统菜单搭建\n  + 实现步骤\n    1. 展示欢迎页面,用输出语句完成主界面的编写\n    2. 获取用户的选择,用Scanner实现键盘录入数据\n    3. 根据用户的选择执行对应的操作,用switch语句完成操作的选择\n\n+ 添加功能实现步骤 \n\n  ![03_添加功能需求分析](./img/java/basics/day11-分类和static.img/03_添加功能需求分析.png)\n\n\n+ 添加功能优化:判断id是否存在\n\n  ![04_判断id是否存在](./img/java/basics/day11-分类和static.img/04_判断id是否存在.png)\n\n+ 查询功能实现步骤\n\n  ![05_查询功能需求分析](./img/java/basics/day11-分类和static.img/05_查询功能需求分析.png)\n\n+ 删除功能实现步骤\n\n  ![06_删除功能需求分析](./img/java/basics/day11-分类和static.img/06_删除功能需求分析.png)\n\n+ 修改功能实现步骤 \n\n  ![07_修改功能需求分析](./img/java/basics/day11-分类和static.img/07_修改功能需求分析.png)\n\n+ 系统优化 \n\n  + 把updateStudent和deleteStudentById中录入学生id代码抽取到一个方法(inputStudentId)中\n    该方法的主要作用就是录入学生的id，方法的返回值为String类型\n\n\n  + 把addStudent和updateStudent中录入学生信息的代码抽取到一个方法(inputStudentInfo)中\n    该方法的主要作用就是录入学生的信息，并封装为学生对象，方法的返回值为Student类型 \n\n#### 4.2.3代码实现 \n\n学生类\n\n```java\npublic class Student {\n    private String id;\n    private String name;\n    private String age;\n    private String birthday;\n    String address;\n\n    public Student() {\n    }\n\n    public Student(String id, String name, String age, String birthday) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n        this.birthday = birthday;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getAge() {\n        return age;\n    }\n\n    public void setAge(String age) {\n        this.age = age;\n    }\n\n    public String getBirthday() {\n        return birthday;\n    }\n\n    public void setBirthday(String birthday) {\n        this.birthday = birthday;\n    }\n\n}\n```\n\n程序入口InfoManagerEntry类\n\n```java\npublic class InfoManagerEntry {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            // 主菜单搭建\n            System.out.println("--------欢迎来到黑马信息管理系统--------");\n            System.out.println("请输入您的选择: 1.学生管理  2.老师管理  3.退出");\n            String choice = sc.next();\n            switch (choice) {\n                case "1":\n                    // System.out.println("学生管理");\n                    // 开启学生管理系统\n                    StudentController studentController = new StudentController();\n                    studentController.start();\n                    break;\n                case "2":\n                    System.out.println("老师管理");\n                    TeacherController teacherController = new TeacherController();\n                    teacherController.start();\n                    break;\n                case "3":\n                    System.out.println("感谢您的使用");\n                    // 退出当前正在运行的JVM虚拟机\n                    System.exit(0);\n                    break;\n                default:\n                    System.out.println("您的输入有误, 请重新输入");\n                    break;\n            }\n        }\n    }\n}\n```\n\nStudentController类\n\n```java\npublic class StudentController {\n    // 业务员对象\n    private StudentService studentService = new StudentService();\n\n    private Scanner sc = new Scanner(System.in);\n\n    // 开启学生管理系统, 并展示学生管理系统菜单\n    public void start() {\n        //Scanner sc = new Scanner(System.in);\n        studentLoop:\n        while (true) {\n            System.out.println("--------欢迎来到 <学生> 管理系统--------");\n            System.out.println("请输入您的选择: 1.添加学生  2.删除学生  3.修改学生  4.查看学生  5.退出");\n            String choice = sc.next();\n            switch (choice) {\n                case "1":\n                    // System.out.println("添加");\n                    addStudent();\n                    break;\n                case "2":\n                    // System.out.println("删除");\n                    deleteStudentById();\n                    break;\n                case "3":\n                    // System.out.println("修改");\n                    updateStudent();\n                    break;\n                case "4":\n                    // System.out.println("查询");\n                    findAllStudent();\n                    break;\n                case "5":\n                    System.out.println("感谢您使用学生管理系统, 再见!");\n                    break studentLoop;\n                default:\n                    System.out.println("您的输入有误, 请重新输入");\n                    break;\n            }\n        }\n    }\n\n    // 修改学生方法\n    public void updateStudent() {\n        String updateId = inputStudentId();\n        Student newStu = inputStudentInfo(updateId);\n        studentService.updateStudent(updateId, newStu);\n\n        System.out.println("修改成功!");\n    }\n\n    // 删除学生方法\n    public void deleteStudentById() {\n        String delId = inputStudentId();\n        // 3. 调用业务员中的deleteStudentById根据id, 删除学生\n        studentService.deleteStudentById(delId);\n        // 4. 提示删除成功\n        System.out.println("删除成功!");\n    }\n\n    // 查看学生方法\n    public void findAllStudent() {\n        // 1. 调用业务员中的获取方法, 得到学生的对象数组\n        Student[] stus = studentService.findAllStudent();\n        // 2. 判断数组的内存地址, 是否为null\n        if (stus == null) {\n            System.out.println("查无信息, 请添加后重试");\n            return;\n        }\n        // 3. 遍历数组, 获取学生信息并打印在控制台\n        System.out.println("学号\\t\\t姓名\\t年龄\\t生日");\n        for (int i = 0; i < stus.length; i++) {\n            Student stu = stus[i];\n            if (stu != null) {\n                System.out.println(stu.getId() + "\\t" + stu.getName() + "\\t" + stu.getAge() + "\\t\\t" + stu.getBirthday());\n            }\n        }\n    }\n\n    // 添加学生方法\n    public void addStudent() {\n        // StudentService studentService = new StudentService();\n        // 1. 键盘接收学生信息\n        String id;\n        while (true) {\n            System.out.println("请输入学生id:");\n            id = sc.next();\n            boolean flag = studentService.isExists(id);\n            if (flag) {\n                System.out.println("学号已被占用, 请重新输入");\n            } else {\n                break;\n            }\n        }\n\n        Student stu = inputStudentInfo(id);\n\n        // 3. 将学生对象,传递给StudentService(业务员)中的addStudent方法\n        boolean result = studentService.addStudent(stu);\n        // 4. 根据返回的boolean类型结果, 在控制台打印成功\\失败\n        if (result) {\n            System.out.println("添加成功");\n        } else {\n            System.out.println("添加失败");\n        }\n    }\n\n    // 键盘录入学生id\n    public String inputStudentId() {\n        String id;\n        while (true) {\n            System.out.println("请输入学生id:");\n            id = sc.next();\n            boolean exists = studentService.isExists(id);\n            if (!exists) {\n                System.out.println("您输入的id不存在, 请重新输入:");\n            } else {\n                break;\n            }\n        }\n        return id;\n    }\n\n    // 键盘录入学生信息\n    public Student inputStudentInfo(String id) {\n        System.out.println("请输入学生姓名:");\n        String name = sc.next();\n        System.out.println("请输入学生年龄:");\n        String age = sc.next();\n        System.out.println("请输入学生生日:");\n        String birthday = sc.next();\n        Student stu = new Student();\n        stu.setId(id);\n        stu.setName(name);\n        stu.setAge(age);\n        stu.setBirthday(birthday);\n        return stu;\n    }\n}\n```\n\nStudentService类\n\n```java\npublic class StudentService {\n    // 创建StudentDao (库管)\n    private StudentDao studentDao = new StudentDao();\n    // 添加学生方法\n    public boolean addStudent(Student stu) {\n        // 2. 将学生对象, 传递给StudentDao 库管中的addStudent方法\n        // 3. 将返回的boolean类型结果, 返还给StudentController\n        return studentDao.addStudent(stu);\n    }\n    // 判断学号是否存在方法\n    public boolean isExists(String id) {\n        Student[] stus = studentDao.findAllStudent();\n        // 假设id在数组中不存在\n        boolean exists = false;\n        // 遍历数组, 获取每一个学生对象, 准备进行判断\n        for (int i = 0; i < stus.length; i++) {\n            Student student = stus[i];\n            if(student != null && student.getId().equals(id)){\n                exists = true;\n                break;\n            }\n        }\n\n        return exists;\n    }\n    // 查看学生方法\n    public Student[] findAllStudent() {\n        // 1. 调用库管对象的findAllStudent获取学生对象数组\n        Student[] allStudent = studentDao.findAllStudent();\n        // 2. 判断数组中是否有学生信息 (有: 返回地址,  没有: 返回null)\n        // 思路: 数组中只要存在一个不是null的元素, 那就代表有学生信息\n        boolean flag = false;\n        for (int i = 0; i < allStudent.length; i++) {\n            Student stu = allStudent[i];\n            if(stu != null){\n                flag = true;\n                break;\n            }\n        }\n\n        if(flag){\n            // 有信息\n            return allStudent;\n        }else{\n            // 没有信息\n            return null;\n        }\n\n    }\n\n    public void deleteStudentById(String delId) {\n        studentDao.deleteStudentById(delId);\n    }\n\n    public void updateStudent(String updateId, Student newStu) {\n        studentDao.updateStudent(updateId, newStu);\n    }\n}\n```\n\nStudentDao类\n\n```java\npublic class StudentDao {\n    // 创建学生对象数组\n    private static Student[] stus = new Student[5];\n    // 添加学生方法\n    public boolean addStudent(Student stu) {\n\n        // 2. 添加学生到数组\n        //2.1 定义变量index为-1，假设数组已经全部存满，没有null的元素\n        int index = -1;\n        //2.2 遍历数组取出每一个元素，判断是否是null\n        for (int i = 0; i < stus.length; i++) {\n            Student student = stus[i];\n            if(student == null){\n                index = i;\n                //2.3 如果为null，让index变量记录当前索引位置，并使用break结束循环遍历\n                break;\n            }\n        }\n\n        // 3. 返回是否添加成功的boolean类型状态\n        if(index == -1){\n            // 装满了\n            return false;\n        }else{\n            // 没有装满, 正常添加, 返回true\n            stus[index] = stu;\n            return true;\n        }\n    }\n    // 查看学生方法\n    public Student[] findAllStudent() {\n        return stus;\n    }\n\n    public void deleteStudentById(String delId) {\n        // 1. 查找id在容器中所在的索引位置\n        int index = getIndex(delId);\n        // 2. 将该索引位置,使用null元素进行覆盖\n        stus[index] = null;\n    }\n\n    public int getIndex(String id){\n        int index = -1;\n        for (int i = 0; i < stus.length; i++) {\n            Student stu = stus[i];\n            if(stu != null && stu.getId().equals(id)){\n                index = i;\n                break;\n            }\n        }\n        return index;\n    }\n\n    public void updateStudent(String updateId, Student newStu) {\n        // 1. 查找updateId, 在容器中的索引位置\n        int index = getIndex(updateId);\n        // 2. 将该索引位置, 使用新的学生对象替换\n        stus[index] = newStu;\n    }\n}\n```\n\n### 4.3老师管理系统 (应用) \n\n#### 4.3.1需求说明 \n\n+ 添加老师: 通过键盘录入老师信息(id，name，age，birthday)\n\n  使用数组存储老师信息,要求老师的id不能重复\n\n+ 删除老师: 通过键盘录入要删除老师的id值,将该老师从数组中移除,如果录入的id在数组中不存在,需要重新录入\n\n+ 修改老师: 通过键盘录入要修改老师的id值和修改后的老师信息\n\n  将数组中该老师的信息修改,如果录入的id在数组中不存在,需要重新录入\n\n+ 查询老师: 将数组中存储的所有老师的信息输出到控制台\n\n#### 4.3.2实现步骤 \n\n+ 环境搭建实现步骤\n\n  | 包                                       | 存储的类                                     | 作用                   |\n  | --------------------------------------- | ---------------------------------------- | -------------------- |\n  | com.itheima.edu.info.manager.domain     | Student.java   Teacher.java              | 封装学生信息  封装老师信息       |\n  | com.itheima.edu.info.manager.dao        | StudentDao.java  TeacherDao.java         | 访问存储数据的数组,进行赠删改查（库管） |\n  | com.itheima.edu.info.manager.service    | StudentService.java  TeacherService.java | 业务的逻辑处理（业务员）         |\n  | com.itheima.edu.info.manager.controller | StudentController.java  TeacherController.java | 和用户打交道（客服接待）         |\n  | com.itheima.edu.info.manager.entry      | InfoManagerEntry.java                    | 程序的入口类,提供一个main方法    |\n\n+ 菜单搭建实现步骤\n\n  1. 展示欢迎页面,用输出语句完成主界面的编写\n  2. 获取用户的选择,用Scanner实现键盘录入数据\n  3. 根据用户的选择执行对应的操作,用switch语句完成操作的选择\n\n+ 添加功能实现步骤\n\n  ![10_添加老师功能实现步骤](./img/java/basics/day11-分类和static.img/10_添加老师功能实现步骤.png)\n\n+ 查询功能实现步骤\n\n  ![11_查询老师功能实现步骤](./img/java/basics/day11-分类和static.img/11_查询老师功能实现步骤.png)\n\n+ 删除功能实现步骤\n\n  ![12_删除老师功能实现步骤](./img/java/basics/day11-分类和static.img/12_删除老师功能实现步骤.png)\n\n+ 修改功能实现步骤\n\n  ![13_修改老师功能实现步骤](./img/java/basics/day11-分类和static.img/13_修改老师功能实现步骤.png)\n\n+ 系统优化\n\n  + 把updateTeacher和deleteTeacherById中录入老师id代码抽取到一个方法(inputTeacherId)中\n    该方法的主要作用就是录入老师的id,方法的返回值为String类型\n  + 把addTeacher和updateTeacher中录入老师信息的代码抽取到一个方法(inputTeacherInfo)中\n    该方法的主要作用就是录入老师的信息,并封装为老师对象,方法的返回值为Teacher类型\n\n#### 4.3.3代码实现\n\n老师类\n\n```java\npublic class Teacher extends Person{\n\tprivate String id;\n    private String name;\n    private String age;\n    private String birthday;\n    String address;\n\n    public Teacher() {\n    }\n\n    public Teacher(String id, String name, String age, String birthday) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n        this.birthday = birthday;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getAge() {\n        return age;\n    }\n\n    public void setAge(String age) {\n        this.age = age;\n    }\n\n    public String getBirthday() {\n        return birthday;\n    }\n\n    public void setBirthday(String birthday) {\n        this.birthday = birthday;\n    }\n}\n```\n\nTeacherController类\n\n```java\npublic class TeacherController {\n\n    private Scanner sc = new Scanner(System.in);\n    private TeacherService teacherService = new TeacherService();\n\n    public void start() {\n\n        teacherLoop:\n        while (true) {\n            System.out.println("--------欢迎来到 <老师> 管理系统--------");\n            System.out.println("请输入您的选择: 1.添加老师  2.删除老师  3.修改老师  4.查看老师  5.退出");\n            String choice = sc.next();\n            switch (choice) {\n                case "1":\n                    // System.out.println("添加老师");\n                    addTeacher();\n                    break;\n                case "2":\n                    // System.out.println("删除老师");\n                    deleteTeacherById();\n                    break;\n                case "3":\n                    // System.out.println("修改老师");\n                    updateTeacher();\n                    break;\n                case "4":\n                    // System.out.println("查看老师");\n                    findAllTeacher();\n                    break;\n                case "5":\n                    System.out.println("感谢您使用老师管理系统, 再见!");\n                    break teacherLoop;\n                default:\n                    System.out.println("您的输入有误, 请重新输入");\n                    break;\n            }\n        }\n\n    }\n\n    public void updateTeacher() {\n        String id = inputTeacherId();\n\n        Teacher newTeacher = inputTeacherInfo(id);\n\n        // 调用业务员的修改方法\n        teacherService.updateTeacher(id,newTeacher);\n        System.out.println("修改成功");\n    }\n\n    public void deleteTeacherById() {\n\n        String id = inputTeacherId();\n\n        // 2. 调用业务员中的删除方法, 根据id, 删除老师\n        teacherService.deleteTeacherById(id);\n\n        // 3. 提示删除成功\n        System.out.println("删除成功");\n\n\n    }\n\n    public void findAllTeacher() {\n        // 1. 从业务员中, 获取老师对象数组\n        Teacher[] teachers = teacherService.findAllTeacher();\n\n        // 2. 判断数组中是否有元素\n        if (teachers == null) {\n            System.out.println("查无信息, 请添加后重试");\n            return;\n        }\n\n        // 3. 遍历数组, 取出元素, 并打印在控制台\n        System.out.println("学号\\t\\t姓名\\t年龄\\t生日");\n        for (int i = 0; i < teachers.length; i++) {\n            Teacher t = teachers[i];\n            if (t != null) {\n                System.out.println(t.getId() + "\\t" + t.getName() + "\\t" + t.getAge() + "\\t\\t" + t.getBirthday());\n            }\n        }\n    }\n\n    public void addTeacher() {\n        String id;\n        while (true) {\n            // 1. 接收不存在的老师id\n            System.out.println("请输入老师id:");\n            id = sc.next();\n            // 2. 判断id是否存在\n            boolean exists = teacherService.isExists(id);\n\n            if (exists) {\n                System.out.println("id已被占用, 请重新输入:");\n            } else {\n                break;\n            }\n        }\n\n        Teacher t = inputTeacherInfo(id);\n\n        // 5. 将封装好的老师对象, 传递给TeacherService继续完成添加操作\n        boolean result = teacherService.addTeacher(t);\n\n        if (result) {\n            System.out.println("添加成功");\n        } else {\n            System.out.println("添加失败");\n        }\n    }\n\n    // 录入老师id\n    public String inputTeacherId(){\n        String id;\n        while(true){\n            System.out.println("请输入id");\n            id = sc.next();\n            boolean exists = teacherService.isExists(id);\n            if(!exists){\n                System.out.println("您输入的id不存在, 请重新输入:");\n            }else{\n                break;\n            }\n        }\n        return id;\n    }\n\n    // 录入老师信息, 封装为老师对象\n    public Teacher inputTeacherInfo(String id){\n        System.out.println("请输入老师姓名:");\n        String name = sc.next();\n        System.out.println("请输入老师年龄:");\n        String age = sc.next();\n        System.out.println("请输入老师生日:");\n        String birthday = sc.next();\n\n        Teacher t = new Teacher();\n        t.setId(id);\n        t.setName(name);\n        t.setAge(age);\n        t.setBirthday(birthday);\n\n        return t;\n    }\n}\n```\n\nTeacherService类\n\n```java\npublic class TeacherService {\n\n    private TeacherDao teacherDao = new TeacherDao();\n\n    public boolean addTeacher(Teacher t) {\n        return teacherDao.addTeacher(t);\n    }\n\n    public boolean isExists(String id) {\n        // 1. 获取库管对象中的数组\n        Teacher[] teachers = teacherDao.findAllTeacher();\n\n        boolean exists = false;\n\n        // 2. 遍历数组, 取出每一个元素, 进行判断\n        for (int i = 0; i < teachers.length; i++) {\n            Teacher teacher = teachers[i];\n            if(teacher != null && teacher.getId().equals(id)){\n                exists = true;\n                break;\n            }\n        }\n\n        return exists;\n    }\n\n    public Teacher[] findAllTeacher() {\n        Teacher[] allTeacher = teacherDao.findAllTeacher();\n\n        boolean flag = false;\n\n        for (int i = 0; i < allTeacher.length; i++) {\n            Teacher t = allTeacher[i];\n            if(t != null){\n                flag = true;\n                break;\n            }\n        }\n\n        if(flag){\n            return allTeacher;\n        }else{\n            return null;\n        }\n\n    }\n\n    public void deleteTeacherById(String id) {\n        teacherDao.deleteTeacherById(id);\n    }\n\n    public void updateTeacher(String id, Teacher newTeacher) {\n        teacherDao.updateTeacher(id,newTeacher);\n    }\n}\n```\n\nTeacherDao类\n\n```java\npublic class TeacherDao {\n\n    private static Teacher[] teachers = new Teacher[5];\n\n    public boolean addTeacher(Teacher t) {\n        int index = -1;\n        for (int i = 0; i < teachers.length; i++) {\n            Teacher teacher = teachers[i];\n            if(teacher == null){\n                index = i;\n                break;\n            }\n        }\n\n        if(index == -1){\n            return false;\n        }else{\n            teachers[index] = t;\n            return true;\n        }\n\n    }\n\n    public Teacher[] findAllTeacher() {\n        return teachers;\n    }\n\n    public void deleteTeacherById(String id) {\n        // 1. 查询id在数组中的索引位置\n        int index = getIndex(id);\n        // 2. 将该索引位置的元素, 使用null进行替换\n        teachers[index] = null;\n    }\n\n    public int getIndex(String id){\n        int index = -1;\n        for (int i = 0; i < teachers.length; i++) {\n            Teacher t = teachers[i];\n            if(t != null && t.getId().equals(id)){\n                index = i;\n                break;\n            }\n        }\n\n        return index;\n    }\n\n    public void updateTeacher(String id, Teacher newTeacher) {\n        int index = getIndex(id);\n        teachers[index] = newTeacher;\n    }\n}\n```\n\n## 5.static关键字\n\n### 5.1static关键字概述 (理解)\n\nstatic 关键字是静态的意思,是Java中的一个修饰符,可以修饰成员方法,成员变量\n\n### 5.2static修饰的特点 (记忆) \n\n+ 被类的所有对象共享\n\n  是我们判断是否使用静态关键字的条件\n\n+ 随着类的加载而加载，优先于对象存在\n\n  对象需要类被加载后，才能创建\n\n+ 可以通过类名调用\n\n  也可以通过对象名调用\n\n### 5.3static关键字注意事项 (理解)\n\n+ 静态方法只能访问静态的成员\n+ 非静态方法可以访问静态的成员，也可以访问非静态的成员\n+ 静态方法中是没有this关键字 ',sn='## 1. 继承\n\n### 1.1 继承的实现（掌握）\n\n- 继承的概念\n\n  - 继承是面向对象三大特征之一，可以使得子类具有父类的属性和方法，还可以在子类中重新定义，以及追加属性和方法\n\n- 实现继承的格式\n\n  - 继承通过extends实现\n  - 格式：class 子类 extends 父类 { } \n    - 举例：class Dog extends Animal { }\n\n- 继承带来的好处\n\n  - 继承可以让类与类之间产生关系，子父类关系，产生子父类后，子类则可以使用父类中非私有的成员。\n\n- 示例代码\n\n  ```java\n  public class Fu {\n      public void show() {\n          System.out.println("show方法被调用");\n      }\n  }\n  public class Zi extends Fu {\n      public void method() {\n          System.out.println("method方法被调用");\n      }\n  }\n  public class Demo {\n      public static void main(String[] args) {\n          //创建对象，调用方法\n          Fu f = new Fu();\n          f.show();\n\n          Zi z = new Zi();\n          z.method();\n          z.show();\n      }\n  }\n  ```\n\n### 1.2 继承的好处和弊端（理解）\n\n- 继承好处\n  - 提高了代码的复用性(多个类相同的成员可以放到同一个类中)\n  - 提高了代码的维护性(如果方法的代码需要修改，修改一处即可)\n- 继承弊端\n  - 继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性\n- 继承的应用场景：\n  - 使用继承，需要考虑类与类之间是否存在is..a的关系，不能盲目使用继承\n    - is..a的关系：谁是谁的一种，例如：老师和学生是人的一种，那人就是父类，学生和老师就是子类\n\n### 1.3. Java中继承的特点（掌握）\n\n- Java中继承的特点\n\n  1. Java中类只支持单继承，不支持多继承\n     - 错误范例：class A extends B, C { }\n  2. Java中类支持多层继承\n\n- 多层继承示例代码：\n\n  ```java\n  public class Granddad {\n\n      public void drink() {\n          System.out.println("爷爷爱喝酒");\n      }\n\n  }\n\n  public class Father extends Granddad {\n\n      public void smoke() {\n          System.out.println("爸爸爱抽烟");\n      }\n\n  }\n\n  public class Mother {\n\n      public void dance() {\n          System.out.println("妈妈爱跳舞");\n      }\n\n  }\n  public class Son extends Father {\n  \t// 此时，Son类中就同时拥有drink方法以及smoke方法\n  }\n  ```\n\n## 2. 继承中的成员访问特点\n\n### 2.1 继承中变量的访问特点（掌握）\n\n在子类方法中访问一个变量，采用的是就近原则。\n\n1. 子类局部范围找\n2. 子类成员范围找\n3. 父类成员范围找\n4. 如果都没有就报错(不考虑父亲的父亲…)\n\n- 示例代码\n\n  ```java\n  class Fu {\n      int num = 10;\n  }\n  class Zi {\n      int num = 20;\n      public void show(){\n          int num = 30;\n          System.out.println(num);\n      }\n  }\n  public class Demo1 {\n      public static void main(String[] args) {\n          Zi z = new Zi();\n          z.show();\t// 输出show方法中的局部变量30\n      }\n  }\n  ```\n\n### 2.2 super（掌握）\n\n- this&super关键字：\n  - this：代表本类对象的引用\n  - super：代表父类存储空间的标识(可以理解为父类对象引用)\n- this和super的使用分别\n  - 成员变量：\n    - this.成员变量    -   访问本类成员变量\n    - super.成员变量 -   访问父类成员变量\n  - 成员方法：\n    - this.成员方法  - 访问本类成员方法\n    - super.成员方法 - 访问父类成员方法\n- 构造方法：\n  - this(…)  -  访问本类构造方法\n  - super(…)  -  访问父类构造方法\n\n### 2.3 继承中构造方法的访问特点（理解）\n\n**注意：子类中所有的构造方法默认都会访问父类中无参的构造方法**\n\n​\t子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化，原因在于，每一个子类构造方法的第一条语句默认都是：super()\n\n**问题：如果父类中没有无参构造方法，只有带参构造方法，该怎么办呢？**\n\n```\n1. 通过使用super关键字去显示的调用父类的带参构造方法\n2. 子类通过this去调用本类的其他构造方法,本类其他构造方法再通过super去手动调用父类的带参的构造方法\n\n注意: this(…)super(…) 必须放在构造方法的第一行有效语句，并且二者不能共存\n```\n\n### 2.4 继承中成员方法的访问特点（掌握）\n\n通过子类对象访问一个方法\n\n1. 子类成员范围找\n2. 父类成员范围找\n3. 如果都没有就报错(不考虑父亲的父亲…)\n\n### 2.5 super内存图（理解）\n\n- 对象在堆内存中，会单独存在一块super区域，用来存放父类的数据 \n\n  ![01_super内存图](./img/java/basics/day12-继承.img/01_super内存图.png)\n\n### 2.6 方法重写（掌握）\n\n- 1、方法重写概念\n  - 子类出现了和父类中一模一样的方法声明（方法名一样，参数列表也必须一样）\n- 2、方法重写的应用场景\n  - 当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容\n- 3、Override注解\n  - 用来检测当前的方法，是否是重写的方法，起到【校验】的作用\n\n### 2.7 方法重写的注意事项（掌握）\n\n- 方法重写的注意事项\n\n1. 私有方法不能被重写(父类私有成员子类是不能继承的)\n2. 子类方法访问权限不能更低(public > 默认 > 私有)\n3. 静态方法不能被重写,如果子类也有相同的方法,并不是重写的父类的方法\n\n- 示例代码\n\n```java\npublic class Fu {\n    private void show() {\n        System.out.println("Fu中show()方法被调用");\n    }\n\n    void method() {\n        System.out.println("Fu中method()方法被调用");\n    }\n}\n\npublic class Zi extends Fu {\n\n    /* 编译【出错】，子类不能重写父类私有的方法*/\n    @Override\n    private void show() {\n        System.out.println("Zi中show()方法被调用");\n    }\n   \n    /* 编译【出错】，子类重写父类方法的时候，访问权限需要大于等于父类 */\n    @Override\n    private void method() {\n        System.out.println("Zi中method()方法被调用");\n    }\n\n    /* 编译【通过】，子类重写父类方法的时候，访问权限需要大于等于父类 */\n    @Override\n    public void method() {\n        System.out.println("Zi中method()方法被调用");\n    }\n}\n```\n\n### 2.8 权限修饰符 (理解) \n\n![02_权限修饰符](./img/java/basics/day12-继承.img/02_权限修饰符.png)\n\n### 2.9 黑马信息管理系统使用继承改进 (掌握) \n\n+ 需求\n\n  把学生类和老师类共性的内容向上抽取,抽取到出一个 Person 父类,让学生类和老师类继承 Person 类\n\n+ 实现步骤\n\n  1. 抽取Person类\n\n  2. 优化StudentController类中，inputStudentInfo方法，将setXxx赋值方式，改进为构造方法初始化\n\n     注意：直接修改这种操作方式，不符合我们开发中的一个原则\n\n     ​\t开闭原则 ( 对扩展开放对修改关闭 ) : 尽量在不更改原有代码的前提下以完成需求 \n\n     解决：重新创建一个OtherStudentController类\n\n     编写新的inputStudentInfo方法\n\n  3. 根据StudentController类、OtherStudentController类，向上抽取出BaseStudentController类\n     再让StudentController类、OtherStudentController类，继承BaseStudentController类\n\n+ 代码实现\n\n  Person类及学生类和老师类\n\n  ```java\n  public class Person {\n      private String id;\n      private String name;\n      private String age;\n      private String birthday;\n\n      public Person() {\n      }\n\n      public Person(String id, String name, String age, String birthday) {\n          this.id = id;\n          this.name = name;\n          this.age = age;\n          this.birthday = birthday;\n      }\n\n      public String getId() {\n          return id;\n      }\n\n      public void setId(String id) {\n          this.id = id;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public String getAge() {\n          return age;\n      }\n\n      public void setAge(String age) {\n          this.age = age;\n      }\n\n      public String getBirthday() {\n          return birthday;\n      }\n\n      public void setBirthday(String birthday) {\n          this.birthday = birthday;\n      }\n  }\n  // Student类\n  public class Student extends Person {\n      public Student() {\n      }\n\n      public Student(String id, String name, String age, String birthday) {\n          super(id, name, age, birthday);\n      }\n  }\n  // Teacher类\n  public class Teacher extends Person {\n      public Teacher() {\n      }\n\n      public Teacher(String id, String name, String age, String birthday) {\n          super(id, name, age, birthday);\n      }\n  }\n  ```\n\n  BaseStudentController类\n\n  ```java\n  public abstract class BaseStudentController {\n      // 业务员对象\n      private StudentService studentService = new StudentService();\n\n      private Scanner sc = new Scanner(System.in);\n\n      // 开启学生管理系统, 并展示学生管理系统菜单\n      public void start() {\n          //Scanner sc = new Scanner(System.in);\n          studentLoop:\n          while (true) {\n              System.out.println("--------欢迎来到 <学生> 管理系统--------");\n              System.out.println("请输入您的选择: 1.添加学生  2.删除学生  3.修改学生  4.查看学生  5.退出");\n              String choice = sc.next();\n              switch (choice) {\n                  case "1":\n                      // System.out.println("添加");\n                      addStudent();\n                      break;\n                  case "2":\n                      // System.out.println("删除");\n                      deleteStudentById();\n                      break;\n                  case "3":\n                      // System.out.println("修改");\n                      updateStudent();\n                      break;\n                  case "4":\n                      // System.out.println("查询");\n                      findAllStudent();\n                      break;\n                  case "5":\n                      System.out.println("感谢您使用学生管理系统, 再见!");\n                      break studentLoop;\n                  default:\n                      System.out.println("您的输入有误, 请重新输入");\n                      break;\n              }\n          }\n      }\n\n      // 修改学生方法\n      public void updateStudent() {\n          String updateId = inputStudentId();\n          Student newStu = inputStudentInfo(updateId);\n          studentService.updateStudent(updateId, newStu);\n\n          System.out.println("修改成功!");\n      }\n\n      // 删除学生方法\n      public void deleteStudentById() {\n          String delId = inputStudentId();\n          // 3. 调用业务员中的deleteStudentById根据id, 删除学生\n          studentService.deleteStudentById(delId);\n          // 4. 提示删除成功\n          System.out.println("删除成功!");\n      }\n\n      // 查看学生方法\n      public void findAllStudent() {\n          // 1. 调用业务员中的获取方法, 得到学生的对象数组\n          Student[] stus = studentService.findAllStudent();\n          // 2. 判断数组的内存地址, 是否为null\n          if (stus == null) {\n              System.out.println("查无信息, 请添加后重试");\n              return;\n          }\n          // 3. 遍历数组, 获取学生信息并打印在控制台\n          System.out.println("学号\\t\\t姓名\\t年龄\\t生日");\n          for (int i = 0; i < stus.length; i++) {\n              Student stu = stus[i];\n              if (stu != null) {\n                  System.out.println(stu.getId() + "\\t" + stu.getName() + "\\t" + stu.getAge() + "\\t\\t" + stu.getBirthday());\n              }\n          }\n      }\n\n      // 添加学生方法\n      public void addStudent() {\n          // StudentService studentService = new StudentService();\n          // 1. 键盘接收学生信息\n          String id;\n          while (true) {\n              System.out.println("请输入学生id:");\n              id = sc.next();\n              boolean flag = studentService.isExists(id);\n              if (flag) {\n                  System.out.println("学号已被占用, 请重新输入");\n              } else {\n                  break;\n              }\n          }\n\n          Student stu = inputStudentInfo(id);\n\n          // 3. 将学生对象,传递给StudentService(业务员)中的addStudent方法\n          boolean result = studentService.addStudent(stu);\n          // 4. 根据返回的boolean类型结果, 在控制台打印成功\\失败\n          if (result) {\n              System.out.println("添加成功");\n          } else {\n              System.out.println("添加失败");\n          }\n      }\n\n      // 键盘录入学生id\n      public String inputStudentId() {\n          String id;\n          while (true) {\n              System.out.println("请输入学生id:");\n              id = sc.next();\n              boolean exists = studentService.isExists(id);\n              if (!exists) {\n                  System.out.println("您输入的id不存在, 请重新输入:");\n              } else {\n                  break;\n              }\n          }\n          return id;\n      }\n\n      // 键盘录入学生信息\n      // 开闭原则: 对扩展内容开放, 对修改内容关闭\n    public Student inputStudentInfo(String id){\n      return null;\n    }\n  }\n  ```\n\n  StudentController类\n\n  ```java\n  public class StudentController extends BaseStudentController {\n\n      private Scanner sc = new Scanner(System.in);\n\n      // 键盘录入学生信息\n      // 开闭原则: 对扩展内容开放, 对修改内容关闭\n      @Override\n      public Student inputStudentInfo(String id) {\n          System.out.println("请输入学生姓名:");\n          String name = sc.next();\n          System.out.println("请输入学生年龄:");\n          String age = sc.next();\n          System.out.println("请输入学生生日:");\n          String birthday = sc.next();\n          Student stu = new Student();\n          stu.setId(id);\n          stu.setName(name);\n          stu.setAge(age);\n          stu.setBirthday(birthday);\n          return stu;\n      }\n  }\n  ```\n\n  OtherStudentController类\n\n  ```java\n  public class OtherStudentController extends BaseStudentController {\n\n      private Scanner sc = new Scanner(System.in);\n\n      // 键盘录入学生信息\n      // 开闭原则: 对扩展内容开放, 对修改内容关闭\n      @Override\n      public Student inputStudentInfo(String id) {\n          System.out.println("请输入学生姓名:");\n          String name = sc.next();\n          System.out.println("请输入学生年龄:");\n          String age = sc.next();\n          System.out.println("请输入学生生日:");\n          String birthday = sc.next();\n          Student stu = new Student(id,name,age,birthday);\n          return stu;\n      }\n  }\n  ```\n\n## 3.抽象类\n\n### 3.1抽象类的概述（理解）\n\n​\t当我们在做子类共性功能抽取时，有些方法在父类中并没有具体的体现，这个时候就需要抽象类了！\n\n​\t在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类！\n\n### 3.2抽象类的特点（记忆）\n\n- 抽象类和抽象方法必须使用 abstract 关键字修饰\n\n  ```java\n  //抽象类的定义\n  public abstract class 类名 {}\n\n  //抽象方法的定义\n  public abstract void eat();\n  ```\n\n- 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类\n\n- 抽象类不能实例化\n\n- 抽象类可以有构造方法\n\n- 抽象类的子类\n\n  ​\t要么重写抽象类中的所有抽象方法\n\n  ​\t要么是抽象类\n\n### 3.3抽象类的案例（应用）\n\n- 案例需求\n\n  ​\t定义猫类(Cat)和狗类(Dog)\n\n  ​\t猫类成员方法：eat（猫吃鱼）drink（喝水…）\n\n  ​\t狗类成员方法：eat（狗吃肉）drink（喝水…）\n\n- 实现步骤\n\n  1. 猫类和狗类中存在共性内容，应向上抽取出一个动物类（Animal）\n  2. 父类Animal中，无法将 eat 方法具体实现描述清楚，所以定义为抽象方法\n  3. 抽象方法需要存活在抽象类中，将Animal定义为抽象类\n  4. 让 Cat 和 Dog 分别继承 Animal，重写eat方法\n  5. 测试类中创建 Cat 和 Dog 对象，调用方法测试\n\n- 代码实现\n\n  - 动物类\n\n  ```java\n  public abstract class Animal {\n      public void drink(){\n          System.out.println("喝水");\n      }\n\n      public Animal(){\n\n      }\n\n      public abstract void eat();\n  }\n  ```\n\n  - 猫类\n\n  ```java\n  public class Cat extends Animal {\n      @Override\n      public void eat() {\n          System.out.println("猫吃鱼");\n      }\n  }\n  ```\n\n  - 狗类\n\n  ```java\n  public class Dog extends Animal {\n      @Override\n      public void eat() {\n          System.out.println("狗吃肉");\n      }\n  }\n  ```\n\n  - 测试类\n\n  ```java\n  public static void main(String[] args) {\n          Dog d = new Dog();\n          d.eat();\n          d.drink();\n\n          Cat c = new Cat();\n          c.drink();\n          c.eat();\n\n          //Animal a = new Animal();\n          //a.eat();\n      }\n  ```\n\n### 3.4模板设计模式 \n\n+ 设计模式\n\n  设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。\n  使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。\n\n+ 模板设计模式\n\n  把抽象类整体就可以看做成一个模板，模板中不能决定的东西定义成抽象方法\n  让使用模板的类（继承抽象类的类）去重写抽象方法实现需求\n\n+ 模板设计模式的优势\n\n  模板已经定义了通用结构，使用者只需要关心自己需要实现的功能即可\n\n+ 示例代码\n\n  模板类\n\n  ```java\n  /*\n      作文模板类\n   */\n  public abstract class CompositionTemplate {\n\n      public final void write(){\n          System.out.println("<<我的爸爸>>");\n\n          body();\n\n          System.out.println("啊~ 这就是我的爸爸");\n\n      }\n\n      public abstract void body();\n  }\n  ```\n\n  实现类A\n\n  ```java\n  public class Tom extends CompositionTemplate {\n\n      @Override\n      public void body() {\n          System.out.println("那是一个秋天, 风儿那么缠绵,记忆中, " +\n                  "那天爸爸骑车接我放学回家,我的脚卡在了自行车链当中, 爸爸蹬不动,他就站起来蹬...");\n      }\n  }\n  ```\n\n  实现类B\n\n  ```java\n  public class Tony extends CompositionTemplate {\n      @Override\n      public void body() {\n\n      }\n\n      /*public void write(){\n\n      }*/\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class Test {\n      public static void main(String[] args) {\n          Tom t = new Tom();\n          t.write();\n      }\n  }\n  ```\n\n### 3.5final（应用）\n\n- fianl关键字的作用\n\n  - final代表最终的意思，可以修饰成员方法，成员变量，类\n\n- final修饰类、方法、变量的效果  \n\n  - fianl修饰类：该类不能被继承（不能有子类，但是可以有父类）\n\n  - final修饰方法：该方法不能被重写\n\n  - final修饰变量：表明该变量是一个常量，不能再次赋值\n\n    + 变量是基本类型,不能改变的是值\n\n    + 变量是引用类型,不能改变的是地址值,但地址里面的内容是可以改变的\n\n    + 举例\n\n      ```java\n      public static void main(String[] args){\n          final Student s = new Student(23);\n        \ts = new Student(24);  // 错误\n       \ts.setAge(24);  // 正确\n      }\n      ```\n\n### 3.6黑马信息管理系统使用抽象类改进 (应用)\n\n+ 需求\n\n  1. 使用抽象类的思想，将BaseStudentController 中的 inputStudentInfo 方法，定义为抽象方法\n  2. 将不希望子类重写的方法，使用 final 进行修饰\n\n+ 代码实现\n\n  BaseStudentController类\n\n  ```java\n  public abstract class BaseStudentController {\n      // 业务员对象\n      private StudentService studentService = new StudentService();\n\n      private Scanner sc = new Scanner(System.in);\n\n      // 开启学生管理系统, 并展示学生管理系统菜单\n      public final void start() {\n          //Scanner sc = new Scanner(System.in);\n          studentLoop:\n          while (true) {\n              System.out.println("--------欢迎来到 <学生> 管理系统--------");\n              System.out.println("请输入您的选择: 1.添加学生  2.删除学生  3.修改学生  4.查看学生  5.退出");\n              String choice = sc.next();\n              switch (choice) {\n                  case "1":\n                      // System.out.println("添加");\n                      addStudent();\n                      break;\n                  case "2":\n                      // System.out.println("删除");\n                      deleteStudentById();\n                      break;\n                  case "3":\n                      // System.out.println("修改");\n                      updateStudent();\n                      break;\n                  case "4":\n                      // System.out.println("查询");\n                      findAllStudent();\n                      break;\n                  case "5":\n                      System.out.println("感谢您使用学生管理系统, 再见!");\n                      break studentLoop;\n                  default:\n                      System.out.println("您的输入有误, 请重新输入");\n                      break;\n              }\n          }\n      }\n\n      // 修改学生方法\n      public final void updateStudent() {\n          String updateId = inputStudentId();\n          Student newStu = inputStudentInfo(updateId);\n          studentService.updateStudent(updateId, newStu);\n\n          System.out.println("修改成功!");\n      }\n\n      // 删除学生方法\n      public final void deleteStudentById() {\n          String delId = inputStudentId();\n          // 3. 调用业务员中的deleteStudentById根据id, 删除学生\n          studentService.deleteStudentById(delId);\n          // 4. 提示删除成功\n          System.out.println("删除成功!");\n      }\n\n      // 查看学生方法\n      public final void findAllStudent() {\n          // 1. 调用业务员中的获取方法, 得到学生的对象数组\n          Student[] stus = studentService.findAllStudent();\n          // 2. 判断数组的内存地址, 是否为null\n          if (stus == null) {\n              System.out.println("查无信息, 请添加后重试");\n              return;\n          }\n          // 3. 遍历数组, 获取学生信息并打印在控制台\n          System.out.println("学号\\t\\t姓名\\t年龄\\t生日");\n          for (int i = 0; i < stus.length; i++) {\n              Student stu = stus[i];\n              if (stu != null) {\n                  System.out.println(stu.getId() + "\\t" + stu.getName() + "\\t" + stu.getAge() + "\\t\\t" + stu.getBirthday());\n              }\n          }\n      }\n\n      // 添加学生方法\n      public final void addStudent() {\n          // StudentService studentService = new StudentService();\n          // 1. 键盘接收学生信息\n          String id;\n          while (true) {\n              System.out.println("请输入学生id:");\n              id = sc.next();\n              boolean flag = studentService.isExists(id);\n              if (flag) {\n                  System.out.println("学号已被占用, 请重新输入");\n              } else {\n                  break;\n              }\n          }\n\n          Student stu = inputStudentInfo(id);\n\n          // 3. 将学生对象,传递给StudentService(业务员)中的addStudent方法\n          boolean result = studentService.addStudent(stu);\n          // 4. 根据返回的boolean类型结果, 在控制台打印成功\\失败\n          if (result) {\n              System.out.println("添加成功");\n          } else {\n              System.out.println("添加失败");\n          }\n      }\n\n      // 键盘录入学生id\n      public String inputStudentId() {\n          String id;\n          while (true) {\n              System.out.println("请输入学生id:");\n              id = sc.next();\n              boolean exists = studentService.isExists(id);\n              if (!exists) {\n                  System.out.println("您输入的id不存在, 请重新输入:");\n              } else {\n                  break;\n              }\n          }\n          return id;\n      }\n\n      // 键盘录入学生信息\n      // 开闭原则: 对扩展内容开放, 对修改内容关闭\n    public abstract Student inputStudentInfo(String id);\n  }\n  ```\n\n## 4.代码块 \n\n### 4.1代码块概述 (理解)\n\n在Java中，使用 { } 括起来的代码被称为代码块\n\n### 4.2代码块分类 (理解) \n\n+ 局部代码块\n\n  + 位置: 方法中定义\n\n  + 作用: 限定变量的生命周期，及早释放，提高内存利用率\n\n  + 示例代码\n\n    ```java\n    public class Test {\n        /*\n            局部代码块\n                位置：方法中定义\n                作用：限定变量的生命周期，及早释放，提高内存利用率\n         */\n        public static void main(String[] args) {\n            {\n                int a = 10;\n                System.out.println(a);\n            }\n\n           // System.out.println(a);\n        }\n    }\n    ```\n\n+ 构造代码块\n\n  + 位置: 类中方法外定义\n\n  + 特点: 每次构造方法执行的时，都会执行该代码块中的代码，并且在构造方法执行前执行\n\n  + 作用: 将多个构造方法中相同的代码，抽取到构造代码块中，提高代码的复用性\n\n  + 示例代码\n\n    ```java\n    public class Test {\n        /*\n            构造代码块:\n                位置：类中方法外定义\n                特点：每次构造方法执行的时，都会执行该代码块中的代码，并且在构造方法执行前执行\n                作用：将多个构造方法中相同的代码，抽取到构造代码块中，提高代码的复用性\n         */\n        public static void main(String[] args) {\n            Student stu1 = new Student();\n            Student stu2 = new Student(10);\n        }\n    }\n\n    class Student {\n\n        {\n            System.out.println("好好学习");\n        }\n\n        public Student(){\n            System.out.println("空参数构造方法");\n        }\n\n        public Student(int a){\n            System.out.println("带参数构造方法...........");\n        }\n    }\n    ```\n\n+ 静态代码块\n\n  + 位置: 类中方法外定义\n\n  + 特点: 需要通过static关键字修饰，随着类的加载而加载，并且只执行一次\n\n  + 作用: 在类加载的时候做一些数据初始化的操作\n\n  + 示例代码\n\n    ```java\n    public class Test {\n        /*\n            静态代码块:\n                位置：类中方法外定义\n                特点：需要通过static关键字修饰，随着类的加载而加载，并且只执行一次\n                作用：在类加载的时候做一些数据初始化的操作\n         */\n        public static void main(String[] args) {\n            Person p1 = new Person();\n            Person p2 = new Person(10);\n        }\n    }\n\n    class Person {\n        static {\n            System.out.println("我是静态代码块, 我执行了");\n        }\n\n        public Person(){\n            System.out.println("我是Person类的空参数构造方法");\n        }\n\n        public Person(int a){\n            System.out.println("我是Person类的带...........参数构造方法");\n        }\n    }\n    ```\n\n### 4.3黑马信息管理系统使用代码块改进 (应用) \n\n+ 需求\n\n  使用静态代码块，初始化一些学生数据\n\n+ 实现步骤\n\n  1. 在StudentDao类中定义一个静态代码块，用来初始化一些学生数据\n  2. 将初始化好的学生数据存储到学生数组中\n\n+ 示例代码\n\n  StudentDao类\n\n  ```java\n  public class StudentDao {\n      // 创建学生对象数组\n      private static Student[] stus = new Student[5];\n\n      static {\n          Student stu1 = new Student("heima001","张三","23","1999-11-11");\n          Student stu2 = new Student("heima002","李四","24","2000-11-11");\n\n          stus[0] = stu1;\n          stus[1] = stu2;\n      }\n\n      // 添加学生方法\n      public boolean addStudent(Student stu) {\n\n          // 2. 添加学生到数组\n          //2.1 定义变量index为-1，假设数组已经全部存满，没有null的元素\n          int index = -1;\n          //2.2 遍历数组取出每一个元素，判断是否是null\n          for (int i = 0; i < stus.length; i++) {\n              Student student = stus[i];\n              if(student == null){\n                  index = i;\n                  //2.3 如果为null，让index变量记录当前索引位置，并使用break结束循环遍历\n                  break;\n              }\n          }\n\n          // 3. 返回是否添加成功的boolean类型状态\n          if(index == -1){\n              // 装满了\n              return false;\n          }else{\n              // 没有装满, 正常添加, 返回true\n              stus[index] = stu;\n              return true;\n          }\n      }\n      // 查看学生方法\n      public Student[] findAllStudent() {\n          return stus;\n      }\n\n      public void deleteStudentById(String delId) {\n          // 1. 查找id在容器中所在的索引位置\n          int index = getIndex(delId);\n          // 2. 将该索引位置,使用null元素进行覆盖\n          stus[index] = null;\n      }\n\n      public int getIndex(String id){\n          int index = -1;\n          for (int i = 0; i < stus.length; i++) {\n              Student stu = stus[i];\n              if(stu != null && stu.getId().equals(id)){\n                  index = i;\n                  break;\n              }\n          }\n          return index;\n      }\n\n      public void updateStudent(String updateId, Student newStu) {\n          // 1. 查找updateId, 在容器中的索引位置\n          int index = getIndex(updateId);\n          // 2. 将该索引位置, 使用新的学生对象替换\n          stus[index] = newStu;\n      }\n  }\n  ```\n\n  ​\n\n',on='## 1.接口\n\n### 1.1黑马信息管理系统集合改进 (应用)\n\n+ 使用数组容器的弊端\n\n  1. 容器长度是固定的，不能根据添加功能自动增长\n  2. 没有提供用于赠删改查的方法\n\n+ 优化步骤\n\n  1. 创建新的StudentDao类，OtherStudentDao\n\n  2. 创建ArrayList集合容器对象\n\n  3. OtherStudentDao中的方法声明，需要跟StudentDao保持一致\n\n     注意：如果不一致，StudentService中的代码就需要进行修改\n\n  4. 完善方法（添加、删除、修改、查看）\n\n  5. 替换StudentService中的Dao对象\n\n+ 代码实现\n\n  OtherStudentDao类\n\n  ```java\n  public class OtherStudentDao {\n      // 集合容器\n      private static ArrayList<Student> stus = new ArrayList<>();\n\n      static {\n          Student stu1 = new Student("heima001","张三","23","1999-11-11");\n          Student stu2 = new Student("heima002","李四","24","2000-11-11");\n\n          stus.add(stu1);\n          stus.add(stu2);\n      }\n\n      // 添加学生方法\n      public boolean addStudent(Student stu) {\n         stus.add(stu);\n         return true;\n      }\n\n      // 查看学生方法\n      public Student[] findAllStudent() {\n\n          Student[] students = new Student[stus.size()];\n\n          for (int i = 0; i < students.length; i++) {\n              students[i] = stus.get(i);\n          }\n\n          return students;\n      }\n\n      public void deleteStudentById(String delId) {\n          // 1. 查找id在容器中所在的索引位置\n          int index = getIndex(delId);\n          stus.remove(index);\n      }\n\n      public int getIndex(String id){\n          int index = -1;\n          for (int i = 0; i < stus.size(); i++) {\n              Student stu = stus.get(i);\n              if(stu != null && stu.getId().equals(id)){\n                  index = i;\n                  break;\n              }\n          }\n          return index;\n      }\n\n      public void updateStudent(String updateId, Student newStu) {\n          // 1. 查找updateId, 在容器中的索引位置\n          int index = getIndex(updateId);\n          stus.set(index, newStu);\n      }\n  }\n  ```\n\n  StudentService类\n\n  ```java\n  public class StudentService {\n      // 创建StudentDao (库管)\n       private OtherStudentDao studentDao = new OtherStudentDao();\n    \t// 其他方法没有变化,此处省略...\n  }    \n  ```\n\n### 1.2黑马信息管理系统抽取Dao (应用)\n\n+ 优化步骤\n\n  1. 将方法向上抽取，抽取出一个父类 （ BaseStudentDao ）\n  2. 方法的功能实现在父类中无法给出具体明确，定义为抽象方法\n  3. 让两个类分别继承 BaseStudentDao ，重写内部抽象方法\n\n+ 代码实现\n\n  BaseStudentDao类\n\n  ```java\n  public abstract class BaseStudentDao {\n      // 添加学生方法\n      public abstract boolean addStudent(Student stu);\n      // 查看学生方法\n      public abstract Student[] findAllStudent();\n      // 删除学生方法\n      public abstract void deleteStudentById(String delId);\n      // 根据id找索引方法\n      public abstract int getIndex(String id);\n      // 修改学生方法\n      public abstract void updateStudent(String updateId, Student newStu);\n  }\n  ```\n\n  StudentDao类\n\n  ```java\n  public class StudentDao extends BaseStudentDao {\n    // 其他内容不变,此处省略\n  }\n  ```\n\n  OtherStudentDao类\n\n  ```java\n  public class OtherStudentDao extends BaseStudentDao {\n    // 其他内容不变,此处省略\n  }\n  ```\n\n### 1.3接口的概述（理解）\n\n+ 接口就是一种公共的规范标准，只要符合规范标准，大家都可以通用。\n+ Java中接口存在的两个意义\n  1. 用来定义规范\n  2. 用来做功能的拓展\n\n### 1.4接口的特点（记忆）\n\n- 接口用关键字interface修饰\n\n  ```java\n  public interface 接口名 {} \n  ```\n\n- 类实现接口用implements表示\n\n  ```java\n  public class 类名 implements 接口名 {}\n  ```\n\n- 接口不能实例化\n\n  ​\t我们可以创建接口的实现类对象使用\n\n- 接口的子类\n\n  ​\t要么重写接口中的所有抽象方法\n\n  ​\t要么子类也是抽象类\n\n### 1.5接口的成员特点（记忆）\n\n- 成员特点\n\n  - 成员变量\n\n    ​\t 只能是常量\n    ​\t 默认修饰符：public static final\n\n  - 构造方法\n\n    ​\t没有，因为接口主要是扩展功能的，而没有具体存在\n\n  - 成员方法\n\n    ​\t只能是抽象方法\n\n    ​\t默认修饰符：public abstract\n\n    ​\t关于接口中的方法，JDK8和JDK9中有一些新特性，后面再讲解\n\n- 代码演示\n\n  - 接口\n\n  ```java\n  public interface Inter {\n      public static final int NUM = 10;\n\n      public abstract void show();\n  }\n  ```\n\n  - 实现类\n\n  ```java\n  class InterImpl implements Inter{\n\n      public void method(){\n          // NUM = 20;\n          System.out.println(NUM);\n      }\n\n      public void show(){\n\n      }\n  }\n  ```\n\n  - 测试类\n\n  ```java\n  public class TestInterface {\n      /*\n          成员变量: 只能是常量 系统会默认加入三个关键字\n                      public static final\n          构造方法: 没有\n          成员方法: 只能是抽象方法, 系统会默认加入两个关键字\n                      public abstract\n       */\n      public static void main(String[] args) {\n          System.out.println(Inter.NUM);\n      }\n    \n  }\n  ```\n\n### 1.6类和接口的关系（记忆）\n\n- 类与类的关系\n\n  ​\t继承关系，只能单继承，但是可以多层继承\n\n- 类与接口的关系\n\n  ​\t实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口\n\n- 接口与接口的关系\n\n  ​\t继承关系，可以单继承，也可以多继承\n\n### 1.7黑马信息管理系统使用接口改进 (应用)\n\n+ 实现步骤\n\n  1. 将 BaseStudentDao 改进为一个接口\n  2. 让 StudentDao 和 OtherStudentDao 去实现这个接口\n\n+ 代码实现\n\n  BaseStudentDao接口\n\n  ```java\n  public interface BaseStudentDao {\n      // 添加学生方法\n      public abstract boolean addStudent(Student stu);\n      // 查看学生方法\n      public abstract Student[] findAllStudent();\n      // 删除学生方法\n      public abstract void deleteStudentById(String delId);\n      // 根据id找索引方法\n      public abstract int getIndex(String id);\n      // 修改学生方法\n      public abstract void updateStudent(String updateId, Student newStu);\n  }\n  ```\n\n  StudentDao类\n\n  ```java\n  public class StudentDao implements BaseStudentDao {\n    // 其他内容不变,此处省略\n  }\n  ```\n\n  OtherStudentDao类\n\n  ```java\n  public class OtherStudentDao implements BaseStudentDao {\n    // 其他内容不变,此处省略\n  }\n  ```\n\n### 1.8黑马信息管理系统解耦合改进 (应用) \n\n+ 实现步骤\n\n  1. 创建factory包，创建 StudentDaoFactory（工厂类）\n  2. 提供 static 修改的 getStudentDao 方法，该方法用于创建StudentDao对象并返回\n\n+ 代码实现\n\n  StudentDaoFactory类\n\n  ```java\n  public class StudentDaoFactory {\n      public static OtherStudentDao getStudentDao(){\n          return new OtherStudentDao();\n      }\n  }\n  ```\n\n  StudentService类\n\n  ```java\n  public class StudentService {\n      // 创建StudentDao (库管)\n      // private OtherStudentDao studentDao = new OtherStudentDao();\n\n      // 通过学生库管工厂类, 获取库管对象\n      private OtherStudentDao studentDao = StudentDaoFactory.getStudentDao();\n  }  \n  ```\n\n## 2.接口组成更新\n\n### 2.1接口组成更新概述【理解】\n\n- 常量\n\n  public static final\n\n- 抽象方法\n\n  public abstract\n\n- 默认方法(Java 8)\n\n- 静态方法(Java 8)\n\n- 私有方法(Java 9)\n\n### 2.2接口中默认方法【应用】\n\n- 格式\n\n  public default 返回值类型 方法名(参数列表) {   }\n\n- 作用\n\n  解决接口升级的问题\n\n- 范例\n\n  ```java\n  public default void show3() { \n  }\n  ```\n\n- 注意事项\n\n  - 默认方法不是抽象方法，所以不强制被重写。但是可以被重写，重写的时候去掉default关键字\n  - public可以省略，default不能省略\n  - 如果实现了多个接口，多个接口中存在相同的方法声明，子类就必须对该方法进行重写\n\n### 2.3接口中静态方法【应用】\n\n- 格式\n\n  public static 返回值类型 方法名(参数列表) {   }\n\n- 范例\n\n  ```java\n  public static void show() {\n  }\n  ```\n\n- 注意事项\n\n  - 静态方法只能通过接口名调用，不能通过实现类名或者对象名调用\n  - public可以省略，static不能省略\n\n### 2.4接口中私有方法【应用】\n\n- 私有方法产生原因\n\n  Java 9中新增了带方法体的私有方法，这其实在Java 8中就埋下了伏笔：Java 8允许在接口中定义带方法体的默认方法和静态方法。这样可能就会引发一个问题：当两个默认方法或者静态方法中包含一段相同的代码实现时，程序必然考虑将这段实现代码抽取成一个共性方法，而这个共性方法是不需要让别人使用的，因此用私有给隐藏起来，这就是Java 9增加私有方法的必然性\n\n- 定义格式\n\n  - 格式1\n\n    private 返回值类型 方法名(参数列表) {   }\n\n  - 范例1\n\n    ```java\n    private void show() {  \n    }\n    ```\n\n  - 格式2\n\n    private static 返回值类型 方法名(参数列表) {   }\n\n  - 范例2\n\n    ```java\n    private static void method() {  \n    }\n    ```\n\n- 注意事项\n\n  - 默认方法可以调用私有的静态方法和非静态方法\n  - 静态方法只能调用私有的静态方法\n\n## 3.多态 \n\n### 3.1多态的概述（记忆）\n\n- 什么是多态\n\n  ​\t同一个对象，在不同时刻表现出来的不同形态\n\n- 多态的前提\n\n  - 要有继承或实现关系\n  - 要有方法的重写\n  - 要有父类引用指向子类对象\n\n- 代码演示\n\n  ```java\n  class Animal {\n      public void eat(){\n          System.out.println("动物吃饭");\n      }\n  }\n\n  class Cat extends Animal {\n      @Override\n      public void eat() {\n          System.out.println("猫吃鱼");\n      }\n  }\n\n  public class Test1Polymorphic {\n      /*\n          多态的前提:\n\n              1. 要有(继承 \\ 实现)关系\n              2. 要有方法重写\n              3. 要有父类引用, 指向子类对象\n       */\n      public static void main(String[] args) {\n          // 当前事物, 是一只猫\n          Cat c = new Cat();\n          // 当前事物, 是一只动物\n          Animal a = new Cat();\n          a.eat();\n\n      }\n  }\n  ```\n\n### 3.2多态中的成员访问特点（记忆）\n\n- 成员访问特点\n\n  - 成员变量\n\n    ​\t编译看父类，运行看父类\n\n  - 成员方法\n\n    ​\t编译看父类，运行看子类\n\n- 代码演示\n\n  ```java\n  class Fu {\n      int num = 10;\n\n      public void method(){\n          System.out.println("Fu.. method");\n      }\n  }\n\n  class Zi extends Fu {\n      int num = 20;\n\n      public void method(){\n          System.out.println("Zi.. method");\n      }\n  }\n\n  public class Test2Polymorpic {\n      /*\n           多态的成员访问特点:\n\n                  成员变量: 编译看左边 (父类), 运行看左边 (父类)\n\n                  成员方法: 编译看左边 (父类), 运行看右边 (子类)\n       */\n      public static void main(String[] args) {\n          Fu f = new Zi();\n          System.out.println(f.num);\n          f.method();\n      }\n  }\n  ```\n\n### 3.3多态的好处和弊端（记忆）\n\n- 好处\n\n  ​\t提高程序的扩展性。定义方法时候，使用父类型作为参数，在使用的时候，使用具体的子类型参与操作\n\n- 弊端\n\n  ​\t不能使用子类的特有成员\n\n### 3.4多态中的转型（应用）\n\n- 向上转型\n\n  ​\t父类引用指向子类对象就是向上转型\n\n- 向下转型\n\n  ​\t格式：子类型 对象名 = (子类型)父类引用;\n\n- 代码演示\n\n  ```java\n  class Fu {\n      public void show(){\n          System.out.println("Fu..show...");\n      }\n  }\n\n  class Zi extends Fu {\n      @Override\n      public void show() {\n          System.out.println("Zi..show...");\n      }\n\n      public void method(){\n          System.out.println("我是子类特有的方法, method");\n      }\n  }\n\n  public class Test3Polymorpic {\n      public static void main(String[] args) {\n          // 1. 向上转型 : 父类引用指向子类对象\n          Fu f = new Zi();\n          f.show();\n          // 多态的弊端: 不能调用子类特有的成员\n          // f.method();\n\n          // A: 直接创建子类对象\n          // B: 向下转型\n\n          // 2. 向下转型 : 从父类类型, 转换回子类类型\n          Zi z = (Zi) f;\n          z.method();\n      }\n  }\n  ```\n\n### 3.5多态中转型存在的风险和解决方案 (应用) \n\n+ 风险\n\n  如果被转的引用类型变量,对应的实际类型和目标类型不是同一种类型,那么在转换的时候就会出现ClassCastException \n\n+ 解决方案\n\n  + 关键字\n\n    instanceof\n\n  + 使用格式\n\n    变量名 instanceof 类型\n\n    通俗的理解：判断关键字左边的变量，是否是右边的类型，返回boolean类型结果\n\n+ 代码演示\n\n  ```java\n  abstract class Animal {\n      public abstract void eat();\n  }\n\n  class Dog extends Animal {\n      public void eat() {\n          System.out.println("狗吃肉");\n      }\n\n      public void watchHome(){\n          System.out.println("看家");\n      }\n  }\n\n  class Cat extends Animal {\n      public void eat() {\n          System.out.println("猫吃鱼");\n      }\n  }\n\n  public class Test4Polymorpic {\n      public static void main(String[] args) {\n          useAnimal(new Dog());\n          useAnimal(new Cat());\n      }\n\n      public static void useAnimal(Animal a){  // Animal a = new Dog();\n                                               // Animal a = new Cat();\n          a.eat();\n          //a.watchHome();\n\n  //        Dog dog = (Dog) a;\n  //        dog.watchHome();  // ClassCastException  类型转换异常\n        \n          // 判断a变量记录的类型, 是否是Dog\n          if(a instanceof Dog){\n              Dog dog = (Dog) a;\n              dog.watchHome();\n          }\n      }\n\n  }\n  ```\n\n### 3.6黑马信息管理系统多态改进 (应用) \n\n+ 实现步骤\n\n  1. StudentDaoFactory类中方法的返回值定义成父类类型BaseStudentDao\n  2. StudentService中接收方法返回值的类型定义成父类类型BaseStudentDao\n\n+ 代码实现\n\n  StudentDaoFactory类\n\n  ```java\n  public class StudentDaoFactory {\n      public static BaseStudentDao getStudentDao(){\n          return new OtherStudentDao();\n      }\n  }\n  ```\n\n  StudentService类\n\n  ```java\n  public class StudentService {\n      // 创建StudentDao (库管)\n      // private OtherStudentDao studentDao = new OtherStudentDao();\n\n      // 通过学生库管工厂类, 获取库管对象\n      private BaseStudentDao studentDao = StudentDaoFactory.getStudentDao();\n  }  \n  ```\n\n## 4.内部类 \n\n### 4.1 内部类的基本使用（理解）\n\n- 内部类概念\n\n  - 在一个类中定义一个类。举例：在一个类A的内部定义一个类B，类B就被称为内部类\n\n- 内部类定义格式\n\n  - 格式&举例：\n\n    ```java\n    /*\n    \t格式：\n        class 外部类名{\n        \t修饰符 class 内部类名{\n        \t\n        \t}\n        }\n    */\n\n    class Outer {\n        public class Inner {\n            \n        }\n    }\n    ```\n\n- 内部类的访问特点 \n\n  - 内部类可以直接访问外部类的成员，包括私有\n  - 外部类要访问内部类的成员，必须创建对象\n\n- 示例代码：\n\n  ```java\n  /*\n      内部类访问特点：\n          内部类可以直接访问外部类的成员，包括私有\n          外部类要访问内部类的成员，必须创建对象\n   */\n  public class Outer {\n      private int num = 10;\n      public class Inner {\n          public void show() {\n              System.out.println(num);\n          }\n      }\n      public void method() {\n          Inner i = new Inner();\n          i.show();\n      }\n  }\n  ```\n\n### 2.2 成员内部类（理解）\n\n- 成员内部类的定义位置\n\n  - 在类中方法，跟成员变量是一个位置\n\n- 外界创建成员内部类格式\n\n  - 格式：外部类名.内部类名 对象名 = 外部类对象.内部类对象;\n  - 举例：Outer.Inner oi = new Outer().new Inner();\n\n- 私有成员内部类\n\n  - 将一个类，设计为内部类的目的，大多数都是不想让外界去访问，所以内部类的定义应该私有化，私有化之后，再提供一个可以让外界调用的方法，方法内部创建内部类对象并调用。\n\n  - 示例代码：\n\n    ```java\n    class Outer {\n        private int num = 10;\n        private class Inner {\n            public void show() {\n                System.out.println(num);\n            }\n        }\n        public void method() {\n            Inner i = new Inner();\n            i.show();\n        }\n    }\n    public class InnerDemo {\n        public static void main(String[] args) {\n    \t\t//Outer.Inner oi = new Outer().new Inner();\n    \t\t//oi.show();\n            Outer o = new Outer();\n            o.method();\n        }\n    }\n    ```\n\n- 静态成员内部类\n\n  + 静态成员内部类访问格式：外部类名.内部类名 对象名 = new 外部类名.内部类名();\n\n  + 静态成员内部类中的静态方法：外部类名.内部类名.方法名();\n\n  + 示例代码\n\n    ```java\n    class Outer {\n        static class Inner {\n            public void show(){\n                System.out.println("inner..show");\n            }\n\n            public static void method(){\n                System.out.println("inner..method");\n            }\n        }\n    }\n\n    public class Test3Innerclass {\n        /*\n            静态成员内部类演示\n         */\n        public static void main(String[] args) {\n            // 外部类名.内部类名 对象名 = new 外部类名.内部类名();\n            Outer.Inner oi = new Outer.Inner();\n            oi.show();\n\n            Outer.Inner.method();\n        }\n    }\n    ```\n\n### 2.3 局部内部类（理解）\n\n- 局部内部类定义位置\n\n  - 局部内部类是在方法中定义的类\n\n- 局部内部类方式方式\n\n  - 局部内部类，外界是无法直接使用，需要在方法内部创建对象并使用\n  - 该类可以直接访问外部类的成员，也可以访问方法内的局部变量\n\n- 示例代码\n\n  ```java\n  class Outer {\n      private int num = 10;\n      public void method() {\n          int num2 = 20;\n          class Inner {\n              public void show() {\n                  System.out.println(num);\n                  System.out.println(num2);\n              }\n          }\n          Inner i = new Inner();\n          i.show();\n      }\n  }\n  public class OuterDemo {\n      public static void main(String[] args) {\n          Outer o = new Outer();\n          o.method();\n      }\n  }\n\n  ```\n\n### 2.4 匿名内部类（应用）\n\n- 匿名内部类的前提\n\n  - 存在一个类或者接口，这里的类可以是具体类也可以是抽象类\n\n- 匿名内部类的格式\n\n  - 格式：new 类名 ( ) {  重写方法 }    new  接口名 ( ) { 重写方法 }\n\n  - 举例： \n\n    ```java\n    new Inter(){\n        @Override\n        public void method(){}\n    } \n    ```\n\n- 匿名内部类的本质\n\n  - 本质：是一个继承了该类或者实现了该接口的子类匿名对象\n\n- 匿名内部类的细节\n\n  - 匿名内部类可以通过多态的形式接受\n\n    ```java\n    Inter i = new Inter(){\n      @Override\n        public void method(){\n            \n        }\n    }\n    ```\n\n- 匿名内部类直接调用方法\n\n  ```java\n  interface Inter{\n      void method();\n  }\n\n  class Test{\n      public static void main(String[] args){\n          new Inter(){\n              @Override\n              public void method(){\n                  System.out.println("我是匿名内部类");\n              }\n          }.method();\t// 直接调用方法\n      }\n  }\n  ```\n\n### 2.4 匿名内部类在开发中的使用（应用）\n\n- 匿名内部类在开发中的使用\n\n  - 当发现某个方法需要，接口或抽象类的子类对象，我们就可以传递一个匿名内部类过去，来简化传统的代码\n\n- 示例代码：\n\n  ```java\n  /*\n      游泳接口\n   */\n  interface Swimming {\n      void swim();\n  }\n\n  public class TestSwimming {\n      public static void main(String[] args) {\n          goSwimming(new Swimming() {\n              @Override\n              public void swim() {\n                  System.out.println("铁汁, 我们去游泳吧");\n              }\n          });\n      }\n\n      /**\n       * 使用接口的方法\n       */\n      public static void goSwimming(Swimming swimming){\n          /*\n              Swimming swim = new Swimming() {\n                  @Override\n                  public void swim() {\n                      System.out.println("铁汁, 我们去游泳吧");\n                  }\n              }\n           */\n          swimming.swim();\n      }\n  }\n  ```\n\n## 5.Lambda表达式\n\n### 5.1体验Lambda表达式【理解】\n\n- 代码演示\n\n  ```java\n  /*\n      游泳接口\n   */\n  interface Swimming {\n      void swim();\n  }\n\n  public class TestSwimming {\n      public static void main(String[] args) {\n          // 通过匿名内部类实现\n          goSwimming(new Swimming() {\n              @Override\n              public void swim() {\n                  System.out.println("铁汁, 我们去游泳吧");\n              }\n          });\n\n          /*  通过Lambda表达式实现\n              理解: 对于Lambda表达式, 对匿名内部类进行了优化\n           */\n          goSwimming(() -> System.out.println("铁汁, 我们去游泳吧"));\n      }\n\n      /**\n       * 使用接口的方法\n       */\n      public static void goSwimming(Swimming swimming) {\n          swimming.swim();\n      }\n  }\n  ```\n\n- 函数式编程思想概述\n\n  在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿数据做操作”\n\n  面向对象思想强调“必须通过对象的形式来做事情”\n\n  函数式思想则尽量忽略面向对象的复杂语法：“强调做什么，而不是以什么形式去做”\n\n  而我们要学习的Lambda表达式就是函数式思想的体现\n\n### 5.2Lambda表达式的标准格式【理解】\n\n- 格式：\n\n  ​\t(形式参数) -> {代码块}\n\n  - 形式参数：如果有多个参数，参数之间用逗号隔开；如果没有参数，留空即可\n  - ->：由英文中画线和大于符号组成，固定写法。代表指向动作\n  - 代码块：是我们具体要做的事情，也就是以前我们写的方法体内容\n\n- 组成Lambda表达式的三要素：\n\n  - 形式参数，箭头，代码块\n\n### 5.3Lambda表达式练习1【应用】\n\n- Lambda表达式的使用前提\n\n  - 有一个接口\n  - 接口中有且仅有一个抽象方法\n\n- 练习描述\n\n  ​\t无参无返回值抽象方法的练习\n\n- 操作步骤\n\n  - 定义一个接口(Eatable)，里面定义一个抽象方法：void eat();\n  - 定义一个测试类(EatableDemo)，在测试类中提供两个方法\n    - 一个方法是：useEatable(Eatable e)\n    - 一个方法是主方法，在主方法中调用useEatable方法\n\n- 示例代码\n\n  ```java\n  //接口\n  public interface Eatable {\n      void eat();\n  }\n  //实现类\n  public class EatableImpl implements Eatable {\n      @Override\n      public void eat() {\n          System.out.println("一天一苹果，医生远离我");\n      }\n  }\n  //测试类\n  public class EatableDemo {\n      public static void main(String[] args) {\n          //在主方法中调用useEatable方法\n          Eatable e = new EatableImpl();\n          useEatable(e);\n\n          //匿名内部类\n          useEatable(new Eatable() {\n              @Override\n              public void eat() {\n                  System.out.println("一天一苹果，医生远离我");\n              }\n          });\n\n          //Lambda表达式\n          useEatable(() -> {\n              System.out.println("一天一苹果，医生远离我");\n          });\n      }\n\n      private static void useEatable(Eatable e) {\n          e.eat();\n      }\n  }\n  ```\n\n### 5.4Lambda表达式练习2【应用】\n\n- 练习描述\n\n  有参无返回值抽象方法的练习\n\n- 操作步骤\n\n  - 定义一个接口(Flyable)，里面定义一个抽象方法：void fly(String s);\n  - 定义一个测试类(FlyableDemo)，在测试类中提供两个方法\n    - 一个方法是：useFlyable(Flyable f)\n    - 一个方法是主方法，在主方法中调用useFlyable方法\n\n- 示例代码\n\n  ```java\n  public interface Flyable {\n      void fly(String s);\n  }\n\n  public class FlyableDemo {\n      public static void main(String[] args) {\n          //在主方法中调用useFlyable方法\n          //匿名内部类\n          useFlyable(new Flyable() {\n              @Override\n              public void fly(String s) {\n                  System.out.println(s);\n                  System.out.println("飞机自驾游");\n              }\n          });\n          System.out.println("--------");\n\n          //Lambda\n          useFlyable((String s) -> {\n              System.out.println(s);\n              System.out.println("飞机自驾游");\n          });\n\n      }\n\n      private static void useFlyable(Flyable f) {\n          f.fly("风和日丽，晴空万里");\n      }\n  }\n  ```\n\n### 5.5Lambda表达式练习3【应用】\n\n- 练习描述\n\n  有参有返回值抽象方法的练习\n\n- 操作步骤\n\n  - 定义一个接口(Addable)，里面定义一个抽象方法：int add(int x,int y);\n  - 定义一个测试类(AddableDemo)，在测试类中提供两个方法\n    - 一个方法是：useAddable(Addable a)\n    - 一个方法是主方法，在主方法中调用useAddable方法\n\n- 示例代码\n\n  ```java\n  public interface Addable {\n      int add(int x,int y);\n  }\n\n  public class AddableDemo {\n      public static void main(String[] args) {\n          //在主方法中调用useAddable方法\n          useAddable((int x,int y) -> {\n              return x + y;\n          });\n\n      }\n\n      private static void useAddable(Addable a) {\n          int sum = a.add(10, 20);\n          System.out.println(sum);\n      }\n  }\n  ```\n\n### 5.6Lambda表达式的省略模式【应用】\n\n- 省略的规则\n\n  - 参数类型可以省略。但是有多个参数的情况下，不能只省略一个\n  - 如果参数有且仅有一个，那么小括号可以省略\n  - 如果代码块的语句只有一条，可以省略大括号和分号，和return关键字\n\n- 代码演示\n\n  ```java\n  public interface Addable {\n      int add(int x, int y);\n  }\n\n  public interface Flyable {\n      void fly(String s);\n  }\n\n  public class LambdaDemo {\n      public static void main(String[] args) {\n  //        useAddable((int x,int y) -> {\n  //            return x + y;\n  //        });\n          //参数的类型可以省略\n          useAddable((x, y) -> {\n              return x + y;\n          });\n\n  //        useFlyable((String s) -> {\n  //            System.out.println(s);\n  //        });\n          //如果参数有且仅有一个，那么小括号可以省略\n  //        useFlyable(s -> {\n  //            System.out.println(s);\n  //        });\n\n          //如果代码块的语句只有一条，可以省略大括号和分号\n          useFlyable(s -> System.out.println(s));\n\n          //如果代码块的语句只有一条，可以省略大括号和分号，如果有return，return也要省略掉\n          useAddable((x, y) -> x + y);\n      }\n\n      private static void useFlyable(Flyable f) {\n          f.fly("风和日丽，晴空万里");\n      }\n\n      private static void useAddable(Addable a) {\n          int sum = a.add(10, 20);\n          System.out.println(sum);\n      }\n  }\n  ```\n\n### 5.7Lambda表达式的使用前提【理解】\n\n- 使用Lambda必须要有接口\n- 并且要求接口中有且仅有一个抽象方法\n\n### 5.8Lambda表达式和匿名内部类的区别【理解】\n\n- 所需类型不同\n  - 匿名内部类：可以是接口，也可以是抽象类，还可以是具体类\n  - Lambda表达式：只能是接口\n- 使用限制不同\n  - 如果接口中有且仅有一个抽象方法，可以使用Lambda表达式，也可以使用匿名内部类\n  - 如果接口中多于一个抽象方法，只能使用匿名内部类，而不能使用Lambda表达式\n- 实现原理不同\n  - 匿名内部类：编译之后，产生一个单独的.class字节码文件\n  - Lambda表达式：编译之后，没有一个单独的.class字节码文件。对应的字节码会在运行的时候动态生成\n\n\n\n',ln={data:function(){return{MainComponent1:an,MainComponent2:sn,MainComponent3:on}}},cn=ln,pn=Object(d["a"])(cn,tn,rn,!1,null,"40a7023c",null),un=pn.exports,mn=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent1}}),t("q-markdown",{attrs:{src:n.MainComponent2}})],1)},dn=[],gn='## 1.API\n\n### 1.1 API概述【理解】\n\n- 什么是API\n\n  ​\tAPI (Application Programming Interface) ：应用程序编程接口\n\n- java中的API\n\n  ​\t指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。\n\n### 1.2 如何使用API帮助文档【应用】\n\n- 打开帮助文档\n\n![01](./img/java/basics/day14-常用API01.img/01.png)\n\n- 找到索引选项卡中的输入框\n\n![02](./img/java/basics/day14-常用API01.img/02.png)\n\n- 在输入框中输入Random\n\n![03](./img/java/basics/day14-常用API01.img/03.png)\n\n- 看类在哪个包下\n\n![04](./img/java/basics/day14-常用API01.img/04.png)\n\n- 看类的描述\n\n![05](./img/java/basics/day14-常用API01.img/05.png)\n\n- 看构造方法\n\n![06](./img/java/basics/day14-常用API01.img/06.png)\n\n- 看成员方法\n\n![07](./img/java/basics/day14-常用API01.img/07.png)\n\n## 2.常用API \n\n### 2.1 Math（应用）\n\n- 1、Math类概述\n\n  - Math 包含执行基本数字运算的方法\n\n- 2、Math中方法的调用方式\n\n  - Math类中无构造方法，但内部的方法都是静态的，则可以通过   **类名.进行调用**\n\n- 3、Math类的常用方法\n\n  | 方法名    方法名                               | 说明                         |\n  | ---------------------------------------- | -------------------------- |\n  | public static int   abs(int a)           | 返回参数的绝对值                   |\n  | public static double ceil(double a)      | 返回大于或等于参数的最小double值，等于一个整数 |\n  | public static double floor(double a)     | 返回小于或等于参数的最大double值，等于一个整数 |\n  | public   static int round(float a)       | 按照四舍五入返回最接近参数的int          |\n  | public static int   max(int a,int b)     | 返回两个int值中的较大值              |\n  | public   static int min(int a,int b)     | 返回两个int值中的较小值              |\n  | public   static double pow (double a,double b) | 返回a的b次幂的值                  |\n  | public   static double random()          | 返回值为double的正值，[0.0,1.0)    |\n\n### 2.2 System（应用）\n\n- System类的常用方法 \n  | 方法名                                      | 说明                            |\n  | ---------------------------------------- | ----------------------------- |\n  | public   static void exit(int status)    | 终止当前运行的   Java   虚拟机，非零表示异常终止 |\n  | public   static long currentTimeMillis() | 返回当前时间(以毫秒为单位)                |\n\n- 示例代码\n\n  - 需求：在控制台输出1-10000，计算这段代码执行了多少毫秒 \n\n  ```java\n  public class SystemDemo {\n      public static void main(String[] args) {\n          // 获取开始的时间节点\n          long start = System.currentTimeMillis();\n          for (int i = 1; i <= 10000; i++) {\n              System.out.println(i);\n          }\n          // 获取代码运行结束后的时间节点\n          long end = System.currentTimeMillis();\n          System.out.println("共耗时：" + (end - start) + "毫秒");\n      }\n  }\n  ```\n\n### 2.3 Object类的toString方法（应用）\n\n- Object类概述\n\n  - Object 是类层次结构的根，每个类都可以将 Object 作为超类。所有类都直接或者间接的继承自该类，换句话说，该类所具备的方法，所有类都会有一份\n\n- 查看方法源码的方式\n\n  - 选中方法，按下Ctrl + B\n\n- 重写toString方法的方式\n\n  - 1. Alt + Insert 选择toString\n  - 1. 在类的空白区域，右键 -> Generate -> 选择toString\n\n- toString方法的作用：\n\n  - 以良好的格式，更方便的展示对象中的属性值\n\n- 示例代码：\n\n  ```java\n  class Student extends Object {\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public String toString() {\n          return "Student{" +\n                  "name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n  }\n  public class ObjectDemo {\n      public static void main(String[] args) {\n          Student s = new Student();\n          s.setName("林青霞");\n          s.setAge(30);\n          System.out.println(s); \n          System.out.println(s.toString()); \n      }\n  }\n  ```\n\n- 运行结果：\n\n  ```java\n  Student{name=\'林青霞\', age=30}\n  Student{name=\'林青霞\', age=30}\n  ```\n\n### 2.4 Object类的equals方法（应用）\n\n- equals方法的作用\n\n  - 用于对象之间的比较，返回true和false的结果\n  - 举例：s1.equals(s2);    s1和s2是两个对象\n\n- 重写equals方法的场景\n\n  - 不希望比较对象的地址值，想要结合对象属性进行比较的时候。\n\n- 重写equals方法的方式\n\n  - 1. alt + insert  选择equals() and hashCode()，IntelliJ Default，一路next，finish即可\n  - 1. 在类的空白区域，右键 -> Generate -> 选择equals() and hashCode()，后面的同上。\n\n- 示例代码：\n\n  ```java\n  class Student {\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public boolean equals(Object o) {\n          //this -- s1\n          //o -- s2\n          if (this == o) return true;\n          if (o == null || getClass() != o.getClass()) return false;\n\n          Student student = (Student) o; //student -- s2\n\n          if (age != student.age) return false;\n          return name != null ? name.equals(student.name) : student.name == null;\n      }\n  }\n  public class ObjectDemo {\n      public static void main(String[] args) {\n          Student s1 = new Student();\n          s1.setName("林青霞");\n          s1.setAge(30);\n\n          Student s2 = new Student();\n          s2.setName("林青霞");\n          s2.setAge(30);\n\n          //需求：比较两个对象的内容是否相同\n          System.out.println(s1.equals(s2));\n      }\n  }\n\n  ```\n\n- 面试题\n\n  ```java\n  // 看程序,分析结果\n  String s = “abc”;\n  StringBuilder sb = new StringBuilder(“abc”);\n  s.equals(sb); \n  sb.equals(s); \n\n  public class InterviewTest {\n      public static void main(String[] args) {\n          String s1 = "abc";\n          StringBuilder sb = new StringBuilder("abc");\n          //1.此时调用的是String类中的equals方法.\n          //保证参数也是字符串,否则不会比较属性值而直接返回false\n          //System.out.println(s1.equals(sb)); // false\n\n          //StringBuilder类中是没有重写equals方法,用的就是Object类中的.\n          System.out.println(sb.equals(s1)); // false\n      }\n  }\n  ```\n\n### 2.5 Objects (应用)\n\n+ 常用方法\n\n  | 方法名                                      | 说明               |\n  | ---------------------------------------- | ---------------- |\n  | public static String toString(对象)        | 返回参数中对象的字符串表示形式。 |\n  | public static String toString(对象, 默认字符串) | 返回对象的字符串表示形式。    |\n  | public static Boolean isNull(对象)         | 判断对象是否为空         |\n  | public static Boolean nonNull(对象)        | 判断对象是否不为空        |\n\n+ 示例代码\n\n  学生类\n\n  ```java\n  class Student {\n        private String name;\n        private int age;\n\n        public Student() {\n        }\n\n        public Student(String name, int age) {\n            this.name = name;\n            this.age = age;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public int getAge() {\n            return age;\n        }\n\n        public void setAge(int age) {\n            this.age = age;\n        }\n\n        @Override\n        public String toString() {\n            return "Student{" +\n                    "name=\'" + name + \'\\\'\' +\n                    ", age=" + age +\n                    \'}\';\n        }\n    }\n  ```\n\n  测试类\n\n  ```java\n  public class MyObjectsDemo {\n            public static void main(String[] args) {\n        //        public static String toString(对象): 返回参数中对象的字符串表示形式。\n        //        Student s = new Student("小罗同学",50);\n        //        String result = Objects.toString(s);\n        //        System.out.println(result);\n        //        System.out.println(s);\n\n        //        public static String toString(对象, 默认字符串): 返回对象的字符串表示形式。如果对象为空,那么返回第二个参数.\n                //Student s = new Student("小花同学",23);\n        //        Student s = null;\n        //        String result = Objects.toString(s, "随便写一个");\n        //        System.out.println(result);\n        \n        //        public static Boolean isNull(对象): 判断对象是否为空\n                //Student s = null;\n        //        Student s = new Student();\n        //        boolean result = Objects.isNull(s);\n        //        System.out.println(result);\n\n        //        public static Boolean nonNull(对象): 判断对象是否不为空\n                //Student s = new Student();\n                Student s = null;\n                boolean result = Objects.nonNull(s);\n                System.out.println(result);\n            }\n    }\n  ```\n\n\n### 2.6 BigDecimal (应用)\n\n+ 作用\n\n  可以用来进行精确计算\n\n\n+ 构造方法\n\n  | 方法名                    | 说明        |\n  | ---------------------- | --------- |\n  | BigDecimal(double val) | 参数为double |\n  | BigDecimal(String val) | 参数为String |\n\n+ 常用方法\n\n  | 方法名                                      | 说明   |\n  | ---------------------------------------- | ---- |\n  | public BigDecimal add(另一个BigDecimal对象)   | 加法   |\n  | public BigDecimal subtract (另一个BigDecimal对象) | 减法   |\n  | public BigDecimal multiply (另一个BigDecimal对象) | 乘法   |\n  | public BigDecimal divide (另一个BigDecimal对象) | 除法   |\n  | public BigDecimal divide (另一个BigDecimal对象，精确几位，舍入模式) | 除法   |\n\n+ 总结\n\n  1. BigDecimal是用来进行精确计算的\n  2. 创建BigDecimal的对象，构造方法使用参数类型为字符串的。\n  3. 四则运算中的除法，如果除不尽请使用divide的三个参数的方法。\n\n  代码示例：\n\n  ```java\n  BigDecimal divide = bd1.divide(参与运算的对象,小数点后精确到多少位,舍入模式);\n  参数1 ，表示参与运算的BigDecimal 对象。\n  参数2 ，表示小数点后面精确到多少位\n  参数3 ，舍入模式  \n    BigDecimal.ROUND_UP  进一法\n    BigDecimal.ROUND_FLOOR 去尾法\n    BigDecimal.ROUND_HALF_UP 四舍五入\n  ```\n\n## 3.包装类\n\n### 3.1 基本类型包装类（记忆）\n\n- 基本类型包装类的作用\n\n   将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据\n\n   常用的操作之一：用于基本数据类型与字符串之间的转换\n\n- 基本类型对应的包装类\n\n  | 基本数据类型  | 包装类       |\n  | ------- | --------- |\n  | byte    | Byte      |\n  | short   | Short     |\n  | int     | Integer   |\n  | long    | Long      |\n  | float   | Float     |\n  | double  | Double    |\n  | char    | Character |\n  | boolean | Boolean   |\n\n### 3.2 Integer类（应用）\n\n- Integer类概述\n\n   包装一个对象中的原始类型 int 的值\n\n- Integer类构造方法\n\n  | 方法名                                     | 说明                           |\n  | --------------------------------------- | ---------------------------- |\n  | public Integer(int   value)             | 根据 int 值创建 Integer 对象(过时)    |\n  | public Integer(String s)                | 根据 String 值创建 Integer 对象(过时) |\n  | public static Integer valueOf(int i)    | 返回表示指定的 int 值的 Integer   实例  |\n  | public static Integer valueOf(String s) | 返回一个保存指定值的 Integer 对象 String |\n\n- 示例代码\n\n  ```java\n  public class IntegerDemo {\n      public static void main(String[] args) {\n          //public Integer(int value)：根据 int 值创建 Integer 对象(过时)\n          Integer i1 = new Integer(100);\n          System.out.println(i1);\n\n          //public Integer(String s)：根据 String 值创建 Integer 对象(过时)\n          Integer i2 = new Integer("100");\n  //        Integer i2 = new Integer("abc"); //NumberFormatException\n          System.out.println(i2);\n          System.out.println("--------");\n\n          //public static Integer valueOf(int i)：返回表示指定的 int 值的 Integer 实例\n          Integer i3 = Integer.valueOf(100);\n          System.out.println(i3);\n\n          //public static Integer valueOf(String s)：返回一个保存指定值的Integer对象 String\n          Integer i4 = Integer.valueOf("100");\n          System.out.println(i4);\n      }\n  }\n  ```\n\n### 3.3 自动拆箱和自动装箱（理解）\n\n- 自动装箱\n\n  ​\t把基本数据类型转换为对应的包装类类型\n\n- 自动拆箱\n\n  ​\t把包装类类型转换为对应的基本数据类型\n\n- 示例代码\n\n  ```java\n  Integer i = 100;  // 自动装箱\n  i += 200;         // i = i + 200;  i + 200 自动拆箱；i = i + 200; 是自动装箱\n  ```\n\n### 3.4 int和String类型的相互转换（记忆）\n\n- int转换为String\n\n  - 转换方式\n\n    - 方式一：直接在数字后加一个空字符串\n    - 方式二：通过String类静态方法valueOf()\n\n  - 示例代码\n\n    ```java\n    public class IntegerDemo {\n        public static void main(String[] args) {\n            //int --- String\n            int number = 100;\n            //方式1\n            String s1 = number + "";\n            System.out.println(s1);\n            //方式2\n            //public static String valueOf(int i)\n            String s2 = String.valueOf(number);\n            System.out.println(s2);\n            System.out.println("--------");\n        }\n    }\n    ```\n\n- String转换为int\n\n  - 转换方式\n\n    - 方式一：先将字符串数字转成Integer，再调用valueOf()方法\n    - 方式二：通过Integer静态方法parseInt()进行转换\n\n  - 示例代码\n\n    ```java\n    public class IntegerDemo {\n        public static void main(String[] args) {\n            //String --- int\n            String s = "100";\n            //方式1：String --- Integer --- int\n            Integer i = Integer.valueOf(s);\n            //public int intValue()\n            int x = i.intValue();\n            System.out.println(x);\n            //方式2\n            //public static int parseInt(String s)\n            int y = Integer.parseInt(s);\n            System.out.println(y);\n        }\n    }\n    ```\n\n### 3.5 字符串数据排序案例（应用）\n\n- 案例需求\n\n  ​\t有一个字符串：“91 27 46 38 50”，请写程序实现最终输出结果是：27 38 46 50 91\n\n- 代码实现\n\n  ```java\n  public class IntegerTest {\n      public static void main(String[] args) {\n          //定义一个字符串\n          String s = "91 27 46 38 50";\n\n          //把字符串中的数字数据存储到一个int类型的数组中\n          String[] strArray = s.split(" ");\n  //        for(int i=0; i<strArray.length; i++) {\n  //            System.out.println(strArray[i]);\n  //        }\n\n          //定义一个int数组，把 String[] 数组中的每一个元素存储到 int 数组中\n          int[] arr = new int[strArray.length];\n          for(int i=0; i<arr.length; i++) {\n              arr[i] = Integer.parseInt(strArray[i]);\n          }\n\n          //对 int 数组进行排序\n          Arrays.sort(arr);\n\n        \tfor(int i=0; i<arr.length; i++){\n           System.out.print(arr[i] + " ");\n        \t}\n  }\n  ```\n\n## 4.递归\n\n### 4.1 递归【应用】\n\n- 递归的介绍\n\n  - 以编程的角度来看，递归指的是方法定义中调用方法本身的现象\n  - 把一个复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解\n  - 递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算\n\n- 递归的基本使用\n\n  ```java\n  public class MyFactorialDemo2 {\n      public static void main(String[] args) {\n          int sum = getSum(100);\n          System.out.println(sum);\n      }\n\n      private static int getSum(int i) {\n          //1- 100之间的和\n              //100 + (1-99之间的和)\n                      // 99 + (1- 98之间的和)\n                          //....\n                              //1\n          //方法的作用: 求 1- i 之间和\n          if(i == 1){\n              return 1;\n          }else{\n              return i + getSum(i -1);\n          }\n      }\n  }    \n  ```\n\n- 递归的注意事项\n\n  - 递归一定要有出口。否则内存溢出\n  - 递归虽然有出口，但是递归的次数也不宜过多。否则内存溢出\n\n### 4.2 递归求阶乘【应用】\n\n- 案例需求\n\n  ​\t用递归求5的阶乘，并把结果在控制台输出\n\n- 代码实现\n\n  ```java\n  public class DiGuiDemo01 {\n      public static void main(String[] args) {\n          //调用方法\n          int result = jc(5);\n          //输出结果\n          System.out.println("5的阶乘是：" + result);\n      }\n\n      //定义一个方法，用于递归求阶乘，参数为一个int类型的变量\n      public static int jc(int n) {\n          //在方法内部判断该变量的值是否是1\n          if(n == 1) {\n              //是：返回1\n              return 1;\n          } else {\n              //不是：返回n*(n-1)!\n              return n*jc(n-1);\n          }\n      }\n  }\n  ```\n\n- 内存图\n\n  ![08_递归内存图](./img/java/basics/day14-常用API01.img/08_递归内存图.png)\n\n## 5.数组的高级操作 \n\n### 5.1 二分查找 (理解)\n\n+ 二分查找概述\n\n  查找指定元素在数组中的位置时,以前的方式是通过遍历,逐个获取每个元素,看是否是要查找的元素,这种方式当数组元素较多时,查找的效率很低\n\n  二分查找也叫折半查找,每次可以去掉一半的查找范围,从而提高查找的效率\n\n\n+ 需求\n\n  在数组{1,2,3,4,5,6,7,8,9,10}中,查找某个元素的位置\n\n+ 实现步骤\n\n  1. 定义两个变量，表示要查找的范围。默认min = 0 ，max = 最大索引\n  2. 循环查找，但是min <= max\n  3. 计算出mid的值\n  4. 判断mid位置的元素是否为要查找的元素，如果是直接返回对应索引\n  5. 如果要查找的值在mid的左半边，那么min值不变，max = mid -1.继续下次循环查找\n  6. 如果要查找的值在mid的右半边，那么max值不变，min = mid + 1.继续下次循环查找\n  7. 当min > max 时，表示要查找的元素在数组中不存在，返回-1.\n\n+ 代码实现\n\n  ```java\n  public class MyBinarySearchDemo {\n      public static void main(String[] args) {\n          int [] arr = {1,2,3,4,5,6,7,8,9,10};\n          int number = 11;\n\n          //1,我现在要干嘛? --- 二分查找\n          //2.我干这件事情需要什么? --- 数组 元素\n          //3,我干完了,要不要把结果返回调用者 --- 把索引返回给调用者\n          int index = binarySearchForIndex(arr,number);\n          System.out.println(index);\n      }\n\n      private static int binarySearchForIndex(int[] arr, int number) {\n          //1,定义查找的范围\n          int min = 0;\n          int max = arr.length - 1;\n          //2.循环查找 min <= max\n          while(min <= max){\n              //3.计算出中间位置 mid\n              int mid = (min + max) >> 1;\n              //mid指向的元素 > number\n              if(arr[mid] > number){\n                  //表示要查找的元素在左边.\n                  max = mid -1;\n              }else if(arr[mid] < number){\n                  //mid指向的元素 < number\n                  //表示要查找的元素在右边.\n                  min = mid + 1;\n              }else{\n                  //mid指向的元素 == number\n                  return mid;\n              }\n          }\n          //如果min大于了max就表示元素不存在,返回-1.\n          return -1;\n      }\n    \n  }\n  ```\n\n+ 注意事项\n\n  有一个前提条件，数组内的元素一定要按照大小顺序排列，如果没有大小顺序，是不能使用二分查找法的\n\n### 5.2 冒泡排序 (理解)\n\n+ 冒泡排序概述\n\n  一种排序的方式，对要进行排序的数据中相邻的数据进行两两比较，将较大的数据放在后面，依次对所有的数据进行操作，直至所有数据按要求完成排序\n\n  如果有n个数据进行排序，总共需要比较n-1次\n\n  每一次比较完毕，下一次的比较就会少一个数据参与\n\n+ 代码实现\n\n  ```java\n  public class MyBubbleSortDemo2 {\n      public static void main(String[] args) {\n          int[] arr = {3, 5, 2, 1, 4};\n          //1 2 3 4 5\n          bubbleSort(arr);\n      }\n\n      private static void bubbleSort(int[] arr) {\n          //外层循环控制的是次数 比数组的长度少一次.\n          for (int i = 0; i < arr.length -1; i++) {\n              //内存循环就是实际循环比较的\n              //-1 是为了让数组不要越界\n              //-i 每一轮结束之后,我们就会少比一个数字.\n              for (int j = 0; j < arr.length - 1 - i; j++) {\n                  if (arr[j] > arr[j + 1]) {\n                      int temp = arr[j];\n                      arr[j] = arr[j + 1];\n                      arr[j + 1] = temp;\n                  }\n              }\n          }\n\n          printArr(arr);\n      }\n\n      private static void printArr(int[] arr) {\n          for (int i = 0; i < arr.length; i++) {\n              System.out.print(arr[i] + " ");\n          }\n          System.out.println();\n      }\n    \n  }\n  ```\n\n### 5.3 快速排序 (理解)\n\n+ 快速排序概述\n\n  冒泡排序算法中,一次循环结束,就相当于确定了当前的最大值,也能确定最大值在数组中应存入的位置\n\n  快速排序算法中,每一次递归时以第一个数为基准数,找到数组中所有比基准数小的.再找到所有比基准数大的.小的全部放左边,大的全部放右边,确定基准数的正确位置\n\n+ 核心步骤\n\n  1. 从右开始找比基准数小的\n  2. 从左开始找比基准数大的\n  3. 交换两个值的位置\n  4. 红色继续往左找，蓝色继续往右找，直到两个箭头指向同一个索引为止\n  5. 基准数归位\n\n+ 代码实现\n\n  ```java\n  public class MyQuiteSortDemo2 {\n      public static void main(String[] args) {\n  //        1，从右开始找比基准数小的\n  //        2，从左开始找比基准数大的\n  //        3，交换两个值的位置\n  //        4，红色继续往左找，蓝色继续往右找，直到两个箭头指向同一个索引为止\n  //        5，基准数归位\n          int[] arr = {6, 1, 2, 7, 9, 3, 4, 5, 10, 8};\n\n          quiteSort(arr,0,arr.length-1);\n\n          for (int i = 0; i < arr.length; i++) {\n              System.out.print(arr[i] + " ");\n          }\n      }\n\n      private static void quiteSort(int[] arr, int left, int right) {\n       \t// 递归结束的条件\n          if(right < left){\n              return;\n          }\n\n          int left0 = left;\n          int right0 = right;\n\n          //计算出基准数\n          int baseNumber = arr[left0];\n\n          while(left != right){\n  //        1，从右开始找比基准数小的\n              while(arr[right] >= baseNumber && right > left){\n                  right--;\n              }\n  //        2，从左开始找比基准数大的\n              while(arr[left] <= baseNumber && right > left){\n                  left++;\n              }\n  //        3，交换两个值的位置\n              int temp = arr[left];\n              arr[left] = arr[right];\n              arr[right] = temp;\n          }\n          //基准数归位\n          int temp = arr[left];\n          arr[left] = arr[left0];\n          arr[left0] = temp;\n        \n  \t\t// 递归调用自己,将左半部分排好序\n          quiteSort(arr,left0,left-1);\n        \t// 递归调用自己,将右半部分排好序\n          quiteSort(arr,left +1,right0);\n\n      }\n  }\n  ```\n\n### 5.4 Arrays (应用)\n\n- Arrays的常用方法\n\n  | 方法名                                      | 说明                |\n  | ---------------------------------------- | ----------------- |\n  | public static String toString(int[] a)   | 返回指定数组的内容的字符串表示形式 |\n  | public static void sort(int[] a)         | 按照数字顺序排列指定的数组     |\n  | public static int binarySearch(int[] a, int key) | 利用二分查找返回指定元素的索引   |\n\n- 示例代码\n\n  ```java\n  public class MyArraysDemo {\n        public static void main(String[] args) {\n    //        public static String toString(int[] a)    返回指定数组的内容的字符串表示形式\n    //        int [] arr = {3,2,4,6,7};\n    //        System.out.println(Arrays.toString(arr));\n\n    //        public static void sort(int[] a)\t  按照数字顺序排列指定的数组\n    //        int [] arr = {3,2,4,6,7};\n    //        Arrays.sort(arr);\n    //        System.out.println(Arrays.toString(arr));\n\n    //        public static int binarySearch(int[] a, int key) 利用二分查找返回指定元素的索引\n            int [] arr = {1,2,3,4,5,6,7,8,9,10};\n            int index = Arrays.binarySearch(arr, 0);\n            System.out.println(index);\n            //1,数组必须有序\n            //2.如果要查找的元素存在,那么返回的是这个元素实际的索引\n            //3.如果要查找的元素不存在,那么返回的是 (-插入点-1)\n                //插入点:如果这个元素在数组中,他应该在哪个索引上.\n        }\n    }\n  ```\n\n- 工具类设计思想\n\n  1. 构造方法用 private 修饰\n  2. 成员用 public static 修饰\n\n\n\n',Sn='## 1.时间日期类\n\n### 1.1 Date类（应用）\n\n+ 计算机中时间原点\n\n  1970年1月1日 00:00:00\n\n+ 时间换算单位\n\n  1秒 = 1000毫秒\n\n+ Date类概述\n\n  Date 代表了一个特定的时间，精确到毫秒\n\n+ Date类构造方法\n\n  | 方法名                    | 说明                                  |\n  | ---------------------- | ----------------------------------- |\n  | public Date()          | 分配一个 Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒 |\n  | public Date(long date) | 分配一个 Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数 |\n\n+ 示例代码\n\n  ```java\n  public class DateDemo01 {\n      public static void main(String[] args) {\n          //public Date()：分配一个 Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒\n          Date d1 = new Date();\n          System.out.println(d1);\n\n          //public Date(long date)：分配一个 Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数\n          long date = 1000*60*60;\n          Date d2 = new Date(date);\n          System.out.println(d2);\n      }\n  }\n  ```\n\n### 1.2 Date类常用方法（应用）\n\n- 常用方法\n\n  | 方法名                            | 说明                                 |\n  | ------------------------------ | ---------------------------------- |\n  | public long getTime()          | 获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值 |\n  | public void setTime(long time) | 设置时间，给的是毫秒值                        |\n\n- 示例代码\n\n  ```java\n  public class DateDemo02 {\n      public static void main(String[] args) {\n          //创建日期对象\n          Date d = new Date();\n\n          //public long getTime():获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值\n  //        System.out.println(d.getTime());\n  //        System.out.println(d.getTime() * 1.0 / 1000 / 60 / 60 / 24 / 365 + "年");\n\n          //public void setTime(long time):设置时间，给的是毫秒值\n  //        long time = 1000*60*60;\n          long time = System.currentTimeMillis();\n          d.setTime(time);\n\n          System.out.println(d);\n      }\n  }\n  ```\n\n### 1.3 SimpleDateFormat类（应用）\n\n- SimpleDateFormat类概述\n\n  ​\tSimpleDateFormat是一个具体的类，用于以区域设置敏感的方式格式化和解析日期。\n\n  ​\t我们重点学习日期格式化和解析\n\n- SimpleDateFormat类构造方法\n\n  | 方法名                                     | 说明                                  |\n  | --------------------------------------- | ----------------------------------- |\n  | public   SimpleDateFormat()             | 构造一个SimpleDateFormat，使用默认模式和日期格式    |\n  | public SimpleDateFormat(String pattern) | 构造一个SimpleDateFormat使用给定的模式和默认的日期格式 |\n\n- SimpleDateFormat类的常用方法\n\n  - 格式化(从Date到String)\n    - public final String format(Date date)：将日期格式化成日期/时间字符串\n  - 解析(从String到Date)\n    - public Date parse(String source)：从给定字符串的开始解析文本以生成日期\n\n- 示例代码\n\n  ```java\n  public class SimpleDateFormatDemo {\n      public static void main(String[] args) throws ParseException {\n          //格式化：从 Date 到 String\n          Date d = new Date();\n  //        SimpleDateFormat sdf = new SimpleDateFormat();\n          SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");\n          String s = sdf.format(d);\n          System.out.println(s);\n          System.out.println("--------");\n\n          //从 String 到 Date\n          String ss = "2048-08-09 11:11:11";\n          //ParseException\n          SimpleDateFormat sdf2 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");\n          Date dd = sdf2.parse(ss);\n          System.out.println(dd);\n      }\n  }\n  ```\n\n### 1.4 时间日期类练习 (应用) \n\n+ 需求\n\n  秒杀开始时间是2020年11月11日 00:00:00,结束时间是2020年11月11日 00:10:00,用户小贾下单时间是2020年11月11日 00:03:47,用户小皮下单时间是2020年11月11日 00:10:11,判断用户有没有成功参与秒杀活动\n\n+ 实现步骤\n\n  1. 判断下单时间是否在开始到结束的范围内\n  2. 把字符串形式的时间变成毫秒值\n\n+ 代码实现\n\n  ```java\n  public class DateDemo5 {\n      public static void main(String[] args) throws ParseException {\n          //开始时间：2020年11月11日 0:0:0\n          //结束时间：2020年11月11日 0:10:0\n\n          //小贾2020年11月11日 0:03:47\n          //小皮2020年11月11日 0:10:11\n\n          //1.判断两位同学的下单时间是否在范围之内就可以了。\n\n          //2.要把每一个时间都换算成毫秒值。\n\n          String start = "2020年11月11日 0:0:0";\n          String end = "2020年11月11日 0:10:0";\n\n          String jia = "2020年11月11日 0:03:47";\n          String pi = "2020年11月11日 0:10:11";\n\n          SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");\n          long startTime = sdf.parse(start).getTime();\n          long endTime = sdf.parse(end).getTime();\n\n  //        System.out.println(startTime);\n  //        System.out.println(endTime);\n          long jiaTime = sdf.parse(jia).getTime();\n          long piTime = sdf.parse(pi).getTime();\n\n          if(jiaTime >= startTime && jiaTime <= endTime){\n              System.out.println("小贾同学参加上了秒杀活动");\n          }else{\n              System.out.println("小贾同学没有参加上秒杀活动");\n          }\n\n          System.out.println("------------------------");\n\n          if(piTime >= startTime && piTime <= endTime){\n              System.out.println("小皮同学参加上了秒杀活动");\n          }else{\n              System.out.println("小皮同学没有参加上秒杀活动");\n          }\n\n      }\n    \n  }\n  ```\n\n## 2.JDK8时间日期类 \n\n### 2.1 JDK8新增日期类 (理解) \n\n+ LocalDate       表示日期（年月日）  \n+ LocalTime       表示时间（时分秒）\n+ LocalDateTime    表示时间+ 日期 （年月日时分秒）\n\n### 2.2 LocalDateTime创建方法 (应用) \n\n+ 方法说明\n\n  | 方法名                                      | 说明                              |\n  | ---------------------------------------- | ------------------------------- |\n  | public static LocalDateTime now()        | 获取当前系统时间                        |\n  | public static LocalDateTime of  (年, 月 , 日, 时, 分, 秒) | 使用指定年月日和时分秒初始化一个LocalDateTime对象 |\n\n+ 示例代码\n\n  ```java\n  public class JDK8DateDemo2 {\n      public static void main(String[] args) {\n          LocalDateTime now = LocalDateTime.now();\n          System.out.println(now);\n\n          LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 11, 11, 11);\n          System.out.println(localDateTime);\n      }\n  }\n  ```\n\n### 2.3 LocalDateTime获取方法 (应用)\n\n+ 方法说明\n\n  | 方法名                             | 说明               |\n  | ------------------------------- | ---------------- |\n  | public int getYear()            | 获取年              |\n  | public int getMonthValue()      | 获取月份（1-12）       |\n  | public int getDayOfMonth()      | 获取月份中的第几天（1-31）  |\n  | public int getDayOfYear()       | 获取一年中的第几天（1-366） |\n  | public DayOfWeek getDayOfWeek() | 获取星期             |\n  | public int getMinute()          | 获取分钟             |\n  | public int getHour()            | 获取小时             |\n\n+ 示例代码\n\n  ```java\n  public class JDK8DateDemo3 {\n      public static void main(String[] args) {\n          LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 11, 11, 20);\n          //public int getYear()           获取年\n          int year = localDateTime.getYear();\n          System.out.println("年为" +year);\n          //public int getMonthValue()     获取月份（1-12）\n          int month = localDateTime.getMonthValue();\n          System.out.println("月份为" + month);\n\n          Month month1 = localDateTime.getMonth();\n  //        System.out.println(month1);\n\n          //public int getDayOfMonth()     获取月份中的第几天（1-31）\n          int day = localDateTime.getDayOfMonth();\n          System.out.println("日期为" + day);\n\n          //public int getDayOfYear()      获取一年中的第几天（1-366）\n          int dayOfYear = localDateTime.getDayOfYear();\n          System.out.println("这是一年中的第" + dayOfYear + "天");\n\n          //public DayOfWeek getDayOfWeek()获取星期\n          DayOfWeek dayOfWeek = localDateTime.getDayOfWeek();\n          System.out.println("星期为" + dayOfWeek);\n\n          //public int getMinute()        获取分钟\n          int minute = localDateTime.getMinute();\n          System.out.println("分钟为" + minute);\n          //public int getHour()           获取小时\n    \n          int hour = localDateTime.getHour();\n          System.out.println("小时为" + hour);\n      }\n  }\n  ```\n\n### 2.4 LocalDateTime转换方法 (应用)\n\n+ 方法说明\n\n  | 方法名                              | 说明                |\n  | -------------------------------- | ----------------- |\n  | public LocalDate  toLocalDate () | 转换成为一个LocalDate对象 |\n  | public LocalTime toLocalTime ()  | 转换成为一个LocalTime对象 |\n\n+ 示例代码\n\n  ```java\n  public class JDK8DateDemo4 {\n      public static void main(String[] args) {\n          LocalDateTime localDateTime = LocalDateTime.of(2020, 12, 12, 8, 10, 12);\n          //public LocalDate toLocalDate ()    转换成为一个LocalDate对象\n          LocalDate localDate = localDateTime.toLocalDate();\n          System.out.println(localDate);\n\n          //public LocalTime toLocalTime ()    转换成为一个LocalTime对象\n          LocalTime localTime = localDateTime.toLocalTime();\n          System.out.println(localTime);\n      }\n  }\n  ```\n\n### 2.5 LocalDateTime格式化和解析 (应用)\n\n+ 方法说明\n\n  | 方法名                                      | 说明                                     |\n  | ---------------------------------------- | -------------------------------------- |\n  | public String format (指定格式)              | 把一个LocalDateTime格式化成为一个字符串             |\n  | public LocalDateTime parse (准备解析的字符串, 解析格式) | 把一个日期字符串解析成为一个LocalDateTime对象          |\n  | public static DateTimeFormatter ofPattern(String pattern) | 使用指定的日期模板获取一个日期格式化器DateTimeFormatter对象 |\n\n+ 示例代码\n\n  ```java\n  public class JDK8DateDemo5 {\n      public static void main(String[] args) {\n          //method1();\n          //method2();\n      }\n\n      private static void method2() {\n          //public static LocalDateTime parse (准备解析的字符串, 解析格式) 把一个日期字符串解析成为一个LocalDateTime对象\n          String s = "2020年11月12日 13:14:15";\n          DateTimeFormatter pattern = DateTimeFormatter.ofPattern("yyyy年MM月dd日 HH:mm:ss");\n          LocalDateTime parse = LocalDateTime.parse(s, pattern);\n          System.out.println(parse);\n      }\n\n      private static void method1() {\n          LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 12, 13, 14, 15);\n          System.out.println(localDateTime);\n          //public String format (指定格式)   把一个LocalDateTime格式化成为一个字符串\n          DateTimeFormatter pattern = DateTimeFormatter.ofPattern("yyyy年MM月dd日 HH:mm:ss");\n          String s = localDateTime.format(pattern);\n          System.out.println(s);\n      }\n  }\n  ```\n\n### 2.6 LocalDateTime增加或者减少时间的方法 (应用)\n\n+ 方法说明\n\n  | 方法名                                      | 说明      |\n  | ---------------------------------------- | ------- |\n  | public LocalDateTime plusYears (long years) | 添加或者减去年 |\n  | public LocalDateTime plusMonths(long months) | 添加或者减去月 |\n  | public LocalDateTime plusDays(long days) | 添加或者减去日 |\n  | public LocalDateTime plusHours(long hours) | 添加或者减去时 |\n  | public LocalDateTime plusMinutes(long minutes) | 添加或者减去分 |\n  | public LocalDateTime plusSeconds(long seconds) | 添加或者减去秒 |\n  | public LocalDateTime plusWeeks(long weeks) | 添加或者减去周 |\n\n+ 示例代码\n\n  ```java\n  /**\n   * JDK8 时间类添加或者减去时间的方法\n   */\n  public class JDK8DateDemo6 {\n      public static void main(String[] args) {\n          //public LocalDateTime plusYears (long years)   添加或者减去年\n\n          LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 13, 14, 15);\n          //LocalDateTime newLocalDateTime = localDateTime.plusYears(1);\n          //System.out.println(newLocalDateTime);\n\n          LocalDateTime newLocalDateTime = localDateTime.plusYears(-1);\n          System.out.println(newLocalDateTime);\n      }\n  }\n  ```\n\n### 2.7 LocalDateTime减少或者增加时间的方法 (应用)\n\n+ 方法说明\n\n  | 方法名                                      | 说明      |\n  | ---------------------------------------- | ------- |\n  | public LocalDateTime  minusYears (long years) | 减去或者添加年 |\n  | public LocalDateTime  minusMonths(long months) | 减去或者添加月 |\n  | public LocalDateTime minusDays(long days) | 减去或者添加日 |\n  | public LocalDateTime minusHours(long hours) | 减去或者添加时 |\n  | public LocalDateTime minusMinutes(long minutes) | 减去或者添加分 |\n  | public LocalDateTime minusSeconds(long seconds) | 减去或者添加秒 |\n  | public LocalDateTime minusWeeks(long weeks) | 减去或者添加周 |\n\n+ 示例代码\n\n  ```java\n  /**\n   * JDK8 时间类减少或者添加时间的方法\n   */\n  public class JDK8DateDemo7 {\n      public static void main(String[] args) {\n          //public LocalDateTime minusYears (long years)  减去或者添加年\n          LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 13, 14, 15);\n          //LocalDateTime newLocalDateTime = localDateTime.minusYears(1);\n          //System.out.println(newLocalDateTime);\n\n          LocalDateTime newLocalDateTime = localDateTime.minusYears(-1);\n          System.out.println(newLocalDateTime);\n\n      }\n  }\n  ```\n\n### 2.8 LocalDateTime修改方法 (应用)\n\n+ 方法说明\n\n  | 方法名                                      | 说明               |\n  | ---------------------------------------- | ---------------- |\n  | public LocalDateTime withYear(int year)  | 直接修改年            |\n  | public LocalDateTime withMonth(int month) | 直接修改月            |\n  | public LocalDateTime withDayOfMonth(int dayofmonth) | 直接修改日期(一个月中的第几天) |\n  | public LocalDateTime withDayOfYear(int dayOfYear) | 直接修改日期(一年中的第几天)  |\n  | public LocalDateTime withHour(int hour)  | 直接修改小时           |\n  | public LocalDateTime withMinute(int minute) | 直接修改分钟           |\n  | public LocalDateTime withSecond(int second) | 直接修改秒            |\n\n+ 示例代码\n\n  ```java\n  /**\n   * JDK8 时间类修改时间\n   */\n  public class JDK8DateDemo8 {\n      public static void main(String[] args) {\n          //public LocalDateTime withYear(int year)   修改年\n          LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 13, 14, 15);\n         // LocalDateTime newLocalDateTime = localDateTime.withYear(2048);\n         // System.out.println(newLocalDateTime);\n\n          LocalDateTime newLocalDateTime = localDateTime.withMonth(20);\n          System.out.println(newLocalDateTime);\n\n      }\n  }\n  ```\n\n### 2.9 Period (应用)\n\n+ 方法说明\n\n  | 方法名                                     | 说明          |\n  | --------------------------------------- | ----------- |\n  | public static Period between(开始时间,结束时间) | 计算两个“时间"的间隔 |\n  | public int getYears()                   | 获得这段时间的年数   |\n  | public int getMonths()                  | 获得此期间的总月数   |\n  | public int getDays()                    | 获得此期间的天数    |\n  | public long toTotalMonths()             | 获取此期间的总月数   |\n\n+ 示例代码\n\n  ```java\n  /**\n   *  计算两个时间的间隔\n   */\n  public class JDK8DateDemo9 {\n      public static void main(String[] args) {\n          //public static Period between(开始时间,结束时间)  计算两个"时间"的间隔\n\n          LocalDate localDate1 = LocalDate.of(2020, 1, 1);\n          LocalDate localDate2 = LocalDate.of(2048, 12, 12);\n          Period period = Period.between(localDate1, localDate2);\n          System.out.println(period);//P28Y11M11D\n\n          //public int getYears()         获得这段时间的年数\n          System.out.println(period.getYears());//28\n          //public int getMonths()        获得此期间的月数\n          System.out.println(period.getMonths());//11\n          //public int getDays()          获得此期间的天数\n          System.out.println(period.getDays());//11\n\n          //public long toTotalMonths()   获取此期间的总月数\n          System.out.println(period.toTotalMonths());//347\n\n      }\n  }\n  ```\n\n### 2.10 Duration (应用)\n\n+ 方法说明\n\n  | 方法名                                      | 说明          |\n  | ---------------------------------------- | ----------- |\n  | public static Durationbetween(开始时间,结束时间) | 计算两个“时间"的间隔 |\n  | public long toSeconds()                  | 获得此时间间隔的秒   |\n  | public int toMillis()                    | 获得此时间间隔的毫秒  |\n  | public int toNanos()                     | 获得此时间间隔的纳秒  |\n\n+ 示例代码\n\n  ```java\n  /**\n   *  计算两个时间的间隔\n   */\n  public class JDK8DateDemo10 {\n      public static void main(String[] args) {\n          //public static Duration between(开始时间,结束时间)  计算两个“时间"的间隔\n\n          LocalDateTime localDateTime1 = LocalDateTime.of(2020, 1, 1, 13, 14, 15);\n          LocalDateTime localDateTime2 = LocalDateTime.of(2020, 1, 2, 11, 12, 13);\n          Duration duration = Duration.between(localDateTime1, localDateTime2);\n          System.out.println(duration);//PT21H57M58S\n          //public long toSeconds()\t       获得此时间间隔的秒\n          System.out.println(duration.toSeconds());//79078\n          //public int toMillis()\t           获得此时间间隔的毫秒\n          System.out.println(duration.toMillis());//79078000\n          //public int toNanos()             获得此时间间隔的纳秒\n          System.out.println(duration.toNanos());//79078000000000\n      }\n  }\n  ```\n\n## 3.异常\n\n### 3.1 异常（记忆）\n\n- 异常的概述\n\n  ​\t异常就是程序出现了不正常的情况\n\n- 异常的体系结构\n\n  ![01_异常体系结构](./img/java/basics/day15-常用API02.img/01_异常体系结构.png)\n\n### 3.2 编译时异常和运行时异常的区别（记忆）\n\n- 编译时异常\n\n  - 都是Exception类及其子类\n  - 必须显示处理，否则程序就会发生错误，无法通过编译\n\n- 运行时异常\n\n  - 都是RuntimeException类及其子类\n  - 无需显示处理，也可以和编译时异常一样处理\n\n- 图示\n\n  ![02_编译时异常和运行时异常](./img/java/basics/day15-常用API02.img/02_编译时异常和运行时异常.png)\n\n### 3.3 JVM默认处理异常的方式（理解）\n\n- 如果程序出现了问题，我们没有做任何处理，最终JVM 会做默认的处理，处理方式有如下两个步骤：\n  - 把异常的名称，错误原因及异常出现的位置等信息输出在了控制台\n  - 程序停止执行\n\n### 3.4 查看异常信息 (理解) \n\n控制台在打印异常信息时,会打印异常类名,异常出现的原因,异常出现的位置\n\n我们调bug时,可以根据提示,找到异常出现的位置,分析原因,修改异常代码\n\n![03_查看异常信息](./img/java/basics/day15-常用API02.img/03_查看异常信息.png)\n\n### 3.5 throws方式处理异常（应用）\n\n- 定义格式\n\n  ```java\n  public void 方法() throws 异常类名 {\n      \n  }\n  ```\n\n- 示例代码\n\n  ```java\n  public class ExceptionDemo {\n      public static void main(String[] args) throws ParseException{\n          System.out.println("开始");\n  //        method();\n            method2();\n\n          System.out.println("结束");\n      }\n\n      //编译时异常\n      public static void method2() throws ParseException {\n          String s = "2048-08-09";\n          SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");\n          Date d = sdf.parse(s);\n          System.out.println(d);\n      }\n\n      //运行时异常\n      public static void method() throws ArrayIndexOutOfBoundsException {\n          int[] arr = {1, 2, 3};\n          System.out.println(arr[3]);\n      }\n  }\n  ```\n\n- 注意事项\n\n  - 这个throws格式是跟在方法的括号后面的\n  - 编译时异常必须要进行处理，两种处理方案：try...catch …或者 throws，如果采用 throws 这种方案，在方法上进行显示声明,将来谁调用这个方法谁处理\n  - 运行时异常因为在运行时才会发生,所以在方法后面可以不写,运行时出现异常默认交给jvm处理\n\n### 3.6 throw抛出异常 (应用) \n\n+ 格式\n\n  throw new 异常();\n\n+ 注意\n\n  这个格式是在方法内的，表示当前代码手动抛出一个异常，下面的代码不用再执行了\n\n+ throws和throw的区别\n\n  | throws                  | throw                 |\n  | ----------------------- | --------------------- |\n  | 用在方法声明后面，跟的是异常类名        | 用在方法体内，跟的是异常对象名       |\n  | 表示声明异常，调用该方法有可能会出现这样的异常 | 表示手动抛出异常对象，由方法体内的语句处理 |\n\n+ 示例代码\n\n  ```java\n  public class ExceptionDemo8 {\n      public static void main(String[] args) {\n          //int [] arr = {1,2,3,4,5};\n          int [] arr = null;\n          printArr(arr);//就会 接收到一个异常.\n                          //我们还需要自己处理一下异常.\n      }\n\n      private static void printArr(int[] arr) {\n          if(arr == null){\n              //调用者知道成功打印了吗?\n              //System.out.println("参数不能为null");\n              throw new NullPointerException(); //当参数为null的时候\n                                              //手动创建了一个异常对象,抛给了调用者,产生了一个异常\n          }else{\n              for (int i = 0; i < arr.length; i++) {\n                  System.out.println(arr[i]);\n              }\n          }\n      }\n\n  }\n  ```\n\n### 3.7 try-catch方式处理异常（应用）\n\n- 定义格式\n\n  ```java\n  try {\n  \t可能出现异常的代码;\n  } catch(异常类名 变量名) {\n  \t异常的处理代码;\n  }\n  ```\n\n- 执行流程\n\n  - 程序从 try 里面的代码开始执行\n  - 出现异常，就会跳转到对应的 catch 里面去执行\n  - 执行完毕之后，程序还可以继续往下执行\n\n- 示例代码\n\n  ```java\n  public class ExceptionDemo01 {\n      public static void main(String[] args) {\n          System.out.println("开始");\n          method();\n          System.out.println("结束");\n      }\n\n      public static void method() {\n          try {\n              int[] arr = {1, 2, 3};\n              System.out.println(arr[3]);\n              System.out.println("这里能够访问到吗");\n          } catch (ArrayIndexOutOfBoundsException e) {\n              System.out.println("你访问的数组索引不存在，请回去修改为正确的索引");\n          }\n      }\n  }\n  ```\n\n- 注意\n\n  1. 如果 try 中没有遇到问题，怎么执行？\n\n     会把try中所有的代码全部执行完毕,不会执行catch里面的代码\n\n  2. 如果 try 中遇到了问题，那么 try 下面的代码还会执行吗？\n\n     那么直接跳转到对应的catch语句中,try下面的代码就不会再执行了\n     当catch里面的语句全部执行完毕,表示整个体系全部执行完全,继续执行下面的代码\n\n  3. 如果出现的问题没有被捕获，那么程序如何运行？\n\n     那么try...catch就相当于没有写.那么也就是自己没有处理.\n     默认交给虚拟机处理.\n\n  4. 同时有可能出现多个异常怎么处理？\n\n     出现多个异常,那么就写多个catch就可以了.\n     注意点:如果多个异常之间存在子父类关系.那么父类一定要写在下面\n\n### 3.8 Throwable成员方法（应用）\n\n- 常用方法\n\n  | 方法名                           | 说明                     |\n  | ----------------------------- | ---------------------- |\n  | public String getMessage()    | 返回此 throwable 的详细消息字符串 |\n  | public String toString()      | 返回此可抛出的简短描述            |\n  | public void printStackTrace() | 把异常的错误信息输出在控制台         |\n\n- 示例代码\n\n  ```java\n  public class ExceptionDemo02 {\n      public static void main(String[] args) {\n          System.out.println("开始");\n          method();\n          System.out.println("结束");\n      }\n\n      public static void method() {\n          try {\n              int[] arr = {1, 2, 3};\n              System.out.println(arr[3]); //new ArrayIndexOutOfBoundsException();\n              System.out.println("这里能够访问到吗");\n          } catch (ArrayIndexOutOfBoundsException e) { //new ArrayIndexOutOfBoundsException();\n  //            e.printStackTrace();\n\n              //public String getMessage():返回此 throwable 的详细消息字符串\n  //            System.out.println(e.getMessage());\n              //Index 3 out of bounds for length 3\n\n              //public String toString():返回此可抛出的简短描述\n  //            System.out.println(e.toString());\n              //java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\n\n              //public void printStackTrace():把异常的错误信息输出在控制台\n              e.printStackTrace();\n  //            java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\n  //            at com.itheima_02.ExceptionDemo02.method(ExceptionDemo02.java:18)\n  //            at com.itheima_02.ExceptionDemo02.main(ExceptionDemo02.java:11)\n\n          }\n      }\n  }\n  ```\n\n### 3.9 异常的练习 (应用) \n\n+ 需求\n\n  键盘录入学生的姓名和年龄,其中年龄为18 - 25岁,超出这个范围是异常数据不能赋值.需要重新录入,一直录到正确为止\n\n+ 实现步骤\n\n  1. 创建学生对象\n  2. 键盘录入姓名和年龄，并赋值给学生对象\n  3. 如果是非法数据就再次录入\n\n+ 代码实现\n\n  学生类\n\n  ```java\n  public class Student {\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          if(age >= 18 && age <= 25){\n              this.age = age;\n          }else{\n              //当年龄不合法时,产生一个异常\n              throw new RuntimeException("年龄超出了范围");\n          }\n      }\n\n      @Override\n      public String toString() {\n          return "Student{" +\n                  "name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class ExceptionDemo12 {\n      public static void main(String[] args) {\n          // 键盘录入学生的姓名和年龄,其中年龄为 18 - 25岁,\n          // 超出这个范围是异常数据不能赋值.需要重新录入,一直录到正确为止。\n\n          Student s = new Student();\n\n          Scanner sc = new Scanner(System.in);\n          System.out.println("请输入姓名");\n          String name = sc.nextLine();\n          s.setName(name);\n         while(true){\n             System.out.println("请输入年龄");\n             String ageStr = sc.nextLine();\n             try {\n                 int age = Integer.parseInt(ageStr);\n                 s.setAge(age);\n                 break;\n             } catch (NumberFormatException e) {\n                 System.out.println("请输入一个整数");\n                 continue;\n             } catch (AgeOutOfBoundsException e) {\n                 System.out.println(e.toString());\n                 System.out.println("请输入一个符合范围的年龄");\n                 continue;\n             }\n             /*if(age >= 18 && age <=25){\n                 s.setAge(age);\n                 break;\n             }else{\n                 System.out.println("请输入符合要求的年龄");\n                 continue;\n             }*/\n         }\n          System.out.println(s);\n\n      }\n  }\n  ```\n\n### 3.10 自定义异常（应用）\n\n+ 自定义异常概述\n\n  当Java中提供的异常不能满足我们的需求时,我们可以自定义异常\n\n+ 实现步骤\n\n  1. 定义异常类\n  2. 写继承关系\n  3. 提供空参构造\n  4. 提供带参构造\n\n+ 代码实现\n\n  异常类\n\n  ```java\n  public class AgeOutOfBoundsException extends RuntimeException {\n      public AgeOutOfBoundsException() {\n      }\n\n      public AgeOutOfBoundsException(String message) {\n          super(message);\n      }\n  }\n  ```\n\n  学生类\n\n  ```java\n  public class Student {\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          if(age >= 18 && age <= 25){\n              this.age = age;\n          }else{\n              //如果Java中提供的异常不能满足我们的需求,我们可以使用自定义的异常\n              throw new AgeOutOfBoundsException("年龄超出了范围");\n          }\n      }\n\n      @Override\n      public String toString() {\n          return "Student{" +\n                  "name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class ExceptionDemo12 {\n      public static void main(String[] args) {\n          // 键盘录入学生的姓名和年龄,其中年龄为 18 - 25岁,\n          // 超出这个范围是异常数据不能赋值.需要重新录入,一直录到正确为止。\n\n          Student s = new Student();\n\n          Scanner sc = new Scanner(System.in);\n          System.out.println("请输入姓名");\n          String name = sc.nextLine();\n          s.setName(name);\n         while(true){\n             System.out.println("请输入年龄");\n             String ageStr = sc.nextLine();\n             try {\n                 int age = Integer.parseInt(ageStr);\n                 s.setAge(age);\n                 break;\n             } catch (NumberFormatException e) {\n                 System.out.println("请输入一个整数");\n                 continue;\n             } catch (AgeOutOfBoundsException e) {\n                 System.out.println(e.toString());\n                 System.out.println("请输入一个符合范围的年龄");\n                 continue;\n             }\n             /*if(age >= 18 && age <=25){\n                 s.setAge(age);\n                 break;\n             }else{\n                 System.out.println("请输入符合要求的年龄");\n                 continue;\n             }*/\n         }\n          System.out.println(s);\n\n      }\n  }\n  ```\n\n\n## 4.Optional\n\n### 4.1获取对象(应用)\n\n+ Optional概述\n\n  可能包含或不包含非null值的容器对象\n\n+ 方法介绍\n\n  | 方法名                                      | 说明                                       |\n  | ---------------------------------------- | ---------------------------------------- |\n  | static <T> Optional<T> of(T value)       | 获取一个Optional对象，封装的是非null值的对象             |\n  | static <T> Optional<T> ofNullable(T value) | 获取一个Optional对象，Optional封装的值对象可以是null也可以不是null |\n\n+ 示例代码\n\n  ```java\n  public class OptionalDemo1 {\n      public static void main(String[] args) {\n          //method1();\n\n          //public static <T> Optional<T> ofNullable(T value)\n          //获取一个Optional对象，Optional封装的值对象可以是null也可以不是null\n          //Student s = new Student("zhangsan",23);\n          Student s = null;\n          //ofNullable方法，封装的对象可以是null，也可以不是null。\n          Optional<Student> optional = Optional.ofNullable(s);\n\n          System.out.println(optional);\n      }\n\n      private static void method1() {\n          //static <T> Optional<T> of(T value)    获取一个Optional对象，封装的是非null值的对象\n\n          //Student s = new Student("zhangsan",23);\n          Student s = null;\n          //Optional可以看做是一个容器，里面装了一个引用数据类型的对象。\n          //返回值就是Optional的对象\n          //如果使用of方法，封装的对象如果为空，那么还是会抛出空指针异常\n          Optional<Student> optional1 = Optional.of(s);\n          System.out.println(optional1);\n      }\n  }\n  ```\n\n### 4.2常用方法(应用)\n\n+ 方法介绍\n\n  | 方法名                 | 说明                                   |\n  | ------------------- | ------------------------------------ |\n  | T get()             | 如果存在值,返回值,否则抛出NoSuchElementException |\n  | boolean isPresent() | 如果存在值,则返回true,否则为false               |\n\n+ 示例代码\n\n  ```java\n  public class OptionalDemo2 {\n      public static void main(String[] args) {\n          //get() 如果存在值，返回值，否则抛出NoSuchElementException\n          //public boolean isPresent()    判断Optional所封装的对象是否不为空，如果不为空返回true , 否则返回false\n\n          //Student s = new Student("zhangsan",23);\n          Student s = null;\n          Optional<Student> optional = Optional.ofNullable(s);\n          //如果封装的是一个null，那么通过get方法再次获取会抛出NoSuchElementException。\n          if(optional.isPresent()){\n              Student student = optional.get();\n              System.out.println(student);\n          }else{\n              System.out.println("Optional封装的对象为空");\n          }\n      }\n  }\n  ```\n\n### 4.3处理空指针的方法(应用)\n\n+ 方法介绍\n\n  | 方法名                                      | 说明                               |\n  | ---------------------------------------- | -------------------------------- |\n  | T orElse(T other)                        | 如果不为空,则返回具体的值,否则返回参数中的值          |\n  | T orElseGet(Supplier<? extends T> supplier) | 如果不为空,则返回具体的值,否则返回由括号中函数产生的结果    |\n  | void ifPresent (Consumer<? super T> action) | 如果不为空,则使用该值执行给定的操作,否则不执行任何操作     |\n  | void ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction) | 如果不为空,则使用该值执行给定的操作,否则执行给定的基于空的操作 |\n\n+ 示例代码\n\n  ```java\n  public class OptionalDemo3 {\n      public static void main(String[] args) {\n          //method1();\n\n          //method2();\n          //method3();\n          //method4();\n\n      }\n\n      private static void method4() {\n          //Student s = new Student("zhangsan",23);\n          Student s = null;\n          Optional<Student> optional = Optional.ofNullable(s);\n          //public void ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction)、\n          //如果不为空，则使用该值执行给定的操作，否则执行给定的基于空的操作。\n          optional.ifPresentOrElse(student -> System.out.println(student),\n                  ()->System.out.println("为空了"));\n      }\n\n      private static void method3() {\n          //Student s = new Student("zhangsan",23);\n          Student s = null;\n          Optional<Student> optional = Optional.ofNullable(s);\n          //ifPresent (Consumer<? super T> action)\n          //如果不为空，则使用该值执行给定的操作，否则不执行任何操作\n          optional.ifPresent(student -> System.out.println(student));\n      }\n\n      private static void method2() {\n          Student s = new Student("zhangsan",23);\n          //Student s = null;\n          Optional<Student> optional = Optional.ofNullable(s);\n          //orElseGet(Supplier<? extends T> supplier)\n          //如果不为空，则返回具体的值，否则返回由括号中函数产生的结果\n\n          Student student = optional.orElseGet(()-> new Student("lisi" , 24));\n          System.out.println(student);\n      }\n\n      private static void method1() {\n          //Student s = new Student("zhangsan",23);\n          Student s = null;\n          Optional<Student> optional = Optional.ofNullable(s);\n          //orElse(T other) 如果不为空，则返回具体的值，否则返回参数中的值\n          Student student = optional.orElse(new Student("lisi", 24));\n          System.out.println(student);\n      }\n  }\n  ```\n\n  ​',vn={data:function(){return{MainComponent1:gn,MainComponent2:Sn}}},bn=vn,hn=Object(d["a"])(bn,mn,dn,!1,null,"3a9ae85e",null),yn=hn.exports,fn=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent1}}),t("q-markdown",{attrs:{src:n.MainComponent2}}),t("q-markdown",{attrs:{src:n.MainComponent3}})],1)},xn=[],wn='\n\n## 1.Collection集合\n\n### 1.1数组和集合的区别【理解】\n\n+ 相同点\n\n  都是容器,可以存储多个数据\n\n+ 不同点\n\n  + 数组的长度是不可变的,集合的长度是可变的\n\n  + 数组可以存基本数据类型和引用数据类型\n\n    集合只能存引用数据类型,如果要存基本数据类型,需要存对应的包装类\n\n### 1.2集合类体系结构【理解】\n\n![01_集合类体系结构图](./img/java/basics/day16-集合01.img/01_集合类体系结构图.png)\n\n### 1.3Collection 集合概述和使用【应用】\n\n+ Collection集合概述\n\n  + 是单例集合的顶层接口,它表示一组对象,这些对象也称为Collection的元素\n  + JDK 不提供此接口的任何直接实现.它提供更具体的子接口(如Set和List)实现\n\n+ 创建Collection集合的对象\n\n  + 多态的方式\n  + 具体的实现类ArrayList\n\n+ Collection集合常用方法\n\n  | 方法名                        | 说明                |\n  | :------------------------- | :---------------- |\n  | boolean add(E e)           | 添加元素              |\n  | boolean remove(Object o)   | 从集合中移除指定的元素       |\n  | boolean removeIf(Object o) | 根据条件进行移除          |\n  | void   clear()             | 清空集合中的元素          |\n  | boolean contains(Object o) | 判断集合中是否存在指定的元素    |\n  | boolean isEmpty()          | 判断集合是否为空          |\n  | int   size()               | 集合的长度，也就是集合中元素的个数 |\n\n### 1.4Collection集合的遍历【应用】\n\n+ 迭代器介绍\n\n  + 迭代器,集合的专用遍历方式\n  + Iterator<E> iterator(): 返回此集合中元素的迭代器,通过集合对象的iterator()方法得到\n\n+ Iterator中的常用方法\n\n  ​\tboolean hasNext(): 判断当前位置是否有元素可以被取出\n  ​\tE next(): 获取当前位置的元素,将迭代器对象移向下一个索引位置\n\n+ Collection集合的遍历\n\n  ```java\n  public class IteratorDemo1 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Collection<String> c = new ArrayList<>();\n\n          //添加元素\n          c.add("hello");\n          c.add("world");\n          c.add("java");\n          c.add("javaee");\n\n          //Iterator<E> iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到\n          Iterator<String> it = c.iterator();\n\n          //用while循环改进元素的判断和获取\n          while (it.hasNext()) {\n              String s = it.next();\n              System.out.println(s);\n          }\n      }\n  }\n  ```\n\n+ 迭代器中删除的方法\n\n  ​\tvoid remove(): 删除迭代器对象当前指向的元素\n\n  ```java\n  public class IteratorDemo2 {\n      public static void main(String[] args) {\n          ArrayList<String> list = new ArrayList<>();\n          list.add("a");\n          list.add("b");\n          list.add("b");\n          list.add("c");\n          list.add("d");\n\n          Iterator<String> it = list.iterator();\n          while(it.hasNext()){\n              String s = it.next();\n              if("b".equals(s)){\n                  //指向谁,那么此时就删除谁.\n                  it.remove();\n              }\n          }\n          System.out.println(list);\n      }\n  }\n  ```\n\n### 1.5增强for循环【应用】\n\n+ 介绍\n\n  + 它是JDK5之后出现的,其内部原理是一个Iterator迭代器\n  + 实现Iterable接口的类才可以使用迭代器和增强for\n  + 简化数组和Collection集合的遍历\n\n+ 格式\n\n  ​\tfor(集合/数组中元素的数据类型 变量名 :  集合/数组名) {\n\n  ​\t\t// 已经将当前遍历到的元素封装到变量中了,直接使用变量即可\n\n  ​\t}\n\n+ 代码\n\n  ```java\n  public class MyCollectonDemo1 {\n      public static void main(String[] args) {\n          ArrayList<String> list =  new ArrayList<>();\n          list.add("a");\n          list.add("b");\n          list.add("c");\n          list.add("d");\n          list.add("e");\n          list.add("f");\n\n          //1,数据类型一定是集合或者数组中元素的类型\n          //2,str仅仅是一个变量名而已,在循环的过程中,依次表示集合或者数组中的每一个元素\n          //3,list就是要遍历的集合或者数组\n          for(String str : list){\n              System.out.println(str);\n          }\n      }\n  }\n  ```\n\n## 2.List集合\n\n### 2.1List集合的概述和特点【记忆】\n\n+ List集合的概述\n  + 有序集合,这里的有序指的是存取顺序\n  + 用户可以精确控制列表中每个元素的插入位置,用户可以通过整数索引访问元素,并搜索列表中的元素\n  + 与Set集合不同,列表通常允许重复的元素\n+ List集合的特点\n  + 存取有序\n  + 可以重复\n  + 有索引\n\n### 2.2List集合的特有方法【应用】\n\n| 方法名                             | 描述                  |\n| ------------------------------- | ------------------- |\n| void add(int index,E   element) | 在此集合中的指定位置插入指定的元素   |\n| E remove(int   index)           | 删除指定索引处的元素，返回被删除的元素 |\n| E set(int index,E   element)    | 修改指定索引处的元素，返回被修改的元素 |\n| E get(int   index)              | 返回指定索引处的元素          |\n\n## 3.数据结构\n\n### 3.1数据结构之栈和队列【记忆】\n\n- 栈结构\n\n  ​\t先进后出\n\n- 队列结构\n\n  ​\t先进先出\n\n### 3.2数据结构之数组和链表【记忆】\n\n- 数组结构\n\n  ​\t查询快、增删慢\n\n- 队列结构\n\n  ​\t查询慢、增删快\n\n## 4.List集合的实现类\n\n### 4.1List集合子类的特点【记忆】\n\n- ArrayList集合\n\n  ​\t底层是数组结构实现，查询快、增删慢\n\n- LinkedList集合\n\n  ​\t底层是链表结构实现，查询慢、增删快\n\n### 4.2LinkedList集合的特有功能【应用】\n\n- 特有方法\n\n  | 方法名                       | 说明               |\n  | ------------------------- | ---------------- |\n  | public void addFirst(E e) | 在该列表开头插入指定的元素    |\n  | public void addLast(E e)  | 将指定的元素追加到此列表的末尾  |\n  | public E getFirst()       | 返回此列表中的第一个元素     |\n  | public   E getLast()      | 返回此列表中的最后一个元素    |\n  | public E removeFirst()    | 从此列表中删除并返回第一个元素  |\n  | public   E removeLast()   | 从此列表中删除并返回最后一个元素 |\n\n## 5.泛型\n\n### 5.1泛型概述【理解】\n\n+ 泛型的介绍\n\n  ​\t泛型是JDK5中引入的特性，它提供了编译时类型安全检测机制\n\n+ 泛型的好处\n\n  1. 把运行时期的问题提前到了编译期间\n  2. 避免了强制类型转换\n\n+ 泛型的定义格式\n\n  + <类型>: 指定一种类型的格式.尖括号里面可以任意书写,一般只写一个字母.例如: <E> <T>\n  + <类型1,类型2…>: 指定多种类型的格式,多种类型之间用逗号隔开.例如: <E,T> <K,V>\n\n### 5.2泛型类【应用】\n\n- 定义格式\n\n  ```java\n  修饰符 class 类名<类型> {  }\n  ```\n\n- 示例代码\n\n  - 泛型类\n\n    ```java\n    public class Generic<T> {\n        private T t;\n\n        public T getT() {\n            return t;\n        }\n\n        public void setT(T t) {\n            this.t = t;\n        }\n    }\n    ```\n\n  - 测试类\n\n    ```java\n    public class GenericDemo1 {\n        public static void main(String[] args) {\n            Generic<String> g1 = new Generic<String>();\n            g1.setT("杨幂");\n            System.out.println(g1.getT());\n\n            Generic<Integer> g2 = new Generic<Integer>();\n            g2.setT(30);\n            System.out.println(g2.getT());\n\n            Generic<Boolean> g3 = new Generic<Boolean>();\n            g3.setT(true);\n            System.out.println(g3.getT());\n        }\n    }\n    ```\n\n### 5.3泛型方法【应用】\n\n- 定义格式\n\n  ```java\n  修饰符 <类型> 返回值类型 方法名(类型 变量名) {  }\n  ```\n\n- 示例代码\n\n  - 带有泛型方法的类\n\n    ```java\n    public class Generic {\n        public <T> void show(T t) {\n            System.out.println(t);\n        }\n    }\n    ```\n\n  - 测试类\n\n    ```java\n    public class GenericDemo2 {\n        public static void main(String[] args) {\n    \t    Generic g = new Generic();\n            g.show("柳岩");\n            g.show(30);\n            g.show(true);\n            g.show(12.34);\n        }\n    }\n    ```\n\n### 5.4泛型接口【应用】\n\n- 定义格式\n\n  ```java\n  修饰符 interface 接口名<类型> {  }\n  ```\n\n- 示例代码\n\n  - 泛型接口\n\n    ```java\n    public interface Generic<T> {\n        void show(T t);\n    }\n    ```\n\n  - 泛型接口实现类1\n\n    ​\t定义实现类时,定义和接口相同泛型,创建实现类对象时明确泛型的具体类型\n\n    ```java\n    public class GenericImpl1<T> implements Generic<T> {\n        @Override\n        public void show(T t) {\n            System.out.println(t);\n        }\n    }\n    ```\n\n  - 泛型接口实现类2\n\n    ​\t定义实现类时,直接明确泛型的具体类型\n\n    ```java\n    public class GenericImpl2 implements Generic<Integer>{\n         @Override\n         public void show(Integer t) {\n              System.out.println(t);\n         }\n    }\n    ```\n\n  - 测试类\n\n    ```java\n    public class GenericDemo3 {\n        public static void main(String[] args) {\n            GenericImpl1<String> g1 = new GenericImpl<String>();\n            g1.show("林青霞");\n            GenericImpl1<Integer> g2 = new GenericImpl<Integer>();\n            g2.show(30);\n          \n            GenericImpl2 g3 = new GenericImpl2();\n          \tg3.show(10);\n        }\n    }\n\n    ```\n\n### 5.5类型通配符\n\n- 类型通配符: <?>\n\n  - ArrayList<?>: 表示元素类型未知的ArrayList,它的元素可以匹配任何的类型\n  - 但是并不能把元素添加到ArrayList中了,获取出来的也是父类类型\n\n- 类型通配符上限: <? extends 类型>\n\n  - ArrayListList <? extends Number>: 它表示的类型是Number或者其子类型\n\n- 类型通配符下限: <? super 类型>\n\n  - ArrayListList <? super Number>: 它表示的类型是Number或者其父类型\n\n- 泛型通配符的使用\n\n  ```java\n  public class GenericDemo4 {\n      public static void main(String[] args) {\n          ArrayList<Integer> list1 = new ArrayList<>();\n          ArrayList<String> list2 = new ArrayList<>();\n          ArrayList<Number> list3 = new ArrayList<>();\n          ArrayList<Object> list4 = new ArrayList<>();\n\n          method(list1);\n          method(list2);\n          method(list3);\n          method(list4);\n\n          getElement1(list1);\n          getElement1(list2);//报错\n          getElement1(list3);\n          getElement1(list4);//报错\n\n          getElement2(list1);//报错\n          getElement2(list2);//报错\n          getElement2(list3);\n          getElement2(list4);\n      }\n    \n      // 泛型通配符: 此时的泛型?,可以是任意类型\n      public static void method(ArrayList<?> list){}\n      // 泛型的上限: 此时的泛型?,必须是Number类型或者Number类型的子类\n      public static void getElement1(ArrayList<? extends Number> list){}\n      // 泛型的下限: 此时的泛型?,必须是Number类型或者Number类型的父类\n      public static void getElement2(ArrayList<? super Number> list){}\n\n  }\n  ```\n\n\n\n',jn='## 1.Set集合\n\n### 1.1Set集合概述和特点【应用】\n\n+ 不可以存储重复元素\n+ 没有索引,不能使用普通for循环遍历\n\n### 1.2Set集合的使用【应用】\n\n存储字符串并遍历\n\n```java\npublic class MySet1 {\n    public static void main(String[] args) {\n      \t//创建集合对象\n        Set<String> set = new TreeSet<>();\n      \t//添加元素\n        set.add("ccc");\n        set.add("aaa");\n        set.add("aaa");\n        set.add("bbb");\n\n//        for (int i = 0; i < set.size(); i++) {\n//            //Set集合是没有索引的，所以不能使用通过索引获取元素的方法\n//        }\n      \n      \t//遍历集合\n        Iterator<String> it = set.iterator();\n        while (it.hasNext()){\n            String s = it.next();\n            System.out.println(s);\n        }\n        System.out.println("-----------------------------------");\n        for (String s : set) {\n            System.out.println(s);\n        }\n    }\n}\n```\n\n## 2.TreeSet集合\n\n### 2.1TreeSet集合概述和特点【应用】\n\n+ 不可以存储重复元素\n+ 没有索引\n+ 可以将元素按照规则进行排序\n  + TreeSet()：根据其元素的自然排序进行排序\n  + TreeSet(Comparator comparator) ：根据指定的比较器进行排序\n\n### 2.2TreeSet集合基本使用【应用】\n\n存储Integer类型的整数并遍历\n\n```java\npublic class TreeSetDemo01 {\n    public static void main(String[] args) {\n        //创建集合对象\n        TreeSet<Integer> ts = new TreeSet<Integer>();\n\n        //添加元素\n        ts.add(10);\n        ts.add(40);\n        ts.add(30);\n        ts.add(50);\n        ts.add(20);\n\n        ts.add(30);\n\n        //遍历集合\n        for(Integer i : ts) {\n            System.out.println(i);\n        }\n    }\n}\n```\n\n### 2.3自然排序Comparable的使用【应用】\n\n- 案例需求\n\n  - 存储学生对象并遍历，创建TreeSet集合使用无参构造方法\n  - 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序\n\n- 实现步骤\n\n  1. 使用空参构造创建TreeSet集合\n     + 用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的\n  2. 自定义的Student类实现Comparable接口\n     + 自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(T o)方法\n  3. 重写接口中的compareTo方法\n     + 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写\n\n- 代码实现\n\n  学生类\n\n  ```java\n  public class Student implements Comparable<Student>{\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public String toString() {\n          return "Student{" +\n                  "name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n\n      @Override\n      public int compareTo(Student o) {\n          //按照对象的年龄进行排序\n          //主要判断条件: 按照年龄从小到大排序\n          int result = this.age - o.age;\n          //次要判断条件: 年龄相同时，按照姓名的字母顺序排序\n          result = result == 0 ? this.name.compareTo(o.getName()) : result;\n          return result;\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class MyTreeSet2 {\n      public static void main(String[] args) {\n          //创建集合对象\n          TreeSet<Student> ts = new TreeSet<>();\n  \t    //创建学生对象\n          Student s1 = new Student("zhangsan",28);\n          Student s2 = new Student("lisi",27);\n          Student s3 = new Student("wangwu",29);\n          Student s4 = new Student("zhaoliu",28);\n          Student s5 = new Student("qianqi",30);\n  \t\t//把学生添加到集合\n          ts.add(s1);\n          ts.add(s2);\n          ts.add(s3);\n          ts.add(s4);\n          ts.add(s5);\n  \t\t//遍历集合\n          for (Student student : ts) {\n              System.out.println(student);\n          }\n      }\n  }\n  ```\n\n### 2.4比较器排序Comparator的使用【应用】\n\n- 案例需求\n\n  - 存储老师对象并遍历，创建TreeSet集合使用带参构造方法\n  - 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序\n\n- 实现步骤\n\n  - 用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的\n  - 比较器排序，就是让集合构造方法接收Comparator的实现类对象，重写compare(T o1,T o2)方法\n  - 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写\n\n- 代码实现\n\n  老师类\n\n  ```java\n  public class Teacher {\n      private String name;\n      private int age;\n\n      public Teacher() {\n      }\n\n      public Teacher(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public String toString() {\n          return "Teacher{" +\n                  "name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class MyTreeSet4 {\n      public static void main(String[] args) {\n        \t//创建集合对象\n          TreeSet<Teacher> ts = new TreeSet<>(new Comparator<Teacher>() {\n              @Override\n              public int compare(Teacher o1, Teacher o2) {\n                  //o1表示现在要存入的那个元素\n                  //o2表示已经存入到集合中的元素\n                \n                  //主要条件\n                  int result = o1.getAge() - o2.getAge();\n                  //次要条件\n                  result = result == 0 ? o1.getName().compareTo(o2.getName()) : result;\n                  return result;\n              }\n          });\n  \t\t//创建老师对象\n          Teacher t1 = new Teacher("zhangsan",23);\n          Teacher t2 = new Teacher("lisi",22);\n          Teacher t3 = new Teacher("wangwu",24);\n          Teacher t4 = new Teacher("zhaoliu",24);\n  \t\t//把老师添加到集合\n          ts.add(t1);\n          ts.add(t2);\n          ts.add(t3);\n          ts.add(t4);\n  \t\t//遍历集合\n          for (Teacher teacher : ts) {\n              System.out.println(teacher);\n          }\n      }\n  }\n  ```\n\n### 2.4两种比较方式总结【理解】\n\n+ 两种比较方式小结\n  + 自然排序: 自定义类实现Comparable接口,重写compareTo方法,根据返回值进行排序\n  + 比较器排序: 创建TreeSet对象的时候传递Comparator的实现类对象,重写compare方法,根据返回值进行排序\n  + 在使用的时候,默认使用自然排序,当自然排序不满足现在的需求时,必须使用比较器排序\n+ 两种方式中关于返回值的规则\n  + 如果返回值为负数，表示当前存入的元素是较小值，存左边\n  + 如果返回值为0，表示当前存入的元素跟集合中元素重复了，不存\n  + 如果返回值为正数，表示当前存入的元素是较大值，存右边\n\n## 3.数据结构\n\n### 3.1二叉树【理解】\n\n+ 二叉树的特点\n\n  + 二叉树中,任意一个节点的度要小于等于2\n    + 节点: 在树结构中,每一个元素称之为节点\n    + 度: 每一个节点的子节点数量称之为度\n\n+ 二叉树结构图\n\n  ![01_二叉树结构图](./img/java/basics/day17-集合02.img/01_二叉树结构图.png)\n\n### 3.2二叉查找树【理解】\n\n+ 二叉查找树的特点\n\n  + 二叉查找树,又称二叉排序树或者二叉搜索树\n  + 每一个节点上最多有两个子节点\n  + 左子树上所有节点的值都小于根节点的值\n  + 右子树上所有节点的值都大于根节点的值\n\n+ 二叉查找树结构图\n\n  ![02_二叉查找树结构图](./img/java/basics/day17-集合02.img/02_二叉查找树结构图.png)\n\n+ 二叉查找树和二叉树对比结构图\n\n  ![03_二叉查找树和二叉树对比结构图](./img/java/basics/day17-集合02.img/03_二叉查找树和二叉树对比结构图.png)\n\n+ 二叉查找树添加节点规则\n\n  + 小的存左边\n  + 大的存右边\n  + 一样的不存\n\n  ![04_二叉查找树添加节点规则](./img/java/basics/day17-集合02.img/04_二叉查找树添加节点规则.png)\n\n### 3.3平衡二叉树【理解】\n\n+ 平衡二叉树的特点\n\n  + 二叉树左右两个子树的高度差不超过1\n  + 任意节点的左右两个子树都是一颗平衡二叉树\n\n+ 平衡二叉树旋转\n\n  + 旋转触发时机\n\n    + 当添加一个节点之后,该树不再是一颗平衡二叉树\n\n  + 左旋\n\n    + 就是将根节点的右侧往左拉,原先的右子节点变成新的父节点,并把多余的左子节点出让,给已经降级的根节点当右子节点\n\n    ![05_平衡二叉树左旋01](./img/java/basics/day17-集合02.img/05_平衡二叉树左旋01.png)\n\n    ![05_平衡二叉树左旋02](./img/java/basics/day17-集合02.img/05_平衡二叉树左旋02.png)\n\n  + 右旋\n\n    + 就是将根节点的左侧往右拉,左子节点变成了新的父节点,并把多余的右子节点出让,给已经降级根节点当左子节点\n\n      ![06_平衡二叉树右旋01](./img/java/basics/day17-集合02.img/06_平衡二叉树右旋01.png)\n\n      ![06_平衡二叉树右旋02](./img/java/basics/day17-集合02.img/06_平衡二叉树右旋02.png)\n\n+ 平衡二叉树和二叉查找树对比结构图\n\n  ![07_平衡二叉树和二叉查找树对比结构图](./img/java/basics/day17-集合02.img/07_平衡二叉树和二叉查找树对比结构图.png)\n\n+ 平衡二叉树旋转的四种情况\n\n  + 左左\n\n    + 左左: 当根节点左子树的左子树有节点插入,导致二叉树不平衡\n\n    + 如何旋转: 直接对整体进行右旋即可\n\n      ![08_平衡二叉树左左](./img/java/basics/day17-集合02.img/08_平衡二叉树左左.png)\n\n  + 左右\n\n    + 左右: 当根节点左子树的右子树有节点插入,导致二叉树不平衡\n\n    + 如何旋转: 先在左子树对应的节点位置进行左旋,在对整体进行右旋\n\n      ![09_平衡二叉树左右](./img/java/basics/day17-集合02.img/09_平衡二叉树左右.png)\n\n  + 右右\n\n    + 右右: 当根节点右子树的右子树有节点插入,导致二叉树不平衡\n\n    + 如何旋转: 直接对整体进行左旋即可\n\n      ![10_平衡二叉树右右](./img/java/basics/day17-集合02.img/10_平衡二叉树右右.png)\n\n  + 右左\n\n    + 右左:当根节点右子树的左子树有节点插入,导致二叉树不平衡\n\n    + 如何旋转: 先在右子树对应的节点位置进行右旋,在对整体进行左旋\n\n      ![11_平衡二叉树右左](./img/java/basics/day17-集合02.img/11_平衡二叉树右左.png)\n\n### 3.4红黑树【理解】\n\n+ 红黑树的特点\n\n  + 平衡二叉B树\n  + 每一个节点可以是红或者黑\n  + 红黑树不是高度平衡的,它的平衡是通过"自己的红黑规则"进行实现的\n\n+ 红黑树的红黑规则有哪些\n\n  1. 每一个节点或是红色的,或者是黑色的\n\n  2. 根节点必须是黑色\n\n  3. 如果一个节点没有子节点或者父节点,则该节点相应的指针属性值为Nil,这些Nil视为叶节点,每个叶节点(Nil)是黑色的\n\n  4. 如果某一个节点是红色,那么它的子节点必须是黑色(不能出现两个红色节点相连 的情况)\n\n  5. 对每一个节点,从该节点到其所有后代叶节点的简单路径上,均包含相同数目的黑色节点\n\n     ![12_红黑树结构图](./img/java/basics/day17-集合02.img/12_红黑树结构图.png)\n\n+ 红黑树添加节点的默认颜色\n\n  + 添加节点时,默认为红色,效率高\n\n    ![13_红黑树添加节点颜色](./img/java/basics/day17-集合02.img/13_红黑树添加节点颜色.png)\n\n+ 红黑树添加节点后如何保持红黑规则\n\n  + 根节点位置\n    + 直接变为黑色\n  + 非根节点位置\n    + 父节点为黑色\n      + 不需要任何操作,默认红色即可\n    + 父节点为红色\n      + 叔叔节点为红色\n        1. 将"父节点"设为黑色,将"叔叔节点"设为黑色\n        2. 将"祖父节点"设为红色\n        3. 如果"祖父节点"为根节点,则将根节点再次变成黑色\n      + 叔叔节点为黑色\n        1. 将"父节点"设为黑色\n        2. 将"祖父节点"设为红色\n        3. 以"祖父节点"为支点进行旋转\n\n### 3.5成绩排序案例【应用】\n\n- 案例需求\n\n  - 用TreeSet集合存储多个学生信息(姓名,语文成绩,数学成绩,英语成绩),并遍历该集合\n  - 要求: 按照总分从高到低出现\n\n- 代码实现\n\n  学生类\n\n  ```java\n  public class Student implements Comparable<Student> {\n      private String name;\n      private int chinese;\n      private int math;\n      private int english;\n\n      public Student() {\n      }\n\n      public Student(String name, int chinese, int math, int english) {\n          this.name = name;\n          this.chinese = chinese;\n          this.math = math;\n          this.english = english;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getChinese() {\n          return chinese;\n      }\n\n      public void setChinese(int chinese) {\n          this.chinese = chinese;\n      }\n\n      public int getMath() {\n          return math;\n      }\n\n      public void setMath(int math) {\n          this.math = math;\n      }\n\n      public int getEnglish() {\n          return english;\n      }\n\n      public void setEnglish(int english) {\n          this.english = english;\n      }\n\n      public int getSum() {\n          return this.chinese + this.math + this.english;\n      }\n\n      @Override\n      public int compareTo(Student o) {\n          // 主要条件: 按照总分进行排序\n          int result = o.getSum() - this.getSum();\n          // 次要条件: 如果总分一样,就按照语文成绩排序\n          result = result == 0 ? o.getChinese() - this.getChinese() : result;\n          // 如果语文成绩也一样,就按照数学成绩排序\n          result = result == 0 ? o.getMath() - this.getMath() : result;\n          // 如果总分一样,各科成绩也都一样,就按照姓名排序\n          result = result == 0 ? o.getName().compareTo(this.getName()) : result;\n          return result;\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class TreeSetDemo {\n      public static void main(String[] args) {\n          //创建TreeSet集合对象，通过比较器排序进行排序\n          TreeSet<Student> ts = new TreeSet<Student>();\n          //创建学生对象\n          Student s1 = new Student("jack", 98, 100, 95);\n          Student s2 = new Student("rose", 95, 95, 95);\n          Student s3 = new Student("sam", 100, 93, 98);\n          //把学生对象添加到集合\n          ts.add(s1);\n          ts.add(s2);\n          ts.add(s3);\n\n          //遍历集合\n          for (Student s : ts) {\n              System.out.println(s.getName() + "," + s.getChinese() + "," + s.getMath() + "," + s.getEnglish() + "," + s.getSum());\n          }\n      }\n  }\n  ```\n\n## 4.HashSet集合\n\n### 4.1HashSet集合概述和特点【应用】\n\n+ 底层数据结构是哈希表\n+ 存取无序\n+ 不可以存储重复元素\n+ 没有索引,不能使用普通for循环遍历\n\n### 4.2HashSet集合的基本应用【应用】\n\n存储字符串并遍历\n\n```java\npublic class HashSetDemo {\n    public static void main(String[] args) {\n        //创建集合对象\n        HashSet<String> set = new HashSet<String>();\n\n        //添加元素\n        set.add("hello");\n        set.add("world");\n        set.add("java");\n        //不包含重复元素的集合\n        set.add("world");\n\n        //遍历\n        for(String s : set) {\n            System.out.println(s);\n        }\n    }\n}\n```\n\n### 4.3哈希值【理解】\n\n- 哈希值简介\n\n  ​\t是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值\n\n- 如何获取哈希值\n\n  ​\tObject类中的public int hashCode()：返回对象的哈希码值\n\n- 哈希值的特点\n\n  - 同一个对象多次调用hashCode()方法返回的哈希值是相同的\n  - 默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同\n\n### 4.4哈希表结构【理解】\n\n+ JDK1.8以前\n\n  ​\t数组 + 链表\n\n  ![14_JKD8以前哈希表](./img/java/basics/day17-集合02.img/14_JKD8以前哈希表.png)\n\n+ JDK1.8以后\n\n  + 节点个数少于等于8个\n\n    ​\t数组 + 链表\n\n  + 节点个数多于8个\n\n    ​\t数组 + 红黑树\n\n  ![15_JKD8以后哈希表](./img/java/basics/day17-集合02.img/15_JKD8以后哈希表.png)\n\n### 4.5HashSet集合存储学生对象并遍历【应用】\n\n- 案例需求\n\n  - 创建一个存储学生对象的集合，存储多个学生对象，使用程序实现在控制台遍历该集合\n  - 要求：学生对象的成员变量值相同，我们就认为是同一个对象\n\n- 代码实现\n\n  学生类\n\n  ```java\n  public class Student {\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public boolean equals(Object o) {\n          if (this == o) return true;\n          if (o == null || getClass() != o.getClass()) return false;\n\n          Student student = (Student) o;\n\n          if (age != student.age) return false;\n          return name != null ? name.equals(student.name) : student.name == null;\n      }\n\n      @Override\n      public int hashCode() {\n          int result = name != null ? name.hashCode() : 0;\n          result = 31 * result + age;\n          return result;\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class HashSetDemo02 {\n      public static void main(String[] args) {\n          //创建HashSet集合对象\n          HashSet<Student> hs = new HashSet<Student>();\n\n          //创建学生对象\n          Student s1 = new Student("林青霞", 30);\n          Student s2 = new Student("张曼玉", 35);\n          Student s3 = new Student("王祖贤", 33);\n\n          Student s4 = new Student("王祖贤", 33);\n\n          //把学生添加到集合\n          hs.add(s1);\n          hs.add(s2);\n          hs.add(s3);\n          hs.add(s4);\n\n          //遍历集合(增强for)\n          for (Student s : hs) {\n              System.out.println(s.getName() + "," + s.getAge());\n          }\n      }\n  }\n  ```\n\n- 总结\n\n  ​\tHashSet集合存储自定义类型元素,要想实现元素的唯一,要求必须重写hashCode方法和equals方法',Cn='## 1.Map集合\n\n### 1.1Map集合概述和特点【理解】\n\n- Map集合概述\n\n  ```java\n  interface Map<K,V>  K：键的类型；V：值的类型\n  ```\n\n- Map集合的特点\n\n  - 双列集合,一个键对应一个值\n  - 键不可以重复,值可以重复\n\n- Map集合的基本使用\n\n  ```java\n  public class MapDemo01 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String,String> map = new HashMap<String,String>();\n\n          //V put(K key, V value) 将指定的值与该映射中的指定键相关联\n          map.put("itheima001","林青霞");\n          map.put("itheima002","张曼玉");\n          map.put("itheima003","王祖贤");\n          map.put("itheima003","柳岩");\n\n          //输出集合对象\n          System.out.println(map);\n      }\n  }\n  ```\n\n### 1.2Map集合的基本功能【应用】\n\n- 方法介绍\n\n  | 方法名                                 | 说明                 |\n  | ----------------------------------- | ------------------ |\n  | V   put(K key,V   value)            | 添加元素               |\n  | V   remove(Object key)              | 根据键删除键值对元素         |\n  | void   clear()                      | 移除所有的键值对元素         |\n  | boolean containsKey(Object key)     | 判断集合是否包含指定的键       |\n  | boolean containsValue(Object value) | 判断集合是否包含指定的值       |\n  | boolean isEmpty()                   | 判断集合是否为空           |\n  | int size()                          | 集合的长度，也就是集合中键值对的个数 |\n\n- 示例代码\n\n  ```java\n  public class MapDemo02 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String,String> map = new HashMap<String,String>();\n\n          //V put(K key,V value)：添加元素\n          map.put("张无忌","赵敏");\n          map.put("郭靖","黄蓉");\n          map.put("杨过","小龙女");\n\n          //V remove(Object key)：根据键删除键值对元素\n  //        System.out.println(map.remove("郭靖"));\n  //        System.out.println(map.remove("郭襄"));\n\n          //void clear()：移除所有的键值对元素\n  //        map.clear();\n\n          //boolean containsKey(Object key)：判断集合是否包含指定的键\n  //        System.out.println(map.containsKey("郭靖"));\n  //        System.out.println(map.containsKey("郭襄"));\n\n          //boolean isEmpty()：判断集合是否为空\n  //        System.out.println(map.isEmpty());\n\n          //int size()：集合的长度，也就是集合中键值对的个数\n          System.out.println(map.size());\n\n          //输出集合对象\n          System.out.println(map);\n      }\n  }\n  ```\n\n### 1.3Map集合的获取功能【应用】\n\n- 方法介绍\n\n  | 方法名                              | 说明           |\n  | -------------------------------- | ------------ |\n  | V   get(Object key)              | 根据键获取值       |\n  | Set<K>   keySet()                | 获取所有键的集合     |\n  | Collection<V>   values()         | 获取所有值的集合     |\n  | Set<Map.Entry<K,V>>   entrySet() | 获取所有键值对对象的集合 |\n\n- 示例代码\n\n  ```java\n  public class MapDemo03 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String, String> map = new HashMap<String, String>();\n\n          //添加元素\n          map.put("张无忌", "赵敏");\n          map.put("郭靖", "黄蓉");\n          map.put("杨过", "小龙女");\n\n          //V get(Object key):根据键获取值\n  //        System.out.println(map.get("张无忌"));\n  //        System.out.println(map.get("张三丰"));\n\n          //Set<K> keySet():获取所有键的集合\n  //        Set<String> keySet = map.keySet();\n  //        for(String key : keySet) {\n  //            System.out.println(key);\n  //        }\n\n          //Collection<V> values():获取所有值的集合\n          Collection<String> values = map.values();\n          for(String value : values) {\n              System.out.println(value);\n          }\n      }\n  }\n  ```\n\n### 1.4Map集合的遍历(方式1)【应用】\n\n- 遍历思路\n\n  - 我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合\n    - 把所有的丈夫给集中起来\n    - 遍历丈夫的集合，获取到每一个丈夫\n    - 根据丈夫去找对应的妻子\n\n- 步骤分析\n\n  - 获取所有键的集合。用keySet()方法实现\n  - 遍历键的集合，获取到每一个键。用增强for实现  \n  - 根据键去找值。用get(Object key)方法实现\n\n- 代码实现\n\n  ```java\n  public class MapDemo01 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String, String> map = new HashMap<String, String>();\n\n          //添加元素\n          map.put("张无忌", "赵敏");\n          map.put("郭靖", "黄蓉");\n          map.put("杨过", "小龙女");\n\n          //获取所有键的集合。用keySet()方法实现\n          Set<String> keySet = map.keySet();\n          //遍历键的集合，获取到每一个键。用增强for实现\n          for (String key : keySet) {\n              //根据键去找值。用get(Object key)方法实现\n              String value = map.get(key);\n              System.out.println(key + "," + value);\n          }\n      }\n  }\n  ```\n\n### 1.5Map集合的遍历(方式2)【应用】\n\n- 遍历思路\n\n  - 我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合\n    - 获取所有结婚证的集合\n    - 遍历结婚证的集合，得到每一个结婚证\n    - 根据结婚证获取丈夫和妻子\n\n- 步骤分析\n\n  - 获取所有键值对对象的集合\n    - Set<Map.Entry<K,V>> entrySet()：获取所有键值对对象的集合\n  - 遍历键值对对象的集合，得到每一个键值对对象\n    - 用增强for实现，得到每一个Map.Entry\n  - 根据键值对对象获取键和值\n    - 用getKey()得到键\n    - 用getValue()得到值\n\n- 代码实现\n\n  ```java\n  public class MapDemo02 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String, String> map = new HashMap<String, String>();\n\n          //添加元素\n          map.put("张无忌", "赵敏");\n          map.put("郭靖", "黄蓉");\n          map.put("杨过", "小龙女");\n\n          //获取所有键值对对象的集合\n          Set<Map.Entry<String, String>> entrySet = map.entrySet();\n          //遍历键值对对象的集合，得到每一个键值对对象\n          for (Map.Entry<String, String> me : entrySet) {\n              //根据键值对对象获取键和值\n              String key = me.getKey();\n              String value = me.getValue();\n              System.out.println(key + "," + value);\n          }\n      }\n  }\n  ```\n\n## 2.HashMap集合\n\n### 2.1HashMap集合概述和特点【理解】\n\n+ HashMap底层是哈希表结构的\n+ 依赖hashCode方法和equals方法保证键的唯一\n+ 如果键要存储的是自定义对象，需要重写hashCode和equals方法\n\n### 2.2HashMap集合应用案例【应用】\n\n- 案例需求\n\n  - 创建一个HashMap集合，键是学生对象(Student)，值是居住地 (String)。存储多个元素，并遍历。\n  - 要求保证键的唯一性：如果学生对象的成员变量值相同，我们就认为是同一个对象\n\n- 代码实现\n\n  学生类\n\n  ```java\n  public class Student {\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public boolean equals(Object o) {\n          if (this == o) return true;\n          if (o == null || getClass() != o.getClass()) return false;\n\n          Student student = (Student) o;\n\n          if (age != student.age) return false;\n          return name != null ? name.equals(student.name) : student.name == null;\n      }\n\n      @Override\n      public int hashCode() {\n          int result = name != null ? name.hashCode() : 0;\n          result = 31 * result + age;\n          return result;\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class HashMapDemo {\n      public static void main(String[] args) {\n          //创建HashMap集合对象\n          HashMap<Student, String> hm = new HashMap<Student, String>();\n\n          //创建学生对象\n          Student s1 = new Student("林青霞", 30);\n          Student s2 = new Student("张曼玉", 35);\n          Student s3 = new Student("王祖贤", 33);\n          Student s4 = new Student("王祖贤", 33);\n\n          //把学生添加到集合\n          hm.put(s1, "西安");\n          hm.put(s2, "武汉");\n          hm.put(s3, "郑州");\n          hm.put(s4, "北京");\n\n          //遍历集合\n          Set<Student> keySet = hm.keySet();\n          for (Student key : keySet) {\n              String value = hm.get(key);\n              System.out.println(key.getName() + "," + key.getAge() + "," + value);\n          }\n      }\n  }\n  ```\n\n## 3.TreeMap集合\n\n### 3.1TreeMap集合概述和特点【理解】\n\n+ TreeMap底层是红黑树结构\n+ 依赖自然排序或者比较器排序,对键进行排序\n+ 如果键存储的是自定义对象,需要实现Comparable接口或者在创建TreeMap对象时候给出比较器排序规则\n\n### 3.2TreeMap集合应用案例一【应用】\n\n+ 案例需求\n\n  + 创建一个TreeMap集合,键是学生对象(Student),值是籍贯(String),学生属性姓名和年龄,按照年龄进行排序并遍历\n  + 要求按照学生的年龄进行排序,如果年龄相同则按照姓名进行排序\n\n+ 代码实现\n\n  学生类\n\n  ```java\n  public class Student implements Comparable<Student>{\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public String toString() {\n          return "Student{" +\n                  "name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n\n      @Override\n      public int compareTo(Student o) {\n          //按照年龄进行排序\n          int result = o.getAge() - this.getAge();\n          //次要条件，按照姓名排序。\n          result = result == 0 ? o.getName().compareTo(this.getName()) : result;\n          return result;\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class Test1 {\n      public static void main(String[] args) {\n        \t// 创建TreeMap集合对象\n          TreeMap<Student,String> tm = new TreeMap<>();\n        \n  \t\t// 创建学生对象\n          Student s1 = new Student("xiaohei",23);\n          Student s2 = new Student("dapang",22);\n          Student s3 = new Student("xiaomei",22);\n        \n  \t\t// 将学生对象添加到TreeMap集合中\n          tm.put(s1,"江苏");\n          tm.put(s2,"北京");\n          tm.put(s3,"天津");\n        \n  \t\t// 遍历TreeMap集合,打印每个学生的信息\n          tm.forEach(\n                  (Student key, String value)->{\n                      System.out.println(key + "---" + value);\n                  }\n          );\n      }\n  }\n  ```\n\n### 3.3TreeMap集合应用案例二【应用】\n\n- 案例需求\n\n  - 给定一个字符串,要求统计字符串中每个字符出现的次数。\n  - 举例: 给定字符串是“aababcabcdabcde”,在控制台输出: “a(5)b(4)c(3)d(2)e(1)”\n\n- 代码实现\n\n  ```java\n  public class Test2 {\n      public static void main(String[] args) {\n        \t// 给定字符串\n          String s = "aababcabcdabcde";\n  \t\t// 创建TreeMap集合对象,键是Character,值是Integer\n          TreeMap<Character,Integer> tm = new TreeMap<>();\n\n          //遍历字符串，得到每一个字符\n          for (int i = 0; i < s.length(); i++) {\n              //c依次表示字符串中的每一个字符\n              char c = s.charAt(i);\n            \t// 判断当前遍历到的字符是否在集合中出现过\n              if(!tm.containsKey(c)){\n                  //表示当前字符是第一次出现。\n                  tm.put(c,1);\n              }else{\n                  //存在，表示当前字符已经出现过了\n                  //先获取这个字符已经出现的次数\n                  Integer count = tm.get(c);\n                  //自增，表示这个字符又出现了依次\n                  count++;\n                  //将自增后的结果再次添加到集合中。\n                  tm.put(c,count);\n              }\n          }\n          //  a（5）b（4）c（3）d（2）e（1）\n          //System.out.println(tm);\n          tm.forEach(\n                  (Character key,Integer value)->{\n                      System.out.print(key + "（" + value + "）");\n                  }\n          );\n      }\n  }\n  ```\n\n## 4.可变参数\n\n### 4.1可变参数【应用】\n\n- 可变参数介绍\n\n  - 可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了\n  - 方法的参数类型已经确定,个数不确定,我们可以使用可变参数\n\n- 可变参数定义格式\n\n  ```java\n  修饰符 返回值类型 方法名(数据类型… 变量名) {  }\n  ```\n\n- 可变参数的注意事项\n\n  - 这里的变量其实是一个数组\n  - 如果一个方法有多个参数，包含可变参数，可变参数要放在最后\n\n- 可变参数的基本使用\n\n  ```java\n  public class ArgsDemo01 {\n      public static void main(String[] args) {\n          System.out.println(sum(10, 20));\n          System.out.println(sum(10, 20, 30));\n          System.out.println(sum(10, 20, 30, 40));\n\n          System.out.println(sum(10,20,30,40,50));\n          System.out.println(sum(10,20,30,40,50,60));\n          System.out.println(sum(10,20,30,40,50,60,70));\n          System.out.println(sum(10,20,30,40,50,60,70,80,90,100));\n      }\n\n  //    public static int sum(int b,int... a) {\n  //        return 0;\n  //    }\n\n      public static int sum(int... a) {\n          int sum = 0;\n          for(int i : a) {\n              sum += i;\n          }\n          return sum;\n      }\n  }\n  ```\n\n### 4.2创建不可变集合【理解】\n\n+ 方法介绍\n\n  + 在List、Set、Map接口中,都存在of方法,可以创建一个不可变的集合\n    + 这个集合不能添加,不能删除,不能修改\n    + 但是可以结合集合的带参构造,实现集合的批量添加\n  + 在Map接口中,还有一个ofEntries方法可以提高代码的阅读性\n    + 首先会把键值对封装成一个Entry对象,再把这个Entry对象添加到集合当中\n\n+ 示例代码\n\n  ```java\n  public class MyVariableParameter4 {\n      public static void main(String[] args) {\n          // static <E>  List<E>  of(E…elements)  创建一个具有指定元素的List集合对象\n          //static <E>  Set<E>  of(E…elements)    创建一个具有指定元素的Set集合对象\n          //static <K , V>   Map<K，V>  of(E…elements) 创建一个具有指定元素的Map集合对象\n\n          //method1();\n          //method2();\n          //method3();\n          //method4();\n\n      }\n\n      private static void method4() {\n          Map<String, String> map = Map.ofEntries(\n                  Map.entry("zhangsan", "江苏"),\n                  Map.entry("lisi", "北京"));\n          System.out.println(map);\n      }\n\n      private static void method3() {\n          Map<String, String> map = Map.of("zhangsan", "江苏", "lisi", "北京", "wangwu", "天津");\n          System.out.println(map);\n      }\n\n      private static void method2() {\n          //传递的参数当中，不能存在重复的元素。\n          Set<String> set = Set.of("a", "b", "c", "d","a");\n          System.out.println(set);\n      }\n\n      private static void method1() {\n          List<String> list = List.of("a", "b", "c", "d");\n          System.out.println(list);\n          //list.add("Q");\n          //list.remove("a");\n          //list.set(0,"A");\n          //System.out.println(list);\n\n  //        ArrayList<String> list2 = new ArrayList<>();\n  //        list2.add("aaa");\n  //        list2.add("aaa");\n  //        list2.add("aaa");\n  //        list2.add("aaa");\n\n          //集合的批量添加。\n          //首先是通过调用List.of方法来创建一个不可变的集合，of方法的形参就是一个可变参数。\n          //再创建一个ArrayList集合，并把这个不可变的集合中所有的数据，都添加到ArrayList中。\n          ArrayList<String> list3 = new ArrayList<>(List.of("a", "b", "c", "d"));\n          System.out.println(list3);\n      }\n  }\n  ```\n\n## 5.Stream流\n\n### 5.1体验Stream流【理解】\n\n- 案例需求\n\n  按照下面的要求完成集合的创建和遍历\n\n  - 创建一个集合，存储多个字符串元素\n  - 把集合中所有以"张"开头的元素存储到一个新的集合\n  - 把"张"开头的集合中的长度为3的元素存储到一个新的集合\n  - 遍历上一步得到的集合\n\n- 原始方式示例代码\n\n  ```java\n  public class StreamDemo {\n      public static void main(String[] args) {\n          //创建一个集合，存储多个字符串元素\n          ArrayList<String> list = new ArrayList<String>();\n\n          list.add("林青霞");\n          list.add("张曼玉");\n          list.add("王祖贤");\n          list.add("柳岩");\n          list.add("张敏");\n          list.add("张无忌");\n\n          //把集合中所有以"张"开头的元素存储到一个新的集合\n          ArrayList<String> zhangList = new ArrayList<String>();\n\n          for(String s : list) {\n              if(s.startsWith("张")) {\n                  zhangList.add(s);\n              }\n          }\n\n  //        System.out.println(zhangList);\n\n          //把"张"开头的集合中的长度为3的元素存储到一个新的集合\n          ArrayList<String> threeList = new ArrayList<String>();\n\n          for(String s : zhangList) {\n              if(s.length() == 3) {\n                  threeList.add(s);\n              }\n          }\n\n  //        System.out.println(threeList);\n\n          //遍历上一步得到的集合\n          for(String s : threeList) {\n              System.out.println(s);\n          }\n          System.out.println("--------");\n\n          //Stream流来改进\n  //        list.stream().filter(s -> s.startsWith("张")).filter(s -> s.length() == 3).forEach(s -> System.out.println(s));\n          list.stream().filter(s -> s.startsWith("张")).filter(s -> s.length() == 3).forEach(System.out::println);\n      }\n  }\n  ```\n\n- 使用Stream流示例代码\n\n  ```java\n  public class StreamDemo {\n      public static void main(String[] args) {\n          //创建一个集合，存储多个字符串元素\n          ArrayList<String> list = new ArrayList<String>();\n\n          list.add("林青霞");\n          list.add("张曼玉");\n          list.add("王祖贤");\n          list.add("柳岩");\n          list.add("张敏");\n          list.add("张无忌");\n\n          //Stream流来改进\n          list.stream().filter(s -> s.startsWith("张")).filter(s -> s.length() == 3).forEach(System.out::println);\n      }\n  }\n  ```\n\n- Stream流的好处\n\n  - 直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤姓张、过滤长度为3、逐一打印\n  - Stream流把真正的函数式编程风格引入到Java中\n  - 代码简洁\n\n### 5.2Stream流的常见生成方式【应用】\n\n- Stream流的思想\n\n  ![01_Stream流思想](./img/java/basics/day18-集合03.img/01_Stream流思想.png)\n\n- Stream流的三类方法\n\n  + 获取Stream流\n    + 创建一条流水线,并把数据放到流水线上准备进行操作\n  + 中间方法\n    + 流水线上的操作\n    + 一次操作完毕之后,还可以继续进行其他操作\n  + 终结方法\n    + 一个Stream流只能有一个终结方法\n    + 是流水线上的最后一个操作\n\n- 生成Stream流的方式\n\n  - Collection体系集合\n\n    使用默认方法stream()生成流， default Stream<E> stream()\n\n  - Map体系集合\n\n    把Map转成Set集合，间接的生成流\n\n  - 数组\n\n    通过Arrays中的静态方法stream生成流\n\n  - 同种数据类型的多个数据\n\n    通过Stream接口的静态方法of(T... values)生成流\n\n- 代码演示\n\n  ```java\n  public class StreamDemo {\n      public static void main(String[] args) {\n          //Collection体系的集合可以使用默认方法stream()生成流\n          List<String> list = new ArrayList<String>();\n          Stream<String> listStream = list.stream();\n\n          Set<String> set = new HashSet<String>();\n          Stream<String> setStream = set.stream();\n\n          //Map体系的集合间接的生成流\n          Map<String,Integer> map = new HashMap<String, Integer>();\n          Stream<String> keyStream = map.keySet().stream();\n          Stream<Integer> valueStream = map.values().stream();\n          Stream<Map.Entry<String, Integer>> entryStream = map.entrySet().stream();\n\n          //数组可以通过Arrays中的静态方法stream生成流\n          String[] strArray = {"hello","world","java"};\n          Stream<String> strArrayStream = Arrays.stream(strArray);\n        \n        \t//同种数据类型的多个数据可以通过Stream接口的静态方法of(T... values)生成流\n          Stream<String> strArrayStream2 = Stream.of("hello", "world", "java");\n          Stream<Integer> intStream = Stream.of(10, 20, 30);\n      }\n  }\n  ```\n\n### 5.3Stream流中间操作方法【应用】\n\n- 概念\n\n  中间操作的意思是,执行完此方法之后,Stream流依然可以继续执行其他操作\n\n- 常见方法\n\n  | 方法名                                      | 说明                                       |\n  | ---------------------------------------- | ---------------------------------------- |\n  | Stream<T> filter(Predicate predicate)    | 用于对流中的数据进行过滤                             |\n  | Stream<T> limit(long maxSize)            | 返回此流中的元素组成的流，截取前指定参数个数的数据                |\n  | Stream<T> skip(long n)                   | 跳过指定参数个数的数据，返回由该流的剩余元素组成的流               |\n  | static <T> Stream<T> concat(Stream a, Stream b) | 合并a和b两个流为一个流                             |\n  | Stream<T> distinct()                     | 返回由该流的不同元素（根据Object.equals(Object) ）组成的流 |\n\n- filter代码演示\n\n  ```java\n  public class StreamDemo01 {\n      public static void main(String[] args) {\n          //创建一个集合，存储多个字符串元素\n          ArrayList<String> list = new ArrayList<String>();\n\n          list.add("林青霞");\n          list.add("张曼玉");\n          list.add("王祖贤");\n          list.add("柳岩");\n          list.add("张敏");\n          list.add("张无忌");\n\n          //需求1：把list集合中以张开头的元素在控制台输出\n          list.stream().filter(s -> s.startsWith("张")).forEach(System.out::println);\n          System.out.println("--------");\n\n          //需求2：把list集合中长度为3的元素在控制台输出\n          list.stream().filter(s -> s.length() == 3).forEach(System.out::println);\n          System.out.println("--------");\n\n          //需求3：把list集合中以张开头的，长度为3的元素在控制台输出\n          list.stream().filter(s -> s.startsWith("张")).filter(s -> s.length() == 3).forEach(System.out::println);\n      }\n  }\n  ```\n\n- limit&skip代码演示\n\n  ```java\n  public class StreamDemo02 {\n      public static void main(String[] args) {\n          //创建一个集合，存储多个字符串元素\n          ArrayList<String> list = new ArrayList<String>();\n\n          list.add("林青霞");\n          list.add("张曼玉");\n          list.add("王祖贤");\n          list.add("柳岩");\n          list.add("张敏");\n          list.add("张无忌");\n\n          //需求1：取前3个数据在控制台输出\n          list.stream().limit(3).forEach(System.out::println);\n          System.out.println("--------");\n\n          //需求2：跳过3个元素，把剩下的元素在控制台输出\n          list.stream().skip(3).forEach(System.out::println);\n          System.out.println("--------");\n\n          //需求3：跳过2个元素，把剩下的元素中前2个在控制台输出\n          list.stream().skip(2).limit(2).forEach(System.out::println);\n      }\n  }\n  ```\n\n- concat&distinct代码演示\n\n  ```java\n  public class StreamDemo03 {\n      public static void main(String[] args) {\n          //创建一个集合，存储多个字符串元素\n          ArrayList<String> list = new ArrayList<String>();\n\n          list.add("林青霞");\n          list.add("张曼玉");\n          list.add("王祖贤");\n          list.add("柳岩");\n          list.add("张敏");\n          list.add("张无忌");\n\n          //需求1：取前4个数据组成一个流\n          Stream<String> s1 = list.stream().limit(4);\n\n          //需求2：跳过2个数据组成一个流\n          Stream<String> s2 = list.stream().skip(2);\n\n          //需求3：合并需求1和需求2得到的流，并把结果在控制台输出\n  //        Stream.concat(s1,s2).forEach(System.out::println);\n\n          //需求4：合并需求1和需求2得到的流，并把结果在控制台输出，要求字符串元素不能重复\n          Stream.concat(s1,s2).distinct().forEach(System.out::println);\n      }\n  }\n  ```\n\n### 5.4Stream流终结操作方法【应用】\n\n- 概念\n\n  终结操作的意思是,执行完此方法之后,Stream流将不能再执行其他操作\n\n- 常见方法\n\n  | 方法名                           | 说明           |\n  | ----------------------------- | ------------ |\n  | void forEach(Consumer action) | 对此流的每个元素执行操作 |\n  | long count()                  | 返回此流中的元素数    |\n\n- 代码演示\n\n  ```java\n  public class StreamDemo {\n      public static void main(String[] args) {\n          //创建一个集合，存储多个字符串元素\n          ArrayList<String> list = new ArrayList<String>();\n\n          list.add("林青霞");\n          list.add("张曼玉");\n          list.add("王祖贤");\n          list.add("柳岩");\n          list.add("张敏");\n          list.add("张无忌");\n\n          //需求1：把集合中的元素在控制台输出\n  //        list.stream().forEach(System.out::println);\n\n          //需求2：统计集合中有几个以张开头的元素，并把统计结果在控制台输出\n          long count = list.stream().filter(s -> s.startsWith("张")).count();\n          System.out.println(count);\n      }\n  }\n  ```\n\n### 5.5Stream流的收集操作【应用】\n\n- 概念\n\n  对数据使用Stream流的方式操作完毕后,可以把流中的数据收集到集合中\n\n- 常用方法\n\n  | 方法名                            | 说明        |\n  | ------------------------------ | --------- |\n  | R collect(Collector collector) | 把结果收集到集合中 |\n\n- 工具类Collectors提供了具体的收集方式\n\n  | 方法名                                      | 说明            |\n  | ---------------------------------------- | ------------- |\n  | public static <T> Collector toList()     | 把元素收集到List集合中 |\n  | public static <T> Collector toSet()      | 把元素收集到Set集合中  |\n  | public static  Collector toMap(Function keyMapper,Function valueMapper) | 把元素收集到Map集合中  |\n\n- 代码演示\n\n  ```java\n  public class CollectDemo {\n      public static void main(String[] args) {\n          //创建List集合对象\n          List<String> list = new ArrayList<String>();\n          list.add("林青霞");\n          list.add("张曼玉");\n          list.add("王祖贤");\n          list.add("柳岩");\n\n          /*\n          //需求1：得到名字为3个字的流\n          Stream<String> listStream = list.stream().filter(s -> s.length() == 3);\n\n          //需求2：把使用Stream流操作完毕的数据收集到List集合中并遍历\n          List<String> names = listStream.collect(Collectors.toList());\n          for(String name : names) {\n              System.out.println(name);\n          }\n          */\n\n          //创建Set集合对象\n          Set<Integer> set = new HashSet<Integer>();\n          set.add(10);\n          set.add(20);\n          set.add(30);\n          set.add(33);\n          set.add(35);\n\n          /*\n          //需求3：得到年龄大于25的流\n          Stream<Integer> setStream = set.stream().filter(age -> age > 25);\n\n          //需求4：把使用Stream流操作完毕的数据收集到Set集合中并遍历\n          Set<Integer> ages = setStream.collect(Collectors.toSet());\n          for(Integer age : ages) {\n              System.out.println(age);\n          }\n          */\n          //定义一个字符串数组，每一个字符串数据由姓名数据和年龄数据组合而成\n          String[] strArray = {"林青霞,30", "张曼玉,35", "王祖贤,33", "柳岩,25"};\n\n          //需求5：得到字符串中年龄数据大于28的流\n          Stream<String> arrayStream = Stream.of(strArray).filter(s -> Integer.parseInt(s.split(",")[1]) > 28);\n\n          //需求6：把使用Stream流操作完毕的数据收集到Map集合中并遍历，字符串中的姓名作键，年龄作值\n          Map<String, Integer> map = arrayStream.collect(Collectors.toMap(s -> s.split(",")[0], s -> Integer.parseInt(s.split(",")[1])));\n\n          Set<String> keySet = map.keySet();\n          for (String key : keySet) {\n              Integer value = map.get(key);\n              System.out.println(key + "," + value);\n          }\n      }\n  }\n  ```\n\n### 5.6Stream流综合练习【应用】\n\n- 案例需求\n\n  现在有两个ArrayList集合，分别存储6名男演员名称和6名女演员名称，要求完成如下的操作\n\n  - 男演员只要名字为3个字的前三人\n  - 女演员只要姓林的，并且不要第一个\n  - 把过滤后的男演员姓名和女演员姓名合并到一起\n  - 把上一步操作后的元素作为构造方法的参数创建演员对象,遍历数据\n\n  演员类Actor已经提供，里面有一个成员变量，一个带参构造方法，以及成员变量对应的get/set方法\n\n- 代码实现\n\n  演员类\n\n  ```java\n  public class Actor {\n      private String name;\n\n      public Actor(String name) {\n          this.name = name;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class StreamTest {\n      public static void main(String[] args) {\n          //创建集合\n          ArrayList<String> manList = new ArrayList<String>();\n          manList.add("周润发");\n          manList.add("成龙");\n          manList.add("刘德华");\n          manList.add("吴京");\n          manList.add("周星驰");\n          manList.add("李连杰");\n\n          ArrayList<String> womanList = new ArrayList<String>();\n          womanList.add("林心如");\n          womanList.add("张曼玉");\n          womanList.add("林青霞");\n          womanList.add("柳岩");\n          womanList.add("林志玲");\n          womanList.add("王祖贤");\n    \n          /*\n          //男演员只要名字为3个字的前三人\n          Stream<String> manStream = manList.stream().filter(s -> s.length() == 3).limit(3);\n    \n          //女演员只要姓林的，并且不要第一个\n          Stream<String> womanStream = womanList.stream().filter(s -> s.startsWith("林")).skip(1);\n    \n          //把过滤后的男演员姓名和女演员姓名合并到一起\n          Stream<String> stream = Stream.concat(manStream, womanStream);\n    \n          //把上一步操作后的元素作为构造方法的参数创建演员对象,遍历数据\n  //        stream.map(Actor::new).forEach(System.out::println);\n          stream.map(Actor::new).forEach(p -> System.out.println(p.getName()));\n          */\n    \n          Stream.concat(manList.stream().filter(s -> s.length() == 3).limit(3),\n                  womanList.stream().filter(s -> s.startsWith("林")).skip(1)).map(Actor::new).\n                  forEach(p -> System.out.println(p.getName()));\n      }\n  }\n  ```\n\n\n',Tn={data:function(){return{MainComponent1:wn,MainComponent2:jn,MainComponent3:Cn}}},En=Tn,In=Object(d["a"])(En,fn,xn,!1,null,"1a810af6",null),Dn=In.exports,Rn=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent1}}),t("q-markdown",{attrs:{src:n.MainComponent2}})],1)},Mn=[],An='## 1.File类\n\n### 1.1File类概述和构造方法【应用】\n\n- File类介绍\n\n  - 它是文件和目录路径名的抽象表示\n  - 文件和目录是可以通过File封装成对象的\n  - 对于File而言,其封装的并不是一个真正存在的文件,仅仅是一个路径名而已.它可以是存在的,也可以是不存在的.将来是要通过具体的操作把这个路径的内容转换为具体存在的\n\n- File类的构造方法\n\n  | 方法名                                 | 说明                               |\n  | ----------------------------------- | -------------------------------- |\n  | File(String   pathname)             | 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例 |\n  | File(String   parent, String child) | 从父路径名字符串和子路径名字符串创建新的   File实例    |\n  | File(File   parent, String child)   | 从父抽象路径名和子路径名字符串创建新的   File实例     |\n\n- 示例代码\n\n  ```java\n  public class FileDemo01 {\n      public static void main(String[] args) {\n          //File(String pathname): 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例\n          File f1 = new File("E:\\\\itcast\\\\java.txt");\n          System.out.println(f1);\n\n          //File(String parent, String child): 从父路径名字符串和子路径名字符串创建新的 File实例\n          File f2 = new File("E:\\\\itcast","java.txt");\n          System.out.println(f2);\n\n          //File(File parent, String child): 从父抽象路径名和子路径名字符串创建新的 File实例\n          File f3 = new File("E:\\\\itcast");\n          File f4 = new File(f3,"java.txt");\n          System.out.println(f4);\n      }\n  }\n  ```\n\n### 1.2绝对路径和相对路径【理解】\n\n+ 绝对路径\n\n  是一个完整的路径,从盘符开始\n\n+ 相对路径\n\n  是一个简化的路径,相对当前项目下的路径\n\n+ 示例代码\n\n  ```java\n  public class FileDemo02 {\n      public static void main(String[] args) {\n          // 是一个完整的路径,从盘符开始\n          File file1 = new File("D:\\\\itheima\\\\a.txt");\n\n          // 是一个简化的路径,从当前项目根目录开始\n          File file2 = new File("a.txt");\n          File file3 = new File("模块名\\\\a.txt");\n      }\n  }\n  ```\n\n### 1.3File类创建功能【应用】\n\n- 方法分类\n\n  | 方法名                            | 说明                               |\n  | ------------------------------ | -------------------------------- |\n  | public boolean createNewFile() | 当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件 |\n  | public boolean mkdir()         | 创建由此抽象路径名命名的目录                   |\n  | public boolean mkdirs()        | 创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录    |\n\n- 示例代码\n\n  ```java\n  public class FileDemo02 {\n      public static void main(String[] args) throws IOException {\n          //需求1：我要在E:\\\\itcast目录下创建一个文件java.txt\n          File f1 = new File("E:\\\\itcast\\\\java.txt");\n          System.out.println(f1.createNewFile());\n          System.out.println("--------");\n\n          //需求2：我要在E:\\\\itcast目录下创建一个目录JavaSE\n          File f2 = new File("E:\\\\itcast\\\\JavaSE");\n          System.out.println(f2.mkdir());\n          System.out.println("--------");\n\n          //需求3：我要在E:\\\\itcast目录下创建一个多级目录JavaWEB\\\\HTML\n          File f3 = new File("E:\\\\itcast\\\\JavaWEB\\\\HTML");\n  //        System.out.println(f3.mkdir());\n          System.out.println(f3.mkdirs());\n          System.out.println("--------");\n\n          //需求4：我要在E:\\\\itcast目录下创建一个文件javase.txt\n          File f4 = new File("E:\\\\itcast\\\\javase.txt");\n  //        System.out.println(f4.mkdir());\n          System.out.println(f4.createNewFile());\n      }\n  }\n  ```\n\n### 1.4File类删除功能【应用】\n\n- 方法分类\n\n  | 方法名                       | 说明                |\n  | ------------------------- | ----------------- |\n  | public boolean   delete() | 删除由此抽象路径名表示的文件或目录 |\n\n- 示例代码\n\n  ```java\n  public class FileDemo03 {\n      public static void main(String[] args) throws IOException {\n  //        File f1 = new File("E:\\\\itcast\\\\java.txt");\n          //需求1：在当前模块目录下创建java.txt文件\n          File f1 = new File("myFile\\\\java.txt");\n  //        System.out.println(f1.createNewFile());\n\n          //需求2：删除当前模块目录下的java.txt文件\n          System.out.println(f1.delete());\n          System.out.println("--------");\n\n          //需求3：在当前模块目录下创建itcast目录\n          File f2 = new File("myFile\\\\itcast");\n  //        System.out.println(f2.mkdir());\n\n          //需求4：删除当前模块目录下的itcast目录\n          System.out.println(f2.delete());\n          System.out.println("--------");\n\n          //需求5：在当前模块下创建一个目录itcast,然后在该目录下创建一个文件java.txt\n          File f3 = new File("myFile\\\\itcast");\n  //        System.out.println(f3.mkdir());\n          File f4 = new File("myFile\\\\itcast\\\\java.txt");\n  //        System.out.println(f4.createNewFile());\n\n          //需求6：删除当前模块下的目录itcast\n          System.out.println(f4.delete());\n          System.out.println(f3.delete());\n      }\n  }\n  ```\n\n### 1.5File类判断和获取功能【应用】\n\n- 判断功能\n\n  | 方法名                            | 说明                   |\n  | ------------------------------ | -------------------- |\n  | public   boolean isDirectory() | 测试此抽象路径名表示的File是否为目录 |\n  | public   boolean isFile()      | 测试此抽象路径名表示的File是否为文件 |\n  | public   boolean   exists()    | 测试此抽象路径名表示的File是否存在  |\n\n- 获取功能\n\n  | 方法名                               | 说明                            |\n  | --------------------------------- | ----------------------------- |\n  | public   String getAbsolutePath() | 返回此抽象路径名的绝对路径名字符串             |\n  | public   String getPath()         | 将此抽象路径名转换为路径名字符串              |\n  | public   String getName()         | 返回由此抽象路径名表示的文件或目录的名称          |\n  | public   File[] listFiles()       | 返回此抽象路径名表示的目录中的文件和目录的File对象数组 |\n\n- 示例代码\n\n  ```java\n  public class FileDemo04 {\n      public static void main(String[] args) {\n          //创建一个File对象\n          File f = new File("myFile\\\\java.txt");\n\n  //        public boolean isDirectory()：测试此抽象路径名表示的File是否为目录\n  //        public boolean isFile()：测试此抽象路径名表示的File是否为文件\n  //        public boolean exists()：测试此抽象路径名表示的File是否存在\n          System.out.println(f.isDirectory());\n          System.out.println(f.isFile());\n          System.out.println(f.exists());\n\n  //        public String getAbsolutePath()：返回此抽象路径名的绝对路径名字符串\n  //        public String getPath()：将此抽象路径名转换为路径名字符串\n  //        public String getName()：返回由此抽象路径名表示的文件或目录的名称\n          System.out.println(f.getAbsolutePath());\n          System.out.println(f.getPath());\n          System.out.println(f.getName());\n          System.out.println("--------");\n\n  //        public File[] listFiles()：返回此抽象路径名表示的目录中的文件和目录的File对象数组\n          File f2 = new File("E:\\\\itcast");\n          File[] fileArray = f2.listFiles();\n          for(File file : fileArray) {\n  //            System.out.println(file);\n  //            System.out.println(file.getName());\n              if(file.isFile()) {\n                  System.out.println(file.getName());\n              }\n          }\n      }\n  }\n  ```\n\n### 1.6File类练习一【应用】\n\n+ 案例需求\n\n   在当前模块下的aaa文件夹中创建一个a.txt文件\n\n+ 实现步骤\n\n  + 创建File对象,指向aaa文件夹\n  + 判断aaa文件夹是否存在,如果不存在则创建\n  + 创建File对象,指向aaa文件夹下的a.txt文件\n  + 创建这个文件\n\n+ 代码实现\n\n  ```java\n  public class Test1 {\n      public static void main(String[] args) throws IOException {\n          //练习一：在当前模块下的aaa文件夹中创建一个a.txt文件\n         /* File file = new File("filemodule\\\\aaa\\\\a.txt");\n          file.createNewFile();*/\n          //注意点:文件所在的文件夹必须要存在.\n\n        \t//1.创建File对象,指向aaa文件夹\n          File file = new File("filemodule\\\\aaa");\n        \t//2.判断aaa文件夹是否存在,如果不存在则创建\n          if(!file.exists()){\n              //如果文件夹不存在,就创建出来\n              file.mkdirs();\n          }\n        \t//3.创建File对象,指向aaa文件夹下的a.txt文件\n          File newFile = new File(file,"a.txt");\n        \t//4.创建这个文件\n          newFile.createNewFile();\n      }\n  }\n  ```\n\n### 1.7File类练习二【应用】\n\n+ 案例需求\n\n  删除一个多级文件夹\n\n+ 实现步骤\n\n  + 定义一个方法,接收一个File对象\n  + 遍历这个File对象,获取它下边的每个文件和文件夹对象\n  + 判断当前遍历到的File对象是文件还是文件夹\n  + 如果是文件,直接删除\n  + 如果是文件夹,递归调用自己,将当前遍历到的File对象当做参数传递\n  + 参数传递过来的文件夹File对象已经处理完成,最后直接删除这个空文件夹\n\n+ 代码实现\n\n  ```java\n  public class Test2 {\n      public static void main(String[] args) {\n          //练习二：删除一个多级文件夹\n          //delete方法\n          //只能删除文件和空文件夹.\n          //如果现在要删除一个有内容的文件夹?\n          //先删掉这个文件夹里面所有的内容.\n          //最后再删除这个文件夹\n\n          File src = new File("C:\\\\Users\\\\apple\\\\Desktop\\\\src");\n          deleteDir(src);\n      }\n    \n  \t//1.定义一个方法,接收一个File对象\n      private static void deleteDir(File src) {\n          //先删掉这个文件夹里面所有的内容.\n          //递归 方法在方法体中自己调用自己.\n          //注意: 可以解决所有文件夹和递归相结合的题目\n          //2.遍历这个File对象,获取它下边的每个文件和文件夹对象\n          File[] files = src.listFiles();\n          //3.判断当前遍历到的File对象是文件还是文件夹\n          for (File file : files) {\n              //4.如果是文件,直接删除\n              if(file.isFile()){\n                  file.delete();\n              }else{\n                  //5.如果是文件夹,递归调用自己,将当前遍历到的File对象当做参数传递\n                  deleteDir(file);//参数一定要是src文件夹里面的文件夹File对象\n              }\n          }\n          //6.参数传递过来的文件夹File对象已经处理完成,最后直接删除这个空文件夹\n          src.delete();\n      }\n\n  }\n  ```\n\n### 1.8File类练习三【应用】\n\n+ 案例需求\n\n  统计一个文件夹中每种文件的个数并打印\n\n  打印格式如下：\n\n    \t\t\ttxt:3个\n\n    \t\t\tdoc:4个\n\n    \t\t\tjpg:6个\n\n   \t\t\t …\n\n+ 实现步骤\n\n  + 定义一个方法,参数是HashMap集合用来统计次数和File对象要统计的文件夹\n  + 遍历File对象,获取它下边的每一个文件和文件夹对象\n  + 判断当前File对象是文件还是文件夹\n  + 如果是文件,判断这种类型文件后缀名在HashMap集合中是否出现过\n    + 没出现过,将这种类型文件的后缀名存入集合中,次数存1\n    + 出现过,获取这种类型文件的后缀名出现的次数,对其+1,在存回集合中\n  + 如果是文件夹,递归调用自己,HashMap集合就是参数集合,File对象是当前文件夹对象\n\n+ 代码实现\n\n  ```java\n  public class Test3 {\n      public static void main(String[] args) {\n          //统计一个文件夹中,每种文件出现的次数.\n          //统计 --- 定义一个变量用来统计. ---- 弊端:同时只能统计一种文件\n          //利用map集合进行数据统计,键 --- 文件后缀名  值 ----  次数\n\n          File file = new File("filemodule");\n          HashMap<String, Integer> hm = new HashMap<>();\n          getCount(hm, file);\n          System.out.println(hm);\n      }\n    \n  \t//1.定义一个方法,参数是HashMap集合用来统计次数和File对象要统计的文件夹\n      private static void getCount(HashMap<String, Integer> hm, File file) {\n        \t//2.遍历File对象,获取它下边的每一个文件和文件夹对象\n          File[] files = file.listFiles();\n          for (File f : files) {\n            \t//3.判断当前File对象是文件还是文件夹\n              if(f.isFile()){\n                \t//如果是文件,判断这种类型文件后缀名在HashMap集合中是否出现过\n                  String fileName = f.getName();\n                  String[] fileNameArr = fileName.split("\\\\.");\n                  if(fileNameArr.length == 2){\n                      String fileEndName = fileNameArr[1];\n                      if(hm.containsKey(fileEndName)){\n                          //出现过,获取这种类型文件的后缀名出现的次数,对其+1,在存回集合中\n                          Integer count = hm.get(fileEndName);\n                          //这种文件又出现了一次.\n                          count++;\n                          //把已经出现的次数给覆盖掉.\n                          hm.put(fileEndName,count);\n                      }else{\n                          // 没出现过,将这种类型文件的后缀名存入集合中,次数存1\n                          hm.put(fileEndName,1);\n                      }\n                  }\n              }else{\n                //如果是文件夹,递归调用自己,HashMap集合就是参数集合,File对象是当前文件夹对象代码实现\n                  getCount(hm,f);\n              }\n          }\n      }\n    \n  }\n  ```\n\n## 2.字节流\n\n### 2.1 IO流概述和分类【理解】\n\n- IO流介绍\n  - IO：输入/输出(Input/Output)\n  - 流：是一种抽象概念,是对数据传输的总称.也就是说数据在设备间的传输称为流,流的本质是数据传输\n  - IO流就是用来处理设备间数据传输问题的.常见的应用: 文件复制; 文件上传; 文件下载\n- IO流的分类\n  - 按照数据的流向\n    - 输入流：读数据\n    - 输出流：写数据\n  - 按照数据类型来分\n    - 字节流\n      - 字节输入流\n      - 字节输出流\n    - 字符流\n      - 字符输入流\n      - 字符输出流\n- IO流的使用场景\n  - 如果操作的是纯文本文件,优先使用字符流\n  - 如果操作的是图片、视频、音频等二进制文件,优先使用字节流\n  - 如果不确定文件类型,优先使用字节流.字节流是万能的流\n\n### 2.2字节流写数据【应用】\n\n- 字节流抽象基类\n\n  - InputStream：这个抽象类是表示字节输入流的所有类的超类\n  - OutputStream：这个抽象类是表示字节输出流的所有类的超类\n  - 子类名特点：子类名称都是以其父类名作为子类名的后缀\n\n- 字节输出流\n\n  - FileOutputStream(String name)：创建文件输出流以指定的名称写入文件\n\n- 使用字节输出流写数据的步骤\n\n  - 创建字节输出流对象(调用系统功能创建了文件,创建字节输出流对象,让字节输出流对象指向文件)\n  - 调用字节输出流对象的写数据方法\n  - 释放资源(关闭此文件输出流并释放与此流相关联的任何系统资源)\n\n- 示例代码\n\n  ```java\n  public class FileOutputStreamDemo01 {\n      public static void main(String[] args) throws IOException {\n          //创建字节输出流对象\n        \t/*\n        \t\t注意点:\n        \t\t\t\t1.如果文件不存在,会帮我们创建\n        \t\t\t\t2.如果文件存在,会把文件清空\n        \t*/\n        \t//FileOutputStream(String name)：创建文件输出流以指定的名称写入文件\n          FileOutputStream fos = new FileOutputStream("myByteStream\\\\fos.txt");\n\n          //void write(int b)：将指定的字节写入此文件输出流\n          fos.write(97);\n  //        fos.write(57);\n  //        fos.write(55);\n\n          //最后都要释放资源\n          //void close()：关闭此文件输出流并释放与此流相关联的任何系统资源。\n          fos.close();\n      }\n  }\n  ```\n\n### 2.3字节流写数据的三种方式【应用】\n\n- 写数据的方法分类\n\n  | 方法名                                      | 说明                                       |\n  | ---------------------------------------- | ---------------------------------------- |\n  | void   write(int b)                      | 将指定的字节写入此文件输出流   一次写一个字节数据               |\n  | void   write(byte[] b)                   | 将 b.length字节从指定的字节数组写入此文件输出流   一次写一个字节数组数据 |\n  | void   write(byte[] b, int off, int len) | 将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流   一次写一个字节数组的部分数据 |\n\n- 示例代码\n\n  ```java\n  public class FileOutputStreamDemo02 {\n      public static void main(String[] args) throws IOException {\n          //FileOutputStream(String name)：创建文件输出流以指定的名称写入文件\n          FileOutputStream fos = new FileOutputStream("myByteStream\\\\fos.txt");\n          //FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件\n  //        FileOutputStream fos = new FileOutputStream(new File("myByteStream\\\\fos.txt"));\n\n          //void write(int b)：将指定的字节写入此文件输出流\n  //        fos.write(97);\n  //        fos.write(98);\n  //        fos.write(99);\n  //        fos.write(100);\n  //        fos.write(101);\n\n  //        void write(byte[] b)：将 b.length字节从指定的字节数组写入此文件输出流\n  //        byte[] bys = {97, 98, 99, 100, 101};\n          //byte[] getBytes()：返回字符串对应的字节数组\n          byte[] bys = "abcde".getBytes();\n  //        fos.write(bys);\n\n          //void write(byte[] b, int off, int len)：将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流\n  //        fos.write(bys,0,bys.length);\n          fos.write(bys,1,3);\n\n          //释放资源\n          fos.close();\n      }\n  }\n  ```\n\n### 2.4字节流写数据的两个小问题【应用】\n\n- 字节流写数据如何实现换行\n\n  - windows:\\r\\n\n  - linux:\\n\n  - mac:\\r\n\n- 字节流写数据如何实现追加写入\n\n  - public FileOutputStream(String name,boolean append)\n  - 创建文件输出流以指定的名称写入文件。如果第二个参数为true ，则字节将写入文件的末尾而不是开头\n\n- 示例代码\n\n  ```java\n  public class FileOutputStreamDemo03 {\n      public static void main(String[] args) throws IOException {\n          //创建字节输出流对象\n  //        FileOutputStream fos = new FileOutputStream("myByteStream\\\\fos.txt");\n          FileOutputStream fos = new FileOutputStream("myByteStream\\\\fos.txt",true);\n\n          //写数据\n          for (int i = 0; i < 10; i++) {\n              fos.write("hello".getBytes());\n              fos.write("\\r\\n".getBytes());\n          }\n\n          //释放资源\n          fos.close();\n      }\n  }\n  ```\n\n### 2.5字节流写数据加异常处理【应用】\n\n- 异常处理格式\n\n  - try-catch-finally\n\n    ```java\n    try{\n    \t可能出现异常的代码;\n    }catch(异常类名 变量名){\n    \t异常的处理代码;\n    }finally{\n    \t执行所有清除操作;\n    }\n    ```\n\n  - finally特点\n\n    - 被finally控制的语句一定会执行，除非JVM退出\n\n- 示例代码\n\n  ```java\n  public class FileOutputStreamDemo04 {\n      public static void main(String[] args) {\n          //加入finally来实现释放资源\n          FileOutputStream fos = null;\n          try {\n              fos = new FileOutputStream("myByteStream\\\\fos.txt");\n              fos.write("hello".getBytes());\n          } catch (IOException e) {\n              e.printStackTrace();\n          } finally {\n              if(fos != null) {\n                  try {\n                      fos.close();\n                  } catch (IOException e) {\n                      e.printStackTrace();\n                  }\n              }\n          }\n      }\n  }\n  ```\n\n### 2.6字节流读数据(一次读一个字节数据)【应用】\n\n- 字节输入流\n\n  - FileInputStream(String name)：通过打开与实际文件的连接来创建一个FileInputStream,该文件由文件系统中的路径名name命名\n\n- 字节输入流读取数据的步骤\n\n  - 创建字节输入流对象\n  - 调用字节输入流对象的读数据方法\n  - 释放资源\n\n- 示例代码\n\n  ```java\n  public class FileInputStreamDemo01 {\n      public static void main(String[] args) throws IOException {\n          //创建字节输入流对象\n          //FileInputStream(String name)\n          FileInputStream fis = new FileInputStream("myByteStream\\\\fos.txt");\n\n          int by;\n          /*\n              fis.read()：读数据\n              by=fis.read()：把读取到的数据赋值给by\n              by != -1：判断读取到的数据是否是-1\n           */\n          while ((by=fis.read())!=-1) {\n              System.out.print((char)by);\n          }\n\n          //释放资源\n          fis.close();\n      }\n  }\n  ```\n\n### 2.7字节流复制文件【应用】\n\n- 案例需求\n\n  ​\t把“E:\\\\itcast\\\\窗里窗外.txt”复制到模块目录下的“窗里窗外.txt”   (文件可以是任意文件)\n\n- 实现步骤\n\n  - 复制文本文件，其实就把文本文件的内容从一个文件中读取出来(数据源)，然后写入到另一个文件中(目的地)\n\n  - 数据源：\n\n    ​\tE:\\\\itcast\\\\窗里窗外.txt --- 读数据 --- InputStream --- FileInputStream \n\n  - 目的地：\n\n    ​\tmyByteStream\\\\窗里窗外.txt --- 写数据 --- OutputStream --- FileOutputStream\n\n- 代码实现\n\n  ```java\n  public class CopyTxtDemo {\n      public static void main(String[] args) throws IOException {\n          //根据数据源创建字节输入流对象\n          FileInputStream fis = new FileInputStream("E:\\\\itcast\\\\窗里窗外.txt");\n          //根据目的地创建字节输出流对象\n          FileOutputStream fos = new FileOutputStream("myByteStream\\\\窗里窗外.txt");\n\n          //读写数据，复制文本文件(一次读取一个字节，一次写入一个字节)\n          int by;\n          while ((by=fis.read())!=-1) {\n              fos.write(by);\n          }\n\n          //释放资源\n          fos.close();\n          fis.close();\n      }\n  }\n  ```\n\n### 2.8字节流读数据(一次读一个字节数组数据)【应用】\n\n- 一次读一个字节数组的方法\n\n  - public int read(byte[] b)：从输入流读取最多b.length个字节的数据\n  - 返回的是读入缓冲区的总字节数,也就是实际的读取字节个数\n\n- 示例代码\n\n  ```java\n  public class FileInputStreamDemo02 {\n      public static void main(String[] args) throws IOException {\n          //创建字节输入流对象\n          FileInputStream fis = new FileInputStream("myByteStream\\\\fos.txt");\n\n          byte[] bys = new byte[1024]; //1024及其整数倍\n          int len;\n        \t//循环读取\n          while ((len=fis.read(bys))!=-1) {\n              System.out.print(new String(bys,0,len));\n          }\n\n          //释放资源\n          fis.close();\n      }\n  }\n  ```\n\n### 2.9字节流复制文件【应用】\n\n- 案例需求\n\n  ​\t把“E:\\\\itcast\\\\mn.jpg”复制到模块目录下的“mn.jpg”  (文件可以是任意文件去)\n\n- 实现步骤\n\n  - 根据数据源创建字节输入流对象\n  - 根据目的地创建字节输出流对象\n  - 读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组)\n  - 释放资源\n\n- 代码实现\n\n  ```java\n  public class CopyJpgDemo {\n      public static void main(String[] args) throws IOException {\n          //根据数据源创建字节输入流对象\n          FileInputStream fis = new FileInputStream("E:\\\\itcast\\\\mn.jpg");\n          //根据目的地创建字节输出流对象\n          FileOutputStream fos = new FileOutputStream("myByteStream\\\\mn.jpg");\n\n          //读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组)\n          byte[] bys = new byte[1024];\n          int len;\n          while ((len=fis.read(bys))!=-1) {\n              fos.write(bys,0,len);\n          }\n\n          //释放资源\n          fos.close();\n          fis.close();\n      }\n  }\n  ```\n\n## 3.字节缓冲流\n\n### 3.1字节缓冲流构造方法【应用】\n\n- 字节缓冲流介绍\n\n  - lBufferOutputStream：该类实现缓冲输出流.通过设置这样的输出流,应用程序可以向底层输出流写入字节,而不必为写入的每个字节导致底层系统的调用\n  - lBufferedInputStream：创建BufferedInputStream将创建一个内部缓冲区数组.当从流中读取或跳过字节时,内部缓冲区将根据需要从所包含的输入流中重新填充,一次很多字节\n\n- 构造方法：\n\n  | 方法名                                    | 说明          |\n  | -------------------------------------- | ----------- |\n  | BufferedOutputStream(OutputStream out) | 创建字节缓冲输出流对象 |\n  | BufferedInputStream(InputStream in)    | 创建字节缓冲输入流对象 |\n\n- 示例代码\n\n  ```java\n  public class BufferStreamDemo {\n      public static void main(String[] args) throws IOException {\n          //字节缓冲输出流：BufferedOutputStream(OutputStream out)\n   \n          BufferedOutputStream bos = new BufferedOutputStream(new \t\t\t\t                                       FileOutputStream("myByteStream\\\\bos.txt"));\n          //写数据\n          bos.write("hello\\r\\n".getBytes());\n          bos.write("world\\r\\n".getBytes());\n          //释放资源\n          bos.close();\n      \n\n          //字节缓冲输入流：BufferedInputStream(InputStream in)\n          BufferedInputStream bis = new BufferedInputStream(new                                                          FileInputStream("myByteStream\\\\bos.txt"));\n\n          //一次读取一个字节数据\n  //        int by;\n  //        while ((by=bis.read())!=-1) {\n  //            System.out.print((char)by);\n  //        }\n\n          //一次读取一个字节数组数据\n          byte[] bys = new byte[1024];\n          int len;\n          while ((len=bis.read(bys))!=-1) {\n              System.out.print(new String(bys,0,len));\n          }\n\n          //释放资源\n          bis.close();\n      }\n  }\n  ```\n\n### 3.2字节缓冲流复制视频【应用】\n\n- 案例需求\n\n  把“E:\\\\itcast\\\\字节流复制图片.avi”复制到模块目录下的“字节流复制图片.avi”\n\n- 实现步骤\n\n  - 根据数据源创建字节输入流对象\n  - 根据目的地创建字节输出流对象\n  - 读写数据，复制视频\n  - 释放资源\n\n- 代码实现\n\n  ```java\n  public class CopyAviDemo {\n      public static void main(String[] args) throws IOException {\n\n          //复制视频\n  //        method1();\n        \t method2();\n\n      }\n\n      //字节缓冲流一次读写一个字节数组\n      public static void method2() throws IOException {\n          BufferedInputStream bis = new BufferedInputStream(new FileInputStream("E:\\\\itcast\\\\字节流复制图片.avi"));\n          BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("myByteStream\\\\字节流复制图片.avi"));\n\n          byte[] bys = new byte[1024];\n          int len;\n          while ((len=bis.read(bys))!=-1) {\n              bos.write(bys,0,len);\n          }\n\n          bos.close();\n          bis.close();\n      }\n\n      //字节缓冲流一次读写一个字节\n      public static void method1() throws IOException {\n          BufferedInputStream bis = new BufferedInputStream(new FileInputStream("E:\\\\itcast\\\\字节流复制图片.avi"));\n          BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("myByteStream\\\\字节流复制图片.avi"));\n\n          int by;\n          while ((by=bis.read())!=-1) {\n              bos.write(by);\n          }\n\n          bos.close();\n          bis.close();\n      }\n\n  }\n  ```\n\n\n\n\n',On='## 1.字符流\n\n### 1.1为什么会出现字符流【理解】\n\n- 字符流的介绍\n\n  由于字节流操作中文不是特别的方便，所以Java就提供字符流\n\n  字符流 = 字节流 + 编码表\n\n- 中文的字节存储方式\n\n  用字节流复制文本文件时，文本文件也会有中文，但是没有问题，原因是最终底层操作会自动进行字节拼接成中文，如何识别是中文的呢？\n\n  汉字在存储的时候，无论选择哪种编码存储，第一个字节都是负数\n\n### 1.2编码表【理解】\n\n- 什么是字符集\n\n  是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等\n\n  l计算机要准确的存储和识别各种字符集符号，就需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBXXX字符集、Unicode字符集等\n\n- 常见的字符集\n\n  - ASCII字符集：\n\n    lASCII：是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符(回车键、退格、换行键等)和可显示字符(英文大小写字符、阿拉伯数字和西文符号) \n\n    基本的ASCII字符集，使用7位表示一个字符，共128字符。ASCII的扩展字符集使用8位表示一个字符，共256字符，方便支持欧洲常用字符。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等\n\n  - GBXXX字符集：\n\n    GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等\n\n  - Unicode字符集：\n\n    UTF-8编码：可以用来表示Unicode标准中任意字符，它是电子邮件、网页及其他存储或传送文字的应用 中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。它使用一至四个字节为每个字符编码\n\n    编码规则： \n\n      128个US-ASCII字符，只需一个字节编码\n\n      拉丁文等字符，需要二个字节编码\n\n      大部分常用字（含中文），使用三个字节编码\n\n      其他极少使用的Unicode辅助字符，使用四字节编码\n\n### 1.3字符串中的编码解码问题【应用】\n\n- 相关方法\n\n  | 方法名                                      | 说明                          |\n  | ---------------------------------------- | --------------------------- |\n  | byte[] getBytes()                        | 使用平台的默认字符集将该 String编码为一系列字节 |\n  | byte[] getBytes(String charsetName)      | 使用指定的字符集将该 String编码为一系列字节   |\n  | String(byte[] bytes)                     | 使用平台的默认字符集解码指定的字节数组来创建字符串   |\n  | String(byte[] bytes, String charsetName) | 通过指定的字符集解码指定的字节数组来创建字符串     |\n\n- 代码演示\n\n  ```java\n  public class StringDemo {\n      public static void main(String[] args) throws UnsupportedEncodingException {\n          //定义一个字符串\n          String s = "中国";\n\n          //byte[] bys = s.getBytes(); //[-28, -72, -83, -27, -101, -67]\n          //byte[] bys = s.getBytes("UTF-8"); //[-28, -72, -83, -27, -101, -67]\n          byte[] bys = s.getBytes("GBK"); //[-42, -48, -71, -6]\n          System.out.println(Arrays.toString(bys));\n\n          //String ss = new String(bys);\n          //String ss = new String(bys,"UTF-8");\n          String ss = new String(bys,"GBK");\n          System.out.println(ss);\n      }\n  }\n  ```\n\n### 1.4字符流写数据【应用】\n\n- 介绍\n\n  Writer: 用于写入字符流的抽象父类\n\n  FileWriter: 用于写入字符流的常用子类\n\n\n- 构造方法\n\n  | 方法名                                      | 说明                                       |\n  | ---------------------------------------- | ---------------------------------------- |\n  | FileWriter(File file)                    | 根据给定的 File 对象构造一个 FileWriter 对象          |\n  | FileWriter(File file, boolean append)    | 根据给定的 File 对象构造一个 FileWriter 对象          |\n  | FileWriter(String fileName)              | 根据给定的文件名构造一个 FileWriter 对象               |\n  | FileWriter(String fileName, boolean append) | 根据给定的文件名以及指示是否附加写入数据的 boolean 值来构造 FileWriter 对象 |\n\n\n- 成员方法\n\n  | 方法名                                      | 说明         |\n  | ---------------------------------------- | ---------- |\n  | void   write(int c)                      | 写一个字符      |\n  | void   write(char[] cbuf)                | 写入一个字符数组   |\n  | void write(char[] cbuf, int off, int len) | 写入字符数组的一部分 |\n  | void write(String str)                   | 写一个字符串     |\n  | void write(String str, int off, int len) | 写一个字符串的一部分 |\n\n- 刷新和关闭的方法\n\n  | 方法名     | 说明                                 |\n  | ------- | ---------------------------------- |\n  | flush() | 刷新流，之后还可以继续写数据                     |\n  | close() | 关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据 |\n\n- 代码演示\n\n  ```java\n  public class OutputStreamWriterDemo {\n      public static void main(String[] args) throws IOException {\n          FileWriter fw = new FileWriter("myCharStream\\\\a.txt");\n\n          //void write(int c)：写一个字符\n  //        fw.write(97);\n  //        fw.write(98);\n  //        fw.write(99);\n\n          //void writ(char[] cbuf)：写入一个字符数组\n          char[] chs = {\'a\', \'b\', \'c\', \'d\', \'e\'};\n  //        fw.write(chs);\n\n          //void write(char[] cbuf, int off, int len)：写入字符数组的一部分\n  //        fw.write(chs, 0, chs.length);\n  //        fw.write(chs, 1, 3);\n\n          //void write(String str)：写一个字符串\n  //        fw.write("abcde");\n\n          //void write(String str, int off, int len)：写一个字符串的一部分\n  //        fw.write("abcde", 0, "abcde".length());\n          fw.write("abcde", 1, 3);\n\n          //释放资源\n          fw.close();\n      }\n  }\n  ```\n\n### 1.5字符流读数据【应用】\n\n+ 介绍\n\n  Reader: 用于读取字符流的抽象父类\n\n  FileReader: 用于读取字符流的常用子类\n\n\n+ 构造方法\n\n  | 方法名                         | 说明                                   |\n  | --------------------------- | ------------------------------------ |\n  | FileReader(File file)       | 在给定从中读取数据的 File 的情况下创建一个新 FileReader |\n  | FileReader(String fileName) | 在给定从中读取数据的文件名的情况下创建一个新 FileReader    |\n\n- 成员方法\n\n  | 方法名                   | 说明          |\n  | --------------------- | ----------- |\n  | int read()            | 一次读一个字符数据   |\n  | int read(char[] cbuf) | 一次读一个字符数组数据 |\n\n- 代码演示\n\n  ```java\n  public class InputStreamReaderDemo {\n      public static void main(String[] args) throws IOException {\n     \n          FileReader fr = new FileReader("myCharStream\\\\b.txt");\n\n          //int read()：一次读一个字符数据\n  //        int ch;\n  //        while ((ch=fr.read())!=-1) {\n  //            System.out.print((char)ch);\n  //        }\n\n          //int read(char[] cbuf)：一次读一个字符数组数据\n          char[] chs = new char[1024];\n          int len;\n          while ((len = fr.read(chs)) != -1) {\n              System.out.print(new String(chs, 0, len));\n          }\n\n          //释放资源\n          fr.close();\n      }\n  }\n  ```\n\n### 1.6字符流用户注册案例【应用】\n\n- 案例需求\n\n  将键盘录入的用户名和密码保存到本地实现永久化存储\n\n- 实现步骤\n  - 获取用户输入的用户名和密码\n  - 将用户输入的用户名和密码写入到本地文件中\n  - 关流,释放资源\n\n- 代码实现\n\n  ```java\n  public class CharStreamDemo8 {\n      public static void main(String[] args) throws IOException {\n          //需求: 将键盘录入的用户名和密码保存到本地实现永久化存储\n          //要求：用户名独占一行，密码独占一行\n\n          //分析：\n          //1，实现键盘录入，把用户名和密码录入进来\n          Scanner sc = new Scanner(System.in);\n          System.out.println("请录入用户名");\n          String username = sc.next();\n          System.out.println("请录入密码");\n          String password = sc.next();\n\n          //2.分别把用户名和密码写到本地文件。\n          FileWriter fw = new FileWriter("charstream\\\\a.txt");\n          //将用户名和密码写到文件中\n          fw.write(username);\n          //表示写出一个回车换行符 windows \\r\\n  MacOS \\r  Linux \\n\n          fw.write("\\r\\n");\n          fw.write(password);\n          //刷新流\n          fw.flush();\n          //3.关流,释放资源\n          fw.close();\n      }\n  }\n  ```\n\n### 1.7字符缓冲流【应用】\n\n- 字符缓冲流介绍\n\n  - BufferedWriter：将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途\n\n  - BufferedReader：从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。 默认值足够大，可用于大多数用途\n\n- 构造方法\n\n  | 方法名                        | 说明          |\n  | -------------------------- | ----------- |\n  | BufferedWriter(Writer out) | 创建字符缓冲输出流对象 |\n  | BufferedReader(Reader in)  | 创建字符缓冲输入流对象 |\n\n- 代码演示\n\n  ```java\n  public class BufferedStreamDemo01 {\n      public static void main(String[] args) throws IOException {\n          //BufferedWriter(Writer out)\n          BufferedWriter bw = new BufferedWriter(new                                                            FileWriter("myCharStream\\\\bw.txt"));\n          bw.write("hello\\r\\n");\n          bw.write("world\\r\\n");\n          bw.close();\n\n          //BufferedReader(Reader in)\n          BufferedReader br = new BufferedReader(new                                                           FileReader("myCharStream\\\\bw.txt"));\n\n          //一次读取一个字符数据\n  //        int ch;\n  //        while ((ch=br.read())!=-1) {\n  //            System.out.print((char)ch);\n  //        }\n\n          //一次读取一个字符数组数据\n          char[] chs = new char[1024];\n          int len;\n          while ((len=br.read(chs))!=-1) {\n              System.out.print(new String(chs,0,len));\n          }\n\n          br.close();\n      }\n  }\n  ```\n\n### 1.8字符缓冲流特有功能【应用】\n\n- 方法介绍\n\n  BufferedWriter：\n\n  | 方法名            | 说明                     |\n  | -------------- | ---------------------- |\n  | void newLine() | 写一行行分隔符，行分隔符字符串由系统属性定义 |\n\n  BufferedReader:\n\n  | 方法名               | 说明                                       |\n  | ----------------- | ---------------------------------------- |\n  | String readLine() | 读一行文字。 结果包含行的内容的字符串，不包括任何行终止字符如果流的结尾已经到达，则为null |\n\n- 代码演示\n\n  ```java\n  public class BufferedStreamDemo02 {\n      public static void main(String[] args) throws IOException {\n\n          //创建字符缓冲输出流\n          BufferedWriter bw = new BufferedWriter(new                                                          FileWriter("myCharStream\\\\bw.txt"));\n\n          //写数据\n          for (int i = 0; i < 10; i++) {\n              bw.write("hello" + i);\n              //bw.write("\\r\\n");\n              bw.newLine();\n              bw.flush();\n          }\n\n          //释放资源\n          bw.close();\n\n          //创建字符缓冲输入流\n          BufferedReader br = new BufferedReader(new                                                          FileReader("myCharStream\\\\bw.txt"));\n\n          String line;\n          while ((line=br.readLine())!=null) {\n              System.out.println(line);\n          }\n\n          br.close();\n      }\n  }\n  ```\n\n### 1.9字符缓冲流操作文件中数据排序案例【应用】\n\n- 案例需求\n\n  使用字符缓冲流读取文件中的数据，排序后再次写到本地文件\n\n- 实现步骤\n\n  - 将文件中的数据读取到程序中\n  - 对读取到的数据进行处理\n  - 将处理后的数据添加到集合中\n  - 对集合中的数据进行排序\n  - 将排序后的集合中的数据写入到文件中\n\n- 代码实现\n\n  ```java\n  public class CharStreamDemo14 {\n      public static void main(String[] args) throws IOException {\n          //需求：读取文件中的数据，排序后再次写到本地文件\n          //分析：\n          //1.要把文件中的数据读取进来。\n          BufferedReader br = new BufferedReader(new FileReader("charstream\\\\sort.txt"));\n          //输出流一定不能写在这里，因为会清空文件中的内容\n          //BufferedWriter bw = new BufferedWriter(new FileWriter("charstream\\\\sort.txt"));\n\n          String line = br.readLine();\n          System.out.println("读取到的数据为" + line);\n          br.close();\n\n          //2.按照空格进行切割\n          String[] split = line.split(" ");//9 1 2 5 3 10 4 6 7 8\n          //3.把字符串类型的数组变成int类型\n          int [] arr = new int[split.length];\n          //遍历split数组，可以进行类型转换。\n          for (int i = 0; i < split.length; i++) {\n              String smallStr = split[i];\n              //类型转换\n              int number = Integer.parseInt(smallStr);\n              //把转换后的结果存入到arr中\n              arr[i] = number;\n          }\n          //4.排序\n          Arrays.sort(arr);\n          System.out.println(Arrays.toString(arr));\n\n          //5.把排序之后结果写回到本地 1 2 3 4...\n          BufferedWriter bw = new BufferedWriter(new FileWriter("charstream\\\\sort.txt"));\n          //写出\n          for (int i = 0; i < arr.length; i++) {\n              bw.write(arr[i] + " ");\n              bw.flush();\n          }\n          //释放资源\n          bw.close();\n\n      }\n  }\n  ```\n\n### 1.10IO流小结【理解】\n\n+ IO流小结\n\n  ![01_IO流小结](./img/java/basics/day20-IO流02.img/01_IO流小结.png)\n\n\n## 2.转换流\n\n### 2.1字符流中和编码解码问题相关的两个类【理解】\n\n- InputStreamReader：是从字节流到字符流的桥梁,父类是Reader\n\n  ​\t它读取字节，并使用指定的编码将其解码为字符\n\n  ​\t它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集\n\n- OutputStreamWriter：是从字符流到字节流的桥梁,父类是Writer\n\n  ​\t是从字符流到字节流的桥梁，使用指定的编码将写入的字符编码为字节\n\n  ​\t它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集\n\n### 2.2转换流读写数据【应用】\n\n+ 构造方法\n\n  | 方法名                                      | 说明                              |\n  | ---------------------------------------- | ------------------------------- |\n  | InputStreamReader(InputStream in)        | 使用默认字符编码创建InputStreamReader对象   |\n  | InputStreamReader(InputStream in,String chatset) | 使用指定的字符编码创建InputStreamReader对象  |\n  | OutputStreamWriter(OutputStream out)     | 使用默认字符编码创建OutputStreamWriter对象  |\n  | OutputStreamWriter(OutputStream out,String charset) | 使用指定的字符编码创建OutputStreamWriter对象 |\n\n+ 代码演示\n\n  ```java\n  public class ConversionStreamDemo {\n      public static void main(String[] args) throws IOException {\n          //OutputStreamWriter osw = new OutputStreamWriter(new                                             FileOutputStream("myCharStream\\\\osw.txt"));\n          OutputStreamWriter osw = new OutputStreamWriter(new                                              FileOutputStream("myCharStream\\\\osw.txt"),"GBK");\n          osw.write("中国");\n          osw.close();\n\n          //InputStreamReader isr = new InputStreamReader(new \t                                         FileInputStream("myCharStream\\\\osw.txt"));\n          InputStreamReader isr = new InputStreamReader(new                                                 FileInputStream("myCharStream\\\\osw.txt"),"GBK");\n          //一次读取一个字符数据\n          int ch;\n          while ((ch=isr.read())!=-1) {\n              System.out.print((char)ch);\n          }\n          isr.close();\n      }\n  }\n  ```\n\n## 3.对象操作流\n\n### 3.1对象序列化流【应用】\n\n- 对象序列化介绍\n\n  - 对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象\n  - 这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象中存储的属性等信息\n  - 字节序列写到文件之后，相当于文件中持久保存了一个对象的信息\n  - 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化\n\n- 对象序列化流： ObjectOutputStream\n\n  - 将Java对象的原始数据类型和图形写入OutputStream。 可以使用ObjectInputStream读取（重构）对象。 可以通过使用流的文件来实现对象的持久存储。 如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象 \n\n- 构造方法\n\n  | 方法名                                  | 说明                                       |\n  | ------------------------------------ | ---------------------------------------- |\n  | ObjectOutputStream(OutputStream out) | 创建一个写入指定的OutputStream的ObjectOutputStream |\n\n- 序列化对象的方法\n\n  | 方法名                          | 说明                         |\n  | ---------------------------- | -------------------------- |\n  | void writeObject(Object obj) | 将指定的对象写入ObjectOutputStream |\n\n- 示例代码\n\n  学生类\n\n  ```java\n  public class Student implements Serializable {\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public String toString() {\n          return "Student{" +\n                  "name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class ObjectOutputStreamDemo {\n      public static void main(String[] args) throws IOException {\n          //ObjectOutputStream(OutputStream out)：创建一个写入指定的OutputStream的ObjectOutputStream\n          ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("myOtherStream\\\\oos.txt"));\n\n          //创建对象\n          Student s = new Student("佟丽娅",30);\n\n          //void writeObject(Object obj)：将指定的对象写入ObjectOutputStream\n          oos.writeObject(s);\n\n          //释放资源\n          oos.close();\n      }\n  }\n  ```\n\n- 注意事项\n\n  - 一个对象要想被序列化，该对象所属的类必须必须实现Serializable 接口\n  - Serializable是一个标记接口，实现该接口，不需要重写任何方法\n\n### 3.2对象反序列化流【应用】\n\n- 对象反序列化流： ObjectInputStream\n\n  - ObjectInputStream反序列化先前使用ObjectOutputStream编写的原始数据和对象\n\n- 构造方法\n\n  | 方法名                               | 说明                                    |\n  | --------------------------------- | ------------------------------------- |\n  | ObjectInputStream(InputStream in) | 创建从指定的InputStream读取的ObjectInputStream |\n\n- 反序列化对象的方法\n\n  | 方法名                 | 说明                       |\n  | ------------------- | ------------------------ |\n  | Object readObject() | 从ObjectInputStream读取一个对象 |\n\n- 示例代码\n\n  ```java\n  public class ObjectInputStreamDemo {\n      public static void main(String[] args) throws IOException, ClassNotFoundException {\n          //ObjectInputStream(InputStream in)：创建从指定的InputStream读取的ObjectInputStream\n          ObjectInputStream ois = new ObjectInputStream(new FileInputStream("myOtherStream\\\\oos.txt"));\n\n          //Object readObject()：从ObjectInputStream读取一个对象\n          Object obj = ois.readObject();\n\n          Student s = (Student) obj;\n          System.out.println(s.getName() + "," + s.getAge());\n\n          ois.close();\n      }\n  }\n  ```\n\n### 3.3serialVersionUID&transient【应用】\n\n- serialVersionUID\n\n  - 用对象序列化流序列化了一个对象后，假如我们修改了对象所属的类文件，读取数据会不会出问题呢？\n    - 会出问题，会抛出InvalidClassException异常\n  - 如果出问题了，如何解决呢？\n    - 重新序列化\n    - 给对象所属的类加一个serialVersionUID \n      - private static final long serialVersionUID = 42L;\n\n- transient\n\n  - 如果一个对象中的某个成员变量的值不想被序列化，又该如何实现呢？\n    - 给该成员变量加transient关键字修饰，该关键字标记的成员变量不参与序列化过程\n\n- 示例代码\n\n  学生类\n\n  ```java\n  public class Student implements Serializable {\n      private static final long serialVersionUID = 42L;\n      private String name;\n  //    private int age;\n      private transient int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n  //    @Override\n  //    public String toString() {\n  //        return "Student{" +\n  //                "name=\'" + name + \'\\\'\' +\n  //                ", age=" + age +\n  //                \'}\';\n  //    }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class ObjectStreamDemo {\n      public static void main(String[] args) throws IOException, ClassNotFoundException {\n  //        write();\n          read();\n      }\n\n      //反序列化\n      private static void read() throws IOException, ClassNotFoundException {\n          ObjectInputStream ois = new ObjectInputStream(new FileInputStream("myOtherStream\\\\oos.txt"));\n          Object obj = ois.readObject();\n          Student s = (Student) obj;\n          System.out.println(s.getName() + "," + s.getAge());\n          ois.close();\n      }\n\n      //序列化\n      private static void write() throws IOException {\n          ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("myOtherStream\\\\oos.txt"));\n          Student s = new Student("佟丽娅", 30);\n          oos.writeObject(s);\n          oos.close();\n      }\n  }\n  ```\n\n### 3.4对象操作流练习【应用】\n\n- 案例需求\n\n  创建多个学生类对象写到文件中,再次读取到内存中\n\n- 实现步骤\n\n  - 创建序列化流对象\n  - 创建多个学生对象\n  - 将学生对象添加到集合中\n  - 将集合对象序列化到文件中\n  - 创建反序列化流对象\n  - 将文件中的对象数据,读取到内存中\n\n- 代码实现\n\n  学生类\n\n  ```java\n  public class Student implements Serializable{\n      \n      private static final long serialVersionUID = 2L;\n\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class Demo03 {\n      /**\n       *  read():\n       *      读取到文件末尾返回值是 -1\n       *  readLine():\n       *      读取到文件的末尾返回值 null\n       *  readObject():\n       *      读取到文件的末尾 直接抛出异常\n       *  如果要序列化的对象有多个,不建议直接将多个对象序列化到文件中,因为反序列化时容易出异常\n       *      建议: 将要序列化的多个对象存储到集合中,然后将集合序列化到文件中\n       */\n      public static void main(String[] args) throws Exception {\n          /*// 序列化\n          //1.创建序列化流对象\n          ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("myCode\\\\oos.txt"));\n          ArrayList<Student> arrayList = new ArrayList<>();\n          //2.创建多个学生对象\n          Student s = new Student("佟丽娅",30);\n          Student s01 = new Student("佟丽娅",30);\n          //3.将学生对象添加到集合中\n          arrayList.add(s);\n          arrayList.add(s01);\n          //4.将集合对象序列化到文件中\n          oos.writeObject(arrayList);\n          oos.close();*/\n\n          // 反序列化\n        \t//5.创建反序列化流对象\n          ObjectInputStream ois = new ObjectInputStream(new FileInputStream("myCode\\\\oos.txt"));\n        \t//6.将文件中的对象数据,读取到内存中\n          Object obj = ois.readObject();\n          ArrayList<Student> arrayList = (ArrayList<Student>)obj;\n          ois.close();\n          for (Student s : arrayList) {\n              System.out.println(s.getName() + "," + s.getAge());\n          }\n      }\n  }\n  ```\n\n## 4.Properties集合\n\n### 4.1Properties作为Map集合的使用【应用】\n\n- Properties介绍\n\n  - 是一个Map体系的集合类\n  - Properties可以保存到流中或从流中加载\n  - 属性列表中的每个键及其对应的值都是一个字符串\n\n- Properties基本使用\n\n  ```java\n  public class PropertiesDemo01 {\n      public static void main(String[] args) {\n          //创建集合对象\n  //        Properties<String,String> prop = new Properties<String,String>(); //错误\n          Properties prop = new Properties();\n\n          //存储元素\n          prop.put("itheima001", "佟丽娅");\n          prop.put("itheima002", "赵丽颖");\n          prop.put("itheima003", "刘诗诗");\n\n          //遍历集合\n          Set<Object> keySet = prop.keySet();\n          for (Object key : keySet) {\n              Object value = prop.get(key);\n              System.out.println(key + "," + value);\n          }\n      }\n  }\n  ```\n\n### 4.2Properties作为Map集合的特有方法【应用】\n\n- 特有方法\n\n  | 方法名                                      | 说明                                       |\n  | ---------------------------------------- | ---------------------------------------- |\n  | Object   setProperty(String key, String value) | 设置集合的键和值，都是String类型，底层调用   Hashtable方法 put |\n  | String   getProperty(String key)         | 使用此属性列表中指定的键搜索属性                         |\n  | Set<String>   stringPropertyNames()      | 从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串         |\n\n- 示例代码\n\n  ```java\n  public class PropertiesDemo02 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Properties prop = new Properties();\n\n          //Object setProperty(String key, String value)：设置集合的键和值，都是String类型\n          prop.setProperty("itheima001", "佟丽娅");\n          prop.setProperty("itheima002", "赵丽颖");\n          prop.setProperty("itheima003", "刘诗诗");\n\n          //String getProperty(String key)：使用此属性列表中指定的键搜索属性\n  //        System.out.println(prop.getProperty("itheima001"));\n  //        System.out.println(prop.getProperty("itheima0011"));\n\n  //        System.out.println(prop);\n\n          //Set<String> stringPropertyNames()：从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串\n          Set<String> names = prop.stringPropertyNames();\n          for (String key : names) {\n  //            System.out.println(key);\n              String value = prop.getProperty(key);\n              System.out.println(key + "," + value);\n          }\n      }\n  }\n  ```\n\n### 4.3Properties和IO流相结合的方法【应用】\n\n- 和IO流结合的方法\n\n  | 方法名                                      | 说明                                       |\n  | ---------------------------------------- | ---------------------------------------- |\n  | void   load(Reader reader)               | 从输入字符流读取属性列表（键和元素对）                      |\n  | void   store(Writer writer, String comments) | 将此属性列表（键和元素对）写入此   Properties表中，以适合使用   load(Reader)方法的格式写入输出字符流 |\n\n- 示例代码\n\n  ```java\n  public class PropertiesDemo03 {\n      public static void main(String[] args) throws IOException {\n          //把集合中的数据保存到文件\n  //        myStore();\n\n          //把文件中的数据加载到集合\n          myLoad();\n\n      }\n\n      private static void myLoad() throws IOException {\n          Properties prop = new Properties();\n\n          //void load(Reader reader)：\n          FileReader fr = new FileReader("myOtherStream\\\\fw.txt");\n          prop.load(fr);\n          fr.close();\n\n          System.out.println(prop);\n      }\n\n      private static void myStore() throws IOException {\n          Properties prop = new Properties();\n\n          prop.setProperty("itheima001","佟丽娅");\n          prop.setProperty("itheima002","赵丽颖");\n          prop.setProperty("itheima003","刘诗诗");\n\n          //void store(Writer writer, String comments)：\n          FileWriter fw = new FileWriter("myOtherStream\\\\fw.txt");\n          prop.store(fw,null);\n          fw.close();\n      }\n  }\n  ```\n\n### 4.4Properties集合练习【应用】\n\n- 案例需求\n\n  在Properties文件中手动写上姓名和年龄,读取到集合中,将该数据封装成学生对象,写到本地文件\n\n- 实现步骤\n\n  - 创建Properties集合,将本地文件中的数据加载到集合中\n  - 获取集合中的键值对数据,封装到学生对象中\n  - 创建序列化流对象,将学生对象序列化到本地文件中\n\n- 代码实现\n\n  学生类\n\n  ```java\n  public class Student implements Serializable {\n      private static final long serialVersionUID = 1L;\n\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public String toString() {\n          return "Student{" +\n                  "name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class Test {\n\n      public static void main(String[] args) throws IOException {\n        \t//1.创建Properties集合,将本地文件中的数据加载到集合中\n          Properties prop = new Properties();\n          FileReader fr = new FileReader("prop.properties");\n          prop.load(fr);\n          fr.close();\n  \t\t//2.获取集合中的键值对数据,封装到学生对象中\n          String name = prop.getProperty("name");\n          int age = Integer.parseInt(prop.getProperty("age"));\n          Student s = new Student(name,age);\n  \t\t//3.创建序列化流对象,将学生对象序列化到本地文件中\n          ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("a.txt"));\n          oos.writeObject(s);\n          oos.close();\n      }\n  }\n  ```\n\n\n\n\n',Pn={data:function(){return{MainComponent1:An,MainComponent2:On}}},Ln=Pn,qn=Object(d["a"])(Ln,Rn,Mn,!1,null,"6037173d",null),kn=qn.exports,Bn=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent1}}),t("q-markdown",{attrs:{src:n.MainComponent2}})],1)},_n=[],Fn='\x3c!--\n * @Date           : 2021-04-27 00:32:23\n * @FilePath       : /jinnian-space/src/pages/java/module/basics/md/day21-多线程01.md\n * @Description    : \n--\x3e\n## 1.实现多线程\n\n### 1.1简单了解多线程【理解】\n\n是指从软件或者硬件上实现多个线程并发执行的技术。\n具有多线程能力的计算机因有硬件支持而能够在同一时间执行多个线程，提升性能。\n\n![01_简单了解多线程](./img/java/basics/day21-多线程01.img/01_简单了解多线程.png)\n\n### 1.2并发和并行【理解】\n\n+ 并行：在同一时刻，有多个指令在多个CPU上同时执行。\n\n  ![02_并行](./img/java/basics/day21-多线程01.img/02_并行.png)\n\n+ 并发：在同一时刻，有多个指令在单个CPU上交替执行。\n\n  ![03_并发](./img/java/basics/day21-多线程01.img/03_并发.png)\n\n### 1.3进程和线程【理解】\n\n- 进程：是正在运行的程序\n\n  独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位\n  动态性：进程的实质是程序的一次执行过程，进程是动态产生，动态消亡的\n  并发性：任何进程都可以同其他进程一起并发执行\n\n- 线程：是进程中的单个顺序控制流，是一条执行路径\n\n  ​\t单线程：一个进程如果只有一条执行路径，则称为单线程程序\n\n  ​\t多线程：一个进程如果有多条执行路径，则称为多线程程序\n\n  ​\t![04_多线程示例](./img/java/basics/day21-多线程01.img/04_多线程示例.png)\n\n### 1.4实现多线程方式一：继承Thread类【应用】\n\n- 方法介绍\n\n  | 方法名          | 说明                         |\n  | ------------ | -------------------------- |\n  | void run()   | 在线程开启后，此方法将被调用执行           |\n  | void start() | 使此线程开始执行，Java虚拟机会调用run方法() |\n\n- 实现步骤\n  - 定义一个类MyThread继承Thread类\n  - 在MyThread类中重写run()方法\n  - 创建MyThread类的对象\n  - 启动线程\n\n- 代码演示\n\n  ```java\n  public class MyThread extends Thread {\n      @Override\n      public void run() {\n          for(int i=0; i<100; i++) {\n              System.out.println(i);\n          }\n      }\n  }\n  public class MyThreadDemo {\n      public static void main(String[] args) {\n          MyThread my1 = new MyThread();\n          MyThread my2 = new MyThread();\n\n  //        my1.run();\n  //        my2.run();\n\n          //void start() 导致此线程开始执行; Java虚拟机调用此线程的run方法\n          my1.start();\n          my2.start();\n      }\n  }\n  ```\n\n- 两个小问题\n\n  - 为什么要重写run()方法？\n\n    因为run()是用来封装被线程执行的代码\n\n  - run()方法和start()方法的区别？\n\n    run()：封装线程执行的代码，直接调用，相当于普通方法的调用\n\n    start()：启动线程；然后由JVM调用此线程的run()方法\n\n### 1.5实现多线程方式二：实现Runnable接口【应用】\n\n- Thread构造方法\n\n  | 方法名                                  | 说明             |\n  | ------------------------------------ | -------------- |\n  | Thread(Runnable target)              | 分配一个新的Thread对象 |\n  | Thread(Runnable target, String name) | 分配一个新的Thread对象 |\n\n- 实现步骤\n\n  - 定义一个类MyRunnable实现Runnable接口\n  - 在MyRunnable类中重写run()方法\n  - 创建MyRunnable类的对象\n  - 创建Thread类的对象，把MyRunnable对象作为构造方法的参数\n  - 启动线程\n\n- 代码演示\n\n  ```java\n  public class MyRunnable implements Runnable {\n      @Override\n      public void run() {\n          for(int i=0; i<100; i++) {\n              System.out.println(Thread.currentThread().getName()+":"+i);\n          }\n      }\n  }\n  public class MyRunnableDemo {\n      public static void main(String[] args) {\n          //创建MyRunnable类的对象\n          MyRunnable my = new MyRunnable();\n\n          //创建Thread类的对象，把MyRunnable对象作为构造方法的参数\n          //Thread(Runnable target)\n  //        Thread t1 = new Thread(my);\n  //        Thread t2 = new Thread(my);\n          //Thread(Runnable target, String name)\n          Thread t1 = new Thread(my,"坦克");\n          Thread t2 = new Thread(my,"飞机");\n\n          //启动线程\n          t1.start();\n          t2.start();\n      }\n  }\n  ```\n\n### 1.6实现多线程方式三: 实现Callable接口【应用】\n\n+ 方法介绍\n\n  | 方法名                              | 说明                                  |\n  | -------------------------------- | ----------------------------------- |\n  | V call()                         | 计算结果，如果无法计算结果，则抛出一个异常               |\n  | FutureTask(Callable<V> callable) | 创建一个 FutureTask，一旦运行就执行给定的 Callable |\n  | V get()                          | 如有必要，等待计算完成，然后获取其结果                 |\n\n+ 实现步骤\n\n  + 定义一个类MyCallable实现Callable接口\n  + 在MyCallable类中重写call()方法\n  + 创建MyCallable类的对象\n  + 创建Future的实现类FutureTask对象，把MyCallable对象作为构造方法的参数\n  + 创建Thread类的对象，把FutureTask对象作为构造方法的参数\n  + 启动线程\n  + 再调用get方法，就可以获取线程结束之后的结果。\n\n+ 代码演示\n\n  ```java\n  public class MyCallable implements Callable<String> {\n      @Override\n      public String call() throws Exception {\n          for (int i = 0; i < 100; i++) {\n              System.out.println("跟女孩表白" + i);\n          }\n          //返回值就表示线程运行完毕之后的结果\n          return "答应";\n      }\n  }\n  public class Demo {\n      public static void main(String[] args) throws ExecutionException, InterruptedException {\n          //线程开启之后需要执行里面的call方法\n          MyCallable mc = new MyCallable();\n\n          //Thread t1 = new Thread(mc);\n\n          //可以获取线程执行完毕之后的结果.也可以作为参数传递给Thread对象\n          FutureTask<String> ft = new FutureTask<>(mc);\n\n          //创建线程对象\n          Thread t1 = new Thread(ft);\n\n          String s = ft.get();\n          //开启线程\n          t1.start();\n\n          //String s = ft.get();\n          System.out.println(s);\n      }\n  }\n  ```\n\n+ 三种实现方式的对比\n  + 实现Runnable、Callable接口\n    + 好处: 扩展性强，实现该接口的同时还可以继承其他的类\n    + 缺点: 编程相对复杂，不能直接使用Thread类中的方法\n  + 继承Thread类\n    + 好处: 编程比较简单，可以直接使用Thread类中的方法\n    + 缺点: 可以扩展性较差，不能再继承其他的类\n\n### 1.7设置和获取线程名称【应用】\n\n- 方法介绍\n\n  | 方法名                        | 说明                 |\n  | -------------------------- | ------------------ |\n  | void  setName(String name) | 将此线程的名称更改为等于参数name |\n  | String  getName()          | 返回此线程的名称           |\n  | Thread  currentThread()    | 返回对当前正在执行的线程对象的引用  |\n\n- 代码演示\n\n  ```java\n  public class MyThread extends Thread {\n      public MyThread() {}\n      public MyThread(String name) {\n          super(name);\n      }\n\n      @Override\n      public void run() {\n          for (int i = 0; i < 100; i++) {\n              System.out.println(getName()+":"+i);\n          }\n      }\n  }\n  public class MyThreadDemo {\n      public static void main(String[] args) {\n          MyThread my1 = new MyThread();\n          MyThread my2 = new MyThread();\n\n          //void setName(String name)：将此线程的名称更改为等于参数 name\n          my1.setName("高铁");\n          my2.setName("飞机");\n\n          //Thread(String name)\n          MyThread my1 = new MyThread("高铁");\n          MyThread my2 = new MyThread("飞机");\n\n          my1.start();\n          my2.start();\n\n          //static Thread currentThread() 返回对当前正在执行的线程对象的引用\n          System.out.println(Thread.currentThread().getName());\n      }\n  }\n  ```\n\n### 1.8线程休眠【应用】\n\n+ 相关方法\n\n  | 方法名                            | 说明                       |\n  | ------------------------------ | ------------------------ |\n  | static void sleep(long millis) | 使当前正在执行的线程停留（暂停执行）指定的毫秒数 |\n\n+ 代码演示\n\n  ```java\n  public class MyRunnable implements Runnable {\n      @Override\n      public void run() {\n          for (int i = 0; i < 100; i++) {\n              try {\n                  Thread.sleep(100);\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n\n              System.out.println(Thread.currentThread().getName() + "---" + i);\n          }\n      }\n  }\n  public class Demo {\n      public static void main(String[] args) throws InterruptedException {\n          /*System.out.println("睡觉前");\n          Thread.sleep(3000);\n          System.out.println("睡醒了");*/\n\n          MyRunnable mr = new MyRunnable();\n\n          Thread t1 = new Thread(mr);\n          Thread t2 = new Thread(mr);\n\n          t1.start();\n          t2.start();\n      }\n  }\n  ```\n\n### 1.9线程优先级【应用】\n\n- 线程调度\n\n  - 两种调度方式\n    - 分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片\n    - 抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些\n\n  - Java使用的是抢占式调度模型\n\n  - 随机性\n\n    假如计算机只有一个 CPU，那么 CPU 在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。所以说多线程程序的执行是有随机性，因为谁抢到CPU的使用权是不一定的\n\n    ![05_多线程示例图](./img/java/basics/day21-多线程01.img/05_多线程示例图.png)\n\n- 优先级相关方法\n\n  | 方法名                                     | 说明                                |\n  | --------------------------------------- | --------------------------------- |\n  | final int getPriority()                 | 返回此线程的优先级                         |\n  | final void setPriority(int newPriority) | 更改此线程的优先级线程默认优先级是5；线程优先级的范围是：1-10 |\n\n- 代码演示\n\n  ```java\n  public class MyCallable implements Callable<String> {\n      @Override\n      public String call() throws Exception {\n          for (int i = 0; i < 100; i++) {\n              System.out.println(Thread.currentThread().getName() + "---" + i);\n          }\n          return "线程执行完毕了";\n      }\n  }\n  public class Demo {\n      public static void main(String[] args) {\n          //优先级: 1 - 10 默认值:5\n          MyCallable mc = new MyCallable();\n\n          FutureTask<String> ft = new FutureTask<>(mc);\n\n          Thread t1 = new Thread(ft);\n          t1.setName("飞机");\n          t1.setPriority(10);\n          //System.out.println(t1.getPriority());//5\n          t1.start();\n\n          MyCallable mc2 = new MyCallable();\n\n          FutureTask<String> ft2 = new FutureTask<>(mc2);\n\n          Thread t2 = new Thread(ft2);\n          t2.setName("坦克");\n          t2.setPriority(1);\n          //System.out.println(t2.getPriority());//5\n          t2.start();\n      }\n  }\n  ```\n\n### 1.10守护线程【应用】\n\n- 相关方法\n\n  | 方法名                        | 说明                                   |\n  | -------------------------- | ------------------------------------ |\n  | void setDaemon(boolean on) | 将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出 |\n\n- 代码演示\n\n  ```java\n  public class MyThread1 extends Thread {\n      @Override\n      public void run() {\n          for (int i = 0; i < 10; i++) {\n              System.out.println(getName() + "---" + i);\n          }\n      }\n  }\n  public class MyThread2 extends Thread {\n      @Override\n      public void run() {\n          for (int i = 0; i < 100; i++) {\n              System.out.println(getName() + "---" + i);\n          }\n      }\n  }\n  public class Demo {\n      public static void main(String[] args) {\n          MyThread1 t1 = new MyThread1();\n          MyThread2 t2 = new MyThread2();\n\n          t1.setName("女神");\n          t2.setName("备胎");\n\n          //把第二个线程设置为守护线程\n          //当普通线程执行完之后,那么守护线程也没有继续运行下去的必要了.\n          t2.setDaemon(true);\n\n          t1.start();\n          t2.start();\n      }\n  }\n  ```\n\n## 2.线程同步\n\n### 2.1卖票【应用】\n\n- 案例需求\n\n  某电影院目前正在上映国产大片，共有100张票，而它有3个窗口卖票，请设计一个程序模拟该电影院卖票\n\n- 实现步骤\n\n  - 定义一个类SellTicket实现Runnable接口，里面定义一个成员变量：private int tickets = 100;\n\n  - 在SellTicket类中重写run()方法实现卖票，代码步骤如下\n\n  - 判断票数大于0，就卖票，并告知是哪个窗口卖的\n  - 卖了票之后，总票数要减1\n  - 票卖没了，线程停止\n  - 定义一个测试类SellTicketDemo，里面有main方法，代码步骤如下\n  - 创建SellTicket类的对象\n  - 创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称\n  - 启动线程\n\n- 代码实现\n\n  ```java\n  public class SellTicket implements Runnable {\n      private int tickets = 100;\n      //在SellTicket类中重写run()方法实现卖票，代码步骤如下\n      @Override\n      public void run() {\n          while (true) {\n              if(ticket <= 0){\n                      //卖完了\n                      break;\n                  }else{\n                      try {\n                          Thread.sleep(100);\n                      } catch (InterruptedException e) {\n                          e.printStackTrace();\n                      }\n                      ticket--;\n                      System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticket + "张票");\n                  }\n          }\n      }\n  }\n  public class SellTicketDemo {\n      public static void main(String[] args) {\n          //创建SellTicket类的对象\n          SellTicket st = new SellTicket();\n\n          //创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称\n          Thread t1 = new Thread(st,"窗口1");\n          Thread t2 = new Thread(st,"窗口2");\n          Thread t3 = new Thread(st,"窗口3");\n\n          //启动线程\n          t1.start();\n          t2.start();\n          t3.start();\n      }\n  }\n  ```\n\n\n### 2.2卖票案例的问题【理解】\n\n- 卖票出现了问题\n\n  - 相同的票出现了多次\n\n  - 出现了负数的票\n\n- 问题产生原因\n\n  线程执行的随机性导致的,可能在卖票过程中丢失cpu的执行权,导致出现问题\n\n\n### 2.3同步代码块解决数据安全问题【应用】\n\n- 安全问题出现的条件\n\n  - 是多线程环境\n\n  - 有共享数据\n\n  - 有多条语句操作共享数据\n\n- 如何解决多线程安全问题呢?\n\n  - 基本思想：让程序没有安全问题的环境\n\n- 怎么实现呢?\n\n  - 把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可\n\n  - Java提供了同步代码块的方式来解决\n\n- 同步代码块格式：\n\n  ```java\n  synchronized(任意对象) { \n  \t多条语句操作共享数据的代码 \n  }\n  ```\n\n  synchronized(任意对象)：就相当于给代码加锁了，任意对象就可以看成是一把锁\n\n- 同步的好处和弊端  \n\n  - 好处：解决了多线程的数据安全问题\n\n  - 弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率\n\n- 代码演示\n\n  ```java\n  public class SellTicket implements Runnable {\n      private int tickets = 100;\n      private Object obj = new Object();\n\n      @Override\n      public void run() {\n          while (true) {\n              synchronized (obj) { // 对可能有安全问题的代码加锁,多个线程必须使用同一把锁\n                  //t1进来后，就会把这段代码给锁起来\n                  if (tickets > 0) {\n                      try {\n                          Thread.sleep(100);\n                          //t1休息100毫秒\n                      } catch (InterruptedException e) {\n                          e.printStackTrace();\n                      }\n                      //窗口1正在出售第100张票\n                      System.out.println(Thread.currentThread().getName() + "正在出售第" + tickets + "张票");\n                      tickets--; //tickets = 99;\n                  }\n              }\n              //t1出来了，这段代码的锁就被释放了\n          }\n      }\n  }\n\n  public class SellTicketDemo {\n      public static void main(String[] args) {\n          SellTicket st = new SellTicket();\n\n          Thread t1 = new Thread(st, "窗口1");\n          Thread t2 = new Thread(st, "窗口2");\n          Thread t3 = new Thread(st, "窗口3");\n\n          t1.start();\n          t2.start();\n          t3.start();\n      }\n  }\n  ```\n\n### 2.4同步方法解决数据安全问题【应用】\n\n- 同步方法的格式\n\n  同步方法：就是把synchronized关键字加到方法上\n\n  ```java\n  修饰符 synchronized 返回值类型 方法名(方法参数) { \n  \t方法体；\n  }\n  ```\n\n  同步方法的锁对象是什么呢?\n\n  ​\tthis\n\n- 静态同步方法\n\n  同步静态方法：就是把synchronized关键字加到静态方法上\n\n  ```java\n  修饰符 static synchronized 返回值类型 方法名(方法参数) { \n  \t方法体；\n  }\n  ```\n\n  同步静态方法的锁对象是什么呢?\n\n  ​\t类名.class\n\n- 代码演示\n\n  ```java\n  public class MyRunnable implements Runnable {\n      private static int ticketCount = 100;\n\n      @Override\n      public void run() {\n          while(true){\n              if("窗口一".equals(Thread.currentThread().getName())){\n                  //同步方法\n                  boolean result = synchronizedMthod();\n                  if(result){\n                      break;\n                  }\n              }\n\n              if("窗口二".equals(Thread.currentThread().getName())){\n                  //同步代码块\n                  synchronized (MyRunnable.class){\n                      if(ticketCount == 0){\n                         break;\n                      }else{\n                          try {\n                              Thread.sleep(10);\n                          } catch (InterruptedException e) {\n                              e.printStackTrace();\n                          }\n                          ticketCount--;\n                          System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticketCount + "张票");\n                      }\n                  }\n              }\n\n          }\n      }\n\n      private static synchronized boolean synchronizedMthod() {\n          if(ticketCount == 0){\n              return true;\n          }else{\n              try {\n                  Thread.sleep(10);\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n              ticketCount--;\n              System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticketCount + "张票");\n              return false;\n          }\n      }\n  }\n\n\n  public class Demo {\n      public static void main(String[] args) {\n          MyRunnable mr = new MyRunnable();\n\n          Thread t1 = new Thread(mr);\n          Thread t2 = new Thread(mr);\n\n          t1.setName("窗口一");\n          t2.setName("窗口二");\n\n          t1.start();\n          t2.start();\n      }\n  }\n  ```\n\n\n### 2.5Lock锁【应用】\n\n虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock\n\nLock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化\n\n- ReentrantLock构造方法\n\n  | 方法名             | 说明                   |\n  | --------------- | -------------------- |\n  | ReentrantLock() | 创建一个ReentrantLock的实例 |\n\n- 加锁解锁方法\n\n  | 方法名           | 说明   |\n  | ------------- | ---- |\n  | void lock()   | 获得锁  |\n  | void unlock() | 释放锁  |\n\n- 代码演示\n\n  ```java\n  public class Ticket implements Runnable {\n      //票的数量\n      private int ticket = 100;\n      private Object obj = new Object();\n      private ReentrantLock lock = new ReentrantLock();\n\n      @Override\n      public void run() {\n          while (true) {\n              //synchronized (obj){//多个线程必须使用同一把锁.\n              try {\n                  lock.lock();\n                  if (ticket <= 0) {\n                      //卖完了\n                      break;\n                  } else {\n                      Thread.sleep(100);\n                      ticket--;\n                      System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticket + "张票");\n                  }\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              } finally {\n                  lock.unlock();\n              }\n              // }\n          }\n      }\n  }\n\n  public class Demo {\n      public static void main(String[] args) {\n          Ticket ticket = new Ticket();\n\n          Thread t1 = new Thread(ticket);\n          Thread t2 = new Thread(ticket);\n          Thread t3 = new Thread(ticket);\n\n          t1.setName("窗口一");\n          t2.setName("窗口二");\n          t3.setName("窗口三");\n\n          t1.start();\n          t2.start();\n          t3.start();\n      }\n  }\n  ```\n\n### 2.6死锁【理解】\n\n+ 概述\n\n  线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行\n\n+ 什么情况下会产生死锁\n\n  1. 资源有限\n  2. 同步嵌套\n\n+ 代码演示\n\n  ```java\n  public class Demo {\n      public static void main(String[] args) {\n          Object objA = new Object();\n          Object objB = new Object();\n\n          new Thread(()->{\n              while(true){\n                  synchronized (objA){\n                      //线程一\n                      synchronized (objB){\n                          System.out.println("小康同学正在走路");\n                      }\n                  }\n              }\n          }).start();\n\n          new Thread(()->{\n              while(true){\n                  synchronized (objB){\n                      //线程二\n                      synchronized (objA){\n                          System.out.println("小薇同学正在走路");\n                      }\n                  }\n              }\n          }).start();\n      }\n  }\n  ```\n\n## 3.生产者消费者\n\n### 3.1生产者和消费者模式概述【应用】\n\n- 概述\n\n  生产者消费者模式是一个十分经典的多线程协作的模式，弄懂生产者消费者问题能够让我们对多线程编程的理解更加深刻。\n\n  所谓生产者消费者问题，实际上主要是包含了两类线程：\n\n  ​\t一类是生产者线程用于生产数据\n\n  ​\t一类是消费者线程用于消费数据\n\n  为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库\n\n  生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为\n\n  消费者只需要从共享数据区中去获取数据，并不需要关心生产者的行为\n\n- Object类的等待和唤醒方法\n\n  | 方法名              | 说明                                       |\n  | ---------------- | ---------------------------------------- |\n  | void wait()      | 导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法 |\n  | void notify()    | 唤醒正在等待对象监视器的单个线程                         |\n  | void notifyAll() | 唤醒正在等待对象监视器的所有线程                         |\n\n### 3.2生产者和消费者案例【应用】\n\n- 案例需求\n\n  + 桌子类(Desk)：定义表示包子数量的变量,定义锁对象变量,定义标记桌子上有无包子的变量\n\n  + 生产者类(Cooker)：实现Runnable接口，重写run()方法，设置线程任务\n\n      1.判断是否有包子,决定当前线程是否执行\n\n      2.如果有包子,就进入等待状态,如果没有包子,继续执行,生产包子\n\n      3.生产包子之后,更新桌子上包子状态,唤醒消费者消费包子\n\n  + 消费者类(Foodie)：实现Runnable接口，重写run()方法，设置线程任务\n\n      1.判断是否有包子,决定当前线程是否执行\n\n      2.如果没有包子,就进入等待状态,如果有包子,就消费包子\n\n      3.消费包子后,更新桌子上包子状态,唤醒生产者生产包子\n\n  + 测试类(Demo)：里面有main方法，main方法中的代码步骤如下\n\n      创建生产者线程和消费者线程对象\n\n      分别开启两个线程\n\n- 代码实现\n\n  ```java\n  public class Desk {\n\n      //定义一个标记\n      //true 就表示桌子上有汉堡包的,此时允许吃货执行\n      //false 就表示桌子上没有汉堡包的,此时允许厨师执行\n      public static boolean flag = false;\n\n      //汉堡包的总数量\n      public static int count = 10;\n\n      //锁对象\n      public static final Object lock = new Object();\n  }\n\n  public class Cooker extends Thread {\n  //    生产者步骤：\n  //            1，判断桌子上是否有汉堡包\n  //    如果有就等待，如果没有才生产。\n  //            2，把汉堡包放在桌子上。\n  //            3，叫醒等待的消费者开吃。\n      @Override\n      public void run() {\n          while(true){\n              synchronized (Desk.lock){\n                  if(Desk.count == 0){\n                      break;\n                  }else{\n                      if(!Desk.flag){\n                          //生产\n                          System.out.println("厨师正在生产汉堡包");\n                          Desk.flag = true;\n                          Desk.lock.notifyAll();\n                      }else{\n                          try {\n                              Desk.lock.wait();\n                          } catch (InterruptedException e) {\n                              e.printStackTrace();\n                          }\n                      }\n                  }\n              }\n          }\n      }\n  }\n\n  public class Foodie extends Thread {\n      @Override\n      public void run() {\n  //        1，判断桌子上是否有汉堡包。\n  //        2，如果没有就等待。\n  //        3，如果有就开吃\n  //        4，吃完之后，桌子上的汉堡包就没有了\n  //                叫醒等待的生产者继续生产\n  //        汉堡包的总数量减一\n\n          //套路:\n              //1. while(true)死循环\n              //2. synchronized 锁,锁对象要唯一\n              //3. 判断,共享数据是否结束. 结束\n              //4. 判断,共享数据是否结束. 没有结束\n          while(true){\n              synchronized (Desk.lock){\n                  if(Desk.count == 0){\n                      break;\n                  }else{\n                      if(Desk.flag){\n                          //有\n                          System.out.println("吃货在吃汉堡包");\n                          Desk.flag = false;\n                          Desk.lock.notifyAll();\n                          Desk.count--;\n                      }else{\n                          //没有就等待\n                          //使用什么对象当做锁,那么就必须用这个对象去调用等待和唤醒的方法.\n                          try {\n                              Desk.lock.wait();\n                          } catch (InterruptedException e) {\n                              e.printStackTrace();\n                          }\n                      }\n                  }\n              }\n          }\n\n      }\n  }\n\n  public class Demo {\n      public static void main(String[] args) {\n          /*消费者步骤：\n          1，判断桌子上是否有汉堡包。\n          2，如果没有就等待。\n          3，如果有就开吃\n          4，吃完之后，桌子上的汉堡包就没有了\n                  叫醒等待的生产者继续生产\n          汉堡包的总数量减一*/\n\n          /*生产者步骤：\n          1，判断桌子上是否有汉堡包\n          如果有就等待，如果没有才生产。\n          2，把汉堡包放在桌子上。\n          3，叫醒等待的消费者开吃。*/\n\n          Foodie f = new Foodie();\n          Cooker c = new Cooker();\n\n          f.start();\n          c.start();\n\n      }\n  }\n  ```\n\n### 3.3生产者和消费者案例优化【应用】\n\n+ 需求\n\n  + 将Desk类中的变量,采用面向对象的方式封装起来\n  + 生产者和消费者类中构造方法接收Desk类对象,之后在run方法中进行使用\n  + 创建生产者和消费者线程对象,构造方法中传入Desk类对象\n  + 开启两个线程\n\n+ 代码实现\n\n  ```java\n  public class Desk {\n\n      //定义一个标记\n      //true 就表示桌子上有汉堡包的,此时允许吃货执行\n      //false 就表示桌子上没有汉堡包的,此时允许厨师执行\n      //public static boolean flag = false;\n      private boolean flag;\n\n      //汉堡包的总数量\n      //public static int count = 10;\n      //以后我们在使用这种必须有默认值的变量\n     // private int count = 10;\n      private int count;\n\n      //锁对象\n      //public static final Object lock = new Object();\n      private final Object lock = new Object();\n\n      public Desk() {\n          this(false,10); // 在空参内部调用带参,对成员变量进行赋值,之后就可以直接使用成员变量了\n      }\n\n      public Desk(boolean flag, int count) {\n          this.flag = flag;\n          this.count = count;\n      }\n\n      public boolean isFlag() {\n          return flag;\n      }\n\n      public void setFlag(boolean flag) {\n          this.flag = flag;\n      }\n\n      public int getCount() {\n          return count;\n      }\n\n      public void setCount(int count) {\n          this.count = count;\n      }\n\n      public Object getLock() {\n          return lock;\n      }\n\n      @Override\n      public String toString() {\n          return "Desk{" +\n                  "flag=" + flag +\n                  ", count=" + count +\n                  ", lock=" + lock +\n                  \'}\';\n      }\n  }\n\n  public class Cooker extends Thread {\n\n      private Desk desk;\n\n      public Cooker(Desk desk) {\n          this.desk = desk;\n      }\n  //    生产者步骤：\n  //            1，判断桌子上是否有汉堡包\n  //    如果有就等待，如果没有才生产。\n  //            2，把汉堡包放在桌子上。\n  //            3，叫醒等待的消费者开吃。\n\n      @Override\n      public void run() {\n          while(true){\n              synchronized (desk.getLock()){\n                  if(desk.getCount() == 0){\n                      break;\n                  }else{\n                      //System.out.println("验证一下是否执行了");\n                      if(!desk.isFlag()){\n                          //生产\n                          System.out.println("厨师正在生产汉堡包");\n                          desk.setFlag(true);\n                          desk.getLock().notifyAll();\n                      }else{\n                          try {\n                              desk.getLock().wait();\n                          } catch (InterruptedException e) {\n                              e.printStackTrace();\n                          }\n                      }\n                  }\n              }\n          }\n      }\n  }\n\n  public class Foodie extends Thread {\n      private Desk desk;\n\n      public Foodie(Desk desk) {\n          this.desk = desk;\n      }\n\n      @Override\n      public void run() {\n  //        1，判断桌子上是否有汉堡包。\n  //        2，如果没有就等待。\n  //        3，如果有就开吃\n  //        4，吃完之后，桌子上的汉堡包就没有了\n  //                叫醒等待的生产者继续生产\n  //        汉堡包的总数量减一\n\n          //套路:\n              //1. while(true)死循环\n              //2. synchronized 锁,锁对象要唯一\n              //3. 判断,共享数据是否结束. 结束\n              //4. 判断,共享数据是否结束. 没有结束\n          while(true){\n              synchronized (desk.getLock()){\n                  if(desk.getCount() == 0){\n                      break;\n                  }else{\n                      //System.out.println("验证一下是否执行了");\n                      if(desk.isFlag()){\n                          //有\n                          System.out.println("吃货在吃汉堡包");\n                          desk.setFlag(false);\n                          desk.getLock().notifyAll();\n                          desk.setCount(desk.getCount() - 1);\n                      }else{\n                          //没有就等待\n                          //使用什么对象当做锁,那么就必须用这个对象去调用等待和唤醒的方法.\n                          try {\n                              desk.getLock().wait();\n                          } catch (InterruptedException e) {\n                              e.printStackTrace();\n                          }\n                      }\n                  }\n              }\n          }\n\n      }\n  }\n\n  public class Demo {\n      public static void main(String[] args) {\n          /*消费者步骤：\n          1，判断桌子上是否有汉堡包。\n          2，如果没有就等待。\n          3，如果有就开吃\n          4，吃完之后，桌子上的汉堡包就没有了\n                  叫醒等待的生产者继续生产\n          汉堡包的总数量减一*/\n\n          /*生产者步骤：\n          1，判断桌子上是否有汉堡包\n          如果有就等待，如果没有才生产。\n          2，把汉堡包放在桌子上。\n          3，叫醒等待的消费者开吃。*/\n\n          Desk desk = new Desk();\n\n          Foodie f = new Foodie(desk);\n          Cooker c = new Cooker(desk);\n\n          f.start();\n          c.start();\n\n      }\n  }\n  ```\n\n### 3.4阻塞队列基本使用【理解】\n\n+ 阻塞队列继承结构\n\n  ![06_阻塞队列继承结构](./img/java/basics/day21-多线程01.img/06_阻塞队列继承结构.png)\n\n\n+ 常见BlockingQueue:\n\n   ArrayBlockingQueue: 底层是数组,有界\n\n   LinkedBlockingQueue: 底层是链表,无界.但不是真正的无界,最大为int的最大值\n\n+ BlockingQueue的核心方法:\n\n   put(anObject): 将参数放入队列,如果放不进去会阻塞\n\n   take(): 取出第一个数据,取不到会阻塞\n\n+ 代码示例\n\n  ```java\n  public class Demo02 {\n      public static void main(String[] args) throws Exception {\n          // 创建阻塞队列的对象,容量为 1\n          ArrayBlockingQueue<String> arrayBlockingQueue = new ArrayBlockingQueue<>(1);\n\n          // 存储元素\n          arrayBlockingQueue.put("汉堡包");\n\n          // 取元素\n          System.out.println(arrayBlockingQueue.take());\n          System.out.println(arrayBlockingQueue.take()); // 取不到会阻塞\n\n          System.out.println("程序结束了");\n      }\n  }\n  ```\n\n### 3.5阻塞队列实现等待唤醒机制【理解】\n\n+ 案例需求\n\n  + 生产者类(Cooker)：实现Runnable接口，重写run()方法，设置线程任务\n\n      1.构造方法中接收一个阻塞队列对象\n\n      2.在run方法中循环向阻塞队列中添加包子\n\n      3.打印添加结果\n\n  + 消费者类(Foodie)：实现Runnable接口，重写run()方法，设置线程任务\n\n       1.构造方法中接收一个阻塞队列对象\n\n       2.在run方法中循环获取阻塞队列中的包子\n\n       3.打印获取结果\n\n  + 测试类(Demo)：里面有main方法，main方法中的代码步骤如下\n\n      创建阻塞队列对象\n\n      创建生产者线程和消费者线程对象,构造方法中传入阻塞队列对象\n\n      分别开启两个线程\n\n+ 代码实现\n\n  ```java\n  public class Cooker extends Thread {\n\n      private ArrayBlockingQueue<String> bd;\n\n      public Cooker(ArrayBlockingQueue<String> bd) {\n          this.bd = bd;\n      }\n  //    生产者步骤：\n  //            1，判断桌子上是否有汉堡包\n  //    如果有就等待，如果没有才生产。\n  //            2，把汉堡包放在桌子上。\n  //            3，叫醒等待的消费者开吃。\n\n      @Override\n      public void run() {\n          while (true) {\n              try {\n                  bd.put("汉堡包");\n                  System.out.println("厨师放入一个汉堡包");\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n          }\n      }\n  }\n\n  public class Foodie extends Thread {\n      private ArrayBlockingQueue<String> bd;\n\n      public Foodie(ArrayBlockingQueue<String> bd) {\n          this.bd = bd;\n      }\n\n      @Override\n      public void run() {\n  //        1，判断桌子上是否有汉堡包。\n  //        2，如果没有就等待。\n  //        3，如果有就开吃\n  //        4，吃完之后，桌子上的汉堡包就没有了\n  //                叫醒等待的生产者继续生产\n  //        汉堡包的总数量减一\n\n          //套路:\n          //1. while(true)死循环\n          //2. synchronized 锁,锁对象要唯一\n          //3. 判断,共享数据是否结束. 结束\n          //4. 判断,共享数据是否结束. 没有结束\n          while (true) {\n              try {\n                  String take = bd.take();\n                  System.out.println("吃货将" + take + "拿出来吃了");\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n          }\n\n      }\n  }\n\n  public class Demo {\n      public static void main(String[] args) {\n          ArrayBlockingQueue<String> bd = new ArrayBlockingQueue<>(1);\n\n          Foodie f = new Foodie(bd);\n          Cooker c = new Cooker(bd);\n\n          f.start();\n          c.start();\n      }\n  }\n  ```\n\n  ​\n\n\n\n',Hn='## 1.线程池\n\n### 1.1 线程状态介绍\n\n当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。那么Java中的线程存在哪几种状态呢？Java中的线程\n\n状态被定义在了java.lang.Thread.State枚举类中，State枚举类的源码如下：\n\n```java\npublic class Thread {\n    \n    public enum State {\n    \n        /* 新建 */\n        NEW , \n\n        /* 可运行状态 */\n        RUNNABLE , \n\n        /* 阻塞状态 */\n        BLOCKED , \n\n        /* 无限等待状态 */\n        WAITING , \n\n        /* 计时等待 */\n        TIMED_WAITING , \n\n        /* 终止 */\n        TERMINATED;\n    \n\t}\n    \n    // 获取当前线程的状态\n    public State getState() {\n        return jdk.internal.misc.VM.toThreadState(threadStatus);\n    }\n    \n}\n```\n\n通过源码我们可以看到Java中的线程存在6种状态，每种线程状态的含义如下\n\n| 线程状态          | 具体含义                                     |\n| ------------- | ---------------------------------------- |\n| NEW           | 一个尚未启动的线程的状态。也称之为初始状态、开始状态。线程刚被创建，但是并未启动。还没调用start方法。MyThread t = new MyThread()只有线程象，没有线程特征。 |\n| RUNNABLE      | 当我们调用线程对象的start方法，那么此时线程对象进入了RUNNABLE状态。那么此时才是真正的在JVM进程中创建了一个线程，线程一经启动并不是立即得到执行，线程的运行与否要听令与CPU的调度，那么我们把这个中间状态称之为可执行状态(RUNNABLE)也就是说它具备执行的资格，但是并没有真正的执行起来而是在等待CPU的度。 |\n| BLOCKED       | 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。 |\n| WAITING       | 一个正在等待的线程的状态。也称之为等待状态。造成线程等待的原因有两种，分别是调用Object.wait()、join()方法。处于等待状态的线程，正在等待其他线程去执行一个特定的操作。例如：因为wait()而等待的线程正在等待另一个线程去调用notify()或notifyAll()；一个因为join()而等待的线程正在等待另一个线程结束。 |\n| TIMED_WAITING | 一个在限定时间内等待的线程的状态。也称之为限时等待状态。造成线程限时等待状态的原因有三种，分别是：Thread.sleep(long)，Object.wait(long)、join(long)。 |\n| TERMINATED    | 一个完全运行完成的线程的状态。也称之为终止状态、结束状态             |\n\n各个状态的转换，如下图所示：\n\n![1591163781941](./img/java/basics/day22-多线程02.img/1591163781941.png)\n\n### 1.2 线程的状态-练习1\n\n**目的 :** 本案例主要演示TIME_WAITING的状态转换。\n\n**需求：**编写一段代码，依次显示一个线程的这些状态：NEW -> RUNNABLE -> TIME_WAITING -> RUNNABLE -> TERMINATED\n\n为了简化我们的开发，本次我们使用匿名内部类结合lambda表达式的方式使用多线程。\n\n**代码实现**\n\n```java\npublic class ThreadStateDemo01 {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        //定义一个内部线程\n        Thread thread = new Thread(() -> {\n            System.out.println("2.执行thread.start()之后，线程的状态：" + Thread.currentThread().getState());\n            try {\n                //休眠100毫秒\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println("4.执行Thread.sleep(long)完成之后，线程的状态：" + Thread.currentThread().getState());\n        });\n\n        //获取start()之前的状态\n        System.out.println("1.通过new初始化一个线程，但是还没有start()之前，线程的状态：" + thread.getState());\n\n        //启动线程\n        thread.start();\n\n        //休眠50毫秒\n        Thread.sleep(50);\n\n        //因为thread1需要休眠100毫秒，所以在第50毫秒，thread处于sleep状态\n        System.out.println("3.执行Thread.sleep(long)时，线程的状态：" + thread.getState());\n\n        //thread1和main线程主动休眠150毫秒，所以在第150毫秒,thread早已执行完毕\n        Thread.sleep(100);\n\n        System.out.println("5.线程执行完毕之后，线程的状态：" + thread.getState() + "\\n");\n\n    }\n\n}\n```\n\n控制台输出\n\n```java\n1.通过new初始化一个线程，但是还没有start()之前，线程的状态：NEW\n2.执行thread.start()之后，线程的状态：RUNNABLE\n3.执行Thread.sleep(long)时，线程的状态：TIMED_WAITING\n4.执行Thread.sleep(long)完成之后，线程的状态：RUNNABLE\n5.线程执行完毕之后，线程的状态：TERMINATED\n```\n\n### \n\n### 1.3 线程的状态-练习2\n\n**目的 :** 本案例主要演示WAITING的状态转换。\n\n**需求 ：**编写一段代码，依次显示一个线程的这些状态：NEW -> RUNNABLE -> WAITING -> RUNNABLE -> TERMINATED\n\n**代码实现 :** \n\n```java\npublic class ThreadStateDemo02 {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        //定义一个对象，用来加锁和解锁\n        Object obj = new Object();\n\n        //定义一个内部线程\n        Thread thread1 = new Thread(() -> {\n            System.out.println("2.执行thread.start()之后，线程的状态：" + Thread.currentThread().getState());\n            synchronized (obj) {\n                try {\n\n                    //thread1需要休眠100毫秒\n                    Thread.sleep(100);\n\n                    //thread1100毫秒之后，通过wait()方法释放obj对象是锁\n                    obj.wait();\n                    \n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println("4.被object.notify()方法唤醒之后，线程的状态：" + Thread.currentThread().getState());\n        });\n\n        //获取start()之前的状态\n        System.out.println("1.通过new初始化一个线程，但是还没有start()之前，线程的状态：" + thread1.getState());\n\n        //启动线程\n        thread1.start();\n\n        //main线程休眠150毫秒\n        Thread.sleep(150);\n\n        //因为thread1在第100毫秒进入wait等待状态，所以第150秒肯定可以获取其状态\n        System.out.println("3.执行object.wait()时，线程的状态：" + thread1.getState());\n\n        //声明另一个线程进行解锁\n        new Thread(() -> {\n            synchronized (obj) {\n                //唤醒等待的线程\n                obj.notify();\n            }\n        }).start();\n\n        //main线程休眠10毫秒等待thread1线程能够苏醒\n        Thread.sleep(10);\n\n        //获取thread1运行结束之后的状态\n        System.out.println("5.线程执行完毕之后，线程的状态：" + thread1.getState() + "\\n");\n\n    }\n\n}\n```\n\n控制台输出结果\n\n```java\n1.通过new初始化一个线程，但是还没有start()之前，线程的状态：NEW\n2.执行thread.start()之后，线程的状态：RUNNABLE\n3.执行object.wait()时，线程的状态：WAITING\n4.被object.notify()方法唤醒之后，线程的状态：RUNNABLE\n5.线程执行完毕之后，线程的状态：TERMINATED\n```\n\n### \n\n### 1.4 线程的状态-练习3\n\n**目的 :**   本案例主要演示BLOCKED的状态转换。\n\n**需求 ：**编写一段代码，依次显示一个线程的这些状态：NEW -> RUNNABLE -> BLOCKED -> RUNNABLE -> TERMINATED\n\n```java\npublic class ThreadStateDemo03 {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        //定义一个对象，用来加锁和解锁\n        Object obj2 = new Object();\n\n        //定义一个线程，先抢占了obj2对象的锁\n        new Thread(() -> {\n            synchronized (obj2) {\n                try {\n                    Thread.sleep(100);              //第一个线程要持有锁100毫秒\n                    obj2.wait();                          //然后通过wait()方法进行等待状态，并释放obj2的对象锁\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n\n        //定义目标线程，获取等待获取obj2的锁\n        Thread thread = new Thread(() -> {\n            System.out.println("2.执行thread.start()之后，线程的状态：" + Thread.currentThread().getState());\n            synchronized (obj2) {\n                try {\n                    Thread.sleep(100);              //thread3要持有对象锁100毫秒\n                    obj2.notify();                        //然后通过notify()方法唤醒所有在ojb2上等待的线程继续执行后续操作\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println("4.阻塞结束后，线程的状态：" + Thread.currentThread().getState());\n        });\n\n        //获取start()之前的状态\n        System.out.println("1.通过new初始化一个线程，但是还没有thread.start()之前，线程的状态：" + thread.getState());\n\n        //启动线程\n        thread.start();\n\n        //先等100毫秒\n        Thread.sleep(50);\n\n        //第一个线程释放锁至少需要100毫秒，所以在第50毫秒时，thread正在因等待obj的对象锁而阻塞\n        System.out.println("3.因为等待锁而阻塞时，线程的状态：" + thread.getState());\n\n        //再等300毫秒\n        Thread.sleep(300);\n\n        //两个线程的执行时间加上之前等待的50毫秒总共是250毫秒，所以第300毫秒，所有的线程都已经执行完毕\n        System.out.println("5.线程执行完毕之后，线程的状态：" + thread.getState());\n\n    }\n\n}\n```\n\n**控制台输出结果**\n\n```java\n1.通过new初始化一个线程，但是还没有thread.start()之前，线程的状态：NEW\n2.执行thread.start()之后，线程的状态：RUNNABLE\n3.因为等待锁而阻塞时，线程的状态：BLOCKED\n4.阻塞结束后，线程的状态：RUNNABLE\n5.线程执行完毕之后，线程的状态：TERMINATED\n```\n\n\n\n### 1.5 线程池-基本原理\n\n**概述 :** \n\n​\t提到池，大家应该能想到的就是水池。水池就是一个容器，在该容器中存储了很多的水。那么什么是线程池呢？线程池也是可以看做成一个池子，在该池子中存储很多个线程。\n\n线程池存在的意义：\n\n​\t系统创建一个线程的成本是比较高的，因为它涉及到与操作系统交互，当程序中需要创建大量生存期很短暂的线程时，频繁的创建和销毁线程对系统的资源消耗有可能大于业务处理是对系\n\n​\t统资源的消耗，这样就有点"舍本逐末"了。针对这一种情况，为了提高性能，我们就可以采用线程池。线程池在启动的时，会创建大量空闲线程，当我们向线程池提交任务的时，线程池就\n\n​\t会启动一个线程来执行该任务。等待任务执行完毕以后，线程并不会死亡，而是再次返回到线程池中称为空闲状态。等待下一次任务的执行。\n\n**线程池的设计思路 :**\n\n1. 准备一个任务容器\n2. 一次性启动多个(2个)消费者线程\n3. 刚开始任务容器是空的，所以线程都在wait\n4. 直到一个外部线程向这个任务容器中扔了一个"任务"，就会有一个消费者线程被唤醒\n5. 这个消费者线程取出"任务"，并且执行这个任务，执行完毕后，继续等待下一次任务的到来\n\n### 1.6 线程池-Executors默认线程池\n\n概述 : JDK对线程池也进行了相关的实现，在真实企业开发中我们也很少去自定义线程池，而是使用JDK中自带的线程池。\n\n我们可以使用Executors中所提供的**静态**方法来创建线程池\n\n​\tstatic ExecutorService newCachedThreadPool()   创建一个默认的线程池\n\tstatic newFixedThreadPool(int nThreads)\t    创建一个指定最多线程数量的线程池\n\n**代码实现 :** \n\n```java\npackage com.itheima.mythreadpool;\n\n\n//static ExecutorService newCachedThreadPool()   创建一个默认的线程池\n//static newFixedThreadPool(int nThreads)\t    创建一个指定最多线程数量的线程池\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class MyThreadPoolDemo {\n    public static void main(String[] args) throws InterruptedException {\n\n        //1,创建一个默认的线程池对象.池子中默认是空的.默认最多可以容纳int类型的最大值.\n        ExecutorService executorService = Executors.newCachedThreadPool();\n        //Executors --- 可以帮助我们创建线程池对象\n        //ExecutorService --- 可以帮助我们控制线程池\n\n        executorService.submit(()->{\n            System.out.println(Thread.currentThread().getName() + "在执行了");\n        });\n\n        //Thread.sleep(2000);\n\n        executorService.submit(()->{\n            System.out.println(Thread.currentThread().getName() + "在执行了");\n        });\n\n        executorService.shutdown();\n    }\n}\n\n```\n\n\n\n### 1.7 线程池-Executors创建指定上限的线程池\n\n**使用Executors中所提供的静态方法来创建线程池**\n\n​\tstatic ExecutorService newFixedThreadPool(int nThreads) : 创建一个指定最多线程数量的线程池\n\n**代码实现 :** \n\n```java\npackage com.itheima.mythreadpool;\n\n//static ExecutorService newFixedThreadPool(int nThreads)\n//创建一个指定最多线程数量的线程池\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\n\npublic class MyThreadPoolDemo2 {\n    public static void main(String[] args) {\n        //参数不是初始值而是最大值\n        ExecutorService executorService = Executors.newFixedThreadPool(10);\n\n        ThreadPoolExecutor pool = (ThreadPoolExecutor) executorService;\n        System.out.println(pool.getPoolSize());//0\n\n        executorService.submit(()->{\n            System.out.println(Thread.currentThread().getName() + "在执行了");\n        });\n\n        executorService.submit(()->{\n            System.out.println(Thread.currentThread().getName() + "在执行了");\n        });\n\n        System.out.println(pool.getPoolSize());//2\n//        executorService.shutdown();\n    }\n}\n\n```\n\n\n\n### 1.8 线程池-ThreadPoolExecutor\n\n**创建线程池对象 :** \n\nThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(核心线程数量,最大线程数量,空闲线程最大存活时间,任务队列,创建线程工厂,任务的拒绝策略);\n\n**代码实现 :** \n\n```java\npackage com.itheima.mythreadpool;\n\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class MyThreadPoolDemo3 {\n//    参数一：核心线程数量\n//    参数二：最大线程数\n//    参数三：空闲线程最大存活时间\n//    参数四：时间单位\n//    参数五：任务队列\n//    参数六：创建线程工厂\n//    参数七：任务的拒绝策略\n    public static void main(String[] args) {\n        ThreadPoolExecutor pool = new ThreadPoolExecutor(2,5,2,TimeUnit.SECONDS,new ArrayBlockingQueue<>(10), Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());\n        pool.submit(new MyRunnable());\n        pool.submit(new MyRunnable());\n\n        pool.shutdown();\n    }\n}\n```\n\n### 1.9 线程池-参数详解\n\n![1591165506516](./img/java/basics/day22-多线程02.img/1591165506516.png)\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler)\n    \ncorePoolSize：   核心线程的最大值，不能小于0\nmaximumPoolSize：最大线程数，不能小于等于0，maximumPoolSize >= corePoolSize\nkeepAliveTime：  空闲线程最大存活时间,不能小于0\nunit：           时间单位\nworkQueue：      任务队列，不能为null\nthreadFactory：  创建线程工厂,不能为null      \nhandler：        任务的拒绝策略,不能为null  \n```\n\n\n\n### 1.10 线程池-非默认任务拒绝策略\n\nRejectedExecutionHandler是jdk提供的一个任务拒绝策略接口，它下面存在4个子类。\n\n```java\nThreadPoolExecutor.AbortPolicy: \t\t    丢弃任务并抛出RejectedExecutionException异常。是默认的策略。\nThreadPoolExecutor.DiscardPolicy： \t\t   丢弃任务，但是不抛出异常 这是不推荐的做法。\nThreadPoolExecutor.DiscardOldestPolicy：    抛弃队列中等待最久的任务 然后把当前任务加入队列中。\nThreadPoolExecutor.CallerRunsPolicy:        调用任务的run()方法绕过线程池直接执行。\n```\n\n注：明确线程池对多可执行的任务数 = 队列容量 + 最大线程数\n\n**案例演示1**：演示ThreadPoolExecutor.AbortPolicy任务处理策略\n\n```java\npublic class ThreadPoolExecutorDemo01 {\n\n    public static void main(String[] args) {\n\n        /**\n         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s\n         */\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.AbortPolicy()) ;\n\n        // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用AbortPolicy这个任务处理策略的时候，就会抛出异常\n        for(int x = 0 ; x < 5 ; x++) {\n            threadPoolExecutor.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + "----\x3e> 执行了任务");\n            });\n        }\n    }\n}\n```\n\n**控制台输出结果**\n\n```java\npool-1-thread-1----\x3e> 执行了任务\npool-1-thread-3----\x3e> 执行了任务\npool-1-thread-2----\x3e> 执行了任务\npool-1-thread-3----\x3e> 执行了任务\n```\n\n控制台报错，仅仅执行了4个任务，有一个任务被丢弃了\n\n\n\n**案例演示2**：演示ThreadPoolExecutor.DiscardPolicy任务处理策略\n\n```java\npublic class ThreadPoolExecutorDemo02 {\n    public static void main(String[] args) {\n        /**\n         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s\n         */\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardPolicy()) ;\n\n        // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用DiscardPolicy这个任务处理策略的时候，控制台不会报错\n        for(int x = 0 ; x < 5 ; x++) {\n            threadPoolExecutor.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + "----\x3e> 执行了任务");\n            });\n        }\n    }\n}\n```\n\n**控制台输出结果**\n\n```java\npool-1-thread-1----\x3e> 执行了任务\npool-1-thread-1----\x3e> 执行了任务\npool-1-thread-3----\x3e> 执行了任务\npool-1-thread-2----\x3e> 执行了任务\n```\n\n控制台没有报错，仅仅执行了4个任务，有一个任务被丢弃了\n\n\n\n**案例演示3**：演示ThreadPoolExecutor.DiscardOldestPolicy任务处理策略\n\n```java\npublic class ThreadPoolExecutorDemo02 {\n    public static void main(String[] args) {\n        /**\n         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s\n         */\n        ThreadPoolExecutor threadPoolExecutor;\n        threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardOldestPolicy());\n        // 提交5个任务\n        for(int x = 0 ; x < 5 ; x++) {\n            // 定义一个变量，来指定指定当前执行的任务;这个变量需要被final修饰\n            final int y = x ;\n            threadPoolExecutor.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + "----\x3e> 执行了任务" + y);\n            });     \n        }\n    }\n}\n```\n\n**控制台输出结果**\n\n```java\npool-1-thread-2----\x3e> 执行了任务2\npool-1-thread-1----\x3e> 执行了任务0\npool-1-thread-3----\x3e> 执行了任务3\npool-1-thread-1----\x3e> 执行了任务4\n```\n\n由于任务1在线程池中等待时间最长，因此任务1被丢弃。\n\n\n\n**案例演示4**：演示ThreadPoolExecutor.CallerRunsPolicy任务处理策略\n\n```java\npublic class ThreadPoolExecutorDemo04 {\n    public static void main(String[] args) {\n\n        /**\n         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s\n         */\n        ThreadPoolExecutor threadPoolExecutor;\n        threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.CallerRunsPolicy());\n\n        // 提交5个任务\n        for(int x = 0 ; x < 5 ; x++) {\n            threadPoolExecutor.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + "----\x3e> 执行了任务");\n            });\n        }\n    }\n}\n```\n\n**控制台输出结果**\n\n```java\npool-1-thread-1----\x3e> 执行了任务\npool-1-thread-3----\x3e> 执行了任务\npool-1-thread-2----\x3e> 执行了任务\npool-1-thread-1----\x3e> 执行了任务\nmain----\x3e> 执行了任务\n```\n\n通过控制台的输出，我们可以看到次策略没有通过线程池中的线程执行任务，而是直接调用任务的run()方法绕过线程池直接执行。\n\n## 2. 原子性\n\n### 2.1 volatile-问题\n\n**代码分析 :** \n\n```java\npackage com.itheima.myvolatile;\n\npublic class Demo {\n    public static void main(String[] args) {\n        MyThread1 t1 = new MyThread1();\n        t1.setName("小路同学");\n        t1.start();\n\n        MyThread2 t2 = new MyThread2();\n        t2.setName("小皮同学");\n        t2.start();\n    }\n}\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class Money {\n    public static int money = 100000;\n}\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class MyThread1 extends  Thread {\n    @Override\n    public void run() {\n        while(Money.money == 100000){\n\n        }\n\n        System.out.println("结婚基金已经不是十万了");\n    }\n}\n\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class MyThread2 extends Thread {\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        Money.money = 90000;\n    }\n}\n\n```\n\n**程序问题 :**  女孩虽然知道结婚基金是十万，但是当基金的余额发生变化的时候，女孩无法知道最新的余额。\n\n\n\n### 2.2 volatile解决\n\n**以上案例出现的问题 :**\n\n​\t当A线程修改了共享数据时，B线程没有及时获取到最新的值，如果还在使用原先的值，就会出现问题 \n\n​\t1，堆内存是唯一的，每一个线程都有自己的线程栈。\n\n​\t2 ，每一个线程在使用堆里面变量的时候，都会先拷贝一份到变量的副本中。\n\n​\t3 ，在线程中，每一次使用是从变量的副本中获取的。\n\n**Volatile关键字 :** 强制线程每次在使用的时候，都会看一下共享区域最新的值\n\n**代码实现 :** **使用volatile关键字解决**\n\n```java\npackage com.itheima.myvolatile;\n\npublic class Demo {\n    public static void main(String[] args) {\n        MyThread1 t1 = new MyThread1();\n        t1.setName("小路同学");\n        t1.start();\n\n        MyThread2 t2 = new MyThread2();\n        t2.setName("小皮同学");\n        t2.start();\n    }\n}\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class Money {\n    public static volatile int money = 100000;\n}\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class MyThread1 extends  Thread {\n    @Override\n    public void run() {\n        while(Money.money == 100000){\n\n        }\n\n        System.out.println("结婚基金已经不是十万了");\n    }\n}\n\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class MyThread2 extends Thread {\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        Money.money = 90000;\n    }\n}\n\n```\n\n\n\n### 2.3 synchronized解决\n\n**synchronized解决 :** \n\n​\t1 ，线程获得锁\n\n​\t2 ，清空变量副本\n\n​\t3 ，拷贝共享变量最新的值到变量副本中\n\n​\t4 ，执行代码\n\n​\t5 ，将修改后变量副本中的值赋值给共享数据\n\n​\t6 ，释放锁\n\n**代码实现 :** \n\n```java\npackage com.itheima.myvolatile2;\n\npublic class Demo {\n    public static void main(String[] args) {\n        MyThread1 t1 = new MyThread1();\n        t1.setName("小路同学");\n        t1.start();\n\n        MyThread2 t2 = new MyThread2();\n        t2.setName("小皮同学");\n        t2.start();\n    }\n}\n```\n\n```java\npackage com.itheima.myvolatile2;\n\npublic class Money {\n    public static Object lock = new Object();\n    public static volatile int money = 100000;\n}\n```\n\n```java\npackage com.itheima.myvolatile2;\n\npublic class MyThread1 extends  Thread {\n    @Override\n    public void run() {\n        while(true){\n            synchronized (Money.lock){\n                if(Money.money != 100000){\n                    System.out.println("结婚基金已经不是十万了");\n                    break;\n                }\n            }\n        }\n    }\n}\n```\n\n```java\npackage com.itheima.myvolatile2;\n\npublic class MyThread2 extends Thread {\n    @Override\n    public void run() {\n        synchronized (Money.lock) {\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            Money.money = 90000;\n        }\n    }\n}\n```\n\n\n\n### 2.4 原子性\n\n**概述 :** 所谓的原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行，多个操作是一个不可以分割的整体。\n\n**代码实现 :** \n\n```java\npackage com.itheima.threadatom;\n\npublic class AtomDemo {\n    public static void main(String[] args) {\n        MyAtomThread atom = new MyAtomThread();\n\n        for (int i = 0; i < 100; i++) {\n            new Thread(atom).start();\n        }\n    }\n}\nclass MyAtomThread implements Runnable {\n    private volatile int count = 0; //送冰淇淋的数量\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            //1,从共享数据中读取数据到本线程栈中.\n            //2,修改本线程栈中变量副本的值\n            //3,会把本线程栈中变量副本的值赋值给共享数据.\n            count++;\n            System.out.println("已经送了" + count + "个冰淇淋");\n        }\n    }\n}\n```\n\n**代码总结 :** count++ 不是一个原子性操作, 他在执行的过程中,有可能被其他线程打断\n\n\n\n### 2.5 volatile关键字不能保证原子性\n\n解决方案 : 我们可以给count++操作添加锁，那么count++操作就是临界区中的代码，临界区中的代码一次只能被一个线程去执行，所以count++就变成了原子操作。\n\n```java\npackage com.itheima.threadatom2;\n\npublic class AtomDemo {\n    public static void main(String[] args) {\n        MyAtomThread atom = new MyAtomThread();\n\n        for (int i = 0; i < 100; i++) {\n            new Thread(atom).start();\n        }\n    }\n}\nclass MyAtomThread implements Runnable {\n    private volatile int count = 0; //送冰淇淋的数量\n    private Object lock = new Object();\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            //1,从共享数据中读取数据到本线程栈中.\n            //2,修改本线程栈中变量副本的值\n            //3,会把本线程栈中变量副本的值赋值给共享数据.\n            synchronized (lock) {\n                count++;\n                System.out.println("已经送了" + count + "个冰淇淋");\n            }\n        }\n    }\n}\n```\n\n\n\n### 2.6 原子性_AtomicInteger\n\n概述：java从JDK1.5开始提供了java.util.concurrent.atomic包(简称Atomic包)，这个包中的原子操作类提供了一种用法简单，性能高效，线程安全地更新一个变量的方式。因为变\n\n量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性(字段)。本次我们只讲解\n\n使用原子的方式更新基本类型，使用原子的方式更新基本类型Atomic包提供了以下3个类：\n\nAtomicBoolean： 原子更新布尔类型\n\nAtomicInteger：   原子更新整型\n\nAtomicLong：\t原子更新长整型\n\n以上3个类提供的方法几乎一模一样，所以本节仅以AtomicInteger为例进行讲解，AtomicInteger的常用方法如下：\n\n```java\npublic AtomicInteger()：\t   \t\t\t    初始化一个默认值为0的原子型Integer\npublic AtomicInteger(int initialValue)：  初始化一个指定值的原子型Integer\n\nint get():   \t\t\t \t\t\t\t获取值\nint getAndIncrement():      \t\t\t 以原子方式将当前值加1，注意，这里返回的是自增前的值。\nint incrementAndGet():     \t\t\t\t 以原子方式将当前值加1，注意，这里返回的是自增后的值。\nint addAndGet(int data):\t\t\t\t 以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。\nint getAndSet(int value):   \t\t\t 以原子方式设置为newValue的值，并返回旧值。\n```\n\n**代码实现 :**\n\n```java\npackage com.itheima.threadatom3;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class MyAtomIntergerDemo1 {\n//    public AtomicInteger()：\t               初始化一个默认值为0的原子型Integer\n//    public AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integer\n    public static void main(String[] args) {\n        AtomicInteger ac = new AtomicInteger();\n        System.out.println(ac);\n\n        AtomicInteger ac2 = new AtomicInteger(10);\n        System.out.println(ac2);\n    }\n\n}\n```\n\n```java\npackage com.itheima.threadatom3;\n\nimport java.lang.reflect.Field;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class MyAtomIntergerDemo2 {\n//    int get():   \t\t \t\t获取值\n//    int getAndIncrement():     以原子方式将当前值加1，注意，这里返回的是自增前的值。\n//    int incrementAndGet():     以原子方式将当前值加1，注意，这里返回的是自增后的值。\n//    int addAndGet(int data):\t 以原子方式将参数与对象中的值相加，并返回结果。\n//    int getAndSet(int value):  以原子方式设置为newValue的值，并返回旧值。\n    public static void main(String[] args) {\n//        AtomicInteger ac1 = new AtomicInteger(10);\n//        System.out.println(ac1.get());\n\n//        AtomicInteger ac2 = new AtomicInteger(10);\n//        int andIncrement = ac2.getAndIncrement();\n//        System.out.println(andIncrement);\n//        System.out.println(ac2.get());\n\n//        AtomicInteger ac3 = new AtomicInteger(10);\n//        int i = ac3.incrementAndGet();\n//        System.out.println(i);//自增后的值\n//        System.out.println(ac3.get());\n\n//        AtomicInteger ac4 = new AtomicInteger(10);\n//        int i = ac4.addAndGet(20);\n//        System.out.println(i);\n//        System.out.println(ac4.get());\n\n        AtomicInteger ac5 = new AtomicInteger(100);\n        int andSet = ac5.getAndSet(20);\n        System.out.println(andSet);\n        System.out.println(ac5.get());\n    }\n}\n```\n\n\n\n### 2.7 AtomicInteger-内存解析\n\n**AtomicInteger原理 :** 自旋锁  + CAS 算法\n\n**CAS算法：**\n\n​\t有3个操作数（内存值V， 旧的预期值A，要修改的值B）\n\n​\t当旧的预期值A == 内存值   此时修改成功，将V改为B                 \n\n​\t当旧的预期值A！=内存值   此时修改失败，不做任何操作                 \n\n​\t并重新获取现在的最新值（这个重新获取的动作就是自旋）\n\n### 2.8 AtomicInteger-源码解析\n\n**代码实现 :**\n\n```java\npackage com.itheima.threadatom4;\n\npublic class AtomDemo {\n    public static void main(String[] args) {\n        MyAtomThread atom = new MyAtomThread();\n\n        for (int i = 0; i < 100; i++) {\n            new Thread(atom).start();\n        }\n    }\n}\n```\n\n```java\npackage com.itheima.threadatom4;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class MyAtomThread implements Runnable {\n    //private volatile int count = 0; //送冰淇淋的数量\n    //private Object lock = new Object();\n    AtomicInteger ac = new AtomicInteger(0);\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            //1,从共享数据中读取数据到本线程栈中.\n            //2,修改本线程栈中变量副本的值\n            //3,会把本线程栈中变量副本的值赋值给共享数据.\n            //synchronized (lock) {\n//                count++;\n//                ac++;\n            int count = ac.incrementAndGet();\n            System.out.println("已经送了" + count + "个冰淇淋");\n           // }\n        }\n    }\n}\n\n```\n\n**源码解析 :** \n\n```java\n\n//先自增，然后获取自增后的结果\npublic final int incrementAndGet() {\n        //+ 1 自增后的结果\n        //this 就表示当前的atomicInteger（值）\n        //1    自增一次\n        return U.getAndAddInt(this, VALUE, 1) + 1;\n}\n\npublic final int getAndAddInt(Object o, long offset, int delta) {\n        //v 旧值\n        int v;\n        //自旋的过程\n        do {\n            //不断的获取旧值\n            v = getIntVolatile(o, offset);\n            //如果这个方法的返回值为false，那么继续自旋\n            //如果这个方法的返回值为true，那么自旋结束\n            //o 表示的就是内存值\n            //v 旧值\n            //v + delta 修改后的值\n        } while (!weakCompareAndSetInt(o, offset, v, v + delta));\n            //作用：比较内存中的值，旧值是否相等，如果相等就把修改后的值写到内存中，返回true。表示修改成功。\n            //                                 如果不相等，无法把修改后的值写到内存中，返回false。表示修改失败。\n            //如果修改失败，那么继续自旋。\n        return v;\n}\n```\n\n\n\n### 2.9 悲观锁和乐观锁\n\n**synchronized和CAS的区别 :** \n\n**相同点：**在多线程情况下，都可以保证共享数据的安全性。\n\n**不同点：**synchronized总是从最坏的角度出发，认为每次获取数据的时候，别人都有可能修改。所以在每                       次操作共享数据之前，都会上锁。（悲观锁）\n\n​\tcas是从乐观的角度出发，假设每次获取数据别人都不会修改，所以不会上锁。只不过在修改共享数据的时候，会检查一下，别人有没有修改过这个数据。\n\n​\t如果别人修改过，那么我再次获取现在最新的值。            \n\n​\t 如果别人没有修改过，那么我现在直接修改共享数据的值.(乐观锁）\n\n\n\n## 3. 并发工具类\n\n### 3.1 并发工具类-Hashtable\n\n​\t**Hashtable出现的原因 :** 在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。\n\n**代码实现 :** \n\n```java\npackage com.itheima.mymap;\n\nimport java.util.HashMap;\nimport java.util.Hashtable;\n\npublic class MyHashtableDemo {\n    public static void main(String[] args) throws InterruptedException {\n        Hashtable<String, String> hm = new Hashtable<>();\n\n        Thread t1 = new Thread(() -> {\n            for (int i = 0; i < 25; i++) {\n                hm.put(i + "", i + "");\n            }\n        });\n\n\n        Thread t2 = new Thread(() -> {\n            for (int i = 25; i < 51; i++) {\n                hm.put(i + "", i + "");\n            }\n        });\n\n        t1.start();\n        t2.start();\n\n        System.out.println("----------------------------");\n        //为了t1和t2能把数据全部添加完毕\n        Thread.sleep(1000);\n\n        //0-0 1-1 ..... 50- 50\n\n        for (int i = 0; i < 51; i++) {\n            System.out.println(hm.get(i + ""));\n        }//0 1 2 3 .... 50\n\n\n    }\n}\n```\n\n\n\n### 3.2 并发工具类-ConcurrentHashMap基本使用\n\n​\t**ConcurrentHashMap出现的原因 :** 在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。\n\n基于以上两个原因我们可以使用JDK1.5以后所提供的ConcurrentHashMap。\n\n**体系结构 :** \n\n![1591168965857](./img/java/basics/day22-多线程02.img/1591168965857.png)\n\n**总结 :** \n\n​\t1 ，HashMap是线程不安全的。多线程环境下会有数据安全问题\n\n​\t2 ，Hashtable是线程安全的，但是会将整张表锁起来，效率低下\n\n​\t3，ConcurrentHashMap也是线程安全的，效率较高。     在JDK7和JDK8中，底层原理不一样。\n\n**代码实现 :** \n\n```java\npackage com.itheima.mymap;\n\nimport java.util.Hashtable;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class MyConcurrentHashMapDemo {\n    public static void main(String[] args) throws InterruptedException {\n        ConcurrentHashMap<String, String> hm = new ConcurrentHashMap<>(100);\n\n        Thread t1 = new Thread(() -> {\n            for (int i = 0; i < 25; i++) {\n                hm.put(i + "", i + "");\n            }\n        });\n\n\n        Thread t2 = new Thread(() -> {\n            for (int i = 25; i < 51; i++) {\n                hm.put(i + "", i + "");\n            }\n        });\n\n        t1.start();\n        t2.start();\n\n        System.out.println("----------------------------");\n        //为了t1和t2能把数据全部添加完毕\n        Thread.sleep(1000);\n\n        //0-0 1-1 ..... 50- 50\n\n        for (int i = 0; i < 51; i++) {\n            System.out.println(hm.get(i + ""));\n        }//0 1 2 3 .... 50\n    }\n}\n```\n\n\n\n### 3.3 并发工具类-ConcurrentHashMap1.7原理\n\n![1591169254280](./img/java/basics/day22-多线程02.img/1591169254280.png)\n\n### 3.4 并发工具类-ConcurrentHashMap1.8原理\n\n![1591169338256](./img/java/basics/day22-多线程02.img/1591169338256.png)\n\n**总结 :** \n\n​\t1，如果使用空参构造创建ConcurrentHashMap对象，则什么事情都不做。     在第一次添加元素的时候创建哈希表\n\n​\t2，计算当前元素应存入的索引。\n\n​\t3，如果该索引位置为null，则利用cas算法，将本结点添加到数组中。\n\n​\t4，如果该索引位置不为null，则利用volatile关键字获得当前位置最新的结点地址，挂在他下面，变成链表。\t\t\n\n​\t5，当链表的长度大于等于8时，自动转换成红黑树6，以链表或者红黑树头结点为锁对象，配合悲观锁保证多线程操作集合时数据的安全性\n\n### 3.5 并发工具类-CountDownLatch\n\n**CountDownLatch类 :** \t\t\n\n| 方法                               | 解释               |\n| -------------------------------- | ---------------- |\n| public CountDownLatch(int count) | 参数传递线程数，表示等待线程数量 |\n| public void await()              | 让线程等待            |\n| public void countDown()          | 当前线程执行完毕         |\n\n**使用场景：** 让某一条线程等待其他线程执行完毕之后再执行\n\n**代码实现 :** \n\n```java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class ChileThread1 extends Thread {\n\n    private CountDownLatch countDownLatch;\n    public ChileThread1(CountDownLatch countDownLatch) {\n        this.countDownLatch = countDownLatch;\n    }\n\n    @Override\n    public void run() {\n        //1.吃饺子\n        for (int i = 1; i <= 10; i++) {\n            System.out.println(getName() + "在吃第" + i + "个饺子");\n        }\n        //2.吃完说一声\n        //每一次countDown方法的时候，就让计数器-1\n        countDownLatch.countDown();\n    }\n}\n\n```\n\n```java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class ChileThread2 extends Thread {\n\n    private CountDownLatch countDownLatch;\n    public ChileThread2(CountDownLatch countDownLatch) {\n        this.countDownLatch = countDownLatch;\n    }\n    @Override\n    public void run() {\n        //1.吃饺子\n        for (int i = 1; i <= 15; i++) {\n            System.out.println(getName() + "在吃第" + i + "个饺子");\n        }\n        //2.吃完说一声\n        //每一次countDown方法的时候，就让计数器-1\n        countDownLatch.countDown();\n    }\n}\n\n```\n\n```java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class ChileThread3 extends Thread {\n\n    private CountDownLatch countDownLatch;\n    public ChileThread3(CountDownLatch countDownLatch) {\n        this.countDownLatch = countDownLatch;\n    }\n    @Override\n    public void run() {\n        //1.吃饺子\n        for (int i = 1; i <= 20; i++) {\n            System.out.println(getName() + "在吃第" + i + "个饺子");\n        }\n        //2.吃完说一声\n        //每一次countDown方法的时候，就让计数器-1\n        countDownLatch.countDown();\n    }\n}\n\n```\n\n```java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class MotherThread extends Thread {\n    private CountDownLatch countDownLatch;\n    public MotherThread(CountDownLatch countDownLatch) {\n        this.countDownLatch = countDownLatch;\n    }\n\n    @Override\n    public void run() {\n        //1.等待\n        try {\n            //当计数器变成0的时候，会自动唤醒这里等待的线程。\n            countDownLatch.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        //2.收拾碗筷\n        System.out.println("妈妈在收拾碗筷");\n    }\n}\n\n```\n\n```java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class MyCountDownLatchDemo {\n    public static void main(String[] args) {\n        //1.创建CountDownLatch的对象，需要传递给四个线程。\n        //在底层就定义了一个计数器，此时计数器的值就是3\n        CountDownLatch countDownLatch = new CountDownLatch(3);\n        //2.创建四个线程对象并开启他们。\n        MotherThread motherThread = new MotherThread(countDownLatch);\n        motherThread.start();\n\n        ChileThread1 t1 = new ChileThread1(countDownLatch);\n        t1.setName("小明");\n\n        ChileThread2 t2 = new ChileThread2(countDownLatch);\n        t2.setName("小红");\n\n        ChileThread3 t3 = new ChileThread3(countDownLatch);\n        t3.setName("小刚");\n\n        t1.start();\n        t2.start();\n        t3.start();\n    }\n}\n```\n\n**总结 :** \n\n​\t1. CountDownLatch(int count)：参数写等待线程的数量。并定义了一个计数器。\n\n​\t2. await()：让线程等待，当计数器为0时，会唤醒等待的线程\n\n​\t3. countDown()： 线程执行完毕时调用，会将计数器-1。\n\n### 3.6 并发工具类-Semaphore\n\n**使用场景 :** \n\n​\t可以控制访问特定资源的线程数量。\n\n**实现步骤 :** \n\n​\t1，需要有人管理这个通道\n\n​\t2，当有车进来了，发通行许可证\n\n​\t3，当车出去了，收回通行许可证\n\n​\t4，如果通行许可证发完了，那么其他车辆只能等着\n\n**代码实现 :** \n\n```java\npackage com.itheima.mysemaphore;\n\nimport java.util.concurrent.Semaphore;\n\npublic class MyRunnable implements Runnable {\n    //1.获得管理员对象，\n    private Semaphore semaphore = new Semaphore(2);\n    @Override\n    public void run() {\n        //2.获得通行证\n        try {\n            semaphore.acquire();\n            //3.开始行驶\n            System.out.println("获得了通行证开始行驶");\n            Thread.sleep(2000);\n            System.out.println("归还通行证");\n            //4.归还通行证\n            semaphore.release();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n```java\npackage com.itheima.mysemaphore;\n\npublic class MySemaphoreDemo {\n    public static void main(String[] args) {\n        MyRunnable mr = new MyRunnable();\n\n        for (int i = 0; i < 100; i++) {\n            new Thread(mr).start();\n        }\n    }\n}\n```\n\n\n\n',Nn={data:function(){return{MainComponent1:Fn,MainComponent2:Hn}}},Jn=Nn,Un=Object(d["a"])(Jn,Bn,_n,!1,null,"9395efc6",null),Gn=Un.exports,Vn=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent1}}),t("q-markdown",{attrs:{src:n.MainComponent2}})],1)},zn=[],Wn='## 1.网络编程入门\n\n### 1.1 网络编程概述【理解】\n\n- 计算机网络\n\n  是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统\n\n- 网络编程\n\n  在网络通信协议下，不同计算机上运行的程序，可以进行数据传输\n\n### 1.2 网络编程三要素【理解】\n\n- IP地址\n\n  要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识\n\n- 端口\n\n  网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识\n\n- 协议\n\n  通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。常见的协议有UDP协议和TCP协议\n\n### 1.3 IP地址【理解】\n\nIP地址：是网络中设备的唯一标识\n\n- IP地址分为两大类\n\n  - IPv4：是给每个连接在网络上的主机分配一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每个IP地址长32bit，也就是4个字节。例如一个采用二进制形式的IP地址是“11000000 10101000 00000001 01000010”，这么长的地址，处理起来也太费劲了。为了方便使用，IP地址经常被写成十进制的形式，中间使用符号“.”分隔不同的字节。于是，上面的IP地址可以表示为“192.168.1.66”。IP地址的这种表示法叫做“点分十进制表示法”，这显然比1和0容易记忆得多\n\n  - IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。为了扩大地址空间，通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，这样就解决了网络地址资源数量不够的问题\n\n- DOS常用命令：\n\n  - ipconfig：查看本机IP地址\n\n  - ping IP地址：检查网络是否连通\n\n- 特殊IP地址：\n  - 127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用\n\n### 1.4 InetAddress【应用】\n\nInetAddress：此类表示Internet协议（IP）地址\n\n- 相关方法\n\n  | 方法名                                      | 说明                               |\n  | ---------------------------------------- | -------------------------------- |\n  | static InetAddress getByName(String host) | 确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址 |\n  | String getHostName()                     | 获取此IP地址的主机名                      |\n  | String getHostAddress()                  | 返回文本显示中的IP地址字符串                  |\n\n- 代码演示\n\n  ```java\n  public class InetAddressDemo {\n      public static void main(String[] args) throws UnknownHostException {\n  \t\t//InetAddress address = InetAddress.getByName("itheima");\n          InetAddress address = InetAddress.getByName("192.168.1.66");\n\n          //public String getHostName()：获取此IP地址的主机名\n          String name = address.getHostName();\n          //public String getHostAddress()：返回文本显示中的IP地址字符串\n          String ip = address.getHostAddress();\n\n          System.out.println("主机名：" + name);\n          System.out.println("IP地址：" + ip);\n      }\n  }\n  ```\n\n\n### 1.5 端口和协议【理解】\n\n- 端口\n\n  - 设备上应用程序的唯一标识\n\n- 端口号\n\n  - 用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败\n\n- 协议\n\n  - 计算机网络中，连接和通信的规则被称为网络通信协议\n\n- UDP协议\n  - 用户数据报协议(User Datagram Protocol)\n  - UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。\n  - 由于使用UDP协议消耗系统资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输\n  - 例如视频会议通常采用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议\n\n- TCP协议\n\n  - 传输控制协议 (Transmission Control Protocol)\n\n  - TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”\n\n  - 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠\n\n    第一次握手，客户端向服务器端发出连接请求，等待服务器确认\n\n    第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求\n\n    第三次握手，客户端再次向服务器端发送确认信息，确认连接\n\n  - 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛。例如上传文件、下载文件、浏览网页等\n\n## 2.UDP通信程序\n\n### 2.1 UDP发送数据【应用】\n\n- Java中的UDP通信\n  - UDP协议是一种不可靠的网络协议，它在通信的两端各建立一个Socket对象，但是这两个Socket只是发送，接收数据的对象，因此对于基于UDP协议的通信双方而言，没有所谓的客户端和服务器的概念\n  - Java提供了DatagramSocket类作为基于UDP协议的Socket\n\n- 构造方法\n\n  | 方法名                                      | 说明                           |\n  | ---------------------------------------- | ---------------------------- |\n  | DatagramSocket()                         | 创建数据报套接字并将其绑定到本机地址上的任何可用端口   |\n  | DatagramPacket(byte[] buf,int len,InetAddress add,int port) | 创建数据包,发送长度为len的数据包到指定主机的指定端口 |\n\n- 相关方法\n\n  | 方法名                            | 说明          |\n  | ------------------------------ | ----------- |\n  | void send(DatagramPacket p)    | 发送数据报包      |\n  | void close()                   | 关闭数据报套接字    |\n  | void receive(DatagramPacket p) | 从此套接字接受数据报包 |\n\n- 发送数据的步骤\n  - 创建发送端的Socket对象(DatagramSocket)\n  - 创建数据，并把数据打包\n  - 调用DatagramSocket对象的方法发送数据\n  - 关闭发送端\n\n- 代码演示\n\n  ```java\n  public class SendDemo {\n      public static void main(String[] args) throws IOException {\n          //创建发送端的Socket对象(DatagramSocket)\n          // DatagramSocket() 构造数据报套接字并将其绑定到本地主机上的任何可用端口\n          DatagramSocket ds = new DatagramSocket();\n\n          //创建数据，并把数据打包\n          //DatagramPacket(byte[] buf, int length, InetAddress address, int port)\n          //构造一个数据包，发送长度为 length的数据包到指定主机上的指定端口号。\n          byte[] bys = "hello,udp,我来了".getBytes();\n\n          DatagramPacket dp = new DatagramPacket(bys,bys.length,InetAddress.getByName("127.0.0.1"),10086);\n\n          //调用DatagramSocket对象的方法发送数据\n          //void send(DatagramPacket p) 从此套接字发送数据报包\n          ds.send(dp);\n\n          //关闭发送端\n          //void close() 关闭此数据报套接字\n          ds.close();\n      }\n  }\n  ```\n\n### 2.2UDP接收数据【应用】\n\n- 接收数据的步骤\n  - 创建接收端的Socket对象(DatagramSocket)\n  - 创建一个数据包，用于接收数据\n  - 调用DatagramSocket对象的方法接收数据\n  - 解析数据包，并把数据在控制台显示\n  - 关闭接收端\n\n- 构造方法\n\n  | 方法名                                 | 说明                               |\n  | ----------------------------------- | -------------------------------- |\n  | DatagramPacket(byte[] buf, int len) | 创建一个DatagramPacket用于接收长度为len的数据包 |\n\n- 相关方法\n\n  | 方法名               | 说明                   |\n  | ----------------- | -------------------- |\n  | byte[]  getData() | 返回数据缓冲区              |\n  | int  getLength()  | 返回要发送的数据的长度或接收的数据的长度 |\n\n- 示例代码\n\n  ```java\n  public class ReceiveDemo {\n      public static void main(String[] args) throws IOException {\n        \t//创建接收端的Socket对象(DatagramSocket)\n        \tDatagramSocket ds = new DatagramSocket(12345);\n\n        \t//创建一个数据包，用于接收数据\n        \tbyte[] bys = new byte[1024];\n        \tDatagramPacket dp = new DatagramPacket(bys, bys.length);\n\n        \t//调用DatagramSocket对象的方法接收数据\n        \tds.receive(dp);\n\n        \t//解析数据包，并把数据在控制台显示\n        \tSystem.out.println("数据是：" + new String(dp.getData(), 0,                                             dp.getLength()));\n          }\n      }\n  }\n  ```\n\n### 2.3UDP通信程序练习【应用】\n\n- 案例需求\n\n  UDP发送数据：数据来自于键盘录入，直到输入的数据是886，发送数据结束\n\n  UDP接收数据：因为接收端不知道发送端什么时候停止发送，故采用死循环接收\n\n- 代码实现\n\n  ```java\n  /*\n      UDP发送数据：\n          数据来自于键盘录入，直到输入的数据是886，发送数据结束\n   */\n  public class SendDemo {\n      public static void main(String[] args) throws IOException {\n          //创建发送端的Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket();\n          //键盘录入数据\n          Scanner sc = new Scanner(System.in);\n          while (true) {\n            \tString s = sc.nextLine();\n              //输入的数据是886，发送数据结束\n              if ("886".equals(s)) {\n                  break;\n              }\n              //创建数据，并把数据打包\n              byte[] bys = s.getBytes();\n              DatagramPacket dp = new DatagramPacket(bys, bys.length, InetAddress.getByName("192.168.1.66"), 12345);\n\n              //调用DatagramSocket对象的方法发送数据\n              ds.send(dp);\n          }\n          //关闭发送端\n          ds.close();\n      }\n  }\n\n  /*\n      UDP接收数据：\n          因为接收端不知道发送端什么时候停止发送，故采用死循环接收\n   */\n  public class ReceiveDemo {\n      public static void main(String[] args) throws IOException {\n          //创建接收端的Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket(12345);\n          while (true) {\n              //创建一个数据包，用于接收数据\n              byte[] bys = new byte[1024];\n              DatagramPacket dp = new DatagramPacket(bys, bys.length);\n              //调用DatagramSocket对象的方法接收数据\n              ds.receive(dp);\n              //解析数据包，并把数据在控制台显示\n              System.out.println("数据是：" + new String(dp.getData(), 0, dp.getLength()));\n          }\n          //关闭接收端\n  //        ds.close();\n      }\n  }\n  ```\n\n\n### 2.4UDP三种通讯方式【理解】\n\n+ 单播\n\n  单播用于两个主机之间的端对端通信\n\n+ 组播\n\n  组播用于对一组特定的主机进行通信\n\n+ 广播\n\n  广播用于一个主机对整个局域网上所有主机上的数据通信\n\n### 2.5UDP组播实现【理解】\n\n+ 实现步骤\n\n  + 发送端\n    1. 创建发送端的Socket对象(DatagramSocket)\n    2. 创建数据，并把数据打包(DatagramPacket)\n    3. 调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址)\n    4. 释放资源\n  + 接收端\n    1. 创建接收端Socket对象(MulticastSocket)\n    2. 创建一个箱子,用于接收数据\n    3. 把当前计算机绑定一个组播地址\n    4. 将数据接收到箱子中\n    5. 解析数据包,并打印数据\n    6. 释放资源\n\n+ 代码实现\n\n  ```java\n  // 发送端\n  public class ClinetDemo {\n      public static void main(String[] args) throws IOException {\n          // 1. 创建发送端的Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket();\n          String s = "hello 组播";\n          byte[] bytes = s.getBytes();\n          InetAddress address = InetAddress.getByName("224.0.1.0");\n          int port = 10000;\n          // 2. 创建数据，并把数据打包(DatagramPacket)\n          DatagramPacket dp = new DatagramPacket(bytes,bytes.length,address,port);\n          // 3. 调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址)\n          ds.send(dp);\n          // 4. 释放资源\n          ds.close();\n      }\n  }\n  // 接收端\n  public class ServerDemo {\n      public static void main(String[] args) throws IOException {\n          // 1. 创建接收端Socket对象(MulticastSocket)\n          MulticastSocket ms = new MulticastSocket(10000);\n          // 2. 创建一个箱子,用于接收数据\n          DatagramPacket dp = new DatagramPacket(new byte[1024],1024);\n          // 3. 把当前计算机绑定一个组播地址,表示添加到这一组中.\n          ms.joinGroup(InetAddress.getByName("224.0.1.0"));\n          // 4. 将数据接收到箱子中\n          ms.receive(dp);\n          // 5. 解析数据包,并打印数据\n          byte[] data = dp.getData();\n          int length = dp.getLength();\n          System.out.println(new String(data,0,length));\n          // 6. 释放资源\n          ms.close();\n      }\n  }\n  ```\n\n### 2.6UDP广播实现【理解】\n\n+ 实现步骤\n\n  + 发送端\n    1. 创建发送端Socket对象(DatagramSocket)\n    2. 创建存储数据的箱子,将广播地址封装进去\n    3. 发送数据\n    4. 释放资源\n  + 接收端\n    1. 创建接收端的Socket对象(DatagramSocket)\n    2. 创建一个数据包，用于接收数据\n    3. 调用DatagramSocket对象的方法接收数据\n    4. 解析数据包，并把数据在控制台显示\n    5. 关闭接收端\n\n+ 代码实现\n\n  ```java\n  // 发送端\n  public class ClientDemo {\n      public static void main(String[] args) throws IOException {\n        \t// 1. 创建发送端Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket();\n  \t\t// 2. 创建存储数据的箱子,将广播地址封装进去\n          String s = "广播 hello";\n          byte[] bytes = s.getBytes();\n          InetAddress address = InetAddress.getByName("255.255.255.255");\n          int port = 10000;\n          DatagramPacket dp = new DatagramPacket(bytes,bytes.length,address,port);\n  \t\t// 3. 发送数据\n          ds.send(dp);\n  \t\t// 4. 释放资源\n          ds.close();\n      }\n  }\n  // 接收端\n  public class ServerDemo {\n      public static void main(String[] args) throws IOException {\n          // 1. 创建接收端的Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket(10000);\n          // 2. 创建一个数据包，用于接收数据\n          DatagramPacket dp = new DatagramPacket(new byte[1024],1024);\n          // 3. 调用DatagramSocket对象的方法接收数据\n          ds.receive(dp);\n          // 4. 解析数据包，并把数据在控制台显示\n          byte[] data = dp.getData();\n          int length = dp.getLength();\n          System.out.println(new String(data,0,length));\n          // 5. 关闭接收端\n          ds.close();\n      }\n  }\n  ```\n\n\n## 3.TCP通信程序\n\n### 3.1TCP发送数据【应用】\n\n- Java中的TCP通信\n\n  - Java对基于TCP协议的的网络提供了良好的封装，使用Socket对象来代表两端的通信端口，并通过Socket产生IO流来进行网络通信。\n  - Java为客户端提供了Socket类，为服务器端提供了ServerSocket类\n\n- 构造方法\n\n  | 方法名                                  | 说明                      |\n  | ------------------------------------ | ----------------------- |\n  | Socket(InetAddress address,int port) | 创建流套接字并将其连接到指定IP指定端口号   |\n  | Socket(String host, int port)        | 创建流套接字并将其连接到指定主机上的指定端口号 |\n\n- 相关方法\n\n  | 方法名                            | 说明         |\n  | ------------------------------ | ---------- |\n  | InputStream  getInputStream()  | 返回此套接字的输入流 |\n  | OutputStream getOutputStream() | 返回此套接字的输出流 |\n\n- 示例代码\n\n  ```java\n  public class ClientDemo {\n      public static void main(String[] args) throws IOException {\n          //创建客户端的Socket对象(Socket)\n          //Socket(String host, int port) 创建流套接字并将其连接到指定主机上的指定端口号\n          Socket s = new Socket("127.0.0.1",10000);\n\n          //获取输出流，写数据\n          //OutputStream getOutputStream() 返回此套接字的输出流\n          OutputStream os = s.getOutputStream();\n          os.write("hello,tcp,我来了".getBytes());\n\n          //释放资源\n          s.close();\n      }\n  }\n  ```\n\n### 3.2TCP接收数据【应用】\n\n- 构造方法\n\n  | 方法名                     | 说明               |\n  | ----------------------- | ---------------- |\n  | ServletSocket(int port) | 创建绑定到指定端口的服务器套接字 |\n\n- 相关方法\n\n  | 方法名             | 说明              |\n  | --------------- | --------------- |\n  | Socket accept() | 监听要连接到此的套接字并接受它 |\n\n- 注意事项\n\n  1. accept方法是阻塞的,作用就是等待客户端连接\n  2. 客户端创建对象并连接服务器,此时是通过三次握手协议,保证跟服务器之间的连接\n  3. 针对客户端来讲,是往外写的,所以是输出流\n     针对服务器来讲,是往里读的,所以是输入流\n  4. read方法也是阻塞的\n  5. 客户端在关流的时候,还多了一个往服务器写结束标记的动作\n  6. 最后一步断开连接,通过四次挥手协议保证连接终止\n\n- 三次握手和四次挥手\n\n  - 三次握手\n\n    ![07_TCP三次握手](./img/java/basics/day23-网络编程01.img/07_TCP三次握手.png)\n\n  - 四次挥手\n\n    ![08_TCP四次挥手](./img/java/basics/day23-网络编程01.img/08_TCP四次挥手.png)\n\n\n- 示例代码\n\n  ```java\n  public class ServerDemo {\n      public static void main(String[] args) throws IOException {\n          //创建服务器端的Socket对象(ServerSocket)\n          //ServerSocket(int port) 创建绑定到指定端口的服务器套接字\n          ServerSocket ss = new ServerSocket(10000);\n\n          //Socket accept() 侦听要连接到此套接字并接受它\n          Socket s = ss.accept();\n\n          //获取输入流，读数据，并把数据显示在控制台\n          InputStream is = s.getInputStream();\n          byte[] bys = new byte[1024];\n          int len = is.read(bys);\n          String data = new String(bys,0,len);\n          System.out.println("数据是：" + data);\n\n          //释放资源\n          s.close();\n          ss.close();\n      }\n  }\n  ```\n\n### 3.3TCP程序练习【应用】\n\n- 案例需求\n\n  客户端：发送数据，接受服务器反馈\n\n  服务器：收到消息后给出反馈\n\n- 案例分析\n  - 客户端创建对象，使用输出流输出数据\n  - 服务端创建对象，使用输入流接受数据\n  - 服务端使用输出流给出反馈数据\n  - 客户端使用输入流接受反馈数据\n\n- 代码实现\n\n  ```java\n  // 客户端\n  public class ClientDemo {\n      public static void main(String[] args) throws IOException {\n          Socket socket = new Socket("127.0.0.1",10000);\n\n          OutputStream os = socket.getOutputStream();\n          os.write("hello".getBytes());\n         // os.close();如果在这里关流,会导致整个socket都无法使用\n          socket.shutdownOutput();//仅仅关闭输出流.并写一个结束标记,对socket没有任何影响\n          \n          BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n          String line;\n          while((line = br.readLine())!=null){\n              System.out.println(line);\n          }\n          br.close();\n          os.close();\n          socket.close();\n      }\n  }\n  // 服务器\n  public class ServerDemo {\n      public static void main(String[] args) throws IOException {\n          ServerSocket ss = new ServerSocket(10000);\n\n          Socket accept = ss.accept();\n\n          InputStream is = accept.getInputStream();\n          int b;\n          while((b = is.read())!=-1){\n              System.out.println((char) b);\n          }\n\n          System.out.println("看看我执行了吗?");\n\n          BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream()));\n          bw.write("你谁啊?");\n          bw.newLine();\n          bw.flush();\n\n          bw.close();\n          is.close();\n          accept.close();\n          ss.close();\n      }\n  }\n  ```\n\n### 3.4TCP程序文件上传练习【应用】\n\n- 案例需求\n\n  客户端：数据来自于本地文件，接收服务器反馈\n\n  服务器：接收到的数据写入本地文件，给出反馈\n\n- 案例分析\n  - 创建客户端对象，创建输入流对象指向文件，每读一次数据就给服务器输出一次数据，输出结束后使用shutdownOutput()方法告知服务端传输结束\n  - 创建服务器对象，创建输出流对象指向文件，每接受一次数据就使用输出流输出到文件中，传输结束后。使用输出流给客户端反馈信息\n  - 客户端接受服务端的回馈信息\n\n- 相关方法\n\n  | 方法名                   | 说明                 |\n  | --------------------- | ------------------ |\n  | void shutdownInput()  | 将此套接字的输入流放置在“流的末尾” |\n  | void shutdownOutput() | 禁止用此套接字的输出流        |\n\n- 代码实现\n\n  ```java\n  // 客户端\n  public class ClientDemo {\n      public static void main(String[] args) throws IOException {\n          Socket socket = new Socket("127.0.0.1",10000);\n\n          //是本地的流,用来读取本地文件的.\n          BufferedInputStream bis = new BufferedInputStream(new FileInputStream("socketmodule\\\\ClientDir\\\\1.jpg"));\n\n          //写到服务器 --- 网络中的流\n          OutputStream os = socket.getOutputStream();\n          BufferedOutputStream bos = new BufferedOutputStream(os);\n\n          int b;\n          while((b = bis.read())!=-1){\n              bos.write(b);//通过网络写到服务器中\n          }\n          bos.flush();\n          //给服务器一个结束标记,告诉服务器文件已经传输完毕\n          socket.shutdownOutput();\n\n          BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n          String line;\n          while((line = br.readLine()) !=null){\n              System.out.println(line);\n          }\n          bis.close();\n          socket.close();\n      }\n  }\n  // 服务器\n  public class ServerDemo {\n      public static void main(String[] args) throws IOException {\n          ServerSocket ss = new ServerSocket(10000);\n\n          Socket accept = ss.accept();\n\n          //网络中的流,从客户端读取数据的\n          BufferedInputStream bis = new BufferedInputStream(accept.getInputStream());\n          //本地的IO流,把数据写到本地中,实现永久化存储\n          BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("socketmodule\\\\ServerDir\\\\copy.jpg"));\n\n          int b;\n          while((b = bis.read()) !=-1){\n              bos.write(b);\n          }\n\n          BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream()));\n          bw.write("上传成功");\n          bw.newLine();\n          bw.flush();\n\n          bos.close();\n          accept.close();\n          ss.close();\n      }\n  }\n  ```\n\n### 3.5TCP程序服务器优化【应用】\n\n- 优化方案一\n\n  + 需求\n\n    服务器只能处理一个客户端请求，接收完一个图片之后，服务器就关闭了。\n\n  + 解决方案\n\n    使用循环\n\n  + 代码实现\n\n    ```java\n    // 服务器代码如下,客户端代码同上个案例,此处不再给出\n    public class ServerDemo {\n        public static void main(String[] args) throws IOException {\n            ServerSocket ss = new ServerSocket(10000);\n\n            while (true) {\n                Socket accept = ss.accept();\n\n                //网络中的流,从客户端读取数据的\n                BufferedInputStream bis = new BufferedInputStream(accept.getInputStream());\n                //本地的IO流,把数据写到本地中,实现永久化存储\n                BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("optimizeserver\\\\ServerDir\\\\copy.jpg"));\n\n                int b;\n                while((b = bis.read()) !=-1){\n                    bos.write(b);\n                }\n\n                BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream()));\n                bw.write("上传成功");\n                bw.newLine();\n                bw.flush();\n\n                bos.close();\n                accept.close();\n            }\n            //ss.close();\n            \n        }\n    }\n    ```\n\n- 优化方案二\n\n  + 需求\n\n    第二次上传文件的时候，会把第一次的文件给覆盖。\n\n  + 解决方案\n\n    UUID. randomUUID()方法生成随机的文件名\n\n  + 代码实现\n\n    ```java\n    // 服务器代码如下,客户端代码同上个案例,此处不再给出\n    public class ServerDemo {\n        public static void main(String[] args) throws IOException {\n            ServerSocket ss = new ServerSocket(10000);\n\n            while (true) {\n                Socket accept = ss.accept();\n\n                //网络中的流,从客户端读取数据的\n                BufferedInputStream bis = new BufferedInputStream(accept.getInputStream());\n                //本地的IO流,把数据写到本地中,实现永久化存储\n                BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("optimizeserver\\\\ServerDir\\\\" + UUID.randomUUID().toString() + ".jpg"));\n\n                int b;\n                while((b = bis.read()) !=-1){\n                    bos.write(b);\n                }\n\n                BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream()));\n                bw.write("上传成功");\n                bw.newLine();\n                bw.flush();\n\n                bos.close();\n                accept.close();\n            }\n            //ss.close();\n\n        }\n    }\n    ```\n\n- 优化方案三\n\n  - 需求\n\n    使用循环虽然可以让服务器处理多个客户端请求。但是还是无法同时跟多个客户端进行通信。\n\n  - 解决方案\n\n    开启多线程处理\n\n  - 代码实现\n\n    ```java\n    // 线程任务类\n    public class ThreadSocket implements Runnable {\n        private Socket acceptSocket;\n\n        public ThreadSocket(Socket accept) {\n            this.acceptSocket = accept;\n        }\n      \n        @Override\n        public void run() {\n            BufferedOutputStream bos = null;\n            try {\n                //网络中的流,从客户端读取数据的\n                BufferedInputStream bis = new BufferedInputStream(acceptSocket.getInputStream());\n                //本地的IO流,把数据写到本地中,实现永久化存储\n                bos = new BufferedOutputStream(new FileOutputStream("optimizeserver\\\\ServerDir\\\\" + UUID.randomUUID().toString() + ".jpg"));\n\n                int b;\n                while((b = bis.read()) !=-1){\n                    bos.write(b);\n                }\n              \n                BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(acceptSocket.getOutputStream()));\n                bw.write("上传成功");\n                bw.newLine();\n                bw.flush();\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                if(bos != null){\n                    try {\n                        bos.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n\n                if (acceptSocket != null){\n                    try {\n                        acceptSocket.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n    // 服务器代码\n    public class ServerDemo {\n        public static void main(String[] args) throws IOException {\n            ServerSocket ss = new ServerSocket(10000);\n\n            while (true) {\n                Socket accept = ss.accept();\n                ThreadSocket ts = new ThreadSocket(accept);\n                new Thread(ts).start();\n            }\n            //ss.close();\n        }\n    }\n    ```\n\n- 优化方案四\n\n  - 需求\n\n    使用多线程虽然可以让服务器同时处理多个客户端请求。但是资源消耗太大。\n\n  - 解决方案\n\n    加入线程池\n\n  - 代码实现\n\n    ```java\n    // 服务器代码如下,线程任务类代码同上,此处不再给出\n    public class ServerDemo {\n        public static void main(String[] args) throws IOException {\n            ServerSocket ss = new ServerSocket(10000);\n            ThreadPoolExecutor pool = new ThreadPoolExecutor(\n                    3,//核心线程数量\n                    10,   //线程池的总数量\n                    60,   //临时线程空闲时间\n                    TimeUnit.SECONDS, //临时线程空闲时间的单位\n                    new ArrayBlockingQueue<>(5),//阻塞队列\n                    Executors.defaultThreadFactory(),//创建线程的方式\n                    new ThreadPoolExecutor.AbortPolicy()//任务拒绝策略\n            );\n\n            while (true) {\n                Socket accept = ss.accept();\n                ThreadSocket ts = new ThreadSocket(accept);\n                //new Thread(ts).start();\n                pool.submit(ts);\n            }\n            //ss.close();\n        }\n    }\n    ```\n\n\n## 4.NIO\n\n### 4.1概述【理解】\n\n+ BIO\n\n  Blocking IO,阻塞型IO\n\n+ NIO\n\n  No Blocking IO,非阻塞型IO\n\n+ 阻塞IO的弊端\n\n  在等待的过程中,什么事也做不了\n\n+ 非阻塞IO的好处\n\n  不需要一直等待,当一切就绪了再去做\n\n### 4.2NIO与BIO的区别【理解】\n\n+ 区别一\n\n  BIO是阻塞的，NIO是非阻塞的\n\n+ 区别二\n\n  BIO是面向流的，NIO是面向缓冲区的\n\n  BIO中数据传输是单向的，NIO中的缓冲区是双向的\n\n### 4.3NIO三大模块【理解】\n\n+ 缓冲区\n\n  用来存储数据\n\n+ 通道\n\n  用来建立连接和传输数据\n\n+ 选择器\n\n  监视通道状态\n\n  ![09_三大模块](./img/java/basics/day23-网络编程01.img/09_三大模块.png)\n\n### 4.4NIO创建缓冲区对象【应用】\n\n+ 方法介绍\n\n  | 方法名                                    | 说明                |\n  | -------------------------------------- | ----------------- |\n  | static  ByteBuffer  allocate(长度)       | 创建byte类型的缓冲区      |\n  | static  ByteBuffer  wrap(byte[] array) | 创建一个有内容的byte类型缓冲区 |\n\n+ 代码示例\n\n  ```java\n  public class CreateByteBufferDemo1 {\n      public static void main(String[] args) {\n          //method1();\n\n          //method2();\n\n          ByteBuffer wrap = ByteBuffer.wrap("aaa".getBytes());\n          for (int i = 0; i < 3; i++) {\n              System.out.println(wrap.get());\n          }\n      }\n\n      private static void method2() {\n          byte [] bytes = {97,98,99};\n          ByteBuffer byteBuffer2 = ByteBuffer.wrap(bytes);\n          //缓冲区的长度3\n          //缓冲区里面的内容就是字节数组的内容.\n          for (int i = 0; i < 3; i++) {\n              System.out.println(byteBuffer2.get());\n          }\n          System.out.println(byteBuffer2.get());\n      }\n\n      private static void method1() {\n          ByteBuffer byteBuffer1 = ByteBuffer.allocate(5);\n          //get\n          for (int i = 0; i < 5; i++) {\n              System.out.println(byteBuffer1.get());\n          }\n          System.out.println(byteBuffer1.get());\n      }\n  }\n  ```\n\n### 4.5NIO缓冲区添加数据【应用】\n\n+ 方法介绍\n\n  ![10_NIO缓冲区添加数据](./img/java/basics/day23-网络编程01.img/10_NIO缓冲区添加数据.png)\n\n+ 代码示例\n\n  ```java\n  public class ByteBufferDemo2 {\n      public static void main(String[] args) {\n  //        int position()\t\t  当前要操作的索引\n  //        int limit() \t\t  最多能操作到哪个索引\n  //        int capacity()\t\t  缓冲区的总长度\n          ByteBuffer byteBuffer = ByteBuffer.allocate(10);\n          System.out.println(byteBuffer.position());//0\n          System.out.println(byteBuffer.limit());//10\n          System.out.println(byteBuffer.capacity());//10\n\n  //        put(byte b)\t\t  一次添加一个字节\n  //        byteBuffer.put((byte) 97);\n  //        System.out.println(byteBuffer.position());\n  //        System.out.println(byteBuffer.limit());\n  //        System.out.println(byteBuffer.capacity());\n\n  //        put(byte[] src)\t\t 一次添加一个字节数组\n  //        byteBuffer.put("aaa".getBytes());\n  //        System.out.println(byteBuffer.position());//3\n  //        System.out.println(byteBuffer.limit());//10\n  //        System.out.println(byteBuffer.capacity());//10\n\n  //        position(int newPosition) 修改position\n  //        byteBuffer.position(1);\n\n  //        limit(int newLimit)\t  修改limit\n  //        byteBuffer.limit(5);\n  //        System.out.println(byteBuffer.position());\n  //        System.out.println(byteBuffer.limit());\n  //        System.out.println(byteBuffer.capacity());\n\n  //        int remaining()\t\t  还有多少能操作\n  //        boolean hasRemaining()\t  是否还有能操作的\n\n          byteBuffer.put("0123456789".getBytes());\n          System.out.println(byteBuffer.remaining());\n          System.out.println(byteBuffer.hasRemaining());\n      }\n  }\n  ```\n\n### 4.6NIO缓冲区获取数据【应用】\n\n+ 方法介绍\n\n  | 方法名              | 介绍                  |\n  | ---------------- | ------------------- |\n  | flip()           | 切换读写模式（写à读）         |\n  | get()            | 读一个字节               |\n  | get(byte[]  dst) | 读多个字节               |\n  | get(int  index)  | 读指定索引的字节            |\n  | rewind()         | 将position设置为0，可以重复读 |\n  | clear()          | 数据读写完毕（读->写）        |\n  | array()          | 将缓冲区转换成字节数组返回       |\n\n+ 代码示例\n\n  ```java\n  public class ByteBufferDemo3 {\n      public static void main(String[] args) {\n          ByteBuffer byteBuffer = ByteBuffer.allocate(10);\n          byteBuffer.put("abc".getBytes());\n\n  //        flip()  切换读写模式（写读）\n          byteBuffer.flip();\n  //        get()   读一个字节\n  //        while(byteBuffer.limit() != byteBuffer.position()){\n  //            System.out.println((char) byteBuffer.get());\n  //        }\n\n          for (int i = 0; i < byteBuffer.limit(); i++) {\n              System.out.println((char) byteBuffer.get());\n          }\n\n  //        get(byte[] dst) 读多个字节\n  //        byte [] bytes = new byte[byteBuffer.limit()];\n  //        byteBuffer.get(bytes);\n  //        System.out.println(new String(bytes));\n\n  //        get(int index)  读指定索引的字节\n  //        System.out.println((char) byteBuffer.get(0));\n\n  //        rewind()    将position设置为0，可以重复读\n  //        byteBuffer.rewind();\n  //        for (int i = 0; i < byteBuffer.limit(); i++) {\n  //            System.out.println((char) byteBuffer.get());\n  //        }\n\n  //        clear()     数据读写完毕（读->写）\n          byteBuffer.clear();\n          byteBuffer.put("qqq".getBytes());\n  //        array()     将缓冲区转换成字节数组返回\n\n          byte[] bytes = byteBuffer.array();\n          System.out.println(new String(bytes));\n      }\n  }\n  ```\n\n### 4.7小结【理解】\n\n1. 需求：我要把数据写到缓冲区中。\n\n   数据是从外面进入到缓冲区的，所以缓冲区在做读数据的操作。\n\n2. 需求：我要把数据从缓冲区中读出来。\n\n   数据是从缓冲区里面到外面的。所以缓冲区在做写数据的操作。\n\n3. capacity：容量（长度）\n   limit：   界限（最多能读/写到哪里）\n   posotion：位置（读/写哪个索引）\n\n4. 获取缓冲区里面数据之前，需要调用flip方法\n\n5. 再次写数据之前，需要调用clear方法，\n\n   但是数据还未消失，等再次写入数据，被覆盖了才会消失。\n\n',Qn='## 1.NIO\n\n### 1.1 NIO通道客户端【应用】\n\n+ 客户端实现步骤\n\n  1. 打开通道\n  2. 指定IP和端口号\n  3. 写出数据\n  4. 释放资源\n\n+ 示例代码\n\n  ```java\n  public class NIOClient {\n      public static void main(String[] args) throws IOException {\n          //1.打开通道\n          SocketChannel socketChannel = SocketChannel.open();\n\n          //2.指定IP和端口号\n          socketChannel.connect(new InetSocketAddress("127.0.0.1",10000));\n\n          //3.写出数据\n          ByteBuffer byteBuffer = ByteBuffer.wrap("一点寒毛先制".getBytes());\n          socketChannel.write(byteBuffer);\n\n          //4.释放资源\n          socketChannel.close();\n      }\n  }\n  ```\n\n### 1.2 NIO通道服务端【应用】\n\n+ NIO通道\n\n  + 服务端通道 \n\n    只负责建立建立，不负责传递数据\n\n  + 客户端通道\n\n    建立建立并将数据传递给服务端\n\n  + 缓冲区\n\n    客户端发送的数据都在缓冲区中\n\n  + 服务端通道内部创建出来的客户端通道\n\n    相当于客户端通道的延伸用来传递数据\n\n+ 服务端实现步骤\n\n  1. 打开一个服务端通道\n  2. 绑定对应的端口号\n  3. 通道默认是阻塞的，需要设置为非阻塞\n  4. 此时没有门卫大爷，所以需要经常看一下有没有连接发过来没？\n  5. 如果有客户端来连接了,则在服务端通道内部,再创建一个客户端通道,相当于是客户端通道的延伸\n  6. 获取客户端传递过来的数据,并把数据放在byteBuffer1这个缓冲区中\n  7. 给客户端回写数据\n  8. 释放资源\n\n+ 示例代码\n\n  ```java\n  public class NIOServer {\n      public static void main(String[] args) throws IOException {\n  //        1.打开一个服务端通道\n          ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n  //        2.绑定对应的端口号\n          serverSocketChannel.bind(new InetSocketAddress(10000));\n  //        3.通道默认是阻塞的，需要设置为非阻塞\n              //如果传递true 表示通道设置为阻塞通道...默认值\n              //如果传递false 表示通道设置为非阻塞通道\n          serverSocketChannel.configureBlocking(false);\n  //        4.此时没有门卫大爷，所以需要经常看一下有没有连接发过来没？\n          while (true) {\n  //        5.如果有客户端来连接了，则在服务端通道内部，再创建一个客户端通道，相当于是客户端通道的延伸\n              //此时已经设置了通道为非阻塞\n              //所以在调用方法的时候,如果有客户端来连接,那么会创建一个SocketChannel对象.\n              //如果在调用方法的时候,没有客户端来连接,那么他会返回一个null\n              SocketChannel socketChannel = serverSocketChannel.accept();\n              //System.out.println(socketChannel);\n              if(socketChannel != null){\n  //        6.客户端将缓冲区通过通道传递给服务端,就到了这个延伸通道socketChannel里面\n  //        7.服务端创建一个空的缓冲区装数据并输出\n                  ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n                  //获取传递过来的数据,并把他们放到byteBuffer缓冲区中.\n                  //返回值:\n                      //正数: 表示本次读到的有效字节个数.\n                      //0   : 表示本次没有读到有效字节.\n                      //-1  : 表示读到了末尾\n                  int len = socketChannel.read(byteBuffer);\n                  System.out.println(new String(byteBuffer.array(),0,len));\n                //8.释放资源\n                  socketChannel.close();\n              }\n          }\n      }\n  }\n  ```\n\n### 1.3 NIO通道练习【应用】\n\n+ 客户端\n\n  + 实现步骤\n\n    1. 打开通道\n    2. 指定IP和端口号\n    3. 写出数据\n    4. 读取服务器写回的数据\n    5. 释放资源\n\n  + 示例代码\n\n    ```java\n    public class Clinet {\n        public static void main(String[] args) throws IOException {\n            // 1.打开通道\n            SocketChannel socketChannel = SocketChannel.open();\n            // 2.指定IP和端口号\n            socketChannel.connect(new InetSocketAddress("127.0.0.1",10000));\n            // 3.写出数据\n            ByteBuffer byteBuffer1 = ByteBuffer.wrap("吃俺老孙一棒棒".getBytes());\n            socketChannel.write(byteBuffer1);\n      \t\t// 手动写入结束标记\n            socketChannel.shutdownOutput();\n\n            System.out.println("数据已经写给服务器");\n            // 4.读取服务器写回的数据\n            ByteBuffer byteBuffer2 = ByteBuffer.allocate(1024);\n            int len;\n            while((len = socketChannel.read(byteBuffer2)) != -1){\n                byteBuffer2.flip();\n                System.out.println(new String(byteBuffer2.array(),0,len));\n                byteBuffer2.clear();\n            }\n            // 5.释放资源\n            socketChannel.close();\n        }\n    }\n    ```\n\n+ 服务端\n\n  + 实现步骤\n\n    1. 打开一个服务端通道\n    2. 绑定对应的端口号\n    3. 通道默认是阻塞的，需要设置为非阻塞\n    4. 此时没有门卫大爷，所以需要经常看一下有没有连接发过来没？\n    5. 如果有客户端来连接了,则在服务端通道内部,再创建一个客户端通道,相当于是客户端通道的延伸\n    6. 获取客户端传递过来的数据,并把数据放在byteBuffer1这个缓冲区中\n    7. 给客户端回写数据\n    8. 释放资源\n\n  + 示例代码\n\n    ```java\n    public class Sever {\n        public static void main(String[] args) throws IOException {\n            // 1，打开一个服务端通道\n            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n            // 2，绑定对应的端口号\n            serverSocketChannel.bind(new InetSocketAddress(10000));\n            // 3，通道默认是阻塞的，需要设置为非阻塞\n            serverSocketChannel.configureBlocking(false);\n            // 4，此时没有门卫大爷，所以需要经常看一下有没有连接发过来没？\n            while(true){\n                //  5，如果有客户端来连接了，则在服务端通道内部，再创建一个客户端通道，相当于是客户端通道的延伸\n                SocketChannel socketChannel = serverSocketChannel.accept();\n                if(socketChannel != null){\n                    System.out.println("此时有客户端来连接了");\n                    // 6,获取客户端传递过来的数据,并把数据放在byteBuffer1这个缓冲区中\n                    ByteBuffer byteBuffer1 = ByteBuffer.allocate(1024);\n                    //socketChannel.read(byteBuffer1);\n                    int len;\n                    //针对于缓冲区来讲\n                        //如果 从添加数据 ----\x3e 获取数据 flip\n                        //如果 从获取数据 ----\x3e 添加数据 clear\n                    while((len = socketChannel.read(byteBuffer1)) != -1){\n                        byteBuffer1.flip();\n                        System.out.println(new String(byteBuffer1.array(),0,len));\n                        byteBuffer1.clear();\n                    }\n\n                    System.out.println("接收数据完毕,准备开始往客户端回写数据");\n                    // 7,给客户端回写数据\n                    ByteBuffer byteBuffer2 = ByteBuffer.wrap("哎哟,真疼啊!!!".getBytes());\n                    socketChannel.write(byteBuffer2);\n                    // 8,释放资源\n                    socketChannel.close();\n                }\n            }\n        }\n    }\n    ```\n\n### 1.4 NIO通道练习优化【应用】\n\n+ 存在问题\n\n  服务端内部获取的客户端通道在读取时,如果读取不到结束标记就会一直阻塞\n\n+ 解决方案\n\n  将服务端内部获取的客户端通道设置为非阻塞的\n\n+ 示例代码\n\n  ```java\n  // 客户端\n  public class Clinet {\n      public static void main(String[] args) throws IOException {\n          SocketChannel socketChannel = SocketChannel.open();\n\n          socketChannel.connect(new InetSocketAddress("127.0.0.1",10000));\n\n          ByteBuffer byteBuffer1 = ByteBuffer.wrap("吃俺老孙一棒棒".getBytes());\n          socketChannel.write(byteBuffer1);\n\n          System.out.println("数据已经写给服务器");\n\n          ByteBuffer byteBuffer2 = ByteBuffer.allocate(1024);\n          int len;\n          while((len = socketChannel.read(byteBuffer2)) != -1){\n              System.out.println("客户端接收回写数据");\n              byteBuffer2.flip();\n              System.out.println(new String(byteBuffer2.array(),0,len));\n              byteBuffer2.clear();\n          }\n          socketChannel.close();\n      }\n  }\n  // 服务端\n  public class Sever {\n      public static void main(String[] args) throws IOException {\n          ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n\n          serverSocketChannel.bind(new InetSocketAddress(10000));\n\n          serverSocketChannel.configureBlocking(false);\n\n          while(true){\n              SocketChannel socketChannel = serverSocketChannel.accept();\n              if(socketChannel != null){\n                  System.out.println("此时有客户端来连接了");\n                \t// 将服务端内部获取的客户端通道设置为非阻塞的\n                  socketChannel.configureBlocking(false);\n                  //获取客户端传递过来的数据,并把数据放在byteBuffer1这个缓冲区中\n                  ByteBuffer byteBuffer1 = ByteBuffer.allocate(1024);\n                  //socketChannel.read(byteBuffer1);\n                  int len;\n                  //针对于缓冲区来讲\n                      //如果 从添加数据 ----\x3e 获取数据 flip\n                      //如果 从获取数据 ----\x3e 添加数据 clear\n                  while((len = socketChannel.read(byteBuffer1)) > 0){\n                      System.out.println("服务端接收发送数据");\n                      byteBuffer1.flip();\n                      System.out.println(new String(byteBuffer1.array(),0,len));\n                      byteBuffer1.clear();\n                  }\n\n                  System.out.println("接收数据完毕,准备开始往客户端回写数据");\n\n                  ByteBuffer byteBuffer2 = ByteBuffer.wrap("哎哟,真疼啊!!!".getBytes());\n                  socketChannel.write(byteBuffer2);\n\n                  socketChannel.close();\n              }\n          }\n      }\n  }\n  ```\n\n### 1.5NIO选择器【理解】\n\n+ 概述\n\n  选择器可以监视通道的状态,多路复用\n\n  ![02_选择器概述](./img/java/basics/day24-网络编程02.img/02_选择器概述.png)\n\n  ![01_选择器多路复用](./img/java/basics/day24-网络编程02.img/01_选择器多路复用.png)\n\n+ 选择器对象\n\n  + Selector\n\n    选择器对象\n\n  + SelectionKey\n\n    绑定的key\n\n  + SelectableChannel\n\n    能使用选择器的通道\n\n    + SocketChannel\n    + ServerSocketChannel\n\n### 1.6NIO选择器改写服务端【应用】\n\n+ 实现步骤\n\n  1. 打开一个服务端通道(open)\n\n  2. 绑定对应的端口号\n\n  3. 通道默认是阻塞的，需要设置为非阻塞\n\n  4. 打开一个选择器（门卫大爷）\n\n  5. 将选择器绑定服务端通道，并监视服务端是否准备好\n\n  6. 如果有客户端来连接了，大爷会遍历所有的服务端通道，谁准备好了，就让谁来连接\n       连接后，在服务端通道内部，再创建一个客户端延伸通道\n\n  7. 如果客户端把数据传递过来了，大爷会遍历所有的延伸通道，谁准备好了，谁去接收数据\n\n       ![03_选择器改写服务器](./img/java/basics/day24-网络编程02.img/03_选择器改写服务器.png)\n\n+  代码实现\n\n   ```java\n   // 客户端\n   public class Clinet {\n       public static void main(String[] args) throws IOException {\n           SocketChannel socketChannel = SocketChannel.open();\n\n           socketChannel.connect(new InetSocketAddress("127.0.0.1",10000));\n\n           ByteBuffer byteBuffer1 = ByteBuffer.wrap("吃俺老孙一棒棒".getBytes());\n           socketChannel.write(byteBuffer1);\n\n           System.out.println("数据已经写给服务器");\n\n           ByteBuffer byteBuffer2 = ByteBuffer.allocate(1024);\n           int len;\n           while((len = socketChannel.read(byteBuffer2)) != -1){\n               System.out.println("客户端接收回写数据");\n               byteBuffer2.flip();\n               System.out.println(new String(byteBuffer2.array(),0,len));\n               byteBuffer2.clear();\n           }\n           socketChannel.close();\n       }\n   }\n   // 服务端\n   public class Server {\n       public static void main(String[] args) throws IOException {\n           //1.打开服务端通道\n           ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n           //2.让这个通道绑定一个端口\n           serverSocketChannel.bind(new InetSocketAddress(10000));\n           //3.设置通道为非阻塞\n           serverSocketChannel.configureBlocking(false);\n           //4.打开一个选择器\n           //Selector --- 选择器\n   //        SelectionKey --- 绑定通道后返回那个令牌\n     //      SelectableChannel --- 可以使用选择器的通道\n           Selector selector = Selector.open();\n           //5.绑定选择器和服务端通道\n           serverSocketChannel.register(selector,SelectionKey.OP_ACCEPT);\n\n           while(true){\n               System.out.println("11");\n               //选择器会监视客户端通道的状态.\n               //6.返回值就表示此时有多少个客户端来连接.\n               int count = selector.select();\n               System.out.println("222");\n               if(count != 0){\n                   System.out.println("有客户端来连接了");\n                   //7.会遍历所有的服务端通道.看谁准备好了,谁准备好了,就让谁去连接.\n                   //获取所有服务端通道的令牌,并将它们都放到一个集合中,将集合返回.\n                   Set<SelectionKey> selectionKeys = selector.selectedKeys();\n                   Iterator<SelectionKey> iterator = selectionKeys.iterator();\n                   while(iterator.hasNext()){\n                       //selectionKey 依次表示每一个服务端通道的令牌\n                       SelectionKey selectionKey = iterator.next();\n                       if(selectionKey.isAcceptable()){\n                           //可以通过令牌来获取到了一个已经就绪的服务端通道\n                           ServerSocketChannel ssc = (ServerSocketChannel) selectionKey.channel();\n                           //客户端的延伸通道\n                           SocketChannel socketChannel = ssc.accept();\n                           //将客户端延伸通道设置为非阻塞的\n                           socketChannel.configureBlocking(false);\n                           socketChannel.register(selector,SelectionKey.OP_READ);\n                           //当客户端来连接的时候,所有的步骤已经全部执行完毕.\n                       }else if(selectionKey.isReadable()){\n                           //当前通道已经做好了读取的准备(延伸通道)\n                           SocketChannel socketChannel = (SocketChannel) selectionKey.channel();\n                           ByteBuffer byteBuffer1 = ByteBuffer.allocate(1024);\n                           //socketChannel.read(byteBuffer1);\n                           int len;\n                           while((len = socketChannel.read(byteBuffer1)) > 0){\n                               byteBuffer1.flip();\n                               System.out.println(new String(byteBuffer1.array(),0,len));\n                               byteBuffer1.clear();\n                           }\n                           //给客户端的回写数据\n                           socketChannel.write(ByteBuffer.wrap("哎哟喂好疼啊!!!".getBytes()));\n                           socketChannel.close();\n                       }\n                       iterator.remove();\n                   }\n               }\n           }\n       }\n   }\n   ```\n\n## 2.HTTP协议\n\n### 2.1概述【理解】\n\n超文本传输协议(关于超文本的概念JavaWeb在进行学习)，是建立在TCP/IP协议基础上,是网络应用层的协议。\n\n由请求和响应构成,是一个标准的客户端和服务器模型\n\n### 2.2URL【理解】\n\n+ 概述\n\n  统一资源定位符,常见的如http://bbs.itheima.com/forum.php\n\n  完整的格式为 http://bbs.itheima.com:80/forum.php\n\n+ 详解\n\n  ![04_url](./img/java/basics/day24-网络编程02.img/04_url.png)\n\n### 2.3抓包工具的使用【应用】\n\n+ 使用步骤\n\n  1. 在谷歌浏览器网页中按F12 或者网页空白处右键,点击检查,可以调出工具\n\n  2. 点击network,进入到查看网络相关信息界面\n\n  3. 这时在浏览器中发起请求,进行访问,工具中就会显示出请求和响应相关的信息\n\n     ![05_抓包](./img/java/basics/day24-网络编程02.img/05_抓包.png)\n\n### 2.4请求信息【理解】\n\n+ 组成\n  + 请求行\n  + 请求头\n  + 请求空行\n  + 请求体\n\n\n+ 请求行\n\n  + 格式\n\n    ![06_请求行格式](./img/java/basics/day24-网络编程02.img/06_请求行格式.png)\n\n  + 请求方式\n\n    GET,POST,HEAD,PUT,DELETE,CONNECT,OPTIONS,TRACE,PATCH\n\n    其中用的比较多的是GET和POST\n\n  + URI\n\n    请求资源路径,统一资源标识符\n\n    ![07_Uri图示](./img/java/basics/day24-网络编程02.img/07_Uri图示.png)\n\n  + 协议版本\n\n    + HTTP1.0: 每次请求和响应都需要建立一个单独的连接\n    + HTTP1.1:支持长连接\n\n+ 请求头\n\n  + 格式\n\n    ![08_请求头图示](./img/java/basics/day24-网络编程02.img/08_请求头图示.png)\n\n  + 请求头名称\n\n    + Host: 用来指定请求的服务端地址\n    + Connection: 取值为keep-alive表示需要持久连接\n    + User-Agent: 客户端的信息\n    + Accept: 指定客户端能够接收的内容类型\n    + Accept-Encoding: 指定浏览器可以支持的服务器返回内容压缩编码类型\n    + Accept-Language: 浏览器可接受的语言\n\n    ![09_请求头示例](./img/java/basics/day24-网络编程02.img/09_请求头示例.png)\n\n+ 小结\n\n  ![10_请求信息小结](./img/java/basics/day24-网络编程02.img/10_请求信息小结.png)\n\n### 2.5响应信息【理解】\n\n+ 组成\n  + 响应行\n  + 响应头\n  + 响应空行\n  + 响应体\n\n\n+ 响应行\n\n  + 格式\n\n    ![11_响应头格式](./img/java/basics/day24-网络编程02.img/11_响应头格式.png)\n\n  + 协议版本\n\n    + HTTP1.0: 每次请求和响应都需要建立一个单独的连接\n    + HTTP1.1: 支持长连接\n\n  + 响应状态码\n\n    + 1xx: 指示信息(表示请求已接收，继续处理)\n    + 2xx: 成功(表示请求已被成功接收、理解、接受)\n    + 3xx: 请求重定向(要完成请求必须进行更进一步的操作)\n    + 4xx: 客户端错误(请求有语法错误或请求无法实现)\n    + 5xx: 服务器端错误(服务器未能实现合法的请求)\n\n  + 状态信息\n\n    + 200 ok\n    + 404 Not Found\n    + 500 Internal Server Error\n\n+ 响应头\n\n  + 响应头名称\n\n    + Content-Type: 告诉客户端实际返回内容的网络媒体类型(互联网媒体类型,也叫做MIME类型)\n\n  + 响应头值\n\n    + text/html ----\x3e 文本类型\n    + image/png ----\x3e png格式文件\n    + image/jpeg ----\x3e jpg格式文件\n\n    ![13_响应头示例](./img/java/basics/day24-网络编程02.img/13_响应头示例.png)\n\n+ 小结\n\n  ![12_响应信息小结](./img/java/basics/day24-网络编程02.img/12_响应信息小结.png)\n\n## 3.HTTP服务器\n\n### 3.1需求【理解】\n\n+ 编写服务器端代码,实现可以解析浏览器的请求,给浏览器响应数据\n\n### 3.2环境搭建【理解】\n\n+ 实现步骤\n  + 编写HttpServer类,实现可以接收浏览器发出的请求\n  + 其中获取连接的代码可以单独抽取到一个类中\n\n+ 代码实现\n\n  ```java\n  // 服务端代码\n  public class HttpServer {\n      public static void main(String[] args) throws IOException {\n          //1.打开服务端通道\n          ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n          //2.让这个通道绑定一个端口\n          serverSocketChannel.bind(new InetSocketAddress(10000));\n          //3.设置通道为非阻塞\n          serverSocketChannel.configureBlocking(false);\n          //4.打开一个选择器\n          Selector selector = Selector.open();\n\n          //5.绑定选择器和服务端通道\n          serverSocketChannel.register(selector,SelectionKey.OP_ACCEPT);\n\n          while(true){\n              //6.选择器会监视通道的状态.\n              int count = selector.select();\n              if(count != 0){\n                  //7.会遍历所有的服务端通道.看谁准备好了,谁准备好了,就让谁去连接.\n                  //获取所有服务端通道的令牌,并将它们都放到一个集合中,将集合返回.\n                  Set<SelectionKey> selectionKeys = selector.selectedKeys();\n                  Iterator<SelectionKey> iterator = selectionKeys.iterator();\n                  while(iterator.hasNext()){\n                      //selectionKey 依次表示每一个服务端通道的令牌\n                      SelectionKey selectionKey = iterator.next();\n                      if(selectionKey.isAcceptable()){\n                          //获取连接\n                          AcceptHandler acceptHandler = new AcceptHandler();\n                          acceptHandler.connSocketChannel(selectionKey);\n                      }else if(selectionKey.isReadable()){\n                         \n                      }\n                      //任务处理完毕以后,将SelectionKey从集合中移除\n                      iterator.remove();\n                  }\n              }\n          }\n      }\n  }\n  // 将获取连接的代码抽取到这个类中\n  public class AcceptHandler {\n\n      public SocketChannel connSocketChannel(SelectionKey selectionKey){\n          try {\n              //获取到已经就绪的服务端通道\n              ServerSocketChannel ssc = (ServerSocketChannel) selectionKey.channel();\n              SocketChannel socketChannel = ssc.accept();\n              //设置为非阻塞状态\n              socketChannel.configureBlocking(false);\n              //把socketChannel注册到选择器上\n              socketChannel.register(selectionKey.selector(), SelectionKey.OP_READ);\n              return socketChannel;\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n          return null;\n      }\n  }\n  ```\n\n### 3.3获取请求信息并解析【理解】\n\n+ 实现步骤\n\n  + 将请求信息封装到HttpRequest类中\n  + 在类中定义方法,实现获取请求信息并解析\n\n+ 代码实现\n\n  ```java\n  /**\n   * 用来封装请求数据的类\n   */\n  public class HttpRequest {\n      private String method; //请求方式\n      private String requestURI; //请求的uri\n      private String version;   //http的协议版本\n\n      private HashMap<String,String> hm = new HashMap<>();//所有的请求头\n\n      //parse --- 获取请求数据 并解析\n      public void parse(SelectionKey selectionKey){\n          try {\n              SocketChannel socketChannel = (SocketChannel) selectionKey.channel();\n\n              StringBuilder sb = new StringBuilder();\n              //创建一个缓冲区\n              ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n              int len;\n              //循环读取\n              while((len = socketChannel.read(byteBuffer)) > 0){\n                  byteBuffer.flip();\n                  sb.append(new String(byteBuffer.array(),0,len));\n                  //System.out.println(new String(byteBuffer.array(),0,len));\n                  byteBuffer.clear();\n              }\n              //System.out.println(sb);\n              parseHttpRequest(sb);\n\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n      }\n\n      //解析http请求协议中的数据\n      private void parseHttpRequest(StringBuilder sb) {\n          //1.需要把StringBuilder先变成一个字符串\n          String httpRequestStr = sb.toString();\n          //2.获取每一行数据\n          String[] split = httpRequestStr.split("\\r\\n");\n          //3.获取请求行\n          String httpRequestLine = split[0];//GET / HTTP/1.1\n          //4.按照空格进行切割,得到请求行中的三部分\n          String[] httpRequestInfo = httpRequestLine.split(" ");\n          this.method = httpRequestInfo[0];\n          this.requestURI = httpRequestInfo[1];\n          this.version = httpRequestInfo[2];\n          //5.操作每一个请求头\n          for (int i = 1; i < split.length; i++) {\n              String httpRequestHeaderInfo = split[i];//Host: 127.0.0.1:10000\n              String[] httpRequestHeaderInfoArr = httpRequestHeaderInfo.split(": ");\n              hm.put(httpRequestHeaderInfoArr[0],httpRequestHeaderInfoArr[1]);\n          }\n\n      }\n\n      public String getMethod() {\n          return method;\n      }\n\n      public void setMethod(String method) {\n          this.method = method;\n      }\n\n      public String getRequestURI() {\n          return requestURI;\n      }\n\n      public void setRequestURI(String requestURI) {\n          this.requestURI = requestURI;\n      }\n\n      public String getVersion() {\n          return version;\n      }\n\n      public void setVersion(String version) {\n          this.version = version;\n      }\n\n      public HashMap<String, String> getHm() {\n          return hm;\n      }\n\n      public void setHm(HashMap<String, String> hm) {\n          this.hm = hm;\n      }\n\n      @Override\n      public String toString() {\n          return "HttpRequest{" +\n                  "method=\'" + method + \'\\\'\' +\n                  ", requestURI=\'" + requestURI + \'\\\'\' +\n                  ", version=\'" + version + \'\\\'\' +\n                  ", hm=" + hm +\n                  \'}\';\n      }\n  }\n  ```\n\n### 3.4给浏览器响应数据【理解】\n\n+ 实现步骤\n\n  + 将响应信息封装HttpResponse类中\n  + 定义方法,封装响应信息,给浏览器响应数据\n\n+ 代码实现\n\n  ```java\n  public class HttpResponse {\n      private String version; //协议版本\n      private String status;  //响应状态码\n      private String desc;    //状态码的描述信息\n\n      //响应头数据\n      private HashMap<String, String> hm = new HashMap<>();\n\n      private HttpRequest httpRequest;  //我们后面要根据请求的数据,来进行一些判断\n\n      //给浏览器响应数据的方法\n      public void sendStaticResource(SelectionKey selectionKey) {\n          //1.给响应行赋值\n          this.version = "HTTP/1.1";\n          this.status = "200";\n          this.desc = "ok";\n          //2.将响应行拼接成一个单独的字符串 // HTTP/1.1 200 ok\n          String responseLine = this.version + " " + this.status + " " + this.desc + "\\r\\n";\n\n          //3.给响应头赋值\n          hm.put("Content-Type", "text/html;charset=UTF-8");\n\n          //4.将所有的响应头拼接成一个单独的字符串\n          StringBuilder sb = new StringBuilder();\n          Set<Map.Entry<String, String>> entries = hm.entrySet();\n          for (Map.Entry<String, String> entry : entries) {\n              sb.append(entry.getKey()).append(": ").append(entry.getValue()).append("\\r\\n");\n          }\n\n          //5.响应空行\n          String emptyLine = "\\r\\n";\n\n          //6.响应行,响应头,响应空行拼接成一个大字符串\n          String responseLineStr = responseLine + sb.toString() + emptyLine;\n\n          try {\n              //7.将上面三个写给浏览器\n              SocketChannel socketChannel = (SocketChannel) selectionKey.channel();\n              ByteBuffer byteBuffer1 = ByteBuffer.wrap(responseLineStr.getBytes());\n              socketChannel.write(byteBuffer1);\n\n              //8.单独操作响应体\n              //因为在以后响应体不一定是一个字符串\n              //有可能是一个文件,所以单独操作\n              String s = "哎哟,妈呀,终于写完了.";\n              ByteBuffer byteBuffer2 = ByteBuffer.wrap(s.getBytes());\n              socketChannel.write(byteBuffer2);\n\n              //9.释放资源\n              socketChannel.close();\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n      }\n\n      public String getVersion() {\n          return version;\n      }\n\n      public void setVersion(String version) {\n          this.version = version;\n      }\n\n      public String getStatus() {\n          return status;\n      }\n\n      public void setStatus(String status) {\n          this.status = status;\n      }\n\n      public String getDesc() {\n          return desc;\n      }\n\n      public void setDesc(String desc) {\n          this.desc = desc;\n      }\n\n      public HashMap<String, String> getHm() {\n          return hm;\n      }\n\n      public void setHm(HashMap<String, String> hm) {\n          this.hm = hm;\n      }\n\n      public HttpRequest getHttpRequest() {\n          return httpRequest;\n      }\n\n      public void setHttpRequest(HttpRequest httpRequest) {\n          this.httpRequest = httpRequest;\n      }\n\n      @Override\n      public String toString() {\n          return "HttpResponse{" +\n                  "version=\'" + version + \'\\\'\' +\n                  ", status=\'" + status + \'\\\'\' +\n                  ", desc=\'" + desc + \'\\\'\' +\n                  ", hm=" + hm +\n                  ", httpRequest=" + httpRequest +\n                  \'}\';\n      }\n  }\n  ```\n\n### 3.5代码优化【理解】\n\n+ 实现步骤\n\n  + 根据请求资源路径不同,响应不同的数据\n  + 服务端健壮性处理\n  + 访问不存在的资源处理\n\n+ 代码实现\n\n  ```java\n  /**\n   * 接收连接的任务处理类\n   */\n  public class AcceptHandler {\n\n      public SocketChannel connSocketChannel(SelectionKey selectionKey){\n          try {\n              //获取到已经就绪的服务端通道\n              ServerSocketChannel ssc = (ServerSocketChannel) selectionKey.channel();\n              SocketChannel socketChannel = ssc.accept();\n              //设置为非阻塞状态\n              socketChannel.configureBlocking(false);\n              //把socketChannel注册到选择器上\n              socketChannel.register(selectionKey.selector(), SelectionKey.OP_READ);\n              return socketChannel;\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n          return null;\n      }\n  }\n  /**\n   * 接收客户端请求的类\n   */\n  public class HttpServer {\n      public static void main(String[] args) throws IOException {\n          //1.打开服务端通道\n          ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n          //2.让这个通道绑定一个端口\n          serverSocketChannel.bind(new InetSocketAddress(10000));\n          //3.设置通道为非阻塞\n          serverSocketChannel.configureBlocking(false);\n          //4.打开一个选择器\n          Selector selector = Selector.open();\n          //5.绑定选择器和服务端通道\n          serverSocketChannel.register(selector,SelectionKey.OP_ACCEPT);\n\n          while(true){\n              //6.选择器会监视通道的状态.\n              int count = selector.select();\n              if(count != 0){\n                  //7.会遍历所有的服务端通道.看谁准备好了,谁准备好了,就让谁去连接.\n                  //获取所有服务端通道的令牌,并将它们都放到一个集合中,将集合返回.\n                  Set<SelectionKey> selectionKeys = selector.selectedKeys();\n                  Iterator<SelectionKey> iterator = selectionKeys.iterator();\n                  while(iterator.hasNext()){\n                      //selectionKey 依次表示每一个服务端通道的令牌\n                      SelectionKey selectionKey = iterator.next();\n                      if(selectionKey.isAcceptable()){\n                          //获取连接\n                          AcceptHandler acceptHandler = new AcceptHandler();\n                          acceptHandler.connSocketChannel(selectionKey);\n\n                      }else if(selectionKey.isReadable()){\n                          //读取数据\n                          HttpRequest httpRequest = new HttpRequest();\n                          httpRequest.parse(selectionKey);\n                          System.out.println("http请求的数据为 ----\x3e" + httpRequest);\n\n                          if(httpRequest.getRequestURI() == null || "".equals(httpRequest.getRequestURI())){\n                              selectionKey.channel();\n                              continue;\n                          }\n                          System.out.println("...数据解析完毕,准备响应数据....");\n\n                          //响应数据\n                          HttpResponse httpResponse = new HttpResponse();\n                          httpResponse.setHttpRequest(httpRequest);\n                          httpResponse.sendStaticResource(selectionKey);\n                      }\n                      //任务处理完毕以后,将SelectionKey从集合中移除\n                      iterator.remove();\n                  }\n              }\n          }\n      }\n  }\n  /**\n   * 用来封装请求数据的类\n   */\n  public class HttpRequest {\n      private String method; //请求方式\n      private String requestURI; //请求的uri\n      private String version;   //http的协议版本\n\n      private HashMap<String,String> hm = new HashMap<>();//所有的请求头\n\n      //parse --- 获取请求数据 并解析\n      public void parse(SelectionKey selectionKey){\n          try {\n              SocketChannel socketChannel = (SocketChannel) selectionKey.channel();\n\n              StringBuilder sb = new StringBuilder();\n              //创建一个缓冲区\n              ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n              int len;\n              //循环读取\n              while((len = socketChannel.read(byteBuffer)) > 0){\n                  byteBuffer.flip();\n                  sb.append(new String(byteBuffer.array(),0,len));\n                  //System.out.println(new String(byteBuffer.array(),0,len));\n                  byteBuffer.clear();\n              }\n              //System.out.println(sb);\n              parseHttpRequest(sb);\n\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n      }\n    \n      //解析http请求协议中的数据\n      private void parseHttpRequest(StringBuilder sb) {\n          //1.需要把StringBuilder先变成一个字符串\n          String httpRequestStr = sb.toString();\n          if(!(httpRequestStr == null || "".equals(httpRequestStr))){\n              //2.获取每一行数据\n              String[] split = httpRequestStr.split("\\r\\n");\n              //3.获取请求行\n              String httpRequestLine = split[0];//GET / HTTP/1.1\n              //4.按照空格进行切割,得到请求行中的三部分\n              String[] httpRequestInfo = httpRequestLine.split(" ");\n              this.method = httpRequestInfo[0];\n              this.requestURI = httpRequestInfo[1];\n              this.version = httpRequestInfo[2];\n              //5.操作每一个请求头\n              for (int i = 1; i < split.length; i++) {\n                  String httpRequestHeaderInfo = split[i];//Host: 127.0.0.1:10000\n                  String[] httpRequestHeaderInfoArr = httpRequestHeaderInfo.split(": ");\n                  hm.put(httpRequestHeaderInfoArr[0],httpRequestHeaderInfoArr[1]);\n              }\n          }\n      }\n\n      public String getMethod() {\n          return method;\n      }\n\n      public void setMethod(String method) {\n          this.method = method;\n      }\n\n      public String getRequestURI() {\n          return requestURI;\n      }\n\n      public void setRequestURI(String requestURI) {\n          this.requestURI = requestURI;\n      }\n\n      public String getVersion() {\n          return version;\n      }\n\n      public void setVersion(String version) {\n          this.version = version;\n      }\n\n      public HashMap<String, String> getHm() {\n          return hm;\n      }\n\n      public void setHm(HashMap<String, String> hm) {\n          this.hm = hm;\n      }\n\n      @Override\n      public String toString() {\n          return "HttpRequest{" +\n                  "method=\'" + method + \'\\\'\' +\n                  ", requestURI=\'" + requestURI + \'\\\'\' +\n                  ", version=\'" + version + \'\\\'\' +\n                  ", hm=" + hm +\n                  \'}\';\n      }\n  }\n  /**\n   * 用来封装响应数据的类\n   */\n  public class HttpResponse {\n      private String version; //协议版本\n      private String status;  //响应状态码\n      private String desc;    //状态码的描述信息\n\n      //响应头数据\n      private HashMap<String, String> hm = new HashMap<>();\n\n      private HttpRequest httpRequest;  //我们后面要根据请求的数据,来进行一些判断\n\n      //给浏览器响应数据的方法\n      public void sendStaticResource(SelectionKey selectionKey) {\n          //1.给响应行赋值\n          this.version = "HTTP/1.1";\n          this.status = "200";\n          this.desc = "ok";\n\n          //3.给响应头赋值\n          //先获取浏览器请求的URI\n          String requestURI = this.getHttpRequest().getRequestURI();\n          if(requestURI != null){\n\n              File file = new File(WEB_APP_PATH + requestURI);\n              //判断这个路径是否存在\n              if(!file.exists()){\n                  this.status = "404";\n                  this.desc = "NOT FOUNG";\n              }\n\n              if("200".equals(this.status)){\n                  if("/".equals(requestURI)){\n                      hm.put("Content-Type", "text/html;charset=UTF-8");\n                  }else if("/favicon.ico".equals(requestURI)){\n                      hm.put("Content-Type", "image/x-icon");\n                  }else if("/a.txt".equals(requestURI)){\n                      hm.put("Content-Type", "text/html;charset=UTF-8");\n                  }else if("/1.jpg".equals(requestURI)){\n                      hm.put("Content-Type", "image/jpeg");\n                  }else if("/1.png".equals(requestURI)){\n                      hm.put("Content-Type", "image/png");\n                  }\n              }else{\n                  hm.put("Content-Type", "text/html;charset=UTF-8");\n              }\n\n          }\n\n          //2.将响应行拼接成一个单独的字符串 // HTTP/1.1 200 ok\n          String responseLine = this.version + " " + this.status + " " + this.desc + "\\r\\n";\n\n          //4.将所有的响应头拼接成一个单独的字符串\n          StringBuilder sb = new StringBuilder();\n          Set<Map.Entry<String, String>> entries = hm.entrySet();\n          for (Map.Entry<String, String> entry : entries) {\n              sb.append(entry.getKey()).append(": ").append(entry.getValue()).append("\\r\\n");\n          }\n\n          //5.响应空行\n          String emptyLine = "\\r\\n";\n\n          //6.响应行,响应头,响应空行拼接成一个大字符串\n          String responseLineStr = responseLine + sb.toString() + emptyLine;\n\n          try {\n              //7.将上面三个写给浏览器\n              SocketChannel socketChannel = (SocketChannel) selectionKey.channel();\n              ByteBuffer byteBuffer1 = ByteBuffer.wrap(responseLineStr.getBytes());\n              socketChannel.write(byteBuffer1);\n\n              //8.单独操作响应体\n              //因为在以后响应体不一定是一个字符串\n              //有可能是一个文件,所以单独操作\n             // String s = "哎哟,妈呀,终于写完了.";\n              byte [] bytes = getContent();\n              ByteBuffer byteBuffer2 = ByteBuffer.wrap(bytes);\n              socketChannel.write(byteBuffer2);\n\n              //9.释放资源\n              socketChannel.close();\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n      }\n\n      public static final String WEB_APP_PATH = "mynio\\\\webapp";\n      private byte[] getContent() {\n          try {\n              //1.获取浏览器请求的URI\n              String requestURI = this.getHttpRequest().getRequestURI();\n              if(requestURI != null){\n\n                  if("200".equals(this.status)){\n                      //2.判断一下请求的URI,根据不同的URI来响应不同的东西\n                      if("/".equals(requestURI)){\n                          String s = "哎哟,妈呀,终于写完了.";\n                          return s.getBytes();\n                      }else/* if("/favicon.ico".equals(requestURI))*/{\n                          //获取一个ico文件\n                          FileInputStream fis = new FileInputStream(WEB_APP_PATH + requestURI);\n                          //把ico文件变成一个字节数组返回\n                          return IOUtils.toByteArray(fis);\n                      }\n                  }else{\n                      return "访问的资源不存在".getBytes();\n                  }\n              }\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n          return new byte[0];\n      }\n\n      public String getVersion() {\n          return version;\n      }\n\n      public void setVersion(String version) {\n          this.version = version;\n      }\n\n      public String getStatus() {\n          return status;\n      }\n\n      public void setStatus(String status) {\n          this.status = status;\n      }\n\n      public String getDesc() {\n          return desc;\n      }\n\n      public void setDesc(String desc) {\n          this.desc = desc;\n      }\n\n      public HashMap<String, String> getHm() {\n          return hm;\n      }\n\n      public void setHm(HashMap<String, String> hm) {\n          this.hm = hm;\n      }\n\n      public HttpRequest getHttpRequest() {\n          return httpRequest;\n      }\n\n      public void setHttpRequest(HttpRequest httpRequest) {\n          this.httpRequest = httpRequest;\n      }\n\n      @Override\n      public String toString() {\n          return "HttpResponse{" +\n                  "version=\'" + version + \'\\\'\' +\n                  ", status=\'" + status + \'\\\'\' +\n                  ", desc=\'" + desc + \'\\\'\' +\n                  ", hm=" + hm +\n                  ", httpRequest=" + httpRequest +\n                  \'}\';\n      }\n  }\n  ```\n\n  ​\n\n',Kn={data:function(){return{MainComponent1:Wn,MainComponent2:Qn}}},$n=Kn,Xn=Object(d["a"])($n,Vn,zn,!1,null,"b2c30d14",null),Yn=Xn.exports,Zn=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent1}}),t("q-markdown",{attrs:{src:n.MainComponent2}}),t("q-markdown",{attrs:{src:n.MainComponent3}})],1)},ne=[],ee='## 1.类加载器\r\n\r\n### 1.1类加载器【理解】\r\n\r\n+ 作用\r\n\r\n  负责将.class文件（存储的物理文件）加载在到内存中\r\n\r\n  ![01_类加载器](./img/java/basics/day25-基础加强01.img/01_类加载器.png)\r\n\r\n### 1.2类加载的过程【理解】\r\n\r\n+ 类加载时机\r\n\r\n  + 创建类的实例（对象）\r\n  + 调用类的类方法\r\n  + 访问类或者接口的类变量，或者为该类变量赋值\r\n  + 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象\r\n  + 初始化某个类的子类\r\n  + 直接使用java.exe命令来运行某个主类\r\n\r\n+ 类加载过程\r\n\r\n  1. 加载\r\n\r\n     + 通过包名 + 类名，获取这个类，准备用流进行传输\r\n     + 在这个类加载到内存中\r\n     + 加载完毕创建一个class对象\r\n\r\n     ![02_类加载过程加载](./img/java/basics/day25-基础加强01.img/02_类加载过程加载.png)\r\n\r\n  2. 链接\r\n\r\n     + 验证\r\n\r\n       确保Class文件字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全\r\n\r\n       (文件中的信息是否符合虚拟机规范有没有安全隐患)\r\n\r\n     ![03_类加载过程验证](./img/java/basics/day25-基础加强01.img/03_类加载过程验证.png)\r\n\r\n     + 准备\r\n\r\n       负责为类的类变量（被static修饰的变量）分配内存，并设置默认初始化值\r\n\r\n       (初始化静态变量)\r\n\r\n     ![04_类加载过程准备](./img/java/basics/day25-基础加强01.img/04_类加载过程准备.png)\r\n\r\n     + 解析\r\n\r\n       将类的二进制数据流中的符号引用替换为直接引用\r\n\r\n       (本类中如果用到了其他类，此时就需要找到对应的类)\r\n\r\n     ![05_类加载过程解析](./img/java/basics/day25-基础加强01.img/05_类加载过程解析.png)\r\n\r\n  3. 初始化\r\n\r\n     根据程序员通过程序制定的主观计划去初始化类变量和其他资源\r\n\r\n     (静态变量赋值以及初始化其他资源)\r\n\r\n     ![06_类加载过程初始化](./img/java/basics/day25-基础加强01.img/06_类加载过程初始化.png)\r\n\r\n+ 小结\r\n\r\n  + 当一个类被使用的时候，才会加载到内存\r\n  + 类加载的过程: 加载、验证、准备、解析、初始化\r\n\r\n### 1.3类加载的分类【理解】\r\n\r\n+ 分类\r\n  + Bootstrap class loader：虚拟机的内置类加载器，通常表示为null ，并且没有父null\r\n  + Platform class loader：平台类加载器,负责加载JDK中一些特殊的模块\r\n  + System class loader：系统类加载器,负责加载用户类路径上所指定的类库\r\n\r\n+ 类加载器的继承关系\r\n\r\n  + System的父加载器为Platform\r\n  + Platform的父加载器为Bootstrap\r\n\r\n+ 代码演示\r\n\r\n  ```java\r\n  public class ClassLoaderDemo1 {\r\n      public static void main(String[] args) {\r\n          //获取系统类加载器\r\n          ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\r\n\r\n          //获取系统类加载器的父加载器 --- 平台类加载器\r\n          ClassLoader classLoader1 = systemClassLoader.getParent();\r\n\r\n          //获取平台类加载器的父加载器 --- 启动类加载器\r\n          ClassLoader classLoader2 = classLoader1.getParent();\r\n\r\n          System.out.println("系统类加载器" + systemClassLoader);\r\n          System.out.println("平台类加载器" + classLoader1);\r\n          System.out.println("启动类加载器" + classLoader2);\r\n\r\n      }\r\n  }\r\n  ```\r\n\r\n### 1.4双亲委派模型【理解】\r\n\r\n+ 介绍\r\n\r\n  如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式\r\n\r\n  ![07_双亲委派模型](./img/java/basics/day25-基础加强01.img/07_双亲委派模型.png)\r\n\r\n\r\n### 1.5ClassLoader 中的两个方法【应用】\r\n\r\n- 方法介绍\r\n\r\n  | 方法名                                      | 说明        |\r\n  | ---------------------------------------- | --------- |\r\n  | public static ClassLoader getSystemClassLoader() | 获取系统类加载器  |\r\n  | public InputStream getResourceAsStream(String name) | 加载某一个资源文件 |\r\n\r\n- 示例代码\r\n\r\n  ```java\r\n  public class ClassLoaderDemo2 {\r\n      public static void main(String[] args) throws IOException {\r\n          //static ClassLoader getSystemClassLoader() 获取系统类加载器\r\n          //InputStream getResourceAsStream(String name)  加载某一个资源文件\r\n\r\n          //获取系统类加载器\r\n          ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\r\n\r\n          //利用加载器去加载一个指定的文件\r\n          //参数：文件的路径（放在src的根目录下，默认去那里加载）\r\n          //返回值：字节流。\r\n          InputStream is = systemClassLoader.getResourceAsStream("prop.properties");\r\n\r\n          Properties prop = new Properties();\r\n          prop.load(is);\r\n\r\n          System.out.println(prop);\r\n\r\n          is.close();\r\n      }\r\n  }\r\n  ```\r\n\r\n## 2.反射\r\n\r\n### 2.1反射的概述【理解】\r\n\r\n+ 反射机制\r\n\r\n  是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；\r\n  对于任意一个对象，都能够调用它的任意属性和方法；\r\n  这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。\r\n\r\n### 2.2获取Class类对象的三种方式【应用】\r\n\r\n+ 三种方式分类\r\n  + 类名.class属性\r\n\r\n  + 对象名.getClass()方法\r\n\r\n  + Class.forName(全类名)方法\r\n\r\n    ​\r\n\r\n  ![08_获取Class对象的三种方式](./img/java/basics/day25-基础加强01.img/08_获取Class对象的三种方式.png)\r\n\r\n+ 示例代码\r\n\r\n  ```java\r\n  public class Student {\r\n      private String name;\r\n      private int age;\r\n\r\n      public Student() {\r\n      }\r\n\r\n      public Student(String name, int age) {\r\n          this.name = name;\r\n          this.age = age;\r\n      }\r\n\r\n      public String getName() {\r\n          return name;\r\n      }\r\n\r\n      public void setName(String name) {\r\n          this.name = name;\r\n      }\r\n\r\n      public int getAge() {\r\n          return age;\r\n      }\r\n\r\n      public void setAge(int age) {\r\n          this.age = age;\r\n      }\r\n\r\n      public void study(){\r\n          System.out.println("学生在学习");\r\n      }\r\n\r\n      @Override\r\n      public String toString() {\r\n          return "Student{" +\r\n                  "name=\'" + name + \'\\\'\' +\r\n                  ", age=" + age +\r\n                  \'}\';\r\n      }\r\n  }\r\n  public class ReflectDemo1 {\r\n      public static void main(String[] args) throws ClassNotFoundException {\r\n          //1.Class类中的静态方法forName("全类名")\r\n              //全类名:包名 + 类名\r\n          Class clazz = Class.forName("com.itheima.myreflect2.Student");\r\n          System.out.println(clazz);\r\n\r\n          //2.通过class属性来获取\r\n          Class clazz2 = Student.class;\r\n          System.out.println(clazz2);\r\n\r\n          //3.利用对象的getClass方法来获取class对象\r\n          //getClass方法是定义在Object类中.\r\n          Student s = new Student();\r\n          Class clazz3 = s.getClass();\r\n          System.out.println(clazz3);\r\n\r\n          System.out.println(clazz == clazz2);\r\n          System.out.println(clazz2 == clazz3);\r\n      }\r\n  }\r\n  ```\r\n\r\n### 2.3反射获取构造方法并使用【应用】\r\n\r\n#### 2.3.1Class类获取构造方法对象的方法\r\n\r\n- 方法介绍\r\n\r\n  | 方法名                                      | 说明              |\r\n  | ---------------------------------------- | --------------- |\r\n  | Constructor<?>[] getConstructors()       | 返回所有公共构造方法对象的数组 |\r\n  | Constructor<?>[] getDeclaredConstructors() | 返回所有构造方法对象的数组   |\r\n  | Constructor<T> getConstructor(Class<?>... parameterTypes) | 返回单个公共构造方法对象    |\r\n  | Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes) | 返回单个构造方法对象      |\r\n\r\n- 示例代码\r\n\r\n  ```java\r\n  public class Student {\r\n      private String name;\r\n      private int age;\r\n\r\n      //私有的有参构造方法\r\n      private Student(String name) {\r\n          System.out.println("name的值为:" + name);\r\n          System.out.println("private...Student...有参构造方法");\r\n      }\r\n\r\n      //公共的无参构造方法\r\n      public Student() {\r\n          System.out.println("public...Student...无参构造方法");\r\n      }\r\n\r\n      //公共的有参构造方法\r\n      public Student(String name, int age) {\r\n          System.out.println("name的值为:" + name + "age的值为:" + age);\r\n          System.out.println("public...Student...有参构造方法");\r\n      }\r\n  }\r\n  public class ReflectDemo1 {\r\n      public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException {\r\n          //method1();\r\n          //method2();\r\n          //method3();\r\n          //method4();\r\n      }\r\n\r\n      private static void method4() throws ClassNotFoundException, NoSuchMethodException {\r\n          //        Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes)：\r\n  //                                      返回单个构造方法对象\r\n          //1.获取Class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect3.Student");\r\n          Constructor constructor = clazz.getDeclaredConstructor(String.class);\r\n          System.out.println(constructor);\r\n      }\r\n\r\n      private static void method3() throws ClassNotFoundException, NoSuchMethodException {\r\n          //        Constructor<T> getConstructor(Class<?>... parameterTypes)：\r\n  //                                      返回单个公共构造方法对象\r\n          //1.获取Class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect3.Student");\r\n          //小括号中,一定要跟构造方法的形参保持一致.\r\n          Constructor constructor1 = clazz.getConstructor();\r\n          System.out.println(constructor1);\r\n\r\n          Constructor constructor2 = clazz.getConstructor(String.class, int.class);\r\n          System.out.println(constructor2);\r\n\r\n          //因为Student类中,没有只有一个int的构造,所以这里会报错.\r\n          Constructor constructor3 = clazz.getConstructor(int.class);\r\n          System.out.println(constructor3);\r\n      }\r\n\r\n      private static void method2() throws ClassNotFoundException {\r\n          //        Constructor<?>[] getDeclaredConstructors()：\r\n  //                                      返回所有构造方法对象的数组\r\n          //1.获取Class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect3.Student");\r\n\r\n          Constructor[] constructors = clazz.getDeclaredConstructors();\r\n          for (Constructor constructor : constructors) {\r\n              System.out.println(constructor);\r\n          }\r\n      }\r\n\r\n      private static void method1() throws ClassNotFoundException {\r\n          //        Constructor<?>[] getConstructors()：\r\n  //                                      返回所有公共构造方法对象的数组\r\n          //1.获取Class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect3.Student");\r\n          Constructor[] constructors = clazz.getConstructors();\r\n          for (Constructor constructor : constructors) {\r\n              System.out.println(constructor);\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n#### 2.3.2Constructor类用于创建对象的方法\r\n\r\n+ 方法介绍\r\n\r\n  | 方法名                              | 说明               |\r\n  | -------------------------------- | ---------------- |\r\n  | T newInstance(Object...initargs) | 根据指定的构造方法创建对象    |\r\n  | setAccessible(boolean flag)      | 设置为true,表示取消访问检查 |\r\n\r\n+ 示例代码\r\n\r\n  ```java\r\n  // Student类同上一个示例,这里就不在重复提供了\r\n  public class ReflectDemo2 {\r\n      public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\r\n          //T newInstance(Object... initargs)：根据指定的构造方法创建对象\r\n          //method1();\r\n          //method2();\r\n          //method3();\r\n          //method4();\r\n\r\n      }\r\n\r\n      private static void method4() throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {\r\n          //获取一个私有的构造方法并创建对象\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect3.Student");\r\n\r\n          //2.获取一个私有化的构造方法.\r\n          Constructor constructor = clazz.getDeclaredConstructor(String.class);\r\n\r\n          //被private修饰的成员,不能直接使用的\r\n          //如果用反射强行获取并使用,需要临时取消访问检查\r\n          constructor.setAccessible(true);\r\n\r\n          //3.直接创建对象\r\n          Student student = (Student) constructor.newInstance("zhangsan");\r\n\r\n          System.out.println(student);\r\n      }\r\n\r\n      private static void method3() throws ClassNotFoundException, InstantiationException, IllegalAccessException {\r\n          //简写格式\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect3.Student");\r\n\r\n          //2.在Class类中,有一个newInstance方法,可以利用空参直接创建一个对象\r\n          Student student = (Student) clazz.newInstance();//这个方法现在已经过时了,了解一下\r\n\r\n          System.out.println(student);\r\n      }\r\n\r\n      private static void method2() throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect3.Student");\r\n\r\n          //2.获取构造方法对象\r\n          Constructor constructor = clazz.getConstructor();\r\n\r\n          //3.利用空参来创建Student的对象\r\n          Student student = (Student) constructor.newInstance();\r\n\r\n          System.out.println(student);\r\n      }\r\n\r\n      private static void method1() throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect3.Student");\r\n\r\n          //2.获取构造方法对象\r\n          Constructor constructor = clazz.getConstructor(String.class, int.class);\r\n\r\n          //3.利用newInstance创建Student的对象\r\n          Student student = (Student) constructor.newInstance("zhangsan", 23);\r\n\r\n          System.out.println(student);\r\n      }\r\n  }\r\n  ```\r\n\r\n#### 2.3.3小结\r\n\r\n+ 获取class对象\r\n\r\n  三种方式: Class.forName(“全类名”), 类名.class, 对象名.getClass()\r\n\r\n+ 获取里面的构造方法对象\r\n\r\n  getConstructor (Class<?>... parameterTypes)\r\n  getDeclaredConstructor (Class<?>... parameterTypes)\r\n\r\n+ 如果是public的，直接创建对象\r\n\r\n  newInstance(Object... initargs)\r\n\r\n+ 如果是非public的，需要临时取消检查，然后再创建对象\r\n\r\n  setAccessible(boolean)  暴力反射\r\n\r\n### 2.4反射获取成员变量并使用【应用】\r\n\r\n#### 2.4.1Class类获取成员变量对象的方法\r\n\r\n- 方法分类\r\n\r\n  | 方法名                                 | 说明              |\r\n  | ----------------------------------- | --------------- |\r\n  | Field[] getFields()                 | 返回所有公共成员变量对象的数组 |\r\n  | Field[] getDeclaredFields()         | 返回所有成员变量对象的数组   |\r\n  | Field getField(String name)         | 返回单个公共成员变量对象    |\r\n  | Field getDeclaredField(String name) | 返回单个成员变量对象      |\r\n\r\n- 示例代码\r\n\r\n  ```java\r\n  public class Student {\r\n\r\n      public String name;\r\n\r\n      public int age;\r\n\r\n      public String gender;\r\n\r\n      private int money = 300;\r\n\r\n      @Override\r\n      public String toString() {\r\n          return "Student{" +\r\n                  "name=\'" + name + \'\\\'\' +\r\n                  ", age=" + age +\r\n                  ", gender=\'" + gender + \'\\\'\' +\r\n                  ", money=" + money +\r\n                  \'}\';\r\n      }\r\n  }\r\n  public class ReflectDemo1 {\r\n      public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException {\r\n         // method1();\r\n          //method2();\r\n          //method3();\r\n          //method4();\r\n\r\n      }\r\n\r\n      private static void method4() throws ClassNotFoundException, NoSuchFieldException {\r\n          //        Field getDeclaredField(String name)：返回单个成员变量对象\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect4.Student");\r\n    \r\n          //2.获取money成员变量\r\n          Field field = clazz.getDeclaredField("money");\r\n    \r\n          //3.打印一下\r\n          System.out.println(field);\r\n      }\r\n    \r\n      private static void method3() throws ClassNotFoundException, NoSuchFieldException {\r\n          //        Field getField(String name)：返回单个公共成员变量对象\r\n          //想要获取的成员变量必须是真实存在的\r\n          //且必须是public修饰的.\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect4.Student");\r\n    \r\n          //2.获取name这个成员变量\r\n          //Field field = clazz.getField("name");\r\n          //Field field = clazz.getField("name1");\r\n          Field field = clazz.getField("money");\r\n    \r\n          //3.打印一下\r\n          System.out.println(field);\r\n      }\r\n    \r\n      private static void method2() throws ClassNotFoundException {\r\n          //        Field[] getDeclaredFields()：返回所有成员变量对象的数组\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect4.Student");\r\n    \r\n          //2.获取所有的Field对象\r\n          Field[] fields = clazz.getDeclaredFields();\r\n    \r\n          //3.遍历\r\n          for (Field field : fields) {\r\n              System.out.println(field);\r\n          }\r\n      }\r\n    \r\n      private static void method1() throws ClassNotFoundException {\r\n          //        Field[] getFields()：返回所有公共成员变量对象的数组\r\n    \r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect4.Student");\r\n    \r\n          //2.获取Field对象.\r\n          Field[] fields = clazz.getFields();\r\n    \r\n          //3.遍历\r\n          for (Field field : fields) {\r\n              System.out.println(field);\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n#### 2.4.2Field类用于给成员变量赋值的方法\r\n\r\n+ 方法介绍\r\n\r\n  | 方法名                                | 说明   |\r\n  | ---------------------------------- | ---- |\r\n  | void set(Object obj, Object value) | 赋值   |\r\n  | Object get(Object obj)             | 获取值  |\r\n\r\n+ 示例代码\r\n\r\n  ```java\r\n  // Student类同上一个示例,这里就不在重复提供了\r\n  public class ReflectDemo2 {\r\n      public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException, InstantiationException {\r\n  //        Object get(Object obj) 返回由该 Field表示的字段在指定对象上的值。\r\n          //method1();\r\n          //method2();\r\n\r\n      }\r\n\r\n      private static void method2() throws ClassNotFoundException, NoSuchFieldException, InstantiationException, IllegalAccessException {\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect4.Student");\r\n\r\n          //2.获取成员变量Field的对象\r\n          Field field = clazz.getDeclaredField("money");\r\n\r\n          //3.取消一下访问检查\r\n          field.setAccessible(true);\r\n\r\n          //4.调用get方法来获取值\r\n          //4.1创建一个对象\r\n          Student student = (Student) clazz.newInstance();\r\n          //4.2获取指定对象的money的值\r\n          Object o = field.get(student);\r\n\r\n          //5.打印一下\r\n          System.out.println(o);\r\n      }\r\n\r\n      private static void method1() throws ClassNotFoundException, NoSuchFieldException, InstantiationException, IllegalAccessException {\r\n          //        void set(Object obj, Object value)：给obj对象的成员变量赋值为value\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect4.Student");\r\n\r\n          //2.获取name这个Field对象\r\n          Field field = clazz.getField("name");\r\n\r\n          //3.利用set方法进行赋值.\r\n          //3.1先创建一个Student对象\r\n          Student student = (Student) clazz.newInstance();\r\n          //3.2有了对象才可以给指定对象进行赋值\r\n          field.set(student,"zhangsan");\r\n\r\n          System.out.println(student);\r\n      }\r\n  }\r\n  ```\r\n\r\n### 2.5反射获取成员方法并使用【应用】\r\n\r\n#### 2.5.1Class类获取成员方法对象的方法\r\n\r\n- 方法分类\r\n\r\n  | 方法名                                      | 说明                    |\r\n  | ---------------------------------------- | --------------------- |\r\n  | Method[] getMethods()                    | 返回所有公共成员方法对象的数组，包括继承的 |\r\n  | Method[] getDeclaredMethods()            | 返回所有成员方法对象的数组，不包括继承的  |\r\n  | Method getMethod(String name, Class<?>... parameterTypes) | 返回单个公共成员方法对象          |\r\n  | Method getDeclaredMethod(String name, Class<?>... parameterTypes) | 返回单个成员方法对象            |\r\n\r\n- 示例代码\r\n\r\n  ```java\r\n  public class Student {\r\n\r\n      //私有的，无参无返回值\r\n      private void show() {\r\n          System.out.println("私有的show方法，无参无返回值");\r\n      }\r\n\r\n      //公共的，无参无返回值\r\n      public void function1() {\r\n          System.out.println("function1方法，无参无返回值");\r\n      }\r\n\r\n      //公共的，有参无返回值\r\n      public void function2(String name) {\r\n          System.out.println("function2方法，有参无返回值,参数为" + name);\r\n      }\r\n\r\n      //公共的，无参有返回值\r\n      public String function3() {\r\n          System.out.println("function3方法，无参有返回值");\r\n          return "aaa";\r\n      }\r\n\r\n      //公共的，有参有返回值\r\n      public String function4(String name) {\r\n          System.out.println("function4方法，有参有返回值,参数为" + name);\r\n          return "aaa";\r\n      }\r\n  }\r\n  public class ReflectDemo1 {\r\n      public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException {\r\n          //method1();\r\n          //method2();\r\n          //method3();\r\n          //method4();\r\n          //method5();\r\n      }\r\n\r\n      private static void method5() throws ClassNotFoundException, NoSuchMethodException {\r\n          //        Method getDeclaredMethod(String name, Class<?>... parameterTypes)：\r\n  //                                返回单个成员方法对象\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect5.Student");\r\n          //2.获取一个成员方法show\r\n          Method method = clazz.getDeclaredMethod("show");\r\n          //3.打印一下\r\n          System.out.println(method);\r\n      }\r\n    \r\n      private static void method4() throws ClassNotFoundException, NoSuchMethodException {\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect5.Student");\r\n          //2.获取一个有形参的方法function2\r\n          Method method = clazz.getMethod("function2", String.class);\r\n          //3.打印一下\r\n          System.out.println(method);\r\n      }\r\n    \r\n      private static void method3() throws ClassNotFoundException, NoSuchMethodException {\r\n          //        Method getMethod(String name, Class<?>... parameterTypes) ：\r\n  //                                返回单个公共成员方法对象\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect5.Student");\r\n          //2.获取成员方法function1\r\n          Method method1 = clazz.getMethod("function1");\r\n          //3.打印一下\r\n          System.out.println(method1);\r\n      }\r\n    \r\n      private static void method2() throws ClassNotFoundException {\r\n          //        Method[] getDeclaredMethods()：\r\n  //                                返回所有成员方法对象的数组，不包括继承的\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect5.Student");\r\n    \r\n          //2.获取Method对象\r\n          Method[] methods = clazz.getDeclaredMethods();\r\n          //3.遍历一下数组\r\n          for (Method method : methods) {\r\n              System.out.println(method);\r\n          }\r\n      }\r\n    \r\n      private static void method1() throws ClassNotFoundException {\r\n          //        Method[] getMethods()：返回所有公共成员方法对象的数组，包括继承的\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect5.Student");\r\n          //2.获取成员方法对象\r\n          Method[] methods = clazz.getMethods();\r\n          //3.遍历\r\n          for (Method method : methods) {\r\n              System.out.println(method);\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n#### 2.5.2Method类用于执行方法的方法\r\n\r\n+ 方法介绍\r\n\r\n  | 方法名                                      | 说明   |\r\n  | ---------------------------------------- | ---- |\r\n  | Object invoke(Object obj, Object... args) | 运行方法 |\r\n\r\n  参数一: 用obj对象调用该方法\r\n\r\n  参数二: 调用方法的传递的参数(如果没有就不写)\r\n\r\n  返回值: 方法的返回值(如果没有就不写)\r\n\r\n+ 示例代码\r\n\r\n  ```java\r\n  public class ReflectDemo2 {\r\n      public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException {\r\n  //        Object invoke(Object obj, Object... args)：运行方法\r\n  //        参数一：用obj对象调用该方法\r\n  //        参数二：调用方法的传递的参数（如果没有就不写）\r\n  //        返回值：方法的返回值（如果没有就不写）\r\n\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect5.Student");\r\n          //2.获取里面的Method对象  function4\r\n          Method method = clazz.getMethod("function4", String.class);\r\n          //3.运行function4方法就可以了\r\n          //3.1创建一个Student对象,当做方法的调用者\r\n          Student student = (Student) clazz.newInstance();\r\n          //3.2运行方法\r\n          Object result = method.invoke(student, "zhangsan");\r\n          //4.打印一下返回值\r\n          System.out.println(result);\r\n      }\r\n  }\r\n  ```\r\n\r\n## 3.http服务器改写\r\n\r\n### 3.1静态资源和动态资源【理解】\r\n\r\n![11_请求资源分类](./img/java/basics/day25-基础加强01.img/11_请求资源分类.png)\r\n\r\n+ 静态资源\r\n\r\n  在服务器提前准备好的文件。(图片，文本)\r\n\r\n  ![09_静态资源](./img/java/basics/day25-基础加强01.img/09_静态资源.png)\r\n\r\n+ 动态资源\r\n\r\n  在图示的案例中，当用户点击了浏览器上的按钮。\r\n  本质上访问的就是服务端的某一个类中的某一个方法。\r\n  在方法中，可以写一些判断代码和逻辑代码，让响应的内容，有可能不一样了。\r\n  那么，服务端所对应的这个类我们常常将其称之为“动态资源”\r\n\r\n  ![10_动态资源](./img/java/basics/day25-基础加强01.img/10_动态资源.png)\r\n\r\n### 3.2准备工作【理解】\r\n\r\n+ 修改四个地方\r\n\r\n  + HttpResponse -> 常量WEB_APP_PATH的值与当前模块一致\r\n  + HttpServer -> main方法中端口改成80\r\n  + HttpResponse -> 添加一个write方法，添加一个带参数的构造方法\r\n  + HttpResponse -> 添加一个contentType成员变量，生成对应的set/get方法\r\n\r\n+ 示例代码\r\n\r\n  ```java\r\n  // 1.HttpResponse -> 常量WEB_APP_PATH的值与当前模块一致\r\n  public class HttpResponse {\r\n    ...\r\n    public static final String WEB_APP_PATH = "http-dynamic-server\\\\webapp";\r\n    ...\r\n  }\r\n\r\n  // 2.HttpServer -> main方法中端口改成80\r\n  public class HttpServer {\r\n    public static void main(String[] args) throws IOException {\r\n      ...\r\n      //2.让这个通道绑定一个端口\r\n    \tserverSocketChannel.bind(new InetSocketAddress(80));\r\n      ...\r\n    }\r\n  }  \r\n\r\n  // 3.HttpResponse -> 添加一个write方法，添加一个带参数的构造方法\r\n  public class HttpResponse {\r\n    ...\r\n    // 已经提供了selectionKey，所以之前的方法接收这个参数的可以去掉了，直接使用这个即可\r\n    // HttpRequest也按照此方式进行优化，定义成员变量，在构造方法中赋值，其他方法直接使用即可\r\n    private SelectionKey selectionKey;\r\n    \r\n    public HttpResponse(SelectionKey selectionKey) {\r\n          this.selectionKey = selectionKey;\r\n      }\r\n    \r\n    //给浏览器响应数据的方法 ---- 浏览器在请求动态资源时,响应数据的方法.\r\n    //content:响应的内容\r\n    public void write(String content){\r\n    }\r\n    ...\r\n  }\r\n\r\n  public class HttpServer {\r\n    public static void main(String[] args) throws IOException {\r\n      ...\r\n      //响应数据  //修改后的构造方法中要传入参数\r\n      HttpResponse httpResponse = new HttpResponse(selectionKey);\r\n      ...\r\n    }\r\n  }  \r\n\r\n  // 4.HttpResponse -> 添加一个contentType成员变量，生成对应的set/get方法\r\n  public class HttpResponse {\r\n    ...\r\n    private String contentType;//MIME类型\r\n    \r\n    public String getContentType() {\r\n          return contentType;\r\n      }\r\n    public void setContentTpye(String contentType) {\r\n          this.contentType = contentType;\r\n          //添加到map集合中\r\n          hm.put("Content-Type",contentType);\r\n      }\r\n    ...\r\n  }\r\n  ```\r\n\r\n### 3.3浏览器请求动态资源【理解】\r\n\r\n+ 两个小问题\r\n\r\n  + 服务器如何判断浏览器请求的是静态资源还是动态资源?\r\n\r\n    我们可以规定：如果浏览器地址栏中的uri是以”/servlet”开始的，那么就表示请求动态资源\r\n\r\n  + 在一个项目中有很多类，很多方法。那么请求过来之后，执行哪个方法呢?\r\n\r\n    写一个UserServlet类，在类中写service方法\r\n    我们可以规定：如果请求动态资源，就创建这个类对象，并调用service方法，表示服务器处理了当前请求\r\n\r\n+ 实现步骤\r\n\r\n  1. 解析http请求\r\n\r\n  2. 处理浏览器请求\r\n\r\n     定义一个UserServlet 类，类中定义service方法，处理浏览器请求动态资源\r\n     解析完http请求之后，再判断uri是否以/servlet开头\r\n\r\n  3. 响应\r\n\r\n+ 示例代码\r\n\r\n  ```java\r\n  public class UserServlet{\r\n    public void service(){\r\n          //模拟业务处理  ---- 就可以对这个手机号进行判断验证\r\n          System.out.println("UserServlet处理了用户的请求...");\r\n      }\r\n  }\r\n  public class HttpServer {\r\n    public static void main(String[] args) throws IOException {\r\n      \t...\r\n      \t//响应数据\r\n      \tHttpResponse httpResponse = new HttpResponse(selectionKey);\r\n          httpResponse.setHttpRequest(httpRequest);\r\n\r\n          if(httpRequest.getRequestURI().startsWith("/servlet")){\r\n            \t//本次请求动态资源\r\n            \t//处理 \r\n            \tUserServlet userServlet = new UserServlet();\r\n            \tuserServlet.service();\r\n            \t//响应\r\n          \thttpResponse.setContentTpye("text/html;charset=UTF-8");\r\n          \thttpResponse.write("ok,UserServlet处理了本次请求....");  \r\n          }else{\r\n            //本次请求静态资源\r\n            httpResponse.sendStaticResource();\r\n          }\r\n      \t...\r\n    }\r\n  } \r\n\r\n  public class HttpResponse {\r\n    \t...\r\n  \t//给浏览器响应数据的方法 ---- 浏览器在请求动态资源时,响应数据的方法.\r\n      //content:响应的内容\r\n      public void write(String content){\r\n          //准备响应行数据\r\n          this.version = "HTTP/1.1";\r\n          this.status = "200";\r\n          this.desc = "ok";\r\n\r\n          //把响应行拼接在一起\r\n          String responseLine = this.version + " " + this.status + " " + this.desc + "\\r\\n";\r\n\r\n          //准备响应头\r\n          StringBuilder sb = new StringBuilder();\r\n          Set<Map.Entry<String, String>> entries = hm.entrySet();\r\n          for (Map.Entry<String, String> entry : entries) {\r\n              //entry依次表示每一个键值对对象\r\n              //键 --- 响应头的名称\r\n              //值 --- 响应头的值\r\n              sb.append(entry.getKey()).append(": ").append(entry.getValue()).append("\\r\\n");\r\n          }\r\n\r\n          //处理响应空行\r\n          String emptyLine = "\\r\\n";\r\n\r\n          //拼接响应行,响应头,响应空行\r\n          String result = responseLine + sb.toString() + emptyLine;\r\n\r\n          try {\r\n              //给浏览器响应 响应行,响应头,响应空行\r\n              ByteBuffer byteBuffer1 = ByteBuffer.wrap(result.getBytes());\r\n              SocketChannel channel = (SocketChannel) selectionKey.channel();\r\n              channel.write(byteBuffer1);\r\n\r\n              //给浏览器响应 响应体\r\n              ByteBuffer byteBuffer2 = ByteBuffer.wrap(content.getBytes());\r\n              channel.write(byteBuffer2);\r\n\r\n              //释放资源\r\n              channel.close();\r\n\r\n          } catch (IOException e) {\r\n              System.out.println("响应数据失败....");\r\n              e.printStackTrace();\r\n          }\r\n\r\n      }    \r\n   \t ...\r\n  }\r\n  ```\r\n\r\n### 3.4main方法和Servlet优化【理解】\r\n\r\n+ main方法优化\r\n\r\n  + 需求\r\n\r\n    将请求动态资源的代码抽取到一个单独的类单独的方法中，简化main中的代码\r\n\r\n  + 代码实现\r\n\r\n    ```java\r\n    public class DynamicResourceProcess {\r\n      \r\n        //执行指定动态资源的service方法\r\n        //参数一\r\n        //由于后期可能根据用户请求的uri做出相应的处理.\r\n        //参数二\r\n        //要给用户响应数据,那么就需要使用到httpResponse.\r\n        public void process(HttpRequest httpRequest,HttpResponse httpResponse) {\r\n            // 创建UserServlet对象,调用service方法,进行处理\r\n            UserServlet userServlet = new UserServlet();\r\n            userServlet.service();\r\n\r\n            //给浏览器响应\r\n            httpResponse.setContentTpye("text/html;charset=UTF-8");\r\n            httpResponse.write("ok,UserServlet处理了本次请求....");\r\n        }\r\n    }\r\n\r\n    public class HttpServer {\r\n      public static void main(String[] args) throws IOException {\r\n        \t...\r\n        \t//响应数据\r\n        \tHttpResponse httpResponse = new HttpResponse(selectionKey);\r\n            httpResponse.setHttpRequest(httpRequest);\r\n\r\n            if(httpRequest.getRequestURI().startsWith("/servlet")){\r\n              \t//本次请求动态资源\r\n           \t\tDynamicResourceProcess drp = new DynamicResourceProcess();\r\n                drp.process(httpRequest,httpResponse);\r\n            }else{\r\n              //本次请求静态资源\r\n              httpResponse.sendStaticResource();\r\n            }\r\n        \t...\r\n      }\r\n    } \r\n    ```\r\n\r\n+ Servlet优化\r\n\r\n  + 需求\r\n\r\n    将给浏览器响应的代码写到Servlet中\r\n\r\n  + 代码实现\r\n\r\n    ```java\r\n    public class UserServlet implements HttpServlet{\r\n\r\n        //处理浏览器请求的方法\r\n        //参数一\r\n        //由于后期可能根据用户请求的uri做出相应的处理.\r\n        //参数二\r\n        //要给用户响应数据,那么就需要使用到httpResponse.\r\n        public void service(HttpRequest httpRequest, HttpResponse httpResponse){\r\n            //模拟业务处理  ---- 就可以对这个手机号进行判断验证\r\n            System.out.println("UserServlet处理了用户的请求...");\r\n            //给浏览器响应\r\n            httpResponse.setContentTpye("text/html;charset=UTF-8");\r\n            httpResponse.write("ok,UserServlet处理了本次请求....");\r\n        }\r\n    }\r\n\r\n    public class DynamicResourceProcess {\r\n      \r\n        //执行指定动态资源的service方法\r\n        //参数一\r\n        //由于后期可能根据用户请求的uri做出相应的处理.\r\n        //参数二\r\n        //要给用户响应数据,那么就需要使用到httpResponse.\r\n        public void process(HttpRequest httpRequest,HttpResponse httpResponse) {\r\n            // 创建UserServlet对象,调用service方法,进行处理\r\n            UserServlet userServlet = new UserServlet();\r\n            userServlet.service(httpRequest,httpResponse);\r\n        }\r\n    }\r\n    ```\r\n\r\n### 3.5多个动态资源【理解】\r\n\r\n+ 多个动态资源\r\n\r\n  针对每一个业务操作，我们都会去定义一个对应的Servlet来完成。\r\n  就会在服务端产生很多个Servlet\r\n\r\n  ![12_多个动态资源](./img/java/basics/day25-基础加强01.img/12_多个动态资源.png)\r\n\r\n+ 实现步骤\r\n\r\n  + 定义一个接口HttpServlet，接口中定义service方法。\r\n  + 针对于每一种业务，都定义一个servlet类与之对应，该类实现HttpServlet接口\r\n  + 获取请求的uri，进行判断，调用不同的servlet类中的service方法\r\n\r\n+ 代码实现\r\n\r\n  ```java\r\n  // 1.定义一个接口HttpServlet，接口中定义service方法\r\n  public interface HttpServlet {\r\n\r\n      //定义业务处理的方法\r\n      public abstract void service(HttpRequest httpRequest, HttpResponse httpResponse);\r\n  }\r\n\r\n  // 2.针对于每一种业务，都定义一个servlet类与之对应，该类实现HttpServlet接口\r\n  public class UserServlet implements HttpServlet{\r\n      //处理浏览器请求的方法\r\n      //参数一\r\n      //由于后期可能根据用户请求的uri做出相应的处理.\r\n      //参数二\r\n      //要给用户响应数据,那么就需要使用到httpResponse.\r\n      public void service(HttpRequest httpRequest, HttpResponse httpResponse){\r\n          //模拟业务处理  ---- 就可以对这个手机号进行判断验证\r\n          System.out.println("UserServlet处理了用户的请求...");\r\n          //给浏览器响应\r\n          httpResponse.setContentTpye("text/html;charset=UTF-8");\r\n          httpResponse.write("ok,UserServlet处理了本次请求....");\r\n      }\r\n  }\r\n\r\n  public class LoginServlet implements HttpServlet{\r\n      @Override\r\n      public void service(HttpRequest httpRequest, HttpResponse httpResponse) {\r\n         //处理\r\n          System.out.println("LoginServlet处理了登录请求");\r\n         //响应\r\n          httpResponse.setContentTpye("text/html;charset=UTF-8");\r\n          httpResponse.write("登录成功");\r\n      }\r\n  }\r\n\r\n  public class RegisterServlet implements HttpServlet{\r\n      @Override\r\n      public void service(HttpRequest httpRequest, HttpResponse httpResponse) {\r\n         //处理\r\n          System.out.println("RegisterServlet处理了注册请求");\r\n         //响应\r\n          httpResponse.setContentTpye("text/html;charset=UTF-8");\r\n          httpResponse.write("注册成功");\r\n      }\r\n  }\r\n\r\n  public class SearchServlet implements HttpServlet{\r\n      @Override\r\n      public void service(HttpRequest httpRequest, HttpResponse httpResponse) {\r\n         //处理\r\n          System.out.println("SearchServlet处理了搜索商品请求");\r\n         //响应\r\n          httpResponse.setContentTpye("text/html;charset=UTF-8");\r\n          httpResponse.write("响应了一些商品信息");\r\n      }\r\n  }\r\n\r\n  // 3.获取请求的uri，进行判断，调用不同的servlet类中的service方法\r\n  public class DynamicResourceProcess {\r\n    \r\n      public void process(HttpRequest httpRequest,HttpResponse httpResponse){\r\n            //获取请求的uri\r\n            String requestURI = httpRequest.getRequestURI();\r\n   \r\n            //根据请求的uri进行判断\r\n            if("/servlet/loginservlet".equals(requestURI)){\r\n                //登录请求\r\n                LoginServlet loginServlet = new LoginServlet();\r\n                loginServlet.service(httpRequest,httpResponse);\r\n            }else if("/servlet/registerservlet".equals(requestURI)){\r\n                //注册请求\r\n                RegisterServlet registerServlet = new RegisterServlet();\r\n                registerServlet.service(httpRequest,httpResponse);\r\n            }else if("/servlet/searchservlet".equals(requestURI)){\r\n                //搜索商品请求\r\n                SearchServlet searchServlet = new SearchServlet();\r\n                searchServlet.service(httpRequest,httpResponse);\r\n            }else{\r\n                //表示默认处理方法\r\n                //创建UserServlet对象,调用service方法,进行处理\r\n                UserServlet userServlet = new UserServlet();\r\n                userServlet.service(httpRequest,httpResponse);\r\n            }\r\n        }\r\n  }\r\n  ```\r\n\r\n### 3.6通过反射和配置文件优化【理解】\r\n\r\n+ 优化步骤\r\n\r\n  1. 把Servlet信息写到properties配置文件中\r\n\r\n     格式为：servlet-info=/servlet/UserServlet，全类名；/servlet/loginServlet，全类名\r\n\r\n  2. 定义一个接口ServletConcurrentHashMap，接口中定义ConcurrentHashMap，该集合存储所有的servlet信息\r\n\r\n  3. 定义一个接口ParseServletConfig，该接口中定义一个方法（parse）\r\n\r\n  4. 定义ParseServletConfig的实现类，解析配置文件，并把配置文件中Servlet信息存到map集合中\r\n\r\n  5. 在main方法的第一行，开启一条线程执行解析配置文件的代码\r\n\r\n  6. 修改处理DynamicResourceProcess中的process方法\r\n\r\n     ![13_反射和配置文件优化](./img/java/basics/day25-基础加强01.img/13_反射和配置文件优化.png)\r\n\r\n+ 代码实现\r\n\r\n  ```java\r\n  // 1.把Servlet信息写到properties配置文件中\r\n  // 在webapp\\config\\servlet-info.properties文件中，写入如下内容\r\n  servlet-info=/servlet/loginservlet,com.itheima.myservlet.LoginServlet;/servlet/registerservlet,com.itheima.myservlet.RegisterServlet;/servlet/searchservlet,com.itheima.myservlet.SearchServlet;/servlet/lostpasswordservlet,com.itheima.myservlet.LostPasswordServlet\r\n\r\n  // 2.定义一个接口ServletConcurrentHashMap，接口中定义ConcurrentHashMap，该集合存储所有的servlet信息\r\n  public interface ServletConcurrentHashMap {\r\n      //存储请求路径和对应的servlet的map集合\r\n      //键: 请求的uri\r\n      //值: 对应的Servlet对象\r\n      public static final ConcurrentHashMap<String,  HttpServlet> map = new ConcurrentHashMap<>();\r\n  }\r\n\r\n  // 3.定义一个接口ParseServletConfig，该接口中定义一个方法（parse）\r\n  public interface ParseServletConfig {\r\n      //解析数据的方法\r\n      public abstract void parse();\r\n  }\r\n\r\n  // 4.定义ParseServletConfig的实现类，解析配置文件，并把配置文件中Servlet信息存到map集合中\r\n  public class PropertiesParseServletConfig implements ParseServletConfig {\r\n      @Override\r\n      public void parse() {\r\n\r\n          try {\r\n              //1.读取配置文件中的数据\r\n              Properties properties = new Properties();\r\n              FileReader fr = new FileReader("http-dynamic-server/webapp/config/servlet-info.properties");\r\n              properties.load(fr);\r\n              fr.close();\r\n\r\n              //2.获取集合中servlet-info的属性值\r\n              String properValue = (String) properties.get("servlet-info");\r\n              // uri,全类名;uri,全类名\r\n\r\n              //3.解析\r\n              String[] split = properValue.split(";");\r\n              for (String servletInfo : split) {\r\n                  String[] servletInfoArr = servletInfo.split(",");\r\n                  String uri = servletInfoArr[0];\r\n                  String servletName = servletInfoArr[1];\r\n\r\n                  //我们需要通过servletName(全类名)来创建他的对象\r\n                  Class clazz = Class.forName(servletName);\r\n                  HttpServlet httpServlet = (HttpServlet) clazz.newInstance();\r\n                  //4.将uri和httpServlet添加到map集合中\r\n                  ServletConcurrentHashMap.map.put(uri,httpServlet);\r\n              }\r\n          } catch (Exception e) {\r\n              System.out.println("解析数据异常.....");\r\n              e.printStackTrace();\r\n          }\r\n      }\r\n  }\r\n\r\n  public class LoaderResourceRunnable implements  Runnable {\r\n      @Override\r\n      public void run() {\r\n          //执行parse方法\r\n          ParseServletConfig parseServletConfig = new PropertiesParseServletConfig();\r\n          parseServletConfig.parse();\r\n          \r\n      }\r\n  }\r\n\r\n  // 5.在main方法的第一行，开启一条线程执行解析配置文件的代码\r\n  public class HttpServer {\r\n      public static void main(String[] args) throws IOException {\r\n          //开启一条线程去解析配置文件\r\n          new Thread(new LoaderResourceRunnable()).start();\r\n          ...\r\n      }\r\n  }\r\n\r\n  // 6.修改处理DynamicResourceProcess中的process方法\r\n  public class DynamicResourceProcess {\r\n    \r\n      public void process(HttpRequest httpRequest,HttpResponse httpResponse){\r\n            \t//获取请求的uri\r\n            \tString requestURI = httpRequest.getRequestURI();\r\n            \t//根据请求的uri到map集合中直接找到对应的servlet的对象\r\n          \tHttpServlet httpServlet = ServletConcurrentHashMap.map.get(requestURI);\r\n              //调用service方法对请求进行处理并响应\r\n              httpServlet.service(httpRequest,httpResponse);\r\n      }\r\n  }    \r\n  ```\r\n\r\n### 3.7Servlet忘记实现HttpServlet接口处理【理解】\r\n\r\n+ 出现情况\r\n\r\n  在写Servlet时，忘记了实现HttpServlet接口\r\n\r\n+ 导致结果\r\n\r\n  在反射创建对象后，强转成HttpServlet时，会报类型转换异常\r\n\r\n+ 解决方案\r\n\r\n  在反射创建对象后，强转成HttpServlet前，进行判断\r\n\r\n  如果有实现HttpServlet接口，就进行强转\r\n\r\n  否则抛出一个异常\r\n\r\n+ 代码实现\r\n\r\n  ```java\r\n  public class PropertiesParseServletConfig implements ParseServletConfig {\r\n      @Override\r\n      public void parse() {\r\n\r\n          try {\r\n              //1.读取配置文件中的数据\r\n              Properties properties = new Properties();\r\n              FileReader fr = new FileReader("http-dynamic-server/webapp/config/servlet-info.properties");\r\n              properties.load(fr);\r\n              fr.close();\r\n\r\n              //2.获取集合中servlet-info的属性值\r\n              String properValue = (String) properties.get("servlet-info");\r\n              // uri,全类名;uri,全类名\r\n\r\n              //3.解析\r\n              String[] split = properValue.split(";");\r\n              for (String servletInfo : split) {\r\n                  String[] servletInfoArr = servletInfo.split(",");\r\n                  String uri = servletInfoArr[0];\r\n                  String servletName = servletInfoArr[1];\r\n\r\n                  //我们需要通过servletName(全类名)来创建他的对象\r\n                  Class clazz = Class.forName(servletName);\r\n\r\n                  //获取该类所实现的所有的接口信息,得到的是一个数组\r\n                  Class[] interfaces = clazz.getInterfaces();\r\n\r\n                  //定义一个boolean类型的变量\r\n                  boolean flag =  false;\r\n                  //遍历数组\r\n                  for (Class clazzInfo : interfaces) {\r\n                      //判断当前所遍历的接口的字节码对象是否和HttpServlet的字节码文件对象相同\r\n                      if(clazzInfo == HttpServlet.class){\r\n\r\n                          //如果相同,就需要更改flag值.结束循环\r\n                          flag = true;\r\n                          break;\r\n                      }\r\n                  }\r\n\r\n                  if(flag){\r\n                      //true就表示当前的类已经实现了HttpServlet接口\r\n                      HttpServlet httpServlet = (HttpServlet) clazz.newInstance();\r\n                      //4.将uri和httpServlet添加到map集合中\r\n                      ServletConcurrentHashMap.map.put(uri,httpServlet);\r\n                  }else{\r\n                      //false就表示当前的类还没有实现HttpServlet接口\r\n                      throw new NotImplementsHttpServletException(clazz.getName() + "Not Implements HttpServlet");\r\n                  }\r\n              }\r\n          } catch (NotImplementsHttpServletException e) {\r\n              e.printStackTrace();\r\n          }catch (Exception e) {\r\n              System.out.println("解析数据异常.....");\r\n              e.printStackTrace();\r\n          }\r\n      }\r\n  }\r\n\r\n  ```\r\n\r\n### 3.8响应404【理解】\r\n\r\n+ 出现情况\r\n\r\n  客户端浏览器请求了一个服务器中不存在的动态资源\r\n\r\n+ 导致结果\r\n\r\n  服务器中代码出现异常，程序停止\r\n\r\n+ 解决方案\r\n\r\n  如果请求的动态资源不存在，服务器根据请求的uri找到对应的Servlet时为null，继续调用方法会出现异常\r\n\r\n  增加一个非空的判断，如果不为null，则继续处理请求，调用方法\r\n\r\n  如果为null，则响应404\r\n\r\n+ 代码实现\r\n\r\n  ```java\r\n  public class DynamicResourceProcess {\r\n      //执行指定动态资源的service方法\r\n      //参数一\r\n      //由于后期可能根据用户请求的uri做出相应的处理.\r\n      //参数二\r\n      //要给用户响应数据,那么就需要使用到httpResponse.\r\n      public void process(HttpRequest httpRequest,HttpResponse httpResponse){\r\n          //获取请求的uri\r\n          String requestURI = httpRequest.getRequestURI();\r\n          //根据请求的uri到map集合中直接找到对应的servlet的对象\r\n          HttpServlet httpServlet = ServletConcurrentHashMap.map.get(requestURI);\r\n          if(httpServlet != null){\r\n              //调用service方法对请求进行处理并响应\r\n              httpServlet.service(httpRequest,httpResponse);\r\n          }else{\r\n              //浏览器请求的动态资源不存在\r\n              //响应404\r\n              response404(httpResponse);\r\n          }\r\n      }\r\n      //浏览器请求动态资源不存在,响应404的方法\r\n      private void response404(HttpResponse httpResponse) {\r\n          try {\r\n              //准备响应行\r\n              String responseLine = "HTTP/1.1 404 NOT FOUND\\r\\n";\r\n              //准备响应头\r\n              String responseHeader = "Content-Type: text/html;charset=UTF-8\\r\\n";\r\n              //准备响应空行\r\n              String emptyLine = "\\r\\n";\r\n              //拼接在一起\r\n              String result = responseLine + responseHeader + emptyLine;\r\n\r\n              //把响应行,响应头,响应空行去响应给浏览器\r\n              SelectionKey selectionKey = httpResponse.getSelectionKey();\r\n              SocketChannel channel = (SocketChannel) selectionKey.channel();\r\n\r\n              ByteBuffer byteBuffer1 = ByteBuffer.wrap(result.getBytes());\r\n              channel.write(byteBuffer1);\r\n\r\n              //给浏览器 响应 响应体内容\r\n              ByteBuffer byteBuffer2 = ByteBuffer.wrap("404 NOT FOUND....".getBytes());\r\n              channel.write(byteBuffer2);\r\n\r\n              //释放资源\r\n              channel.close();\r\n          } catch (IOException e) {\r\n              e.printStackTrace();\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n  ​\r\n\r\n',te='## 1.xml\n\n### 1.1概述【理解】\n\n+ 万维网联盟(W3C)\n\n  万维网联盟(W3C)创建于1994年，又称W3C理事会。1994年10月在麻省理工学院计算机科学实验室成立。\n  建立者： Tim Berners-Lee (蒂姆·伯纳斯·李)。\n  是Web技术领域最具权威和影响力的国际中立性技术标准机构。\n  到目前为止，W3C已发布了200多项影响深远的Web技术标准及实施指南，\n\n  + 如广为业界采用的超文本标记语言HTML（标准通用标记语言下的一个应用）、\n\n  + 可扩展标记语言XML（标准通用标记语言下的一个子集）\n\n  + 以及帮助残障人士有效获得Web信息的无障碍指南（WCAG）等\n\n    ![01_w3c概述](./img/java/basics/day26-基础加强02.img/01_w3c概述.png)\n\n+ xml概述\n\n  XML的全称为(EXtensible Markup Language)，是一种可扩展的标记语言\n  标记语言: 通过标签来描述数据的一门语言(标签有时我们也将其称之为元素)\n  可扩展：标签的名字是可以自定义的,XML文件是由很多标签组成的,而标签名是可以自定义的\n\n+ 作用\n\n  + 用于进行存储数据和传输数据\n  + 作为软件的配置文件\n\n+ 作为配置文件的优势\n\n  + 可读性好\n  + 可维护性高\n\n### 1.2标签的规则【应用】\n\n+ 标签由一对尖括号和合法标识符组成\n\n  ```java\n  <student>\n  ```\n\n+ 标签必须成对出现\n\n  ```java\n  <student> </student>\n  前边的是开始标签，后边的是结束标签\n  ```\n\n+ 特殊的标签可以不成对,但是必须有结束标记\n\n  ```java\n  <address/>\n  ```\n\n+ 标签中可以定义属性,属性和标签名空格隔开,属性值必须用引号引起来\n\n  ```java\n  <student id="1"> </student>\n  ```\n\n+ 标签需要正确的嵌套\n\n  ```java\n  这是正确的: <student id="1"> <name>张三</name> </student>\n  这是错误的: <student id="1"><name>张三</student></name>\n  ```\n\n### 1.3语法规则【应用】\n\n+ 语法规则\n\n  + XML文件的后缀名为：xml\n\n  + 文档声明必须是第一行第一列\n\n    <?xml version=“1.0” encoding=“UTF-8” standalone=“yes”?>\n    version：该属性是必须存在的\n    encoding：该属性不是必须的\n\n    ​\t打开当前xml文件的时候应该是使用什么字符编码表(一般取值都是UTF-8)\n\n    standalone: 该属性不是必须的，描述XML文件是否依赖其他的xml文件，取值为yes/no\n\n  + 必须存在一个根标签，有且只能有一个\n\n  + XML文件中可以定义注释信息\n\n  + XML文件中可以存在以下特殊字符\n\n    ```java\n    &lt; < 小于\n    &gt; > 大于\n    &amp; & 和号\n    &apos; \' 单引号\n    &quot; " 引号\n    ```\n\n  + XML文件中可以存在CDATA区\n\n    <![CDATA[ …内容… ]]>\n\n+ 示例代码\n\n  ```xml\n  <?xml version="1.0" encoding="UTF-8" ?>\n  \x3c!--注释的内容--\x3e\n  \x3c!--本xml文件用来描述多个学生信息--\x3e\n  <students>\n\n      \x3c!--第一个学生信息--\x3e\n      <student id="1">\n          <name>张三</name>\n          <age>23</age>\n          <info>学生&lt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;的信息</info>\n          <message> <![CDATA[内容 <<<<<< >>>>>> ]]]></message>\n      </student>\n\n      \x3c!--第二个学生信息--\x3e\n      <student id="2">\n          <name>李四</name>\n          <age>24</age>\n      </student>\n\n  </students>\n  ```\n\n### 1.4xml解析【应用】\n\n+ 概述\n\n  xml解析就是从xml中获取到数据\n\n+ 常见的解析思想\n\n  DOM(Document Object Model)文档对象模型:就是把文档的各个组成部分看做成对应的对象。\n  会把xml文件全部加载到内存,在内存中形成一个树形结构,再获取对应的值\n\n  ![02_dom解析概述](./img/java/basics/day26-基础加强02.img/02_dom解析概述.png)\n\n+ 常见的解析工具\n\n  + JAXP: SUN公司提供的一套XML的解析的API\n  + JDOM: 开源组织提供了一套XML的解析的API-jdom\n  + DOM4J: 开源组织提供了一套XML的解析的API-dom4j,全称：Dom For Java\n  + pull: 主要应用在Android手机端解析XML\n\n+ 解析的准备工作\n\n  1. 我们可以通过网站：https://dom4j.github.io/ 去下载dom4j\n\n     今天的资料中已经提供,我们不用再单独下载了,直接使用即可\n\n  2. 将提供好的dom4j-1.6.1.zip解压,找到里面的dom4j-1.6.1.jar\n\n  3. 在idea中当前模块下新建一个libs文件夹,将jar包复制到文件夹中\n\n  4. 选中jar包 -> 右键 -> 选择add as library即可\n\n+ 需求\n\n  + 解析提供好的xml文件\n  + 将解析到的数据封装到学生对象中\n  + 并将学生对象存储到ArrayList集合中\n  + 遍历集合\n\n+ 代码实现\n\n  ```java\n  <?xml version="1.0" encoding="UTF-8" ?>\n  \x3c!--注释的内容--\x3e\n  \x3c!--本xml文件用来描述多个学生信息--\x3e\n  <students>\n\n      \x3c!--第一个学生信息--\x3e\n      <student id="1">\n          <name>张三</name>\n          <age>23</age>\n      </student>\n\n      \x3c!--第二个学生信息--\x3e\n      <student id="2">\n          <name>李四</name>\n          <age>24</age>\n      </student>\n\n  </students>\n\n  // 上边是已经准备好的student.xml文件\n  public class Student {\n      private String id;\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String id, String name, int age) {\n          this.id = id;\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getId() {\n          return id;\n      }\n\n      public void setId(String id) {\n          this.id = id;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public String toString() {\n          return "Student{" +\n                  "id=\'" + id + \'\\\'\' +\n                  ", name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n  }\n\n  /**\n   * 利用dom4j解析xml文件\n   */\n  public class XmlParse {\n      public static void main(String[] args) throws DocumentException {\n          //1.获取一个解析器对象\n          SAXReader saxReader = new SAXReader();\n          //2.利用解析器把xml文件加载到内存中,并返回一个文档对象\n          Document document = saxReader.read(new File("myxml\\\\xml\\\\student.xml"));\n          //3.获取到根标签\n          Element rootElement = document.getRootElement();\n          //4.通过根标签来获取student标签\n          //elements():可以获取调用者所有的子标签.会把这些子标签放到一个集合中返回.\n          //elements("标签名"):可以获取调用者所有的指定的子标签,会把这些子标签放到一个集合中并返回\n          //List list = rootElement.elements();\n          List<Element> studentElements = rootElement.elements("student");\n          //System.out.println(list.size());\n\n          //用来装学生对象\n          ArrayList<Student> list = new ArrayList<>();\n\n          //5.遍历集合,得到每一个student标签\n          for (Element element : studentElements) {\n              //element依次表示每一个student标签\n    \n              //获取id这个属性\n              Attribute attribute = element.attribute("id");\n              //获取id的属性值\n              String id = attribute.getValue();\n\n              //获取name标签\n              //element("标签名"):获取调用者指定的子标签\n              Element nameElement = element.element("name");\n              //获取这个标签的标签体内容\n              String name = nameElement.getText();\n\n              //获取age标签\n              Element ageElement = element.element("age");\n              //获取age标签的标签体内容\n              String age = ageElement.getText();\n\n  //            System.out.println(id);\n  //            System.out.println(name);\n  //            System.out.println(age);\n\n              Student s = new Student(id,name,Integer.parseInt(age));\n              list.add(s);\n          }\n          //遍历操作\n          for (Student student : list) {\n              System.out.println(student);\n          }\n      }\n  }\n  ```\n\n### 1.5DTD约束【理解】\n\n+ 什么是约束\n\n  用来限定xml文件中可使用的标签以及属性\n\n+ 约束的分类\n\n  + DTD\n  + schema\n\n+ 编写DTD约束\n\n  + 步骤\n\n    1. 创建一个文件，这个文件的后缀名为.dtd\n\n    2. 看xml文件中使用了哪些元素\n\n       <!ELEMENT> 可以定义元素\n\n    3. 判断元素是简单元素还是复杂元素\n\n       简单元素：没有子元素。\n       复杂元素：有子元素的元素；\n\n  + 代码实现\n\n    ```java\n    <!ELEMENT persons (person)>\n    <!ELEMENT person (name,age)>\n    <!ELEMENT name (#PCDATA)>\n    <!ELEMENT age (#PCDATA)>\n    ```\n  ```\n\n  ```\n\n+ 引入DTD约束\n\n  + 引入DTD约束的三种方法\n\n    + 引入本地dtd\n\n      <!DOCTYPE 根元素名称 SYSTEM ‘DTD文件的路径\'>\n\n    + 在xml文件内部引入\n\n      <!DOCTYPE 根元素名称 [ dtd文件内容 ]>\n\n    + 引入网络dtd\n\n      <!DOCTYPE 根元素的名称 PUBLIC "DTD文件名称" "DTD文档的URL">\n\n  + 代码实现\n\n    + 引入本地DTD约束\n\n      ```xml\n      // 这是persondtd.dtd文件中的内容,已经提前写好\n      <!ELEMENT persons (person)>\n      <!ELEMENT person (name,age)>\n      <!ELEMENT name (#PCDATA)>\n      <!ELEMENT age (#PCDATA)>\n\n      // 在person1.xml文件中引入persondtd.dtd约束\n      <?xml version="1.0" encoding="UTF-8" ?>\n      <!DOCTYPE persons SYSTEM \'persondtd.dtd\'>\n\n      <persons>\n          <person>\n              <name>张三</name>\n              <age>23</age>\n          </person>\n\n      </persons>\n      ```\n\n    + 在xml文件内部引入\n\n      ```xml\n      <?xml version="1.0" encoding="UTF-8" ?>\n      <!DOCTYPE persons [\n              <!ELEMENT persons (person)>\n              <!ELEMENT person (name,age)>\n              <!ELEMENT name (#PCDATA)>\n              <!ELEMENT age (#PCDATA)>\n              ]>\n\n      <persons>\n          <person>\n              <name>张三</name>\n              <age>23</age>\n          </person>\n\n      </persons>\n      ```\n\n    + 引入网络dtd\n\n      ```xml\n      <?xml version="1.0" encoding="UTF-8" ?>\n      <!DOCTYPE persons PUBLIC "dtd文件的名称" "dtd文档的URL">\n\n      <persons>\n          <person>\n              <name>张三</name>\n              <age>23</age>\n          </person>\n\n      </persons>\n      ```\n\n+ DTD语法\n\n  + 定义元素\n\n    定义一个元素的格式为：<!ELEMENT 元素名 元素类型>\n    简单元素：\n\n    ​\tEMPTY: 表示标签体为空\n\n    ​\tANY: 表示标签体可以为空也可以不为空\n\n    ​\tPCDATA: 表示该元素的内容部分为字符串\n\n    复杂元素：\n    ​\t直接写子元素名称. 多个子元素可以使用","或者"|"隔开；\n    ​\t","表示定义子元素的顺序 ; "|": 表示子元素只能出现任意一个\n    ​\t"?"零次或一次, "+"一次或多次, "*"零次或多次;如果不写则表示出现一次\n\n    ![03_DTD语法定义元素](./img/java/basics/day26-基础加强02.img/03_DTD语法定义元素.png)\n\n\n  + 定义属性\n\n    格式\n\n    定义一个属性的格式为：<!ATTLIST 元素名称 属性名称 属性的类型 属性的约束>\n    属性的类型：\n    ​\tCDATA类型：普通的字符串\n\n    属性的约束:\n\n    ​\t// #REQUIRED： 必须的\n    ​\t// #IMPLIED： 属性不是必需的\n    ​\t// #FIXED value：属性值是固定的\n\n  + 代码实现\n\n    ```java\n    <!ELEMENT persons (person+)>\n    <!ELEMENT person (name,age)>\n    <!ELEMENT name (#PCDATA)>\n    <!ELEMENT age (#PCDATA)>\n    <!ATTLIST person id CDATA #REQUIRED>\n\n    <?xml version="1.0" encoding="UTF-8" ?>\n    <!DOCTYPE persons SYSTEM \'persondtd.dtd\'>\n\n    <persons>\n        <person id="001">\n            <name>张三</name>\n            <age>23</age>\n        </person>\n\n        <person id = "002">\n            <name>张三</name>\n            <age>23</age>\n        </person>\n\n    </persons>\n    ​```\n    ```\n\n### 1.6schema约束【理解】\n\n+ schema和dtd的区别\n\n  1. schema约束文件也是一个xml文件，符合xml的语法，这个文件的后缀名.xsd\n  2. 一个xml中可以引用多个schema约束文件，多个schema使用名称空间区分（名称空间类似于java包名）\n  3. dtd里面元素类型的取值比较单一常见的是PCDATA类型，但是在schema里面可以支持很多个数据类型\n  4. schema 语法更加的复杂\n\n  ![04_schema约束介绍](./img/java/basics/day26-基础加强02.img/04_schema约束介绍.png)\n\n+ 编写schema约束\n\n  + 步骤\n\n    1，创建一个文件，这个文件的后缀名为.xsd。\n    2，定义文档声明\n    3，schema文件的根标签为： <schema>\n    4，在<schema>中定义属性：\n    ​\txmlns=http://www.w3.org/2001/XMLSchema\n    5，在<schema>中定义属性 ：\n    ​\ttargetNamespace =唯一的url地址，指定当前这个schema文件的名称空间。\n    6，在<schema>中定义属性 ：\n    ​\telementFormDefault="qualified“，表示当前schema文件是一个质量良好的文件。\n    7，通过element定义元素\n    8，判断当前元素是简单元素还是复杂元素\n\n    ![05_schema约束编写](./img/java/basics/day26-基础加强02.img/05_schema约束编写.png)\n\n  + 代码实现\n\n    ```java\n    <?xml version="1.0" encoding="UTF-8" ?>\n    <schema\n        xmlns="http://www.w3.org/2001/XMLSchema"\n        targetNamespace="http://www.itheima.cn/javase"\n        elementFormDefault="qualified"\n    >\n\n        \x3c!--定义persons复杂元素--\x3e\n        <element name="persons">\n            <complexType>\n                <sequence>\n                    \x3c!--定义person复杂元素--\x3e\n                    <element name = "person">\n                        <complexType>\n                            <sequence>\n                                \x3c!--定义name和age简单元素--\x3e\n                                <element name = "name" type = "string"></element>\n                                <element name = "age" type = "string"></element>\n                            </sequence>\n                            \n                        </complexType>\n                    </element>\n                </sequence>\n            </complexType>\n\n        </element>\n\n    </schema>\n\n    ```\n\n+ 引入schema约束\n\n  + 步骤\n\n    1，在根标签上定义属性xmlns="http://www.w3.org/2001/XMLSchema-instance"\n    2，通过xmlns引入约束文件的名称空间\n    3，给某一个xmlns属性添加一个标识，用于区分不同的名称空间\n    ​\t格式为: xmlns:标识=“名称空间地址” ,标识可以是任意的，但是一般取值都是xsi\n    4，通过xsi:schemaLocation指定名称空间所对应的约束文件路径\n    ​\t格式为：xsi:schemaLocation = "名称空间url 文件路径“\n\n  + 代码实现\n\n    ```java\n    <?xml version="1.0" encoding="UTF-8" ?>\n\n    <persons\n        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n        xmlns="http://www.itheima.cn/javase"\n        xsi:schemaLocation="http://www.itheima.cn/javase person.xsd"\n    >\n        <person>\n            <name>张三</name>\n            <age>23</age>\n        </person>\n\n    </persons>\n    ​```\n    ```\n\n+ schema约束定义属性\n\n  + 代码示例\n\n    ```java\n    <?xml version="1.0" encoding="UTF-8" ?>\n    <schema\n        xmlns="http://www.w3.org/2001/XMLSchema"\n        targetNamespace="http://www.itheima.cn/javase"\n        elementFormDefault="qualified"\n    >\n\n        \x3c!--定义persons复杂元素--\x3e\n        <element name="persons">\n            <complexType>\n                <sequence>\n                    \x3c!--定义person复杂元素--\x3e\n                    <element name = "person">\n                        <complexType>\n                            <sequence>\n                                \x3c!--定义name和age简单元素--\x3e\n                                <element name = "name" type = "string"></element>\n                                <element name = "age" type = "string"></element>\n                            </sequence>\n                            \n                            \x3c!--定义属性，required( 必须的)/optional( 可选的)--\x3e\n                            <attribute name="id" type="string" use="required"></attribute>\n                        </complexType>\n                        \n                    </element>\n                </sequence>\n            </complexType>\n        </element>\n        \n    </schema>\n\n    <?xml version="1.0" encoding="UTF-8" ?>\n    <persons\n        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n        xmlns="http://www.itheima.cn/javase"\n        xsi:schemaLocation="http://www.itheima.cn/javase person.xsd"\n    >\n        <person id="001">\n            <name>张三</name>\n            <age>23</age>\n        </person>\n\n    </persons>\n    ​```\n    ```\n\n### 1.7服务器改进【应用】\n\n+ 准备xml文件\n\n  1. 在当前模块下的webapp目录下新建一个文件夹，名字叫WEB-INF\n\n  2. 新建一个xml文件，名字叫web.xml\n\n  3. 将资料中的web.xml文件中引入约束的代码复制到新建的web.xml文件中\n\n  4. 将要解析的数据配置到xml文件中\n\n     ![06_配置要解析的Servlet数据](./img/java/basics/day26-基础加强02.img/06_配置要解析的Servlet数据.png)\n\n+ 需求\n\n  把uri和servlet信息放到一个concurrentHashMap集合当中\n  当浏览器请求一个动态资源时，我们会获取uri对应的servlet来处理当前业务\n\n+ 实现步骤\n\n  1. 导入dom4j的jar包\n  2. 定义一个XmlParseServletConfig类实现ParseServletConfig接口\n  3. 在parse方法里面就可以解析xml文件了\n\n+ 代码实现\n\n  ```java\n  // web.xml配置文件中配置的信息\n  <?xml version="1.0" encoding="UTF-8" ?>\n  <web-app xmlns="http://java.sun.com/xml/ns/javaee"\n           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n           xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"\n           version="2.5">\n\n      \x3c!--在以后需要配置servlet的时候，就直接在这里配置就可以了--\x3e\n      <servlet>\n          <servlet-name>LoginServlet</servlet-name>\n          <servlet-class>com.itheima.myservlet.LoginServlet</servlet-class>\n      </servlet>\n\n      <servlet-mapping>\n          <servlet-name>LoginServlet</servlet-name>\n          <url-pattern>/servlet/loginservlet</url-pattern>\n      </servlet-mapping>\n\n  </web-app>\n\n  // 定义一个XmlParseServletConfig类实现ParseServletConfig接口\n  public class XMLParseServletConfig implements ParseServletConfig {\n      //定义web.xml文件的路径\n      private static final String WEB_XML_PATH = "http-dynamic-server/webapp/WEB-INF/web.xml";\n\n  \t//在parse方法里面就可以解析xml文件了\n      @Override\n      public void parse() {\n          try {\n              //1.创建一个解析器对象(注意:如果解析器对象等不能使用,请检查一下jar包是否导入)\n              SAXReader saxReader = new SAXReader();\n\n              //2.利用解析器把xml文件读取到内存中\n              Document document = saxReader.read(new File(WEB_XML_PATH));\n\n              //3.获取根节点元素对象\n              Element rootElement = document.getRootElement();\n\n              //创建一个Map集合，用来存储servlet的配置信息\n              HashMap<String,String> servletInfoHashMap = new HashMap<>();\n\n              //4.获取根元素对象下所有的servlet元素的对象\n              List<Element> servletInfos = rootElement.elements("servlet");\n\n              //5.遍历集合，依次获取到每一个servlet标签对象\n              for (Element servletInfo : servletInfos) {\n                  //servletInfo依次表示每一个servlet标签对象\n\n                  //获取到servlet下的servlet-name元素对象，并且获取标签体内容\n                  String servletName = servletInfo.element("servlet-name").getText();\n                  //获取到servlet下的servlet-class元素对象，并且获取标签体内容\n                  String servletClass = servletInfo.element("servlet-class").getText();\n\n                  servletInfoHashMap.put(servletName,servletClass);\n              }\n\n              //--------------------servlet-mapping--------------------------------------\n              //获取到所有的servlet-mapping标签\n              List<Element> servletMappingInfos = rootElement.elements("servlet-mapping");\n              //遍历集合依次得到每一个servlet-mapping标签\n              for (Element servletMappingInfo : servletMappingInfos) {\n                  //servletMappingInfo依次表示每一个servlet-mapping标签\n\n                  //获取servlet-mapping标签标签中的servlet-name标签的标签体内容\n                  String servletName = servletMappingInfo.element("servlet-name").getText();\n\n                  //获取servlet-mapping标签标签中的url-pattern标签的标签体内容\n                  String urlPattern = servletMappingInfo.element("url-pattern").getText();\n\n                  //通过servletName来获取到servlet的全类名\n                  String servletClassName = servletInfoHashMap.get(servletName);\n\n                  //通过反射来创建这个servlet对象\n                  Class clazz = Class.forName(servletClassName);\n\n                  //获取该类所实现的所有的接口信息,得到的是一个数组\n                  Class[] interfaces = clazz.getInterfaces();\n\n                  //定义一个boolean类型的变量\n                  boolean flag =  false;\n                  //遍历数组\n                  for (Class clazzInfo : interfaces) {\n                      //判断当前所遍历的接口的字节码对象是否和HttpServlet的字节码文件对象相同\n                      if(clazzInfo == HttpServlet.class){\n\n                          //如果相同,就需要更改flag值.结束循环\n                          flag = true;\n                          break;\n                      }\n                  }\n\n                  if(flag){\n                      //true就表示当前的类已经实现了HttpServlet接口\n                      HttpServlet httpServlet = (HttpServlet) clazz.newInstance();\n                      //4.将uri和httpServlet添加到map集合中\n                      ServletConcurrentHashMap.map.put(urlPattern,httpServlet);\n                  }else{\n                      //false就表示当前的类还没有实现HttpServlet接口\n                      throw new NotImplementsHttpServletException(clazz.getName() + "Not Implements HttpServlet");\n                  }\n              }\n          } catch (NotImplementsHttpServletException e) {\n              e.printStackTrace();\n          }catch (Exception e) {\n              e.printStackTrace();\n          }\n      }\n  }\n\n  public class LoaderResourceRunnable implements  Runnable {\n      @Override\n      public void run() {\n  //        //执行parse方法\n  //        ParseServletConfig parseServletConfig = new PropertiesParseServletConfig();\n  //        parseServletConfig.parse();\n\n          ParseServletConfig parseServletConfig = new XMLParseServletConfig();\n          parseServletConfig.parse();\n\n      }\n  }\n  ```\n\n## 2.枚举\n\n### 2.1概述【理解】\n\n为了间接的表示一些固定的值，Java就给我们提供了枚举\n是指将变量的值一一列出来,变量的值只限于列举出来的值的范围内\n\n### 2.2定义格式【应用】\n\n+ 格式\n\n  ```java\n  public enum s {   \n  \t枚举项1,枚举项2,枚举项3;\n  }\n  注意: 定义枚举类要用关键字enum\n  ```\n\n+ 示例代码\n\n  ```java\n  // 定义一个枚举类，用来表示春，夏，秋，冬这四个固定值\n  public enum Season {\n      SPRING,SUMMER,AUTUMN,WINTER;\n  }\n  ```\n\n### 2.3枚举的特点【理解】\n\n+ 特点\n\n  + 所有枚举类都是Enum的子类\n\n  + 我们可以通过"枚举类名.枚举项名称"去访问指定的枚举项\n\n  + 每一个枚举项其实就是该枚举的一个对象\n\n  + 枚举也是一个类，也可以去定义成员变量\n\n  + 枚举类的第一行上必须是枚举项，最后一个枚举项后的分号是可以省略的，但是如果枚举类有其他的东西，这个分号就不能省略。建议不要省略\n\n  + 枚举类可以有构造器，但必须是private的，它默认的也是private的。\n\n    枚举项的用法比较特殊：枚举("");\n\n  + 枚举类也可以有抽象方法，但是枚举项必须重写该方法\n\n+ 示例代码\n\n  ```java\n  public enum Season {\n\n      SPRING("春"){\n\n          //如果枚举类中有抽象方法\n          //那么在枚举项中必须要全部重写\n          @Override\n          public void show() {\n              System.out.println(this.name);\n          }\n\n      },\n\n      SUMMER("夏"){\n          @Override\n          public void show() {\n              System.out.println(this.name);\n          }\n      },\n\n      AUTUMN("秋"){\n          @Override\n          public void show() {\n              System.out.println(this.name);\n          }\n      },\n\n      WINTER("冬"){\n          @Override\n          public void show() {\n              System.out.println(this.name);\n          }\n      };\n\n      public String name;\n\n      //空参构造\n      //private Season(){}\n    \n      //有参构造\n      private Season(String name){\n          this.name = name;\n      }\n    \n      //抽象方法\n      public abstract void show();\n  }\n\n  public class EnumDemo {\n      public static void main(String[] args) {\n          /*\n          1.所有枚举类都是Enum的子类\n          2.我们可以通过"枚举类名.枚举项名称"去访问指定的枚举项\n          3.每一个枚举项其实就是该枚举的一个对象\n          4.枚举也是一个类，也可以去定义成员变量\n          5.枚举类的第一行上必须是枚举项，最后一个枚举项后的分号是可以省略的，\n            但是如果枚举类有其他的东西，这个分号就不能省略。建议不要省略\n          6.枚举类可以有构造器，但必须是private的，它默认的也是private的。\n            枚举项的用法比较特殊：枚举("");\n          7.枚举类也可以有抽象方法，但是枚举项必须重写该方法\n      */\n    \n          //第二个特点的演示\n          //我们可以通过"枚举类名.枚举项名称"去访问指定的枚举项\n          System.out.println(Season.SPRING);\n          System.out.println(Season.SUMMER);\n          System.out.println(Season.AUTUMN);\n          System.out.println(Season.WINTER);\n    \n          //第三个特点的演示\n          //每一个枚举项其实就是该枚举的一个对象\n          Season spring = Season.SPRING;\n      }\n  }\n  ```\n\n### 2.4枚举的方法【应用】\n\n+ 方法介绍\n\n  | 方法名                                      | 说明                 |\n  | ---------------------------------------- | ------------------ |\n  | String name()                            | 获取枚举项的名称           |\n  | int ordinal()                            | 返回枚举项在枚举类中的索引值     |\n  | int compareTo(E  o)                      | 比较两个枚举项，返回的是索引值的差值 |\n  | String toString()                        | 返回枚举常量的名称          |\n  | static <T> T  valueOf(Class<T> type,String  name) | 获取指定枚举类中的指定名称的枚举值  |\n  | values()                                 | 获得所有的枚举项           |\n\n+ 示例代码\n\n  ```java\n  public enum Season {\n      SPRING,SUMMER,AUTUMN,WINTER;\n  }\n\n  public class EnumDemo {\n      public static void main(String[] args) {\n  //        String name() 获取枚举项的名称\n          String name = Season.SPRING.name();\n          System.out.println(name);\n          System.out.println("-----------------------------");\n\n  //        int ordinal() 返回枚举项在枚举类中的索引值\n          int index1 = Season.SPRING.ordinal();\n          int index2 = Season.SUMMER.ordinal();\n          int index3 = Season.AUTUMN.ordinal();\n          int index4 = Season.WINTER.ordinal();\n          System.out.println(index1);\n          System.out.println(index2);\n          System.out.println(index3);\n          System.out.println(index4);\n          System.out.println("-----------------------------");\n\n  //        int compareTo(E o) 比较两个枚举项，返回的是索引值的差值\n          int result = Season.SPRING.compareTo(Season.WINTER);\n          System.out.println(result);//-3\n          System.out.println("-----------------------------");\n\n  //        String toString()   返回枚举常量的名称\n          String s = Season.SPRING.toString();\n          System.out.println(s);\n          System.out.println("-----------------------------");\n\n  //        static <T> T valueOf(Class<T> type,String name)\n  //        获取指定枚举类中的指定名称的枚举值\n          Season spring = Enum.valueOf(Season.class, "SPRING");\n          System.out.println(spring);\n          System.out.println(Season.SPRING == spring);\n          System.out.println("-----------------------------");\n\n  //        values()       获得所有的枚举项\n          Season[] values = Season.values();\n          for (Season value : values) {\n              System.out.println(value);\n          }\n      }\n  }\n  ```\n\n## 3.注解\n\n### 3.1概述【理解】\n\n+ 概述\n\n  对我们的程序进行标注和解释\n\n+ 注解和注释的区别\n\n  + 注释: 给程序员看的\n  + 注解: 给编译器看的\n\n+ 使用注解进行配置配置的优势\n\n  代码更加简洁,方便\n\n### 3.2自定义注解【理解】\n\n+ 格式\n\n  public @interface 注解名称 {\n\n  ​\tpublic 属性类型 属性名() default 默认值 ;\n\n  }\n\n+ 属性类型\n\n  + 基本数据类型\n  + String\n  + Class\n  + 注解\n  + 枚举\n  + 以上类型的一维数组\n\n+ 代码演示\n\n  ```java\n  public @interface Anno2 {\n  }\n\n  public enum Season {\n      SPRING,SUMMER,AUTUMN,WINTER;\n  }\n\n  public @interface Anno1 {\n\n      //定义一个基本类型的属性\n      int a () default 23;\n\n      //定义一个String类型的属性\n      public String name() default "itheima";\n\n      //定义一个Class类型的属性\n      public Class clazz() default Anno2.class;\n\n      //定义一个注解类型的属性\n      public Anno2 anno() default @Anno2;\n\n      //定义一个枚举类型的属性\n      public Season season() default Season.SPRING;\n\n      //以上类型的一维数组\n      //int数组\n      public int[] arr() default {1,2,3,4,5};\n\n      //枚举数组\n      public Season[] seasons() default {Season.SPRING,Season.SUMMER};\n\n      //value。后期我们在使用注解的时候，如果我们只需要给注解的value属性赋值。\n      //那么value就可以省略\n      public String value();\n\n  }\n\n  //在使用注解的时候如果注解里面的属性没有指定默认值。\n  //那么我们就需要手动给出注解属性的设置值。\n  //@Anno1(name = "itheima")\n  @Anno1("abc")\n  public class AnnoDemo {\n  }\n  ```\n\n+ 注意\n\n  如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可\n\n+ 自定义注解案例\n\n  + 需求\n\n    自定义一个注解@Test,用于指定类的方法上,如果某一个类的方法上使用了该注解,就执行该方法\n\n  + 实现步骤\n\n    1. 自定义一个注解Test,并在类中的某几个方法上加上注解\n    2. 在测试类中,获取注解所在的类的Class对象\n    3. 获取类中所有的方法对象\n    4. 遍历每一个方法对象,判断是否有对应的注解\n\n  + 代码实现\n\n    ```java\n    //表示Test这个注解的存活时间\n    @Retention(value = RetentionPolicy.RUNTIME)\n    public @interface Test {\n    }\n\n    public class UseTest {\n\n        //没有使用Test注解\n        public void show(){\n            System.out.println("UseTest....show....");\n        }\n\n        //使用Test注解\n        @Test\n        public void method(){\n            System.out.println("UseTest....method....");\n        }\n\n        //没有使用Test注解\n        @Test\n        public void function(){\n            System.out.println("UseTest....function....");\n        }\n    }\n\n    public class AnnoDemo {\n        public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException {\n            //1.通过反射获取UseTest类的字节码文件对象\n            Class clazz = Class.forName("com.itheima.myanno3.UseTest");\n\n            //创建对象\n            UseTest useTest = (UseTest) clazz.newInstance();\n\n            //2.通过反射获取这个类里面所有的方法对象\n            Method[] methods = clazz.getDeclaredMethods();\n\n            //3.遍历数组，得到每一个方法对象\n            for (Method method : methods) {\n                //method依次表示每一个方法对象。\n                //isAnnotationPresent(Class<? extends Annotation> annotationClass)\n                //判断当前方法上是否有指定的注解。\n                //参数：注解的字节码文件对象\n                //返回值：布尔结果。  true 存在  false 不存在\n                if(method.isAnnotationPresent(Test.class)){\n                    method.invoke(useTest);\n                }\n            }\n        }\n    }\n    ```\n\n### 3.3元注解【理解】\n\n+ 概述\n\n  元注解就是描述注解的注解\n\n+ 元注解介绍\n\n  | 元注解名        | 说明                    |\n  | ----------- | --------------------- |\n  | @Target     | 指定了注解能在哪里使用           |\n  | @Retention  | 可以理解为保留时间(生命周期)       |\n  | @Inherited  | 表示修饰的自定义注解可以被子类继承     |\n  | @Documented | 表示该自定义注解，会出现在API文档里面。 |\n\n+ 示例代码\n\n  ```java\n  @Target({ElementType.FIELD,ElementType.TYPE,ElementType.METHOD})  //指定注解使用的位置（成员变量，类，方法）\n  @Retention(RetentionPolicy.RUNTIME) //指定该注解的存活时间\n  //@Inherited //指定该注解可以被继承\n  public @interface Anno {\n  }\n\n  @Anno\n  public class Person {\n  }\n\n  public class Student extends Person {\n      public void show(){\n          System.out.println("student.......show..........");\n      }\n  }\n\n  public class StudentDemo {\n      public static void main(String[] args) throws ClassNotFoundException {\n          //获取到Student类的字节码文件对象\n          Class clazz = Class.forName("com.itheima.myanno4.Student");\n\n          //获取注解。\n          boolean result = clazz.isAnnotationPresent(Anno.class);\n          System.out.println(result);\n      }\n  }\n\n  ```\n\n### 3.4改写服务器【理解】\n\n+ 需求\n\n  目前项目中Servlet和url对应关系,是配置在xml文件中的,将其改为在Servlet类上通过注解配置实现\n\n+ 实现步骤\n\n  1. 定义一个注解(@WebServlet),注解内有一个属性urlPatterns\n  2. 在servlet类上去使用该注解,来指定当前Servlet的访问路径\n  3. 创建一个注解解析类(AnnoParseServletConfig),该类实现ParseServletConfig接口\n  4. 实现parse方法\n\n+ 代码实现\n\n  ```java\n  @Target(ElementType.TYPE) //指定该注解可以使用在类上\n  @Retention(RetentionPolicy.RUNTIME)//指定该注解的存活时间 --- 为运行期\n  public @interface WebServlet {\n\n      //让用户去指定某一个Servlet在进行访问的时候所对应的请求uri\n      public String urlPatterns();\n  }\n\n  // 这里只给出了LoginServlet的配置,其他Servlet同理\n  @WebServlet(urlPatterns = "/servlet/loginservlet")\n  public class LoginServlet implements HttpServlet{\n      @Override\n      public void service(HttpRequest httpRequest, HttpResponse httpResponse) {\n         //处理\n          System.out.println("LoginServlet处理了登录请求");\n\n         //响应\n          httpResponse.setContentTpye("text/html;charset=UTF-8");\n          httpResponse.write("登录成功");\n      }\n  }\n\n  public class AnnoParseServletConfig implements ParseServletConfig {\n\n      //定义一个servlet路径所对应的常量\n      public static final String SERVLET_PATH = "http-dynamic-server\\\\src\\\\com\\\\itheima\\\\myservlet";\n    \n      //定义包名\n      public static final String SERVLET_PACKAGE_NAME = "com.itheima.myservlet.";\n    \n      @Override\n      public void parse() {\n          //获取类名\n  //  1.获得servlet所在文件夹的路径，并封装成File对象\n          File file = new File(SERVLET_PATH);\n  //  2.调用listFiles方法，获取文件夹下所有的File对象\n          File[] servletFiles = file.listFiles();\n  //  3.遍历数组，获取每一个File对象\n          for (File servletFile : servletFiles) {\n  //  4.获取File对象的名字（后缀名）\n              String servletFileName = servletFile.getName().replace(".java", "");\n  //  5.根据包名 + 类名 得到每一个类的全类名\n             String servletFullName = SERVLET_PACKAGE_NAME + servletFileName;\n              try {\n  //  6.通过全类名获取字节码文件对象\n                  Class servletClazz = Class.forName(servletFullName);\n                  //  7.判断该类是否有WebServlet注解\n                  if(servletClazz.isAnnotationPresent(WebServlet.class)){\n                  //  8.判断该Servlet类是否实现HttpServlet接口\n                      //获取该类所实现的所有的接口信息,得到的是一个数组\n                      Class[] interfaces = servletClazz.getInterfaces();\n    \n                      //定义一个boolean类型的变量\n                      boolean flag =  false;\n                      //遍历数组\n                      for (Class clazzInfo : interfaces) {\n                          //判断当前所遍历的接口的字节码对象是否和HttpServlet的字节码文件对象相同\n                          if(clazzInfo == HttpServlet.class){\n                              //如果相同,就需要更改flag值.结束循环\n                              flag = true;\n                              break;\n                          }\n                      }\n    \n                      if(flag){\n                          //  9.如果满足，则获取注解中的urlPattrens的值，\n                          WebServlet annotation = (WebServlet) servletClazz.getAnnotation(WebServlet.class);\n                          String uri = annotation.urlPatterns();\n    \n                          //  10.创建当前Servlet类对象存入值位置\n                          HttpServlet httpServlet = (HttpServlet) servletClazz.newInstance();\n                          //  11.存入集合的键位置\n                          ServletConcurrentHashMap.map.put(uri,httpServlet);\n                          //\n                      }else{\n                          //  12.如果不满足，抛出异常\n                          //false就表示当前的类还没有实现HttpServlet接口\n                          throw new NotImplementsHttpServletException(servletClazz.getName() + "Not Implements HttpServlet");\n                      }\n                  }\n              } catch (NotImplementsHttpServletException e) {\n                  e.printStackTrace();\n              } catch (Exception e) {\n                  e.printStackTrace();\n              }\n          }\n\n          }\n      }\n\n  public class LoaderResourceRunnable implements  Runnable {\n      @Override\n      public void run() {\n  //        //执行parse方法\n  //        ParseServletConfig parseServletConfig = new PropertiesParseServletConfig();\n  //        parseServletConfig.parse();\n\n  //        ParseServletConfig parseServletConfig = new XMLParseServletConfig();\n  //        parseServletConfig.parse();\n\n          ParseServletConfig parseServletConfig = new AnnoParseServletConfig();\n          parseServletConfig.parse();\n    \n      }\n  }\n  ```\n\n',re='\x3c!--\n * @Date           : 2021-04-27 00:39:22\n * @FilePath       : /jinnian-space/src/pages/java/module/basics/md/day27-基础加强03.md\n * @Description    : \n--\x3e\n## 1.管理系统与服务器集成\n\n### 1.1准备工作【应用】\n\n+ 需求\n\n  对之前写过的黑马信息管理系统进行改进,实现可以通过浏览器进行访问的功能\n\n+ 准备工作\n\n  + 将资料中的黑马管理系统代码拷贝到当前模块下\n\n  + 导包的代码可能报错,因为之前的包路径可能和当前代码不一致,将导包的代码修改下\n\n    ![02_要拷贝的包](./img/java/basics/day27-基础加强03.img/02_要拷贝的包.png)\n\n+ 业务分析\n\n  ![03_业务分析02](./img/java/basics/day27-基础加强03.img/03_业务分析02.png)\n\n  ![01_业务分析](./img/java/basics/day27-基础加强03.img/01_业务分析.png)\n\n  1. 解析URL封装到HttpReques对象\n  2. DynamicResourceProcess类（执行指定动态资源的service方法）\n  3. 定义servlet类完成查询学生、添加学生、删除学生、修改学生的逻辑\n\n+ 项目结构\n\n  ![04_包结构](./img/java/basics/day27-基础加强03.img/04_包结构.png)\n\n  ![05_三层结构](./img/java/basics/day27-基础加强03.img/05_三层结构.png)\n\n### 1.2HttpRequest类代码实现【应用】\n\n+ 实现步骤\n\n  1. 提供一个存储url中用户信息的map集合\n  2. 提供一个getParamter方法,用于根据请求参数的名称获取请求参数的值\n  3. 提供一个parseParamter方法,用于解析请求参数把请求参数存储到map集合中\n\n+ 代码实现\n\n  ```java\n  // 此处只给出了新增的代码,其他代码同之前没有变化\n  public class HttpRequest {\n     \n      //用来存储请求URL中问号后面的那些数据\n      //id=1  name=itheima\n      private Map<String,String> paramterHashMap = new HashMap<>();\n\n      //parse --- 获取请求数据 并解析\n      public void parse(){\n          try {\n              SocketChannel socketChannel = (SocketChannel) selectionKey.channel();\n              StringBuilder sb = new StringBuilder();\n              //创建一个缓冲区\n              ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n              int len;\n              //循环读取\n              while((len = socketChannel.read(byteBuffer)) > 0){\n                  byteBuffer.flip();\n                  sb.append(new String(byteBuffer.array(),0,len));\n                  //System.out.println(new String(byteBuffer.array(),0,len));\n                  byteBuffer.clear();\n              }\n              //System.out.println(sb);\n              parseHttpRequest(sb);\n\n              //解析请求参数，把请求参数存储到paramterHashMap集合\n              parseParamter();\n\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n      }\n\n      //解析请求参数，把请求参数存储到paramterHashMap集合\n      private void parseParamter(){\n          //获取请求的uri\n          String requestURI = this.requestURI;\n          //按照问号进行切割，然后再获取到第二部分\n          String[] uriInfoArr = requestURI.split("\\\\?");\n          //判断数组的长度，如果长度为2，说明是存在请求参数。\n          if(uriInfoArr.length == 2){\n              //获取请求参数内容（问号后面的那些参数）\n              String paramterInfo = uriInfoArr[1];\n\n              //使用&进行切割\n              String[] paramterInfoArr = paramterInfo.split("&");\n\n              //遍历数组\n              //id=1 name=itheima age =23\n              for (String paramter : paramterInfoArr) {\n                  String[] paramterArr = paramter.split("=");\n                  //获取请求参数名称\n                  String paramterName = paramterArr[0];\n                  //获取请求参数的值\n                  String paramterValue = paramterArr[1];\n                  //添加到集合中\n                  paramterHashMap.put(paramterName,paramterValue);\n              }\n          }\n      }\n    \n      //id=1 name=itheima\n      //可以根据请求参数的名称来获取请求参数的值\n      public String getParamter(String name){\n          return paramterHashMap.get(name);\n      }\n\n  }\n  ```\n\n### 1.3DynamicResourceProcess类代码实现【应用】\n\n+ 实现步骤\n\n  获取的uri是包含?后边的数据的,要进行切割,只要?号前边的内容\n\n\n+ 代码实现\n\n  ```java\n  // 此处只给出了新增的代码,其他代码同之前没有变化\n  public class DynamicResourceProcess {\n\n      public void process(HttpRequest httpRequest,HttpResponse httpResponse){\n          //获取请求的uri\n          String requestURI = httpRequest.getRequestURI();\n          //对requestURI进行切割操作\n          String[] split = requestURI.split("\\\\?");\n          //根据请求的uri到map集合中直接找到对应的servlet的对象\n          HttpServlet httpServlet = ServletConcurrentHashMap.map.get(split[0]);\n          System.out.println(httpServlet);\n        \t// ...\n      }\n  }  \n  ```\n\n### 1.4StudentServlet类代码实现【应用】\n\n+ 实现步骤\n\n  1. 在service方法中获取请求参数中的数据\n  2. 判断是要添加学生还是修改学生等\n  3. 调用对应的方法,执行对应的操作\n\n+ 代码实现\n\n  ```java\n  @WebServlet(urlPatterns = "/servlet/studentservlet")\n  public class StudentServlet implements HttpServlet {\n\n      @Override\n      public void service(HttpRequest httpRequest, HttpResponse httpResponse) {\n          //获取method请求参数\n          String method = httpRequest.getParamter("method");\n          System.out.println(method);\n          //判断\n          if ("addStudent".equals(method)) {\n              //添加学生\n              addStudent(httpRequest, httpResponse);\n          } else if ("delStudent".equals(method)) {\n              //删除学生\n              delStudent(httpRequest, httpResponse);\n          } else if ("updateStudent".equals(method)) {\n              //修改学生\n              updateStudent(httpRequest, httpResponse);\n          } else if ("findStudent".equals(method)) {\n              //查询学生\n              findStudent(httpRequest, httpResponse);\n          }\n      }\n\n      //查询学生\n      private void findStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n      }\n\n      //修改学生\n      private void updateStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n      }\n\n      //删除学生\n      private void delStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n      }\n\n      //添加学生\n      private void addStudent(HttpRequest httpRequest, HttpResponse httpResponse) {   \n      }\n  }\n  ```\n\n### 1.5查询学生【应用】\n\n+ 实现步骤\n\n  1. 创建StudentService对象\n  2. 调用StudentService中的findAllStudent方法，完成学生数据的查询操作\n  3. 遍历数组，拼接成一个字符串\n  4. 将拼接的结果响应给浏览器\n\n+ 代码实现\n\n  ```java\n  @WebServlet(urlPatterns = "/servlet/studentservlet")\n  public class StudentServlet implements HttpServlet {\n      //1.创建StudentService对象\n      private StudentService studentService = new StudentService();\n\n      @Override\n      public void service(HttpRequest httpRequest, HttpResponse httpResponse) {\n          //获取method请求参数\n\n          String method = httpRequest.getParamter("method");\n          System.out.println(method);\n          //判断\n          if ("addStudent".equals(method)) {\n              //添加学生\n              addStudent(httpRequest, httpResponse);\n          } else if ("delStudent".equals(method)) {\n              //删除学生\n              delStudent(httpRequest, httpResponse);\n          } else if ("updateStudent".equals(method)) {\n              //修改学生\n              updateStudent(httpRequest, httpResponse);\n          } else if ("findStudent".equals(method)) {\n              //查询学生\n              findStudent(httpRequest, httpResponse);\n          }\n      }\n\n      //查询学生\n      private void findStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n          //2.调用StudentService中的findAllStudent方法，完成学生数据的查询操作\n          Student[] allStudent = studentService.findAllStudent();\n          //3.遍历数组，拼接成一个字符串\n          StringBuilder sb = new StringBuilder();\n          for (Student student : allStudent) {\n              sb.append(student.getId()).append(", ").append(student.getName()).\n                      append(", ").append(student.getAge()).append(", ").\n                      append(student.getBirthday()).append("<br>");\n          }\n          String result = sb.toString();\n          //4.将拼接的结果响应给浏览器\n          //告诉浏览器响应的类型\n          httpResponse.setContentTpye("text/html;charset=UTF-8");\n          if (result == null || "".equals(result)) {\n              httpResponse.write("暂无学生数据。。。。");\n          } else {\n              httpResponse.write(result);\n          }\n      }\n      //修改学生\n      private void updateStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n      }\n\n      //删除学生\n      private void delStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n      }\n\n      //添加学生\n      private void addStudent(HttpRequest httpRequest, HttpResponse httpResponse) {   \n      }\n  }  \n  ```\n\n### 1.6添加学生【应用】\n\n+ 实现步骤\n\n  1. 获取id的请求参数\n  2. 判断id是否重复\n  3. 如果重复。给浏览器响应，id已经重复\n  4. 如果id不重复。添加学生。并给浏览器响应添加学生成功\n\n+ 代码实现\n\n  ```java\n  @WebServlet(urlPatterns = "/servlet/studentservlet")\n  public class StudentServlet implements HttpServlet {\n      //1.创建StudentService对象\n      private StudentService studentService = new StudentService();\n\n      @Override\n      public void service(HttpRequest httpRequest, HttpResponse httpResponse) {\n          //获取method请求参数\n\n          String method = httpRequest.getParamter("method");\n          System.out.println(method);\n          //判断\n          if ("addStudent".equals(method)) {\n              //添加学生\n              addStudent(httpRequest, httpResponse);\n          } else if ("delStudent".equals(method)) {\n              //删除学生\n              delStudent(httpRequest, httpResponse);\n          } else if ("updateStudent".equals(method)) {\n              //修改学生\n              updateStudent(httpRequest, httpResponse);\n          } else if ("findStudent".equals(method)) {\n              //查询学生\n              findStudent(httpRequest, httpResponse);\n          }\n      }\n\n      //查询学生\n      private void findStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n         //...\n      }\n      //修改学生\n      private void updateStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n      }\n      //删除学生\n      private void delStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n      }\n      //添加学生\n      private void addStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n          //1.获取id的请求参数\n          String id = httpRequest.getParamter("id");\n          //2.判断id是否重复\n          boolean exists = studentService.isExists(id);\n          httpResponse.setContentTpye("text/html;charset=UTF-8");\n          if (exists) {\n              //3.如果重复。给浏览器响应，id已经重复\n              httpResponse.write("id已经存在，请重新输入。。。");\n          } else {\n              //4.如果id不重复。添加学生。并给浏览器响应添加学生成功\n              String name = httpRequest.getParamter("name");\n              String age = httpRequest.getParamter("age");\n              String birthday = httpRequest.getParamter("birthday");\n              //对数据进行处理\n              try {\n                  int ageInt = Integer.parseInt(age);\n                  SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");\n                  Date date = sdf.parse(birthday);\n                  //创建一个学生对象\n                  Student s = new Student();\n                  s.setId(id);\n                  s.setName(name);\n                  s.setAge(age);\n                  s.setBirthday(birthday);\n                  //调用studentservice里面的方法\n                  studentService.addStudent(s);\n                  //给浏览器响应\n                  httpResponse.write("学生数据添加成功....");\n              } catch (ParseException e) {\n                  httpResponse.write("日期格式不正确，正确的格式为:yyyy-MM-dd");\n                  e.printStackTrace();\n              } catch (NumberFormatException e) {\n                  httpResponse.write("年龄只能为整数");\n                  e.printStackTrace();\n              }\n              //birthday  yyyy-MM-dd\n          }\n      }\n  }\n  ```\n\n## 2.单元测试\n\n### 2.1概述【理解】\n\nJUnit是一个 Java 编程语言的单元测试工具。JUnit 是一个非常重要的测试工具\n\n### 2.2特点【理解】\n\n+ JUnit是一个开放源代码的测试工具。\n+ 提供注解来识别测试方法。\n+ JUnit测试可以让你编写代码更快，并能提高质量。\n+ JUnit优雅简洁。没那么复杂，花费时间较少。\n+ JUnit在一个条中显示进度。如果运行良好则是绿色；如果运行失败，则变成红色。\n\n### 2.3使用步骤【应用】\n\n+ 使用步骤\n  1. 将junit的jar包导入到工程中 junit-4.9.jar\n  2. 编写测试方法该测试方法必须是公共的无参数无返回值的非静态方法\n  3. 在测试方法上使用@Test注解标注该方法是一个测试方法\n  4. 选中测试方法右键通过junit运行该方法\n\n+ 代码示例\n\n  ```java\n  public class JunitDemo1 {\n      @Test\n      public void add() {\n          System.out.println(2 / 0);\n          int a = 10;\n          int b = 20;\n          int sum = a + b;\n          System.out.println(sum);\n      }\n  }\n  ```\n\n### 2.4相关注解【应用】\n\n+ 注解说明\n\n  | 注解      | 含义        |\n  | ------- | --------- |\n  | @Test   | 表示测试该方法   |\n  | @Before | 在测试的方法前运行 |\n  | @After  | 在测试的方法后运行 |\n\n+ 代码示例\n\n  ```java\n  public class JunitDemo2 {\n      @Before\n      public void before() {\n        \t// 在执行测试代码之前执行，一般用于初始化操作\n          System.out.println("before");\n      }\n      @Test\n      public void test() {\n        \t// 要执行的测试代码\n          System.out.println("test");\n      }\n      @After\n      public void after() {\n        \t// 在执行测试代码之后执行，一般用于释放资源\n          System.out.println("after");\n      }\n  }\n  ```\n\n## 3.日志\n\n### 3.1概述【理解】\n\n+ 概述\n\n  程序中的日志可以用来记录程序在运行的时候点点滴滴。并可以进行永久存储。\n\n+ 日志与输出语句的区别\n\n  |      | 输出语句          | 日志技术                 |\n  | ---- | ------------- | -------------------- |\n  | 取消日志 | 需要修改代码，灵活性比较差 | 不需要修改代码，灵活性比较好       |\n  | 输出位置 | 只能是控制台        | 可以将日志信息写入到文件或者数据库中   |\n  | 多线程  | 和业务代码处于一个线程中  | 多线程方式记录日志，不影响业务代码的性能 |\n\n### 3.2日志体系结构和Log4J【理解】\n\n+ 体系结构\n\n  ![06_日志体系结构](./img/java/basics/day27-基础加强03.img/06_日志体系结构.png)\n\n+ Log4J\n\n  Log4j是Apache的一个开源项目。\n\n  通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件等位置。\n\n  我们也可以控制每一条日志的输出格式。\n\n  通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。\n\n  最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。\n\n+ Apache基金会\n\n  Apache软件基金会（也就是Apache Software Foundation，简称为ASF），为支持开源软件项目而办的一个非盈利性组织。\n\n### 3.3入门案例【应用】\n\n+ 使用步骤\n\n  1. 导入log4j的相关jar包\n  2. 编写log4j配置文件\n  3. 在代码中获取日志的对象\n  4. 按照级别设置记录日志信息\n\n+ 代码示例\n\n  ```java\n  // log4j的配置文件,名字为log4j.properties, 放在src根目录下\n  log4j.rootLogger=debug,my,fileAppender\n\n  ### direct log messages to my ###\n  log4j.appender.my=org.apache.log4j.ConsoleAppender\n  log4j.appender.my.ImmediateFlush = true\n  log4j.appender.my.Target=System.out\n  log4j.appender.my.layout=org.apache.log4j.PatternLayout\n  log4j.appender.my.layout.ConversionPattern=%d %t %5p %c{1}:%L - %m%n\n\n  # fileAppender��ʾ\n  log4j.appender.fileAppender=org.apache.log4j.FileAppender\n  log4j.appender.fileAppender.ImmediateFlush = true\n  log4j.appender.fileAppender.Append=true\n  log4j.appender.fileAppender.File=D:/log4j-log.log\n  log4j.appender.fileAppender.layout=org.apache.log4j.PatternLayout\n  log4j.appender.fileAppender.layout.ConversionPattern=%d %5p %c{1}:%L - %m%n\n\n  // 测试类\n  public class Log4JTest01 {\n\n      //使用log4j的api来获取日志的对象\n      //弊端：如果以后我们更换日志的实现类，那么下面的代码就需要跟着改\n      //不推荐使用\n      //private static final Logger LOGGER = Logger.getLogger(Log4JTest01.class);\n\n      //使用slf4j里面的api来获取日志的对象\n      //好处：如果以后我们更换日志的实现类，那么下面的代码不需要跟着修改\n      //推荐使用\n      private static  final Logger LOGGER = LoggerFactory.getLogger(Log4JTest01.class);\n\n      public static void main(String[] args) {\n          //1.导入jar包\n          //2.编写配置文件\n          //3.在代码中获取日志的对象\n          //4.按照日志级别设置日志信息\n          LOGGER.debug("debug级别的日志");\n          LOGGER.info("info级别的日志");\n          LOGGER.warn("warn级别的日志");\n          LOGGER.error("error级别的日志");\n      }\n  }\n  ```\n\n### 3.4配置文件详解【理解】\n\n+ 三个核心\n\n  + Loggers(记录器)        日志的级别\n\n    Loggers组件在此系统中常见的五个级别：DEBUG、INFO、WARN、ERROR 和 FATAL。\n\n    DEBUG < INFO < WARN < ERROR < FATAL。\n\n    Log4j有一个规则：只输出级别不低于设定级别的日志信息。\n\n  + Appenders(输出源)   日志要输出的地方\n\n    把日志输出到不同的地方，如控制台（Console）、文件（Files）等。\n\n    + org.apache.log4j.ConsoleAppender（控制台）\n    + org.apache.log4j.FileAppender（文件）\n\n  + Layouts(布局)             日志输出的格式\n\n    可以根据自己的喜好规定日志输出的格式\n\n    常用的布局管理器：\n\n    ​\t\torg.apache.log4j.PatternLayout（可以灵活地指定布局模式）\n\n    ​          \torg.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）\n\n     \t\torg.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等信息）\n\n+ 配置根Logger\n\n  + 格式\n\n    log4j.rootLogger=日志级别，appenderName1，appenderName2，…\n\n  + 日志级别\n\n    OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者自定义的级别。\n\n  + appenderName1\n\n    就是指定日志信息要输出到哪里。可以同时指定多个输出目的地，用逗号隔开。\n\n    例如：log4j.rootLogger＝INFO，ca，fa\n\n+ ConsoleAppender常用的选项\n\n  + ImmediateFlush=true\n\n    表示所有消息都会被立即输出，设为false则不输出，默认值是true。\n\n  + Target=System.err\n\n    默认值是System.out。\n\n+ FileAppender常用的选项\n\n  + ImmediateFlush=true\n\n    表示所有消息都会被立即输出。设为false则不输出，默认值是true\n\n  + Append=false\n\n    true表示将消息添加到指定文件中，原来的消息不覆盖。\n\n    false则将消息覆盖指定的文件内容，默认值是true。\n\n  + File=D:/logs/logging.log4j\n\n    指定消息输出到logging.log4j文件中\n\n+ PatternLayout常用的选项\n\n  + ConversionPattern=%m%n\n\n    设定以怎样的格式显示消息\n\n    ![07_PatternLayout常用的选项](./img/java/basics/day27-基础加强03.img/07_PatternLayout常用的选项.png)\n\n### 3.5在项目中的应用【应用】\n\n+ 步骤\n\n  1. 导入相关的依赖\n  2. 将资料中的properties配置文件复制到src目录下\n  3. 在代码中获取日志的对象\n  4. 按照级别设置记录日志信息\n\n+ 代码实现\n\n  ```java\n  @WebServlet(urlPatterns = "/servlet/loginservlet")\n  public class LoginServlet implements HttpServlet{\n\n      //获取日志的对象\n      private static final Logger LOGGER = LoggerFactory.getLogger(LoginServlet.class);\n\n      @Override\n      public void service(HttpRequest httpRequest, HttpResponse httpResponse) {\n         //处理\n          System.out.println("LoginServlet处理了登录请求");\n\n          LOGGER.info("现在已经处理了登录请求，准备给浏览器响应");\n\n         //响应\n          httpResponse.setContentTpye("text/html;charset=UTF-8");\n          httpResponse.write("登录成功");\n      }\n  }\n  ```\n\n',ae={data:function(){return{MainComponent1:ee,MainComponent2:te,MainComponent3:re}}},ie=ae,se=Object(d["a"])(ie,Zn,ne,!1,null,"3590c4ee",null),oe=se.exports,le=t("3686"),ce=t("1b62"),pe=Object(le["a"])(t("20e7"),"md",!0),ue=pe.all_components,me=pe.all_modules,de={mixins:[ce["c"],ce["b"]],components:{m99:S,m1:I,m2:L,m3:N,m4:Q,m5:en,m6:un,m7:yn,m8:Dn,m9:kn,m10:Gn,m11:Yn,m12:oe},data:function(){return{img_prefix:"./books/java/basic/",tab:"m1",tab_level:2,tabs:[{label:"基础笔记",value:"m99"},{label:"Java基础语法",value:"m1"},{label:"面向对象基础",value:"m2"},{label:"API基础",value:"m3"},{label:"集合基础",value:"m4"},{label:"Git",value:"m5"},{label:"面向对象进阶",value:"m6"},{label:"常用API&异常",value:"m7"},{label:"集合",value:"m8"},{label:"IO流",value:"m9"},{label:"多线程",value:"m10"},{label:"网络编程",value:"m11"},{label:"基础加强",value:"m12"}].concat(l()(me))}},watch:{tab:function(n,e){this.MainComponent=ue[this.tab]}}},ge=de,Se=Object(d["a"])(ge,i,s,!1,null,"46ba5dfe",null),ve=Se.exports,be=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[t(""+n.tab,{tag:"component"})],1)},he=[],ye=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},fe=[],xe='\x3c!--\r\n * @Date           : 2021-04-12 16:03:11\r\n * @FilePath       : /jinnian-space/src/pages/java/module/jdbc/md/JDBC-01-授课笔记.md\r\n * @Description    : \r\n--\x3e\r\n# JDBC-01-授课笔记\r\n\r\n### 一、JDBC快速入门\r\n\r\n#### 1.jdbc的概念\r\n \r\n\r\n- JDBC（Java DataBase Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系型数据库提供统一访问，它是由一组用Java语言编写的类和接口组成的。\r\n\r\n#### 2.jdbc的本质\r\n\r\n- 其实就是java官方提供的一套规范(接口)。用于帮助开发人员快速实现不同关系型数据库的连接！\r\n\r\n#### 3.jdbc的快速入门程序\r\n\r\n1. 导入jar包\r\n\r\n2. 注册驱动\r\n\r\n   ```java\r\n   Class.forName("com.mysql.jdbc.Driver");\r\n   ```\r\n\r\n3. 获取连接\r\n\r\n   ```java\r\n   Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/db2", "root", "root");\r\n   ```\r\n\r\n4. 获取执行者对象\r\n\r\n   ```java\r\n   Statement stat = con.createStatement();\r\n   ```\r\n\r\n5. 执行sql语句，并接收返回结果\r\n\r\n   ```java\r\n   String sql = "SELECT * FROM user";\r\n   ResultSet rs = stat.executeQuery(sql);\r\n   ```\r\n\r\n6. 处理结果\r\n\r\n   ```java\r\n   while(rs.next()) {\r\n       System.out.println(rs.getInt("id") + "\\t" + rs.getString("name"));\r\n   }\r\n   ```\r\n\r\n7. 释放资源\r\n\r\n   ```java\r\n   con.close();\r\n   stat.close();\r\n   rs.close();\r\n   ```\r\n\r\n### 二、JDBC各个功能类详解\r\n\r\n#### 1.DriverManager\r\n\r\n- DriverManager：驱动管理对象\r\n\r\n  - 注册驱动(告诉程序该使用哪一个数据库驱动)\r\n\r\n    - static void registerDriver(Driver driver)：注册与给定的驱动程序 DriverManager \r\n    - 写代码使用：Class.forName("com.mysql.jdbc.Driver");\r\n    - 通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块\r\n\r\n    ```java\r\n    static {\r\n    \ttry {\r\n    \t\tjava.sql.DriverManager.registerDriver(new Driver());\r\n    \t} catch (SQLException E) {\r\n    \t\tthrow new RuntimeException("Can\'t register driver!");\r\n    \t}\r\n    }\r\n    ```\r\n\r\n    - 注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。在jar包中，存在一个java.sql.Driver配置文件，文件中指定了com.mysql.jdbc.Driver\r\n\r\n  - 获取数据库连接(获取到数据库的连接并返回连接对象)\r\n\r\n    - static Connection getConnection(String url, String user, String password);\r\n      - 返回值：Connection数据库连接对象\r\n      - 参数\r\n        - url：指定连接的路径。语法：jdbc:mysql://ip地址(域名):端口号/数据库名称\r\n        - user：用户名\r\n        - password：密码\r\n\r\n#### 2.Connection\r\n\r\n- Connection：数据库连接对象\r\n  - 获取执行者对象\r\n    - 获取普通执行者对象：Statement createStatement();\r\n    - 获取预编译执行者对象：PreparedStatement prepareStatement(String sql);\r\n  - 管理事务\r\n    - 开启事务：setAutoCommit(boolean autoCommit);     参数为false，则开启事务。\r\n    - 提交事务：commit();\r\n    - 回滚事务：rollback();\r\n  - 释放资源\r\n    - 立即将数据库连接对象释放：void close();\r\n\r\n#### 3.Statement\r\n\r\n- Statement：执行sql语句的对象\r\n  - 执行DML语句：int executeUpdate(String sql);\r\n    - 返回值int：返回影响的行数。\r\n    - 参数sql：可以执行insert、update、delete语句。\r\n  - 执行DQL语句：ResultSet executeQuery(String sql);\r\n    - 返回值ResultSet：封装查询的结果。\r\n    - 参数sql：可以执行select语句。\r\n  - 释放资源\r\n    - 立即将执行者对象释放：void close();\r\n\r\n#### 4.ResultSet\r\n\r\n- ResultSet：结果集对象\r\n  - 判断结果集中是否还有数据：boolean next();\r\n    - 有数据返回true，并将索引向下移动一行\r\n    - 没有数据返回false\r\n  - 获取结果集中的数据：XXX getXxx("列名");\r\n    - XXX代表数据类型(要获取某列数据，这一列的数据类型)\r\n    - 例如：String getString("name");          int getInt("age");\r\n  - 释放资源\r\n    - 立即将结果集对象释放：void close();\r\n\r\n### 三、JDBC案例student学生表的CRUD\r\n\r\n#### 1.数据准备\r\n\r\n- 数据库和数据表\r\n\r\n```mysql\r\n-- 创建db14数据库\r\nCREATE DATABASE db14;\r\n\r\n-- 使用db14数据库\r\nUSE db14;\r\n\r\n-- 创建student表\r\nCREATE TABLE student(\r\n\tsid INT PRIMARY KEY AUTO_INCREMENT,\t-- 学生id\r\n\tNAME VARCHAR(20),\t\t\t\t\t-- 学生姓名\r\n\tage INT,\t\t\t\t\t\t\t-- 学生年龄\r\n\tbirthday DATE\t\t\t\t\t\t-- 学生生日\r\n);\r\n\r\n-- 添加数据\r\nINSERT INTO student VALUES (NULL,\'张三\',23,\'1999-09-23\'),(NULL,\'李四\',24,\'1998-08-10\'),(NULL,\'王五\',25,\'1996-06-06\'),(NULL,\'赵六\',26,\'1994-10-20\');\r\n```\r\n\r\n- 实体类\r\n  - Student类，成员变量对应表中的列\r\n  - 注意：所有的基本数据类型需要使用包装类，以防null值无法赋值\r\n\r\n```java\r\npackage com.itheima02.domain;\r\n\r\nimport java.util.Date;\r\n\r\npublic class Student {\r\n    private Integer sid;\r\n    private String name;\r\n    private Integer age;\r\n    private Date birthday;\r\n\r\n    public Student() {\r\n    }\r\n\r\n    public Student(Integer sid, String name, Integer age, Date birthday) {\r\n        this.sid = sid;\r\n        this.name = name;\r\n        this.age = age;\r\n        this.birthday = birthday;\r\n    }\r\n\r\n    public Integer getSid() {\r\n        return sid;\r\n    }\r\n\r\n    public void setSid(Integer sid) {\r\n        this.sid = sid;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public Integer getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(Integer age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public Date getBirthday() {\r\n        return birthday;\r\n    }\r\n\r\n    public void setBirthday(Date birthday) {\r\n        this.birthday = birthday;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return "Student{" +\r\n                "sid=" + sid +\r\n                ", name=\'" + name + \'\\\'\' +\r\n                ", age=" + age +\r\n                ", birthday=" + birthday +\r\n                \'}\';\r\n    }\r\n}\r\n```\r\n\r\n#### 2.需求一：查询全部\r\n\r\n- 持久层\r\n\r\n```java\r\n/*\r\n     查询所有学生信息\r\n*/\r\n@Override\r\npublic ArrayList<Student> findAll() {\r\n    ArrayList<Student> list = new ArrayList<>();\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    ResultSet rs = null;\r\n    try{\r\n        //1.注册驱动\r\n        Class.forName("com.mysql.jdbc.Driver");\r\n\r\n        //2.获取数据库连接\r\n        con = DriverManager.getConnection("jdbc:mysql://192.168.59.129:3306/db14", "root", "itheima");\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        String sql = "SELECT * FROM student";\r\n        rs = stat.executeQuery(sql);\r\n\r\n        //5.处理结果集\r\n        while(rs.next()) {\r\n            Integer sid = rs.getInt("sid");\r\n            String name = rs.getString("name");\r\n            Integer age = rs.getInt("age");\r\n            Date birthday = rs.getDate("birthday");\r\n\r\n            //封装Student对象\r\n            Student stu = new Student(sid,name,age,birthday);\r\n\r\n            //将student对象保存到集合中\r\n            list.add(stu);\r\n        }\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        if(con != null) {\r\n            try {\r\n                con.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if(stat != null) {\r\n            try {\r\n                stat.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if(rs != null) {\r\n            try {\r\n                rs.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n    //将集合对象返回\r\n    return list;\r\n}\r\n```\r\n\r\n- 业务层\r\n\r\n```java\r\n/*\r\n    查询所有学生信息\r\n*/\r\n@Override\r\npublic ArrayList<Student> findAll() {\r\n    return dao.findAll();\r\n}\r\n```\r\n\r\n- 控制层\r\n\r\n```java\r\n/*\r\n    查询所有学生信息\r\n*/\r\n@Test\r\npublic void findAll() {\r\n    ArrayList<Student> list = service.findAll();\r\n    for(Student stu : list) {\r\n        System.out.println(stu);\r\n    }\r\n}\r\n```\r\n\r\n#### 3.需求二：条件查询\r\n\r\n- 持久层\r\n\r\n```java\r\n/*\r\n    条件查询，根据id查询学生信息\r\n*/\r\n@Override\r\npublic Student findById(Integer id) {\r\n    Student stu = new Student();\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    ResultSet rs = null;\r\n    try{\r\n        //1.注册驱动\r\n        Class.forName("com.mysql.jdbc.Driver");\r\n\r\n        //2.获取数据库连接\r\n        con = DriverManager.getConnection("jdbc:mysql://192.168.59.129:3306/db14", "root", "itheima");\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        String sql = "SELECT * FROM student WHERE sid=\'"+id+"\'";\r\n        rs = stat.executeQuery(sql);\r\n\r\n        //5.处理结果集\r\n        while(rs.next()) {\r\n            Integer sid = rs.getInt("sid");\r\n            String name = rs.getString("name");\r\n            Integer age = rs.getInt("age");\r\n            Date birthday = rs.getDate("birthday");\r\n\r\n            //封装Student对象\r\n            stu.setSid(sid);\r\n            stu.setName(name);\r\n            stu.setAge(age);\r\n            stu.setBirthday(birthday);\r\n        }\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        if(con != null) {\r\n            try {\r\n                con.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if(stat != null) {\r\n            try {\r\n                stat.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if(rs != null) {\r\n            try {\r\n                rs.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n    //将对象返回\r\n    return stu;\r\n}\r\n```\r\n\r\n- 业务层\r\n\r\n```java\r\n/*\r\n    条件查询，根据id查询学生信息\r\n*/\r\n@Override\r\npublic Student findById(Integer id) {\r\n    return dao.findById(id);\r\n}\r\n```\r\n\r\n- 控制层\r\n\r\n```java\r\n/*\r\n    条件查询，根据id查询学生信息\r\n*/\r\n@Test\r\npublic void findById() {\r\n    Student stu = service.findById(3);\r\n    System.out.println(stu);\r\n}\r\n```\r\n\r\n#### 4.需求三：新增数据\r\n\r\n- 持久层\r\n\r\n```java\r\n/*\r\n      添加学生信息\r\n*/\r\n@Override\r\npublic int insert(Student stu) {\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    int result = 0;\r\n    try{\r\n        //1.注册驱动\r\n        Class.forName("com.mysql.jdbc.Driver");\r\n\r\n        //2.获取数据库连接\r\n        con = DriverManager.getConnection("jdbc:mysql://192.168.59.129:3306/db14", "root", "itheima");\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        Date d = stu.getBirthday();\r\n        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");\r\n        String birthday = sdf.format(d);\r\n        String sql = "INSERT INTO student VALUES (\'"+stu.getSid()+"\',\'"+stu.getName()+"\',\'"+stu.getAge()+"\',\'"+birthday+"\')";\r\n        result = stat.executeUpdate(sql);\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        if(con != null) {\r\n            try {\r\n                con.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if(stat != null) {\r\n            try {\r\n                stat.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n    //将结果返回\r\n    return result;\r\n}\r\n```\r\n\r\n- 业务层\r\n\r\n```java\r\n/*\r\n    新增学生信息\r\n*/\r\n@Override\r\npublic int insert(Student stu) {\r\n    return dao.insert(stu);\r\n}\r\n```\r\n\r\n- 控制层\r\n\r\n```java\r\n/*\r\n  \t新增学生信息\r\n*/\r\n@Test\r\npublic void insert() {\r\n    Student stu = new Student(5,"周七",27,new Date());\r\n    int result = service.insert(stu);\r\n    if(result != 0) {\r\n        System.out.println("新增成功");\r\n    }else {\r\n        System.out.println("新增失败");\r\n    }\r\n}\r\n```\r\n\r\n#### 5.需求四：修改数据\r\n\r\n- 持久层\r\n\r\n```java\r\n/*\r\n    修改学生信息\r\n*/\r\n@Override\r\npublic int update(Student stu) {\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    int result = 0;\r\n    try{\r\n        //1.注册驱动\r\n        Class.forName("com.mysql.jdbc.Driver");\r\n\r\n        //2.获取数据库连接\r\n        con = DriverManager.getConnection("jdbc:mysql://192.168.59.129:3306/db14", "root", "itheima");\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        Date d = stu.getBirthday();\r\n        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");\r\n        String birthday = sdf.format(d);\r\n        String sql = "UPDATE student SET sid=\'"+stu.getSid()+"\',name=\'"+stu.getName()+"\',age=\'"+stu.getAge()+"\',birthday=\'"+birthday+"\' WHERE sid=\'"+stu.getSid()+"\'";\r\n        result = stat.executeUpdate(sql);\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        if(con != null) {\r\n            try {\r\n                con.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if(stat != null) {\r\n            try {\r\n                stat.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n    //将结果返回\r\n    return result;\r\n}\r\n```\r\n\r\n- 业务层\r\n\r\n```java\r\n/*\r\n    修改学生信息\r\n*/\r\n@Override\r\npublic int update(Student stu) {\r\n    return dao.update(stu);\r\n}\r\n```\r\n\r\n- 控制层\r\n\r\n```java\r\n/*\r\n    修改学生信息\r\n*/\r\n@Test\r\npublic void update() {\r\n    Student stu = service.findById(5);\r\n    stu.setName("周七七");\r\n\r\n    int result = service.update(stu);\r\n    if(result != 0) {\r\n        System.out.println("修改成功");\r\n    }else {\r\n        System.out.println("修改失败");\r\n    }\r\n}\r\n```\r\n\r\n#### 6.需求五：删除数据\r\n\r\n- 持久层\r\n\r\n```java\r\n/*\r\n    删除学生信息\r\n*/\r\n@Override\r\npublic int delete(Integer id) {\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    int result = 0;\r\n    try{\r\n        //1.注册驱动\r\n        Class.forName("com.mysql.jdbc.Driver");\r\n\r\n        //2.获取数据库连接\r\n        con = DriverManager.getConnection("jdbc:mysql://192.168.59.129:3306/db14", "root", "itheima");\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        String sql = "DELETE FROM student WHERE sid=\'"+id+"\'";\r\n        result = stat.executeUpdate(sql);\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        if(con != null) {\r\n            try {\r\n                con.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if(stat != null) {\r\n            try {\r\n                stat.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n    //将结果返回\r\n    return result;\r\n}\r\n```\r\n\r\n- 业务层\r\n\r\n```java\r\n/*\r\n    删除学生信息\r\n*/\r\n@Override\r\npublic int delete(Integer id) {\r\n    return dao.delete(id);\r\n}\r\n```\r\n\r\n- 控制层\r\n\r\n```java\r\n/*\r\n    删除学生信息\r\n*/\r\n@Test\r\npublic void delete() {\r\n    int result = service.delete(5);\r\n\r\n    if(result != 0) {\r\n        System.out.println("删除成功");\r\n    }else {\r\n        System.out.println("删除失败");\r\n    }\r\n}\r\n```\r\n\r\n### 四、JDBC工具类\r\n\r\n#### 1.工具类的抽取\r\n\r\n- 配置文件(在src下创建config.properties)\r\n\r\n```properties\r\ndriverClass=com.mysql.jdbc.Driver\r\nurl=jdbc:mysql://localhost:3306/db14\r\nusername=root\r\npassword=itheima\r\n```\r\n\r\n- 工具类\r\n\r\n```java\r\n/*\r\n    JDBC工具类\r\n */\r\npublic class JDBCUtils {\r\n    //1.私有构造方法\r\n    private JDBCUtils(){};\r\n\r\n    //2.声明配置信息变量\r\n    private static String driverClass;\r\n    private static String url;\r\n    private static String username;\r\n    private static String password;\r\n    private static Connection con;\r\n\r\n    //3.静态代码块中实现加载配置文件和注册驱动\r\n    static{\r\n        try{\r\n            //通过类加载器返回配置文件的字节流\r\n            InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream("config.properties");\r\n\r\n            //创建Properties集合，加载流对象的信息\r\n            Properties prop = new Properties();\r\n            prop.load(is);\r\n\r\n            //获取信息为变量赋值\r\n            driverClass = prop.getProperty("driverClass");\r\n            url = prop.getProperty("url");\r\n            username = prop.getProperty("username");\r\n            password = prop.getProperty("password");\r\n\r\n            //注册驱动\r\n            Class.forName(driverClass);\r\n\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    //4.获取数据库连接的方法\r\n    public static Connection getConnection() {\r\n        try {\r\n            con = DriverManager.getConnection(url,username,password);\r\n        } catch (SQLException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        return con;\r\n    }\r\n\r\n    //5.释放资源的方法\r\n    public static void close(Connection con, Statement stat, ResultSet rs) {\r\n        if(con != null) {\r\n            try {\r\n                con.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if(stat != null) {\r\n            try {\r\n                stat.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if(rs != null) {\r\n            try {\r\n                rs.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void close(Connection con, Statement stat) {\r\n        close(con,stat,null);\r\n    }\r\n}\r\n```\r\n\r\n#### 2.使用工具类优化student表的CRUD\r\n\r\n- 查询全部\r\n\r\n```java\r\n/*\r\n    查询所有学生信息\r\n*/\r\n@Override\r\npublic ArrayList<Student> findAll() {\r\n    ArrayList<Student> list = new ArrayList<>();\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    ResultSet rs = null;\r\n    try{\r\n\r\n        con = JDBCUtils.getConnection();\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        String sql = "SELECT * FROM student";\r\n        rs = stat.executeQuery(sql);\r\n\r\n        //5.处理结果集\r\n        while(rs.next()) {\r\n            Integer sid = rs.getInt("sid");\r\n            String name = rs.getString("name");\r\n            Integer age = rs.getInt("age");\r\n            Date birthday = rs.getDate("birthday");\r\n\r\n            //封装Student对象\r\n            Student stu = new Student(sid,name,age,birthday);\r\n\r\n            //将student对象保存到集合中\r\n            list.add(stu);\r\n        }\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        JDBCUtils.close(con,stat,rs);\r\n    }\r\n    //将集合对象返回\r\n    return list;\r\n}\r\n```\r\n\r\n- 条件查询\r\n\r\n```java\r\n/*\r\n    条件查询，根据id查询学生信息\r\n*/\r\n@Override\r\npublic Student findById(Integer id) {\r\n    Student stu = new Student();\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    ResultSet rs = null;\r\n    try{\r\n\r\n        con = JDBCUtils.getConnection();\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        String sql = "SELECT * FROM student WHERE sid=\'"+id+"\'";\r\n        rs = stat.executeQuery(sql);\r\n\r\n        //5.处理结果集\r\n        while(rs.next()) {\r\n            Integer sid = rs.getInt("sid");\r\n            String name = rs.getString("name");\r\n            Integer age = rs.getInt("age");\r\n            Date birthday = rs.getDate("birthday");\r\n\r\n            //封装Student对象\r\n            stu.setSid(sid);\r\n            stu.setName(name);\r\n            stu.setAge(age);\r\n            stu.setBirthday(birthday);\r\n        }\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        JDBCUtils.close(con,stat,rs);\r\n    }\r\n    //将对象返回\r\n    return stu;\r\n}\r\n```\r\n\r\n- 新增数据\r\n\r\n```java\r\n/*\r\n     添加学生信息\r\n*/\r\n@Override\r\npublic int insert(Student stu) {\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    int result = 0;\r\n    try{\r\n        con = JDBCUtils.getConnection();\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        Date d = stu.getBirthday();\r\n        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");\r\n        String birthday = sdf.format(d);\r\n        String sql = "INSERT INTO student VALUES (\'"+stu.getSid()+"\',\'"+stu.getName()+"\',\'"+stu.getAge()+"\',\'"+birthday+"\')";\r\n        result = stat.executeUpdate(sql);\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        JDBCUtils.close(con,stat);\r\n    }\r\n    //将结果返回\r\n    return result;\r\n}\r\n```\r\n\r\n- 修改数据\r\n\r\n```java\r\n/*\r\n     修改学生信息\r\n*/\r\n@Override\r\npublic int update(Student stu) {\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    int result = 0;\r\n    try{\r\n        con = JDBCUtils.getConnection();\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        Date d = stu.getBirthday();\r\n        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");\r\n        String birthday = sdf.format(d);\r\n        String sql = "UPDATE student SET sid=\'"+stu.getSid()+"\',name=\'"+stu.getName()+"\',age=\'"+stu.getAge()+"\',birthday=\'"+birthday+"\' WHERE sid=\'"+stu.getSid()+"\'";\r\n        result = stat.executeUpdate(sql);\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        JDBCUtils.close(con,stat);\r\n    }\r\n    //将结果返回\r\n    return result;\r\n}\r\n```\r\n\r\n- 删除数据\r\n\r\n```java\r\n/*\r\n   删除学生信息\r\n*/\r\n@Override\r\npublic int delete(Integer id) {\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    int result = 0;\r\n    try{\r\n        con = JDBCUtils.getConnection();\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        String sql = "DELETE FROM student WHERE sid=\'"+id+"\'";\r\n        result = stat.executeUpdate(sql);\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        JDBCUtils.close(con,stat);\r\n    }\r\n    //将结果返回\r\n    return result;\r\n}\r\n```\r\n\r\n#### 3.student表的CRUD整合页面\r\n\r\n- 用户表的数据准备\r\n\r\n```mysql\r\n-- 创建用户表\r\nCREATE TABLE USER(\r\n\tuid VARCHAR(50) PRIMARY KEY,\t-- 用户id\r\n\tucode VARCHAR(50),\t\t\t\t-- 用户标识\r\n\tloginname VARCHAR(100),\t\t\t-- 登录用户名\r\n\tPASSWORD VARCHAR(100),\t\t\t-- 登录密码\r\n\tusername VARCHAR(100),\t\t\t-- 用户名\r\n\tgender VARCHAR(10),\t\t\t\t-- 用户性别\r\n\tbirthday DATE,\t\t\t\t\t-- 出生日期\r\n\tdutydate DATE                   -- 入职日期\r\n);\r\n\r\n-- 添加一条测试数据\r\nINSERT INTO `user` VALUES (\'11111111\', \'zhangsan001\', \'zhangsan\', \'1234\', \'张三\', \'男\', \'2008-10-28\', \'2018-10-28\');\r\n```\r\n\r\n- 将student表的dao层操作复制到项目中的dao层即可\r\n\r\n```java\r\npublic class StudentDaoImpl implements StudentDao {\r\n\r\n    /*\r\n        查询所有学生信息\r\n     */\r\n    @Override\r\n    public ArrayList<Student> findAll() {\r\n        Connection con = null;\r\n        Statement stat = null;\r\n        ResultSet rs = null;\r\n        ArrayList<Student> list = new ArrayList<>();\r\n        try {\r\n            //1.获取连接\r\n            con = JDBCUtils.getConnection();\r\n\r\n            //2.获取执行者对象\r\n            stat = con.createStatement();\r\n\r\n            //3.执行sql语句，并接收结果\r\n            String sql = "SELECT * FROM student";\r\n            rs = stat.executeQuery(sql);\r\n\r\n            //4.处理结果，将每条记录封装成一个Student对象。将多个Student对象保存到集合中\r\n            while(rs.next()) {\r\n                Integer sid = rs.getInt("sid");\r\n                String name = rs.getString("name");\r\n                Integer age = rs.getInt("age");\r\n                Date birthday = rs.getDate("birthday");\r\n\r\n                Student stu = new Student(sid,name,age,birthday);\r\n\r\n                list.add(stu);\r\n            }\r\n\r\n        } catch (SQLException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //5.释放资源\r\n            JDBCUtils.close(con,stat,rs);\r\n        }\r\n\r\n        return list;\r\n    }\r\n\r\n    /*\r\n        条件查询，根据id查询学生信息\r\n     */\r\n    @Override\r\n    public Student findById(Integer id) {\r\n        Connection con = null;\r\n        Statement stat = null;\r\n        ResultSet rs = null;\r\n        Student stu = new Student();\r\n        try {\r\n            //1.获取连接\r\n            con = JDBCUtils.getConnection();\r\n\r\n            //2.获取执行者对象\r\n            stat = con.createStatement();\r\n\r\n            //3.执行sql语句，并接收结果\r\n            String sql = "SELECT * FROM student WHERE sid=\'"+id+"\'";\r\n            rs = stat.executeQuery(sql);\r\n\r\n            //4.处理结果，将记录封装成一个Student对象。\r\n            if(rs.next()) {\r\n                Integer sid = rs.getInt("sid");\r\n                String name = rs.getString("name");\r\n                Integer age = rs.getInt("age");\r\n                Date birthday = rs.getDate("birthday");\r\n\r\n                stu.setSid(sid);\r\n                stu.setName(name);\r\n                stu.setAge(age);\r\n                stu.setBirthday(birthday);\r\n            }\r\n\r\n        } catch (SQLException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //5.释放资源\r\n            JDBCUtils.close(con,stat,rs);\r\n        }\r\n\r\n        return stu;\r\n    }\r\n\r\n    /*\r\n        新增学生信息\r\n     */\r\n    @Override\r\n    public int insert(Student stu) {\r\n        Connection con = null;\r\n        Statement stat = null;\r\n        int result = 0;\r\n        try{\r\n            //1.获取连接\r\n            con = JDBCUtils.getConnection();\r\n\r\n            //2.获取执行者对象\r\n            stat = con.createStatement();\r\n\r\n            //3.执行sql语句，并接收结果\r\n            Date date = stu.getBirthday();\r\n            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");\r\n            String birthday = sdf.format(date);\r\n            String sql = "INSERT INTO student VALUES (null,\'"+stu.getName()+"\',\'"+stu.getAge()+"\',\'"+birthday+"\')";\r\n            result = stat.executeUpdate(sql);\r\n\r\n        } catch (SQLException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //4.释放资源\r\n            JDBCUtils.close(con,stat);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /*\r\n        修改学生信息\r\n     */\r\n    @Override\r\n    public int update(Student stu) {\r\n        Connection con = null;\r\n        Statement stat = null;\r\n        int result = 0;\r\n        try{\r\n            //1.获取连接\r\n            con = JDBCUtils.getConnection();\r\n\r\n            //2.获取执行者对象\r\n            stat = con.createStatement();\r\n\r\n            //3.执行sql语句，并接收结果\r\n            Date date = stu.getBirthday();\r\n            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");\r\n            String birthday = sdf.format(date);\r\n            String sql = "UPDATE student SET sid=\'"+stu.getSid()+"\',name=\'"+stu.getName()+"\',age=\'"+stu.getAge()+"\',birthday=\'"+birthday+"\' WHERE sid=\'"+stu.getSid()+"\'";\r\n            result = stat.executeUpdate(sql);\r\n\r\n        } catch (SQLException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //4.释放资源\r\n            JDBCUtils.close(con,stat);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /*\r\n        删除学生信息\r\n     */\r\n    @Override\r\n    public int delete(Integer id) {\r\n        Connection con = null;\r\n        Statement stat = null;\r\n        int result = 0;\r\n        try{\r\n            //1.获取连接\r\n            con = JDBCUtils.getConnection();\r\n\r\n            //2.获取执行者对象\r\n            stat = con.createStatement();\r\n\r\n            //3.执行sql语句，并接收结果\r\n            String sql = "DELETE FROM student WHERE sid=\'"+id+"\'";\r\n            result = stat.executeUpdate(sql);\r\n\r\n        } catch (SQLException e) {\r\n            e.printStackTrace();\r\n        }  finally {\r\n            //4.释放资源\r\n            JDBCUtils.close(con,stat);\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n### 五、SQL注入攻击\r\n\r\n#### 1.sql注入攻击的演示\r\n\r\n- 在登录界面，输入一个错误的用户名或密码，也可以登录成功\r\n\r\n![06](./img/java/jdbc/JDBC-01-授课笔记.assets/06.png)\r\n\r\n#### 2.sql注入攻击的原理\r\n\r\n- 按照正常道理来说，我们在密码处输入的所有内容，都应该认为是密码的组成\r\n- 但是现在Statement对象在执行sql语句时，将一部分内容当做查询条件来执行了\r\n\r\n#### 3.PreparedStatement的介绍\r\n\r\n- 预编译sql语句的执行者对象。在执行sql语句之前，将sql语句进行提前编译。明确sql语句的格式后，就不会改变了。剩余的内容都会认为是参数！参数使用?作为占位符\r\n- 为参数赋值的方法：setXxx(参数1,参数2);\r\n  - 参数1：?的位置编号(编号从1开始)\r\n  - 参数2：?的实际参数\r\n- 执行sql语句的方法\r\n  - 执行insert、update、delete语句：int executeUpdate();\r\n  - 执行select语句：ResultSet executeQuery();\r\n\r\n#### 4.PreparedStatement的使用\r\n\r\n```java\r\n/*\r\n\t 使用PreparedStatement的登录方法，解决注入攻击\r\n*/\r\n@Override\r\npublic User findByLoginNameAndPassword(String loginName, String password) {\r\n    //定义必要信息\r\n    Connection conn = null;\r\n    PreparedStatement pstm = null;\r\n    ResultSet rs = null;\r\n    User user = null;\r\n    try {\r\n        //1.获取连接\r\n        conn = JDBCUtils.getConnection();\r\n        //2.创建操作SQL对象\r\n        String sql = "SELECT * FROM user WHERE loginname=? AND password=?";\r\n        pstm = conn.prepareStatement(sql);\r\n        //3.设置参数\r\n        pstm.setString(1,loginName);\r\n        pstm.setString(2,password);\r\n        System.out.println(sql);\r\n        //4.执行sql语句，获取结果集\r\n        rs = pstm.executeQuery();\r\n        //5.获取结果集\r\n        if (rs.next()) {\r\n            //6.封装\r\n            user = new User();\r\n            user.setUid(rs.getString("uid"));\r\n            user.setUcode(rs.getString("ucode"));\r\n            user.setUsername(rs.getString("username"));\r\n            user.setPassword(rs.getString("password"));\r\n            user.setGender(rs.getString("gender"));\r\n            user.setDutydate(rs.getDate("dutydate"));\r\n            user.setBirthday(rs.getDate("birthday"));\r\n            user.setLoginname(rs.getString("loginname"));\r\n        }\r\n        //7.返回\r\n        return user;\r\n    }catch (Exception e){\r\n        throw new RuntimeException(e);\r\n    }finally {\r\n        JDBCUtils.close(conn,pstm,rs);\r\n    }\r\n}\r\n```\r\n\r\n#### 5.使用PreparedStatement优化student表的CRUD（作业）\r\n\r\n```java\r\npublic class StudentDaoImpl implements StudentDao {\r\n\r\n    @Override\r\n    public ArrayList<Student> findAll() {\r\n        //定义必要信息\r\n        Connection conn = null;\r\n        PreparedStatement pstm = null;\r\n        ResultSet rs = null;\r\n        ArrayList<Student> students = null;\r\n        try {\r\n            //1.获取连接\r\n            conn = JDBCUtils.getConnection();\r\n            //2.获取操作对象\r\n            pstm = conn.prepareStatement("select * from student");\r\n            //3.执行sql语句，获取结果集\r\n            rs = pstm.executeQuery();\r\n            //4.遍历结果集\r\n            students = new ArrayList<Student>();\r\n            while (rs.next()) {\r\n                //5.封装\r\n                Student student = new Student();\r\n                student.setSid(rs.getInt("sid"));\r\n                student.setName(rs.getString("name"));\r\n                student.setAge(rs.getInt("age"));\r\n                student.setBirthday(rs.getDate("birthday"));\r\n                //加入到集合中\r\n                students.add(student);\r\n            }\r\n            //6.返回\r\n            return students;\r\n        }catch (Exception e){\r\n            throw new RuntimeException(e);\r\n        }finally {\r\n            JDBCUtils.close(conn,pstm,rs);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public Student findById(Integer sid) {\r\n        //定义必要信息\r\n        Connection conn = null;\r\n        PreparedStatement pstm = null;\r\n        ResultSet rs = null;\r\n        Student student = null;\r\n        try {\r\n            //1.获取连接\r\n            conn = JDBCUtils.getConnection();\r\n            //2.获取操作对象\r\n            pstm = conn.prepareStatement("select * from student where sid = ? ");\r\n            pstm.setInt(1,sid);\r\n            //3.执行sql语句，获取结果集\r\n            rs = pstm.executeQuery();\r\n            //4.遍历结果集\r\n            if (rs.next()) {\r\n                //5.封装\r\n                student = new Student();\r\n                student.setSid(rs.getInt("sid"));\r\n                student.setName(rs.getString("name"));\r\n                student.setAge(rs.getInt("age"));\r\n                student.setBirthday(rs.getDate("birthday"));\r\n            }\r\n            //6.返回\r\n            return student;\r\n        }catch (Exception e){\r\n            throw new RuntimeException(e);\r\n        }finally {\r\n            JDBCUtils.close(conn,pstm,rs);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int insert(Student student) {\r\n        //定义必要信息\r\n        Connection conn = null;\r\n        PreparedStatement pstm = null;\r\n        int result = 0;\r\n        try {\r\n            //1.获取连接\r\n            conn = JDBCUtils.getConnection();\r\n            //2.获取操作对象\r\n            pstm = conn.prepareStatement("insert into student(sid,name,age,birthday)values(null,?,?,?)");\r\n            //3.设置参数\r\n            //pstm.setInt(1,null);\r\n            pstm.setString(1,student.getName());\r\n            pstm.setInt(2,student.getAge());\r\n            pstm.setDate(3,new Date(student.getBirthday().getTime()));\r\n            //4.执行sql语句\r\n            result = pstm.executeUpdate();\r\n        }catch (Exception e){\r\n            throw new RuntimeException(e);\r\n        }finally {\r\n            JDBCUtils.close(conn,pstm);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public int update(Student student) {\r\n        //定义必要信息\r\n        Connection conn = null;\r\n        PreparedStatement pstm = null;\r\n        int result = 0;\r\n        try {\r\n            //1.获取连接\r\n            conn = JDBCUtils.getConnection();\r\n            //2.获取操作对象\r\n            pstm = conn.prepareStatement("update student set name=?,age=?,birthday=? where sid=? ");\r\n            //3.设置参数\r\n            pstm.setString(1,student.getName());\r\n            pstm.setInt(2,student.getAge());\r\n            pstm.setDate(3,new Date(student.getBirthday().getTime()));\r\n            pstm.setInt(4,student.getSid());\r\n            //4.执行sql语句\r\n            result = pstm.executeUpdate();\r\n        }catch (Exception e){\r\n            throw new RuntimeException(e);\r\n        }finally {\r\n            JDBCUtils.close(conn,pstm);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public int delete(Integer sid) {\r\n        //定义必要信息\r\n        Connection conn = null;\r\n        PreparedStatement pstm = null;\r\n        int result = 0;\r\n        try {\r\n            //1.获取连接\r\n            conn = JDBCUtils.getConnection();\r\n            //2.获取操作对象\r\n            pstm = conn.prepareStatement("delete from student where sid=? ");\r\n            //3.设置参数\r\n            pstm.setInt(1,sid);\r\n            //4.执行sql语句\r\n            result = pstm.executeUpdate();\r\n        }catch (Exception e){\r\n            throw new RuntimeException(e);\r\n        }finally {\r\n            JDBCUtils.close(conn,pstm);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n### 六、综合案例-课程表批量新增加事务管理\r\n\r\n#### 1.service层\r\n\r\n- 接口\r\n\r\n```java\r\n/*\r\n\t 批量添加\r\n*/\r\nvoid batchAdd(List<User> users);\r\n```\r\n\r\n- 实现类\r\n\r\n```java\r\n/*\r\n      事务要控制在此处\r\n*/\r\n@Override\r\npublic void batchAdd(List<User> users) {\r\n    //获取数据库连接\r\n    Connection connection = JDBCUtils.getConnection();\r\n    try {\r\n        //开启事务\r\n        connection.setAutoCommit(false);\r\n        for (User user : users) {\r\n            //1.创建ID,并把UUID中的-替换\r\n            String uid = UUID.randomUUID().toString().replace("-", "").toUpperCase();\r\n            //2.给user的uid赋值\r\n            user.setUid(uid);\r\n            //3.生成员工编号\r\n            user.setUcode(uid);\r\n\r\n            //模拟异常\r\n            //int n = 1 / 0;\r\n\r\n            //4.保存\r\n            userDao.save(connection,user);\r\n        }\r\n        //提交事务\r\n        connection.commit();\r\n    }catch (Exception e){\r\n        try {\r\n            //回滚事务\r\n            connection.rollback();\r\n        }catch (Exception ex){\r\n            ex.printStackTrace();\r\n        }\r\n        e.printStackTrace();\r\n    }finally {\r\n        JDBCUtils.close(connection,null,null);\r\n    }\r\n}\r\n```\r\n\r\n#### 2.dao层\r\n\r\n- 接口\r\n\r\n```java\r\n/**\r\n\t支持事务的添加\r\n*/\r\nvoid save(Connection connection,User user);\r\n```\r\n\r\n- 实现类\r\n\r\n```java\r\n/*\r\n       支持事务的添加\r\n*/\r\n@Override\r\npublic void save(Connection connection, User user) {\r\n    //定义必要信息\r\n    PreparedStatement pstm = null;\r\n    try {\r\n        //1.获取连接\r\n        connection = JDBCUtils.getConnection();\r\n        //2.获取操作对象\r\n        pstm = connection.prepareStatement("insert into user(uid,ucode,loginname,password,username,gender,birthday,dutydate)values(?,?,?,?,?,?,?,?)");\r\n        //3.设置参数\r\n        pstm.setString(1,user.getUid());\r\n        pstm.setString(2,user.getUcode());\r\n        pstm.setString(3,user.getLoginname());\r\n        pstm.setString(4,user.getPassword());\r\n        pstm.setString(5,user.getUsername());\r\n        pstm.setString(6,user.getGender());\r\n        pstm.setDate(7,new Date(user.getBirthday().getTime()));\r\n        pstm.setDate(8,new Date(user.getDutydate().getTime()));\r\n        //4.执行sql语句，获取结果集\r\n        pstm.executeUpdate();\r\n    }catch (Exception e){\r\n        throw new RuntimeException(e);\r\n    }finally {\r\n        JDBCUtils.close(null,pstm,null);\r\n    }\r\n}\r\n```\r\n\r\n',we={data:function(){return{MainComponent:xe}}},je=we,Ce=Object(d["a"])(je,ye,fe,!1,null,"3c00a60c",null),Te=Ce.exports,Ee=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},Ie=[],De='\x3c!--\r\n * @Date           : 2021-04-12 16:03:42\r\n * @FilePath       : /jinnian-space/src/pages/java/module/jdbc/md/JDBC-02-授课笔记.md\r\n * @Description    : \r\n--\x3e\r\n# JDBC-02-授课笔记\r\n\r\n### 一、数据库连接池\r\n\r\n#### 1.数据库连接池的概念\r\n\r\n- 数据库连接背景\r\n  - 数据库连接是一种关键的、有限的、昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。数据库连接池正是针对这个问题提出来的。\r\n- 数据库连接池\r\n  - 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个。这项技术能明显提高对数据库操作的性能。\r\n- 数据库连接池原理\r\n\r\n![01](./img/java/jdbc/JDBC-02-授课笔记.assets/01.png)\r\n\r\n#### 2.自定义连接池\r\n\r\n- java.sql.DataSource接口：数据源(数据库连接池)。java官方提供的数据库连接池规范(接口)\r\n  - 获取数据库连接对象：Connection getConnection();\r\n- 自定义连接池\r\n\r\n```java\r\n/*\r\n\t自定义连接池类\r\n*/\r\npublic class MyDataSource implements DataSource{\r\n    //定义集合容器，用于保存多个数据库连接对象\r\n    private static List<Connection> pool = Collections.synchronizedList(new ArrayList<Connection>());\r\n\r\n    //静态代码块，生成10个数据库连接保存到集合中\r\n    static {\r\n        for (int i = 0; i < 10; i++) {\r\n            Connection con = JDBCUtils.getConnection();\r\n            pool.add(con);\r\n        }\r\n    }\r\n\r\n    //返回连接池的大小\r\n    public int getSize() {\r\n        return pool.size();\r\n    }\r\n\r\n    //从池中返回一个数据库连接\r\n    @Override\r\n    public Connection getConnection() {\r\n        if(pool.size() > 0) {\r\n            //从池中获取数据库连接\r\n            return pool.remove(0);\r\n        }else {\r\n            throw new RuntimeException("连接数量已用尽");\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public Connection getConnection(String username, String password) throws SQLException {\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public <T> T unwrap(Class<T> iface) throws SQLException {\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public boolean isWrapperFor(Class<?> iface) throws SQLException {\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    public PrintWriter getLogWriter() throws SQLException {\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public void setLogWriter(PrintWriter out) throws SQLException {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void setLoginTimeout(int seconds) throws SQLException {\r\n\r\n    }\r\n\r\n    @Override\r\n    public int getLoginTimeout() throws SQLException {\r\n        return 0;\r\n    }\r\n\r\n    @Override\r\n    public Logger getParentLogger() throws SQLFeatureNotSupportedException {\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n#### 3.自定义连接池测试\r\n\r\n```java\r\npublic class MyDataSourceTest {\r\n    public static void main(String[] args) throws Exception{\r\n        //创建数据库连接池对象\r\n        MyDataSource dataSource = new MyDataSource();\r\n\r\n        System.out.println("使用之前连接池数量：" + dataSource.getSize());\r\n        \r\n        //获取数据库连接对象\r\n        Connection con = dataSource.getConnection();\r\n        System.out.println(con.getClass());// JDBC4Connection\r\n\r\n        //查询学生表全部信息\r\n        String sql = "SELECT * FROM student";\r\n        PreparedStatement pst = con.prepareStatement(sql);\r\n        ResultSet rs = pst.executeQuery();\r\n\r\n        while(rs.next()) {\r\n            System.out.println(rs.getInt("sid") + "\\t" + rs.getString("name") + "\\t" + rs.getInt("age") + "\\t" + rs.getDate("birthday"));\r\n        }\r\n        \r\n        //释放资源\r\n        rs.close();\r\n        pst.close();\r\n\t\t//目前的连接对象close方法，是直接关闭连接，而不是将连接归还池中\r\n        con.close();\r\n\r\n        System.out.println("使用之后连接池数量：" + dataSource.getSize());\r\n    }\r\n}\r\n```\r\n\r\n#### 4.归还连接\r\n\r\n- 继承(无法解决)\r\n\r\n  - 通过打印连接对象，发现DriverManager获取的连接实现类是JDBC4Connection。\r\n  - 自定义一个类，继承JDBC4Connection这个类，重写close()方法。\r\n\r\n  ```java\r\n  /*\r\n      自定义Connection类\r\n   */\r\n  public class MyConnection1 extends JDBC4Connection {\r\n      //声明连接对象和连接池集合对象\r\n      private Connection con;\r\n      private List<Connection> pool;\r\n  \r\n      //通过构造方法给成员变量赋值\r\n      public MyConnection1(String hostToConnectTo, int portToConnectTo, Properties info, String databaseToConnectTo, String url,Connection con,List<Connection> pool) throws SQLException {\r\n          super(hostToConnectTo, portToConnectTo, info, databaseToConnectTo, url);\r\n          this.con = con;\r\n          this.pool = pool;\r\n      }\r\n  \r\n      //重写close()方法，将连接归还给池中\r\n      @Override\r\n      public void close() throws SQLException {\r\n          pool.add(con);\r\n      }\r\n  }\r\n  ```\r\n\r\n  - 但是这种方式行不通，通过查看JDBC工具类获取连接的方法我们发现：我们虽然自定义了一个子类，完成了归还连接的操作。但是DriverManager获取的还是JDBC4Connection这个对象，并不是我们的子类对象。而我们又不能整体去修改驱动包中类的功能！\r\n\r\n  ```java\r\n  //将之前的连接对象换成自定义的子类对象\r\n  private static MyConnection1 con;\r\n  \r\n  //4.获取数据库连接的方法\r\n  public static Connection getConnection() {\r\n      try {\r\n          //等效于：MyConnection1 con = new JDBC4Connection();  语法错误！\r\n          con = DriverManager.getConnection(url,username,password);\r\n      } catch (SQLException e) {\r\n          e.printStackTrace();\r\n      }\r\n  \r\n      return con;\r\n  }\r\n  ```\r\n\r\n- 装饰设计模式\r\n\r\n  - 自定义连接类\r\n\r\n  ```java\r\n  /*\r\n      自定义Connection类。通过装饰设计模式，实现和mysql驱动包中的Connection实现类相同的功能！\r\n      实现步骤：\r\n          1.定义一个类，实现Connection接口\r\n          2.定义Connection连接对象和连接池容器对象的变量\r\n          3.提供有参构造方法，接收连接对象和连接池对象，对变量赋值\r\n          4.在close()方法中，完成连接的归还\r\n          5.剩余方法，只需要调用mysql驱动包的连接对象完成即可\r\n   */\r\n  public class MyConnection2 implements Connection {\r\n  \r\n      //2.定义Connection连接对象和连接池容器对象的变量\r\n      private Connection con;\r\n      private List<Connection> pool;\r\n  \r\n      //3.提供有参构造方法，接收连接对象和连接池对象，对变量赋值\r\n      public MyConnection2(Connection con,List<Connection> pool) {\r\n          this.con = con;\r\n          this.pool = pool;\r\n      }\r\n  \r\n      //4.在close()方法中，完成连接的归还\r\n      @Override\r\n      public void close() throws SQLException {\r\n          pool.add(con);\r\n      }\r\n  \r\n  \r\n      @Override\r\n      public Statement createStatement() throws SQLException {\r\n          return con.createStatement();\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql) throws SQLException {\r\n          return con.prepareStatement(sql);\r\n      }\r\n  \r\n      @Override\r\n      public CallableStatement prepareCall(String sql) throws SQLException {\r\n          return con.prepareCall(sql);\r\n      }\r\n  \r\n      @Override\r\n      public String nativeSQL(String sql) throws SQLException {\r\n          return con.nativeSQL(sql);\r\n      }\r\n  \r\n      @Override\r\n      public void setAutoCommit(boolean autoCommit) throws SQLException {\r\n          con.setAutoCommit(autoCommit);\r\n      }\r\n  \r\n      @Override\r\n      public boolean getAutoCommit() throws SQLException {\r\n          return con.getAutoCommit();\r\n      }\r\n  \r\n      @Override\r\n      public void commit() throws SQLException {\r\n          con.commit();\r\n      }\r\n  \r\n      @Override\r\n      public void rollback() throws SQLException {\r\n          con.rollback();\r\n      }\r\n  \r\n      @Override\r\n      public boolean isClosed() throws SQLException {\r\n          return con.isClosed();\r\n      }\r\n  \r\n      @Override\r\n      public DatabaseMetaData getMetaData() throws SQLException {\r\n          return con.getMetaData();\r\n      }\r\n  \r\n      @Override\r\n      public void setReadOnly(boolean readOnly) throws SQLException {\r\n          con.setReadOnly(readOnly);\r\n      }\r\n  \r\n      @Override\r\n      public boolean isReadOnly() throws SQLException {\r\n          return con.isReadOnly();\r\n      }\r\n  \r\n      @Override\r\n      public void setCatalog(String catalog) throws SQLException {\r\n          con.setCatalog(catalog);\r\n      }\r\n  \r\n      @Override\r\n      public String getCatalog() throws SQLException {\r\n          return con.getCatalog();\r\n      }\r\n  \r\n      @Override\r\n      public void setTransactionIsolation(int level) throws SQLException {\r\n          con.setTransactionIsolation(level);\r\n      }\r\n  \r\n      @Override\r\n      public int getTransactionIsolation() throws SQLException {\r\n          return con.getTransactionIsolation();\r\n      }\r\n  \r\n      @Override\r\n      public SQLWarning getWarnings() throws SQLException {\r\n          return con.getWarnings();\r\n      }\r\n  \r\n      @Override\r\n      public void clearWarnings() throws SQLException {\r\n          con.clearWarnings();\r\n      }\r\n  \r\n      @Override\r\n      public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {\r\n          return con.createStatement(resultSetType,resultSetConcurrency);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {\r\n          return con.prepareStatement(sql,resultSetType,resultSetConcurrency);\r\n      }\r\n  \r\n      @Override\r\n      public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {\r\n          return con.prepareCall(sql,resultSetType,resultSetConcurrency);\r\n      }\r\n  \r\n      @Override\r\n      public Map<String, Class<?>> getTypeMap() throws SQLException {\r\n          return con.getTypeMap();\r\n      }\r\n  \r\n      @Override\r\n      public void setTypeMap(Map<String, Class<?>> map) throws SQLException {\r\n          con.setTypeMap(map);\r\n      }\r\n  \r\n      @Override\r\n      public void setHoldability(int holdability) throws SQLException {\r\n          con.setHoldability(holdability);\r\n      }\r\n  \r\n      @Override\r\n      public int getHoldability() throws SQLException {\r\n          return con.getHoldability();\r\n      }\r\n  \r\n      @Override\r\n      public Savepoint setSavepoint() throws SQLException {\r\n          return con.setSavepoint();\r\n      }\r\n  \r\n      @Override\r\n      public Savepoint setSavepoint(String name) throws SQLException {\r\n          return con.setSavepoint(name);\r\n      }\r\n  \r\n      @Override\r\n      public void rollback(Savepoint savepoint) throws SQLException {\r\n          con.rollback(savepoint);\r\n      }\r\n  \r\n      @Override\r\n      public void releaseSavepoint(Savepoint savepoint) throws SQLException {\r\n          con.releaseSavepoint(savepoint);\r\n      }\r\n  \r\n      @Override\r\n      public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {\r\n          return con.createStatement(resultSetType,resultSetConcurrency,resultSetHoldability);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {\r\n          return con.prepareStatement(sql,resultSetType,resultSetConcurrency,resultSetHoldability);\r\n      }\r\n  \r\n      @Override\r\n      public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {\r\n          return con.prepareCall(sql,resultSetType,resultSetConcurrency,resultSetHoldability);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {\r\n          return con.prepareStatement(sql,autoGeneratedKeys);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {\r\n          return con.prepareStatement(sql,columnIndexes);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {\r\n          return con.prepareStatement(sql,columnNames);\r\n      }\r\n  \r\n      @Override\r\n      public Clob createClob() throws SQLException {\r\n          return con.createClob();\r\n      }\r\n  \r\n      @Override\r\n      public Blob createBlob() throws SQLException {\r\n          return con.createBlob();\r\n      }\r\n  \r\n      @Override\r\n      public NClob createNClob() throws SQLException {\r\n          return con.createNClob();\r\n      }\r\n  \r\n      @Override\r\n      public SQLXML createSQLXML() throws SQLException {\r\n          return con.createSQLXML();\r\n      }\r\n  \r\n      @Override\r\n      public boolean isValid(int timeout) throws SQLException {\r\n          return con.isValid(timeout);\r\n      }\r\n  \r\n      @Override\r\n      public void setClientInfo(String name, String value) throws SQLClientInfoException {\r\n          con.setClientInfo(name,value);\r\n      }\r\n  \r\n      @Override\r\n      public void setClientInfo(Properties properties) throws SQLClientInfoException {\r\n          con.setClientInfo(properties);\r\n      }\r\n  \r\n      @Override\r\n      public String getClientInfo(String name) throws SQLException {\r\n          return con.getClientInfo(name);\r\n      }\r\n  \r\n      @Override\r\n      public Properties getClientInfo() throws SQLException {\r\n          return con.getClientInfo();\r\n      }\r\n  \r\n      @Override\r\n      public Array createArrayOf(String typeName, Object[] elements) throws SQLException {\r\n          return con.createArrayOf(typeName,elements);\r\n      }\r\n  \r\n      @Override\r\n      public Struct createStruct(String typeName, Object[] attributes) throws SQLException {\r\n          return con.createStruct(typeName,attributes);\r\n      }\r\n  \r\n      @Override\r\n      public void setSchema(String schema) throws SQLException {\r\n          con.setSchema(schema);\r\n      }\r\n  \r\n      @Override\r\n      public String getSchema() throws SQLException {\r\n          return con.getSchema();\r\n      }\r\n  \r\n      @Override\r\n      public void abort(Executor executor) throws SQLException {\r\n          con.abort(executor);\r\n      }\r\n  \r\n      @Override\r\n      public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {\r\n          con.setNetworkTimeout(executor,milliseconds);\r\n      }\r\n  \r\n      @Override\r\n      public int getNetworkTimeout() throws SQLException {\r\n          return con.getNetworkTimeout();\r\n      }\r\n  \r\n      @Override\r\n      public <T> T unwrap(Class<T> iface) throws SQLException {\r\n          return con.unwrap(iface);\r\n      }\r\n  \r\n      @Override\r\n      public boolean isWrapperFor(Class<?> iface) throws SQLException {\r\n          return con.isWrapperFor(iface);\r\n      }\r\n  }\r\n  ```\r\n\r\n  - 自定义连接池类\r\n\r\n  ```java\r\n  public class MyDataSource implements DataSource{\r\n      //定义集合容器，用于保存多个数据库连接对象\r\n      private static List<Connection> pool = Collections.synchronizedList(new ArrayList<Connection>());\r\n  \r\n      //静态代码块，生成10个数据库连接保存到集合中\r\n      static {\r\n          for (int i = 0; i < 10; i++) {\r\n              Connection con = JDBCUtils.getConnection();\r\n              pool.add(con);\r\n          }\r\n      }\r\n  \r\n      //返回连接池的大小\r\n      public int getSize() {\r\n          return pool.size();\r\n      }\r\n  \r\n      //从池中返回一个数据库连接\r\n      @Override\r\n      public Connection getConnection() {\r\n          if(pool.size() > 0) {\r\n              //从池中获取数据库连接\r\n              Connection con = pool.remove(0);\r\n              //通过自定义连接对象进行包装\r\n              MyConnection2 mycon = new MyConnection2(con,pool);\r\n              //返回包装后的连接对象\r\n              return mycon;\r\n          }else {\r\n              throw new RuntimeException("连接数量已用尽");\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n- 适配器设计模式\r\n\r\n  - 通过之前MyConnection2连接类我们发现，有很多个需要实现的方法。这个时候我们就可以使用适配器设计模式了。提供一个适配器类，实现Connection接口，将所有功能进行实现(除了close方法)。自定义连接类只需要继承这个适配器类，重写需要改进的close()方法即可！\r\n  - 适配器类\r\n\r\n  ```java\r\n  /*\r\n      适配器抽象类。实现Connection接口。\r\n      实现所有的方法，调用mysql驱动包中Connection连接对象的方法\r\n   */\r\n  public abstract class MyAdapter implements Connection {\r\n  \r\n      // 定义数据库连接对象的变量\r\n      private Connection con;\r\n  \r\n      // 通过构造方法赋值\r\n      public MyAdapter(Connection con) {\r\n          this.con = con;\r\n      }\r\n  \r\n      // 所有的方法，均调用mysql的连接对象实现\r\n      @Override\r\n      public Statement createStatement() throws SQLException {\r\n          return con.createStatement();\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql) throws SQLException {\r\n          return con.prepareStatement(sql);\r\n      }\r\n  \r\n      @Override\r\n      public CallableStatement prepareCall(String sql) throws SQLException {\r\n          return con.prepareCall(sql);\r\n      }\r\n  \r\n      @Override\r\n      public String nativeSQL(String sql) throws SQLException {\r\n          return con.nativeSQL(sql);\r\n      }\r\n  \r\n      @Override\r\n      public void setAutoCommit(boolean autoCommit) throws SQLException {\r\n          con.setAutoCommit(autoCommit);\r\n      }\r\n  \r\n      @Override\r\n      public boolean getAutoCommit() throws SQLException {\r\n          return con.getAutoCommit();\r\n      }\r\n  \r\n      @Override\r\n      public void commit() throws SQLException {\r\n          con.commit();\r\n      }\r\n  \r\n      @Override\r\n      public void rollback() throws SQLException {\r\n          con.rollback();\r\n      }\r\n  \r\n      @Override\r\n      public boolean isClosed() throws SQLException {\r\n          return con.isClosed();\r\n      }\r\n  \r\n      @Override\r\n      public DatabaseMetaData getMetaData() throws SQLException {\r\n          return con.getMetaData();\r\n      }\r\n  \r\n      @Override\r\n      public void setReadOnly(boolean readOnly) throws SQLException {\r\n          con.setReadOnly(readOnly);\r\n      }\r\n  \r\n      @Override\r\n      public boolean isReadOnly() throws SQLException {\r\n          return con.isReadOnly();\r\n      }\r\n  \r\n      @Override\r\n      public void setCatalog(String catalog) throws SQLException {\r\n          con.setCatalog(catalog);\r\n      }\r\n  \r\n      @Override\r\n      public String getCatalog() throws SQLException {\r\n          return con.getCatalog();\r\n      }\r\n  \r\n      @Override\r\n      public void setTransactionIsolation(int level) throws SQLException {\r\n          con.setTransactionIsolation(level);\r\n      }\r\n  \r\n      @Override\r\n      public int getTransactionIsolation() throws SQLException {\r\n          return con.getTransactionIsolation();\r\n      }\r\n  \r\n      @Override\r\n      public SQLWarning getWarnings() throws SQLException {\r\n          return con.getWarnings();\r\n      }\r\n  \r\n      @Override\r\n      public void clearWarnings() throws SQLException {\r\n          con.clearWarnings();\r\n      }\r\n  \r\n      @Override\r\n      public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {\r\n          return con.createStatement(resultSetType,resultSetConcurrency);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {\r\n          return con.prepareStatement(sql,resultSetType,resultSetConcurrency);\r\n      }\r\n  \r\n      @Override\r\n      public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {\r\n          return con.prepareCall(sql,resultSetType,resultSetConcurrency);\r\n      }\r\n  \r\n      @Override\r\n      public Map<String, Class<?>> getTypeMap() throws SQLException {\r\n          return con.getTypeMap();\r\n      }\r\n  \r\n      @Override\r\n      public void setTypeMap(Map<String, Class<?>> map) throws SQLException {\r\n          con.setTypeMap(map);\r\n      }\r\n  \r\n      @Override\r\n      public void setHoldability(int holdability) throws SQLException {\r\n          con.setHoldability(holdability);\r\n      }\r\n  \r\n      @Override\r\n      public int getHoldability() throws SQLException {\r\n          return con.getHoldability();\r\n      }\r\n  \r\n      @Override\r\n      public Savepoint setSavepoint() throws SQLException {\r\n          return con.setSavepoint();\r\n      }\r\n  \r\n      @Override\r\n      public Savepoint setSavepoint(String name) throws SQLException {\r\n          return con.setSavepoint(name);\r\n      }\r\n  \r\n      @Override\r\n      public void rollback(Savepoint savepoint) throws SQLException {\r\n          con.rollback(savepoint);\r\n      }\r\n  \r\n      @Override\r\n      public void releaseSavepoint(Savepoint savepoint) throws SQLException {\r\n          con.releaseSavepoint(savepoint);\r\n      }\r\n  \r\n      @Override\r\n      public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {\r\n          return con.createStatement(resultSetType,resultSetConcurrency,resultSetHoldability);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {\r\n          return con.prepareStatement(sql,resultSetType,resultSetConcurrency,resultSetHoldability);\r\n      }\r\n  \r\n      @Override\r\n      public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {\r\n          return con.prepareCall(sql,resultSetType,resultSetConcurrency,resultSetHoldability);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {\r\n          return con.prepareStatement(sql,autoGeneratedKeys);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {\r\n          return con.prepareStatement(sql,columnIndexes);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {\r\n          return con.prepareStatement(sql,columnNames);\r\n      }\r\n  \r\n      @Override\r\n      public Clob createClob() throws SQLException {\r\n          return con.createClob();\r\n      }\r\n  \r\n      @Override\r\n      public Blob createBlob() throws SQLException {\r\n          return con.createBlob();\r\n      }\r\n  \r\n      @Override\r\n      public NClob createNClob() throws SQLException {\r\n          return con.createNClob();\r\n      }\r\n  \r\n      @Override\r\n      public SQLXML createSQLXML() throws SQLException {\r\n          return con.createSQLXML();\r\n      }\r\n  \r\n      @Override\r\n      public boolean isValid(int timeout) throws SQLException {\r\n          return con.isValid(timeout);\r\n      }\r\n  \r\n      @Override\r\n      public void setClientInfo(String name, String value) throws SQLClientInfoException {\r\n          con.setClientInfo(name,value);\r\n      }\r\n  \r\n      @Override\r\n      public void setClientInfo(Properties properties) throws SQLClientInfoException {\r\n          con.setClientInfo(properties);\r\n      }\r\n  \r\n      @Override\r\n      public String getClientInfo(String name) throws SQLException {\r\n          return con.getClientInfo(name);\r\n      }\r\n  \r\n      @Override\r\n      public Properties getClientInfo() throws SQLException {\r\n          return con.getClientInfo();\r\n      }\r\n  \r\n      @Override\r\n      public Array createArrayOf(String typeName, Object[] elements) throws SQLException {\r\n          return con.createArrayOf(typeName,elements);\r\n      }\r\n  \r\n      @Override\r\n      public Struct createStruct(String typeName, Object[] attributes) throws SQLException {\r\n          return con.createStruct(typeName,attributes);\r\n      }\r\n  \r\n      @Override\r\n      public void setSchema(String schema) throws SQLException {\r\n          con.setSchema(schema);\r\n      }\r\n  \r\n      @Override\r\n      public String getSchema() throws SQLException {\r\n          return con.getSchema();\r\n      }\r\n  \r\n      @Override\r\n      public void abort(Executor executor) throws SQLException {\r\n          con.abort(executor);\r\n      }\r\n  \r\n      @Override\r\n      public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {\r\n          con.setNetworkTimeout(executor,milliseconds);\r\n      }\r\n  \r\n      @Override\r\n      public int getNetworkTimeout() throws SQLException {\r\n          return con.getNetworkTimeout();\r\n      }\r\n  \r\n      @Override\r\n      public <T> T unwrap(Class<T> iface) throws SQLException {\r\n          return con.unwrap(iface);\r\n      }\r\n  \r\n      @Override\r\n      public boolean isWrapperFor(Class<?> iface) throws SQLException {\r\n          return con.isWrapperFor(iface);\r\n      }\r\n  }\r\n  ```\r\n\r\n  - 自定义连接类\r\n\r\n  ```java\r\n  /*\r\n      自定义Connection连接类。通过适配器设计模式。完成close()方法的重写\r\n          1.定义一个类，继承适配器父类\r\n          2.定义Connection连接对象和连接池容器对象的变量\r\n          3.提供有参构造方法，接收连接对象和连接池对象，对变量赋值\r\n          4.在close()方法中，完成连接的归还\r\n   */\r\n  public class MyConnection3 extends MyAdapter {\r\n      //2.定义Connection连接对象和连接池容器对象的变量\r\n      private Connection con;\r\n      private List<Connection> pool;\r\n  \r\n      //3.提供有参构造方法，接收连接对象和连接池对象，对变量赋值\r\n      public MyConnection3(Connection con,List<Connection> pool) {\r\n          super(con);    // 将接收的数据库连接对象给适配器父类传递\r\n          this.con = con;\r\n          this.pool = pool;\r\n      }\r\n  \r\n      //4.在close()方法中，完成连接的归还\r\n      @Override\r\n      public void close() throws SQLException {\r\n          pool.add(con);\r\n      }\r\n  }\r\n  ```\r\n\r\n  - 自定义连接池类\r\n\r\n  ```java\r\n  public class MyDataSource implements DataSource{\r\n      //定义集合容器，用于保存多个数据库连接对象\r\n      private static List<Connection> pool = Collections.synchronizedList(new ArrayList<Connection>());\r\n  \r\n      //静态代码块，生成10个数据库连接保存到集合中\r\n      static {\r\n          for (int i = 0; i < 10; i++) {\r\n              Connection con = JDBCUtils.getConnection();\r\n              pool.add(con);\r\n          }\r\n      }\r\n  \r\n      //返回连接池的大小\r\n      public int getSize() {\r\n          return pool.size();\r\n      }\r\n  \r\n      //从池中返回一个数据库连接\r\n      @Override\r\n      public Connection getConnection() {\r\n          if(pool.size() > 0) {\r\n              //从池中获取数据库连接\r\n              Connection con = pool.remove(0);\r\n  \r\n              //通过自定义连接对象进行包装\r\n              //MyConnection2 mycon = new MyConnection2(con,pool);\r\n              MyConnection3 mycon = new MyConnection3(con,pool);\r\n  \r\n              //返回包装后的连接对象\r\n              return mycon;\r\n          }else {\r\n              throw new RuntimeException("连接数量已用尽");\r\n          }\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n- 动态代理\r\n\r\n  - 经过我们适配器模式的改进，自定义连接类中的方法已经很简洁了。剩余所有的方法已经抽取到了适配器类中。但是适配器这个类还是我们自己编写的，也比较麻烦！所以可以使用动态代理的方式来改进。\r\n  - 自定义数据库连接池类\r\n\r\n  ```java\r\n  public class MyDataSource implements DataSource{\r\n      //定义集合容器，用于保存多个数据库连接对象\r\n      private static List<Connection> pool = Collections.synchronizedList(new ArrayList<Connection>());\r\n  \r\n      //静态代码块，生成10个数据库连接保存到集合中\r\n      static {\r\n          for (int i = 0; i < 10; i++) {\r\n              Connection con = JDBCUtils.getConnection();\r\n              pool.add(con);\r\n          }\r\n      }\r\n  \r\n      //返回连接池的大小\r\n      public int getSize() {\r\n          return pool.size();\r\n      }\r\n  \r\n      //动态代理方式\r\n      @Override\r\n      public Connection getConnection() {\r\n          if(pool.size() > 0) {\r\n              //从池中获取数据库连接\r\n              Connection con = pool.remove(0);\r\n  \r\n              Connection proxyCon = (Connection)Proxy.newProxyInstance(con.getClass().getClassLoader(), new Class[]{Connection.class}, new InvocationHandler() {\r\n                  /*\r\n                      执行Connection实现类所有方法都会经过invoke\r\n                      如果是close方法，则将连接还回池中\r\n                      如果不是，直接执行实现类的原有方法\r\n                   */\r\n                  @Override\r\n                  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n                      if(method.getName().equals("close")) {\r\n                          pool.add(con);\r\n                          return null;\r\n                      }else {\r\n                          return method.invoke(con,args);\r\n                      }\r\n                  }\r\n              });\r\n  \r\n              return proxyCon;\r\n          }else {\r\n              throw new RuntimeException("连接数量已用尽");\r\n          }\r\n      }\r\n  \r\n  \r\n      //从池中返回一个数据库连接\r\n      /*@Override\r\n      public Connection getConnection() {\r\n          if(pool.size() > 0) {\r\n              //从池中获取数据库连接\r\n              Connection con = pool.remove(0);\r\n  \r\n              //通过自定义连接对象进行包装\r\n              //MyConnection2 mycon = new MyConnection2(con,pool);\r\n              MyConnection3 mycon = new MyConnection3(con,pool);\r\n  \r\n              //返回包装后的连接对象\r\n              return mycon;\r\n          }else {\r\n              throw new RuntimeException("连接数量已用尽");\r\n          }\r\n      }*/\r\n  }\r\n  \r\n  ```\r\n\r\n#### 5.开源连接池的使用\r\n\r\n- C3P0\r\n\r\n  - 基本使用\r\n\r\n  ```java\r\n  /*\r\n      使用C3P0连接池\r\n      1.导入jar包\r\n      2.导入配置文件到src目录下\r\n      3.创建c3p0连接池对象\r\n      4.获取数据库连接进行使用\r\n   */\r\n  public class C3P0Demo1 {\r\n      public static void main(String[] args) throws Exception{\r\n          //创建c3p0连接池对象\r\n          DataSource dataSource = new ComboPooledDataSource();\r\n  \r\n          //获取数据库连接进行使用\r\n          Connection con = dataSource.getConnection();\r\n  \r\n          //查询全部学生信息\r\n          String sql = "SELECT * FROM student";\r\n          PreparedStatement pst = con.prepareStatement(sql);\r\n          ResultSet rs = pst.executeQuery();\r\n  \r\n          while(rs.next()) {\r\n              System.out.println(rs.getInt("sid") + "\\t" + rs.getString("name") + "\\t" + rs.getInt("age") + "\\t" + rs.getDate("birthday"));\r\n          }\r\n  \r\n          //释放资源\r\n          rs.close();\r\n          pst.close();\r\n          con.close();    // 将连接对象归还池中\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n  - 配置演示\r\n\r\n  ```java\r\n  public class C3P0Demo2 {\r\n      public static void main(String[] args) throws Exception{\r\n          //创建c3p0连接池对象\r\n          DataSource dataSource = new ComboPooledDataSource();\r\n  \r\n          //获取数据库连接进行使用\r\n          for(int i = 1; i <= 11; i++) {\r\n              Connection con = dataSource.getConnection();\r\n              System.out.println(i + ":" + con);\r\n              if(i == 5) {\r\n                  con.close();\r\n              }\r\n          }\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n- Druid\r\n\r\n  - 基本使用\r\n\r\n  ```java\r\n  /*\r\n      Druid连接池\r\n      1.导入jar包\r\n      2.编写配置文件，放在src目录下\r\n      3.通过Properties集合加载配置文件\r\n      4.通过Druid连接池工厂类获取数据库连接池对象\r\n      5.获取数据库连接，进行使用\r\n   */\r\n  public class DruidDemo1 {\r\n      public static void main(String[] args) throws Exception{\r\n          //通过Properties集合加载配置文件\r\n          InputStream is = DruidDemo1.class.getClassLoader().getResourceAsStream("druid.properties");\r\n          Properties prop = new Properties();\r\n          prop.load(is);\r\n  \r\n          //通过Druid连接池工厂类获取数据库连接池对象\r\n          DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);\r\n  \r\n          //获取数据库连接，进行使用\r\n          Connection con = dataSource.getConnection();\r\n  \r\n          //查询全部学生信息\r\n          String sql = "SELECT * FROM student";\r\n          PreparedStatement pst = con.prepareStatement(sql);\r\n          ResultSet rs = pst.executeQuery();\r\n  \r\n          while(rs.next()) {\r\n              System.out.println(rs.getInt("sid") + "\\t" + rs.getString("name") + "\\t" + rs.getInt("age") + "\\t" + rs.getDate("birthday"));\r\n          }\r\n  \r\n          //释放资源\r\n          rs.close();\r\n          pst.close();\r\n          con.close();    // 将连接对象归还池中\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n  - 抽取工具类\r\n\r\n  ```java\r\n  /*\r\n      数据库连接池工具类\r\n   */\r\n  public class DataSourceUtils {\r\n      //1.私有构造方法\r\n      private DataSourceUtils(){}\r\n  \r\n      //2.定义DataSource数据源变量\r\n      private static DataSource dataSource;\r\n  \r\n      //3.提供静态代码块，完成配置文件的加载和获取连接池对象\r\n      static {\r\n          try{\r\n              //加载配置文件\r\n              InputStream is = DruidDemo1.class.getClassLoader().getResourceAsStream("druid.properties");\r\n              Properties prop = new Properties();\r\n              prop.load(is);\r\n  \r\n              //获取数据库连接池对象\r\n              dataSource = DruidDataSourceFactory.createDataSource(prop);\r\n  \r\n          } catch(Exception e) {\r\n              e.printStackTrace();\r\n          }\r\n      }\r\n  \r\n      //4.提供获取数据库连接的方法\r\n      public static Connection getConnection() {\r\n          Connection con = null;\r\n          try {\r\n              con = dataSource.getConnection();\r\n          } catch (SQLException e) {\r\n              e.printStackTrace();\r\n          }\r\n          return con;\r\n      }\r\n  \r\n      //5.提供获取数据库连接池的方法\r\n      public static DataSource getDataSource() {\r\n          return dataSource;\r\n      }\r\n  \r\n      //6.提供释放资源的方法\r\n      public static void close(Connection con, Statement stat, ResultSet rs) {\r\n          if(con != null) {\r\n              try {\r\n                  con.close();\r\n              } catch (SQLException e) {\r\n                  e.printStackTrace();\r\n              }\r\n          }\r\n  \r\n          if(stat != null) {\r\n              try {\r\n                  stat.close();\r\n              } catch (SQLException e) {\r\n                  e.printStackTrace();\r\n              }\r\n          }\r\n  \r\n          if(rs != null) {\r\n              try {\r\n                  rs.close();\r\n              } catch (SQLException e) {\r\n                  e.printStackTrace();\r\n              }\r\n          }\r\n      }\r\n  \r\n      public static void close(Connection con, Statement stat) {\r\n          close(con,stat,null);\r\n      }\r\n  \r\n  }\r\n  \r\n  ```\r\n\r\n### 二、JDBC框架(JDBCTemplate)\r\n\r\n#### 1.分析前一天案例中的重复代码\r\n\r\n- dao层的重复代码\r\n  - 定义必要的信息、获取数据库的连接、释放资源都是重复的代码！\r\n  - 而我们最终的核心功能仅仅只是执行一条sql语句而已啊！\r\n  - 所以我们可以抽取出一个JDBC模板类，来封装一些方法(update、query)，专门帮我们执行增删改查的sql语句！\r\n  - 将之前那些重复的操作，都抽取到模板类中的方法里。就能大大简化我们的使用步骤！\r\n\r\n#### 2.自定义JDBC框架\r\n\r\n##### 2.1数据库的源信息\r\n\r\n- DataBaseMetaData(了解)：数据库的源信息\r\n  - java.sql.DataBaseMetaData：封装了整个数据库的综合信息\r\n  - 例如：\r\n    - String getDatabaseProductName()：获取数据库产品的名称\r\n    - int getDatabaseProductVersion()：获取数据库产品的版本号\r\n- ParameterMetaData：参数的源信息\r\n  - java.sql.ParameterMetaData：封装的是预编译执行者对象中每个参数的类型和属性\r\n  - 这个对象可以通过预编译执行者对象中的getParameterMetaData()方法来获取\r\n  - 核心功能：\r\n    - int getParameterCount()：获取sql语句中参数的个数\r\n- ResultSetMetaData：结果集的源信息\r\n  - java.sql.ResultSetMetaData：封装的是结果集对象中列的类型和属性\r\n  - 这个对象可以通过结果集对象中的getMetaData()方法来获取\r\n  - 核心功能：\r\n    - int getColumnCount()：获取列的总数\r\n    - String getColumnName(int i)：获取列名\r\n\r\n##### 2.2JDBCTemplate类增删改功能的编写\r\n\r\n```java\r\npublic class JDBCTemplate {\r\n    private DataSource dataSource;\r\n    private Connection con;\r\n    private PreparedStatement pst;\r\n    private ResultSet rs;\r\n\r\n    public JDBCTemplate(DataSource dataSource) {\r\n        this.dataSource = dataSource;\r\n    }\r\n\r\n    //专用于执行增删改sql语句的方法\r\n    public int update(String sql,Object...objs) {\r\n        int result = 0;\r\n\r\n        try{\r\n            con = dataSource.getConnection();\r\n            pst = con.prepareStatement(sql);\r\n\r\n            //获取sql语句中的参数源信息\r\n            ParameterMetaData pData = pst.getParameterMetaData();\r\n            //获取sql语句中参数的个数\r\n            int parameterCount = pData.getParameterCount();\r\n\r\n            //判断参数个数是否一致\r\n            if(parameterCount != objs.length) {\r\n                throw new RuntimeException("参数个数不匹配");\r\n            }\r\n\r\n            //为sql语句中的?占位符赋值\r\n            for (int i = 0; i < objs.length; i++) {\r\n                pst.setObject(i+1,objs[i]);\r\n            }\r\n\r\n            //执行sql语句\r\n            result = pst.executeUpdate();\r\n\r\n        } catch(Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //释放资源\r\n            DataSourceUtils.close(con,pst);\r\n        }\r\n\r\n        //返回结果\r\n        return result;\r\n    }\r\n}\r\n\r\n```\r\n\r\n##### 2.3JDBCTemplate类查询功能的编写\r\n\r\n- 实体类\r\n\r\n```java\r\n/*\r\n    学生实体类\r\n */\r\npublic class Student {\r\n    private Integer sid;\r\n    private String name;\r\n    private Integer age;\r\n    private Date birthday;\r\n\r\n    public Student() {\r\n    }\r\n\r\n    public Student(Integer sid, String name, Integer age, Date birthday) {\r\n        this.sid = sid;\r\n        this.name = name;\r\n        this.age = age;\r\n        this.birthday = birthday;\r\n    }\r\n\r\n    public Integer getSid() {\r\n        return sid;\r\n    }\r\n\r\n    public void setSid(Integer sid) {\r\n        this.sid = sid;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public Integer getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(Integer age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public Date getBirthday() {\r\n        return birthday;\r\n    }\r\n\r\n    public void setBirthday(Date birthday) {\r\n        this.birthday = birthday;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return "Student{" +\r\n                "sid=" + sid +\r\n                ", name=\'" + name + \'\\\'\' +\r\n                ", age=" + age +\r\n                ", birthday=" + birthday +\r\n                \'}\';\r\n    }\r\n}\r\n\r\n```\r\n\r\n- ResultSetHandler接口\r\n\r\n```java\r\n/*\r\n    用于处理结果集的接口\r\n */\r\npublic interface ResultSetHandler<T> {\r\n    //处理结果集的抽象方法。\r\n    <T> T handler(ResultSet rs);\r\n}\r\n\r\n```\r\n\r\n- BeanHandler实现类\r\n\r\n```java\r\n/*\r\n    实现类1：用于完成将查询出来的一条记录，封装到Student对象中\r\n */\r\npublic class BeanHandler<T> implements ResultSetHandler<T> {\r\n    //1.声明对象类型变量\r\n    private Class<T> beanClass;\r\n\r\n    //2.有参构造对变量赋值\r\n    public BeanHandler(Class<T> beanClass) {\r\n        this.beanClass = beanClass;\r\n    }\r\n\r\n    /*\r\n        将ResultSet结果集中的数据封装到beanClass类型对象中\r\n     */\r\n    @Override\r\n    public T handler(ResultSet rs) {\r\n        //3.声明对象\r\n        T bean = null;\r\n        try{\r\n            //4.创建传递参数的对象\r\n            bean = beanClass.newInstance();\r\n\r\n            //5.判断是否有结果集\r\n            if(rs.next()) {\r\n                //6.得到所有的列名\r\n                //6.1先得到结果集的源信息\r\n                ResultSetMetaData rsmd = rs.getMetaData();\r\n                //6.2还要得到有多少列\r\n                int columnCount = rsmd.getColumnCount();\r\n                //6.3遍历列数\r\n                for(int i = 1; i <= columnCount; i++) {\r\n                    //6.4得到每列的列名\r\n                    String columnName = rsmd.getColumnName(i);\r\n                    //6.5通过列名获取数据\r\n                    Object columnValue = rs.getObject(columnName);\r\n\r\n                    //6.6列名其实就是对象中成员变量的名称。于是就可以使用列名得到对象中属性的描述器(get和set方法)\r\n                    PropertyDescriptor pd = new PropertyDescriptor(columnName.toLowerCase(),beanClass);\r\n                    //6.7获取set方法\r\n                    Method writeMethod = pd.getWriteMethod();\r\n                    //6.8执行set方法，给成员变量赋值\r\n                    writeMethod.invoke(bean,columnValue);\r\n                }\r\n            }\r\n\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        //7.将对象返回\r\n        return bean;\r\n    }\r\n}\r\n\r\n```\r\n\r\n- BeanListHandler实现类\r\n\r\n```java\r\n/*\r\n    实现类2：用于将结果集封装到集合中\r\n */\r\npublic class BeanListHandler<T> implements ResultSetHandler<T> {\r\n\r\n    //1.声明对象变量\r\n    private Class<T> beanClass;\r\n\r\n    //2.有参构造为变量赋值\r\n    public BeanListHandler(Class<T> beanClass) {\r\n        this.beanClass = beanClass;\r\n    }\r\n\r\n    @Override\r\n    public List<T> handler(ResultSet rs) {\r\n        //3.创建集合对象\r\n        List<T> list = new ArrayList<>();\r\n\r\n        try{\r\n            //4.遍历结果集对象\r\n            while(rs.next()) {\r\n                //5.创建传递参数的对象\r\n                T bean = beanClass.newInstance();\r\n                //6.得到所有的列名\r\n                //6.1先得到结果集的源信息\r\n                ResultSetMetaData rsmd = rs.getMetaData();\r\n                //6.2还要得到有多少列\r\n                int columnCount = rsmd.getColumnCount();\r\n                //6.3遍历列数\r\n                for(int i = 1; i <= columnCount; i++) {\r\n                    //6.4得到每列的列名\r\n                    String columnName = rsmd.getColumnName(i);\r\n                    //6.5通过列名获取数据\r\n                    Object columnValue = rs.getObject(columnName);\r\n\r\n                    //6.6列名其实就是对象中成员变量的名称。于是就可以使用列名得到对象中属性的描述器(get和set方法)\r\n                    PropertyDescriptor pd = new PropertyDescriptor(columnName.toLowerCase(),beanClass);\r\n                    //6.7获取set方法\r\n                    Method writeMethod = pd.getWriteMethod();\r\n                    //6.8执行set方法，给成员变量赋值\r\n                    writeMethod.invoke(bean,columnValue);\r\n                }\r\n                //7.将对象保存到集合中\r\n                list.add(bean);\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n        //8.返回结果\r\n        return list;\r\n    }\r\n}\r\n\r\n```\r\n\r\n- ScalarHandler实现类\r\n\r\n```java\r\n/*\r\n    实现类3：用于返回一个聚合函数的查询结果\r\n */\r\npublic class ScalarHandler<T> implements ResultSetHandler<T> {\r\n    @Override\r\n    public Long handler(ResultSet rs) {\r\n        //1.声明一个变量\r\n        Long value = null;\r\n        try{\r\n            //2.判断是否有结果\r\n            if(rs.next()) {\r\n                //3.获取结果集的源信息\r\n                ResultSetMetaData rsmd = rs.getMetaData();\r\n                //4.获取第一列的列名\r\n                String columnName = rsmd.getColumnName(1);\r\n                //5.根据列名获取值\r\n                value = rs.getLong(columnName);\r\n            }\r\n        } catch(Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n        //6.将结果返回\r\n        return value;\r\n    }\r\n}\r\n\r\n```\r\n\r\n- JDBCTemplate类\r\n\r\n```java\r\npublic class JDBCTemplate {\r\n    private DataSource dataSource;\r\n    private Connection con;\r\n    private PreparedStatement pst;\r\n    private ResultSet rs;\r\n\r\n    public JDBCTemplate(DataSource dataSource) {\r\n        this.dataSource = dataSource;\r\n    }\r\n    \r\n    /*\r\n    \t专用于执行聚合函数sql语句的方法\r\n    */\r\n    public Long queryForScalar(String sql, ResultSetHandler<Long> rsh, Object...objs) {\r\n        Long result = null;\r\n        try{\r\n            con = dataSource.getConnection();\r\n            pst = con.prepareStatement(sql);\r\n\r\n            //获取sql语句中的参数源信息\r\n            ParameterMetaData pData = pst.getParameterMetaData();\r\n            int parameterCount = pData.getParameterCount();\r\n\r\n            //判断参数个数是否一致\r\n            if(parameterCount != objs.length) {\r\n                throw new RuntimeException("参数个数不匹配");\r\n            }\r\n\r\n            //为sql语句中的?占位符赋值\r\n            for (int i = 0; i < objs.length; i++) {\r\n                pst.setObject(i+1,objs[i]);\r\n            }\r\n\r\n            //执行sql语句\r\n            rs = pst.executeQuery();\r\n\r\n            //通过ScalarHandler方式对结果进行处理\r\n            result = rsh.handler(rs);\r\n\r\n        } catch(Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //释放资源\r\n            DataSourceUtils.close(con,pst,rs);\r\n        }\r\n\r\n        //将结果返回\r\n        return result;\r\n    }\r\n\r\n    /*\r\n    \t专用于查询所有记录sql语句的方法\r\n    */\r\n    public <T> List<T> queryForList(String sql, ResultSetHandler<T> rsh, Object...objs) {\r\n        List<T> list = new ArrayList<>();\r\n        try{\r\n            con = dataSource.getConnection();\r\n            pst = con.prepareStatement(sql);\r\n\r\n            //获取sql语句中的参数源信息\r\n            ParameterMetaData pData = pst.getParameterMetaData();\r\n            int parameterCount = pData.getParameterCount();\r\n\r\n            //判断参数个数是否一致\r\n            if(parameterCount != objs.length) {\r\n                throw new RuntimeException("参数个数不匹配");\r\n            }\r\n\r\n            //为sql语句中的?占位符赋值\r\n            for (int i = 0; i < objs.length; i++) {\r\n                pst.setObject(i+1,objs[i]);\r\n            }\r\n\r\n            //执行sql语句\r\n            rs = pst.executeQuery();\r\n\r\n            //通过BeanListHandler方式对结果进行处理\r\n            list = rsh.handler(rs);\r\n\r\n        } catch(Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //释放资源\r\n            DataSourceUtils.close(con,pst,rs);\r\n        }\r\n\r\n        //将结果返回\r\n        return list;\r\n    }\r\n\r\n\r\n    /*\r\n    \t专用于执行查询一条记录sql语句的方法\r\n    */\r\n    public <T> T queryForObject(String sql, ResultSetHandler<T> rsh, Object...objs) {\r\n        T obj = null;\r\n        try{\r\n            con = dataSource.getConnection();\r\n            pst = con.prepareStatement(sql);\r\n\r\n            //获取sql语句中的参数源信息\r\n            ParameterMetaData pData = pst.getParameterMetaData();\r\n            int parameterCount = pData.getParameterCount();\r\n\r\n            //判断参数个数是否一致\r\n            if(parameterCount != objs.length) {\r\n                throw new RuntimeException("参数个数不匹配");\r\n            }\r\n\r\n            //为sql语句中的?占位符赋值\r\n            for (int i = 0; i < objs.length; i++) {\r\n                pst.setObject(i+1,objs[i]);\r\n            }\r\n\r\n            //执行sql语句\r\n            rs = pst.executeQuery();\r\n\r\n            //通过BeanHandler方式对结果进行处理\r\n            obj = rsh.handler(rs);\r\n\r\n        } catch(Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //释放资源\r\n            DataSourceUtils.close(con,pst,rs);\r\n        }\r\n\r\n        //将结果返回\r\n        return obj;\r\n    }\r\n}\r\n\r\n```\r\n\r\n##### 2.4测试自定义JDBC框架的使用\r\n\r\n```java\r\npublic class JDBCTemplateTest {\r\n    //创建JDBCTemplate对象\r\n    JDBCTemplate template = new JDBCTemplate(DataSourceUtils.getDataSource());\r\n\r\n    @Test\r\n    public void selectScalar() {\r\n        //查询student表的记录条数\r\n        String sql = "SELECT COUNT(*) FROM student";\r\n        Long count = template.queryForScalar(sql, new ScalarHandler<Long>());\r\n        System.out.println(count);\r\n    }\r\n\r\n    @Test\r\n    public void selectAll() {\r\n        //查询所有学生信息\r\n        String sql = "SELECT * FROM student";\r\n        List<Student> list = template.queryForList(sql, new BeanListHandler<Student>(Student.class));\r\n        for(Student stu : list) {\r\n            System.out.println(stu);\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void selectOne() {\r\n        //查询张三这条记录\r\n        String sql = "SELECT * FROM student WHERE sid=?";\r\n        //通过BeanHandler将结果封装成一个Student对象\r\n        Student stu = template.queryForObject(sql, new BeanHandler<Student>(Student.class), 1);\r\n        System.out.println(stu);\r\n    }\r\n\r\n    @Test\r\n    public void insert() {\r\n        //新增周七记录\r\n        String sql = "INSERT INTO student VALUES (?,?,?,?)";\r\n        Object[] params = {5,"周七",27,"2007-07-07"};\r\n        int result = template.update(sql, params);\r\n        System.out.println(result);\r\n    }\r\n\r\n    @Test\r\n    public void delete() {\r\n        //删除周七这条记录\r\n        String sql = "DELETE FROM student WHERE sid=?";\r\n        int result = template.update(sql, 5);\r\n        System.out.println(result);\r\n    }\r\n\r\n    @Test\r\n    public void update() {\r\n        //修改张三的年龄为33\r\n        String sql = "UPDATE student SET age=? WHERE name=?";\r\n        Object[] params = {33,"张三"};\r\n        int result = template.update(sql,params);\r\n        System.out.println(result);\r\n    }\r\n}\r\n\r\n```\r\n\r\n',Re={data:function(){return{MainComponent:De}}},Me=Re,Ae=Object(d["a"])(Me,Ee,Ie,!1,null,"58b04fa8",null),Oe=Ae.exports,Pe={mixins:[ce["c"]],components:{m1:Te,m2:Oe},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"JDBC-01-授课笔记",value:"m1"},{label:"JDBC-02-授课笔记",value:"m2"}]}}},Le=Pe,qe=Object(d["a"])(Le,be,he,!1,null,"44cb1a20",null),ke=qe.exports,Be=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[t(""+n.tab,{tag:"component"})],1)},_e=[],Fe=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},He=[],Ne='\x3c!--\n * @Date           : 2021-04-12 17:00:35\n * @FilePath       : /jinnian-space/src/pages/java/module/javaweb/md/Servlet-授课.md\n * @Description    : \n--\x3e\n# Servlet-授课\n\n# 1 Servlet\n\n## 1.1 Servlet概述\n\nServlet是SUN公司提供的一套规范，名称就叫Servlet规范，它也是JavaEE规范之一。我们可以像学习Java基础一样，通过API来学习Servlet。这里需要注意的是，在我们之前JDK的API中是没有Servlet规范的相关内容，需要使用JavaEE的API。目前在Oracle官网中的最新版本是[JavaEE8](https://www.oracle.com/technetwork/java/javaee/documentation/ee8-release-notes-3894362.html)，该网址中介绍了JavaEE8的一些新特性。当然，我们可以通过访问[官方API](https://javaee.github.io/javaee-spec/javadocs/)，学习和查阅里面的内容。\n\n打开官方API网址，在左上部分找到javax.servlet包，在左下部分找到Servlet，如下图显示：\n\n![Servlet的API官网](./img/java/javaweb/Servlet-授课.assets/Servlet的API官网.png)\n\n通过阅读API，我们得到如下信息：\n\n第一：Servlet是一个运行在web服务端的java小程序\n\n第二：它可以用于接收和响应客户端的请求\n\n第三：要想实现Servlet功能，可以实现Servlet接口，继承GenericServlet或者HttpServlet\n\n第四：每次请求都会执行service方法\n\n第五：Servlet还支持配置\n\n具体请看下图：\n\n![ServletAPI详解](./img/java/javaweb/Servlet-授课.assets/ServletAPI详解.png)\n\n## 1.2 Servlet入门\n\n### 1.2.1 Servlet编码步骤\n\n#### 1）编码步骤\n\n**第一步：前期准备-创建JavaWeb工程**\n\n**第二步：编写一个普通类继承GenericServlet并重写service方法**\n\n**第三步：在web.xml配置Servlet**\n\n#### 2）测试\n\n**在Tomcat中部署项目**\n\n**在浏览器访问Servlet**\n\n![测试入门案例执行](./img/java/javaweb/Servlet-授课.assets/测试入门案例执行.png)\n\n### 1.2.2 Servlet执行过程分析\n\n我们通过浏览器发送请求，请求首先到达Tomcat服务器，由服务器解析请求URL，然后在部署的应用列表中找到我们的应用。接下来，在我们的应用中找应用里的web.xml配置文件，在web.xml中找到FirstServlet的配置，找到后执行service方法，最后由FirstServlet响应客户浏览器。整个过程如下图所示：\n\n![Servlet执行过程图](./img/java/javaweb/Servlet-授课.assets/Servlet执行过程图.jpg)\n\n一句话总结执行过程：\n\n浏览器——>Tomcat服务器——>我们的应用——>应用中的web.xml——>FirstServlet——>响应浏览器\n\n### 1.2.3 Servlet类视图\n\n在《Tomcat和Http协议》这天课程和刚才的入门案例中，我们都定义了自己的Servlet，实现的方式都是选择继承GenericServlet，在Servlet的API介绍中，它提出了我们除了继承GenericServlet外还可以继承HttpServlet，通过查阅servlet的类视图，我们看到GenericServlet还有一个子类HttpServlet。同时，在service方法中还有参数ServletRequest和ServletResponse，它们的关系如下图所示：\n\n![Servlet类视图](./img/java/javaweb/Servlet-授课.assets/Servlet类视图.png)\n\n### 1.2.4 Servlet编写方式\n\n#### 1）编写方式说明\n\n我们在实现Servlet功能时，可以选择以下三种方式：\n\n第一种：实现Servlet接口，接口中的方法必须全部实现。\n\n​\t\t\t  使用此种方式，表示接口中的所有方法在需求方面都有重写的必要。此种方式支持最大程度的自定义。\n\n第二种：继承GenericServlet，service方法必须重写，其他方可根据需求，选择性重写。\n\n​\t\t\t  使用此种方式，表示只在接收和响应客户端请求这方面有重写的需求，而其他方法可根据实际需求选择性重写，使我们的开发Servlet变得简单。但是，此种方式是和HTTP协议无关的。\n\n第三种：继承HttpServlet，它是javax.servlet.http包下的一个抽象类，是GenericServlet的子类。<b><font color=\'red\'>如果我们选择继承HttpServlet时，只需要重写doGet和doPost方法，不要覆盖service方法。</font></b>\n\n​\t\t\t\t使用此种方式，表示我们的请求和响应需要和HTTP协议相关。也就是说，我们是通过HTTP协议来访问的。那么每次请求和响应都符合HTTP协议的规范。请求的方式就是HTTP协议所支持的方式（目前我们只知道GET和POST，而实际HTTP协议支持7种请求方式，GET POST PUT DELETE TRACE OPTIONS HEAD )。\n\n#### 2）HttpServlet的使用细节\n\n**第一步：在入门案例的工程中创建一个Servlet继承HttpServlet**\n\n<font color=\'red\'>注意：不要重写任何方法</font>，如下图所示：\n\n![HttpServlet的使用1](./img/java/javaweb/Servlet-授课.assets/HttpServlet的使用1.png)\n\n![HttpServlet的使用2](./img/java/javaweb/Servlet-授课.assets/HttpServlet的使用2.png)\n\n**第二步：部署项目并测试访问**\n\n当我们在地址栏输入ServletDemo2的访问URL时，出现了访问错误，状态码是405。提示信息是：方法不允许。\n\n**第三步：分析原因** \n\n得出HttpServlet的使用结论：\n\n​\t <b><font color=\'red\'>我们继承了HttpServlet，需要重写里面的doGet和doPost方法来接收get方式和post方式的请求。</font></b>\n\n为了实现代码的可重用性，我们只需要在doGet或者doPost方法中一个里面提供具体功能即可，而另外的那个方法只需要调用提供了功能的方法。\n\n## 1.3 Servlet使用细节\n\n### 1.3.1 Servlet的生命周期\n\n对象的生命周期，就是对象从生到死的过程，即：出生——活着——死亡。用更偏向 于开发的官方说法就是对象创建到销毁的过程。\n\n出生：请求第一次到达Servlet时，对象就创建出来，并且初始化成功。只出生一次，就放到内存中。\n\n活着：服务器提供服务的整个过程中，该对象一直存在，每次只是执行service方法。\n\n死亡：当服务停止时，或者服务器宕机时，对象消亡。\n\n通过分析Servlet的生命周期我们发现，它的实例化和初始化只会在请求第一次到达Servlet时执行，而销毁只会在Tomcat服务器停止时执行，由此我们得出一个结论，Servlet对象只会创建一次，销毁一次。所以，Servlet对象只有一个实例。如果一个对象实例在应用中是唯一的存在，那么我们就说它是单实例的，即运用了单例模式。\n\n### 1.3.2 Servlet的线程安全\n\n由于Servlet运用了单例模式，即整个应用中只有一个实例对象，所以我们需要分析这个唯一的实例中的类成员是否线程安全。接下来，我们来看下面的的示例：\n\n```java\n/*\n    Servlet线程安全\n */\npublic class ServletDemo04 extends HttpServlet{\n    //1.定义用户名成员变量\n    //private String username = null;\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String username = null;\n        //synchronized (this) {\n            //2.获取用户名\n            username = req.getParameter("username");\n\n            try {\n                Thread.sleep(3000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            //3.获取输出流对象\n            PrintWriter pw = resp.getWriter();\n\n            //4.响应给客户端浏览器\n            pw.print("welcome:" + username);\n\n            //5.关流\n            pw.close();\n        //}\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n```\n\n启动两个浏览器，输入不同的参数，访问之后发现输出的结果都是一样，所以出现线程安全问题\n\n![Servlet的线程安全问题](./img/java/javaweb/Servlet-授课.assets/Servlet的线程安全问题.png)\n\n通过上面的测试我们发现，在Servlet中定义了类成员之后，多个浏览器都会共享类成员的数据。其实每一个浏览器端发送请求，就代表是一个线程，那么多个浏览器就是多个线程，所以测试的结果说明了多个线程会共享Servlet类成员中的数据，其中任何一个线程修改了数据，都会影响其他线程。因此，我们可以认为Servlet它不是线程安全的。\n\n分析产生这个问题的根本原因，其实就是因为Servlet是单例，单例对象的类成员只会随类实例化时初始化一次，之后的操作都是改变，而不会重新初始化。\n\n解决这个问题也非常简单，就是在Servlet中定义类成员要慎重。如果类成员是共用的，并且只会在初始化时赋值，其余时间都是获取的话，那么是没问题。如果类成员并非共用，或者每次使用都有可能对其赋值，那么就要考虑线程安全问题了，把它定义到doGet或者doPost方法里面去就可以了。\n\n### 1.3.3 Servlet的注意事项\n\n#### 1）映射Servlet的细节\n\nServlet支持三种映射方式，以达到灵活配置的目的。\n\n首先编写一个Servlet，代码如下：\n\n```java\n/**\n * 演示Servlet的映射方式\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletDemo5 extends HttpServlet {\n\n    /**\n     * doGet方法输出一句话\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println("ServletDemo5接收到了请求");\n    }\n\n    /**\n     * 调用doGet方法\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n```\n\n**第一种：指名道姓的方式**\n\n​\t\t\t   此种方式，只有和映射配置一模一样时，Servlet才会接收和响应来自客户端的请求。\n\n​\t\t\t   例如：映射为：/servletDemo5\n\n​\t\t\t\t\t\t   访问URL：http://localhost:8585/servlet_demo/servletDemo5\n\n![Servlet映射1](./img/java/javaweb/Servlet-授课.assets/Servlet映射1.png)\n\n**第二种：/开头+通配符的方式**\n\n​\t\t\t   此种方式，只要符合目录结构即可，不用考虑结尾是什么。\n\n​\t\t\t\t例如：映射为：/servlet/*\n\n​\t\t\t\t\t\t\t访问URL：http://localhost:8585/servlet/itheima\n\n​\t\t\t\t\t\t\t\t\t\t\t   http://localhost:8585/servlet/itcast.do\n\n​\t\t\t\t\t\t\t这两个URL都可以。因为用的*，表示/servlet/后面的内容是什么都可以。\n\n![Servlet映射2](./img/java/javaweb/Servlet-授课.assets/Servlet映射2.png)\n\n**第三种：通配符+固定格式结尾**\n\n​\t\t\t\t此种方式，只要符合固定结尾格式即可，其前面的访问URI无须关心（注意协议，主机和端口必须正确）\n\n​\t\t\t\t例如：映射为：*.do\n\n​\t\t\t\t\t\t\t访问URL：http://localhost:8585/servlet/itcast.do\n\n​\t\t\t\t\t\t\t\t\t\t\t\thttp://localhost:8585/itheima.do\n\n​\t\t\t\t\t\t\t这两个URL都可以方法。因为都是以.do作为结尾，而前面用*号通配符配置的映射，所有无须关心。\n\n![Servlet映射3](./img/java/javaweb/Servlet-授课.assets/Servlet映射3.png)\n\n通过测试我们发现，Servlet支持多种配置方式，但是由此也引出了一个问题，当有两个及以上的Servlet映射都符合请求URL时，由谁来响应呢？注意：HTTP协议的特征是一请求一响应的规则。那么有一个请求，必然有且只有一个响应。所以，我们接下来明确一下，多种映射规则的优先级。\n\n先说结论：指名道姓的方式优先级最高，带有通配符的映射方式，有/的比没/的优先级高\n\n所以，我们前面讲解的三种映射方式的优先级为：第一种>第二种>第三种。\n\n演示代码如下：\n\n```java\n/**\n * 它和ServletDemo5组合演示Servlet的访问优先级问题\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletDemo6 extends HttpServlet {\n\n    /**\n     * doGet方法输出一句话\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println("ServletDemo6接收到了请求");\n    }\n\n    /**\n     * 调用doGet方法\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n```\n\n```xml\n\x3c!--配置ServletDemo6--\x3e\n<servlet>\n    <servlet-name>servletDemo6</servlet-name>\n    <servlet-class>com.itheima.web.servlet.ServletDemo6</servlet-class>\n</servlet>\n<servlet-mapping>\n    <servlet-name>servletDemo6</servlet-name>\n    <url-pattern>/*</url-pattern>\n</servlet-mapping>\n```\n\n运行结果如下：\n\n![Servlet的优先级](./img/java/javaweb/Servlet-授课.assets/Servlet的优先级.png)\n\n#### 2）多路径映射Servlet\n\n上一小节我们讲解了Servlet的多种映射方式，这一小节我们来介绍一下，一个Servlet的多种路径配置的支持。\n\n它其实就是给一个Servlet配置多个访问映射，从而可以根据不同请求URL实现不同的功能。\n\n首先，创建一个Servlet：\n\n```java\n/**\n * 演示Servlet的多路径映射\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletDemo7 extends HttpServlet {\n\n    /**\n     * 根据不同的请求URL，做不同的处理规则\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //1.获取当前请求的URI\n        String uri = req.getRequestURI();\n        uri = uri.substring(uri.lastIndexOf("/"),uri.length());\n        //2.判断是1号请求还是2号请求\n        if("/servletDemo7".equals(uri)){\n            System.out.println("ServletDemo7执行1号请求的业务逻辑：商品单价7折显示");\n        }else if("/demo7".equals(uri)){\n            System.out.println("ServletDemo7执行2号请求的业务逻辑：商品单价8折显示");\n        }else {\n            System.out.println("ServletDemo7执行基本业务逻辑：商品单价原价显示");\n        }\n    }\n\n    /**\n     * 调用doGet方法\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n```\n\n接下来，在web.xml配置Servlet：\n\n```xml\n\x3c!--配置ServletDemo7--\x3e\n<servlet>\n    <servlet-name>servletDemo7</servlet-name>\n    <servlet-class>com.itheima.web.servlet.ServletDemo7</servlet-class>\n</servlet>\n\x3c!--映射路径1--\x3e\n<servlet-mapping>\n    <servlet-name>servletDemo7</servlet-name>\n    <url-pattern>/demo7</url-pattern>\n</servlet-mapping>\n\x3c!--映射路径2--\x3e\n<servlet-mapping>\n    <servlet-name>servletDemo7</servlet-name>\n    <url-pattern>/servletDemo7</url-pattern>\n</servlet-mapping>\n\x3c!--映射路径3--\x3e\n<servlet-mapping>\n    <servlet-name>servletDemo7</servlet-name>\n    <url-pattern>/servlet/*</url-pattern>\n</servlet-mapping>\n```\n\n最后，启动服务测试运行结果：\n\n![多路径URL映射](./img/java/javaweb/Servlet-授课.assets/多路径URL映射.png)\n\n#### 3）启动时创建Servlet\n\n我们前面讲解了Servlet的生命周期，Servlet的创建默认情况下是请求第一次到达Servlet时创建的。但是我们都知道，Servlet是单例的，也就是说在应用中只有唯一的一个实例，所以在Tomcat启动加载应用的时候就创建也是一个很好的选择。那么两者有什么区别呢？\n\n- 第一种：应用加载时创建Servlet，它的优势是在服务器启动时，就把需要的对象都创建完成了，从而在使用的时候减少了创建对象的时间，提高了首次执行的效率。它的弊端也同样明显，因为在应用加载时就创建了Servlet对象，因此，导致内存中充斥着大量用不上的Servlet对象，造成了内存的浪费。\n- 第二种：请求第一次访问是创建Servlet，它的优势就是减少了对服务器内存的浪费，因为那些一直没有被访问过的Servlet对象都没有创建，因此也提高了服务器的启动时间。而它的弊端就是，如果有一些要在应用加载时就做的初始化操作，它都没法完成，从而要考虑其他技术实现。\n\n通过上面的描述，相信同学们都能分析得出何时采用第一种方式，何时采用第二种方式。就是当需要在应用加载就要完成一些工作时，就需要选择第一种方式。当有很多Servlet的使用时机并不确定是，就选择第二种方式。\n\n在web.xml中是支持对Servlet的创建时机进行配置的，配置的方式如下：我们就以ServletDemo3为例。\n\n```xml\n\x3c!--配置ServletDemo3--\x3e\n<servlet>\n    <servlet-name>servletDemo3</servlet-name>\n    <servlet-class>com.itheima.web.servlet.ServletDemo3</servlet-class>\n    \x3c!--配置Servlet的创建顺序，当配置此标签时，Servlet就会改为应用加载时创建\n        配置项的取值只能是正整数（包括0），数值越小，表明创建的优先级越高\n    --\x3e\n    <load-on-startup>1</load-on-startup>\n</servlet>\n<servlet-mapping>\n    <servlet-name>servletDemo3</servlet-name>\n    <url-pattern>/servletDemo3</url-pattern>\n</servlet-mapping>\n```\n\n![Servlet的启动顺序](./img/java/javaweb/Servlet-授课.assets/Servlet的启动顺序.png)\n\n#### 4）默认Servlet\n\n默认Servlet是由服务器提供的一个Servlet，它配置在Tomcat的conf目录下的web.xml中。如下图所示：\n\n![默认Servlet](./img/java/javaweb/Servlet-授课.assets/默认Servlet.png)\n\n它的映射路径是<b><font color=\'red\'>`<url-pattern>/<url-pattern>`</font></b>，我们在发送请求时，首先会在我们应用中的web.xml中查找映射配置，找到就执行，这块没有问题。但是当找不到对应的Servlet路径时，就去找默认的Servlet，由默认Servlet处理。所以，一切都是Servlet。\n\n### 1.4 Servlet关系总图\n\n![Servlet类关系总视图](./img/java/javaweb/Servlet-授课.assets/Servlet类关系总视图.png)\n\n# 2 ServletConfig\n\n## 2.1 ServletConfig概述\n\n### 2.1.1 基本概念\n\n它是Servlet的配置参数对象，在Servlet规范中，允许为每个Servlet都提供一些初始化配置。所以，每个Servlet都一个自己的ServletConfig。它的作用是在Servlet初始化期间，把一些配置信息传递给Servlet。\n\n### 2.1.2 生命周期\n\n由于它是在初始化阶段读取了web.xml中为Servlet准备的初始化配置，并把配置信息传递给Servlet，所以生命周期与Servlet相同。这里需要注意的是，如果Servlet配置了`<load-on-startup>1</load-on-startup>`，那么ServletConfig也会在应用加载时创建。\n\n## 2.2 ServletConfig的使用\n\n### 2.2.1 如何获取\n\n首先，我们要清楚的认识到，它可以为每个Servlet都提供初始化参数，所以肯定可以在每个Servlet中都配置。那是配置在Servlet的声明部分，还是映射部分呢？我们接下来先准备一个Servlet，然后给同学们揭秘。\n\n```java\n/**\n * 演示Servlet的初始化参数对象\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletDemo8 extends HttpServlet {\n\n    //定义Servlet配置对象ServletConfig\n    private ServletConfig servletConfig;\n\n    /**\n     * 在初始化时为ServletConfig赋值\n     * @param config\n     * @throws ServletException\n     */\n    @Override\n    public void init(ServletConfig config) throws ServletException {\n        this.servletConfig = config;\n    }\n\n    /**\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //输出ServletConfig\n        System.out.println(servletConfig);\n    }\n\n    /**\n     * 调用doGet方法\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n```\n\n```xml\n\x3c!--配置ServletDemo8--\x3e\n<servlet>\n    <servlet-name>servletDemo8</servlet-name>\n    <servlet-class>com.itheima.web.servlet.ServletDemo8</servlet-class>\n</servlet>\n<servlet-mapping>\n    <servlet-name>servletDemo8</servlet-name>\n    <url-pattern>/servletDemo8</url-pattern>\n</servlet-mapping>\n```\n\n### 2.2.2 如何配置\n\n在上一小节中，我们已经准备好了Servlet，同时也获取到了它的ServletConfig对象，在本小节中我们将告诉同学们如何配置初始化参数，它需要使用`<servlet>`标签中的`<init-param>`标签来配置。这也就揭秘上一小节的悬念，Servlet的初始化参数都是配置在Servlet的声明部分的。并且每个Servlet都支持有多个初始化参数，并且初始化参数都是以键值对的形式存在的。接下来，我们看配置示例：\n\n```xml\n\x3c!--配置ServletDemo8--\x3e\n<servlet>\n    <servlet-name>servletDemo8</servlet-name>\n    <servlet-class>com.itheima.web.servlet.ServletDemo8</servlet-class>\n    \x3c!--配置初始化参数--\x3e\n    <init-param>\n        \x3c!--用于获取初始化参数的key--\x3e\n        <param-name>encoding</param-name>\n        \x3c!--初始化参数的值--\x3e\n        <param-value>UTF-8</param-value>\n    </init-param>\n    \x3c!--每个初始化参数都需要用到init-param标签--\x3e\n    <init-param>\n        <param-name>servletInfo</param-name>\n        <param-value>This is Demo8</param-value>\n    </init-param>\n</servlet>\n<servlet-mapping>\n    <servlet-name>servletDemo8</servlet-name>\n    <url-pattern>/servletDemo8</url-pattern>\n</servlet-mapping>\n```\n\n### 2.2.3 常用方法\n\n![ServletConfig对象](./img/java/javaweb/Servlet-授课.assets/ServletConfig对象.png)\n\n```java\n/**\n * 演示Servlet的初始化参数对象\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletDemo8 extends HttpServlet {\n\n    //定义Servlet配置对象ServletConfig\n    private ServletConfig servletConfig;\n\n    /**\n     * 在初始化时为ServletConfig赋值\n     * @param config\n     * @throws ServletException\n     */\n    @Override\n    public void init(ServletConfig config) throws ServletException {\n        this.servletConfig = config;\n    }\n\n    /**\n     * doGet方法输出一句话\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //1.输出ServletConfig\n        System.out.println(servletConfig);\n        //2.获取Servlet的名称\n        String servletName= servletConfig.getServletName();\n        System.out.println(servletName);\n        //3.获取字符集编码\n        String encoding = servletConfig.getInitParameter("encoding");\n        System.out.println(encoding);\n        //4.获取所有初始化参数名称的枚举\n        Enumeration<String> names = servletConfig.getInitParameterNames();\n        //遍历names\n        while(names.hasMoreElements()){\n            //取出每个name\n            String name = names.nextElement();\n            //根据key获取value\n            String value = servletConfig.getInitParameter(name);\n            System.out.println("name:"+name+",value:"+value);\n        }\n        //5.获取ServletContext对象\n        ServletContext servletContext = servletConfig.getServletContext();\n        System.out.println(servletContext);\n    }\n\n    /**\n     * 调用doGet方法\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n```\n\n![ServletConfig演示](./img/java/javaweb/Servlet-授课.assets/ServletConfig演示.png)\n\n# 3 ServletContext\n\n## 3.1 ServletContext概述\n\n### 3.1.1 基本介绍\n\nServletContext对象，它是应用上下文对象。每一个应用有且只有一个ServletContext对象。它可以实现让应用中所有Servlet间的数据共享。 \n\n### 3.1.2 生命周期\n\n出生——活着——死亡\n\n出生： 应用一加载，该对象就被创建出来了。一个应用只有一个实例对象。(Servlet和ServletContext都是单例的)\n\n活着：只要应用一直提供服务，该对象就一直存在。\n\n死亡：应用被卸载（或者服务器挂了），该对象消亡。\n\n### 3.1.3 域对象概念\n\n域对象的概念，它指的是对象有作用域，即有作用范围。\n\n域对象的作用，域对象可以实现数据共享。不同作用范围的域对象，共享数据的能力不一样。\n\n在Servlet规范中，一共有4个域对象。今天我们讲解的ServletContext就是其中一个。它也是我们接触的第一个域对象。它是web应用中最大的作用域，叫application域。每个应用只有一个application域。它可以实现整个应用间的数据共享功能。\n\n## 3.2 ServletContext的使用\n\n### 3.2 1 ServletContext介绍\n\n```\nServletContext 是应用上下文对象。每一个应用中只有一个 ServletContext 对象。\n作用：可以获得应用的全局初始化参数和达到 Servlet 之间的数据共享。\n生命周期：应用一加载则创建，应用被停止则销毁。\n```\n\n![](./img/java/javaweb/Servlet-授课.assets/ServletContext.png)\n\n### 3.2.2 域对象\n\n```\n域对象指的是对象有作用域。也就是有作用范围。域对象可以实现数据的共享。不同作用范围的域对象，共享数据的能力也不一样。\n\n在 Servlet 规范中，一共有 4 个域对象。ServletContext 就是其中的一个。它也是 web 应用中最大的作用域，也叫 application 域。它可以实现整个应用之间的数据共享！\n```\n\n\n\n### 3.2.3 ServletContext配置\n\nServletContext既然被称之为应用上下文对象，所以它的配置是针对整个应用的配置，而非某个特定Servlet的配置。它的配置被称为应用的初始化参数配置。\n\n配置的方式，需要在`<web-app>`标签中使用`<context-param>`来配置初始化参数。具体代码如下：\n\n```xml\n\x3c!--配置应用初始化参数--\x3e\n<context-param>\n    \x3c!--用于获取初始化参数的key--\x3e\n    <param-name>servletContextInfo</param-name>\n    \x3c!--初始化参数的值--\x3e\n    <param-value>This is application scope</param-value>\n</context-param>\n\x3c!--每个应用初始化参数都需要用到context-param标签--\x3e\n<context-param>\n    <param-name>globalEncoding</param-name>\n    <param-value>UTF-8</param-value>\n</context-param>\n```\n\n### 3.2.4 ServletContext常用方法\n\n```java\npublic class ServletContextDemo extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //获取ServletContext对象\n        ServletContext context = getServletContext();\n\n        //获取全局配置的globalEncoding\n        String value = context.getInitParameter("globalEncoding");\n        System.out.println(value);\n\n        //获取应用的访问虚拟目录\n        String contextPath = context.getContextPath();\n        System.out.println(contextPath);\n\n        //根据虚拟目录获取应用部署的磁盘绝对路径\n        //获取b.txt文件的绝对路径\n        String b = context.getRealPath("/b.txt");\n        System.out.println(b);\n\n        //获取c.txt文件的绝对路径\n        String c = context.getRealPath("/WEB-INF/c.txt");\n        System.out.println(c);\n\n        //获取a.txt文件的绝对路径\n        String a = context.getRealPath("/WEB-INF/classes/a.txt");\n        System.out.println(a);\n\n\n        //向域对象中存储数据\n        context.setAttribute("username","zhangsan");\n\n        //移除域对象中username的数据\n        //context.removeAttribute("username");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n```\n\n\n\n# 4 注解开发Servlet\n\n## 4.1 Servlet3.0规范\n\n首先，我们要先跟同学们明确一件事情，我们在《Tomcat和HTTP协议》课程中已经介绍了，我们使用的是Tomcat9，JavaEE规范要求是8，对应的Servlet规范规范应该是JavaEE8包含的4.x版本。\n\n但是，同学们要知道，在企业级应用的开发中，稳定远比追新版本重要的多。所以，我们虽然用到了Tomcat9和对应的JavaEE8，但是涉及的Servlet规范我们降板使用，用的是Servlet3.1版本。关于兼容性问题，同学们也无须担心，向下兼容的特性，在这里也依然适用。\n\n接下来，同学还有可能疑惑的地方就是，我们课程中明明使用的是Servlet3.1版本的规范，但是却总听老师提Servlet3.0规范，这两个到底有怎样的联系呢？\n\n现在就给同学们解惑，在大概十多年前，那会还是Servlet2.5的版本的天下，它最明显的特征就是Servlet的配置要求配在web.xml中，<b><font color=\'red\'>我们今天课程中在第4章节《注解开发Servlet》之前，全都是基于Servlet2.5规范编写的。</font></b>从2007年开始到2009年底，在这个时间段，软件开发开始逐步的演变，基于注解的配置理念开始逐渐出现，大量注解配置思想开始用于各种框架的设计中，例如：Spring3.0版本的Java Based Configuration，JPA规范，apache旗下的struts2和mybatis的注解配置开发等等。\n\nJavaEE6规范也是在这个期间设计并推出的，与之对应就是它里面包含了新的Servlet规范：<b><font color=\'red\'>Servlet3.0版本！</font></b>\n\n## 4.2 注解开发入门案例\n\n### 4.2.1 自动注解配置\n\n#### 1）配置步骤\n\n**第一步：创建JavaWeb工程，并移除web.xml**\n\n![Servlet注解开发1](./img/java/javaweb/Servlet-授课.assets/Servlet注解开发1.png)\n\n![Servlet注解开发2](./img/java/javaweb/Servlet-授课.assets/Servlet注解开发2.png)\n\n![注解开发Servlet移除web.xml](./img/java/javaweb/Servlet-授课.assets/注解开发Servlet移除web.xml.png)\n\n**第二步：编写Servlet**\n\n```java\n/**\n * 注解开发Servlet\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletDemo1 extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doPost(req,resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println("Servlet Demo1 Annotation");\n    }\n}\n```\n\n**第三步：使用注解配置Servlet**\n\n![注解配置Servlet映射](./img/java/javaweb/Servlet-授课.assets/注解配置Servlet映射.png)\n\n**第四步：测试**\n\n![注解配置Servlet测试](./img/java/javaweb/Servlet-授课.assets/注解配置Servlet测试.png)\n\n#### 2）注解详解\n\n```java\n/**\n * WebServlet注解\n * @since Servlet 3.0 (Section 8.1.1)\n */\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface WebServlet {\n\n    /**\n     * 指定Servlet的名称。\n     * 相当于xml配置中<servlet>标签下的<servlet-name>\n     */\n    String name() default "";\n\n    /**\n     * 用于映射Servlet访问的url映射\n     * 相当于xml配置时的<url-pattern>\n     */\n    String[] value() default {};\n\n    /**\n     * 相当于xml配置时的<url-pattern>\n     */\n    String[] urlPatterns() default {};\n\n    /**\n     * 用于配置Servlet的启动时机\n     * 相当于xml配置的<load-on-startup>\n     */\n    int loadOnStartup() default -1;\n\n    /**\n     * 用于配置Servlet的初始化参数\n     * 相当于xml配置的<init-param>\n     */\n    WebInitParam[] initParams() default {};\n\n    /**\n     * 用于配置Servlet是否支持异步\n     * 相当于xml配置的<async-supported>\n     */\n    boolean asyncSupported() default false;\n\n    /**\n     * 用于指定Servlet的小图标\n     */\n    String smallIcon() default "";\n\n    /**\n     * 用于指定Servlet的大图标\n     */\n    String largeIcon() default "";\n\n    /**\n     * 用于指定Servlet的描述信息\n     */\n    String description() default "";\n\n    /**\n     * 用于指定Servlet的显示名称\n     */\n    String displayName() default "";\n}\n```\n\n### 4.2.2 手动创建容器\n\n#### 1）前置说明\n\n在使用Servlet3.1版本的规范时，脱离了web.xml进行注解开发，它除了支持使用注解的配置方式外，还支持纯手动创建Servlet容器的方式。要想使用的话，必须遵循它的编写规范。它是从Servlet3.0规范才开始引入的，加入了一个新的接口：\n\n```java\npackage javax.servlet;\n\nimport java.util.Set;\n\n/**\n * 初始化Servlet容器必须实现此接口\n * 它是Servlet3.0规范提供的标准接口\n * @since Servlet 3.0\n */\npublic interface ServletContainerInitializer {\n     /**\n     * 启动容器时做一些初始化操作，例如注册Servlet,Filter,Listener等等。\n \t * @since Servlet 3.0\n     */\n    void onStartup(Set<Class<?>> c, ServletContext ctx) throws ServletException;\n}\n```\n\n同时可以利用@HandlesTypes注解，把要加载到onStartup方法中的类字节码传入进来，@HandlesTypes源码如下：\n\n```java\n/**\n * 用于指定要加载到ServletContainerInitializer接口实现了中的字节码\n * @see javax.servlet.ServletContainerInitializer\n * @since Servlet 3.0\n */\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface HandlesTypes {\n\n    /**\n     * 指定要加载到ServletContainerInitializer实现类的onStartUp方法中类的字节码。\n     * 字节码可以是接口，抽象类或者普通类。\n     */\n    Class[] value();\n}\n```\n\n#### 2）编写步骤\n\n**第一步：创建工程，并移除web.xml**\n\n![手动创建容器之创建工程](./img/java/javaweb/Servlet-授课.assets/手动创建容器之创建工程.png)\n\n![手动创建容器之移除web.xml](./img/java/javaweb/Servlet-授课.assets/手动创建容器之移除web.xml.png)\n\n**第二步：编写Servlet**\n\n```java\n/**\n * 注解开发Servlet 之 手动初始化容器\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletDemo1 extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doPost(req,resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println("Servlet Demo1 Annotation manual");\n    }\n}\n```\n\n**第三步：创建初始化容器的类，并按照要求配置**\n\n```java\n/**\n * 初始化容器操作\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class MyServletContainerInitializer implements ServletContainerInitializer {\n\n    @Override\n    public void onStartup(Set<Class<?>> c, ServletContext ctx) throws ServletException {\n       \n    }\n}\n```\n\n在脱离web.xml时，要求在src目录下包含一个META-INF目录，位置和及字母都不能改变，且严格区分大小写。在目录中创建一个名称为`javax.servlet.ServletContainerInitializer`的文件，里面写实现了`ServletContainerInitializer`接口的全限定类名。如下图所示：\n\n![手动创建容器之初始化容器的配置](./img/java/javaweb/Servlet-授课.assets/手动创建容器之初始化容器的配置.png)\n\n**第四步：编写注册Servlet的代码**\n\n![手动创建容器之编写注册Servlet的代码](./img/java/javaweb/Servlet-授课.assets/手动创建容器之编写注册Servlet的代码.png)\n\n**第五步：测试**\n\n![手动创建容器之测试](./img/java/javaweb/Servlet-授课.assets/手动创建容器之测试.png)\n\n# 5 Servlet应用案例-学生管理系统\n\n## 5.1 案例介绍\n\n### 5.1.1 案例需求\n\n在昨天的课程讲解中，我们用Tomcat服务器替代了SE阶段的学生管理系统中自己写的服务器。今后我们进入企业肯定也会使用成型的产品，而不会自己去写服务器（除非是专门做应用服务器的公司）。\n\n从今天开始案例正式进入了编码阶段，它是延续了JavaSE阶段课程的学生管理系统。并且分析了SE中系统的各类问题，在JavaWeb阶段学习，就是要通过每天的学习，逐步解决SE阶段学生管理系统中的遗留问题。\n\n今天，我们将会去解决下面这个问题：<b><font color=\'red\'>保存学生</font></b>。也就是让数据真正的动起来，本质就是通过html发送一个请求，把表单中填写的数据带到服务器端。因为每个使用者在表单填写的内容不一样，所有最终存起来的也就不一样了。\n\n### 5.1.2 技术选型\n\n这是一个全新的案例，而不是在SE阶段的案例上进行改造。所以我们用项目的方式来去约束这个案例。\n\n任何一个项目，在立项之初都会有技术选型，也就是定义使用的技术集，这里面包含很多。例如：表现层技术，持久层技术，数据库技术等等。\n\n我们今天只针对表现层进行编码，所以就先来定义表现层技术。表现层技术的选型就是Servlet+HTML的组合。\n\n由HTML中编写表单，Servlet中定义接收请求的方法，最终把表单数据输出到控制台即可。<b>我们Servlet的配置方式仍然选择基于web.xml的配置方式。</b>\n',Je={data:function(){return{MainComponent:Ne}}},Ue=Je,Ge=Object(d["a"])(Ue,Fe,He,!1,null,"e9f59c5e",null),Ve=Ge.exports,ze=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},We=[],Qe='# Request&Response-授课\n\n# 1 响应对象\n\n## 1.1 响应对象概述\n\n### 1.1.1 关于响应\n\n响应，它表示了服务器端收到请求，同时也已经处理完成，把处理的结果告知用户。简单来说，指的就是服务器把请求的处理结果告知客户端。在B/S架构中，响应就是把结果带回浏览器。\n\n响应对象，顾名思义就是用于在JavaWeb工程中实现上述功能的对象。\n\n### 1.1.2 常用响应对象\n\n响应对象也是是Servlet规范中定义的，它包括了协议无关的和协议相关的。\n\n协议无关的对象标准是：ServletResponse接口\n\n协议相关的对象标准是：HttpServletResponse接口\n\n类结构图如下：\n\n![响应类视图](./img/java/javaweb/Request&Response-授课.assets/响应类视图.png)\n\n我们课程中涉及的响应对象都是和HTTP协议相关的。即使用的是HttpServletResponse接口的实现类。\n\n这里有些同学可能会产生疑问，我们在使用Servlet时，需要定义一个类，然后实现Servlet接口（或者继承它的实现类）。现在我们想要实现响应功能，要不要定义一个类，然后实现HttpServletResponse接口呢？\n\n<b>此问题的答案是否定的，我们无需这么做。</b>我们只需要在自己写的Servlet中直接使用即可，因为这个对象的实现类是由Tomcat提供的，无须我们自定义。同时它还会帮我们把对象创建出来并传入doGet和doPost方法中。\n\n## 1.2 常用方法介绍 \n\n在HttpServletResponse接口中提供了很多方法，接下来我们通过API文档，来了解一下这些方法。\n\n![响应方法详解](./img/java/javaweb/Request&Response-授课.assets/响应方法详解.png)\n\n常用状态码：\n\n| 状态码 |                            说明                            |\n| :----: | :--------------------------------------------------------: |\n|  200   |                          执行成功                          |\n|  302   | 它和307一样，都是用于重定向的状态码。只是307目前已不再使用 |\n|  304   |                 请求资源未改变，使用缓存。                 |\n|  400   |            请求错误。最常见的就是请求参数有问题            |\n|  404   |                       请求资源未找到                       |\n|  405   |                      请求方式不被支持                      |\n|  500   |                     服务器运行内部错误                     |\n\n状态码首位含义：\n\n| 状态码 |    说明    |\n| :----: | :--------: |\n|  1xx   |    消息    |\n|  2xx   |    成功    |\n|  3xx   |   重定向   |\n|  4xx   | 客户端错误 |\n|  5xx   | 服务器错误 |\n\n## 1.3 响应对象的使用示例\n\n### 1.3.1 响应-字节流输出中文问题\n\n```java\n/**\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ResponseDemo1 extends HttpServlet {\n\n    /**\n     * 演示字节流输出的乱码问题\n     */\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        /**\n         * 问题：\n         * \t  String str = "字节流中文乱码问题";\n         * \t     使用字节流输出，会不会产生中文乱码？\n         * 答案：\n         * \t  会产生乱码\n         * 原因：\n         * \tString str = "字节流中文乱码问题"; 在保存时用的是IDEA创建文件使用的字符集UTF-8。\n         * \t到浏览器上显示，chrome浏览器和ie浏览器默认的字符集是GB2312(其实就是GBK)，存和取用的不是同一个码表，就会产生乱码。\n         *\n         * 引申：\n         *   如果产生了乱码，就是存和取用的不是同一个码表\n         * 解决办法：\n         *   把存和取的码表统一。\n         */\n        String str = "字节流输出中文的乱码问题";//UTF-8的字符集，此时浏览器显示也需要使用UTF-8的字符集。\n        //1.拿到字节流输出对象\n        ServletOutputStream sos = response.getOutputStream();\n        /**\n         * 解决办法：\n         * \t第一种解决办法：\n         *      修改浏览器的编码，使用右键——编码——改成UTF-8。(不推荐使用，我们的应用尽量不要求用户取做什么事情)\n         *      ie和火狐浏览器可以直接右键设置字符集。而chrome需要安装插件，很麻烦。\n         * \t第二种解决办法： (不建议使用，因为不好记)\n         *  \t向页面上输出一个meta标签，内容如下： <meta http-equiv="content-type" content="text/html;charset=UTF-8">\n         *      其实它就是指挥了浏览器，使用哪个编码进行显示。\n         *  第三种解决办法：\n         * \t\t设置响应消息头，告知浏览器响应正文的MIME类型和字符集\n         * \t\tresponse.setHeader("Content-Type","text/html;charset=UTF-8");\n         * \t第四种解决办法：我们推荐使用的办法\n         * \t    它的本质就是设置了一个响应消息头\n         *  \tresponse.setContentType("text/html;charset=UTF-8");\n         */\n        //第二种解决办法：sos.write("<meta http-equiv=\'content-type\' content=\'text/html;charset=UTF-8\'>".getBytes());\n        //第三种解决办法：response.setHeader("Content-Type","text/html;charset=UTF-8");\n        //第四种解决办法：\n        response.setContentType("text/html;charset=UTF-8");\n        //2.把str转换成字节数组之后输出到浏览器\n        sos.write(str.getBytes("UTF-8")); \n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n}\n```\n\n![ResponseDemo1](./img/java/javaweb/Request&Response-授课.assets/ResponseDemo1.png)\n\n### 1.3.2 响应-字符流输出中文问题\n\n```java\n/**\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ResponseDemo2 extends HttpServlet {\n\n    /**\n     * 字符流输出中文乱码\n     * @param request\n     * @param response\n     * @throws ServletException\n     * @throws IOException\n     */\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String str = "字符流输出中文乱码";\n        //response.setCharacterEncoding("UTF-8");\n\n        //设置响应正文的MIME类型和字符集\n        response.setContentType("text/html;charset=UTF-8");\n        //1.获取字符输出流\n        PrintWriter out = response.getWriter();\n        //2.使用字符流输出中文\n        /**\n         * 问题：\n         * \tout.write(str); 直接输出，会不会产生乱码\n         * 答案：\n         * \t会产生乱码\n         * 原因：\n         * \t存用的什么码表：UTF-8\n         *  在浏览器取之前，字符流PrintWriter已经获取过一次了，PrintWriter它在取的时候出现了乱码。\n         * \t浏览器取默认用的是GBK。（本地系统字符集）\n         *\n         *  UTF-8(存)————>PrintWriter ISO-8859-1(取)\t\t\t\t\t乱\n         *  PrintWirter ISO-8859-1(存)————>浏览器 GBK(取)\t\t\t\t乱\n         *\n         * 解决办法：\n         * \t改变PrintWriter的字符集，PrintWriter是从response对象中获取的，其实设置response的字符集。\n         *  注意：设置response的字符集，需要在拿流之前。\n         *  response.setCharacterEncoding("UTF-8");\n         *\n         * response.setContentType("text/html;charset=UTF-8");\n         * 此方法，其实是做了两件事：\n         * \t\t1.设置响应对象的字符集（包括响应对象取出的字符输出流）\n         * \t\t2.告知浏览器响应正文的MIME类型和字符集\n         */\n\n        out.write(str);\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n}\n```\n\n![ResponseDemo2](./img/java/javaweb/Request&Response-授课.assets/ResponseDemo2.png)\n\n### 1.3.3 响应-生成验证码\n\n```java\n/**\n * @author 黑马程序员\n * @Company http://www.itheima.com\n *\n */\npublic class ResponseDemo3 extends HttpServlet {\n\n    /**\n     * 输出图片\n     * @param request\n     * @param response\n     * @throws ServletException\n     * @throws IOException\n     */\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        int width = 200;\n        int height = 35;\n        /**\n         * 实现步骤:\n         * \t1.创建图像内存对象\n         *  2.拿到画笔\n         *  3.设置颜色，画矩形边框\n         *  4.设置颜色，填充矩形\n         *  5.设置颜色，画干扰线\n         *  6.设置颜色，画验证码\n         *  7.把内存图像输出到浏览器上\n         */\n        //创建内存图像\n        BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);//参数：宽度，高度 （指的都是像素），使用的格式（RGB）\n        Graphics g = image.getGraphics();//画笔就一根\n\n        //设置颜色\n        g.setColor(Color.BLUE);\n        //画边框\n        g.drawRect(0, 0, width, height);\n\n        //设置颜色\n        g.setColor(Color.GRAY);\n        //填充矩形\n        g.fillRect(1, 1, width-2, height-2);\n\n        //设置颜色\n        g.setColor(Color.WHITE);\n        //拿随机数对象\n        Random r = new Random();\n        //画干扰线 10条\n        for(int i=0;i<10;i++){\n            g.drawLine(r.nextInt(width), r.nextInt(height),r.nextInt(width), r.nextInt(height));\n        }\n\n        //设置颜色\n        g.setColor(Color.RED);\n        //改变字体大小\n        Font font = new Font("宋体", Font.BOLD,30);//参数：1字体名称。2.字体样式 3.字体大小\n        g.setFont(font);//设置字体\n        //画验证码\t4个\n        int x = 35;//第一个数的横坐标是35像素\n        for(int i=0;i<4;i++){\n            //r.nextInt(10)+""这种写法效率是十分低的\n            g.drawString(String.valueOf(r.nextInt(10)), x, 25);\n            x+=35;\n        }\n\n        //输出到浏览器上\n        //参数： 1.内存对象。2.输出的图片格式。3.使用的输出流\n        ImageIO.write(image, "jpg", response.getOutputStream());\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n![ResponseDemo3](./img/java/javaweb/Request&Response-授课.assets/ResponseDemo3.png)\n\n### 1.3.4 设置响应消息头-控制缓存\n\n```java\n/**\n * 设置缓存时间\n * \t使用缓存的一般都是静态资源\n *  动态资源一般不能缓存。\n *  我们现在目前只掌握了Servlet，所以用Servlet做演示\n * @author 黑马程序员\n * @Company http://www.itheima.com\n *\n */\npublic class ResponseDemo4 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String str = "设置缓存时间";\n        /*\n         * 设置缓存时间，其实就是设置响应消息头：Expires 但是值是一个毫秒数。\n         * 使用的是\n         * \tresponse.setDateHeader();\n         *\n         * 缓存1小时，是在当前时间的毫秒数上加上1小时之后的毫秒值\n         */\n        response.setDateHeader("Expires",System.currentTimeMillis()+1*60*60*1000);\n        response.setContentType("text/html;charset=UTF-8");\n        response.getOutputStream().write(str.getBytes());\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n![ResponseDemo4_chrome](./img/java/javaweb/Request&Response-授课.assets/ResponseDemo4_chrome.png)\n\n![ResponseDemo4_ie](./img/java/javaweb/Request&Response-授课.assets/ResponseDemo4_ie.png)\n\n### 1.3.5 设置响应消息头定时刷新\n\n```java\n/**\n * 设置响应消息头：\n * 通过定时刷新演示添加消息头\n * @author 黑马程序员\n * @Company http://www.itheima.com\n *\n */\npublic class ResponseDemo5 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String str = "用户名和密码不匹配，2秒后转向登录页面...";\n        response.setContentType("text/html;charset=UTF-8");\n        PrintWriter out = response.getWriter();\n        out.write(str);\n        //定时刷新，其实就是设置一个响应消息头\n        response.setHeader("Refresh", "2;URL=/login.html");//Refresh设置的时间单位是秒，如果刷新到其他地址，需要在时间后面拼接上地址\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n![ResponseDemo5](./img/java/javaweb/Request&Response-授课.assets/ResponseDemo5.png)\n\n### 1.3.6 请求重定向：注意地址栏发生改变。\n\n```java\n/**\n * 设置响应状态码，实现重定向\n * 重定向的特点：\n * \t 两次请求，地址栏改变，浏览器行为，xxxx\n * @author 黑马程序员\n * @Company http://www.itheima.com\n *\n */\npublic class ResponseDemo6 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        //1.设置响应状态码\n//\t\tresponse.setStatus(302);\n        //2.定向到哪里去: 其实就是设置响应消息头，Location\n//\t\tresponse.setHeader("Location", "ResponseDemo7");\n\n        //使用重定向方法\n        response.sendRedirect("ResponseDemo7");//此行做了什么事，请看上面\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n```java\n/**\n * 重定向的目的地\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ResponseDemo7 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.getWriter().write("welcome to ResponseDemo7");\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n![ResponseDemo6](./img/java/javaweb/Request&Response-授课.assets/ResponseDemo6.png)\n\n### 1.3.7 响应和消息头组合应用-文件下载\n\n首先，在工程的web目录下新建一个目录uploads，并且拷贝一张图片到目录中，如下图所示：\n\n![文件下载的图片](./img/java/javaweb/Request&Response-授课.assets/文件下载的图片.png)\n\n文件下载的Servlet代码如下：\n\n```java\n/**\n * 文件下载\n * @author 黑马程序员\n * @Company http://www.itheima.com\n *\n */\npublic class ResponseDemo8 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        /*\n         * 文件下载的思路：\n         * \t\t1.获取文件路径\n         * \t\t2.把文件读到字节输入流中\n         * \t\t3.告知浏览器，以下载的方式打开（告知浏览器下载文件的MIME类型）\n         * \t\t4.使用响应对象的字节输出流输出到浏览器上\n         */\n        //1.获取文件路径（绝对路径）\n        ServletContext context = this.getServletContext();\n        String filePath = context.getRealPath("/uploads/6.jpg");//通过文件的虚拟路径，获取文件的绝对路径\n        //2.通过文件路径构建一个字节输入流\n        InputStream in  = new FileInputStream(filePath);\n        //3.设置响应消息头\n        response.setHeader("Content-Type", "application/octet-stream");//注意下载的时候，设置响应正文的MIME类型，用application/octet-stream\n        response.setHeader("Content-Disposition", "attachment;filename=1.jpg");//告知浏览器以下载的方式打开\n        //4.使用响应对象的字节输出流输出\n        OutputStream out = response.getOutputStream();\n        int len = 0;\n        byte[] by = new byte[1024];\n        while((len = in.read(by)) != -1){\n            out.write(by, 0, len);\n        }\n        in.close();\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n![ResponseDemo8](./img/java/javaweb/Request&Response-授课.assets/ResponseDemo8.png)\n\n### 1.3.8 响应对象注意事项\n\n**第一： response得到的字符流和字节流互斥，只能选其一**\n\n**第二：response获取的流不用关闭，由服务器关闭即可**\n\n```java\n/**\n * 使用Response对象获取流时候的注意事项：\n * \t1.我们使用response获取的流，可以不用关闭。服务器会给我们关闭。\n * \t2.在response对象中，字节流和字符流互斥，输出的时候，只能选择一个\n * @author zhy\n *\n */\npublic class ResponseDemo9 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String str = "test";\n        response.getOutputStream().write(str.getBytes());\n        //response.getWriter().write(str);\n//\t\tresponse.getOutputStream().write("haha".getBytes());\n\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n![ResponseDemo9](./img/java/javaweb/Request&Response-授课.assets/ResponseDemo9.png)\n\n# 2 请求对象\n\n## 2.1 请求对象概述\n\n### 2.1.1 关于请求\n\n请求，顾明思议，就是使用者希望从服务器端索取一些资源，向服务器发出询问。在B/S架构中，就是客户浏览器向服务器发出询问。在我们的JavaEE工程中，客户浏览器发出询问，要遵循HTTP协议所规定的。\n\n请求对象，就是在JavaEE工程中，用于发送请求的对象。我们常用的对象就是ServletRequest和HttpServletRequest，它们的区别就是是否和HTTP协议有关。\n\n### 2.1.2 常用请求对象\n\n![请求对象的类试图](./img/java/javaweb/Request&Response-授课.assets/请求对象的类试图.png)\n\n## 2.2 常用方法介绍\n\n![Request方法详解](./img/java/javaweb/Request&Response-授课.assets/Request方法详解.png)\n\n## 2.3 请求对象的使用示例\n\n### 2.3.1 请求对象常用方法1-获取各种路径\n\n```java\n/**\n * 请求对象的各种信息获取\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class RequestDemo1 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        //本机地址：服务器地址\n        String localAddr = request.getLocalAddr();\n        //本机名称：服务器名称\n        String localName = request.getLocalName();\n        //本机端口：服务器端口\n        int localPort = request.getLocalPort();\n        //来访者ip\n        String remoteAddr = request.getRemoteAddr();\n        //来访者主机\n        String remoteHost = request.getRemoteHost();\n        //来访者端口\n        int remotePort = request.getRemotePort();\n        //统一资源标识符\n        String URI = request.getRequestURI();\n        //统一资源定位符\n        String URL = request.getRequestURL().toString();\n        //获取查询字符串\n        String queryString = request.getQueryString();\n        //获取Servlet映射路径\n        String servletPath = request.getServletPath();\n\n        //输出内容\n\t\tSystem.out.println("getLocalAddr() is :"+localAddr);\n\t\tSystem.out.println("getLocalName() is :"+localName);\n\t\tSystem.out.println("getLocalPort() is :"+localPort);\n\t\tSystem.out.println("getRemoteAddr() is :"+remoteAddr);\n\t\tSystem.out.println("getRemoteHost() is :"+remoteHost);\n\t\tSystem.out.println("getRemotePort() is :"+remotePort);\n\t\tSystem.out.println("getRequestURI() is :"+URI);\n\t\tSystem.out.println("getRequestURL() is :"+URL);\n        System.out.println("getQueryString() is :"+queryString);\n        System.out.println("getServletPath() is :"+servletPath);\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n}\n```\n\n### 2.3.2 请求对象常用方法2-获取请求头信息\n\n```java\n/**\n * 获取请求消息头\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class RequestDemo2 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        //1.根据名称获取头的值\t一个消息头一个值\n        String value = request.getHeader("Accept-Encoding");\n        System.out.println("getHeader():"+value);\n\n        //2.根据名称获取头的值\t一个头多个值\n        Enumeration<String> values = request.getHeaders("Accept");\n        while(values.hasMoreElements()){\n            System.out.println("getHeaders():"+values.nextElement());\n        }\n\n        //3.获取请求消息头的名称的枚举\n        Enumeration<String> names = request.getHeaderNames();\n        while(names.hasMoreElements()){\n            String name = names.nextElement();\n            String value1 = request.getHeader(name);\n            System.out.println(name+":"+value1);\n        }\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n### 2.3.3 请求对象常用方法3-获取请求参数（非常重要）\n\n在本小节，我们会讲解HttpServletRequest对象获取请求参数的常用方法，以及把获取到的请求参数封装到实体类中的方式。首先，我们先来创建一个Servlet对象\n\n```java\n/**\n * 封装请求正文到javabean（数据模型）\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class RequestDemo3 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        /*\n         * 把下面\n         *\t\t1）获取请求参数\n         *\t\t2）封装请求参数到实体类中\n         * 中定义的test1到test8逐个添加到此处来运行即可。\n         */\n    }\n \n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n}\n```\n\n接下来，我们在来准备一个表单页面：\n\n```html\n<html>\n<head>\n\t<title>login to request demo 3</title>\n</head>\n<body>\n<form action="/day10_1122_requestresponse/RequestDemo3" method="post">\n\t用户名：<input type="text" name="username" /><br/>\n\t密码：<input type="password" name="password" /><br/>\n\t性别：<input type="radio" name="gender" value="1" checked>男\n\t<input type="radio" name="gender" value="0">女\n\t<br/>\n\t<input type="submit" value="注册" />\n</form>\n</body>\n</html>\n```\n\n现在，我们开始分析HttpServletRequest对象用于获取请求参数的方法：\n\n#### 1）获取请求参数\n\n**getParameter()方法的示例代码**\n\n```java\n/**\n * 获取请求正文，一个名称对应一个值。\t\t\t\t\t\t\t\t没有使用确认密码\n * @param request\n * @param response\n * @throws ServletException\n * @throws IOException\n */\nprivate void test1(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n    //1.获取请求正文\n    String username = request.getParameter("username");\n    String password = request.getParameter("password");\n    String gender = request.getParameter("gender");\n    System.out.println(username+","+password+","+gender);\n}\n```\n\n**getParameterValues()方法的示例代码**\n\n```java\n/**\n * 获取请求正文，一个名称可能对应多个值\t\t\t\t\t\t\t\t\t使用了确认密码\n * @param request\n * @param response\n * @throws ServletException\n * @throws IOException\n*/\nprivate void test2(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n    //1.获取请求正文\n    String username = request.getParameter("username");\n    String[] password = request.getParameterValues("password");//当表单中有多个名称是一样时，得到是一个字符串数组\n    String gender = request.getParameter("gender");\n    System.out.println(username+","+Arrays.toString(password)+","+gender);\n}\n```\n\n```html\n<html>\n<head>\n\t<title>login to request demo 4</title>\n</head>\n<body>\n<form action="/day10_1122_requestresponse/RequestDemo4" method="post" enctype="multipart/form-data">\n\t用户名：<input type="text" name="username" /><br/>\n\t密码：<input type="password" name="password" /><br/>\n\t确认密码：<input type="password" name="password" /><br/>\n\t性别：<input type="radio" name="gender" value="1" checked>男\n\t<input type="radio" name="gender" value="0">女\n\t<br/>\n\t<input type="submit" value="注册" />\n</form>\n</body>\n</html>\n```\n\n**getParameterNames()方法的示例代码**\n\n```java\n/**\n * 获取请求正文，一个名称一个值。但是先要获取正文名称的枚举（key的枚举）\t\t\t\t没有使用确认密码\n * @param request\n * @param response\n * @throws ServletException\n * @throws IOException\n*/\nprivate void test3(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n    //1.获取请求正文名称的枚举\n    Enumeration<String> names = request.getParameterNames();\n    //2.遍历正文名称的枚举\n    while(names.hasMoreElements()){\n        String name = names.nextElement();\n        String value = request.getParameter(name);\n        System.out.println(name+":"+value);\n    }\n}\n```\n\n**总结：**\n\n​\t以上三个方法可以获取表单提交过来的请求参数。\n\n​\t参数的名称是一个字符串，参数的值可能是一个字符串，也可能是一个字符串数组。\n\n#### 2）封装请求参数到实体类中\n\n我们通过上面的方法可以获取到请求参数，但是如果参数过多，在进行传递时，方法的形参定义将会变得非常难看。此时我们应该用一个对象来描述这些参数，它就是实体类。这种类的定义，从基础阶段我们就开始使用了。在基础阶段，我们做过一个学生管理系统，用到了一个Student的类，它就是用于描述一个学生的实体类。\n\n我们现在要做的就是把表单中提交过来的数据填充到实体类中。\n\n**第一种：最简单直接的封装方式**\n\n```java\n/**\n * 封装请求正文到User对象中\t\t\t\t\t\t\t\t\t没有使用确认密码\n * @param request\n * @param response\n * @throws ServletException\n * @throws IOException\n */\nprivate void test4(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n    //1.获取请求正文\n    String username = request.getParameter("username");\n    String password = request.getParameter("password");\n    String gender = request.getParameter("gender");\n    //2.创建一个User对象\n    User user = new User();\n    System.out.println("封装前："+user.toString());\n    //3.把请求正文封装到user对象中\n    user.setUsername(username);\n    user.setPassword(password);\n    user.setGender(gender);\n    System.out.println("封装后："+user.toString());\n}\n```\n\n**第二种：使用反射方式封装**\n\n此种封装的使用要求是，表单`<input>`标签的name属性取值，必须和实体类中定义的属性名称一致。\n\n```java\n/**\n * 封装请求正文到javabean中\t\t\t\t\t\t\t\t\t\t没有使用确认密码\n * 使用反射+内省实现数据模型的封装\n * 内省：是sun公司推出的一套简化反射操作的规范。把javabean中的元素都封装成一个属性描述器。\n * \t        属性描述器中会有字段信息，get和set方法（取值或存值）\n * @param request\n * @param response\n * @throws ServletException\n * @throws IOException\n*/\nprivate void test5(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n    //1.获取请求正文名称的枚举\n    Enumeration<String> names = request.getParameterNames();\n    User user = new User();\n    System.out.println("封装前："+user.toString());\n    //2.遍历正文名称的枚举\n    while(names.hasMoreElements()){\n        String name = names.nextElement();\n        String value = request.getParameter(name);\n        try{\n            //1.拿到User对象中的属性描述器。是谁的属性描述器：是由构造函数的第一个参数决定的。第二个参数是指定javabean的字节码\n            PropertyDescriptor pd = new PropertyDescriptor(name, User.class);//参数指的就是拿哪个类的哪个属性的描述器\n            //2.设置javabean属性的值\n            Method method = pd.getWriteMethod();\n            //3.执行方法\n            method.invoke(user, value);//第一个参数是指的给哪个对象，第二个参数指的是赋什么值\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n    System.out.println("封装后："+user.toString());\n} \n```\n\n**第三种：使用反射封装，同时请求参数的值是一个数组**\n\n此种方式其实就是针对请求参数中包含name属性相同的参数，例如：密码和确认密码，还有爱好。\n\n```java\n/**\n * 获取请求正文的关系映射Map<String,String[]>\t\t\t\t使用确认密码\n * @param request\n * @param response\n * @throws ServletException\n * @throws IOException\n */\nprivate void test6(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n    //1.获取请求正文的映射关系\n    Map<String,String[]> map = request.getParameterMap();\n    //2.遍历集合\n    for(Map.Entry<String,String[]> me : map.entrySet()){\n        String name = me.getKey();\n        String[] value = me.getValue();\n        System.out.println(name+":"+Arrays.toString(value));\n    }\n} \n```\n\n当我们把请求参数获取出来之后，就要考虑如何针对数组的反射了，具体代码如下：\n\n```java\n /**\n * 封装请求正文到javabean。使用的是反射+内省\t\t\t\t\t\t使用了确认密码\n * @param request\n * @param response\n * @throws ServletException\n * @throws IOException\n */\nprivate void test7(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n    //1.获取请求正文的映射关系\n    Map<String,String[]> map = request.getParameterMap();\n    Users user = new Users();\n    System.out.println("封装前："+user.toString());\n    //2.遍历集合\n    for(Map.Entry<String,String[]> me : map.entrySet()){\n        String name = me.getKey();\n        String[] value = me.getValue();\n        try{\n            //1.拿到User对象中的属性描述器。是谁的属性描述器：是由构造函数的第一个参数决定的。第二个参数是指定javabean的字节码\n            PropertyDescriptor pd = new PropertyDescriptor(name, Users.class);//参数指的就是拿哪个类的哪个属性的描述器\n            //2.设置javabean属性的值\n            Method method = pd.getWriteMethod();\n            //3.执行方法\n            //判断参数到底是几个值\n            if(value.length > 1){//最少有2个元素\n                method.invoke(user, (Object)value);//第一个参数是指的给哪个对象，第二个参数指的是赋什么值\n            }else{\n                method.invoke(user, value);//第一个参数是指的给哪个对象，第二个参数指的是赋什么值\n            }\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n    System.out.println("封装后："+user.toString());\n}\n```\n\n当我们写完此种封装方式之后，同学们可以发现，我们绝大多数封装都可以使用这段代码来实现。并且，无论是谁来写这段通用的封装代码，其代码内容都是大同小异的。**那么，我们就可以得出一个很有趣的结论：一般遇到这种情况时，肯定有人帮我们写好了，我们只需要用就行了。**我们后面还会遇到类似这样的情况。\n\n此时，帮我们写好这段封装代码的是apache软件基金会，我们前面学习的tomcat也是它提供的。它里面有一个开源工具包集合commons，里面有很多开源工具类，今天我们就来讲解第一个：<font color=\'red\'><b>commons-beanutils</b></font>。\n\n**第四种：使用apache的commons-beanutils实现封装**\n\n实现代码：\n\n```java\n/**\n * 终极方法：使用beanutils实现请求正文封装到javabean中\t\t\t\t使用了确认密码\n * 要想使用beanutils，需要先导包\n * @param request\n * @param response\n * @throws ServletException\n * @throws IOException\n */\nprivate void test8(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n    Users user = new Users();\n    System.out.println("封装前："+user.toString());\n    try{\n        BeanUtils.populate(user, request.getParameterMap());//就这一句话\n    }catch(Exception e){\n        e.printStackTrace();\n    }\n    System.out.println("封装后："+user.toString());\n}\n```\n\n### 2.3.4 用流的形式读取请求信息\n\n我们除了使用2.3.3小节中获取请求参数之外，还可以使用下面代码中的 方式来获取：\n\n```java\n/**\n * 使用流的方式读取请求正文\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class RequestDemo4 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        //1.获取请求正文的字节输入流\n        ServletInputStream sis = request.getInputStream();\n        //2.读取流中的数据\n        int len = 0;\n        byte[] by = new byte[1024];\n        while((len = sis.read(by)) != -1){\n            System.out.println(new String(by,0,len));\n        }\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n### 2.3.5请求正文中中文编码问题\n\n关于请求中文乱码问题，我们需要分开讨论，第一是POST请求方式，第二是GET方式。\n\n#### 1）POST方式请求\n\n在POST方式请求中，我们的乱码问题可以用如下代码解决：\n\n```java\n/**\n * 请求正文的中文乱码问题\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class RequestDemo5 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        //1.获取请求正文\n\t\t/*POST方式：\n\t\t * 问题：\n\t\t * \t取的时候会不会有乱码\n\t\t * 答案：\n\t\t * \t获取请求正文，会有乱码问题。\n\t\t * \t是在获取的时候就已经乱码了。\n\t\t * 解决办法：\n\t\t * \t 是request对象的编码出问题了\n\t\t *   设置request对象的字符集\n\t\t *   request.setCharacterEncoding("GBK");它只能解决POST的请求方式，GET方式解决不了\n\t\t * 结论：\n\t\t * \t 请求正文的字符集和响应正文的字符集没有关系。各是各的\n\t\t */\n\t\trequest.setCharacterEncoding("UTF-8");\n\t\tString username = request.getParameter("username");\n        //输出到控制台\n\t\tSystem.out.println(username);\n        //输出到浏览器：注意响应的乱码问题已经解决了\n        response.setContentType("text/html;charset=UTF-8");\n        PrintWriter out = response.getWriter();\n        out.write(username);\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n}\n```\n\n#### 2）GET方式请求\n\nGET方式请求的正文是在地址栏中，在Tomcat8.5版本及以后，Tomcat服务器已经帮我们解决了，所以不会有乱码问题了。\n\n而如果我们使用的不是Tomcat服务器，或者Tomcat的版本是8.5以前，那么GET方式仍然会有乱码问题，解决方式如下：（以下代码了解即可，因为我们现在使用的是Tomcat9.0.27版本）\n\n```java\n/**\n * 在Servlet的doGet方法中添加如下代码\n */\npublic void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n   \n\n        /*\n         * GET方式：正文在地址栏\n         * username=%D5%C5%C8%FD\n         * %D5%C5%C8%FD是已经被编过一次码了\n         *\n         * 解决办法：\n         * \t 使用正确的码表对已经编过码的数据进行解码。\n         * \t\t就是把取出的内容转成一个字节数组，但是要使用正确的码表。（ISO-8859-1）\n         * \t 再使用正确的码表进行编码\n         * \t\t把字节数组再转成一个字符串，需要使用正确的码表，是看浏览器当时用的是什么码表\n         */\n        String username = request.getParameter("username");\n        byte[] by = username.getBytes("ISO-8859-1");\n        username = new String(by,"GBK");\n\n        //输出到浏览器：注意响应的乱码问题已经解决了\n        response.setContentType("text/html;charset=UTF-8");\n        PrintWriter out = response.getWriter();\n        out.write(username);\n}\n\npublic void doPost(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n    doGet(request, response);\n}\n```\n\n### 2.3.6 请求转发（与重定向的区别）\n\n在实际开发中，重定向和请求转发都是我们要用到的响应方式，那么他们有什么区别呢？我们通过下面的示例来看一下：\n\n```java\n/**\n * 重定向特点：\n * \t两次请求，浏览器行为，地址栏改变，请求域中的数据会丢失\n * 请求转发：\n * \t一次请求，服务器行为，地址栏不变，请求域中的数据不丢失\n *\n * 请求域的作用范围：\n * \t 当前请求（一次请求）,和当前请求的转发之中\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class RequestDemo6 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        //1.拿到请求调度对象\n        RequestDispatcher rd = request.getRequestDispatcher("/RequestDemo7");//如果是给浏览器看的，/可写可不写。如果是给服务器看的，一般情况下，/都是必须的。\n        //放入数据到请求域中\n        request.setAttribute("CityCode", "bj-010");\n        //2.实现真正的转发操作\n        rd.forward(request, response);//实现真正的转发操作\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n```java\n/**\n * 转发的目的地\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class RequestDemo7 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        //获取请求域中的数据\n        String value = (String)request.getAttribute("CityCode");\n        response.getWriter().write("welcome to request demo 7    "+value);\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n### 2.3.7 请求包含\n\n在实际开发中，我们可能需要把两个Servlet的内容合并到一起来响应浏览器，而同学们都知道HTTP协议的特点是一请求，一响应的方式。所以绝对不可能出现有两个Servlet同时响应方式。那么我们就需要用到请求包含，把两个Servlet的响应内容合并输出。我们看具体使用示例：\n\n```java\n/**\n * 请求包含\n *\n * 它是把两个Servlet的响应内容合并输出。\n * 注意：\n * \t这种包含是动态包含。\n *\n * 动态包含的特点：\n * \t\t各编译各的，只是最后合并输出。\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class RequestDemo8 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.getWriter().write("I am request demo8 ");\n        //1.拿到请求调度对象\n        RequestDispatcher rd = request.getRequestDispatcher("/RequestDemo9");\n        //2.实现包含的操作\n        rd.include(request, response);\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n}\n```\n\n```java\n/**\n * 被包含者\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class RequestDemo9 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.getWriter().write("include request demo 9 ");\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n### 2.3.8 细节问题\n\n请求转发的注意事项：负责转发的Servlet，转发前后的响应正文丢失，由转发目的地来响应浏览器。\n\n请求包含的注意事项：被包含者的响应消息头丢失。因为它被包含起来了。\n\n# 3 案例中的使用\n\n## 3.1 案例的需求及环境\n\n### 3.1.1 案例需求介绍\n\n在昨天的课程中，我们实现了浏览器发送请求，由Servlet来接收。今天，我们继续对学生管理系统进行升级，通过Servlet来实现学生的新增，删除，修改，查询操作。\n\n新增：Create\n\n查询：Read\n\n修改：Update\n\n删除：Delete\n\n每个单词取第一个字母，组成了CRUD。所以，同学们今后看到CRUD操作，指的就是增删改查。\n\n今天案例的CRUD，我们只关注Servlet接收请求和处理响应，不用过多的去关注真正增删改查操作（因为，我们目前还是把学生信息写到文件中，等web5天课程结束，我们会讲解数据库，它是我们保存数据这类问题的终极解决方案，而保存文件只是个替代品，我们没必要在替代品处消耗太多精力）。\n\n',Ke={data:function(){return{MainComponent:Qe}}},$e=Ke,Xe=Object(d["a"])($e,ze,We,!1,null,"19d0f2b6",null),Ye=Xe.exports,Ze=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},nt=[],et='# Cookie&SessionJsp-授课\n\n# 1 会话技术\n\n## 1.1 会话管理概述\n\n### 1.1.1 什么是会话\n\n这里的会话，指的是web开发中的一次通话过程，当打开浏览器，访问网站地址后，会话开始，当关闭浏览器（或者到了过期时间），会话结束。\n\n举个例子：\n\n​\t例如，你在给家人打电话，这时突然有送快递的配送员敲门，你放下电话去开门，收完快递回来后，通话还在保持中，继续说话就行了。\n\n### 1.1.2 会话管理作用\n\n什么时候会用到会话管理呢？最常见的就是购物车，当我们登录成功后，把商品加入到购物车之中，此时我们无论再浏览什么商品，当点击购物车时，那些加入的商品都仍在购物车中。\n\n在我们的实际开发中，还有很多地方都离不开会话管理技术。比如，我们在论坛发帖，没有登录的游客身份是不允许发帖的。所以当我们登录成功后，无论我们进入哪个版块发帖，只要权限允许的情况下，服务器都会认识我们，从而让我们发帖，因为登录成功的信息一直保留在服务器端的会话中。\n\n通过上面的两个例子，我们可以看出，它是为我们共享数据用的，并且是在不同请求间实现数据共享。也就是说，如果我们需要在多次请求间实现数据共享，就可以考虑使用会话管理技术了。\n\n### 1.1.3 会话管理分类\n\n在JavaEE的项目中，会话管理分为两类。分别是：客户端会话管理技术和服务端会话管理技术。\n\n**客户端会话管理技术**\n\n​\t\t它是把要共享的数据保存到了客户端（也就是浏览器端）。每次请求时，把会话信息带到服务器，从而实现多次请求的数据共享。\n\n**服务端会话管理技术**\n\n​\t\t它本质仍是采用客户端会话管理技术，只不过保存到客户端的是一个特殊的标识，并且把要共享的数据保存到了服务端的内存对象中。每次请求时，把这个标识带到服务器端，然后使用这个标识，找到对应的内存空间，从而实现数据共享。\n\n## 1.2 客户端会话管理技术\n\n### 1.2.1 Cookie概述\n\n#### 1）什么是Cookie\n\n它是客户端浏览器的缓存文件，里面记录了客户浏览器访问网站的一些内容。同时，也是HTTP协议请求和响应消息头的一部分（在HTTP协议课程中，我们备注了它很重要）。\n\n#### 2）Cookie的API详解\n\n**作用**\n\n它可以保存客户浏览器访问网站的相关内容（需要客户端不禁用Cookie）。从而在每次访问需要同一个内容时，先从本地缓存获取，使资源共享，提高效率。\n\n**Cookie的属性**\n\n| 属性名称 | 属性作用                 | 是否重要 |\n| -------- | ------------------------ | -------- |\n| name     | cookie的名称             | 必要属性 |\n| value    | cookie的值（不能是中文） | 必要属性 |\n| path     | cookie的路径             | 重要     |\n| domain   | cookie的域名             | 重要     |\n| maxAge   | cookie的生存时间。       | 重要     |\n| version  | cookie的版本号。         | 不重要   |\n| comment  | cookie的说明。           | 不重要   |\n\n**细节**\n\nCookie有大小，个数限制。每个网站最多只能存20个cookie，且大小不能超过4kb。同时，所有网站的cookie总数不超过300个。\n\n当删除Cookie时，设置maxAge值为0。当不设置maxAge时，使用的是浏览器的内存，当关闭浏览器之后，cookie将丢失。设置了此值，就会保存成缓存文件（值必须是大于0的,以秒为单位）。\n\n#### 3）Cookie涉及的常用方法\n\n**创建Cookie**\n\n![Cookie的方法](./img/java/javaweb/Cookie&SessionJsp-授课.assets/Cookie的方法.png)\n\n```java\n/**\n * 通过指定的名称和值构造一个Cookie\n *\n * Cookie的名称必须遵循RFC 2109规范。这就意味着，它只能包含ASCII字母数字字符，\n * 不能包含逗号、分号或空格或以$字符开头。\n * 创建后无法更改cookie的名称。\n *\n * 该值可以是服务器选择发送的任何内容。\n * 它的价值可能只有服务器才感兴趣。\n * 创建之后，可以使用setValue方法更改cookie的值。\n */\npublic Cookie(String name, String value) {\n\tvalidation.validate(name);\n\tthis.name = name;\n\tthis.value = value;\n}\n```\n\n**向浏览器添加Cookie**\n\n![添加Cookie的方法](./img/java/javaweb/Cookie&SessionJsp-授课.assets/添加Cookie的方法.png)\n\n```java\n/**\n * 添加Cookie到响应中。此方法可以多次调用，用以添加多个Cookie。\n */\npublic void addCookie(Cookie cookie);\n```\n\n**从服务器端获取Cookie**\n\n![获取Cookie的方法](./img/java/javaweb/Cookie&SessionJsp-授课.assets/获取Cookie的方法.png)\n\n```java\n/**\n * 这是HttpServletRequest中的方法。\n * 它返回一个Cookie的数组，包含客户端随此请求发送的所有Cookie对象。\n * 如果没有符合规则的cookie，则此方法返回null。\n */\n public Cookie[] getCookies();\n```\n\n### 1.2.2 Cookie的Path细节：浏览器什么时候带给服务器，什么时候不带\n\n#### 1）需求说明\n\n创建一个Cookie，设置Cookie的path，通过不同的路径访问，从而查看请求携带Cookie的情况。\n\n#### 2）案例目的\n\n通过此案例的讲解，同学们可以清晰的描述出，客户浏览器何时带cookie到服务器端，何时不带。\n\n#### 3）案例步骤\n\n**第一步：创建JavaWeb工程**\n\n沿用第一个案例中的工程即可。\n\n**第二步：编写Servlet**\n\n```JAVA\n/**\n * Cookie的路径问题\n * 前期准备：\n * \t1.在demo1中写一个cookie到客户端\n *  2.在demo2和demo3中分别去获取cookie\n *  \tdemo1的Servlet映射是   /servlet/PathQuestionDemo1\n *  \tdemo2的Servlet映射是   /servlet/PathQuestionDemo2\n *  \tdemo3的Servlet映射是   /PathQuestionDemo3\n *\n * @author 黑马程序员\n * @Company http://www.itheima.com\n *\n */\npublic class PathQuestionDemo1 extends HttpServlet {\n\n\tpublic void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\t//1.创建一个Cookie\n\t\tCookie cookie = new Cookie("pathquestion","CookiePathQuestion");\n\t\t//2.设置cookie的最大存活时间\n\t\tcookie.setMaxAge(Integer.MAX_VALUE);\n\t\t//3.把cookie发送到客户端\n\t\tresponse.addCookie(cookie);//setHeader("Set-Cookie","cookie的值")\n\t}\n\n\tpublic void doPost(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\tdoGet(request, response);\n\t}\n}\n\n```\n\n```java\n/**\n * 获取Cookie，名称是pathquestion\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class PathQuestionDemo2 extends HttpServlet {\n\n\tpublic void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\t//1.获取所有的cookie\n\t\tCookie[] cs = request.getCookies();\n\t\t//2.遍历cookie的数组\n\t\tfor(int i=0;cs!=null && i<cs.length;i++){\n\t\t\tif("pathquestion".equals(cs[i].getName())){\n\t\t\t\t//找到了我们想要的cookie，输出cookie的值\n\t\t\t\tresponse.getWriter().write(cs[i].getValue());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void doPost(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\tdoGet(request, response);\n\t}\n}\n```\n\n```java\n/**\n * 获取Cookie，名称是pathquestion\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class PathQuestionDemo3 extends HttpServlet {\n\n\tpublic void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\t//1.获取所有的cookie\n\t\tCookie[] cs = request.getCookies();\n\t\t//2.遍历cookie的数组\n\t\tfor(int i=0;cs!=null && i<cs.length;i++){\n\t\t\tif("pathquestion".equals(cs[i].getName())){\n\t\t\t\t//找到了我们想要的cookie，输出cookie的值\n\t\t\t\tresponse.getWriter().write(cs[i].getValue());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void doPost(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\tdoGet(request, response);\n\t}\n}\n```\n\n**第三步：配置Servlet**\n\n```xml\n\x3c!--配置Cookie路径问题案例的Servlet--\x3e\n<servlet>\n    <servlet-name>PathQuestionDemo1</servlet-name>\n    <servlet-class>com.itheima.web.servlet.pathquestion.PathQuestionDemo1</servlet-class>\n</servlet>\n<servlet-mapping>\n    <servlet-name>PathQuestionDemo1</servlet-name>\n    <url-pattern>/servlet/PathQuestionDemo1</url-pattern>\n</servlet-mapping>\n\n<servlet>\n    <servlet-name>PathQuestionDemo2</servlet-name>\n    <servlet-class>com.itheima.web.servlet.pathquestion.PathQuestionDemo2</servlet-class>\n</servlet>\n<servlet-mapping>\n    <servlet-name>PathQuestionDemo2</servlet-name>\n    <url-pattern>/servlet/PathQuestionDemo2</url-pattern>\n</servlet-mapping>\n\n<servlet>\n    <servlet-name>PathQuestionDemo3</servlet-name>\n    <servlet-class>com.itheima.web.servlet.pathquestion.PathQuestionDemo3</servlet-class>\n</servlet>\n<servlet-mapping>\n    <servlet-name>PathQuestionDemo3</servlet-name>\n    <url-pattern>/PathQuestionDemo3</url-pattern>\n</servlet-mapping>\n```\n\n**第四步：部署工程**\n\n沿用第一个案例中的工程部署即可。\n\n#### 4）测试结果\n\n通过分别运行PathQuestionDemo1，2和3这3个Servlet，我们发现由demo1写Cookie，在demo2中可以取到，但是到了demo3中就无法获取了，如下图所示：\n\n![案例2-1](./img/java/javaweb/Cookie&SessionJsp-授课.assets/案例2-1.png)\n\n![案例2-2](./img/java/javaweb/Cookie&SessionJsp-授课.assets/案例2-2.png)\n\n![案例2-3](./img/java/javaweb/Cookie&SessionJsp-授课.assets/案例2-3.png)\n\n#### 5）路径问题的分析及总结\n\n**问题：**\n \t demo2和demo3谁能取到cookie？\n **答案：**\n \t demo2能取到，demo3取不到\n**分析：**\n \t 首先，我们要知道如何确定一个cookie？\n \t 那就是使用cookie的三个属性组合：<font color=\'red\'><b>domain+path+name</b></font>\n \t 这里面，同一个应用的domain是一样的，在我们的案例中都是localhost。\n​      并且，我们取的都是同一个cookie，所以name也是一样的，都是pathquestion。\n​      那么，不一样的只能是path了。但是我们没有设置过cookie的path属性，这就表明path是有默认值的。\n \t 接下来，我们打开这个cookie来看一看，在ie浏览器访问一次PathQuestionDemo1这个Servlet：\n\nCookie中的内容：\n \t\t ![Cookie文件介绍](./img/java/javaweb/Cookie&SessionJsp-授课.assets/Cookie文件介绍.png)\n 我们是通过demo1写的cookie，demo1的访问路径是： http://localhost:9090/servlet/PathQuestionDemo1\n 通过比较两个路径：请求资源地址和cookie的path，可以看出：cookie的path默认值是：请求资源URI，没有资源的部分（在我们的案例中，就是没有PathQuestionDemo1）。\n\n**客户端什么时候带cookie到服务器，什么时候不带？**\n​\t就是看请求资源URI和cookie的path比较。\n\n​\t<font color=\'red\'>请求资源URI.startWith(cookie的path) </font> 如果返回的是true就带，如果返回的是false就不带。\n\n​\t简单的说： 就是看谁的地址更精细\n\n​\t比如：Cookie的path：       /国家\t\t\t/省份\t\t\t/城市\n\n \t\t \t 请求资源URI\t:   \t  /国家\t\t\t/省份\t\t\t\t\t\t\t\t\t\t\t\t\t\t  不带\n \t\t \t 请求资源URI   ：\t   /国家\t\t\t/省份\t\t\t/城市\t\t\t/区县\t\t\t\t带\n\n![案例2-4](./img/java/javaweb/Cookie&SessionJsp-授课.assets/案例2-4.png)\n\n在我们的案例中：\n\n| 访问URL                                                      | URI部分                    | Cookie的Path | 是否携带Cookie | 能否取到Cookie |\n| ------------------------------------------------------------ | -------------------------- | ------------ | -------------- | -------------- |\n| [PathQuestionDemo2](http://localhost:9090/servlet/PathQuestionDemo2) | /servlet/PathQuestionDemo2 | /servlet/    | 带             | 能取到         |\n| [PathQuestionDemo3](http://localhost:9090/PathQuestionDemo3) | /PathQuestionDemo3         | /servlet/    | 不带           | 不能取到       |\n\n## 1.3 服务端会话管理概述\n\n### 1.3.1 HttpSession概述\n\n#### 1）HttpSession对象介绍\n\n它是Servlet规范中提供的一个接口。该接口的实现由Servlet规范的实现提供商提供。我们使用的是Tomcat服务器，它对Servlet规范进行了实现，所以HttpSession接口的实现由Tomcat提供。该对象用于提供一种通过多个页面请求或访问网站来标识用户并存储有关该用户的信息的方法。简单说它就是一个服务端会话对象，用于存储用户的会话数据。\n\n同时，它也是Servlet规范中四大域对象之一的会话域对象。并且它也是用于实现数据共享的。但它与我们之前讲解的应用域和请求域是有区别的。\n\n| 域对象         | 作用范围     | 使用场景                                                     |\n| -------------- | ------------ | ------------------------------------------------------------ |\n| ServletContext | 整个应用范围 | 当前项目中需要数据共享时，可以使用此域对象。                 |\n| ServletRequest | 当前请求范围 | 在请求或者当前请求转发时需要数据共享可以使用此域对象。       |\n| HttpSession    | 会话返回     | 在当前会话范围中实现数据共享。它可以在多次请求中实现数据共享。 |\n\n#### 2）HttpSession的获取\n\n获取HttpSession是通过HttpServletRequest接口中的两个方法获取的，如下图所示：\n\n![获取HttpSession的两个方法](./img/java/javaweb/Cookie&SessionJsp-授课.assets/获取HttpSession的两个方法.png)\n\n这两个方法的区别：\n\n![获取Session的两个方法](./img/java/javaweb/Cookie&SessionJsp-授课.assets/获取Session的两个方法.png)\n\n#### 3）HttpSession的常用方法\n\n![HttpSession方法介绍](./img/java/javaweb/Cookie&SessionJsp-授课.assets/HttpSession方法介绍.png)\n\n### 1.3.2 HttpSession的入门案例\n\n#### 1）需求说明\n\n在请求HttpSessionDemo1这个Servlet时，携带用户名信息，并且把信息保存到会话域中，然后从HttpSessionDemo2这个Servlet中获取登录信息。\n\n#### 2）案例目的\n\n通过本案例的讲解，同学们可以清楚的认识到会话域的作用，即多次请求间的数据共享。因为是两次请求，请求域肯定不一样了，所以不能用请求域实现。\n\n最终掌握HttpSession对象的获取和使用。\n\n#### 3）原理分析\n\nHttpSession，它虽然是服务端会话管理技术的对象，但它本质仍是一个Cookie。是一个由服务器自动创建的特殊的Cookie，Cookie的名称就是JSESSIONID，Cookie的值是服务器分配的一个唯一的标识。\n\n当我们使用HttpSession时，浏览器在没有禁用Cookie的情况下，都会把这个Cookie带到服务器端，然后根据唯一标识去查找对应的HttpSession对象，找到了，我们就可以直接使用了。下图就是我们入门案例中，HttpSession分配的唯一标识，同学们可以看到两次请求的JSESSIONID的值是一样的：\n\n![案例3-5](./img/java/javaweb/Cookie&SessionJsp-授课.assets/案例3-5.png)\n\n### 1.3.3 HttpSession的钝化和活化\n\n**什么是持久态**\n\n​\t\t把长时间不用，但还不到过期时间的HttpSession进行序列化，写到磁盘上。\n\n​\t\t我们把HttpSession持久态也叫做钝化。（与钝化相反的，我们叫活化。）\n\n**什么时候使用持久化**\n\n​\t\t第一种情况：当访问量很大时，服务器会根据getLastAccessTime来进行排序，对长时间不用，但是还没到过期时间的HttpSession进行持久化。\n\n​\t\t第二种情况：当服务器进行重启的时候，为了保持客户HttpSession中的数据，也要对HttpSession进行持久化\n\n**注意**\n\n​\t\tHttpSession的持久化由服务器来负责管理，我们不用关心。\n\n​\t\t只有实现了序列化接口的类才能被序列化，否则不行。\n\n# 2 页面技术\n\n## 2.1 JSP基础\n\n### 2.1.1 JSP简介\n\nJSP全称是Java Server Page，它和Servlet一样，也是sun公司推出的一套开发动态web资源的技术，称为JSP/Servlet规范。JSP的本质其实就是一个Servlet。\n\n### 2.1.2 JSP和HTML以及Servlet的适用场景\n\n| 类别    | 适用场景                                                     |\n| ------- | ------------------------------------------------------------ |\n| HTML    | 只能开发静态资源，不能包含java代码，无法添加动态数据。       |\n| Servlet | 写java代码，可以输出页面内容，但是很不方便，开发效率极低。   |\n| JSP     | 它包括了HTML的展示技术，同时具备Servlet输出动态资源的能力。但是不适合作为控制器来用。 |\n\n### 2.1.3 JSP简单入门\n\n**创建JavaWeb工程**\n\n![案例jsp1](./img/java/javaweb/Cookie&SessionJsp-授课.assets/案例jsp1.png)\n\n**在index.jsp中填写内容**\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n  <head>\n    <title>JSP的入门</title>\n  </head>\n  <body>\n      这是第一个JSP页面\n  </body>\n</html>\n```\n\n**部署项目**\n\n沿用会话管理工程的部署方式即可。\n\n**测试运行**\n\n![案例jsp2](./img/java/javaweb/Cookie&SessionJsp-授课.assets/案例jsp2.png)\n\n### 2.1.4 JSP说明\n\n写在之前： 明确JSP就是一个Servlet。是一个特殊的Servlet。\n\nJSP的原理：\n\n​           客户端提交请求\n\n​\t\t\t\t——Tomcat服务器解析请求地址\n\n​\t\t\t\t\t\t——找到JSP页面\n\n​\t\t\t\t\t\t\t\t——Tomcat将JSP页面翻译成Servlet的java文件\n\n​\t\t\t\t\t\t\t\t\t\t——将翻译好的.java文件编译成.class文件\n\n​\t\t\t\t\t\t\t\t\t\t\t\t——返回到客户浏览器上。\n\n#### 1）执行过程分析图\n\n![Tomcat执行过程](./img/java/javaweb/Cookie&SessionJsp-授课.assets/Tomcat执行过程.png)\n\n#### 2）JSP的.java文件内容分析\n\n当我们打开index.jsp翻译的java文件看到的就是`public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase`类的声明，然后我们在Tomcat的源码中找到类的声明，如下图：\n\n![Tomcat中的HttpJspBase类声明](./img/java/javaweb/Cookie&SessionJsp-授课.assets/Tomcat中的HttpJspBase类声明.png)\n\n这张图一出场，就表明我们写的JSP它本质就是一个HttpServlet了。\n\n![jsp的本质说明](./img/java/javaweb/Cookie&SessionJsp-授课.assets/jsp的本质说明.png)\n\n同时，我们在index_jsp.java文件中找到了输出页面的代码，并且在浏览器端查看源文件，看到的内容是一样的。这也就是说明，我们的浏览器上的内容，在通过jsp展示时，本质都是用out.write()输出出来的。\n\n讲到这里，我们应该清楚的认识到，JSP它是一个特殊的Servlet，主要是用于展示动态数据。它展示的方式是用流把数据输出出来，而我们在使用JSP时，涉及HTML的部分，都与HTML的用法一致，这部分称为jsp中的模板元素，在开发过程中，先写好这些模板元素，因为它们决定了页面的外观。\n\n## 2.2 JSP应用\n\n### 2.2.1 JSP语法\n\n#### 1）Java代码块\n\n在jsp中，可以使用java脚本代码。形式为：<font color=\'red\'><b><% 此处写java代码 %></b></font>\n\n但是，在实际开发中，极少使用此种形式编写java代码。同时需要注意的是：\n\n```jsp\n<%\n\t在里面写java程序脚本需要注意：这里面的内容由tomcat负责翻译，翻译之后是service方法的成员变量\n%>\n```\n\n**示例：**\n\n```jsp\n\x3c!--Java代码块--\x3e\n<% out.println("这是Java代码块");%>\n<hr/>\n```\n\n#### 2）JSP表达式\n\n在jsp中，可以使用特定表达式语法，形式为：<font color=\'red\'><b><%=表达式%></b></font>\n\njsp在翻译完后是out.print(表达式内容);\n\n所以：<%out.print("当前时间);%>和<%="当前时间"%>是一样的。\n\n在实际开发中，这种表达式语法用的也很少使用。\n\n**示例：**\n\n```jsp\n\x3c!--JSP表达式--\x3e\n<%="这是JSP表达式"%><br/>\n就相当于<br/>\n<%out.println("这是没有JSP表达式输出的");%>\n```\n\n#### 3）JSP声明\n\n在JSP中也可以声明一些变量，方法，静态方法，形式为：<font color=\'red\'><b><%! 声明的内容 %></b></font>\n\n使用JSP声明需要注意：\n\n```jsp\n<%! \n\t需要注意的是： 写在里面的内容将会被tomcat翻译成全局的属性或者类方法。\n%>                                    \n```\n\n**示例：**\n\n```jsp\n\x3c!--JSP声明--\x3e\n<%! String str = "声明语法格式";%>\n<%=str%>\n```\n\n#### 4）JSP注释\n\n在使用JSP时，它有自己的注释，形式为：<font color=\'red\'><b><%--注释--%></b></font>\n\n需要注意的是：\n\n​      在Jsp中可以使用html的注释，但是只能注释html元素，不能注释java程序片段和表达式。同时，被html注释部分会参与翻译，并且会在浏览器上显示\n\n​      jsp的注释不仅可以注释java程序片段，也可以注释html元素，并且被jsp注释的部分不会参与翻译成.java文件，也不会在浏览器上显示。\n\n**示例：**\n\n```jsp\n<%--JSP注释--%>\n\x3c!--HTML注释--\x3e\n```\n\n#### 5）语法的示例\n\n**JSP语法完整示例代码**\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>JSP语法</title>\n</head>\n<body>\n\n\x3c!--Java代码块--\x3e\n<% out.println("这是Java代码块");%>\n<hr/>\n\n\x3c!--JSP表达式--\x3e\n<%="这是JSP表达式"%><br/>\n就相当于<br/>\n<%out.println("这是没有JSP表达式输出的");%>\n\n<hr/>\n\x3c!--JSP声明--\x3e\n<%! String str = "声明语法格式";%>\n<%=str%>\n\n<hr/>\n\n<%--JSP注释--%>\n\x3c!--HTML注释--\x3e\n\n</body>\n</html>\n```\n\n**JSP语法运行结果**\n\n![案例jsp3](./img/java/javaweb/Cookie&SessionJsp-授课.assets/案例jsp3.png)\n\n### 2.2.2 JSP指令\n\n#### 1）page指令\n\n**language:**告知引擎，脚本使用的是java，默认是java，支持java。不写也行。\n\n**extends**：告知引擎，JSP对应的Servlet的父类是哪个，不需要写，也不需要改。\n\n**import**：告知引擎，导入哪些包（类）。\n\n​                **注意：引擎会自动导入：java.lang.\\*,javax.servlet.\\*,javax.servlet.http.\\*,javax.servlet.jsp.\\***\n\n​                    **导入的形式：** \n\n​                         **<%@page import=”java.util.Date,java.util.UUID”%>或者：**\n\n​                         **<%@page import=”java.util.Date”%>**\n\n​                         **<%@page import=”java.util.UUID”%>**  **用Eclipse：Alt+/ 自动导入**\n\n**session**：告知引擎是否产生HttpSession对象，即是否在代码中调用request.getSession()。默认是true。\n\n**buffer**：JspWriter用于输出JSP内容到页面上。告知引擎，设定他的缓存大小。默认8kb。\n\n**errorPage**：告知引擎，当前页面出现异常后，应该转发到哪个页面上（路径写法：/代表当前应用）\n\n​                \t**小贴士：当在errorpage上使用了isErrorPage=true之后，ie8有时候不能正常显示**\n\n​            \t\t **配置全局错误页面：web.xml**\n\n\n\n```xml\n<error-page>    \n    <exception-type>java.lang.Exception</exception-type>    \t\t\t\n    <location>/error.jsp</location>\n</error-page>\n<error-page>\n    <error-code>404</error-code>\n    <location>/404.html</location>\n</error-page>                                 \n```\n\n​           \t\t **当使用了全局错误页面，就无须再写errorPage来实现转到错误页面，而是由服务器负责跳转到错误页面。**\n\n**isErrorPage**：告知引擎，是否抓住异常。如果该属性为true，页面中就可以使用exception对象，打印异常的详细信息。默认值是false。\n\n**contentType**：告知引擎，响应正文的MIME类型。contentType="text/html;charset=UTF-8"\n\n​               \t\t\t相当于response.setContentType("text/html;charset=UTF-8");\n\n**pageEncoding**：告知引擎，翻译jsp时（从磁盘上读取jsp文件）所用的码表。pageEncoding="UTF-8"相当于告知引擎用UTF-8读取JSP\n\n**isELIgnored***：告知引擎，是否忽略EL表达式，默认值是false，不忽略。\n\n#### 2）include指令\n\n语法格式：<%@include file="" %>该指令是包含外部页面。 \n\n属性：file，以/开头，就代表当前应用。\n\n**使用示例**\n\n![静态包含1](./img/java/javaweb/Cookie&SessionJsp-授课.assets/静态包含1.png)\n\n**静态包含的特点**\n\n![静态包含2](./img/java/javaweb/Cookie&SessionJsp-授课.assets/静态包含2.png)\n\n#### 3）taglib指令\n\n语法格式：<%taglib uri="" prefix=""%>\n\n作用：该指令用于引入外部标签库。html标签和jsp标签不用引入。\n\n属性：                                                                                   \n\n​       uri：外部标签的URI地址。\n\n​       prefix：使用标签时的前缀。\n\n### 2.2.3 JSP细节\n\n#### 1）九大隐式对象\n\n什么是隐式对象呢？它指的是在jsp中，可以不声明就直接使用的对象。它只存在于jsp中，因为java类中的变量必须要先声明再使用。其实jsp中的隐式对象也并非是未声明，只是它是在翻译成.java文件时声明的。所以我们在jsp中可以直接使用。\n\n| 隐式对象名称 | 类型                                   | 备注                          |\n| ------------ | -------------------------------------- | ----------------------------- |\n| request      | javax.servlet.http.HttpServletRequest  |                               |\n| response     | javax.servlet.http.HttpServletResponse |                               |\n| session      | javax.servlet.http.HttpSession         | Page指令可以控制开关          |\n| application  | javax.servlet.ServletContext           |                               |\n| page         | Java.lang.Object                       | 当前jsp对应的servlet引用实例  |\n| config       | javax.servlet.ServletConfig            |                               |\n| exception    | java.lang.Throwable                    | page指令有开关                |\n| out          | javax.servlet.jsp.JspWriter            | 字符输出流，相当于printwriter |\n| pageContext  | javax.servlet.jsp.PageContext          | 很重要                        |\n\n#### 2）PageContext对象\n\n**简介**\n\n它是JSP独有的对象，Servlet中没有这个对象。本身也是一个域（作用范围）对象，但是它可以操作其他3个域对象中的属性。而且还可以获取其他8个隐式对象。\n\n**生命周期**\n\n它是一个局部变量，所以它的生命周期随着JSP的创建而诞生，随着JSP的结束而消失。每个JSP页面都有一个独立的PageContext。\n\n**常用方法**\n\n![PageContext方法详解](./img/java/javaweb/Cookie&SessionJsp-授课.assets/PageContext方法详解.png)\n\n在上图中，同学们发现没有页面域操作的方法，其实是定义在了PageContext的父类JspContext中，如下图所示：\n\n![JspContext](./img/java/javaweb/Cookie&SessionJsp-授课.assets/JspContext.png)\n\n#### 3）四大域对象\n\n| 域对象名称     | 范围     | 级别                     | 备注                                     |\n| -------------- | -------- | ------------------------ | ---------------------------------------- |\n| PageContext    | 页面范围 | 最小，只能在当前页面用   | 因范围太小，开发中用的很少               |\n| ServletRequest | 请求范围 | 一次请求或当期请求转发用 | 当请求转发之后，再次转发时请求域丢失     |\n| HttpSession    | 会话范围 | 多次请求数据共享时使用   | 多次请求共享数据，但不同的客户端不能共享 |\n| ServletContext | 应用范围 | 最大，整个应用都可以使用 | 尽量少用，如果对数据有修改需要做同步处理 |\n\n### 2.2.4 JSP最佳实战-MVC模型\n\n**Servlet：**擅长处理业务逻辑，不擅长输出显示界面。在web开发中多用于控制程序逻辑（流程）。所以我们称之为：控制器。\n\n**JSP：**擅长显示界面，不擅长处理程序逻辑。在web开发中多用于展示动态界面。所以我们称之为：视图。\n\n例如:               ![1577355748295](./img/java/javaweb/Cookie&SessionJsp-授课.assets/1577355748295.png)                                                                      \n\nM：model      ，通常用于封装数据，封装的是数据模型。\n\nV：view\t       ，通常用于展示数据。动态展示用jsp页面，静态数据展示用html。\n\nC：controller ，通常用于处理请求和响应。一般指的是Servlet。\n\n# 3 综合案例-学生管理系统升级\n\n## 3.1 登录功能实现\n\n### 3.1.1 创建一个web项目，在 web 目录下创建一个 index.jsp。\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>学生管理系统首页</title>\n</head>\n<body>\n    <%--\n        获取会话域中的数据\n        如果获取到了则显示添加和查看功能的超链接\n        如果没获取到则显示登录功能的超链接\n    --%>\n    <% Object username = session.getAttribute("username");\n        if(username == null) {\n    %>\n        <a href="/stu/login.jsp">请登录</a>\n    <%} else {%>\n        <a href="/stu/addStudent.jsp">添加学生</a>\n        <a href="/stu/listStudentServlet">查看学生</a>\n    <%}%>\n</body>\n</html>\n```\n\n\n\n### 3.1.2 在 web 目录下创建一个 login.jsp。实现登录页面\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>学生登录</title>\n</head>\n<body>\n    <form action="/stu/loginStudentServlet" method="get" autocomplete="off">\n        姓名：<input type="text" name="username"> <br>\n        密码：<input type="password" name="password"> <br>\n        <button type="submit">登录</button>\n    </form>\n</body>\n</html>\n\n```\n\n\n\n### 3.1.3 创建 LoginStudentServlet，获取用户名和密码\n\n```java\npackage com.itheima.servlet;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/*\n    学生登录\n */\n@WebServlet("/loginStudentServlet")\npublic class LoginStudentServlet extends HttpServlet{\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //1.获取用户名和密码\n        String username = req.getParameter("username");\n        String password = req.getParameter("password");\n\n        //2.判断用户名\n        if(username == null || "".equals(username)) {\n            //2.1用户名为空 重定向到登录页面\n            resp.sendRedirect("/stu/login.jsp");\n            return;\n        }\n\n        //2.2用户名不为空 将用户名存入会话域中\n        req.getSession().setAttribute("username",username);\n\n        //3.重定向到首页index.jsp\n        resp.sendRedirect("/stu/index.jsp");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n\n```\n\n\n\n##  3.2添加功能实现\n\n### 3.2.1 在 web 目录下创建一个 addStudent.jsp，实现添加学生的表单项\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>添加学生</title>\n</head>\n<body>\n<form action="/stu/addStudentServlet" method="get" autocomplete="off">\n    学生姓名：<input type="text" name="username"> <br>\n    学生年龄：<input type="number" name="age"> <br>\n    学生成绩：<input type="number" name="score"> <br>\n    <button type="submit">保存</button>\n</form>\n</body>\n</html>\n\n```\n\n### 3.2.2 创建 AddStudentServlet，获取学生信息并保存到文件中\n\n```java\npackage com.itheima.servlet;\n\nimport com.itheima.bean.Student;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/*\n    实现添加功能\n */\n@WebServlet("/addStudentServlet")\npublic class AddStudentServlet extends HttpServlet{\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //1.获取表单中的数据\n        String username = req.getParameter("username");\n        String age = req.getParameter("age");\n        String score = req.getParameter("score");\n\n        //2.创建学生对象并赋值\n        Student stu = new Student();\n        stu.setUsername(username);\n        stu.setAge(Integer.parseInt(age));\n        stu.setScore(Integer.parseInt(score));\n\n        //3.将学生对象的数据保存到d:\\\\stu.txt文件中\n        BufferedWriter bw = new BufferedWriter(new FileWriter("d:\\\\stu.txt",true));\n        bw.write(stu.getUsername() + "," + stu.getAge() + "," + stu.getScore());\n        bw.newLine();\n        bw.close();\n\n        //4.通过定时刷新功能响应给浏览器\n        resp.setContentType("text/html;charset=UTF-8");\n        resp.getWriter().write("添加成功。2秒后自动跳转到首页...");\n        resp.setHeader("Refresh","2;URL=/stu/index.jsp");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n\n```\n\n## 3.3 查看学生功能\n\n### 3.3.1 创建 ListStudentServlet，读取文件中的学生信息到集合中\n\n```\n1、将集合添加到会话域中\n\n2、重定向到 listStudent.jsp 页面上\n```\n\n\n\n```java\npackage com.itheima.servlet;\n\nimport com.itheima.bean.Student;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.ArrayList;\n\n/*\n    实现查看功能\n */\n@WebServlet("/listStudentServlet")\npublic class ListStudentServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //1.创建字符输入流对象，关联读取的文件\n        BufferedReader br = new BufferedReader(new FileReader("d:\\\\stu.txt"));\n\n        //2.创建集合对象，用于保存Student对象\n        ArrayList<Student> list = new ArrayList<>();\n\n        //3.循环读取文件中的数据，将数据封装到Student对象中。再把多个学生对象添加到集合中\n        String line;\n        while((line = br.readLine()) != null) {\n            //张三,23,95\n            Student stu = new Student();\n            String[] arr = line.split(",");\n            stu.setUsername(arr[0]);\n            stu.setAge(Integer.parseInt(arr[1]));\n            stu.setScore(Integer.parseInt(arr[2]));\n            list.add(stu);\n        }\n\n        //4.将集合对象存入会话域中\n        req.getSession().setAttribute("students",list);\n\n        //5.重定向到学生列表页面\n        resp.sendRedirect("/stu/listStudent.jsp");\n\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n\n```\n\n### 3.3.2 在 web 目录下创建一个 listStudent.jsp\n\n```jsp\n<%@ page import="com.itheima.bean.Student" %>\n<%@ page import="java.util.ArrayList" %>\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>查看学生</title>\n</head>\n<body>\n    <table width="600px" border="1px">\n        <tr>\n            <th>学生姓名</th>\n            <th>学生年龄</th>\n            <th>学生成绩</th>\n        </tr>\n        <% ArrayList<Student> students = (ArrayList<Student>) session.getAttribute("students");\n            for(Student stu : students) {\n        %>\n            <tr align="center">\n                <td><%=stu.getUsername()%></td>\n                <td><%=stu.getAge()%></td>\n                <td><%=stu.getScore()%></td>\n            </tr>\n        <%}%>\n    </table>\n</body>\n</html>\n\n```\n\n',tt={data:function(){return{MainComponent:et}}},rt=tt,at=Object(d["a"])(rt,Ze,nt,!1,null,"6b004ea5",null),it=at.exports,st=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},ot=[],lt='EL&Filter&Listener-授课\n\n# 1 EL表达式和JSTL\n\n## 1.1 EL表达式\n\n### 1.1.1 EL表达式概述\n\n**基本概念**\n\nEL表达式，全称是Expression Language。意为表达式语言。它是Servlet规范中的一部分，是JSP2.0规范加入的内容。其作用是用于在JSP页面中获取数据，从而让我们的JSP脱离java代码块和JSP表达式。\n\n**基本语法**\n\nEL表达式的语法格式非常简单，写为 <b><font color=\'red\' size=\'5\'>${表达式内容}</font></b>\n\n例如：在浏览器中输出请求域中名称为message的内容。\n\n假定，我们在请求域中存入了一个名称为message的数据（`request.setAttribute("message","EL");`），此时在jsp中获取的方式，如下表显示：\n\n| Java代码块                                                   | JSP表达式                              | EL表达式                              |\n| :----------------------------------------------------------- | :------------------------------------- | :------------------------------------ |\n| `<%<br/> <br/> String message = (String)request.getAttribute("message");<br/> out.write(message);<br/>%>` | `<%=request.getAttribute("message")%>` | <font color=\'red\'>`${message}`</font> |\n\n通过上面我们可以看出，都可以从请求域中获取数据，但是EL表达式写起来是最简单的方式。这也是以后我们在实际开发中，当使用JSP作为视图时，绝大多数都会采用的方式。\n\n### 1.1.2 EL表达式的入门案例\n\n#### 第一步：创建JavaWeb工程\n\n![入门案例1](./img/java/javaweb/EL&Filter&Listener-授课.assets/入门案例1.png)\n\n#### 第二步：创建jsp页面\n\n![入门案例2](./img/java/javaweb/EL&Filter&Listener-授课.assets/入门案例2.png)\n\n#### 第三步：在JSP页面中编写代码\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n  <head>\n    <title>EL表达式入门案例</title>\n  </head>\n  <body>\n    <%--使用java代码在请求域中存入一个名称为message的数据--%>\n    <% request.setAttribute("message","Expression Language");%>\n\n    Java代码块获取：<% out.print(request.getAttribute("message"));%>\n    <br/>\n    JSP表达式获取：<%=request.getAttribute("message")%>\n    <br/>\n    EL表达式获取：${message}\n  </body>\n</html>\n```\n\n#### 第四步：部署工程\n\n![入门案例3](./img/java/javaweb/EL&Filter&Listener-授课.assets/入门案例3.png)\n\n#### 第五步：运行测试\n\n![入门案例4](./img/java/javaweb/EL&Filter&Listener-授课.assets/入门案例4.png)\n\n### 1.1.2 EL表达式基本用法\n\n在前面的概述介绍中，我们介绍了EL表达式的作用，它就是用于获取数据的，那么它是从哪获取数据呢？\n\n#### 1）获取四大域中的数据\n\n它只能从四大域中获取数据，调用的就是`findAttribute(name,value);`方法，根据名称由小到大逐个域中查找，找到就返回，找不到就什么都不显示。\n\n它可以获取对象，可以是对象中关联其他对象，可以是一个List集合，也可以是一个Map集合。具体代码如下：\n\n**创建两个实体类，User和Address**\n\n```java\n/**\n * 用户的实体类\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class User implements Serializable{\n\n\tprivate String name = "黑马程序员";\n\tprivate int age = 18;\n\tprivate Address address = new Address();\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n\tpublic Address getAddress() {\n\t\treturn address;\n\t}\n\tpublic void setAddress(Address address) {\n\t\tthis.address = address;\n\t}\t\n}\n```\n\n```java\n/**\n * 地址的实体类\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class Address implements Serializable {\n\n\tprivate String province = "北京";\n\tprivate String city = "昌平区";\n\tpublic String getProvince() {\n\t\treturn province;\n\t}\n\tpublic void setProvince(String province) {\n\t\tthis.province = province;\n\t}\n\tpublic String getCity() {\n\t\treturn city;\n\t}\n\tpublic void setCity(String city) {\n\t\tthis.city = city;\n\t}\n}\n```\n\n**JSP代码**\n\n```jsp\n<%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%>\n<%@ page import="com.itheima.domain.User" %>\n<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">\n<html>\n\t<head>\n\t\t<title>EL入门</title>\n\t</head>\n\t<body>\n\t\t<%--EL表达式概念：\n\t\t\t\t它是Expression Language的缩写。它是一种替换jsp表达式的语言。\n\t\t\tEL表达式的语法：\n\t\t\t\t${表达式}\n\t\t\t\t表达式的特点：有明确的返回值。\n\t\t\t\tEL表达式就是把内容输出到页面上\n\t\t\tEL表达式的注意事项：\n\t\t\t\t1.EL表达式没有空指针异常\n\t\t\t\t2.EL表达式没有数组下标越界\n\t\t\t\t3.EL表达式没有字符串拼接\n\t\t\tEL表达式的数据获取：\n\t\t\t\t它只能在四大域对象中获取数据，不在四大域对象中的数据它取不到。\n\t\t\t\t它的获取方式就是findAttribute(String name)\n\t\t --%>\n\t\t <br/>-----------获取对象数据---------------------<br/>\n\t\t <% //1.把用户信息存入域中\n\t\t \tUser user = new User();\n\t\t \tpageContext.setAttribute("u",user);\n\t\t  %>\n\t\t  ${u}===============输出的是内存地址<%--就相当于调用此行代码<%=pageContext.findAttribute("u")%> --%><br/>\n\t\t  ${u.name}<%--就相当于调用此行代码<% User user = (User) pageContext.findAttribute("u");out.print(user.getName());%> --%><br/>\n\t\t  ${u.age}\n\t\t <br/>-----------获取关联对象数据------------------<br/>\n\t\t ${u.address}==========输出的address对象的地址<br/>\n\t\t ${u.address.province}${u.address.city}<br/>\n\t\t ${u["address"][\'province\']}\n\t\t <br/>-----------获取数组数据---------------------<br/>\n\t\t <% String[] strs = new String[]{"He","llo","Expression","Language"}; \n\t\t \tpageContext.setAttribute("strs", strs);\n\t\t %>\n\t\t ${strs[0]}==========取的数组中下标为0的元素<br/>\n\t\t ${strs[3]}\n\t\t ${strs[5]}===========如果超过了数组的下标，则什么都不显示<br/>\n\t\t ${strs["2"]}=========会自动为我们转换成下标<br/>\n\t\t ${strs[\'1\']}\n\t\t <br/>-----------获取List集合数据-----------------<br/>\n\t\t <% List<String> list = new ArrayList<String>();\n\t\t \tlist.add("AAA");\n\t\t \tlist.add("BBB");\n\t\t \tlist.add("CCC");\n\t\t \tlist.add("DDD");\n\t\t \tpageContext.setAttribute("list", list);\n\t\t  %>\n\t\t ${list}<br/>\n\t\t ${list[0] }<br/>\n\t\t ${list[3] }<br/>\t \n\t\t <br/>-----------获取Map集合数据------------------<br/>\n\t\t <% Map<String,User> map = new HashMap<String,User>();\n\t\t \tmap.put("aaa",new User());\n\t\t \tpageContext.setAttribute("map", map);\n\t\t  %>\n\t\t  ${map}<br/>\n\t\t  ${map.aaa}<%--获取map的value，是通过get(Key) --%><br/>\n\t\t  ${map.aaa.name}${map.aaa.age}<br/>\n\t\t  ${map["aaa"].name }\n\t</body>\n</html>\n```\n\n运行结果如图：\n\n![eldemo1](./img/java/javaweb/EL&Filter&Listener-授课.assets/eldemo1.png)\n\n#### 2）EL表达式的注意事项\n\n在使用EL表达式时，它帮我们做了一些处理，使我们在使用时可以避免一些错误。它没有空指针异常，没有数组下标越界，没有字符串拼接。\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n  <head>\n    <title>EL表达式的注意事项</title>\n  </head>\n  <body>\n    <%--EL表达式的三个没有--%>\n    第一个：没有空指针异常<br/>\n    <% String str = null;\n       request.setAttribute("testNull",str);\n    %>\n    ${testNull}\n    <hr/>\n    第二个：没有数组下标越界<br/>\n    <% String[] strs = new String[]{"a","b","c"};\n       request.setAttribute("strs",strs);\n    %>\n    取第一个元素：${strs[0]}\n    取第六个元素：${strs[5]}\n    <hr/>\n    第三个：没有字符串拼接<br/>\n    <%--${strs[0]+strs[1]}--%>\n    ${strs[0]}+${strs[1]}\n  </body>\n</html>\n```\n\n运行结果图：\n\n\\\\\n\n#### 3）EL表达式的使用细节\n\nEL表达式除了能在四大域中获取数据，同时它可以访问其他隐式对象，并且访问对象有返回值的方法.\n\n#### 4）EL表达式的运算符\n\nEL表达式中运算符如下图所示，它们都是一目了然的：\n\n![1577782263203](./img/java/javaweb/EL&Filter&Listener-授课.assets/1577782263203.png)\n\n![1577782270585](./img/java/javaweb/EL&Filter&Listener-授课.assets/1577782270585.png)\n\n但是有两个特殊的运算符，使用方式的代码如下：\n\n```jsp\n<%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%>\n<%@ page import="com.itheima.domain.User" %>\n<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">\n<html>\n\t<head>\n\t\t<title>EL两个特殊的运算符</title>\n\t</head>\n\t<body>\n\t\t<%--empty运算符：\n\t\t\t它会判断：对象是否为null，字符串是否为空字符串，集合中元素是否是0个\n\t\t--%>\n\t\t<% String str = null;\n\t\t  String str1 = "";\n\t\t  List<String> slist = new ArrayList<String>();\n\t\t  pageContext.setAttribute("str", str);\n\t\t  pageContext.setAttribute("str1", str1);\n\t\t  pageContext.setAttribute("slist", slist);\n\t\t%>\n\t\t${empty str}============当对象为null返回true<br/>\n\t\t${empty str1 }==========当字符串为空字符串是返回true(注意：它不会调用trim()方法)<br>\n\t\t${empty slist}==========当集合中的元素是0个时，是true\n\t\t<hr/>\n\t\t<%--三元运算符 \n\t\t\t 条件?真:假\n\t\t--%>\n\t\t<% request.setAttribute("gender", "female"); %>\n\t\t<input type="radio" name="gender" value="male" ${gender eq "male"?"checked":""} >男\n\t\t<input type="radio" name="gender" value="female" ${gender eq "female"?"checked":""}>女\n\t</body>\n</html>\n```\n\n运行结果图：\n\n![eldemo4](./img/java/javaweb/EL&Filter&Listener-授课.assets/eldemo4.png)\n\n### 1.1.3 EL表达式的11个隐式对象\n\n#### 1）隐式对象介绍\n\nEL表达式也为我们提供隐式对象，可以让我们不声明直接来使用，十一个对象见下表，需要注意的是，它和JSP的隐式对象不是一回事：\n\n| EL中的隐式对象   | 类型                          | 对应JSP隐式对象 | 备注                                    |\n| ---------------- | ----------------------------- | --------------- | --------------------------------------- |\n| PageContext      | Javax.serlvet.jsp.PageContext | PageContext     | 完全一样                                |\n| ApplicationScope | Java.util.Map                 | 没有            | 应用层范围                              |\n| SessionScope     | Java.util.Map                 | 没有            | 会话范围                                |\n| RequestScope     | Java.util.Map                 | 没有            | 请求范围                                |\n| PageScope        | Java.util.Map                 | 没有            | 页面层范围                              |\n| Header           | Java.util.Map                 | 没有            | 请求消息头key，值是value（一个）        |\n| HeaderValues     | Java.util.Map                 | 没有            | 请求消息头key，值是数组（一个头多个值） |\n| Param            | Java.util.Map                 | 没有            | 请求参数key，值是value（一个）          |\n| ParamValues      | Java.util.Map                 | 没有            | 请求参数key，值是数组（一个名称多个值） |\n| InitParam        | Java.util.Map                 | 没有            | 全局参数，key是参数名称，value是参数值  |\n| Cookie           | Java.util.Map                 | 没有            | Key是cookie的名称，value是cookie对象    |\n\n## 1.2 JSTL\n\n### 1.2.1 JSTL概述\n\n#### 1）简介\n\nJSTL的全称是：JSP Standard Tag Libary。它是JSP中标准的标签库。它是由Apache实现的。\n\n它由以下5个部分组成：\n\n| 组成      | 作用         | 说明                           |\n| --------- | ------------ | ------------------------------ |\n| Core      | 核心标签库。 | 通用逻辑处理                   |\n| Fmt       | 国际化有关。 | 需要不同地域显示不同语言时使用 |\n| Functions | EL函数       | EL表达式可以使用的方法         |\n| SQL       | 操作数据库。 | 不用                           |\n| XML       | 操作XML。    | 不用                           |\n\n#### 2）使用要求\n\n要想使用JSTL标签库，在javaweb工程中需要导入坐标。首先是在工程的WEB-INF目录中创建一个lib目录，接下来把jstl的jar拷贝到lib目录中，最后在jar包上点击右键，然后选择【Add as Libary】添加。如下图所示：\n\n![jstl的jar包](./img/java/javaweb/EL&Filter&Listener-授课.assets/jstl的jar包.png)\n\n### 1.2.2 核心标签库\n\n在我们实际开发中，用到的jstl标签库主要以核心标签库为准，偶尔会用到国际化标签库的标签。下表中把我们经常可能用到的标签列在此处，其余标签库请同学们参考【JSTL标签库.doc】文档。\n\n| 标签名称                             | 功能分类 | 分类       | 作用             |\n| ------------------------------------ | -------- | ---------- | ---------------- |\n| `<c:if>`                             | 流程控制 | 核心标签库 | 用于判断         |\n| `<c:choose> ,<c:when>,<c:otherwise>` | 流程控制 | 核心标签库 | 用于多个条件判断 |\n| `<c:foreache>`                       | 迭代操作 | 核心标签库 | 用于循环遍历     |\n\n### 1.2.3 JSTL使用\n\n```jsp\n<%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%>\n<%--导入jstl标签库 --%>\n<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>\n<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">\n<html>\n  <head>\n    <title>JSTL的常用标签</title>\n  </head>\n  <body>\n    <%-- c:if  c:choose   c:when c:otherwise --%>\n    <% pageContext.setAttribute("score","F"); %>\n    <c:if test="${pageScope.score eq \'A\' }">\n    \t优秀\n    </c:if>\n    <c:if\ttest="${pageScope.score eq \'C\' }">\n    \t一般\n    </c:if>\n    <hr/>\n    <c:choose>\n    \t<c:when test="${pageScope.score eq \'A\' }">\n    \t\tAAA\n    \t</c:when>\n    \t<c:when test="${pageScope.score eq \'B\' }">BBB\n    \t</c:when>\n    \t<c:when test="${pageScope.score eq \'C\' }">CCC\n    \t</c:when>\n    \t<c:when test="${pageScope.score eq \'D\' }">DDD\n    \t</c:when>\n    \t<c:otherwise>其他</c:otherwise>\n    </c:choose>\n    \n    <%-- c:forEach 它是用来遍历集合的\n    \t 属性：\n    \t \titems：要遍历的集合，它可以是EL表达式取出来的\n    \t \tvar：把当前遍历的元素放入指定的page域中。 var的取值就是key,当前遍历的元素就是value\n    \t \t\t注意：它不能支持EL表达式，只能是字符串常量\n    \t \tbegin:开始遍历的索引\n    \t \tend:结束遍历的索引\n    \t \tstep：步长。i+=step\n    \t \tvarStatus：它是一个计数器对象。里面有两个属性，一个是用于记录索引。一个是用于计数。\n    \t \t\t\t   索引是从0开始。计数是从1开始\n    --%>\n    <hr/>\n    <% List<String> list = new ArrayList<String>();\n       list.add("AAA");\n       list.add("BBB");\n       list.add("CCC");\n       list.add("DDD");\n       list.add("EEE");\n       list.add("FFF");\n       list.add("GGG");\n       list.add("HHH");\n       list.add("III");\n       list.add("JJJ");\n       list.add("KKK");\n       list.add("LLL");\n       pageContext.setAttribute("list",list);\n     %>\n\t<c:forEach items="${list}" var="s" begin="1" end="7" step="2">\n    \t${s}<br/>\n    </c:forEach>\n    <hr/>\n    <c:forEach begin="1" end="9" var="num">\n    \t<a href="#">${num}</a>\n    </c:forEach>\n    <hr/>\n    <table>\n    \t<tr>\n    \t\t<td>索引</td>\n    \t\t<td>序号</td>\n    \t\t<td>信息</td>\n    \t</tr>\n    <c:forEach items="${list}" var="s" varStatus="vs">\n    \t<tr>\n    \t\t<td>${vs.index}</td>\n    \t\t<td>${vs.count}</td>\n    \t\t<td>${s}</td>\n    \t</tr>\n    </c:forEach>\n    </table>\n  </body>\n</html>\n```\n\n# 2 Servlet规范中的过滤器-Filter\n\n## 2.1 过滤器入门\n\n### 2.1.1 过滤器概念及作用\n\n过滤器——Filter，它是JavaWeb三大组件之一。另外两个是Servlet和Listener。\n\n它是在2000年发布的Servlet2.3规范中加入的一个接口。是Servlet规范中非常实用的技术。\n\n它可以对web应用中的所有资源进行拦截，并且在拦截之后进行一些特殊的操作。\n\n常见应用场景：URL级别的权限控制；过滤敏感词汇；中文乱码问题等等。\n\n### 2.1.2 过滤器的入门案例\n\n#### 1）前期准备\n\n**创建JavaWeb工程**\n\n![filter_demo1](./img/java/javaweb/EL&Filter&Listener-授课.assets/filter_demo1.png)\n\n**编写和配置接收请求用的Servlet**\n\n```java\n/**\n * 用于接收和处理请求的Servlet\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletDemo1 extends HttpServlet {\n\n    /**\n     * 处理请求的方法\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println("ServletDemo1接收到了请求");\n        req.getRequestDispatcher("/WEB-INF/pages/success.jsp").forward(req,resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n       doGet(req,resp);\n    }\n}\n```\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee\n                      http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"\n         version="3.1"\n         metadata-complete="true">\n    \n    \x3c!--配置Servlet--\x3e\n    <servlet>\n        <servlet-name>ServletDemo1</servlet-name>\n        <servlet-class>com.itheima.web.servlet.ServletDemo1</servlet-class>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>ServletDemo1</servlet-name>\n        <url-pattern>/ServletDemo1</url-pattern>\n    </servlet-mapping>\n</web-app>\n\n```\n\n**编写index.jsp**\n\n```jsp\n<%-- Created by IntelliJ IDEA. --%>\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n  <head>\n    <title>主页面</title>\n  </head>\n  <body>\n    <a href="${pageContext.request.contextPath}/ServletDemo1">访问ServletDemo1</a>\n  </body>\n</html>\n```\n\n**编写success.jsp**\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>成功页面</title>\n</head>\n<body>\n<%System.out.println("success.jsp执行了");%>\n执行成功！\n</body>\n</html>\n\n```\n\n![filter_demo2](./img/java/javaweb/EL&Filter&Listener-授课.assets/filter_demo2.png)\n\n#### 2）过滤器的编写步骤\n\n**编写过滤器**\n\n```java\n/**\n * Filter的入门案例\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class FilterDemo1 implements Filter {\n\n    /**\n     * 过滤器的核心方法\n     * @param request\n     * @param response\n     * @param chain\n     * @throws IOException\n     * @throws ServletException\n     */\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        /**\n         * 如果不写此段代码，控制台会输出两次：FilterDemo1拦截到了请求。\n         */\n        HttpServletRequest req = (HttpServletRequest) request;\n        String requestURI = req.getRequestURI();\n        if (requestURI.contains("favicon.ico")) {\n            return;\n        }\n        System.out.println("FilterDemo1拦截到了请求");\n    }\n}\n```\n\n**配置过滤器**\n\n```xml\n\x3c!--配置过滤器--\x3e\n<filter>\n    <filter-name>FilterDemo1</filter-name>\n    <filter-class>com.itheima.web.filter.FilterDemo1</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>FilterDemo1</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n\n#### 3）测试部署\n\n**部署项目**\n\n![filter_demo3](./img/java/javaweb/EL&Filter&Listener-授课.assets/filter_demo3.png)\n\n**测试结果**\n\n![filter_demo4](./img/java/javaweb/EL&Filter&Listener-授课.assets/filter_demo4.png)\n\n**案例的问题分析及解决**\n\n当我们启动服务，在地址栏输入访问地址后，发现浏览器任何内容都没有，控制台却输出了【FilterDemo1拦截到了请求】，也就是说在访问任何资源的时候，都先经过了过滤器。\n\n这是因为：我们在配置过滤器的拦截规则时，使用了<font color=\'red\' size="5"><b>/*</b></font>,表明访问当前应用下任何资源，此过滤器都会起作用。除了这种全部过滤的规则之外，它还支持特定类型的过滤配置。我们可以稍作调整，就可以不用加上面那段过滤图标的代码了。修改的方式如下：\n\n![filter_demo6](./img/java/javaweb/EL&Filter&Listener-授课.assets/filter_demo6.png)\n\n现在的问题是，我们拦截下来了，点击链接发送请求，运行结果是：\n\n![filter_demo7](./img/java/javaweb/EL&Filter&Listener-授课.assets/filter_demo7.png)\n\n需要对过滤器执行放行操作，才能让他继续执行，那么如何放行的？\n\n我们需要使用`FilterChain`中的`doFilter`方法放行。\n\n![1577953319367](./img/java/javaweb/EL&Filter&Listener-授课.assets/filter_demo5.png)\n\n## 2.2 过滤器的细节\n\n### 2.2.1 过滤器API介绍\n\n#### 1）Filter\n\n![Filter_API](./img/java/javaweb/EL&Filter&Listener-授课.assets/Filter_API.png)\n\n![Filter_API2](./img/java/javaweb/EL&Filter&Listener-授课.assets/Filter_API2.png)\n\n#### 2）FilterConfig\n\n![FilterConfig_API](./img/java/javaweb/EL&Filter&Listener-授课.assets/FilterConfig_API.png)\n\n#### 3）FilterChain\n\n![FilterChain_API](./img/java/javaweb/EL&Filter&Listener-授课.assets/FilterChain_API.png)\n\n### 2.2.2 入门案例过程及生命周期\n\n#### 1）生命周期\n\n**出生——活着——死亡**\n\n**出生：**当应用加载的时候执行实例化和初始化方法。\n\n**活着：**只要应用一直提供服务，对象就一直存在。\n\n**死亡：**当应用卸载时，或者服务器宕机时，对象消亡。\n\n**Filter的实例对象在内存中也只有一份。所以也是单例的。**\n\n#### 2）过滤器核心方法的细节\n\n在`FilterDemo1`的`doFilter`方法添加一行代码，如下：\n\n```java\n/**\n     * 过滤器的核心方法\n     * @param request\n     * @param response\n     * @param chain\n     * @throws IOException\n     * @throws ServletException\n     */\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        /**\n         * 如果不写此段代码，控制台会输出两次：FilterDemo1拦截到了请求。\n\n        HttpServletRequest req = (HttpServletRequest) request;\n        String requestURI = req.getRequestURI();\n        if (requestURI.contains("favicon.ico")) {\n            return;\n        }*/\n        System.out.println("FilterDemo1拦截到了请求");\n        //过滤器放行\n        chain.doFilter(request,response);\n        System.out.println("FilterDemo1放行之后，又回到了doFilter方法");\n    }\n```\n\n测试运行结果，我们发现过滤器放行之后执行完目标资源，仍会回到过滤器中：\n\n![filter_demo8](./img/java/javaweb/EL&Filter&Listener-授课.assets/filter_demo8.png)\n\n### 2.2.3 过滤器初始化参数配置\n\n#### 1）创建过滤器FilterDemo2\n\n```java\n/**\n * Filter的初始化参数配置\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class FilterDemo2 implements Filter {\n\n    private FilterConfig filterConfig;\n\n    /**\n     * 初始化方法\n     * @param filterConfig\n     * @throws ServletException\n     */\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        System.out.println("FilterDemo2的初始化方法执行了");\n        //给过滤器配置对象赋值\n        this.filterConfig = filterConfig;\n    }\n\n    /**\n     * 过滤器的核心方法\n     * @param request\n     * @param response\n     * @param chain\n     * @throws IOException\n     * @throws ServletException\n     */\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n\n        System.out.println("FilterDemo2拦截到了请求");\n        //过滤器放行\n        chain.doFilter(request,response);\n    }\n    \n    /**\n     * 销毁方法\n     */\n    @Override\n    public void destroy() {\n        System.out.println("FilterDemo2的销毁方法执行了");\n    }\n}\n```\n\n#### 2）配置FilterDemo2\n\n```xml\n<filter>\n    <filter-name>FilterDemo2</filter-name>\n    <filter-class>com.itheima.web.filter.FilterDemo2</filter-class>\n    \x3c!--配置过滤器的初始化参数--\x3e\n    <init-param>\n        <param-name>filterInitParamName</param-name>\n        <param-value>filterInitParamValue</param-value>\n    </init-param>\n</filter>\n<filter-mapping>\n    <filter-name>FilterDemo2</filter-name>\n    <url-pattern>/ServletDemo1</url-pattern>\n</filter-mapping>\n```\n\n#### 3）在FilterDemo2的doFilter方法中添加下面的代码\n\n```java\n//根据名称获取过滤器的初始化参数\nString paramValue = filterConfig.getInitParameter("filterInitParamName");\nSystem.out.println(paramValue);\n\n//获取过滤器初始化参数名称的枚举\nEnumeration<String> initNames = filterConfig.getInitParameterNames();\nwhile(initNames.hasMoreElements()){\n    String initName = initNames.nextElement();\n    String initValue = filterConfig.getInitParameter(initName);\n    System.out.println(initName+","+initValue);\n}\n\n//获取ServletContext对象\nServletContext servletContext = filterConfig.getServletContext();\nSystem.out.println(servletContext);\n\n//获取过滤器名称\nString filterName = filterConfig.getFilterName();\nSystem.out.println(filterName);\n```\n\n#### 4）测试运行结果\n\n![FilterConfig_demo](./img/java/javaweb/EL&Filter&Listener-授课.assets/FilterConfig_demo.png)\n\n我们通过这个测试，看到了过滤器的初始化参数配置和获取的使用。但是同学们也肯定发现了，在我们的工程中两个过滤器都起作用了，这就是我们在API中说的链式调用，那么当有多个过滤器，它的执行顺序是什么样的呢？\n\n我们来看下一小节。\n\n### 2.2.5 多个过滤器的执行顺序\n\n#### 1）修改FilterDemo1和FilterDemo2两个过滤器的代码，删掉多余的代码\n\n```java\n/**\n * Filter的入门案例\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class FilterDemo1 implements Filter {\n    /**\n     * 过滤器的核心方法\n     * @param request\n     * @param response\n     * @param chain\n     * @throws IOException\n     * @throws ServletException\n     */\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        \n        System.out.println("FilterDemo1拦截到了请求");\n        //过滤器放行\n        chain.doFilter(request,response);\n    }\n\n    /**\n     * 初始化方法\n     * @param filterConfig\n     * @throws ServletException\n     */\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        System.out.println("FilterDemo1的初始化方法执行了");\n    }\n\n    /**\n     * 销毁方法\n     */\n    @Override\n    public void destroy() {\n        System.out.println("FilterDemo1的销毁方法执行了");\n    }\n}\n```\n\n```java\n/**\n * Filter的初始化参数配置\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class FilterDemo2 implements Filter {\n\n    /**\n     * 初始化方法\n     * @param filterConfig\n     * @throws ServletException\n     */\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        System.out.println("FilterDemo2的初始化方法执行了");\n\n    }\n\n    /**\n     * 过滤器的核心方法\n     * @param request\n     * @param response\n     * @param chain\n     * @throws IOException\n     * @throws ServletException\n     */\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n\n        System.out.println("FilterDemo2拦截到了请求");\n        //过滤器放行\n        chain.doFilter(request,response);\n    }\n\n    /**\n     * 销毁方法\n     */\n    @Override\n    public void destroy() {\n        System.out.println("FilterDemo2的销毁方法执行了");\n    }\n}\n```\n\n#### 2）修改两个过滤器的配置，删掉多余的配置\n\n```xml\n\x3c!--配置过滤器--\x3e\n<filter>\n    <filter-name>FilterDemo1</filter-name>\n    <filter-class>com.itheima.web.filter.FilterDemo1</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>FilterDemo1</filter-name>\n    <url-pattern>/ServletDemo1</url-pattern>\n</filter-mapping>\n\n\n<filter>\n    <filter-name>FilterDemo2</filter-name>\n    <filter-class>com.itheima.web.filter.FilterDemo2</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>FilterDemo2</filter-name>\n    <url-pattern>/ServletDemo1</url-pattern>\n</filter-mapping>\n```\n\n#### 3）测试运行结果\n\n![filter_multi_demo](./img/java/javaweb/EL&Filter&Listener-授课.assets/filter_multi_demo.png)\n\n此处我们看到了多个过滤器的执行顺序，它正好和我们在web.xml中的配置顺序一致，如下图：\n\n![filter_execute_order](./img/java/javaweb/EL&Filter&Listener-授课.assets/filter_execute_order.png)\n\n在过滤器的配置中，有过滤器的声明和过滤器的映射两部分，到底是声明决定顺序，还是映射决定顺序呢？\n\n答案是：<font color=\'red\'><b>`<filter-mapping>`的配置前后顺序决定过滤器的调用顺序，也就是由映射配置顺序决定。</b></font>\n\n### 2.2.6 过滤器的五种拦截行为\n\n我们的过滤器目前拦截的是请求，但是在实际开发中，我们还有请求转发和请求包含，以及由服务器触发调用的全局错误页面。默认情况下过滤器是不参与过滤的，要想使用，需要我们配置。配置的方式如下：\n\n```xml\n\x3c!--配置过滤器--\x3e\n<filter>\n    <filter-name>FilterDemo1</filter-name>\n    <filter-class>com.itheima.web.filter.FilterDemo1</filter-class>\n    \x3c!--配置开启异步支持，当dispatcher配置ASYNC时，需要配置此行--\x3e\n    <async-supported>true</async-supported>\n</filter>\n<filter-mapping>\n    <filter-name>FilterDemo1</filter-name>\n    <url-pattern>/ServletDemo1</url-pattern>\n    \x3c!--过滤请求：默认值。--\x3e\n    <dispatcher>REQUEST</dispatcher>\n    \x3c!--过滤全局错误页面：当由服务器调用全局错误页面时，过滤器工作--\x3e\n    <dispatcher>ERROR</dispatcher>\n    \x3c!--过滤请求转发：当请求转发时，过滤器工作。--\x3e\n    <dispatcher>FORWARD</dispatcher>\n    \x3c!--过滤请求包含：当请求包含时，过滤器工作。它只能过滤动态包含，jsp的include指令是静态包含--\x3e\n    <dispatcher>INCLUDE</dispatcher>\n    \x3c!--过滤异步类型，它要求我们在filter标签中配置开启异步支持--\x3e\n    <dispatcher>ASYNC</dispatcher>\n</filter-mapping>\n```\n\n### 2.2.4 过滤器与Servlet的区别\n\n| 方法/类型                                          | Servlet                                                      | Filter                                                       | 备注                                                         |\n| -------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 初始化                                        方法 | `void   init(ServletConfig);   `                             | `void init(FilterConfig);   `                                | 几乎一样，都是在web.xml中配置参数，用该对象的方法可以获取到。 |\n| 提供服务方法                                       | `void   service(request,response);                                               ` | `void   dofilter(request,response,FilterChain);                                   ` | Filter比Servlet多了一个FilterChain，它不仅能完成Servlet的功能，而且还可以决定程序是否能继续执行。所以过滤器比Servlet更为强大。   在Struts2中，核心控制器就是一个过滤器。 |\n| 销毁方法                                           | `void destroy();`                                            | `void destroy();`                                            |                                                              |\n\n## 2.3 过滤器的使用案例\n\n### 2.3.1 静态资源设置缓存时间过滤器\n\n#### 1） 需求说明\n\n在我们访问html，js，image时，不需要每次都重新发送请求读取资源，就可以通过设置响应消息头的方式，设置缓存时间。但是如果每个Servlet都编写相同的代码，显然不符合我们统一调用和维护的理念。（此处有个非常重要的编程思想：AOP思想，在录制视频时提不提都可以）\n\n因此，我们要采用过滤器来实现功能。\n\n#### 2） 编写步骤\n\n**第一步：创建JavaWeb工程**\n\n![filter2_demo](./img/java/javaweb/EL&Filter&Listener-授课.assets/filter2_demo.png)\n\n**第二步：导入静态资源**\n\n![filter2_demo_staticresource](./img/java/javaweb/EL&Filter&Listener-授课.assets/filter2_demo_staticresource.png)\n\n**第三步：编写过滤器**\n\n```java\n/**\n * 静态资源设置缓存时间\n * \thtml设置为1小时\n *  js设置为2小时\n *  css设置为3小时\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class StaticResourceNeedCacheFilter implements Filter {\n\n    private FilterConfig filterConfig;\n\n    public void init(FilterConfig filterConfig) throws ServletException {\n        this.filterConfig = filterConfig;\n    }\n\n\n    public void doFilter(ServletRequest req, ServletResponse res,\n                         FilterChain chain) throws IOException, ServletException {\n        //1.把doFilter的请求和响应对象转换成跟http协议有关的对象\n        HttpServletRequest  request;\n        HttpServletResponse response;\n        try {\n            request = (HttpServletRequest) req;\n            response = (HttpServletResponse) res;\n        } catch (ClassCastException e) {\n            throw new ServletException("non-HTTP request or response");\n        }\n        //2.获取请求资源URI\n        String uri = request.getRequestURI();\n        //3.得到请求资源到底是什么类型\n        String extend = uri.substring(uri.lastIndexOf(".")+1);//我们只需要判断它是不是html,css,js。其他的不管\n        //4.判断到底是什么类型的资源\n        long time = 60*60*1000;\n        if("html".equals(extend)){\n            //html 缓存1小时\n            String html = filterConfig.getInitParameter("html");\n            time = time*Long.parseLong(html);\n        }else if("js".equals(extend)){\n            //js 缓存2小时\n            String js = filterConfig.getInitParameter("js");\n            time = time*Long.parseLong(js);\n        }else if("css".equals(extend)){\n            //css 缓存3小时\n            String css = filterConfig.getInitParameter("css");\n            time = time*Long.parseLong(css);\n\n        }\n        //5.设置响应消息头\n        response.setDateHeader("Expires", System.currentTimeMillis()+time);\n        //6.放行\n        chain.doFilter(request, response);\n    }\n\n\n    public void destroy() {\n\n    }\n\n}\n```\n\n**第四步：配置过滤器**\n\n```xml\n<filter>\n    <filter-name>StaticResourceNeedCacheFilter</filter-name>\n    <filter-class>com.itheima.web.filter.StaticResourceNeedCacheFilter</filter-class>\n    <init-param>\n        <param-name>html</param-name>\n        <param-value>3</param-value>\n    </init-param>\n    <init-param>\n        <param-name>js</param-name>\n        <param-value>4</param-value>\n    </init-param>\n    <init-param>\n        <param-name>css</param-name>\n        <param-value>5</param-value>\n    </init-param>\n</filter>\n<filter-mapping>\n    <filter-name>StaticResourceNeedCacheFilter</filter-name>\n    <url-pattern>*.html</url-pattern>\n</filter-mapping>\n<filter-mapping>\n    <filter-name>StaticResourceNeedCacheFilter</filter-name>\n    <url-pattern>*.js</url-pattern>\n</filter-mapping>\n<filter-mapping>\n    <filter-name>StaticResourceNeedCacheFilter</filter-name>\n    <url-pattern>*.css</url-pattern>\n</filter-mapping>\n```\n\n#### 3） 测试结果\n\n> 此案例演示时需要注意一下，chrome浏览器刷新时，每次也都会发送请求，所以看不到304状态码。建议用IE浏览器，因为它在刷新时不会再次请求。\n\n![staticresource_demo](./img/java/javaweb/EL&Filter&Listener-授课.assets/staticresource_demo.png)\n\n### 2.3.2 特殊字符过滤器\n\n#### 1）需求说明\n\n在实际开发中，可能会面临一个问题，就是很多输入框都会遇到特殊字符。此时，我们也可以通过过滤器来解决。\n\n例如：\n\n​\t我们模拟一个论坛，有人发帖问：“在HTML中表示水平线的标签是哪个？”。\n\n如果我们在文本框中直接输入`<hr/>`就会出现一条水平线，这个会让发帖人一脸懵。\n\n我们接下来就用过滤器来解决一下。\n\n#### 2）编写步骤\n\n**第一步：创建JavaWeb工程**\n\n沿用第一个案例的工程\n\n**第二步：编写Servlet和JSP**\n\n```java\n/**\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletDemo1 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String content = request.getParameter("content");\n        response.getWriter().write(content);\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n```jsp\n<servlet>\n    <servlet-name>ServletDemo1</servlet-name>\n    <servlet-class>com.itheima.web.servlet.ServletDemo1</servlet-class>\n</servlet>\n<servlet-mapping>\n    <servlet-name>ServletDemo1</servlet-name>\n    <url-pattern>/ServletDemo1</url-pattern>\n</servlet-mapping>\n```\n\n```jsp\n<%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%>\n<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">\n<html>\n<head>\n    <title></title>\n</head>\n<body>\n<form action="${pageContext.request.contextPath}/ServletDemo1" method="POST">\n    回帖：<textarea rows="5" cols="25" name="content"></textarea><br/>\n    <input type="submit" value="发言">\n</form>\n</body>\n</html>\n```\n\n**第三步：编写过滤器**\n\n```java\n\n/**\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class HTMLFilter implements Filter {\n\n    public void init(FilterConfig filterConfig) throws ServletException {\n\n    }\n\n\n    public void doFilter(ServletRequest req, ServletResponse res,\n                         FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest request;\n        HttpServletResponse response;\n        try {\n            request = (HttpServletRequest) req;\n            response = (HttpServletResponse) res;\n        } catch (ClassCastException e) {\n            throw new ServletException("non-HTTP request or response");\n        }\n        //创建一个自己的Request类\n        MyHttpServletRequest2 myrequest = new MyHttpServletRequest2(request);\n        //放行：\n        chain.doFilter(myrequest, response);\n    }\n\n    public void destroy() {\n    }\n}\nclass MyHttpServletRequest2 extends HttpServletRequestWrapper {\n    //提供一个构造方法\n    public MyHttpServletRequest2(HttpServletRequest request){\n        super(request);\n    }\n\n    //重写getParameter方法\n    public String getParameter(String name) {\n        //1.获取出请求正文： 调用父类的获取方法\n        String value = super.getParameter(name);\n        //2.判断value是否有值\n        if(value == null){\n            return null;\n        }\n        return htmlfilter(value);\n    }\n\n    private String htmlfilter(String message){\n        if (message == null)\n            return (null);\n\n        char content[] = new char[message.length()];\n        message.getChars(0, message.length(), content, 0);\n        StringBuilder result = new StringBuilder(content.length + 50);\n        for (int i = 0; i < content.length; i++) {\n            switch (content[i]) {\n                case \'<\':\n                    result.append("&lt;");\n                    break;\n                case \'>\':\n                    result.append("&gt;");\n                    break;\n                case \'&\':\n                    result.append("&amp;");\n                    break;\n                case \'"\':\n                    result.append("&quot;");\n                    break;\n                default:\n                    result.append(content[i]);\n            }\n        }\n        return (result.toString());\n    }\n\n}\n```\n\n**第四步：配置过滤器**\n\n```xml\n<filter>\n    <filter-name>HTMLFilter</filter-name>\n    <filter-class>com.itheima.web.filter.HTMLFilter</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>HTMLFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n\n#### 3）测试结果\n\n![HTMLFilter_demo](./img/java/javaweb/EL&Filter&Listener-授课.assets/HTMLFilter_demo.png)\n\n# 3 Servlet规范中的监听器-Listener\n\n## 3.1 观察者设计模式\n\n在介绍监听器之前，先跟同学们普及一个知识，观察者设计模式。因为所有的监听器都是观察者设计模式的体现。\n\n那什么是观察者设计模式呢？\n\n它是事件驱动的一种体现形式。就好比在做什么事情的时候被人盯着。当对应做到某件事时，触发事件。\n\n观察者模式通常由以下三部分组成：\n\n​            事件源：触发事件的对象。\n\n​\t\t\t事件：触发的动作，里面封装了事件源。\n\n​\t\t\t监听器：当事件源触发事件时，要做的事情。一般是一个接口，由使用者来实现。（此处的思想还涉及了一个涉及模式，我们在JDBC的第二天课程中就给同学们讲解，策略模式）\n\n下图描述了观察者设计模式组成：\n\n![观察者模式](./img/java/javaweb/EL&Filter&Listener-授课.assets/观察者模式.jpg)\n\n## 3.1 Servlet规范中的8个监听器简介\n\n### 3.1.1 监听对象创建的\n\n#### 1）ServletContextListener\n\n```java\n/**\n * 用于监听ServletContext对象创建和销毁的监听器\n * @since v 2.3\n */\n\npublic interface ServletContextListener extends EventListener {\n\n    /**\n     *\t对象创建时执行此方法。该方法的参数是ServletContextEvent事件对象，事件是【创建对象】这个动作\n     *  事件对象中封装着触发事件的来源，即事件源，就是ServletContext\n     */\n    public default void contextInitialized(ServletContextEvent sce) {\n    }\n\n    /**\n     * 对象销毁执行此方法\n     */\n    public default void contextDestroyed(ServletContextEvent sce) {\n    }\n}\n```\n\n#### 2）HttpSessionListener\n\n```java\n/**\n * 用于监听HttpSession对象创建和销毁的监听器\n * @since v 2.3\n */\npublic interface HttpSessionListener extends EventListener {\n\n    /**\n     * 对象创建时执行此方法。\n     */\n    public default void sessionCreated(HttpSessionEvent se) {\n    }\n\n    /**\n     *  对象销毁执行此方法\n     */\n    public default void sessionDestroyed(HttpSessionEvent se) {\n    }\n}\n```\n\n#### 3）ServletRequestListener\n\n```java\n/**\n * 用于监听ServletRequest对象创建和销毁的监听器\n * @since Servlet 2.4\n */\npublic interface ServletRequestListener extends EventListener {\n\n   \t/**\n     *  对象创建时执行此方法。\n     */\n    public default void requestInitialized (ServletRequestEvent sre) {\n    }\n    \n    /**\n     * 对象销毁执行此方法\n     */\n    public default void requestDestroyed (ServletRequestEvent sre) {\n    } \n}\n```\n\n### 3.1.2 监听域中属性发生变化的\n\n#### 1）ServletContextAttributeListener\n\n```java\n/**\n * 用于监听ServletContext域（应用域）中属性发生变化的监听器\n * @since v 2.3\n */\n\npublic interface ServletContextAttributeListener extends EventListener {\n    /**\n     * 域中添加了属性触发此方法。参数是ServletContextAttributeEvent事件对象，事件是【添加属性】。\n     * 事件对象中封装着事件源，即ServletContext。\n     * 当ServletContext执行setAttribute方法时，此方法可以知道，并执行。\n     */\n    public default void attributeAdded(ServletContextAttributeEvent scae) {\n    }\n\n    /**\n     * 域中删除了属性触发此方法\n     */\n    public default void attributeRemoved(ServletContextAttributeEvent scae) {\n    }\n\n    /**\n     * 域中属性发生改变触发此方法\n     */\n    public default void attributeReplaced(ServletContextAttributeEvent scae) {\n    }\n}\n```\n\n#### 2）HttpSessionAttributeListener\n\n```java\n/**\n * 用于监听HttpSession域（会话域）中属性发生变化的监听器\n * @since v 2.3\n */\npublic interface HttpSessionAttributeListener extends EventListener {\n\n    /**\n     * 域中添加了属性触发此方法。\n     */\n    public default void attributeAdded(HttpSessionBindingEvent se) {\n    }\n\n    /**\n     * 域中删除了属性触发此方法\n     */\n    public default void attributeRemoved(HttpSessionBindingEvent se) {\n    }\n\n    /**\n     * 域中属性发生改变触发此方法\n     */\n    public default void attributeReplaced(HttpSessionBindingEvent se) {\n    }\n}\n```\n\n#### 3）ServletRequestAttributeListener\n\n```java\n/**\n * 用于监听ServletRequest域（请求域）中属性发生变化的监听器\n * @since Servlet 2.4\n */\npublic interface ServletRequestAttributeListener extends EventListener {\n    /**\n     * 域中添加了属性触发此方法。\n     */\n    public default void attributeAdded(ServletRequestAttributeEvent srae) {\n    }\n\n    /**\n     * 域中删除了属性触发此方法\n     */\n    public default void attributeRemoved(ServletRequestAttributeEvent srae) {\n    }\n\n    /**\n     * 域中属性发生改变触发此方法\n     */\n    public default void attributeReplaced(ServletRequestAttributeEvent srae) {\n    }\n}\n```\n\n### 3.1.3 和会话相关的两个感知型监听器\n\n此处要跟同学们明确一下，和会话域相关的两个感知型监听器是无需配置的，直接编写代码即可。\n\n#### 1）HttpSessionBinderListener\n\n```java\n/**\n * 用于感知对象和和会话域绑定的监听器\n * 当有数据加入会话域或从会话域中移除，此监听器的两个方法会执行。\n * 加入会话域即和会话域绑定\n * 从会话域移除即从会话域解绑\n */\npublic interface HttpSessionBindingListener extends EventListener {\n\n    /**\n     * 当数据加入会话域时，也就是绑定，此方法执行\n     */\n    public default void valueBound(HttpSessionBindingEvent event) {\n    }\n\n    /**\n     * 当从会话域移除时，也就是解绑，此方法执行\n     */\n    public default void valueUnbound(HttpSessionBindingEvent event) {\n    }\n}\n\n```\n\n#### 2）HttpSessionActivationListener\n\n```java\n/**\n * 用于感知会话域中对象钝化和活化的监听器\n */\npublic interface HttpSessionActivationListener extends EventListener {\n\n    /**\n     * 当会话域中的数据钝化时，此方法执行\n     */\n    public default void sessionWillPassivate(HttpSessionEvent se) {\n    }\n\n    /**\n     * 当会话域中的数据活化时（激活），此方法执行\n     */\n    public default void sessionDidActivate(HttpSessionEvent se) {\n    }\n}\n```\n\n## 3.2 监听器的使用\n\n在实际开发中，我们可以根据具体情况来从这8个监听器中选择使用。感知型监听器由于无需配置，只需要根据实际需求编写代码，所以此处我们就不再演示了。我们在剩余6个中分别选择一个监听对象创建销毁和对象域中属性发生变化的监听器演示一下。\n\n### 3.2.1 ServletContextListener的使用\n\n**第一步：创建工程**\n\n![listener_demo1](./img/java/javaweb/EL&Filter&Listener-授课.assets/listener_demo1.png)\n\n**第二步：编写监听器**\n\n```java\n/**\n * 用于监听ServletContext对象创建和销毁的监听器\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletContextListenerDemo implements ServletContextListener {\n\n    /**\n     * 对象创建时，执行此方法\n     * @param sce\n     */\n    @Override\n    public void contextInitialized(ServletContextEvent sce) {\n        System.out.println("监听到了对象的创建");\n        //1.获取事件源对象\n        ServletContext servletContext = sce.getServletContext();\n        System.out.println(servletContext);\n    }\n\n    /**\n     * 对象销毁时，执行此方法\n     * @param sce\n     */\n    @Override\n    public void contextDestroyed(ServletContextEvent sce) {\n        System.out.println("监听到了对象的销毁");\n    }\n}\n```\n\n**第三步：在web.xml中配置监听器**\n\n```xml\n\x3c!--配置监听器--\x3e\n<listener>\n    <listener-class>com.itheima.web.listener.ServletContextListenerDemo</listener-class>\n</listener>\n```\n\n**第四步：测试结果**\n\n![listener_demo2](./img/java/javaweb/EL&Filter&Listener-授课.assets/listener_demo2.png)\n\n### 3.2.2 ServletContextAttributeListener的使用\n\n**第一步：创建工程**\n\n沿用上一个案例的工程\n\n**第二步：编写监听器**\n\n```java\n/**\n * 监听域中属性发生变化的监听器\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletContextAttributeListenerDemo implements ServletContextAttributeListener {\n\n    /**\n     * 域中添加了数据\n     * @param scae\n     */\n    @Override\n    public void attributeAdded(ServletContextAttributeEvent scae) {\n        System.out.println("监听到域中加入了属性");\n        /**\n         * 由于除了我们往域中添加了数据外，应用在加载时还会自动往域中添加一些属性。\n         * 我们可以获取域中所有名称的枚举，从而看到域中都有哪些属性\n         */\n        \n        //1.获取事件源对象ServletContext\n        ServletContext servletContext = scae.getServletContext();\n        //2.获取域中所有名称的枚举\n        Enumeration<String> names = servletContext.getAttributeNames();\n        //3.遍历名称的枚举\n        while(names.hasMoreElements()){\n            //4.获取每个名称\n            String name = names.nextElement();\n            //5.获取值\n            Object value = servletContext.getAttribute(name);\n            //6.输出名称和值\n            System.out.println("name is "+name+" and value is "+value);\n        }\n    }\n\n    /**\n     * 域中移除了数据\n     * @param scae\n     */\n    @Override\n    public void attributeRemoved(ServletContextAttributeEvent scae) {\n        System.out.println("监听到域中移除了属性");\n    }\n\n    /**\n     * 域中属性发生了替换\n     * @param scae\n     */\n    @Override\n    public void attributeReplaced(ServletContextAttributeEvent scae) {\n        System.out.println("监听到域中属性发生了替换");\n    }\n}\n```\n\n同时，我们还需要借助第一个`ServletContextListenerDemo`监听器，往域中存入数据，替换域中的数据以及从域中移除数据，代码如下：\n\n```java\n/**\n * 用于监听ServletContext对象创建和销毁的监听器\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletContextListenerDemo implements ServletContextListener {\n\n    /**\n     * 对象创建时，执行此方法\n     * @param sce\n     */\n    @Override\n    public void contextInitialized(ServletContextEvent sce) {\n        System.out.println("监听到了对象的创建");\n        //1.获取事件源对象\n        ServletContext servletContext = sce.getServletContext();\n        //2.往域中加入属性\n        servletContext.setAttribute("servletContext","test");\n    }\n\n    /**\n     * 对象销毁时，执行此方法\n     * @param sce\n     */\n    @Override\n    public void contextDestroyed(ServletContextEvent sce) {\n        //1.取出事件源对象\n        ServletContext servletContext = sce.getServletContext();\n        //2.往域中加入属性，但是名称仍采用servletContext，此时就是替换\n        servletContext.setAttribute("servletContext","demo");\n        System.out.println("监听到了对象的销毁");\n        //3.移除属性\n        servletContext.removeAttribute("servletContext");\n    }\n}\n```\n\n**第三步：在web.xml中配置监听器**\n\n```xml\n\x3c!--配置监听器--\x3e\n<listener>\n    <listener-class>com.itheima.web.listener.ServletContextListenerDemo</listener-class>\n</listener>\n\n\x3c!--配置监听器--\x3e\n<listener>\n    <listener-class>com.itheima.web.listener.ServletContextAttributeListenerDemo</listener-class>\n</listener>\n```\n\n**第四步：测试结果**\n\n![attributelistener_demo](./img/java/javaweb/EL&Filter&Listener-授课.assets/attributelistener_demo.png)\n\n# 4 综合案例-学生管理系统改造\n\n## 4.1 需求说明\n\n### 4.1.1 解决乱码问题\n\n我们的学生管理系统中，肯定会有请求和响应的中文乱码问题。而乱码问题在学习Servlet的课程中已经讲解了如何解决了。只是在实际开发中，当有很多的Servlet时，肯定不能在每个Servlet中都编写一遍解决乱码的代码。因此，就可以利用我们今天学习的过滤器来实现统一解决请求和响应乱码的问题。\n\n### 4.1.2 检查登录\n\n在学生管理系统中，它包含了学生信息的录入和学生列表的查询，用户（员工）信息的录入以及查询。当然，我们实际的功能可能远远不止这些。但是就已有功能来说，也不是谁都可以通过地址栏直接输入访问的，它应该有权限的控制，只是我们课程在此处没法深入展开讲解权限，但最起码的登录，身份的认证还是必要的。\n\n由此，就引出来一个问题，是在每次访问Servlet时，在Servlet的代码中加入是否认证过身份的判断吗？显然，是不合理的。那么，既然不是在每个Servlet中编写，就应该是统一管理和维护。此时，我们的过滤器就又可以出场了。\n\n### 4.1.3 页面的java代码块和jsp表达式改造\n\n我们今天除了学习了过滤器，还学习了EL表达式和JSTL标签库，它们的出现就是避免我们的JSP页面中有过多的java代码或者jsp表达式。我们要运用今天所学知识改造页面。\n\n## 4.2 案例实现\n\n### 4.2.1 乱码问题过滤器\n\n创建EncodingFilter类，解决乱码\n\n```java\npackage com.itheima.filter;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.annotation.WebFilter;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/*\n    解决全局乱码问题\n */\n@WebFilter("/*")\npublic class EncodingFilter implements Filter{\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) {\n        try{\n            //1.将请求和响应对象转换为和HTTP协议相关\n            HttpServletRequest request = (HttpServletRequest) servletRequest;\n            HttpServletResponse response = (HttpServletResponse) servletResponse;\n\n            //2.设置编码格式\n            request.setCharacterEncoding("UTF-8");\n            response.setContentType("text/html;charset=UTF-8");\n\n            //3.放行\n            filterChain.doFilter(request,response);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n}\n\n```\n\n\n\n### 4.2.2 检查登录过滤器\n\n检查登录，创建LoginFilter 类\n\n```java\npackage com.itheima.filter;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.annotation.WebFilter;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/*\n    检查登录\n */\n@WebFilter(value = {"/addStudent.jsp","/listStudentServlet"})\npublic class LoginFilter implements Filter{\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) {\n        try{\n            //1.将请求和响应对象转换为和HTTP协议相关\n            HttpServletRequest request = (HttpServletRequest) servletRequest;\n            HttpServletResponse response = (HttpServletResponse) servletResponse;\n\n            //2.获取会话域对象中数据\n            Object username = request.getSession().getAttribute("username");\n\n            //3.判断用户名\n            if(username == null || "".equals(username)) {\n                //重定向到登录页面\n                response.sendRedirect(request.getContextPath() + "/login.jsp");\n                return;\n            }\n\n            //4.放行\n            filterChain.doFilter(request,response);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n\n\n### 4.2.3 jsp页面的改造 \n\n​\t1，修改`addStudent.jsp`的虚拟访问路径\n\n```jsp\n<form action="${pageContext.request.contextPath}/addStudentServlet" method="get" autocomplete="off">\n    学生姓名：<input type="text" name="username"> <br>\n    学生年龄：<input type="number" name="age"> <br>\n    学生成绩：<input type="number" name="score"> <br>\n    <button type="submit">保存</button>\n</form>\n```\n\n2，修改`index.jsp`\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>\n<html>\n<head>\n    <title>学生管理系统首页</title>\n</head>\n<body>\n    <%--\n        获取会话域中的数据\n        如果获取到了则显示添加和查看功能的超链接\n        如果没获取到则显示登录功能的超链接\n    --%>\n    <c:if test="${sessionScope.username eq null}">\n        <a href="${pageContext.request.contextPath}/login.jsp">请登录</a>\n    </c:if>\n\n    <c:if test="${sessionScope.username ne null}">\n        <a href="${pageContext.request.contextPath}/addStudent.jsp">添加学生</a>\n        <a href="${pageContext.request.contextPath}/listStudentServlet">查看学生</a>\n    </c:if>\n\n</body>\n</html>\n\n```\n\n3，修改`listStudent.jsp`\n\n```jsp\n<%@ page import="com.itheima.bean.Student" %>\n<%@ page import="java.util.ArrayList" %>\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>\n<html>\n<head>\n    <title>查看学生</title>\n</head>\n<body>\n    <table width="600px" border="1px">\n        <tr>\n            <th>学生姓名</th>\n            <th>学生年龄</th>\n            <th>学生成绩</th>\n        </tr>\n        <c:forEach items="${students}" var="s">\n            <tr align="center">\n                <td>${s.username}</td>\n                <td>${s.age}</td>\n                <td>${s.score}</td>\n            </tr>\n        </c:forEach>\n    </table>\n</body>\n</html>\n\n```\n\n4，修改`login.jsp`\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>学生登录</title>\n</head>\n<body>\n    <form action="${pageContext.request.contextPath}/loginStudentServlet" method="get" autocomplete="off">\n        姓名：<input type="text" name="username"> <br>\n        密码：<input type="password" name="password"> <br>\n        <button type="submit">登录</button>\n    </form>\n</body>\n</html>\n\n```\n\n',ct={data:function(){return{MainComponent:lt}}},pt=ct,ut=Object(d["a"])(pt,st,ot,!1,null,"b9465e50",null),mt=ut.exports,dt=function(){var n=this;return n.$createElement,n._self._c,n._m(0)},gt=[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[t("div",[n._v("JSP")]),t("pre",[n._v("            jsp\n            java 表达式 % %   %-%  %@%  %!%\n            jsp 表达式 %= %\n            四大域对象： 页面域 pageContext ，请求域 ServletRequest ，会话域 HttpSession，应用域 ServletContext\n            EL 表达式 ${} 直接从 各域对象找值 ,只要域对象中有就可以\n\n        ")]),t("div",{staticClass:"article-content",staticStyle:{width:"100%",float:"left"}},[t("input",{attrs:{type:"hidden",name:"article_id",id:"article_id",value:"12156"}}),t("input",{attrs:{type:"hidden",name:"catid",id:"catid",value:"0"}}),t("p",[n._v("\n        在本章中，我们将讨论和学习JSP中的隐式对象。这些对象是JSP容器为每个页面中的开发人员提供的Java对象，开发人员可以直接调用它们而不用显式地声明它们再调用。\n        JSP隐式对象也称为预定义变量。\n      ")]),t("p",[n._v("下表列出了JSP支持的九个隐式对象 -")]),t("table",[t("thead",[t("tr",[t("th",[n._v("编号")]),t("th",[n._v("对象")]),t("th",[n._v("描述")])])]),t("tbody",[t("tr",[t("td",[n._v("1")]),t("td",[t("code",[n._v("request")])]),t("td",[n._v("这是与请求相关联的"),t("code",[n._v("HttpServletRequest")]),n._v("对象。")])]),t("tr",[t("td",[n._v("2")]),t("td",[t("code",[n._v("response")])]),t("td",[n._v("\n              这是与客户端的响应关联的"),t("code",[n._v("HttpServletResponse")]),n._v("对象。\n            ")])]),t("tr",[t("td",[n._v("3")]),t("td",[t("code",[n._v("out")])]),t("td",[n._v("这是用于将输出发送到客户端的"),t("code",[n._v("PrintWriter")]),n._v("对象。")])]),t("tr",[t("td",[n._v("4")]),t("td",[t("code",[n._v("session")])]),t("td",[n._v("这是与请求相关联的"),t("code",[n._v("HttpSession")]),n._v("对象。")])]),t("tr",[t("td",[n._v("5")]),t("td",[t("code",[n._v("application")])]),t("td",[n._v("\n              这是与应用程序上下文相关联的"),t("code",[n._v("ServletContext")]),n._v("对象。\n            ")])]),t("tr",[t("td",[n._v("6")]),t("td",[t("code",[n._v("config")])]),t("td",[n._v("这是与该页面相关联的"),t("code",[n._v("ServletConfig")]),n._v("对象。")])]),t("tr",[t("td",[n._v("7")]),t("td",[t("code",[n._v("pageContext")])]),t("td",[n._v("\n              这封装了使用服务器特定的功能，如更高性能的"),t("code",[n._v("JspWriter")]),n._v("。\n            ")])]),t("tr",[t("td",[n._v("8")]),t("td",[t("code",[n._v("page")])]),t("td",[n._v("这只是一个同义词，用于调用由翻译的servlet类定义的方法。")])]),t("tr",[t("td",[n._v("9")]),t("td",[t("code",[n._v("Exception")])]),t("td",[t("code",[n._v("Exception")]),n._v("对象允许指定的JSP访问异常数据。")])])])]),t("div",{staticClass:"table-wrapper"},[t("table",{staticStyle:{height:"230px",width:"486px"},attrs:{border:"0"}},[t("tbody",[t("tr",[t("td",{staticStyle:{"text-align":"center"}},[n._v("编号")]),t("td",{staticStyle:{"text-align":"center"}},[n._v("对象")]),t("td",{staticStyle:{"text-align":"center"}},[n._v("所属作用域")]),t("td",{staticStyle:{"text-align":"center"}},[n._v("作用域描述")])]),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[n._v("1")]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("request")])]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("request")])]),t("td",{staticStyle:{"text-align":"center"}},[n._v("\n              在当前"),t("strong",[n._v("请求")]),n._v("中有效\n            ")])]),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[n._v("2")]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("response")])]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("page")])]),t("td",{staticStyle:{"text-align":"center"}},[n._v("在当前"),t("strong",[n._v("页面")]),n._v("有效")])]),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[n._v("3")]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("out")])]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("page")])]),t("td",{staticStyle:{"text-align":"center"}},[n._v("在当前"),t("strong",[n._v("页面")]),n._v("有效")])]),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[n._v("4")]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("session")])]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("session")])]),t("td",{staticStyle:{"text-align":"center"}},[n._v("\n              在当前"),t("strong",[n._v("会话")]),n._v("中有效\n            ")])]),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[n._v("5")]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("application")])]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("application")])]),t("td",{staticStyle:{"text-align":"center"}},[n._v("\n              在所有"),t("strong",[n._v("应用程序")]),n._v("中有效\n            ")])]),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[n._v("6")]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("config")])]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("page")])]),t("td",{staticStyle:{"text-align":"center"}},[n._v("在当前"),t("strong",[n._v("页面")]),n._v("有效")])]),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[n._v("7")]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("pageContext")])]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("page")])]),t("td",{staticStyle:{"text-align":"center"}},[n._v("在当前"),t("strong",[n._v("页面")]),n._v("有效")])]),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[n._v("8")]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("page")])]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("page")])]),t("td",{staticStyle:{"text-align":"center"}},[n._v("在当前"),t("strong",[n._v("页面")]),n._v("有效")])]),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[n._v("9")]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("Exception")])]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("page")])]),t("td",{staticStyle:{"text-align":"center"}},[n._v("在当前"),t("strong",[n._v("页面")]),n._v("有效")])])])])]),t("h2",{attrs:{id:"h2-1-request-"}},[t("a",{staticClass:"reference-link",attrs:{name:"1. request对象"}}),t("span",{staticClass:"header-link octicon octicon-link"}),n._v("1. request对象\n      ")]),t("p",[t("code",[n._v("request")]),n._v("对象是"),t("code",[n._v("javax.servlet.http.HttpServletRequest")]),n._v("对象的一个实例。每当客户端请求页面时，JSP引擎将创建一个新对象来表示该请求。\n      ")]),t("p",[t("code",[n._v("request")]),n._v("对象提供了获取包括表单数据，Cookie，HTTP方法等HTTP头信息的方法。\n      ")]),t("h2",{attrs:{id:"h2-2-response-"}},[t("a",{staticClass:"reference-link",attrs:{name:"2. response对象"}}),t("span",{staticClass:"header-link octicon octicon-link"}),n._v("2. response对象\n      ")]),t("p",[t("code",[n._v("response")]),n._v("对象是"),t("code",[n._v("javax.servlet.http.HttpServletResponse")]),n._v("对象的一个实例。就像服务器创建"),t("code",[n._v("request")]),n._v("对象一样，它还创建一个对象来表示对客户端的响应。\n      ")]),t("p",[t("code",[n._v("response")]),n._v("对象还定义了处理创建新HTTP头的接口。通过此对象，JSP程序员可以添加新的Cookie或日期戳，HTTP状态代码等。\n      ")]),t("h2",{attrs:{id:"h2-3-out-"}},[t("a",{staticClass:"reference-link",attrs:{name:"3. out对象"}}),t("span",{staticClass:"header-link octicon octicon-link"}),n._v("3. out对象\n      ")]),t("p",[t("code",[n._v("out")]),n._v("隐式对象是"),t("code",[n._v("javax.servlet.jsp.JspWriter")]),n._v("对象的一个实例，用于在响应中发送内容。\n      ")]),t("p",[n._v("\n        初始化"),t("code",[n._v("JspWriter")]),n._v("对象根据页面是否缓存而不同地实例化。缓冲可以通过使用"),t("code",[n._v("page")]),n._v("指令的"),t("code",[n._v("buffered ='false'")]),n._v("属性来关闭。\n      ")]),t("p",[t("code",[n._v("JspWriter")]),n._v("对象包含与"),t("code",[n._v("java.io.PrintWriter")]),n._v("类大部分相同的方法。但是，"),t("code",[n._v("JspWriter")]),n._v("还有一些额外的方法用来处理缓冲。与"),t("code",[n._v("PrintWriter")]),n._v("对象不同，"),t("code",[n._v("JspWriter")]),n._v("会抛出"),t("code",[n._v("IOExceptions")]),n._v("异常。\n      ")]),t("p",[n._v("\n        下表列出了用于写入"),t("code",[n._v("boolean")]),n._v("，"),t("code",[n._v("char")]),n._v("，"),t("code",[n._v("int")]),n._v("，"),t("code",[n._v("double")]),n._v("，"),t("code",[n._v("object")]),n._v("，"),t("code",[n._v("String")]),n._v("等类型数据的重要方法。\n      ")]),t("table",[t("thead",[t("tr",[t("th",[n._v("编号")]),t("th",[n._v("方法")]),t("th",[n._v("描述")])])]),t("tbody",[t("tr",[t("td",[n._v("1")]),t("td",[t("code",[n._v("out.print(dataType dt)")])]),t("td",[n._v("打印数据类型值")])]),t("tr",[t("td",[n._v("2")]),t("td",[t("code",[n._v("out.println(dataType dt)")])]),t("td",[n._v("打印数据类型值，然后用新行(换行)字符终止行。")])]),t("tr",[t("td",[n._v("3")]),t("td",[t("code",[n._v("out.flush()")])]),t("td",[n._v("刷新流")])])])]),t("h2",{attrs:{id:"h2-4-session-"}},[t("a",{staticClass:"reference-link",attrs:{name:"4. session对象"}}),t("span",{staticClass:"header-link octicon octicon-link"}),n._v("4. session对象\n      ")]),t("p",[t("code",[n._v("session")]),n._v("对象是"),t("code",[n._v("javax.servlet.http.HttpSession")]),n._v("的一个实例，其行为与Java\n        Servlet下的会话对象行为完全相同。"),t("br"),t("code",[n._v("session")]),n._v("对象用于跟踪客户端请求之间的客户端会话。 \n      ")]),t("h2",{attrs:{id:"h2-5-application-"}},[t("a",{staticClass:"reference-link",attrs:{name:"5. application对象"}}),t("span",{staticClass:"header-link octicon octicon-link"}),n._v("5.\n        application对象\n      ")]),t("p",[t("code",[n._v("application")]),n._v("对象是生成的"),t("code",[n._v("Servlet")]),n._v("的"),t("code",[n._v("ServletContext")]),n._v("对象的直接包装，实际上是"),t("code",[n._v("javax.servlet.ServletContext")]),n._v("对象的一个实例。\n      ")]),t("p",[t("code",[n._v("application")]),n._v("对象是JSP页面在其整个生命周期中的表示。\n        当JSP页面被初始化时，将创建此对象，并且在JSP页面被"),t("code",[n._v("jspDestroy()")]),n._v("方法删除时"),t("code",[n._v("application")]),n._v("对象也将被删除。\n      ")]),t("p",[n._v("\n        通过向"),t("code",[n._v("application")]),n._v("对象添加属性值，可以确保组成Web应用程序的所有JSP文件都可以访问它。\n      ")]),t("h2",{attrs:{id:"h2-6-config-"}},[t("a",{staticClass:"reference-link",attrs:{name:"6. config对象"}}),t("span",{staticClass:"header-link octicon octicon-link"}),n._v("6. config对象\n      ")]),t("p",[t("code",[n._v("config")]),n._v("对象是"),t("code",[n._v("javax.servlet.ServletConfig")]),n._v("的实例化，是生成的servlet的"),t("code",[n._v("ServletConfig")]),n._v("对象周围的直接包装。\n      ")]),t("p",[n._v("\n        该对象允许JSP程序员访问Servlet或JSP引擎初始化参数，例如：路径或文件位置等。"),t("br"),n._v("以下配置方法是唯一可以使用的配置方法，它的用法是非常简单的\n        -\n      ")]),t("pre",{staticClass:"language-java code-toolbar"},[t("code",{staticClass:" language-java"},[n._v("config"),t("span",{staticClass:"token punctuation"},[n._v(".")]),t("span",{staticClass:"token function"},[n._v("getServletName")]),t("span",{staticClass:"token punctuation"},[n._v("(")]),t("span",{staticClass:"token punctuation"},[n._v(")")]),t("span",{staticClass:"token punctuation"},[n._v(";")]),n._v("\n")]),t("div",{staticClass:"toolbar"},[t("div",{staticClass:"toolbar-item"},[t("span",[n._v("Java")])])])]),t("p",[n._v("\n        这将返回当前"),t("code",[n._v("servlet")]),n._v("名称，它是包含在"),t("code",[n._v("WEB-INF\\web.xml")]),n._v("文件中定义的"),t("code",[n._v("<servlet-name>")]),n._v("元素中的字符串。\n      ")]),t("h2",{attrs:{id:"h2-7-pagecontext-"}},[t("a",{staticClass:"reference-link",attrs:{name:"7. pageContext对象"}}),t("span",{staticClass:"header-link octicon octicon-link"}),n._v("7.\n        pageContext对象\n      ")]),t("p",[t("code",[n._v("pageContext")]),n._v("对象是"),t("code",[n._v("javax.servlet.jsp.PageContext")]),n._v("对象的一个实例。"),t("code",[n._v("pageContext")]),n._v("对象用于表示整个JSP页面。\n      ")]),t("p",[t("code",[n._v("pageContext")]),n._v("对象旨在作为访问有关页面的信息的一种手段，同时避免大部分实现细节。"),t("br"),n._v("该对象存储对每个请求的请求和响应对象的引用。应用程序，配置，会话和输出对象是通过访问此对象的属性导出的。\n      ")]),t("p",[t("code",[n._v("pageContext")]),n._v("对象还包含有关发布到JSP页面的指令的信息，包括缓冲信息，"),t("code",[n._v("errorPageURL")]),n._v("和页面范围。\n      ")]),t("p",[t("code",[n._v("PageContext")]),n._v("类定义了几个字段，包括："),t("code",[n._v("PAGE_SCOPE")]),n._v("，"),t("code",[n._v("REQUEST_SCOPE")]),n._v("，"),t("code",[n._v("SESSION_SCOPE")]),n._v("和"),t("code",[n._v("APPLICATION_SCOPE")]),n._v("，它们标识了四个范围。它还支持超过"),t("code",[n._v("40")]),n._v("种方法，其中约一半是从"),t("code",[n._v("javax.servlet.jsp.JspContext")]),n._v("类继承的。\n      ")]),t("p",[n._v("\n        其中一个重要的方法是"),t("code",[n._v("removeAttribute")]),n._v("。\n        此方法接受一个或两个参数。\n        例如，"),t("code",[n._v('pageContext.removeAttribute("attrName")')]),n._v("从所有作用域中删除属性，而以下代码仅将其从页面范围中删除\n        -\n      ")]),t("pre",{staticClass:"language-java code-toolbar"},[t("code",{staticClass:" language-java"},[n._v("pageContext"),t("span",{staticClass:"token punctuation"},[n._v(".")]),t("span",{staticClass:"token function"},[n._v("removeAttribute")]),t("span",{staticClass:"token punctuation"},[n._v("(")]),t("span",{staticClass:"token string"},[n._v('"attrName"')]),t("span",{staticClass:"token punctuation"},[n._v(",")]),n._v(" PAGE_SCOPE"),t("span",{staticClass:"token punctuation"},[n._v(")")]),t("span",{staticClass:"token punctuation"},[n._v(";")]),n._v("\n")]),t("div",{staticClass:"toolbar"},[t("div",{staticClass:"toolbar-item"},[t("span",[n._v("Java")])])])]),t("h2",{attrs:{id:"h2-8-page-"}},[t("a",{staticClass:"reference-link",attrs:{name:"8. page对象"}}),t("span",{staticClass:"header-link octicon octicon-link"}),n._v("8. page对象\n      ")]),t("p",[t("code",[n._v("page")]),n._v("对象是对该页面实例的实际引用。可以认为它是表示整个JSP页面的对象。\n      ")]),t("p",[t("code",[n._v("page")]),n._v("对象是"),t("code",[n._v("this")]),n._v("对象的直接同义词。")]),t("h2",{attrs:{id:"h2-9-exception-"}},[t("a",{staticClass:"reference-link",attrs:{name:"9. exception对象"}}),t("span",{staticClass:"header-link octicon octicon-link"}),n._v("9. exception对象\n      ")]),t("p",[t("code",[n._v("exception")]),n._v("对象是一个包含上一页抛出的异常的包装器。它通常用于生成对错误条件的适当响应。\n      ")]),t("br")]),t("h4",[n._v("JSP 标准标签库（JSTL）")]),t("div",[t("a",{attrs:{href:"https://www.runoob.com/jsp/jsp-jstl.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://www.runoob.com/jsp/jsp-jstl.html")])])])}],St={},vt=St,bt=Object(d["a"])(vt,dt,gt,!1,null,"503f0b1b",null),ht=bt.exports,yt=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},ft=[],xt='# Tomcat&Http协议-授课\n\n# 1 企业开发简介\n\n## 1.1 JavaEE规范\n\n`JavaEE`规范是`J2EE`规范的新名称，早期被称为`J2EE`规范，其全称是`Java 2 Platform Enterprise Edition`，它是由SUN公司领导、各厂家共同制定并得到广泛认可的工业标准（`JCP`组织成员）。之所以改名为`JavaEE`，目的还是让大家清楚`J2EE`只是`Java`企业应用。在2004年底中国软件技术大会`Ioc`微容器(也就是`Jdon`框架的实现原理)演讲中指出：我们需要一个跨`J2SE/WEB/EJB`的微容器，保护我们的业务核心组件，以延续它的生命力，而不是依赖`J2SE/J2EE`版本.此次`J2EE`改名为`Java EE`，实际也反映出业界这种共同心声。\n\n`JavaEE`规范是很多`Java`开发技术的总称。这些技术规范都是沿用自`J2EE`的。一共包括了13个技术规范。例如：`jsp/servlet`，`jndi`，`jaxp`，`jdbc`，`jni`，`jaxb`，`jmf`，`jta`，`jpa`，`EJB`等。\n\n其中，`JCP`组织的全称是`Java Community Process`。它是一个开放的国际组织，主要由`Java`开发者以及被授权者组成，职能是发展和更新。成立于1998年。官网是：[JCP](https://jcp.org/en/home/index)\n\n`JavaEE`的版本是延续了`J2EE`的版本，但是没有继续采用其命名规则。`J2EE`的版本从1.0开始到1.4结束，而`JavaEE`版本是从`JavaEE 5`版本开始，目前最新的的版本是`JavaEE 8`。\n\n详情请参考：[JavaEE8规范概览](https://www.oracle.com/technetwork/cn/java/javaee/overview/index.html)\n\n## 1.2 Web概述\n\nWeb在英文中的含义是网状物，网络。在计算机领域，它通常指的是后者，即<b>网络</b>。像我们前面接触的`WWW`，它是由3个单词组成的，即：`World Wide Web `，中文含义是<b>万维网</b>。而我们前面学的`HTML`，`CSS`和`JS`的参考文档《`W3School`全套教程》中的`W3C`就是万维网联盟。他们的出现都是为了让我们在网络的世界中获取资源，这些资源的存放之处，我们称之为<b><font color=\'red\'>网站</font></b>。我们通过输入网站的地址（即：网址），就可以访问网站中提供的资源。在网上我们能访问到的内容全是资源（不区分局域网还是广域网）。只不过，不同类型的资源展示的效果不一样。\n\n首先，我们先来介绍资源的分类，它分为静态资源和动态资源。其中：\n\n静态资源指的是，网站中提供给人们展示的资源是一成不变的，也就是说不同人或者在不同时间，看到的内容都是一样的。例如：我们看到的新闻，网站的使用手册，网站功能说明文档等等。而作为开发者，我们编写的`html`,`css`,`js`,图片，多媒体等等都可以称为静态资源。\n\n动态资源它指的是，网站中提供给人们展示的资源是由程序产生的，在不同的时间或者用不同的人员由于身份的不同，所看到的内容是不一样的。例如：我们在12306上购买火车票，火车票的余票数由于时间的变化，会逐渐的减少，直到最后没有余票。还有，我们在`CSDN`上下载资料，只有登录成功后，且积分足够时才能下载。否则就不能下载，这就是访客身份和会员身份的区别。作为开发人员，我们编写的`JSP`，`servlet`，`php`，`ASP`等都是动态资源。\n\n关于广域网和局域网的划分，广域网指的就是万维网，也就是我们说的互联网。局域网是指的是在一定范围之内可以访问的网络，出了这个范围，就不能再使用的网络。\n\n## 1.3 系统结构\n\n### 1.3.1 系统结构简介\n\n在我们前面课程的学习中，开发的都是`Java`工程。这些工程在企业中称之为项目或者产品。项目也好，产品也罢，它是有系统架构的，系统架构的划分有很多种方式。我们今天讨论的是基础结构上的划分。除此之外，还有技术选型划分，部署方式划分等等。\n\n基础结构划分：C/S结构，B/S结构两类。\n\n技术选型划分：Model1模型，Model2模型，MVC模型和三层架构+MVC模型。\n\n部署方式划分：一体化架构，垂直拆分架构，分布式架构，流动计算架构，微服务架构。\n\n### 1.3.2 C/S结构\n\n它指的是客户端——服务器的方式。其中C代表着Client，S代表着服务器。C/S结构的系统设计图如下：\n\n![CS结构图](./img/java/javaweb/Tomcat&Http协议-授课.assets/CS结构图.jpg)\n\n### 1.3.3 B/S结构\n\n它指的是浏览器——服务器的方式。其中B代表着Browser，S代表着服务器。B/S结构的系统设计图如下：\n\n![BS结构图](./img/java/javaweb/Tomcat&Http协议-授课.assets/BS结构图.jpg)\n\n### 1.3.4 两种结构的区别及优略\n\n**两种结构的区别**\n\n第一：硬件环境不同，C/S通常是建立在专用的网络或小范围的网络环境上（即局域网），且必须要安装客户端。而B/S是建立在广域网上的，适应范围强，通常有操作系统和浏览器就行。\n\n第二：C/S结构比B/S结构更安全，因为用户群相对固定，对信息的保护更强。\n\n第三：B/S结构维护升级比较简单，而C/S结构维护升级相对困难。\n\n**优略**\n\n1 C/S：是能充分发挥客户端PC的处理能力，很多工作可以在客户端处理后再提交给服务器。对应的优点就是客户端响应速度快。\n\n2 B/S：总体拥有成本低、维护方便、 分布性强、开发简单，可以不用安装任何专门的软件就能 实现在任何地方进行操作，客户端零维护，系统的扩展非常容易，只要有一台能上网的电脑就能使用。\n\n**关于课程中结构的选择**\n\n<b><font color=\'red\'>我们的课程中涉及的系统结构都是是基于B/S结构。</font></b>\n\n# 2 Tomcat\n\n## 2.1 Tomcat介绍\n\n### 2.1.1 关于服务器\n\n服务器的概念非常的广泛，它可以指代一台特殊的计算机（相比普通计算机运行更快、负载更高、价格更贵），也可以指代用于部署网站的应用。我们这里说的服务器，其实是web服务器，或者应用服务器。它本质就是一个软件，一个应用。作用就是发布我们的应用（工程），让用户可以通过浏览器访问我们的应用。\n\n常见的应用服务器，请看下表：\n\n| 服务器名称  | 说明                                                  |\n| ----------- | ----------------------------------------------------- |\n| weblogic    | 实现了javaEE规范，重量级服务器，又称为javaEE容器      |\n| websphereAS | 实现了javaEE规范，重量级服务器。                      |\n| JBOSSAS     | 实现了JavaEE规范，重量级服务器。免费的。              |\n| Tomcat      | 实现了jsp/servlet规范，是一个轻量级服务器，开源免费。 |\n\n### 2.1.2 Tomcat下载与安装\n\n[Tomcat官网下载地址](http://tomcat.apache.org/)\n\n![tomcat官网](./img/java/javaweb/Tomcat&Http协议-授课.assets/tomcat官网.png)\n\n### 2.1.3 Tomcat各版本所需支持\n\n![Tomcat各版本使用技术支持](./img/java/javaweb/Tomcat&Http协议-授课.assets/Tomcat各版本使用技术支持.png)\n\n### 2.1.4 Tomcat目录结构详解\n\n![tomcat目录结构详解](./img/java/javaweb/Tomcat&Http协议-授课.assets/tomcat目录结构详解.png)\n\n## 2.2 Tomcat基本使用\n\n### 2.2.1 Tomcat启动和停止及问题分析解决\n\n#### 1）启动和停止\n\nTomcat服务器的启动文件在二进制文件目录中：![1574762703742](./img/java/javaweb/Tomcat&Http协议-授课.assets/1574762703742.png)，这两个文件就是Tomcat的启动文件。\n\nTomcat服务器的停止文件也在二进制文件目录中：![1574762805135](./img/java/javaweb/Tomcat&Http协议-授课.assets/1574762805135.png)，这两个文件就是Tomcat的停止文件。\n\n其中`.bat`文件是针对`windows`系统的运行程序，`.sh`文件是针对`linux`系统的运行程序。\n\n#### 2）启动问题\n\n**第一个问题：启动一闪而过**\n\n原因：没有配置环境变量。\n\n解决办法：配置上JAVA_HOME环境变量\n\n**第二个：Address already in use : JVM_Bind**\n\n![1574768107180](./img/java/javaweb/Tomcat&Http协议-授课.assets/1574768107180.png)\n\n原因：端口被占用\n\n解决办法：找到占用该端口的应用\n\n​                    进程不重要：使用cmd命令：netstat -a -o 查看pid  在任务管理器中结束占用端口的进程。\n\n​                    进程很重要：修改自己的端口号。修改的是Tomcat目录下`\\conf\\server.xml`中的配置。\n\n​\t\t\t![1574768222804](./img/java/javaweb/Tomcat&Http协议-授课.assets/1574768222804.png)\n\n**第三个：启动产生很多异常，但能正常启动**\n\n原因：Tomcat中部署着很多项目，每次启动这些项目都会启动。而这些项目中有启动报异常的。\n\n解决办法：\n\n​\t\t\t能找到报异常的项目，就把它从发布目录中移除。\n\n​\t\t\t不能确定报异常的项目，就重新解压一个新的Tomcat。\n\n**第四个：其它问题**\n\n例如：启动产生异常，但是不能正常启动。此时就需要解压一个新的Tomcat启动，来确定是系统问题，还是Tomcat的问题。\n\n所以，此时就需要具体问题，具体分析，然后再对症解决。\n\n### 2.2.2 IDEA集成Tomcat服务器\n\n**第一步**\n\n![IDEA配置Tomcat1](./img/java/javaweb/Tomcat&Http协议-授课.assets/IDEA配置Tomcat1.png)\n\n**第二步**\n\n![IDEA配置Tomcat2](./img/java/javaweb/Tomcat&Http协议-授课.assets/IDEA配置Tomcat2.png)\n\n**第三步**\n\n![IDEA配置Tomcat3](./img/java/javaweb/Tomcat&Http协议-授课.assets/IDEA配置Tomcat3.png)\n\n**第四步**\n\n![IDEA配置Tomcat4](./img/java/javaweb/Tomcat&Http协议-授课.assets/IDEA配置Tomcat4.png)\n\n### 2.2.3 Linux系统安装Tomcat\n\n**第一步：下载tomcat**\n\n参考**2.1.2小节的《Tomcat下载与安装》**进入Tomcat官网，找到对应版本点击`download`进入下载页面，如下图：\n\n![Linux版Tomcat](./img/java/javaweb/Tomcat&Http协议-授课.assets/Linux版Tomcat.png)\n\n**第二步：上传到linux**\n\n在crt上 使用 alt+p \n将windows上的软件拖进去即可(root目录)\n\n**第三步：在 /usr/local 新建一个文件夹tomcat**\n\n```\nmkdir /usr/local/tomcat\n```\n\n**第四步：移动 tomcat...tar.gz 到 /usr/local/tomcat**\n\n```\nmv apache-tomcat-8.5.32.tar.gz /usr/local/tomcat/\n```\n\n**第五步：进入/usr/local/tomcat目录,解压Tomcat**\n\n```\ncd /usr/local/tomcat\ntar -xvf apache-tomcat-8.5.32.tar.gz\n```\n\n**第六步：进入 /usr/local/tomcat/apache-tomcat-8.5.32/bin**\n\n```\ncd /usr/local/tomcat/apache-tomcat-8.5.32/bin\n```\n\n**第七步：启动tomcat**\n\n```\n方式1:\n\tsh startup.sh\n方式2:\n\t./startup.sh\n```\n\n**第八步：修改防火墙的规则 **\n\n```\n方式1:service iptables stop  关闭防火墙(不建议); 用到哪一个端口号就放行哪一个(80,8080,3306...)\n\n方式2:放行8080 端口\n\t修改配置文件\n\t\tcd /etc/sysconfig\n\t\tvi iptables\n\t\t\t复制(yy , p)\t\n\t\t\t\t-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT\n\t\t\t改成\n\t\t\t\t-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT\n\t\t重启加载防火墙或者重启防火墙\n\t\t\tservice iptables reload  \n\t\t\t或者\n\t\t\tservice iptables restart\n```\n\n## 2.3 Tomcat发布应用-JavaWeb应用\n\n### 2.3.1 JavaWeb工程概述\n\n`JavaWeb`应用是一个全新的应用种类。这类应用程序指供浏览器访问的程序，通常也简称为web应用。\n\n一个web应用由多个静态web资源和动态web资源组成，例如：html、css、js文件，jsp文件、java程序、支持jar包、工程配置文件、图片、音视频等等。\n\nWeb应用开发好后，若想供外界访问，需要把web应用所在目录交给Web服务器管理（Tomcat就是Web服务器之一），这个过程称之为虚似目录的映射。\n\n### 2.3.2 JavaWeb应用目录结构详解\n\n![1574768644245](./img/java/javaweb/Tomcat&Http协议-授课.assets/1574768644245.png)\n\n```\nmyapp--------------应用名称\n    1.html\n    css/css.css\n    js/demo.js\n\tWEB-INF--------如果有web.xml或者.class文件时，该目录必须存在，且严格区分大小写。\n\t\t   --------该目录下的资源，客户端是无法直接访问的。\n           --------目录中内容如下：\n        classes目录----------------web应用的class文件（加载顺序：我们的class，lib目录中的jar包，tomcat的lib目录中的jar包。优先级依次降低）\n        lib目录--------------------web应用所需的jar包（tomcat的lib目录下jar为所有应用共享）\n        web.xml-------------------web应用的主配置文件\n```\n\n### 2.3.3 JavaWeb应用的创建\n\n**第一步**\n\n![IDEA创建Javaweb工程](./img/java/javaweb/Tomcat&Http协议-授课.assets/IDEA创建Javaweb工程.png)\n\n**第二步**\n\n![创建Javaweb工程2](./img/java/javaweb/Tomcat&Http协议-授课.assets/创建Javaweb工程2.png)\n\n**第三步**\n\n![创建Javaweb工程3](./img/java/javaweb/Tomcat&Http协议-授课.assets/创建Javaweb工程3.png)\n\n**第四步**\n\n![创建Javaweb工程4](./img/java/javaweb/Tomcat&Http协议-授课.assets/创建Javaweb工程4.png)\n\n### 2.3.4 JavaWeb应用的部署\n\n#### 1）IDEA部署\n\n**第一步**\n\n![IDEA发布工程1](./img/java/javaweb/Tomcat&Http协议-授课.assets/IDEA发布工程1.png)\n\n**第二步**\n\n![IDEA发布工程2](./img/java/javaweb/Tomcat&Http协议-授课.assets/IDEA发布工程2.png)\n\n**第三步**\n\n![IDEA发布工程3-启动服务](./img/java/javaweb/Tomcat&Http协议-授课.assets/IDEA发布工程3-启动服务.png)\n\n#### 2）war包发布\n\n**第一步：使用<b>`jar -cvf war` <font color=\'blue\'>包的名称</font>  <font color=\'purple\'>当前目录中哪些资源要打入war</font></b>**\n\n![jar命令](./img/java/javaweb/Tomcat&Http协议-授课.assets/jar命令.png)\n\n![war包](./img/java/javaweb/Tomcat&Http协议-授课.assets/war包.png)\n\n**第二步：把打好的war拷贝到tomcat的webapps目录中**\n\n![拷贝war包到webapps](./img/java/javaweb/Tomcat&Http协议-授课.assets/拷贝war包到webapps.png)\n\n**第三步：启动服务时，tomcat会自动解压。**\n\n![启动Tomcat自动解压war包](./img/java/javaweb/Tomcat&Http协议-授课.assets/启动Tomcat自动解压war包.png)\n\n### 2.4.1 Tomcat配置虚拟目录\n\n虚拟目录的配置，支持两种方式。第一种是通过在主配置文件中添加标签实现。第二种是通过写一个独立配置文件实现。\n\n第一种方式：在`server.xml`的`<Host>`元素中加一个`<Context path="" docBase=""/>`元素。\n​\t\t\t\t\t `path`：访问资源URI。URI名称可以随便起，但是必须在前面加上一个/\n​\t\t\t\t\t`docBase`：资源所在的磁盘物理地址。\n第二种方式：是写一个独立的`xml`文件，该文件名可以随便起。在文件内写一个`<Context/>`元素。\n​\t\t\t\t\t该文件要放在Tomcat目录中的`conf\\Catalina\\localhost\\`目录下。\n需要注意的是，在使用了独立的配置文件之后，访问资源URI就变成了<b><font color=\'red\'>/+文件的名称</font></b>。而`Context`的`path`属性就失效了。\n\n### 2.4.2 Tomcat配置虚拟主机\n\n在`<Engine>`元素中添加一个`<Host name="" appBase="" unparkWARs="" autoDeploy="" />`，其中：\n​\t\t`name`：指定主机的名称\n​\t\t`appBase`：当前主机的应用发布目录\n​\t\t`unparkWARs`：启动时是否自动解压war包\n​\t\t`autoDeploy`：是否自动发布\n\n配置示例如下：\n\n```xml\n<Host name="www.itcast.cn" appBase="D:\\itcastapps" unpackWARs="true" autoDeploy="true"/>\n\n<Host name="www.itheima.com" appBase="D:\\itheimaapps" unpackWARs="true" autoDeploy="true"/>\n```\n\n### 2.4.3 Tomcat默认项配置\n\n**配置默认端口**\n\nTomcat服务器主配置文件中配置着访问端口，它在配置文件中写的值是：8080。但是它不是Tomcat的默认端口。我们此处说的默认端口是，当使用默认值的时候，端口号可以省略。Tomcat的默认端口是<b><font color=\'red\'>80</font></b>。\n\n配置方式如下：\n\n```xml\n<Connector port="80" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" />\t\t\n```\n\n**配置默认应用**\n\n有两种方式配置默认应用。\n第一种：把要作为默认应用的应用，名称改为`ROOT`。放到`webapps`目录中。\n\n![默认应用1](./img/java/javaweb/Tomcat&Http协议-授课.assets/默认应用1.png)\n\n第二种：写一个独立的配置文件，文件名称为`ROOT.xml`。\n​\t\t\t\t注意：`ROOT`必须大写。当使用了独立的`ROOT.xml`文件时，`webapps`下`ROOT`应用就不是默认应用了。\n\n![默认应用2](./img/java/javaweb/Tomcat&Http协议-授课.assets/默认应用2.png)\n\n**配置默认主页**\n\n首先要明确的是，配置默认主页是针对应用说的。是应用的默认主页。\n在应用的web.xml中配置：\n\n```xml\n<welcome-file-list>\n    <welcome-file>默认主页</welcome-file>\n</welcome-file-list>\n```\n\n例如：\n\n```xml\n<welcome-file-list>\n    <welcome-file>index.html</welcome-file>\n    <welcome-file>index.htm</welcome-file>\n    <welcome-file>index.jsp</welcome-file>\n</welcome-file-list>\n```\n\n# 3 HTTP协议\n\n## 3.1 HTTP协议概述\n\n### 3.1.1 HTTP协议概念\n\nHTTP的全称是：Hyper Text Transfer Protocol，意为 超文本传输协议。它指的是服务器和客户端之间交互必须遵循的一问一答的规则。形容这个规则：问答机制、握手机制。\n\n它规范了请求和响应内容的类型和格式。\n\nHTTP协议是由`W3C`组织管理和维护的。\n\n### 3.1.2 HTTP协议版本\n\n目前HTTP协议主要是1.0版本和1.1版本。这两个版本的区别主要是两个方面。\n\n第一：HTTP1.1版本比1.0版本多了一些消息头。\n\n第二：HTTP1.1版本和1.0版本的执行过程不一样。执行过程如下：\n\n| HTTP1.0            | HTTP1.1                |\n| ------------------ | ---------------------- |\n| 创建连接（TCP/IP） | 创建连接（TCP/IP）     |\n| 发送请求           | 发送请求1              |\n| 得到响应           | 得到响应1              |\n| 关闭连接           | 发送请求2              |\n| 创建连接（TCP/IP） | 得到响应2              |\n| 发送请求           | .......                |\n| 得到响应           | .......                |\n| 关闭连接           | 连接超时或手动关闭连接 |\n\n### 3.1.3 HTTP协议相关说明\n\nHTTP协议概念是客户浏览器和服务器一种一问一答的规则，那么必须要有问有答，而且要先问后答。\n但是我们使用`<script>`,`<link>`和`<img>`标签，没有手动发起请求，但是仍然能从服务器端拿到数据，原因就是：**在浏览器遇到`<script>`,`<link>`,`<img>`标签时会自动发出请求。**\n\n## 3.2 HTTP协议组成\n\n由HTTP协议的概念可知，它分为问和答两部分。其中问指的就是请求部分，而答指的就是响应部分。\n\n### 3.2.1请求部分  \n\n请求行： 永远位于请求的第一行\n请求消息头： 从第二行开始，到第一个空行结束\n请求的正文： 从第一个空行后开始，到正文的结束\n\n![请求部分](./img/java/javaweb/Tomcat&Http协议-授课.assets/请求部分-1574824553003.jpg)\n\n### 3.2.2 响应部分\n\n响应行： 永远位于响应的第一行\n响应消息头： 从第二行开始，到第一个空行结束\n响应的正文： 从第一个空行后开始，到正文的结束\n\n![响应部分](./img/java/javaweb/Tomcat&Http协议-授课.assets/响应部分-1574824560809.jpg)\n\n### 3.3.3 消息头的共性分析\n\n消息头名称首字母大写，多个单词每个单词的首字母都大写。\n多个单词用<b><font color=\'red\'>-</font></b>分隔\n名称和值之间用<b><font color=\'red\'>冒号加空格</font></b>分隔\n多个值之间用<b><font color=\'red\'>逗号加空格</font></b>分隔\n两个头之间用<b><font color=\'red\'>回车</font></b>分隔\n\n## 3.3 请求部分详解\n\n### 3.3.1 请求行详解\n\n请求行：`GET /myapp/2.html HTTP/1.1`\n\n| 内容          | 说明                       |\n| ------------- | -------------------------- |\n| GET           | 请求的方式。（还有POST）   |\n| /myapp/2.html | 请求的资源。               |\n| HTTP/1.1      | 使用的协议，及协议的版本。 |\n\n### 3.3.2 请求消息头详解\n\n| 内容                   | 说明                                                         |\n| ---------------------- | ------------------------------------------------------------ |\n| Accept                 | 告知服务器，客户浏览器所支持的MIME类型。                     |\n| Accept-Encoding        | 告知服务器，客户浏览器所支持的压缩编码格式。最常用的就是gzip压缩。 |\n| Accept-Language        | 告知服务器，客户浏览器所支持的语言。一般都是zh_CN或en_US等。 |\n| Referer                | 告知服务器，当前请求的来源。<br/>只有当前请求有来源的时候，才有这个消息头。从地址栏输入的没有来源。<br/>作用：1 投放广告  2 防盗链 |\n| Content-Type           | 告知服务器，请求正文的MIME类型。                             |\n| Content-Length         | 告知服务器，请求正文的长度。                                 |\n| User-Agent             | 浏览器相关信息                                               |\n| Connection: Keep-Alive | 连接的状态：保持连接                                         |\n| If-Modified-Since      | 告知服务器，客户浏览器缓存文件的最后修改时间。               |\n| Cookie（********）     | 会话管理相关，非常的重要。                                   |\n\n### 3.3.3 请求正文详解\n\n第一：只有post请求方式，才有请求的正文。get方式的正文是在地址栏中的。\n第二：表单的输入域有name属性的才会被提交。不分get和post的请求方式。\n第三：表单的enctype属性取值决定了请求正文的体现形式。概述的含义是：请求正文的MIME编码类型。\n\n| enctype取值                       | 请求正文体现形式                                   | 示例                                                         |\n| --------------------------------- | -------------------------------------------------- | ------------------------------------------------------------ |\n| application/x-www-form-urlencoded | key=value&key=value                                | username=test&password=1234                                  |\n| multipart/form-data               | 此时变成了多部分表单数据。多部分是靠分隔符分隔的。 | -----------------------------7df23a16c0210<br/>Content-Disposition: form-data; name="username"<br/><br/>test<br/>-----------------------------7df23a16c0210<br/>Content-Disposition: form-data; name="password"<br/><br/>1234<br/>-----------------------------7df23a16c0210<br/>Content-Disposition: form-data; name="headfile"; filename="C:\\Users\\zhy\\Desktop\\请求部分.jpg"<br/>Content-Type: image/pjpeg<br/>-----------------------------7df23a16c0210 |\n\n## 3.4 响应部分详解\n\n### 3.4.1 响应行详解\n\n响应行：`HTTP/1.1 200 OK`\n\n| 内容     | 说明             |\n| -------- | ---------------- |\n| HTTP/1.1 | 使用协议的版本。 |\n| 200      | 响应状态码       |\n| OK       | 状态码描述       |\n\n常用状态码介绍：\n\n| 状态码  | 说明                                             |\n| ------- | ------------------------------------------------ |\n| 200     | 一切都OK>                                        |\n| 302/307 | 请求重定向(客户端行为，两次请求，地址栏发生改变) |\n| 304     | 请求资源未发生变化，使用缓存                     |\n| 404     | 请求资源未找到                                   |\n| 500     | 服务器错误                                       |\n\n### 3.4.2 响应消息头详解\n\n| 消息头                  | 说明                                                         |\n| ----------------------- | ------------------------------------------------------------ |\n| Location                | 请求重定向的地址，常与302,307配合使用。                      |\n| Server                  | 服务器相关信息。                                             |\n| Content-Type            | 告知客户浏览器，响应正文的MIME类型。                         |\n| Content-Length          | 告知客户浏览器，响应正文的长度。                             |\n| Content-Encoding        | 告知客户浏览器，响应正文使用的压缩编码格式。常用的gzip压缩。 |\n| Content-Language        | 告知客户浏览器，响应正文的语言。zh_CN或en_US等等。           |\n| Content-Disposition     | 告知客户浏览器，以下载的方式打开响应正文。                   |\n| Refresh                 | 定时刷新                                                     |\n| Last-Modified           | 服务器资源的最后修改时间。                                   |\n| Set-Cookie（*******）   | 会话管理相关，非常的重要                                     |\n| Expires:-1              | 服务器资源到客户浏览器后的缓存时间                           |\n| Catch-Control: no-catch | 不要缓存，//针对http协议1.1版本                              |\n| Pragma:no-catch         | 不要缓存，//针对http协议1.0版本                              |\n\n### 3.4.3 响应正文详解\n\n就和我们在浏览器上右键查看源文件看到的内容是一样的。\n\n```html\n<html>\n    <head>\n        <link rel="stylesheet" href="css.css" type="text/css">\n        <script type="text/javascript" src="demo.js"><\/script>\n    </head>\n    <body>\n        <img src="1.jpg" />\n    </body>\n</html>\n```\n\n# 4 综合案例-Tomcat的具体应用\n\n## 4.1 静态资源案例-门户类网站的部署和访问\n\n### 4.1.1 案例介绍\n\n**需求：**\n\n​\t\t在浏览器中输入地址，访问静态HTML页面。\n\n**细节说明：**\n\n​\t\t把`HTML`和`CSS`课程中制作的页面加入到`JavaWeb`工程中，在Tomcat中部署工程，然后启动Tomcat服务器，并使用浏览器访问。\n\n### 4.1.2 实现步骤\n\n**第一步：创建工程并选择使用的Tomcat版本**\n\n![静态资源工程1](./img/java/javaweb/Tomcat&Http协议-授课.assets/静态资源工程1.png)\n\n![静态资源工程2](./img/java/javaweb/Tomcat&Http协议-授课.assets/静态资源工程2.png)\n\n**第二步：拷贝资源到工程的web目录中**\n\n![静态资源工程3](./img/java/javaweb/Tomcat&Http协议-授课.assets/静态资源工程3.png)\n\n**第三步：在web.xml中配置默认主页**\n\n![静态资源工程4](./img/java/javaweb/Tomcat&Http协议-授课.assets/静态资源工程4.png)\n\n**第四步：部署工程到Tomcat服务器**\n\n![静态资源工程5](./img/java/javaweb/Tomcat&Http协议-授课.assets/静态资源工程5.png)\n\n**第五步：测试浏览器访问**\n\n![静态资源工程6](./img/java/javaweb/Tomcat&Http协议-授课.assets/静态资源工程6.png)\n\n![静态资源工程7](./img/java/javaweb/Tomcat&Http协议-授课.assets/静态资源工程7.png)\n\n## 4.2 动态资源的案例-学生管理系统的部署和访问\n\n### 4.2.1 案例介绍\n\n**需求：**\n\n​\t\t把JavaSE进阶阶段的学生管理系统的服务器改用Tomcat实现。\n\n**细节说明：**\n\n​\t\t把学生管理系统涉及的HTML和样式以及图片文件拷贝到JavaWeb工程中，在Tomcat中部署工程，然后启动Tomcat服务器，并使用浏览器访问。\n\n### 4.2.2 实现步骤\n\n**第一步：创建工程**\n\n![动态资源工程](./img/java/javaweb/Tomcat&Http协议-授课.assets/动态资源工程.png)\n\n![动态资源工程1](./img/java/javaweb/Tomcat&Http协议-授课.assets/动态资源工程1.png)\n\n**第二步：拷贝资源**\n\n![动态资源工程2](./img/java/javaweb/Tomcat&Http协议-授课.assets/动态资源工程2.png)\n\n**第三步：配置默认主页**\n\n![动态资源工程4](./img/java/javaweb/Tomcat&Http协议-授课.assets/动态资源工程4.png)\n\n**第四步：部署项目**\n\n![动态资源工程3](./img/java/javaweb/Tomcat&Http协议-授课.assets/动态资源工程3.png)\n\n### 4.3.2 创建案例中的动态资源-Servlet\n\n#### 1） Servlet简介\n\nServlet翻译成中文是服务端脚本，它是SUN公司推出的一套规范，称为Servlet规范。Servlet规范是JavaEE规范中的一部分。我们可以通过查阅JavaEE规范的API来了解Servlet的基本概念。通过点击[JavaEE8官方文档](https://javaee.github.io/javaee-spec/javadocs/)，就可以看到关于Servlet的内容介绍。\n\n#### 2） 按步骤编写Servlet\n\n**前期准备：在IDEA创建Javaweb工程**\n\n![前期准备](./img/java/javaweb/Tomcat&Http协议-授课.assets/前期准备.png)\n\n**第一步：编写一个普通类实现Servlet接口或者继承GenericServlet类或者继承HttpServlet**\n\n![编写Servlet](./img/java/javaweb/Tomcat&Http协议-授课.assets/编写Servlet.png)\n\n**第二步：重写service方法，输出一句话**\n\n![重写Service方法](./img/java/javaweb/Tomcat&Http协议-授课.assets/重写Service方法.png)\n\n**第三步：在web.xml配置Servlet**\n\n![配置Servlet](./img/java/javaweb/Tomcat&Http协议-授课.assets/配置Servlet.png)\n\n**第四步：启动tomcat服务器测试**\n\n在地址栏输入：http://localhost:8585/crm/studentServlet 测试访问结果 \n\n#### 3）测试访问\n\n![测试访问结果](./img/java/javaweb/Tomcat&Http协议-授课.assets/测试访问结果.png)',wt={data:function(){return{MainComponent:xt}}},jt=wt,Ct=Object(d["a"])(jt,yt,ft,!1,null,"a775c5dc",null),Tt=Ct.exports,Et={mixins:[ce["c"]],components:{m1:Ve,m2:Ye,m3:it,m4:mt,m5:ht,m6:Tt},data:function(){return{tab:"m6",tab_level:2,tabs:[{label:"Tomcat&Http协议",value:"m6"},{label:"Servlet",value:"m1"},{label:"Request&Response",value:"m2"},{label:"Cookie&SessionJsp",value:"m3"},{label:"EL&Filter&Listener",value:"m4"},{label:"JSP",value:"m5"}]}}},It=Et,Dt=Object(d["a"])(It,Be,_e,!1,null,"34d52570",null),Rt=Dt.exports,Mt=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[t(""+n.tab,{tag:"component"})],1)},At=[],Ot=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},Pt=[],Lt='\x3c!--\n * @Date           : 2021-04-14 00:53:12\n * @FilePath       : /jinnian-space/src/pages/java/module/mybatis/md/mybatis-第1天讲义.md\n * @Description    : \n--\x3e\n## Mybatis 基础\n\n\n\n### 一.Mybatis快速入门\n\n#### 1.1 框架介绍\n\n* 框架是一款半成品软件，我们可以基于这个半成品软件继续开发，来完成我们个性化的需求！\n\n* 如图:\n\n  ![1590919723185](./img/java/mybatis/mybatis-第1天讲义.img/1590919723185.png)\n\n​ \n\n#### 1.2 ORM介绍\n\n* ORM(Object Relational Mapping)： 对象关系映射\n\n* 指的是持久化数据和实体对象的映射模式，为了解决面向对象与关系型数据库存在的互不匹配的现象的技术。\n\n* 如图:\n\n  ![1590919786415](./img/java/mybatis/mybatis-第1天讲义.img/1590919786415.png)\n\n* 具体映射关系如下图:\n\n![1590919824416](./img/java/mybatis/mybatis-第1天讲义.img/1590919824416.png)\n\n#### 1.3 原始jdbc操作（查询数据）\n\n![1590915350408](./img/java/mybatis/mybatis-第1天讲义.img/1590915350408.png)\n\n#### 1.4原始jdbc操作（插入数据）\n\n![1590915389449](./img/java/mybatis/mybatis-第1天讲义.img/1590915389449.png)\n\n#### 1.5 原始jdbc操作的分析\n\n* 原始 JDBC 的操作问题分析 \n\n  ​    1.频繁创建和销毁数据库的连接会造成系统资源浪费从而影响系统性能。\n\n    2. sql 语句在代码中硬编码，如果要修改 sql 语句，就需要修改 java 代码，造成代码不易维护。\n    3. 查询操作时，需要手动将结果集中的数据封装到实体对象中。\n    4. 增删改查操作需要参数时，需要手动将实体对象的数据设置到 sql 语句的占位符。 \n\n* 原始 JDBC 的操作问题解决方案 \n\n  ​    1.使用数据库连接池初始化连接资源。 \n\n  2. 将 sql 语句抽取到配置文件中。 \n  3. 使用反射、内省等底层技术，将实体与表进行属性与字段的自动映射    \n\n#### 1.6 什么是Mybatis\n\nmybatis 是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。\n\nmybatis通过xml或注解的方式将要执行的各种 statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。\n\n最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc 进行了封装，屏蔽了jdbc api 底层访问细节，使我们不用与jdbc api 打交道，就可以完成对数据库的持久化操作。\n\nMyBatis官网地址：<http://www.mybatis.org/mybatis-3/> \n\n#### 1.7  Mybatis的快速入门\n\n**MyBatis开发步骤：**\n\n①添加MyBatis的jar包\n\n②创建Student数据表\n\n③编写Studentr实体类 \n\n④编写映射文件StudentMapper.xml\n\n⑤编写核心文件MyBatisConfig.xml\n\n⑥编写测试类\n\n##### 1.7.1  环境搭建\n\n1)导入MyBatis的jar包\n\n* mysql-connector-java-5.1.37-bin.jar\n* mybatis-3.5.3.jar\n* log4j-1.2.17.jar\n\n2)  创建student数据表\n\n![1590916243454](./img/java/mybatis/mybatis-第1天讲义.img/1590916243454.png)\n\n3) 编写Student实体\n\n```java\npublic class Student {\n    private Integer id;\n    private String name;\n    private Integer age;\n    //省略get个set方法\n}\n```\n\n4)编写StudentMapper.xml映射文件\n\n```xml\n<?xml version="1.0" encoding="UTF-8" ?>\n\x3c!--MyBatis的DTD约束--\x3e\n<!DOCTYPE mapper\n        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n\n\x3c!--\n    mapper：核心根标签\n    namespace属性：名称空间\n--\x3e\n<mapper namespace="StudentMapper">\n    \x3c!--\n        select：查询功能的标签\n        id属性：唯一标识\n        resultType属性：指定结果映射对象类型\n        parameterType属性：指定参数映射对象类型\n    --\x3e\n    <select id="selectAll" resultType="student">\n        SELECT * FROM student\n    </select>\n\n    <select id="selectById" resultType="student" parameterType="int">\n        SELECT * FROM student WHERE id = #{id}\n    </select>\n\n    <insert id="insert" parameterType="student">\n        INSERT INTO student VALUES (#{id},#{name},#{age})\n    </insert>\n\n    <update id="update" parameterType="student">\n        UPDATE student SET name = #{name},age = #{age} WHERE id = #{id}\n    </update>\n\n    <delete id="delete" parameterType="int">\n        DELETE FROM student WHERE id = #{id}\n    </delete>\n</mapper>\n```\n\n5) 编写MyBatis核心文件\n\n```xml\n<?xml version="1.0" encoding="UTF-8" ?>\n\x3c!--MyBatis的DTD约束--\x3e\n<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">\n\n\x3c!--configuration 核心根标签--\x3e\n<configuration>\n\n    \x3c!--引入数据库连接的配置文件--\x3e\n    <properties resource="jdbc.properties"/>\n\n    \x3c!--配置LOG4J--\x3e\n    <settings>\n        <setting name="logImpl" value="log4j"/>\n    </settings>\n\n    \x3c!--起别名--\x3e\n    <typeAliases>\n        <typeAlias type="com.itheima.bean.Student" alias="student"/>\n        \x3c!--<package name="com.itheima.bean"/>--\x3e\n    </typeAliases>\n\n    \x3c!--environments配置数据库环境，环境可以有多个。default属性指定使用的是哪个--\x3e\n    <environments default="mysql">\n        \x3c!--environment配置数据库环境  id属性唯一标识--\x3e\n        <environment id="mysql">\n            \x3c!-- transactionManager事务管理。  type属性，采用JDBC默认的事务--\x3e\n            <transactionManager type="JDBC"></transactionManager>\n            \x3c!-- dataSource数据源信息   type属性 连接池--\x3e\n            <dataSource type="POOLED">\n                \x3c!-- property获取数据库连接的配置信息 --\x3e\n                <property name="driver" value="${driver}" />\n                <property name="url" value="${url}" />\n                <property name="username" value="${username}" />\n                <property name="password" value="${password}" />\n            </dataSource>\n        </environment>\n    </environments>\n\n    \x3c!-- mappers引入映射配置文件 --\x3e\n    <mappers>\n        \x3c!-- mapper 引入指定的映射配置文件   resource属性指定映射配置文件的名称 --\x3e\n        <mapper resource="StudentMapper.xml"/>\n    </mappers>\n</configuration>\n\n```\n##### 1.7.2编写dao代码\n```java\n\n    /*\n        查询全部\n     */\n    @Test\n    public void selectAll() throws Exception{\n        //1.加载核心配置文件\n        //InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n        InputStream is = StudentTest01.class.getClassLoader().getResourceAsStream("MyBatisConfig.xml");\n\n        //2.获取SqlSession工厂对象\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n\n        //3.通过SqlSession工厂对象获取SqlSession对象\n        SqlSession sqlSession = sqlSessionFactory.openSession();\n\n        //4.执行映射配置文件中的sql语句，并接收结果\n        List<Student> list = sqlSession.selectList("StudentMapper.selectAll");\n\n        //5.处理结果\n        for (Student stu : list) {\n            System.out.println(stu);\n        }\n\n        //6.释放资源\n        sqlSession.close();\n        is.close();\n    }\n/*\n        新增功能\n     */\n    @Test\n    public void insert() throws Exception{\n        //1.加载核心配置文件\n        InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n\n        //2.获取SqlSession工厂对象\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n\n        //3.通过工厂对象获取SqlSession对象\n        //SqlSession sqlSession = sqlSessionFactory.openSession();\n        SqlSession sqlSession = sqlSessionFactory.openSession(true);\n\n        //4.执行映射配置文件中的sql语句，并接收结果\n        Student stu = new Student(5,"周七",27);\n        int result = sqlSession.insert("StudentMapper.insert", stu);\n\n        //5.提交事务\n        //sqlSession.commit();\n\n        //6.处理结果\n        System.out.println(result);\n\n        //7.释放资源\n        sqlSession.close();\n        is.close();\n    }    \n\n```\n\n##### 1.7.3编写测试代码\n\n```java\n/*\n    控制层测试类\n */\npublic class StudentController {\n    //创建业务层对象\n    private StudentService service = new StudentServiceImpl();\n\n    //查询全部功能测试\n    @Test\n    public void selectAll() {\n        List<Student> students = service.selectAll();\n        for (Student stu : students) {\n            System.out.println(stu);\n        }\n    }\n}\n```\n\n#### 1.8 知识小结\n\n* 框架       \n\n   框架是一款半成品软件，我们可以基于框架继续开发，从而完成一些个性化的需求。\n\n* ORM        \n\n  对象关系映射，数据和实体对象的映射。\n\n* MyBatis       \n\n   是一个优秀的基于 Java 的持久层框架，它内部封装了 JDBC。\n\n  \n\n### 二. MyBatis的相关api\n\n#### 2.1 Resources\n\n* org.apache.ibatis.io.Resources：加载资源的工具类。\n\n* 核心方法\n\n  ![1590917572321](./img/java/mybatis/mybatis-第1天讲义.img/1590917572321.png)\n\n#### 2.2 构建器SqlSessionFactoryBuilder\n\n* org.apache.ibatis.session.SqlSessionFactoryBuilder：获取 SqlSessionFactory 工厂对象的功能类\n\n* 核心方法\n\n  ![1590916852504](./img/java/mybatis/mybatis-第1天讲义.img/1590916852504.png)\n\n* 通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象\n\n```java\nString resource = "org/mybatis/builder/mybatis-config.xml"; \nInputStream inputStream = Resources.getResourceAsStream(resource); \nSqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); \nSqlSessionFactory factory = builder.build(inputStream);\n```\n\n其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。\n\n#### 2.3 工厂对象SqlSessionFactory\n\n* org.apache.ibatis.session.SqlSessionFactory：获取 SqlSession 构建者对象的工厂接口。\n\n* 核心api\n\n  ![1590917006637](./img/java/mybatis/mybatis-第1天讲义.img/1590917006637.png)\n\n\n\n#### 2.4 SqlSession会话对象\n\n* org.apache.ibatis.session.SqlSession：构建者对象接口。用于执行 SQL、管理事务、接口代理。\n\n* 核心api\n\n  ![1590917052849](./img/java/mybatis/mybatis-第1天讲义.img/1590917052849.png)\n\nSqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。\n\n### 三.MyBatis 映射配置文件\n\n#### 3.1 映射配置文件介绍\n\n* 映射配置文件包含了数据和对象之间的映射关系以及要执行的 SQL 语句\n\n  ![1590917306615](./img/java/mybatis/mybatis-第1天讲义.img/1590917306615.png)\n\n\n\n#### 3.2 查询功能\n\n*  select：查询功能标签。\n\n* 属性        \n\n   id：唯一标识， 配合名称空间使用。     \n\n   parameterType：指定参数映射的对象类型。       \n\n   resultType：指定结果映射的对象类型。\n\n* SQL 获取参数:        #{属性名}\n\n* 示例\n\n  ![1590917699865](./img/java/mybatis/mybatis-第1天讲义.img/1590917699865.png)\n\n####3.3 新增功能 \n\n- insert：新增功能标签。\n\n- 属性        \n\n  id：唯一标识， 配合名称空间使用。     \n\n  parameterType：指定参数映射的对象类型。       \n\n  resultType：指定结果映射的对象类型。\n\n- SQL 获取参数:        #{属性名}\n\n* 示例\n\n![1590918390112](./img/java/mybatis/mybatis-第1天讲义.img/1590918390112.png)\n\n\n\n#### 3.4 修改功能\n\n- update：修改功能标签。\n\n- 属性        \n\n  id：唯一标识， 配合名称空间使用。     \n\n  parameterType：指定参数映射的对象类型。       \n\n  resultType：指定结果映射的对象类型。\n\n- SQL 获取参数:        #{属性名}\n\n* 示例\n\n![1590918538863](./img/java/mybatis/mybatis-第1天讲义.img/1590918538863.png)\n\n#### 3.5 删除功能\n\n- delete：查询功能标签。\n\n- 属性        \n\n  id：唯一标识， 配合名称空间使用。     \n\n  parameterType：指定参数映射的对象类型。       \n\n  resultType：指定结果映射的对象类型。\n\n- SQL 获取参数:        #{属性名}\n\n* 示例\n\n  ![1590918458329](./img/java/mybatis/mybatis-第1天讲义.img/1590918458329.png)\n\n* 总结： 大家可以发现crud操作，除了标签名称以及sql语句不一样之外，其他属性参数基本一致。\n\n#### 3.6 映射配置文件小结\n\n\n\n![1590918743943](./img/java/mybatis/mybatis-第1天讲义.img/1590918743943.png)\n\n### 四.Mybatis核心配置文件介绍\n\n#### 4.1 核心配置文件介绍\n\n核心配置文件包含了 MyBatis 最核心的设置和属性信息。如数据库的连接、事务、连接池信息等。\n\n如下图:\n\n~~~xml\n<?xml version="1.0" encoding="UTF-8" ?>\n\x3c!--MyBatis的DTD约束--\x3e\n<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">\n\n\x3c!--configuration 核心根标签--\x3e\n<configuration>\n\n    \x3c!--environments配置数据库环境，环境可以有多个。default属性指定使用的是哪个--\x3e\n    <environments default="mysql">\n        \x3c!--environment配置数据库环境  id属性唯一标识--\x3e\n        <environment id="mysql">\n            \x3c!-- transactionManager事务管理。  type属性，采用JDBC默认的事务--\x3e\n            <transactionManager type="JDBC"></transactionManager>\n            \x3c!-- dataSource数据源信息   type属性 连接池--\x3e\n            <dataSource type="POOLED">\n                \x3c!-- property获取数据库连接的配置信息 --\x3e\n                <property name="driver" value="com.mysql.jdbc.Driver" />\n                <property name="url" value="jdbc:mysql:///db1" />\n                <property name="username" value="root" />\n                <property name="password" value="root" />\n            </dataSource>\n        </environment>\n    </environments>\n\n    \x3c!-- mappers引入映射配置文件 --\x3e\n    <mappers>\n        \x3c!-- mapper 引入指定的映射配置文件   resource属性指定映射配置文件的名称 --\x3e\n        <mapper resource="StudentMapper.xml"/>\n    </mappers>\n</configuration>\n~~~\n\n#### 4.2 数据库连接配置文件引入\n\n* properties标签引入外部文件\n\n  ~~~xml\n      \x3c!--引入数据库连接的配置文件--\x3e\n      <properties resource="jdbc.properties"/>\n  ~~~\n\n* 具体使用，如下配置\n\n  ~~~xml\n    \x3c!-- property获取数据库连接的配置信息 --\x3e\n      <property name="driver" value="${driver}" />\n      <property name="url" value="${url}" />\n      <property name="username" value="${username}" />\n      <property name="password" value="${password}" />\n  ~~~\n\n  \n\n#### 4.3 起别名\n\n* <typeAliases>：为全类名起别名的父标签。\n\n* <typeAlias>：为全类名起别名的子标签。\n\n* 属性      \n\n   type：指定全类名      \n\n   alias：指定别名\n\n* <package>：为指定包下所有类起别名的子标签。(别名就是类名)\n\n* 如下图：\n\n  ![1590919106324](./img/java/mybatis/mybatis-第1天讲义.img/1590919106324.png)\n\n* 具体如下配置\n\n  ~~~xml\n      \x3c!--起别名--\x3e\n      <typeAliases>\n          <typeAlias type="com.itheima.bean.Student" alias="student"/>\n          \x3c!--<package name="com.itheima.bean"/>--\x3e\n      </typeAliase\n  ~~~\n\n#### 4.4 总结\n```xml\n核心配置文件包含了MyBatis.最核心的设置和属性信息。如数据库的连接、事务、连接池信息等。\n\n<configuration> :核心根标签。\n<properties> :引入数据库连接信息配置文件标签。\n<typeAliases> :起别名标签。\n<environments>:配置数据库环境标签。\n<environment>:配置数据库信息标签。\n<transactionManager>︰事务管理标签。\n<dataSource>︰数据源标签。\n<property>:数据库连接信息标签。\n<mappers> :引入映射配置文件标签。\n\n```\n\n \n\n### 五.Mybatis传统方式开发\n\n#### 5.1 Dao 层传统实现方式\n\n* 分层思想：控制层(controller)、业务层(service)、持久层(dao)。\n\n* 调用流程\n\n  ![1590919558066](./img/java/mybatis/mybatis-第1天讲义.img/1590919558066.png)\n\n#### 5.2 LOG4J的配置和使用\n\n* 在日常开发过程中，排查问题时难免需要输出 MyBatis 真正执行的 SQL 语句、参数、结果等信息，我们就可以借助 LOG4J 的功能来实现执行信息的输出。\n\n* 使用步骤：\n\n  ![1590919638466](./img/java/mybatis/mybatis-第1天讲义.img/1590919638466.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',qt={data:function(){return{MainComponent:Lt}}},kt=qt,Bt=Object(d["a"])(kt,Ot,Pt,!1,null,"6cfc0ffb",null),_t=Bt.exports,Ft=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},Ht=[],Nt='\x3c!--\n * @Date           : 2021-04-14 00:54:32\n * @FilePath       : /jinnian-space/src/pages/java/module/mybatis/md/mybatis-第2天讲义.md\n * @Description    : \n--\x3e\n## Mybatis 进阶\n\n\n### 一.接口代理方式实现Dao\n\n#### 1.1 代理开发方式介绍\n\n​\t采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是我们后面进入企业的主流。\n\nMapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。\n\nMapper 接口开发需要遵循以下规范：\n\n**1) Mapper.xml文件中的namespace与mapper接口的全限定名相同**\n\n**2) Mapper接口方法名和Mapper.xml中定义的每个statement的id相同**\n\n**3) Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同**\n\n**4) Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同**\n\n总结: \n\n接口开发的方式: 程序员只需定义接口,就可以对数据库进行操作,那么具体的对象怎么创建?\n\n1.程序员负责定义接口\n\n2.在操作数据库,mybatis框架根据接口,通过动态代理的方式生成代理对象,负责数据库的crud操作\n\n#### 1.2.编写StudentMapper接口\n\n![1590937589503](./img/java/mybatis/mybatis-第2天讲义.img/1590937589503.png)\n\n#### 1.3 测试代理方式\n\n```java\n public Student selectById(Integer id) {\n        Student stu = null;\n        SqlSession sqlSession = null;\n        InputStream is = null;\n        try{\n            //1.加载核心配置文件\n            is = Resources.getResourceAsStream("MyBatisConfig.xml");\n\n            //2.获取SqlSession工厂对象\n            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n\n            //3.通过工厂对象获取SqlSession对象\n            sqlSession = sqlSessionFactory.openSession(true);\n\n            //4.获取StudentMapper接口的实现类对象\n            StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); // StudentMapper mapper = new StudentMapperImpl();\n\n            //5.通过实现类对象调用方法，接收结果\n            stu = mapper.selectById(id);\n\n        } catch (Exception e) {\n\n        } finally {\n            //6.释放资源\n            if(sqlSession != null) {\n                sqlSession.close();\n            }\n            if(is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        //7.返回结果\n        return stu;\n    }\n```\n\n#### 1.4 源码分析\n\n* 分析动态代理对象如何生成的？ \n\n  通过动态代理开发模式，我们只编写一个接口，不写实现类，我们通过 getMapper() 方法最终获取到 org.apache.ibatis.binding.MapperProxy 代理对象，然后执行功能，而这个代理对象正是 MyBatis 使用了 JDK 的动态代理技术，帮助我们生成了代理实现类对象。从而可以进行相关持久化操作。 \n\n* 分析方法是如何执行的？\n\n   动态代理实现类对象在执行方法的时候最终调用了 mapperMethod.execute() 方法，这个方法中通过 switch 语句根据操作类型来判断是新增、修改、删除、查询操作，最后一步回到了 MyBatis 最原生的 SqlSession 方式来执行增删改查。    \n\n#### 1.5 知识小结\n\n 接口代理方式可以让我们只编写接口即可，而实现类对象由 MyBatis 生成。 \n\n 实现规则 ：\n\n1. 映射配置文件中的名称空间必须和 Dao 层接口的全类名相同。\n2. 映射配置文件中的增删改查标签的 id 属性必须和 Dao 层接口的方法名相同。 \n3. 映射配置文件中的增删改查标签的 parameterType 属性必须和 Dao 层接口方法的参数相同。 \n4. 映射配置文件中的增删改查标签的 resultType 属性必须和 Dao 层接口方法的返回值相同。 \n5. 获取动态代理对象 SqlSession 功能类中的 getMapper() 方法。    \n\n### 二. 动态sql语句\n\n#### 2.1 动态sql语句概述\n\n​\tMybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL是动态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。\n\n参考的官方文档，描述如下：\n\n![](img\\图片2.png)\n\n#### 2.2 动态 SQL  之<**if>** \n\n我们根据实体类的不同取值，使用不同的 SQL语句来进行查询。比如在 id如果不为空时可以根据id查询，如果username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。\n\n如下图：\n\n```xml\n<select id="findByCondition" parameterType="student" resultType="student">\n    select * from student\n    <where>\n        <if test="id!=0">\n            and id=#{id}\n        </if>\n        <if test="username!=null">\n            and username=#{username}\n        </if>\n    </where>\n</select>\n\n```\n\n当查询条件id和username都存在时，控制台打印的sql语句如下：\n\n```java\n     … … …\n     //获得MyBatis框架生成的StudentMapper接口的实现类\n    StudentMapper mapper = sqlSession.getMapper( StudentMapper.class);\n    Student condition = new Student();\n    condition.setId(1);\n    condition.setUsername("lucy");\n    Student student = mapper.findByCondition(condition);\n    … … …\n```\n\n![1590936579118](./img/java/mybatis/mybatis-第2天讲义.img/1590936579118.png)\n\n\n\n当查询条件只有id存在时，控制台打印的sql语句如下：\n\n```java\n … … …\n //获得MyBatis框架生成的UserMapper接口的实现类\n StudentMapper mapper = sqlSession.getMapper( StudentMapper.class);\n    Student condition = new Student();\n    condition.setId(1);\n    Student student = mapper.findByCondition(condition);\n… … …\n\n```\n\n![1590936654661](./img/java/mybatis/mybatis-第2天讲义.img/1590936654661.png)\n\n总结语法:\n\n~~~xml\n<where>：条件标签。如果有动态条件，则使用该标签代替 where 关键字。\n<if>：条件判断标签。\n<if test=“条件判断”>\n\t查询条件拼接\n</if>\n~~~\n\n\n\n#### 2.3  动态 SQL  之<**foreach>** \n\n循环执行sql的拼接操作，例如：SELECT * FROM student  WHERE id IN (1,2,5)。\n\n ```xml\n<select id="findByIds" parameterType="list" resultType="student">\n    select * from student\n    <where>\n        <foreach collection="array" open="id in(" close=")" item="id" separator=",">\n            #{id}\n        </foreach>\n    </where>\n</select>\n ```\n\n测试代码片段如下：\n\n```java\n … … …\n //获得MyBatis框架生成的UserMapper接口的实现类\nStudentMapper mapper = sqlSession.getMapper(StudentMapper.class);\nint[] ids = new int[]{2,5};\nList<Student> sList = mapper.findByIds(ids);\nSystem.out.println(sList);\n… … …\n\n```\n\n总结语法:\n\n~~~xml\n<foreach>：循环遍历标签。适用于多个参数或者的关系。\n    <foreach collection=“”open=“”close=“”item=“”separator=“”>\n\t\t获取参数\n\t</foreach>\n~~~\n\n属性\ncollection：参数容器类型， (list-集合， array-数组)。\nopen：开始的 SQL 语句。\nclose：结束的 SQL 语句。\nitem：参数变量名。\nseparator：分隔符。\n\n#### 2.4  SQL片段抽取\n\nSql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的\n\n```xml\n\x3c!--抽取sql片段简化编写--\x3e\n<sql id="selectStudent" select * from student</sql>\n<select id="findById" parameterType="int" resultType="student">\n    <include refid="selectStudent"></include> where id=#{id}\n</select>\n<select id="findByIds" parameterType="list" resultType="student">\n    <include refid="selectStudent"></include>\n    <where>\n        <foreach collection="array" open="id in(" close=")" item="id" separator=",">\n            #{id}\n        </foreach>\n    </where>\n</select>\n```\n\n总结语法:\n\n我们可以将一些重复性的 SQL 语句进行抽取，以达到复用的效果。 \n\n~~~xml\n-  <sql>：抽取 SQL 语句标签。 \n-  <include>：引入 SQL 片段标签。 \n   <sql id=“片段唯一标识”>抽取的 SQL 语句</sql> <include refid=“片段唯一标识”/>\n \n~~~\n\n#### 2.5 知识小结\n\nMyBatis映射文件配置：\n\n~~~xml\n<select>：查询\n\n<insert>：插入\n\n<update>：修改\n\n<delete>：删除\n\n<where>：where条件\n\n<if>：if判断\n\n<foreach>：循环\n\n<sql>：sql片段抽取\n\n~~~\n\n\n\n### 三. 分页插件\n\n#### 3.1 分页插件介绍\n\n![1590937779260](./img/java/mybatis/mybatis-第2天讲义.img/1590937779260.png)\n\n* 分页可以将很多条结果进行分页显示。 \n*  如果当前在第一页，则没有上一页。如果当前在最后一页，则没有下一页。 \n*  需要明确当前是第几页，这一页中显示多少条结果。    \n* MyBatis分页插件总结\n  1. 在企业级开发中，分页也是一种常见的技术。而目前使用的 MyBatis 是不带分页功能的，如果想实现分页的 功能，需要我们手动编写 LIMIT 语句。但是不同的数据库实现分页的 SQL 语句也是不同的，所以手写分页 成本较高。这个时候就可以借助分页插件来帮助我们实现分页功能。 \n  2. PageHelper：第三方分页助手。将复杂的分页操作进行封装，从而让分页功能变得非常简单。    \n\n#### 3.2 分页插件的使用\n\nMyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封装，使用简单的方式即可获得分页的相关数据\n\n开发步骤：\n\n①导入与PageHelper的jar包\n\n②在mybatis核心配置文件中配置PageHelper插件\n\n~~~xml\n\x3c!-- 注意：分页助手的插件  配置在通用mapper之前 --\x3e\n<plugin interceptor="com.github.pagehelper.PageHelper">\n    \x3c!-- 指定方言 --\x3e\n    <property name="dialect" value="mysql"/>\n</plugin>\n~~~\n\n③测试分页数据获取\n\n~~~java\n@Test\npublic void testPageHelper(){\n    //设置分页参数\n    PageHelper.startPage(1,2);\n\n    List<User> select = userMapper2.select(null);\n    for(User user : select){\n        System.out.println(user);\n    }\n}\n~~~\n\n#### 3.3 分页插件的参数获取\n\n**获得分页相关的其他参数**：\n\n```java\n//其他分页的数据\nPageInfo<User> pageInfo = new PageInfo<User>(select);\nSystem.out.println("总条数："+pageInfo.getTotal());\nSystem.out.println("总页数："+pageInfo.getPages());\nSystem.out.println("当前页："+pageInfo.getPageNum());\nSystem.out.println("每页显示长度："+pageInfo.getPageSize());\nSystem.out.println("是否第一页："+pageInfo.isIsFirstPage());\nSystem.out.println("是否最后一页："+pageInfo.isIsLastPage());\n\n```\n\n#### 3.4  分页插件知识小结\n\n​    分页：可以将很多条结果进行分页显示。 \n\n* 分页插件 jar 包： pagehelper-5.1.10.jar jsqlparser-3.1.jar \n\n*  plugins：集成插件标签。 \n\n* 分页助手相关 API \n\n  ​    1.PageHelper：分页助手功能类。\n\n  2. startPage()：设置分页参数 \n  3. PageInfo：分页相关参数功能类。 \n  4. getTotal()：获取总条数 \n  5. getPages()：获取总页数\n  6.  getPageNum()：获取当前页\n  7.  getPageSize()：获取每页显示条数\n  8.  getPrePage()：获取上一页 \n  9. getNextPage()：获取下一页 \n  10. isIsFirstPage()：获取是否是第一页 \n  11. isIsLastPage()：获取是否是最后一页    \n\n### 四.MyBatis的多表操作\n\n#### 4.1 多表模型介绍\n\n我们之前学习的都是基于单表操作的，而实际开发中，随着业务难度的加深，肯定需要多表操作的。 \n\n*  多表模型分类 一对一：在任意一方建立外键，关联对方的主键。\n*  一对多：在多的一方建立外键，关联一的一方的主键。\n*  多对多：借助中间表，中间表至少两个字段，分别关联两张表的主键。    \n\n#### 4.2 多表模型一对一操作\n\n1. 一对一模型： 人和身份证，一个人只有一个身份证\n\n2. 代码实现\n\n   * 步骤一: sql语句准备\n\n     ~~~sql\n     CREATE TABLE person(\n     \tid INT PRIMARY KEY AUTO_INCREMENT,\n     \tNAME VARCHAR(20),\n     \tage INT\n     );\n     INSERT INTO person VALUES (NULL,\'张三\',23);\n     INSERT INTO person VALUES (NULL,\'李四\',24);\n     INSERT INTO person VALUES (NULL,\'王五\',25);\n     \n     CREATE TABLE card(\n     \tid INT PRIMARY KEY AUTO_INCREMENT,\n     \tnumber VARCHAR(30),\n     \tpid INT,\n     \tCONSTRAINT cp_fk FOREIGN KEY (pid) REFERENCES person(id)\n     );\n     INSERT INTO card VALUES (NULL,\'12345\',1);\n     INSERT INTO card VALUES (NULL,\'23456\',2);\n     INSERT INTO card VALUES (NULL,\'34567\',3);\n     ~~~\n\n   * 步骤二:配置文件\n\n     ~~~xml\n     <?xml version="1.0" encoding="UTF-8" ?>\n     <!DOCTYPE mapper\n             PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n             "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n     \n     <mapper namespace="com.itheima.table01.OneToOneMapper">\n         \x3c!--配置字段和实体对象属性的映射关系--\x3e\n         <resultMap id="oneToOne" type="card">\n             <id column="cid" property="id" />\n             <result column="number" property="number" />\n             \x3c!--\n                 association：配置被包含对象的映射关系\n                 property：被包含对象的变量名\n                 javaType：被包含对象的数据类型\n             --\x3e\n             <association property="p" javaType="person">\n                 <id column="pid" property="id" />\n                 <result column="name" property="name" />\n                 <result column="age" property="age" />\n             </association>\n         </resultMap>\n     \n         <select id="selectAll" resultMap="oneToOne">\n             SELECT c.id cid,number,pid,NAME,age FROM card c,person p WHERE c.pid=p.id\n         </select>\n     </mapper>\n     ~~~\n\n   * 步骤三：测试类\n\n     ~~~java\n      @Test\n         public void selectAll() throws Exception{\n             //1.加载核心配置文件\n             InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n     \n             //2.获取SqlSession工厂对象\n             SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n     \n             //3.通过工厂对象获取SqlSession对象\n             SqlSession sqlSession = sqlSessionFactory.openSession(true);\n     \n             //4.获取OneToOneMapper接口的实现类对象\n             OneToOneMapper mapper = sqlSession.getMapper(OneToOneMapper.class);\n     \n             //5.调用实现类的方法，接收结果\n             List<Card> list = mapper.selectAll();\n     \n             //6.处理结果\n             for (Card c : list) {\n                 System.out.println(c);\n             }\n     \n             //7.释放资源\n             sqlSession.close();\n             is.close();\n         }\n     ~~~\n\n   3.一对一配置总结:\n\n   ~~~xml-dtd\n   <resultMap>：配置字段和对象属性的映射关系标签。\n       id 属性：唯一标识\n       type 属性：实体对象类型\n   <id>：配置主键映射关系标签。\n   <result>：配置非主键映射关系标签。\n       column 属性：表中字段名称\n       property 属性： 实体对象变量名称\n   <association>：配置被包含对象的映射关系标签。\n       property 属性：被包含对象的变量名\n       javaType 属性：被包含对象的数据类型\n   ~~~\n\n   \n\n#### 4.3 多表模型一对多操作\n\n1. 一对多模型： 一对多模型：班级和学生，一个班级可以有多个学生。    \n\n2. 代码实现\n\n   - 步骤一: sql语句准备\n\n     ```sql\n     CREATE TABLE classes(\n     \tid INT PRIMARY KEY AUTO_INCREMENT,\n     \tNAME VARCHAR(20)\n     );\n     INSERT INTO classes VALUES (NULL,\'黑马一班\');\n     INSERT INTO classes VALUES (NULL,\'黑马二班\');\n     \n     \n     CREATE TABLE student(\n     \tid INT PRIMARY KEY AUTO_INCREMENT,\n     \tNAME VARCHAR(30),\n     \tage INT,\n     \tcid INT,\n     \tCONSTRAINT cs_fk FOREIGN KEY (cid) REFERENCES classes(id)\n     );\n     INSERT INTO student VALUES (NULL,\'张三\',23,1);\n     INSERT INTO student VALUES (NULL,\'李四\',24,1);\n     INSERT INTO student VALUES (NULL,\'王五\',25,2);\n     INSERT INTO student VALUES (NULL,\'赵六\',26,2);\n     ```\n\n   - 步骤二:配置文件\n\n     ```xml\n     <mapper namespace="com.itheima.table02.OneToManyMapper">\n         <resultMap id="oneToMany" type="classes">\n             <id column="cid" property="id"/>\n             <result column="cname" property="name"/>\n     \n             \x3c!--\n                 collection：配置被包含的集合对象映射关系\n                 property：被包含对象的变量名\n                 ofType：被包含对象的实际数据类型\n             --\x3e\n             <collection property="students" ofType="student">\n                 <id column="sid" property="id"/>\n                 <result column="sname" property="name"/>\n                 <result column="sage" property="age"/>\n             </collection>\n         </resultMap>\n         <select id="selectAll" resultMap="oneToMany">\n             SELECT c.id cid,c.name cname,s.id sid,s.name sname,s.age sage FROM classes c,student s WHERE c.id=s.cid\n         </select>\n     </mapper>\n     ```\n\n   - 步骤三：测试类\n\n     ```java\n         @Test\n         public void selectAll() throws Exception{\n             //1.加载核心配置文件\n             InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n     \n             //2.获取SqlSession工厂对象\n             SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n     \n             //3.通过工厂对象获取SqlSession对象\n             SqlSession sqlSession = sqlSessionFactory.openSession(true);\n     \n             //4.获取OneToManyMapper接口的实现类对象\n             OneToManyMapper mapper = sqlSession.getMapper(OneToManyMapper.class);\n     \n             //5.调用实现类的方法，接收结果\n             List<Classes> classes = mapper.selectAll();\n     \n             //6.处理结果\n             for (Classes cls : classes) {\n                 System.out.println(cls.getId() + "," + cls.getName());\n                 List<Student> students = cls.getStudents();\n                 for (Student student : students) {\n                     System.out.println("\\t" + student);\n                 }\n             }\n     \n             //7.释放资源\n             sqlSession.close();\n             is.close();\n         }\n     ```\n\n   3.一对多配置文件总结：\n\n   ~~~xml-dtd\n   <resultMap>：配置字段和对象属性的映射关系标签。\n       id 属性：唯一标识\n       type 属性：实体对象类型\n   <id>：配置主键映射关系标签。\n   <result>：配置非主键映射关系标签。\n       column 属性：表中字段名称\n       property 属性： 实体对象变量名称\n   <collection>：配置被包含集合对象的映射关系标签。\n       property 属性：被包含集合对象的变量名\n       ofType 属性：集合中保存的对象数据类型\n   ~~~\n\n    \n\n#### 4.4 多表模型多对多操作\n\n1. 多对多模型：学生和课程，一个学生可以选择多门课程、一个课程也可以被多个学生所选择。       \n\n2. 代码实现\n\n   - 步骤一: sql语句准备\n\n     ```sql\n     CREATE TABLE course(\n     \tid INT PRIMARY KEY AUTO_INCREMENT,\n     \tNAME VARCHAR(20)\n     );\n     INSERT INTO course VALUES (NULL,\'语文\');\n     INSERT INTO course VALUES (NULL,\'数学\');\n     \n     \n     CREATE TABLE stu_cr(\n     \tid INT PRIMARY KEY AUTO_INCREMENT,\n     \tsid INT,\n     \tcid INT,\n     \tCONSTRAINT sc_fk1 FOREIGN KEY (sid) REFERENCES student(id),\n     \tCONSTRAINT sc_fk2 FOREIGN KEY (cid) REFERENCES course(id)\n     );\n     INSERT INTO stu_cr VALUES (NULL,1,1);\n     INSERT INTO stu_cr VALUES (NULL,1,2);\n     INSERT INTO stu_cr VALUES (NULL,2,1);\n     INSERT INTO stu_cr VALUES (NULL,2,2);\n     ```\n\n   - 步骤二:配置文件\n\n     ```xml\n     <?xml version="1.0" encoding="UTF-8" ?>\n     <!DOCTYPE mapper\n             PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n             "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n     \n     <mapper namespace="com.itheima.table03.ManyToManyMapper">\n         <resultMap id="manyToMany" type="student">\n             <id column="sid" property="id"/>\n             <result column="sname" property="name"/>\n             <result column="sage" property="age"/>\n     \n             <collection property="courses" ofType="course">\n                 <id column="cid" property="id"/>\n                 <result column="cname" property="name"/>\n             </collection>\n         </resultMap>\n         <select id="selectAll" resultMap="manyToMany">\n             SELECT sc.sid,s.name sname,s.age sage,sc.cid,c.name cname FROM student s,course c,stu_cr sc WHERE sc.sid=s.id AND sc.cid=c.id\n         </select>\n     </mapper>\n     ```\n\n   - 步骤三：测试类\n\n     ```java\n      @Test\n         public void selectAll() throws Exception{\n             //1.加载核心配置文件\n             InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n     \n             //2.获取SqlSession工厂对象\n             SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n     \n             //3.通过工厂对象获取SqlSession对象\n             SqlSession sqlSession = sqlSessionFactory.openSession(true);\n     \n             //4.获取ManyToManyMapper接口的实现类对象\n             ManyToManyMapper mapper = sqlSession.getMapper(ManyToManyMapper.class);\n     \n             //5.调用实现类的方法，接收结果\n             List<Student> students = mapper.selectAll();\n     \n             //6.处理结果\n             for (Student student : students) {\n                 System.out.println(student.getId() + "," + student.getName() + "," + student.getAge());\n                 List<Course> courses = student.getCourses();\n                 for (Course cours : courses) {\n                     System.out.println("\\t" + cours);\n                 }\n             }\n     \n             //7.释放资源\n             sqlSession.close();\n             is.close();\n         }\n         \n     ```\n\n   3.多对多配置文件总结：\n\n   ```xml-dtd\n   <resultMap>：配置字段和对象属性的映射关系标签。\n   \tid 属性：唯一标识\n   \ttype 属性：实体对象类型\n    <id>：配置主键映射关系标签。\n    <result>：配置非主键映射关系标签。\n   \tcolumn 属性：表中字段名称\n   \tproperty 属性： 实体对象变量名称\n   <collection>：配置被包含集合对象的映射关系标签。\n   \tproperty 属性：被包含集合对象的变量名\n   \tofType 属性：集合中保存的对象数据类型\n   ```\n\n    \n\n#### 4.5 多表模型操作总结\n\n~~~xml-dtd\n <resultMap>：配置字段和对象属性的映射关系标签。\n    id 属性：唯一标识\n    type 属性：实体对象类型\n<id>：配置主键映射关系标签。\n<result>：配置非主键映射关系标签。\n\tcolumn 属性：表中字段名称\n\tproperty 属性： 实体对象变量名称\n<association>：配置被包含对象的映射关系标签。\n\tproperty 属性：被包含对象的变量名\n\tjavaType 属性：被包含对象的数据类型\n<collection>：配置被包含集合对象的映射关系标签。\n\tproperty 属性：被包含集合对象的变量名\n\tofType 属性：集合中保存的对象数据类型\n~~~\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n##### \n\n\n\n',Jt={data:function(){return{MainComponent:Nt}}},Ut=Jt,Gt=Object(d["a"])(Ut,Ft,Ht,!1,null,"d167a30e",null),Vt=Gt.exports,zt=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},Wt=[],Qt='\x3c!--\n * @Date           : 2021-04-14 00:54:56\n * @FilePath       : /jinnian-space/src/pages/java/module/mybatis/md/mybatis-第3天讲义.md\n * @Description    : \n--\x3e\n## Mybatis 高级\n\n\n### 一.Mybatis注解开发单表操作\n\n#### 1.1 MyBatis的常用注解 \n\n这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样我们就可以减少编写Mapper\n\n映射文件了。我们先围绕一些基本的CRUD来学习，再学习复杂映射多表操作。\n\n@Insert：实现新增\n\n@Update：实现更新\n\n@Delete：实现删除\n\n@Select：实现查询\n\n@Result：实现结果集封装\n\n@Results：可以与@Result 一起使用，封装多个结果集\n\n@One：实现一对一结果集封装\n\n@Many：实现一对多结果集封装\n\n#### 1.2 MyBatis的增删改查 \n\n我们完成简单的student表的增删改查的操作\n\n* 步骤一:创建mapper接口\n\n  ~~~java\n  public interface StudentMapper {\n      //查询全部\n      @Select("SELECT * FROM student")\n      public abstract List<Student> selectAll();\n  \n      //新增操作\n      @Insert("INSERT INTO student VALUES (#{id},#{name},#{age})")\n      public abstract Integer insert(Student stu);\n  \n      //修改操作\n      @Update("UPDATE student SET name=#{name},age=#{age} WHERE id=#{id}")\n      public abstract Integer update(Student stu);\n  \n      //删除操作\n      @Delete("DELETE FROM student WHERE id=#{id}")\n      public abstract Integer delete(Integer id);\n  }\n  \n  ~~~\n\n* 步骤二：测试类\n\n  ~~~java\n  public class Test01 {\n      @Test\n      public void selectAll() throws Exception{\n          //1.加载核心配置文件\n          InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n  \n          //2.获取SqlSession工厂对象\n          SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n  \n          //3.通过工厂对象获取SqlSession对象\n          SqlSession sqlSession = sqlSessionFactory.openSession(true);\n  \n          //4.获取StudentMapper接口的实现类对象\n          StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);\n  \n          //5.调用实现类对象中的方法，接收结果\n          List<Student> list = mapper.selectAll();\n  \n          //6.处理结果\n          for (Student student : list) {\n              System.out.println(student);\n          }\n  \n          //7.释放资源\n          sqlSession.close();\n          is.close();\n      }\n  \n      @Test\n      public void insert() throws Exception{\n          //1.加载核心配置文件\n          InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n  \n          //2.获取SqlSession工厂对象\n          SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n  \n          //3.通过工厂对象获取SqlSession对象\n          SqlSession sqlSession = sqlSessionFactory.openSession(true);\n  \n          //4.获取StudentMapper接口的实现类对象\n          StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);\n  \n          //5.调用实现类对象中的方法，接收结果\n          Student stu = new Student(4,"赵六",26);\n          Integer result = mapper.insert(stu);\n  \n          //6.处理结果\n          System.out.println(result);\n  \n          //7.释放资源\n          sqlSession.close();\n          is.close();\n      }\n  \n      @Test\n      public void update() throws Exception{\n          //1.加载核心配置文件\n          InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n  \n          //2.获取SqlSession工厂对象\n          SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n  \n          //3.通过工厂对象获取SqlSession对象\n          SqlSession sqlSession = sqlSessionFactory.openSession(true);\n  \n          //4.获取StudentMapper接口的实现类对象\n          StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);\n  \n          //5.调用实现类对象中的方法，接收结果\n          Student stu = new Student(4,"赵六",36);\n          Integer result = mapper.update(stu);\n  \n          //6.处理结果\n          System.out.println(result);\n  \n          //7.释放资源\n          sqlSession.close();\n          is.close();\n      }\n  \n      @Test\n      public void delete() throws Exception{\n          //1.加载核心配置文件\n          InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n  \n          //2.获取SqlSession工厂对象\n          SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n  \n          //3.通过工厂对象获取SqlSession对象\n          SqlSession sqlSession = sqlSessionFactory.openSession(true);\n  \n          //4.获取StudentMapper接口的实现类对象\n          StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);\n  \n          //5.调用实现类对象中的方法，接收结果\n          Integer result = mapper.delete(4);\n  \n          //6.处理结果\n          System.out.println(result);\n  \n          //7.释放资源\n          sqlSession.close();\n          is.close();\n      }\n  }\n  \n  ~~~\n\n* 注意：\n\n  修改MyBatis的核心配置文件，我们使用了注解替代的映射文件，所以我们只需要加载使用了注解的Mapper接口即可\n\n```xml\n<mappers>\n    \x3c!--扫描使用注解的类--\x3e\n    <mapper class="com.itheima.mapper.UserMapper"></mapper>\n</mappers>\n```\n\n​\t或者指定扫描包含映射关系的接口所在的包也可以\n\n```xml\n<mappers>\n    \x3c!--扫描使用注解的类所在的包--\x3e\n    <package name="com.itheima.mapper"></package>\n</mappers>\n```\n\n#### 1.3 注解开发总结\n\n注解可以简化开发操作，省略映射配置文件的编写。 \n\n* 常用注解 \n\n  @Select(“查询的 SQL 语句”)：执行查询操作注解\n\n   @Insert(“查询的 SQL 语句”)：执行新增操作注解\n\n   @Update(“查询的 SQL 语句”)：执行修改操作注解\n\n   @Delete(“查询的 SQL 语句”)：执行删除操作注解 \n\n* 配置映射关系 \n\n  ~~~xml\n  <mappers> <package name="接口所在包"/> </mappers>    \n  ~~~\n\n  \n\n### 二.MyBatis注解开发的多表操作\n\n#### 2.1  MyBatis的注解实现复杂映射开发\n\n实现复杂关系映射之前我们可以在映射文件中通过配置<resultMap>来实现，使用注解开发后，我们可以使用@Results注解，@Result注解，@One注解，@Many注解组合完成复杂关系的配置\n\n![](img\\图片10.png)\n\n![](img\\图片11.png)\n\n#### 2.2  一对一查询\n\n##### 2.2.1 一对一查询的模型\n\n一对一查询的需求：查询一个用户信息，与此同时查询出该用户对应的身份证信息\n\n![1590942011460](./img/java/mybatis/mybatis-第3天讲义.img/1590942011460.png)\n\n##### 2.2.2 一对一查询的语句\n\n对应的sql语句：\n\n```sql\nSELECT * FROM card；\n\nSELECT * FROM person WHERE id=#{id};\n```\n\n##### \n\n##### 2.2.3 创建PersonMapper接口\n\n```java\npublic interface PersonMapper {\n    //根据id查询\n    @Select("SELECT * FROM person WHERE id=#{id}")\n    public abstract Person selectById(Integer id);\n}\n\n```\n\n##### 2.2.4 使用注解配置Mapper\n\n```java\npublic interface CardMapper {\n    //查询全部\n    @Select("SELECT * FROM card")\n    @Results({\n            @Result(column = "id",property = "id"),\n            @Result(column = "number",property = "number"),\n            @Result(\n                    property = "p",             // 被包含对象的变量名\n                    javaType = Person.class,    // 被包含对象的实际数据类型\n                    column = "pid",             // 根据查询出的card表中的pid字段来查询person表\n                    /*\n                        one、@One 一对一固定写法\n                        select属性：指定调用哪个接口中的哪个方法\n                     */\n                    one = @One(select = "com.itheima.one_to_one.PersonMapper.selectById")\n            )\n    })\n    public abstract List<Card> selectAll();\n}\n```\n\n##### 2.2.5 测试类\n\n```java\npublic class Test01 {\n    @Test\n    public void selectAll() throws Exception{\n        //1.加载核心配置文件\n        InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n\n        //2.获取SqlSession工厂对象\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n\n        //3.通过工厂对象获取SqlSession对象\n        SqlSession sqlSession = sqlSessionFactory.openSession(true);\n\n        //4.获取CardMapper接口的实现类对象\n        CardMapper mapper = sqlSession.getMapper(CardMapper.class);\n\n        //5.调用实现类对象中的方法，接收结果\n        List<Card> list = mapper.selectAll();\n\n        //6.处理结果\n        for (Card card : list) {\n            System.out.println(card);\n        }\n\n        //7.释放资源\n        sqlSession.close();\n        is.close();\n    }\n\n}\n\n```\n\n##### 2.2.6  一对一配置总结\n\n~~~xml-dtd\n@Results：封装映射关系的父注解。\n\tResult[] value()：定义了 Result 数组\n@Result：封装映射关系的子注解。\n\tcolumn 属性：查询出的表中字段名称\n\tproperty 属性：实体对象中的属性名称\n\tjavaType 属性：被包含对象的数据类型\n\tone 属性：一对一查询固定属性\n @One：一对一查询的注解。\n\tselect 属性：指定调用某个接口中的方法\n~~~\n\n\n\n#### 2.3 一对多查询\n\n##### 2.3.1 一对多查询的模型\n\n一对多查询的需求：查询一个课程，与此同时查询出该该课程对应的学生信息\n\n![1590942772892](./img/java/mybatis/mybatis-第3天讲义.img/1590942772892.png)\n\n##### 2.3.2 一对多查询的语句\n\n对应的sql语句：\n\n```sql\nSELECT * FROM classes\n\nSELECT * FROM student WHERE cid=#{cid}\n```\n\n##### \n\n##### 2.3.3 创建StudentMapper接口\n\n```java\npublic interface StudentMapper {\n    //根据cid查询student表\n    @Select("SELECT * FROM student WHERE cid=#{cid}")\n    public abstract List<Student> selectByCid(Integer cid);\n}\n\n```\n\n##### 2.3.4 使用注解配置Mapper\n\n```java\npublic interface ClassesMapper {\n    //查询全部\n    @Select("SELECT * FROM classes")\n    @Results({\n            @Result(column = "id",property = "id"),\n            @Result(column = "name",property = "name"),\n            @Result(\n                    property = "students",  // 被包含对象的变量名\n                    javaType = List.class,  // 被包含对象的实际数据类型\n                    column = "id",          // 根据查询出的classes表的id字段来查询student表\n                    /*\n                        many、@Many 一对多查询的固定写法\n                        select属性：指定调用哪个接口中的哪个查询方法\n                     */\n                    many = @Many(select = "com.itheima.one_to_many.StudentMapper.selectByCid")\n            )\n    })\n    public abstract List<Classes> selectAll();\n}\n```\n\n##### 2.3.5 测试类\n\n```java\npublic class Test01 {\n    @Test\n    public void selectAll() throws Exception{\n        //1.加载核心配置文件\n        InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n\n        //2.获取SqlSession工厂对象\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n\n        //3.通过工厂对象获取SqlSession对象\n        SqlSession sqlSession = sqlSessionFactory.openSession(true);\n\n        //4.获取ClassesMapper接口的实现类对象\n        ClassesMapper mapper = sqlSession.getMapper(ClassesMapper.class);\n\n        //5.调用实现类对象中的方法，接收结果\n        List<Classes> list = mapper.selectAll();\n\n        //6.处理结果\n        for (Classes cls : list) {\n            System.out.println(cls.getId() + "," + cls.getName());\n            List<Student> students = cls.getStudents();\n            for (Student student : students) {\n                System.out.println("\\t" + student);\n            }\n        }\n\n        //7.释放资源\n        sqlSession.close();\n        is.close();\n    }\n\n}\n\n```\n\n##### 2.3.6 一对多配置总结\n\n~~~xml-dtd\n@Results：封装映射关系的父注解。\n\tResult[] value()：定义了 Result 数组\n@Result：封装映射关系的子注解。\n\tcolumn 属性：查询出的表中字段名称\n\tproperty 属性：实体对象中的属性名称\n\tjavaType 属性：被包含对象的数据类型\n\tmany 属性：一对多查询固定属性\n@Many：一对多查询的注解。\n\tselect 属性：指定调用某个接口中的方法\n~~~\n\n\n\n#### 2.4  多对多查询\n\n##### 2.4.1 多对多查询的模型\n\n多对多查询的需求：查询学生以及所对应的课程信息\n\n![1590943489827](./img/java/mybatis/mybatis-第3天讲义.img/1590943489827.png)\n\n##### 2.4.2 多对多查询的语句\n\n对应的sql语句：\n\n```sql\nSELECT DISTINCT s.id,s.name,s.age FROM student s,stu_cr sc WHERE sc.sid=s.id\nSELECT c.id,c.name FROM stu_cr sc,course c WHERE sc.cid=c.id AND sc.sid=#{id}\n```\n\n\n\n##### 2.4.3  添加CourseMapper 接口方法\n\n```java\npublic interface CourseMapper {\n    //根据学生id查询所选课程\n    @Select("SELECT c.id,c.name FROM stu_cr sc,course c WHERE sc.cid=c.id AND sc.sid=#{id}")\n    public abstract List<Course> selectBySid(Integer id);\n}\n\n```\n\n##### 2.4.4 使用注解配置Mapper\n\n```java\npublic interface StudentMapper {\n    //查询全部\n    @Select("SELECT DISTINCT s.id,s.name,s.age FROM student s,stu_cr sc WHERE sc.sid=s.id")\n    @Results({\n            @Result(column = "id",property = "id"),\n            @Result(column = "name",property = "name"),\n            @Result(column = "age",property = "age"),\n            @Result(\n                    property = "courses",   // 被包含对象的变量名\n                    javaType = List.class,  // 被包含对象的实际数据类型\n                    column = "id",          // 根据查询出student表的id来作为关联条件，去查询中间表和课程表\n                    /*\n                        many、@Many 一对多查询的固定写法\n                        select属性：指定调用哪个接口中的哪个查询方法\n                     */\n                    many = @Many(select = "com.itheima.many_to_many.CourseMapper.selectBySid")\n            )\n    })\n    public abstract List<Student> selectAll();\n}\n\n```\n\n##### 2.4.5 测试类\n\n```java\npublic class Test01 {\n    @Test\n    public void selectAll() throws Exception{\n        //1.加载核心配置文件\n        InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n\n        //2.获取SqlSession工厂对象\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n\n        //3.通过工厂对象获取SqlSession对象\n        SqlSession sqlSession = sqlSessionFactory.openSession(true);\n\n        //4.获取StudentMapper接口的实现类对象\n        StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);\n\n        //5.调用实现类对象中的方法，接收结果\n        List<Student> list = mapper.selectAll();\n\n        //6.处理结果\n        for (Student student : list) {\n            System.out.println(student.getId() + "," + student.getName() + "," + student.getAge());\n            List<Course> courses = student.getCourses();\n            for (Course cours : courses) {\n                System.out.println("\\t" + cours);\n            }\n        }\n\n        //7.释放资源\n        sqlSession.close();\n        is.close();\n    }\n\n}\n```\n\n##### 2.4.6 多对多配置总结\n\n~~~xml-dtd\n@Results：封装映射关系的父注解。\n\tResult[] value()：定义了 Result 数组\n@Result：封装映射关系的子注解。\n\tcolumn 属性：查询出的表中字段名称\n\tproperty 属性：实体对象中的属性名称\n\tjavaType 属性：被包含对象的数据类型\n\tmany 属性：一对多查询固定属性\n@Many：一对多查询的注解。\n\tselect 属性：指定调用某个接口中的方法\n~~~\n\n\n\n### 三.构建sql\n\n#### 3.1 SQL 构建对象介绍    \n\n* 我们之前通过注解开发时，相关 SQL 语句都是自己直接拼写的。一些关键字写起来比较麻烦、而且容易出错。 \n*  MyBatis 给我们提供了 org.apache.ibatis.jdbc.SQL 功能类，专门用于构建 SQL 语句  \n*  org.apache.ibatis.jdbc.SQL      -     org.apache.ibatis.AbstractSQL  \n\n\n* ![1590943921472](./img/java/mybatis/mybatis-第3天讲义.img/1590943921472.png)\n\n#### 3.2  查询功能的实现\n\n* 定义功能类并提供获取查询的 SQL 语句的方法。 \n\n* @SelectProvider：生成查询用的 SQL 语句注解。\n\n   type 属性：生成 SQL 语句功能类对象 \n\n   method 属性：指定调用方法    \n\n#### 3.3  新增功能的实现\n\n* 定义功能类并提供获取新增的 SQL 语句的方法。 \n\n* @InsertProvider：生成新增用的 SQL 语句注解。 \n\n  type 属性：生成 SQL 语句功能类对象 \n\n  method 属性：指定调用方法    \n\n#### 3.4  修改功能的实现\n\n* 定义功能类并提供获取修改的 SQL 语句的方法。 \n\n*  @UpdateProvider：生成修改用的 SQL 语句注解。 \n\n   type 属性：生成 SQL 语句功能类对象\n\n   method 属性：指定调用方法    \n\n#### 3.5  删除功能的实现\n\n* 定义功能类并提供获取删除的 SQL 语句的方法。 \n\n*  @DeleteProvider：生成删除用的 SQL 语句注解。\n\n   type 属性：生成 SQL 语句功能类对象 \n\n   method 属性：指定调用方法   \n\n ####  3.6  定义sql 语句 ReturnSql.java\n ```java\npackage com.itheima.sql;\n\nimport com.itheima.bean.Student;\nimport org.apache.ibatis.jdbc.SQL;\n\npublic class ReturnSql {\n    //定义方法，返回查询的sql语句\n    public String getSelectAll() {\n        return new SQL() {\n            {\n                SELECT("*");\n                FROM("student");\n            }\n        }.toString();\n    }\n\n    //定义方法，返回新增的sql语句\n    public String getInsert(Student stu) {\n        return new SQL() {\n            {\n                INSERT_INTO("student");\n                INTO_VALUES("#{id},#{name},#{age}");\n            }\n        }.toString();\n    }\n\n    //定义方法，返回修改的sql语句\n    public String getUpdate(Student stu) {\n        return new SQL() {\n            {\n                UPDATE("student");\n                SET("name=#{name}","age=#{age}");\n                WHERE("id=#{id}");\n            }\n        }.toString();\n    }\n\n    //定义方法，返回删除的sql语句\n    public String getDelete(Integer id) {\n        return new SQL() {\n            {\n                DELETE_FROM("student");\n                WHERE("id=#{id}");\n            }\n        }.toString();\n    }\n}\n ```\n\n ####  3.7 使用 sql 语句 StudentMapper.java\n ```java\npackage com.itheima.mapper;\n\nimport com.itheima.bean.Student;\nimport com.itheima.sql.ReturnSql;\nimport org.apache.ibatis.annotations.DeleteProvider;\nimport org.apache.ibatis.annotations.InsertProvider;\nimport org.apache.ibatis.annotations.SelectProvider;\nimport org.apache.ibatis.annotations.UpdateProvider;\n\nimport java.util.List;\n\npublic interface StudentMapper {\n    //查询全部\n    //@Select("SELECT * FROM student")\n    @SelectProvider(type = ReturnSql.class , method = "getSelectAll")\n    public abstract List<Student> selectAll();\n\n    //新增功能\n    //@Insert("INSERT INTO student VALUES (#{id},#{name},#{age})")\n    @InsertProvider(type = ReturnSql.class , method = "getInsert")\n    public abstract Integer insert(Student stu);\n\n    //修改功能\n    //@Update("UPDATE student SET name=#{name},age=#{age} WHERE id=#{id}")\n    @UpdateProvider(type = ReturnSql.class , method = "getUpdate")\n    public abstract Integer update(Student stu);\n\n    //删除功能\n    //@Delete("DELETE FROM student WHERE id=#{id}")\n    @DeleteProvider(type = ReturnSql.class , method = "getDelete")\n    public abstract Integer delete(Integer id);\n}\n\n\n ```\n\n ####  3.8 测试\n ```java\n   @Test\n    public void selectAll() throws Exception{\n        //1.加载核心配置文件\n        InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n\n        //2.获取SqlSession工厂对象\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n\n        //3.通过工厂对象获取SqlSession对象\n        SqlSession sqlSession = sqlSessionFactory.openSession(true);\n\n        //4.获取StudentMapper接口的实现类对象\n        StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);\n\n        //5.调用实现类对象中的方法，接收结果\n        List<Student> list = mapper.selectAll();\n\n        //6.处理结果\n        for (Student student : list) {\n            System.out.println(student);\n        }\n\n        //7.释放资源\n        sqlSession.close();\n        is.close();\n    }\n\n ```\n\n### 四.综合案例\n\n#### 4.1  系统介绍\n\n​         我们之前在做学生管理系统时，使用的是原始JDBC操作数据库的，操作非常麻烦，现在我们使用MyBatis操作数据库，简化Dao的开发。\n\n#### 4.2  环境搭建（略）\n\n#### 4.3  代码改造\n\n* 步骤一：新增MyBatis配置文件 `MyBatisConfig.xml`\n\n  ~~~xml\n  <?xml version="1.0" encoding="UTF-8" ?>\n  \x3c!--MyBatis的DTD约束--\x3e\n  <!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">\n  \n  \x3c!--configuration 核心根标签--\x3e\n  <configuration>\n  \n      \x3c!--引入数据库连接的配置文件--\x3e\n      <properties resource="config.properties"/>\n  \n      \x3c!--配置LOG4J--\x3e\n      <settings>\n          <setting name="logImpl" value="log4j"/>\n      </settings>\n  \n      \x3c!--environments配置数据库环境，环境可以有多个。default属性指定使用的是哪个--\x3e\n      <environments default="mysql">\n          \x3c!--environment配置数据库环境  id属性唯一标识--\x3e\n          <environment id="mysql">\n              \x3c!-- transactionManager事务管理。  type属性，采用JDBC默认的事务--\x3e\n              <transactionManager type="JDBC"></transactionManager>\n              \x3c!-- dataSource数据源信息   type属性 连接池--\x3e\n              <dataSource type="POOLED">\n                  \x3c!-- property获取数据库连接的配置信息 --\x3e\n                  <property name="driver" value="${driver}" />\n                  <property name="url" value="${url}" />\n                  <property name="username" value="${username}" />\n                  <property name="password" value="${password}" />\n              </dataSource>\n          </environment>\n      </environments>\n  \n      \x3c!--配置映射关系--\x3e\n      <mappers>\n          <package name="com.itheima"/>\n      </mappers>\n  </configuration>\n  \n  ~~~\n\n* 步骤二: 删除`StudentDaoImpl`，修改`StudentDao`\n\n  ```java\n  package com.itheima.dao;\n  \n  import com.itheima.domain.Student;\n  import org.apache.ibatis.annotations.Delete;\n  import org.apache.ibatis.annotations.Insert;\n  import org.apache.ibatis.annotations.Select;\n  import org.apache.ibatis.annotations.Update;\n  \n  import java.util.ArrayList;\n  \n  /*\n      Dao层接口\n   */\n  public interface StudentDao {\n      //查询所有学生信息\n      @Select("SELECT * FROM student")\n      public abstract ArrayList<Student> findAll();\n  \n      //条件查询，根据id获取学生信息\n      @Select("SELECT * FROM student WHERE sid=#{sid}")\n      public abstract Student findById(Integer sid);\n  \n      //新增学生信息\n      @Insert("INSERT INTO student VALUES (#{sid},#{name},#{age},#{birthday})")\n      public abstract int insert(Student stu);\n  \n      //修改学生信息\n      @Update("UPDATE student SET name=#{name},age=#{age},birthday=#{birthday} WHERE sid=#{sid}")\n      public abstract int update(Student stu);\n  \n      //删除学生信息\n      @Delete("DELETE FROM student WHERE sid=#{sid}")\n      public abstract int delete(Integer sid);\n  }\n  \n  ```\n  \n  \n  \n* 步骤三：修改`StudentServiceImpl`\n\n  ```java\n  package com.itheima.service.impl;\n  \n  import com.itheima.dao.StudentDao;\n  import com.itheima.domain.Student;\n  import com.itheima.service.StudentService;\n  import org.apache.ibatis.io.Resources;\n  import org.apache.ibatis.session.SqlSession;\n  import org.apache.ibatis.session.SqlSessionFactory;\n  import org.apache.ibatis.session.SqlSessionFactoryBuilder;\n  \n  import java.io.IOException;\n  import java.io.InputStream;\n  import java.util.ArrayList;\n  import java.util.List;\n  \n  /**\n   * 学生的业务层实现类\n   * @author 黑马程序员\n   * @Company http://www.itheima.com\n   */\n  public class StudentServiceImpl implements StudentService {\n  \n      @Override\n      public List<Student> findAll() {\n          ArrayList<Student> list = null;\n          SqlSession sqlSession = null;\n          InputStream is = null;\n          try{\n              //1.加载核心配置文件\n              is = Resources.getResourceAsStream("MyBatisConfig.xml");\n  \n              //2.获取SqlSession工厂对象\n              SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n  \n              //3.通过工厂对象获取SqlSession对象\n              sqlSession = sqlSessionFactory.openSession(true);\n  \n              //4.获取StudentDao接口的实现类对象\n              StudentDao mapper = sqlSession.getMapper(StudentDao.class);\n  \n              //5.调用实现类对象的方法，接收结果\n              list = mapper.findAll();\n  \n          } catch (Exception e) {\n              e.printStackTrace();\n          } finally {\n              //6.释放资源\n              if(sqlSession != null) {\n                  sqlSession.close();\n              }\n              if(is != null) {\n                  try {\n                      is.close();\n                  } catch (IOException e) {\n                      e.printStackTrace();\n                  }\n              }\n          }\n  \n          //7.返回结果\n          return list;\n      }\n  \n      @Override\n      public Student findById(Integer sid) {\n          Student stu = null;\n          SqlSession sqlSession = null;\n          InputStream is = null;\n          try{\n              //1.加载核心配置文件\n              is = Resources.getResourceAsStream("MyBatisConfig.xml");\n  \n              //2.获取SqlSession工厂对象\n              SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n  \n              //3.通过工厂对象获取SqlSession对象\n              sqlSession = sqlSessionFactory.openSession(true);\n  \n              //4.获取StudentDao接口的实现类对象\n              StudentDao mapper = sqlSession.getMapper(StudentDao.class);\n  \n              //5.调用实现类对象的方法，接收结果\n              stu = mapper.findById(sid);\n  \n          } catch (Exception e) {\n              e.printStackTrace();\n          } finally {\n              //6.释放资源\n              if(sqlSession != null) {\n                  sqlSession.close();\n              }\n              if(is != null) {\n                  try {\n                      is.close();\n                  } catch (IOException e) {\n                      e.printStackTrace();\n                  }\n              }\n          }\n  \n          //7.返回结果\n          return stu;\n      }\n  \n      @Override\n      public void save(Student student) {\n          SqlSession sqlSession = null;\n          InputStream is = null;\n          try{\n              //1.加载核心配置文件\n              is = Resources.getResourceAsStream("MyBatisConfig.xml");\n  \n              //2.获取SqlSession工厂对象\n              SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n  \n              //3.通过工厂对象获取SqlSession对象\n              sqlSession = sqlSessionFactory.openSession(true);\n  \n              //4.获取StudentDao接口的实现类对象\n              StudentDao mapper = sqlSession.getMapper(StudentDao.class);\n  \n              //5.调用实现类对象的方法，接收结果\n              mapper.insert(student);\n  \n          } catch (Exception e) {\n              e.printStackTrace();\n          } finally {\n              //6.释放资源\n              if(sqlSession != null) {\n                  sqlSession.close();\n              }\n              if(is != null) {\n                  try {\n                      is.close();\n                  } catch (IOException e) {\n                      e.printStackTrace();\n                  }\n              }\n          }\n      }\n  \n      @Override\n      public void update(Student student) {\n          SqlSession sqlSession = null;\n          InputStream is = null;\n          try{\n              //1.加载核心配置文件\n              is = Resources.getResourceAsStream("MyBatisConfig.xml");\n  \n              //2.获取SqlSession工厂对象\n              SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n  \n              //3.通过工厂对象获取SqlSession对象\n              sqlSession = sqlSessionFactory.openSession(true);\n  \n              //4.获取StudentDao接口的实现类对象\n              StudentDao mapper = sqlSession.getMapper(StudentDao.class);\n  \n              //5.调用实现类对象的方法，接收结果\n              mapper.update(student);\n  \n          } catch (Exception e) {\n              e.printStackTrace();\n          } finally {\n              //6.释放资源\n              if(sqlSession != null) {\n                  sqlSession.close();\n              }\n              if(is != null) {\n                  try {\n                      is.close();\n                  } catch (IOException e) {\n                      e.printStackTrace();\n                  }\n              }\n          }\n      }\n  \n      @Override\n      public void delete(Integer sid) {\n          SqlSession sqlSession = null;\n          InputStream is = null;\n          try{\n              //1.加载核心配置文件\n              is = Resources.getResourceAsStream("MyBatisConfig.xml");\n  \n              //2.获取SqlSession工厂对象\n              SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n  \n              //3.通过工厂对象获取SqlSession对象\n              sqlSession = sqlSessionFactory.openSession(true);\n  \n              //4.获取StudentDao接口的实现类对象\n              StudentDao mapper = sqlSession.getMapper(StudentDao.class);\n  \n              //5.调用实现类对象的方法，接收结果\n              mapper.delete(sid);\n  \n          } catch (Exception e) {\n              e.printStackTrace();\n          } finally {\n              //6.释放资源\n              if(sqlSession != null) {\n                  sqlSession.close();\n              }\n              if(is != null) {\n                  try {\n                      is.close();\n                  } catch (IOException e) {\n                      e.printStackTrace();\n                  }\n              }\n          }\n      }\n  }\n  \n```\n\n\n\n\n',Kt={data:function(){return{MainComponent:Qt}}},$t=Kt,Xt=Object(d["a"])($t,zt,Wt,!1,null,"706d773c",null),Yt=Xt.exports,Zt={mixins:[ce["c"]],components:{m1:_t,m2:Vt,m3:Yt},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"Mybatis 基础",value:"m1"},{label:"Mybatis 进阶",value:"m2"},{label:"Mybatis 高级",value:"m3"}]}}},nr=Zt,er=Object(d["a"])(nr,Mt,At,!1,null,"aafe9f46",null),tr=er.exports,rr=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[t(""+n.tab,{tag:"component"})],1)},ar=[],ir=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},sr=[],or='# Maven基础\r\n\r\n## 学习目标\r\n\r\n目标1：能够说出maven的作用，POM的概念\r\n\r\n目标2：完成maven的下载，安装和环境配置\r\n\r\n目标3：能够说出仓库，坐标的概念，完成仓库的配置\r\n\r\n目标4：完成手动搭建maven项目的案例\r\n\r\n目标5：完成IDEA工具搭建maven项目的案例\r\n\r\n目标6：能够说出依赖的传递方式和如何解决依赖传递冲突\r\n\r\n目标7：能够说出maven的生命周期\r\n\r\n## 1.Maven简介\r\n\r\n### 1.1 Maven是什么\r\n\r\n在学习Maven之前，我们先来看一下我们现在做的项目都有哪些问题。假设你现在做了一个crm的系统，项目中肯定要用到一些jar包，比如说mybatis，log4j，JUnit等，除了这些之外，你有可能用到你的同事开发的其他的东西，比如说别人做了一个财务模块或做了一个结算的模块，你在这里边有可能要用到这些东西。\r\n\r\n![](./img/java/maven/Maven基础.img/1.png)\r\n\r\n假如有一天你们的项目中mybatis进行了一个升级，但是它内部使用的JUnit没有升级，你升级以后的mybatis假如要用5.0的JUnit，而你项目中目前用的是4.0的，会不会冲突？必然会出问题！这个时候管理起来会比较麻烦，你需要各种调整。更有甚者，假如同事做的这些东西升级了但又没有通知你，这个时候，就会出现几种严重的问题：\r\n\r\n（1）jar包不统一，jar不兼容\r\n\r\n（2）工程升级维护过程操作繁琐\r\n\r\n除此之外，还会有其它的一系列问题。那么要解决这些问题，就用到了我们今天要讲的Maven了。\r\n\r\n\r\n\r\n那**Maven是什么**？\r\n\r\n​\t**Maven的本质是一个项目管理工具，将项目开发和管理过程抽象成一个项目对象模型（POM）**\r\n\r\nMaven是用Java语言编写的。他管理的东西统统以面向对象的形式进行设计，最终他把一个项目看成一个对象，而这个对象叫做POM(project  object model)，即项目对象模型\r\n\r\n![](./img/java/maven/Maven基础.img/2.png)\r\n\r\n我们说一个项目就是一个对象，作为对象的行为、对象的属性都有哪些呢？\r\n\r\nMaven说我们需要编写一个pom.xml文件，Maven通过加载这个配置文件就可以知道我们项目的相关信息了！到这里我们知道了Maven离不开一个叫pom.xml的文件。因为这个文件代表就一个项目。\r\n\r\n>提个问题大家思考，如果我们做8个项目，对应的是1个文件，还是8个文件？肯定是8个！\r\n\r\n那Maven是如何帮我们进行项目资源管理的呢？这就需要用到Maven中的第二个东西：**依赖管理**。这也是它的第二个核心！\r\n\r\n所谓依赖管理就是maven对项目所有依赖资源的一种管理，它和项目之间是一种双向关系，即当我们做项目的时候maven的依赖管理可以帮助你去管理你所需要的其他资源，当其他的项目需要依赖我们项目的时候，maven也会把我们的项目当作一种资源去进行管理，这就是一种双向关系。\r\n\r\n那maven的依赖管理它管理的这些资源存在哪儿呢？主要有三个位置：本地仓库，私服，中央仓库\r\n\r\n本地仓库顾名思义就是存储在本地的一种资源仓库，如果本地仓库中没有相关资源，可以去私服上获取，私服也是一个资源仓库，只不过不在本地，是一种远程仓库，如果私服上也没有相关资源，可以去中央仓库去获取，中央仓库也是一种远程仓库。\r\n\r\nMaven除了帮我们管理项目资源之外还能帮助我们对项目进行构建，管理项目的整个生命周期，当然它的这些功能需要使用一些相关的插件来完成，当然整个生命周期过程中插件是需要配合使用的，单独一个无法完成完整的生命周期。\r\n\r\n### 1.2 Maven的作用\r\n\r\nMaven的作用我们可以分成三类：\r\n\r\n（1）项目构建：提供标准的，跨平台的自动化构建项目的方式\r\n\r\n（2）依赖管理：方便快捷的管理项目依赖的资源（jar包），避免资源间的版本冲突等问题\r\n\r\n（3）统一开发结构：提供标准的，统一的项目开发结构，如下图所示：\r\n\r\n![](./img/java/maven/Maven基础.img/4.png)\r\n\r\n各目录存放资源类型说明：\r\n\r\n**src/main/java**：项目java源码\r\n\r\n**src/main/resources**：项目的相关配置文件（比如mybatis配置，xml映射配置，自定义配置文件等）\r\n\r\n**src/main/webapp**：web资源（比如html，css，js等）\r\n\r\nsrc/test/java：测试代码\r\n\r\nsrc/test/resources：测试相关配置文件\r\n\r\nsrc/pom.xml：项目pom文件\r\n\r\n## 2.Maven环境搭建\r\n\r\nmaven的官网：http://maven.apache.org/\r\n\r\n### 2.1 下载\r\n\r\n官方下载地址：http://maven.apache.org/download.cgi\r\n\r\n![](./img/java/maven/Maven基础.img/5.png)\r\n\r\n在今日课程资料`安装程序`中给大家提供了已经下载好的包，我们可以直接使用\r\n\r\n### 2.2 安装\r\n\r\nmaven是一个绿色软件，解压即安装，非常容易，\r\n\r\n我们找到今日课程资料中的`安装程序`，将里面的`apache-maven-3.6.1-bin.zip`直接解压到D盘根目录下即可\r\n\r\n解压完成后我们可以查看一下maven自己的一个目录结构如下\r\n\r\n![](./img/java/maven/Maven基础.img/6.png)\r\n\r\n各目录结构说明：\r\n\r\nbin：可执行程序目录，\r\n\r\nboot：maven自身的启动加载器\r\n\r\nconf：maven配置文件的存放目录\r\n\r\nlib：maven运行所需库的存放目录\r\n\r\n### 2.3 环境配置\r\n\r\nmaven的运行需要java的环境，需要我们配置`JAVA_HOME`环境变量，这个相信大家已经存在了\r\n\r\n下面在去配置`MAVEN_HOME`的环境变量\r\n\r\n1：`我的电脑`--------\x3e`属性`---------\x3e`高级系统设置`----------\x3e`新建系统变量MAVEN_HOME`，\r\n\r\n![](./img/java/maven/Maven基础.img/7.png)\r\n\r\n系统变量值就是maven软件的根目录，我们刚刚已经将maven解压到D盘了，因此变量值就如图中所示\r\n\r\n2：环境变量配置好之后需要测试环境配置结果，我们需要在DOS命令窗口下输入以下命令查看输出\r\n\r\n```bash\r\nmvn -v\r\n```\r\n\r\n![](./img/java/maven/Maven基础.img/8.png)\r\n\r\n如果能够看到输出的maven的版本信息代表配置成功\r\n\r\n## 3.Maven基础概念\r\n\r\n### 3.1 仓库\r\n\r\n仓库：用于存储资源，主要是各种jar包\r\n\r\n![](./img/java/maven/Maven基础.img/9.png)\r\n\r\n关于仓库，我们前面讲到了有三种：本地仓库，私服，中央仓库，其中私服和中央仓库都属于远程仓库\r\n\r\n**中央仓库**：maven团队自身维护的仓库，属于开源的\r\n\r\n**私服**：各公司/部门等小范围内存储资源的仓库，私服也可以从中央仓库获取资源\r\n\r\n**本地仓库**：开发者自己电脑上存储资源的仓库，也可从远程仓库获取资源\r\n\r\n\r\n\r\n**私服的作用：**\r\n\r\n（1）保存具有版权的资源，包含购买或自主研发的jar\r\n\r\n（2）一定范围内共享资源，能做到仅对内不对外开放\r\n\r\n### 3.2 坐标\r\n\r\n我们说maven的仓库里存储了各种各样的资源（jar包），那这些资源我们如何找到它们呢？我们需要知道它们具体的一个位置才能知道如何找到它们，这个就叫坐标\r\n\r\n**坐标**：maven中的坐标用于描述仓库中资源的位置\r\n\r\nhttps://repo1.maven.org/maven2/\r\n\r\n那maven中的坐标是如何构成的呢？\r\n\r\nmaven坐标的主要组成如下：\r\n\r\n**groupId**：定义当前资源隶属组织名称（通常是域名反写，如：org.mybatis；com.itheima）\r\n\r\n**artifactId**：定义当前资源的名称（通常是项目或模块名称，如：crm，sms）\r\n\r\n**version**：定义当前资源的版本号\r\n\r\n>packaging：定义资源的打包方式，取值一般有如下三种\r\n>\r\n>（1）jar：该资源打成jar包，默认是jar\r\n>\r\n>（2）war：该资源打成war包\r\n>\r\n>（3）pom：该资源是一个父资源（表明使用maven分模块管理），打包时只生成一个pom.xml不生成jar或其他包结构\r\n\r\n如果要查询maven某一个资源的坐标，我们通常可以去maven的仓库进行查询，\r\n\r\n<https://mvnrepository.com/>，在该网站中可直接搜索想要的资源，然后就能得到该资源的坐标\r\n\r\n输入资源名称进行检索\r\n\r\n![](./img/java/maven/Maven基础.img/10.png)\r\n\r\n点击你想要的资源进行查看\r\n\r\n![](./img/java/maven/Maven基础.img/11.png)\r\n\r\n选择版本查看坐标\r\n\r\n![](./img/java/maven/Maven基础.img/12.png)\r\n\r\n\r\n\r\n**maven坐标的作用：**\r\n\r\n使用唯一标识，唯一性定义资源位置，通过该标识可以将资源的识别与下载工作交由机器完成。\r\n\r\n### 3.3 仓库配置\r\n\r\n开发者要在自己电脑上做开发，首先要做的就是配置本地仓库\r\n\r\n默认情况下maven本地仓库的位置在哪儿呢？\r\n\r\n我们可以选择在全局进行配置，在maven的配置文件`conf/settings.xml`中可以找到它的说明\r\n\r\n```xml\r\n  \x3c!-- localRepository\r\n   | The path to the local repository maven will use to store artifacts.\r\n   |\r\n   | Default: ${user.home}/.m2/repository\r\n  <localRepository>/path/to/local/repo</localRepository>\r\n  --\x3e\r\n```\r\n\r\n也就是在系统盘当前用户目录下的`.m2/repository`，比如我当前的系统用户是`zs`，则默认的本地仓库仓库位置在`C:\\Users\\zs\\.m2\\repository`\r\n\r\n因为我们平时开发项目所有的资源会比较多，而且各种资源还有好多的版本，资源与资源之间还有相互依赖的这种情况，因此本地仓库保存的内容会非常的多，它的体积会很大，如果放在C盘下不太合适，因此我们可以自己来指定一个位置作为本地仓库的位置，这个指定同样是需要来修改maven的配置文件`conf/settings.xml`\r\n\r\n在我们前面查看这个文件的时候大家会发现它提供了一个标签`<localRepository>/path/to/local/repo</localRepository>`，\r\n\r\n这个标签中配置的值就是我们本地仓库的位置，但是这个标签是在注释中的，也就是说目前不起作用，因此我们要将该标签挪出注释，并修改标签内的值，指定一个新的位置作为本地仓库的位置，例如\r\n\r\n```xml\r\n  \x3c!-- localRepository\r\n   | The path to the local repository maven will use to store artifacts.\r\n   |\r\n   | Default: ${user.home}/.m2/repository\r\n  <localRepository>/path/to/local/repo</localRepository>\r\n  --\x3e\r\n<localRepository>D:\\maven-repository</localRepository>\r\n```\r\n\r\n如果是局部用户配置：在仓库的同级目录也可以包含一个`settings.xml`配置文件，在里面也可以进行指定\r\n\r\n注意：局部用户配置优先与全局配置（遇见相同配置项的时候）\r\n\r\n![](./img/java/maven/Maven基础.img/17.png)\r\n\r\n\r\n\r\n另外大家需要注意：maven默认连接的远程仓库位置是：（即中央仓库）\r\n\r\n![](./img/java/maven/Maven基础.img/18.png)\r\n\r\n此站点并不在国内，因此有时候下载速度非常慢，因此我们可以配置一个国内站点镜像，可用于加速下载资源\r\n\r\n我们在`conf/settings.xml`配置文件中找到`<mirrors>`标签，在这组标签下添加镜像的配置，如下\r\n\r\n```xml\r\n<mirror>\r\n    <id>nexus-aliyun</id>\r\n    <mirrorOf>central</mirrorOf>\r\n    <name>Nexus aliyun</name>\r\n    <url>http://maven.aliyun.com/nexus/content/groups/public</url>\r\n</mirror>\r\n```\r\n\r\n## 4.Maven项目搭建\r\n\r\n我们回顾一下maven规范的目录结构：\r\n\r\n![](./img/java/maven/Maven基础.img/13.png)\r\n\r\n### 4.1 手动搭建maven项目\r\n\r\n我们先使用手动的方式来创建maven项目\r\n\r\n（1）在D盘下创建目录`mvnproject`并进入该目录，作为我们的操作目录\r\n\r\n（2）创建我们的maven项目，创建一个目录`project-java`作为我们的项目文件夹，并进入到该目录\r\n\r\n（3）创建java代码（源代码）所在目录，即创建`src/main/java`\r\n\r\n（4）创建配置文件所在目录，即创建`src/main/resources`\r\n\r\n（5）创建测试源代码所在目录，即创建`src/test/java`\r\n\r\n（6）创建测试存放配置文件存放目录，即`src/test/resources`\r\n\r\n（7）在`src/main/java`中创建一个包（注意在windos文件夹下就是创建目录）`com/itheima`，在该目录下创建`Demo.java`文件，作为演示所需java程序，内容如下\r\n\r\n```java\r\npackage com.itheima;\r\n\r\npublic class Demo{\r\n\tpublic String say(String name){\r\n\t\tSystem.out.println("hello "+name);\r\n\t\treturn "hello "+name;\r\n\t}\r\n}\r\n```\r\n\r\n（8）在`src/test/java`中创建一个测试包（目录）`com/itheima`，在该包下创建测试程序`DemoTest.java`\r\n\r\n```java\r\npackage com.itheima;\r\n\r\nimport org.junit.*;\r\npublic class DemoTest{\r\n\t\r\n\t@Test\r\n\tpublic void testSay(){\r\n\t\tDemo d = new Demo();\r\n\t\tString ret = d.say("maven");\r\n\t\tAssert.assertEquals("hello maven",ret);\r\n\t}\r\n\t\r\n}\r\n```\r\n\r\n（9）在`project-java/src`下创建`pom.xml`文件，编辑如下\r\n\r\n```xml\r\n<?xml version="1.0" encoding="UTF-8"?>\r\n<project\r\n    xmlns="http://maven.apache.org/POM/4.0.0"\r\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\r\n    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">\r\n\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <groupId>com.itheima</groupId>\r\n    <artifactId>project-java</artifactId>\r\n    <version>1.0</version>\r\n    <packaging>jar</packaging>\r\n\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>junit</groupId>\r\n            <artifactId>junit</artifactId>\r\n            <version>4.12</version>\r\n        </dependency>\r\n    </dependencies>\r\n\r\n</project>\r\n```\r\n\r\n\r\n\r\n*通过前面的操作，我们已经搭建好了maven的项目结构，下面要通过maven来构建我们的项目*\r\n\r\nmaven的构建命令以`mvn`开头，后面添加功能参数，可以一次性执行多个命令，用空格分离\r\n\r\n`mvn compile`：编译\r\n\r\n`mvn clean`：清理\r\n\r\n`mvn test`：测试\r\n\r\n`mvn package`：打包\r\n\r\n`mvn install`：安装到本地仓库\r\n\r\n\r\n\r\n下面我们来进行操作：\r\n\r\n（1）在项目`project-java`所在的DOS命令窗口下执行`mvn compile`进行源码编译，当然首次执行需要先下载相关插件\r\n\r\n![](./img/java/maven/Maven基础.img/15.png)\r\n\r\n编辑结果如下：\r\n\r\n![](./img/java/maven/Maven基础.img/16.png)\r\n\r\n编译完成后在项目`project-java`下多了一个目录`target`，在这个目录下就存放的是maven编译好的一些东西\r\n\r\n![](./img/java/maven/Maven基础.img/19.png)\r\n\r\n我们可以进入到`target`目录查看\r\n\r\n![](./img/java/maven/Maven基础.img/20.png)\r\n\r\n其中生成的`classes`目录就是编译好的字节码文件\r\n\r\n（2）当然如果我们想清理掉这些东西，我们只需执行`mvn clean`命令即可，清理掉后`target`目录也就消失了\r\n\r\n（3）如果我们要执行测试包中的测试程序，我们只需执行`mvn test`命令即可\r\n\r\n![](./img/java/maven/Maven基础.img/21.png)\r\n\r\n此时在看`target`目录会多一些东西\r\n\r\n![](./img/java/maven/Maven基础.img/22.png)\r\n\r\n其中产生的`test-classes`就是测试代码的字节码文件，`surefire-reports`是它产生的测试报告\r\n\r\n![](./img/java/maven/Maven基础.img/23.png)\r\n\r\n（4）使用`mvn package`命令进行打包，如下\r\n\r\n![](./img/java/maven/Maven基础.img/24.png)\r\n\r\n在生成的`target`目录中可以看到打包的结果\r\n\r\n![](./img/java/maven/Maven基础.img/25.png)\r\n\r\n当然，如果仔细看DOS窗口输出的我们会发现，`mvn package`命令的时候maven会把前面两个命令`mvn compile,mvn test`都执行一遍\r\n\r\n（5）使用`mvn install`命令进行安装，将项目打好的包存入本地仓库\r\n\r\n![](./img/java/maven/Maven基础.img/26.png)\r\n\r\n>仔细查看输出会发现`mvn install`命令执行的时候也会将前面的命令都执行一遍\r\n\r\n此时我们可以去本地仓库中查找，如何查找？这个很重要\r\n\r\nmaven是按照`groupId/artifactId/version`的结构在本地仓库进行存储\r\n\r\n![](./img/java/maven/Maven基础.img/27.png)\r\n\r\n\r\n\r\n\r\n\r\n前面我们是通过手动的方式创建的maven项目，相对来说比较的麻烦，maven本身也是这样觉得的，因此maven本身就给我们提供了相关的插件来帮助我们快速构建项目，当然这是一些命令：\r\n\r\n![](./img/java/maven/Maven基础.img/28.png)\r\n\r\n这些命令不用记，因为实际操作的时候也用不着，因为实际开发的时候我们基本都是用过一些IDE工具来进行项目开发，这些IDE工具基本都集成了Maven，我们操作起来非常简单。\r\n\r\n### 4.2 IDEA工具搭建maven项目\r\n\r\n前面学习的基本都是通过命令来构建和管理项目，但是这在实际开发过程中基本不常用，常用的是通过相关IDE工具来进行项目的构建和管理，因此我们使用IDEA工具进行maven项目的搭建\r\n\r\n需要注意的是：Maven和IDEA在版本上存在一些兼容性问题，因为要合理的选择Maven和IDEA的版本，本课程中提供安装maven-3.6.1版本是可用的\r\n\r\n#### 4.2.1 不使用原型创建项目\r\n\r\n（1）在IDEA中配置Maven\r\n\r\n![](./img/java/maven/Maven基础.img/29.png)\r\n\r\n（2）创建maven工程\r\n\r\n![](./img/java/maven/Maven基础.img/30.png)\r\n\r\n（3）填写本项目的坐标\r\n\r\n![](./img/java/maven/Maven基础.img/31.png)\r\n\r\n（4）查看各目录颜色标记是否正确\r\n\r\n![](./img/java/maven/Maven基础.img/32.png)\r\n\r\n（5）IDEA右侧有一个maven管理界面，可点开查看\r\n\r\n![](./img/java/maven/Maven基础.img/33.png)\r\n\r\n（6）在项目的pom.xml文件中添加项目资源依赖\r\n\r\n```xml\r\n<dependencies>\r\n    <dependency>\r\n        <groupId>junit</groupId>\r\n        <artifactId>junit</artifactId>\r\n        <version>4.12</version>\r\n    </dependency>\r\n</dependencies>\r\n```\r\n\r\n（7）创建源代码：com.itheima.Demo\r\n\r\n```java\r\npackage com.itheima;\r\n\r\n/**\r\n * Created by 传智播客*黑马程序员.\r\n */\r\npublic class Demo{\r\n    public String say(String name){\r\n        System.out.println("hello "+name);\r\n        return "hello "+name;\r\n    }\r\n}\r\n```\r\n\r\n（8）创建测试代码：com.itheima.DemoTest\r\n\r\n```java\r\npackage com.itheima;\r\n\r\nimport org.junit.Assert;\r\nimport org.junit.Test;\r\n\r\n/**\r\n * Created by 传智播客*黑马程序员.\r\n */\r\npublic class DemoTest{\r\n\r\n    @Test\r\n    public void testSay(){\r\n        Demo d = new Demo();\r\n        String ret = d.say("maven");\r\n        Assert.assertEquals("hello maven",ret);\r\n    }\r\n\r\n}\r\n```\r\n\r\n![](./img/java/maven/Maven基础.img/34.png)\r\n\r\n然后可以进行测试运行\r\n\r\n\r\n\r\n运行的时候可以编辑运行模板：\r\n\r\n![](./img/java/maven/Maven基础.img/35.png)\r\n\r\n\r\n\r\n然后点击运行：\r\n\r\n![](./img/java/maven/Maven基础.img/36.png)\r\n\r\n\r\n\r\n#### 4.2.2 使用原型创建项目\r\n\r\n- 首先我们来看普通的java工程如何创建：\r\n\r\n（1）创建maven项目的时候选择使用原型骨架\r\n\r\n![](./img/java/maven/Maven基础.img/37.png)\r\n\r\n（2）创建完成后发现通过这种方式缺少一些目录，如下图\r\n\r\n![](./img/java/maven/Maven基础.img/38.png)\r\n\r\n**我们需要手动去补全目录，并且要对补全的目录进行标记，切记**\r\n\r\n![](./img/java/maven/Maven基础.img/39.png)\r\n\r\n\r\n\r\n- 然后我们在来看web工程如何创建：\r\n\r\n（1）选择web对应的原型骨架\r\n\r\n>有很多的webapp原型骨架，选择哪个基本都差不多，包括前面创建普通项目也是一样，quickstart原型也有很多\r\n\r\n![](./img/java/maven/Maven基础.img/40.png)\r\n\r\n（2）和前面创建普通项目一样，通过原型创建web项目得到的目录结构是不全的，因此需要我们自行补全，同时要标记正确，最终需要得到如下结构\r\n\r\n![](./img/java/maven/Maven基础.img/41.png)\r\n\r\n（3）web工程创建好之后需要启动运行，需要使用一个tomcat插件来运行我们的项目，在`pom.xml`中添加插件的坐标即可，最终改好的`pom.xml`如下\r\n\r\n```xml\r\n<?xml version="1.0" encoding="UTF-8"?>\r\n\r\n<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\r\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\r\n  <modelVersion>4.0.0</modelVersion>\r\n\r\n  <groupId>com.itheima</groupId>\r\n  <artifactId>web01</artifactId>\r\n  <version>1.0-SNAPSHOT</version>\r\n  <packaging>war</packaging>\r\n\r\n  <name>web01 Maven Webapp</name>\r\n  <url>http://www.example.com</url>\r\n\r\n  <properties>\r\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\r\n    <maven.compiler.source>1.8</maven.compiler.source>\r\n    <maven.compiler.target>1.8</maven.compiler.target>\r\n  </properties>\r\n\r\n  <dependencies>\r\n    <dependency>\r\n      <groupId>junit</groupId>\r\n      <artifactId>junit</artifactId>\r\n      <version>4.12</version>\r\n      <scope>test</scope>\r\n    </dependency>\r\n  </dependencies>\r\n\r\n  <build>\r\n    <finalName>web01</finalName>\r\n    <plugins>\r\n      <plugin>\r\n        <groupId>org.apache.tomcat.maven</groupId>\r\n        <artifactId>tomcat7-maven-plugin</artifactId>\r\n        <version>2.1</version>\r\n      </plugin>\r\n    </plugins>\r\n  </build>\r\n</project>\r\n```\r\n\r\n（4）插件配置好后，在IDEA右侧`maven-project`操作面板上可以看到该插件，并且可以利用该插件启动项目\r\n\r\n![](./img/java/maven/Maven基础.img/42.png)\r\n\r\n运行后该插件会给我们一个可运行地址：\r\n\r\n![](./img/java/maven/Maven基础.img/43.png)\r\n\r\n如果我们想更换端口，只需要在`pom.xml`中配置该插件即可\r\n\r\n```xml\r\n<plugins>\r\n    <plugin>\r\n        <groupId>org.apache.tomcat.maven</groupId>\r\n        <artifactId>tomcat7-maven-plugin</artifactId>\r\n        <version>2.1</version>\r\n        <configuration>\r\n            <port>80</port>\r\n        </configuration>\r\n    </plugin>\r\n```\r\n\r\n（5）同时为了运行方便我们也可以创建运行模板：\r\n\r\n![](./img/java/maven/Maven基础.img/44.png)\r\n\r\n## 5.Maven依赖管理\r\n\r\n### 5.1 依赖配置与依赖传递\r\n\r\n依赖是指在当前项目中运行所需的jar，依赖配置的格式如下图\r\n\r\n![](./img/java/maven/Maven基础.img/45.png)\r\n\r\n\r\n\r\n**依赖传递：**\r\n\r\n依赖具有传递性，分两种\r\n\r\n（1）直接依赖：在当前项目中通过依赖配置建立的依赖关系\r\n\r\n（2）间接依赖：被依赖的资源如果依赖其他资源，则表明当前项目间接依赖其他资源\r\n\r\n注意：直接依赖和间接依赖其实也是一个相对关系\r\n\r\n![](./img/java/maven/Maven基础.img/46.png)\r\n\r\n**依赖传递的冲突问题：**\r\n\r\n在依赖传递过程中产生了冲突，我们有三种优先法则\r\n\r\n（1）路径优先：当依赖中出现相同资源时，层级越深，优先级越低，反之则越高\r\n\r\n（2）声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖靠后的\r\n\r\n（3）特殊优先：当同级配置了相同资源的不同版本时，后配置的覆盖先配置的\r\n\r\n![](./img/java/maven/Maven基础.img/47.png)\r\n\r\n**可选依赖**：\r\n\r\n![](./img/java/maven/Maven基础.img/48.png)\r\n\r\n**排除依赖：**\r\n\r\n![](./img/java/maven/Maven基础.img/49.png)\r\n\r\n### 5.2 依赖范围\r\n\r\n依赖的jar默认情况可以在任何地方可用，可以通过`scope`标签设定其作用范围\r\n\r\n这里的范围主要是指以下三种范围\r\n\r\n（1）主程序范围有效（src/main目录范围内）\r\n\r\n（2）测试程序范围内有效（src/test目录范围内）\r\n\r\n（3）是否参与打包（package指令范围内）\r\n\r\n此外：`scope`标签的取值有四种：`compile,test,provided,runtime`\r\n\r\n这四种取值与范围的对应情况如下：\r\n\r\n![](./img/java/maven/Maven基础.img/50.png)\r\n\r\n\r\n\r\n**依赖范围的传递性：**\r\n\r\n![](./img/java/maven/Maven基础.img/51.png)\r\n\r\n## 6.Maven生命周期与插件\r\n\r\n### 6.1 生命周期\r\n\r\nmaven的构建生命周期描述的是一次构建过程经历了多少个事件\r\n\r\n比如我们项目最常用的一套流程如下：\r\n\r\n![](./img/java/maven/Maven基础.img/52.png)\r\n\r\n当然maven的生命周期不止这一套，总共分为3套，每套里面包含的事件如下\r\n\r\n（1）clean：清理工作\r\n\r\n>pre-clean：执行一些在clean之前的工作\r\n>\r\n>clean：移除上一次构建产生的所有文件\r\n>\r\n>post-clean：执行一些在clean之后立刻完成的工作\r\n\r\n（2）default：核心工作，例如编译，测试，打包，部署等\r\n\r\n>这里面的事件非常的多，如下图\r\n>\r\n>![](./img/java/maven/Maven基础.img/53.png)\r\n\r\n**对于default生命周期，每个事件在执行之前都会将之前的所有事件依次执行一遍**\r\n\r\n（3）site：产生报告，发布站点等\r\n\r\n>pre-site：执行一些在生成站点文档之前的工作\r\n>\r\n>site：生成项目的站点文档\r\n>\r\n>post-site：执行一些在生成站点文档之后完成的工作，为部署做准备\r\n>\r\n>site-deploy：将生成的站点文档部署到特定的服务器上\r\n\r\n### 6.2 插件\r\n\r\n前面我们讲了maven生命周期中的相关事件，那这些事件是谁来执行的呢？答案是maven的插件\r\n\r\n**插件：**\r\n\r\n- 插件与生命周期内的阶段绑定，在执行到对应生命周期时执行对应的插件\r\n- maven默认在各个生命周期上都绑定了预先设定的插件来完成相应功能\r\n- 插件还可以完成一些自定义功能\r\n\r\n插件的配置方式如下：\r\n\r\n![](./img/java/maven/Maven基础.img/54.png)\r\n\r\n在maven官网中有对插件的介绍：\r\n\r\nhttp://maven.apache.org/plugins/index.html\r\n\r\n',lr={data:function(){return{MainComponent:or}}},cr=lr,pr=Object(d["a"])(cr,ir,sr,!1,null,"00416f76",null),ur=pr.exports,mr=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},dr=[],gr='# 附件1：POM文件总体配置说明\r\n\r\n```xml\r\n<project xmlns="http://maven.apache.org/POM/4.0.0" \r\nxmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" \r\nxsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd "> \r\n\r\n    \x3c!-- 父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。\r\n         坐标包括group ID，artifact ID和 version。 --\x3e \r\n    <parent> \r\n        \x3c!-- 被继承的父项目的构件标识符 --\x3e \r\n        <artifactId>xxx</artifactId>\r\n\r\n        \x3c!-- 被继承的父项目的全球唯一标识符 --\x3e\r\n        <groupId>xxx</groupId> \r\n\r\n        \x3c!-- 被继承的父项目的版本 --\x3e \r\n        <version>xxx</version>\r\n\r\n        \x3c!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。\r\n             Maven首先在构建当前项目的地方寻找父项目的pom，其次在文件系统的这个位置（relativePath位置），\r\n             然后在本地仓库，最后在远程仓库寻找父项目的pom。 --\x3e \r\n        <relativePath>xxx</relativePath> \r\n    </parent> \r\n\r\n    \x3c!-- 声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，\r\n         这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --\x3e \r\n    <modelVersion> 4.0.0 </modelVersion> \r\n\r\n    \x3c!-- 项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， \r\n         如com.mycompany.app生成的相对路径为：/com/mycompany/app --\x3e \r\n    <groupId>xxx</groupId> \r\n\r\n    \x3c!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID\r\n         和groupID；在某个特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven\r\n         为项目产生的构件包括：JARs，源码，二进制发布和WARs等。 --\x3e \r\n    <artifactId>xxx</artifactId> \r\n\r\n    \x3c!-- 项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --\x3e \r\n    <packaging> jar </packaging> \r\n\r\n    \x3c!-- 项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --\x3e \r\n    <version> 1.0-SNAPSHOT </version> \r\n\r\n    \x3c!-- 项目的名称, Maven产生的文档用 --\x3e \r\n    <name> xxx-maven </name> \r\n\r\n    \x3c!-- 项目主页的URL, Maven产生的文档用 --\x3e \r\n    <url> http://maven.apache.org </url> \r\n\r\n    \x3c!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，\r\n         就可以包含HTML标签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的\r\n         索引页文件，而不是调整这里的文档。 --\x3e \r\n    <description> A maven project to study maven. </description> \r\n\r\n    \x3c!-- 描述了这个项目构建环境中的前提条件。 --\x3e \r\n    <prerequisites> \r\n        \x3c!-- 构建该项目或使用该插件所需要的Maven的最低版本 --\x3e \r\n        <maven></maven> \r\n    </prerequisites> \r\n\r\n    \x3c!-- 项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --\x3e \r\n    <issueManagement> \r\n        \x3c!-- 问题管理系统（例如jira）的名字， --\x3e \r\n        <system> jira </system> \r\n\r\n        \x3c!-- 该项目使用的问题管理系统的URL --\x3e \r\n        <url> http://jira.baidu.com/banseon </url> \r\n    </issueManagement> \r\n\r\n    \x3c!-- 项目持续集成信息 --\x3e \r\n    <ciManagement> \r\n        \x3c!-- 持续集成系统的名字，例如continuum --\x3e \r\n        <system></system> \r\n\r\n        \x3c!-- 该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --\x3e \r\n        <url></url> \r\n\r\n        \x3c!-- 构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --\x3e \r\n        <notifiers> \r\n            \x3c!-- 配置一种方式，当构建中断时，以该方式通知用户/开发者 --\x3e \r\n            <notifier> \r\n                \x3c!-- 传送通知的途径 --\x3e \r\n                <type></type> \r\n\r\n                \x3c!-- 发生错误时是否通知 --\x3e \r\n                <sendOnError></sendOnError> \r\n\r\n                \x3c!-- 构建失败时是否通知 --\x3e \r\n                <sendOnFailure></sendOnFailure> \r\n\r\n                \x3c!-- 构建成功时是否通知 --\x3e \r\n                <sendOnSuccess></sendOnSuccess> \r\n\r\n                \x3c!-- 发生警告时是否通知 --\x3e \r\n                <sendOnWarning></sendOnWarning> \r\n\r\n                \x3c!-- 不赞成使用。通知发送到哪里 --\x3e \r\n                <address></address> \r\n\r\n                \x3c!-- 扩展配置项 --\x3e \r\n                <configuration></configuration> \r\n            </notifier> \r\n        </notifiers> \r\n    </ciManagement> \r\n\r\n    \x3c!-- 项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --\x3e \r\n    <inceptionYear /> \r\n\r\n    \x3c!-- 项目相关邮件列表信息 --\x3e \r\n    <mailingLists> \r\n        \x3c!-- 该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --\x3e \r\n        <mailingList> \r\n            \x3c!-- 邮件的名称 --\x3e \r\n            <name> Demo </name> \r\n\r\n            \x3c!-- 发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --\x3e \r\n            <post> banseon@126.com </post> \r\n\r\n            \x3c!-- 订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --\x3e \r\n            <subscribe> banseon@126.com </subscribe> \r\n\r\n            \x3c!-- 取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --\x3e \r\n            <unsubscribe> banseon@126.com </unsubscribe> \r\n\r\n            \x3c!-- 你可以浏览邮件信息的URL --\x3e \r\n            <archive> http:/hi.baidu.com/banseon/demo/dev/ </archive> \r\n        </mailingList> \r\n    </mailingLists> \r\n\r\n    \x3c!-- 项目开发者列表 --\x3e \r\n    <developers> \r\n        \x3c!-- 某个项目开发者的信息 --\x3e \r\n        <developer> \r\n            \x3c!-- SCM里项目开发者的唯一标识符 --\x3e \r\n            <id> HELLO WORLD </id>\r\n            \r\n            \x3c!-- 项目开发者的全名 --\x3e \r\n            <name> banseon </name> \r\n\r\n            \x3c!-- 项目开发者的email --\x3e \r\n            <email> banseon@126.com </email> \r\n\r\n            \x3c!-- 项目开发者的主页的URL --\x3e \r\n            <url></url> \r\n\r\n            \x3c!-- 项目开发者在项目中扮演的角色，角色元素描述了各种角色 --\x3e \r\n            <roles> \r\n                <role> Project Manager </role> \r\n                <role> Architect </role> \r\n            </roles> \r\n\r\n            \x3c!-- 项目开发者所属组织 --\x3e \r\n            <organization> demo </organization> \r\n\r\n            \x3c!-- 项目开发者所属组织的URL --\x3e \r\n            <organizationUrl> http://hi.baidu.com/xxx </organizationUrl> \r\n\r\n            \x3c!-- 项目开发者属性，如即时消息如何处理等 --\x3e \r\n            <properties> \r\n                <dept> No </dept> \r\n            </properties> \r\n\r\n            \x3c!-- 项目开发者所在时区， -11到12范围内的整数。 --\x3e \r\n            <timezone> -5 </timezone> \r\n        </developer> \r\n    </developers> \r\n\r\n    \x3c!-- 项目的其他贡献者列表 --\x3e \r\n    <contributors> \r\n        \x3c!-- 项目的其他贡献者。参见developers/developer元素 --\x3e \r\n        <contributor> \r\n            \x3c!-- 项目贡献者的全名 --\x3e \r\n            <name></name>\r\n\r\n            \x3c!-- 项目贡献者的email --\x3e\r\n            <email></email>\r\n\r\n            \x3c!-- 项目贡献者的主页的URL --\x3e\r\n            <url></url>\r\n\r\n            \x3c!-- 项目贡献者所属组织 --\x3e\r\n            <organization></organization>\r\n\r\n            \x3c!-- 项目贡献者所属组织的URL --\x3e\r\n            <organizationUrl></organizationUrl>\r\n\r\n            \x3c!-- 项目贡献者在项目中扮演的角色，角色元素描述了各种角色 --\x3e \r\n            <roles> \r\n                <role> Project Manager </role> \r\n                <role> Architect </role> \r\n            </roles>\r\n\r\n            \x3c!-- 项目贡献者所在时区， -11到12范围内的整数。 --\x3e \r\n            <timezone></timezone>\r\n            \r\n            \x3c!-- 项目贡献者属性，如即时消息如何处理等 --\x3e \r\n            <properties> \r\n                <dept> No </dept> \r\n            </properties>  \r\n        </contributor> \r\n    </contributors> \r\n\r\n    \x3c!-- 该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。\r\n         如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --\x3e \r\n    <licenses> \r\n        \x3c!-- 描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --\x3e \r\n        <license> \r\n            \x3c!-- license用于法律上的名称 --\x3e \r\n            <name> Apache 2 </name> \r\n\r\n            \x3c!-- 官方的license正文页面的URL --\x3e \r\n            <url> http://www.baidu.com/banseon/LICENSE-2.0.txt </url> \r\n\r\n            \x3c!-- 项目分发的主要方式： \r\n                    repo，可以从Maven库下载 \r\n                    manual， 用户必须手动下载和安装依赖 --\x3e \r\n            <distribution> repo </distribution> \r\n\r\n            \x3c!-- 关于license的补充信息 --\x3e \r\n            <comments> A business-friendly OSS license </comments> \r\n        </license> \r\n    </licenses> \r\n\r\n    \x3c!-- SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --\x3e \r\n    <scm> \r\n        \x3c!-- SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --\x3e \r\n        <connection> \r\n            scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk)\r\n        </connection> \r\n\r\n        \x3c!-- 给开发者使用的，类似connection元素。即该连接不仅仅只读 --\x3e \r\n        <developerConnection> \r\n            scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk \r\n        </developerConnection> \r\n\r\n        \x3c!-- 当前代码的标签，在开发阶段默认为HEAD --\x3e \r\n        <tag></tag> \r\n\r\n        \x3c!-- 指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --\x3e \r\n        <url> http://svn.baidu.com/banseon </url> \r\n    </scm> \r\n\r\n    \x3c!-- 描述项目所属组织的各种属性。Maven产生的文档用 --\x3e \r\n    <organization> \r\n        \x3c!-- 组织的全名 --\x3e \r\n        <name> demo </name> \r\n\r\n        \x3c!-- 组织主页的URL --\x3e \r\n        <url> http://www.baidu.com/banseon </url> \r\n    </organization> \r\n\r\n    \x3c!-- 构建项目需要的信息 --\x3e \r\n    <build> \r\n        \x3c!-- 该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对\r\n             于pom.xml的相对路径。 --\x3e \r\n        <sourceDirectory></sourceDirectory> \r\n\r\n        \x3c!-- 该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容会\r\n             被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --\x3e \r\n        <scriptSourceDirectory></scriptSourceDirectory> \r\n\r\n        \x3c!-- 该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。\r\n             该路径是相对于pom.xml的相对路径。 --\x3e \r\n        <testSourceDirectory></testSourceDirectory> \r\n\r\n        \x3c!-- 被编译过的应用程序class文件存放的目录。 --\x3e \r\n        <outputDirectory></outputDirectory> \r\n\r\n        \x3c!-- 被编译过的测试class文件存放的目录。 --\x3e \r\n        <testOutputDirectory></testOutputDirectory> \r\n\r\n        \x3c!-- 使用来自该项目的一系列构建扩展 --\x3e \r\n        <extensions> \r\n            \x3c!-- 描述使用到的构建扩展。 --\x3e \r\n            <extension> \r\n                \x3c!-- 构建扩展的groupId --\x3e \r\n                <groupId></groupId> \r\n\r\n                \x3c!-- 构建扩展的artifactId --\x3e \r\n                <artifactId></artifactId> \r\n\r\n                \x3c!-- 构建扩展的版本 --\x3e \r\n                <version></version> \r\n            </extension> \r\n        </extensions> \r\n\r\n        \x3c!-- 当项目没有规定目标（Maven2 叫做阶段）时的默认值 --\x3e \r\n        <defaultGoal></defaultGoal> \r\n\r\n        \x3c!-- 这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在\r\n             最终的打包文件里。 --\x3e \r\n        <resources> \r\n            \x3c!-- 这个元素描述了项目相关或测试相关的所有资源路径 --\x3e \r\n            <resource> \r\n                \x3c!-- 描述了资源的目标路径。该路径相对target/classes目录（例如${project.build.outputDirectory}）。\r\n                     举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为\r\n                    org/apache/maven/messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --\x3e \r\n                <targetPath></targetPath> \r\n\r\n                \x3c!-- 是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素\r\n                     里列出。 --\x3e \r\n                <filtering></filtering>\r\n\r\n                \x3c!-- 描述存放资源的目录，该路径相对POM路径 --\x3e \r\n                <directory></directory>\r\n\r\n                \x3c!-- 包含的模式列表，例如**/*.xml. --\x3e \r\n                <includes>\r\n                    <include></include>\r\n                </includes>\r\n\r\n                \x3c!-- 排除的模式列表，例如**/*.xml --\x3e\r\n                <excludes>\r\n                    <exclude></exclude>\r\n                </excludes>\r\n            </resource> \r\n        </resources> \r\n\r\n        \x3c!-- 这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --\x3e \r\n        <testResources> \r\n            \x3c!-- 这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --\x3e \r\n            <testResource> \r\n                \x3c!-- 描述了测试相关的资源的目标路径。该路径相对target/classes目录（例如${project.build.outputDirectory}）。\r\n                     举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为\r\n                    org/apache/maven/messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --\x3e \r\n                <targetPath></targetPath> \r\n\r\n                \x3c!-- 是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素\r\n                     里列出。 --\x3e \r\n                <filtering></filtering>\r\n\r\n                \x3c!-- 描述存放测试相关的资源的目录，该路径相对POM路径 --\x3e \r\n                <directory></directory>\r\n\r\n                \x3c!-- 包含的模式列表，例如**/*.xml. --\x3e \r\n                <includes>\r\n                    <include></include>\r\n                </includes>\r\n\r\n                \x3c!-- 排除的模式列表，例如**/*.xml --\x3e\r\n                <excludes>\r\n                    <exclude></exclude>\r\n                </excludes> \r\n            </testResource> \r\n        </testResources> \r\n\r\n        \x3c!-- 构建产生的所有文件存放的目录 --\x3e \r\n        <directory></directory> \r\n\r\n        \x3c!-- 产生的构件的文件名，默认值是${artifactId}-${version}。 --\x3e \r\n        <finalName></finalName> \r\n\r\n        \x3c!-- 当filtering开关打开时，使用到的过滤器属性文件列表 --\x3e \r\n        <filters></filters> \r\n\r\n        \x3c!-- 子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本\r\n             地配置都会覆盖这里的配置 --\x3e \r\n        <pluginManagement> \r\n            \x3c!-- 使用的插件列表 。 --\x3e \r\n            <plugins> \r\n                \x3c!-- plugin元素包含描述插件所需要的信息。 --\x3e \r\n                <plugin> \r\n                    \x3c!-- 插件在仓库里的group ID --\x3e \r\n                    <groupId></groupId> \r\n\r\n                    \x3c!-- 插件在仓库里的artifact ID --\x3e \r\n                    <artifactId></artifactId> \r\n\r\n                    \x3c!-- 被使用的插件的版本（或版本范围） --\x3e \r\n                    <version></version> \r\n\r\n                    \x3c!-- 是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该\r\n                         元素才被设置成enabled。 --\x3e \r\n                    <extensions>true/false</extensions> \r\n\r\n                    \x3c!-- 在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --\x3e \r\n                    <executions> \r\n                        \x3c!-- execution元素包含了插件执行需要的信息 --\x3e \r\n                        <execution> \r\n                            \x3c!-- 执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --\x3e \r\n                            <id></id>\r\n\r\n                            \x3c!-- 绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --\x3e \r\n                            <phase></phase>\r\n\r\n                            \x3c!-- 配置的执行目标 --\x3e \r\n                            <goals></goals> \r\n\r\n                            \x3c!-- 配置是否被传播到子POM --\x3e \r\n                            <inherited>true/false</inherited> \r\n\r\n                            \x3c!-- 作为DOM对象的配置 --\x3e \r\n                            <configuration></configuration>\r\n                        </execution> \r\n                    </executions> \r\n\r\n                    \x3c!-- 项目引入插件所需要的额外依赖 --\x3e \r\n                    <dependencies>\r\n                        \x3c!-- 参见dependencies/dependency元素 --\x3e \r\n                        <dependency> \r\n                        </dependency> \r\n                    </dependencies> \r\n\r\n                    \x3c!-- 任何配置是否被传播到子项目 --\x3e \r\n                    <inherited>true/false</inherited>\r\n\r\n                    \x3c!-- 作为DOM对象的配置 --\x3e \r\n                    <configuration></configuration>\r\n                </plugin> \r\n            </plugins> \r\n        </pluginManagement> \r\n\r\n        \x3c!-- 该项目使用的插件列表 。 --\x3e \r\n        <plugins> \r\n            \x3c!-- plugin元素包含描述插件所需要的信息。 --\x3e \r\n            <plugin> \r\n                \x3c!-- 插件在仓库里的group ID --\x3e \r\n                <groupId></groupId> \r\n\r\n                \x3c!-- 插件在仓库里的artifact ID --\x3e \r\n                <artifactId></artifactId> \r\n\r\n                \x3c!-- 被使用的插件的版本（或版本范围） --\x3e \r\n                <version></version> \r\n\r\n                \x3c!-- 是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该\r\n                     元素才被设置成enabled。 --\x3e \r\n                <extensions>true/false</extensions> \r\n\r\n                \x3c!-- 在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --\x3e \r\n                <executions> \r\n                    \x3c!-- execution元素包含了插件执行需要的信息 --\x3e \r\n                    <execution> \r\n                        \x3c!-- 执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --\x3e \r\n                        <id></id>\r\n\r\n                        \x3c!-- 绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --\x3e \r\n                        <phase></phase>\r\n\r\n                        \x3c!-- 配置的执行目标 --\x3e \r\n                        <goals></goals> \r\n\r\n                        \x3c!-- 配置是否被传播到子POM --\x3e \r\n                        <inherited>true/false</inherited> \r\n\r\n                        \x3c!-- 作为DOM对象的配置 --\x3e \r\n                        <configuration></configuration>\r\n                    </execution> \r\n                </executions> \r\n\r\n                \x3c!-- 项目引入插件所需要的额外依赖 --\x3e \r\n                <dependencies>\r\n                    \x3c!-- 参见dependencies/dependency元素 --\x3e \r\n                    <dependency> \r\n                    </dependency> \r\n                </dependencies> \r\n\r\n                \x3c!-- 任何配置是否被传播到子项目 --\x3e \r\n                <inherited>true/false</inherited> \r\n\r\n                \x3c!-- 作为DOM对象的配置 --\x3e \r\n                <configuration></configuration> \r\n            </plugin> \r\n        </plugins>\r\n    </build> \r\n\r\n    \x3c!-- 在列的项目构建profile，如果被激活，会修改构建处理 --\x3e \r\n    <profiles> \r\n        \x3c!-- 根据环境参数或命令行参数激活某个构建处理 --\x3e \r\n        <profile> \r\n            \x3c!-- 构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --\x3e \r\n            <id></id>\r\n\r\n            \x3c!-- 自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它能够\r\n                 在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元\r\n                 素并不是激活profile的唯一方式。 --\x3e \r\n            <activation> \r\n                \x3c!-- profile默认是否激活的标志 --\x3e \r\n                <activeByDefault>true/false</activeByDefault> \r\n\r\n                \x3c!-- 当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本\r\n                     不是以1.4开头的JDK。 --\x3e \r\n                <jdk>jdk版本，如:1.7</jdk> \r\n\r\n                \x3c!-- 当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --\x3e \r\n                <os> \r\n                    \x3c!-- 激活profile的操作系统的名字 --\x3e \r\n                    <name> Windows XP </name> \r\n\r\n                    \x3c!-- 激活profile的操作系统所属家族(如 \'windows\') --\x3e \r\n                    <family> Windows </family> \r\n\r\n                    \x3c!-- 激活profile的操作系统体系结构 --\x3e \r\n                    <arch> x86 </arch> \r\n\r\n                    \x3c!-- 激活profile的操作系统版本 --\x3e \r\n                    <version> 5.1.2600 </version> \r\n                </os> \r\n\r\n                \x3c!-- 如果Maven检测到某一个属性（其值可以在POM中通过${名称}引用），其拥有对应的名称和值，Profile\r\n                     就会被激活。如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹\r\n                     配属性值字段 --\x3e \r\n                <property> \r\n                    \x3c!-- 激活profile的属性的名称 --\x3e \r\n                    <name> mavenVersion </name> \r\n\r\n                    \x3c!-- 激活profile的属性的值 --\x3e \r\n                    <value> 2.0.3 </value> \r\n                </property> \r\n\r\n                \x3c!-- 提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 \r\n                     profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --\x3e \r\n                <file> \r\n                    \x3c!-- 如果指定的文件存在，则激活profile。 --\x3e \r\n                    <exists> /usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ </exists> \r\n\r\n                    \x3c!-- 如果指定的文件不存在，则激活profile。 --\x3e \r\n                    <missing> /usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ </missing> \r\n                </file> \r\n            </activation> \r\n\r\n            \x3c!-- 构建项目所需要的信息。参见build元素 --\x3e \r\n            <build> \r\n                <defaultGoal /> \r\n                <resources> \r\n                    <resource> \r\n                        <targetPath></targetPath>\r\n                        <filtering></filtering>\r\n                        <directory></directory>\r\n                        <includes>\r\n                            <include></include>\r\n                        </includes>\r\n                        <excludes>\r\n                            <exclude></exclude>\r\n                        </excludes>\r\n                    </resource> \r\n                </resources> \r\n                <testResources> \r\n                    <testResource> \r\n                        <targetPath></targetPath>\r\n                        <filtering></filtering>\r\n                        <directory></directory>\r\n                        <includes>\r\n                            <include></include>\r\n                        </includes>\r\n                        <excludes>\r\n                            <exclude></exclude>\r\n                        </excludes> \r\n                    </testResource> \r\n                </testResources> \r\n                <directory></directory>\r\n                <finalName></finalName>\r\n                <filters></filters> \r\n                <pluginManagement> \r\n                    <plugins> \r\n                        \x3c!-- 参见build/pluginManagement/plugins/plugin元素 --\x3e \r\n                        <plugin> \r\n                            <groupId></groupId>\r\n                            <artifactId></artifactId>\r\n                            <version></version>\r\n                            <extensions>true/false</extensions> \r\n                            <executions> \r\n                                <execution> \r\n                                    <id></id>\r\n                                    <phase></phase>\r\n                                    <goals></goals>\r\n                                    <inherited>true/false</inherited>\r\n                                    <configuration></configuration> \r\n                                </execution> \r\n                            </executions> \r\n                            <dependencies> \r\n                                \x3c!-- 参见dependencies/dependency元素 --\x3e \r\n                                <dependency> \r\n                                </dependency> \r\n                            </dependencies> \r\n                            <goals></goals>\r\n                            <inherited>true/false</inherited>\r\n                            <configuration></configuration>\r\n                        </plugin> \r\n                    </plugins> \r\n                </pluginManagement> \r\n                <plugins> \r\n                    \x3c!-- 参见build/pluginManagement/plugins/plugin元素 --\x3e \r\n                    <plugin> \r\n                        <groupId></groupId>\r\n                        <artifactId></artifactId>\r\n                        <version></version>\r\n                        <extensions>true/false</extensions> \r\n                        <executions> \r\n                            <execution> \r\n                                <id></id>\r\n                                <phase></phase>\r\n                                <goals></goals>\r\n                                <inherited>true/false</inherited>\r\n                                <configuration></configuration> \r\n                            </execution> \r\n                        </executions> \r\n                        <dependencies> \r\n                            \x3c!-- 参见dependencies/dependency元素 --\x3e \r\n                            <dependency> \r\n                            </dependency> \r\n                        </dependencies> \r\n                        <goals></goals>\r\n                        <inherited>true/false</inherited>\r\n                        <configuration></configuration> \r\n                    </plugin> \r\n                </plugins> \r\n            </build> \r\n\r\n            \x3c!-- 模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的\r\n                 相对路径 --\x3e \r\n            <modules>\r\n                \x3c!--子项目相对路径--\x3e\r\n                <module></module>\r\n            </modules> \r\n\r\n            \x3c!-- 发现依赖和扩展的远程仓库列表。 --\x3e \r\n            <repositories> \r\n                \x3c!-- 参见repositories/repository元素 --\x3e \r\n                <repository> \r\n                    <releases> \r\n                        <enabled><enabled>\r\n                        <updatePolicy></updatePolicy>\r\n                        <checksumPolicy></checksumPolicy> \r\n                    </releases> \r\n                    <snapshots> \r\n                        <enabled><enabled>\r\n                        <updatePolicy></updatePolicy>\r\n                        <checksumPolicy></checksumPolicy> \r\n                    </snapshots> \r\n                    <id></id>\r\n                    <name></name>\r\n                    <url></url>\r\n                    <layout></layout> \r\n                </repository> \r\n            </repositories> \r\n\r\n            \x3c!-- 发现插件的远程仓库列表，这些插件用于构建和报表 --\x3e \r\n            <pluginRepositories> \r\n                \x3c!-- 包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --\x3e \r\n                <pluginRepository> \r\n                    <releases> \r\n                        <enabled><enabled>\r\n                        <updatePolicy></updatePolicy>\r\n                        <checksumPolicy></checksumPolicy> \r\n                    </releases> \r\n                    <snapshots> \r\n                        <enabled><enabled>\r\n                        <updatePolicy></updatePolicy>\r\n                        <checksumPolicy></checksumPolicy>\r\n                    </snapshots> \r\n                    <id></id>\r\n                    <name></name>\r\n                    <url></url>\r\n                    <layout></layout> \r\n                </pluginRepository> \r\n            </pluginRepositories> \r\n\r\n            \x3c!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的\r\n                 仓库中下载。要获取更多信息，请看项目依赖机制。 --\x3e \r\n            <dependencies> \r\n                \x3c!-- 参见dependencies/dependency元素 --\x3e \r\n                <dependency> \r\n                </dependency> \r\n            </dependencies> \r\n\r\n            \x3c!-- 不赞成使用. 现在Maven忽略该元素. --\x3e \r\n            <reports></reports> \r\n\r\n            \x3c!-- 该元素包括使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看\r\n                 到所有报表的链接。参见reporting元素 --\x3e \r\n            <reporting></reporting> \r\n\r\n            \x3c!-- 参见dependencyManagement元素 --\x3e \r\n            <dependencyManagement> \r\n                <dependencies> \r\n                    \x3c!-- 参见dependencies/dependency元素 --\x3e \r\n                    <dependency> \r\n                    </dependency> \r\n                </dependencies> \r\n            </dependencyManagement> \r\n\r\n            \x3c!-- 参见distributionManagement元素 --\x3e \r\n            <distributionManagement> \r\n            </distributionManagement> \r\n\r\n            \x3c!-- 参见properties元素 --\x3e \r\n            <properties /> \r\n        </profile> \r\n    </profiles> \r\n\r\n    \x3c!-- 模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --\x3e \r\n    <modules>\r\n        \x3c!--子项目相对路径--\x3e\r\n        <module></module>\r\n    </modules> \r\n\r\n    \x3c!-- 发现依赖和扩展的远程仓库列表。 --\x3e \r\n    <repositories> \r\n        \x3c!-- 包含需要连接到远程仓库的信息 --\x3e \r\n        <repository> \r\n            \x3c!-- 如何处理远程仓库里发布版本的下载 --\x3e \r\n            <releases> \r\n                \x3c!-- true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --\x3e \r\n                <enabled><enabled> \r\n\r\n                \x3c!-- 该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），\r\n                     daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --\x3e \r\n                <updatePolicy></updatePolicy> \r\n\r\n                \x3c!-- 当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --\x3e \r\n                <checksumPolicy></checksumPolicy> \r\n            </releases> \r\n\r\n            \x3c!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，\r\n                 为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --\x3e \r\n            <snapshots> \r\n                <enabled><enabled>\r\n                <updatePolicy></updatePolicy>\r\n                <checksumPolicy></checksumPolicy> \r\n            </snapshots> \r\n\r\n            \x3c!-- 远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --\x3e \r\n            <id> banseon-repository-proxy </id> \r\n\r\n            \x3c!-- 远程仓库名称 --\x3e \r\n            <name> banseon-repository-proxy </name> \r\n\r\n            \x3c!-- 远程仓库URL，按protocol://hostname/path形式 --\x3e \r\n            <url> http://192.168.1.169:9999/repository/ </url> \r\n\r\n            \x3c!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认\r\n                 的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --\x3e \r\n            <layout> default </layout> \r\n        </repository> \r\n    </repositories> \r\n\r\n    \x3c!-- 发现插件的远程仓库列表，这些插件用于构建和报表 --\x3e \r\n    <pluginRepositories> \r\n        \x3c!-- 包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --\x3e \r\n        <pluginRepository> \r\n        </pluginRepository> \r\n    </pluginRepositories> \r\n\r\n    \x3c!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。\r\n         要获取更多信息，请看项目依赖机制。 --\x3e \r\n    <dependencies> \r\n        <dependency> \r\n            \x3c!-- 依赖的group ID --\x3e \r\n            <groupId> org.apache.maven </groupId> \r\n\r\n            \x3c!-- 依赖的artifact ID --\x3e \r\n            <artifactId> maven-artifact </artifactId> \r\n\r\n            \x3c!-- 依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --\x3e \r\n            <version> 3.8.1 </version> \r\n\r\n            \x3c!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展\r\n                 名或分类器。类型经常和使用的打包方式对应，尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。\r\n                 如果设置extensions为 true，就可以在plugin里定义新的类型。所以前面的类型的例子不完整。 --\x3e \r\n            <type> jar </type> \r\n\r\n            \x3c!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，\r\n                 如果你想要构建两个单独的构件成JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生\r\n                 成两个单独的JAR构件。 --\x3e \r\n            <classifier></classifier> \r\n\r\n            \x3c!-- 依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 \r\n                - compile ：默认范围，用于编译 \r\n                - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath \r\n                - runtime: 在执行时需要使用 \r\n                - test: 用于test任务时使用 \r\n                - system: 需要外在提供相应的元素。通过systemPath来取得 \r\n                - systemPath: 仅用于范围为system。提供相应的路径 \r\n                - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --\x3e \r\n            <scope> test </scope> \r\n\r\n            \x3c!-- 仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件\r\n                 系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如${java.home}。 --\x3e \r\n            <systemPath></systemPath> \r\n\r\n            \x3c!-- 当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的\r\n                 依赖。此元素主要用于解决版本冲突问题 --\x3e \r\n            <exclusions> \r\n                <exclusion> \r\n                    <artifactId> spring-core </artifactId> \r\n                    <groupId> org.springframework </groupId> \r\n                </exclusion> \r\n            </exclusions> \r\n\r\n            \x3c!-- 可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。\r\n                 可选依赖阻断依赖的传递性。 --\x3e \r\n            <optional> true </optional> \r\n        </dependency> \r\n    </dependencies> \r\n\r\n    \x3c!-- 不赞成使用. 现在Maven忽略该元素. --\x3e \r\n    <reports></reports> \r\n\r\n    \x3c!-- 该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 --\x3e \r\n    <reporting> \r\n        \x3c!-- true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。 --\x3e \r\n        <excludeDefaults /> \r\n\r\n        \x3c!-- 所有产生的报表存放到哪里。默认值是${project.build.directory}/site。 --\x3e \r\n        <outputDirectory /> \r\n\r\n        \x3c!-- 使用的报表插件和他们的配置。 --\x3e \r\n        <plugins> \r\n            \x3c!-- plugin元素包含描述报表插件需要的信息 --\x3e \r\n            <plugin> \r\n                \x3c!-- 报表插件在仓库里的group ID --\x3e \r\n                <groupId></groupId> \r\n                \x3c!-- 报表插件在仓库里的artifact ID --\x3e \r\n                <artifactId></artifactId> \r\n\r\n                \x3c!-- 被使用的报表插件的版本（或版本范围） --\x3e \r\n                <version></version> \r\n\r\n                \x3c!-- 任何配置是否被传播到子项目 --\x3e \r\n                <inherited>true/false</inherited> \r\n\r\n                \x3c!-- 报表插件的配置 --\x3e \r\n                <configuration></configuration> \r\n\r\n                \x3c!-- 一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，\r\n                     有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报\r\n                     表集，对应另一个执行目标 --\x3e \r\n                <reportSets> \r\n                    \x3c!-- 表示报表的一个集合，以及产生该集合的配置 --\x3e \r\n                    <reportSet> \r\n                        \x3c!-- 报表集合的唯一标识符，POM继承时用到 --\x3e \r\n                        <id></id> \r\n\r\n                        \x3c!-- 产生报表集合时，被使用的报表的配置 --\x3e \r\n                        <configuration></configuration> \r\n\r\n                        \x3c!-- 配置是否被继承到子POMs --\x3e \r\n                        <inherited>true/false</inherited> \r\n\r\n                        \x3c!-- 这个集合里使用到哪些报表 --\x3e \r\n                        <reports></reports> \r\n                    </reportSet> \r\n                </reportSets> \r\n            </plugin> \r\n        </plugins> \r\n    </reporting> \r\n\r\n    \x3c!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖\r\n        （必须描述group ID和artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过\r\n            group ID和artifact ID匹配到这里的依赖，并使用这里的依赖信息。 --\x3e \r\n    <dependencyManagement> \r\n        <dependencies> \r\n            \x3c!-- 参见dependencies/dependency元素 --\x3e \r\n            <dependency> \r\n            </dependency> \r\n        </dependencies> \r\n    </dependencyManagement> \r\n\r\n    \x3c!-- 项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者\r\n         把构件部署到远程仓库。 --\x3e \r\n    <distributionManagement> \r\n        \x3c!-- 部署项目产生的构件到远程仓库需要的信息 --\x3e \r\n        <repository> \r\n            \x3c!-- 是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见\r\n                 repositories/repository元素 --\x3e \r\n            <uniqueVersion /> \r\n            <id> banseon-maven2 </id> \r\n            <name> banseon maven2 </name> \r\n            <url> file://${basedir}/target/deploy </url> \r\n            <layout></layout> \r\n        </repository> \r\n\r\n        \x3c!-- 构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见\r\n             distributionManagement/repository元素 --\x3e \r\n        <snapshotRepository> \r\n            <uniqueVersion /> \r\n            <id> banseon-maven2 </id> \r\n            <name> Banseon-maven2 Snapshot Repository </name> \r\n            <url> scp://svn.baidu.com/banseon:/usr/local/maven-snapshot </url> \r\n            <layout></layout>\r\n        </snapshotRepository> \r\n\r\n        \x3c!-- 部署项目的网站需要的信息 --\x3e \r\n        <site> \r\n            \x3c!-- 部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --\x3e \r\n            <id> banseon-site </id> \r\n\r\n            \x3c!-- 部署位置的名称 --\x3e \r\n            <name> business api website </name> \r\n\r\n            \x3c!-- 部署位置的URL，按protocol://hostname/path形式 --\x3e \r\n            <url> \r\n                scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web \r\n            </url> \r\n        </site> \r\n\r\n        \x3c!-- 项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位\r\n             那些不在仓库里的构件（由于license限制）。 --\x3e \r\n        <downloadUrl /> \r\n\r\n        \x3c!-- 如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --\x3e \r\n        <relocation> \r\n            \x3c!-- 构件新的group ID --\x3e \r\n            <groupId></groupId> \r\n\r\n            \x3c!-- 构件新的artifact ID --\x3e \r\n            <artifactId></artifactId> \r\n\r\n            \x3c!-- 构件新的版本号 --\x3e \r\n            <version></version> \r\n\r\n            \x3c!-- 显示给用户的，关于移动的额外信息，例如原因。 --\x3e \r\n            <message></message> \r\n        </relocation> \r\n\r\n        \x3c!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值\r\n             有：none（默认），converted（仓库管理员从Maven 1 POM转换过来），partner（直接从伙伴Maven \r\n             2仓库同步过来），deployed（从Maven 2实例部署），verified（被核实时正确的和最终的）。 --\x3e \r\n        <status></status> \r\n    </distributionManagement> \r\n\r\n    \x3c!-- 以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里\r\n         activation元素的说明）。格式是<name>value</name>。 --\x3e \r\n    <properties>\r\n        <name>value</name>\r\n    </properties> \r\n</project> \r\n```\r\n\r\n\r\n\r\n# 附件2：POM文件单项配置说明\r\n\r\n## localRepository\r\n\r\n```XML\r\n \x3c!-- 本地仓库的路径。默认值为${user.home}/.m2/repository。 --\x3e\r\n <localRepository>usr/local/maven</localRepository>\r\n```\r\n\r\n## interactiveMode\r\n\r\n```XML\r\n \x3c!--Maven是否需要和用户交互以获得输入。如果Maven需要和用户交互以获得输入，则设置成true，反之则应为false。默认为true。--\x3e\r\n <interactiveMode>true</interactiveMode>\r\n```\r\n\r\n## usePluginRegistry\r\n\r\n```XML\r\n\x3c!--Maven是否需要使用plugin-registry.xml文件来管理插件版本。如果需要让Maven使用文件${user.home}/.m2/plugin-registry.xml来管理插件版本，则设为true。默认为false。--\x3e\r\n <usePluginRegistry>false</usePluginRegistry>\r\n```\r\n\r\n## offline\r\n\r\n```XML\r\n \x3c!--表示Maven是否需要在离线模式下运行。如果构建系统需要在离线模式下运行，则为true，默认为false。当由于网络设置原因或者安全因素，构建服务器不能连接远程仓库的时候，该配置就十分有用。 --\x3e\r\n <offline>false</offline>\r\n```\r\n\r\n## pluginGroups\r\n\r\n```XML\r\n\x3c!--当插件的组织Id（groupId）没有显式提供时，供搜寻插件组织Id（groupId）的列表。该元素包含一个pluginGroup元素列表，每个子元素包含了一个组织Id（groupId）。当我们使用某个插件，并且没有在命令行为其提供组织Id（groupId）的时候，Maven就会使用该列表。默认情况下该列表包含了org.apache.maven.plugins和org.codehaus.mojo --\x3e\r\n <pluginGroups>\r\n  \x3c!--plugin的组织Id（groupId） --\x3e\r\n  <pluginGroup>org.codehaus.mojo</pluginGroup>\r\n </pluginGroups>\r\n```\r\n\r\n## proxies\r\n\r\n```XML\r\n\x3c!--用来配置不同的代理，多代理profiles 可以应对笔记本或移动设备的工作环境：通过简单的设置profile id就可以很容易的更换整个代理配置。 --\x3e\r\n <proxies>\r\n  \x3c!--代理元素包含配置代理时需要的信息--\x3e\r\n  <proxy>\r\n   \x3c!--代理的唯一定义符，用来区分不同的代理元素。--\x3e\r\n   <id>myproxy</id>\r\n   \x3c!--该代理是否是激活的那个。true则激活代理。当我们声明了一组代理，而某个时候只需要激活一个代理的时候，该元素就可以派上用处。 --\x3e\r\n   <active>true</active>\r\n   \x3c!--代理的协议。 协议://主机名:端口，分隔成离散的元素以方便配置。--\x3e\r\n   <protocol>http</protocol>\r\n   \x3c!--代理的主机名。协议://主机名:端口，分隔成离散的元素以方便配置。  --\x3e\r\n   <host>proxy.somewhere.com</host>\r\n   \x3c!--代理的端口。协议://主机名:端口，分隔成离散的元素以方便配置。 --\x3e\r\n   <port>8080</port>\r\n   \x3c!--代理的用户名，用户名和密码表示代理服务器认证的登录名和密码。 --\x3e\r\n   <username>proxyuser</username>\r\n   \x3c!--代理的密码，用户名和密码表示代理服务器认证的登录名和密码。 --\x3e\r\n   <password>somepassword</password>\r\n   \x3c!--不该被代理的主机名列表。该列表的分隔符由代理服务器指定；例子中使用了竖线分隔符，使用逗号分隔也很常见。--\x3e\r\n   <nonProxyHosts>*.google.com|ibiblio.org</nonProxyHosts>\r\n  </proxy>\r\n </proxies>\r\n```\r\n\r\n## servers\r\n\r\n```XML\r\n\x3c!--配置服务端的一些设置。一些设置如安全证书不应该和pom.xml一起分发。这种类型的信息应该存在于构建服务器上的settings.xml文件中。--\x3e\r\n <servers>\r\n  \x3c!--服务器元素包含配置服务器时需要的信息 --\x3e\r\n  <server>\r\n   \x3c!--这是server的id（注意不是用户登陆的id），该id与distributionManagement中repository元素的id相匹配。--\x3e\r\n   <id>server001</id>\r\n   \x3c!--鉴权用户名。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。 --\x3e\r\n   <username>my_login</username>\r\n   \x3c!--鉴权密码 。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。密码加密功能已被添加到2.1.0 +。详情请访问密码加密页面--\x3e\r\n   <password>my_password</password>\r\n   \x3c!--鉴权时使用的私钥位置。和前两个元素类似，私钥位置和私钥密码指定了一个私钥的路径（默认是${user.home}/.ssh/id_dsa）以及如果需要的话，一个密语。将来passphrase和password元素可能会被提取到外部，但目前它们必须在settings.xml文件以纯文本的形式声明。 --\x3e\r\n   <privateKey>${usr.home}/.ssh/id_dsa</privateKey>\r\n   \x3c!--鉴权时使用的私钥密码。--\x3e\r\n   <passphrase>some_passphrase</passphrase>\r\n   \x3c!--文件被创建时的权限。如果在部署的时候会创建一个仓库文件或者目录，这时候就可以使用权限（permission）。这两个元素合法的值是一个三位数字，其对应了unix文件系统的权限，如664，或者775。 --\x3e\r\n   <filePermissions>664</filePermissions>\r\n   \x3c!--目录被创建时的权限。 --\x3e\r\n   <directoryPermissions>775</directoryPermissions>\r\n  </server>\r\n </servers>\r\n```\r\n\r\n## mirrors\r\n\r\n```XML\r\n\x3c!--为仓库列表配置的下载镜像列表。高级设置请参阅镜像设置页面 --\x3e\r\n <mirrors>\r\n  \x3c!--给定仓库的下载镜像。 --\x3e\r\n  <mirror>\r\n   \x3c!--该镜像的唯一标识符。id用来区分不同的mirror元素。 --\x3e\r\n   <id>planetmirror.com</id>\r\n   \x3c!--镜像名称 --\x3e\r\n   <name>PlanetMirror Australia</name>\r\n   \x3c!--该镜像的URL。构建系统会优先考虑使用该URL，而非使用默认的服务器URL。 --\x3e\r\n   <url>http://downloads.planetmirror.com/pub/maven2</url>\r\n   \x3c!--被镜像的服务器的id。例如，如果我们要设置了一个Maven中央仓库（http://repo.maven.apache.org/maven2/）的镜像，就需要将该元素设置成central。这必须和中央仓库的id central完全一致。--\x3e\r\n   <mirrorOf>central</mirrorOf>\r\n  </mirror>\r\n </mirrors>\r\n```\r\n\r\n## profiles\r\n\r\n```XML\r\n \x3c!--根据环境参数来调整构建配置的列表。settings.xml中的profile元素是pom.xml中profile元素的裁剪版本。它包含了id，activation, repositories, pluginRepositories和 properties元素。这里的profile元素只包含这五个子元素是因为这里只关心构建系统这个整体（这正是settings.xml文件的角色定位），而非单独的项目对象模型设置。如果一个settings中的profile被激活，它的值会覆盖任何其它定义在POM中或者profile.xml中的带有相同id的profile。 --\x3e\r\n <profiles>\r\n  \x3c!--根据环境参数来调整的构件的配置--\x3e\r\n  <profile>\r\n   \x3c!--该配置的唯一标识符。 --\x3e\r\n   <id>test</id>\r\n```\r\n\r\n## Activation\r\n\r\n```XML\r\n\x3c!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。如POM中的profile一样，profile的力量来自于它能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。settings.xml文件中的activeProfile元素可以包含profile的id。profile也可以通过在命令行，使用-P标记和逗号分隔的列表来显式的激活（如，-P test）。--\x3e\r\n   <activation>\r\n    \x3c!--profile默认是否激活的标识--\x3e\r\n    <activeByDefault>false</activeByDefault>\r\n    \x3c!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。--\x3e\r\n    <jdk>1.5</jdk>\r\n    \x3c!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。--\x3e\r\n    <os>\r\n     \x3c!--激活profile的操作系统的名字 --\x3e\r\n     <name>Windows XP</name>\r\n     \x3c!--激活profile的操作系统所属家族(如 \'windows\')  --\x3e\r\n     <family>Windows</family>\r\n     \x3c!--激活profile的操作系统体系结构  --\x3e\r\n     <arch>x86</arch>\r\n     \x3c!--激活profile的操作系统版本--\x3e\r\n     <version>5.1.2600</version>\r\n    </os>\r\n    \x3c!--如果Maven检测到某一个属性（其值可以在POM中通过${name}引用），其拥有对应的name = 值，Profile就会被激活。如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段--\x3e\r\n    <property>\r\n     \x3c!--激活profile的属性的名称--\x3e\r\n     <name>mavenVersion</name>\r\n     \x3c!--激活profile的属性的值 --\x3e\r\n     <value>2.0.3</value>\r\n    </property>\r\n    \x3c!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。--\x3e\r\n    <file>\r\n     \x3c!--如果指定的文件存在，则激活profile。 --\x3e\r\n     <exists>${basedir}/file2.properties</exists>\r\n     \x3c!--如果指定的文件不存在，则激活profile。--\x3e\r\n     <missing>${basedir}/file1.properties</missing>\r\n    </file>\r\n   </activation>\r\n```\r\n\r\n## Repositories\r\n\r\n```XML\r\n  \x3c!--远程仓库列表，它是Maven用来填充构建系统本地仓库所使用的一组远程项目。 --\x3e\r\n   <repositories>\r\n    \x3c!--包含需要连接到远程仓库的信息 --\x3e\r\n    <repository>\r\n     \x3c!--远程仓库唯一标识--\x3e\r\n     <id>codehausSnapshots</id>\r\n     \x3c!--远程仓库名称 --\x3e\r\n     <name>Codehaus Snapshots</name>\r\n     \x3c!--如何处理远程仓库里发布版本的下载--\x3e\r\n     <releases>\r\n      \x3c!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。  --\x3e\r\n      <enabled>false</enabled>\r\n      \x3c!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --\x3e\r\n      <updatePolicy>always</updatePolicy>\r\n      \x3c!--当Maven验证构件校验文件失败时该怎么做-ignore（忽略），fail（失败），或者warn（警告）。--\x3e\r\n      <checksumPolicy>warn</checksumPolicy>\r\n     </releases>\r\n     \x3c!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素--\x3e\r\n     <snapshots>\r\n      <enabled/><updatePolicy/><checksumPolicy/>\r\n     </snapshots>\r\n     \x3c!--远程仓库URL，按protocol://hostname/path形式 --\x3e\r\n     <url>http://snapshots.maven.codehaus.org/maven2</url>\r\n     \x3c!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --\x3e\r\n     <layout>default</layout>\r\n    </repository>\r\n   </repositories>\r\n   \x3c!--发现插件的远程仓库列表。仓库是两种主要构件的家。第一种构件被用作其它构件的依赖。这是中央仓库中存储的大部分构件类型。另外一种构件类型是插件。Maven插件是一种特殊类型的构件。由于这个原因，插件仓库独立于其它仓库。pluginRepositories元素的结构和repositories元素的结构类似。每个pluginRepository元素指定一个Maven可以用来寻找新插件的远程地址。--\x3e\r\n   <pluginRepositories>\r\n    \x3c!--包含需要连接到远程插件仓库的信息.参见profiles/profile/repositories/repository元素的说明--\x3e\r\n          <pluginRepository>           \r\n     <releases>      \r\n      <enabled/><updatePolicy/><checksumPolicy/>\r\n     </releases>\r\n     <snapshots>\r\n      <enabled/><updatePolicy/><checksumPolicy/>\r\n     </snapshots>\r\n     <id/><name/><url/><layout/>\r\n          </pluginRepository>\r\n        </pluginRepositories>\r\n  </profile>\r\n </profiles>\r\n```\r\n\r\n## activeProfiles\r\n\r\n```XML\r\n\x3c!--手动激活profiles的列表，按照profile被应用的顺序定义activeProfile。 该元素包含了一组activeProfile元素，每个activeProfile都含有一个profile id。任何在activeProfile中定义的profile id，不论环境设置如何，其对应的\r\n        profile都会被激活。如果没有匹配的profile，则什么都不会发生。例如，env-test是一个activeProfile，则在pom.xml（或者profile.xml）中对应id的profile会被激活。如果运行过程中找不到这样一个profile，Maven则会像往常一样运行。 --\x3e\r\n   <activeProfiles>\r\n    <activeProfile>env-test</activeProfile>\r\n   </activeProfiles>\r\n</settings>\r\n```',Sr={data:function(){return{MainComponent:gr}}},vr=Sr,br=Object(d["a"])(vr,mr,dr,!1,null,"432a16c9",null),hr=br.exports,yr={mixins:[ce["c"]],components:{m1:ur,m2:hr},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"maven 基础",value:"m1"},{label:"POM文件帮助文档",value:"m2"}]}}},fr=yr,xr=Object(d["a"])(fr,rr,ar,!1,null,"159cf718",null),wr=xr.exports,jr=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[t(""+n.tab,{tag:"component"})],1)},Cr=[],Tr=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},Er=[],Ir='\x3c!--\n * @Date           : 2021-04-28 01:12:51\n * @FilePath       : /jinnian-space/src/pages/java/module/springmvc/md/Spring-day01.md\n * @Description    : \n--\x3e\n#  IOC\n\n## 1)Spring简介\n\n### 1.1)什么是框架\n\n- 源自于建筑学，隶属土木工程，后发展到软件工程领域\n\n- 软件工程框架：经过验证的，具有一定功能的，半成品软件\n\n  - 经过验证\n\n  - 具有一定功能\n\n  - 半成品\n\n![1590631254933](./img/java/springmvc/Spring-day01/1590631254933.png)\n\n### 1.2)框架的作用\n\n![1590631300743](./img/java/springmvc/Spring-day01/1590631300743.png)\n\n### 1.3)Spring是什么\n\nSpring是分层的JavaSE/EE应用full-stack轻量级开源框架\n\n![1590631495077](./img/java/springmvc/Spring-day01/1590631495077.png)\n\n### 1.4)Spring的体系结构\n\n![1590631552693](./img/java/springmvc/Spring-day01/1590631552693.png)\n\n### 1.5)Spring的发展历史\n\n![1590631606747](./img/java/springmvc/Spring-day01/1590631606747.png)\n\n### 1.6)Spring优势\n\n| Spring的优势             |          |\n| ------------------------ | -------- |\n| 方便解耦，简化开发       | 第一天   |\n| 方便集成各种优秀框架     | 第一天   |\n| 方便程序的测试           | 第二天   |\n| AOP编程的支持            | 第三天   |\n| 声明式事务的支持         | 第四天   |\n| 降低JavaEE API的使用难度 | 第四天   |\n| Java源码是经典学习范例   | 长期学习 |\n\n## 2)IoC简介\n\n### 2.1)优质程序代码的制作原则\n\n![1590636507198](./img/java/springmvc/Spring-day01/1590636507198.png)\n\n### 2.2)耦合与内聚\n\n- 耦合（Coupling）：代码书写过程中所使用技术的结合紧密度，用于衡量软件中各个模块之间的互联程度\n\n- 内聚（Cohesion）：代码书写过程中单个模块内部各组成部分间的联系，用于衡量软件中各个功能模块内部的功能联系\n\n![1590636557953](./img/java/springmvc/Spring-day01/1590636557953.png)\n\n- 程序书写的目标：高内聚，低耦合\n  - 就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却不要那么紧密\n\n### 2.3)工厂模式发展史\n\n![1590636616069](./img/java/springmvc/Spring-day01/1590636616069.png)\n\n![1590636644096](./img/java/springmvc/Spring-day01/1590636644096.png)\n\n![1590636661026](./img/java/springmvc/Spring-day01/1590636661026.png)\n\n### 2.4)Spring发展历程\n\n![1590636704098](./img/java/springmvc/Spring-day01/1590636704098.png)\n\n### 2.5)IoC\n\n- IoC（Inversion Of Control）控制反转，Spring反向控制应用程序所需要使用的外部资源\n\n- Spring控制的资源全部放置在Spring容器中，该容器称为IoC容器\n\n  ![1590636750876](./img/java/springmvc/Spring-day01/1590636750876.png)\n\n\n\n\n\n## 3)入门案例\n\n### 3.1)案例环境说明\n\n- 模拟三层架构中表现层调用业务层功能\n\n  - 表现层：UserApp模拟UserServlet（使用main方法模拟）\n\n  - 业务层：UserService\n\n### 3.2)IoC入门案例制作步骤\n\n1.导入spring坐标（5.1.9.release）\n\n2.编写业务层与表现层（模拟）接口与实现类\n\n3.建立spring配置文件\n\n4.配置所需资源（Service）为spring控制的资源\n\n5.表现层（App）通过spring获取资源（Service实例）\n\n![1590637353510](./img/java/springmvc/Spring-day01/1590637353510.png)\n\n#### 3.2.1)IoC入门案例制作步骤-1\n\n```xml\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context</artifactId>\n    <version>5.1.9.RELEASE</version>\n</dependency>\n```\n\n#### 3.2.2)IoC入门案例制作步骤-2\n\n```java\npublic interface UserService {\n\t//业务方法  \n\tvoid save();\n}\n```\n\n#### 3.2.3)IoC入门案例制作步骤-3\n\n```java\npublic class UserServiceImpl implements UserService {\n    public void save() {\n        System.out.println("user service running...");\n    }\n}\n```\n\n#### 3.2.4)IoC入门案例制作步骤-4\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd">\n    \x3c!-- 1.创建spring控制的资源--\x3e\n    <bean id="userService" class="com.itheima.service.impl.UserServiceImpl"/>\n</beans>\n```\n\n#### 3.2.5)IoC入门案例制作步骤-5\n\n```java\npublic class UserApp {\n    public static void main(String[] args) {\n        //2.加载配置文件\n        ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");\n        //3.获取资源\n        UserService userService = (UserService) ctx.getBean("userService");\n        userService.save();\n    }\n}\n```\n\n## 4)IoC配置（XML格式）\n\n### 4.1)bean\n\n- 名称：bean\n\n- 类型：**标签**\n\n- 归属：beans标签\n\n- 作用：定义spring中的资源，受此标签定义的资源将受到spring控制\n\n- 格式：\n\n  ```xml\n  <beans>\n  \t<bean />\n  </beans>\n  ```\n\n- 基本属性：\n\n  ```xml\n  <bean id="beanId" name="beanName1,beanName2" class="ClassName"></bean>\n  ```\n\n  ​\tid：bean的名称，通过id值获取bean\n\n  ​\tclass：bean的类型\n\n  ​\tname：bean的名称，可以通过name值获取bean，用于多人配合时给bean起别名\n\n### 4.2)bean属性scope\n\n- 名称：scope\n\n- 类型：**属性**\n\n- 归属：bean标签\n\n- 作用：定义bean的作用范围\n\n- 格式：\n\n  ```xml\n  <bean scope="singleton"></bean>\n  ```\n\n- 取值：\n\n  - singleton：设定创建出的对象保存在spring容器中，是一个单例的对象\n  - prototype：设定创建出的对象保存在spring容器中，是一个非单例的对象\n  - request、session、application、 websocket ：设定创建出的对象放置在web容器对应的位置\n\n### 4.3)bean生命周期\n\n- 名称：init-method，destroy-method\n\n- 类型：**属性**\n\n- 归属：bean标签\n\n- 作用：定义bean对象在初始化或销毁时完成的工作\n\n- 格式：\n\n  ```xml\n  <bean init-method="init" destroy-method="destroy></bean>\n  ```\n\n- 取值：bean对应的类中对应的具体方法名\n\n- 注意事项：\n\n  - 当scope=“singleton”时，spring容器中有且仅有一个对象，init方法在创建容器时仅执行一次\n\n  - 当scope=“prototype”时，spring容器要创建同一类型的多个对象，init方法在每个对象创建时均执行一次\n\n  - 当scope=“singleton”时，关闭容器会导致bean实例的销毁，调用destroy方法一次\n\n  - 当scope=“prototype”时，对象的销毁由垃圾回收机制gc()控制，destroy方法将不会被执行\n\n### 4.4)bean对象创建方式（了解）\n\n(1)factory-bean\n\n- 名称：factory-bean\n\n- 类型：**属性**\n\n- 归属：bean标签\n\n- 作用：定义bean对象创建方式，使用静态工厂的形式创建bean，兼容早期遗留系统的升级工作\n\n- 格式：\n\n  ```xml\n  <bean class="FactoryClassName" factory-method="factoryMethodName"></bean>\n  ```\n\n- 取值：工厂bean中用于获取对象的静态方法名\n\n- 注意事项：\n  \n  - class属性必须配置成静态工厂的类名\n\n(2)factory-bean，factory-method\n\n- 名称：factory-bean，factory-method\n\n- 类型：**属性**\n\n- 归属：bean标签\n\n- 作用：定义bean对象创建方式，使用实例工厂的形式创建bean，兼容早期遗留系统的升级工作\n\n- 格式：\n\n  ```xml\n  <bean factory-bean="factoryBeanId" factory-method="factoryMethodName"></bean>\n  ```\n\n- 取值：工厂bean中用于获取对象的实例方法名\n\n- 注意事项：\n\n  - 使用实例工厂创建bean首先需要将实例工厂配置bean，交由spring进行管理\n\n  - factory-bean是实例工厂的beanId\n\n### 4.5)DI\n\n- IoC（Inversion Of Control）控制翻转，Spring反向控制应用程序所需要使用的外部资源\n\n- DI（Dependency Injection）依赖注入，应用程序运行依赖的资源由Spring为其提供，资源进入应用程序的方式称为注入\n\n![1590659778689](./img/java/springmvc/Spring-day01/1590659778689.png)\n\nIoC与DI的关系\n\n- IoC与DI是同一件事站在不同角度看待问题\n\n- 半杯水\n\n- \n\n- \n\n  ![1590659854696](./img/java/springmvc/Spring-day01/1590659854696.png)set注入（主流）\n\n### 4.6)set注入（主流）\n\n- 名称：property\n\n- 类型：**标签**\n\n- 归属：bean标签\n\n- 作用：使用set方法的形式为bean提供资源\n\n- 格式：\n\n  ```java\n  <bean>\n  \t<property />\n  </bean>\n  ```\n\n- 基本属性：\n\n  ```xml\n  <property name="propertyName" value="propertyValue" ref="beanId"/>\n  ```\n\n​\tname：对应bean中的属性名，要求该属性必须提供可访问的set方法（严格规范为此名称是set方法对应名称）\n\n​\tvalue：设定非引用类型属性对应的值，不能与ref同时使用\n\n​\tref：设定引用类型属性对应bean的id ，不能与value同时使用\n\n- 注意：一个bean可以有多个property标签\n\n### 4.7)构造器注入（了解）\n\n- 名称：constructor-arg\n\n- 类型：**标签**\n\n- 归属：bean标签\n\n- 作用：使用构造方法的形式为bean提供资源，兼容早期遗留系统的升级工作\n\n- 格式：\n\n  ```xml\n  <bean>\n  \t<constructor-arg />\n  </bean>\n  ```\n\n- 基本属性：\n\n  ```xml\n  <constructor-arg name="argsName" value="argsValue />\n  ```\n\n​\tname：对应bean中的构造方法所携带的参数名\n\n​\tvalue：设定非引用类型构造方法参数对应的值，不能与ref同时使用\n\n其他属性：\n\n```xml\n<constructor-arg index="arg-index" type="arg-type" ref="beanId"/>\n```\n\n​\tref：设定引用类型构造方法参数对应bean的id ，不能与value同时使用\n\n​\ttype ：设定构造方法参数的类型，用于按类型匹配参数或进行类型校验\n\n​\tindex ：设定构造方法参数的位置，用于按位置匹配参数，参数index值从0开始计数\n\n- 注意：一个bean可以有多个constructor-arg标签\n\n### 4.8)集合类型数据注入\n\n- 名称：array，list，set，map，props\n\n- 类型：**标签**\n\n- 归属：property标签 或 constructor-arg标签\n\n- 作用：注入集合数据类型属性\n\n- 格式：\n\n  ```xml\n  <property>\n  \t<list></list>\n  </property>\n  ```\n\n(1)集合类型数据注入——list\n\n```xml\n<property name="al">\n    <list>\n        <value>itheima</value>\n        <value>66666</value>\n    </list>\n</property>\n```\n\n(2)集合类型数据注入——props\n\n```xml\n<property name="properties">\n    <props>\n        <prop key="name">itheima666</prop>\n        <prop key="value">666666</prop>\n    </props>\n</property>\n```\n\n(3)集合类型数据注入——array （了解）\n\n```xml\n<property name="arr">\n    <array>\n        <value>123456</value>\n        <value>66666</value>\n    </array>\n</property>\n```\n\n(4)集合类型数据注入——set（了解）\n\n```xml\n <property name="hs">\n     <set>\n         <value>itheima</value>\n         <value>66666</value>\n     </set>\n</property>\n```\n\n(5)集合类型数据注入——map（了解）\n\n```xml\n<property name="hm">\n    <map>\n        <entry key="name" value="itheima66666"/>\n        <entry key="value" value="6666666666"/>\n    </map>\n</property>\n```\n\n### 4.9)使用p命名空间简化配置（了解）\n\n- 名称：p:propertyName，p:propertyName-ref\n\n- 类型：**属性**\n\n- 归属：bean标签\n\n- 作用：为bean注入属性值\n\n- 格式：\n\n  ```xml\n  <bean p:propertyName="propertyValue" p:propertyName-ref="beanId"/>\n  ```\n\n- 注意：使用p命令空间需要先开启spring对p命令空间的的支持，在beans标签中添加对应空间支持\n\n  ```xml\n  <beans xmlns="http://www.springframework.org/schema/beans"    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"    xmlns:p="http://www.springframework.org/schema/p"       xsi:schemaLocation="http://www.springframework.org/schema/beans     https://www.springframework.org/schema/beans/spring-beans.xsd">\n  ```\n\n  后续课程中还将开启其他的命名空间，方式同上\n\n- 案例：\n\n  ```xml\n   <bean\n         id="userService"\n         class="com.itheima.service.impl.UserServiceImpl"\n         p:userDao-ref="userDao"\n         p:bookDao-ref="bookDao"\n         />\n  ```\n\n  \n\n### 4.10)SpEL （了解）\n\n- Spring提供了对EL表达式的支持，统一属性注入格式\n\n- 类型：**属性值**\n\n- 归属：value属性值\n\n- 作用：为bean注入属性值\n\n- 格式：\n\n  ```xml\n  <property value="EL"></bean>\n  ```\n\n- 注意：所有属性值不区分是否引用类型，统一使用value赋值\n\n- 所有格式统一使用  value=“********”\n\n  - 常量  #{10}  #{3.14}  #{2e5}  #{‘itcast’}\n\n  - 引用bean  #{beanId}    \n\n  - 引用bean属性  #{beanId.propertyName}\n\n  - 引用bean方法  beanId.methodName().method2()\n\n  - 引用静态方法  T(java.lang.Math).PI\n\n  - 运算符支持  #{3 lt 4 == 4 ge 3}\n\n  - 正则表达式支持  #{user.name matches‘[a-z]{6,}’}\n\n  - 集合支持  #{likes[3]}\n\n- 案例：\n\n  ```xml\n   <bean id="userService" class="com.itheima.service.impl.UserServiceImpl">\n       <property name="userDao" value="#{userDao}"/>\n       <property name="bookDao" value="#{bookDao}"/>\n       <property name="num" value="#{666666666}"/>\n       <property name="version" value="#{\'itcast\'}"/>\n  </bean>\n  ```\n\n### 4.11)properties文件\n\n- Spring提供了读取外部properties文件的机制，使用读取到的数据为bean的属性赋值\n\n- 操作步骤\n\n  1.准备外部properties文件\n\n  2.开启context命名空间支持\n\n  ```xml\n  xmlns:context="http://www.springframework.org/schema/context"\n  ```\n\n​\t\t3.加载指定的properties文件\n\n```xml\n<context:property-placeholder location="classpath:filename.properties">\n```\n\n​\t\t4.使用加载的数据\n\n```xml\n<property name="propertyName" value="${propertiesName}"/>\n```\n\n- 注意：如果需要加载所有的properties文件，可以使用`*.properties`表示加载所有的properties文件\n\n- 注意：读取数据使用**${propertiesName}**格式进行，其中**propertiesName**指properties文件中的属性名\n\n### 4.12)团队开发\n\n- 名称：import\n\n- 类型：**标签**\n\n- 归属：beans标签\n\n- 作用：在当前配置文件中导入其他配置文件中的项\n\n- 格式：\n\n  ```xml\n  <beans>\n      <import />\n  </beans>\n  ```\n\n- 基本属性：\n\n  ```xml\n  <import resource=“config.xml"/>\n  ```\n\n​\tresource：加载的配置文件名\n\n- Spring容器加载多个配置文件\n\n  ```java\n  new ClassPathXmlApplicationContext("config1.xml","config2.xml");\n  ```\n\n- Spring容器中的bean定义冲突问题\n\n  - 同id的bean，后定义的覆盖先定义的\n\n  - 导入配置文件可以理解为将导入的配置文件复制粘贴到对应位置\n\n  - 导入配置文件的顺序与位置不同可能会导致最终程序运行结果不同\n\n### 4.13)ApplicationContext\n\n1.ApplicationContext是一个接口，提供了访问spring容器的API\n\n2.ClassPathXmlApplicationContext是一个类，实现了上述功能\n\n3.ApplicationContext的顶层接口是BeanFactory\n\n4.BeanFactory定义了bean相关的最基本操作\n\n5.ApplicationContext在BeanFactory基础上追加了若干新功能\n\n**对比BeanFactory**\n\n1.BeanFactory创建的bean采用延迟加载形式，使用才创建\n\n2.ApplicationContext创建的bean默认采用立即加载形式\n\n**FileSystemXmlApplicationContext**\n\n可以加载文件系统中任意位置的配置文件，而ClassPathXmlApplicationContext只能加载类路径下的配置文件\n\n![1591021082290](./img/java/springmvc/Spring-day01/1591021082290.png)\n\n**BeanFactory**\n\n```java\nResource res = new ClassPathResource("applicationContext.xml");\nBeanFactory bf = new XmlBeanFactory(res);\nUserService userService = (UserService)bf.getBean("userService");\n```\n\n### 4.14)第三方资源配置\n\n- 阿里数据源方案Druid\n\n  ```xml\n  <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">\n      <property name="driverClassName" value="com.mysql.jdbc.Driver"></property>\n      <property name="url" value="jdbc:mysql://localhost:3306/spring_ioc"></property>\n      <property name="username" value="root"></property>\n      <property name="password" value="root"></property>\n  </bean>\n  \n  ```\n\n## 5)综合案例\n\n### **5.1)案例介绍**\n\n- 使用spring整合mybatis技术，完成账户模块（Account）的基础增删改查功能\n\n- 账户模块对应字段\n\n  - 编号：id\n\n  - 账户名：name\n\n  - 余额：money\n\n### **5.2)案例分析**\n\n非spring环境\n\n1.实体类与表\n\n2.业务层接口与实现\n\n3.数据层接口\n\n4.Mybatis核心配置\n\n5.Mybatis映射配置\n\n6.客户端程序测试功能\n\n\n\nspring环境\n\n1.实体类与表\n\n2.业务层接口与实现（提供数据层接口的注入操作）\n\n3.数据层接口\n\n4.Mybatis核心配置（交给spring控制，该文件省略）\n\n5.Mybatis映射配置\n\n6.客户端程序测试功能（使用spring方式获取bean）\n\n7.Spring核心配置文件\n\n8.Druid数据源的应用（可选）\n\n9.Spring整合MyBatis\n\n\n\n### 5.3)案例制作步骤——基础准备工作\n\n- 环境准备\n\n1.导入Spring坐标，MyBatis坐标，MySQL坐标，Druid坐标\n\n- 业务类与接口准备\n\n2.创建数据库表，并制作相应的实体类Account\n\n3.定义业务层接口与数据层接口\n\n4.在业务层调用数据层接口，并实现业务方法的调用\n\n- 基础配置文件\n\n5.jdbc.properties\n\n6.MyBatis映射配置文件\n\n### 5.4)案例制作步骤——整合准备工作\n\n- 整合前基础准备工作\n\n1.spring配置文件，加上context命名空间，用于加载properties文件\n\n2.开启加载properties文件\n\n3.配置数据源druid（备用）\n\n4.定义service层bean，注入dao层bean\n\n5.dao的bean无需定义，使用代理自动生成\n\n### 5.5)案例制作步骤——整合工作\n\n- 整合工作\n\n1.导入Spring整合MyBatis坐标\n\n2.将mybatis配置成spring管理的bean（SqlSessionFactoryBean）\n\n​\t-将原始配置文件中的所有项，转入到当前配置中\n\n​\t数据源转换\n\n​\t映射转换\n\n3.通过spring加载mybatis的映射配置文件到spring环境中\n\n4.设置类型别名\n\n- 测试结果\n\n5.使用spring环境加载业务层bean，执行操作\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd">\n\n    \x3c!--加载perperties配置文件的信息--\x3e\n    <context:property-placeholder location="classpath:*.properties"/>\n\n    \x3c!--加载druid资源--\x3e\n    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">\n        <property name="driverClassName" value="${jdbc.driver}"/>\n        <property name="url" value="${jdbc.url}"/>\n        <property name="username" value="${jdbc.username}"/>\n        <property name="password" value="${jdbc.password}"/>\n    </bean>\n\n    \x3c!--配置service作为spring的bean,注入dao--\x3e\n    <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl">\n        <property name="accountDao" ref="accountDao"/>\n    </bean>\n\n    \x3c!--spring整合mybatis后控制的创建连接用的对象--\x3e\n    <bean class="org.mybatis.spring.SqlSessionFactoryBean">\n        <property name="dataSource" ref="dataSource"/>\n        <property name="typeAliasesPackage" value="com.itheima.domain"/>\n    </bean>\n\n    \x3c!--加载mybatis映射配置的扫描，将其作为spring的bean进行管理--\x3e\n    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">\n        <property name="basePackage" value="com.itheima.dao"/>\n    </bean>\n\n\n\n</beans>\n\n\n\n```\n\n\n### **小节**\n\n- 需要专用的spring整合mybatis的jar包\n\n- Mybatis核心配置文件消失\n\n  - 环境environment转换成数据源对象\n\n  - 映射Mapper扫描工作交由spring处理\n\n  - 类型别名交由spring处理\n\n- 业务发起使用spring上下文对象获取对应的bean\n\n',Dr={data:function(){return{MainComponent:Ir}}},Rr=Dr,Mr=Object(d["a"])(Rr,Tr,Er,!1,null,"5b05fd68",null),Ar=Mr.exports,Or=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},Pr=[],Lr='# 注解开发\n\n## 1)注解驱动的意义\n\n### 1.1)什么是注解驱动\n\n注解启动时使用注解的形式替代xml配置，将繁杂的spring配置文件从工程中彻底消除掉，简化书写\n\n![1591023265469](./img/java/springmvc/Spring-day02/1591023265469.png)\n\n### 1.2)注解驱动的弊端\n\n- 为了达成注解驱动的目的，可能会将原先很简单的书写，变的更加复杂\n\n- XML中配置第三方开发的资源是很方便的，但使用注解驱动无法在第三方开发的资源中进行编辑，因此会增大开发工作量\n\n![1591023337010](./img/java/springmvc/Spring-day02/1591023337010.png)\n\n\n\n## 2)常用注解\n\n### 2.1)启动注解功能\n\n- 启动注解扫描，加载类中配置的注解项\n\n  ```xml\n  <context:component-scan base-package="packageName"/>\n  ```\n\n- 说明：\n\n  - 在进行包所扫描时，会对配置的包及其子包中所有文件进行扫描\n\n  - 扫描过程是以文件夹递归迭代的形式进行的\n\n  - 扫描过程仅读取合法的java文件\n\n  - 扫描时仅读取spring可识别的注解\n\n  - 扫描结束后会将可识别的有效注解转化为spring对应的资源加入IoC容器\n\n- 注意：\n\n  - 无论是注解格式还是XML配置格式，最终都是将资源加载到IoC容器中，差别仅仅是数据读取方式不同\n\n  - 从加载效率上来说注解优于XML配置文件\n\n### 2.2)bean的定义\n\n- 名称：@Component    @Controller    @Service    @Repository\n\n- 类型：**类注解**\n\n- 位置：类定义上方\n\n- 作用：设置该类为spring管理的bean\n\n- 范例：\n\n  ```java\n  @Component\n  public class ClassName{}\n  ```\n\n- 说明：\n\n  - @Controller、@Service 、@Repository是@Component的衍生注解，功能同@Component\n\n- 相关属性\n  - value（默认）：定义bean的访问id\n\n### 2.3)bean的作用域\n\n- 名称：@Scope\n\n- 类型：**类注解**\n\n- 位置：类定义上方\n\n- 作用：设置该类作为bean对应的scope属性\n\n- 范例：\n\n  ```java\n  @Scope\n  public class ClassName{}\n  ```\n\n- 相关属性\n\n  - value（默认）：定义bean的作用域，默认为singleton\n\n### 2.4)bean的生命周期\n\n- 名称：@PostConstruct、@PreDestroy\n\n- 类型：**方法注解**\n\n- 位置：方法定义上方\n\n- 作用：设置该类作为bean对应的生命周期方法\n\n- 范例：\n\n  ```java\n  @PostConstruct\n  public void init() { System.out.println("init..."); }\n  ```\n\n### 2.5)加载第三方资源\n\n- 名称：@Bean\n\n- 类型：**方法注解**\n\n- 位置：方法定义上方\n\n- 作用：设置该方法的返回值作为spring管理的bean\n\n- 范例：\n\n  ```java\n  @Bean("dataSource")\n  public DruidDataSource createDataSource() {    return ……;    }\n  ```\n\n- 说明：\n\n  - 因为第三方bean无法在其源码上进行修改，使用@Bean解决第三方bean的引入问题\n\n  - 该注解用于替代XML配置中的静态工厂与实例工厂创建bean，不区分方法是否为静态或非静态\n\n  - @Bean所在的类必须被spring扫描加载，否则该注解无法生效\n\n- 相关属性\n  - value（默认）：定义bean的访问id\n\n### 2.6)bean的非引用类型属性注入\n\n- 名称：@Value\n\n- 类型：**属性注解、方法注解**\n\n- 位置：属性定义上方，方法定义上方\n\n- 作用：设置对应属性的值或对方法进行传参\n\n- 范例：\n\n  ```java\n  @Value("${jdbc.username}")\n  private String username;\n  ```\n\n- 说明：\n\n  - value值仅支持非引用类型数据，赋值时对方法的所有参数全部赋值\n\n  - value值支持读取properties文件中的属性值，通过类属性将properties中数据传入类中\n\n  - value值支持SpEL\n\n  - @value注解如果添加在属性上方，可以省略set方法（set方法的目的是为属性赋值）\n\n- 相关属性\n  - value（默认）：定义对应的属性值或参数值\n\n### 2.7)bean的引用类型属性注入\n\n- 名称：@Autowired、@Qualifier\n\n- 类型：**属性注解、方法注解**\n\n- 位置：属性定义上方，方法定义上方\n\n- 作用：设置对应属性的对象或对方法进行引用类型传参\n\n- 范例：\n\n  ```java\n  @Autowired(required = false)\n  @Qualifier("userDao")\n  private UserDao userDao;\n  ```\n\n- 说明：\n\n  - @Autowired默认按类型装配，指定@Qualifier后可以指定自动装配的bean的id\n\n- 相关属性\n  - required：定义该属性是否允许为null\n\n### 2.8)bean的引用类型属性注入\n\n- 名称：@Primary\n\n- 类型：**类注解**\n\n- 位置：类定义上方\n\n- 作用：设置类对应的bean按类型装配时优先装配\n\n- 范例：\n\n  ```java\n  @Primary\n  public class ClassName{}\n  ```\n\n- 说明：\n\n  - @Autowired默认按类型装配，当出现相同类型的bean，使用@Primary提高按类型自动装配的优先级，多个@Primary会导致优先级设置无效\n\n### 2.9)bean的引用类型属性注入\n\n- 名称：@Inject、@Named、@Resource\n\n- 说明：\n  - @Inject与@Named是JSR330规范中的注解，功能与@Autowired和@Qualifier完全相同，适用于不同架构场景\n  - @Resource是JSR250规范中的注解，可以简化书写格式\n\n- @Resource相关属性\n\n  - name：设置注入的bean的id\n\n  - type：设置注入的bean的类型，接收的参数为Class类型\n\n### 2.10)加载properties文件\n\n- 名称：@PropertySource\n\n- 类型：**类注解**\n\n- 位置：类定义上方\n\n- 作用：加载properties文件中的属性值\n\n- 范例：\n\n  ```java\n  @PropertySource(value = "classpath:filename.properties")\n  public class ClassName {\n      @Value("${propertiesAttributeName}")\n      private String attributeName;\n  }\n  ```\n\n- 说明：\n\n  - 不支持*通配格式，一旦加载，所有spring控制的bean中均可使用对应属性值\n\n- 相关属性\n\n  - value（默认）：设置加载的properties文件名\n\n  - ignoreResourceNotFound：如果资源未找到，是否忽略，默认为false\n\n### 2.11)纯注解格式\n\n- 名称：@Configuration、@ComponentScan\n\n- 类型：**类注解**\n\n- 位置：类定义上方\n\n- 作用：设置当前类为spring核心配置加载类\n\n- 范例：\n\n  ```java\n  @Configuration\n  @ComponentScan("scanPackageName")\n  public class SpringConfigClassName{\n  }\n  ```\n\n- 说明：\n\n  - 核心配合类用于替换spring核心配置文件，此类可以设置空的，不设置变量与属性\n\n  - bean扫描工作使用注解@ComponentScan替代\n\n**AnnotationConfigApplicationContext**\n\n- 加载纯注解格式上下文对象，需要使用AnnotationConfigApplicationContext\n\n  ```java\n  AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);\n  ```\n\n### 2.12)第三方bean配置与管理\n\n- 名称：@Import\n\n- 类型：**类注解**\n\n- 位置：类定义上方\n\n- 作用：导入第三方bean作为spring控制的资源\n\n- 范例：\n\n  ```java\n  @Configuration\n  @Import(OtherClassName.class)\n  public class ClassName {\n  }\n  ```\n\n- 说明：\n\n  - @Import注解在同一个类上，仅允许添加一次，如果需要导入多个，使用数组的形式进行设定\n\n  - 在被导入的类中可以继续使用@Import导入其他资源（了解）\n\n  - @Bean所在的类可以使用导入的形式进入spring容器，无需声明为bean\n\n## 3)bean加载控制\n\n### 3.1)依赖加载\n\n(1)@DependsOn\n\n- 名称：@DependsOn\n\n- 类型：类注解、方法注解\n\n- 位置：bean定义的位置（类上或方法上）\n\n- 作用：控制bean的加载顺序，使其在指定bean加载完毕后再加载\n\n- 范例：\n\n  ```java\n  @DependsOn("beanId")\n  public class ClassName {\n  }\n  ```\n\n- 说明：\n\n  - 配置在方法上，使@DependsOn指定的bean优先于@Bean配置的bean进行加载\n\n  - 配置在类上，使@DependsOn指定的bean优先于当前类中所有@Bean配置的bean进行加载\n\n  - 配置在类上，使@DependsOn指定的bean优先于@Component等配置的bean进行加载\n\n- 相关属性\n  - value（默认）：设置当前bean所依赖的bean的id\n\n(2)@Order\n\n- 名称：@Order\n\n- 类型：**配置类注解**\n\n- 位置：配置类定义的位置（类上）\n\n- 作用：控制配置类的加载顺序\n\n- 范例：\n\n  ```java\n  @Order(1)\n  public class SpringConfigClassName {\n  }\n  ```\n\n(3)@Lazy\n\n- 名称：@Lazy\n\n- 类型：**类注解、方法注解**\n\n- 位置：bean定义的位置（类上或方法上）\n\n- 作用：控制bean的加载时机，使其延迟加载\n\n- 范例：\n\n  ```java\n  @Lazy\n  public class ClassName {\n  }\n  ```\n\n### **3.2)依赖加载应用场景**\n\n@DependsOn\n\n- 微信订阅号，发布消息和订阅消息的bean的加载顺序控制\n\n- 双11活动期间，零点前是结算策略A，零点后是结算策略B，策略B操作的数据为促销数据。策略B加载顺序与促销数据的加载顺序\n\n@Lazy\n\n- 程序灾难出现后对应的应急预案处理是启动容器时加载时机\n\n@Order\n\n- 多个种类的配置出现后，优先加载系统级的，然后加载业务级的，避免细粒度的加载控制\n\n\n\n## 4)整合第三方技术\n\n### 4.1)综合案例改版（注解整合MyBatis）\n\n![1591024717408](./img/java/springmvc/Spring-day02/1591024717408.png)\n\n### 4.2)注解整合MyBatis分析\n\n- 业务类使用注解形式声明bean，属性采用注解注入\n\n- 建立独立的配置管理类，分类管理外部资源，根据功能进行分类，并提供对应的方法获取bean\n\n- 使用注解形式启动bean扫描，加载所有注解配置的资源（bean）\n\n- 使用AnnotationConfigApplicationContext对象加载所有的启动配置类，内部使用导入方式进行关联\n\n### 4.3)注解整合MyBatis步骤\n\n1.修改mybatis外部配置文件格式为注解格式\n\n2.业务类使用@Component声明bean，使用@Autowired注入对象\n\n3.建立配置文件JDBCConfig与MyBatisConfig类，并将其导入到核心配置类SpringConfig\n\n4.开启注解扫描\n\n5.使用AnnotationConfigApplicationContext对象加载配置项\n\n### 4.4)综合案例改版（注解整合Junit）\n\n1.Spring接管Junit的运行权，使用Spring专用的Junit类加载器\n\n2.为Junit测试用例设定对应的spring容器：\n\n- 从Spring5.0以后，要求Junit的版本必须是4.12及以上\n\n- Junit仅用于单元测试，不能将Junit的测试类配置成spring的bean，否则该配置将会被打包进入工程中 \n\n\n\n导入Spring整合Junit坐标\n\n```xml\n<dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.12</version>\n</dependency>\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-test</artifactId>\n    <version>5.1.9.RELEASE</version>\n</dependency>\n```\n\nSpring整合Junit测试用例注解格式\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(classes = SpringConfig.class)\npublic class UserServiceTest {\n}\n```\n\n## 5)IoC底层核心原理\n\n### 5.1)IoC核心接口\n\n![1591024936518](./img/java/springmvc/Spring-day02/1591024936518.png)\n\n### **5.2)组件扫描器**\n\n- 开发过程中，需要根据需求加载必要的bean，排除指定bean\n\n![1591024975438](./img/java/springmvc/Spring-day02/1591024975438.png)\n\n### **5.3)设定组件扫描加载过滤器**\n\n- 名称：@ComponentScan\n\n- 类型：**类注解**\n\n- 位置：类定义上方\n\n- 作用：设置spring配置加载类扫描规则\n\n- 范例：\n\n  ```java\n  @ComponentScan(\n      value="com.itheima",\t           //设置基础扫描路径\n      excludeFilters =                          //设置过滤规则，当前为排除过滤\n  \t@ComponentScan.Filter(            //设置过滤器\n  \t    type= FilterType.ANNOTATION,  //设置过滤方式为按照注解进行过滤\n  \t    classes=Repository.class)     //设置具体的过滤项，过滤所有@Repository修饰的bean\n      )\n  ```\n\n​\tincludeFilters：设置包含性过滤器\n\n​\texcludeFilters：设置排除性过滤器\n\n​\ttype：设置过滤器类型\n\n### **5.4)自定义组件过滤器**\n\n- 名称：TypeFilter\n\n- 类型：**接口**\n\n- 作用：自定义类型过滤器\n\n- 范例：\n\n  ```java\n  public class MyTypeFilter implements TypeFilter {\n      public boolean match(MetadataReader mr, MetadataReaderFactory mrf) throws IOException {\n          ClassMetadata cm = metadataReader.getClassMetadata();\n          tring className = cm.getClassName();\n          if(className.equals("com.itheima.dao.impl.BookDaoImpl")){\n              return false;\n          }\n          return false;\n      }\n  }\n  ```\n\n### **5.5)自定义导入器**\n\n- bean只有通过配置才可以进入spring容器，被spring加载并控制\n\n- 配置bean的方式如下：\n\n  - XML文件中使用<bean/>标签配置\n\n  - 使用@Component及衍生注解配置\n\n- 企业开发过程中，通常需要配置大量的bean，需要一种快速高效配置大量bean的方式\n\n**ImportSelector**\n\n- 名称： ImportSelector\n\n- 类型：**接口**\n\n- 作用：自定义bean导入器\n\n- 范例：\n\n  ```java\n  public class MyImportSelector implements ImportSelector {\n      public String[] selectImports(AnnotationMetadata icm) {\n          return new String[]{"com.itheima.dao.impl.AccountDaoImpl"};\n      }\n  }\n  ```\n\n  ```java\n  @Configuration\n  @ComponentScan("com.itheima")\n  @Import(MyImportSelector.class)\n  public class SpringConfig {\n  }\n  ```\n\n### **5.6)自定义注册器**\n\n- 名称：ImportBeanDefinitionRegistrar\n\n- 类型：**接口**\n\n- 作用：自定义bean定义注册器\n\n- 范例：\n\n  ```java\n  public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {\n      public void registerBeanDefinitions(AnnotationMetadata icm, BeanDefinitionRegistry r) {\n          ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(r, false);\n          TypeFilter tf = new TypeFilter() {\n              public boolean match(MetadataReader mr, MetadataReaderFactory mrf) throws IOException {\n                  return true;\n              }\n          };\n          scanner.addIncludeFilter(tf);\n          //scanner.addExcludeFilter(tf);\n          scanner.scan("com.itheima");\n      }\n  }\n  ```\n\n### 5.7)bean初始化过程解析\n\n![1591025338778](./img/java/springmvc/Spring-day02/1591025338778.png)\n\n### 5.8)bean初始化过程解析\n\n- BeanFactoryPostProcessor\n\n  - 作用：定义了在bean工厂对象创建后，bean对象创建前执行的动作，用于对工厂进行创建后业务处理\n\n  - 运行时机：当前操作用于对工厂进行处理，仅运行一次\n\n- BeanPostProcessor\n\n  - 作用：定义了所有bean初始化前后进行的统一动作，用于对bean进行创建前业务处理与创建后业务处理\n\n  - 运行时机：当前操作伴随着每个bean的创建过程，每次创建bean均运行该操作\n\n- InitializingBean\n\n  - 作用：定义了每个bean的初始化前进行的动作，属于非统一性动作，用于对bean进行创建前业务处理\n\n  - 运行时机：当前操作伴随着任意一个bean的创建过程，保障其个性化业务处理\n\n- 注意：上述操作均需要被spring容器加载放可运行\n\n### 5.9)bean初始化过程解析\n\n![1591025440019](./img/java/springmvc/Spring-day02/1591025440019.png)\n\n### 5.10)繁琐的bean初始化过程处理\n\n- FactoryBean\n  - 对单一的bean的初始化过程进行封装，达到简化配置的目的\n\n**FactoryBean与BeanFactory区别**\n\n- FactoryBean：封装单个bean的创建过程\n\n- BeanFactory：Spring容器顶层接口，定义了bean相关的获取操作\n\n',qr={data:function(){return{MainComponent:Lr}}},kr=qr,Br=Object(d["a"])(kr,Or,Pr,!1,null,"2f711389",null),_r=Br.exports,Fr=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},Hr=[],Nr='# AOP\n\n## 1)AOP简介\n\n### 1.1)OOP开发思路\n\n![1591281580135](./img/java/springmvc/Spring-day03/1591281580135.png)\n\n### 1.2)AOP开发思想\n\n![1591281706237](./img/java/springmvc/Spring-day03/1591281706237.png)\n\n### 1.3)AOP概念\n\n- AOP(Aspect Oriented Programing)面向切面编程，一种编程**范式**，隶属于软工范畴，指导开发者如何组织程序结构\n\n- AOP弥补了OOP的不足，基于OOP基础之上进行横向开发\n\n  - uOOP规定程序开发以类为主体模型，一切围绕对象进行，完成某个任务先构建模型\n\n  - uAOP程序开发主要关注基于OOP开发中的共性功能，一切围绕共性功能进行，完成某个任务先构建可能遇到的所有共性功能（当所有功能都开发出来也就没有共性与非共性之分）\n\n- “AOP联盟”\n\n### 1.4)AOP作用\n\n- 伴随着AOP时代的降临，可以从各个行业的标准化、规范化开始入手，一步一步将所有共性功能逐一开发完毕，最终以功能组合来完成个别业务模块乃至整体业务系统的开发\n\n- 目标：将软件开发由手工制作走向半自动化/全自动化阶段，实现“插拔式组件体系结构”搭建\n\n### 1.5)AOP优势\n\n- 提高代码的可重用性\n\n- 业务代码编码更简洁\n\n- 业务代码维护更高效\n\n- 业务功能扩展更便捷\n\n![1591281844901](./img/java/springmvc/Spring-day03/1591281844901.png)\n\n\n\n## 2)AOP入门案例\n\n### 2.1)AOP相关概念\n\n![1591281889446](./img/java/springmvc/Spring-day03/1591281889446.png)\n\n![1591281914574](./img/java/springmvc/Spring-day03/1591281914574.png)\n\n![1591281945260](./img/java/springmvc/Spring-day03/1591281945260.png)\n\n- Joinpoint(连接点)：就是方法\n\n- Pointcut(切入点)：就是挖掉共性功能的方法\n\n- Advice(通知)：就是共性功能，最终以一个方法的形式呈现\n\n- Aspect(切面)：就是共性功能与挖的位置的对应关系\n\n- Target(目标对象)：就是挖掉功能的方法对应的类产生的对象，这种对象是无法直接完成最终工作的\n\n- Weaving(织入)：就是将挖掉的功能回填的动态过程\n\n- Proxy(代理)：目标对象无法直接完成工作，需要对其进行功能回填，通过创建原始对象的代理对象实现\n\n- Introduction(引入/引介) ：就是对原始对象无中生有的添加成员变量或成员方法\n\n### 2.2)AOP开发过程\n\n- 开发阶段(开发者完成)\n\n  - 正常的制作程序\n\n  - 将非共性功能开发到对应的目标对象类中，并制作成切入点方法\n\n  - 将共性功能独立开发出来，制作成**通知**\n\n  - 在配置文件中，声明**切入点**\n\n  - 在配置文件中，声明**切入点**与**通知**间的关系（含**通知类型**），即**切面**\n\n- 运行阶段(AOP完成)\n\n  - Spring容器加载配置文件，监控所有配置的**切入点**方法的执行\n\n  - 当监控到**切入点**方法被运行，使用**代理**机制，动态创建**目标对象**的**代理对象**，根据**通知类别**，在**代理对象**的对应位置将**通知**对应的功能**织入**，完成完整的代码逻辑并运行\n\n### 2.2)AOP开发方式\n\n- XML方式\n\n- XML+注解方式\n\n- 注解方式\n\n### 2.3)入门案例制作分析\n\n1.导入相关坐标\n\n2.确认要抽取的功能，并将其制作成方法保存到专用的类中，删除原始业务中对应的功能\n\n3.将所有进行AOP操作的资源加载到IoC容器中\n\n4.使用配置的方式描述被抽取功能的位置，并描述被抽取功能与对应位置的关系\n\n5.运行程序\n\n\n\n步骤一 导入坐标\n\n```xml\n<dependency>\n    <groupId>org.aspectj</groupId>\n    <artifactId>aspectjweaver</artifactId>\n    <version>1.9.4</version>\n</dependency>\n```\n\n步骤二 在业务层抽取通用代码\n\n![1591282302976](./img/java/springmvc/Spring-day03/1591282302976.png)\n\n步骤三 把通知加入spring容器管理\n\n![1591282320624](./img/java/springmvc/Spring-day03/1591282320624.png)\n\n\n\n步骤四 在配置文件中配置aop的配置 \n\n```xml\n\x3c!--aop配置--\x3e\n<aop:config>\n    \x3c!--配置切入点--\x3e\n    <aop:pointcut id="pt" expression="execution(* *..*())"/>\n    \x3c!--配置切面--\x3e\n    <aop:aspect ref="myAdvice">\n        <!—通知与切入点之间的关系--\x3e\n        <aop:before method="logAdvice" pointcut-ref="pt"/>\n    </aop:aspect>\n</aop:config>\n```\n\n## 3)AOP配置（XML）\n\n### 3.1)**AspectJ**\n\n- Aspect（切面）用于描述切入点与通知间的关系，是AOP编程中的一个概念\n\n- AspectJ是基于java语言对Aspect的实现\n\n### 3.2)AOP配置\n\n#### 3.2.1)aop:config\n\n- 名称：aop:config\n\n- 类型：**标签**\n\n- 归属：beans标签\n\n- 作用：设置AOP\n\n- 格式：\n\n  ```xml\n  <beans>\n      <aop:config>……</aop:config>\n      <aop:config>……</aop:config>\n  </beans>\n  ```\n\n- 说明：一个beans标签中可以配置多个aop:config标签\n\n#### 3.2.2)aop:aspect\n\n- 名称：aop:aspect\n\n- 类型：**标签**\n\n- 归属：aop:config标签\n\n- 作用：设置具体的AOP通知对应的切入点\n\n- 格式：\n\n  ```xml\n  <aop:config>\n      <aop:aspect ref="beanId">……</aop:aspect>\n      <aop:aspect ref="beanId">……</aop:aspect>\n  </aop:config>\n  ```\n\n- 说明：\n\n  一个aop:config标签中可以配置多个aop:aspect标签\n\n- 基本属性：\n\n  - ref ：通知所在的bean的id\n\n#### 3.2.3)aop:pointcut\n\n- 名称：aop:pointcut\n\n- 类型：**标签**\n\n- 归属：aop:config标签、aop:aspect标签\n\n- 作用：设置切入点\n\n- 格式：\n\n  ```xml\n  <aop:config>\n      <aop:pointcut id="pointcutId" expression="……"/>\n      <aop:aspect>\n          <aop:pointcut id="pointcutId" expression="……"/>\n      </aop:aspect>\n  </aop:config>\n  ```\n\n- 说明：\n\n  一个aop:config标签中可以配置多个aop:pointcut标签，且该标签可以配置在aop:aspect标签内\n\n- 基本属性：\n\n  - id ：识别切入点的名称\n\n  - expression ：切入点表达式\n\n### **3.3)切入点**\n\n- 切入点描述的是某个方法\n\n- 切入点表达式是一个快速匹配方法描述的通配格式，类似于正则表达式\n\n### **3.4)切入点表达式的组成**\n\n- 切入点描述的是某个方法\n\n- 切入点表达式是一个快速匹配方法描述的通配格式，类似于正则表达式\n\n  ```xml\n  关键字（访问修饰符  返回值  包名.类名.方法名（参数）异常名）\n  ```\n\n​\t关键字：描述表达式的匹配模式（参看关键字列表）\n\n​\t访问修饰符：方法的访问控制权限修饰符\n\n​\t类名：方法所在的类（此处可以配置接口名称）\n\n​\t异常：方法定义中指定抛出的异常\n\n- 范例：\n\n  ```xml\n  execution（public User com.itheima.service.UserService.findById（int））\n  ```\n\n#### 3.4.1)切入点表达式——关键字\n\n- execution ：匹配执行指定方法\n\n- args ：匹配带有指定参数类型的方法\n\n- within ：…… \n\n- this ：…… \n\n- target ：…… \n\n- @within ：…… \n\n- @target ：…… \n\n- @args ：…… \n\n- @annotation ：…… \n\n- bean ：……\n\n- reference pointcut ：……\n\n#### 3.4.2)切入点表达式——**通配符**\n\n- *：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现\n\n  ```xml\n  execution（public * com.itheima.*.UserService.find*（*））\n  ```\n\n​\t匹配com.itheima包下的任意包中的UserService类或接口中所有find开头的带有一个参数的方法\n\n- .. ：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写\n\n  ```xml\n  execution（public User com..UserService.findById（..））\n  ```\n\n​\t匹配com包下的任意包中的UserService类或接口中所有名称为findById的方法\n\n- +：专用于匹配子类类型\n\n  ```xml\n  execution(* *..*Service+.*(..))\n  ```\n\n#### 3.4.3)切入点表达式——逻辑运算符\n\n- && ：连接两个切入点表达式，表示两个切入点表达式同时成立的匹配\n\n- || ：连接两个切入点表达式，表示两个切入点表达式成立任意一个的匹配\n\n- ! ：连接单个切入点表达式，表示该切入点表达式不成立的匹配\n\n#### 3.4.4)切入点表达式——范例\n\n```java\nexecution(* *(..))\nexecution(* *..*(..))\nexecution(* *..*.*(..))\nexecution(public * *..*.*(..))\nexecution(public int *..*.*(..))\nexecution(public void *..*.*(..))\nexecution(public void com..*.*(..)) \nexecution(public void com..service.*.*(..))\nexecution(public void com.itheima.service.*.*(..))\nexecution(public void com.itheima.service.User*.*(..))\nexecution(public void com.itheima.service.*Service.*(..))\nexecution(public void com.itheima.service.UserService.*(..))\nexecution(public User com.itheima.service.UserService.find*(..))\nexecution(public User com.itheima.service.UserService.*Id(..))\nexecution(public User com.itheima.service.UserService.findById(..))\nexecution(public User com.itheima.service.UserService.findById(int))\nexecution(public User com.itheima.service.UserService.findById(int,int))\nexecution(public User com.itheima.service.UserService.findById(int,*))\nexecution(public User com.itheima.service.UserService.findById(*,int))\nexecution(public User com.itheima.service.UserService.findById())\nexecution(List com.itheima.service.*Service+.findAll(..))\n```\n\n### **3.5)切入点的三种配置方式**\n\n```xml\n<aop:config>\n    \x3c!--配置公共切入点--\x3e\n    <aop:pointcut id="pt1" expression="execution(* *(..))"/>\n    <aop:aspect ref="myAdvice">\n        \x3c!--配置局部切入点--\x3e\n        <aop:pointcut id="pt2" expression="execution(* *(..))"/>\n        \x3c!--引用公共切入点--\x3e\n        <aop:before method="logAdvice" pointcut-ref="pt1"/>\n        \x3c!--引用局部切入点--\x3e\n        <aop:before method="logAdvice" pointcut-ref="pt2"/>\n        \x3c!--直接配置切入点--\x3e\n        <aop:before method="logAdvice" pointcut="execution(* *(..))"/>\n    </aop:aspect>\n</aop:config>\n```\n\n### **3.6)切入点配置经验**\n\n- 企业开发命名规范严格遵循规范文档进行\n\n- 先为方法配置局部切入点\n\n- 再抽取类中公共切入点\n\n- 最后抽取全局切入点\n\n- 代码走查过程中检测切入点是否存在越界性包含\n\n- 代码走查过程中检测切入点是否存在非包含性进驻\n\n- 设定AOP执行检测程序，在单元测试中监控通知被执行次数与预计次数是否匹配\n\n- 设定完毕的切入点如果发生调整务必进行回归测试\n\n（以上规则适用于XML配置格式）\n\n### **3.7)通知类型**\n\nAOP的通知类型共5种\n\n- 前置通知：原始方法执行前执行，如果通知中抛出异常，阻止原始方法运行\n\n  应用：数据校验\n\n- 后置通知：原始方法执行后执行，无论原始方法中是否出现异常，都将执行通知\n\n    应用：现场清理\n\n- 返回后通知：原始方法正常执行完毕并返回结果后执行，如果原始方法中抛出异常，无法执行\n\n    应用：返回值相关数据处理\n\n- 抛出异常后通知：原始方法抛出异常后执行，如果原始方法没有抛出异常，无法执行\n\n    应用：对原始方法中出现的异常信息进行处理\n\n- 环绕通知：在原始方法执行前后均有对应执行执行，还可以阻止原始方法的执行\n\n    应用：十分强大，可以做任何事情\n\n#### 3.7.1)aop:before\n\n- 名称：aop:before\n\n- 类型：**标签**\n\n- 归属：aop:aspect标签\n\n- 作用：设置前置通知\n\n- 格式：\n\n  ```xml\n  <aop:aspect ref="adviceId">\n      <aop:before method="methodName" pointcut="……"/>\n  </aop:aspect>\n  ```\n\n-  说明：一个aop:aspect标签中可以配置多个aop:before标签\n\n- 基本属性：\n\n  - method ：在通知类中设置当前通知类别对应的方法\n\n  - pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突\n\n  - pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突\n\n#### 3.7.2)aop:after\n\n- 名称：aop:after\n\n- 类型：**标签**\n\n- 归属：aop:aspect标签\n\n- 作用：设置后置通知\n\n- 格式：\n\n  ```xml\n  <aop:aspect ref="adviceId">\n      <aop:after method="methodName" pointcut="……"/>\n  </aop:aspect>\n  ```\n\n-  说明：一个aop:aspect标签中可以配置多个aop:after标签\n\n- 基本属性：\n\n  - method ：在通知类中设置当前通知类别对应的方法\n\n  - pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突\n\n  - pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突\n\n#### 3.7.3)aop:after-returning\n\n- 名称：aop:after-returning\n\n- 类型：**标签**\n\n- 归属：aop:aspect标签\n\n- 作用：设置返回后通知\n\n- 格式：\n\n  ```xml\n  <aop:aspect ref="adviceId">\n      <aop:after-returning method="methodName" pointcut="……"/>\n  </aop:aspect>\n  ```\n\n-  说明：一个aop:aspect标签中可以配置多个aop:after-returning标签\n\n- 基本属性：\n\n  - method ：在通知类中设置当前通知类别对应的方法\n\n  - pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突\n\n  - pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突\n\n#### 3.7.4)aop:after-throwing\n\n- 名称：aop:after-throwing\n\n- 类型：**标签**\n\n- 归属：aop:aspect标签\n\n- 作用：设置抛出异常后通知\n\n- 格式：\n\n  ```xml\n  <aop:aspect ref="adviceId">\n      <aop:after-throwing method="methodName" pointcut="……"/>\n  </aop:aspect>\n  ```\n\n-  说明：一个aop:aspect标签中可以配置多个aop:after-throwing标签\n\n- 基本属性：\n\n  - method ：在通知类中设置当前通知类别对应的方法\n\n  - pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突\n\n  - pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突\n\n#### 3.7.5)aop:around\n\n- 名称：aop:around\n\n- 类型：**标签**\n\n- 归属：aop:aspect标签\n\n- 作用：设置环绕通知\n\n- 格式：\n\n  ```xml\n  <aop:aspect ref="adviceId">\n      <aop:around method="methodName" pointcut="……"/>\n  </aop:aspect>\n  ```\n\n-  说明：一个aop:aspect标签中可以配置多个aop:around标签\n\n- 基本属性：\n\n  - method ：在通知类中设置当前通知类别对应的方法\n\n  - pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突\n\n  - pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突\n\n环绕通知的开发方式\n\n- 环绕通知是在原始方法的前后添加功能，在环绕通知中，存在对原始方法的显式调用\n\n  ```java\n  public Object around(ProceedingJoinPoint pjp) throws Throwable {\n      Object ret = pjp.proceed();\n      return ret;\n  }\n  ```\n\n- 环绕通知方法相关说明：\n\n  - 方法须设定Object类型的返回值，否则会拦截原始方法的返回。如果原始方法返回值类型为void，通知方\t也可以设定返回值类型为void，最终返回null\n\n  - 方法需在第一个参数位置设定ProceedingJoinPoint对象，通过该对象调用proceed()方法，实现对原始方法的调用。如省略该参数，原始方法将无法执行\n\n  - 使用proceed()方法调用原始方法时，因无法预知原始方法运行过程中是否会出现异常，强制抛出Throwable对象，封装原始方法中可能出现的异常信息\n\n### **3.8)通知顺序（了解）**\n\n当同一个切入点配置了多个通知时，通知会存在运行的先后顺序，该顺序以通知配置的顺序为准\n\n### **3.9)通知获取数据**\n\n- 参数\n\n- 返回值\n\n- 异常\n\n#### **3.9.1)通知获取参数数据**\n\n第一种情况：\n\n- 设定通知方法第一个参数为JoinPoint，通过该对象调用getArgs()方法，获取原始方法运行的参数数组\n\n  ```java\n  public void before(JoinPoint jp) throws Throwable {\n      Object[] args = jp.getArgs();\n  }\n  ```\n\n- 所有的通知均可以获取参数\n\n第二种情况：\n\n- 设定切入点表达式为通知方法传递参数（锁定通知变量名）\n\n- 原始方法\n\n![1591284387913](./img/java/springmvc/Spring-day03/1591284387913.png)\n\n第三种情况\n\n- 设定切入点表达式为通知方法传递参数（改变通知变量名的定义顺序）\n\n- 原始方法\n\n![1591284429541](./img/java/springmvc/Spring-day03/1591284429541.png)\n\n#### **3.9.2)通知获取返回值数据**\n\n第一种：返回值变量名\n\n- 设定返回值变量名\n\n- 原始方法\n\n  ```java\n  public int save() {\n  \tSystem.out.println("user service running...");\n      return 100;\n  }\n  ```\n\n-  AOP配置\n\n  ```xml\n  <aop:aspect ref="myAdvice">\n      <aop:pointcut id="pt3" expression="execution(* *(..))  "/>\n      <aop:after-returning method="afterReturning" pointcut-ref="pt3" returning="ret"/>\n  </aop:aspect>\n  ```\n\n- 通知类\n\n  ```java\n  public void afterReturning(Object ret) {\n      System.out.println(ret);\n  }\n  ```\n\n- 适用于返回后通知（after-returning）\n\n第二种：\n\n- 在通知类的方法中调用原始方法获取返回值\n\n- 原始方法\n\n  ```java\n  public int save() {\n      System.out.println("user service running...");\n      return 100;\n  }\n  ```\n\n- AOP配置l\n\n  ```xml\n  <aop:aspect ref="myAdvice">\n      <aop:pointcut id="pt2" expression="execution(* *(..))  "/>\n      <aop:around method="around" pointcut-ref="pt2" />\n  </aop:aspect>\n  ```\n\n- 通知类\n\n  ```java\n  public Object around(ProceedingJoinPoint pjp) throws Throwable {\n      Object ret = pjp.proceed();\n      return ret;\n  }\n  ```\n\n- 适用于环绕通知（around）\n\n#### **3.9.3)通知获取异常数据**\n\n第一种：通知类的方法中调用原始方法捕获异常\n\n- 在通知类的方法中调用原始方法捕获异常\n\n- 原始方法\n\n  ```java\n  public void save() {\n      System.out.println("user service running...");\n      int i = 1/0;\n  }\n  ```\n\n-  AOP配置\n\n  ```xml\n  <aop:aspect ref="myAdvice">\n      <aop:pointcut id="pt4" expression="execution(* *(..))  "/>\n      <aop:around method="around" pointcut-ref="pt4" />\n  </aop:aspect>\n  ```\n\n- 通知类\n\n  ```java\n  public Object around(ProceedingJoinPoint pjp) throws Throwable {\n      Object ret = pjp.proceed();\t//对此处调用进行try……catch……捕获异常，或抛出异常\n      return ret;\n  }\n  ```\n\n- 适用于环绕通知（around）\n\n第二种：\n\n- 设定异常对象变量名\n\n- 原始方法\n\n  ```java\n  public void save() {\n      System.out.println("user service running...");\n      int i = 1/0;\n  }\n  ```\n\n-  AOP配置\n\n  ```xml\n  <aop:aspect ref="myAdvice">\n  \t<aop:pointcut id="pt4" expression="execution(* *(..))  "/>\n      <aop:after-throwing method="afterThrowing" pointcut-ref="pt4" throwing="t"/>\n  </aop:aspect>\n  ```\n\n- 通知类\n\n  ```java\n  public void afterThrowing(Throwable t){\n      System.out.println(t.getMessage());\n  }\n  ```\n\n- 适用于返回后通知（after-throwing）\n\n## 4)AOP配置（注解）\n\n### 4.1)AOP配置\n\n![1591285050618](./img/java/springmvc/Spring-day03/1591285050618.png)\n\n### 4.2)注解开发AOP制作步骤\n\n在XML格式基础上\n\n- 导入坐标（伴随spring-context坐标导入已经依赖导入完成）\n\n- 开启AOP注解支持\n\n- 配置切面@Aspect\n\n- 定义专用的切入点方法，并配置切入点@Pointcut\n\n- 为通知方法配置通知类型及对应切入点@Before\n\n### 4.3)注解开发AOP注意事项\n\n1.切入点最终体现为一个方法，无参无返回值，无实际方法体内容，但不能是抽象方法\n\n2.引用切入点时必须使用方法调用名称，方法后面的（）不能省略\n\n3.切面类中定义的切入点只能在当前类中使用，如果想引用其他类中定义的切入点使用“类名.方法名()”引用\n\n4.可以在通知类型注解后添加参数，实现XML配置中的属性，例如after-returning后的returning属性\n\n![1591285152119](./img/java/springmvc/Spring-day03/1591285152119.png)\n\n### 4.4)AOP注解详解\n\n#### 4.4.1)@Aspect\n\n- 名称：@Aspect\n\n- 类型：**注解**\n\n- 位置：类定义上方\n\n- 作用：设置当前类为切面类\n\n- 格式：\n\n  ```java\n  @Aspect\n  public class AopAdvice {\n  }\n  ```\n\n- 说明：一个beans标签中可以配置多个aop:config标签\n\n#### 4.4.2)@Pointcut\n\n- 名称：@Pointcut\n\n- 类型：**注解**\n\n- 位置：方法定义上方\n\n- 作用：使用当前方法名作为切入点引用名称\n\n- 格式：\n\n  ```java\n  @Pointcut("execution(* *(..))")\n  public void pt() {\n  }\n  ```\n\n- 说明：被修饰的方法忽略其业务功能，格式设定为无参无返回值的方法，方法体内空实现（非抽象）\n\n#### 4.4.3)@Before\n\n- 名称：@Before\n\n- 类型：**注解**\n\n- 位置：方法定义上方\n\n- 作用：标注当前方法作为前置通知\n\n- 格式：\n\n  ```java\n  @Before("pt()")\n  public void before(){\n  }\n  ```\n\n- 特殊参数：\n\n  - 无\n\n#### 4.4.4)@After\n\n- 名称：@After\n\n- 类型：**注解**\n\n- 位置：方法定义上方\n\n- 作用：标注当前方法作为后置通知\n\n- 格式：\n\n  ```java\n  @After("pt()")\n  public void after(){\n  }\n  ```\n\n- 特殊参数：\n\n  - 无\n\n#### 4.4.5)@AfterReturning\n\n- 名称：@AfterReturning\n\n- 类型：**注解**\n\n- 位置：方法定义上方\n\n- 作用：标注当前方法作为返回后通知\n\n- 格式：\n\n  ```java\n  @AfterReturning(value="pt()",returning = "ret")\n  public void afterReturning(Object ret) {\n  }\n  ```\n\n- 特殊参数：\n\n  - returning ：设定使用通知方法参数接收返回值的变量名\n\n#### 4.4.6)@AfterThrowing\n\n- 名称：@AfterThrowing\n\n- 类型：**注解**\n\n- 位置：方法定义上方\n\n- 作用：标注当前方法作为异常后通知\n\n- 格式：\n\n  ```java\n  @AfterThrowing(value="pt()",throwing = "t")\n  public void afterThrowing(Throwable t){\n  }\n  ```\n\n- 特殊参数：\n\n  - throwing ：设定使用通知方法参数接收原始方法中抛出的异常对象名\n\n#### 4.4.7)@Around\n\n- 名称：@Around\n\n- 类型：**注解**\n\n- 位置：方法定义上方\n\n- 作用：标注当前方法作为环绕通知\n\n- 格式：\n\n  ```java\n  @Around("pt()")\n  public Object around(ProceedingJoinPoint pjp) throws Throwable {\n      Object ret = pjp.proceed();\n      return ret;\n  }\n  ```\n\n- 特殊参数：\n\n  - 无\n\n### 4.5)AOP注解开发通知执行顺序控制（了解）\n\n1.AOP使用XML配置情况下，通知的执行顺序由配置顺序决定，在注解情况下由于不存在配置顺序的概念的概念，参照通知所配置的方法名字符串对应的编码值顺序，可以简单理解为字母排序\n\n- 同一个通知类中，相同通知类型以方法名排序为准\n\n- 不同通知类中，以类名排序为准\n\n- 使用@Order注解通过变更bean的加载顺序改变通知的加载顺序\n\n2.企业开发经验\n\n- 通知方法名由3部分组成，分别是前缀、顺序编码、功能描述\n\n- 前缀为固定字符串，例如baidu、itheima等，无实际意义\n\n- 顺序编码为6位以内的整数，通常3位即可，不足位补0\n\n- 功能描述为该方法对应的实际通知功能，例如exception、strLenCheck\n\n  - 制通知执行顺序使用顺序编码控制，使用时做一定空间预留\n\n  - 003使用，006使用，预留001、002、004、005、007、008\n\n  - 使用时从中段开始使用，方便后期做前置追加或后置追加\n\n  - 最终顺序以运行顺序为准，以测试结果为准，不以设定规则为准\n\n### 4.6)AOP注解驱动\n\n- 名称：@EnableAspectJAutoProxy\n\n- 类型：**注解**\n\n- 位置：Spring注解配置类定义上方\n\n- 作用：设置当前类开启AOP注解驱动的支持，加载AOP注解\n\n- 格式：\n\n  ```java\n  @Configuration\n  @ComponentScan("com.itheima")\n  @EnableAspectJAutoProxy\n  public class SpringConfig {\n  }\n  ```\n\n## 5)综合案例\n\n### **5.1)案例介绍**\n\n对项目进行业务层接口执行监控，测量业务层接口的执行效率\n\n```java\npublic interface AccountService {\n    void save(Account account);\n    void delete(Integer id);\n    void update(Account account);\n    List<Account> findAll();\n    Account findById(Integer id);\n}\n```\n\n### **5.2)案例分析**\n\n- 测量接口执行效率：接口方法执行前后获取执行时间，求出执行时长\n  - System.currentTimeMillis( )\n\n- 对项目进行监控：项目中所有接口方法，AOP思想，执行期动态织入代码\n\n  - 环绕通知\n\n  - proceed()方法执行前后获取系统时间\n\n### **5.3)案例制作步骤**\n\n- 定义切入点（务必要绑定到接口上，而不是接口实现类上）\n\n- 制作AOP环绕通知，完成测量功能\n\n- 注解配置AOP\n\n- 开启注解驱动支持\n\n### **5.4)案例制作核心代码**\n\n```java\npublic class RunTimeMonitorAdvice {\n    //拦截所有的业务层接口中查询操作的执行\n    @Pointcut("execution(* com.itheima.service.*Service.find*(..))")\n    public void pt(){}\n    @Around("pt()")\n    public Object runtimeMonitor(ProceedingJoinPoint pjp) throws Throwable {\n        //获取执行签名信息\n        Signature signature = pjp.getSignature();\n        //通过签名获取执行类型（接口名）\n        String targetClass = signature.getDeclaringTypeName();\n        //通过签名获取执行操作名称（方法名）\n        String targetMethod = signature.getName();\n        //获取操作前系统时间beginTime\n        long beginTime = System.currentTimeMillis();\n        Object ret = pjp.proceed(pjp.getArgs());\n        //获取操作后系统时间endTime\n        long endTime = System.currentTimeMillis();\n        System.out.println(targetClass+" 中 "+targetMethod+" 运行时长 "+(endTime-beginTime)+"ms");\n        return ret;\n    }\n}\n```\n\n### **5.5)案例后续思考与设计**\n\n- 测量真实性\n\n  - 开发测量是隔离性反复执行某个操作，是理想情况，上线测量差异过大\n\n  - 上线测量服务器性能略低于单机开发测量\n\n  - 上线测量基于缓存的性能查询要优于数据库查询测量\n\n  - 上线测量接口的性能与最终对外提供的服务性能差异过大\n\n  - 当外部条件发生变化（硬件），需要进行回归测试，例如数据库迁移\n\n- 测量结果展示\n\n  - 测量结果无需每一个都展示，需要设定检测阈值\n\n  - 阈值设定要根据业务进行区分，一个复杂的查询与简单的查询差异化很大\n\n  - 阈值设定需要做独立的配置文件或通过图形工具配置（工具级别的开发）\n\n  - 配合图形界面展示测量结果\n\n\n\n## 6)AOP底层原理\n\n- 静态代理\n\n- 动态代理——Proxy\n\n- 动态代理——CGLIB\n\n- 织入形式\n\n### **6.1)静态代理**\n\n装饰者模式（Decorator Pattern）：在不惊动原始设计的基础上，为其添加功能\n\n![1591287238806](./img/java/springmvc/Spring-day03/1591287238806.png)\n\n```java\npublic class UserServiceDecorator implements UserService{\n    private UserService userService;\n    public UserServiceDecorator(UserService userService) {\n        this.userService = userService;\n    }\n    public void save() {\n        //原始调用\n        userService.save();\n        //增强功能（后置）\n        System.out.println("刮大白");\n    }\n}\n```\n\n### 6.2)动态代理——JDK Proxy\n\nJDKProxy动态代理是针对对象做代理，要求原始对象具有接口实现，并对接口方法进行增强\n\n```java\npublic class UserServiceJDKProxy {\n    public UserService createUserServiceJDKProxy(final UserService userService){\n        //获取被代理对象的类加载器\n        ClassLoader classLoader = userService.getClass().getClassLoader();\n        //获取被代理对象实现的接口\n        Class[] classes = userService.getClass().getInterfaces();\n        //对原始方法执行进行拦截并增强\n        InvocationHandler ih = new InvocationHandler() {\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                //前置增强内容\n                Object ret = method.invoke(userService, args);\n                //后置增强内容\n                System.out.println("刮大白2");\n                return ret;\n            }\n        };\n        //使用原始被代理对象创建新的代理对象\n        UserService proxy = (UserService) Proxy.newProxyInstance(classLoader,classes,ih);\n        return proxy;\n    }\n}\n```\n\n### 6.3)动态代理——CGLIB\n\n- CGLIB(Code Generation Library)，Code生成类库\n\n- CGLIB动态代理不限定是否具有接口，可以对任意操作进行增强\n\n- CGLIB动态代理无需要原始被代理对象，动态创建出新的代理对象\n\n![1591287441096](./img/java/springmvc/Spring-day03/1591287441096.png)\n\n```java\npublic class UserServiceImplCglibProxy {\n    public static UserServiceImpl createUserServiceCglibProxy(Class clazz){\n        //创建Enhancer对象（可以理解为内存中动态创建了一个类的字节码）\n        Enhancer enhancer = new Enhancer();\n        //设置Enhancer对象的父类是指定类型UserServerImpl\n        enhancer.setSuperclass(clazz);\n        Callback cb = new MethodInterceptor() {\n            public Object intercept(Object o, Method m, Object[] a, MethodProxy mp) throws Throwable {\n                Object ret = mp.invokeSuper(o, a);\n                if(m.getName().equals("save")) {\n                    System.out.println("刮大白");\n                }\n                return ret;\n            }\n        };\n        //设置回调方法\n        enhancer.setCallback(cb);\n        //使用Enhancer对象创建对应的对象\n        return (UserServiceImpl)enhancer.create();\n    }\n}\n```\n\n### **6.4)代理模式的选择**\n\nSpirng可以通过配置的形式控制使用的代理形式，默认使用jdkproxy，通过配置可以修改为使用cglib\n\n- XML配置\n\n  ```xml\n  \x3c!--XMP配置AOP--\x3e\n  <aop:config proxy-target-class="false">\v</aop:config>\n  ```\n\n- XML注解支持\n\n  ```xml\n  \x3c!--注解配置AOP--\x3e\n  <aop:aspectj-autoproxy proxy-target-class="false"/>\n  ```\n\n- 注解驱动\n\n  ```java\n  //注解驱动\n  @EnableAspectJAutoProxy(proxyTargetClass = true)\n  ```\n\n### **6.5)织入时机**\n\n![1591287839941](./img/java/springmvc/Spring-day03/1591287839941.png)',Jr={data:function(){return{MainComponent:Nr}}},Ur=Jr,Gr=Object(d["a"])(Ur,Fr,Hr,!1,null,"b14069ae",null),Vr=Gr.exports,zr=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},Wr=[],Qr='# spring 事务\n\n## 1)事务回顾\n\n### 1.1)什么是事务？\n\n事务指数据库中多个操作合并在一起形成的操作序列\n\n### 1.2)事务的作用\n\n1.当数据库操作序列中个别操作失败时，提供一种方式使数据库状态恢复到正常状态（**A**），保障数据库即使在异常状态下仍能保持数据一致性（**C**）（要么操作前状态，要么操作后状态）。\n\n2.当出现并发访问数据库时，在多个访问间进行相互隔离，防止并发访问操作结果互相干扰（**I**）。\n\n- 事务特征（ACID）\n\n  - 原子性（Atomicity）指事务是一个不可分割的整体，其中的操作要么全执行或全不执行\n\n  - 一致性（Consistency）事务前后数据的完整性必须保持一致\n\n  - 隔离性（Isolation）事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离\n\n  - 持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响\n\n### 1.3)事务的隔离级\n\n- 脏读：允许读取未提交的信息\n\n  - 原因：Read uncommitted\n\n  解决方案： （表级读锁）\n\n![1591321851725](./img/java/springmvc/Spring-day04/1591321851725.png)\n\n- 不可重复读：读取过程中单个数据发生了变化\n  - 解决方案： Repeatable read （行级写锁）\n\n![1591321927034](./img/java/springmvc/Spring-day04/1591321927034.png)\n\n- 幻读：读取过程中数据条目发生了变化\n  - 解决方案： Serializable（表级写锁）\n\n![1591321959641](./img/java/springmvc/Spring-day04/1591321959641.png)\n\n\n\n## 2)事务管理\n\n### 2.1)**Spring**事务核心对象\n\n- J2EE开发使用分层设计的思想进行，对于简单的业务层转调数据层的单一操作，事务开启在业务层或者数据层并无太大差别，当业务中包含多个数据层的调用时，需要在业务层开启事务，对数据层中多个操作进行组合并归属于同一个事务进行处理\n\n- Spring为业务层提供了整套的事务解决方案\n\n  - PlatformTransactionManager\n  - TransactionDefinition\n\n  - TransactionStatus\n\n### **2.2)PlatformTransactionManager**\n\n- 平台事务管理器实现类\n\n  - DataSourceTransactionManager  适用于Spring JDBC或MyBatis\n\n  - HibernateTransactionManager  适用于Hibernate3.0及以上版本\n\n  - JpaTransactionManager  适用于JPA\n\n  - JdoTransactionManager  适用于JDO\n\n  - JtaTransactionManager  适用于JTA\n\n\n\n- JPA（Java Persistence API）Java EE 标准之一，为POJO提供持久化标准规范，并规范了持久化开发的统一API，符合JPA规范的开发可以在不同的JPA框架下运行\n\n- JDO(Java Data Object )是Java对象持久化规范，用于存取某种数据库中的对象，并提供标准化API。与JDBC相比，JDBC仅针对关系数据库进行操作，JDO可以扩展到关系数据库、文件、XML、对象数据库（ODBMS）等，可移植性更强\n\n- JTA（Java Transaction API）Java EE 标准之一，允许应用程序执行分布式事务处理。与JDBC相比，JDBC事务则被限定在一个单一的数据库连接，而一个JTA事务可以有多个参与者，比如JDBC连接、JDO 都可以参与到一个JTA事务中\n\n此接口定义了事务的基本操作\n\n- 获取事务 ：\n\n  ```java\n  TransactionStatus getTransaction(TransactionDefinition definition)\n  ```\n\n- 提交事务 ：\n\n  ```java\n  void commit(TransactionStatus status) \n  ```\n\n- 回滚事务 ：\n\n  ```java\n  void rollback(TransactionStatus status)\n  ```\n\n### **2.3)TransactionDefinition**\n\n此接口定义了事务的基本信息\n\n- 获取事务定义名称\n\n  ```java\n  String getName()\n  ```\n\n- 获取事务的读写属性\n\n  ```java\n  boolean isReadOnly()\n  ```\n\n- 获取事务隔离级别\n\n  ```java\n  int getIsolationLevel()\n  ```\n\n- 获事务超时时间\n\n  ```java\n  int getTimeout()\n  ```\n\n- 获取事务传播行为特征\n\n  ```java\n  int getPropagationBehavior()\n  ```\n\n### **2.4)TransactionStatus**\n\n此接口定义了事务在执行过程中某个时间点上的状态信息及对应的状态操作\n\n![1591322466820](./img/java/springmvc/Spring-day04/1591322466820.png)\n\n### **2.5)事务控制方式**\n\n- 编程式\n\n- 声明式（XML）\n\n- 声明式（注解）\n\n### **2.6)案例说明**\n\n#### 2.6.1)案例说明\n\n银行转账业务说明\n\n银行转账操作中，涉及从A账户到B账户的资金转移操作。数据层仅提供单条数据的基础操作，未设计多账户间的业务操作。\n\n#### 2.6.2)案例环境（基于Spring、Mybatis整合）\n\n- 业务层接口提供转账操作\n\n```java\n/**\n* 转账操作\n* @param outName     出账用户名\n* @param inName      入账用户名\n* @param money       转账金额\n*/\npublic void transfer(String outName,String inName,Double money);\n```\n\n- 业务层实现提供转账操作\n\n```java\npublic void transfer(String outName,String inName,Double money){\n    accountDao.inMoney(outName,money);                                                       accountDao.outMoney(inName,money);\n}\n```\n\n- 数据层提供对应的入账与出账操作\n\n```xml\n<update id="inMoney">\n\tupdate account set money = money + #{money} where name = #{name}\n</update>\n<update id="outMoney">\n\tupdate account set money = money - #{money} where name = #{name}\n</update>\n```\n\n#### **2.6.3)编程式事务**\n\n```java\npublic void transfer(String outName,String inName,Double money){\n    //创建事务管理器\n    DataSourceTransactionManager dstm = new DataSourceTransactionManager();\n    //为事务管理器设置与数据层相同的数据源\n    dstm.setDataSource(dataSource);\n    //创建事务定义对象\n    TransactionDefinition td = new DefaultTransactionDefinition();\n    //创建事务状态对象，用于控制事务执行\n    TransactionStatus ts = dstm.getTransaction(td);\n    accountDao.inMoney(outName,money);\n    int i = 1/0;    //模拟业务层事务过程中出现错误\n    accountDao.outMoney(inName,money);\n    //提交事务\n    dstm.commit(ts);\n}\n```\n\n### 2.7)使用AOP控制事务\n\n将业务层的事务处理功能抽取出来制作成AOP通知，利用环绕通知运行期动态织入\n\n```java\npublic Object tx(ProceedingJoinPoint pjp) throws Throwable {\n    \n    DataSourceTransactionManager dstm = new DataSourceTransactionManager();\n    dstm.setDataSource(dataSource);\n    TransactionDefinition td = new DefaultTransactionDefinition();\n    TransactionStatus ts = dstm.getTransaction(td);\n    Object ret = pjp.proceed(pjp.getArgs());\n    dstm.commit(ts);\n    \n    return ret;\n}\n```\n\n配置AOP通知类，并注入dataSource\n\n```xml\n<bean id="txAdvice" class="com.itheima.aop.TxAdvice">\n    <property name="dataSource" ref="dataSource"/>\n</bean>\n```\n\n使用环绕通知将通知类织入到原始业务对象执行过程中\n\n```xml\n<aop:config>\n    <aop:pointcut id="pt" expression="execution(* *..transfer(..))"/>\n    <aop:aspect ref="txAdvice">\n        <aop:around method="tx" pointcut-ref="pt"/>\n    </aop:aspect>\n</aop:config>\n```\n\n### **2.8声明式事务（XML）**\n\n**AOP**配置事务是否具有特例性？\n\n```java\npublic Object tx(ProceedingJoinPoint pjp) throws Throwable {\n    DataSourceTransactionManager dstm = new DataSourceTransactionManager();\n    dstm.setDataSource(dataSource);\n    TransactionDefinition td = new DefaultTransactionDefinition();\n    TransactionStatus ts = dstm.getTransaction(td);\n    Object ret = pjp.proceed(pjp.getArgs());\n    dstm.commit(ts);\n\n    return ret;\n}\n```\n\n```xml\n<bean id="txAdvice" class="com.itheima.aop.TxAdvice">\n\t<property name="dataSource" ref="dataSource"/>\n</bean>\n```\n\n使用tx命名空间配置事务专属通知类\n\n```xml\n<tx:advice id="txAdvice" transaction-manager="txManager">\n    <tx:attributes>\n        <tx:method name="*" read-only="false" />\n        <tx:method name="get*" read-only="true" />\n        <tx:method name="find*" read-only="true" />\n    </tx:attributes>\n</tx:advice>\n```\n\n使用aop:advisor在AOP配置中引用事务专属通知类\n\n```xml\n<aop:config>\n    <aop:pointcut id="pt" expression="execution(* *..*(..))"/>\n    <aop:advisor advice-ref="txAdvice" pointcut-ref="pt"/>\n</aop:config>\n```\n\n#### 2.8.1)**aop:advice与aop:advisor区别**\n\n- aop:advice配置的通知类可以是普通java对象，不实现接口，也不使用继承关系\n\n- aop:advisor配置的通知类必须实现通知接口\n\n  - MethodBeforeAdvice\n\n  - AfterReturningAdvice\n\n  - ThrowsAdvice\n\n  - ……\n\n#### 2.8.2)tx配置----tx:advice\n\n- 名称：tx:advice\n\n- 类型：**标签**\n\n- 归属：beans标签\n\n- 作用：专用于声明事务通知\n\n- 格式：\n\n  ```xml\n  <beans>\n      <tx:advice id="txAdvice" transaction-manager="txManager">\n      </tx:advice>\n  </beans>\n  ```\n\n- 基本属性：\n\n  - id ：用于配置aop时指定通知器的id\n\n  - transaction-manager ：指定事务管理器bean\n\n#### 2.8.3)tx配置----tx:attributes\n\n- 名称：tx:attributes\n\n- 类型：**标签**\n\n- 归属：tx:advice标签\n\n- 作用：定义通知属性\n\n- 格式：\n\n  ```xml\n  <tx:advice id="txAdvice" transaction-manager="txManager">\n      <tx:attributes>\n      </tx:attributes>\n  </tx:advice>\n  ```\n\n- 基本属性：\n\n  - 无\n\n#### 2.8.4)tx配置----tx:method\n\n- 名称：tx:method\n\n- 类型：**标签**\n\n- 归属：tx:attribute标签\n\n- 作用：设置具体的事务属性\n\n- 格式：\n\n  ```xml\n  <tx:attributes>\n      <tx:method name="*" read-only="false" />\n      <tx:method name="get*" read-only="true" />\n  </tx:attributes>\n  ```\n\n- 说明：\n\n  通常事务属性会配置多个，包含1个读写的全事务属性，1个只读的查询类事务属性\n\n**tx:method属性**\n\n![1591367291135](./img/java/springmvc/Spring-day04/1591367291135.png)\n\n### **2.9)事务传播行为**\n\n- 事务管理员\n\n- 事务协调员\n\n![1591367347482](./img/java/springmvc/Spring-day04/1591367347482.png)\n\n- 事务传播行为描述的是事务协调员对事务管理员所携带事务的处理态度\n\n### **2.10)事务传播行为**\n\n![1591367375088](./img/java/springmvc/Spring-day04/1591367375088.png)\n\n### **2.11)事务传播应用**\n\n- 场景A：生成订单业务\n\n  - 子业务S1：记录日志到数据库表X\n\n  - 子业务S2：保存订单数据到数据库表Y\n\n  - 子业务S3：……\n\n  - 如果S2或S3或……事务提交失败，此时S1是否回滚？如何控制？\n\n  - （S1需要新事务）\n\n- 场景B：生成订单业务\n\n  - 背景1：订单号生成依赖数据库中一个专门用于控制订单号编号生成的表M获取\n\n  - 背景2：每次获取完订单号，表M中记录的编号自增1\n\n  - 子业务S1：从表M中获取订单编号\n\n  - 子业务S2：保存订单数据，订单编号来自于表M\n\n  - 子业务S3：……\n\n  - 如果S2或S3或……事务提交失败，此时S1是否回滚？如何控制？\n\n  - （S1需要新事务）\n\n### **2.12)声明式事务（注解）**\n\n#### 2.12.1)@Transactional\n\n- 名称：@Transactional\n\n- 类型：**方法注解，类注解，接口注解**\n\n- 位置：方法定义上方，类定义上方，接口定义上方\n\n- 作用：设置当前类/接口中所有方法或具体方法开启事务，并指定相关事务属性\n\n- 范例：\n\n  ```java\n  @Transactional(\n      readOnly = false,\n      timeout = -1,\n      isolation = Isolation.DEFAULT,\n      rollbackFor = {ArithmeticException.class, IOException.class},\n      noRollbackFor = {},\n      propagation = Propagation.REQUIRES_NEW\n  )\n  ```\n\n#### 2.12.2)tx:annotation-driven\n\n- 名称：tx:annotation-driven\n\n- 类型：**标签**\n\n- 归属：beans标签\n\n- 作用：开启事务注解驱动，并指定对应的事务管理器\n\n- 范例：\n\n  ```xml\n  <tx:annotation-driven transaction-manager="txManager"/>\n  ```\n\n### **2.13)声明式事务（纯注解驱动）**\n\n- 名称：@EnableTransactionManagement\n\n- 类型：**类注解**\n\n- 位置：Spring注解配置类上方\n\n- 作用：开启注解驱动，等同XML格式中的注解驱动\n\n- 范例：\n\n  ```java\n  @Configuration\n  @ComponentScan("com.itheima")\n  @PropertySource("classpath:jdbc.properties")\n  @Import({JDBCConfig.class,MyBatisConfig.class,TransactionManagerConfig.class})\n  @EnableTransactionManagement\n  public class SpringConfig {\n  }\n  ```\n\n  ```java\n  public class TransactionManagerConfig {\n      @Bean\n      public PlatformTransactionManager getTransactionManager(@Autowired DataSource dataSource){\n          return new DataSourceTransactionManager(dataSource);\n      }\n  }\n  ```\n\n## 3)模板对象\n\n### 3.1)Spring模块对象\n\n![1591368087398](./img/java/springmvc/Spring-day04/1591368087398.png)\n\n- TransactionTemplate\n\n- JdbcTemplate\n\n- RedisTemplate\n\n- RabbitTemplate\n\n- JmsTemplate\n\n- HibernateTemplate\n\n- RestTemplate\n\n### 3.2)JdbcTemplate（了解）\n\n提供标准的sql语句操作API\n\n```java\npublic void save(Account account) {\n    String sql = "insert into account(name,money)values(?,?)";\n    jdbcTemplate.update(sql,account.getName(),account.getMoney());\n}\n```\n\n### 3.3)NamedParameterJdbcTemplate(了解）\n\n提供标准的具名sql语句操作API\n\n```java\npublic void save(Account account) {\n    String sql = "insert into account(name,money)values(:name,:money)";\n    Map pm = new HashMap();\n    pm.put("name",account.getName());\n    pm.put("money",account.getMoney());\n    jdbcTemplate.update(sql,pm);\n}\n```\n\n### **3.4)RedisTemplate**\n\nRedisTemplate对象结构\n\n![1591368270508](./img/java/springmvc/Spring-day04/1591368270508.png)\n\n```java\npublic void changeMoney(Integer id, Double money) {\n    redisTemplate.opsForValue().set("account:id:"+id,money);\n}\npublic Double findMondyById(Integer id) {\n    Object money = redisTemplate.opsForValue().get("account:id:" + id);\n    return new Double(money.toString());\n}\n```\n\n\n\n## 4)事务底层原理解析\n\n### **4.1)策略模式应用**\n\n策略模式（Strategy Pattern）使用不同策略的对象实现不同的行为方式，策略对象的变化导致行为的变化。\n\n![1591368340720](./img/java/springmvc/Spring-day04/1591368340720.png)\n\n策略模式（Strategy Pattern）使用不同策略的对象实现不同的行为方式，策略对象的变化导致行为的变化。\n\n![1591368370924](./img/java/springmvc/Spring-day04/1591368370924.png)\n\n',Kr={data:function(){return{MainComponent:Qr}}},$r=Kr,Xr=Object(d["a"])($r,zr,Wr,!1,null,"1f4e82c9",null),Yr=Xr.exports,Zr=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},na=[],ea='# 1 SpringMVC 概述\r\n\r\n**三层架构**    \r\n\r\n- 表现层：负责数据展示\r\n\r\n-  业务层：负责业务处理\r\n\r\n- 数据层：负责数据操作\r\n\r\n![image-20200426174726083](./img/java/springmvc/SpringMVC-day01/image-20200426174726083.png)\r\n\r\nMVC（Model View Controller），一种用于设计创建Web应用程序表现层的模式\r\n\r\n- Model（模型）：数据模型，用于封装数据\r\n\r\n-  View（视图）：页面视图，用于展示数据\r\n\r\n* jsp  \r\n* html\r\n\r\nController（控制器）：处理用户交互的调度器，用于根据用户需求处理程序逻辑\r\n\r\n* Servlet\r\n* SpringMVC\r\n\r\n![image-20200426180210590](./img/java/springmvc/SpringMVC-day01/image-20200426180210590.png)  \r\n\r\n![image-20200426180348299](./img/java/springmvc/SpringMVC-day01/image-20200426180348299.png)\r\n\r\n\r\n# 2 入门案例\r\n\r\n## 2.1 入门案例制作\r\n\r\n①导入SpringMVC相关坐标\r\n\r\n```xml\r\n\x3c!-- servlet3.1规范的坐标 --\x3e\r\n<dependency>\r\n    <groupId>javax.servlet</groupId>\r\n    <artifactId>javax.servlet-api</artifactId>\r\n    <version>3.1.0</version>\r\n    <scope>provided</scope>\r\n</dependency>\r\n\x3c!--jsp坐标--\x3e\r\n<dependency>\r\n    <groupId>javax.servlet.jsp</groupId>\r\n    <artifactId>jsp-api</artifactId>\r\n    <version>2.1</version>\r\n    <scope>provided</scope>\r\n</dependency>\r\n\x3c!--spring的坐标--\x3e\r\n<dependency>\r\n    <groupId>org.springframework</groupId>\r\n    <artifactId>spring-context</artifactId>\r\n    <version>5.1.9.RELEASE</version>\r\n</dependency>\r\n\x3c!--spring web的坐标--\x3e\r\n<dependency>\r\n    <groupId>org.springframework</groupId>\r\n    <artifactId>spring-web</artifactId>\r\n    <version>5.1.9.RELEASE</version>\r\n</dependency>\r\n\x3c!--springmvc的坐标--\x3e\r\n<dependency>\r\n    <groupId>org.springframework</groupId>\r\n    <artifactId>spring-webmvc</artifactId>\r\n    <version>5.1.9.RELEASE</version>\r\n</dependency>\r\n```\r\n\r\n②定义表现层业务处理器Controller，并配置成spring的bean（等同于Servlet）\r\n\r\n```java\r\n@Controller\r\npublic class UserController {\r\n\r\n    public void save(){\r\n        System.out.println("user mvc controller is running ...");\r\n    }\r\n}\r\n```\r\n\r\n```xml\r\n<?xml version="1.0" encoding="UTF-8"?>\r\n<beans xmlns="http://www.springframework.org/schema/beans"\r\n       xmlns:context="http://www.springframework.org/schema/context"\r\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\r\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\r\n        http://www.springframework.org/schema/context\r\n        http://www.springframework.org/schema/context/spring-context.xsd">\r\n    \x3c!--扫描加载所有的控制类类--\x3e\r\n    <context:component-scan base-package="com.itheima"/>\r\n\r\n</beans>\r\n```\r\n\r\n③web.xml中配置SpringMVC核心控制器，用于将请求转发到对应的具体业务处理器Controller中（等同于Servlet配置）\r\n\r\n```xml\r\n<servlet>\r\n    <servlet-name>DispatcherServlet</servlet-name>\r\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\r\n    <init-param>\r\n        <param-name>contextConfigLocation</param-name>\r\n        <param-value>classpath*:spring-mvc.xml</param-value>\r\n    </init-param>\r\n</servlet>\r\n<servlet-mapping>\r\n    <servlet-name>DispatcherServlet</servlet-name>\r\n    <url-pattern>/</url-pattern>\r\n</servlet-mapping>\r\n```\r\n\r\n④设定具体Controller的访问路径（等同于Servlet在web.xml中的配置）\r\n\r\n```java\r\n//设定当前方法的访问映射地址\r\n@RequestMapping("/save")\r\npublic void save(){\r\n    System.out.println("user mvc controller is running ...");\r\n}\r\n```\r\n\r\n⑤设置返回页面  \r\n\r\n```java\r\n//设定当前方法的访问映射地址\r\n@RequestMapping("/save")\r\n//设置当前方法返回值类型为String，用于指定请求完成后跳转的页面\r\npublic String save(){\r\n    System.out.println("user mvc controller is running ...");\r\n    //设定具体跳转的页面\r\n    return "success.jsp";\r\n}\r\n```\r\n\r\n\r\n\r\n## 2.2 入门案例工作流程分析  \r\n\r\n* 服务器启动\r\n  1. 加载web.xml中DispatcherServlet\r\n  2. 读取spring-mvc.xml中的配置，加载所有com.itheima包中所有标记为bean的类\r\n  3. 读取bean中方法上方标注@RequestMapping的内容\r\n* 处理请求\r\n  1. DispatcherServlet配置拦截所有请求 /\r\n  2. 使用请求路径与所有加载的@RequestMapping的内容进行比对\r\n  3. 执行对应的方法\r\n  4. 根据方法的返回值在webapp目录中查找对应的页面并展示  \r\n\r\n\r\n\r\n## 2.3 SpringMVC 技术架构图\r\n\r\n![image-20200426182959446](./img/java/springmvc/SpringMVC-day01/image-20200426182959446.png)\r\n\r\n\r\n\r\n![image-20200426183024690](./img/java/springmvc/SpringMVC-day01/image-20200426183024690.png)\r\n\r\n\r\n\r\n*  DispatcherServlet：前端控制器， 是整体流程控制的中心，由其调用其它组件处理用户的请求， 有\r\n  效的降低了组件间的耦合性\r\n* HandlerMapping：处理器映射器， 负责根据用户请求找到对应具体的Handler处理器\r\n* Handler：处理器，业务处理的核心类，通常由开发者编写，描述具体的业务\r\n* HandlAdapter：处理器适配器，通过它对处理器进行执行\r\n* View Resolver：视图解析器， 将处理结果生成View视图\r\n* View：视图，最终产出结果， 常用视图如jsp、 html  \r\n\r\n![image-20200426183313406](./img/java/springmvc/SpringMVC-day01/image-20200426183313406.png)\r\n\r\n# 3 基本配置\r\n\r\n## 3.1 常规配置（Controller加载控制）\r\n\r\n* SpringMVC的处理器对应的bean必须按照规范格式开发，未避免加入无效的bean可通过bean加载过滤器进\r\n  行包含设定或排除设定，表现层bean标注通常设定为@Controller  \r\n\r\n**xml方式**\r\n\r\n```xml\r\n<context:component-scan base-package="com.itheima">\r\n    <context:include-filter\r\n                            type="annotation"\r\n                            expression="org.springframework.stereotype.Controller"/>\r\n</context:component-scan>\r\n```\r\n\r\n### 3.1.1 静态资源加载\r\n\r\n```xml\r\n\x3c!--放行指定类型静态资源配置方式--\x3e\r\n<mvc:resources mapping="/img/**" location="/img/"/>\r\n<mvc:resources mapping="/js/**" location="/js/"/>\r\n<mvc:resources mapping="/css/**" location="/css/"/>\r\n\r\n\x3c!--SpringMVC提供的通用资源放行方式--\x3e\r\n<mvc:default-servlet-handler/>\r\n```\r\n\r\n \r\n\r\n### 3.1.2 中文乱码处理 \r\n\r\n  SpringMVC提供专用的中文字符过滤器，用于处理乱码问题  \r\n\r\n  配置在 **web.xml** 里面\r\n\r\n```XML\r\n\x3c!--乱码处理过滤器，与Servlet中使用的完全相同，差异之处在于处理器的类由Spring提供--\x3e\r\n<filter>\r\n    <filter-name>CharacterEncodingFilter</filter-name>\r\n    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\r\n    <init-param>\r\n        <param-name>encoding</param-name>\r\n        <param-value>UTF-8</param-value>\r\n    </init-param>\r\n</filter>\r\n<filter-mapping>\r\n    <filter-name>CharacterEncodingFilter</filter-name>\r\n    <url-pattern>/*</url-pattern>\r\n</filter-mapping>\r\n```\r\n\r\n\r\n\r\n## 3.2 注解驱动\r\n\r\n*   使用注解形式转化SpringMVC核心配置文件为配置类  \r\n\r\n\r\n```java\r\n@Configuration\r\n@ComponentScan(value = "com.itheima",includeFilters =\r\n    @ComponentScan.Filter(type=FilterType.ANNOTATION,classes = {Controller.class})\r\n    )\r\npublic class SpringMVCConfiguration implements WebMvcConfigurer{\r\n    //注解配置放行指定资源格式\r\n//    @Override\r\n//    public void addResourceHandlers(ResourceHandlerRegistry registry) {\r\n//        registry.addResourceHandler("/img/**").addResourceLocations("/img/");\r\n//        registry.addResourceHandler("/js/**").addResourceLocations("/js/");\r\n//        registry.addResourceHandler("/css/**").addResourceLocations("/css/");\r\n//    }\r\n\r\n    //注解配置通用放行资源的格式\r\n    @Override\r\n    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {\r\n        configurer.enable();;\r\n    }\r\n}\r\n```\r\n\r\n*   基于servlet3.0规范，自定义Servlet容器初始化配置类，加载SpringMVC核心配置类  \r\n\r\n\r\n```java\r\npublic class ServletContainersInitConfig extends AbstractDispatcherServletInitializer {\r\n    //创建Servlet容器时，使用注解的方式加载SPRINGMVC配置类中的信息，并加载成WEB专用的\t\t\t           //ApplicationContext对象\r\n    //该对象放入了ServletContext范围，后期在整个WEB容器中可以随时获取调用\r\n    @Override\r\n    protected WebApplicationContext createServletApplicationContext() {\r\n        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();\r\n        ctx.register(SpringMVCConfiguration.class);\r\n        return ctx;\r\n    }\r\n\r\n    //注解配置映射地址方式，服务于SpringMVC的核心控制器DispatcherServlet\r\n    @Override\r\n    protected String[] getServletMappings() {\r\n        return new String[]{"/"};\r\n    }\r\n\r\n    @Override\r\n    protected WebApplicationContext createRootApplicationContext() {\r\n        return null;\r\n    }\r\n\r\n    //乱码处理作为过滤器，在servlet容器启动时进行配置，相关内容参看Servlet零配置相关课程\r\n    @Override\r\n    public void onStartup(ServletContext servletContext) throws ServletException {\r\n        super.onStartup(servletContext);\r\n        CharacterEncodingFilter cef = new CharacterEncodingFilter();\r\n        cef.setEncoding("UTF-8");\r\n        FilterRegistration.Dynamic registration = servletContext.addFilter("characterEncodingFilter", cef);\r\n        registration.addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST,DispatcherType.FORWARD,DispatcherType.INCLUDE),false,"/*");\r\n    }\r\n}\r\n```\r\n\r\n  删除web.xml\r\n  删除spring-mvc.xml  \r\n\r\n **小节**\r\n 基于servlet3.0规范，配置Servlet容器初始化配置类，初始化时加载SpringMVC配置类\r\n 转化SpringMVC核心配置文件\r\n 转化为注解（例如： spring处理器加载过滤）\r\n 转化为bean进行加载\r\n 按照标准接口进行开发并加载（例如：中文乱码处理、静态资源加载过滤）  \r\n\r\n# 4 请求\r\n\r\n## 4.1 普通类型参数传参\r\n\r\n  参数名与处理器方法形参名保持一致  \r\n\r\n  访问URL： http://localhost/requestParam1?name=itheima&age=14  \r\n\r\n```java\r\n@RequestMapping("/requestParam1")\r\npublic String requestParam1(String name ,String age){\r\n    System.out.println("name="+name+",age="+age);\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n **@RequestParam** 的使用\r\n 类型： 形参注解\r\n 位置：处理器类中的方法形参前方\r\n 作用：绑定请求参数与对应处理方法形参间的关系  \r\n\r\n```java\r\n@RequestMapping("/requestParam2")\r\npublic String requestParam2(@RequestParam(\r\n                            name = "userName",\r\n                            required = true,\r\n                            defaultValue = "itheima") String name){\r\n    \r\n    System.out.println("name="+name);\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n## 4.2 POJO类型参数传参\r\n\r\n当POJO中使用简单类型属性时， 参数名称与POJO类属性名保持一致  \r\n\r\n访问URL： http://localhost/requestParam3?name=itheima&age=14  \r\n\r\n**Controller**\r\n\r\n```java\r\n@RequestMapping("/requestParam3")\r\npublic String requestParam3(User user){\r\n    System.out.println("name="+user.getName());\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n**POJO类**\r\n\r\n```java\r\npublic class User {\r\n    private String name;\r\n    private Integer age;\r\n    \r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public Integer getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(Integer age) {\r\n        this.age = age;\r\n    }\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n**参数冲突**\r\n 当POJO类型属性与其他形参出现同名问题时，将被同时赋值\r\n 建议使用@RequestParam注解进行区分\r\n访问URL： http://localhost/requestParam4?name=itheima&**age**=14  \r\n\r\n```java\r\n@RequestMapping("/requestParam4")\r\npublic String requestParam4(User user,String age){\r\n    System.out.println("user.age="+user.getAge()+",age="+age);\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n\r\n\r\n**复杂POJO类型参数**\r\n 当POJO中出现对象属性时，参数名称与对象层次结构名称保持一致  \r\n\r\n  访问URL： http://localhost/requestParam5?address.province=beijing  \r\n\r\n```java\r\npublic class User {\r\n    private String name;\r\n    private Integer age;\r\n\r\n    private Address address;\r\n    \r\n    public Address getAddress() {\r\n        return address;\r\n    }\r\n\r\n    public void setAddress(Address address) {\r\n        this.address = address;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public Integer getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(Integer age) {\r\n        this.age = age;\r\n    }\r\n\r\n}\r\n```\r\n\r\n```java\r\n@RequestMapping("/requestParam5")\r\npublic String requestParam5(User user){\r\n    System.out.println("user.address="+user.getAddress().getProvince());\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n![image-20200426190932459](./img/java/springmvc/SpringMVC-day01/image-20200426190932459.png)\r\n\r\n**当POJO中出现List，保存对象数据，参数名称与对象层次结构名称保持一致，使用数组格式描述集合中对象的位置**  \r\n\r\n访问URL： http://localhost/requestParam7?addresses[0].province=bj&addresses[1].province=tj  \r\n\r\n```java\r\npublic class User {\r\n    private String name;\r\n    private Integer age;\r\n    private List<Address> addresses;\r\n}\r\n\r\npublic class Address {\r\n    private String province;\r\n    private String city;\r\n    private String address;\r\n}\r\n```\r\n\r\n```java\r\n@RequestMapping("/requestParam7")\r\npublic String requestParam7(User user){\r\n    System.out.println("user.addresses="+user.getAddress());\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n **当POJO中出现Map，保存对象数据，参数名称与对象层次结构名称保持一致，使用映射格式描述集合中对象的位置**  \r\n\r\n 访问URL： http://localhost/requestParam8?addressMap[’home’].province=bj&addressMap[’job’].province=tj  \r\n\r\n```java\r\npublic class User {\r\n    private String name;\r\n    private Integer age;\r\n    private Map<String,Address> addressMap;\r\n}\r\npublic class Address {\r\n    private String province;\r\n    private String city;\r\n    private String address;\r\n}\r\n```\r\n\r\n```java\r\n@RequestMapping("/requestParam8")\r\npublic String requestParam8(User user){\r\n    System.out.println("user.addressMap="+user.getAddressMap());\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n## 4.3 数组与集合类型参数传参\r\n\r\n**数组类型参数**\r\n\r\n请求参数名与处理器方法形参名保持一致，且请求参数数量＞ 1个  \r\n\r\n访问URL： http://localhost/requestParam9?nick=Jockme&nick=zahc  \r\n\r\n```java\r\n@RequestMapping("/requestParam9")\r\npublic String requestParam9(String[] nick){\r\n    System.out.println(nick[0]+","+nick[1]);\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n**集合类型参数**\r\n 保存简单类型数据，请求参数名与处理器方法形参名保持一致，且请求参数数量＞ 1个\r\n访问URL： http://localhost/requestParam10?nick=Jockme&nick=zahc\r\n\r\n```java\r\n@RequestMapping("/requestParam10")\r\npublic String requestParam10(@RequestParam("nick") List<String> nick){\r\n    System.out.println(nick);\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n 注意： SpringMVC默认将List作为对象处理，赋值前先创建对象，然后将nick作为对象的属性进行处理。由于\r\nList是接口，无法创建对象，报无法找到构造方法异常；修复类型为可创建对象的ArrayList类型后，对象可\r\n以创建，但没有nick属性，因此数据为空。此时需要告知SpringMVC的处理器nick是一组数据，而不是一个单\r\n一数据。通过@RequestParam注解，将数量大于1个names参数打包成参数数组后， SpringMVC才能识别该数\r\n据格式，并判定形参类型是否为数组或集合，并按数组或集合对象的形式操作数据。  \r\n\r\n **小节**\r\n 请求POJO类型参数获取\r\n POJO的简单属性\r\n POJO的对象属性\r\n POJO的集合属性（存储简单数据）\r\n POJO的集合属性（存储对象数据）\r\n 名称冲突问题  \r\n\r\n## 4.4 类型转换器\r\n\r\nSpringMVC对接收的数据进行自动类型转换，该工作通过Converter接口实现  \r\n\r\n![image-20200426193801059](./img/java/springmvc/SpringMVC-day01/image-20200426193801059.png)\r\n\r\n* **标量转换器**\r\n   StringToBooleanConverter String→Boolean\r\n   ObjectToStringConverter Object→String\r\n   StringToNumberConverterFactory String→Number（ Integer、 Long等）\r\n   NumberToNumberConverterFactory Number子类型之间(Integer、 Long、 Double等)\r\n   StringToCharacterConverter String→java.lang.Character\r\n   NumberToCharacterConverter Number子类型(Integer、 Long、 Double等)→java.lang.Character\r\n   CharacterToNumberFactory java.lang.Character→Number子类型(Integer、 Long、 Double等)\r\n   StringToEnumConverterFactory String→enum类型\r\n   EnumToStringConverter enum类型→String\r\n   StringToLocaleConverter String→java.util.Local\r\n   PropertiesToStringConverter java.util.Properties→String\r\n   StringToPropertiesConverter String→java.util.Properties  \r\n\r\n* **集合、数组相关转换器**\r\n   ArrayToCollectionConverter 数组→集合（ List、 Set）\r\n   CollectionToArrayConverter 集合（ List、 Set） →数组\r\n   ArrayToArrayConverter 数组间\r\n   CollectionToCollectionConverter 集合间（ List、 Set）\r\n   MapToMapConverter Map间\r\n   ArrayToStringConverter 数组→String类型\r\n   StringToArrayConverter String→数组， trim后使用“,”split\r\n   ArrayToObjectConverter 数组→Object\r\n   ObjectToArrayConverter Object→单元素数组\r\n   CollectionToStringConverter 集合（ List、 Set） →String\r\n   StringToCollectionConverter String→集合（ List、 Set）， trim后使用“,”split\r\n   CollectionToObjectConverter 集合→Object\r\n   ObjectToCollectionConverter Object→单元素集合  \r\n*  **默认转换器**\r\n   ObjectToObjectConverter Object间\r\n   IdToEntityConverter Id→Entity\r\n   FallbackObjectToStringConverter Object→String  \r\n\r\n* **SpringMVC对接收的数据进行自动类型转换，该工作通过Converter接口实现**  \r\n\r\n  ![image-20200426194106166](./img/java/springmvc/SpringMVC-day01/image-20200426194106166.png)\r\n\r\n## 4.5 日期类型格式转换  \r\n\r\n* **声明自定义的转换格式并覆盖系统转换格式**  \r\n\r\n  ```xml\r\n  \x3c!--5.启用自定义Converter--\x3e\r\n  <mvc:annotation-driven conversion-service="conversionService"/>\r\n  \x3c!--1.设定格式类型Converter，注册为Bean，受SpringMVC管理--\x3e\r\n  <bean id="conversionService"\r\n        class="org.springframework.format.support.FormattingConversionServiceFactoryBean">\r\n      \x3c!--2.自定义Converter格式类型设定，该设定使用的是同类型覆盖的思想--\x3e\r\n      <property name="formatters">\r\n          \x3c!--3.使用set保障相同类型的转换器仅保留一个，避免冲突--\x3e\r\n          <set>\r\n              \x3c!--4.设置具体的格式类型--\x3e\r\n              <bean class="org.springframework.format.datetime.DateFormatter">\r\n                  \x3c!--5.类型规则--\x3e\r\n                  <property name="pattern" value="yyyy-MM-dd"/>\r\n              </bean>\r\n          </set>\r\n      </property>\r\n  </bean>\r\n  ```\r\n\r\n* **日期类型格式转换（简化版）**\r\n   名称： @DateTimeFormat\r\n   类型： 形参注解、成员变量注解\r\n   位置：形参前面 或 成员变量上方\r\n   作用：为当前参数或变量指定类型转换规则\r\n   范例：  \r\n\r\n  ```java\r\n  public String requestParam12(@DateTimeFormat(pattern = "yyyy-MM-dd") Date date){\r\n      System.out.println("date="+date);\r\n      return "page.jsp";\r\n  }\r\n  ```\r\n\r\n  ```java\r\n  @DateTimeFormat(pattern = "yyyy-MM-dd")\r\n  private Date birthday;\r\n  ```\r\n\r\n* 注意：依赖注解驱动支持  \r\n\r\n    <mvc:annotation-driven />  \r\n\r\n\r\n## 4.6 自定义类型转换器\r\n\r\n* 自定义类型转换器，实现Converter接口，并制定转换前与转换后的类型\r\n\r\n  ```xml\r\n  \x3c!--1.将自定义Converter注册为Bean，受SpringMVC管理--\x3e\r\n  <bean id="myDateConverter" class="com.itheima.converter.MyDateConverter"/>\r\n  \x3c!--2.设定自定义Converter服务bean--\x3e\r\n  <bean id="conversionService"\r\n        class="org.springframework.context.support.ConversionServiceFactoryBean">\r\n      \x3c!--3.注入所有的自定义Converter，该设定使用的是同类型覆盖的思想--\x3e\r\n      <property name="converters">\r\n          \x3c!--4.set保障同类型转换器仅保留一个，去重规则以Converter<S,T>的泛型为准--\x3e\r\n          <set>\r\n              \x3c!--5.具体的类型转换器--\x3e\r\n              <ref bean="myDateConverter"/>\r\n          </set>\r\n      </property>\r\n  </bean>\r\n  ```\r\n\r\n  ```java\r\n  //自定义类型转换器，实现Converter接口，接口中指定的泛型即为最终作用的条件\r\n  //本例中的泛型填写的是String，Date，最终出现字符串转日期时，该类型转换器生效\r\n  public class MyDateConverter implements Converter<String, Date> {\r\n      //重写接口的抽象方法，参数由泛型决定\r\n      public Date convert(String source) {\r\n          DateFormat df = new SimpleDateFormat("yyyy-MM-dd");\r\n          Date date = null;\r\n          //类型转换器无法预计使用过程中出现的异常，因此必须在类型转换器内部捕获，不允许抛出，框架无法预计此类异常如何处理\r\n          try {\r\n              date = df.parse(source);\r\n          } catch (ParseException e) {\r\n              e.printStackTrace();\r\n          }\r\n          return date;\r\n      }\r\n  }\r\n  ```\r\n\r\n  \r\n\r\n* **通过注册自定义转换器，将该功能加入到SpringMVC的转换服务ConverterService中**  \r\n\r\n  ```xml\r\n  \x3c!--开启注解驱动，加载自定义格式化转换器对应的类型转换服务--\x3e\r\n  <mvc:annotation-driven conversion-service="conversionService"/>\r\n  ```\r\n\r\n  \r\n\r\n## 4.7 请求映射 @RequestMapping\r\n\r\n### 4.7.1 方法注解\r\n\r\n* 名称： @RequestMapping\r\n   类型： 方法注解 \r\n   位置：处理器类中的方法定义上方\r\n   作用：绑定请求地址与对应处理方法间的关系\r\n   范例：\r\n   访问路径： /requestURL1  \r\n\r\n```java\r\n@Controller\r\n@RequestMapping("/user")\r\npublic class UserController {\r\n    @RequestMapping("/requestURL2")\r\n    public String requestURL2() {\r\n        return "page.jsp";\r\n    }\r\n}\r\n```\r\n\r\n### 4.7.2 类注解\r\n\r\n**名称： @RequestMapping**\r\n 类型： 类注解\r\n 位置：处理器类定义上方\r\n 作用：为当前处理器中所有方法设定公共的访问路径前缀\r\n 范例：\r\n 访问路径： /user/requestURL1\r\n\r\n```java\r\n@Controller\r\n@RequestMapping("/user")\r\npublic class UserController {\r\n    @RequestMapping("/requestURL2")\r\n    public String requestURL2() {\r\n        return "page.jsp";\r\n    }\r\n}  \r\n```\r\n\r\n* 常用属性\r\n\r\n  ```java\r\n  @RequestMapping(\r\n      value="/requestURL3", //设定请求路径，与path属性、 value属性相同\r\n      method = RequestMethod.GET, //设定请求方式\r\n      params = "name", //设定请求参数条件\r\n      headers = "content-type=text/*", //设定请求消息头条件\r\n      consumes = "text/*", //用于指定可以接收的请求正文类型（MIME类型）\r\n      produces = "text/*" //用于指定可以生成的响应正文类型（MIME类型）\r\n  )\r\n  public String requestURL3() {\r\n      return "/page.jsp";\r\n  }\r\n  ```\r\n\r\n  \r\n\r\n# 5 响应\r\n\r\n## 5.1 页面跳转\r\n\r\n* 转发（默认）\r\n\r\n```java\r\n@RequestMapping("/showPage1")\r\npublic String showPage1() {\r\n    System.out.println("user mvc controller is running ...");\r\n    return "forward:page.jsp";\r\n}\r\n```\r\n\r\n*  重定向\r\n\r\n```\r\n@RequestMapping("/showPage2")\r\npublic String showPage2() {\r\nSystem.out.println("user mvc controller is running ...");\r\nreturn "redirect:page.jsp";\r\n}\r\n```\r\n\r\n 注意：页面访问地址中所携带的   **/**  \r\n\r\n## 5.2 页面访问快捷设定 (InternalResourceViewResolver)\r\n\r\n  展示页面的保存位置通常固定，且结构相似，可以设定通用的访问路径，简化页面配置格式  \r\n\r\n```java\r\n<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">\r\n    <property name="prefix" value="/WEB-INF/pages/"/>\r\n    <property name="suffix" value=".jsp"/>\r\n/bean>\r\n```\r\n\r\n```java\r\npublic String showPage3() {\r\n    return "page";\r\n}\r\n```\r\n\r\n  **如果未设定了返回值，使用void类型，则默认使用访问路径作页面地址的前缀后缀**  \r\n\r\n```java\r\n//最简页面配置方式，使用访问路径作为页面名称，省略返回值\r\n@RequestMapping("/showPage5")\r\npublic void showPage5() {\r\n    System.out.println("user mvc controller is running ...");\r\n}\r\n```\r\n\r\n## 5.3 带数据页面跳转\r\n\r\n*   方式一：使用HttpServletRequest类型形参进行数据传递  \r\n\r\n  ```java\r\n  @RequestMapping("/showPageAndData1")\r\n  public String showPageAndData1(HttpServletRequest request) {\r\n      request.setAttribute("name","itheima");\r\n      return "page";\r\n  }\r\n  ```\r\n\r\n  \r\n\r\n*   方式二：使用Model类型形参进行数据传递  \r\n\r\n  ```java\r\n  @RequestMapping("/showPageAndData2")\r\n  public String showPageAndData2(Model model) {\r\n      model.addAttribute("name","itheima");\r\n      Book book = new Book();\r\n      book.setName("SpringMVC入门实战");\r\n      book.setPrice(66.6d);\r\n      model.addAttribute("book",book);\r\n      return "page";\r\n  }\r\n  ```\r\n\r\n  \r\n\r\n*   方式三：使用ModelAndView类型形参进行数据传递，将该对象作为返回值传递给调用者  \r\n\r\n  ```java\r\n  //使用ModelAndView形参传递参数，该对象还封装了页面信息\r\n  @RequestMapping("/showPageAndData3")\r\n  public ModelAndView showPageAndData3(ModelAndView modelAndView) {\r\n      //ModelAndView mav = new ModelAndView();    替换形参中的参数\r\n      Book book  = new Book();\r\n      book.setName("SpringMVC入门案例");\r\n      book.setPrice(66.66d);\r\n      //添加数据的方式，key对value\r\n      modelAndView.addObject("book",book);\r\n      //添加数据的方式，key对value\r\n      modelAndView.addObject("name","Jockme");\r\n      //设置页面的方式，该方法最后一次执行的结果生效\r\n      modelAndView.setViewName("page");\r\n      //返回值设定成ModelAndView对象\r\n      return modelAndView;\r\n  }\r\n  ```\r\n\r\n## 5.4 返回json数据\r\n\r\n*   方式一：基于response返回数据的简化格式，返回JSON数据  \r\n\r\n  ```java\r\n  //使用jackson进行json数据格式转化\r\n  @RequestMapping("/showData3")\r\n  @ResponseBody\r\n  public String showData3() throws JsonProcessingException {\r\n      Book book  = new Book();\r\n      book.setName("SpringMVC入门案例");\r\n      book.setPrice(66.66d);\r\n  \r\n      ObjectMapper om = new ObjectMapper();\r\n      return om.writeValueAsString(book);\r\n  }\r\n  ```\r\n\r\n*    使用SpringMVC提供的消息类型转换器将对象与集合数据自动转换为JSON数据    \r\n\r\n  ```java\r\n  //使用SpringMVC注解驱动，对标注@ResponseBody注解的控制器方法进行结果转换，由于返回值为引用类型，自动调用jackson提供的类型转换器进行格式转换\r\n  @RequestMapping("/showData4")\r\n  @ResponseBody\r\n  public Book showData4() {\r\n      Book book  = new Book();\r\n      book.setName("SpringMVC入门案例");\r\n      book.setPrice(66.66d);\r\n      return book;\r\n  }\r\n  ```\r\n\r\n    需要手工添加信息类型转换器  \r\n\r\n  ```xml\r\n  <bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter">\r\n      <property name="messageConverters">\r\n          <list>\r\n              <bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"/>\r\n          </list>\r\n      </property>\r\n  </bean\r\n  ```\r\n\r\n*   方式三：使用SpringMVC注解驱动简化配置  \r\n\r\n  ```xml\r\n  \x3c!--开启springmvc注解驱动，对@ResponseBody的注解进行格式增强，追加其类型转换的功能，具体实现由MappingJackson2HttpMessageConverter进行--\x3e\r\n  <mvc:annotation-driven/>\r\n  ```\r\n\r\n  \r\n\r\n# 6 Servlet相关接口-Servlet相关接口替换方案\r\n\r\n  **HttpServletRequest / HttpServletResponse / HttpSession**  \r\n\r\n*   **SpringMVC提供访问原始Servlet接口API的功能，通过形参声明即可**  \r\n\r\n  ```java\r\n  @RequestMapping("/servletApi")\r\n  public String servletApi(HttpServletRequest request,\r\n                           HttpServletResponse response, HttpSession session){\r\n      System.out.println(request);\r\n      System.out.println(response);\r\n      System.out.println(session);\r\n      request.setAttribute("name","itheima");\r\n      System.out.println(request.getAttribute("name"));\r\n      return "page.jsp";\r\n  }\r\n  ```\r\n\r\n*   **Head数据获取**  \r\n\r\n   名称： @RequestHeader\r\n   类型： 形参注解\r\n   位置：处理器类中的方法形参前方\r\n   作用：绑定请求头数据与对应处理方法形参间的关系\r\n   范例：\r\n\r\n  ```java\r\n  @RequestMapping("/headApi")\r\n  public String headApi(@RequestHeader("Accept-Language") String head){\r\n      System.out.println(head);\r\n      return "page.jsp";\r\n  }  \r\n  ```\r\n\r\n*   **Cookie数据获取**  \r\n\r\n   名称： @CookieValue\r\n   类型： 形参注解\r\n   位置：处理器类中的方法形参前方\r\n   作用：绑定请求Cookie数据与对应处理方法形参间的关系\r\n   范例：\r\n\r\n  ```java\r\n  @RequestMapping("/cookieApi")\r\n  public String cookieApi(@CookieValue("JSESSIONID") String jsessionid){\r\n      System.out.println(jsessionid);\r\n      return "page.jsp";\r\n  }  \r\n  ```\r\n\r\n*   **Session数据获取**  \r\n\r\n   名称： @SessionAttribute\r\n   类型： 形参注解\r\n   位置：处理器类中的方法形参前方\r\n   作用：绑定请求Session数据与对应处理方法形参间的关系\r\n   范例：\r\n\r\n  ```java\r\n  @RequestMapping("/sessionApi")\r\n  public String sessionApi(@SessionAttribute("name") String name){\r\n      System.out.println(name);\r\n      return "page.jsp";\r\n  }  \r\n  ```\r\n\r\n*   **Session数据设置（了解）**  \r\n\r\n   名称： @SessionAttributes\r\n   类型： 类注解\r\n   位置：处理器类上方\r\n   作用：声明放入session范围的变量名称，适用于Model类型数据传参\r\n   范例：\r\n\r\n  ```java\r\n  @Controller\r\n  @SessionAttributes(names={"name"})\r\n  public class ServletController {\r\n      @RequestMapping("/setSessionData2")\r\n      public String setSessionDate2(Model model) {\r\n          model.addAttribute("name", "Jock2");\r\n          return "page.jsp";\r\n      }\r\n  }  \r\n  ```\r\n\r\n*   **注解式参数数据封装底层原理**  \r\n\r\n   数据的来源不同，对应的处理策略要进行区分\r\n   Head\r\n   Cookie\r\n   Session\r\n   SpringMVC使用策略模式进行处理分发\r\n   顶层接口： HandlerMethodArgumentResolver\r\n   实现类： ……  ',ta={data:function(){return{MainComponent:ea}}},ra=ta,aa=Object(d["a"])(ra,Zr,na,!1,null,"24f050c3",null),ia=aa.exports,sa=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},oa=[],la='# 1 异步调用\r\n\r\n## 1.1 发送异步请求（回顾）  \r\n\r\n```js\r\n<a href="javascript:void(0);" id="testAjax">访问controller</a>\r\n<script type="text/javascript" src="/js/jquery-3.3.1.min.js"><\/script>\r\n<script type="text/javascript">\r\n    $(function(){\r\n    $("#testAjax").click(function(){ //为id="testAjax"的组件绑定点击事件\r\n        $.ajax({ //发送异步调用\r\n            type:"POST", //请求方式： POST请求\r\n            url:"ajaxController", //请求参数（也就是请求内容）\r\n            data:\'ajax message\', //请求参数（也就是请求内容）\r\n            dataType:"text", //响应正文类型\r\n            contentType:"application/text", //请求正文的MIME类型\r\n        });\r\n    });\r\n});\r\n<\/script>\r\n```\r\n\r\n## 1.2 接受异步请求参数\r\n\r\n 名称： @RequestBody\r\n 类型： 形参注解\r\n 位置：处理器类中的方法形参前方\r\n 作用：将异步提交数据组织成标准请求参数格式，并赋值给形参\r\n 范例：\r\n\r\n```java\r\n@RequestMapping("/ajaxController")\r\npublic String ajaxController(@RequestBody String message){\r\n    System.out.println(message);\r\n    return "page.jsp";\r\n}  \r\n```\r\n\r\n* 注解添加到Pojo参数前方时，封装的异步提交数据按照Pojo的属性格式进行关系映射\r\n* 注解添加到集合参数前方时，封装的异步提交数据按照集合的存储结构进行关系映射 \r\n\r\n```java\r\n@RequestMapping("/ajaxPojoToController")\r\n//如果处理参数是POJO，且页面发送的请求数据格式与POJO中的属性对应，@RequestBody注解可以自动映射对应请求数据到POJO中\r\n//注意：POJO中的属性如果请求数据中没有，属性值为null，POJO中没有的属性如果请求数据中有，不进行映射\r\npublic String  ajaxPojoToController(@RequestBody User user){\r\n    System.out.println("controller pojo :"+user);\r\n    return "page.jsp";\r\n}\r\n\r\n@RequestMapping("/ajaxListToController")\r\n//如果处理参数是List集合且封装了POJO，且页面发送的数据是JSON格式的对象数组，数据将自动映射到集合参数中\r\npublic String  ajaxListToController(@RequestBody List<User> userList){\r\n    System.out.println("controller list :"+userList);\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n## 1.3 异步请求接受响应数据\r\n\r\n* 方法返回值为Pojo时，自动封装数据成json对象数据\r\n\r\n```java\r\n@RequestMapping("/ajaxReturnJson")\r\n@ResponseBody\r\npublic User ajaxReturnJson(){\r\n    System.out.println("controller return json pojo...");\r\n    User user = new User();\r\n    user.setName("Jockme");\r\n    user.setAge(40);\r\n    return user;\r\n}  \r\n```\r\n\r\n* 方法返回值为List时，自动封装数据成json对象数组数据  \r\n\r\n```java\r\n@RequestMapping("/ajaxReturnJsonList")\r\n@ResponseBody\r\n//基于jackon技术，使用@ResponseBody注解可以将返回的保存POJO对象的集合转成json数组格式数据\r\npublic List ajaxReturnJsonList(){\r\n    System.out.println("controller return json list...");\r\n    User user1 = new User();\r\n    user1.setName("Tom");\r\n    user1.setAge(3);\r\n\r\n    User user2 = new User();\r\n    user2.setName("Jerry");\r\n    user2.setAge(5);\r\n\r\n    ArrayList al = new ArrayList();\r\n    al.add(user1);\r\n    al.add(user2);\r\n\r\n    return al;\r\n}\r\n```\r\n\r\n# 2 异步请求-跨域访问\r\n\r\n## 2.1 跨域访问介绍\r\n\r\n* 当通过域名A下的操作访问域名B下的资源时，称为跨域访问\r\n* 跨域访问时，会出现无法访问的现象   \r\n\r\n![image-20200427162623591](./img/java/springmvc/SpringMVC-day02/image-20200427162623591.png)\r\n\r\n## 2.2 跨域环境搭建\r\n\r\n* 为当前主机添加备用域名\r\n  * 修改windows安装目录中的host文件\r\n  *  格式： ip 域名\r\n* 动态刷新DNS\r\n  *  命令： ipconfig /displaydns\r\n  *  命令： ipconfig /flushdns   \r\n\r\n## 2.3 跨域访问支持  \r\n\r\n 名称： @CrossOrigin\r\n 类型： 方法注解 、 类注解\r\n 位置：处理器类中的方法上方 或 类上方\r\n 作用：设置当前处理器方法/处理器类中所有方法支持跨域访问\r\n 范例：  \r\n\r\n```java\r\n@RequestMapping("/cross")\r\n@ResponseBody\r\n//使用@CrossOrigin开启跨域访问\r\n//标注在处理器方法上方表示该方法支持跨域访问\r\n//标注在处理器类上方表示该处理器类中的所有处理器方法均支持跨域访问\r\n@CrossOrigin\r\npublic User cross(HttpServletRequest request){\r\n    System.out.println("controller cross..."+request.getRequestURL());\r\n    User user = new User();\r\n    user.setName("Jockme");\r\n    user.setAge(39);\r\n    return user;\r\n}\r\n```\r\n\r\n# 3 拦截器\r\n\r\n## 3.1 拦截器概念\r\n\r\n* 请求处理过程解析  \r\n\r\n![image-20200427164038103](./img/java/springmvc/SpringMVC-day02/image-20200427164038103.png)\r\n\r\n 拦截器（ Interceptor）是一种动态拦截方法调用的机制\r\n 作用：\r\n   \t1. 在指定的方法调用前后执行预先设定后的的代码\r\n \t2. 阻止原始方法的执行\r\n\r\n 核心原理： AOP思想\r\n 拦截器链：多个拦截器按照一定的顺序，对原始被调用功能进行增强  \r\n\r\n\r\n\r\n* **拦截器VS过滤器**\r\n   归属不同： Filter属于Servlet技术， Interceptor属于SpringMVC技术\r\n   拦截内容不同： Filter对所有访问进行增强， Interceptor仅针对SpringMVC的访问进行增强  \r\n  \r\n  ![image-20200427164512745](./img/java/springmvc/SpringMVC-day02/image-20200427164512745.png)\r\n\r\n## 3.2 自定义拦截器开发过程\r\n\r\n* 实现HandlerInterceptor接口  \r\n\r\n  ```java\r\n  //自定义拦截器需要实现HandleInterceptor接口\r\n  public class MyInterceptor implements HandlerInterceptor {\r\n      //处理器运行之前执行\r\n      @Override\r\n      public boolean preHandle(HttpServletRequest request,\r\n                               HttpServletResponse response,\r\n                               Object handler) throws Exception {\r\n          System.out.println("前置运行----a1");\r\n          //返回值为false将拦截原始处理器的运行\r\n          //如果配置多拦截器，返回值为false将终止当前拦截器后面配置的拦截器的运行\r\n          return true;\r\n      }\r\n  \r\n      //处理器运行之后执行\r\n      @Override\r\n      public void postHandle(HttpServletRequest request,\r\n                             HttpServletResponse response,\r\n                             Object handler,\r\n                             ModelAndView modelAndView) throws Exception {\r\n          System.out.println("后置运行----b1");\r\n      }\r\n  \r\n      //所有拦截器的后置执行全部结束后，执行该操作\r\n      @Override\r\n      public void afterCompletion(HttpServletRequest request,\r\n                                  HttpServletResponse response,\r\n                                  Object handler,\r\n                                  Exception ex) throws Exception {\r\n          System.out.println("完成运行----c1");\r\n      }\r\n  \r\n      //三个方法的运行顺序为    preHandle -> postHandle -> afterCompletion\r\n      //如果preHandle返回值为false，三个方法仅运行preHandle\r\n  }\r\n  ```\r\n\r\n  \r\n\r\n*   配置拦截器  \r\n\r\n  配置拦截器  \r\n\r\n```xml\r\n<mvc:interceptors>\r\n    <mvc:interceptor>\r\n        <mvc:mapping path="/showPage"/>\r\n        <bean class="com.itheima.interceptor.MyInterceptor"/>\r\n    </mvc:interceptor>\r\n</mvc:interceptors>\r\n```\r\n\r\n  <u>注意：配置顺序为先配置执行位置，后配置执行类</u>  \r\n\r\n## 3.3 拦截器执行流程\r\n\r\n![image-20200427164840131](./img/java/springmvc/SpringMVC-day02/image-20200427164840131.png)\r\n\r\n\r\n\r\n## 3.4 拦截器配置与方法参数\r\n\r\n### 3.4.1 前置处理方法\r\n\r\n原始方法之前运行\r\n\r\n```java\r\npublic boolean preHandle(HttpServletRequest request,\r\n                         HttpServletResponse response,\r\n                         Object handler) throws Exception {\r\n    System.out.println("preHandle");\r\n    return true;\r\n}\r\n```\r\n\r\n* 参数\r\n   request:请求对象\r\n   response:响应对象\r\n   handler:被调用的处理器对象，本质上是一个方法对象，对反射中的Method对象进行了再包装\r\n* 返回值\r\n   返回值为false，被拦截的处理器将不执行  \r\n\r\n### 3.4.2   后置处理方法\r\n\r\n原始方法运行后运行，如果原始方法被拦截，则不执行  \r\n\r\n```java\r\npublic void postHandle(HttpServletRequest request,\r\n                       HttpServletResponse response,\r\n                       Object handler,\r\n                       ModelAndView modelAndView) throws Exception {\r\n    System.out.println("postHandle");\r\n}\r\n```\r\n\r\n 参数\r\n modelAndView:如果处理器执行完成具有返回结果，可以读取到对应数据与页面信息，并进行调整  \r\n\r\n### 3.4.3 完成处理方法\r\n\r\n  拦截器最后执行的方法，无论原始方法是否执行  \r\n\r\n```java\r\npublic void afterCompletion(HttpServletRequest request,\r\n                            HttpServletResponse response,\r\n                            Object handler,\r\n                            Exception ex) throws Exception {\r\n    System.out.println("afterCompletion");\r\n}\r\n```\r\n\r\n 参数\r\n ex:如果处理器执行过程中出现异常对象，可以针对异常情况进行单独处理  \r\n\r\n## 3.5 拦截器配置项  \r\n\r\n```xml\r\n<mvc:interceptors>\r\n    \x3c!--开启具体的拦截器的使用，可以配置多个--\x3e\r\n    <mvc:interceptor>\r\n        \x3c!--设置拦截器的拦截路径，支持*通配--\x3e\r\n        \x3c!--/**         表示拦截所有映射--\x3e\r\n        \x3c!--/*          表示拦截所有/开头的映射--\x3e\r\n        \x3c!--/user/*     表示拦截所有/user/开头的映射--\x3e\r\n        \x3c!--/user/add*  表示拦截所有/user/开头，且具体映射名称以add开头的映射--\x3e\r\n        \x3c!--/user/*All  表示拦截所有/user/开头，且具体映射名称以All结尾的映射--\x3e\r\n        <mvc:mapping path="/*"/>\r\n        <mvc:mapping path="/**"/>\r\n        <mvc:mapping path="/handleRun*"/>\r\n        \x3c!--设置拦截排除的路径，配置/**或/*，达到快速配置的目的--\x3e\r\n        <mvc:exclude-mapping path="/b*"/>\r\n        \x3c!--指定具体的拦截器类--\x3e\r\n        <bean class="MyInterceptor"/>\r\n    </mvc:interceptor>\r\n</mvc:interceptors>\r\n```\r\n\r\n\r\n\r\n## 3.6 多拦截器配置\r\n\r\n![image-20200427171422781](./img/java/springmvc/SpringMVC-day02/image-20200427171422781.png)\r\n\r\n**责任链模式**\r\n 责任链模式是一种行为模式\r\n 特征：\r\n沿着一条预先设定的任务链顺序执行，每个节点具有独立的工作任务\r\n 优势：\r\n独立性：只关注当前节点的任务，对其他任务直接放行到下一节点\r\n隔离性：具备链式传递特征，无需知晓整体链路结构，只需等待请求到达后进行处理即可\r\n灵活性：可以任意修改链路结构动态新增或删减整体链路责任\r\n解耦：将动态任务与原始任务解耦\r\n 弊端：\r\n链路过长时，处理效率低下\r\n可能存在节点上的循环引用现象，造成死循环，导致系统崩溃  \r\n\r\n# 4 异常处理\r\n\r\n## 4.1 异常处理器\r\n\r\n  **HandlerExceptionResolver**接口（异常处理器）  \r\n\r\n```java\r\n@Component\r\npublic class ExceptionResolver implements HandlerExceptionResolver {\r\n    public ModelAndView resolveException(HttpServletRequest request,\r\n                                         HttpServletResponse response,\r\n                                         Object handler,\r\n                                         Exception ex) {\r\n        System.out.println("异常处理器正在执行中");\r\n        ModelAndView modelAndView = new ModelAndView();\r\n        //定义异常现象出现后，反馈给用户查看的信息\r\n        modelAndView.addObject("msg","出错啦！ ");\r\n        //定义异常现象出现后，反馈给用户查看的页面\r\n        modelAndView.setViewName("error.jsp");\r\n        return modelAndView;\r\n    }\r\n}\r\n```\r\n\r\n  根据异常的种类不同，进行分门别类的管理，返回不同的信息  \r\n\r\n```java\r\npublic class ExceptionResolver implements HandlerExceptionResolver {\r\n    @Override\r\n    public ModelAndView resolveException(HttpServletRequest request,\r\n                                         HttpServletResponse response,\r\n                                         Object handler,\r\n                                         Exception ex) {\r\n        System.out.println("my exception is running ...."+ex);\r\n        ModelAndView modelAndView = new ModelAndView();\r\n        if( ex instanceof NullPointerException){\r\n            modelAndView.addObject("msg","空指针异常");\r\n        }else if ( ex instanceof  ArithmeticException){\r\n            modelAndView.addObject("msg","算数运算异常");\r\n        }else{\r\n            modelAndView.addObject("msg","未知的异常");\r\n        }\r\n        modelAndView.setViewName("error.jsp");\r\n        return modelAndView;\r\n    }\r\n}\r\n```\r\n\r\n## 4.2 注解开发异常处理器\r\n\r\n* 使用注解实现异常分类管理\r\n   名称： @ControllerAdvice\r\n   类型： 类注解\r\n   位置：异常处理器类上方\r\n   作用：设置当前类为异常处理器类\r\n   范例：\r\n\r\n```java\r\n@Component\r\n@ControllerAdvice\r\npublic class ExceptionAdvice {\r\n}  \r\n```\r\n\r\n* 使用注解实现异常分类管理\r\n   名称： @ExceptionHandler\r\n   类型： 方法注解\r\n   位置：异常处理器类中针对指定异常进行处理的方法上方\r\n   作用：设置指定异常的处理方式\r\n   范例：\r\n   说明：处理器方法可以设定多个\r\n ```java\r\n@ExceptionHandler(Exception.class)\r\n@ResponseBody\r\npublic String doOtherException(Exception ex){\r\n    return "出错啦，请联系管理员！ ";\r\n}  \r\n ```\r\n\r\n## 4.3 异常处理解决方案\r\n\r\n* 异常处理方案\r\n  * 业务异常：\r\n     发送对应消息传递给用户，提醒规范操作\r\n  * 系统异常：\r\n     发送固定消息传递给用户，安抚用户\r\n     发送特定消息给运维人员，提醒维护\r\n     记录日志\r\n  * 其他异常：\r\n     发送固定消息传递给用户，安抚用户\r\n     发送特定消息给编程人员，提醒维护\r\n     纳入预期范围内\r\n     记录日志  \r\n\r\n## 4.4 自定义异常\r\n\r\n* 异常定义格式\r\n\r\n  ```java\r\n  //自定义异常继承RuntimeException，覆盖父类所有的构造方法\r\n  public class BusinessException extends RuntimeException {\r\n      public BusinessException() {\r\n      }\r\n  \r\n      public BusinessException(String message) {\r\n          super(message);\r\n      }\r\n  \r\n      public BusinessException(String message, Throwable cause) {\r\n          super(message, cause);\r\n      }\r\n  \r\n      public BusinessException(Throwable cause) {\r\n          super(cause);\r\n      }\r\n  \r\n      public BusinessException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\r\n          super(message, cause, enableSuppression, writableStackTrace);\r\n      }\r\n  }\r\n  ```\r\n\r\n* 异常触发方式\r\n\r\n  ```java\r\n  if(user.getName().trim().length()<4) {\r\n      throw new BusinessException("用户名长度必须在2-4位之间，请重新输入！ ");\r\n  }\r\n  ```\r\n\r\n* 通过自定义异常将所有的异常现象进行分类管理，以统一的格式对外呈现异常消息  \r\n\r\n# 5 实用技术\r\n\r\n## 5.1 文件上传下载\r\n\r\n* 上传文件过程分析  \r\n\r\n  ![image-20200427174442939](./img/java/springmvc/SpringMVC-day02/image-20200427174442939.png)\r\n\r\n*   MultipartResolver接口  \r\n\r\n  *  MultipartResolver接口定义了文件上传过程中的相关操作，并对通用性操作进行了封装\r\n  * MultipartResolver接口底层实现类CommonsMultipartResovler\r\n  * CommonsMultipartResovler并未自主实现文件上传下载对应的功能，而是调用了apache的文件上传下载组件  \r\n\r\n  ```xml\r\n  <dependency>\r\n      <groupId>commons-fileupload</groupId>\r\n      <artifactId>commons-fileupload</artifactId>\r\n      <version>1.4</version>\r\n  </dependency>\r\n  ```\r\n\r\n* 文件上传下载实现\r\n\r\n  *   页面表单  \r\n\r\n    ```html\r\n    <form action="/fileupload" method="post" enctype="multipart/form-data">\r\n        上传LOGO： <input type="file" name="file"/><br/>\r\n        <input type="submit" value="上传"/>\r\n    </form>\r\n    ```\r\n\r\n  *   SpringMVC配置  \r\n\r\n    ```xml\r\n    <bean id="multipartResolver"\r\n          class="org.springframework.web.multipart.commons.CommonsMultipartResolver">\r\n    </bean>\r\n    ```\r\n\r\n  *   控制器  \r\n\r\n    ```java\r\n    @RequestMapping(value = "/fileupload")\r\n    public void fileupload(MultipartFile file){\r\n        file.transferTo(new File("file.png"));\r\n    }\r\n    ```\r\n\r\n## 5.2 文件上传注意事项\r\n\r\n1. 文件命名问题， 获取上传文件名，并解析文件名与扩展名\r\n2. 文件名过长问题\r\n3. 文件保存路径\r\n4. 重名问题\r\n\r\n```java\r\n@RequestMapping(value = "/fileupload")\r\n//参数中定义MultipartFile参数，用于接收页面提交的type=file类型的表单，要求表单名称与参数名相同\r\npublic String fileupload(MultipartFile file,MultipartFile file1,MultipartFile file2, HttpServletRequest request) throws IOException {\r\n    System.out.println("file upload is running ..."+file);\r\n    //        MultipartFile参数中封装了上传的文件的相关信息\r\n    //        System.out.println(file.getSize());\r\n    //        System.out.println(file.getBytes().length);\r\n    //        System.out.println(file.getContentType());\r\n    //        System.out.println(file.getName());\r\n    //        System.out.println(file.getOriginalFilename());\r\n    //        System.out.println(file.isEmpty());\r\n    //首先判断是否是空文件，也就是存储空间占用为0的文件\r\n    if(!file.isEmpty()){\r\n        //如果大小在范围要求内正常处理，否则抛出自定义异常告知用户（未实现）\r\n        //获取原始上传的文件名，可以作为当前文件的真实名称保存到数据库中备用\r\n        String fileName = file.getOriginalFilename();\r\n        //设置保存的路径\r\n        String realPath = request.getServletContext().getRealPath("/images");\r\n        //保存文件的方法，指定保存的位置和文件名即可，通常文件名使用随机生成策略产生，避免文件名冲突问题\r\n        file.transferTo(new File(realPath,file.getOriginalFilename()));\r\n    }\r\n    //测试一次性上传多个文件\r\n    if(!file1.isEmpty()){\r\n        String fileName = file1.getOriginalFilename();\r\n        //可以根据需要，对不同种类的文件做不同的存储路径的区分，修改对应的保存位置即可\r\n        String realPath = request.getServletContext().getRealPath("/images");\r\n        file1.transferTo(new File(realPath,file1.getOriginalFilename()));\r\n    }\r\n    if(!file2.isEmpty()){\r\n        String fileName = file2.getOriginalFilename();\r\n        String realPath = request.getServletContext().getRealPath("/images");\r\n        file2.transferTo(new File(realPath,file2.getOriginalFilename()));\r\n    }\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n## 5.4 Restful风格配置\r\n\r\n### 5.4.1 Rest\r\n\r\n* Rest（ REpresentational State Transfer） 一种网络资源的访问风格，定义了网络资源的访问方式\r\n  * 传统风格访问路径\r\n     http://localhost/user/get?id=1\r\n     http://localhost/deleteUser?id=1\r\n  * Rest风格访问路径\r\n     http://localhost/user/1\r\n* Restful是按照Rest风格访问网络资源\r\n* 优点\r\n   隐藏资源的访问行为，通过地址无法得知做的是何种操作\r\n   书写简化\r\n\r\n### 5.4.2 Rest行为约定方式  \r\n\r\n GET（查询） http://localhost/user/1 GET\r\n POST（保存） http://localhost/user POST\r\n PUT（更新） http://localhost/user PUT\r\n DELETE（删除） http://localhost/user DELETE\r\n**注意：**上述行为是约定方式，约定不是规范，可以打破，所以称Rest风格，而不是Rest规范  \r\n\r\n### 5.4.3 Restful开发入门  \r\n\r\n```java\r\n//设置rest风格的控制器\r\n@RestController\r\n//设置公共访问路径，配合下方访问路径使用\r\n@RequestMapping("/user/")\r\npublic class UserController {\r\n\r\n    //rest风格访问路径完整书写方式\r\n    @RequestMapping("/user/{id}")\r\n    //使用@PathVariable注解获取路径上配置的具名变量，该配置可以使用多次\r\n    public String restLocation(@PathVariable Integer id){\r\n        System.out.println("restful is running ....");\r\n        return "success.jsp";\r\n    }\r\n\r\n    //rest风格访问路径简化书写方式，配合类注解@RequestMapping使用\r\n    @RequestMapping("{id}")\r\n    public String restLocation2(@PathVariable Integer id){\r\n        System.out.println("restful is running ....get:"+id);\r\n        return "success.jsp";\r\n    }\r\n\r\n    //接收GET请求配置方式\r\n    @RequestMapping(value = "{id}",method = RequestMethod.GET)\r\n    //接收GET请求简化配置方式\r\n    @GetMapping("{id}")\r\n    public String get(@PathVariable Integer id){\r\n        System.out.println("restful is running ....get:"+id);\r\n        return "success.jsp";\r\n    }\r\n\r\n    //接收POST请求配置方式\r\n    @RequestMapping(value = "{id}",method = RequestMethod.POST)\r\n    //接收POST请求简化配置方式\r\n    @PostMapping("{id}")\r\n    public String post(@PathVariable Integer id){\r\n        System.out.println("restful is running ....post:"+id);\r\n        return "success.jsp";\r\n    }\r\n\r\n    //接收PUT请求简化配置方式\r\n    @RequestMapping(value = "{id}",method = RequestMethod.PUT)\r\n    //接收PUT请求简化配置方式\r\n    @PutMapping("{id}")\r\n    public String put(@PathVariable Integer id){\r\n        System.out.println("restful is running ....put:"+id);\r\n        return "success.jsp";\r\n    }\r\n\r\n    //接收DELETE请求简化配置方式\r\n    @RequestMapping(value = "{id}",method = RequestMethod.DELETE)\r\n    //接收DELETE请求简化配置方式\r\n    @DeleteMapping("{id}")\r\n    public String delete(@PathVariable Integer id){\r\n        System.out.println("restful is running ....delete:"+id);\r\n        return "success.jsp";\r\n    }\r\n}\r\n```\r\n\r\n```xml\r\n\x3c!--配置拦截器，解析请求中的参数_method，否则无法发起PUT请求与DELETE请求，配合页面表单使用--\x3e\r\n<filter>\r\n    <filter-name>HiddenHttpMethodFilter</filter-name>\r\n    <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>\r\n</filter>\r\n<filter-mapping>\r\n    <filter-name>HiddenHttpMethodFilter</filter-name>\r\n    <servlet-name>DispatcherServlet</servlet-name>\r\n</filter-mapping>\r\n```\r\n\r\n 开启SpringMVC对Restful风格的访问支持过滤器，即可通过页面表单提交PUT与DELETE请求\r\n 页面表单使用隐藏域提交请求类型，参数名称固定为_method，必须配合提交类型method=post使用\r\n\r\n```xml\r\n<form action="/user/1" method="post">\r\n    <input type="hidden" name="_method" value="PUT"/>\r\n    <input type="submit"/>\r\n</form>  \r\n```\r\n\r\n*   Restful请求路径简化配置方式  \r\n\r\n  ```java\r\n  @RestController\r\n  public class UserController {\r\n      @RequestMapping(value = "/user/{id}",method = RequestMethod.DELETE)\r\n      public String restDelete(@PathVariable String id){\r\n          System.out.println("restful is running ....delete:"+id);\r\n          return "success.jsp";\r\n      }\r\n  }  \r\n  ```\r\n\r\n## 5.5 postman工具安装与使用\r\n\r\n**postman** 是  一款可以发送Restful风格请求的工具，方便开发调试。首次运行需要联网注册  \r\n\r\n![image-20200427180851880](./img/java/springmvc/SpringMVC-day02/image-20200427180851880.png)\r\n\r\n',ca={data:function(){return{MainComponent:la}}},pa=ca,ua=Object(d["a"])(pa,sa,oa,!1,null,"f43f4576",null),ma=ua.exports,da=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},ga=[],Sa='\x3c!--\r\n * @Date           : 2021-04-28 01:12:51\r\n * @FilePath       : /jinnian-space/src/pages/java/module/springmvc/md/SpringMVC-day03.md\r\n * @Description    : \r\n--\x3e\r\n# 1 校验框架\r\n\r\n## 1.1 校验框架入门\r\n\r\n### 1.1.1 表单校验的重要性\r\n\r\n* 表单校验保障了数据有效性、安全性  \r\n\r\n![image-20200505144306747](./img/java/springmvc/SpringMVC-day03/image-20200505144306747.png)\r\n\r\n数据可以随意输入，导致错误的结果。后端表单校验的重要性。\r\n\r\n### 1.1.2 表单校验分类  \r\n\r\n* 校验位置：\r\n  * 客户端校验\r\n  * 服务端校验\r\n* 校验内容与对应方式：\r\n  * 格式校验\r\n    * 客户端：使用Js技术，利用正则表达式校验\r\n    * 服务端：使用校验框架 \r\n  * 逻辑校验\r\n    * 客户端：使用ajax发送要校验的数据，在服务端完成逻辑校验，返回校验结果\r\n    * 服务端：接收到完整的请求后，在执行业务操作前，完成逻辑校验\r\n\r\n###  1.1.3 表单校验规则\r\n\r\n* 长度：例如用户名长度，评论字符数量\r\n* 非法字符：例如用户名组成\r\n* 数据格式：例如Email格式、 IP地址格式\r\n* 边界值：例如转账金额上限，年龄上下限\r\n* 重复性：例如用户名是否重复\r\n\r\n### 1.1.4 表单校验框架\r\n\r\n* JSR（Java Specification Requests）：Java 规范提案  \r\n\r\n    303：提供bean属性相关校验规则  \r\n\r\n* JSR规范列表\r\n  * 企业应用技术\r\n     Contexts and Dependency Injection for Java (Web Beans 1.0) (JSR 299)\r\n     Dependency Injection for Java 1.0 (JSR 330)@postConstruct, @PreDestroy\r\n     Bean Validation 1.0 (JSR 303)\r\n     Enterprise JavaBeans 3.1 (includes Interceptors 1.1) (JSR 318)\r\n     Java EE Connector Architecture 1.6 (JSR 322)\r\n     Java Persistence 2.0 (JSR 317)\r\n     Common Annotations for the Java Platform 1.1 (JSR 250)\r\n     Java Message Service API 1.1 (JSR 914)\r\n     Java Transaction API (JTA) 1.1 (JSR 907)\r\n     JavaMail 1.4 (JSR 919)\r\n  * Web应用技术\r\n     Java Servlet 3.0 (JSR 315)\r\n     JavaServer Faces 2.0 (JSR 314)\r\n     JavaServer Pages 2.2/Expression Language 2.2 (JSR 245)\r\n     Standard Tag Library for JavaServer Pages (JSTL) 1.2 (JSR 52)\r\n     Debugging Support for Other Languages 1.0 (JSR 45)\r\n     模块化 (JSR 294)\r\n     Swing应用框架 (JSR 296)\r\n     JavaBeans Activation Framework (JAF) 1.1 (JSR 925)\r\n     Streaming API for XML (StAX) 1.0 (JSR 173)\r\n  * 管理与安全技术\r\n     Java Authentication Service Provider Interface for Containers (JSR 196)\r\n     Java Authorization Contract for Containers 1.3 (JSR 115)\r\n     Java EE Application Deployment 1.2 (JSR 88)\r\n     J2EE Management 1.1 (JSR 77)\r\n     Java SE中与Java EE有关的规范\r\n     JCache API (JSR 107)\r\n     Java Memory Model (JSR 133)\r\n     Concurrency Utilitie (JSR 166)\r\n     Java API for XML Processing (JAXP) 1.3 (JSR 206)\r\n     Java Database Connectivity 4.0 (JSR 221)\r\n     Java Management Extensions (JMX) 2.0 (JSR 255)\r\n     Java Portlet API (JSR 286)\r\n\r\n* Web Service技术\r\n   Java Date与Time API (JSR 310)\r\n   Java API for RESTful Web Services (JAX-RS) 1.1 (JSR 311)\r\n   Implementing Enterprise Web Services 1.3 (JSR 109)\r\n   Java API for XML-Based Web Services (JAX-WS) 2.2 (JSR 224)\r\n   Java Architecture for XML Binding (JAXB) 2.2 (JSR 222)\r\n   Web Services Metadata for the Java Platform (JSR 181)\r\n   Java API for XML-Based RPC (JAX-RPC) 1.1 (JSR 101)\r\n   Java APIs for XML Messaging 1.3 (JSR 67)\r\n   Java API for XML Registries (JAXR) 1.0 (JSR 93)\r\n\r\n* JCP（Java Community Process）：Java社区\r\n\r\n*  Hibernate框架中包含一套独立的校验框架hibernate-validator  \r\n\r\n     导入坐标\r\n\r\n  ```xml\r\n  <dependency>\r\n      <groupId>org.hibernate</groupId>\r\n      <artifactId>hibernate-validator</artifactId>\r\n      <version>6.1.0.Final</version>\r\n  </dependency>\r\n  ```\r\n\r\n  **注意：**\r\n  tomcat7 ：搭配hibernate-validator版本5.*.*.Final\r\n  tomcat8.5↑ ：搭配hibernate-validator版本6.*.*.Final  \r\n\r\n\r\n\r\n## 1.2 快速使用\r\n\r\n**1. 开启校验**\r\n\r\n 名称：@Valid 、 @Validated\r\n 类型：形参注解\r\n 位置：处理器类中的实体类类型的方法形参前方\r\n 作用：设定对当前实体类类型参数进行校验\r\n 范例：  \r\n\r\n```java\r\n@RequestMapping(value = "/addemployee")\r\npublic String addEmployee(@Valid Employee employee) {\r\n    System.out.println(employee);\r\n}\r\n```\r\n\r\n**2.设置校验规则**\r\n\r\n 名称：@NotNull\r\n 类型：属性注解 等\r\n 位置：实体类属性上方\r\n 作用：设定当前属性校验规则\r\n 范例：\r\n    每个校验规则所携带的参数不同，根据校验规则进行相应的调整\r\n    具体的校验规则查看对应的校验框架进行获取\r\n\r\n```java\r\npublic class Employee{\r\n    @NotNull(message = "姓名不能为空")\r\n    private String name;//员工姓名\r\n}  \r\n```\r\n\r\n**3.获取错误信息**\r\n\r\n```java\r\n@RequestMapping(value = "/addemployee")\r\npublic String addEmployee(@Valid Employee employee, Errors errors, Model model){\r\n    System.out.println(employee);\r\n    if(errors.hasErrors()){\r\n        for(FieldError error : errors.getFieldErrors()){\r\n            model.addAttribute(error.getField(),error.getDefaultMessage());\r\n        }\r\n        return "addemployee.jsp";\r\n    }\r\n    return "success.jsp";\r\n}  \r\n```\r\n\r\n  通过形参Errors获取校验结果数据，通过Model接口将数据封装后传递到页面显示  \r\n\r\n```html\r\n<form action="/addemployee" method="post">\r\n    员工姓名：<input type="text" name="name"><span style="color:red">${name}</span><br/>\r\n    员工年龄：<input type="text" name="age"><span style="color:red">${age}</span><br/>\r\n    <input type="submit" value="提交">\r\n</form>\r\n```\r\n\r\n通过形参Errors获取校验结果数据，通过Model接口将数据封装后传递到页面显示\r\n页面获取后台封装的校验结果信息  \r\n\r\n## 1.3 多规则校验\r\n\r\n* 同一个属性可以添加多个校验器  \r\n\r\n```java\r\n@NotNull(message = "请输入您的年龄")\r\n@Max(value = 60,message = "年龄最大值不允许超过60岁")\r\n@Min(value = 18,message = "年龄最小值不允许低于18岁")\r\nprivate Integer age;//员工年龄\r\n```\r\n\r\n* 3种判定空校验器的区别  \r\n\r\n![image-20200506160725709](./img/java/springmvc/SpringMVC-day03/image-20200506160725709.png)\r\n\r\n## 1.4 嵌套校验\r\n\r\n 名称：@Valid\r\n 类型：属性注解\r\n 位置：实体类中的引用类型属性上方\r\n 作用：设定当前应用类型属性中的属性开启校验\r\n 范例：\r\n\r\n```java\r\npublic class Employee {\r\n    //实体类中的引用类型通过标注@Valid注解，设定开启当前引用类型字段中的属性参与校验\r\n    @Valid\r\n    private Address address;\r\n}\r\n```\r\n\r\n 注意：开启嵌套校验后，被校验对象内部需要添加对应的校验规则  \r\n\r\n## 1.5 分组校验\r\n\r\n* 同一个模块，根据执行的业务不同，需要校验的属性会有不同\r\n  * 新增用户\r\n  * 修改用户\r\n* 对不同种类的属性进行分组，在校验时可以指定参与校验的字段所属的组类别\r\n  * 定义组（通用）\r\n  * 为属性设置所属组，可以设置多个\r\n  * 开启组校验\r\n\r\n```java\r\npublic interface GroupOne {\r\n}\r\n```\r\n\r\n```java\r\npublic String addEmployee(@Validated({GroupOne.class}) Employee employee){\r\n}  \r\n```\r\n\r\n\r\n\r\n\r\n```java\r\n@NotEmpty(message = "姓名不能为空",groups = {GroupOne.class})\r\nprivate String name;//员工姓名\r\n```\r\n\r\n# 2 ssm整合\r\n\r\n## 2.1 整合流程简介\r\n\r\n整合步骤分析\r\n\r\nSSM（Spring+SpringMVC+MyBatis）\r\n\r\n* Spring\r\n  * 框架基础\r\n\r\n* MyBatis\r\n  * mysql+druid+pagehelper\r\n\r\n* Spring整合MyBatis\r\n\r\n* junit测试业务层接口\r\n\r\n* SpringMVC\r\n  * rest风格（postman测试请求结果）\r\n  * 数据封装json（jackson）\r\n\r\n* Spring整合SpringMVC\r\n\r\n  * Controller调用Service\r\n\r\n* 其他\r\n\r\n  * 表现层数据封装\r\n\r\n  * 自定义异常\r\n\r\n**表结构**\r\n\r\n![image-20200506093609697](./img/java/springmvc/SpringMVC-day03/image-20200506093609697.png)\r\n\r\n​    最重要的5个步骤\r\n\r\n1. Spring\r\n\r\n2. MyBatis\r\n\r\n3. Spring整合MyBatis\r\n\r\n4. SpringMVC\r\n\r\n5. Spring整合SpringMVC\r\n\r\n\r\n\r\n## 2.2 项目结构搭建\r\n\r\n**Part0：**   项目基础结构搭建\r\n\r\n* 创建项目，组织项目结构，创建包\r\n\r\n* 创建表与实体类\r\n\r\n* 创建三层架构对应的模块、接口与实体类，建立关联关系\r\n\r\n* 数据层接口（代理自动创建实现类）\r\n  * 业务层接口+业务层实现类\r\n  * 表现层类\r\n\r\n\r\n\r\n![image-20200506094053535](./img/java/springmvc/SpringMVC-day03/image-20200506094053535.png)\r\n\r\n\r\n\r\n```java\r\npublic interface UserDao {\r\n    public boolean save(User user);  public boolean update(User user);  \r\n    public boolean delete(Integer uuid);  public User get(Integer uuid);\r\n    public List<User> getAll(int page,int size);\r\n\r\n    public interface UserService {  \r\n        public boolean save(User user);  public boolean update(User user);\r\n        public boolean delete(Integer uuid);\r\n        public User get(Integer uuid);\r\n        public List<User> getAll(int page, int size);\r\n        /**\r\n        用户登录\r\n        @param userName 用户名\r\n        @param password 密码信息\r\n        @return\r\n        */\r\n        public User login(String userName,String password);\r\n    }\r\n```\r\n\r\n\r\n\r\n## 2.3 Spring整合Mybatis（复习）\r\n\r\n**Part1 :**  Spring环境配置\r\n\r\n```xml\r\n<?xml version="1.0" encoding="UTF-8"?>\r\n<beans xmlns="http://www.springframework.org/schema/beans"  xmlns:context="http://www.springframework.org/schema/context"  xmlns:tx="http://www.springframework.org/schema/tx"  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xsi:schemaLocation="http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd  http://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context.xsd  http://www.springframework.org/schema/tx  http://www.springframework.org/schema/tx/spring-tx.xsd">\r\n\r\n    \x3c!--开启bean注解扫描--\x3e\r\n    <context:component-scan base-package="com.itheima"/>\r\n\r\n</beans>\r\n\r\n```\r\n\r\n**Part1 :**  Mybatis配置事务\r\n\r\n* MyBatis映射\r\n\r\n  ```xml\r\n  <?xml version="1.0" encoding="UTF-8"?>\r\n  <!DOCTYPE mapper\r\n          PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\r\n          "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\r\n  <mapper namespace="com.itheima.dao.UserDao">\r\n  \r\n      \x3c!--添加--\x3e\r\n      <insert id="save" parameterType="user">\r\n          insert into user(userName,password,realName,gender,birthday)values(#{userName},#{password},#{realName},#{gender},#{birthday})\r\n      </insert>\r\n  \r\n      \x3c!--删除--\x3e\r\n      <delete id="delete" parameterType="int">\r\n          delete from user where uuid = #{uuid}\r\n      </delete>\r\n  \r\n      \x3c!--修改--\x3e\r\n      <update id="update" parameterType="user">\r\n          update user set userName=#{userName},password=#{password},realName=#{realName},gender=#{gender},birthday=#{birthday} where uuid=#{uuid}\r\n      </update>\r\n  \r\n      \x3c!--查询单个--\x3e\r\n      <select id="get" resultType="user" parameterType="int">\r\n          select * from user where uuid = #{uuid}\r\n      </select>\r\n  \r\n      \x3c!--分页查询--\x3e\r\n      <select id="getAll" resultType="user">\r\n          select * from user\r\n      </select>\r\n  \r\n      \x3c!--登录--\x3e\r\n      <select id="getByUserNameAndPassword" resultType="user" >\r\n          select * from user where userName=#{userName} and password=#{password}\r\n      </select>\r\n  \r\n  </mapper>\r\n  ```\r\n\r\n  \r\n\r\n* Mybatis核心配置\r\n\r\n  ```xml\r\n  \x3c!--开启注解式事务--\x3e\r\n  <tx:annotation-driven transaction-manager="txManager"/>\r\n  \r\n  \x3c!--加载properties文件--\x3e\r\n  <context:property-placeholder location="classpath*:jdbc.properties"/>\r\n  \r\n  \x3c!--数据源--\x3e\r\n  <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">\r\n      <property name="driverClassName" value="${jdbc.driver}"/>\r\n      <property name="url" value="${jdbc.url}"/>\r\n      <property name="username" value="${jdbc.username}"/>\r\n      <property name="password" value="${jdbc.password}"/>\r\n  </bean>\r\n  \r\n  \x3c!--整合mybatis到spring中--\x3e\r\n  <bean class="org.mybatis.spring.SqlSessionFactoryBean">\r\n      <property name="dataSource" ref="dataSource"/>\r\n      <property name="typeAliasesPackage" value="com.itheima.domain"/>\r\n      \x3c!--分页插件--\x3e\r\n      <property name="plugins">\r\n          <array>\r\n              <bean class="com.github.pagehelper.PageInterceptor">\r\n                  <property name="properties">\r\n                      <props>\r\n                          <prop key="helperDialect">mysql</prop>\r\n                          <prop key="reasonable">true</prop>\r\n                      </props>\r\n                  </property>\r\n              </bean>\r\n          </array>\r\n      </property>\r\n  </bean>\r\n  \r\n  \x3c!--映射扫描--\x3e\r\n  <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">\r\n      <property name="basePackage" value="com.itheima.dao"/>\r\n  </bean>\r\n  \r\n  \x3c!--事务管理器--\x3e\r\n  <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\r\n      <property name="dataSource" ref="dataSource"/>\r\n  </bean>\r\n  ```\r\n\r\n  \r\n\r\n## 2.4 整合junit\r\n\r\n**Part2：**单元测试整合junit\r\n\r\n```java\r\n@RunWith(SpringJUnit4ClassRunner.class)  \r\n@ContextConfiguration(locations = "classpath:applicationContext.xml")  \r\npublic class UserServiceTest {\r\n\r\n    @Autowired\r\n    private UserService userService;\r\n\r\n    @Test\r\n    public void testDelete(){  \r\n        User user = new User();  userService.delete(3);\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n## 2.5 Spring整合SpringMVC\r\n\r\n**Part3：**SpringMVC\r\n\r\n* web.xml配置\r\n\r\n  ```xml\r\n  <servlet>\r\n      <servlet-name>DispatcherServlet</servlet-name>\r\n      <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\r\n      <init-param>\r\n          <param-name>contextConfigLocation</param-name>\r\n          <param-value>classpath*:spring-mvc.xml</param-value>\r\n      </init-param>\r\n  </servlet>\r\n  <servlet-mapping>\r\n      <servlet-name>DispatcherServlet</servlet-name>\r\n      <url-pattern>/</url-pattern>\r\n  </servlet-mapping>\r\n  ```\r\n\r\n* spring-mvc.xml\r\n\r\n  ```xml\r\n  <?xml version="1.0" encoding="UTF-8"?>\r\n  <beans xmlns="http://www.springframework.org/schema/beans"\r\n         xmlns:context="http://www.springframework.org/schema/context"\r\n         xmlns:mvc="http://www.springframework.org/schema/mvc"\r\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\r\n         xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\r\n          http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\r\n          http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">\r\n  \r\n      <mvc:annotation-driven/>\r\n  \r\n      <context:component-scan base-package="com.itheima.controller"/>\r\n  \r\n  </beans>\r\n  ```\r\n\r\n* controller层\r\n\r\n  ```java\r\n  @RestController  \r\n  @RequestMapping("/user")  public class UserController {\r\n      @PostMapping\r\n      public boolean save(User user) {  \r\n          System.out.println("save ..." + user);  return true;\r\n      }\r\n      @PostMapping("/login")\r\n      public User login(String userName,String password){  \r\n          System.out.println("login ..." + userName + " ," +password);\r\n          return null;\r\n      }\r\n  }\r\n  ```\r\n\r\n\r\n\r\n**Part4：**Spring整合SpringMVC\r\n\r\n* web.xml加载Spring环境\r\n\r\n  ```xml\r\n  <context-param>\r\n      <param-name>contextConfigLocation</param-name>\r\n      <param-value>classpath*:applicationContext.xml</param-value>\r\n  </context-param>\r\n  \r\n  \x3c!--启动服务器时，通过监听器加载spring运行环境--\x3e\r\n  <listener>\r\n      <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\r\n  </listener>\r\n  ```\r\n\r\n* Controller调用Service\r\n\r\n  ```java\r\n  @RestController\r\n  @RequestMapping("/user")\r\n  public class UserController {\r\n      @Autowired\r\n      private UserService userService;\r\n  \r\n  \r\n      @PostMapping\r\n      public boolean save(User user){\r\n          return userService.save(user);\r\n      }\r\n  }\r\n  ```\r\n\r\n## 2.6 表现层数据封装\r\n\r\n**Part5-1：**表现层数据封装\r\n\r\n* 前端接收表现层返回的数据种类\r\n\r\n| u操作是否成功 | true/false | 格式A |\r\n| ------------- | ---------- | ----- |\r\n| u单个数据     | 1,100,true | 格式B |\r\n| u对象数据     | json对象   | 格式C |\r\n| u集合数据     | json数组   | 格式D |\r\n\r\n![image-20200506103851845](./img/java/springmvc/SpringMVC-day03/image-20200506103851845.png)\r\n\r\n\r\n\r\n* 返回数据格式设计\r\n\r\n![image-20200506104339019](./img/java/springmvc/SpringMVC-day03/image-20200506104339019.png)\r\n\r\n* 代码\r\n\r\n  ```java\r\n  public class Result {\r\n      // 操作结果编码\r\n      private Integer code;\r\n      // 操作数据结果\r\n      private Object data;\r\n      // 消息\r\n      private String message;\r\n      public Result(Integer code) {\r\n          this.code = code;\r\n      }\r\n      public Result(Integer code, Object data) {\r\n          this.code = code;\r\n          this.data = data;\r\n      }\r\n  }\r\n  ```\r\n\r\n  状态码常量可以根据自己的业务需求设定\r\n\r\n  ```java\r\n  public class Code {\r\n      public static final Integer SAVE_OK = 20011;\r\n      public static final Integer SAVE_ERROR = 20010;\r\n      //其他编码\r\n  }\r\n  ```\r\n\r\n  controller 调用\r\n\r\n  ```java\r\n  @RestController\r\n  public class UserController {\r\n      @Autowired\r\n      private UserService userService;\r\n      @PostMapping\r\n      public Result save(User user){\r\n          boolean flag = userService.save(user);\r\n          return new Result(flag ? Code.SAVE_OK:Code.SAVE_ERROR);\r\n      }\r\n      @GetMapping("/{uuid}")\r\n      public Result get(@PathVariable Integer uuid){\r\n          User user = userService.get(uuid);\r\n          return new Result(null != user ?Code.GET_OK: Code.GET_ERROR,user);\r\n      }\r\n  }\r\n  ```\r\n\r\n  \r\n\r\n\r\n\r\n## 2.7 自定义异常\r\n\r\n**Part5-2：**自定义异常\r\n\r\n* 设定自定义异常，封装程序执行过程中出现的问题，便于表现层进行统一的异常拦截并进行处理\r\n  * BusinessException\r\n  * SystemException\r\n\r\n* 自定义异常消息返回时需要与业务正常执行的消息按照统一的格式进行处理\r\n\r\n\r\n\r\n**定义BusinessException**\r\n\r\n```java\r\npublic class BusinessException extends RuntimeException {\r\n    //自定义异常中封装对应的错误编码，用于异常处理时获取对应的操作编码\r\n    private Integer code;\r\n\r\n    public Integer getCode() {\r\n        return code;\r\n    }\r\n\r\n    public void setCode(Integer code) {\r\n        this.code = code;\r\n    }\r\n\r\n    public BusinessException(Integer code) {\r\n        this.code = code;\r\n    }\r\n\r\n    public BusinessException(String message, Integer code) {\r\n        super(message);\r\n        this.code = code;\r\n    }\r\n\r\n    public BusinessException(String message, Throwable cause,Integer code) {\r\n        super(message, cause);\r\n        this.code = code;\r\n    }\r\n\r\n    public BusinessException(Throwable cause,Integer code) {\r\n        super(cause);\r\n        this.code = code;\r\n    }\r\n\r\n    public BusinessException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace,Integer code) {\r\n        super(message, cause, enableSuppression, writableStackTrace);\r\n        this.code = code;\r\n    }\r\n}\r\n\r\n```\r\n\r\n```java\r\n@GetMapping("/{uuid}")\r\npublic Result get(@PathVariable Integer uuid){\r\n    User user = userService.get(uuid);\r\n    //模拟出现异常，使用条件控制，便于测试结果\r\n    if (uuid == 10 ) throw new BusinessException("查询出错啦，请重试！",Code.GET_ERROR);\r\n    return new Result(null != user ?Code.GET_OK: Code.GET_ERROR,user);\r\n}\r\n```\r\n\r\n\r\n\r\n## **2.8 返回消息兼容异常信息**\r\n\r\n```java\r\n@Component\r\n@ControllerAdvice\r\npublic class ProjectExceptionAdivce {\r\n    @ExceptionHandler(BusinessException.class)\r\n    @ResponseBody\r\n    //对出现异常的情况进行拦截，并将其处理成统一的页面数据结果格式\r\n    public Result doBusinessException(BusinessException e){\r\n        return new Result(e.getCode(),e.getMessage());\r\n    }\r\n}\r\n```\r\n\r\n# 3 纯注解开发SSM\r\n\r\n## 3.1 用注解替代applicationContext.xml\r\n\r\n同前期设置，添加事务注解驱动\r\n@Configuration\r\n\r\n```java\r\n//扫描组件，排除SpringMVC对应的bean，等同于<context:component-scan />\r\n@ComponentScan(value = "com.itheima",excludeFilters = {\r\n    @ComponentScan.Filter(type= FilterType.ANNOTATION,classes = {Controller.class})})\r\n@PropertySource("classpath:jdbc.properties")\r\n@Import({JdbcConfig.class,MyBatisConfig.class})\r\n//等同于<tx:annotation-driven transaction-manager="txManager"/>，导入的默认名称为transactionManager\r\n@EnableTransactionManagement\r\npublic class SpringConfig {\r\n    //等同于<bean   class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\r\n    @Bean("transactionManager")\r\n    public DataSourceTransactionManager getDataSourceTxManager(@Autowired DataSource dataSource){\r\n        DataSourceTransactionManager dtm = new DataSourceTransactionManager();\r\n        //等同于<property name="dataSource" ref="dataSource"/>\r\n        dtm.setDataSource(dataSource);\r\n        return dtm;\r\n    }\r\n}  \r\n```\r\n\r\n## 3.2 用注解替代spring-mvc.xml  \r\n\r\n*   同前期设置，添加@EnableWebMvc注解  \r\n\r\n  ```java\r\n  @Configuration\r\n  @ComponentScan("com.itheima.controller")\r\n  @EnableWebMvc\r\n  public class SpringMvcConfig implements WebMvcConfigurer {\r\n  }\r\n  ```\r\n\r\n*   EnableWebMvc  \r\n\r\n\r\n1. 支持ConversionService的配置，可以方便配置自定义类型转换器\r\n2. 支持@NumberFormat注解格式化数字类型\r\n3. 支持@DateTimeFormat注解格式化日期数据，日期包括Date,Calendar,JodaTime（JodaTime要导包）\r\n4. 支持@Valid的参数校验(需要导入JSR-303规范)\r\n5. 配合第三方jar包和SpringMVC提供的注解读写XML和JSON格式数据  ',va={data:function(){return{MainComponent:Sa}}},ba=va,ha=Object(d["a"])(ba,da,ga,!1,null,"00956706",null),ya=ha.exports,fa={mixins:[ce["c"]],components:{m1:Ar,m2:_r,m3:Vr,m4:Yr,m5:ia,m6:ma,m7:ya},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"spring IOC",value:"m1"},{label:"spring 注解",value:"m2"},{label:"spring AOP",value:"m3"},{label:"spring 事务",value:"m4"},{label:"springMVC",value:"m5"},{label:"springMVC",value:"m6"},{label:"springMVC",value:"m7"}]}}},xa=fa,wa=Object(d["a"])(xa,jr,Cr,!1,null,"42a83ff4",null),ja=wa.exports,Ca={mixins:[ce["c"]],components:{m1:ve,m3:Rt,m4:ke,m5:tr,m6:wr,m7:ja},data:function(){return{tab:"m1",tab_level:1,tabs:[{label:"JAVA基础",value:"m1"},{label:"javaweb",value:"m3"},{label:"JDBC",value:"m4"},{label:"mybatis",value:"m5"},{label:"maven",value:"m6"},{label:"springmvc",value:"m7"}]}}},Ta=Ca,Ea=Object(d["a"])(Ta,r,a,!1,null,"65191316",null);e["default"]=Ea.exports},3686:function(n,e,t){"use strict";t.d(e,"a",(function(){return i})),t("e260"),t("d81d"),t("fb6a"),t("4e82"),t("d3b7"),t("ac1f"),t("5319"),t("ddb0");var r=t("d958"),a=function(n){var e=r(n,{style:r.STYLE_NORMAL}),t="";return e.map((function(n){t+=n[0]})),t},i=function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"md",t=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];console.log("当前 require.context---",n),console.log("当前 field_components.keys()---",n.keys());var r=n.keys(),i={},s=[],o={},l=[];return r.map((function(r){var s=/[^\u4E00-\u9FA5A-Za-z]+/g,c=r.slice(2,r.length-e.length-1),p="";t?(p=a(r).replace(s,""),p=p.slice(0,p.length-e.length)):p=c,l.push(c),o[c]=p,console.log("x---",r),i[p]=n(r).default})),l.sort((function(n,e){return parseFloat(n)-parseFloat(e)})),l.map((function(n){s.push({label:n,value:o[n]})})),console.log("all_components------------",i),console.log("all_modules---------------",s),{all_components:i,all_modules:s}}},fd4e:function(n,e,t){"use strict";t.r(e),e["default"]='# JAVA核心知识点最详细版（面试必备）\r\n\r\n- \r\n  \\1. JVM、JRE及JDK的关系 ＊＊\r\n\r\n- \\2. JAVA语言特点　＊＊\r\n\r\n- \\3. JAVA和C++的区别　＊＊\r\n\r\n- \\4. Java的基本数据类型 　＊＊\r\n\r\n- \\5. 隐式(自动)类型转换和显示(强制)类型转换　＊＊\r\n\r\n- \\6. 自动装箱与拆箱 ＊＊\r\n\r\n- - String(不是基本数据类型)\r\n  - \\7. String的不可变性  ＊＊＊\r\n  - \\8. 字符型常量和字符串常量的区别 ＊\r\n  - \\9. 什么是字符串常量池？＊\r\n  - \\10. String 类的常用方法都有哪些？＊＊\r\n  - \\11. String和StringBuffer、StringBuilder的区别是什么？＊＊＊\r\n\r\n- \\12. switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上 ＊\r\n\r\n- \\13. Java语言采用何种编码方案？有何特点？＊\r\n\r\n- \\14. 访问修饰符 ＊＊\r\n\r\n- \\15. 运算符　＊\r\n\r\n- - 关键字\r\n  - \\16. static关键字　＊＊＊\r\n  - \\17. final 关键字　＊＊＊\r\n  - \\18. final finally finalize区别　＊＊＊\r\n  - \\19. this关键字　＊＊\r\n  - \\20. super关键字 ＊＊\r\n  - \\21. this与super的区别　＊＊\r\n  - \\22. break ,continue ,return 的区别及作用　＊＊\r\n\r\n- \\23. 面向对象和面向过程的区别　＊＊\r\n\r\n- \\24. 面向对象三大特性(封装、继承、多态)　＊＊＊\r\n\r\n- \\25. 面向对象五大基本原则是什么　＊＊\r\n\r\n- \\26. 抽象类和接口的对比　＊＊＊\r\n\r\n- \\27. 在Java中定义一个不做事且没有参数的构造方法的作用　＊\r\n\r\n- \\28. 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是 ＊\r\n\r\n- \\29. 一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？ ＊\r\n\r\n- \\30. 构造方法有哪些特性？　＊＊\r\n\r\n- \\31. 变量　＊＊\r\n\r\n- \\32. 内部类　＊＊\r\n\r\n- 重写与重载　＊＊＊\r\n\r\n- - \\33. 重载和重写的区别\r\n  - \\34. 构造器（constructor）是否可被重写（override）\r\n  - \\35. 重载的方法能否根据返回类型进行区分？为什么？\r\n\r\n- \\36. == 和 equals 的区别　＊＊＊\r\n\r\n- \\37. hashCode 与 equals（为什么重写equals方法后，hashCode方法也必须重写）　＊＊＊\r\n\r\n- \\38. Java 中是值传递还是引用传递，还是两者共存　＊＊\r\n\r\n- \\39. IO流　＊\r\n\r\n- \\40. BIO,NIO,AIO 有什么区别?　＊＊\r\n\r\n- \\41. 反射　＊＊＊\r\n\r\n- \\42. JAVA异常　＊＊＊\r\n\r\n- \\43. JAVA注解　＊＊\r\n\r\n- \\44. JAVA泛型　＊＊＊\r\n\r\n- \\45. JAVA序列化　＊＊\r\n\r\n- \\46. 深拷贝与浅拷贝　＊＊＊\r\n\r\n- \\47. 常见的Object方法　＊＊＊\r\n\r\n往期内容：\r\n\r\n- [面试官：请用五种方法来实现多线程交替打印问题](http://mp.weixin.qq.com/s?__biz=MzA4NjU1MzA2MQ==&mid=2647724685&idx=1&sn=0c4d54e897753b6ff2b67c4e214c28ba&chksm=87e34a07b094c311e5ed6d1d791d5d8e30ecd6c0975dbcdb1dfeab24b7c24614e6f6c119e365&scene=21#wechat_redirect)\r\n- [并发编程高频面试题第一弹](http://mp.weixin.qq.com/s?__biz=MzA4NjU1MzA2MQ==&mid=2647724650&idx=1&sn=361a6102991e5123a5a94727143aaca3&chksm=87e34ae0b094c3f6ec01c245b38312163af096c2b019e1dd89961279980655f49eb890bb9307&scene=21#wechat_redirect)\r\n- [技术岗面试中的一些常见问题](http://mp.weixin.qq.com/s?__biz=MzA4NjU1MzA2MQ==&mid=2647724575&idx=1&sn=1cb6f9974485a4fee9faaf6f12612132&chksm=87e34a95b094c383b055b18360f75df627aa2d8fa19678b2ae5386134af641ec5c2c06a49378&scene=21#wechat_redirect)\r\n\r\n## 1. JVM、JRE及JDK的关系 ＊＊\r\n\r\nJDK（Java Development Kit）是针对Java开发员的产品，是整个Java的核心，包括了Java运行环境JRE、Java工具和Java基础类库。\r\n\r\nJava Runtime Environment（JRE）是运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。\r\n\r\nJVM是Java Virtual Machine（Java虚拟机）的缩写，是整个java实现跨平台的最核心的部分，能够运行以Java语言写作的软件程序。\r\n\r\n**简单来说就是JDK是Java的开发工具，JRE是Java程序运行所需的环境，JVM是Java虚拟机．它们之间的关系是JDK包含JRE和JVM，JRE包含JVM．**\r\n\r\n## 2. JAVA语言特点　＊＊\r\n\r\n- Java是一种面向对象的语言\r\n- Java通过Java虚拟机实现了平台无关性，一次编译，到处运行\r\n- 支持多线程\r\n- 支持网络编程\r\n- 具有较高的安全性和可靠性\r\n\r\n## 3. JAVA和C++的区别　＊＊\r\n\r\n> 面试时记住前四个就行了\r\n\r\n- Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。\r\n- Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。\r\n- Java 支持自动垃圾回收，而 C++ 需要手动回收。\r\n- Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。\r\n- Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操 作符重载，而 C++ 可以。\r\n- Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。\r\n\r\n## 4. Java的基本数据类型 　＊＊\r\n\r\n> 注意`String`不是基本数据类型\r\n\r\n|     类型     | 关键字  | 包装器类型 | 占用内存(字节)(**重要**) |         取值范围          |  默认值  |\r\n| :----------: | :-----: | :--------: | :----------------------: | :-----------------------: | :------: |\r\n|    字节型    |  byte   |    Byte    |            1             | -128(-2^7)  ~  127(2^7-1) |    0     |\r\n|    短整型    |  short  |   Short    |            2             |     -2^15  ~  2^15-1      |    0     |\r\n|     整型     |   int   |  Integer   |            4             |     -2^31  ~  2^31-1      |    0     |\r\n|    长整型    |  long   |    Long    |            8             |     -2^63  ~  2^63-1      |    0L    |\r\n| 单精度浮点型 |  float  |   Float    |            4             |    3.4e-45  ~  1.4e38     |   0.0F   |\r\n| 双精度浮点型 | double  |   Double   |            8             |   4.9e-324  ~  1.8e308    |   0.0D   |\r\n|    字符型    |  char   | Character  |            2             |                           | \'\\u0000\' |\r\n|    布尔型    | boolean |  Boolean   |            1             |        true/flase         |  flase   |\r\n\r\n## 5. 隐式(自动)类型转换和显示(强制)类型转换　＊＊\r\n\r\n- 隐式(自动)类型转换：从存储范围小的类型到存储范围大的类型。`byte`→`short(char)`→`int`→`long`→`float`→`double`\r\n- 显示(强制)类型转换：从存储范围大的类型到存储范围小的类型。`double`→`float`→`long`→`int`→`short(char)`→`byte`。该类类型转换很可能存在精度的损失。\r\n\r\n看一个经典的代码\r\n\r\n```\r\nshort s = 1;\r\ns = s + 1;\r\n```\r\n\r\n这是会报错的，因为1是`int`型，`s+1`会自动转换为`int`型，将`int`型直接赋值给`short`型会报错。\r\n\r\n做一下修改即可避免报错\r\n\r\n```\r\nshort s = 1;\r\ns = (short)(s + 1);\r\n```\r\n\r\n或这样写，因为`s += 1`会自动进行强制类型转换\r\n\r\n```\r\nshort s = 1;\r\ns += 1;\r\n```\r\n\r\n## 6. 自动装箱与拆箱 ＊＊\r\n\r\n- 装箱：将基本类型用包装器类型包装起来\r\n\r\n- 拆箱：将包装器类型转换为基本类型\r\n\r\n  > 这个地方有很多易混淆的地方，但在面试中问到的频率一般，笔试的选择题中经常出现，还有一个`String`创建对象和这个比较像，很容易混淆，在下文可以看到\r\n\r\n- 下面这段代码的输出结果是什么？\r\n\r\n  ```\r\n  public class Main {\r\n      public static void main(String[] args) {\r\n          \r\n              Integer a = 100;\r\n              Integer b = 100;\r\n              Integer c = 128;\r\n              Integer d = 128;\r\n  \r\n              System.out.println(a==b);\r\n              System.out.println(c==d);\r\n      }\r\n  }\r\n  ```\r\n\r\n  ```\r\n  true\r\n  false\r\n  ```\r\n\r\n  很多人看到这个结果会很疑惑，为什么会是一个`true`一个`flase`．其实从源码中可以很容易找到原因．首先找到`Integer`方法中的`valueOf`方法\r\n\r\n  ```\r\n  public static Integer valueOf(int i) {\r\n        if (i >= IntegerCache.low && i <= IntegerCache.high)\r\n          return IntegerCache.cache[i + (-IntegerCache.low)];\r\n        return new Integer(i);\r\n    }\r\n  ```\r\n\r\n  可以看到当不满足`if`语句中的条件，就会重新创建一个对象返回，那结果必然不相等。继续打开`IntegerCache`可以看到\r\n\r\n  ```\r\n      private static class IntegerCache {\r\n            static final int low = -128;\r\n          static final int high;\r\n            static final Integer cache[];\r\n    \r\n            static {\r\n                // high value may be configured by property\r\n                int h = 127;\r\n                String integerCacheHighPropValue =\r\n                    sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");\r\n                if (integerCacheHighPropValue != null) {\r\n                    try {\r\n                        int i = parseInt(integerCacheHighPropValue);\r\n                        i = Math.max(i, 127);\r\n                        // Maximum array size is Integer.MAX_VALUE\r\n                        h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\r\n                    } catch( NumberFormatException nfe) {\r\n                        // If the property cannot be parsed into an int, ignore it.\r\n                    }\r\n                }\r\n                high = h;\r\n    \r\n                cache = new Integer[(high - low) + 1];\r\n                int j = low;\r\n                for(int k = 0; k < cache.length; k++)\r\n                    cache[k] = new Integer(j++);\r\n    \r\n                // range [-128, 127] must be interned (JLS7 5.1.7)\r\n                assert IntegerCache.high >= 127;\r\n            }\r\n    \r\n            private IntegerCache() {}\r\n        }\r\n  ```\r\n\r\n  代码挺长，大概说的就是在通过`valueOf`方法创建`Integer`对象的时候，如果数值在[-128,127]之间，便返回指向`IntegerCache.cache`中已经存在的对象的引用；否则创建一个新的`Integer`对象。所以上面代码中`a`与`b`相等，`c`与`d`不相等。\r\n\r\n- 再看下面的代码会输出什么\r\n\r\n  ```\r\n  public class Main {\r\n      public static void main(String[] args) {\r\n  \r\n              Double a = 1.0;\r\n              Double b = 1.0;\r\n              Double c = 2.0;\r\n              Double d = 2.0;\r\n  \r\n              System.out.println(a==b);\r\n              System.out.println(c==d);\r\n  \r\n      }\r\n  }\r\n  ```\r\n\r\n  ```\r\n  flase\r\n  flase\r\n  ```\r\n\r\n  采用同样的方法，可以看到`Double`的`valueOf`方法，每次返回都是重新`new`一个新的对象，所以上面代码中的结果都不想等。\r\n\r\n  ```\r\n  public static Double valueOf(double d) {\r\n            return new Double(d);\r\n  }\r\n  ```\r\n\r\n- 最后再看这段代码的输出结果\r\n\r\n  ```\r\n  public class Main {\r\n      public static void main(String[] args) {\r\n  \r\n          Boolean a = false;\r\n          Boolean b = false;\r\n          Boolean c = true;\r\n          Boolean d = true;\r\n  \r\n          System.out.println(a==b);\r\n          System.out.println(c==d);\r\n      }\r\n  }\r\n  ```\r\n\r\n  ```\r\n  true\r\n  true\r\n  ```\r\n\r\n  老方法继续看`valueOf`方法\r\n\r\n  ```\r\n  public static Boolean valueOf(boolean b) {\r\n          return (b ? TRUE : FALSE);\r\n      }\r\n  ```\r\n\r\n  再看看`TRUE`和`FALSE`是个什么东西，是两个静态成员属性。\r\n\r\n  ```\r\n  public static final Boolean TRUE = new Boolean(true);\r\n  public static final Boolean FALSE = new Boolean(false);\r\n  ```\r\n\r\n**说下结论 **：`Integer`、`Short`、`Byte`、`Character`、`Long`这几个类的`valueOf`方法的实现是类似的。`Double`、`Float`的`valueOf`方法的实现是类似的。然后是`Boolean`的`valueOf`方法是单独一组的。\r\n\r\n- `Integer i = new Integer(xxx)`和`Integer i =xxx`的区别\r\n\r\n  这两者的区别主要是第一种会触发自动装箱，第二者不会\r\n\r\n  最后看看下面这段程序的输出结果\r\n\r\n  ```\r\n  public class Main {\r\n      public static void main(String[] args) {\r\n          Integer a = 1;\r\n          Integer b = 2;\r\n          Integer c = 3;\r\n          Long g = 3L;\r\n          int int1 = 12;\r\n          int int2 = 12;\r\n          Integer integer1 = new Integer(12);\r\n          Integer integer2 = new Integer(12);\r\n          Integer integer3 = new Integer(1);\r\n  \r\n          System.out.println("c==(a+b) ->"+ (c==(a+b)));\r\n          System.out.println("g==(a+b) ->" + (g==(a+b)));\r\n          System.out.println( "c.equals(a+b) ->" + (c.equals(a+b)));\r\n          System.out.println( "g.equals(a+b) ->" + (g.equals(a+b)));\r\n          System.out.println("int1 == int2 -> " + (int1 == int2));\r\n          System.out.println("int1 == integer1 -> " + (int1 == integer1));\r\n          System.out.println("integer1 == integer2 -> " + (integer1 == integer2));\r\n          System.out.println("integer3 == a1 -> " + (integer3 == a));\r\n      }\r\n  }\r\n  ```\r\n\r\n  ```\r\n  c==(a+b) ->true\r\n  g==(a+b) ->true\r\n  c.equals(a+b) ->true\r\n  g.equals(a+b) ->false\r\n  int1 == int2 -> true\r\n  int1 == integer1 -> true\r\n  integer1 == integer2 -> false\r\n  integer3 == a1 -> false\r\n  ```\r\n\r\n  下面简单解释这些结果。\r\n\r\n  1.当 "=="运算符的两个操作数都是包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。所以`c==a+b`，`g==a+b`为`true`。\r\n\r\n  2.而对于`equals`方法会先触发自动拆箱过程，再触发自动装箱过程。也就是说a+b，会先各自调用`intValue`方法，得到了加法运算后的数值之后，便调用`Integer.valueOf`方法，再进行`equals`比较。所以`c.equals(a+b)`为`true`。而对于`g.equals(a+b)`，`a+b`会先拆箱进行相加运算，在装箱进行`equals`比较，但是装箱后为`Integer`，`g`为`Long`，所以`g.equals(a+b)`为`false`。\r\n\r\n  3.`int1 == int2`为`true`无需解释，`int1 == integer1`，在进行比较时，`integer1`会先进行一个拆箱操作变成`int`型在进行比较，所以`int1 == integer1`为`true`。\r\n\r\n  4.`integer1 == integer2`->`false`。`integer1`和`integer2`都是通过`new`关键字创建的，可以看成两个对象，所以`integer1 == integer2` 为`false`。`integer3 == a1` -> `false` , `integer3`是一个对象类型，而`a1`是一个常量它们存放内存的位置不一样，所以`integer3 == a1`为`false`，具体原因可学习下java的内存模型。\r\n\r\n### String(不是基本数据类型)\r\n\r\n### 7. String的不可变性  ＊＊＊\r\n\r\n在 Java 8 中，`String` 内部使用 `char` 数组存储数据。并且被声明为`final`，因此它不可被继承。\r\n\r\n```\r\npublic final class String implements java.io.Serializable, Comparable<String>, CharSequence { \r\n private final char value[];\r\n}\r\n```\r\n\r\n为什么`Strin`g`要设计成不可变的呢（不可变性的好处）:\r\n\r\n1.可以缓存 `hash` 值（）\r\n\r\n因为 `String` 的`hash`值经常被使用，例如`String` 用做 `HashMap` 的 `key`。不可变的特性可以使得 `hash`值也不可变， 因此只需要进行一次计算。\r\n\r\n2.常量池优化\r\n\r\n`String` 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。\r\n\r\n3.线程安全\r\n\r\n`String` 不可变性天生具备线程安全，可以在多个线程中安全地使用。\r\n\r\n### 8. 字符型常量和字符串常量的区别 ＊\r\n\r\n1. 形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符\r\n2. 含义上: 字符常量相当于一个整形值(ASCII值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)\r\n3. 占内存大小 字符常量占两个字节 字符串常量占若干个字节(至少一个字符结束标志)\r\n\r\n### 9. 什么是字符串常量池？＊\r\n\r\n字符串常量池位于堆内存中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串，在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。\r\n\r\n### 10. String 类的常用方法都有哪些？＊＊\r\n\r\n> 面试时一般不会问，但面试或笔试写字符串相关的算法题经常会涉及到，还是得背一背（以下大致是按使用频率优先级排序）\r\n\r\n- `length()`：返回字符串长度\r\n- `charAt()`：返回指定索引处的字符\r\n- `substring()`：截取字符串\r\n- `trim()`：去除字符串两端空白\r\n- `split()`：分割字符串，返回一个分割后的字符串数组。\r\n- `replace()`：字符串替换。\r\n- `indexOf()`：返回指定字符的索引。\r\n- `toLowerCase()`：将字符串转成小写字母。\r\n- `toUpperCase()`：将字符串转成大写字符。\r\n\r\n### 11. String和StringBuffer、StringBuilder的区别是什么？＊＊＊\r\n\r\n1.可变性\r\n\r\n`String`不可变，`StringBuilder`和`StringBuffer`是可变的\r\n\r\n2.线程安全性\r\n\r\n`String`由于是不可变的，所以线程安全。`StringBuffer`对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。 `StringBuilder`并没有对方法进行加同步锁，所以是非线程安全的。\r\n\r\n3.性能\r\n\r\n```\r\nStringBuilder` > `StringBuffer` > `String\r\n```\r\n\r\n> 为了方便记忆，总结如下\r\n\r\n|               | 是否可变 | 是否安全 | 性能 |\r\n| :-----------: | :------: | :------: | :--: |\r\n|    String     |  不可变  |   安全   |  低  |\r\n| StringBuilder |   可变   |  不安全  |  高  |\r\n| StringBuffer  |   可变   |   安全   | 较高 |\r\n\r\n## 12. switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上 ＊\r\n\r\n`switch`可以作用于`char` `byte` `short` `int`及它们对应的包装类型，`switch`不可作用于`long` `double` `float` `boolean`及他们的包装类型。在 JDK1.5之后可以作用于枚举类型，在JDK1.7之后可作用于`String`类型。\r\n\r\n## 13. Java语言采用何种编码方案？有何特点？＊\r\n\r\nJava语言采用Unicode编码标准，它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。\r\n\r\n## 14. 访问修饰符 ＊＊\r\n\r\n在Java编程语言中有四种权限访问控制符，这四种访问权限的控制符能够控制类中成员的可见性。其中类有两种`public`、`default`。而方法和变量有 4 种：`public`、`default`、`protected`、`private`。\r\n\r\n- **public** : 对所有类可见。使用对象：类、接口、变量、方法\r\n\r\n- **protected** : 对同一包内的类和所有子类可见。使用对象：变量、方法。**注意：不能修饰类（外部类）**。\r\n\r\n- **default** : 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。\r\n\r\n- **private** : 在同一类内可见。使用对象：变量、方法。**注意：不能修饰类（外部类）**\r\n\r\n  |  修饰符   | 当前类 | 同包内 | 子类(同包) | 其他包 |\r\n  | :-------: | :----: | :----: | :--------: | :----: |\r\n  |  public   |   Y    |   Y    |     Y      |   Y    |\r\n  | protected |   Y    |   Y    |     Y      |   N    |\r\n  |  default  |   Y    |   Y    |     Y      |   N    |\r\n  |  private  |   Y    |   N    |     N      |   N    |\r\n\r\n## 15. 运算符　＊\r\n\r\n- **&&和&**\r\n\r\n  `&&`和`&`都可以表示逻辑与，但他们是有区别的，共同点是他们两边的条件都成立的时候最终结果才是`true`；不同点是`&&`只要是第一个条件不成立为`false`，就不会再去判断第二个条件，最终结果直接为`false`，而`&`判断的是所有的条件。\r\n\r\n- **||和|**\r\n\r\n  `||`和`|`都表示逻辑或，共同点是只要两个判断条件其中有一个成立最终的结果就是`true`，区别是`||`只要满足第一个条件，后面的条件就不再判断，而`|`要对所有的条件进行判断。\r\n\r\n### 关键字\r\n\r\n### 16. static关键字　＊＊＊\r\n\r\n`static`关键字的主要用途**就是方便在没有创建对象时调用方法和变量和优化程序性能**\r\n\r\n**1.static变量（静态变量）**\r\n\r\n用`static`修饰的变量被称为静态变量，也被称为类变量，可以直接通过类名来访问它。静态变量被所有的对象共享，在内存中只有一个副本，仅当在类初次加载时会被初始化，而非静态变量在创建对象的时候被初始化，并且存在多个副本，各个对象拥有的副本互不影响。\r\n\r\n**2.static方法(静态方法)**\r\n\r\n`static`方法不依赖于任何对象就可以进行访问，在`static`方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用，但是在非静态成员方法中是可以访问静态成员方法/变量的。\r\n\r\n```\r\npublic class Main {\r\n    public static String s1 = "s1";//静态变量\r\n    String s2  = "s2";\r\n    public void fun1(){\r\n        System.out.println(s1);\r\n        System.out.println(s2);\r\n    }\r\n    \r\n    public static void fun2(){\r\n        System.out.println(s1);\r\n        System.out.println(s2);//此处报错，静态方法不能调用非静态变量\r\n    }\r\n}\r\n```\r\n\r\n**3.static代码块（静态代码块）**\r\n\r\n静态代码块的主要用途是可以用来优化程序的性能，因为它只会在类加载时加载一次，很多时候会将一些只需要进行一次的初始化操作都放在`static`代码块中进行。如果程序中有多个`static`块，在类初次被加载的时候，会按照`static`块的顺序来执行每个`static`块。\r\n\r\n```\r\npublic class Main {\r\n    static {\r\n        System.out.println("hello,word");\r\n    }\r\n    public static void main(String[] args) {\r\n        Main m = new Main();\r\n    }\r\n}\r\n```\r\n\r\n**4.可以通过this访问静态成员变量吗？（可以）**\r\n\r\n`this`代表当前对象，可以访问静态变量，而静态方法中是不能访问非静态变量,也不能使用`this`引用。\r\n\r\n**5.初始化顺序**\r\n\r\n静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。如果存在继承关系的话，初始化顺序为**父类中的静态变量和静态代码块——子类中的静态变量和静态代码块——父类中的实例变量和普通代码块——父类的构造函数——子类的实例变量和普通代码块——子类的构造函数**\r\n\r\n### 17. final 关键字　＊＊＊\r\n\r\n`final`关键字主要用于修饰类，变量，方法。\r\n\r\n1. 类：被`final`修饰的类不可以被继承\r\n2. 方法：被`final`修饰的方法不可以被重写\r\n3. 变量：被`final`修饰的变量是基本类型，变量的数值不能改变；被修饰的变量是引用类型，变量便不能在引用其他对象，但是变量所引用的对象本身是可以改变的。\r\n\r\n```\r\npublic class Main {\r\n    int a = 1;\r\n    public static void main(String[] args) {\r\n        final int b = 1;\r\n        b = 2;//报错\r\n        final Main m = new Main();\r\n        m.a = 2;//不报错,可以改变引用类型变量所指向的对象\r\n    }\r\n} \r\n```\r\n\r\n### 18. final finally finalize区别　＊＊＊\r\n\r\n- `final`主要用于修饰类，变量，方法\r\n- `finally`一般作用在`try-catch`代码块中，在处理异常的时候，通常我们将一定要执行的代码方法`finally`代码块 中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。\r\n- `finalize`是一个属于`Object`类的一个方法，该方法一般由垃圾回收器来调用，当我们调用`System.gc()`方法的时候，由垃圾回收器调用`finalize()`，回收垃圾，但Java语言规范并不保证`inalize`方法会被及时地执行、而且根本不会保证它们会被执行。\r\n\r\n### 19. this关键字　＊＊\r\n\r\n> 重点掌握前三种即可\r\n\r\n1.`this`关键字可用来引用当前类的实例变量。主要用于形参与成员名字重名，用`this`来区分。\r\n\r\n```\r\npublic Person(String name, int age) {\r\n    this.name = name;\r\n    this.age = age;\r\n}\r\n```\r\n\r\n2.`this`关键字可用于调用当前类方法。\r\n\r\n```\r\npublic class Main {\r\n    public void fun1(){\r\n        System.out.println("hello,word");\r\n    }\r\n    public void fun2(){\r\n        this.fun1();//this可省略\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Main m = new Main();\r\n        m.fun2();\r\n    }\r\n}\r\n```\r\n\r\n3.`this()`可以用来调用当前类的构造函数。(注意：`this()`一定要放在构造函数的第一行，否则编译不通过)\r\n\r\n```\r\nclass Person{\r\n    private String name;\r\n    private int age;\r\n    \r\n    public Person() {\r\n    }\r\n \r\n    public Person(String name) {\r\n        this.name = name;\r\n    }\r\n    public Person(String name, int age) {\r\n        this(name);\r\n        this.age = age;\r\n    }\r\n}\r\n```\r\n\r\n4.`this`关键字可作为调用方法中的参数传递。\r\n\r\n5.`this`关键字可作为参数在构造函数调用中传递。\r\n\r\n6.`this`关键字可用于从方法返回当前类的实例。super\r\n\r\n### 20. super关键字 ＊＊\r\n\r\n1.`super`可以用来引用直接父类的实例变量。和`this`类似，主要用于区分父类和子类中相同的字段\r\n\r\n2.`super`可以用来调用直接父类构造函数。(注意：`super()`一定要放在构造函数的第一行，否则编译不通过)\r\n\r\n3.`super`可以用来调用直接父类方法。\r\n\r\n```\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        Child child = new Child("Father","Child");\r\n        child.test();\r\n    }\r\n}\r\n\r\nclass Father{\r\n    protected String name;\r\n\r\n    public Father(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public void Say(){\r\n        System.out.println("hello,child");\r\n    }\r\n\r\n}\r\n\r\nclass Child extends Father{\r\n    private String name;\r\n\r\n    public Child(String name1, String name2) {\r\n        super(name1);      //调用直接父类构造函数\r\n        this.name = name2;\r\n    }\r\n\r\n    public void test(){\r\n        System.out.println(this.name);\r\n        System.out.println(super.name);  //引用直接父类的实例变量\r\n        super.Say();      //调用直接父类方法\r\n    }\r\n}\r\n```\r\n\r\n### 21. this与super的区别　＊＊\r\n\r\n- 相同点：\r\n\r\n- 1. `super()`和`this()`都必须在构造函数的第一行进行调用，否则就是错误的\r\n  2. `this()`和`super()`都指的是对象，所以，均不可以在`static`环境中使用。\r\n\r\n- 不同点：\r\n\r\n- 1. `super()`主要是对父类构造函数的调用，`this()`是对重载构造函数的调用\r\n  2. `super()`主要是在继承了父类的子类的构造函数中使用，是在不同类中的使用；`this()`主要是在同一类的不同构造函数中的使用\r\n\r\n### 22. break ,continue ,return 的区别及作用　＊＊\r\n\r\n- `break`结束当前的循环体\r\n- `continue`结束本次循环,进入下一次循环\r\n- `return`结束当前方法\r\n\r\n## 23. 面向对象和面向过程的区别　＊＊\r\n\r\n- 面向过程\r\n\r\n  优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源。\r\n\r\n  缺点：没有面向对象易维护、易复用、易扩展\r\n\r\n- 面向对象\r\n\r\n  优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护\r\n\r\n  缺点：性能比面向过程低\r\n\r\n## 24. 面向对象三大特性(封装、继承、多态)　＊＊＊\r\n\r\n- 封装\r\n\r\n  **封装就是隐藏对象的属性和实现细节，仅对外公开接口**，控制在程序中属性的读和修改的访问级别。\r\n\r\n- 继承\r\n\r\n  **继承就是子类继承父类的特征和行为**，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。\r\n\r\n- 多态（重要）\r\n\r\n  多态是同一个行为具有多个不同表现形式或形态的能力。这句话不是很好理解，可以看这个解释，在Java语言中，多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。\r\n\r\n  在Java中实现多态的三个必要条件：继承、重写、向上转型。继承和重写很好理解，向上转型是指在多态中需要将子类的引用赋给父类对象。\r\n\r\n  ```\r\n  public class Main {\r\n      public static void main(String[] args) {\r\n            Person person = new Student(); //向上转型\r\n            person.run();\r\n      }\r\n  }\r\n  \r\n  class Person {\r\n      public void run() {\r\n          System.out.println("Person");\r\n      }\r\n  }\r\n  \r\n  class Student extends Person {   //继承\r\n      @Override \r\n      public void run() {         //重载\r\n          System.out.println("Student");\r\n      }\r\n  }\r\n  ```\r\n\r\n  运行结果为\r\n\r\n  ```\r\n  Student\r\n  ```\r\n\r\n## 25. 面向对象五大基本原则是什么　＊＊\r\n\r\n- **单一职责原则（Single-Resposibility Principle）**\r\n\r\n  **一个类，最好只做一件事，只有一个引起它的变化。**单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。\r\n\r\n- **开放封闭原则（Open-Closed principle）**\r\n\r\n  **软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。**\r\n\r\n- **里氏替换原则** **（Liskov-Substituion Principle）**\r\n\r\n  **子类必须能够替换其基类。**这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。\r\n\r\n- **依赖倒置原则（Dependecy-Inversion Principle）**\r\n\r\n  **依赖于抽象。**具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。\r\n\r\n- **接口隔离原则（Interface-Segregation Principle）**\r\n\r\n  **使用多个小的专门的接口，而不要使用一个大的总接口。**\r\n\r\n## 26. 抽象类和接口的对比　＊＊＊\r\n\r\n在Java语言中，`abstract class`和`interface`是支持抽象类定义的两种机制。抽象类：用来捕捉子类的通用特性的。接口：抽象方法的集合。\r\n\r\n**相同点：**\r\n\r\n- 接口和抽象类都不能实例化\r\n- 都包含抽象方法，其子类都必须覆写这些抽象方法\r\n\r\n**不同点：**\r\n\r\n|    类型    |                            抽象类                            |                          接口                          |\r\n| :--------: | :----------------------------------------------------------: | :----------------------------------------------------: |\r\n|    定义    |                        abstract class                        |                       Interface                        |\r\n|    实现    |        extends(需要提供抽象类中所有声明的方法的实现)         |    implements（需要提供接口中所有声明的方法的实现）    |\r\n|    继承    | 抽象类可以继承一个类和实现多个接口；子类只可以继承一个抽象类 | 接口只可以继承接口（一个或多个）；子类可以实现多个接口 |\r\n| 访问修饰符 |      抽象方法可以有public、protected和default这些修饰符      |   接口方法默认修饰符是public。你不可以使用其它修饰符   |\r\n|   构造器   |                      抽象类可以有构造器                      |                    接口不能有构造器                    |\r\n|  字段声明  |                 抽象类的字段声明可以是任意的                 |         接口的字段默认都是 static 和 final 的          |\r\n\r\n## 27. 在Java中定义一个不做事且没有参数的构造方法的作用　＊\r\n\r\nJava程序存在继承，在执行子类的构造方法时，如果没有用`super()`来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。如果父类只定义了有参数的构造函数，而子类的构造函数没有用`super`调用父类那个特定的构造函数，就会出错。\r\n\r\n## 28. 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是 ＊\r\n\r\n帮助子类做初始化工作。\r\n\r\n## 29. 一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？ ＊\r\n\r\n主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。\r\n\r\n## 30. 构造方法有哪些特性？　＊＊\r\n\r\n- 方法名称和类同名\r\n- 不用定义返回值类型\r\n- 不可以写`retrun`语句\r\n- 构造方法可以被重载\r\n\r\n## 31. 变量　＊＊\r\n\r\n- 类变量：独立于方法之外的变量，用`static`修饰。\r\n\r\n- 实例变量：独立于方法之外的变量，不过没有 `static` 修饰。\r\n\r\n- 局部变量：类的方法中的变量。\r\n\r\n- 成员变量：成员变量又称全局变量，可分为类变量和实例变量，有`static`修饰为类变量，没有`static`修饰为实例变量。\r\n\r\n  |          |       类变量       |       实例变量       |         局部变量         |\r\n  | :------: | :----------------: | :------------------: | :----------------------: |\r\n  | 定义位置 |    类中，方法外    |     类中，方法外     |          方法中          |\r\n  |  初始值  |    有默认初始值    |     有默认初始值     |       无默认初始值       |\r\n  | 存储位置 |       方法区       |          堆          |            栈            |\r\n  | 生命周期 | 类何时被加载和卸载 | 实例何时被创建及销毁 | 方法何时被调用及结束调用 |\r\n\r\n## 32. 内部类　＊＊\r\n\r\n内部类包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类\r\n\r\n- 成员内部类\r\n\r\n  1.成员内部类定义为位于另一个类的内部，成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括`private`成员和静态成员）。\r\n\r\n  ```\r\n  class Outer{\r\n      private double a = 0;\r\n      public static int b =1;\r\n      public Outer(double a) {\r\n          this.a = a;\r\n      }\r\n  \r\n      class Inner {     //内部类\r\n          public void fun() {\r\n              System.out.println(a);\r\n              System.out.println(b);\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n  2.当成员内部类拥有和外部类同名的成员变量或者方法时，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：外部类.`this`.成员变量\r\n\r\n  3.在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问。\r\n\r\n  4.成员内部类是依附外部类而存在的，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：\r\n\r\n  ```\r\n  class Outter{\r\n      private double a = 0;\r\n      public static int b =1;\r\n      public Outter(){}\r\n      public Outter(double a) {\r\n          this.a = a;\r\n          Inner inner = new Inner();\r\n          inner.fun();     //调用内部类的方法\r\n      }\r\n  \r\n  \r\n      class Inner {     //内部类\r\n          int b = 2;\r\n          public void fun() {\r\n              System.out.println(a);\r\n              System.out.println(b);            //访问内部类的b\r\n              System.out.println(Outter.this.b);//访问外部类的b\r\n          }\r\n      }\r\n  }\r\n  public class Main{\r\n      public static void main(String[] args) {\r\n          Outter outter = new Outter();\r\n          Outter.Inner inner = outter.new Inner(); //创建内部类的对象\r\n      }\r\n  }\r\n  ```\r\n\r\n- 局部内部类\r\n\r\n  局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。\r\n\r\n  ```\r\n  class Outter {\r\n  \r\n      private int outter_a = 1;\r\n      private static int static_b = 2;\r\n  \r\n      public void test1(){\r\n          int inner_c =3;\r\n          class Inner {\r\n              private void fun(){\r\n                  System.out.println(outter_a);\r\n                  System.out.println(static_b);\r\n                  System.out.println(inner_c);\r\n              }\r\n          }\r\n          Inner  inner = new Inner(); //创建局部内部类\r\n          inner.fun();\r\n      }\r\n      public static void test2(){\r\n          int inner_d =3;\r\n          class Inner {\r\n              private void fun(){\r\n                   System.out.println(outter_a); //编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量\r\n                  System.out.println(static_b);\r\n                  System.out.println(inner_d);\r\n              }\r\n          }\r\n          Inner  inner = new Inner();\r\n          inner.fun();\r\n      }\r\n  }\r\n  ```\r\n\r\n- 匿名内部类\r\n\r\n  匿名内部类只没有名字的内部类，在日常开发中使用较多。使用匿名内部类的前提条件：必须继承一个父类或实现一个接口。\r\n\r\n  ```\r\n  interface Person {\r\n      public void fun();\r\n  }\r\n  class Demo {\r\n      public static void main(String[] args) {\r\n           new Person() {\r\n              public void fun() {\r\n                  System.out.println("hello,word");\r\n              }\r\n          }.fun();\r\n      }\r\n  }\r\n  ```\r\n\r\n- 静态内部类\r\n\r\n  静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字`static`。静态内部类是不需要依赖于外部类的，并且它不能使用外部类的非`static`成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非`static`成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。\r\n\r\n  ```\r\n  class Outter {\r\n      int a = 1;\r\n      static int b = 2;\r\n      public Outter() {\r\n  \r\n      }\r\n  \r\n      static class Inner {\r\n          public Inner() {\r\n              System.out.println(a);//报错，静态内部类不能访问非静态变量\r\n              System.out.println(b);\r\n          }\r\n      }\r\n  \r\n  }\r\n  public class Main{\r\n      public static void main(String[] args) {\r\n          Outter.Inner inner = new Outter.Inner();\r\n      }\r\n  }\r\n  ```\r\n\r\n- 内部类的优点：\r\n\r\n- 1. 内部类不为同一包的其他类所见，具有很好的封装性；\r\n  2. 匿名内部类可以很方便的定义回调。\r\n  3. 每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。\r\n  4. 内部类有效实现了“多重继承”，优化 java 单继承的缺陷。\r\n\r\n- 局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上`final`？\r\n\r\n  ```\r\n  public class Main {\r\n      public static void main(String[] args)  {\r\n           \r\n      }\r\n       \r\n      public void fun(final int b) {\r\n          final int a = 10;\r\n          new Thread(){\r\n              public void run() {\r\n                  System.out.println(a);\r\n                  System.out.println(b);\r\n              };\r\n          }.start();\r\n      }\r\n  }\r\n  ```\r\n\r\n  对于变量`a`可以从生命周期的角度理解，局部变量直接存储在栈中，当方法执行结束后，非`final`的局部变量就被销毁，而局部内部类对局部变量的引用依然存在，如果局部内部类要调用没有`final`修饰的局部变量时，就会造成生命周期不一致出错。\r\n\r\n  对于变量`b`，其实是将`fun`方法中的变量`b`以参数的形式对匿名内部类中的拷贝（变量`b`的拷贝）进行赋值初始化。在`run`方法中访问的变量`b`根本就不是`test`方法中的局部变量`b`，而是一个拷贝值，所以不存在生命周期不一致的问题，但如果在`run`方法中修改变量`b`的值会导致数据不一致，所以需要加`final`修饰。\r\n\r\n## 重写与重载　＊＊＊\r\n\r\n### 33. 重载和重写的区别\r\n\r\n- 重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分。\r\n- 重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为`private`则子类中就不是重写。\r\n\r\n### 34. 构造器（constructor）是否可被重写（override）\r\n\r\n构造器可以被重载，不能被重写\r\n\r\n### 35. 重载的方法能否根据返回类型进行区分？为什么？\r\n\r\n不能，因为调用时不能指定类型信息，编译器不知道你要调用哪个函数。\r\n\r\n## 36. == 和 equals 的区别　＊＊＊\r\n\r\n- ==\r\n\r\n  对于基本数据类型，`==`比较的是值；对于引用数据类型，`==`比较的是内存地址。\r\n\r\n- eauals\r\n\r\n  对于没有重写`equals`方法的类，`equals`方法和`==`作用类似；对于重写过`equals`方法的类，`equals`比较的是值。\r\n\r\n## 37. hashCode 与 equals（为什么重写equals方法后，hashCode方法也必须重写）　＊＊＊\r\n\r\n- equals\r\n\r\n  先看下`String`类中重写的`equals`方法。\r\n\r\n  ```\r\n      public boolean equals(Object anObject) {\r\n          if (this == anObject) {\r\n              return true;\r\n          }\r\n          if (anObject instanceof String) {\r\n              String anotherString = (String)anObject;\r\n              int n = value.length;\r\n              if (n == anotherString.value.length) {\r\n                  char v1[] = value;\r\n                  char v2[] = anotherString.value;\r\n                  int i = 0;\r\n                  while (n-- != 0) {\r\n                      if (v1[i] != v2[i])\r\n                          return false;\r\n                      i++;\r\n                  }\r\n                  return true;\r\n              }\r\n          }\r\n          return false;\r\n      }\r\n  ```\r\n\r\n  从源码中可以看到：\r\n\r\n- 1. `equals`方法首先比较的是内存地址，如果内存地址相同，直接返回`true`；如果内存地址不同，再比较对象的类型，类型不同直接返回`false`；类型相同，再比较值是否相同；值相同返回`true`，值不同返回`false`。总结一下，`equals`会比较**内存地址、对象类型、以及值**，内存地址相同，`equals`一定返回`true`；对象类型和值相同，`equals`方法一定返回`true`。\r\n  2. 如果没有重写`equals`方法，那么`equals`和`==`的作用相同，比较的是对象的地址值。\r\n\r\n- `hashCode`\r\n\r\n  `hashCode`方法返回对象的散列码，返回值是`int`类型的散列码。散列码的作用是确定该对象在哈希表中的索引位置。\r\n\r\n  关于`hashCode`有一些约定：\r\n\r\n- 1. 两个对象相等，则`hashCode`一定相同。\r\n  2. 两个对象有相同的`hashCode`值，它们不一定相等。\r\n  3. `hashCode()`方法默认是对堆上的对象产生独特值，如果没有重写`hashCode()`方法，则该类的两个对象的`hashCode`值肯定不同\r\n\r\n- 为什么重写`equals`方法后，`hashCode`方法也必须重写\r\n\r\n- 1. 根据规定，两个对象相等，`hashCode`值也许相同，所以重写`equals`方法后，`hashCode`方法也必须重写（面试官肯定不是想听这个答案）\r\n  2. `hashCode`在具有哈希机制的集合中起着非常关键的作用，比如`HashMap`、`HashSet`等。以`HashSet`为例，`HashSet`的特点是存储元素时无序且唯一，在向`HashSet`中添加对象时，首先会计算对象的`HashCode`值来确定对象的存储位置，如果该位置没有其他对象，直接将该对象添加到该位置；如果该存储位置有存储其他对象（新添加的对象和该存储位置的对象的`HashCode`值相同），调用`equals`方法判断两个对象是否相同，如果相同，则添加对象失败，如果不相同，则会将该对象重新散列到其他位置。所以重写`equals`方法后，`hashCode`方法不重写的话，会导致所有对象的`HashCode`值都不相同，都能添加成功，那么`HashSet`中会出现很多重复元素，`HashMap`也是同理（因为`HashSet`的底层就是通过`HashMap`实现的），会出现大量相同的`Key`（`HashMap`中的`key`是唯一的，但不同的`key`可以对应相同的`value`）。所以重写`equals`方法后，`hashCode`方法也必须重写。同时因为两个对象的`hashCode`值不同，则它们一定不相等，所以先计算对象的`hashCode`值可以在一定程度上判断两个对象是否相等，提高了集合的效率。总结一下，一共两点：**第一，在`HashSet`等集合中，不重写`hashCode`方法会导致其功能出现问题；第二，可以提高集合效率。**\r\n\r\n## 38. Java 中是值传递还是引用传递，还是两者共存　＊＊\r\n\r\n> 这是一个很容易搞混又很难解释清楚的问题，先说结论，Java中只有值传递\r\n\r\n先看这样一段代码\r\n\r\n```\r\npublic class Main{\r\n    public static void main(String[] args) {\r\n        int a = 1;\r\n        printValue(a);\r\n        System.out.println("a:" + a);\r\n    }\r\n    public static void printValue(int b){\r\n        b = 2;\r\n        System.out.println("b:"+ b);\r\n    }\r\n}\r\n```\r\n\r\n输出\r\n\r\n```\r\nb:2\r\na:1\r\n```\r\n\r\n可以看到将`a`的值传到`printValue`方法中，并将其值改为2。但方法调用结束后，`a`的值还是1，并未发生改变，所以这种情况下为值传递。\r\n\r\n再看这段代码\r\n\r\n```\r\npublic class Main{\r\n    public static void main(String[] args) {\r\n        Preson p = new Preson();\r\n        p.name = "zhangsan";\r\n        printValue(p);\r\n        System.out.println("p.name: " + p.name);\r\n    }\r\n    public static void printValue(Preson q){\r\n        q.name = "lisi";\r\n        System.out.println("q.name: "+ q.name);\r\n    }\r\n}\r\nclass Preson{\r\n    public String name;\r\n}\r\n```\r\n\r\n输出结果\r\n\r\n```\r\nq.name: lisi\r\np.name: lisi\r\n```\r\n\r\n在将`p`传入`printValue`方法后，方法调用结束，`p`的`name`属性竟然被改变了！所以得出结论，参数为基本类型为值传递，参数为引用类型为时为引用传递。这个结论是错误的，下面来看看判断是值传递还是值传递的关键是什么，先看定义\r\n\r\n- 值传递：是指在调用函数时将实际参数**复制一份**传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。\r\n- 引用传递：是指在调用函数时将实际参数的**地址**直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。\r\n\r\n从定义中可以明显看出，区分是值传递还是引用传递主要是看**向方法中传递的是实际参数的副本还是实际参数的地址**。上面第一个例子很明显是值传递，其实第二个例子中向`printValue`方法中传递的是一个引用的副本，只是这个**副本引用和原始的引用指向的同一个对象**，所以副本引用修改过对象属性后，通过原始引用查看对象属性肯定也是被修改过的。换句话说，`printValue`方法中修改的是副本引用指向的对象的属性，不是引用本身，如果修改的是引用本身，那么原始引用肯定不受影响。看下面这个例子\r\n\r\n```\r\npublic class Main{\r\n    public static void main(String[] args) {\r\n        Preson p = new Preson();\r\n        p.name = "zhangsan";\r\n        printValue(p);\r\n        System.out.println("p.name: " + p.name);\r\n    }\r\n    public static void printValue(Preson q){\r\n        q = new Preson();\r\n        q.name = "lisi";\r\n        System.out.println("q.name: "+ q.name);\r\n    }\r\n}\r\nclass Preson{\r\n    public String name;\r\n}\r\n```\r\n\r\n输出结果\r\n\r\n```\r\nq.name: lisi\r\np.name: zhangsan\r\n```\r\n\r\n可以看到将`p`传入`printValue`方法后，`printValue`方法调用结束后，`p`的属性`name`没有改变，这是因为**在`printValue`方法中并没有改变副本引用`q`所指向的对象，而是改变了副本引用`q`本身，将副本引用`q`指向了另一个对象并对这个对象的属性进行修改**，所以原始引用`p`所指向的对象不受影响。所以证明Java中只存在值传递。\r\n\r\n## 39. IO流　＊\r\n\r\nJava IO流主要可以分为输入流和输出流。按照照操作单元划分，可以划分为字节流和字符流。按照流的角色划分为节点流和处理流。\r\n\r\nJava I0流的40多个类都是从4个抽象类基类中派生出来的。\r\n\r\n- InputStream：字节输入流\r\n- Reader：字符输入流\r\n- OutputStream：字节输出流\r\n- Writer：字符输出流\r\n\r\n## 40. BIO,NIO,AIO 有什么区别?　＊＊\r\n\r\n- **BIO (Blocking I/O)：**服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制来改善。BIO方式适用于连接数目比较小且固定的架构，这种方式对服务端资源要求比较高，并发局限于应用中，在jdk1.4以前是唯一的io\r\n\r\n- **NIO (New I/O)：**服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有IO请求时才启动一个线程进行处理。NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，jdk1,4开始支持\r\n\r\n- **AIO (Asynchronous I/O)：**服务器实现模式为一个有效请求一个线程，客户端的IO请求都是由操作系统先完成了再通知服务器用其启动线程进行处理。AIO方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，jdk1.7开始支持。\r\n\r\n  这些概念看着比较枯燥，可以从这个经典的烧开水的例子去理解\r\n\r\n  **BIO ：**来到厨房，开始烧水，并坐在水壶面前一直等着水烧开。\r\n\r\n  **NIO**：来到厨房，开始烧水，但是我们不一直坐在水壶前面等，而是做些其他事，然后每隔几分钟到厨房看一下水有没有烧开。\r\n\r\n  **AIO**：来到厨房，开始烧水，我们不一直坐在水壶前面等，而是在水壶上面装个开关，水烧开之后它会通知我。\r\n\r\n## 41. 反射　＊＊＊\r\n\r\nJAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。\r\n\r\nJava获取Class对象的三种方式\r\n\r\n```\r\nclass Person {\r\n    public String name = "zhangsan";\r\n    public Person() {\r\n    }\r\n}\r\npublic class Main{\r\n    public static void main(String[] args) throws ClassNotFoundException {\r\n //方式1\r\n     Person p1 = new Person();\r\n     Class c1 = p1.getClass();\r\n     //方式2\r\n    Class c2 = Person.class;\r\n    //方式3可能会抛出ClassNotFoundException异常\r\n    Class c3 = Class.forName("com.company");\r\n    }\r\n}\r\n```\r\n\r\n因为在一个类在 JVM 中只会有一个 `Class` 实例，所以对`c1`、`c2`、`c3`进行`equals`比较时返回的都是`true`。\r\n\r\n**反射优缺点：**\r\n\r\n- 优点：运行期类型的判断，动态加载类，提高代码灵活度。\r\n- 缺点：性能比直接的java代码要慢很多。\r\n\r\n**反射应用场景：**\r\n\r\n1. Java的很多框架都用到了反射，例如`Spring`中的xml的配置模式等\r\n2. 动态代理设计模式也采用了反射机制\r\n\r\n## 42. JAVA异常　＊＊＊\r\n\r\n异常主要分为`Error`和`Exception`两种\r\n\r\n- Error：`Error`类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理。\r\n- EXception：`Exception`以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。\r\n\r\n异常框图\r\n\r\n![image](\\JAVA核心知识点最详细版.assets\\66.png)\r\n\r\n除了以上的分类，异常还能分为非检查异常和检查异常\r\n\r\n- **非检查异常**（unckecked exception）：**该类异常包括运行时异常（RuntimeException及其子类）和错误（Error）。**编译器不会进行检查并且不要求必须处理的异常，也就说当程序中出现此类异常时，即使我们没有`try-catch`捕获它，也没有使用`throws`抛出该异常，编译也会正常通过。因为这样的异常发生的原因很可能是代码写的有问题。\r\n- **检查异常**（checked exception）：**除了`Error`和 `RuntimeException`的其它异常。**这是编译器要求必须处理的异常。这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，所以必须处理这些异常。\r\n\r\n> 下面来看下`try{}catch(){}finally{}`和`return`之间的“恩恩怨怨”，这里有些乱，面试时问的也不是很多，实在记不住就算啦。还是先看代码猜结果。\r\n\r\n```\r\npublic class Main{\r\n    public static void main(String[] args) {\r\n        int a = test1();\r\n        System.out.println(a);\r\n        int b = test2();\r\n        System.out.println(b);\r\n        int c = test3();\r\n        System.out.println(c);\r\n        int d = test4();\r\n        System.out.println(d);\r\n        int e = test5();\r\n        System.out.println(e);\r\n    }\r\n    public static int test1(){\r\n        int a = 1;\r\n        try{\r\n            a = 2;\r\n            return a;\r\n        }catch(Exception e){\r\n            System.out.println("hello,test1");\r\n            a = 3;\r\n        }finally{\r\n            a = 4;\r\n        }\r\n        return a;\r\n    }\r\n    //输出 2\r\n    \r\n    \r\n    public static int test2(){\r\n        int a = 1;\r\n        try{\r\n            a = 2;\r\n            return a;\r\n        }catch(Exception e){\r\n            System.out.println("hello,test2");\r\n            a = 3;\r\n            return a;\r\n        }finally{\r\n            a = 4;\r\n        }\r\n    }\r\n    //输出 2\r\n    \r\n    \r\n    public static int test3(){\r\n        int a = 1;\r\n        try{\r\n            a = 2/0;\r\n            return a;\r\n        }catch(Exception e){\r\n            System.out.println("hello,test3");\r\n            a = 3;\r\n        }finally{\r\n            a = 4;\r\n        }\r\n        return a;\r\n    }\r\n    //输出 hello,test3 \r\n    // 4\r\n    \r\n    \r\n    public static int test4(){\r\n        int a = 1;\r\n        try{\r\n            a = 2/0;\r\n            return a;\r\n        }catch(Exception e){\r\n            System.out.println("hello,test4");\r\n            a = 3;\r\n            return a;\r\n        }finally{\r\n            a = 4;\r\n        }\r\n    }\r\n    //输出 hello,test4\r\n    // 3\r\n    \r\n    public static int test5(){\r\n        int a = 1;\r\n        try{\r\n            a = 2/0;\r\n            return a;\r\n        }catch(Exception e){\r\n            a = 3;\r\n            return a;\r\n        }finally{\r\n            a = 4;\r\n            return a;\r\n        }\r\n    }\r\n    \r\n    //输出 4\r\n}\r\n```\r\n\r\n如果没有仔细的研究过，应该好多会猜错，下面总结下规律。\r\n\r\n1. 从前三个例子可以看出如果`try{}`中的代码没有异常，`catch(){}`代码块中的代码不会执行。所以如果`try{}`和`catch(){}`都含有`return`时，无异常执行`try{}`中的`return`，存在异常执行`catch(){}`的`return`。\r\n2. 不管任何情况，就算`try{}`或`catch(){}`中含有`return`，`finally{}`中的代码一定会执行，那么为什么`test1`、`test2`、`test3`中的结果不是4呢，因为虽然`finally`是在`return`后面的表达式运算之后执行的，但此时并没有返回运算之后的值，而是把值保存起来，不管`finally`对该值做任何的改变，返回的值都不会改变，依然返回保存起来的值。也就是说方法的返回值是在`finally`运算之前就确定了的。\r\n3. 如果`return`的数据是引用数据类型，而在`finally`中对该引用数据类型的属性值的改变起作用，`try`中的`return`语句返回的就是在`finally`中改变后的该属性的值。这个不理解可以看看上面提到的Java的值传递的问题。\r\n4. 如果`finally{}`中含有`return`，会导致程序提前退出，不在执行`try{}`或`catch(){}`中的`return`。所以`test5`返回的值是4。\r\n\r\n最后总计一下`try{}catch(){}finally{}`的执行顺序。\r\n\r\n1. 先执行`try`中的语句，包括`return`后面的表达式；\r\n2. 有异常时,执行`catch`中的语句，包括`return`后面的表达式，无异常跳过`catch`语句；\r\n3. 然后执行`finally`中的语句，如果`finally`里面有`return`语句，执行`return`语句，程序结束；\r\n4. `finally{}`中没有`return`时，无异常执行`try`中的`return`，如果有异常时则执行`catch`中的`return`。前两步执行的`return`只是确定返回的值，程序并未结束，`finally{}`执行之后，最后将前两步确定的`return`的返回值返回。\r\n\r\n## 43. JAVA注解　＊＊\r\n\r\n> 面试问的不多，但是在使用框架开发时会经常使用，但东西太多了，这里只是简单介绍下概念。\r\n\r\n`Annotation`注解可以看成是java中的一种标记记号，用来给java中的类，成员，方法，参数等任何程序元素添加一些额外的说明信息，同时不改变程序语义。注解可以分为三类：基本注解，元注解，自定义注解\r\n\r\n- 标准注解\r\n\r\n- 1. @Deprecated：该注解用来说明程序中的某个元素（类，方法，成员变量等）已经不再使用，如果使用的话的编译器会给出警告。\r\n  2. @SuppressWarnings(value=“”)：用来抑制各种可能出现的警告。\r\n  3. @Override：用来说明子类方法覆盖了父类的方法，保护覆盖方法的正确使用\r\n\r\n- 元注解（元注解也称为元数据注解，是对注解进行标注的注解，元注解更像是一种对注解的规范说明，用来对定义的注解进行行为的限定。例如说明注解的生存周期，注解的作用范围等）\r\n\r\n- 1. @Target(value=“ ”)：该注解是用来限制注解的使用范围的，即该注解可以用于哪些程序元素。\r\n  2. @Retention(value=“ ”)：用于说明注解的生存周期\r\n  3. @Documnent：用来说明指定被修饰的注解可以被javadoc.exe工具提取进入文档中，所有使用了该注解进行标注的类在生成API文档时都在包含该注解的说明。\r\n  4. @Inherited：用来说明使用了该注解的父类，其子类会自动继承该注解。\r\n  5. @Repeatable：java1.8新出的元注解，如果需要在给程序元素使用相同类型的注解，则需将该注解标注上。\r\n\r\n- 自定义注解：用@Interface来声明注解。\r\n\r\n## 44. JAVA泛型　＊＊＊\r\n\r\nJava 泛型是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。\r\n\r\n- 泛型擦除（这是面试考察泛型时经常问到的问题）\r\n\r\n  Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。看下面代码\r\n\r\n  ```\r\n  public class Main{\r\n      public static void main(String[] args) {\r\n          ArrayList<Integer> arrayList1 = new ArrayList<>();\r\n          ArrayList<String> arrayList2 = new ArrayList<>();\r\n  \r\n          System.out.println(arrayList1.getClass() == arrayList2.getClass());\r\n      }\r\n  }\r\n  ```\r\n\r\n  输出结果\r\n\r\n  ```\r\n  true\r\n  ```\r\n\r\n  可以看到`ArrayList<Integer>`和`ArrayList<String>`的原始类型是相同，在编译成字节码文件后都会变成`List`，JVM看到的只有`List`，看不到泛型信息，这就是泛型的类型擦除。再看下面这段代码\r\n\r\n  ```\r\n  public class Main{\r\n      public static void main(String[] args) throws Exception {\r\n          ArrayList<Integer> arrayList = new ArrayList<>();\r\n          arrayList.add(1);\r\n          arrayList.getClass().getMethod("add", Object.class).invoke(arrayList, "a");\r\n          System.out.println(arrayList.get(0));\r\n          System.out.println(arrayList.get(1));\r\n      }\r\n  }\r\n  ```\r\n\r\n  输出\r\n\r\n  ```\r\n  1\r\n  a\r\n  ```\r\n\r\n  可以看到通过反射进行`add`操作，`ArrayList<Integer>`竟然可以存储字符串，这是因为在反射就是在运行期调用的`add`方法，在运行期泛型信息已经被擦除。\r\n\r\n- 既然存在类型擦除，那么Java是如何保证在`ArrayList<Integer>`添加字符串会报错呢？\r\n\r\n  Java编译器是通过先检查代码中泛型的类型，然后在进行类型擦除，再进行编译。\r\n\r\n## 45. JAVA序列化　＊＊\r\n\r\n- 序列化：将对象写入到IO流中\r\n\r\n- 反序列化：从IO流中恢复对象\r\n\r\n- 序列化的意义：将Java对象转换成字节序列，这些字节序列更加便于通过网络传输或存储在磁盘上，在需要时可以通过反序列化恢复成原来的对象。\r\n\r\n- 实现方式：\r\n\r\n- 1. 实现**Serializable**接口\r\n  2. 实现**Externalizable**接口\r\n\r\n- 序列化的注意事项：\r\n\r\n- 1. 对象的类名、实例变量会被序列化；方法、类变量、`transient`实例变量都不会被序列化。\r\n  2. 某个变量不被序列化，可以使用`transient`修饰。\r\n  3. 序列化对象的引用类型成员变量，也必须是可序列化的，否则，会报错。\r\n  4. 反序列化时必须有序列化对象的`class`文件。\r\n\r\n## 46. 深拷贝与浅拷贝　＊＊＊\r\n\r\n- 深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，两个引用指向两个对象，但对象内容相同。\r\n\r\n- 浅拷贝：对基本数据类型进行值传递，对引用数据类型复制一个引用指向原始引用的对象，就是复制的引用和原始引用指向同一个对象。\r\n\r\n  具体区别看下图\r\n\r\n  ![image](\\JAVA核心知识点最详细版.assets\\67.png)\r\n\r\n- 深拷贝的实现方式\r\n\r\n- 1. 重载`clone`方法\r\n\r\n     ```\r\n      public class Main{\r\n         public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException, CloneNotSupportedException {\r\n             Address s = new Address("天津");\r\n             Person p = new Person("张三", 23, s);\r\n             System.out.println("克隆前的地址：" + p.getAddress().getName());\r\n             Person cloneP = (Person) p.clone();\r\n             cloneP.getAddress().setName("北京");\r\n             System.out.println("克隆后的地址：" + cloneP.getAddress().getName());\r\n         }\r\n     }\r\n     \r\n     class Address implements Cloneable {\r\n         private String city;\r\n         public Address(String name){\r\n             this.city = name;\r\n     }\r\n         @Override\r\n         protected Object clone() throws CloneNotSupportedException {\r\n                 return super.clone();\r\n         }\r\n         public String getName() {\r\n             return city;\r\n     \r\n         }\r\n         public void setName(String name) {\r\n             this.city = name;\r\n     \r\n         }\r\n     }\r\n     class Person implements Cloneable{\r\n         private String name;\r\n         private int age;\r\n         private Address address;\r\n         public Person(String name, int age, Address address){\r\n             this.name = name;\r\n             this.age = age;\r\n             this.address = address;\r\n     \r\n         }\r\n         @Override\r\n         public Object clone() throws CloneNotSupportedException {\r\n               Person  person = (Person) super.clone();\r\n               person.address = (Address)address.clone();\r\n             return person;\r\n         }\r\n         public String getName() {\r\n             return name;\r\n         }\r\n         public void setName(String name) {\r\n             this.name = name;\r\n         }\r\n         public int getAge() {\r\n             return age;\r\n         }\r\n         public void setAge(int age) {\r\n             this.age = age;\r\n         }\r\n         public Address getAddress() {\r\n             return address;\r\n         }\r\n         public void setAddress(Address address) {\r\n             this.address = address;\r\n         }\r\n     }\r\n     ```\r\n\r\n     输出\r\n\r\n     ```\r\n     克隆前的地址：天津\r\n     克隆后的地址：北京\r\n     ```\r\n\r\n     其实就是`Person`类和`Address`类都要重写`clone`方法，这里面需要注意的一点是`super.clone()`为浅克隆，所以在在`Person`类中重写`clone`方法时，`address`对象需要调用`address.clone()`重新赋值，因为`address`类型为引用类型。\r\n\r\n  2. 序列化\r\n\r\n     ```\r\n     public class Main{\r\n         public static void main(String[] args) throws IOException, ClassNotFoundException {\r\n             Address s = new Address("天津");\r\n             Person p = new Person("张三", 23, s);\r\n             System.out.println("克隆前的地址：" + p.getAddress().getName());\r\n             Person cloneP = (Person) p.deepClone();\r\n             cloneP.getAddress().setName("北京");\r\n             System.out.println("克隆后的地址：" + cloneP.getAddress().getName());\r\n         }\r\n     }\r\n     \r\n     class Address implements Serializable{\r\n         private String city;\r\n         public Address(String name){\r\n             this.city = name;\r\n         }\r\n     \r\n         public String getName() {\r\n             return city;\r\n     \r\n         }\r\n         public void setName(String name) {\r\n             this.city = name;\r\n     \r\n         }\r\n     }\r\n     class Person implements Serializable{\r\n         private String name;\r\n         private int age;\r\n         private Address address;\r\n         public Person(String name, int age, Address address){\r\n             this.name = name;\r\n             this.age = age;\r\n             this.address = address;\r\n     \r\n         }\r\n     \r\n         public Object deepClone() throws IOException, ClassNotFoundException {        \r\n             ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n             ObjectOutputStream oos = new ObjectOutputStream(bos);\r\n             oos.writeObject(this);        \r\n             ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());\r\n             ObjectInputStream ois = new ObjectInputStream(bis);\r\n             return ois.readObject();\r\n         }\r\n     \r\n         public String getName() {\r\n             return name;\r\n         }\r\n         public void setName(String name) {\r\n             this.name = name;\r\n         }\r\n         public int getAge() {\r\n             return age;\r\n         }\r\n         public void setAge(int age) {\r\n             this.age = age;\r\n         }\r\n         public Address getAddress() {\r\n             return address;\r\n         }\r\n         public void setAddress(Address address) {\r\n             this.address = address;\r\n         }\r\n     }\r\n     ```\r\n\r\n     输出\r\n\r\n     ```\r\n     克隆前的地址：天津\r\n     克隆后的地址：北京\r\n     ```\r\n\r\n## 47. 常见的Object方法　＊＊＊\r\n\r\n> 这些方法都很重要，面试经常会问到，要结合其他知识将这些方法理解透彻\r\n\r\n- `Object clone()`：创建与该对象的类相同的新对象\r\n- `boolean equals(Object)`：比较两对象是否相等\r\n- `void finalize()`：当垃圾回收器确定不存在对该对象的更多引用时，对象垃圾回收器调用该方法\r\n- `Class getClass()`：返回一个对象运行时的实例类\r\n- `int hashCode()`：返回该对象的散列码值\r\n- `void notify()`：唤醒等待在该对象的监视器上的一个线程\r\n- `void notifyAll()`：唤醒等待在该对象的监视器上的全部线程\r\n- `String toString()`：返回该对象的字符串表示\r\n- `void wait()`：在其他线程调用此对象的 `notify()` 方法或 `notifyAll()`方法前，导致当前线程等待'}}]);