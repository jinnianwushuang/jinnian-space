(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[11],{"037e":function(n,e,t){"use strict";t.r(e),e["default"]='## Docker介绍\n\n### 什么是 Docker？\n\n说实话关于 Docker 是什么并不太好说，下面我通过四点向你说明 Docker 到底是个什么东西。\n\n- Docker 是世界领先的软件容器平台，基于 **Go 语言** 进行开发实现。\n- Docker 能够自动执行重复性任务，例如搭建和配置开发环境，从而解放开发人员。\n- 用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。\n- Docker 可以**对进程进行封装隔离，属于操作系统层面的虚拟化技术。** 由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。\n\n官网地址：https://www.docker.com/ 。\n\n \n\n### 为什么要用 Docker?\n\nDocker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。\n\n容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app），更重要的是容器性能开销极低。\n\n传统的开发流程中，我们的项目通常需要使用 MySQL、Redis、FastDFS 等等环境，这些环境都是需要我们手动去进行下载并配置的，安装配置流程极其复杂，而且不同系统下的操作也不一样。\n\nDocker 的出现完美地解决了这一问题，我们可以在容器中安装 MySQL、Redis 等软件环境，使得应用和环境架构分开，它的优势在于：\n\n1. 一致的运行环境，能够更轻松地迁移\n2. 对进程进行封装隔离，容器与容器之间互不影响，更高效地利用系统资源\n3. 可以通过镜像复制多个一致的容器\n\n另外，[《Docker 从入门到实践》](https://yeasy.gitbook.io/docker_practice/introduction/why) 这本开源书籍中也已经给出了使用 Docker 的原因。\n\n![](Docker从入门到实战.assets/20210412220015698.png)\n\n## Docker 的安装\n\n### Windows\n\n接下来对 Docker 进行安装，以 Windows 系统为例，访问 Docker 的官网：\n\n![](Docker从入门到实战.assets/up-4e3146984adaee0067bdc5e9b1d757bb479.png)\n\n然后点击`Get Started`：\n\n![](Docker从入门到实战.assets/up-96adfbfebe3e59097c8ba25e55f68ba7908.png)\n\n在此处点击`Download for Windows`即可进行下载。\n\n如果你的电脑是`Windows 10 64位专业版`的操作系统，则在安装 Docker 之前需要开启一下`Hyper-V`，开启方式如下。打开控制面板，选择程序：\n\n![](Docker从入门到实战.assets/up-73ce678240826de0f49225250a970b4d205.png)\n\n点击`启用或关闭Windows功能`：\n\n![](Docker从入门到实战.assets/up-9c7a96c332e56b9506325a1f1fdb608a659.png)\n\n勾选上`Hyper-V`，点击确定即可：\n\n![](Docker从入门到实战.assets/up-aad4a58c5e917f7185908d6320d7fb06861.png)\n\n完成更改后需要重启一下计算机。\n\n开启了`Hyper-V`后，我们就可以对 Docker 进行安装了，打开安装程序后，等待片刻点击`Ok`即可：\n\n![](Docker从入门到实战.assets/up-62ac3c9184bdc21387755294613ff5054c6.png)\n\n安装完成后，我们仍然需要重启计算机，重启后，若提示如下内容：\n\n![](Docker从入门到实战.assets/up-3585c7d6a4632134ed925493a7d43e14a43.png)\n\n它的意思是询问我们是否使用 WSL2，这是基于 Windows 的一个 Linux 子系统，这里我们取消即可，它就会使用我们之前勾选的`Hyper-V`虚拟机。\n\n因为是图形界面的操作，这里就不介绍 Docker Desktop 的具体用法了。\n\n### Mac\n\n直接使用 Homebrew 安装即可\n\n```shell\nbrew install --cask docker\n```\n\n### Linux\n\n下面来看看 Linux 中如何安装 Docker，这里以 CentOS7 为例。\n\n在测试或开发环境中，Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，执行这个脚本后就会自动地将一切准备工作做好，并且把 Docker 的稳定版本安装在系统中。\n\n```shell\ncurl -fsSL get.docker.com -o get-docker.sh\n```\n\n```shell\nsh get-docker.sh --mirror Aliyun\n```\n\n安装完成后直接启动服务：\n\n```shell\nsystemctl start docker\n```\n\n推荐设置开机自启，执行指令：\n\n```shell\nsystemctl enable docker\n```\n\n## Docker 中的几个概念\n\n在正式学习 Docker 之前，我们需要了解 Docker 中的几个核心概念：\n\n### 镜像\n\n镜像就是一个只读的模板，镜像可以用来创建 Docker 容器，一个镜像可以创建多个容器\n\n### 容器\n\n容器是用镜像创建的运行实例，Docker 利用容器独立运行一个或一组应用。它可以被启动、开始、停止、删除，每个容器都是相互隔离的、保证安全的平台。 可以把容器看作是一个简易的 Linux 环境和运行在其中的应用程序。容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的\n\n### 仓库\n\n仓库是集中存放镜像文件的场所。仓库和仓库注册服务器是有区别的，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签。 仓库分为公开仓库和私有仓库两种形式，最大的公开仓库是 DockerHub，存放了数量庞大的镜像供用户下载，国内的公开仓库有阿里云、网易云等\n\n### 总结\n\n通俗点说，一个镜像就代表一个软件；而基于某个镜像运行就是生成一个程序实例，这个程序实例就是容器；而仓库是用来存储 Docker 中所有镜像的。\n\n其中仓库又分为远程仓库和本地仓库，和 Maven 类似，倘若每次都从远程下载依赖，则会大大降低效率，为此，Maven 的策略是第一次访问依赖时，将其下载到本地仓库，第二次、第三次使用时直接用本地仓库的依赖即可，Docker 的远程仓库和本地仓库的作用也是类似的。\n\n## Docker 初体验\n\n下面我们来对 Docker 进行一个初步的使用，这里以下载一个 MySQL 的镜像为例`(在CentOS7下进行)`。\n\n和 GitHub 一样，Docker 也提供了一个 DockerHub 用于查询各种镜像的地址和安装教程，为此，我们先访问 DockerHub：[https://hub.docker.com/](https://hub.docker.com/)\n\n![](Docker从入门到实战.assets/up-37d083cc92fe36aad829e975646b9d27fa0.png)\n\n在左上角的搜索框中输入`MySQL`并回车：\n\n![](Docker从入门到实战.assets/up-ced37002391a059754def9b3a6c2aa4e342.png)\n\n可以看到相关 MySQL 的镜像非常多，若右上角有`OFFICIAL IMAGE`标识，则说明是官方镜像，所以我们点击第一个 MySQL 镜像：\n\n![](Docker从入门到实战.assets/up-48ba3fdc99c93a96e18b929195ca8e93c6c.png)\n\n右边提供了下载 MySQL 镜像的指令为`docker pull MySQL`，但该指令始终会下载 MySQL 镜像的最新版本。\n\n若是想下载指定版本的镜像，则点击下面的`View Available Tags`：\n\n![](Docker从入门到实战.assets/up-ed601649275c6cfe65bbe422b463c263a64.png)\n\n这里就可以看到各种版本的镜像，右边有下载的指令，所以若是想下载 5.7.32 版本的 MySQL 镜像，则执行：\n\n```shell\ndocker pull MySQL:5.7.32\n```\n\n然而下载镜像的过程是非常慢的，所以我们需要配置一下镜像源加速下载，访问`阿里云`官网：\n\n![](Docker从入门到实战.assets/up-0a46effd262d3db1b613a0db597efa31f34.png)\n\n点击控制台：\n\n![](Docker从入门到实战.assets/up-60f198e0106be6b43044969d2900272504f.png)\n\n然后点击左上角的菜单，在弹窗的窗口中，将鼠标悬停在产品与服务上，并在右侧搜索容器镜像服务，最后点击容器镜像服务：\n\n![](Docker从入门到实战.assets/up-2f6706a979b405dab01bc44a29bb6b26fc4.png)\n\n点击左侧的镜像加速器，并依次执行右侧的配置指令即可。\n\n```shell\nsudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json <<-\'EOF\'\n{\n  "registry-mirrors": ["https://679xpnpz.mirror.aliyuncs.com"]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n```\n\n## Docker 镜像指令\n\nDocker 需要频繁地操作相关的镜像，所以我们先来了解一下 Docker 中的镜像指令。\n\n若想查看 Docker 中当前拥有哪些镜像，则可以使用 `docker images` 命令。\n\n```shell\n[root@izrcf5u3j3q8xaz ~]# docker images\nREPOSITORY    TAG       IMAGE ID       CREATED         SIZE\nMySQL         5.7.32    f07dfa83b528   11 days ago     448MB\ntomcat        latest    feba8d001e3f   2 weeks ago     649MB\nnginx         latest    ae2feff98a0c   2 weeks ago     133MB\nhello-world   latest    bf756fb1ae65   12 months ago   13.3kB\n```\n\n其中`REPOSITORY`为镜像名，`TAG`为版本标志，`IMAGE ID`为镜像 id(唯一的)，`CREATED`为创建时间，注意这个时间并不是我们将镜像下载到 Docker 中的时间，而是镜像创建者创建的时间，`SIZE`为镜像大小。\n\n该指令能够查询指定镜像名：\n\n```shell\ndocker image MySQL\n```\n\n若如此做，则会查询出 Docker 中的所有 MySQL 镜像：\n\n```shell\n[root@izrcf5u3j3q8xaz ~]# docker images MySQL\nREPOSITORY   TAG       IMAGE ID       CREATED         SIZE\nMySQL        5.6       0ebb5600241d   11 days ago     302MB\nMySQL        5.7.32    f07dfa83b528   11 days ago     448MB\nMySQL        5.5       d404d78aa797   20 months ago   205MB\n```\n\n该指令还能够携带`-q`参数：`docker images -q` ， `-q`表示仅显示镜像的 id：\n\n```shell\n[root@izrcf5u3j3q8xaz ~]# docker images -q\n0ebb5600241d\nf07dfa83b528\nfeba8d001e3f\nd404d78aa797\n```\n\n若是要下载镜像，则使用：\n\n```shell\ndocker pull MySQL:5.7\n```\n\n`docker pull`是固定的，后面写上需要下载的镜像名及版本标志；若是不写版本标志，而是直接执行`docker pull MySQL`，则会下载镜像的最新版本。\n\n一般在下载镜像前我们需要搜索一下镜像有哪些版本才能对指定版本进行下载，使用指令：\n\n```shell\ndocker search MySQL\n```\n\n![](Docker从入门到实战.assets/up-559083ae80e7501e86e95fbbad25b6d571a.png)\n\n不过该指令只能查看 MySQL 相关的镜像信息，而不能知道有哪些版本，若想知道版本，则只能这样查询：\n\n```shell\ndocker search MySQL:5.5\n```\n\n![](Docker从入门到实战.assets/up-68394e25f652964bb042571151c5e0fd2e9.png)\n\n若是查询的版本不存在，则结果为空：\n\n![](Docker从入门到实战.assets/up-abfdd51b9ad2ced3711268369f52b077b12.png)\n\n删除镜像使用指令：\n\n```shell\ndocker image rm MySQL:5.5\n```\n\n若是不指定版本，则默认删除的也是最新版本。\n\n还可以通过指定镜像 id 进行删除：\n\n```shell\ndocker image rm bf756fb1ae65\n```\n\n然而此时报错了：\n\n```shell\n[root@izrcf5u3j3q8xaz ~]# docker image rm bf756fb1ae65\nError response from daemon: conflict: unable to delete bf756fb1ae65 (must be forced) - image is being used by stopped container d5b6c177c151\n```\n\n这是因为要删除的`hello-world`镜像正在运行中，所以无法删除镜像，此时需要强制执行删除：\n\n```shell\ndocker image rm -f bf756fb1ae65\n```\n\n该指令会将镜像和通过该镜像执行的容器全部删除，谨慎使用。\n\nDocker 还提供了删除镜像的简化版本：`docker rmi 镜像名:版本标志` 。\n\n此时我们即可借助`rmi`和`-q`进行一些联合操作，比如现在想删除所有的 MySQL 镜像，那么你需要查询出 MySQL 镜像的 id，并根据这些 id 一个一个地执行`docker rmi`进行删除，但是现在，我们可以这样：\n\n```shell\ndocker rmi -f $(docker images MySQL -q)\n```\n\n首先通过`docker images MySQL -q`查询出 MySQL 的所有镜像 id，`-q`表示仅查询 id，并将这些 id 作为参数传递给`docker rmi -f`指令，这样所有的 MySQL 镜像就都被删除了。\n\n## Docker 容器指令\n\n掌握了镜像的相关指令之后，我们需要了解一下容器的指令，容器是基于镜像的。\n\n若需要通过镜像运行一个容器，则使用：\n\n```shell\ndocker run tomcat:8.0-jre8\n```\n\n当然了，运行的前提是你拥有这个镜像，所以先下载镜像：\n\n```shell\ndocker pull tomcat:8.0-jre8\n```\n\n下载完成后就可以运行了，运行后查看一下当前运行的容器：`docker ps` 。\n\n![](Docker从入门到实战.assets/up-bd48e20ef07b7c91ad16f92821a3dbca5b5.png)\n\n其中`CONTAINER_ID`为容器的 id，`IMAGE`为镜像名，`COMMAND`为容器内执行的命令，`CREATED`为容器的创建时间，`STATUS`为容器的状态，`PORTS`为容器内服务监听的端口，`NAMES`为容器的名称。\n\n通过该方式运行的 tomcat 是不能直接被外部访问的，因为容器具有隔离性，若是想直接通过 8080 端口访问容器内部的 tomcat，则需要对宿主机端口与容器内的端口进行映射：\n\n```shell\ndocker run -p 8080:8080 tomcat:8.0-jre8\n```\n\n解释一下这两个端口的作用(`8080:8080`)，第一个 8080 为宿主机端口，第二个 8080 为容器内的端口，外部访问 8080 端口就会通过映射访问容器内的 8080 端口。\n\n此时外部就可以访问 Tomcat 了：\n\n![](Docker从入门到实战.assets/up-16d9ff4d29094681f51424ea8d0ee4fd73e.png)\n\n若是这样进行映射：\n\n```shell\ndocker run -p 8088:8080 tomcat:8.0-jre8\n```\n\n则外部需访问 8088 端口才能访问 tomcat，需要注意的是，每次运行的容器都是相互独立的，所以同时运行多个 tomcat 容器并不会产生端口的冲突。\n\n容器还能够以后台的方式运行，这样就不会占用终端：\n\n```shell\ndocker run -d -p 8080:8080 tomcat:8.0-jre8\n```\n\n启动容器时默认会给容器一个名称，但这个名称其实是可以设置的，使用指令：\n\n```shell\ndocker run -d -p 8080:8080 --name tomcat01 tomcat:8.0-jre8\n```\n\n此时的容器名称即为 tomcat01，容器名称必须是唯一的。\n\n再来引申一下`docker ps`中的几个指令参数，比如`-a`：\n\n```shell\ndocker ps -a\n```\n\n该参数会将运行和非运行的容器全部列举出来：\n\n![](Docker从入门到实战.assets/up-16d9ff4d29094681f51424ea8d0ee4fd73e.png)\n\n`-q`参数将只查询正在运行的容器 id：`docker ps -q` 。\n\n```shell\n[root@izrcf5u3j3q8xaz ~]# docker ps -q\nf3aac8ee94a3\n074bf575249b\n1d557472a708\n4421848ba294\n```\n\n若是组合使用，则查询运行和非运行的所有容器 id：`docker ps -qa` 。\n\n```shell\n[root@izrcf5u3j3q8xaz ~]# docker ps -aq\nf3aac8ee94a3\n7f7b0e80c841\n074bf575249b\na1e830bddc4c\n1d557472a708\n4421848ba294\nb0440c0a219a\nc2f5d78c5d1a\n5831d1bab2a6\nd5b6c177c151\n```\n\n接下来是容器的停止、重启指令，因为非常简单，就不过多介绍了。\n\n```shell\ndocker start c2f5d78c5d1a\n```\n\n通过该指令能够将已经停止运行的容器运行起来，可以通过容器的 id 启动，也可以通过容器的名称启动。\n\n```shell\ndocker restart c2f5d78c5d1a\n```\n\n该指令能够重启指定的容器。\n\n```shell\ndocker stop c2f5d78c5d1a\n```\n\n该指令能够停止指定的容器。\n\n```shell\ndocker kill c2f5d78c5d1a\n```\n\n该指令能够直接杀死指定的容器。\n\n以上指令都能够通过容器的 id 和容器名称两种方式配合使用。\n\n---\n\n当容器被停止之后，容器虽然不再运行了，但仍然是存在的，若是想删除它，则使用指令：\n\n```shell\ndocker rm d5b6c177c151\n```\n\n需要注意的是容器的 id 无需全部写出来，只需唯一标识即可。\n\n若是想删除正在运行的容器，则需要添加`-f`参数强制删除：\n\n```shell\ndocker rm -f d5b6c177c151\n```\n\n若是想删除所有容器，则可以使用组合指令：\n\n```shell\ndocker rm -f $(docker ps -qa)\n```\n\n先通过`docker ps -qa`查询出所有容器的 id，然后通过`docker rm -f`进行删除。\n\n---\n\n当容器以后台的方式运行时，我们无法知晓容器的运行状态，若此时需要查看容器的运行日志，则使用指令：\n\n```shell\ndocker logs 289cc00dc5ed\n```\n\n这样的方式显示的日志并不是实时的，若是想实时显示，需要使用`-f`参数：\n\n```shell\ndocker logs -f 289cc00dc5ed\n```\n\n通过`-t`参数还能够显示日志的时间戳，通常与`-f`参数联合使用：\n\n```shell\ndocker logs -ft 289cc00dc5ed\n```\n\n---\n\n查看容器内运行了哪些进程，可以使用指令：\n\n```shell\ndocker top 289cc00dc5ed\n```\n\n![](Docker从入门到实战.assets/up-7ec71a682712e56e90490f55c32cf660fd3.png)\n\n若是想与容器进行交互，则使用指令：\n\n```shell\ndocker exec -it 289cc00dc5ed bash\n```\n\n![](Docker从入门到实战.assets/up-fd17796322f833685ca8ead592d38581898.png)\n\n此时终端将会进入容器内部，执行的指令都将在容器中生效，在容器内只能执行一些比较简单的指令，如：ls、cd 等，若是想退出容器终端，重新回到 CentOS 中，则执行`exit`即可。\n\n现在我们已经能够进入容器终端执行相关操作了，那么该如何向 tomcat 容器中部署一个项目呢？\n\n```shell\ndocker cp ./test.html 289cc00dc5ed:/usr/local/tomcat/webapps\n```\n\n通过`docker cp`指令能够将文件从 CentOS 复制到容器中，`./test.html`为 CentOS 中的资源路径，`289cc00dc5ed`为容器 id，`/usr/local/tomcat/webapps`为容器的资源路径，此时`test.html`文件将会被复制到该路径下。\n\n```shell\n[root@izrcf5u3j3q8xaz ~]# docker exec -it 289cc00dc5ed bash\nroot@289cc00dc5ed:/usr/local/tomcat# cd webapps\nroot@289cc00dc5ed:/usr/local/tomcat/webapps# ls\ntest.html\nroot@289cc00dc5ed:/usr/local/tomcat/webapps#\n```\n\n若是想将容器内的文件复制到 CentOS 中，则反过来写即可：\n\n```shell\ndocker cp 289cc00dc5ed:/usr/local/tomcat/webapps/test.html ./\n```\n\n所以现在若是想要部署项目，则先将项目上传到 CentOS，然后将项目从 CentOS 复制到容器内，此时启动容器即可。\n\n---\n\n虽然使用 Docker 启动软件环境非常简单，但同时也面临着一个问题，我们无法知晓容器内部具体的细节，比如监听的端口、绑定的 ip 地址等等，好在这些 Docker 都帮我们想到了，只需使用指令：\n\n```shell\ndocker inspect 923c969b0d91\n```\n\n![](Docker从入门到实战.assets/up-fca74d4350cdfebfc2b06101e1cab411619.png)\n\n## Docker 数据卷\n\n学习了容器的相关指令之后，我们来了解一下 Docker 中的数据卷，它能够实现宿主机与容器之间的文件共享，它的好处在于我们对宿主机的文件进行修改将直接影响容器，而无需再将宿主机的文件再复制到容器中。\n\n现在若是想将宿主机中`/opt/apps`目录与容器中`webapps`目录做一个数据卷，则应该这样编写指令：\n\n```shell\ndocker run -d -p 8080:8080 --name tomcat01 -v /opt/apps:/usr/local/tomcat/webapps tomcat:8.0-jre8\n```\n\n然而此时访问 tomcat 会发现无法访问：\n\n![](Docker从入门到实战.assets/up-8fa1b23f6ea2567b5938370e7d7f636533f.png)\n\n这就说明我们的数据卷设置成功了，Docker 会将容器内的`webapps`目录与`/opt/apps`目录进行同步，而此时`/opt/apps`目录是空的，导致`webapps`目录也会变成空目录，所以就访问不到了。\n\n此时我们只需向`/opt/apps`目录下添加文件，就会使得`webapps`目录也会拥有相同的文件，达到文件共享，测试一下：\n\n```shell\n[root@centos-7 opt]# cd apps/\n[root@centos-7 apps]# vim test.html\n[root@centos-7 apps]# ls\ntest.html\n[root@centos-7 apps]# cat test.html\n<h1>This is a test html!</h1>\n```\n\n在`/opt/apps`目录下创建了一个 `test.html` 文件，那么容器内的`webapps`目录是否会有该文件呢？进入容器的终端：\n\n```shell\n[root@centos-7 apps]# docker exec -it tomcat01 bash\nroot@115155c08687:/usr/local/tomcat# cd webapps/\nroot@115155c08687:/usr/local/tomcat/webapps# ls\ntest.html\n```\n\n容器内确实已经有了该文件，那接下来我们编写一个简单的 Web 应用：\n\n```java\npublic class HelloServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        resp.getWriter().println("Hello World!");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n```\n\n这是一个非常简单的 Servlet，我们将其打包上传到`/opt/apps`中，那么容器内肯定就会同步到该文件，此时进行访问：\n\n![](Docker从入门到实战.assets/up-712716a8c8c444ba3a77ade8ff27e7c6cf5.png)\n\n这种方式设置的数据卷称为自定义数据卷，因为数据卷的目录是由我们自己设置的，Docker 还为我们提供了另外一种设置数据卷的方式：\n\n```shell\ndocker run -d -p 8080:8080 --name tomcat01 -v aa:/usr/local/tomcat/webapps tomcat:8.0-jre8\n```\n\n此时的`aa`并不是数据卷的目录，而是数据卷的别名，Docker 会为我们自动创建一个名为`aa`的数据卷，并且会将容器内`webapps`目录下的所有内容复制到数据卷中，该数据卷的位置在`/var/lib/docker/volumes`目录下：\n\n```shell\n[root@centos-7 volumes]# pwd\n/var/lib/docker/volumes\n[root@centos-7 volumes]# cd aa/\n[root@centos-7 aa]# ls\n_data\n[root@centos-7 aa]# cd _data/\n[root@centos-7 _data]# ls\ndocs  examples  host-manager  manager  ROOT\n```\n\n此时我们只需修改该目录的内容就能能够影响到容器。\n\n---\n\n最后再介绍几个容器和镜像相关的指令：\n\n```shell\ndocker commit -m "描述信息" -a "镜像作者" tomcat01 my_tomcat:1.0\n```\n\n该指令能够将容器打包成一个镜像，此时查询镜像：\n\n```shell\n[root@centos-7 _data]# docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nmy_tomcat           1.0                 79ab047fade5        2 seconds ago       463MB\ntomcat              8                   a041be4a5ba5        2 weeks ago         533MB\nMySQL               latest              db2b37ec6181        2 months ago        545MB\n```\n\n若是想将镜像备份出来，则可以使用指令：\n\n```shell\ndocker save my_tomcat:1.0 -o my-tomcat-1.0.tar\n```\n\n```shell\n[root@centos-7 ~]# docker save my_tomcat:1.0 -o my-tomcat-1.0.tar\n[root@centos-7 ~]# ls\nanaconda-ks.cfg  initial-setup-ks.cfg  公共  视频  文档  音乐\nget-docker.sh    my-tomcat-1.0.tar     模板  图片  下载  桌面\n```\n\n若是拥有`.tar`格式的镜像，该如何将其加载到 Docker 中呢？执行指令：\n\n```shell\ndocker load -i my-tomcat-1.0.tar\n```\n\n```shell\nroot@centos-7 ~]# docker load -i my-tomcat-1.0.tar\nb28ef0b6fef8: Loading layer [==================================================>]  105.5MB/105.5MB\n0b703c74a09c: Loading layer [==================================================>]  23.99MB/23.99MB\n......\nLoaded image: my_tomcat:1.0\n[root@centos-7 ~]# docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nmy_tomcat           1.0                 79ab047fade5        7 minutes ago       463MB\n```\n'},"1b62":function(n,e,t){"use strict";t.d(e,"d",(function(){return r})),t.d(e,"c",(function(){return u})),t.d(e,"a",(function(){return _})),t.d(e,"b",(function(){return D}));t("4de4"),t("c975");var o=t("448a"),i=t.n(o),s=["/第1阶段-运维基本功（升级7.6版本）/01运维概述与Linux系统安装.pdf","/第1阶段-运维基本功（升级7.6版本）/02Linux基础命令.pdf"],c="linux/heima-Linux云计算",r={name:"Container",data:function(){return{prefix:c,book_options:s,book_options_all:[],show:!0,book:s[0],src:""}},created:function(){this.book_options_all=i()(this.book_options),this.src=this.$utils.compute_book_src(this.prefix+this.book)},watch:{book:function(n,e){n&&this.change_book()}},methods:{change_book:function(){console.log("this.book",this.book),this.src=this.$utils.compute_book_src(this.prefix+this.book)},filterFn:function(n,e){var t=this;e(""!==n?function(){var e=n.toLowerCase();t.book_options=t.book_options_all.filter((function(n){return n.toLowerCase().indexOf(e)>-1}))}:function(){t.book_options=t.book_options_all})}}},a=t("ded3"),l=t.n(a),d=t("2f62"),u={data:function(){return{tab:"",tab_level:1,is_active:!1}},computed:l()({},Object(d["c"])(["get_current_selected_right_menu"])),created:function(){this.is_active=!0,this.fix_right_menu_config()},watch:{tab:function(){this.tab||this.fix_right_menu_config()},get_current_selected_right_menu:function(n,e){this.tab=this.get_current_selected_right_menu["t"+this.tab_level]}},methods:l()(l()({},Object(d["b"])(["set_right_menu_fix_config"])),{},{fix_right_menu_config:function(){this.set_right_menu_fix_config({tl:this.tab_level,tabs:this.tabs||[],tv:this.tab||this.tabs[0]["value"]})}}),beforeDestroy:function(){this.is_active=!1}},p=(t("99af"),t("d81d"),t("fb6a"),t("a434"),t("07ac"),function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"q-my-md q-mx-sm"},[t("div",{staticClass:"q-mb-md row q-gutter-x-md q-gutter-y-sm"},[t("q-select",{staticStyle:{width:"300px"},attrs:{dense:"",filled:"","use-input":"","hide-selected":"","fill-input":"","input-debounce":"0",options:n.topic_options_filtered},on:{filter:n.filterFn,"filter-abort":n.abortFilterFn,input:n.handle_topic_change},scopedSlots:n._u([{key:"before",fn:function(){return[n._v("\n        主题\n      ")]},proxy:!0}]),model:{value:n.topic,callback:function(e){n.topic=e},expression:"topic"}}),t("q-select",{staticStyle:{width:"300px"},attrs:{dense:"",filled:"",options:n.column_options},on:{input:n.handle_column_change},scopedSlots:n._u([{key:"before",fn:function(){return[n._v("\n        列数\n      ")]},proxy:!0}]),model:{value:n.column,callback:function(e){n.column=e},expression:"column"}})],1),t("q-markup-table",{attrs:{dense:""}},[t("thead",[t("tr",[t("th",{staticClass:"text-left text-weight-bolder  ",attrs:{colspan:n.column}},[n._v("\n          "+n._s(n.table_title?n.table_title+"------":"")+"当前词条数量："+n._s(n.word_total)+"\n        ")])])]),t("tbody",[n._l(n.table_data,(function(e,o){return[n.compute_if_show(e)?t("tr",{key:o,class:n.compute_topic_options_style(e)},n._l(n.column,(function(o){return t("td",{key:o,staticClass:"text-left"},[n._v("\n            "+n._s(e[o-1])+"\n          ")])})),0):n._e()]}))],2)])],1)}),h=[],m=(t("caad"),t("a9e3"),t("2532"),{data:function(){return{topic:"全部",column:2,topic_options_filtered:[],topic_options_all:[]}},props:{table_title:{type:String,default:""},word_total:{type:Number,default:0},topic_options:{type:Array,default:function(){return[]}},column_options:{type:Array,default:function(){return[]}},table_data:{type:Array,default:function(){return[]}},show_empty_line:!1},watch:{topic_options:function(n,e){this.init_topic_options_related()},column_options:function(n,e){this.init_column()}},created:function(){this.init_topic_options_related(),this.init_column(),this.handle_column_change(),this.handle_topic_change()},methods:{init_topic_options_related:function(){this.topic_options_all=i()(this.topic_options),this.topic_options_filtered=i()(this.topic_options)},filterFn:function(n,e,t){var o=this;console.log("this.topic_options_all",this.topic_options_all),setTimeout((function(){e((function(){if(""===n)o.topic_options_filtered=i()(o.topic_options_all);else{var e=n.toLowerCase();o.topic_options_filtered=o.topic_options_all.filter((function(n){return n.toLowerCase().indexOf(e)>-1}))}o.$forceUpdate()}),(function(e){""!==n&&e.options.length>0&&(e.setOptionIndex(-1),e.moveOptionSelection(1,!0))}))}),300)},abortFilterFn:function(){},handle_column_change:function(){this.$emit("handle_column_change",this.column)},handle_topic_change:function(){this.$emit("handle_topic_change",this.topic)},init_column:function(){var n=this.$q.platform.is.desktop,e=window.innerWidth;e=n?e-200:e-100,e=e<370?370:e,console.log("ww",e);var t=Math.ceil(e/350);t=t<1?1:t,e<400&&(t=1),t=t>8?8:t,this.column=t},compute_topic_options_style:function(n){var e="",t=1==n.length&&this.topic_options.includes(n[0]);return e=t?"bg-teal-4":"",e},compute_if_show:function(n){if(this.show_empty_line)return!0;var e=n.filter((function(n){return n}));return e.length>0}}}),k=m,b=t("2877"),g=Object(b["a"])(k,p,h,!1,null,"4e74a874",null),f=g.exports,_={components:{excelTable:f},data:function(){return{workSheetsFromFile:[[{data:[]}]],table_title:"",column:8,word_total:0,table_data:[],table_data_all:[],column_options:[1,2,3,4,5,6,7,8],exclude_topic_options:!0,show_empty_line:!1,topic:"",topic_options:[]}},created:function(){this.init_workSheetsFromFile()},methods:{init_workSheetsFromFile:function(){},handle_column_change:function(n){this.column=n,this.init_data()},handle_topic_change:function(n){this.topic=n,console.log("this.topic----",this.topic),this.compute_table_data_show_and_word_total()},rebuild_arr_reduce_empty_line:function(n){var e=[[""]];return n.map((function(n){var t=n.filter((function(n){return n})),o=t.length;if(o)e.push(n);else{var i=e[e.length-1].filter((function(n){return n})).length,s=e[e.length-1].length;s>0&&i>0&&e.push([""])}})),e},init_data:function(){var n=this;console.log("workSheetsFromFile --------",this.workSheetsFromFile);var e=[],t={},o=[];this.workSheetsFromFile.map((function(n){e=e.concat(n["data"])}));var s=this.$lodash.cloneDeep(e[0].filter((function(n){return n})));s.map((function(n,e){t["key_"+e]={title:n,words_raw:[]}})),this.exclude_topic_options&&e.splice(0,1),e.map((function(n,e){n.map((function(n,e){t["key_"+e]["words_raw"].push(n)}))})),console.log("final_obj------------",t);var c=Object.values(t);c.map((function(e,t){o.push([e["title"]]),o=o.concat(n.$lodash.chunk(e["words_raw"],n.column)),o=o.concat([[""]])})),this.topic_options=["全部"].concat(i()(s)),this.table_data_all=this.rebuild_arr_reduce_empty_line(o),this.compute_table_data_show_and_word_total(),console.log("  this.table_data_all   ",this.table_data_all)},compute_table_data_show_and_word_total:function(){var n=[],e=[],t=0;if(e=this.$lodash.cloneDeep(this.table_data_all),console.log(" table_data--------",e),"全部"==this.topic)n=e;else{var o=this.topic_options.indexOf(this.topic),i=o==this.topic_options.length-1,s=i?"":this.topic_options[o+1],c=this.find_topic_index(this.topic),r=s?this.find_topic_index(s):e.length;n=e.slice(c,r)}n.map((function(n){var e=n.filter((function(n){return n})).length;t+=e})),this.word_total=t,this.table_data=n},find_topic_index:function(n){for(var e=0,t=0;t<this.table_data_all.length;t++){var o=this.table_data_all[t];if(1==o.length&&o[0]&&o[0]==n){e=t;break}}return e}}},D=(t("7db0"),t("ac1f"),t("1276"),{data:function(){return{relative_path:"",tab:"",tabs:[],MainComponent:"",img_prefix:"./img/linux/heima-Linux云计算/讲义/"}},methods:{extendMarkdown:function(n){var e=this;console.log(n.renderer.rules);var t=n.renderer.rules.html_block;n.renderer.rules.html_block=function(n,o,i,s,c){var r=n[o];if(console.log("1"),r.content.includes("<img")){console.log("token-- ",r);var a="";a=r.content;var l=a.split('src="'),d="",u=l[1];l[0],e.img_prefix,l[1],d=u.includes("http")?l[0]+' src="'+u:l[0]+' src="'+e.img_prefix+u,r.content=d}return r.attrSet("class","q-markdown--token  "),t(n,o,i,s,c)},n.renderer.rules.image=function(n,t,o,i,s){var c=n[t];console.log("3"),c.attrSet("class","q-markdown--image"),console.log("token--- "+t+"-----",c);var r=c.attrGet("src");return console.log(r),r.includes("http")?c.attrSet("src",r):c.attrSet("src",e.img_prefix+r),s.renderToken(n,t,o)}},compute_img_prefix:function(){var n=this;if(this.MainComponent){var e=this.tabs.find((function(e){return e["value"]==n.tab}));if(e&&e["modules_obj"]){var t=this.relative_path;this.img_prefix="."+t+(e["modules_obj"]["relative_folder"]||"")}else this.img_prefix="."+relative_path}}}})},"2fd5":function(n,e,t){var o={"./Docker.md":"97a0","./Docker从入门到实战.md":"037e","./Git.md":"a212","./Github技巧.md":"4b2e"};function i(n){var e=s(n);return t(e)}function s(n){if(!t.o(o,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return o[n]}i.keys=function(){return Object.keys(o)},i.resolve=s,n.exports=i,i.id="2fd5"},3686:function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t("e260"),t("a15b"),t("d81d"),t("fb6a"),t("4e82"),t("d3b7"),t("ac1f"),t("1276"),t("ddb0");var o=t("ded3"),i=t.n(o),s=t("6821"),c=(t("d958"),function(n){if(!n)return"";var e="",t=n.split("/");return t.shift(),t.pop(),e=t.join("/"),e?"/"+e+"/":""}),r=function(n){n=n||"";var e=n.split("/"),t=e.length;return e[t-1]},a=function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"md",t=arguments.length>3&&void 0!==arguments[3]&&arguments[3],o=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];console.log("当前 require.context---",n),console.log("当前 field_components.keys()---",n.keys());var a=n.keys(),l={},d=[],u={},p=[];return a.map((function(o){var i=o.slice(2,o.length-e.length-1),r="module_"+s(o);p.push(i),u[i]={value:r,relative_path:o,relative_folder:c(o)},console.log("x---",o),l[r]=t?"\n            <div>\n            <code>\n              ".concat(n(o).default,"\n            </code>\n            </div>\n            "):n(o).default})),p.sort((function(n,e){return parseFloat(n)-parseFloat(e)})),p.map((function(n){d.push({label:o?r(n):n,value:u[n]["value"],modules_obj:i()({},u[n])})})),console.log("all_components------------",l),console.log("all_modules---------------",d),{all_components:l,all_modules:d}}},"4b2e":function(n,e,t){"use strict";t.r(e),e["default"]="我使用 Github 已经有 5 年多了，今天毫无保留地把自己觉得比较有用的 Github 小技巧送给关注 JavaGuide 的各位小伙伴。\n\n这篇文章肝了很久，就挺用心的，大家看内容就知道了。\n\n如果觉得有收获的话，不要白嫖！点个赞/在看就是对我最大的鼓励。你要是可以三连（点赞+在看+转发）的话，我就更爽了（_我在想屁吃？_）。\n\n## 1. 一键生成 Github 简历\n\n通过 [https://resume.github.io/](https://resume.github.io/) 这个网站你可以一键生成一个在线的 Github 简历。\n\n当时我参加的校招的时候，个人信息那里就放了一个在线的 Github 简历。我觉得这样会让面试官感觉你是一个内行，会提高一些印象分。\n\n但是，如果你的 Github 没有什么项目的话还是不要放在简历里面了。生成后的效果如下图所示。\n\n![Github简历](Github技巧.assets/image-20201108192205620.png)\n\n## 2. 个性化 Github 首页\n\nGithub 目前支持在个人主页自定义展示一些内容。展示效果如下图所示。\n\n![个性化首页展示效果](Github技巧.assets/image-20210616221212259.png)\n\n想要做到这样非常简单，你只需要创建一个和你的 Github 账户同名的仓库，然后自定义`README.md`的内容即可。\n\n展示在你主页的自定义内容就是`README.md`的内容（_不会 Markdown 语法的小伙伴自行面壁 5 分钟_）。\n\n![创建一个和你的Github账户同名的仓库](Github技巧.assets/image-20201107110309341.png)\n\n这个也是可以玩出花来的！比如说：通过 [github-readme-stats](https://hellogithub.com/periodical/statistics/click/?target=https://github.com/anuraghazra/github-readme-stats) 这个开源项目，你可以 README 中展示动态生成的 GitHub 统计信息。展示效果如下图所示。\n\n![通过github-readme-stats动态生成GitHub统计信息 ](Github技巧.assets/image-20210616221312426.png)\n\n关于个性化首页这个就不多提了，感兴趣的小伙伴自行研究一下。\n\n## 3. 自定义项目徽章\n\n你在 Github 上看到的项目徽章都是通过 [https://shields.io/](https://shields.io/) 这个网站生成的。我的 JavaGuide 这个项目的徽章如下图所示。\n\n![项目徽章](Github技巧.assets/image-20201107143136559.png)\n\n并且，你不光可以生成静态徽章，shield.io 还可以动态读取你项目的状态并生成对应的徽章。\n\n![自定义项目徽章](Github技巧.assets/image-20201107143502356.png)\n\n生成的描述项目状态的徽章效果如下图所示。\n\n![描述项目状态的徽章](Github技巧.assets/image-20201107143752642.png)\n\n## 4. Github 表情\n\n![Github表情](Github技巧.assets/image-20201107162254582.png)\n\n如果你想要在 Github 使用表情的话，可以在这里找找 ：[www.webfx.com/tools/emoji-cheat-sheet/ ](www.webfx.com/tools/emoji-cheat-sheet/)。\n\n![在线Github表情](Github技巧.assets/image-20201107162432941.png)\n\n## 5. 高效阅读 Github 项目的源代码\n\nGithub 前段时间推出的 Codespaces 可以提供类似 VS Code 的在线 IDE，不过目前还没有完全开发使用。\n\n简单介绍几种我最常用的阅读 Github 项目源代码的方式。\n\n### 5.1. Chrome 插件 Octotree\n\n这个已经老生常谈了，是我最喜欢的一种方式。使用了 Octotree 之后网页侧边栏会按照树形结构展示项目，为我们带来 IDE 般的阅读源代码的感受。\n\n![Chrome插件Octotree](Github技巧.assets/image-20201107144944798.png)\n\n### 5.2. Chrome 插件 SourceGraph\n\n我不想将项目 clone 到本地的时候一般就会使用这种方式来阅读项目源代码。SourceGraph 不仅可以让我们在 Github 优雅的查看代码，它还支持一些骚操作，比如：类之间的跳转、代码搜索等功能。\n\n当你下载了这个插件之后，你的项目主页会多出一个小图标如下图所示。点击这个小图标即可在线阅读项目源代码。\n\n![](Github技巧.assets/image-20201107145749659.png)\n\n使用 SourceGraph 阅读代码的就像下面这样，同样是树形结构展示代码，但是我个人感觉没有 Octotree 的手感舒服。不过，SourceGraph 内置了很多插件，而且还支持类之间的跳转！\n\n![](Github技巧.assets/image-20201107150307314.png)\n\n### 5.3. 克隆项目到本地\n\n先把项目克隆到本地，然后使用自己喜欢的 IDE 来阅读。可以说是最酸爽的方式了！\n\n如果你想要深入了解某个项目的话，首选这种方式。一个`git clone` 就完事了。\n\n### 5.4. 其他\n\n如果你要看的是前端项目的话，还可以考虑使用 [https://stackblitz.com/](https://stackblitz.com/) 这个网站。\n\n这个网站会提供一个类似 VS Code 的在线 IDE。\n\n## 6. 扩展 Github 的功能\n\n**Enhanced GitHub** 可以让你的 Github 更好用。这个 Chrome 插件可以可视化你的 Github 仓库大小，每个文件的大小并且可以让你快速下载单个文件。\n\n![](Github技巧.assets/image-20201107160817672.png)\n\n## 7. 自动为 Markdown 文件生成目录\n\n如果你想为 Github 上的 Markdown 文件生成目录的话，通过 VS Code 的 **Markdown Preview Enhanced** 这个插件就可以了。\n\n生成的目录效果如下图所示。你直接点击目录中的链接即可跳转到文章对应的位置，可以优化阅读体验。\n\n![](<Github技巧.assets/iShot2020-11-07 16.14.14 (1).png>)\n\n## 8. 后记\n\n这篇文章是我上周六的时候坐在窗台写的，花了一下午时间。\n\n![](Github技巧.assets/301604738120_.pic_hd.jpg)\n\n除了我提到的这些技巧之外，像 Github 搜索技巧、GitHub Actions 等内容的话，我这里没有提，感兴趣的小伙伴自行研究一下。\n\n这里多说一句心里话： **Github 搜索技巧不必要记网上那些文章说的各种命令啥的，真没啥卵用。你会发现你用的最多的还是关键字搜索以及 Github 自带的筛选功能。**\n"},"97a0":function(n,e,t){"use strict";t.r(e),e["default"]='**本文只是对 Docker 的概念做了较为详细的介绍，并不涉及一些像 Docker 环境的安装以及 Docker 的一些常见操作和命令。**\n\n## 一 认识容器\n\n**Docker 是世界领先的软件容器平台**，所以想要搞懂 Docker 的概念我们必须先从容器开始说起。\n\n### 1.1 什么是容器?\n\n#### 先来看看容器较为官方的解释\n\n**一句话概括容器：容器就是将软件打包成标准化单元，以用于开发、交付和部署。**\n\n- **容器镜像是轻量的、可执行的独立软件包** ，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。\n- **容器化软件适用于基于 Linux 和 Windows 的应用，在任何环境中都能够始终如一地运行。**\n- **容器赋予了软件独立性**，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。\n\n#### 再来看看容器较为通俗的解释\n\n**如果需要通俗地描述容器的话，我觉得容器就是一个存放东西的地方，就像书包可以装各种文具、衣柜可以放各种衣服、鞋架可以放各种鞋子一样。我们现在所说的容器存放的东西可能更偏向于应用比如网站、程序甚至是系统环境。**\n\n![认识容器](Docker.assets/container.png)\n\n\n\n### 1.2 图解物理机,虚拟机与容器\n\n关于虚拟机与容器的对比在后面会详细介绍到，这里只是通过网上的图片加深大家对于物理机、虚拟机与容器这三者的理解(下面的图片来源于网络)。\n\n**物理机：**\n\n![物理机](Docker.assets/物理机图解.png)\n\n**虚拟机：**\n\n![虚拟机](Docker.assets/虚拟机图解.png)\n\n**容器：**\n\n\n\n通过上面这三张抽象图，我们可以大概通过类比概括出： **容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的。虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。因此容器的隔离级别会稍低一些。**\n\n---\n\n**相信通过上面的解释大家对于容器这个既陌生又熟悉的概念有了一个初步的认识，下面我们就来谈谈 Docker 的一些概念。**\n\n## 二 再来谈谈 Docker 的一些概念\n\n\n\n### 2.1 什么是 Docker?\n\n说实话关于 Docker 是什么并太好说，下面我通过四点向你说明 Docker 到底是个什么东西。\n\n- **Docker 是世界领先的软件容器平台。**\n- **Docker** 使用 Google 公司推出的 **Go 语言** 进行开发实现，基于 **Linux 内核** 提供的 CGroup 功能和 namespace 来实现的，以及 AUFS 类的 **UnionFS** 等技术，**对进程进行封装隔离，属于操作系统层面的虚拟化技术。** 由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。\n- **Docker 能够自动执行重复性任务，例如搭建和配置开发环境，从而解放了开发人员以便他们专注在真正重要的事情上：构建杰出的软件。**\n- **用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。**\n\n\n\n### 2.2 Docker 思想\n\n- **集装箱**\n- **标准化：** ① 运输方式 ② 存储方式 ③ API 接口\n- **隔离**\n\n### 2.3 Docker 容器的特点\n\n- **轻量** :  在一台机器上运行的多个 Docker 容器可以共享这台机器的操作系统内核；它们能够迅速启动，只需占用很少的计算和内存资源。镜像是通过文件系统层进行构造的，并共享一些公共文件。这样就能尽量降低磁盘用量，并能更快地下载镜像。\n- **标准** : Docker 容器基于开放式标准，能够在所有主流 Linux 版本、Microsoft Windows 以及包括 VM、裸机服务器和云在内的任何基础设施上运行。\n- **安全** : Docker 赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker 默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。\n\n### 2.4 为什么要用 Docker ?\n\n- **Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊” 这类问题；——一致的运行环境**\n- **可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。——更快速的启动时间**\n- **避免公用的服务器，资源会容易受到其他用户的影响。——隔离性**\n- **善于处理集中爆发的服务器使用压力；——弹性伸缩，快速扩展**\n- **可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。——迁移方便**\n- **使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。——持续交付和部署**\n\n---\n\n## 三 容器 VS 虚拟机\n\n**每当说起容器，我们不得不将其与虚拟机做一个比较。就我而言，对于两者无所谓谁会取代谁，而是两者可以和谐共存。**\n\n简单来说： **容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。**\n\n### 3.1 两者对比图\n\n传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。\n\n\n\n### 3.2 容器与虚拟机总结\n\n\n\n- **容器是一个应用层抽象，用于将代码和依赖资源打包在一起。** **多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行** 。与虚拟机相比， **容器占用的空间较少**（容器镜像大小通常只有几十兆），**瞬间就能完成启动** 。\n\n- **虚拟机 (VM) 是一个物理硬件层抽象，用于将一台服务器变成多台服务器。** 管理程序允许多个 VM 在一台机器上运行。每个 VM 都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此 **占用大量空间** 。而且 VM **启动也十分缓慢** 。\n\n通过 Docker 官网，我们知道了这么多 Docker 的优势，但是大家也没有必要完全否定虚拟机技术，因为两者有不同的使用场景。**虚拟机更擅长于彻底隔离整个运行环境**。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而 **Docker 通常用于隔离不同的应用** ，例如前端，后端以及数据库。\n\n### 3.3 容器与虚拟机两者是可以共存的\n\n就我而言，对于两者无所谓谁会取代谁，而是两者可以和谐共存。\n\n\n\n---\n\n## 四 Docker 基本概念\n\n**Docker 中有非常重要的三个基本概念，理解了这三个概念，就理解了 Docker 的整个生命周期。**\n\n- **镜像（Image）**\n- **容器（Container）**\n- **仓库（Repository）**\n\n理解了这三个概念，就理解了 Docker 的整个生命周期\n\n![docker基本概念](Docker.assets/docker基本概念.png)\n\n### 4.1 镜像(Image):一个特殊的文件系统\n\n**操作系统分为内核和用户空间**。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。\n\n**Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。** 镜像不包含任何动态数据，其内容在构建之后也不会被改变。\n\nDocker 设计时，就充分利用 **Union FS** 的技术，将其设计为**分层存储的架构** 。镜像实际是由多层文件系统联合组成。\n\n**镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。** 比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。\n\n分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。\n\n### 4.2 容器(Container):镜像运行时的实体\n\n镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，**容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等** 。\n\n**容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。前面讲过镜像使用的是分层存储，容器也是如此。**\n\n**容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。**\n\n按照 Docker 最佳实践的要求，**容器不应该向其存储层内写入任何数据** ，容器存储层要保持无状态化。**所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录**，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此， **使用数据卷后，容器可以随意删除、重新 run ，数据却不会丢失。**\n\n### 4.3 仓库(Repository):集中存放镜像文件的地方\n\n镜像构建完成后，可以很容易的在当前宿主上运行，但是， **如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。**\n\n一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。所以说：**镜像仓库是 Docker 用来集中存放镜像文件的地方类似于我们之前常用的代码仓库。**\n\n通常，**一个仓库会包含同一个软件不同版本的镜像**，而**标签就常用于对应该软件的各个版本** 。我们可以通过`<仓库名>:<标签>`的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签.。\n\n**这里补充一下 Docker Registry 公开服务和私有 Docker Registry 的概念：**\n\n**Docker Registry 公开服务** 是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。\n\n最常使用的 Registry 公开服务是官方的 **Docker Hub** ，这也是默认的 Registry，并拥有大量的高质量的官方镜像，网址为：[https://hub.docker.com/](https://hub.docker.com/ "https://hub.docker.com/") 。官方是这样介绍 Docker Hub 的：\n\n> Docker Hub 是 Docker 官方提供的一项服务，用于与您的团队查找和共享容器镜像。\n\n比如我们想要搜索自己想要的镜像：\n\n![利用Docker Hub 搜索镜像](Docker.assets/Screen Shot 2019-11-04 at 8.21.39 PM-1635561617122.png)\n\n在 Docker Hub 的搜索结果中，有几项关键的信息有助于我们选择合适的镜像：\n\n- **OFFICIAL Image** ：代表镜像为 Docker 官方提供和维护，相对来说稳定性和安全性较高。\n- **Stars** ：和点赞差不多的意思，类似 GitHub 的 Star。\n- **Dowloads** ：代表镜像被拉取的次数，基本上能够表示镜像被使用的频度。\n\n当然，除了直接通过 Docker Hub 网站搜索镜像这种方式外，我们还可以通过 `docker search` 这个命令搜索 Docker Hub 中的镜像，搜索的结果是一致的。\n\n```bash\n➜  ~ docker search mysql\nNAME                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED\nmysql                             MySQL is a widely used, open-source relation…   8763                [OK]\nmariadb                           MariaDB is a community-developed fork of MyS…   3073                [OK]\nmysql/mysql-server                Optimized MySQL Server Docker images. Create…   650                                     [OK]\n```\n\n在国内访问**Docker Hub** 可能会比较慢国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 [时速云镜像库](https://www.tenxcloud.com/ "时速云镜像库")、[网易云镜像服务](https://www.163yun.com/product/repo "网易云镜像服务")、[DaoCloud 镜像市场](https://www.daocloud.io/ "DaoCloud 镜像市场")、[阿里云镜像库](https://www.aliyun.com/product/containerservice?utm_content=se_1292836 "阿里云镜像库")等。\n\n除了使用公开服务外，用户还可以在 **本地搭建私有 Docker Registry** 。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。\n\n---\n\n## 五 常见命令\n\n### 5.1 基本命令\n\n```bash\ndocker version # 查看docker版本\ndocker images # 查看所有已下载镜像，等价于：docker image ls 命令\ndocker container ls #\t查看所有容器\ndocker ps #查看正在运行的容器\ndocker image prune # 清理临时的、没有被使用的镜像文件。-a, --all: 删除所有没有用的镜像，而不仅仅是临时文件；\n```\n\n### 5.2 拉取镜像\n\n```bash\ndocker search mysql # 查看mysql相关镜像\ndocker pull mysql:5.7 # 拉取mysql镜像\ndocker image ls # 查看所有已下载镜像\n```\n\n### 5.3 删除镜像\n\n比如我们要删除我们下载的 mysql 镜像。\n\n通过 `docker rmi [image]` （等价于`docker image rm [image]`）删除镜像之前首先要确保这个镜像没有被容器引用（可以通过标签名称或者镜像 ID删除）。通过我们前面讲的` docker ps`命令即可查看。\n\n```shell\n➜  ~ docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES\nc4cd691d9f80        mysql:5.7           "docker-entrypoint.s…"   7 weeks ago         Up 12 days          0.0.0.0:3306->3306/tcp, 33060/tcp   mysql\n```\n\n可以看到 mysql 正在被 id 为 c4cd691d9f80 的容器引用，我们需要首先通过 `docker stop c4cd691d9f80` 或者 `docker stop mysql`暂停这个容器。\n\n然后查看 mysql 镜像的 id\n\n```shell\n➜  ~ docker images\nREPOSITORY              TAG                 IMAGE ID            CREATED             SIZE\nmysql                   5.7                 f6509bac4980        3 months ago        373MB\n```\n\n通过 IMAGE ID  或者 REPOSITORY 名字即可删除\n\n```shell\ndocker rmi f6509bac4980 #  或者 docker rmi mysql \n```\n\n## 六 Build Ship and Run\n\n**Docker 的概念以及常见命令基本上已经讲完，我们再来谈谈：Build, Ship, and Run。**\n\n如果你搜索 Docker 官网，会发现如下的字样：**“Docker - Build, Ship, and Run Any App, Anywhere”**。那么 Build, Ship, and Run 到底是在干什么呢？\n\n\n\n- **Build（构建镜像）** ： 镜像就像是集装箱包括文件以及运行环境等等资源。\n- **Ship（运输镜像）** ：主机和仓库间运输，这里的仓库就像是超级码头一样。\n- **Run （运行镜像）** ：运行的镜像就是一个容器，容器就是运行程序的地方。\n\n**Docker 运行过程也就是去仓库把镜像拉到本地，然后用一条命令把镜像运行起来变成容器。所以，我们也常常将 Docker 称为码头工人或码头装卸工，这和 Docker 的中文翻译搬运工人如出一辙。**\n\n## 七 简单了解一下 Docker 底层原理\n\n### 7.1 虚拟化技术\n\n首先，Docker **容器虚拟化**技术为基础的软件，那么什么是虚拟化技术呢？\n\n简单点来说，虚拟化技术可以这样定义：\n\n> 虚拟化技术是一种资源管理技术，是将计算机的各种[实体资源](https://zh.wikipedia.org/wiki/資源_(計算機科學 "实体资源"))（[CPU](https://zh.wikipedia.org/wiki/CPU "CPU")、[内存](https://zh.wikipedia.org/wiki/内存 "内存")、[磁盘空间](https://zh.wikipedia.org/wiki/磁盘空间 "磁盘空间")、[网络适配器](https://zh.wikipedia.org/wiki/網路適配器 "网络适配器")等），予以抽象、转换后呈现出来并可供分割、组合为一个或多个电脑配置环境。由此，打破实体结构间的不可切割的障碍，使用户可以比原本的配置更好的方式来应用这些电脑硬件资源。这些资源的新虚拟部分是不受现有资源的架设方式，地域或物理配置所限制。一般所指的虚拟化资源包括计算能力和数据存储。\n\n### 7.2 Docker 基于 LXC 虚拟容器技术\n\nDocker 技术是基于 LXC（Linux container- Linux 容器）虚拟容器技术的。\n\n> LXC，其名称来自 Linux 软件容器（Linux Containers）的缩写，一种操作系统层虚拟化（Operating system–level virtualization）技术，为 Linux 内核容器功能的一个用户空间接口。它将应用软件系统打包成一个软件容器（Container），内含应用软件本身的代码，以及所需要的操作系统核心和库。通过统一的名字空间和共用 API 来分配不同软件容器的可用硬件资源，创造出应用程序的独立沙箱运行环境，使得 Linux 用户可以容易的创建和管理系统或应用容器。\n\nLXC 技术主要是借助 Linux 内核中提供的 CGroup 功能和 namespace 来实现的，通过 LXC 可以为软件提供一个独立的操作系统运行环境。\n\n**cgroup 和 namespace 介绍：**\n\n- **namespace 是 Linux 内核用来隔离内核资源的方式。** 通过 namespace 可以让一些进程只能看到与自己相关的一部分资源，而另外一些进程也只能看到与它们自己相关的资源，这两拨进程根本就感觉不到对方的存在。具体的实现方式是把一个或多个进程的相关资源指定在同一个 namespace 中。Linux namespaces 是对全局系统资源的一种封装隔离，使得处于不同 namespace 的进程拥有独立的全局系统资源，改变一个 namespace 中的系统资源只会影响当前 namespace 里的进程，对其他 namespace 中的进程没有影响。\n\n  （以上关于 namespace 介绍内容来自https://www.cnblogs.com/sparkdev/p/9365405.html ，更多关于 namespace 的呢内容可以查看这篇文章 ）。\n\n- **CGroup 是 Control Groups 的缩写，是 Linux 内核提供的一种可以限制、记录、隔离进程组 (process groups) 所使用的物力资源 (如 cpu memory i/o 等等) 的机制。**\n\n  （以上关于 CGroup 介绍内容来自 https://www.ibm.com/developerworks/cn/linux/1506_cgroup/index.html ，更多关于 CGroup 的内容可以查看这篇文章 ）。\n\n**cgroup 和 namespace 两者对比：**\n\n两者都是将进程进行分组，但是两者的作用还是有本质区别。namespace 是为了隔离进程组之间的资源，而 cgroup 是为了对一组进程进行统一的资源监控和限制。\n\n## 八 总结\n\n本文主要把 Docker 中的一些常见概念做了详细的阐述，但是并不涉及 Docker 的安装、镜像的使用、容器的操作等内容。这部分东西，希望读者自己可以通过阅读书籍与官方文档的形式掌握。如果觉得官方文档阅读起来很费力的话，这里推荐一本书籍《Docker 技术入门与实战第二版》。\n\n## 九 推荐阅读\n\n- [10 分钟看懂 Docker 和 K8S](https://zhuanlan.zhihu.com/p/53260098 "10分钟看懂Docker和K8S")\n- [从零开始入门 K8s：详解 K8s 容器基本概念](https://www.infoq.cn/article/te70FlSyxhltL1Cr7gzM "从零开始入门 K8s：详解 K8s 容器基本概念")\n\n## 十 参考\n\n- [Linux Namespace 和 Cgroup](https://segmentfault.com/a/1190000009732550 "Linux Namespace和Cgroup")\n- [LXC vs Docker: Why Docker is Better](https://www.upguard.com/articles/docker-vs-lxc "LXC vs Docker: Why Docker is Better")\n- [CGroup 介绍、应用实例及原理描述](https://www.ibm.com/developerworks/cn/linux/1506_cgroup/index.html "CGroup 介绍、应用实例及原理描述")\n'},a212:function(n,e,t){"use strict";t.r(e),e["default"]='\n\n\n\n\x3c!-- TOC --\x3e\n\n- [版本控制](#版本控制)\n    - [什么是版本控制](#什么是版本控制)\n    - [为什么要版本控制](#为什么要版本控制)\n    - [本地版本控制系统](#本地版本控制系统)\n    - [集中化的版本控制系统](#集中化的版本控制系统)\n    - [分布式版本控制系统](#分布式版本控制系统)\n- [认识 Git](#认识-git)\n    - [Git 简史](#git-简史)\n    - [Git 与其他版本管理系统的主要区别](#git-与其他版本管理系统的主要区别)\n    - [Git 的三种状态](#git-的三种状态)\n- [Git 使用快速入门](#git-使用快速入门)\n    - [获取 Git 仓库](#获取-git-仓库)\n    - [记录每次更新到仓库](#记录每次更新到仓库)\n    - [一个好的 Git 提交消息](#一个好的-Git-提交消息)\n    - [推送改动到远程仓库](#推送改动到远程仓库)\n    - [远程仓库的移除与重命名](#远程仓库的移除与重命名)\n    - [查看提交历史](#查看提交历史)\n    - [撤销操作](#撤销操作)\n    - [分支](#分支)\n- [推荐阅读](#推荐阅读)\n\n\x3c!-- /TOC --\x3e\n\n## 版本控制\n\n### 什么是版本控制\n\n版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 除了项目源代码，你可以对任何类型的文件进行版本控制。\n\n### 为什么要版本控制\n\n有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。\n\n### 本地版本控制系统\n\n许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。\n\n为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。\n\n![本地版本控制系统](Git.assets/本地版本控制系统.png)\n\n### 集中化的版本控制系统\n\n接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？ 于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。 \n\n集中化的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。\n\n![集中化的版本控制系统](Git.assets/集中化的版本控制系统.png)\n\n这么做虽然解决了本地版本控制系统无法让在不同系统上的开发者协同工作的诟病，但也还是存在下面的问题：\n\n- **单点故障：** 中央服务器宕机，则其他人无法使用；如果中心数据库磁盘损坏又没有进行备份，你将丢失所有数据。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。\n- **必须联网才能工作：** 受网络状况、带宽影响。\n\n### 分布式版本控制系统\n\n于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 Git 就是一个典型的分布式版本控制系统。\n\n这类系统，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。\n\n![分布式版本控制系统](Git.assets/分布式版本控制系统.png)\n\n分布式版本控制系统可以不用联网就可以工作，因为每个人的电脑上都是完整的版本库，当你修改了某个文件后，你只需要将自己的修改推送给别人就可以了。但是，在实际使用分布式版本控制系统的时候，很少会直接进行推送修改，而是使用一台充当“中央服务器”的东西。这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。\n\n分布式版本控制系统的优势不单是不必联网这么简单，后面我们还会看到 Git 极其强大的分支管理等功能。\n\n## 认识 Git\n\n### Git 简史\n\nLinux 内核项目组当时使用分布式版本控制系统 BitKeeper 来管理和维护代码。但是，后来开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统，而且对新的版本控制系统做了很多改进。 \n\n### Git 与其他版本管理系统的主要区别\n\n Git 在保存和对待各种信息的时候与其它版本控制系统有很大差异，尽管操作起来的命令形式非常相近，理解这些差异将有助于防止你使用中的困惑。\n\n下面我们主要说一个关于 Git 与其他版本管理系统的主要差别：**对待数据的方式**。\n\n**Git采用的是直接记录快照的方式，而非差异比较。我后面会详细介绍这两种方式的差别。**\n\n大部分版本控制系统（CVS、Subversion、Perforce、Bazaar 等等）都是以文件变更列表的方式存储信息，这类系统**将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。**\n\n具体原理如下图所示，理解起来其实很简单，每当我们提交更新一个文件之后，系统都会记录这个文件做了哪些更新，以增量符号Δ(Delta)表示。\n\n![](Git.assets/2019-3deltas.png)\n\n\n\n\n**我们怎样才能得到一个文件的最终版本呢？**\n\n很简单，高中数学的基本知识，我们只需要将这些原文件和这些增加进行相加就行了。\n\n**这种方式有什么问题呢？**\n\n比如我们的增量特别特别多的话，如果我们要得到最终的文件是不是会耗费时间和性能。\n\nGit 不按照以上方式对待或保存数据。 反之，Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 **快照流**。\n\n![](Git.assets/2019-3snapshots.png)\n\n\n\n\n\n### Git 的三种状态\n\nGit 有三种状态，你的文件可能处于其中之一：\n\n1. **已提交（committed）**：数据已经安全的保存在本地数据库中。\n2. **已修改（modified）**：已修改表示修改了文件，但还没保存到数据库中。\n3. **已暂存（staged）**：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。\n\n由此引入 Git 项目的三个工作区域的概念：**Git 仓库(.git directory)**、**工作目录(Working Directory)** 以及 **暂存区域(Staging Area)** 。\n\n![](Git.assets/2019-3areas.png)\n\n\n\n\n**基本的 Git 工作流程如下：**\n\n1. 在工作目录中修改文件。\n2. 暂存文件，将文件的快照放入暂存区域。\n3. 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。\n\n## Git 使用快速入门\n\n### 获取 Git 仓库\n\n有两种取得 Git 项目仓库的方法。\n\n1. 在现有目录中初始化仓库: 进入项目目录运行  `git init`  命令,该命令将创建一个名为 `.git` 的子目录。\n2. 从一个服务器克隆一个现有的 Git 仓库: `git clone [url]` 自定义本地仓库的名字: `git clone [url] directoryname`\n\n### 记录每次更新到仓库\n\n1. **检测当前文件状态** : `git status`\n2. **提出更改（把它们添加到暂存区**）：`git add filename ` (针对特定文件)、`git add *`(所有文件)、`git add *.txt`（支持通配符，所有 .txt 文件）\n3. **忽略文件**：`.gitignore` 文件\n4. **提交更新:** `git commit -m "代码提交信息"` （每次准备提交前，先用 `git status` 看下，是不是都已暂存起来了， 然后再运行提交命令 `git commit`）\n5. **跳过使用暂存区域更新的方式** : `git commit -a -m "代码提交信息"`。 `git commit` 加上 `-a` 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 `git add` 步骤。\n6. **移除文件** ：`git rm filename`  （从暂存区域移除，然后提交。）\n7. **对文件重命名** ：`git mv README.md README`(这个命令相当于`mv README.md README`、`git rm README.md`、`git add README` 这三条命令的集合)\n\n### 一个好的 Git 提交消息\n一个好的 Git 提交消息如下：\n\n    标题行：用这一行来描述和解释你的这次提交\n    \n    主体部分可以是很少的几行，来加入更多的细节来解释提交，最好是能给出一些相关的背景或者解释这个提交能修复和解决什么问题。\n    \n    主体部分当然也可以有几段，但是一定要注意换行和句子不要太长。因为这样在使用 "git log" 的时候会有缩进比较好看。\n\n提交的标题行描述应该尽量的清晰和尽量的一句话概括。这样就方便相关的 Git 日志查看工具显示和其他人的阅读。\n\n### 推送改动到远程仓库\n\n- 如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：`git remote add origin <server>` ,比如我们要让本地的一个仓库和 Github 上创建的一个仓库关联可以这样`git remote add origin https://github.com/Snailclimb/test.git` \n- 将这些改动提交到远端仓库：`git push origin master` (可以把 *master* 换成你想要推送的任何分支)\n\n  如此你就能够将你的改动推送到所添加的服务器上去了。\n\n### 远程仓库的移除与重命名\n\n- 将 test 重命名为 test1：`git remote rename test test1`\n- 移除远程仓库 test1:`git remote rm test1`\n\n### 查看提交历史\n\n在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 `git log` 命令。`git log` 会按提交时间列出所有的更新，最近的更新排在最上面。\n\n**可以添加一些参数来查看自己希望看到的内容：**\n\n只看某个人的提交记录：\n\n```shell\ngit log --author=bob\n```\n\n### 撤销操作\n\n有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 `--amend` 选项的提交命令尝试重新提交：\n\n```shell\ngit commit --amend\n```\n\n取消暂存的文件\n\n```shell\ngit reset filename\n```\n\n撤消对文件的修改:\n\n```shell\ngit checkout -- filename\n```\n\n假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：\n\n```shell\ngit fetch origin\ngit reset --hard origin/master\n```\n\n\n### 分支\n\n分支是用来将特性开发绝缘开来的。在你创建仓库的时候，*master* 是“默认”的分支。在其他分支上进行开发，完成后再将它们合并到主分支上。\n\n我们通常在开发新功能、修复一个紧急 bug 等等时候会选择创建分支。单分支开发好还是多分支开发好，还是要看具体场景来说。\n\n创建一个名字叫做 test 的分支\n\n```shell\ngit branch test\n```\n\n切换当前分支到 test（当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样）\n\n```shell\ngit checkout test\n```\n\n\n\n![](Git.assets/2019-3切换分支.png)\n\n你也可以直接这样创建分支并切换过去(上面两条命令的合写)\n\n```shell\ngit checkout -b feature_x\n```\n\n切换到主分支\n\n```shell\ngit checkout master\n```\n\n合并分支(可能会有冲突)\n\n```shell\n git merge test\n```\n\n把新建的分支删掉\n\n```shell\ngit branch -d feature_x\n```\n\n将分支推送到远端仓库（推送成功后其他人可见）：\n\n```shell\ngit push origin\n```\n\n## 推荐\n\n**在线演示学习工具：**\n\n「补充，来自[issue729](https://github.com/Snailclimb/JavaGuide/issues/729)」Learn Git Branching https://oschina.gitee.io/learn-git-branching/ 。该网站可以方便的演示基本的git操作，讲解得明明白白。每一个基本命令的作用和结果。\n\n**推荐阅读：**\n\n- [Git - 简明指南](https://rogerdudler.github.io/git-guide/index.zh.html)\n- [图解Git](https://marklodato.github.io/visual-git-guide/index-zh-cn.html)\n- [猴子都能懂得Git入门](https://backlog.com/git-tutorial/cn/intro/intro1_1.html)\n- https://git-scm.com/book/en/v2\n- [Generating a new SSH key and adding it to the ssh-agent](https://help.github.com/en/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent)\n- [一个好的 Git 提交消息，出自 Linus 之手](https://github.com/torvalds/subsurface-for-dirk/blob/a48494d2fbed58c751e9b7e8fbff88582f9b2d02/README#L88)\n'},c32c:function(n,e,t){"use strict";t.r(e);var o=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[t("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}})],1)},i=[],s=t("3686"),c=t("1b62"),r=Object(s["a"])(t("2fd5"),"md",!0),a=r.all_components,l=r.all_modules,d={mixins:[c["c"],c["b"]],data:function(){return{img_prefix:"./books/tools/",tab:l[0].value,tab_level:1,MainComponent:a[l[0].value],tabs:l}},watch:{tab:function(n,e){this.MainComponent=a[this.tab]}}},u=d,p=t("2877"),h=Object(p["a"])(u,o,i,!1,null,"687b66c2",null);e["default"]=h.exports}}]);