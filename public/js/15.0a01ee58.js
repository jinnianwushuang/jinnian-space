(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[15],{"1b62":function(n,r,t){"use strict";t.d(r,"b",(function(){return i})),t.d(r,"a",(function(){return T}));t("4de4"),t("c975");var e=t("448a"),s=t.n(e),E=["/第1阶段-运维基本功（升级7.6版本）/01运维概述与Linux系统安装.pdf","/第1阶段-运维基本功（升级7.6版本）/02Linux基础命令.pdf"],a="linux/heima-Linux云计算",i={name:"Container",data:function(){return{prefix:a,book_options:E,book_options_all:[],show:!0,book:E[0],src:""}},created:function(){this.book_options_all=s()(this.book_options),this.src=this.$utils.compute_book_src(this.prefix+this.book)},watch:{book:function(n,r){n&&this.change_book()}},methods:{change_book:function(){console.log("this.book",this.book),this.src=this.$utils.compute_book_src(this.prefix+this.book)},filterFn:function(n,r){var t=this;r(""!==n?function(){var r=n.toLowerCase();t.book_options=t.book_options_all.filter((function(n){return n.toLowerCase().indexOf(r)>-1}))}:function(){t.book_options=t.book_options_all})}}},o=t("ded3"),d=t.n(o),l=t("2f62"),T={data:function(){return{tab:"",tab_level:1,is_active:!1}},computed:d()({},Object(l["c"])(["get_current_selected_right_menu"])),created:function(){this.is_active=!0,this.fix_right_menu_config()},watch:{tab:function(){this.tab||this.fix_right_menu_config()},get_current_selected_right_menu:function(n,r){this.tab=this.get_current_selected_right_menu["t"+this.tab_level]}},methods:d()(d()({},Object(l["b"])(["set_right_menu_fix_config"])),{},{fix_right_menu_config:function(){this.set_right_menu_fix_config({tl:this.tab_level,tabs:this.tabs||[],tv:this.tab||this.tabs[0]["value"]})}}),beforeDestroy:function(){this.is_active=!1}}},"42b8":function(n,r,t){"use strict";t.r(r);var e=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t(""+n.tab,{tag:"component"})],1)},s=[],E=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t(""+n.tab,{tag:"component"})],1)},a=[],i=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},o=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("pre",[n._v("          添加系统变量\nC:\\Program Files\\MySQL\\MySQL Server 8.0\\bin\n\nnet start mysql\n\nmysql restart\n\n\n\n　一、启动方式\n　　1、使用 service 启动：service mysqld start\n　　2、使用 mysqld 脚本启动：/etc/inint.d/mysqld start\n　　3、使用 safe_mysqld 启动：safe_mysqld&\n　　二、停止\n　　1、使用 service 启动：service mysqld stop\n　　2、使用 mysqld 脚本启动：/etc/inint.d/mysqld stop\n　　3、mysqladmin shutdown\n　　三、重启\n　　1、使用 service 启动：service mysqld restart\n　　2、使用 mysqld 脚本启动：/etc/inint.d/mysqld restart\n      ")]),t("hr"),t("pre",[n._v('mysql  my.ini\n\n          [mysql]\ndefault-character-set=utf8\n\n[mysqld]\nport = 3306\ndefault_authentication_plugin=mysql_native_password\nbasedir="C:/Program Files/MySQL/MySQL Server 8.0/"\ndatadir="C:/Program Files/MySQL/MySQL Server 8.0/data/"\ncharacter-set-server = utf8\ndefault-storage-engine = MyISAM\n      ')]),t("hr"),t("pre",[n._v('          mysql  my.ini\n\n          [client]\n#password=your_password\nport=3306\nsocket=/tmp/mysql.sock\n\n[mysqld]\nport=3306\nsocket=/tmp/mysql.sock\nkey_buffer_size=256M\nmax_allowed_packet=512M\ntable_open_cache=256\nsort_buffer_size=1M\nread_buffer_size=1M\nread_rnd_buffer_size=4M\nmyisam_sort_buffer_size=64M\nthread_cache_size=8\n\nsecure-file-priv=""\nexplicit_defaults_for_timestamp=1\ndatadir= "C:/laragon/data/mysql"\n\n\n[mysqldump]\nquick\nmax_allowed_packet=512M\n\n      ')])])}],d={},l=d,T=t("2877"),R=Object(T["a"])(l,i,o,!1,null,"22c8ad70",null),c=R.exports,L=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},m=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("pre",[n._v("         mysql 安装了最新版本8.x版本后的报错： the server requested authentication method unknown to the client\n2018年07月22日 13:11:38 youcijibi 阅读数 10613\n一，在MySQL 8.0.11中，caching_sha2_password是默认的身份验证插件，而不是以往的mysql_native_password。有关此更改对服务器操作的影响以及服务器与客户端和连接器的兼容性的信息，请参阅caching_sha2_password作为首选的身份验证插件。(翻译自https://dev.mysql.com/doc/refman/8.0/en/caching-sha2-pluggable-authentication.html）\n今天在新服务上配置安装mysql8.0.11时，像往常一样设置mysql密码，设置成功后在shell下输入mysql -u root -p，再输入密码能正常进入，但在phpmyadmin或直接用http://php.net/manual/zh/mysqli.real-connect.php上的连接，均提示无法连接，具体报错信息为\nmysqli_real_connect(): The server requested authentication method unknown to the client [sha256_password]  \n \n搜了一圈，找到官方文档才发现从8.0.11版本起，不再像mysql5.7及以前版本那样，设置用户密码时默认的验证方式为caching_sha2_password，如果发现升级mysql8.0.11后原有的程序不能连接mysql，可迅速在mysql command line client客户端用下面的命令设置成mysql5.7及以前版本的密码验证方式，同时MYSQL8.0.11下修改密码的方式与原先也不大一样，原先的部分修改密码的命令在mysql8.0.11下不能使用。\n> use mysql  \n> ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '你的密码';  \n> FLUSH PRIVILEGES;            \n二，\n \nmysql 安装了最新版本8.0.11后创建用户并授权后，授权的用户连接数据库提示\nThe server requested authentication method unknown to the client\n查阅一些相关的资料后发现是由于新版本的mysql账号密码解锁机制不一致导致的\n解决办法：\n删除创建的用户和授权，\n找到mysql配置文件并加入\ndefault_authentication_plugin=mysql_native_password\n变为原来的验证方式，然后从新创建用户并授权即可\n或\nmysql -uroot -p\n \nuse mysql;\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '你的密码';\n三\nThe caching_sha2_password and sha256_password authentication plugins provide more secure \npassword encryption than the mysql_native_password plugin, and caching_sha2_password provides better performance than sha256_password. \nDue to these superior security and performance characteristics of caching_sha2_password, it is as of MySQL 8.0 the preferred authentication plugin,\n and is also the default authentication plugin rather than mysql_native_password.\n翻译：caching_sha2_password和sha256_password认证插件比mysql_native_password插件提供的密码加密更加安全，并且caching_sha2_password加密比sha256_password的加密性能更好。\n由于caching_sha2_password这样优秀的安全和性能特性，让他作为MySQL8.0的首选认证插件，这也是默认的认证插件插件而不是mysql_native_password。\n具体你可以访问这个caching_sha2_password Compatibility Issues and Solutions来了解，已经使用了新的加密方式，访问不了的解决方法，简单总结一下就是\n1、将加密方式改为旧的，在配置文件my.conf中添加如下：\n[mysqld]\ndefault_authentication_plugin=mysql_native_password\n2、使用支持新的加密方式的客户端（Client），比如等于或高于8.0.4版本的libmysqlclient\n3、使用支持新的加密方式的连接驱动（Connector）：\nMySQL Connector/C++ 1.1.11 or higher or 8.0.7 or higher.\n \nMySQL Connector/J 8.0.9 or higher.\n \nMySQL Connector/NET 8.0.10 or higher (through the classic MySQL protocol).\n \nMySQL Connector/Node.js 8.0.9 or higher.\n \nPHP: the X DevAPI PHP extension (mysql_xdevapi) supports caching_sha2_password.\n4、使用了新的加密方式，改为旧的加密方式，而root用户也要进行相应的更改才可以，因为root用户还是新的加方式，所以使用alter语句改为重置密码来覆盖新的加密方式的密码：\nALTER USER 'root'@'localhost'\n  IDENTIFIED WITH mysql_native_password\n  BY 'password';\npassword是你将要设置的root用户的密码。\n参考文章：Changes Affecting Upgrades to MySQL 8.0\n     ")])])}],A={},u=A,N=Object(T["a"])(u,L,m,!1,null,"1b167366",null),S=N.exports,y=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},p=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("h4",[n._v("mysql 简单命令")]),t("pre",[n._v("         CREATE TABLE `o2o`.`Untitled`  (\n  `area_id` int(2) NOT NULL AUTO_INCREMENT,\n  `area_name` varchar(255) NOT NULL,\n  `priority` int(2) NOT NULL DEFAULT 0,\n  `create_time` datetime(0) NULL DEFAULT NULL,\n  `last_edit_time` datetime(0) NULL DEFAULT NULL,\n  PRIMARY KEY (`area_id`),\n\tunique key `UK_AREA`(`area_name`)\n)engine=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 ;\n\n     ")]),t("pre",[n._v("         加入服务\n加入 环境变量\n管理员启动 CMD\nmysql -u root -p  输入密码\n命令行要带 ； \nddl\ndml\ndql\ndcl\n\n\ncreate database web01; 创建\ncreate database web01 default character set utf8;\nshow create database web01; 查看结构\nuse web01;  database changed;  使用表\nselect database(); 查看当前正在操作的库 \n\ncreat table user(\nuid int(32) primary key auto_increment,\nuname varchar(32),\nupassword varchar(32)\n);\nshow tables; 展示所有表\ndesc user; 显示user表的详细信息\ndrop table user; 删除表\n改变my.ini 文件重启 mysql 服务 ，防止乱码，设置字符集utf8\nset uname gbk;  在 cmd 中 改变单列数据编码，防止中文乱码，只在CMD显示上有效\nalter table user add uage int(32) not null; 添加一列\nalter table user modify uage varchar(100) null; 改变列属性\nalter table user uage uinfo varchar(100) null; 改变列名\nalter table user drop uinfo; 删除列\n\ninsert into user(uid,uname,upasswod) values(null,'name1','pass1');\ninsert into user values(null,'q','w'); 全字段插入\nupdate user set uname='po', upassword='p1' where uid=5; 更新表数值\ndelete from user where uid=2;\ntruncate table user; 摧毁表并重建一张一样字段的表 ，不可回滚，本质上是两张表\nstart trancation;开启事务\nrollback;  回滚 \n\nselect [distinct] * | 列名... from  表 [where 条件]。\n select *  from user as p; 表别名查询\nselect pname as pn from product ;列别名查询\nselect distinct pq from product; 去掉重复值查询\nselect pname,pr+12 from product; 带运算查询\nselect * from pr where pid>45; 条件查询\nselect * from  pro  where pname like '_新%'； 格式 占位符查询 第二个字是新\nselect * from  pro where pid in (4,8,9,52,44,63);  in  范围查询\nselect * from pro where pr is null ; 根据空值查询 \n and or  not 逻辑查询  where not (pr>100);\n 排序\nselect * from pro where pname like '_新%' order by price desc; 排序\n聚合 sum() avg() count(*) max() min()\nselect sum(price) from pro; 聚合\n分组\nselect cid ,count(*) from product group by cid;\nselect cid ,avg(price) from product group by having avg(price)>60\n根据cid分组，分组统计每组商品的平均价格，并且平均价格大于60；\n\n\n\n\n\n\n\n\n\n\n\n\n     ")])])}],I={},O=I,M=Object(T["a"])(O,y,p,!1,null,"66fdad40",null),C=M.exports,h=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},D=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",[n._v("LINUX 安装 5.7 mysql ")]),t("pre",[n._v("1. 通过secureCRT工具连接Linux系统\n\n2. 上传 mysql 的安装包\n\n    alt + p -------\x3e put d:/setup/mysql-5.7.27-1.el7.x86_64.rpm-bundle.tar\n\n3. 解压 mysql 的安装包\n\n\tmkdir mysql\n    \n\ttar -xvf mysql-5.7.27-1.el7.x86_64.rpm-bundle.tar -C mysql/\n\n\n4. 安装客户端\n    \n\tcd mysql/\n    \n\trpm -ivh mysql-community-client-5.7.27-1.el7.x86_64.rpm --force --nodeps\n\n\n5. 安装服务端\n    \n\trpm -ivh mysql-community-server-5.7.27-1.el7.x86_64.rpm --force --nodeps\n\n\n6. 修改mysql默认字符集\n    \n\tvi /etc/my.cnf\n    \n\t添加如下内容：\n    \n\t[mysqld]\n\tcharacter-set-server=utf8\n\tcollation-server=utf8_general_ci\n \n\t-- 在文件最下方添加\n    \n\t[client]\n\tdefault-character-set=utf8\n\n7. 启动mysql服务\n    \n\tservice mysqld start\n\n8. 登录mysql\n    \n\tmysql -u root -p  敲回车，输入密码\n    \n\t初始密码查看：cat /var/log/mysqld.log\n    \n\t在root@localhost:   后面的就是初始密码\n\n9. 修改mysql登录密码\n    \n\tset global validate_password_policy=0;\n    \n\tset global validate_password_length=1;\n    \n\tset password=password('密码');\n\n\n10. 授予远程连接权限\n    \n\t//授权\n\tgrant all privileges on *.* to 'root' @'%' identified by '密码';\n    \n\t//刷新\n\tflush privileges;\n\n\n11. 关闭Linux系统防火墙\n\tsystemctl stop firewalld\n\n12. 重启mysql服务\n\tservice mysqld restart\n\n13. 使用SQLYog工具连接mysql          \n      ")])])}],g={},U=g,_=Object(T["a"])(U,h,D,!1,null,"75b65d6e",null),q=_.exports,b=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},F=[],B="\x3c!--\r\n * @Date           : 2021-04-10 16:40:09\r\n * @FilePath       : /jinnian-space/src/pages/sql/md/MySQL基础-01-授课笔记.md\r\n * @Description    : \r\n--\x3e\r\n# MySQL基础-01-授课笔记\r\n\r\n### 一、数据库的基本概念\r\n\r\n#### 1.为什么要学数据库？\r\n\r\n- 之前我们如果想将一些数据实现永久化存储，可以怎么做呢？没错。使用IO流的技术将数据保存到本地文件中\r\n- 但是接下来我有这样一个需求：将下面的user.txt文件中的王五年龄修改为35\r\n\r\n```txt\r\n张三 23 男\r\n李四 24 男\r\n王五 25 女\r\n赵六 26 女\r\n周七 27 男\r\n```\r\n\r\n- 我们要如何实现呢？\r\n  - 可以采用字符缓冲流，将每一行数据读取出来，封装为User对象。将多个User对象保存到集合中\r\n  - 然后遍历集合，将王五对象的年龄修改为35,再重新将集合中的对象信息写回到文件中\r\n- 这一套操作太麻烦了，而现在我们有一种更加方便的方式来完成这个需求了，这种方式就是数据库！\r\n\r\n#### 2.什么是数据库？\r\n\r\n- 用于存储和管理数据的仓库\r\n- 英文单词为：DataBase，简称DB\r\n\r\n#### 3.数据库的好处？\r\n\r\n- 可以持久化存储数据\r\n- 方便存储和管理数据\r\n- 使用了统一的方式操作数据库 -- SQL\r\n\r\n#### 4.常见的数据库有哪些？\r\n\r\n\r\n\x3c!-- ![01](./img/sql/mysql/MySQL基础-01-授课笔记.assets/01.png) --\x3e\r\n\x3c!-- src\\pages\\sql\\md\\MySQL基础-01-授课笔记.md --\x3e\r\n![01](./img/sql/mysql/MySQL基础-01-授课笔记.assets/01.png)\r\n\r\n### 二、MySQL数据库的介绍和安装\r\n\r\n#### 1.MySQL数据库介绍\r\n\r\n- 小型的数据库\r\n- 开源免费(6版本之前免费)\r\n- 所属于Oracle公司\r\n\r\n#### 2.MySQL数据库安装\r\n\r\n1. 通过secureCRT工具连接Linux系统\r\n\r\n2. 上传 mysql 的安装包\r\n\r\n```linux\r\nalt + p -------\x3e put d:/setup/mysql-5.7.27-1.el7.x86_64.rpm-bundle.tar\r\n```\r\n\r\n3. 解压 mysql 的安装包\r\n\r\n```linux\r\nmkdir mysql\r\ntar -xvf mysql-5.7.27-1.el7.x86_64.rpm-bundle.tar -C mysql/\r\n```\r\n\r\n4. 安装客户端\r\n\r\n```linux\r\ncd mysql/\r\nrpm -ivh mysql-community-client-5.7.27-1.el7.x86_64.rpm --force --nodeps\r\n```\r\n\r\n5. 安装服务端\r\n\r\n```\r\nrpm -ivh mysql-community-server-5.7.27-1.el7.x86_64.rpm --force --nodeps\r\n```\r\n\r\n6. 修改mysql默认字符集\r\n\r\n```\r\nvi /etc/my.cnf\r\n\r\n添加如下内容：\r\n[mysqld]\r\ncharacter-set-server=utf8\r\ncollation-server=utf8_general_ci\r\n\r\n-- 需要在最下方填写\r\n[client]\r\ndefault-character-set=utf8\r\n```\r\n\r\n7. 启动mysql服务\r\n\r\n```\r\nservice mysqld start\r\n```\r\n\r\n8. 登录mysql\r\n\r\n```\r\nmysql -u root -p  敲回车，输入密码\r\n初始密码查看：cat /var/log/mysqld.log\r\n在root@localhost:   后面的就是初始密码\r\n```\r\n\r\n9. 修改mysql登录密码\r\n\r\n```\r\nset global validate_password_policy=0;\r\n\r\nset global validate_password_length=1;\r\n\r\nset password=password('密码');\r\n```\r\n\r\n10. 授予远程连接权限\r\n\r\n```\r\n//授权\r\ngrant all privileges on *.* to 'root' @'%' identified by '密码';\r\n//刷新\r\nflush privileges;\r\n```\r\n\r\n11. 关闭Linux系统防火墙\r\n\r\n```\r\nsystemctl stop firewalld.service\r\n```\r\n\r\n#### 3.MySQL数据库登录\r\n\r\n- sqlyog工具登录mysql\r\n\r\n![02](./img/sql/mysql/MySQL基础-01-授课笔记.assets/02.png)\r\n\r\n### 三、SQL语句\r\n\r\n#### 1.数据库、数据表、数据的关系介绍\r\n\r\n- 数据库\r\n  - 用于存储和管理数据的仓库\r\n  - 一个库中可以包含多个数据表\r\n- 数据表\r\n  - 数据库最重要的组成部分之一\r\n  - 它由纵向的列和横向的行组成(类似excel表格)\r\n  - 可以指定列名、数据类型、约束等\r\n  - 一个表中可以存储多条数据\r\n- 数据\r\n  - 想要永久化存储的数据\r\n\r\n![03](./img/sql/mysql/MySQL基础-01-授课笔记.assets/03.png)\r\n\r\n#### 2.SQL介绍\r\n\r\n- 什么是SQL\r\n\r\n  - Structured Query Language：结构化查询语言\r\n  - 其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式可能会存在一些不一样的地方，我们称为“方言”。\r\n\r\n- SQL通用语法\r\n\r\n  - SQL 语句可以单行或多行书写，以分号结尾。\r\n  - 可使用空格和缩进来增强语句的可读性。\r\n  - MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。\r\n  - 数据库的注释：\r\n    - 单行注释：-- 注释内容       #注释内容(mysql特有)\r\n    - 多行注释：/* 注释内容 */\r\n\r\n- SQL分类\r\n\r\n  - DDL(Data Definition Language)数据定义语言\r\n    - 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等\r\n  - DML(Data Manipulation Language)数据操作语言\r\n    - 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等\r\n  - DQL(Data Query Language)数据查询语言\r\n    - 用来查询数据库中表的记录(数据)。关键字：select, where 等\r\n  - DCL(Data Control Language)数据控制语言(了解)\r\n    - 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等\r\n\r\n  ![04](./img/sql/mysql/MySQL基础-01-授课笔记.assets/04.png)\r\n\r\n#### 3.DDL-操作数据库\r\n\r\n- R(Retrieve)：查询\r\n\r\n  - 查询所有数据库\r\n\r\n  ```mysql\r\n  -- 查询所有数据库\r\n  SHOW DATABASES;\r\n  ```\r\n\r\n  - 查询某个数据库的创建语句\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SHOW CREATE DATABASE 数据库名称;\r\n  \r\n  -- 查看mysql数据库的创建格式\r\n  SHOW CREATE DATABASE mysql;\r\n  ```\r\n\r\n- C(Create)：创建\r\n\r\n  - 创建数据库\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  CREATE DATABASE 数据库名称;\r\n  \r\n  -- 创建db1数据库\r\n  CREATE DATABASE db1;\r\n  \r\n  -- 创建一个已存在的数据库会报错\r\n  -- 错误代码：1007  Can't create database 'db1'; database exists\r\n  CREATE DATABASE db1;\r\n  ```\r\n\r\n  - 创建数据库(判断，如果不存在则创建)\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  CREATE DATABASE IF NOT EXISTS 数据库名称;\r\n  \r\n  -- 创建数据库db2(判断，如果不存在则创建)\r\n  CREATE DATABASE IF NOT EXISTS db2;\r\n  ```\r\n\r\n  - 创建数据库、并指定字符集\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  CREATE DATABASE 数据库名称 CHARACTER SET 字符集名称;\r\n  \r\n  -- 创建数据库db3、并指定字符集utf8\r\n  CREATE DATABASE db3 CHARACTER SET utf8;\r\n  \r\n  -- 查看db3数据库的字符集\r\n  SHOW CREATE DATABASE db3;\r\n  ```\r\n\r\n  - 练习：创建db4数据库、如果不存在则创建，指定字符集为gbk\r\n\r\n  ```mysql\r\n  -- 创建db4数据库、如果不存在则创建，指定字符集为gbk\r\n  CREATE DATABASE IF NOT EXISTS db4 CHARACTER SET gbk;\r\n  \r\n  -- 查看db4数据库的字符集\r\n  SHOW CREATE DATABASE db4;\r\n  ```\r\n\r\n- U(Update)：修改\r\n\r\n  - 修改数据库的字符集\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  ALTER DATABASE 数据库名称 CHARACTER SET 字符集名称;\r\n  \r\n  -- 修改数据库db4的字符集为utf8\r\n  ALTER DATABASE db4 CHARACTER SET utf8;\r\n  \r\n  -- 查看db4数据库的字符集\r\n  SHOW CREATE DATABASE db4;\r\n  ```\r\n\r\n- D(Delete)：删除\r\n\r\n  - 删除数据库\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  DROP DATABASE 数据库名称;\r\n  \r\n  -- 删除db1数据库\r\n  DROP DATABASE db1;\r\n  \r\n  -- 删除一个不存在的数据库会报错\r\n  -- 错误代码：1008  Can't drop database 'db1'; database doesn't exist\r\n  DROP DATABASE db1;\r\n  ```\r\n\r\n  - 删除数据库(判断，如果存在则删除)\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  DROP DATABASE IF EXISTS 数据库名称;\r\n  \r\n  -- 删除数据库db2，如果存在\r\n  DROP DATABASE IF EXISTS db2;\r\n  ```\r\n\r\n- 使用数据库\r\n\r\n  - 查询当前正在使用的数据库名称\r\n\r\n  ```mysql\r\n  -- 查询当前正在使用的数据库\r\n  SELECT DATABASE();\r\n  ```\r\n\r\n  - 使用数据库\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  USE 数据库名称；\r\n  \r\n  -- 使用db4数据库\r\n  USE db4;\r\n  ```\r\n\r\n#### 4.DDL-操作数据表\r\n\r\n- R(Retrieve)：查询\r\n\r\n  - 查询数据库中所有的数据表\r\n\r\n  ```mysql\r\n  -- 使用mysql数据库\r\n  USE mysql;\r\n  \r\n  -- 查询库中所有的表\r\n  SHOW TABLES;\r\n  ```\r\n\r\n  - 查询表结构\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  DESC 表名;\r\n  \r\n  -- 查询user表结构\r\n  DESC user;\r\n  ```\r\n\r\n  - 查询表字符集\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SHOW TABLE STATUS FROM 库名 LIKE '表名';\r\n  \r\n  -- 查看mysql数据库中user表字符集\r\n  SHOW TABLE STATUS FROM mysql LIKE 'user';\r\n  ```\r\n\r\n- C(Create)：创建\r\n\r\n  - 创建数据表\r\n\r\n    - 标准语法\r\n\r\n    ```mysql\r\n    CREATE TABLE 表名(\r\n        列名1 数据类型1,\r\n        列名2 数据类型2,\r\n        ....\r\n        列名n 数据类型n\r\n    );\r\n    -- 注意：最后一列，不需要加逗号\r\n    ```\r\n\r\n    - 数据类型\r\n\r\n    ```mysql\r\n    1. int：整数类型\r\n    \t* age int\r\n    2. double:小数类型\r\n    \t* score double(5,2)\r\n    \t* price double\r\n    3. date:日期，只包含年月日     yyyy-MM-dd\r\n    4. datetime:日期，包含年月日时分秒\t yyyy-MM-dd HH:mm:ss\r\n    5. timestamp:时间戳类型\t包含年月日时分秒\t yyyy-MM-dd HH:mm:ss\t\r\n    \t* 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值\r\n    6. varchar：字符串\r\n    \t* name varchar(20):姓名最大20个字符\r\n    \t* zhangsan 8个字符  张三 2个字符\r\n    ```\r\n\r\n    - 创建数据表\r\n\r\n    ```mysql\r\n    -- 使用db3数据库\r\n    USE db3;\r\n    \r\n    -- 创建一个product商品表\r\n    CREATE TABLE product(\r\n    \tid INT,\t\t\t\t-- 商品编号\r\n    \tNAME VARCHAR(30),\t-- 商品名称\r\n    \tprice DOUBLE,\t\t-- 商品价格\r\n    \tstock INT,\t\t\t-- 商品库存\r\n    \tinsert_time DATE    -- 上架时间\r\n    );\r\n    ```\r\n\r\n    - 复制表\r\n\r\n    ```mysql\r\n    -- 标准语法\r\n    CREATE TABLE 表名 LIKE 被复制的表名;\r\n    \r\n    -- 复制product表到product2表\r\n    CREATE TABLE product2 LIKE product;\r\n    ```\r\n\r\n- U(Update)：修改\r\n\r\n  - 修改表名\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  ALTER TABLE 表名 RENAME TO 新的表名;\r\n  \r\n  -- 修改product2表名为product3\r\n  ALTER TABLE product2 RENAME TO product3;\r\n  ```\r\n\r\n  - 修改表的字符集\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  ALTER TABLE 表名 CHARACTER SET 字符集名称;\r\n  \r\n  -- 查看db3数据库中product3数据表字符集\r\n  SHOW TABLE STATUS FROM db3 LIKE 'product3';\r\n  -- 修改product3数据表字符集为gbk\r\n  ALTER TABLE product3 CHARACTER SET gbk;\r\n  -- 查看db3数据库中product3数据表字符集\r\n  SHOW TABLE STATUS FROM db3 LIKE 'product3';\r\n  ```\r\n\r\n  - 添加一列\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  ALTER TABLE 表名 ADD 列名 数据类型;\r\n  \r\n  -- 给product3表添加一列color\r\n  ALTER TABLE product3 ADD color VARCHAR(10);\r\n  ```\r\n\r\n  - 修改列名称和数据类型\r\n\r\n  ```mysql\r\n  -- 修改数据类型 标准语法\r\n  ALTER TABLE 表名 MODIFY 列名 新数据类型;\r\n  \r\n  -- 将color数据类型修改为int\r\n  ALTER TABLE product3 MODIFY color INT;\r\n  -- 查看product3表详细信息\r\n  DESC product3;\r\n  \r\n  \r\n  -- 修改列名和数据类型 标准语法\r\n  ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型;\r\n  \r\n  -- 将color修改为address,数据类型为varchar\r\n  ALTER TABLE product3 CHANGE color address VARCHAR(30);\r\n  -- 查看product3表详细信息\r\n  DESC product3;\r\n  ```\r\n\r\n  - 删除列\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  ALTER TABLE 表名 DROP 列名;\r\n  \r\n  -- 删除address列\r\n  ALTER TABLE product3 DROP address;\r\n  ```\r\n\r\n- D(Delete)：删除\r\n\r\n  - 删除数据表\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  DROP TABLE 表名;\r\n  \r\n  -- 删除product3表\r\n  DROP TABLE product3;\r\n  \r\n  -- 删除不存在的表，会报错\r\n  -- 错误代码：1051  Unknown table 'product3'\r\n  DROP TABLE product3;\r\n  ```\r\n\r\n  - 删除数据表(判断，如果存在则删除)\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  DROP TABLE IF EXISTS 表名;\r\n  \r\n  -- 删除product3表，如果存在则删除\r\n  DROP TABLE IF EXISTS product3;\r\n  ```\r\n\r\n#### 5.DML-INSERT语句\r\n\r\n- 新增表数据语法\r\n\r\n  - 新增格式1：给指定列添加数据\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  INSERT INTO 表名(列名1,列名2,...) VALUES (值1,值2,...);\r\n  \r\n  -- 向product表添加一条数据\r\n  INSERT INTO product(id,NAME,price,stock,insert_time) VALUES (1,'手机',1999,22,'2099-09-09');\r\n  \r\n  -- 向product表添加指定列数据\r\n  INSERT INTO product (id,NAME,price) VALUES (2,'电脑',4999);\r\n  \r\n  -- 查看表中所有数据\r\n  SELECT * FROM product;\r\n  ```\r\n\r\n  - 新增格式2：默认给全部列添加数据\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  INSERT INTO 表名 VALUES (值1,值2,值3,...);\r\n  \r\n  -- 默认给全部列添加数据\r\n  INSERT INTO product VALUES (3,'电视',2999,18,'2099-06-06');\r\n  \r\n  -- 查看表中所有数据\r\n  SELECT * FROM product;\r\n  ```\r\n\r\n  - 新增格式3：批量添加数据\r\n\r\n  ```mysql\r\n  -- 默认添加所有列数据 标准语法\r\n  INSERT INTO 表名 VALUES (值1,值2,值3,...),(值1,值2,值3,...),(值1,值2,值3,...);\r\n  \r\n  -- 批量添加数据\r\n  INSERT INTO product VALUES (4,'冰箱',999,26,'2099-08-08'),(5,'洗衣机',1999,32,'2099-05-10');\r\n  -- 查看表中所有数据\r\n  SELECT * FROM product;\r\n  \r\n  \r\n  -- 给指定列添加数据 标准语法\r\n  INSERT INTO 表名(列名1,列名2,...) VALUES (值1,值2,...),(值1,值2,...),(值1,值2,...);\r\n  \r\n  -- 批量添加指定列数据\r\n  INSERT INTO product (id,NAME,price) VALUES (6,'微波炉',499),(7,'电磁炉',899);\r\n  -- 查看表中所有数据\r\n  SELECT * FROM product;\r\n  ```\r\n\r\n- 注意事项\r\n\r\n  - 列名和值的数量以及数据类型要对应\r\n  - 除了数字类型，其他数据类型的数据都需要加引号(单引双引都可以，推荐单引)\r\n\r\n#### 6.DML-UPDATE语句\r\n\r\n- 修改表数据语法\r\n\r\n```mysql\r\n-- 标准语法\r\nUPDATE 表名 SET 列名1 = 值1,列名2 = 值2,... [where 条件];\r\n\r\n-- 修改手机的价格为3500\r\nUPDATE product SET price=3500 WHERE NAME='手机';\r\n\r\n-- 查看所有数据\r\nSELECT * FROM product;\r\n\r\n-- 修改电视的价格为1800、库存为36\r\nUPDATE product SET price=1800,stock=36 WHERE NAME='电视';\r\n\r\n-- 修改电磁炉的库存为10\r\nUPDATE product SET stock=10 WHERE id=7;\r\n```\r\n\r\n- 注意事项\r\n  - 修改语句中必须加条件\r\n  - 如果不加条件，则将所有数据都修改\r\n\r\n#### 7.DML-DELETE语句\r\n\r\n- 删除表数据语法\r\n\r\n```mysql\r\n-- 标准语法\r\nDELETE FROM 表名 [WHERE 条件];\r\n\r\n-- 删除product表中的微波炉信息\r\nDELETE FROM product WHERE NAME='微波炉';\r\n\r\n-- 删除product表中库存为10的商品信息\r\nDELETE FROM product WHERE stock=10;\r\n\r\n-- 查看所有商品信息\r\nSELECT * FROM product;\r\n```\r\n\r\n- 注意事项\r\n  - 删除语句中必须加条件\r\n  - 如果不加条件，则将所有数据删除\r\n\r\n#### 8.DQL-单表查询\r\n\r\n- 数据准备(直接复制执行即可)\r\n\r\n```mysql\r\n-- 创建db1数据库\r\nCREATE DATABASE db1;\r\n\r\n-- 使用db1数据库\r\nUSE db1;\r\n\r\n-- 创建数据表\r\nCREATE TABLE product(\r\n\tid INT,\t\t\t\t-- 商品编号\r\n\tNAME VARCHAR(20),\t-- 商品名称\r\n\tprice DOUBLE,\t\t-- 商品价格\r\n\tbrand VARCHAR(10),\t-- 商品品牌\r\n\tstock INT,\t\t\t-- 商品库存\r\n\tinsert_time DATE    -- 添加时间\r\n);\r\n\r\n-- 添加数据\r\nINSERT INTO product VALUES (1,'华为手机',3999,'华为',23,'2088-03-10'),\r\n(2,'小米手机',2999,'小米',30,'2088-05-15'),\r\n(3,'苹果手机',5999,'苹果',18,'2088-08-20'),\r\n(4,'华为电脑',6999,'华为',14,'2088-06-16'),\r\n(5,'小米电脑',4999,'小米',26,'2088-07-08'),\r\n(6,'苹果电脑',8999,'苹果',15,'2088-10-25'),\r\n(7,'联想电脑',7999,'联想',NULL,'2088-11-11');\r\n```\r\n\r\n- 查询语法\r\n\r\n```mysql\r\nselect\r\n\t字段列表\r\nfrom\r\n\t表名列表\r\nwhere\r\n\t条件列表\r\ngroup by\r\n\t分组字段\r\nhaving\r\n\t分组之后的条件\r\norder by\r\n\t排序\r\nlimit\r\n\t分页限定\r\n```\r\n\r\n- 查询全部\r\n\r\n```mysql\r\n-- 标准语法\r\nSELECT * FROM 表名;\r\n\r\n-- 查询product表所有数据\r\nSELECT * FROM product;\r\n```\r\n\r\n- 查询部分\r\n\r\n  - 多个字段查询\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SELECT 列名1,列名2,... FROM 表名;\r\n  \r\n  -- 查询名称、价格、品牌\r\n  SELECT NAME,price,brand FROM product;\r\n  ```\r\n\r\n  - 去除重复查询\r\n    - 注意：只有全部重复的才可以去除\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SELECT DISTINCT 列名1,列名2,... FROM 表名;\r\n  \r\n  -- 查询品牌\r\n  SELECT brand FROM product;\r\n  -- 查询品牌，去除重复\r\n  SELECT DISTINCT brand FROM product;\r\n  ```\r\n\r\n  - 计算列的值(四则运算)\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SELECT 列名1 运算符(+ - * /) 列名2 FROM 表名;\r\n  \r\n  /*\r\n  \t计算列的值\r\n  \t标准语法：\r\n  \t\tSELECT 列名1 运算符(+ - * /) 列名2 FROM 表名;\r\n  \t\t\r\n  \t如果某一列为null，可以进行替换\r\n  \tifnull(表达式1,表达式2)\r\n  \t表达式1：想替换的列\r\n  \t表达式2：想替换的值\r\n  */\r\n  -- 查询商品名称和库存，库存数量在原有基础上加10\r\n  SELECT NAME,stock+10 FROM product;\r\n  \r\n  -- 查询商品名称和库存，库存数量在原有基础上加10。进行null值判断\r\n  SELECT NAME,IFNULL(stock,0)+10 FROM product;\r\n  ```\r\n\r\n  - 起别名\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SELECT 列名1,列名2,... AS 别名 FROM 表名;\r\n  \r\n  -- 查询商品名称和库存，库存数量在原有基础上加10。进行null值判断。起别名为getSum\r\n  SELECT NAME,IFNULL(stock,0)+10 AS getsum FROM product;\r\n  SELECT NAME,IFNULL(stock,0)+10 getsum FROM product;\r\n  ```\r\n\r\n- 条件查询\r\n\r\n  - 条件分类\r\n\r\n  | 符号                | 功能                                   |\r\n  | ------------------- | -------------------------------------- |\r\n  | >                   | 大于                                   |\r\n  | <                   | 小于                                   |\r\n  | >=                  | 大于等于                               |\r\n  | <=                  | 小于等于                               |\r\n  | =                   | 等于                                   |\r\n  | <> 或 !=            | 不等于                                 |\r\n  | BETWEEN ... AND ... | 在某个范围之内(都包含)                 |\r\n  | IN(...)             | 多选一                                 |\r\n  | LIKE 占位符         | 模糊查询  _单个任意字符  %多个任意字符 |\r\n  | IS NULL             | 是NULL                                 |\r\n  | IS NOT NULL         | 不是NULL                               |\r\n  | AND 或 &&           | 并且                                   |\r\n  | OR 或 \\|\\|          | 或者                                   |\r\n  | NOT 或 !            | 非，不是                               |\r\n\r\n  - 条件查询语法\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SELECT 列名 FROM 表名 WHERE 条件;\r\n  \r\n  -- 查询库存大于20的商品信息\r\n  SELECT * FROM product WHERE stock > 20;\r\n  \r\n  -- 查询品牌为华为的商品信息\r\n  SELECT * FROM product WHERE brand='华为';\r\n  \r\n  -- 查询金额在4000 ~ 6000之间的商品信息\r\n  SELECT * FROM product WHERE price >= 4000 AND price <= 6000;\r\n  SELECT * FROM product WHERE price BETWEEN 4000 AND 6000;\r\n  \r\n  -- 查询库存为14、30、23的商品信息\r\n  SELECT * FROM product WHERE stock=14 OR stock=30 OR stock=23;\r\n  SELECT * FROM product WHERE stock IN(14,30,23);\r\n  \r\n  -- 查询库存为null的商品信息\r\n  SELECT * FROM product WHERE stock IS NULL;\r\n  -- 查询库存不为null的商品信息\r\n  SELECT * FROM product WHERE stock IS NOT NULL;\r\n  \r\n  -- 查询名称以小米为开头的商品信息\r\n  SELECT * FROM product WHERE NAME LIKE '小米%';\r\n  \r\n  -- 查询名称第二个字是为的商品信息\r\n  SELECT * FROM product WHERE NAME LIKE '_为%';\r\n  \r\n  -- 查询名称为四个字符的商品信息\r\n  SELECT * FROM product WHERE NAME LIKE '____';\r\n  \r\n  -- 查询名称中包含电脑的商品信息\r\n  SELECT * FROM product WHERE NAME LIKE '%电脑%';\r\n  ```\r\n\r\n- 聚合函数\r\n\r\n  - 将一列数据作为一个整体，进行纵向的计算\r\n  - 聚合函数分类\r\n\r\n  | 函数名      | 功能                           |\r\n  | ----------- | ------------------------------ |\r\n  | count(列名) | 统计数量(一般选用不为null的列) |\r\n  | max(列名)   | 最大值                         |\r\n  | min(列名)   | 最小值                         |\r\n  | sum(列名)   | 求和                           |\r\n  | avg(列名)   | 平均值                         |\r\n\r\n  - 聚合函数语法\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SELECT 函数名(列名) FROM 表名 [WHERE 条件];\r\n  \r\n  -- 计算product表中总记录条数\r\n  SELECT COUNT(*) FROM product;\r\n  \r\n  -- 获取最高价格\r\n  SELECT MAX(price) FROM product;\r\n  -- 获取最高价格的商品名称\r\n  SELECT NAME,price FROM product WHERE price = (SELECT MAX(price) FROM product);\r\n  \r\n  -- 获取最低库存\r\n  SELECT MIN(stock) FROM product;\r\n  -- 获取最低库存的商品名称\r\n  SELECT NAME,stock FROM product WHERE stock = (SELECT MIN(stock) FROM product);\r\n  \r\n  -- 获取总库存数量\r\n  SELECT SUM(stock) FROM product;\r\n  -- 获取品牌为苹果的总库存数量\r\n  SELECT SUM(stock) FROM product WHERE brand='苹果';\r\n  \r\n  -- 获取品牌为小米的平均商品价格\r\n  SELECT AVG(price) FROM product WHERE brand='小米';\r\n  ```\r\n\r\n- 排序查询\r\n\r\n  - 排序分类\r\n    - 注意：多个排序条件，当前边的条件值一样时，才会判断第二条件\r\n\r\n  | 关键词                                   | 功能                                    |\r\n  | ---------------------------------------- | --------------------------------------- |\r\n  | ORDER BY 列名1 排序方式1,列名2 排序方式2 | 对指定列排序，ASC升序(默认的)  DESC降序 |\r\n\r\n  - 排序语法\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SELECT 列名 FROM 表名 [WHERE 条件] ORDER BY 列名1 排序方式1,列名2 排序方式2;\r\n  \r\n  -- 按照库存升序排序\r\n  SELECT * FROM product ORDER BY stock ASC;\r\n  \r\n  -- 查询名称中包含手机的商品信息。按照金额降序排序\r\n  SELECT * FROM product WHERE NAME LIKE '%手机%' ORDER BY price DESC;\r\n  \r\n  -- 按照金额升序排序，如果金额相同，按照库存降序排列\r\n  SELECT * FROM product ORDER BY price ASC,stock DESC;\r\n  ```\r\n\r\n- 分组查询\r\n\r\n```mysql\r\n-- 标准语法\r\nSELECT 列名 FROM 表名 [WHERE 条件] GROUP BY 分组列名 [HAVING 分组后条件过滤] [ORDER BY 排序列名 排序方式];\r\n\r\n-- 按照品牌分组，获取每组商品的总金额\r\nSELECT brand,SUM(price) FROM product GROUP BY brand;\r\n\r\n-- 对金额大于4000元的商品，按照品牌分组,获取每组商品的总金额\r\nSELECT brand,SUM(price) FROM product WHERE price > 4000 GROUP BY brand;\r\n\r\n-- 对金额大于4000元的商品，按照品牌分组，获取每组商品的总金额，只显示总金额大于7000元的\r\nSELECT brand,SUM(price) AS getSum FROM product WHERE price > 4000 GROUP BY brand HAVING getSum > 7000;\r\n\r\n-- 对金额大于4000元的商品，按照品牌分组，获取每组商品的总金额，只显示总金额大于7000元的、并按照总金额的降序排列\r\nSELECT brand,SUM(price) AS getSum FROM product WHERE price > 4000 GROUP BY brand HAVING getSum > 7000 ORDER BY getSum DESC;\r\n```\r\n\r\n- 分页查询\r\n\r\n```mysql\r\n-- 标准语法\r\nSELECT 列名 FROM 表名 [WHERE 条件] GROUP BY 分组列名 [HAVING 分组后条件过滤] [ORDER BY 排序列名 排序方式] LIMIT 开始索引,查询条数;\r\n-- 公式：开始索引 = (当前页码-1) * 每页显示的条数\r\n\r\n-- 每页显示2条数据\r\nSELECT * FROM product LIMIT 0,2;  -- 第一页 开始索引=(1-1) * 2\r\nSELECT * FROM product LIMIT 2,2;  -- 第二页 开始索引=(2-1) * 2\r\nSELECT * FROM product LIMIT 4,2;  -- 第三页 开始索引=(3-1) * 2\r\nSELECT * FROM product LIMIT 6,2;  -- 第四页 开始索引=(4-1) * 2\r\n```\r\n\r\n- 分页查询图解\r\n\r\n![05](./img/sql/mysql/MySQL基础-01-授课笔记.assets/05.png)\r\n\r\n### 四、约束\r\n\r\n#### 1.约束的概念和分类\r\n\r\n- 约束的概念\r\n  - 对表中的数据进行限定，保证数据的正确性、有效性、完整性！\r\n- 约束的分类\r\n\r\n| 约束                          | 说明           |\r\n| ----------------------------- | -------------- |\r\n| PRIMARY KEY                   | 主键约束       |\r\n| PRIMARY KEY AUTO_INCREMENT    | 主键、自动增长 |\r\n| UNIQUE                        | 唯一约束       |\r\n| NOT NULL                      | 非空约束       |\r\n| FOREIGN KEY                   | 外键约束       |\r\n| FOREIGN KEY ON UPDATE CASCADE | 外键级联更新   |\r\n| FOREIGN KEY ON DELETE CASCADE | 外键级联删除   |\r\n\r\n#### 2.主键约束\r\n\r\n- 主键约束特点\r\n  - 主键约束包含：非空和唯一两个功能\r\n  - 一张表只能有一个列作为主键\r\n  - 主键一般用于表中数据的唯一标识\r\n- 建表时添加主键约束\r\n\r\n```mysql\r\n-- 标准语法\r\nCREATE TABLE 表名(\r\n\t列名 数据类型 PRIMARY KEY,\r\n    列名 数据类型,\r\n    ...\r\n);\r\n\r\n-- 创建student表\r\nCREATE TABLE student(\r\n\tid INT PRIMARY KEY  -- 给id添加主键约束\r\n);\r\n\r\n-- 添加数据\r\nINSERT INTO student VALUES (1),(2);\r\n-- 主键默认唯一，添加重复数据，会报错\r\nINSERT INTO student VALUES (2);\r\n-- 主键默认非空，不能添加null的数据\r\nINSERT INTO student VALUES (NULL);\r\n\r\n-- 查询student表\r\nSELECT * FROM student;\r\n-- 查询student表详细\r\nDESC student;\r\n```\r\n\r\n- 删除主键\r\n\r\n```mysql\r\n-- 标准语法\r\nALTER TABLE 表名 DROP PRIMARY KEY;\r\n\r\n-- 删除主键\r\nALTER TABLE student DROP PRIMARY KEY;\r\n```\r\n\r\n- 建表后单独添加主键\r\n\r\n```mysql\r\n-- 标准语法\r\nALTER TABLE 表名 MODIFY 列名 数据类型 PRIMARY KEY;\r\n\r\n-- 添加主键\r\nALTER TABLE student MODIFY id INT PRIMARY KEY;\r\n```\r\n\r\n#### 3.主键自动增长约束\r\n\r\n- 建表时添加主键自增约束\r\n\r\n```mysql\r\n-- 标准语法\r\nCREATE TABLE 表名(\r\n\t列名 数据类型 PRIMARY KEY AUTO_INCREMENT,\r\n    列名 数据类型,\r\n    ...\r\n);\r\n\r\n-- 创建student2表\r\nCREATE TABLE student2(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT    -- 给id添加主键自增约束\r\n);\r\n\r\n-- 添加数据\r\nINSERT INTO student2 VALUES (1),(2);\r\n-- 添加null值，会自动增长\r\nINSERT INTO student2 VALUES (NULL),(NULL);\r\n\r\n-- 查询student2表\r\nSELECT * FROM student2;\r\n-- student2表详细\r\nDESC student2;\r\n```\r\n\r\n- 删除自动增长\r\n\r\n```mysql\r\n-- 标准语法\r\nALTER TABLE 表名 MODIFY 列名 数据类型;\r\n\r\n-- 删除自动增长\r\nALTER TABLE student2 MODIFY id INT;\r\n```\r\n\r\n- 建表后单独添加自动增长\r\n\r\n```mysql\r\n-- 标准语法\r\nALTER TABLE 表名 MODIFY 列名 数据类型 AUTO_INCREMENT;\r\n\r\n-- 添加自动增长\r\nALTER TABLE student2 MODIFY id INT AUTO_INCREMENT;\r\n```\r\n\r\n#### 4.唯一约束\r\n\r\n- 建表时添加唯一约束\r\n\r\n```mysql\r\n-- 标准语法\r\nCREATE TABLE 表名(\r\n\t列名 数据类型 UNIQUE,\r\n    列名 数据类型,\r\n    ...\r\n);\r\n\r\n-- 创建student3表\r\nCREATE TABLE student3(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\ttel VARCHAR(20) UNIQUE    -- 给tel列添加唯一约束\r\n);\r\n\r\n-- 添加数据\r\nINSERT INTO student3 VALUES (NULL,'18888888888'),(NULL,'18666666666');\r\n-- 添加重复数据，会报错\r\nINSERT INTO student3 VALUES (NULL,'18666666666');\r\n\r\n-- 查询student3数据表\r\nSELECT * FROM student3;\r\n-- student3表详细\r\nDESC student3;\r\n```\r\n\r\n- 删除唯一约束\r\n\r\n```mysql\r\n-- 标准语法\r\nALTER TABLE 表名 DROP INDEX 列名;\r\n\r\n-- 删除唯一约束\r\nALTER TABLE student3 DROP INDEX tel;\r\n```\r\n\r\n- 建表后单独添加唯一约束\r\n\r\n```mysql\r\n-- 标准语法\r\nALTER TABLE 表名 MODIFY 列名 数据类型 UNIQUE;\r\n\r\n-- 添加唯一约束\r\nALTER TABLE student3 MODIFY tel VARCHAR(20) UNIQUE;\r\n```\r\n\r\n#### 5.非空约束\r\n\r\n- 建表时添加非空约束\r\n\r\n```mysql\r\n-- 标准语法\r\nCREATE TABLE 表名(\r\n\t列名 数据类型 NOT NULL,\r\n    列名 数据类型,\r\n    ...\r\n);\r\n\r\n-- 创建student4表\r\nCREATE TABLE student4(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tNAME VARCHAR(20) NOT NULL    -- 给name添加非空约束\r\n);\r\n\r\n-- 添加数据\r\nINSERT INTO student4 VALUES (NULL,'张三'),(NULL,'李四');\r\n-- 添加null值，会报错\r\nINSERT INTO student4 VALUES (NULL,NULL);\r\n```\r\n\r\n- 删除非空约束\r\n\r\n```mysql\r\n-- 标准语法\r\nALTER TABLE 表名 MODIFY 列名 数据类型;\r\n\r\n-- 删除非空约束\r\nALTER TABLE student4 MODIFY NAME VARCHAR(20);\r\n```\r\n\r\n- 建表后单独添加非空约束\r\n\r\n  ```SQL\r\n  -- 标准语法\r\n  ALTER TABLE 表名 MODIFY 列名 数据类型 NOT NULL;\r\n  \r\n  -- 添加非空约束\r\n  ALTER TABLE student4 MODIFY NAME VARCHAR(20) NOT NULL;\r\n  ```\r\n\r\n  ",v={data:function(){return{MainComponent:B}}},k=v,f=Object(T["a"])(k,b,F,!1,null,"55c74377",null),H=f.exports,V=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},Y=[],P="\x3c!--\r\n * @Date           : 2021-04-10 22:51:38\r\n * @FilePath       : /jinnian-space/src/pages/sql/md/MySQL数据类型.md\r\n * @Description    : \r\n--\x3e\r\n# MySQL数据类型\r\n### 各数据类型及字节长度一览表：\r\n\r\n| 数据类型           | 字节长度 | 范围或用法                                                   |\r\n| ------------------ | -------- | ------------------------------------------------------------ |\r\n| Bit                | 1        | 无符号[0,255]，有符号[-128,127]，天缘博客备注：BIT和BOOL布尔型都占用1字节 |\r\n| TinyInt            | 1        | 整数[0,255]                                                  |\r\n| SmallInt           | 2        | 无符号[0,65535]，有符号[-32768,32767]                        |\r\n| MediumInt          | 3        | 无符号[0,2^24-1]，有符号[-2^23,2^23-1]]                      |\r\n| Int                | 4        | 无符号[0,2^32-1]，有符号[-2^31,2^31-1]                       |\r\n| BigInt             | 8        | 无符号[0,2^64-1]，有符号[-2^63 ,2^63 -1]                     |\r\n| Float(M,D)         | 4        | 单精度浮点数。天缘博客提醒这里的D是精度，如果D<=24则为默认的FLOAT，如果D>24则会自动被转换为DOUBLE型。 |\r\n| Double(M,D)        | 8        | 双精度浮点。                                                 |\r\n| Decimal(M,D)       | M+1或M+2 | 未打包的浮点数，用法类似于FLOAT和DOUBLE，天缘博客提醒您如果在ASP中使用到Decimal数据类型，直接从数据库读出来的Decimal可能需要先转换成Float或Double类型后再进行运算。 |\r\n| Date               | 3        | 以YYYY-MM-DD的格式显示，比如：2009-07-19                     |\r\n| Date Time          | 8        | 以YYYY-MM-DD HH:MM:SS的格式显示，比如：2009-07-19 11：22：30 |\r\n| TimeStamp          | 4        | 以YYYY-MM-DD的格式显示，比如：2009-07-19                     |\r\n| Time               | 3        | 以HH:MM:SS的格式显示。比如：11：22：30                       |\r\n| Year               | 1        | 以YYYY的格式显示。比如：2009                                 |\r\n| Char(M)            | M        | 定长字符串。                                                 |\r\n| VarChar(M)         | M        | 变长字符串，要求M<=255                                       |\r\n| Binary(M)          | M        | 类似Char的二进制存储，特点是插入定长不足补0                  |\r\n| VarBinary(M)       | M        | 类似VarChar的变长二进制存储，特点是定长不补0                 |\r\n| Tiny Text          | Max:255  | 大小写不敏感                                                 |\r\n| Text               | Max:64K  | 大小写不敏感                                                 |\r\n| Medium Text        | Max:16M  | 大小写不敏感                                                 |\r\n| Long Text          | Max:4G   | 大小写不敏感                                                 |\r\n| TinyBlob           | Max:255  | 大小写敏感                                                   |\r\n| Blob               | Max:64K  | 大小写敏感                                                   |\r\n| MediumBlob         | Max:16M  | 大小写敏感                                                   |\r\n| LongBlob           | Max:4G   | 大小写敏感                                                   |\r\n| Enum               | 1或2     | 最大可达65535个不同的枚举值                                  |\r\n| Set                | 可达8    | 最大可达64个不同的值                                         |\r\n| Geometry           |          |                                                              |\r\n| Point              |          |                                                              |\r\n| LineString         |          |                                                              |\r\n| Polygon            |          |                                                              |\r\n| MultiPoint         |          |                                                              |\r\n| MultiLineString    |          |                                                              |\r\n| MultiPolygon       |          |                                                              |\r\n| GeometryCollection |          |                                                              |\r\n\r\n",x={data:function(){return{MainComponent:P}}},Q=x,w=Object(T["a"])(Q,V,Y,!1,null,"92d89b9c",null),W=w.exports,G=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},K=[],j="# MySQL进阶-02-授课笔记\r\n\r\n### 一、约束\r\n\r\n#### 1.外键约束\r\n\r\n- 外键约束概念\r\n\r\n  - 让表和表之间产生关系，从而保证数据的准确性！\r\n\r\n- 建表时添加外键约束\r\n\r\n  - 为什么要有外键约束\r\n\r\n  ```mysql\r\n  -- 创建db2数据库\r\n  CREATE DATABASE db2;\r\n  -- 使用db2数据库\r\n  USE db2;\r\n  \r\n  -- 创建user用户表\r\n  CREATE TABLE USER(\r\n  \tid INT PRIMARY KEY AUTO_INCREMENT,    -- id\r\n  \tNAME VARCHAR(20) NOT NULL             -- 姓名\r\n  );\r\n  -- 添加用户数据\r\n  INSERT INTO USER VALUES (NULL,'张三'),(NULL,'李四'),(NULL,'王五');\r\n  \r\n  -- 创建orderlist订单表\r\n  CREATE TABLE orderlist(\r\n  \tid INT PRIMARY KEY AUTO_INCREMENT,    -- id\r\n  \tnumber VARCHAR(20) NOT NULL,          -- 订单编号\r\n  \tuid INT                               -- 订单所属用户\r\n  );\r\n  -- 添加订单数据\r\n  INSERT INTO orderlist VALUES (NULL,'hm001',1),(NULL,'hm002',1),\r\n  (NULL,'hm003',2),(NULL,'hm004',2),\r\n  (NULL,'hm005',3),(NULL,'hm006',3);\r\n  \r\n  -- 添加一个订单，但是没有所属用户。这合理吗？\r\n  INSERT INTO orderlist VALUES (NULL,'hm007',8);\r\n  -- 删除王五这个用户，但是订单表中王五还有很多个订单呢。这合理吗？\r\n  DELETE FROM USER WHERE NAME='王五';\r\n  \r\n  -- 所以我们需要添加外键约束，让两张表产生关系\r\n  ```\r\n\r\n  - 外键约束格式\r\n\r\n  ```mysql\r\n  CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主表主键列名)\r\n  ```\r\n\r\n  - 创建表添加外键约束\r\n\r\n  ```mysql\r\n  -- 创建user用户表\r\n  CREATE TABLE USER(\r\n  \tid INT PRIMARY KEY AUTO_INCREMENT,    -- id\r\n  \tNAME VARCHAR(20) NOT NULL             -- 姓名\r\n  );\r\n  -- 添加用户数据\r\n  INSERT INTO USER VALUES (NULL,'张三'),(NULL,'李四'),(NULL,'王五');\r\n  \r\n  -- 创建orderlist订单表\r\n  CREATE TABLE orderlist(\r\n  \tid INT PRIMARY KEY AUTO_INCREMENT,    -- id\r\n  \tnumber VARCHAR(20) NOT NULL,          -- 订单编号\r\n  \tuid INT,                              -- 订单所属用户\r\n  \tCONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id)   -- 添加外键约束\r\n  );\r\n  -- 添加订单数据\r\n  INSERT INTO orderlist VALUES (NULL,'hm001',1),(NULL,'hm002',1),\r\n  (NULL,'hm003',2),(NULL,'hm004',2),\r\n  (NULL,'hm005',3),(NULL,'hm006',3);\r\n  \r\n  -- 添加一个订单，但是没有所属用户。无法添加\r\n  INSERT INTO orderlist VALUES (NULL,'hm007',8);\r\n  -- 删除王五这个用户，但是订单表中王五还有很多个订单呢。无法删除\r\n  DELETE FROM USER WHERE NAME='王五';\r\n  ```\r\n\r\n- 删除外键约束\r\n\r\n```mysql\r\n-- 标准语法\r\nALTER TABLE 表名 DROP FOREIGN KEY 外键名;\r\n\r\n-- 删除外键\r\nALTER TABLE orderlist DROP FOREIGN KEY ou_fk1;\r\n```\r\n\r\n- 建表后添加外键约束\r\n\r\n```mysql\r\n-- 标准语法\r\nALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名);\r\n\r\n-- 添加外键约束\r\nALTER TABLE orderlist ADD CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id);\r\n```\r\n\r\n#### 2.外键的级联更新和级联删除(了解)\r\n\r\n- 什么是级联更新和级联删除\r\n  - 当我想把user用户表中的某个用户删掉，我希望该用户所有的订单也随之被删除\r\n  - 当我想把user用户表中的某个用户id修改，我希望订单表中该用户所属的订单用户编号也随之修改\r\n- 添加级联更新和级联删除\r\n\r\n```mysql\r\n-- 添加外键约束，同时添加级联更新  标准语法\r\nALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名) ON UPDATE CASCADE;\r\n\r\n-- 添加外键约束，同时添加级联删除  标准语法\r\nALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名) ON DELETE CASCADE;\r\n\r\n-- 添加外键约束，同时添加级联更新和级联删除  标准语法\r\nALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名) ON UPDATE CASCADE ON DELETE CASCADE;\r\n\r\n\r\n-- 删除外键约束\r\nALTER TABLE orderlist DROP FOREIGN KEY ou_fk1;\r\n\r\n-- 添加外键约束，同时添加级联更新和级联删除\r\nALTER TABLE orderlist ADD CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id) ON UPDATE CASCADE ON DELETE CASCADE;\r\n\r\n-- 将王五用户的id修改为5    订单表中的uid也随之被修改\r\nUPDATE USER SET id=5 WHERE id=3;\r\n\r\n-- 将王五用户删除     订单表中该用户所有订单也随之删除\r\nDELETE FROM USER WHERE id=5;\r\n```\r\n\r\n### 二、多表设计\r\n\r\n#### 1.一对一(了解)\r\n\r\n- 分析\r\n  - 人和身份证。一个人只有一个身份证，一个身份证只能对应一个人！\r\n- 实现原则\r\n  - 在任意一个表建立外键，去关联另外一个表的主键\r\n- SQL演示\r\n\r\n```mysql\r\n-- 创建db5数据库\r\nCREATE DATABASE db5;\r\n-- 使用db5数据库\r\nUSE db5;\r\n\r\n-- 创建person表\r\nCREATE TABLE person(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tNAME VARCHAR(20)\r\n);\r\n-- 添加数据\r\nINSERT INTO person VALUES (NULL,'张三'),(NULL,'李四');\r\n\r\n-- 创建card表\r\nCREATE TABLE card(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tnumber VARCHAR(50),\r\n\tpid INT UNIQUE,\r\n\tCONSTRAINT cp_fk1 FOREIGN KEY (pid) REFERENCES person(id) -- 添加外键\r\n);\r\n-- 添加数据\r\nINSERT INTO card VALUES (NULL,'12345',1),(NULL,'56789',2);\r\n```\r\n\r\n- 图解\r\n\r\n![01](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/01.png)\r\n\r\n#### 2.一对多\r\n\r\n- 分析\r\n  - 用户和订单。一个用户可以有多个订单！\r\n  - 商品分类和商品。一个分类下可以有多个商品！\r\n- 实现原则\r\n  - 在多的一方，建立外键约束，来关联一的一方主键\r\n- SQL演示\r\n\r\n```mysql\r\n/*\r\n\t用户和订单\r\n*/\r\n-- 创建user表\r\nCREATE TABLE USER(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tNAME VARCHAR(20)\r\n);\r\n-- 添加数据\r\nINSERT INTO USER VALUES (NULL,'张三'),(NULL,'李四');\r\n\r\n-- 创建orderlist表\r\nCREATE TABLE orderlist(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tnumber VARCHAR(20),\r\n\tuid INT,\r\n\tCONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id)  -- 添加外键约束\r\n);\r\n-- 添加数据\r\nINSERT INTO orderlist VALUES (NULL,'hm001',1),(NULL,'hm002',1),(NULL,'hm003',2),(NULL,'hm004',2);\r\n\r\n\r\n/*\r\n\t商品分类和商品\r\n*/\r\n-- 创建category表\r\nCREATE TABLE category(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tNAME VARCHAR(10)\r\n);\r\n-- 添加数据\r\nINSERT INTO category VALUES (NULL,'手机数码'),(NULL,'电脑办公');\r\n\r\n-- 创建product表\r\nCREATE TABLE product(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tNAME VARCHAR(30),\r\n\tcid INT,\r\n\tCONSTRAINT pc_fk1 FOREIGN KEY (cid) REFERENCES category(id)  -- 添加外键约束\r\n);\r\n-- 添加数据\r\nINSERT INTO product VALUES (NULL,'华为P30',1),(NULL,'小米note3',1),\r\n(NULL,'联想电脑',2),(NULL,'苹果电脑',2);\r\n```\r\n\r\n- 图解\r\n\r\n![02](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/02.png)\r\n\r\n#### 3.多对多\r\n\r\n- 分析\r\n  - 学生和课程。一个学生可以选择多个课程，一个课程也可以被多个学生选择！\r\n- 实现原则\r\n  - 需要借助第三张表中间表，中间表至少包含两个列，这两个列作为中间表的外键，分别关联两张表的主键\r\n- SQL演示\r\n\r\n```mysql\r\n-- 创建student表\r\nCREATE TABLE student(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tNAME VARCHAR(20)\r\n);\r\n-- 添加数据\r\nINSERT INTO student VALUES (NULL,'张三'),(NULL,'李四');\r\n\r\n-- 创建course表\r\nCREATE TABLE course(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tNAME VARCHAR(10)\r\n);\r\n-- 添加数据\r\nINSERT INTO course VALUES (NULL,'语文'),(NULL,'数学');\r\n\r\n-- 创建中间表\r\nCREATE TABLE stu_course(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tsid INT, -- 用于和student表的id进行外键关联\r\n\tcid INT, -- 用于和course表的id进行外键关联\r\n\tCONSTRAINT sc_fk1 FOREIGN KEY (sid) REFERENCES student(id), -- 添加外键约束\r\n\tCONSTRAINT sc_fk2 FOREIGN KEY (cid) REFERENCES course(id)   -- 添加外键约束\r\n);\r\n-- 添加数据\r\nINSERT INTO stu_course VALUES (NULL,1,1),(NULL,1,2),(NULL,2,1),(NULL,2,2);\r\n```\r\n\r\n- 图解\r\n\r\n![03](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/03.png)\r\n\r\n### 三、多表查询\r\n\r\n#### 1.多表查询-数据准备\r\n\r\n- SQL语句\r\n\r\n```mysql\r\n-- 创建db6数据库\r\nCREATE DATABASE db6;\r\n-- 使用db6数据库\r\nUSE db6;\r\n\r\n-- 创建user表\r\nCREATE TABLE USER(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\t-- 用户id\r\n\tNAME VARCHAR(20),\t\t\t        -- 用户姓名\r\n\tage INT                             -- 用户年龄\r\n);\r\n-- 添加数据\r\nINSERT INTO USER VALUES (1,'张三',23);\r\nINSERT INTO USER VALUES (2,'李四',24);\r\nINSERT INTO USER VALUES (3,'王五',25);\r\nINSERT INTO USER VALUES (4,'赵六',26);\r\n\r\n\r\n-- 订单表\r\nCREATE TABLE orderlist(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\t-- 订单id\r\n\tnumber VARCHAR(30),\t\t\t\t\t-- 订单编号\r\n\tuid INT,    -- 外键字段\r\n\tCONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id)\r\n);\r\n-- 添加数据\r\nINSERT INTO orderlist VALUES (1,'hm001',1);\r\nINSERT INTO orderlist VALUES (2,'hm002',1);\r\nINSERT INTO orderlist VALUES (3,'hm003',2);\r\nINSERT INTO orderlist VALUES (4,'hm004',2);\r\nINSERT INTO orderlist VALUES (5,'hm005',3);\r\nINSERT INTO orderlist VALUES (6,'hm006',3);\r\nINSERT INTO orderlist VALUES (7,'hm007',NULL);\r\n\r\n\r\n-- 商品分类表\r\nCREATE TABLE category(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,  -- 商品分类id\r\n\tNAME VARCHAR(10)                    -- 商品分类名称\r\n);\r\n-- 添加数据\r\nINSERT INTO category VALUES (1,'手机数码');\r\nINSERT INTO category VALUES (2,'电脑办公');\r\nINSERT INTO category VALUES (3,'烟酒茶糖');\r\nINSERT INTO category VALUES (4,'鞋靴箱包');\r\n\r\n\r\n-- 商品表\r\nCREATE TABLE product(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,   -- 商品id\r\n\tNAME VARCHAR(30),                    -- 商品名称\r\n\tcid INT, -- 外键字段\r\n\tCONSTRAINT cp_fk1 FOREIGN KEY (cid) REFERENCES category(id)\r\n);\r\n-- 添加数据\r\nINSERT INTO product VALUES (1,'华为手机',1);\r\nINSERT INTO product VALUES (2,'小米手机',1);\r\nINSERT INTO product VALUES (3,'联想电脑',2);\r\nINSERT INTO product VALUES (4,'苹果电脑',2);\r\nINSERT INTO product VALUES (5,'中华香烟',3);\r\nINSERT INTO product VALUES (6,'玉溪香烟',3);\r\nINSERT INTO product VALUES (7,'计生用品',NULL);\r\n\r\n\r\n-- 中间表\r\nCREATE TABLE us_pro(\r\n\tupid INT PRIMARY KEY AUTO_INCREMENT,  -- 中间表id\r\n\tuid INT, -- 外键字段。需要和用户表的主键产生关联\r\n\tpid INT, -- 外键字段。需要和商品表的主键产生关联\r\n\tCONSTRAINT up_fk1 FOREIGN KEY (uid) REFERENCES USER(id),\r\n\tCONSTRAINT up_fk2 FOREIGN KEY (pid) REFERENCES product(id)\r\n);\r\n-- 添加数据\r\nINSERT INTO us_pro VALUES (NULL,1,1);\r\nINSERT INTO us_pro VALUES (NULL,1,2);\r\nINSERT INTO us_pro VALUES (NULL,1,3);\r\nINSERT INTO us_pro VALUES (NULL,1,4);\r\nINSERT INTO us_pro VALUES (NULL,1,5);\r\nINSERT INTO us_pro VALUES (NULL,1,6);\r\nINSERT INTO us_pro VALUES (NULL,1,7);\r\nINSERT INTO us_pro VALUES (NULL,2,1);\r\nINSERT INTO us_pro VALUES (NULL,2,2);\r\nINSERT INTO us_pro VALUES (NULL,2,3);\r\nINSERT INTO us_pro VALUES (NULL,2,4);\r\nINSERT INTO us_pro VALUES (NULL,2,5);\r\nINSERT INTO us_pro VALUES (NULL,2,6);\r\nINSERT INTO us_pro VALUES (NULL,2,7);\r\nINSERT INTO us_pro VALUES (NULL,3,1);\r\nINSERT INTO us_pro VALUES (NULL,3,2);\r\nINSERT INTO us_pro VALUES (NULL,3,3);\r\nINSERT INTO us_pro VALUES (NULL,3,4);\r\nINSERT INTO us_pro VALUES (NULL,3,5);\r\nINSERT INTO us_pro VALUES (NULL,3,6);\r\nINSERT INTO us_pro VALUES (NULL,3,7);\r\nINSERT INTO us_pro VALUES (NULL,4,1);\r\nINSERT INTO us_pro VALUES (NULL,4,2);\r\nINSERT INTO us_pro VALUES (NULL,4,3);\r\nINSERT INTO us_pro VALUES (NULL,4,4);\r\nINSERT INTO us_pro VALUES (NULL,4,5);\r\nINSERT INTO us_pro VALUES (NULL,4,6);\r\nINSERT INTO us_pro VALUES (NULL,4,7);\r\n```\r\n\r\n- 架构器图解\r\n\r\n![04](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/04.png)\r\n\r\n#### 2.多表查询-笛卡尔积查询(了解)\r\n\r\n- 有两张表，获取这两个表的所有组合情况\r\n- 要完成多表查询，需要消除这些没有用的数据\r\n- 多表查询格式\r\n\r\n```mysql\r\nSELECT\r\n\t列名列表\r\nFROM\r\n\t表名列表\r\nWHERE\r\n\t条件...\r\n```\r\n\r\n- 笛卡尔积查询\r\n\r\n```mysql\r\n-- 标准语法\r\nSELECT 列名 FROM 表名1,表名2,...;\r\n\r\n-- 查询user表和orderlist表\r\nSELECT * FROM USER,orderlist;\r\n```\r\n\r\n#### 3.多表查询-内连接查询\r\n\r\n- 查询原理\r\n  - 内连接查询的是两张表有交集的部分数据(有主外键关联的数据)\r\n- 显式内连接\r\n\r\n```mysql\r\n-- 标准语法\r\nSELECT 列名 FROM 表名1 [INNER] JOIN 表名2 ON 条件;\r\n\r\n-- 查询用户信息和对应的订单信息\r\nSELECT * FROM USER INNER JOIN orderlist ON user.id=orderlist.uid;\r\nSELECT * FROM USER JOIN orderlist ON user.id=orderlist.uid;\r\n\r\n-- 查询用户信息和对应的订单信息，起别名\r\nSELECT * FROM USER u JOIN orderlist o ON u.id=o.uid;\r\n\r\n-- 查询用户姓名，年龄。和订单编号\r\nSELECT\r\n\tu.`name`,\t-- 姓名\r\n\tu.`age`,\t-- 年龄\r\n\to.`number`\t-- 订单编号\r\nFROM\r\n\tUSER u          -- 用户表\r\nJOIN\r\n\torderlist o     -- 订单表\r\nON \r\n\tu.`id` = o.`uid`;\r\n```\r\n\r\n- 隐式内连接\r\n\r\n```mysql\r\n-- 标准语法\r\nSELECT 列名 FROM 表名1,表名2 WHERE 条件;\r\n\r\n-- 查询用户姓名，年龄。和订单编号\r\nSELECT\r\n\tu.`name`,\t-- 姓名\r\n\tu.`age`,\t-- 年龄\r\n\to.`number`\t-- 订单编号\r\nFROM\r\n\tUSER u,\t\t-- 用户表\r\n\torderlist o     -- 订单表\r\nWHERE\r\n\tu.`id`=o.`uid`;\r\n```\r\n\r\n#### 4.多表查询-外连接查询\r\n\r\n- 左外连接\r\n\r\n  - 查询原理\r\n    - 查询左表的全部数据，和左右两张表有交集部分的数据\r\n  - 基本演示\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SELECT 列名 FROM 表名1 LEFT [OUTER] JOIN 表名2 ON 条件;\r\n  \r\n  -- 查询所有用户信息，以及用户对应的订单信息\r\n  SELECT\r\n  \tu.`name`,\t-- 姓名\r\n  \tu.`age`,\t-- 年龄\r\n  \to.`number`\t-- 订单编号\r\n  FROM\r\n  \tUSER u          -- 用户表\r\n  LEFT OUTER JOIN\r\n  \torderlist o     -- 订单表\r\n  ON\r\n  \tu.`id`=o.`uid`;\r\n  ```\r\n\r\n- 右外连接\r\n\r\n  - 查询原理\r\n    - 查询右表的全部数据，和左右两张表有交集部分的数据\r\n  - 基本演示\r\n\r\n  ```mysql\r\n  -- 基本语法\r\n  SELECT 列名 FROM 表名1 RIGHT [OUTER] JOIN 表名2 ON 条件;\r\n  \r\n  -- 查询所有订单信息，以及订单所属的用户信息\r\n  SELECT\r\n  \tu.`name`,\t-- 姓名\r\n  \tu.`age`,\t-- 年龄\r\n  \to.`number`\t-- 订单编号\r\n  FROM\r\n  \tUSER u          -- 用户表\r\n  RIGHT OUTER JOIN\r\n  \torderlist o     -- 订单表\r\n  ON\r\n  \tu.`id`=o.`uid`;\r\n  ```\r\n\r\n#### 5.多表查询-子查询\r\n\r\n- 子查询介绍\r\n\r\n  - 查询语句中嵌套了查询语句。我们就将嵌套查询称为子查询！\r\n\r\n- 子查询-结果是单行单列的\r\n\r\n  - 可以作为条件，使用运算符进行判断！\r\n  - 基本演示\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SELECT 列名 FROM 表名 WHERE 列名=(SELECT 聚合函数(列名) FROM 表名 [WHERE 条件]);\r\n  \r\n  -- 查询年龄最高的用户姓名\r\n  SELECT MAX(age) FROM USER;              -- 查询出最高年龄\r\n  SELECT NAME,age FROM USER WHERE age=26; -- 根据查询出来的最高年龄，查询姓名和年龄\r\n  SELECT NAME,age FROM USER WHERE age = (SELECT MAX(age) FROM USER);\r\n  ```\r\n\r\n- 子查询-结果是多行单列的\r\n\r\n  - 可以作为条件，使用运算符in或not in进行判断！\r\n  - 基本演示\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SELECT 列名 FROM 表名 WHERE 列名 [NOT] IN (SELECT 列名 FROM 表名 [WHERE 条件]); \r\n  \r\n  -- 查询张三和李四的订单信息\r\n  SELECT id FROM USER WHERE NAME='张三' OR NAME='李四';   -- 查询张三和李四用户的id\r\n  SELECT number,uid FROM orderlist WHERE uid=1 OR uid=2; -- 根据id查询订单\r\n  SELECT number,uid FROM orderlist WHERE uid IN (SELECT id FROM USER WHERE NAME='张三' OR NAME='李四');\r\n  ```\r\n\r\n- 子查询-结果是多行多列的\r\n\r\n  - 可以作为一张虚拟表参与查询！\r\n  - 基本演示\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SELECT 列名 FROM 表名 [别名],(SELECT 列名 FROM 表名 [WHERE 条件]) [别名] [WHERE 条件];\r\n  \r\n  -- 查询订单表中id大于4的订单信息和所属用户信息\r\n  SELECT * FROM USER u,(SELECT * FROM orderlist WHERE id>4) o WHERE u.id=o.uid;\r\n  ```\r\n\r\n#### 6.多表查询练习\r\n\r\n- 查询用户的编号、姓名、年龄。订单编号\r\n\r\n```mysql\r\n/*\r\n分析：\r\n\t用户的编号、姓名、年龄  user表     订单编号 orderlist表\r\n\t条件：user.id = orderlist.uid\r\n*/\r\nSELECT\r\n\tt1.`id`,\t-- 用户编号\r\n\tt1.`name`,\t-- 用户姓名\r\n\tt1.`age`,\t-- 用户年龄\r\n\tt2.`number`\t-- 订单编号\r\nFROM\r\n\tUSER t1,       -- 用户表\r\n\torderlist t2   -- 订单表\r\nWHERE\r\n\tt1.`id` = t2.`uid`;\r\n```\r\n\r\n- 查询所有的用户。用户的编号、姓名、年龄。订单编号\r\n\r\n```mysql\r\n/*\r\n分析：\r\n\t用户的编号、姓名、年龄 user表     订单编号 orderlist表\r\n\t条件：user.id = orderlist.uid\r\n\t查询所有用户，使用左外连接\r\n*/\r\nSELECT\r\n\tt1.`id`,\t-- 用户编号\r\n\tt1.`name`,\t-- 用户姓名\r\n\tt1.`age`,\t-- 用户年龄\r\n\tt2.`number`\t-- 订单编号\r\nFROM\r\n\tUSER t1        -- 用户表\r\nLEFT OUTER JOIN\r\n\torderlist t2   -- 订单表\r\nON\r\n\tt1.`id` = t2.`uid`;\r\n```\r\n\r\n- 查询所有的订单。用户的编号、姓名、年龄。订单编号\r\n\r\n```mysql\r\n/*\r\n分析：\r\n\t用户的编号、姓名、年龄 user表     订单编号 orderlist表\r\n\t条件：user.id = orderlist.uid\r\n\t查询所有订单，使用右外连接\r\n*/\r\nSELECT\r\n\tt1.`id`,\t-- 用户编号\r\n\tt1.`name`,\t-- 用户姓名\r\n\tt1.`age`,\t-- 用户年龄\r\n\tt2.`number`\t-- 订单编号\r\nFROM\r\n\tUSER t1         -- 用户表\r\nRIGHT OUTER JOIN\r\n\torderlist t2    -- 订单表\r\nON\r\n\tt1.`id` = t2.`uid`;\r\n```\r\n\r\n- 查询用户年龄大于23岁的信息。显示用户的编号、姓名、年龄。订单编号\r\n\r\n```mysql\r\n/*\r\n分析：\r\n\t用户的编号、姓名、年龄 user表     订单编号 orderlist表\r\n\t条件：user.age > 23 AND user.id = orderlist.uid\r\n*/\r\n/*\r\nselect\r\n\tt1.`id`,\t-- 用户编号\r\n\tt1.`name`,\t-- 用户姓名\r\n\tt1.`age`,\t-- 用户年龄\r\n\tt2.`number`\t-- 订单编号\r\nfrom\r\n\tuser t1,     -- 用户表\r\n\torderlist t2 -- 订单表\r\nwhere\r\n\tt1.`age` > 23\r\n\tand\r\n\tt1.`id` = t2.`uid`;\r\n*/\r\nSELECT\r\n\tt1.`id`,\t-- 用户编号\r\n\tt1.`name`,\t-- 用户姓名\r\n\tt1.`age`,\t-- 用户年龄\r\n\tt2.`number`\t-- 订单编号\r\nFROM\r\n\tUSER t1       -- 用户表\r\nLEFT OUTER JOIN\r\n\torderlist t2  -- 订单表\r\nON\r\n\tt1.`id` = t2.`uid`\r\nWHERE\r\n\tt1.`age` > 23;\r\n```\r\n\r\n- 查询张三和李四用户的信息。显示用户的编号、姓名、年龄。订单编号\r\n\r\n```mysql\r\n/*\r\n分析：\r\n\t用户的编号、姓名、年龄 user表     订单编号 orderlist表\r\n\t条件：user.id = orderlist.uid AND user.name IN ('张三','李四');\r\n*/\r\nSELECT\r\n\tt1.`id`,\t-- 用户编号\r\n\tt1.`name`,\t-- 用户姓名\r\n\tt1.`age`,\t-- 用户年龄\r\n\tt2.`number`\t-- 订单编号\r\nFROM\r\n\tUSER t1,        -- 用户表\r\n\torderlist t2    -- 订单表\r\nWHERE\r\n\tt1.`id` = t2.`uid`\r\n\tAND\r\n\t-- (t1.`name` = '张三' OR t1.`name` = '李四');\r\n\tt1.`name` IN ('张三','李四');\r\n```\r\n\r\n- 查询商品分类的编号、分类名称。分类下的商品名称\r\n\r\n```mysql\r\n/*\r\n分析：\r\n\t商品分类的编号、分类名称 category表     分类下的商品名称 product表\r\n\t条件：category.id = product.cid\r\n*/\r\nSELECT\r\n\tt1.`id`,\t-- 分类编号\r\n\tt1.`name`,\t-- 分类名称\r\n\tt2.`name`\t-- 商品名称\r\nFROM\r\n\tcategory t1,\t-- 商品分类表\r\n\tproduct t2\t    -- 商品表\r\nWHERE\r\n\tt1.`id` = t2.`cid`;\r\n```\r\n\r\n- 查询所有的商品分类。商品分类的编号、分类名称。分类下的商品名称\r\n\r\n```mysql\r\n/*\r\n分析：\r\n\t商品分类的编号、分类名称 category表     分类下的商品名称 product表\r\n\t条件：category.id = product.cid\r\n\t查询所有的商品分类，使用左外连接\r\n*/\r\nSELECT\r\n\tt1.`id`,\t-- 分类编号\r\n\tt1.`name`,\t-- 分类名称\r\n\tt2.`name`\t-- 商品名称\r\nFROM\r\n\tcategory t1\t-- 商品分类表\r\nLEFT OUTER JOIN\r\n\tproduct t2\t-- 商品表\r\nON\r\n\tt1.`id` = t2.`cid`;\r\n```\r\n\r\n- 查询所有的商品信息。商品分类的编号、分类名称。分类下的商品名称\r\n\r\n```mysql\r\n/*\r\n分析：\r\n\t商品分类的编号、分类名称 category表     分类下的商品名称 product表\r\n\t条件：category.id = product.cid\r\n\t查询所有的商品信息，使用右外连接\r\n*/\r\nSELECT\r\n\tt1.`id`,\t-- 分类编号\r\n\tt1.`name`,\t-- 分类名称\r\n\tt2.`name`\t-- 商品名称\r\nFROM\r\n\tcategory t1\t-- 商品分类表\r\nRIGHT OUTER JOIN\r\n\tproduct t2\t-- 商品表\r\nON\r\n\tt1.`id` = t2.`cid`;\r\n```\r\n\r\n- 查询所有的用户和所有的商品。显示用户的编号、姓名、年龄。商品名称\r\n\r\n```mysql\r\n/*\r\n分析：\r\n\t用户的编号、姓名、年龄 user表   商品名称 product表   中间表 us_pro\r\n\t条件：us_pro.uid = user.id AND us_pro.pid = product.id\r\n*/\r\nSELECT\r\n\tt1.`id`,\t-- 用户编号\r\n\tt1.`name`,\t-- 用户名称\r\n\tt1.`age`,\t-- 用户年龄\r\n\tt2.`name`\t-- 商品名称\r\nFROM\r\n\tUSER t1,\t-- 用户表\r\n\tproduct t2,\t-- 商品表\r\n\tus_pro t3\t-- 中间表\r\nWHERE\r\n\tt3.`uid` = t1.`id`\r\n\tAND\r\n\tt3.`pid` = t2.`id`;\r\n```\r\n\r\n- 查询张三和李四这两个用户可以看到的商品。显示用户的编号、姓名、年龄。商品名称\r\n\r\n```mysql\r\n/*\r\n分析：\r\n\t用户的编号、姓名、年龄 user表   商品名称 product表   中间表 us_pro\r\n\t条件：us_pro.uid = user.id AND us_pro.pid = product.id AND user.name IN ('张三','李四')\r\n*/\r\nSELECT\r\n\tt1.`id`,\t-- 用户编号\r\n\tt1.`name`,\t-- 用户名称\r\n\tt1.`age`,\t-- 用户年龄\r\n\tt2.`name`\t-- 商品名称\r\nFROM\r\n\tUSER t1,\t-- 用户表\r\n\tproduct t2,\t-- 商品表\r\n\tus_pro t3\t-- 中间表\r\nWHERE\r\n\t(t3.`uid` = t1.`id` AND t3.`pid` = t2.`id`)\r\n\tAND\r\n\t-- (t1.`name` = '张三' or t1.`name` = '李四');\r\n\tt1.`name` IN ('张三','李四');\r\n```\r\n\r\n#### 7.多表查询-自关联查询\r\n\r\n- 自关联查询介绍\r\n  - 同一张表中有数据关联。可以多次查询这同一个表！\r\n- 自关联查询演示\r\n\r\n```mysql\r\n-- 创建员工表\r\nCREATE TABLE employee(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tNAME VARCHAR(20),\r\n\tmgr INT,\r\n\tsalary DOUBLE\r\n);\r\n-- 添加数据\r\nINSERT INTO employee VALUES (1001,'孙悟空',1005,9000.00),\r\n(1002,'猪八戒',1005,8000.00),\r\n(1003,'沙和尚',1005,8500.00),\r\n(1004,'小白龙',1005,7900.00),\r\n(1005,'唐僧',NULL,15000.00),\r\n(1006,'武松',1009,7600.00),\r\n(1007,'李逵',1009,7400.00),\r\n(1008,'林冲',1009,8100.00),\r\n(1009,'宋江',NULL,16000.00);\r\n\r\n-- 查询所有员工的姓名及其直接上级的姓名，没有上级的员工也需要查询\r\n/*\r\n分析：\r\n\t员工姓名 employee表        直接上级姓名 employee表\r\n\t条件：employee.mgr = employee.id\r\n\t查询左表的全部数据，和左右两张表交集部分数据，使用左外连接\r\n*/\r\nSELECT\r\n\tt1.name,\t-- 员工姓名\r\n\tt1.mgr,\t\t-- 上级编号\r\n\tt2.id,\t\t-- 员工编号\r\n\tt2.name     -- 员工姓名\r\nFROM\r\n\temployee t1  -- 员工表\r\nLEFT OUTER JOIN\r\n\temployee t2  -- 员工表\r\nON\r\n\tt1.mgr = t2.id;\r\n```\r\n\r\n### 四、视图\r\n\r\n#### 1.视图的概念\r\n\r\n- 视图是一种虚拟存在的数据表\r\n- 这个虚拟的表并不在数据库中实际存在\r\n- 作用是将一些比较复杂的查询语句的结果，封装到一个虚拟表中。后期再有相同复杂查询时，直接查询这张虚拟表即可\r\n- 说白了，视图就是将一条SELECT查询语句的结果封装到了一个虚拟表中，所以我们在创建视图的时候，工作重心就要放在这条SELECT查询语句上\r\n\r\n#### 2.视图的好处\r\n\r\n- 简单\r\n  - 对于使用视图的用户不需要关心表的结构、关联条件和筛选条件。因为这张虚拟表中保存的就是已经过滤好条件的结果集\r\n- 安全\r\n  - 视图可以设置权限 , 致使访问视图的用户只能访问他们被允许查询的结果集\r\n- 数据独立\r\n  - 一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响\r\n\r\n#### 3.视图数据准备\r\n\r\n```mysql\r\n-- 创建db7数据库\r\nCREATE DATABASE db7;\r\n\r\n-- 使用db7数据库\r\nUSE db7;\r\n\r\n-- 创建country表\r\nCREATE TABLE country(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tcountry_name VARCHAR(30)\r\n);\r\n-- 添加数据\r\nINSERT INTO country VALUES (NULL,'中国'),(NULL,'美国'),(NULL,'俄罗斯');\r\n\r\n-- 创建city表\r\nCREATE TABLE city(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tcity_name VARCHAR(30),\r\n\tcid INT, -- 外键列。关联country表的主键列id\r\n\tCONSTRAINT cc_fk1 FOREIGN KEY (cid) REFERENCES country(id)\r\n);\r\n-- 添加数据\r\nINSERT INTO city VALUES (NULL,'北京',1),(NULL,'上海',1),(NULL,'纽约',2),(NULL,'莫斯科',3);\r\n```\r\n\r\n#### 4.视图的创建\r\n\r\n- 创建视图语法\r\n\r\n```mysql\r\n-- 标准语法\r\nCREATE VIEW 视图名称 [(列名列表)] AS 查询语句;\r\n```\r\n\r\n- 普通多表查询，查询城市和所属国家\r\n\r\n```mysql\r\n-- 普通多表查询，查询城市和所属国家\r\nSELECT\r\n\tt1.*,\r\n\tt2.country_name\r\nFROM\r\n\tcity t1,\r\n\tcountry t2\r\nWHERE\r\n\tt1.cid = t2.id;\r\n\t\r\n-- 经常需要查询这样的数据，就可以创建一个视图\r\n```\r\n\r\n- 创建视图基本演示\r\n\r\n```mysql\r\n-- 创建一个视图。将查询出来的结果保存到这张虚拟表中\r\nCREATE\r\nVIEW\r\n\tcity_country\r\nAS\r\n\tSELECT t1.*,t2.country_name FROM city t1,country t2 WHERE t1.cid=t2.id;\r\n```\r\n\r\n- 创建视图并指定列名基本演示\r\n\r\n```mysql\r\n-- 创建一个视图，指定列名。将查询出来的结果保存到这张虚拟表中\r\nCREATE\r\nVIEW\r\n\tcity_country2 (city_id,city_name,cid,country_name) \r\nAS\r\n\tSELECT t1.*,t2.country_name FROM city t1,country t2 WHERE t1.cid=t2.id;\r\n\r\n```\r\n\r\n#### 5.视图的查询\r\n\r\n- 查询视图语法\r\n\r\n```mysql\r\n-- 标准语法\r\nSELECT * FROM 视图名称;\r\n```\r\n\r\n- 查询视图基本演示\r\n\r\n```mysql\r\n-- 查询视图。查询这张虚拟表，就等效于查询城市和所属国家\r\nSELECT * FROM city_country;\r\n\r\n-- 查询指定列名的视图\r\nSELECT * FROM city_country2;\r\n\r\n-- 查询所有数据表，视图也会查询出来\r\nSHOW TABLES;\r\n```\r\n\r\n- 查询视图创建语法\r\n\r\n```mysql\r\n-- 标准语法\r\nSHOW CREATE VIEW 视图名称;\r\n```\r\n\r\n- 查询视图创建语句基本演示\r\n\r\n```mysql\r\nSHOW CREATE VIEW city_country;\r\n```\r\n\r\n#### 6.视图的修改\r\n\r\n- 修改视图表中的数据\r\n\r\n```mysql\r\n-- 标准语法\r\nUPDATE 视图名称 SET 列名=值 WHERE 条件;\r\n\r\n-- 修改视图表中的城市名称北京为北京市\r\nUPDATE city_country SET city_name='北京市' WHERE city_name='北京';\r\n\r\n-- 查询视图\r\nSELECT * FROM city_country;\r\n\r\n-- 查询city表,北京也修改为了北京市\r\nSELECT * FROM city;\r\n\r\n-- 注意：视图表数据修改，会自动修改源表中的数据\r\n```\r\n\r\n- 修改视图表结构\r\n\r\n```mysql\r\n-- 标准语法\r\nALTER VIEW 视图名称 [(列名列表)] AS 查询语句;\r\n\r\n-- 查询视图2\r\nSELECT * FROM city_country2;\r\n\r\n-- 修改视图2的列名city_id为id\r\nALTER\r\nVIEW\r\n\tcity_country2 (id,city_name,cid,country_name)\r\nAS\r\n\tSELECT t1.*,t2.country_name FROM city t1,country t2 WHERE t1.cid=t2.id;\r\n```\r\n\r\n#### 7.视图的删除\r\n\r\n- 删除视图\r\n\r\n```mysql\r\n-- 标准语法\r\nDROP VIEW [IF EXISTS] 视图名称;\r\n\r\n-- 删除视图\r\nDROP VIEW city_country;\r\n\r\n-- 删除视图2，如果存在则删除\r\nDROP VIEW IF EXISTS city_country2;\r\n```\r\n\r\n#### 8.视图的总结\r\n\r\n- 视图是一种虚拟存在的数据表\r\n- 这个虚拟的表并不在数据库中实际存在\r\n- 说白了，视图就是将一条SELECT查询语句的结果封装到了一个虚拟表中，所以我们在创建视图的时候，工作重心就要放在这条SELECT查询语句上\r\n- 视图的好处\r\n  - 简单\r\n  - 安全\r\n  - 数据独立\r\n\r\n### 五、备份与还原\r\n\r\n#### 1.命令行方式\r\n\r\n- 备份\r\n\r\n  - 使用SecureCRT工具连接到Linux系统，输入：mysqldump -u root -p 数据库名称 > 文件保存路径\r\n\r\n  ![12](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/12.png)\r\n\r\n  - 进入文件保存路径，查看文件是否存在\r\n\r\n  ![13](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/13.png)\r\n\r\n  ![14](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/14.png)\r\n\r\n- 恢复\r\n\r\n  - 登录mysql数据库\r\n\r\n  ![15](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/15.png)\r\n\r\n  - 删除已经备份的数据库\r\n\r\n  ![16](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/16.png)\r\n\r\n  - 重新创建名称相同的数据库\r\n\r\n  ![17](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/17.png)\r\n\r\n  - 使用该数据库\r\n\r\n  ![18](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/18.png)\r\n\r\n  - 导入文件执行：source 备份文件路径;\r\n\r\n  ![19](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/19.png)\r\n\r\n#### 2.图形化界面方式\r\n\r\n- 备份\r\n\r\n![05](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/05.png)\r\n\r\n![06](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/06.png)\r\n\r\n![07](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/07.png)\r\n\r\n- 恢复\r\n\r\n![08](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/08.png)\r\n\r\n![09](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/09.png)\r\n\r\n![10](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/10.png)\r\n\r\n![11](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/11.png)\r\n\r\n",$={data:function(){return{MainComponent:j}}},J=$,X=Object(T["a"])(J,G,K,!1,null,"4e40c8a8",null),z=X.exports,Z=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},nn=[],rn="# MySQL高级-03-授课笔记\r\n\r\n### 一、MySQL存储过程和函数\r\n\r\n#### 1.存储过程和函数的概念\r\n\r\n- 存储过程和函数是  事先经过编译并存储在数据库中的一段 SQL 语句的集合\r\n\r\n#### 2.存储过程和函数的好处\r\n\r\n- 存储过程和函数可以重复使用，减轻开发人员的工作量。类似于java中方法可以多次调用\r\n- 减少网络流量，存储过程和函数位于服务器上，调用的时候只需要传递名称和参数即可\r\n- 减少数据在数据库和应用服务器之间的传输，可以提高数据处理的效率\r\n- 将一些业务逻辑在数据库层面来实现，可以减少代码层面的业务处理\r\n\r\n#### 3.存储过程和函数的区别\r\n\r\n- 函数必须有返回值\r\n- 存储过程没有返回值\r\n\r\n#### 4.创建存储过程\r\n\r\n- 小知识\r\n\r\n```mysql\r\n/*\r\n\t该关键字用来声明sql语句的分隔符，告诉MySQL该段命令已经结束！\r\n\tsql语句默认的分隔符是分号，但是有的时候我们需要一条功能sql语句中包含分号，但是并不作为结束标识。\r\n\t这个时候就可以使用DELIMITER来指定分隔符了！\r\n*/\r\n-- 标准语法\r\nDELIMITER 分隔符\r\n```\r\n\r\n- 数据准备\r\n\r\n```mysql\r\n-- 创建db8数据库\r\nCREATE DATABASE db8;\r\n\r\n-- 使用db8数据库\r\nUSE db8;\r\n\r\n-- 创建学生表\r\nCREATE TABLE student(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\t-- 学生id\r\n\tNAME VARCHAR(20),\t\t\t\t\t-- 学生姓名\r\n\tage INT,\t\t\t\t\t\t\t-- 学生年龄\r\n\tgender VARCHAR(5),\t\t\t\t\t-- 学生性别\r\n\tscore INT                           -- 学生成绩\r\n);\r\n-- 添加数据\r\nINSERT INTO student VALUES (NULL,'张三',23,'男',95),(NULL,'李四',24,'男',98),\r\n(NULL,'王五',25,'女',100),(NULL,'赵六',26,'女',90);\r\n\r\n-- 按照性别进行分组，查询每组学生的总成绩。按照总成绩的升序排序\r\nSELECT gender,SUM(score) getSum FROM student GROUP BY gender ORDER BY getSum ASC;\r\n```\r\n\r\n- 创建存储过程语法\r\n\r\n```mysql\r\n-- 修改分隔符为$\r\nDELIMITER $\r\n\r\n-- 标准语法\r\nCREATE PROCEDURE 存储过程名称(参数...)\r\nBEGIN\r\n\tsql语句;\r\nEND$\r\n\r\n-- 修改分隔符为分号\r\nDELIMITER ;\r\n```\r\n\r\n- 创建存储过程\r\n\r\n```mysql\r\n-- 修改分隔符为$\r\nDELIMITER $\r\n\r\n-- 创建存储过程，封装分组查询学生总成绩的sql语句\r\nCREATE PROCEDURE stu_group()\r\nBEGIN\r\n\tSELECT gender,SUM(score) getSum FROM student GROUP BY gender ORDER BY getSum ASC;\r\nEND$\r\n\r\n-- 修改分隔符为分号\r\nDELIMITER ;\r\n```\r\n\r\n#### 5.调用存储过程\r\n\r\n- 调用存储过程语法\r\n\r\n```mysql\r\n-- 标准语法\r\nCALL 存储过程名称(实际参数);\r\n\r\n-- 调用stu_group存储过程\r\nCALL stu_group();\r\n```\r\n\r\n#### 6.查看存储过程\r\n\r\n- 查看存储过程语法\r\n\r\n```mysql\r\n-- 查询数据库中所有的存储过程 标准语法\r\nSELECT * FROM mysql.proc WHERE db='数据库名称';\r\n```\r\n\r\n#### 7.删除存储过程\r\n\r\n- 删除存储过程语法\r\n\r\n```mysql\r\n-- 标准语法\r\nDROP PROCEDURE [IF EXISTS] 存储过程名称;\r\n\r\n-- 删除stu_group存储过程\r\nDROP PROCEDURE stu_group;\r\n```\r\n\r\n#### 8.存储过程语法\r\n\r\n##### 8.1存储过程语法介绍\r\n\r\n- 存储过程是可以进行编程的。意味着可以使用变量、表达式、条件控制语句、循环语句等，来完成比较复杂的功能！\r\n\r\n##### 8.2变量的使用\r\n\r\n- 定义变量\r\n\r\n```mysql\r\n-- 标准语法\r\nDECLARE 变量名 数据类型 [DEFAULT 默认值];\r\n-- 注意： DECLARE定义的是局部变量，只能用在BEGIN END范围之内\r\n\r\n-- 定义一个int类型变量、并赋默认值为10\r\nDELIMITER $\r\n\r\nCREATE PROCEDURE pro_test1()\r\nBEGIN\r\n\tDECLARE num INT DEFAULT 10;   -- 定义变量\r\n\tSELECT num;                   -- 查询变量\r\nEND$\r\n\r\nDELIMITER ;\r\n\r\n-- 调用pro_test1存储过程\r\nCALL pro_test1();\r\n```\r\n\r\n- 变量的赋值1\r\n\r\n```mysql\r\n-- 标准语法\r\nSET 变量名 = 变量值;\r\n\r\n-- 定义字符串类型变量，并赋值\r\nDELIMITER $\r\n\r\nCREATE PROCEDURE pro_test2()\r\nBEGIN\r\n\tDECLARE NAME VARCHAR(10);   -- 定义变量\r\n\tSET NAME = '存储过程';       -- 为变量赋值\r\n\tSELECT NAME;                -- 查询变量\r\nEND$\r\n\r\nDELIMITER ;\r\n\r\n-- 调用pro_test2存储过程\r\nCALL pro_test2();\r\n```\r\n\r\n- 变量的赋值2\r\n\r\n```mysql\r\n-- 标准语法\r\nSELECT 列名 INTO 变量名 FROM 表名 [WHERE 条件];\r\n\r\n-- 定义两个int变量，用于存储男女同学的总分数\r\nDELIMITER $\r\n\r\nCREATE PROCEDURE pro_test3()\r\nBEGIN\r\n\tDECLARE men,women INT;  -- 定义变量\r\n\tSELECT SUM(score) INTO men FROM student WHERE gender='男';    -- 计算男同学总分数赋值给men\r\n\tSELECT SUM(score) INTO women FROM student WHERE gender='女';  -- 计算女同学总分数赋值给women\r\n\tSELECT men,women;           -- 查询变量\r\nEND$\r\n\r\nDELIMITER ;\r\n\r\n-- 调用pro_test3存储过程\r\nCALL pro_test3();\r\n```\r\n\r\n##### 8.3if语句的使用\r\n\r\n- 标准语法\r\n\r\n```mysql\r\n-- 标准语法\r\nIF 判断条件1 THEN 执行的sql语句1;\r\n[ELSEIF 判断条件2 THEN 执行的sql语句2;]\r\n...\r\n[ELSE 执行的sql语句n;]\r\nEND IF;\r\n```\r\n\r\n- 案例演示\r\n\r\n```mysql\r\n/*\r\n\t定义一个int变量，用于存储班级总成绩\r\n\t定义一个varchar变量，用于存储分数描述\r\n\t根据总成绩判断：\r\n\t\t380分及以上    学习优秀\r\n\t\t320 ~ 380     学习不错\r\n\t\t320以下       学习一般\r\n*/\r\nDELIMITER $\r\n\r\nCREATE PROCEDURE pro_test4()\r\nBEGIN\r\n\t-- 定义总分数变量\r\n\tDECLARE total INT;\r\n\t-- 定义分数描述变量\r\n\tDECLARE description VARCHAR(10);\r\n\t-- 为总分数变量赋值\r\n\tSELECT SUM(score) INTO total FROM student;\r\n\t-- 判断总分数\r\n\tIF total >= 380 THEN \r\n\t\tSET description = '学习优秀';\r\n\tELSEIF total >= 320 AND total < 380 THEN \r\n\t\tSET description = '学习不错';\r\n\tELSE \r\n\t\tSET description = '学习一般';\r\n\tEND IF;\r\n\t\r\n\t-- 查询总成绩和描述信息\r\n\tSELECT total,description;\r\nEND$\r\n\r\nDELIMITER ;\r\n\r\n-- 调用pro_test4存储过程\r\nCALL pro_test4();\r\n```\r\n\r\n##### 8.4参数的传递\r\n\r\n- 参数传递的语法\r\n\r\n```mysql\r\nDELIMITER $\r\n\r\n-- 标准语法\r\nCREATE PROCEDURE 存储过程名称([IN|OUT|INOUT] 参数名 数据类型)\r\nBEGIN\r\n\t执行的sql语句;\r\nEND$\r\n/*\r\n\tIN:代表输入参数，需要由调用者传递实际数据。默认的\r\n\tOUT:代表输出参数，该参数可以作为返回值\r\n\tINOUT:代表既可以作为输入参数，也可以作为输出参数\r\n*/\r\nDELIMITER ;\r\n```\r\n\r\n- 输入参数\r\n\r\n  - 标准语法\r\n\r\n  ```mysql\r\n  DELIMITER $\r\n  \r\n  -- 标准语法\r\n  CREATE PROCEDURE 存储过程名称(IN 参数名 数据类型)\r\n  BEGIN\r\n  \t执行的sql语句;\r\n  END$\r\n  \r\n  DELIMITER ;\r\n  ```\r\n\r\n  - 案例演示\r\n\r\n  ```mysql\r\n  /*\r\n  \t输入总成绩变量，代表学生总成绩\r\n  \t定义一个varchar变量，用于存储分数描述\r\n  \t根据总成绩判断：\r\n  \t\t380分及以上  学习优秀\r\n  \t\t320 ~ 380    学习不错\r\n  \t\t320以下      学习一般\r\n  */\r\n  DELIMITER $\r\n  \r\n  CREATE PROCEDURE pro_test5(IN total INT)\r\n  BEGIN\r\n  \t-- 定义分数描述变量\r\n  \tDECLARE description VARCHAR(10);\r\n  \t-- 判断总分数\r\n  \tIF total >= 380 THEN \r\n  \t\tSET description = '学习优秀';\r\n  \tELSEIF total >= 320 AND total < 380 THEN \r\n  \t\tSET description = '学习不错';\r\n  \tELSE \r\n  \t\tSET description = '学习一般';\r\n  \tEND IF;\r\n  \t\r\n  \t-- 查询总成绩和描述信息\r\n  \tSELECT total,description;\r\n  END$\r\n  \r\n  DELIMITER ;\r\n  \r\n  -- 调用pro_test5存储过程\r\n  CALL pro_test5(390);\r\n  CALL pro_test5((SELECT SUM(score) FROM student));\r\n  ```\r\n\r\n- 输出参数\r\n\r\n  - 标准语法\r\n\r\n  ```mysql\r\n  DELIMITER $\r\n  \r\n  -- 标准语法\r\n  CREATE PROCEDURE 存储过程名称(OUT 参数名 数据类型)\r\n  BEGIN\r\n  \t执行的sql语句;\r\n  END$\r\n  \r\n  DELIMITER ;\r\n  ```\r\n\r\n  - 案例演示\r\n\r\n  ```mysql\r\n  /*\r\n  \t输入总成绩变量，代表学生总成绩\r\n  \t输出分数描述变量，代表学生总成绩的描述\r\n  \t根据总成绩判断：\r\n  \t\t380分及以上  学习优秀\r\n  \t\t320 ~ 380    学习不错\r\n  \t\t320以下      学习一般\r\n  */\r\n  DELIMITER $\r\n  \r\n  CREATE PROCEDURE pro_test6(IN total INT,OUT description VARCHAR(10))\r\n  BEGIN\r\n  \t-- 判断总分数\r\n  \tIF total >= 380 THEN \r\n  \t\tSET description = '学习优秀';\r\n  \tELSEIF total >= 320 AND total < 380 THEN \r\n  \t\tSET description = '学习不错';\r\n  \tELSE \r\n  \t\tSET description = '学习一般';\r\n  \tEND IF;\r\n  END$\r\n  \r\n  DELIMITER ;\r\n  \r\n  -- 调用pro_test6存储过程\r\n  CALL pro_test6(310,@description);\r\n  \r\n  -- 查询总成绩描述\r\n  SELECT @description;\r\n  ```\r\n\r\n  - 小知识\r\n\r\n  ```mysql\r\n  @变量名:  这种变量要在变量名称前面加上“@”符号，叫做用户会话变量，代表整个会话过程他都是有作用的，这个类似于全局变量一样。\r\n  \r\n  @@变量名: 这种在变量前加上 \"@@\" 符号, 叫做系统变量 \r\n  ```\r\n\r\n##### 8.5case语句的使用\r\n\r\n- 标准语法1\r\n\r\n```mysql\r\n-- 标准语法\r\nCASE 表达式\r\nWHEN 值1 THEN 执行sql语句1;\r\n[WHEN 值2 THEN 执行sql语句2;]\r\n...\r\n[ELSE 执行sql语句n;]\r\nEND CASE;\r\n```\r\n\r\n- 标准语法2\r\n\r\n```mysql\r\n-- 标准语法\r\nCASE\r\nWHEN 判断条件1 THEN 执行sql语句1;\r\n[WHEN 判断条件2 THEN 执行sql语句2;]\r\n...\r\n[ELSE 执行sql语句n;]\r\nEND CASE;\r\n```\r\n\r\n- 案例演示\r\n\r\n```mysql\r\n/*\r\n\t输入总成绩变量，代表学生总成绩\r\n\t定义一个varchar变量，用于存储分数描述\r\n\t根据总成绩判断：\r\n\t\t380分及以上  学习优秀\r\n\t\t320 ~ 380    学习不错\r\n\t\t320以下      学习一般\r\n*/\r\nDELIMITER $\r\n\r\nCREATE PROCEDURE pro_test7(IN total INT)\r\nBEGIN\r\n\t-- 定义变量\r\n\tDECLARE description VARCHAR(10);\r\n\t-- 使用case判断\r\n\tCASE\r\n\tWHEN total >= 380 THEN\r\n\t\tSET description = '学习优秀';\r\n\tWHEN total >= 320 AND total < 380 THEN\r\n\t\tSET description = '学习不错';\r\n\tELSE \r\n\t\tSET description = '学习一般';\r\n\tEND CASE;\r\n\t\r\n\t-- 查询分数描述信息\r\n\tSELECT description;\r\nEND$\r\n\r\nDELIMITER ;\r\n\r\n-- 调用pro_test7存储过程\r\nCALL pro_test7(390);\r\nCALL pro_test7((SELECT SUM(score) FROM student));\r\n```\r\n\r\n##### 8.6while循环\r\n\r\n- 标准语法\r\n\r\n```mysql\r\n-- 标准语法\r\n初始化语句;\r\nWHILE 条件判断语句 DO\r\n\t循环体语句;\r\n\t条件控制语句;\r\nEND WHILE;\r\n```\r\n\r\n- 案例演示\r\n\r\n```mysql\r\n/*\r\n\t计算1~100之间的偶数和\r\n*/\r\nDELIMITER $\r\n\r\nCREATE PROCEDURE pro_test8()\r\nBEGIN\r\n\t-- 定义求和变量\r\n\tDECLARE result INT DEFAULT 0;\r\n\t-- 定义初始化变量\r\n\tDECLARE num INT DEFAULT 1;\r\n\t-- while循环\r\n\tWHILE num <= 100 DO\r\n\t\t-- 偶数判断\r\n\t\tIF num%2=0 THEN\r\n\t\t\tSET result = result + num; -- 累加\r\n\t\tEND IF;\r\n\t\t\r\n\t\t-- 让num+1\r\n\t\tSET num = num + 1;         \r\n\tEND WHILE;\r\n\t\r\n\t-- 查询求和结果\r\n\tSELECT result;\r\nEND$\r\n\r\nDELIMITER ;\r\n\r\n-- 调用pro_test8存储过程\r\nCALL pro_test8();\r\n```\r\n\r\n##### 8.7repeat循环\r\n\r\n- 标准语法\r\n\r\n```mysql\r\n-- 标准语法\r\n初始化语句;\r\nREPEAT\r\n\t循环体语句;\r\n\t条件控制语句;\r\n\tUNTIL 条件判断语句\r\nEND REPEAT;\r\n\r\n-- 注意：repeat循环是条件满足则停止。while循环是条件满足则执行\r\n```\r\n\r\n- 案例演示\r\n\r\n```mysql\r\n/*\r\n\t计算1~10之间的和\r\n*/\r\nDELIMITER $\r\n\r\nCREATE PROCEDURE pro_test9()\r\nBEGIN\r\n\t-- 定义求和变量\r\n\tDECLARE result INT DEFAULT 0;\r\n\t-- 定义初始化变量\r\n\tDECLARE num INT DEFAULT 1;\r\n\t-- repeat循环\r\n\tREPEAT\r\n\t\t-- 累加\r\n\t\tSET result = result + num;\r\n\t\t-- 让num+1\r\n\t\tSET num = num + 1;\r\n\t\t\r\n\t\t-- 停止循环\r\n\t\tUNTIL num>10\r\n\tEND REPEAT;\r\n\t\r\n\t-- 查询求和结果\r\n\tSELECT result;\r\nEND$\r\n\r\nDELIMITER ;\r\n\r\n-- 调用pro_test9存储过程\r\nCALL pro_test9();\r\n```\r\n\r\n##### 8.8loop循环\r\n\r\n- 标准语法\r\n\r\n```mysql\r\n-- 标准语法\r\n初始化语句;\r\n[循环名称:] LOOP\r\n\t条件判断语句\r\n\t\t[LEAVE 循环名称;]\r\n\t循环体语句;\r\n\t条件控制语句;\r\nEND LOOP 循环名称;\r\n\r\n-- 注意：loop可以实现简单的循环，但是退出循环需要使用其他的语句来定义。我们可以使用leave语句完成！\r\n--      如果不加退出循环的语句，那么就变成了死循环。\r\n```\r\n\r\n- 案例演示\r\n\r\n```mysql\r\n/*\r\n\t计算1~10之间的和\r\n*/\r\nDELIMITER $\r\n\r\nCREATE PROCEDURE pro_test10()\r\nBEGIN\r\n\t-- 定义求和变量\r\n\tDECLARE result INT DEFAULT 0;\r\n\t-- 定义初始化变量\r\n\tDECLARE num INT DEFAULT 1;\r\n\t-- loop循环\r\n\tl:LOOP\r\n\t\t-- 条件成立，停止循环\r\n\t\tIF num > 10 THEN\r\n\t\t\tLEAVE l;\r\n\t\tEND IF;\r\n\t\r\n\t\t-- 累加\r\n\t\tSET result = result + num;\r\n\t\t-- 让num+1\r\n\t\tSET num = num + 1;\r\n\tEND LOOP l;\r\n\t\r\n\t-- 查询求和结果\r\n\tSELECT result;\r\nEND$\r\n\r\nDELIMITER ;\r\n\r\n-- 调用pro_test10存储过程\r\nCALL pro_test10();\r\n```\r\n\r\n##### 8.9游标\r\n\r\n- 游标的概念\r\n\r\n  - 游标可以遍历返回的多行结果，每次拿到一整行数据\r\n  - 在存储过程和函数中可以使用游标对结果集进行循环的处理\r\n  - 简单来说游标就类似于集合的迭代器遍历\r\n  - MySQL中的游标只能用在存储过程和函数中\r\n\r\n- 游标的语法\r\n\r\n  - 创建游标\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  DECLARE 游标名称 CURSOR FOR 查询sql语句;\r\n  ```\r\n\r\n  - 打开游标\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  OPEN 游标名称;\r\n  ```\r\n\r\n  - 使用游标获取数据\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  FETCH 游标名称 INTO 变量名1,变量名2,...;\r\n  ```\r\n\r\n  - 关闭游标\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  CLOSE 游标名称;\r\n  ```\r\n\r\n- 游标的基本使用\r\n\r\n```mysql\r\n-- 创建stu_score表\r\nCREATE TABLE stu_score(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tscore INT\r\n);\r\n\r\n/*\r\n\t将student表中所有的成绩保存到stu_score表中\r\n*/\r\nDELIMITER $\r\n\r\nCREATE PROCEDURE pro_test11()\r\nBEGIN\r\n\t-- 定义成绩变量\r\n\tDECLARE s_score INT;\r\n\t-- 创建游标,查询所有学生成绩数据\r\n\tDECLARE stu_result CURSOR FOR SELECT score FROM student;\r\n\t\r\n\t-- 开启游标\r\n\tOPEN stu_result;\r\n\t\r\n\t-- 使用游标，遍历结果,拿到第1行数据\r\n\tFETCH stu_result INTO s_score;\r\n\t-- 将数据保存到stu_score表中\r\n\tINSERT INTO stu_score VALUES (NULL,s_score);\r\n\t\r\n\t-- 使用游标，遍历结果,拿到第2行数据\r\n\tFETCH stu_result INTO s_score;\r\n\t-- 将数据保存到stu_score表中\r\n\tINSERT INTO stu_score VALUES (NULL,s_score);\r\n\t\r\n\t-- 使用游标，遍历结果,拿到第3行数据\r\n\tFETCH stu_result INTO s_score;\r\n\t-- 将数据保存到stu_score表中\r\n\tINSERT INTO stu_score VALUES (NULL,s_score);\r\n\t\r\n\t-- 使用游标，遍历结果,拿到第4行数据\r\n\tFETCH stu_result INTO s_score;\r\n\t-- 将数据保存到stu_score表中\r\n\tINSERT INTO stu_score VALUES (NULL,s_score);\r\n\t\r\n\t-- 关闭游标\r\n\tCLOSE stu_result;\r\nEND$\r\n\r\nDELIMITER ;\r\n\r\n-- 调用pro_test11存储过程\r\nCALL pro_test11();\r\n\r\n-- 查询stu_score表\r\nSELECT * FROM stu_score;\r\n\r\n\r\n-- ===========================================================\r\n/*\r\n\t出现的问题：\r\n\t\tstudent表中一共有4条数据，我们在游标遍历了4次，没有问题！\r\n\t\t但是在游标中多遍历几次呢？就会出现问题\r\n*/\r\nDELIMITER $\r\n\r\nCREATE PROCEDURE pro_test11()\r\nBEGIN\r\n\t-- 定义成绩变量\r\n\tDECLARE s_score INT;\r\n\t-- 创建游标,查询所有学生成绩数据\r\n\tDECLARE stu_result CURSOR FOR SELECT score FROM student;\r\n\t\r\n\t-- 开启游标\r\n\tOPEN stu_result;\r\n\t\r\n\t-- 使用游标，遍历结果,拿到第1行数据\r\n\tFETCH stu_result INTO s_score;\r\n\t-- 将数据保存到stu_score表中\r\n\tINSERT INTO stu_score VALUES (NULL,s_score);\r\n\t\r\n\t-- 使用游标，遍历结果,拿到第2行数据\r\n\tFETCH stu_result INTO s_score;\r\n\t-- 将数据保存到stu_score表中\r\n\tINSERT INTO stu_score VALUES (NULL,s_score);\r\n\t\r\n\t-- 使用游标，遍历结果,拿到第3行数据\r\n\tFETCH stu_result INTO s_score;\r\n\t-- 将数据保存到stu_score表中\r\n\tINSERT INTO stu_score VALUES (NULL,s_score);\r\n\t\r\n\t-- 使用游标，遍历结果,拿到第4行数据\r\n\tFETCH stu_result INTO s_score;\r\n\t-- 将数据保存到stu_score表中\r\n\tINSERT INTO stu_score VALUES (NULL,s_score);\r\n\t\r\n\t-- 使用游标，遍历结果,拿到第5行数据\r\n\tFETCH stu_result INTO s_score;\r\n\t-- 将数据保存到stu_score表中\r\n\tINSERT INTO stu_score VALUES (NULL,s_score);\r\n\t\r\n\t-- 关闭游标\r\n\tCLOSE stu_result;\r\nEND$\r\n\r\nDELIMITER ;\r\n\r\n-- 调用pro_test11存储过程\r\nCALL pro_test11();\r\n\r\n-- 查询stu_score表,虽然数据正确，但是在执行存储过程时会报错\r\nSELECT * FROM stu_score;\r\n```\r\n\r\n- 游标的优化使用(配合循环使用)\r\n\r\n```mysql\r\n/*\r\n\t当游标结束后，会触发游标结束事件。我们可以通过这一特性来完成循环操作\r\n\t加标记思想：\r\n\t\t1.定义一个变量，默认值为0(意味着有数据)\r\n\t\t2.当游标结束后，将变量值改为1(意味着没有数据了)\r\n*/\r\n-- 1.定义一个变量，默认值为0(意味着有数据)\r\nDECLARE flag INT DEFAULT 0;\r\n-- 2.当游标结束后，将变量值改为1(意味着没有数据了)\r\nDECLARE EXIT HANDLER FOR NOT FOUND SET flag = 1;\r\n```\r\n\r\n```mysql\r\n/*\r\n\t将student表中所有的成绩保存到stu_score表中\r\n*/\r\nDELIMITER $\r\n\r\nCREATE PROCEDURE pro_test12()\r\nBEGIN\r\n\t-- 定义成绩变量\r\n\tDECLARE s_score INT;\r\n\t-- 定义标记变量\r\n\tDECLARE flag INT DEFAULT 0;\r\n\t-- 创建游标，查询所有学生成绩数据\r\n\tDECLARE stu_result CURSOR FOR SELECT score FROM student;\r\n\t-- 游标结束后，将标记变量改为1\r\n\tDECLARE EXIT HANDLER FOR NOT FOUND SET flag = 1;\r\n\t\r\n\t-- 开启游标\r\n\tOPEN stu_result;\r\n\t\r\n\t-- 循环使用游标\r\n\tREPEAT\r\n\t\t-- 使用游标，遍历结果,拿到数据\r\n\t\tFETCH stu_result INTO s_score;\r\n\t\t-- 将数据保存到stu_score表中\r\n\t\tINSERT INTO stu_score VALUES (NULL,s_score);\r\n\tUNTIL flag=1\r\n\tEND REPEAT;\r\n\t\r\n\t-- 关闭游标\r\n\tCLOSE stu_result;\r\nEND$\r\n\r\nDELIMITER ;\r\n\r\n-- 调用pro_test12存储过程\r\nCALL pro_test12();\r\n\r\n-- 查询stu_score表\r\nSELECT * FROM stu_score;\r\n```\r\n\r\n#### 9.存储过程的总结\r\n\r\n- 存储过程是 事先经过编译并存储在数据库中的一段 SQL 语句的集合。可以在数据库层面做一些业务处理\r\n- 说白了存储过程其实就是将sql语句封装为方法，然后可以调用方法执行sql语句而已\r\n- 存储过程的好处\r\n  - 安全\r\n  - 高效\r\n  - 复用性强\r\n\r\n#### 10.存储函数\r\n\r\n- 存储函数和存储过程是非常相似的。存储函数可以做的事情，存储过程也可以做到！\r\n\r\n- 存储函数有返回值，存储过程没有返回值(参数的out其实也相当于是返回数据了)\r\n\r\n- 标准语法\r\n\r\n  - 创建存储函数\r\n\r\n  ```mysql\r\n  DELIMITER $\r\n  \r\n  -- 标准语法\r\n  CREATE FUNCTION 函数名称([参数 数据类型])\r\n  RETURNS 返回值类型\r\n  BEGIN\r\n  \t执行的sql语句;\r\n  \tRETURN 结果;\r\n  END$\r\n  \r\n  DELIMITER ;\r\n  ```\r\n\r\n  - 调用存储函数\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SELECT 函数名称(实际参数);\r\n  ```\r\n\r\n  - 删除存储函数\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  DROP FUNCTION 函数名称;\r\n  ```\r\n\r\n- 案例演示\r\n\r\n```mysql\r\n/*\r\n\t定义存储函数，获取学生表中成绩大于95分的学生数量\r\n*/\r\nDELIMITER $\r\n\r\nCREATE FUNCTION fun_test1()\r\nRETURNS INT\r\nBEGIN\r\n\t-- 定义统计变量\r\n\tDECLARE result INT;\r\n\t-- 查询成绩大于95分的学生数量，给统计变量赋值\r\n\tSELECT COUNT(*) INTO result FROM student WHERE score > 95;\r\n\t-- 返回统计结果\r\n\tRETURN result;\r\nEND$\r\n\r\nDELIMITER ;\r\n\r\n-- 调用fun_test1存储函数\r\nSELECT fun_test1();\r\n```\r\n\r\n### 二、MySQL触发器\r\n\r\n#### 1.触发器的概念\r\n\r\n- 触发器是与表有关的数据库对象，可以在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句。触发器的这种特性可以协助应用在数据库端确保数据的完整性 、日志记录 、数据校验等操作 。\r\n- 使用别名 NEW 和 OLD 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。\r\n\r\n| 触发器类型      | OLD的含义                      | NEW的含义                      |\r\n| --------------- | ------------------------------ | ------------------------------ |\r\n| INSERT 型触发器 | 无 (因为插入前状态无数据)      | NEW 表示将要或者已经新增的数据 |\r\n| UPDATE 型触发器 | OLD 表示修改之前的数据         | NEW 表示将要或已经修改后的数据 |\r\n| DELETE 型触发器 | OLD 表示将要或者已经删除的数据 | 无 (因为删除后状态无数据)      |\r\n\r\n#### 2.创建触发器\r\n\r\n- 标准语法\r\n\r\n```mysql\r\nDELIMITER $\r\n\r\nCREATE TRIGGER 触发器名称\r\nBEFORE|AFTER INSERT|UPDATE|DELETE\r\nON 表名\r\n[FOR EACH ROW]  -- 行级触发器\r\nBEGIN\r\n\t触发器要执行的功能;\r\nEND$\r\n\r\nDELIMITER ;\r\n```\r\n\r\n- 触发器演示。通过触发器记录账户表的数据变更日志。包含：增加、修改、删除\r\n\r\n  - 创建账户表\r\n\r\n  ```mysql\r\n  -- 创建db9数据库\r\n  CREATE DATABASE db9;\r\n  \r\n  -- 使用db9数据库\r\n  USE db9;\r\n  \r\n  -- 创建账户表account\r\n  CREATE TABLE account(\r\n  \tid INT PRIMARY KEY AUTO_INCREMENT,\t-- 账户id\r\n  \tNAME VARCHAR(20),\t\t\t\t\t-- 姓名\r\n  \tmoney DOUBLE\t\t\t\t\t\t-- 余额\r\n  );\r\n  -- 添加数据\r\n  INSERT INTO account VALUES (NULL,'张三',1000),(NULL,'李四',2000);\r\n  ```\r\n\r\n  - 创建日志表\r\n\r\n  ```mysql\r\n  -- 创建日志表account_log\r\n  CREATE TABLE account_log(\r\n  \tid INT PRIMARY KEY AUTO_INCREMENT,\t-- 日志id\r\n  \toperation VARCHAR(20),\t\t\t\t-- 操作类型 (insert update delete)\r\n  \toperation_time DATETIME,\t\t\t-- 操作时间\r\n  \toperation_id INT,\t\t\t\t\t-- 操作表的id\r\n  \toperation_params VARCHAR(200)       -- 操作参数\r\n  );\r\n  ```\r\n\r\n  - 创建INSERT触发器\r\n\r\n  ```mysql\r\n  -- 创建INSERT触发器\r\n  DELIMITER $\r\n  \r\n  CREATE TRIGGER account_insert\r\n  AFTER INSERT\r\n  ON account\r\n  FOR EACH ROW\r\n  BEGIN\r\n  \tINSERT INTO account_log VALUES (NULL,'INSERT',NOW(),new.id,CONCAT('插入后{id=',new.id,',name=',new.name,',money=',new.money,'}'));\r\n  END$\r\n  \r\n  DELIMITER ;\r\n  \r\n  -- 向account表添加记录\r\n  INSERT INTO account VALUES (NULL,'王五',3000);\r\n  \r\n  -- 查询account表\r\n  SELECT * FROM account;\r\n  \r\n  -- 查询日志表\r\n  SELECT * FROM account_log;\r\n  ```\r\n\r\n  - 创建UPDATE触发器\r\n\r\n  ```mysql\r\n  -- 创建UPDATE触发器\r\n  DELIMITER $\r\n  \r\n  CREATE TRIGGER account_update\r\n  AFTER UPDATE\r\n  ON account\r\n  FOR EACH ROW\r\n  BEGIN\r\n  \tINSERT INTO account_log VALUES (NULL,'UPDATE',NOW(),new.id,CONCAT('修改前{id=',old.id,',name=',old.name,',money=',old.money,'}','修改后{id=',new.id,',name=',new.name,',money=',new.money,'}'));\r\n  END$\r\n  \r\n  DELIMITER ;\r\n  \r\n  -- 修改account表\r\n  UPDATE account SET money=3500 WHERE id=3;\r\n  \r\n  -- 查询account表\r\n  SELECT * FROM account;\r\n  \r\n  -- 查询日志表\r\n  SELECT * FROM account_log;\r\n  ```\r\n\r\n  - 创建DELETE触发器\r\n\r\n  ```mysql\r\n  -- 创建DELETE触发器\r\n  DELIMITER $\r\n  \r\n  CREATE TRIGGER account_delete\r\n  AFTER DELETE\r\n  ON account\r\n  FOR EACH ROW\r\n  BEGIN\r\n  \tINSERT INTO account_log VALUES (NULL,'DELETE',NOW(),old.id,CONCAT('删除前{id=',old.id,',name=',old.name,',money=',old.money,'}'));\r\n  END$\r\n  \r\n  DELIMITER ;\r\n  \r\n  -- 删除account表数据\r\n  DELETE FROM account WHERE id=3;\r\n  \r\n  -- 查询account表\r\n  SELECT * FROM account;\r\n  \r\n  -- 查询日志表\r\n  SELECT * FROM account_log;\r\n  ```\r\n\r\n#### 3.查看触发器\r\n\r\n```mysql\r\n-- 标准语法\r\nSHOW TRIGGERS;\r\n\r\n-- 查看触发器\r\nSHOW TRIGGERS;\r\n```\r\n\r\n#### 4.删除触发器\r\n\r\n```mysql\r\n-- 标准语法\r\nDROP TRIGGER 触发器名称;\r\n\r\n-- 删除DELETE触发器\r\nDROP TRIGGER account_delete;\r\n```\r\n\r\n#### 5.触发器的总结\r\n\r\n- 触发器是与表有关的数据库对象\r\n- 可以在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句\r\n- 触发器的这种特性可以协助应用在数据库端确保数据的完整性 、日志记录 、数据校验等操作 \r\n- 使用别名 NEW 和 OLD 来引用触发器中发生变化的记录内容\r\n\r\n### 三、MySQL事务\r\n\r\n#### 1.事务的概念\r\n\r\n- 一条或多条 SQL 语句组成一个执行单元，其特点是这个单元要么同时成功要么同时失败，单元中的每条 SQL 语句都相互依赖，形成一个整体，如果某条 SQL 语句执行失败或者出现错误，那么整个单元就会回滚，撤回到事务最初的状态，如果单元中所有的 SQL 语句都执行成功，则事务就顺利执行。\r\n\r\n#### 2.事务的数据准备\r\n\r\n```mysql\r\n-- 创建db10数据库\r\nCREATE DATABASE db10;\r\n\r\n-- 使用db10数据库\r\nUSE db10;\r\n\r\n-- 创建账户表\r\nCREATE TABLE account(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\t-- 账户id\r\n\tNAME VARCHAR(20),\t\t\t-- 账户名称\r\n\tmoney DOUBLE\t\t\t\t-- 账户余额\r\n);\r\n-- 添加数据\r\nINSERT INTO account VALUES (NULL,'张三',1000),(NULL,'李四',1000);\r\n```\r\n\r\n#### 3.未管理事务演示\r\n\r\n```mysql\r\n-- 张三给李四转账500元\r\n-- 1.张三账户-500\r\nUPDATE account SET money=money-500 WHERE NAME='张三';\r\n-- 2.李四账户+500\r\n出错了...\r\nUPDATE account SET money=money+500 WHERE NAME='李四';\r\n\r\n-- 该场景下，这两条sql语句要么同时成功，要么同时失败。就需要被事务所管理！\r\n```\r\n\r\n#### 4.管理事务演示\r\n\r\n- 操作事务的三个步骤\r\n  1. 开启事务：记录回滚点，并通知服务器，将要执行一组操作，要么同时成功、要么同时失败\r\n  2. 执行sql语句：执行具体的一条或多条sql语句\r\n  3. 结束事务(提交|回滚)\r\n     - 提交：没出现问题，数据进行更新\r\n     - 回滚：出现问题，数据恢复到开启事务时的状态\r\n- 开启事务\r\n\r\n```mysql\r\n-- 标准语法\r\nSTART TRANSACTION;\r\n```\r\n\r\n- 回滚事务\r\n\r\n```mysql\r\n-- 标准语法\r\nROLLBACK;\r\n```\r\n\r\n- 提交事务\r\n\r\n```mysql\r\n-- 标准语法\r\nCOMMIT;\r\n```\r\n\r\n- 管理事务演示\r\n\r\n```mysql\r\n-- 开启事务\r\nSTART TRANSACTION;\r\n\r\n-- 张三给李四转账500元\r\n-- 1.张三账户-500\r\nUPDATE account SET money=money-500 WHERE NAME='张三';\r\n-- 2.李四账户+500\r\n-- 出错了...\r\nUPDATE account SET money=money+500 WHERE NAME='李四';\r\n\r\n-- 回滚事务(出现问题)\r\nROLLBACK;\r\n\r\n-- 提交事务(没出现问题)\r\nCOMMIT;\r\n```\r\n\r\n#### 5.事务的提交方式\r\n\r\n- 提交方式\r\n\r\n  - 自动提交(MySQL默认为自动提交)\r\n  - 手动提交\r\n\r\n- 修改提交方式\r\n\r\n  - 查看提交方式\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SELECT @@AUTOCOMMIT;  -- 1代表自动提交    0代表手动提交\r\n  ```\r\n\r\n  - 修改提交方式\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SET @@AUTOCOMMIT=数字;\r\n  \r\n  -- 修改为手动提交\r\n  SET @@AUTOCOMMIT=0;\r\n  \r\n  -- 查看提交方式\r\n  SELECT @@AUTOCOMMIT;\r\n  ```\r\n\r\n#### 6.事务的四大特征(ACID)\r\n\r\n- 原子性(atomicity)\r\n  - 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响\r\n- 一致性(consistency)\r\n  - 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态\r\n  - 拿转账来说，假设张三和李四两者的钱加起来一共是2000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是2000，这就是事务的一致性\r\n- 隔离性(isolcation)\r\n  - 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离\r\n- 持久性(durability)\r\n  - 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作\r\n\r\n#### 7.事务的隔离级别\r\n\r\n- 隔离级别的概念\r\n  - 多个客户端操作时 ,各个客户端的事务之间应该是隔离的，相互独立的 , 不受影响的。\r\n  - 而如果多个事务操作同一批数据时，则需要设置不同的隔离级别 , 否则就会产生问题 。\r\n  - 我们先来了解一下四种隔离级别的名称 , 再来看看可能出现的问题\r\n- 四种隔离级别\r\n\r\n| 1     | 读未提交     | read uncommitted    |\r\n| ----- | ------------ | ------------------- |\r\n| **2** | **读已提交** | **read committed**  |\r\n| **3** | **可重复读** | **repeatable read** |\r\n| **4** | **串行化**   | **serializable**    |\r\n\r\n- 可能引发的问题\r\n\r\n| 问题           | 现象                                                         |\r\n| -------------- | ------------------------------------------------------------ |\r\n| **脏读**       | **是指在一个事务处理过程中读取了另一个未提交的事务中的数据 , 导致两次查询结果不一致** |\r\n| **不可重复读** | **是指在一个事务处理过程中读取了另一个事务中修改并已提交的数据, 导致两次查询结果不一致** |\r\n| **幻读**       | **select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入。或不存在执行delete删除，却发现删除成功** |\r\n\r\n- 查询数据库隔离级别\r\n\r\n```mysql\r\n-- 标准语法\r\nSELECT @@TX_ISOLATION;\r\n```\r\n\r\n- 修改数据库隔离级别\r\n\r\n```mysql\r\n-- 标准语法\r\nSET GLOBAL TRANSACTION ISOLATION LEVEL 级别字符串;\r\n\r\n-- 修改数据库隔离级别为read uncommitted\r\nSET GLOBAL TRANSACTION ISOLATION LEVEL read uncommitted;\r\n\r\n-- 查看隔离级别\r\nSELECT @@TX_ISOLATION;   -- 修改后需要断开连接重新开\r\n```\r\n\r\n#### 8.事务隔离级别演示\r\n\r\n- 脏读的问题\r\n\r\n  - 窗口1\r\n\r\n  ```mysql\r\n  -- 查询账户表\r\n  select * from account;\r\n  \r\n  -- 设置隔离级别为read uncommitted\r\n  set global transaction isolation level read uncommitted;\r\n  \r\n  -- 开启事务\r\n  start transaction;\r\n  \r\n  -- 转账\r\n  update account set money = money - 500 where id = 1;\r\n  update account set money = money + 500 where id = 2;\r\n  \r\n  -- 窗口2查询转账结果 ,出现脏读(查询到其他事务未提交的数据)\r\n  \r\n  -- 窗口2查看转账结果后，执行回滚\r\n  rollback;\r\n  ```\r\n\r\n  - 窗口2\r\n\r\n  ```mysql\r\n  -- 查询隔离级别\r\n  select @@tx_isolation;\r\n  \r\n  -- 开启事务\r\n  start transaction;\r\n  \r\n  -- 查询账户表\r\n  select * from account;\r\n  ```\r\n\r\n- 解决脏读的问题和演示不可重复读的问题\r\n\r\n  - 窗口1\r\n\r\n  ```mysql\r\n  -- 设置隔离级别为read committed\r\n  set global transaction isolation level read committed;\r\n  \r\n  -- 开启事务\r\n  start transaction;\r\n  \r\n  -- 转账\r\n  update account set money = money - 500 where id = 1;\r\n  update account set money = money + 500 where id = 2;\r\n  \r\n  -- 窗口2查看转账结果，并没有发生变化(脏读问题被解决了)\r\n  \r\n  -- 执行提交事务。\r\n  commit;\r\n  \r\n  -- 窗口2查看转账结果，数据发生了变化(出现了不可重复读的问题，读取到其他事务已提交的数据)\r\n  ```\r\n\r\n  - 窗口2\r\n\r\n  ```mysql\r\n  -- 查询隔离级别\r\n  select @@tx_isolation;\r\n  \r\n  -- 开启事务\r\n  start transaction;\r\n  \r\n  -- 查询账户表\r\n  select * from account;\r\n  ```\r\n\r\n- 解决不可重复读的问题\r\n\r\n  - 窗口1\r\n\r\n  ```mysql\r\n  -- 设置隔离级别为repeatable read\r\n  set global transaction isolation level repeatable read;\r\n  \r\n  -- 开启事务\r\n  start transaction;\r\n  \r\n  -- 转账\r\n  update account set money = money - 500 where id = 1;\r\n  update account set money = money + 500 where id = 2;\r\n  \r\n  -- 窗口2查看转账结果，并没有发生变化\r\n  \r\n  -- 执行提交事务\r\n  commit;\r\n  \r\n  -- 这个时候窗口2只要还在上次事务中，看到的结果都是相同的。只有窗口2结束事务，才能看到变化(不可重复读的问题被解决)\r\n  ```\r\n\r\n  - 窗口2\r\n\r\n  ```mysql\r\n  -- 查询隔离级别\r\n  select @@tx_isolation;\r\n  \r\n  -- 开启事务\r\n  start transaction;\r\n  \r\n  -- 查询账户表\r\n  select * from account;\r\n  \r\n  -- 提交事务\r\n  commit;\r\n  \r\n  -- 查询账户表\r\n  select * from account;\r\n  ```\r\n\r\n- 幻读的问题和解决\r\n\r\n  - 窗口1\r\n\r\n  ```mysql\r\n  -- 设置隔离级别为repeatable read\r\n  set global transaction isolation level repeatable read;\r\n  \r\n  -- 开启事务\r\n  start transaction;\r\n  \r\n  -- 添加一条记录\r\n  INSERT INTO account VALUES (3,'王五',1500);\r\n  \r\n  -- 查询账户表，本窗口可以查看到id为3的结果\r\n  SELECT * FROM account;\r\n  \r\n  -- 提交事务\r\n  COMMIT;\r\n  ```\r\n\r\n  - 窗口2\r\n\r\n  ```mysql\r\n  -- 查询隔离级别\r\n  select @@tx_isolation;\r\n  \r\n  -- 开启事务\r\n  start transaction;\r\n  \r\n  -- 查询账户表，查询不到新添加的id为3的记录\r\n  select * from account;\r\n  \r\n  -- 添加id为3的一条数据，发现添加失败。出现了幻读\r\n  INSERT INTO account VALUES (3,'测试',200);\r\n  \r\n  -- 提交事务\r\n  COMMIT;\r\n  \r\n  -- 查询账户表，查询到了新添加的id为3的记录\r\n  select * from account;\r\n  ```\r\n\r\n  - 解决幻读的问题\r\n\r\n  ```mysql\r\n  /*\r\n  \t窗口1\r\n  */\r\n  -- 设置隔离级别为serializable\r\n  set global transaction isolation level serializable;\r\n  \r\n  -- 开启事务\r\n  start transaction;\r\n  \r\n  -- 添加一条记录\r\n  INSERT INTO account VALUES (4,'赵六',1600);\r\n  \r\n  -- 查询账户表，本窗口可以查看到id为4的结果\r\n  SELECT * FROM account;\r\n  \r\n  -- 提交事务\r\n  COMMIT;\r\n  \r\n  \r\n  \r\n  /*\r\n  \t窗口2\r\n  */\r\n  -- 查询隔离级别\r\n  select @@tx_isolation;\r\n  \r\n  -- 开启事务\r\n  start transaction;\r\n  \r\n  -- 查询账户表，发现查询语句无法执行，数据表被锁住！只有窗口1提交事务后，才可以继续操作\r\n  select * from account;\r\n  \r\n  -- 添加id为4的一条数据，发现已经存在了，就不会再添加了！幻读的问题被解决\r\n  INSERT INTO account VALUES (4,'测试',200);\r\n  \r\n  -- 提交事务\r\n  COMMIT;\r\n  ```\r\n\r\n#### 9.隔离级别总结\r\n\r\n|      | 隔离级别             | 名称     | 出现脏读 | 出现不可重复读 | 出现幻读 | 数据库默认隔离级别  |\r\n| ---- | -------------------- | -------- | -------- | -------------- | -------- | ------------------- |\r\n| 1    | **read uncommitted** | 读未提交 | 是       | 是             | 是       |                     |\r\n| 2    | **read committed**   | 读已提交 | 否       | 是             | 是       | Oracle / SQL Server |\r\n| 3    | **repeatable read**  | 可重复读 | 否       | 否             | 是       | MySQL               |\r\n| 4    | **serializable **    | 串行化   | 否       | 否             | 否       |                     |\r\n\r\n> 注意：隔离级别从小到大安全性越来越高，但是效率越来越低 , 所以不建议使用READ UNCOMMITTED 和 SERIALIZABLE 隔离级别.\r\n\r\n#### 10.事务的总结\r\n\r\n- 一条或多条 SQL 语句组成一个执行单元，其特点是这个单元要么同时成功要么同时失败。例如转账操作\r\n- 开启事务：start transaction;\r\n- 回滚事务：rollback;\r\n- 提交事务：commit;\r\n- 事务四大特征\r\n  - 原子性\r\n  - 持久性\r\n  - 隔离性\r\n  - 一致性\r\n- 事务的隔离级别\r\n  - read uncommitted(读未提交)\r\n  - read committed (读已提交)\r\n  - repeatable read (可重复读)\r\n  - serializable (串行化)\r\n\r\n",tn={data:function(){return{MainComponent:rn}}},en=tn,sn=Object(T["a"])(en,Z,nn,!1,null,"665818fa",null),En=sn.exports,an=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},on=[],dn='\x3c!--\r\n * @Date           : 2021-04-11 02:20:56\r\n * @FilePath       : /jinnian-space/src/pages/sql/module/mysql/md/MySQL高级-04-授课笔记.md\r\n * @Description    : \r\n--\x3e\r\n# MySQL高级-04-授课笔记\r\n\r\n### 一、MySQL存储引擎\r\n\r\n#### 1.MySQL体系结构\r\n\r\n- 体系结构的概念\r\n\r\n  - 任何一套系统当中，每个部件都能起到一定的作用！\r\n\r\n- MySQL的体系结构\r\n\r\n![02](./img/sql/mysql/MySQL高级-04-授课笔记.assets/02.png)\r\n\r\n- 体系结构详解\r\n  - 客户端连接\r\n    - 支持接口：支持的客户端连接，例如C、Java、PHP等语言来连接MySQL数据库\r\n  - 第一层：网络连接层\r\n    - 连接池：管理、缓冲用户的连接，线程处理等需要缓存的需求。\r\n    - 例如：当客户端发送一个请求连接，会从连接池中获取一个连接进行使用。\r\n  - 第二层：核心服务层\r\n    - 管理服务和工具：系统的管理和控制工具，例如备份恢复、复制、集群等。 \r\n    - SQL接口：接受SQL命令，并且返回查询结果。\r\n    - 查询解析器：验证和解析SQL命令，例如过滤条件、语法结构等。 \r\n    - 查询优化器：在执行查询之前，使用默认的一套优化机制进行优化sql语句\r\n    - 缓存：如果缓存当中有想查询的数据，则直接将缓存中的数据返回。没有的话再重新查询！\r\n  - 第三层：存储引擎层\r\n    - 插件式存储引擎：管理和操作数据的一种机制，包括(存储数据、如何更新、查询数据等)\r\n  - 第四层：系统文件层\r\n    - 文件系统：配置文件、数据文件、日志文件、错误文件、二进制文件等等的保存\r\n\r\n#### 2.MySQL存储引擎\r\n\r\n- 引擎的概念\r\n\r\n  - 生活中，引擎就是整个机器运行的核心，不同的引擎具备不同的功能。\r\n\r\n- MySQL存储引擎的概念\r\n  - MySQL数据库使用不同的机制存取表文件 , 机制的差别在于不同的存储方式、索引技巧、锁定水平以及广泛的不同的功能和能力，在MySQL中 , 将这些不同的技术及配套的功能称为**存储引擎**\r\n  - 在关系型数据库中数据的存储是以表的形式存进行储的，所以存储引擎也可以称为**表类型**（即存储和操作此表的类型）。\r\n  - Oracle , SqlServer等数据库只有一种存储引擎 , 而MySQL针对不同的需求, 配置MySQL的不同的存储引擎 , 就会让数据库采取了不同的处理数据的方式和扩展功能。\r\n  - 通过选择不同的引擎 ,能够获取最佳的方案 ,  也能够获得额外的速度或者功能，提高程序的整体效果。所以了解引擎的特性 , 才能贴合我们的需求 , 更好的发挥数据库的性能。\r\n- MySQL支持的存储引擎\r\n  - MySQL5.7支持的引擎包括：InnoDB、MyISAM、MEMORY、Archive、Federate、CSV、BLACKHOLE等\r\n  - 其中较为常用的有三种：InnoDB、MyISAM、MEMORY\r\n\r\n#### 3.常用引擎的特性对比\r\n\r\n- 常用的存储引擎\r\n  - MyISAM存储引擎\r\n    - 访问快,不支持事务和外键。表结构保存在.frm文件中，表数据保存在.MYD文件中，索引保存在.MYI文件中。\r\n  - InnoDB存储引擎(MySQL5.5版本后默认的存储引擎)\r\n    - 支持事务 ,占用磁盘空间大 ,支持并发控制。表结构保存在.frm文件中，如果是共享表空间，数据和索引保存在 innodb_data_home_dir 和 innodb_data_file_path定义的表空间中，可以是多个文件。如果是多表空间存储，每个表的数据和索引单独保存在 .ibd 中。\r\n  - MEMORY存储引擎\r\n    - 内存存储 , 速度快 ,不安全 ,适合小量快速访问的数据。表结构保存在.frm中。\r\n- 特性对比\r\n\r\n| 特性         | MyISAM                       | InnoDB        | MEMORY             |\r\n| ------------ | ---------------------------- | ------------- | ------------------ |\r\n| 存储限制     | 有(平台对文件系统大小的限制) | 64TB          | 有(平台的内存限制) |\r\n| **事务安全** | **不支持**                   | **支持**      | **不支持**         |\r\n| **锁机制**   | **表锁**                     | **表锁/行锁** | **表锁**           |\r\n| B+Tree索引   | 支持                         | 支持          | 支持               |\r\n| 哈希索引     | 不支持                       | 不支持        | 支持               |\r\n| 全文索引     | 支持                         | 支持          | 不支持             |\r\n| **集群索引** | **不支持**                   | **支持**      | **不支持**         |\r\n| 数据索引     | 不支持                       | 支持          | 支持               |\r\n| 数据缓存     | 不支持                       | 支持          | N/A                |\r\n| 索引缓存     | 支持                         | 支持          | N/A                |\r\n| 数据可压缩   | 支持                         | 不支持        | 不支持             |\r\n| 空间使用     | 低                           | 高            | N/A                |\r\n| 内存使用     | 低                           | 高            | 中等               |\r\n| 批量插入速度 | 高                           | 低            | 高                 |\r\n| **外键**     | **不支持**                   | **支持**      | **不支持**         |\r\n\r\n#### 4.引擎的操作\r\n\r\n- 查询数据库支持的引擎\r\n\r\n```mysql\r\n-- 标准语法\r\nSHOW ENGINES;\r\n\r\n-- 查询数据库支持的存储引擎\r\nSHOW ENGINES;\r\n```\r\n\r\n```mysql\r\n-- 表含义:\r\n  - support : 指服务器是否支持该存储引擎\r\n  - transactions : 指存储引擎是否支持事务\r\n  - XA : 指存储引擎是否支持分布式事务处理\r\n  - Savepoints : 指存储引擎是否支持保存点\r\n```\r\n\r\n- 查询某个数据库中所有数据表的引擎\r\n\r\n```mysql\r\n-- 标准语法\r\nSHOW TABLE STATUS FROM 数据库名称;\r\n\r\n-- 查看db9数据库所有表的存储引擎\r\nSHOW TABLE STATUS FROM db9;\r\n```\r\n\r\n- 查询某个数据库中某个数据表的引擎\r\n\r\n```mysql\r\n-- 标准语法\r\nSHOW TABLE STATUS FROM 数据库名称 WHERE NAME = \'数据表名称\';\r\n\r\n-- 查看db9数据库中stu_score表的存储引擎\r\nSHOW TABLE STATUS FROM db9 WHERE NAME = \'stu_score\';\r\n```\r\n\r\n- 创建数据表，指定存储引擎\r\n\r\n```mysql\r\n-- 标准语法\r\nCREATE TABLE 表名(\r\n\t列名,数据类型,\r\n    ...\r\n)ENGINE = 引擎名称;\r\n\r\n-- 创建db11数据库\r\nCREATE DATABASE db11;\r\n\r\n-- 使用db11数据库\r\nUSE db11;\r\n\r\n-- 创建engine_test表，指定存储引擎为MyISAM\r\nCREATE TABLE engine_test(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tNAME VARCHAR(10)\r\n)ENGINE = MYISAM;\r\n\r\n-- 查询engine_test表的引擎\r\nSHOW TABLE STATUS FROM db11 WHERE NAME = \'engine_test\';\r\n```\r\n\r\n- 修改表的存储引擎\r\n\r\n```mysql\r\n-- 标准语法\r\nALTER TABLE 表名 ENGINE = 引擎名称;\r\n\r\n-- 修改engine_test表的引擎为InnoDB\r\nALTER TABLE engine_test ENGINE = INNODB;\r\n\r\n-- 查询engine_test表的引擎\r\nSHOW TABLE STATUS FROM db11 WHERE NAME = \'engine_test\';\r\n```\r\n\r\n#### 5.总结：引擎的选择\r\n\r\n- MyISAM ：由于MyISAM不支持事务、不支持外键、支持全文检索和表级锁定，读写相互阻塞，读取速度快，节约资源，所以如果应用是以**查询操作**和**插入操作**为主，只有很少的**更新和删除**操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。\r\n- InnoDB : 是MySQL的默认存储引擎， 由于InnoDB支持事务、支持外键、行级锁定 ，支持所有辅助索引(5.5.5后不支持全文检索)，高缓存，所以用于对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，读写频繁的操作，那么InnoDB存储引擎是比较合适的选择，比如BBS、计费系统、充值转账等\r\n- MEMORY：将所有数据保存在RAM中，在需要快速定位记录和其他类似数据环境下，可以提供更快的访问。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。MEMORY表通常用于更新不太频繁的小表，用以快速得到访问结果。\r\n- 总结：针对不同的需求场景，来选择最适合的存储引擎即可！如果不确定、则使用数据库默认的存储引擎！\r\n\r\n### 二、MySQL索引\r\n\r\n#### 1.索引的概念\r\n\r\n- 我们之前学习过集合，其中的ArrayList集合的特点之一就是有索引。那么有索引会带来哪些好处呢？\r\n- 没错，查询数据快！我们可以通过索引来快速查找到想要的数据。那么对于我们的MySQL数据库中的索引功能也是类似的！\r\n- MySQL数据库中的索引：是帮助MySQL高效获取数据的一种数据结构！所以，索引的本质就是数据结构。\r\n- 在表数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式指向数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。\r\n- 一张数据表，用于保存数据。   一个索引配置文件，用于保存索引，每个索引都去指向了某一个数据(表格演示)\r\n- 举例，无索引和有索引的查找原理\r\n\r\n![04](./img/sql/mysql/MySQL高级-04-授课笔记.assets/04.png)\r\n\r\n#### 2.索引的分类\r\n\r\n- 功能分类 \r\n  - 普通索引： 最基本的索引，它没有任何限制。\r\n  - 唯一索引：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值组合必须唯一。\r\n  - 主键索引：一种特殊的唯一索引，不允许有空值。一般在建表时同时创建主键索引。\r\n  - 组合索引：顾名思义，就是将单列索引进行组合。\r\n  - 外键索引：只有InnoDB引擎支持外键索引，用来保证数据的一致性、完整性和实现级联操作。\r\n  - 全文索引：快速匹配全部文档的方式。InnoDB引擎5.6版本后才支持全文索引。MEMORY引擎不支持。\r\n- 结构分类\r\n  - B+Tree索引 ：MySQL使用最频繁的一个索引数据结构，是InnoDB和MyISAM存储引擎默认的索引类型。\r\n  - Hash索引 : MySQL中Memory存储引擎默认支持的索引类型。\r\n\r\n#### 3.索引的操作\r\n\r\n- 数据准备\r\n\r\n```mysql\r\n-- 创建db12数据库\r\nCREATE DATABASE db12;\r\n\r\n-- 使用db12数据库\r\nUSE db12;\r\n\r\n-- 创建student表\r\nCREATE TABLE student(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tNAME VARCHAR(10),\r\n\tage INT,\r\n\tscore INT\r\n);\r\n-- 添加数据\r\nINSERT INTO student VALUES (NULL,\'张三\',23,98),(NULL,\'李四\',24,95),\r\n(NULL,\'王五\',25,96),(NULL,\'赵六\',26,94),(NULL,\'周七\',27,99);\r\n```\r\n\r\n- 创建索引\r\n  - 注意：如果一个表中有一列是主键，那么就会默认为其创建主键索引！(主键列不需要单独创建索引)\r\n\r\n```mysql\r\n-- 标准语法\r\nCREATE [UNIQUE|FULLTEXT] INDEX 索引名称\r\n[USING 索引类型]  -- 默认是B+TREE\r\nON 表名(列名...);\r\n\r\n-- 为student表中姓名列创建一个普通索引\r\nCREATE INDEX idx_name ON student(NAME);\r\n\r\n-- 为student表中年龄列创建一个唯一索引\r\nCREATE UNIQUE INDEX idx_age ON student(age);\r\n```\r\n\r\n- 查看索引\r\n\r\n```mysql\r\n-- 标准语法\r\nSHOW INDEX FROM 表名;\r\n\r\n-- 查看student表中的索引\r\nSHOW INDEX FROM student;\r\n```\r\n\r\n- alter语句添加索引\r\n\r\n```mysql\r\n-- 普通索引\r\nALTER TABLE 表名 ADD INDEX 索引名称(列名);\r\n\r\n-- 组合索引\r\nALTER TABLE 表名 ADD INDEX 索引名称(列名1,列名2,...);\r\n\r\n-- 主键索引\r\nALTER TABLE 表名 ADD PRIMARY KEY(主键列名); \r\n\r\n-- 外键索引(添加外键约束，就是外键索引)\r\nALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名);\r\n\r\n-- 唯一索引\r\nALTER TABLE 表名 ADD UNIQUE 索引名称(列名);\r\n\r\n-- 全文索引(mysql只支持文本类型)\r\nALTER TABLE 表名 ADD FULLTEXT 索引名称(列名);\r\n\r\n\r\n-- 为student表中name列添加全文索引\r\nALTER TABLE student ADD FULLTEXT idx_fulltext_name(name);\r\n\r\n-- 查看student表中的索引\r\nSHOW INDEX FROM student;\r\n```\r\n\r\n- 删除索引\r\n\r\n```mysql\r\n-- 标准语法\r\nDROP INDEX 索引名称 ON 表名;\r\n\r\n-- 删除student表中的idx_score索引\r\nDROP INDEX idx_score ON student;\r\n\r\n-- 查看student表中的索引\r\nSHOW INDEX FROM student;\r\n```\r\n\r\n#### 4.索引效率的测试\r\n\r\n```mysql\r\n-- 创建product商品表\r\nCREATE TABLE product(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,  -- 商品id\r\n\tNAME VARCHAR(10),\t\t    -- 商品名称\r\n\tprice INT                           -- 商品价格\r\n);\r\n\r\n-- 定义存储函数，生成长度为10的随机字符串并返回\r\nDELIMITER $\r\n\r\nCREATE FUNCTION rand_string() \r\nRETURNS VARCHAR(255)\r\nBEGIN\r\n\tDECLARE big_str VARCHAR(100) DEFAULT \'abcdefghijklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ\';\r\n\tDECLARE small_str VARCHAR(255) DEFAULT \'\';\r\n\tDECLARE i INT DEFAULT 1;\r\n\t\r\n\tWHILE i <= 10 DO\r\n\t\tSET small_str =CONCAT(small_str,SUBSTRING(big_str,FLOOR(1+RAND()*52),1));\r\n\t\tSET i=i+1;\r\n\tEND WHILE;\r\n\t\r\n\tRETURN small_str;\r\nEND$\r\n\r\nDELIMITER ;\r\n\r\n\r\n\r\n-- 定义存储过程，添加100万条数据到product表中\r\nDELIMITER $\r\n\r\nCREATE PROCEDURE pro_test()\r\nBEGIN\r\n\tDECLARE num INT DEFAULT 1;\r\n\t\r\n\tWHILE num <= 1000000 DO\r\n\t\tINSERT INTO product VALUES (NULL,rand_string(),num);\r\n\t\tSET num = num + 1;\r\n\tEND WHILE;\r\nEND$\r\n\r\nDELIMITER ;\r\n\r\n-- 调用存储过程\r\nCALL pro_test();\r\n\r\n\r\n-- 查询总记录条数\r\nSELECT COUNT(*) FROM product;\r\n\r\n\r\n\r\n-- 查询product表的索引\r\nSHOW INDEX FROM product;\r\n\r\n-- 查询name为OkIKDLVwtG的数据   (0.049)\r\nSELECT * FROM product WHERE NAME=\'OkIKDLVwtG\';\r\n\r\n-- 通过id列查询OkIKDLVwtG的数据  (1毫秒)\r\nSELECT * FROM product WHERE id=999998;\r\n\r\n-- 为name列添加索引\r\nALTER TABLE product ADD INDEX idx_name(NAME);\r\n\r\n-- 查询name为OkIKDLVwtG的数据   (0.001)\r\nSELECT * FROM product WHERE NAME=\'OkIKDLVwtG\';\r\n\r\n\r\n/*\r\n\t范围查询\r\n*/\r\n-- 查询价格为800~1000之间的所有数据 (0.052)\r\nSELECT * FROM product WHERE price BETWEEN 800 AND 1000;\r\n\r\n/*\r\n\t排序查询\r\n*/\r\n-- 查询价格为800~1000之间的所有数据,降序排列  (0.083)\r\nSELECT * FROM product WHERE price BETWEEN 800 AND 1000 ORDER BY price DESC;\r\n\r\n-- 为price列添加索引\r\nALTER TABLE product ADD INDEX idx_price(price);\r\n\r\n-- 查询价格为800~1000之间的所有数据 (0.011)\r\nSELECT * FROM product WHERE price BETWEEN 800 AND 1000;\r\n\r\n-- 查询价格为800~1000之间的所有数据,降序排列  (0.001)\r\nSELECT * FROM product WHERE price BETWEEN 800 AND 1000 ORDER BY price DESC;\r\n```\r\n\r\n#### 5.索引的实现原则\r\n\r\n- 索引是在MySQL的存储引擎中实现的，所以每种存储引擎的索引不一定完全相同，也不是所有的引擎支持所有的索引类型。这里我们主要介绍InnoDB引擎的实现的**B+Tree索引**。\r\n- B+Tree是一种树型数据结构，是B-Tree的变种。通常使用在数据库和操作系统中的文件系统，特点是能够保持数据稳定有序。我们逐步的来了解一下。\r\n\r\n##### 5.1磁盘存储\r\n\r\n- 系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的\r\n- 位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。\r\n- InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB。\r\n- InnoDB引擎将若干个地址连接磁盘块，以此来达到页的大小16KB，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。\r\n\r\n##### 5.2BTree\r\n\r\n- BTree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述BTree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。BTree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的BTree： \r\n\r\n  ![05](./img/sql/mysql/MySQL高级-04-授课笔记.assets/05.png)\r\n\r\n- 根据图中结构显示，每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。\r\n\r\n查找顺序：\r\n\r\n```mysql\r\n模拟查找15的过程 : \r\n\r\n1.根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】\r\n\t比较关键字15在区间（<17），找到磁盘块1的指针P1。\r\n2.P1指针找到磁盘块2，读入内存。【磁盘I/O操作第2次】\r\n\t比较关键字15在区间（>12），找到磁盘块2的指针P3。\r\n3.P3指针找到磁盘块7，读入内存。【磁盘I/O操作第3次】\r\n\t在磁盘块7中找到关键字15。\r\n\t\r\n-- 分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。\r\n-- 由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个BTree查找效率的决定因素。BTree使用较少的节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。\r\n```\r\n\r\n##### 5.3B+Tree\r\n\r\n- B+Tree是在BTree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。\r\n- 从上一节中的BTree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。\r\n- B+Tree相对于BTree区别：\r\n  - 非叶子节点只存储键值信息。\r\n  - 所有叶子节点之间都有一个连接指针。\r\n  - 数据记录都存放在叶子节点中。\r\n- 将上一节中的BTree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：\r\n\r\n![06](./img/sql/mysql/MySQL高级-04-授课笔记.assets/06.png)\r\n\r\n通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：\r\n\r\n- 【有范围】对于主键的范围查找和分页查找\r\n- 【有顺序】从根节点开始，进行随机查找\r\n\r\n实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。\r\n\r\n#### 6.总结：索引的设计原则\r\n\r\n索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。\r\n\r\n- 创建索引时的原则\r\n  - 对查询频次较高，且数据量比较大的表建立索引。\r\n  - 使用唯一索引，区分度越高，使用索引的效率越高。\r\n  - 索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。\r\n  - 使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I/O效率。\r\n  - 索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。\r\n- 联合索引的特点\r\n\r\n在mysql建立联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配，\r\n对列name列、address和列phone列建一个联合索引\r\n\r\n```mysql\r\nALTER TABLE user ADD INDEX index_three(name,address,phone);\r\n```\r\n\r\n联合索引index_three实际建立了(name)、(name,address)、(name,address,phone)三个索引。所以下面的三个SQL语句都可以命中索引。\r\n\r\n```mysql\r\nSELECT * FROM user WHERE address = \'北京\' AND phone = \'12345\' AND name = \'张三\';\r\nSELECT * FROM user WHERE name = \'张三\' AND address = \'北京\';\r\nSELECT * FROM user WHERE name = \'张三\';\r\n```\r\n\r\n上面三个查询语句执行时会依照最左前缀匹配原则，检索时分别会使用索引\r\n\r\n```\r\n(name,address,phone)\r\n(name,address)\r\n(name)\r\n```\r\n\r\n进行数据匹配。\r\n\r\n索引的字段可以是任意顺序的，如：\r\n\r\n```mysql\r\n-- 优化器会帮助我们调整顺序，下面的SQL语句都可以命中索引\r\nSELECT * FROM user WHERE address = \'北京\' AND phone = \'12345\' AND name = \'张三\';\r\n```\r\n\r\nMysql的优化器会帮助我们调整where条件中的顺序，以匹配我们建立的索引。\r\n\r\n联合索引中最左边的列不包含在条件查询中，所以根据上面的原则，下面的SQL语句就不会命中索引。\r\n\r\n```mysql\r\n-- 联合索引中最左边的列不包含在条件查询中，下面的SQL语句就不会命中索引\r\nSELECT * FROM user WHERE address = \'北京\' AND phone = \'12345\';\r\n```\r\n\r\n### 三、MySQL锁\r\n\r\n#### 1.锁的概念\r\n\r\n- 之前我们学习过多线程，多线程当中如果想保证数据的准确性是如何实现的呢？没错，通过同步实现。同步就相当于是加锁。加了锁以后有什么好处呢？当一个线程真正在操作数据的时候，其他线程只能等待。当一个线程执行完毕后，释放锁。其他线程才能进行操作！\r\n\r\n- 那么我们的MySQL数据库中的锁的功能也是类似的。在我们学习事务的时候，讲解过事务的隔离性，可能会出现脏读、不可重复读、幻读的问题，当时我们的解决方式是通过修改事务的隔离级别来控制，但是数据库的隔离级别呢我们并不推荐修改。所以，锁的作用也可以解决掉之前的问题！\r\n\r\n- 锁机制 : 数据库为了保证数据的一致性，而使用各种共享的资源在被并发访问时变得有序所设计的一种规则。\r\n\r\n- 举例，在电商网站购买商品时，商品表中只存有1个商品，而此时又有两个人同时购买，那么谁能买到就是一个关键的问题。\r\n\r\n  这里会用到事务进行一系列的操作：\r\n\r\n  1. 先从商品表中取出物品的数据\r\n  2. 然后插入订单\r\n  3. 付款后，再插入付款表信息\r\n  4. 更新商品表中商品的数量\r\n\r\n  以上过程中，使用锁可以对商品数量数据信息进行保护，实现隔离，即只允许第一位用户完成整套购买流程，而其他用户只能等待，这样就解决了并发中的矛盾问题。\r\n\r\n- 在数据库中，数据是一种供许多用户共享访问的资源，如何保证数据并发访问的一致性、有效性，是所有数据库必须解决的一个问题，MySQL由于自身架构的特点，在不同的存储引擎中，都设计了面对特定场景的锁定机制，所以引擎的差别，导致锁机制也是有很大差别的。\r\n\r\n#### 2.锁的分类\r\n\r\n- 按操作分类：\r\n  - 共享锁：也叫读锁。针对同一份数据，多个事务读取操作可以同时加锁而不互相影响 ，但是不能修改数据记录。\r\n  - 排他锁：也叫写锁。当前的操作没有完成前,会阻断其他操作的读取和写入\r\n- 按粒度分类：\r\n  - 表级锁：操作时，会锁定整个表。开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低。偏向于MyISAM存储引擎！\r\n  - 行级锁：操作时，会锁定当前操作行。开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。偏向于InnoDB存储引擎！\r\n  - 页级锁：锁的粒度、发生冲突的概率和加锁的开销介于表锁和行锁之间，会出现死锁，并发性能一般。\r\n- 按使用方式分类：\r\n  - 悲观锁：每次查询数据时都认为别人会修改，很悲观，所以查询时加锁。\r\n  - 乐观锁：每次查询数据时都认为别人不会修改，很乐观，但是更新时会判断一下在此期间别人有没有去更新这个数据\r\n- 不同存储引擎支持的锁\r\n\r\n| 存储引擎 | 表级锁 | 行级锁 | 页级锁 |\r\n| -------- | ------ | ------ | ------ |\r\n| MyISAM   | 支持   | 不支持 | 不支持 |\r\n| InnoDB   | 支持   | 支持   | 不支持 |\r\n| MEMORY   | 支持   | 不支持 | 不支持 |\r\n| BDB      | 支持   | 不支持 | 支持   |\r\n\r\n#### 3.演示InnoDB锁\r\n\r\n- 数据准备\r\n\r\n```mysql\r\n-- 创建db13数据库\r\nCREATE DATABASE db13;\r\n\r\n-- 使用db13数据库\r\nUSE db13;\r\n\r\n-- 创建student表\r\nCREATE TABLE student(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tNAME VARCHAR(10),\r\n\tage INT,\r\n\tscore INT\r\n);\r\n-- 添加数据\r\nINSERT INTO student VALUES (NULL,\'张三\',23,99),(NULL,\'李四\',24,95),\r\n(NULL,\'王五\',25,98),(NULL,\'赵六\',26,97);\r\n```\r\n\r\n- 共享锁\r\n\r\n```mysql\r\n-- 标准语法\r\nSELECT语句 LOCK IN SHARE MODE;\r\n```\r\n\r\n```mysql\r\n-- 窗口1\r\n/*\r\n\t共享锁：数据可以被多个事务查询，但是不能修改\r\n*/\r\n-- 开启事务\r\nSTART TRANSACTION;\r\n\r\n-- 查询id为1的数据记录。加入共享锁\r\nSELECT * FROM student WHERE id=1 LOCK IN SHARE MODE;\r\n\r\n-- 查询分数为99分的数据记录。加入共享锁\r\nSELECT * FROM student WHERE score=99 LOCK IN SHARE MODE;\r\n\r\n-- 提交事务\r\nCOMMIT;\r\n```\r\n\r\n```mysql\r\n-- 窗口2\r\n-- 开启事务\r\nSTART TRANSACTION;\r\n\r\n-- 查询id为1的数据记录(普通查询，可以查询)\r\nSELECT * FROM student WHERE id=1;\r\n\r\n-- 查询id为1的数据记录，并加入共享锁(可以查询。共享锁和共享锁兼容)\r\nSELECT * FROM student WHERE id=1 LOCK IN SHARE MODE;\r\n\r\n-- 修改id为1的姓名为张三三(不能修改，会出现锁的情况。只有窗口1提交事务后，才能修改成功)\r\nUPDATE student SET NAME=\'张三三\' WHERE id = 1;\r\n\r\n-- 修改id为2的姓名为李四四(修改成功，InnoDB引擎默认是行锁)\r\nUPDATE student SET NAME=\'李四四\' WHERE id = 2;\r\n\r\n-- 修改id为3的姓名为王五五(注意：InnoDB引擎如果不采用带索引的列。则会提升为表锁)\r\nUPDATE student SET NAME=\'王五五\' WHERE id = 3;\r\n\r\n-- 提交事务\r\nCOMMIT;\r\n```\r\n\r\n- 排他锁\r\n\r\n```mysql\r\n-- 标准语法\r\nSELECT语句 FOR UPDATE;\r\n```\r\n\r\n```mysql\r\n-- 窗口1\r\n/*\r\n\t排他锁：加锁的数据，不能被其他事务加锁查询或修改\r\n*/\r\n-- 开启事务\r\nSTART TRANSACTION;\r\n\r\n-- 查询id为1的数据记录，并加入排他锁\r\nSELECT * FROM student WHERE id=1 FOR UPDATE;\r\n\r\n-- 提交事务\r\nCOMMIT;\r\n```\r\n\r\n```mysql\r\n-- 窗口2\r\n-- 开启事务\r\nSTART TRANSACTION;\r\n\r\n-- 查询id为1的数据记录(普通查询没问题)\r\nSELECT * FROM student WHERE id=1;\r\n\r\n-- 查询id为1的数据记录，并加入共享锁(不能查询。因为排他锁不能和其他锁共存)\r\nSELECT * FROM student WHERE id=1 LOCK IN SHARE MODE;\r\n\r\n-- 查询id为1的数据记录，并加入排他锁(不能查询。因为排他锁不能和其他锁共存)\r\nSELECT * FROM student WHERE id=1 FOR UPDATE;\r\n\r\n-- 修改id为1的姓名为张三(不能修改，会出现锁的情况。只有窗口1提交事务后，才能修改成功)\r\nUPDATE student SET NAME=\'张三\' WHERE id=1;\r\n\r\n-- 提交事务\r\nCOMMIT;\r\n```\r\n\r\n- 注意：锁的兼容性\r\n  - 共享锁和共享锁     兼容\r\n  - 共享锁和排他锁     冲突\r\n  - 排他锁和排他锁     冲突\r\n  - 排他锁和共享锁     冲突\r\n\r\n#### 4.演示MyISAM锁\r\n\r\n- 数据准备\r\n\r\n```mysql\r\n-- 创建product表\r\nCREATE TABLE product(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tNAME VARCHAR(20),\r\n\tprice INT\r\n)ENGINE = MYISAM;  -- 指定存储引擎为MyISAM\r\n\r\n-- 添加数据\r\nINSERT INTO product VALUES (NULL,\'华为手机\',4999),(NULL,\'小米手机\',2999),\r\n(NULL,\'苹果\',8999),(NULL,\'中兴\',1999);\r\n```\r\n\r\n- 读锁\r\n\r\n```mysql\r\n-- 标准语法\r\n-- 加锁\r\nLOCK TABLE 表名 READ;\r\n\r\n-- 解锁(将当前会话所有的表进行解锁)\r\nUNLOCK TABLES;\r\n```\r\n\r\n```mysql\r\n-- 窗口1\r\n/*\r\n\t读锁：所有连接只能读取数据，不能修改\r\n*/\r\n-- 为product表加入读锁\r\nLOCK TABLE product READ;\r\n\r\n-- 查询product表(查询成功)\r\nSELECT * FROM product;\r\n\r\n-- 修改华为手机的价格为5999(修改失败)\r\nUPDATE product SET price=5999 WHERE id=1;\r\n\r\n-- 解锁\r\nUNLOCK TABLES;\r\n```\r\n\r\n```mysql\r\n-- 窗口2\r\n-- 查询product表(查询成功)\r\nSELECT * FROM product;\r\n\r\n-- 修改华为手机的价格为5999(不能修改，窗口1解锁后才能修改成功)\r\nUPDATE product SET price=5999 WHERE id=1;\r\n```\r\n\r\n- 写锁\r\n\r\n```mysql\r\n-- 标准语法\r\n-- 加锁\r\nLOCK TABLE 表名 WRITE;\r\n\r\n-- 解锁(将当前会话所有的表进行解锁)\r\nUNLOCK TABLES;\r\n```\r\n\r\n```mysql\r\n-- 窗口1\r\n/*\r\n\t写锁：其他连接不能查询和修改数据\r\n*/\r\n-- 为product表添加写锁\r\nLOCK TABLE product WRITE;\r\n\r\n-- 查询product表(查询成功)\r\nSELECT * FROM product;\r\n\r\n-- 修改小米手机的金额为3999(修改成功)\r\nUPDATE product SET price=3999 WHERE id=2;\r\n\r\n-- 解锁\r\nUNLOCK TABLES;\r\n```\r\n\r\n```mysql\r\n-- 窗口2\r\n-- 查询product表(不能查询。只有窗口1解锁后才能查询成功)\r\nSELECT * FROM product;\r\n\r\n-- 修改小米手机的金额为2999(不能修改。只有窗口1解锁后才能修改成功)\r\nUPDATE product SET price=2999 WHERE id=2;\r\n```\r\n\r\n#### 5.演示悲观锁和乐观锁\r\n\r\n- 悲观锁的概念\r\n\r\n  - 就是很悲观，它对于数据被外界修改的操作持保守态度，认为数据随时会修改。\r\n  - 整个数据处理中需要将数据加锁。悲观锁一般都是依靠关系型数据库提供的锁机制。\r\n  - 我们之前所学的行锁，表锁不论是读写锁都是悲观锁。\r\n\r\n- 乐观锁的概念\r\n\r\n  - 就是很乐观，每次自己操作数据的时候认为没有人会来修改它，所以不去加锁。\r\n  - 但是在更新的时候会去判断在此期间数据有没有被修改。\r\n  - 需要用户自己去实现，不会发生并发抢占资源，只有在提交操作的时候检查是否违反数据完整性。\r\n\r\n- 悲观锁和乐观锁使用前提\r\n\r\n  - 对于读的操作远多于写的操作的时候，这时候一个更新操作加锁会阻塞所有的读取操作，降低了吞吐量。最后还要释放锁，锁是需要一些开销的，这时候可以选择乐观锁。\r\n  - 如果是读写比例差距不是非常大或者系统没有响应不及时，吞吐量瓶颈的问题，那就不要去使用乐观锁，它增加了复杂度，也带来了业务额外的风险。这时候可以选择悲观锁。\r\n\r\n- 乐观锁的实现方式\r\n\r\n  - 版本号\r\n\r\n    - 给数据表中添加一个version列，每次更新后都将这个列的值加1。\r\n    - 读取数据时，将版本号读取出来，在执行更新的时候，比较版本号。\r\n    - 如果相同则执行更新，如果不相同，说明此条数据已经发生了变化。\r\n    - 用户自行根据这个通知来决定怎么处理，比如重新开始一遍，或者放弃本次更新。\r\n\r\n    ```mysql\r\n    -- 创建city表\r\n    CREATE TABLE city(\r\n    \tid INT PRIMARY KEY AUTO_INCREMENT,  -- 城市id\r\n    \tNAME VARCHAR(20),                   -- 城市名称\r\n    \tVERSION INT                         -- 版本号\r\n    );\r\n    \r\n    -- 添加数据\r\n    INSERT INTO city VALUES (NULL,\'北京\',1),(NULL,\'上海\',1),(NULL,\'广州\',1),(NULL,\'深圳\',1);\r\n    \r\n    -- 修改北京为北京市\r\n    -- 1.查询北京的version\r\n    SELECT VERSION FROM city WHERE NAME=\'北京\';\r\n    -- 2.修改北京为北京市，版本号+1。并对比版本号\r\n    UPDATE city SET NAME=\'北京市\',VERSION=VERSION+1 WHERE NAME=\'北京\' AND VERSION=1;\r\n    ```\r\n\r\n  - 时间戳\r\n\r\n    - 和版本号方式基本一样，给数据表中添加一个列，名称无所谓，数据类型需要是timestamp\r\n    - 每次更新后都将最新时间插入到此列。\r\n    - 读取数据时，将时间读取出来，在执行更新的时候，比较时间。\r\n    - 如果相同则执行更新，如果不相同，说明此条数据已经发生了变化。\r\n\r\n#### 6.锁的总结\r\n\r\n- 表锁和行锁\r\n\r\n  - 行锁：锁的粒度更细，加行锁的性能损耗较大。并发处理能力较高。InnoDB引擎默认支持！\r\n  - 表锁：锁的粒度较粗，加表锁的性能损耗较小。并发处理能力较低。InnoDB、MyISAM引擎支持！\r\n\r\n- InnoDB锁优化建议\r\n\r\n  - 尽量通过带索引的列来完成数据查询，从而避免InnoDB无法加行锁而升级为表锁。\r\n\r\n  - 合理设计索引，索引要尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定。\r\n  - 尽可能减少基于范围的数据检索过滤条件。\r\n  - 尽量控制事务的大小，减少锁定的资源量和锁定时间长度。\r\n  - 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率。\r\n  - 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁的产生。\r\n\r\n### 四、集群\r\n\r\n#### 1.集群的概念\r\n\r\n- 如今随着互联网的发展，数据的量级也是成指数的增长，从GB到TB到PB。对数据的各种操作也是愈加的困难，传统的关系型数据库已经无法满足快速查询与插入数据的需求。一台数据库服务器已经无法满足海量数据的存储需求，所以由多台数据库构成的数据库集群成了必然的方式。不过，为了保证数据的一致性，查询效率等，同时又要解决多台服务器间的通信、负载均衡等问题。\r\n- MyCat是一款数据库集群软件，是阿里曾经开源的知名产品——Cobar，简单的说，MyCAT就是：一个新颖的数据库中间件产品支持MySQL集群，提供高可用性数据分片集群。你可以像使用mysql一样使用mycat。对于开发人员来说根本感觉不到mycat的存在。MyCat不单单是支持MySQL，像常用的关系型数据库Oracle、SqlServer都支持。\r\n\r\n![07](./img/sql/mysql/MySQL高级-04-授课笔记.assets/07.png)\r\n\r\n#### 2.集群的原理\r\n\r\n- 我们来说个例子，大海捞针和一个水瓶里捞针，毋庸置疑水瓶里一定能更快找到针，因为它需要检索的范围更小。数据库集群也是如此原理，我们可以将一个数据量为300G的数据库数据平均拆分成3部分，每个数据库中只存储100G数据，此时用户搜索，先经过我们中间代理层，中间代理层同时发出3个请求执行查询，比如第1台返回100条数据，耗时3秒，第2台返回200条数据，耗时3秒，第3台返回500条数据，耗时3秒，此时中间件只需要在800条记录中进行筛选，即可检索出用户要的结果，此时耗时其实一共只有3秒，因为每台机器做运算的时候，都是同时执行。如果我们此时直接在300G的数据库查询，耗时10秒，那使用中间件进行集群的效率就非常明显\r\n\r\n![08](./img/sql/mysql/MySQL高级-04-授课笔记.assets/08.png)\r\n\r\n- MyCat的实现流程和这个流程大致相似。MyCat自身不存储数据，但用户每次链接数据库的时候，直接连接MyCat即可.所以我们MyCat自身其实就是个逻辑数据库，它自身还有表结构，表结构叫逻辑表。\r\n\r\n#### 3.Mycat环境搭建\r\n\r\n##### 3.1 Mycat下载和安装\r\n\r\n- 官网：`http://www.mycat.io/`\r\n\r\n  ![09](./img/sql/mysql/MySQL高级-04-授课笔记.assets/09.png)\r\n\r\n- 下载地址 : `http://dl.mycat.io/`\r\n\r\n  ![10](./img/sql/mysql/MySQL高级-04-授课笔记.assets/10.png)\r\n\r\n- 选择1.6.7.1的版本，下载到D盘，安装包入下图：\r\n\r\n  ![11](./img/sql/mysql/MySQL高级-04-授课笔记.assets/11.png)\r\n\r\n- 上传：使用SecureCRT的SFTP命令，将文件发送到Linux虚拟机root目录下：\r\n\r\n  ```java\r\n  sftp> put D:\\Mycat-server-1.6.7.1-release-20190627191042-linux.tar.gz \r\n  ```\r\n\r\n- 解压：解压mycat.tar.gz并查看\r\n\r\n  ```java\r\n  tar -zxvf mycat.tar.gz\r\n  cd mycat\r\n  ll\r\n  ```\r\n\r\n  ![12](./img/sql/mysql/MySQL高级-04-授课笔记.assets/12.png)\r\n\r\n- 授权：设置mycat权限\r\n\r\n  ```java\r\n  chmod -R 777 mycat\r\n  ```\r\n\r\n- 环境变量：配置环境变量\r\n\r\n  ```java\r\n  vi /etc/profile \r\n  // 添加\r\n  export MYCAT_HOME=/root/mycat\r\n  \r\n  // 使环境变量生效\r\n  source /etc/profile\r\n  ```\r\n\r\n- 启动mycat\r\n\r\n  ```java\r\n  // 进入bin目录\r\n  [root@localhost]# cd /root/mycat/bin\r\n  \r\n  // 执行启动命令\r\n  [root@localhost bin]# ./mycat start\r\n  ```\r\n\r\n- 查看：检测端口监听状况，Mycat的端口号是8066\r\n\r\n  ```java\r\n  [root@localhost bin]# netstat -ant|grep 8066\r\n  ```\r\n\r\n  ![13](./img/sql/mysql/MySQL高级-04-授课笔记.assets/13.png)\r\n\r\n- 连接：使用SQLYog连接Mycat\r\n\r\n![14](./img/sql/mysql/MySQL高级-04-授课笔记.assets/14.png)\r\n\r\n- 连接后显示：\r\n\r\n  ![15](./img/sql/mysql/MySQL高级-04-授课笔记.assets/15.png)\r\n\r\n##### 3.2 环境准备\r\n\r\n- 配置模型\r\n\r\n![16](./img/sql/mysql/MySQL高级-04-授课笔记.assets/16.png)\r\n\r\n- 克隆虚拟机\r\n\r\n![17](./img/sql/mysql/MySQL高级-04-授课笔记.assets/17.png)\r\n\r\n![18](./img/sql/mysql/MySQL高级-04-授课笔记.assets/18.png)\r\n\r\n![19](./img/sql/mysql/MySQL高级-04-授课笔记.assets/19.png)\r\n\r\n![20](./img/sql/mysql/MySQL高级-04-授课笔记.assets/20.png)\r\n\r\n![21](./img/sql/mysql/MySQL高级-04-授课笔记.assets/21.png)\r\n\r\n![22](./img/sql/mysql/MySQL高级-04-授课笔记.assets/22.png)\r\n\r\n![23](./img/sql/mysql/MySQL高级-04-授课笔记.assets/23.png)\r\n\r\n- 修改配置网卡\r\n\r\n  - 在第二个虚拟机中，生成全新mac地址\r\n\r\n  ![24](./img/sql/mysql/MySQL高级-04-授课笔记.assets/24.png)\r\n\r\n  ![25](./img/sql/mysql/MySQL高级-04-授课笔记.assets/25.png)\r\n\r\n  - 重启网络\r\n\r\n  ```linux\r\n  // 重启网络\r\n  service network restart\r\n  //查看ip地址\r\n  ip addr\r\n  ```\r\n\r\n- 修改mysql配置文件,更改uuid\r\n\r\n  - 在第二个服务器上，修改mysql的uuid\r\n\r\n  ```\r\n  // 编辑配置文件\r\n  vi /var/lib/mysql/auto.cnf\r\n  // 将server-uuid更改\r\n  ```\r\n\r\n- 启动MySQL并查看\r\n\r\n```\r\n//将两台服务器的防火墙关闭\r\nsystemctl stop firewalld\r\n\r\n//启动两台服务器的mysql\r\nservice mysqld restart\r\n\r\n//启动两台服务器的mycat\r\ncd /root/mycat/bin\r\n./mycat restart\r\n\r\n//查看监听端口\r\nnetstat -ant|grep 3306\r\nnetstat -ant|grep 8066\r\n\r\n//使用sqlyog测试连接\r\n```\r\n\r\n#### 4.主从复制\r\n\r\n- 主从复制的概念\r\n\r\n  - 为了使用Mycat进行读写分离，我们先要配置MySQL数据库的主从复制。\r\n  - 从服务器自动同步主服务器的数据，从而达到数据一致。\r\n  - 进而，我们可以写操作时，只操作主服务器，而读操作，就可以操作从服务器了。\r\n  - 原理：主服务器在处理数据时，生成binlog日志，通过对日志的备份，实现从服务器的数据同步。\r\n\r\n  ![26](./img/sql/mysql/MySQL高级-04-授课笔记.assets/26.png)\r\n\r\n- 主服务器的配置\r\n\r\n  - 在第一个服务器上，编辑mysql配置文件\r\n\r\n  ```\r\n  // 编辑mysql配置文件\r\n  vi /etc/my.cnf\r\n  \r\n  //在[mysqld]下面加上：\r\n  log-bin=mysql-bin # 开启复制操作\r\n  server-id=1 # master is 1\r\n  innodb_flush_log_at_trx_commit=1\r\n  sync_binlog=1\r\n  ```\r\n\r\n  - 登录mysql，创建用户并授权\r\n\r\n  ```\r\n  // 登录mysql\r\n  mysql -u root -p\r\n  \r\n  // 去除密码权限\r\n  SET GLOBAL validate_password_policy=0;\r\n  SET GLOBAL validate_password_length=1;\r\n  \r\n  // 创建用户\r\n  CREATE USER \'hm\'@\'%\' IDENTIFIED BY \'itheima\';\r\n  \r\n  // 授权\r\n  GRANT ALL ON *.* TO \'hm\'@\'%\';\r\n  ```\r\n\r\n  - 重启mysql服务，登录mysql服务\r\n\r\n  ```\r\n  // 重启mysql\r\n  service mysqld restart\r\n  \r\n  // 登录mysql\r\n  mysql -u root -p\r\n  ```\r\n\r\n  - 查看主服务器的配置\r\n\r\n  ```\r\n  // 查看主服务器配置\r\n  show master status;\r\n  ```\r\n\r\n  ![27](./img/sql/mysql/MySQL高级-04-授课笔记.assets/27.png)\r\n\r\n- 从服务器的配置\r\n\r\n  - 在第二个服务器上，编辑mysql配置文件\r\n\r\n  ```\r\n  // 编辑mysql配置文件\r\n  vi /etc/my.cnf\r\n  \r\n  // 在[mysqld]下面加上：\r\n  server-id=2\r\n  ```\r\n\r\n  - 登录mysql\r\n\r\n  ```\r\n  // 登录mysql\r\n  mysql -u root -p\r\n  \r\n  // 执行\r\n  use mysql;\r\n  drop table slave_master_info;\r\n  drop table slave_relay_log_info;\r\n  drop table slave_worker_info;\r\n  drop table innodb_index_stats;\r\n  drop table innodb_table_stats;\r\n  source /usr/share/mysql/mysql_system_tables.sql;\r\n  ```\r\n\r\n  - 重启mysql，重新登录，配置从节点\r\n\r\n  ```\r\n  // 重启mysql\r\n  service mysqld restart\r\n  \r\n  // 重新登录mysql\r\n  mysql -u root -p\r\n  \r\n  // 执行\r\n  change master to master_host=\'主服务器ip地址\',master_port=3306,master_user=\'hm\',master_password=\'itheima\',master_log_file=\'mysql-bin.000001\',master_log_pos=4642;\r\n  ```\r\n\r\n  - 重启mysql，重新登录，开启从节点\r\n\r\n  ```\r\n  // 重启mysql\r\n  service mysqld restart\r\n  \r\n  // 重新登录mysql\r\n  mysql -u root -p\r\n  \r\n  // 开启从节点\r\n  start slave;\r\n  \r\n  // 查询结果\r\n  show slave status\\G;\r\n  //Slave_IO_Running和Slave_SQL_Running都为yes才表示同步成功。\r\n  ```\r\n\r\n  ![28](./img/sql/mysql/MySQL高级-04-授课笔记.assets/28.png)\r\n\r\n- 测试\r\n\r\n  - sqlyog连接主服务器\r\n\r\n  ```mysql\r\n  -- 主服务器创建db1数据库,从服务器会自动同步\r\n  CREATE DATABASE db1;\r\n  ```\r\n\r\n  - sqlyog连接从服务器\r\n\r\n  ```mysql\r\n  -- 从服务器创建db2数据库,主服务器不会自动同步\r\n  CREATE DATABASE db2;\r\n  ```\r\n\r\n- 启动失败的解决方案\r\n\r\n```\r\n启动失败：Slave_IO_Running为 NO \r\n方法一:重置slave\r\nslave stop;\r\nreset slave;\r\nstart slave ;\r\n方法二:重设同步日志文件及读取位置\r\nslave stop;\r\nchange master to master_log_file=’mysql-bin.000001’, master_log_pos=1;\r\nstart slave ;\r\n```\r\n\r\n#### 5.读写分离\r\n\r\n- 读写分离的概念\r\n  - 写操作只写入主服务器，读操作读取从服务器。\r\n\r\n- 在主服务器上修改server.xml\r\n  - user标签主要用于定义登录mycat的用户和权限。如上面定义用户名mycat和密码123456，该用户可以访问的schema的HEIMADB逻辑库。\r\n\r\n```xml\r\n<user name="root" defaultAccount="true">\r\n\t\t<property name="password">123456</property>\r\n\t\t<property name="schemas">HEIMADB</property>\r\n\t\t\r\n\t\t\x3c!-- 表级 DML 权限设置 --\x3e\r\n\t\t\x3c!-- \t\t\r\n\t\t<privileges check="false">\r\n\t\t\t<schema name="TESTDB" dml="0110" >\r\n\t\t\t\t<table name="tb01" dml="0000"></table>\r\n\t\t\t\t<table name="tb02" dml="1111"></table>\r\n\t\t\t</schema>\r\n\t\t</privileges>\t\t\r\n\t\t --\x3e\r\n</user>\r\n```\r\n\r\n- 在主服务器上修改schema.xml\r\n\r\n```xml\r\n<?xml version="1.0"?>\r\n<!DOCTYPE mycat:schema SYSTEM "schema.dtd">\r\n<mycat:schema xmlns:mycat="http://io.mycat/">\r\n\r\n\t<schema name="HEIMADB" checkSQLschema="false" sqlMaxLimit="100" dataNode="dn1"></schema>\r\n\t\r\n\t<dataNode name="dn1" dataHost="localhost1" database="db1" />\r\n\t\r\n\t<dataHost name="localhost1" maxCon="1000" minCon="10" balance="1"\r\n\t\t\t  writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">\r\n\t\t<heartbeat>select user()</heartbeat>\r\n\t\t\x3c!-- 主服务器进行写操作 --\x3e\r\n\t\t<writeHost host="hostM1" url="localhost:3306" user="root"\r\n\t\t\t\t   password="itheima">\r\n\t\t\x3c!-- 从服务器负责读操作 --\x3e\r\n\t\t<readHost host="hostS1" url="192.168.203.135:3306" user="root" password="itheima" />\r\n\t\t</writeHost>\r\n\t</dataHost>\r\n\t\r\n</mycat:schema>\r\n```\r\n\r\n- 配置详解\r\n\r\n  - schema标签逻辑库的概念和mysql数据库中Datebase的概念相同，我们在查询这两个逻辑库中的表的时候，需要切换到该逻辑库下才可以查到所需要的表。\r\n  - dataNode属性：该属性用于绑定逻辑库到某个具体的database上。\r\n  - dataNode标签： dataNode标签定义了mycat中的数据节点，也就是数据分片。一个dataNode标签就是一个独立的数据分片。\r\n  - name属性：定义数据节点的名字，这个名字需要是唯一的，我们需要在table标签上应用这个名字，来建立表与分片对应的关系。\r\n  - dataHost属性：该属性用于定义该分片属于那个数据库实例，属性值是引用datahost标签定义的name属性。\r\n  - database属性：该属性用于定义该分片属于那个具体数据库实例上的具体库，因为这里使用两个纬度来定义分片，就是：实例+具体的库。因为每个库上建立的表和表结构是一样的。所以这样做就可以轻松的对表进行水平拆分。\r\n  - dataHost标签：该标签在mycat逻辑库中也是作为最底层的标签存在，直接定义了具体的数据库实例、读写分离配置和心跳语句。\r\n\r\n  - balance属性： 负载均衡类型\r\n    ​    balance=0: 不开启读写分离，所有读操作都发送到当前可用的writeHost上。\r\n    ​    balance=1: 全部的readHost与Stand by writeHost都参与select语句的负载均衡\r\n    ​     balance=2: 所有的读操作都随机在writeHost，readHost上分发。\r\n    ​     balance=3: 所有的读请求都随机分配到writeHost对应的readHost上执行，writeHost不负担读压力。\r\n  - switchType属性： \r\n    ​    -1：表示不自动切换。\r\n    ​    1  ：默认值，表示自动切换\r\n    ​    2：表示基于MySQL主从同步状态决定是否切换，心跳语句： show slave status.\r\n    ​    3:表示基于mysql galary cluster的切换机制，适合mycat1.4之上的版本，心跳语句show status like "%esrep%";\r\n  - writeHost标签，readHost标签：这两个标签指定后端数据库的相关配置给mycat，用于实例化后端连接池。唯一不同的是，writeHost指定写实例、readHost指定读实例，组合这些读写实例来满足系统的要求。\r\n    - host属性：用于标识不同的实例，对于writehost，一般使用*M1；对于readhost一般使用*S1.\r\n    - url属性：后端实例连接地址，如果使用native的dbDriver，则一般为address:port这种形式，用JDBC或其他的dbDriver，则需要特殊指定。当使用JDBC时则可以这么写：jdbc:mysql://localhost:3306/。\r\n    - user属性：后端存储实例的用户名。\r\n    - password属性：后端存储实例的密码\r\n\r\n- 测试\r\n\r\n  - 重启主服务器的mycat\r\n\r\n  ```\r\n  // 重启mycat\r\n  cd /root/mycat/bin\r\n  \r\n  ./mycat restart\r\n  \r\n  // 查看端口监听\r\n  netstat -ant|grep 8066\r\n  ```\r\n\r\n  - sqlyog连接mycat\r\n\r\n  ```mysql\r\n  -- 创建学生表\r\n  CREATE TABLE student(\r\n  \tid INT PRIMARY KEY AUTO_INCREMENT,\r\n  \tNAME VARCHAR(10)\r\n  );\r\n  -- 查询学生表\r\n  SELECT * FROM student;\r\n  \r\n  -- 添加两条记录\r\n  INSERT INTO student VALUES (NULL,\'张三\'),(NULL,\'李四\');\r\n  \r\n  -- 停止主从复制后，添加的数据只会保存到主服务器上。\r\n  INSERT INTO student VALUES (NULL,\'王五\');\r\n  ```\r\n\r\n  - sqlyog连接主服务器\r\n\r\n  ```mysql\r\n  -- 主服务器：查询学生表，可以看到数据\r\n  SELECT * FROM student;\r\n  ```\r\n\r\n  - sqlyog连接从服务器\r\n\r\n  ```mysql\r\n  -- 从服务器：查询学生表，可以看到数据(因为有主从复制)\r\n  SELECT * FROM student;\r\n  \r\n  -- 从服务器：删除一条记录。(主服务器并没有删除，mycat中间件查询的结果是从服务器的数据)\r\n  DELETE FROM student WHERE id=2;\r\n  ```\r\n\r\n#### 6.分库分表\r\n\r\n- 分库分表的概念\r\n\r\n  - 将庞大的数据进行拆分\r\n  - 水平拆分：根据表的数据逻辑关系，将同一表中的数据按照某种条件，拆分到多台数据库服务器上，也叫做横向拆分。例如：一张1000万的大表，按照一模一样的结构，拆分成4个250万的小表，分别保存到4个数据库中。\r\n  - 垂直拆分：根据业务的维度，将不同的表切分到不同的数据库之上，也叫做纵向拆分。例如：所有的订单都保存到订单库中，所有的用户都保存到用户库中，同类型的表保存在同一库，不同的表分散在不同的库中。\r\n\r\n- Mycat水平拆分\r\n\r\n  - 修改主服务器的server.xml\r\n\r\n    - 0：本地文件方式\r\n\r\n      在mycat/conf/sequence_conf.properties文件中：\r\n      GLOBAL.MINDI=10000最小值\r\n      GLOBAL.MAXID=20000最大值，建议修改到9999999999\r\n\r\n    - 1：数据库方式\r\n\r\n      分库分表中保证全局主键自增唯一，但是需要执行mycat函数，配置sequence_db_conf.properties\r\n\r\n    - 2：时间戳方式\r\n\r\n      mycat实现的时间戳，建议varchar类型，要注意id的长度\r\n\r\n  ```xml\r\n  \x3c!-- 修改主键的方式 --\x3e\r\n  <property name="sequnceHandlerType">0</property>\r\n  ```\r\n\r\n  - 修改主服务器的sequence_conf.properties\r\n\r\n  ```properties\r\n  #default global sequence\r\n  GLOBAL.HISIDS=      # 可以自定义关键字\r\n  GLOBAL.MINID=10001  # 最小值\r\n  GLOBAL.MAXID=20000  # 最大值\r\n  GLOBAL.CURID=10000\r\n  ```\r\n\r\n  - 修改主服务器的schema.xml\r\n    - table标签定义了逻辑表，所有需要拆分的表都需要在这个标签中定义。 \r\n    - rule属性：拆分规则。mod-long是拆分规则之一，主键根据服务器数量取模，在rule.xml中指定。如果是3个数据库，那么数据取模后，平均分配到三个库中。\r\n    - name属性：定义逻辑表的表名，这个名字就如同在数据库中执行create table命令指定的名字一样，同一个schema标签中定义的表名必须是唯一的。\r\n    - dataNode属性： 定义这个逻辑表所属的dataNode，该属性的值需要和dataNode标签中name属性的值相互对应。\r\n\r\n  ```xml\r\n  <?xml version="1.0"?>\r\n  <!DOCTYPE mycat:schema SYSTEM "schema.dtd">\r\n  <mycat:schema xmlns:mycat="http://io.mycat/">\r\n  \r\n  \t<schema name="HEIMADB" checkSQLschema="false" sqlMaxLimit="100">\r\n  \t\t<table name="product" primaryKey="id" dataNode="dn1,dn2,dn3" rule="mod-long"/>\r\n  \t</schema>\r\n  \t\r\n  \t<dataNode name="dn1" dataHost="localhost1" database="db1" />\r\n  \t<dataNode name="dn2" dataHost="localhost1" database="db2" />\r\n  \t<dataNode name="dn3" dataHost="localhost1" database="db3" />\r\n  \t\r\n  \t<dataHost name="localhost1" maxCon="1000" minCon="10" balance="1"\r\n  \t\t\t  writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">\r\n  \t\t<heartbeat>select user()</heartbeat>\r\n  \t\t\x3c!-- write --\x3e\r\n  \t\t<writeHost host="hostM1" url="localhost:3306" user="root"\r\n  \t\t\t\t   password="itheima">\r\n  \t\t\x3c!-- read --\x3e\r\n  \t\t<readHost host="hostS1" url="192.168.203.135:3306" user="root" password="itheima" />\r\n  \t\t</writeHost>\r\n  \t</dataHost>\r\n  \t\r\n  </mycat:schema>\r\n  ```\r\n\r\n  - 修改主服务器的rule.xml\r\n\r\n  ```xml\r\n  <function name="mod-long" class="io.mycat.route.function.PartitionByMod">\r\n  \t\t\x3c!-- 数据库的数量 --\x3e\r\n  \t\t<property name="count">3</property>\r\n  </function>\r\n  ```\r\n\r\n  - 测试\r\n\r\n    - mycat操作\r\n\r\n    ```mysql\r\n    -- 创建product表\r\n    CREATE TABLE product(\r\n    \tid INT PRIMARY KEY AUTO_INCREMENT,\r\n    \tNAME VARCHAR(20),\r\n    \tprice INT\r\n    );\r\n    \r\n    -- 添加6条数据\r\n    INSERT INTO product(id,NAME,price) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,\'苹果手机\',6999);\r\n    INSERT INTO product(id,NAME,price) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,\'华为手机\',5999); \r\n    INSERT INTO product(id,NAME,price) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,\'三星手机\',4999); \r\n    INSERT INTO product(id,NAME,price) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,\'小米手机\',3999); \r\n    INSERT INTO product(id,NAME,price) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,\'中兴手机\',2999); \r\n    INSERT INTO product(id,NAME,price) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,\'OOPO手机\',1999); \r\n    \r\n    -- 查询product表\r\n    SELECT * FROM product; \r\n    ```\r\n\r\n    - 主服务器操作\r\n\r\n    ```mysql\r\n    -- 在不同数据库中查询product表\r\n    SELECT * FROM product;\r\n    ```\r\n\r\n    - 从服务器操作\r\n\r\n    ```mysql\r\n    -- 在不同数据库中查询product表\r\n    SELECT * FROM product;\r\n    ```\r\n\r\n- Mycat垂直拆分\r\n\r\n  - 修改主服务器的schema\r\n\r\n  ```xml\r\n  <?xml version="1.0"?>\r\n  <!DOCTYPE mycat:schema SYSTEM "schema.dtd">\r\n  <mycat:schema xmlns:mycat="http://io.mycat/">\r\n  \r\n  \t<schema name="HEIMADB" checkSQLschema="false" sqlMaxLimit="100">\r\n  \t\t<table name="product" primaryKey="id" dataNode="dn1,dn2,dn3" rule="mod-long"/>\r\n  \t\t\r\n  \t\t\x3c!-- 动物类数据表 --\x3e\r\n  \t\t<table name="dog" primaryKey="id" autoIncrement="true" dataNode="dn4" />\r\n  \t\t<table name="cat" primaryKey="id" autoIncrement="true" dataNode="dn4" />\r\n      \r\n         \x3c!-- 水果类数据表 --\x3e\r\n  \t\t<table name="apple" primaryKey="id" autoIncrement="true" dataNode="dn5" />\r\n  \t\t<table name="banana" primaryKey="id" autoIncrement="true" dataNode="dn5" />\r\n  \t</schema>\r\n  \t\r\n  \t<dataNode name="dn1" dataHost="localhost1" database="db1" />\r\n  \t<dataNode name="dn2" dataHost="localhost1" database="db2" />\r\n  \t<dataNode name="dn3" dataHost="localhost1" database="db3" />\r\n  \t\r\n  \t<dataNode name="dn4" dataHost="localhost1" database="db4" />\r\n  \t<dataNode name="dn5" dataHost="localhost1" database="db5" />\r\n  \t\r\n  \t<dataHost name="localhost1" maxCon="1000" minCon="10" balance="1"\r\n  \t\t\t  writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">\r\n  \t\t<heartbeat>select user()</heartbeat>\r\n  \t\t\x3c!-- write --\x3e\r\n  \t\t<writeHost host="hostM1" url="localhost:3306" user="root"\r\n  \t\t\t\t   password="itheima">\r\n  \t\t\x3c!-- read --\x3e\r\n  \t\t<readHost host="hostS1" url="192.168.203.135:3306" user="root" password="itheima" />\r\n  \t\t</writeHost>\r\n  \t</dataHost>\r\n  \t\r\n  </mycat:schema>\r\n  ```\r\n\r\n  - 测试\r\n\r\n    - sqlyog连接mycat\r\n\r\n    ```mysql\r\n    -- 创建dog表\r\n    CREATE TABLE dog(\r\n    \tid INT PRIMARY KEY AUTO_INCREMENT,\r\n    \tNAME VARCHAR(10)\r\n    );\r\n    -- 添加数据\r\n    INSERT INTO dog(id,NAME) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,\'哈士奇\');\r\n    -- 查询dog表\r\n    SELECT * FROM dog;\r\n    \r\n    \r\n    -- 创建cat表\r\n    CREATE TABLE cat(\r\n    \tid INT PRIMARY KEY AUTO_INCREMENT,\r\n    \tNAME VARCHAR(10)\r\n    );\r\n    -- 添加数据\r\n    INSERT INTO cat(id,NAME) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,\'波斯猫\');\r\n    -- 查询cat表\r\n    SELECT * FROM cat;\r\n    \r\n    \r\n    \r\n    -- 创建apple表\r\n    CREATE TABLE apple(\r\n    \tid INT PRIMARY KEY AUTO_INCREMENT,\r\n    \tNAME VARCHAR(10)\r\n    );\r\n    -- 添加数据\r\n    INSERT INTO apple(id,NAME) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,\'红富士\');\r\n    -- 查询apple表\r\n    SELECT * FROM apple;\r\n    \r\n    \r\n    -- 创建banana表\r\n    CREATE TABLE banana(\r\n    \tid INT PRIMARY KEY AUTO_INCREMENT,\r\n    \tNAME VARCHAR(10)\r\n    );\r\n    -- 添加数据\r\n    INSERT INTO banana(id,NAME) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,\'香蕉\');\r\n    -- 查询banana表\r\n    SELECT * FROM banana;\r\n    ```\r\n\r\n    - sqlyog连接主服务器\r\n\r\n    ```mysql\r\n    -- 查询dog表\r\n    SELECT * FROM dog;\r\n    -- 查询cat表\r\n    SELECT * FROM cat;\r\n    \r\n    \r\n    -- 查询apple表\r\n    SELECT * FROM apple;\r\n    -- 查询banana表\r\n    SELECT * FROM banana;\r\n    ```\r\n\r\n    - sqlyog连接从服务器\r\n\r\n    ```mysql\r\n    -- 查询dog表\r\n    SELECT * FROM dog;\r\n    -- 查询cat表\r\n    SELECT * FROM cat;\r\n    \r\n    \r\n    -- 查询apple表\r\n    SELECT * FROM apple;\r\n    -- 查询banana表\r\n    SELECT * FROM banana;\r\n    ```\r\n',ln={data:function(){return{MainComponent:dn}}},Tn=ln,Rn=Object(T["a"])(Tn,an,on,!1,null,"61501579",null),cn=Rn.exports,Ln=t("1b62"),mn={mixins:[Ln["a"]],components:{m1:c,m2:S,m3:C,m5:q,m6:H,m7:W,m8:z,m9:En,m10:cn},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"基本",value:"m1"},{label:"常见错误",value:"m2"},{label:"常规语句",value:"m3"},{label:"LINUX 安装 5.7 mysql",value:"m5"},{label:"MySQL数据类型",value:"m7"},{label:"MySQL基础",value:"m6"},{label:"MySQL进阶",value:"m8"},{label:"MySQL高级1",value:"m9"},{label:"MySQL高级2",value:"m10"}]}}},An=mn,un=Object(T["a"])(An,E,a,!1,null,"33669a8e",null),Nn=un.exports,Sn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t(""+n.tab,{tag:"component"})],1)},yn=[],pn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},In=[],On='\x3c!--\n * @Date           : 2021-04-19 00:11:26\n * @FilePath       : /jinnian-space/src/pages/sql/module/redis/md/第一章 Redis基础.md\n * @Description    : \n--\x3e\n\n\n# 第一章 Redis基础\n\n**课程计划**\n\n| 1. Redis 入 门         | **（了解）** | **（操作）** |              |\n| ---------------------- | ------------ | ------------ | ------------ |\n| 2. 数据类型            | **（重点）** | **（操作）** | **（理解）** |\n| 3. 常用指令            |              | **（操作）** |              |\n| 4. Jedis               | **（重点）** | **（操作）** |              |\n| 5. 持 久 化            | **（重点）** |              | **（理解）** |\n| 6. 数据删除与淘汰策略  |              |              | **（理解）** |\n| 7. 主从复制            | **（重点）** | **（操作）** | **（理解）** |\n| 8. 哨 兵               | **（重点）** | **（操作）** | **（理解）** |\n| 9. Cluster集群方案     | **（重点）** | **（操作）** | **（理解）** |\n| 10. 企业级缓存解决方案 | **（重点）** |              | **（理解）** |\n| 11. 性能指标监控       | **（了解）** |              |              |\n\n## 学习目标：\n\n目标1：能够说出NoSQL的概念，redis的应用场景，能够完成redis的下载安装与启动以及一些常用的配置\n\n目标2：能够说出redis常用的5种数据类型，对应这些数据类型的基本操作，应用场景及对应的解决方案\n\n目标3：能够说出redis中常用的一些基本指令\n\n目标4：能够使用jedis完成客户端应用程序的开发\n\n目标5：能够说出redis数据持久化的两种方式，各自相关的操作配置及指令，以及两种方式的优缺点比较\n\n## 1. Redis 简介\n\n在这个部分，我们将学习以下3个部分的内容，分别是：\n\n◆ Redis 简介（NoSQL概念、Redis概念）\n\n◆ Redis 的下载与安装\n\n◆ Redis 的基本操作\n\n### 1.1 NoSQL概念\n\n#### 1.1.1 问题现象\n\n在讲解NoSQL的概念之前呢，我们先来看一个现象：\n\n（1）问题现象\n\n每年到了过年期间，大家都会自觉自发的组织一场活动，叫做春运！以前我们买票都是到火车站排队，后来呢有了12306，有了他以后就更方便了，我们可以在网上买票，但是带来的问题，大家也很清楚，春节期间买票进不去，进去了刷不着票。什么原因呢，人太多了！\n  ![112555588888](./img/sql/redis/第一章Redis基础/java/redis/第一章Redis基础/12306-淘宝.png)\n\n除了这种做铁路的，它系统做的不专业以外，还有马爸爸做的淘宝，它面临一样的问题。淘宝也崩，也是用户量太大！作为我们整个电商界的东哥来说，他第一次做图书促销的时候，也遇到了服务器崩掉的这样一个现象，原因同样是因为用户量太大！\n  ![](./img/sql/redis/第一章Redis基础/京东翻车案.png)\n\n（2）现象特征\n\n再来看这几个现象，有两个非常相似的特征：\n\n第一，用户比较多，海量用户\n\n第二，高并发\n\n这两个现象出现以后，对应的就会造成我们的服务器瘫痪。核心本质是什么呢？其实并不是我们的应用服务器，而是我们的关系型数据库。关系型数据库才是最终的罪魁祸首！\n\n（3）造成原因\n\n什么样的原因导致的整个系统崩掉的呢：\n\n1.性能瓶颈：磁盘IO性能低下\n\n关系型数据库菜存取数据的时候和读取数据的时候他要走磁盘IO。磁盘这个性能本身是比较低的。\n\n2.扩展瓶颈：数据关系复杂，扩展性差，不便于大规模集群\n\n我们说关系型数据库，它里面表与表之间的关系非常复杂，不知道大家能不能想象一点，就是一张表，通过它的外键关联了七八张表，这七八张表又通过她的外件，每张又关联了四五张表。你想想，查询一下，你要想拿到数据，你就要从A到B、B到C、C到D的一直这么关联下去，最终非常影响查询的效率。同时，你想扩展下，也很难!\n\n（4）解决思路\n\n面对这样的现象，我们要想解决怎么版呢。两方面：\n\n一，降低磁盘IO次数，越低越好。\n\n二，去除数据间关系，越简单越好。\n\n降低磁盘IO次数，越低越好，怎么搞？我不用你磁盘不就行了吗？于是，内存存储的思想就提出来了，我数据不放到你磁盘里边，放内存里，这样是不是效率就高了。\n\n第二，你的数据关系很复杂，那怎么办呢？干脆简单点，我断开你的关系，我不存关系了，我只存数据，这样不就没这事了吗？\n\n把这两个特征一合并一起，就出来了一个新的概念：NoSQL\n\n#### 1.1.2 NoSQL的概念\n\n（1）概念\n\nNoSQL：即 Not-Only SQL（ 泛指非关系型的数据库），作为关系型数据库的补充。 作用：应对基于海量用户和海量数据前提下的数据处理问题。\n\n他说这句话说的非常客气，什么意思呢？就是我们数据存储要用SQL，但是呢可以不仅仅用SQL，还可以用别的东西，那别的东西叫什么呢？于是他定义了一句话叫做NoSQL。这个意思就是说我们存储数据，可以不光使用SQL，我们还可以使用非SQL的这种存储方案，这就是所谓的NoSQL。\n\n（2）特征\n\n可扩容，可伸缩。SQL数据关系过于复杂，你扩容一下难度很高，那我们Nosql 这种的，不存关系，所以它的扩容就简单一些。\n\n大数据量下高性能。包数据非常多的时候，它的性能高，因为你不走磁盘IO，你走的是内存，性能肯定要比磁盘IO的性能快一些。\n\n灵活的数据模型、高可用。他设计了自己的一些数据存储格式，这样能保证效率上来说是比较高的，最后一个高可用，我们等到集群内部分再去它！\n\n（3）常见 Nosql 数据库\n\n目前市面上常见的Nosql产品：Redis、memcache、HBase、MongoDB\n\n（4）应用场景-电商为例\n\n我们以电商为例，来看一看他在这里边起到的作用。\n\n第一类，在电商中我们的基础数据一定要存储起来，比如说商品名称，价格，生产厂商，这些都属于基础数据，这些数据放在MySQL数据库。\n\n第二类，我们商品的附加信息，比如说，你买了一个商品评价了一下，这个评价它不属于商品本身。就像你买一个苹果，“这个苹果很好吃”就是评论，但是你能说很好吃是这个商品的属性嘛？不能这么说，那只是一个人对他的评论而已。这一类数据呢，我们放在另外一个地方，我们放到MongoDB。它也可以用来加快我们的访问，他属于NoSQL的一种。\n\n第三，图片内的信息。注意这种信息相对来说比较固定，他有专用的存储区，我们一般用文件系统来存储。至于是不是分布式，要看你的系统的一个整个   瓶颈   了？如果说你发现你需要做分布式，那就做，不需要的话，一台主机就搞定了。\n\n第四，搜索关键字。为了加快搜索，我们会用到一些技术，有些人可能了解过，像分ES、Lucene、solr都属于搜索技术。那说的这么热闹，我们的电商解决方案中还没出现我们的redis啊！注意第五类信息。\n\n第五，热点信息。访问频度比较高的信息，这种东西的第二特征就是它具有波段性。换句话说他不是稳定的，它具有一个时效性的。那么这类信息放哪儿了，放到我们的redis这个解决方案中来进行存储。\n\n具体的我们从我们的整个数据存储结构的设计上来看一下。\n\n![](./img/sql/redis/第一章Redis基础/电商场景解决方案.png)\n\n我们的基础数据都存MySQL,在它的基础之上，我们把它连在一块儿，同时对外提供服务。向上走，有一些信息加载完以后,要放到我们的MongoDB中。还有一类信息，我们放到我们专用的文件系统中（比如图片），就放到我们的这个搜索专用的，如Lucene、solr及集群里边，或者用ES的这种技术里边。那么剩下来的热点信息，放到我们的redis里面。\n\n### 1.2 Redis概念\n\n#### 1.2.1 redis概念\n\n概念：Redis (REmote DIctionary Server) 是用 C 语言开发的一个开源的高性能键值对（key-value）数据库。\n\n特征：\n\n（1）数据间没有必然的关联关系；\n\n（2）内部采用单线程机制进行工作；\n\n（3）高性能。官方提供测试数据，50个并发执行100000 个请求,读的速度是110000 次/s,写的速度是81000次/s。\n\n（4）多数据类型支持\n\n \n\n|     类型       |                     |\n| -------------- | -------------------- | \n| 字符串类型   |    string            |\n| 列表类型     |     list             |\n| 散列类型     |     hash             |\n| 集合类型       |      set             |\n| 有序集合类型   |    zset/sorted_set   |\n\n（5）支持持久化，可以进行数据灾难恢复\n\n#### 1.2.2 redis的应用场景\n\n（1）为热点数据加速查询（主要场景）。如热点商品、热点新闻、热点资讯、推广类等高访问量信息等。\n\n（2）即时信息查询。如各位排行榜、各类网站访问统计、公交到站信息、在线人数信息（聊天室、网站）、设备信号等。\n\n（3）时效性信息控制。如验证码控制、投票控制等。\n\n（4）分布式数据共享。如分布式集群架构中的 session 分离\n\n（5）消息队列.\n\n### 1.3 Redis 的下载与安装\n\n后期所有资料分4中不同色块显示，详情如下：\n\n![](./img/sql/redis/第一章Redis基础/约定格式.png)\n\n#### 1.3.1 Redis 的下载与安装\n\n本课程所示，均基于Center OS7安装Redis。\n\n（1)下载Redis\n\n下载安装包：\n\n```bash\nwget http://download.redis.io/releases/redis-5.0.0.tar.gz\n```\n\n解压安装包：\n\n```bash\ntar –xvf redis-5.0.0.tar.gz\n```\n\n编译（在解压的目录中执行）：\n\n```bash\nmake\n```\n\n安装（在解压的目录中执行）：\n\n```bash\nmake install\n```\n\n（2）安装 Redis\n\nredis-server，服务器启动命令 客户端启动命令\n\nredis-cli，redis核心配置文件\n\nredis.conf，RDB文件检查工具（快照持久化文件）\n\nredis-check-dump，AOF文件修复工具\n\nredis-check-aof\n\n### 1.4 Redis服务器启动\n\n#### 1.4.1 Redis服务器启动\n\n启动服务器——参数启动\n\n```bash\nredis-server [--port port]\n```\n\n范例\n\n```bash\nredis-server --port 6379\n```\n\n启动服务器——配置文件启动\n\n```bash\nredis-server config_file_name\n```\n\n范例\n\n```bash\nredis-server redis.conf\n```\n\n#### 1.4.2 Redis客户端启动\n\n启动客户端\n\n```bash\nredis-cli [-h host] [-p port]\n```\n\n范 例\n\n```bash\nredis-cli –h 61.129.65.248 –p 6384\n```\n\n注意：服务器启动指定端口使用的是--port，客户端启动指定端口使用的是-p。-的数量不同。\n\n#### 1.4.3 Redis基础环境设置约定\n\n创建配置文件存储目录\n\n```bash\nmkdir conf\n```\n\n创建服务器文件存储目录（包含日志、数据、临时配置文件等）\n\n```bash\nmkdir data\n```\n\n创建快速访问链接\n\n```bash\nln -s redis-5.0.0 redis\n```\n\n### 1.5 配置文件启动与常用配置\n\n#### 1.5.1 服务器端设定\n\n设置服务器以守护进程的方式运行，开启后服务器控制台中将打印服务器运行信息（同日志内容相同）\n\n```bash\ndaemonize yes|no\n```\n\n绑定主机地址\n\n```bash\nbind ip\n```\n\n设置服务器端口\n\n```bash\nport port\n```\n\n设置服务器文件保存地址\n\n```bash\ndir path\n```\n\n#### 1.5.2  客户端配置\n\n 服务器允许客户端连接最大数量，默认0，表示无限制。当客户端连接到达上限后，Redis会拒绝新的连接\n\n```bash\nmaxclients count\n```\n\n客户端闲置等待最大时长，达到最大值后关闭对应连接。如需关闭该功能，设置为 0\n\n```bash\ntimeout seconds\n```\n\n#### 1.5.3  日志配置\n\n设置服务器以指定日志记录级别\n\n```bash\nloglevel debug|verbose|notice|warning\n```\n\n日志记录文件名\n\n```bash\nlogfile filename\n```\n\n注意：日志级别开发期设置为verbose即可，生产环境中配置为notice，简化日志输出量，降低写日志IO的频度。\n\n### 1.6 Redis基本操作\n\n#### 1.6.1  命令行模式工具使用思考\n\n功能性命令\n\n帮助信息查阅\n\n退出指令\n\n清除屏幕信息\n\n#### 1.6.2  信息读写\n\n设置 key，value 数据\n\n```bash\nset key value\n```\n\n范例\n\n```bash\nset name itheima\n```\n\n根据 key 查询对应的 value，如果不存在，返回空（nil）\n\n```bash\nget key\n```\n\n范例\n\n```bash\nget name\n```\n\n#### 1.6.3  帮助信息\n\n获取命令帮助文档\n\n```bash\nhelp [command]\n```\n\n范例\n\n```bash\nhelp set\n```\n\n获取组中所有命令信息名称\n\n```bash\nhelp [@group-name]\n```\n\n范例\n\n```bash\nhelp @string\n```\n\n1.6.4  退出命令行客户端模式\n\n退出客户端\n\n````bash\nquit\nexit\n````\n\n快捷键\n\n```bash\nCtrl+C\n```\n\n#### 1.6.4  redis入门总结\n\n到这里，Redis 入门的相关知识，我们就全部学习完了，再来回顾一下，这个部分我们主要讲解了哪些内容呢？\n\n首先，我们对Redis进行了一个简单介绍，包括NoSQL的概念、Redis的概念等。\n\n然后，我们介绍了Redis 的下载与安装。包括下载与安装、服务器与客户端启动、以及相关配置文件（3类）。\n\n最后，我们介绍了Redis 的基本操作。包括数据读写、退出与帮助信息获取。\n\n## 2. 数据类型\n\n在这个部分，我们将学习一共要学习三大块内容，首先需要了解一下数据类型，接下来将针对着我们要学习的数据类型进行逐一的讲解，如string、hash、list、set等，最后我们通过一个案例来总结前面的数据类型的使用场景。\n\n### 2.1  数据存储类型介绍\n\n#### 2.1.1  业务数据的特殊性\n\n在讲解数据类型之前，我们得先思考一个问题，数据类型既然是用来描述数据的存储格式的，如果你不知道哪些数据未来会进入到我们来的redis中，那么对应的数据类型的选择，你就会出现问题，我们一块来看一下：\n\n（1）原始业务功能设计\n\n秒杀。他这个里边数据变化速度特别的快，访问量也特别的高，用户大量涌入以后都会针对着一部分数据进行操作，这一类要记住。\n\n618活动。对于我们京东的618活动、以及天猫的双11活动，相信大家不用说都知道这些数据一定要进去，因为他们的访问频度实在太高了。\n\n排队购票。我们12306的票务信息。这些信息在原始设计的时候，他们就注定了要进redis。\n\n（2）运营平台监控到的突发高频访问数据\n\n此类平台临时监控到的这些数据，比如说现在出来的一个八卦的信息，这个新闻一旦出现以后呢，顺速的被围观了，那么这个时候，这个数据就会变得访量特别高，那么这类信息也要进入进去。\n\n（3）高频、复杂的统计数据\n\n在线人数。比如说直播现在很火，直播里边有很多数据，例如在线人数。进一个人出一个人，这个数据就要跳动，那么这个访问速度非常的快，而且访量很高，并且它里边有一个复杂的数据统计，在这里这种信息也要进入到我们的redis中。\n\n投票排行榜。投票投票类的信息他的变化速度也比较快，为了追求一个更快的一个即时投票的名次变化，这种数据最好也放到redis中。\n\n#### 2.1.2  Redis 数据类型(5种常用)\n\n基于以上数据特征我们进行分析，最终得出来我们的Redis中要设计5种 数据类型：\n\nstring、hash、list、set、sorted_set/zset（应用性较低）\n\n### 2.2  string数据类型\n\n在学习第一个数据类型之前，先给大家介绍一下，在随后这部分内容的学习过程中，我们每一种数据类型都分成三块来讲：首先是讲下它的基本操作，接下来讲一些它的扩展操作，最后我们会去做一个小的案例分析。\n\n#### 2.2.1Redis 数据存储格式\n\n在学习string这个数据形式之前，我们先要明白string到底是修饰什么的。我们知道redis 自身是一个 Map，其中所有的数据都是采用 key : value 的形式存储。\n\n对于这种结构来说，我们用来存储数据一定是一个值前面对应一个名称。我们通过名称来访问后面的值。按照这种形势，我们可以对出来我们的存储格式。前面这一部分我们称为key。后面的一部分称为value，而我们的数据类型，他一定是修饰value的。\n\n![](./img/sql/redis/第一章Redis基础/redis存储空间.png)\n\n数据类型指的是存储的数据的类型，也就是 value 部分的类型，key 部分永远都是字符串。\n\n#### 2.2.2  string 类型\n\n（1）存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型。\n\nstring，他就是存一个字符串儿，注意是value那一部分是一个字符串，它是redis中最基本、最简单的存储数据的格式。\n\n（2）存储数据的格式：一个存储空间保存一个数据\n\n每一个空间中只能保存一个字符串信息，这个信息里边如果是存的纯数字，他也能当数字使用，我们来看一下，这是我们的数据的存储空间。\n\n（3）存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用.\n\n![](./img/sql/redis/第一章Redis基础/redis存储空间2.png)\n\n一个key对一个value，而这个itheima就是我们所说的string类型，当然它也可以是一个纯数字的格式。\n\n#### 2.2.3  string 类型数据的基本操作\n\n（1）基础指令\n\n添加/修改数据添加/修改数据\n\n```\nset key value\n```\n\n获取数据\n\n```\nget key\n```\n\n删除数据\n\n```\ndel key\n```\n\n判定性添加数据\n\n```\nsetnx key value\n```\n\n添加/修改多个数据\n\n```\nmset key1 value1 key2 value2 …\n```\n\n获取多个数据\n\n```\nmget key1 key2 …\n```\n\n获取数据字符个数（字符串长度）\n\n```\nstrlen key\n```\n\n追加信息到原始信息后部（如果原始信息存在就追加，否则新建）\n\n```\nappend key value\n```\n\n（2）单数据操作与多数据操作的选择之惑\n\n即set 与mset的关系。这对于这两个操作来说，没有什么你应该选哪个，而是他们自己的特征是什么，你要根据这个特征去比对你的业务，看看究竟适用于哪个。\n\n![](./img/sql/redis/第一章Redis基础/set.png)\n\n假如说这是我们现在的服务器，他要向redis要数据的话，它会发出一条指令。那么当这条指令发过来的时候，比如说是这个set指令过来，那么它会把这个结果返回给你，这个时候我们要思考这里边一共经过了多长时间。\n\n首先，发送set指令要时间，这是网络的一个时间，接下来redis要去运行这个指令要消耗时间，最终把这个结果返回给你又有一个时间，这个时间又是一个网络的时间，那我们可以理解为：一个指令发送的过程中需要消耗这样的时间.\n\n但是如果说现在不是一条指令了，你要发3个set的话，还要多长时间呢？对应的发送时间要乘3了，因为这是三个单条指令,而运行的操作时间呢，它也要乘3了，但最终返回的也要发3次，所以这边也要乘3。\n\n于是我们可以得到一个结论：单指令发3条它需要的时间，假定他们两个一样，是6个网络时间加3个处理时间，如果我们把它合成一个mset呢，我们想一想。\n\n假如说用多指令发3个指令的话，其实只需要发一次就行了。这样我们可以得到一个结论，多指令发3个指令的话，其实它是两个网络时间加上3个redis的操作时间，为什么这写一个小加号呢，就是因为毕竟发的信息量变大了，所以网络时间有可能会变长。\n\n那么通过这张图，你就可以得到一个结论，我们单指令和多指令他们的差别就在于你发送的次数是多还是少。当你影响的数据比较少的时候，你可以用单指令，也可以用多指令。但是一旦这个量大了，你就要选择多指令了，他的效率会高一些。\n\n### 2.3  string 类型数据的扩展操作\n\n#### 2.3.1  string 类型数据的扩展操作\n\n下面我们来看一string的扩展操作，分成两大块：一块是对数字进行操作的，第二块是对我们的key的时间进行操作的。\n\n设置数值数据增加指定范围的值\n\n```bash\nincr key\nincrby key increment\nincrbyfloat key increment\n```\n\n设置数值数据减少指定范围的值\n\n```bash\ndecr key\ndecrby key increment\n```\n\n设置数据具有指定的生命周期\n\n```bash\nsetex key seconds value\npsetex key milliseconds value\n```\n\n#### 2.3.2  string 类型数据操作的注意事项\n\n(1)数据操作不成功的反馈与数据正常操作之间的差异\n\n表示运行结果是否成功\n\n(integer) 0  → false                 失败\n\n(integer) 1  → true                  成功\n\n表示运行结果值\n\n(integer) 3  → 3                        3个\n\n(integer) 1  → 1                         1个\n\n(2)数据未获取到时，对应的数据为（nil），等同于null\n\n(3)数据最大存储量：512MB\n\n(4)string在redis内部存储默认就是一个字符串，当遇到增减类操作incr，decr时会转成数值型进行计算\n\n(5)按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis 数值上限范围，将报错\n9223372036854775807（java中Long型数据最大值，Long.MAX_VALUE）\n\n(6)redis所有的操作都是原子性的，采用单线程处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响.\n\n### 2.4string应用场景与key命名约定\n\n#### 2.4.1  应用场景\n\n它的应用场景在于：主页高频访问信息显示控制，例如新浪微博大V主页显示粉丝数与微博数量。\n\n![](./img/sql/redis/第一章Redis基础/string应用场景.png)\n\n我们来思考一下：这些信息是不是你进入大V的页面儿以后就要读取这写信息的啊，那这种信息一定要存储到我们的redis中，因为他的访问量太高了！那这种数据应该怎么存呢？我们来一块儿看一下方案！\n\n#### 2.4.2  解决方案\n\n（1）在redis中为大V用户设定用户信息，以用户主键和属性值作为key，后台设定定时刷新策略即可。\n\n```markdown\neg:\tuser:id:3506728370:fans\t\t→\t12210947\neg:\tuser:id:3506728370:blogs\t→\t6164\neg:\tuser:id:3506728370:focuses\t→\t83\n```\n\n（2）也可以使用json格式保存数据\n\n```markdown\neg:\tuser:id:3506728370    →\t{“fans”：12210947，“blogs”：6164，“ focuses ”：83 }\n```\n\n（3） key 的设置约定\n\n数据库中的热点数据key命名惯例\n\n|       | **表名** | **主键名** | 主键值    | **字段名** |\n| ----- | -------- | ---------- | --------- | ---------- |\n| eg1： | order    | id         | 29437595  | name       |\n| eg2： | equip    | id         | 390472345 | type       |\n| eg3： | news     | id         | 202004150 | title      |\n\n### 2.5  hash的基本操作\n\n下面我们来学习第二个数据类型hash。\n\n#### 2.5.1  数据存储的困惑\n\n对象类数据的存储如果具有较频繁的更新需求操作会显得笨重！\n\n在正式学习之前，我们先来看一个关于数据存储的困惑：\n\n![](./img/sql/redis/第一章Redis基础/hash存储.png)\n\n比如说前面我们用以上形式存了数据，如果我们用单条去存的话，它存的条数会很多。但如果我们用json格式，它存一条数据就够了。问题来了，假如说现在粉丝数量发生变化了，你要把整个值都改了。但是用单条存的话就不存在这个问题，你只需要改其中一个就行了。这个时候我们就想，有没有一种新的存储结构，能帮我们解决这个问题呢。\n\n我们一块儿来分析一下：\n\n![](./img/sql/redis/第一章Redis基础/数据.png)\n\n如上图所示：单条的话是对应的数据在后面放着。仔细观察：我们看左边是不是长得都一模一样啊，都是对应的表名、ID等的一系列的东西。我们可以将右边红框中的这个区域给他封起来。\n\n那如果要是这样的形式的话，如下图，我们把它一合并，并把右边的东西给他变成这个格式，这不就行了吗？\n\n![](./img/sql/redis/第一章Redis基础/hash数据.png)\n\n这个图其实大家并不陌生，第一，你前面学过一个东西叫hashmap不就这格式吗？第二，redis自身不也是这格式吗？那是什么意思呢？注意，这就是我们要讲的第二种格式，hash。\n\n![](./img/sql/redis/第一章Redis基础/hash结构.png)\n\n在右边对应的值，我们就存具体的值，那左边儿这就是我们的key。问题来了，那中间的这一块叫什么呢？这个东西我们给他起个名儿，叫做field字段。那么右边儿整体这块儿空间我们就称为hash，也就是说hash是存了一个key value的存储空间。\n\n#### 2.5.2  hash 类型\n\n新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息\n\n需要的存储结构：一个存储空间保存多个键值对数据\n\nhash类型：底层使用哈希表结构实现数据存储\n\n![](./img/sql/redis/第一章Redis基础/hash结构图.png)\n\n如上图所示，这种结构叫做hash，左边一个key，对右边一个存储空间。这里要明确一点，右边这块儿存储空间叫hash，也就是说hash是指的一个数据类型，他指的不是一个数据，是这里边的一堆数据，那么它底层呢，是用hash表的结构来实现的。\n\n值得注意的是：\n\n如果field数量较少，存储结构优化为类数组结构\n\n如果field数量较多，存储结构使用HashMap结构\n\n#### 2.5.3  hash 类型数据的基本操作\n\n添加/修改数据\n\n```bash\nhset key field value\n```\n\n获取数据\n\n```bash\nhget key field\nhgetall key\n```\n\n删除数据\n\n```bash\nhdel key field1 [field2]\n```\n\n设置field的值，如果该field存在则不做任何操作\n\n```bash\nhsetnx key field value\n```\n\n添加/修改多个数据\n\n```bash\nhmset key field1 value1 field2 value2 …\n```\n\n获取多个数据\n\n```bash\nhmget key field1 field2 …\n```\n\n获取哈希表中字段的数量\n\n```bash\nhlen key\n```\n\n获取哈希表中是否存在指定的字段\n\n```bash\nhexists key field\n```\n\n### 2.6  hash的拓展操作\n\n在看完hash的基本操作后，我们再来看他的拓展操作，他的拓展操作相对比较简单：\n\n#### 2.6.1  hash 类型数据扩展操作\n\n获取哈希表中所有的字段名或字段值\n\n```\nhkeys key\nhvals key\n```\n\n设置指定字段的数值数据增加指定范围的值\n\n```\nhincrby key field increment\nhincrbyfloat key field increment\n```\n\n#### 2.6.2  hash类型数据操作的注意事项\n\n(1)hash类型中value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象。如果数据未获取到，对应的值为（nil）。\n\n(2）每个 hash 可以存储 232 - 1 个键值对\nhash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计 的，切记不可滥用，更不可以将hash作为对象列表使用。\n\n(3)hgetall 操作可以获取全部属性，如果内部field过多，遍历整体数据效率就很会低，有可能成为数据访问瓶颈。\n\n### 2.7  hash应用场景\n\n#### 2.7.1  应用场景\n\n双11活动日，销售手机充值卡的商家对移动、联通、电信的30元、50元、100元商品推出抢购活动，每种商品抢购上限1000  张。\n\n![](./img/sql/redis/第一章Redis基础/hash应用.png)\n\n也就是商家有了，商品有了，数量有了。最终我们的用户买东西就是在改变这个数量。那你说这个结构应该怎么存呢？对应的商家的ID作为key，然后这些充值卡的ID作为field，最后这些数量作为value。而我们所谓的操作是其实就是increa这个操作，只不过你传负值就行了。看一看对应的解决方案：\n\n#### 2.7.2  解决方案\n\n以商家id作为key\n\n将参与抢购的商品id作为field\n\n将参与抢购的商品数量作为对应的value\n\n抢购时使用降值的方式控制产品数量\n\n注意：实际业务中还有超卖等实际问题，这里不做讨论\n\n### 2.8  list基本操作\n\n前面我们存数据的时候呢，单个数据也能存，多个数据也能存，但是这里面有一个问题，我们存多个数据用hash的时候它是没有顺序的。我们平时操作，实际上数据很多情况下都是有顺序的，那有没有一种能够用来存储带有顺序的这种数据模型呢，list就专门来干这事儿。\n\n#### 2.8.1  list 类型\n\n数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分\n\n需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序\n\nlist类型：保存多个数据，底层使用双向链表存储结构实现\n\n先来通过一张图，回忆一下顺序表、链表、双向链表。\n\n![](./img/sql/redis/第一章Redis基础/list1.png)\n\nlist对应的存储结构是什么呢？里边存的这个东西是个列表，他有一个对应的名称。就是key存一个list的这样结构。对应的基本操作，你其实是可以想到的。\n\n![](./img/sql/redis/第一章Redis基础/list2.png)\n\n来看一下，因为它是双向的，所以他左边右边都能操作，它对应的操作结构两边都能进数据。这就是链表的一个存储结构。往外拿数据的时候怎么拿呢？通常是从一端拿，当然另一端也能拿。如果两端都能拿的话，这就是个双端队列，两边儿都能操作。如果只能从一端进一端出，这个模型咱们前面了解过，叫做栈。\n\n#### 2.8.2 list 类型数据基本操作\n\n最后看一下他的基本操作\n\n添加/修改数据\n\n```bash\nlpush key value1 [value2] ……\nrpush key value1 [value2] ……\n```\n\n获取数据\n\n```bash\nlrange key start stop\nlindex key index\nllen key\n```\n\n获取并移除数据\n\n```bash\nlpop key\nrpop key\n```\n\n### 2.9  list扩展操作\n\n#### 2.9.1  list 类型数据扩展操作\n\n移除指定数据\n\n```\nlrem key count value\n```\n\n规定时间内获取并移除数据\n\n```\nblpop key1 [key2] timeout\nbrpop key1 [key2] timeout\nbrpoplpush source destination timeout\n```\n\n#### 2.9.2  list 类型数据操作注意事项\n\n（1）list中保存的数据都是string类型的，数据总容量是有限的，最多232 - 1 个元素(4294967295)。\n\n（2）list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作，或以栈的形式进行入栈出栈操作\n\n（3）获取全部数据操作结束索引设置为-1\n\n（4）list可以对数据进行分页操作，通常第一页的信息来自于list，第2页及更多的信息通过数据库的形式加载\n\n\n\n### 2.10 list 应用场景\n\n#### 2.10.1  应用场景\n\n企业运营过程中，系统将产生出大量的运营数据，如何保障多台服务器操作日志的统一顺序输出？\n\n![](./img/sql/redis/第一章Redis基础/list应用.png)\n\n假如现在你有多台服务器，每一台服务器都会产生它的日志，假设你是一个运维人员，你想看它的操作日志，你怎么看呢？打开A机器的日志看一看，打开B机器的日志再看一看吗？这样的话你会可能会疯掉的！因为左边看的有可能它的时间是11:01，右边11:02，然后再看左边11:03，它们本身是连续的，但是你在看的时候就分成四个文件了，这个时候你看起来就会很麻烦。能不能把他们合并呢？答案是可以的！怎么做呢？建立起redis服务器。当他们需要记日志的时候，记在哪儿,全部发给redis。等到你想看的时候，通过服务器访问redis获取日志。然后得到以后，就会得到一个完整的日志信息。那么这里面就可以获取到完整的日志了，依靠什么来实现呢？就依靠我们的list的模型的顺序来实现。进来一组数据就往里加，谁先进来谁先加进去，它是有一定的顺序的。\n\n#### 2.10.2  解决方案\n\n依赖list的数据具有顺序的特征对信息进行管理\n\n使用队列模型解决多路信息汇总合并的问题\n\n使用栈模型解决最新消息的问题\n\n### 2.11  set 基本操作\n\n#### 2.11.1 set类型\n\n新的存储需求：存储大量的数据，在查询方面提供更高的效率\n\n需要的存储结构：能够保存大量的数据，高效的内部存储机制，便于查询\n\nset类型：与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的\n\n![](./img/sql/redis/第一章Redis基础/set模型.png)\n\n通过这个名称，大家也基本上能够认识到和我们Java中的set完全一样。我们现在要存储大量的数据，并且要求提高它的查询效率。用list这种链表形式，它的查询效率是不高的，那怎么办呢？这时候我们就想，有没有高效的存储机制。其实前面咱讲Java的时候说过hash表的结构就非常的好，但是这里边我们已经有hash了，他做了这么一个设定，干嘛呢，他把hash的存储空间给改一下，右边你原来存数据改掉,全部存空，那你说数据放哪儿了？放到原来的filed的位置，也就在这里边存真正的值，那么这个模型就是我们的set 模型。\n\nset类型：与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的。\n\n看一下它的整个结构：\n\n![](./img/sql/redis/第一章Redis基础/set4.png)\n\n#### 2.11.2 set类型数据的基本操作\n\n添加数据\n\n```bash\nsadd key member1 [member2]\n```\n\n获取全部数据\n\n```bash\nsmembers key\n```\n\n删除数据\n\n```bash\nsrem key member1 [member2]\n```\n\n获取集合数据总量\n\n```bash\nscard key\n```\n\n判断集合中是否包含指定数据\n\n```bash\nsismember key member\n```\n\n随机获取集合中指定数量的数据\n\n```bash\nsrandmember key [count]\n```\n\n随机获取集中的某个数据并将该数据移除集合\n\n```bash\nspop key [count]\n```\n\n### 2.12  set 类型数据的扩展操作\n\n#### 2.12.1  set 类型数据的扩展操作\n\n求两个集合的交、并、差集\n\n```\nsinter key1 [key2 …]  \nsunion key1 [key2 …]  \nsdiff key1 [key2 …]\n```\n\n求两个集合的交、并、差集并存储到指定集合中\n\n```\nsinterstore destination key1 [key2 …]  \nsunionstore destination key1 [key2 …]  \nsdiffstore destination key1 [key2 …]\n```\n\n将指定数据从原始集合中移动到目标集合中\n\n```\nsmove source destination member\n```\n\n通过下面一张图回忆一下交、并、差\n\n![](./img/sql/redis/第一章Redis基础/交并差.png)\n\n#### 2.12.2  set 类型数据操作的注意事项\n\nset 类型不允许数据重复，如果添加的数据在 set 中已经存在，将只保留一份。\n\nset 虽然与hash的存储结构相同，但是无法启用hash中存储值的空间。\n\n### 2.13  set应用场景\n\n#### 2.13.1  set应用场景\n\n（1）黑名单\n\n资讯类信息类网站追求高访问量，但是由于其信息的价值，往往容易被不法分子利用，通过爬虫技术，  快速获取信息，个别特种行业网站信息通过爬虫获取分析后，可以转换成商业机密进行出售。例如第三方火 车票、机票、酒店刷票代购软件，电商刷评论、刷好评。\n\n同时爬虫带来的伪流量也会给经营者带来错觉，产生错误的决策，有效避免网站被爬虫反复爬取成为每个网站都要考虑的基本问题。在基于技术层面区分出爬虫用户后，需要将此类用户进行有效的屏蔽，这就是黑名单的典型应用。\n\nps:不是说爬虫一定做摧毁性的工作，有些小型网站需要爬虫为其带来一些流量。\n\n（2）白名单\n\n对于安全性更高的应用访问，仅仅靠黑名单是不能解决安全问题的，此时需要设定可访问的用户群体， 依赖白名单做更为苛刻的访问验证。\n\n#### 2.13.2  解决方案\n\n基于经营战略设定问题用户发现、鉴别规则\n\n周期性更新满足规则的用户黑名单，加入set集合\n\n用户行为信息达到后与黑名单进行比对，确认行为去向\n\n黑名单过滤IP地址：应用于开放游客访问权限的信息源\n\n黑名单过滤设备信息：应用于限定访问设备的信息源\n\n黑名单过滤用户：应用于基于访问权限的信息源\n\n### 2.14  实践案例\n\n#### 2.14.1业务场景\n\n使用微信的过程中，当微信接收消息后，会默认将最近接收的消息置顶，当多个好友及关注的订阅号同时发 送消息时，该排序会不停的进行交替。同时还可以将重要的会话设置为置顶。一旦用户离线后，再次打开微信时，消息该按照什么样的顺序显示。\n\n我们分析一下：\n\n![](./img/sql/redis/第一章Redis基础/set案例.png)\n\n100这台手机代表你。而200、300、400这三台代表你好友的手机。在这里有一些东西需要交代一下，因为我们每个人的都会对自己的微信中的一些比较重要的人设置会话置顶，将他的那条对话放在最上面。我们假定这个人有两个会话置顶的好友，分别是400和500，而这里边就包含400.\n\n下面呢，我们就来发这个消息，第一个发消息的是300，他发了个消息给100。发完以后，这个东西应该怎么存储呢？在这里面一定要分开，记录置顶的这些人的会话，对应的会话显示顺序和非置顶的一定要分两。\n\n这里面我们创建两个模型，一个是普通的，一个是置顶的，而上面的这个置顶的用户呢，我们用set来存储，因为不重复。而下面这些因为有顺序，很容易想到用list去存储,不然你怎么表达顺序呢？\n\n![](./img/sql/redis/第一章Redis基础/300.png)\n\n那当300发给消息给100以后，这个时候我们先判定你在置顶人群中吗？不在,那好，300的消息对应的顺序就应该放在普通的列表里边。而在这里边，我们把300加进去。第一个数据也就是现在300。\n\n![](./img/sql/redis/第一章Redis基础/400.png)\n\n接下来400，发了个消息。判断一下，他是需要置顶的，所以400将进入list的置顶里边放着。当前还没有特殊的地方。\n\n![](./img/sql/redis/第一章Redis基础/200.png)\n\n再来200发消息了，和刚才的判定方法一样，先看在不在置顶里，不在的话进普通，然后在普通里边把200加入就行了，OK，到这里目前还没有顺序变化。\n\n接下来200又发消息过来，同一个人给你连发了两条，那这个时候200的消息到达以后，先判断是否在置顶范围，不在，接下来他要放在list普通中，这里你要注意一点，因为这里边已经有200，所以进来以后先干一件事儿，把200杀掉，没有200，然后再把200加进来，那你想一下，现在这个位置顺序是什么呢？就是新的都在右边，对不对？\n\n还记得我们说list模型，如果是一个双端队列，它是可以两头进两头出。当然我们双端从一头进一头出，这就是栈模型，现在咱们运用的就是list模型中的栈模型。\n\n![](./img/sql/redis/第一章Redis基础/3002.png)\n\n现在300发消息，先判定他在不在，不在，用普通的队列，接下来按照刚才的操作，不管你里边原来有没有300，我先把300杀掉，没了，200自然就填到300的位置了，他现在是list里面唯一一个，然后让300进来，注意是从右侧进来的，那么现在300就是最新的。\n\n![](./img/sql/redis/第一章Redis基础/分析.png)\n\n那么到这里呢，我们让100来读取消息。你觉得这个消息顺序应该是什么样的？首先置顶的400有一个，他跑在最上面，然后list普通如果出来的话，300是最新的消息，而200在他后面的。用这种形式，我们就可以做出来他的消息顺序来。\n\n#### 2.14.2  解决方案\n\n看一下最终的解决方案：\n\n依赖list的数据具有顺序的特征对消息进行管理，将list结构作为栈使用\n\n置顶与普通会话分别创建独立的list分别管理\n\n当某个list中接收到用户消息后，将消息发送方的id从list的一侧加入list（此处设定左侧）\n\n多个相同id发出的消息反复入栈会出现问题，在入栈之前无论是否具有当前id对应的消息，先删除对应id\n\n推送消息时先推送置顶会话list，再推送普通会话list，推送完成的list清除所有数据\n消息的数量，也就是微信用户对话数量采用计数器的思想另行记录，伴随list操作同步更新\n\n#### 2.14.3  数据类型总结\n\n总结一下，在整个数据类型的部分，我们主要介绍了哪些内容：\n\n首先我们了解了一下数据类型，接下来针对着我们要学习的数据类型，进行逐一讲解了string、hash、list、set等，最后通过一个案例总结了一下前面的数据类型的使用场景。\n\n## 3. 常用指令\n\n在这部分中呢，我们家学习两个知识，第一个是key的常用指令，第二个是数据库的常用指令。和前面我们学数据类型做一下区分，前面你学的那些指令呢，都是针对某一个数据类型操作的，现在学的都是对所有的操作的，来看一下，我们在学习Key的操作的时候，我们先想一下的操作我们应该学哪些东西:\n\n### 3.1  key 操作分析\n\n#### 3.1.1  key应该设计哪些操作？\n\nkey是一个字符串，通过key获取redis中保存的数据\n\n对于key自身状态的相关操作，例如：删除，判定存在，获取类型等\n\n对于key有效性控制相关操作，例如：有效期设定，判定是否有效，有效状态的切换等\n\n对于key快速查询操作，例如：按指定策略查询key\n\n#### 3.1.2  key 基本操作\n\n删除指定key\n\n```bash\ndel key\n```\n\n获取key是否存在\n\n```bash\nexists key\n```\n\n获取key的类型\n\n```bash\ntype key\n```\n\n3.1.3  拓展操作\n\n排序\n\n```bash\nsort\n```\n\n改名\n\n```bash\nrename key newkey\nrenamenx key newkey\n```\n\n#### 3.1.3  key 扩展操作（时效性控制）\n\n为指定key设置有效期\n\n```bash\nexpire key seconds\npexpire key milliseconds\nexpireat key timestamp\npexpireat key milliseconds-timestamp\n```\n\n获取key的有效时间\n\n```bash\nttl key\npttl key\n```\n\n切换key从时效性转换为永久性\n\n```bash\npersist key\n```\n\n#### 3.1.4  key 扩展操作（查询模式）\n\n查询key\n\n```bash\nkeys pattern\n```\n\n查询模式规则\n\n*匹配任意数量的任意符号      ?\t配合一个任意符号\t[]\t匹配一个指定符号\n\n```bash\nkeys *  keys    查询所有\nit*  keys       查询所有以it开头\n*heima          查询所有以heima结尾\nkeys ??heima    查询所有前面两个字符任意，后面以heima结尾 查询所有以\nkeys user:?     user:开头，最后一个字符任意\nkeys u[st]er:1  查询所有以u开头，以er:1结尾，中间包含一个字母，s或t\n```\n\n### 3.2  数据库指令\n\n#### 3.2.1  key 的重复问题\n\n在这个地方我们来讲一下数据库的常用指令，在讲这个东西之前，我们先思考一个问题：\n\n假如说你们十个人同时操作redis，会不会出现key名字命名冲突的问题。\n\n一定会，为什么?因为你的key是由程序而定义的。你想写什么写什么，那在使用的过程中大家都在不停的加，早晚有一天他会冲突的。\n\nredis在使用过程中，伴随着操作数据量的增加，会出现大量的数据以及对应的key。\n\n那这个问题我们要不要解决？要！怎么解决呢？我们最好把数据进行一个分类，除了命名规范我们做统一以外，如果还能把它分开，这样是不是冲突的机率就会小一些了，这就是咱们下面要说的解决方案！\n\n#### 3.2.2  解决方案\n\nredis为每个服务提供有16个数据库，编号从0到15\n\n每个数据库之间的数据相互独立\n\n![](./img/sql/redis/第一章Redis基础/数据库.png)\n\n在对应的数据库中划出一块区域，说他就是几，你就用几那块，同时，其他的这些都可以进行定义，一共是16个，这里边需要注意一点，他们这16个共用redis的内存。没有说谁大谁小，也就是说数字只是代表了一块儿区域，区域具体多大未知。这是数据库的一个分区的一个策略！\n\n#### 3.2.3   数据库的基本操作\n\n切换数据库\n\n```\nselect index\n```\n\n其他操作\n\n```\nping\n```\n\n#### 3.2.4  数据库扩展操作\n\n数据移动\n\n```\nmove key db\n```\n\n数据总量\n\n```\ndbsize\n```\n\n数据清除\n\n```\nflushdb  flushall\n```\n\n## 4. Jedis\n\n在学习完redis后，我们现在就要用Java来连接redis了，也就是我们的这一章要学的Jedis了。在这个部分，我们主要讲解以下3个内容：\n\nHelloWorld（Jedis版）\n\nJedis简易工具类开发\n\n可视化客户端\n\n### 4.1  Jedis简介\n\n#### 4.1.1  编程语言与redis\n\n![](./img/sql/redis/第一章Redis基础/jedis1.png)\n\n对于我们现在的数据来说，它是在我们的redis中，而最终我们是要做程序。那么程序就要和我们的redis进行连接。干什么事情呢？两件事：程序中有数据的时候，我们要把这些数据全部交给redis管理。同时，redis中的数据还能取出来，回到我们的应用程序中。那在这个过程中，在Java与redis之间打交道的这个东西就叫做Jedis.简单说，Jedis就是提供了Java与redis的连接服务的，里边有各种各样的API接口，你可以去调用它。\n\n除了Jedis外，还有没有其他的这种连接服务呢？其实还有很多，了解一下：\n\nJava语言连接redis服务 Jedis（SpringData、Redis 、 Lettuce）\n\n其它语言：C 、C++ 、C# 、Erlang、Lua 、Objective-C 、Perl 、PHP 、Python 、Ruby 、Scala\n\n#### 4.1.2  准备工作\n\n(1)jar包导入\n\n下载地址：https://mvnrepository.com/artifact/redis.clients/jedis\n\n基于maven\n\n```xml\n<dependency>\n<groupId>redis.clients</groupId>\n<artifactId>jedis</artifactId>\n<version>2.9.0</version>\n</dependency>\n```\n\n(2)客户端连接redis\n\n连接redis\n\n```\nJedis jedis = new Jedis("localhost", 6379);\n```\n\n操作redis\n\n```\njedis.set("name", "itheima");  jedis.get("name");\n```\n\n关闭redis连接\n\n```\njedis.close();\n```\n\nAPI文档\n\nhttp://xetorthio.github.io/jedis/\n\n#### 4.1.3 代码实现\n\n创建：com.itheima.JedisTest\n\n```java\npublic class JedisTest {\n\n    public static void main(String[] args) {\n        //1.获取连接对象\n        Jedis jedis = new Jedis("192.168.40.130",6379);\n        //2.执行操作\n        jedis.set("age","39");\n        String hello = jedis.get("hello");\n        System.out.println(hello);\n        jedis.lpush("list1","a","b","c","d");\n        List<String> list1 = jedis.lrange("list1", 0, -1);\n        for (String s:list1 ) {\n            System.out.println(s);\n        }\n        jedis.sadd("set1","abc","abc","def","poi","cba");\n        Long len = jedis.scard("set1");\n        System.out.println(len);\n        //3.关闭连接\n        jedis.close();\n    }\n}\n```\n\n\n\n### 4.2  Jedis简易工具类开发\n\n前面我们做的程序还是有点儿小问题，就是我们的Jedis对象的管理是我们自己创建的，真实企业开发中是不可能让你去new一个的，那接下来咱们就要做一个工具类，简单来说，就是做一个创建Jedis的这样的一个工具。\n\n#### 4.2.1  基于连接池获取连接\n\nJedisPool：Jedis提供的连接池技术 \n\npoolConfig:连接池配置对象 \n\nhost:redis服务地址\n\nport:redis服务端口号\n\n\n\nJedisPool的构造器如下：\n\n```java\npublic JedisPool(GenericObjectPoolConfig poolConfig, String host, int port) {\nthis(poolConfig, host, port, 2000, (String)null, 0, (String)null);\n}\n```\n\n#### 4.2.2  封装连接参数\n\n创建jedis的配置文件：jedis.properties\n\n```properties\njedis.host=192.168.40.130  \njedis.port=6379  \njedis.maxTotal=50  \njedis.maxIdle=10\n```\n\n#### 4.2.3  加载配置信息\n\n 创建JedisUtils：com.itheima.util.JedisUtils，使用静态代码块初始化资源\n\n```java\npublic class JedisUtils {\n    private static int maxTotal;\n    private static int maxIdel;\n    private static String host;\n    private static int port;\n    private static JedisPoolConfig jpc;\n    private static JedisPool jp;\n\n    static {\n        ResourceBundle bundle = ResourceBundle.getBundle("redis");\n        maxTotal = Integer.parseInt(bundle.getString("redis.maxTotal"));\n        maxIdel = Integer.parseInt(bundle.getString("redis.maxIdel"));\n        host = bundle.getString("redis.host");\n        port = Integer.parseInt(bundle.getString("redis.port"));\n        //Jedis连接池配置\n        jpc = new JedisPoolConfig();\n        jpc.setMaxTotal(maxTotal);\n        jpc.setMaxIdle(maxIdel);\n        jp = new JedisPool(jpc,host,port);\n    }\n\n}\n```\n\n#### 4.2.4  获取连接\n\n 对外访问接口，提供jedis连接对象，连接从连接池获取，在JedisUtils中添加一个获取jedis的方法：getJedis\n\n```java\npublic static Jedis getJedis(){\n\tJedis jedis = jedisPool.getResource();\n\treturn jedis;\n}\n```\n\n\n\n### 4.3  可视化客户端\n\n4.3.1  Redis Desktop Manager\n\n![](./img/sql/redis/第一章Redis基础/可视化.png)\n\n## 5. 持久化\n\n下面呢，进入到持久化的学习.这部分内容理解的东西多，操作的东西少。在这个部分，我们将讲解四个东西：\n\n持久化简介\n\nRDB\n\nAOF\n\nRDB与AOF区别\n\n### 5.1  持久化简介\n\n#### 5.1.1  场景-意外断电\n\n不知道大家有没有遇见过，就是正工作的时候停电了，如果你用的是笔记本电脑还好，你有电池，但如果你用的是台式机呢，那恐怕就比较灾难了，假如你现在正在写一个比较重要的文档，如果你要使用的是word，这种办公自动化软件的话，他一旦遇到停电，其实你不用担心，因为它会给你生成一些其他的文件。\n\n![](./img/sql/redis/第一章Redis基础/持久化案例1.png)\n\n其实他们都在做一件事儿，帮你自动恢复，有了这个文件，你前面的东西就不再丢了。那什么是自动恢复呢？你要先了解他的整个过程。\n\n我们说自动恢复，其实基于的一个前提就是他提前把你的数据给存起来了。你平常操作的所有信息都是在内存中的，而我们真正的信息是保存在硬盘中的，内存中的信息断电以后就消失了，硬盘中的信息断电以后还可以保留下来！\n\n![](./img/sql/redis/第一章Redis基础/备份.png)\n\n我们将文件由内存中保存到硬盘中的这个过程，我们叫做数据保存，也就叫做持久化。但是把它保存下来不是你的目的，最终你还要把它再读取出来，它加载到内存中这个过程，我们叫做数据恢复，这就是我们所说的word为什么断电以后还能够给你保留文件，因为它执行了一个自动备份的过程，也就是通过自动的形式，把你的数据存储起来，那么有了这种形式以后，我们的数据就可以由内存到硬盘上实现保存。\n\n#### 5.1.2  什么是持久化\n\n(1)什么是持久化\n\n利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化 。\n\n持久化用于防止数据的意外丢失，确保数据安全性。\n\n(2)持久化过程保存什么？\n\n我们知道一点，计算机中的数据全部都是二进制，如果现在我要你给我保存一组数据的话，你有什么样的方式呢，其实最简单的就是现在长什么样，我就记下来就行了，那么这种是记录纯粹的数据，也叫做快照存储，也就是它保存的是某一时刻的数据状态。\n\n还有一种形式，它不记录你的数据，它记录你所有的操作过程，比如说大家用idea的时候，有没有遇到过写错了ctrl+z撤销，然后ctrl+y还能恢复，这个地方它也是在记录，但是记录的是你所有的操作过程，那我想问一下，操作过程，我都给你留下来了，你说数据还会丢吗？肯定不会丢，因为你所有的操作过程我都保存了。这种保存操作过程的存储，用专业术语来说可以说是日志，这是两种不同的保存数据的形式啊。\n\n![](./img/sql/redis/第一章Redis基础/持久化2.png)\n\n\n\n总结一下：\n\n第一种：将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单，关注点在数据。\n\n第二种：将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂，关注点在数据的操作过程。\n\n### 5.2  RDB\n\n#### 5.2.1  save指令\n\n手动执行一次保存操作\n\n```\nsave\n```\n\n**save指令相关配置**\n\n设置本地数据库文件名，默认值为 dump.rdb，通常设置为dump-端口号.rdb\n\n```\ndbfilename filename\n```\n\n设置存储.rdb文件的路径，通常设置成存储空间较大的目录中，目录名称data\n\n```\ndir path\n```\n\n设置存储至本地数据库时是否压缩数据，默认yes，设置为no，节省 CPU 运行时间，但存储文件变大\n\n```\nrdbcompression yes|no\n```\n\n设置读写文件过程是否进行RDB格式校验，默认yes，设置为no，节约读写10%时间消耗，单存在数据损坏的风险\n\n```\nrdbchecksum yes|no\n```\n\n**save指令工作原理**\n\n![](./img/sql/redis/第一章Redis基础/rdb启动方式.png)\n\n![](./img/sql/redis/第一章Redis基础/启动方式2.png)\n\n需要注意一个问题，来看一下，现在有四个客户端各自要执行一个指令，把这些指令发送到redis服务器后，他们执行有一个先后顺序问题，假定就是按照1234的顺序放过去的话，那会是什么样的？\n\n记得redis是个单线程的工作模式，它会创建一个任务队列，所有的命令都会进到这个队列里边，在这儿排队执行，执行完一个消失一个，当所有的命令都执行完了，OK，结果达到了。\n\n但是如果现在我们执行的时候save指令保存的数据量很大会是什么现象呢？\n\n他会非常耗时，以至于影响到它在执行的时候，后面的指令都要等，所以说这种模式是不友好的，这是save指令对应的一个问题，当cpu执行的时候会阻塞redis服务器，直到他执行完毕，所以说我们不建议大家在线上环境用save指令。\n\n#### 5.2.2  bgsave指令\n\n之前我们讲到了当save指令的数据量过大时，单线程执行方式造成效率过低，那应该如何处理？\n\n此时我们可以使用：**bgsave**指令，bg其实是background的意思，后台执行的意思\n\n手动启动后台保存操作，但不是立即执行\n\n```properties\nbgsave\n```\n\n**bgsave指令相关配置**\n\n后台存储过程中如果出现错误现象，是否停止保存操作，默认yes\n\n```properties\nstop-writes-on-bgsave-error yes|no\n```\n\n其 他\n\n```properties\ndbfilename filename  \ndir path  \nrdbcompression yes|no  \nrdbchecksum yes|no\n```\n\n**bgsave指令工作原理**\n\n![](./img/sql/redis/第一章Redis基础/rdb启动方式3.png)\n\n当执行bgsave的时候，客户端发出bgsave指令给到redis服务器。注意，这个时候服务器马上回一个结果告诉客户端后台已经开始了，与此同时它会创建一个子进程，使用Linux的fork函数创建一个子进程，让这个子进程去执行save相关的操作，此时我们可以想一下，我们主进程一直在处理指令，而子进程在执行后台的保存，它会不会干扰到主进程的执行吗？\n\n答案是不会，所以说他才是主流方案。子进程开始执行之后，它就会创建啊RDB文件把它存起来，操作完以后他会把这个结果返回，也就是说bgsave的过程分成两个过程，第一个是服务端拿到指令直接告诉客户端开始执行了；另外一个过程是一个子进程在完成后台的保存操作，操作完以后回一个消息。\n\n#### 5.2.3 save配置自动执行\n\n设置自动持久化的条件，满足限定时间范围内key的变化数量达到指定数量即进行持久化\n\n```properties\nsave second changes\n```\n\n参数\n\nsecond：监控时间范围\n\nchanges：监控key的变化量\n\n范例：\n\n```markdown\nsave 900 1\nsave 300 10\nsave 60 10000\n```\n\n其他相关配置：\n\n```markdown\ndbfilename filename\ndir path\nrdbcompression yes|no\nrdbchecksum yes|no\nstop-writes-on-bgsave-error yes|no\n```\n\n**save配置工作原理**\n\n![](./img/sql/redis/第一章Redis基础/启动方式4.png)\n\n#### 5.2.4 RDB三种启动方式对比\n\n| 方式           | save指令 | bgsave指令 |\n| -------------- | -------- | ---------- |\n| 读写           | 同步     | 异步       |\n| 阻塞客户端指令 | 是       | 否         |\n| 额外内存消耗   | 否       | 是         |\n| 启动新进程     | 否       | 是         |\n\n**RDB特殊启动形式**\n\n服务器运行过程中重启\n\n```bash\ndebug reload\n```\n\n关闭服务器时指定保存数据\n\n```bash\nshutdown save\n```\n\n全量复制（在主从复制中详细讲解）\n\n\n\n**RDB优点：**\n\n- RDB是一个紧凑压缩的二进制文件，存储效率较高\n- RDB内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景\n- RDB恢复数据的速度要比AOF快很多\n- 应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。\n\n**RDB缺点**\n\n- RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大的可能性丢失数据\n- bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能\n- Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式无法兼容现象\n\n\n\n### 5.3  AOF\n\n为什么要有AOF,这得从RDB的存储的弊端说起：\n\n- 存储数据量较大，效率较低，基于快照思想，每次读写都是全部数据，当数据量巨大时，效率非常低\n- 大数据量下的IO性能较低\n- 基于fork创建子进程，内存产生额外消耗\n- 宕机带来的数据丢失风险\n\n\n\n那解决的思路是什么呢？\n\n- 不写全数据，仅记录部分数据\n- 降低区分数据是否改变的难度，改记录数据为记录操作过程\n- 对所有操作均进行记录，排除丢失数据的风险\n\n#### 5.3.1 AOF概念\n\n**AOF**(append only file)持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令 达到恢复数据的目的。**与RDB相比可以简单理解为由记录数据改为记录数据产生的变化**\n\nAOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式\n\n**AOF写数据过程**\n\n![](./img/sql/redis/第一章Redis基础/1.png)\n\n**启动AOF相关配置**\n\n开启AOF持久化功能，默认no，即不开启状态\n\n```properties\nappendonly yes|no\n```\n\nAOF持久化文件名，默认文件名为appendonly.aof，建议配置为appendonly-端口号.aof\n\n```properties\nappendfilename filename\n```\n\nAOF持久化文件保存路径，与RDB持久化文件保持一致即可\n\n```properties\ndir\n```\n\nAOF写数据策略，默认为everysec\n\n```properties\nappendfsync always|everysec|no\n```\n\n\n\n#### 5.3.2 AOF执行策略\n\nAOF写数据三种策略(appendfsync)\n\n- **always**(每次）：每次写入操作均同步到AOF文件中数据零误差，性能较低，不建议使用。\n\n\n- **everysec**（每秒）：每秒将缓冲区中的指令同步到AOF文件中，在系统突然宕机的情况下丢失1秒内的数据 数据准确性较高，性能较高，建议使用，也是默认配置\n\n\n- **no**（系统控制）：由操作系统控制每次同步到AOF文件的周期，整体过程不可控\n\n#### 5.3.3 AOF重写\n\n场景：AOF写数据遇到的问题，如果连续执行如下指令该如何处理\n\n![](./img/sql/redis/第一章Redis基础/2.png)\n\n**什么叫AOF重写？**\n\n随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积。AOF文件重 写是将Redis进程内的数据转化为写命令同步到新AOF文件的过程。简单说就是将对同一个数据的若干个条命令执行结 果转化成最终结果数据对应的指令进行记录。\n\n**AOF重写作用**\n\n- 降低磁盘占用量，提高磁盘利用率\n- 提高持久化效率，降低持久化写时间，提高IO性能\n- 降低数据恢复用时，提高数据恢复效率\n\n**AOF重写规则**\n\n- 进程内具有时效性的数据，并且数据已超时将不再写入文件\n\n\n- 非写入类的无效指令将被忽略，只保留最终数据的写入命令\n\n  如del key1、 hdel key2、srem key3、set key4 111、set key4 222等\n\n  如select指令虽然不更改数据，但是更改了数据的存储位置，此类命令同样需要记录\n\n- 对同一数据的多条写命令合并为一条命令\n\n如lpushlist1 a、lpush list1 b、lpush list1 c可以转化为：lpush list1 a b c。\n\n为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素\n\n\n\n**AOF重写方式**\n\n- 手动重写\n\n```properties\nbgrewriteaof\n```\n\n**手动重写原理分析：**\n\n![](./img/sql/redis/第一章Redis基础/3.png)\n\n\n\n- 自动重写\n\n```properties\nauto-aof-rewrite-min-size size\nauto-aof-rewrite-percentage percentage\n```\n\n自动重写触发条件设置\n\n```properties\nauto-aof-rewrite-min-size size\nauto-aof-rewrite-percentage percent\n```\n\n自动重写触发比对参数（ 运行指令info Persistence获取具体信息 ）\n\n```properties\naof_current_size  \naof_base_size\n```\n\n 自动重写触发条件公式：\n\n![](./img/sql/redis/第一章Redis基础/4.png)\n\n\n\n\n\n#### 5.3.4 AOF工作流程及重写流程\n\n![](./img/sql/redis/第一章Redis基础/AOF工作流程.png)\n\n\n\n![](./img/sql/redis/第一章Redis基础/AOF流程2.png)\n\n\n\n![](./img/sql/redis/第一章Redis基础/AOF3.png)\n\n\n\n\n\n### 5.4  RDB与AOF区别\n\n#### 5.4.1 RDB与AOF对比（优缺点）\n\n| 持久化方式   | RDB                | AOF                |\n| ------------ | ------------------ | ------------------ |\n| 占用存储空间 | 小（数据级：压缩） | 大（指令级：重写） |\n| 存储速度     | 慢                 | 快                 |\n| 恢复速度     | 快                 | 慢                 |\n| 数据安全性   | 会丢失数据         | 依据策略决定       |\n| 资源消耗     | 高/重量级          | 低/轻量级          |\n| 启动优先级   | 低                 | 高                 |\n\n#### 5.4.2 RDB与AOF应用场景\n\nRDB与AOF的选择之惑\n\n- 对数据非常敏感，建议使用默认的AOF持久化方案\n\nAOF持久化策略使用everysecond，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出 现问题时，最多丢失0-1秒内的数据。\n\n注意：由于AOF文件存储体积较大，且恢复速度较慢\n\n- 数据呈现阶段有效性，建议使用RDB持久化方案\n\n数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且恢复速度较快，阶段 点数据恢复通常采用RDB方案\n\n注意：利用RDB实现紧凑的数据持久化会使Redis降的很低，慎重总结：\n\n\n\n**综合比对**\n\n- RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊\n- 如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF\n- 如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用RDB\n- 灾难恢复选用RDB\n- 双保险策略，同时开启 RDB和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据的量',Mn={data:function(){return{MainComponent:On}}},Cn=Mn,hn=Object(T["a"])(Cn,pn,In,!1,null,"866fbbd0",null),Dn=hn.exports,gn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},Un=[],_n="\x3c!--\r\n * @Date           : 2020-11-05 21:36:01\r\n * @FilePath       : /jinnian-space/src/pages/sql/module/redis/md/redis.md\r\n * @Description    : \r\n--\x3e\r\n# redis\r\n\r\n## Redis\r\n\r\n### 启动Redis服务\r\n\r\n- redis-server（默认配置）\r\n- redis-server --configKey1 configValue1 --configKey2 configValue2（根据配置项启动）\r\n- redis-server /opt/redis/redis.conf（配置文件启动）\r\n\r\n### 连接Redis服务器\r\n\r\n- redis-cli -h {host} -p {port} (交互方式)\r\n- redis-cli -h {host} -p {port} {command}\t(命令方式)\r\n\r\n### 停止Redis服务\r\n\r\n- redis-cli shutdown nosave|save（断开与客户端连接、持久化文件生成）\r\n- kill -9 redis（强制杀死Redis服务）\r\n\r\n### 全局命令\r\n\r\n- keys * ：查看所有键\r\n- dbsize:  键总数\r\n- exists key: \t检查键是否存在\r\n- del key [key ...]:\t删除键\r\n- expire key seconds:\t设置键过期时间\r\n- ttl key:\t查看键剩余过期时间 \r\n- type key: 获取键的数据结构类型\r\n\r\n\t- string\r\n\t- list\r\n\t- set\r\n\t- zset\r\n\t- hash\r\n\r\n- object encoding key:\t查询键的内部编码\r\n\r\n### 字符串\r\n\r\n- set key value [ex seconds] [px milliseconds] [nx|xx]:\t设置值\r\n- get key:\t获取值\r\n- mset key value [key value ...]:\t批量设置值\r\n- mget key [key...]:\t\t批量获取值\r\n- incr key:\t值自增\r\n\r\n\t- 值不是整数，报错\r\n\t- 键不存在，默认为0，自增后返回1\r\n\t- 值是整数，返回自增后的结果\r\n\r\n- decr: 值自减\r\n- incrby、decrby、incrbyfloat\r\n- append key value: 追加值\r\n- strlen key: 字符串长度\r\n- getset: 设置并返回原值\r\n- setrange key offeset value: 设置指定位置的字符\r\n- getrange key start end：获取部分字符串\r\n\r\n### 哈希\r\n\r\n- hset key field value：\t设置值\r\n- hget key field:\t获取值\r\n- hdel key field [field ...]:\t\t删除field\r\n- hlen key:\t计算field个数\r\n- hmget key field [field ...]:\t批量获取\r\n- hmset key field [field value ...]:\t批量设置\r\n- hexists key field:\t\t检查field是否存在\r\n- hkeys key:\t\t获取所有field\r\n- hvals key：\t\t获取所有value\r\n- hgetall key:\t\t获取所有field-value\r\n- hincrby key field、hincrbyfloat key field\r\n- hstrlen key field:\t\t计算value的字符串长度\r\n\r\n### 列表\r\n\r\n- 添加\r\n\r\n\t- rpush key value [value...]:\t从右边插入元素\r\n\t- lpush key value [value...]:\t从左边插入元素\r\n\t- linsert key before/after pivot value:\t在值为pivot的前面或后面插入元素\r\n\r\n- 查找\r\n\r\n\t- lrange key start end:\t获取指定范围内的元素列表\r\n\t- lindex key index:\t获取列表指定索引下标的元素\r\n\t- llen key:\t获取列表长度\r\n\r\n- 删除\r\n\r\n\t- lpop key:\t从列表左侧弹出元素\r\n\t- rpop key:\t从列表右侧弹出元素\r\n\t- lrem  key count value:\t删除值等于value的元素\r\n\r\n\t\t- count>0:\t从左到右，删除最多count个元素\r\n\t\t- count<0:\t从右往左，删除最多count绝对值个元素\r\n\t\t- count=0:\t删除所有元素\r\n\r\n\t- ltrim key start end:\t按照索引范围修剪列表\r\n\r\n- 修改\r\n\r\n\t- lset key index newValue:\t修改指定索引下标的元素\r\n\r\n- 阻塞\r\n\r\n\t- blpop/brpop key [key...] timeout\r\n\r\n\t\t- 列表为空\r\n\r\n\t\t\t- timeout=n:\tn秒后返回\r\n\t\t\t- timeout=0\r\n\r\n\t\t\t\t- 客户端一直阻塞\r\n\t\t\t\t- 如果列表有值插入则立即返回\r\n\r\n\t\t- 列表非空\r\n\r\n\t\t\t- 客户端立即返回\r\n\r\n\t\t- brpop两点注意\r\n\r\n\t\t\t- 多个键，brpop会从左往右遍历键，一旦有一个键能弹出元素，客户端立即返回\r\n\t\t\t- 多个客户端对一个键执行brpop，最先执行brpop命令的客户端可以获取到弹出的值\r\n\r\n### 集合\r\n\r\n- sadd key member [...member]:\t添加元素\r\n- srem key member [...member]:\t删除元素\r\n- sismember key member:\t判断是否为集合元素\r\n- scard key:\t计算集合大小\r\n- srandmember key [count]:\t随机返回count个元素\r\n- spop key [count]:\t随机弹出count个元素\r\n- smembers key: 返回集合所有元素\r\n- sinter key [key...]:\t返回多个集合交集\r\n- sunion key [key...]:\t返回多个集合并集\r\n- sdiff key [key...]:\t返回多个集合差集\r\n- sinterstore/sunionstore/sdiffstore destination key [...key]:\t将返回的集合存储在destination中\r\n\r\n### 有序集合\r\n\r\n- zadd key [NX|XX] [CH] [INCR] score member [...score member]:\t添加元素\r\n\r\n\t- NX: 添加\r\n\t- XX：更新\r\n\t- CH：返回这次操作后发生变化的个数\r\n\t- INCR：对score做增加\r\n\r\n- zrem key member [...member]:\t删除元素\r\n- zcard key:\t计算有序集合大小\r\n- zscore key member:\t返回某个元素的分数\r\n- zrank/zrevrank key member:\t返回某个元素的排名(升序、降序)\r\n- zincrby key increment member:\t增加成员分数\r\n- zrange/zrevrange key start end:\t返回指定排名（升序、降序）范围内的元素\r\n- zrangebyscore/zrevrangebyscore key mix max:\t返回指定分数（升序、降序）范围内的元素\r\n- zcount key min max:\t返回指定分数范围成员个数\r\n- zremrangebyrank key start end:\t删除指定排名内的升序元素\r\n- zremrangebyscore key min max:\t删除指定分数范围内的元素\r\n- zinterstore destination numkeys key [...key] [weights weight [...weight]] [aggrerate sum|min|max]:\t交集\r\n- zunionstore destination numkeys key [...key] [weights weight [...weight]] [aggrerate sum|min|max]:\t\t并集\r\n\r\n## 核心\r\n\r\n### Redis\r\n\r\n- 单线程模型\r\n\r\n\t- 请求\r\n\r\n\t\t- 步骤\r\n\r\n\t\t\t- 发送命令\r\n\t\t\t- 执行命令\r\n\t\t\t- 返回结果\r\n\r\n\t\t- 重点\r\n\r\n\t\t\t- 一条命令从客户端达到服务端不会立刻被执行， 所有命令都会进入一个队列中，然后逐个执行。\r\n\r\n- 单线程为什么可以这么快\r\n\r\n\t- 纯内存访问\r\n\t- 非阻塞I/O，Redis使用epoll作为I/O多路复用技术的实现，加上Redis自身的时间处理模型（Redis Event Loop）\r\n\t- 避免线程切换和静态条件的消耗\r\n\r\n## 数据结构\r\n\r\n### 字符串\r\n\r\n- 内部编码\r\n\r\n\t- int：\t8个字节的长整型\r\n\t- embstr：小于等于39个字节的字符串\r\n\t- raw：大于39个字节的字符串\r\n\r\n- 使用场景\r\n\r\n\t- 缓存：Redis作为缓存层，MySQL作为存储层。\r\n\r\n\t\t- 加速读写和降低后端压力的作用\r\n\r\n\t- 计数：使用Redis作为计数的基础工具。\r\n\r\n\t\t- 实现快速计数、查询缓存且数据可以异步落地到其他数据源\r\n\r\n\t- 共享Session：使用Redis将用户的Session集中管理。\r\n\r\n\t\t- 出于负载均衡的考虑，分布式服务会将用户的访问均衡到不同服务器，用户每刷新一次就有可能发现需要重新登录\r\n\r\n\t- 限速：限制用户单位时间内访问次数\r\n\r\n### 哈希\r\n\r\n- 内部编码\r\n\r\n\t- ziplist(压缩表)\r\n\t- hashtable（哈希表）\r\n\r\n- 使用场景\r\n\r\n\t- 缓存用户信息\r\n\r\n### 列表\r\n\r\n- 内部编码\r\n\r\n\t- ziplist\r\n\t- linkedlist\r\n\r\n- 使用场景\r\n\r\n\t- 消息队列\r\n\r\n\t\t- 生产者使用lpush从列表左侧插入元素，消费者使用brpop命令阻塞式的‘抢’列表尾部的元素\r\n\r\n\t- 文章列表\r\n\r\n\t\t- 存储用户文章列表，分页获取文章\r\n\r\n### 集合\r\n\r\n- 内部编码\r\n\r\n\t- intset:\r\n\t- hashtable:\r\n\r\n- 使用场景\r\n\r\n\t- 用户标签\r\n\r\n### 有序集合\r\n\r\n- 内部编码\r\n\r\n\t- ziplist\r\n\t- skiplist\r\n\r\n- 使用场景\r\n\r\n\t- 排行榜系统\r\n\r\n",qn={data:function(){return{MainComponent:_n}}},bn=qn,Fn=Object(T["a"])(bn,gn,Un,!1,null,"dd80896e",null),Bn=Fn.exports,vn={mixins:[Ln["a"]],components:{m1:Dn,m2:Bn},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"Redis基础",value:"m1"},{label:"Redis",value:"m2"}]}}},kn=vn,fn=Object(T["a"])(kn,Sn,yn,!1,null,"bd497176",null),Hn=fn.exports,Vn={mixins:[Ln["a"]],components:{m1:Nn,m2:Hn},data:function(){return{tab:"m1",tab_level:1,tabs:[{label:"mysql",value:"m1"},{label:"redis",value:"m2"}]}}},Yn=Vn,Pn=Object(T["a"])(Yn,e,s,!1,null,"1a22cb9a",null);r["default"]=Pn.exports}}]);