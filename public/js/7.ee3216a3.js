(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[7],{"131b":function(n,t,e){"use strict";e.r(t),t["default"]='### 一 斐波那契数列\n\n#### **题目描述：**\n\n大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。\nn<=39\n\n#### **问题分析：**\n\n可以肯定的是这一题通过递归的方式是肯定能做出来，但是这样会有一个很大的问题，那就是递归大量的重复计算会导致内存溢出。另外可以使用迭代法，用fn1和fn2保存计算过程中的结果，并复用起来。下面我会把两个方法示例代码都给出来并给出两个方法的运行时间对比。\n\n#### **示例代码：**\n\n**采用迭代法：**\n\n```java\nint Fibonacci(int number) {\n    if (number <= 0) {\n        return 0;\n    }\n    if (number == 1 || number == 2) {\n        return 1;\n    }\n    int first = 1, second = 1, third = 0;\n    for (int i = 3; i <= number; i++) {\n        third = first + second;\n        first = second;\n        second = third;\n    }\n    return third;\n}\n```\n\n**采用递归：**\n\n```java\npublic int Fibonacci(int n) {\n    if (n <= 0) {\n        return 0;\n    }\n    if (n == 1||n==2) {\n        return 1;\n    }\n\n    return Fibonacci(n - 2) + Fibonacci(n - 1);\n}\n```\n\n### 二 跳台阶问题\n\n#### **题目描述：**\n\n一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。\n\n#### **问题分析：**\n\n**正常分析法：**\na.如果两种跳法，1阶或者2阶，那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1);\nb.假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2)\nc.由a，b假设可以得出总跳法为: f(n) = f(n-1) + f(n-2) \nd.然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2\n**找规律分析法：**\nf(1) = 1, f(2) = 2, f(3) = 3, f(4) = 5，  可以总结出f(n) = f(n-1) + f(n-2)的规律。\n但是为什么会出现这样的规律呢？假设现在6个台阶，我们可以从第5跳一步到6，这样的话有多少种方案跳到5就有多少种方案跳到6，另外我们也可以从4跳两步跳到6，跳到4有多少种方案的话，就有多少种方案跳到6，其他的不能从3跳到6什么的啦，所以最后就是f(6) = f(5) + f(4)；这样子也很好理解变态跳台阶的问题了。\n\n**所以这道题其实就是斐波那契数列的问题。**\n代码只需要在上一题的代码稍做修改即可。和上一题唯一不同的就是这一题的初始元素变为 1 2 3 5 8.....而上一题为1 1 2  3 5 .......。另外这一题也可以用递归做，但是递归效率太低，所以我这里只给出了迭代方式的代码。\n\n#### **示例代码：**\n\n```java\nint jumpFloor(int number) {\n    if (number <= 0) {\n        return 0;\n    }\n    if (number == 1) {\n        return 1;\n    }\n    if (number == 2) {\n        return 2;\n    }\n    int first = 1, second = 2, third = 0;\n    for (int i = 3; i <= number; i++) {\n        third = first + second;\n        first = second;\n        second = third;\n    }\n    return third;\n}\n```\n\n### 三 变态跳台阶问题\n\n#### **题目描述：**\n\n一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。\n\n#### **问题分析：**\n\n假设n>=2，第一步有n种跳法：跳1级、跳2级、到跳n级\n跳1级，剩下n-1级，则剩下跳法是f(n-1)\n跳2级，剩下n-2级，则剩下跳法是f(n-2)\n......\n跳n-1级，剩下1级，则剩下跳法是f(1)\n跳n级，剩下0级，则剩下跳法是f(0)\n所以在n>=2的情况下：\nf(n)=f(n-1)+f(n-2)+...+f(1)\n因为f(n-1)=f(n-2)+f(n-3)+...+f(1)\n所以f(n)=2*f(n-1) 又f(1)=1,所以可得**f(n)=2^(number-1)**\n\n#### **示例代码：**\n\n```java\nint JumpFloorII(int number) {\n    return 1 << --number;//2^(number-1)用位移操作进行，更快\n}\n```\n\n#### **补充：**\n\n**java中有三种移位运算符：**\n\n1. “<<” :     **左移运算符**，等同于乘2的n次方\n2. “>>”:     **右移运算符**，等同于除2的n次方\n3. “>>>” :  **无符号右移运算符**，不管移动前最高位是0还是1，右移后左侧产生的空位部分都以0来填充。与>>类似。\n   例：\n    int a = 16;\n    int b = a << 2;//左移2，等同于16 * 2的2次方，也就是16 * 4\n    int c = a >> 2;//右移2，等同于16 / 2的2次方，也就是16 / 4\n\n### 四 二维数组查找\n\n#### **题目描述：**\n\n在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n\n#### **问题解析：**\n\n这一道题还是比较简单的，我们需要考虑的是如何做，效率最快。这里有一种很好理解的思路：\n\n> 矩阵是有序的，从左下角来看，向上数字递减，向右数字递增，\n>    因此从左下角开始查找，当要查找数字比左下角数字大时。右移\n>     要查找数字比左下角数字小时，上移。这样找的速度最快。\n\n#### **示例代码：**\n\n```java\npublic boolean Find(int target, int [][] array) {\n    //基本思路从左下角开始找，这样速度最快\n    int row = array.length-1;//行\n    int column = 0;//列\n    //当行数大于0，当前列数小于总列数时循环条件成立\n    while((row >= 0)&& (column< array[0].length)){\n        if(array[row][column] > target){\n            row--;\n        }else if(array[row][column] < target){\n            column++;\n        }else{\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n### 五 替换空格\n\n#### **题目描述：**\n\n请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。\n\n#### **问题分析：**\n\n这道题不难，我们可以通过循环判断字符串的字符是否为空格，是的话就利用append()方法添加追加“%20”，否则还是追加原字符。\n\n或者最简单的方法就是利用：replaceAll(String regex,String replacement)方法了，一行代码就可以解决。\n\n#### **示例代码：**\n\n**常规做法：**\n\n```java\npublic String replaceSpace(StringBuffer str) {\n    StringBuffer out = new StringBuffer();\n    for (int i = 0; i < str.toString().length(); i++) {\n        char b = str.charAt(i);\n        if(String.valueOf(b).equals(" ")){\n            out.append("%20");\n        }else{\n            out.append(b);\n        }\n    }\n    return out.toString();     \n}\n```\n\n**一行代码解决：**\n\n```java\npublic String replaceSpace(StringBuffer str) {\n    //return str.toString().replaceAll(" ", "%20");\n    //public String replaceAll(String regex,String replacement)\n    //用给定的替换替换与给定的regular expression匹配的此字符串的每个子字符串。 \n    //\\ 转义字符. 如果你要使用 "\\" 本身, 则应该使用 "\\\\". String类型中的空格用“\\s”表示，所以我这里猜测"\\\\s"就是代表空格的意思\n    return str.toString().replaceAll("\\\\s", "%20");\n}\n```\n\n### 六 数值的整数次方\n\n#### **题目描述：**\n\n给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。\n\n#### **问题解析：**\n\n这道题算是比较麻烦和难一点的一个了。我这里采用的是**二分幂**思想，当然也可以采用**快速幂**。\n更具剑指offer书中细节，该题的解题思路如下：\n1.当底数为0且指数<0时，会出现对0求倒数的情况，需进行错误处理，设置一个全局变量；\n2.判断底数是否等于0，由于base为double型，所以不能直接用==判断\n3.优化求幂函数（二分幂）。\n当n为偶数，a^n =（a^n/2）*（a^n/2）；\n当n为奇数，a^n = a^[(n-1)/2] * a^[(n-1)/2] * a。时间复杂度O(logn)\n\n**时间复杂度**：O(logn)\n\n#### **示例代码：**\n\n```java\npublic class Solution { \n      boolean invalidInput=false;    \n      public double Power(double base, int exponent) {\n          //如果底数等于0并且指数小于0\n          //由于base为double型，不能直接用==判断\n        if(equal(base,0.0)&&exponent<0){\n            invalidInput=true;\n            return 0.0;\n        }\n        int absexponent=exponent;\n         //如果指数小于0，将指数转正\n        if(exponent<0)\n            absexponent=-exponent;\n         //getPower方法求出base的exponent次方。\n        double res=getPower(base,absexponent);\n         //如果指数小于0，所得结果为上面求的结果的倒数\n        if(exponent<0)\n            res=1.0/res;\n        return res;\n  }\n    //比较两个double型变量是否相等的方法\n    boolean equal(double num1,double num2){\n        if(num1-num2>-0.000001&&num1-num2<0.000001)\n            return true;\n        else\n            return false;\n    }\n    //求出b的e次方的方法\n    double getPower(double b,int e){\n        //如果指数为0，返回1\n        if(e==0)\n            return 1.0;\n        //如果指数为1，返回b\n        if(e==1)\n            return b;\n        //e>>1相等于e/2，这里就是求a^n =（a^n/2）*（a^n/2）\n        double result=getPower(b,e>>1);\n        result*=result;\n        //如果指数n为奇数，则要再乘一次底数base\n        if((e&1)==1)\n            result*=b;\n        return result;\n    }\n}\n```\n\n当然这一题也可以采用笨方法：累乘。不过这种方法的时间复杂度为O（n），这样没有前一种方法效率高。\n\n```java\n// 使用累乘\npublic double powerAnother(double base, int exponent) {\n    double result = 1.0;\n    for (int i = 0; i < Math.abs(exponent); i++) {\n        result *= base;\n    }\n    if (exponent >= 0)\n        return result;\n    else\n        return 1 / result;\n}\n```\n\n### 七 调整数组顺序使奇数位于偶数前面\n\n#### **题目描述：**\n\n输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。\n\n#### **问题解析：**\n\n这道题有挺多种解法的，给大家介绍一种我觉得挺好理解的方法：\n我们首先统计奇数的个数假设为n,然后新建一个等长数组，然后通过循环判断原数组中的元素为偶数还是奇数。如果是则从数组下标0的元素开始，把该奇数添加到新数组；如果是偶数则从数组下标为n的元素开始把该偶数添加到新数组中。\n\n#### **示例代码：**\n\n时间复杂度为O（n），空间复杂度为O（n）的算法\n\n```java\npublic class Solution {\n    public void reOrderArray(int [] array) {\n        //如果数组长度等于0或者等于1，什么都不做直接返回\n        if(array.length==0||array.length==1) \n            return;\n        //oddCount：保存奇数个数\n        //oddBegin：奇数从数组头部开始添加\n        int oddCount=0,oddBegin=0;\n        //新建一个数组\n        int[] newArray=new int[array.length];\n        //计算出（数组中的奇数个数）开始添加元素\n        for(int i=0;i<array.length;i++){\n            if((array[i]&1)==1) oddCount++;\n        }\n        for(int i=0;i<array.length;i++){\n            //如果数为基数新数组从头开始添加元素\n            //如果为偶数就从oddCount（数组中的奇数个数）开始添加元素\n            if((array[i]&1)==1) \n                newArray[oddBegin++]=array[i];\n            else newArray[oddCount++]=array[i];\n        }\n        for(int i=0;i<array.length;i++){\n            array[i]=newArray[i];\n        }\n    }\n}\n```\n\n### 八 链表中倒数第k个节点\n\n#### **题目描述：**\n\n输入一个链表，输出该链表中倒数第k个结点\n\n#### **问题分析：**\n\n**一句话概括：**\n两个指针一个指针p1先开始跑，指针p1跑到k-1个节点后，另一个节点p2开始跑，当p1跑到最后时，p2所指的指针就是倒数第k个节点。\n\n**思想的简单理解：**\n前提假设：链表的结点个数(长度)为n。\n规律一：要找到倒数第k个结点，需要向前走多少步呢？比如倒数第一个结点，需要走n步，那倒数第二个结点呢？很明显是向前走了n-1步，所以可以找到规律是找到倒数第k个结点，需要向前走n-k+1步。\n**算法开始：**\n\n1. 设两个都指向head的指针p1和p2，当p1走了k-1步的时候，停下来。p2之前一直不动。\n2. p1的下一步是走第k步，这个时候，p2开始一起动了。至于为什么p2这个时候动呢？看下面的分析。\n3. 当p1走到链表的尾部时，即p1走了n步。由于我们知道p2是在p1走了k-1步才开始动的，也就是说p1和p2永远差k-1步。所以当p1走了n步时，p2走的应该是在n-(k-1)步。即p2走了n-k+1步，此时巧妙的是p2正好指向的是规律一的倒数第k个结点处。\n   这样是不是很好理解了呢？\n\n#### **考察内容：**\n\n链表+代码的鲁棒性\n\n#### **示例代码：**\n\n```java\n/*\n//链表类\npublic class ListNode {\n    int val;\n    ListNode next = null;\n\n    ListNode(int val) {\n        this.val = val;\n    }\n}*/\n\n//时间复杂度O(n),一次遍历即可\npublic class Solution {\n    public ListNode FindKthToTail(ListNode head,int k) {\n        ListNode pre=null,p=null;\n        //两个指针都指向头结点\n        p=head;\n        pre=head;\n        //记录k值\n        int a=k;\n        //记录节点的个数\n        int count=0;\n        //p指针先跑，并且记录节点数，当p指针跑了k-1个节点后，pre指针开始跑，\n        //当p指针跑到最后时，pre所指指针就是倒数第k个节点\n        while(p!=null){\n            p=p.next;\n            count++;\n            if(k<1){\n                pre=pre.next;\n            }\n            k--;\n        }\n        //如果节点个数小于所求的倒数第k个节点，则返回空\n        if(count<a) return null;\n        return pre;\n            \n    }\n}\n```\n\n### 九 反转链表\n\n#### **题目描述：**\n\n输入一个链表，反转链表后，输出链表的所有元素。\n\n#### **问题分析：**\n\n链表的很常规的一道题，这一道题思路不算难，但自己实现起来真的可能会感觉无从下手，我是参考了别人的代码。\n思路就是我们根据链表的特点，前一个节点指向下一个节点的特点，把后面的节点移到前面来。\n就比如下图：我们把1节点和2节点互换位置，然后再将3节点指向2节点，4节点指向3节点，这样以来下面的链表就被反转了。\n![链表](剑指offer部分编程题.assets/20160420134000174)\n\n#### **考察内容：**\n\n链表+代码的鲁棒性\n\n#### **示例代码：**\n\n```java\n/*\npublic class ListNode {\n    int val;\n    ListNode next = null;\n\n    ListNode(int val) {\n        this.val = val;\n    }\n}*/\npublic class Solution {\n    public ListNode ReverseList(ListNode head) {\n       ListNode next = null;\n       ListNode pre = null;\n        while (head != null) {\n              //保存要反转到头来的那个节点\n               next = head.next;\n               //要反转的那个节点指向已经反转的上一个节点\n               head.next = pre;\n               //上一个已经反转到头部的节点\n               pre = head;\n               //一直向链表尾走\n               head = next;\n        }\n        return pre;\n    }\n}\n```\n\n### 十 合并两个排序的链表\n\n#### **题目描述：**\n\n输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。\n\n#### **问题分析：**\n\n我们可以这样分析:\n\n1. 假设我们有两个链表 A,B；\n2. A的头节点A1的值与B的头结点B1的值比较，假设A1小，则A1为头节点；\n3. A2再和B1比较，假设B1小,则，A1指向B1；\n4. A2再和B2比较。。。。。。。\n   就这样循环往复就行了，应该还算好理解。\n\n#### **考察内容：**\n\n链表+代码的鲁棒性\n\n#### **示例代码：**\n\n**非递归版本：**\n\n```java\n/*\npublic class ListNode {\n    int val;\n    ListNode next = null;\n\n    ListNode(int val) {\n        this.val = val;\n    }\n}*/\npublic class Solution {\n    public ListNode Merge(ListNode list1,ListNode list2) {\n       //list1为空，直接返回list2\n       if(list1 == null){\n            return list2;\n        }\n        //list2为空，直接返回list1\n        if(list2 == null){\n            return list1;\n        }\n        ListNode mergeHead = null;\n        ListNode current = null;   \n        //当list1和list2不为空时\n        while(list1!=null && list2!=null){\n            //取较小值作头结点 \n            if(list1.val <= list2.val){\n                if(mergeHead == null){\n                   mergeHead = current = list1;\n                }else{\n                   current.next = list1;\n                    //current节点保存list1节点的值因为下一次还要用\n                   current = list1;\n                }\n                //list1指向下一个节点\n                list1 = list1.next;\n            }else{\n                if(mergeHead == null){\n                   mergeHead = current = list2;\n                }else{\n                   current.next = list2;\n                     //current节点保存list2节点的值因为下一次还要用\n                   current = list2;\n                }\n                //list2指向下一个节点\n                list2 = list2.next;\n            }\n        }\n        if(list1 == null){\n            current.next = list2;\n        }else{\n            current.next = list1;\n        }\n        return mergeHead;\n    }\n}\n```\n\n**递归版本：**\n\n```java\npublic ListNode Merge(ListNode list1,ListNode list2) {\n    if(list1 == null){\n        return list2;\n    }\n    if(list2 == null){\n        return list1;\n    }\n    if(list1.val <= list2.val){\n        list1.next = Merge(list1.next, list2);\n        return list1;\n    }else{\n        list2.next = Merge(list1, list2.next);\n        return list2;\n    }       \n}\n```\n\n### 十一 用两个栈实现队列\n\n#### **题目描述：**\n\n用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。\n\n#### 问题分析：\n\n先来回顾一下栈和队列的基本特点：\n**栈：**后进先出（LIFO）\n**队列：** 先进先出\n很明显我们需要根据JDK给我们提供的栈的一些基本方法来实现。先来看一下Stack类的一些基本方法：\n![Stack类的一些常见方法](剑指offer部分编程题.assets/5985000.jpg)\n\n既然题目给了我们两个栈，我们可以这样考虑当push的时候将元素push进stack1，pop的时候我们先把stack1的元素pop到stack2，然后再对stack2执行pop操作，这样就可以保证是先进先出的。（负[pop]负[pop]得正[先进先出]）\n\n#### 考察内容：\n\n队列+栈\n\n#### 示例代码：\n\n```java\n//左程云的《程序员代码面试指南》的答案\nimport java.util.Stack;\n \npublic class Solution {\n    Stack<Integer> stack1 = new Stack<Integer>();\n    Stack<Integer> stack2 = new Stack<Integer>();\n     \n    //当执行push操作时，将元素添加到stack1\n    public void push(int node) {\n        stack1.push(node);\n    }\n     \n    public int pop() {\n        //如果两个队列都为空则抛出异常,说明用户没有push进任何元素\n        if(stack1.empty()&&stack2.empty()){\n            throw new RuntimeException("Queue is empty!");\n        }\n        //如果stack2不为空直接对stack2执行pop操作，\n        if(stack2.empty()){\n            while(!stack1.empty()){\n                //将stack1的元素按后进先出push进stack2里面\n                stack2.push(stack1.pop());\n            }\n        }\n          return stack2.pop();\n    }\n}\n```\n\n### 十二 栈的压入,弹出序列\n\n#### **题目描述：**\n\n输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）\n\n#### **题目分析：**\n\n这道题想了半天没有思路，参考了Alias的答案，他的思路写的也很详细应该很容易看懂。\n作者：Alias\nhttps://www.nowcoder.com/questionTerminal/d77d11405cc7470d82554cb392585106\n来源：牛客网\n\n【思路】借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。\n\n举例：\n\n入栈1,2,3,4,5\n\n出栈4,5,3,2,1\n\n首先1入辅助栈，此时栈顶1≠4，继续入栈2\n\n此时栈顶2≠4，继续入栈3\n\n此时栈顶3≠4，继续入栈4\n\n此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，,辅助栈里面是1,2,3\n\n此时栈顶3≠5，继续入栈5\n\n此时栈顶5=5，出栈5,弹出序列向后一位，此时为3，,辅助栈里面是1,2,3\n\n….\n依次执行，最后辅助栈为空。如果不为空说明弹出序列不是该栈的弹出顺序。 \n\n#### **考察内容：**\n\n栈\n\n#### **示例代码：**\n\n```java\nimport java.util.ArrayList;\nimport java.util.Stack;\n//这道题没想出来，参考了Alias同学的答案：https://www.nowcoder.com/questionTerminal/d77d11405cc7470d82554cb392585106\npublic class Solution {\n    public boolean IsPopOrder(int [] pushA,int [] popA) {\n        if(pushA.length == 0 || popA.length == 0)\n            return false;\n        Stack<Integer> s = new Stack<Integer>();\n        //用于标识弹出序列的位置\n        int popIndex = 0;\n        for(int i = 0; i< pushA.length;i++){\n            s.push(pushA[i]);\n            //如果栈不为空，且栈顶元素等于弹出序列\n            while(!s.empty() &&s.peek() == popA[popIndex]){\n                //出栈\n                s.pop();\n                //弹出序列向后一位\n                popIndex++;\n            }\n        }\n        return s.empty();\n    }\n}\n```'},"1b62":function(n,t,e){"use strict";e.d(t,"d",(function(){return o})),e.d(t,"c",(function(){return p})),e.d(t,"a",(function(){return _})),e.d(t,"b",(function(){return S})),e("4de4"),e("c975");var i=e("448a"),a=e.n(i),s=["/第1阶段-运维基本功（升级7.6版本）/01运维概述与Linux系统安装.pdf","/第1阶段-运维基本功（升级7.6版本）/02Linux基础命令.pdf"],r="linux/heima-Linux云计算",o={name:"Container",data:function(){return{prefix:r,book_options:s,book_options_all:[],show:!0,book:s[0],src:""}},created:function(){this.book_options_all=a()(this.book_options),this.src=this.$utils.compute_book_src(this.prefix+this.book)},watch:{book:function(n,t){n&&this.change_book()}},methods:{change_book:function(){console.log("this.book",this.book),this.src=this.$utils.compute_book_src(this.prefix+this.book)},filterFn:function(n,t){var e=this;t(""!==n?function(){var t=n.toLowerCase();e.book_options=e.book_options_all.filter((function(n){return n.toLowerCase().indexOf(t)>-1}))}:function(){e.book_options=e.book_options_all})}}},l=e("ded3"),c=e.n(l),u=e("2f62"),p={data:function(){return{tab:"",tab_level:1,is_active:!1}},computed:c()({},Object(u["c"])(["get_current_selected_right_menu"])),created:function(){this.is_active=!0,this.fix_right_menu_config()},watch:{tab:function(){this.tab||this.fix_right_menu_config()},get_current_selected_right_menu:function(n,t){this.tab=this.get_current_selected_right_menu["t"+this.tab_level]}},methods:c()(c()({},Object(u["b"])(["set_right_menu_fix_config"])),{},{fix_right_menu_config:function(){this.set_right_menu_fix_config({tl:this.tab_level,tabs:this.tabs||[],tv:this.tab||this.tabs[0]["value"]})}}),beforeDestroy:function(){this.is_active=!1}},d=(e("99af"),e("d81d"),e("fb6a"),e("a434"),e("07ac"),function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"q-my-md q-mx-sm"},[e("div",{staticClass:"q-mb-md row q-gutter-x-md q-gutter-y-sm"},[e("q-select",{staticStyle:{width:"300px"},attrs:{dense:"",filled:"","use-input":"","hide-selected":"","fill-input":"","input-debounce":"0",options:n.topic_options_filtered},on:{filter:n.filterFn,"filter-abort":n.abortFilterFn,input:n.handle_topic_change},scopedSlots:n._u([{key:"before",fn:function(){return[n._v("\n        主题\n      ")]},proxy:!0}]),model:{value:n.topic,callback:function(t){n.topic=t},expression:"topic"}}),e("q-select",{staticStyle:{width:"300px"},attrs:{dense:"",filled:"",options:n.column_options},on:{input:n.handle_column_change},scopedSlots:n._u([{key:"before",fn:function(){return[n._v("\n        列数\n      ")]},proxy:!0}]),model:{value:n.column,callback:function(t){n.column=t},expression:"column"}})],1),e("q-markup-table",{attrs:{dense:""}},[e("thead",[e("tr",[e("th",{staticClass:"text-left text-weight-bolder  ",attrs:{colspan:n.column}},[n._v("\n          "+n._s(n.table_title?n.table_title+"------":"")+"当前词条数量："+n._s(n.word_total)+"\n        ")])])]),e("tbody",[n._l(n.table_data,(function(t,i){return[n.compute_if_show(t)?e("tr",{key:i,class:n.compute_topic_options_style(t)},n._l(n.column,(function(i){return e("td",{key:i,staticClass:"text-left"},[n._v("\n            "+n._s(t[i-1])+"\n          ")])})),0):n._e()]}))],2)])],1)}),h=[],f=(e("caad"),e("a9e3"),e("2532"),{data:function(){return{topic:"全部",column:2,topic_options_filtered:[],topic_options_all:[]}},props:{table_title:{type:String,default:""},word_total:{type:Number,default:0},topic_options:{type:Array,default:function(){return[]}},column_options:{type:Array,default:function(){return[]}},table_data:{type:Array,default:function(){return[]}},show_empty_line:!1},watch:{topic_options:function(n,t){this.init_topic_options_related()},column_options:function(n,t){this.init_column()}},created:function(){this.init_topic_options_related(),this.init_column(),this.handle_column_change(),this.handle_topic_change()},methods:{init_topic_options_related:function(){this.topic_options_all=a()(this.topic_options),this.topic_options_filtered=a()(this.topic_options)},filterFn:function(n,t,e){var i=this;console.log("this.topic_options_all",this.topic_options_all),setTimeout((function(){t((function(){if(""===n)i.topic_options_filtered=a()(i.topic_options_all);else{var t=n.toLowerCase();i.topic_options_filtered=i.topic_options_all.filter((function(n){return n.toLowerCase().indexOf(t)>-1}))}i.$forceUpdate()}),(function(t){""!==n&&t.options.length>0&&(t.setOptionIndex(-1),t.moveOptionSelection(1,!0))}))}),300)},abortFilterFn:function(){},handle_column_change:function(){this.$emit("handle_column_change",this.column)},handle_topic_change:function(){this.$emit("handle_topic_change",this.topic)},init_column:function(){var n=this.$q.platform.is.desktop,t=window.innerWidth;t=n?t-200:t-100,t=t<370?370:t,console.log("ww",t);var e=Math.ceil(t/350);e=e<1?1:e,t<400&&(e=1),e=e>8?8:e,this.column=e},compute_topic_options_style:function(n){var t="",e=1==n.length&&this.topic_options.includes(n[0]);return t=e?"bg-teal-4":"",t},compute_if_show:function(n){if(this.show_empty_line)return!0;var t=n.filter((function(n){return n}));return t.length>0}}}),m=f,g=e("2877"),b=Object(g["a"])(m,d,h,!1,null,"4e74a874",null),v=b.exports,_={components:{excelTable:v},data:function(){return{workSheetsFromFile:[[{data:[]}]],table_title:"",column:8,word_total:0,table_data:[],table_data_all:[],column_options:[1,2,3,4,5,6,7,8],exclude_topic_options:!0,show_empty_line:!1,topic:"",topic_options:[]}},created:function(){this.init_workSheetsFromFile()},methods:{init_workSheetsFromFile:function(){},handle_column_change:function(n){this.column=n,this.init_data()},handle_topic_change:function(n){this.topic=n,console.log("this.topic----",this.topic),this.compute_table_data_show_and_word_total()},rebuild_arr_reduce_empty_line:function(n){var t=[[""]];return n.map((function(n){var e=n.filter((function(n){return n})),i=e.length;if(i)t.push(n);else{var a=t[t.length-1].filter((function(n){return n})).length,s=t[t.length-1].length;s>0&&a>0&&t.push([""])}})),t},init_data:function(){var n=this;console.log("workSheetsFromFile --------",this.workSheetsFromFile);var t=[],e={},i=[];this.workSheetsFromFile.map((function(n){t=t.concat(n["data"])}));var s=this.$lodash.cloneDeep(t[0].filter((function(n){return n})));s.map((function(n,t){e["key_"+t]={title:n,words_raw:[]}})),this.exclude_topic_options&&t.splice(0,1),t.map((function(n,t){n.map((function(n,t){e["key_"+t]["words_raw"].push(n)}))})),console.log("final_obj------------",e);var r=Object.values(e);r.map((function(t,e){i.push([t["title"]]),i=i.concat(n.$lodash.chunk(t["words_raw"],n.column)),i=i.concat([[""]])})),this.topic_options=["全部"].concat(a()(s)),this.table_data_all=this.rebuild_arr_reduce_empty_line(i),this.compute_table_data_show_and_word_total(),console.log("  this.table_data_all   ",this.table_data_all)},compute_table_data_show_and_word_total:function(){var n=[],t=[],e=0;if(t=this.$lodash.cloneDeep(this.table_data_all),console.log(" table_data--------",t),"全部"==this.topic)n=t;else{var i=this.topic_options.indexOf(this.topic),a=i==this.topic_options.length-1,s=a?"":this.topic_options[i+1],r=this.find_topic_index(this.topic),o=s?this.find_topic_index(s):t.length;n=t.slice(r,o)}n.map((function(n){var t=n.filter((function(n){return n})).length;e+=t})),this.word_total=e,this.table_data=n},find_topic_index:function(n){for(var t=0,e=0;e<this.table_data_all.length;e++){var i=this.table_data_all[e];if(1==i.length&&i[0]&&i[0]==n){t=e;break}}return t}}},S=(e("7db0"),e("ac1f"),e("1276"),{data:function(){return{relative_path:"",tab:"",tabs:[],MainComponent:"",img_prefix:"./img/linux/heima-Linux云计算/讲义/"}},methods:{extendMarkdown:function(n){var t=this;console.log(n.renderer.rules);var e=n.renderer.rules.html_block;n.renderer.rules.html_block=function(n,i,a,s,r){var o=n[i];if(console.log("1"),o.content.includes("<img")){console.log("token-- ",o);var l="";l=o.content;var c=l.split('src="'),u="",p=c[1];c[0],t.img_prefix,c[1],u=p.includes("http")?c[0]+' src="'+p:c[0]+' src="'+t.img_prefix+p,o.content=u}return o.attrSet("class","q-markdown--token  "),e(n,i,a,s,r)},n.renderer.rules.image=function(n,e,i,a,s){var r=n[e];console.log("3"),r.attrSet("class","q-markdown--image"),console.log("token--- "+e+"-----",r);var o=r.attrGet("src");return console.log(o),o.includes("http")?r.attrSet("src",o):r.attrSet("src",t.img_prefix+o),s.renderToken(n,e,i)}},compute_img_prefix:function(){var n=this;if(this.MainComponent){var t=this.tabs.find((function(t){return t["value"]==n.tab}));if(t&&t["modules_obj"]){var e=this.relative_path;this.img_prefix="."+e+(t["modules_obj"]["relative_folder"]||"")}else this.img_prefix="."+relative_path}}}})},3686:function(n,t,e){"use strict";e.d(t,"a",(function(){return c})),e("e260"),e("a15b"),e("d81d"),e("fb6a"),e("4e82"),e("d3b7"),e("ac1f"),e("5319"),e("1276"),e("ddb0");var i=e("ded3"),a=e.n(i),s=e("d958"),r=function(n){var t=s(n,{style:s.STYLE_NORMAL}),e="";return t.map((function(n){e+=n[0]})),e},o=function(n){if(!n)return"";var t="",e=n.split("/");return e.shift(),e.pop(),t=e.join("/"),t?"/"+t+"/":""},l=function(n){n=n||"";var t=n.split("/"),e=t.length;return t[e-1]},c=function(n){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"md",e=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],i=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];console.log("当前 require.context---",n),console.log("当前 field_components.keys()---",n.keys());var c=n.keys(),u={},p=[],d={},h=[];return c.map((function(a){var s=/[^\u4E00-\u9FA5A-Za-z]+/g,l=a.slice(2,a.length-t.length-1),c="";e?(c=r(a).replace(s,""),c=c.slice(0,c.length-t.length)):c=l,h.push(l),d[l]={value:c,relative_path:a,relative_folder:o(a)},console.log("x---",a),u[c]=i?"\n            <div>\n            <code>\n              ".concat(n(a).default,"\n            </code>\n            </div>\n            "):n(a).default})),h.sort((function(n,t){return parseFloat(n)-parseFloat(t)})),h.map((function(n){p.push({label:s?l(n):n,value:d[n]["value"],modules_obj:a()({},d[n])})})),console.log("all_components------------",u),console.log("all_modules---------------",p),{all_components:u,all_modules:p}}},"46e3":function(n,t,e){"use strict";e.r(t),t["default"]="# 树\n\n树就是一种类似现实生活中的树的数据结构（倒置的树）。任何一颗非空树只有一个根节点。\n\n一棵树具有以下特点：\n\n1. 一棵树中的任意两个结点有且仅有唯一的一条路径连通。\n2. 一棵树如果有 n 个结点，那么它一定恰好有 n-1 条边。\n3. 一棵树不包含回路。\n\n下图就是一颗树，并且是一颗二叉树。\n\n![二叉树](树.assets/二叉树-2.png)\n\n如上图所示，通过上面这张图说明一下树中的常用概念：\n\n- **节点** ：树中的每个元素都可以统称为节点。\n- **根节点** ：顶层节点或者说没有父节点的节点。上图中 A 节点就是根节点。\n- **父节点** ：若一个节点含有子节点，则这个节点称为其子节点的父节点。上图中的 B 节点是 D 节点、E 节点的父节点。\n- **子节点** ：一个节点含有的子树的根节点称为该节点的子节点。上图中 D 节点、E 节点是 B 节点的子节点。\n- **兄弟节点** ：具有相同父节点的节点互称为兄弟节点。上图中 D 节点、E 节点的共同父节点是 B 节点，故 D 和 E 为兄弟节点。\n- **叶子节点** ：没有子节点的节点。上图中的 D、F、H、I 都是叶子节点。\n- **节点的高度** ：该节点到叶子节点的最长路径所包含的边数。\n- **节点的深度** ：根节点到该节点的路径所包含的边数\n- **节点的层数** ：节点的深度+1。\n- **树的高度** ：根节点的高度。\n\n## 二叉树的分类\n\n**二叉树**（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。\n\n**二叉树** 的分支通常被称作“**左子树**”或“**右子树**”。并且，**二叉树** 的分支具有左右次序，不能随意颠倒。\n\n**二叉树** 的第 i 层至多拥有 `2^(i-1)` 个节点，深度为 k 的二叉树至多总共有 `2^k-1` 个节点\n\n### 满二叉树\n\n一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是 **满二叉树**。也就是说，如果一个二叉树的层数为 K，且结点总数是(2^k) -1 ，则它就是 **满二叉树**。如下图所示：\n\n![](树.assets/满二叉树.png)\n\n### 完全二叉树\n\n除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则这个二叉树就是 **完全二叉树** 。\n\n大家可以想象为一棵树从根结点开始扩展，扩展完左子节点才能开始扩展右子节点，每扩展完一层，才能继续扩展下一层。如下图所示：\n\n![](树.assets/完全二叉树.png)\n\n完全二叉树有一个很好的性质：**父结点和子节点的序号有着对应关系。**\n\n细心的小伙伴可能发现了，当根节点的值为 1 的情况下，若父结点的序号是 i，那么左子节点的序号就是 2i，右子节点的序号是 2i+1。这个性质使得完全二叉树利用数组存储时可以极大地节省空间，以及利用序号找到某个节点的父结点和子节点，后续二叉树的存储会详细介绍。\n\n### 平衡二叉树\n\n**平衡二叉树** 是一棵二叉排序树，且具有以下性质：\n\n1. 可以是一棵空树\n2. 如果不是空树，它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。\n\n平衡二叉树的常用实现方法有 **红黑树**、**AVL 树**、**替罪羊树**、**加权平衡树**、**伸展树** 等。\n\n在给大家展示平衡二叉树之前，先给大家看一棵树：\n\n![](树.assets/斜树.png)\n\n**你管这玩意儿叫树？？？**\n\n没错，这玩意儿还真叫树，只不过这棵树已经退化为一个链表了，我们管它叫 **斜树**。\n\n**如果这样，那我为啥不直接用链表呢?**\n\n谁说不是呢？\n\n二叉树相比于链表，由于父子节点以及兄弟节点之间往往具有某种特殊的关系，这种关系使得我们在树中对数据进行**搜索**和**修改**时，相对于链表更加快捷便利。\n\n但是，如果二叉树退化为一个链表了，那么那么树所具有的优秀性质就难以表现出来，效率也会大打折，为了避免这样的情况，我们希望每个做 “家长”（父结点） 的，都 **一碗水端平**，分给左儿子和分给右儿子的尽可能一样多，相差最多不超过一层，如下图所示：\n\n![](树.assets/平衡二叉树.png)\n\n## 二叉树的存储\n\n二叉树的存储主要分为 **链式存储** 和 **顺序存储** 两种：\n\n### 链式存储\n\n和链表类似，二叉树的链式存储依靠指针将各个节点串联起来，不需要连续的存储空间。\n\n每个节点包括三个属性：\n\n- 数据 data。data 不一定是单一的数据，根据不同情况，可以是多个具有不同类型的数据。\n- 左节点指针 left\n- 右节点指针 right。\n\n可是 JAVA 没有指针啊！\n\n那就直接引用对象呗（别问我对象哪里找）\n\n![](树.assets/链式存储二叉树.png)\n\n### 顺序存储\n\n顺序存储就是利用数组进行存储，数组中的每一个位置仅存储节点的 data，不存储左右子节点的指针，子节点的索引通过数组下标完成。根结点的序号为 1，对于每个节点 Node，假设它存储在数组中下标为 i 的位置，那么它的左子节点就存储在 2 _ i 的位置，它的右子节点存储在下标为 2 _ i+1 的位置。\n\n一棵完全二叉树的数组顺序存储如下图所示：\n\n![](树.assets/顺序存储.png)\n\n大家可以试着填写一下存储如下二叉树的数组，比较一下和完全二叉树的顺序存储有何区别：\n\n![](树.assets/顺序存储2.png)\n\n可以看到，如果我们要存储的二叉树不是完全二叉树，在数组中就会出现空隙，导致内存利用率降低\n\n## 二叉树的遍历\n\n### 先序遍历\n\n![](树.assets/先序遍历.png)\n\n二叉树的先序遍历，就是先输出根结点，再遍历左子树，最后遍历右子树，遍历左子树和右子树的时候，同样遵循先序遍历的规则，也就是说，我们可以递归实现先序遍历。\n\n代码如下：\n\n```java\npublic void preOrder(TreeNode root){\n\tif(root == null){\n\t\treturn;\n\t}\n\tsystem.out.println(root.data);\n\tpreOrder(root.left);\n\tpreOrder(root.right);\n}\n```\n\n### 中序遍历\n\n![](树.assets/中序遍历.png)\n\n二叉树的中序遍历，就是先递归中序遍历左子树，再输出根结点的值，再递归中序遍历右子树，大家可以想象成一巴掌把树压扁，父结点被拍到了左子节点和右子节点的中间，如下图所示：\n\n![](树.assets/中序遍历2.png)\n\n代码如下：\n\n```java\npublic void inOrder(TreeNode root){\n\tif(root == null){\n\t\treturn;\n\t}\n\tinOrder(root.left);\n\tsystem.out.println(root.data);\n\tinOrder(root.right);\n}\n```\n\n### 后序遍历\n\n![](树.assets/后序遍历.png)\n\n二叉树的后序遍历，就是先递归后序遍历左子树，再递归后序遍历右子树，最后输出根结点的值\n\n代码如下：\n\n```java\npublic void postOrder(TreeNode root){\n\tif(root == null){\n\t\treturn;\n\t}\n\tpostOrder(root.left);\n\tpostOrder(root.right);\n\tsystem.out.println(root.data);\n}\n```"},"53b8":function(n,t,e){"use strict";e.r(t),t["default"]="\x3c!-- MarkdownTOC --\x3e\n\n- [1. 两数相加](#1-两数相加)\n  - [题目描述](#题目描述)\n  - [问题分析](#问题分析)\n  - [Solution](#solution)\n- [2. 翻转链表](#2-翻转链表)\n  - [题目描述](#题目描述-1)\n  - [问题分析](#问题分析-1)\n  - [Solution](#solution-1)\n- [3. 链表中倒数第k个节点](#3-链表中倒数第k个节点)\n  - [题目描述](#题目描述-2)\n  - [问题分析](#问题分析-2)\n  - [Solution](#solution-2)\n- [4. 删除链表的倒数第N个节点](#4-删除链表的倒数第n个节点)\n  - [问题分析](#问题分析-3)\n  - [Solution](#solution-3)\n- [5. 合并两个排序的链表](#5-合并两个排序的链表)\n  - [题目描述](#题目描述-3)\n  - [问题分析](#问题分析-4)\n  - [Solution](#solution-4)\n\n\x3c!-- /MarkdownTOC --\x3e\n\n\n# 1. 两数相加\n\n### 题目描述\n\n> Leetcode:给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。\n>\n>你可以假设除了数字 0 之外，这两个数字都不会以零开头。\n\n示例：\n\n```\n输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)\n输出：7 -> 0 -> 8\n原因：342 + 465 = 807\n```\n\n### 问题分析\n\nLeetcode官方详细解答地址：\n\n https://leetcode-cn.com/problems/add-two-numbers/solution/\n\n> 要对头结点进行操作时，考虑创建哑节点dummy，使用dummy->next表示真正的头节点。这样可以避免处理头节点为空的边界问题。\n\n我们使用变量来跟踪进位，并从包含最低有效位的表头开始模拟逐\n位相加的过程。\n\n![图1，对两数相加方法的可视化: 342 + 465 = 807342+465=807， 每个结点都包含一个数字，并且数字按位逆序存储。](几道常见的链表算法题.assets/34910956.jpg)\n\n### Solution\n\n**我们首先从最低有效位也就是列表 l1和 l2 的表头开始相加。注意需要考虑到进位的情况！**\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n //https://leetcode-cn.com/problems/add-two-numbers/description/\nclass Solution {\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    ListNode dummyHead = new ListNode(0);\n    ListNode p = l1, q = l2, curr = dummyHead;\n    //carry 表示进位数\n    int carry = 0;\n    while (p != null || q != null) {\n        int x = (p != null) ? p.val : 0;\n        int y = (q != null) ? q.val : 0;\n        int sum = carry + x + y;\n        //进位数\n        carry = sum / 10;\n        //新节点的数值为sum % 10\n        curr.next = new ListNode(sum % 10);\n        curr = curr.next;\n        if (p != null) p = p.next;\n        if (q != null) q = q.next;\n    }\n    if (carry > 0) {\n        curr.next = new ListNode(carry);\n    }\n    return dummyHead.next;\n}\n}\n```\n\n# 2. 翻转链表\n\n\n### 题目描述\n> 剑指 offer:输入一个链表，反转链表后，输出链表的所有元素。\n\n![翻转链表](几道常见的链表算法题.assets/81431871.jpg)\n\n### 问题分析\n\n这道算法题，说直白点就是：如何让后一个节点指向前一个节点！在下面的代码中定义了一个 next 节点，该节点主要是保存要反转到头的那个节点，防止链表 “断裂”。\n\n### Solution\n\n\n```java\npublic class ListNode {\n  int val;\n  ListNode next = null;\n\n  ListNode(int val) {\n    this.val = val;\n  }\n}\n```\n\n```java\n/**\n * \n * @author Snailclimb\n * @date 2018年9月19日\n * @Description: TODO\n */\npublic class Solution {\n\n  public ListNode ReverseList(ListNode head) {\n\n    ListNode next = null;\n    ListNode pre = null;\n\n    while (head != null) {\n      // 保存要反转到头的那个节点\n      next = head.next;\n      // 要反转的那个节点指向已经反转的上一个节点(备注:第一次反转的时候会指向null)\n      head.next = pre;\n      // 上一个已经反转到头部的节点\n      pre = head;\n      // 一直向链表尾走\n      head = next;\n    }\n    return pre;\n  }\n\n}\n```\n\n测试方法：\n\n```java\n  public static void main(String[] args) {\n\n    ListNode a = new ListNode(1);\n    ListNode b = new ListNode(2);\n    ListNode c = new ListNode(3);\n    ListNode d = new ListNode(4);\n    ListNode e = new ListNode(5);\n    a.next = b;\n    b.next = c;\n    c.next = d;\n    d.next = e;\n    new Solution().ReverseList(a);\n    while (e != null) {\n      System.out.println(e.val);\n      e = e.next;\n    }\n  }\n```\n\n输出：\n\n```\n5\n4\n3\n2\n1\n```\n\n# 3. 链表中倒数第k个节点\n\n### 题目描述\n\n> 剑指offer: 输入一个链表，输出该链表中倒数第k个结点。\n\n### 问题分析\n\n> **链表中倒数第k个节点也就是正数第(L-K+1)个节点，知道了只一点，这一题基本就没问题！**\n\n首先两个节点/指针，一个节点 node1 先开始跑，指针 node1 跑到 k-1 个节点后，另一个节点 node2 开始跑，当 node1 跑到最后时，node2 所指的节点就是倒数第k个节点也就是正数第(L-K+1)个节点。\n\n\n### Solution\n\n```java\n/*\npublic class ListNode {\n    int val;\n    ListNode next = null;\n\n    ListNode(int val) {\n        this.val = val;\n    }\n}*/\n\n// 时间复杂度O(n),一次遍历即可\n// https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&tqId=11167&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking\npublic class Solution {\n  public ListNode FindKthToTail(ListNode head, int k) {\n    // 如果链表为空或者k小于等于0\n    if (head == null || k <= 0) {\n      return null;\n    }\n    // 声明两个指向头结点的节点\n    ListNode node1 = head, node2 = head;\n    // 记录节点的个数\n    int count = 0;\n    // 记录k值，后面要使用\n    int index = k;\n    // p指针先跑，并且记录节点数，当node1节点跑了k-1个节点后，node2节点开始跑，\n    // 当node1节点跑到最后时，node2节点所指的节点就是倒数第k个节点\n    while (node1 != null) {\n      node1 = node1.next;\n      count++;\n      if (k < 1) {\n        node2 = node2.next;\n      }\n      k--;\n    }\n    // 如果节点个数小于所求的倒数第k个节点，则返回空\n    if (count < index)\n      return null;\n    return node2;\n\n  }\n}\n```\n\n\n# 4. 删除链表的倒数第N个节点\n\n\n> Leetcode:给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。\n\n**示例：**\n\n```\n给定一个链表: 1->2->3->4->5, 和 n = 2.\n\n当删除了倒数第二个节点后，链表变为 1->2->3->5.\n\n```\n\n**说明：**\n\n给定的 n 保证是有效的。\n\n**进阶：**\n\n你能尝试使用一趟扫描实现吗？\n\n该题在 leetcode 上有详细解答，具体可参考 Leetcode.\n\n### 问题分析\n\n\n我们注意到这个问题可以容易地简化成另一个问题：删除从列表开头数起的第 (L - n + 1)个结点，其中 L是列表的长度。只要我们找到列表的长度 L，这个问题就很容易解决。\n\n![图 1. 删除列表中的第 L - n + 1 个元素](几道常见的链表算法题.assets/94354387.jpg)\n\n### Solution\n\n**两次遍历法**\n\n首先我们将添加一个 **哑结点** 作为辅助，该结点位于列表头部。哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。在第一次遍历中，我们找出列表的长度 L。然后设置一个指向哑结点的指针，并移动它遍历列表，直至它到达第 (L - n) 个结点那里。**我们把第 (L - n)个结点的 next 指针重新链接至第 (L - n + 2)个结点，完成这个算法。**\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n// https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/description/\npublic class Solution {\n  public ListNode removeNthFromEnd(ListNode head, int n) {\n    // 哑结点，哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部\n    ListNode dummy = new ListNode(0);\n    // 哑结点指向头结点\n    dummy.next = head;\n    // 保存链表长度\n    int length = 0;\n    ListNode len = head;\n    while (len != null) {\n      length++;\n      len = len.next;\n    }\n    length = length - n;\n    ListNode target = dummy;\n    // 找到 L-n 位置的节点\n    while (length > 0) {\n      target = target.next;\n      length--;\n    }\n    // 把第 (L - n)个结点的 next 指针重新链接至第 (L - n + 2)个结点\n    target.next = target.next.next;\n    return dummy.next;\n  }\n}\n```\n\n**复杂度分析：**\n\n- **时间复杂度 O(L)** ：该算法对列表进行了两次遍历，首先计算了列表的长度 LL 其次找到第 (L - n)(L−n) 个结点。 操作执行了 2L-n2L−n 步，时间复杂度为 O(L)O(L)。\n- **空间复杂度 O(1)** ：我们只用了常量级的额外空间。 \n\n\n\n**进阶——一次遍历法：**\n\n\n> 链表中倒数第N个节点也就是正数第(L-N+1)个节点。\n\n其实这种方法就和我们上面第四题找“链表中倒数第k个节点”所用的思想是一样的。**基本思路就是：**  定义两个节点 node1、node2;node1 节点先跑，node1节点 跑到第 n+1 个节点的时候,node2 节点开始跑.当node1 节点跑到最后一个节点时，node2 节点所在的位置就是第 （L-n ） 个节点（L代表总链表长度，也就是倒数第 n+1 个节点）\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n  public ListNode removeNthFromEnd(ListNode head, int n) {\n\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    // 声明两个指向头结点的节点\n    ListNode node1 = dummy, node2 = dummy;\n\n    // node1 节点先跑，node1节点 跑到第 n 个节点的时候,node2 节点开始跑\n    // 当node1 节点跑到最后一个节点时，node2 节点所在的位置就是第 （L-n ） 个节点，也就是倒数第 n+1（L代表总链表长度）\n    while (node1 != null) {\n      node1 = node1.next;\n      if (n < 1 && node1 != null) {\n        node2 = node2.next;\n      }\n      n--;\n    }\n\n    node2.next = node2.next.next;\n\n    return dummy.next;\n\n  }\n}\n```\n\n\n\n\n\n# 5. 合并两个排序的链表\n\n### 题目描述\n\n> 剑指offer:输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。\n\n### 问题分析\n\n我们可以这样分析: \n\n1. 假设我们有两个链表 A,B； \n2. A的头节点A1的值与B的头结点B1的值比较，假设A1小，则A1为头节点； \n3. A2再和B1比较，假设B1小,则，A1指向B1； \n4. A2再和B2比较\n就这样循环往复就行了，应该还算好理解。\n\n考虑通过递归的方式实现！\n\n### Solution\n\n**递归版本：**\n\n```java\n/*\npublic class ListNode {\n    int val;\n    ListNode next = null;\n\n    ListNode(int val) {\n        this.val = val;\n    }\n}*/\n//https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&tqId=11169&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking\npublic class Solution {\npublic ListNode Merge(ListNode list1,ListNode list2) {\n       if(list1 == null){\n           return list2;\n       }\n       if(list2 == null){\n           return list1;\n       }\n       if(list1.val <= list2.val){\n           list1.next = Merge(list1.next, list2);\n           return list1;\n       }else{\n           list2.next = Merge(list1, list2.next);\n           return list2;\n       }       \n   }\n}\n```\n\n"},5980:function(n,t,e){"use strict";e.r(t),t["default"]="# 图\n\n> 开头还是求点赞，求转发！原创优质公众号，希望大家能让更多人看到我们的文章。\n>\n> 图片都是我们手绘的，可以说非常用心了！\n\n图是一种较为复杂的非线性结构。 **为啥说其较为复杂呢？**\n\n根据前面的内容，我们知道：\n\n- 线性数据结构的元素满足唯一的线性关系，每个元素(除第一个和最后一个外)只有一个直接前趋和一个直接后继。\n- 树形数据结构的元素之间有着明显的层次关系。\n\n但是，图形结构的元素之间的关系是任意的。\n\n**何为图呢？** 简单来说，图就是由顶点的有穷非空集合和顶点之间的边组成的集合。通常表示为：**G(V,E)**，其中，G表示一个图，V表示顶点的集合，E表示边的集合。\n\n下图所展示的就是图这种数据结构，并且还是一张有向图。\n\n![图](图.assets/图.png)\n\n图在我们日常生活中的例子很多！比如我们在社交软件上好友关系就可以用图来表示。\n\n## 图的基本概念\n\n### 顶点\n图中的数据元素，我们称之为顶点，图至少有一个顶点（非空有穷集合）\n\n对应到好友关系图，每一个用户就代表一个顶点。\n\n### 边\n顶点之间的关系用边表示。\n\n对应到好友关系图，两个用户是好友的话，那两者之间就存在一条边。\n\n### 度\n度表示一个顶点包含多少条边，在有向图中，还分为出度和入度，出度表示从该顶点出去的边的条数，入度表示进入该顶点的边的条数。\n\n对应到好友关系图，度就代表了某个人的好友数量。\n\n### 无向图和有向图\n边表示的是顶点之间的关系，有的关系是双向的，比如同学关系，A是B的同学，那么B也肯定是A的同学，那么在表示A和B的关系时，就不用关注方向，用不带箭头的边表示，这样的图就是无向图。\n\n有的关系是有方向的，比如父子关系，师生关系，微博的关注关系，A是B的爸爸，但B肯定不是A的爸爸，A关注B，B不一定关注A。在这种情况下，我们就用带箭头的边表示二者的关系，这样的图就是有向图。\n\n### 无权图和带权图\n\n对于一个关系，如果我们只关心关系的有无，而不关心关系有多强，那么就可以用无权图表示二者的关系。\n\n对于一个关系，如果我们既关心关系的有无，也关心关系的强度，比如描述地图上两个城市的关系，需要用到距离，那么就用带权图来表示，带权图中的每一条边一个数值表示权值，代表关系的强度。\n\n![image-20211030113847042](图.assets/image-20211030113847042.png)\n\n\n\n## 图的存储\n### 邻接矩阵存储\n邻接矩阵将图用二维矩阵存储，是一种较为直观的表示方式。\n\n如果第i个顶点和第j个顶点之间有关系，且关系权值为n，则 `A[i][j]=n` 。\n\n在无向图中，我们只关心关系的有无，所以当顶点i和顶点j有关系时，`A[i][j]`=1，当顶点i和顶点j没有关系时，`A[i][j]`=0。如下图所示：\n\n![无向图的邻接矩阵存储](图.assets/无向图的邻接矩阵存储.png)\n\n值得注意的是：**无向图的邻接矩阵是一个对称矩阵，因为在无向图中，顶点i和顶点j有关系，则顶点j和顶点i必有关系。**\n\n![有向图的邻接矩阵存储](图.assets/有向图的邻接矩阵存储.png)\n\n邻接矩阵存储的方式优点是简单直接（直接使用一个二维数组即可），并且，在获取两个定点之间的关系的时候也非常高效（直接获取指定位置的数组元素的值即可）。但是，这种存储方式的缺点也比较明显，那就是比较浪费空间，\n\n### 邻接表存储\n\n针对上面邻接矩阵比较浪费内存空间的问题，诞生了图的另外一种存储方法—**邻接表** 。\n\n邻接链表使用一个链表来存储某个顶点的所有后继相邻顶点。对于图中每个顶点Vi，把所有邻接于Vi的顶点Vj链成一个单链表，这个单链表称为顶点Vi的 **邻接表**。如下图所示：\n\n\n\n![无向图的邻接表存储](图.assets/无向图的邻接表存储.png)\n\n\n\n![有向图的邻接表存储](图.assets/有向图的邻接表存储.png)\n\n大家可以数一数邻接表中所存储的元素的个数以及图中边的条数，你会发现：\n\n- 在无向图中，邻接表元素个数等于边的条数的两倍，如左图所示的无向图中，边的条数为7，邻接表存储的元素个数为14。\n- 在有向图中，邻接表元素个数等于边的条数，如右图所示的有向图中，边的条数为8，邻接表存储的元素个数为8。\n\n## 图的搜索\n### 广度优先搜索\n广度优先搜索就像水面上的波纹一样一层一层向外扩展，如下图所示：\n\n![广度优先搜索图示](图.assets/广度优先搜索图示.png)\n\n**广度优先搜索的具体实现方式用到了之前所学过的线性数据结构——队列** 。具体过程如下图所示：\n\n**第1步：**\n\n![广度优先搜索1](图.assets/广度优先搜索1.png)\n\n**第2步：**\n\n![广度优先搜索2](图.assets/广度优先搜索2.png)\n\n**第3步：**\n\n![广度优先搜索3](图.assets/广度优先搜索3.png)\n\n**第4步：**\n\n![广度优先搜索4](图.assets/广度优先搜索4.png)\n\n**第5步：**\n\n![广度优先搜索5](图.assets/广度优先搜索5.png)\n\n**第6步：**\n\n![广度优先搜索6](图.assets/广度优先搜索6.png)\n\n### 深度优先搜索\n\n深度优先搜索就是“一条路走到黑”，从源顶点开始，一直走到没有后继节点，才回溯到上一顶点，然后继续“一条路走到黑”，如下图所示：\n\n![深度优先搜索图示](图.assets/深度优先搜索图示.png)\n\n\n**和广度优先搜索类似，深度优先搜索的具体实现用到了另一种线性数据结构——栈** 。具体过程如下图所示：\n\n**第1步：**\n\n![深度优先搜索1](图.assets/深度优先搜索1.png)\n\n**第2步：**\n\n![深度优先搜索1](图.assets/深度优先搜索2.png)\n\n**第3步：**\n\n![深度优先搜索1](图.assets/深度优先搜索3.png)\n\n**第4步：**\n\n![深度优先搜索1](图.assets/深度优先搜索4.png)\n\n**第5步：**\n\n![深度优先搜索1](图.assets/深度优先搜索5.png)\n\n**第6步：**\n\n![深度优先搜索1](图.assets/深度优先搜索6.png)\n\n"},7725:function(n,t,e){"use strict";e.r(t),t["default"]='海量数据处理以及缓存穿透这两个场景让我认识了 布隆过滤器 ，我查阅了一些资料来了解它，但是很多现成资料并不满足我的需求，所以就决定自己总结一篇关于布隆过滤器的文章。希望通过这篇文章让更多人了解布隆过滤器，并且会实际去使用它！\n\n下面我们将分为几个方面来介绍布隆过滤器：\n\n1. 什么是布隆过滤器？\n2. 布隆过滤器的原理介绍。\n3. 布隆过滤器使用场景。\n4. 通过 Java 编程手动实现布隆过滤器。\n5. 利用 Google 开源的 Guava 中自带的布隆过滤器。\n6. Redis 中的布隆过滤器。\n\n### 1.什么是布隆过滤器？\n\n首先，我们需要了解布隆过滤器的概念。\n\n布隆过滤器（Bloom Filter）是一个叫做 Bloom 的老哥于 1970 年提出的。我们可以把它看作由二进制向量（或者说位数组）和一系列随机映射函数（哈希函数）两部分组成的数据结构。相比于我们平时常用的的 List、Map 、Set 等数据结构，它占用空间更少并且效率更高，但是缺点是其返回的结果是概率性的，而不是非常准确的。理论情况下添加到集合中的元素越多，误报的可能性就越大。并且，存放在布隆过滤器的数据不容易删除。\n\n![布隆过滤器示意图](bloom-filter.assets/布隆过滤器-bit数组.png)\n\n位数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。这样申请一个 100w 个元素的位数组只占用 1000000Bit / 8 = 125000 Byte = 125000/1024 kb ≈ 122kb 的空间。\n\n总结：**一个名叫 Bloom 的人提出了一种来检索元素是否在给定大集合中的数据结构，这种数据结构是高效且性能很好的，但缺点是具有一定的错误识别率和删除难度。并且，理论情况下，添加到集合中的元素越多，误报的可能性就越大。**\n\n### 2.布隆过滤器的原理介绍\n\n**当一个元素加入布隆过滤器中的时候，会进行如下操作：**\n\n1. 使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。\n2. 根据得到的哈希值，在位数组中把对应下标的值置为 1。\n\n**当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：**\n\n1. 对给定元素再次进行相同的哈希计算；\n2. 得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。\n\n举个简单的例子：\n\n![布隆过滤器hash计算](bloom-filter.assets/布隆过滤器-hash运算.png)\n\n如图所示，当字符串存储要加入到布隆过滤器中时，该字符串首先由多个哈希函数生成不同的哈希值，然后将对应的位数组的下标设置为 1（当位数组初始化时，所有位置均为 0）。当第二次存储相同字符串时，因为先前的对应位置已设置为 1，所以很容易知道此值已经存在（去重非常方便）。\n\n如果我们需要判断某个字符串是否在布隆过滤器中时，只需要对给定字符串再次进行相同的哈希计算，得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。\n\n**不同的字符串可能哈希出来的位置相同，这种情况我们可以适当增加位数组大小或者调整我们的哈希函数。**\n\n综上，我们可以得出：**布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。**\n\n### 3.布隆过滤器使用场景\n\n1. 判断给定数据是否存在：比如判断一个数字是否存在于包含大量数字的数字集中（数字集很大，5 亿以上！）、 防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）等等、邮箱的垃圾邮件过滤、黑名单功能等等。\n2. 去重：比如爬给定网址的时候对已经爬取过的 URL 去重。\n\n### 4.通过 Java 编程手动实现布隆过滤器\n\n我们上面已经说了布隆过滤器的原理，知道了布隆过滤器的原理之后就可以自己手动实现一个了。\n\n如果你想要手动实现一个的话，你需要：\n\n1. 一个合适大小的位数组保存数据\n2. 几个不同的哈希函数\n3. 添加元素到位数组（布隆过滤器）的方法实现\n4. 判断给定元素是否存在于位数组（布隆过滤器）的方法实现。\n\n下面给出一个我觉得写的还算不错的代码（参考网上已有代码改进得到，对于所有类型对象皆适用）：\n\n```java\nimport java.util.BitSet;\n\npublic class MyBloomFilter {\n\n    /**\n     * 位数组的大小\n     */\n    private static final int DEFAULT_SIZE = 2 << 24;\n    /**\n     * 通过这个数组可以创建 6 个不同的哈希函数\n     */\n    private static final int[] SEEDS = new int[]{3, 13, 46, 71, 91, 134};\n\n    /**\n     * 位数组。数组中的元素只能是 0 或者 1\n     */\n    private BitSet bits = new BitSet(DEFAULT_SIZE);\n\n    /**\n     * 存放包含 hash 函数的类的数组\n     */\n    private SimpleHash[] func = new SimpleHash[SEEDS.length];\n\n    /**\n     * 初始化多个包含 hash 函数的类的数组，每个类中的 hash 函数都不一样\n     */\n    public MyBloomFilter() {\n        // 初始化多个不同的 Hash 函数\n        for (int i = 0; i < SEEDS.length; i++) {\n            func[i] = new SimpleHash(DEFAULT_SIZE, SEEDS[i]);\n        }\n    }\n\n    /**\n     * 添加元素到位数组\n     */\n    public void add(Object value) {\n        for (SimpleHash f : func) {\n            bits.set(f.hash(value), true);\n        }\n    }\n\n    /**\n     * 判断指定元素是否存在于位数组\n     */\n    public boolean contains(Object value) {\n        boolean ret = true;\n        for (SimpleHash f : func) {\n            ret = ret && bits.get(f.hash(value));\n        }\n        return ret;\n    }\n\n    /**\n     * 静态内部类。用于 hash 操作！\n     */\n    public static class SimpleHash {\n\n        private int cap;\n        private int seed;\n\n        public SimpleHash(int cap, int seed) {\n            this.cap = cap;\n            this.seed = seed;\n        }\n\n        /**\n         * 计算 hash 值\n         */\n        public int hash(Object value) {\n            int h;\n            return (value == null) ? 0 : Math.abs(seed * (cap - 1) & ((h = value.hashCode()) ^ (h >>> 16)));\n        }\n\n    }\n}\n```\n\n测试：\n\n```java\nString value1 = "https://javaguide.cn/";\nString value2 = "https://github.com/Snailclimb";\nMyBloomFilter filter = new MyBloomFilter();\nSystem.out.println(filter.contains(value1));\nSystem.out.println(filter.contains(value2));\nfilter.add(value1);\nfilter.add(value2);\nSystem.out.println(filter.contains(value1));\nSystem.out.println(filter.contains(value2));\n```\n\nOutput:\n\n```\nfalse\nfalse\ntrue\ntrue\n```\n\n测试：\n\n```java\nInteger value1 = 13423;\nInteger value2 = 22131;\nMyBloomFilter filter = new MyBloomFilter();\nSystem.out.println(filter.contains(value1));\nSystem.out.println(filter.contains(value2));\nfilter.add(value1);\nfilter.add(value2);\nSystem.out.println(filter.contains(value1));\nSystem.out.println(filter.contains(value2));\n```\n\nOutput:\n\n```java\nfalse\nfalse\ntrue\ntrue\n```\n\n### 5.利用 Google 开源的 Guava 中自带的布隆过滤器\n\n自己实现的目的主要是为了让自己搞懂布隆过滤器的原理，Guava 中布隆过滤器的实现算是比较权威的，所以实际项目中我们不需要手动实现一个布隆过滤器。\n\n首先我们需要在项目中引入 Guava 的依赖：\n\n```java\n<dependency>\n    <groupId>com.google.guava</groupId>\n    <artifactId>guava</artifactId>\n    <version>28.0-jre</version>\n</dependency>\n```\n\n实际使用如下：\n\n我们创建了一个最多存放 最多 1500 个整数的布隆过滤器，并且我们可以容忍误判的概率为百分之（0.01）\n\n```java\n// 创建布隆过滤器对象\nBloomFilter<Integer> filter = BloomFilter.create(\n    Funnels.integerFunnel(),\n    1500,\n    0.01);\n// 判断指定元素是否存在\nSystem.out.println(filter.mightContain(1));\nSystem.out.println(filter.mightContain(2));\n// 将元素添加进布隆过滤器\nfilter.put(1);\nfilter.put(2);\nSystem.out.println(filter.mightContain(1));\nSystem.out.println(filter.mightContain(2));\n```\n\n在我们的示例中，当`mightContain()` 方法返回 _true_ 时，我们可以 99％确定该元素在过滤器中，当过滤器返回 _false_ 时，我们可以 100％确定该元素不存在于过滤器中。\n\n**Guava 提供的布隆过滤器的实现还是很不错的（想要详细了解的可以看一下它的源码实现），但是它有一个重大的缺陷就是只能单机使用（另外，容量扩展也不容易），而现在互联网一般都是分布式的场景。为了解决这个问题，我们就需要用到 Redis 中的布隆过滤器了。**\n\n### 6.Redis 中的布隆过滤器\n\n#### 6.1 介绍\n\nRedis v4.0 之后有了 Module（模块/插件） 功能，Redis Modules 让 Redis 可以使用外部模块扩展其功能 。布隆过滤器就是其中的 Module。详情可以查看 Redis 官方对 Redis Modules 的介绍 ：https://redis.io/modules\n\n另外，官网推荐了一个 RedisBloom 作为 Redis 布隆过滤器的 Module，地址：https://github.com/RedisBloom/RedisBloom \n其他还有：\n\n- redis-lua-scaling-bloom-filter（lua 脚本实现）：https://github.com/erikdubbelboer/redis-lua-scaling-bloom-filter\n- pyreBloom（Python 中的快速 Redis 布隆过滤器） ：https://github.com/seomoz/pyreBloom\n- ......\n\nRedisBloom 提供了多种语言的客户端支持，包括：Python、Java、JavaScript 和 PHP。\n\n#### 6.2 使用 Docker 安装\n\n如果我们需要体验 Redis 中的布隆过滤器非常简单，通过 Docker 就可以了！我们直接在 Google 搜索 **docker redis bloomfilter** 然后在排除广告的第一条搜素结果就找到了我们想要的答案（这是我平常解决问题的一种方式，分享一下），具体地址：https://hub.docker.com/r/redislabs/rebloom/ （介绍的很详细 ）。\n\n**具体操作如下：**\n\n```\n➜  ~ docker run -p 6379:6379 --name redis-redisbloom redislabs/rebloom:latest\n➜  ~ docker exec -it redis-redisbloom bash\nroot@21396d02c252:/data# redis-cli\n127.0.0.1:6379>\n```\n\n#### 6.3 常用命令一览\n\n> 注意： key : 布隆过滤器的名称，item : 添加的元素。\n\n1. **`BF.ADD`**：将元素添加到布隆过滤器中，如果该过滤器尚不存在，则创建该过滤器。格式：`BF.ADD {key} {item}`。\n2. **`BF.MADD`** : 将一个或多个元素添加到“布隆过滤器”中，并创建一个尚不存在的过滤器。该命令的操作方式`BF.ADD`与之相同，只不过它允许多个输入并返回多个值。格式：`BF.MADD {key} {item} [item ...]` 。\n3. **`BF.EXISTS`** : 确定元素是否在布隆过滤器中存在。格式：`BF.EXISTS {key} {item}`。\n4. **`BF.MEXISTS`** ： 确定一个或者多个元素是否在布隆过滤器中存在格式：`BF.MEXISTS {key} {item} [item ...]`。\n\n另外，`BF.RESERVE` 命令需要单独介绍一下：\n\n这个命令的格式如下：\n\n`BF.RESERVE {key} {error_rate} {capacity} [EXPANSION expansion]`。\n\n下面简单介绍一下每个参数的具体含义：\n\n1. key：布隆过滤器的名称\n2. error_rate : 期望的误报率。该值必须介于 0 到 1 之间。例如，对于期望的误报率 0.1％（1000 中为 1），error_rate 应该设置为 0.001。该数字越接近零，则每个项目的内存消耗越大，并且每个操作的 CPU 使用率越高。\n3. capacity: 过滤器的容量。当实际存储的元素个数超过这个值之后，性能将开始下降。实际的降级将取决于超出限制的程度。随着过滤器元素数量呈指数增长，性能将线性下降。\n\n可选参数：\n\n- expansion：如果创建了一个新的子过滤器，则其大小将是当前过滤器的大小乘以`expansion`。默认扩展值为 2。这意味着每个后续子过滤器将是前一个子过滤器的两倍。\n\n#### 6.4 实际使用\n\n```shell\n127.0.0.1:6379> BF.ADD myFilter java\n(integer) 1\n127.0.0.1:6379> BF.ADD myFilter javaguide\n(integer) 1\n127.0.0.1:6379> BF.EXISTS myFilter java\n(integer) 1\n127.0.0.1:6379> BF.EXISTS myFilter javaguide\n(integer) 1\n127.0.0.1:6379> BF.EXISTS myFilter github\n(integer) 0\n```\n'},"80bc":function(n,t,e){"use strict";e.r(t),t["default"]="**红黑树特点** :\n\n1. 每个节点非红即黑；\n2. 根节点总是黑色的；\n3. 每个叶子节点都是黑色的空节点（NIL节点）；\n4. 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；\n5. 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。\n\n**红黑树的应用** ：TreeMap、TreeSet以及JDK1.8的HashMap底层都用到了红黑树。\n\n**为什么要用红黑树？** 简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。详细了解可以查看 [漫画：什么是红黑树？](https://juejin.im/post/5a27c6946fb9a04509096248#comment)（也介绍到了二叉查找树，非常推荐）\n\n**相关阅读** ：[《红黑树深入剖析及Java实现》](https://zhuanlan.zhihu.com/p/24367771)（美团点评技术团队）    \n\n"},"8ca6":function(n,t,e){var i={"./bloom-filter.md":"7725","./几道常见的字符串算法题.md":"f533","./几道常见的链表算法题.md":"53b8","./剑指offer部分编程题.md":"131b","./图.md":"5980","./堆.md":"a449","./树.md":"46e3","./红黑树.md":"80bc","./线性数据结构.md":"9a8a"};function a(n){var t=s(n);return e(t)}function s(n){if(!e.o(i,n)){var t=new Error("Cannot find module '"+n+"'");throw t.code="MODULE_NOT_FOUND",t}return i[n]}a.keys=function(){return Object.keys(i)},a.resolve=s,n.exports=a,a.id="8ca6"},"9a8a":function(n,t,e){"use strict";e.r(t),t["default"]="# 线性数据结构\n\n> 开头还是求点赞，求转发！原创优质公众号，希望大家能让更多人看到我们的文章。\n>\n> 图片都是我们手绘的，可以说非常用心了！\n\n## 1. 数组\n\n**数组（Array）** 是一种很常见的数据结构。它由相同类型的元素（element）组成，并且是使用一块连续的内存来存储。\n\n我们直接可以利用元素的索引（index）可以计算出该元素对应的存储地址。\n\n数组的特点是：**提供随机访问** 并且容量有限。\n\n```java\n假如数组的长度为 n。\n访问：O（1）//访问特定位置的元素\n插入：O（n ）//最坏的情况发生在插入发生在数组的首部并需要移动所有元素时\n删除：O（n）//最坏的情况发生在删除数组的开头发生并需要移动第一元素后面所有的元素时\n```\n\n![数组](线性数据结构.assets/数组.png)\n\n## 2. 链表\n\n### 2.1. 链表简介\n\n**链表（LinkedList）** 虽然是一种线性表，但是并不会按线性的顺序存储数据，使用的不是连续的内存空间来存储数据。\n\n链表的插入和删除操作的复杂度为 O(1) ，只需要知道目标位置元素的上一个元素即可。但是，在查找一个节点或者访问特定位置的节点的时候复杂度为 O(n) 。\n\n使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间,实现灵活的内存动态管理。但链表不会节省空间，相比于数组会占用更多的空间，因为链表中每个节点存放的还有指向其他节点的指针。除此之外，链表不具有数组随机读取的优点。\n\n### 2.2. 链表分类\n\n**常见链表分类：**\n\n1. 单链表\n2. 双向链表\n3. 循环链表\n4. 双向循环链表\n\n```java\n假如链表中有n个元素。\n访问：O（n）//访问特定位置的元素\n插入删除：O（1）//必须要要知道插入元素的位置\n```\n\n#### 2.2.1. 单链表\n\n**单链表** 单向链表只有一个方向，结点只有一个后继指针 next 指向后面的节点。因此，链表这种数据结构通常在物理内存上是不连续的。我们习惯性地把第一个结点叫作头结点，链表通常有一个不保存任何值的 head 节点(头结点)，通过头结点我们可以遍历整个链表。尾结点通常指向 null。\n\n![单链表](线性数据结构.assets/单链表2.png)\n\n#### 2.2.2. 循环链表\n\n**循环链表** 其实是一种特殊的单链表，和单链表不同的是循环链表的尾结点不是指向 null，而是指向链表的头结点。\n\n![循环链表](线性数据结构.assets/循环链表2.png)\n\n#### 2.2.3. 双向链表\n\n**双向链表** 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。\n\n![双向链表](线性数据结构.assets/双向链表.png)\n\n#### 2.2.4. 双向循环链表\n\n**双向循环链表** 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。\n\n![双向循环链表](线性数据结构.assets/双向循环链表.png)\n\n### 2.3. 应用场景\n\n- 如果需要支持随机访问的话，链表没办法做到。\n- 如果需要存储的数据元素的个数不确定，并且需要经常添加和删除数据的话，使用链表比较合适。\n- 如果需要存储的数据元素的个数确定，并且不需要经常添加和删除数据的话，使用数组比较合适。\n\n### 2.4. 数组 vs 链表\n\n- 数组支持随机访问，而链表不支持。\n- 数组使用的是连续内存空间对 CPU 的缓存机制友好，链表则相反。\n- 数组的大小固定，而链表则天然支持动态扩容。如果声明的数组过小，需要另外申请一个更大的内存空间存放数组元素，然后将原数组拷贝进去，这个操作是比较耗时的！\n\n## 3. 栈\n\n### 3.1. 栈简介\n\n**栈** (stack)只允许在有序的线性数据集合的一端（称为栈顶 top）进行加入数据（push）和移除数据（pop）。因而按照 **后进先出（LIFO, Last In First Out）** 的原理运作。**在栈中，push 和 pop 的操作都发生在栈顶。**\n\n栈常用一维数组或链表来实现，用数组实现的栈叫作 **顺序栈** ，用链表实现的栈叫作 **链式栈** 。\n\n```java\n假设堆栈中有n个元素。\n访问：O（n）//最坏情况\n插入删除：O（1）//顶端插入和删除元素\n```\n\n![栈](线性数据结构.assets/栈.png)\n\n### 3.2. 栈的常见应用常见应用场景\n\n当我们我们要处理的数据只涉及在一端插入和删除数据，并且满足 **后进先出（LIFO, Last In First Out）** 的特性时，我们就可以使用栈这个数据结构。\n\n#### 3.2.1. 实现浏览器的回退和前进功能\n\n我们只需要使用两个栈(Stack1 和 Stack2)和就能实现这个功能。比如你按顺序查看了 1,2,3,4 这四个页面，我们依次把 1,2,3,4 这四个页面压入 Stack1 中。当你想回头看 2 这个页面的时候，你点击回退按钮，我们依次把 4,3 这两个页面从 Stack1 弹出，然后压入 Stack2 中。假如你又想回到页面 3，你点击前进按钮，我们将 3 页面从 Stack2 弹出，然后压入到 Stack1 中。示例图如下:\n\n![栈实现浏览器倒退和前进](线性数据结构.assets/栈实现浏览器倒退和前进.png)\n\n#### 3.2.2. 检查符号是否成对出现\n\n> 给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串，判断该字符串是否有效。\n>\n> 有效字符串需满足：\n>\n> 1.  左括号必须用相同类型的右括号闭合。\n> 2.  左括号必须以正确的顺序闭合。\n>\n> 比如 \"()\"、\"()[]{}\"、\"{[]}\" 都是有效字符串，而 \"(]\" 、\"([)]\" 则不是。\n\n这个问题实际是 Leetcode 的一道题目，我们可以利用栈 `Stack` 来解决这个问题。\n\n1. 首先我们将括号间的对应规则存放在 `Map` 中，这一点应该毋容置疑；\n2. 创建一个栈。遍历字符串，如果字符是左括号就直接加入`stack`中，否则将`stack` 的栈顶元素与这个括号做比较，如果不相等就直接返回 false。遍历结束，如果`stack`为空，返回 `true`。\n\n```java\npublic boolean isValid(String s){\n    // 括号之间的对应规则\n    HashMap<Character, Character> mappings = new HashMap<Character, Character>();\n    mappings.put(')', '(');\n    mappings.put('}', '{');\n    mappings.put(']', '[');\n    Stack<Character> stack = new Stack<Character>();\n    char[] chars = s.toCharArray();\n    for (int i = 0; i < chars.length; i++) {\n        if (mappings.containsKey(chars[i])) {\n            char topElement = stack.empty() ? '#' : stack.pop();\n            if (topElement != mappings.get(chars[i])) {\n                return false;\n            }\n        } else {\n            stack.push(chars[i]);\n        }\n    }\n    return stack.isEmpty();\n}\n```\n\n#### 3.2.3. 反转字符串\n\n将字符串中的每个字符先入栈再出栈就可以了。\n\n#### 3.2.4. 维护函数调用\n\n最后一个被调用的函数必须先完成执行，符合栈的 **后进先出（LIFO, Last In First Out）** 特性。\n\n### 3.3. 栈的实现\n\n栈既可以通过数组实现，也可以通过链表来实现。不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)。\n\n下面我们使用数组来实现一个栈，并且这个栈具有`push()`、`pop()`（返回栈顶元素并出栈）、`peek()` （返回栈顶元素不出栈）、`isEmpty()`、`size()`这些基本的方法。\n\n> 提示：每次入栈之前先判断栈的容量是否够用，如果不够用就用`Arrays.copyOf()`进行扩容；\n\n```java\npublic class MyStack {\n    private int[] storage;//存放栈中元素的数组\n    private int capacity;//栈的容量\n    private int count;//栈中元素数量\n    private static final int GROW_FACTOR = 2;\n\n    //不带初始容量的构造方法。默认容量为8\n    public MyStack() {\n        this.capacity = 8;\n        this.storage=new int[8];\n        this.count = 0;\n    }\n\n    //带初始容量的构造方法\n    public MyStack(int initialCapacity) {\n        if (initialCapacity < 1)\n            throw new IllegalArgumentException(\"Capacity too small.\");\n\n        this.capacity = initialCapacity;\n        this.storage = new int[initialCapacity];\n        this.count = 0;\n    }\n\n    //入栈\n    public void push(int value) {\n        if (count == capacity) {\n            ensureCapacity();\n        }\n        storage[count++] = value;\n    }\n\n    //确保容量大小\n    private void ensureCapacity() {\n        int newCapacity = capacity * GROW_FACTOR;\n        storage = Arrays.copyOf(storage, newCapacity);\n        capacity = newCapacity;\n    }\n\n    //返回栈顶元素并出栈\n    private int pop() {\n        if (count == 0)\n            throw new IllegalArgumentException(\"Stack is empty.\");\n        count--;\n        return storage[count];\n    }\n\n    //返回栈顶元素不出栈\n    private int peek() {\n        if (count == 0){\n            throw new IllegalArgumentException(\"Stack is empty.\");\n        }else {\n            return storage[count-1];\n        }\n    }\n\n    //判断栈是否为空\n    private boolean isEmpty() {\n        return count == 0;\n    }\n\n    //返回栈中元素的个数\n    private int size() {\n        return count;\n    }\n\n}\n```\n\n验证\n\n```java\nMyStack myStack = new MyStack(3);\nmyStack.push(1);\nmyStack.push(2);\nmyStack.push(3);\nmyStack.push(4);\nmyStack.push(5);\nmyStack.push(6);\nmyStack.push(7);\nmyStack.push(8);\nSystem.out.println(myStack.peek());//8\nSystem.out.println(myStack.size());//8\nfor (int i = 0; i < 8; i++) {\n    System.out.println(myStack.pop());\n}\nSystem.out.println(myStack.isEmpty());//true\nmyStack.pop();//报错：java.lang.IllegalArgumentException: Stack is empty.\n```\n\n## 4. 队列\n\n### 4.1. 队列简介\n\n**队列** 是 **先进先出( FIFO，First In, First Out)** 的线性表。在具体应用中通常用链表或者数组来实现，用数组实现的队列叫作 **顺序队列** ，用链表实现的队列叫作 **链式队列** 。**队列只允许在后端（rear）进行插入操作也就是 入队 enqueue，在前端（front）进行删除操作也就是出队 dequeue**\n\n队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。\n\n```java\n假设队列中有n个元素。\n访问：O（n）//最坏情况\n插入删除：O（1）//后端插入前端删除元素\n```\n\n![队列](线性数据结构.assets/队列.png)\n\n### 4.2. 队列分类\n\n#### 4.2.1. 单队列\n\n单队列就是常见的队列, 每次添加元素时，都是添加到队尾。单队列又分为 **顺序队列（数组实现）** 和 **链式队列（链表实现）**。\n\n**顺序队列存在“假溢出”的问题也就是明明有位置却不能添加的情况。**\n\n假设下图是一个顺序队列，我们将前两个元素 1,2 出队，并入队两个元素 7,8。当进行入队、出队操作的时候，front 和 rear 都会持续往后移动，当 rear 移动到最后的时候,我们无法再往队列中添加数据，即使数组中还有空余空间，这种现象就是 **”假溢出“** 。除了假溢出问题之外，如下图所示，当添加元素 8 的时候，rear 指针移动到数组之外（越界）。\n\n> 为了避免当只有一个元素的时候，队头和队尾重合使处理变得麻烦，所以引入两个指针，front 指针指向对头元素，rear 指针指向队列最后一个元素的下一个位置，这样当 front 等于 rear 时，此队列不是还剩一个元素，而是空队列。——From 《大话数据结构》\n\n![顺序队列假溢出](线性数据结构.assets/顺序队列假溢出1.png)\n\n#### 4.2.2. 循环队列\n\n循环队列可以解决顺序队列的假溢出和越界问题。解决办法就是：从头开始，这样也就会形成头尾相接的循环，这也就是循环队列名字的由来。\n\n还是用上面的图，我们将 rear 指针指向数组下标为 0 的位置就不会有越界问题了。当我们再向队列中添加元素的时候， rear 向后移动。\n\n![循环队列](线性数据结构.assets/循环队列.png)\n\n顺序队列中，我们说 `front==rear` 的时候队列为空，循环队列中则不一样，也可能为满，如上图所示。解决办法有两种：\n\n1. 可以设置一个标志变量 `flag`,当 `front==rear` 并且 `flag=0` 的时候队列为空，当`front==rear` 并且 `flag=1` 的时候队列为满。\n2. 队列为空的时候就是 `front==rear` ，队列满的时候，我们保证数组还有一个空闲的位置，rear 就指向这个空闲位置，如下图所示，那么现在判断队列是否为满的条件就是： `(rear+1) % QueueSize= front` 。\n\n![循环队列-队满](线性数据结构.assets/循环队列-堆满.png)\n\n### 4.3. 常见应用场景\n\n当我们需要按照一定顺序来处理数据的时候可以考虑使用队列这个数据结构。\n\n- **阻塞队列：** 阻塞队列可以看成在队列基础上加了阻塞操作的队列。当队列为空的时候，出队操作阻塞，当队列满的时候，入队操作阻塞。使用阻塞队列我们可以很容易实现“生产者 - 消费者“模型。\n- **线程池中的请求/任务队列：** 线程池中没有空闲线程时，新的任务请求线程资源时，线程池该如何处理呢？答案是将这些请求放在队列中，当有空闲线程的时候，会循环中反复从队列中获取任务来执行。队列分为无界队列(基于链表)和有界队列(基于数组)。无界队列的特点就是可以一直入列，除非系统资源耗尽，比如 ：`FixedThreadPool` 使用无界队列 `LinkedBlockingQueue`。但是有界队列就不一样了，当队列满的话后面再有任务/请求就会拒绝，在 Java 中的体现就是会抛出`java.util.concurrent.RejectedExecutionException` 异常。\n- Linux 内核进程队列（按优先级排队）\n- 现实生活中的派对，播放器上的播放列表;\n- 消息队列\n- 等等......\n"},a449:function(n,t,e){"use strict";e.r(t),t["default"]='# 堆\n\n## 什么是堆\n\n堆是一种满足以下条件的树：\n\n堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。或者说，任意一个节点的值都大于等于（或小于等于）所有子节点的值。\n\n> 大家可以把堆(最大堆)理解为一个公司,这个公司很公平,谁能力强谁就当老大,不存在弱的人当老大,老大手底下的人一定不会比他强。这样有助于理解后续堆的操作。\n\n**!!!特别提示：**\n\n- 很多博客说堆是完全二叉树，其实并非如此，**堆不一定是完全二叉树**，只是为了方便存储和索引，我们通常用完全二叉树的形式来表示堆，事实上，广为人知的斐波那契堆和二项堆就不是完全二叉树,它们甚至都不是二叉树。\n- （**二叉**）堆是一个数组，它可以被看成是一个 **近似的完全二叉树**。——《算法导论》第三版\n\n大家可以尝试判断下面给出的图是否是堆？\n\n![](堆.assets/堆1.png)\n\n第1个和第2个是堆。第1个是最大堆，每个节点都比子树中所有节点大。第2个是最小堆，每个节点都比子树中所有节点小。\n\n第3个不是，第三个中，根结点1比2和15小，而15却比3大，19比5大，不满足堆的性质。\n\n## 堆的用途\n当我们只关心所有数据中的最大值或者最小值，存在多次获取最大值或者最小值，多次插入或删除数据时，就可以使用堆。\n\n有小伙伴可能会想到用有序数组，初始化一个有序数组时间复杂度是 `O(nlog(n))`，查找最大值或者最小值时间复杂度都是 `O(1)`，但是，涉及到更新（插入或删除）数据时，时间复杂度为 `O(n)`，即使是使用复杂度为 `O(log(n))` 的二分法找到要插入或者删除的数据，在移动数据时也需要 `O(n)` 的时间复杂度。\n\n**相对于有序数组而言，堆的主要优势在于更新数据效率较高。** 堆的初始化时间复杂度为 `O(nlog(n))`，堆可以做到`O(1)`时间复杂度取出最大值或者最小值，`O(log(n))`时间复杂度插入或者删除数据，具体操作在后续章节详细介绍。\n\n## 堆的分类\n\n堆分为 **最大堆** 和 **最小堆**。二者的区别在于节点的排序方式。\n- **最大堆** ：堆中的每一个节点的值都大于等于子树中所有节点的值\n- **最小堆** ：堆中的每一个节点的值都小于等于子树中所有节点的值\n\n如下图所示，图1是最大堆，图2是最小堆\n\n![](堆.assets/堆2.png)\n\n\n## 堆的存储\n之前介绍树的时候说过，由于完全二叉树的优秀性质，利用数组存储二叉树即节省空间，又方便索引（若根结点的序号为1，那么对于树中任意节点i，其左子节点序号为 `2*i`，右子节点序号为 `2*i+1`）。\n\n为了方便存储和索引，（二叉）堆可以用完全二叉树的形式进行存储。存储的方式如下图所示：\n\n![堆的存储](堆.assets/堆的存储.png)\n\n## 堆的操作\n堆的更新操作主要包括两种 :  **插入元素** 和 **删除堆顶元素**。操作过程需要着重掌握和理解。\n> 在进入正题之前，再重申一遍，堆是一个公平的公司，有能力的人自然会走到与他能力所匹配的位置\n### 插入元素\n> 插入元素，作为一个新入职的员工，初来乍到，这个员工需要从基层做起\n\n**1.将要插入的元素放到最后**\n\n![堆-插入元素-1](堆.assets/堆-插入元素1.png)\n\n> 有能力的人会逐渐升职加薪，是金子总会发光的！！！\n\n**2.从底向上，如果父结点比该元素大，则该节点和父结点交换，直到无法交换**\n\n![堆-插入元素2](堆.assets/堆-插入元素2.png)\n\n![堆-插入元素3](堆.assets/堆-插入元素3.png)\n\n### 删除堆顶元素\n\n根据堆的性质可知，最大堆的堆顶元素为所有元素中最大的，最小堆的堆顶元素是所有元素中最小的。当我们需要多次查找最大元素或者最小元素的时候，可以利用堆来实现。\n\n删除堆顶元素后，为了保持堆的性质，需要对堆的结构进行调整，我们将这个过程称之为"**堆化**"，堆化的方法分为两种：\n\n- 一种是自底向上的堆化，上述的插入元素所使用的就是自底向上的堆化，元素从最底部向上移动。\n- 另一种是自顶向下堆化，元素由最顶部向下移动。在讲解删除堆顶元素的方法时，我将阐述这两种操作的过程，大家可以体会一下二者的不同。\n\n#### 自底向上堆化\n\n> 在堆这个公司中，会出现老大离职的现象，老大离职之后，他的位置就空出来了\n\n首先删除堆顶元素，使得数组中下标为1的位置空出。\n\n\n\n![删除堆顶元素1](堆.assets/删除堆顶元素1.png)\n\n\n> 那么他的位置由谁来接替呢，当然是他的直接下属了，谁能力强就让谁上呗\n\n比较根结点的左子节点和右子节点，也就是下标为2,3的数组元素，将较大的元素填充到根结点(下标为1)的位置。\n\n![删除堆顶元素2](堆.assets/删除堆顶元素2.png)\n\n\n> 这个时候又空出一个位置了，老规矩，谁有能力谁上\n\n一直循环比较空出位置的左右子节点，并将较大者移至空位，直到堆的最底部\n\n![删除堆顶元素3](堆.assets/删除堆顶元素3.png)\n\n这个时候已经完成了自底向上的堆化，没有元素可以填补空缺了，但是，我们可以看到数组中出现了“气泡”，这会导致存储空间的浪费。接下来我们试试自顶向下堆化。\n\n#### 自顶向下堆化\n自顶向下的堆化用一个词形容就是“石沉大海”，那么第一件事情，就是把石头抬起来，从海面扔下去。这个石头就是堆的最后一个元素，我们将最后一个元素移动到堆顶。\n\n![删除堆顶元素4](堆.assets/删除堆顶元素4.png)\n\n然后开始将这个石头沉入海底，不停与左右子节点的值进行比较，和较大的子节点交换位置，直到无法交换位置。\n\n![删除堆顶元素5](堆.assets/删除堆顶元素5.png)\n\n![删除堆顶元素6](堆.assets/删除堆顶元素6.png)\n\n\n\n### 堆的操作总结\n\n- **插入元素** ：先将元素放至数组末尾，再自底向上堆化，将末尾元素上浮\n- **删除堆顶元素** ：删除堆顶元素，将末尾元素放至堆顶，再自顶向下堆化，将堆顶元素下沉。也可以自底向上堆化，只是会产生“气泡”，浪费存储空间。最好采用自顶向下堆化的方式。\n\n\n## 堆排序\n\n堆排序的过程分为两步：\n\n- 第一步是建堆，将一个无序的数组建立为一个堆\n- 第二步是排序，将堆顶元素取出，然后对剩下的元素进行堆化，反复迭代，直到所有元素被取出为止。\n\n### 建堆\n\n如果你已经足够了解堆化的过程，那么建堆的过程掌握起来就比较容易了。建堆的过程就是一个对所有非叶节点的自顶向下堆化过程。\n\n首先要了解哪些是非叶节点，最后一个节点的父结点及它之前的元素，都是非叶节点。也就是说，如果节点个数为n，那么我们需要对n/2到1的节点进行自顶向下（沉底）堆化。\n\n具体过程如下图：\n\n![建堆1](堆.assets/建堆1.png)\n\n将初始的无序数组抽象为一棵树，图中的节点个数为6，所以4,5,6节点为叶节点，1,2,3节点为非叶节点，所以要对1-3号节点进行自顶向下（沉底）堆化，注意，顺序是从后往前堆化，从3号节点开始，一直到1号节点。\n3号节点堆化结果：\n\n![建堆1](堆.assets/建堆2.png)\n\n2号节点堆化结果：\n\n![建堆1](堆.assets/建堆3.png)\n\n1号节点堆化结果：\n\n![建堆1](堆.assets/建堆4.png)\n\n至此，数组所对应的树已经成为了一个最大堆，建堆完成！\n\n### 排序\n\n由于堆顶元素是所有元素中最大的，所以我们重复取出堆顶元素，将这个最大的堆顶元素放至数组末尾，并对剩下的元素进行堆化即可。\n\n现在思考两个问题：\n\n- 删除堆顶元素后需要执行自顶向下（沉底）堆化还是自底向上（上浮）堆化？\n- 取出的堆顶元素存在哪，新建一个数组存？\n\n先回答第一个问题，我们需要执行自顶向下（沉底）堆化，这个堆化一开始要将末尾元素移动至堆顶，这个时候末尾的位置就空出来了，由于堆中元素已经减小，这个位置不会再被使用，所以我们可以将取出的元素放在末尾。\n\n机智的小伙伴已经发现了，这其实是做了一次交换操作，将堆顶和末尾元素调换位置，从而将取出堆顶元素和堆化的第一步(将末尾元素放至根结点位置)进行合并。\n\n详细过程如下图所示：\n\n取出第一个元素并堆化：\n\n![堆排序1](堆.assets/堆排序1.png)\n\n取出第二个元素并堆化：\n\n![堆排序2](堆.assets/堆排序2.png)\n\n取出第三个元素并堆化：\n\n![堆排序3](堆.assets/堆排序3.png)\n\n取出第四个元素并堆化：\n\n![堆排序4](堆.assets/堆排序4.png)\n\n取出第五个元素并堆化：\n\n![堆排序5](堆.assets/堆排序5.png)\n\n取出第六个元素并堆化：\n\n![堆排序6](堆.assets/堆排序6.png)\n\n堆排序完成！\n'},e694:function(n,t,e){"use strict";e.r(t);var i=function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",[e("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}})],1)},a=[],s=e("3686"),r=e("1b62"),o=Object(s["a"])(e("8ca6"),"md",!0),l=o.all_components,c=o.all_modules,u={mixins:[r["c"],r["b"]],data:function(){return{img_prefix:"./books/algorithms/",tab:c[0].value,tab_level:1,MainComponent:l[c[0].value],tabs:c}},watch:{tab:function(n,t){this.MainComponent=l[this.tab]}}},p=u,d=e("2877"),h=Object(d["a"])(p,i,a,!1,null,"4c9c3938",null);t["default"]=h.exports},f533:function(n,t,e){"use strict";e.r(t),t["default"]='\x3c!-- MarkdownTOC --\x3e\n\n- [说明](#说明)\n- [1. KMP 算法](#1-kmp-算法)\n- [2. 替换空格](#2-替换空格)\n- [3. 最长公共前缀](#3-最长公共前缀)\n- [4. 回文串](#4-回文串)\n  - [4.1. 最长回文串](#41-最长回文串)\n  - [4.2. 验证回文串](#42-验证回文串)\n  - [4.3. 最长回文子串](#43-最长回文子串)\n  - [4.4. 最长回文子序列](#44-最长回文子序列)\n- [5. 括号匹配深度](#5-括号匹配深度)\n- [6. 把字符串转换成整数](#6-把字符串转换成整数)\n\n\x3c!-- /MarkdownTOC --\x3e\n\n\n\n> 授权转载！\n>\n> - 本文作者：wwwxmu\n> - 原文地址:https://www.weiweiblog.cn/13string/\n\n\n\n考虑到篇幅问题，我会分两次更新这个内容。本篇文章只是原文的一部分，我在原文的基础上增加了部分内容以及修改了部分代码和注释。另外，我增加了爱奇艺 2018 秋招 Java：`求给定合法括号序列的深度` 这道题。所有代码均编译成功，并带有注释，欢迎各位享用！\n\n## 1. KMP 算法\n\n谈到字符串问题，不得不提的就是 KMP 算法，它是用来解决字符串查找的问题，可以在一个字符串（S）中查找一个子串（W）出现的位置。KMP 算法把字符匹配的时间复杂度缩小到 O(m+n) ,而空间复杂度也只有O(m)。因为“暴力搜索”的方法会反复回溯主串，导致效率低下，而KMP算法可以利用已经部分匹配这个有效信息，保持主串上的指针不回溯，通过修改子串的指针，让模式串尽量地移动到有效的位置。\n\n具体算法细节请参考：\n\n- **字符串匹配的KMP算法:** http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html\n- **从头到尾彻底理解KMP:** https://blog.csdn.net/v_july_v/article/details/7041827\n- **如何更好的理解和掌握 KMP 算法?:** https://www.zhihu.com/question/21923021\n- **KMP 算法详细解析:**  https://blog.sengxian.com/algorithms/kmp\n- **图解 KMP 算法:** http://blog.jobbole.com/76611/\n- **汪都能听懂的KMP字符串匹配算法【双语字幕】:** https://www.bilibili.com/video/av3246487/?from=search&seid=17173603269940723925\n- **KMP字符串匹配算法1:** https://www.bilibili.com/video/av11866460?from=search&seid=12730654434238709250\n\n**除此之外，再来了解一下BM算法！**\n\n> BM算法也是一种精确字符串匹配算法，它采用从右向左比较的方法，同时应用到了两种启发式规则，即坏字符规则 和好后缀规则 ，来决定向右跳跃的距离。基本思路就是从右往左进行字符匹配，遇到不匹配的字符后从坏字符表和好后缀表找一个最大的右移值，将模式串右移继续匹配。\n《字符串匹配的KMP算法》:http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html\n\n\n## 2. 替换空格\n\n> 剑指offer：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。\n\n这里我提供了两种方法：①常规方法；②利用 API 解决。\n\n```java\n//https://www.weiweiblog.cn/replacespace/\npublic class Solution {\n\n  /**\n   * 第一种方法：常规方法。利用String.charAt(i)以及String.valueOf(char).equals(" "\n   * )遍历字符串并判断元素是否为空格。是则替换为"%20",否则不替换\n   */\n  public static String replaceSpace(StringBuffer str) {\n\n    int length = str.length();\n    // System.out.println("length=" + length);\n    StringBuffer result = new StringBuffer();\n    for (int i = 0; i < length; i++) {\n      char b = str.charAt(i);\n      if (String.valueOf(b).equals(" ")) {\n        result.append("%20");\n      } else {\n        result.append(b);\n      }\n    }\n    return result.toString();\n\n  }\n\n  /**\n   * 第二种方法：利用API替换掉所用空格，一行代码解决问题\n   */\n  public static String replaceSpace2(StringBuffer str) {\n\n    return str.toString().replaceAll("\\\\s", "%20");\n  }\n}\n\n```\n\n## 3. 最长公共前缀\n\n> Leetcode:  编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 ""。\n\n示例 1:\n\n```\n输入: ["flower","flow","flight"]\n输出: "fl"\n```\n\n示例 2:\n\n```\n输入: ["dog","racecar","car"]\n输出: ""\n解释: 输入不存在公共前缀。\n```\n\n\n思路很简单！先利用Arrays.sort(strs)为数组排序，再将数组第一个元素和最后一个元素的字符从前往后对比即可！\n\n```java\npublic class Main {\n\tpublic static String replaceSpace(String[] strs) {\n\n\t\t// 如果检查值不合法及就返回空串\n\t\tif (!checkStrs(strs)) {\n\t\t\treturn "";\n\t\t}\n\t\t// 数组长度\n\t\tint len = strs.length;\n\t\t// 用于保存结果\n\t\tStringBuilder res = new StringBuilder();\n\t\t// 给字符串数组的元素按照升序排序(包含数字的话，数字会排在前面)\n\t\tArrays.sort(strs);\n\t\tint m = strs[0].length();\n\t\tint n = strs[len - 1].length();\n\t\tint num = Math.min(m, n);\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tif (strs[0].charAt(i) == strs[len - 1].charAt(i)) {\n\t\t\t\tres.append(strs[0].charAt(i));\n\t\t\t} else\n\t\t\t\tbreak;\n\n\t\t}\n\t\treturn res.toString();\n\n\t}\n\n\tprivate static boolean chechStrs(String[] strs) {\n\t\tboolean flag = false;\n\t\tif (strs != null) {\n\t\t\t// 遍历strs检查元素值\n\t\t\tfor (int i = 0; i < strs.length; i++) {\n\t\t\t\tif (strs[i] != null && strs[i].length() != 0) {\n\t\t\t\t\tflag = true;\n\t\t\t\t} else {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn flag;\n\t}\n\n\t// 测试\n\tpublic static void main(String[] args) {\n\t\tString[] strs = { "customer", "car", "cat" };\n\t\t// String[] strs = { "customer", "car", null };//空串\n\t\t// String[] strs = {};//空串\n\t\t// String[] strs = null;//空串\n\t\tSystem.out.println(Main.replaceSpace(strs));// c\n\t}\n}\n\n```\n\n## 4. 回文串\n\n### 4.1. 最长回文串\n\n> LeetCode:  给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。在构造过程中，请注意区分大小写。比如`"Aa"`不能当做一个回文字符串。注\n意:假设字符串的长度不会超过 1010。\n\n\n\n> 回文串：“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。——百度百科  地址：https://baike.baidu.com/item/%E5%9B%9E%E6%96%87%E4%B8%B2/1274921?fr=aladdin\n\n示例 1:\n\n```\n输入:\n"abccccdd"\n\n输出:\n7\n\n解释:\n我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。\n```\n\n我们上面已经知道了什么是回文串？现在我们考虑一下可以构成回文串的两种情况：\n\n- 字符出现次数为双数的组合\n- **字符出现次数为偶数的组合+单个字符中出现次数最多且为奇数次的字符** （参见 **[issue665](https://github.com/Snailclimb/JavaGuide/issues/665)** ）\n\n统计字符出现的次数即可，双数才能构成回文。因为允许中间一个数单独出现，比如“abcba”，所以如果最后有字母落单，总长度可以加 1。首先将字符串转变为字符数组。然后遍历该数组，判断对应字符是否在hashset中，如果不在就加进去，如果在就让count++，然后移除该字符！这样就能找到出现次数为双数的字符个数。\n\n```java\n//https://leetcode-cn.com/problems/longest-palindrome/description/\nclass Solution {\n  public  int longestPalindrome(String s) {\n    if (s.length() == 0)\n      return 0;\n    // 用于存放字符\n    HashSet<Character> hashset = new HashSet<Character>();\n    char[] chars = s.toCharArray();\n    int count = 0;\n    for (int i = 0; i < chars.length; i++) {\n      if (!hashset.contains(chars[i])) {// 如果hashset没有该字符就保存进去\n        hashset.add(chars[i]);\n      } else {// 如果有,就让count++（说明找到了一个成对的字符），然后把该字符移除\n        hashset.remove(chars[i]);\n        count++;\n      }\n    }\n    return hashset.isEmpty() ? count * 2 : count * 2 + 1;\n  }\n}\n```\n\n\n### 4.2. 验证回文串\n\n> LeetCode: 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。\n\n示例 1:\n\n```\n输入: "A man, a plan, a canal: Panama"\n输出: true\n```\n\n示例 2:\n\n```\n输入: "race a car"\n输出: false\n```\n\n```java\n//https://leetcode-cn.com/problems/valid-palindrome/description/\nclass Solution {\n  public  boolean isPalindrome(String s) {\n    if (s.length() == 0)\n      return true;\n    int l = 0, r = s.length() - 1;\n    while (l < r) {\n      // 从头和尾开始向中间遍历\n      if (!Character.isLetterOrDigit(s.charAt(l))) {// 字符不是字母和数字的情况\n        l++;\n      } else if (!Character.isLetterOrDigit(s.charAt(r))) {// 字符不是字母和数字的情况\n        r--;\n      } else {\n        // 判断二者是否相等\n        if (Character.toLowerCase(s.charAt(l)) != Character.toLowerCase(s.charAt(r)))\n          return false;\n        l++;\n        r--;\n      }\n    }\n    return true;\n  }\n}\n```\n\n\n### 4.3. 最长回文子串\n\n> Leetcode: LeetCode: 最长回文子串 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。\n\n示例 1：\n\n```\n输入: "babad"\n输出: "bab"\n注意: "aba"也是一个有效答案。\n```\n\n示例 2：\n\n```\n输入: "cbbd"\n输出: "bb"\n```\n\n以某个元素为中心，分别计算偶数长度的回文最大长度和奇数长度的回文最大长度。给大家大致花了个草图，不要嫌弃！\n\n\n\n\n```java\n//https://leetcode-cn.com/problems/longest-palindromic-substring/description/\nclass Solution {\n  private int index, len;\n\n  public String longestPalindrome(String s) {\n    if (s.length() < 2)\n      return s;\n    for (int i = 0; i < s.length() - 1; i++) {\n      PalindromeHelper(s, i, i);\n      PalindromeHelper(s, i, i + 1);\n    }\n    return s.substring(index, index + len);\n  }\n\n  public void PalindromeHelper(String s, int l, int r) {\n    while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {\n      l--;\n      r++;\n    }\n    if (len < r - l - 1) {\n      index = l + 1;\n      len = r - l - 1;\n    }\n  }\n}\n```\n\n### 4.4. 最长回文子序列\n\n> LeetCode: 最长回文子序列\n给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。\n**最长回文子序列和上一题最长回文子串的区别是，子串是字符串中连续的一个序列，而子序列是字符串中保持相对位置的字符序列，例如，"bbbb"可以是字符串"bbbab"的子序列但不是子串。**\n\n给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。\n\n示例 1:\n\n```\n输入:\n"bbbab"\n输出:\n4\n```\n一个可能的最长回文子序列为 "bbbb"。\n\n示例 2:\n\n```\n输入:\n"cbbd"\n输出:\n2\n```\n\n一个可能的最长回文子序列为 "bb"。\n\n**动态规划：**  dp[i][j] = dp[i+1][j-1] + 2 if s.charAt(i) == s.charAt(j) otherwise, dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])\n\n```java\nclass Solution {\n    public int longestPalindromeSubseq(String s) {\n        int len = s.length();\n        int [][] dp = new int[len][len];\n        for(int i = len - 1; i>=0; i--){\n            dp[i][i] = 1;\n            for(int j = i+1; j < len; j++){\n                if(s.charAt(i) == s.charAt(j))\n                    dp[i][j] = dp[i+1][j-1] + 2;\n                else\n                    dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);\n            }\n        }\n        return dp[0][len-1];\n    }\n}\n```\n\n## 5. 括号匹配深度\n\n> 爱奇艺 2018 秋招 Java：\n>一个合法的括号匹配序列有以下定义:\n>1. 空串""是一个合法的括号匹配序列\n>2.  如果"X"和"Y"都是合法的括号匹配序列,"XY"也是一个合法的括号匹配序列\n>3. 如果"X"是一个合法的括号匹配序列,那么"(X)"也是一个合法的括号匹配序列\n>4. 每个合法的括号序列都可以由以上规则生成。\n\n> 例如: "","()","()()","((()))"都是合法的括号序列\n>对于一个合法的括号序列我们又有以下定义它的深度:\n>1. 空串""的深度是0\n>2. 如果字符串"X"的深度是x,字符串"Y"的深度是y,那么字符串"XY"的深度为max(x,y)   \n>3. 如果"X"的深度是x,那么字符串"(X)"的深度是x+1\n\n> 例如: "()()()"的深度是1,"((()))"的深度是3。牛牛现在给你一个合法的括号序列,需要你计算出其深度。 \n\n```\n输入描述:\n输入包括一个合法的括号序列s,s长度length(2 ≤ length ≤ 50),序列中只包含\'(\'和\')\'。\n\n输出描述:\n输出一个正整数,即这个序列的深度。\n```\n\n示例：\n\n```\n输入:\n(())\n输出:\n2\n```\n\n\n\n\n\n\n代码如下：\n\n```java\nimport java.util.Scanner;\n\n/**\n * https://www.nowcoder.com/test/8246651/summary\n * \n * @author Snailclimb\n * @date 2018年9月6日\n * @Description: TODO 求给定合法括号序列的深度\n */\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String s = sc.nextLine();\n    int cnt = 0, max = 0, i;\n    for (i = 0; i < s.length(); ++i) {\n      if (s.charAt(i) == \'(\')\n        cnt++;\n      else\n        cnt--;\n      max = Math.max(max, cnt);\n    }\n    sc.close();\n    System.out.println(max);\n  }\n}\n\n```\n\n## 6. 把字符串转换成整数\n\n> 剑指offer:  将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。\n\n```java\n//https://www.weiweiblog.cn/strtoint/\npublic class Main {\n\n  public static int StrToInt(String str) {\n    if (str.length() == 0)\n      return 0;\n    char[] chars = str.toCharArray();\n    // 判断是否存在符号位\n    int flag = 0;\n    if (chars[0] == \'+\')\n      flag = 1;\n    else if (chars[0] == \'-\')\n      flag = 2;\n    int start = flag > 0 ? 1 : 0;\n    int res = 0;// 保存结果\n    for (int i = start; i < chars.length; i++) {\n      if (Character.isDigit(chars[i])) {// 调用Character.isDigit(char)方法判断是否是数字，是返回True，否则False\n        int temp = chars[i] - \'0\';\n        res = res * 10 + temp;\n      } else {\n        return 0;\n      }\n    }\n   return flag != 2 ? res : -res;\n\n  }\n\n  public static void main(String[] args) {\n    // TODO Auto-generated method stub\n    String s = "-12312312";\n    System.out.println("使用库函数转换：" + Integer.valueOf(s));\n    int res = Main.StrToInt(s);\n    System.out.println("使用自己写的方法转换：" + res);\n\n  }\n\n}\n\n```\n'}}]);