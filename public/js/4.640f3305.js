(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[4],{"008f":function(n,e,t){"use strict";t.r(e),e["default"]='## 1.API\n\n### 1.1 API概述【理解】\n\n- 什么是API\n\n  ​\tAPI (Application Programming Interface) ：应用程序编程接口\n\n- java中的API\n\n  ​\t指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。\n\n### 1.2 如何使用API帮助文档【应用】\n\n- 打开帮助文档\n\n![01](./day14-常用API01.img/01.png)\n\n- 找到索引选项卡中的输入框\n\n![02](./day14-常用API01.img/02.png)\n\n- 在输入框中输入Random\n\n![03](./day14-常用API01.img/03.png)\n\n- 看类在哪个包下\n\n![04](./day14-常用API01.img/04.png)\n\n- 看类的描述\n\n![05](./day14-常用API01.img/05.png)\n\n- 看构造方法\n\n![06](./day14-常用API01.img/06.png)\n\n- 看成员方法\n\n![07](./day14-常用API01.img/07.png)\n\n## 2.常用API \n\n### 2.1 Math（应用）\n\n- 1、Math类概述\n\n  - Math 包含执行基本数字运算的方法\n\n- 2、Math中方法的调用方式\n\n  - Math类中无构造方法，但内部的方法都是静态的，则可以通过   **类名.进行调用**\n\n- 3、Math类的常用方法\n\n  | 方法名    方法名                               | 说明                         |\n  | ---------------------------------------- | -------------------------- |\n  | public static int   abs(int a)           | 返回参数的绝对值                   |\n  | public static double ceil(double a)      | 返回大于或等于参数的最小double值，等于一个整数 |\n  | public static double floor(double a)     | 返回小于或等于参数的最大double值，等于一个整数 |\n  | public   static int round(float a)       | 按照四舍五入返回最接近参数的int          |\n  | public static int   max(int a,int b)     | 返回两个int值中的较大值              |\n  | public   static int min(int a,int b)     | 返回两个int值中的较小值              |\n  | public   static double pow (double a,double b) | 返回a的b次幂的值                  |\n  | public   static double random()          | 返回值为double的正值，[0.0,1.0)    |\n\n### 2.2 System（应用）\n\n- System类的常用方法 \n  | 方法名                                      | 说明                            |\n  | ---------------------------------------- | ----------------------------- |\n  | public   static void exit(int status)    | 终止当前运行的   Java   虚拟机，非零表示异常终止 |\n  | public   static long currentTimeMillis() | 返回当前时间(以毫秒为单位)                |\n\n- 示例代码\n\n  - 需求：在控制台输出1-10000，计算这段代码执行了多少毫秒 \n\n  ```java\n  public class SystemDemo {\n      public static void main(String[] args) {\n          // 获取开始的时间节点\n          long start = System.currentTimeMillis();\n          for (int i = 1; i <= 10000; i++) {\n              System.out.println(i);\n          }\n          // 获取代码运行结束后的时间节点\n          long end = System.currentTimeMillis();\n          System.out.println("共耗时：" + (end - start) + "毫秒");\n      }\n  }\n  ```\n\n### 2.3 Object类的toString方法（应用）\n\n- Object类概述\n\n  - Object 是类层次结构的根，每个类都可以将 Object 作为超类。所有类都直接或者间接的继承自该类，换句话说，该类所具备的方法，所有类都会有一份\n\n- 查看方法源码的方式\n\n  - 选中方法，按下Ctrl + B\n\n- 重写toString方法的方式\n\n  - 1. Alt + Insert 选择toString\n  - 1. 在类的空白区域，右键 -> Generate -> 选择toString\n\n- toString方法的作用：\n\n  - 以良好的格式，更方便的展示对象中的属性值\n\n- 示例代码：\n\n  ```java\n  class Student extends Object {\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public String toString() {\n          return "Student{" +\n                  "name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n  }\n  public class ObjectDemo {\n      public static void main(String[] args) {\n          Student s = new Student();\n          s.setName("林青霞");\n          s.setAge(30);\n          System.out.println(s); \n          System.out.println(s.toString()); \n      }\n  }\n  ```\n\n- 运行结果：\n\n  ```java\n  Student{name=\'林青霞\', age=30}\n  Student{name=\'林青霞\', age=30}\n  ```\n\n### 2.4 Object类的equals方法（应用）\n\n- equals方法的作用\n\n  - 用于对象之间的比较，返回true和false的结果\n  - 举例：s1.equals(s2);    s1和s2是两个对象\n\n- 重写equals方法的场景\n\n  - 不希望比较对象的地址值，想要结合对象属性进行比较的时候。\n\n- 重写equals方法的方式\n\n  - 1. alt + insert  选择equals() and hashCode()，IntelliJ Default，一路next，finish即可\n  - 1. 在类的空白区域，右键 -> Generate -> 选择equals() and hashCode()，后面的同上。\n\n- 示例代码：\n\n  ```java\n  class Student {\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public boolean equals(Object o) {\n          //this -- s1\n          //o -- s2\n          if (this == o) return true;\n          if (o == null || getClass() != o.getClass()) return false;\n\n          Student student = (Student) o; //student -- s2\n\n          if (age != student.age) return false;\n          return name != null ? name.equals(student.name) : student.name == null;\n      }\n  }\n  public class ObjectDemo {\n      public static void main(String[] args) {\n          Student s1 = new Student();\n          s1.setName("林青霞");\n          s1.setAge(30);\n\n          Student s2 = new Student();\n          s2.setName("林青霞");\n          s2.setAge(30);\n\n          //需求：比较两个对象的内容是否相同\n          System.out.println(s1.equals(s2));\n      }\n  }\n\n  ```\n\n- 面试题\n\n  ```java\n  // 看程序,分析结果\n  String s = “abc”;\n  StringBuilder sb = new StringBuilder(“abc”);\n  s.equals(sb); \n  sb.equals(s); \n\n  public class InterviewTest {\n      public static void main(String[] args) {\n          String s1 = "abc";\n          StringBuilder sb = new StringBuilder("abc");\n          //1.此时调用的是String类中的equals方法.\n          //保证参数也是字符串,否则不会比较属性值而直接返回false\n          //System.out.println(s1.equals(sb)); // false\n\n          //StringBuilder类中是没有重写equals方法,用的就是Object类中的.\n          System.out.println(sb.equals(s1)); // false\n      }\n  }\n  ```\n\n### 2.5 Objects (应用)\n\n+ 常用方法\n\n  | 方法名                                      | 说明               |\n  | ---------------------------------------- | ---------------- |\n  | public static String toString(对象)        | 返回参数中对象的字符串表示形式。 |\n  | public static String toString(对象, 默认字符串) | 返回对象的字符串表示形式。    |\n  | public static Boolean isNull(对象)         | 判断对象是否为空         |\n  | public static Boolean nonNull(对象)        | 判断对象是否不为空        |\n\n+ 示例代码\n\n  学生类\n\n  ```java\n  class Student {\n        private String name;\n        private int age;\n\n        public Student() {\n        }\n\n        public Student(String name, int age) {\n            this.name = name;\n            this.age = age;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public int getAge() {\n            return age;\n        }\n\n        public void setAge(int age) {\n            this.age = age;\n        }\n\n        @Override\n        public String toString() {\n            return "Student{" +\n                    "name=\'" + name + \'\\\'\' +\n                    ", age=" + age +\n                    \'}\';\n        }\n    }\n  ```\n\n  测试类\n\n  ```java\n  public class MyObjectsDemo {\n            public static void main(String[] args) {\n        //        public static String toString(对象): 返回参数中对象的字符串表示形式。\n        //        Student s = new Student("小罗同学",50);\n        //        String result = Objects.toString(s);\n        //        System.out.println(result);\n        //        System.out.println(s);\n\n        //        public static String toString(对象, 默认字符串): 返回对象的字符串表示形式。如果对象为空,那么返回第二个参数.\n                //Student s = new Student("小花同学",23);\n        //        Student s = null;\n        //        String result = Objects.toString(s, "随便写一个");\n        //        System.out.println(result);\n        \n        //        public static Boolean isNull(对象): 判断对象是否为空\n                //Student s = null;\n        //        Student s = new Student();\n        //        boolean result = Objects.isNull(s);\n        //        System.out.println(result);\n\n        //        public static Boolean nonNull(对象): 判断对象是否不为空\n                //Student s = new Student();\n                Student s = null;\n                boolean result = Objects.nonNull(s);\n                System.out.println(result);\n            }\n    }\n  ```\n\n\n### 2.6 BigDecimal (应用)\n\n+ 作用\n\n  可以用来进行精确计算\n\n\n+ 构造方法\n\n  | 方法名                    | 说明        |\n  | ---------------------- | --------- |\n  | BigDecimal(double val) | 参数为double |\n  | BigDecimal(String val) | 参数为String |\n\n+ 常用方法\n\n  | 方法名                                      | 说明   |\n  | ---------------------------------------- | ---- |\n  | public BigDecimal add(另一个BigDecimal对象)   | 加法   |\n  | public BigDecimal subtract (另一个BigDecimal对象) | 减法   |\n  | public BigDecimal multiply (另一个BigDecimal对象) | 乘法   |\n  | public BigDecimal divide (另一个BigDecimal对象) | 除法   |\n  | public BigDecimal divide (另一个BigDecimal对象，精确几位，舍入模式) | 除法   |\n\n+ 总结\n\n  1. BigDecimal是用来进行精确计算的\n  2. 创建BigDecimal的对象，构造方法使用参数类型为字符串的。\n  3. 四则运算中的除法，如果除不尽请使用divide的三个参数的方法。\n\n  代码示例：\n\n  ```java\n  BigDecimal divide = bd1.divide(参与运算的对象,小数点后精确到多少位,舍入模式);\n  参数1 ，表示参与运算的BigDecimal 对象。\n  参数2 ，表示小数点后面精确到多少位\n  参数3 ，舍入模式  \n    BigDecimal.ROUND_UP  进一法\n    BigDecimal.ROUND_FLOOR 去尾法\n    BigDecimal.ROUND_HALF_UP 四舍五入\n  ```\n\n## 3.包装类\n\n### 3.1 基本类型包装类（记忆）\n\n- 基本类型包装类的作用\n\n   将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据\n\n   常用的操作之一：用于基本数据类型与字符串之间的转换\n\n- 基本类型对应的包装类\n\n  | 基本数据类型  | 包装类       |\n  | ------- | --------- |\n  | byte    | Byte      |\n  | short   | Short     |\n  | int     | Integer   |\n  | long    | Long      |\n  | float   | Float     |\n  | double  | Double    |\n  | char    | Character |\n  | boolean | Boolean   |\n\n### 3.2 Integer类（应用）\n\n- Integer类概述\n\n   包装一个对象中的原始类型 int 的值\n\n- Integer类构造方法\n\n  | 方法名                                     | 说明                           |\n  | --------------------------------------- | ---------------------------- |\n  | public Integer(int   value)             | 根据 int 值创建 Integer 对象(过时)    |\n  | public Integer(String s)                | 根据 String 值创建 Integer 对象(过时) |\n  | public static Integer valueOf(int i)    | 返回表示指定的 int 值的 Integer   实例  |\n  | public static Integer valueOf(String s) | 返回一个保存指定值的 Integer 对象 String |\n\n- 示例代码\n\n  ```java\n  public class IntegerDemo {\n      public static void main(String[] args) {\n          //public Integer(int value)：根据 int 值创建 Integer 对象(过时)\n          Integer i1 = new Integer(100);\n          System.out.println(i1);\n\n          //public Integer(String s)：根据 String 值创建 Integer 对象(过时)\n          Integer i2 = new Integer("100");\n  //        Integer i2 = new Integer("abc"); //NumberFormatException\n          System.out.println(i2);\n          System.out.println("--------");\n\n          //public static Integer valueOf(int i)：返回表示指定的 int 值的 Integer 实例\n          Integer i3 = Integer.valueOf(100);\n          System.out.println(i3);\n\n          //public static Integer valueOf(String s)：返回一个保存指定值的Integer对象 String\n          Integer i4 = Integer.valueOf("100");\n          System.out.println(i4);\n      }\n  }\n  ```\n\n### 3.3 自动拆箱和自动装箱（理解）\n\n- 自动装箱\n\n  ​\t把基本数据类型转换为对应的包装类类型\n\n- 自动拆箱\n\n  ​\t把包装类类型转换为对应的基本数据类型\n\n- 示例代码\n\n  ```java\n  Integer i = 100;  // 自动装箱\n  i += 200;         // i = i + 200;  i + 200 自动拆箱；i = i + 200; 是自动装箱\n  ```\n\n### 3.4 int和String类型的相互转换（记忆）\n\n- int转换为String\n\n  - 转换方式\n\n    - 方式一：直接在数字后加一个空字符串\n    - 方式二：通过String类静态方法valueOf()\n\n  - 示例代码\n\n    ```java\n    public class IntegerDemo {\n        public static void main(String[] args) {\n            //int --- String\n            int number = 100;\n            //方式1\n            String s1 = number + "";\n            System.out.println(s1);\n            //方式2\n            //public static String valueOf(int i)\n            String s2 = String.valueOf(number);\n            System.out.println(s2);\n            System.out.println("--------");\n        }\n    }\n    ```\n\n- String转换为int\n\n  - 转换方式\n\n    - 方式一：先将字符串数字转成Integer，再调用valueOf()方法\n    - 方式二：通过Integer静态方法parseInt()进行转换\n\n  - 示例代码\n\n    ```java\n    public class IntegerDemo {\n        public static void main(String[] args) {\n            //String --- int\n            String s = "100";\n            //方式1：String --- Integer --- int\n            Integer i = Integer.valueOf(s);\n            //public int intValue()\n            int x = i.intValue();\n            System.out.println(x);\n            //方式2\n            //public static int parseInt(String s)\n            int y = Integer.parseInt(s);\n            System.out.println(y);\n        }\n    }\n    ```\n\n### 3.5 字符串数据排序案例（应用）\n\n- 案例需求\n\n  ​\t有一个字符串：“91 27 46 38 50”，请写程序实现最终输出结果是：27 38 46 50 91\n\n- 代码实现\n\n  ```java\n  public class IntegerTest {\n      public static void main(String[] args) {\n          //定义一个字符串\n          String s = "91 27 46 38 50";\n\n          //把字符串中的数字数据存储到一个int类型的数组中\n          String[] strArray = s.split(" ");\n  //        for(int i=0; i<strArray.length; i++) {\n  //            System.out.println(strArray[i]);\n  //        }\n\n          //定义一个int数组，把 String[] 数组中的每一个元素存储到 int 数组中\n          int[] arr = new int[strArray.length];\n          for(int i=0; i<arr.length; i++) {\n              arr[i] = Integer.parseInt(strArray[i]);\n          }\n\n          //对 int 数组进行排序\n          Arrays.sort(arr);\n\n        \tfor(int i=0; i<arr.length; i++){\n           System.out.print(arr[i] + " ");\n        \t}\n  }\n  ```\n\n## 4.递归\n\n### 4.1 递归【应用】\n\n- 递归的介绍\n\n  - 以编程的角度来看，递归指的是方法定义中调用方法本身的现象\n  - 把一个复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解\n  - 递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算\n\n- 递归的基本使用\n\n  ```java\n  public class MyFactorialDemo2 {\n      public static void main(String[] args) {\n          int sum = getSum(100);\n          System.out.println(sum);\n      }\n\n      private static int getSum(int i) {\n          //1- 100之间的和\n              //100 + (1-99之间的和)\n                      // 99 + (1- 98之间的和)\n                          //....\n                              //1\n          //方法的作用: 求 1- i 之间和\n          if(i == 1){\n              return 1;\n          }else{\n              return i + getSum(i -1);\n          }\n      }\n  }    \n  ```\n\n- 递归的注意事项\n\n  - 递归一定要有出口。否则内存溢出\n  - 递归虽然有出口，但是递归的次数也不宜过多。否则内存溢出\n\n### 4.2 递归求阶乘【应用】\n\n- 案例需求\n\n  ​\t用递归求5的阶乘，并把结果在控制台输出\n\n- 代码实现\n\n  ```java\n  public class DiGuiDemo01 {\n      public static void main(String[] args) {\n          //调用方法\n          int result = jc(5);\n          //输出结果\n          System.out.println("5的阶乘是：" + result);\n      }\n\n      //定义一个方法，用于递归求阶乘，参数为一个int类型的变量\n      public static int jc(int n) {\n          //在方法内部判断该变量的值是否是1\n          if(n == 1) {\n              //是：返回1\n              return 1;\n          } else {\n              //不是：返回n*(n-1)!\n              return n*jc(n-1);\n          }\n      }\n  }\n  ```\n\n- 内存图\n\n  ![08_递归内存图](./day14-常用API01.img/08_递归内存图.png)\n\n## 5.数组的高级操作 \n\n### 5.1 二分查找 (理解)\n\n+ 二分查找概述\n\n  查找指定元素在数组中的位置时,以前的方式是通过遍历,逐个获取每个元素,看是否是要查找的元素,这种方式当数组元素较多时,查找的效率很低\n\n  二分查找也叫折半查找,每次可以去掉一半的查找范围,从而提高查找的效率\n\n\n+ 需求\n\n  在数组{1,2,3,4,5,6,7,8,9,10}中,查找某个元素的位置\n\n+ 实现步骤\n\n  1. 定义两个变量，表示要查找的范围。默认min = 0 ，max = 最大索引\n  2. 循环查找，但是min <= max\n  3. 计算出mid的值\n  4. 判断mid位置的元素是否为要查找的元素，如果是直接返回对应索引\n  5. 如果要查找的值在mid的左半边，那么min值不变，max = mid -1.继续下次循环查找\n  6. 如果要查找的值在mid的右半边，那么max值不变，min = mid + 1.继续下次循环查找\n  7. 当min > max 时，表示要查找的元素在数组中不存在，返回-1.\n\n+ 代码实现\n\n  ```java\n  public class MyBinarySearchDemo {\n      public static void main(String[] args) {\n          int [] arr = {1,2,3,4,5,6,7,8,9,10};\n          int number = 11;\n\n          //1,我现在要干嘛? --- 二分查找\n          //2.我干这件事情需要什么? --- 数组 元素\n          //3,我干完了,要不要把结果返回调用者 --- 把索引返回给调用者\n          int index = binarySearchForIndex(arr,number);\n          System.out.println(index);\n      }\n\n      private static int binarySearchForIndex(int[] arr, int number) {\n          //1,定义查找的范围\n          int min = 0;\n          int max = arr.length - 1;\n          //2.循环查找 min <= max\n          while(min <= max){\n              //3.计算出中间位置 mid\n              int mid = (min + max) >> 1;\n              //mid指向的元素 > number\n              if(arr[mid] > number){\n                  //表示要查找的元素在左边.\n                  max = mid -1;\n              }else if(arr[mid] < number){\n                  //mid指向的元素 < number\n                  //表示要查找的元素在右边.\n                  min = mid + 1;\n              }else{\n                  //mid指向的元素 == number\n                  return mid;\n              }\n          }\n          //如果min大于了max就表示元素不存在,返回-1.\n          return -1;\n      }\n    \n  }\n  ```\n\n+ 注意事项\n\n  有一个前提条件，数组内的元素一定要按照大小顺序排列，如果没有大小顺序，是不能使用二分查找法的\n\n### 5.2 冒泡排序 (理解)\n\n+ 冒泡排序概述\n\n  一种排序的方式，对要进行排序的数据中相邻的数据进行两两比较，将较大的数据放在后面，依次对所有的数据进行操作，直至所有数据按要求完成排序\n\n  如果有n个数据进行排序，总共需要比较n-1次\n\n  每一次比较完毕，下一次的比较就会少一个数据参与\n\n+ 代码实现\n\n  ```java\n  public class MyBubbleSortDemo2 {\n      public static void main(String[] args) {\n          int[] arr = {3, 5, 2, 1, 4};\n          //1 2 3 4 5\n          bubbleSort(arr);\n      }\n\n      private static void bubbleSort(int[] arr) {\n          //外层循环控制的是次数 比数组的长度少一次.\n          for (int i = 0; i < arr.length -1; i++) {\n              //内存循环就是实际循环比较的\n              //-1 是为了让数组不要越界\n              //-i 每一轮结束之后,我们就会少比一个数字.\n              for (int j = 0; j < arr.length - 1 - i; j++) {\n                  if (arr[j] > arr[j + 1]) {\n                      int temp = arr[j];\n                      arr[j] = arr[j + 1];\n                      arr[j + 1] = temp;\n                  }\n              }\n          }\n\n          printArr(arr);\n      }\n\n      private static void printArr(int[] arr) {\n          for (int i = 0; i < arr.length; i++) {\n              System.out.print(arr[i] + " ");\n          }\n          System.out.println();\n      }\n    \n  }\n  ```\n\n### 5.3 快速排序 (理解)\n\n+ 快速排序概述\n\n  冒泡排序算法中,一次循环结束,就相当于确定了当前的最大值,也能确定最大值在数组中应存入的位置\n\n  快速排序算法中,每一次递归时以第一个数为基准数,找到数组中所有比基准数小的.再找到所有比基准数大的.小的全部放左边,大的全部放右边,确定基准数的正确位置\n\n+ 核心步骤\n\n  1. 从右开始找比基准数小的\n  2. 从左开始找比基准数大的\n  3. 交换两个值的位置\n  4. 红色继续往左找，蓝色继续往右找，直到两个箭头指向同一个索引为止\n  5. 基准数归位\n\n+ 代码实现\n\n  ```java\n  public class MyQuiteSortDemo2 {\n      public static void main(String[] args) {\n  //        1，从右开始找比基准数小的\n  //        2，从左开始找比基准数大的\n  //        3，交换两个值的位置\n  //        4，红色继续往左找，蓝色继续往右找，直到两个箭头指向同一个索引为止\n  //        5，基准数归位\n          int[] arr = {6, 1, 2, 7, 9, 3, 4, 5, 10, 8};\n\n          quiteSort(arr,0,arr.length-1);\n\n          for (int i = 0; i < arr.length; i++) {\n              System.out.print(arr[i] + " ");\n          }\n      }\n\n      private static void quiteSort(int[] arr, int left, int right) {\n       \t// 递归结束的条件\n          if(right < left){\n              return;\n          }\n\n          int left0 = left;\n          int right0 = right;\n\n          //计算出基准数\n          int baseNumber = arr[left0];\n\n          while(left != right){\n  //        1，从右开始找比基准数小的\n              while(arr[right] >= baseNumber && right > left){\n                  right--;\n              }\n  //        2，从左开始找比基准数大的\n              while(arr[left] <= baseNumber && right > left){\n                  left++;\n              }\n  //        3，交换两个值的位置\n              int temp = arr[left];\n              arr[left] = arr[right];\n              arr[right] = temp;\n          }\n          //基准数归位\n          int temp = arr[left];\n          arr[left] = arr[left0];\n          arr[left0] = temp;\n        \n  \t\t// 递归调用自己,将左半部分排好序\n          quiteSort(arr,left0,left-1);\n        \t// 递归调用自己,将右半部分排好序\n          quiteSort(arr,left +1,right0);\n\n      }\n  }\n  ```\n\n### 5.4 Arrays (应用)\n\n- Arrays的常用方法\n\n  | 方法名                                      | 说明                |\n  | ---------------------------------------- | ----------------- |\n  | public static String toString(int[] a)   | 返回指定数组的内容的字符串表示形式 |\n  | public static void sort(int[] a)         | 按照数字顺序排列指定的数组     |\n  | public static int binarySearch(int[] a, int key) | 利用二分查找返回指定元素的索引   |\n\n- 示例代码\n\n  ```java\n  public class MyArraysDemo {\n        public static void main(String[] args) {\n    //        public static String toString(int[] a)    返回指定数组的内容的字符串表示形式\n    //        int [] arr = {3,2,4,6,7};\n    //        System.out.println(Arrays.toString(arr));\n\n    //        public static void sort(int[] a)\t  按照数字顺序排列指定的数组\n    //        int [] arr = {3,2,4,6,7};\n    //        Arrays.sort(arr);\n    //        System.out.println(Arrays.toString(arr));\n\n    //        public static int binarySearch(int[] a, int key) 利用二分查找返回指定元素的索引\n            int [] arr = {1,2,3,4,5,6,7,8,9,10};\n            int index = Arrays.binarySearch(arr, 0);\n            System.out.println(index);\n            //1,数组必须有序\n            //2.如果要查找的元素存在,那么返回的是这个元素实际的索引\n            //3.如果要查找的元素不存在,那么返回的是 (-插入点-1)\n                //插入点:如果这个元素在数组中,他应该在哪个索引上.\n        }\n    }\n  ```\n\n- 工具类设计思想\n\n  1. 构造方法用 private 修饰\n  2. 成员用 public static 修饰\n\n\n\n'},"0186":function(n,e,t){"use strict";t.r(e),e["default"]='熟练掌握 BIO,NIO,AIO 的基本概念以及一些常见问题是你准备面试的过程中不可或缺的一部分，另外这些知识点也是你学习 Netty 的基础。\n\n\x3c!-- MarkdownTOC --\x3e\n\n- [BIO,NIO,AIO 总结](#bionioaio-总结)\n  - [1. BIO \\(Blocking I/O\\)](#1-bio-blocking-io)\n    - [1.1 传统 BIO](#11-传统-bio)\n    - [1.2 伪异步 IO](#12-伪异步-io)\n    - [1.3 代码示例](#13-代码示例)\n    - [1.4 总结](#14-总结)\n  - [2. NIO \\(New I/O\\)](#2-nio-new-io)\n    - [2.1 NIO 简介](#21-nio-简介)\n    - [2.2 NIO的特性/NIO与IO区别](#22-nio的特性nio与io区别)\n      - [1)Non-blocking IO（非阻塞IO）](#1non-blocking-io非阻塞io)\n      - [2)Buffer\\(缓冲区\\)](#2buffer缓冲区)\n      - [3)Channel \\(通道\\)](#3channel-通道)\n      - [4)Selectors\\(选择器\\)](#4selector-选择器)\n    - [2.3  NIO 读数据和写数据方式](#23-nio-读数据和写数据方式)\n    - [2.4 NIO核心组件简单介绍](#24-nio核心组件简单介绍)\n    - [2.5 代码示例](#25-代码示例)\n  - [3. AIO  \\(Asynchronous I/O\\)](#3-aio-asynchronous-io)\n  - [参考](#参考)\n\n\x3c!-- /MarkdownTOC --\x3e\n\n\n# BIO,NIO,AIO 总结\n\n Java 中的 BIO、NIO和 AIO 理解为是 Java 语言对操作系统的各种 IO 模型的封装。程序员在使用这些 API 的时候，不需要关心操作系统层面的知识，也不需要根据不同操作系统编写不同的代码。只需要使用Java的API就可以了。\n\n在讲 BIO,NIO,AIO 之前先来回顾一下这样几个概念：同步与异步，阻塞与非阻塞。\n\n关于同步和异步的概念解读困扰着很多程序员，大部分的解读都会带有自己的一点偏见。参考了 [Stackoverflow](https://stackoverflow.com/questions/748175/asynchronous-vs-synchronous-execution-what-does-it-really-mean)相关问题后对原有答案进行了进一步完善：\n\n> When you execute something synchronously, you wait for it to finish before moving on to another task. When you execute something asynchronously, you can move on to another task before it finishes.\n>\n> 当你同步执行某项任务时，你需要等待其完成才能继续执行其他任务。当您异步执行某项任务时，你可以在它完成之前继续执行其他任务。\n\n- **同步** ：两个同步任务相互依赖，并且一个任务必须以依赖于另一任务的某种方式执行。 比如在`A->B`事件模型中，你需要先完成 A 才能执行B。 再换句话说，同步调用中被调用者未处理完请求之前，调用不返回，调用者会一直等待结果的返回。\n- **异步**： 两个异步的任务是完全独立的，一方的执行不需要等待另外一方的执行。再换句话说，异步调用中一调用就返回结果不需要等待结果返回，当结果返回的时候通过回调函数或者其他方式拿着结果再做相关事情。\n\n**阻塞和非阻塞**\n\n- **阻塞：** 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。\n- **非阻塞：** 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。\n\n**如何区分 “同步/异步 ”和 “阻塞/非阻塞” 呢？**\n\n同步/异步是从行为角度描述事物的，而阻塞和非阻塞描述的当前事物的状态（等待调用结果时的状态）。\n\n## 1. BIO (Blocking I/O)\n\n同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。\n\n### 1.1 传统 BIO\n\nBIO通信（一请求一应答）模型图如下(图源网络，原出处不明)：\n\n![传统BIO通信模型图](BIO,NIO,AIO总结.assets/2.png)\n\n采用 **BIO 通信模型** 的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接。我们一般通过在`while(true)` 循环中服务端会调用 `accept()` 方法等待接收客户端的连接的方式监听请求，一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成， 不过可以通过多线程来支持多个客户端的连接，如上图所示。\n\n如果要让 **BIO 通信模型** 能够同时处理多个客户端请求，就必须使用多线程（主要原因是`socket.accept()`、`socket.read()`、`socket.write()` 涉及的三个主要函数都是同步阻塞的），也就是说它在接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成之后，通过输出流返回应答给客户端，线程销毁。这就是典型的 **一请求一应答通信模型** 。我们可以设想一下如果这个连接不做任何事情的话就会造成不必要的线程开销，不过可以通过 **线程池机制** 改善，线程池还可以让线程的创建和回收成本相对较低。使用`FixedThreadPool` 可以有效的控制了线程的最大数量，保证了系统有限的资源的控制，实现了N(客户端请求数量):M(处理客户端请求的线程数量)的伪异步I/O模型（N 可以远远大于 M），下面一节"伪异步 BIO"中会详细介绍到。\n\n**我们再设想一下当客户端并发访问量增加后这种模型会出现什么问题？**\n\n在 Java 虚拟机中，线程是宝贵的资源，线程的创建和销毁成本很高，除此之外，线程的切换成本也是很高的。尤其在 Linux 这样的操作系统中，线程本质上就是一个进程，创建和销毁线程都是重量级的系统函数。如果并发访问量增加会导致线程数急剧膨胀可能会导致线程堆栈溢出、创建新线程失败等问题，最终导致进程宕机或者僵死，不能对外提供服务。\n\n### 1.2 伪异步 IO\n\n为了解决同步阻塞I/O面临的一个链路需要一个线程处理的问题，后来有人对它的线程模型进行了优化一一一后端通过一个线程池来处理多个客户端的请求接入，形成客户端个数M：线程池最大线程数N的比例关系，其中M可以远远大于N.通过线程池可以灵活地调配线程资源，设置线程的最大值，防止由于海量并发接入导致线程耗尽。\n\n伪异步IO模型图(图源网络，原出处不明)：\n\n![伪异步IO模型图](BIO,NIO,AIO总结.assets/3.png)\n\n采用线程池和任务队列可以实现一种叫做伪异步的 I/O 通信框架，它的模型图如上图所示。当有新的客户端接入时，将客户端的 Socket 封装成一个Task（该任务实现java.lang.Runnable接口）投递到后端的线程池中进行处理，JDK 的线程池维护一个消息队列和 N 个活跃线程，对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。\n\n伪异步I/O通信框架采用了线程池实现，因此避免了为每个请求都创建一个独立线程造成的线程资源耗尽问题。不过因为它的底层仍然是同步阻塞的BIO模型，因此无法从根本上解决问题。\n\n### 1.3 代码示例\n\n下面代码中演示了BIO通信（一请求一应答）模型。我们会在客户端创建多个线程依次连接服务端并向其发送"当前时间+:hello world"，服务端会为每个客户端线程创建一个线程来处理。代码示例出自闪电侠的博客，原地址如下：        \n\n[https://www.jianshu.com/p/a4e03835921a](https://www.jianshu.com/p/a4e03835921a)\n\n**客户端**\n\n```java\n/**\n * \n * @author 闪电侠\n * @date 2018年10月14日\n * @Description:客户端\n */\npublic class IOClient {\n\n  public static void main(String[] args) {\n    // TODO 创建多个线程，模拟多个客户端连接服务端\n    new Thread(() -> {\n      try {\n        Socket socket = new Socket("127.0.0.1", 3333);\n        while (true) {\n          try {\n            socket.getOutputStream().write((new Date() + ": hello world").getBytes());\n            Thread.sleep(2000);\n          } catch (Exception e) {\n          }\n        }\n      } catch (IOException e) {\n      }\n    }).start();\n\n  }\n\n}\n\n```\n\n**服务端**\n\n```java\n/**\n * @author 闪电侠\n * @date 2018年10月14日\n * @Description: 服务端\n */\npublic class IOServer {\n\n  public static void main(String[] args) throws IOException {\n    // TODO 服务端处理客户端连接请求\n    ServerSocket serverSocket = new ServerSocket(3333);\n\n    // 接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理\n    new Thread(() -> {\n      while (true) {\n        try {\n          // 阻塞方法获取新的连接\n          Socket socket = serverSocket.accept();\n\n          // 每一个新的连接都创建一个线程，负责读取数据\n          new Thread(() -> {\n            try {\n              int len;\n              byte[] data = new byte[1024];\n              InputStream inputStream = socket.getInputStream();\n              // 按字节流方式读取数据\n              while ((len = inputStream.read(data)) != -1) {\n                System.out.println(new String(data, 0, len));\n              }\n            } catch (IOException e) {\n            }\n          }).start();\n\n        } catch (IOException e) {\n        }\n\n      }\n    }).start();\n\n  }\n\n}\n```\n\n### 1.4 总结\n\n在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。\n\n## 2. NIO (New I/O)\n\n### 2.1 NIO 简介\n\n NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。\n\nNIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 `Socket` 和 `ServerSocket` 相对应的 `SocketChannel` 和 `ServerSocketChannel` 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。\n\n### 2.2 NIO的特性/NIO与IO区别\n\n如果是在面试中回答这个问题，我觉得首先肯定要从 NIO 流是非阻塞 IO 而 IO 流是阻塞 IO 说起。然后，可以从 NIO 的3个核心组件/特性为 NIO 带来的一些改进来分析。如果，你把这些都回答上了我觉得你对于 NIO 就有了更为深入一点的认识，面试官问到你这个问题，你也能很轻松的回答上来了。\n\n#### 1)Non-blocking IO（非阻塞IO）\n\n**IO流是阻塞的，NIO流是不阻塞的。**\n\nJava NIO使我们可以进行非阻塞IO操作。比如说，单线程中从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后，线程再继续处理数据。写数据也是一样的。另外，非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。\n\nJava IO的各种流是阻塞的。这意味着，当一个线程调用 `read()` 或  `write()` 时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了\n\n#### 2)Buffer(缓冲区)\n\n**IO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)。**\n\nBuffer是一个对象，它包含一些要写入或者要读出的数据。在NIO类库中加入Buffer对象，体现了新库与原I/O的一个重要区别。在面向流的I/O中·可以将数据直接写入或者将数据直接读到 Stream 对象中。虽然 Stream 中也有 Buffer 开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而 NIO 却是直接读到 Buffer 中进行操作。\n\n在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的; 在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。\n\n最常用的缓冲区是 ByteBuffer,一个 ByteBuffer 提供了一组功能用于操作 byte 数组。除了ByteBuffer,还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean类型）都对应有一种缓冲区。\n\n#### 3)Channel (通道)\n\nNIO 通过Channel（通道） 进行读写。\n\n通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因为 Buffer，通道可以异步地读写。\n\n#### 4)Selector (选择器)\n\nNIO有选择器，而IO没有。\n\n选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。 因此，为了提高系统效率选择器是有用的。\n\n![一个单线程中Selector维护3个Channel的示意图](BIO,NIO,AIO总结.assets/Slector.png)\n\n### 2.3  NIO 读数据和写数据方式\n通常来说NIO中的所有IO都是从 Channel（通道） 开始的。\n\n- 从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。\n- 从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。\n\n数据读取和写入操作图示：\n\n![NIO读写数据的方式](BIO,NIO,AIO总结.assets/NIO读写数据的方式.png)\n\n\n### 2.4 NIO核心组件简单介绍\n\nNIO 包含下面几个核心的组件：\n\n- Channel(通道)\n- Buffer(缓冲区)\n- Selector(选择器)\n\n整个NIO体系包含的类远远不止这三个，只能说这三个是NIO体系的“核心API”。我们上面已经对这三个概念进行了基本的阐述，这里就不多做解释了。\n\n### 2.5 代码示例\n\n代码示例出自闪电侠的博客，原地址如下：        \n\n[https://www.jianshu.com/p/a4e03835921a](https://www.jianshu.com/p/a4e03835921a)\n\n客户端 IOClient.java 的代码不变，我们对服务端使用 NIO 进行改造。以下代码较多而且逻辑比较复杂，大家看看就好。\n\n```java\n/**\n * \n * @author 闪电侠\n * @date 2019年2月21日\n * @Description: NIO 改造后的服务端\n */\npublic class NIOServer {\n  public static void main(String[] args) throws IOException {\n    // 1. serverSelector负责轮询是否有新的连接，服务端监测到新的连接之后，不再创建一个新的线程，\n    // 而是直接将新连接绑定到clientSelector上，这样就不用 IO 模型中 1w 个 while 循环在死等\n    Selector serverSelector = Selector.open();\n    // 2. clientSelector负责轮询连接是否有数据可读\n    Selector clientSelector = Selector.open();\n\n    new Thread(() -> {\n      try {\n        // 对应IO编程中服务端启动\n        ServerSocketChannel listenerChannel = ServerSocketChannel.open();\n        listenerChannel.socket().bind(new InetSocketAddress(3333));\n        listenerChannel.configureBlocking(false);\n        listenerChannel.register(serverSelector, SelectionKey.OP_ACCEPT);\n\n        while (true) {\n          // 监测是否有新的连接，这里的1指的是阻塞的时间为 1ms\n          if (serverSelector.select(1) > 0) {\n            Set<SelectionKey> set = serverSelector.selectedKeys();\n            Iterator<SelectionKey> keyIterator = set.iterator();\n\n            while (keyIterator.hasNext()) {\n              SelectionKey key = keyIterator.next();\n\n              if (key.isAcceptable()) {\n                try {\n                  // (1) 每来一个新连接，不需要创建一个线程，而是直接注册到clientSelector\n                  SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept();\n                  clientChannel.configureBlocking(false);\n                  clientChannel.register(clientSelector, SelectionKey.OP_READ);\n                } finally {\n                  keyIterator.remove();\n                }\n              }\n\n            }\n          }\n        }\n      } catch (IOException ignored) {\n      }\n    }).start();\n    new Thread(() -> {\n      try {\n        while (true) {\n          // (2) 批量轮询是否有哪些连接有数据可读，这里的1指的是阻塞的时间为 1ms\n          if (clientSelector.select(1) > 0) {\n            Set<SelectionKey> set = clientSelector.selectedKeys();\n            Iterator<SelectionKey> keyIterator = set.iterator();\n\n            while (keyIterator.hasNext()) {\n              SelectionKey key = keyIterator.next();\n\n              if (key.isReadable()) {\n                try {\n                  SocketChannel clientChannel = (SocketChannel) key.channel();\n                  ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n                  // (3) 面向 Buffer\n                  clientChannel.read(byteBuffer);\n                  byteBuffer.flip();\n                  System.out.println(\n                      Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());\n                } finally {\n                  keyIterator.remove();\n                  key.interestOps(SelectionKey.OP_READ);\n                }\n              }\n\n            }\n          }\n        }\n      } catch (IOException ignored) {\n      }\n    }).start();\n\n  }\n}\n```\n\n为什么大家都不愿意用 JDK 原生 NIO 进行开发呢？从上面的代码中大家都可以看出来，是真的难用！除了编程复杂、编程模型难之外，它还有以下让人诟病的问题：\n\n- JDK 的 NIO 底层由 epoll 实现，该实现饱受诟病的空轮询 bug 会导致 cpu 飙升 100%\n- 项目庞大之后，自行实现的 NIO 很容易出现各类 bug，维护成本较高，上面这一坨代码我都不能保证没有 bug\n\nNetty 的出现很大程度上改善了 JDK 原生 NIO 所存在的一些让人难以忍受的问题。\n\n### 3. AIO (Asynchronous I/O)\n\nAIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。\n\nAIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。（除了 AIO 其他的 IO 类型都是同步的，这一点可以从底层IO线程模型解释，推荐一篇文章：[《漫话：如何给女朋友解释什么是Linux的五种IO模型？》](https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&mid=2247484746&amp;idx=1&amp;sn=c0a7f9129d780786cabfcac0a8aa6bb7&source=41#wechat_redirect) ）\n\n查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。\n\n## 参考\n\n- 《Netty 权威指南》第二版\n- https://zhuanlan.zhihu.com/p/23488863 (美团技术团队)\n'},"0245":function(n,e,t){"use strict";t.r(e),e["default"]='\x3c!--\n * @Date           : 2021-04-27 00:39:22\n * @FilePath       : /jinnian-space/src/pages/java/module/basics/md/day27-基础加强03.md\n * @Description    : \n--\x3e\n## 1.管理系统与服务器集成\n\n### 1.1准备工作【应用】\n\n+ 需求\n\n  对之前写过的黑马信息管理系统进行改进,实现可以通过浏览器进行访问的功能\n\n+ 准备工作\n\n  + 将资料中的黑马管理系统代码拷贝到当前模块下\n\n  + 导包的代码可能报错,因为之前的包路径可能和当前代码不一致,将导包的代码修改下\n\n    ![02_要拷贝的包](./day27-基础加强03.img/02_要拷贝的包.png)\n\n+ 业务分析\n\n  ![03_业务分析02](./day27-基础加强03.img/03_业务分析02.png)\n\n  ![01_业务分析](./day27-基础加强03.img/01_业务分析.png)\n\n  1. 解析URL封装到HttpReques对象\n  2. DynamicResourceProcess类（执行指定动态资源的service方法）\n  3. 定义servlet类完成查询学生、添加学生、删除学生、修改学生的逻辑\n\n+ 项目结构\n\n  ![04_包结构](./day27-基础加强03.img/04_包结构.png)\n\n  ![05_三层结构](./day27-基础加强03.img/05_三层结构.png)\n\n### 1.2HttpRequest类代码实现【应用】\n\n+ 实现步骤\n\n  1. 提供一个存储url中用户信息的map集合\n  2. 提供一个getParamter方法,用于根据请求参数的名称获取请求参数的值\n  3. 提供一个parseParamter方法,用于解析请求参数把请求参数存储到map集合中\n\n+ 代码实现\n\n  ```java\n  // 此处只给出了新增的代码,其他代码同之前没有变化\n  public class HttpRequest {\n     \n      //用来存储请求URL中问号后面的那些数据\n      //id=1  name=itheima\n      private Map<String,String> paramterHashMap = new HashMap<>();\n\n      //parse --- 获取请求数据 并解析\n      public void parse(){\n          try {\n              SocketChannel socketChannel = (SocketChannel) selectionKey.channel();\n              StringBuilder sb = new StringBuilder();\n              //创建一个缓冲区\n              ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n              int len;\n              //循环读取\n              while((len = socketChannel.read(byteBuffer)) > 0){\n                  byteBuffer.flip();\n                  sb.append(new String(byteBuffer.array(),0,len));\n                  //System.out.println(new String(byteBuffer.array(),0,len));\n                  byteBuffer.clear();\n              }\n              //System.out.println(sb);\n              parseHttpRequest(sb);\n\n              //解析请求参数，把请求参数存储到paramterHashMap集合\n              parseParamter();\n\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n      }\n\n      //解析请求参数，把请求参数存储到paramterHashMap集合\n      private void parseParamter(){\n          //获取请求的uri\n          String requestURI = this.requestURI;\n          //按照问号进行切割，然后再获取到第二部分\n          String[] uriInfoArr = requestURI.split("\\\\?");\n          //判断数组的长度，如果长度为2，说明是存在请求参数。\n          if(uriInfoArr.length == 2){\n              //获取请求参数内容（问号后面的那些参数）\n              String paramterInfo = uriInfoArr[1];\n\n              //使用&进行切割\n              String[] paramterInfoArr = paramterInfo.split("&");\n\n              //遍历数组\n              //id=1 name=itheima age =23\n              for (String paramter : paramterInfoArr) {\n                  String[] paramterArr = paramter.split("=");\n                  //获取请求参数名称\n                  String paramterName = paramterArr[0];\n                  //获取请求参数的值\n                  String paramterValue = paramterArr[1];\n                  //添加到集合中\n                  paramterHashMap.put(paramterName,paramterValue);\n              }\n          }\n      }\n    \n      //id=1 name=itheima\n      //可以根据请求参数的名称来获取请求参数的值\n      public String getParamter(String name){\n          return paramterHashMap.get(name);\n      }\n\n  }\n  ```\n\n### 1.3DynamicResourceProcess类代码实现【应用】\n\n+ 实现步骤\n\n  获取的uri是包含?后边的数据的,要进行切割,只要?号前边的内容\n\n\n+ 代码实现\n\n  ```java\n  // 此处只给出了新增的代码,其他代码同之前没有变化\n  public class DynamicResourceProcess {\n\n      public void process(HttpRequest httpRequest,HttpResponse httpResponse){\n          //获取请求的uri\n          String requestURI = httpRequest.getRequestURI();\n          //对requestURI进行切割操作\n          String[] split = requestURI.split("\\\\?");\n          //根据请求的uri到map集合中直接找到对应的servlet的对象\n          HttpServlet httpServlet = ServletConcurrentHashMap.map.get(split[0]);\n          System.out.println(httpServlet);\n        \t// ...\n      }\n  }  \n  ```\n\n### 1.4StudentServlet类代码实现【应用】\n\n+ 实现步骤\n\n  1. 在service方法中获取请求参数中的数据\n  2. 判断是要添加学生还是修改学生等\n  3. 调用对应的方法,执行对应的操作\n\n+ 代码实现\n\n  ```java\n  @WebServlet(urlPatterns = "/servlet/studentservlet")\n  public class StudentServlet implements HttpServlet {\n\n      @Override\n      public void service(HttpRequest httpRequest, HttpResponse httpResponse) {\n          //获取method请求参数\n          String method = httpRequest.getParamter("method");\n          System.out.println(method);\n          //判断\n          if ("addStudent".equals(method)) {\n              //添加学生\n              addStudent(httpRequest, httpResponse);\n          } else if ("delStudent".equals(method)) {\n              //删除学生\n              delStudent(httpRequest, httpResponse);\n          } else if ("updateStudent".equals(method)) {\n              //修改学生\n              updateStudent(httpRequest, httpResponse);\n          } else if ("findStudent".equals(method)) {\n              //查询学生\n              findStudent(httpRequest, httpResponse);\n          }\n      }\n\n      //查询学生\n      private void findStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n      }\n\n      //修改学生\n      private void updateStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n      }\n\n      //删除学生\n      private void delStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n      }\n\n      //添加学生\n      private void addStudent(HttpRequest httpRequest, HttpResponse httpResponse) {   \n      }\n  }\n  ```\n\n### 1.5查询学生【应用】\n\n+ 实现步骤\n\n  1. 创建StudentService对象\n  2. 调用StudentService中的findAllStudent方法，完成学生数据的查询操作\n  3. 遍历数组，拼接成一个字符串\n  4. 将拼接的结果响应给浏览器\n\n+ 代码实现\n\n  ```java\n  @WebServlet(urlPatterns = "/servlet/studentservlet")\n  public class StudentServlet implements HttpServlet {\n      //1.创建StudentService对象\n      private StudentService studentService = new StudentService();\n\n      @Override\n      public void service(HttpRequest httpRequest, HttpResponse httpResponse) {\n          //获取method请求参数\n\n          String method = httpRequest.getParamter("method");\n          System.out.println(method);\n          //判断\n          if ("addStudent".equals(method)) {\n              //添加学生\n              addStudent(httpRequest, httpResponse);\n          } else if ("delStudent".equals(method)) {\n              //删除学生\n              delStudent(httpRequest, httpResponse);\n          } else if ("updateStudent".equals(method)) {\n              //修改学生\n              updateStudent(httpRequest, httpResponse);\n          } else if ("findStudent".equals(method)) {\n              //查询学生\n              findStudent(httpRequest, httpResponse);\n          }\n      }\n\n      //查询学生\n      private void findStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n          //2.调用StudentService中的findAllStudent方法，完成学生数据的查询操作\n          Student[] allStudent = studentService.findAllStudent();\n          //3.遍历数组，拼接成一个字符串\n          StringBuilder sb = new StringBuilder();\n          for (Student student : allStudent) {\n              sb.append(student.getId()).append(", ").append(student.getName()).\n                      append(", ").append(student.getAge()).append(", ").\n                      append(student.getBirthday()).append("<br>");\n          }\n          String result = sb.toString();\n          //4.将拼接的结果响应给浏览器\n          //告诉浏览器响应的类型\n          httpResponse.setContentTpye("text/html;charset=UTF-8");\n          if (result == null || "".equals(result)) {\n              httpResponse.write("暂无学生数据。。。。");\n          } else {\n              httpResponse.write(result);\n          }\n      }\n      //修改学生\n      private void updateStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n      }\n\n      //删除学生\n      private void delStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n      }\n\n      //添加学生\n      private void addStudent(HttpRequest httpRequest, HttpResponse httpResponse) {   \n      }\n  }  \n  ```\n\n### 1.6添加学生【应用】\n\n+ 实现步骤\n\n  1. 获取id的请求参数\n  2. 判断id是否重复\n  3. 如果重复。给浏览器响应，id已经重复\n  4. 如果id不重复。添加学生。并给浏览器响应添加学生成功\n\n+ 代码实现\n\n  ```java\n  @WebServlet(urlPatterns = "/servlet/studentservlet")\n  public class StudentServlet implements HttpServlet {\n      //1.创建StudentService对象\n      private StudentService studentService = new StudentService();\n\n      @Override\n      public void service(HttpRequest httpRequest, HttpResponse httpResponse) {\n          //获取method请求参数\n\n          String method = httpRequest.getParamter("method");\n          System.out.println(method);\n          //判断\n          if ("addStudent".equals(method)) {\n              //添加学生\n              addStudent(httpRequest, httpResponse);\n          } else if ("delStudent".equals(method)) {\n              //删除学生\n              delStudent(httpRequest, httpResponse);\n          } else if ("updateStudent".equals(method)) {\n              //修改学生\n              updateStudent(httpRequest, httpResponse);\n          } else if ("findStudent".equals(method)) {\n              //查询学生\n              findStudent(httpRequest, httpResponse);\n          }\n      }\n\n      //查询学生\n      private void findStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n         //...\n      }\n      //修改学生\n      private void updateStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n      }\n      //删除学生\n      private void delStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n      }\n      //添加学生\n      private void addStudent(HttpRequest httpRequest, HttpResponse httpResponse) {\n          //1.获取id的请求参数\n          String id = httpRequest.getParamter("id");\n          //2.判断id是否重复\n          boolean exists = studentService.isExists(id);\n          httpResponse.setContentTpye("text/html;charset=UTF-8");\n          if (exists) {\n              //3.如果重复。给浏览器响应，id已经重复\n              httpResponse.write("id已经存在，请重新输入。。。");\n          } else {\n              //4.如果id不重复。添加学生。并给浏览器响应添加学生成功\n              String name = httpRequest.getParamter("name");\n              String age = httpRequest.getParamter("age");\n              String birthday = httpRequest.getParamter("birthday");\n              //对数据进行处理\n              try {\n                  int ageInt = Integer.parseInt(age);\n                  SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");\n                  Date date = sdf.parse(birthday);\n                  //创建一个学生对象\n                  Student s = new Student();\n                  s.setId(id);\n                  s.setName(name);\n                  s.setAge(age);\n                  s.setBirthday(birthday);\n                  //调用studentservice里面的方法\n                  studentService.addStudent(s);\n                  //给浏览器响应\n                  httpResponse.write("学生数据添加成功....");\n              } catch (ParseException e) {\n                  httpResponse.write("日期格式不正确，正确的格式为:yyyy-MM-dd");\n                  e.printStackTrace();\n              } catch (NumberFormatException e) {\n                  httpResponse.write("年龄只能为整数");\n                  e.printStackTrace();\n              }\n              //birthday  yyyy-MM-dd\n          }\n      }\n  }\n  ```\n\n## 2.单元测试\n\n### 2.1概述【理解】\n\nJUnit是一个 Java 编程语言的单元测试工具。JUnit 是一个非常重要的测试工具\n\n### 2.2特点【理解】\n\n+ JUnit是一个开放源代码的测试工具。\n+ 提供注解来识别测试方法。\n+ JUnit测试可以让你编写代码更快，并能提高质量。\n+ JUnit优雅简洁。没那么复杂，花费时间较少。\n+ JUnit在一个条中显示进度。如果运行良好则是绿色；如果运行失败，则变成红色。\n\n### 2.3使用步骤【应用】\n\n+ 使用步骤\n  1. 将junit的jar包导入到工程中 junit-4.9.jar\n  2. 编写测试方法该测试方法必须是公共的无参数无返回值的非静态方法\n  3. 在测试方法上使用@Test注解标注该方法是一个测试方法\n  4. 选中测试方法右键通过junit运行该方法\n\n+ 代码示例\n\n  ```java\n  public class JunitDemo1 {\n      @Test\n      public void add() {\n          System.out.println(2 / 0);\n          int a = 10;\n          int b = 20;\n          int sum = a + b;\n          System.out.println(sum);\n      }\n  }\n  ```\n\n### 2.4相关注解【应用】\n\n+ 注解说明\n\n  | 注解      | 含义        |\n  | ------- | --------- |\n  | @Test   | 表示测试该方法   |\n  | @Before | 在测试的方法前运行 |\n  | @After  | 在测试的方法后运行 |\n\n+ 代码示例\n\n  ```java\n  public class JunitDemo2 {\n      @Before\n      public void before() {\n        \t// 在执行测试代码之前执行，一般用于初始化操作\n          System.out.println("before");\n      }\n      @Test\n      public void test() {\n        \t// 要执行的测试代码\n          System.out.println("test");\n      }\n      @After\n      public void after() {\n        \t// 在执行测试代码之后执行，一般用于释放资源\n          System.out.println("after");\n      }\n  }\n  ```\n\n## 3.日志\n\n### 3.1概述【理解】\n\n+ 概述\n\n  程序中的日志可以用来记录程序在运行的时候点点滴滴。并可以进行永久存储。\n\n+ 日志与输出语句的区别\n\n  |      | 输出语句          | 日志技术                 |\n  | ---- | ------------- | -------------------- |\n  | 取消日志 | 需要修改代码，灵活性比较差 | 不需要修改代码，灵活性比较好       |\n  | 输出位置 | 只能是控制台        | 可以将日志信息写入到文件或者数据库中   |\n  | 多线程  | 和业务代码处于一个线程中  | 多线程方式记录日志，不影响业务代码的性能 |\n\n### 3.2日志体系结构和Log4J【理解】\n\n+ 体系结构\n\n  ![06_日志体系结构](./day27-基础加强03.img/06_日志体系结构.png)\n\n+ Log4J\n\n  Log4j是Apache的一个开源项目。\n\n  通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件等位置。\n\n  我们也可以控制每一条日志的输出格式。\n\n  通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。\n\n  最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。\n\n+ Apache基金会\n\n  Apache软件基金会（也就是Apache Software Foundation，简称为ASF），为支持开源软件项目而办的一个非盈利性组织。\n\n### 3.3入门案例【应用】\n\n+ 使用步骤\n\n  1. 导入log4j的相关jar包\n  2. 编写log4j配置文件\n  3. 在代码中获取日志的对象\n  4. 按照级别设置记录日志信息\n\n+ 代码示例\n\n  ```java\n  // log4j的配置文件,名字为log4j.properties, 放在src根目录下\n  log4j.rootLogger=debug,my,fileAppender\n\n  ### direct log messages to my ###\n  log4j.appender.my=org.apache.log4j.ConsoleAppender\n  log4j.appender.my.ImmediateFlush = true\n  log4j.appender.my.Target=System.out\n  log4j.appender.my.layout=org.apache.log4j.PatternLayout\n  log4j.appender.my.layout.ConversionPattern=%d %t %5p %c{1}:%L - %m%n\n\n  # fileAppender��ʾ\n  log4j.appender.fileAppender=org.apache.log4j.FileAppender\n  log4j.appender.fileAppender.ImmediateFlush = true\n  log4j.appender.fileAppender.Append=true\n  log4j.appender.fileAppender.File=D:/log4j-log.log\n  log4j.appender.fileAppender.layout=org.apache.log4j.PatternLayout\n  log4j.appender.fileAppender.layout.ConversionPattern=%d %5p %c{1}:%L - %m%n\n\n  // 测试类\n  public class Log4JTest01 {\n\n      //使用log4j的api来获取日志的对象\n      //弊端：如果以后我们更换日志的实现类，那么下面的代码就需要跟着改\n      //不推荐使用\n      //private static final Logger LOGGER = Logger.getLogger(Log4JTest01.class);\n\n      //使用slf4j里面的api来获取日志的对象\n      //好处：如果以后我们更换日志的实现类，那么下面的代码不需要跟着修改\n      //推荐使用\n      private static  final Logger LOGGER = LoggerFactory.getLogger(Log4JTest01.class);\n\n      public static void main(String[] args) {\n          //1.导入jar包\n          //2.编写配置文件\n          //3.在代码中获取日志的对象\n          //4.按照日志级别设置日志信息\n          LOGGER.debug("debug级别的日志");\n          LOGGER.info("info级别的日志");\n          LOGGER.warn("warn级别的日志");\n          LOGGER.error("error级别的日志");\n      }\n  }\n  ```\n\n### 3.4配置文件详解【理解】\n\n+ 三个核心\n\n  + Loggers(记录器)        日志的级别\n\n    Loggers组件在此系统中常见的五个级别：DEBUG、INFO、WARN、ERROR 和 FATAL。\n\n    DEBUG < INFO < WARN < ERROR < FATAL。\n\n    Log4j有一个规则：只输出级别不低于设定级别的日志信息。\n\n  + Appenders(输出源)   日志要输出的地方\n\n    把日志输出到不同的地方，如控制台（Console）、文件（Files）等。\n\n    + org.apache.log4j.ConsoleAppender（控制台）\n    + org.apache.log4j.FileAppender（文件）\n\n  + Layouts(布局)             日志输出的格式\n\n    可以根据自己的喜好规定日志输出的格式\n\n    常用的布局管理器：\n\n    ​\t\torg.apache.log4j.PatternLayout（可以灵活地指定布局模式）\n\n    ​          \torg.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）\n\n     \t\torg.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等信息）\n\n+ 配置根Logger\n\n  + 格式\n\n    log4j.rootLogger=日志级别，appenderName1，appenderName2，…\n\n  + 日志级别\n\n    OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者自定义的级别。\n\n  + appenderName1\n\n    就是指定日志信息要输出到哪里。可以同时指定多个输出目的地，用逗号隔开。\n\n    例如：log4j.rootLogger＝INFO，ca，fa\n\n+ ConsoleAppender常用的选项\n\n  + ImmediateFlush=true\n\n    表示所有消息都会被立即输出，设为false则不输出，默认值是true。\n\n  + Target=System.err\n\n    默认值是System.out。\n\n+ FileAppender常用的选项\n\n  + ImmediateFlush=true\n\n    表示所有消息都会被立即输出。设为false则不输出，默认值是true\n\n  + Append=false\n\n    true表示将消息添加到指定文件中，原来的消息不覆盖。\n\n    false则将消息覆盖指定的文件内容，默认值是true。\n\n  + File=D:/logs/logging.log4j\n\n    指定消息输出到logging.log4j文件中\n\n+ PatternLayout常用的选项\n\n  + ConversionPattern=%m%n\n\n    设定以怎样的格式显示消息\n\n    ![07_PatternLayout常用的选项](./day27-基础加强03.img/07_PatternLayout常用的选项.png)\n\n### 3.5在项目中的应用【应用】\n\n+ 步骤\n\n  1. 导入相关的依赖\n  2. 将资料中的properties配置文件复制到src目录下\n  3. 在代码中获取日志的对象\n  4. 按照级别设置记录日志信息\n\n+ 代码实现\n\n  ```java\n  @WebServlet(urlPatterns = "/servlet/loginservlet")\n  public class LoginServlet implements HttpServlet{\n\n      //获取日志的对象\n      private static final Logger LOGGER = LoggerFactory.getLogger(LoginServlet.class);\n\n      @Override\n      public void service(HttpRequest httpRequest, HttpResponse httpResponse) {\n         //处理\n          System.out.println("LoginServlet处理了登录请求");\n\n          LOGGER.info("现在已经处理了登录请求，准备给浏览器响应");\n\n         //响应\n          httpResponse.setContentTpye("text/html;charset=UTF-8");\n          httpResponse.write("登录成功");\n      }\n  }\n  ```\n\n'},"0b43":function(n,e,t){"use strict";t.r(e),e["default"]='## 1.NIO\n\n### 1.1 NIO通道客户端【应用】\n\n+ 客户端实现步骤\n\n  1. 打开通道\n  2. 指定IP和端口号\n  3. 写出数据\n  4. 释放资源\n\n+ 示例代码\n\n  ```java\n  public class NIOClient {\n      public static void main(String[] args) throws IOException {\n          //1.打开通道\n          SocketChannel socketChannel = SocketChannel.open();\n  \n          //2.指定IP和端口号\n          socketChannel.connect(new InetSocketAddress("127.0.0.1",10000));\n  \n          //3.写出数据\n          ByteBuffer byteBuffer = ByteBuffer.wrap("一点寒毛先制".getBytes());\n          socketChannel.write(byteBuffer);\n  \n          //4.释放资源\n          socketChannel.close();\n      }\n  }\n  ```\n\n### 1.2 NIO通道服务端【应用】\n\n+ NIO通道\n\n  + 服务端通道 \n\n    只负责建立建立，不负责传递数据\n\n  + 客户端通道\n\n    建立建立并将数据传递给服务端\n\n  + 缓冲区\n\n    客户端发送的数据都在缓冲区中\n\n  + 服务端通道内部创建出来的客户端通道\n\n    相当于客户端通道的延伸用来传递数据\n\n+ 服务端实现步骤\n\n  1. 打开一个服务端通道\n  2. 绑定对应的端口号\n  3. 通道默认是阻塞的，需要设置为非阻塞\n  4. 此时没有门卫大爷，所以需要经常看一下有没有连接发过来没？\n  5. 如果有客户端来连接了,则在服务端通道内部,再创建一个客户端通道,相当于是客户端通道的延伸\n  6. 获取客户端传递过来的数据,并把数据放在byteBuffer1这个缓冲区中\n  7. 给客户端回写数据\n  8. 释放资源\n\n+ 示例代码\n\n  ```java\n  public class NIOServer {\n      public static void main(String[] args) throws IOException {\n  //        1.打开一个服务端通道\n          ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n  //        2.绑定对应的端口号\n          serverSocketChannel.bind(new InetSocketAddress(10000));\n  //        3.通道默认是阻塞的，需要设置为非阻塞\n              //如果传递true 表示通道设置为阻塞通道...默认值\n              //如果传递false 表示通道设置为非阻塞通道\n          serverSocketChannel.configureBlocking(false);\n  //        4.此时没有门卫大爷，所以需要经常看一下有没有连接发过来没？\n          while (true) {\n  //        5.如果有客户端来连接了，则在服务端通道内部，再创建一个客户端通道，相当于是客户端通道的延伸\n              //此时已经设置了通道为非阻塞\n              //所以在调用方法的时候,如果有客户端来连接,那么会创建一个SocketChannel对象.\n              //如果在调用方法的时候,没有客户端来连接,那么他会返回一个null\n              SocketChannel socketChannel = serverSocketChannel.accept();\n              //System.out.println(socketChannel);\n              if(socketChannel != null){\n  //        6.客户端将缓冲区通过通道传递给服务端,就到了这个延伸通道socketChannel里面\n  //        7.服务端创建一个空的缓冲区装数据并输出\n                  ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n                  //获取传递过来的数据,并把他们放到byteBuffer缓冲区中.\n                  //返回值:\n                      //正数: 表示本次读到的有效字节个数.\n                      //0   : 表示本次没有读到有效字节.\n                      //-1  : 表示读到了末尾\n                  int len = socketChannel.read(byteBuffer);\n                  System.out.println(new String(byteBuffer.array(),0,len));\n                //8.释放资源\n                  socketChannel.close();\n              }\n          }\n      }\n  }\n  ```\n\n### 1.3 NIO通道练习【应用】\n\n+ 客户端\n\n  + 实现步骤\n\n    1. 打开通道\n    2. 指定IP和端口号\n    3. 写出数据\n    4. 读取服务器写回的数据\n    5. 释放资源\n\n  + 示例代码\n\n    ```java\n    public class Clinet {\n        public static void main(String[] args) throws IOException {\n            // 1.打开通道\n            SocketChannel socketChannel = SocketChannel.open();\n            // 2.指定IP和端口号\n            socketChannel.connect(new InetSocketAddress("127.0.0.1",10000));\n            // 3.写出数据\n            ByteBuffer byteBuffer1 = ByteBuffer.wrap("吃俺老孙一棒棒".getBytes());\n            socketChannel.write(byteBuffer1);\n      \t\t// 手动写入结束标记\n            socketChannel.shutdownOutput();\n  \n            System.out.println("数据已经写给服务器");\n            // 4.读取服务器写回的数据\n            ByteBuffer byteBuffer2 = ByteBuffer.allocate(1024);\n            int len;\n            while((len = socketChannel.read(byteBuffer2)) != -1){\n                byteBuffer2.flip();\n                System.out.println(new String(byteBuffer2.array(),0,len));\n                byteBuffer2.clear();\n            }\n            // 5.释放资源\n            socketChannel.close();\n        }\n    }\n    ```\n\n+ 服务端\n\n  + 实现步骤\n\n    1. 打开一个服务端通道\n    2. 绑定对应的端口号\n    3. 通道默认是阻塞的，需要设置为非阻塞\n    4. 此时没有门卫大爷，所以需要经常看一下有没有连接发过来没？\n    5. 如果有客户端来连接了,则在服务端通道内部,再创建一个客户端通道,相当于是客户端通道的延伸\n    6. 获取客户端传递过来的数据,并把数据放在byteBuffer1这个缓冲区中\n    7. 给客户端回写数据\n    8. 释放资源\n\n  + 示例代码\n\n    ```java\n    public class Sever {\n        public static void main(String[] args) throws IOException {\n            // 1，打开一个服务端通道\n            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n            // 2，绑定对应的端口号\n            serverSocketChannel.bind(new InetSocketAddress(10000));\n            // 3，通道默认是阻塞的，需要设置为非阻塞\n            serverSocketChannel.configureBlocking(false);\n            // 4，此时没有门卫大爷，所以需要经常看一下有没有连接发过来没？\n            while(true){\n                //  5，如果有客户端来连接了，则在服务端通道内部，再创建一个客户端通道，相当于是客户端通道的延伸\n                SocketChannel socketChannel = serverSocketChannel.accept();\n                if(socketChannel != null){\n                    System.out.println("此时有客户端来连接了");\n                    // 6,获取客户端传递过来的数据,并把数据放在byteBuffer1这个缓冲区中\n                    ByteBuffer byteBuffer1 = ByteBuffer.allocate(1024);\n                    //socketChannel.read(byteBuffer1);\n                    int len;\n                    //针对于缓冲区来讲\n                        //如果 从添加数据 ----\x3e 获取数据 flip\n                        //如果 从获取数据 ----\x3e 添加数据 clear\n                    while((len = socketChannel.read(byteBuffer1)) != -1){\n                        byteBuffer1.flip();\n                        System.out.println(new String(byteBuffer1.array(),0,len));\n                        byteBuffer1.clear();\n                    }\n    \n                    System.out.println("接收数据完毕,准备开始往客户端回写数据");\n                    // 7,给客户端回写数据\n                    ByteBuffer byteBuffer2 = ByteBuffer.wrap("哎哟,真疼啊!!!".getBytes());\n                    socketChannel.write(byteBuffer2);\n                    // 8,释放资源\n                    socketChannel.close();\n                }\n            }\n        }\n    }\n    ```\n\n### 1.4 NIO通道练习优化【应用】\n\n+ 存在问题\n\n  服务端内部获取的客户端通道在读取时,如果读取不到结束标记就会一直阻塞\n\n+ 解决方案\n\n  将服务端内部获取的客户端通道设置为非阻塞的\n\n+ 示例代码\n\n  ```java\n  // 客户端\n  public class Clinet {\n      public static void main(String[] args) throws IOException {\n          SocketChannel socketChannel = SocketChannel.open();\n  \n          socketChannel.connect(new InetSocketAddress("127.0.0.1",10000));\n  \n          ByteBuffer byteBuffer1 = ByteBuffer.wrap("吃俺老孙一棒棒".getBytes());\n          socketChannel.write(byteBuffer1);\n  \n          System.out.println("数据已经写给服务器");\n  \n          ByteBuffer byteBuffer2 = ByteBuffer.allocate(1024);\n          int len;\n          while((len = socketChannel.read(byteBuffer2)) != -1){\n              System.out.println("客户端接收回写数据");\n              byteBuffer2.flip();\n              System.out.println(new String(byteBuffer2.array(),0,len));\n              byteBuffer2.clear();\n          }\n          socketChannel.close();\n      }\n  }\n  // 服务端\n  public class Sever {\n      public static void main(String[] args) throws IOException {\n          ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n  \n          serverSocketChannel.bind(new InetSocketAddress(10000));\n  \n          serverSocketChannel.configureBlocking(false);\n  \n          while(true){\n              SocketChannel socketChannel = serverSocketChannel.accept();\n              if(socketChannel != null){\n                  System.out.println("此时有客户端来连接了");\n                \t// 将服务端内部获取的客户端通道设置为非阻塞的\n                  socketChannel.configureBlocking(false);\n                  //获取客户端传递过来的数据,并把数据放在byteBuffer1这个缓冲区中\n                  ByteBuffer byteBuffer1 = ByteBuffer.allocate(1024);\n                  //socketChannel.read(byteBuffer1);\n                  int len;\n                  //针对于缓冲区来讲\n                      //如果 从添加数据 ----\x3e 获取数据 flip\n                      //如果 从获取数据 ----\x3e 添加数据 clear\n                  while((len = socketChannel.read(byteBuffer1)) > 0){\n                      System.out.println("服务端接收发送数据");\n                      byteBuffer1.flip();\n                      System.out.println(new String(byteBuffer1.array(),0,len));\n                      byteBuffer1.clear();\n                  }\n  \n                  System.out.println("接收数据完毕,准备开始往客户端回写数据");\n  \n                  ByteBuffer byteBuffer2 = ByteBuffer.wrap("哎哟,真疼啊!!!".getBytes());\n                  socketChannel.write(byteBuffer2);\n  \n                  socketChannel.close();\n              }\n          }\n      }\n  }\n  ```\n\n### 1.5NIO选择器【理解】\n\n+ 概述\n\n  选择器可以监视通道的状态,多路复用\n\n  ![02_选择器概述](./day24-网络编程02.img/02_选择器概述.png)\n\n  ![01_选择器多路复用](./day24-网络编程02.img/01_选择器多路复用.png)\n\n+ 选择器对象\n\n  + Selector\n\n    选择器对象\n\n  + SelectionKey\n\n    绑定的key\n\n  + SelectableChannel\n\n    能使用选择器的通道\n\n    + SocketChannel\n    + ServerSocketChannel\n\n### 1.6NIO选择器改写服务端【应用】\n\n+ 实现步骤\n\n  1. 打开一个服务端通道(open)\n\n  2. 绑定对应的端口号\n\n  3. 通道默认是阻塞的，需要设置为非阻塞\n\n  4. 打开一个选择器（门卫大爷）\n\n  5. 将选择器绑定服务端通道，并监视服务端是否准备好\n\n  6. 如果有客户端来连接了，大爷会遍历所有的服务端通道，谁准备好了，就让谁来连接\n       连接后，在服务端通道内部，再创建一个客户端延伸通道\n\n  7. 如果客户端把数据传递过来了，大爷会遍历所有的延伸通道，谁准备好了，谁去接收数据\n\n       ![03_选择器改写服务器](./day24-网络编程02.img/03_选择器改写服务器.png)\n\n+  代码实现\n\n   ```java\n   // 客户端\n   public class Clinet {\n       public static void main(String[] args) throws IOException {\n           SocketChannel socketChannel = SocketChannel.open();\n   \n           socketChannel.connect(new InetSocketAddress("127.0.0.1",10000));\n   \n           ByteBuffer byteBuffer1 = ByteBuffer.wrap("吃俺老孙一棒棒".getBytes());\n           socketChannel.write(byteBuffer1);\n   \n           System.out.println("数据已经写给服务器");\n   \n           ByteBuffer byteBuffer2 = ByteBuffer.allocate(1024);\n           int len;\n           while((len = socketChannel.read(byteBuffer2)) != -1){\n               System.out.println("客户端接收回写数据");\n               byteBuffer2.flip();\n               System.out.println(new String(byteBuffer2.array(),0,len));\n               byteBuffer2.clear();\n           }\n           socketChannel.close();\n       }\n   }\n   // 服务端\n   public class Server {\n       public static void main(String[] args) throws IOException {\n           //1.打开服务端通道\n           ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n           //2.让这个通道绑定一个端口\n           serverSocketChannel.bind(new InetSocketAddress(10000));\n           //3.设置通道为非阻塞\n           serverSocketChannel.configureBlocking(false);\n           //4.打开一个选择器\n           //Selector --- 选择器\n   //        SelectionKey --- 绑定通道后返回那个令牌\n     //      SelectableChannel --- 可以使用选择器的通道\n           Selector selector = Selector.open();\n           //5.绑定选择器和服务端通道\n           serverSocketChannel.register(selector,SelectionKey.OP_ACCEPT);\n   \n           while(true){\n               System.out.println("11");\n               //选择器会监视客户端通道的状态.\n               //6.返回值就表示此时有多少个客户端来连接.\n               int count = selector.select();\n               System.out.println("222");\n               if(count != 0){\n                   System.out.println("有客户端来连接了");\n                   //7.会遍历所有的服务端通道.看谁准备好了,谁准备好了,就让谁去连接.\n                   //获取所有服务端通道的令牌,并将它们都放到一个集合中,将集合返回.\n                   Set<SelectionKey> selectionKeys = selector.selectedKeys();\n                   Iterator<SelectionKey> iterator = selectionKeys.iterator();\n                   while(iterator.hasNext()){\n                       //selectionKey 依次表示每一个服务端通道的令牌\n                       SelectionKey selectionKey = iterator.next();\n                       if(selectionKey.isAcceptable()){\n                           //可以通过令牌来获取到了一个已经就绪的服务端通道\n                           ServerSocketChannel ssc = (ServerSocketChannel) selectionKey.channel();\n                           //客户端的延伸通道\n                           SocketChannel socketChannel = ssc.accept();\n                           //将客户端延伸通道设置为非阻塞的\n                           socketChannel.configureBlocking(false);\n                           socketChannel.register(selector,SelectionKey.OP_READ);\n                           //当客户端来连接的时候,所有的步骤已经全部执行完毕.\n                       }else if(selectionKey.isReadable()){\n                           //当前通道已经做好了读取的准备(延伸通道)\n                           SocketChannel socketChannel = (SocketChannel) selectionKey.channel();\n                           ByteBuffer byteBuffer1 = ByteBuffer.allocate(1024);\n                           //socketChannel.read(byteBuffer1);\n                           int len;\n                           while((len = socketChannel.read(byteBuffer1)) > 0){\n                               byteBuffer1.flip();\n                               System.out.println(new String(byteBuffer1.array(),0,len));\n                               byteBuffer1.clear();\n                           }\n                           //给客户端的回写数据\n                           socketChannel.write(ByteBuffer.wrap("哎哟喂好疼啊!!!".getBytes()));\n                           socketChannel.close();\n                       }\n                       iterator.remove();\n                   }\n               }\n           }\n       }\n   }\n   ```\n\n## 2.HTTP协议\n\n### 2.1概述【理解】\n\n超文本传输协议(关于超文本的概念JavaWeb在进行学习)，是建立在TCP/IP协议基础上,是网络应用层的协议。\n\n由请求和响应构成,是一个标准的客户端和服务器模型\n\n### 2.2URL【理解】\n\n+ 概述\n\n  统一资源定位符,常见的如http://bbs.itheima.com/forum.php\n\n  完整的格式为 http://bbs.itheima.com:80/forum.php\n\n+ 详解\n\n  ![04_url](./day24-网络编程02.img/04_url.png)\n\n### 2.3抓包工具的使用【应用】\n\n+ 使用步骤\n\n  1. 在谷歌浏览器网页中按F12 或者网页空白处右键,点击检查,可以调出工具\n\n  2. 点击network,进入到查看网络相关信息界面\n\n  3. 这时在浏览器中发起请求,进行访问,工具中就会显示出请求和响应相关的信息\n\n     ![05_抓包](./day24-网络编程02.img/05_抓包.png)\n\n### 2.4请求信息【理解】\n\n+ 组成\n  + 请求行\n  + 请求头\n  + 请求空行\n  + 请求体\n\n\n+ 请求行\n\n  + 格式\n\n    ![06_请求行格式](./day24-网络编程02.img/06_请求行格式.png)\n\n  + 请求方式\n\n    GET,POST,HEAD,PUT,DELETE,CONNECT,OPTIONS,TRACE,PATCH\n\n    其中用的比较多的是GET和POST\n\n  + URI\n\n    请求资源路径,统一资源标识符\n\n    ![07_Uri图示](./day24-网络编程02.img/07_Uri图示.png)\n\n  + 协议版本\n\n    + HTTP1.0: 每次请求和响应都需要建立一个单独的连接\n    + HTTP1.1:支持长连接\n\n+ 请求头\n\n  + 格式\n\n    ![08_请求头图示](./day24-网络编程02.img/08_请求头图示.png)\n\n  + 请求头名称\n\n    + Host: 用来指定请求的服务端地址\n    + Connection: 取值为keep-alive表示需要持久连接\n    + User-Agent: 客户端的信息\n    + Accept: 指定客户端能够接收的内容类型\n    + Accept-Encoding: 指定浏览器可以支持的服务器返回内容压缩编码类型\n    + Accept-Language: 浏览器可接受的语言\n\n    ![09_请求头示例](./day24-网络编程02.img/09_请求头示例.png)\n\n+ 小结\n\n  ![10_请求信息小结](./day24-网络编程02.img/10_请求信息小结.png)\n\n### 2.5响应信息【理解】\n\n+ 组成\n  + 响应行\n  + 响应头\n  + 响应空行\n  + 响应体\n\n\n+ 响应行\n\n  + 格式\n\n    ![11_响应头格式](./day24-网络编程02.img/11_响应头格式.png)\n\n  + 协议版本\n\n    + HTTP1.0: 每次请求和响应都需要建立一个单独的连接\n    + HTTP1.1: 支持长连接\n\n  + 响应状态码\n\n    + 1xx: 指示信息(表示请求已接收，继续处理)\n    + 2xx: 成功(表示请求已被成功接收、理解、接受)\n    + 3xx: 请求重定向(要完成请求必须进行更进一步的操作)\n    + 4xx: 客户端错误(请求有语法错误或请求无法实现)\n    + 5xx: 服务器端错误(服务器未能实现合法的请求)\n\n  + 状态信息\n\n    + 200 ok\n    + 404 Not Found\n    + 500 Internal Server Error\n\n+ 响应头\n\n  + 响应头名称\n\n    + Content-Type: 告诉客户端实际返回内容的网络媒体类型(互联网媒体类型,也叫做MIME类型)\n\n  + 响应头值\n\n    + text/html ----\x3e 文本类型\n    + image/png ----\x3e png格式文件\n    + image/jpeg ----\x3e jpg格式文件\n\n    ![13_响应头示例](./day24-网络编程02.img/13_响应头示例.png)\n\n+ 小结\n\n  ![12_响应信息小结](./day24-网络编程02.img/12_响应信息小结.png)\n\n## 3.HTTP服务器\n\n### 3.1需求【理解】\n\n+ 编写服务器端代码,实现可以解析浏览器的请求,给浏览器响应数据\n\n### 3.2环境搭建【理解】\n\n+ 实现步骤\n  + 编写HttpServer类,实现可以接收浏览器发出的请求\n  + 其中获取连接的代码可以单独抽取到一个类中\n\n+ 代码实现\n\n  ```java\n  // 服务端代码\n  public class HttpServer {\n      public static void main(String[] args) throws IOException {\n          //1.打开服务端通道\n          ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n          //2.让这个通道绑定一个端口\n          serverSocketChannel.bind(new InetSocketAddress(10000));\n          //3.设置通道为非阻塞\n          serverSocketChannel.configureBlocking(false);\n          //4.打开一个选择器\n          Selector selector = Selector.open();\n  \n          //5.绑定选择器和服务端通道\n          serverSocketChannel.register(selector,SelectionKey.OP_ACCEPT);\n  \n          while(true){\n              //6.选择器会监视通道的状态.\n              int count = selector.select();\n              if(count != 0){\n                  //7.会遍历所有的服务端通道.看谁准备好了,谁准备好了,就让谁去连接.\n                  //获取所有服务端通道的令牌,并将它们都放到一个集合中,将集合返回.\n                  Set<SelectionKey> selectionKeys = selector.selectedKeys();\n                  Iterator<SelectionKey> iterator = selectionKeys.iterator();\n                  while(iterator.hasNext()){\n                      //selectionKey 依次表示每一个服务端通道的令牌\n                      SelectionKey selectionKey = iterator.next();\n                      if(selectionKey.isAcceptable()){\n                          //获取连接\n                          AcceptHandler acceptHandler = new AcceptHandler();\n                          acceptHandler.connSocketChannel(selectionKey);\n                      }else if(selectionKey.isReadable()){\n                         \n                      }\n                      //任务处理完毕以后,将SelectionKey从集合中移除\n                      iterator.remove();\n                  }\n              }\n          }\n      }\n  }\n  // 将获取连接的代码抽取到这个类中\n  public class AcceptHandler {\n  \n      public SocketChannel connSocketChannel(SelectionKey selectionKey){\n          try {\n              //获取到已经就绪的服务端通道\n              ServerSocketChannel ssc = (ServerSocketChannel) selectionKey.channel();\n              SocketChannel socketChannel = ssc.accept();\n              //设置为非阻塞状态\n              socketChannel.configureBlocking(false);\n              //把socketChannel注册到选择器上\n              socketChannel.register(selectionKey.selector(), SelectionKey.OP_READ);\n              return socketChannel;\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n          return null;\n      }\n  }\n  ```\n\n### 3.3获取请求信息并解析【理解】\n\n+ 实现步骤\n\n  + 将请求信息封装到HttpRequest类中\n  + 在类中定义方法,实现获取请求信息并解析\n\n+ 代码实现\n\n  ```java\n  /**\n   * 用来封装请求数据的类\n   */\n  public class HttpRequest {\n      private String method; //请求方式\n      private String requestURI; //请求的uri\n      private String version;   //http的协议版本\n  \n      private HashMap<String,String> hm = new HashMap<>();//所有的请求头\n  \n      //parse --- 获取请求数据 并解析\n      public void parse(SelectionKey selectionKey){\n          try {\n              SocketChannel socketChannel = (SocketChannel) selectionKey.channel();\n  \n              StringBuilder sb = new StringBuilder();\n              //创建一个缓冲区\n              ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n              int len;\n              //循环读取\n              while((len = socketChannel.read(byteBuffer)) > 0){\n                  byteBuffer.flip();\n                  sb.append(new String(byteBuffer.array(),0,len));\n                  //System.out.println(new String(byteBuffer.array(),0,len));\n                  byteBuffer.clear();\n              }\n              //System.out.println(sb);\n              parseHttpRequest(sb);\n  \n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n      }\n  \n      //解析http请求协议中的数据\n      private void parseHttpRequest(StringBuilder sb) {\n          //1.需要把StringBuilder先变成一个字符串\n          String httpRequestStr = sb.toString();\n          //2.获取每一行数据\n          String[] split = httpRequestStr.split("\\rn");\n          //3.获取请求行\n          String httpRequestLine = split[0];//GET / HTTP/1.1\n          //4.按照空格进行切割,得到请求行中的三部分\n          String[] httpRequestInfo = httpRequestLine.split(" ");\n          this.method = httpRequestInfo[0];\n          this.requestURI = httpRequestInfo[1];\n          this.version = httpRequestInfo[2];\n          //5.操作每一个请求头\n          for (int i = 1; i < split.length; i++) {\n              String httpRequestHeaderInfo = split[i];//Host: 127.0.0.1:10000\n              String[] httpRequestHeaderInfoArr = httpRequestHeaderInfo.split(": ");\n              hm.put(httpRequestHeaderInfoArr[0],httpRequestHeaderInfoArr[1]);\n          }\n  \n      }\n  \n      public String getMethod() {\n          return method;\n      }\n  \n      public void setMethod(String method) {\n          this.method = method;\n      }\n  \n      public String getRequestURI() {\n          return requestURI;\n      }\n  \n      public void setRequestURI(String requestURI) {\n          this.requestURI = requestURI;\n      }\n  \n      public String getVersion() {\n          return version;\n      }\n  \n      public void setVersion(String version) {\n          this.version = version;\n      }\n  \n      public HashMap<String, String> getHm() {\n          return hm;\n      }\n  \n      public void setHm(HashMap<String, String> hm) {\n          this.hm = hm;\n      }\n  \n      @Override\n      public String toString() {\n          return "HttpRequest{" +\n                  "method=\'" + method + \'\\\'\' +\n                  ", requestURI=\'" + requestURI + \'\\\'\' +\n                  ", version=\'" + version + \'\\\'\' +\n                  ", hm=" + hm +\n                  \'}\';\n      }\n  }\n  ```\n\n### 3.4给浏览器响应数据【理解】\n\n+ 实现步骤\n\n  + 将响应信息封装HttpResponse类中\n  + 定义方法,封装响应信息,给浏览器响应数据\n\n+ 代码实现\n\n  ```java\n  public class HttpResponse {\n      private String version; //协议版本\n      private String status;  //响应状态码\n      private String desc;    //状态码的描述信息\n  \n      //响应头数据\n      private HashMap<String, String> hm = new HashMap<>();\n  \n      private HttpRequest httpRequest;  //我们后面要根据请求的数据,来进行一些判断\n  \n      //给浏览器响应数据的方法\n      public void sendStaticResource(SelectionKey selectionKey) {\n          //1.给响应行赋值\n          this.version = "HTTP/1.1";\n          this.status = "200";\n          this.desc = "ok";\n          //2.将响应行拼接成一个单独的字符串 // HTTP/1.1 200 ok\n          String responseLine = this.version + " " + this.status + " " + this.desc + "\\rn";\n  \n          //3.给响应头赋值\n          hm.put("Content-Type", "text/html;charset=UTF-8");\n  \n          //4.将所有的响应头拼接成一个单独的字符串\n          StringBuilder sb = new StringBuilder();\n          Set<Map.Entry<String, String>> entries = hm.entrySet();\n          for (Map.Entry<String, String> entry : entries) {\n              sb.append(entry.getKey()).append(": ").append(entry.getValue()).append("\\rn");\n          }\n  \n          //5.响应空行\n          String emptyLine = "\\rn";\n  \n          //6.响应行,响应头,响应空行拼接成一个大字符串\n          String responseLineStr = responseLine + sb.toString() + emptyLine;\n  \n          try {\n              //7.将上面三个写给浏览器\n              SocketChannel socketChannel = (SocketChannel) selectionKey.channel();\n              ByteBuffer byteBuffer1 = ByteBuffer.wrap(responseLineStr.getBytes());\n              socketChannel.write(byteBuffer1);\n  \n              //8.单独操作响应体\n              //因为在以后响应体不一定是一个字符串\n              //有可能是一个文件,所以单独操作\n              String s = "哎哟,妈呀,终于写完了.";\n              ByteBuffer byteBuffer2 = ByteBuffer.wrap(s.getBytes());\n              socketChannel.write(byteBuffer2);\n  \n              //9.释放资源\n              socketChannel.close();\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n      }\n  \n      public String getVersion() {\n          return version;\n      }\n  \n      public void setVersion(String version) {\n          this.version = version;\n      }\n  \n      public String getStatus() {\n          return status;\n      }\n  \n      public void setStatus(String status) {\n          this.status = status;\n      }\n  \n      public String getDesc() {\n          return desc;\n      }\n  \n      public void setDesc(String desc) {\n          this.desc = desc;\n      }\n  \n      public HashMap<String, String> getHm() {\n          return hm;\n      }\n  \n      public void setHm(HashMap<String, String> hm) {\n          this.hm = hm;\n      }\n  \n      public HttpRequest getHttpRequest() {\n          return httpRequest;\n      }\n  \n      public void setHttpRequest(HttpRequest httpRequest) {\n          this.httpRequest = httpRequest;\n      }\n  \n      @Override\n      public String toString() {\n          return "HttpResponse{" +\n                  "version=\'" + version + \'\\\'\' +\n                  ", status=\'" + status + \'\\\'\' +\n                  ", desc=\'" + desc + \'\\\'\' +\n                  ", hm=" + hm +\n                  ", httpRequest=" + httpRequest +\n                  \'}\';\n      }\n  }\n  ```\n\n### 3.5代码优化【理解】\n\n+ 实现步骤\n\n  + 根据请求资源路径不同,响应不同的数据\n  + 服务端健壮性处理\n  + 访问不存在的资源处理\n\n+ 代码实现\n\n  ```java\n  /**\n   * 接收连接的任务处理类\n   */\n  public class AcceptHandler {\n  \n      public SocketChannel connSocketChannel(SelectionKey selectionKey){\n          try {\n              //获取到已经就绪的服务端通道\n              ServerSocketChannel ssc = (ServerSocketChannel) selectionKey.channel();\n              SocketChannel socketChannel = ssc.accept();\n              //设置为非阻塞状态\n              socketChannel.configureBlocking(false);\n              //把socketChannel注册到选择器上\n              socketChannel.register(selectionKey.selector(), SelectionKey.OP_READ);\n              return socketChannel;\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n          return null;\n      }\n  }\n  /**\n   * 接收客户端请求的类\n   */\n  public class HttpServer {\n      public static void main(String[] args) throws IOException {\n          //1.打开服务端通道\n          ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n          //2.让这个通道绑定一个端口\n          serverSocketChannel.bind(new InetSocketAddress(10000));\n          //3.设置通道为非阻塞\n          serverSocketChannel.configureBlocking(false);\n          //4.打开一个选择器\n          Selector selector = Selector.open();\n          //5.绑定选择器和服务端通道\n          serverSocketChannel.register(selector,SelectionKey.OP_ACCEPT);\n  \n          while(true){\n              //6.选择器会监视通道的状态.\n              int count = selector.select();\n              if(count != 0){\n                  //7.会遍历所有的服务端通道.看谁准备好了,谁准备好了,就让谁去连接.\n                  //获取所有服务端通道的令牌,并将它们都放到一个集合中,将集合返回.\n                  Set<SelectionKey> selectionKeys = selector.selectedKeys();\n                  Iterator<SelectionKey> iterator = selectionKeys.iterator();\n                  while(iterator.hasNext()){\n                      //selectionKey 依次表示每一个服务端通道的令牌\n                      SelectionKey selectionKey = iterator.next();\n                      if(selectionKey.isAcceptable()){\n                          //获取连接\n                          AcceptHandler acceptHandler = new AcceptHandler();\n                          acceptHandler.connSocketChannel(selectionKey);\n  \n                      }else if(selectionKey.isReadable()){\n                          //读取数据\n                          HttpRequest httpRequest = new HttpRequest();\n                          httpRequest.parse(selectionKey);\n                          System.out.println("http请求的数据为 ----\x3e" + httpRequest);\n  \n                          if(httpRequest.getRequestURI() == null || "".equals(httpRequest.getRequestURI())){\n                              selectionKey.channel();\n                              continue;\n                          }\n                          System.out.println("...数据解析完毕,准备响应数据....");\n  \n                          //响应数据\n                          HttpResponse httpResponse = new HttpResponse();\n                          httpResponse.setHttpRequest(httpRequest);\n                          httpResponse.sendStaticResource(selectionKey);\n                      }\n                      //任务处理完毕以后,将SelectionKey从集合中移除\n                      iterator.remove();\n                  }\n              }\n          }\n      }\n  }\n  /**\n   * 用来封装请求数据的类\n   */\n  public class HttpRequest {\n      private String method; //请求方式\n      private String requestURI; //请求的uri\n      private String version;   //http的协议版本\n  \n      private HashMap<String,String> hm = new HashMap<>();//所有的请求头\n  \n      //parse --- 获取请求数据 并解析\n      public void parse(SelectionKey selectionKey){\n          try {\n              SocketChannel socketChannel = (SocketChannel) selectionKey.channel();\n  \n              StringBuilder sb = new StringBuilder();\n              //创建一个缓冲区\n              ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n              int len;\n              //循环读取\n              while((len = socketChannel.read(byteBuffer)) > 0){\n                  byteBuffer.flip();\n                  sb.append(new String(byteBuffer.array(),0,len));\n                  //System.out.println(new String(byteBuffer.array(),0,len));\n                  byteBuffer.clear();\n              }\n              //System.out.println(sb);\n              parseHttpRequest(sb);\n  \n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n      }\n    \n      //解析http请求协议中的数据\n      private void parseHttpRequest(StringBuilder sb) {\n          //1.需要把StringBuilder先变成一个字符串\n          String httpRequestStr = sb.toString();\n          if(!(httpRequestStr == null || "".equals(httpRequestStr))){\n              //2.获取每一行数据\n              String[] split = httpRequestStr.split("\\rn");\n              //3.获取请求行\n              String httpRequestLine = split[0];//GET / HTTP/1.1\n              //4.按照空格进行切割,得到请求行中的三部分\n              String[] httpRequestInfo = httpRequestLine.split(" ");\n              this.method = httpRequestInfo[0];\n              this.requestURI = httpRequestInfo[1];\n              this.version = httpRequestInfo[2];\n              //5.操作每一个请求头\n              for (int i = 1; i < split.length; i++) {\n                  String httpRequestHeaderInfo = split[i];//Host: 127.0.0.1:10000\n                  String[] httpRequestHeaderInfoArr = httpRequestHeaderInfo.split(": ");\n                  hm.put(httpRequestHeaderInfoArr[0],httpRequestHeaderInfoArr[1]);\n              }\n          }\n      }\n  \n      public String getMethod() {\n          return method;\n      }\n  \n      public void setMethod(String method) {\n          this.method = method;\n      }\n  \n      public String getRequestURI() {\n          return requestURI;\n      }\n  \n      public void setRequestURI(String requestURI) {\n          this.requestURI = requestURI;\n      }\n  \n      public String getVersion() {\n          return version;\n      }\n  \n      public void setVersion(String version) {\n          this.version = version;\n      }\n  \n      public HashMap<String, String> getHm() {\n          return hm;\n      }\n  \n      public void setHm(HashMap<String, String> hm) {\n          this.hm = hm;\n      }\n  \n      @Override\n      public String toString() {\n          return "HttpRequest{" +\n                  "method=\'" + method + \'\\\'\' +\n                  ", requestURI=\'" + requestURI + \'\\\'\' +\n                  ", version=\'" + version + \'\\\'\' +\n                  ", hm=" + hm +\n                  \'}\';\n      }\n  }\n  /**\n   * 用来封装响应数据的类\n   */\n  public class HttpResponse {\n      private String version; //协议版本\n      private String status;  //响应状态码\n      private String desc;    //状态码的描述信息\n  \n      //响应头数据\n      private HashMap<String, String> hm = new HashMap<>();\n  \n      private HttpRequest httpRequest;  //我们后面要根据请求的数据,来进行一些判断\n  \n      //给浏览器响应数据的方法\n      public void sendStaticResource(SelectionKey selectionKey) {\n          //1.给响应行赋值\n          this.version = "HTTP/1.1";\n          this.status = "200";\n          this.desc = "ok";\n  \n          //3.给响应头赋值\n          //先获取浏览器请求的URI\n          String requestURI = this.getHttpRequest().getRequestURI();\n          if(requestURI != null){\n  \n              File file = new File(WEB_APP_PATH + requestURI);\n              //判断这个路径是否存在\n              if(!file.exists()){\n                  this.status = "404";\n                  this.desc = "NOT FOUNG";\n              }\n  \n              if("200".equals(this.status)){\n                  if("/".equals(requestURI)){\n                      hm.put("Content-Type", "text/html;charset=UTF-8");\n                  }else if("/favicon.ico".equals(requestURI)){\n                      hm.put("Content-Type", "image/x-icon");\n                  }else if("/a.txt".equals(requestURI)){\n                      hm.put("Content-Type", "text/html;charset=UTF-8");\n                  }else if("/1.jpg".equals(requestURI)){\n                      hm.put("Content-Type", "image/jpeg");\n                  }else if("/1.png".equals(requestURI)){\n                      hm.put("Content-Type", "image/png");\n                  }\n              }else{\n                  hm.put("Content-Type", "text/html;charset=UTF-8");\n              }\n  \n          }\n  \n          //2.将响应行拼接成一个单独的字符串 // HTTP/1.1 200 ok\n          String responseLine = this.version + " " + this.status + " " + this.desc + "\\rn";\n  \n          //4.将所有的响应头拼接成一个单独的字符串\n          StringBuilder sb = new StringBuilder();\n          Set<Map.Entry<String, String>> entries = hm.entrySet();\n          for (Map.Entry<String, String> entry : entries) {\n              sb.append(entry.getKey()).append(": ").append(entry.getValue()).append("\\rn");\n          }\n  \n          //5.响应空行\n          String emptyLine = "\\rn";\n  \n          //6.响应行,响应头,响应空行拼接成一个大字符串\n          String responseLineStr = responseLine + sb.toString() + emptyLine;\n  \n          try {\n              //7.将上面三个写给浏览器\n              SocketChannel socketChannel = (SocketChannel) selectionKey.channel();\n              ByteBuffer byteBuffer1 = ByteBuffer.wrap(responseLineStr.getBytes());\n              socketChannel.write(byteBuffer1);\n  \n              //8.单独操作响应体\n              //因为在以后响应体不一定是一个字符串\n              //有可能是一个文件,所以单独操作\n             // String s = "哎哟,妈呀,终于写完了.";\n              byte [] bytes = getContent();\n              ByteBuffer byteBuffer2 = ByteBuffer.wrap(bytes);\n              socketChannel.write(byteBuffer2);\n  \n              //9.释放资源\n              socketChannel.close();\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n      }\n  \n      public static final String WEB_APP_PATH = "mynio\\\\webapp";\n      private byte[] getContent() {\n          try {\n              //1.获取浏览器请求的URI\n              String requestURI = this.getHttpRequest().getRequestURI();\n              if(requestURI != null){\n  \n                  if("200".equals(this.status)){\n                      //2.判断一下请求的URI,根据不同的URI来响应不同的东西\n                      if("/".equals(requestURI)){\n                          String s = "哎哟,妈呀,终于写完了.";\n                          return s.getBytes();\n                      }else/* if("/favicon.ico".equals(requestURI))*/{\n                          //获取一个ico文件\n                          FileInputStream fis = new FileInputStream(WEB_APP_PATH + requestURI);\n                          //把ico文件变成一个字节数组返回\n                          return IOUtils.toByteArray(fis);\n                      }\n                  }else{\n                      return "访问的资源不存在".getBytes();\n                  }\n              }\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n          return new byte[0];\n      }\n  \n      public String getVersion() {\n          return version;\n      }\n  \n      public void setVersion(String version) {\n          this.version = version;\n      }\n  \n      public String getStatus() {\n          return status;\n      }\n  \n      public void setStatus(String status) {\n          this.status = status;\n      }\n  \n      public String getDesc() {\n          return desc;\n      }\n  \n      public void setDesc(String desc) {\n          this.desc = desc;\n      }\n  \n      public HashMap<String, String> getHm() {\n          return hm;\n      }\n  \n      public void setHm(HashMap<String, String> hm) {\n          this.hm = hm;\n      }\n  \n      public HttpRequest getHttpRequest() {\n          return httpRequest;\n      }\n  \n      public void setHttpRequest(HttpRequest httpRequest) {\n          this.httpRequest = httpRequest;\n      }\n  \n      @Override\n      public String toString() {\n          return "HttpResponse{" +\n                  "version=\'" + version + \'\\\'\' +\n                  ", status=\'" + status + \'\\\'\' +\n                  ", desc=\'" + desc + \'\\\'\' +\n                  ", hm=" + hm +\n                  ", httpRequest=" + httpRequest +\n                  \'}\';\n      }\n  }\n  ```\n\n  \n\n'},"0b4c":function(n,e,t){"use strict";t.r(e),e["default"]="## 1. Java概述\r\n\r\n### 1.1 Java语言背景介绍（了解）\r\n\r\n语言：人与人交流沟通的表达方式\r\n\r\n计算机语言：人与计算机之间进行信息交流沟通的一种特殊语言\r\n\r\nJava语言是美国Sun公司（Stanford University Network）在1995年推出的计算机语言\r\n\r\nJava之父：詹姆斯·高斯林（James Gosling）\r\n\r\n2009年，Sun公司被甲骨文公司收购，所以我们现在访问oracle官网即可：[https://www.oracle.com](https://www.oracle.com/) \r\n\r\njava语言的三个版本：\r\n\r\n​\tJavaSE:  Java 语言的（标准版），用于桌面应用的开发，是其他两个版本的基础\r\n\r\n​\tJavaME: Java 语言的（小型版），用于嵌入式消费类电子设备\r\n\r\n​\tJavaEE: Java 语言的（企业版），用于 Web 方向的网站开发\r\n\r\n### 1.2 Java语言跨平台原理（理解）\r\n\r\nJava程序并非是直接运行的，Java编译器将Java源程序编译成与平台无关的字节码文件(class文件)，然后由Java虚拟机（JVM）对字节码文件解释执行。所以在不同的操作系统下，只需安装不同的Java虚拟机即可实现java程序的跨平台。\r\n\r\n### 1.3 JRE和JDK（记忆）\r\n\r\nJVM（Java Virtual Machine），Java虚拟机\r\n\r\nJRE（Java Runtime Environment），Java运行环境，包含了JVM和Java的核心类库（Java API）\r\n\r\nJDK（Java Development Kit）称为Java开发工具，包含了JRE和开发工具\r\n\r\n总结：我们只需安装JDK即可，它包含了java的运行环境和虚拟机。\r\n\r\n### 1.4 JDK的下载和安装（应用）\r\n\r\n#### 1.4.1 下载\r\n\r\n通过官方网站获取JDK\r\n\r\n[http://www.oracle.com](http://www.oracle.com/)\r\n\r\n**注意**：针对不同的操作系统，需要下载对应版本的JDK。\r\n\r\n#### 1.4.2 安装\r\n\r\n傻瓜式安装，下一步即可。但默认的安装路径是在C:\\Program Files下，为方便统一管理建议修改安装路径，将与开发相关的软件都安装到一个目录下，例如：E:\\develop。\r\n\r\n**注意**：安装路径不要包含中文或者空格等特殊字符（使用纯英文目录）。\r\n\r\n#### 1.4.3 JDK的安装目录介绍\r\n\r\n| 目录名称 | 说明                                                         |\r\n| -------- | ------------------------------------------------------------ |\r\n| bin      | 该路径下存放了JDK的各种工具命令。javac和java就放在这个目录。 |\r\n| conf     | 该路径下存放了JDK的相关配置文件。                            |\r\n| include  | 该路径下存放了一些平台特定的头文件。                         |\r\n| jmods    | 该路径下存放了JDK的各种模块。                                |\r\n| legal    | 该路径下存放了JDK各模块的授权文档。                          |\r\n| lib      | 该路径下存放了JDK工具的一些补充JAR包。                       |\r\n\r\n\r\n\r\n## 2. 第一个演示程序\r\n\r\n### 2.1 常用DOS命令（应用）\r\n\r\n在接触集成开发环境之前，我们需要使用命令行窗口对java程序进行编译和运行，所以需要知道一些常用DOS命令。\r\n\r\n1、打开命令行窗口的方式：win + r打开运行窗口，输入cmd，回车。\r\n\r\n2、常用命令及其作用\r\n\r\n| 操作               | 说明                              |\r\n| ------------------ | --------------------------------- |\r\n| 盘符名称:          | 盘符切换。E:回车，表示切换到E盘。 |\r\n| dir                | 查看当前路径下的内容。            |\r\n| cd 目录            | 进入单级目录。cd itheima          |\r\n| cd ..              | 回退到上一级目录。                |\r\n| cd 目录1\\目录2\\... | 进入多级目录。cd itheima\\JavaSE   |\r\n| cd \\               | 回退到盘符目录。                  |\r\n| cls                | 清屏。                            |\r\n| exit               | 退出命令提示符窗口。              |\r\n\r\n### 2.2 Path环境变量的配置（应用）\r\n\r\n#### 2.2.1 为什么配置环境变量\r\n\r\n开发Java程序，需要使用JDK提供的开发工具（比如javac.exe、java.exe等命令），而这些工具在JDK的安装目录的bin目录下，如果不配置环境变量，那么这些命令只可以在该目录下执行。我们不可能把所有的java文件都放到JDK的bin目录下，所以配置环境变量的作用就是可以使bin目录下的java相关命令可以在任意目录下使用。    \r\n\r\n### 2.3 HelloWorld案例（应用）\r\n\r\nHelloWorld案例是指在计算机屏幕上输出“HelloWorld”这行文字。\r\n\r\n各种计算机语言都习惯使用该案例作为第一个演示案例。\r\n\r\n#### 2.3.1 Java程序开发运行流程\r\n\r\n开发Java程序，需要三个步骤：编写程序，编译程序，运行程序。\r\n\r\n#### 2.3.2 HelloWorld案例的编写\r\n\r\n1、新建文本文档文件，修改名称为HelloWorld.java。\r\n\r\n2、用记事本打开HelloWorld.java文件，输写程序内容。\r\n\r\n~~~java\r\npublic class HelloWorld {\r\n\tpublic static void main(String[] args) {\r\n\t\tSystem.out.println(\"HelloWorld\");\r\n\t}\r\n}\r\n~~~\r\n\r\n#### 2.3.3 HelloWorld案例的编译和运行\r\n\r\n存文件，打开命令行窗口，将目录切换至java文件所在目录，编译java文件生成class文件，运行class文件。\r\n\r\n> 编译：javac 文件名.java\r\n>\r\n> 范例：javac HelloWorld.java\r\n>\r\n> 执行：java 类名\r\n>\r\n> 范例：java HelloWorld\r\n\r\n### 2.4 HelloWorld案例详解（理解）\r\n\r\n![](./day01-java基础语法.img/图片1.jpg)\r\n\r\n### 2.5 HelloWorld案例常见问题（理解）\r\n\r\n#### 2.5.1 BUG\r\n\r\n在电脑系统或程序中，隐藏着的一些未被发现的缺陷或问题统称为bug（漏洞）。\r\n\r\n#### 2.5.2 BUG的解决\r\n\r\n1、具备识别BUG的能力：多看\r\n\r\n2、具备分析BUG的能力：多思考，多查资料\r\n\r\n3、具备解决BUG的能力：多尝试，多总结\r\n\r\n#### 2.5.3 HelloWorld案例常见问题\r\n\r\n1、非法字符问题。Java中的符号都是英文格式的。\r\n\r\n2、大小写问题。Java语言对大小写敏感（区分大小写）。\r\n\r\n3、在系统中显示文件的扩展名，避免出现HelloWorld.java.txt文件。\r\n\r\n4、编译命令后的java文件名需要带文件后缀.java\r\n\r\n5、运行命令后的class文件名（类名）不带文件后缀\r\n\r\n### 2.6 Notepad++软件的安装和使用（应用）\r\n\r\n#### 2.6.1 什么要使用Notepad++软件\r\n\r\nNotepad++功能比windows中的自带记事本功能强大，除了可以用来制作一般的纯文字说明文件，也十分适合编写计算机程序代码。Notepad++有行号，能够快速定位问题位置，还有语法高亮度显示、代码折叠等功能。而且它是免费的。\r\n\r\n#### 2.6.2 Notepad++软件安装\r\n\r\n安装：傻瓜式安装，一直下一步即可。建议也安装到统一的开发软件目录下，比如E:\\develop。\r\n\r\n#### 2.6.3Notepad++软件配置\r\n\r\n安装完毕之后，为了使用方便，做一个简单的配置：修改默认语言和编码。\r\n\r\n## 3. java基础语法\r\n\r\n### 3.1 注释（理解）\r\n\r\n注释是对代码的解释和说明文字，可以提高程序的可读性，因此在程序中添加必要的注释文字十分重要。Java中的注释分为三种：\r\n\r\n单行注释。单行注释的格式是使用//，从//开始至本行结尾的文字将作为注释文字。\r\n\r\n~~~java\r\n// 这是单行注释文字\r\n~~~\r\n\r\n多行注释。多行注释的格式是使用/* 和 */将一段较长的注释括起来。\r\n\r\n~~~java\r\n/*\r\n这是多行注释文字\r\n这是多行注释文字\r\n这是多行注释文字\r\n*/\r\n注意：多行注释不能嵌套使用。\r\n~~~\r\n\r\n文档注释。文档注释以`/**`开始，以`*/`结束。（以后讲）\r\n\r\n### 3.2 关键字（理解）\r\n\r\n关键字是指被java语言赋予了特殊含义的单词。\r\n\r\n关键字的特点：\r\n\r\n​\t关键字的字母全部小写。\r\n\r\n​\t常用的代码编辑器对关键字都有高亮显示，比如现在我们能看到的public、class、static等。\r\n\r\n### 3.3 常量（应用）\r\n\r\n常量：在程序运行过程中，其值不可以发生改变的量。\r\n\r\nJava中的常量分类：\r\n\r\n​\t字符串常量  用双引号括起来的多个字符（可以包含0个、一个或多个），例如\"a\"、\"abc\"、\"中国\"等\r\n\r\n​\t整数常量  整数，例如：-10、0、88等\r\n\r\n​\t小数常量  小数，例如：-5.5、1.0、88.88等\r\n\r\n​\t字符常量  用单引号括起来的一个字符，例如：'a'、'5'、'B'、'中'等\r\n\r\n​\t布尔常量  布尔值，表示真假，只有两个值true和false\r\n\r\n​\t空常量  一个特殊的值，空值，值为null\r\n\r\n除空常量外，其他常量均可使用输出语句直接输出。\r\n\r\n~~~java\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        System.out.println(10); // 输出一个整数\r\n        System.out.println(5.5); // 输出一个小数\r\n        System.out.println('a'); // 输出一个字符\r\n        System.out.println(true); // 输出boolean值true\r\n        System.out.println(\"欢迎来到黑马程序员\"); // 输出字符串\r\n    }\r\n}\r\n~~~\r\n\r\n### 3.4 变量的介绍(理解)\r\n\r\n变量的定义格式：\r\n\r\n​\t数据类型 变量名 = 数据值；\r\n\r\n​\t数据类型：为空间中存储的数据加入类型限制。整数？小数？\r\n\r\n​\t变量名：自己要为空间起的名字，没有难度\r\n\r\n​\t数据值： 空间中要存储的数值，没有难度\r\n\r\n### 3.5 数据类型（应用）\r\n\r\n#### 3.5.1 计算机存储单元\r\n\r\n我们知道计算机是可以用来存储数据的，但是无论是内存还是硬盘，计算机存储设备的最小信息单元叫“位（bit）”，我们又称之为“比特位”，通常用小写的字母”b”表示。而计算机中最基本的存储单元叫“字节（byte）”，\r\n\r\n通常用大写字母”B”表示，字节是由连续的8个位组成。\r\n\r\n除了字节外还有一些常用的存储单位，其换算单位如下：\r\n\r\n1B（字节） = 8bit\r\n\r\n1KB = 1024B\r\n\r\n1MB = 1024KB\r\n\r\n1GB = 1024MB\r\n\r\n1TB = 1024GB\r\n\r\n#### 3.5.2 Java中的数据类型\r\n\r\nJava是一个强类型语言，Java中的数据必须明确数据类型。在Java中的数据类型包括基本数据类型和引用数据类型两种。\r\n\r\nJava中的基本数据类型：\r\n\r\n| 数据类型 | 关键字       | 内存占用 | 取值范围                                                     |\r\n| :------- | ------------ | -------- | :----------------------------------------------------------- |\r\n| 整数类型 | byte         | 1        | -128~127                                                     |\r\n|          | short        | 2        | -32768~32767                                                 |\r\n|          | int(默认)    | 4        | -2的31次方到2的31次方-1                                      |\r\n|          | long         | 8        | -2的63次方到2的63次方-1                                      |\r\n| 浮点类型 | float        | 4        | 负数：-3.402823E+38到-1.401298E-45                                                             正数：   1.401298E-45到3.402823E+38 |\r\n|          | double(默认) | 8        | 负数：-1.797693E+308到-4.9000000E-324                                              正数：4.9000000E-324   到1.797693E+308 |\r\n| 字符类型 | char         | 2        | 0-65535                                                      |\r\n| 布尔类型 | boolean      | 1        | true，false                                                  |\r\n\r\n说明：\r\n\r\n​\te+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方。\r\n\r\n​\t在java中整数默认是int类型，浮点数默认是double类型。\r\n\r\n### 3.6 变量（应用）\r\n\r\n#### 3.6.1 变量的定义\r\n\r\n变量：在程序运行过程中，其值可以发生改变的量。\r\n\r\n从本质上讲，变量是内存中的一小块区域，其值可以在一定范围内变化。\r\n\r\n变量的定义格式：\r\n\r\n```java\r\n数据类型 变量名 = 初始化值; // 声明变量并赋值\r\nint age = 18;\r\nSystem.out.println(age);\r\n```\r\n\r\n或者(扩展)\r\n\r\n```java\r\n// 先声明，后赋值（使用前赋值即可）\r\n数据类型 变量名;\r\n变量名 = 初始化值;\r\ndouble money;\r\nmoney = 55.5;\r\nSystem.out.println(money);\r\n```\r\n\r\n还可以(扩展)\r\n\r\n在同一行定义多个同一种数据类型的变量，中间使用逗号隔开。但不建议使用这种方式，降低程序的可读性。\r\n\r\n```java\r\nint a = 10, b = 20; // 定义int类型的变量a和b，中间使用逗号隔开\r\nSystem.out.println(a);\r\nSystem.out.println(b);\r\n\r\nint c,d; // 声明int类型的变量c和d，中间使用逗号隔开\r\nc = 30;\r\nd = 40;\r\nSystem.out.println(c);\r\nSystem.out.println(d);\r\n```\r\n\r\n#### 3.6.2 变量的修改\r\n\r\n```java\r\nint a = 10;\r\na = 30;  //修改变量的值\r\nSystem.out.println(a);\r\n```\r\n\r\n变量前面不加数据类型时，表示修改已存在的变量的值。\r\n\r\n### 3.7 变量的注意事项(理解)\r\n\r\n1. 在同一对花括号中，变量名不能重复。\r\n2. 变量在使用之前，必须初始化（赋值）。\r\n3. 定义long类型的变量时，需要在整数的后面加L（大小写均可，建议大写）。因为整数默认是int类型，整数太大可能超出int范围。\r\n4. 定义float类型的变量时，需要在小数的后面加F（大小写均可，建议大写）。因为浮点数的默认类型是double， double的取值范围是大于float的，类型不兼容。\r\n\r\n### 3.8 键盘录入（理解）\r\n\r\n我们可以通过 Scanner 类来获取用户的输入。使用步骤如下：\r\n\r\n1、导包。Scanner 类在java.util包下，所以需要将该类导入。导包的语句需要定义在类的上面。\r\n\r\n```java\r\nimport java.util.Scanner; \r\n```\r\n\r\n2、创建Scanner对象。\r\n\r\n```java\r\nScanner sc = new Scanner(System.in);// 创建Scanner对象，sc表示变量名，其他均不可变\r\n```\r\n\r\n3、接收数据\r\n\r\n```java\r\nint i = sc.nextInt(); // 表示将键盘录入的值作为int数返回。\r\n```\r\n\r\n示例：\r\n\r\n```java\r\nimport java.util.Scanner;\r\npublic class ScannerDemo {\r\n\tpublic static void main(String[] args) {\r\n\t\t//创建对象\r\n\t\tScanner sc = new Scanner(System.in);\r\n\t\t//接收数据\r\n\t\tint a = sc.nextInt();\r\n\t\t//输出数据\r\n\t\tSystem.out.println(a);\r\n\t}\r\n}\r\n```\r\n\r\n### 3.9 标识符（理解）\r\n\r\n标识符是用户编程时使用的名字，用于给类、方法、变量、常量等命名。\r\n\r\nJava中标识符的组成规则：\r\n\r\n​\t由字母、数字、下划线“_”、美元符号“$”组成，第一个字符不能是数字。\r\n\r\n​\t不能使用java中的关键字作为标识符。\t\r\n\r\n​\t标识符对大小写敏感（区分大小写）。\r\n\r\nJava中标识符的命名约定：\r\n\r\n​\t小驼峰式命名：变量名、方法名\r\n\r\n​\t\t首字母小写，从第二个单词开始每个单词的首字母大写。\r\n\r\n​\t大驼峰式命名：类名\r\n\r\n​\t\t每个单词的首字母都大写。\r\n\r\n​\t另外，标识符的命名最好可以做到见名知意\r\n\r\n​\t\t例如：username、studentNumber等。\r\n\r\n"},"0fe1":function(n,e,t){"use strict";t.r(e),e["default"]='## 1.ArrayList\r\n\r\n**集合和数组的区别 :** \r\n\r\n​\t共同点：都是存储数据的容器\r\n\r\n​\t不同点：数组的容量是固定的，集合的容量是可变的\r\n\r\n### 1.1 -ArrayList的构造方法和添加方法\r\n\r\n| public ArrayList()                   | 创建一个空的集合对象               |\r\n| ------------------------------------ | ---------------------------------- |\r\n| public boolean add(E e)              | 将指定的元素追加到此集合的末尾     |\r\n| public void add(int index,E element) | 在此集合中的指定位置插入指定的元素 |\r\n\r\n**ArrayList<E> ：** \r\n\r\n​\t可调整大小的数组实现 \r\n\r\n​\t<E> : 是一种特殊的数据类型，泛型。\r\n\r\n**怎么用呢 ?**\t\r\n\r\n​\t在出现E的地方我们使用引用数据类型替换即可\t\r\n\r\n​\t举例：ArrayList<String>, ArrayList<Student>\r\n\r\n### 1.2ArrayList类常用方法【应用】\r\n\r\n**成员方法 : **\r\n\r\n| public boolean remove(Object o)   | 删除指定的元素，返回删除是否成功       |\r\n| --------------------------------- | -------------------------------------- |\r\n| public E remove(int index)        | 删除指定索引处的元素，返回被删除的元素 |\r\n| public E set(int index,E element) | 修改指定索引处的元素，返回被修改的元素 |\r\n| public E get(int index)           | 返回指定索引处的元素                   |\r\n| public int size()                 | 返回集合中的元素的个数                 |\r\n\r\n**示例代码 :** \r\n\r\n```java\r\npublic class ArrayListDemo02 {\r\n    public static void main(String[] args) {\r\n        //创建集合\r\n        ArrayList<String> array = new ArrayList<String>();\r\n\r\n        //添加元素\r\n        array.add("hello");\r\n        array.add("world");\r\n        array.add("java");\r\n\r\n        //public boolean remove(Object o)：删除指定的元素，返回删除是否成功\r\n//        System.out.println(array.remove("world"));\r\n//        System.out.println(array.remove("javaee"));\r\n\r\n        //public E remove(int index)：删除指定索引处的元素，返回被删除的元素\r\n//        System.out.println(array.remove(1));\r\n\r\n        //IndexOutOfBoundsException\r\n//        System.out.println(array.remove(3));\r\n\r\n        //public E set(int index,E element)：修改指定索引处的元素，返回被修改的元素\r\n//        System.out.println(array.set(1,"javaee"));\r\n\r\n        //IndexOutOfBoundsException\r\n//        System.out.println(array.set(3,"javaee"));\r\n\r\n        //public E get(int index)：返回指定索引处的元素\r\n//        System.out.println(array.get(0));\r\n//        System.out.println(array.get(1));\r\n//        System.out.println(array.get(2));\r\n        //System.out.println(array.get(3)); //？？？？？？ 自己测试\r\n\r\n        //public int size()：返回集合中的元素的个数\r\n        System.out.println(array.size());\r\n\r\n        //输出集合\r\n        System.out.println("array:" + array);\r\n    }\r\n}\r\n```\r\n\r\n### 1.3 ArrayList存储字符串并遍历\r\n\r\n**案例需求 :** \r\n\r\n​\t创建一个存储字符串的集合，存储3个字符串元素，使用程序实现在控制台遍历该集合\r\n\r\n**实现步骤 :** \r\n\r\n \t1:创建集合对象\r\n        2:往集合中添加字符串对象\r\n        3:遍历集合，首先要能够获取到集合中的每一个元素，这个通过get(int index)方法实现\r\n        4:遍历集合，其次要能够获取到集合的长度，这个通过size()方法实现\r\n        5:遍历集合的通用格式\r\n\r\n**代码实现 :** \r\n\r\n```java\r\n/*\r\n    思路：\r\n        1:创建集合对象\r\n        2:往集合中添加字符串对象\r\n        3:遍历集合，首先要能够获取到集合中的每一个元素，这个通过get(int index)方法实现\r\n        4:遍历集合，其次要能够获取到集合的长度，这个通过size()方法实现\r\n        5:遍历集合的通用格式\r\n */\r\npublic class ArrayListTest01 {\r\n    public static void main(String[] args) {\r\n        //创建集合对象\r\n        ArrayList<String> array = new ArrayList<String>();\r\n\r\n        //往集合中添加字符串对象\r\n        array.add("刘正风");\r\n        array.add("左冷禅");\r\n        array.add("风清扬");\r\n\r\n        //遍历集合，其次要能够获取到集合的长度，这个通过size()方法实现\r\n//        System.out.println(array.size());\r\n\r\n        //遍历集合的通用格式\r\n        for(int i=0; i<array.size(); i++) {\r\n            String s = array.get(i);\r\n            System.out.println(s);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 1.4 ArrayList存储学生对象并遍历\r\n\r\n**案例需求 :** \r\n\r\n​\t创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合\r\n\r\n**实现步骤 : ** \r\n\r\n​\t1:定义学生类    \r\n\r\n​\t2:创建集合对象    \r\n\r\n​\t3:创建学生对象    \r\n\r\n​\t4:添加学生对象到集合中    \r\n\r\n​\t5:遍历集合，采用通用遍历格式实现\r\n\r\n**代码实现 :**\r\n\r\n```java\r\n/*\r\n    思路：\r\n        1:定义学生类\r\n        2:创建集合对象\r\n        3:创建学生对象\r\n        4:添加学生对象到集合中\r\n        5:遍历集合，采用通用遍历格式实现\r\n */\r\npublic class ArrayListTest02 {\r\n    public static void main(String[] args) {\r\n        //创建集合对象\r\n        ArrayList<Student> array = new ArrayList<>();\r\n\r\n        //创建学生对象\r\n        Student s1 = new Student("林青霞", 30);\r\n        Student s2 = new Student("风清扬", 33);\r\n        Student s3 = new Student("张曼玉", 18);\r\n\r\n        //添加学生对象到集合中\r\n        array.add(s1);\r\n        array.add(s2);\r\n        array.add(s3);\r\n\r\n        //遍历集合，采用通用遍历格式实现\r\n        for (int i = 0; i < array.size(); i++) {\r\n            Student s = array.get(i);\r\n            System.out.println(s.getName() + "," + s.getAge());\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 1.5 键盘录入学生信息到集合\r\n\r\n**案例需求 :** \r\n\r\n​\t创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合\r\n\r\n​        学生的姓名和年龄来自于键盘录入\r\n\r\n**实现步骤 :**\r\n\r\n​\t1:定义学生类，为了键盘录入数据方便，把学生类中的成员变量都定义为String类型    \r\n\r\n​\t2:创建集合对象    \r\n\r\n​\t3:键盘录入学生对象所需要的数据    \r\n\r\n​\t4:创建学生对象，把键盘录入的数据赋值给学生对象的成员变量    \r\n\r\n​\t5:往集合中添加学生对象    \r\n\r\n​\t6:遍历集合，采用通用遍历格式实现\r\n\r\n**代码实现 :** \r\n\r\n```java\r\n/*\r\n    思路：\r\n        1:定义学生类，为了键盘录入数据方便，把学生类中的成员变量都定义为String类型\r\n        2:创建集合对象\r\n        3:键盘录入学生对象所需要的数据\r\n        4:创建学生对象，把键盘录入的数据赋值给学生对象的成员变量\r\n        5:往集合中添加学生对象\r\n        6:遍历集合，采用通用遍历格式实现\r\n */\r\npublic class ArrayListTest {\r\n    public static void main(String[] args) {\r\n        //创建集合对象\r\n        ArrayList<Student> array = new ArrayList<Student>();\r\n\r\n        //为了提高代码的复用性，我们用方法来改进程序\r\n        addStudent(array);\r\n        addStudent(array);\r\n        addStudent(array);\r\n\r\n        //遍历集合，采用通用遍历格式实现\r\n        for (int i = 0; i < array.size(); i++) {\r\n            Student s = array.get(i);\r\n            System.out.println(s.getName() + "," + s.getAge());\r\n        }\r\n    }\r\n\r\n    /*\r\n        两个明确：\r\n            返回值类型：void\r\n            参数：ArrayList<Student> array\r\n     */\r\n    public static void addStudent(ArrayList<Student> array) {\r\n        //键盘录入学生对象所需要的数据\r\n        Scanner sc = new Scanner(System.in);\r\n\r\n        System.out.println("请输入学生姓名:");\r\n        String name = sc.nextLine();\r\n\r\n        System.out.println("请输入学生年龄:");\r\n        String age = sc.nextLine();\r\n\r\n        //创建学生对象，把键盘录入的数据赋值给学生对象的成员变量\r\n        Student s = new Student();\r\n        s.setName(name);\r\n        s.setAge(age);\r\n\r\n        //往集合中添加学生对象\r\n        array.add(s);\r\n    }\r\n}\r\n```\r\n\r\n## 2. 学生管理系统\r\n\r\n### 2.1 学生管理系统实现步骤\r\n\r\n- **案例需求**\r\n\r\n  ​\t针对目前我们的所学内容，完成一个综合案例：学生管理系统！该系统主要功能如下：\r\n\r\n  ​\t添加学生：通过键盘录入学生信息，添加到集合中\r\n\r\n  ​\t删除学生：通过键盘录入要删除学生的学号，将该学生对象从集合中删除\r\n\r\n  ​\t修改学生：通过键盘录入要修改学生的学号，将该学生对象其他信息进行修改\r\n\r\n  ​\t查看学生：将集合中的学生对象信息进行展示\r\n\r\n  ​\t退出系统：结束程序\r\n\r\n- **实现步骤**\r\n\r\n  1. 定义学生类，包含以下成员变量\r\n\r\n     学生类：\tStudent成员变量：\t\r\n\r\n     ​\t学号：sid\t\r\n\r\n     ​\t姓名：name\t\r\n\r\n     ​\t年龄：age\t\r\n\r\n     ​\t生日：birthday\r\n\r\n     ​\t构造方法：\t\r\n\r\n     ​\t\t无参构造\t\r\n\r\n     ​\t\t带四个参数的构造成员方法：\t\r\n\r\n     ​\t每个成员变量对应给出get/set方法\r\n\r\n  2. 学生管理系统主界面的搭建步骤\r\n\r\n     2.1 用输出语句完成主界面的编写\r\n\r\n     2.2 用Scanner实现键盘录入数据\r\n\r\n     2.3 用switch语句完成操作的选择\r\n\r\n     2.4 用循环完成再次回到主界面\r\n\r\n  3. 学生管理系统的添加学生功能实现步骤\r\n\r\n     3.1 用键盘录入选择添加学生\r\n\r\n     3.2 定义一个方法，用于添加学生\r\n\r\n     ​\t显示提示信息，提示要输入何种信息\r\n\r\n     ​\t键盘录入学生对象所需要的数据\r\n\r\n     ​\t创建学生对象，把键盘录入的数据赋值给学生对象的成员变量\r\n\r\n     ​\t将学生对象添加到集合中（保存）\r\n\r\n     ​\t给出添加成功提示\r\n\r\n     3.3 调用方法\r\n\r\n  4. 学生管理系统的查看学生功能实现步骤\r\n\r\n     4.1 用键盘录入选择查看所有学生信息\r\n\r\n     4.2 定义一个方法，用于查看学生信息\r\n\r\n     ​\t显示表头信息\r\n\r\n     ​\t将集合中数据取出按照对应格式显示学生信息，年龄显示补充“岁”\r\n\r\n     4.3 调用方法\r\n\r\n  5. 学生管理系统的删除学生功能实现步骤\r\n\r\n     5.1 用键盘录入选择删除学生信息\r\n\r\n     5.2 定义一个方法，用于删除学生信息\r\n\r\n     ​\t显示提示信息\r\n\r\n     ​\t键盘录入要删除的学生学号\r\n\r\n     ​\t调用getIndex方法，查找该学号在集合的索引\r\n\r\n     ​\t如果索引为-1，提示信息不存在\r\n\r\n     ​\t如果索引不是-1，调用remove方法删除并提示删除成功\r\n\r\n     5.3 调用方法\r\n\r\n  6. 学生管理系统的修改学生功能实现步骤\r\n\r\n     6.1 用键盘录入选择修改学生信息\r\n\r\n     6.2 定义一个方法，用于修改学生信息\r\n\r\n     ​\t显示提示信息\r\n\r\n     ​\t键盘录入要修改的学生学号\r\n\r\n     ​\t调用getIndex方法，查找该学号在集合的索引\r\n\r\n     ​\t如果索引为-1，提示信息不存在\r\n\r\n     ​\t如果索引不是-1，键盘录入要修改的学生信息\r\n\r\n     ​\t集合修改对应的学生信息\r\n\r\n     ​\t给出修改成功提示\r\n\r\n     6.3 调用方法\r\n\r\n  7. 退出系统\r\n\r\n     使用System.exit(0);退出JVM\r\n\r\n### 2.2 学生类的定义\r\n\r\n```java\r\npackage com.itheima.domain;\r\n\r\npublic class Student {\r\n    private String sid; // 学号\r\n    private String name; // 姓名\r\n    private int age; // 年龄\r\n    private String birthday; // 生日\r\n\r\n    public Student() {\r\n    }\r\n\r\n    public Student(String sid, String name, int age, String birthday) {\r\n        this.sid = sid;\r\n        this.name = name;\r\n        this.age = age;\r\n        this.birthday = birthday;\r\n    }\r\n\r\n    public String getSid() {\r\n        return sid;\r\n    }\r\n\r\n    public void setSid(String sid) {\r\n        this.sid = sid;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public String getBirthday() {\r\n        return birthday;\r\n    }\r\n\r\n    public void setBirthday(String birthday) {\r\n        this.birthday = birthday;\r\n    }\r\n}\r\n```\r\n\r\n### 2.3 测试类的定义\r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\nimport com.itheima.domain.Student;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Scanner;\r\n\r\npublic class StudentManager {\r\n    public static void main(String[] args) {\r\n\r\n        Scanner sc = new Scanner(System.in);\r\n\r\n        // 创建集合容器对象\r\n        ArrayList<Student> list = new ArrayList<>();\r\n\r\n        lo:\r\n        while (true) {\r\n            // 1. 搭建主界面菜单\r\n            System.out.println("--------欢迎来到学生管理系统--------");\r\n            System.out.println("1 添加学生");\r\n            System.out.println("2 删除学生");\r\n            System.out.println("3 修改学生");\r\n            System.out.println("4 查看学生");\r\n            System.out.println("5 退出");\r\n            System.out.println("请输入您的选择:");\r\n\r\n            String choice = sc.next();\r\n\r\n            switch (choice) {\r\n                case "1":\r\n                    //System.out.println("添加学生");\r\n                    addStudent(list);\r\n                    break;\r\n                case "2":\r\n                    //System.out.println("删除学生");\r\n                    deleteStudent(list);\r\n                    break;\r\n                case "3":\r\n                    //System.out.println("修改学生");\r\n                    updateStudent(list);\r\n                    break;\r\n                case "4":\r\n                    // System.out.println("查看学生");\r\n                    queryStudents(list);\r\n                    break;\r\n                case "5":\r\n                    System.out.println("感谢您的使用");\r\n                    break lo;\r\n                default:\r\n                    System.out.println("您的输入有误");\r\n                    break;\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    // 修改学生的方法\r\n    public static void updateStudent(ArrayList<Student> list) {\r\n        System.out.println("请输入您要修改的学生学号:");\r\n        Scanner sc = new Scanner(System.in);\r\n        String updateSid = sc.next();\r\n        // 3. 调用getIndex方法, 查找该学号在集合中出现的索引位置\r\n        int index = getIndex(list,updateSid);\r\n        // 4. 根据索引判断, 学号在集合中是否存在\r\n        if(index == -1){\r\n            // 不存在: 给出提示\r\n            System.out.println("查无信息, 请重新输入");\r\n        }else{\r\n            // 存在: 接收新的学生信息\r\n            System.out.println("请输入新的学生姓名:");\r\n            String name = sc.next();\r\n            System.out.println("请输入新的学生年龄:");\r\n            int age = sc.nextInt();\r\n            System.out.println("请输入新的学生生日:");\r\n            String birthday = sc.next();\r\n            // 封装为新的学生对象\r\n            Student stu = new Student(updateSid, name, age, birthday);\r\n            // 调用集合的set方法, 完成修改\r\n            list.set(index, stu);\r\n            System.out.println("修改成功!");\r\n        }\r\n    }\r\n\r\n    // 删除学生的方法\r\n    public static void deleteStudent(ArrayList<Student> list) {\r\n        // 1. 给出提示信息 (请输入您要删除的学号)\r\n        System.out.println("请输入您要删除的学生学号:");\r\n        // 2. 键盘接收要删除的学号\r\n        Scanner sc = new Scanner(System.in);\r\n        String deleteSid = sc.next();\r\n        // 3. 调用getIndex方法, 查找该学号在集合中出现的索引位置\r\n        int index = getIndex(list,deleteSid);\r\n        // 4. 根据索引判断, 学号在集合中是否存在\r\n        if(index == -1){\r\n            // 不存在: 给出提示\r\n            System.out.println("查无信息, 请重新输入");\r\n        }else{\r\n            // 存在:删除\r\n            list.remove(index);\r\n            System.out.println("删除成功!");\r\n        }\r\n    }\r\n\r\n    // 查看学生的方法\r\n    public static void queryStudents(ArrayList<Student> list) {\r\n        // 1. 判断集合中是否存在数据, 如果不存在直接给出提示\r\n        if(list.size() == 0){\r\n            System.out.println("无信息, 请添加后重新查询");\r\n            return;\r\n        }\r\n        // 2. 存在: 展示表头数据\r\n        System.out.println("学号\\t\\t姓名\\t年龄\\t生日");\r\n        // 3. 遍历集合, 获取每一个学生对象的信息, 打印在控制台\r\n        for (int i = 0; i < list.size(); i++) {\r\n            Student stu = list.get(i);\r\n            System.out.println(stu.getSid() + "\\t" + stu.getName() + "\\t" + stu.getAge() + "\\t\\t" + stu.getBirthday());\r\n        }\r\n    }\r\n\r\n    // 添加学生的方法\r\n    public static void addStudent(ArrayList<Student> list) {\r\n        Scanner sc = new Scanner(System.in);\r\n        // 1. 给出录入的提示信息\r\n\r\n        String sid;\r\n\r\n        while(true){\r\n            System.out.println("请输入学号:");\r\n            sid = sc.next();\r\n\r\n            int index = getIndex(list, sid);\r\n\r\n            if(index == -1){\r\n                // sid不存在, 学号可以使用\r\n                break;\r\n            }\r\n        }\r\n\r\n        System.out.println("请输入姓名:");\r\n        String name = sc.next();\r\n        System.out.println("请输入年龄:");\r\n        int age = sc.nextInt();\r\n        System.out.println("请输入生日:");\r\n        String birthday = sc.next();\r\n        // 2. 将键盘录入的信息封装为学生对象\r\n        Student stu = new Student(sid,name,age,birthday);\r\n        // 3. 将封装好的学生对象, 添加到集合容器当中\r\n        list.add(stu);\r\n        // 4. 给出添加成功的提示信息\r\n        System.out.println("添加成功!");\r\n    }\r\n\r\n    /*\r\n        getIndex : 接收一个集合对象, 接收一个学生学号\r\n\r\n        查找这个学号, 在集合中出现的索引位置\r\n     */\r\n    public static int getIndex(ArrayList<Student> list, String sid){\r\n        // 1. 假设传入的学号, 在集合中不存在\r\n        int index = -1;\r\n        // 2. 遍历集合, 获取每一个学生对象, 准备进行查找\r\n        for (int i = 0; i < list.size(); i++) {\r\n            Student stu = list.get(i);\r\n            // 3. 获取每一个学生对象的学号\r\n            String id = stu.getSid();\r\n            // 4. 使用获取出的学生学号, 和传入的学号(查找的学号)进行比对\r\n            if(id.equals(sid)){\r\n                // 存在: 让index变量记录正确的索引位置\r\n                index = i;\r\n            }\r\n        }\r\n\r\n        return index;\r\n    }\r\n}\r\n```\r\n'},1052:function(n,e,t){"use strict";t.r(e),e["default"]='这篇文章是我根据官方文档以及自己平时的使用情况，对 Dubbo 所做的一个总结。欢迎补充！\n\n## RPC基础\n\n### 何为 RPC?\n\n**RPC（Remote Procedure Call）** 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。\n\n**为什么要 RPC  ？** 因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也需要通过网络编程来接收。但是，如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的，因为，我们需要考虑底层传输方式（TCP还是UDP）、序列化方式等等方面。\n\n\n**RPC 能帮助我们做什么呢？** 简单来说，通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。并且！我们不需要了解底层网络编程的具体细节。\n\n\n举个例子：两个不同的服务 A、B 部署在两台不同的机器上，服务 A 如果想要调用服务 B 中的某个方法的话就可以通过 RPC 来做。\n\n一言蔽之：**RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单。**\n\n### RPC 的原理是什么?\n\n为了能够帮助小伙伴们理解 RPC 原理，我们可以将整个 RPC的 核心功能看作是下面👇 6 个部分实现的：\n\n\n1. **客户端（服务消费端）** ：调用远程方法的一端。\n1. **客户端 Stub（桩）** ： 这其实就是一代理类。代理类主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端。\n1. **网络传输** ： 网络传输就是你要把你调用的方法的信息比如说参数啊这些东西传输到服务端，然后服务端执行完之后再把返回结果通过网络传输给你传输回来。网络传输的实现方式有很多种比如最近基本的 Socket或者性能以及封装更加优秀的 Netty（推荐）。\n1. **服务端 Stub（桩）** ：这个桩就不是代理类了。我觉得理解为桩实际不太好，大家注意一下就好。这里的服务端 Stub 实际指的就是接收到客户端执行方法的请求后，去指定对应的方法然后返回结果给客户端的类。\n1. **服务端（服务提供端）** ：提供远程方法的一端。\n\n具体原理图如下，后面我会串起来将整个RPC的过程给大家说一下。\n\n\n![RPC原理图](Dubbo.assets/37345851.jpg)\n\n1. 服务消费端（client）以本地调用的方式调用远程服务；\n1. 客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：`RpcRequest`；\n1. 客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；\n1. 服务端 Stub（桩）收到消息将消息反序列化为Java对象: `RpcRequest`；\n1. 服务端 Stub（桩）根据`RpcRequest`中的类、方法、方法参数等信息调用本地的方法；\n1. 服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：`RpcResponse`（序列化）发送至消费方；\n1. 客户端 Stub（client stub）接收到消息并将消息反序列化为Java对象:`RpcResponse` ，这样也就得到了最终结果。over!\n\n相信小伙伴们看完上面的讲解之后，已经了解了 RPC 的原理。\n\n虽然篇幅不多，但是基本把 RPC 框架的核心原理讲清楚了！另外，对于上面的技术细节，我会在后面的章节介绍到。\n\n**最后，对于 RPC 的原理，希望小伙伴不单单要理解，还要能够自己画出来并且能够给别人讲出来。因为，在面试中这个问题在面试官问到 RPC 相关内容的时候基本都会碰到。**\n\n## Dubbo基础\n\n### 什么是 Dubbo?\n\n![](Dubbo.assets/427f2168-1930-4c14-8760-415fac8db1d0-20200802184737978.png)\n\n[Apache Dubbo](https://github.com/apache/dubbo) |ˈdʌbəʊ|  是一款高性能、轻量级的开源 Java RPC 框架。\n\n根据 [Dubbo 官方文档](https://dubbo.apache.org/zh/)的介绍，Dubbo 提供了六大核心能力\n\n1. 面向接口代理的高性能RPC调用。\n2. 智能容错和负载均衡。\n3. 服务自动注册和发现。\n4. 高度可扩展能力。\n5. 运行期流量调度。\n6. 可视化的服务治理与运维。\n\n![Dubbo提供的六大核心能力](Dubbo.assets/dubbo提供的六大核心能力.png)\n\n简单来说就是： **Dubbo 不光可以帮助我们调用远程服务，还提供了一些其他开箱即用的功能比如智能负载均衡。**\n\nDubbo 目前已经有接近 34.4 k 的 Star  。 \n\n在 **2020 年度 OSC 中国开源项目** 评选活动中，Dubbo 位列开发框架和基础组件类项目的第7名。想比几年前来说，热度和排名有所下降。\n\n![](Dubbo.assets/image-20210107153159545.png)\n\nDubbo 是由阿里开源，后来加入了 Apache 。正式由于 Dubbo 的出现，才使得越来越多的公司开始使用以及接受分布式架构。\n\n### 为什么要用 Dubbo?\n\n随着互联网的发展，网站的规模越来越大，用户数量越来越多。单一应用架构 、垂直应用架构无法满足我们的需求，这个时候分布式服务架构就诞生了。\n\n分布式服务架构下，系统被拆分成不同的服务比如短信服务、安全服务，每个服务独立提供系统的某个核心服务。\n\n我们可以使用 Java RMI（Java Remote Method Invocation）、Hessian这种支持远程调用的框架来简单地暴露和引用远程服务。但是！当服务越来越多之后，服务调用关系越来越复杂。当应用访问压力越来越大后，负载均衡以及服务监控的需求也迫在眉睫。我们可以用 F5 这类硬件来做负载均衡，但这样增加了成本，并且存在单点故障的风险。\n\n不过，Dubbo 的出现让上述问题得到了解决。**Dubbo 帮助我们解决了什么问题呢？**\n\n1. **负载均衡** ： 同一个服务部署在不同的机器时该调用哪一台机器上的服务。\n2. **服务调用链路生成**  ： 随着系统的发展，服务越来越多，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。Dubbo 可以为我们解决服务之间互相是如何调用的。\n3. **服务访问压力以及时长统计、资源调度和治理** ：基于访问压力实时管理集群容量，提高集群利用率。\n4. ......\n\n![](Dubbo.assets/43050183.jpg)\n\n另外，Dubbo 除了能够应用在分布式系统中，也可以应用在现在比较火的微服务系统中。不过，由于 Spring Cloud 在微服务中应用更加广泛，所以，我觉得一般我们提 Dubbo 的话，大部分是分布式系统的情况。\n\n**我们刚刚提到了分布式这个概念，下面再给大家介绍一下什么是分布式？为什么要分布式？**\n\n## 分布式基础\n\n### 什么是分布式?\n\n分布式或者说 SOA 分布式重要的就是面向服务，说简单的分布式就是我们把整个系统拆分成不同的服务然后将这些服务放在不同的服务器上减轻单体服务的压力提高并发量和性能。比如电商系统可以简单地拆分成订单系统、商品系统、登录系统等等，拆分之后的每个服务可以部署在不同的机器上，如果某一个服务的访问量比较大的话也可以将这个服务同时部署在多台机器上。\n\n![分布式事务示意图](Dubbo.assets/分布式事务示意图.png)\n\n### 为什么要分布式?\n\n从开发角度来讲单体应用的代码都集中在一起，而分布式系统的代码根据业务被拆分。所以，每个团队可以负责一个服务的开发，这样提升了开发效率。另外，代码根据业务拆分之后更加便于维护和扩展。\n\n另外，我觉得将系统拆分成分布式之后不光便于系统扩展和维护，更能提高整个系统的性能。你想一想嘛？把整个系统拆分成不同的服务/系统，然后每个服务/系统 单独部署在一台服务器上，是不是很大程度上提高了系统性能呢？\n\n## Dubbo 架构\n\n### Dubbo 架构中的核心角色有哪些？\n\n[官方文档中的框架设计章节](https://dubbo.apache.org/zh/docs/v2.7/dev/design/) 已经介绍的非常详细了，我这里把一些比较重要的点再提一下。\n\n![dubbo-relation](Dubbo.assets/dubbo-relation.jpg)\n\n上述节点简单介绍以及他们之间的关系：\n\n- **Container：** 服务运行容器，负责加载、运行服务提供者。必须。\n- **Provider：** 暴露服务的服务提供方，会向注册中心注册自己提供的服务。必须。\n- **Consumer：** 调用远程服务的服务消费方，会向注册中心订阅自己所需的服务。必须。\n- **Registry：** 服务注册与发现的注册中心。注册中心会返回服务提供者地址列表给消费者。非必须。\n- **Monitor：** 统计服务的调用次数和调用时间的监控中心。服务消费者和提供者会定时发送统计数据到监控中心。 非必须。\n\n### Dubbo 中的 Invoker 概念了解么？\n\n`Invoker` 是 Dubbo 领域模型中非常重要的一个概念，你如果阅读过 Dubbo 源码的话，你会无数次看到这玩意。就比如下面我要说的负载均衡这块的源码中就有大量 `Invoker` 的身影。\n\n简单来说，`Invoker` 就是 Dubbo 对远程调用的抽象。\n\n![dubbo_rpc_invoke.jpg](Dubbo.assets/dubbo_rpc_invoke.jpg)\n\n按照 Dubbo 官方的话来说，`Invoker`  分为\n\n- 服务提供 `Invoker` \n- 服务消费 `Invoker`\n\n假如我们需要调用一个远程方法，我们需要动态代理来屏蔽远程调用的细节吧！我们屏蔽掉的这些细节就依赖对应的 `Invoker`  实现， `Invoker` 实现了真正的远程服务调用。\n\n### Dubbo 的工作原理了解么？\n\n下图是 Dubbo 的整体设计，从下至上分为十层，各层均为单向依赖。\n\n> 左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。\n\n![dubbo-framework](Dubbo.assets/dubbo-framework.jpg)\n\n- **config 配置层**：Dubbo相关的配置。支持代码配置，同时也支持基于 Spring  来做配置，以 `ServiceConfig`, `ReferenceConfig` 为中心\n- **proxy 服务代理层**：调用远程方法像调用本地的方法一样简单的一个关键，真实调用过程依赖代理类，以 `ServiceProxy` 为中心。\n- **registry 注册中心层**：封装服务地址的注册与发现。\n- **cluster 路由层**：封装多个提供者的路由及负载均衡，并桥接注册中心，以 `Invoker` 为中心。\n- **monitor 监控层**：RPC 调用次数和调用时间监控，以 `Statistics` 为中心。\n- **protocol 远程调用层**：封装 RPC 调用，以 `Invocation`, `Result` 为中心。\n- **exchange 信息交换层**：封装请求响应模式，同步转异步，以 `Request`, `Response` 为中心。\n- **transport 网络传输层**：抽象 mina 和 netty 为统一接口，以 `Message` 为中心。\n- **serialize 数据序列化层** ：对需要在网络传输的数据进行序列化。\n\n### Dubbo 的 SPI 机制了解么？ 如何扩展 Dubbo 中的默认实现？\n\nSPI（Service Provider Interface） 机制被大量用在开源项目中，它可以帮助我们动态寻找服务/功能（比如负载均衡策略）的实现。\n\nSPI 的具体原理是这样的：我们将接口的实现类放在配置文件中，我们在程序运行过程中读取配置文件，通过反射加载实现类。这样，我们可以在运行的时候，动态替换接口的实现类。和 IoC 的解耦思想是类似的。\n\nJava 本身就提供了 SPI 机制的实现。不过，Dubbo 没有直接用，而是对 Java原生的 SPI机制进行了增强，以便更好满足自己的需求。\n\n**那我们如何扩展 Dubbo 中的默认实现呢？**\n\n比如说我们想要实现自己的负载均衡策略，我们创建对应的实现类 `XxxLoadBalance` 实现 `LoadBalance` 接口或者 `AbstractLoadBalance` 类。\n\n```java\npackage com.xxx;\n \nimport org.apache.dubbo.rpc.cluster.LoadBalance;\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.Invocation;\nimport org.apache.dubbo.rpc.RpcException; \n \npublic class XxxLoadBalance implements LoadBalance {\n    public <T> Invoker<T> select(List<Invoker<T>> invokers, Invocation invocation) throws RpcException {\n        // ...\n    }\n}\n```\n\n我们将这个实现类的路径写入到`resources` 目录下的 `META-INF/dubbo/org.apache.dubbo.rpc.cluster.LoadBalance`文件中即可。\n\n```java\nsrc\n |-main\n    |-java\n        |-com\n            |-xxx\n                |-XxxLoadBalance.java (实现LoadBalance接口)\n    |-resources\n        |-META-INF\n            |-dubbo\n                |-org.apache.dubbo.rpc.cluster.LoadBalance (纯文本文件，内容为：xxx=com.xxx.XxxLoadBalance)\n```\n\n`org.apache.dubbo.rpc.cluster.LoadBalance` \n\n```\nxxx=com.xxx.XxxLoadBalance\n```\n\n其他还有很多可供扩展的选择，你可以在[官方文档@SPI扩展实现](https://dubbo.apache.org/zh/docs/v2.7/dev/impls/)这里找到。\n\n![](Dubbo.assets/20210328091015555.png)\n\n### Dubbo 的微内核架构了解吗？\n\nDubbo 采用 微内核（Microkernel） + 插件（Plugin） 模式，简单来说就是微内核架构。微内核只负责组装插件。\n\n**何为微内核架构呢？** 《软件架构模式》 这本书是这样介绍的：\n\n> 微内核架构模式（有时被称为插件架构模式）是实现基于产品应用程序的一种自然模式。基于产品的应用程序是已经打包好并且拥有不同版本，可作为第三方插件下载的。然后，很多公司也在开发、发布自己内部商业应用像有版本号、说明及可加载插件式的应用软件（这也是这种模式的特征）。微内核系统可让用户添加额外的应用如插件，到核心应用，继而提供了可扩展性和功能分离的用法。\n\n微内核架构包含两类组件：**核心系统（core system）** 和 **插件模块（plug-in modules）**。\n\n![](Dubbo.assets/微内核架构示意图.png)\n\n核心系统提供系统所需核心能力，插件模块可以扩展系统的功能。因此， 基于微内核架构的系统，非常易于扩展功能。\n\n我们常见的一些IDE，都可以看作是基于微内核架构设计的。绝大多数 IDE比如IDEA、VSCode都提供了插件来丰富自己的功能。\n\n正是因为Dubbo基于微内核架构，才使得我们可以随心所欲替换Dubbo的功能点。比如你觉得Dubbo 的序列化模块实现的不满足自己要求，没关系啊！你自己实现一个序列化模块就好了啊！\n\n通常情况下，微核心都会采用 Factory、IoC、OSGi 等方式管理插件生命周期。Dubbo 不想依赖 Spring 等 IoC 容器，也不想自己造一个小的 IoC 容器（过度设计），因此采用了一种最简单的 Factory 方式管理插件 ：**JDK 标准的 SPI 扩展机制** （`java.util.ServiceLoader`）。\n\n### 关于Dubbo架构的一些自测小问题\n\n#### 注册中心的作用了解么？\n\n注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互。\n\n#### 服务提供者宕机后，注册中心会做什么？\n\n注册中心会立即推送事件通知消费者。\n\n#### 监控中心的作用呢？\n\n监控中心负责统计各服务调用次数，调用时间等。\n\n#### 注册中心和监控中心都宕机的话，服务都会挂掉吗？\n\n不会。两者都宕机也不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表。注册中心和监控中心都是可选的，服务消费者可以直连服务提供者。\n\n\n## Dubbo 的负载均衡策略\n\n### 什么是负载均衡？\n\n先来看一下稍微官方点的解释。下面这段话摘自维基百科对负载均衡的定义：\n\n> 负载均衡改善了跨多个计算资源（例如计算机，计算机集群，网络链接，中央处理单元或磁盘驱动）的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间，并避免任何单个资源的过载。使用具有负载平衡而不是单个组件的多个组件可以通过冗余提高可靠性和可用性。负载平衡通常涉及专用软件或硬件。\n\n**上面讲的大家可能不太好理解，再用通俗的话给大家说一下。**\n\n我们的系统中的某个服务的访问量特别大，我们将这个服务部署在了多台服务器上，当客户端发起请求的时候，多台服务器都可以处理这个请求。那么，如何正确选择处理该请求的服务器就很关键。假如，你就要一台服务器来处理该服务的请求，那该服务部署在多台服务器的意义就不复存在了。负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题，我们从负载均衡的这四个字就能明显感受到它的意义。\n\n### Dubbo 提供的负载均衡策略有哪些？\n\n在集群负载均衡时，Dubbo 提供了多种均衡策略，默认为 `random` 随机调用。我们还可以自行扩展负载均衡策略（参考Dubbo SPI机制）。\n\n在 Dubbo 中，所有负载均衡实现类均继承自 `AbstractLoadBalance`，该类实现了 `LoadBalance` 接口，并封装了一些公共的逻辑。\n\n```java\npublic abstract class AbstractLoadBalance implements LoadBalance {\n\n    static int calculateWarmupWeight(int uptime, int warmup, int weight) {\n    }\n\n    @Override\n    public <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n    }\n\n    protected abstract <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation);\n\n\n    int getWeight(Invoker<?> invoker, Invocation invocation) {\n\n    }\n}\n```\n\n`AbstractLoadBalance` 的实现类有下面这些：\n\n![](Dubbo.assets/image-20210326105257812.png)\n\n官方文档对负载均衡这部分的介绍非常详细，推荐小伙伴们看看，地址：[https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/#m-zhdocsv27devsourceloadbalance](https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/#m-zhdocsv27devsourceloadbalance ) 。\n\n####  RandomLoadBalance\n\n根据权重随机选择（对加权随机算法的实现）。这是Dubbo默认采用的一种负载均衡策略。\n\n` RandomLoadBalance` 具体的实现原理非常简单，假如有两个提供相同服务的服务器 S1,S2，S1的权重为7，S2的权重为3。\n\n我们把这些权重值分布在坐标区间会得到：S1->[0, 7) ，S2->[7, 10)。我们生成[0, 10) 之间的随机数，随机数落到对应的区间，我们就选择对应的服务器来处理请求。\n\n![RandomLoadBalance](Dubbo.assets/ RandomLoadBalance.png)\n\n`RandomLoadBalance` 的源码非常简单，简单花几分钟时间看一下。\n\n> 以下源码来自 Dubbo master 分支上的最新的版本 2.7.9。\n\n```java\npublic class RandomLoadBalance extends AbstractLoadBalance {\n\n    public static final String NAME = "random";\n\n    @Override\n    protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n\n        int length = invokers.size();\n        boolean sameWeight = true;\n        int[] weights = new int[length]; \n        int totalWeight = 0;\n        // 下面这个for循环的主要作用就是计算所有该服务的提供者的权重之和 totalWeight（），\n        // 除此之外，还会检测每个服务提供者的权重是否相同\n        for (int i = 0; i < length; i++) {\n            int weight = getWeight(invokers.get(i), invocation);\n            totalWeight += weight;\n            weights[i] = totalWeight;\n            if (sameWeight && totalWeight != weight * (i + 1)) {\n                sameWeight = false;\n            }\n        }\n        if (totalWeight > 0 && !sameWeight) {\n            // 随机生成一个 [0, totalWeight) 区间内的数字\n            int offset = ThreadLocalRandom.current().nextInt(totalWeight);\n            // 判断会落在哪个服务提供者的区间\n            for (int i = 0; i < length; i++) {\n                if (offset < weights[i]) {\n                    return invokers.get(i);\n                }\n            }\n  \n        return invokers.get(ThreadLocalRandom.current().nextInt(length));\n    }\n\n}\n\n```\n\n####  LeastActiveLoadBalance\n\n`LeastActiveLoadBalance` 直译过来就是**最小活跃数负载均衡**。\n\n这个名字起得有点不直观，不仔细看官方对活跃数的定义，你压根不知道这玩意是干嘛的。\n\n我这么说吧！初始状态下所有服务提供者的活跃数均为 0（每个服务提供者的中特定方法都对应一个活跃数，我在后面的源码中会提到），每收到一个请求后，对应的服务提供者的活跃数 +1，当这个请求处理完之后，活跃数 -1。\n\n因此，**Dubbo 就认为谁的活跃数越少，谁的处理速度就越快，性能也越好，这样的话，我就优先把请求给活跃数少的服务提供者处理。**\n\n**如果有多个服务提供者的活跃数相等怎么办？**\n\n很简单，那就再走一遍  `RandomLoadBalance` 。\n\n```java\npublic class LeastActiveLoadBalance extends AbstractLoadBalance {\n\n    public static final String NAME = "leastactive";\n\n    @Override\n    protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n        int length = invokers.size();\n        int leastActive = -1;\n        int leastCount = 0;\n        int[] leastIndexes = new int[length];\n        int[] weights = new int[length];\n        int totalWeight = 0;\n        int firstWeight = 0;\n        boolean sameWeight = true;\n        // 这个 for 循环的主要作用是遍历 invokers 列表，找出活跃数最小的 Invoker\n        // 如果有多个 Invoker 具有相同的最小活跃数，还会记录下这些 Invoker 在 invokers 集合中的下标，并累加它们的权重，比较它们的权重值是否相等\n        for (int i = 0; i < length; i++) {\n            Invoker<T> invoker = invokers.get(i);\n            // 获取 invoker 对应的活跃(active)数\n            int active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive();\n            int afterWarmup = getWeight(invoker, invocation);\n            weights[i] = afterWarmup;\n            if (leastActive == -1 || active < leastActive) {\n                leastActive = active;\n                leastCount = 1;\n                leastIndexes[0] = i;\n                totalWeight = afterWarmup;\n                firstWeight = afterWarmup;\n                sameWeight = true;\n            } else if (active == leastActive) {\n                leastIndexes[leastCount++] = i;\n                totalWeight += afterWarmup;\n                if (sameWeight && afterWarmup != firstWeight) {\n                    sameWeight = false;\n                }\n            }\n        }\n       // 如果只有一个 Invoker 具有最小的活跃数，此时直接返回该 Invoker 即可\n        if (leastCount == 1) {\n            return invokers.get(leastIndexes[0]);\n        }\n        // 如果有多个 Invoker 具有相同的最小活跃数，但它们之间的权重不同\n        // 这里的处理方式就和  RandomLoadBalance 一致了\n        if (!sameWeight && totalWeight > 0) {\n            int offsetWeight = ThreadLocalRandom.current().nextInt(totalWeight);\n            for (int i = 0; i < leastCount; i++) {\n                int leastIndex = leastIndexes[i];\n                offsetWeight -= weights[leastIndex];\n                if (offsetWeight < 0) {\n                    return invokers.get(leastIndex);\n                }\n            }\n        }\n        return invokers.get(leastIndexes[ThreadLocalRandom.current().nextInt(leastCount)]);\n    }\n}\n\n```\n\n活跃数是通过 `RpcStatus` 中的一个 `ConcurrentMap` 保存的，根据 URL 以及服务提供者被调用的方法的名称，我们便可以获取到对应的活跃数。也就是说服务提供者中的每一个方法的活跃数都是互相独立的。\n\n```java\npublic class RpcStatus {\n    \n    private static final ConcurrentMap<String, ConcurrentMap<String, RpcStatus>> METHOD_STATISTICS =\n            new ConcurrentHashMap<String, ConcurrentMap<String, RpcStatus>>();\n\n   public static RpcStatus getStatus(URL url, String methodName) {\n        String uri = url.toIdentityString();\n        ConcurrentMap<String, RpcStatus> map = METHOD_STATISTICS.computeIfAbsent(uri, k -> new ConcurrentHashMap<>());\n        return map.computeIfAbsent(methodName, k -> new RpcStatus());\n    }\n    public int getActive() {\n        return active.get();\n    }\n\n}\n```\n\n####  ConsistentHashLoadBalance\n\n`ConsistentHashLoadBalance`  小伙伴们应该也不会陌生，在分库分表、各种集群中就经常使用这个负载均衡策略。\n\n`ConsistentHashLoadBalance` 即**一致性Hash负载均衡策略**。 `ConsistentHashLoadBalance` 中没有权重的概念，具体是哪个服务提供者处理请求是由你的请求的参数决定的，也就是说相同参数的请求总是发到同一个服务提供者。\n\n![](Dubbo.assets/consistent-hash-data-incline.jpg)\n\n另外，Dubbo 为了避免数据倾斜问题（节点不够分散，大量请求落到同一节点），还引入了虚拟节点的概念。通过虚拟节点可以让节点更加分散，有效均衡各个节点的请求量。\n\n\n\n![](Dubbo.assets/consistent-hash-invoker.jpg)\n\n官方有详细的源码分析：[https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/#23-consistenthashloadbalance](https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/#23-consistenthashloadbalance) 。这里还有一个相关的 [PR#5440](https://github.com/apache/dubbo/pull/5440) 来修复老版本中 ConsistentHashLoadBalance 存在的一些Bug。感兴趣的小伙伴，可以多花点时间研究一下。我这里不多分析了，这个作业留给你们！\n\n####  RoundRobinLoadBalance\n\n加权轮询负载均衡。\n\n轮询就是把请求依次分配给每个服务提供者。加权轮询就是在轮询的基础上，让更多的请求落到权重更大的服务提供者上。比如假如有两个提供相同服务的服务器 S1,S2，S1的权重为7，S2的权重为3。\n\n如果我们有 10 次请求，那么  7 次会被 S1处理，3次被 S2处理。\n\n但是，如果是 `RandomLoadBalance` 的话，很可能存在10次请求有9次都被 S1 处理的情况（概率性问题）。\n\nDubbo 中的 `RoundRobinLoadBalance` 的代码实现被修改重建了好几次，Dubbo-2.6.5 版本的 `RoundRobinLoadBalance` 为平滑加权轮询算法。\n\n## Dubbo序列化协议\n\n### Dubbo 支持哪些序列化方式呢？\n\n![](Dubbo.assets/20210328092219640.png)\n\nDubbo 支持多种序列化方式：JDK自带的序列化、hessian2、JSON、Kryo、FST、Protostuff，ProtoBuf等等。\n\nDubbo 默认使用的序列化方式是 hession2。\n\n### 谈谈你对这些序列化协议了解？\n\n一般我们不会直接使用 JDK 自带的序列化方式。主要原因有两个：\n\n1. **不支持跨语言调用** : 如果调用的是其他语言开发的服务的时候就不支持了。\n2. **性能差** ：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。\n\nJSON 序列化由于性能问题，我们一般也不会考虑使用。\n\n像 Protostuff，ProtoBuf、hessian2这些都是跨语言的序列化方式，如果有跨语言需求的话可以考虑使用。\n\nKryo和FST这两种序列化方式是 Dubbo 后来才引入的，性能非常好。不过，这两者都是专门针对 Java 语言的。Dubbo 官网的一篇文章中提到说推荐使用 Kryo 作为生产环境的序列化方式。(文章地址：[https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rest/](https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rest/))\n\n![](Dubbo.assets/569e541a-22b2-4846-aa07-0ad479f07440.png)\n\nDubbo 官方文档中还有一个关于这些[序列化协议的性能对比图](https://dubbo.apache.org/zh/docs/v2.7/user/serialization/#m-zhdocsv27userserialization)可供参考。\n\n![](Dubbo.assets/20210328093219609-1635780335830.png)\n\n'},"11a2":function(n,e,t){"use strict";t.r(e),e["default"]='[FrancisQ](https://juejin.im/user/5c33853851882525ea106810) 投稿。\n\n\n\x3c!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} --\x3e\n\n\x3c!-- code_chunk_output --\x3e\n\n- [1. 好久不见](#1-好久不见)\n- [2. 什么是ZooKeeper](#2-什么是zookeeper)\n- [3. 一致性问题](#3-一致性问题)\n- [4. 一致性协议和算法](#4-一致性协议和算法)\n  - [4.1. 2PC（两阶段提交）](#41-2pc两阶段提交)\n  - [4.2. 3PC（三阶段提交）](#42-3pc三阶段提交)\n  - [4.3. `Paxos` 算法](#43-paxos-算法)\n    - [4.3.1. prepare 阶段](#431-prepare-阶段)\n    - [4.3.2. accept 阶段](#432-accept-阶段)\n    - [4.3.3. `paxos` 算法的死循环问题](#433-paxos-算法的死循环问题)\n- [5. 引出 `ZAB`](#5-引出-zab)\n  - [5.1. `Zookeeper` 架构](#51-zookeeper-架构)\n  - [5.2. `ZAB` 中的三个角色](#52-zab-中的三个角色)\n  - [5.3. 消息广播模式](#53-消息广播模式)\n  - [5.4. 崩溃恢复模式](#54-崩溃恢复模式)\n- [6. Zookeeper的几个理论知识](#6-zookeeper的几个理论知识)\n  - [6.1. 数据模型](#61-数据模型)\n  - [6.2. 会话](#62-会话)\n  - [6.3. ACL](#63-acl)\n  - [6.4. Watcher机制](#64-watcher机制)\n- [7. Zookeeper的几个典型应用场景](#7-zookeeper的几个典型应用场景)\n  - [7.1. 选主](#71-选主)\n  - [7.2. 分布式锁](#72-分布式锁)\n  - [7.3. 命名服务](#73-命名服务)\n  - [7.4. 集群管理和注册中心](#74-集群管理和注册中心)\n- [8. 总结](#8-总结)\n\n\x3c!-- /code_chunk_output --\x3e\n\n\n## 1. 好久不见\n\n离上一篇文章的发布也快一个月了，想想已经快一个月没写东西了，其中可能有期末考试、课程设计和驾照考试，但这都不是借口！\n\n一到冬天就懒的不行，望广大掘友督促我🙄🙄✍️✍️。\n\n> 文章很长，先赞后看，养成习惯。❤️ 🧡 💛 💚 💙 💜\n\n## 2. 什么是ZooKeeper\n\n`ZooKeeper` 由 `Yahoo` 开发，后来捐赠给了 `Apache` ，现已成为 `Apache` 顶级项目。`ZooKeeper` 是一个开源的分布式应用程序协调服务器，其为分布式系统提供一致性服务。其一致性是通过基于 `Paxos` 算法的 `ZAB` 协议完成的。其主要功能包括：配置维护、分布式同步、集群管理、分布式事务等。\n\n\n\n简单来说， `ZooKeeper` 是一个 **分布式协调服务框架** 。分布式？协调服务？这啥玩意？🤔🤔\n\n其实解释到分布式这个概念的时候，我发现有些同学并不是能把 **分布式和集群 **这两个概念很好的理解透。前段时间有同学和我探讨起分布式的东西，他说分布式不就是加机器吗？一台机器不够用再加一台抗压呗。当然加机器这种说法也无可厚非，你一个分布式系统必定涉及到多个机器，但是你别忘了，计算机学科中还有一个相似的概念—— `Cluster` ，集群不也是加机器吗？但是 集群 和 分布式 其实就是两个完全不同的概念。\n\n比如，我现在有一个秒杀服务，并发量太大单机系统承受不住，那我加几台服务器也 **一样** 提供秒杀服务，这个时候就是 **`Cluster` 集群** 。\n\n![cluster](zookeeper-plus.assets/ffcb080eb66f242ffcd8d2047a7f46aa.png)\n\n但是，我现在换一种方式，我将一个秒杀服务 **拆分成多个子服务** ，比如创建订单服务，增加积分服务，扣优惠券服务等等，**然后我将这些子服务都部署在不同的服务器上** ，这个时候就是  **`Distributed` 分布式** 。\n\n![distributed](zookeeper-plus.assets/07191f38aa947b0075e5c0a6a019a11d.png)\n\n而我为什么反驳同学所说的分布式就是加机器呢？因为我认为加机器更加适用于构建集群，因为它真是只有加机器。而对于分布式来说，你首先需要将业务进行拆分，然后再加机器（不仅仅是加机器那么简单），同时你还要去解决分布式带来的一系列问题。\n\n\n\n比如各个分布式组件如何协调起来，如何减少各个系统之间的耦合度，分布式事务的处理，如何去配置整个分布式系统等等。`ZooKeeper` 主要就是解决这些问题的。\n\n## 3. 一致性问题\n\n设计一个分布式系统必定会遇到一个问题—— **因为分区容忍性（partition tolerance）的存在，就必定要求我们需要在系统可用性（availability）和数据一致性（consistency）中做出权衡** 。这就是著名的 `CAP` 定理。\n\n理解起来其实很简单，比如说把一个班级作为整个系统，而学生是系统中的一个个独立的子系统。这个时候班里的小红小明偷偷谈恋爱被班里的大嘴巴小花发现了，小花欣喜若狂告诉了周围的人，然后小红小明谈恋爱的消息在班级里传播起来了。当在消息的传播（散布）过程中，你抓到一个同学问他们的情况，如果回答你不知道，那么说明整个班级系统出现了数据不一致的问题（因为小花已经知道这个消息了）。而如果他直接不回答你，因为整个班级有消息在进行传播（为了保证一致性，需要所有人都知道才可提供服务），这个时候就出现了系统的可用性问题。\n\n\n\n而上述前者就是 `Eureka` 的处理方式，它保证了AP（可用性），后者就是我们今天所要讲的 `ZooKeeper` 的处理方式，它保证了CP（数据一致性）。\n\n## 4. 一致性协议和算法\n\n而为了解决数据一致性问题，在科学家和程序员的不断探索中，就出现了很多的一致性协议和算法。比如 2PC（两阶段提交），3PC（三阶段提交），Paxos算法等等。\n\n这时候请你思考一个问题，同学之间如果采用传纸条的方式去传播消息，那么就会出现一个问题——我咋知道我的小纸条有没有传到我想要传递的那个人手中呢？万一被哪个小家伙给劫持篡改了呢，对吧？\n\n\n\n这个时候就引申出一个概念—— **拜占庭将军问题** 。它意指 **在不可靠信道上试图通过消息传递的方式达到一致性是不可能的**， 所以所有的一致性算法的 **必要前提** 就是安全可靠的消息通道。\n\n而为什么要去解决数据一致性的问题？你想想，如果一个秒杀系统将服务拆分成了下订单和加积分服务，这两个服务部署在不同的机器上了，万一在消息的传播过程中积分系统宕机了，总不能你这边下了订单却没加积分吧？你总得保证两边的数据需要一致吧？\n\n### 4.1. 2PC（两阶段提交）\n\n两阶段提交是一种保证分布式系统数据一致性的协议，现在很多数据库都是采用的两阶段提交协议来完成 **分布式事务** 的处理。\n\n在介绍2PC之前，我们先来想想分布式事务到底有什么问题呢？\n\n还拿秒杀系统的下订单和加积分两个系统来举例吧（我想你们可能都吐了🤮🤮🤮），我们此时下完订单会发个消息给积分系统告诉它下面该增加积分了。如果我们仅仅是发送一个消息也不收回复，那么我们的订单系统怎么能知道积分系统的收到消息的情况呢？如果我们增加一个收回复的过程，那么当积分系统收到消息后返回给订单系统一个 `Response` ，但在中间出现了网络波动，那个回复消息没有发送成功，订单系统是不是以为积分系统消息接收失败了？它是不是会回滚事务？但此时积分系统是成功收到消息的，它就会去处理消息然后给用户增加积分，这个时候就会出现积分加了但是订单没下成功。\n\n所以我们所需要解决的是在分布式系统中，整个调用链中，我们所有服务的数据处理要么都成功要么都失败，即所有服务的 **原子性问题** 。\n\n在两阶段提交中，主要涉及到两个角色，分别是协调者和参与者。\n\n第一阶段：当要执行一个分布式事务的时候，事务发起者首先向协调者发起事务请求，然后协调者会给所有参与者发送 `prepare` 请求（其中包括事务内容）告诉参与者你们需要执行事务了，如果能执行我发的事务内容那么就先执行但不提交，执行后请给我回复。然后参与者收到 `prepare` 消息后，他们会开始执行事务（但不提交），并将 `Undo` 和 `Redo` 信息记入事务日志中，之后参与者就向协调者反馈是否准备好了。\n\n第二阶段：第二阶段主要是协调者根据参与者反馈的情况来决定接下来是否可以进行事务的提交操作，即提交事务或者回滚事务。\n\n比如这个时候 **所有的参与者** 都返回了准备好了的消息，这个时候就进行事务的提交，协调者此时会给所有的参与者发送 **`Commit` 请求** ，当参与者收到 `Commit` 请求的时候会执行前面执行的事务的 **提交操作** ，提交完毕之后将给协调者发送提交成功的响应。\n\n而如果在第一阶段并不是所有参与者都返回了准备好了的消息，那么此时协调者将会给所有参与者发送 **回滚事务的 `rollback` 请求**，参与者收到之后将会 **回滚它在第一阶段所做的事务处理** ，然后再将处理情况返回给协调者，最终协调者收到响应后便给事务发起者返回处理失败的结果。\n\n![2PC流程](zookeeper-plus.assets/7ce4e40b68d625676bb42c29efce046a.png)\n\n个人觉得 2PC 实现得还是比较鸡肋的，因为事实上它只解决了各个事务的原子性问题，随之也带来了很多的问题。\n\n\n\n* **单点故障问题**，如果协调者挂了那么整个系统都处于不可用的状态了。\n* **阻塞问题**，即当协调者发送 `prepare` 请求，参与者收到之后如果能处理那么它将会进行事务的处理但并不提交，这个时候会一直占用着资源不释放，如果此时协调者挂了，那么这些资源都不会再释放了，这会极大影响性能。\n* **数据不一致问题**，比如当第二阶段，协调者只发送了一部分的 `commit` 请求就挂了，那么也就意味着，收到消息的参与者会进行事务的提交，而后面没收到的则不会进行事务提交，那么这时候就会产生数据不一致性问题。\n\n### 4.2. 3PC（三阶段提交）\n\n因为2PC存在的一系列问题，比如单点，容错机制缺陷等等，从而产生了 **3PC（三阶段提交）** 。那么这三阶段又分别是什么呢？\n\n> 千万不要吧PC理解成个人电脑了，其实他们是 phase-commit 的缩写，即阶段提交。\n\n1. **CanCommit阶段**：协调者向所有参与者发送 `CanCommit` 请求，参与者收到请求后会根据自身情况查看是否能执行事务，如果可以则返回 YES 响应并进入预备状态，否则返回 NO 。\n2. **PreCommit阶段**：协调者根据参与者返回的响应来决定是否可以进行下面的 `PreCommit` 操作。如果上面参与者返回的都是 YES，那么协调者将向所有参与者发送 `PreCommit` 预提交请求，**参与者收到预提交请求后，会进行事务的执行操作，并将 `Undo` 和 `Redo` 信息写入事务日志中** ，最后如果参与者顺利执行了事务则给协调者返回成功的响应。如果在第一阶段协调者收到了 **任何一个 NO** 的信息，或者 **在一定时间内** 并没有收到全部的参与者的响应，那么就会中断事务，它会向所有参与者发送中断请求（abort），参与者收到中断请求之后会立即中断事务，或者在一定时间内没有收到协调者的请求，它也会中断事务。\n3. **DoCommit阶段**：这个阶段其实和 `2PC` 的第二阶段差不多，如果协调者收到了所有参与者在 `PreCommit` 阶段的 YES 响应，那么协调者将会给所有参与者发送 `DoCommit` 请求，**参与者收到 `DoCommit` 请求后则会进行事务的提交工作**，完成后则会给协调者返回响应，协调者收到所有参与者返回的事务提交成功的响应之后则完成事务。若协调者在 `PreCommit` 阶段 **收到了任何一个 NO 或者在一定时间内没有收到所有参与者的响应** ，那么就会进行中断请求的发送，参与者收到中断请求后则会 **通过上面记录的回滚日志** 来进行事务的回滚操作，并向协调者反馈回滚状况，协调者收到参与者返回的消息后，中断事务。\n\n![3PC流程](zookeeper-plus.assets/d0b44361c746593f70a6e42c298b413a.png)\n\n> 这里是 `3PC` 在成功的环境下的流程图，你可以看到 `3PC` 在很多地方进行了超时中断的处理，比如协调者在指定时间内为收到全部的确认消息则进行事务中断的处理，这样能 **减少同步阻塞的时间** 。还有需要注意的是，**`3PC` 在 `DoCommit` 阶段参与者如未收到协调者发送的提交事务的请求，它会在一定时间内进行事务的提交**。为什么这么做呢？是因为这个时候我们肯定**保证了在第一阶段所有的协调者全部返回了可以执行事务的响应**，这个时候我们有理由**相信其他系统都能进行事务的执行和提交**，所以**不管**协调者有没有发消息给参与者，进入第三阶段参与者都会进行事务的提交操作。\n\n总之，`3PC` 通过一系列的超时机制很好的缓解了阻塞问题，但是最重要的一致性并没有得到根本的解决，比如在 `PreCommit` 阶段，当一个参与者收到了请求之后其他参与者和协调者挂了或者出现了网络分区，这个时候收到消息的参与者都会进行事务提交，这就会出现数据不一致性问题。\n\n所以，要解决一致性问题还需要靠 `Paxos` 算法⭐️ ⭐️ ⭐️ 。\n\n### 4.3. `Paxos` 算法\n\n`Paxos` 算法是基于**消息传递且具有高度容错特性的一致性算法**，是目前公认的解决分布式一致性问题最有效的算法之一，**其解决的问题就是在分布式系统中如何就某个值（决议）达成一致** 。\n\n在 `Paxos` 中主要有三个角色，分别为 `Proposer提案者`、`Acceptor表决者`、`Learner学习者`。`Paxos` 算法和 `2PC` 一样，也有两个阶段，分别为 `Prepare` 和 `accept` 阶段。\n\n#### 4.3.1. prepare 阶段\n\n* `Proposer提案者`：负责提出 `proposal`，每个提案者在提出提案时都会首先获取到一个 **具有全局唯一性的、递增的提案编号N**，即在整个集群中是唯一的编号 N，然后将该编号赋予其要提出的提案，在**第一阶段是只将提案编号发送给所有的表决者**。\n* `Acceptor表决者`：每个表决者在 `accept` 某提案后，会将该提案编号N记录在本地，这样每个表决者中保存的已经被 accept 的提案中会存在一个**编号最大的提案**，其编号假设为 `maxN`。每个表决者仅会 `accept` 编号大于自己本地 `maxN` 的提案，在批准提案时表决者会将以前接受过的最大编号的提案作为响应反馈给 `Proposer` 。\n\n> 下面是 `prepare` 阶段的流程图，你可以对照着参考一下。\n\n![paxos第一阶段](zookeeper-plus.assets/22e8d512d954676bdf0cc92d200af8ef.png)\n\n#### 4.3.2. accept 阶段\n\n当一个提案被 `Proposer` 提出后，如果 `Proposer` 收到了超过半数的 `Acceptor` 的批准（`Proposer` 本身同意），那么此时 `Proposer` 会给所有的 `Acceptor` 发送真正的提案（你可以理解为第一阶段为试探），这个时候 `Proposer` 就会发送提案的内容和提案编号。\n\n表决者收到提案请求后会再次比较本身已经批准过的最大提案编号和该提案编号，如果该提案编号 **大于等于** 已经批准过的最大提案编号，那么就 `accept` 该提案（此时执行提案内容但不提交），随后将情况返回给 `Proposer` 。如果不满足则不回应或者返回 NO 。\n\n![paxos第二阶段1](zookeeper-plus.assets/b82536f956f70a584c6a20c10113f225.png)\n\n当 `Proposer` 收到超过半数的 `accept` ，那么它这个时候会向所有的 `acceptor` 发送提案的提交请求。需要注意的是，因为上述仅仅是超过半数的 `acceptor` 批准执行了该提案内容，其他没有批准的并没有执行该提案内容，所以这个时候需要**向未批准的 `acceptor` 发送提案内容和提案编号并让它无条件执行和提交**，而对于前面已经批准过该提案的 `acceptor` 来说 **仅仅需要发送该提案的编号** ，让 `acceptor` 执行提交就行了。\n\n![paxos第二阶段2](zookeeper-plus.assets/743889b97485fdfe2094e5ef0af6b141.png)\n\n而如果 `Proposer` 如果没有收到超过半数的 `accept`  那么它将会将 **递增** 该 `Proposal` 的编号，然后 **重新进入 `Prepare` 阶段** 。\n\n> 对于 `Learner` 来说如何去学习 `Acceptor` 批准的提案内容，这有很多方式，读者可以自己去了解一下，这里不做过多解释。\n\n#### 4.3.3. `paxos` 算法的死循环问题\n\n其实就有点类似于两个人吵架，小明说我是对的，小红说我才是对的，两个人据理力争的谁也不让谁🤬🤬。\n\n比如说，此时提案者 P1 提出一个方案 M1，完成了 `Prepare` 阶段的工作，这个时候 `acceptor` 则批准了 M1，但是此时提案者 P2 同时也提出了一个方案 M2，它也完成了 `Prepare` 阶段的工作。然后 P1 的方案已经不能在第二阶段被批准了（因为 `acceptor` 已经批准了比 M1 更大的 M2），所以 P1 自增方案变为 M3 重新进入 `Prepare` 阶段，然后 `acceptor` ，又批准了新的 M3 方案，它又不能批准 M2 了，这个时候 M2 又自增进入 `Prepare` 阶段。。。\n\n就这样无休无止的永远提案下去，这就是 `paxos` 算法的死循环问题。\n\n\n\n那么如何解决呢？很简单，人多了容易吵架，我现在 **就允许一个能提案** 就行了。\n\n## 5. 引出 `ZAB`\n\n### 5.1. `Zookeeper` 架构\n\n作为一个优秀高效且可靠的分布式协调框架，`ZooKeeper` 在解决分布式数据一致性问题时并没有直接使用 `Paxos` ，而是专门定制了一致性协议叫做 `ZAB(ZooKeeper Atomic Broadcast)` 原子广播协议，该协议能够很好地支持 **崩溃恢复** 。\n\n![Zookeeper架构](zookeeper-plus.assets/0c38d08ea026e25bf3849cc7654a4e79.png)\n\n### 5.2. `ZAB` 中的三个角色\n\n和介绍 `Paxos` 一样，在介绍 `ZAB` 协议之前，我们首先来了解一下在 `ZAB` 中三个主要的角色，`Leader 领导者`、`Follower跟随者`、`Observer观察者` 。\n\n* `Leader` ：集群中 **唯一的写请求处理者** ，能够发起投票（投票也是为了进行写请求）。\n* `Follower`：能够接收客户端的请求，如果是读请求则可以自己处理，**如果是写请求则要转发给 `Leader`** 。在选举过程中会参与投票，**有选举权和被选举权** 。\n* `Observer` ：就是没有选举权和被选举权的 `Follower` 。\n\n在 `ZAB` 协议中对 `zkServer`(即上面我们说的三个角色的总称) 还有两种模式的定义，分别是 **消息广播** 和 **崩溃恢复** 。\n\n### 5.3. 消息广播模式\n\n说白了就是 `ZAB` 协议是如何处理写请求的，上面我们不是说只有 `Leader` 能处理写请求嘛？那么我们的 `Follower` 和 `Observer` 是不是也需要 **同步更新数据** 呢？总不能数据只在 `Leader` 中更新了，其他角色都没有得到更新吧？\n\n不就是 **在整个集群中保持数据的一致性** 嘛？如果是你，你会怎么做呢？\n\n\n\n废话，第一步肯定需要 `Leader` 将写请求 **广播** 出去呀，让 `Leader` 问问 `Followers` 是否同意更新，如果超过半数以上的同意那么就进行 `Follower` 和 `Observer` 的更新（和 `Paxos` 一样）。当然这么说有点虚，画张图理解一下。\n\n![消息广播](zookeeper-plus.assets/08ccce48190fe4edcbcbb223d6231876.png)\n\n嗯。。。看起来很简单，貌似懂了🤥🤥🤥。这两个 `Queue` 哪冒出来的？答案是 **`ZAB` 需要让 `Follower` 和 `Observer` 保证顺序性** 。何为顺序性，比如我现在有一个写请求A，此时 `Leader` 将请求A广播出去，因为只需要半数同意就行，所以可能这个时候有一个 `Follower` F1因为网络原因没有收到，而 `Leader` 又广播了一个请求B，因为网络原因，F1竟然先收到了请求B然后才收到了请求A，这个时候请求处理的顺序不同就会导致数据的不同，从而 **产生数据不一致问题** 。\n\n所以在 `Leader` 这端，它为每个其他的 `zkServer` 准备了一个 **队列** ，采用先进先出的方式发送消息。由于协议是 **通过 `TCP` **来进行网络通信的，保证了消息的发送顺序性，接受顺序性也得到了保证。\n\n除此之外，在 `ZAB` 中还定义了一个 **全局单调递增的事务ID `ZXID`** ，它是一个64位long型，其中高32位表示 `epoch` 年代，低32位表示事务id。`epoch` 是会根据 `Leader` 的变化而变化的，当一个 `Leader` 挂了，新的 `Leader` 上位的时候，年代（`epoch`）就变了。而低32位可以简单理解为递增的事务id。\n\n定义这个的原因也是为了顺序性，每个 `proposal` 在 `Leader` 中生成后需要 **通过其 `ZXID` 来进行排序** ，才能得到处理。\n\n### 5.4. 崩溃恢复模式\n\n说到崩溃恢复我们首先要提到 `ZAB` 中的 `Leader` 选举算法，当系统出现崩溃影响最大应该是 `Leader` 的崩溃，因为我们只有一个 `Leader` ，所以当 `Leader` 出现问题的时候我们势必需要重新选举 `Leader` 。\n\n`Leader` 选举可以分为两个不同的阶段，第一个是我们提到的 `Leader` 宕机需要重新选举，第二则是当 `Zookeeper` 启动时需要进行系统的 `Leader` 初始化选举。下面我先来介绍一下 `ZAB` 是如何进行初始化选举的。\n\n假设我们集群中有3台机器，那也就意味着我们需要两台以上同意（超过半数）。比如这个时候我们启动了 `server1` ，它会首先 **投票给自己** ，投票内容为服务器的 `myid` 和 `ZXID` ，因为初始化所以 `ZXID` 都为0，此时 `server1` 发出的投票为 (1,0)。但此时 `server1` 的投票仅为1，所以不能作为 `Leader` ，此时还在选举阶段所以整个集群处于 **`Looking` 状态**。\n\n接着 `server2` 启动了，它首先也会将投票选给自己(2,0)，并将投票信息广播出去（`server1`也会，只是它那时没有其他的服务器了），`server1` 在收到 `server2` 的投票信息后会将投票信息与自己的作比较。**首先它会比较 `ZXID` ，`ZXID` 大的优先为 `Leader`，如果相同则比较 `myid`，`myid` 大的优先作为 `Leader`**。所以此时`server1` 发现 `server2` 更适合做 `Leader`，它就会将自己的投票信息更改为(2,0)然后再广播出去，之后`server2`  收到之后发现和自己的一样无需做更改，并且自己的 **投票已经超过半数** ，则 **确定 `server2` 为 `Leader`**，`server1` 也会将自己服务器设置为 `Following` 变为 `Follower`。整个服务器就从 `Looking` 变为了正常状态。\n\n当 `server3` 启动发现集群没有处于 `Looking` 状态时，它会直接以 `Follower` 的身份加入集群。\n\n还是前面三个 `server` 的例子，如果在整个集群运行的过程中 `server2` 挂了，那么整个集群会如何重新选举 `Leader` 呢？其实和初始化选举差不多。\n\n首先毫无疑问的是剩下的两个 `Follower` 会将自己的状态 **从 `Following` 变为 `Looking` 状态** ，然后每个 `server` 会向初始化投票一样首先给自己投票（这不过这里的 `zxid` 可能不是0了，这里为了方便随便取个数字）。\n\n假设 `server1` 给自己投票为(1,99)，然后广播给其他 `server`，`server3` 首先也会给自己投票(3,95)，然后也广播给其他 `server`。`server1` 和 `server3` 此时会收到彼此的投票信息，和一开始选举一样，他们也会比较自己的投票和收到的投票（`zxid` 大的优先，如果相同那么就 `myid` 大的优先）。这个时候 `server1` 收到了 `server3` 的投票发现没自己的合适故不变，`server3` 收到 `server1` 的投票结果后发现比自己的合适于是更改投票为(1,99)然后广播出去，最后 `server1` 收到了发现自己的投票已经超过半数就把自己设为 `Leader`，`server3` 也随之变为 `Follower`。\n\n> 请注意 `ZooKeeper` 为什么要设置奇数个结点？比如这里我们是三个，挂了一个我们还能正常工作，挂了两个我们就不能正常工作了（已经没有超过半数的节点数了，所以无法进行投票等操作了）。而假设我们现在有四个，挂了一个也能工作，**但是挂了两个也不能正常工作了**，这是和三个一样的，而三个比四个还少一个，带来的效益是一样的，所以 `Zookeeper` 推荐奇数个 `server` 。\n\n那么说完了 `ZAB` 中的 `Leader` 选举方式之后我们再来了解一下 **崩溃恢复** 是什么玩意？\n\n其实主要就是 **当集群中有机器挂了，我们整个集群如何保证数据一致性？**\n\n如果只是 `Follower` 挂了，而且挂的没超过半数的时候，因为我们一开始讲了在 `Leader` 中会维护队列，所以不用担心后面的数据没接收到导致数据不一致性。\n\n如果 `Leader` 挂了那就麻烦了，我们肯定需要先暂停服务变为 `Looking` 状态然后进行 `Leader` 的重新选举（上面我讲过了），但这个就要分为两种情况了，分别是 **确保已经被Leader提交的提案最终能够被所有的Follower提交** 和 **跳过那些已经被丢弃的提案** 。\n\n确保已经被Leader提交的提案最终能够被所有的Follower提交是什么意思呢？\n\n假设 `Leader (server2)` 发送 `commit` 请求（忘了请看上面的消息广播模式），他发送给了 `server3`，然后要发给 `server1` 的时候突然挂了。这个时候重新选举的时候我们如果把 `server1` 作为 `Leader` 的话，那么肯定会产生数据不一致性，因为 `server3` 肯定会提交刚刚 `server2` 发送的 `commit` 请求的提案，而 `server1` 根本没收到所以会丢弃。\n\n![崩溃恢复](zookeeper-plus.assets/ffcb12c6fb2bad76ac7105696655e85c.png)\n\n那怎么解决呢？\n\n聪明的同学肯定会质疑，**这个时候 `server1` 已经不可能成为 `Leader` 了，因为 `server1` 和 `server3` 进行投票选举的时候会比较 `ZXID` ，而此时 `server3` 的 `ZXID` 肯定比 `server1` 的大了**。(不理解可以看前面的选举算法)\n\n那么跳过那些已经被丢弃的提案又是什么意思呢？\n\n假设 `Leader (server2)` 此时同意了提案N1，自身提交了这个事务并且要发送给所有 `Follower` 要 `commit` 的请求，却在这个时候挂了，此时肯定要重新进行 `Leader` 的选举，比如说此时选 `server1` 为 `Leader` （这无所谓）。但是过了一会，这个 **挂掉的 `Leader` 又重新恢复了** ，此时它肯定会作为 `Follower` 的身份进入集群中，需要注意的是刚刚 `server2` 已经同意提交了提案N1，但其他 `server` 并没有收到它的 `commit` 信息，所以其他 `server` 不可能再提交这个提案N1了，这样就会出现数据不一致性问题了，所以 **该提案N1最终需要被抛弃掉** 。\n\n![崩溃恢复](zookeeper-plus.assets/abb6efc7d4df9c82b162cbecb129a6e3.png)\n\n## 6. Zookeeper的几个理论知识\n\n了解了 `ZAB` 协议还不够，它仅仅是 `Zookeeper` 内部实现的一种方式，而我们如何通过 `Zookeeper` 去做一些典型的应用场景呢？比如说集群管理，分布式锁，`Master` 选举等等。\n\n这就涉及到如何使用 `Zookeeper` 了，但在使用之前我们还需要掌握几个概念。比如 `Zookeeper` 的 **数据模型** 、**会话机制**、**ACL**、**Watcher机制** 等等。\n\n### 6.1. 数据模型\n\n`zookeeper` 数据存储结构与标准的 `Unix` 文件系统非常相似，都是在根节点下挂很多子节点(树型)。但是 `zookeeper` 中没有文件系统中目录与文件的概念，而是 **使用了 `znode` 作为数据节点** 。`znode` 是 `zookeeper` 中的最小数据单元，每个 `znode` 上都可以保存数据，同时还可以挂载子节点，形成一个树形化命名空间。\n\n![zk数据模型](zookeeper-plus.assets/8f35dba8c44c4a10d81e3395df971ce7.png)\n\n每个 `znode` 都有自己所属的 **节点类型** 和 **节点状态**。\n\n其中节点类型可以分为 **持久节点**、**持久顺序节点**、**临时节点** 和 **临时顺序节点**。\n\n* 持久节点：一旦创建就一直存在，直到将其删除。\n* 持久顺序节点：一个父节点可以为其子节点 **维护一个创建的先后顺序** ，这个顺序体现在 **节点名称** 上，是节点名称后自动添加一个由 10 位数字组成的数字串，从 0 开始计数。\n* 临时节点：临时节点的生命周期是与 **客户端会话** 绑定的，**会话消失则节点消失** 。临时节点 **只能做叶子节点** ，不能创建子节点。\n* 临时顺序节点：父节点可以创建一个维持了顺序的临时节点(和前面的持久顺序性节点一样)。\n\n节点状态中包含了很多节点的属性比如 `czxid` 、`mzxid` 等等，在 `zookeeper` 中是使用 `Stat` 这个类来维护的。下面我列举一些属性解释。\n\n* `czxid`：`Created ZXID`，该数据节点被 **创建** 时的事务ID。\n* `mzxid`：`Modified ZXID`，节点 **最后一次被更新时** 的事务ID。\n* `ctime`：`Created Time`，该节点被创建的时间。\n* `mtime`： `Modified Time`，该节点最后一次被修改的时间。\n* `version`：节点的版本号。\n* `cversion`：**子节点** 的版本号。\n* `aversion`：节点的 `ACL` 版本号。\n* `ephemeralOwner`：创建该节点的会话的 `sessionID` ，如果该节点为持久节点，该值为0。\n* `dataLength`：节点数据内容的长度。\n* `numChildre`：该节点的子节点个数，如果为临时节点为0。\n* `pzxid`：该节点子节点列表最后一次被修改时的事务ID，注意是子节点的 **列表** ，不是内容。\n\n### 6.2. 会话\n\n我想这个对于后端开发的朋友肯定不陌生，不就是 `session` 吗？只不过 `zk` 客户端和服务端是通过 **`TCP` 长连接** 维持的会话机制，其实对于会话来说你可以理解为 **保持连接状态** 。\n\n在 `zookeeper` 中，会话还有对应的事件，比如 `CONNECTION_LOSS 连接丢失事件` 、`SESSION_MOVED 会话转移事件` 、`SESSION_EXPIRED 会话超时失效事件` 。\n\n### 6.3. ACL\n\n`ACL` 为 `Access Control Lists` ，它是一种权限控制。在 `zookeeper` 中定义了5种权限，它们分别为：\n\n* `CREATE` ：创建子节点的权限。\n* `READ`：获取节点数据和子节点列表的权限。\n* `WRITE`：更新节点数据的权限。\n* `DELETE`：删除子节点的权限。\n* `ADMIN`：设置节点 ACL 的权限。\n\n### 6.4. Watcher机制\n\n`Watcher` 为事件监听器，是 `zk` 非常重要的一个特性，很多功能都依赖于它，它有点类似于订阅的方式，即客户端向服务端 **注册** 指定的 `watcher` ，当服务端符合了 `watcher` 的某些事件或要求则会 **向客户端发送事件通知** ，客户端收到通知后找到自己定义的 `Watcher` 然后 **执行相应的回调方法** 。\n\n![watcher机制](zookeeper-plus.assets/241ab8cc37571034fa984322b753c7ba.png)\n\n## 7. Zookeeper的几个典型应用场景\n\n前面说了这么多的理论知识，你可能听得一头雾水，这些玩意有啥用？能干啥事？别急，听我慢慢道来。\n\n\n\n### 7.1. 选主\n\n还记得上面我们的所说的临时节点吗？因为 `Zookeeper` 的强一致性，能够很好地在保证 **在高并发的情况下保证节点创建的全局唯一性** (即无法重复创建同样的节点)。\n\n利用这个特性，我们可以 **让多个客户端创建一个指定的节点** ，创建成功的就是 `master`。\n\n但是，如果这个 `master` 挂了怎么办？？？\n\n你想想为什么我们要创建临时节点？还记得临时节点的生命周期吗？`master` 挂了是不是代表会话断了？会话断了是不是意味着这个节点没了？还记得 `watcher` 吗？我们是不是可以 **让其他不是 `master` 的节点监听节点的状态** ，比如说我们监听这个临时节点的父节点，如果子节点个数变了就代表 `master` 挂了，这个时候我们 **触发回调函数进行重新选举** ，或者我们直接监听节点的状态，我们可以通过节点是否已经失去连接来判断 `master` 是否挂了等等。\n\n![选主](zookeeper-plus.assets/a94707028c5581c815f72fba0f50f43a.png)\n\n总的来说，我们可以完全 **利用 临时节点、节点状态 和 `watcher` 来实现选主的功能**，临时节点主要用来选举，节点状态和`watcher` 可以用来判断 `master` 的活性和进行重新选举。\n\n### 7.2. 分布式锁\n\n分布式锁的实现方式有很多种，比如 `Redis` 、数据库 、`zookeeper` 等。个人认为 `zookeeper` 在实现分布式锁这方面是非常非常简单的。\n\n上面我们已经提到过了 **zk在高并发的情况下保证节点创建的全局唯一性**，这玩意一看就知道能干啥了。实现互斥锁呗，又因为能在分布式的情况下，所以能实现分布式锁呗。\n\n如何实现呢？这玩意其实跟选主基本一样，我们也可以利用临时节点的创建来实现。\n\n首先肯定是如何获取锁，因为创建节点的唯一性，我们可以让多个客户端同时创建一个临时节点，**创建成功的就说明获取到了锁** 。然后没有获取到锁的客户端也像上面选主的非主节点创建一个 `watcher` 进行节点状态的监听，如果这个互斥锁被释放了（可能获取锁的客户端宕机了，或者那个客户端主动释放了锁）可以调用回调函数重新获得锁。\n\n> `zk` 中不需要向 `redis` 那样考虑锁得不到释放的问题了，因为当客户端挂了，节点也挂了，锁也释放了。是不是很简答？                                               \n\n那能不能使用 `zookeeper` 同时实现 **共享锁和独占锁** 呢？答案是可以的，不过稍微有点复杂而已。\n\n还记得 **有序的节点** 吗？\n\n这个时候我规定所有创建节点必须有序，当你是读请求（要获取共享锁）的话，如果 **没有比自己更小的节点，或比自己小的节点都是读请求** ，则可以获取到读锁，然后就可以开始读了。**若比自己小的节点中有写请求** ，则当前客户端无法获取到读锁，只能等待前面的写请求完成。\n\n如果你是写请求（获取独占锁），若 **没有比自己更小的节点** ，则表示当前客户端可以直接获取到写锁，对数据进行修改。若发现 **有比自己更小的节点，无论是读操作还是写操作，当前客户端都无法获取到写锁** ，等待所有前面的操作完成。\n\n这就很好地同时实现了共享锁和独占锁，当然还有优化的地方，比如当一个锁得到释放它会通知所有等待的客户端从而造成 **羊群效应** 。此时你可以通过让等待的节点只监听他们前面的节点。\n\n具体怎么做呢？其实也很简单，你可以让 **读请求监听比自己小的最后一个写请求节点，写请求只监听比自己小的最后一个节点** ，感兴趣的小伙伴可以自己去研究一下。                                                                                                                                                                                                                                                                                       \n\n### 7.3. 命名服务\n\n如何给一个对象设置ID，大家可能都会想到 `UUID`，但是 `UUID` 最大的问题就在于它太长了。。。(太长不一定是好事，嘿嘿嘿)。那么在条件允许的情况下，我们能不能使用 `zookeeper` 来实现呢？\n\n我们之前提到过 `zookeeper` 是通过 **树形结构** 来存储数据节点的，那也就是说，对于每个节点的 **全路径**，它必定是唯一的，我们可以使用节点的全路径作为命名方式了。而且更重要的是，路径是我们可以自己定义的，这对于我们对有些有语意的对象的ID设置可以更加便于理解。\n\n### 7.4. 集群管理和注册中心\n\n看到这里是不是觉得 `zookeeper` 实在是太强大了，它怎么能这么能干！\n\n别急，它能干的事情还很多呢。可能我们会有这样的需求，我们需要了解整个集群中有多少机器在工作，我们想对集群中的每台机器的运行时状态进行数据采集，对集群中机器进行上下线操作等等。\n\n而 `zookeeper` 天然支持的 `watcher` 和 临时节点能很好的实现这些需求。我们可以为每条机器创建临时节点，并监控其父节点，如果子节点列表有变动（我们可能创建删除了临时节点），那么我们可以使用在其父节点绑定的 `watcher` 进行状态监控和回调。\n\n![集群管理](zookeeper-plus.assets/6115820219c35c68bcb2c9a855ebace3.png)\n\n至于注册中心也很简单，我们同样也是让 **服务提供者** 在 `zookeeper` 中创建一个临时节点并且将自己的 `ip、port、调用方式` 写入节点，当 **服务消费者** 需要进行调用的时候会 **通过注册中心找到相应的服务的地址列表(IP端口什么的)** ，并缓存到本地(方便以后调用)，当消费者调用服务时，不会再去请求注册中心，而是直接通过负载均衡算法从地址列表中取一个服务提供者的服务器调用服务。\n\n当服务提供者的某台服务器宕机或下线时，相应的地址会从服务提供者地址列表中移除。同时，注册中心会将新的服务地址列表发送给服务消费者的机器并缓存在消费者本机（当然你可以让消费者进行节点监听，我记得 `Eureka` 会先试错，然后再更新）。\n\n![注册中心](zookeeper-plus.assets/0b5b3911a7c2dae23391d17c91416b29.png)\n\n## 8. 总结\n\n看到这里的同学实在是太有耐心了👍👍👍，如果觉得我写得不错的话点个赞哈。\n\n不知道大家是否还记得我讲了什么😒。\n\n\n\n这篇文章中我带大家入门了 `zookeeper` 这个强大的分布式协调框架。现在我们来简单梳理一下整篇文章的内容。\n\n* 分布式与集群的区别\n\n* `2PC` 、`3PC` 以及 `paxos` 算法这些一致性框架的原理和实现。\n\n* `zookeeper` 专门的一致性算法 `ZAB` 原子广播协议的内容（`Leader` 选举、崩溃恢复、消息广播）。\n\n* `zookeeper` 中的一些基本概念，比如 `ACL`，数据节点，会话，`watcher`机制等等。\n\n* `zookeeper` 的典型应用场景，比如选主，注册中心等等。\n  \n  如果忘了可以回去看看再次理解一下，如果有疑问和建议欢迎提出🤝🤝🤝。\n'},1229:function(n,e,t){"use strict";t.r(e),e["default"]='\x3c!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} --\x3e\n\n\x3c!-- code_chunk_output --\x3e\n\n- [基础概念与常识](#基础概念与常识)\n  - [Java 语言有哪些特点?](#java-语言有哪些特点)\n  - [JVM vs JDK vs JRE](#jvm-vs-jdk-vs-jre)\n    - [JVM](#jvm)\n    - [JDK 和 JRE](#jdk-和-jre)\n  - [为什么说 Java 语言“编译与解释并存”？](#为什么说-java-语言编译与解释并存)\n  - [Oracle JDK 和 OpenJDK 的对比](#oracle-jdk-和-openjdk-的对比)\n  - [Java 和 C++的区别?](#java-和-c的区别)\n  - [import java 和 javax 有什么区别？](#import-java-和-javax-有什么区别)\n- [基本语法](#基本语法)\n  - [字符型常量和字符串常量的区别?](#字符型常量和字符串常量的区别)\n  - [注释](#注释)\n  - [标识符和关键字的区别是什么？](#标识符和关键字的区别是什么)\n  - [Java 中有哪些常见的关键字？](#java-中有哪些常见的关键字)\n  - [自增自减运算符](#自增自减运算符)\n  - [continue、break、和 return 的区别是什么？](#continue-break-和-return-的区别是什么)\n  - [Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？](#java-泛型了解么什么是类型擦除介绍一下常用的通配符)\n  - [==和 equals 的区别](#和-equals-的区别)\n  - [hashCode()与 equals()](#hashcode与-equals)\n- [基本数据类型](#基本数据类型)\n  - [Java 中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？](#java-中的几种基本数据类型是什么对应的包装类型是什么各自占用多少字节呢)\n  - [自动装箱与拆箱](#自动装箱与拆箱)\n  - [8 种基本类型的包装类和常量池](#8-种基本类型的包装类和常量池)\n- [方法（函数）](#方法函数)\n  - [什么是方法的返回值?](#什么是方法的返回值)\n  - [方法有哪几种类型？](#方法有哪几种类型)\n  - [在一个静态方法内调用一个非静态成员为什么是非法的?](#在一个静态方法内调用一个非静态成员为什么是非法的)\n  - [静态方法和实例方法有何不同？](#静态方法和实例方法有何不同)\n  - [为什么 Java 中只有值传递？](#为什么-java-中只有值传递)\n  - [重载和重写的区别](#重载和重写的区别)\n    - [重载](#重载)\n    - [重写](#重写)\n  - [深拷贝 vs 浅拷贝](#深拷贝-vs-浅拷贝)\n- [Java 面向对象](#java-面向对象)\n  - [面向对象和面向过程的区别](#面向对象和面向过程的区别)\n  - [成员变量与局部变量的区别有哪些？](#成员变量与局部变量的区别有哪些)\n  - [创建一个对象用什么运算符?对象实体与对象引用有何不同?](#创建一个对象用什么运算符对象实体与对象引用有何不同)\n  - [对象的相等与指向他们的引用相等,两者有什么不同?](#对象的相等与指向他们的引用相等两者有什么不同)\n  - [一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?](#一个类的构造方法的作用是什么-若一个类没有声明构造方法该程序能正确执行吗-为什么)\n  - [构造方法有哪些特点？是否可被 override?](#构造方法有哪些特点是否可被-override)\n  - [面向对象三大特征](#面向对象三大特征)\n    - [封装](#封装)\n    - [继承](#继承)\n    - [多态](#多态)\n  - [String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?](#string-stringbuffer-和-stringbuilder-的区别是什么-string-为什么是不可变的)\n  - [Object 类的常见方法总结](#object-类的常见方法总结)\n- [反射](#反射)\n  - [何为反射？](#何为反射)\n  - [反射机制优缺点](#反射机制优缺点)\n  - [反射的应用场景](#反射的应用场景)\n- [异常](#异常)\n  - [Java 异常类层次结构图](#java-异常类层次结构图)\n  - [Throwable 类常用方法](#throwable-类常用方法)\n  - [try-catch-finally](#try-catch-finally)\n  - [使用 `try-with-resources` 来代替`try-catch-finally`](#使用-try-with-resources-来代替try-catch-finally)\n- [I\\O 流](#io-流)\n  - [什么是序列化?什么是反序列化?](#什么是序列化什么是反序列化)\n  - [Java 序列化中如果有些字段不想进行序列化，怎么办？](#java-序列化中如果有些字段不想进行序列化怎么办)\n  - [获取用键盘输入常用的两种方法](#获取用键盘输入常用的两种方法)\n  - [Java 中 IO 流分为几种?](#java-中-io-流分为几种)\n  - [既然有了字节流,为什么还要有字符流?](#既然有了字节流为什么还要有字符流)\n- [4. 参考](#4-参考)\n\n\x3c!-- /code_chunk_output --\x3e\n\n## 基础概念与常识\n\n### Java 语言有哪些特点?\n\n1. 简单易学；\n2. 面向对象（封装，继承，多态）；\n3. 平台无关性（ Java 虚拟机实现平台无关性）；\n4. 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；\n5. 可靠性；\n6. 安全性；\n7. 支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；\n8. 编译与解释并存；\n\n> **🐛 修正（参见： [issue#544](https://github.com/Snailclimb/JavaGuide/issues/544)）** ：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用`std::thread`和`std::async`来创建线程。参考链接：http://www.cplusplus.com/reference/thread/thread/?kw=thread\n\n### JVM vs JDK vs JRE\n\n#### JVM\n\nJava 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。\n\n**什么是字节码?采用字节码的好处是什么?**\n\n> 在 Java 中，JVM 可以理解的代码就叫做`字节码`（即扩展名为 `.class` 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。\n\n**Java 程序从源代码到运行一般有下面 3 步：**\n\n![Java程序运行过程](Java基础知识.assets/Java 程序运行过程.png)\n\n我们需要格外注意的是 .class->机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。\n\n> HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。\n\n**总结：**\n\nJava 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。\n\n#### JDK 和 JRE\n\nJDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。\n\nJRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。\n\n如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。\n\n### 为什么说 Java 语言“编译与解释并存”？\n\n高级编程语言按照程序的执行方式分为编译型和解释型两种。简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。比如，你想阅读一本英文名著，你可以找一个英文翻译人员帮助你阅读，\n有两种选择方式，你可以先等翻译人员将全本的英文名著（也就是源码）都翻译成汉语，再去阅读，也可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。\n\nJava 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（`*.class` 文件），这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存。\n\n### Oracle JDK 和 OpenJDK 的对比\n\n可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么 Oracle JDK 和 OpenJDK 之间是否存在重大差异？下面我通过收集到的一些资料，为你解答这个被很多人忽视的问题。\n\n对于 Java 7，没什么关键的地方。OpenJDK 项目主要基于 Sun 捐赠的 HotSpot 源代码。此外，OpenJDK 被选为 Java 7 的参考实现，由 Oracle 工程师维护。关于 JVM，JDK，JRE 和 OpenJDK 之间的区别，Oracle 博客帖子在 2012 年有一个更详细的答案：\n\n> 问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？\n>\n> 答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些闭源的第三方组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。\n\n**总结：**\n\n1. Oracle JDK 大概每 6 个月发一次主要版本，而 OpenJDK 版本大概每三个月发布一次。但这不是固定的，我觉得了解这个没啥用处。详情参见：[https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence](https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence) 。\n2. OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；\n3. Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；\n4. 在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；\n5. Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；\n6. Oracle JDK 使用 BCL/OTN 协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。\n\n🌈 拓展一下：\n\n- BCL 协议（Oracle Binary Code License Agreement）： 可以使用JDK（支持商用），但是不能进行修改。\n- OTN 协议（Oracle Technology Network License Agreement）： 11 及之后新发布的JDK用的都是这个协议，可以自己私下用，但是商用需要付费。\n\n![](Java基础知识.assets/20210425151835918.png)\n\n相关阅读👍：[《Differences Between Oracle JDK and OpenJDK》](https://www.baeldung.com/oracle-jdk-vs-openjdk)\n\n### Java 和 C++的区别?\n\n我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来！\n\n- 都是面向对象的语言，都支持封装、继承和多态\n- Java 不提供指针来直接访问内存，程序内存更加安全\n- Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。\n- Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。\n- C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。\n- ......\n\n### import java 和 javax 有什么区别？\n\n刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准 API 的一部分。\n\n所以，实际上 java 和 javax 没有区别。这都是一个名字。\n\n## 基本语法\n\n### 字符型常量和字符串常量的区别?\n\n1. **形式** : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符\n2. **含义** : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)\n3. **占内存大小** ： 字符常量只占 2 个字节; 字符串常量占若干个字节 (**注意： char 在 Java 中占两个字节**),\n\n   > 字符封装类 `Character` 有一个成员常量 `Character.SIZE` 值为 16,单位是`bits`,该值除以 8(`1byte=8bits`)后就可以得到 2 个字节\n\n> java 编程思想第四版：2.2.2 节\n> ![](Java基础知识.assets/86735519.jpg)\n\n### 注释\n\nJava 中的注释有三种：\n\n1. 单行注释\n\n2. 多行注释\n\n3. 文档注释。\n\n在我们编写代码的时候，如果代码量比较少，我们自己或者团队其他成员还可以很轻易地看懂代码，但是当项目结构一旦复杂起来，我们就需要用到注释了。注释并不会执行(编译器在编译代码之前会把代码中的所有注释抹掉,字节码中不保留注释)，是我们程序员写给自己看的，注释是你的代码说明书，能够帮助看代码的人快速地理清代码之间的逻辑关系。因此，在写程序的时候随手加上注释是一个非常好的习惯。\n\n《Clean Code》这本书明确指出：\n\n> **代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。**\n>\n> **若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。**\n>\n> 举个例子：\n>\n> 去掉下面复杂的注释，只需要创建一个与注释所言同一事物的函数即可\n>\n> ```java\n> // check to see if the employee is eligible for full benefits\n> if ((employee.flags & HOURLY_FLAG) && (employee.age > 65))\n> ```\n>\n> 应替换为\n>\n> ```java\n> if (employee.isEligibleForFullBenefits())\n> ```\n\n### 标识符和关键字的区别是什么？\n\n在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了标识符，简单来说，标识符就是一个名字。但是有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这种特殊的标识符就是关键字。因此，关键字是被赋予特殊含义的标识符。比如，在我们的日常生活中 ，“警察局”这个名字已经被赋予了特殊的含义，所以如果你开一家店，店的名字不能叫“警察局”，“警察局”就是我们日常生活中的关键字。\n\n### Java 中有哪些常见的关键字？\n\n| 分类             | 关键字  |   |    |              |            |           |        |\n| :-------------------- | -------- | ---------- | -------- | ------------ | ---------- | --------- | ------ |\n| 访问控制             | private  | protected  | public   |              |            |           |        |\n| 类，方法和变量修饰符 | abstract | class      | extends  | final        | implements | interface | native |\n|                      | new      | static     | strictfp | synchronized | transient  | volatile  |        |\n| 程序控制             | break    | continue   | return   | do           | while      | if        | else   |\n|                      | for      | instanceof | switch   | case         | default    |           |        |\n| 错误处理             | try      | catch      | throw    | throws       | finally    |           |        |\n| 包相关               | import   | package    |          |              |            |           |        |\n| 基本类型             | boolean  | byte       | char     | double       | float      | int       | long   |\n|                      | short    | null       | true     | false        |            |           |        |\n| 变量引用             | super    | this       | void     |              |            |           |        |\n| 保留字               | goto     | const      |          |              |            |           |        |\n\n### 自增自减运算符\n\n在写代码的过程中，常见的一种情况是需要某个整数类型变量增加 1 或减少 1，Java 提供了一种特殊的运算符，用于这种表达式，叫做自增运算符（++)和自减运算符（--）。\n\n++和--运算符可以放在变量之前，也可以放在变量之后，当运算符放在变量之前时(前缀)，先自增/减，再赋值；当运算符放在变量之后时(后缀)，先赋值，再自增/减。例如，当 `b = ++a` 时，先自增（自己增加 1），再赋值（赋值给 b）；当 `b = a++` 时，先赋值(赋值给 b)，再自增（自己增加 1）。也就是，++a 输出的是 a+1 的值，a++输出的是 a 值。用一句口诀就是：“符号在前就先加/减，符号在后就后加/减”。\n\n### continue、break、和 return 的区别是什么？\n\n在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：\n\n1. continue ：指跳出当前的这一次循环，继续下一次循环。\n2. break ：指跳出整个循环体，继续执行循环下面的语句。\n\nreturn 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：\n\n1. `return;` ：直接使用 return 结束方法执行，用于没有返回值函数的方法\n2. `return value;` ：return 一个特定值，用于有返回值函数的方法\n\n### Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？\n\nJava 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。\n\nJava 的泛型是伪泛型，这是因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。\n\n```java\nList<Integer> list = new ArrayList<>();\n\nlist.add(12);\n//这里直接添加会报错\nlist.add("a");\nClass<? extends List> clazz = list.getClass();\nMethod add = clazz.getDeclaredMethod("add", Object.class);\n//但是通过反射添加，是可以的\nadd.invoke(list, "kl");\n\nSystem.out.println(list);\n```\n\n泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。\n\n**1.泛型类**：\n\n```java\n//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型\n//在实例化泛型类时，必须指定T的具体类型\npublic class Generic<T> {\n\n    private T key;\n\n    public Generic(T key) {\n        this.key = key;\n    }\n\n    public T getKey() {\n        return key;\n    }\n}\n```\n\n如何实例化泛型类：\n\n```java\nGeneric<Integer> genericInteger = new Generic<Integer>(123456);\n```\n\n**2.泛型接口** ：\n\n```java\npublic interface Generator<T> {\n    public T method();\n}\n```\n\n实现泛型接口，不指定类型：\n\n```java\nclass GeneratorImpl<T> implements Generator<T>{\n    @Override\n    public T method() {\n        return null;\n    }\n}\n```\n\n实现泛型接口，指定类型：\n\n```java\nclass GeneratorImpl implements Generator<String>{\n    @Override\n    public String method() {\n        return "hello";\n    }\n}\n```\n\n**3.泛型方法** ：\n\n```java\npublic static <E> void printArray(E[] inputArray) {\n    for (E element : inputArray) {\n        System.out.printf("%s ", element);\n    }\n    System.out.println();\n}\n```\n\n使用：\n\n```java\n// 创建不同类型数组： Integer, Double 和 Character\nInteger[] intArray = { 1, 2, 3 };\nString[] stringArray = { "Hello", "World" };\nprintArray(intArray);\nprintArray(stringArray);\n```\n\n**常用的通配符为： T，E，K，V，？**\n\n- ？ 表示不确定的 java 类型\n- T (type) 表示具体的一个 java 类型\n- K V (key value) 分别代表 java 键值中的 Key Value\n- E (element) 代表 Element\n\n### ==和 equals 的区别\n\n对于基本数据类型来说，==比较的是值。对于引用数据类型来说，==比较的是对象的内存地址。\n\n> 因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。\n\n**`equals()`** 作用不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。`equals()`方法存在于`Object`类中，而`Object`类是所有类的直接或间接父类。\n\n`Object` 类 `equals()` 方法：\n\n```java\npublic boolean equals(Object obj) {\n     return (this == obj);\n}\n```\n\n`equals()` 方法存在两种使用情况：\n\n- **类没有覆盖 `equals()`方法** ：通过`equals()`比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 `Object`类`equals()`方法。\n- **类覆盖了 `equals()`方法** ：一般我们都覆盖 `equals()`方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。\n\n**举个例子：**\n\n```java\npublic class test1 {\n    public static void main(String[] args) {\n        String a = new String("ab"); // a 为一个引用\n        String b = new String("ab"); // b为另一个引用,对象的内容一样\n        String aa = "ab"; // 放在常量池中\n        String bb = "ab"; // 从常量池中查找\n        if (aa == bb) // true\n            System.out.println("aa==bb");\n        if (a == b) // false，非同一对象\n            System.out.println("a==b");\n        if (a.equals(b)) // true\n            System.out.println("aEQb");\n        if (42 == 42.0) { // true\n            System.out.println("true");\n        }\n    }\n}\n```\n\n**说明：**\n\n- `String` 中的 `equals` 方法是被重写过的，因为 `Object` 的 `equals` 方法是比较的对象的内存地址，而 `String` 的 `equals` 方法比较的是对象的值。\n- 当创建 `String` 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 `String` 对象。\n\n`String`类`equals()`方法：\n\n```java\npublic boolean equals(Object anObject) {\n    if (this == anObject) {\n        return true;\n    }\n    if (anObject instanceof String) {\n        String anotherString = (String)anObject;\n        int n = value.length;\n        if (n == anotherString.value.length) {\n            char v1[] = value;\n            char v2[] = anotherString.value;\n            int i = 0;\n            while (n-- != 0) {\n                if (v1[i] != v2[i])\n                    return false;\n                i++;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n### hashCode()与 equals()\n\n面试官可能会问你：“你重写过 `hashcode` 和 `equals`么，为什么重写 `equals` 时必须重写 `hashCode` 方法？”\n\n**1)hashCode()介绍:**\n\n`hashCode()` 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。`hashCode()`定义在 JDK 的 `Object` 类中，这就意味着 Java 中的任何类都包含有 `hashCode()` 函数。另外需要注意的是： `Object` 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。\n\n```java\npublic native int hashCode();\n```\n\n散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）\n\n**2)为什么要有 hashCode？**\n\n我们以“`HashSet` 如何检查重复”为例子来说明为什么要有 hashCode？\n\n当你把对象加入 `HashSet` 时，`HashSet` 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，`HashSet` 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 `equals()` 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head First Java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。\n\n**3)为什么重写 `equals` 时必须重写 `hashCode` 方法？**\n\n如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。**因此，equals 方法被覆盖过，则 `hashCode` 方法也必须被覆盖。**\n\n> `hashCode()`的默认行为是对堆上的对象产生独特值。如果没有重写 `hashCode()`，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）\n\n**4)为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？**\n\n在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。\n\n因为 `hashCode()` 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 `hashCode` )。\n\n我们刚刚也提到了 `HashSet`,如果 `HashSet` 在对比的时候，同样的 hashcode 有多个对象，它会使用 `equals()` 来判断是否真的相同。也就是说 `hashcode` 只是用来缩小查找成本。\n\n更多关于 `hashcode()` 和 `equals()` 的内容可以查看：[Java hashCode() 和 equals()的若干问题解答](https://www.cnblogs.com/skywang12345/p/3324958.html)\n\n## 基本数据类型\n\n### Java 中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？\n\nJava 中有 8 种基本数据类型，分别为：\n\n1. 6 种数字类型 ：`byte`、`short`、`int`、`long`、`float`、`double`\n2. 1 种字符类型：`char`\n3. 1 种布尔型：`boolean`。\n\n这 8 种基本数据类型的默认值以及所占空间的大小如下：\n\n| 基本类型  | 位数 | 字节 | 默认值  |\n| :-------- | :--- | :--- | :------ |\n| `int`     | 32   | 4    | 0       |\n| `short`   | 16   | 2    | 0       |\n| `long`    | 64   | 8    | 0L      |\n| `byte`    | 8    | 1    | 0       |\n| `char`    | 16   | 2    | \'u0000\' |\n| `float`   | 32   | 4    | 0f      |\n| `double`  | 64   | 8    | 0d      |\n| `boolean` | 1    |      | false   |\n\n另外，对于 `boolean`，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。\n\n**注意：**\n\n1. Java 里使用 `long` 类型的数据一定要在数值后面加上 **L**，否则将作为整型解析。\n2. `char a = \'h\'`char :单引号，`String a = "hello"` :双引号。\n\n这八种基本类型都有对应的包装类分别为：`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`、`Boolean` 。\n\n包装类型不赋值就是 `Null` ，而基本类型有默认值且不是 `Null`。\n\n另外，这个问题建议还可以先从 JVM 层面来分析。\n\n基本数据类型直接存放在 Java 虚拟机栈中的局部变量表中，而包装类型属于对象类型，我们知道对象实例都存在于堆中。相比于对象类型， 基本数据类型占用的空间非常小。\n\n> 《深入理解 Java 虚拟机》 ：局部变量表主要存放了编译期可知的基本数据类型 **（boolean、byte、char、short、int、float、long、double）**、**对象引用**（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。\n\n### 自动装箱与拆箱\n\n- **装箱**：将基本类型用它们对应的引用类型包装起来；\n- **拆箱**：将包装类型转换为基本数据类型；\n\n举例：\n\n```java\nInteger i = 10;  //装箱\nint n = i;   //拆箱\n```\n\n上面这两行代码对应的字节码为：\n\n```java\n   L1\n\n    LINENUMBER 8 L1\n\n    ALOAD 0\n\n    BIPUSH 10\n\n    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;\n\n    PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;\n\n   L2\n\n    LINENUMBER 9 L2\n\n    ALOAD 0\n\n    ALOAD 0\n\n    GETFIELD AutoBoxTest.i : Ljava/lang/Integer;\n\n    INVOKEVIRTUAL java/lang/Integer.intValue ()I\n\n    PUTFIELD AutoBoxTest.n : I\n\n    RETURN\n```\n\n从字节码中，我们发现装箱其实就是调用了 包装类的`valueOf()`方法，拆箱其实就是调用了 `xxxValue()`方法。\n\n因此，\n\n- `Integer i = 10` 等价于 `Integer i = Integer.valueOf(10)`\n- `int n = i` 等价于 `int n = i.intValue()`;\n\n### 8 种基本类型的包装类和常量池\n\nJava 基本类型的包装类的大部分都实现了常量池技术。`Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，`Character` 创建了数值在[0,127]范围的缓存数据，`Boolean` 直接返回 `True` Or `False`。\n\n**Integer 缓存源码：**\n\n```java\n/**\n\n*此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。\n\n*/\n\npublic static Integer valueOf(int i) {\n\n    if (i >= IntegerCache.low && i <= IntegerCache.high)\n\n      return IntegerCache.cache[i + (-IntegerCache.low)];\n\n    return new Integer(i);\n\n}\n\nprivate static class IntegerCache {\n\n    static final int low = -128;\n\n    static final int high;\n\n    static final Integer cache[];\n\n}\n```\n\n**`Character` 缓存源码:**\n\n```java\npublic static Character valueOf(char c) {\n\n    if (c <= 127) { // must cache\n\n      return CharacterCache.cache[(int)c];\n\n    }\n\n    return new Character(c);\n\n}\n\n\n\nprivate static class CharacterCache {\n\n    private CharacterCache(){}\n\n\n\n    static final Character cache[] = new Character[127 + 1];\n\n    static {\n\n        for (int i = 0; i < cache.length; i++)\n\n            cache[i] = new Character((char)i);\n\n    }\n\n}\n```\n\n**`Boolean` 缓存源码：**\n\n```java\npublic static Boolean valueOf(boolean b) {\n\n    return (b ? TRUE : FALSE);\n\n}\n```\n\n如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。\n\n两种浮点数类型的包装类 `Float`,`Double` 并没有实现常量池技术。\n\n```java\nInteger i1 = 33;\n\nInteger i2 = 33;\n\nSystem.out.println(i1 == i2);// 输出 true\n\nFloat i11 = 333f;\n\nFloat i22 = 333f;\n\nSystem.out.println(i11 == i22);// 输出 false\n\nDouble i3 = 1.2;\n\nDouble i4 = 1.2;\n\nSystem.out.println(i3 == i4);// 输出 false\n```\n\n下面我们来看一下问题。下面的代码的输出结果是 `true` 还是 `flase` 呢？\n\n```java\nInteger i1 = 40;\n\nInteger i2 = new Integer(40);\n\nSystem.out.println(i1==i2);\n```\n\n`Integer i1=40` 这一行代码会发生装箱，也就是说这行代码等价于 `Integer i1=Integer.valueOf(40)` 。因此，`i1` 直接使用的是常量池中的对象。而`Integer i1 = new Integer(40)` 会直接创建新的对象。\n\n因此，答案是 `false` 。你答对了吗？\n\n记住：**所有整型包装类对象之间值的比较，全部使用 equals 方法比较**。\n\n![](https://img-blog.csdnimg.cn/20210422164544846.png)\n\n## 方法（函数）\n\n### 什么是方法的返回值?\n\n方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用是接收出结果，使得它可以用于其他的操作！\n\n### 方法有哪几种类型？\n\n**1.无参数无返回值的方法**\n\n```java\n// 无参数无返回值的方法(如果方法没有返回值，不能不写，必须写void，表示没有返回值)\npublic void f1() {\n    System.out.println("无参数无返回值的方法");\n}\n```\n\n**2.有参数无返回值的方法**\n\n```java\n/**\n* 有参数无返回值的方法\n* 参数列表由零组到多组“参数类型+形参名”组合而成，多组参数之间以英文逗号（,）隔开，形参类型和形参名之间以英文空格隔开\n*/\npublic void f2(int a, String b, int c) {\n    System.out.println(a + "--\x3e" + b + "--\x3e" + c);\n}\n```\n\n**3.有返回值无参数的方法**\n\n```java\n// 有返回值无参数的方法（返回值可以是任意的类型,在函数里面必须有return关键字返回对应的类型）\npublic int f3() {\n    System.out.println("有返回值无参数的方法");\n    return 2;\n}\n```\n\n**4.有返回值有参数的方法**\n\n```java\n// 有返回值有参数的方法\npublic int f4(int a, int b) {\n    return a * b;\n}\n```\n\n**5.return 在无返回值方法的特殊使用**\n\n```java\n// return在无返回值方法的特殊使用\npublic void f5(int a) {\n    if (a > 10) {\n        return;//表示结束所在方法 （f5方法）的执行,下方的输出语句不会执行\n    }\n    System.out.println(a);\n}\n```\n\n### 在一个静态方法内调用一个非静态成员为什么是非法的?\n\n这个需要结合 JVM 的相关知识，静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，然后通过类的实例对象去访问。在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。\n\n### 静态方法和实例方法有何不同？\n\n**1、调用方式**\n\n在外部调用静态方法时，可以使用 `类名.方法名` 的方式，也可以使用 `对象.方法名` 的方式，而实例方法只有后面这种方式。也就是说，**调用静态方法可以无需创建对象** 。\n\n不过，需要注意的是一般不建议使用 `对象.方法名` 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。\n\n因此，一般建议使用  `类名.方法名` 的方式来调用静态方法。\n\n```java\n\npublic class Person {\n    public void method() { \n      //......\n    }\n \n    public static void staicMethod(){\n      //......\n    }\n    public static void main(String[] args) {\n        Person person = new Person();\n        // 调用实例方法\n        person.method(); \n        // 调用静态方法\n        Person.staicMethod()\n    }\n}\n```\n\n**2、访问类成员是否存在限制**\n\n静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。\n\n### 为什么 Java 中只有值传递？\n\n首先，我们回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。\n\n**按值调用(call by value)** 表示方法接收的是调用者提供的值，**按引用调用（call by reference)** 表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。它用来描述各种程序设计语言（不只是 Java）中方法参数传递方式。\n\n**Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。**\n\n**下面通过 3 个例子来给大家说明**\n\n> **example 1**\n\n```java\npublic static void main(String[] args) {\n    int num1 = 10;\n    int num2 = 20;\n\n    swap(num1, num2);\n\n    System.out.println("num1 = " + num1);\n    System.out.println("num2 = " + num2);\n}\n\npublic static void swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n\n    System.out.println("a = " + a);\n    System.out.println("b = " + b);\n}\n```\n\n**结果：**\n\n```\na = 20\nb = 10\nnum1 = 10\nnum2 = 20\n```\n\n**解析：**\n\n![example 1 ](Java基础知识.assets/22191348.jpg)\n\n在 swap 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 中的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。\n\n**通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.**\n\n> **example 2**\n\n```java\n\tpublic static void main(String[] args) {\n\t\tint[] arr = { 1, 2, 3, 4, 5 };\n\t\tSystem.out.println(arr[0]);\n\t\tchange(arr);\n\t\tSystem.out.println(arr[0]);\n\t}\n\n\tpublic static void change(int[] array) {\n\t\t// 将数组的第一个元素变为0\n\t\tarray[0] = 0;\n\t}\n```\n\n**结果：**\n\n```\n1\n0\n```\n\n**解析：**\n\n![example 2](Java基础知识.assets/3825204.jpg)\n\narray 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的是同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。\n\n**通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。**\n\n**很多程序设计语言（特别是，C++和 Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为 Java 程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。**\n\n> **example 3**\n\n```java\npublic class Test {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tStudent s1 = new Student("小张");\n\t\tStudent s2 = new Student("小李");\n\t\tTest.swap(s1, s2);\n\t\tSystem.out.println("s1:" + s1.getName());\n\t\tSystem.out.println("s2:" + s2.getName());\n\t}\n\n\tpublic static void swap(Student x, Student y) {\n\t\tStudent temp = x;\n\t\tx = y;\n\t\ty = temp;\n\t\tSystem.out.println("x:" + x.getName());\n\t\tSystem.out.println("y:" + y.getName());\n\t}\n}\n```\n\n**结果：**\n\n```\nx:小李\ny:小张\ns1:小张\ns2:小李\n```\n\n**解析：**\n\n交换之前：\n\n![](Java基础知识.assets/88729818.jpg)\n\n交换之后：\n\n![](Java基础知识.assets/34384414.jpg)\n\n通过上面两张图可以很清晰的看出： **方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝**\n\n> **总结**\n\nJava 程序设计语言对对象采用的不是引用调用，实际上，对象引用是按\n值传递的。\n\n下面再总结一下 Java 中方法参数的使用情况：\n\n- 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。\n- 一个方法可以改变一个对象参数的状态。\n- 一个方法不能让对象参数引用一个新的对象。\n\n**参考：**\n\n《Java 核心技术卷 Ⅰ》基础知识第十版第四章 4.5 小节\n\n### 重载和重写的区别\n\n> 重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理\n>\n> 重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法\n\n#### 重载\n\n发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。\n\n下面是《Java 核心技术》对重载这个概念的介绍：\n\n![](Java基础知识.assets/desktopjava核心技术-重载.jpg)\n\n综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。\n\n#### 重写\n\n重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。\n\n1. 返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。\n2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。\n3. 构造方法无法被重写\n\n综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变\n\n暖心的 Guide 哥最后再来个图表总结一下！\n\n| 区别点     | 重载方法 | 重写方法                                                     |\n| :--------- | :------- | :----------------------------------------------------------- |\n| 发生范围   | 同一个类 | 子类                                                         |\n| 参数列表   | 必须修改 | 一定不能修改                                                 |\n| 返回类型   | 可修改   | 子类方法返回值类型应比父类方法返回值类型更小或相等           |\n| 异常       | 可修改   | 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等； |\n| 访问修饰符 | 可修改   | 一定不能做更严格的限制（可以降低限制）                       |\n| 发生阶段   | 编译期   | 运行期                                                       |\n\n**方法的重写要遵循“两同两小一大”**（以下内容摘录自《疯狂 Java 讲义》,[issue#892](https://github.com/Snailclimb/JavaGuide/issues/892) ）：\n\n- “两同”即方法名相同、形参列表相同；\n- “两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；\n- “一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。\n\n⭐️ 关于 **重写的返回值类型** 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。\n\n```java\npublic class Hero {\n    public String name() {\n        return "超级英雄";\n    }\n}\npublic class SuperMan extends Hero{\n    @Override\n    public String name() {\n        return "超人";\n    }\n    public Hero hero() {\n        return new Hero();\n    }\n}\n\npublic class SuperSuperMan extends SuperMan {\n    public String name() {\n        return "超级超级英雄";\n    }\n\n    @Override\n    public SuperMan hero() {\n        return new SuperMan();\n    }\n}\n```\n\n### 深拷贝 vs 浅拷贝\n\n1. **浅拷贝**：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。\n2. **深拷贝**：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。\n\n![deep and shallow copy](Java基础知识.assets/java-deep-and-shallow-copy.jpg)\n\n## Java 面向对象\n\n### 面向对象和面向过程的区别\n\n- **面向过程** ：**面向过程性能比面向对象高。** 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，**面向过程没有面向对象易维护、易复用、易扩展。**\n- **面向对象** ：**面向对象易维护、易复用、易扩展。** 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，**面向对象性能比面向过程低**。\n\n参见 issue : [面向过程 ：面向过程性能比面向对象高？？](https://github.com/Snailclimb/JavaGuide/issues/431)\n\n> 这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码。\n>\n> 而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比 Java 好。\n\n### 成员变量与局部变量的区别有哪些？\n\n1. 从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 `public`,`private`,`static` 等修饰符所修饰，而局部变量不能被访问控制修饰符及 `static` 所修饰；但是，成员变量和局部变量都能被 `final` 所修饰。\n2. 从变量在内存中的存储方式来看,如果成员变量是使用 `static` 修饰的，那么这个成员变量是属于类的，如果没有使用 `static` 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。\n3. 从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。\n4. 从变量是否有默认值来看，成员变量如果没有被赋初，则会自动以类型的默认值而赋值（一种情况例外:被 `final` 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。\n\n### 创建一个对象用什么运算符?对象实体与对象引用有何不同?\n\nnew 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。\n\n一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。\n\n### 对象的相等与指向他们的引用相等,两者有什么不同?\n\n对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。\n\n### 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?\n\n构造方法主要作用是完成对类对象的初始化工作。\n\n如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，这时候，就不能直接 new 一个对象而不传递参数了，所以我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。\n\n### 构造方法有哪些特点？是否可被 override?\n\n特点：\n\n1. 名字与类名相同。\n2. 没有返回值，但不能用 void 声明构造函数。\n3. 生成类的对象时自动执行，无需调用。\n\n构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。\n\n### 面向对象三大特征\n\n#### 封装\n\n封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。\n\n```java\npublic class Student {\n    private int id;//id属性私有化\n    private String name;//name属性私有化\n\n    //获取id的方法\n    public int getId() {\n        return id;\n    }\n\n    //设置id的方法\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    //获取name的方法\n    public String getName() {\n        return name;\n    }\n\n    //设置name的方法\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n```\n\n#### 继承\n\n不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。\n\n**关于继承如下 3 点请记住：**\n\n1. 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。\n2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。\n3. 子类可以用自己的方式实现父类的方法。（以后介绍）。\n\n#### 多态\n\n多态，顾名思义，表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。\n\n**多态的特点:**\n\n- 对象类型和引用类型之间具有继承（类）/实现（接口）的关系；\n- 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；\n- 多态不能调用“只在子类存在但在父类不存在”的方法；\n- 如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。\n\n### String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?\n\n**可变性**\n\n简单的来说：`String` 类中使用 final 关键字修饰字符数组来保存字符串，`private final char value[]`，所以`String` 对象是不可变的。\n\n> 补充（来自[issue 675](https://github.com/Snailclimb/JavaGuide/issues/675)）：在 Java 9 之后，String 、`StringBuilder` 与 `StringBuffer` 的实现改用 byte 数组存储字符串 `private final byte[] value`\n\n而 `StringBuilder` 与 `StringBuffer` 都继承自 `AbstractStringBuilder` 类，在 `AbstractStringBuilder` 中也是使用字符数组保存字符串`char[]value` 但是没有用 `final` 关键字修饰，所以这两种对象都是可变的。\n\n`StringBuilder` 与 `StringBuffer` 的构造方法都是调用父类构造方法也就是`AbstractStringBuilder` 实现的，大家可以自行查阅源码。\n\n`AbstractStringBuilder.java`\n\n```java\nabstract class AbstractStringBuilder implements Appendable, CharSequence {\n    /**\n     * The value is used for character storage.\n     */\n    char[] value;\n\n    /**\n     * The count is the number of characters used.\n     */\n    int count;\n\n    AbstractStringBuilder(int capacity) {\n        value = new char[capacity];\n    }}\n```\n\n**线程安全性**\n\n`String` 中的对象是不可变的，也就可以理解为常量，线程安全。`AbstractStringBuilder` 是 `StringBuilder` 与 `StringBuffer` 的公共父类，定义了一些字符串的基本操作，如 `expandCapacity`、`append`、`insert`、`indexOf` 等公共方法。`StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。`StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的。\n\n**性能**\n\n每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。`StringBuffer` 每次都会对 `StringBuffer` 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 `StringBuilder` 相比使用 `StringBuffer` 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。\n\n**对于三者使用的总结：**\n\n1. 操作少量的数据: 适用 `String`\n2. 单线程操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`\n3. 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer`\n\n### Object 类的常见方法总结\n\nObject 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：\n\n```java\npublic final native Class<?> getClass()//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。\n\npublic native int hashCode() //native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。\npublic boolean equals(Object obj)//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。\n\nprotected native Object clone() throws CloneNotSupportedException//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。\n\npublic String toString()//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。\n\npublic final native void notify()//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。\n\npublic final native void notifyAll()//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。\n\npublic final native void wait(long timeout) throws InterruptedException//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。\n\npublic final void wait(long timeout, int nanos) throws InterruptedException//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。\n\npublic final void wait() throws InterruptedException//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念\n\nprotected void finalize() throws Throwable { }//实例被垃圾回收器回收的时候触发的操作\n```\n\n\n## 反射\n\n### 何为反射？\n\n如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。\n\n反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。\n\n通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。\n\n### 反射机制优缺点\n\n- **优点** ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利\n- **缺点** ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。[Java Reflection: Why is it so slow?](https://stackoverflow.com/questions/1392351/java-reflection-why-is-it-so-slow)\n\n### 反射的应用场景\n\n像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。\n\n但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。\n\n**这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。**\n\n比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 `Method` 来调用指定的方法。\n\n```java\npublic class DebugInvocationHandler implements InvocationHandler {\n    /**\n     * 代理类中的真实对象\n     */\n    private final Object target;\n\n    public DebugInvocationHandler(Object target) {\n        this.target = target;\n    }\n\n\n    public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {\n        System.out.println("before method " + method.getName());\n        Object result = method.invoke(target, args);\n        System.out.println("after method " + method.getName());\n        return result;\n    }\n}\n\n```\n\n另外，像 Java 中的一大利器 **注解** 的实现也用到了反射。\n\n为什么你使用 Spring 的时候 ，一个`@Component`注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 `@Value`注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？\n\n这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。\n\n## 异常\n\n### Java 异常类层次结构图\n\n![](Java基础知识.assets/Java异常类层次结构图.png)\n\n<p style="font-size:13px;text-align:right">图片来自：https://simplesnippets.tech/exception-handling-in-java-part-1/</p>\n\n![](Java基础知识.assets/Java异常类层次结构图2.png)\n\n<p style="font-size:13px;text-align:right">图片来自：https://chercher.tech/java-programming/exceptions-java</p>\n\n在 Java 中，所有的异常都有一个共同的祖先 `java.lang` 包中的 `Throwable` 类。`Throwable` 类有两个重要的子类 `Exception`（异常）和 `Error`（错误）。`Exception` 能被程序本身处理(`try-catch`)， `Error` 是无法处理的(只能尽量避免)。\n\n`Exception` 和 `Error` 二者都是 Java 异常处理的重要子类，各自都包含大量子类。\n\n- **`Exception`** :程序本身可以处理的异常，可以通过 `catch` 来进行捕获。`Exception` 又可以分为 受检查异常(必须处理) 和 不受检查异常(可以不处理)。\n- **`Error`** ：`Error` 属于程序无法处理的错误 ，我们没办法通过 `catch` 来进行捕获 。例如，Java 虚拟机运行错误（`Virtual MachineError`）、虚拟机内存不够错误(`OutOfMemoryError`)、类定义错误（`NoClassDefFoundError`）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。\n\n**受检查异常**\n\nJava 代码在编译过程中，如果受检查异常没有被 `catch`/`throw` 处理的话，就没办法通过编译 。比如下面这段 IO 操作的代码。\n\n![check-exception](Java基础知识.assets/check-exception.png)\n\n除了`RuntimeException`及其子类以外，其他的`Exception`类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、`ClassNotFoundException` 、`SQLException`...。\n\n**不受检查异常**\n\nJava 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。\n\n`RuntimeException` 及其子类都统称为非受检查异常，例如：`NullPointerException`、`NumberFormatException`（字符串转换为数字）、`ArrayIndexOutOfBoundsException`（数组越界）、`ClassCastException`（类型转换错误）、`ArithmeticException`（算术错误）等。\n\n### Throwable 类常用方法\n\n- **`public String getMessage()`**:返回异常发生时的简要描述\n- **`public String toString()`**:返回异常发生时的详细信息\n- **`public String getLocalizedMessage()`**:返回异常对象的本地化信息。使用 `Throwable` 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 `getMessage()`返回的结果相同\n- **`public void printStackTrace()`**:在控制台上打印 `Throwable` 对象封装的异常信息\n\n### try-catch-finally\n\n- **`try`块：** 用于捕获异常。其后可接零个或多个 `catch` 块，如果没有 `catch` 块，则必须跟一个 `finally` 块。\n- **`catch`块：** 用于处理 try 捕获到的异常。\n- **`finally` 块：** 无论是否捕获或处理异常，`finally` 块里的语句都会被执行。当在 `try` 块或 `catch` 块中遇到 `return` 语句时，`finally` 语句块将在方法返回之前被执行。\n\n**在以下 3 种特殊情况下，`finally` 块不会被执行：**\n\n1. 在 `try` 或 `finally`块中用了 `System.exit(int)`退出程序。但是，如果 `System.exit(int)` 在异常语句之后，`finally` 还是会被执行\n2. 程序所在的线程死亡。\n3. 关闭 CPU。\n\n下面这部分内容来自 issue:<https://github.com/Snailclimb/JavaGuide/issues/190>。\n\n**注意：** 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：\n\n```java\npublic class Test {\n    public static int f(int value) {\n        try {\n            return value * value;\n        } finally {\n            if (value == 2) {\n                return 0;\n            }\n        }\n    }\n}\n```\n\n如果调用 `f(2)`，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。\n\n### 使用 `try-with-resources` 来代替`try-catch-finally`\n\n1. **适用范围（资源的定义）：** 任何实现 `java.lang.AutoCloseable`或者 `java.io.Closeable` 的对象\n2. **关闭资源和 finally 块的执行顺序：** 在 `try-with-resources` 语句中，任何 catch 或 finally 块在声明的资源关闭后运行\n\n《Effecitve Java》中明确指出：\n\n> 面对必须要关闭的资源，我们总是应该优先使用 `try-with-resources` 而不是`try-finally`。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。`try-with-resources`语句让我们更容易编写必须要关闭的资源的代码，若采用`try-finally`则几乎做不到这点。\n\nJava 中类似于`InputStream`、`OutputStream` 、`Scanner` 、`PrintWriter`等的资源都需要我们调用`close()`方法来手动关闭，一般情况下我们都是通过`try-catch-finally`语句来实现这个需求，如下：\n\n```java\n        //读取文本文件的内容\n        Scanner scanner = null;\n        try {\n            scanner = new Scanner(new File("D://read.txt"));\n            while (scanner.hasNext()) {\n                System.out.println(scanner.nextLine());\n            }\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } finally {\n            if (scanner != null) {\n                scanner.close();\n            }\n        }\n```\n\n使用 Java 7 之后的 `try-with-resources` 语句改造上面的代码:\n\n```java\ntry (Scanner scanner = new Scanner(new File("test.txt"))) {\n    while (scanner.hasNext()) {\n        System.out.println(scanner.nextLine());\n    }\n} catch (FileNotFoundException fnfe) {\n    fnfe.printStackTrace();\n}\n```\n\n当然多个资源需要关闭的时候，使用 `try-with-resources` 实现起来也非常简单，如果你还是用`try-catch-finally`可能会带来很多问题。\n\n通过使用分号分隔，可以在`try-with-resources`块中声明多个资源。\n\n```java\ntry (BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File("test.txt")));\n             BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File("out.txt")))) {\n            int b;\n            while ((b = bin.read()) != -1) {\n                bout.write(b);\n            }\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n```\n\n## I/O 流\n\n### 什么是序列化?什么是反序列化?\n\n如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。\n\n简单来说：\n\n- **序列化**： 将数据结构或对象转换成二进制字节流的过程\n- **反序列化**：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程\n\n对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。\n\n维基百科是如是介绍序列化的：\n\n> **序列化**（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。\n\n综上：**序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。**\n\n![](Java基础知识.assets/a478c74d-2c48-40ae-9374-87aacf05188c.png)\n\n<p style="text-align:right;font-size:13px;color:gray">https://www.corejavaguru.com/java/serialization/interview-questions-1</p>\n\n### Java 序列化中如果有些字段不想进行序列化，怎么办？\n\n对于不想进行序列化的变量，使用 `transient` 关键字修饰。\n\n`transient` 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 `transient` 修饰的变量值不会被持久化和恢复。\n\n关于 `transient` 还有几点注意： \n- `transient` 只能修饰变量，不能修饰类和方法。\n- `transient` 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 `int` 类型，那么反序列后结果就是 `0`。\n- `static` 变量因为不属于任何对象(Object)，所以无论有没有 `transient` 关键字修饰，均不会被序列化。\n\n### 获取用键盘输入常用的两种方法\n\n方法 1：通过 `Scanner`\n\n```java\nScanner input = new Scanner(System.in);\nString s  = input.nextLine();\ninput.close();\n```\n\n方法 2：通过 `BufferedReader`\n\n```java\nBufferedReader input = new BufferedReader(new InputStreamReader(System.in));\nString s = input.readLine();\n```\n\n### Java 中 IO 流分为几种?\n\n- 按照流的流向分，可以分为输入流和输出流；\n- 按照操作单元划分，可以划分为字节流和字符流；\n- 按照流的角色划分为节点流和处理流。\n\nJava IO 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。\n\n- InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。\n- OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。\n\n按操作方式分类结构图：\n\n![IO-操作方式分类](Java基础知识.assets/IO-操作方式分类.png)\n\n按操作对象分类结构图：\n\n![IO-操作对象分类](Java基础知识.assets/IO-操作对象分类.png)\n\n### 既然有了字节流,为什么还要有字符流?\n\n问题本质想问：**不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？**\n\n回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。\n\n## 4. 参考\n\n- https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre\n- https://www.educba.com/oracle-vs-openjdk/\n- https://stackoverflow.com/questions/22358071/differences-between-oracle-jdk-and-openjdk 基础概念与常识\n'},1729:function(n,e,t){"use strict";t.r(e),e["default"]="大家好呀！今天和小伙伴们聊聊读写分离以及分库分表。\n\n相信很多小伙伴们对于这两个概念已经比较熟悉了，这篇文章全程都是大白话的形式，希望能够给你带来不一样的感受。\n\n如果你之前不太了解这两个概念，那我建议你搞懂之后，可以把自己对于读写分离以及分库分表的理解讲给你的同事/朋友听听。\n\n**原创不易，若有帮助，点赞/分享就是对我最大的鼓励！**\n\n_个人能力有限。如果文章有任何需要补充/完善/修改的地方，欢迎在评论区指出，共同进步！_\n\n# 读写分离&分库分表\n\n## 读写分离\n\n### 何为读写分离？\n\n见名思意，根据读写分离的名字，我们就可以知道：**读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。** 这样的话，就能够小幅提升写性能，大幅提升读性能。\n\n我简单画了一张图来帮助不太清楚读写分离的小伙伴理解。\n\n![读写分离](读写分离&分库分表.assets/9c624bc130d053860a5089cb9a53310a.png)\n\n一般情况下，我们都会选择一主多从，也就是一台主数据库负责写，其他的从数据库负责读。主库和从库之间会进行数据同步，以保证从库中数据的准确性。这样的架构实现起来比较简单，并且也符合系统的写少读多的特点。\n\n### 读写分离会带来什么问题？如何解决？\n\n读写分离对于提升数据库的并发非常有效，但是，同时也会引来一个问题：主库和从库的数据存在延迟，比如你写完主库之后，主库的数据同步到从库是需要时间的，这个时间差就导致了主库和从库的数据不一致性问题。这也就是我们经常说的 **主从同步延迟** 。\n\n主从同步延迟问题的解决，没有特别好的一种方案（可能是我太菜了，欢迎评论区补充）。你可以根据自己的业务场景，参考一下下面几种解决办法。\n\n**1.强制将读请求路由到主库处理。**\n\n既然你从库的数据过期了，那我就直接从主库读取嘛！这种方案虽然会增加主库的压力，但是，实现起来比较简单，也是我了解到的使用最多的一种方式。\n\n比如 `Sharding-JDBC` 就是采用的这种方案。通过使用 Sharding-JDBC 的 `HintManager` 分片键值管理器，我们可以强制使用主库。\n\n```java\nHintManager hintManager = HintManager.getInstance();\nhintManager.setMasterRouteOnly();\n// 继续JDBC操作\n```\n\n对于这种方案，你可以将那些必须获取最新数据的读请求都交给主库处理。\n\n**2.延迟读取。**\n\n还有一些朋友肯定会想既然主从同步存在延迟，那我就在延迟之后读取啊，比如主从同步延迟 0.5s,那我就 1s 之后再读取数据。这样多方便啊！方便是方便，但是也很扯淡。\n\n不过，如果你是这样设计业务流程就会好很多：对于一些对数据比较敏感的场景，你可以在完成写请求之后，避免立即进行请求操作。比如你支付成功之后，跳转到一个支付成功的页面，当你点击返回之后才返回自己的账户。\n\n另外，[《MySQL 实战 45 讲》](https://time.geekbang.org/column/intro/100020801?code=ieY8HeRSlDsFbuRtggbBQGxdTh-1jMASqEIeqzHAKrI%3D)这个专栏中的[《读写分离有哪些坑？》](https://time.geekbang.org/column/article/77636)这篇文章还介绍了很多其他比较实际的解决办法，感兴趣的小伙伴可以自行研究一下。\n\n### 如何实现读写分离？\n\n不论是使用哪一种读写分离具体的实现方案，想要实现读写分离一般包含如下几步：\n\n1. 部署多台数据库，选择其中的一台作为主数据库，其他的一台或者多台作为从数据库。\n2. 保证主数据库和从数据库之间的数据是实时同步的，这个过程也就是我们常说的**主从复制**。\n3. 系统将写请求交给主数据库处理，读请求交给从数据库处理。\n\n落实到项目本身的话，常用的方式有两种：\n\n**1.代理方式**\n\n![读写分离-代理层](读写分离&分库分表.assets/461112716e30db118f4c784adc6e2ff7.png)\n\n我们可以在应用和数据中间加了一个代理层。应用程序所有的数据请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中。\n\n提供类似功能的中间件有 **MySQL Router**（官方）、**Atlas**（基于 MySQL Proxy）、**Maxscale**、**MyCat**。\n\n**2.组件方式**\n\n在这种方式中，我们可以通过引入第三方组件来帮助我们读写请求。\n\n这也是我比较推荐的一种方式。这种方式目前在各种互联网公司中用的最多的，相关的实际的案例也非常多。如果你要采用这种方式的话，推荐使用 `sharding-jdbc` ，直接引入 jar 包即可使用，非常方便。同时，也节省了很多运维的成本。\n\n你可以在 shardingsphere 官方找到[sharding-jdbc 关于读写分离的操作](https://shardingsphere.apache.org/document/legacy/3.x/document/cn/manual/sharding-jdbc/usage/read-write-splitting/)。\n\n### 主从复制原理了解么？\n\nMySQL binlog(binary log 即二进制日志文件) 主要记录了 MySQL 数据库中数据的所有变化(数据库执行的所有 DDL 和 DML 语句)。因此，我们根据主库的 MySQL binlog 日志就能够将主库的数据同步到从库中。\n\n更具体和详细的过程是这个样子的（图片来自于：[《MySQL Master-Slave Replication on the Same Machine》](https://www.toptal.com/mysql/mysql-master-slave-replication-tutorial)）：\n\n![MySQL主从复制](读写分离&分库分表.assets/78816271d3ab52424bfd5ad3086c1a0f.png)\n\n1. 主库将数据库中数据的变化写入到 binlog\n2. 从库连接主库\n3. 从库会创建一个 I/O 线程向主库请求更新的 binlog\n4. 主库会创建一个 binlog dump 线程来发送 binlog ，从库中的 I/O 线程负责接收\n5. 从库的 I/O 线程将接收的 binlog 写入到 relay log 中。\n6. 从库的 SQL 线程读取 relay log 同步数据本地（也就是再执行一遍 SQL ）。\n\n怎么样？看了我对主从复制这个过程的讲解，你应该搞明白了吧!\n\n你一般看到 binlog 就要想到主从复制。当然，除了主从复制之外，binlog 还能帮助我们实现数据恢复。\n\n🌈 拓展一下：\n\n不知道大家有没有使用过阿里开源的一个叫做 canal 的工具。这个工具可以帮助我们实现 MySQL 和其他数据源比如 Elasticsearch 或者另外一台 MySQL 数据库之间的数据同步。很显然，这个工具的底层原理肯定也是依赖 binlog。canal 的原理就是模拟 MySQL 主从复制的过程，解析 binlog 将数据同步到其他的数据源。\n\n另外，像咱们常用的分布式缓存组件 Redis 也是通过主从复制实现的读写分离。\n\n🌕 简单总结一下：\n\n**MySQL 主从复制是依赖于 binlog 。另外，常见的一些同步 MySQL 数据到其他数据源的工具（比如 canal）的底层一般也是依赖 binlog 。**\n\n## 分库分表\n\n读写分离主要应对的是数据库读并发，没有解决数据库存储问题。试想一下：**如果 MySQL 一张表的数据量过大怎么办?**\n\n换言之，**我们该如何解决 MySQL 的存储压力呢？**\n\n答案之一就是 **分库分表**。\n\n### 何为分库？\n\n**分库** 就是将数据库中的数据分散到不同的数据库上。\n\n下面这些操作都涉及到了分库：\n\n- 你将数据库中的用户表和用户订单表分别放在两个不同的数据库。\n- 由于用户表数据量太大，你对用户表进行了水平切分，然后将切分后的 2 张用户表分别放在两个不同的数据库。\n\n### 何为分表？\n\n**分表** 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。\n\n**何为垂直拆分？**\n\n简单来说，垂直拆分是对数据表列的拆分，把一张列比较多的表拆分为多张表。\n\n举个例子：我们可以将用户信息表中的一些列单独抽出来作为一个表。\n\n**何为水平拆分？**\n\n简单来说，水平拆分是对数据表行的拆分，把一张行比较多的表拆分为多张表。\n\n举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。\n\n[《从零开始学架构》](https://time.geekbang.org/column/intro/100006601?code=i00Nq3pHUcUj04ZWy70NCRl%2FD2Lfj8GVzcGzZ3Wf5Ug%3D) 中的有一张图片对于垂直拆分和水平拆分的描述还挺直观的。\n\n![](读写分离&分库分表.assets/662ea3bda90061d0b40177e3a46fefc3.jpg)\n\n### 什么情况下需要分库分表？\n\n遇到下面几种场景可以考虑分库分表：\n\n- 单表的数据达到千万级别以上，数据库读写速度比较缓慢（分表）。\n- 数据库中的数据占用的空间越来越大，备份时间越来越长（分库）。\n- 应用的并发量太大（分库）。\n\n### 分库分表会带来什么问题呢？\n\n记住，你在公司做的任何技术决策，不光是要考虑这个技术能不能满足我们的要求，是否适合当前业务场景，还要重点考虑其带来的成本。\n\n引入分库分表之后，会给系统带来什么挑战呢？\n\n- **join 操作** ： 同一个数据库中的表分布在了不同的数据库中，导致无法使用 join 操作。这样就导致我们需要手动进行数据的封装，比如你在一个数据库中查询到一个数据之后，再根据这个数据去另外一个数据库中找对应的数据。\n- **事务问题** ：同一个数据库中的表分布在了不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足我们的要求了。\n- **分布式 id** ：分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。我们如何为不同的数据节点生成全局唯一主键呢？这个时候，我们就需要为我们的系统引入分布式 id 了。\n- ......\n\n另外，引入分库分表之后，一般需要 DBA 的参与，同时还需要更多的数据库服务器，这些都属于成本。\n\n### 分库分表有没有什么比较推荐的方案？\n\nShardingSphere 项目（包括 Sharding-JDBC、Sharding-Proxy 和 Sharding-Sidecar）是当当捐入 Apache 的，目前主要由京东数科的一些巨佬维护。\n\n![](读写分离&分库分表.assets/60649996bfc69acb1953063dddf0c2e6.png)\n\nShardingSphere 绝对可以说是当前分库分表的首选！ShardingSphere 的功能完善，除了支持读写分离和分库分表，还提供分布式事务、数据库治理等功能。\n\n另外，ShardingSphere 的生态体系完善，社区活跃，文档完善，更新和发布比较频繁。\n\n艿艿之前写了一篇分库分表的实战文章，各位朋友可以看看：[《芋道 Spring Boot 分库分表入门》](https://mp.weixin.qq.com/s/A2MYOFT7SP-7kGOon8qJaw) 。\n\n### 分库分表后，数据怎么迁移呢？\n\n分库分表之后，我们如何将老库（单库单表）的数据迁移到新库（分库分表后的数据库系统）呢？\n\n比较简单同时也是非常常用的方案就是**停机迁移**，写个脚本老库的数据写到新库中。比如你在凌晨 2 点，系统使用的人数非常少的时候，挂一个公告说系统要维护升级预计 1 小时。然后，你写一个脚本将老库的数据都同步到新库中。\n\n如果你不想停机迁移数据的话，也可以考虑**双写方案**。双写方案是针对那种不能停机迁移的场景，实现起来要稍微麻烦一些。具体原理是这样的：\n\n- 我们对老库的更新操作（增删改），同时也要写入新库（双写）。如果操作的数据不存在于新库的话，需要插入到新库中。 这样就能保证，咱们新库里的数据是最新的。\n- 在迁移过程，双写只会让被更新操作过的老库中的数据同步到新库，我们还需要自己写脚本将老库中的数据和新库的数据做比对。如果新库中没有，那咱们就把数据插入到新库。如果新库有，旧库没有，就把新库对应的数据删除（冗余数据清理）。\n- 重复上一步的操作，直到老库和新库的数据一致为止。\n\n想要在项目中实施双写还是比较麻烦的，很容易会出现问题。我们可以借助上面提到的数据库同步工具 Canal 做增量数据迁移（还是依赖 binlog，开发和维护成本较低）。\n"},"1ac0":function(n,e,t){"use strict";t.r(e),e["default"]='------\n\n\n\n## Kafka面试题总结\n\n### Kafka 是什么？主要应用场景有哪些？\n\nKafka 是一个分布式流式处理平台。这到底是什么意思呢？\n\n流平台具有三个关键功能：\n\n1. **消息队列**：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。\n2. **容错的持久方式存储记录消息流**： Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险。\n3. **流式处理平台：** 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。\n\nKafka 主要有两大应用场景：\n\n1. **消息队列** ：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据。\n2. **数据处理：** 构建实时的流数据处理程序来转换或处理数据流。\n\n### 和其他消息队列相比,Kafka的优势在哪里？\n\n我们现在经常提到 Kafka 的时候就已经默认它是一个非常优秀的消息队列了，我们也会经常拿它跟 RocketMQ、RabbitMQ 对比。我觉得 Kafka 相比其他消息队列主要的优势如下：\n\n1. **极致的性能** ：基于 Scala 和 Java 语言开发，设计中大量使用了批量处理和异步的思想，最高可以每秒处理千万级别的消息。\n2. **生态系统兼容性无可匹敌** ：Kafka 与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域。\n\n实际上在早期的时候 Kafka 并不是一个合格的消息队列，早期的 Kafka 在消息队列领域就像是一个衣衫褴褛的孩子一样，功能不完备并且有一些小问题比如丢失消息、不保证消息可靠性等等。当然，这也和 LinkedIn 最早开发 Kafka 用于处理海量的日志有很大关系，哈哈哈，人家本来最开始就不是为了作为消息队列滴，谁知道后面误打误撞在消息队列领域占据了一席之地。\n\n随着后续的发展，这些短板都被 Kafka 逐步修复完善。所以，**Kafka 作为消息队列不可靠这个说法已经过时！**\n\n### 队列模型了解吗？Kafka 的消息模型知道吗？\n\n> 题外话：早期的 JMS 和 AMQP 属于消息服务领域权威组织所做的相关的标准，我在 [JavaGuide](https://github.com/Snailclimb/JavaGuide)的 [《消息队列其实很简单》](https://github.com/Snailclimb/JavaGuide#%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E4%B8%AD%E9%97%B4%E4%BB%B6)这篇文章中介绍过。但是，这些标准的进化跟不上消息队列的演进速度，这些标准实际上已经属于废弃状态。所以，可能存在的情况是：不同的消息队列都有自己的一套消息模型。\n\n#### 队列模型：早期的消息模型\n\n![队列模型](Kafka常见面试题总结.assets/队列模型23.png)\n\n**使用队列（Queue）作为消息通信载体，满足生产者与消费者模式，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。** 比如：我们生产者发送 100 条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）\n\n**队列模型存在的问题：**\n\n假如我们存在这样一种情况：我们需要将生产者产生的消息分发给多个消费者，并且每个消费者都能接收到完整的消息内容。\n\n这种情况，队列模型就不好解决了。很多比较杠精的人就说：我们可以为每个消费者创建一个单独的队列，让生产者发送多份。这是一种非常愚蠢的做法，浪费资源不说，还违背了使用消息队列的目的。\n\n#### 发布-订阅模型:Kafka 消息模型\n\n发布-订阅模型主要是为了解决队列模型存在的问题。\n\n![发布订阅模型](Kafka常见面试题总结.assets/发布订阅模型.png)\n\n发布订阅模型（Pub-Sub） 使用**主题（Topic）** 作为消息通信载体，类似于**广播模式**；发布者发布一条消息，该消息通过主题传递给所有的订阅者，**在一条消息广播之后才订阅的用户则是收不到该条消息的**。\n\n**在发布 - 订阅模型中，如果只有一个订阅者，那它和队列模型就基本是一样的了。所以说，发布 - 订阅模型在功能层面上是可以兼容队列模型的。**\n\n**Kafka 采用的就是发布 - 订阅模型。** \n\n> **RocketMQ 的消息模型和 Kafka 基本是完全一样的。唯一的区别是 Kafka 中没有队列这个概念，与之对应的是 Partition（分区）。**\n\n### 什么是Producer、Consumer、Broker、Topic、Partition？\n\nKafka 将生产者发布的消息发送到 **Topic（主题）** 中，需要这些消息的消费者可以订阅这些 **Topic（主题）**，如下图所示：\n\n![Kafka Topic Partition](Kafka常见面试题总结.assets/KafkaTopicPartitioning.png)\n\n上面这张图也为我们引出了，Kafka 比较重要的几个概念：\n\n1. **Producer（生产者）** : 产生消息的一方。\n2. **Consumer（消费者）** : 消费消息的一方。\n3. **Broker（代理）** : 可以看作是一个独立的 Kafka 实例。多个 Kafka Broker 组成一个 Kafka Cluster。\n\n同时，你一定也注意到每个 Broker 中又包含了 Topic 以及 Partition 这两个重要的概念：\n\n- **Topic（主题）** : Producer 将消息发送到特定的主题，Consumer 通过订阅特定的 Topic(主题) 来消费消息。\n- **Partition（分区）** : Partition 属于 Topic 的一部分。一个 Topic 可以有多个 Partition ，并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上，这也就表明一个 Topic 可以横跨多个 Broker 。这正如我上面所画的图一样。\n\n> 划重点：**Kafka 中的 Partition（分区） 实际上可以对应成为消息队列中的队列。这样是不是更好理解一点？**\n\n### Kafka 的多副本机制了解吗？带来了什么好处？\n\n还有一点我觉得比较重要的是 Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。\n\n> 生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。当 leader 副本发生故障时会从 follower 中选举出一个 leader,但是 follower 中如果有和 leader 同步程度达不到要求的参加不了 leader 的竞选。\n\n**Kafka 的多分区（Partition）以及多副本（Replica）机制有什么好处呢？**\n\n1. Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力（负载均衡）。\n2. Partition 可以指定对应的 Replica 数, 这也极大地提高了消息存储的安全性, 提高了容灾能力，不过也相应的增加了所需要的存储空间。\n\n### Zookeeper 在 Kafka 中的作用知道吗？\n\n> **要想搞懂 zookeeper 在 Kafka 中的作用 一定要自己搭建一个 Kafka 环境然后自己进 zookeeper 去看一下有哪些文件夹和 Kafka 有关，每个节点又保存了什么信息。** 一定不要光看不实践，这样学来的也终会忘记！这部分内容参考和借鉴了这篇文章：https://www.jianshu.com/p/a036405f989c 。\n\n\n\n下图就是我的本地 Zookeeper ，它成功和我本地的 Kafka 关联上（以下文件夹结构借助 idea 插件 Zookeeper tool 实现）。\n\n<img src="Kafka常见面试题总结.assets/zookeeper-kafka.jpg" style="zoom:50%;" />\n\nZooKeeper 主要为 Kafka 提供元数据的管理的功能。\n\n从图中我们可以看出，Zookeeper 主要为 Kafka 做了下面这些事情：\n\n1. **Broker 注册** ：在 Zookeeper 上会有一个专门**用来进行 Broker 服务器列表记录**的节点。每个 Broker 在启动时，都会到 Zookeeper 上进行注册，即到 `/brokers/ids` 下创建属于自己的节点。每个 Broker 就会将自己的 IP 地址和端口等信息记录到该节点中去\n2. **Topic 注册** ： 在 Kafka 中，同一个**Topic 的消息会被分成多个分区**并将其分布在多个 Broker 上，**这些分区信息及与 Broker 的对应关系**也都是由 Zookeeper 在维护。比如我创建了一个名字为 my-topic 的主题并且它有两个分区，对应到 zookeeper 中会创建这些文件夹：`/brokers/topics/my-topic/Partitions/0`、`/brokers/topics/my-topic/Partitions/1`\n3. **负载均衡** ：上面也说过了 Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力。 对于同一个 Topic 的不同 Partition，Kafka 会尽力将这些 Partition 分布到不同的 Broker 服务器上。当生产者产生消息后也会尽量投递到不同 Broker 的 Partition 里面。当 Consumer 消费的时候，Zookeeper 可以根据当前的 Partition 数量以及 Consumer 数量来实现动态负载均衡。\n4. ......\n\n###  Kafka 如何保证消息的消费顺序？\n\n我们在使用消息队列的过程中经常有业务场景需要严格保证消息的消费顺序，比如我们同时发了 2 个消息，这 2 个消息对应的操作分别对应的数据库操作是：\n\n1. 更改用户会员等级。\n2. 根据会员等级计算订单价格。\n\n假如这两条消息的消费顺序不一样造成的最终结果就会截然不同。\n\n我们知道 Kafka 中 Partition(分区)是真正保存消息的地方，我们发送的消息都被放在了这里。而我们的 Partition(分区) 又存在于 Topic(主题) 这个概念中，并且我们可以给特定 Topic 指定多个 Partition。\n\n![](Kafka常见面试题总结.assets/KafkaTopicPartionsLayout.png)\n\n每次添加消息到 Partition(分区) 的时候都会采用尾加法，如上图所示。 **Kafka 只能为我们保证 Partition(分区) 中的消息有序。**\n\n> 消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。Kafka 通过偏移量（offset）来保证消息在分区内的顺序性。\n\n所以，我们就有一种很简单的保证消息消费顺序的方法：**1 个 Topic 只对应一个 Partition**。这样当然可以解决问题，但是破坏了 Kafka 的设计初衷。\n\nKafka 中发送 1 条消息的时候，可以指定 topic, partition, key,data（数据） 4 个参数。如果你发送消息的时候指定了 Partition 的话，所有消息都会被发送到指定的 Partition。并且，同一个 key 的消息可以保证只发送到同一个 partition，这个我们可以采用表/对象的 id 来作为 key 。\n\n总结一下，对于如何保证 Kafka 中消息消费的顺序，有了下面两种方法：\n\n1. 1 个 Topic 只对应一个 Partition。\n2. （推荐）发送消息的时候指定 key/Partition。\n\n当然不仅仅只有上面两种方法，上面两种方法是我觉得比较好理解的，\n\n### Kafka 如何保证消息不丢失\n\n#### 生产者丢失消息的情况\n\n生产者(Producer) 调用`send`方法发送消息之后，消息可能因为网络问题并没有发送过去。 \n\n所以，我们不能默认在调用`send`方法发送消息之后消息发送成功了。为了确定消息是发送成功，我们要判断消息发送的结果。但是要注意的是  Kafka 生产者(Producer) 使用  `send` 方法发送消息实际上是异步的操作，我们可以通过 `get()`方法获取调用结果，但是这样也让它变为了同步操作，示例代码如下：\n\n> **详细代码见我的这篇文章：[Kafka系列第三篇！10 分钟学会如何在 Spring Boot 程序中使用 Kafka 作为消息队列?](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486269&idx=2&sn=ec00417ad641dd8c3d145d74cafa09ce&chksm=cea244f6f9d5cde0c8eb233fcc4cf82e11acd06446719a7af55230649863a3ddd95f78d111de&token=1633957262&lang=zh_CN#rd)**\n\n```java\nSendResult<String, Object> sendResult = kafkaTemplate.send(topic, o).get();\nif (sendResult.getRecordMetadata() != null) {\n  logger.info("生产者成功发送消息到" + sendResult.getProducerRecord().topic() + "-> " + sendRe\n              sult.getProducerRecord().value().toString());\n}\n```\n\n但是一般不推荐这么做！可以采用为其添加回调函数的形式，示例代码如下：\n\n````java\n        ListenableFuture<SendResult<String, Object>> future = kafkaTemplate.send(topic, o);\n        future.addCallback(result -> logger.info("生产者成功发送消息到topic:{} partition:{}的消息", result.getRecordMetadata().topic(), result.getRecordMetadata().partition()),\n                ex -> logger.error("生产者发送消失败，原因：{}", ex.getMessage()));\n````\n\n如果消息发送失败的话，我们检查失败的原因之后重新发送即可！\n\n**另外这里推荐为 Producer 的`retries `（重试次数）设置一个比较合理的值，一般是 3 ，但是为了保证消息不丢失的话一般会设置比较大一点。设置完成之后，当出现网络问题之后能够自动重试消息发送，避免消息丢失。另外，建议还要设置重试间隔，因为间隔太小的话重试的效果就不明显了，网络波动一次你3次一下子就重试完了**\n\n#### 消费者丢失消息的情况\n\n我们知道消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。偏移量（offset)表示 Consumer 当前消费到的 Partition(分区)的所在的位置。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。\n\n![kafka offset](Kafka常见面试题总结.assets/kafka-offset.jpg)\n\n当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset。自动提交的话会有一个问题，试想一下，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了。\n\n**解决办法也比较粗暴，我们手动关闭自动提交 offset，每次在真正消费完消息之后再自己手动提交 offset 。** 但是，细心的朋友一定会发现，这样会带来消息被重新消费的问题。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。\n\n#### Kafka 弄丢了消息\n\n 我们知道 Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。\n\n**试想一种情况：假如 leader 副本所在的 broker 突然挂掉，那么就要从 follower 副本重新选出一个 leader ，但是 leader 的数据还有一些没有被 follower 副本的同步的话，就会造成消息丢失。**\n\n**设置 acks = all**\n\n解决办法就是我们设置  **acks = all**。acks 是 Kafka 生产者(Producer)  很重要的一个参数。\n\nacks 的默认值即为1，代表我们的消息被leader副本接收之后就算被成功发送。当我们配置 **acks = all** 代表则所有副本都要接收到该消息之后该消息才算真正成功被发送。\n\n**设置 replication.factor >= 3**\n\n为了保证 leader 副本能有 follower 副本能同步消息，我们一般会为 topic 设置 **replication.factor >= 3**。这样就可以保证每个 分区(partition) 至少有 3 个副本。虽然造成了数据冗余，但是带来了数据的安全性。\n\n**设置 min.insync.replicas > 1**\n\n一般情况下我们还需要设置 **min.insync.replicas> 1** ，这样配置代表消息至少要被写入到 2 个副本才算是被成功发送。**min.insync.replicas** 的默认值为 1 ，在实际生产中应尽量避免默认值 1。\n\n但是，为了保证整个 Kafka 服务的高可用性，你需要确保 **replication.factor > min.insync.replicas** 。为什么呢？设想一下假如两者相等的话，只要是有一个副本挂掉，整个分区就无法正常工作了。这明显违反高可用性！一般推荐设置成 **replication.factor = min.insync.replicas + 1**。\n\n**设置 unclean.leader.election.enable = false**\n\n> **Kafka 0.11.0.0版本开始 unclean.leader.election.enable 参数的默认值由原来的true 改为false**\n\n我们最开始也说了我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。多个 follower 副本之间的消息同步情况不一样，当我们配置了 **unclean.leader.election.enable = false**  的话，当 leader 副本发生故障时就不会从  follower 副本中和 leader 同步程度达不到要求的副本中选择出  leader ，这样降低了消息丢失的可能性。\n\n### Kafka 如何保证消息不重复消费\n\n**kafka出现消息重复消费的原因：**\n\n- 服务端侧已经消费的数据没有成功提交 offset（根本原因）。\n- Kafka 侧 由于服务端处理业务时间长或者网络链接等等原因让 Kafka 认为服务假死，触发了分区 rebalance。\n\n**解决方案：**\n\n- 消费消息服务做幂等校验，比如 Redis 的set、MySQL 的主键等天然的幂等功能。这种方法最有效。\n- 将 **`enable.auto.commit`** 参数设置为 false，关闭自动提交，开发者在代码中手动提交 offset。那么这里会有个问题：**什么时候提交offset合适？**\n    * 处理完消息再提交：依旧有消息重复消费的风险，和自动提交一样\n    * 拉取到消息即提交：会有消息丢失的风险。允许消息延时的场景，一般会采用这种方式。然后，通过定时任务在业务不繁忙（比如凌晨）的时候做数据兜底。\n\n### Reference\n\n- Kafka 官方文档： https://kafka.apache.org/documentation/\n- 极客时间—《Kafka核心技术与实战》第11节：无消息丢失配置怎么实现？\n'},"1b62":function(n,e,t){"use strict";t.d(e,"d",(function(){return o})),t.d(e,"c",(function(){return u})),t.d(e,"a",(function(){return y})),t.d(e,"b",(function(){return f}));var r=t("448a"),a=t.n(r),i=(t("4de4"),t("d3b7"),["/第1阶段-运维基本功（升级7.6版本）/01运维概述与Linux系统安装.pdf","/第1阶段-运维基本功（升级7.6版本）/02Linux基础命令.pdf"]),s="linux/heima-Linux云计算",o={name:"Container",data:function(){return{prefix:s,book_options:i,book_options_all:[],show:!0,book:i[0],src:""}},created:function(){this.book_options_all=a()(this.book_options),this.src=this.$utils.compute_book_src(this.prefix+this.book)},watch:{book:function(n,e){n&&this.change_book()}},methods:{change_book:function(){console.log("this.book",this.book),this.src=this.$utils.compute_book_src(this.prefix+this.book)},filterFn:function(n,e){var t=this;e(""!==n?function(){var e=n.toLowerCase();t.book_options=t.book_options_all.filter((function(n){return n.toLowerCase().indexOf(e)>-1}))}:function(){t.book_options=t.book_options_all})}}},l=t("ded3"),c=t.n(l),p=t("2f62"),u={data:function(){return{tab:"",tab_level:1,is_active:!1}},computed:c()({},Object(p["c"])(["get_current_selected_right_menu"])),created:function(){this.is_active=!0,this.fix_right_menu_config()},watch:{tab:function(){this.tab||this.fix_right_menu_config()},get_current_selected_right_menu:function(n,e){this.tab=this.get_current_selected_right_menu["t"+this.tab_level]}},methods:c()(c()({},Object(p["b"])(["set_right_menu_fix_config"])),{},{fix_right_menu_config:function(){this.set_right_menu_fix_config({tl:this.tab_level,tabs:this.tabs||[],tv:this.tab||this.tabs[0]["value"]})}}),beforeDestroy:function(){this.is_active=!1}},d=(t("d81d"),t("99af"),t("a434"),t("07ac"),t("fb6a"),function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"q-my-md q-mx-sm"},[t("div",{staticClass:"q-mb-md row q-gutter-x-md q-gutter-y-sm"},[t("q-select",{staticStyle:{width:"300px"},attrs:{dense:"",filled:"","use-input":"","hide-selected":"","fill-input":"","input-debounce":"0",options:n.topic_options_filtered},on:{filter:n.filterFn,"filter-abort":n.abortFilterFn,input:n.handle_topic_change},scopedSlots:n._u([{key:"before",fn:function(){return[n._v("\n        主题\n      ")]},proxy:!0}]),model:{value:n.topic,callback:function(e){n.topic=e},expression:"topic"}}),t("q-select",{staticStyle:{width:"300px"},attrs:{dense:"",filled:"",options:n.column_options},on:{input:n.handle_column_change},scopedSlots:n._u([{key:"before",fn:function(){return[n._v("\n        列数\n      ")]},proxy:!0}]),model:{value:n.column,callback:function(e){n.column=e},expression:"column"}})],1),t("q-markup-table",{attrs:{dense:""}},[t("thead",[t("tr",[t("th",{staticClass:"text-left text-weight-bolder  ",attrs:{colspan:n.column}},[n._v("\n          "+n._s(n.table_title?n.table_title+"------":"")+"当前词条数量："+n._s(n.word_total)+"\n        ")])])]),t("tbody",[n._l(n.table_data,(function(e,r){return[n.compute_if_show(e)?t("tr",{key:r,class:n.compute_topic_options_style(e)},n._l(n.column,(function(r){return t("td",{key:r,staticClass:"text-left"},[n._v("\n            "+n._s(e[r-1])+"\n          ")])})),0):n._e()]}))],2)])],1)}),m=[],S=(t("a9e3"),t("caad"),t("2532"),{data:function(){return{topic:"全部",column:2,topic_options_filtered:[],topic_options_all:[]}},props:{table_title:{type:String,default:""},word_total:{type:Number,default:0},topic_options:{type:Array,default:function(){return[]}},column_options:{type:Array,default:function(){return[]}},table_data:{type:Array,default:function(){return[]}},show_empty_line:!1},watch:{topic_options:function(n,e){this.init_topic_options_related()},column_options:function(n,e){this.init_column()}},created:function(){this.init_topic_options_related(),this.init_column(),this.handle_column_change(),this.handle_topic_change()},methods:{init_topic_options_related:function(){this.topic_options_all=a()(this.topic_options),this.topic_options_filtered=a()(this.topic_options)},filterFn:function(n,e,t){var r=this;console.log("this.topic_options_all",this.topic_options_all),setTimeout((function(){e((function(){if(""===n)r.topic_options_filtered=a()(r.topic_options_all);else{var e=n.toLowerCase();r.topic_options_filtered=r.topic_options_all.filter((function(n){return n.toLowerCase().indexOf(e)>-1}))}r.$forceUpdate()}),(function(e){""!==n&&e.options.length>0&&(e.setOptionIndex(-1),e.moveOptionSelection(1,!0))}))}),300)},abortFilterFn:function(){},handle_column_change:function(){this.$emit("handle_column_change",this.column)},handle_topic_change:function(){this.$emit("handle_topic_change",this.topic)},init_column:function(){var n=this.$q.platform.is.desktop,e=window.innerWidth;e=n?e-200:e-100,e=e<370?370:e,console.log("ww",e);var t=Math.ceil(e/350);t=t<1?1:t,e<400&&(t=1),t=t>8?8:t,this.column=t},compute_topic_options_style:function(n){var e="",t=1==n.length&&this.topic_options.includes(n[0]);return e=t?"bg-teal-4":"",e},compute_if_show:function(n){if(this.show_empty_line)return!0;var e=n.filter((function(n){return n}));return e.length>0}}}),g=S,v=t("2877"),b=Object(v["a"])(g,d,m,!1,null,"352286d7",null),h=b.exports,y={components:{excelTable:h},data:function(){return{workSheetsFromFile:[[{data:[]}]],table_title:"",column:8,word_total:0,table_data:[],table_data_all:[],column_options:[1,2,3,4,5,6,7,8],exclude_topic_options:!0,show_empty_line:!1,topic:"",topic_options:[]}},created:function(){this.init_workSheetsFromFile()},methods:{init_workSheetsFromFile:function(){},handle_column_change:function(n){this.column=n,this.init_data()},handle_topic_change:function(n){this.topic=n,console.log("this.topic----",this.topic),this.compute_table_data_show_and_word_total()},rebuild_arr_reduce_empty_line:function(n){var e=[[""]];return n.map((function(n){var t=n.filter((function(n){return n})),r=t.length;if(r)e.push(n);else{var a=e[e.length-1].filter((function(n){return n})).length,i=e[e.length-1].length;i>0&&a>0&&e.push([""])}})),e},init_data:function(){var n=this;console.log("workSheetsFromFile --------",this.workSheetsFromFile);var e=[],t={},r=[];this.workSheetsFromFile.map((function(n){e=e.concat(n["data"])}));var i=this.$lodash.cloneDeep(e[0].filter((function(n){return n})));i.map((function(n,e){t["key_"+e]={title:n,words_raw:[]}})),this.exclude_topic_options&&e.splice(0,1),e.map((function(n,e){n.map((function(n,e){t["key_"+e]["words_raw"].push(n)}))})),console.log("final_obj------------",t);var s=Object.values(t);s.map((function(e,t){r.push([e["title"]]),r=r.concat(n.$lodash.chunk(e["words_raw"],n.column)),r=r.concat([[""]])})),this.topic_options=["全部"].concat(a()(i)),this.table_data_all=this.rebuild_arr_reduce_empty_line(r),this.compute_table_data_show_and_word_total(),console.log("  this.table_data_all   ",this.table_data_all)},compute_table_data_show_and_word_total:function(){var n=[],e=[],t=0;if(e=this.$lodash.cloneDeep(this.table_data_all),console.log(" table_data--------",e),"全部"==this.topic)n=e;else{var r=this.topic_options.indexOf(this.topic),a=r==this.topic_options.length-1,i=a?"":this.topic_options[r+1],s=this.find_topic_index(this.topic),o=i?this.find_topic_index(i):e.length;n=e.slice(s,o)}n.map((function(n){var e=n.filter((function(n){return n})).length;t+=e})),this.word_total=t,this.table_data=n},find_topic_index:function(n){for(var e=0,t=0;t<this.table_data_all.length;t++){var r=this.table_data_all[t];if(1==r.length&&r[0]&&r[0]==n){e=t;break}}return e}}},f=(t("ac1f"),t("1276"),t("498a"),t("2ca0"),t("5319"),t("5b81"),t("7db0"),{data:function(){return{relative_path:"",tab:"",tabs:[],MainComponent:"",img_prefix:"./img/linux/heima-Linux云计算/讲义/"}},methods:{extendMarkdown:function(n){var e=this;console.log(n.renderer.rules);var t=n.renderer.rules.html_block;n.renderer.rules.html_block=function(n,r,a,i,s){var o=n[r];if(console.log("1"),console.log("md.renderer.rules.html_block  ",o),o.content.includes("<img")){console.log("token-- ",o);var l="";l=o.content;var c=l.split('src="'),p="",u=c[1];c[0],e.img_prefix,c[1],p=u.includes("http")?c[0]+' src="'+u:c[0]+' src="'+e.img_prefix+u,o.content=p}return o.attrSet("class","q-markdown--token  "),t(n,r,a,i,s)},n.renderer.rules.image=function(n,t,r,a,i){var s=n[t];console.log("3"),s.attrSet("class","q-markdown--image"),console.log("token--- "+t+"-----",s);var o=s.attrGet("src");return console.log(o),o.includes("http")?s.attrSet("src",o):s.attrSet("src",e.img_prefix+o),i.renderToken(n,t,r)},n.renderer.rules.link_open=function(n,r,a,i,s){var o=n[r];console.log("tokens--- md.renderer.rules.link_open ",o),console.log("4");var l=decodeURIComponent(o.attrGet("href")).trim();console.log("raw_href-",l);var c=l.startsWith("源码下载:");if(console.log(" is_yuanma_download=-----",c),c){var p=e.img_prefix+l.split("源码下载:")[1];return o.attrSet("href",p),s.renderToken(n,r,a)}var u=l.startsWith("#");return u?(o.content=l.replaceAll("#",""),o.tag="p",t(n,r,a,i,s)):s.renderToken(n,r,a)}},compute_img_prefix:function(){var n=this;if(this.MainComponent){var e=this.tabs.find((function(e){return e["value"]==n.tab}));if(e&&e["modules_obj"]){var t=this.relative_path;this.img_prefix="."+t+(e["modules_obj"]["relative_folder"]||"")}else this.img_prefix="."+relative_path}}}})},2044:function(n,e,t){"use strict";t.r(e),e["default"]='\x3c!--\n * @Date           : 2021-04-28 01:12:51\n * @FilePath       : /jinnian-space/src/pages/java/module/springmvc/md/Spring-day01.md\n * @Description    : \n--\x3e\n#  IOC\n\n## 1)Spring简介\n\n### 1.1)什么是框架\n\n- 源自于建筑学，隶属土木工程，后发展到软件工程领域\n\n- 软件工程框架：经过验证的，具有一定功能的，半成品软件\n\n  - 经过验证\n\n  - 具有一定功能\n\n  - 半成品\n\n![1590631254933](./Spring-day01/1590631254933.png)\n\n### 1.2)框架的作用\n\n![1590631300743](./Spring-day01/1590631300743.png)\n\n### 1.3)Spring是什么\n\nSpring是分层的JavaSE/EE应用full-stack轻量级开源框架\n\n![1590631495077](./Spring-day01/1590631495077.png)\n\n### 1.4)Spring的体系结构\n\n![1590631552693](./Spring-day01/1590631552693.png)\n\n### 1.5)Spring的发展历史\n\n![1590631606747](./Spring-day01/1590631606747.png)\n\n### 1.6)Spring优势\n\n| Spring的优势             |          |\n| ------------------------ | -------- |\n| 方便解耦，简化开发       | 第一天   |\n| 方便集成各种优秀框架     | 第一天   |\n| 方便程序的测试           | 第二天   |\n| AOP编程的支持            | 第三天   |\n| 声明式事务的支持         | 第四天   |\n| 降低JavaEE API的使用难度 | 第四天   |\n| Java源码是经典学习范例   | 长期学习 |\n\n## 2)IoC简介\n\n### 2.1)优质程序代码的制作原则\n\n![1590636507198](./Spring-day01/1590636507198.png)\n\n### 2.2)耦合与内聚\n\n- 耦合（Coupling）：代码书写过程中所使用技术的结合紧密度，用于衡量软件中各个模块之间的互联程度\n\n- 内聚（Cohesion）：代码书写过程中单个模块内部各组成部分间的联系，用于衡量软件中各个功能模块内部的功能联系\n\n![1590636557953](./Spring-day01/1590636557953.png)\n\n- 程序书写的目标：高内聚，低耦合\n  - 就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却不要那么紧密\n\n### 2.3)工厂模式发展史\n\n![1590636616069](./Spring-day01/1590636616069.png)\n\n![1590636644096](./Spring-day01/1590636644096.png)\n\n![1590636661026](./Spring-day01/1590636661026.png)\n\n### 2.4)Spring发展历程\n\n![1590636704098](./Spring-day01/1590636704098.png)\n\n### 2.5)IoC\n\n- IoC（Inversion Of Control）控制反转，Spring反向控制应用程序所需要使用的外部资源\n\n- Spring控制的资源全部放置在Spring容器中，该容器称为IoC容器\n\n  ![1590636750876](./Spring-day01/1590636750876.png)\n\n\n\n\n\n## 3)入门案例\n\n### 3.1)案例环境说明\n\n- 模拟三层架构中表现层调用业务层功能\n\n  - 表现层：UserApp模拟UserServlet（使用main方法模拟）\n\n  - 业务层：UserService\n\n### 3.2)IoC入门案例制作步骤\n\n1.导入spring坐标（5.1.9.release）\n\n2.编写业务层与表现层（模拟）接口与实现类\n\n3.建立spring配置文件\n\n4.配置所需资源（Service）为spring控制的资源\n\n5.表现层（App）通过spring获取资源（Service实例）\n\n![1590637353510](./Spring-day01/1590637353510.png)\n\n#### 3.2.1)IoC入门案例制作步骤-1\n\n```xml\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context</artifactId>\n    <version>5.1.9.RELEASE</version>\n</dependency>\n```\n\n#### 3.2.2)IoC入门案例制作步骤-2\n\n```java\npublic interface UserService {\n\t//业务方法  \n\tvoid save();\n}\n```\n\n#### 3.2.3)IoC入门案例制作步骤-3\n\n```java\npublic class UserServiceImpl implements UserService {\n    public void save() {\n        System.out.println("user service running...");\n    }\n}\n```\n\n#### 3.2.4)IoC入门案例制作步骤-4\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd">\n    \x3c!-- 1.创建spring控制的资源--\x3e\n    <bean id="userService" class="com.itheima.service.impl.UserServiceImpl"/>\n</beans>\n```\n\n#### 3.2.5)IoC入门案例制作步骤-5\n\n```java\npublic class UserApp {\n    public static void main(String[] args) {\n        //2.加载配置文件\n        ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");\n        //3.获取资源\n        UserService userService = (UserService) ctx.getBean("userService");\n        userService.save();\n    }\n}\n```\n\n## 4)IoC配置（XML格式）\n\n### 4.1)bean\n\n- 名称：bean\n\n- 类型：**标签**\n\n- 归属：beans标签\n\n- 作用：定义spring中的资源，受此标签定义的资源将受到spring控制\n\n- 格式：\n\n  ```xml\n  <beans>\n  \t<bean />\n  </beans>\n  ```\n\n- 基本属性：\n\n  ```xml\n  <bean id="beanId" name="beanName1,beanName2" class="ClassName"></bean>\n  ```\n\n  ​\tid：bean的名称，通过id值获取bean\n\n  ​\tclass：bean的类型\n\n  ​\tname：bean的名称，可以通过name值获取bean，用于多人配合时给bean起别名\n\n### 4.2)bean属性scope\n\n- 名称：scope\n\n- 类型：**属性**\n\n- 归属：bean标签\n\n- 作用：定义bean的作用范围\n\n- 格式：\n\n  ```xml\n  <bean scope="singleton"></bean>\n  ```\n\n- 取值：\n\n  - singleton：设定创建出的对象保存在spring容器中，是一个单例的对象\n  - prototype：设定创建出的对象保存在spring容器中，是一个非单例的对象\n  - request、session、application、 websocket ：设定创建出的对象放置在web容器对应的位置\n\n### 4.3)bean生命周期\n\n- 名称：init-method，destroy-method\n\n- 类型：**属性**\n\n- 归属：bean标签\n\n- 作用：定义bean对象在初始化或销毁时完成的工作\n\n- 格式：\n\n  ```xml\n  <bean init-method="init" destroy-method="destroy></bean>\n  ```\n\n- 取值：bean对应的类中对应的具体方法名\n\n- 注意事项：\n\n  - 当scope=“singleton”时，spring容器中有且仅有一个对象，init方法在创建容器时仅执行一次\n\n  - 当scope=“prototype”时，spring容器要创建同一类型的多个对象，init方法在每个对象创建时均执行一次\n\n  - 当scope=“singleton”时，关闭容器会导致bean实例的销毁，调用destroy方法一次\n\n  - 当scope=“prototype”时，对象的销毁由垃圾回收机制gc()控制，destroy方法将不会被执行\n\n### 4.4)bean对象创建方式（了解）\n\n(1)factory-bean\n\n- 名称：factory-bean\n\n- 类型：**属性**\n\n- 归属：bean标签\n\n- 作用：定义bean对象创建方式，使用静态工厂的形式创建bean，兼容早期遗留系统的升级工作\n\n- 格式：\n\n  ```xml\n  <bean class="FactoryClassName" factory-method="factoryMethodName"></bean>\n  ```\n\n- 取值：工厂bean中用于获取对象的静态方法名\n\n- 注意事项：\n  \n  - class属性必须配置成静态工厂的类名\n\n(2)factory-bean，factory-method\n\n- 名称：factory-bean，factory-method\n\n- 类型：**属性**\n\n- 归属：bean标签\n\n- 作用：定义bean对象创建方式，使用实例工厂的形式创建bean，兼容早期遗留系统的升级工作\n\n- 格式：\n\n  ```xml\n  <bean factory-bean="factoryBeanId" factory-method="factoryMethodName"></bean>\n  ```\n\n- 取值：工厂bean中用于获取对象的实例方法名\n\n- 注意事项：\n\n  - 使用实例工厂创建bean首先需要将实例工厂配置bean，交由spring进行管理\n\n  - factory-bean是实例工厂的beanId\n\n### 4.5)DI\n\n- IoC（Inversion Of Control）控制翻转，Spring反向控制应用程序所需要使用的外部资源\n\n- DI（Dependency Injection）依赖注入，应用程序运行依赖的资源由Spring为其提供，资源进入应用程序的方式称为注入\n\n![1590659778689](./Spring-day01/1590659778689.png)\n\nIoC与DI的关系\n\n- IoC与DI是同一件事站在不同角度看待问题\n\n- 半杯水\n\n- \n\n- \n\n  ![1590659854696](./Spring-day01/1590659854696.png)set注入（主流）\n\n### 4.6)set注入（主流）\n\n- 名称：property\n\n- 类型：**标签**\n\n- 归属：bean标签\n\n- 作用：使用set方法的形式为bean提供资源\n\n- 格式：\n\n  ```java\n  <bean>\n  \t<property />\n  </bean>\n  ```\n\n- 基本属性：\n\n  ```xml\n  <property name="propertyName" value="propertyValue" ref="beanId"/>\n  ```\n\n​\tname：对应bean中的属性名，要求该属性必须提供可访问的set方法（严格规范为此名称是set方法对应名称）\n\n​\tvalue：设定非引用类型属性对应的值，不能与ref同时使用\n\n​\tref：设定引用类型属性对应bean的id ，不能与value同时使用\n\n- 注意：一个bean可以有多个property标签\n\n### 4.7)构造器注入（了解）\n\n- 名称：constructor-arg\n\n- 类型：**标签**\n\n- 归属：bean标签\n\n- 作用：使用构造方法的形式为bean提供资源，兼容早期遗留系统的升级工作\n\n- 格式：\n\n  ```xml\n  <bean>\n  \t<constructor-arg />\n  </bean>\n  ```\n\n- 基本属性：\n\n  ```xml\n  <constructor-arg name="argsName" value="argsValue />\n  ```\n\n​\tname：对应bean中的构造方法所携带的参数名\n\n​\tvalue：设定非引用类型构造方法参数对应的值，不能与ref同时使用\n\n其他属性：\n\n```xml\n<constructor-arg index="arg-index" type="arg-type" ref="beanId"/>\n```\n\n​\tref：设定引用类型构造方法参数对应bean的id ，不能与value同时使用\n\n​\ttype ：设定构造方法参数的类型，用于按类型匹配参数或进行类型校验\n\n​\tindex ：设定构造方法参数的位置，用于按位置匹配参数，参数index值从0开始计数\n\n- 注意：一个bean可以有多个constructor-arg标签\n\n### 4.8)集合类型数据注入\n\n- 名称：array，list，set，map，props\n\n- 类型：**标签**\n\n- 归属：property标签 或 constructor-arg标签\n\n- 作用：注入集合数据类型属性\n\n- 格式：\n\n  ```xml\n  <property>\n  \t<list></list>\n  </property>\n  ```\n\n(1)集合类型数据注入——list\n\n```xml\n<property name="al">\n    <list>\n        <value>itheima</value>\n        <value>66666</value>\n    </list>\n</property>\n```\n\n(2)集合类型数据注入——props\n\n```xml\n<property name="properties">\n    <props>\n        <prop key="name">itheima666</prop>\n        <prop key="value">666666</prop>\n    </props>\n</property>\n```\n\n(3)集合类型数据注入——array （了解）\n\n```xml\n<property name="arr">\n    <array>\n        <value>123456</value>\n        <value>66666</value>\n    </array>\n</property>\n```\n\n(4)集合类型数据注入——set（了解）\n\n```xml\n <property name="hs">\n     <set>\n         <value>itheima</value>\n         <value>66666</value>\n     </set>\n</property>\n```\n\n(5)集合类型数据注入——map（了解）\n\n```xml\n<property name="hm">\n    <map>\n        <entry key="name" value="itheima66666"/>\n        <entry key="value" value="6666666666"/>\n    </map>\n</property>\n```\n\n### 4.9)使用p命名空间简化配置（了解）\n\n- 名称：p:propertyName，p:propertyName-ref\n\n- 类型：**属性**\n\n- 归属：bean标签\n\n- 作用：为bean注入属性值\n\n- 格式：\n\n  ```xml\n  <bean p:propertyName="propertyValue" p:propertyName-ref="beanId"/>\n  ```\n\n- 注意：使用p命令空间需要先开启spring对p命令空间的的支持，在beans标签中添加对应空间支持\n\n  ```xml\n  <beans xmlns="http://www.springframework.org/schema/beans"    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"    xmlns:p="http://www.springframework.org/schema/p"       xsi:schemaLocation="http://www.springframework.org/schema/beans     https://www.springframework.org/schema/beans/spring-beans.xsd">\n  ```\n\n  后续课程中还将开启其他的命名空间，方式同上\n\n- 案例：\n\n  ```xml\n   <bean\n         id="userService"\n         class="com.itheima.service.impl.UserServiceImpl"\n         p:userDao-ref="userDao"\n         p:bookDao-ref="bookDao"\n         />\n  ```\n\n  \n\n### 4.10)SpEL （了解）\n\n- Spring提供了对EL表达式的支持，统一属性注入格式\n\n- 类型：**属性值**\n\n- 归属：value属性值\n\n- 作用：为bean注入属性值\n\n- 格式：\n\n  ```xml\n  <property value="EL"></bean>\n  ```\n\n- 注意：所有属性值不区分是否引用类型，统一使用value赋值\n\n- 所有格式统一使用  value=“********”\n\n  - 常量  #{10}  #{3.14}  #{2e5}  #{‘itcast’}\n\n  - 引用bean  #{beanId}    \n\n  - 引用bean属性  #{beanId.propertyName}\n\n  - 引用bean方法  beanId.methodName().method2()\n\n  - 引用静态方法  T(java.lang.Math).PI\n\n  - 运算符支持  #{3 lt 4 == 4 ge 3}\n\n  - 正则表达式支持  #{user.name matches‘[a-z]{6,}’}\n\n  - 集合支持  #{likes[3]}\n\n- 案例：\n\n  ```xml\n   <bean id="userService" class="com.itheima.service.impl.UserServiceImpl">\n       <property name="userDao" value="#{userDao}"/>\n       <property name="bookDao" value="#{bookDao}"/>\n       <property name="num" value="#{666666666}"/>\n       <property name="version" value="#{\'itcast\'}"/>\n  </bean>\n  ```\n\n### 4.11)properties文件\n\n- Spring提供了读取外部properties文件的机制，使用读取到的数据为bean的属性赋值\n\n- 操作步骤\n\n  1.准备外部properties文件\n\n  2.开启context命名空间支持\n\n  ```xml\n  xmlns:context="http://www.springframework.org/schema/context"\n  ```\n\n​\t\t3.加载指定的properties文件\n\n```xml\n<context:property-placeholder location="classpath:filename.properties">\n```\n\n​\t\t4.使用加载的数据\n\n```xml\n<property name="propertyName" value="${propertiesName}"/>\n```\n\n- 注意：如果需要加载所有的properties文件，可以使用`*.properties`表示加载所有的properties文件\n\n- 注意：读取数据使用**${propertiesName}**格式进行，其中**propertiesName**指properties文件中的属性名\n\n### 4.12)团队开发\n\n- 名称：import\n\n- 类型：**标签**\n\n- 归属：beans标签\n\n- 作用：在当前配置文件中导入其他配置文件中的项\n\n- 格式：\n\n  ```xml\n  <beans>\n      <import />\n  </beans>\n  ```\n\n- 基本属性：\n\n  ```xml\n  <import resource=“config.xml"/>\n  ```\n\n​\tresource：加载的配置文件名\n\n- Spring容器加载多个配置文件\n\n  ```java\n  new ClassPathXmlApplicationContext("config1.xml","config2.xml");\n  ```\n\n- Spring容器中的bean定义冲突问题\n\n  - 同id的bean，后定义的覆盖先定义的\n\n  - 导入配置文件可以理解为将导入的配置文件复制粘贴到对应位置\n\n  - 导入配置文件的顺序与位置不同可能会导致最终程序运行结果不同\n\n### 4.13)ApplicationContext\n\n1.ApplicationContext是一个接口，提供了访问spring容器的API\n\n2.ClassPathXmlApplicationContext是一个类，实现了上述功能\n\n3.ApplicationContext的顶层接口是BeanFactory\n\n4.BeanFactory定义了bean相关的最基本操作\n\n5.ApplicationContext在BeanFactory基础上追加了若干新功能\n\n**对比BeanFactory**\n\n1.BeanFactory创建的bean采用延迟加载形式，使用才创建\n\n2.ApplicationContext创建的bean默认采用立即加载形式\n\n**FileSystemXmlApplicationContext**\n\n可以加载文件系统中任意位置的配置文件，而ClassPathXmlApplicationContext只能加载类路径下的配置文件\n\n![1591021082290](./Spring-day01/1591021082290.png)\n\n**BeanFactory**\n\n```java\nResource res = new ClassPathResource("applicationContext.xml");\nBeanFactory bf = new XmlBeanFactory(res);\nUserService userService = (UserService)bf.getBean("userService");\n```\n\n### 4.14)第三方资源配置\n\n- 阿里数据源方案Druid\n\n  ```xml\n  <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">\n      <property name="driverClassName" value="com.mysql.jdbc.Driver"></property>\n      <property name="url" value="jdbc:mysql://localhost:3306/spring_ioc"></property>\n      <property name="username" value="root"></property>\n      <property name="password" value="root"></property>\n  </bean>\n  \n  ```\n\n## 5)综合案例\n\n### **5.1)案例介绍**\n\n- 使用spring整合mybatis技术，完成账户模块（Account）的基础增删改查功能\n\n- 账户模块对应字段\n\n  - 编号：id\n\n  - 账户名：name\n\n  - 余额：money\n\n### **5.2)案例分析**\n\n非spring环境\n\n1.实体类与表\n\n2.业务层接口与实现\n\n3.数据层接口\n\n4.Mybatis核心配置\n\n5.Mybatis映射配置\n\n6.客户端程序测试功能\n\n\n\nspring环境\n\n1.实体类与表\n\n2.业务层接口与实现（提供数据层接口的注入操作）\n\n3.数据层接口\n\n4.Mybatis核心配置（交给spring控制，该文件省略）\n\n5.Mybatis映射配置\n\n6.客户端程序测试功能（使用spring方式获取bean）\n\n7.Spring核心配置文件\n\n8.Druid数据源的应用（可选）\n\n9.Spring整合MyBatis\n\n\n\n### 5.3)案例制作步骤——基础准备工作\n\n- 环境准备\n\n1.导入Spring坐标，MyBatis坐标，MySQL坐标，Druid坐标\n\n- 业务类与接口准备\n\n2.创建数据库表，并制作相应的实体类Account\n\n3.定义业务层接口与数据层接口\n\n4.在业务层调用数据层接口，并实现业务方法的调用\n\n- 基础配置文件\n\n5.jdbc.properties\n\n6.MyBatis映射配置文件\n\n### 5.4)案例制作步骤——整合准备工作\n\n- 整合前基础准备工作\n\n1.spring配置文件，加上context命名空间，用于加载properties文件\n\n2.开启加载properties文件\n\n3.配置数据源druid（备用）\n\n4.定义service层bean，注入dao层bean\n\n5.dao的bean无需定义，使用代理自动生成\n\n### 5.5)案例制作步骤——整合工作\n\n- 整合工作\n\n1.导入Spring整合MyBatis坐标\n\n2.将mybatis配置成spring管理的bean（SqlSessionFactoryBean）\n\n​\t-将原始配置文件中的所有项，转入到当前配置中\n\n​\t数据源转换\n\n​\t映射转换\n\n3.通过spring加载mybatis的映射配置文件到spring环境中\n\n4.设置类型别名\n\n- 测试结果\n\n5.使用spring环境加载业务层bean，执行操作\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd">\n\n    \x3c!--加载perperties配置文件的信息--\x3e\n    <context:property-placeholder location="classpath:*.properties"/>\n\n    \x3c!--加载druid资源--\x3e\n    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">\n        <property name="driverClassName" value="${jdbc.driver}"/>\n        <property name="url" value="${jdbc.url}"/>\n        <property name="username" value="${jdbc.username}"/>\n        <property name="password" value="${jdbc.password}"/>\n    </bean>\n\n    \x3c!--配置service作为spring的bean,注入dao--\x3e\n    <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl">\n        <property name="accountDao" ref="accountDao"/>\n    </bean>\n\n    \x3c!--spring整合mybatis后控制的创建连接用的对象--\x3e\n    <bean class="org.mybatis.spring.SqlSessionFactoryBean">\n        <property name="dataSource" ref="dataSource"/>\n        <property name="typeAliasesPackage" value="com.itheima.domain"/>\n    </bean>\n\n    \x3c!--加载mybatis映射配置的扫描，将其作为spring的bean进行管理--\x3e\n    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">\n        <property name="basePackage" value="com.itheima.dao"/>\n    </bean>\n\n\n\n</beans>\n\n\n\n```\n\n\n### **小节**\n\n- 需要专用的spring整合mybatis的jar包\n\n- Mybatis核心配置文件消失\n\n  - 环境environment转换成数据源对象\n\n  - 映射Mapper扫描工作交由spring处理\n\n  - 类型别名交由spring处理\n\n- 业务发起使用spring上下文对象获取对应的bean\n\n'},"20e7":function(n,e,t){var r={"./BIO,NIO,AIO总结.md":"0186","./IO模型.md":"5be8","./J2EE基础知识.md":"e8ec","./JAVA核心知识点最详细版.md":"fd4e","./Java基础知识.md":"1229","./Java基础知识疑难点.md":"9d3e","./Java常见关键字总结.md":"71cb","./代理模式详解.md":"4989","./反射机制.md":"8b79","./用好Java中的枚举真的没有那么简单.md":"8b11"};function a(n){var e=i(n);return t(e)}function i(n){if(!t.o(r,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return r[n]}a.keys=function(){return Object.keys(r)},a.resolve=i,n.exports=a,a.id="20e7"},"21b0":function(n,e,t){"use strict";t.r(e),e["default"]='# Maven基础\r\n\r\n## 学习目标\r\n\r\n目标1：能够说出maven的作用，POM的概念\r\n\r\n目标2：完成maven的下载，安装和环境配置\r\n\r\n目标3：能够说出仓库，坐标的概念，完成仓库的配置\r\n\r\n目标4：完成手动搭建maven项目的案例\r\n\r\n目标5：完成IDEA工具搭建maven项目的案例\r\n\r\n目标6：能够说出依赖的传递方式和如何解决依赖传递冲突\r\n\r\n目标7：能够说出maven的生命周期\r\n\r\n## 1.Maven简介\r\n\r\n### 1.1 Maven是什么\r\n\r\n在学习Maven之前，我们先来看一下我们现在做的项目都有哪些问题。假设你现在做了一个crm的系统，项目中肯定要用到一些jar包，比如说mybatis，log4j，JUnit等，除了这些之外，你有可能用到你的同事开发的其他的东西，比如说别人做了一个财务模块或做了一个结算的模块，你在这里边有可能要用到这些东西。\r\n\r\n![](./Maven基础.img/1.png)\r\n\r\n假如有一天你们的项目中mybatis进行了一个升级，但是它内部使用的JUnit没有升级，你升级以后的mybatis假如要用5.0的JUnit，而你项目中目前用的是4.0的，会不会冲突？必然会出问题！这个时候管理起来会比较麻烦，你需要各种调整。更有甚者，假如同事做的这些东西升级了但又没有通知你，这个时候，就会出现几种严重的问题：\r\n\r\n（1）jar包不统一，jar不兼容\r\n\r\n（2）工程升级维护过程操作繁琐\r\n\r\n除此之外，还会有其它的一系列问题。那么要解决这些问题，就用到了我们今天要讲的Maven了。\r\n\r\n\r\n\r\n那**Maven是什么**？\r\n\r\n​\t**Maven的本质是一个项目管理工具，将项目开发和管理过程抽象成一个项目对象模型（POM）**\r\n\r\nMaven是用Java语言编写的。他管理的东西统统以面向对象的形式进行设计，最终他把一个项目看成一个对象，而这个对象叫做POM(project  object model)，即项目对象模型\r\n\r\n![](./Maven基础.img/2.png)\r\n\r\n我们说一个项目就是一个对象，作为对象的行为、对象的属性都有哪些呢？\r\n\r\nMaven说我们需要编写一个pom.xml文件，Maven通过加载这个配置文件就可以知道我们项目的相关信息了！到这里我们知道了Maven离不开一个叫pom.xml的文件。因为这个文件代表就一个项目。\r\n\r\n>提个问题大家思考，如果我们做8个项目，对应的是1个文件，还是8个文件？肯定是8个！\r\n\r\n那Maven是如何帮我们进行项目资源管理的呢？这就需要用到Maven中的第二个东西：**依赖管理**。这也是它的第二个核心！\r\n\r\n所谓依赖管理就是maven对项目所有依赖资源的一种管理，它和项目之间是一种双向关系，即当我们做项目的时候maven的依赖管理可以帮助你去管理你所需要的其他资源，当其他的项目需要依赖我们项目的时候，maven也会把我们的项目当作一种资源去进行管理，这就是一种双向关系。\r\n\r\n那maven的依赖管理它管理的这些资源存在哪儿呢？主要有三个位置：本地仓库，私服，中央仓库\r\n\r\n本地仓库顾名思义就是存储在本地的一种资源仓库，如果本地仓库中没有相关资源，可以去私服上获取，私服也是一个资源仓库，只不过不在本地，是一种远程仓库，如果私服上也没有相关资源，可以去中央仓库去获取，中央仓库也是一种远程仓库。\r\n\r\nMaven除了帮我们管理项目资源之外还能帮助我们对项目进行构建，管理项目的整个生命周期，当然它的这些功能需要使用一些相关的插件来完成，当然整个生命周期过程中插件是需要配合使用的，单独一个无法完成完整的生命周期。\r\n\r\n### 1.2 Maven的作用\r\n\r\nMaven的作用我们可以分成三类：\r\n\r\n（1）项目构建：提供标准的，跨平台的自动化构建项目的方式\r\n\r\n（2）依赖管理：方便快捷的管理项目依赖的资源（jar包），避免资源间的版本冲突等问题\r\n\r\n（3）统一开发结构：提供标准的，统一的项目开发结构，如下图所示：\r\n\r\n![](./Maven基础.img/4.png)\r\n\r\n各目录存放资源类型说明：\r\n\r\n**src/main/java**：项目java源码\r\n\r\n**src/main/resources**：项目的相关配置文件（比如mybatis配置，xml映射配置，自定义配置文件等）\r\n\r\n**src/main/webapp**：web资源（比如html，css，js等）\r\n\r\nsrc/test/java：测试代码\r\n\r\nsrc/test/resources：测试相关配置文件\r\n\r\nsrc/pom.xml：项目pom文件\r\n\r\n## 2.Maven环境搭建\r\n\r\nmaven的官网：http://maven.apache.org/\r\n\r\n### 2.1 下载\r\n\r\n官方下载地址：http://maven.apache.org/download.cgi\r\n\r\n![](./Maven基础.img/5.png)\r\n\r\n在今日课程资料`安装程序`中给大家提供了已经下载好的包，我们可以直接使用\r\n\r\n### 2.2 安装\r\n\r\nmaven是一个绿色软件，解压即安装，非常容易，\r\n\r\n我们找到今日课程资料中的`安装程序`，将里面的`apache-maven-3.6.1-bin.zip`直接解压到D盘根目录下即可\r\n\r\n解压完成后我们可以查看一下maven自己的一个目录结构如下\r\n\r\n![](./Maven基础.img/6.png)\r\n\r\n各目录结构说明：\r\n\r\nbin：可执行程序目录，\r\n\r\nboot：maven自身的启动加载器\r\n\r\nconf：maven配置文件的存放目录\r\n\r\nlib：maven运行所需库的存放目录\r\n\r\n### 2.3 环境配置\r\n\r\nmaven的运行需要java的环境，需要我们配置`JAVA_HOME`环境变量，这个相信大家已经存在了\r\n\r\n下面在去配置`MAVEN_HOME`的环境变量\r\n\r\n1：`我的电脑`--------\x3e`属性`---------\x3e`高级系统设置`----------\x3e`新建系统变量MAVEN_HOME`，\r\n\r\n![](./Maven基础.img/7.png)\r\n\r\n系统变量值就是maven软件的根目录，我们刚刚已经将maven解压到D盘了，因此变量值就如图中所示\r\n\r\n2：环境变量配置好之后需要测试环境配置结果，我们需要在DOS命令窗口下输入以下命令查看输出\r\n\r\n```bash\r\nmvn -v\r\n```\r\n\r\n![](./Maven基础.img/8.png)\r\n\r\n如果能够看到输出的maven的版本信息代表配置成功\r\n\r\n## 3.Maven基础概念\r\n\r\n### 3.1 仓库\r\n\r\n仓库：用于存储资源，主要是各种jar包\r\n\r\n![](./Maven基础.img/9.png)\r\n\r\n关于仓库，我们前面讲到了有三种：本地仓库，私服，中央仓库，其中私服和中央仓库都属于远程仓库\r\n\r\n**中央仓库**：maven团队自身维护的仓库，属于开源的\r\n\r\n**私服**：各公司/部门等小范围内存储资源的仓库，私服也可以从中央仓库获取资源\r\n\r\n**本地仓库**：开发者自己电脑上存储资源的仓库，也可从远程仓库获取资源\r\n\r\n\r\n\r\n**私服的作用：**\r\n\r\n（1）保存具有版权的资源，包含购买或自主研发的jar\r\n\r\n（2）一定范围内共享资源，能做到仅对内不对外开放\r\n\r\n### 3.2 坐标\r\n\r\n我们说maven的仓库里存储了各种各样的资源（jar包），那这些资源我们如何找到它们呢？我们需要知道它们具体的一个位置才能知道如何找到它们，这个就叫坐标\r\n\r\n**坐标**：maven中的坐标用于描述仓库中资源的位置\r\n\r\nhttps://repo1.maven.org/maven2/\r\n\r\n那maven中的坐标是如何构成的呢？\r\n\r\nmaven坐标的主要组成如下：\r\n\r\n**groupId**：定义当前资源隶属组织名称（通常是域名反写，如：org.mybatis；com.itheima）\r\n\r\n**artifactId**：定义当前资源的名称（通常是项目或模块名称，如：crm，sms）\r\n\r\n**version**：定义当前资源的版本号\r\n\r\n>packaging：定义资源的打包方式，取值一般有如下三种\r\n>\r\n>（1）jar：该资源打成jar包，默认是jar\r\n>\r\n>（2）war：该资源打成war包\r\n>\r\n>（3）pom：该资源是一个父资源（表明使用maven分模块管理），打包时只生成一个pom.xml不生成jar或其他包结构\r\n\r\n如果要查询maven某一个资源的坐标，我们通常可以去maven的仓库进行查询，\r\n\r\n<https://mvnrepository.com/>，在该网站中可直接搜索想要的资源，然后就能得到该资源的坐标\r\n\r\n输入资源名称进行检索\r\n\r\n![](./Maven基础.img/10.png)\r\n\r\n点击你想要的资源进行查看\r\n\r\n![](./Maven基础.img/11.png)\r\n\r\n选择版本查看坐标\r\n\r\n![](./Maven基础.img/12.png)\r\n\r\n\r\n\r\n**maven坐标的作用：**\r\n\r\n使用唯一标识，唯一性定义资源位置，通过该标识可以将资源的识别与下载工作交由机器完成。\r\n\r\n### 3.3 仓库配置\r\n\r\n开发者要在自己电脑上做开发，首先要做的就是配置本地仓库\r\n\r\n默认情况下maven本地仓库的位置在哪儿呢？\r\n\r\n我们可以选择在全局进行配置，在maven的配置文件`conf/settings.xml`中可以找到它的说明\r\n\r\n```xml\r\n  \x3c!-- localRepository\r\n   | The path to the local repository maven will use to store artifacts.\r\n   |\r\n   | Default: ${user.home}/.m2/repository\r\n  <localRepository>/path/to/local/repo</localRepository>\r\n  --\x3e\r\n```\r\n\r\n也就是在系统盘当前用户目录下的`.m2/repository`，比如我当前的系统用户是`zs`，则默认的本地仓库仓库位置在`C:\\Users\\zs\\.m2\\repository`\r\n\r\n因为我们平时开发项目所有的资源会比较多，而且各种资源还有好多的版本，资源与资源之间还有相互依赖的这种情况，因此本地仓库保存的内容会非常的多，它的体积会很大，如果放在C盘下不太合适，因此我们可以自己来指定一个位置作为本地仓库的位置，这个指定同样是需要来修改maven的配置文件`conf/settings.xml`\r\n\r\n在我们前面查看这个文件的时候大家会发现它提供了一个标签`<localRepository>/path/to/local/repo</localRepository>`，\r\n\r\n这个标签中配置的值就是我们本地仓库的位置，但是这个标签是在注释中的，也就是说目前不起作用，因此我们要将该标签挪出注释，并修改标签内的值，指定一个新的位置作为本地仓库的位置，例如\r\n\r\n```xml\r\n  \x3c!-- localRepository\r\n   | The path to the local repository maven will use to store artifacts.\r\n   |\r\n   | Default: ${user.home}/.m2/repository\r\n  <localRepository>/path/to/local/repo</localRepository>\r\n  --\x3e\r\n<localRepository>D:\\maven-repository</localRepository>\r\n```\r\n\r\n如果是局部用户配置：在仓库的同级目录也可以包含一个`settings.xml`配置文件，在里面也可以进行指定\r\n\r\n注意：局部用户配置优先与全局配置（遇见相同配置项的时候）\r\n\r\n![](./Maven基础.img/17.png)\r\n\r\n\r\n\r\n另外大家需要注意：maven默认连接的远程仓库位置是：（即中央仓库）\r\n\r\n![](./Maven基础.img/18.png)\r\n\r\n此站点并不在国内，因此有时候下载速度非常慢，因此我们可以配置一个国内站点镜像，可用于加速下载资源\r\n\r\n我们在`conf/settings.xml`配置文件中找到`<mirrors>`标签，在这组标签下添加镜像的配置，如下\r\n\r\n```xml\r\n<mirror>\r\n    <id>nexus-aliyun</id>\r\n    <mirrorOf>central</mirrorOf>\r\n    <name>Nexus aliyun</name>\r\n    <url>http://maven.aliyun.com/nexus/content/groups/public</url>\r\n</mirror>\r\n```\r\n\r\n## 4.Maven项目搭建\r\n\r\n我们回顾一下maven规范的目录结构：\r\n\r\n![](./Maven基础.img/13.png)\r\n\r\n### 4.1 手动搭建maven项目\r\n\r\n我们先使用手动的方式来创建maven项目\r\n\r\n（1）在D盘下创建目录`mvnproject`并进入该目录，作为我们的操作目录\r\n\r\n（2）创建我们的maven项目，创建一个目录`project-java`作为我们的项目文件夹，并进入到该目录\r\n\r\n（3）创建java代码（源代码）所在目录，即创建`src/main/java`\r\n\r\n（4）创建配置文件所在目录，即创建`src/main/resources`\r\n\r\n（5）创建测试源代码所在目录，即创建`src/test/java`\r\n\r\n（6）创建测试存放配置文件存放目录，即`src/test/resources`\r\n\r\n（7）在`src/main/java`中创建一个包（注意在windos文件夹下就是创建目录）`com/itheima`，在该目录下创建`Demo.java`文件，作为演示所需java程序，内容如下\r\n\r\n```java\r\npackage com.itheima;\r\n\r\npublic class Demo{\r\n\tpublic String say(String name){\r\n\t\tSystem.out.println("hello "+name);\r\n\t\treturn "hello "+name;\r\n\t}\r\n}\r\n```\r\n\r\n（8）在`src/test/java`中创建一个测试包（目录）`com/itheima`，在该包下创建测试程序`DemoTest.java`\r\n\r\n```java\r\npackage com.itheima;\r\n\r\nimport org.junit.*;\r\npublic class DemoTest{\r\n\t\r\n\t@Test\r\n\tpublic void testSay(){\r\n\t\tDemo d = new Demo();\r\n\t\tString ret = d.say("maven");\r\n\t\tAssert.assertEquals("hello maven",ret);\r\n\t}\r\n\t\r\n}\r\n```\r\n\r\n（9）在`project-java/src`下创建`pom.xml`文件，编辑如下\r\n\r\n```xml\r\n<?xml version="1.0" encoding="UTF-8"?>\r\n<project\r\n    xmlns="http://maven.apache.org/POM/4.0.0"\r\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\r\n    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">\r\n\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <groupId>com.itheima</groupId>\r\n    <artifactId>project-java</artifactId>\r\n    <version>1.0</version>\r\n    <packaging>jar</packaging>\r\n\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>junit</groupId>\r\n            <artifactId>junit</artifactId>\r\n            <version>4.12</version>\r\n        </dependency>\r\n    </dependencies>\r\n\r\n</project>\r\n```\r\n\r\n\r\n\r\n*通过前面的操作，我们已经搭建好了maven的项目结构，下面要通过maven来构建我们的项目*\r\n\r\nmaven的构建命令以`mvn`开头，后面添加功能参数，可以一次性执行多个命令，用空格分离\r\n\r\n`mvn compile`：编译\r\n\r\n`mvn clean`：清理\r\n\r\n`mvn test`：测试\r\n\r\n`mvn package`：打包\r\n\r\n`mvn install`：安装到本地仓库\r\n\r\n\r\n\r\n下面我们来进行操作：\r\n\r\n（1）在项目`project-java`所在的DOS命令窗口下执行`mvn compile`进行源码编译，当然首次执行需要先下载相关插件\r\n\r\n![](./Maven基础.img/15.png)\r\n\r\n编辑结果如下：\r\n\r\n![](./Maven基础.img/16.png)\r\n\r\n编译完成后在项目`project-java`下多了一个目录`target`，在这个目录下就存放的是maven编译好的一些东西\r\n\r\n![](./Maven基础.img/19.png)\r\n\r\n我们可以进入到`target`目录查看\r\n\r\n![](./Maven基础.img/20.png)\r\n\r\n其中生成的`classes`目录就是编译好的字节码文件\r\n\r\n（2）当然如果我们想清理掉这些东西，我们只需执行`mvn clean`命令即可，清理掉后`target`目录也就消失了\r\n\r\n（3）如果我们要执行测试包中的测试程序，我们只需执行`mvn test`命令即可\r\n\r\n![](./Maven基础.img/21.png)\r\n\r\n此时在看`target`目录会多一些东西\r\n\r\n![](./Maven基础.img/22.png)\r\n\r\n其中产生的`test-classes`就是测试代码的字节码文件，`surefire-reports`是它产生的测试报告\r\n\r\n![](./Maven基础.img/23.png)\r\n\r\n（4）使用`mvn package`命令进行打包，如下\r\n\r\n![](./Maven基础.img/24.png)\r\n\r\n在生成的`target`目录中可以看到打包的结果\r\n\r\n![](./Maven基础.img/25.png)\r\n\r\n当然，如果仔细看DOS窗口输出的我们会发现，`mvn package`命令的时候maven会把前面两个命令`mvn compile,mvn test`都执行一遍\r\n\r\n（5）使用`mvn install`命令进行安装，将项目打好的包存入本地仓库\r\n\r\n![](./Maven基础.img/26.png)\r\n\r\n>仔细查看输出会发现`mvn install`命令执行的时候也会将前面的命令都执行一遍\r\n\r\n此时我们可以去本地仓库中查找，如何查找？这个很重要\r\n\r\nmaven是按照`groupId/artifactId/version`的结构在本地仓库进行存储\r\n\r\n![](./Maven基础.img/27.png)\r\n\r\n\r\n\r\n\r\n\r\n前面我们是通过手动的方式创建的maven项目，相对来说比较的麻烦，maven本身也是这样觉得的，因此maven本身就给我们提供了相关的插件来帮助我们快速构建项目，当然这是一些命令：\r\n\r\n![](./Maven基础.img/28.png)\r\n\r\n这些命令不用记，因为实际操作的时候也用不着，因为实际开发的时候我们基本都是用过一些IDE工具来进行项目开发，这些IDE工具基本都集成了Maven，我们操作起来非常简单。\r\n\r\n### 4.2 IDEA工具搭建maven项目\r\n\r\n前面学习的基本都是通过命令来构建和管理项目，但是这在实际开发过程中基本不常用，常用的是通过相关IDE工具来进行项目的构建和管理，因此我们使用IDEA工具进行maven项目的搭建\r\n\r\n需要注意的是：Maven和IDEA在版本上存在一些兼容性问题，因为要合理的选择Maven和IDEA的版本，本课程中提供安装maven-3.6.1版本是可用的\r\n\r\n#### 4.2.1 不使用原型创建项目\r\n\r\n（1）在IDEA中配置Maven\r\n\r\n![](./Maven基础.img/29.png)\r\n\r\n（2）创建maven工程\r\n\r\n![](./Maven基础.img/30.png)\r\n\r\n（3）填写本项目的坐标\r\n\r\n![](./Maven基础.img/31.png)\r\n\r\n（4）查看各目录颜色标记是否正确\r\n\r\n![](./Maven基础.img/32.png)\r\n\r\n（5）IDEA右侧有一个maven管理界面，可点开查看\r\n\r\n![](./Maven基础.img/33.png)\r\n\r\n（6）在项目的pom.xml文件中添加项目资源依赖\r\n\r\n```xml\r\n<dependencies>\r\n    <dependency>\r\n        <groupId>junit</groupId>\r\n        <artifactId>junit</artifactId>\r\n        <version>4.12</version>\r\n    </dependency>\r\n</dependencies>\r\n```\r\n\r\n（7）创建源代码：com.itheima.Demo\r\n\r\n```java\r\npackage com.itheima;\r\n\r\n/**\r\n * Created by 传智播客*黑马程序员.\r\n */\r\npublic class Demo{\r\n    public String say(String name){\r\n        System.out.println("hello "+name);\r\n        return "hello "+name;\r\n    }\r\n}\r\n```\r\n\r\n（8）创建测试代码：com.itheima.DemoTest\r\n\r\n```java\r\npackage com.itheima;\r\n\r\nimport org.junit.Assert;\r\nimport org.junit.Test;\r\n\r\n/**\r\n * Created by 传智播客*黑马程序员.\r\n */\r\npublic class DemoTest{\r\n\r\n    @Test\r\n    public void testSay(){\r\n        Demo d = new Demo();\r\n        String ret = d.say("maven");\r\n        Assert.assertEquals("hello maven",ret);\r\n    }\r\n\r\n}\r\n```\r\n\r\n![](./Maven基础.img/34.png)\r\n\r\n然后可以进行测试运行\r\n\r\n\r\n\r\n运行的时候可以编辑运行模板：\r\n\r\n![](./Maven基础.img/35.png)\r\n\r\n\r\n\r\n然后点击运行：\r\n\r\n![](./Maven基础.img/36.png)\r\n\r\n\r\n\r\n#### 4.2.2 使用原型创建项目\r\n\r\n- 首先我们来看普通的java工程如何创建：\r\n\r\n（1）创建maven项目的时候选择使用原型骨架\r\n\r\n![](./Maven基础.img/37.png)\r\n\r\n（2）创建完成后发现通过这种方式缺少一些目录，如下图\r\n\r\n![](./Maven基础.img/38.png)\r\n\r\n**我们需要手动去补全目录，并且要对补全的目录进行标记，切记**\r\n\r\n![](./Maven基础.img/39.png)\r\n\r\n\r\n\r\n- 然后我们在来看web工程如何创建：\r\n\r\n（1）选择web对应的原型骨架\r\n\r\n>有很多的webapp原型骨架，选择哪个基本都差不多，包括前面创建普通项目也是一样，quickstart原型也有很多\r\n\r\n![](./Maven基础.img/40.png)\r\n\r\n（2）和前面创建普通项目一样，通过原型创建web项目得到的目录结构是不全的，因此需要我们自行补全，同时要标记正确，最终需要得到如下结构\r\n\r\n![](./Maven基础.img/41.png)\r\n\r\n（3）web工程创建好之后需要启动运行，需要使用一个tomcat插件来运行我们的项目，在`pom.xml`中添加插件的坐标即可，最终改好的`pom.xml`如下\r\n\r\n```xml\r\n<?xml version="1.0" encoding="UTF-8"?>\r\n\r\n<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\r\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\r\n  <modelVersion>4.0.0</modelVersion>\r\n\r\n  <groupId>com.itheima</groupId>\r\n  <artifactId>web01</artifactId>\r\n  <version>1.0-SNAPSHOT</version>\r\n  <packaging>war</packaging>\r\n\r\n  <name>web01 Maven Webapp</name>\r\n  <url>http://www.example.com</url>\r\n\r\n  <properties>\r\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\r\n    <maven.compiler.source>1.8</maven.compiler.source>\r\n    <maven.compiler.target>1.8</maven.compiler.target>\r\n  </properties>\r\n\r\n  <dependencies>\r\n    <dependency>\r\n      <groupId>junit</groupId>\r\n      <artifactId>junit</artifactId>\r\n      <version>4.12</version>\r\n      <scope>test</scope>\r\n    </dependency>\r\n  </dependencies>\r\n\r\n  <build>\r\n    <finalName>web01</finalName>\r\n    <plugins>\r\n      <plugin>\r\n        <groupId>org.apache.tomcat.maven</groupId>\r\n        <artifactId>tomcat7-maven-plugin</artifactId>\r\n        <version>2.1</version>\r\n      </plugin>\r\n    </plugins>\r\n  </build>\r\n</project>\r\n```\r\n\r\n（4）插件配置好后，在IDEA右侧`maven-project`操作面板上可以看到该插件，并且可以利用该插件启动项目\r\n\r\n![](./Maven基础.img/42.png)\r\n\r\n运行后该插件会给我们一个可运行地址：\r\n\r\n![](./Maven基础.img/43.png)\r\n\r\n如果我们想更换端口，只需要在`pom.xml`中配置该插件即可\r\n\r\n```xml\r\n<plugins>\r\n    <plugin>\r\n        <groupId>org.apache.tomcat.maven</groupId>\r\n        <artifactId>tomcat7-maven-plugin</artifactId>\r\n        <version>2.1</version>\r\n        <configuration>\r\n            <port>80</port>\r\n        </configuration>\r\n    </plugin>\r\n```\r\n\r\n（5）同时为了运行方便我们也可以创建运行模板：\r\n\r\n![](./Maven基础.img/44.png)\r\n\r\n## 5.Maven依赖管理\r\n\r\n### 5.1 依赖配置与依赖传递\r\n\r\n依赖是指在当前项目中运行所需的jar，依赖配置的格式如下图\r\n\r\n![](./Maven基础.img/45.png)\r\n\r\n\r\n\r\n**依赖传递：**\r\n\r\n依赖具有传递性，分两种\r\n\r\n（1）直接依赖：在当前项目中通过依赖配置建立的依赖关系\r\n\r\n（2）间接依赖：被依赖的资源如果依赖其他资源，则表明当前项目间接依赖其他资源\r\n\r\n注意：直接依赖和间接依赖其实也是一个相对关系\r\n\r\n![](./Maven基础.img/46.png)\r\n\r\n**依赖传递的冲突问题：**\r\n\r\n在依赖传递过程中产生了冲突，我们有三种优先法则\r\n\r\n（1）路径优先：当依赖中出现相同资源时，层级越深，优先级越低，反之则越高\r\n\r\n（2）声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖靠后的\r\n\r\n（3）特殊优先：当同级配置了相同资源的不同版本时，后配置的覆盖先配置的\r\n\r\n![](./Maven基础.img/47.png)\r\n\r\n**可选依赖**：\r\n\r\n![](./Maven基础.img/48.png)\r\n\r\n**排除依赖：**\r\n\r\n![](./Maven基础.img/49.png)\r\n\r\n### 5.2 依赖范围\r\n\r\n依赖的jar默认情况可以在任何地方可用，可以通过`scope`标签设定其作用范围\r\n\r\n这里的范围主要是指以下三种范围\r\n\r\n（1）主程序范围有效（src/main目录范围内）\r\n\r\n（2）测试程序范围内有效（src/test目录范围内）\r\n\r\n（3）是否参与打包（package指令范围内）\r\n\r\n此外：`scope`标签的取值有四种：`compile,test,provided,runtime`\r\n\r\n这四种取值与范围的对应情况如下：\r\n\r\n![](./Maven基础.img/50.png)\r\n\r\n\r\n\r\n**依赖范围的传递性：**\r\n\r\n![](./Maven基础.img/51.png)\r\n\r\n## 6.Maven生命周期与插件\r\n\r\n### 6.1 生命周期\r\n\r\nmaven的构建生命周期描述的是一次构建过程经历了多少个事件\r\n\r\n比如我们项目最常用的一套流程如下：\r\n\r\n![](./Maven基础.img/52.png)\r\n\r\n当然maven的生命周期不止这一套，总共分为3套，每套里面包含的事件如下\r\n\r\n（1）clean：清理工作\r\n\r\n>pre-clean：执行一些在clean之前的工作\r\n>\r\n>clean：移除上一次构建产生的所有文件\r\n>\r\n>post-clean：执行一些在clean之后立刻完成的工作\r\n\r\n（2）default：核心工作，例如编译，测试，打包，部署等\r\n\r\n>这里面的事件非常的多，如下图\r\n>\r\n>![](./Maven基础.img/53.png)\r\n\r\n**对于default生命周期，每个事件在执行之前都会将之前的所有事件依次执行一遍**\r\n\r\n（3）site：产生报告，发布站点等\r\n\r\n>pre-site：执行一些在生成站点文档之前的工作\r\n>\r\n>site：生成项目的站点文档\r\n>\r\n>post-site：执行一些在生成站点文档之后完成的工作，为部署做准备\r\n>\r\n>site-deploy：将生成的站点文档部署到特定的服务器上\r\n\r\n### 6.2 插件\r\n\r\n前面我们讲了maven生命周期中的相关事件，那这些事件是谁来执行的呢？答案是maven的插件\r\n\r\n**插件：**\r\n\r\n- 插件与生命周期内的阶段绑定，在执行到对应生命周期时执行对应的插件\r\n- maven默认在各个生命周期上都绑定了预先设定的插件来完成相应功能\r\n- 插件还可以完成一些自定义功能\r\n\r\n插件的配置方式如下：\r\n\r\n![](./Maven基础.img/54.png)\r\n\r\n在maven官网中有对插件的介绍：\r\n\r\nhttp://maven.apache.org/plugins/index.html\r\n\r\n'},"222c":function(n,e,t){"use strict";t.r(e),e["default"]='\x3c!--\n * @Date           : 2021-04-27 00:32:23\n * @FilePath       : /jinnian-space/src/pages/java/module/basics/md/day21-多线程01.md\n * @Description    : \n--\x3e\n## 1.实现多线程\n\n### 1.1简单了解多线程【理解】\n\n是指从软件或者硬件上实现多个线程并发执行的技术。\n具有多线程能力的计算机因有硬件支持而能够在同一时间执行多个线程，提升性能。\n\n![01_简单了解多线程](./day21-多线程01.img/01_简单了解多线程.png)\n\n### 1.2并发和并行【理解】\n\n+ 并行：在同一时刻，有多个指令在多个CPU上同时执行。\n\n  ![02_并行](./day21-多线程01.img/02_并行.png)\n\n+ 并发：在同一时刻，有多个指令在单个CPU上交替执行。\n\n  ![03_并发](./day21-多线程01.img/03_并发.png)\n\n### 1.3进程和线程【理解】\n\n- 进程：是正在运行的程序\n\n  独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位\n  动态性：进程的实质是程序的一次执行过程，进程是动态产生，动态消亡的\n  并发性：任何进程都可以同其他进程一起并发执行\n\n- 线程：是进程中的单个顺序控制流，是一条执行路径\n\n  ​\t单线程：一个进程如果只有一条执行路径，则称为单线程程序\n\n  ​\t多线程：一个进程如果有多条执行路径，则称为多线程程序\n\n  ​\t![04_多线程示例](./day21-多线程01.img/04_多线程示例.png)\n\n### 1.4实现多线程方式一：继承Thread类【应用】\n\n- 方法介绍\n\n  | 方法名          | 说明                         |\n  | ------------ | -------------------------- |\n  | void run()   | 在线程开启后，此方法将被调用执行           |\n  | void start() | 使此线程开始执行，Java虚拟机会调用run方法() |\n\n- 实现步骤\n  - 定义一个类MyThread继承Thread类\n  - 在MyThread类中重写run()方法\n  - 创建MyThread类的对象\n  - 启动线程\n\n- 代码演示\n\n  ```java\n  public class MyThread extends Thread {\n      @Override\n      public void run() {\n          for(int i=0; i<100; i++) {\n              System.out.println(i);\n          }\n      }\n  }\n  public class MyThreadDemo {\n      public static void main(String[] args) {\n          MyThread my1 = new MyThread();\n          MyThread my2 = new MyThread();\n\n  //        my1.run();\n  //        my2.run();\n\n          //void start() 导致此线程开始执行; Java虚拟机调用此线程的run方法\n          my1.start();\n          my2.start();\n      }\n  }\n  ```\n\n- 两个小问题\n\n  - 为什么要重写run()方法？\n\n    因为run()是用来封装被线程执行的代码\n\n  - run()方法和start()方法的区别？\n\n    run()：封装线程执行的代码，直接调用，相当于普通方法的调用\n\n    start()：启动线程；然后由JVM调用此线程的run()方法\n\n### 1.5实现多线程方式二：实现Runnable接口【应用】\n\n- Thread构造方法\n\n  | 方法名                                  | 说明             |\n  | ------------------------------------ | -------------- |\n  | Thread(Runnable target)              | 分配一个新的Thread对象 |\n  | Thread(Runnable target, String name) | 分配一个新的Thread对象 |\n\n- 实现步骤\n\n  - 定义一个类MyRunnable实现Runnable接口\n  - 在MyRunnable类中重写run()方法\n  - 创建MyRunnable类的对象\n  - 创建Thread类的对象，把MyRunnable对象作为构造方法的参数\n  - 启动线程\n\n- 代码演示\n\n  ```java\n  public class MyRunnable implements Runnable {\n      @Override\n      public void run() {\n          for(int i=0; i<100; i++) {\n              System.out.println(Thread.currentThread().getName()+":"+i);\n          }\n      }\n  }\n  public class MyRunnableDemo {\n      public static void main(String[] args) {\n          //创建MyRunnable类的对象\n          MyRunnable my = new MyRunnable();\n\n          //创建Thread类的对象，把MyRunnable对象作为构造方法的参数\n          //Thread(Runnable target)\n  //        Thread t1 = new Thread(my);\n  //        Thread t2 = new Thread(my);\n          //Thread(Runnable target, String name)\n          Thread t1 = new Thread(my,"坦克");\n          Thread t2 = new Thread(my,"飞机");\n\n          //启动线程\n          t1.start();\n          t2.start();\n      }\n  }\n  ```\n\n### 1.6实现多线程方式三: 实现Callable接口【应用】\n\n+ 方法介绍\n\n  | 方法名                              | 说明                                  |\n  | -------------------------------- | ----------------------------------- |\n  | V call()                         | 计算结果，如果无法计算结果，则抛出一个异常               |\n  | FutureTask(Callable<V> callable) | 创建一个 FutureTask，一旦运行就执行给定的 Callable |\n  | V get()                          | 如有必要，等待计算完成，然后获取其结果                 |\n\n+ 实现步骤\n\n  + 定义一个类MyCallable实现Callable接口\n  + 在MyCallable类中重写call()方法\n  + 创建MyCallable类的对象\n  + 创建Future的实现类FutureTask对象，把MyCallable对象作为构造方法的参数\n  + 创建Thread类的对象，把FutureTask对象作为构造方法的参数\n  + 启动线程\n  + 再调用get方法，就可以获取线程结束之后的结果。\n\n+ 代码演示\n\n  ```java\n  public class MyCallable implements Callable<String> {\n      @Override\n      public String call() throws Exception {\n          for (int i = 0; i < 100; i++) {\n              System.out.println("跟女孩表白" + i);\n          }\n          //返回值就表示线程运行完毕之后的结果\n          return "答应";\n      }\n  }\n  public class Demo {\n      public static void main(String[] args) throws ExecutionException, InterruptedException {\n          //线程开启之后需要执行里面的call方法\n          MyCallable mc = new MyCallable();\n\n          //Thread t1 = new Thread(mc);\n\n          //可以获取线程执行完毕之后的结果.也可以作为参数传递给Thread对象\n          FutureTask<String> ft = new FutureTask<>(mc);\n\n          //创建线程对象\n          Thread t1 = new Thread(ft);\n\n          String s = ft.get();\n          //开启线程\n          t1.start();\n\n          //String s = ft.get();\n          System.out.println(s);\n      }\n  }\n  ```\n\n+ 三种实现方式的对比\n  + 实现Runnable、Callable接口\n    + 好处: 扩展性强，实现该接口的同时还可以继承其他的类\n    + 缺点: 编程相对复杂，不能直接使用Thread类中的方法\n  + 继承Thread类\n    + 好处: 编程比较简单，可以直接使用Thread类中的方法\n    + 缺点: 可以扩展性较差，不能再继承其他的类\n\n### 1.7设置和获取线程名称【应用】\n\n- 方法介绍\n\n  | 方法名                        | 说明                 |\n  | -------------------------- | ------------------ |\n  | void  setName(String name) | 将此线程的名称更改为等于参数name |\n  | String  getName()          | 返回此线程的名称           |\n  | Thread  currentThread()    | 返回对当前正在执行的线程对象的引用  |\n\n- 代码演示\n\n  ```java\n  public class MyThread extends Thread {\n      public MyThread() {}\n      public MyThread(String name) {\n          super(name);\n      }\n\n      @Override\n      public void run() {\n          for (int i = 0; i < 100; i++) {\n              System.out.println(getName()+":"+i);\n          }\n      }\n  }\n  public class MyThreadDemo {\n      public static void main(String[] args) {\n          MyThread my1 = new MyThread();\n          MyThread my2 = new MyThread();\n\n          //void setName(String name)：将此线程的名称更改为等于参数 name\n          my1.setName("高铁");\n          my2.setName("飞机");\n\n          //Thread(String name)\n          MyThread my1 = new MyThread("高铁");\n          MyThread my2 = new MyThread("飞机");\n\n          my1.start();\n          my2.start();\n\n          //static Thread currentThread() 返回对当前正在执行的线程对象的引用\n          System.out.println(Thread.currentThread().getName());\n      }\n  }\n  ```\n\n### 1.8线程休眠【应用】\n\n+ 相关方法\n\n  | 方法名                            | 说明                       |\n  | ------------------------------ | ------------------------ |\n  | static void sleep(long millis) | 使当前正在执行的线程停留（暂停执行）指定的毫秒数 |\n\n+ 代码演示\n\n  ```java\n  public class MyRunnable implements Runnable {\n      @Override\n      public void run() {\n          for (int i = 0; i < 100; i++) {\n              try {\n                  Thread.sleep(100);\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n\n              System.out.println(Thread.currentThread().getName() + "---" + i);\n          }\n      }\n  }\n  public class Demo {\n      public static void main(String[] args) throws InterruptedException {\n          /*System.out.println("睡觉前");\n          Thread.sleep(3000);\n          System.out.println("睡醒了");*/\n\n          MyRunnable mr = new MyRunnable();\n\n          Thread t1 = new Thread(mr);\n          Thread t2 = new Thread(mr);\n\n          t1.start();\n          t2.start();\n      }\n  }\n  ```\n\n### 1.9线程优先级【应用】\n\n- 线程调度\n\n  - 两种调度方式\n    - 分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片\n    - 抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些\n\n  - Java使用的是抢占式调度模型\n\n  - 随机性\n\n    假如计算机只有一个 CPU，那么 CPU 在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。所以说多线程程序的执行是有随机性，因为谁抢到CPU的使用权是不一定的\n\n    ![05_多线程示例图](./day21-多线程01.img/05_多线程示例图.png)\n\n- 优先级相关方法\n\n  | 方法名                                     | 说明                                |\n  | --------------------------------------- | --------------------------------- |\n  | final int getPriority()                 | 返回此线程的优先级                         |\n  | final void setPriority(int newPriority) | 更改此线程的优先级线程默认优先级是5；线程优先级的范围是：1-10 |\n\n- 代码演示\n\n  ```java\n  public class MyCallable implements Callable<String> {\n      @Override\n      public String call() throws Exception {\n          for (int i = 0; i < 100; i++) {\n              System.out.println(Thread.currentThread().getName() + "---" + i);\n          }\n          return "线程执行完毕了";\n      }\n  }\n  public class Demo {\n      public static void main(String[] args) {\n          //优先级: 1 - 10 默认值:5\n          MyCallable mc = new MyCallable();\n\n          FutureTask<String> ft = new FutureTask<>(mc);\n\n          Thread t1 = new Thread(ft);\n          t1.setName("飞机");\n          t1.setPriority(10);\n          //System.out.println(t1.getPriority());//5\n          t1.start();\n\n          MyCallable mc2 = new MyCallable();\n\n          FutureTask<String> ft2 = new FutureTask<>(mc2);\n\n          Thread t2 = new Thread(ft2);\n          t2.setName("坦克");\n          t2.setPriority(1);\n          //System.out.println(t2.getPriority());//5\n          t2.start();\n      }\n  }\n  ```\n\n### 1.10守护线程【应用】\n\n- 相关方法\n\n  | 方法名                        | 说明                                   |\n  | -------------------------- | ------------------------------------ |\n  | void setDaemon(boolean on) | 将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出 |\n\n- 代码演示\n\n  ```java\n  public class MyThread1 extends Thread {\n      @Override\n      public void run() {\n          for (int i = 0; i < 10; i++) {\n              System.out.println(getName() + "---" + i);\n          }\n      }\n  }\n  public class MyThread2 extends Thread {\n      @Override\n      public void run() {\n          for (int i = 0; i < 100; i++) {\n              System.out.println(getName() + "---" + i);\n          }\n      }\n  }\n  public class Demo {\n      public static void main(String[] args) {\n          MyThread1 t1 = new MyThread1();\n          MyThread2 t2 = new MyThread2();\n\n          t1.setName("女神");\n          t2.setName("备胎");\n\n          //把第二个线程设置为守护线程\n          //当普通线程执行完之后,那么守护线程也没有继续运行下去的必要了.\n          t2.setDaemon(true);\n\n          t1.start();\n          t2.start();\n      }\n  }\n  ```\n\n## 2.线程同步\n\n### 2.1卖票【应用】\n\n- 案例需求\n\n  某电影院目前正在上映国产大片，共有100张票，而它有3个窗口卖票，请设计一个程序模拟该电影院卖票\n\n- 实现步骤\n\n  - 定义一个类SellTicket实现Runnable接口，里面定义一个成员变量：private int tickets = 100;\n\n  - 在SellTicket类中重写run()方法实现卖票，代码步骤如下\n\n  - 判断票数大于0，就卖票，并告知是哪个窗口卖的\n  - 卖了票之后，总票数要减1\n  - 票卖没了，线程停止\n  - 定义一个测试类SellTicketDemo，里面有main方法，代码步骤如下\n  - 创建SellTicket类的对象\n  - 创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称\n  - 启动线程\n\n- 代码实现\n\n  ```java\n  public class SellTicket implements Runnable {\n      private int tickets = 100;\n      //在SellTicket类中重写run()方法实现卖票，代码步骤如下\n      @Override\n      public void run() {\n          while (true) {\n              if(ticket <= 0){\n                      //卖完了\n                      break;\n                  }else{\n                      try {\n                          Thread.sleep(100);\n                      } catch (InterruptedException e) {\n                          e.printStackTrace();\n                      }\n                      ticket--;\n                      System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticket + "张票");\n                  }\n          }\n      }\n  }\n  public class SellTicketDemo {\n      public static void main(String[] args) {\n          //创建SellTicket类的对象\n          SellTicket st = new SellTicket();\n\n          //创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称\n          Thread t1 = new Thread(st,"窗口1");\n          Thread t2 = new Thread(st,"窗口2");\n          Thread t3 = new Thread(st,"窗口3");\n\n          //启动线程\n          t1.start();\n          t2.start();\n          t3.start();\n      }\n  }\n  ```\n\n\n### 2.2卖票案例的问题【理解】\n\n- 卖票出现了问题\n\n  - 相同的票出现了多次\n\n  - 出现了负数的票\n\n- 问题产生原因\n\n  线程执行的随机性导致的,可能在卖票过程中丢失cpu的执行权,导致出现问题\n\n\n### 2.3同步代码块解决数据安全问题【应用】\n\n- 安全问题出现的条件\n\n  - 是多线程环境\n\n  - 有共享数据\n\n  - 有多条语句操作共享数据\n\n- 如何解决多线程安全问题呢?\n\n  - 基本思想：让程序没有安全问题的环境\n\n- 怎么实现呢?\n\n  - 把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可\n\n  - Java提供了同步代码块的方式来解决\n\n- 同步代码块格式：\n\n  ```java\n  synchronized(任意对象) { \n  \t多条语句操作共享数据的代码 \n  }\n  ```\n\n  synchronized(任意对象)：就相当于给代码加锁了，任意对象就可以看成是一把锁\n\n- 同步的好处和弊端  \n\n  - 好处：解决了多线程的数据安全问题\n\n  - 弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率\n\n- 代码演示\n\n  ```java\n  public class SellTicket implements Runnable {\n      private int tickets = 100;\n      private Object obj = new Object();\n\n      @Override\n      public void run() {\n          while (true) {\n              synchronized (obj) { // 对可能有安全问题的代码加锁,多个线程必须使用同一把锁\n                  //t1进来后，就会把这段代码给锁起来\n                  if (tickets > 0) {\n                      try {\n                          Thread.sleep(100);\n                          //t1休息100毫秒\n                      } catch (InterruptedException e) {\n                          e.printStackTrace();\n                      }\n                      //窗口1正在出售第100张票\n                      System.out.println(Thread.currentThread().getName() + "正在出售第" + tickets + "张票");\n                      tickets--; //tickets = 99;\n                  }\n              }\n              //t1出来了，这段代码的锁就被释放了\n          }\n      }\n  }\n\n  public class SellTicketDemo {\n      public static void main(String[] args) {\n          SellTicket st = new SellTicket();\n\n          Thread t1 = new Thread(st, "窗口1");\n          Thread t2 = new Thread(st, "窗口2");\n          Thread t3 = new Thread(st, "窗口3");\n\n          t1.start();\n          t2.start();\n          t3.start();\n      }\n  }\n  ```\n\n### 2.4同步方法解决数据安全问题【应用】\n\n- 同步方法的格式\n\n  同步方法：就是把synchronized关键字加到方法上\n\n  ```java\n  修饰符 synchronized 返回值类型 方法名(方法参数) { \n  \t方法体；\n  }\n  ```\n\n  同步方法的锁对象是什么呢?\n\n  ​\tthis\n\n- 静态同步方法\n\n  同步静态方法：就是把synchronized关键字加到静态方法上\n\n  ```java\n  修饰符 static synchronized 返回值类型 方法名(方法参数) { \n  \t方法体；\n  }\n  ```\n\n  同步静态方法的锁对象是什么呢?\n\n  ​\t类名.class\n\n- 代码演示\n\n  ```java\n  public class MyRunnable implements Runnable {\n      private static int ticketCount = 100;\n\n      @Override\n      public void run() {\n          while(true){\n              if("窗口一".equals(Thread.currentThread().getName())){\n                  //同步方法\n                  boolean result = synchronizedMthod();\n                  if(result){\n                      break;\n                  }\n              }\n\n              if("窗口二".equals(Thread.currentThread().getName())){\n                  //同步代码块\n                  synchronized (MyRunnable.class){\n                      if(ticketCount == 0){\n                         break;\n                      }else{\n                          try {\n                              Thread.sleep(10);\n                          } catch (InterruptedException e) {\n                              e.printStackTrace();\n                          }\n                          ticketCount--;\n                          System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticketCount + "张票");\n                      }\n                  }\n              }\n\n          }\n      }\n\n      private static synchronized boolean synchronizedMthod() {\n          if(ticketCount == 0){\n              return true;\n          }else{\n              try {\n                  Thread.sleep(10);\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n              ticketCount--;\n              System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticketCount + "张票");\n              return false;\n          }\n      }\n  }\n\n\n  public class Demo {\n      public static void main(String[] args) {\n          MyRunnable mr = new MyRunnable();\n\n          Thread t1 = new Thread(mr);\n          Thread t2 = new Thread(mr);\n\n          t1.setName("窗口一");\n          t2.setName("窗口二");\n\n          t1.start();\n          t2.start();\n      }\n  }\n  ```\n\n\n### 2.5Lock锁【应用】\n\n虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock\n\nLock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化\n\n- ReentrantLock构造方法\n\n  | 方法名             | 说明                   |\n  | --------------- | -------------------- |\n  | ReentrantLock() | 创建一个ReentrantLock的实例 |\n\n- 加锁解锁方法\n\n  | 方法名           | 说明   |\n  | ------------- | ---- |\n  | void lock()   | 获得锁  |\n  | void unlock() | 释放锁  |\n\n- 代码演示\n\n  ```java\n  public class Ticket implements Runnable {\n      //票的数量\n      private int ticket = 100;\n      private Object obj = new Object();\n      private ReentrantLock lock = new ReentrantLock();\n\n      @Override\n      public void run() {\n          while (true) {\n              //synchronized (obj){//多个线程必须使用同一把锁.\n              try {\n                  lock.lock();\n                  if (ticket <= 0) {\n                      //卖完了\n                      break;\n                  } else {\n                      Thread.sleep(100);\n                      ticket--;\n                      System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticket + "张票");\n                  }\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              } finally {\n                  lock.unlock();\n              }\n              // }\n          }\n      }\n  }\n\n  public class Demo {\n      public static void main(String[] args) {\n          Ticket ticket = new Ticket();\n\n          Thread t1 = new Thread(ticket);\n          Thread t2 = new Thread(ticket);\n          Thread t3 = new Thread(ticket);\n\n          t1.setName("窗口一");\n          t2.setName("窗口二");\n          t3.setName("窗口三");\n\n          t1.start();\n          t2.start();\n          t3.start();\n      }\n  }\n  ```\n\n### 2.6死锁【理解】\n\n+ 概述\n\n  线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行\n\n+ 什么情况下会产生死锁\n\n  1. 资源有限\n  2. 同步嵌套\n\n+ 代码演示\n\n  ```java\n  public class Demo {\n      public static void main(String[] args) {\n          Object objA = new Object();\n          Object objB = new Object();\n\n          new Thread(()->{\n              while(true){\n                  synchronized (objA){\n                      //线程一\n                      synchronized (objB){\n                          System.out.println("小康同学正在走路");\n                      }\n                  }\n              }\n          }).start();\n\n          new Thread(()->{\n              while(true){\n                  synchronized (objB){\n                      //线程二\n                      synchronized (objA){\n                          System.out.println("小薇同学正在走路");\n                      }\n                  }\n              }\n          }).start();\n      }\n  }\n  ```\n\n## 3.生产者消费者\n\n### 3.1生产者和消费者模式概述【应用】\n\n- 概述\n\n  生产者消费者模式是一个十分经典的多线程协作的模式，弄懂生产者消费者问题能够让我们对多线程编程的理解更加深刻。\n\n  所谓生产者消费者问题，实际上主要是包含了两类线程：\n\n  ​\t一类是生产者线程用于生产数据\n\n  ​\t一类是消费者线程用于消费数据\n\n  为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库\n\n  生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为\n\n  消费者只需要从共享数据区中去获取数据，并不需要关心生产者的行为\n\n- Object类的等待和唤醒方法\n\n  | 方法名              | 说明                                       |\n  | ---------------- | ---------------------------------------- |\n  | void wait()      | 导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法 |\n  | void notify()    | 唤醒正在等待对象监视器的单个线程                         |\n  | void notifyAll() | 唤醒正在等待对象监视器的所有线程                         |\n\n### 3.2生产者和消费者案例【应用】\n\n- 案例需求\n\n  + 桌子类(Desk)：定义表示包子数量的变量,定义锁对象变量,定义标记桌子上有无包子的变量\n\n  + 生产者类(Cooker)：实现Runnable接口，重写run()方法，设置线程任务\n\n      1.判断是否有包子,决定当前线程是否执行\n\n      2.如果有包子,就进入等待状态,如果没有包子,继续执行,生产包子\n\n      3.生产包子之后,更新桌子上包子状态,唤醒消费者消费包子\n\n  + 消费者类(Foodie)：实现Runnable接口，重写run()方法，设置线程任务\n\n      1.判断是否有包子,决定当前线程是否执行\n\n      2.如果没有包子,就进入等待状态,如果有包子,就消费包子\n\n      3.消费包子后,更新桌子上包子状态,唤醒生产者生产包子\n\n  + 测试类(Demo)：里面有main方法，main方法中的代码步骤如下\n\n      创建生产者线程和消费者线程对象\n\n      分别开启两个线程\n\n- 代码实现\n\n  ```java\n  public class Desk {\n\n      //定义一个标记\n      //true 就表示桌子上有汉堡包的,此时允许吃货执行\n      //false 就表示桌子上没有汉堡包的,此时允许厨师执行\n      public static boolean flag = false;\n\n      //汉堡包的总数量\n      public static int count = 10;\n\n      //锁对象\n      public static final Object lock = new Object();\n  }\n\n  public class Cooker extends Thread {\n  //    生产者步骤：\n  //            1，判断桌子上是否有汉堡包\n  //    如果有就等待，如果没有才生产。\n  //            2，把汉堡包放在桌子上。\n  //            3，叫醒等待的消费者开吃。\n      @Override\n      public void run() {\n          while(true){\n              synchronized (Desk.lock){\n                  if(Desk.count == 0){\n                      break;\n                  }else{\n                      if(!Desk.flag){\n                          //生产\n                          System.out.println("厨师正在生产汉堡包");\n                          Desk.flag = true;\n                          Desk.lock.notifyAll();\n                      }else{\n                          try {\n                              Desk.lock.wait();\n                          } catch (InterruptedException e) {\n                              e.printStackTrace();\n                          }\n                      }\n                  }\n              }\n          }\n      }\n  }\n\n  public class Foodie extends Thread {\n      @Override\n      public void run() {\n  //        1，判断桌子上是否有汉堡包。\n  //        2，如果没有就等待。\n  //        3，如果有就开吃\n  //        4，吃完之后，桌子上的汉堡包就没有了\n  //                叫醒等待的生产者继续生产\n  //        汉堡包的总数量减一\n\n          //套路:\n              //1. while(true)死循环\n              //2. synchronized 锁,锁对象要唯一\n              //3. 判断,共享数据是否结束. 结束\n              //4. 判断,共享数据是否结束. 没有结束\n          while(true){\n              synchronized (Desk.lock){\n                  if(Desk.count == 0){\n                      break;\n                  }else{\n                      if(Desk.flag){\n                          //有\n                          System.out.println("吃货在吃汉堡包");\n                          Desk.flag = false;\n                          Desk.lock.notifyAll();\n                          Desk.count--;\n                      }else{\n                          //没有就等待\n                          //使用什么对象当做锁,那么就必须用这个对象去调用等待和唤醒的方法.\n                          try {\n                              Desk.lock.wait();\n                          } catch (InterruptedException e) {\n                              e.printStackTrace();\n                          }\n                      }\n                  }\n              }\n          }\n\n      }\n  }\n\n  public class Demo {\n      public static void main(String[] args) {\n          /*消费者步骤：\n          1，判断桌子上是否有汉堡包。\n          2，如果没有就等待。\n          3，如果有就开吃\n          4，吃完之后，桌子上的汉堡包就没有了\n                  叫醒等待的生产者继续生产\n          汉堡包的总数量减一*/\n\n          /*生产者步骤：\n          1，判断桌子上是否有汉堡包\n          如果有就等待，如果没有才生产。\n          2，把汉堡包放在桌子上。\n          3，叫醒等待的消费者开吃。*/\n\n          Foodie f = new Foodie();\n          Cooker c = new Cooker();\n\n          f.start();\n          c.start();\n\n      }\n  }\n  ```\n\n### 3.3生产者和消费者案例优化【应用】\n\n+ 需求\n\n  + 将Desk类中的变量,采用面向对象的方式封装起来\n  + 生产者和消费者类中构造方法接收Desk类对象,之后在run方法中进行使用\n  + 创建生产者和消费者线程对象,构造方法中传入Desk类对象\n  + 开启两个线程\n\n+ 代码实现\n\n  ```java\n  public class Desk {\n\n      //定义一个标记\n      //true 就表示桌子上有汉堡包的,此时允许吃货执行\n      //false 就表示桌子上没有汉堡包的,此时允许厨师执行\n      //public static boolean flag = false;\n      private boolean flag;\n\n      //汉堡包的总数量\n      //public static int count = 10;\n      //以后我们在使用这种必须有默认值的变量\n     // private int count = 10;\n      private int count;\n\n      //锁对象\n      //public static final Object lock = new Object();\n      private final Object lock = new Object();\n\n      public Desk() {\n          this(false,10); // 在空参内部调用带参,对成员变量进行赋值,之后就可以直接使用成员变量了\n      }\n\n      public Desk(boolean flag, int count) {\n          this.flag = flag;\n          this.count = count;\n      }\n\n      public boolean isFlag() {\n          return flag;\n      }\n\n      public void setFlag(boolean flag) {\n          this.flag = flag;\n      }\n\n      public int getCount() {\n          return count;\n      }\n\n      public void setCount(int count) {\n          this.count = count;\n      }\n\n      public Object getLock() {\n          return lock;\n      }\n\n      @Override\n      public String toString() {\n          return "Desk{" +\n                  "flag=" + flag +\n                  ", count=" + count +\n                  ", lock=" + lock +\n                  \'}\';\n      }\n  }\n\n  public class Cooker extends Thread {\n\n      private Desk desk;\n\n      public Cooker(Desk desk) {\n          this.desk = desk;\n      }\n  //    生产者步骤：\n  //            1，判断桌子上是否有汉堡包\n  //    如果有就等待，如果没有才生产。\n  //            2，把汉堡包放在桌子上。\n  //            3，叫醒等待的消费者开吃。\n\n      @Override\n      public void run() {\n          while(true){\n              synchronized (desk.getLock()){\n                  if(desk.getCount() == 0){\n                      break;\n                  }else{\n                      //System.out.println("验证一下是否执行了");\n                      if(!desk.isFlag()){\n                          //生产\n                          System.out.println("厨师正在生产汉堡包");\n                          desk.setFlag(true);\n                          desk.getLock().notifyAll();\n                      }else{\n                          try {\n                              desk.getLock().wait();\n                          } catch (InterruptedException e) {\n                              e.printStackTrace();\n                          }\n                      }\n                  }\n              }\n          }\n      }\n  }\n\n  public class Foodie extends Thread {\n      private Desk desk;\n\n      public Foodie(Desk desk) {\n          this.desk = desk;\n      }\n\n      @Override\n      public void run() {\n  //        1，判断桌子上是否有汉堡包。\n  //        2，如果没有就等待。\n  //        3，如果有就开吃\n  //        4，吃完之后，桌子上的汉堡包就没有了\n  //                叫醒等待的生产者继续生产\n  //        汉堡包的总数量减一\n\n          //套路:\n              //1. while(true)死循环\n              //2. synchronized 锁,锁对象要唯一\n              //3. 判断,共享数据是否结束. 结束\n              //4. 判断,共享数据是否结束. 没有结束\n          while(true){\n              synchronized (desk.getLock()){\n                  if(desk.getCount() == 0){\n                      break;\n                  }else{\n                      //System.out.println("验证一下是否执行了");\n                      if(desk.isFlag()){\n                          //有\n                          System.out.println("吃货在吃汉堡包");\n                          desk.setFlag(false);\n                          desk.getLock().notifyAll();\n                          desk.setCount(desk.getCount() - 1);\n                      }else{\n                          //没有就等待\n                          //使用什么对象当做锁,那么就必须用这个对象去调用等待和唤醒的方法.\n                          try {\n                              desk.getLock().wait();\n                          } catch (InterruptedException e) {\n                              e.printStackTrace();\n                          }\n                      }\n                  }\n              }\n          }\n\n      }\n  }\n\n  public class Demo {\n      public static void main(String[] args) {\n          /*消费者步骤：\n          1，判断桌子上是否有汉堡包。\n          2，如果没有就等待。\n          3，如果有就开吃\n          4，吃完之后，桌子上的汉堡包就没有了\n                  叫醒等待的生产者继续生产\n          汉堡包的总数量减一*/\n\n          /*生产者步骤：\n          1，判断桌子上是否有汉堡包\n          如果有就等待，如果没有才生产。\n          2，把汉堡包放在桌子上。\n          3，叫醒等待的消费者开吃。*/\n\n          Desk desk = new Desk();\n\n          Foodie f = new Foodie(desk);\n          Cooker c = new Cooker(desk);\n\n          f.start();\n          c.start();\n\n      }\n  }\n  ```\n\n### 3.4阻塞队列基本使用【理解】\n\n+ 阻塞队列继承结构\n\n  ![06_阻塞队列继承结构](./day21-多线程01.img/06_阻塞队列继承结构.png)\n\n\n+ 常见BlockingQueue:\n\n   ArrayBlockingQueue: 底层是数组,有界\n\n   LinkedBlockingQueue: 底层是链表,无界.但不是真正的无界,最大为int的最大值\n\n+ BlockingQueue的核心方法:\n\n   put(anObject): 将参数放入队列,如果放不进去会阻塞\n\n   take(): 取出第一个数据,取不到会阻塞\n\n+ 代码示例\n\n  ```java\n  public class Demo02 {\n      public static void main(String[] args) throws Exception {\n          // 创建阻塞队列的对象,容量为 1\n          ArrayBlockingQueue<String> arrayBlockingQueue = new ArrayBlockingQueue<>(1);\n\n          // 存储元素\n          arrayBlockingQueue.put("汉堡包");\n\n          // 取元素\n          System.out.println(arrayBlockingQueue.take());\n          System.out.println(arrayBlockingQueue.take()); // 取不到会阻塞\n\n          System.out.println("程序结束了");\n      }\n  }\n  ```\n\n### 3.5阻塞队列实现等待唤醒机制【理解】\n\n+ 案例需求\n\n  + 生产者类(Cooker)：实现Runnable接口，重写run()方法，设置线程任务\n\n      1.构造方法中接收一个阻塞队列对象\n\n      2.在run方法中循环向阻塞队列中添加包子\n\n      3.打印添加结果\n\n  + 消费者类(Foodie)：实现Runnable接口，重写run()方法，设置线程任务\n\n       1.构造方法中接收一个阻塞队列对象\n\n       2.在run方法中循环获取阻塞队列中的包子\n\n       3.打印获取结果\n\n  + 测试类(Demo)：里面有main方法，main方法中的代码步骤如下\n\n      创建阻塞队列对象\n\n      创建生产者线程和消费者线程对象,构造方法中传入阻塞队列对象\n\n      分别开启两个线程\n\n+ 代码实现\n\n  ```java\n  public class Cooker extends Thread {\n\n      private ArrayBlockingQueue<String> bd;\n\n      public Cooker(ArrayBlockingQueue<String> bd) {\n          this.bd = bd;\n      }\n  //    生产者步骤：\n  //            1，判断桌子上是否有汉堡包\n  //    如果有就等待，如果没有才生产。\n  //            2，把汉堡包放在桌子上。\n  //            3，叫醒等待的消费者开吃。\n\n      @Override\n      public void run() {\n          while (true) {\n              try {\n                  bd.put("汉堡包");\n                  System.out.println("厨师放入一个汉堡包");\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n          }\n      }\n  }\n\n  public class Foodie extends Thread {\n      private ArrayBlockingQueue<String> bd;\n\n      public Foodie(ArrayBlockingQueue<String> bd) {\n          this.bd = bd;\n      }\n\n      @Override\n      public void run() {\n  //        1，判断桌子上是否有汉堡包。\n  //        2，如果没有就等待。\n  //        3，如果有就开吃\n  //        4，吃完之后，桌子上的汉堡包就没有了\n  //                叫醒等待的生产者继续生产\n  //        汉堡包的总数量减一\n\n          //套路:\n          //1. while(true)死循环\n          //2. synchronized 锁,锁对象要唯一\n          //3. 判断,共享数据是否结束. 结束\n          //4. 判断,共享数据是否结束. 没有结束\n          while (true) {\n              try {\n                  String take = bd.take();\n                  System.out.println("吃货将" + take + "拿出来吃了");\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n          }\n\n      }\n  }\n\n  public class Demo {\n      public static void main(String[] args) {\n          ArrayBlockingQueue<String> bd = new ArrayBlockingQueue<>(1);\n\n          Foodie f = new Foodie(bd);\n          Cooker c = new Cooker(bd);\n\n          f.start();\n          c.start();\n      }\n  }\n  ```\n\n  ​\n\n\n\n'},"22c9":function(n,e,t){"use strict";t.r(e),e["default"]='# web综合案例\n\n## 1.登录功能\n\n###  1.1 登录功能\n\n（1）`MemberServlet`中添加login方法\n\n```java\n  public Result login(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        Member member = getData(request,Member.class);\n        member = memberService.login(member.getEmail(),member.getPassword());\n\n        if(member != null){\n            return new Result("登录成功！", member);\n        }else{\n            return new Result("用户名密码错误，请重试！", false, null, Code.LOGIN_FAIL);\n        }\n    }\n```\n\n（2）`Code`中添加 常量\n\n```java\npublic static final Integer LOGIN_FAIL = 50101;\n```\n\n（3）补全service和impl和dao、xml代码\n\n`MemberService`\n\n```java\n /**\n     * 根据email和密码登录\n     * @param email\n     * @param password\n     * @return\n     */\n    Member login(String email, String password);\n```\n\n\n\n`MemberServiceImpl`\n\n```java\n @Override\n    public Member login(String email, String password) {\n        SqlSession sqlSession = null;\n        try{\n            //1.获取SqlSession\n            sqlSession = MapperFactory.getSqlSession();\n            //2.获取Dao\n            MemberDao memberDao = MapperFactory.getMapper(sqlSession, MemberDao.class);\n            password = MD5Util.md5(password);\n            Member member = memberDao.findByEmailAndPwd(email,password);\n            return member;\n        }catch (Exception e){\n            e.printStackTrace();\n            throw new RuntimeException(e);\n            //记录日志\n        }finally {\n            try {\n                TransactionUtil.close(sqlSession);\n            }catch (Exception e){\n                e.printStackTrace();\n            }\n        }\n    }\n```\n\n`MemberDao`\n\n```java\nMember findByEmailAndPwd(@Param("email") String email,@Param("password") String password);\n```\n\n`MemberDao.xml`\n\n```xml\n\x3c!--配置查询的列名公共SQL语句--\x3e\n<sql \t\tid="Base_Column_List">id,nick_name,password,gender,birthday,email,telephone,address,register_date,state </sql>\n\n<select id="findByEmailAndPwd" parameterType="map" resultMap="BaseResultMap">\n    select \n    <include refid="Base_Column_List"/>\n\tfrom tr_memberwhere email = #{email,jdbcType=VARCHAR} and password = #{password,jdbcType=VARCHAR} \n</select>\n```\n\n（4）修改`login.html`，添加164行左右\n\n```html\n //根据返回的结果进行下一步的动作\n if( res.flag){\n     // 跳转页面 index.html\n     window.open("index.html","_self");\n }else{\n \talert(res.message);\n }\n```\n\n启动服务器，访问页面，进行登录\n\n\n\n###  1.2 将登陆信息保存到redis中\n\n（1）将资料中`工程资源文件`中的`JedisUtils`拷贝工程目录下。\n\n（2）将资料中`工程资源文件`中的`jedis.properties`拷贝到resources下\n\n（3）将登录用户id信息放入到redis是，修改``login 方法，添加如下代码\n\n```java\n@Override\n    public Member login(String email, String password) {\n        SqlSession sqlSession = null;\n        try{\n            //1.获取SqlSession\n            sqlSession = MapperFactory.getSqlSession();\n            //2.获取Dao\n            MemberDao memberDao = MapperFactory.getMapper(sqlSession, MemberDao.class);\n            password = MD5Util.md5(password);\n            Member member = memberDao.findByEmailAndPwd(email,password);\n\n            //3.将登录人的信息保存到redis中\n            Jedis jedis = JedisUtils.getResource();\n            //使用登录人的id作为key，设定3600秒的过期时间，value值待定\n            jedis.setex(member.getId(),3600,"");\n            jedis.close();\n\n            return member;\n        }catch (Exception e){\n            e.printStackTrace();\n            throw new RuntimeException(e);\n            //记录日志\n        }finally {\n            try {\n                TransactionUtil.close(sqlSession);\n            }catch (Exception e){\n                e.printStackTrace();\n            }\n        }\n    }\n```\n\n启动redis服务器。\n\n启动项目服务进行测试\n\n### 1.3 登陆状态校验\n\n（1）在`MemberServlet`中添加方法`checkLogin`方法，用于判断登录用户的id是否存在redis中\n\n```java\n public Result checkLogin(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        Member member = getData(request,Member.class);        //根据获取到的id去redis中查找，是否存在        String nickName = memberService.getLoginInfo(member.getId());        return new Result("", nickName);    }\n```\n\n（2）修改`index.html`中checkLogin()方法\n\n```javascript\n checkLogin() {    //判断当前用户是否登录了，判断现在是否有登录人的信息    /*  状态1：未登录    document.querySelector("#register").style.display = \'block\';    document.querySelector("#login").style.display = \'block\';    document.querySelector("#myexam").style.display = \'none\';    document.querySelector("#exam").style.display = \'none\';    document.querySelector("#exit").style.display = \'none\';    document.querySelector("#nickname").style.display = \'none\';    */    /*  状态2：已登录    document.querySelector("#register").style.display = \'none\';    document.querySelector("#login").style.display = \'none\';    document.querySelector("#myexam").style.display = \'block\';    document.querySelector("#exam").style.display = \'block\';    document.querySelector("#exit").style.display = \'block\';    document.querySelector("#nickname").style.display = \'block\';    */    let _this = this;    //从localStorage中获取数据，获取当前保存的用户名，再根据用户名获取后台是否登录的状态    if(!window.localStorage){    alert("浏览器不支持localStorage，请升级浏览器")    }else {    //获取localStorage对象    let storage = window.localStorage;    alert("id："+storage.id);    //测试是否有登录数据，id    if(storage.id ==  undefined){    //如果本地没有用户信息，显示登陆和注册按钮    document.querySelector("#register").style.display = \'block\';    document.querySelector("#login").style.display = \'block\';    document.querySelector("#myexam").style.display = \'none\';    document.querySelector("#exam").style.display = \'none\';    document.querySelector("#exit").style.display = \'none\';    document.querySelector("#nickname").style.display = \'none\';    }else {    //如果本地存在用户信息，需要确认服务器是否存在当前用户登录信息（redis中）    //发送请求，根据当前id去服务器中查找对应的数据    axios.post(\'/member/checkLogin\', \'{"id":"\'+storage.id+\'"}\').then(function (response) {    //alert(response.data.data)    //获取响应数据    let res = response.data;    //alert("redis服务器中存储的用户名信息  : "+res.data)    //判定本地用户对应是否处于登录状态，处于登录状态的用户具有用户名信息    if(res.data == undefined){    //如果没有用户名信息，当前用户未登录，显示登陆与注册按钮    document.querySelector("#register").style.display = \'block\';    document.querySelector("#login").style.display = \'block\';    document.querySelector("#myexam").style.display = \'none\';    document.querySelector("#exam").style.display = \'none\';    document.querySelector("#exit").style.display = \'none\';    document.querySelector("#nickname").style.display = \'none\';    }else{    //如果具有用户名信息，显示用户答题相关按钮    //设置vue对象nickname属性值    _this.nickname = res.data;    document.querySelector("#register").style.display = \'none\';    document.querySelector("#login").style.display = \'none\';    document.querySelector("#myexam").style.display = \'block\';    document.querySelector("#exam").style.display = \'block\';    document.querySelector("#exit").style.display = \'block\';    //显示当前登录用户对应的登录信息组件    document.querySelector("#nickname").style.display = \'block\';    }    }).catch(function (err) {    console.log(err)    });    }    }   },     \n```\n\n（3）显示登录昵称\n\n`MemberService`接口中添加方法 `getLoginInfo`\n\n```java\n/**     * 根据登录人id获取对应的昵称，从redis中获取     * @param id     * @return     */    String getLoginInfo(String id);\n```\n\n修改`MemberServiceImpl`实现类中`login`方法\n\n```java\n//使用登录人的id作为key，设定3600秒的过期时间，value值待定jedis.setex(member.getId(),3600,member.getNickName());\n```\n\n添加方法`getLoginInfo`方法\n\n```java\n @Override    public String getLoginInfo(String id) {        //使用给定的id去查找redis中是否存在当前数据        Jedis jedis = JedisUtils.getResource();        String nickName = jedis.get(id);        jedis.close();        return nickName;    }\n```\n\n### 1.4 退出登录\n\n（1）修改`index.html`页面，将退出方法名修改成`logout`，并添加`logout`方法\n\n```html\n<span class="top-right"  id="exit" style="display: none">\t<a href="#" @click="logout()" style="color:white">退出</a></span>\n```\n\n```javascript\nlogout(){    //1.获取localStorage    let storage = window.localStorage;    //2.发送请求，清除登录状态    axios.post(\'/member/logout\', \'{"id":"\'+storage.id+\'"}\').then(function (response) {        //1.获取响应数据        let data = response.data;        //2.提示        //alert(data.flag);    }).catch(function (err) {    \tconsole.log(err)    });        //3.清理localStorage        window.localStorage.clear();        //4.通过调用checkLogin方法重置主页面的右上角显示区域        this.checkLogin();    }},\n```\n\n(2) `MemberServlet `添加`logout`方法\n\n```java\npublic Result logout(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        Member member = getData(request,Member.class);        boolean flag = memberService.logout(member.getId());        if(flag){            return new Result("退出成功!", flag);        }else{            return new Result("", false, flag, Code.LOGOUT_FAIL);        }    }\n```\n\n\n\n`MemberService`添加方法\n\n```java\nboolean logout(String id);\n```\n\n`MemberServiceImpl`添加方法\n\n```java\n  @Override    public boolean logout(String id) {        Jedis jedis = JedisUtils.getResource();        Long row = jedis.del(id);        jedis.close();        return row > 0 ;    }\n```\n\n## 2.答题试卷\n\n### 2.1 生成试卷\n\n（1）创建实体类`Question`\n\n```java\npackage com.itheima.domain.store;import java.util.List;public class Question {    private String id;            //题目ID    private String subject;     //题干    private String type;       \t//题目类型  1:单选，2：多选，3：简答}\n```\n\n(2) 创建`ExamServlet`继承`BaseServlet`\n\n```java\n@WebServlet("/exam/*")public class ExamServlet extends BaseServlet {    public Result getPaper(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        List<Question> questionList = examService.getPaper();        return new Result("试卷生成成功！", questionList);    }}\n```\n\n(3) 创建`ExamService`\n\n```java\npublic interface ExamService {    List<Question> getPaper();}\n```\n\n(4) 创建`ExamServiceImpl`实现`ExamService`\n\n```java\npublic class ExamServiceImpl implements ExamService {    @Override    public List<Question> getPaper() {        SqlSession sqlSession = null;        try{            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            QuestionDao questionDao = MapperFactory.getMapper(sqlSession, QuestionDao.class);            List<Question> questionList = questionDao.findAll();            return questionList;        }catch (Exception e){            e.printStackTrace();            throw new RuntimeException(e);            //记录日志        }finally {            try {                TransactionUtil.close(sqlSession);            }catch (Exception e){                e.printStackTrace();            }        }    }}\n```\n\n(5) 创建`QuestionDao`\n\n```java\npublic interface QuestionDao {    List<Question> findAll();}\n```\n\n(6) 创建`QuestionDao.xml`\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"><mapper namespace="com.itheima.dao.store.QuestionDao">    \x3c!--配置实体类属性和数据库表中列的对应关系--\x3e    <resultMap id="BaseResultMap" type="com.itheima.domain.store.Question">        <id column="id" jdbcType="VARCHAR" property="id"/>        <result column="subject" jdbcType="VARCHAR" property="subject"/>        <result column="type" jdbcType="VARCHAR" property="type"/>    </resultMap>    \x3c!--配置查询的列名公共SQL语句--\x3e    <sql id="Base_Column_List">        id, subject,type    </sql>    \x3c!--配置查询所有，带条件--\x3e    <select id="findAll" resultMap="BaseResultMap">        select        <include refid="Base_Column_List"/>        from st_question        order by        limit 2    </select></mapper>\n```\n\n启动服务，开始测试\n\n\n\n### 2.2 加载选项\n\n（1）创建`QuestionItem`实体类\n\n```java\npackage com.itheima.domain.store;public class QuestionItem {    private String id;          \t//ID    private String questionId;  //题目ID    private String content;     //选项内容    private String isRight;    //是否正确答案}\n```\n\n（2）给`Question`实体类添加属性`questionItemList`\n\n```java\n    private List<QuestionItem> questionItemList;    public List<QuestionItem> getQuestionItemList() {        return questionItemList;    }    public void setQuestionItemList(List<QuestionItem> questionItemList) {        this.questionItemList = questionItemList;    }\n```\n\n(3) 创建`QuestionItemDao`\n\n```java\npublic interface QuestionItemDao {    List<QuestionItem> findByQuestionId(String questionId);}\n```\n\n（4）创建`QuestionItemDao.xml`\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"><mapper namespace="com.itheima.dao.store.QuestionItemDao">    \x3c!--配置实体类属性和数据库表中列的对应关系--\x3e    <resultMap id="BaseResultMap" type="com.itheima.domain.store.QuestionItem">        <id column="id" jdbcType="VARCHAR" property="id"/>        <result column="question_id" jdbcType="VARCHAR" property="questionId"/>        <result column="content" jdbcType="VARCHAR" property="content"/>        <result column="is_right" jdbcType="VARCHAR" property="isRight"/>    </resultMap>    \x3c!--配置查询的列名公共SQL语句--\x3e    <sql id="Base_Column_List">        id, question_id, content, is_right    </sql>    \x3c!--配置查询所有，带条件--\x3e    <select id="findAll" parameterType="java.lang.String" resultMap="BaseResultMap">        select        <include refid="Base_Column_List"/>        from st_question_item        where question_id = #{questionId,jdbcType=VARCHAR}    </select>    \x3c!--配置根据ID查询--\x3e    <select id="findById" parameterType="java.lang.String" resultMap="BaseResultMap">        select        <include refid="Base_Column_List"/>        from st_question_item        where id = #{id,jdbcType=VARCHAR}    </select>    \x3c!--根据题目id查询所有选项--\x3e    <select id="findByQuestionId" resultMap="BaseResultMap" parameterType="string">        select        <include refid="Base_Column_List"/>        from st_question_item        where question_id = #{questionId}    </select></mapper>\n```\n\n(5) 修改`QuestionDao.xml`\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"><mapper namespace="com.itheima.dao.store.QuestionDao">    \x3c!--配置实体类属性和数据库表中列的对应关系--\x3e    <resultMap id="BaseResultMap" type="com.itheima.domain.store.Question">        <id column="id" jdbcType="VARCHAR" property="id"/>        <result column="subject" jdbcType="VARCHAR" property="subject"/>        <result column="type" jdbcType="VARCHAR" property="type"/>        \x3c!--题目对题目选项的一对多--\x3e        <collection            property="questionItemList"            javaType="java.util.List"            ofType="com.itheima.domain.store.QuestionItem"            select="com.itheima.dao.store.QuestionItemDao.findByQuestionId"            column="id"            />    </resultMap>    \x3c!--配置查询的列名公共SQL语句--\x3e    <sql id="Base_Column_List">        id, subject,type    </sql>    \x3c!--配置查询所有，带条件--\x3e    <select id="findAll" resultMap="BaseResultMap">        select        <include refid="Base_Column_List"/>        from st_question        order by id desc        limit 2    </select></mapper>\n```\n\n### 2.3 单选结果处理\n\n在`paper.html`页面中，修改`changeResultRadio`方法\n\n```javascript\n changeResultRadio(item){     //输出选中信息     // alert("当前选项所属题目id："+item.questionId);     // alert(\'当前选项id：\'+item.id);     // alert("本次操作前数据结果：" + JSON.stringify(this.results))    //组织数据（要加入到results中的数据）    var temp = {"questionId":item.questionId,"answer":item.id};    //alert(JSON.stringify(temp))    //删除当前results中已经存在的本题目对应的数据    this.results = this.results.filter(e=>{return e.questionId !== item.questionId})    //alert("results[操作前]：" + JSON.stringify(this.results))    //将本次操作的结果加入到results    this.results.push(temp);    //alert("results[操作后]：" + JSON.stringify(this.results))},\n```\n\n刷新页面，查看alert信息\n\n### 2.4 多选结果处理\n\n在`paper.html`页面中，修改`changeResultCheckBox`方法\n\n```javascript\n            changeResultCheckBox(item){                /*                var s = \'11,22,33,44\';                x = \'33\'                var arr = s.split(",");                var index = arr.indexOf(x);                arr.splice(index,1);                s = arr.join(",");                alert(s)                */                //输出选中信息                // alert("当前选项所属题目id："+item.questionId);                // alert("当前选项id："+item.id);                // alert(\'当前\'+ this.checked);                // alert("本次操作前数据结果：" + JSON.stringify(this.results))                var temp = this.results.find(e=>{return e.questionId === item.questionId})                if(temp == undefined){                    //当前题目从来未作答过                    temp = {"questionId":item.questionId,"answer":item.id};                }else{                    if(this.checked){                        // 添加该答案                        temp.answer = temp.answer + "," + item.id;                    }else{                        //删除该答案                        var arr = temp.answer.split(",");                        var index = arr.indexOf(item.id);                        arr.splice(index,1);                        temp.answer = arr.join(",");                    }                }                //组织数据（要加入到results中的数据）                // var temp = {"questionId":item.questionId,"answer":item.id};                // alert(JSON.stringify(temp))                //删除当前results中已经存在的本题目对应的数据                this.results = this.results.filter(e=>{return e.questionId !== item.questionId})                alert("results[操作前]：" + JSON.stringify(this.results))                //将本次操作的结果加入到results                this.results.push(temp);                alert("results[操作后]：" + JSON.stringify(this.results))            },\n```\n\n### 2.5 提交试卷\n\n`paper.html`最终代码\n\n```html\n<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    \x3c!--<link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css">--\x3e    <link rel="stylesheet" href="element-ui/lib/theme-chalk/index.css">    <link rel="stylesheet" href="/css/tt.css">    <link rel="stylesheet" type="text/css" href="./plugins/normalize-css/normalize.css" />    <link rel="stylesheet" type="text/css" href="./plugins/yui/cssgrids-min.css" />    <link rel="stylesheet" type="text/css" href="./plugins/sui/sui.min.css" />    <link rel="stylesheet" type="text/css" href="./plugins/sui/sui-append.min.css" />    <link rel="stylesheet" type="text/css" href="./plugins/font-awesome/css/font-awesome.min.css" />    <link rel="stylesheet" type="text/css" href="./css/widget-base.css" />    <link rel="stylesheet" type="text/css" href="./css/widget-head-foot.css" />    <link rel="stylesheet" type="text/css" href="./plugins/bootstrap/dist/css/bootstrap.min.css" />    <link rel="stylesheet" type="text/css" href="./css/page-sj-spit-index.css" />    <title>自我测试</title>    <script src="js/vue.js" type="text/javascript"><\/script>    <script src="./js/axios-0.18.0.js" type="text/javascript"><\/script>    <script src="element-ui/lib/index.js"><\/script></head><body><div id="app">    <div style="height:100px;background-color:black;color:white;text-align:center;font-size:35px">        开&nbsp;&nbsp;&nbsp; 始&nbsp;&nbsp;&nbsp; 答&nbsp;&nbsp;&nbsp; 题    </div>    <el-form :model="ruleForm" :rules="rules" ref="ruleForm" label-width="100px" class="demo-ruleForm">        <div class="wrapper tag-item">            <div class="fl left-list">                <div class="tc-data-list">                    <div class="tc-list">                        <ul class="detail-list" v-for="question in questions">                            <li class="qa-item">                                <div class="fl record">                                    <div class="number">                                        <div class="border answer">                                            <p class="usenum"></p>                                            <p class="zannum"><strong> 题干</strong> </p>                                        </div>                                        <hr/>                                        <div class="border answer">                                            <p class="zannum"><strong>选项</strong> </p>                                        </div>                                    </div>                                </div>                                <div class="info">                                    <p class="text">                                        <b>{{question.subject}}</b>                                    </p>                                    <div class="other">                                        <div class="fl date">                                        <span>                                            <el-form-item label="单选题"  v-if="question.type == 1">                                                <el-radio-group v-model="question.id">                                                    <el-radio v-for="(item,index) in question.questionItemList"                                                              :key="item.id"                                                              :label="item.content"                                                              :name="question.id"                                                              v-model="checked"                                                              @change="changeResultRadio(item)">                                                        {{item.content}}                                                    </el-radio>                                                </el-radio-group>                                            </el-form-item>                                            <el-form-item label="多选题" v-if="question.type == 2" >                                                 <el-checkbox v-for="(item,index) in question.questionItemList"                                                              :key="item.id"                                                              :label="item.content"                                                              :name="question.id"                                                              v-model="checked"                                                              @change="changeResultCheckBox(item)">                                                      {{item.content}}                                                 </el-checkbox>                                            </el-form-item>                                        </span>                                        </div>                                    </div>                                </div>                                <div class="clearfix"></div>                            </li>                        <ul class="detail-list" v-for="question in questions">                        </ul>                        <el-form-item>                            <el-button type="primary" @click="submitForm(\'ruleForm\')">交卷</el-button>                        </el-form-item>                    </div>                </div>            </div>        </div>    </el-form></div></body></html><script>    /* 脚本中创建对象,处理业务 */    new Vue({        el: \'#app\',        data: {            questions:[],            results:[],            checked:[],        },        methods: {            /*-------------------------单选多选题处理结构    开始-------------------------                //1.分情况处理，单选题与多选题处理方式不同                //2.约定回传的答案格式       单选题由题号与选项组成，多选题由题号和多个选项组成                {                    questionId:XXXXXXXX,                    answer:mm                }                {                    questionId:XXXXXXXX,                    answer:mm,nn                }                //3.无论是单选还是多选，最终都是将所有题目的答案结果放置在一个数据中保存（results），整体操作就是为results添加/修改数据                [{},{},{}]                //4.操作模式                每次操作一个题目，先将当前题目对应的questionId在原始results中删除，添加新数据到results中                [1,1,1]                单选：加入一个数据，如果之前有这个题目的数据，先删除再添加                多选：加入一个数据，如果之前有这个题目的数据，先删除再添加                -------------------------单选多选题处理结构    结束-------------------------*/            changeResultRadio(item){                //输出选中信息                // alert("当前选项所属题目id："+item.questionId);                // alert(\'当前选项id：\'+item.id);                // alert("本次操作前数据结果：" + JSON.stringify(this.results))                //组织数据（要加入到results中的数据）                var temp = {"questionId":item.questionId,"answer":item.id};                //alert(JSON.stringify(temp))                //删除当前results中已经存在的本题目对应的数据                this.results = this.results.filter(e=>{return e.questionId !== item.questionId})                //alert("results[操作前]：" + JSON.stringify(this.results))                //将本次操作的结果加入到results                this.results.push(temp);                //alert("results[操作后]：" + JSON.stringify(this.results))            },            changeResultCheckBox(item){                /*                var s = \'11,22,33,44\';                x = \'33\'                var arr = s.split(",");                var index = arr.indexOf(x);                arr.splice(index,1);                s = arr.join(",");                alert(s)                */                //输出选中信息                // alert("当前选项所属题目id："+item.questionId);                // alert("当前选项id："+item.id);                // alert(\'当前\'+ this.checked);                // alert("本次操作前数据结果：" + JSON.stringify(this.results))                var temp = this.results.find(e=>{return e.questionId === item.questionId})                if(temp == undefined){                    //当前题目从来未作答过                    temp = {"questionId":item.questionId,"answer":item.id};                }else{                    if(this.checked){                        // 添加该答案                        temp.answer = temp.answer + "," + item.id;                    }else{                        //删除该答案                        var arr = temp.answer.split(",");                        var index = arr.indexOf(item.id);                        arr.splice(index,1);                        temp.answer = arr.join(",");                    }                }                //组织数据（要加入到results中的数据）                // var temp = {"questionId":item.questionId,"answer":item.id};                // alert(JSON.stringify(temp))                //删除当前results中已经存在的本题目对应的数据                this.results = this.results.filter(e=>{return e.questionId !== item.questionId})                //alert("results[操作前]：" + JSON.stringify(this.results))                //将本次操作的结果加入到results                this.results.push(temp);                //alert("results[操作后]：" + JSON.stringify(this.results))                var arr ;                var temp = this.results.find(e=>{return e.questionId === item.questionId})                if(temp == undefined){                    temp = {"questionId":item.questionId,"answer":item.id};                }else{                    if(this.checked){                        temp.answer = temp.answer + "," + item.id;                    }else{                        arr = temp.answer.split(",");                        var index = arr.indexOf(item.id);                        arr.splice(index,1);                        temp.answer = arr.join(",");                    }                }                this.results = this.results.filter(e=>{return e.questionId !== item.questionId})                if(var.length > 0){                    this.results.push(temp);                }                var temp = this.results.find(e=>{return e.questionId === item.questionId})                if(temp == undefined){                    temp = {"questionId":item.questionId,"answer":item.id};                }else{                    if(this.checked){                        temp.answer = temp.answer + "," + item.id;                    }else{                        var arr = temp.answer.split(",");                        var index = arr.indexOf(item.id);                        arr.splice(index,1);                        temp.answer = arr.join(",");                    }                }                this.results = this.results.filter(e=>{return e.questionId !== item.questionId})                this.results.push(temp);            },            submitForm(formName) {                if(this.results.length != this.questions.length){                    alert("请检查题目是否全部选择");                    return;                }else{                    if(window.confirm("确定交卷吗？")) {                        //把json数据转成字符串                        let str = JSON.stringify(this.results);                        //获取localSotrage                        let storage = window.localStorage;                        //发送请求，交卷                        axios.post(\'/exam/applyPaper\', \'{"memberId":"\'+storage.id+\'","results":\'+str+\'}\').then(function (response) {                            //输出提示信息                            //alert(response.data.message);                            //发送完请求，跳转到交卷成功页面                            window.open(\'/index.html\', \'_self\');                        }).catch(function (err) {                            console.log(err)                        });                    }                }            },            findQuestion(){                let _this = this;                //4.发送post请求，获取题目信息                axios.post(\'/exam/getPaper\').then(function (response) {                    //5.得到响应数据                    var res = response.data;                    //alert(JSON.stringify(res));                    _this.questions = res.data;                }).catch(function (err) {                    console.log(err)                });            }        },        created(){            this.findQuestion();        },    });<\/script>\n```\n\n`ExamServlet`\n\n```java\n@WebServlet("/exam/*")public class ExamServlet extends BaseServlet {    public Result getPaper(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        List<Question> questionList = examService.getPaper();        return new Result("试卷生成成功！", questionList);    }    public Result applyPaper(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //memberId:?????,results:[{},{}]        //1.得到全部请求的json数据        String json = JSONObject.parseObject(request.getInputStream(), String.class);        //2.将json数据转换为json对象        JSONObject jsonObject = JSON.parseObject(json);        //3.获取当前提交试卷人的id        String memberId = jsonObject.getObject("memberId", String.class);        //4.获取当前提交的试卷信息        JSONArray jsonArray = jsonObject.getJSONArray("results");        List<ExamQuestion> examQuestionList = jsonArray.toJavaList(ExamQuestion.class);        boolean flag = examService.applyPaper(memberId,examQuestionList);        return new Result("试卷提交成功！",flag);    }}\n```\n\n`ExamPaper`实体类\n\n```java\npackage com.itheima.domain.front;import java.util.Date;public class ExamPaper {    private String id;    private String memberId;    private Date applyTime;    private String state;   //1-可用  0-不可用    private Integer score;}\n```\n\n`ExamQuestion`实体类\n\n```java\npackage com.itheima.domain.front;public class ExamQuestion {    private String id;    private String examPaperId;    private String questionId;    private String answer;}\n```\n\n`ExamService`接口\n\n```java\npackage com.itheima.service.front;import com.itheima.domain.front.ExamQuestion;import com.itheima.domain.store.Question;import java.util.List;public interface ExamService {    List<Question> getPaper();    boolean applyPaper(String memberId, List<ExamQuestion> examQuestionList);}\n```\n\n`ExamServiceImpl`实现类\n\n```java\npackage com.itheima.service.front.impl;import com.itheima.dao.front.ExamPaperDao;import com.itheima.dao.front.ExamQuestionDao;import com.itheima.dao.store.QuestionDao;import com.itheima.domain.front.ExamPaper;import com.itheima.domain.front.ExamQuestion;import com.itheima.domain.store.Question;import com.itheima.factory.MapperFactory;import com.itheima.service.front.ExamService;import com.itheima.utils.TransactionUtil;import org.apache.ibatis.session.SqlSession;import java.util.Date;import java.util.List;import java.util.UUID;public class ExamServiceImpl implements ExamService {    @Override    public List<Question> getPaper() {        SqlSession sqlSession = null;        try{            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            QuestionDao questionDao = MapperFactory.getMapper(sqlSession, QuestionDao.class);            List<Question> questionList = questionDao.findAll();            return questionList;        }catch (Exception e){            e.printStackTrace();            throw new RuntimeException(e);            //记录日志        }finally {            try {                TransactionUtil.close(sqlSession);            }catch (Exception e){                e.printStackTrace();            }        }    }    @Override    public boolean applyPaper(String memberId, List<ExamQuestion> examQuestionList) {        SqlSession sqlSession = null;        try{            boolean flag = true;            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            ExamPaperDao examPaperDao = MapperFactory.getMapper(sqlSession, ExamPaperDao.class);            ExamQuestionDao examQuestionDao = MapperFactory.getMapper(sqlSession, ExamQuestionDao.class);            //3.提交保存的试卷信息            ExamPaper examPaper  = new ExamPaper();            String paperId = UUID.randomUUID().toString();            examPaper.setId(paperId);            examPaper.setApplyTime(new Date());            examPaper.setMemberId(memberId);            examPaper.setState("1");            flag = flag && examPaperDao.save(examPaper) > 0;            //4.提交保存的试卷中的所有题目对应的答案信息            for(ExamQuestion eq: examQuestionList) {                eq.setId(UUID.randomUUID().toString());                eq.setExamPaperId(paperId);                flag = flag && examQuestionDao.save(eq) > 0;            }            TransactionUtil.commit(sqlSession);            return flag;        }catch (Exception e){            TransactionUtil.rollback(sqlSession);            throw new RuntimeException(e);            //记录日志        }finally {            try {                TransactionUtil.close(sqlSession);            }catch (Exception e){                e.printStackTrace();            }        }    }}\n```\n\n`ExamPaperDao`接口\n\n```java\npackage com.itheima.dao.front;import com.itheima.domain.front.ExamPaper;public interface ExamPaperDao {    int save(ExamPaper examPaper);}\n```\n\n`ExamQuestionDao`接口\n\n```java\npackage com.itheima.dao.front;import com.itheima.domain.front.ExamQuestion;public interface ExamQuestionDao {    int save(ExamQuestion eq);}\n```\n\n`ExamPaperDao.xml`文件\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"><mapper namespace="com.itheima.dao.front.ExamPaperDao">    <insert id="save" parameterType="com.itheima.domain.front.ExamPaper">        insert into tr_examination_paper (id, member_id, state, apply_time)        values (#{id}, #{memberId}, #{state}, #{applyTime})    </insert></mapper>\n```\n\n`ExamQuestionDao.xml`文件\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"><mapper namespace="com.itheima.dao.front.ExamQuestionDao">    <insert id="save" parameterType="com.itheima.domain.front.ExamQuestion">        insert into tr_member_question (id, question_id, examinationpaper_id,answer_result)        values (#{id}, #{questionId}, #{examPaperId},#{answer})    </insert></mapper>\n```\n\n'},"23f3":function(n,e,t){"use strict";t.r(e),e["default"]='# web综合案例\r\n\r\n## 学习目标\r\n\r\n目标1：完成使用POI读写Excel的测试案例\r\n\r\n目标2：完成题目模板的制作，包括表头，标题及数据\r\n\r\n目标3：完成题目报表数据导出的业务功能\r\n\r\n目标4：完成角色与模块功能的快速开发\r\n\r\n目标5：能够自己独立分析树形控件的页面制作\r\n\r\n目标6：完成授权时动态加载授权数据\r\n\r\n目标7：完成角色与模块的绑定关系\r\n\r\n## 1. ​报表\r\n\r\n**报表**：简单的说，报表就是用表格、图表等格式来动态显示数据，可以用公式表示为：“报表 = 多样的格式 + 动态的数据”。\r\n\r\n报表的种类有很多：Excel报表，PDF报表，网页报表等，他们各有优缺点\r\n\r\n![](web综合案例_day03.assets/1.png)\r\n\r\n在本课程中，我们主要来将Excel报表。\r\n\r\n对于Excel报表的技术实现上也有很多种选择：\r\n\r\n- JXL：支持xls文件操作\r\n- POI：支持xls和xlsx文件操作\r\n\r\n我们只要来讲POI技术，要使用POI就要导入其坐标，如下\r\n\r\n```xml\r\n\x3c!--POI--\x3e\r\n<dependency>\r\n    <groupId>org.apache.poi</groupId>\r\n    <artifactId>poi</artifactId>\r\n    <version>4.0.1</version>\r\n</dependency>\r\n<dependency>\r\n    <groupId>org.apache.poi</groupId>\r\n    <artifactId>poi-ooxml</artifactId>\r\n    <version>4.0.1</version>\r\n</dependency>\r\n<dependency>\r\n    <groupId>org.apache.poi</groupId>\r\n    <artifactId>poi-ooxml-schemas</artifactId>\r\n    <version>4.0.1</version>\r\n</dependency>\r\n```\r\n\r\n\r\n\r\n### 1.1 POI写Excel文件\r\n\r\n在测试包下创建POI测试类：com.itheima.service.store.PoiTest\r\n\r\n```java\r\npublic class PoiTest {\r\n\r\n    @Test\r\n    public void testWriteByPoi() throws IOException {\r\n        //1.获取到对应的Excel文件，工作簿文件\r\n        Workbook wb = new XSSFWorkbook();\r\n        //2.创建工作表\r\n        Sheet sheet = wb.createSheet();\r\n        wb.createSheet("这是啥呀");\r\n\r\n        //3.创建工作表中的行对象\r\n        Row row = sheet.createRow(1);\r\n        //4.创建工作表中行中的列对象\r\n        Cell cell = row.createCell(1);\r\n        //5.在列中写数据\r\n        cell.setCellValue("测试一下单元格");\r\n\r\n        //创建一个文件对象，作为excel文件内容的输出文件\r\n        File f = new File("test.xlsx");\r\n        //输出时通过流的形式对外输出，包装对应的目标文件\r\n        OutputStream os = new FileOutputStream(f);\r\n        //将内存中的workbook数据写入到流中\r\n        wb.write(os);\r\n        wb.close();\r\n        os.close();\r\n    }\r\n}\r\n```\r\n\r\n使用单元测试进行测试！\r\n\r\n### 1.2 POI读Excel文件\r\n\r\n创建读Excel的测试方法：`testReadByPoi`\r\n\r\n```java\r\n@Test\r\npublic void testReadByPoi() throws IOException {\r\n    //1.获取要读取的文件工作簿对象\r\n    Workbook wb = new XSSFWorkbook("test.xlsx");\r\n    //2.获取工作表\r\n    Sheet s = wb.getSheetAt(0);\r\n    //3.获取行\r\n    Row row = s.getRow(3);\r\n    //4.获取列\r\n    Cell cell = row.getCell(1);\r\n    //5.根据数据的类型获取数据\r\n    //        String data = cell.getStringCellValue();\r\n    //        double data = cell.getNumericCellValue();\r\n    boolean data = cell.getBooleanCellValue();\r\n\r\n    System.out.println(data);\r\n\r\n    wb.close();\r\n}\r\n```\r\n\r\n直接读取第一节创建好的Excel文件\r\n\r\n### 1.3 题目模板表头制作\r\n\r\n前两节我们讲了如何去读取及写入Excel数据，操作相对简单，但是实际业务中我们要操作的Excel报表还是比较繁琐的，我们可以从今日课程资料中找到我们最终要导出报表的模板：`资料\\Excel解析\\模板.xlsx`\r\n\r\n![](web综合案例_day03.assets/2.png)\r\n\r\n这种形式的我们如何去操作呢？\r\n\r\n在测试类中再编写一个测试方法：`testProjectPoi`\r\n\r\n```java\r\n@Test\r\npublic void testProjectPoi() throws IOException {\r\n    //1.获取到对应的Excel文件，工作簿文件\r\n    Workbook wb = new XSSFWorkbook();\r\n    //2.创建工作表\r\n    Sheet s = wb.createSheet("题目数据文件");\r\n    //制作标题\r\n    s.addMergedRegion(new CellRangeAddress(1,1,1,12)); \r\n    Row row_1 = s.createRow(1);\r\n    Cell cell_1_1 = row_1.createCell(1);\r\n    cell_1_1.setCellValue("在线试题导出信息");\r\n    //创建一个样式\r\n    CellStyle cs_title = wb.createCellStyle();\r\n    cs_title.setAlignment(HorizontalAlignment.CENTER);\r\n    cs_title.setVerticalAlignment(VerticalAlignment.CENTER);\r\n    cell_1_1.setCellStyle(cs_title);\r\n    //制作表头\r\n    \r\n    //制作数据区\r\n    \r\n    //创建一个文件对象，作为excel文件内容的输出文件\r\n    File f = new File("test.xlsx");\r\n    //输出时通过流的形式对外输出，包装对应的目标文件\r\n    OutputStream os = new FileOutputStream(f);\r\n    //将内存中的workbook数据写入到流中\r\n    wb.write(os);\r\n    wb.close();\r\n    os.close();\r\n}\r\n```\r\n\r\n### 1.4 题目模板标题制作\r\n\r\n下面我们接着来做Excel的表头\r\n\r\n在测试方法`testProjectPoi`中继续编写代码\r\n\r\n```java\r\n@Test\r\npublic void testProjectPoi() throws IOException {\r\n    //1.获取到对应的Excel文件，工作簿文件\r\n    Workbook wb = new XSSFWorkbook();\r\n    //2.创建工作表\r\n    Sheet s = wb.createSheet("题目数据文件");\r\n    //设置通用配置\r\n    //        s.setColumnWidth(4,100);\r\n    //制作标题\r\n    s.addMergedRegion(new CellRangeAddress(1,1,1,12));  \r\n    Row row_1 = s.createRow(1);\r\n    Cell cell_1_1 = row_1.createCell(1);\r\n    cell_1_1.setCellValue("在线试题导出信息");\r\n    //创建一个样式\r\n    CellStyle cs_title = wb.createCellStyle();\r\n    cs_title.setAlignment(HorizontalAlignment.CENTER);\r\n    cs_title.setVerticalAlignment(VerticalAlignment.CENTER);\r\n    cell_1_1.setCellStyle(cs_title);\r\n    //制作表头\r\n   String[] fields = {"题目ID","所属公司ID","所属目录ID","题目简介","题干描述",\r\n                "题干配图","题目分析","题目类型","题目难度","是否经典题","题目状态","审核状态"};\r\n    Row row_2 = s.createRow(2);\r\n    for (int i = 0; i < fields.length; i++) {\r\n        Cell cell_2_temp = row_2.createCell(1 + i); //++\r\n        cell_2_temp.setCellValue(fields[i]);    //++\r\n        \r\n        CellStyle cs_field = wb.createCellStyle();\r\n        cs_field.setAlignment(HorizontalAlignment.CENTER);\r\n        cell_2_temp.setCellStyle(cs_field);\r\n    }\r\n    \r\n    //制作数据区\r\n\r\n    //创建一个文件对象，作为excel文件内容的输出文件\r\n    File f = new File("test.xlsx");\r\n    //输出时通过流的形式对外输出，包装对应的目标文件\r\n    OutputStream os = new FileOutputStream(f);\r\n    //将内存中的workbook数据写入到流中\r\n    wb.write(os);\r\n    wb.close();\r\n    os.close();\r\n}\r\n```\r\n\r\n\r\n\r\n### 1.5 题目模板数据制作\r\n\r\n我们继续来做数据区\r\n\r\n```java\r\n@Test\r\npublic void testProjectPoi() throws IOException {\r\n    //1.获取到对应的Excel文件，工作簿文件\r\n    Workbook wb = new XSSFWorkbook();\r\n    //2.创建工作表\r\n    Sheet s = wb.createSheet("题目数据文件");\r\n    //设置通用配置\r\n    //        s.setColumnWidth(4,100);\r\n    CellStyle cs_field = wb.createCellStyle();\r\n    cs_field.setAlignment(HorizontalAlignment.CENTER);\r\n    cs_field.setBorderTop(BorderStyle.THIN);\r\n    cs_field.setBorderBottom(BorderStyle.THIN);\r\n    cs_field.setBorderLeft(BorderStyle.THIN);\r\n    cs_field.setBorderRight(BorderStyle.THIN);\r\n\r\n    \r\n    //制作标题\r\n    s.addMergedRegion(new CellRangeAddress(1,1,1,12));\r\n    Row row_1 = s.createRow(1);\r\n    Cell cell_1_1 = row_1.createCell(1);\r\n    cell_1_1.setCellValue("在线试题导出信息");\r\n    //创建一个样式\r\n    CellStyle cs_title = wb.createCellStyle();\r\n    cs_title.setAlignment(HorizontalAlignment.CENTER);\r\n    cs_title.setVerticalAlignment(VerticalAlignment.CENTER);\r\n    cell_1_1.setCellStyle(cs_title);\r\n    //制作表头\r\n    String[] fields = {"题目ID","所属公司ID","所属目录ID","题目简介","题干描述",\r\n                       "题干配图","题目分析","题目类型","题目难度","是否经典题","题目状态","审核状态"};\r\n    Row row_2 = s.createRow(2);\r\n\r\n    for (int i = 0; i < fields.length; i++) {\r\n        Cell cell_2_temp = row_2.createCell(1 + i); //++\r\n        cell_2_temp.setCellValue(fields[i]);    //++\r\n        cell_2_temp.setCellStyle(cs_field);\r\n    }\r\n\r\n    \r\n    //制作数据区\r\n    List<Question> questionList = new ArrayList<>();\r\n    Question qq = new Question();\r\n    qq.setId("1");\r\n    qq.setPicture("12");\r\n    qq.setReviewStatus("13");\r\n    qq.setAnalysis("14");\r\n    qq.setCatalogId("15");\r\n    qq.setCompanyId("16");\r\n    qq.setDifficulty("17");\r\n    qq.setIsClassic("18");\r\n    qq.setRemark("19");\r\n    qq.setState("21");\r\n    qq.setSubject("31");\r\n    qq.setType("41");\r\n    questionList.add(qq);\r\n    Question qqq = new Question();\r\n    qqq.setId("1");\r\n    qqq.setPicture("12");\r\n    qqq.setReviewStatus("13");\r\n    qqq.setAnalysis("14");\r\n    qqq.setCatalogId("15");\r\n    qqq.setCompanyId("16");\r\n    qqq.setDifficulty("17");\r\n    qqq.setIsClassic("18");\r\n    qqq.setRemark("19");\r\n    qqq.setState("21");\r\n    qqq.setSubject("31");\r\n    qqq.setType("41");\r\n    questionList.add(qqq);\r\n\r\n\r\n    int row_index = 0;\r\n    for (Question q : questionList) {\r\n        int cell_index = 0;\r\n        Row row_temp = s.createRow(3 + row_index++);\r\n\r\n        Cell cell_data_1 = row_temp.createCell(1 + cell_index++);\r\n        cell_data_1.setCellValue(q.getId());    //++\r\n        cell_data_1.setCellStyle(cs_field);\r\n\r\n        Cell cell_data_2 = row_temp.createCell(1 + cell_index++);\r\n        cell_data_2.setCellValue(q.getCompanyId());    //++\r\n        cell_data_2.setCellStyle(cs_field);\r\n\r\n        Cell cell_data_3 = row_temp.createCell(1 + cell_index++);\r\n        cell_data_3.setCellValue(q.getCatalogId());    //++\r\n        cell_data_3.setCellStyle(cs_field);\r\n\r\n        Cell cell_data_4 = row_temp.createCell(1 + cell_index++);\r\n        cell_data_4.setCellValue(q.getRemark());    //++\r\n        cell_data_4.setCellStyle(cs_field);\r\n\r\n        Cell cell_data_5 = row_temp.createCell(1 + cell_index++);\r\n        cell_data_5.setCellValue(q.getSubject());    //++\r\n        cell_data_5.setCellStyle(cs_field);\r\n\r\n        Cell cell_data_6 = row_temp.createCell(1 + cell_index++);\r\n        cell_data_6.setCellValue(q.getPicture());    //++\r\n        cell_data_6.setCellStyle(cs_field);\r\n\r\n        Cell cell_data_7 = row_temp.createCell(1 + cell_index++);\r\n        cell_data_7.setCellValue(q.getAnalysis());    //++\r\n        cell_data_7.setCellStyle(cs_field);\r\n\r\n        Cell cell_data_8 = row_temp.createCell(1 + cell_index++);\r\n        cell_data_8.setCellValue(q.getType());    //++\r\n        cell_data_8.setCellStyle(cs_field);\r\n\r\n        Cell cell_data_9 = row_temp.createCell(1 + cell_index++);\r\n        cell_data_9.setCellValue(q.getDifficulty());    //++\r\n        cell_data_9.setCellStyle(cs_field);\r\n\r\n        Cell cell_data_10 = row_temp.createCell(1 + cell_index++);\r\n        cell_data_10.setCellValue(q.getIsClassic());    //++\r\n        cell_data_10.setCellStyle(cs_field);\r\n\r\n        Cell cell_data_11 = row_temp.createCell(1 + cell_index++);\r\n        cell_data_11.setCellValue(q.getState());    //++\r\n        cell_data_11.setCellStyle(cs_field);\r\n\r\n        Cell cell_data_12 = row_temp.createCell(1 + cell_index++);\r\n        cell_data_12.setCellValue(q.getReviewStatus());    //++\r\n        cell_data_12.setCellStyle(cs_field);\r\n    }\r\n\r\n    //创建一个文件对象，作为excel文件内容的输出文件\r\n    File f = new File("test.xlsx");\r\n    //输出时通过流的形式对外输出，包装对应的目标文件\r\n    OutputStream os = new FileOutputStream(f);\r\n    //将内存中的workbook数据写入到流中\r\n    wb.write(os);\r\n    wb.close();\r\n    os.close();\r\n}\r\n```\r\n\r\n测试即可！\r\n\r\n### 1.6 题目报表数据准备\r\n\r\n（1）找到`/WEB-INF/pages/store/question/list.jsp`页面，修改导出题目的链接\r\n\r\n```jsp\r\n<button type="button" class="btn btn-default" title="导出题目" onclick=location.href="${ctx}/store/question?operation=downloadReport"> <i class="fa fa-download"></i>导出题目</button>\r\n```\r\n\r\n（2）在后台servlet中添加对应的方法\r\n\r\n```java\r\n// uri:/store/question?operation=list\r\n@WebServlet("/store/question")\r\npublic class QuestionServlet extends BaseServlet {\r\n\r\n    @Override\r\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        String operation = request.getParameter("operation");\r\n        if("list".equals(operation)){\r\n            this.list(request,response);\r\n        }\r\n        //其他的else if判断省略\r\n        else if("downloadReport".equals(operation)){\r\n            this.downloadReport(request,response);\r\n        }\r\n    }\r\n\r\n    private void downloadReport(HttpServletRequest request, HttpServletResponse response) throws IOException {\r\n        //生成报告的文件，然后传递到前端页面\r\n        questionService.getReport();\r\n    }\r\n}\r\n```\r\n\r\n（3）在业务层`QuestionService`添加一个方法`getReport`\r\n\r\n```java\r\npublic void getReport() throws IOException;\r\n```\r\n\r\n（4）在对应的实现类中去实现该方法，把之前在测试类中的测试方法`testProjectPoi`里面的所有代码拷贝过来，其中数据我们应该是从数据库中查询出来，因此调用dao完成数据的查询\r\n\r\n```java\r\n@Overridepublic void getReport() throws IOException{     //获取对应要展示的数据        SqlSession sqlSession = null;        List<Question> questionList = null;        try{            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            QuestionDao questionDao = MapperFactory.getMapper(sqlSession,QuestionDao.class);            //3.调用Dao层操作            questionList = questionDao.findAll();        }catch (Exception e){            throw new RuntimeException(e);            //记录日志        }finally {            try {                TransactionUtil.close(sqlSession);            }catch (Exception e){                e.printStackTrace();            }        }                //1.获取到对应的Excel文件，工作簿文件        Workbook wb = new XSSFWorkbook();        //2.创建工作表        Sheet s = wb.createSheet("题目数据文件");        //设置通用配置//        s.setColumnWidth(4,100);        CellStyle cs_field = wb.createCellStyle();        cs_field.setAlignment(HorizontalAlignment.CENTER);        cs_field.setBorderTop(BorderStyle.THIN);        cs_field.setBorderBottom(BorderStyle.THIN);        cs_field.setBorderLeft(BorderStyle.THIN);        cs_field.setBorderRight(BorderStyle.THIN);        //制作标题        s.addMergedRegion(new CellRangeAddress(1,1,1,12));        Row row_1 = s.createRow(1);        Cell cell_1_1 = row_1.createCell(1);        cell_1_1.setCellValue("在线试题导出信息");        //创建一个样式        CellStyle cs_title = wb.createCellStyle();        cs_title.setAlignment(HorizontalAlignment.CENTER);        cs_title.setVerticalAlignment(VerticalAlignment.CENTER);        cell_1_1.setCellStyle(cs_title);            //制作表头        String[] fields = {"题目ID","所属公司ID","所属目录ID","题目简介","题干描述",                "题干配图","题目分析","题目类型","题目难度","是否经典题","题目状态","审核状态"};        Row row_2 = s.createRow(2);        for (int i = 0; i < fields.length; i++) {            Cell cell_2_temp = row_2.createCell(1 + i); //++            cell_2_temp.setCellValue(fields[i]);    //++            cell_2_temp.setCellStyle(cs_field);        }        //制作数据区        int row_index = 0;        for (Question q : questionList) {            int cell_index = 0;            Row row_temp = s.createRow(3 + row_index++);            Cell cell_data_1 = row_temp.createCell(1 + cell_index++);            cell_data_1.setCellValue(q.getId());    //++            cell_data_1.setCellStyle(cs_field);            Cell cell_data_2 = row_temp.createCell(1 + cell_index++);            cell_data_2.setCellValue(q.getCompanyId());    //++            cell_data_2.setCellStyle(cs_field);            Cell cell_data_3 = row_temp.createCell(1 + cell_index++);            cell_data_3.setCellValue(q.getCatalogId());    //++            cell_data_3.setCellStyle(cs_field);            Cell cell_data_4 = row_temp.createCell(1 + cell_index++);            cell_data_4.setCellValue(q.getRemark());    //++            cell_data_4.setCellStyle(cs_field);            Cell cell_data_5 = row_temp.createCell(1 + cell_index++);            cell_data_5.setCellValue(q.getSubject());    //++            cell_data_5.setCellStyle(cs_field);            Cell cell_data_6 = row_temp.createCell(1 + cell_index++);            cell_data_6.setCellValue(q.getPicture());    //++            cell_data_6.setCellStyle(cs_field);            Cell cell_data_7 = row_temp.createCell(1 + cell_index++);            cell_data_7.setCellValue(q.getAnalysis());    //++            cell_data_7.setCellStyle(cs_field);            Cell cell_data_8 = row_temp.createCell(1 + cell_index++);            cell_data_8.setCellValue(q.getType());    //++            cell_data_8.setCellStyle(cs_field);            Cell cell_data_9 = row_temp.createCell(1 + cell_index++);            cell_data_9.setCellValue(q.getDifficulty());    //++            cell_data_9.setCellStyle(cs_field);            Cell cell_data_10 = row_temp.createCell(1 + cell_index++);            cell_data_10.setCellValue(q.getIsClassic());    //++            cell_data_10.setCellStyle(cs_field);            Cell cell_data_11 = row_temp.createCell(1 + cell_index++);            cell_data_11.setCellValue(q.getState());    //++            cell_data_11.setCellStyle(cs_field);            Cell cell_data_12 = row_temp.createCell(1 + cell_index++);            cell_data_12.setCellValue(q.getReviewStatus());    //++            cell_data_12.setCellStyle(cs_field);        }        //创建一个文件对象，作为excel文件内容的输出文件        File f = new File("test.xlsx");        //输出时通过流的形式对外输出，包装对应的目标文件        OutputStream os = new FileOutputStream(f);        //将内存中的workbook数据写入到流中        wb.write(os);        wb.close();        os.close();}\r\n```\r\n\r\n\r\n\r\n### 1.7 题目报表业务实现\r\n\r\n现在后台已经能够生成Excel文件并且填充了数据，但是真实的业务中我们是需要将这个文件下载到客户端\r\n\r\n（1）修改接口方法`getReport`，添加返回值\r\n\r\n```java\r\n/**     * 获取包含了数据的流对象     * @return 包含了报表数据的流对象     * @throws IOException     */ByteArrayOutputStream getReport() throws IOException;\r\n```\r\n\r\n（2）在实现类中实现该方法时，将内存中的Excel相关数据写入到`ByteArrayOutputStream`流中\r\n\r\n```java\r\n@Overridepublic ByteArrayOutputStream getReport() throws IOException {    //前面的代码无变动 故省略        /**    //创建一个文件对象，作为excel文件内容的输出文件        File f = new File("test.xlsx");        //输出时通过流的形式对外输出，包装对应的目标文件        OutputStream os = new FileOutputStream(f);        //将内存中的workbook数据写入到流中        wb.write(os);        wb.close();        os.close();    */    //将内存中的workbook数据写入到流中    ByteArrayOutputStream os = new ByteArrayOutputStream();    wb.write(os);    wb.close();    return os;}\r\n```\r\n\r\n（3）修改后台servlet的`downloadReport`方法\r\n\r\n```java\r\nprivate void downloadReport(HttpServletRequest request, HttpServletResponse response) throws IOException {    //返回的数据类型为文件xlsx类型    response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=utf-8");    String fileName = new String("测试文件名.xlsx".getBytes(),"iso8859-1");    response.addHeader("Content-Disposition","attachment;fileName="+fileName);    //生成报告的文件，然后传递到前端页面    ByteArrayOutputStream os = questionService.getReport();    //获取产生响应的流对象    ServletOutputStream sos = response.getOutputStream();    //将数据从原始的字节流对象中提取出来写入到servlet对应的输出流中    os.writeTo(sos);    //将输出流刷新    sos.flush();    os.close();}\r\n```\r\n\r\n（4）启动项目，进行测试\r\n\r\n## 2.权限系统设计与开发\r\n\r\n### 2.1 权限系统简介与结构设计\r\n\r\n![](web综合案例_day03.assets/3.png)\r\n\r\n**什么是权限系统？**\r\n\r\n**权限系统是一种设定用户与可操作模块之间关系的系统。**\r\n\r\n**通过设定用户与可操作的模块之间的关系,控制用户在可指定范围内进行业务执行**\r\n\r\n**基于用户的权限控制(UBAC:User-BasedAccessControl)**\r\n\r\n**基于角色的权限控制(RBAC:role-BasedAccessControl)**\r\n\r\n\r\n\r\n在本课程中我们采用基于角色的权限控制RBAC\r\n\r\n![](web综合案例_day03.assets/4.png)\r\n\r\n### 2.2 角色与模块功能快速开发\r\n\r\n首先来看角色与模块各自的结构\r\n\r\n![](web综合案例_day03.assets/5.png)\r\n\r\n（1）创建角色实体：com.itheima.domain.system.Role\r\n\r\n```java\r\npublic class Role {    private String id;    private String name;    private String remark;    private Date createTime;\t// getter/setter略}\r\n```\r\n\r\n（2）创建角色Dao：com.itheima.dao.system.RoleDao\r\n\r\n```java\r\npublic interface RoleDao {    int save(Role role);    int delete(Role role);    int update(Role role);    Role findById(String id);    List<Role> findAll();}\r\n```\r\n\r\n（3）添加接口的映射配置文件，从今日课程资料中找到`资料\\dao层资源文件`将里面所有的xml映射配置文件拷贝到项目`src/main/resources/com/itheima/dao/system`目录下\r\n\r\n（4）创建业务层接口：com.itheima.service.system.RoleService\r\n\r\n```java\r\npublic interface RoleService {    /**     * 添加     * @param role     * @return     */    void save(Role role);    /**     * 删除     * @param role     * @return     */    void delete(Role role);    /**     * 修改     * @param role     * @return     */    void update(Role role);    /**     * 查询单个     * @param id 查询的条件（id）     * @return 查询的结果，单个对象     */    Role findById(String id);    /**     * 查询全部的数据     * @return 全部数据的列表对象     */    List<Role> findAll();    /**     * 分页查询数据     * @param page 页码     * @param size 每页显示的数据总量     * @return     */    PageInfo findAll(int page, int size);}\r\n```\r\n\r\n（5）创建接口的实现：com.itheima.service.system.impl\r\n\r\n```java\r\npublic class RoleServiceImpl implements RoleService {    @Override    public void save(Role role) {        SqlSession sqlSession = null;        try{            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            RoleDao roleDao = MapperFactory.getMapper(sqlSession,RoleDao.class);            //id使用UUID的生成策略来获取            String id = UUID.randomUUID().toString();            role.setId(id);            //3.调用Dao层操作            roleDao.save(role);            //4.提交事务            TransactionUtil.commit(sqlSession);        }catch (Exception e){            TransactionUtil.rollback(sqlSession);            throw new RuntimeException(e);            //记录日志        }finally {            try {                TransactionUtil.close(sqlSession);            }catch (Exception e){                e.printStackTrace();            }        }    }    @Override    public void delete(Role role) {        SqlSession sqlSession = null;        try{            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            RoleDao roleDao = MapperFactory.getMapper(sqlSession,RoleDao.class);            //3.调用Dao层操作            roleDao.delete(role);            //4.提交事务            TransactionUtil.commit(sqlSession);        }catch (Exception e){            TransactionUtil.rollback(sqlSession);            throw new RuntimeException(e);            //记录日志        }finally {            try {                TransactionUtil.close(sqlSession);            }catch (Exception e){                e.printStackTrace();            }        }    }    @Override    public void update(Role role) {        SqlSession sqlSession = null;        try{            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            RoleDao roleDao = MapperFactory.getMapper(sqlSession,RoleDao.class);            //3.调用Dao层操作            roleDao.update(role);            //4.提交事务            TransactionUtil.commit(sqlSession);        }catch (Exception e){            TransactionUtil.rollback(sqlSession);            throw new RuntimeException(e);            //记录日志        }finally {            try {                TransactionUtil.close(sqlSession);            }catch (Exception e){                e.printStackTrace();            }        }    }    @Override    public Role findById(String id) {        SqlSession sqlSession = null;        try{            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            RoleDao roleDao = MapperFactory.getMapper(sqlSession,RoleDao.class);            //3.调用Dao层操作            return roleDao.findById(id);        }catch (Exception e){            throw new RuntimeException(e);            //记录日志        }finally {            try {                TransactionUtil.close(sqlSession);            }catch (Exception e){                e.printStackTrace();            }        }    }    @Override    public List<Role> findAll() {        SqlSession sqlSession = null;        try{            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            RoleDao roleDao = MapperFactory.getMapper(sqlSession,RoleDao.class);            //3.调用Dao层操作            return roleDao.findAll();        }catch (Exception e){            throw new RuntimeException(e);            //记录日志        }finally {            try {                TransactionUtil.close(sqlSession);            }catch (Exception e){                e.printStackTrace();            }        }    }    @Override    public PageInfo findAll(int page, int size) {        SqlSession sqlSession = null;        try{            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            RoleDao roleDao = MapperFactory.getMapper(sqlSession,RoleDao.class);            //3.调用Dao层操作            PageHelper.startPage(page,size);            List<Role> all = roleDao.findAll();            PageInfo pageInfo = new PageInfo(all);            return pageInfo;        }catch (Exception e){            throw new RuntimeException(e);            //记录日志        }finally {            try {                TransactionUtil.close(sqlSession);            }catch (Exception e){                e.printStackTrace();            }        }    }}\r\n```\r\n\r\n（6）创建sevlet：com.itheima.web.controller.system.RoleServlet\r\n\r\n```java\r\n// uri:/system/role?operation=list@WebServlet("/system/role")public class RoleServlet extends BaseServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        String operation = request.getParameter("operation");        if("list".equals(operation)){            this.list(request,response);        }else if("toAdd".equals(operation)){            this.toAdd(request,response);        }else if("save".equals(operation)){            this.save(request, response);        }else if("toEdit".equals(operation)){            this.toEdit(request,response);        }else if("edit".equals(operation)){            this.edit(request,response);        }else if("delete".equals(operation)){            this.delete(request,response);        }else if("author".equals(operation)){            this.author(request,response);        }    }    private void list(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {        //进入列表页        //获取数据        int page = 1;        int size = 5;        if(StringUtils.isNotBlank(request.getParameter("page"))){            page = Integer.parseInt(request.getParameter("page"));        }        if(StringUtils.isNotBlank(request.getParameter("size"))){            size = Integer.parseInt(request.getParameter("size"));        }        PageInfo all = roleService.findAll(page, size);        //将数据保存到指定的位置        request.setAttribute("page",all);        //跳转页面        request.getRequestDispatcher("/WEB-INF/pages/system/role/list.jsp").forward(request,response);    }    private void toAdd(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {        //加载所有的部门信息放入到roleList        List<Role> all = roleService.findAll();        request.setAttribute("roleList",all);        //跳转页面        request.getRequestDispatcher("/WEB-INF/pages/system/role/add.jsp").forward(request,response);    }    private void save(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {        //将数据获取到，封装成一个对象        Role role = BeanUtil.fillBean(request,Role.class,"yyyy-MM-dd");        //调用业务层接口save        roleService.save(role);        //跳转回到页面list        response.sendRedirect(request.getContextPath()+"/system/role?operation=list");    }    private void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //查询要修改的数据findById        String id = request.getParameter("id");        Role role = roleService.findById(id);        //将数据加载到指定区域，供页面获取        request.setAttribute("role",role);        //跳转页面        request.getRequestDispatcher("/WEB-INF/pages/system/role/update.jsp").forward(request,response);    }    private void edit(HttpServletRequest request, HttpServletResponse response) throws IOException {        //将数据获取到，封装成一个对象        Role role = BeanUtil.fillBean(request,Role.class,"yyyy-MM-dd");        //调用业务层接口save        roleService.update(role);        //跳转回到页面list        response.sendRedirect(request.getContextPath()+"/system/role?operation=list");    }    private void delete(HttpServletRequest request, HttpServletResponse response) throws IOException {        //将数据获取到，封装成一个对象        Role role = BeanUtil.fillBean(request,Role.class);        //调用业务层接口save        roleService.delete(role);        //跳转回到页面list        response.sendRedirect(request.getContextPath()+"/system/role?operation=list");    }    private void author(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {        //获取要授权的角色id        String roleId = request.getParameter("id");        //使用id查询对应的数据（角色id对应的模块信息）        Role role = roleService.findById(roleId);        request.setAttribute("role",role);        //根据当前的角色id获取所有的模块数据，并加载关系数据        List<Map> map = moduleService.findAuthorDataByRoleId(roleId);        //map转成json数据        ObjectMapper om = new ObjectMapper();        String json = om.writeValueAsString(map);        request.setAttribute("roleModuleJson",json);        // TODO 数据未查询        //跳转到树页面中        request.getRequestDispatcher("/WEB-INF/pages/system/role/author.jsp").forward(request,response);    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request,response);    }}\r\n```\r\n\r\n同时需要在BaseServlet中添加`RoleService`\r\n\r\n```java\r\npublic class BaseServlet extends HttpServlet {    protected CompanyService companyService;    protected DeptService deptService;    protected UserService userService;    protected CourseService courseService;    protected CatalogService catalogService;    protected QuestionService questionService;    protected QuestionItemService questionItemService;    protected RoleService roleService;    @Override    public void init() throws ServletException {        companyService = new CompanyServiceImpl();        deptService = new DeptServiceImpl();        userService = new UserServiceImpl();        courseService = new CourseServiceImpl();        catalogService = new CatalogServiceImpl();        questionService = new QuestionServiceImpl();        questionItemService = new QuestionItemServiceImpl();        roleService = new RoleServiceImpl();    }}\r\n```\r\n\r\n（7）拷贝页面到项目中，从今日课程资料中找到：`资料\\模块页面`将下面所有模块全部拷贝到项目`/WEB-INF/pages/system`目录下\r\n\r\n（8）启动项目，进行测试\r\n\r\n\r\n\r\n然后我们按照相同的方式将模块的相关功能快速开发完成\r\n\r\n（1）创建模块实体：com.itheima.domain.system.Module\r\n\r\n```java\r\npublic class Module {    private String id;    private String parentId;    private String name;    private Long ctype;    private Long state;    private String curl;    private String remark;    private Module module;\t// getter/setter略}\r\n```\r\n\r\n（2）创建模块dao：com.itheima.dao.system.ModuleDao\r\n\r\n```java\r\npublic interface ModuleDao {    int save(Module module);    int delete(Module module);    int update(Module module);    Module findById(String id);    List<Module> findAll();}\r\n```\r\n\r\n（3）映射配置文件，之前已拷贝，查看一下即可\r\n\r\n（4）创建业务层接口：com.itheima.service.system.ModuleService\r\n\r\n```java\r\npublic interface ModuleService {    /**     * 添加     * @param module     * @return     */    void save(Module module);    /**     * 删除     * @param module     * @return     */    void delete(Module module);    /**     * 修改     * @param module     * @return     */    void update(Module module);    /**     * 查询单个     * @param id 查询的条件（id）     * @return 查询的结果，单个对象     */    Module findById(String id);    /**     * 查询全部的数据     * @return 全部数据的列表对象     */    List<Module> findAll();    /**     * 分页查询数据     * @param page 页码     * @param size 每页显示的数据总量     * @return     */    PageInfo findAll(int page, int size);}\r\n```\r\n\r\n（5）创建业务层实现类：com.itheima.service.system.impl.ModuleServiceImpl\r\n\r\n```java\r\npublic class ModuleServiceImpl implements ModuleService {    @Override    public void save(Module module) {        SqlSession sqlSession = null;        try{            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            ModuleDao moduleDao = MapperFactory.getMapper(sqlSession,ModuleDao.class);            //id使用UUID的生成策略来获取            String id = UUID.randomUUID().toString();            module.setId(id);            //3.调用Dao层操作            moduleDao.save(module);            //4.提交事务            TransactionUtil.commit(sqlSession);        }catch (Exception e){            TransactionUtil.rollback(sqlSession);            throw new RuntimeException(e);            //记录日志        }finally {            try {                TransactionUtil.close(sqlSession);            }catch (Exception e){                e.printStackTrace();            }        }    }    @Override    public void delete(Module module) {        SqlSession sqlSession = null;        try{            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            ModuleDao moduleDao = MapperFactory.getMapper(sqlSession,ModuleDao.class);            //3.调用Dao层操作            moduleDao.delete(module);            //4.提交事务            TransactionUtil.commit(sqlSession);        }catch (Exception e){            TransactionUtil.rollback(sqlSession);            throw new RuntimeException(e);            //记录日志        }finally {            try {                TransactionUtil.close(sqlSession);            }catch (Exception e){                e.printStackTrace();            }        }    }    @Override    public void update(Module module) {        SqlSession sqlSession = null;        try{            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            ModuleDao moduleDao = MapperFactory.getMapper(sqlSession,ModuleDao.class);            //3.调用Dao层操作            moduleDao.update(module);            //4.提交事务            TransactionUtil.commit(sqlSession);        }catch (Exception e){            TransactionUtil.rollback(sqlSession);            throw new RuntimeException(e);            //记录日志        }finally {            try {                TransactionUtil.close(sqlSession);            }catch (Exception e){                e.printStackTrace();            }        }    }    @Override    public Module findById(String id) {        SqlSession sqlSession = null;        try{            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            ModuleDao moduleDao = MapperFactory.getMapper(sqlSession,ModuleDao.class);            //3.调用Dao层操作            return moduleDao.findById(id);        }catch (Exception e){            throw new RuntimeException(e);            //记录日志        }finally {            try {                TransactionUtil.close(sqlSession);            }catch (Exception e){                e.printStackTrace();            }        }    }    @Override    public List<Module> findAll() {        SqlSession sqlSession = null;        try{            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            ModuleDao moduleDao = MapperFactory.getMapper(sqlSession,ModuleDao.class);            //3.调用Dao层操作            return moduleDao.findAll();        }catch (Exception e){            throw new RuntimeException(e);            //记录日志        }finally {            try {                TransactionUtil.close(sqlSession);            }catch (Exception e){                e.printStackTrace();            }        }    }    @Override    public PageInfo findAll(int page, int size) {        SqlSession sqlSession = null;        try{            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            ModuleDao moduleDao = MapperFactory.getMapper(sqlSession,ModuleDao.class);            //3.调用Dao层操作            PageHelper.startPage(page,size);            List<Module> all = moduleDao.findAll();            PageInfo pageInfo = new PageInfo(all);            return pageInfo;        }catch (Exception e){            throw new RuntimeException(e);            //记录日志        }finally {            try {                TransactionUtil.close(sqlSession);            }catch (Exception e){                e.printStackTrace();            }        }    }}\r\n```\r\n\r\n（6）创建servlet：com.itheima.web.controller.system.ModuleServlet\r\n\r\n```java\r\n// uri:/system/module?operation=list@WebServlet("/system/module")public class ModuleServlet extends BaseServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        String operation = request.getParameter("operation");        if("list".equals(operation)){            this.list(request,response);        }else if("toAdd".equals(operation)){            this.toAdd(request,response);        }else if("save".equals(operation)){            this.save(request, response);        }else if("toEdit".equals(operation)){            this.toEdit(request,response);        }else if("edit".equals(operation)){            this.edit(request,response);        }else if("delete".equals(operation)){            this.delete(request,response);        }    }    private void list(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {        //进入列表页        //获取数据        int page = 1;        int size = 10;        if(StringUtils.isNotBlank(request.getParameter("page"))){            page = Integer.parseInt(request.getParameter("page"));        }        if(StringUtils.isNotBlank(request.getParameter("size"))){            size = Integer.parseInt(request.getParameter("size"));        }        PageInfo all = moduleService.findAll(page, size);        //将数据保存到指定的位置        request.setAttribute("page",all);        //跳转页面        request.getRequestDispatcher("/WEB-INF/pages/system/module/list.jsp").forward(request,response);    }    private void toAdd(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {        //加载所有的信息放入到moduleList        List<Module> all = moduleService.findAll();        request.setAttribute("moduleList",all);        //跳转页面        request.getRequestDispatcher("/WEB-INF/pages/system/module/add.jsp").forward(request,response);    }    private void save(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {        //将数据获取到，封装成一个对象        Module module = BeanUtil.fillBean(request,Module.class,"yyyy-MM-dd");        //调用业务层接口save        moduleService.save(module);        //跳转回到页面list        response.sendRedirect(request.getContextPath()+"/system/module?operation=list");    }    private void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //查询要修改的数据findById        String id = request.getParameter("id");        Module module = moduleService.findById(id);        //将数据加载到指定区域，供页面获取        request.setAttribute("module",module);        //跳转页面        request.getRequestDispatcher("/WEB-INF/pages/system/module/update.jsp").forward(request,response);    }    private void edit(HttpServletRequest request, HttpServletResponse response) throws IOException {        //将数据获取到，封装成一个对象        Module module = BeanUtil.fillBean(request,Module.class,"yyyy-MM-dd");        //调用业务层接口save        moduleService.update(module);        //跳转回到页面list        response.sendRedirect(request.getContextPath()+"/system/module?operation=list");    }    private void delete(HttpServletRequest request, HttpServletResponse response) throws IOException {        //将数据获取到，封装成一个对象        Module module = BeanUtil.fillBean(request,Module.class);        //调用业务层接口save        moduleService.delete(module);        //跳转回到页面list        response.sendRedirect(request.getContextPath()+"/system/module?operation=list");    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request,response);    }}\r\n```\r\n\r\n同时需要在BserServlet中添加`ModuleService`\r\n\r\n```java\r\npublic class BaseServlet extends HttpServlet {    protected CompanyService companyService;    protected DeptService deptService;    protected UserService userService;    protected CourseService courseService;    protected CatalogService catalogService;    protected QuestionService questionService;    protected QuestionItemService questionItemService;    protected RoleService roleService;    protected ModuleService moduleService;    @Override    public void init() throws ServletException {        companyService = new CompanyServiceImpl();        deptService = new DeptServiceImpl();        userService = new UserServiceImpl();        courseService = new CourseServiceImpl();        catalogService = new CatalogServiceImpl();        questionService = new QuestionServiceImpl();        questionItemService = new QuestionItemServiceImpl();        roleService = new RoleServiceImpl();        moduleService = new ModuleServiceImpl();    }}\r\n```\r\n\r\n（7）拷贝页面：之前已经拷贝过了，我们可以直接启动项目进行测试！\r\n\r\n\r\n\r\n### 2.3 树形控件结构分析（1）\r\n\r\n树形结构如下图所示：\r\n\r\n![](web综合案例_day03.assets/6.png)\r\n\r\n对应的实现技术有：\r\n\r\n**dTree**\r\n\r\n**tdTree**\r\n\r\n**zTree**\r\n\r\n\r\n\r\n我们主要来看关于**zTree**的相关操作，从今日课程资料中找到：`资料\\树\\zTree-zTree_v3-master\\zTree_v3\\demo\\cn\\index.html`，打开就可查阅\r\n\r\n![](web综合案例_day03.assets/7.png)\r\n\r\n\r\n\r\n我们主要是针对里面的Checkbox 勾选操作进行学习，我们自己来编写一个测试页面`test.html`来完成一个树形结构，操作步骤：\r\n\r\n- 1.观察整体的页面结构\r\n- 2.去除无效的基础信息\r\n- 3.去除页面无效的基础信息\r\n- 4.分析页面js内容\r\n- 5.分页结构所使用的数据\r\n- 6.简化页面内容书写\r\n\r\n```html\r\n- 1.观察整体的页面结构- 2.去除无效的基础信息- 3.去除页面无效的基础信息- 4.分析页面js内容- 5.分页结构所使用的数据- 6.简化页面内容书写<meta http-equiv="content-type" content="text/html; charset=UTF-8"><link rel="stylesheet" href="../../../css/demo.css" type="text/css"><link rel="stylesheet" href="../../../css/zTreeStyle/zTreeStyle.css" type="text/css"><script type="text/javascript" src="../../../js/jquery-1.4.4.min.js"><\/script><script type="text/javascript" src="../../../js/jquery.ztree.core-3.5.js"><\/script><script type="text/javascript" src="../../../js/jquery.ztree.excheck-3.5.js"><\/script><SCRIPT type="text/javascript">    var setting = {        check: {            enable: true        },        data: {            simpleData: {                enable: true            }        }    };    /**/var zNodes =[        { id:11, pId:1, name:"随意勾选 1-1", open:true},        { id:111, pId:11, name:"随意勾选 1-1-1"},        { id:112, pId:11, name:"随意勾选 1-1-2"},        { id:12, pId:1, name:"随意勾选 1-2", open:true},        { id:121, pId:12, name:"随意勾选 1-2-1"},        { id:122, pId:12, name:"随意勾选 1-2-2"},        { id:2, pId:0, name:"随意勾选 2", checked:true, open:true},        { id:21, pId:2, name:"随意勾选 2-1"},        { id:22, pId:2, name:"随意勾选 2-2", open:true},        { id:221, pId:22, name:"随意勾选 2-2-1", checked:true},        { id:222, pId:22, name:"随意勾选 2-2-2"},        { id:23, pId:2, name:"随意勾选 2-3"},        { id:1, pId:0, name:"随意勾选 1", open:true}    ];    var code;    function setCheck() {        var zTree = $.fn.zTree.getZTreeObj("treeDemo"),            py = $("#py").attr("checked")? "p":"",            sy = $("#sy").attr("checked")? "s":"",            pn = $("#pn").attr("checked")? "p":"",            sn = $("#sn").attr("checked")? "s":"",            type = { "Y":py + sy, "N":pn + sn};        zTree.setting.check.chkboxType = type;        showCode(\'setting.check.chkboxType = { "Y" : "\' + type.Y + \'", "N" : "\' + type.N + \'" };\');    }    function showCode(str) {        if (!code) code = $("#code");        code.empty();        code.append("<li>"+str+"</li>");    }    $(document).ready(function(){        $.fn.zTree.init($("#treeDemo"), setting, zNodes);        setCheck();        $("#py").bind("change", setCheck);        $("#sy").bind("change", setCheck);        $("#pn").bind("change", setCheck);        $("#sn").bind("change", setCheck);    });<\/SCRIPT><div class="content_wrap">    <div class="zTreeDemoBackground left">        <ul id="treeDemo" class="ztree"></ul>    </div>    <div class="right">        <ul class="info">            <li class="title">                <ul class="list">                    <li>                        <input type="checkbox" id="py" class="checkbox first" checked /><span>关联父</span>                        <input type="checkbox" id="sy" class="checkbox first" checked /><span>关联子</span><br/>                        <input type="checkbox" id="pn" class="checkbox first" checked /><span>关联父</span>                        <input type="checkbox" id="sn" class="checkbox first" checked /><span>关联子</span><br/>                        <ul id="code" class="log" style="height:20px;"></ul></p>            </li>        </ul>        </li>    </ul></div></div>\r\n```\r\n\r\n### 2.4 树形控件结构分析（2）\r\n\r\n分析页面js\r\n\r\n```html\r\n- 1.观察整体的页面结构- 2.去除无效的基础信息- 3.去除页面无效的基础信息- 4.分析页面js内容- 5.分页结构所使用的数据- 6.简化页面内容书写<meta http-equiv="content-type" content="text/html; charset=UTF-8"><link rel="stylesheet" href="../../../css/demo.css" type="text/css"><link rel="stylesheet" href="../../../css/zTreeStyle/zTreeStyle.css" type="text/css"><script type="text/javascript" src="../../../js/jquery-1.4.4.min.js"><\/script><script type="text/javascript" src="../../../js/jquery.ztree.core-3.5.js"><\/script><script type="text/javascript" src="../../../js/jquery.ztree.excheck-3.5.js"><\/script><SCRIPT type="text/javascript">\tvar setting = {check: {enable: true},data: {\tsimpleData: {enable: true}}};\tvar zNodes =[        { id:11, pId:1, name:"随意勾选 1-1", open:true},        { id:111, pId:11, name:"随意勾选 1-1-1"},        { id:112, pId:11, name:"随意勾选 1-1-2"},        { id:12, pId:1, name:"随意勾选 1-2", open:true},        { id:121, pId:12, name:"随意勾选 1-2-1"},        { id:122, pId:12, name:"随意勾选 1-2-2"},        { id:2, pId:0, name:"随意勾选 2", checked:true, open:true},        { id:21, pId:2, name:"随意勾选 2-1"},        { id:22, pId:2, name:"随意勾选 2-2", open:true},        { id:221, pId:22, name:"随意勾选 2-2-1", checked:true},        { id:222, pId:22, name:"随意勾选 2-2-2"},        { id:23, pId:2, name:"随意勾选 2-3"},        { id:1, pId:0, name:"随意勾选 1", open:true}    ];\t$(document).ready(function(){\t\t$.fn.zTree.init($("#treeDemo"), setting, zNodes);\t\tvar zTree = $.fn.zTree.getZTreeObj("treeDemo")\t\tzTree.setting.check.chkboxType = { "Y" : "ps", "N" : "ps" }\t});<\/SCRIPT><ul id="treeDemo" class="ztree"></ul>\r\n```\r\n\r\n### 2.5 树形控件结构分析（3）\r\n\r\n继续进行数据结构的分析\r\n\r\n```html\r\n<meta http-equiv="content-type" content="text/html; charset=UTF-8"><link rel="stylesheet" href="../../../css/demo.css" type="text/css"><link rel="stylesheet" href="../../../css/zTreeStyle/zTreeStyle.css" type="text/css"><script type="text/javascript" src="../../../js/jquery-1.4.4.min.js"><\/script><script type="text/javascript" src="../../../js/jquery.ztree.core-3.5.js"><\/script><script type="text/javascript" src="../../../js/jquery.ztree.excheck-3.5.js"><\/script><SCRIPT type="text/javascript">\tvar setting = {check: {enable: true},data: {\tsimpleData: {enable: true}}};\tvar zNodes =[\t\t{ id:2, pId:0, name:"test", checked:true, open:true},\t\t{ id:21, pId:2, name:"test22222"},\t\t{ id:22, pId:1, name:"test22222"}\t];\t$(document).ready(function(){\t\t$.fn.zTree.init($("#treeDemo"), setting, zNodes);\t\tvar zTree = $.fn.zTree.getZTreeObj("treeDemo")\t\tzTree.setting.check.chkboxType = { "Y" : "ps", "N" : "ps" }\t});<\/SCRIPT><ul id="treeDemo" class="ztree"></ul>\r\n```\r\n\r\n### 2.6 动态加载授权数据\r\n\r\n（1）查看页面：`/WEB-INF/pages/system/role/list.jsp`，授权按钮点击时要传递id\r\n\r\n（2）进入后台servlet：`RoleServlet`添加`author`方法\r\n\r\n```java\r\n@Overrideprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    String operation = request.getParameter("operation");    if("list".equals(operation)){        this.list(request,response);    }else if("toAdd".equals(operation)){        this.toAdd(request,response);    }else if("save".equals(operation)){        this.save(request, response);    }else if("toEdit".equals(operation)){        this.toEdit(request,response);    }else if("edit".equals(operation)){        this.edit(request,response);    }else if("delete".equals(operation)){        this.delete(request,response);    }else if("author".equals(operation)){        this.author(request,response);    }}private void author(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {    //获取要授权的角色id    String roleId = request.getParameter("id");    // TODO 数据未查询    //跳转到树页面中    request.getRequestDispatcher("/WEB-INF/pages/system/role/author.jsp").forward(request,response);}\r\n```\r\n\r\n（3）在`/WEB-INF/pages/system/role`下创建一个jsp页面：`test.jsp`，内容粘贴我们之前编辑的`test.html`页面，我们在后台跳转的时候跳转的是该目录下的`author.jsp`，我们可以拿这俩页面做一个对比\r\n\r\n（4）完善servlet中的`author`方法\r\n\r\n```java\r\nprivate void author(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {    //获取要授权的角色id    String roleId = request.getParameter("id");    //使用id查询对应的数据（角色id对应的模块信息）    Role role = roleService.findById(roleId);    request.setAttribute("role",role);    //根据当前的角色id获取所有的模块数据，并加载关系数据    List<Map> map = moduleService.findAuthorDataByRoleId(roleId);    //map转成json数据    ObjectMapper om = new ObjectMapper();    String json = om.writeValueAsString(map);    request.setAttribute("roleModuleJson",json);    // TODO 数据未查询    //跳转到树页面中    request.getRequestDispatcher("/WEB-INF/pages/system/role/author.jsp").forward(request,response);}\r\n```\r\n\r\n在`WEB-INF\\pages\\system\\role\\author.jsp`页面中修改js代码：用后台查询的数据直接赋值给zNodes\r\n\r\n```javascript\r\nvar zNodes =${roleModuleJson}\r\n```\r\n\r\n\r\n\r\n（5）在`ModuleService`中添加`findAuthorDataByRoleId`方法\r\n\r\n```java\r\n/**     * 根据角色id获取对应的所有模块关联数据     * @param roleId 角色id     */List<Map> findAuthorDataByRoleId(String roleId);\r\n```\r\n\r\n（6）在实现类中实现该方法\r\n\r\n```java\r\n@Overridepublic List<Map> findAuthorDataByRoleId(String roleId) {    SqlSession sqlSession = null;    try{        //1.获取SqlSession        sqlSession = MapperFactory.getSqlSession();        //2.获取Dao        ModuleDao moduleDao = MapperFactory.getMapper(sqlSession,ModuleDao.class);        //3.调用Dao层操作        return moduleDao.findAuthorDataByRoleId(roleId);    }catch (Exception e){        throw new RuntimeException(e);        //记录日志    }finally {        try {            TransactionUtil.close(sqlSession);        }catch (Exception e){            e.printStackTrace();        }    }}\r\n```\r\n\r\n（7）添加dao接口方法：`findAuthorDataByRoleId`\r\n\r\n```java\r\nList<Map> findAuthorDataByRoleId(String roleId);\r\n```\r\n\r\n（8）在ModuleDao对应的映射配置文件中添加对应的查询语句\r\n\r\n```xml\r\n<select id="findAuthorDataByRoleId" parameterType="string" resultType="java.util.Map">\tselect\t\tmodule_id as id,\t\tparent_id as pId,\t\tname as name,\t\tcase\t\t\twhen module_id in (select module_id from ss_role_module where role_id = #{roleId})\t\t\t\tthen \'true\'\t\t\t\telse \'false\'\t\t\tend\t\tas checked\tfrom\t\tss_module</select>\r\n```\r\n\r\n（9）启动测试\r\n\r\n### 2.7 绑定角色与模块关系\r\n\r\n（1）查看`WEB-INF\\pages\\system\\role\\author.jsp`页面中提交保存的js代码\r\n\r\n```html\r\n<SCRIPT type="text/javascript">    //实现权限分配    function submitCheckedNodes() {        //1.获取所有的勾选权限节点        var nodes = zTreeObj.getCheckedNodes(true);//true:被勾选，false：未被勾选        //2.循环nodes，获取每个节点的id，并将数据加入数组        //1,2,3,4,5     1+","+2+","+3.....        //数据的临时存储数组，为了方便内容连接成为一个由逗号分隔的字符串        var moduleArrays = [];        for(var i=0;i<nodes.length;i++) {            moduleArrays.push(nodes[i].id);        }        //3.将数组中的数据使用,连接后，赋值给表单，传入后台        $("#moduleIds").val(moduleArrays.join(\',\'));    //1,2,3,4,5        $("#icform").submit();    }<\/SCRIPT><form id="icform" method="post" action="${ctx}/system/role?operation=updateRoleModule">    <input type="hidden" name="roleId" value="${role.id}"/>        <input type="hidden" id="moduleIds" name="moduleIds" value=""/>            <ul id="treeDemo" class="ztree"></ul></form>\x3c!--工具栏--\x3e</form>\r\n```\r\n\r\n（2）在后台servlet中添加方法`updateRoleModule`\r\n\r\n```java\r\n@Overrideprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    String operation = request.getParameter("operation");    if("list".equals(operation)){        this.list(request,response);    }    //中间的else if无变动 省略    else if("updateRoleModule".equals(operation)){        this.updateRoleModule(request,response);    }}private void updateRoleModule(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {    String roleId = request.getParameter("roleId");    String moduleIds = request.getParameter("moduleIds");    roleService.updateRoleModule(roleId,moduleIds);    //跳转回到页面list    response.sendRedirect(request.getContextPath()+"/system/role?operation=list");}\r\n```\r\n\r\n（3）在`RoleService`中添加方法`updateRoleModule`\r\n\r\n```java\r\n/**     * 建立角色与模块之间的关联     * @param roleId 角色id     * @param moduleIds 模块id（多个）     */void updateRoleModule(String roleId, String moduleIds);\r\n```\r\n\r\n（4）在对应的实现类中实现该方法\r\n\r\n```java\r\n@Overridepublic void updateRoleModule(String roleId, String moduleIds) {    SqlSession sqlSession = null;    try{        //1.获取SqlSession        sqlSession = MapperFactory.getSqlSession();        //2.获取Dao        RoleDao roleDao = MapperFactory.getMapper(sqlSession,RoleDao.class);        //3.调用Dao层操作        //修改role_module        //3.1现有的关系全部取消掉        roleDao.deleteRoleModule(roleId);        //3.2建立新的关系（多个）        String[] moduleArray = moduleIds.split(",");        for(String moduleId:moduleArray){            roleDao.saveRoleModule(roleId,moduleId);        }        //4.提交事务        TransactionUtil.commit(sqlSession);    }catch (Exception e){        TransactionUtil.rollback(sqlSession);        throw new RuntimeException(e);        //记录日志    }finally {        try {            TransactionUtil.close(sqlSession);        }catch (Exception e){            e.printStackTrace();        }    }}\r\n```\r\n\r\n（5）在`RoleDao`中添加方法`deleteRoleModule`，`saveRoleModule`\r\n\r\n```java\r\n    void deleteRoleModule(String roleId);    void saveRoleModule(@Param("roleId") String roleId, @Param("moduleId") String moduleId);\r\n```\r\n\r\n（6）在对应的映射配置文件中添加对应的操作\r\n\r\n```xml\r\n\x3c!--配置根据roleId删除关系表数据--\x3e<delete id="deleteRoleModule" parameterType="java.lang.String">    delete from ss_role_module    where role_id = #{roleId,jdbcType=VARCHAR}</delete>\x3c!--配置全字段插入，当某个字段没有值时，插入null--\x3e<insert id="saveRoleModule" parameterType="map">    insert into ss_role_module (role_id, module_id)    values (#{roleId,jdbcType=VARCHAR}, #{moduleId,jdbcType=VARCHAR})</insert>\r\n```\r\n\r\n（7）启动项目进行测试'},"240e":function(n,e,t){"use strict";t.r(e),e["default"]='## 1. ArrayList 简介\n\n`ArrayList` 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用`ensureCapacity`操作来增加 `ArrayList` 实例的容量。这可以减少递增式再分配的数量。\n\n`ArrayList`继承于 **`AbstractList`** ，实现了 **`List`**, **`RandomAccess`**, **`Cloneable`**, **`java.io.Serializable`** 这些接口。\n\n```java\n\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable{\n\n  }\n```\n\n- `RandomAccess` 是一个标志接口，表明实现这个这个接口的 List 集合是支持**快速随机访问**的。在 `ArrayList` 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。\n- `ArrayList` 实现了 **`Cloneable` 接口** ，即覆盖了函数`clone()`，能被克隆。\n- `ArrayList` 实现了 `java.io.Serializable`接口，这意味着`ArrayList`支持序列化，能通过序列化去传输。\n\n### 1.1. Arraylist 和 Vector 的区别?\n\n1. `ArrayList` 是 `List` 的主要实现类，底层使用 `Object[ ]`存储，适用于频繁的查找工作，线程不安全 ；\n2. `Vector` 是 `List` 的古老实现类，底层使用 `Object[ ]`存储，线程安全的。\n\n### 1.2. Arraylist 与 LinkedList 区别?\n\n1. **是否保证线程安全：** `ArrayList` 和 `LinkedList` 都是不同步的，也就是不保证线程安全；\n2. **底层数据结构：** `Arraylist` 底层使用的是 **`Object` 数组**；`LinkedList` 底层使用的是 **双向链表** 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）\n3. **插入和删除是否受元素位置的影响：** ① **`ArrayList` 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。** 比如：执行`add(E e)`方法的时候， `ArrayList` 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（`add(int index, E element)`）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② **`LinkedList` 采用链表存储，所以对于`add(E e)`方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置`i`插入和删除元素的话（`(add(int index, E element)`） 时间复杂度近似为`o(n))`因为需要先移动到指定位置再插入。**\n4. **是否支持快速随机访问：** `LinkedList` 不支持高效的随机元素访问，而 `ArrayList` 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于`get(int index)`方法)。\n5. **内存空间占用：** `ArrayList` 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 `LinkedList` 的空间花费则体现在它的每一个元素都需要消耗比 `ArrayList` 更多的空间（因为要存放直接后继和直接前驱以及数据）。\n\n## 2. ArrayList 核心源码解读\n\n```java\npackage java.util;\n\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.function.UnaryOperator;\n\n\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n{\n    private static final long serialVersionUID = 8683452581122892189L;\n\n    /**\n     * 默认初始容量大小\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n\n    /**\n     * 空数组（用于空实例）。\n     */\n    private static final Object[] EMPTY_ELEMENTDATA = {};\n\n     //用于默认大小空实例的共享空数组实例。\n      //我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    /**\n     * 保存ArrayList数据的数组\n     */\n    transient Object[] elementData; // non-private to simplify nested class access\n\n    /**\n     * ArrayList 所包含的元素个数\n     */\n    private int size;\n\n    /**\n     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）\n     */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {\n            //如果传入的参数大于0，创建initialCapacity大小的数组\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n            //如果传入的参数等于0，创建空数组\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n            //其他情况，抛出异常\n            throw new IllegalArgumentException("Illegal Capacity: "+\n                                               initialCapacity);\n        }\n    }\n\n    /**\n     *默认无参构造函数\n     *DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n\n    /**\n     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。\n     */\n    public ArrayList(Collection<? extends E> c) {\n        //将指定集合转换为数组\n        elementData = c.toArray();\n        //如果elementData数组的长度不为0\n        if ((size = elementData.length) != 0) {\n            // 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）\n            if (elementData.getClass() != Object[].class)\n                //将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // 其他情况，用空数组代替\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n\n    /**\n     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。\n     */\n    public void trimToSize() {\n        modCount++;\n        if (size < elementData.length) {\n            elementData = (size == 0)\n              ? EMPTY_ELEMENTDATA\n              : Arrays.copyOf(elementData, size);\n        }\n    }\n//下面是ArrayList的扩容机制\n//ArrayList的扩容机制提高了性能，如果每次只扩充一个，\n//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。\n    /**\n     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量\n     * @param   minCapacity   所需的最小容量\n     */\n    public void ensureCapacity(int minCapacity) {\n        //如果是true，minExpand的值为0，如果是false,minExpand的值为10\n        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n            // any size if not default element table\n            ? 0\n            // larger than default for default empty table. It\'s already\n            // supposed to be at default size.\n            : DEFAULT_CAPACITY;\n        //如果最小容量大于已有的最大容量\n        if (minCapacity > minExpand) {\n            ensureExplicitCapacity(minCapacity);\n        }\n    }\n   //得到最小扩容量\n    private void ensureCapacityInternal(int minCapacity) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n              // 获取“默认的容量”和“传入参数”两者之间的最大值\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n\n        ensureExplicitCapacity(minCapacity);\n    }\n  //判断是否需要扩容\n    private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n\n        // overflow-conscious code\n        if (minCapacity - elementData.length > 0)\n            //调用grow方法进行扩容，调用此方法代表已经开始扩容了\n            grow(minCapacity);\n    }\n\n    /**\n     * 要分配的最大数组大小\n     */\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n    /**\n     * ArrayList扩容的核心方法。\n     */\n    private void grow(int minCapacity) {\n        // oldCapacity为旧容量，newCapacity为新容量\n        int oldCapacity = elementData.length;\n        //将oldCapacity 右移一位，其效果相当于oldCapacity /2，\n        //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        //再检查新容量是否超出了ArrayList所定义的最大容量，\n        //若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，\n        //如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n    //比较minCapacity和 MAX_ARRAY_SIZE\n    private static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n    }\n\n    /**\n     *返回此列表中的元素数。\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * 如果此列表不包含元素，则返回 true 。\n     */\n    public boolean isEmpty() {\n        //注意=和==的区别\n        return size == 0;\n    }\n\n    /**\n     * 如果此列表包含指定的元素，则返回true 。\n     */\n    public boolean contains(Object o) {\n        //indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1\n        return indexOf(o) >= 0;\n    }\n\n    /**\n     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1\n     */\n    public int indexOf(Object o) {\n        if (o == null) {\n            for (int i = 0; i < size; i++)\n                if (elementData[i]==null)\n                    return i;\n        } else {\n            for (int i = 0; i < size; i++)\n                //equals()方法比较\n                if (o.equals(elementData[i]))\n                    return i;\n        }\n        return -1;\n    }\n\n    /**\n     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.\n     */\n    public int lastIndexOf(Object o) {\n        if (o == null) {\n            for (int i = size-1; i >= 0; i--)\n                if (elementData[i]==null)\n                    return i;\n        } else {\n            for (int i = size-1; i >= 0; i--)\n                if (o.equals(elementData[i]))\n                    return i;\n        }\n        return -1;\n    }\n\n    /**\n     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）\n     */\n    public Object clone() {\n        try {\n            ArrayList<?> v = (ArrayList<?>) super.clone();\n            //Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度\n            v.elementData = Arrays.copyOf(elementData, size);\n            v.modCount = 0;\n            return v;\n        } catch (CloneNotSupportedException e) {\n            // 这不应该发生，因为我们是可以克隆的\n            throw new InternalError(e);\n        }\n    }\n\n    /**\n     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。\n     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。\n     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。\n     */\n    public Object[] toArray() {\n        return Arrays.copyOf(elementData, size);\n    }\n\n    /**\n     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;\n     *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。\n     *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。\n     *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。\n     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）\n     */\n    @SuppressWarnings("unchecked")\n    public <T> T[] toArray(T[] a) {\n        if (a.length < size)\n            // 新建一个运行时类型的数组，但是ArrayList数组的内容\n            return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n            //调用System提供的arraycopy()方法实现数组之间的复制\n        System.arraycopy(elementData, 0, a, 0, size);\n        if (a.length > size)\n            a[size] = null;\n        return a;\n    }\n\n    // Positional Access Operations\n\n    @SuppressWarnings("unchecked")\n    E elementData(int index) {\n        return (E) elementData[index];\n    }\n\n    /**\n     * 返回此列表中指定位置的元素。\n     */\n    public E get(int index) {\n        rangeCheck(index);\n\n        return elementData(index);\n    }\n\n    /**\n     * 用指定的元素替换此列表中指定位置的元素。\n     */\n    public E set(int index, E element) {\n        //对index进行界限检查\n        rangeCheck(index);\n\n        E oldValue = elementData(index);\n        elementData[index] = element;\n        //返回原来在这个位置的元素\n        return oldValue;\n    }\n\n    /**\n     * 将指定的元素追加到此列表的末尾。\n     */\n    public boolean add(E e) {\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //这里看到ArrayList添加元素的实质就相当于为数组赋值\n        elementData[size++] = e;\n        return true;\n    }\n\n    /**\n     * 在此列表中的指定位置插入指定的元素。\n     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；\n     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。\n     */\n    public void add(int index, E element) {\n        rangeCheckForAdd(index);\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己\n        System.arraycopy(elementData, index, elementData, index + 1,\n                         size - index);\n        elementData[index] = element;\n        size++;\n    }\n\n    /**\n     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。\n     */\n    public E remove(int index) {\n        rangeCheck(index);\n\n        modCount++;\n        E oldValue = elementData(index);\n\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n      //从列表中删除的元素\n        return oldValue;\n    }\n\n    /**\n     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。\n     *返回true，如果此列表包含指定的元素\n     */\n    public boolean remove(Object o) {\n        if (o == null) {\n            for (int index = 0; index < size; index++)\n                if (elementData[index] == null) {\n                    fastRemove(index);\n                    return true;\n                }\n        } else {\n            for (int index = 0; index < size; index++)\n                if (o.equals(elementData[index])) {\n                    fastRemove(index);\n                    return true;\n                }\n        }\n        return false;\n    }\n\n    /*\n     * Private remove method that skips bounds checking and does not\n     * return the value removed.\n     */\n    private void fastRemove(int index) {\n        modCount++;\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n    }\n\n    /**\n     * 从列表中删除所有元素。\n     */\n    public void clear() {\n        modCount++;\n\n        // 把数组中所有的元素的值设为null\n        for (int i = 0; i < size; i++)\n            elementData[i] = null;\n\n        size = 0;\n    }\n\n    /**\n     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。\n     */\n    public boolean addAll(Collection<? extends E> c) {\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        ensureCapacityInternal(size + numNew);  // Increments modCount\n        System.arraycopy(a, 0, elementData, size, numNew);\n        size += numNew;\n        return numNew != 0;\n    }\n\n    /**\n     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。\n     */\n    public boolean addAll(int index, Collection<? extends E> c) {\n        rangeCheckForAdd(index);\n\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        ensureCapacityInternal(size + numNew);  // Increments modCount\n\n        int numMoved = size - index;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index, elementData, index + numNew,\n                             numMoved);\n\n        System.arraycopy(a, 0, elementData, index, numNew);\n        size += numNew;\n        return numNew != 0;\n    }\n\n    /**\n     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。\n     *将任何后续元素移动到左侧（减少其索引）。\n     */\n    protected void removeRange(int fromIndex, int toIndex) {\n        modCount++;\n        int numMoved = size - toIndex;\n        System.arraycopy(elementData, toIndex, elementData, fromIndex,\n                         numMoved);\n\n        // clear to let GC do its work\n        int newSize = size - (toIndex-fromIndex);\n        for (int i = newSize; i < size; i++) {\n            elementData[i] = null;\n        }\n        size = newSize;\n    }\n\n    /**\n     * 检查给定的索引是否在范围内。\n     */\n    private void rangeCheck(int index) {\n        if (index >= size)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n    }\n\n    /**\n     * add和addAll使用的rangeCheck的一个版本\n     */\n    private void rangeCheckForAdd(int index) {\n        if (index > size || index < 0)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n    }\n\n    /**\n     * 返回IndexOutOfBoundsException细节信息\n     */\n    private String outOfBoundsMsg(int index) {\n        return "Index: "+index+", Size: "+size;\n    }\n\n    /**\n     * 从此列表中删除指定集合中包含的所有元素。\n     */\n    public boolean removeAll(Collection<?> c) {\n        Objects.requireNonNull(c);\n        //如果此列表被修改则返回true\n        return batchRemove(c, false);\n    }\n\n    /**\n     * 仅保留此列表中包含在指定集合中的元素。\n     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。\n     */\n    public boolean retainAll(Collection<?> c) {\n        Objects.requireNonNull(c);\n        return batchRemove(c, true);\n    }\n\n\n    /**\n     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。\n     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。\n     *返回的列表迭代器是fail-fast 。\n     */\n    public ListIterator<E> listIterator(int index) {\n        if (index < 0 || index > size)\n            throw new IndexOutOfBoundsException("Index: "+index);\n        return new ListItr(index);\n    }\n\n    /**\n     *返回列表中的列表迭代器（按适当的顺序）。\n     *返回的列表迭代器是fail-fast 。\n     */\n    public ListIterator<E> listIterator() {\n        return new ListItr(0);\n    }\n\n    /**\n     *以正确的顺序返回该列表中的元素的迭代器。\n     *返回的迭代器是fail-fast 。\n     */\n    public Iterator<E> iterator() {\n        return new Itr();\n    }\n\n\n```\n\n## 3. ArrayList 扩容机制分析\n\n### 3.1. 先从 ArrayList 的构造函数说起\n\n**（JDK8）ArrayList 有三种方式来初始化，构造方法源码如下：**\n\n```java\n   /**\n     * 默认初始容量大小\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n\n\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    /**\n     *默认构造函数，使用初始容量10构造一个空列表(无参数构造)\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n\n    /**\n     * 带初始容量参数的构造函数。（用户自己指定容量）\n     */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {//初始容量大于0\n            //创建initialCapacity大小的数组\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {//初始容量等于0\n            //创建空数组\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {//初始容量小于0，抛出异常\n            throw new IllegalArgumentException("Illegal Capacity: "+\n                                               initialCapacity);\n        }\n    }\n\n\n   /**\n    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回\n    *如果指定的集合为null，throws NullPointerException。\n    */\n     public ArrayList(Collection<? extends E> c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n\n```\n\n细心的同学一定会发现 ：**以无参数构造方法创建 `ArrayList` 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。** 下面在我们分析 ArrayList 扩容时会讲到这一点内容！\n\n> 补充：JDK6 new 无参构造的 `ArrayList` 对象时，直接创建了长度是 10 的 `Object[]` 数组 elementData 。\n\n### 3.2. 一步一步分析 ArrayList 扩容机制\n\n这里以无参构造函数创建的 ArrayList 为例分析\n\n#### 3.2.1. 先来看 `add` 方法\n\n```java\n    /**\n     * 将指定的元素追加到此列表的末尾。\n     */\n    public boolean add(E e) {\n   //添加元素之前，先调用ensureCapacityInternal方法\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //这里看到ArrayList添加元素的实质就相当于为数组赋值\n        elementData[size++] = e;\n        return true;\n    }\n```\n\n> **注意** ：JDK11 移除了 `ensureCapacityInternal()` 和 `ensureExplicitCapacity()` 方法\n\n#### 3.2.2. 再来看看 `ensureCapacityInternal()` 方法\n\n（JDK7）可以看到 `add` 方法 首先调用了`ensureCapacityInternal(size + 1)`\n\n```java\n   //得到最小扩容量\n    private void ensureCapacityInternal(int minCapacity) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n              // 获取默认的容量和传入参数的较大值\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n\n        ensureExplicitCapacity(minCapacity);\n    }\n```\n\n**当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。**\n\n> 此处和后续 JDK8 代码格式化略有不同，核心代码基本一样。\n\n#### 3.2.3. `ensureExplicitCapacity()` 方法\n\n如果调用 `ensureCapacityInternal()` 方法就一定会进入（执行）这个方法，下面我们来研究一下这个方法的源码！\n\n```java\n  //判断是否需要扩容\n    private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n\n        // overflow-conscious code\n        if (minCapacity - elementData.length > 0)\n            //调用grow方法进行扩容，调用此方法代表已经开始扩容了\n            grow(minCapacity);\n    }\n\n```\n\n我们来仔细分析一下：\n\n- 当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 `ensureCapacityInternal()` 方法 ，所以 minCapacity 此时为 10。此时，`minCapacity - elementData.length > 0`成立，所以会进入 `grow(minCapacity)` 方法。\n- 当 add 第 2 个元素时，minCapacity 为 2，此时 e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，`minCapacity - elementData.length > 0` 不成立，所以不会进入 （执行）`grow(minCapacity)` 方法。\n- 添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。\n\n直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。\n\n#### 3.2.4. `grow()` 方法\n\n```java\n    /**\n     * 要分配的最大数组大小\n     */\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n    /**\n     * ArrayList扩容的核心方法。\n     */\n    private void grow(int minCapacity) {\n        // oldCapacity为旧容量，newCapacity为新容量\n        int oldCapacity = elementData.length;\n        //将oldCapacity 右移一位，其效果相当于oldCapacity /2，\n        //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n       // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，\n       //如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n```\n\n**int newCapacity = oldCapacity + (oldCapacity >> 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！** 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.\n\n> ">>"（移位运算符）：>>1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity /2。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源\n\n**我们再来通过例子探究一下`grow()` 方法 ：**\n\n- 当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity = minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 `hugeCapacity` 方法。数组容量为 10，add 方法中 return true,size 增为 1。\n- 当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。\n- 以此类推······\n\n**这里补充一点比较重要，但是容易被忽视掉的知识点：**\n\n- java 中的 `length`属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.\n- java 中的 `length()` 方法是针对字符串说的,如果想看这个字符串的长度则用到 `length()` 这个方法.\n- java 中的 `size()` 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!\n\n#### 3.2.5. `hugeCapacity()` 方法。\n\n从上面 `grow()` 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。\n\n```java\n    private static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        //对minCapacity和MAX_ARRAY_SIZE进行比较\n        //若minCapacity大，将Integer.MAX_VALUE作为新数组的大小\n        //若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小\n        //MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n    }\n```\n\n### 3.3. `System.arraycopy()` 和 `Arrays.copyOf()`方法\n\n阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及`add(int index, E element)`、`toArray()` 等方法中都用到了该方法！\n\n#### 3.3.1. `System.arraycopy()` 方法\n\n源码：\n\n```java\n    // 我们发现 arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义\n    /**\n    *   复制数组\n    * @param src 源数组\n    * @param srcPos 源数组中的起始位置\n    * @param dest 目标数组\n    * @param destPos 目标数组中的起始位置\n    * @param length 要复制的数组元素的数量\n    */\n    public static native void arraycopy(Object src,  int  srcPos,\n                                        Object dest, int destPos,\n                                        int length);\n```\n\n场景：\n\n```java\n    /**\n     * 在此列表中的指定位置插入指定的元素。\n     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；\n     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。\n     */\n    public void add(int index, E element) {\n        rangeCheckForAdd(index);\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //arraycopy()方法实现数组自己复制自己\n        //elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；\n        System.arraycopy(elementData, index, elementData, index + 1, size - index);\n        elementData[index] = element;\n        size++;\n    }\n```\n\n我们写一个简单的方法测试以下：\n\n```java\npublic class ArraycopyTest {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[] a = new int[10];\n\t\ta[0] = 0;\n\t\ta[1] = 1;\n\t\ta[2] = 2;\n\t\ta[3] = 3;\n\t\tSystem.arraycopy(a, 2, a, 3, 3);\n\t\ta[2]=99;\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tSystem.out.print(a[i] + " ");\n\t\t}\n\t}\n\n}\n```\n\n结果：\n\n```\n0 1 99 2 3 0 0 0 0 0\n```\n\n#### 3.3.2. `Arrays.copyOf()`方法\n\n源码：\n\n```java\n    public static int[] copyOf(int[] original, int newLength) {\n    \t// 申请一个新的数组\n        int[] copy = new int[newLength];\n\t// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组\n        System.arraycopy(original, 0, copy, 0,\n                         Math.min(original.length, newLength));\n        return copy;\n    }\n```\n\n场景：\n\n```java\n   /**\n     以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。\n     */\n    public Object[] toArray() {\n    //elementData：要复制的数组；size：要复制的长度\n        return Arrays.copyOf(elementData, size);\n    }\n```\n\n个人觉得使用 `Arrays.copyOf()`方法主要是为了给原有数组扩容，测试代码如下：\n\n```java\npublic class ArrayscopyOfTest {\n\n\tpublic static void main(String[] args) {\n\t\tint[] a = new int[3];\n\t\ta[0] = 0;\n\t\ta[1] = 1;\n\t\ta[2] = 2;\n\t\tint[] b = Arrays.copyOf(a, 10);\n\t\tSystem.out.println("b.length"+b.length);\n\t}\n}\n```\n\n结果：\n\n```\n10\n```\n\n#### 3.3.3. 两者联系和区别\n\n**联系：**\n\n看两者源代码可以发现 `copyOf()`内部实际调用了 `System.arraycopy()` 方法\n\n**区别：**\n\n`arraycopy()` 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 `copyOf()` 是系统自动在内部新建一个数组，并返回该数组。\n\n### 3.4. `ensureCapacity`方法\n\nArrayList 源码中有一个 `ensureCapacity` 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？\n\n```java\n    /**\n    如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。\n     *\n     * @param   minCapacity   所需的最小容量\n     */\n    public void ensureCapacity(int minCapacity) {\n        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n            // any size if not default element table\n            ? 0\n            // larger than default for default empty table. It\'s already\n            // supposed to be at default size.\n            : DEFAULT_CAPACITY;\n\n        if (minCapacity > minExpand) {\n            ensureExplicitCapacity(minCapacity);\n        }\n    }\n\n```\n\n**最好在 add 大量元素之前用 `ensureCapacity` 方法，以减少增量重新分配的次数**\n\n我们通过下面的代码实际测试以下这个方法的效果：\n\n```java\npublic class EnsureCapacityTest {\n\tpublic static void main(String[] args) {\n\t\tArrayList<Object> list = new ArrayList<Object>();\n\t\tfinal int N = 10000000;\n\t\tlong startTime = System.currentTimeMillis();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tlist.add(i);\n\t\t}\n\t\tlong endTime = System.currentTimeMillis();\n\t\tSystem.out.println("使用ensureCapacity方法前："+(endTime - startTime));\n\n\t}\n}\n```\n\n运行结果：\n\n```\n使用ensureCapacity方法前：2158\n```\n\n```java\npublic class EnsureCapacityTest {\n    public static void main(String[] args) {\n        ArrayList<Object> list = new ArrayList<Object>();\n        final int N = 10000000;\n        list = new ArrayList<Object>();\n        long startTime1 = System.currentTimeMillis();\n        list.ensureCapacity(N);\n        for (int i = 0; i < N; i++) {\n            list.add(i);\n        }\n        long endTime1 = System.currentTimeMillis();\n        System.out.println("使用ensureCapacity方法后："+(endTime1 - startTime1));\n    }\n}\n```\n\n运行结果：\n\n```\n使用ensureCapacity方法后：1773\n```\n\n通过运行结果，我们可以看出向 ArrayList 添加大量元素之前最好先使用`ensureCapacity` 方法，以减少增量重新分配的次数。\n'},"24e5":function(n,e,t){"use strict";t.r(e),e["default"]='# WEB综合案例\r\n\r\n## 学习目标：\r\n\r\n目标1：能够说出案例的系统架构和技术架构\r\n\r\n目标2：能够说出案例的大致需求\r\n\r\n目标3：完成案例工程结构和页面结构的搭建\r\n\r\n目标4：完成企业模块相关功能的业务开发\r\n\r\n目标5：完成部门模块相关功能的业务开发\r\n\r\n目标6：完成用户模块相关功能的业务的开发\r\n\r\n## 1. 概述\r\n\r\n### 1.1 案例介绍\r\n\r\n**黑马面面是一款面向程序员的面试刷题系统**，服务于学员培训学习完毕后的复习问题，通过大量刷题，提高企业面试题的熟知度，辅助学员顺利完成求职面试。\r\n\r\n注意：我们在本课程中只做黑马面面系统的一部分，对有些功能进行了微缩改造，\r\n\r\n黑马面面本原始系统又分为三个子系统：**后台系统，前台系统，手机端**（在本课程中不涉及），以下是各子系统核心的功能介绍\r\n\r\n**后台系统**：试题的录入\r\n\r\n![](web综合案例-day01.assets/0.png)\r\n\r\n![](web综合案例-day01.assets/1.png)\r\n\r\n**前台系统**：会员刷题\r\n\r\n![](web综合案例-day01.assets/2.png)\r\n\r\n**手机端**：会员刷题（常用/主流）\r\n\r\n### 1.2系统架构\r\n\r\n接下来在做之前，我们就要说说这套案例制作的时候应该采用怎样的一种结构进行搭建？同时采用什么样的技术进行实现。那么首先我们先聊一聊整个项目的系统架构。\r\n\r\n![](web综合案例-day01.assets/3.png)\r\n\r\n对于整个系统来说，它分成两块，一个是后台系统，一个是前台系统。那么我们在访问后台系统的时候，是通过浏览器来进行访问，最终把我们的数据存入到我们的数据库端。记得一点，我们从后台系统录入的题目数据，最终会被前台系统使用，所以说前后台系统，他们在数据这一端上来说是进行共享的。也就是前后台系统用的基础数据是同一组。那么前台系统是通过手机端来进行刷这个题，那么我们在这里边呢，不做手机端的，我们也做浏览器的，这就是它的一个整体的结构，你要先了解。\r\n\r\n那么对于后台系统来说，开发的时候，我们采用三层架构的形式开发，分为表现、业务、数据。表现层负责数据的收集以及回显，业务层负责业务逻辑处理，数据层负责与数据库打交道。那么对于前台系统来说呢，它仍然是这样的，只不过他们之间用的技术有差别。那么都有哪些差别呢？接下来咱们就要来说一下技术架构！\r\n\r\n### 1.3 技术架构\r\n\r\n对于后台系统与前台系统，我们分成五个层面来介绍他们的产品。分别是页面端的技术，也就是我们的前端技术了，以及controller、service、Dao、DB。\r\n\r\n详情见下图：\r\n\r\n![](web综合案例-day01.assets/4.png)\r\n\r\nAdminLTE：一个前端框架，提供了很多友好的主题样式，动态功能效果，可直接使用，非常方便\r\n\r\nPOI：数据报表工具，可用于报表导出\r\n\r\n### 1.4 需求分析\r\n\r\n刷题是整个项目的核心功能，那么试题一定是我们的核心。对一道题来说，体型会多种多样，这次我们以最复杂的选择题来演示。选择题一般由题目与选项构成，题目与选项是一对多的关系。在下图中，我们以线和圆点来表述它们之间的关系。没有圆点的是“一”方，有圆点的是“多”方。\r\n\r\n继续看，试题一定有归属的学科，比如你Java的同学做python的题，其实意义不大对吧。题目和学科能直产生一对多的关系吗？一个学科下其实分了很多的东西，比如Java下分Java基础、JavaWeb等等，所以在学科和试题建，需要有个目录。\r\n\r\n假如你现在想去一个企业，是不想想看看这个企业以前都出些什么面试题呀。那就需要一个企业的模块了。一个企业与试题之间，也是一对多的关系。\r\n\r\n试题是谁录入系统呢？需要有用户模块，那肯定是操作系统的人，对于这个用户来说，并不是所有人都能录入，所以需要约定一个部门。然后，那是部门中所有人都需要录入么？这样就涉及到了一个权限的问题了，我们说你这个用户有一种角色，就能拥有录入试题的权限！所以在用户与角色之间形成一个多对多的关系。\r\n\r\n这个人分配角色了就能录试题了吗？不，还需要一个叫模块的东西。就是这个系统中一共有多少种操作？在我们系统中有一个模块叫做录入试题的模块，有一个模块叫审核试题的模块，是这个角色能操作这个模块儿，所以这个用户才能执行这项操作。模块与角色之间也是一个多对多的关系。\r\n\r\n录入完了就能直接用么？不能，万一你录的题有问题呢？所以一定要有一个审核机制。对于所有的操作，我们都需要有一个日志来记录了，所以还要有一个日志的东西。\r\n\r\n![](web综合案例-day01.assets/5.png)\r\n\r\n接下来要开始答题 ，那谁来答题呢？，会员。所以我们要有一个会员的模块。会员就直接做题吗？，做题应该是以试卷的形式呈现。作为一个会员，登录以后，你要去做一套卷子，而不是做一道题，当然你说能不能做单个题，可以，可以把单个题理解为这个试卷就一道题。会员与试卷是一对多的关系。\r\n\r\n那试卷就与我们的试题直接产生关系么，不需要。我们每一个试卷生成以后。都需要把这个题给做出来，你做出来以后，除了有题目以外，试卷中还得有你做题的答案。所以说试卷中会保存一个试卷的答题明细，这个地方试卷对答题明细是一个一对多的关系。其实答题明细中本身就有试题的ID，因此我们这里用试卷与答题明细对试题进行关联。\r\n\r\n总结一下，左边这块是属于后台系统，负责保障录入试题的。右边这块属于前台系统，负责学员的刷题功能。\r\n\r\n### 1.5 课程计划安排\r\n\r\n![](web综合案例-day01.assets/6.png)\r\n\r\n## 2. 环境搭建\r\n\r\n### 2.1 工程结构搭建\r\n\r\n创建工程的要求，及注意点：\r\n\r\n- 创建maven工程（web工程）\r\n\r\n\r\n- 导入项目依赖的坐标（资源）\r\n\r\n\r\n- 补全目录结构\r\n\r\n>web\r\n>\r\n>​    |-----src\r\n>\r\n>​\t       |-------main\r\n>\r\n>​\t\t\t      |------------java\r\n>\r\n>​\t                      |------------resources\r\n>\r\n>​                              |------------webapp\r\n>\r\n>​                |-------test\r\n>\r\n>​\t\t\t      |-------------java\r\n>\r\n>​\t\t\t      |-------------resources\r\n\r\n\r\n\r\n- 创建三层架构开发的包层次结构\r\n\r\n\r\n- 创建三层架构开发的包层次结构\r\n\r\n>domain\r\n>\r\n>dao\r\n>\r\n>service\r\n>\r\n>web\r\n>\r\n>​       controller\r\n>\r\n>​\tfilters\r\n>\r\n>utils\r\n>\r\n>factory\r\n\r\n\r\n\r\n1：创建项目：mm\r\n\r\n```xml\r\n<groupId>com.itheima</groupId>\r\n<artifactId>mm</artifactId>\r\n<version>1.0-SNAPSHOT</version>\r\n<packaging>war</packaging>\r\n```\r\n\r\n2：在pom.xml文件中添加相关坐标：\r\n\r\n```xml\r\n<properties>\r\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\r\n    <maven.compiler.source>1.8</maven.compiler.source>\r\n    <maven.compiler.target>1.8</maven.compiler.target>\r\n</properties>\r\n\r\n<dependencies>\r\n    \x3c!--mybatis_--\x3e\r\n    <dependency>\r\n        <groupId>org.mybatis</groupId>\r\n        <artifactId>mybatis</artifactId>\r\n        <version>3.5.3</version>\r\n    </dependency>\r\n    \x3c!--分页插件--\x3e\r\n    <dependency>\r\n        <groupId>com.github.pagehelper</groupId>\r\n        <artifactId>pagehelper</artifactId>\r\n        <version>5.1.2</version>\r\n    </dependency>\r\n    \x3c!--mysql--\x3e\r\n    <dependency>\r\n        <groupId>mysql</groupId>\r\n        <artifactId>mysql-connector-java</artifactId>\r\n        <version>5.1.46</version>\r\n    </dependency>\r\n    \x3c!--druid数据源--\x3e\r\n    <dependency>\r\n        <groupId>com.alibaba</groupId>\r\n        <artifactId>druid</artifactId>\r\n        <version>1.1.21</version>\r\n    </dependency>\r\n    \x3c!--junit--\x3e\r\n    <dependency>\r\n        <groupId>junit</groupId>\r\n        <artifactId>junit</artifactId>\r\n        <version>4.12</version>\r\n        <scope>test</scope>\r\n    </dependency>\r\n    \x3c!-- servlet3.0 --\x3e\r\n    <dependency>\r\n        <groupId>javax.servlet</groupId>\r\n        <artifactId>javax.servlet-api</artifactId>\r\n        <version>3.1.0</version>\r\n        <scope>provided</scope>\r\n    </dependency>\r\n    \x3c!--jsp--\x3e\r\n    <dependency>\r\n        <groupId>javax.servlet.jsp</groupId>\r\n        <artifactId>javax.servlet.jsp-api</artifactId>\r\n        <version>2.3.3</version>\r\n        <scope>provided</scope>\r\n    </dependency>\r\n    \x3c!--bean-utils--\x3e\r\n    <dependency>\r\n        <groupId>commons-beanutils</groupId>\r\n        <artifactId>commons-beanutils</artifactId>\r\n        <version>1.9.4</version>\r\n    </dependency>\r\n    \x3c!--apache工具包--\x3e\r\n    <dependency>\r\n        <groupId>org.apache.commons</groupId>\r\n        <artifactId>commons-lang3</artifactId>\r\n        <version>3.9</version>\r\n    </dependency>\r\n    \x3c!--jstl--\x3e\r\n    <dependency>\r\n        <groupId>jstl</groupId>\r\n        <artifactId>jstl</artifactId>\r\n        <version>1.2</version>\r\n    </dependency>\r\n    \x3c!--jackson--\x3e\r\n    <dependency>\r\n        <groupId>com.fasterxml.jackson.core</groupId>\r\n        <artifactId>jackson-annotations</artifactId>\r\n        <version>2.9.0</version>\r\n    </dependency>\r\n    <dependency>\r\n        <groupId>com.fasterxml.jackson.core</groupId>\r\n        <artifactId>jackson-core</artifactId>\r\n        <version>2.9.0</version>\r\n    </dependency>\r\n    <dependency>\r\n        <groupId>com.fasterxml.jackson.core</groupId>\r\n        <artifactId>jackson-databind</artifactId>\r\n        <version>2.9.0</version>\r\n    </dependency>\r\n    \x3c!--文件上传--\x3e\r\n    <dependency>\r\n        <groupId>commons-fileupload</groupId>\r\n        <artifactId>commons-fileupload</artifactId>\r\n        <version>1.3.1</version>\r\n    </dependency>\r\n    \x3c!--POI--\x3e\r\n    <dependency>\r\n        <groupId>org.apache.poi</groupId>\r\n        <artifactId>poi</artifactId>\r\n        <version>4.0.1</version>\r\n    </dependency>\r\n    <dependency>\r\n        <groupId>org.apache.poi</groupId>\r\n        <artifactId>poi-ooxml</artifactId>\r\n        <version>4.0.1</version>\r\n    </dependency>\r\n    <dependency>\r\n        <groupId>org.apache.poi</groupId>\r\n        <artifactId>poi-ooxml-schemas</artifactId>\r\n        <version>4.0.1</version>\r\n    </dependency>\r\n</dependencies>\r\n\r\n<build>\r\n    <plugins>\r\n        \x3c!--tomcat插件--\x3e\r\n        <plugin>\r\n            <groupId>org.apache.tomcat.maven</groupId>\r\n            <artifactId>tomcat7-maven-plugin</artifactId>\r\n            <version>2.1</version>\r\n            <configuration>\r\n                <port>80</port>\r\n                <path>/</path>\r\n            </configuration>\r\n        </plugin>\r\n    </plugins>\r\n</build>\r\n```\r\n\r\n3：创建相关目录结构，包结构，如下\r\n\r\n![](web综合案例-day01.assets/7.png)\r\n\r\n删除：web.xml\r\n\r\n4：启动初始项目，运行查看！\r\n\r\n5：从今日课程资料--------\x3e工程资源文件中找到项目数据库脚本，导入到mysql数据库，创建好相关的库表结构\r\n\r\n### 2.2 页面结构搭建\r\n\r\n管理后台一般有着固定的页面构建模式，我们可以进行快速构建\r\n\r\n![](web综合案例-day01.assets/8.png)\r\n\r\n- AdminLTE是一款建立在bootstrap和jquery之上的开源模板主题工具，其中内置了多个模板页面，可以用于快速创建响应式Html5网站，并免去了书写大量的 CSS 与 JS 的工作\r\n- 黑马程序员研究院对AdminLTE进行了汉化，并改良了个别功能，方便学员学习使用\r\n\r\n\r\n\r\n从今日课程资料中找到：模块页面----------\x3e案例结构页面-----------\x3e导入到项目的webapp目录下，如果有文件需要覆盖则选择覆盖，\r\n\r\n导入完成后可以启动项目进行查看\r\n\r\n由AdminLTE构建的网站后台的整体页面布局如下：\r\n\r\n![](web综合案例-day01.assets/9.png)\r\n\r\n## 3. 企业模块\r\n\r\n我们选择一个单表的增删改查功能来进行入门，熟悉开发的模式和流程，因此选择企业模块\r\n\r\n![](web综合案例-day01.assets/10.png)\r\n\r\n要对企业信息做CRUD，我们需要知道要操作企业的那些字段，\r\n\r\n![](web综合案例-day01.assets/11.png)\r\n\r\n### 3.1 数据层开发\r\n\r\n1：创建实体：com.itheima.domain.store.Company\r\n\r\n```java\r\npublic class Company {\r\n\r\n    private String id;\r\n    private String name;\r\n    private Date expirationDate;\r\n    private String address;\r\n    private String licenseId;\r\n    private String representative;\r\n    private String phone;\r\n    private String companySize;\r\n    private String industry;\r\n    private String remarks;\r\n    private Integer state;\r\n    private String city;\r\n\r\n    public String getId() {\r\n        return id;\r\n    }\r\n\r\n    public void setId(String id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public Date getExpirationDate() {\r\n        return expirationDate;\r\n    }\r\n\r\n    public void setExpirationDate(Date expirationDate) {\r\n        this.expirationDate = expirationDate;\r\n    }\r\n\r\n    public String getAddress() {\r\n        return address;\r\n    }\r\n\r\n    public void setAddress(String address) {\r\n        this.address = address;\r\n    }\r\n\r\n    public String getLicenseId() {\r\n        return licenseId;\r\n    }\r\n\r\n    public void setLicenseId(String licenseId) {\r\n        this.licenseId = licenseId;\r\n    }\r\n\r\n    public String getRepresentative() {\r\n        return representative;\r\n    }\r\n\r\n    public void setRepresentative(String representative) {\r\n        this.representative = representative;\r\n    }\r\n\r\n    public String getPhone() {\r\n        return phone;\r\n    }\r\n\r\n    public void setPhone(String phone) {\r\n        this.phone = phone;\r\n    }\r\n\r\n    public String getCompanySize() {\r\n        return companySize;\r\n    }\r\n\r\n    public void setCompanySize(String companySize) {\r\n        this.companySize = companySize;\r\n    }\r\n\r\n    public String getIndustry() {\r\n        return industry;\r\n    }\r\n\r\n    public void setIndustry(String industry) {\r\n        this.industry = industry;\r\n    }\r\n\r\n    public String getRemarks() {\r\n        return remarks;\r\n    }\r\n\r\n    public void setRemarks(String remarks) {\r\n        this.remarks = remarks;\r\n    }\r\n\r\n    public Integer getState() {\r\n        return state;\r\n    }\r\n\r\n    public void setState(Integer state) {\r\n        this.state = state;\r\n    }\r\n\r\n    public String getCity() {\r\n        return city;\r\n    }\r\n\r\n    public void setCity(String city) {\r\n        this.city = city;\r\n    }\r\n}\r\n```\r\n\r\n2：创建dao：com.itheima.dao.store.CompanyDao\r\n\r\n```java\r\npublic interface CompanyDao {\r\n\r\n    int save(Company company);\r\n\r\n    int delete(Company company);\r\n\r\n    int update(Company company);\r\n\r\n    Company findById(String id);\r\n\r\n    List<Company> findAll();\r\n\r\n}\r\n```\r\n\r\n3：从今日课程资料中找到：dao层资源文件---------拷贝配置文件下的资源到项目resources目录下\r\n\r\n4：在项目resources目录下创建一个目录：com\\itheima\\dao\\store，然后把CompanyDao.xml配置文件放到该目录中\r\n\r\n5：从今日课程资料中找到：dao层资源文件----------拷贝工具类下的资源到项目中的utils包和factory包下；注意别放错位置\r\n\r\n\r\n\r\n**总结**：\r\n\r\n![](web综合案例-day01.assets/12.png)\r\n\r\n\r\n\r\n### 3.2 业务层开发\r\n\r\n业务层基础功能：\r\n\r\n增\r\n\r\n删\r\n\r\n改\r\n\r\n查单个\r\n\r\n查全部\r\n\r\n分页查（分页插件）\r\n\r\n\r\n\r\n我们依次来实现\r\n\r\n1：创建业务层接口：com.itheima.service.store.CompanyService\r\n\r\n```java\r\npublic interface CompanyService {\r\n\r\n    /**\r\n     * 添加\r\n     * @param company\r\n     * @return\r\n     */\r\n    void save(Company company);\r\n\r\n    /**\r\n     * 删除\r\n     * @param company\r\n     * @return\r\n     */\r\n    void delete(Company company);\r\n\r\n    /**\r\n     * 修改\r\n     * @param company\r\n     * @return\r\n     */\r\n    void update(Company company);\r\n\r\n    /**\r\n     * 查询单个\r\n     * @param id 查询的条件（id）\r\n     * @return 查询的结果，单个对象\r\n     */\r\n    Company findById(String id);\r\n\r\n    /**\r\n     * 查询全部的数据\r\n     * @return 全部数据的列表对象\r\n     */\r\n    List<Company> findAll();\r\n\r\n    /**\r\n     * 分页查询数据\r\n     * @param page 页码\r\n     * @param size 每页显示的数据总量\r\n     * @return\r\n     */\r\n    PageInfo findAll(int page,int size);\r\n\r\n}\r\n```\r\n\r\n2：创建业务层实现类：com.itheima.service.store.impl.CompanyServiceImpl\r\n\r\n```java\r\npublic class CompanyServiceImpl implements CompanyService {\r\n    @Override\r\n    public void save(Company company) {\r\n        SqlSession sqlSession = null;\r\n        try{\r\n            //1.获取SqlSession\r\n            sqlSession = MapperFactory.getSqlSession();\r\n            //2.获取Dao\r\n            CompanyDao companyDao = MapperFactory.getMapper(sqlSession,CompanyDao.class);\r\n            //id使用UUID的生成策略来获取\r\n            String id = UUID.randomUUID().toString();\r\n            company.setId(id);\r\n            //3.调用Dao层操作\r\n            companyDao.save(company);\r\n            //4.提交事务\r\n            TransactionUtil.commit(sqlSession);\r\n        }catch (Exception e){\r\n            TransactionUtil.rollback(sqlSession);\r\n            throw new RuntimeException(e);\r\n            //记录日志\r\n        }finally {\r\n            try {\r\n                TransactionUtil.close(sqlSession);\r\n            }catch (Exception e){\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void delete(Company company) {\r\n        SqlSession sqlSession = null;\r\n        try{\r\n            //1.获取SqlSession\r\n            sqlSession = MapperFactory.getSqlSession();\r\n            //2.获取Dao\r\n            CompanyDao companyDao = MapperFactory.getMapper(sqlSession,CompanyDao.class);\r\n            //3.调用Dao层操作\r\n            companyDao.delete(company);\r\n            //4.提交事务\r\n            TransactionUtil.commit(sqlSession);\r\n        }catch (Exception e){\r\n            TransactionUtil.rollback(sqlSession);\r\n            throw new RuntimeException(e);\r\n            //记录日志\r\n        }finally {\r\n            try {\r\n                TransactionUtil.close(sqlSession);\r\n            }catch (Exception e){\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void update(Company company) {\r\n        SqlSession sqlSession = null;\r\n        try{\r\n            //1.获取SqlSession\r\n            sqlSession = MapperFactory.getSqlSession();\r\n            //2.获取Dao\r\n            CompanyDao companyDao = MapperFactory.getMapper(sqlSession,CompanyDao.class);\r\n            //3.调用Dao层操作\r\n            companyDao.update(company);\r\n            //4.提交事务\r\n            TransactionUtil.commit(sqlSession);\r\n        }catch (Exception e){\r\n            TransactionUtil.rollback(sqlSession);\r\n            throw new RuntimeException(e);\r\n            //记录日志\r\n        }finally {\r\n            try {\r\n                TransactionUtil.close(sqlSession);\r\n            }catch (Exception e){\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public Company findById(String id) {\r\n        SqlSession sqlSession = null;\r\n        try{\r\n            //1.获取SqlSession\r\n            sqlSession = MapperFactory.getSqlSession();\r\n            //2.获取Dao\r\n            CompanyDao companyDao = MapperFactory.getMapper(sqlSession,CompanyDao.class);\r\n            //3.调用Dao层操作\r\n            return companyDao.findById(id);\r\n        }catch (Exception e){\r\n            throw new RuntimeException(e);\r\n            //记录日志\r\n        }finally {\r\n            try {\r\n                TransactionUtil.close(sqlSession);\r\n            }catch (Exception e){\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public List<Company> findAll() {\r\n        SqlSession sqlSession = null;\r\n        try{\r\n            //1.获取SqlSession\r\n            sqlSession = MapperFactory.getSqlSession();\r\n            //2.获取Dao\r\n            CompanyDao companyDao = MapperFactory.getMapper(sqlSession,CompanyDao.class);\r\n            //3.调用Dao层操作\r\n            return companyDao.findAll();\r\n        }catch (Exception e){\r\n            throw new RuntimeException(e);\r\n            //记录日志\r\n        }finally {\r\n            try {\r\n                TransactionUtil.close(sqlSession);\r\n            }catch (Exception e){\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public PageInfo findAll(int page, int size) {\r\n        SqlSession sqlSession = null;\r\n        try{\r\n            //1.获取SqlSession\r\n            sqlSession = MapperFactory.getSqlSession();\r\n            //2.获取Dao\r\n            CompanyDao companyDao = MapperFactory.getMapper(sqlSession,CompanyDao.class);\r\n            //3.调用Dao层操作\r\n            PageHelper.startPage(page,size);\r\n            List<Company> all = companyDao.findAll();\r\n            PageInfo pageInfo = new PageInfo(all);\r\n            return pageInfo;\r\n        }catch (Exception e){\r\n            throw new RuntimeException(e);\r\n            //记录日志\r\n        }finally {\r\n            try {\r\n                TransactionUtil.close(sqlSession);\r\n            }catch (Exception e){\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n3：创建测试类，对业务层方法依次测试，在测试包下创建：com.itheima.service.store.CompanyServiceTest\r\n\r\n```java\r\npublic class CompanyServiceTest {\r\n    private static CompanyService companyService = null;\r\n    @BeforeClass\r\n    public static void init(){\r\n        companyService = new CompanyServiceImpl();\r\n    }\r\n\r\n    @Test\r\n    public void testSave(){\r\n        Company company = new Company();\r\n        company.setName("测试数据");\r\n        companyService.save(company);\r\n    }\r\n\r\n    @Test\r\n    public void testFindAll(){\r\n        PageInfo all = companyService.findAll(1, 100);\r\n        System.out.println(all);\r\n    }\r\n\r\n    @AfterClass\r\n    public static void destory(){\r\n        companyService = null;\r\n    }\r\n\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n### 3.3 表现层列表功能\r\n\r\n功能分析：\r\n\r\n![](web综合案例-day01.assets/13.png)\r\n\r\n1：在今日课程资料中找到：模块页面---------\x3ecompany下的所有页面-----\x3e拷贝并添加到项目`webapp\\pages\\store\\company`目录下，当然后两级目录需要自己新建\r\n\r\n2：在`webapp/pages/home/aside.jsp`中找到企业管理，修改对应的连接为`${ctx}/pages/store/company/list.jsp`\r\n\r\n3：在项目中创建目录：`webapp/pages/common`，从今日课程给大家提供的模块页面中找到：公共页面，将里面的jsp拷贝到刚刚创建好的common目录中\r\n\r\n4：创建Servlet：com.itheima.web.controller.store.company.CompanyServlet\r\n\r\n```java\r\n// uri:/store/company?operation=list\r\n@WebServlet("/store/company")\r\npublic class CompanyServlet extends HttpServlet {\r\n\r\n    @Override\r\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        String operation = request.getParameter("operation");\r\n        if("list".equals(operation)){\r\n            CompanyService companyService = new CompanyServiceImpl();\r\n            PageInfo all = companyService.findAll(1, 100);\r\n            //将数据保存到指定的位置\r\n            request.setAttribute("page",all);\r\n            //跳转页面\r\n            request.getRequestDispatcher("/WEB-INF/pages/store/company/list.jsp").forward(request,response);\r\n        }else if("list".equals(operation)){\r\n\r\n        }else if("list".equals(operation)){\r\n\r\n        }else if("list".equals(operation)){\r\n\r\n        }else if("list".equals(operation)){\r\n\r\n        }else if("list".equals(operation)){\r\n\r\n        }\r\n    }\r\n\r\n    @Override\r\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        this.doGet(request,response);\r\n    }\r\n}\r\n```\r\n\r\n5：将项目webapp下的pages目录拷贝到WEB-INF目录，并删除home目录，然后删除原本webapp/pages目录下的common及store目录\r\n\r\n6：找到`webapp/pages/home/aside.jsp`中的企业管理，修改连接为`${ctx}/store/company?operation=list`\r\n\r\n7：在页面中进行数据渲染，找到`WEB-INF/pages/store/compay/list.jsp`，填充数据区，注意页面中已经写好了\r\n\r\n```jsp\r\n\x3c!--数据列表--\x3e\r\n<table id="dataList" class="table table-bordered table-striped table-hover dataTable">\r\n    <thead>\r\n        <tr>\r\n            <th class="" style="padding-right:0px;">\r\n\r\n            </th>\r\n            <th class="sorting">企业名称</th>\r\n            <th class="sorting">所在地</th>\r\n            <th class="sorting">地址</th>\r\n            <th class="sorting">企业法人</th>\r\n            <th class="sorting">联系方式</th>\r\n            <th class="sorting">所属行业</th>\r\n            <th class="sorting">状态</th>\r\n            <th class="text-center">操作</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <c:forEach items="${page.list}" var="item">\r\n            <tr>\r\n                <td><input name="ids" value="${item.id}" type="checkbox"></td>\r\n                <td>\r\n                    ${item.name}\r\n                </td>\r\n                <td>${item.city}</td>\r\n                <td>${item.address}</td>\r\n                <td>${item.representative}</td>\r\n                <td>${item.phone}</td>\r\n                <td>${item.industry}</td>\r\n                <td>${item.state ==0?\'未审核\':\'已审核\'}</td>\r\n                <td class="text-center">\r\n                    <button type="button" class="btn bg-olive btn-xs" onclick=\'location.href="${ctx}/store/company?operation=toEdit&id=${item.id}"\'>编辑</button>\r\n                </td>\r\n            </tr>\r\n        </c:forEach>\r\n    </tbody>\r\n</table>\r\n```\r\n\r\n8：优化doGost方法，添加分页控制\r\n\r\n```java\r\n@Override\r\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n    String operation = request.getParameter("operation");\r\n    if("list".equals(operation)){\r\n        CompanyService companyService = new CompanyServiceImpl();\r\n        int page = 1;\r\n        int size = 5;\r\n        if(StringUtils.isNotBlank(request.getParameter("page"))){\r\n            page = Integer.parseInt(request.getParameter("page"));\r\n        }\r\n        if(StringUtils.isNotBlank(request.getParameter("size"))){\r\n            size = Integer.parseInt(request.getParameter("size"));\r\n        }\r\n        PageInfo all = companyService.findAll(page, size);\r\n        //将数据保存到指定的位置\r\n        request.setAttribute("page",all);\r\n        //跳转页面\r\n        request.getRequestDispatcher("/WEB-INF/pages/store/company/list.jsp").forward(request,response);\r\n    }else if("list".equals(operation)){\r\n\r\n    }else if("list".equals(operation)){\r\n\r\n    }else if("list".equals(operation)){\r\n\r\n    }else if("list".equals(operation)){\r\n\r\n    }else if("list".equals(operation)){\r\n\r\n    }\r\n}\r\n```\r\n\r\n### 3.4 表现层添加功能\r\n\r\n1：为了应对更多的方法，我们进行方法抽取\r\n\r\n```java\r\n// uri:/store/company?operation=list\r\n@WebServlet("/store/company")\r\npublic class CompanyServlet extends HttpServlet {\r\n\r\n    @Override\r\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        String operation = request.getParameter("operation");\r\n        if("list".equals(operation)){\r\n            this.list(request,response);\r\n        }else if("toAdd".equals(operation)){\r\n            this.toAdd(request,response);\r\n        }else if("save".equals(operation)){\r\n            this.save(request, response);\r\n        }\r\n    }\r\n\r\n    private void list(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {\r\n        //进入列表页\r\n        //获取数据\r\n        CompanyService companyService = new CompanyServiceImpl();\r\n        int page = 1;\r\n        int size = 5;\r\n        if(StringUtils.isNotBlank(request.getParameter("page"))){\r\n            page = Integer.parseInt(request.getParameter("page"));\r\n        }\r\n        if(StringUtils.isNotBlank(request.getParameter("size"))){\r\n            size = Integer.parseInt(request.getParameter("size"));\r\n        }\r\n        PageInfo all = companyService.findAll(page, size);\r\n        //将数据保存到指定的位置\r\n        request.setAttribute("page",all);\r\n        //跳转页面\r\n        request.getRequestDispatcher("/WEB-INF/pages/store/company/list.jsp").forward(request,response);\r\n    }\r\n\r\n    private void toAdd(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {\r\n        //跳转页面\r\n        request.getRequestDispatcher("/WEB-INF/pages/store/company/add.jsp").forward(request,response);\r\n    }\r\n\r\n    private void save(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {\r\n      \r\n    }\r\n\r\n    @Override\r\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        this.doGet(request,response);\r\n    }\r\n}\r\n```\r\n\r\n2：编辑`/WEB-INF/pages/store/company/add.jsp`页面（无需修改）\r\n\r\n3：从课程资料中找到：web层资源文件，在里面找到：`BeanUtil.java`拷贝到项目utils包下\r\n\r\n4：编写save方法，完成数据的保存\r\n\r\n```java\r\nprivate void save(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {\r\n    //将数据获取到，封装成一个对象\r\n    Company company = BeanUtil.fillBean(request,Company.class,"yyyy-MM-dd");\r\n    //调用业务层接口save\r\n    CompanyService companyService = new CompanyServiceImpl();\r\n    companyService.save(company);\r\n    //跳转回到页面list\r\n    //list(request,response);\r\n    response.sendRedirect(request.getContextPath()+"/store/company?operation=list");\r\n}\r\n```\r\n\r\n### 3.5 表现层删除修改功能\r\n\r\n修改和保存差异不大，一个是做save，一个是做update，\r\n\r\n1：在doGet方法添加去到修改页面和真正修改的两个方法\r\n\r\n```java\r\n@Override\r\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n    String operation = request.getParameter("operation");\r\n    if("list".equals(operation)){\r\n        this.list(request,response);\r\n    }else if("toAdd".equals(operation)){\r\n        this.toAdd(request,response);\r\n    }else if("save".equals(operation)){\r\n        this.save(request, response);\r\n    }else if("toEdit".equals(operation)){\r\n        this.toEdit(request,response);\r\n    }else if("edit".equals(operation)){\r\n        this.edit(request,response);\r\n    }\r\n}\r\n\r\nprivate void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        //查询要修改的数据findById\r\n        String id = request.getParameter("id");\r\n        CompanyService companyService = new CompanyServiceImpl();\r\n        Company company = companyService.findById(id);\r\n        //将数据加载到指定区域，供页面获取\r\n        request.setAttribute("company",company);\r\n        //跳转页面\r\n        request.getRequestDispatcher("/WEB-INF/pages/store/company/update.jsp").forward(request,response);\r\n    }\r\n\r\n    private void edit(HttpServletRequest request, HttpServletResponse response) throws IOException {\r\n        //将数据获取到，封装成一个对象\r\n        Company company = BeanUtil.fillBean(request,Company.class,"yyyy-MM-dd");\r\n        //调用业务层接口save\r\n        CompanyService companyService = new CompanyServiceImpl();\r\n        companyService.update(company);\r\n        //跳转回到页面list\r\n        //list(request,response);\r\n        response.sendRedirect(request.getContextPath()+"/store/company?operation=list");\r\n    }\r\n```\r\n\r\n2：删除功能后台相对简单，主要是前台对要删除数据的id如何获取，对于后台，在doGet方法中添加对删除操作的判断，并添加删除方法\r\n\r\n```java\r\n@Override\r\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n    String operation = request.getParameter("operation");\r\n    if("list".equals(operation)){\r\n        this.list(request,response);\r\n    }else if("toAdd".equals(operation)){\r\n        this.toAdd(request,response);\r\n    }else if("save".equals(operation)){\r\n        this.save(request, response);\r\n    }else if("toEdit".equals(operation)){\r\n        this.toEdit(request,response);\r\n    }else if("edit".equals(operation)){\r\n        this.edit(request,response);\r\n    }else if("delete".equals(operation)){\r\n        this.delete(request,response);\r\n    }\r\n}\r\n\r\nprivate void delete(HttpServletRequest request, HttpServletResponse response) throws IOException {\r\n    //将数据获取到，封装成一个对象\r\n    Company company = BeanUtil.fillBean(request,Company.class);\r\n    //调用业务层接口save\r\n    //        CompanyService companyService = new CompanyServiceImpl();\r\n    companyService.delete(company);\r\n    //跳转回到页面list\r\n    //list(request,response);\r\n    response.sendRedirect(request.getContextPath()+"/store/company?operation=list");\r\n}\r\n```\r\n\r\n\r\n\r\n3：代码优化，在所有的操作方法中我们要调用业务层，我们都要去创建业务层对象，每个方法中都去创建略显复杂，怎么办？\r\n\r\n创建一个BaseServlet：com.itheima.web.controller.BaseServlet\r\n\r\n```java\r\npublic class BaseServlet extends HttpServlet {\r\n    protected CompanyService companyService;\r\n\r\n    @Override\r\n    public void init() throws ServletException {\r\n        companyService = new CompanyServiceImpl();\r\n    }\r\n}\r\n```\r\n\r\n4：修改`CompanyServlet`让其继承自`BaseServlet`，然后在各个方法中注释掉业务层对象创建的代码，完整的`CompanyServlet`如下\r\n\r\n```java\r\n// uri:/store/company?operation=list\r\n@WebServlet("/store/company")\r\npublic class CompanyServlet extends BaseServlet {\r\n\r\n    @Override\r\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        String operation = request.getParameter("operation");\r\n        if("list".equals(operation)){\r\n            this.list(request,response);\r\n        }else if("toAdd".equals(operation)){\r\n            this.toAdd(request,response);\r\n        }else if("save".equals(operation)){\r\n            this.save(request, response);\r\n        }else if("toEdit".equals(operation)){\r\n            this.toEdit(request,response);\r\n        }else if("edit".equals(operation)){\r\n            this.edit(request,response);\r\n        }else if("delete".equals(operation)){\r\n            this.delete(request,response);\r\n        }\r\n    }\r\n\r\n    private void list(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {\r\n        //进入列表页\r\n        //获取数据\r\n//        CompanyService companyService = new CompanyServiceImpl();\r\n        int page = 1;\r\n        int size = 5;\r\n        if(StringUtils.isNotBlank(request.getParameter("page"))){\r\n            page = Integer.parseInt(request.getParameter("page"));\r\n        }\r\n        if(StringUtils.isNotBlank(request.getParameter("size"))){\r\n            size = Integer.parseInt(request.getParameter("size"));\r\n        }\r\n        PageInfo all = companyService.findAll(page, size);\r\n        //将数据保存到指定的位置\r\n        request.setAttribute("page",all);\r\n        //跳转页面\r\n        request.getRequestDispatcher("/WEB-INF/pages/store/company/list.jsp").forward(request,response);\r\n    }\r\n\r\n    private void toAdd(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {\r\n        //跳转页面\r\n        request.getRequestDispatcher("/WEB-INF/pages/store/company/add.jsp").forward(request,response);\r\n    }\r\n\r\n    private void save(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {\r\n        //将数据获取到，封装成一个对象\r\n        Company company = BeanUtil.fillBean(request,Company.class,"yyyy-MM-dd");\r\n        //调用业务层接口save\r\n//        CompanyService companyService = new CompanyServiceImpl();\r\n        companyService.save(company);\r\n        //跳转回到页面list\r\n        //list(request,response);\r\n        response.sendRedirect(request.getContextPath()+"/store/company?operation=list");\r\n    }\r\n\r\n    private void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        //查询要修改的数据findById\r\n        String id = request.getParameter("id");\r\n//        CompanyService companyService = new CompanyServiceImpl();\r\n        Company company = companyService.findById(id);\r\n        //将数据加载到指定区域，供页面获取\r\n        request.setAttribute("company",company);\r\n        //跳转页面\r\n        request.getRequestDispatcher("/WEB-INF/pages/store/company/update.jsp").forward(request,response);\r\n    }\r\n\r\n    private void edit(HttpServletRequest request, HttpServletResponse response) throws IOException {\r\n        //将数据获取到，封装成一个对象\r\n        Company company = BeanUtil.fillBean(request,Company.class,"yyyy-MM-dd");\r\n        //调用业务层接口save\r\n//        CompanyService companyService = new CompanyServiceImpl();\r\n        companyService.update(company);\r\n        //跳转回到页面list\r\n        //list(request,response);\r\n        response.sendRedirect(request.getContextPath()+"/store/company?operation=list");\r\n    }\r\n\r\n    private void delete(HttpServletRequest request, HttpServletResponse response) throws IOException {\r\n        //将数据获取到，封装成一个对象\r\n        Company company = BeanUtil.fillBean(request,Company.class);\r\n        //调用业务层接口save\r\n//        CompanyService companyService = new CompanyServiceImpl();\r\n        companyService.delete(company);\r\n        //跳转回到页面list\r\n        //list(request,response);\r\n        response.sendRedirect(request.getContextPath()+"/store/company?operation=list");\r\n    }\r\n\r\n    @Override\r\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        this.doGet(request,response);\r\n    }\r\n}\r\n```\r\n\r\n## 4. 部门模块\r\n\r\n对于部门，我们要弄清楚的部门的结构\r\n\r\n![](web综合案例-day01.assets/14.png)\r\n\r\n### 4.1 部门模块单表开发\r\n\r\n1：创建实体：com.itheima.domain.system.Dept\r\n\r\n```java\r\npublic class Dept {\r\n    private String id;\r\n    private String deptName;\r\n    private String parentId;\r\n    private Integer state;\r\n\r\n    public String getId() {\r\n        return id;\r\n    }\r\n\r\n    public void setId(String id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public String getDeptName() {\r\n        return deptName;\r\n    }\r\n\r\n    public void setDeptName(String deptName) {\r\n        this.deptName = deptName;\r\n    }\r\n\r\n    public String getParentId() {\r\n        return parentId;\r\n    }\r\n\r\n    public void setParentId(String parentId) {\r\n        this.parentId = parentId;\r\n    }\r\n\r\n    public Integer getState() {\r\n        return state;\r\n    }\r\n\r\n    public void setState(Integer state) {\r\n        this.state = state;\r\n    }\r\n}\r\n```\r\n\r\n2：在`src/main/resources`下创建目录`com/itheima/dao/system`，找到课程资料的`dao层资源文件\\配置文件\\DeptDao.xml`，拷贝到该目录下\r\n\r\n3：创建dao接口：com.itheima.dao.system.DeptDao\r\n\r\n```java\r\npublic interface DeptDao {\r\n    int save(Dept dept);\r\n\r\n    int delete(Dept dept);\r\n\r\n    int update(Dept dept);\r\n\r\n    Dept findById(String id);\r\n\r\n    List<Dept> findAll();\r\n\r\n}\r\n```\r\n\r\n4：创建业务层接口：com.itheima.service.system.DeptService\r\n\r\n```java\r\npublic interface DeptService {\r\n    /**\r\n     * 添加\r\n     * @param dept\r\n     * @return\r\n     */\r\n    void save(Dept dept);\r\n\r\n    /**\r\n     * 删除\r\n     * @param dept\r\n     * @return\r\n     */\r\n    void delete(Dept dept);\r\n\r\n    /**\r\n     * 修改\r\n     * @param dept\r\n     * @return\r\n     */\r\n    void update(Dept dept);\r\n\r\n    /**\r\n     * 查询单个\r\n     * @param id 查询的条件（id）\r\n     * @return 查询的结果，单个对象\r\n     */\r\n    Dept findById(String id);\r\n\r\n    /**\r\n     * 查询全部的数据\r\n     * @return 全部数据的列表对象\r\n     */\r\n    List<Dept> findAll();\r\n\r\n    /**\r\n     * 分页查询数据\r\n     * @param page 页码\r\n     * @param size 每页显示的数据总量\r\n     * @return\r\n     */\r\n    PageInfo findAll(int page, int size);\r\n}\r\n```\r\n\r\n5：创建业务层实现类：com.itheima.service.system.impl.DeptServiceImpl\r\n\r\n```java\r\npublic class DeptServiceImpl implements DeptService {\r\n    @Override\r\n    public void save(Dept dept) {\r\n        SqlSession sqlSession = null;\r\n        try{\r\n            //1.获取SqlSession\r\n            sqlSession = MapperFactory.getSqlSession();\r\n            //2.获取Dao\r\n            DeptDao deptDao = MapperFactory.getMapper(sqlSession,DeptDao.class);\r\n            //id使用UUID的生成策略来获取\r\n            String id = UUID.randomUUID().toString();\r\n            dept.setId(id);\r\n            //3.调用Dao层操作\r\n            deptDao.save(dept);\r\n            //4.提交事务\r\n            TransactionUtil.commit(sqlSession);\r\n        }catch (Exception e){\r\n            TransactionUtil.rollback(sqlSession);\r\n            throw new RuntimeException(e);\r\n            //记录日志\r\n        }finally {\r\n            try {\r\n                TransactionUtil.close(sqlSession);\r\n            }catch (Exception e){\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void delete(Dept dept) {\r\n        SqlSession sqlSession = null;\r\n        try{\r\n            //1.获取SqlSession\r\n            sqlSession = MapperFactory.getSqlSession();\r\n            //2.获取Dao\r\n            DeptDao deptDao = MapperFactory.getMapper(sqlSession,DeptDao.class);\r\n            //3.调用Dao层操作\r\n            deptDao.delete(dept);\r\n            //4.提交事务\r\n            TransactionUtil.commit(sqlSession);\r\n        }catch (Exception e){\r\n            TransactionUtil.rollback(sqlSession);\r\n            throw new RuntimeException(e);\r\n            //记录日志\r\n        }finally {\r\n            try {\r\n                TransactionUtil.close(sqlSession);\r\n            }catch (Exception e){\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void update(Dept dept) {\r\n        SqlSession sqlSession = null;\r\n        try{\r\n            //1.获取SqlSession\r\n            sqlSession = MapperFactory.getSqlSession();\r\n            //2.获取Dao\r\n            DeptDao deptDao = MapperFactory.getMapper(sqlSession,DeptDao.class);\r\n            //3.调用Dao层操作\r\n            deptDao.update(dept);\r\n            //4.提交事务\r\n            TransactionUtil.commit(sqlSession);\r\n        }catch (Exception e){\r\n            TransactionUtil.rollback(sqlSession);\r\n            throw new RuntimeException(e);\r\n            //记录日志\r\n        }finally {\r\n            try {\r\n                TransactionUtil.close(sqlSession);\r\n            }catch (Exception e){\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public Dept findById(String id) {\r\n        SqlSession sqlSession = null;\r\n        try{\r\n            //1.获取SqlSession\r\n            sqlSession = MapperFactory.getSqlSession();\r\n            //2.获取Dao\r\n            DeptDao deptDao = MapperFactory.getMapper(sqlSession,DeptDao.class);\r\n            //3.调用Dao层操作\r\n            return deptDao.findById(id);\r\n        }catch (Exception e){\r\n            throw new RuntimeException(e);\r\n            //记录日志\r\n        }finally {\r\n            try {\r\n                TransactionUtil.close(sqlSession);\r\n            }catch (Exception e){\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public List<Dept> findAll() {\r\n        SqlSession sqlSession = null;\r\n        try{\r\n            //1.获取SqlSession\r\n            sqlSession = MapperFactory.getSqlSession();\r\n            //2.获取Dao\r\n            DeptDao deptDao = MapperFactory.getMapper(sqlSession,DeptDao.class);\r\n            //3.调用Dao层操作\r\n            return deptDao.findAll();\r\n        }catch (Exception e){\r\n            throw new RuntimeException(e);\r\n            //记录日志\r\n        }finally {\r\n            try {\r\n                TransactionUtil.close(sqlSession);\r\n            }catch (Exception e){\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public PageInfo findAll(int page, int size) {\r\n        SqlSession sqlSession = null;\r\n        try{\r\n            //1.获取SqlSession\r\n            sqlSession = MapperFactory.getSqlSession();\r\n            //2.获取Dao\r\n            DeptDao deptDao = MapperFactory.getMapper(sqlSession,DeptDao.class);\r\n            //3.调用Dao层操作\r\n            PageHelper.startPage(page,size);\r\n            List<Dept> all = deptDao.findAll();\r\n            PageInfo pageInfo = new PageInfo(all);\r\n            return pageInfo;\r\n        }catch (Exception e){\r\n            throw new RuntimeException(e);\r\n            //记录日志\r\n        }finally {\r\n            try {\r\n                TransactionUtil.close(sqlSession);\r\n            }catch (Exception e){\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n6：创建Servlet：com.itheima.web.controller.system.DeptServlet\r\n\r\n```java\r\n// uri:/system/dept?operation=list\r\n@WebServlet("/system/dept")\r\npublic class DeptServlet extends BaseServlet {\r\n\r\n    @Override\r\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        String operation = request.getParameter("operation");\r\n        if("list".equals(operation)){\r\n            this.list(request,response);\r\n        }else if("toAdd".equals(operation)){\r\n            this.toAdd(request,response);\r\n        }else if("save".equals(operation)){\r\n            this.save(request, response);\r\n        }else if("toEdit".equals(operation)){\r\n            this.toEdit(request,response);\r\n        }else if("edit".equals(operation)){\r\n            this.edit(request,response);\r\n        }else if("delete".equals(operation)){\r\n            this.delete(request,response);\r\n        }\r\n    }\r\n\r\n    private void list(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {\r\n        //进入列表页\r\n        //获取数据\r\n        int page = 1;\r\n        int size = 5;\r\n        if(StringUtils.isNotBlank(request.getParameter("page"))){\r\n            page = Integer.parseInt(request.getParameter("page"));\r\n        }\r\n        if(StringUtils.isNotBlank(request.getParameter("size"))){\r\n            size = Integer.parseInt(request.getParameter("size"));\r\n        }\r\n        PageInfo all = deptService.findAll(page, size);\r\n        //将数据保存到指定的位置\r\n        request.setAttribute("page",all);\r\n        //跳转页面\r\n        request.getRequestDispatcher("/WEB-INF/pages/system/dept/list.jsp").forward(request,response);\r\n    }\r\n\r\n    private void toAdd(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {\r\n        //跳转页面\r\n        request.getRequestDispatcher("/WEB-INF/pages/system/dept/add.jsp").forward(request,response);\r\n    }\r\n\r\n    private void save(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {\r\n        //将数据获取到，封装成一个对象\r\n        Dept dept = BeanUtil.fillBean(request,Dept.class,"yyyy-MM-dd");\r\n        //调用业务层接口save\r\n//        DeptService deptService = new DeptServiceImpl();\r\n        deptService.save(dept);\r\n        //跳转回到页面list\r\n        //list(request,response);\r\n        response.sendRedirect(request.getContextPath()+"/system/dept?operation=list");\r\n    }\r\n\r\n    private void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        //查询要修改的数据findById\r\n        String id = request.getParameter("id");\r\n//        DeptService deptService = new DeptServiceImpl();\r\n        Dept dept = deptService.findById(id);\r\n        //将数据加载到指定区域，供页面获取\r\n        request.setAttribute("dept",dept);\r\n        //跳转页面\r\n        request.getRequestDispatcher("/WEB-INF/pages/system/dept/update.jsp").forward(request,response);\r\n    }\r\n\r\n    private void edit(HttpServletRequest request, HttpServletResponse response) throws IOException {\r\n        //将数据获取到，封装成一个对象\r\n        Dept dept = BeanUtil.fillBean(request,Dept.class,"yyyy-MM-dd");\r\n        //调用业务层接口save\r\n//        DeptService deptService = new DeptServiceImpl();\r\n        deptService.update(dept);\r\n        //跳转回到页面list\r\n        //list(request,response);\r\n        response.sendRedirect(request.getContextPath()+"/system/dept?operation=list");\r\n    }\r\n\r\n    private void delete(HttpServletRequest request, HttpServletResponse response) throws IOException {\r\n        //将数据获取到，封装成一个对象\r\n        Dept dept = BeanUtil.fillBean(request,Dept.class);\r\n        //调用业务层接口save\r\n//        DeptService deptService = new DeptServiceImpl();\r\n        deptService.delete(dept);\r\n        //跳转回到页面list\r\n        //list(request,response);\r\n        response.sendRedirect(request.getContextPath()+"/system/dept?operation=list");\r\n    }\r\n\r\n    @Override\r\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        this.doGet(request,response);\r\n    }\r\n}\r\n```\r\n\r\n7：在BaseServlet中添加新的代码，如下\r\n\r\n```java\r\npublic class BaseServlet extends HttpServlet {\r\n    protected CompanyService companyService;\r\n    protected DeptService deptService;\r\n\r\n    @Override\r\n    public void init() throws ServletException {\r\n        companyService = new CompanyServiceImpl();\r\n        deptService = new DeptServiceImpl();\r\n    }\r\n}\r\n```\r\n\r\n8：创建目录`WEB-INF/pages/system/dept`，从`WEB-INF/pages/store/company/`下拷贝`add.jsp,list.jsp,update.jsp`到该目录中\r\n\r\n9：调整上述拷贝过来的`list.jsp`，修改数据表格部分\r\n\r\n```jsp\r\n\x3c!--数据列表--\x3e\r\n<table id="dataList" class="table table-bordered table-striped table-hover dataTable">\r\n    <thead>\r\n        <tr>\r\n            <th class="" style="padding-right:0px;">\r\n                <input type="checkbox" name="selid" onclick="checkAll(\'id\',this)">\r\n            </th>\r\n            <th class="sorting">部门名称</th>\r\n            <th class="sorting">所属部门</th>\r\n            <th class="sorting">状态</th>\r\n            <th class="text-center">操作</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <c:forEach items="${page.list}" var="dept">\r\n            <tr>\r\n                <td><input type="checkbox" name="id" value="${dept.id }"/></td>\r\n                <td>${dept.deptName }</td>\r\n                <td>${dept.parent.deptName }</td>\r\n                <td>${dept.state ==0?\'未启用\':\'使用中\'}</td>\r\n                <th class="text-center">\r\n                    <button type="button" class="btn bg-olive btn-xs" onclick=\'location.href="${ctx}/system/dept?operation=toEdit&id=${dept.id}"\'>编辑</button>\r\n                </th>\r\n            </tr>\r\n        </c:forEach>\r\n    </tbody>\r\n</table>\r\n```\r\n\r\n了解了如何去修改这些页面后，为方便我们的开发：从今日的课程资料中找到：`模块页面\\dept`下的所有页面，用他们替换`WEB-INF/pages/system/dept`下的这些页面即可\r\n\r\n### 4.2 部门自连接\r\n\r\n![](web综合案例-day01.assets/15.png)\r\n\r\n1：在实体中添加自关联的字段，parent\r\n\r\n```java\r\npublic class Dept {\r\n    private String id;\r\n    private String deptName;\r\n    private String parentId;\r\n    private Integer state;\r\n\r\n    private Dept parent;\r\n\r\n    public Dept getParent() {\r\n        return parent;\r\n    }\r\n\r\n    public void setParent(Dept parent) {\r\n        this.parent = parent;\r\n    }\r\n\r\n    //-------其他get/set方法略\r\n}\r\n```\r\n\r\n2：修改映射配置，找到`src/main/resources/com/itheima/dao/system/DeptDao.xml`，添加关联映射\r\n\r\n```xml\r\n\x3c!--配置实体类属性和数据库表中列的对应关系--\x3e\r\n<resultMap id="BaseResultMap" type="com.itheima.domain.system.Dept">\r\n    <id column="dept_id" jdbcType="VARCHAR" property="id"/>\r\n    <result column="dept_name" jdbcType="VARCHAR" property="deptName"/>\r\n    <result column="parent_id" jdbcType="VARCHAR" property="parentId"/>\r\n    <result column="state" jdbcType="DECIMAL" property="state"/>\r\n    \x3c!--关联关系--\x3e\r\n    <association\r\n                 property="parent"\r\n                 javaType="com.itheima.domain.system.Dept"\r\n                 column="parent_id"\r\n                 select="com.itheima.dao.system.DeptDao.findById"\r\n                 />\r\n</resultMap>\r\n```\r\n\r\n3：新建的时候要查询所有部门数据，装载到页面上\r\n\r\n找到：DeptServlet中的toAdd方法，添加查询部门信息的代码\r\n\r\n```java\r\nprivate void toAdd(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {\r\n    //加载所有的部门信息放入到deptList\r\n    List<Dept> all = deptService.findAll();\r\n    request.setAttribute("deptList",all);\r\n    //跳转页面\r\n    request.getRequestDispatcher("/WEB-INF/pages/system/dept/add.jsp").forward(request,response);\r\n}\r\n```\r\n\r\n4：同理找到DeptServlet中的toEdit方法，添加查询部门信息的代码\r\n\r\n```java\r\nprivate void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n    //查询要修改的数据findById\r\n    String id = request.getParameter("id");\r\n    //        DeptService deptService = new DeptServiceImpl();\r\n    Dept dept = deptService.findById(id);\r\n    //加载所有的部门信息放入到deptList\r\n    List<Dept> all = deptService.findAll();\r\n    request.setAttribute("deptList",all);\r\n    //将数据加载到指定区域，供页面获取\r\n    request.setAttribute("dept",dept);\r\n    //跳转页面\r\n    request.getRequestDispatcher("/WEB-INF/pages/system/dept/update.jsp").forward(request,response);\r\n}\r\n```\r\n\r\n\r\n\r\n## 5. 用户模块\r\n\r\n![](web综合案例-day01.assets/16.png)\r\n\r\n1：创建实体：com.itheima.domain.system.User\r\n\r\n```java\r\npublic class User {\r\n    private String id;\r\n    private String email;       //邮箱\r\n    private String userName;    //姓名\r\n    private String password;    //密码\r\n    private Long state;         //状态\r\n    private String gender;      //性别\r\n    private String telephone;   //电话\r\n    private Date birthday;      //出生年月\r\n    private Date joinDate;      //入职时间\r\n    private String deptId;      //部门id\r\n\r\n    private Dept dept;\r\n\r\n    public Dept getDept() {\r\n        return dept;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return "User{" +\r\n                "id=\'" + id + \'\\\'\' +\r\n                ", email=\'" + email + \'\\\'\' +\r\n                ", userName=\'" + userName + \'\\\'\' +\r\n                ", password=\'" + password + \'\\\'\' +\r\n                ", state=" + state +\r\n                ", gender=\'" + gender + \'\\\'\' +\r\n                ", telephone=\'" + telephone + \'\\\'\' +\r\n                ", birthday=" + birthday +\r\n                ", joinDate=" + joinDate +\r\n                ", deptId=\'" + deptId + \'\\\'\' +\r\n                ", dept=" + dept +\r\n                \'}\';\r\n    }\r\n\r\n\t//---------get/set方法略\r\n}\r\n```\r\n\r\n2：创建dao接口：com.itheima.dao.system.UserDao\r\n\r\n```java\r\npublic interface UserDao {\r\n    int save(User user);\r\n\r\n    int delete(User user);\r\n\r\n    int update(User user);\r\n\r\n    User findById(String id);\r\n\r\n    List<User> findAll();\r\n}\r\n```\r\n\r\n3：添加映射配置文件，从今日课程中找到：`dao层资源文件\\配置文件\\UserDao.xml`，拷贝到项目中`src/main/resources/com/itheima/dao/system/`目录下\r\n\r\n4：创建业务层接口：com.itheima.service.system.UserService\r\n\r\n```java\r\npublic interface UserService {\r\n    /**\r\n     * 添加\r\n     * @param user\r\n     * @return\r\n     */\r\n    void save(User user);\r\n\r\n    /**\r\n     * 删除\r\n     * @param user\r\n     * @return\r\n     */\r\n    void delete(User user);\r\n\r\n    /**\r\n     * 修改\r\n     * @param user\r\n     * @return\r\n     */\r\n    void update(User user);\r\n\r\n    /**\r\n     * 查询单个\r\n     * @param id 查询的条件（id）\r\n     * @return 查询的结果，单个对象\r\n     */\r\n    User findById(String id);\r\n\r\n    /**\r\n     * 查询全部的数据\r\n     * @return 全部数据的列表对象\r\n     */\r\n    List<User> findAll();\r\n\r\n    /**\r\n     * 分页查询数据\r\n     * @param page 页码\r\n     * @param size 每页显示的数据总量\r\n     * @return\r\n     */\r\n    PageInfo findAll(int page, int size);\r\n}\r\n```\r\n\r\n5：创建业务层实现类：com.itheima.service.system.impl.UserServiceImpl\r\n\r\n```java\r\npublic class UserServiceImpl implements UserService {\r\n    @Override\r\n    public void save(User user) {\r\n        SqlSession sqlSession = null;\r\n        try{\r\n            //1.获取SqlSession\r\n            sqlSession = MapperFactory.getSqlSession();\r\n            //2.获取Dao\r\n            UserDao userDao = MapperFactory.getMapper(sqlSession,UserDao.class);\r\n            //id使用UUID的生成策略来获取\r\n            String id = UUID.randomUUID().toString();\r\n            user.setId(id);\r\n            //3.调用Dao层操作\r\n            userDao.save(user);\r\n            //4.提交事务\r\n            TransactionUtil.commit(sqlSession);\r\n        }catch (Exception e){\r\n            TransactionUtil.rollback(sqlSession);\r\n            throw new RuntimeException(e);\r\n            //记录日志\r\n        }finally {\r\n            try {\r\n                TransactionUtil.close(sqlSession);\r\n            }catch (Exception e){\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void delete(User user) {\r\n        SqlSession sqlSession = null;\r\n        try{\r\n            //1.获取SqlSession\r\n            sqlSession = MapperFactory.getSqlSession();\r\n            //2.获取Dao\r\n            UserDao userDao = MapperFactory.getMapper(sqlSession,UserDao.class);\r\n            //3.调用Dao层操作\r\n            userDao.delete(user);\r\n            //4.提交事务\r\n            TransactionUtil.commit(sqlSession);\r\n        }catch (Exception e){\r\n            TransactionUtil.rollback(sqlSession);\r\n            throw new RuntimeException(e);\r\n            //记录日志\r\n        }finally {\r\n            try {\r\n                TransactionUtil.close(sqlSession);\r\n            }catch (Exception e){\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void update(User user) {\r\n        SqlSession sqlSession = null;\r\n        try{\r\n            //1.获取SqlSession\r\n            sqlSession = MapperFactory.getSqlSession();\r\n            //2.获取Dao\r\n            UserDao userDao = MapperFactory.getMapper(sqlSession,UserDao.class);\r\n            //3.调用Dao层操作\r\n            userDao.update(user);\r\n            //4.提交事务\r\n            TransactionUtil.commit(sqlSession);\r\n        }catch (Exception e){\r\n            TransactionUtil.rollback(sqlSession);\r\n            throw new RuntimeException(e);\r\n            //记录日志\r\n        }finally {\r\n            try {\r\n                TransactionUtil.close(sqlSession);\r\n            }catch (Exception e){\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public User findById(String id) {\r\n        SqlSession sqlSession = null;\r\n        try{\r\n            //1.获取SqlSession\r\n            sqlSession = MapperFactory.getSqlSession();\r\n            //2.获取Dao\r\n            UserDao userDao = MapperFactory.getMapper(sqlSession,UserDao.class);\r\n            //3.调用Dao层操作\r\n            return userDao.findById(id);\r\n        }catch (Exception e){\r\n            throw new RuntimeException(e);\r\n            //记录日志\r\n        }finally {\r\n            try {\r\n                TransactionUtil.close(sqlSession);\r\n            }catch (Exception e){\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public List<User> findAll() {\r\n        SqlSession sqlSession = null;\r\n        try{\r\n            //1.获取SqlSession\r\n            sqlSession = MapperFactory.getSqlSession();\r\n            //2.获取Dao\r\n            UserDao userDao = MapperFactory.getMapper(sqlSession,UserDao.class);\r\n            //3.调用Dao层操作\r\n            return userDao.findAll();\r\n        }catch (Exception e){\r\n            throw new RuntimeException(e);\r\n            //记录日志\r\n        }finally {\r\n            try {\r\n                TransactionUtil.close(sqlSession);\r\n            }catch (Exception e){\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public PageInfo findAll(int page, int size) {\r\n        SqlSession sqlSession = null;\r\n        try{\r\n            //1.获取SqlSession\r\n            sqlSession = MapperFactory.getSqlSession();\r\n            //2.获取Dao\r\n            UserDao userDao = MapperFactory.getMapper(sqlSession,UserDao.class);\r\n            //3.调用Dao层操作\r\n            PageHelper.startPage(page,size);\r\n            List<User> all = userDao.findAll();\r\n            PageInfo pageInfo = new PageInfo(all);\r\n            return pageInfo;\r\n        }catch (Exception e){\r\n            throw new RuntimeException(e);\r\n            //记录日志\r\n        }finally {\r\n            try {\r\n                TransactionUtil.close(sqlSession);\r\n            }catch (Exception e){\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n6：创建servlet：com.itheima.web.controller.system.UserServlet\r\n\r\n```java\r\n// uri:/system/user?operation=list\r\n@WebServlet("/system/user")\r\npublic class UserServlet extends BaseServlet {\r\n\r\n    @Override\r\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        String operation = request.getParameter("operation");\r\n        if("list".equals(operation)){\r\n            this.list(request,response);\r\n        }else if("toAdd".equals(operation)){\r\n            this.toAdd(request,response);\r\n        }else if("save".equals(operation)){\r\n            this.save(request, response);\r\n        }else if("toEdit".equals(operation)){\r\n            this.toEdit(request,response);\r\n        }else if("edit".equals(operation)){\r\n            this.edit(request,response);\r\n        }else if("delete".equals(operation)){\r\n            this.delete(request,response);\r\n        }\r\n    }\r\n\r\n    private void list(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {\r\n        //进入列表页\r\n        //获取数据\r\n//        UserService userService = new UserServiceImpl();\r\n        int page = 1;\r\n        int size = 5;\r\n        if(StringUtils.isNotBlank(request.getParameter("page"))){\r\n            page = Integer.parseInt(request.getParameter("page"));\r\n        }\r\n        if(StringUtils.isNotBlank(request.getParameter("size"))){\r\n            size = Integer.parseInt(request.getParameter("size"));\r\n        }\r\n        PageInfo all = userService.findAll(page, size);\r\n        //将数据保存到指定的位置\r\n        request.setAttribute("page",all);\r\n        //跳转页面\r\n        request.getRequestDispatcher("/WEB-INF/pages/system/user/list.jsp").forward(request,response);\r\n    }\r\n\r\n    private void toAdd(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {\r\n        //跳转页面\r\n        request.getRequestDispatcher("/WEB-INF/pages/system/user/add.jsp").forward(request,response);\r\n    }\r\n\r\n    private void save(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {\r\n        //将数据获取到，封装成一个对象\r\n        User user = BeanUtil.fillBean(request,User.class,"yyyy-MM-dd");\r\n        //调用业务层接口save\r\n        userService.save(user);\r\n        //跳转回到页面list\r\n        response.sendRedirect(request.getContextPath()+"/system/user?operation=list");\r\n    }\r\n\r\n    private void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        //查询要修改的数据findById\r\n        String id = request.getParameter("id");\r\n        User user = userService.findById(id);\r\n        //将数据加载到指定区域，供页面获取\r\n        request.setAttribute("user",user);\r\n        //查询部门信息\r\n        List<Dept> all = deptService.findAll();\r\n        //放入指定位置\r\n        request.setAttribute("deptList",all);\r\n        //跳转页面\r\n        request.getRequestDispatcher("/WEB-INF/pages/system/user/update.jsp").forward(request,response);\r\n    }\r\n\r\n    private void edit(HttpServletRequest request, HttpServletResponse response) throws IOException {\r\n        //将数据获取到，封装成一个对象\r\n        User user = BeanUtil.fillBean(request,User.class,"yyyy-MM-dd");\r\n        //调用业务层接口save\r\n        userService.update(user);\r\n        //跳转回到页面list\r\n        response.sendRedirect(request.getContextPath()+"/system/user?operation=list");\r\n    }\r\n\r\n    private void delete(HttpServletRequest request, HttpServletResponse response) throws IOException {\r\n        //将数据获取到，封装成一个对象\r\n        User user = BeanUtil.fillBean(request,User.class);\r\n        //调用业务层接口save\r\n        userService.delete(user);\r\n        //跳转回到页面list\r\n        response.sendRedirect(request.getContextPath()+"/system/user?operation=list");\r\n    }\r\n\r\n    @Override\r\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        this.doGet(request,response);\r\n    }\r\n}\r\n```\r\n\r\n7：修改BaseServlet\r\n\r\n```java\r\npublic class BaseServlet extends HttpServlet {\r\n    protected CompanyService companyService;\r\n    protected DeptService deptService;\r\n    protected UserService userService;\r\n\r\n    @Override\r\n    public void init() throws ServletException {\r\n        companyService = new CompanyServiceImpl();\r\n        deptService = new DeptServiceImpl();\r\n        userService = new UserServiceImpl();\r\n    }\r\n}\r\n```\r\n\r\n8：创建`WEB-INF/pages/user`，然后从今日课程资料中找到`模块页面\\user`下的所有页面，拷贝到该目录\r\n\r\n注意：在此处希望大家是自行的拷贝之前dept的页面然后自己修改\r\n\r\n9：新建功能时，去新建页面时需要查询部门信息，修改toAdd方法\r\n\r\n```java\r\nprivate void toAdd(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {\r\n    //查询部门信息\r\n    List<Dept> all = deptService.findAll();\r\n    //放入指定位置\r\n    request.setAttribute("deptList",all);\r\n    //跳转页面\r\n    request.getRequestDispatcher("/WEB-INF/pages/system/user/add.jsp").forward(request,response);\r\n}\r\n```\r\n\r\n10：新建用户时，用户的密码需要加密\r\n\r\n从今日课程资料中找到：`service层资源文件/MD5Util.java`拷贝到项目utils包下\r\n\r\n11：修改业务层代码，找到：save方法，给密码加密完成后再存入数据库\r\n\r\n```java\r\n@Override\r\npublic void save(User user) {\r\n    SqlSession sqlSession = null;\r\n    try{\r\n        //1.获取SqlSession\r\n        sqlSession = MapperFactory.getSqlSession();\r\n        //2.获取Dao\r\n        UserDao userDao = MapperFactory.getMapper(sqlSession,UserDao.class);\r\n        //id使用UUID的生成策略来获取\r\n        String id = UUID.randomUUID().toString();\r\n        user.setId(id);\r\n        //密码必须经过加密处理MD5加密\r\n        user.setPassword(MD5Util.md5(user.getPassword()));\r\n        //3.调用Dao层操作\r\n        userDao.save(user);\r\n        //4.提交事务\r\n        TransactionUtil.commit(sqlSession);\r\n    }catch (Exception e){\r\n        TransactionUtil.rollback(sqlSession);\r\n        throw new RuntimeException(e);\r\n        //记录日志\r\n    }finally {\r\n        try {\r\n            TransactionUtil.close(sqlSession);\r\n        }catch (Exception e){\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n12：修改时，在去修改页面是，需要加载部门信息，找到UseServlet的toEdit方法，\r\n\r\n```java\r\nprivate void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n    //查询要修改的数据findById\r\n    String id = request.getParameter("id");\r\n    User user = userService.findById(id);\r\n    //将数据加载到指定区域，供页面获取\r\n    request.setAttribute("user",user);\r\n    //查询部门信息\r\n    List<Dept> all = deptService.findAll();\r\n    //放入指定位置\r\n    request.setAttribute("deptList",all);\r\n    //跳转页面\r\n    request.getRequestDispatcher("/WEB-INF/pages/system/user/update.jsp").forward(request,response);\r\n}\r\n```\r\n\r\n13：真正在修改时，我们需要在业务层做一些处理，找到用户的业务层实现类，修改update方法\r\n\r\n```java\r\n@Override\r\npublic void update(User user) {\r\n    SqlSession sqlSession = null;\r\n    try{\r\n        //1.获取SqlSession\r\n        sqlSession = MapperFactory.getSqlSession();\r\n        //2.获取Dao\r\n        UserDao userDao = MapperFactory.getMapper(sqlSession,UserDao.class);\r\n\r\n        //方案1：读取现有库中的信息，覆盖现有的数据\r\n        //方案2：修改update语句\r\n        System.out.println(user);\r\n        //3.调用Dao层操作\r\n        userDao.update(user);\r\n        //4.提交事务\r\n        TransactionUtil.commit(sqlSession);\r\n    }catch (Exception e){\r\n        TransactionUtil.rollback(sqlSession);\r\n        throw new RuntimeException(e);\r\n        //记录日志\r\n    }finally {\r\n        try {\r\n            TransactionUtil.close(sqlSession);\r\n        }catch (Exception e){\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n我们采用方案二：找到用户对应的xml配置文件：`UserDao.XML`，找到update标签，做出修改\r\n\r\n```xml\r\n\x3c!--配置全字段更新，当提供的数据为null时，数据库数据会被更新为null--\x3e\r\n<update id="update" parameterType="com.itheima.domain.system.User">\r\n    update ss_user\r\n    set user_name = #{userName,jdbcType=VARCHAR},\r\n    state = #{state,jdbcType=DECIMAL},\r\n    gender = #{gender,jdbcType=CHAR},\r\n    telephone = #{telephone,jdbcType=VARCHAR},\r\n    dept_id = #{deptId,jdbcType=VARCHAR}\r\n    where user_id = #{id,jdbcType=VARCHAR}\r\n</update>\r\n```\r\n\r\n'},2687:function(n,e,t){"use strict";t.r(e),e["default"]='## 认证 (Authentication) 和授权 (Authorization)的区别是什么？\n\n这是一个绝大多数人都会混淆的问题。首先先从读音上来认识这两个名词，很多人都会把它俩的读音搞混，所以我建议你先先去查一查这两个单词到底该怎么读，他们的具体含义是什么。\n\n说简单点就是：\n\n- **认证 (Authentication)：** 你是谁。\n- **授权 (Authorization)：** 你有权限干什么。\n\n稍微正式点（啰嗦点）的说法就是 ：\n\n- **Authentication（认证）** 是验证您的身份的凭据（例如用户名/用户 ID 和密码），通过这个凭据，系统得以知道你就是你，也就是说系统存在你这个用户。所以，Authentication 被称为身份/用户验证。\n- **Authorization（授权）** 发生在 **Authentication（认证）** 之后。授权嘛，光看意思大家应该就明白，它主要掌管我们访问系统的权限。比如有些特定资源只能具有特定权限的人才能访问比如 admin，有些对系统资源操作比如删除、添加、更新只能特定人才具有。\n\n认证 ：\n\n![](basis-of-authority-certification.assets/20210604160908352.png)\n\n授权：\n\n![](basis-of-authority-certification.assets/20210604161032412.png)\n\n这两个一般在我们的系统中被结合在一起使用，目的就是为了保护我们系统的安全性。\n\n## RBAC 模型了解吗？\n\n系统权限控制最常采用的访问控制模型就是 **RBAC 模型** 。\n\n**什么是 RBAC 呢？**\n\nRBAC 即基于角色的权限访问控制（Role-Based Access Control）。这是一种通过角色关联权限，角色同时又关联用户的授权的方式。\n\n简单地说：一个用户可以拥有若干角色，每一个角色又可以被分配若干权限，这样就构造成“用户-角色-权限” 的授权模型。在这种模型中，用户与角色、角色与权限之间构成了多对多的关系，如下图\n\n![RBAC](basis-of-authority-certification.assets/RBAC.png)\n\n**在 RBAC 中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。**\n\n本系统的权限设计相关的表如下（一共 5 张表，2 张用户建立表之间的联系）：\n\n![image-20211101231635088](basis-of-authority-certification.assets/image-20211101231635088.png)\n\n通过这个权限模型，我们可以创建不同的角色并为不同的角色分配不同的权限范围（菜单）。\n\n![](basis-of-authority-certification.assets/权限管理模块.png)\n\n通常来说，如果系统对于权限控制要求比较严格的话，一般都会选择使用 RBAC 模型来做权限控制。\n\n## 什么是 Cookie ? Cookie 的作用是什么?\n\n![](basis-of-authority-certification.assets/20210615162505880.png)\n\n`Cookie` 和 `Session` 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。\n\n维基百科是这样定义 `Cookie` 的：\n\n> `Cookies` 是某些网站为了辨别用户身份而储存在用户本地终端上的数据（通常经过加密）。\n\n简单来说： **`Cookie` 存放在客户端，一般用来保存用户信息**。\n\n下面是 `Cookie` 的一些应用案例：\n\n1. 我们在 `Cookie` 中保存已经登录过的用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了。除此之外，`Cookie` 还能保存用户首选项，主题和其他设置信息。\n2. 使用 `Cookie` 保存 `Session` 或者 `Token` ，向后端发送请求的时候带上 `Cookie`，这样后端就能取到 `Session` 或者 `Token` 了。这样就能记录用户当前的状态了，因为 HTTP 协议是无状态的。\n3. `Cookie` 还可以用来记录和分析用户行为。举个简单的例子你在网上购物的时候，因为 HTTP 协议是没有状态的，如果服务器想要获取你在某个页面的停留状态或者看了哪些商品，一种常用的实现方式就是将这些信息存放在 `Cookie`\n4. ......\n\n## 如何在项目中使用 Cookie 呢？\n\n我这里以 Spring Boot 项目为例。\n\n**1)设置 `Cookie` 返回给客户端**\n\n```java\n@GetMapping("/change-username")\npublic String setCookie(HttpServletResponse response) {\n    // 创建一个 cookie\n    Cookie cookie = new Cookie("username", "Jovan");\n    //设置 cookie过期时间\n    cookie.setMaxAge(7 * 24 * 60 * 60); // expires in 7 days\n    //添加到 response 中\n    response.addCookie(cookie);\n\n    return "Username is changed!";\n}\n```\n\n**2) 使用 Spring 框架提供的 `@CookieValue` 注解获取特定的 cookie 的值**\n\n```java\n@GetMapping("/")\npublic String readCookie(@CookieValue(value = "username", defaultValue = "Atta") String username) {\n    return "Hey! My username is " + username;\n}\n```\n\n**3) 读取所有的 `Cookie` 值**\n\n```java\n@GetMapping("/all-cookies")\npublic String readAllCookies(HttpServletRequest request) {\n\n    Cookie[] cookies = request.getCookies();\n    if (cookies != null) {\n        return Arrays.stream(cookies)\n                .map(c -> c.getName() + "=" + c.getValue()).collect(Collectors.joining(", "));\n    }\n\n    return "No cookies";\n}\n```\n\n更多关于如何在 Spring Boot 中使用 `Cookie` 的内容可以查看这篇文章：[How to use cookies in Spring Boot](https://attacomsian.com/blog/cookies-spring-boot。) 。\n\n## Cookie 和 Session 有什么区别？\n\n**`Session` 的主要作用就是通过服务端记录用户的状态。** 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 `Session` 之后就可以标识这个用户并且跟踪这个用户了。\n\n`Cookie` 数据保存在客户端(浏览器端)，`Session` 数据保存在服务器端。相对来说 `Session` 安全性更高。如果使用 `Cookie` 的一些敏感信息不要写入 `Cookie` 中，最好能将 `Cookie` 信息加密然后使用到的时候再去服务器端解密。\n\n**那么，如何使用 `Session` 进行身份验证？**\n\n## 如何使用 Session-Cookie 方案进行身份验证？\n\n很多时候我们都是通过 `SessionID` 来实现特定的用户，`SessionID` 一般会选择存放在 Redis 中。举个例子：\n\n1. 用户成功登陆系统，然后返回给客户端具有 `SessionID` 的 `Cookie`\n2. 当用户向后端发起请求的时候会把 `SessionID` 带上，这样后端就知道你的身份状态了。\n\n关于这种认证方式更详细的过程如下：\n\n![](basis-of-authority-certification.assets/session-cookie.png)\n\n1. 用户向服务器发送用户名、密码、验证码用于登陆系统。\n2. 服务器验证通过后，服务器为用户创建一个 `Session`，并将 `Session` 信息存储起来。\n3. 服务器向用户返回一个 `SessionID`，写入用户的 `Cookie`。\n4. 当用户保持登录状态时，`Cookie` 将与每个后续请求一起被发送出去。\n5. 服务器可以将存储在 `Cookie` 上的 `SessionID` 与存储在内存中或者数据库中的 `Session` 信息进行比较，以验证用户的身份，返回给用户客户端响应信息的时候会附带用户当前的状态。\n\n使用 `Session` 的时候需要注意下面几个点：\n\n1. 依赖 `Session` 的关键业务一定要确保客户端开启了 `Cookie`。\n2. 注意 `Session` 的过期时间。\n\n另外，Spring Session 提供了一种跨多个应用程序或实例管理用户会话信息的机制。如果想详细了解可以查看下面几篇很不错的文章：\n\n- [Getting Started with Spring Session](https://codeboje.de/spring-Session-tutorial/)\n- [Guide to Spring Session](https://www.baeldung.com/spring-Session)\n- [Sticky Sessions with Spring Session & Redis](https://medium.com/@gvnix/sticky-Sessions-with-spring-Session-redis-bdc6f7438cc3)\n\n## 多服务器节点下 Session-Cookie 方案如何做？\n\nSession-Cookie 方案在单体环境是一个非常好的身份认证方案。但是，当服务器水平拓展成多节点时，Session-Cookie 方案就要面临挑战了。\n\n举个例子：假如我们部署了两份相同的服务 A，B，用户第一次登陆的时候 ，Nginx 通过负载均衡机制将用户请求转发到 A 服务器，此时用户的 Session 信息保存在 A 服务器。结果，用户第二次访问的时候 Nginx 将请求路由到 B 服务器，由于 B 服务器没有保存 用户的 Session 信息，导致用户需要重新进行登陆。\n\n**我们应该如何避免上面这种情况的出现呢？**\n\n有几个方案可供大家参考：\n\n1. 某个用户的所有请求都通过特性的哈希策略分配给同一个服务器处理。这样的话，每个服务器都保存了一部分用户的 Session 信息。服务器宕机，其保存的所有 Session 信息就完全丢失了。\n2. 每一个服务器保存的 Session 信息都是互相同步的，也就是说每一个服务器都保存了全量的 Session 信息。每当一个服务器的 Session 信息发生变化，我们就将其同步到其他服务器。这种方案成本太大，并且，节点越多时，同步成本也越高。\n3. 单独使用一个所有服务器都能访问到的数据节点（比如缓存）来存放 Session 信息。为了保证高可用，数据节点尽量要避免是单点。\n\n## 如果没有 Cookie 的话 Session 还能用吗？\n\n这是一道经典的面试题！\n\n一般是通过 `Cookie` 来保存 `SessionID` ，假如你使用了 `Cookie` 保存 `SessionID` 的方案的话， 如果客户端禁用了 `Cookie`，那么 `Session` 就无法正常工作。\n\n但是，并不是没有 `Cookie` 之后就不能用 `Session` 了，比如你可以将 `SessionID` 放在请求的 `url` 里面`https://javaguide.cn/?Session_id=xxx` 。这种方案的话可行，但是安全性和用户体验感降低。当然，为了你也可以对 `SessionID` 进行一次加密之后再传入后端。\n\n## 为什么 Cookie 无法防止 CSRF 攻击，而 Token 可以？\n\n**CSRF（Cross Site Request Forgery）**一般被翻译为 **跨站请求伪造** 。那么什么是 **跨站请求伪造** 呢？说简单用你的身份去发送一些对你不友好的请求。举个简单的例子：\n\n小壮登录了某网上银行，他来到了网上银行的帖子区，看到一个帖子下面有一个链接写着“科学理财，年盈利率过万”，小壮好奇的点开了这个链接，结果发现自己的账户少了 10000 元。这是这么回事呢？原来黑客在链接中藏了一个请求，这个请求直接利用小壮的身份给银行发送了一个转账请求,也就是通过你的 Cookie 向银行发出请求。\n\n```html\n<a src=http://www.mybank.com/Transfer?bankId=11&money=10000>科学理财，年盈利率过万</>\n```\n\n上面也提到过，进行 `Session` 认证的时候，我们一般使用 `Cookie` 来存储 `SessionId`,当我们登陆后后端生成一个 `SessionId` 放在 Cookie 中返回给客户端，服务端通过 Redis 或者其他存储工具记录保存着这个 `SessionId`，客户端登录以后每次请求都会带上这个 `SessionId`，服务端通过这个 `SessionId` 来标示你这个人。如果别人通过 `Cookie` 拿到了 `SessionId` 后就可以代替你的身份访问系统了。\n\n`Session` 认证中 `Cookie` 中的 `SessionId` 是由浏览器发送到服务端的，借助这个特性，攻击者就可以通过让用户误点攻击链接，达到攻击效果。\n\n但是，我们使用 `Token` 的话就不会存在这个问题，在我们登录成功获得 `Token` 之后，一般会选择存放在 `localStorage` （浏览器本地存储）中。然后我们在前端通过某些方式会给每个发到后端的请求加上这个 `Token`,这样就不会出现 CSRF 漏洞的问题。因为，即使有个你点击了非法链接发送了请求到服务端，这个非法请求是不会携带 `Token` 的，所以这个请求将是非法的。\n\n![](basis-of-authority-certification.assets/20210615161108272.png)\n\n需要注意的是不论是 `Cookie` 还是 `Token` 都无法避免 **跨站脚本攻击（Cross Site Scripting）XSS** 。\n\n> 跨站脚本攻击（Cross Site Scripting）缩写为 CSS 但这会与层叠样式表（Cascading Style Sheets，CSS）的缩写混淆。因此，有人将跨站脚本攻击缩写为 XSS。\n\nXSS 中攻击者会用各种方式将恶意代码注入到其他用户的页面中。就可以通过脚本盗用信息比如 `Cookie` 。\n\n推荐阅读：[如何防止 CSRF 攻击？—美团技术团队](https://tech.meituan.com/2018/10/11/fe-security-csrf.html)\n\n## 什么是 Token?什么是 JWT?\n\n我们在前面的问题中探讨了使用 `Session` 来鉴别用户的身份，并且给出了几个 Spring Session 的案例分享。 我们知道 `Session` 信息需要保存一份在服务器端。这种方式会带来一些麻烦，比如需要我们保证保存 `Session` 信息服务器的可用性、不适合移动端（依赖 `Cookie`）等等。\n\n有没有一种不需要自己存放 `Session` 信息就能实现身份验证的方式呢？使用 `Token` 即可！**JWT** （JSON Web Token） 就是这种方式的实现，通过这种方式服务器端就不需要保存 `Session` 数据了，只用在客户端保存服务端返回给客户的 `Token` 就可以了，扩展性得到提升。\n\n**JWT 本质上就一段签名的 JSON 格式的数据。由于它是带有签名的，因此接收者便可以验证它的真实性。**\n\n下面是 [RFC 7519](https://tools.ietf.org/html/rfc7519) 对 JWT 做的较为正式的定义。\n\n> JSON Web Token (JWT) is a compact, URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or integrity protected with a Message Authentication Code (MAC) and/or encrypted. ——[JSON Web Token (JWT)](https://tools.ietf.org/html/rfc7519)\n\nJWT 由 3 部分构成:\n\n1. **Header** : 描述 JWT 的元数据，定义了生成签名的算法以及 `Token` 的类型。\n2. **Payload** : 用来存放实际需要传递的数据\n3. **Signature（签名）** ：服务器通过`Payload`、`Header`和一个密钥(`secret`)使用 `Header` 里面指定的签名算法（默认是 HMAC SHA256）生成。\n\n## 如何基于 Token 进行身份验证？\n\n在基于 Token 进行身份验证的的应用程序中，服务器通过`Payload`、`Header`和一个密钥(`secret`)创建令牌（`Token`）并将 `Token` 发送给客户端，客户端将 `Token` 保存在 Cookie 或者 localStorage 里面，以后客户端发出的所有请求都会携带这个令牌。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP Header 的 Authorization 字段中：`Authorization: Bearer Token`。\n\n![jwt](basis-of-authority-certification.assets/jwt.png)\n\n1. 用户向服务器发送用户名和密码用于登陆系统。\n2. 身份验证服务响应并返回了签名的 JWT，上面包含了用户是谁的内容。\n3. 用户以后每次向后端发请求都在 `Header` 中带上 JWT。\n4. 服务端检查 JWT 并从中获取用户相关信息。\n\n## 什么是 SSO?\n\nSSO(Single Sign On)即单点登录说的是用户登陆多个子系统的其中一个就有权访问与其相关的其他系统。举个例子我们在登陆了京东金融之后，我们同时也成功登陆京东的京东超市、京东国际、京东生鲜等子系统。\n\n![sso](basis-of-authority-certification.assets/sso.png)\n\n## 什么是 OAuth 2.0？\n\nOAuth 是一个行业的标准授权协议，主要用来授权第三方应用获取有限的权限。而 OAuth 2.0 是对 OAuth 1.0 的完全重新设计，OAuth 2.0 更快，更容易实现，OAuth 1.0 已经被废弃。详情请见：[rfc6749](https://tools.ietf.org/html/rfc6749)。\n\n实际上它就是一种授权机制，它的最终目的是为第三方应用颁发一个有时效性的令牌 Token，使得第三方应用能够通过该令牌获取相关的资源。\n\nOAuth 2.0 比较常用的场景就是第三方登录，当你的网站接入了第三方登录的时候一般就是使用的 OAuth 2.0 协议。\n\n另外，现在 OAuth 2.0 也常见于支付场景（微信支付、支付宝支付）和开发平台（微信开放平台、阿里开放平台等等）。\n\n微信支付账户相关参数：\n\n![](basis-of-authority-certification.assets/微信支付-fnglfdlgdfj.png)\n\n下图是 [Slack OAuth 2.0 第三方登录](https://api.slack.com/legacy/oauth)的示意图：\n\n![](basis-of-authority-certification.assets/20210615151716340.png)\n\n**推荐阅读：**\n\n- [OAuth 2.0 的一个简单解释](http://www.ruanyifeng.com/blog/2019/04/oauth_design.html)\n- [10 分钟理解什么是 OAuth 2.0 协议](https://deepzz.com/post/what-is-oauth2-protocol.html)\n- [OAuth 2.0 的四种方式](http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html)\n- [GitHub OAuth 第三方登录示例教程](http://www.ruanyifeng.com/blog/2019/04/github-oauth.html)\n'},"2a10":function(n,e,t){"use strict";t.r(e),e["default"]="下面这些问题都是一线大厂的真实面试问题，不论是对你面试还是说拓宽知识面都很有帮助。之前发过一篇[8 张图读懂大型网站技术架构](https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484416&idx=1&sn=6ced00d65491ef8fd33151bdfa8895c9&chksm=fd985261caefdb779412974a6a7207c93d0c2da5b28489afb74acd2fee28505daebbadb018ff&token=177958022&lang=zh_CN#rd) 可以作为不太了解大型网站系统技术架构朋友的入门文章。\n\n\x3c!-- MarkdownTOC --\x3e\n\n- [1. 你使用过哪些组件或者方法来提升网站性能,可用性以及并发量](#1-你使用过哪些组件或者方法来提升网站性能可用性以及并发量)\n- [2. 设计高可用系统的常用手段](#2-设计高可用系统的常用手段)\n- [3. 现代互联网应用系统通常具有哪些特点?](#3-现代互联网应用系统通常具有哪些特点)\n- [4. 谈谈你对微服务领域的了解和认识](#4-谈谈你对微服务领域的了解和认识)\n- [5. 谈谈你对 Dubbo 和 Spring Cloud 的认识\\(两者关系\\)](#5-谈谈你对-dubbo-和-spring-cloud-的认识两者关系)\n- [6. 性能测试了解吗?说说你知道的性能测试工具?](#6-性能测试了解吗说说你知道的性能测试工具)\n- [7. 对于一个单体应用系统,随着产品使用的用户越来越多,网站的流量会增加,最终单台服务器无法处理那么大的流量怎么办?](#7-对于一个单体应用系统随着产品使用的用户越来越多网站的流量会增加最终单台服务器无法处理那么大的流量怎么办)\n- [8. 大表优化的常见手段](#8-大表优化的常见手段)\n- [9. 在系统中使用消息队列能带来什么好处?](#9-在系统中使用消息队列能带来什么好处)\n  - [1) 通过异步处理提高系统性能](#1-通过异步处理提高系统性能)\n- [2) 降低系统耦合性](#2-降低系统耦合性)\n- [10. 说说自己对 CAP 定理,BASE 理论的了解](#10-说说自己对-cap-定理base-理论的了解)\n  - [CAP 定理](#cap-定理)\n  - [BASE 理论](#base-理论)\n- [参考](#参考)\n\n\x3c!-- /MarkdownTOC --\x3e\n\n\n### 1. 你使用过哪些组件或者方法来提升网站性能,可用性以及并发量\n\n1. **提高硬件能力、增加系统服务器**。（当服务器增加到某个程度的时候系统所能提供的并发访问量几乎不变，所以不能根本解决问题）\n2. **使用缓存**（本地缓存：本地可以使用JDK自带的 Map、Guava Cache.分布式缓存：Redis、Memcache.本地缓存不适用于提高系统并发量，一般是用在程序中。比如Spring是如何实现单例的呢？大家如果看过源码的话，应该知道，S把已经初始过的变量放在一个Map中，下次再要使用这个变量的时候，先判断Map中有没有，这也就是系统中常见的单例模式的实现。）\n3. **消息队列** （解耦+削峰+异步）\n4. **采用分布式开发** （不同的服务部署在不同的机器节点上，并且一个服务也可以部署在多台机器上，然后利用 Nginx 负载均衡访问。这样就解决了单点部署(All In)的缺点，大大提高的系统并发量）\n5. **数据库分库（读写分离）、分表（水平分表、垂直分表）**\n6. **采用集群** （多台机器提供相同的服务）\n7. **CDN 加速** (将一些静态资源比如图片、视频等等缓存到离用户最近的网络节点)\n8. **浏览器缓存**\n9. **使用合适的连接池**（数据库连接池、线程池等等）\n10. **适当使用多线程进行开发。**\n\n\n### 2. 设计高可用系统的常用手段\n\n1. **降级：** 服务降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。降级往往会指定不同的级别，面临不同的异常等级执行不同的处理。根据服务方式：可以拒接服务，可以延迟服务，也有时候可以随机服务。根据服务范围：可以砍掉某个功能，也可以砍掉某些模块。总之服务降级需要根据不同的业务需求采用不同的降级策略。主要的目的就是服务虽然有损但是总比没有好；\n2. **限流：** 防止恶意请求流量、恶意攻击，或者防止流量超出系统峰值；\n3. **缓存：** 避免大量请求直接落到数据库，将数据库击垮；\n4. **超时和重试机制：** 避免请求堆积造成雪崩；\n5. **回滚机制：** 快速修复错误版本。\n\n\n### 3. 现代互联网应用系统通常具有哪些特点?\n\n1. 高并发，大流量；\n2. 高可用：系统7×24小时不间断服务；\n3. 海量数据：需要存储、管理海量数据，需要使用大量服务器；\n4. 用户分布广泛，网络情况复杂：许多大型互联网都是为全球用户提供服务的，用户分布范围广，各地网络情况千差万别；\n5. 安全环境恶劣：由于互联网的开放性，使得互联网更容易受到攻击，大型网站几乎每天都会被黑客攻击；\n6. 需求快速变更，发布频繁：和传统软件的版本发布频率不同，互联网产品为快速适应市场，满足用户需求，其产品发布频率是极高的；\n7. 渐进式发展：与传统软件产品或企业应用系统一开始就规划好全部的功能和非功能需求不同，几乎所有的大型互联网网站都是从一个小网站开始，渐进地发展起来。\n\n### 4. 谈谈你对微服务领域的了解和认识\n\n现在大公司都在用并且未来的趋势都是 Spring Cloud，而阿里开源的 Spring Cloud Alibaba 也是 Spring Cloud 规范的实现 。\n\n我们通常把 Spring Cloud 理解为一系列开源组件的集合，但是 Spring Cloud并不是等同于 Spring Cloud Netflix 的 Ribbon、Feign、Eureka（停止更新）、Hystrix 这一套组件，而是抽象了一套通用的开发模式。它的目的是通过抽象出这套通用的模式，让开发者更快更好地开发业务。但是这套开发模式运行时的实际载体，还是依赖于 RPC、网关、服务发现、配置管理、限流熔断、分布式链路跟踪等组件的具体实现。\n\nSpring Cloud Alibaba 是官方认证的新一套 Spring Cloud 规范的实现,Spring Cloud Alibaba 是一套国产开源产品集合，后续还会有中文 reference 和一些原理分析文章，所以，这对于国内的开发者是非常棒的一件事。阿里的这一举动势必会推动国内微服务技术的发展，因为在没有 Spring Cloud Alibaba 之前，我们的第一选择是 Spring Cloud Netflix，但是它们的文档都是英文的，出问题后排查也比较困难， 在国内并不是有特别多的人精通。Spring Cloud Alibaba 由阿里开源组件和阿里云产品组件两部分组成，其致力于提供微服务一站式解决方案，方便开发者通过 Spring Cloud 编程模型轻松开发微服务应用。\n\n另外，Apache Dubbo Ecosystem 是围绕 Apache Dubbo 打造的微服务生态，是经过生产验证的微服务的最佳实践组合。在阿里巴巴的微服务解决方案中，Dubbo、Nacos 和 Sentinel，以及后续将开源的微服务组件，都是 Dubbo EcoSystem 的一部分。阿里后续也会将 Dubbo EcoSystem 集成到 Spring Cloud 的生态中。\n\n### 5. 谈谈你对 Dubbo 和 Spring Cloud 的认识(两者关系) \n\n具体可以看公众号-阿里巴巴中间件的这篇文章:[独家解读：Dubbo Ecosystem - 从微服务框架到微服务生态](https://mp.weixin.qq.com/s/iNVctXw7tUGHhnF0hV84ww)\n\nDubbo 与 Spring Cloud 并不是竞争关系，Dubbo 作为成熟的 RPC 框架，其易用性、扩展性和健壮性已得到业界的认可。未来 Dubbo 将会作为 Spring Cloud Alibaba 的 RPC 组件，并与 Spring Cloud 原生的 Feign 以及 RestTemplate 进行无缝整合，实现“零”成本迁移。\n\n在阿里巴巴的微服务解决方案中，Dubbo、Nacos 和 Sentinel，以及后续将开源的微服务组件，都是 Dubbo EcoSystem 的一部分。我们后续也会将 Dubbo EcoSystem 集成到 Spring Cloud 的生态中。\n\n### 6. 性能测试了解吗?说说你知道的性能测试工具?\n\n性能测试指通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。性能测试是总称，通常细分为：\n\n1. **基准测试：** 在给系统施加较低压力时，查看系统的运行状况并记录相关数做为基础参考\n2. **负载测试：** 是指对系统不断地增加压力或增加一定压力下的持续时间，直到系统的某项或多项性能指标达到安全临界值，例如某种资源已经达到饱和状态等 。此时继续加压，系统处理能力会下降。\n3. **压力测试：** 超过安全负载情况下，不断施加压力（增加并发请求），直到系统崩溃或无法处理任何请求，依此获得系统最大压力承受能力。\n4. **稳定性测试：** 被测试系统在特定硬件、软件、网络环境下，加载一定业务压力（模拟生产环境不同时间点、不均匀请求，呈波浪特性）运行一段较长时间，以此检测系统是否稳定。\n\n后端程序员或者测试平常比较常用的测试工具是 JMeter（官网：[https://jmeter.apache.org/](https://jmeter.apache.org/)）。Apache JMeter 是一款基于Java的压力测试工具(100％纯Java应用程序)，旨在加载测试功能行为和测量性能。它最初被设计用于 Web 应用测试但后来扩展到其他测试领域。\n\n### 7. 对于一个单体应用系统,随着产品使用的用户越来越多,网站的流量会增加,最终单台服务器无法处理那么大的流量怎么办?\n\n这个时候就要考虑扩容了。《亿级流量网站架构核心技术》这本书上面介绍到我们可以考虑下面几步来解决这个问题：\n\n- 第一步，可以考虑简单的扩容来解决问题。比如增加系统的服务器，提高硬件能力等等。\n- 第二步，如果简单扩容搞不定，就需要水平拆分和垂直拆分数据／应用来提升系统的伸缩性，即通过扩容提升系统负载能力。\n- 第三步，如果通过水平拆分／垂直拆分还是搞不定，那就需要根据现有系统特性，架构层面进行重构甚至是重新设计，即推倒重来。\n\n对于系统设计，理想的情况下应支持线性扩容和弹性扩容，即在系统瓶颈时，只需要增加机器就可以解决系统瓶颈，如降低延迟提升吞吐量，从而实现扩容需求。\n\n如果你想扩容，则支持水平/垂直伸缩是前提。在进行拆分时，一定要清楚知道自己的目的是什么，拆分后带来的问题如何解决，拆分后如果没有得到任何收益就不要为了\n拆而拆，即不要过度拆分，要适合自己的业务。\n\n### 8. 大表优化的常见手段\n\n   当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：\n\n1. **限定数据的范围：** 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；\n2. **读/写分离：** 经典的数据库拆分方案，主库负责写，从库负责读；\n3. **垂直分区：** **根据数据库里面数据表的相关性进行拆分。** 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。**简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。** 如下图所示，这样来说大家应该就更容易理解了。**垂直拆分的优点：** 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。**垂直拆分的缺点：** 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；\n4. **水平分区：** **保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。** 水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。水平拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 **水平拆分最好分库** 。水平拆分能够 **支持非常大的数据量存储，应用端改造也少**，但 **分片事务难以解决**  ，跨界点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 **尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度** ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。\n\n**下面补充一下数据库分片的两种常见方案：**\n\n- **客户端代理：**  **分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。** 当当网的 **Sharding-JDBC** 、阿里的TDDL是两种比较常用的实现。\n- **中间件代理：** **在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。** 我们现在谈的 **Mycat** 、360的Atlas、网易的DDB等等都是这种架构的实现。\n\n### 9. 在系统中使用消息队列能带来什么好处?\n\n**《大型网站技术架构》第四章和第七章均有提到消息队列对应用性能及扩展性的提升。**\n\n#### 1) 通过异步处理提高系统性能\n\n如上图，**在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。**\n\n通过以上分析我们可以得出**消息队列具有很好的削峰作用的功能**——即**通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。** 举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：\n\n因为**用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败**。因此使用消息队列进行异步处理之后，需要**适当修改业务流程进行配合**，比如**用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功**，以免交易纠纷。这就类似我们平时手机订火车票和电影票。\n\n### 2) 降低系统耦合性\n我们知道模块分布式部署以后聚合方式通常有两种：1.**分布式消息队列**和2.**分布式服务**。\n\n> **先来简单说一下分布式服务：**\n\n目前使用比较多的用来构建**SOA（Service Oriented Architecture面向服务体系结构）**的**分布式服务框架**是阿里巴巴开源的**Dubbo**.如果想深入了解Dubbo的可以看我写的关于Dubbo的这一篇文章：**《高性能优秀的服务框架-dubbo介绍》**：[https://juejin.im/post/5acadeb1f265da2375072f9c](https://juejin.im/post/5acadeb1f265da2375072f9c)\n\n> **再来谈我们的分布式消息队列：**\n\n我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。\n\n我们最常见的**事件驱动架构**类似生产者消费者模式，在大型网站中通常用利用消息队列实现事件驱动结构。如下图所示：\n\n**消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。** 从上图可以看到**消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合**，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。**对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计**。\n\n消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。\n\n**另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。**   \n\n**备注：** 不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的，**比如在我们的ActiveMQ消息队列中还有点对点工作模式**，具体的会在后面的文章给大家详细介绍，这一篇文章主要还是让大家对消息队列有一个更透彻的了解。\n\n> 这个问题一般会在上一个问题问完之后，紧接着被问到。“使用消息队列会带来什么问题？”这个问题要引起重视，一般我们都会考虑使用消息队列会带来的好处而忽略它带来的问题！\n\n### 10. 说说自己对 CAP 定理,BASE 理论的了解\n\n#### CAP 定理\n\n\n在理论计算机科学中，CAP定理（CAP theorem），又被称作布鲁尔定理（Brewer's theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：\n\n- **一致性（Consistence）** :所有节点访问同一份最新的数据副本\n- **可用性（Availability）**:每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据\n- **分区容错性（Partition tolerance）** : 分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。\n\nCAP仅适用于原子读写的NOSQL场景中，并不适合数据库系统。现在的分布式系统具有更多特性比如扩展性、可用性等等，在进行系统设计和开发时，我们不应该仅仅局限在CAP问题上。\n\n**注意：不是所谓的3选2（不要被网上大多数文章误导了）:**\n\n大部分人解释这一定律时，常常简单的表述为：“一致性、可用性、分区容忍性三者你只能同时达到其中两个，不可能同时达到”。实际上这是一个非常具有误导性质的说法，而且在CAP理论诞生12年之后，CAP之父也在2012年重写了之前的论文。\n\n**当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能2选1。也就是说当网络分区之后P是前提，决定了P之后才有C和A的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。**\n\n我在网上找了很多文章想看一下有没有文章提到这个不是所谓的3选2，用百度半天没找到了一篇，用谷歌搜索找到一篇比较不错的，如果想深入学习一下CAP就看这篇文章把，我这里就不多BB了：**《分布式系统之CAP理论》 ：** [https://www.cnblogs.com/hxsyl/p/4381980.html](https://www.cnblogs.com/hxsyl/p/4381980.html)\n\n\n#### BASE 理论\n\n**BASE** 是 **Basically Available（基本可用）** 、**Soft-state（软状态）** 和 **Eventually Consistent（最终一致性）** 三个短语的缩写。BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的，它大大降低了我们对系统的要求。\n\n**BASE理论的核心思想：** 即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。\n\n**BASE理论三要素：**\n\n\n\n1. **基本可用：** 基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。 比如： **①响应时间上的损失**:正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒；**②系统功能上的损失**：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面；\n2. **软状态：** 软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时；\n3. **最终一致性：** 最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。\n\n### 参考\n\n- 《大型网站技术架构》\n- 《亿级流量网站架构核心技术》\n- 《Java工程师修炼之道》\n-  https://www.cnblogs.com/puresoul/p/5456855.html\n"},"2a54":function(n,e,t){"use strict";t.r(e),e["default"]='\x3c!--\n * @Date           : 2021-04-14 00:54:32\n * @FilePath       : /jinnian-space/src/pages/java/module/mybatis/md/mybatis-第2天讲义.md\n * @Description    : \n--\x3e\n## Mybatis 进阶\n\n\n### 一.接口代理方式实现Dao\n\n#### 1.1 代理开发方式介绍\n\n​\t采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是我们后面进入企业的主流。\n\nMapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。\n\nMapper 接口开发需要遵循以下规范：\n\n**1) Mapper.xml文件中的namespace与mapper接口的全限定名相同**\n\n**2) Mapper接口方法名和Mapper.xml中定义的每个statement的id相同**\n\n**3) Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同**\n\n**4) Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同**\n\n总结: \n\n接口开发的方式: 程序员只需定义接口,就可以对数据库进行操作,那么具体的对象怎么创建?\n\n1.程序员负责定义接口\n\n2.在操作数据库,mybatis框架根据接口,通过动态代理的方式生成代理对象,负责数据库的crud操作\n\n#### 1.2.编写StudentMapper接口\n\n![1590937589503](./mybatis-第2天讲义.img/1590937589503.png)\n\n#### 1.3 测试代理方式\n\n```java\n public Student selectById(Integer id) {\n        Student stu = null;\n        SqlSession sqlSession = null;\n        InputStream is = null;\n        try{\n            //1.加载核心配置文件\n            is = Resources.getResourceAsStream("MyBatisConfig.xml");\n\n            //2.获取SqlSession工厂对象\n            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n\n            //3.通过工厂对象获取SqlSession对象\n            sqlSession = sqlSessionFactory.openSession(true);\n\n            //4.获取StudentMapper接口的实现类对象\n            StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); // StudentMapper mapper = new StudentMapperImpl();\n\n            //5.通过实现类对象调用方法，接收结果\n            stu = mapper.selectById(id);\n\n        } catch (Exception e) {\n\n        } finally {\n            //6.释放资源\n            if(sqlSession != null) {\n                sqlSession.close();\n            }\n            if(is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        //7.返回结果\n        return stu;\n    }\n```\n\n#### 1.4 源码分析\n\n* 分析动态代理对象如何生成的？ \n\n  通过动态代理开发模式，我们只编写一个接口，不写实现类，我们通过 getMapper() 方法最终获取到 org.apache.ibatis.binding.MapperProxy 代理对象，然后执行功能，而这个代理对象正是 MyBatis 使用了 JDK 的动态代理技术，帮助我们生成了代理实现类对象。从而可以进行相关持久化操作。 \n\n* 分析方法是如何执行的？\n\n   动态代理实现类对象在执行方法的时候最终调用了 mapperMethod.execute() 方法，这个方法中通过 switch 语句根据操作类型来判断是新增、修改、删除、查询操作，最后一步回到了 MyBatis 最原生的 SqlSession 方式来执行增删改查。    \n\n#### 1.5 知识小结\n\n 接口代理方式可以让我们只编写接口即可，而实现类对象由 MyBatis 生成。 \n\n 实现规则 ：\n\n1. 映射配置文件中的名称空间必须和 Dao 层接口的全类名相同。\n2. 映射配置文件中的增删改查标签的 id 属性必须和 Dao 层接口的方法名相同。 \n3. 映射配置文件中的增删改查标签的 parameterType 属性必须和 Dao 层接口方法的参数相同。 \n4. 映射配置文件中的增删改查标签的 resultType 属性必须和 Dao 层接口方法的返回值相同。 \n5. 获取动态代理对象 SqlSession 功能类中的 getMapper() 方法。    \n\n### 二. 动态sql语句\n\n#### 2.1 动态sql语句概述\n\n​\tMybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL是动态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。\n\n参考的官方文档，描述如下：\n\n![](img\\图片2.png)\n\n#### 2.2 动态 SQL  之<**if>** \n\n我们根据实体类的不同取值，使用不同的 SQL语句来进行查询。比如在 id如果不为空时可以根据id查询，如果username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。\n\n如下图：\n\n```xml\n<select id="findByCondition" parameterType="student" resultType="student">\n    select * from student\n    <where>\n        <if test="id!=0">\n            and id=#{id}\n        </if>\n        <if test="username!=null">\n            and username=#{username}\n        </if>\n    </where>\n</select>\n\n```\n\n当查询条件id和username都存在时，控制台打印的sql语句如下：\n\n```java\n     … … …\n     //获得MyBatis框架生成的StudentMapper接口的实现类\n    StudentMapper mapper = sqlSession.getMapper( StudentMapper.class);\n    Student condition = new Student();\n    condition.setId(1);\n    condition.setUsername("lucy");\n    Student student = mapper.findByCondition(condition);\n    … … …\n```\n\n![1590936579118](./mybatis-第2天讲义.img/1590936579118.png)\n\n\n\n当查询条件只有id存在时，控制台打印的sql语句如下：\n\n```java\n … … …\n //获得MyBatis框架生成的UserMapper接口的实现类\n StudentMapper mapper = sqlSession.getMapper( StudentMapper.class);\n    Student condition = new Student();\n    condition.setId(1);\n    Student student = mapper.findByCondition(condition);\n… … …\n\n```\n\n![1590936654661](./mybatis-第2天讲义.img/1590936654661.png)\n\n总结语法:\n\n~~~xml\n<where>：条件标签。如果有动态条件，则使用该标签代替 where 关键字。\n<if>：条件判断标签。\n<if test=“条件判断”>\n\t查询条件拼接\n</if>\n~~~\n\n\n\n#### 2.3  动态 SQL  之<**foreach>** \n\n循环执行sql的拼接操作，例如：SELECT * FROM student  WHERE id IN (1,2,5)。\n\n ```xml\n<select id="findByIds" parameterType="list" resultType="student">\n    select * from student\n    <where>\n        <foreach collection="array" open="id in(" close=")" item="id" separator=",">\n            #{id}\n        </foreach>\n    </where>\n</select>\n ```\n\n测试代码片段如下：\n\n```java\n … … …\n //获得MyBatis框架生成的UserMapper接口的实现类\nStudentMapper mapper = sqlSession.getMapper(StudentMapper.class);\nint[] ids = new int[]{2,5};\nList<Student> sList = mapper.findByIds(ids);\nSystem.out.println(sList);\n… … …\n\n```\n\n总结语法:\n\n~~~xml\n<foreach>：循环遍历标签。适用于多个参数或者的关系。\n    <foreach collection=“”open=“”close=“”item=“”separator=“”>\n\t\t获取参数\n\t</foreach>\n~~~\n\n属性\ncollection：参数容器类型， (list-集合， array-数组)。\nopen：开始的 SQL 语句。\nclose：结束的 SQL 语句。\nitem：参数变量名。\nseparator：分隔符。\n\n#### 2.4  SQL片段抽取\n\nSql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的\n\n```xml\n\x3c!--抽取sql片段简化编写--\x3e\n<sql id="selectStudent" select * from student</sql>\n<select id="findById" parameterType="int" resultType="student">\n    <include refid="selectStudent"></include> where id=#{id}\n</select>\n<select id="findByIds" parameterType="list" resultType="student">\n    <include refid="selectStudent"></include>\n    <where>\n        <foreach collection="array" open="id in(" close=")" item="id" separator=",">\n            #{id}\n        </foreach>\n    </where>\n</select>\n```\n\n总结语法:\n\n我们可以将一些重复性的 SQL 语句进行抽取，以达到复用的效果。 \n\n~~~xml\n-  <sql>：抽取 SQL 语句标签。 \n-  <include>：引入 SQL 片段标签。 \n   <sql id=“片段唯一标识”>抽取的 SQL 语句</sql> <include refid=“片段唯一标识”/>\n \n~~~\n\n#### 2.5 知识小结\n\nMyBatis映射文件配置：\n\n~~~xml\n<select>：查询\n\n<insert>：插入\n\n<update>：修改\n\n<delete>：删除\n\n<where>：where条件\n\n<if>：if判断\n\n<foreach>：循环\n\n<sql>：sql片段抽取\n\n~~~\n\n\n\n### 三. 分页插件\n\n#### 3.1 分页插件介绍\n\n![1590937779260](./mybatis-第2天讲义.img/1590937779260.png)\n\n* 分页可以将很多条结果进行分页显示。 \n*  如果当前在第一页，则没有上一页。如果当前在最后一页，则没有下一页。 \n*  需要明确当前是第几页，这一页中显示多少条结果。    \n* MyBatis分页插件总结\n  1. 在企业级开发中，分页也是一种常见的技术。而目前使用的 MyBatis 是不带分页功能的，如果想实现分页的 功能，需要我们手动编写 LIMIT 语句。但是不同的数据库实现分页的 SQL 语句也是不同的，所以手写分页 成本较高。这个时候就可以借助分页插件来帮助我们实现分页功能。 \n  2. PageHelper：第三方分页助手。将复杂的分页操作进行封装，从而让分页功能变得非常简单。    \n\n#### 3.2 分页插件的使用\n\nMyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封装，使用简单的方式即可获得分页的相关数据\n\n开发步骤：\n\n①导入与PageHelper的jar包\n\n②在mybatis核心配置文件中配置PageHelper插件\n\n~~~xml\n\x3c!-- 注意：分页助手的插件  配置在通用mapper之前 --\x3e\n<plugin interceptor="com.github.pagehelper.PageHelper">\n    \x3c!-- 指定方言 --\x3e\n    <property name="dialect" value="mysql"/>\n</plugin>\n~~~\n\n③测试分页数据获取\n\n~~~java\n@Test\npublic void testPageHelper(){\n    //设置分页参数\n    PageHelper.startPage(1,2);\n\n    List<User> select = userMapper2.select(null);\n    for(User user : select){\n        System.out.println(user);\n    }\n}\n~~~\n\n#### 3.3 分页插件的参数获取\n\n**获得分页相关的其他参数**：\n\n```java\n//其他分页的数据\nPageInfo<User> pageInfo = new PageInfo<User>(select);\nSystem.out.println("总条数："+pageInfo.getTotal());\nSystem.out.println("总页数："+pageInfo.getPages());\nSystem.out.println("当前页："+pageInfo.getPageNum());\nSystem.out.println("每页显示长度："+pageInfo.getPageSize());\nSystem.out.println("是否第一页："+pageInfo.isIsFirstPage());\nSystem.out.println("是否最后一页："+pageInfo.isIsLastPage());\n\n```\n\n#### 3.4  分页插件知识小结\n\n​    分页：可以将很多条结果进行分页显示。 \n\n* 分页插件 jar 包： pagehelper-5.1.10.jar jsqlparser-3.1.jar \n\n*  plugins：集成插件标签。 \n\n* 分页助手相关 API \n\n  ​    1.PageHelper：分页助手功能类。\n\n  2. startPage()：设置分页参数 \n  3. PageInfo：分页相关参数功能类。 \n  4. getTotal()：获取总条数 \n  5. getPages()：获取总页数\n  6.  getPageNum()：获取当前页\n  7.  getPageSize()：获取每页显示条数\n  8.  getPrePage()：获取上一页 \n  9. getNextPage()：获取下一页 \n  10. isIsFirstPage()：获取是否是第一页 \n  11. isIsLastPage()：获取是否是最后一页    \n\n### 四.MyBatis的多表操作\n\n#### 4.1 多表模型介绍\n\n我们之前学习的都是基于单表操作的，而实际开发中，随着业务难度的加深，肯定需要多表操作的。 \n\n*  多表模型分类 一对一：在任意一方建立外键，关联对方的主键。\n*  一对多：在多的一方建立外键，关联一的一方的主键。\n*  多对多：借助中间表，中间表至少两个字段，分别关联两张表的主键。    \n\n#### 4.2 多表模型一对一操作\n\n1. 一对一模型： 人和身份证，一个人只有一个身份证\n\n2. 代码实现\n\n   * 步骤一: sql语句准备\n\n     ~~~sql\n     CREATE TABLE person(\n     \tid INT PRIMARY KEY AUTO_INCREMENT,\n     \tNAME VARCHAR(20),\n     \tage INT\n     );\n     INSERT INTO person VALUES (NULL,\'张三\',23);\n     INSERT INTO person VALUES (NULL,\'李四\',24);\n     INSERT INTO person VALUES (NULL,\'王五\',25);\n     \n     CREATE TABLE card(\n     \tid INT PRIMARY KEY AUTO_INCREMENT,\n     \tnumber VARCHAR(30),\n     \tpid INT,\n     \tCONSTRAINT cp_fk FOREIGN KEY (pid) REFERENCES person(id)\n     );\n     INSERT INTO card VALUES (NULL,\'12345\',1);\n     INSERT INTO card VALUES (NULL,\'23456\',2);\n     INSERT INTO card VALUES (NULL,\'34567\',3);\n     ~~~\n\n   * 步骤二:配置文件\n\n     ~~~xml\n     <?xml version="1.0" encoding="UTF-8" ?>\n     <!DOCTYPE mapper\n             PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n             "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n     \n     <mapper namespace="com.itheima.table01.OneToOneMapper">\n         \x3c!--配置字段和实体对象属性的映射关系--\x3e\n         <resultMap id="oneToOne" type="card">\n             <id column="cid" property="id" />\n             <result column="number" property="number" />\n             \x3c!--\n                 association：配置被包含对象的映射关系\n                 property：被包含对象的变量名\n                 javaType：被包含对象的数据类型\n             --\x3e\n             <association property="p" javaType="person">\n                 <id column="pid" property="id" />\n                 <result column="name" property="name" />\n                 <result column="age" property="age" />\n             </association>\n         </resultMap>\n     \n         <select id="selectAll" resultMap="oneToOne">\n             SELECT c.id cid,number,pid,NAME,age FROM card c,person p WHERE c.pid=p.id\n         </select>\n     </mapper>\n     ~~~\n\n   * 步骤三：测试类\n\n     ~~~java\n      @Test\n         public void selectAll() throws Exception{\n             //1.加载核心配置文件\n             InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n     \n             //2.获取SqlSession工厂对象\n             SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n     \n             //3.通过工厂对象获取SqlSession对象\n             SqlSession sqlSession = sqlSessionFactory.openSession(true);\n     \n             //4.获取OneToOneMapper接口的实现类对象\n             OneToOneMapper mapper = sqlSession.getMapper(OneToOneMapper.class);\n     \n             //5.调用实现类的方法，接收结果\n             List<Card> list = mapper.selectAll();\n     \n             //6.处理结果\n             for (Card c : list) {\n                 System.out.println(c);\n             }\n     \n             //7.释放资源\n             sqlSession.close();\n             is.close();\n         }\n     ~~~\n\n   3.一对一配置总结:\n\n   ~~~xml-dtd\n   <resultMap>：配置字段和对象属性的映射关系标签。\n       id 属性：唯一标识\n       type 属性：实体对象类型\n   <id>：配置主键映射关系标签。\n   <result>：配置非主键映射关系标签。\n       column 属性：表中字段名称\n       property 属性： 实体对象变量名称\n   <association>：配置被包含对象的映射关系标签。\n       property 属性：被包含对象的变量名\n       javaType 属性：被包含对象的数据类型\n   ~~~\n\n   \n\n#### 4.3 多表模型一对多操作\n\n1. 一对多模型： 一对多模型：班级和学生，一个班级可以有多个学生。    \n\n2. 代码实现\n\n   - 步骤一: sql语句准备\n\n     ```sql\n     CREATE TABLE classes(\n     \tid INT PRIMARY KEY AUTO_INCREMENT,\n     \tNAME VARCHAR(20)\n     );\n     INSERT INTO classes VALUES (NULL,\'黑马一班\');\n     INSERT INTO classes VALUES (NULL,\'黑马二班\');\n     \n     \n     CREATE TABLE student(\n     \tid INT PRIMARY KEY AUTO_INCREMENT,\n     \tNAME VARCHAR(30),\n     \tage INT,\n     \tcid INT,\n     \tCONSTRAINT cs_fk FOREIGN KEY (cid) REFERENCES classes(id)\n     );\n     INSERT INTO student VALUES (NULL,\'张三\',23,1);\n     INSERT INTO student VALUES (NULL,\'李四\',24,1);\n     INSERT INTO student VALUES (NULL,\'王五\',25,2);\n     INSERT INTO student VALUES (NULL,\'赵六\',26,2);\n     ```\n\n   - 步骤二:配置文件\n\n     ```xml\n     <mapper namespace="com.itheima.table02.OneToManyMapper">\n         <resultMap id="oneToMany" type="classes">\n             <id column="cid" property="id"/>\n             <result column="cname" property="name"/>\n     \n             \x3c!--\n                 collection：配置被包含的集合对象映射关系\n                 property：被包含对象的变量名\n                 ofType：被包含对象的实际数据类型\n             --\x3e\n             <collection property="students" ofType="student">\n                 <id column="sid" property="id"/>\n                 <result column="sname" property="name"/>\n                 <result column="sage" property="age"/>\n             </collection>\n         </resultMap>\n         <select id="selectAll" resultMap="oneToMany">\n             SELECT c.id cid,c.name cname,s.id sid,s.name sname,s.age sage FROM classes c,student s WHERE c.id=s.cid\n         </select>\n     </mapper>\n     ```\n\n   - 步骤三：测试类\n\n     ```java\n         @Test\n         public void selectAll() throws Exception{\n             //1.加载核心配置文件\n             InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n     \n             //2.获取SqlSession工厂对象\n             SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n     \n             //3.通过工厂对象获取SqlSession对象\n             SqlSession sqlSession = sqlSessionFactory.openSession(true);\n     \n             //4.获取OneToManyMapper接口的实现类对象\n             OneToManyMapper mapper = sqlSession.getMapper(OneToManyMapper.class);\n     \n             //5.调用实现类的方法，接收结果\n             List<Classes> classes = mapper.selectAll();\n     \n             //6.处理结果\n             for (Classes cls : classes) {\n                 System.out.println(cls.getId() + "," + cls.getName());\n                 List<Student> students = cls.getStudents();\n                 for (Student student : students) {\n                     System.out.println("\\t" + student);\n                 }\n             }\n     \n             //7.释放资源\n             sqlSession.close();\n             is.close();\n         }\n     ```\n\n   3.一对多配置文件总结：\n\n   ~~~xml-dtd\n   <resultMap>：配置字段和对象属性的映射关系标签。\n       id 属性：唯一标识\n       type 属性：实体对象类型\n   <id>：配置主键映射关系标签。\n   <result>：配置非主键映射关系标签。\n       column 属性：表中字段名称\n       property 属性： 实体对象变量名称\n   <collection>：配置被包含集合对象的映射关系标签。\n       property 属性：被包含集合对象的变量名\n       ofType 属性：集合中保存的对象数据类型\n   ~~~\n\n    \n\n#### 4.4 多表模型多对多操作\n\n1. 多对多模型：学生和课程，一个学生可以选择多门课程、一个课程也可以被多个学生所选择。       \n\n2. 代码实现\n\n   - 步骤一: sql语句准备\n\n     ```sql\n     CREATE TABLE course(\n     \tid INT PRIMARY KEY AUTO_INCREMENT,\n     \tNAME VARCHAR(20)\n     );\n     INSERT INTO course VALUES (NULL,\'语文\');\n     INSERT INTO course VALUES (NULL,\'数学\');\n     \n     \n     CREATE TABLE stu_cr(\n     \tid INT PRIMARY KEY AUTO_INCREMENT,\n     \tsid INT,\n     \tcid INT,\n     \tCONSTRAINT sc_fk1 FOREIGN KEY (sid) REFERENCES student(id),\n     \tCONSTRAINT sc_fk2 FOREIGN KEY (cid) REFERENCES course(id)\n     );\n     INSERT INTO stu_cr VALUES (NULL,1,1);\n     INSERT INTO stu_cr VALUES (NULL,1,2);\n     INSERT INTO stu_cr VALUES (NULL,2,1);\n     INSERT INTO stu_cr VALUES (NULL,2,2);\n     ```\n\n   - 步骤二:配置文件\n\n     ```xml\n     <?xml version="1.0" encoding="UTF-8" ?>\n     <!DOCTYPE mapper\n             PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n             "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n     \n     <mapper namespace="com.itheima.table03.ManyToManyMapper">\n         <resultMap id="manyToMany" type="student">\n             <id column="sid" property="id"/>\n             <result column="sname" property="name"/>\n             <result column="sage" property="age"/>\n     \n             <collection property="courses" ofType="course">\n                 <id column="cid" property="id"/>\n                 <result column="cname" property="name"/>\n             </collection>\n         </resultMap>\n         <select id="selectAll" resultMap="manyToMany">\n             SELECT sc.sid,s.name sname,s.age sage,sc.cid,c.name cname FROM student s,course c,stu_cr sc WHERE sc.sid=s.id AND sc.cid=c.id\n         </select>\n     </mapper>\n     ```\n\n   - 步骤三：测试类\n\n     ```java\n      @Test\n         public void selectAll() throws Exception{\n             //1.加载核心配置文件\n             InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n     \n             //2.获取SqlSession工厂对象\n             SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n     \n             //3.通过工厂对象获取SqlSession对象\n             SqlSession sqlSession = sqlSessionFactory.openSession(true);\n     \n             //4.获取ManyToManyMapper接口的实现类对象\n             ManyToManyMapper mapper = sqlSession.getMapper(ManyToManyMapper.class);\n     \n             //5.调用实现类的方法，接收结果\n             List<Student> students = mapper.selectAll();\n     \n             //6.处理结果\n             for (Student student : students) {\n                 System.out.println(student.getId() + "," + student.getName() + "," + student.getAge());\n                 List<Course> courses = student.getCourses();\n                 for (Course cours : courses) {\n                     System.out.println("\\t" + cours);\n                 }\n             }\n     \n             //7.释放资源\n             sqlSession.close();\n             is.close();\n         }\n         \n     ```\n\n   3.多对多配置文件总结：\n\n   ```xml-dtd\n   <resultMap>：配置字段和对象属性的映射关系标签。\n   \tid 属性：唯一标识\n   \ttype 属性：实体对象类型\n    <id>：配置主键映射关系标签。\n    <result>：配置非主键映射关系标签。\n   \tcolumn 属性：表中字段名称\n   \tproperty 属性： 实体对象变量名称\n   <collection>：配置被包含集合对象的映射关系标签。\n   \tproperty 属性：被包含集合对象的变量名\n   \tofType 属性：集合中保存的对象数据类型\n   ```\n\n    \n\n#### 4.5 多表模型操作总结\n\n~~~xml-dtd\n <resultMap>：配置字段和对象属性的映射关系标签。\n    id 属性：唯一标识\n    type 属性：实体对象类型\n<id>：配置主键映射关系标签。\n<result>：配置非主键映射关系标签。\n\tcolumn 属性：表中字段名称\n\tproperty 属性： 实体对象变量名称\n<association>：配置被包含对象的映射关系标签。\n\tproperty 属性：被包含对象的变量名\n\tjavaType 属性：被包含对象的数据类型\n<collection>：配置被包含集合对象的映射关系标签。\n\tproperty 属性：被包含集合对象的变量名\n\tofType 属性：集合中保存的对象数据类型\n~~~\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n##### \n\n\n\n'},"2cff":function(n,e,t){"use strict";t.r(e);var r=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[t(""+n.tab,{tag:"component"})],1)},a=[],i=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[n.MainComponent?t("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}}):t(""+n.tab,{tag:"component"})],1)},s=[],o=t("448a"),l=t.n(o),c=(t("99af"),function(){var n=this;n.$createElement;return n._self._c,n._m(0)}),p=[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[t("div",{staticClass:"text-h5"},[n._v("JAVA 基础")]),t("div",{staticClass:"text-h6"},[n._v(" 基本环境 ")]),t("pre",[n._v("    java SE ME  EE \n    跨平台  -- jvm 虚拟机  jvm 虚拟机本身 不能跨平台 java 程序在 不同平台的不同的 jvm 虚拟机  运行\n    JRE JDK JVM 作用 \n    开发java : 编写代码 编译代码  运行代码 \n    JRE : JAVA  Runtime Enviroment   包含 JVM 虚拟机 和 JAVA 核心 类库  \n    类= java 文件 ，每个 java 文件是一个 Java 类 \n    核心类库：  java 已写好的 非常核心的 代码仓库  ，很多个java  核心 类 文件 \n    代码中 会用到 java 存放在 JRE 中 写好的 核心 java 文件 比如： System   String Number \n    java 文件的 编译 是使用 java JDK 中的  编译工具 进行编译 ，编译为 jvm 能够识别运行的 程序文件 \n    JDK : JAVA development Kit  Java 语言的 软件开发工具包 ，内部包含了 代码的 编译工具和 运行工具 \n    流程：1.使用JDK中的编译工具编译 .java  文件到      .class 字节码文件，\n          2.使用JDK中的运行工具 将  .class 文件运行在  JVM 虚拟机当中  \n    总结：1. 编写代码 需要使用 JRE 中 java 已经写好的 代码 （核心类库）\n          2. 编译代码 需要使用 JDK 中 的 编译工具\n          3. 运行代码 需要使用 JDK 中 的  运行工具\n          4. 代码运行在  JVM 虚拟机当中  \n     JDK=( JRE=(JVM 虚拟机 + 核心类库)  + 开发工具=（编译工具 + 运行工具） )    \n     系统环境变量 添加变量 Java_Home  D:\\Program Files\\Java\\jdk1.8.0_91\n                   path 编辑 新建    %Java_Home%\\bin    %Java_Home%\\jre\\bin           \n    javac  AAA.java  执行生成 AAA.class 文件 \n    java  AAA    执行 AAA.class 文件 \n    main 方法 程序的 入口点\n    public static void main(String[] args ){\n    }\n    public 确保 文件名称和 类名 必须 同名         \n    java 关键字  基本  都是小写的\n   ")]),t("div",{staticClass:"text-h6"},[n._v(" 数据类型 ")]),t("pre",[n._v("       java 有字符串 和 字符 区别  字符串 双引号 任意个字符    字符 单引号 且只能1个字符 \n      不同数据类型  占用内存空间\n      byte 1 short 2 int 4 long 8     float 4 double 8  char 2 boolean 1 \n      引用数据类型： class interface  array\n      基本数据类型  整数 浮点数 字符  布尔 \n      int a = 1;\n      float b = 1.36F; float 类型 不加 F 标识， 则默认 double 类型转换 会报错 丢失精度\n      long c = 556188L; long 类型  后面加 L 标识\n    数据范围关系 从小到大\n    byte, (short=char) , int ,long ,float ,double \n    隐式转换 小的直接变大的\n    运算过程中，小的会先提升为大的，当类型统一之后，再进行运算 。 同类型 运算\n    byte short char 三种数据类型在运算的时候，不管是否有更高的数据类型，都会提升为 int 然后再运算\n    也就是 最低隐士转换为 int 类型 ， 结果 最低是 int 类型\n    强制转换  大的转小的 强转格式 ： int a=10; byte b= (byte)a;   强转可能丢失精度\n    byte d =3+4 ; java 中存在常量优化机制：\n     根据常量计算的结果 判定是否在类型范围内，在就编译通过，不在就报错\n        java 变量作用域： 只在 变量所在的大括号内有用 \n     java 整数相除 结果是整数  10/3 = 3    10/3.0 = 3.333333...\n     \t char b = 'a';\t int c= b +20;  结果  c = 117 ; 字节 a 对应的 ASCII 码表 97 \n          1+99+“年” = \"100年\"\n           &  并且 |  或者 ！ 非 ^ 异或      && || 短路 效果\n           &  |无论如何 左右都会执行 && || 有短路效果 左边值能确定结果 则 右边不执行\n    break continue 只能跳出自己所在的那一层关系。\n    如果想要跳出跳过置顶一层，可以加入标号。\n    IDEA 目录层级关系： project - module - package - class \n    快捷键：\n    ctrl+shirt+a    ctrl+alt+v   ctrl+alt+m 包裹方法\n    psvm ，sout , alt+1，alt+4 ,ctrl+alt+l ,alt+enter   ,ctrl+b 跟进源码\n    数组 int[] arr= new int[30]  初始化定义一个长度是30的数组\n         int arr[] =new int[30]\n    sout 输出 数组 变量 输出的是 数组的 内存地址 \n    java 内存分配： \n    栈内存 ： 方法运行时，进入的内存，局部变量都存放于这块内存中，\n    堆内存 ： new 出来的内容都会进入堆内存，并且会有对应的地址值\n    方法区 ： 字节码文件 .class 加载时进入的内存 \n    本地方法栈 ：调用操作系统相关的资源\n    寄存器： 交给CPU 去使用\n    类的加载过程：\n    1.类的字节码文件加载进方法区 main 方法存放在自己吗文件中\n    2.main方法被jvm 自动调用进入栈内存中执行\n    3. 因为main 方法在 栈内存 ，创建变量 也在 栈内存\n    4.new 方法创建的实例放在堆内存中 ， 有 内存地址，并且有默认初始化值。\n      把地址值给到 变量。（因此打印数组，打印出来的是内存地址）\n    java 数组默认值\n    整数型 0  浮点数 0.0 布尔 false 字符  空字符  引用数据类型 null  \n    int[] arr=new int[]{5,7,8,999};    \n    int[] arr={5,7,8,999};     arr[0]   \n    方法定义：\n    格式：\n     public static void aaa(int num){  //方法体 }\n     public static int aaa(int num){   return 100; //方法体 }  int bb = aaa(30);\n     public static int[] aaa(int[] arr){   int[] b={1,2,3}    return b //方法体 }  int[] cc = aaa(arr) \n    方法和方法之间 是平级 关系 ，不能嵌套定义\n    栈内存： 手枪弹夹  先进后出\n    方法参数类型 和个数 必须匹配 \n    方法的形参，相当于一个局部变量\n    方法重载： java 允许 多个个相同方法名，但是形参不同的方法存在。（个数，类型，顺序）\n               Java jvm 会通过 参数去匹配调用哪个方法  \n    方法参数传递：\n            基本数据类型 ，传递的是值本身，改变传入值，是改变的这个值 ，对其他无影响。不影响原始值\n            引用数据类型 ，传递的是 内存地址 。 改变的是堆内存内的数据。会改变传入的数据本身\n     原码 反码 补码\n     计算机中的数据都是以二进制补码的形式在运算，而补码则是通过反码和原码推算出来的。 \n     原码： 看数据 ，反码：转数据 ，补码：运算数据\n     原码 ：\n     二进制的定点表示法。最高位是符号位。 0 代表正 1代表负值 其余位数表示值的大小\n     一个字节等于8个比特位 ，也就是 8个二进制位\n     byte b1 = 7  ;   0(符号位)0000111    byte b2 = -7 ; 1(符号位) 0000111\n     反码：\n     正数的反码与其原码相同 ； 负数的反码与其原码逐位取反（0变1 ， 1 变 0），符号位除外\n     补码：\n     正数的补码与其原码相同 ； 负数的补码是在其 反码  的末位 加 1 得到的 \n     二维数组\n     int[][] arr 或者   int arr[][]   或者    int[] arr[]  \n      int[][] arr = mew int[30][10];  30个一维数组 ，每个一维数组有10个元素\n    ")]),t("div",{staticClass:"text-red"},[n._v("\n        方法执行完成 弹栈消失\n    ")]),t("pre",[n._v("       类文件在方法区 ，对象实例在堆内存 ， \n       对象实例的方法地址指向方法区的类文件内的方法\n      变量在栈内存，地址指向堆内存中的类的实例对象\n       方法的调用， 类的实例对象的方法的调用 会进栈 \n      类的主方法 main 方法 会被 jvm 主动调用 ，然后 main 方法 进栈\n       代码由上往下执行， 方法顺序进栈  ， 栈内 方法 先进后出。\n       最后调用的方法完成执行后 最先消失 \n       当方法 执行完成 弹栈 消失\n       ")]),t("div",{staticClass:"text-h6"},[n._v("基础")]),t("pre",[n._v(" \n       单个实例对象的 实例在 堆内存中 ，实例的  成员属性在堆内存，\n      成员方法 在方法区 ，但是堆内存中存有 成员方法的内存地址\n      成员变量： \n      类中方法外的变量 ，有初始默认值 ，堆内存 ，随对象GC 消失\n      局部变量：\n      类中方法内的变量 ，无初始默认值， 栈内存 ，随着方法的执行完成弹栈消失\n      private 权限修饰符 \n      私有 保证数据安全 ，需要根基需求提供 set 和 get 方法 获取 和设置 私有 成员属性 \n      java 类的 构造方法\n      1.方法名称和类名相同，大小写一致\n      2.没有返回值类型，连 void 也没有\n      3.没有具体的返回值 ，不能 由 return 带回 结果数据\n\n      java 类的 构造方法 可以通过 方法的 重载 通过不同的参数 进行 不同 的 初始化\n   ")]),t("div",[n._v("String")]),t("pre",[n._v('     "" 创建的字符串  存在 字符串常量池   （在  堆内存 存储 ） 存在则不再创建  ,不可改变\n     s1 = "123"  s2 = "123"  s1==s2 结果是true \n     new 创建的 每次都是不同的 内存地址 放在 堆内存中 new 创建的  不可能相等\n     字符串的加号拼接 ：系统底层会自动创建一个 stringBuilder 对象 ，\n     再调用其append 方法完成拼接 。拼接后，再调用toString 方法 转换为 String 类型\n     因此  s1="abc"  s2="ab"  s3=s2+"c"   s1==s3   s3 是变量计算拼接 不是常量拼接  返回  false  \n     "abc" == "a" + "b" + "c"  返回 true 原因 ：\n      a,b,c 都是常量 java 的 常量优化机制 在编译的时候 就把右侧直接计算了\n      equals 方法 比较 值是否相等\n      String 类型 + 常量字符串 的 字符串拼接每次都会创建 两个对象 ，一个 stringBuilder 一个 string \n   ')]),t("div",[n._v("StringBuilder   一个可变的字符串类   append toString  reverce")]),t("div",[n._v("打印string  stringBuilder 集合 类  都不会出现内存地址。  打印数组  会出现 ")]),t("div",[n._v(" 集合 ArrayList")]),t("pre",[n._v("       Student[] arr = new Student[3]  \n\n    集合和数组 对比\n    集合类 ：  提供一种存储空间可变的存储模型，容量可变\n    数组类 ：   容量是固定的 不可变的 \n    ArrayList  list = new ArrayList();\n    集合内 可以放任意类型数据      \n    泛型\n    ArrayList<String>  list = new ArrayList <>();\n    集合内 只能放 字符串 String 数据   \n    集合常用API :   add remove  set  get size        \n   ")]),t("div",[n._v(" 高级面向对象 ")]),t("pre",[n._v("        业务对象类  本身  \n        DAO  访问存储数据的数组 或者集合  data access object\n        Service  用来 处理业务逻辑 ，服务器内部的 逻辑\n        Controller  用来 处理     用户  和网页 的相关 逻辑  \n        业务逻辑流程：\n        controller 的 addItem 调用 service  的 addItem , service  的 addItem 调用 dao 的 addItem\n       与试图打交道的 类 调用 与数据库打交道的类 ，与数据库打交道的类 调用 数据库类\n\n        private  static  ， static 修饰的  静态成员属性 在内存中 所有这个类的实例中共享\n         一般 存在于方法区中 \n   ")]),t("div",[n._v("继承")]),t("pre",[n._v("       继承： 让类鱼类之间产生 父子类关系 ， 子类可以直接使用 父类的非私有的成员  \n              例如 你可以用你爸爸的车 ，但你不能用他的内裤 \n              父类 ： 基类 超类   子类 ： 派生类 \n              public class ZI extends FU { }\n        继承好处：复用性，维护性，让类之间产生关系是多态的前台\n        继承弊端：继承是侵入性的 ，不灵活 ，子类   必须拥有父类的非私有属性和方法\n                  耦合性强   父类中 非私有的东西 不能随便改 随便删除 \n        JAVA 只支持 单继承 ，不支持 多继承 ，但是 支持多层继承  \n         一个儿子不能 有两个亲爹 ，但是可以 有 爷爷 ， 有十八辈祖宗    \n         this  自己的 当前类的  super  父级的   父类的 \n         this() 访问本类的构造方法  super()访问父类的构造方法\n        子父类同名属性或者方法：    可以通过 this.  读取 自己的 属性方法   ，super. 读取 父级的 属性方法\n        \n        方法 重写  ， 注解  @Override 检查 是否 正确重写 （必须一模一样）\n        "),t("div",{staticClass:"text-red"},[n._v("\n            "),t("div",[n._v("父类的静态方法，个非静态方法 ， 子类必须一摸一样的名字才能重写 ")]),n._v("\n            \n            "),t("div",[n._v("静态方法不能重写，父子类静态方法同名 ，只是子类将父类中的同名方法隐藏起来了。  就近原则")]),n._v("\n        ")]),n._v("\n        子类 重写 父类 方法 ， 权限必须大于等于 父类 权限 \n        java  四个 权限修饰符   private  小于 默认 小于 protected  小于 public \n        private  同一个类中\n        默认     同一个包中 子类 无关类\n        protected 不同包的子类\n        public   不同包的 无关类\n\n        子类的  构造方法 会默认调用 super() ；即便是不写 ，也会默认加上。不然子类没办法拿到继承而来的东西\n\n        其实每一个类  都继承与 Objiect  类 如果没 指定继承则该类的构造方法 默认 继承自 Object 默认调用 super()\n\n        抽象类   abstract\n        抽象方法： 将共性的方法 抽取到父类之中后，发现该方法的实现逻辑无法确定，该方法就要可以定义为抽象方法\n        抽象类： 如果一个类中 存在 抽象方法 ，那么这个类 就必须 声明为 抽象类\n        public  abstract void aa();  \n        public  abstract class  A1{}\n        public  class A99  extends A1{}\n        抽象类 只能被 继承 实现 。 不能创建 实例对象。因为 没有方法体的方法 不能调用。\n        抽象类的 子类 必须 重写 父类的  抽象方法 ， 但是 子类也可以把自己变成 抽象类。\n        抽象类 不一定有抽象方法， 有抽象方法的类 必定是抽象方法 \n\n        抽象类  体现的是 一种  模板设计模式  \n        final 关键字 可以修饰 属性 方法 类名   ，final 修饰的 属性方法 将不能重写 ，类不能  继承 ，一般用于  属性 和方法  禁止重写 \n        局部代码块 在 方法中定义，限定变量的 生命周期，快速释放，提高内存利用率\n         { }  构造代码块 在 类的 构造方法执行之前执行 ，  可以放  构造方法的 公用代码 \n         static {}  静态代码块 随着 类的加载而加载，只执行一次， 一般用于数据初始化 ，只在类文件加载的时候执行。和构造方法调用无关\n                \n   ")]),t("div",[n._v("接口")]),t("pre",[n._v("       抽象类 可以制定 模板 ，制定一定规则 去让子类去实现\n       但是如果某个抽象类的所有方法都是抽象方法的时候，我们就可以将其定义为接口\n       接口也是一种引用数据类型， 比抽象类 更加抽象 \n       接口的存在有两个重要意义： 1. 规则的定义  2. 程序的扩展性\n       public interface AA {}\n       接口本身 和 抽象方法一样不能实例化 \n       public class AA_ZI implements AA{} \n       类不能多继承 ，但是 类 可以实现 多个接口 \n       接口 因为是定义规则  ， 接口中的 属性 变量  默认是 final 修饰的 不能被修改 静态的 \n       全部的修饰符 是  public static final \n       接口没有构造方法 \n       接口中可以 使用 default 定义修饰 默认方法 ，默认方法 只要是用于 接口的迭代升级\n       类 实现多个接口 ，如果多个接口中有重名的 默认方法 ，  子类 必须重写 这个 方法 \n       接口中可以 使用 static 定义修饰 静态 方法  通过 接口名.静态方法名 来调用  \n       接口中 可以有  静态 方法  默认方法 私有方法  抽象方法   \n\n        继承亲爹 实现干爹  \n\n        类和类之间       继承关系   只能 单继承  但是可以 多层继承    你-- 你爹  -你爷爷  - 你十八辈子祖宗\n        类和接口之间     实现关系   可以单实现也可以多实现 ，还可以在继承一个类的时候 同时实现多个接口\n        接口和接口之间   继承关系   可以单继承也可以多继承            \n\n       \n   ")]),t("div",[n._v(" 多态")]),t("pre",[n._v("       通用对象类型  ，例如 全球 70 亿人 实例 都是 人类 \n       多态的前提是  要有 继承 或者实现关系  ，要有方法重写 ，要有父类引用 指向子类对象\n\n       Animal a = new Cat();\n       多态中的 成员访问 特点\n       构造方法：  同继承一样 ，子类会通过  super 访问 父类 构造器\n       成员变量： 编译看左边 父类  ， 执行 看左边父类\n       成员方法：  编译看左边父类，   执行 看 右边子类\n        多态 弊端：  不能调用子类特有 方法 属性\n       多态中的 转型\n       向上转型  父类引用  指向子类对象     把一个 子类类型  转换为 一个 父类类型   小的转大的  不用强制转换\n       向下转型  子类引用  指向父类对象     把一个 父类类型  转换为 一个 子类类型    大的转小的  需要强制类型转换\n       instanceof  \n       \n   ")]),t("div",[n._v(" 内部类")]),t("pre",[n._v('       Outer.Inner i = new Outer().new Inner();\n       匿名内部类\n       函数式编程思想\n       lambda   箭头 函数   是将 匿名 内部类 的  一个  优化 \n       doaaaa( AA a){ a.nn(); }\n        doaaaa(new AA(){\n            public void nn(){\n                sout("Niubi ")\n            }\n        })\n       doaaaa(()->{  sout("Niubi ") })\n       匿名内部类 ，必须 实现一个接口 ，生产 一个实现类的对象 ，重写方法 ，读取重写的方法 ，执行方法  \n       这个方法 根本的阐述    传递的是一个函数 ， 箭头函数方式 我们直接传入 的 是 方法的 实体 ，\n       把原本的关注点 转到方法的具体实现\n       lambda 使用前提：  必须有一个接口  接口中 有且仅有一个 抽象方法 \n       这种 根本上 传入的  还是一个 匿名对象，实例的 匿名实现类的 一个具体的 对象\n   ')]),t("div"),t("pre",[n._v("        collection  map   list  arraylist  linkedlist set hashset treeset   HashMap   TreeMap\n        数组长度固定， 集合 会自动扩缩容 每次 1.5倍数，长度小于10  是 10\n        栈  压栈 弹栈\n        队列  入队列             出队列    前端  后端   \n        数组   查询快 增删慢   因为 增删 需要 把后面的 每个都平移一位 \n        链表    增删快 查询慢  必须 从  头开始查  单向链表\n        链表   结点   头结点（地址）数据地址数据地址。。。。。^ 结束  火车一样，每一个结点 都由 数据 和地址组成  \n                链表有头有尾  尾巴 是 一个空地址   ，前一个结点 记录后一个结点的地址值\n        双向链表      前一个结点的地址+值+下一个结点的地址   \n        linkedlist 链表  增删方法比较特殊 ， 有一些特殊方法 \n\n        泛型  \n        不写 默认 Object,,提供 编译时候 安全检测机制   \n        \n        collection  单列集合   list set \n        set 没有索引 只能用迭代器  iterator 进行迭代    或者 增强 for 进行魂环 \n        hashset  treeset\n        treeset 可以对 内部元素 进行 排序 要想使用 treeset 必须 指定 排序规则   自然排序\n          内部的 元素 必须 实现 comparable 接口  并且重写 compareTo 方法 \n          compareTo  返回 0 则 不存储 ， 大于存右边 ，小于存左边\n          字符串也有 compareTo 方法 \n          comparator  比较器 类 实现 compare 方法  抽象类\n        \n\n        数据结构 树   结点\n          二叉树    结点  父节点+当前节点值+左子节点+右子节点 \n          二叉树的查询都是从根节点进行查询\n          度： 每一个节点的子节点的 数量\n          高度， 二叉树的 根节点 到最 末梢结点的 最长层级 ，也就是 分叉 分了 几次+1\n\n          普通二叉树     二叉查找树，二叉搜索树\n          普通二叉树     左右子节点 大小没关系\n          二叉查找树     左子节点小于右边子节点  ，一样的 不存储  ，\n          二叉查找树     每一次存储一个值 都要从根节点 开始找路径 进行比较，找到自己的位置 ，\n                         可能出现 左右子树高度差的很远\n          平衡二叉树     任意左右节点 的 两个子树都是一棵平衡二叉树 ，左右高度相差不超过1\n                         左右 旋转 ， 变化根节点，根节点 会变化，普通二叉树 不会变根节点\n                         左旋 ，原本根节点的右节点 升为根节点 \n                                新的根节点的 原本的左节点 倒向左侧， 链接旧的的根节点作为右侧，做为右弦\n                         右旋 ：和上面的左旋 处处相反\n                         左左插入--右旋 ， \n                         左右插入--失衡区域左旋，然后整体右旋 ，两次旋转\n                         右右插入--左旋\n                         右左插入--失衡区域右旋，然后整体左旋\n          红黑树         一种自平衡的二叉查找树 ，但不是高度平衡，不是每次都去计算是否平衡，有自己的红黑规则\n                         每一个节点 都是 红色 或者黑色\n                         根节点必须黑色\n                         如果一个节点没有子节点或者父节点，则这个节点相应的值为Nil，被称为叶节点，都是黑色的\n                         如果一个节点是红色的，那么它的子节点必须是黑色的，不能出现两个红色的节点相连\n                         每一个节点，从该节点到它所有的后代叶节点的简单路径上，都包含相同数目的黑色节点\n                         红黑树多了一个颜色属性\n                         添加三个默认黑色 调整两次\n                         添加三个默认红色 调整1次数\n                         红黑树为了提升性能，默认添加数据颜色为红色\n                         红黑树  ---旋转 区域小，只旋转了父节点 祖父节点， 把父节点提升祖父节点下降作为父节点的右子节点 ，或者左子节点\n                         红黑树 添加数据 需要变色 ，只有在父节点红色，叔叔节点黑色，才会旋转\n        \n        hashset  \n          \n              a.hashCode() 计算 哈希值， 同一个对象的 哈希值 一样的\n              0.75 扩展因子， 满容量的 0.75  则扩容 2倍数\n              集合 ，每个位置 一个哈希 ，如果 相同哈希，则存在同一个位置， 同一个位置总数小于8 采用 链表 ，大于等于8 采用 红黑树\n           hashset  必须重写 hashcode 和 equals 方法   \n            \n        MAP\n        Interface Map K,V     \n        键值对 ，entry 对象\n        hashmap  底层 还是 数组 和 红黑树 ，也有 扩展因子  和 hashset 很类似 \n        terrmap  底层 是根据key 排序的 treeset 类似的 原理 \n\n        可变参数  （int ...a）  类似 js 的 数组解构， 底层是一个数组，是一种  简便写法\n        \n        stream  流\n        流 操作 可以 过滤 和js 的  过滤一样  相当于读数据中 每个去过滤 执行\n        流水线 ，每次操作一波，  流水线 ，准备物料 --\x3e 各种一次次操作加工 --\x3e出货  . 获取流--\x3e 中间方法--\x3e 终结方法\n        list1.stream().filter(()->{ }).filter(()->{ }).filter(()->{ }).filter(()->{ }).filter(()->{ }).forEach(()->{})\n        list1.stream().filter(()->{ }).filter(()->{ }).filter(()->{ }).filter(()->{ }).filter(()->{ }).xollect(Collectors.toList())\n        stream.of()\n        limit()  skip() \n        \n        \n        \n        \n                   \n   ")]),t("div",[n._v("IO")]),t("pre",[n._v("        字节流 写 各种文件类型 \n        字符流 写  记事本 txt 文件 \n        释放资 源 close     捕获错误\n        FileOutputStream   FileInputStream \n        字节缓冲流  BufferedOutputStream   BufferedInputStream\n        字符输出流   FileWriter   \n        字符缓冲流  BufferedWriter   BufferedReader\n        转换流\n        对象操作流   ObjectOutputStream   ObjectInputStream  \n                       对象需要实现 可序列化接口 ，需要抛出各种异常  需要看 demo\n                       transient  路过的  序列化跳过字段  例如密码\n        properties  \n                    MAP       双列集合的操作流  \n                    put   setProperty \n                    load  加载.property 文件\n                    store  存储.property 文件      \n                    等号 形式 ，键值对 ，一般作为配置文件  .property 文件\n                    搜索  .property 文件 读取   需要关闭 IO 流 \n                    \n        apche-commons-io\n        \n        \n    ")]),t("div",[n._v(" 多线程")]),t("pre",[n._v("        cpu 在 多个 进程中 高速切换， 表征是 同时运行 ，例如电脑 同时 执行很多个软件\n        并行： 同一时刻，有多个指令 在多个 CPU 上 同时执行    三个人同时做三件事\n        并发： 在同一时刻， 有多个指令 在单个CPU 上交替执行   一个人同时做三件事\n\n        进程 线程\n        进程： 正在 运行的 软件   ，独立 动态 并发\n        线程： 单个进程中的单个顺序控制流 ，一条执行 路径\n               单线程： 一个进程  只有一条执行路径\n               多线程： 一个进程  有多条执行路径 \n        多线程的 实现方案\n         1.继承 Thread 类   2.实现 Runable 接口 ，调用 Thread 类  3. 利用 callable 和 future 接口实现  ，调用 Thread 类 \n         继承 Thread 类   \n         继承 线程类 重写 run 方法  创建一个线程对象 ，开启多个线程  t1.start()\n         run 方法 没有开启线程 ，只是一般的方法 ， start 方法 开启线程\n         实现 Runable 接口\n         定义xx类 实现 Runable 接口  重写 run 方法  创建对象 xxa\n         创建 Thread 类对象 把  xxa对象 作为构造方法的参数 启动线程\n         类 可执行 run 方法      线程 可执行 start 方法   \n         琼东一个线程 去 执行 可执行类的 run 方法 \n         利用 callable 和 future 接口实现 \n         定义一个类 实现 callable 接口  重写 call 方法  创建 aa 对象\n         创建 future 接口 的 实现类 ff对象  把aa对象 作为 ff构造方法的参数  FutureTask\n         创建 Thread 类对象 ，把 ff对象 作为 构造方法的参数  启动线程\n         这种 方式 可以有返回值\n\n        传递给 thread 的 参数 必须 实现了  runable 接口\n        线程的  get 方法 可以 获取 线程执行完的 返回结果 \n        线程 可以自定义  线程名字   setName  getName\n        线程   可以  sleep  休眠  时常  \n\n        线程调度\n        计算机中的 CPU  在任意时刻只能执行一条机器命令。每个线程只有在 获得CPU 的使用权才能执行代码\n        各个线程轮流获得CPU的 使用权 ，分别执行各自的任务 \n        分时调度模型   ，抢占式调度模型 \n        java 使用的是 抢占调度模式  ，每个线程可以 设置 优先级 (10-1)   setPriority\n        \n        后台线程  守护线程    普通线程执行完成后，守护线程不再执行\n        setDaemon   设置为守护线程\n\n        线程 安全问题\n        三个窗口卖100张电影票 ， 相同票买了很多次 ，出现 负数票号\n        执行每一行代码的时候 ，CPU  执行权力 都可能被别的线程 抢走。 \n        多线程安全问题是因为多线程操作共享数据造成的\n        加锁----------------加锁      \n        十个人抢着上一个厕所，抢到的上厕所就立即锁门 ，免得别人进厕所  ，同步执行的代码块，只能单线程，别的只能等 \n        多线程安全问题的解决方案基本思想： 让程序没有安全问题的环境\n        解决方法：\n                把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可\n                java 提供了同步代码块的方式 来解决\n        synchronized(任意锁对象（类的静态成员属性，全部类实例公用的）){多条线程操作的共享数据的代码块} \n                              代码执行会去改变和还原这个锁对象， 锁对象 必须唯一\n        synchronized 会自动上锁\n                    好处： 线程安全\n                    坏处： 线程很多的时候，每个线程都会去判断同步上的锁，很消耗资源，会降低程序的运行效率\n        同步方法和同步代码块：\n                同步代码块可以锁住指定的代码，同步方法是锁住方法中的所有代码\n                同步代码块可以指定锁对象，同步方法不能指定锁对象\n                同步方法 的锁对象 是锁定的  this  对象本身\n        Lock 锁接口       lock  unlock    自定义 锁定 和解锁方法 ， 方便\n        死锁：是指两个或者多个线程相互之间持有对方所需要的 资源，相互等待，无法继续执行。 叉号\n             死锁是多个锁的 嵌套导致\n         生产者，消费者     \n        wait  notify  notifyAll    等待 通知 唤醒  ，使用 锁对象 去 等待和唤醒\n            等待和唤醒机制，需要中间参照    厨师 ，餐桌，顾客\n        阻塞队列    \n        queue    BlockingQueue    一根管子  通道 ， 一头生产者一头消费者 ， 消息队列\n        ArrayBlockingQueue   底层 数组 ，有界限\n        LinkedBlockingQueue  底层 链表 ，无界限   最大为 int 的最大 值\n        阻塞队列 设置最大值  while 循环 无线 添加  无线读取 ， 超限 报警\n        线程池 volatile  threadpool  线程池    executor    submit 提交任务\n        线程 生命周期：创建 new： start---就绪 runnable： 有执行资格，无执行权限---运行：抢到执行权 run----结束 死亡 垃圾回收  \n        线程  其他状态： 阻塞（有锁 lock blocked） ， 等待（wait） ，计时等待(sleep) ，唤起 就绪 notify  \n        线程的每次创建，等待创建和销毁以及等待销毁 都消耗系统资源，因此 线程池 很重要， 就好比碗柜，吃饭拿碗，吃碗放回去\n        线程池 执行原理 和 100人食堂吃饭，使用可循环的碗筷一样 ，只不过 这个放碗的碗柜 可以自己制造碗 \n        Executors 可以创建 线程池  ，  \n        ExecutorService 可以管理线程池 定量或者不限量   poll-1-thread-1  线程池子内的线程的 getName 返回的 样子\n        Thread.currentThread().getName()\n        ThreadPoolExector  \n        核心线程数，最大线程数，空闲线程最大存活时间，时间单位，任务队列，创建线程工厂，任务的拒绝策略\n        任务的拒绝策略：1.丢弃并抛异常 2.丢弃不抛异常 3.抛弃队列中等待最久的任务，添加当前任务 4.调用任务的run方法跳过线程池直接执行\n         修改了共享数据 ，某些线程不知道修改 ，消息不同步  反复无常 ，不稳定\n        共享数据的修改并不能 通知告知 哥哥线程 自己修改了 ， 每个线程也没有每次都去都最新的 ，而是从自己的变量副本读取\n        每个线程有自己的独立的线程栈  ，共享数据 ，多个线程共享、  共享数据在每个线程内是变量副本 ，不是时时刻刻从共享数据读取\n        volatile  ： 强制要求 每次线程执行的时候 去读取 最新的 共享数据 ，在变量前面 加上 volatile 这个关键字  （不稳定的）\n        public static volatile int money = 100000;\n        加了 volatile 之后：  同步代码块 synchronized 执行步骤：\n         1.线程获得锁 2.清空变量副本 3.拷贝共享变量最新的值到变量副本 4.执行代码 5.将修改后的变量副本中的值赋值给共享数据  6. 释放锁 \n\n        原子性： 是指在一次操作或者多次操作中，必须所有的操作全部完整执行才可以，否则所有的操作都不执行，多个操作是一个不可分割的整体\n        原子性 ： 比如 银行转账  扣款和到账必须 是一体的 \n        volatile  只能保证 最新 ，不能保证原子性     volatile   +   synchronized锁  可以保证 原子性  ， 但是 性能较差\n        Atomic 接口  原子类 接口  实现保证原子性，更新 数据  AtomicInterger   以 原子的方式 对值进行修改\n        把共享数据  使用 原子类来实现 ， 共享数据的改变使用  使用原子类来操作    ac.incrementAndGet\n        原子类 原理 ：  自旋锁 + CAS算法 \n                       CAS 算法 有三个操作数 ： 内存值V 旧的预期值A 要修改的值B \n                       自旋操作： 当 A==V 修改成功，把V 赋值为B ， 当 A!=V 修改失败 不做任何操作V还是原来的，并且重新获取现在的最新值\n                              这个重新获取的动作就是自旋。  自旋以后重新去执行CAS算法 ，执行运算\n                               \n         volatile   +   synchronized锁 与 Atomic  CAS  的区别\n            相同点： 多线程情况下都能保证共享数据的安全\n            不同点： （悲观锁）synchronized锁 总是从最坏的角度出发 ，认为每次获取的数据的时候别人都可能修改了，因此每次读取共享数据之前都上锁\n                     （乐观锁）CAS 从乐观的角度出发，假设每次获取数据别人都不会修改，所以不上同步锁，\n                     只不过在每次修改共享数据的时候都会检查一下，别人有没有修改过数据。 （旧的期望值 等不等于  当前的内存值（变量副本中的值））\n         hashmap 是线程不安全的 ，多线程环境下存在问题。为了保证数据安全可以使用 hashTable 但是 hashTable 效率低下 \n                   hashTable  是 悲观锁 实现 数据安全性 ， 只要有数据改变 ，就锁表\n         ConcurrentHashMap 既可以保证线程安全，数据安全 ，又可以保证执行效率    （并发的 hash 双列表 结构） \n         ConcurrentHashMap JDK1.7\n                    二次哈希 ，也会锁表，但是锁的是单个地址位置上的 hashentry数组 ,不影响其他位置使用\n                    第一次会根据 键的哈希值来计算出 在大数组中的应存入的位置，  \n                    如果为null ，创建小数组，二次哈希，计算出小数组的存储位置， 存入。 \n                    如果不为null,先找到小数组，再计算出小数组中的位置，没有就存，有就比较后存储，\n\n         ConcurrentHashMap JDK1.8\n                    数组 链表 红黑树  CAS 原子锁  ，只锁 单个位置上的链表或者红黑树\n         CountDownLatch (倒数计秒 取插销)  传递需要等待的线程数   很奇怪 的 东西  ， 线程数 ，等待 ，以及通知 。某个线程 干完事说一声\n                    CountDownLatch  可以传递给每一个线程， 用于几个线程之间通知 线程执行完毕的状态\n                    每个线程执行完 要调用  countdown 方法   ，再等待的线程 wait 等待 ，等它等待的几条线程全部执行完毕，会被自动唤起开始继续执行\n                    例如 要等待 三个线程 ，等三个线程都完成了 则 再等待的线程开始执行 ， 底层原理 是一个计数器\n        Semaphore     信号标， 通行证 ，令牌 ， 一段时间内 只能去允许 几个线程执行 ， 当某一个执行完成，释放信号，归还通行证， \n                     别的等待的就能领取通行证，开始执行。 原理就跟 限定10辆车进入园区一样， 进去拿通行证，出去交还通行证，最多十辆\n                     多个线程 共同找同一个管理员：   获取通行证 ， 拿到通行证开始执行 方法块代码，执行完了 ， 归还通行证\n                     \n        \n    ")]),t("div",[n._v(" 网络编程  UDP TCP")]),t("pre",[n._v("        三要素： IP地址  端口  协议     ，服务运行的 IP , 程序跑的端口 ， 约定的协议\n        ping 域名  可以取到 这个域名 的 IP \n        IPV4 本身 是 32bit  4个8bit 位置的数组组成   点分 十进制 表示法   127.23.36.23  256 的4次方  42亿个地址左右\n        IPV6 是  128个bit 位置  每16个一组 ，分为8组  冒分 十六进制 表示法   2404:3c00:484d:b300:84ff:c8e3:999c:ecf2   \n        InetAddress  可以获取 电脑的 相关的 名字属性等  网络相关的  地址 协议 等\n        \n        UDP 协议  面向无连接的协议 ，不管对方是否建立连接 ，   速度快 最多64K 不安全 容易丢失数据\n        TCP 协议  面向有连接的协议 ，速度慢 ，没有大小限制 ，数据安全  \n\n        UDP 通讯程序\n            DatagramSocket   数据程序通信    指定端口收发数据 。 发送的都是 字节码  接收 可以指定接收容器大小\n            发送端：  步骤： 新建socket对象， 新的接收消息存放箱子，  消息打包  ，发送出去 ，释放资源 \n            接收端：  步骤： 新建socket对象， 新的接收消息存放箱子，  消息打包  ，从箱子获取消息 ，释放资源 \n        UDP 三种通讯形式： 单播， 组播 （局域网） ，广播     \n            单播 发送端 指定 接收端 ip 和端口   接收端 接收 指定的 IP端口\n            组播 在 224.1.x.x  号段 端口  组播 需要 发送端 和接收端约定 组播地址 ip 和端口\n            广播 在 255.255.255.255  号段  端口  接收端 接收指定 端口  ， 广播针对 当前路由器链接的所有电脑\n            无论如何  接收端 都需要订阅  或者固定 IP端口  或者是 号段\n        TCP 通讯程序\n            在客户端和 服务端 各自建立一个 socket 对象\n            TCP 发送数据通讯之前 必须保证 连接建立\n            客户端    发送数据步骤：\n                    1.创建 客户端的 Socket 对象 与指定的 服务端 链接  Socket( host ,port)\n                    2.获取输出流 ，写数据   OutputStream \n                    3.释放资源  close \n            服务端    接收数据步骤：  \n                    1.创建服务器端的Socket 对象  ServerSocket(port)\n                    2.监听客户端链接，  accept()  如果收到数据则返回一个Socket 对象 ，  死等 阻塞形式的等待\n                    3.获取输入流，读数据，并把数据显示在控制台   InputStream \n                    4.释放资源   close \n\n            注意点：不论是 客户端还是服务器端，有至少有一个写入或者写出流 和 一个 socket 需要 关闭 释放资源 \n                    如果是建立链接后多次写入写出 ，则需要使用 socket 去 关闭写入写出流，并且对socket 没有影响 ，不会关闭自己 \n                    如果传输中文，需要把字节流转换为 字符缓冲流\n                    1. accept 方法是阻塞的 ，作用是等待客户端 链接\n                    2. 客户端创建对象并链接服务器，此时是通过三次握手协议保证跟服务器之间的连接\n                    3.和UDP 相反， TCP 针对客户端来讲，是往外写，是输出流。 针对服务端来讲，是往里读，是输入流\n                    4.服务器 读数据也是阻塞的 ，一直读取\n                    5.在客户端关闭输出流的时候， 还会向服务器发送一个结束标记 的动作 信息\n                    6.客户端断开链接，通过四次挥手协议保证链接终止\n            三次握手： 1.客户端向服务器端发出链接请求 ，等待服务器确认是否可以链接\n                       2.服务器端向客户端返回一个相应，告诉客户端收到了请求，你可以链接/或者不能链接\n                       3.客户端向服务器端再次发出确认信息， 建立链接  去索要东西\n            四次挥手： 1.客户端向服务器发出取消连接请求\n                       2.服务器向客户端返回一个响应，表示收到客户端的取消请求\n                        中间这里，服务器将最后的数据处理完毕\n                       3.服务器向客户端发出确认取消的消息\n                       4.客户端再次发送确认消息 ，取消链接      \n            文件上传要使用 线程池  多线程 实现\n                             \n\n\n    ")]),t("div",[n._v("类加载器和 反射")]),t("pre",[n._v('        classLoader   类加载器     \n        启动类加载器  平台类加载器  系统类加载器  自定义类加载器\n        双亲委派模型  默认先由 父加载器加载类文件 \n        类加载器，可以去加载文件 返回 字节流 \n\n        java的 反射机制   reflect\n               是指再 java 运行状态中，对于任意一个类，都能知道这个类的所有属性和方法\n               对于任意一个对象，都能够调用它的任意属性和方法\n               这种动态获取信息以及动态调用对象的功能称为 java 语言的反射机制\n            通过配置文件 动态的加载类名 和方法名字， 进行调用   \n        获得 class 对象的三种形式   Student.getClass()  Class.forName(类的全类名)   Student.class  \n         使用 反射 获取 类的  constructor field   method  单个对象 的  实例\n        利用反射创建对象实例步骤：\n            1.forName 获取 class 对象\n            2.获取构造方法对象\n            3.利用newInstance  创建 类 的 对象\n            被 private 修饰的 成员 是不能直接使用的，如果使用反射强行获取并且使用，需要临时取消访问检查\n            setAccessible  暴力反射  强行使用\n            field  get  set 设置值 必须指定对象 \n            method  invoke 运行方法\n\n        XML \n            小于  <  大于 > 和号 & 单引号 \' 双引号 "\n            <![CDATA[内容]]>\n            XML 解析 ： jaxp   jdom dom4j  pull  \n            add as libary\n            使用 解析插件  解析xml  获得  document 对象\n        DTD  schema\n        自定义dtd    自定义 文档定义类型\n        !DOCTYPE 跟标签 SYSTEM 本地文件路径\n        !DOCTYPE 跟标签 PUBLIC  文件名  文件网络上的路径\n        ELEMENT ATTLIST \n        schema  .xsd  文件     schema 文档约束文件   更加灵活\n        名称空间 约定  顺序 类型\n\n        枚举  ENUM \n            通过枚举类名.枚举项名称 方式去访问指定的枚举项\n            每一个枚举项其实就是该枚举的一个对象\n            枚举也是一个类，可以去定义成员变量、\n            第一行必须是枚举项\n            枚举类可以有构造器 ，必须是 private 的\n            枚举类也可以有抽象方法，但是枚举项必须重写这个方法\n\n        注解\n            deprecated 过时的   suppressWarning 压制警告  retention 注解存活保留时间 生命周期\n            注解是给编译器看的 ，代表一些特殊功能\n            自定义注解 \n            public @interface 注解名称{\n                    public 属性类型 属性名() default 默认值;\n            }\n            自定义注解的 属性 类型 可是是 基本类型， class 类型 注解类型  枚举类型 ，或者这些可选类型的一维数组类型\n            在使用注解的时候，如果注解里面的属性没有指定默认值，就需要我们手动给出注解属性的默认值\n            @anni(name="但是此时") 针对 value 这个特殊的注解属性，如果只需要给这个属性赋值则可以@ann("杀杀杀")\n            利用反射 获取到类的 方法 ，方法是 method 类的 实例 method 有方法判定是否自身有注解\n            method 注解包内有 方法判定是否预设了指定的注解 ，从而来判断一个方法是否添加了注解 \n            retention  默认 是 只在Java 文件内有效，在 字节码文件  运行时 无效\n        元注解 \n            描述注解的注解      \n                常用元注解：retention 生命周期  target 使用范围  inherited  可被继承  documented   会出现在API文档\n        单元测试 Junit \n            @Test   @before  @after  \n        日志技术 log4j\n            日志体系结构 两套接口 ： JCL slf4j\n            可以直接使用 log4j\n            也可以使用 slf4j 里面的 api 来获取日志对象，使用 log4j 来实现 slf4j\n            好处是 以后更换日志的实现类 代码 基本不用改什么\n            log4j 组成：\n                1.loggers 记录器 日志的级别\n                2.appenders 输出源 日志要输出的地方\n                3.layouts 布局 日志输出的格式 \n\n    ')])])}],u={},d=u,m=t("2877"),S=Object(m["a"])(d,c,p,!1,null,"de391a22",null),g=S.exports,v=t("3686"),b=t("1b62"),h="/books/java/basics/",y=Object(v["a"])(t("31f8"),"md",!0),f=y.all_components,x=y.all_modules,w={mixins:[b["c"],b["b"]],components:{m1:g},data:function(){return{relative_path:h,img_prefix:"."+h,tab:x[0].value,MainComponent:f[x[0].value],tab_level:2,tabs:[{label:"基本",value:"m1"}].concat(l()(x))}},watch:{tab:function(n,e){this.MainComponent=f[this.tab],this.compute_img_prefix()}}},C=w,I=Object(m["a"])(C,i,s,!1,null,"639306fe",null),E=I.exports,T=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[t("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}})],1)},A=[],D="/books/java/jdbc/",j=Object(v["a"])(t("eeb7"),"md",!0),q=j.all_components,R=j.all_modules,k={mixins:[b["c"],b["b"]],data:function(){return{relative_path:D,img_prefix:"."+D,tab:R[0].value,tab_level:2,MainComponent:q[R[0].value],tabs:R}},watch:{tab:function(n,e){this.MainComponent=q[this.tab],this.compute_img_prefix()}}},M=k,P=Object(m["a"])(M,T,A,!1,null,"2dce7a7c",null),O=P.exports,L=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[n.MainComponent?t("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}}):t(""+n.tab,{tag:"component"})],1)},B=[],N="/books/java/javaweb/",H=Object(v["a"])(t("e08d"),"md",!0),F=H.all_components,J=H.all_modules,_={mixins:[b["c"],b["b"]],components:{},data:function(){return{relative_path:N,img_prefix:"."+N,tab:J[0].value,MainComponent:F[J[0].value],tab_level:2,tabs:l()(J)}},watch:{tab:function(n,e){this.MainComponent=F[this.tab],this.compute_img_prefix()}}},U=_,z=Object(m["a"])(U,L,B,!1,null,"f8b2b6a8",null),V=z.exports,Q=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[t("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}})],1)},K=[],G=Object(v["a"])(t("6f7a"),"md",!0),W=G.all_components,Z=G.all_modules,X={mixins:[b["c"],b["b"]],data:function(){return{img_prefix:"./books/java/mybatis/",tab:Z[0].value,tab_level:2,MainComponent:W[Z[0].value],tabs:Z}},watch:{tab:function(n,e){this.MainComponent=W[this.tab]}}},Y=X,$=Object(m["a"])(Y,Q,K,!1,null,"2a736eb8",null),nn=$.exports,en=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[t("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}})],1)},tn=[],rn="/books/java/maven/",an=Object(v["a"])(t("b85c"),"md",!0),sn=an.all_components,on=an.all_modules,ln={mixins:[b["c"],b["b"]],data:function(){return{relative_path:rn,img_prefix:"."+rn,tab:on[0].value,tab_level:2,MainComponent:sn[on[0].value],tabs:on}},watch:{tab:function(n,e){this.MainComponent=sn[this.tab],this.compute_img_prefix()}}},cn=ln,pn=Object(m["a"])(cn,en,tn,!1,null,"1f72ba20",null),un=pn.exports,dn=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[t("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}})],1)},mn=[],Sn=Object(v["a"])(t("35c5"),"md",!0),gn=Sn.all_components,vn=Sn.all_modules,bn={mixins:[b["c"],b["b"]],data:function(){return{img_prefix:"./books/java/spring/",tab:vn[0].value,tab_level:2,MainComponent:gn[vn[0].value],tabs:vn}},watch:{tab:function(n,e){this.MainComponent=gn[this.tab]}}},hn=bn,yn=Object(m["a"])(hn,dn,mn,!1,null,"a2099f38",null),fn=yn.exports,xn=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[t("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}})],1)},wn=[],Cn="/books/java/system-design/",In=Object(v["a"])(t("4a88"),"md",!0),En=In.all_components,Tn=In.all_modules,An={mixins:[b["c"],b["b"]],data:function(){return{relative_path:Cn,img_prefix:"."+Cn,tab:Tn[0].value,tab_level:2,MainComponent:En[Tn[0].value],tabs:Tn}},watch:{tab:function(n,e){this.MainComponent=En[this.tab],this.compute_img_prefix()}}},Dn=An,jn=Object(m["a"])(Dn,xn,wn,!1,null,"023b3ebc",null),qn=jn.exports,Rn=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[t("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}})],1)},kn=[],Mn=Object(v["a"])(t("ab7d"),"md",!0),Pn=Mn.all_components,On=Mn.all_modules,Ln={mixins:[b["c"],b["b"]],data:function(){return{img_prefix:"./books/java/collection/",tab:On[0].value,tab_level:2,MainComponent:Pn[On[0].value],tabs:On}},watch:{tab:function(n,e){this.MainComponent=Pn[this.tab]}}},Bn=Ln,Nn=Object(m["a"])(Bn,Rn,kn,!1,null,"104dcf86",null),Hn=Nn.exports,Fn=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[t("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}})],1)},Jn=[],_n=Object(v["a"])(t("8871"),"md",!0),Un=_n.all_components,zn=_n.all_modules,Vn={mixins:[b["c"],b["b"]],data:function(){return{img_prefix:"./books/java/other/",tab:zn[0].value,tab_level:2,MainComponent:Un[zn[0].value],tabs:zn}},watch:{tab:function(n,e){this.MainComponent=Un[this.tab]}}},Qn=Vn,Kn=Object(m["a"])(Qn,Fn,Jn,!1,null,"39b7d722",null),Gn=Kn.exports,Wn=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[t("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}})],1)},Zn=[],Xn="/books/java/basic/",Yn=Object(v["a"])(t("20e7"),"md",!0),$n=Yn.all_components,ne=Yn.all_modules,ee={mixins:[b["c"],b["b"]],data:function(){return{relative_path:Xn,img_prefix:"."+Xn,tab:ne[0].value,tab_level:2,MainComponent:$n[ne[0].value],tabs:ne}},watch:{tab:function(n,e){this.MainComponent=$n[this.tab],this.compute_img_prefix()}}},te=ee,re=Object(m["a"])(te,Wn,Zn,!1,null,"d1b0d776",null),ae=re.exports,ie={mixins:[b["c"]],components:{m1:E,m3:V,m4:O,m5:nn,m6:un,m7:fn,m14:Hn,m15:Hn,m16:Hn,m70:qn,m88:Gn,m99:ae},data:function(){return{tab:"m1",tab_level:1,tabs:[{label:"JAVA基础-黑马",value:"m1"},{label:"JAVA基础",value:"m99"},{label:"javaweb",value:"m3"},{label:"springmvc",value:"m7"},{label:"collection",value:"m14"},{label:"jvm",value:"m15"},{label:"multi-thread",value:"m16"},{label:"JDBC",value:"m4"},{label:"mybatis",value:"m5"},{label:"maven",value:"m6"},{label:"系统设计",value:"m70"},{label:"其他",value:"m88"}]}}},se=ie,oe=Object(m["a"])(se,r,a,!1,null,"2c565a1d",null);e["default"]=oe.exports},"31f8":function(n,e,t){var r={"./day00-简单.md":"d16c","./day01-java基础语法.md":"0b4c","./day02-Java基础语法.md":"927b","./day03-switch&循环语句.md":"be8c","./day04-IDEA&数组.md":"c63a","./day05-方法.md":"a445","./day06-Debug&基础练习.md":"ef4a","./day07-面向对象.md":"e0c0","./day08-常用API.md":"b642","./day09-ArrayList集合&学生管理系统.md":"0fe1","./day10-Git.md":"9a8e","./day11-分类和static.md":"d5e3","./day12-继承.md":"8c88","./day13-接口和内部类.md":"b5bb","./day14-常用API01.md":"008f","./day15-常用API02.md":"fcfb","./day16-集合01.md":"6c40","./day17-集合02.md":"9390","./day18-集合03.md":"e6d3","./day19-IO流01.md":"7f76","./day20-IO流02.md":"7659","./day21-多线程01.md":"222c","./day22-多线程02.md":"e68d","./day23-网络编程01.md":"f4e4","./day24-网络编程02.md":"0b43","./day25-基础加强01.md":"3834","./day26-基础加强02.md":"7ebe","./day27-基础加强03.md":"0245"};function a(n){var e=i(n);return t(e)}function i(n){if(!t.o(r,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return r[n]}a.keys=function(){return Object.keys(r)},a.resolve=i,n.exports=a,a.id="31f8"},"35c5":function(n,e,t){var r={"./Spring-Design-Patterns.md":"a3ca","./Spring-day01.md":"2044","./Spring-day02.md":"a80a","./Spring-day03.md":"3879","./Spring.md":"4f93","./SpringBoot+Spring常用注解总结.md":"47d8","./SpringMVC-day01.md":"8290","./SpringMVC-day02.md":"d81b","./SpringMVC-day03.md":"4670","./Spring事务总结.md":"8d2d","./Spring常见问题总结.md":"3b19","./spring-cloud.md":"c1c7","./spring-day04.md":"ce37"};function a(n){var e=i(n);return t(e)}function i(n){if(!t.o(r,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return r[n]}a.keys=function(){return Object.keys(r)},a.resolve=i,n.exports=a,a.id="35c5"},3686:function(n,e,t){"use strict";t.d(e,"a",(function(){return l}));var r=t("ded3"),a=t.n(r),i=(t("d81d"),t("ac1f"),t("1276"),t("a15b"),t("e260"),t("d3b7"),t("ddb0"),t("fb6a"),t("4e82"),t("6821")),s=(t("d958"),function(n){if(!n)return"";var e="",t=n.split("/");return t.shift(),t.pop(),e=t.join("/"),e?"/"+e+"/":""}),o=function(n){n=n||"";var e=n.split("/"),t=e.length;return e[t-1]},l=function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"md",t=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];console.log("当前 require.context---",n),console.log("当前 field_components.keys()---",n.keys());var l=n.keys(),c={},p=[],u={},d=[];return l.map((function(r){var a=r.slice(2,r.length-e.length-1),o="module_"+i(r);d.push(a),u[a]={value:o,relative_path:r,relative_folder:s(r)},console.log("x---",r),c[o]=t?"\n            <div>\n            <code>\n              ".concat(n(r).default,"\n            </code>\n            </div>\n            "):n(r).default})),d.sort((function(n,e){return parseFloat(n)-parseFloat(e)})),d.map((function(n){p.push({label:r?o(n):n,value:u[n]["value"],modules_obj:a()({},u[n])})})),console.log("all_components------------",c),console.log("all_modules---------------",p),{all_components:c,all_modules:p}}},3834:function(n,e,t){"use strict";t.r(e),e["default"]='## 1.类加载器\r\n\r\n### 1.1类加载器【理解】\r\n\r\n+ 作用\r\n\r\n  负责将.class文件（存储的物理文件）加载在到内存中\r\n\r\n  ![01_类加载器](./day25-基础加强01.img/01_类加载器.png)\r\n\r\n### 1.2类加载的过程【理解】\r\n\r\n+ 类加载时机\r\n\r\n  + 创建类的实例（对象）\r\n  + 调用类的类方法\r\n  + 访问类或者接口的类变量，或者为该类变量赋值\r\n  + 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象\r\n  + 初始化某个类的子类\r\n  + 直接使用java.exe命令来运行某个主类\r\n\r\n+ 类加载过程\r\n\r\n  1. 加载\r\n\r\n     + 通过包名 + 类名，获取这个类，准备用流进行传输\r\n     + 在这个类加载到内存中\r\n     + 加载完毕创建一个class对象\r\n\r\n     ![02_类加载过程加载](./day25-基础加强01.img/02_类加载过程加载.png)\r\n\r\n  2. 链接\r\n\r\n     + 验证\r\n\r\n       确保Class文件字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全\r\n\r\n       (文件中的信息是否符合虚拟机规范有没有安全隐患)\r\n\r\n     ![03_类加载过程验证](./day25-基础加强01.img/03_类加载过程验证.png)\r\n\r\n     + 准备\r\n\r\n       负责为类的类变量（被static修饰的变量）分配内存，并设置默认初始化值\r\n\r\n       (初始化静态变量)\r\n\r\n     ![04_类加载过程准备](./day25-基础加强01.img/04_类加载过程准备.png)\r\n\r\n     + 解析\r\n\r\n       将类的二进制数据流中的符号引用替换为直接引用\r\n\r\n       (本类中如果用到了其他类，此时就需要找到对应的类)\r\n\r\n     ![05_类加载过程解析](./day25-基础加强01.img/05_类加载过程解析.png)\r\n\r\n  3. 初始化\r\n\r\n     根据程序员通过程序制定的主观计划去初始化类变量和其他资源\r\n\r\n     (静态变量赋值以及初始化其他资源)\r\n\r\n     ![06_类加载过程初始化](./day25-基础加强01.img/06_类加载过程初始化.png)\r\n\r\n+ 小结\r\n\r\n  + 当一个类被使用的时候，才会加载到内存\r\n  + 类加载的过程: 加载、验证、准备、解析、初始化\r\n\r\n### 1.3类加载的分类【理解】\r\n\r\n+ 分类\r\n  + Bootstrap class loader：虚拟机的内置类加载器，通常表示为null ，并且没有父null\r\n  + Platform class loader：平台类加载器,负责加载JDK中一些特殊的模块\r\n  + System class loader：系统类加载器,负责加载用户类路径上所指定的类库\r\n\r\n+ 类加载器的继承关系\r\n\r\n  + System的父加载器为Platform\r\n  + Platform的父加载器为Bootstrap\r\n\r\n+ 代码演示\r\n\r\n  ```java\r\n  public class ClassLoaderDemo1 {\r\n      public static void main(String[] args) {\r\n          //获取系统类加载器\r\n          ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\r\n\r\n          //获取系统类加载器的父加载器 --- 平台类加载器\r\n          ClassLoader classLoader1 = systemClassLoader.getParent();\r\n\r\n          //获取平台类加载器的父加载器 --- 启动类加载器\r\n          ClassLoader classLoader2 = classLoader1.getParent();\r\n\r\n          System.out.println("系统类加载器" + systemClassLoader);\r\n          System.out.println("平台类加载器" + classLoader1);\r\n          System.out.println("启动类加载器" + classLoader2);\r\n\r\n      }\r\n  }\r\n  ```\r\n\r\n### 1.4双亲委派模型【理解】\r\n\r\n+ 介绍\r\n\r\n  如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式\r\n\r\n  ![07_双亲委派模型](./day25-基础加强01.img/07_双亲委派模型.png)\r\n\r\n\r\n### 1.5ClassLoader 中的两个方法【应用】\r\n\r\n- 方法介绍\r\n\r\n  | 方法名                                      | 说明        |\r\n  | ---------------------------------------- | --------- |\r\n  | public static ClassLoader getSystemClassLoader() | 获取系统类加载器  |\r\n  | public InputStream getResourceAsStream(String name) | 加载某一个资源文件 |\r\n\r\n- 示例代码\r\n\r\n  ```java\r\n  public class ClassLoaderDemo2 {\r\n      public static void main(String[] args) throws IOException {\r\n          //static ClassLoader getSystemClassLoader() 获取系统类加载器\r\n          //InputStream getResourceAsStream(String name)  加载某一个资源文件\r\n\r\n          //获取系统类加载器\r\n          ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\r\n\r\n          //利用加载器去加载一个指定的文件\r\n          //参数：文件的路径（放在src的根目录下，默认去那里加载）\r\n          //返回值：字节流。\r\n          InputStream is = systemClassLoader.getResourceAsStream("prop.properties");\r\n\r\n          Properties prop = new Properties();\r\n          prop.load(is);\r\n\r\n          System.out.println(prop);\r\n\r\n          is.close();\r\n      }\r\n  }\r\n  ```\r\n\r\n## 2.反射\r\n\r\n### 2.1反射的概述【理解】\r\n\r\n+ 反射机制\r\n\r\n  是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；\r\n  对于任意一个对象，都能够调用它的任意属性和方法；\r\n  这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。\r\n\r\n### 2.2获取Class类对象的三种方式【应用】\r\n\r\n+ 三种方式分类\r\n  + 类名.class属性\r\n\r\n  + 对象名.getClass()方法\r\n\r\n  + Class.forName(全类名)方法\r\n\r\n    ​\r\n\r\n  ![08_获取Class对象的三种方式](./day25-基础加强01.img/08_获取Class对象的三种方式.png)\r\n\r\n+ 示例代码\r\n\r\n  ```java\r\n  public class Student {\r\n      private String name;\r\n      private int age;\r\n\r\n      public Student() {\r\n      }\r\n\r\n      public Student(String name, int age) {\r\n          this.name = name;\r\n          this.age = age;\r\n      }\r\n\r\n      public String getName() {\r\n          return name;\r\n      }\r\n\r\n      public void setName(String name) {\r\n          this.name = name;\r\n      }\r\n\r\n      public int getAge() {\r\n          return age;\r\n      }\r\n\r\n      public void setAge(int age) {\r\n          this.age = age;\r\n      }\r\n\r\n      public void study(){\r\n          System.out.println("学生在学习");\r\n      }\r\n\r\n      @Override\r\n      public String toString() {\r\n          return "Student{" +\r\n                  "name=\'" + name + \'\\\'\' +\r\n                  ", age=" + age +\r\n                  \'}\';\r\n      }\r\n  }\r\n  public class ReflectDemo1 {\r\n      public static void main(String[] args) throws ClassNotFoundException {\r\n          //1.Class类中的静态方法forName("全类名")\r\n              //全类名:包名 + 类名\r\n          Class clazz = Class.forName("com.itheima.myreflect2.Student");\r\n          System.out.println(clazz);\r\n\r\n          //2.通过class属性来获取\r\n          Class clazz2 = Student.class;\r\n          System.out.println(clazz2);\r\n\r\n          //3.利用对象的getClass方法来获取class对象\r\n          //getClass方法是定义在Object类中.\r\n          Student s = new Student();\r\n          Class clazz3 = s.getClass();\r\n          System.out.println(clazz3);\r\n\r\n          System.out.println(clazz == clazz2);\r\n          System.out.println(clazz2 == clazz3);\r\n      }\r\n  }\r\n  ```\r\n\r\n### 2.3反射获取构造方法并使用【应用】\r\n\r\n#### 2.3.1Class类获取构造方法对象的方法\r\n\r\n- 方法介绍\r\n\r\n  | 方法名                                      | 说明              |\r\n  | ---------------------------------------- | --------------- |\r\n  | Constructor<?>[] getConstructors()       | 返回所有公共构造方法对象的数组 |\r\n  | Constructor<?>[] getDeclaredConstructors() | 返回所有构造方法对象的数组   |\r\n  | Constructor<T> getConstructor(Class<?>... parameterTypes) | 返回单个公共构造方法对象    |\r\n  | Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes) | 返回单个构造方法对象      |\r\n\r\n- 示例代码\r\n\r\n  ```java\r\n  public class Student {\r\n      private String name;\r\n      private int age;\r\n\r\n      //私有的有参构造方法\r\n      private Student(String name) {\r\n          System.out.println("name的值为:" + name);\r\n          System.out.println("private...Student...有参构造方法");\r\n      }\r\n\r\n      //公共的无参构造方法\r\n      public Student() {\r\n          System.out.println("public...Student...无参构造方法");\r\n      }\r\n\r\n      //公共的有参构造方法\r\n      public Student(String name, int age) {\r\n          System.out.println("name的值为:" + name + "age的值为:" + age);\r\n          System.out.println("public...Student...有参构造方法");\r\n      }\r\n  }\r\n  public class ReflectDemo1 {\r\n      public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException {\r\n          //method1();\r\n          //method2();\r\n          //method3();\r\n          //method4();\r\n      }\r\n\r\n      private static void method4() throws ClassNotFoundException, NoSuchMethodException {\r\n          //        Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes)：\r\n  //                                      返回单个构造方法对象\r\n          //1.获取Class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect3.Student");\r\n          Constructor constructor = clazz.getDeclaredConstructor(String.class);\r\n          System.out.println(constructor);\r\n      }\r\n\r\n      private static void method3() throws ClassNotFoundException, NoSuchMethodException {\r\n          //        Constructor<T> getConstructor(Class<?>... parameterTypes)：\r\n  //                                      返回单个公共构造方法对象\r\n          //1.获取Class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect3.Student");\r\n          //小括号中,一定要跟构造方法的形参保持一致.\r\n          Constructor constructor1 = clazz.getConstructor();\r\n          System.out.println(constructor1);\r\n\r\n          Constructor constructor2 = clazz.getConstructor(String.class, int.class);\r\n          System.out.println(constructor2);\r\n\r\n          //因为Student类中,没有只有一个int的构造,所以这里会报错.\r\n          Constructor constructor3 = clazz.getConstructor(int.class);\r\n          System.out.println(constructor3);\r\n      }\r\n\r\n      private static void method2() throws ClassNotFoundException {\r\n          //        Constructor<?>[] getDeclaredConstructors()：\r\n  //                                      返回所有构造方法对象的数组\r\n          //1.获取Class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect3.Student");\r\n\r\n          Constructor[] constructors = clazz.getDeclaredConstructors();\r\n          for (Constructor constructor : constructors) {\r\n              System.out.println(constructor);\r\n          }\r\n      }\r\n\r\n      private static void method1() throws ClassNotFoundException {\r\n          //        Constructor<?>[] getConstructors()：\r\n  //                                      返回所有公共构造方法对象的数组\r\n          //1.获取Class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect3.Student");\r\n          Constructor[] constructors = clazz.getConstructors();\r\n          for (Constructor constructor : constructors) {\r\n              System.out.println(constructor);\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n#### 2.3.2Constructor类用于创建对象的方法\r\n\r\n+ 方法介绍\r\n\r\n  | 方法名                              | 说明               |\r\n  | -------------------------------- | ---------------- |\r\n  | T newInstance(Object...initargs) | 根据指定的构造方法创建对象    |\r\n  | setAccessible(boolean flag)      | 设置为true,表示取消访问检查 |\r\n\r\n+ 示例代码\r\n\r\n  ```java\r\n  // Student类同上一个示例,这里就不在重复提供了\r\n  public class ReflectDemo2 {\r\n      public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\r\n          //T newInstance(Object... initargs)：根据指定的构造方法创建对象\r\n          //method1();\r\n          //method2();\r\n          //method3();\r\n          //method4();\r\n\r\n      }\r\n\r\n      private static void method4() throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {\r\n          //获取一个私有的构造方法并创建对象\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect3.Student");\r\n\r\n          //2.获取一个私有化的构造方法.\r\n          Constructor constructor = clazz.getDeclaredConstructor(String.class);\r\n\r\n          //被private修饰的成员,不能直接使用的\r\n          //如果用反射强行获取并使用,需要临时取消访问检查\r\n          constructor.setAccessible(true);\r\n\r\n          //3.直接创建对象\r\n          Student student = (Student) constructor.newInstance("zhangsan");\r\n\r\n          System.out.println(student);\r\n      }\r\n\r\n      private static void method3() throws ClassNotFoundException, InstantiationException, IllegalAccessException {\r\n          //简写格式\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect3.Student");\r\n\r\n          //2.在Class类中,有一个newInstance方法,可以利用空参直接创建一个对象\r\n          Student student = (Student) clazz.newInstance();//这个方法现在已经过时了,了解一下\r\n\r\n          System.out.println(student);\r\n      }\r\n\r\n      private static void method2() throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect3.Student");\r\n\r\n          //2.获取构造方法对象\r\n          Constructor constructor = clazz.getConstructor();\r\n\r\n          //3.利用空参来创建Student的对象\r\n          Student student = (Student) constructor.newInstance();\r\n\r\n          System.out.println(student);\r\n      }\r\n\r\n      private static void method1() throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect3.Student");\r\n\r\n          //2.获取构造方法对象\r\n          Constructor constructor = clazz.getConstructor(String.class, int.class);\r\n\r\n          //3.利用newInstance创建Student的对象\r\n          Student student = (Student) constructor.newInstance("zhangsan", 23);\r\n\r\n          System.out.println(student);\r\n      }\r\n  }\r\n  ```\r\n\r\n#### 2.3.3小结\r\n\r\n+ 获取class对象\r\n\r\n  三种方式: Class.forName(“全类名”), 类名.class, 对象名.getClass()\r\n\r\n+ 获取里面的构造方法对象\r\n\r\n  getConstructor (Class<?>... parameterTypes)\r\n  getDeclaredConstructor (Class<?>... parameterTypes)\r\n\r\n+ 如果是public的，直接创建对象\r\n\r\n  newInstance(Object... initargs)\r\n\r\n+ 如果是非public的，需要临时取消检查，然后再创建对象\r\n\r\n  setAccessible(boolean)  暴力反射\r\n\r\n### 2.4反射获取成员变量并使用【应用】\r\n\r\n#### 2.4.1Class类获取成员变量对象的方法\r\n\r\n- 方法分类\r\n\r\n  | 方法名                                 | 说明              |\r\n  | ----------------------------------- | --------------- |\r\n  | Field[] getFields()                 | 返回所有公共成员变量对象的数组 |\r\n  | Field[] getDeclaredFields()         | 返回所有成员变量对象的数组   |\r\n  | Field getField(String name)         | 返回单个公共成员变量对象    |\r\n  | Field getDeclaredField(String name) | 返回单个成员变量对象      |\r\n\r\n- 示例代码\r\n\r\n  ```java\r\n  public class Student {\r\n\r\n      public String name;\r\n\r\n      public int age;\r\n\r\n      public String gender;\r\n\r\n      private int money = 300;\r\n\r\n      @Override\r\n      public String toString() {\r\n          return "Student{" +\r\n                  "name=\'" + name + \'\\\'\' +\r\n                  ", age=" + age +\r\n                  ", gender=\'" + gender + \'\\\'\' +\r\n                  ", money=" + money +\r\n                  \'}\';\r\n      }\r\n  }\r\n  public class ReflectDemo1 {\r\n      public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException {\r\n         // method1();\r\n          //method2();\r\n          //method3();\r\n          //method4();\r\n\r\n      }\r\n\r\n      private static void method4() throws ClassNotFoundException, NoSuchFieldException {\r\n          //        Field getDeclaredField(String name)：返回单个成员变量对象\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect4.Student");\r\n    \r\n          //2.获取money成员变量\r\n          Field field = clazz.getDeclaredField("money");\r\n    \r\n          //3.打印一下\r\n          System.out.println(field);\r\n      }\r\n    \r\n      private static void method3() throws ClassNotFoundException, NoSuchFieldException {\r\n          //        Field getField(String name)：返回单个公共成员变量对象\r\n          //想要获取的成员变量必须是真实存在的\r\n          //且必须是public修饰的.\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect4.Student");\r\n    \r\n          //2.获取name这个成员变量\r\n          //Field field = clazz.getField("name");\r\n          //Field field = clazz.getField("name1");\r\n          Field field = clazz.getField("money");\r\n    \r\n          //3.打印一下\r\n          System.out.println(field);\r\n      }\r\n    \r\n      private static void method2() throws ClassNotFoundException {\r\n          //        Field[] getDeclaredFields()：返回所有成员变量对象的数组\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect4.Student");\r\n    \r\n          //2.获取所有的Field对象\r\n          Field[] fields = clazz.getDeclaredFields();\r\n    \r\n          //3.遍历\r\n          for (Field field : fields) {\r\n              System.out.println(field);\r\n          }\r\n      }\r\n    \r\n      private static void method1() throws ClassNotFoundException {\r\n          //        Field[] getFields()：返回所有公共成员变量对象的数组\r\n    \r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect4.Student");\r\n    \r\n          //2.获取Field对象.\r\n          Field[] fields = clazz.getFields();\r\n    \r\n          //3.遍历\r\n          for (Field field : fields) {\r\n              System.out.println(field);\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n#### 2.4.2Field类用于给成员变量赋值的方法\r\n\r\n+ 方法介绍\r\n\r\n  | 方法名                                | 说明   |\r\n  | ---------------------------------- | ---- |\r\n  | void set(Object obj, Object value) | 赋值   |\r\n  | Object get(Object obj)             | 获取值  |\r\n\r\n+ 示例代码\r\n\r\n  ```java\r\n  // Student类同上一个示例,这里就不在重复提供了\r\n  public class ReflectDemo2 {\r\n      public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException, InstantiationException {\r\n  //        Object get(Object obj) 返回由该 Field表示的字段在指定对象上的值。\r\n          //method1();\r\n          //method2();\r\n\r\n      }\r\n\r\n      private static void method2() throws ClassNotFoundException, NoSuchFieldException, InstantiationException, IllegalAccessException {\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect4.Student");\r\n\r\n          //2.获取成员变量Field的对象\r\n          Field field = clazz.getDeclaredField("money");\r\n\r\n          //3.取消一下访问检查\r\n          field.setAccessible(true);\r\n\r\n          //4.调用get方法来获取值\r\n          //4.1创建一个对象\r\n          Student student = (Student) clazz.newInstance();\r\n          //4.2获取指定对象的money的值\r\n          Object o = field.get(student);\r\n\r\n          //5.打印一下\r\n          System.out.println(o);\r\n      }\r\n\r\n      private static void method1() throws ClassNotFoundException, NoSuchFieldException, InstantiationException, IllegalAccessException {\r\n          //        void set(Object obj, Object value)：给obj对象的成员变量赋值为value\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect4.Student");\r\n\r\n          //2.获取name这个Field对象\r\n          Field field = clazz.getField("name");\r\n\r\n          //3.利用set方法进行赋值.\r\n          //3.1先创建一个Student对象\r\n          Student student = (Student) clazz.newInstance();\r\n          //3.2有了对象才可以给指定对象进行赋值\r\n          field.set(student,"zhangsan");\r\n\r\n          System.out.println(student);\r\n      }\r\n  }\r\n  ```\r\n\r\n### 2.5反射获取成员方法并使用【应用】\r\n\r\n#### 2.5.1Class类获取成员方法对象的方法\r\n\r\n- 方法分类\r\n\r\n  | 方法名                                      | 说明                    |\r\n  | ---------------------------------------- | --------------------- |\r\n  | Method[] getMethods()                    | 返回所有公共成员方法对象的数组，包括继承的 |\r\n  | Method[] getDeclaredMethods()            | 返回所有成员方法对象的数组，不包括继承的  |\r\n  | Method getMethod(String name, Class<?>... parameterTypes) | 返回单个公共成员方法对象          |\r\n  | Method getDeclaredMethod(String name, Class<?>... parameterTypes) | 返回单个成员方法对象            |\r\n\r\n- 示例代码\r\n\r\n  ```java\r\n  public class Student {\r\n\r\n      //私有的，无参无返回值\r\n      private void show() {\r\n          System.out.println("私有的show方法，无参无返回值");\r\n      }\r\n\r\n      //公共的，无参无返回值\r\n      public void function1() {\r\n          System.out.println("function1方法，无参无返回值");\r\n      }\r\n\r\n      //公共的，有参无返回值\r\n      public void function2(String name) {\r\n          System.out.println("function2方法，有参无返回值,参数为" + name);\r\n      }\r\n\r\n      //公共的，无参有返回值\r\n      public String function3() {\r\n          System.out.println("function3方法，无参有返回值");\r\n          return "aaa";\r\n      }\r\n\r\n      //公共的，有参有返回值\r\n      public String function4(String name) {\r\n          System.out.println("function4方法，有参有返回值,参数为" + name);\r\n          return "aaa";\r\n      }\r\n  }\r\n  public class ReflectDemo1 {\r\n      public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException {\r\n          //method1();\r\n          //method2();\r\n          //method3();\r\n          //method4();\r\n          //method5();\r\n      }\r\n\r\n      private static void method5() throws ClassNotFoundException, NoSuchMethodException {\r\n          //        Method getDeclaredMethod(String name, Class<?>... parameterTypes)：\r\n  //                                返回单个成员方法对象\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect5.Student");\r\n          //2.获取一个成员方法show\r\n          Method method = clazz.getDeclaredMethod("show");\r\n          //3.打印一下\r\n          System.out.println(method);\r\n      }\r\n    \r\n      private static void method4() throws ClassNotFoundException, NoSuchMethodException {\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect5.Student");\r\n          //2.获取一个有形参的方法function2\r\n          Method method = clazz.getMethod("function2", String.class);\r\n          //3.打印一下\r\n          System.out.println(method);\r\n      }\r\n    \r\n      private static void method3() throws ClassNotFoundException, NoSuchMethodException {\r\n          //        Method getMethod(String name, Class<?>... parameterTypes) ：\r\n  //                                返回单个公共成员方法对象\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect5.Student");\r\n          //2.获取成员方法function1\r\n          Method method1 = clazz.getMethod("function1");\r\n          //3.打印一下\r\n          System.out.println(method1);\r\n      }\r\n    \r\n      private static void method2() throws ClassNotFoundException {\r\n          //        Method[] getDeclaredMethods()：\r\n  //                                返回所有成员方法对象的数组，不包括继承的\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect5.Student");\r\n    \r\n          //2.获取Method对象\r\n          Method[] methods = clazz.getDeclaredMethods();\r\n          //3.遍历一下数组\r\n          for (Method method : methods) {\r\n              System.out.println(method);\r\n          }\r\n      }\r\n    \r\n      private static void method1() throws ClassNotFoundException {\r\n          //        Method[] getMethods()：返回所有公共成员方法对象的数组，包括继承的\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect5.Student");\r\n          //2.获取成员方法对象\r\n          Method[] methods = clazz.getMethods();\r\n          //3.遍历\r\n          for (Method method : methods) {\r\n              System.out.println(method);\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n#### 2.5.2Method类用于执行方法的方法\r\n\r\n+ 方法介绍\r\n\r\n  | 方法名                                      | 说明   |\r\n  | ---------------------------------------- | ---- |\r\n  | Object invoke(Object obj, Object... args) | 运行方法 |\r\n\r\n  参数一: 用obj对象调用该方法\r\n\r\n  参数二: 调用方法的传递的参数(如果没有就不写)\r\n\r\n  返回值: 方法的返回值(如果没有就不写)\r\n\r\n+ 示例代码\r\n\r\n  ```java\r\n  public class ReflectDemo2 {\r\n      public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException {\r\n  //        Object invoke(Object obj, Object... args)：运行方法\r\n  //        参数一：用obj对象调用该方法\r\n  //        参数二：调用方法的传递的参数（如果没有就不写）\r\n  //        返回值：方法的返回值（如果没有就不写）\r\n\r\n          //1.获取class对象\r\n          Class clazz = Class.forName("com.itheima.myreflect5.Student");\r\n          //2.获取里面的Method对象  function4\r\n          Method method = clazz.getMethod("function4", String.class);\r\n          //3.运行function4方法就可以了\r\n          //3.1创建一个Student对象,当做方法的调用者\r\n          Student student = (Student) clazz.newInstance();\r\n          //3.2运行方法\r\n          Object result = method.invoke(student, "zhangsan");\r\n          //4.打印一下返回值\r\n          System.out.println(result);\r\n      }\r\n  }\r\n  ```\r\n\r\n## 3.http服务器改写\r\n\r\n### 3.1静态资源和动态资源【理解】\r\n\r\n![11_请求资源分类](./day25-基础加强01.img/11_请求资源分类.png)\r\n\r\n+ 静态资源\r\n\r\n  在服务器提前准备好的文件。(图片，文本)\r\n\r\n  ![09_静态资源](./day25-基础加强01.img/09_静态资源.png)\r\n\r\n+ 动态资源\r\n\r\n  在图示的案例中，当用户点击了浏览器上的按钮。\r\n  本质上访问的就是服务端的某一个类中的某一个方法。\r\n  在方法中，可以写一些判断代码和逻辑代码，让响应的内容，有可能不一样了。\r\n  那么，服务端所对应的这个类我们常常将其称之为“动态资源”\r\n\r\n  ![10_动态资源](./day25-基础加强01.img/10_动态资源.png)\r\n\r\n### 3.2准备工作【理解】\r\n\r\n+ 修改四个地方\r\n\r\n  + HttpResponse -> 常量WEB_APP_PATH的值与当前模块一致\r\n  + HttpServer -> main方法中端口改成80\r\n  + HttpResponse -> 添加一个write方法，添加一个带参数的构造方法\r\n  + HttpResponse -> 添加一个contentType成员变量，生成对应的set/get方法\r\n\r\n+ 示例代码\r\n\r\n  ```java\r\n  // 1.HttpResponse -> 常量WEB_APP_PATH的值与当前模块一致\r\n  public class HttpResponse {\r\n    ...\r\n    public static final String WEB_APP_PATH = "http-dynamic-server\\\\webapp";\r\n    ...\r\n  }\r\n\r\n  // 2.HttpServer -> main方法中端口改成80\r\n  public class HttpServer {\r\n    public static void main(String[] args) throws IOException {\r\n      ...\r\n      //2.让这个通道绑定一个端口\r\n    \tserverSocketChannel.bind(new InetSocketAddress(80));\r\n      ...\r\n    }\r\n  }  \r\n\r\n  // 3.HttpResponse -> 添加一个write方法，添加一个带参数的构造方法\r\n  public class HttpResponse {\r\n    ...\r\n    // 已经提供了selectionKey，所以之前的方法接收这个参数的可以去掉了，直接使用这个即可\r\n    // HttpRequest也按照此方式进行优化，定义成员变量，在构造方法中赋值，其他方法直接使用即可\r\n    private SelectionKey selectionKey;\r\n    \r\n    public HttpResponse(SelectionKey selectionKey) {\r\n          this.selectionKey = selectionKey;\r\n      }\r\n    \r\n    //给浏览器响应数据的方法 ---- 浏览器在请求动态资源时,响应数据的方法.\r\n    //content:响应的内容\r\n    public void write(String content){\r\n    }\r\n    ...\r\n  }\r\n\r\n  public class HttpServer {\r\n    public static void main(String[] args) throws IOException {\r\n      ...\r\n      //响应数据  //修改后的构造方法中要传入参数\r\n      HttpResponse httpResponse = new HttpResponse(selectionKey);\r\n      ...\r\n    }\r\n  }  \r\n\r\n  // 4.HttpResponse -> 添加一个contentType成员变量，生成对应的set/get方法\r\n  public class HttpResponse {\r\n    ...\r\n    private String contentType;//MIME类型\r\n    \r\n    public String getContentType() {\r\n          return contentType;\r\n      }\r\n    public void setContentTpye(String contentType) {\r\n          this.contentType = contentType;\r\n          //添加到map集合中\r\n          hm.put("Content-Type",contentType);\r\n      }\r\n    ...\r\n  }\r\n  ```\r\n\r\n### 3.3浏览器请求动态资源【理解】\r\n\r\n+ 两个小问题\r\n\r\n  + 服务器如何判断浏览器请求的是静态资源还是动态资源?\r\n\r\n    我们可以规定：如果浏览器地址栏中的uri是以”/servlet”开始的，那么就表示请求动态资源\r\n\r\n  + 在一个项目中有很多类，很多方法。那么请求过来之后，执行哪个方法呢?\r\n\r\n    写一个UserServlet类，在类中写service方法\r\n    我们可以规定：如果请求动态资源，就创建这个类对象，并调用service方法，表示服务器处理了当前请求\r\n\r\n+ 实现步骤\r\n\r\n  1. 解析http请求\r\n\r\n  2. 处理浏览器请求\r\n\r\n     定义一个UserServlet 类，类中定义service方法，处理浏览器请求动态资源\r\n     解析完http请求之后，再判断uri是否以/servlet开头\r\n\r\n  3. 响应\r\n\r\n+ 示例代码\r\n\r\n  ```java\r\n  public class UserServlet{\r\n    public void service(){\r\n          //模拟业务处理  ---- 就可以对这个手机号进行判断验证\r\n          System.out.println("UserServlet处理了用户的请求...");\r\n      }\r\n  }\r\n  public class HttpServer {\r\n    public static void main(String[] args) throws IOException {\r\n      \t...\r\n      \t//响应数据\r\n      \tHttpResponse httpResponse = new HttpResponse(selectionKey);\r\n          httpResponse.setHttpRequest(httpRequest);\r\n\r\n          if(httpRequest.getRequestURI().startsWith("/servlet")){\r\n            \t//本次请求动态资源\r\n            \t//处理 \r\n            \tUserServlet userServlet = new UserServlet();\r\n            \tuserServlet.service();\r\n            \t//响应\r\n          \thttpResponse.setContentTpye("text/html;charset=UTF-8");\r\n          \thttpResponse.write("ok,UserServlet处理了本次请求....");  \r\n          }else{\r\n            //本次请求静态资源\r\n            httpResponse.sendStaticResource();\r\n          }\r\n      \t...\r\n    }\r\n  } \r\n\r\n  public class HttpResponse {\r\n    \t...\r\n  \t//给浏览器响应数据的方法 ---- 浏览器在请求动态资源时,响应数据的方法.\r\n      //content:响应的内容\r\n      public void write(String content){\r\n          //准备响应行数据\r\n          this.version = "HTTP/1.1";\r\n          this.status = "200";\r\n          this.desc = "ok";\r\n\r\n          //把响应行拼接在一起\r\n          String responseLine = this.version + " " + this.status + " " + this.desc + "\\rn";\r\n\r\n          //准备响应头\r\n          StringBuilder sb = new StringBuilder();\r\n          Set<Map.Entry<String, String>> entries = hm.entrySet();\r\n          for (Map.Entry<String, String> entry : entries) {\r\n              //entry依次表示每一个键值对对象\r\n              //键 --- 响应头的名称\r\n              //值 --- 响应头的值\r\n              sb.append(entry.getKey()).append(": ").append(entry.getValue()).append("\\rn");\r\n          }\r\n\r\n          //处理响应空行\r\n          String emptyLine = "\\rn";\r\n\r\n          //拼接响应行,响应头,响应空行\r\n          String result = responseLine + sb.toString() + emptyLine;\r\n\r\n          try {\r\n              //给浏览器响应 响应行,响应头,响应空行\r\n              ByteBuffer byteBuffer1 = ByteBuffer.wrap(result.getBytes());\r\n              SocketChannel channel = (SocketChannel) selectionKey.channel();\r\n              channel.write(byteBuffer1);\r\n\r\n              //给浏览器响应 响应体\r\n              ByteBuffer byteBuffer2 = ByteBuffer.wrap(content.getBytes());\r\n              channel.write(byteBuffer2);\r\n\r\n              //释放资源\r\n              channel.close();\r\n\r\n          } catch (IOException e) {\r\n              System.out.println("响应数据失败....");\r\n              e.printStackTrace();\r\n          }\r\n\r\n      }    \r\n   \t ...\r\n  }\r\n  ```\r\n\r\n### 3.4main方法和Servlet优化【理解】\r\n\r\n+ main方法优化\r\n\r\n  + 需求\r\n\r\n    将请求动态资源的代码抽取到一个单独的类单独的方法中，简化main中的代码\r\n\r\n  + 代码实现\r\n\r\n    ```java\r\n    public class DynamicResourceProcess {\r\n      \r\n        //执行指定动态资源的service方法\r\n        //参数一\r\n        //由于后期可能根据用户请求的uri做出相应的处理.\r\n        //参数二\r\n        //要给用户响应数据,那么就需要使用到httpResponse.\r\n        public void process(HttpRequest httpRequest,HttpResponse httpResponse) {\r\n            // 创建UserServlet对象,调用service方法,进行处理\r\n            UserServlet userServlet = new UserServlet();\r\n            userServlet.service();\r\n\r\n            //给浏览器响应\r\n            httpResponse.setContentTpye("text/html;charset=UTF-8");\r\n            httpResponse.write("ok,UserServlet处理了本次请求....");\r\n        }\r\n    }\r\n\r\n    public class HttpServer {\r\n      public static void main(String[] args) throws IOException {\r\n        \t...\r\n        \t//响应数据\r\n        \tHttpResponse httpResponse = new HttpResponse(selectionKey);\r\n            httpResponse.setHttpRequest(httpRequest);\r\n\r\n            if(httpRequest.getRequestURI().startsWith("/servlet")){\r\n              \t//本次请求动态资源\r\n           \t\tDynamicResourceProcess drp = new DynamicResourceProcess();\r\n                drp.process(httpRequest,httpResponse);\r\n            }else{\r\n              //本次请求静态资源\r\n              httpResponse.sendStaticResource();\r\n            }\r\n        \t...\r\n      }\r\n    } \r\n    ```\r\n\r\n+ Servlet优化\r\n\r\n  + 需求\r\n\r\n    将给浏览器响应的代码写到Servlet中\r\n\r\n  + 代码实现\r\n\r\n    ```java\r\n    public class UserServlet implements HttpServlet{\r\n\r\n        //处理浏览器请求的方法\r\n        //参数一\r\n        //由于后期可能根据用户请求的uri做出相应的处理.\r\n        //参数二\r\n        //要给用户响应数据,那么就需要使用到httpResponse.\r\n        public void service(HttpRequest httpRequest, HttpResponse httpResponse){\r\n            //模拟业务处理  ---- 就可以对这个手机号进行判断验证\r\n            System.out.println("UserServlet处理了用户的请求...");\r\n            //给浏览器响应\r\n            httpResponse.setContentTpye("text/html;charset=UTF-8");\r\n            httpResponse.write("ok,UserServlet处理了本次请求....");\r\n        }\r\n    }\r\n\r\n    public class DynamicResourceProcess {\r\n      \r\n        //执行指定动态资源的service方法\r\n        //参数一\r\n        //由于后期可能根据用户请求的uri做出相应的处理.\r\n        //参数二\r\n        //要给用户响应数据,那么就需要使用到httpResponse.\r\n        public void process(HttpRequest httpRequest,HttpResponse httpResponse) {\r\n            // 创建UserServlet对象,调用service方法,进行处理\r\n            UserServlet userServlet = new UserServlet();\r\n            userServlet.service(httpRequest,httpResponse);\r\n        }\r\n    }\r\n    ```\r\n\r\n### 3.5多个动态资源【理解】\r\n\r\n+ 多个动态资源\r\n\r\n  针对每一个业务操作，我们都会去定义一个对应的Servlet来完成。\r\n  就会在服务端产生很多个Servlet\r\n\r\n  ![12_多个动态资源](./day25-基础加强01.img/12_多个动态资源.png)\r\n\r\n+ 实现步骤\r\n\r\n  + 定义一个接口HttpServlet，接口中定义service方法。\r\n  + 针对于每一种业务，都定义一个servlet类与之对应，该类实现HttpServlet接口\r\n  + 获取请求的uri，进行判断，调用不同的servlet类中的service方法\r\n\r\n+ 代码实现\r\n\r\n  ```java\r\n  // 1.定义一个接口HttpServlet，接口中定义service方法\r\n  public interface HttpServlet {\r\n\r\n      //定义业务处理的方法\r\n      public abstract void service(HttpRequest httpRequest, HttpResponse httpResponse);\r\n  }\r\n\r\n  // 2.针对于每一种业务，都定义一个servlet类与之对应，该类实现HttpServlet接口\r\n  public class UserServlet implements HttpServlet{\r\n      //处理浏览器请求的方法\r\n      //参数一\r\n      //由于后期可能根据用户请求的uri做出相应的处理.\r\n      //参数二\r\n      //要给用户响应数据,那么就需要使用到httpResponse.\r\n      public void service(HttpRequest httpRequest, HttpResponse httpResponse){\r\n          //模拟业务处理  ---- 就可以对这个手机号进行判断验证\r\n          System.out.println("UserServlet处理了用户的请求...");\r\n          //给浏览器响应\r\n          httpResponse.setContentTpye("text/html;charset=UTF-8");\r\n          httpResponse.write("ok,UserServlet处理了本次请求....");\r\n      }\r\n  }\r\n\r\n  public class LoginServlet implements HttpServlet{\r\n      @Override\r\n      public void service(HttpRequest httpRequest, HttpResponse httpResponse) {\r\n         //处理\r\n          System.out.println("LoginServlet处理了登录请求");\r\n         //响应\r\n          httpResponse.setContentTpye("text/html;charset=UTF-8");\r\n          httpResponse.write("登录成功");\r\n      }\r\n  }\r\n\r\n  public class RegisterServlet implements HttpServlet{\r\n      @Override\r\n      public void service(HttpRequest httpRequest, HttpResponse httpResponse) {\r\n         //处理\r\n          System.out.println("RegisterServlet处理了注册请求");\r\n         //响应\r\n          httpResponse.setContentTpye("text/html;charset=UTF-8");\r\n          httpResponse.write("注册成功");\r\n      }\r\n  }\r\n\r\n  public class SearchServlet implements HttpServlet{\r\n      @Override\r\n      public void service(HttpRequest httpRequest, HttpResponse httpResponse) {\r\n         //处理\r\n          System.out.println("SearchServlet处理了搜索商品请求");\r\n         //响应\r\n          httpResponse.setContentTpye("text/html;charset=UTF-8");\r\n          httpResponse.write("响应了一些商品信息");\r\n      }\r\n  }\r\n\r\n  // 3.获取请求的uri，进行判断，调用不同的servlet类中的service方法\r\n  public class DynamicResourceProcess {\r\n    \r\n      public void process(HttpRequest httpRequest,HttpResponse httpResponse){\r\n            //获取请求的uri\r\n            String requestURI = httpRequest.getRequestURI();\r\n   \r\n            //根据请求的uri进行判断\r\n            if("/servlet/loginservlet".equals(requestURI)){\r\n                //登录请求\r\n                LoginServlet loginServlet = new LoginServlet();\r\n                loginServlet.service(httpRequest,httpResponse);\r\n            }else if("/servlet/registerservlet".equals(requestURI)){\r\n                //注册请求\r\n                RegisterServlet registerServlet = new RegisterServlet();\r\n                registerServlet.service(httpRequest,httpResponse);\r\n            }else if("/servlet/searchservlet".equals(requestURI)){\r\n                //搜索商品请求\r\n                SearchServlet searchServlet = new SearchServlet();\r\n                searchServlet.service(httpRequest,httpResponse);\r\n            }else{\r\n                //表示默认处理方法\r\n                //创建UserServlet对象,调用service方法,进行处理\r\n                UserServlet userServlet = new UserServlet();\r\n                userServlet.service(httpRequest,httpResponse);\r\n            }\r\n        }\r\n  }\r\n  ```\r\n\r\n### 3.6通过反射和配置文件优化【理解】\r\n\r\n+ 优化步骤\r\n\r\n  1. 把Servlet信息写到properties配置文件中\r\n\r\n     格式为：servlet-info=/servlet/UserServlet，全类名；/servlet/loginServlet，全类名\r\n\r\n  2. 定义一个接口ServletConcurrentHashMap，接口中定义ConcurrentHashMap，该集合存储所有的servlet信息\r\n\r\n  3. 定义一个接口ParseServletConfig，该接口中定义一个方法（parse）\r\n\r\n  4. 定义ParseServletConfig的实现类，解析配置文件，并把配置文件中Servlet信息存到map集合中\r\n\r\n  5. 在main方法的第一行，开启一条线程执行解析配置文件的代码\r\n\r\n  6. 修改处理DynamicResourceProcess中的process方法\r\n\r\n     ![13_反射和配置文件优化](./day25-基础加强01.img/13_反射和配置文件优化.png)\r\n\r\n+ 代码实现\r\n\r\n  ```java\r\n  // 1.把Servlet信息写到properties配置文件中\r\n  // 在webapp\\config\\servlet-info.properties文件中，写入如下内容\r\n  servlet-info=/servlet/loginservlet,com.itheima.myservlet.LoginServlet;/servlet/registerservlet,com.itheima.myservlet.RegisterServlet;/servlet/searchservlet,com.itheima.myservlet.SearchServlet;/servlet/lostpasswordservlet,com.itheima.myservlet.LostPasswordServlet\r\n\r\n  // 2.定义一个接口ServletConcurrentHashMap，接口中定义ConcurrentHashMap，该集合存储所有的servlet信息\r\n  public interface ServletConcurrentHashMap {\r\n      //存储请求路径和对应的servlet的map集合\r\n      //键: 请求的uri\r\n      //值: 对应的Servlet对象\r\n      public static final ConcurrentHashMap<String,  HttpServlet> map = new ConcurrentHashMap<>();\r\n  }\r\n\r\n  // 3.定义一个接口ParseServletConfig，该接口中定义一个方法（parse）\r\n  public interface ParseServletConfig {\r\n      //解析数据的方法\r\n      public abstract void parse();\r\n  }\r\n\r\n  // 4.定义ParseServletConfig的实现类，解析配置文件，并把配置文件中Servlet信息存到map集合中\r\n  public class PropertiesParseServletConfig implements ParseServletConfig {\r\n      @Override\r\n      public void parse() {\r\n\r\n          try {\r\n              //1.读取配置文件中的数据\r\n              Properties properties = new Properties();\r\n              FileReader fr = new FileReader("http-dynamic-server/webapp/config/servlet-info.properties");\r\n              properties.load(fr);\r\n              fr.close();\r\n\r\n              //2.获取集合中servlet-info的属性值\r\n              String properValue = (String) properties.get("servlet-info");\r\n              // uri,全类名;uri,全类名\r\n\r\n              //3.解析\r\n              String[] split = properValue.split(";");\r\n              for (String servletInfo : split) {\r\n                  String[] servletInfoArr = servletInfo.split(",");\r\n                  String uri = servletInfoArr[0];\r\n                  String servletName = servletInfoArr[1];\r\n\r\n                  //我们需要通过servletName(全类名)来创建他的对象\r\n                  Class clazz = Class.forName(servletName);\r\n                  HttpServlet httpServlet = (HttpServlet) clazz.newInstance();\r\n                  //4.将uri和httpServlet添加到map集合中\r\n                  ServletConcurrentHashMap.map.put(uri,httpServlet);\r\n              }\r\n          } catch (Exception e) {\r\n              System.out.println("解析数据异常.....");\r\n              e.printStackTrace();\r\n          }\r\n      }\r\n  }\r\n\r\n  public class LoaderResourceRunnable implements  Runnable {\r\n      @Override\r\n      public void run() {\r\n          //执行parse方法\r\n          ParseServletConfig parseServletConfig = new PropertiesParseServletConfig();\r\n          parseServletConfig.parse();\r\n          \r\n      }\r\n  }\r\n\r\n  // 5.在main方法的第一行，开启一条线程执行解析配置文件的代码\r\n  public class HttpServer {\r\n      public static void main(String[] args) throws IOException {\r\n          //开启一条线程去解析配置文件\r\n          new Thread(new LoaderResourceRunnable()).start();\r\n          ...\r\n      }\r\n  }\r\n\r\n  // 6.修改处理DynamicResourceProcess中的process方法\r\n  public class DynamicResourceProcess {\r\n    \r\n      public void process(HttpRequest httpRequest,HttpResponse httpResponse){\r\n            \t//获取请求的uri\r\n            \tString requestURI = httpRequest.getRequestURI();\r\n            \t//根据请求的uri到map集合中直接找到对应的servlet的对象\r\n          \tHttpServlet httpServlet = ServletConcurrentHashMap.map.get(requestURI);\r\n              //调用service方法对请求进行处理并响应\r\n              httpServlet.service(httpRequest,httpResponse);\r\n      }\r\n  }    \r\n  ```\r\n\r\n### 3.7Servlet忘记实现HttpServlet接口处理【理解】\r\n\r\n+ 出现情况\r\n\r\n  在写Servlet时，忘记了实现HttpServlet接口\r\n\r\n+ 导致结果\r\n\r\n  在反射创建对象后，强转成HttpServlet时，会报类型转换异常\r\n\r\n+ 解决方案\r\n\r\n  在反射创建对象后，强转成HttpServlet前，进行判断\r\n\r\n  如果有实现HttpServlet接口，就进行强转\r\n\r\n  否则抛出一个异常\r\n\r\n+ 代码实现\r\n\r\n  ```java\r\n  public class PropertiesParseServletConfig implements ParseServletConfig {\r\n      @Override\r\n      public void parse() {\r\n\r\n          try {\r\n              //1.读取配置文件中的数据\r\n              Properties properties = new Properties();\r\n              FileReader fr = new FileReader("http-dynamic-server/webapp/config/servlet-info.properties");\r\n              properties.load(fr);\r\n              fr.close();\r\n\r\n              //2.获取集合中servlet-info的属性值\r\n              String properValue = (String) properties.get("servlet-info");\r\n              // uri,全类名;uri,全类名\r\n\r\n              //3.解析\r\n              String[] split = properValue.split(";");\r\n              for (String servletInfo : split) {\r\n                  String[] servletInfoArr = servletInfo.split(",");\r\n                  String uri = servletInfoArr[0];\r\n                  String servletName = servletInfoArr[1];\r\n\r\n                  //我们需要通过servletName(全类名)来创建他的对象\r\n                  Class clazz = Class.forName(servletName);\r\n\r\n                  //获取该类所实现的所有的接口信息,得到的是一个数组\r\n                  Class[] interfaces = clazz.getInterfaces();\r\n\r\n                  //定义一个boolean类型的变量\r\n                  boolean flag =  false;\r\n                  //遍历数组\r\n                  for (Class clazzInfo : interfaces) {\r\n                      //判断当前所遍历的接口的字节码对象是否和HttpServlet的字节码文件对象相同\r\n                      if(clazzInfo == HttpServlet.class){\r\n\r\n                          //如果相同,就需要更改flag值.结束循环\r\n                          flag = true;\r\n                          break;\r\n                      }\r\n                  }\r\n\r\n                  if(flag){\r\n                      //true就表示当前的类已经实现了HttpServlet接口\r\n                      HttpServlet httpServlet = (HttpServlet) clazz.newInstance();\r\n                      //4.将uri和httpServlet添加到map集合中\r\n                      ServletConcurrentHashMap.map.put(uri,httpServlet);\r\n                  }else{\r\n                      //false就表示当前的类还没有实现HttpServlet接口\r\n                      throw new NotImplementsHttpServletException(clazz.getName() + "Not Implements HttpServlet");\r\n                  }\r\n              }\r\n          } catch (NotImplementsHttpServletException e) {\r\n              e.printStackTrace();\r\n          }catch (Exception e) {\r\n              System.out.println("解析数据异常.....");\r\n              e.printStackTrace();\r\n          }\r\n      }\r\n  }\r\n\r\n  ```\r\n\r\n### 3.8响应404【理解】\r\n\r\n+ 出现情况\r\n\r\n  客户端浏览器请求了一个服务器中不存在的动态资源\r\n\r\n+ 导致结果\r\n\r\n  服务器中代码出现异常，程序停止\r\n\r\n+ 解决方案\r\n\r\n  如果请求的动态资源不存在，服务器根据请求的uri找到对应的Servlet时为null，继续调用方法会出现异常\r\n\r\n  增加一个非空的判断，如果不为null，则继续处理请求，调用方法\r\n\r\n  如果为null，则响应404\r\n\r\n+ 代码实现\r\n\r\n  ```java\r\n  public class DynamicResourceProcess {\r\n      //执行指定动态资源的service方法\r\n      //参数一\r\n      //由于后期可能根据用户请求的uri做出相应的处理.\r\n      //参数二\r\n      //要给用户响应数据,那么就需要使用到httpResponse.\r\n      public void process(HttpRequest httpRequest,HttpResponse httpResponse){\r\n          //获取请求的uri\r\n          String requestURI = httpRequest.getRequestURI();\r\n          //根据请求的uri到map集合中直接找到对应的servlet的对象\r\n          HttpServlet httpServlet = ServletConcurrentHashMap.map.get(requestURI);\r\n          if(httpServlet != null){\r\n              //调用service方法对请求进行处理并响应\r\n              httpServlet.service(httpRequest,httpResponse);\r\n          }else{\r\n              //浏览器请求的动态资源不存在\r\n              //响应404\r\n              response404(httpResponse);\r\n          }\r\n      }\r\n      //浏览器请求动态资源不存在,响应404的方法\r\n      private void response404(HttpResponse httpResponse) {\r\n          try {\r\n              //准备响应行\r\n              String responseLine = "HTTP/1.1 404 NOT FOUND\\rn";\r\n              //准备响应头\r\n              String responseHeader = "Content-Type: text/html;charset=UTF-8\\rn";\r\n              //准备响应空行\r\n              String emptyLine = "\\rn";\r\n              //拼接在一起\r\n              String result = responseLine + responseHeader + emptyLine;\r\n\r\n              //把响应行,响应头,响应空行去响应给浏览器\r\n              SelectionKey selectionKey = httpResponse.getSelectionKey();\r\n              SocketChannel channel = (SocketChannel) selectionKey.channel();\r\n\r\n              ByteBuffer byteBuffer1 = ByteBuffer.wrap(result.getBytes());\r\n              channel.write(byteBuffer1);\r\n\r\n              //给浏览器 响应 响应体内容\r\n              ByteBuffer byteBuffer2 = ByteBuffer.wrap("404 NOT FOUND....".getBytes());\r\n              channel.write(byteBuffer2);\r\n\r\n              //释放资源\r\n              channel.close();\r\n          } catch (IOException e) {\r\n              e.printStackTrace();\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n  ​\r\n\r\n'},3879:function(n,e,t){"use strict";t.r(e),e["default"]='# AOP\n\n## 1)AOP简介\n\n### 1.1)OOP开发思路\n\n![1591281580135](./Spring-day03/1591281580135.png)\n\n### 1.2)AOP开发思想\n\n![1591281706237](./Spring-day03/1591281706237.png)\n\n### 1.3)AOP概念\n\n- AOP(Aspect Oriented Programing)面向切面编程，一种编程**范式**，隶属于软工范畴，指导开发者如何组织程序结构\n\n- AOP弥补了OOP的不足，基于OOP基础之上进行横向开发\n\n  - uOOP规定程序开发以类为主体模型，一切围绕对象进行，完成某个任务先构建模型\n\n  - uAOP程序开发主要关注基于OOP开发中的共性功能，一切围绕共性功能进行，完成某个任务先构建可能遇到的所有共性功能（当所有功能都开发出来也就没有共性与非共性之分）\n\n- “AOP联盟”\n\n### 1.4)AOP作用\n\n- 伴随着AOP时代的降临，可以从各个行业的标准化、规范化开始入手，一步一步将所有共性功能逐一开发完毕，最终以功能组合来完成个别业务模块乃至整体业务系统的开发\n\n- 目标：将软件开发由手工制作走向半自动化/全自动化阶段，实现“插拔式组件体系结构”搭建\n\n### 1.5)AOP优势\n\n- 提高代码的可重用性\n\n- 业务代码编码更简洁\n\n- 业务代码维护更高效\n\n- 业务功能扩展更便捷\n\n![1591281844901](./Spring-day03/1591281844901.png)\n\n\n\n## 2)AOP入门案例\n\n### 2.1)AOP相关概念\n\n![1591281889446](./Spring-day03/1591281889446.png)\n\n![1591281914574](./Spring-day03/1591281914574.png)\n\n![1591281945260](./Spring-day03/1591281945260.png)\n\n- Joinpoint(连接点)：就是方法\n\n- Pointcut(切入点)：就是挖掉共性功能的方法\n\n- Advice(通知)：就是共性功能，最终以一个方法的形式呈现\n\n- Aspect(切面)：就是共性功能与挖的位置的对应关系\n\n- Target(目标对象)：就是挖掉功能的方法对应的类产生的对象，这种对象是无法直接完成最终工作的\n\n- Weaving(织入)：就是将挖掉的功能回填的动态过程\n\n- Proxy(代理)：目标对象无法直接完成工作，需要对其进行功能回填，通过创建原始对象的代理对象实现\n\n- Introduction(引入/引介) ：就是对原始对象无中生有的添加成员变量或成员方法\n\n### 2.2)AOP开发过程\n\n- 开发阶段(开发者完成)\n\n  - 正常的制作程序\n\n  - 将非共性功能开发到对应的目标对象类中，并制作成切入点方法\n\n  - 将共性功能独立开发出来，制作成**通知**\n\n  - 在配置文件中，声明**切入点**\n\n  - 在配置文件中，声明**切入点**与**通知**间的关系（含**通知类型**），即**切面**\n\n- 运行阶段(AOP完成)\n\n  - Spring容器加载配置文件，监控所有配置的**切入点**方法的执行\n\n  - 当监控到**切入点**方法被运行，使用**代理**机制，动态创建**目标对象**的**代理对象**，根据**通知类别**，在**代理对象**的对应位置将**通知**对应的功能**织入**，完成完整的代码逻辑并运行\n\n### 2.2)AOP开发方式\n\n- XML方式\n\n- XML+注解方式\n\n- 注解方式\n\n### 2.3)入门案例制作分析\n\n1.导入相关坐标\n\n2.确认要抽取的功能，并将其制作成方法保存到专用的类中，删除原始业务中对应的功能\n\n3.将所有进行AOP操作的资源加载到IoC容器中\n\n4.使用配置的方式描述被抽取功能的位置，并描述被抽取功能与对应位置的关系\n\n5.运行程序\n\n\n\n步骤一 导入坐标\n\n```xml\n<dependency>\n    <groupId>org.aspectj</groupId>\n    <artifactId>aspectjweaver</artifactId>\n    <version>1.9.4</version>\n</dependency>\n```\n\n步骤二 在业务层抽取通用代码\n\n![1591282302976](./Spring-day03/1591282302976.png)\n\n步骤三 把通知加入spring容器管理\n\n![1591282320624](./Spring-day03/1591282320624.png)\n\n\n\n步骤四 在配置文件中配置aop的配置 \n\n```xml\n\x3c!--aop配置--\x3e\n<aop:config>\n    \x3c!--配置切入点--\x3e\n    <aop:pointcut id="pt" expression="execution(* *..*())"/>\n    \x3c!--配置切面--\x3e\n    <aop:aspect ref="myAdvice">\n        <!—通知与切入点之间的关系--\x3e\n        <aop:before method="logAdvice" pointcut-ref="pt"/>\n    </aop:aspect>\n</aop:config>\n```\n\n## 3)AOP配置（XML）\n\n### 3.1)**AspectJ**\n\n- Aspect（切面）用于描述切入点与通知间的关系，是AOP编程中的一个概念\n\n- AspectJ是基于java语言对Aspect的实现\n\n### 3.2)AOP配置\n\n#### 3.2.1)aop:config\n\n- 名称：aop:config\n\n- 类型：**标签**\n\n- 归属：beans标签\n\n- 作用：设置AOP\n\n- 格式：\n\n  ```xml\n  <beans>\n      <aop:config>……</aop:config>\n      <aop:config>……</aop:config>\n  </beans>\n  ```\n\n- 说明：一个beans标签中可以配置多个aop:config标签\n\n#### 3.2.2)aop:aspect\n\n- 名称：aop:aspect\n\n- 类型：**标签**\n\n- 归属：aop:config标签\n\n- 作用：设置具体的AOP通知对应的切入点\n\n- 格式：\n\n  ```xml\n  <aop:config>\n      <aop:aspect ref="beanId">……</aop:aspect>\n      <aop:aspect ref="beanId">……</aop:aspect>\n  </aop:config>\n  ```\n\n- 说明：\n\n  一个aop:config标签中可以配置多个aop:aspect标签\n\n- 基本属性：\n\n  - ref ：通知所在的bean的id\n\n#### 3.2.3)aop:pointcut\n\n- 名称：aop:pointcut\n\n- 类型：**标签**\n\n- 归属：aop:config标签、aop:aspect标签\n\n- 作用：设置切入点\n\n- 格式：\n\n  ```xml\n  <aop:config>\n      <aop:pointcut id="pointcutId" expression="……"/>\n      <aop:aspect>\n          <aop:pointcut id="pointcutId" expression="……"/>\n      </aop:aspect>\n  </aop:config>\n  ```\n\n- 说明：\n\n  一个aop:config标签中可以配置多个aop:pointcut标签，且该标签可以配置在aop:aspect标签内\n\n- 基本属性：\n\n  - id ：识别切入点的名称\n\n  - expression ：切入点表达式\n\n### **3.3)切入点**\n\n- 切入点描述的是某个方法\n\n- 切入点表达式是一个快速匹配方法描述的通配格式，类似于正则表达式\n\n### **3.4)切入点表达式的组成**\n\n- 切入点描述的是某个方法\n\n- 切入点表达式是一个快速匹配方法描述的通配格式，类似于正则表达式\n\n  ```xml\n  关键字（访问修饰符  返回值  包名.类名.方法名（参数）异常名）\n  ```\n\n​\t关键字：描述表达式的匹配模式（参看关键字列表）\n\n​\t访问修饰符：方法的访问控制权限修饰符\n\n​\t类名：方法所在的类（此处可以配置接口名称）\n\n​\t异常：方法定义中指定抛出的异常\n\n- 范例：\n\n  ```xml\n  execution（public User com.itheima.service.UserService.findById（int））\n  ```\n\n#### 3.4.1)切入点表达式——关键字\n\n- execution ：匹配执行指定方法\n\n- args ：匹配带有指定参数类型的方法\n\n- within ：…… \n\n- this ：…… \n\n- target ：…… \n\n- @within ：…… \n\n- @target ：…… \n\n- @args ：…… \n\n- @annotation ：…… \n\n- bean ：……\n\n- reference pointcut ：……\n\n#### 3.4.2)切入点表达式——**通配符**\n\n- *：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现\n\n  ```xml\n  execution（public * com.itheima.*.UserService.find*（*））\n  ```\n\n​\t匹配com.itheima包下的任意包中的UserService类或接口中所有find开头的带有一个参数的方法\n\n- .. ：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写\n\n  ```xml\n  execution（public User com..UserService.findById（..））\n  ```\n\n​\t匹配com包下的任意包中的UserService类或接口中所有名称为findById的方法\n\n- +：专用于匹配子类类型\n\n  ```xml\n  execution(* *..*Service+.*(..))\n  ```\n\n#### 3.4.3)切入点表达式——逻辑运算符\n\n- && ：连接两个切入点表达式，表示两个切入点表达式同时成立的匹配\n\n- || ：连接两个切入点表达式，表示两个切入点表达式成立任意一个的匹配\n\n- ! ：连接单个切入点表达式，表示该切入点表达式不成立的匹配\n\n#### 3.4.4)切入点表达式——范例\n\n```java\nexecution(* *(..))\nexecution(* *..*(..))\nexecution(* *..*.*(..))\nexecution(public * *..*.*(..))\nexecution(public int *..*.*(..))\nexecution(public void *..*.*(..))\nexecution(public void com..*.*(..)) \nexecution(public void com..service.*.*(..))\nexecution(public void com.itheima.service.*.*(..))\nexecution(public void com.itheima.service.User*.*(..))\nexecution(public void com.itheima.service.*Service.*(..))\nexecution(public void com.itheima.service.UserService.*(..))\nexecution(public User com.itheima.service.UserService.find*(..))\nexecution(public User com.itheima.service.UserService.*Id(..))\nexecution(public User com.itheima.service.UserService.findById(..))\nexecution(public User com.itheima.service.UserService.findById(int))\nexecution(public User com.itheima.service.UserService.findById(int,int))\nexecution(public User com.itheima.service.UserService.findById(int,*))\nexecution(public User com.itheima.service.UserService.findById(*,int))\nexecution(public User com.itheima.service.UserService.findById())\nexecution(List com.itheima.service.*Service+.findAll(..))\n```\n\n### **3.5)切入点的三种配置方式**\n\n```xml\n<aop:config>\n    \x3c!--配置公共切入点--\x3e\n    <aop:pointcut id="pt1" expression="execution(* *(..))"/>\n    <aop:aspect ref="myAdvice">\n        \x3c!--配置局部切入点--\x3e\n        <aop:pointcut id="pt2" expression="execution(* *(..))"/>\n        \x3c!--引用公共切入点--\x3e\n        <aop:before method="logAdvice" pointcut-ref="pt1"/>\n        \x3c!--引用局部切入点--\x3e\n        <aop:before method="logAdvice" pointcut-ref="pt2"/>\n        \x3c!--直接配置切入点--\x3e\n        <aop:before method="logAdvice" pointcut="execution(* *(..))"/>\n    </aop:aspect>\n</aop:config>\n```\n\n### **3.6)切入点配置经验**\n\n- 企业开发命名规范严格遵循规范文档进行\n\n- 先为方法配置局部切入点\n\n- 再抽取类中公共切入点\n\n- 最后抽取全局切入点\n\n- 代码走查过程中检测切入点是否存在越界性包含\n\n- 代码走查过程中检测切入点是否存在非包含性进驻\n\n- 设定AOP执行检测程序，在单元测试中监控通知被执行次数与预计次数是否匹配\n\n- 设定完毕的切入点如果发生调整务必进行回归测试\n\n（以上规则适用于XML配置格式）\n\n### **3.7)通知类型**\n\nAOP的通知类型共5种\n\n- 前置通知：原始方法执行前执行，如果通知中抛出异常，阻止原始方法运行\n\n  应用：数据校验\n\n- 后置通知：原始方法执行后执行，无论原始方法中是否出现异常，都将执行通知\n\n    应用：现场清理\n\n- 返回后通知：原始方法正常执行完毕并返回结果后执行，如果原始方法中抛出异常，无法执行\n\n    应用：返回值相关数据处理\n\n- 抛出异常后通知：原始方法抛出异常后执行，如果原始方法没有抛出异常，无法执行\n\n    应用：对原始方法中出现的异常信息进行处理\n\n- 环绕通知：在原始方法执行前后均有对应执行执行，还可以阻止原始方法的执行\n\n    应用：十分强大，可以做任何事情\n\n#### 3.7.1)aop:before\n\n- 名称：aop:before\n\n- 类型：**标签**\n\n- 归属：aop:aspect标签\n\n- 作用：设置前置通知\n\n- 格式：\n\n  ```xml\n  <aop:aspect ref="adviceId">\n      <aop:before method="methodName" pointcut="……"/>\n  </aop:aspect>\n  ```\n\n-  说明：一个aop:aspect标签中可以配置多个aop:before标签\n\n- 基本属性：\n\n  - method ：在通知类中设置当前通知类别对应的方法\n\n  - pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突\n\n  - pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突\n\n#### 3.7.2)aop:after\n\n- 名称：aop:after\n\n- 类型：**标签**\n\n- 归属：aop:aspect标签\n\n- 作用：设置后置通知\n\n- 格式：\n\n  ```xml\n  <aop:aspect ref="adviceId">\n      <aop:after method="methodName" pointcut="……"/>\n  </aop:aspect>\n  ```\n\n-  说明：一个aop:aspect标签中可以配置多个aop:after标签\n\n- 基本属性：\n\n  - method ：在通知类中设置当前通知类别对应的方法\n\n  - pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突\n\n  - pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突\n\n#### 3.7.3)aop:after-returning\n\n- 名称：aop:after-returning\n\n- 类型：**标签**\n\n- 归属：aop:aspect标签\n\n- 作用：设置返回后通知\n\n- 格式：\n\n  ```xml\n  <aop:aspect ref="adviceId">\n      <aop:after-returning method="methodName" pointcut="……"/>\n  </aop:aspect>\n  ```\n\n-  说明：一个aop:aspect标签中可以配置多个aop:after-returning标签\n\n- 基本属性：\n\n  - method ：在通知类中设置当前通知类别对应的方法\n\n  - pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突\n\n  - pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突\n\n#### 3.7.4)aop:after-throwing\n\n- 名称：aop:after-throwing\n\n- 类型：**标签**\n\n- 归属：aop:aspect标签\n\n- 作用：设置抛出异常后通知\n\n- 格式：\n\n  ```xml\n  <aop:aspect ref="adviceId">\n      <aop:after-throwing method="methodName" pointcut="……"/>\n  </aop:aspect>\n  ```\n\n-  说明：一个aop:aspect标签中可以配置多个aop:after-throwing标签\n\n- 基本属性：\n\n  - method ：在通知类中设置当前通知类别对应的方法\n\n  - pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突\n\n  - pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突\n\n#### 3.7.5)aop:around\n\n- 名称：aop:around\n\n- 类型：**标签**\n\n- 归属：aop:aspect标签\n\n- 作用：设置环绕通知\n\n- 格式：\n\n  ```xml\n  <aop:aspect ref="adviceId">\n      <aop:around method="methodName" pointcut="……"/>\n  </aop:aspect>\n  ```\n\n-  说明：一个aop:aspect标签中可以配置多个aop:around标签\n\n- 基本属性：\n\n  - method ：在通知类中设置当前通知类别对应的方法\n\n  - pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突\n\n  - pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突\n\n环绕通知的开发方式\n\n- 环绕通知是在原始方法的前后添加功能，在环绕通知中，存在对原始方法的显式调用\n\n  ```java\n  public Object around(ProceedingJoinPoint pjp) throws Throwable {\n      Object ret = pjp.proceed();\n      return ret;\n  }\n  ```\n\n- 环绕通知方法相关说明：\n\n  - 方法须设定Object类型的返回值，否则会拦截原始方法的返回。如果原始方法返回值类型为void，通知方\t也可以设定返回值类型为void，最终返回null\n\n  - 方法需在第一个参数位置设定ProceedingJoinPoint对象，通过该对象调用proceed()方法，实现对原始方法的调用。如省略该参数，原始方法将无法执行\n\n  - 使用proceed()方法调用原始方法时，因无法预知原始方法运行过程中是否会出现异常，强制抛出Throwable对象，封装原始方法中可能出现的异常信息\n\n### **3.8)通知顺序（了解）**\n\n当同一个切入点配置了多个通知时，通知会存在运行的先后顺序，该顺序以通知配置的顺序为准\n\n### **3.9)通知获取数据**\n\n- 参数\n\n- 返回值\n\n- 异常\n\n#### **3.9.1)通知获取参数数据**\n\n第一种情况：\n\n- 设定通知方法第一个参数为JoinPoint，通过该对象调用getArgs()方法，获取原始方法运行的参数数组\n\n  ```java\n  public void before(JoinPoint jp) throws Throwable {\n      Object[] args = jp.getArgs();\n  }\n  ```\n\n- 所有的通知均可以获取参数\n\n第二种情况：\n\n- 设定切入点表达式为通知方法传递参数（锁定通知变量名）\n\n- 原始方法\n\n![1591284387913](./Spring-day03/1591284387913.png)\n\n第三种情况\n\n- 设定切入点表达式为通知方法传递参数（改变通知变量名的定义顺序）\n\n- 原始方法\n\n![1591284429541](./Spring-day03/1591284429541.png)\n\n#### **3.9.2)通知获取返回值数据**\n\n第一种：返回值变量名\n\n- 设定返回值变量名\n\n- 原始方法\n\n  ```java\n  public int save() {\n  \tSystem.out.println("user service running...");\n      return 100;\n  }\n  ```\n\n-  AOP配置\n\n  ```xml\n  <aop:aspect ref="myAdvice">\n      <aop:pointcut id="pt3" expression="execution(* *(..))  "/>\n      <aop:after-returning method="afterReturning" pointcut-ref="pt3" returning="ret"/>\n  </aop:aspect>\n  ```\n\n- 通知类\n\n  ```java\n  public void afterReturning(Object ret) {\n      System.out.println(ret);\n  }\n  ```\n\n- 适用于返回后通知（after-returning）\n\n第二种：\n\n- 在通知类的方法中调用原始方法获取返回值\n\n- 原始方法\n\n  ```java\n  public int save() {\n      System.out.println("user service running...");\n      return 100;\n  }\n  ```\n\n- AOP配置l\n\n  ```xml\n  <aop:aspect ref="myAdvice">\n      <aop:pointcut id="pt2" expression="execution(* *(..))  "/>\n      <aop:around method="around" pointcut-ref="pt2" />\n  </aop:aspect>\n  ```\n\n- 通知类\n\n  ```java\n  public Object around(ProceedingJoinPoint pjp) throws Throwable {\n      Object ret = pjp.proceed();\n      return ret;\n  }\n  ```\n\n- 适用于环绕通知（around）\n\n#### **3.9.3)通知获取异常数据**\n\n第一种：通知类的方法中调用原始方法捕获异常\n\n- 在通知类的方法中调用原始方法捕获异常\n\n- 原始方法\n\n  ```java\n  public void save() {\n      System.out.println("user service running...");\n      int i = 1/0;\n  }\n  ```\n\n-  AOP配置\n\n  ```xml\n  <aop:aspect ref="myAdvice">\n      <aop:pointcut id="pt4" expression="execution(* *(..))  "/>\n      <aop:around method="around" pointcut-ref="pt4" />\n  </aop:aspect>\n  ```\n\n- 通知类\n\n  ```java\n  public Object around(ProceedingJoinPoint pjp) throws Throwable {\n      Object ret = pjp.proceed();\t//对此处调用进行try……catch……捕获异常，或抛出异常\n      return ret;\n  }\n  ```\n\n- 适用于环绕通知（around）\n\n第二种：\n\n- 设定异常对象变量名\n\n- 原始方法\n\n  ```java\n  public void save() {\n      System.out.println("user service running...");\n      int i = 1/0;\n  }\n  ```\n\n-  AOP配置\n\n  ```xml\n  <aop:aspect ref="myAdvice">\n  \t<aop:pointcut id="pt4" expression="execution(* *(..))  "/>\n      <aop:after-throwing method="afterThrowing" pointcut-ref="pt4" throwing="t"/>\n  </aop:aspect>\n  ```\n\n- 通知类\n\n  ```java\n  public void afterThrowing(Throwable t){\n      System.out.println(t.getMessage());\n  }\n  ```\n\n- 适用于返回后通知（after-throwing）\n\n## 4)AOP配置（注解）\n\n### 4.1)AOP配置\n\n![1591285050618](./Spring-day03/1591285050618.png)\n\n### 4.2)注解开发AOP制作步骤\n\n在XML格式基础上\n\n- 导入坐标（伴随spring-context坐标导入已经依赖导入完成）\n\n- 开启AOP注解支持\n\n- 配置切面@Aspect\n\n- 定义专用的切入点方法，并配置切入点@Pointcut\n\n- 为通知方法配置通知类型及对应切入点@Before\n\n### 4.3)注解开发AOP注意事项\n\n1.切入点最终体现为一个方法，无参无返回值，无实际方法体内容，但不能是抽象方法\n\n2.引用切入点时必须使用方法调用名称，方法后面的（）不能省略\n\n3.切面类中定义的切入点只能在当前类中使用，如果想引用其他类中定义的切入点使用“类名.方法名()”引用\n\n4.可以在通知类型注解后添加参数，实现XML配置中的属性，例如after-returning后的returning属性\n\n![1591285152119](./Spring-day03/1591285152119.png)\n\n### 4.4)AOP注解详解\n\n#### 4.4.1)@Aspect\n\n- 名称：@Aspect\n\n- 类型：**注解**\n\n- 位置：类定义上方\n\n- 作用：设置当前类为切面类\n\n- 格式：\n\n  ```java\n  @Aspect\n  public class AopAdvice {\n  }\n  ```\n\n- 说明：一个beans标签中可以配置多个aop:config标签\n\n#### 4.4.2)@Pointcut\n\n- 名称：@Pointcut\n\n- 类型：**注解**\n\n- 位置：方法定义上方\n\n- 作用：使用当前方法名作为切入点引用名称\n\n- 格式：\n\n  ```java\n  @Pointcut("execution(* *(..))")\n  public void pt() {\n  }\n  ```\n\n- 说明：被修饰的方法忽略其业务功能，格式设定为无参无返回值的方法，方法体内空实现（非抽象）\n\n#### 4.4.3)@Before\n\n- 名称：@Before\n\n- 类型：**注解**\n\n- 位置：方法定义上方\n\n- 作用：标注当前方法作为前置通知\n\n- 格式：\n\n  ```java\n  @Before("pt()")\n  public void before(){\n  }\n  ```\n\n- 特殊参数：\n\n  - 无\n\n#### 4.4.4)@After\n\n- 名称：@After\n\n- 类型：**注解**\n\n- 位置：方法定义上方\n\n- 作用：标注当前方法作为后置通知\n\n- 格式：\n\n  ```java\n  @After("pt()")\n  public void after(){\n  }\n  ```\n\n- 特殊参数：\n\n  - 无\n\n#### 4.4.5)@AfterReturning\n\n- 名称：@AfterReturning\n\n- 类型：**注解**\n\n- 位置：方法定义上方\n\n- 作用：标注当前方法作为返回后通知\n\n- 格式：\n\n  ```java\n  @AfterReturning(value="pt()",returning = "ret")\n  public void afterReturning(Object ret) {\n  }\n  ```\n\n- 特殊参数：\n\n  - returning ：设定使用通知方法参数接收返回值的变量名\n\n#### 4.4.6)@AfterThrowing\n\n- 名称：@AfterThrowing\n\n- 类型：**注解**\n\n- 位置：方法定义上方\n\n- 作用：标注当前方法作为异常后通知\n\n- 格式：\n\n  ```java\n  @AfterThrowing(value="pt()",throwing = "t")\n  public void afterThrowing(Throwable t){\n  }\n  ```\n\n- 特殊参数：\n\n  - throwing ：设定使用通知方法参数接收原始方法中抛出的异常对象名\n\n#### 4.4.7)@Around\n\n- 名称：@Around\n\n- 类型：**注解**\n\n- 位置：方法定义上方\n\n- 作用：标注当前方法作为环绕通知\n\n- 格式：\n\n  ```java\n  @Around("pt()")\n  public Object around(ProceedingJoinPoint pjp) throws Throwable {\n      Object ret = pjp.proceed();\n      return ret;\n  }\n  ```\n\n- 特殊参数：\n\n  - 无\n\n### 4.5)AOP注解开发通知执行顺序控制（了解）\n\n1.AOP使用XML配置情况下，通知的执行顺序由配置顺序决定，在注解情况下由于不存在配置顺序的概念的概念，参照通知所配置的方法名字符串对应的编码值顺序，可以简单理解为字母排序\n\n- 同一个通知类中，相同通知类型以方法名排序为准\n\n- 不同通知类中，以类名排序为准\n\n- 使用@Order注解通过变更bean的加载顺序改变通知的加载顺序\n\n2.企业开发经验\n\n- 通知方法名由3部分组成，分别是前缀、顺序编码、功能描述\n\n- 前缀为固定字符串，例如baidu、itheima等，无实际意义\n\n- 顺序编码为6位以内的整数，通常3位即可，不足位补0\n\n- 功能描述为该方法对应的实际通知功能，例如exception、strLenCheck\n\n  - 制通知执行顺序使用顺序编码控制，使用时做一定空间预留\n\n  - 003使用，006使用，预留001、002、004、005、007、008\n\n  - 使用时从中段开始使用，方便后期做前置追加或后置追加\n\n  - 最终顺序以运行顺序为准，以测试结果为准，不以设定规则为准\n\n### 4.6)AOP注解驱动\n\n- 名称：@EnableAspectJAutoProxy\n\n- 类型：**注解**\n\n- 位置：Spring注解配置类定义上方\n\n- 作用：设置当前类开启AOP注解驱动的支持，加载AOP注解\n\n- 格式：\n\n  ```java\n  @Configuration\n  @ComponentScan("com.itheima")\n  @EnableAspectJAutoProxy\n  public class SpringConfig {\n  }\n  ```\n\n## 5)综合案例\n\n### **5.1)案例介绍**\n\n对项目进行业务层接口执行监控，测量业务层接口的执行效率\n\n```java\npublic interface AccountService {\n    void save(Account account);\n    void delete(Integer id);\n    void update(Account account);\n    List<Account> findAll();\n    Account findById(Integer id);\n}\n```\n\n### **5.2)案例分析**\n\n- 测量接口执行效率：接口方法执行前后获取执行时间，求出执行时长\n  - System.currentTimeMillis( )\n\n- 对项目进行监控：项目中所有接口方法，AOP思想，执行期动态织入代码\n\n  - 环绕通知\n\n  - proceed()方法执行前后获取系统时间\n\n### **5.3)案例制作步骤**\n\n- 定义切入点（务必要绑定到接口上，而不是接口实现类上）\n\n- 制作AOP环绕通知，完成测量功能\n\n- 注解配置AOP\n\n- 开启注解驱动支持\n\n### **5.4)案例制作核心代码**\n\n```java\npublic class RunTimeMonitorAdvice {\n    //拦截所有的业务层接口中查询操作的执行\n    @Pointcut("execution(* com.itheima.service.*Service.find*(..))")\n    public void pt(){}\n    @Around("pt()")\n    public Object runtimeMonitor(ProceedingJoinPoint pjp) throws Throwable {\n        //获取执行签名信息\n        Signature signature = pjp.getSignature();\n        //通过签名获取执行类型（接口名）\n        String targetClass = signature.getDeclaringTypeName();\n        //通过签名获取执行操作名称（方法名）\n        String targetMethod = signature.getName();\n        //获取操作前系统时间beginTime\n        long beginTime = System.currentTimeMillis();\n        Object ret = pjp.proceed(pjp.getArgs());\n        //获取操作后系统时间endTime\n        long endTime = System.currentTimeMillis();\n        System.out.println(targetClass+" 中 "+targetMethod+" 运行时长 "+(endTime-beginTime)+"ms");\n        return ret;\n    }\n}\n```\n\n### **5.5)案例后续思考与设计**\n\n- 测量真实性\n\n  - 开发测量是隔离性反复执行某个操作，是理想情况，上线测量差异过大\n\n  - 上线测量服务器性能略低于单机开发测量\n\n  - 上线测量基于缓存的性能查询要优于数据库查询测量\n\n  - 上线测量接口的性能与最终对外提供的服务性能差异过大\n\n  - 当外部条件发生变化（硬件），需要进行回归测试，例如数据库迁移\n\n- 测量结果展示\n\n  - 测量结果无需每一个都展示，需要设定检测阈值\n\n  - 阈值设定要根据业务进行区分，一个复杂的查询与简单的查询差异化很大\n\n  - 阈值设定需要做独立的配置文件或通过图形工具配置（工具级别的开发）\n\n  - 配合图形界面展示测量结果\n\n\n\n## 6)AOP底层原理\n\n- 静态代理\n\n- 动态代理——Proxy\n\n- 动态代理——CGLIB\n\n- 织入形式\n\n### **6.1)静态代理**\n\n装饰者模式（Decorator Pattern）：在不惊动原始设计的基础上，为其添加功能\n\n![1591287238806](./Spring-day03/1591287238806.png)\n\n```java\npublic class UserServiceDecorator implements UserService{\n    private UserService userService;\n    public UserServiceDecorator(UserService userService) {\n        this.userService = userService;\n    }\n    public void save() {\n        //原始调用\n        userService.save();\n        //增强功能（后置）\n        System.out.println("刮大白");\n    }\n}\n```\n\n### 6.2)动态代理——JDK Proxy\n\nJDKProxy动态代理是针对对象做代理，要求原始对象具有接口实现，并对接口方法进行增强\n\n```java\npublic class UserServiceJDKProxy {\n    public UserService createUserServiceJDKProxy(final UserService userService){\n        //获取被代理对象的类加载器\n        ClassLoader classLoader = userService.getClass().getClassLoader();\n        //获取被代理对象实现的接口\n        Class[] classes = userService.getClass().getInterfaces();\n        //对原始方法执行进行拦截并增强\n        InvocationHandler ih = new InvocationHandler() {\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                //前置增强内容\n                Object ret = method.invoke(userService, args);\n                //后置增强内容\n                System.out.println("刮大白2");\n                return ret;\n            }\n        };\n        //使用原始被代理对象创建新的代理对象\n        UserService proxy = (UserService) Proxy.newProxyInstance(classLoader,classes,ih);\n        return proxy;\n    }\n}\n```\n\n### 6.3)动态代理——CGLIB\n\n- CGLIB(Code Generation Library)，Code生成类库\n\n- CGLIB动态代理不限定是否具有接口，可以对任意操作进行增强\n\n- CGLIB动态代理无需要原始被代理对象，动态创建出新的代理对象\n\n![1591287441096](./Spring-day03/1591287441096.png)\n\n```java\npublic class UserServiceImplCglibProxy {\n    public static UserServiceImpl createUserServiceCglibProxy(Class clazz){\n        //创建Enhancer对象（可以理解为内存中动态创建了一个类的字节码）\n        Enhancer enhancer = new Enhancer();\n        //设置Enhancer对象的父类是指定类型UserServerImpl\n        enhancer.setSuperclass(clazz);\n        Callback cb = new MethodInterceptor() {\n            public Object intercept(Object o, Method m, Object[] a, MethodProxy mp) throws Throwable {\n                Object ret = mp.invokeSuper(o, a);\n                if(m.getName().equals("save")) {\n                    System.out.println("刮大白");\n                }\n                return ret;\n            }\n        };\n        //设置回调方法\n        enhancer.setCallback(cb);\n        //使用Enhancer对象创建对应的对象\n        return (UserServiceImpl)enhancer.create();\n    }\n}\n```\n\n### **6.4)代理模式的选择**\n\nSpirng可以通过配置的形式控制使用的代理形式，默认使用jdkproxy，通过配置可以修改为使用cglib\n\n- XML配置\n\n  ```xml\n  \x3c!--XMP配置AOP--\x3e\n  <aop:config proxy-target-class="false">\v</aop:config>\n  ```\n\n- XML注解支持\n\n  ```xml\n  \x3c!--注解配置AOP--\x3e\n  <aop:aspectj-autoproxy proxy-target-class="false"/>\n  ```\n\n- 注解驱动\n\n  ```java\n  //注解驱动\n  @EnableAspectJAutoProxy(proxyTargetClass = true)\n  ```\n\n### **6.5)织入时机**\n\n![1591287839941](./Spring-day03/1591287839941.png)'},"3b19":function(n,e,t){"use strict";t.r(e),e["default"]='这篇文章主要是想通过一些问题，加深大家对于 Spring 的理解，所以不会涉及太多的代码！\n\n下面的很多问题我自己在使用 Spring 的过程中也并没有注意，自己也是临时查阅了很多资料和书籍补上的。网上也有一些很多关于 Spring 常见问题/面试题整理的文章，我感觉大部分都是互相 copy，而且很多问题也不是很好，有些回答也存在问题。所以，自己花了一周的业余时间整理了一下，希望对大家有帮助。\n\n## 什么是 Spring 框架?\n\nSpring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。\n\nSpring 翻译过来就是春天的意思，可见其目标和使命就是为 Java 程序员带来春天啊！感动！\n\n> 题外话 ： 语言的流行通常需要一个杀手级的应用，Spring 就是 Java 生态的一个杀手级的应用框架。\n\n我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。\n\n比如说 Spring 自带 IoC（Inverse of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。\n\n![](Spring常见问题总结.assets/38ef122122de4375abcd27c3de8f60b4.png)\n\nSpring 最核心的思想就是不重新造轮子，开箱即用！\n\nSpring 提供的核心功能主要是 IoC 和 AOP。学习 Spring ，一定要把 IoC 和 AOP 的核心思想搞懂！\n\n- Spring 官网：<https://spring.io/>\n- Github 地址： https://github.com/spring-projects/spring-framework\n\n## 列举一些重要的 Spring 模块？\n\n下图对应的是 Spring4.x 版本。目前最新的 5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。\n\n![Spring主要模块](Spring常见问题总结.assets/e0c60b4606711fc4a0b6faf03230247a.png)\n\n**Spring Core**\n\n核心模块， Spring 其他所有的功能基本都需要依赖于该类库，主要提供 IoC 依赖注入功能的支持。\n\n**Spring Aspects**\n\n该模块为与 AspectJ 的集成提供支持。\n\n**Spring AOP**\n\n提供了面向切面的编程实现。\n\n**Spring Data Access/Integration ：**\n\nSpring Data Access/Integration 由 5 个模块组成：\n\n- spring-jdbc : 提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。\n- spring-tx : 提供对事务的支持。\n- spring-orm : 提供对 Hibernate 等 ORM 框架的支持。\n- spring-oxm ： 提供对 Castor 等 OXM 框架的支持。\n- spring-jms : Java 消息服务。\n\n**Spring Web**\n\nSpring Web 由 4 个模块组成：\n\n- spring-web ：对 Web 功能的实现提供一些最基础的支持。\n- spring-webmvc ： 提供对 Spring MVC 的实现。\n- spring-websocket ： 提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。\n- spring-webflux ：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步.\n\n**Spring Test**\n\nSpring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。\n\nSpring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。\n\n## Spring IOC & AOP\n\n### 谈谈自己对于 Spring IoC 的了解\n\n**IoC（Inverse of Control:控制反转）** 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spirng 特有，在其他语言中也有应用。\n\n**为什么叫控制反转？**\n\n- **控制** ：指的是对象创建（实例化、管理）的权力\n- **反转** ：控制权交给外部环境（Spring 框架、IoC 容器）\n\n![](Spring常见问题总结.assets/frc-365faceb5697f04f31399937c059c162.png)\n\n将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。\n\n在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。\n\n在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。\n\nSpring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。\n\n相关阅读：\n\n- [IoC 源码阅读](https://javadoop.com/post/spring-ioc)\n- [面试被问了几百遍的 IoC 和 AOP ，还在傻傻搞不清楚？](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486938&idx=1&sn=c99ef0233f39a5ffc1b98c81e02dfcd4&chksm=cea24211f9d5cb07fa901183ba4d96187820713a72387788408040822ffb2ed575d28e953ce7&token=1736772241&lang=zh_CN#rd)\n\n### 谈谈自己对于 AOP 的了解\n\nAOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。\n\nSpring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 **JDK Proxy**，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 **Cglib** 生成一个被代理对象的子类来作为代理，如下图所示：\n\n![SpringAOPProcess](Spring常见问题总结.assets/926dfc549b06d280a37397f9fd49bf9d.jpg)\n\n当然你也可以使用 **AspectJ** ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。\n\n### Spring AOP 和 AspectJ AOP 有什么区别？\n\n**Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。** Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。\n\nSpring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，\n\n如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。\n\n## Spring bean\n\n### 什么是 bean？\n\n简单来说，bean 代指的就是那些被 IoC 容器所管理的对象。\n\n我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。\n\n```xml\n\x3c!-- Constructor-arg with \'value\' attribute --\x3e\n<bean id="..." class="...">\n   <constructor-arg value="..."/>\n</bean>\n```\n\n下图简单地展示了 IoC 容器如何使用配置元数据来管理对象。\n\n![](Spring常见问题总结.assets/062b422bd7ac4d53afd28fb74b2bc94d.png)\n\n`org.springframework.beans`和 `org.springframework.context` 这两个包是 IoC 实现的基础，如果想要研究 IoC 相关的源码的话，可以去看看\n\n### bean 的作用域有哪些?\n\nSpring 中 Bean 的作用域通常有下面几种：\n\n- **singleton** : 唯一 bean 实例，Spring 中的 bean 默认都是单例的，对单例设计模式的应用。\n- **prototype** : 每次请求都会创建一个新的 bean 实例。\n- **request** : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。\n- **session** : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。\n- **global-session** ： 全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。\n\n**如何配置 bean 的作用域呢？**\n\nxml 方式：\n\n```xml\n<bean id="..." class="..." scope="singleton"></bean>\n```\n\n注解方式：\n\n```java\n@Bean\n@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)\npublic Person personPrototype() {\n    return new Person();\n}\n```\n\n### 单例 bean 的线程安全问题了解吗？\n\n大部分时候我们并没有在项目中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。\n\n常见的有两种解决办法：\n\n1. 在 bean 中尽量避免定义可变的成员变量。\n2. 在类中定义一个 `ThreadLocal` 成员变量，将需要的可变成员变量保存在 `ThreadLocal` 中（推荐的一种方式）。\n\n不过，大部分 bean 实际都是无状态（没有实例变量）的（比如 Dao、Service），这种情况下， bean 是线程安全的。\n\n### @Component 和 @Bean 的区别是什么？\n\n1. `@Component` 注解作用于类，而`@Bean`注解作用于方法。\n2. `@Component`通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 `@ComponentScan` 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。`@Bean` 注解通常是我们在标有该注解的方法中定义产生这个 bean,`@Bean`告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。\n3. `@Bean` 注解比 `@Component` 注解的自定义性更强，而且很多地方我们只能通过 `@Bean` 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 `Spring`容器时，则只能通过 `@Bean`来实现。\n\n`@Bean`注解使用示例：\n\n```java\n@Configuration\npublic class AppConfig {\n    @Bean\n    public TransferService transferService() {\n        return new TransferServiceImpl();\n    }\n\n}\n```\n\n上面的代码相当于下面的 xml 配置\n\n```xml\n<beans>\n    <bean id="transferService" class="com.acme.TransferServiceImpl"/>\n</beans>\n```\n\n下面这个例子是通过 `@Component` 无法实现的。\n\n```java\n@Bean\npublic OneService getService(status) {\n    case (status)  {\n        when 1:\n                return new serviceImpl1();\n        when 2:\n                return new serviceImpl2();\n        when 3:\n                return new serviceImpl3();\n    }\n}\n```\n\n### 将一个类声明为 bean 的注解有哪些?\n\n我们一般使用 `@Autowired` 注解自动装配 bean，要想把类标识成可用于 `@Autowired` 注解自动装配的 bean 的类,采用以下注解可实现：\n\n- `@Component` ：通用的注解，可标注任意类为 `Spring` 组件。如果一个 Bean 不知道属于哪个层，可以使用`@Component` 注解标注。\n- `@Repository` : 对应持久层即 Dao 层，主要用于数据库相关操作。\n- `@Service` : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。\n- `@Controller` : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。\n\n### bean 的生命周期?\n\n> 下面的内容整理自：<https://yemengying.com/2016/07/14/spring-bean-life-cycle/> ，除了这篇文章，再推荐一篇很不错的文章 ：<https://www.cnblogs.com/zrtqsk/p/3735273.html> 。\n\n- Bean 容器找到配置文件中 Spring Bean 的定义。\n- Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。\n- 如果涉及到一些属性值 利用 `set()`方法设置一些属性值。\n- 如果 Bean 实现了 `BeanNameAware` 接口，调用 `setBeanName()`方法，传入 Bean 的名字。\n- 如果 Bean 实现了 `BeanClassLoaderAware` 接口，调用 `setBeanClassLoader()`方法，传入 `ClassLoader`对象的实例。\n- 如果 Bean 实现了 `BeanFactoryAware` 接口，调用 `setBeanFactory()`方法，传入 `BeanFactory`对象的实例。\n- 与上面的类似，如果实现了其他 `*.Aware`接口，就调用相应的方法。\n- 如果有和加载这个 Bean 的 Spring 容器相关的 `BeanPostProcessor` 对象，执行`postProcessBeforeInitialization()` 方法\n- 如果 Bean 实现了`InitializingBean`接口，执行`afterPropertiesSet()`方法。\n- 如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。\n- 如果有和加载这个 Bean 的 Spring 容器相关的 `BeanPostProcessor` 对象，执行`postProcessAfterInitialization()` 方法\n- 当要销毁 Bean 的时候，如果 Bean 实现了 `DisposableBean` 接口，执行 `destroy()` 方法。\n- 当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。\n\n图示：\n\n![Spring Bean 生命周期](Spring常见问题总结.assets/24bc2bad3ce28144d60d9e0a2edf6c7f.jpg)\n\n与之比较类似的中文版本:\n\n![Spring Bean 生命周期](Spring常见问题总结.assets/b5d264565657a5395c2781081a7483e1.jpg)\n\n## Spring MVC\n\n### 说说自己对于 Spring MVC 了解?\n\nMVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。\n\n![](Spring常见问题总结.assets/image-20210809181452421.png)\n\n网上有很多人说 MVC 不是设计模式，只是软件设计规范，我个人更倾向于 MVC 同样是众多设计模式中的一种。**[java-design-patterns](https://github.com/iluwatar/java-design-patterns)** 项目中就有关于 MVC 的相关介绍。\n\n![](Spring常见问题总结.assets/159b3d3e70dd45e6afa81bf06d09264e-1635653448615.png)\n\n想要真正理解 Spring MVC，我们先来看看 Model 1 和 Model 2 这两个没有 Spring MVC 的时代。\n\n**Model 1 时代**\n\n很多学 Java 后端比较晚的朋友可能并没有接触过 Model 1 时代下的 JavaWeb 应用开发。在 Model1 模式下，整个 Web 应用几乎全部用 JSP 页面组成，只用少量的 JavaBean 来处理数据库连接、访问等操作。\n\n这个模式下 JSP 即是控制层（Controller）又是表现层（View）。显而易见，这种模式存在很多问题。比如控制逻辑和表现逻辑混杂在一起，导致代码重用率极低；再比如前端和后端相互依赖，难以进行测试维护并且开发效率极低。\n\n![mvc-mode1](Spring常见问题总结.assets/mvc-mode1.png)\n\n**Model 2 时代**\n\n学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+ JSP（View）+Servlet（Controller） ”这种开发模式，这就是早期的 JavaWeb MVC 开发模式。\n\n- Model:系统涉及的数据，也就是 dao 和 bean。\n- View：展示模型中的数据，只是用来展示。\n- Controller：处理用户请求都发送给 ，返回数据给 JSP 并展示给用户。\n\n![](Spring常见问题总结.assets/mvc-model2.png)\n\nModel2 模式下还存在很多问题，Model2 的抽象和封装程度还远远不够，使用 Model2 进行开发时不可避免地会重复造轮子，这就大大降低了程序的可维护性和复用性。\n\n于是，很多 JavaWeb 开发相关的 MVC 框架应运而生比如 Struts2，但是 Struts2 比较笨重。\n\n**Spring MVC 时代**\n\n随着 Spring 轻量级开发框架的流行，Spring 生态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相比于 Struts2 ， Spring MVC 使用更加简单和方便，开发效率更高，并且 Spring MVC 运行速度更快。\n\nMVC 是一种设计模式,Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的 Web 层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。\n\n### SpringMVC 工作原理了解吗?\n\n**Spring MVC 原理如下图所示：**\n\n> SpringMVC 工作原理的图解我没有自己画，直接图省事在网上找了一个非常清晰直观的，原出处不明。\n\n![](Spring常见问题总结.assets/de6d2b213f112297298f3e223bf08f28.png)\n\n**流程说明（重要）：**\n\n1. 客户端（浏览器）发送请求，直接请求到 `DispatcherServlet`。\n2. `DispatcherServlet` 根据请求信息调用 `HandlerMapping`，解析请求对应的 `Handler`。\n3. 解析到对应的 `Handler`（也就是我们平常说的 `Controller` 控制器）后，开始由 `HandlerAdapter` 适配器处理。\n4. `HandlerAdapter` 会根据 `Handler`来调用真正的处理器开处理请求，并处理相应的业务逻辑。\n5. 处理器处理完业务后，会返回一个 `ModelAndView` 对象，`Model` 是返回的数据对象，`View` 是个逻辑上的 `View`。\n6. `ViewResolver` 会根据逻辑 `View` 查找实际的 `View`。\n7. `DispaterServlet` 把返回的 `Model` 传给 `View`（视图渲染）。\n8. 把 `View` 返回给请求者（浏览器）\n\n## Spring 框架中用到了哪些设计模式？\n\n关于下面一些设计模式的详细介绍，可以看笔主前段时间的原创文章[《面试官:“谈谈 Spring 中都用到了那些设计模式?”。》](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485303&idx=1&sn=9e4626a1e3f001f9b0d84a6fa0cff04a&chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&token=255050878&lang=zh_CN#rd) 。\n\n- **工厂设计模式** : Spring 使用工厂模式通过 `BeanFactory`、`ApplicationContext` 创建 bean 对象。\n- **代理设计模式** : Spring AOP 功能的实现。\n- **单例设计模式** : Spring 中的 Bean 默认都是单例的。\n- **模板方法模式** : Spring 中 `jdbcTemplate`、`hibernateTemplate` 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。\n- **包装器设计模式** : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。\n- **观察者模式:** Spring 事件驱动模型就是观察者模式很经典的一个应用。\n- **适配器模式** : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配`Controller`。\n- ......\n\n## Spring 事务\n\nSpring/SpringBoot 模块下专门有一篇是讲 Spring 事务的，总结的非常详细，通俗易懂。\n\n### Spring 管理事务的方式有几种？\n\n- **编程式事务** ： 在代码中硬编码(不推荐使用) : 通过 `TransactionTemplate`或者 `TransactionManager` 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。\n- **声明式事务** ： 在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于`@Transactional` 的全注解方式使用最多）\n\n### Spring 事务中哪几种事务传播行为?\n\n**事务传播行为是为了解决业务层方法之间互相调用的事务问题**。\n\n当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。\n\n正确的事务传播行为可能的值如下:\n\n**1.`TransactionDefinition.PROPAGATION_REQUIRED`**\n\n使用的最多的一个事务传播行为，我们平时经常使用的`@Transactional`注解默认使用就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。\n\n**`2.TransactionDefinition.PROPAGATION_REQUIRES_NEW`**\n\n创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，`Propagation.REQUIRES_NEW`修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。\n\n**3.`TransactionDefinition.PROPAGATION_NESTED`**\n\n如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于`TransactionDefinition.PROPAGATION_REQUIRED`。\n\n**4.`TransactionDefinition.PROPAGATION_MANDATORY`**\n\n如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）\n\n这个使用的很少。\n\n若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚：\n\n- **`TransactionDefinition.PROPAGATION_SUPPORTS`**: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。\n- **`TransactionDefinition.PROPAGATION_NOT_SUPPORTED`**: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。\n- **`TransactionDefinition.PROPAGATION_NEVER`**: 以非事务方式运行，如果当前存在事务，则抛出异常。\n\n### Spring 事务中的隔离级别有哪几种?\n\n和事务传播行为这块一样，为了方便使用，Spring 也相应地定义了一个枚举类：`Isolation`\n\n```java\npublic enum Isolation {\n\n    DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),\n\n    READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),\n\n    READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),\n\n    REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),\n\n    SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);\n\n    private final int value;\n\n    Isolation(int value) {\n        this.value = value;\n    }\n\n    public int value() {\n        return this.value;\n    }\n\n}\n```\n\n下面我依次对每一种事务隔离级别进行介绍：\n\n- **`TransactionDefinition.ISOLATION_DEFAULT`** :使用后端数据库默认的隔离级别，MySQL 默认采用的 `REPEATABLE_READ` 隔离级别 Oracle 默认采用的 `READ_COMMITTED` 隔离级别.\n- **`TransactionDefinition.ISOLATION_READ_UNCOMMITTED`** :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**\n- **`TransactionDefinition.ISOLATION_READ_COMMITTED`** : 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**\n- **`TransactionDefinition.ISOLATION_REPEATABLE_READ`** : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生。**\n- **`TransactionDefinition.ISOLATION_SERIALIZABLE`** : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。但是这将严重影响程序的性能。通常情况下也不会用到该级别。\n\n### @Transactional(rollbackFor = Exception.class)注解了解吗？\n\n`Exception` 分为运行时异常 `RuntimeException` 和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。\n\n当 `@Transactional` 注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。\n\n在 `@Transactional` 注解中如果不配置`rollbackFor`属性,那么事务只会在遇到`RuntimeException`的时候才会回滚，加上 `rollbackFor=Exception.class`,可以让事务在遇到非运行时异常时也回滚。\n\n## JPA\n\n### 如何使用 JPA 在数据库中非持久化一个字段？\n\n假如我们有下面一个类：\n\n```java\n@Entity(name="USER")\npublic class User {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    @Column(name = "ID")\n    private Long id;\n\n    @Column(name="USER_NAME")\n    private String userName;\n\n    @Column(name="PASSWORD")\n    private String password;\n\n    private String secrect;\n\n}\n```\n\n如果我们想让`secrect` 这个字段不被持久化，也就是不被数据库存储怎么办？我们可以采用下面几种方法：\n\n```java\nstatic String transient1; // not persistent because of static\nfinal String transient2 = "Satish"; // not persistent because of final\ntransient String transient3; // not persistent because of transient\n@Transient\nString transient4; // not persistent because of @Transient\n```\n\n一般使用后面两种方式比较多，我个人使用注解的方式比较多。\n\n## 参考\n\n- 《Spring 技术内幕》\n- <http://www.cnblogs.com/wmyskxz/p/8820371.html>\n- <https://www.journaldev.com/2696/spring-interview-questions-and-answers>\n- <https://www.edureka.co/blog/interview-questions/spring-interview-questions/>\n- https://www.cnblogs.com/clwydjgs/p/9317849.html\n- <https://howtodoinjava.com/interview-questions/top-spring-interview-questions-with-answers/>\n- <http://www.tomaszezula.com/2014/02/09/spring-series-part-5-component-vs-bean/>\n- <https://stackoverflow.com/questions/34172888/difference-between-bean-and-autowired>\n'},"41b3":function(n,e,t){"use strict";t.r(e),e["default"]='\x3c!--\n * @Date           : 2021-04-14 00:54:56\n * @FilePath       : /jinnian-space/src/pages/java/module/mybatis/md/mybatis-第3天讲义.md\n * @Description    : \n--\x3e\n## Mybatis 高级\n\n\n### 一.Mybatis注解开发单表操作\n\n#### 1.1 MyBatis的常用注解 \n\n这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样我们就可以减少编写Mapper\n\n映射文件了。我们先围绕一些基本的CRUD来学习，再学习复杂映射多表操作。\n\n@Insert：实现新增\n\n@Update：实现更新\n\n@Delete：实现删除\n\n@Select：实现查询\n\n@Result：实现结果集封装\n\n@Results：可以与@Result 一起使用，封装多个结果集\n\n@One：实现一对一结果集封装\n\n@Many：实现一对多结果集封装\n\n#### 1.2 MyBatis的增删改查 \n\n我们完成简单的student表的增删改查的操作\n\n* 步骤一:创建mapper接口\n\n  ~~~java\n  public interface StudentMapper {\n      //查询全部\n      @Select("SELECT * FROM student")\n      public abstract List<Student> selectAll();\n  \n      //新增操作\n      @Insert("INSERT INTO student VALUES (#{id},#{name},#{age})")\n      public abstract Integer insert(Student stu);\n  \n      //修改操作\n      @Update("UPDATE student SET name=#{name},age=#{age} WHERE id=#{id}")\n      public abstract Integer update(Student stu);\n  \n      //删除操作\n      @Delete("DELETE FROM student WHERE id=#{id}")\n      public abstract Integer delete(Integer id);\n  }\n  \n  ~~~\n\n* 步骤二：测试类\n\n  ~~~java\n  public class Test01 {\n      @Test\n      public void selectAll() throws Exception{\n          //1.加载核心配置文件\n          InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n  \n          //2.获取SqlSession工厂对象\n          SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n  \n          //3.通过工厂对象获取SqlSession对象\n          SqlSession sqlSession = sqlSessionFactory.openSession(true);\n  \n          //4.获取StudentMapper接口的实现类对象\n          StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);\n  \n          //5.调用实现类对象中的方法，接收结果\n          List<Student> list = mapper.selectAll();\n  \n          //6.处理结果\n          for (Student student : list) {\n              System.out.println(student);\n          }\n  \n          //7.释放资源\n          sqlSession.close();\n          is.close();\n      }\n  \n      @Test\n      public void insert() throws Exception{\n          //1.加载核心配置文件\n          InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n  \n          //2.获取SqlSession工厂对象\n          SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n  \n          //3.通过工厂对象获取SqlSession对象\n          SqlSession sqlSession = sqlSessionFactory.openSession(true);\n  \n          //4.获取StudentMapper接口的实现类对象\n          StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);\n  \n          //5.调用实现类对象中的方法，接收结果\n          Student stu = new Student(4,"赵六",26);\n          Integer result = mapper.insert(stu);\n  \n          //6.处理结果\n          System.out.println(result);\n  \n          //7.释放资源\n          sqlSession.close();\n          is.close();\n      }\n  \n      @Test\n      public void update() throws Exception{\n          //1.加载核心配置文件\n          InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n  \n          //2.获取SqlSession工厂对象\n          SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n  \n          //3.通过工厂对象获取SqlSession对象\n          SqlSession sqlSession = sqlSessionFactory.openSession(true);\n  \n          //4.获取StudentMapper接口的实现类对象\n          StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);\n  \n          //5.调用实现类对象中的方法，接收结果\n          Student stu = new Student(4,"赵六",36);\n          Integer result = mapper.update(stu);\n  \n          //6.处理结果\n          System.out.println(result);\n  \n          //7.释放资源\n          sqlSession.close();\n          is.close();\n      }\n  \n      @Test\n      public void delete() throws Exception{\n          //1.加载核心配置文件\n          InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n  \n          //2.获取SqlSession工厂对象\n          SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n  \n          //3.通过工厂对象获取SqlSession对象\n          SqlSession sqlSession = sqlSessionFactory.openSession(true);\n  \n          //4.获取StudentMapper接口的实现类对象\n          StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);\n  \n          //5.调用实现类对象中的方法，接收结果\n          Integer result = mapper.delete(4);\n  \n          //6.处理结果\n          System.out.println(result);\n  \n          //7.释放资源\n          sqlSession.close();\n          is.close();\n      }\n  }\n  \n  ~~~\n\n* 注意：\n\n  修改MyBatis的核心配置文件，我们使用了注解替代的映射文件，所以我们只需要加载使用了注解的Mapper接口即可\n\n```xml\n<mappers>\n    \x3c!--扫描使用注解的类--\x3e\n    <mapper class="com.itheima.mapper.UserMapper"></mapper>\n</mappers>\n```\n\n​\t或者指定扫描包含映射关系的接口所在的包也可以\n\n```xml\n<mappers>\n    \x3c!--扫描使用注解的类所在的包--\x3e\n    <package name="com.itheima.mapper"></package>\n</mappers>\n```\n\n#### 1.3 注解开发总结\n\n注解可以简化开发操作，省略映射配置文件的编写。 \n\n* 常用注解 \n\n  @Select(“查询的 SQL 语句”)：执行查询操作注解\n\n   @Insert(“查询的 SQL 语句”)：执行新增操作注解\n\n   @Update(“查询的 SQL 语句”)：执行修改操作注解\n\n   @Delete(“查询的 SQL 语句”)：执行删除操作注解 \n\n* 配置映射关系 \n\n  ~~~xml\n  <mappers> <package name="接口所在包"/> </mappers>    \n  ~~~\n\n  \n\n### 二.MyBatis注解开发的多表操作\n\n#### 2.1  MyBatis的注解实现复杂映射开发\n\n实现复杂关系映射之前我们可以在映射文件中通过配置<resultMap>来实现，使用注解开发后，我们可以使用@Results注解，@Result注解，@One注解，@Many注解组合完成复杂关系的配置\n\n![](img\\图片10.png)\n\n![](img\\图片11.png)\n\n#### 2.2  一对一查询\n\n##### 2.2.1 一对一查询的模型\n\n一对一查询的需求：查询一个用户信息，与此同时查询出该用户对应的身份证信息\n\n![1590942011460](./mybatis-第3天讲义.img/1590942011460.png)\n\n##### 2.2.2 一对一查询的语句\n\n对应的sql语句：\n\n```sql\nSELECT * FROM card；\n\nSELECT * FROM person WHERE id=#{id};\n```\n\n##### \n\n##### 2.2.3 创建PersonMapper接口\n\n```java\npublic interface PersonMapper {\n    //根据id查询\n    @Select("SELECT * FROM person WHERE id=#{id}")\n    public abstract Person selectById(Integer id);\n}\n\n```\n\n##### 2.2.4 使用注解配置Mapper\n\n```java\npublic interface CardMapper {\n    //查询全部\n    @Select("SELECT * FROM card")\n    @Results({\n            @Result(column = "id",property = "id"),\n            @Result(column = "number",property = "number"),\n            @Result(\n                    property = "p",             // 被包含对象的变量名\n                    javaType = Person.class,    // 被包含对象的实际数据类型\n                    column = "pid",             // 根据查询出的card表中的pid字段来查询person表\n                    /*\n                        one、@One 一对一固定写法\n                        select属性：指定调用哪个接口中的哪个方法\n                     */\n                    one = @One(select = "com.itheima.one_to_one.PersonMapper.selectById")\n            )\n    })\n    public abstract List<Card> selectAll();\n}\n```\n\n##### 2.2.5 测试类\n\n```java\npublic class Test01 {\n    @Test\n    public void selectAll() throws Exception{\n        //1.加载核心配置文件\n        InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n\n        //2.获取SqlSession工厂对象\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n\n        //3.通过工厂对象获取SqlSession对象\n        SqlSession sqlSession = sqlSessionFactory.openSession(true);\n\n        //4.获取CardMapper接口的实现类对象\n        CardMapper mapper = sqlSession.getMapper(CardMapper.class);\n\n        //5.调用实现类对象中的方法，接收结果\n        List<Card> list = mapper.selectAll();\n\n        //6.处理结果\n        for (Card card : list) {\n            System.out.println(card);\n        }\n\n        //7.释放资源\n        sqlSession.close();\n        is.close();\n    }\n\n}\n\n```\n\n##### 2.2.6  一对一配置总结\n\n~~~xml-dtd\n@Results：封装映射关系的父注解。\n\tResult[] value()：定义了 Result 数组\n@Result：封装映射关系的子注解。\n\tcolumn 属性：查询出的表中字段名称\n\tproperty 属性：实体对象中的属性名称\n\tjavaType 属性：被包含对象的数据类型\n\tone 属性：一对一查询固定属性\n @One：一对一查询的注解。\n\tselect 属性：指定调用某个接口中的方法\n~~~\n\n\n\n#### 2.3 一对多查询\n\n##### 2.3.1 一对多查询的模型\n\n一对多查询的需求：查询一个课程，与此同时查询出该该课程对应的学生信息\n\n![1590942772892](./mybatis-第3天讲义.img/1590942772892.png)\n\n##### 2.3.2 一对多查询的语句\n\n对应的sql语句：\n\n```sql\nSELECT * FROM classes\n\nSELECT * FROM student WHERE cid=#{cid}\n```\n\n##### \n\n##### 2.3.3 创建StudentMapper接口\n\n```java\npublic interface StudentMapper {\n    //根据cid查询student表\n    @Select("SELECT * FROM student WHERE cid=#{cid}")\n    public abstract List<Student> selectByCid(Integer cid);\n}\n\n```\n\n##### 2.3.4 使用注解配置Mapper\n\n```java\npublic interface ClassesMapper {\n    //查询全部\n    @Select("SELECT * FROM classes")\n    @Results({\n            @Result(column = "id",property = "id"),\n            @Result(column = "name",property = "name"),\n            @Result(\n                    property = "students",  // 被包含对象的变量名\n                    javaType = List.class,  // 被包含对象的实际数据类型\n                    column = "id",          // 根据查询出的classes表的id字段来查询student表\n                    /*\n                        many、@Many 一对多查询的固定写法\n                        select属性：指定调用哪个接口中的哪个查询方法\n                     */\n                    many = @Many(select = "com.itheima.one_to_many.StudentMapper.selectByCid")\n            )\n    })\n    public abstract List<Classes> selectAll();\n}\n```\n\n##### 2.3.5 测试类\n\n```java\npublic class Test01 {\n    @Test\n    public void selectAll() throws Exception{\n        //1.加载核心配置文件\n        InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n\n        //2.获取SqlSession工厂对象\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n\n        //3.通过工厂对象获取SqlSession对象\n        SqlSession sqlSession = sqlSessionFactory.openSession(true);\n\n        //4.获取ClassesMapper接口的实现类对象\n        ClassesMapper mapper = sqlSession.getMapper(ClassesMapper.class);\n\n        //5.调用实现类对象中的方法，接收结果\n        List<Classes> list = mapper.selectAll();\n\n        //6.处理结果\n        for (Classes cls : list) {\n            System.out.println(cls.getId() + "," + cls.getName());\n            List<Student> students = cls.getStudents();\n            for (Student student : students) {\n                System.out.println("\\t" + student);\n            }\n        }\n\n        //7.释放资源\n        sqlSession.close();\n        is.close();\n    }\n\n}\n\n```\n\n##### 2.3.6 一对多配置总结\n\n~~~xml-dtd\n@Results：封装映射关系的父注解。\n\tResult[] value()：定义了 Result 数组\n@Result：封装映射关系的子注解。\n\tcolumn 属性：查询出的表中字段名称\n\tproperty 属性：实体对象中的属性名称\n\tjavaType 属性：被包含对象的数据类型\n\tmany 属性：一对多查询固定属性\n@Many：一对多查询的注解。\n\tselect 属性：指定调用某个接口中的方法\n~~~\n\n\n\n#### 2.4  多对多查询\n\n##### 2.4.1 多对多查询的模型\n\n多对多查询的需求：查询学生以及所对应的课程信息\n\n![1590943489827](./mybatis-第3天讲义.img/1590943489827.png)\n\n##### 2.4.2 多对多查询的语句\n\n对应的sql语句：\n\n```sql\nSELECT DISTINCT s.id,s.name,s.age FROM student s,stu_cr sc WHERE sc.sid=s.id\nSELECT c.id,c.name FROM stu_cr sc,course c WHERE sc.cid=c.id AND sc.sid=#{id}\n```\n\n\n\n##### 2.4.3  添加CourseMapper 接口方法\n\n```java\npublic interface CourseMapper {\n    //根据学生id查询所选课程\n    @Select("SELECT c.id,c.name FROM stu_cr sc,course c WHERE sc.cid=c.id AND sc.sid=#{id}")\n    public abstract List<Course> selectBySid(Integer id);\n}\n\n```\n\n##### 2.4.4 使用注解配置Mapper\n\n```java\npublic interface StudentMapper {\n    //查询全部\n    @Select("SELECT DISTINCT s.id,s.name,s.age FROM student s,stu_cr sc WHERE sc.sid=s.id")\n    @Results({\n            @Result(column = "id",property = "id"),\n            @Result(column = "name",property = "name"),\n            @Result(column = "age",property = "age"),\n            @Result(\n                    property = "courses",   // 被包含对象的变量名\n                    javaType = List.class,  // 被包含对象的实际数据类型\n                    column = "id",          // 根据查询出student表的id来作为关联条件，去查询中间表和课程表\n                    /*\n                        many、@Many 一对多查询的固定写法\n                        select属性：指定调用哪个接口中的哪个查询方法\n                     */\n                    many = @Many(select = "com.itheima.many_to_many.CourseMapper.selectBySid")\n            )\n    })\n    public abstract List<Student> selectAll();\n}\n\n```\n\n##### 2.4.5 测试类\n\n```java\npublic class Test01 {\n    @Test\n    public void selectAll() throws Exception{\n        //1.加载核心配置文件\n        InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n\n        //2.获取SqlSession工厂对象\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n\n        //3.通过工厂对象获取SqlSession对象\n        SqlSession sqlSession = sqlSessionFactory.openSession(true);\n\n        //4.获取StudentMapper接口的实现类对象\n        StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);\n\n        //5.调用实现类对象中的方法，接收结果\n        List<Student> list = mapper.selectAll();\n\n        //6.处理结果\n        for (Student student : list) {\n            System.out.println(student.getId() + "," + student.getName() + "," + student.getAge());\n            List<Course> courses = student.getCourses();\n            for (Course cours : courses) {\n                System.out.println("\\t" + cours);\n            }\n        }\n\n        //7.释放资源\n        sqlSession.close();\n        is.close();\n    }\n\n}\n```\n\n##### 2.4.6 多对多配置总结\n\n~~~xml-dtd\n@Results：封装映射关系的父注解。\n\tResult[] value()：定义了 Result 数组\n@Result：封装映射关系的子注解。\n\tcolumn 属性：查询出的表中字段名称\n\tproperty 属性：实体对象中的属性名称\n\tjavaType 属性：被包含对象的数据类型\n\tmany 属性：一对多查询固定属性\n@Many：一对多查询的注解。\n\tselect 属性：指定调用某个接口中的方法\n~~~\n\n\n\n### 三.构建sql\n\n#### 3.1 SQL 构建对象介绍    \n\n* 我们之前通过注解开发时，相关 SQL 语句都是自己直接拼写的。一些关键字写起来比较麻烦、而且容易出错。 \n*  MyBatis 给我们提供了 org.apache.ibatis.jdbc.SQL 功能类，专门用于构建 SQL 语句  \n*  org.apache.ibatis.jdbc.SQL      -     org.apache.ibatis.AbstractSQL  \n\n\n* ![1590943921472](./mybatis-第3天讲义.img/1590943921472.png)\n\n#### 3.2  查询功能的实现\n\n* 定义功能类并提供获取查询的 SQL 语句的方法。 \n\n* @SelectProvider：生成查询用的 SQL 语句注解。\n\n   type 属性：生成 SQL 语句功能类对象 \n\n   method 属性：指定调用方法    \n\n#### 3.3  新增功能的实现\n\n* 定义功能类并提供获取新增的 SQL 语句的方法。 \n\n* @InsertProvider：生成新增用的 SQL 语句注解。 \n\n  type 属性：生成 SQL 语句功能类对象 \n\n  method 属性：指定调用方法    \n\n#### 3.4  修改功能的实现\n\n* 定义功能类并提供获取修改的 SQL 语句的方法。 \n\n*  @UpdateProvider：生成修改用的 SQL 语句注解。 \n\n   type 属性：生成 SQL 语句功能类对象\n\n   method 属性：指定调用方法    \n\n#### 3.5  删除功能的实现\n\n* 定义功能类并提供获取删除的 SQL 语句的方法。 \n\n*  @DeleteProvider：生成删除用的 SQL 语句注解。\n\n   type 属性：生成 SQL 语句功能类对象 \n\n   method 属性：指定调用方法   \n\n ####  3.6  定义sql 语句 ReturnSql.java\n ```java\npackage com.itheima.sql;\n\nimport com.itheima.bean.Student;\nimport org.apache.ibatis.jdbc.SQL;\n\npublic class ReturnSql {\n    //定义方法，返回查询的sql语句\n    public String getSelectAll() {\n        return new SQL() {\n            {\n                SELECT("*");\n                FROM("student");\n            }\n        }.toString();\n    }\n\n    //定义方法，返回新增的sql语句\n    public String getInsert(Student stu) {\n        return new SQL() {\n            {\n                INSERT_INTO("student");\n                INTO_VALUES("#{id},#{name},#{age}");\n            }\n        }.toString();\n    }\n\n    //定义方法，返回修改的sql语句\n    public String getUpdate(Student stu) {\n        return new SQL() {\n            {\n                UPDATE("student");\n                SET("name=#{name}","age=#{age}");\n                WHERE("id=#{id}");\n            }\n        }.toString();\n    }\n\n    //定义方法，返回删除的sql语句\n    public String getDelete(Integer id) {\n        return new SQL() {\n            {\n                DELETE_FROM("student");\n                WHERE("id=#{id}");\n            }\n        }.toString();\n    }\n}\n ```\n\n ####  3.7 使用 sql 语句 StudentMapper.java\n ```java\npackage com.itheima.mapper;\n\nimport com.itheima.bean.Student;\nimport com.itheima.sql.ReturnSql;\nimport org.apache.ibatis.annotations.DeleteProvider;\nimport org.apache.ibatis.annotations.InsertProvider;\nimport org.apache.ibatis.annotations.SelectProvider;\nimport org.apache.ibatis.annotations.UpdateProvider;\n\nimport java.util.List;\n\npublic interface StudentMapper {\n    //查询全部\n    //@Select("SELECT * FROM student")\n    @SelectProvider(type = ReturnSql.class , method = "getSelectAll")\n    public abstract List<Student> selectAll();\n\n    //新增功能\n    //@Insert("INSERT INTO student VALUES (#{id},#{name},#{age})")\n    @InsertProvider(type = ReturnSql.class , method = "getInsert")\n    public abstract Integer insert(Student stu);\n\n    //修改功能\n    //@Update("UPDATE student SET name=#{name},age=#{age} WHERE id=#{id}")\n    @UpdateProvider(type = ReturnSql.class , method = "getUpdate")\n    public abstract Integer update(Student stu);\n\n    //删除功能\n    //@Delete("DELETE FROM student WHERE id=#{id}")\n    @DeleteProvider(type = ReturnSql.class , method = "getDelete")\n    public abstract Integer delete(Integer id);\n}\n\n\n ```\n\n ####  3.8 测试\n ```java\n   @Test\n    public void selectAll() throws Exception{\n        //1.加载核心配置文件\n        InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n\n        //2.获取SqlSession工厂对象\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n\n        //3.通过工厂对象获取SqlSession对象\n        SqlSession sqlSession = sqlSessionFactory.openSession(true);\n\n        //4.获取StudentMapper接口的实现类对象\n        StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);\n\n        //5.调用实现类对象中的方法，接收结果\n        List<Student> list = mapper.selectAll();\n\n        //6.处理结果\n        for (Student student : list) {\n            System.out.println(student);\n        }\n\n        //7.释放资源\n        sqlSession.close();\n        is.close();\n    }\n\n ```\n\n### 四.综合案例\n\n#### 4.1  系统介绍\n\n​         我们之前在做学生管理系统时，使用的是原始JDBC操作数据库的，操作非常麻烦，现在我们使用MyBatis操作数据库，简化Dao的开发。\n\n#### 4.2  环境搭建（略）\n\n#### 4.3  代码改造\n\n* 步骤一：新增MyBatis配置文件 `MyBatisConfig.xml`\n\n  ~~~xml\n  <?xml version="1.0" encoding="UTF-8" ?>\n  \x3c!--MyBatis的DTD约束--\x3e\n  <!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">\n  \n  \x3c!--configuration 核心根标签--\x3e\n  <configuration>\n  \n      \x3c!--引入数据库连接的配置文件--\x3e\n      <properties resource="config.properties"/>\n  \n      \x3c!--配置LOG4J--\x3e\n      <settings>\n          <setting name="logImpl" value="log4j"/>\n      </settings>\n  \n      \x3c!--environments配置数据库环境，环境可以有多个。default属性指定使用的是哪个--\x3e\n      <environments default="mysql">\n          \x3c!--environment配置数据库环境  id属性唯一标识--\x3e\n          <environment id="mysql">\n              \x3c!-- transactionManager事务管理。  type属性，采用JDBC默认的事务--\x3e\n              <transactionManager type="JDBC"></transactionManager>\n              \x3c!-- dataSource数据源信息   type属性 连接池--\x3e\n              <dataSource type="POOLED">\n                  \x3c!-- property获取数据库连接的配置信息 --\x3e\n                  <property name="driver" value="${driver}" />\n                  <property name="url" value="${url}" />\n                  <property name="username" value="${username}" />\n                  <property name="password" value="${password}" />\n              </dataSource>\n          </environment>\n      </environments>\n  \n      \x3c!--配置映射关系--\x3e\n      <mappers>\n          <package name="com.itheima"/>\n      </mappers>\n  </configuration>\n  \n  ~~~\n\n* 步骤二: 删除`StudentDaoImpl`，修改`StudentDao`\n\n  ```java\n  package com.itheima.dao;\n  \n  import com.itheima.domain.Student;\n  import org.apache.ibatis.annotations.Delete;\n  import org.apache.ibatis.annotations.Insert;\n  import org.apache.ibatis.annotations.Select;\n  import org.apache.ibatis.annotations.Update;\n  \n  import java.util.ArrayList;\n  \n  /*\n      Dao层接口\n   */\n  public interface StudentDao {\n      //查询所有学生信息\n      @Select("SELECT * FROM student")\n      public abstract ArrayList<Student> findAll();\n  \n      //条件查询，根据id获取学生信息\n      @Select("SELECT * FROM student WHERE sid=#{sid}")\n      public abstract Student findById(Integer sid);\n  \n      //新增学生信息\n      @Insert("INSERT INTO student VALUES (#{sid},#{name},#{age},#{birthday})")\n      public abstract int insert(Student stu);\n  \n      //修改学生信息\n      @Update("UPDATE student SET name=#{name},age=#{age},birthday=#{birthday} WHERE sid=#{sid}")\n      public abstract int update(Student stu);\n  \n      //删除学生信息\n      @Delete("DELETE FROM student WHERE sid=#{sid}")\n      public abstract int delete(Integer sid);\n  }\n  \n  ```\n  \n  \n  \n* 步骤三：修改`StudentServiceImpl`\n\n  ```java\n  package com.itheima.service.impl;\n  \n  import com.itheima.dao.StudentDao;\n  import com.itheima.domain.Student;\n  import com.itheima.service.StudentService;\n  import org.apache.ibatis.io.Resources;\n  import org.apache.ibatis.session.SqlSession;\n  import org.apache.ibatis.session.SqlSessionFactory;\n  import org.apache.ibatis.session.SqlSessionFactoryBuilder;\n  \n  import java.io.IOException;\n  import java.io.InputStream;\n  import java.util.ArrayList;\n  import java.util.List;\n  \n  /**\n   * 学生的业务层实现类\n   * @author 黑马程序员\n   * @Company http://www.itheima.com\n   */\n  public class StudentServiceImpl implements StudentService {\n  \n      @Override\n      public List<Student> findAll() {\n          ArrayList<Student> list = null;\n          SqlSession sqlSession = null;\n          InputStream is = null;\n          try{\n              //1.加载核心配置文件\n              is = Resources.getResourceAsStream("MyBatisConfig.xml");\n  \n              //2.获取SqlSession工厂对象\n              SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n  \n              //3.通过工厂对象获取SqlSession对象\n              sqlSession = sqlSessionFactory.openSession(true);\n  \n              //4.获取StudentDao接口的实现类对象\n              StudentDao mapper = sqlSession.getMapper(StudentDao.class);\n  \n              //5.调用实现类对象的方法，接收结果\n              list = mapper.findAll();\n  \n          } catch (Exception e) {\n              e.printStackTrace();\n          } finally {\n              //6.释放资源\n              if(sqlSession != null) {\n                  sqlSession.close();\n              }\n              if(is != null) {\n                  try {\n                      is.close();\n                  } catch (IOException e) {\n                      e.printStackTrace();\n                  }\n              }\n          }\n  \n          //7.返回结果\n          return list;\n      }\n  \n      @Override\n      public Student findById(Integer sid) {\n          Student stu = null;\n          SqlSession sqlSession = null;\n          InputStream is = null;\n          try{\n              //1.加载核心配置文件\n              is = Resources.getResourceAsStream("MyBatisConfig.xml");\n  \n              //2.获取SqlSession工厂对象\n              SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n  \n              //3.通过工厂对象获取SqlSession对象\n              sqlSession = sqlSessionFactory.openSession(true);\n  \n              //4.获取StudentDao接口的实现类对象\n              StudentDao mapper = sqlSession.getMapper(StudentDao.class);\n  \n              //5.调用实现类对象的方法，接收结果\n              stu = mapper.findById(sid);\n  \n          } catch (Exception e) {\n              e.printStackTrace();\n          } finally {\n              //6.释放资源\n              if(sqlSession != null) {\n                  sqlSession.close();\n              }\n              if(is != null) {\n                  try {\n                      is.close();\n                  } catch (IOException e) {\n                      e.printStackTrace();\n                  }\n              }\n          }\n  \n          //7.返回结果\n          return stu;\n      }\n  \n      @Override\n      public void save(Student student) {\n          SqlSession sqlSession = null;\n          InputStream is = null;\n          try{\n              //1.加载核心配置文件\n              is = Resources.getResourceAsStream("MyBatisConfig.xml");\n  \n              //2.获取SqlSession工厂对象\n              SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n  \n              //3.通过工厂对象获取SqlSession对象\n              sqlSession = sqlSessionFactory.openSession(true);\n  \n              //4.获取StudentDao接口的实现类对象\n              StudentDao mapper = sqlSession.getMapper(StudentDao.class);\n  \n              //5.调用实现类对象的方法，接收结果\n              mapper.insert(student);\n  \n          } catch (Exception e) {\n              e.printStackTrace();\n          } finally {\n              //6.释放资源\n              if(sqlSession != null) {\n                  sqlSession.close();\n              }\n              if(is != null) {\n                  try {\n                      is.close();\n                  } catch (IOException e) {\n                      e.printStackTrace();\n                  }\n              }\n          }\n      }\n  \n      @Override\n      public void update(Student student) {\n          SqlSession sqlSession = null;\n          InputStream is = null;\n          try{\n              //1.加载核心配置文件\n              is = Resources.getResourceAsStream("MyBatisConfig.xml");\n  \n              //2.获取SqlSession工厂对象\n              SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n  \n              //3.通过工厂对象获取SqlSession对象\n              sqlSession = sqlSessionFactory.openSession(true);\n  \n              //4.获取StudentDao接口的实现类对象\n              StudentDao mapper = sqlSession.getMapper(StudentDao.class);\n  \n              //5.调用实现类对象的方法，接收结果\n              mapper.update(student);\n  \n          } catch (Exception e) {\n              e.printStackTrace();\n          } finally {\n              //6.释放资源\n              if(sqlSession != null) {\n                  sqlSession.close();\n              }\n              if(is != null) {\n                  try {\n                      is.close();\n                  } catch (IOException e) {\n                      e.printStackTrace();\n                  }\n              }\n          }\n      }\n  \n      @Override\n      public void delete(Integer sid) {\n          SqlSession sqlSession = null;\n          InputStream is = null;\n          try{\n              //1.加载核心配置文件\n              is = Resources.getResourceAsStream("MyBatisConfig.xml");\n  \n              //2.获取SqlSession工厂对象\n              SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n  \n              //3.通过工厂对象获取SqlSession对象\n              sqlSession = sqlSessionFactory.openSession(true);\n  \n              //4.获取StudentDao接口的实现类对象\n              StudentDao mapper = sqlSession.getMapper(StudentDao.class);\n  \n              //5.调用实现类对象的方法，接收结果\n              mapper.delete(sid);\n  \n          } catch (Exception e) {\n              e.printStackTrace();\n          } finally {\n              //6.释放资源\n              if(sqlSession != null) {\n                  sqlSession.close();\n              }\n              if(is != null) {\n                  try {\n                      is.close();\n                  } catch (IOException e) {\n                      e.printStackTrace();\n                  }\n              }\n          }\n      }\n  }\n  \n```\n\n\n\n\n'},"465f":function(n,e,t){"use strict";t.r(e),e["default"]='# 再见Java8！Java11新特性真香\n\nJava 8 新特性见这里：[Java8 新特性最佳指南](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484744&idx=1&sn=9db31dca13d327678845054af75efb74&chksm=cea24a83f9d5c3956f4feb9956b068624ab2fdd6c4a75fe52d5df5dca356a016577301399548&token=1082669959&lang=zh_CN&scene=21#wechat_redirect) 。\n\n你可以在 [Archived OpenJDK General-Availability Releases](http://jdk.java.net/archive/) 上下载自己需要的 JDK 版本！\n\n官方的新特性说明文档地址： https://openjdk.java.net/projects/jdk/ 。\n\n_Guide ：别人家的特性都用了几年了，我 Java 才出来，哈哈！真实！_\n\n## Java9\n\n发布于 2017 年 9 月 21 日 。作为 Java8 之后 3 年半才发布的新版本，Java 9 带 来了很多重大的变化其中最重要的改动是 Java 平台模块系统的引入，其他还有诸如集合、Stream 流\n\n### Java 平台模块系统\n\nJava 平台模块系统是[Jigsaw Project](https://openjdk.java.net/projects/jigsaw/)的一部分，把模块化开发实践引入到了 Java 平台中，可以让我们的代码可重用性更好！\n\n什么是模块系统？官方的定义是：A uniquely named, reusable group of related packages, as well as resources (such as images and XML files) and a module descriptor.\n\n简单来说，你可以将一个模块看作是一组唯一命名、可重用的包、资源和模块描述文件（module-info.java）。\n\n任意一个 jar 文件，只要加上一个 模块描述文件（module-info.java），就可以升级为一个模块。\n\n![](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/module-structure.png)\n\n在引入了模块系统之后，JDK 被重新组织成 94 个模块。Java 应用可以通过新增的 jlink 工具，创建出只包含所依赖的 JDK 模块的自定义运行时镜像。这样可以极大的减少 Java 运行时环境的大小。\n\n我们可以通过 exports 关键词精准控制哪些类可以对外开放使用，哪些类只能内部使用。\n\n```java\nmodule my.module {\n    //exports 公开指定包的所有公共成员\n    exports com.my.package.name;\n}\n\nmodule my.module {\n     //exports…to 限制访问的成员范围\n    export com.my.package.name to com.specific.package;\n}\n```\n\nJava 9 模块的重要特征是在其工件（artifact）的根目录中包含了一个描述模块的 `module-info.java` 文 件。 工件的格式可以是传统的 JAR 文件或是 Java 9 新增的 JMOD 文件。\n\n想要深入了解 Java 9 的模块化，参见：\n\n- [《Project Jigsaw: Module System Quick-Start Guide》](https://openjdk.java.net/projects/jigsaw/quick-start)\n- [《Java 9 Modules: part 1》](https://stacktraceguru.com/java9/module-introduction)\n\n### Jshell\n\njshell 是 Java 9 新增的一个实用工具。为 Java 提供了类似于 Python 的实时命令行交互工具。\n\n在 Jshell 中可以直接输入表达式并查看其执行结果。\n\n![](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/image-20210816083417616.png)\n\n### 集合增强\n\n增加 了 `List.of()`、`Set.of()`、`Map.of()` 和 `Map.ofEntries()`等工厂方法来创建不可变集合（这部分内容有点参考 Guava 的味道）\n\n```java\nList.of("Java", "C++");\nSet.of("Java", "C++");\nMap.of("Java", 1, "C++", 2);\n```\n\n使用 `of()` 创建的集合为不可变集合，不能进行添加、删除、替换、 排序等操作，不然会报 `java.lang.UnsupportedOperationException` 异常。\n\n`Collectors` 中增加了新的方法 `filtering()` 和 `flatMapping()`。\n\n`Collectors` 的 `filtering()` 方法类似于 `Stream` 类的 `filter()` 方法，都是用于过滤元素。\n\n> Java 8 为 `Collectors` 类引入了 `groupingBy` 操作，用于根据特定的属性将对象分组。\n\n```java\nList<String> list = List.of("x","www", "yy", "zz");\nMap<Integer, List<String>> result = list.stream()\n        .collect(Collectors.groupingBy(String::length,\n                Collectors.filtering(s -> !s.contains("z"),\n                        Collectors.toList())));\n\nSystem.out.println(result); // {1=[x], 2=[yy], 3=[www]}\n```\n\n### Stream & Optional 增强\n\n`Stream` 中增加了新的方法 `ofNullable()`、`dropWhile()`、`takeWhile()` 以及 `iterate()` 方法的重载方法。\n\nJava 9 中的 `ofNullable()` 方 法允许我们创建一个单元素的 `Stream`，可以包含一个非空元素，也可以创建一个空 `Stream`。 而在 Java 8 中则不可以创建空的 `Stream` 。\n\n```java\nStream<String> stringStream = Stream.ofNullable("Java");\nSystem.out.println(stringStream.count());// 1\nStream<String> nullStream = Stream.ofNullable(null);\nSystem.out.println(nullStream.count());//0\n```\n\n`takeWhile()` 方法可以从 `Stream` 中依次获取满足条件的元素，直到不满足条件为止结束获取。\n\n```java\nList<Integer> integerList = List.of(11, 33, 66, 8, 9, 13);\nintegerList.stream().takeWhile(x -> x < 50).forEach(System.out::println);// 11 33\n```\n\n`dropWhile()` 方法的效果和 `takeWhile()` 相反。\n\n```java\nList<Integer> integerList2 = List.of(11, 33, 66, 8, 9, 13);\nintegerList2.stream().dropWhile(x -> x < 50).forEach(System.out::println);// 66 8 9 13\n```\n\n`iterate()` 方法的新重载方法提供了一个 `Predicate` 参数 (判断条件)来决定什么时候结束迭代\n\n```java\npublic static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f) {\n}\n// 新增加的重载方法\npublic static<T> Stream<T> iterate(T seed, Predicate<? super T> hasNext, UnaryOperator<T> next) {\n\n}\n```\n\n两者的使用对比如下，新的 `iterate()` 重载方法更加灵活一些。\n\n```java\n// 使用原始 iterate() 方法输出数字 1~10\nStream.iterate(1, i -> i + 1).limit(10).forEach(System.out::println);\n// 使用新的 iterate() 重载方法输出数字 1~10\nStream.iterate(1, i -> i <= 10, i -> i + 1).forEach(System.out::println);\n```\n\n`Optional` 类中新增了 `ifPresentOrElse()`、`or()` 和 `stream()` 等方法\n\n`ifPresentOrElse()` 方法接受两个参数 `Consumer` 和 `Runnable` ，如果 `Optional` 不为空调用 `Consumer` 参数，为空则调用 `Runnable` 参数。\n\n```java\npublic void ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction)\n\nOptional<Object> objectOptional = Optional.empty();\nobjectOptional.ifPresentOrElse(System.out::println, () -> System.out.println("Empty!!!"));// Empty!!!\n```\n\n`or()` 方法接受一个 `Supplier` 参数 ，如果 `Optional` 为空则返回 `Supplier` 参数指定的 `Optional` 值。\n\n```java\npublic Optional<T> or(Supplier<? extends Optional<? extends T>> supplier)\n\nOptional<Object> objectOptional = Optional.empty();\nobjectOptional.or(() -> Optional.of("java")).ifPresent(System.out::println);//java\n```\n\n### String 存储结构变更\n\nJDK 8 及之前的版本，`String` 一直是用 `char[]` 存储。在 Java 9 之后，`String` 的实现改用 `byte[]` 数组存储字符串。\n\n### 进程 API\n\nJava 9 增加了 `ProcessHandle` 接口，可以对原生进程进行管理，尤其适合于管理长时间运行的进程。\n\n```java\nSystem.out.println(ProcessHandle.current().pid());\nSystem.out.println(ProcessHandle.current().info());\n```\n\n![](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/image-20210816104614414.png)\n\n### 平台日志 API 和服务\n\nJava 9 允许为 JDK 和应用配置同样的日志实现。新增了 `System.LoggerFinder` 用来管理 JDK 使 用的日志记录器实现。JVM 在运行时只有一个系统范围的 `LoggerFinder` 实例。\n\n我们可以通过添加自己的 `System.LoggerFinder` 实现来让 JDK 和应用使用 SLF4J 等其他日志记录框架。\n\n### 反应式流 （ Reactive Streams ）\n\n在 Java9 中的 `java.util.concurrent.Flow` 类中新增了反应式流规范的核心接口 。\n\n`Flow` 中包含了 `Flow.Publisher`、`Flow.Subscriber`、`Flow.Subscription` 和 `Flow.Processor` 等 4 个核心接口。Java 9 还提供了`SubmissionPublisher` 作为`Flow.Publisher` 的一个实现。\n\n### 变量句柄\n\n变量句柄是一个变量或一组变量的引用，包括静态域，非静态域，数组元素和堆外数据结构中的组成部分等\n\n变量句柄的含义类似于已有的方法句柄 `MethodHandle` ，由 Java 类 `java.lang.invoke.VarHandle` 来表示，可以使用类 `java.lang.invoke.MethodHandles.Lookup` 中的静态工厂方法来创建 `VarHandle` 对象。\n\n`VarHandle` 的出现替代了 `java.util.concurrent.atomic` 和 `sun.misc.Unsafe` 的部分操作。并且提供了一系列标准的内存屏障操作，用于更加细粒度的控制内存排序。在安全性、可用性、性能上都要优于现有的 API。\n\n### 改进方法句柄（Method Handle）\n\n方法句柄从 Java7 开始引入，Java9 在类`java.lang.invoke.MethodHandles` 中新增了更多的静态方法来创建不同类型的方法句柄。\n\n### 接口私有方法\n\nJava 9 允许在接口中使用私有方法。\n\n```java\npublic interface MyInterface {\n    private void methodPrivate(){\n\n    }\n}\n```\n\n### Java9 其它新特性\n\n- **try-with-resources 增强** ：在 try-with-resources 语句中可以使用 effectively-final 变量（什么是 effectively-final 变量，见这篇文章：[《Effectively Final Variables in Java》](https://ilkinulas.github.io/programming/java/2016/03/27/effectively-final-java.html)\n- 类 `CompletableFuture` 中增加了几个新的方法（`completeAsync` ，`orTimeout` 等）\n- **Nashorn 引擎的增强** ：Nashorn 从 Java8 开始引入的 JavaScript 引擎，Java9 对 Nashorn 做了些增强，实现了一些 ES6 的新特性（Java 11 中已经被弃用）。\n- **I/O 流的新特性** ：增加了新的方法来读取和复制 `InputStream` 中包含的数据\n- **改进应用的安全性能** ：Java 9 新增了 4 个 SHA- 3 哈希算法，SHA3-224、SHA3-256、SHA3-384 和 SHA3-512\n- ......\n\n## Java10\n\n发布于 2018 年 3 月 20 日，最知名的特性应该是 var 关键字（局部变量类型推断）的引入了，其他还有垃圾收集器改善、GC 改进、性能提升、线程管控等一批新特性\n\n### var(局部变量推断)\n\n由于太多 Java 开发者希望 Java 中引入局部变量推断，于是 Java 10 的时候它来了，也算是众望所归了！\n\nJava 10 提供了 var 关键字声明局部变量。\n\n> Scala 和 Kotlin 中有 val 关键字 ( `final var` 组合关键字)，Java10 中并没有引入。\n\nJava 10 只引入了 var，而\n\n```java\nvar id = 0;\nvar codefx = new URL("https://mp.weixin.qq.com/");\nvar list = new ArrayList<>();\nvar list = List.of(1, 2, 3);\nvar map = new HashMap<String, String>();\nvar p = Paths.of("src/test/java/Java9FeaturesTest.java");\nvar numbers = List.of("a", "b", "c");\nfor (var n : list)\n    System.out.print(n+ " ");\n```\n\nvar 关键字只能用于带有构造器的局部变量和 for 循环中。\n\n```java\nvar count=null; //❌编译不通过，不能声明为 null\nvar r = () -> Math.random();//❌编译不通过,不能声明为 Lambda表达式\nvar array = {1,2,3};//❌编译不通过,不能声明数组\n```\n\nvar 并不会改变 Java 是一门静态类型语言的事实，编译器负责推断出类型。\n\n相关阅读：[《Java 10 新特性之局部变量类型推断》](https://zhuanlan.zhihu.com/p/34911982)。\n\n### 集合增强\n\n`list`，`set`，`map` 提供了静态方法`copyOf()`返回入参集合的一个不可变拷贝。\n\n以下为 JDK 的源码：\n\n```java\nstatic <E> List<E> copyOf(Collection<? extends E> coll) {\n    return ImmutableCollections.listCopy(coll);\n}\n```\n\n使用 `copyOf()` 创建的集合为不可变集合，不能进行添加、删除、替换、 排序等操作，不然会报 `java.lang.UnsupportedOperationException` 异常。 IDEA 也会有相应的提示。\n\n![](java新特性总结.assets/image-20210816154125579.png)\n\n`java.util.stream.Collectors` 中新增了静态方法，用于将流中的元素收集为不可变的集合。\n\n```java\nvar list = new ArrayList<>();\nlist.stream().collect(Collectors.toUnmodifiableList());\nlist.stream().collect(Collectors.toUnmodifiableSet());\n```\n\n### Optional\n\n新增了`orElseThrow()`方法来在没有值时抛出指定的异常。\n\n```java\nOptional.ofNullable(cache.getIfPresent(key))\n        .orElseThrow(() -> new PrestoException(NOT_FOUND, "Missing entry found for key: " + key));\n```\n\n### 并行全垃圾回收器 G1\n\n从 Java9 开始 G1 就了默认的垃圾回收器，G1 是以一种低延时的垃圾回收器来设计的，旨在避免进行 Full GC,但是 Java9 的 G1 的 FullGC 依然是使用单线程去完成标记清除算法,这可能会导致垃圾回收期在无法回收内存的时候触发 Full GC。\n\n为了最大限度地减少 Full GC 造成的应用停顿的影响，从 Java10 开始，G1 的 FullGC 改为并行的标记清除算法，同时会使用与年轻代回收和混合回收相同的并行工作线程数量，从而减少了 Full GC 的发生，以带来更好的性能提升、更大的吞吐量。\n\n### 应用程序类数据共享(扩展 CDS 功能)\n\n在 Java 5 中就已经引入了类数据共享机制 (Class Data Sharing，简称 CDS)，允许将一组类预处理为共享归档文件，以便在运行时能够进行内存映射以减少 Java 程序的启动时间，当多个 Java 虚拟机（JVM）共享相同的归档文件时，还可以减少动态内存的占用量，同时减少多个虚拟机在同一个物理或虚拟的机器上运行时的资源占用。CDS 在当时还是 Oracle JDK 的商业特性。\n\nJava 10 在现有的 CDS 功能基础上再次拓展，以允许应用类放置在共享存档中。CDS 特性在原来的 bootstrap 类基础之上，扩展加入了应用类的 CDS 为 (Application Class-Data Sharing，AppCDS) 支持，大大加大了 CDS 的适用范围。其原理为：在启动时记录加载类的过程，写入到文本文件中，再次启动时直接读取此启动文本并加载。设想如果应用环境没有大的变化，启动速度就会得到提升。\n\n### Java10 其他新特性\n\n- **线程-局部管控**：Java 10 中线程管控引入 JVM 安全点的概念，将允许在不运行全局 JVM 安全点的情况下实现线程回调，由线程本身或者 JVM 线程来执行，同时保持线程处于阻塞状态，这种方式使得停止单个线程变成可能，而不是只能启用或停止所有线程\n- **备用存储装置上的堆分配**：Java 10 中将使得 JVM 能够使用适用于不同类型的存储机制的堆，在可选内存设备上进行堆内存分配\n- **统一的垃圾回收接口**：Java 10 中，hotspot/gc 代码实现方面，引入一个干净的 GC 接口，改进不同 GC 源代码的隔离性，多个 GC 之间共享的实现细节代码应该存在于辅助类中。统一垃圾回收接口的主要原因是：让垃圾回收器（GC）这部分代码更加整洁，便于新人上手开发，便于后续排查相关问题。\n- ......\n\n## Java11\n\nJava11 于 2018 年 9 月 25 日正式发布，这是很重要的一个版本！Java 11 和 2017 年 9 月份发布的 Java 9 以及 2018 年 3 月份发布的 Java 10 相比，其最大的区别就是：在长期支持(Long-Term-Support)方面，**Oracle 表示会对 Java 11 提供大力支持，这一支持将会持续至 2026 年 9 月。这是据 Java 8 以后支持的首个长期版本。**\n\n![](java新特性总结.assets/20210603202746605.png)\n\n### String\n\nJava 11 增加了一系列的字符串处理方法，如以下所示。\n\n_Guide：说白点就是多了层封装，JDK 开发组的人没少看市面上常见的工具类框架啊!_\n\n```java\n//判断字符串是否为空\n" ".isBlank();//true\n//去除字符串首尾空格\n" Java ".strip();// "Java"\n//去除字符串首部空格\n" Java ".stripLeading();   // "Java "\n//去除字符串尾部空格\n" Java ".stripTrailing();  // " Java"\n//重复字符串多少次\n"Java".repeat(3);             // "JavaJavaJava"\n\n//返回由行终止符分隔的字符串集合。\n"A\\nB\\nC".lines().count();    // 3\n"A\\nB\\nC".lines().collect(Collectors.toList());\n```\n\n### Optional\n\n新增了`empty()`方法来判断指定的 `Optional` 对象是否为空。\n\n```java\nvar op = Optional.empty();\nSystem.out.println(op.isEmpty());//判断指定的 Optional 对象是否为空\n```\n\n### ZGC(可伸缩低延迟垃圾收集器)\n\n**ZGC 即 Z Garbage Collector**，是一个可伸缩的、低延迟的垃圾收集器。\n\nZGC 主要为了满足如下目标进行设计：\n\n- GC 停顿时间不超过 10ms\n- 即能处理几百 MB 的小堆，也能处理几个 TB 的大堆\n- 应用吞吐能力不会下降超过 15%（与 G1 回收算法相比）\n- 方便在此基础上引入新的 GC 特性和利用 colored 针以及 Load barriers 优化奠定基础\n- 当前只支持 Linux/x64 位平台\n\nZGC 目前 **处在实验阶段**，只支持 Linux/x64 平台。\n\n与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。\n\n在 ZGC 中出现 Stop The World 的情况会更少！\n\n详情可以看 ： [《新一代垃圾回收器 ZGC 的探索与实践》](https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html)\n\n### 标准 HTTP Client 升级\n\nJava 11 对 Java 9 中引入并在 Java 10 中进行了更新的 Http Client API 进行了标准化，在前两个版本中进行孵化的同时，Http Client 几乎被完全重写，并且现在完全支持异步非阻塞。\n\n并且，Java11 中，Http Client 的包名由 `jdk.incubator.http` 改为`java.net.http`，该 API 通过 `CompleteableFuture` 提供非阻塞请求和响应语义。使用起来也很简单，如下：\n\n```java\nvar request = HttpRequest.newBuilder()\n    .uri(URI.create("https://javastack.cn"))\n    .GET()\n    .build();\nvar client = HttpClient.newHttpClient();\n\n// 同步\nHttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\nSystem.out.println(response.body());\n\n// 异步\nclient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n    .thenApply(HttpResponse::body)\n    .thenAccept(System.out::println);\n```\n\n### var(Lambda 参数的局部变量语法)\n\n从 Java 10 开始，便引入了局部变量类型推断这一关键特性。类型推断允许使用关键字 var 作为局部变量的类型而不是实际类型，编译器根据分配给变量的值推断出类型。\n\nJava 10 中对 var 关键字存在几个限制\n\n- 只能用于局部变量上\n- 声明时必须初始化\n- 不能用作方法参数\n- 不能在 Lambda 表达式中使用\n\nJava11 开始允许开发者在 Lambda 表达式中使用 var 进行参数声明。\n\n```java\n// 下面两者是等价的\nConsumer<String> consumer = (var i) -> System.out.println(i);\nConsumer<String> consumer = (String i) -> System.out.println(i);\n```\n\n### 启动单文件源代码程序\n\n[JEP 330:启动单文件源代码程序（aunch Single-File Source-Code Programs）](https://openjdk.java.net/jeps/330) 可以让我们运行单一文件的 Java 源代码。此功能允许使用 Java 解释器直接执行 Java 源代码。源代码在内存中编译，然后由解释器执行，不需要在磁盘上生成 `.class` 文件了。\n\n唯一的约束在于所有相关的类必须定义在同一个 Java 文件中。\n\n对于 Java 初学者并希望尝试简单程序的人特别有用，并且能和 jshell 一起使用\n\n一定能程度上增强了使用 Java 来写脚本程序的能力。\n\n### Java11 其他新特性\n\n- **新的垃圾回收器 Epsilon** ：一个完全消极的 GC 实现，分配有限的内存资源，最大限度的降低内存占用和内存吞吐延迟时间\n- **低开销的 Heap Profiling** ：Java 11 中提供一种低开销的 Java 堆分配采样方法，能够得到堆分配的 Java 对象信息，并且能够通过 JVMTI 访问堆信息\n- **TLS1.3 协议** ：Java 11 中包含了传输层安全性（TLS）1.3 规范（RFC 8446）的实现，替换了之前版本中包含的 TLS，包括 TLS 1.2，同时还改进了其他 TLS 功能，例如 OCSP 装订扩展（RFC 6066，RFC 6961），以及会话散列和扩展主密钥扩展（RFC 7627），在安全性和性能方面也做了很多提升\n- **飞行记录器(Java Flight Recorder)** ：飞行记录器之前是商业版 JDK 的一项分析工具，但在 Java 11 中，其代码被包含到公开代码库中，这样所有人都能使用该功能了。\n- ......\n\n## Java12\n\n### String\n\nJava 11 增加了两个的字符串处理方法，如以下所示。\n\n`indent()` 方法可以实现字符串缩进。\n\n```java\nString text = "Java";\n// 缩进 4 格\ntext = text.indent(4);\nSystem.out.println(text);\ntext = text.indent(-10);\nSystem.out.println(text);\n```\n\n输出：\n\n```\n     Java\nJava\n```\n\n`transform()` 方法可以用来转变指定字符串。\n\n```java\nString result = "foo".transform(input -> input + " bar");\nSystem.out.println(result); // foo bar\n```\n\n### 文件比较\n\nJava 12 添加了以下方法来比较两个文件：\n\n```java\npublic static long mismatch(Path path, Path path2) throws IOException\n```\n\n`mismatch()` 方法用于比较两个文件，并返回第一个不匹配字符的位置，如果文件相同则返回 -1L。\n\n代码示例（两个文件内容相同的情况）：\n\n```java\nPath filePath1 = Files.createTempFile("file1", ".txt");\nPath filePath2 = Files.createTempFile("file2", ".txt");\nFiles.writeString(filePath1, "Java 12 Article");\nFiles.writeString(filePath2, "Java 12 Article");\n\nlong mismatch = Files.mismatch(filePath1, filePath2);\nassertEquals(-1, mismatch);\n```\n\n代码示例（两个文件内容不相同的情况）：\n\n```java\nPath filePath3 = Files.createTempFile("file3", ".txt");\nPath filePath4 = Files.createTempFile("file4", ".txt");\nFiles.writeString(filePath3, "Java 12 Article");\nFiles.writeString(filePath4, "Java 12 Tutorial");\n\nlong mismatch = Files.mismatch(filePath3, filePath4);\nassertEquals(8, mismatch);\n```\n\n### 数字格式化工具类\n\n`NumberFormat` 新增了对复杂的数字进行格式化的支持\n\n```java\nNumberFormat fmt = NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.SHORT);\nString result = fmt.format(1000);\n System.out.println(result); // 输出为 1K，计算工资是多少K更方便了。。。\n```\n\n### Shenandoah GC\n\nRedhat 主导开发的 Pauseless GC 实现，主要目标是 99.9% 的暂停小于 10ms，暂停与堆大小无关等\n\n和 Java11 开源的 ZGC 相比（需要升级到 JDK11 才能使用），Shenandoah GC 有稳定的 JDK8u 版本，在 Java8 占据主要市场份额的今天有更大的可落地性。\n\n### G1 收集器提升\n\nJava12 为默认的垃圾收集器 G1 带来了两项更新:\n\n- **可中止的混合收集集合** ：JEP344 的实现，为了达到用户提供的停顿时间目标，JEP 344 通过把要被回收的区域集（混合收集集合）拆分为强制和可选部分，使 G1 垃圾回收器能中止垃圾回收过程。 G1 可以中止可选部分的回收以达到停顿时间目标\n- **及时返回未使用的已分配内存** ：JEP346 的实现，增强 G1 GC，以便在空闲时自动将 Java 堆内存返回给操作系统\n\n### 预览新特性\n\n作为预览特性加入，需要在`javac`编译和`java`运行时增加参数`--enable-preview` 。\n\n#### 增强 Switch\n\n传统的 `switch` 语法存在容易漏写 `break` 的问题，而且从代码整洁性层面来看，多个 break 本质也是一种重复\n\nJava12 增强了 `swtich` 表达式，使用类似 lambda 语法条件匹配成功后的执行块，不需要多写 break 。\n\n```java\nswitch (day) {\n    case MONDAY, FRIDAY, SUNDAY -> System.out.println(6);\n    case TUESDAY                -> System.out.println(7);\n    case THURSDAY, SATURDAY     -> System.out.println(8);\n    case WEDNESDAY              -> System.out.println(9);\n}\n```\n\n#### instanceof 模式匹配\n\n`instanceof` 主要在**类型强转前探测对象的具体类型**。\n\n之前的版本中，我们需要显示地对对象进行类型转换。\n\n```java\nObject obj = "我是字符串";\nif(obj instanceof String){\n   String str = (String) obj;\n\tSystem.out.println(str);\n}\n```\n\n新版的 `instanceof` 可以在判断是否属于具体的类型同时完成转换。\n\n```java\nObject obj = "我是字符串";\nif(obj instanceof String str){\n\tSystem.out.println(str);\n}\n```\n\n## Java13\n\n### 增强 ZGC(释放未使用内存)\n\n在 Java 11 中是实验性的引入的 ZGC 在实际的使用中存在未能主动将未使用的内存释放给操作系统的问题。\n\nZGC 堆由一组称为 ZPages 的堆区域组成。在 GC 周期中清空 ZPages 区域时，它们将被释放并返回到页面缓存 **ZPageCache** 中，此缓存中的 ZPages 按最近最少使用（LRU）的顺序，并按照大小进行组织。\n\n在 Java 13 中，ZGC 将向操作系统返回被标识为长时间未使用的页面，这样它们将可以被其他进程重用。\n\n### SocketAPI 重构\n\nJava Socket API 终于迎来了重大更新！\n\nJava 13 将 Socket API 的底层进行了重写， `NioSocketImpl` 是对 `PlainSocketImpl` 的直接替代，它使用 `java.util.concurrent` 包下的锁而不是同步方法。如果要使用旧实现，请使用 `-Djdk.net.usePlainSocketImpl=true`。\n\n并且，在 Java 13 中是默认使用新的 Socket 实现。\n\n```java\npublic final class NioSocketImpl extends SocketImpl implements PlatformSocketImpl {\n}\n```\n\n### FileSystems\n\n`FileSystems` 类中添加了以下三种新方法，以便更容易地使用将文件内容视为文件系统的文件系统提供程序：\n\n- `newFileSystem(Path)`\n- `newFileSystem(Path, Map<String, ?>)`\n- `newFileSystem(Path, Map<String, ?>, ClassLoader)`\n\n### 动态 CDS 存档\n\nJava 13 中对 Java 10 中引入的应用程序类数据共享(AppCDS)进行了进一步的简化、改进和扩展，即：**允许在 Java 应用程序执行结束时动态进行类归档**，具体能够被归档的类包括所有已被加载，但不属于默认基层 CDS 的应用程序类和引用类库中的类。\n\n这提高了应用程序类数据共享（[AppCDS](https://openjdk.java.net/jeps/310)）的可用性。无需用户进行试运行来为每个应用程序创建类列表。\n\n```bash\n$ java -XX:ArchiveClassesAtExit=my_app_cds.jsa -cp my_app.jar\n$ java -XX:SharedArchiveFile=my_app_cds.jsa -cp my_app.jar\n```\n\n### 预览新特性\n\n#### 文本块\n\n解决 Java 定义多行字符串时只能通过换行转义或者换行连接符来变通支持的问题，引入**三重双引号**来定义多行文本。\n\nJava 13 支持两个 `"""` 符号中间的任何内容都会被解释为字符串的一部分，包括换行符。\n\n未支持文本块之前的 HTML 写法：\n\n```java\nString json ="{\\n" +\n              "   \\"name\\":\\"mkyong\\",\\n" +\n              "   \\"age\\":38\\n" +\n              "}\\n";\n```\n\n支持文本块之后的 HTML 写法：\n\n```java\n String json = """\n                {\n                    "name":"mkyong",\n                    "age":38\n                }\n                """;\n```\n\n未支持文本块之前的 SQL 写法：\n\n```sql\nString query = "SELECT `EMP_ID`, `LAST_NAME` FROM `EMPLOYEE_TB`\\n" +\n               "WHERE `CITY` = \'INDIANAPOLIS\'\\n" +\n               "ORDER BY `EMP_ID`, `LAST_NAME`;\\n";\n```\n\n支持文本块之后的 SQL 写法：\n\n```sql\nString query = """\n               SELECT `EMP_ID`, `LAST_NAME` FROM `EMPLOYEE_TB`\n               WHERE `CITY` = \'INDIANAPOLIS\'\n               ORDER BY `EMP_ID`, `LAST_NAME`;\n               """;\n```\n\n另外，`String` 类新增加了 3 个新的方法来操作文本块：\n\n- `formatted(Object... args)` ：它类似于 `String` 的`format()`方法。添加它是为了支持文本块的格式设置。\n- `stripIndent()` ：用于去除文本块中每一行开头和结尾的空格。\n- `translateEscapes()` ：转义序列如 _“\\\\\\t”_ 转换为 _“\\t”_\n\n由于文本块是一项预览功能，可以在未来版本中删除，因此这些新方法被标记为弃用。\n\n```java\n@Deprecated(forRemoval=true, since="13")\npublic String stripIndent() {\n}\n@Deprecated(forRemoval=true, since="13")\npublic String formatted(Object... args) {\n\n}\n@Deprecated(forRemoval=true, since="13")\npublic String translateEscapes() {\n}\n```\n\n#### 增强 Switch(引入 yield 关键字到 Switch 中)\n\n`Switch` 表达式中就多了一个关键字用于跳出 `Switch` 块的关键字 `yield`，主要用于返回一个值\n\n`yield`和 `return` 的区别在于：`return` 会直接跳出当前循环或者方法，而 `yield` 只会跳出当前 `Switch` 块，同时在使用 `yield` 时，需要有 `default` 条件\n\n```java\n private static String descLanguage(String name) {\n        return switch (name) {\n            case "Java": yield "object-oriented, platform independent and secured";\n            case "Ruby": yield "a programmer\'s best friend";\n            default: yield name +" is a good language";\n        };\n }\n```\n\n## Java14\n\n### 空指针异常精准提示\n\n通过 JVM 参数中添加`-XX:+ShowCodeDetailsInExceptionMessages`，可以在空指针异常中获取更为详细的调用信息，更快的定位和解决问题。\n\n```java\na.b.c.i = 99; // 假设这段代码会发生空指针\n```\n\nJava 14 之前：\n\n```java\nException in thread "main" java.lang.NullPointerException\n    at NullPointerExample.main(NullPointerExample.java:5)\n```\n\nJava 14 之后：\n\n```java\n // 增加参数后提示的异常中很明确的告知了哪里为空导致\nException in thread "main" java.lang.NullPointerException:\n        Cannot read field \'c\' because \'a.b\' is null.\n    at Prog.main(Prog.java:5)\n```\n\n### switch 的增强(转正)\n\nJava12 引入的 switch（预览特性）在 Java14 变为正式版本，不需要增加参数来启用，直接在 JDK14 中就能使用。\n\nJava12 为 switch 表达式引入了类似 lambda 语法条件匹配成功后的执行块，不需要多写 break ，Java13 提供了 `yield` 来在 block 中返回值。\n\n```java\nString result = switch (day) {\n            case "M", "W", "F" -> "MWF";\n            case "T", "TH", "S" -> "TTS";\n            default -> {\n                if(day.isEmpty())\n                    yield "Please insert a valid day.";\n                else\n                    yield "Looks like a Sunday.";\n            }\n\n        };\nSystem.out.println(result);\n```\n\n### 预览新特性\n\n#### record 关键字\n\n简化数据类的定义方式，使用 `record` 代替 `class` 定义的类，只需要声明属性，就可以在获得属性的访问方法，以及 `toString()`，`hashCode()`, `equals()`方法\n\n类似于使用 `class` 定义类，同时使用了 lombok 插件，并打上了`@Getter,@ToString,@EqualsAndHashCode`注解\n\n```java\n/**\n * 这个类具有两个特征\n * 1. 所有成员属性都是final\n * 2. 全部方法由构造方法，和两个成员属性访问器组成（共三个）\n * 那么这种类就很适合使用record来声明\n */\nfinal class Rectangle implements Shape {\n    final double length;\n    final double width;\n\n    public Rectangle(double length, double width) {\n        this.length = length;\n        this.width = width;\n    }\n\n    double length() { return length; }\n    double width() { return width; }\n}\n/**\n * 1. 使用record声明的类会自动拥有上面类中的三个方法\n * 2. 在这基础上还附赠了equals()，hashCode()方法以及toString()方法\n * 3. toString方法中包括所有成员属性的字符串表示形式及其名称\n */\nrecord Rectangle(float length, float width) { }\n```\n\n#### 文本块\n\nJava14 中，文本块依然是预览特性，不过，其引入了两个新的转义字符：\n\n- `\\` : 表示行尾，不引入换行符\n- `\\s` ：表示单个空格\n\n```java\nString str = "凡心所向，素履所往，生如逆旅，一苇以航。";\n\nString str2 = """\n        凡心所向，素履所往， \\\n        生如逆旅，一苇以航。""";\nSystem.out.println(str2);// 凡心所向，素履所往， 生如逆旅，一苇以航。\nString text = """\n        java\n        c++\\sphp\n        """;\nSystem.out.println(text);\n//输出：\njava\nc++ php\n```\n\n#### instanceof 增强\n\n依然是**预览特性** ，Java 12 新特性中介绍过。\n\n### Java14 其他特性\n\n- 从 Java11 引入的 ZGC 作为继 G1 过后的下一代 GC 算法，从支持 Linux 平台到 Java14 开始支持 MacOS 和 Window（个人感觉是终于可以在日常开发工具中先体验下 ZGC 的效果了，虽然其实 G1 也够用）\n- 移除了 CMS(Concurrent Mark Sweep) 垃圾收集器（功成而退）\n- 新增了 jpackage 工具，标配将应用打成 jar 包外，还支持不同平台的特性包，比如 linux 下的`deb`和`rpm`，window 平台下的`msi`和`exe`\n\n## Java15\n\n### CharSequence\n\n`CharSequence` 接口添加了一个默认方法 `isEmpty()` 来判断字符序列为空，如果是则返回 true。\n\n```java\npublic interface CharSequence {\n  default boolean isEmpty() {\n      return this.length() == 0;\n  }\n}\n```\n\n### TreeMap\n\n`TreeMap` 新引入了下面这些方法：\n\n- `putIfAbsent()`\n- `computeIfAbsent()`\n- `computeIfPresent()`\n- `compute()`\n- `merge()`\n\n### ZGC(转正)\n\nJava11 的时候 ，ZGC 还在试验阶段。\n\n当时，ZGC 的出现让众多 Java 开发者看到了垃圾回收器的另外一种可能，因此备受关注。\n\n经过多个版本的迭代，不断的完善和修复问题，ZGC 在 Java 15 已经可以正式使用了！\n\n不过，默认的垃圾回收器依然是 G1。你可以通过下面的参数启动 ZGC：\n\n```bash\n$ java -XX:+UseZGC className\n```\n\n### EdDSA(数字签名算法)\n\n新加入了一个安全性和性能都更强的基于 Edwards-Curve Digital Signature Algorithm （EdDSA）实现的数字签名算法。\n\n虽然其性能优于现有的 ECDSA 实现，不过，它并不会完全取代 JDK 中现有的椭圆曲线数字签名算法( ECDSA)。\n\n```java\nKeyPairGenerator kpg = KeyPairGenerator.getInstance("Ed25519");\nKeyPair kp = kpg.generateKeyPair();\n\nbyte[] msg = "test_string".getBytes(StandardCharsets.UTF_8);\n\nSignature sig = Signature.getInstance("Ed25519");\nsig.initSign(kp.getPrivate());\nsig.update(msg);\nbyte[] s = sig.sign();\n\nString encodedString = Base64.getEncoder().encodeToString(s);\nSystem.out.println(encodedString);\n```\n\n输出：\n\n```\n0Hc0lxxASZNvS52WsvnncJOH/mlFhnA8Tc6D/k5DtAX5BSsNVjtPF4R4+yMWXVjrvB2mxVXmChIbki6goFBgAg==\n```\n\n### 文本块(转正)\n\n在 Java 15 ，文本块是正式的功能特性了。\n\n### 隐藏类(Hidden Classes)\n\n隐藏类是为框架（frameworks）所设计的，隐藏类不能直接被其他类的字节码使用，只能在运行时生成类并通过反射间接使用它们。\n\n### 预览新特性\n\n#### 密封类\n\nJava 15 对 Java 14 中引入的预览新特性进行了增强，主要是引入了一个新的概念 **密封类（Sealed Classes）。**\n\n密封类可以对继承或者实现它们的类进行限制。\n\n比如抽象类 `Person` 只允许 `Employee` 和 `Manager` 继承。\n\n```java\npublic abstract sealed class Person\n    permits Employee, Manager {\n\n    //...\n}\n```\n\n另外，任何扩展密封类的类本身都必须声明为 `sealed`、`non-sealed` 或 `final`。\n\n```java\npublic final class Employee extends Person {\n}\n\npublic non-sealed class Manager extends Person {\n}\n```\n\n![](java新特性总结.assets/image-20210820153955587.png)\n\n#### instanceof 模式匹配\n\nJava 15 并没有对此特性进行调整，继续预览特性，主要用于接受更多的使用反馈。\n\n在未来的 Java 版本中，Java 的目标是继续完善 `instanceof` 模式匹配新特性。\n\n### Java15 其他新特性\n\n- **Nashorn JavaScript 引擎彻底移除** ：Nashorn 从 Java8 开始引入的 JavaScript 引擎，Java9 对 Nashorn 做了些增强，实现了一些 ES6 的新特性。在 Java 11 中就已经被弃用，到了 Java 15 就彻底被删除了。\n- **DatagramSocket API 重构**\n- **禁用和废弃偏向锁（Biased Locking）** ： 偏向锁的引入增加了 JVM 的复杂性大于其带来的性能提升。不过，你仍然可以使用 `-XX:+UseBiasedLocking` 启用偏向锁定，但它会提示 这是一个已弃用的 API。\n- ......\n\n## 总结\n\n### 关于预览特性\n\n先贴一段 oracle 官网原文：`This is a preview feature, which is a feature whose design, specification, and implementation are complete, but is not permanent, which means that the feature may exist in a different form or not at all in future JDK releases. To compile and run code that contains preview features, you must specify additional command-line options.`\n\n这是一个预览功能，该功能的设计，规格和实现是完整的，但不是永久性的，这意味着该功能可能以其他形式存在或在将来的 JDK 版本中根本不存在。 要编译和运行包含预览功能的代码，必须指定其他命令行选项。\n\n就以`switch`的增强为例子，从 Java12 中推出，到 Java13 中将继续增强，直到 Java14 才正式转正进入 JDK 可以放心使用，不用考虑后续 JDK 版本对其的改动或修改\n\n一方面可以看出 JDK 作为标准平台在增加新特性的严谨态度，另一方面个人认为是对于预览特性应该采取审慎使用的态度。特性的设计和实现容易，但是其实际价值依然需要在使用中去验证\n\n### JVM 虚拟机优化\n\n每次 Java 版本的发布都伴随着对 JVM 虚拟机的优化，包括对现有垃圾回收算法的改进，引入新的垃圾回收算法，移除老旧的不再适用于今天的垃圾回收算法等\n\n整体优化的方向是**高效，低时延的垃圾回收表现**\n\n对于日常的应用开发者可能比较关注新的语法特性，但是从一个公司角度来说，在考虑是否升级 Java 平台时更加考虑的是**JVM 运行时的提升**\n\n## 参考资料\n\n- JDK Project Overview ： <https://openjdk.java.net/projects/jdk/ >\n- IBM Developer Java9 <https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-9/>\n- Guide to Java10 <https://www.baeldung.com/java-10-overview>\n- Java 10 新特性介绍<https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-10/index.html>\n- IBM Devloper Java11 <https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-11/index.html>\n- Java 11 – Features and Comparison： <https://www.geeksforgeeks.org/java-11-features-and-comparison/>\n- Oracle Java12 ReleaseNote <https://www.oracle.com/technetwork/java/javase/12all-relnotes-5211423.html#NewFeature>\n- Oracle Java13 ReleaseNote <https://www.oracle.com/technetwork/java/javase/13all-relnotes-5461743.html#NewFeature>\n- New Features in Java 12 <https://www.baeldung.com/java-12-new-features>\n- New Java13 Features <https://www.baeldung.com/java-13-new-features>\n- Java13 新特性概述 <https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-13/index.html>\n- Oracle Java14 record <https://docs.oracle.com/en/java/javase/14/language/records.html>\n- java14-features <https://www.techgeeknext.com/java/java14-features>\n- Java 14 Features : <https://www.journaldev.com/37273/java-14-features>\n- What is new in Java 15: https://mkyong.com/java/what-is-new-in-java-15/\n'},4670:function(n,e,t){"use strict";t.r(e),e["default"]='\x3c!--\r\n * @Date           : 2021-04-28 01:12:51\r\n * @FilePath       : /jinnian-space/src/pages/java/module/springmvc/md/SpringMVC-day03.md\r\n * @Description    : \r\n--\x3e\r\n# 1 校验框架\r\n\r\n## 1.1 校验框架入门\r\n\r\n### 1.1.1 表单校验的重要性\r\n\r\n* 表单校验保障了数据有效性、安全性  \r\n\r\n![image-20200505144306747](./SpringMVC-day03/image-20200505144306747.png)\r\n\r\n数据可以随意输入，导致错误的结果。后端表单校验的重要性。\r\n\r\n### 1.1.2 表单校验分类  \r\n\r\n* 校验位置：\r\n  * 客户端校验\r\n  * 服务端校验\r\n* 校验内容与对应方式：\r\n  * 格式校验\r\n    * 客户端：使用Js技术，利用正则表达式校验\r\n    * 服务端：使用校验框架 \r\n  * 逻辑校验\r\n    * 客户端：使用ajax发送要校验的数据，在服务端完成逻辑校验，返回校验结果\r\n    * 服务端：接收到完整的请求后，在执行业务操作前，完成逻辑校验\r\n\r\n###  1.1.3 表单校验规则\r\n\r\n* 长度：例如用户名长度，评论字符数量\r\n* 非法字符：例如用户名组成\r\n* 数据格式：例如Email格式、 IP地址格式\r\n* 边界值：例如转账金额上限，年龄上下限\r\n* 重复性：例如用户名是否重复\r\n\r\n### 1.1.4 表单校验框架\r\n\r\n* JSR（Java Specification Requests）：Java 规范提案  \r\n\r\n    303：提供bean属性相关校验规则  \r\n\r\n* JSR规范列表\r\n  * 企业应用技术\r\n     Contexts and Dependency Injection for Java (Web Beans 1.0) (JSR 299)\r\n     Dependency Injection for Java 1.0 (JSR 330)@postConstruct, @PreDestroy\r\n     Bean Validation 1.0 (JSR 303)\r\n     Enterprise JavaBeans 3.1 (includes Interceptors 1.1) (JSR 318)\r\n     Java EE Connector Architecture 1.6 (JSR 322)\r\n     Java Persistence 2.0 (JSR 317)\r\n     Common Annotations for the Java Platform 1.1 (JSR 250)\r\n     Java Message Service API 1.1 (JSR 914)\r\n     Java Transaction API (JTA) 1.1 (JSR 907)\r\n     JavaMail 1.4 (JSR 919)\r\n  * Web应用技术\r\n     Java Servlet 3.0 (JSR 315)\r\n     JavaServer Faces 2.0 (JSR 314)\r\n     JavaServer Pages 2.2/Expression Language 2.2 (JSR 245)\r\n     Standard Tag Library for JavaServer Pages (JSTL) 1.2 (JSR 52)\r\n     Debugging Support for Other Languages 1.0 (JSR 45)\r\n     模块化 (JSR 294)\r\n     Swing应用框架 (JSR 296)\r\n     JavaBeans Activation Framework (JAF) 1.1 (JSR 925)\r\n     Streaming API for XML (StAX) 1.0 (JSR 173)\r\n  * 管理与安全技术\r\n     Java Authentication Service Provider Interface for Containers (JSR 196)\r\n     Java Authorization Contract for Containers 1.3 (JSR 115)\r\n     Java EE Application Deployment 1.2 (JSR 88)\r\n     J2EE Management 1.1 (JSR 77)\r\n     Java SE中与Java EE有关的规范\r\n     JCache API (JSR 107)\r\n     Java Memory Model (JSR 133)\r\n     Concurrency Utilitie (JSR 166)\r\n     Java API for XML Processing (JAXP) 1.3 (JSR 206)\r\n     Java Database Connectivity 4.0 (JSR 221)\r\n     Java Management Extensions (JMX) 2.0 (JSR 255)\r\n     Java Portlet API (JSR 286)\r\n\r\n* Web Service技术\r\n   Java Date与Time API (JSR 310)\r\n   Java API for RESTful Web Services (JAX-RS) 1.1 (JSR 311)\r\n   Implementing Enterprise Web Services 1.3 (JSR 109)\r\n   Java API for XML-Based Web Services (JAX-WS) 2.2 (JSR 224)\r\n   Java Architecture for XML Binding (JAXB) 2.2 (JSR 222)\r\n   Web Services Metadata for the Java Platform (JSR 181)\r\n   Java API for XML-Based RPC (JAX-RPC) 1.1 (JSR 101)\r\n   Java APIs for XML Messaging 1.3 (JSR 67)\r\n   Java API for XML Registries (JAXR) 1.0 (JSR 93)\r\n\r\n* JCP（Java Community Process）：Java社区\r\n\r\n*  Hibernate框架中包含一套独立的校验框架hibernate-validator  \r\n\r\n     导入坐标\r\n\r\n  ```xml\r\n  <dependency>\r\n      <groupId>org.hibernate</groupId>\r\n      <artifactId>hibernate-validator</artifactId>\r\n      <version>6.1.0.Final</version>\r\n  </dependency>\r\n  ```\r\n\r\n  **注意：**\r\n  tomcat7 ：搭配hibernate-validator版本5.*.*.Final\r\n  tomcat8.5↑ ：搭配hibernate-validator版本6.*.*.Final  \r\n\r\n\r\n\r\n## 1.2 快速使用\r\n\r\n**1. 开启校验**\r\n\r\n 名称：@Valid 、 @Validated\r\n 类型：形参注解\r\n 位置：处理器类中的实体类类型的方法形参前方\r\n 作用：设定对当前实体类类型参数进行校验\r\n 范例：  \r\n\r\n```java\r\n@RequestMapping(value = "/addemployee")\r\npublic String addEmployee(@Valid Employee employee) {\r\n    System.out.println(employee);\r\n}\r\n```\r\n\r\n**2.设置校验规则**\r\n\r\n 名称：@NotNull\r\n 类型：属性注解 等\r\n 位置：实体类属性上方\r\n 作用：设定当前属性校验规则\r\n 范例：\r\n    每个校验规则所携带的参数不同，根据校验规则进行相应的调整\r\n    具体的校验规则查看对应的校验框架进行获取\r\n\r\n```java\r\npublic class Employee{\r\n    @NotNull(message = "姓名不能为空")\r\n    private String name;//员工姓名\r\n}  \r\n```\r\n\r\n**3.获取错误信息**\r\n\r\n```java\r\n@RequestMapping(value = "/addemployee")\r\npublic String addEmployee(@Valid Employee employee, Errors errors, Model model){\r\n    System.out.println(employee);\r\n    if(errors.hasErrors()){\r\n        for(FieldError error : errors.getFieldErrors()){\r\n            model.addAttribute(error.getField(),error.getDefaultMessage());\r\n        }\r\n        return "addemployee.jsp";\r\n    }\r\n    return "success.jsp";\r\n}  \r\n```\r\n\r\n  通过形参Errors获取校验结果数据，通过Model接口将数据封装后传递到页面显示  \r\n\r\n```html\r\n<form action="/addemployee" method="post">\r\n    员工姓名：<input type="text" name="name"><span style="color:red">${name}</span><br/>\r\n    员工年龄：<input type="text" name="age"><span style="color:red">${age}</span><br/>\r\n    <input type="submit" value="提交">\r\n</form>\r\n```\r\n\r\n通过形参Errors获取校验结果数据，通过Model接口将数据封装后传递到页面显示\r\n页面获取后台封装的校验结果信息  \r\n\r\n## 1.3 多规则校验\r\n\r\n* 同一个属性可以添加多个校验器  \r\n\r\n```java\r\n@NotNull(message = "请输入您的年龄")\r\n@Max(value = 60,message = "年龄最大值不允许超过60岁")\r\n@Min(value = 18,message = "年龄最小值不允许低于18岁")\r\nprivate Integer age;//员工年龄\r\n```\r\n\r\n* 3种判定空校验器的区别  \r\n\r\n![image-20200506160725709](./SpringMVC-day03/image-20200506160725709.png)\r\n\r\n## 1.4 嵌套校验\r\n\r\n 名称：@Valid\r\n 类型：属性注解\r\n 位置：实体类中的引用类型属性上方\r\n 作用：设定当前应用类型属性中的属性开启校验\r\n 范例：\r\n\r\n```java\r\npublic class Employee {\r\n    //实体类中的引用类型通过标注@Valid注解，设定开启当前引用类型字段中的属性参与校验\r\n    @Valid\r\n    private Address address;\r\n}\r\n```\r\n\r\n 注意：开启嵌套校验后，被校验对象内部需要添加对应的校验规则  \r\n\r\n## 1.5 分组校验\r\n\r\n* 同一个模块，根据执行的业务不同，需要校验的属性会有不同\r\n  * 新增用户\r\n  * 修改用户\r\n* 对不同种类的属性进行分组，在校验时可以指定参与校验的字段所属的组类别\r\n  * 定义组（通用）\r\n  * 为属性设置所属组，可以设置多个\r\n  * 开启组校验\r\n\r\n```java\r\npublic interface GroupOne {\r\n}\r\n```\r\n\r\n```java\r\npublic String addEmployee(@Validated({GroupOne.class}) Employee employee){\r\n}  \r\n```\r\n\r\n\r\n\r\n\r\n```java\r\n@NotEmpty(message = "姓名不能为空",groups = {GroupOne.class})\r\nprivate String name;//员工姓名\r\n```\r\n\r\n# 2 ssm整合\r\n\r\n## 2.1 整合流程简介\r\n\r\n整合步骤分析\r\n\r\nSSM（Spring+SpringMVC+MyBatis）\r\n\r\n* Spring\r\n  * 框架基础\r\n\r\n* MyBatis\r\n  * mysql+druid+pagehelper\r\n\r\n* Spring整合MyBatis\r\n\r\n* junit测试业务层接口\r\n\r\n* SpringMVC\r\n  * rest风格（postman测试请求结果）\r\n  * 数据封装json（jackson）\r\n\r\n* Spring整合SpringMVC\r\n\r\n  * Controller调用Service\r\n\r\n* 其他\r\n\r\n  * 表现层数据封装\r\n\r\n  * 自定义异常\r\n\r\n**表结构**\r\n\r\n![image-20200506093609697](./SpringMVC-day03/image-20200506093609697.png)\r\n\r\n​    最重要的5个步骤\r\n\r\n1. Spring\r\n\r\n2. MyBatis\r\n\r\n3. Spring整合MyBatis\r\n\r\n4. SpringMVC\r\n\r\n5. Spring整合SpringMVC\r\n\r\n\r\n\r\n## 2.2 项目结构搭建\r\n\r\n**Part0：**   项目基础结构搭建\r\n\r\n* 创建项目，组织项目结构，创建包\r\n\r\n* 创建表与实体类\r\n\r\n* 创建三层架构对应的模块、接口与实体类，建立关联关系\r\n\r\n* 数据层接口（代理自动创建实现类）\r\n  * 业务层接口+业务层实现类\r\n  * 表现层类\r\n\r\n\r\n\r\n![image-20200506094053535](./SpringMVC-day03/image-20200506094053535.png)\r\n\r\n\r\n\r\n```java\r\npublic interface UserDao {\r\n    public boolean save(User user);  public boolean update(User user);  \r\n    public boolean delete(Integer uuid);  public User get(Integer uuid);\r\n    public List<User> getAll(int page,int size);\r\n\r\n    public interface UserService {  \r\n        public boolean save(User user);  public boolean update(User user);\r\n        public boolean delete(Integer uuid);\r\n        public User get(Integer uuid);\r\n        public List<User> getAll(int page, int size);\r\n        /**\r\n        用户登录\r\n        @param userName 用户名\r\n        @param password 密码信息\r\n        @return\r\n        */\r\n        public User login(String userName,String password);\r\n    }\r\n```\r\n\r\n\r\n\r\n## 2.3 Spring整合Mybatis（复习）\r\n\r\n**Part1 :**  Spring环境配置\r\n\r\n```xml\r\n<?xml version="1.0" encoding="UTF-8"?>\r\n<beans xmlns="http://www.springframework.org/schema/beans"  xmlns:context="http://www.springframework.org/schema/context"  xmlns:tx="http://www.springframework.org/schema/tx"  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xsi:schemaLocation="http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd  http://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context.xsd  http://www.springframework.org/schema/tx  http://www.springframework.org/schema/tx/spring-tx.xsd">\r\n\r\n    \x3c!--开启bean注解扫描--\x3e\r\n    <context:component-scan base-package="com.itheima"/>\r\n\r\n</beans>\r\n\r\n```\r\n\r\n**Part1 :**  Mybatis配置事务\r\n\r\n* MyBatis映射\r\n\r\n  ```xml\r\n  <?xml version="1.0" encoding="UTF-8"?>\r\n  <!DOCTYPE mapper\r\n          PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\r\n          "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\r\n  <mapper namespace="com.itheima.dao.UserDao">\r\n  \r\n      \x3c!--添加--\x3e\r\n      <insert id="save" parameterType="user">\r\n          insert into user(userName,password,realName,gender,birthday)values(#{userName},#{password},#{realName},#{gender},#{birthday})\r\n      </insert>\r\n  \r\n      \x3c!--删除--\x3e\r\n      <delete id="delete" parameterType="int">\r\n          delete from user where uuid = #{uuid}\r\n      </delete>\r\n  \r\n      \x3c!--修改--\x3e\r\n      <update id="update" parameterType="user">\r\n          update user set userName=#{userName},password=#{password},realName=#{realName},gender=#{gender},birthday=#{birthday} where uuid=#{uuid}\r\n      </update>\r\n  \r\n      \x3c!--查询单个--\x3e\r\n      <select id="get" resultType="user" parameterType="int">\r\n          select * from user where uuid = #{uuid}\r\n      </select>\r\n  \r\n      \x3c!--分页查询--\x3e\r\n      <select id="getAll" resultType="user">\r\n          select * from user\r\n      </select>\r\n  \r\n      \x3c!--登录--\x3e\r\n      <select id="getByUserNameAndPassword" resultType="user" >\r\n          select * from user where userName=#{userName} and password=#{password}\r\n      </select>\r\n  \r\n  </mapper>\r\n  ```\r\n\r\n  \r\n\r\n* Mybatis核心配置\r\n\r\n  ```xml\r\n  \x3c!--开启注解式事务--\x3e\r\n  <tx:annotation-driven transaction-manager="txManager"/>\r\n  \r\n  \x3c!--加载properties文件--\x3e\r\n  <context:property-placeholder location="classpath*:jdbc.properties"/>\r\n  \r\n  \x3c!--数据源--\x3e\r\n  <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">\r\n      <property name="driverClassName" value="${jdbc.driver}"/>\r\n      <property name="url" value="${jdbc.url}"/>\r\n      <property name="username" value="${jdbc.username}"/>\r\n      <property name="password" value="${jdbc.password}"/>\r\n  </bean>\r\n  \r\n  \x3c!--整合mybatis到spring中--\x3e\r\n  <bean class="org.mybatis.spring.SqlSessionFactoryBean">\r\n      <property name="dataSource" ref="dataSource"/>\r\n      <property name="typeAliasesPackage" value="com.itheima.domain"/>\r\n      \x3c!--分页插件--\x3e\r\n      <property name="plugins">\r\n          <array>\r\n              <bean class="com.github.pagehelper.PageInterceptor">\r\n                  <property name="properties">\r\n                      <props>\r\n                          <prop key="helperDialect">mysql</prop>\r\n                          <prop key="reasonable">true</prop>\r\n                      </props>\r\n                  </property>\r\n              </bean>\r\n          </array>\r\n      </property>\r\n  </bean>\r\n  \r\n  \x3c!--映射扫描--\x3e\r\n  <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">\r\n      <property name="basePackage" value="com.itheima.dao"/>\r\n  </bean>\r\n  \r\n  \x3c!--事务管理器--\x3e\r\n  <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\r\n      <property name="dataSource" ref="dataSource"/>\r\n  </bean>\r\n  ```\r\n\r\n  \r\n\r\n## 2.4 整合junit\r\n\r\n**Part2：**单元测试整合junit\r\n\r\n```java\r\n@RunWith(SpringJUnit4ClassRunner.class)  \r\n@ContextConfiguration(locations = "classpath:applicationContext.xml")  \r\npublic class UserServiceTest {\r\n\r\n    @Autowired\r\n    private UserService userService;\r\n\r\n    @Test\r\n    public void testDelete(){  \r\n        User user = new User();  userService.delete(3);\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n## 2.5 Spring整合SpringMVC\r\n\r\n**Part3：**SpringMVC\r\n\r\n* web.xml配置\r\n\r\n  ```xml\r\n  <servlet>\r\n      <servlet-name>DispatcherServlet</servlet-name>\r\n      <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\r\n      <init-param>\r\n          <param-name>contextConfigLocation</param-name>\r\n          <param-value>classpath*:spring-mvc.xml</param-value>\r\n      </init-param>\r\n  </servlet>\r\n  <servlet-mapping>\r\n      <servlet-name>DispatcherServlet</servlet-name>\r\n      <url-pattern>/</url-pattern>\r\n  </servlet-mapping>\r\n  ```\r\n\r\n* spring-mvc.xml\r\n\r\n  ```xml\r\n  <?xml version="1.0" encoding="UTF-8"?>\r\n  <beans xmlns="http://www.springframework.org/schema/beans"\r\n         xmlns:context="http://www.springframework.org/schema/context"\r\n         xmlns:mvc="http://www.springframework.org/schema/mvc"\r\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\r\n         xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\r\n          http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\r\n          http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">\r\n  \r\n      <mvc:annotation-driven/>\r\n  \r\n      <context:component-scan base-package="com.itheima.controller"/>\r\n  \r\n  </beans>\r\n  ```\r\n\r\n* controller层\r\n\r\n  ```java\r\n  @RestController  \r\n  @RequestMapping("/user")  public class UserController {\r\n      @PostMapping\r\n      public boolean save(User user) {  \r\n          System.out.println("save ..." + user);  return true;\r\n      }\r\n      @PostMapping("/login")\r\n      public User login(String userName,String password){  \r\n          System.out.println("login ..." + userName + " ," +password);\r\n          return null;\r\n      }\r\n  }\r\n  ```\r\n\r\n\r\n\r\n**Part4：**Spring整合SpringMVC\r\n\r\n* web.xml加载Spring环境\r\n\r\n  ```xml\r\n  <context-param>\r\n      <param-name>contextConfigLocation</param-name>\r\n      <param-value>classpath*:applicationContext.xml</param-value>\r\n  </context-param>\r\n  \r\n  \x3c!--启动服务器时，通过监听器加载spring运行环境--\x3e\r\n  <listener>\r\n      <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\r\n  </listener>\r\n  ```\r\n\r\n* Controller调用Service\r\n\r\n  ```java\r\n  @RestController\r\n  @RequestMapping("/user")\r\n  public class UserController {\r\n      @Autowired\r\n      private UserService userService;\r\n  \r\n  \r\n      @PostMapping\r\n      public boolean save(User user){\r\n          return userService.save(user);\r\n      }\r\n  }\r\n  ```\r\n\r\n## 2.6 表现层数据封装\r\n\r\n**Part5-1：**表现层数据封装\r\n\r\n* 前端接收表现层返回的数据种类\r\n\r\n| u操作是否成功 | true/false | 格式A |\r\n| ------------- | ---------- | ----- |\r\n| u单个数据     | 1,100,true | 格式B |\r\n| u对象数据     | json对象   | 格式C |\r\n| u集合数据     | json数组   | 格式D |\r\n\r\n![image-20200506103851845](./SpringMVC-day03/image-20200506103851845.png)\r\n\r\n\r\n\r\n* 返回数据格式设计\r\n\r\n![image-20200506104339019](./SpringMVC-day03/image-20200506104339019.png)\r\n\r\n* 代码\r\n\r\n  ```java\r\n  public class Result {\r\n      // 操作结果编码\r\n      private Integer code;\r\n      // 操作数据结果\r\n      private Object data;\r\n      // 消息\r\n      private String message;\r\n      public Result(Integer code) {\r\n          this.code = code;\r\n      }\r\n      public Result(Integer code, Object data) {\r\n          this.code = code;\r\n          this.data = data;\r\n      }\r\n  }\r\n  ```\r\n\r\n  状态码常量可以根据自己的业务需求设定\r\n\r\n  ```java\r\n  public class Code {\r\n      public static final Integer SAVE_OK = 20011;\r\n      public static final Integer SAVE_ERROR = 20010;\r\n      //其他编码\r\n  }\r\n  ```\r\n\r\n  controller 调用\r\n\r\n  ```java\r\n  @RestController\r\n  public class UserController {\r\n      @Autowired\r\n      private UserService userService;\r\n      @PostMapping\r\n      public Result save(User user){\r\n          boolean flag = userService.save(user);\r\n          return new Result(flag ? Code.SAVE_OK:Code.SAVE_ERROR);\r\n      }\r\n      @GetMapping("/{uuid}")\r\n      public Result get(@PathVariable Integer uuid){\r\n          User user = userService.get(uuid);\r\n          return new Result(null != user ?Code.GET_OK: Code.GET_ERROR,user);\r\n      }\r\n  }\r\n  ```\r\n\r\n  \r\n\r\n\r\n\r\n## 2.7 自定义异常\r\n\r\n**Part5-2：**自定义异常\r\n\r\n* 设定自定义异常，封装程序执行过程中出现的问题，便于表现层进行统一的异常拦截并进行处理\r\n  * BusinessException\r\n  * SystemException\r\n\r\n* 自定义异常消息返回时需要与业务正常执行的消息按照统一的格式进行处理\r\n\r\n\r\n\r\n**定义BusinessException**\r\n\r\n```java\r\npublic class BusinessException extends RuntimeException {\r\n    //自定义异常中封装对应的错误编码，用于异常处理时获取对应的操作编码\r\n    private Integer code;\r\n\r\n    public Integer getCode() {\r\n        return code;\r\n    }\r\n\r\n    public void setCode(Integer code) {\r\n        this.code = code;\r\n    }\r\n\r\n    public BusinessException(Integer code) {\r\n        this.code = code;\r\n    }\r\n\r\n    public BusinessException(String message, Integer code) {\r\n        super(message);\r\n        this.code = code;\r\n    }\r\n\r\n    public BusinessException(String message, Throwable cause,Integer code) {\r\n        super(message, cause);\r\n        this.code = code;\r\n    }\r\n\r\n    public BusinessException(Throwable cause,Integer code) {\r\n        super(cause);\r\n        this.code = code;\r\n    }\r\n\r\n    public BusinessException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace,Integer code) {\r\n        super(message, cause, enableSuppression, writableStackTrace);\r\n        this.code = code;\r\n    }\r\n}\r\n\r\n```\r\n\r\n```java\r\n@GetMapping("/{uuid}")\r\npublic Result get(@PathVariable Integer uuid){\r\n    User user = userService.get(uuid);\r\n    //模拟出现异常，使用条件控制，便于测试结果\r\n    if (uuid == 10 ) throw new BusinessException("查询出错啦，请重试！",Code.GET_ERROR);\r\n    return new Result(null != user ?Code.GET_OK: Code.GET_ERROR,user);\r\n}\r\n```\r\n\r\n\r\n\r\n## **2.8 返回消息兼容异常信息**\r\n\r\n```java\r\n@Component\r\n@ControllerAdvice\r\npublic class ProjectExceptionAdivce {\r\n    @ExceptionHandler(BusinessException.class)\r\n    @ResponseBody\r\n    //对出现异常的情况进行拦截，并将其处理成统一的页面数据结果格式\r\n    public Result doBusinessException(BusinessException e){\r\n        return new Result(e.getCode(),e.getMessage());\r\n    }\r\n}\r\n```\r\n\r\n# 3 纯注解开发SSM\r\n\r\n## 3.1 用注解替代applicationContext.xml\r\n\r\n同前期设置，添加事务注解驱动\r\n@Configuration\r\n\r\n```java\r\n//扫描组件，排除SpringMVC对应的bean，等同于<context:component-scan />\r\n@ComponentScan(value = "com.itheima",excludeFilters = {\r\n    @ComponentScan.Filter(type= FilterType.ANNOTATION,classes = {Controller.class})})\r\n@PropertySource("classpath:jdbc.properties")\r\n@Import({JdbcConfig.class,MyBatisConfig.class})\r\n//等同于<tx:annotation-driven transaction-manager="txManager"/>，导入的默认名称为transactionManager\r\n@EnableTransactionManagement\r\npublic class SpringConfig {\r\n    //等同于<bean   class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\r\n    @Bean("transactionManager")\r\n    public DataSourceTransactionManager getDataSourceTxManager(@Autowired DataSource dataSource){\r\n        DataSourceTransactionManager dtm = new DataSourceTransactionManager();\r\n        //等同于<property name="dataSource" ref="dataSource"/>\r\n        dtm.setDataSource(dataSource);\r\n        return dtm;\r\n    }\r\n}  \r\n```\r\n\r\n## 3.2 用注解替代spring-mvc.xml  \r\n\r\n*   同前期设置，添加@EnableWebMvc注解  \r\n\r\n  ```java\r\n  @Configuration\r\n  @ComponentScan("com.itheima.controller")\r\n  @EnableWebMvc\r\n  public class SpringMvcConfig implements WebMvcConfigurer {\r\n  }\r\n  ```\r\n\r\n*   EnableWebMvc  \r\n\r\n\r\n1. 支持ConversionService的配置，可以方便配置自定义类型转换器\r\n2. 支持@NumberFormat注解格式化数字类型\r\n3. 支持@DateTimeFormat注解格式化日期数据，日期包括Date,Calendar,JodaTime（JodaTime要导包）\r\n4. 支持@Valid的参数校验(需要导入JSR-303规范)\r\n5. 配合第三方jar包和SpringMVC提供的注解读写XML和JSON格式数据  '},"478a":function(n,e,t){"use strict";t.r(e),e["default"]='# jsp\r\n\r\n\r\n\r\n```\r\n       jsp\r\n            java 表达式 % %   %-%  %@%  %!%\r\n            jsp 表达式 %= %\r\n            四大域对象： 页面域 pageContext ，请求域 ServletRequest ，会话域 HttpSession，应用域 ServletContext\r\n            EL 表达式 ${} 直接从 各域对象找值 ,只要域对象中有就可以\r\n\r\n        \r\n```\r\n\r\n在本章中，我们将讨论和学习JSP中的隐式对象。这些对象是JSP容器为每个页面中的开发人员提供的Java对象，开发人员可以直接调用它们而不用显式地声明它们再调用。 JSP隐式对象也称为预定义变量。\r\n\r\n下表列出了JSP支持的九个隐式对象 -\r\n\r\n| 编号 | 对象          | 描述                                                    |\r\n| ---- | ------------- | ------------------------------------------------------- |\r\n| 1    | `request`     | 这是与请求相关联的`HttpServletRequest`对象。            |\r\n| 2    | `response`    | 这是与客户端的响应关联的`HttpServletResponse`对象。     |\r\n| 3    | `out`         | 这是用于将输出发送到客户端的`PrintWriter`对象。         |\r\n| 4    | `session`     | 这是与请求相关联的`HttpSession`对象。                   |\r\n| 5    | `application` | 这是与应用程序上下文相关联的`ServletContext`对象。      |\r\n| 6    | `config`      | 这是与该页面相关联的`ServletConfig`对象。               |\r\n| 7    | `pageContext` | 这封装了使用服务器特定的功能，如更高性能的`JspWriter`。 |\r\n| 8    | `page`        | 这只是一个同义词，用于调用由翻译的servlet类定义的方法。 |\r\n| 9    | `Exception`   | `Exception`对象允许指定的JSP访问异常数据。              |\r\n\r\n| 编号 | 对象            | 所属作用域      | 作用域描述               |\r\n| ---- | --------------- | --------------- | ------------------------ |\r\n| 1    | **request**     | **request**     | 在当前**请求**中有效     |\r\n| 2    | **response**    | **page**        | 在当前**页面**有效       |\r\n| 3    | **out**         | **page**        | 在当前**页面**有效       |\r\n| 4    | **session**     | **session**     | 在当前**会话**中有效     |\r\n| 5    | **application** | **application** | 在所有**应用程序**中有效 |\r\n| 6    | **config**      | **page**        | 在当前**页面**有效       |\r\n| 7    | **pageContext** | **page**        | 在当前**页面**有效       |\r\n| 8    | **page**        | **page**        | 在当前**页面**有效       |\r\n| 9    | **Exception**   | **page**        | 在当前**页面**有效       |\r\n\r\n## 1. request对象\r\n\r\n`request`对象是`javax.servlet.http.HttpServletRequest`对象的一个实例。每当客户端请求页面时，JSP引擎将创建一个新对象来表示该请求。\r\n\r\n`request`对象提供了获取包括表单数据，Cookie，HTTP方法等HTTP头信息的方法。\r\n\r\n## 2. response对象\r\n\r\n`response`对象是`javax.servlet.http.HttpServletResponse`对象的一个实例。就像服务器创建`request`对象一样，它还创建一个对象来表示对客户端的响应。\r\n\r\n`response`对象还定义了处理创建新HTTP头的接口。通过此对象，JSP程序员可以添加新的Cookie或日期戳，HTTP状态代码等。\r\n\r\n## 3. out对象\r\n\r\n`out`隐式对象是`javax.servlet.jsp.JspWriter`对象的一个实例，用于在响应中发送内容。\r\n\r\n初始化`JspWriter`对象根据页面是否缓存而不同地实例化。缓冲可以通过使用`page`指令的`buffered =\'false\'`属性来关闭。\r\n\r\n`JspWriter`对象包含与`java.io.PrintWriter`类大部分相同的方法。但是，`JspWriter`还有一些额外的方法用来处理缓冲。与`PrintWriter`对象不同，`JspWriter`会抛出`IOExceptions`异常。\r\n\r\n下表列出了用于写入`boolean`，`char`，`int`，`double`，`object`，`String`等类型数据的重要方法。\r\n\r\n| 编号 | 方法                       | 描述                                         |\r\n| ---- | -------------------------- | -------------------------------------------- |\r\n| 1    | `out.print(dataType dt)`   | 打印数据类型值                               |\r\n| 2    | `out.println(dataType dt)` | 打印数据类型值，然后用新行(换行)字符终止行。 |\r\n| 3    | `out.flush()`              | 刷新流                                       |\r\n\r\n## 4. session对象\r\n\r\n`session`对象是`javax.servlet.http.HttpSession`的一个实例，其行为与Java Servlet下的会话对象行为完全相同。\r\n`session`对象用于跟踪客户端请求之间的客户端会话。\r\n\r\n## 5. application对象\r\n\r\n`application`对象是生成的`Servlet`的`ServletContext`对象的直接包装，实际上是`javax.servlet.ServletContext`对象的一个实例。\r\n\r\n`application`对象是JSP页面在其整个生命周期中的表示。 当JSP页面被初始化时，将创建此对象，并且在JSP页面被`jspDestroy()`方法删除时`application`对象也将被删除。\r\n\r\n通过向`application`对象添加属性值，可以确保组成Web应用程序的所有JSP文件都可以访问它。\r\n\r\n## 6. config对象\r\n\r\n`config`对象是`javax.servlet.ServletConfig`的实例化，是生成的servlet的`ServletConfig`对象周围的直接包装。\r\n\r\n该对象允许JSP程序员访问Servlet或JSP引擎初始化参数，例如：路径或文件位置等。\r\n以下配置方法是唯一可以使用的配置方法，它的用法是非常简单的 -\r\n\r\n```java\r\nconfig.getServletName();\r\nJava\r\n```\r\n\r\n这将返回当前`servlet`名称，它是包含在`WEB-INF\\web.xml`文件中定义的`<servlet-name>`元素中的字符串。\r\n\r\n## 7. pageContext对象\r\n\r\n`pageContext`对象是`javax.servlet.jsp.PageContext`对象的一个实例。`pageContext`对象用于表示整个JSP页面。\r\n\r\n`pageContext`对象旨在作为访问有关页面的信息的一种手段，同时避免大部分实现细节。\r\n该对象存储对每个请求的请求和响应对象的引用。应用程序，配置，会话和输出对象是通过访问此对象的属性导出的。\r\n\r\n`pageContext`对象还包含有关发布到JSP页面的指令的信息，包括缓冲信息，`errorPageURL`和页面范围。\r\n\r\n`PageContext`类定义了几个字段，包括：`PAGE_SCOPE`，`REQUEST_SCOPE`，`SESSION_SCOPE`和`APPLICATION_SCOPE`，它们标识了四个范围。它还支持超过`40`种方法，其中约一半是从`javax.servlet.jsp.JspContext`类继承的。\r\n\r\n其中一个重要的方法是`removeAttribute`。 此方法接受一个或两个参数。 例如，`pageContext.removeAttribute("attrName")`从所有作用域中删除属性，而以下代码仅将其从页面范围中删除 -\r\n\r\n```java\r\npageContext.removeAttribute("attrName", PAGE_SCOPE);\r\nJava\r\n```\r\n\r\n## 8. page对象\r\n\r\n`page`对象是对该页面实例的实际引用。可以认为它是表示整个JSP页面的对象。\r\n\r\n`page`对象是`this`对象的直接同义词。\r\n\r\n## 9. exception对象\r\n\r\n`exception`对象是一个包含上一页抛出的异常的包装器。它通常用于生成对错误条件的适当响应。\r\n\r\n\r\n\r\n#### JSP 标准标签库（JSTL）\r\n\r\nhttps://www.runoob.com/jsp/jsp-jstl.html'},"47d8":function(n,e,t){"use strict";t.r(e),e["default"]='\n### 文章目录\n\x3c!-- TOC --\x3e\n\n- [文章目录](#%e6%96%87%e7%ab%a0%e7%9b%ae%e5%bd%95)\n- [0.前言](#0%e5%89%8d%e8%a8%80)\n- [1. `@SpringBootApplication`](#1-springbootapplication)\n- [2. Spring Bean 相关](#2-spring-bean-%e7%9b%b8%e5%85%b3)\n  - [2.1. `@Autowired`](#21-autowired)\n  - [2.2. `@Component`,`@Repository`,`@Service`, `@Controller`](#22-componentrepositoryservice-controller)\n  - [2.3. `@RestController`](#23-restcontroller)\n  - [2.4. `@Scope`](#24-scope)\n  - [2.5. `@Configuration`](#25-configuration)\n- [3. 处理常见的 HTTP 请求类型](#3-%e5%a4%84%e7%90%86%e5%b8%b8%e8%a7%81%e7%9a%84-http-%e8%af%b7%e6%b1%82%e7%b1%bb%e5%9e%8b)\n  - [3.1. GET 请求](#31-get-%e8%af%b7%e6%b1%82)\n  - [3.2. POST 请求](#32-post-%e8%af%b7%e6%b1%82)\n  - [3.3. PUT 请求](#33-put-%e8%af%b7%e6%b1%82)\n  - [3.4. **DELETE 请求**](#34-delete-%e8%af%b7%e6%b1%82)\n  - [3.5. **PATCH 请求**](#35-patch-%e8%af%b7%e6%b1%82)\n- [4. 前后端传值](#4-%e5%89%8d%e5%90%8e%e7%ab%af%e4%bc%a0%e5%80%bc)\n  - [4.1. `@PathVariable` 和 `@RequestParam`](#41-pathvariable-%e5%92%8c-requestparam)\n  - [4.2. `@RequestBody`](#42-requestbody)\n- [5. 读取配置信息](#5-%e8%af%bb%e5%8f%96%e9%85%8d%e7%bd%ae%e4%bf%a1%e6%81%af)\n  - [5.1. `@value`(常用)](#51-value%e5%b8%b8%e7%94%a8)\n  - [5.2. `@ConfigurationProperties`(常用)](#52-configurationproperties%e5%b8%b8%e7%94%a8)\n  - [5.3. `PropertySource`（不常用）](#53-propertysource%e4%b8%8d%e5%b8%b8%e7%94%a8)\n- [6. 参数校验](#6-%e5%8f%82%e6%95%b0%e6%a0%a1%e9%aa%8c)\n  - [6.1. 一些常用的字段验证的注解](#61-%e4%b8%80%e4%ba%9b%e5%b8%b8%e7%94%a8%e7%9a%84%e5%ad%97%e6%ae%b5%e9%aa%8c%e8%af%81%e7%9a%84%e6%b3%a8%e8%a7%a3)\n  - [6.2. 验证请求体(RequestBody)](#62-%e9%aa%8c%e8%af%81%e8%af%b7%e6%b1%82%e4%bd%93requestbody)\n  - [6.3. 验证请求参数(Path Variables 和 Request Parameters)](#63-%e9%aa%8c%e8%af%81%e8%af%b7%e6%b1%82%e5%8f%82%e6%95%b0path-variables-%e5%92%8c-request-parameters)\n- [7. 全局处理 Controller 层异常](#7-%e5%85%a8%e5%b1%80%e5%a4%84%e7%90%86-controller-%e5%b1%82%e5%bc%82%e5%b8%b8)\n- [8. JPA 相关](#8-jpa-%e7%9b%b8%e5%85%b3)\n  - [8.1. 创建表](#81-%e5%88%9b%e5%bb%ba%e8%a1%a8)\n  - [8.2. 创建主键](#82-%e5%88%9b%e5%bb%ba%e4%b8%bb%e9%94%ae)\n  - [8.3. 设置字段类型](#83-%e8%ae%be%e7%bd%ae%e5%ad%97%e6%ae%b5%e7%b1%bb%e5%9e%8b)\n  - [8.4. 指定不持久化特定字段](#84-%e6%8c%87%e5%ae%9a%e4%b8%8d%e6%8c%81%e4%b9%85%e5%8c%96%e7%89%b9%e5%ae%9a%e5%ad%97%e6%ae%b5)\n  - [8.5. 声明大字段](#85-%e5%a3%b0%e6%98%8e%e5%a4%a7%e5%ad%97%e6%ae%b5)\n  - [8.6. 创建枚举类型的字段](#86-%e5%88%9b%e5%bb%ba%e6%9e%9a%e4%b8%be%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%ad%97%e6%ae%b5)\n  - [8.7. 增加审计功能](#87-%e5%a2%9e%e5%8a%a0%e5%ae%a1%e8%ae%a1%e5%8a%9f%e8%83%bd)\n  - [8.8. 删除/修改数据](#88-%e5%88%a0%e9%99%a4%e4%bf%ae%e6%94%b9%e6%95%b0%e6%8d%ae)\n  - [8.9. 关联关系](#89-%e5%85%b3%e8%81%94%e5%85%b3%e7%b3%bb)\n- [9. 事务 `@Transactional`](#9-%e4%ba%8b%e5%8a%a1-transactional)\n- [10. json 数据处理](#10-json-%e6%95%b0%e6%8d%ae%e5%a4%84%e7%90%86)\n  - [10.1. 过滤 json 数据](#101-%e8%bf%87%e6%bb%a4-json-%e6%95%b0%e6%8d%ae)\n  - [10.2. 格式化 json 数据](#102-%e6%a0%bc%e5%bc%8f%e5%8c%96-json-%e6%95%b0%e6%8d%ae)\n  - [10.3. 扁平化对象](#103-%e6%89%81%e5%b9%b3%e5%8c%96%e5%af%b9%e8%b1%a1)\n- [11. 测试相关](#11-%e6%b5%8b%e8%af%95%e7%9b%b8%e5%85%b3)\n\n\x3c!-- /TOC --\x3e\n### 0.前言\n\n_大家好，我是 Guide 哥！这是我的 221 篇优质原创文章。如需转载，请在文首注明地址，蟹蟹！_\n\n本文已经收录进我的 75K Star 的 Java 开源项目 JavaGuide：[https://github.com/Snailclimb/JavaGuide](https://github.com/Snailclimb/JavaGuide)。\n\n可以毫不夸张地说，这篇文章介绍的 Spring/SpringBoot 常用注解基本已经涵盖你工作中遇到的大部分常用的场景。对于每一个注解我都说了具体用法，掌握搞懂，使用 SpringBoot 来开发项目基本没啥大问题了！\n\n**为什么要写这篇文章？**\n\n最近看到网上有一篇关于 SpringBoot 常用注解的文章被转载的比较多，我看了文章内容之后属实觉得质量有点低，并且有点会误导没有太多实际使用经验的人（这些人又占据了大多数）。所以，自己索性花了大概 两天时间简单总结一下了。\n\n**因为我个人的能力和精力有限，如果有任何不对或者需要完善的地方，请帮忙指出！Guide 哥感激不尽！**\n\n### 1. `@SpringBootApplication`\n\n这里先单独拎出`@SpringBootApplication` 注解说一下，虽然我们一般不会主动去使用它。\n\n_Guide 哥：这个注解是 Spring Boot 项目的基石，创建 SpringBoot 项目之后会默认在主类加上。_\n\n```java\n@SpringBootApplication\npublic class SpringSecurityJwtGuideApplication {\n      public static void main(java.lang.String[] args) {\n        SpringApplication.run(SpringSecurityJwtGuideApplication.class, args);\n    }\n}\n```\n\n我们可以把 `@SpringBootApplication`看作是 `@Configuration`、`@EnableAutoConfiguration`、`@ComponentScan` 注解的集合。\n\n```java\npackage org.springframework.boot.autoconfigure;\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(excludeFilters = {\n\t\t@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n   ......\n}\n\npackage org.springframework.boot;\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Configuration\npublic @interface SpringBootConfiguration {\n\n}\n```\n\n根据 SpringBoot 官网，这三个注解的作用分别是：\n\n- `@EnableAutoConfiguration`：启用 SpringBoot 的自动配置机制\n- `@ComponentScan`： 扫描被`@Component` (`@Service`,`@Controller`)注解的 bean，注解默认会扫描该类所在的包下所有的类。\n- `@Configuration`：允许在 Spring 上下文中注册额外的 bean 或导入其他配置类\n\n### 2. Spring Bean 相关\n\n#### 2.1. `@Autowired`\n\n自动导入对象到类中，被注入进的类同样要被 Spring 容器管理比如：Service 类注入到 Controller 类中。\n\n```java\n@Service\npublic class UserService {\n  ......\n}\n\n@RestController\n@RequestMapping("/users")\npublic class UserController {\n   @Autowired\n   private UserService userService;\n   ......\n}\n```\n\n#### 2.2. `@Component`,`@Repository`,`@Service`, `@Controller`\n\n我们一般使用 `@Autowired` 注解让 Spring 容器帮我们自动装配 bean。要想把类标识成可用于 `@Autowired` 注解自动装配的 bean 的类,可以采用以下注解实现：\n\n- `@Component` ：通用的注解，可标注任意类为 `Spring` 组件。如果一个 Bean 不知道属于哪个层，可以使用`@Component` 注解标注。\n- `@Repository` : 对应持久层即 Dao 层，主要用于数据库相关操作。\n- `@Service` : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。\n- `@Controller` : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。\n\n#### 2.3. `@RestController`\n\n`@RestController`注解是`@Controller`和`@ResponseBody`的合集,表示这是个控制器 bean,并且是将函数的返回值直接填入 HTTP 响应体中,是 REST 风格的控制器。\n\n_Guide 哥：现在都是前后端分离，说实话我已经很久没有用过`@Controller`。如果你的项目太老了的话，就当我没说。_\n\n单独使用 `@Controller` 不加 `@ResponseBody`的话一般是用在要返回一个视图的情况，这种情况属于比较传统的 Spring MVC 的应用，对应于前后端不分离的情况。`@Controller` +`@ResponseBody` 返回 JSON 或 XML 形式数据\n\n关于`@RestController` 和 `@Controller`的对比，请看这篇文章：[@RestController vs @Controller](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485544&idx=1&sn=3cc95b88979e28fe3bfe539eb421c6d8&chksm=cea247a3f9d5ceb5e324ff4b8697adc3e828ecf71a3468445e70221cce768d1e722085359907&token=1725092312&lang=zh_CN#rd)。\n\n#### 2.4. `@Scope`\n\n声明 Spring Bean 的作用域，使用方法:\n\n```java\n@Bean\n@Scope("singleton")\npublic Person personSingleton() {\n    return new Person();\n}\n```\n\n**四种常见的 Spring Bean 的作用域：**\n\n- singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。\n- prototype : 每次请求都会创建一个新的 bean 实例。\n- request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。\n- session : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。\n\n#### 2.5. `@Configuration`\n\n一般用来声明配置类，可以使用 `@Component`注解替代，不过使用`@Configuration`注解声明配置类更加语义化。\n\n```java\n@Configuration\npublic class AppConfig {\n    @Bean\n    public TransferService transferService() {\n        return new TransferServiceImpl();\n    }\n\n}\n```\n\n### 3. 处理常见的 HTTP 请求类型\n\n**5 种常见的请求类型:**\n\n- **GET** ：请求从服务器获取特定资源。举个例子：`GET /users`（获取所有学生）\n- **POST** ：在服务器上创建一个新的资源。举个例子：`POST /users`（创建学生）\n- **PUT** ：更新服务器上的资源（客户端提供更新后的整个资源）。举个例子：`PUT /users/12`（更新编号为 12 的学生）\n- **DELETE** ：从服务器删除特定的资源。举个例子：`DELETE /users/12`（删除编号为 12 的学生）\n- **PATCH** ：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新），使用的比较少，这里就不举例子了。\n\n#### 3.1. GET 请求\n\n`@GetMapping("users")` 等价于`@RequestMapping(value="/users",method=RequestMethod.GET)`\n\n```java\n@GetMapping("/users")\npublic ResponseEntity<List<User>> getAllUsers() {\n return userRepository.findAll();\n}\n```\n\n#### 3.2. POST 请求\n\n`@PostMapping("users")` 等价于`@RequestMapping(value="/users",method=RequestMethod.POST)`\n\n关于`@RequestBody`注解的使用，在下面的“前后端传值”这块会讲到。\n\n```java\n@PostMapping("/users")\npublic ResponseEntity<User> createUser(@Valid @RequestBody UserCreateRequest userCreateRequest) {\n return userRespository.save(userCreateRequest);\n}\n```\n\n#### 3.3. PUT 请求\n\n`@PutMapping("/users/{userId}")` 等价于`@RequestMapping(value="/users/{userId}",method=RequestMethod.PUT)`\n\n```java\n@PutMapping("/users/{userId}")\npublic ResponseEntity<User> updateUser(@PathVariable(value = "userId") Long userId,\n  @Valid @RequestBody UserUpdateRequest userUpdateRequest) {\n  ......\n}\n```\n\n#### 3.4. **DELETE 请求**\n\n`@DeleteMapping("/users/{userId}")`等价于`@RequestMapping(value="/users/{userId}",method=RequestMethod.DELETE)`\n\n```java\n@DeleteMapping("/users/{userId}")\npublic ResponseEntity deleteUser(@PathVariable(value = "userId") Long userId){\n  ......\n}\n```\n\n#### 3.5. **PATCH 请求**\n\n一般实际项目中，我们都是 PUT 不够用了之后才用 PATCH 请求去更新数据。\n\n```java\n  @PatchMapping("/profile")\n  public ResponseEntity updateStudent(@RequestBody StudentUpdateRequest studentUpdateRequest) {\n        studentRepository.updateDetail(studentUpdateRequest);\n        return ResponseEntity.ok().build();\n    }\n```\n\n### 4. 前后端传值\n\n**掌握前后端传值的正确姿势，是你开始 CRUD 的第一步！**\n\n#### 4.1. `@PathVariable` 和 `@RequestParam`\n\n`@PathVariable`用于获取路径参数，`@RequestParam`用于获取查询参数。\n\n举个简单的例子：\n\n```java\n@GetMapping("/klasses/{klassId}/teachers")\npublic List<Teacher> getKlassRelatedTeachers(\n         @PathVariable("klassId") Long klassId,\n         @RequestParam(value = "type", required = false) String type ) {\n...\n}\n```\n\n如果我们请求的 url 是：`/klasses/123456/teachers?type=web`\n\n那么我们服务获取到的数据就是：`klassId=123456,type=web`。\n\n#### 4.2. `@RequestBody`\n\n用于读取 Request 请求（可能是 POST,PUT,DELETE,GET 请求）的 body 部分并且**Content-Type 为 application/json** 格式的数据，接收到数据之后会自动将数据绑定到 Java 对象上去。系统会使用`HttpMessageConverter`或者自定义的`HttpMessageConverter`将请求的 body 中的 json 字符串转换为 java 对象。\n\n我用一个简单的例子来给演示一下基本使用！\n\n我们有一个注册的接口：\n\n```java\n@PostMapping("/sign-up")\npublic ResponseEntity signUp(@RequestBody @Valid UserRegisterRequest userRegisterRequest) {\n  userService.save(userRegisterRequest);\n  return ResponseEntity.ok().build();\n}\n```\n\n`UserRegisterRequest`对象：\n\n```java\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class UserRegisterRequest {\n    @NotBlank\n    private String userName;\n    @NotBlank\n    private String password;\n    @NotBlank\n    private String fullName;\n}\n```\n\n我们发送 post 请求到这个接口，并且 body 携带 JSON 数据：\n\n```json\n{"userName":"coder","fullName":"shuangkou","password":"123456"}\n```\n\n这样我们的后端就可以直接把 json 格式的数据映射到我们的 `UserRegisterRequest` 类上。\n\n![](SpringBoot+Spring常用注解总结.assets/@RequestBody.png)\n\n👉 需要注意的是：**一个请求方法只可以有一个`@RequestBody`，但是可以有多个`@RequestParam`和`@PathVariable`**。 如果你的方法必须要用两个 `@RequestBody`来接受数据的话，大概率是你的数据库设计或者系统设计出问题了！\n\n### 5. 读取配置信息\n\n**很多时候我们需要将一些常用的配置信息比如阿里云 oss、发送短信、微信认证的相关配置信息等等放到配置文件中。**\n\n**下面我们来看一下 Spring 为我们提供了哪些方式帮助我们从配置文件中读取这些配置信息。**\n\n我们的数据源`application.yml`内容如下：\n\n```yaml\nwuhan2020: 2020年初武汉爆发了新型冠状病毒，疫情严重，但是，我相信一切都会过去！武汉加油！中国加油！\n\nmy-profile:\n  name: Guide哥\n  email: koushuangbwcx@163.com\n\nlibrary:\n  location: 湖北武汉加油中国加油\n  books:\n    - name: 天才基本法\n      description: 二十二岁的林朝夕在父亲确诊阿尔茨海默病这天，得知自己暗恋多年的校园男神裴之即将出国深造的消息——对方考取的学校，恰是父亲当年为她放弃的那所。\n    - name: 时间的秩序\n      description: 为什么我们记得过去，而非未来？时间“流逝”意味着什么？是我们存在于时间之内，还是时间存在于我们之中？卡洛·罗韦利用诗意的文字，邀请我们思考这一亘古难题——时间的本质。\n    - name: 了不起的我\n      description: 如何养成一个新习惯？如何让心智变得更成熟？如何拥有高质量的关系？ 如何走出人生的艰难时刻？\n```\n\n#### 5.1. `@Value`(常用)\n\n使用 `@Value("${property}")` 读取比较简单的配置信息：\n\n```java\n@Value("${wuhan2020}")\nString wuhan2020;\n```\n\n#### 5.2. `@ConfigurationProperties`(常用)\n\n通过`@ConfigurationProperties`读取配置信息并与 bean 绑定。\n\n```java\n@Component\n@ConfigurationProperties(prefix = "library")\nclass LibraryProperties {\n    @NotEmpty\n    private String location;\n    private List<Book> books;\n\n    @Setter\n    @Getter\n    @ToString\n    static class Book {\n        String name;\n        String description;\n    }\n  省略getter/setter\n  ......\n}\n```\n\n你可以像使用普通的 Spring bean 一样，将其注入到类中使用。\n\n#### 5.3. `@PropertySource`（不常用）\n\n`@PropertySource`读取指定 properties 文件\n\n```java\n@Component\n@PropertySource("classpath:website.properties")\n\nclass WebSite {\n    @Value("${url}")\n    private String url;\n\n  省略getter/setter\n  ......\n}\n```\n\n更多内容请查看我的这篇文章：《[10 分钟搞定 SpringBoot 如何优雅读取配置文件？](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486181&idx=2&sn=10db0ae64ef501f96a5b0dbc4bd78786&chksm=cea2452ef9d5cc384678e456427328600971180a77e40c13936b19369672ca3e342c26e92b50&token=816772476&lang=zh_CN#rd)》 。\n\n### 6. 参数校验\n\n**数据的校验的重要性就不用说了，即使在前端对数据进行校验的情况下，我们还是要对传入后端的数据再进行一遍校验，避免用户绕过浏览器直接通过一些 HTTP 工具直接向后端请求一些违法数据。**\n\n**JSR(Java Specification Requests）** 是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注解加在我们 JavaBean 的属性上面，这样就可以在需要校验的时候进行校验了，非常方便！\n\n校验的时候我们实际用的是 **Hibernate Validator** 框架。Hibernate Validator 是 Hibernate 团队最初的数据校验框架，Hibernate Validator 4.x 是 Bean Validation 1.0（JSR 303）的参考实现，Hibernate Validator 5.x 是 Bean Validation 1.1（JSR 349）的参考实现，目前最新版的 Hibernate Validator 6.x 是 Bean Validation 2.0（JSR 380）的参考实现。\n\nSpringBoot 项目的 spring-boot-starter-web 依赖中已经有 hibernate-validator 包，不需要引用相关依赖。如下图所示（通过 idea 插件—Maven Helper 生成）：\n\n**注**：更新版本的 spring-boot-starter-web 依赖中不再有 hibernate-validator 包（如2.3.11.RELEASE），需要自己引入 `spring-boot-starter-validation` 依赖。\n\n![](SpringBoot+Spring常用注解总结.assets/c7bacd12-1c1a-4e41-aaaf-4cad840fc073.png)\n\n非 SpringBoot 项目需要自行引入相关依赖包，这里不多做讲解，具体可以查看我的这篇文章：《[如何在 Spring/Spring Boot 中做参数校验？你需要了解的都在这里！](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485783&idx=1&sn=a407f3b75efa17c643407daa7fb2acd6&chksm=cea2469cf9d5cf8afbcd0a8a1c9cc4294d6805b8e01bee6f76bb2884c5bc15478e91459def49&token=292197051&lang=zh_CN#rd)》。\n\n👉 需要注意的是： **所有的注解，推荐使用 JSR 注解，即`javax.validation.constraints`，而不是`org.hibernate.validator.constraints`**\n\n#### 6.1. 一些常用的字段验证的注解\n\n- `@NotEmpty` 被注释的字符串的不能为 null 也不能为空\n- `@NotBlank` 被注释的字符串非 null，并且必须包含一个非空白字符\n- `@Null` 被注释的元素必须为 null\n- `@NotNull` 被注释的元素必须不为 null\n- `@AssertTrue` 被注释的元素必须为 true\n- `@AssertFalse` 被注释的元素必须为 false\n- `@Pattern(regex=,flag=)`被注释的元素必须符合指定的正则表达式\n- `@Email` 被注释的元素必须是 Email 格式。\n- `@Min(value)`被注释的元素必须是一个数字，其值必须大于等于指定的最小值\n- `@Max(value)`被注释的元素必须是一个数字，其值必须小于等于指定的最大值\n- `@DecimalMin(value)`被注释的元素必须是一个数字，其值必须大于等于指定的最小值\n- `@DecimalMax(value)` 被注释的元素必须是一个数字，其值必须小于等于指定的最大值\n- `@Size(max=, min=)`被注释的元素的大小必须在指定的范围内\n- `@Digits(integer, fraction)`被注释的元素必须是一个数字，其值必须在可接受的范围内\n- `@Past`被注释的元素必须是一个过去的日期\n- `@Future` 被注释的元素必须是一个将来的日期\n- ......\n\n#### 6.2. 验证请求体(RequestBody)\n\n```java\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Person {\n\n    @NotNull(message = "classId 不能为空")\n    private String classId;\n\n    @Size(max = 33)\n    @NotNull(message = "name 不能为空")\n    private String name;\n\n    @Pattern(regexp = "((^Man$|^Woman$|^UGM$))", message = "sex 值不在可选范围")\n    @NotNull(message = "sex 不能为空")\n    private String sex;\n\n    @Email(message = "email 格式不正确")\n    @NotNull(message = "email 不能为空")\n    private String email;\n\n}\n```\n\n我们在需要验证的参数上加上了`@Valid`注解，如果验证失败，它将抛出`MethodArgumentNotValidException`。\n\n```java\n@RestController\n@RequestMapping("/api")\npublic class PersonController {\n\n    @PostMapping("/person")\n    public ResponseEntity<Person> getPerson(@RequestBody @Valid Person person) {\n        return ResponseEntity.ok().body(person);\n    }\n}\n```\n\n#### 6.3. 验证请求参数(Path Variables 和 Request Parameters)\n\n**一定一定不要忘记在类上加上 `@Validated` 注解了，这个参数可以告诉 Spring 去校验方法参数。**\n\n```java\n@RestController\n@RequestMapping("/api")\n@Validated\npublic class PersonController {\n\n    @GetMapping("/person/{id}")\n    public ResponseEntity<Integer> getPersonByID(@Valid @PathVariable("id") @Max(value = 5,message = "超过 id 的范围了") Integer id) {\n        return ResponseEntity.ok().body(id);\n    }\n}\n```\n\n更多关于如何在 Spring 项目中进行参数校验的内容，请看《[如何在 Spring/Spring Boot 中做参数校验？你需要了解的都在这里！](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485783&idx=1&sn=a407f3b75efa17c643407daa7fb2acd6&chksm=cea2469cf9d5cf8afbcd0a8a1c9cc4294d6805b8e01bee6f76bb2884c5bc15478e91459def49&token=292197051&lang=zh_CN#rd)》这篇文章。\n\n### 7. 全局处理 Controller 层异常\n\n介绍一下我们 Spring 项目必备的全局处理 Controller 层异常。\n\n**相关注解：**\n\n1. `@ControllerAdvice` :注解定义全局异常处理类\n2. `@ExceptionHandler` :注解声明异常处理方法\n\n如何使用呢？拿我们在第 5 节参数校验这块来举例子。如果方法参数不对的话就会抛出`MethodArgumentNotValidException`，我们来处理这个异常。\n\n```java\n@ControllerAdvice\n@ResponseBody\npublic class GlobalExceptionHandler {\n\n    /**\n     * 请求参数异常处理\n     */\n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public ResponseEntity<?> handleMethodArgumentNotValidException(MethodArgumentNotValidException ex, HttpServletRequest request) {\n       ......\n    }\n}\n```\n\n更多关于 Spring Boot 异常处理的内容，请看我的这两篇文章：\n\n1. [SpringBoot 处理异常的几种常见姿势](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485568&idx=2&sn=c5ba880fd0c5d82e39531fa42cb036ac&chksm=cea2474bf9d5ce5dcbc6a5f6580198fdce4bc92ef577579183a729cb5d1430e4994720d59b34&token=2133161636&lang=zh_CN#rd)\n2. [使用枚举简单封装一个优雅的 Spring Boot 全局异常处理！](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486379&idx=2&sn=48c29ae65b3ed874749f0803f0e4d90e&chksm=cea24460f9d5cd769ed53ad7e17c97a7963a89f5350e370be633db0ae8d783c3a3dbd58c70f8&token=1054498516&lang=zh_CN#rd)\n\n### 8. JPA 相关\n\n#### 8.1. 创建表\n\n`@Entity`声明一个类对应一个数据库实体。\n\n`@Table` 设置表名\n\n```java\n@Entity\n@Table(name = "role")\npublic class Role {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    private String name;\n    private String description;\n    省略getter/setter......\n}\n```\n\n#### 8.2. 创建主键\n\n`@Id` ：声明一个字段为主键。\n\n使用`@Id`声明之后，我们还需要定义主键的生成策略。我们可以使用 `@GeneratedValue` 指定主键生成策略。\n\n**1.通过 `@GeneratedValue`直接使用 JPA 内置提供的四种主键生成策略来指定主键生成策略。**\n\n```java\n@Id\n@GeneratedValue(strategy = GenerationType.IDENTITY)\nprivate Long id;\n```\n\nJPA 使用枚举定义了 4 种常见的主键生成策略，如下：\n\n_Guide 哥：枚举替代常量的一种用法_\n\n```java\npublic enum GenerationType {\n\n    /**\n     * 使用一个特定的数据库表格来保存主键\n     * 持久化引擎通过关系数据库的一张特定的表格来生成主键,\n     */\n    TABLE,\n\n    /**\n     *在某些数据库中,不支持主键自增长,比如Oracle、PostgreSQL其提供了一种叫做"序列(sequence)"的机制生成主键\n     */\n    SEQUENCE,\n\n    /**\n     * 主键自增长\n     */\n    IDENTITY,\n\n    /**\n     *把主键生成策略交给持久化引擎(persistence engine),\n     *持久化引擎会根据数据库在以上三种主键生成 策略中选择其中一种\n     */\n    AUTO\n}\n\n```\n\n`@GeneratedValue`注解默认使用的策略是`GenerationType.AUTO`\n\n```java\npublic @interface GeneratedValue {\n\n    GenerationType strategy() default AUTO;\n    String generator() default "";\n}\n```\n\n一般使用 MySQL 数据库的话，使用`GenerationType.IDENTITY`策略比较普遍一点（分布式系统的话需要另外考虑使用分布式 ID）。\n\n**2.通过 `@GenericGenerator`声明一个主键策略，然后 `@GeneratedValue`使用这个策略**\n\n```java\n@Id\n@GeneratedValue(generator = "IdentityIdGenerator")\n@GenericGenerator(name = "IdentityIdGenerator", strategy = "identity")\nprivate Long id;\n```\n\n等价于：\n\n```java\n@Id\n@GeneratedValue(strategy = GenerationType.IDENTITY)\nprivate Long id;\n```\n\njpa 提供的主键生成策略有如下几种：\n\n```java\npublic class DefaultIdentifierGeneratorFactory\n\t\timplements MutableIdentifierGeneratorFactory, Serializable, ServiceRegistryAwareService {\n\n\t@SuppressWarnings("deprecation")\n\tpublic DefaultIdentifierGeneratorFactory() {\n\t\tregister( "uuid2", UUIDGenerator.class );\n\t\tregister( "guid", GUIDGenerator.class );\t\t\t// can be done with UUIDGenerator + strategy\n\t\tregister( "uuid", UUIDHexGenerator.class );\t\t\t// "deprecated" for new use\n\t\tregister( "uuid.hex", UUIDHexGenerator.class ); \t// uuid.hex is deprecated\n\t\tregister( "assigned", Assigned.class );\n\t\tregister( "identity", IdentityGenerator.class );\n\t\tregister( "select", SelectGenerator.class );\n\t\tregister( "sequence", SequenceStyleGenerator.class );\n\t\tregister( "seqhilo", SequenceHiLoGenerator.class );\n\t\tregister( "increment", IncrementGenerator.class );\n\t\tregister( "foreign", ForeignGenerator.class );\n\t\tregister( "sequence-identity", SequenceIdentityGenerator.class );\n\t\tregister( "enhanced-sequence", SequenceStyleGenerator.class );\n\t\tregister( "enhanced-table", TableGenerator.class );\n\t}\n\n\tpublic void register(String strategy, Class generatorClass) {\n\t\tLOG.debugf( "Registering IdentifierGenerator strategy [%s] -> [%s]", strategy, generatorClass.getName() );\n\t\tfinal Class previous = generatorStrategyToClassNameMap.put( strategy, generatorClass );\n\t\tif ( previous != null ) {\n\t\t\tLOG.debugf( "    - overriding [%s]", previous.getName() );\n\t\t}\n\t}\n\n}\n```\n\n#### 8.3. 设置字段类型\n\n`@Column` 声明字段。\n\n**示例：**\n\n设置属性 userName 对应的数据库字段名为 user_name，长度为 32，非空\n\n```java\n@Column(name = "user_name", nullable = false, length=32)\nprivate String userName;\n```\n\n设置字段类型并且加默认值，这个还是挺常用的。\n\n```java\n@Column(columnDefinition = "tinyint(1) default 1")\nprivate Boolean enabled;\n```\n\n#### 8.4. 指定不持久化特定字段\n\n`@Transient` ：声明不需要与数据库映射的字段，在保存的时候不需要保存进数据库 。\n\n如果我们想让`secrect` 这个字段不被持久化，可以使用 `@Transient`关键字声明。\n\n```java\n@Entity(name="USER")\npublic class User {\n\n    ......\n    @Transient\n    private String secrect; // not persistent because of @Transient\n\n}\n```\n\n除了 `@Transient`关键字声明， 还可以采用下面几种方法：\n\n```java\nstatic String secrect; // not persistent because of static\nfinal String secrect = "Satish"; // not persistent because of final\ntransient String secrect; // not persistent because of transient\n```\n\n一般使用注解的方式比较多。\n\n#### 8.5. 声明大字段\n\n`@Lob`:声明某个字段为大字段。\n\n```java\n@Lob\nprivate String content;\n```\n\n更详细的声明：\n\n```java\n@Lob\n//指定 Lob 类型数据的获取策略， FetchType.EAGER 表示非延迟加载，而 FetchType.LAZY 表示延迟加载 ；\n@Basic(fetch = FetchType.EAGER)\n//columnDefinition 属性指定数据表对应的 Lob 字段类型\n@Column(name = "content", columnDefinition = "LONGTEXT NOT NULL")\nprivate String content;\n```\n\n#### 8.6. 创建枚举类型的字段\n\n可以使用枚举类型的字段，不过枚举字段要用`@Enumerated`注解修饰。\n\n```java\npublic enum Gender {\n    MALE("男性"),\n    FEMALE("女性");\n\n    private String value;\n    Gender(String str){\n        value=str;\n    }\n}\n```\n\n```java\n@Entity\n@Table(name = "role")\npublic class Role {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    private String name;\n    private String description;\n    @Enumerated(EnumType.STRING)\n    private Gender gender;\n    省略getter/setter......\n}\n```\n\n数据库里面对应存储的是 MALE/FEMALE。\n\n#### 8.7. 增加审计功能\n\n只要继承了 `AbstractAuditBase`的类都会默认加上下面四个字段。\n\n```java\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@MappedSuperclass\n@EntityListeners(value = AuditingEntityListener.class)\npublic abstract class AbstractAuditBase {\n\n    @CreatedDate\n    @Column(updatable = false)\n    @JsonIgnore\n    private Instant createdAt;\n\n    @LastModifiedDate\n    @JsonIgnore\n    private Instant updatedAt;\n\n    @CreatedBy\n    @Column(updatable = false)\n    @JsonIgnore\n    private String createdBy;\n\n    @LastModifiedBy\n    @JsonIgnore\n    private String updatedBy;\n}\n\n```\n\n我们对应的审计功能对应地配置类可能是下面这样的（Spring Security 项目）:\n\n```java\n\n@Configuration\n@EnableJpaAuditing\npublic class AuditSecurityConfiguration {\n    @Bean\n    AuditorAware<String> auditorAware() {\n        return () -> Optional.ofNullable(SecurityContextHolder.getContext())\n                .map(SecurityContext::getAuthentication)\n                .filter(Authentication::isAuthenticated)\n                .map(Authentication::getName);\n    }\n}\n```\n\n简单介绍一下上面涉及到的一些注解：\n\n1. `@CreatedDate`: 表示该字段为创建时间字段，在这个实体被 insert 的时候，会设置值\n2. `@CreatedBy` :表示该字段为创建人，在这个实体被 insert 的时候，会设置值\n\n   `@LastModifiedDate`、`@LastModifiedBy`同理。\n\n`@EnableJpaAuditing`：开启 JPA 审计功能。\n\n#### 8.8. 删除/修改数据\n\n`@Modifying` 注解提示 JPA 该操作是修改操作,注意还要配合`@Transactional`注解使用。\n\n```java\n@Repository\npublic interface UserRepository extends JpaRepository<User, Integer> {\n\n    @Modifying\n    @Transactional(rollbackFor = Exception.class)\n    void deleteByUserName(String userName);\n}\n```\n\n#### 8.9. 关联关系\n\n- `@OneToOne` 声明一对一关系\n- `@OneToMany` 声明一对多关系\n- `@ManyToOne` 声明多对一关系\n- `@MangToMang` 声明多对多关系\n\n更多关于 Spring Boot JPA 的文章请看我的这篇文章：[一文搞懂如何在 Spring Boot 正确中使用 JPA](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485689&idx=1&sn=061b32c2222869932be5631fb0bb5260&chksm=cea24732f9d5ce24a356fb3675170e7843addbfcc79ee267cfdb45c83fc7e90babf0f20d22e1&token=292197051&lang=zh_CN#rd) 。\n\n### 9. 事务 `@Transactional`\n\n在要开启事务的方法上使用`@Transactional`注解即可!\n\n```java\n@Transactional(rollbackFor = Exception.class)\npublic void save() {\n  ......\n}\n\n```\n\n我们知道 Exception 分为运行时异常 RuntimeException 和非运行时异常。在`@Transactional`注解中如果不配置`rollbackFor`属性,那么事务只会在遇到`RuntimeException`的时候才会回滚,加上`rollbackFor=Exception.class`,可以让事务在遇到非运行时异常时也回滚。\n\n`@Transactional` 注解一般可以作用在`类`或者`方法`上。\n\n- **作用于类**：当把`@Transactional` 注解放在类上时，表示所有该类的 public 方法都配置相同的事务属性信息。\n- **作用于方法**：当类配置了`@Transactional`，方法也配置了`@Transactional`，方法的事务会覆盖类的事务配置信息。\n\n更多关于 Spring 事务的内容请查看：\n\n1. [可能是最漂亮的 Spring 事务管理详解](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484943&idx=1&sn=46b9082af4ec223137df7d1c8303ca24&chksm=cea249c4f9d5c0d2b8212a17252cbfb74e5fbe5488b76d829827421c53332326d1ec360f5d63&token=1082669959&lang=zh_CN#rd)\n2. [一口气说出 6 种 @Transactional 注解失效场景](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486483&idx=2&sn=77be488e206186803531ea5d7164ec53&chksm=cea243d8f9d5cacecaa5c5daae4cde4c697b9b5b21f96dfc6cce428cfcb62b88b3970c26b9c2&token=816772476&lang=zh_CN#rd)\n\n### 10. json 数据处理\n\n#### 10.1. 过滤 json 数据\n\n**`@JsonIgnoreProperties` 作用在类上用于过滤掉特定字段不返回或者不解析。**\n\n```java\n//生成json时将userRoles属性过滤\n@JsonIgnoreProperties({"userRoles"})\npublic class User {\n\n    private String userName;\n    private String fullName;\n    private String password;\n    private List<UserRole> userRoles = new ArrayList<>();\n}\n```\n\n**`@JsonIgnore`一般用于类的属性上，作用和上面的`@JsonIgnoreProperties` 一样。**\n\n```java\n\npublic class User {\n\n    private String userName;\n    private String fullName;\n    private String password;\n   //生成json时将userRoles属性过滤\n    @JsonIgnore\n    private List<UserRole> userRoles = new ArrayList<>();\n}\n```\n\n#### 10.2. 格式化 json 数据\n\n`@JsonFormat`一般用来格式化 json 数据。\n\n比如：\n\n```java\n@JsonFormat(shape=JsonFormat.Shape.STRING, pattern="yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'", timezone="GMT")\nprivate Date date;\n```\n\n#### 10.3. 扁平化对象\n\n```java\n@Getter\n@Setter\n@ToString\npublic class Account {\n    private Location location;\n    private PersonInfo personInfo;\n\n  @Getter\n  @Setter\n  @ToString\n  public static class Location {\n     private String provinceName;\n     private String countyName;\n  }\n  @Getter\n  @Setter\n  @ToString\n  public static class PersonInfo {\n    private String userName;\n    private String fullName;\n  }\n}\n\n```\n\n未扁平化之前：\n\n```json\n{\n    "location": {\n        "provinceName":"湖北",\n        "countyName":"武汉"\n    },\n    "personInfo": {\n        "userName": "coder1234",\n        "fullName": "shaungkou"\n    }\n}\n```\n\n使用`@JsonUnwrapped` 扁平对象之后：\n\n```java\n@Getter\n@Setter\n@ToString\npublic class Account {\n    @JsonUnwrapped\n    private Location location;\n    @JsonUnwrapped\n    private PersonInfo personInfo;\n    ......\n}\n```\n\n```json\n{\n  "provinceName":"湖北",\n  "countyName":"武汉",\n  "userName": "coder1234",\n  "fullName": "shaungkou"\n}\n```\n\n### 11. 测试相关\n\n**`@ActiveProfiles`一般作用于测试类上， 用于声明生效的 Spring 配置文件。**\n\n```java\n@SpringBootTest(webEnvironment = RANDOM_PORT)\n@ActiveProfiles("test")\n@Slf4j\npublic abstract class TestBase {\n  ......\n}\n```\n\n**`@Test`声明一个方法为测试方法**\n\n**`@Transactional`被声明的测试方法的数据会回滚，避免污染测试数据。**\n\n**`@WithMockUser` Spring Security 提供的，用来模拟一个真实用户，并且可以赋予权限。**\n\n```java\n    @Test\n    @Transactional\n    @WithMockUser(username = "user-id-18163138155", authorities = "ROLE_TEACHER")\n    void should_import_student_success() throws Exception {\n        ......\n    }\n```\n\n_暂时总结到这里吧！虽然花了挺长时间才写完，不过可能还是会一些常用的注解的被漏掉，所以，我将文章也同步到了 Github 上去，Github 地址： 欢迎完善！_\n\n本文已经收录进我的 75K Star 的 Java 开源项目 JavaGuide：[https://github.com/Snailclimb/JavaGuide](https://github.com/Snailclimb/JavaGuide)。\n'},4989:function(n,e,t){"use strict";t.r(e),e["default"]='> 本文首更于[《从零开始手把手教你实现一个简单的RPC框架》](https://t.zsxq.com/iIUv7Mn)  。\n\n\x3c!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} --\x3e\n\n\x3c!-- code_chunk_output --\x3e\n\n- [1. 代理模式](#1-代理模式)\n- [2. 静态代理](#2-静态代理)\n- [3. 动态代理](#3-动态代理)\n  - [3.1. JDK 动态代理机制](#31-jdk-动态代理机制)\n    - [3.1.1. 介绍](#311-介绍)\n    - [3.1.2. JDK 动态代理类使用步骤](#312-jdk-动态代理类使用步骤)\n    - [3.1.3. 代码示例](#313-代码示例)\n  - [3.2. CGLIB 动态代理机制](#32-cglib-动态代理机制)\n    - [3.2.1. 介绍](#321-介绍)\n    - [3.2.2. CGLIB 动态代理类使用步骤](#322-cglib-动态代理类使用步骤)\n    - [3.2.3. 代码示例](#323-代码示例)\n  - [3.3. JDK 动态代理和 CGLIB 动态代理对比](#33-jdk-动态代理和-cglib-动态代理对比)\n- [4. 静态代理和动态代理的对比](#4-静态代理和动态代理的对比)\n- [5. 总结](#5-总结)\n\n\x3c!-- /code_chunk_output --\x3e\n\n\n## 1. 代理模式\n\n代理模式是一种比较好理解的设计模式。简单来说就是 **我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。**\n\n**代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。**\n\n举个例子：你找了小红来帮你问话，小红就可以看作是代理你的代理对象，代理的行为（方法）是问话。\n\n![image-20211030120240996](代理模式详解.assets/image-20211030120240996.png)\n\n\n\n\n\n代理模式有静态代理和动态代理两种实现方式，我们 先来看一下静态代理模式的实现。\n\n## 2. 静态代理\n\n**静态代理中，我们对目标对象的每个方法的增强都是手动完成的（_后面会具体演示代码_），非常不灵活（_比如接口一旦新增加方法，目标对象和代理对象都要进行修改_）且麻烦(_需要对每个目标类都单独写一个代理类_)。** 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。\n\n上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， **静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。**\n\n静态代理实现步骤:\n\n1. 定义一个接口及其实现类；\n2. 创建一个代理类同样实现这个接口\n3. 将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。\n\n下面通过代码展示！\n\n**1.定义发送短信的接口**\n\n```java\npublic interface SmsService {\n    String send(String message);\n}\n```\n\n**2.实现发送短信的接口**\n\n```java\npublic class SmsServiceImpl implements SmsService {\n    public String send(String message) {\n        System.out.println("send message:" + message);\n        return message;\n    }\n}\n```\n\n**3.创建代理类并同样实现发送短信的接口**\n\n```java\npublic class SmsProxy implements SmsService {\n\n    private final SmsService smsService;\n\n    public SmsProxy(SmsService smsService) {\n        this.smsService = smsService;\n    }\n\n    @Override\n    public String send(String message) {\n        //调用方法之前，我们可以添加自己的操作\n        System.out.println("before method send()");\n        smsService.send(message);\n        //调用方法之后，我们同样可以添加自己的操作\n        System.out.println("after method send()");\n        return null;\n    }\n}\n```\n\n**4.实际使用**\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        SmsService smsService = new SmsServiceImpl();\n        SmsProxy smsProxy = new SmsProxy(smsService);\n        smsProxy.send("java");\n    }\n}\n```\n\n运行上述代码之后，控制台打印出：\n\n```bash\nbefore method send()\nsend message:java\nafter method send()\n```\n\n可以输出结果看出，我们已经增加了 `SmsServiceImpl` 的`send()`方法。\n\n## 3. 动态代理\n\n相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( _CGLIB 动态代理机制_)。\n\n**从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。**\n\n说到动态代理，Spring AOP、RPC 框架应该是两个不得不提的，它们的实现都依赖了动态代理。\n\n**动态代理在我们日常开发中使用的相对较少，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。**\n\n就 Java 来说，动态代理的实现方式有很多种，比如 **JDK 动态代理**、**CGLIB 动态代理**等等。\n\n[guide-rpc-framework](https://github.com/Snailclimb/guide-rpc-framework) 使用的是 JDK 动态代理，我们先来看看 JDK 动态代理的使用。\n\n另外，虽然 [guide-rpc-framework](https://github.com/Snailclimb/guide-rpc-framework) 没有用到 **CGLIB 动态代理** ，我们这里还是简单介绍一下其使用以及和**JDK 动态代理**的对比。\n\n### 3.1. JDK 动态代理机制\n\n#### 3.1.1. 介绍\n\n**在 Java 动态代理机制中 `InvocationHandler` 接口和 `Proxy` 类是核心。**\n\n`Proxy` 类中使用频率最高的方法是：`newProxyInstance()` ，这个方法主要用来生成一个代理对象。\n\n```java\n    public static Object newProxyInstance(ClassLoader loader,\n                                          Class<?>[] interfaces,\n                                          InvocationHandler h)\n        throws IllegalArgumentException\n    {\n        ......\n    }\n```\n\n这个方法一共有 3 个参数：\n\n1. **loader** :类加载器，用于加载代理对象。\n2. **interfaces** : 被代理类实现的一些接口；\n3. **h** : 实现了 `InvocationHandler` 接口的对象；\n\n要实现动态代理的话，还必须需要实现`InvocationHandler` 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现`InvocationHandler` 接口类的 `invoke` 方法来调用。\n\n```java\npublic interface InvocationHandler {\n\n    /**\n     * 当你使用代理对象调用方法的时候实际会调用到这个方法\n     */\n    public Object invoke(Object proxy, Method method, Object[] args)\n        throws Throwable;\n}\n```\n\n`invoke()` 方法有下面三个参数：\n\n1. **proxy** :动态生成的代理类\n2. **method** : 与代理类对象调用的方法相对应\n3. **args** : 当前 method 方法的参数\n\n也就是说：**你通过`Proxy` 类的 `newProxyInstance()` 创建的代理对象在调用方法的时候，实际会调用到实现`InvocationHandler` 接口的类的 `invoke()`方法。** 你可以在 `invoke()` 方法中自定义处理逻辑，比如在方法执行前后做什么事情。\n\n#### 3.1.2. JDK 动态代理类使用步骤\n\n1. 定义一个接口及其实现类；\n2. 自定义 `InvocationHandler` 并重写`invoke`方法，在 `invoke` 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；\n3. 通过 `Proxy.newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)` 方法创建代理对象；\n\n#### 3.1.3. 代码示例\n\n这样说可能会有点空洞和难以理解，我上个例子，大家感受一下吧！\n\n**1.定义发送短信的接口**\n\n```java\npublic interface SmsService {\n    String send(String message);\n}\n```\n\n**2.实现发送短信的接口**\n\n```java\npublic class SmsServiceImpl implements SmsService {\n    public String send(String message) {\n        System.out.println("send message:" + message);\n        return message;\n    }\n}\n```\n\n**3.定义一个 JDK 动态代理类**\n\n```java\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\n/**\n * @author shuang.kou\n * @createTime 2020年05月11日 11:23:00\n */\npublic class DebugInvocationHandler implements InvocationHandler {\n    /**\n     * 代理类中的真实对象\n     */\n    private final Object target;\n\n    public DebugInvocationHandler(Object target) {\n        this.target = target;\n    }\n\n\n    public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {\n        //调用方法之前，我们可以添加自己的操作\n        System.out.println("before method " + method.getName());\n        Object result = method.invoke(target, args);\n        //调用方法之后，我们同样可以添加自己的操作\n        System.out.println("after method " + method.getName());\n        return result;\n    }\n}\n\n```\n\n`invoke()` 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 `invoke()` 方法，然后 `invoke()` 方法代替我们去调用了被代理对象的原生方法。\n\n**4.获取代理对象的工厂类**\n\n```java\npublic class JdkProxyFactory {\n    public static Object getProxy(Object target) {\n        return Proxy.newProxyInstance(\n                target.getClass().getClassLoader(), // 目标类的类加载\n                target.getClass().getInterfaces(),  // 代理需要实现的接口，可指定多个\n                new DebugInvocationHandler(target)   // 代理对象对应的自定义 InvocationHandler\n        );\n    }\n}\n```\n\n`getProxy()` ：主要通过`Proxy.newProxyInstance（）`方法获取某个类的代理对象\n\n**5.实际使用**\n\n```java\nSmsService smsService = (SmsService) JdkProxyFactory.getProxy(new SmsServiceImpl());\nsmsService.send("java");\n```\n\n运行上述代码之后，控制台打印出：\n\n```\nbefore method send\nsend message:java\nafter method send\n```\n\n### 3.2. CGLIB 动态代理机制\n\n#### 3.2.1. 介绍\n\n**JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。**\n\n**为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。**\n\n[CGLIB](https://github.com/cglib/cglib)(_Code Generation Library_)是一个基于[ASM](http://www.baeldung.com/java-asm)的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了[CGLIB](https://github.com/cglib/cglib)， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。\n\n**在 CGLIB 动态代理机制中 `MethodInterceptor` 接口和 `Enhancer` 类是核心。**\n\n你需要自定义 `MethodInterceptor` 并重写 `intercept` 方法，`intercept` 用于拦截增强被代理类的方法。\n\n```java\npublic interface MethodInterceptor\nextends Callback{\n    // 拦截被代理类中的方法\n    public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args,\n                               MethodProxy proxy) throws Throwable;\n}\n\n```\n\n1. **obj** :被代理的对象（需要增强的对象）\n2. **method** :被拦截的方法（需要增强的方法）\n3. **args** :方法入参\n4. **proxy** :用于调用原始方法\n\n你可以通过 `Enhancer`类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 `MethodInterceptor` 中的 `intercept` 方法。\n\n#### 3.2.2. CGLIB 动态代理类使用步骤\n\n1. 定义一个类；\n2. 自定义 `MethodInterceptor` 并重写 `intercept` 方法，`intercept` 用于拦截增强被代理类的方法，和 JDK 动态代理中的 `invoke` 方法类似；\n3. 通过 `Enhancer` 类的 `create()`创建代理类；\n\n#### 3.2.3. 代码示例\n\n不同于 JDK 动态代理不需要额外的依赖。[CGLIB](https://github.com/cglib/cglib)(_Code Generation Library_) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。\n\n```xml\n<dependency>\n  <groupId>cglib</groupId>\n  <artifactId>cglib</artifactId>\n  <version>3.3.0</version>\n</dependency>\n```\n\n**1.实现一个使用阿里云发送短信的类**\n\n```java\npackage github.javaguide.dynamicProxy.cglibDynamicProxy;\n\npublic class AliSmsService {\n    public String send(String message) {\n        System.out.println("send message:" + message);\n        return message;\n    }\n}\n```\n\n**2.自定义 `MethodInterceptor`（方法拦截器）**\n\n```java\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n\nimport java.lang.reflect.Method;\n\n/**\n * 自定义MethodInterceptor\n */\npublic class DebugMethodInterceptor implements MethodInterceptor {\n\n\n    /**\n     * @param o           代理对象（增强的对象）\n     * @param method      被拦截的方法（需要增强的方法）\n     * @param args        方法入参\n     * @param methodProxy 用于调用原始方法\n     */\n    @Override\n    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n        //调用方法之前，我们可以添加自己的操作\n        System.out.println("before method " + method.getName());\n        Object object = methodProxy.invokeSuper(o, args);\n        //调用方法之后，我们同样可以添加自己的操作\n        System.out.println("after method " + method.getName());\n        return object;\n    }\n\n}\n```\n\n**3.获取代理类**\n\n```java\nimport net.sf.cglib.proxy.Enhancer;\n\npublic class CglibProxyFactory {\n\n    public static Object getProxy(Class<?> clazz) {\n        // 创建动态代理增强类\n        Enhancer enhancer = new Enhancer();\n        // 设置类加载器\n        enhancer.setClassLoader(clazz.getClassLoader());\n        // 设置被代理类\n        enhancer.setSuperclass(clazz);\n        // 设置方法拦截器\n        enhancer.setCallback(new DebugMethodInterceptor());\n        // 创建代理类\n        return enhancer.create();\n    }\n}\n```\n\n**4.实际使用**\n\n```java\nAliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);\naliSmsService.send("java");\n```\n\n运行上述代码之后，控制台打印出：\n\n```bash\nbefore method send\nsend message:java\nafter method send\n```\n\n### 3.3. JDK 动态代理和 CGLIB 动态代理对比\n\n1. **JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。** 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。\n2. 就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。\n\n## 4. 静态代理和动态代理的对比\n\n1. **灵活性** ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！\n2. **JVM 层面** ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。\n\n## 5. 总结\n\n这篇文章中主要介绍了代理模式的两种实现：静态代理以及动态代理。涵盖了静态代理和动态代理实战、静态代理和动态代理的区别、JDK 动态代理和 Cglib 动态代理区别等内容。\n\n文中涉及到的所有源码，你可以在这里找到：[https://github.com/Snailclimb/guide-rpc-framework-learning/tree/master/src/main/java/github/javaguide/proxy](https://github.com/Snailclimb/guide-rpc-framework-learning/tree/master/src/main/java/github/javaguide/proxy) 。\n'},"49d6":function(n,e,t){"use strict";t.r(e),e["default"]="# javaweb基础学习路径\r\n\r\n项目代码： [项目代码](源码下载:mm_exam.zip)\r\n\r\nJAVAWEB 基础的 学习路线图\r\n\r\nJAVAWEB核心的内容为：\r\n\r\n01-Tomcat和HTTP协议\r\n02-Servlet\r\n03-请求&响应 Request&Response-授课\r\n04-Cookie&Session&JSP\r\n05-EL表达式&过滤器&监听器\r\n\r\n\r\n\r\n![image-20211125215229761](0.javaweb基础学习路径.assets/image-20211125215229761.png)"},"4a88":function(n,e,t){var r={"./8 张图读懂大型网站技术架构.md":"a105","./Java定时任务大揭秘.md":"af14","./authority-certification/JWT优缺点分析以及常见问题解决方案.md":"e602","./authority-certification/SSO单点登录看这一篇就够了.md":"89e5","./authority-certification/basis-of-authority-certification.md":"2687","./coding-way/RESTfulAPI简明教程.md":"f6cb","./distributed-system/BASE理论.md":"c623","./distributed-system/CAP理论.md":"79d1","./distributed-system/api-gateway/api网关入门.md":"4bcb","./distributed-system/message-queue/Kafka常见面试题总结.md":"1ac0","./distributed-system/message-queue/RabbitMQ入门看这一篇就够了.md":"82b5","./distributed-system/message-queue/RocketMQ-Questions.md":"59f7","./distributed-system/message-queue/RocketMQ.md":"d594","./distributed-system/message-queue/message-queue.md":"c097","./distributed-system/rpc/Dubbo.md":"1052","./distributed-system/rpc/服务之间的调用为啥不直接用HTTP而用RPC.md":"bb51","./distributed-system/zookeeper/zookeeper-in-action.md":"ec20","./distributed-system/zookeeper/zookeeper-intro.md":"a591","./distributed-system/zookeeper/zookeeper-plus.md":"11a2","./distributed/分布式ID.md":"e92a","./limit-request.md":"f9f1","./naming.md":"aaf8","./关于大型网站系统架构你不得不懂的10个问题.md":"2a10","./如何设计一个高可用系统要考虑哪些地方.md":"fc69","./读写分离&分库分表.md":"1729"};function a(n){var e=i(n);return t(e)}function i(n){if(!t.o(r,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return r[n]}a.keys=function(){return Object.keys(r)},a.resolve=i,n.exports=a,a.id="4a88"},"4bcb":function(n,e,t){"use strict";t.r(e),e["default"]='## 何为网关？为什么要网关？\n\n![微服务-网关](api网关入门.assets/微服务-网关.png)\n\n微服务背景下，一个系统被拆分为多个服务，但是像安全认证，流量控制，日志，监控等功能是每个服务都需要的，没有网关的话，我们就需要在每个服务中单独实现，这使得我们做了很多重复的事情并且没有一个全局的视图来统一管理这些功能。\n\n综上：**一般情况下，网关都会提供请求转发、安全认证（身份/权限认证）、流量控制、负载均衡、容灾、日志、监控这些功能。**\n\n上面介绍了这么多功能，实际上，网关主要做了一件事情：**请求过滤** 。\n\n## 有哪些常见的网关系统？\n\n### Netflix Zuul\n\nZuul 是 Netflix 开发的一款提供动态路由、监控、弹性、安全的网关服务。\n\nZuul 主要通过过滤器（类似于 AOP）来过滤请求，从而实现网关必备的各种功能。\n\n![Zuul架构](api网关入门.assets/865991e34f69f8cb345b4aff918e946e.png)\n\n我们可以自定义过滤器来处理请求，并且，Zuul 生态本身就有很多现成的过滤器供我们使用。就比如限流可以直接用国外朋友写的 [spring-cloud-zuul-ratelimit](https://github.com/marcosbarbero/spring-cloud-zuul-ratelimit) (这里只是举例说明，一般是配合 hystrix 来做限流)：\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-zuul</artifactId>\n</dependency>\n<dependency>\n    <groupId>com.marcosbarbero.cloud</groupId>\n    <artifactId>spring-cloud-zuul-ratelimit</artifactId>\n    <version>2.2.0.RELEASE</version>\n</dependency>\n```\n\nZuul 1.x 基于同步 IO，性能较差。Zuul 2.x 基于 Netty 实现了异步 IO，性能得到了大幅改进。\n\n- Github 地址 ： https://github.com/Netflix/zuul\n- 官方 Wiki ： https://github.com/Netflix/zuul/wiki\n\n### Spring Cloud Gateway\n\nSpringCloud Gateway 属于 Spring Cloud 生态系统中的网关，其诞生的目标是为了替代老牌网关 **Zuul **。准确点来说，应该是 Zuul 1.x。SpringCloud Gateway 起步要比 Zuul 2.x 更早。\n\n为了提升网关的性能，SpringCloud Gateway 基于 Spring WebFlux 。Spring WebFlux 使用 Reactor 库来实现响应式编程模型，底层基于 Netty 实现异步 IO。\n\nSpring Cloud Gateway 的目标，不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，和限流。\n\nSpring Cloud Gateway 和 Zuul 2.x 的差别不大，也是通过过滤器来处理请求。不过，目前更加推荐使用 Spring Cloud Gateway 而非 Zuul，Spring Cloud 生态对其支持更加友好。\n\n- Github 地址 ： https://github.com/spring-cloud/spring-cloud-gateway\n- 官网 ： https://spring.io/projects/spring-cloud-gateway\n\n### Kong\n\nKong 是一款基于 [OpenResty](https://github.com/openresty/) 的高性能、云原生、可扩展的网关系统。\n\n> OpenResty 是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。\n\nKong 提供了插件机制来扩展其功能。比如、在服务上启用 Zipkin 插件\n\n```shell\n$ curl -X POST http://kong:8001/services/{service}/plugins \\\n    --data "name=zipkin"  \\\n    --data "config.http_endpoint=http://your.zipkin.collector:9411/api/v2/spans" \\\n    --data "config.sample_ratio=0.001"\n```\n\n- Github 地址： https://github.com/Kong/kong\n- 官网地址 ： https://konghq.com/kong\n\n### APISIX\n\nAPISIX 是一款基于 Nginx 和 etcd 的高性能、云原生、可扩展的网关系统。\n\n> *etcd*是使用 Go 语言开发的一个开源的、高可用的分布式 key-value 存储系统，使用 Raft 协议做分布式共识。\n\n与传统 API 网关相比，APISIX 具有动态路由和插件热加载，特别适合微服务系统下的 API 管理。并且，APISIX 与 SkyWalking（分布式链路追踪系统）、Zipkin（分布式链路追踪系统）、Prometheus（监控系统） 等 DevOps 生态工具对接都十分方便。\n\n![apisix架构图](api网关入门.assets/727732fad2e943bdd2c502b83ddb1b89.png)\n\n作为 NGINX 和 Kong 的替代项目，APISIX 目前已经是 Apache 顶级开源项目，并且是最快毕业的国产开源项目。国内目前已经有很多知名企业（比如金山、有赞、爱奇艺、腾讯、贝壳）使用 APISIX 处理核心的业务流量。\n\n根据官网介绍：“APISIX 已经生产可用，功能、性能、架构全面优于 Kong”。\n\n- Github 地址 ：https://github.com/apache/apisix\n- 官网地址： https://apisix.apache.org/zh/\n\n相关阅读：\n\n- [有了 NGINX 和 Kong，为什么还需要 Apache APISIX](https://www.apiseven.com/zh/blog/why-we-need-Apache-APISIX)\n- [APISIX 技术博客](https://www.apiseven.com/zh/blog)\n- [APISIX 用户案例](https://www.apiseven.com/zh/usercases)\n\n### Shenyu\n\nShenyu 是一款基于 WebFlux 的可扩展、高性能、响应式网关，Apache 顶级开源项目。\n\n![Shenyu架构](api网关入门.assets/1104eb413cba468cba4dce119165e84e.png)\n\nShenyu 通过插件扩展功能，插件是 ShenYu 的灵魂，并且插件也是可扩展和热插拔的。不同的插件实现不同的功能。Shenyu 自带了诸如限流、熔断、转发 、重写、重定向、和路由监控等插件。\n\n- Github 地址： https://github.com/apache/incubator-shenyu\n- 官网地址 ： https://shenyu.apache.org/\n'},"4ca9":function(n,e,t){"use strict";t.r(e),e["default"]='\x3c!--\r\n * @Date           : 2021-04-12 16:03:42\r\n * @FilePath       : /jinnian-space/src/pages/java/module/jdbc/md/JDBC-02-授课笔记.md\r\n * @Description    : \r\n--\x3e\r\n# JDBC-02-授课笔记\r\n\r\n### 一、数据库连接池\r\n\r\n#### 1.数据库连接池的概念\r\n\r\n- 数据库连接背景\r\n  - 数据库连接是一种关键的、有限的、昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。数据库连接池正是针对这个问题提出来的。\r\n- 数据库连接池\r\n  - 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个。这项技术能明显提高对数据库操作的性能。\r\n- 数据库连接池原理\r\n\r\n![01](./JDBC-02-授课笔记.assets/01.png)\r\n\r\n#### 2.自定义连接池\r\n\r\n- java.sql.DataSource接口：数据源(数据库连接池)。java官方提供的数据库连接池规范(接口)\r\n  - 获取数据库连接对象：Connection getConnection();\r\n- 自定义连接池\r\n\r\n```java\r\n/*\r\n\t自定义连接池类\r\n*/\r\npublic class MyDataSource implements DataSource{\r\n    //定义集合容器，用于保存多个数据库连接对象\r\n    private static List<Connection> pool = Collections.synchronizedList(new ArrayList<Connection>());\r\n\r\n    //静态代码块，生成10个数据库连接保存到集合中\r\n    static {\r\n        for (int i = 0; i < 10; i++) {\r\n            Connection con = JDBCUtils.getConnection();\r\n            pool.add(con);\r\n        }\r\n    }\r\n\r\n    //返回连接池的大小\r\n    public int getSize() {\r\n        return pool.size();\r\n    }\r\n\r\n    //从池中返回一个数据库连接\r\n    @Override\r\n    public Connection getConnection() {\r\n        if(pool.size() > 0) {\r\n            //从池中获取数据库连接\r\n            return pool.remove(0);\r\n        }else {\r\n            throw new RuntimeException("连接数量已用尽");\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public Connection getConnection(String username, String password) throws SQLException {\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public <T> T unwrap(Class<T> iface) throws SQLException {\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public boolean isWrapperFor(Class<?> iface) throws SQLException {\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    public PrintWriter getLogWriter() throws SQLException {\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public void setLogWriter(PrintWriter out) throws SQLException {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void setLoginTimeout(int seconds) throws SQLException {\r\n\r\n    }\r\n\r\n    @Override\r\n    public int getLoginTimeout() throws SQLException {\r\n        return 0;\r\n    }\r\n\r\n    @Override\r\n    public Logger getParentLogger() throws SQLFeatureNotSupportedException {\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n#### 3.自定义连接池测试\r\n\r\n```java\r\npublic class MyDataSourceTest {\r\n    public static void main(String[] args) throws Exception{\r\n        //创建数据库连接池对象\r\n        MyDataSource dataSource = new MyDataSource();\r\n\r\n        System.out.println("使用之前连接池数量：" + dataSource.getSize());\r\n        \r\n        //获取数据库连接对象\r\n        Connection con = dataSource.getConnection();\r\n        System.out.println(con.getClass());// JDBC4Connection\r\n\r\n        //查询学生表全部信息\r\n        String sql = "SELECT * FROM student";\r\n        PreparedStatement pst = con.prepareStatement(sql);\r\n        ResultSet rs = pst.executeQuery();\r\n\r\n        while(rs.next()) {\r\n            System.out.println(rs.getInt("sid") + "\\t" + rs.getString("name") + "\\t" + rs.getInt("age") + "\\t" + rs.getDate("birthday"));\r\n        }\r\n        \r\n        //释放资源\r\n        rs.close();\r\n        pst.close();\r\n\t\t//目前的连接对象close方法，是直接关闭连接，而不是将连接归还池中\r\n        con.close();\r\n\r\n        System.out.println("使用之后连接池数量：" + dataSource.getSize());\r\n    }\r\n}\r\n```\r\n\r\n#### 4.归还连接\r\n\r\n- 继承(无法解决)\r\n\r\n  - 通过打印连接对象，发现DriverManager获取的连接实现类是JDBC4Connection。\r\n  - 自定义一个类，继承JDBC4Connection这个类，重写close()方法。\r\n\r\n  ```java\r\n  /*\r\n      自定义Connection类\r\n   */\r\n  public class MyConnection1 extends JDBC4Connection {\r\n      //声明连接对象和连接池集合对象\r\n      private Connection con;\r\n      private List<Connection> pool;\r\n  \r\n      //通过构造方法给成员变量赋值\r\n      public MyConnection1(String hostToConnectTo, int portToConnectTo, Properties info, String databaseToConnectTo, String url,Connection con,List<Connection> pool) throws SQLException {\r\n          super(hostToConnectTo, portToConnectTo, info, databaseToConnectTo, url);\r\n          this.con = con;\r\n          this.pool = pool;\r\n      }\r\n  \r\n      //重写close()方法，将连接归还给池中\r\n      @Override\r\n      public void close() throws SQLException {\r\n          pool.add(con);\r\n      }\r\n  }\r\n  ```\r\n\r\n  - 但是这种方式行不通，通过查看JDBC工具类获取连接的方法我们发现：我们虽然自定义了一个子类，完成了归还连接的操作。但是DriverManager获取的还是JDBC4Connection这个对象，并不是我们的子类对象。而我们又不能整体去修改驱动包中类的功能！\r\n\r\n  ```java\r\n  //将之前的连接对象换成自定义的子类对象\r\n  private static MyConnection1 con;\r\n  \r\n  //4.获取数据库连接的方法\r\n  public static Connection getConnection() {\r\n      try {\r\n          //等效于：MyConnection1 con = new JDBC4Connection();  语法错误！\r\n          con = DriverManager.getConnection(url,username,password);\r\n      } catch (SQLException e) {\r\n          e.printStackTrace();\r\n      }\r\n  \r\n      return con;\r\n  }\r\n  ```\r\n\r\n- 装饰设计模式\r\n\r\n  - 自定义连接类\r\n\r\n  ```java\r\n  /*\r\n      自定义Connection类。通过装饰设计模式，实现和mysql驱动包中的Connection实现类相同的功能！\r\n      实现步骤：\r\n          1.定义一个类，实现Connection接口\r\n          2.定义Connection连接对象和连接池容器对象的变量\r\n          3.提供有参构造方法，接收连接对象和连接池对象，对变量赋值\r\n          4.在close()方法中，完成连接的归还\r\n          5.剩余方法，只需要调用mysql驱动包的连接对象完成即可\r\n   */\r\n  public class MyConnection2 implements Connection {\r\n  \r\n      //2.定义Connection连接对象和连接池容器对象的变量\r\n      private Connection con;\r\n      private List<Connection> pool;\r\n  \r\n      //3.提供有参构造方法，接收连接对象和连接池对象，对变量赋值\r\n      public MyConnection2(Connection con,List<Connection> pool) {\r\n          this.con = con;\r\n          this.pool = pool;\r\n      }\r\n  \r\n      //4.在close()方法中，完成连接的归还\r\n      @Override\r\n      public void close() throws SQLException {\r\n          pool.add(con);\r\n      }\r\n  \r\n  \r\n      @Override\r\n      public Statement createStatement() throws SQLException {\r\n          return con.createStatement();\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql) throws SQLException {\r\n          return con.prepareStatement(sql);\r\n      }\r\n  \r\n      @Override\r\n      public CallableStatement prepareCall(String sql) throws SQLException {\r\n          return con.prepareCall(sql);\r\n      }\r\n  \r\n      @Override\r\n      public String nativeSQL(String sql) throws SQLException {\r\n          return con.nativeSQL(sql);\r\n      }\r\n  \r\n      @Override\r\n      public void setAutoCommit(boolean autoCommit) throws SQLException {\r\n          con.setAutoCommit(autoCommit);\r\n      }\r\n  \r\n      @Override\r\n      public boolean getAutoCommit() throws SQLException {\r\n          return con.getAutoCommit();\r\n      }\r\n  \r\n      @Override\r\n      public void commit() throws SQLException {\r\n          con.commit();\r\n      }\r\n  \r\n      @Override\r\n      public void rollback() throws SQLException {\r\n          con.rollback();\r\n      }\r\n  \r\n      @Override\r\n      public boolean isClosed() throws SQLException {\r\n          return con.isClosed();\r\n      }\r\n  \r\n      @Override\r\n      public DatabaseMetaData getMetaData() throws SQLException {\r\n          return con.getMetaData();\r\n      }\r\n  \r\n      @Override\r\n      public void setReadOnly(boolean readOnly) throws SQLException {\r\n          con.setReadOnly(readOnly);\r\n      }\r\n  \r\n      @Override\r\n      public boolean isReadOnly() throws SQLException {\r\n          return con.isReadOnly();\r\n      }\r\n  \r\n      @Override\r\n      public void setCatalog(String catalog) throws SQLException {\r\n          con.setCatalog(catalog);\r\n      }\r\n  \r\n      @Override\r\n      public String getCatalog() throws SQLException {\r\n          return con.getCatalog();\r\n      }\r\n  \r\n      @Override\r\n      public void setTransactionIsolation(int level) throws SQLException {\r\n          con.setTransactionIsolation(level);\r\n      }\r\n  \r\n      @Override\r\n      public int getTransactionIsolation() throws SQLException {\r\n          return con.getTransactionIsolation();\r\n      }\r\n  \r\n      @Override\r\n      public SQLWarning getWarnings() throws SQLException {\r\n          return con.getWarnings();\r\n      }\r\n  \r\n      @Override\r\n      public void clearWarnings() throws SQLException {\r\n          con.clearWarnings();\r\n      }\r\n  \r\n      @Override\r\n      public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {\r\n          return con.createStatement(resultSetType,resultSetConcurrency);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {\r\n          return con.prepareStatement(sql,resultSetType,resultSetConcurrency);\r\n      }\r\n  \r\n      @Override\r\n      public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {\r\n          return con.prepareCall(sql,resultSetType,resultSetConcurrency);\r\n      }\r\n  \r\n      @Override\r\n      public Map<String, Class<?>> getTypeMap() throws SQLException {\r\n          return con.getTypeMap();\r\n      }\r\n  \r\n      @Override\r\n      public void setTypeMap(Map<String, Class<?>> map) throws SQLException {\r\n          con.setTypeMap(map);\r\n      }\r\n  \r\n      @Override\r\n      public void setHoldability(int holdability) throws SQLException {\r\n          con.setHoldability(holdability);\r\n      }\r\n  \r\n      @Override\r\n      public int getHoldability() throws SQLException {\r\n          return con.getHoldability();\r\n      }\r\n  \r\n      @Override\r\n      public Savepoint setSavepoint() throws SQLException {\r\n          return con.setSavepoint();\r\n      }\r\n  \r\n      @Override\r\n      public Savepoint setSavepoint(String name) throws SQLException {\r\n          return con.setSavepoint(name);\r\n      }\r\n  \r\n      @Override\r\n      public void rollback(Savepoint savepoint) throws SQLException {\r\n          con.rollback(savepoint);\r\n      }\r\n  \r\n      @Override\r\n      public void releaseSavepoint(Savepoint savepoint) throws SQLException {\r\n          con.releaseSavepoint(savepoint);\r\n      }\r\n  \r\n      @Override\r\n      public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {\r\n          return con.createStatement(resultSetType,resultSetConcurrency,resultSetHoldability);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {\r\n          return con.prepareStatement(sql,resultSetType,resultSetConcurrency,resultSetHoldability);\r\n      }\r\n  \r\n      @Override\r\n      public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {\r\n          return con.prepareCall(sql,resultSetType,resultSetConcurrency,resultSetHoldability);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {\r\n          return con.prepareStatement(sql,autoGeneratedKeys);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {\r\n          return con.prepareStatement(sql,columnIndexes);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {\r\n          return con.prepareStatement(sql,columnNames);\r\n      }\r\n  \r\n      @Override\r\n      public Clob createClob() throws SQLException {\r\n          return con.createClob();\r\n      }\r\n  \r\n      @Override\r\n      public Blob createBlob() throws SQLException {\r\n          return con.createBlob();\r\n      }\r\n  \r\n      @Override\r\n      public NClob createNClob() throws SQLException {\r\n          return con.createNClob();\r\n      }\r\n  \r\n      @Override\r\n      public SQLXML createSQLXML() throws SQLException {\r\n          return con.createSQLXML();\r\n      }\r\n  \r\n      @Override\r\n      public boolean isValid(int timeout) throws SQLException {\r\n          return con.isValid(timeout);\r\n      }\r\n  \r\n      @Override\r\n      public void setClientInfo(String name, String value) throws SQLClientInfoException {\r\n          con.setClientInfo(name,value);\r\n      }\r\n  \r\n      @Override\r\n      public void setClientInfo(Properties properties) throws SQLClientInfoException {\r\n          con.setClientInfo(properties);\r\n      }\r\n  \r\n      @Override\r\n      public String getClientInfo(String name) throws SQLException {\r\n          return con.getClientInfo(name);\r\n      }\r\n  \r\n      @Override\r\n      public Properties getClientInfo() throws SQLException {\r\n          return con.getClientInfo();\r\n      }\r\n  \r\n      @Override\r\n      public Array createArrayOf(String typeName, Object[] elements) throws SQLException {\r\n          return con.createArrayOf(typeName,elements);\r\n      }\r\n  \r\n      @Override\r\n      public Struct createStruct(String typeName, Object[] attributes) throws SQLException {\r\n          return con.createStruct(typeName,attributes);\r\n      }\r\n  \r\n      @Override\r\n      public void setSchema(String schema) throws SQLException {\r\n          con.setSchema(schema);\r\n      }\r\n  \r\n      @Override\r\n      public String getSchema() throws SQLException {\r\n          return con.getSchema();\r\n      }\r\n  \r\n      @Override\r\n      public void abort(Executor executor) throws SQLException {\r\n          con.abort(executor);\r\n      }\r\n  \r\n      @Override\r\n      public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {\r\n          con.setNetworkTimeout(executor,milliseconds);\r\n      }\r\n  \r\n      @Override\r\n      public int getNetworkTimeout() throws SQLException {\r\n          return con.getNetworkTimeout();\r\n      }\r\n  \r\n      @Override\r\n      public <T> T unwrap(Class<T> iface) throws SQLException {\r\n          return con.unwrap(iface);\r\n      }\r\n  \r\n      @Override\r\n      public boolean isWrapperFor(Class<?> iface) throws SQLException {\r\n          return con.isWrapperFor(iface);\r\n      }\r\n  }\r\n  ```\r\n\r\n  - 自定义连接池类\r\n\r\n  ```java\r\n  public class MyDataSource implements DataSource{\r\n      //定义集合容器，用于保存多个数据库连接对象\r\n      private static List<Connection> pool = Collections.synchronizedList(new ArrayList<Connection>());\r\n  \r\n      //静态代码块，生成10个数据库连接保存到集合中\r\n      static {\r\n          for (int i = 0; i < 10; i++) {\r\n              Connection con = JDBCUtils.getConnection();\r\n              pool.add(con);\r\n          }\r\n      }\r\n  \r\n      //返回连接池的大小\r\n      public int getSize() {\r\n          return pool.size();\r\n      }\r\n  \r\n      //从池中返回一个数据库连接\r\n      @Override\r\n      public Connection getConnection() {\r\n          if(pool.size() > 0) {\r\n              //从池中获取数据库连接\r\n              Connection con = pool.remove(0);\r\n              //通过自定义连接对象进行包装\r\n              MyConnection2 mycon = new MyConnection2(con,pool);\r\n              //返回包装后的连接对象\r\n              return mycon;\r\n          }else {\r\n              throw new RuntimeException("连接数量已用尽");\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n- 适配器设计模式\r\n\r\n  - 通过之前MyConnection2连接类我们发现，有很多个需要实现的方法。这个时候我们就可以使用适配器设计模式了。提供一个适配器类，实现Connection接口，将所有功能进行实现(除了close方法)。自定义连接类只需要继承这个适配器类，重写需要改进的close()方法即可！\r\n  - 适配器类\r\n\r\n  ```java\r\n  /*\r\n      适配器抽象类。实现Connection接口。\r\n      实现所有的方法，调用mysql驱动包中Connection连接对象的方法\r\n   */\r\n  public abstract class MyAdapter implements Connection {\r\n  \r\n      // 定义数据库连接对象的变量\r\n      private Connection con;\r\n  \r\n      // 通过构造方法赋值\r\n      public MyAdapter(Connection con) {\r\n          this.con = con;\r\n      }\r\n  \r\n      // 所有的方法，均调用mysql的连接对象实现\r\n      @Override\r\n      public Statement createStatement() throws SQLException {\r\n          return con.createStatement();\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql) throws SQLException {\r\n          return con.prepareStatement(sql);\r\n      }\r\n  \r\n      @Override\r\n      public CallableStatement prepareCall(String sql) throws SQLException {\r\n          return con.prepareCall(sql);\r\n      }\r\n  \r\n      @Override\r\n      public String nativeSQL(String sql) throws SQLException {\r\n          return con.nativeSQL(sql);\r\n      }\r\n  \r\n      @Override\r\n      public void setAutoCommit(boolean autoCommit) throws SQLException {\r\n          con.setAutoCommit(autoCommit);\r\n      }\r\n  \r\n      @Override\r\n      public boolean getAutoCommit() throws SQLException {\r\n          return con.getAutoCommit();\r\n      }\r\n  \r\n      @Override\r\n      public void commit() throws SQLException {\r\n          con.commit();\r\n      }\r\n  \r\n      @Override\r\n      public void rollback() throws SQLException {\r\n          con.rollback();\r\n      }\r\n  \r\n      @Override\r\n      public boolean isClosed() throws SQLException {\r\n          return con.isClosed();\r\n      }\r\n  \r\n      @Override\r\n      public DatabaseMetaData getMetaData() throws SQLException {\r\n          return con.getMetaData();\r\n      }\r\n  \r\n      @Override\r\n      public void setReadOnly(boolean readOnly) throws SQLException {\r\n          con.setReadOnly(readOnly);\r\n      }\r\n  \r\n      @Override\r\n      public boolean isReadOnly() throws SQLException {\r\n          return con.isReadOnly();\r\n      }\r\n  \r\n      @Override\r\n      public void setCatalog(String catalog) throws SQLException {\r\n          con.setCatalog(catalog);\r\n      }\r\n  \r\n      @Override\r\n      public String getCatalog() throws SQLException {\r\n          return con.getCatalog();\r\n      }\r\n  \r\n      @Override\r\n      public void setTransactionIsolation(int level) throws SQLException {\r\n          con.setTransactionIsolation(level);\r\n      }\r\n  \r\n      @Override\r\n      public int getTransactionIsolation() throws SQLException {\r\n          return con.getTransactionIsolation();\r\n      }\r\n  \r\n      @Override\r\n      public SQLWarning getWarnings() throws SQLException {\r\n          return con.getWarnings();\r\n      }\r\n  \r\n      @Override\r\n      public void clearWarnings() throws SQLException {\r\n          con.clearWarnings();\r\n      }\r\n  \r\n      @Override\r\n      public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {\r\n          return con.createStatement(resultSetType,resultSetConcurrency);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {\r\n          return con.prepareStatement(sql,resultSetType,resultSetConcurrency);\r\n      }\r\n  \r\n      @Override\r\n      public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {\r\n          return con.prepareCall(sql,resultSetType,resultSetConcurrency);\r\n      }\r\n  \r\n      @Override\r\n      public Map<String, Class<?>> getTypeMap() throws SQLException {\r\n          return con.getTypeMap();\r\n      }\r\n  \r\n      @Override\r\n      public void setTypeMap(Map<String, Class<?>> map) throws SQLException {\r\n          con.setTypeMap(map);\r\n      }\r\n  \r\n      @Override\r\n      public void setHoldability(int holdability) throws SQLException {\r\n          con.setHoldability(holdability);\r\n      }\r\n  \r\n      @Override\r\n      public int getHoldability() throws SQLException {\r\n          return con.getHoldability();\r\n      }\r\n  \r\n      @Override\r\n      public Savepoint setSavepoint() throws SQLException {\r\n          return con.setSavepoint();\r\n      }\r\n  \r\n      @Override\r\n      public Savepoint setSavepoint(String name) throws SQLException {\r\n          return con.setSavepoint(name);\r\n      }\r\n  \r\n      @Override\r\n      public void rollback(Savepoint savepoint) throws SQLException {\r\n          con.rollback(savepoint);\r\n      }\r\n  \r\n      @Override\r\n      public void releaseSavepoint(Savepoint savepoint) throws SQLException {\r\n          con.releaseSavepoint(savepoint);\r\n      }\r\n  \r\n      @Override\r\n      public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {\r\n          return con.createStatement(resultSetType,resultSetConcurrency,resultSetHoldability);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {\r\n          return con.prepareStatement(sql,resultSetType,resultSetConcurrency,resultSetHoldability);\r\n      }\r\n  \r\n      @Override\r\n      public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {\r\n          return con.prepareCall(sql,resultSetType,resultSetConcurrency,resultSetHoldability);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {\r\n          return con.prepareStatement(sql,autoGeneratedKeys);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {\r\n          return con.prepareStatement(sql,columnIndexes);\r\n      }\r\n  \r\n      @Override\r\n      public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {\r\n          return con.prepareStatement(sql,columnNames);\r\n      }\r\n  \r\n      @Override\r\n      public Clob createClob() throws SQLException {\r\n          return con.createClob();\r\n      }\r\n  \r\n      @Override\r\n      public Blob createBlob() throws SQLException {\r\n          return con.createBlob();\r\n      }\r\n  \r\n      @Override\r\n      public NClob createNClob() throws SQLException {\r\n          return con.createNClob();\r\n      }\r\n  \r\n      @Override\r\n      public SQLXML createSQLXML() throws SQLException {\r\n          return con.createSQLXML();\r\n      }\r\n  \r\n      @Override\r\n      public boolean isValid(int timeout) throws SQLException {\r\n          return con.isValid(timeout);\r\n      }\r\n  \r\n      @Override\r\n      public void setClientInfo(String name, String value) throws SQLClientInfoException {\r\n          con.setClientInfo(name,value);\r\n      }\r\n  \r\n      @Override\r\n      public void setClientInfo(Properties properties) throws SQLClientInfoException {\r\n          con.setClientInfo(properties);\r\n      }\r\n  \r\n      @Override\r\n      public String getClientInfo(String name) throws SQLException {\r\n          return con.getClientInfo(name);\r\n      }\r\n  \r\n      @Override\r\n      public Properties getClientInfo() throws SQLException {\r\n          return con.getClientInfo();\r\n      }\r\n  \r\n      @Override\r\n      public Array createArrayOf(String typeName, Object[] elements) throws SQLException {\r\n          return con.createArrayOf(typeName,elements);\r\n      }\r\n  \r\n      @Override\r\n      public Struct createStruct(String typeName, Object[] attributes) throws SQLException {\r\n          return con.createStruct(typeName,attributes);\r\n      }\r\n  \r\n      @Override\r\n      public void setSchema(String schema) throws SQLException {\r\n          con.setSchema(schema);\r\n      }\r\n  \r\n      @Override\r\n      public String getSchema() throws SQLException {\r\n          return con.getSchema();\r\n      }\r\n  \r\n      @Override\r\n      public void abort(Executor executor) throws SQLException {\r\n          con.abort(executor);\r\n      }\r\n  \r\n      @Override\r\n      public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {\r\n          con.setNetworkTimeout(executor,milliseconds);\r\n      }\r\n  \r\n      @Override\r\n      public int getNetworkTimeout() throws SQLException {\r\n          return con.getNetworkTimeout();\r\n      }\r\n  \r\n      @Override\r\n      public <T> T unwrap(Class<T> iface) throws SQLException {\r\n          return con.unwrap(iface);\r\n      }\r\n  \r\n      @Override\r\n      public boolean isWrapperFor(Class<?> iface) throws SQLException {\r\n          return con.isWrapperFor(iface);\r\n      }\r\n  }\r\n  ```\r\n\r\n  - 自定义连接类\r\n\r\n  ```java\r\n  /*\r\n      自定义Connection连接类。通过适配器设计模式。完成close()方法的重写\r\n          1.定义一个类，继承适配器父类\r\n          2.定义Connection连接对象和连接池容器对象的变量\r\n          3.提供有参构造方法，接收连接对象和连接池对象，对变量赋值\r\n          4.在close()方法中，完成连接的归还\r\n   */\r\n  public class MyConnection3 extends MyAdapter {\r\n      //2.定义Connection连接对象和连接池容器对象的变量\r\n      private Connection con;\r\n      private List<Connection> pool;\r\n  \r\n      //3.提供有参构造方法，接收连接对象和连接池对象，对变量赋值\r\n      public MyConnection3(Connection con,List<Connection> pool) {\r\n          super(con);    // 将接收的数据库连接对象给适配器父类传递\r\n          this.con = con;\r\n          this.pool = pool;\r\n      }\r\n  \r\n      //4.在close()方法中，完成连接的归还\r\n      @Override\r\n      public void close() throws SQLException {\r\n          pool.add(con);\r\n      }\r\n  }\r\n  ```\r\n\r\n  - 自定义连接池类\r\n\r\n  ```java\r\n  public class MyDataSource implements DataSource{\r\n      //定义集合容器，用于保存多个数据库连接对象\r\n      private static List<Connection> pool = Collections.synchronizedList(new ArrayList<Connection>());\r\n  \r\n      //静态代码块，生成10个数据库连接保存到集合中\r\n      static {\r\n          for (int i = 0; i < 10; i++) {\r\n              Connection con = JDBCUtils.getConnection();\r\n              pool.add(con);\r\n          }\r\n      }\r\n  \r\n      //返回连接池的大小\r\n      public int getSize() {\r\n          return pool.size();\r\n      }\r\n  \r\n      //从池中返回一个数据库连接\r\n      @Override\r\n      public Connection getConnection() {\r\n          if(pool.size() > 0) {\r\n              //从池中获取数据库连接\r\n              Connection con = pool.remove(0);\r\n  \r\n              //通过自定义连接对象进行包装\r\n              //MyConnection2 mycon = new MyConnection2(con,pool);\r\n              MyConnection3 mycon = new MyConnection3(con,pool);\r\n  \r\n              //返回包装后的连接对象\r\n              return mycon;\r\n          }else {\r\n              throw new RuntimeException("连接数量已用尽");\r\n          }\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n- 动态代理\r\n\r\n  - 经过我们适配器模式的改进，自定义连接类中的方法已经很简洁了。剩余所有的方法已经抽取到了适配器类中。但是适配器这个类还是我们自己编写的，也比较麻烦！所以可以使用动态代理的方式来改进。\r\n  - 自定义数据库连接池类\r\n\r\n  ```java\r\n  public class MyDataSource implements DataSource{\r\n      //定义集合容器，用于保存多个数据库连接对象\r\n      private static List<Connection> pool = Collections.synchronizedList(new ArrayList<Connection>());\r\n  \r\n      //静态代码块，生成10个数据库连接保存到集合中\r\n      static {\r\n          for (int i = 0; i < 10; i++) {\r\n              Connection con = JDBCUtils.getConnection();\r\n              pool.add(con);\r\n          }\r\n      }\r\n  \r\n      //返回连接池的大小\r\n      public int getSize() {\r\n          return pool.size();\r\n      }\r\n  \r\n      //动态代理方式\r\n      @Override\r\n      public Connection getConnection() {\r\n          if(pool.size() > 0) {\r\n              //从池中获取数据库连接\r\n              Connection con = pool.remove(0);\r\n  \r\n              Connection proxyCon = (Connection)Proxy.newProxyInstance(con.getClass().getClassLoader(), new Class[]{Connection.class}, new InvocationHandler() {\r\n                  /*\r\n                      执行Connection实现类所有方法都会经过invoke\r\n                      如果是close方法，则将连接还回池中\r\n                      如果不是，直接执行实现类的原有方法\r\n                   */\r\n                  @Override\r\n                  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n                      if(method.getName().equals("close")) {\r\n                          pool.add(con);\r\n                          return null;\r\n                      }else {\r\n                          return method.invoke(con,args);\r\n                      }\r\n                  }\r\n              });\r\n  \r\n              return proxyCon;\r\n          }else {\r\n              throw new RuntimeException("连接数量已用尽");\r\n          }\r\n      }\r\n  \r\n  \r\n      //从池中返回一个数据库连接\r\n      /*@Override\r\n      public Connection getConnection() {\r\n          if(pool.size() > 0) {\r\n              //从池中获取数据库连接\r\n              Connection con = pool.remove(0);\r\n  \r\n              //通过自定义连接对象进行包装\r\n              //MyConnection2 mycon = new MyConnection2(con,pool);\r\n              MyConnection3 mycon = new MyConnection3(con,pool);\r\n  \r\n              //返回包装后的连接对象\r\n              return mycon;\r\n          }else {\r\n              throw new RuntimeException("连接数量已用尽");\r\n          }\r\n      }*/\r\n  }\r\n  \r\n  ```\r\n\r\n#### 5.开源连接池的使用\r\n\r\n- C3P0\r\n\r\n  - 基本使用\r\n\r\n  ```java\r\n  /*\r\n      使用C3P0连接池\r\n      1.导入jar包\r\n      2.导入配置文件到src目录下\r\n      3.创建c3p0连接池对象\r\n      4.获取数据库连接进行使用\r\n   */\r\n  public class C3P0Demo1 {\r\n      public static void main(String[] args) throws Exception{\r\n          //创建c3p0连接池对象\r\n          DataSource dataSource = new ComboPooledDataSource();\r\n  \r\n          //获取数据库连接进行使用\r\n          Connection con = dataSource.getConnection();\r\n  \r\n          //查询全部学生信息\r\n          String sql = "SELECT * FROM student";\r\n          PreparedStatement pst = con.prepareStatement(sql);\r\n          ResultSet rs = pst.executeQuery();\r\n  \r\n          while(rs.next()) {\r\n              System.out.println(rs.getInt("sid") + "\\t" + rs.getString("name") + "\\t" + rs.getInt("age") + "\\t" + rs.getDate("birthday"));\r\n          }\r\n  \r\n          //释放资源\r\n          rs.close();\r\n          pst.close();\r\n          con.close();    // 将连接对象归还池中\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n  - 配置演示\r\n\r\n  ```java\r\n  public class C3P0Demo2 {\r\n      public static void main(String[] args) throws Exception{\r\n          //创建c3p0连接池对象\r\n          DataSource dataSource = new ComboPooledDataSource();\r\n  \r\n          //获取数据库连接进行使用\r\n          for(int i = 1; i <= 11; i++) {\r\n              Connection con = dataSource.getConnection();\r\n              System.out.println(i + ":" + con);\r\n              if(i == 5) {\r\n                  con.close();\r\n              }\r\n          }\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n- Druid\r\n\r\n  - 基本使用\r\n\r\n  ```java\r\n  /*\r\n      Druid连接池\r\n      1.导入jar包\r\n      2.编写配置文件，放在src目录下\r\n      3.通过Properties集合加载配置文件\r\n      4.通过Druid连接池工厂类获取数据库连接池对象\r\n      5.获取数据库连接，进行使用\r\n   */\r\n  public class DruidDemo1 {\r\n      public static void main(String[] args) throws Exception{\r\n          //通过Properties集合加载配置文件\r\n          InputStream is = DruidDemo1.class.getClassLoader().getResourceAsStream("druid.properties");\r\n          Properties prop = new Properties();\r\n          prop.load(is);\r\n  \r\n          //通过Druid连接池工厂类获取数据库连接池对象\r\n          DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);\r\n  \r\n          //获取数据库连接，进行使用\r\n          Connection con = dataSource.getConnection();\r\n  \r\n          //查询全部学生信息\r\n          String sql = "SELECT * FROM student";\r\n          PreparedStatement pst = con.prepareStatement(sql);\r\n          ResultSet rs = pst.executeQuery();\r\n  \r\n          while(rs.next()) {\r\n              System.out.println(rs.getInt("sid") + "\\t" + rs.getString("name") + "\\t" + rs.getInt("age") + "\\t" + rs.getDate("birthday"));\r\n          }\r\n  \r\n          //释放资源\r\n          rs.close();\r\n          pst.close();\r\n          con.close();    // 将连接对象归还池中\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n  - 抽取工具类\r\n\r\n  ```java\r\n  /*\r\n      数据库连接池工具类\r\n   */\r\n  public class DataSourceUtils {\r\n      //1.私有构造方法\r\n      private DataSourceUtils(){}\r\n  \r\n      //2.定义DataSource数据源变量\r\n      private static DataSource dataSource;\r\n  \r\n      //3.提供静态代码块，完成配置文件的加载和获取连接池对象\r\n      static {\r\n          try{\r\n              //加载配置文件\r\n              InputStream is = DruidDemo1.class.getClassLoader().getResourceAsStream("druid.properties");\r\n              Properties prop = new Properties();\r\n              prop.load(is);\r\n  \r\n              //获取数据库连接池对象\r\n              dataSource = DruidDataSourceFactory.createDataSource(prop);\r\n  \r\n          } catch(Exception e) {\r\n              e.printStackTrace();\r\n          }\r\n      }\r\n  \r\n      //4.提供获取数据库连接的方法\r\n      public static Connection getConnection() {\r\n          Connection con = null;\r\n          try {\r\n              con = dataSource.getConnection();\r\n          } catch (SQLException e) {\r\n              e.printStackTrace();\r\n          }\r\n          return con;\r\n      }\r\n  \r\n      //5.提供获取数据库连接池的方法\r\n      public static DataSource getDataSource() {\r\n          return dataSource;\r\n      }\r\n  \r\n      //6.提供释放资源的方法\r\n      public static void close(Connection con, Statement stat, ResultSet rs) {\r\n          if(con != null) {\r\n              try {\r\n                  con.close();\r\n              } catch (SQLException e) {\r\n                  e.printStackTrace();\r\n              }\r\n          }\r\n  \r\n          if(stat != null) {\r\n              try {\r\n                  stat.close();\r\n              } catch (SQLException e) {\r\n                  e.printStackTrace();\r\n              }\r\n          }\r\n  \r\n          if(rs != null) {\r\n              try {\r\n                  rs.close();\r\n              } catch (SQLException e) {\r\n                  e.printStackTrace();\r\n              }\r\n          }\r\n      }\r\n  \r\n      public static void close(Connection con, Statement stat) {\r\n          close(con,stat,null);\r\n      }\r\n  \r\n  }\r\n  \r\n  ```\r\n\r\n### 二、JDBC框架(JDBCTemplate)\r\n\r\n#### 1.分析前一天案例中的重复代码\r\n\r\n- dao层的重复代码\r\n  - 定义必要的信息、获取数据库的连接、释放资源都是重复的代码！\r\n  - 而我们最终的核心功能仅仅只是执行一条sql语句而已啊！\r\n  - 所以我们可以抽取出一个JDBC模板类，来封装一些方法(update、query)，专门帮我们执行增删改查的sql语句！\r\n  - 将之前那些重复的操作，都抽取到模板类中的方法里。就能大大简化我们的使用步骤！\r\n\r\n#### 2.自定义JDBC框架\r\n\r\n##### 2.1数据库的源信息\r\n\r\n- DataBaseMetaData(了解)：数据库的源信息\r\n  - java.sql.DataBaseMetaData：封装了整个数据库的综合信息\r\n  - 例如：\r\n    - String getDatabaseProductName()：获取数据库产品的名称\r\n    - int getDatabaseProductVersion()：获取数据库产品的版本号\r\n- ParameterMetaData：参数的源信息\r\n  - java.sql.ParameterMetaData：封装的是预编译执行者对象中每个参数的类型和属性\r\n  - 这个对象可以通过预编译执行者对象中的getParameterMetaData()方法来获取\r\n  - 核心功能：\r\n    - int getParameterCount()：获取sql语句中参数的个数\r\n- ResultSetMetaData：结果集的源信息\r\n  - java.sql.ResultSetMetaData：封装的是结果集对象中列的类型和属性\r\n  - 这个对象可以通过结果集对象中的getMetaData()方法来获取\r\n  - 核心功能：\r\n    - int getColumnCount()：获取列的总数\r\n    - String getColumnName(int i)：获取列名\r\n\r\n##### 2.2JDBCTemplate类增删改功能的编写\r\n\r\n```java\r\npublic class JDBCTemplate {\r\n    private DataSource dataSource;\r\n    private Connection con;\r\n    private PreparedStatement pst;\r\n    private ResultSet rs;\r\n\r\n    public JDBCTemplate(DataSource dataSource) {\r\n        this.dataSource = dataSource;\r\n    }\r\n\r\n    //专用于执行增删改sql语句的方法\r\n    public int update(String sql,Object...objs) {\r\n        int result = 0;\r\n\r\n        try{\r\n            con = dataSource.getConnection();\r\n            pst = con.prepareStatement(sql);\r\n\r\n            //获取sql语句中的参数源信息\r\n            ParameterMetaData pData = pst.getParameterMetaData();\r\n            //获取sql语句中参数的个数\r\n            int parameterCount = pData.getParameterCount();\r\n\r\n            //判断参数个数是否一致\r\n            if(parameterCount != objs.length) {\r\n                throw new RuntimeException("参数个数不匹配");\r\n            }\r\n\r\n            //为sql语句中的?占位符赋值\r\n            for (int i = 0; i < objs.length; i++) {\r\n                pst.setObject(i+1,objs[i]);\r\n            }\r\n\r\n            //执行sql语句\r\n            result = pst.executeUpdate();\r\n\r\n        } catch(Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //释放资源\r\n            DataSourceUtils.close(con,pst);\r\n        }\r\n\r\n        //返回结果\r\n        return result;\r\n    }\r\n}\r\n\r\n```\r\n\r\n##### 2.3JDBCTemplate类查询功能的编写\r\n\r\n- 实体类\r\n\r\n```java\r\n/*\r\n    学生实体类\r\n */\r\npublic class Student {\r\n    private Integer sid;\r\n    private String name;\r\n    private Integer age;\r\n    private Date birthday;\r\n\r\n    public Student() {\r\n    }\r\n\r\n    public Student(Integer sid, String name, Integer age, Date birthday) {\r\n        this.sid = sid;\r\n        this.name = name;\r\n        this.age = age;\r\n        this.birthday = birthday;\r\n    }\r\n\r\n    public Integer getSid() {\r\n        return sid;\r\n    }\r\n\r\n    public void setSid(Integer sid) {\r\n        this.sid = sid;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public Integer getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(Integer age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public Date getBirthday() {\r\n        return birthday;\r\n    }\r\n\r\n    public void setBirthday(Date birthday) {\r\n        this.birthday = birthday;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return "Student{" +\r\n                "sid=" + sid +\r\n                ", name=\'" + name + \'\\\'\' +\r\n                ", age=" + age +\r\n                ", birthday=" + birthday +\r\n                \'}\';\r\n    }\r\n}\r\n\r\n```\r\n\r\n- ResultSetHandler接口\r\n\r\n```java\r\n/*\r\n    用于处理结果集的接口\r\n */\r\npublic interface ResultSetHandler<T> {\r\n    //处理结果集的抽象方法。\r\n    <T> T handler(ResultSet rs);\r\n}\r\n\r\n```\r\n\r\n- BeanHandler实现类\r\n\r\n```java\r\n/*\r\n    实现类1：用于完成将查询出来的一条记录，封装到Student对象中\r\n */\r\npublic class BeanHandler<T> implements ResultSetHandler<T> {\r\n    //1.声明对象类型变量\r\n    private Class<T> beanClass;\r\n\r\n    //2.有参构造对变量赋值\r\n    public BeanHandler(Class<T> beanClass) {\r\n        this.beanClass = beanClass;\r\n    }\r\n\r\n    /*\r\n        将ResultSet结果集中的数据封装到beanClass类型对象中\r\n     */\r\n    @Override\r\n    public T handler(ResultSet rs) {\r\n        //3.声明对象\r\n        T bean = null;\r\n        try{\r\n            //4.创建传递参数的对象\r\n            bean = beanClass.newInstance();\r\n\r\n            //5.判断是否有结果集\r\n            if(rs.next()) {\r\n                //6.得到所有的列名\r\n                //6.1先得到结果集的源信息\r\n                ResultSetMetaData rsmd = rs.getMetaData();\r\n                //6.2还要得到有多少列\r\n                int columnCount = rsmd.getColumnCount();\r\n                //6.3遍历列数\r\n                for(int i = 1; i <= columnCount; i++) {\r\n                    //6.4得到每列的列名\r\n                    String columnName = rsmd.getColumnName(i);\r\n                    //6.5通过列名获取数据\r\n                    Object columnValue = rs.getObject(columnName);\r\n\r\n                    //6.6列名其实就是对象中成员变量的名称。于是就可以使用列名得到对象中属性的描述器(get和set方法)\r\n                    PropertyDescriptor pd = new PropertyDescriptor(columnName.toLowerCase(),beanClass);\r\n                    //6.7获取set方法\r\n                    Method writeMethod = pd.getWriteMethod();\r\n                    //6.8执行set方法，给成员变量赋值\r\n                    writeMethod.invoke(bean,columnValue);\r\n                }\r\n            }\r\n\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        //7.将对象返回\r\n        return bean;\r\n    }\r\n}\r\n\r\n```\r\n\r\n- BeanListHandler实现类\r\n\r\n```java\r\n/*\r\n    实现类2：用于将结果集封装到集合中\r\n */\r\npublic class BeanListHandler<T> implements ResultSetHandler<T> {\r\n\r\n    //1.声明对象变量\r\n    private Class<T> beanClass;\r\n\r\n    //2.有参构造为变量赋值\r\n    public BeanListHandler(Class<T> beanClass) {\r\n        this.beanClass = beanClass;\r\n    }\r\n\r\n    @Override\r\n    public List<T> handler(ResultSet rs) {\r\n        //3.创建集合对象\r\n        List<T> list = new ArrayList<>();\r\n\r\n        try{\r\n            //4.遍历结果集对象\r\n            while(rs.next()) {\r\n                //5.创建传递参数的对象\r\n                T bean = beanClass.newInstance();\r\n                //6.得到所有的列名\r\n                //6.1先得到结果集的源信息\r\n                ResultSetMetaData rsmd = rs.getMetaData();\r\n                //6.2还要得到有多少列\r\n                int columnCount = rsmd.getColumnCount();\r\n                //6.3遍历列数\r\n                for(int i = 1; i <= columnCount; i++) {\r\n                    //6.4得到每列的列名\r\n                    String columnName = rsmd.getColumnName(i);\r\n                    //6.5通过列名获取数据\r\n                    Object columnValue = rs.getObject(columnName);\r\n\r\n                    //6.6列名其实就是对象中成员变量的名称。于是就可以使用列名得到对象中属性的描述器(get和set方法)\r\n                    PropertyDescriptor pd = new PropertyDescriptor(columnName.toLowerCase(),beanClass);\r\n                    //6.7获取set方法\r\n                    Method writeMethod = pd.getWriteMethod();\r\n                    //6.8执行set方法，给成员变量赋值\r\n                    writeMethod.invoke(bean,columnValue);\r\n                }\r\n                //7.将对象保存到集合中\r\n                list.add(bean);\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n        //8.返回结果\r\n        return list;\r\n    }\r\n}\r\n\r\n```\r\n\r\n- ScalarHandler实现类\r\n\r\n```java\r\n/*\r\n    实现类3：用于返回一个聚合函数的查询结果\r\n */\r\npublic class ScalarHandler<T> implements ResultSetHandler<T> {\r\n    @Override\r\n    public Long handler(ResultSet rs) {\r\n        //1.声明一个变量\r\n        Long value = null;\r\n        try{\r\n            //2.判断是否有结果\r\n            if(rs.next()) {\r\n                //3.获取结果集的源信息\r\n                ResultSetMetaData rsmd = rs.getMetaData();\r\n                //4.获取第一列的列名\r\n                String columnName = rsmd.getColumnName(1);\r\n                //5.根据列名获取值\r\n                value = rs.getLong(columnName);\r\n            }\r\n        } catch(Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n        //6.将结果返回\r\n        return value;\r\n    }\r\n}\r\n\r\n```\r\n\r\n- JDBCTemplate类\r\n\r\n```java\r\npublic class JDBCTemplate {\r\n    private DataSource dataSource;\r\n    private Connection con;\r\n    private PreparedStatement pst;\r\n    private ResultSet rs;\r\n\r\n    public JDBCTemplate(DataSource dataSource) {\r\n        this.dataSource = dataSource;\r\n    }\r\n    \r\n    /*\r\n    \t专用于执行聚合函数sql语句的方法\r\n    */\r\n    public Long queryForScalar(String sql, ResultSetHandler<Long> rsh, Object...objs) {\r\n        Long result = null;\r\n        try{\r\n            con = dataSource.getConnection();\r\n            pst = con.prepareStatement(sql);\r\n\r\n            //获取sql语句中的参数源信息\r\n            ParameterMetaData pData = pst.getParameterMetaData();\r\n            int parameterCount = pData.getParameterCount();\r\n\r\n            //判断参数个数是否一致\r\n            if(parameterCount != objs.length) {\r\n                throw new RuntimeException("参数个数不匹配");\r\n            }\r\n\r\n            //为sql语句中的?占位符赋值\r\n            for (int i = 0; i < objs.length; i++) {\r\n                pst.setObject(i+1,objs[i]);\r\n            }\r\n\r\n            //执行sql语句\r\n            rs = pst.executeQuery();\r\n\r\n            //通过ScalarHandler方式对结果进行处理\r\n            result = rsh.handler(rs);\r\n\r\n        } catch(Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //释放资源\r\n            DataSourceUtils.close(con,pst,rs);\r\n        }\r\n\r\n        //将结果返回\r\n        return result;\r\n    }\r\n\r\n    /*\r\n    \t专用于查询所有记录sql语句的方法\r\n    */\r\n    public <T> List<T> queryForList(String sql, ResultSetHandler<T> rsh, Object...objs) {\r\n        List<T> list = new ArrayList<>();\r\n        try{\r\n            con = dataSource.getConnection();\r\n            pst = con.prepareStatement(sql);\r\n\r\n            //获取sql语句中的参数源信息\r\n            ParameterMetaData pData = pst.getParameterMetaData();\r\n            int parameterCount = pData.getParameterCount();\r\n\r\n            //判断参数个数是否一致\r\n            if(parameterCount != objs.length) {\r\n                throw new RuntimeException("参数个数不匹配");\r\n            }\r\n\r\n            //为sql语句中的?占位符赋值\r\n            for (int i = 0; i < objs.length; i++) {\r\n                pst.setObject(i+1,objs[i]);\r\n            }\r\n\r\n            //执行sql语句\r\n            rs = pst.executeQuery();\r\n\r\n            //通过BeanListHandler方式对结果进行处理\r\n            list = rsh.handler(rs);\r\n\r\n        } catch(Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //释放资源\r\n            DataSourceUtils.close(con,pst,rs);\r\n        }\r\n\r\n        //将结果返回\r\n        return list;\r\n    }\r\n\r\n\r\n    /*\r\n    \t专用于执行查询一条记录sql语句的方法\r\n    */\r\n    public <T> T queryForObject(String sql, ResultSetHandler<T> rsh, Object...objs) {\r\n        T obj = null;\r\n        try{\r\n            con = dataSource.getConnection();\r\n            pst = con.prepareStatement(sql);\r\n\r\n            //获取sql语句中的参数源信息\r\n            ParameterMetaData pData = pst.getParameterMetaData();\r\n            int parameterCount = pData.getParameterCount();\r\n\r\n            //判断参数个数是否一致\r\n            if(parameterCount != objs.length) {\r\n                throw new RuntimeException("参数个数不匹配");\r\n            }\r\n\r\n            //为sql语句中的?占位符赋值\r\n            for (int i = 0; i < objs.length; i++) {\r\n                pst.setObject(i+1,objs[i]);\r\n            }\r\n\r\n            //执行sql语句\r\n            rs = pst.executeQuery();\r\n\r\n            //通过BeanHandler方式对结果进行处理\r\n            obj = rsh.handler(rs);\r\n\r\n        } catch(Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //释放资源\r\n            DataSourceUtils.close(con,pst,rs);\r\n        }\r\n\r\n        //将结果返回\r\n        return obj;\r\n    }\r\n}\r\n\r\n```\r\n\r\n##### 2.4测试自定义JDBC框架的使用\r\n\r\n```java\r\npublic class JDBCTemplateTest {\r\n    //创建JDBCTemplate对象\r\n    JDBCTemplate template = new JDBCTemplate(DataSourceUtils.getDataSource());\r\n\r\n    @Test\r\n    public void selectScalar() {\r\n        //查询student表的记录条数\r\n        String sql = "SELECT COUNT(*) FROM student";\r\n        Long count = template.queryForScalar(sql, new ScalarHandler<Long>());\r\n        System.out.println(count);\r\n    }\r\n\r\n    @Test\r\n    public void selectAll() {\r\n        //查询所有学生信息\r\n        String sql = "SELECT * FROM student";\r\n        List<Student> list = template.queryForList(sql, new BeanListHandler<Student>(Student.class));\r\n        for(Student stu : list) {\r\n            System.out.println(stu);\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void selectOne() {\r\n        //查询张三这条记录\r\n        String sql = "SELECT * FROM student WHERE sid=?";\r\n        //通过BeanHandler将结果封装成一个Student对象\r\n        Student stu = template.queryForObject(sql, new BeanHandler<Student>(Student.class), 1);\r\n        System.out.println(stu);\r\n    }\r\n\r\n    @Test\r\n    public void insert() {\r\n        //新增周七记录\r\n        String sql = "INSERT INTO student VALUES (?,?,?,?)";\r\n        Object[] params = {5,"周七",27,"2007-07-07"};\r\n        int result = template.update(sql, params);\r\n        System.out.println(result);\r\n    }\r\n\r\n    @Test\r\n    public void delete() {\r\n        //删除周七这条记录\r\n        String sql = "DELETE FROM student WHERE sid=?";\r\n        int result = template.update(sql, 5);\r\n        System.out.println(result);\r\n    }\r\n\r\n    @Test\r\n    public void update() {\r\n        //修改张三的年龄为33\r\n        String sql = "UPDATE student SET age=? WHERE name=?";\r\n        Object[] params = {33,"张三"};\r\n        int result = template.update(sql,params);\r\n        System.out.println(result);\r\n    }\r\n}\r\n\r\n```\r\n\r\n'},"4f93":function(n,e,t){"use strict";t.r(e),e["default"]="\n\n## Spring相关教程/资料\n\n### 官网相关\n\n- [Spring官网](https://spring.io/)、[Spring系列主要项目](https://spring.io/projects)、[Spring官网指南](https://spring.io/guides)、[官方文档](https://spring.io/docs/reference)\n- [spring-framework-reference](https://docs.spring.io/spring/docs/5.0.14.RELEASE/spring-framework-reference/index.html)\n- [Spring Framework 4.3.17.RELEASE API](https://docs.spring.io/spring/docs/4.3.17.RELEASE/javadoc-api/)\n\n## 系统学习教程\n\n### 文档\n\n-  [极客学院Spring Wiki](http://wiki.jikexueyuan.com/project/spring/transaction-management.html)\n- [Spring W3Cschool教程 ](https://www.w3cschool.cn/wkspring/f6pk1ic8.html)\n\n### 视频\n\n- [网易云课堂——58集精通java教程Spring框架开发](https://study.163.com/course/courseMain.htm?courseId=1004475015#/courseDetail?tab=1&35)\n-  [慕课网相关视频](https://www.imooc.com/)\n\n- **黑马视频和尚硅谷视频（非常推荐）：** 微信公众号：“**JavaGuide**”后台回复关键字 “**1**” 免费领取。\n\n\n## 面试必备知识点\n\n### SpringAOP,IOC实现原理\n\nAOP实现原理、动态代理和静态代理、Spring IOC的初始化过程、IOC原理、自己实现怎么实现一个IOC容器？这些东西都是经常会被问到的。\n\n推荐阅读：\n\n- [自己动手实现的 Spring IOC 和 AOP - 上篇](http://www.coolblog.xyz/2018/01/18/自己动手实现的-Spring-IOC-和-AOP-上篇/)\n\n- [自己动手实现的 Spring IOC 和 AOP - 下篇](http://www.coolblog.xyz/2018/01/18/自己动手实现的-Spring-IOC-和-AOP-下篇/)\n\n### AOP\n\nAOP思想的实现一般都是基于 **代理模式** ，在JAVA中一般采用JDK动态代理模式，但是我们都知道，**JDK动态代理模式只能代理接口而不能代理类**。因此，Spring AOP 会这样子来进行切换，因为Spring AOP 同时支持 CGLIB、ASPECTJ、JDK动态代理。\n\n- 如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；\n- 如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类——不过这个选择过程对开发者完全透明、开发者也无需关心。\n\n推荐阅读：\n\n- [静态代理、JDK动态代理、CGLIB动态代理讲解](https://www.cnblogs.com/puyangsky/p/6218925.html) ：我们知道AOP思想的实现一般都是基于 **代理模式** ，所以在看下面的文章之前建议先了解一下静态代理以及JDK动态代理、CGLIB动态代理的实现方式。\n- [Spring AOP 入门](https://juejin.im/post/5aa7818af265da23844040c6) ：带你入门的一篇文章。这篇文章主要介绍了AOP中的基本概念：5种类型的通知（Before，After，After-returning，After-throwing，Around）；Spring中对AOP的支持：AOP思想的实现一般都是基于代理模式，在Java中一般采用JDK动态代理模式，Spring AOP 同时支持 CGLIB、ASPECTJ、JDK动态代理，\n- [Spring AOP 基于AspectJ注解如何实现AOP](https://juejin.im/post/5a55af9e518825734d14813f) ： **AspectJ是一个AOP框架，它能够对java代码进行AOP编译（一般在编译期进行），让java代码具有AspectJ的AOP功能（当然需要特殊的编译器）**，可以这样说AspectJ是目前实现AOP框架中最成熟，功能最丰富的语言，更幸运的是，AspectJ与java程序完全兼容，几乎是无缝关联，因此对于有java编程基础的工程师，上手和使用都非常容易。Spring注意到AspectJ在AOP的实现方式上依赖于特殊编译器(ajc编译器)，因此Spring很机智回避了这点，转向采用动态代理技术的实现原理来构建Spring AOP的内部机制（动态织入），这是与AspectJ（静态织入）最根本的区别。**Spring 只是使用了与 AspectJ 5 一样的注解，但仍然没有使用 AspectJ 的编译器，底层依是动态代理技术的实现，因此并不依赖于 AspectJ 的编译器**。 Spring AOP虽然是使用了那一套注解，其实实现AOP的底层是使用了动态代理(JDK或者CGLib)来动态植入。至于AspectJ的静态植入，不是本文重点，所以只提一提。\n- [探秘Spring AOP（慕课网视频，很不错）](https://www.imooc.com/learn/869):慕课网视频，讲解的很不错，详细且深入\n- [spring源码剖析（六）AOP实现原理剖析](https://blog.csdn.net/fighterandknight/article/details/51209822) :通过源码分析Spring AOP的原理\n\n### IOC\n\n- [[Spring框架]Spring IOC的原理及详解。](https://www.cnblogs.com/wang-meng/p/5597490.html)\n- [Spring IOC核心源码学习](https://yikun.github.io/2015/05/29/Spring-IOC核心源码学习/) :比较简短，推荐阅读。\n- [Spring IOC 容器源码分析](https://javadoop.com/post/spring-ioc) :强烈推荐，内容详尽，而且便于阅读。\n- [Bean初始化过程](https://www.qzztf.com/2019/08/21/Bean%E5%88%9D%E5%A7%8B%E5%8C%96/#Bean-%E5%AE%9E%E4%BE%8B%E5%8C%96)\n\n\n## Spring事务管理\n\n- [可能是最漂亮的Spring事务管理详解](https://juejin.im/post/5b00c52ef265da0b95276091)\n- [Spring编程式和声明式事务实例讲解](https://juejin.im/post/5b010f27518825426539ba38)\n\n### Spring单例与线程安全\n\n- [Spring框架中的单例模式（源码解读）](https://www.cnblogs.com/chengxuyuanzhilu/p/6404991.html):单例模式是一种常用的软件设计模式。通过单例模式可以保证系统中一个类只有一个实例。spring依赖注入时，使用了 多重判断加锁 的单例模式。\n\n### Spring源码阅读\n\n阅读源码不仅可以加深我们对Spring设计思想的理解，提高自己的编码水平，还可以让自己在面试中如鱼得水。下面的是Github上的一个开源的Spring源码阅读，大家有时间可以看一下，当然你如果有时间也可以自己慢慢研究源码。\n\n - [spring-core](https://github.com/seaswalker/Spring/blob/master/note/Spring.md)\n- [spring-aop](https://github.com/seaswalker/Spring/blob/master/note/spring-aop.md)\n- [spring-context](https://github.com/seaswalker/Spring/blob/master/note/spring-context.md)\n- [spring-task](https://github.com/seaswalker/Spring/blob/master/note/spring-task.md)\n- [spring-transaction](https://github.com/seaswalker/Spring/blob/master/note/spring-transaction.md)\n- [spring-mvc](https://github.com/seaswalker/Spring/blob/master/note/spring-mvc.md)\n- [guava-cache](https://github.com/seaswalker/Spring/blob/master/note/guava-cache.md)\n"},"51bf":function(n,e,t){"use strict";t.r(e),e["default"]='# web综合案例\r\n\r\n## 学习目标\r\n\r\n目标1：能够说出数据库设计的三种常用范式\r\n\r\n目标2：能够使用PD工具进行表结构设计\r\n\r\n目标3：完成学科模块的业务开发\r\n\r\n目标4：完成目录模块的业务开发\r\n\r\n目标5：完成题目模块的业务开发\r\n\r\n目标6：能够说出文件上传前台的三要素\r\n\r\n目标7：能够完成题目选项模块的业务开发\r\n\r\n## 1. 数据库设计\r\n\r\n### 1.1 数据库设计范式\r\n\r\n**什么叫数据库设计范式？**\r\n\r\n**范式：规范的形式，应用于各个行业的标准化**\r\n\r\n数据库设计中有5种范式，但是常用的分别是：第一范式（1NF）,第二范式（2NF），第三范式（3NF）\r\n\r\n**第一范式（1NF）**：针对数据表中的列，列要具备原子性，不可再拆分\r\n\r\n![](web综合案例_day02.assets/1.png)\r\n\r\n如果数据表这样设计，籍贯这一列不具备原子性，因为数据可再次拆分，不拆分的话无法获取用户的州郡信息或县市信息，拆分之后如下：\r\n\r\n![](web综合案例_day02.assets/2.png)\r\n\r\n**第二范式（2NF）**：数据表要具备唯一主键，不存在多主键，使得每一行数据具有唯一性\r\n\r\n![](web综合案例_day02.assets/3.png)\r\n\r\n在如图所示的表中：没有哪一个字段（列）能唯一确定一条数据，要想唯一确定一条数据，需要两个或更多的字段，这就违反了第二范式，数据表不具备唯一主键而存在多主键。\r\n\r\n那如何来解决呢？在表中加一个唯一主键列：id\r\n\r\n**第三范式（3NF）**：不依赖非主键的字段及更深层次的依赖，使得每个字段都独立依赖于主键字段（独立性）\r\n\r\n >什么叫依赖：依赖，就是在一个表中，其中某个字段的值B可以由另一个字段值A来决定，那我们称字段B依赖字段A或字段A决定字段B\r\n\r\n![](web综合案例_day02.assets/4.png)\r\n\r\n在如图所示的表结构中：合计列=单价 X 数量，当然这中间还需要依赖商品编号来查询商品单价\r\n\r\n总而言之，合计这一列，依赖了表中的非主键字段，以及非主键字段的更深层次的依赖，这表明合计这一列的数据是冗余的，因为我们完全可以通过计算的方式得到合计数据，而不需要在表中来存储。\r\n\r\n\r\n\r\n**反三范式**：允许少量的数据冗余，提高查询的速度\r\n\r\n![](web综合案例_day02.assets/5.png)\r\n\r\n### 1.2 数据库设计工具\r\n\r\nPowerDesigner：简称PD，是一款功能强大的建模软件，提供强大的元数据管理功能，可以帮助用户构建关键信息的全方位视图，创建多种类型的模型，包括概念数据模型，物理数据模型，面向对象模型等等，同时集成了数据管理，BI，数据集成和数据整合多种功能。\r\n\r\n## 2. 学科模块快速开发\r\n\r\n下面我们进行学科模块的快速开发：\r\n\r\n（1）创建学科实体：com.itheima.domain.store.Course\r\n\r\n```java\r\npublic class Course {\r\n    private String id;\r\n    private String name;\r\n    private String remark;\r\n    private String state;\r\n    private Date createTime;\r\n\r\n    // getter/setter略\r\n}\r\n```\r\n\r\n（2）创建dao接口：com.itheima.dao.store.CourseDao\r\n\r\n```java\r\npublic interface CourseDao {\r\n    int save(Course course);\r\n\r\n    int delete(Course course);\r\n\r\n    int update(Course course);\r\n\r\n    Course findById(String id);\r\n\r\n    List<Course> findAll();\r\n}\r\n```\r\n\r\n（3）从今日课程资料中找到`dao层资源文件\\CourseDao.xml`，拷贝到项目`src/main/resources/com/itheima/dao/store/`下\r\n\r\n当然这个地方可以将该目录下的所有映射配置文件都拷贝到该目录下，在做后续业务时就无需在拷贝了。\r\n\r\n（4）创建业务层接口：com.itheima.service.store.CourseService\r\n\r\n```java\r\npublic interface CourseService {\r\n    /**\r\n     * 添加\r\n     * @param course\r\n     * @return\r\n     */\r\n    void save(Course course);\r\n\r\n    /**\r\n     * 删除\r\n     * @param course\r\n     * @return\r\n     */\r\n    void delete(Course course);\r\n\r\n    /**\r\n     * 修改\r\n     * @param course\r\n     * @return\r\n     */\r\n    void update(Course course);\r\n\r\n    /**\r\n     * 查询单个\r\n     * @param id 查询的条件（id）\r\n     * @return 查询的结果，单个对象\r\n     */\r\n    Course findById(String id);\r\n\r\n    /**\r\n     * 查询全部的数据\r\n     * @return 全部数据的列表对象\r\n     */\r\n    List<Course> findAll();\r\n\r\n    /**\r\n     * 分页查询数据\r\n     * @param page 页码\r\n     * @param size 每页显示的数据总量\r\n     * @return\r\n     */\r\n    PageInfo findAll(int page, int size);\r\n}\r\n```\r\n\r\n（5）创建业务层实现类：com.itheima.service.store.impl.CourseServiceImpl\r\n\r\n```java\r\npublic class CourseServiceImpl implements CourseService {\r\n    @Override\r\n    public void save(Course course) {\r\n        SqlSession sqlSession = null;\r\n        try{\r\n            //1.获取SqlSession\r\n            sqlSession = MapperFactory.getSqlSession();\r\n            //2.获取Dao\r\n            CourseDao courseDao = MapperFactory.getMapper(sqlSession,CourseDao.class);\r\n            //id使用UUID的生成策略来获取\r\n            String id = UUID.randomUUID().toString();\r\n            course.setId(id);\r\n            //3.调用Dao层操作\r\n            courseDao.save(course);\r\n            //4.提交事务\r\n            TransactionUtil.commit(sqlSession);\r\n        }catch (Exception e){\r\n            TransactionUtil.rollback(sqlSession);\r\n            throw new RuntimeException(e);\r\n            //记录日志\r\n        }finally {\r\n            try {\r\n                TransactionUtil.close(sqlSession);\r\n            }catch (Exception e){\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void delete(Course course) {\r\n        SqlSession sqlSession = null;\r\n        try{\r\n            //1.获取SqlSession\r\n            sqlSession = MapperFactory.getSqlSession();\r\n            //2.获取Dao\r\n            CourseDao courseDao = MapperFactory.getMapper(sqlSession,CourseDao.class);\r\n            //3.调用Dao层操作\r\n            courseDao.delete(course);\r\n            //4.提交事务\r\n            TransactionUtil.commit(sqlSession);\r\n        }catch (Exception e){\r\n            TransactionUtil.rollback(sqlSession);\r\n            throw new RuntimeException(e);\r\n            //记录日志\r\n        }finally {\r\n            try {\r\n                TransactionUtil.close(sqlSession);\r\n            }catch (Exception e){\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void update(Course course) {\r\n        SqlSession sqlSession = null;\r\n        try{\r\n            //1.获取SqlSession\r\n            sqlSession = MapperFactory.getSqlSession();\r\n            //2.获取Dao\r\n            CourseDao courseDao = MapperFactory.getMapper(sqlSession,CourseDao.class);\r\n            //3.调用Dao层操作\r\n            courseDao.update(course);\r\n            //4.提交事务\r\n            TransactionUtil.commit(sqlSession);\r\n        }catch (Exception e){\r\n            TransactionUtil.rollback(sqlSession);\r\n            throw new RuntimeException(e);\r\n            //记录日志\r\n        }finally {\r\n            try {\r\n                TransactionUtil.close(sqlSession);\r\n            }catch (Exception e){\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public Course findById(String id) {\r\n        SqlSession sqlSession = null;\r\n        try{\r\n            //1.获取SqlSession\r\n            sqlSession = MapperFactory.getSqlSession();\r\n            //2.获取Dao\r\n            CourseDao courseDao = MapperFactory.getMapper(sqlSession,CourseDao.class);\r\n            //3.调用Dao层操作\r\n            return courseDao.findById(id);\r\n        }catch (Exception e){\r\n            throw new RuntimeException(e);\r\n            //记录日志\r\n        }finally {\r\n            try {\r\n                TransactionUtil.close(sqlSession);\r\n            }catch (Exception e){\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public List<Course> findAll() {\r\n        SqlSession sqlSession = null;\r\n        try{\r\n            //1.获取SqlSession\r\n            sqlSession = MapperFactory.getSqlSession();\r\n            //2.获取Dao\r\n            CourseDao courseDao = MapperFactory.getMapper(sqlSession,CourseDao.class);\r\n            //3.调用Dao层操作\r\n            return courseDao.findAll();\r\n        }catch (Exception e){\r\n            throw new RuntimeException(e);\r\n            //记录日志\r\n        }finally {\r\n            try {\r\n                TransactionUtil.close(sqlSession);\r\n            }catch (Exception e){\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public PageInfo findAll(int page, int size) {\r\n        SqlSession sqlSession = null;\r\n        try{\r\n            //1.获取SqlSession\r\n            sqlSession = MapperFactory.getSqlSession();\r\n            //2.获取Dao\r\n            CourseDao courseDao = MapperFactory.getMapper(sqlSession,CourseDao.class);\r\n            //3.调用Dao层操作\r\n            PageHelper.startPage(page,size);\r\n            List<Course> all = courseDao.findAll();\r\n            PageInfo pageInfo = new PageInfo(all);\r\n            return pageInfo;\r\n        }catch (Exception e){\r\n            throw new RuntimeException(e);\r\n            //记录日志\r\n        }finally {\r\n            try {\r\n                TransactionUtil.close(sqlSession);\r\n            }catch (Exception e){\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n（6）创建servlet：com.itheima.web.controller.store.CourseServlet\r\n\r\n```java\r\n// uri:/store/course?operation=list\r\n@WebServlet("/store/course")\r\npublic class CourseServlet extends BaseServlet {\r\n\r\n    @Override\r\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        String operation = request.getParameter("operation");\r\n        if("list".equals(operation)){\r\n            this.list(request,response);\r\n        }else if("toAdd".equals(operation)){\r\n            this.toAdd(request,response);\r\n        }else if("save".equals(operation)){\r\n            this.save(request, response);\r\n        }else if("toEdit".equals(operation)){\r\n            this.toEdit(request,response);\r\n        }else if("edit".equals(operation)){\r\n            this.edit(request,response);\r\n        }else if("delete".equals(operation)){\r\n            this.delete(request,response);\r\n        }\r\n    }\r\n\r\n    private void list(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {\r\n        //进入列表页\r\n        //获取数据\r\n        int page = 1;\r\n        int size = 5;\r\n        if(StringUtils.isNotBlank(request.getParameter("page"))){\r\n            page = Integer.parseInt(request.getParameter("page"));\r\n        }\r\n        if(StringUtils.isNotBlank(request.getParameter("size"))){\r\n            size = Integer.parseInt(request.getParameter("size"));\r\n        }\r\n        PageInfo all = courseService.findAll(page, size);\r\n        //将数据保存到指定的位置\r\n        request.setAttribute("page",all);\r\n        //跳转页面\r\n        request.getRequestDispatcher("/WEB-INF/pages/store/course/list.jsp").forward(request,response);\r\n    }\r\n\r\n    private void toAdd(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {\r\n        //跳转页面\r\n        request.getRequestDispatcher("/WEB-INF/pages/store/course/add.jsp").forward(request,response);\r\n    }\r\n\r\n    private void save(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {\r\n        //将数据获取到，封装成一个对象\r\n        Course course = BeanUtil.fillBean(request,Course.class,"yyyy-MM-dd");\r\n        //调用业务层接口save\r\n        courseService.save(course);\r\n        //跳转回到页面list\r\n        response.sendRedirect(request.getContextPath()+"/store/course?operation=list");\r\n    }\r\n\r\n    private void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        //查询要修改的数据findById\r\n        String id = request.getParameter("id");\r\n        Course course = courseService.findById(id);\r\n        //将数据加载到指定区域，供页面获取\r\n        request.setAttribute("course",course);\r\n        //跳转页面\r\n        request.getRequestDispatcher("/WEB-INF/pages/store/course/update.jsp").forward(request,response);\r\n    }\r\n\r\n    private void edit(HttpServletRequest request, HttpServletResponse response) throws IOException {\r\n        //将数据获取到，封装成一个对象\r\n        Course course = BeanUtil.fillBean(request,Course.class,"yyyy-MM-dd");\r\n        //调用业务层接口save\r\n        courseService.update(course);\r\n        //跳转回到页面list\r\n        response.sendRedirect(request.getContextPath()+"/store/course?operation=list");\r\n    }\r\n\r\n    private void delete(HttpServletRequest request, HttpServletResponse response) throws IOException {\r\n        //将数据获取到，封装成一个对象\r\n        Course course = BeanUtil.fillBean(request,Course.class);\r\n        //调用业务层接口save\r\n        courseService.delete(course);\r\n        //跳转回到页面list\r\n        response.sendRedirect(request.getContextPath()+"/store/course?operation=list");\r\n    }\r\n\r\n    @Override\r\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        this.doGet(request,response);\r\n    }\r\n}\r\n```\r\n\r\n（7）修改BaseServlet，添加`CourseService`\r\n\r\n```java\r\npublic class BaseServlet extends HttpServlet {\r\n    protected CompanyService companyService;\r\n    protected DeptService deptService;\r\n    protected UserService userService;\r\n    protected CourseService courseService;\r\n\r\n    @Override\r\n    public void init() throws ServletException {\r\n        companyService = new CompanyServiceImpl();\r\n        deptService = new DeptServiceImpl();\r\n        userService = new UserServiceImpl();\r\n        courseService = new CourseServiceImpl();\r\n    }\r\n}\r\n```\r\n\r\n（8）创建`/WEB-INF/pages/store/course`目录，然后从今日课程资料中找到`模块页面\\course`下的所有页面，拷贝到刚刚创建的目录下\r\n\r\n（9）修改业务层的保存方法，添加创建时间的保存\r\n\r\n```java\r\n@Override\r\npublic void save(Course course) {\r\n    SqlSession sqlSession = null;\r\n    try{\r\n        //1.获取SqlSession\r\n        sqlSession = MapperFactory.getSqlSession();\r\n        //2.获取Dao\r\n        CourseDao courseDao = MapperFactory.getMapper(sqlSession,CourseDao.class);\r\n        //id使用UUID的生成策略来获取\r\n        String id = UUID.randomUUID().toString();\r\n        course.setId(id);\r\n\r\n        //添加创建的时间\r\n        course.setCreateTime(new Date());\r\n\r\n        //3.调用Dao层操作\r\n        courseDao.save(course);\r\n        //4.提交事务\r\n        TransactionUtil.commit(sqlSession);\r\n    }catch (Exception e){\r\n        TransactionUtil.rollback(sqlSession);\r\n        throw new RuntimeException(e);\r\n        //记录日志\r\n    }finally {\r\n        try {\r\n            TransactionUtil.close(sqlSession);\r\n        }catch (Exception e){\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n（10）在修改时，我们的创建时间是不允许修改的，因此我们在dao层进行update操作是去掉对创建时间的修改，找到`CourseDao`对应的持久层映射配置文件`CourseDao.xml`中的`update`，去掉创建时间即可\r\n\r\n```xml\r\n\x3c!--配置全字段更新，当提供的数据为null时，数据库数据会被更新为null--\x3e\r\n<update id="update" parameterType="com.itheima.domain.store.Course">\r\n    update st_course\r\n    set name = #{name,jdbcType=VARCHAR},\r\n    remark = #{remark,jdbcType=VARCHAR},\r\n    state = #{state,jdbcType=VARCHAR}\r\n    where id = #{id,jdbcType=VARCHAR}\r\n</update>\r\n```\r\n\r\n（11）解决站点字符编码的问题，从今日课程资料中找到`web层资源文件\\CharacterEncodingFilter.java`\r\n\r\n然后创建一个包`com.itheima.web.filters`，然后把该文件拷贝到该包下\r\n\r\n（12）启动项目进行测试\r\n\r\n## 3. 目录模块\r\n\r\n（1）创建目录实体：com.itheima.domain.store.Catalog\r\n\r\n```java\r\npublic class Catalog {    private String id;    private String name;    private String remark;    private String state;    private Date createTime;    private String courseId;    private Course course;\t// getter/setter略}\r\n```\r\n\r\n（2）创建dao接口：com.itheima.dao.store.CatalogDao\r\n\r\n```java\r\npublic interface CatalogDao {    int save(Catalog catalog);    int delete(Catalog catalog);    int update(Catalog catalog);    Catalog findById(String id);    List<Catalog> findAll();}\r\n```\r\n\r\n（3）拷贝dao映射配置文件：前面已完成\r\n\r\n（4）创建业务层接口：com.itheima.service.store.CatalogService\r\n\r\n```java\r\npublic interface CatalogService {    /**     * 添加     * @param catalog     * @return     */    void save(Catalog catalog);    /**     * 删除     * @param catalog     * @return     */    void delete(Catalog catalog);    /**     * 修改     * @param catalog     * @return     */    void update(Catalog catalog);    /**     * 查询单个     * @param id 查询的条件（id）     * @return 查询的结果，单个对象     */    Catalog findById(String id);    /**     * 查询全部的数据     * @return 全部数据的列表对象     */    List<Catalog> findAll();    /**     * 分页查询数据     * @param page 页码     * @param size 每页显示的数据总量     * @return     */    PageInfo findAll(int page, int size);}\r\n```\r\n\r\n（5）创建业务层实现类：com.itheima.service.store.impl.CatalogServiceImpl\r\n\r\n```java\r\npublic class CatalogServiceImpl implements CatalogService {    @Override    public void save(Catalog catalog) {        SqlSession sqlSession = null;        try {            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            CatalogDao catalogDao = MapperFactory.getMapper(sqlSession, CatalogDao.class);            //id使用UUID的生成策略来获取            String id = UUID.randomUUID().toString();            catalog.setId(id);            //3.调用Dao层操作            catalogDao.save(catalog);            //4.提交事务            TransactionUtil.commit(sqlSession);        } catch (Exception e) {            TransactionUtil.rollback(sqlSession);            throw new RuntimeException(e);            //记录日志        } finally {            try {                TransactionUtil.close(sqlSession);            } catch (Exception e) {                e.printStackTrace();            }        }    }    @Override    public void delete(Catalog catalog) {        SqlSession sqlSession = null;        try {            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            CatalogDao catalogDao = MapperFactory.getMapper(sqlSession, CatalogDao.class);            //3.调用Dao层操作            catalogDao.delete(catalog);            //4.提交事务            TransactionUtil.commit(sqlSession);        } catch (Exception e) {            TransactionUtil.rollback(sqlSession);            throw new RuntimeException(e);            //记录日志        } finally {            try {                TransactionUtil.close(sqlSession);            } catch (Exception e) {                e.printStackTrace();            }        }    }    @Override    public void update(Catalog catalog) {        SqlSession sqlSession = null;        try {            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            CatalogDao catalogDao = MapperFactory.getMapper(sqlSession, CatalogDao.class);            //3.调用Dao层操作            catalogDao.update(catalog);            //4.提交事务            TransactionUtil.commit(sqlSession);        } catch (Exception e) {            TransactionUtil.rollback(sqlSession);            throw new RuntimeException(e);            //记录日志        } finally {            try {                TransactionUtil.close(sqlSession);            } catch (Exception e) {                e.printStackTrace();            }        }    }    @Override    public Catalog findById(String id) {        SqlSession sqlSession = null;        try {            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            CatalogDao catalogDao = MapperFactory.getMapper(sqlSession, CatalogDao.class);            //3.调用Dao层操作            return catalogDao.findById(id);        } catch (Exception e) {            throw new RuntimeException(e);            //记录日志        } finally {            try {                TransactionUtil.close(sqlSession);            } catch (Exception e) {                e.printStackTrace();            }        }    }    @Override    public List<Catalog> findAll() {        SqlSession sqlSession = null;        try {            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            CatalogDao catalogDao = MapperFactory.getMapper(sqlSession, CatalogDao.class);            //3.调用Dao层操作            return catalogDao.findAll();        } catch (Exception e) {            throw new RuntimeException(e);            //记录日志        } finally {            try {                TransactionUtil.close(sqlSession);            } catch (Exception e) {                e.printStackTrace();            }        }    }    @Override    public PageInfo findAll(int page, int size) {        SqlSession sqlSession = null;        try {            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            CatalogDao catalogDao = MapperFactory.getMapper(sqlSession, CatalogDao.class);            //3.调用Dao层操作            PageHelper.startPage(page, size);            List<Catalog> all = catalogDao.findAll();            PageInfo pageInfo = new PageInfo(all);            return pageInfo;        } catch (Exception e) {            throw new RuntimeException(e);            //记录日志        } finally {            try {                TransactionUtil.close(sqlSession);            } catch (Exception e) {                e.printStackTrace();            }        }    }}\r\n```\r\n\r\n（6）创建servlet：com.itheima.web.controller.store.CatalogServlet\r\n\r\n```java\r\n// uri:/store/catalog?operation=list@WebServlet("/store/catalog")public class CatalogServlet extends BaseServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        String operation = request.getParameter("operation");        if("list".equals(operation)){            this.list(request,response);        }else if("toAdd".equals(operation)){            this.toAdd(request,response);        }else if("save".equals(operation)){            this.save(request, response);        }else if("toEdit".equals(operation)){            this.toEdit(request,response);        }else if("edit".equals(operation)){            this.edit(request,response);        }else if("delete".equals(operation)){            this.delete(request,response);        }    }    private void list(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {        //进入列表页        //获取数据        int page = 1;        int size = 5;        if(StringUtils.isNotBlank(request.getParameter("page"))){            page = Integer.parseInt(request.getParameter("page"));        }        if(StringUtils.isNotBlank(request.getParameter("size"))){            size = Integer.parseInt(request.getParameter("size"));        }        PageInfo all = catalogService.findAll(page, size);        //将数据保存到指定的位置        request.setAttribute("page",all);        //跳转页面        request.getRequestDispatcher("/WEB-INF/pages/store/catalog/list.jsp").forward(request,response);    }    private void toAdd(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {        //跳转页面        request.getRequestDispatcher("/WEB-INF/pages/store/catalog/add.jsp").forward(request,response);    }    private void save(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {        //将数据获取到，封装成一个对象        Catalog catalog = BeanUtil.fillBean(request,Catalog.class,"yyyy-MM-dd");        //调用业务层接口save        catalogService.save(catalog);        //跳转回到页面list        response.sendRedirect(request.getContextPath()+"/store/catalog?operation=list");    }    private void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //查询要修改的数据findById        String id = request.getParameter("id");        Catalog catalog = catalogService.findById(id);        //将数据加载到指定区域，供页面获取        request.setAttribute("catalog",catalog);        //跳转页面        request.getRequestDispatcher("/WEB-INF/pages/store/catalog/update.jsp").forward(request,response);    }    private void edit(HttpServletRequest request, HttpServletResponse response) throws IOException {        //将数据获取到，封装成一个对象        Catalog catalog = BeanUtil.fillBean(request,Catalog.class,"yyyy-MM-dd");        //调用业务层接口save        catalogService.update(catalog);        //跳转回到页面list        response.sendRedirect(request.getContextPath()+"/store/catalog?operation=list");    }    private void delete(HttpServletRequest request, HttpServletResponse response) throws IOException {        //将数据获取到，封装成一个对象        Catalog catalog = BeanUtil.fillBean(request,Catalog.class);        //调用业务层接口save        catalogService.delete(catalog);        //跳转回到页面list        response.sendRedirect(request.getContextPath()+"/store/catalog?operation=list");    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request,response);    }}\r\n```\r\n\r\n（7）修改BaseServlet，添加`CatalogService`\r\n\r\n```java\r\npublic class BaseServlet extends HttpServlet {    protected CompanyService companyService;    protected DeptService deptService;    protected UserService userService;    protected CourseService courseService;    protected CatalogService catalogService;    @Override    public void init() throws ServletException {        companyService = new CompanyServiceImpl();        deptService = new DeptServiceImpl();        userService = new UserServiceImpl();        courseService = new CourseServiceImpl();        catalogService = new CatalogServiceImpl();    }}\r\n```\r\n\r\n（8）创建页面存放目录`/WEB-INF/pages/store/catalog`，然后从今日课程资料中找到`模块页面\\catalog`下的所有页面到该目录\r\n\r\n（9）修改servlet代码，找到`toAdd`方法，在去添加页面之前查询所有的学科数据\r\n\r\n```java\r\nprivate void toAdd(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {    //加载学科信息    List<Course> all = courseService.findAll();    request.setAttribute("courseList",all);    //跳转页面    request.getRequestDispatcher("/WEB-INF/pages/store/catalog/add.jsp").forward(request,response);}\r\n```\r\n\r\n（10）保存目录的时候要保存创建时间，修改业务层的save方法，添加对创建时间的保存\r\n\r\n```java\r\n@Overridepublic void save(Catalog catalog) {    SqlSession sqlSession = null;    try {        //1.获取SqlSession        sqlSession = MapperFactory.getSqlSession();        //2.获取Dao        CatalogDao catalogDao = MapperFactory.getMapper(sqlSession, CatalogDao.class);        //id使用UUID的生成策略来获取        String id = UUID.randomUUID().toString();        catalog.setId(id);        catalog.setCreateTime(new Date());        //3.调用Dao层操作        catalogDao.save(catalog);        //4.提交事务        TransactionUtil.commit(sqlSession);    } catch (Exception e) {        TransactionUtil.rollback(sqlSession);        throw new RuntimeException(e);        //记录日志    } finally {        try {            TransactionUtil.close(sqlSession);        } catch (Exception e) {            e.printStackTrace();        }    }}\r\n```\r\n\r\n（11）修改servlet代码，找到`toEdit`方法，去到编辑页面之前查询所有的学科信息，\r\n\r\n```java\r\nprivate void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    //查询要修改的数据findById    String id = request.getParameter("id");    Catalog catalog = catalogService.findById(id);    //将数据加载到指定区域，供页面获取    request.setAttribute("catalog",catalog);    //加载学科信息    List<Course> all = courseService.findAll();    request.setAttribute("courseList",all);    //跳转页面    request.getRequestDispatcher("/WEB-INF/pages/store/catalog/update.jsp").forward(request,response);}\r\n```\r\n\r\n（12）启动项目，进行测试\r\n\r\n## 4. 题目模块\r\n\r\n### 4.1 题目模块快速开发\r\n\r\n（1）创建题目实体：com.itheima.domain.store.Question\r\n\r\n```java\r\npublic class Question {    private String id;\t\t\t//题目ID    private String companyId;\t//所属企业    private String catalogId;\t//题目所属目录ID    private String remark;\t\t//题目简介    private String subject;     //题干    private String analysis;\t//题目分析    private String type;       \t//题目类型  1:单选，2：多选，3：简答    private String difficulty; \t//难易程度： 1极易 2容易 3普通  4困难  5极难    private String isClassic; \t//是否经典面试题 0：否 1：是    private String state;   \t//题目状态  0：不可用  1：可用（只有审核通过的题目才可以设置）    private String reviewStatus;//审核状态  -1 审核不通过  0 审核中   1 审核通过    private Date createTime;        private Company company;    private Catalog catalog;    \t// getter/setter 略}\r\n```\r\n\r\n（2）创建dao接口：com.itheima.dao.store.QuestionDao\r\n\r\n```java\r\npublic interface QuestionDao {    int save(Question question);    int delete(Question question);    int update(Question question);    Question findById(String id);    List<Question> findAll();}\r\n```\r\n\r\n（3）添加题目dao的映射配置文件，之前已操作，略\r\n\r\n（4）创建业务层接口：com.itheima.service.store.QuestionService\r\n\r\n```java\r\npublic interface QuestionService {    /**     * 添加     * @param question     * @return     */    void save(Question question);    /**     * 删除     * @param question     * @return     */    void delete(Question question);    /**     * 修改     * @param question     * @return     */    void update(Question question);    /**     * 查询单个     * @param id 查询的条件（id）     * @return 查询的结果，单个对象     */    Question findById(String id);    /**     * 查询全部的数据     * @return 全部数据的列表对象     */    List<Question> findAll();    /**     * 分页查询数据     * @param page 页码     * @param size 每页显示的数据总量     * @return     */    PageInfo findAll(int page, int size);}\r\n```\r\n\r\n（5）创建业务层实现类：com.itheima.service.store.impl.QuestionServiceImpl\r\n\r\n```java\r\npublic class QuestionServiceImpl implements QuestionService {    @Override    public void save(Question question) {        SqlSession sqlSession = null;        try{            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            QuestionDao questionDao = MapperFactory.getMapper(sqlSession,QuestionDao.class);            //id使用UUID的生成策略来获取            String id = UUID.randomUUID().toString();            question.setId(id);            //3.调用Dao层操作            questionDao.save(question);            //4.提交事务            TransactionUtil.commit(sqlSession);        }catch (Exception e){            TransactionUtil.rollback(sqlSession);            throw new RuntimeException(e);            //记录日志        }finally {            try {                TransactionUtil.close(sqlSession);            }catch (Exception e){                e.printStackTrace();            }        }    }    @Override    public void delete(Question question) {        SqlSession sqlSession = null;        try{            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            QuestionDao questionDao = MapperFactory.getMapper(sqlSession,QuestionDao.class);            //3.调用Dao层操作            questionDao.delete(question);            //4.提交事务            TransactionUtil.commit(sqlSession);        }catch (Exception e){            TransactionUtil.rollback(sqlSession);            throw new RuntimeException(e);            //记录日志        }finally {            try {                TransactionUtil.close(sqlSession);            }catch (Exception e){                e.printStackTrace();            }        }    }    @Override    public void update(Question question) {        SqlSession sqlSession = null;        try{            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            QuestionDao questionDao = MapperFactory.getMapper(sqlSession,QuestionDao.class);            //3.调用Dao层操作            questionDao.update(question);            //4.提交事务            TransactionUtil.commit(sqlSession);        }catch (Exception e){            TransactionUtil.rollback(sqlSession);            throw new RuntimeException(e);            //记录日志        }finally {            try {                TransactionUtil.close(sqlSession);            }catch (Exception e){                e.printStackTrace();            }        }    }    @Override    public Question findById(String id) {        SqlSession sqlSession = null;        try{            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            QuestionDao questionDao = MapperFactory.getMapper(sqlSession,QuestionDao.class);            //3.调用Dao层操作            return questionDao.findById(id);        }catch (Exception e){            throw new RuntimeException(e);            //记录日志        }finally {            try {                TransactionUtil.close(sqlSession);            }catch (Exception e){                e.printStackTrace();            }        }    }    @Override    public List<Question> findAll() {        SqlSession sqlSession = null;        try{            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            QuestionDao questionDao = MapperFactory.getMapper(sqlSession,QuestionDao.class);            //3.调用Dao层操作            return questionDao.findAll();        }catch (Exception e){            throw new RuntimeException(e);            //记录日志        }finally {            try {                TransactionUtil.close(sqlSession);            }catch (Exception e){                e.printStackTrace();            }        }    }    @Override    public PageInfo findAll(int page, int size) {        SqlSession sqlSession = null;        try{            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            QuestionDao questionDao = MapperFactory.getMapper(sqlSession,QuestionDao.class);            //3.调用Dao层操作            PageHelper.startPage(page,size);            List<Question> all = questionDao.findAll();            PageInfo pageInfo = new PageInfo(all);            return pageInfo;        }catch (Exception e){            throw new RuntimeException(e);            //记录日志        }finally {            try {                TransactionUtil.close(sqlSession);            }catch (Exception e){                e.printStackTrace();            }        }    }}\r\n```\r\n\r\n（6）创建servlet：com.itheima.web.controller.store.QuestionServlet\r\n\r\n```java\r\n// uri:/store/question?operation=list@WebServlet("/store/question")public class QuestionServlet extends BaseServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        String operation = request.getParameter("operation");        if("list".equals(operation)){            this.list(request,response);        }else if("toAdd".equals(operation)){            this.toAdd(request,response);        }else if("save".equals(operation)){            this.save(request, response);        }else if("toEdit".equals(operation)){            this.toEdit(request,response);        }else if("edit".equals(operation)){            this.edit(request,response);        }else if("delete".equals(operation)){            this.delete(request,response);        }    }    private void list(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {        //进入列表页        //获取数据        int page = 1;        int size = 5;        if(StringUtils.isNotBlank(request.getParameter("page"))){            page = Integer.parseInt(request.getParameter("page"));        }        if(StringUtils.isNotBlank(request.getParameter("size"))){            size = Integer.parseInt(request.getParameter("size"));        }        PageInfo all = questionService.findAll(page, size);        //将数据保存到指定的位置        request.setAttribute("page",all);        //跳转页面        request.getRequestDispatcher("/WEB-INF/pages/store/question/list.jsp").forward(request,response);    }    private void toAdd(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {        //跳转页面        request.getRequestDispatcher("/WEB-INF/pages/store/question/add.jsp").forward(request,response);    }    private void save(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {        //将数据获取到，封装成一个对象        Question question = BeanUtil.fillBean(request,Question.class,"yyyy-MM-dd");        //调用业务层接口save        questionService.save(question);        //跳转回到页面list        response.sendRedirect(request.getContextPath()+"/store/question?operation=list");    }    private void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //查询要修改的数据findById        String id = request.getParameter("id");        Question question = questionService.findById(id);        //将数据加载到指定区域，供页面获取        request.setAttribute("question",question);        //跳转页面        request.getRequestDispatcher("/WEB-INF/pages/store/question/update.jsp").forward(request,response);    }    private void edit(HttpServletRequest request, HttpServletResponse response) throws IOException {        //将数据获取到，封装成一个对象        Question question = BeanUtil.fillBean(request,Question.class,"yyyy-MM-dd");        //调用业务层接口save        questionService.update(question);        //跳转回到页面list        //list(request,response);        response.sendRedirect(request.getContextPath()+"/store/question?operation=list");    }    private void delete(HttpServletRequest request, HttpServletResponse response) throws IOException {        //将数据获取到，封装成一个对象        Question question = BeanUtil.fillBean(request,Question.class);        //调用业务层接口save        questionService.delete(question);        //跳转回到页面list        response.sendRedirect(request.getContextPath()+"/store/question?operation=list");    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request,response);    }}\r\n```\r\n\r\n（7）修改BaserServlet，添加`QuestionService`\r\n\r\n```java\r\npublic class BaseServlet extends HttpServlet {    protected CompanyService companyService;    protected DeptService deptService;    protected UserService userService;    protected CourseService courseService;    protected CatalogService catalogService;    protected QuestionService questionService;    @Override    public void init() throws ServletException {        companyService = new CompanyServiceImpl();        deptService = new DeptServiceImpl();        userService = new UserServiceImpl();        courseService = new CourseServiceImpl();        catalogService = new CatalogServiceImpl();        questionService = new QuestionServiceImpl();    }}\r\n```\r\n\r\n（8）创建页面存放目录,`/WEB-INF/pages/store/question`，从今日课程资料中找到`模块页面\\question`，将下面的所有页面拷贝到该目录下\r\n\r\n（9）修改servlet，找到`toAdd`方法，去添加页面之前查询企业和目录数据\r\n\r\n```java\r\nprivate void toAdd(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {    List<Company> companyList = companyService.findAll();    List<Catalog> catalogList = catalogService.findAll();    request.setAttribute("companyList",companyList);    request.setAttribute("catalogList",catalogList);    //跳转页面    request.getRequestDispatcher("/WEB-INF/pages/store/question/add.jsp").forward(request,response);}\r\n```\r\n\r\n找到`toEdit`方法，去修改页面之前查询企业和目录数据\r\n\r\n```java\r\nprivate void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    //查询要修改的数据findById    String id = request.getParameter("id");    Question question = questionService.findById(id);    //将数据加载到指定区域，供页面获取    request.setAttribute("question",question);    List<Company> companyList = companyService.findAll();    List<Catalog> catalogList = catalogService.findAll();    request.setAttribute("companyList",companyList);    request.setAttribute("catalogList",catalogList);    //跳转页面    request.getRequestDispatcher("/WEB-INF/pages/store/question/update.jsp").forward(request,response);}\r\n```\r\n\r\n（10）修改业务层代码，找到添加数据的方法，需要新增审核状态和创建时间的数据\r\n\r\n```java\r\n@Overridepublic void save(Question question) {    SqlSession sqlSession = null;    try{        //1.获取SqlSession        sqlSession = MapperFactory.getSqlSession();        //2.获取Dao        QuestionDao questionDao = MapperFactory.getMapper(sqlSession,QuestionDao.class);        //id使用UUID的生成策略来获取        String id = UUID.randomUUID().toString();        question.setId(id);        //设置新创建的题目默认的审核状态为未审核（0）        question.setReviewStatus("0");        question.setCreateTime(new Date());        //3.调用Dao层操作        questionDao.save(question);        //4.提交事务        TransactionUtil.commit(sqlSession);    }catch (Exception e){        TransactionUtil.rollback(sqlSession);        throw new RuntimeException(e);        //记录日志    }finally {        try {            TransactionUtil.close(sqlSession);        }catch (Exception e){            e.printStackTrace();        }    }}\r\n```\r\n\r\n（11）修改查询所有数据时的排序，修改对应的dao映射配置文件`QuestionDao.xml`\r\n\r\n```xml\r\n\x3c!--配置查询所有，带条件--\x3e<select id="findAll" resultMap="BaseResultMap">    select    <include refid="Base_Column_List"/>    from st_question    order by create_time desc</select>\r\n```\r\n\r\n（12）在进行数据修改时，有些数据是不能修改的，我们可以在持久层映射配置文件中进行控制\r\n\r\n```xml\r\n\x3c!--配置全字段更新，当提供的数据为null时，数据库数据会被更新为null--\x3e<update id="update" parameterType="com.itheima.domain.store.Question">    update    st_question    set    company_id = #{companyId,jdbcType=VARCHAR},    catalog_id = #{catalogId,jdbcType=VARCHAR},    remark = #{remark,jdbcType=VARCHAR},    subject = #{subject,jdbcType=VARCHAR},    analysis = #{analysis,jdbcType=VARCHAR},    difficulty = #{difficulty,jdbcType=VARCHAR},    is_classic = #{isClassic,jdbcType=VARCHAR},    state = #{state,jdbcType=VARCHAR}    where    id = #{id,jdbcType=VARCHAR}</update>\r\n```\r\n\r\n\r\n\r\n### 4.2 文件上传基础演示\r\n\r\n文件上传功能需要前台功能和后台功能共同配合完成\r\n\r\n**前台**：文件上传的三要素\r\n\r\n- 页面提供文件上传的表单元素\r\n\r\n![](web综合案例_day02.assets/6.png)\r\n\r\n- form表单enctype属性的值为`multipart/form-data`\r\n\r\n![](web综合案例_day02.assets/7.png)\r\n\r\n- 表单的提交方式必须是`POST`，get方式无法提交大量的数据\r\n\r\n**后台**：可以使用的技术有很多，在此处我们使用apache提供的commons-fileupload组件完成文件上次操作，后台的操作步骤如下\r\n\r\n- 确认请求操作是否支持文件上传\r\n- 创建磁盘工厂对象，用于将页面上传的文件保存到磁盘中\r\n- 获取servet文件上传核心对象\r\n- 读取数据\r\n- 对读取到数据中的文件表单进行操作，并将内容写到指定位置\r\n\r\n\r\n\r\n下面我们开始进行文件上传的演示：\r\n\r\n（1）从今日课程资料找到`文件下载\\testFileUpload.jsp`文件上传页面，将其添加到项目`/WEB-INF/pages/store/question目录下`\r\n\r\n（2）在question目录下的list.jsp页面上添加一个新的按钮，点击该按钮跳转到文件上传页面\r\n\r\n```html\r\n<button type="button" class="btn btn-default" title="测试文件上传" onclick=\'location.href="${ctx}/store/question?operation=toTestUpload"\'><i class="fa fa-file-o"></i> 测试文件上传</button>\r\n```\r\n\r\n（3）在`QuestionServlet`中添加`toTestUpload`方法，跳转到文件上传页面\r\n\r\n```java\r\n@WebServlet("/store/question")public class QuestionServlet extends BaseServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        String operation = request.getParameter("operation");        if("list".equals(operation)){            this.list(request,response);        }else if("toAdd".equals(operation)){            this.toAdd(request,response);        }else if("save".equals(operation)){            this.save(request, response);        }else if("toEdit".equals(operation)){            this.toEdit(request,response);        }else if("edit".equals(operation)){            this.edit(request,response);        }else if("delete".equals(operation)){            this.delete(request,response);        }else if("toTestUpload".equals(operation)){            this.toTestUpload(request,response);        }else if("testUpload".equals(operation)){            try {                this.testUpload(request,response);            } catch (Exception e) {                e.printStackTrace();            }        }    }    private void toTestUpload(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {        request.getRequestDispatcher("/WEB-INF/pages/store/question/testFileUpload.jsp").forward(request,response);    }    private void testUpload(HttpServletRequest request,HttpServletResponse response) throws Exception {          }}   \r\n```\r\n\r\n（4）完成文件上传的后台代码\r\n\r\n```java\r\nprivate void testUpload(HttpServletRequest request,HttpServletResponse response) throws Exception {    //1.确认该操作是否支持文件上传操作，enctype="multipart/form-data"    if(ServletFileUpload.isMultipartContent(request)){        //2.创建磁盘工厂对象        DiskFileItemFactory factory = new DiskFileItemFactory();        //3.Servlet文件上传核心对象        ServletFileUpload fileUpload = new ServletFileUpload(factory);        //4.从request中读取数据        List<FileItem> fileItems = fileUpload.parseRequest(request);        for(FileItem item : fileItems){            //5.当前表单是否是文件表单            if(!item.isFormField()){                //6.从临时存储文件的地方将内容写入到指定位置                item.write(new File(this.getServletContext().getRealPath("upload"),item.getName()));            }        }    }}\r\n```\r\n\r\n需要在项目`webapp`目录下创建一个upload目录用于存储上传过来的文件\r\n\r\n（5）启动测试\r\n\r\n### 4.3 添加题目时加入文件上传\r\n\r\n（1）在题目实体中添加图片的属性\r\n\r\n```java\r\npublic class Question {\t// 其他属性略    private String picture;        public String getPicture() {        return picture;    }    public void setPicture(String picture) {        this.picture = picture;    }}    \r\n```\r\n\r\n（2）在对应的dao映射配置文件中添加图片字段的配置，在`resultMap，查询的sql片段，保存，更新`几个位置添加映射配置即可，更新的时候是不需要更改图片的名称，因此是去掉对图片名称的更新\r\n\r\n```xml\r\n\x3c!--配置实体类属性和数据库表中列的对应关系--\x3e<resultMap id="BaseResultMap" type="com.itheima.domain.store.Question">    <id column="id" jdbcType="VARCHAR" property="id"/>    <result column="company_id" jdbcType="VARCHAR" property="companyId"/>    <result column="catalog_id" jdbcType="VARCHAR" property="catalogId"/>    <result column="remark" jdbcType="VARCHAR" property="remark"/>    <result column="subject" jdbcType="VARCHAR" property="subject"/>    <result column="analysis" jdbcType="VARCHAR" property="analysis"/>    <result column="type" jdbcType="VARCHAR" property="type"/>    <result column="difficulty" jdbcType="VARCHAR" property="difficulty"/>    <result column="is_classic" jdbcType="VARCHAR" property="isClassic"/>    <result column="state" jdbcType="VARCHAR" property="state"/>    <result column="review_status" jdbcType="VARCHAR" property="reviewStatus"/>    <result column="create_time" jdbcType="TIMESTAMP" property="createTime"/>    <result column="picture" jdbcType="VARCHAR" property="picture"/>    <association                 property="company"                 column="company_id"                 javaType="com.itheima.domain.store.Course"                 select="com.itheima.dao.store.CompanyDao.findById"/>    <association                 property="catalog"                 column="catalog_id"                 javaType="com.itheima.domain.store.Course"                 select="com.itheima.dao.store.CatalogDao.findById"                 /></resultMap>\x3c!--配置查询的列名公共SQL语句--\x3e<sql id="Base_Column_List">    id, catalog_id, company_id, remark,subject,analysis,type, difficulty, is_classic,    state, review_status, create_time, picture</sql>\x3c!--配置全字段插入，当某个字段没有值时，插入null--\x3e<insert id="save" parameterType="com.itheima.domain.store.Question">    insert into st_question(id, company_id, catalog_id, remark, subject, analysis, type,    difficulty, is_classic, state, review_status, create_time ,picture )    values (#{id,jdbcType=VARCHAR}, #{companyId,jdbcType=VARCHAR}, #{catalogId,jdbcType=VARCHAR},    #{remark,jdbcType=VARCHAR}, #{subject,jdbcType=VARCHAR}, #{analysis,jdbcType=VARCHAR},    #{type,jdbcType=VARCHAR}, #{difficulty,jdbcType=VARCHAR}, #{isClassic,jdbcType=VARCHAR},    #{state,jdbcType=VARCHAR}, #{reviewStatus,jdbcType=VARCHAR}, #{createTime,jdbcType=TIMESTAMP},    #{picture,jdbcType=VARCHAR} )</insert>\x3c!--配置全字段更新，当提供的数据为null时，数据库数据会被更新为null--\x3e<update id="update" parameterType="com.itheima.domain.store.Question">    update    st_question    set    company_id = #{companyId,jdbcType=VARCHAR},    catalog_id = #{catalogId,jdbcType=VARCHAR},    remark = #{remark,jdbcType=VARCHAR},    subject = #{subject,jdbcType=VARCHAR},    analysis = #{analysis,jdbcType=VARCHAR},    difficulty = #{difficulty,jdbcType=VARCHAR},    is_classic = #{isClassic,jdbcType=VARCHAR},    state = #{state,jdbcType=VARCHAR}    where    id = #{id,jdbcType=VARCHAR}</update>\r\n```\r\n\r\n（3）在question模块的添加页面`add.jsp`中加入图片上传的表单项\r\n\r\n```jsp\r\n<form id="editForm" action="${ctx}/store/question?operation=save" method="post" enctype="multipart/form-data">    \x3c!--其他元素略--\x3e        <div class="col-md-2 title">题干图片</div>\x3c!--放到题干后面--\x3e    <div class="col-md-10 data ">        <input type="file" class="form-control" placeholder="题干图片" name="picture">    </div>    </form>\r\n```\r\n\r\n（4）在servlet中修改保存题目的方法`save`，首先要更改的就是接收数据的方式，我们要按照文件上传的形式来接收\r\n\r\n```java\r\n@Overrideprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    String operation = request.getParameter("operation");    if("list".equals(operation)){        this.list(request,response);    }else if("toAdd".equals(operation)){        this.toAdd(request,response);    }else if("save".equals(operation)){        try {            this.save(request, response);        } catch (Exception e) {            e.printStackTrace();        }    }else if("toEdit".equals(operation)){        this.toEdit(request,response);    }else if("edit".equals(operation)){        this.edit(request,response);    }else if("delete".equals(operation)){        this.delete(request,response);    }else if("toTestUpload".equals(operation)){        this.toTestUpload(request,response);    }else if("testUpload".equals(operation)){        try {            this.testUpload(request,response);        } catch (Exception e) {            e.printStackTrace();        }    }}private void save(HttpServletRequest request,HttpServletResponse response) throws Exception {    //1.确认该操作是否支持文件上传操作，enctype="multipart/form-data"    if(ServletFileUpload.isMultipartContent(request)){        //2.创建磁盘工厂对象        DiskFileItemFactory factory = new DiskFileItemFactory();        //3.Servlet文件上传核心对象        ServletFileUpload fileUpload = new ServletFileUpload(factory);        //4.从request中读取数据        List<FileItem> fileItems = fileUpload.parseRequest(request);        // --处理form表单提交过来的普通数据        //将数据获取到，封装成一个对象        Question question = BeanUtil.fillBean(fileItems,Question.class);        //调用业务层接口save        questionService.save(question);        // --处理form表单提交过来的文件数据        for(FileItem item : fileItems){            //5.当前表单是否是文件表单            if(!item.isFormField()){                //6.从临时存储文件的地方将内容写入到指定位置                item.write(new File(this.getServletContext().getRealPath("upload"),item.getName()));            }        }    }    //跳转回到页面list    response.sendRedirect(request.getContextPath()+"/store/question?operation=list");}\r\n```\r\n\r\n\r\n\r\n### 4.4 文件上传的重名问题\r\n\r\n（1）在question模块的`list.jsp`页面中添加对图片名称的展示\r\n\r\n```jsp\r\n\x3c!--数据列表--\x3e<table id="dataList" class="table table-bordered table-striped table-hover dataTable">    <thead>        <tr>            <th class="" style="padding-right:0px;">                <input type="checkbox" name="selid" onclick="checkAll(\'id\',this)">            </th>            <th class="sorting">图片</th>            <th class="sorting">企业</th>            <th class="sorting">类别</th>            <th class="sorting">题目</th>            <th class="sorting">类型</th>            <th class="sorting">难度</th>            <th class="sorting">经典面试题</th>            <th class="sorting">状态</th>            <th class="sorting">审核结果</th>            <th class="text-center">操作</th>        </tr>    </thead>    <tbody>        <c:forEach items="${page.list}" var="o" varStatus="status">            <tr class="odd" onmouseover="this.className=\'highlight\'" onmouseout="this.className=\'odd\'" >                <td><input type="checkbox" name="id" value="${o.id}"/></td>                <td>${o.picture}</td>                <td>${o.company.name}</td>                <td>${o.catalog.name}</td>                <td>${o.subject}</td>                <td>                    <c:choose>                        <c:when test="${o.type eq \'1\'}">单选</c:when>                        <c:when test="${o.type eq \'2\'}">多选</c:when>                        <c:when test="${o.type eq \'3\'}">简答</c:when>                    </c:choose>                </td>                <td>                    <c:forEach begin="1" end="${o.difficulty}">                        ★                    </c:forEach>                </td>                <td>${o.isClassic eq "1" ? "经典题":"普通题"}</td>                <td>${o.state eq "1" ? "<font color=\'green\'>启用</font>" : "<font color=\'red\'>禁用</font>"}</td>                <td>                    <c:choose>                        <c:when test="${o.reviewStatus eq \'1\'}"><font color="green">审核通过</font></c:when>                        <c:when test="${o.reviewStatus eq \'0\'}">审核中</c:when>                        <c:when test="${o.reviewStatus eq \'-1\'}"><font color="red">审核不通过</font></c:when>                    </c:choose>                </td>                <th class="text-center">                    <button type="button" class="btn bg-olive btn-xs" onclick=\'location.href="${ctx}/store/question?operation=toEdit&id=${o.id}"\'>编辑</button>                    <button type="button" class="btn bg-olive btn-xs" onclick=\'location.href="${ctx}/store/question?operation=toExamine&id=${o.id}"\'>审核</button>                </th>            </tr>        </c:forEach>    </tbody></table>\r\n```\r\n\r\n\r\n\r\n文件上传的常见问题：**文件重名问题**\r\n\r\n（1）修改业务层接口`QuestionService`的保存方法，添加返回值，将图片的名称返回\r\n\r\n```java\r\n/**     * 添加     * @param question     * @return 保存的图片名称     */String save(Question question);\r\n```\r\n\r\n（2）修改实现类，添加对图片名称的存储及返回图片的名称，图片名称使用该条数据的id\r\n\r\n```java\r\n@Overridepublic String save(Question question) {    SqlSession sqlSession = null;    try{        //1.获取SqlSession        sqlSession = MapperFactory.getSqlSession();        //2.获取Dao        QuestionDao questionDao = MapperFactory.getMapper(sqlSession,QuestionDao.class);        //id使用UUID的生成策略来获取        String id = UUID.randomUUID().toString();        question.setId(id);        //设置新创建的题目默认的审核状态为未审核（0）        question.setReviewStatus("0");        question.setCreateTime(new Date());        //设置当前存储的图片名称为id值        question.setPicture(id);        //3.调用Dao层操作        questionDao.save(question);        //4.提交事务        TransactionUtil.commit(sqlSession);        return id;    }catch (Exception e){        TransactionUtil.rollback(sqlSession);        throw new RuntimeException(e);        //记录日志    }finally {        try {            TransactionUtil.close(sqlSession);        }catch (Exception e){            e.printStackTrace();        }    }}\r\n```\r\n\r\n（3）在servlet中的`save`方法中接收图片名称\r\n\r\n```java\r\nprivate void save(HttpServletRequest request,HttpServletResponse response) throws Exception {    //1.确认该操作是否支持文件上传操作，enctype="multipart/form-data"    if(ServletFileUpload.isMultipartContent(request)){        //2.创建磁盘工厂对象        DiskFileItemFactory factory = new DiskFileItemFactory();        //3.Servlet文件上传核心对象        ServletFileUpload fileUpload = new ServletFileUpload(factory);        //4.从request中读取数据        List<FileItem> fileItems = fileUpload.parseRequest(request);        // --处理form表单提交过来的普通数据        //将数据获取到，封装成一个对象        Question question = BeanUtil.fillBean(fileItems,Question.class);        //调用业务层接口save        String picture = questionService.save(question);        // --处理form表单提交过来的文件数据        for(FileItem item : fileItems){            //5.当前表单是否是文件表单            if(!item.isFormField()){                //6.从临时存储文件的地方将内容写入到指定位置                item.write(new File(this.getServletContext().getRealPath("upload"),picture));            }        }    }    //跳转回到页面list    response.sendRedirect(request.getContextPath()+"/store/question?operation=list");}\r\n```\r\n\r\n\r\n\r\n### 4.5 修改题目时加入文件上传\r\n\r\n修改之前需要先将图片展示出来\r\n\r\n（1）在`question`模块的`update.jsp`页面中添加图片的展示，同时把修改时上传图片的表单项添加进去，以及表单也要配套修改\r\n\r\n```jsp\r\n<form id="editForm" action="${ctx}/store/question?operation=edit" method="post" enctype="multipart/form-data">\t\t\x3c!--其他省略--\x3e               <div class="col-md-2 title">题干图片</div>            <div class="col-md-10 data ">                <input type="file" class="form-control" placeholder="题干图片" name="picture" value="${question.picture}">            </div>            <div class="col-md-2 title">题干图片</div>            <div class="col-md-10 data ">                <img src="${ctx}/upload/${question.picture}"/>            </div>           </form>\r\n```\r\n\r\n（2）修改后台的servlet，找到`edit`方法进行修改\r\n\r\n```java\r\n@Overrideprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    String operation = request.getParameter("operation");    if("list".equals(operation)){        this.list(request,response);    }else if("toAdd".equals(operation)){        this.toAdd(request,response);    }else if("save".equals(operation)){        try {            this.save(request, response);        } catch (Exception e) {            e.printStackTrace();        }    }else if("toEdit".equals(operation)){        this.toEdit(request,response);    }else if("edit".equals(operation)){        try {            this.edit(request,response);        } catch (Exception e) {            e.printStackTrace();        }    }else if("delete".equals(operation)){        this.delete(request,response);    }else if("toTestUpload".equals(operation)){        this.toTestUpload(request,response);    }else if("testUpload".equals(operation)){        try {            this.testUpload(request,response);        } catch (Exception e) {            e.printStackTrace();        }    }}private void edit(HttpServletRequest request, HttpServletResponse response) throws Exception {    //1.确认该操作是否支持文件上传操作，enctype="multipart/form-data"    if(ServletFileUpload.isMultipartContent(request)){        //2.创建磁盘工厂对象        DiskFileItemFactory factory = new DiskFileItemFactory();        //3.Servlet文件上传核心对象        ServletFileUpload fileUpload = new ServletFileUpload(factory);        //4.从request中读取数据        List<FileItem> fileItems = fileUpload.parseRequest(request);        // --处理form表单提交过来的普通数据        //将数据获取到，封装成一个对象        Question question = BeanUtil.fillBean(fileItems,Question.class);        //调用业务层接口save        questionService.update(question);        // --处理form表单提交过来的文件数据        for(FileItem item : fileItems){            //5.当前表单是否是文件表单            if(!item.isFormField()){                //6.从临时存储文件的地方将内容写入到指定位置                item.write(new File(this.getServletContext().getRealPath("upload"),question.getId()));            }        }    }    //跳转回到页面list    response.sendRedirect(request.getContextPath()+"/store/question?operation=list");}\r\n```\r\n\r\n（3）业务层实现类的`update`方法在进行数据修改时，图片名称不需要修改，这个我们在持久层的update操作时去掉对图片的更改，我们改一下对应的映射配置文件（这步操作之前已完成）如下\r\n\r\n```xml\r\n\x3c!--配置全字段更新，当提供的数据为null时，数据库数据会被更新为null--\x3e<update id="update" parameterType="com.itheima.domain.store.Question">    update    st_question    set    company_id = #{companyId,jdbcType=VARCHAR},    catalog_id = #{catalogId,jdbcType=VARCHAR},    remark = #{remark,jdbcType=VARCHAR},    subject = #{subject,jdbcType=VARCHAR},    analysis = #{analysis,jdbcType=VARCHAR},    difficulty = #{difficulty,jdbcType=VARCHAR},    is_classic = #{isClassic,jdbcType=VARCHAR},    state = #{state,jdbcType=VARCHAR}    where    id = #{id,jdbcType=VARCHAR}</update>\r\n```\r\n\r\n\r\n\r\n### 4.6 兼容图片上传可选操作与显示问题\r\n\r\n**问题**：\r\n\r\n如果在新增的时候没有选择上传图片，会导致在修改的时候页面上展示不出图片，如下图所示\r\n\r\n![](web综合案例_day02.assets/8.png)\r\n\r\n**产生问题的原因：**\r\n\r\n新增的时候虽然没有上传图片，但是由于我们保存数据的时候默认是将数据的id作为图片的名称，所以在展示的时候会去找这个名称的图片，但是我们又没上传因此会找到不到\r\n\r\n**改进方法：**\r\n\r\n在新增时做一个判断，如果上传了图片再去保存图片的名称，没有上传则不保存图片的名称\r\n\r\n（1）在servlet的`add`方法中去判断当前是否上传文件，可以用一个布尔值标记来表明是否有文件上传，同时在业务层执行保存操作时可以把这个是否有图片的标记传递过去\r\n\r\n```java\r\nprivate void save(HttpServletRequest request,HttpServletResponse response) throws Exception {    //1.确认该操作是否支持文件上传操作，enctype="multipart/form-data"    if(ServletFileUpload.isMultipartContent(request)){        //2.创建磁盘工厂对象        DiskFileItemFactory factory = new DiskFileItemFactory();        //3.Servlet文件上传核心对象        ServletFileUpload fileUpload = new ServletFileUpload(factory);        //4.从request中读取数据        List<FileItem> fileItems = fileUpload.parseRequest(request);        //创建一个标记位,标记当前时候有上传文件的操作        boolean flag = false;        for(FileItem item :fileItems){            if(StringUtils.isNotBlank(item.getName())){                flag = true;                break;            }        }        // --处理form表单提交过来的普通数据        //将数据获取到，封装成一个对象        Question question = BeanUtil.fillBean(fileItems,Question.class);        //调用业务层接口save        String picture = questionService.save(question , flag);        // --处理form表单提交过来的文件数据        for(FileItem item : fileItems){            //5.当前表单是否是文件表单            if(!item.isFormField()){                //6.从临时存储文件的地方将内容写入到指定位置                item.write(new File(this.getServletContext().getRealPath("upload"),picture));            }        }    }    //跳转回到页面list    response.sendRedirect(request.getContextPath()+"/store/question?operation=list");}\r\n```\r\n\r\n（2）修改业务层接口方法`save`，添加参数\r\n\r\n```java\r\n/**     * 添加     * @param question     * @param flag 是否有上传文件的操作     * @return 保存的图片名称     */String save(Question question,boolean flag);\r\n```\r\n\r\n（3）修改对应的接口实现类：\r\n\r\n```java\r\n@Overridepublic String save(Question question,boolean flag) {    SqlSession sqlSession = null;    try{        //1.获取SqlSession        sqlSession = MapperFactory.getSqlSession();        //2.获取Dao        QuestionDao questionDao = MapperFactory.getMapper(sqlSession,QuestionDao.class);        //id使用UUID的生成策略来获取        String id = UUID.randomUUID().toString();        question.setId(id);        //设置新创建的题目默认的审核状态为未审核（0）        question.setReviewStatus("0");        question.setCreateTime(new Date());        //检测到前端上传文件了，记录文件名，否则不记录        if(flag) {            //设置当前存储的图片名称为id值            question.setPicture(id);        }        //3.调用Dao层操作        questionDao.save(question);        //4.提交事务        TransactionUtil.commit(sqlSession);        return id;    }catch (Exception e){        TransactionUtil.rollback(sqlSession);        throw new RuntimeException(e);        //记录日志    }finally {        try {            TransactionUtil.close(sqlSession);        }catch (Exception e){            e.printStackTrace();        }    }}\r\n```\r\n\r\n（4）在修改时，如果没有图片则不显示图片，有图片信息的时候再显示，我们可以使用`<c:if>`进行判断\r\n\r\n```jsp\r\n<div class="col-md-2 title">题干图片</div><div class="col-md-10 data ">    <input type="file" class="form-control" placeholder="题干图片" name="picture" value="${question.picture}"></div><c:if test="${question.picture.length() > 0}">    <div class="col-md-2 title">题干图片</div>    <div class="col-md-10 data ">        <img src="${ctx}/upload/${question.picture}"/>    </div></c:if>\r\n```\r\n\r\n（5）页面修改完成后，在进行真正的修改操作时，我们同样需要进行判断，如果上传了图片则进行修改，否则不进行修改。\r\n\r\n找到后台的servlet的`edit`方法，做出如下修改\r\n\r\n```java\r\nprivate void edit(HttpServletRequest request, HttpServletResponse response) throws Exception {    //1.确认该操作是否支持文件上传操作，enctype="multipart/form-data"    if(ServletFileUpload.isMultipartContent(request)){        //2.创建磁盘工厂对象        DiskFileItemFactory factory = new DiskFileItemFactory();        //3.Servlet文件上传核心对象        ServletFileUpload fileUpload = new ServletFileUpload(factory);        //4.从request中读取数据        List<FileItem> fileItems = fileUpload.parseRequest(request);        //创建一个标记位,标记当前时候有上传文件的操作        boolean flag = false;        for(FileItem item :fileItems){            if(StringUtils.isNotBlank(item.getName())){                flag = true;                break;            }        }        // --处理form表单提交过来的普通数据        //将数据获取到，封装成一个对象        Question question = BeanUtil.fillBean(fileItems,Question.class);        //调用业务层接口save        questionService.update(question , flag);        // --处理form表单提交过来的文件数据        for(FileItem item : fileItems){            //5.当前表单是否是文件表单            if(!item.isFormField()){                //6.从临时存储文件的地方将内容写入到指定位置                item.write(new File(this.getServletContext().getRealPath("upload"),question.getId()));            }        }    }    //跳转回到页面list    response.sendRedirect(request.getContextPath()+"/store/question?operation=list");}\r\n```\r\n\r\n（6）同样需要修改业务层接口，在`update`方法上添加是否修改图片的参数\r\n\r\n```java\r\n/**     * 修改     * @param question     * @param flag 是否有上传文件的操作     * @return     */void update(Question question,boolean flag);\r\n```\r\n\r\n（7）在业务层实现类中修改该方法\r\n\r\n```java\r\n@Overridepublic void update(Question question, boolean flag) {    SqlSession sqlSession = null;    try{        //1.获取SqlSession        sqlSession = MapperFactory.getSqlSession();        //2.获取Dao        QuestionDao questionDao = MapperFactory.getMapper(sqlSession,QuestionDao.class);        //检测到前端上传文件了，记录文件名，否则不记录        if(flag) {            //设置当前存储的图片名称为id值            question.setPicture(question.getId());        }        //3.调用Dao层操作        questionDao.update(question);        //4.提交事务        TransactionUtil.commit(sqlSession);    }catch (Exception e){        TransactionUtil.rollback(sqlSession);        throw new RuntimeException(e);        //记录日志    }finally {        try {            TransactionUtil.close(sqlSession);        }catch (Exception e){            e.printStackTrace();        }    }}\r\n```\r\n\r\n（8）在持久层dao真正进行update操作的时候我们把对图片的更新添加进去，我们去修改对应的映射配置文件即可\r\n\r\n```xml\r\n\x3c!--配置全字段更新，当提供的数据为null时，数据库数据会被更新为null--\x3e<update id="update" parameterType="com.itheima.domain.store.Question">    update    st_question    set    company_id = #{companyId,jdbcType=VARCHAR},    catalog_id = #{catalogId,jdbcType=VARCHAR},    remark = #{remark,jdbcType=VARCHAR},    subject = #{subject,jdbcType=VARCHAR},    analysis = #{analysis,jdbcType=VARCHAR},    difficulty = #{difficulty,jdbcType=VARCHAR},    is_classic = #{isClassic,jdbcType=VARCHAR},    picture = #{picture,jdbcType=VARCHAR},    state = #{state,jdbcType=VARCHAR}    where    id = #{id,jdbcType=VARCHAR}</update>\r\n```\r\n\r\n## 5. 题目选项模块\r\n\r\n### 5.1 列表页制作\r\n\r\n（1）创建题目选项实体：com.itheima.domain.store.QuestionItem\r\n\r\n```java\r\npublic class QuestionItem {    private String id;          \t//ID    private String questionId;  //题目ID    private String content;     //选项内容    private String picture;      //选项图片    private String isRight;    //是否正确答案    @Override    public String toString() {        return "QuestionItem{" +                "id=\'" + id + \'\\\'\' +                ", questionId=\'" + questionId + \'\\\'\' +                ", content=\'" + content + \'\\\'\' +                ", picture=\'" + picture + \'\\\'\' +                ", isRight=\'" + isRight + \'\\\'\' +                \'}\';    }\t// getter/setter方法略}\r\n```\r\n\r\n（2）创建dao接口：com.itheima.dao.store.QuestionItemDao\r\n\r\n```java\r\npublic interface QuestionItemDao { \tint save(QuestionItem questionItem);    int delete(QuestionItem questionItem);    int update(QuestionItem questionItem);    QuestionItem findById(String id);    List<QuestionItem> findAll();}\r\n```\r\n\r\n（3）添加对应的映射配置文件，之前已导入过了\r\n\r\n（4）创建业务层接口：com.itheima.service.store.QuestionItemService\r\n\r\n```java\r\npublic interface QuestionItemService {    /**     * 添加     * @param questionItem     * @return     */    void save(QuestionItem questionItem);    /**     * 删除     * @param questionItem     * @return     */    void delete(QuestionItem questionItem);    /**     * 修改     * @param questionItem     * @return     */    void update(QuestionItem questionItem);    /**     * 查询单个     * @param id 查询的条件（id）     * @return 查询的结果，单个对象     */    QuestionItem findById(String id);    /**     * 查询全部的数据     * @return 全部数据的列表对象     */    List<QuestionItem> findAll();    /**     * 分页查询数据     * @param page 页码     * @param size 每页显示的数据总量     * @return     */    PageInfo findAll(int page, int size);}\r\n```\r\n\r\n（5）创建业务层实现类：com.itheima.service.store.impl.QuestionItemServiceImpl\r\n\r\n我们基于`CompanyServiceImpl`拷贝然后改造\r\n\r\n```java\r\npublic class QuestionItemServiceImpl implements QuestionItemService {    @Override    public void save(QuestionItem questionItem) {        SqlSession sqlSession = null;        try{            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            QuestionItemDao questionItemDao = MapperFactory.getMapper(sqlSession,QuestionItemDao.class);            //id使用UUID的生成策略来获取            String id = UUID.randomUUID().toString();            questionItem.setId(id);            //3.调用Dao层操作            questionItemDao.save(questionItem);            //4.提交事务            TransactionUtil.commit(sqlSession);        }catch (Exception e){            TransactionUtil.rollback(sqlSession);            throw new RuntimeException(e);            //记录日志        }finally {            try {                TransactionUtil.close(sqlSession);            }catch (Exception e){                e.printStackTrace();            }        }    }    @Override    public void delete(QuestionItem questionItem) {        SqlSession sqlSession = null;        try{            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            QuestionItemDao questionItemDao = MapperFactory.getMapper(sqlSession,QuestionItemDao.class);            //3.调用Dao层操作            questionItemDao.delete(questionItem);            //4.提交事务            TransactionUtil.commit(sqlSession);        }catch (Exception e){            TransactionUtil.rollback(sqlSession);            throw new RuntimeException(e);            //记录日志        }finally {            try {                TransactionUtil.close(sqlSession);            }catch (Exception e){                e.printStackTrace();            }        }    }    @Override    public void update(QuestionItem questionItem) {        SqlSession sqlSession = null;        try{            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            QuestionItemDao questionItemDao = MapperFactory.getMapper(sqlSession,QuestionItemDao.class);            //3.调用Dao层操作            questionItemDao.update(questionItem);            //4.提交事务            TransactionUtil.commit(sqlSession);        }catch (Exception e){            TransactionUtil.rollback(sqlSession);            throw new RuntimeException(e);            //记录日志        }finally {            try {                TransactionUtil.close(sqlSession);            }catch (Exception e){                e.printStackTrace();            }        }    }    @Override    public QuestionItem findById(String id) {        SqlSession sqlSession = null;        try{            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            QuestionItemDao questionItemDao = MapperFactory.getMapper(sqlSession,QuestionItemDao.class);            //3.调用Dao层操作            return questionItemDao.findById(id);        }catch (Exception e){            throw new RuntimeException(e);            //记录日志        }finally {            try {                TransactionUtil.close(sqlSession);            }catch (Exception e){                e.printStackTrace();            }        }    }    @Override    public List<QuestionItem> findAll() {        SqlSession sqlSession = null;        try{            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            QuestionItemDao questionItemDao = MapperFactory.getMapper(sqlSession,QuestionItemDao.class);            //3.调用Dao层操作            return questionItemDao.findAll();        }catch (Exception e){            throw new RuntimeException(e);            //记录日志        }finally {            try {                TransactionUtil.close(sqlSession);            }catch (Exception e){                e.printStackTrace();            }        }    }    @Override    public PageInfo findAll(int page, int size) {        SqlSession sqlSession = null;        try{            //1.获取SqlSession            sqlSession = MapperFactory.getSqlSession();            //2.获取Dao            QuestionItemDao questionItemDao = MapperFactory.getMapper(sqlSession,QuestionItemDao.class);            //3.调用Dao层操作            PageHelper.startPage(page,size);            List<QuestionItem> all = questionItemDao.findAll();            PageInfo pageInfo = new PageInfo(all);            return pageInfo;        }catch (Exception e){            throw new RuntimeException(e);            //记录日志        }finally {            try {                TransactionUtil.close(sqlSession);            }catch (Exception e){                e.printStackTrace();            }        }    }}\r\n```\r\n\r\n（6）创建servlet：com.itheima.web.controller.store.QuestionItemServlet\r\n\r\n基于`CompanyServlet`拷贝进行改造（修改完成后有些方法其实没有用，我们暂时不用去修改，后续我们会逐级进行修改）\r\n\r\n```java\r\n@WebServlet("/store/questionItem")public class QuestionItemServlet extends BaseServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        String operation = request.getParameter("operation");        if("list".equals(operation)){            this.list(request,response);        }else if("toAdd".equals(operation)){            this.toAdd(request,response);        }else if("save".equals(operation)){            this.save(request, response);        }else if("toEdit".equals(operation)){            this.toEdit(request,response);        }else if("edit".equals(operation)){            this.edit(request,response);        }else if("delete".equals(operation)){            this.delete(request,response);        }    }    private void list(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {        //进入列表页        //获取数据        int page = 1;        int size = 5;        if(StringUtils.isNotBlank(request.getParameter("page"))){            page = Integer.parseInt(request.getParameter("page"));        }        if(StringUtils.isNotBlank(request.getParameter("size"))){            size = Integer.parseInt(request.getParameter("size"));        }        PageInfo all = questionItemService.findAll(page, size);        //将数据保存到指定的位置        request.setAttribute("page",all);        //跳转页面        request.getRequestDispatcher("/WEB-INF/pages/store/questionItem/list.jsp").forward(request,response);    }    private void toAdd(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {        //跳转页面        request.getRequestDispatcher("/WEB-INF/pages/store/questionItem/add.jsp").forward(request,response);    }    private void save(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {        //将数据获取到，封装成一个对象        QuestionItem questionItem = BeanUtil.fillBean(request,QuestionItem.class,"yyyy-MM-dd");        //调用业务层接口save        questionItemService.save(questionItem);        //跳转回到页面list        response.sendRedirect(request.getContextPath()+"/store/questionItem?operation=list");    }    private void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //查询要修改的数据findById        String id = request.getParameter("id");        QuestionItem questionItem = questionItemService.findById(id);        //将数据加载到指定区域，供页面获取        request.setAttribute("questionItem",questionItem);        //跳转页面        request.getRequestDispatcher("/WEB-INF/pages/store/questionItem/update.jsp").forward(request,response);    }    private void edit(HttpServletRequest request, HttpServletResponse response) throws IOException {        //将数据获取到，封装成一个对象        QuestionItem questionItem = BeanUtil.fillBean(request,QuestionItem.class,"yyyy-MM-dd");        //调用业务层接口save        questionItemService.update(questionItem);        //跳转回到页面list        response.sendRedirect(request.getContextPath()+"/store/questionItem?operation=list");    }    private void delete(HttpServletRequest request, HttpServletResponse response) throws IOException {        //将数据获取到，封装成一个对象        QuestionItem questionItem = BeanUtil.fillBean(request,QuestionItem.class);        //调用业务层接口save        questionItemService.delete(questionItem);        //跳转回到页面list        response.sendRedirect(request.getContextPath()+"/store/questionItem?operation=list");    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request,response);    }\r\n```\r\n\r\n（7）在BaseServlet中添加`QuestionItemService`\r\n\r\n```java\r\npublic class BaseServlet extends HttpServlet {    protected CompanyService companyService;    protected DeptService deptService;    protected UserService userService;    protected CourseService courseService;    protected CatalogService catalogService;    protected QuestionService questionService;    protected QuestionItemService questionItemService;    @Override    public void init() throws ServletException {        companyService = new CompanyServiceImpl();        deptService = new DeptServiceImpl();        userService = new UserServiceImpl();        courseService = new CourseServiceImpl();        catalogService = new CatalogServiceImpl();        questionService = new QuestionServiceImpl();        questionItemService = new QuestionItemServiceImpl();    }}\r\n```\r\n\r\n（8）创建页面存放的目录`/WEB-INF/pages/store/questionItem`，从今日课程资料中的`模块页面\\questionItem`下复制所有的页面到刚创建好的目录中\r\n\r\n（9）在`question`模块的`list.jsp`页面中添加题目选项列表页的入口，因为题目选项是针对某个具体的题目的，在每条列表数据的操作中添加一个配置选项的按钮\r\n\r\n```jsp\r\n<button type="button" class="btn bg-olive btn-xs" onclick=\'location.href="${ctx}/store/questionItem?operation=list&questionId=${o.id}"\'>配置选项</button>\r\n```\r\n\r\n同时在`questionItem`模块中的`list.jsp`页面中我们需要删除一些页面元素，分页，新建按钮，删除按钮，只留下刷新按钮\r\n\r\n（10）在后台servlet的list方法中接收题目的id，我们要查询的列表应该是该题目下的所有选项列表\r\n\r\n```java\r\nprivate void list(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {    String questionId = request.getParameter("questionId");    PageInfo all = questionItemService.findAll(questionId,1, 100);    //将数据保存到指定的位置    request.setAttribute("page",all);    //跳转页面    request.getRequestDispatcher("/WEB-INF/pages/store/questionItem/list.jsp").forward(request,response);}\r\n```\r\n\r\n（11）修改业务层接口方法，添加参数，注意是改带分页的那个方法\r\n\r\n```java\r\n/**     * 分页查询数据     * @param questionId 题目对应的id     * @param page 页码     * @param size 每页显示的数据总量     * @return     */PageInfo findAll(String questionId,int page, int size);\r\n```\r\n\r\n（12）在业务层实现类中修改对应的方法\r\n\r\n```java\r\n@Overridepublic PageInfo findAll(String questionId,int page, int size) {    SqlSession sqlSession = null;    try{        //1.获取SqlSession        sqlSession = MapperFactory.getSqlSession();        //2.获取Dao        QuestionItemDao questionItemDao = MapperFactory.getMapper(sqlSession,QuestionItemDao.class);        //3.调用Dao层操作        PageHelper.startPage(page,size);        List<QuestionItem> all = questionItemDao.findAll(questionId);        PageInfo pageInfo = new PageInfo(all);        return pageInfo;    }catch (Exception e){        throw new RuntimeException(e);        //记录日志    }finally {        try {            TransactionUtil.close(sqlSession);        }catch (Exception e){            e.printStackTrace();        }    }}\r\n```\r\n\r\n（13）修改持久层接口方法`findAll`，添加查询参数\r\n\r\n```java\r\n/**     * 根据题目id查询所有选项      * @param questionId     * @return     */List<QuestionItem> findAll(String questionId);\r\n```\r\n\r\n（14）修改dao映射配置文件，添加条件\r\n\r\n```xml\r\n\x3c!--配置查询所有，带条件--\x3e<select id="findAll" parameterType="java.lang.String" resultMap="BaseResultMap">    select    <include refid="Base_Column_List"/>    from st_question_item    where question_id = #{questionId,jdbcType=VARCHAR}</select>\r\n```\r\n\r\n（15）对于业务层原有的不带任何参数的`findAll`方法，我们可以去掉，删除接口和实现类中的无参的`findAll`方法\r\n\r\n（16）启动项目测试效果 \r\n\r\n### 5.2 添加功能制作\r\n\r\n（1）在后台servlet的`doGet`方法中去掉一些逻辑，`toAdd`的逻辑判断和对应的`toAdd`方法需要删除，然后直接查看`save`方法\r\n\r\n（2）`save`方法最后需要去跳转页面，我们让它直接调用`list`方法，该方法最后就是跳转页面的\r\n\r\n```java\r\nprivate void save(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {    //将数据获取到，封装成一个对象    QuestionItem questionItem = BeanUtil.fillBean(request,QuestionItem.class,"yyyy-MM-dd");    //调用业务层接口save    questionItemService.save(questionItem);    //跳转回到页面list    list(request,response);}\r\n```\r\n\r\n（3）找到`questionItem`模块下的`list.jsp`页面，在`<form id="editForm">`该表单里面添加一个隐藏域，接收题目的id\r\n\r\n```jsp\r\n<input type="hidden" name="questionId" value="${questionId}">\r\n```\r\n\r\n同时要保证这个值能够在该页面中获取到，我们需要在跳转到该页面的后台`list`方法中向`request`域中存入该值即可，修改后台servlet的`list`方法\r\n\r\n```java\r\nprivate void list(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {    String questionId = request.getParameter("questionId");    //进入list页时添加对应的问题id，为添加操作使用    request.setAttribute("questionId",questionId);    PageInfo all = questionItemService.findAll(questionId,1, 100);    //将数据保存到指定的位置    request.setAttribute("page",all);    //跳转页面    request.getRequestDispatcher("/WEB-INF/pages/store/questionItem/list.jsp").forward(request,response);}\r\n```\r\n\r\n（4）启动项目进行测试\r\n\r\n### 5.3 删除功能制作\r\n\r\n（1）删除首先要解决的是删除完成后端页面跳转问题，需要修改后台servlet的`delete`方法，删除完成后调用`list`方法进行跳转\r\n\r\n```java\r\nprivate void delete(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {    //将数据获取到，封装成一个对象    QuestionItem questionItem = BeanUtil.fillBean(request,QuestionItem.class);    //调用业务层接口save    questionItemService.delete(questionItem);    //跳转回到页面list    list(request,response);}\r\n```\r\n\r\n（2）产生的新的问题是，删除后跳转回`list.jsp`页面其他的数据都不见了，分析得到的原因是后台servlet执行完成删除调用`list`方法时，需要去获取题目的id，来查询该题目下的所有选项，这个地方缺少了题目的id，因此解决方案是在页面发送删除请求时需要将题目id传递给后台，因此我们需要去修改页面删除的js代码\r\n\r\n```javascript\r\n<script type="text/javascript">    function deleteById(id) {    var questionId = \'${questionId}\';    if(confirm("你确认要删除此条记录吗？")) {        window.location.href="${ctx}/store/questionItem?operation=delete&questionId=${questionId}&id="+id;    }}<\/script>\r\n```\r\n\r\n（3）启动项目，进行测试\r\n\r\n### 5.4 修改功能制作\r\n\r\n（1）修改后台servlet的`toEdit`方法，查询完数据后跳转页面仍然是调用`list`方法完成跳转\r\n\r\n```java\r\nprivate void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    //查询要修改的数据findById    String id = request.getParameter("id");    QuestionItem questionItem = questionItemService.findById(id);    //将数据加载到指定区域，供页面获取    request.setAttribute("questionItem",questionItem);    //跳转回到页面list    list(request,response);}\r\n```\r\n\r\n（2）出现的问题是，点完编辑后跳转到页面上所有数据都无法显示，包括之前的所有选项数据，我们需要先来解决之前所有的选项数据的显示问题，原因很简单，还是因为在点击编辑的时候没有传递题目的id到后台，后台在通过list方法进行跳转的时候没有题目的id就无法查询题目下的选项\r\n\r\n在`questionItem/list.jsp`页面上修改编辑按钮，添加题目id的参数\r\n\r\n```jsp\r\n<button type="button" class="btn bg-olive btn-xs" onclick=\'location.href="${ctx}/store/questionItem?operation=toEdit&questionId=${questionId}&id=${o.id}"\'>编辑</button>\r\n```\r\n\r\n（3）然后在解决点完编辑后对应编辑的数据无法展示的问题，需要调整`questionItem/list.jsp`页面表单，添加数据的展示\r\n\r\n```jsp\r\n<form id="editForm" action="${ctx}/store/questionItem?operation=saveOrUpdate" method="post">    <input type="hidden" name="questionId" value="${questionId}">    <input type="hidden" name="id" value="${questionItem.id}">    <div class="row data-type" style="margin: 0px">        <div class="col-md-2 title">选项内容</div>        <div class="col-md-4 data">            <input type="text" class="form-control" placeholder="选项内容" name="content" value="${questionItem.content}">        </div>        <div class="col-md-2 title">选项图片</div>        <div class="col-md-4 data">            <input type="file" class="form-control" placeholder="请选择" name="picture" >        </div>        <%--<div class="col-md-2 title">是否正确答案</div>                    <div class="col-md-4 data">                        <select class="form-control" name="isRight">                            <option value="">请选择</option>                            <option value="1">正确答案</option>                            <option value="0">错误选项</option>                        </select>                    </div>--%>        <div class="col-md-2 title">是否正确答案</div>        <div class="col-md-4 data">            <select class="form-control" name="isRight">                <option value="">请选择</option>                <option value="1" ${questionItem.isRight eq "1" ? "selected" : ""}>正确答案</option>                <option value="0" ${questionItem.isRight eq "0" ? "selected" : ""}>错误选项</option>            </select>        </div>    </div></form>\r\n```\r\n\r\n（4）启动后测试，发现了新的问题，我们要提交编辑的数据，但结果却变成了保存，问题的原因是什么呢？\r\n\r\n经过分析发现是因为表单的提交路径一直写的就是保存的路径，如何解决呢？\r\n\r\n通过后台传递一个操作类型的变量值到前端，前端在表单的`action`里面使用该变量值，通过这个变量我们来控制是新增还是编辑\r\n\r\n在后台的`list`和`toEdit`方法中来操作该变量值\r\n\r\n```java\r\nprivate void list2(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {    String questionId = request.getParameter("questionId");    //进入list页时添加对应的问题id，为添加操作使用    request.setAttribute("questionId",questionId);    //获取数据    PageInfo all = questionItemService.findAll(questionId, 1, 100);    //将数据保存到指定的位置    request.setAttribute("page",all);    if(request.getAttribute("operation") == null) {        //保存一个操作的类型，传递到前端save        request.setAttribute("operation", "save");    }    //跳转页面    request.getRequestDispatcher("/WEB-INF/pages/store/questionItem/list.jsp").forward(request,response);}private void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    //查询要修改的数据findById    String id = request.getParameter("id");    QuestionItem questionItem = questionItemService.findById(id);    //将数据加载到指定区域，供页面获取    request.setAttribute("questionItem",questionItem);    //保存一个操作的类型，传递到前端save    request.setAttribute("operation","edit");    //跳转回到页面list    list(request,response);}\r\n```\r\n\r\n然后需要在页面的表单`action`属性上接收该值\r\n\r\n```jsp\r\n<form id="editForm" action="${ctx}/store/questionItem?operation=${operation}" method="post">\r\n```\r\n\r\n（5）启动项目进行测试\r\n\r\n（6）测试发现编辑后，提交编辑的数据完成编辑哦呼跳转回页面，页面所有的数据又消失了，回到后台servlet查看`edit`方法，发现是页面跳转的问题\r\n\r\n```java\r\nprivate void edit(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {    //将数据获取到，封装成一个对象    QuestionItem questionItem = BeanUtil.fillBean(request,QuestionItem.class,"yyyy-MM-dd");    //调用业务层接口save    questionItemService.update(questionItem);    //跳转回到页面list    list(request,response);}\r\n```\r\n\r\n（7）数据显示的问题解决后我们发现数据并没有真正的修改完成，分析原因发现是因为编辑后提交编辑的数据进行修改，但是没有提交问题选项的id值，我们需要在表单中接收问题选项的id值，能够让它在编辑的时候被提交到后台\r\n\r\n```jsp\r\n<input type="hidden" name="id" value="${questionItem.id}">\r\n```\r\n\r\n（8）启动项目进行测试\r\n\r\n### 5.5 添加修改功能合并\r\n\r\n（1）把`questionItem/list.jsp`进行备份，`questionItem/list2.jsp`\r\n\r\n（2）将后台`list,toEdit`方法进行备份，分别叫做`list2,toEdit2`，与前台的`list2.jsp`配套，\r\n\r\n（3）在后台servlet中封装一个`saveOrUpdate`方法，同时需要修改`doGet`方法\r\n\r\n```java\r\n@Overrideprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    String operation = request.getParameter("operation");    if("list".equals(operation)){        this.list(request,response);    }else if("save".equals(operation)){        this.save(request, response);    }else if("toEdit".equals(operation)){        this.toEdit(request,response);    }else if("edit".equals(operation)){        this.edit(request,response);    }else if("delete".equals(operation)){        this.delete(request,response);    }else if("saveOrUpdate".equals(operation)){        this.saveOrUpdate(request,response);    }}private void saveOrUpdate(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {    //将数据获取到，封装成一个对象    QuestionItem questionItem = BeanUtil.fillBean(request,QuestionItem.class,"yyyy-MM-dd");    //如果页面传递了当前数据的id，则为修改业务，否则为添加业务    if(StringUtils.isNotBlank(questionItem.getId())){        questionItemService.update(questionItem);    }else {        questionItemService.save(questionItem);    }    //跳转回到页面list    list(request,response);}\r\n```\r\n\r\n（4）修改原始的`list,toEdit`方法，不需要之前添加操作标识的变量了\r\n\r\n```java\r\nprivate void list(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {    String questionId = request.getParameter("questionId");    //进入list页时添加对应的问题id，为添加操作使用    request.setAttribute("questionId",questionId);    //获取数据    PageInfo all = questionItemService.findAll(questionId, 1, 100);    //将数据保存到指定的位置    request.setAttribute("page",all);    //跳转页面    request.getRequestDispatcher("/WEB-INF/pages/store/questionItem/list.jsp").forward(request,response);}private void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    //查询要修改的数据findById    String id = request.getParameter("id");    QuestionItem questionItem = questionItemService.findById(id);    //将数据加载到指定区域，供页面获取    request.setAttribute("questionItem",questionItem);    //跳转回到页面list    list(request,response);}\r\n```\r\n\r\n（5）修改`list.jsp`页面表单的`action`属性\r\n\r\n```java\r\n <form id="editForm" action="${ctx}/store/questionItem?operation=saveOrUpdate" method="post">\r\n```\r\n\r\n（6）启动项目测试\r\n\r\n### 5.6 删除功能相关问题及解决方案\r\n\r\n题目选项功能完成后，伴随而来的是题目的有些功能出现了问题，比如：删除题目，题目数据删除了，那该题目下的选项数据呢？目前是没有删除，\r\n\r\n因此我们要解决的是：删除题目数据的时候伴随着删除该题目下的选项数据\r\n\r\n**解决方案**\r\n\r\n**解决方案一:触发器**\r\n\r\n◆注意使用触发器实现是将业务绑定到了数据库端,在进行系统设计时要确认方案\r\n\r\n**解决方案二:业务层删除操作中分别调用两个模块的删除功能**\r\n\r\n◆注意删除主使用按id删除,删除从使用按关联id删除\r\n\r\n◆注意删除的顺序,先删从,后删主\r\n\r\n**解决方案三:存储过程**\r\n\r\n◆整套的数据层解决方案,没有单一功能使用的\r\n\r\n**解决方案四:依赖框架提供的级联删除功能**\r\n\r\n**解决方案五:定时维护/垃圾数据清理**'},5536:function(n,e,t){"use strict";t.r(e),e["default"]="### 书籍\n\n- **《Java8 In Action》**\n- **《写给大忙人看的Java SE 8》**\n\n上述书籍的PDF版本见 https://shimo.im/docs/CPB0PK05rP4CFmI2/ 中的 “Java 书籍推荐”。\n\n### 开源文档\n\n- **【译】Java 8 简明教程**：<https://github.com/wizardforcel/modern-java-zh>\n- **30 seconds of java8:**  <https://github.com/biezhi/30-seconds-of-java8>\n\n### 视频\n\n- **尚硅谷 Java 8 新特性**\n\n视频资源见： https://shimo.im/docs/CPB0PK05rP4CFmI2/ 。\n\n"},"59f7":function(n,e,t){"use strict";t.r(e),e["default"]='本文来自读者 [PR](https://github.com/Snailclimb/JavaGuide/pull/291)。\n\x3c!-- TOC --\x3e\n\n- [1 单机版消息中心](#1-%E5%8D%95%E6%9C%BA%E7%89%88%E6%B6%88%E6%81%AF%E4%B8%AD%E5%BF%83)\n- [2 分布式消息中心](#2-%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E4%B8%AD%E5%BF%83)\n  - [2.1 问题与解决](#21-%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3)\n    - [2.1.1 消息丢失的问题](#211-%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98)\n    - [2.1.2 同步落盘怎么才能快](#212-%E5%90%8C%E6%AD%A5%E8%90%BD%E7%9B%98%E6%80%8E%E4%B9%88%E6%89%8D%E8%83%BD%E5%BF%AB)\n    - [2.1.3 消息堆积的问题](#213-%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E7%9A%84%E9%97%AE%E9%A2%98)\n    - [2.1.4 定时消息的实现](#214-%E5%AE%9A%E6%97%B6%E6%B6%88%E6%81%AF%E7%9A%84%E5%AE%9E%E7%8E%B0)\n    - [2.1.5 顺序消息的实现](#215-%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF%E7%9A%84%E5%AE%9E%E7%8E%B0)\n    - [2.1.6 分布式消息的实现](#216-%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E7%9A%84%E5%AE%9E%E7%8E%B0)\n    - [2.1.7 消息的 push 实现](#217-%E6%B6%88%E6%81%AF%E7%9A%84-push-%E5%AE%9E%E7%8E%B0)\n    - [2.1.8 消息重复发送的避免](#218-%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E5%8F%91%E9%80%81%E7%9A%84%E9%81%BF%E5%85%8D)\n    - [2.1.9 广播消费与集群消费](#219-%E5%B9%BF%E6%92%AD%E6%B6%88%E8%B4%B9%E4%B8%8E%E9%9B%86%E7%BE%A4%E6%B6%88%E8%B4%B9)\n    - [2.1.10 RocketMQ 不使用 ZooKeeper 作为注册中心的原因，以及自制的 NameServer 优缺点？](#2110-rocketmq-%E4%B8%8D%E4%BD%BF%E7%94%A8-zookeeper-%E4%BD%9C%E4%B8%BA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%88%B6%E7%9A%84-nameserver-%E4%BC%98%E7%BC%BA%E7%82%B9)\n    - [2.1.11 其它](#2111-%E5%85%B6%E5%AE%83)\n- [3 参考](#3-%E5%8F%82%E8%80%83)\n\n\x3c!-- TOC --\x3e\n\n# 1 单机版消息中心\n\n一个消息中心，最基本的需要支持多生产者、多消费者，例如下：\n\n```java\nclass Scratch {\n\n    public static void main(String[] args) {\n        // 实际中会有 nameserver 服务来找到 broker 具体位置以及 broker 主从信息\n        Broker broker = new Broker();\n        Producer producer1 = new Producer();\n        producer1.connectBroker(broker);\n        Producer producer2 = new Producer();\n        producer2.connectBroker(broker);\n\n        Consumer consumer1 = new Consumer();\n        consumer1.connectBroker(broker);\n        Consumer consumer2 = new Consumer();\n        consumer2.connectBroker(broker);\n\n        for (int i = 0; i < 2; i++) {\n            producer1.asyncSendMsg("producer1 send msg" + i);\n            producer2.asyncSendMsg("producer2 send msg" + i);\n        }\n        System.out.println("broker has msg:" + broker.getAllMagByDisk());\n\n        for (int i = 0; i < 1; i++) {\n            System.out.println("consumer1 consume msg：" + consumer1.syncPullMsg());\n        }\n        for (int i = 0; i < 3; i++) {\n            System.out.println("consumer2 consume msg：" + consumer2.syncPullMsg());\n        }\n    }\n\n}\n\nclass Producer {\n\n    private Broker broker;\n\n    public void connectBroker(Broker broker) {\n        this.broker = broker;\n    }\n\n    public void asyncSendMsg(String msg) {\n        if (broker == null) {\n            throw new RuntimeException("please connect broker first");\n        }\n        new Thread(() -> {\n            broker.sendMsg(msg);\n        }).start();\n    }\n}\n\nclass Consumer {\n    private Broker broker;\n\n    public void connectBroker(Broker broker) {\n        this.broker = broker;\n    }\n\n    public String syncPullMsg() {\n        return broker.getMsg();\n    }\n\n}\n\nclass Broker {\n\n    // 对应 RocketMQ 中 MessageQueue，默认情况下 1 个 Topic 包含 4 个 MessageQueue\n    private LinkedBlockingQueue<String> messageQueue = new LinkedBlockingQueue(Integer.MAX_VALUE);\n\n    // 实际发送消息到 broker 服务器使用 Netty 发送\n    public void sendMsg(String msg) {\n        try {\n            messageQueue.put(msg);\n            // 实际会同步或异步落盘，异步落盘使用的定时任务定时扫描落盘\n        } catch (InterruptedException e) {\n\n        }\n    }\n\n    public String getMsg() {\n        try {\n            return messageQueue.take();\n        } catch (InterruptedException e) {\n\n        }\n        return null;\n    }\n\n    public String getAllMagByDisk() {\n        StringBuilder sb = new StringBuilder("\\n");\n        messageQueue.iterator().forEachRemaining((msg) -> {\n            sb.append(msg + "\\n");\n        });\n        return sb.toString();\n    }\n}\n```\n\n问题：  \n1. 没有实现真正执行消息存储落盘\n2. 没有实现 NameServer 去作为注册中心，定位服务\n3. 使用 LinkedBlockingQueue 作为消息队列，注意，参数是无限大，在真正 RocketMQ 也是如此是无限大，理论上不会出现对进来的数据进行抛弃，但是会有内存泄漏问题（阿里巴巴开发手册也因为这个问题，建议我们使用自制线程池）  \n4. 没有使用多个队列（即多个 LinkedBlockingQueue），RocketMQ 的顺序消息是通过生产者和消费者同时使用同一个 MessageQueue 来实现，但是如果我们只有一个 MessageQueue，那我们天然就支持顺序消息\n5. 没有使用 MappedByteBuffer 来实现文件映射从而使消息数据落盘非常的快（实际 RocketMQ 使用的是 FileChannel+DirectBuffer）\n\n# 2 分布式消息中心\n\n## 2.1 问题与解决\n\n### 2.1.1 消息丢失的问题\n\n1. 当你系统需要保证百分百消息不丢失，你可以使用生产者每发送一个消息，Broker 同步返回一个消息发送成功的反馈消息\n2. 即每发送一个消息，同步落盘后才返回生产者消息发送成功，这样只要生产者得到了消息发送生成的返回，事后除了硬盘损坏，都可以保证不会消息丢失\n3. 但是这同时引入了一个问题，同步落盘怎么才能快？\n\n### 2.1.2 同步落盘怎么才能快\n\n1. 使用 FileChannel + DirectBuffer 池，使用堆外内存，加快内存拷贝  \n2. 使用数据和索引分离，当消息需要写入时，使用 commitlog 文件顺序写，当需要定位某个消息时，查询index 文件来定位，从而减少文件IO随机读写的性能损耗\n\n### 2.1.3 消息堆积的问题\n\n1. 后台定时任务每隔72小时，删除旧的没有使用过的消息信息  \n2. 根据不同的业务实现不同的丢弃任务，具体参考线程池的 AbortPolicy，例如FIFO/LRU等（RocketMQ没有此策略）  \n3. 消息定时转移，或者对某些重要的 TAG 型（支付型）消息真正落库\n### 2.1.4 定时消息的实现\n\n1. 实际 RocketMQ 没有实现任意精度的定时消息，它只支持某些特定的时间精度的定时消息\n2. 实现定时消息的原理是：创建特定时间精度的 MessageQueue，例如生产者需要定时1s之后被消费者消费，你只需要将此消息发送到特定的 Topic，例如：MessageQueue-1 表示这个 MessageQueue 里面的消息都会延迟一秒被消费，然后 Broker 会在 1s 后发送到消费者消费此消息，使用 newSingleThreadScheduledExecutor 实现\n\n### 2.1.5 顺序消息的实现\n\n1. 与定时消息同原理，生产者生产消息时指定特定的 MessageQueue ，消费者消费消息时，消费特定的 MessageQueue，其实单机版的消息中心在一个 MessageQueue 就天然支持了顺序消息\n2. 注意：同一个 MessageQueue 保证里面的消息是顺序消费的前提是：消费者是串行的消费该 MessageQueue，因为就算 MessageQueue 是顺序的，但是当并行消费时，还是会有顺序问题，但是串行消费也同时引入了两个问题：\n>1. 引入锁来实现串行\n>2. 前一个消费阻塞时后面都会被阻塞\n\n### 2.1.6 分布式消息的实现\n\n1. 需要前置知识：2PC  \n2. RocketMQ4.3 起支持，原理为2PC，即两阶段提交，prepared->commit/rollback\n3. 生产者发送事务消息，假设该事务消息 Topic 为 Topic1-Trans，Broker 得到后首先更改该消息的 Topic 为 Topic1-Prepared，该 Topic1-Prepared 对消费者不可见。然后定时回调生产者的本地事务A执行状态，根据本地事务A执行状态，来是否将该消息修改为 Topic1-Commit 或 Topic1-Rollback，消费者就可以正常找到该事务消息或者不执行等\n\n>注意，就算是事务消息最后回滚了也不会物理删除，只会逻辑删除该消息\n\n### 2.1.7 消息的 push 实现\n\n1. 注意，RocketMQ 已经说了自己会有低延迟问题，其中就包括这个消息的 push 延迟问题\n2. 因为这并不是真正的将消息主动的推送到消费者，而是 Broker 定时任务每5s将消息推送到消费者\n3. pull模式需要我们手动调用consumer拉消息，而push模式则只需要我们提供一个listener即可实现对消息的监听，而实际上，RocketMQ的push模式是基于pull模式实现的，它没有实现真正的push。\n4. push方式里，consumer把轮询过程封装了，并注册MessageListener监听器，取到消息后，唤醒MessageListener的consumeMessage()来消费，对用户而言，感觉消息是被推送过来的。\n\n### 2.1.8 消息重复发送的避免\n\n1. RocketMQ 会出现消息重复发送的问题，因为在网络延迟的情况下，这种问题不可避免的发生，如果非要实现消息不可重复发送，那基本太难，因为网络环境无法预知，还会使程序复杂度加大，因此默认允许消息重复发送\n2. RocketMQ 让使用者在消费者端去解决该问题，即需要消费者端在消费消息时支持幂等性的去消费消息\n3. 最简单的解决方案是每条消费记录有个消费状态字段，根据这个消费状态字段来判断是否消费或者使用一个集中式的表，来存储所有消息的消费状态，从而避免重复消费\n4. 具体实现可以查询关于消息幂等消费的解决方案\n\n### 2.1.9 广播消费与集群消费\n\n1. 消息消费区别：广播消费，订阅该 Topic 的消息者们都会消费**每个**消息。集群消费，订阅该 Topic 的消息者们只会有一个去消费**某个**消息\n2. 消息落盘区别：具体表现在消息消费进度的保存上。广播消费，由于每个消费者都独立的去消费每个消息，因此每个消费者各自保存自己的消息消费进度。而集群消费下，订阅了某个 Topic，而旗下又有多个 MessageQueue，每个消费者都可能会去消费不同的 MessageQueue，因此总体的消费进度保存在 Broker 上集中的管理\n\n### 2.1.10 RocketMQ 不使用 ZooKeeper 作为注册中心的原因，以及自制的 NameServer 优缺点？\n\n1. ZooKeeper 作为支持顺序一致性的中间件，在某些情况下，它为了满足一致性，会丢失一定时间内的可用性，RocketMQ 需要注册中心只是为了发现组件地址，在某些情况下，RocketMQ 的注册中心可以出现数据不一致性，这同时也是 NameServer 的缺点，因为 NameServer 集群间互不通信，它们之间的注册信息可能会不一致\n2. 另外，当有新的服务器加入时，NameServer 并不会立马通知到 Producer，而是由 Producer 定时去请求 NameServer 获取最新的 Broker/Consumer 信息（这种情况是通过 Producer 发送消息时，负载均衡解决）\n\n### 2.1.11 其它\n\n![image-20211101235848839](RocketMQ-Questions.assets/image-20211101235848839.png)\n\n加分项咯 \n1. 包括组件通信间使用 Netty 的自定义协议\n2. 消息重试负载均衡策略（具体参考 Dubbo 负载均衡策略）\n3. 消息过滤器（Producer 发送消息到 Broker，Broker 存储消息信息，Consumer 消费时请求 Broker 端从磁盘文件查询消息文件时,在 Broker 端就使用过滤服务器进行过滤）  \n4. Broker 同步双写和异步双写中 Master 和 Slave 的交互\n5. Broker 在 4.5.0 版本更新中引入了基于 Raft 协议的多副本选举，之前这是商业版才有的特性 [ISSUE-1046][2]\n\n# 3 参考\n\n1. 《RocketMQ技术内幕》：https://blog.csdn.net/prestigeding/article/details/85233529\n2. 关于 RocketMQ 对 MappedByteBuffer 的一点优化：https://lishoubo.github.io/2017/09/27/MappedByteBuffer%E7%9A%84%E4%B8%80%E7%82%B9%E4%BC%98%E5%8C%96/\n3. 十分钟入门RocketMQ：https://developer.aliyun.com/article/66101\n4. 分布式事务的种类以及 RocketMQ 支持的分布式消息：https://www.infoq.cn/article/2018/08/rocketmq-4.3-release\n5. 滴滴出行基于RocketMQ构建企业级消息队列服务的实践：https://yq.aliyun.com/articles/664608\n6. 基于《RocketMQ技术内幕》源码注释：https://github.com/LiWenGu/awesome-rocketmq\n\n[1]: https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/RocketMQ%E6%B5%81%E7%A8%8B.png\n[2]: http://rocketmq.apache.org/release_notes/release-notes-4.5.0/\n'},"5be8":function(n,e,t){"use strict";t.r(e),e["default"]="IO 模型这块确实挺难理解的，需要太多计算机底层知识。写这篇文章用了挺久，就非常希望能把我所知道的讲出来吧!希望朋友们能有收获！为了写这篇文章，还翻看了一下《UNIX 网络编程》这本书，太难了，我滴乖乖！心痛~\n\n_个人能力有限。如果文章有任何需要补充/完善/修改的地方，欢迎在评论区指出，共同进步！_\n\n## 前言\n\nI/O 一直是很多小伙伴难以理解的一个知识点，这篇文章我会将我所理解的 I/O 讲给你听，希望可以对你有所帮助。\n\n## I/O\n\n### 何为 I/O?\n\nI/O（**I**nput/**O**utpu） 即**输入／输出** 。\n\n**我们先从计算机结构的角度来解读一下 I/O。**\n\n根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。\n\n![冯诺依曼体系结构](IO模型.assets/20190624122126398.jpeg)\n\n输入设备（比如键盘）和输出设备（比如显示器）都属于外部设备。网卡、硬盘这种既可以属于输入设备，也可以属于输出设备。\n\n输入设备向计算机输入数据，输出设备接收计算机输出的数据。\n\n**从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。**\n\n**我们再先从应用程序的角度来解读一下 I/O。**\n\n根据大学里学到的操作系统相关的知识：为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 **用户空间（User space）** 和 **内核空间（Kernel space ）** 。\n\n像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。\n\n并且，用户空间的程序不能直接访问内核空间。\n\n当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。\n\n因此，用户进程想要执行 IO 操作的话，必须通过 **系统调用** 来间接访问内核空间\n\n我们在平常开发过程中接触最多的就是 **磁盘 IO（读写文件）** 和 **网络 IO（网络请求和响应）**。\n\n**从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。**\n\n当应用程序发起 I/O 调用后，会经历两个步骤：\n\n1. 内核等待 I/O 设备准备好数据\n2. 内核将数据从内核空间拷贝到用户空间。\n\n### 有哪些常见的 IO 模型?\n\nUNIX 系统下， IO 模型一共有 5 种： **同步阻塞 I/O**、**同步非阻塞 I/O**、**I/O 多路复用**、**信号驱动 I/O** 和**异步 I/O**。\n\n这也是我们经常提到的 5 种 IO 模型。\n\n## Java 中 3 种常见 IO 模型\n\n### BIO (Blocking I/O)\n\n**BIO 属于同步阻塞 IO 模型** 。\n\n同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。\n\n![图源：《深入拆解Tomcat & Jetty》](IO模型.assets/6a9e704af49b4380bb686f0c96d33b81~tplv-k3u1fbpfcp-watermark.image)\n\n在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。\n\n### NIO (Non-blocking/New I/O)\n\nJava 中的 NIO 于 Java 1.4 中引入，对应 `java.nio` 包，提供了 `Channel` , `Selector`，`Buffer` 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。\n\nJava 中的 NIO 可以看作是 **I/O 多路复用模型**。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。\n\n跟着我的思路往下看看，相信你会得到答案！\n\n我们先来看看 **同步非阻塞 IO 模型**。\n\n![图源：《深入拆解Tomcat & Jetty》](IO模型.assets/bb174e22dbe04bb79fe3fc126aed0c61~tplv-k3u1fbpfcp-watermark.image)\n\n同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。\n\n相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。\n\n但是，这种 IO 模型同样存在问题：**应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。**\n\n这个时候，**I/O 多路复用模型** 就上场了。\n\n![](IO模型.assets/88ff862764024c3b8567367df11df6ab~tplv-k3u1fbpfcp-watermark.image)\n\nIO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间->用户空间）还是阻塞的。\n\n> 目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，是目前几乎在所有的操作系统上都有支持\n>\n> - **select 调用** ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。\n> - **epoll 调用** ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。\n\n**IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。**\n\nJava 中的 NIO ，有一个非常重要的**选择器 ( Selector )** 的概念，也可以被称为 **多路复用器**。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。\n\n![](IO模型.assets/0f483f2437ce4ecdb180134270a00144~tplv-k3u1fbpfcp-watermark.image)\n\n### AIO (Asynchronous I/O)\n\nAIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。\n\n异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。\n\n![](IO模型.assets/3077e72a1af049559e81d18205b56fd7~tplv-k3u1fbpfcp-watermark.image)\n\n目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。\n\n最后，来一张图，简单总结一下 Java 中的 BIO、NIO、AIO。\n\n![](IO模型.assets/33b193457c928ae02217480f994814b6.png)\n\n## 参考\n\n- 《深入拆解 Tomcat & Jetty》\n- 如何完成一次 IO：[https://llc687.top/post/如何完成一次-io/](https://llc687.top/post/如何完成一次-io/)\n- 程序员应该这样理解 IO：[https://www.jianshu.com/p/fa7bdc4f3de7](https://www.jianshu.com/p/fa7bdc4f3de7)\n- 10 分钟看懂， Java NIO 底层原理：https://www.cnblogs.com/crazymakercircle/p/10225159.html\n- IO 模型知多少 | 理论篇：https://www.cnblogs.com/sheng-jie/p/how-much-you-know-about-io-models.html\n- 《UNIX 网络编程 卷 1；套接字联网 API 》6.2 节 IO 模型\n"},"5f88":function(n,e,t){"use strict";t.r(e),e["default"]="# Maven高级\n\n## 1)分模块开发与设计\n\n### **1.1)工程模块与模块划分**\n\n![1592058795771](Maven高级.assets/1592058795771.png)\n\n### **1.2)ssm_pojo拆分**\n\n新建模块\n\n拷贝原始项目中对应的相关内容到ssm_pojo模块中\n\n​\t实体类（User）\n\n​\t配置文件（无）\n\n### **1.3)ssm_dao拆分**\n\n- 新建模块\n\n- 拷贝原始项目中对应的相关内容到ssm_dao模块中\n\n  - 数据层接口（UserDao）\n\n  - 配置文件：保留与数据层相关配置文件(3个）\n\n  - 注意：分页插件在配置中与SqlSessionFactoryBean绑定，需要保留\n\n  - pom.xml：引入数据层相关坐标即可，删除springmvc相关坐标\n\n    - spring\n\n    - mybatis\n\n    - spring 整合mybatis\n\n    - mysql\n\n    - druid\n\n    - pagehelper\n\n    - 直接依赖ssm_pojo（对ssm_pojo模块执行install指令，将其安装到本地仓库）\n\n### **1.4)ssm_service拆分**\n\n- 新建模块\n\n- 拷贝原始项目中对应的相关内容到ssm_service模块中\n\n  - 业务层接口与实现类（UserService、UserServiceImpl）\n\n  - 配置文件：保留与数据层相关配置文件(1个）\n\n  - pom.xml：引入数据层相关坐标即可，删除springmvc相关坐标\n\n    - spring\n\n    - junit\n\n    - spring 整合junit\n\n    - 直接依赖ssm_dao（对ssm_dao模块执行install指令，将其安装到本地仓库）\n\n    - 间接依赖ssm_pojo（由ssm_dao模块负责依赖关系的建立）\n\n  - 修改service模块spring核心配置文件名，添加模块名称，格式：applicationContext-service.xml\n\n  - 修改dao模块spring核心配置文件名，添加模块名称，格式：applicationContext-dao.xml\n\n  - 修改单元测试引入的配置文件名称，由单个文件修改为多个文件\n\n### **1.5)ssm_control拆分**\n\n- 新建模块（使用webapp模板）\n\n- 拷贝原始项目中对应的相关内容到ssm_controller模块中\n\n  - 现层控制器类与相关设置类（UserController、异常相关……）\n\n  - 配置文件：保留与表现层相关配置文件(1个）、服务器相关配置文件（1个）\n\n  - pom.xml：引入数据层相关坐标即可，删除springmvc相关坐标\n\n    - spring\n\n    - springmvc\n\n    - jackson\n\n    - servlet\n\n    - tomcat服务器插件\n\n    - 直接依赖ssm_service（对ssm_service模块执行install指令，将其安装到本地仓库）\n\n    - 间接依赖ssm_dao、ssm_pojo\n\n  - 修改web.xml配置文件中加载spring环境的配置文件名称，使用*通配，加载所有applicationContext-开始的配置文件\n\n**小节**\n\n分模块开发\n\n- 模块中仅包含当前模块对应的功能类与配置文件\n\n- spring核心配置根据模块功能不同进行独立制作\n\n- 当前模块所依赖的模块通过导入坐标的形式加入当前模块后才可以使用\n\n- web.xml需要加载所有的spring核心配置文件\n\n## 2)聚合\n\n### **2.1)多模块构建维护**\n\n![1592059171938](Maven高级.assets/1592059171938.png)\n\n### **2.2)聚合**\n\n- 作用：聚合用于快速构建maven工程，一次性构建多个项目/模块。\n\n- 制作方式：\n\n  - 创建一个空模块，打包类型定义为pom\n\n    ```xml\n    <packaging>pom</packaging>\n    ```\n\n  - 定义当前模块进行构建操作时关联的其他模块名称\n\n    ```xml\n    <modules>\n        <module>../ssm_controller</module>\n        <module>../ssm_service</module>\n        <module>../ssm_dao</module>\n        <module>../ssm_pojo</module>\n    </modules>\n    ```\n\n注意事项：参与聚合操作的模块最终执行顺序与模块间的依赖关系有关，与配置顺序无关\n\n\n\n## 3)继承\n\n### **3.1)模块依赖关系维护**\n\n![1592059337530](Maven高级.assets/1592059337530.png)\n\n### **3.2)继承**\n\n- 作用：通过继承可以实现在子工程中沿用父工程中的配置\n\n  - maven中的继承与java中的继承相似，在子工程中配置继承关系\n\n- 制作方式：\n\n  - 在子工程中声明其父工程坐标与对应的位置\n\n    ```xml\n    \x3c!--定义该工程的父工程--\x3e\n    <parent>\n        <groupId>com.itheima</groupId>\n        <artifactId>ssm</artifactId>\n        <version>1.0-SNAPSHOT</version>\n        \x3c!--填写父工程的pom文件--\x3e\n        <relativePath>../ssm/pom.xml</relativePath>\n    </parent>\n    ```\n\n### **3.3)继承依赖定义**\n\n在父工程中定义依赖管理\n\n```xml\n\x3c!--声明此处进行依赖管理--\x3e\n<dependencyManagement>\n    \x3c!--具体的依赖--\x3e\n    <dependencies>\n        \x3c!--spring环境--\x3e\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.1.9.RELEASE</version>\n        </dependency>\n    <dependencies>\n<dependencyManagement>\n```\n\n### **3.4)继承依赖使用**\n\n在子工程中定义依赖关系，无需声明依赖版本，版本参照父工程中依赖的版本\n\n```xml\n<dependencies>\n    \x3c!--spring环境--\x3e\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-context</artifactId>\n    </dependency>\n</dependencies>\n```\n\n### **3.5)继承的资源**\n\ngroupId：项目组ID，项目坐标的核心元素\n\nversion：项目版本，项目坐标的核心因素\n\ndescription：项目的描述信息\n\norganization：项目的组织信息\n\ninceptionYear：项目的创始年份\n\nurl：项目的URL地址\n\ndevelopers：项目的开发者信息\n\ncontributors：项目的贡献者信息\n\ndistributionManagement：项目的部署配置\n\nissueManagement：项目的缺陷跟踪系统信息\n\nciManagement：项目的持续集成系统信息\n\nscm：项目的版本控制系统西溪\n\nmalilingLists：项目的邮件列表信息\n\nproperties：自定义的Maven属性\n\ndependencies：项目的依赖配置\n\ndependencyManagement：项目的依赖管理配置\n\nrepositories：项目的仓库配置\n\nbuild：包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等\n\nreporting：包括项目的报告输出目录配置、报告插件配置等\n\n### **3.6)继承与聚合**\n\n作用\n\n- 聚合用于快速构建项目\n\n- 继承用于快速配置\n\n相同点：\n\n- 聚合与继承的pom.xml文件打包方式均为pom，可以将两种关系制作到同一个pom文件中\n\n- 聚合与继承均属于设计型模块，并无实际的模块内容\n\n不同点：\n\n- 聚合是在当前模块中配置关系，聚合可以感知到参与聚合的模块有哪些\n\n- 继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己\n\n## 4)属性\n\n### **4.1)版本统一的重要性**\n\n![1592059609949](Maven高级.assets/1592059609949.png)\n\n### **4.2)属性类别**\n\n1.自定义属性\n\n2.内置属性\n\n3.Setting属性\n\n4.Java系统属性\n\n5.环境变量属性\n\n### **4.3)属性类别：自定义属性**\n\n作用\n\n- 等同于定义变量，方便统一维护\n\n定义格式：\n\n```xml\n\x3c!--定义自定义属性--\x3e\n<properties>\n    <spring.version>5.1.9.RELEASE</spring.version>\n    <junit.version>4.12</junit.version>\n</properties>\n```\n\n- 聚合与继承的pom.xml文件打包方式均为pom，可以将两种关系制作到同一个pom文件中\n\n- 聚合与继承均属于设计型模块，并无实际的模块内容\n\n调用格式：\n\n```xml\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context</artifactId>\n    <version>${spring.version}</version>\n</dependency>\n```\n\n### **4.4)属性类别：内置属性**\n\n作用\n\n- 使用maven内置属性，快速配置\n\n调用格式：\n\n```xml\n${basedir}\n${version}\n```\n\n### **4.5)属性类别：Setting属性**\n\n作用\n\n- 使用Maven配置文件setting.xml中的标签属性，用于动态配置\n\n调用格式：\n\n```xml\n${settings.localRepository} \n```\n\n### **4.6)属性类别：Java系统属性**\n\n作用\n\n- 读取Java系统属性\n\n调用格式\n\n```\n${user.home} \n```\n\n系统属性查询方式\n\n```\nmvn help:system \n```\n\n### **4.7)属性类别：环境变量属性**\n\n作用\n\n- 使用Maven配置文件setting.xml中的标签属性，用于动态配置\n\n调用格式\n\n```\n${env.JAVA_HOME} \n```\n\n环境变量属性查询方式\n\n```\nmvn help:system \n```\n\n## 5)版本管理\n\n### **5.1)工程版本区分**\n\n![1592060021315](Maven高级.assets/1592060021315.png)\n\n### **5.2)工程版本**\n\n- SNAPSHOT（快照版本）\n\n  - 项目开发过程中，为方便团队成员合作，解决模块间相互依赖和时时更新的问题，开发者对每个模块进行构建的时候，输出的临时性版本叫快照版本（测试阶段版本）\n\n  - u快照版本会随着开发的进展不断更新\n\n- RELEASE（发布版本）\n\n  - u项目开发到进入阶段里程碑后，向团队外部发布较为稳定的版本，这种版本所对应的构件文件是稳定的，即便进行功能的后续开发，也不会改变当前发布版本内容，这种版本称为发布版本\n\n### **5.3)工程版本号约定**\n\n约定规范：\n\n- <主版本>.<次版本>.<增量版本>.<里程碑版本>\n\n- 主版本：表示项目重大架构的变更，如：spring5相较于spring4的迭代\n\n- 次版本：表示有较大的功能增加和变化，或者全面系统地修复漏洞\n\n- 增量版本：表示有重大漏洞的修复\n\n- 里程碑版本：表明一个版本的里程碑（版本内部）。这样的版本同下一个正式版本相比，相对来说不是很稳定，有待更多的测试\n\n范例：\n\n- 5.1.9.RELEASE\n\n## 6)资源配置\n\n### **6.1)资源配置多文件维护**\n\n![1592060128683](Maven高级.assets/1592060128683.png)\n\n### **6.2)配置文件引用pom属性**\n\n- 作用\n  - 在任意配置文件中加载pom文件中定义的属性\n- 调用格式\n\n```\n${jdbc.url} \n```\n\n- 开启配置文件加载pom属性\n\n  ```xml\n  \x3c!--配置资源文件对应的信息--\x3e<resources>    <resource>        \x3c!--设定配置文件对应的位置目录，支持使用属性动态设定路径--\x3e        <directory>${project.basedir}/src/main/resources</directory>        \x3c!--开启对配置文件的资源加载过滤--\x3e        <filtering>true</filtering>    </resource></resources>\n  ```\n\n## 7)多环境开发配置\n\n### **7.1)多环境兼容**\n\n![1592060250502](Maven高级.assets/1592060250502.png)\n\n### **7.2)多环境配置**\n\n```xml\n\x3c!--创建多环境--\x3e<profiles>    \x3c!--定义具体的环境：生产环境--\x3e    <profile>        \x3c!--定义环境对应的唯一名称--\x3e        <id>pro_env</id>        \x3c!--定义环境中专用的属性值--\x3e        <properties>            <jdbc.url>jdbc:mysql://127.1.1.1:3306/ssm_db</jdbc.url>        </properties>        \x3c!--设置默认启动--\x3e        <activation>            <activeByDefault>true</activeByDefault>        </activation>    </profile>    \x3c!--定义具体的环境：开发环境--\x3e    <profile>        <id>dev_env</id>        ……    </profile></profiles>\n```\n\n### **7.3)加载指定环境**\n\n作用\n\n- 加载指定环境配置\n\n调用格式\n\n```\nmvn 指令 –P 环境定义id\n```\n\n范例\n\n```\nmvn install –P pro_env\n```\n\n## 8)跳过测试\n\n### **8.1)跳过测试环节的应用场景**\n\n整体模块功能未开发\n\n模块中某个功能未开发完毕\n\n单个功能更新调试导致其他功能失败\n\n快速打包\n\n……\n\n### **8.2)使用命令跳过测试**\n\n命令\n\n```\nmvn 指令 –D skipTests\n```\n\n注意事项\n\n- 执行的指令生命周期必须包含测试环节\n\n### **8.3)使用界面操作跳过测试**\n\n![1592060441318](Maven高级.assets/1592060441318.png)\n\n### **8.4)使用配置跳过测试**\n\n```xml\n<plugin>    <artifactId>maven-surefire-plugin</artifactId>    <version>2.22.1</version>    <configuration>        <skipTests>true</skipTests>\x3c!--设置跳过测试--\x3e        <includes> \x3c!--包含指定的测试用例--\x3e            <include>**/User*Test.java</include>        </includes>        <excludes>\x3c!--排除指定的测试用例--\x3e            <exclude>**/User*TestCase.java</exclude>        </excludes>    </configuration></plugin>\n```\n\n## 9)私服\n\n### **9.1)分模块合作开发**\n\n![1592060518477](Maven高级.assets/1592060518477.png)\n\n### **9.2)Nexus**\n\nNexus是Sonatype公司的一款maven私服产品\n\n下载地址：https://help.sonatype.com/repomanager3/download \n\n### **9.3)Nexus*安装、启动与配置**\n\n启动服务器（命令行启动）\n\n```\nnexus.exe /run nexus\n```\n\n访问服务器（默认端口：8081）\n\n```\nhttp://localhost:8081\n```\n\n修改基础配置信息\n\n- 安装路径下etc目录中nexus-default.properties文件保存有nexus基础配置信息，例如默认访问端口\n\n修改服务器运行配置信息\n\n- 安装路径下bin目录中nexus.vmoptions文件保存有nexus服务器启动对应的配置信息，例如默认占用内存空间\n\n### **9.4)私服资源获取**\n\n![1592060611850](Maven高级.assets/1592060611850.png)\n\n### **9.5)仓库分类**\n\n宿主仓库hosted \n\n- 保存无法从中央仓库获取的资源\n  - 自主研发\n  - 第三方非开源项目\n\n代理仓库proxy \n\n- 代理远程仓库，通过nexus访问其他公共仓库，例如中央仓库\n\n仓库组group \n\n- 将若干个仓库组成一个群组，简化配置\n- 仓库组不能保存资源，属于设计型仓库\n\n### **9.6)资源上传**\n\n上传资源时提供对应的信息\n\n- 保存的位置（宿主仓库）\n\n- 资源文件\n\n- 对应坐标\n\n### **9.7)idea环境中资源上传与下载**\n\n![1592060719086](Maven高级.assets/1592060719086.png)\n\n### **9.8)访问私服配置（本地仓库访问私服）**\n\n配置本地仓库访问私服的权限（setting.xml）\n\n```xml\n<servers>    <server>        <id>heima-release</id>        <username>admin</username>        <password>admin</password>    </server>    <server>        <id>heima-snapshots</id>        <username>admin</username>        <password>admin</password>    </server></servers>\n```\n\n配置本地仓库资源来源（setting.xml）\n\n```xml\n<mirrors>    <mirror>        <id>nexus-heima</id>        <mirrorOf>*</mirrorOf>        <url>http://localhost:8081/repository/maven-public/</url>    </mirror></mirrors>\n```\n\n### **9.9)访问私服配置（ 项目工程访问私服）**\n\n配置当前项目访问私服上传资源的保存位置（pom.xml）\n\n```xml\n<distributionManagement>    <repository>        <id>heima-release</id>        <url>http://localhost:8081/repository/heima-release/</url>    </repository>    <snapshotRepository>        <id>heima-snapshots</id>        <url>http://localhost:8081/repository/heima-snapshots/</url>    </snapshotRepository></distributionManagement>\n```\n\n发布资源到私服命令\n\n```\nmvn deploy\n```\n\n"},6502:function(n,e,t){"use strict";t.r(e),e["default"]='\x3c!--\n * @Date           : 2021-04-12 17:00:35\n * @FilePath       : /jinnian-space/src/pages/java/module/javaweb/md/Servlet-授课.md\n * @Description    : \n--\x3e\n# Servlet-授课\n\n# 1 Servlet\n\n## 1.1 Servlet概述\n\nServlet是SUN公司提供的一套规范，名称就叫Servlet规范，它也是JavaEE规范之一。我们可以像学习Java基础一样，通过API来学习Servlet。这里需要注意的是，在我们之前JDK的API中是没有Servlet规范的相关内容，需要使用JavaEE的API。目前在Oracle官网中的最新版本是[JavaEE8](https://www.oracle.com/technetwork/java/javaee/documentation/ee8-release-notes-3894362.html)，该网址中介绍了JavaEE8的一些新特性。当然，我们可以通过访问[官方API](https://javaee.github.io/javaee-spec/javadocs/)，学习和查阅里面的内容。\n\n打开官方API网址，在左上部分找到javax.servlet包，在左下部分找到Servlet，如下图显示：\n\n![Servlet的API官网](./Servlet-授课.assets/Servlet的API官网.png)\n\n通过阅读API，我们得到如下信息：\n\n第一：Servlet是一个运行在web服务端的java小程序\n\n第二：它可以用于接收和响应客户端的请求\n\n第三：要想实现Servlet功能，可以实现Servlet接口，继承GenericServlet或者HttpServlet\n\n第四：每次请求都会执行service方法\n\n第五：Servlet还支持配置\n\n具体请看下图：\n\n![ServletAPI详解](./Servlet-授课.assets/ServletAPI详解.png)\n\n## 1.2 Servlet入门\n\n### 1.2.1 Servlet编码步骤\n\n#### 1）编码步骤\n\n**第一步：前期准备-创建JavaWeb工程**\n\n**第二步：编写一个普通类继承GenericServlet并重写service方法**\n\n**第三步：在web.xml配置Servlet**\n\n#### 2）测试\n\n**在Tomcat中部署项目**\n\n**在浏览器访问Servlet**\n\n![测试入门案例执行](./Servlet-授课.assets/测试入门案例执行.png)\n\n### 1.2.2 Servlet执行过程分析\n\n我们通过浏览器发送请求，请求首先到达Tomcat服务器，由服务器解析请求URL，然后在部署的应用列表中找到我们的应用。接下来，在我们的应用中找应用里的web.xml配置文件，在web.xml中找到FirstServlet的配置，找到后执行service方法，最后由FirstServlet响应客户浏览器。整个过程如下图所示：\n\n![Servlet执行过程图](./Servlet-授课.assets/Servlet执行过程图.jpg)\n\n一句话总结执行过程：\n\n浏览器——>Tomcat服务器——>我们的应用——>应用中的web.xml——>FirstServlet——>响应浏览器\n\n### 1.2.3 Servlet类视图\n\n在《Tomcat和Http协议》这天课程和刚才的入门案例中，我们都定义了自己的Servlet，实现的方式都是选择继承GenericServlet，在Servlet的API介绍中，它提出了我们除了继承GenericServlet外还可以继承HttpServlet，通过查阅servlet的类视图，我们看到GenericServlet还有一个子类HttpServlet。同时，在service方法中还有参数ServletRequest和ServletResponse，它们的关系如下图所示：\n\n![Servlet类视图](./Servlet-授课.assets/Servlet类视图.png)\n\n### 1.2.4 Servlet编写方式\n\n#### 1）编写方式说明\n\n我们在实现Servlet功能时，可以选择以下三种方式：\n\n第一种：实现Servlet接口，接口中的方法必须全部实现。\n\n​\t\t\t  使用此种方式，表示接口中的所有方法在需求方面都有重写的必要。此种方式支持最大程度的自定义。\n\n第二种：继承GenericServlet，service方法必须重写，其他方可根据需求，选择性重写。\n\n​\t\t\t  使用此种方式，表示只在接收和响应客户端请求这方面有重写的需求，而其他方法可根据实际需求选择性重写，使我们的开发Servlet变得简单。但是，此种方式是和HTTP协议无关的。\n\n第三种：继承HttpServlet，它是javax.servlet.http包下的一个抽象类，是GenericServlet的子类。<b><font color=\'red\'>如果我们选择继承HttpServlet时，只需要重写doGet和doPost方法，不要覆盖service方法。</font></b>\n\n​\t\t\t\t使用此种方式，表示我们的请求和响应需要和HTTP协议相关。也就是说，我们是通过HTTP协议来访问的。那么每次请求和响应都符合HTTP协议的规范。请求的方式就是HTTP协议所支持的方式（目前我们只知道GET和POST，而实际HTTP协议支持7种请求方式，GET POST PUT DELETE TRACE OPTIONS HEAD )。\n\n#### 2）HttpServlet的使用细节\n\n**第一步：在入门案例的工程中创建一个Servlet继承HttpServlet**\n\n<font color=\'red\'>注意：不要重写任何方法</font>，如下图所示：\n\n![HttpServlet的使用1](./Servlet-授课.assets/HttpServlet的使用1.png)\n\n![HttpServlet的使用2](./Servlet-授课.assets/HttpServlet的使用2.png)\n\n**第二步：部署项目并测试访问**\n\n当我们在地址栏输入ServletDemo2的访问URL时，出现了访问错误，状态码是405。提示信息是：方法不允许。\n\n**第三步：分析原因** \n\n得出HttpServlet的使用结论：\n\n​\t <b><font color=\'red\'>我们继承了HttpServlet，需要重写里面的doGet和doPost方法来接收get方式和post方式的请求。</font></b>\n\n为了实现代码的可重用性，我们只需要在doGet或者doPost方法中一个里面提供具体功能即可，而另外的那个方法只需要调用提供了功能的方法。\n\n## 1.3 Servlet使用细节\n\n### 1.3.1 Servlet的生命周期\n\n对象的生命周期，就是对象从生到死的过程，即：出生——活着——死亡。用更偏向 于开发的官方说法就是对象创建到销毁的过程。\n\n出生：请求第一次到达Servlet时，对象就创建出来，并且初始化成功。只出生一次，就放到内存中。\n\n活着：服务器提供服务的整个过程中，该对象一直存在，每次只是执行service方法。\n\n死亡：当服务停止时，或者服务器宕机时，对象消亡。\n\n通过分析Servlet的生命周期我们发现，它的实例化和初始化只会在请求第一次到达Servlet时执行，而销毁只会在Tomcat服务器停止时执行，由此我们得出一个结论，Servlet对象只会创建一次，销毁一次。所以，Servlet对象只有一个实例。如果一个对象实例在应用中是唯一的存在，那么我们就说它是单实例的，即运用了单例模式。\n\n### 1.3.2 Servlet的线程安全\n\n由于Servlet运用了单例模式，即整个应用中只有一个实例对象，所以我们需要分析这个唯一的实例中的类成员是否线程安全。接下来，我们来看下面的的示例：\n\n```java\n/*\n    Servlet线程安全\n */\npublic class ServletDemo04 extends HttpServlet{\n    //1.定义用户名成员变量\n    //private String username = null;\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String username = null;\n        //synchronized (this) {\n            //2.获取用户名\n            username = req.getParameter("username");\n\n            try {\n                Thread.sleep(3000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            //3.获取输出流对象\n            PrintWriter pw = resp.getWriter();\n\n            //4.响应给客户端浏览器\n            pw.print("welcome:" + username);\n\n            //5.关流\n            pw.close();\n        //}\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n```\n\n启动两个浏览器，输入不同的参数，访问之后发现输出的结果都是一样，所以出现线程安全问题\n\n![Servlet的线程安全问题](./Servlet-授课.assets/Servlet的线程安全问题.png)\n\n通过上面的测试我们发现，在Servlet中定义了类成员之后，多个浏览器都会共享类成员的数据。其实每一个浏览器端发送请求，就代表是一个线程，那么多个浏览器就是多个线程，所以测试的结果说明了多个线程会共享Servlet类成员中的数据，其中任何一个线程修改了数据，都会影响其他线程。因此，我们可以认为Servlet它不是线程安全的。\n\n分析产生这个问题的根本原因，其实就是因为Servlet是单例，单例对象的类成员只会随类实例化时初始化一次，之后的操作都是改变，而不会重新初始化。\n\n解决这个问题也非常简单，就是在Servlet中定义类成员要慎重。如果类成员是共用的，并且只会在初始化时赋值，其余时间都是获取的话，那么是没问题。如果类成员并非共用，或者每次使用都有可能对其赋值，那么就要考虑线程安全问题了，把它定义到doGet或者doPost方法里面去就可以了。\n\n### 1.3.3 Servlet的注意事项\n\n#### 1）映射Servlet的细节\n\nServlet支持三种映射方式，以达到灵活配置的目的。\n\n首先编写一个Servlet，代码如下：\n\n```java\n/**\n * 演示Servlet的映射方式\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletDemo5 extends HttpServlet {\n\n    /**\n     * doGet方法输出一句话\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println("ServletDemo5接收到了请求");\n    }\n\n    /**\n     * 调用doGet方法\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n```\n\n**第一种：指名道姓的方式**\n\n​\t\t\t   此种方式，只有和映射配置一模一样时，Servlet才会接收和响应来自客户端的请求。\n\n​\t\t\t   例如：映射为：/servletDemo5\n\n​\t\t\t\t\t\t   访问URL：http://localhost:8585/servlet_demo/servletDemo5\n\n![Servlet映射1](./Servlet-授课.assets/Servlet映射1.png)\n\n**第二种：/开头+通配符的方式**\n\n​\t\t\t   此种方式，只要符合目录结构即可，不用考虑结尾是什么。\n\n​\t\t\t\t例如：映射为：/servlet/*\n\n​\t\t\t\t\t\t\t访问URL：http://localhost:8585/servlet/itheima\n\n​\t\t\t\t\t\t\t\t\t\t\t   http://localhost:8585/servlet/itcast.do\n\n​\t\t\t\t\t\t\t这两个URL都可以。因为用的*，表示/servlet/后面的内容是什么都可以。\n\n![Servlet映射2](./Servlet-授课.assets/Servlet映射2.png)\n\n**第三种：通配符+固定格式结尾**\n\n​\t\t\t\t此种方式，只要符合固定结尾格式即可，其前面的访问URI无须关心（注意协议，主机和端口必须正确）\n\n​\t\t\t\t例如：映射为：*.do\n\n​\t\t\t\t\t\t\t访问URL：http://localhost:8585/servlet/itcast.do\n\n​\t\t\t\t\t\t\t\t\t\t\t\thttp://localhost:8585/itheima.do\n\n​\t\t\t\t\t\t\t这两个URL都可以方法。因为都是以.do作为结尾，而前面用*号通配符配置的映射，所有无须关心。\n\n![Servlet映射3](./Servlet-授课.assets/Servlet映射3.png)\n\n通过测试我们发现，Servlet支持多种配置方式，但是由此也引出了一个问题，当有两个及以上的Servlet映射都符合请求URL时，由谁来响应呢？注意：HTTP协议的特征是一请求一响应的规则。那么有一个请求，必然有且只有一个响应。所以，我们接下来明确一下，多种映射规则的优先级。\n\n先说结论：指名道姓的方式优先级最高，带有通配符的映射方式，有/的比没/的优先级高\n\n所以，我们前面讲解的三种映射方式的优先级为：第一种>第二种>第三种。\n\n演示代码如下：\n\n```java\n/**\n * 它和ServletDemo5组合演示Servlet的访问优先级问题\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletDemo6 extends HttpServlet {\n\n    /**\n     * doGet方法输出一句话\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println("ServletDemo6接收到了请求");\n    }\n\n    /**\n     * 调用doGet方法\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n```\n\n```xml\n\x3c!--配置ServletDemo6--\x3e\n<servlet>\n    <servlet-name>servletDemo6</servlet-name>\n    <servlet-class>com.itheima.web.servlet.ServletDemo6</servlet-class>\n</servlet>\n<servlet-mapping>\n    <servlet-name>servletDemo6</servlet-name>\n    <url-pattern>/*</url-pattern>\n</servlet-mapping>\n```\n\n运行结果如下：\n\n![Servlet的优先级](./Servlet-授课.assets/Servlet的优先级.png)\n\n#### 2）多路径映射Servlet\n\n上一小节我们讲解了Servlet的多种映射方式，这一小节我们来介绍一下，一个Servlet的多种路径配置的支持。\n\n它其实就是给一个Servlet配置多个访问映射，从而可以根据不同请求URL实现不同的功能。\n\n首先，创建一个Servlet：\n\n```java\n/**\n * 演示Servlet的多路径映射\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletDemo7 extends HttpServlet {\n\n    /**\n     * 根据不同的请求URL，做不同的处理规则\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //1.获取当前请求的URI\n        String uri = req.getRequestURI();\n        uri = uri.substring(uri.lastIndexOf("/"),uri.length());\n        //2.判断是1号请求还是2号请求\n        if("/servletDemo7".equals(uri)){\n            System.out.println("ServletDemo7执行1号请求的业务逻辑：商品单价7折显示");\n        }else if("/demo7".equals(uri)){\n            System.out.println("ServletDemo7执行2号请求的业务逻辑：商品单价8折显示");\n        }else {\n            System.out.println("ServletDemo7执行基本业务逻辑：商品单价原价显示");\n        }\n    }\n\n    /**\n     * 调用doGet方法\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n```\n\n接下来，在web.xml配置Servlet：\n\n```xml\n\x3c!--配置ServletDemo7--\x3e\n<servlet>\n    <servlet-name>servletDemo7</servlet-name>\n    <servlet-class>com.itheima.web.servlet.ServletDemo7</servlet-class>\n</servlet>\n\x3c!--映射路径1--\x3e\n<servlet-mapping>\n    <servlet-name>servletDemo7</servlet-name>\n    <url-pattern>/demo7</url-pattern>\n</servlet-mapping>\n\x3c!--映射路径2--\x3e\n<servlet-mapping>\n    <servlet-name>servletDemo7</servlet-name>\n    <url-pattern>/servletDemo7</url-pattern>\n</servlet-mapping>\n\x3c!--映射路径3--\x3e\n<servlet-mapping>\n    <servlet-name>servletDemo7</servlet-name>\n    <url-pattern>/servlet/*</url-pattern>\n</servlet-mapping>\n```\n\n最后，启动服务测试运行结果：\n\n![多路径URL映射](./Servlet-授课.assets/多路径URL映射.png)\n\n#### 3）启动时创建Servlet\n\n我们前面讲解了Servlet的生命周期，Servlet的创建默认情况下是请求第一次到达Servlet时创建的。但是我们都知道，Servlet是单例的，也就是说在应用中只有唯一的一个实例，所以在Tomcat启动加载应用的时候就创建也是一个很好的选择。那么两者有什么区别呢？\n\n- 第一种：应用加载时创建Servlet，它的优势是在服务器启动时，就把需要的对象都创建完成了，从而在使用的时候减少了创建对象的时间，提高了首次执行的效率。它的弊端也同样明显，因为在应用加载时就创建了Servlet对象，因此，导致内存中充斥着大量用不上的Servlet对象，造成了内存的浪费。\n- 第二种：请求第一次访问是创建Servlet，它的优势就是减少了对服务器内存的浪费，因为那些一直没有被访问过的Servlet对象都没有创建，因此也提高了服务器的启动时间。而它的弊端就是，如果有一些要在应用加载时就做的初始化操作，它都没法完成，从而要考虑其他技术实现。\n\n通过上面的描述，相信同学们都能分析得出何时采用第一种方式，何时采用第二种方式。就是当需要在应用加载就要完成一些工作时，就需要选择第一种方式。当有很多Servlet的使用时机并不确定是，就选择第二种方式。\n\n在web.xml中是支持对Servlet的创建时机进行配置的，配置的方式如下：我们就以ServletDemo3为例。\n\n```xml\n\x3c!--配置ServletDemo3--\x3e\n<servlet>\n    <servlet-name>servletDemo3</servlet-name>\n    <servlet-class>com.itheima.web.servlet.ServletDemo3</servlet-class>\n    \x3c!--配置Servlet的创建顺序，当配置此标签时，Servlet就会改为应用加载时创建\n        配置项的取值只能是正整数（包括0），数值越小，表明创建的优先级越高\n    --\x3e\n    <load-on-startup>1</load-on-startup>\n</servlet>\n<servlet-mapping>\n    <servlet-name>servletDemo3</servlet-name>\n    <url-pattern>/servletDemo3</url-pattern>\n</servlet-mapping>\n```\n\n![Servlet的启动顺序](./Servlet-授课.assets/Servlet的启动顺序.png)\n\n#### 4）默认Servlet\n\n默认Servlet是由服务器提供的一个Servlet，它配置在Tomcat的conf目录下的web.xml中。如下图所示：\n\n![默认Servlet](./Servlet-授课.assets/默认Servlet.png)\n\n它的映射路径是<b><font color=\'red\'>`<url-pattern>/<url-pattern>`</font></b>，我们在发送请求时，首先会在我们应用中的web.xml中查找映射配置，找到就执行，这块没有问题。但是当找不到对应的Servlet路径时，就去找默认的Servlet，由默认Servlet处理。所以，一切都是Servlet。\n\n### 1.4 Servlet关系总图\n\n![Servlet类关系总视图](./Servlet-授课.assets/Servlet类关系总视图.png)\n\n# 2 ServletConfig\n\n## 2.1 ServletConfig概述\n\n### 2.1.1 基本概念\n\n它是Servlet的配置参数对象，在Servlet规范中，允许为每个Servlet都提供一些初始化配置。所以，每个Servlet都一个自己的ServletConfig。它的作用是在Servlet初始化期间，把一些配置信息传递给Servlet。\n\n### 2.1.2 生命周期\n\n由于它是在初始化阶段读取了web.xml中为Servlet准备的初始化配置，并把配置信息传递给Servlet，所以生命周期与Servlet相同。这里需要注意的是，如果Servlet配置了`<load-on-startup>1</load-on-startup>`，那么ServletConfig也会在应用加载时创建。\n\n## 2.2 ServletConfig的使用\n\n### 2.2.1 如何获取\n\n首先，我们要清楚的认识到，它可以为每个Servlet都提供初始化参数，所以肯定可以在每个Servlet中都配置。那是配置在Servlet的声明部分，还是映射部分呢？我们接下来先准备一个Servlet，然后给同学们揭秘。\n\n```java\n/**\n * 演示Servlet的初始化参数对象\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletDemo8 extends HttpServlet {\n\n    //定义Servlet配置对象ServletConfig\n    private ServletConfig servletConfig;\n\n    /**\n     * 在初始化时为ServletConfig赋值\n     * @param config\n     * @throws ServletException\n     */\n    @Override\n    public void init(ServletConfig config) throws ServletException {\n        this.servletConfig = config;\n    }\n\n    /**\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //输出ServletConfig\n        System.out.println(servletConfig);\n    }\n\n    /**\n     * 调用doGet方法\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n```\n\n```xml\n\x3c!--配置ServletDemo8--\x3e\n<servlet>\n    <servlet-name>servletDemo8</servlet-name>\n    <servlet-class>com.itheima.web.servlet.ServletDemo8</servlet-class>\n</servlet>\n<servlet-mapping>\n    <servlet-name>servletDemo8</servlet-name>\n    <url-pattern>/servletDemo8</url-pattern>\n</servlet-mapping>\n```\n\n### 2.2.2 如何配置\n\n在上一小节中，我们已经准备好了Servlet，同时也获取到了它的ServletConfig对象，在本小节中我们将告诉同学们如何配置初始化参数，它需要使用`<servlet>`标签中的`<init-param>`标签来配置。这也就揭秘上一小节的悬念，Servlet的初始化参数都是配置在Servlet的声明部分的。并且每个Servlet都支持有多个初始化参数，并且初始化参数都是以键值对的形式存在的。接下来，我们看配置示例：\n\n```xml\n\x3c!--配置ServletDemo8--\x3e\n<servlet>\n    <servlet-name>servletDemo8</servlet-name>\n    <servlet-class>com.itheima.web.servlet.ServletDemo8</servlet-class>\n    \x3c!--配置初始化参数--\x3e\n    <init-param>\n        \x3c!--用于获取初始化参数的key--\x3e\n        <param-name>encoding</param-name>\n        \x3c!--初始化参数的值--\x3e\n        <param-value>UTF-8</param-value>\n    </init-param>\n    \x3c!--每个初始化参数都需要用到init-param标签--\x3e\n    <init-param>\n        <param-name>servletInfo</param-name>\n        <param-value>This is Demo8</param-value>\n    </init-param>\n</servlet>\n<servlet-mapping>\n    <servlet-name>servletDemo8</servlet-name>\n    <url-pattern>/servletDemo8</url-pattern>\n</servlet-mapping>\n```\n\n### 2.2.3 常用方法\n\n![ServletConfig对象](./Servlet-授课.assets/ServletConfig对象.png)\n\n```java\n/**\n * 演示Servlet的初始化参数对象\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletDemo8 extends HttpServlet {\n\n    //定义Servlet配置对象ServletConfig\n    private ServletConfig servletConfig;\n\n    /**\n     * 在初始化时为ServletConfig赋值\n     * @param config\n     * @throws ServletException\n     */\n    @Override\n    public void init(ServletConfig config) throws ServletException {\n        this.servletConfig = config;\n    }\n\n    /**\n     * doGet方法输出一句话\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //1.输出ServletConfig\n        System.out.println(servletConfig);\n        //2.获取Servlet的名称\n        String servletName= servletConfig.getServletName();\n        System.out.println(servletName);\n        //3.获取字符集编码\n        String encoding = servletConfig.getInitParameter("encoding");\n        System.out.println(encoding);\n        //4.获取所有初始化参数名称的枚举\n        Enumeration<String> names = servletConfig.getInitParameterNames();\n        //遍历names\n        while(names.hasMoreElements()){\n            //取出每个name\n            String name = names.nextElement();\n            //根据key获取value\n            String value = servletConfig.getInitParameter(name);\n            System.out.println("name:"+name+",value:"+value);\n        }\n        //5.获取ServletContext对象\n        ServletContext servletContext = servletConfig.getServletContext();\n        System.out.println(servletContext);\n    }\n\n    /**\n     * 调用doGet方法\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n```\n\n![ServletConfig演示](./Servlet-授课.assets/ServletConfig演示.png)\n\n# 3 ServletContext\n\n## 3.1 ServletContext概述\n\n### 3.1.1 基本介绍\n\nServletContext对象，它是应用上下文对象。每一个应用有且只有一个ServletContext对象。它可以实现让应用中所有Servlet间的数据共享。 \n\n### 3.1.2 生命周期\n\n出生——活着——死亡\n\n出生： 应用一加载，该对象就被创建出来了。一个应用只有一个实例对象。(Servlet和ServletContext都是单例的)\n\n活着：只要应用一直提供服务，该对象就一直存在。\n\n死亡：应用被卸载（或者服务器挂了），该对象消亡。\n\n### 3.1.3 域对象概念\n\n域对象的概念，它指的是对象有作用域，即有作用范围。\n\n域对象的作用，域对象可以实现数据共享。不同作用范围的域对象，共享数据的能力不一样。\n\n在Servlet规范中，一共有4个域对象。今天我们讲解的ServletContext就是其中一个。它也是我们接触的第一个域对象。它是web应用中最大的作用域，叫application域。每个应用只有一个application域。它可以实现整个应用间的数据共享功能。\n\n## 3.2 ServletContext的使用\n\n### 3.2 1 ServletContext介绍\n\n```\nServletContext 是应用上下文对象。每一个应用中只有一个 ServletContext 对象。\n作用：可以获得应用的全局初始化参数和达到 Servlet 之间的数据共享。\n生命周期：应用一加载则创建，应用被停止则销毁。\n```\n\n![](./Servlet-授课.assets/ServletContext.png)\n\n### 3.2.2 域对象\n\n```\n域对象指的是对象有作用域。也就是有作用范围。域对象可以实现数据的共享。不同作用范围的域对象，共享数据的能力也不一样。\n\n在 Servlet 规范中，一共有 4 个域对象。ServletContext 就是其中的一个。它也是 web 应用中最大的作用域，也叫 application 域。它可以实现整个应用之间的数据共享！\n```\n\n\n\n### 3.2.3 ServletContext配置\n\nServletContext既然被称之为应用上下文对象，所以它的配置是针对整个应用的配置，而非某个特定Servlet的配置。它的配置被称为应用的初始化参数配置。\n\n配置的方式，需要在`<web-app>`标签中使用`<context-param>`来配置初始化参数。具体代码如下：\n\n```xml\n\x3c!--配置应用初始化参数--\x3e\n<context-param>\n    \x3c!--用于获取初始化参数的key--\x3e\n    <param-name>servletContextInfo</param-name>\n    \x3c!--初始化参数的值--\x3e\n    <param-value>This is application scope</param-value>\n</context-param>\n\x3c!--每个应用初始化参数都需要用到context-param标签--\x3e\n<context-param>\n    <param-name>globalEncoding</param-name>\n    <param-value>UTF-8</param-value>\n</context-param>\n```\n\n### 3.2.4 ServletContext常用方法\n\n```java\npublic class ServletContextDemo extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //获取ServletContext对象\n        ServletContext context = getServletContext();\n\n        //获取全局配置的globalEncoding\n        String value = context.getInitParameter("globalEncoding");\n        System.out.println(value);\n\n        //获取应用的访问虚拟目录\n        String contextPath = context.getContextPath();\n        System.out.println(contextPath);\n\n        //根据虚拟目录获取应用部署的磁盘绝对路径\n        //获取b.txt文件的绝对路径\n        String b = context.getRealPath("/b.txt");\n        System.out.println(b);\n\n        //获取c.txt文件的绝对路径\n        String c = context.getRealPath("/WEB-INF/c.txt");\n        System.out.println(c);\n\n        //获取a.txt文件的绝对路径\n        String a = context.getRealPath("/WEB-INF/classes/a.txt");\n        System.out.println(a);\n\n\n        //向域对象中存储数据\n        context.setAttribute("username","zhangsan");\n\n        //移除域对象中username的数据\n        //context.removeAttribute("username");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n```\n\n\n\n# 4 注解开发Servlet\n\n## 4.1 Servlet3.0规范\n\n首先，我们要先跟同学们明确一件事情，我们在《Tomcat和HTTP协议》课程中已经介绍了，我们使用的是Tomcat9，JavaEE规范要求是8，对应的Servlet规范规范应该是JavaEE8包含的4.x版本。\n\n但是，同学们要知道，在企业级应用的开发中，稳定远比追新版本重要的多。所以，我们虽然用到了Tomcat9和对应的JavaEE8，但是涉及的Servlet规范我们降板使用，用的是Servlet3.1版本。关于兼容性问题，同学们也无须担心，向下兼容的特性，在这里也依然适用。\n\n接下来，同学还有可能疑惑的地方就是，我们课程中明明使用的是Servlet3.1版本的规范，但是却总听老师提Servlet3.0规范，这两个到底有怎样的联系呢？\n\n现在就给同学们解惑，在大概十多年前，那会还是Servlet2.5的版本的天下，它最明显的特征就是Servlet的配置要求配在web.xml中，<b><font color=\'red\'>我们今天课程中在第4章节《注解开发Servlet》之前，全都是基于Servlet2.5规范编写的。</font></b>从2007年开始到2009年底，在这个时间段，软件开发开始逐步的演变，基于注解的配置理念开始逐渐出现，大量注解配置思想开始用于各种框架的设计中，例如：Spring3.0版本的Java Based Configuration，JPA规范，apache旗下的struts2和mybatis的注解配置开发等等。\n\nJavaEE6规范也是在这个期间设计并推出的，与之对应就是它里面包含了新的Servlet规范：<b><font color=\'red\'>Servlet3.0版本！</font></b>\n\n## 4.2 注解开发入门案例\n\n### 4.2.1 自动注解配置\n\n#### 1）配置步骤\n\n**第一步：创建JavaWeb工程，并移除web.xml**\n\n![Servlet注解开发1](./Servlet-授课.assets/Servlet注解开发1.png)\n\n![Servlet注解开发2](./Servlet-授课.assets/Servlet注解开发2.png)\n\n![注解开发Servlet移除web.xml](./Servlet-授课.assets/注解开发Servlet移除web.xml.png)\n\n**第二步：编写Servlet**\n\n```java\n/**\n * 注解开发Servlet\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletDemo1 extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doPost(req,resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println("Servlet Demo1 Annotation");\n    }\n}\n```\n\n**第三步：使用注解配置Servlet**\n\n![注解配置Servlet映射](./Servlet-授课.assets/注解配置Servlet映射.png)\n\n**第四步：测试**\n\n![注解配置Servlet测试](./Servlet-授课.assets/注解配置Servlet测试.png)\n\n#### 2）注解详解\n\n```java\n/**\n * WebServlet注解\n * @since Servlet 3.0 (Section 8.1.1)\n */\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface WebServlet {\n\n    /**\n     * 指定Servlet的名称。\n     * 相当于xml配置中<servlet>标签下的<servlet-name>\n     */\n    String name() default "";\n\n    /**\n     * 用于映射Servlet访问的url映射\n     * 相当于xml配置时的<url-pattern>\n     */\n    String[] value() default {};\n\n    /**\n     * 相当于xml配置时的<url-pattern>\n     */\n    String[] urlPatterns() default {};\n\n    /**\n     * 用于配置Servlet的启动时机\n     * 相当于xml配置的<load-on-startup>\n     */\n    int loadOnStartup() default -1;\n\n    /**\n     * 用于配置Servlet的初始化参数\n     * 相当于xml配置的<init-param>\n     */\n    WebInitParam[] initParams() default {};\n\n    /**\n     * 用于配置Servlet是否支持异步\n     * 相当于xml配置的<async-supported>\n     */\n    boolean asyncSupported() default false;\n\n    /**\n     * 用于指定Servlet的小图标\n     */\n    String smallIcon() default "";\n\n    /**\n     * 用于指定Servlet的大图标\n     */\n    String largeIcon() default "";\n\n    /**\n     * 用于指定Servlet的描述信息\n     */\n    String description() default "";\n\n    /**\n     * 用于指定Servlet的显示名称\n     */\n    String displayName() default "";\n}\n```\n\n### 4.2.2 手动创建容器\n\n#### 1）前置说明\n\n在使用Servlet3.1版本的规范时，脱离了web.xml进行注解开发，它除了支持使用注解的配置方式外，还支持纯手动创建Servlet容器的方式。要想使用的话，必须遵循它的编写规范。它是从Servlet3.0规范才开始引入的，加入了一个新的接口：\n\n```java\npackage javax.servlet;\n\nimport java.util.Set;\n\n/**\n * 初始化Servlet容器必须实现此接口\n * 它是Servlet3.0规范提供的标准接口\n * @since Servlet 3.0\n */\npublic interface ServletContainerInitializer {\n     /**\n     * 启动容器时做一些初始化操作，例如注册Servlet,Filter,Listener等等。\n \t * @since Servlet 3.0\n     */\n    void onStartup(Set<Class<?>> c, ServletContext ctx) throws ServletException;\n}\n```\n\n同时可以利用@HandlesTypes注解，把要加载到onStartup方法中的类字节码传入进来，@HandlesTypes源码如下：\n\n```java\n/**\n * 用于指定要加载到ServletContainerInitializer接口实现了中的字节码\n * @see javax.servlet.ServletContainerInitializer\n * @since Servlet 3.0\n */\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface HandlesTypes {\n\n    /**\n     * 指定要加载到ServletContainerInitializer实现类的onStartUp方法中类的字节码。\n     * 字节码可以是接口，抽象类或者普通类。\n     */\n    Class[] value();\n}\n```\n\n#### 2）编写步骤\n\n**第一步：创建工程，并移除web.xml**\n\n![手动创建容器之创建工程](./Servlet-授课.assets/手动创建容器之创建工程.png)\n\n![手动创建容器之移除web.xml](./Servlet-授课.assets/手动创建容器之移除web.xml.png)\n\n**第二步：编写Servlet**\n\n```java\n/**\n * 注解开发Servlet 之 手动初始化容器\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletDemo1 extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doPost(req,resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println("Servlet Demo1 Annotation manual");\n    }\n}\n```\n\n**第三步：创建初始化容器的类，并按照要求配置**\n\n```java\n/**\n * 初始化容器操作\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class MyServletContainerInitializer implements ServletContainerInitializer {\n\n    @Override\n    public void onStartup(Set<Class<?>> c, ServletContext ctx) throws ServletException {\n       \n    }\n}\n```\n\n在脱离web.xml时，要求在src目录下包含一个META-INF目录，位置和及字母都不能改变，且严格区分大小写。在目录中创建一个名称为`javax.servlet.ServletContainerInitializer`的文件，里面写实现了`ServletContainerInitializer`接口的全限定类名。如下图所示：\n\n![手动创建容器之初始化容器的配置](./Servlet-授课.assets/手动创建容器之初始化容器的配置.png)\n\n**第四步：编写注册Servlet的代码**\n\n![手动创建容器之编写注册Servlet的代码](./Servlet-授课.assets/手动创建容器之编写注册Servlet的代码.png)\n\n**第五步：测试**\n\n![手动创建容器之测试](./Servlet-授课.assets/手动创建容器之测试.png)\n\n# 5 Servlet应用案例-学生管理系统\n\n## 5.1 案例介绍\n\n### 5.1.1 案例需求\n\n在昨天的课程讲解中，我们用Tomcat服务器替代了SE阶段的学生管理系统中自己写的服务器。今后我们进入企业肯定也会使用成型的产品，而不会自己去写服务器（除非是专门做应用服务器的公司）。\n\n从今天开始案例正式进入了编码阶段，它是延续了JavaSE阶段课程的学生管理系统。并且分析了SE中系统的各类问题，在JavaWeb阶段学习，就是要通过每天的学习，逐步解决SE阶段学生管理系统中的遗留问题。\n\n今天，我们将会去解决下面这个问题：<b><font color=\'red\'>保存学生</font></b>。也就是让数据真正的动起来，本质就是通过html发送一个请求，把表单中填写的数据带到服务器端。因为每个使用者在表单填写的内容不一样，所有最终存起来的也就不一样了。\n\n### 5.1.2 技术选型\n\n这是一个全新的案例，而不是在SE阶段的案例上进行改造。所以我们用项目的方式来去约束这个案例。\n\n任何一个项目，在立项之初都会有技术选型，也就是定义使用的技术集，这里面包含很多。例如：表现层技术，持久层技术，数据库技术等等。\n\n我们今天只针对表现层进行编码，所以就先来定义表现层技术。表现层技术的选型就是Servlet+HTML的组合。\n\n由HTML中编写表单，Servlet中定义接收请求的方法，最终把表单数据输出到控制台即可。<b>我们Servlet的配置方式仍然选择基于web.xml的配置方式。</b>\n'},"6c40":function(n,e,t){"use strict";t.r(e),e["default"]='\n\n## 1.Collection集合\n\n### 1.1数组和集合的区别【理解】\n\n+ 相同点\n\n  都是容器,可以存储多个数据\n\n+ 不同点\n\n  + 数组的长度是不可变的,集合的长度是可变的\n\n  + 数组可以存基本数据类型和引用数据类型\n\n    集合只能存引用数据类型,如果要存基本数据类型,需要存对应的包装类\n\n### 1.2集合类体系结构【理解】\n\n![01_集合类体系结构图](./day16-集合01.img/01_集合类体系结构图.png)\n\n### 1.3Collection 集合概述和使用【应用】\n\n+ Collection集合概述\n\n  + 是单例集合的顶层接口,它表示一组对象,这些对象也称为Collection的元素\n  + JDK 不提供此接口的任何直接实现.它提供更具体的子接口(如Set和List)实现\n\n+ 创建Collection集合的对象\n\n  + 多态的方式\n  + 具体的实现类ArrayList\n\n+ Collection集合常用方法\n\n  | 方法名                        | 说明                |\n  | :------------------------- | :---------------- |\n  | boolean add(E e)           | 添加元素              |\n  | boolean remove(Object o)   | 从集合中移除指定的元素       |\n  | boolean removeIf(Object o) | 根据条件进行移除          |\n  | void   clear()             | 清空集合中的元素          |\n  | boolean contains(Object o) | 判断集合中是否存在指定的元素    |\n  | boolean isEmpty()          | 判断集合是否为空          |\n  | int   size()               | 集合的长度，也就是集合中元素的个数 |\n\n### 1.4Collection集合的遍历【应用】\n\n+ 迭代器介绍\n\n  + 迭代器,集合的专用遍历方式\n  + Iterator<E> iterator(): 返回此集合中元素的迭代器,通过集合对象的iterator()方法得到\n\n+ Iterator中的常用方法\n\n  ​\tboolean hasNext(): 判断当前位置是否有元素可以被取出\n  ​\tE next(): 获取当前位置的元素,将迭代器对象移向下一个索引位置\n\n+ Collection集合的遍历\n\n  ```java\n  public class IteratorDemo1 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Collection<String> c = new ArrayList<>();\n\n          //添加元素\n          c.add("hello");\n          c.add("world");\n          c.add("java");\n          c.add("javaee");\n\n          //Iterator<E> iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到\n          Iterator<String> it = c.iterator();\n\n          //用while循环改进元素的判断和获取\n          while (it.hasNext()) {\n              String s = it.next();\n              System.out.println(s);\n          }\n      }\n  }\n  ```\n\n+ 迭代器中删除的方法\n\n  ​\tvoid remove(): 删除迭代器对象当前指向的元素\n\n  ```java\n  public class IteratorDemo2 {\n      public static void main(String[] args) {\n          ArrayList<String> list = new ArrayList<>();\n          list.add("a");\n          list.add("b");\n          list.add("b");\n          list.add("c");\n          list.add("d");\n\n          Iterator<String> it = list.iterator();\n          while(it.hasNext()){\n              String s = it.next();\n              if("b".equals(s)){\n                  //指向谁,那么此时就删除谁.\n                  it.remove();\n              }\n          }\n          System.out.println(list);\n      }\n  }\n  ```\n\n### 1.5增强for循环【应用】\n\n+ 介绍\n\n  + 它是JDK5之后出现的,其内部原理是一个Iterator迭代器\n  + 实现Iterable接口的类才可以使用迭代器和增强for\n  + 简化数组和Collection集合的遍历\n\n+ 格式\n\n  ​\tfor(集合/数组中元素的数据类型 变量名 :  集合/数组名) {\n\n  ​\t\t// 已经将当前遍历到的元素封装到变量中了,直接使用变量即可\n\n  ​\t}\n\n+ 代码\n\n  ```java\n  public class MyCollectonDemo1 {\n      public static void main(String[] args) {\n          ArrayList<String> list =  new ArrayList<>();\n          list.add("a");\n          list.add("b");\n          list.add("c");\n          list.add("d");\n          list.add("e");\n          list.add("f");\n\n          //1,数据类型一定是集合或者数组中元素的类型\n          //2,str仅仅是一个变量名而已,在循环的过程中,依次表示集合或者数组中的每一个元素\n          //3,list就是要遍历的集合或者数组\n          for(String str : list){\n              System.out.println(str);\n          }\n      }\n  }\n  ```\n\n## 2.List集合\n\n### 2.1List集合的概述和特点【记忆】\n\n+ List集合的概述\n  + 有序集合,这里的有序指的是存取顺序\n  + 用户可以精确控制列表中每个元素的插入位置,用户可以通过整数索引访问元素,并搜索列表中的元素\n  + 与Set集合不同,列表通常允许重复的元素\n+ List集合的特点\n  + 存取有序\n  + 可以重复\n  + 有索引\n\n### 2.2List集合的特有方法【应用】\n\n| 方法名                             | 描述                  |\n| ------------------------------- | ------------------- |\n| void add(int index,E   element) | 在此集合中的指定位置插入指定的元素   |\n| E remove(int   index)           | 删除指定索引处的元素，返回被删除的元素 |\n| E set(int index,E   element)    | 修改指定索引处的元素，返回被修改的元素 |\n| E get(int   index)              | 返回指定索引处的元素          |\n\n## 3.数据结构\n\n### 3.1数据结构之栈和队列【记忆】\n\n- 栈结构\n\n  ​\t先进后出\n\n- 队列结构\n\n  ​\t先进先出\n\n### 3.2数据结构之数组和链表【记忆】\n\n- 数组结构\n\n  ​\t查询快、增删慢\n\n- 队列结构\n\n  ​\t查询慢、增删快\n\n## 4.List集合的实现类\n\n### 4.1List集合子类的特点【记忆】\n\n- ArrayList集合\n\n  ​\t底层是数组结构实现，查询快、增删慢\n\n- LinkedList集合\n\n  ​\t底层是链表结构实现，查询慢、增删快\n\n### 4.2LinkedList集合的特有功能【应用】\n\n- 特有方法\n\n  | 方法名                       | 说明               |\n  | ------------------------- | ---------------- |\n  | public void addFirst(E e) | 在该列表开头插入指定的元素    |\n  | public void addLast(E e)  | 将指定的元素追加到此列表的末尾  |\n  | public E getFirst()       | 返回此列表中的第一个元素     |\n  | public   E getLast()      | 返回此列表中的最后一个元素    |\n  | public E removeFirst()    | 从此列表中删除并返回第一个元素  |\n  | public   E removeLast()   | 从此列表中删除并返回最后一个元素 |\n\n## 5.泛型\n\n### 5.1泛型概述【理解】\n\n+ 泛型的介绍\n\n  ​\t泛型是JDK5中引入的特性，它提供了编译时类型安全检测机制\n\n+ 泛型的好处\n\n  1. 把运行时期的问题提前到了编译期间\n  2. 避免了强制类型转换\n\n+ 泛型的定义格式\n\n  + <类型>: 指定一种类型的格式.尖括号里面可以任意书写,一般只写一个字母.例如: <E> <T>\n  + <类型1,类型2…>: 指定多种类型的格式,多种类型之间用逗号隔开.例如: <E,T> <K,V>\n\n### 5.2泛型类【应用】\n\n- 定义格式\n\n  ```java\n  修饰符 class 类名<类型> {  }\n  ```\n\n- 示例代码\n\n  - 泛型类\n\n    ```java\n    public class Generic<T> {\n        private T t;\n\n        public T getT() {\n            return t;\n        }\n\n        public void setT(T t) {\n            this.t = t;\n        }\n    }\n    ```\n\n  - 测试类\n\n    ```java\n    public class GenericDemo1 {\n        public static void main(String[] args) {\n            Generic<String> g1 = new Generic<String>();\n            g1.setT("杨幂");\n            System.out.println(g1.getT());\n\n            Generic<Integer> g2 = new Generic<Integer>();\n            g2.setT(30);\n            System.out.println(g2.getT());\n\n            Generic<Boolean> g3 = new Generic<Boolean>();\n            g3.setT(true);\n            System.out.println(g3.getT());\n        }\n    }\n    ```\n\n### 5.3泛型方法【应用】\n\n- 定义格式\n\n  ```java\n  修饰符 <类型> 返回值类型 方法名(类型 变量名) {  }\n  ```\n\n- 示例代码\n\n  - 带有泛型方法的类\n\n    ```java\n    public class Generic {\n        public <T> void show(T t) {\n            System.out.println(t);\n        }\n    }\n    ```\n\n  - 测试类\n\n    ```java\n    public class GenericDemo2 {\n        public static void main(String[] args) {\n    \t    Generic g = new Generic();\n            g.show("柳岩");\n            g.show(30);\n            g.show(true);\n            g.show(12.34);\n        }\n    }\n    ```\n\n### 5.4泛型接口【应用】\n\n- 定义格式\n\n  ```java\n  修饰符 interface 接口名<类型> {  }\n  ```\n\n- 示例代码\n\n  - 泛型接口\n\n    ```java\n    public interface Generic<T> {\n        void show(T t);\n    }\n    ```\n\n  - 泛型接口实现类1\n\n    ​\t定义实现类时,定义和接口相同泛型,创建实现类对象时明确泛型的具体类型\n\n    ```java\n    public class GenericImpl1<T> implements Generic<T> {\n        @Override\n        public void show(T t) {\n            System.out.println(t);\n        }\n    }\n    ```\n\n  - 泛型接口实现类2\n\n    ​\t定义实现类时,直接明确泛型的具体类型\n\n    ```java\n    public class GenericImpl2 implements Generic<Integer>{\n         @Override\n         public void show(Integer t) {\n              System.out.println(t);\n         }\n    }\n    ```\n\n  - 测试类\n\n    ```java\n    public class GenericDemo3 {\n        public static void main(String[] args) {\n            GenericImpl1<String> g1 = new GenericImpl<String>();\n            g1.show("林青霞");\n            GenericImpl1<Integer> g2 = new GenericImpl<Integer>();\n            g2.show(30);\n          \n            GenericImpl2 g3 = new GenericImpl2();\n          \tg3.show(10);\n        }\n    }\n\n    ```\n\n### 5.5类型通配符\n\n- 类型通配符: <?>\n\n  - ArrayList<?>: 表示元素类型未知的ArrayList,它的元素可以匹配任何的类型\n  - 但是并不能把元素添加到ArrayList中了,获取出来的也是父类类型\n\n- 类型通配符上限: <? extends 类型>\n\n  - ArrayListList <? extends Number>: 它表示的类型是Number或者其子类型\n\n- 类型通配符下限: <? super 类型>\n\n  - ArrayListList <? super Number>: 它表示的类型是Number或者其父类型\n\n- 泛型通配符的使用\n\n  ```java\n  public class GenericDemo4 {\n      public static void main(String[] args) {\n          ArrayList<Integer> list1 = new ArrayList<>();\n          ArrayList<String> list2 = new ArrayList<>();\n          ArrayList<Number> list3 = new ArrayList<>();\n          ArrayList<Object> list4 = new ArrayList<>();\n\n          method(list1);\n          method(list2);\n          method(list3);\n          method(list4);\n\n          getElement1(list1);\n          getElement1(list2);//报错\n          getElement1(list3);\n          getElement1(list4);//报错\n\n          getElement2(list1);//报错\n          getElement2(list2);//报错\n          getElement2(list3);\n          getElement2(list4);\n      }\n    \n      // 泛型通配符: 此时的泛型?,可以是任意类型\n      public static void method(ArrayList<?> list){}\n      // 泛型的上限: 此时的泛型?,必须是Number类型或者Number类型的子类\n      public static void getElement1(ArrayList<? extends Number> list){}\n      // 泛型的下限: 此时的泛型?,必须是Number类型或者Number类型的父类\n      public static void getElement2(ArrayList<? super Number> list){}\n\n  }\n  ```\n\n\n\n'},"6f7a":function(n,e,t){var r={"./mybatis-interview.md":"efed","./mybatis-第1天讲义.md":"9440","./mybatis-第2天讲义.md":"2a54","./mybatis-第3天讲义.md":"41b3"};function a(n){var e=i(n);return t(e)}function i(n){if(!t.o(r,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return r[n]}a.keys=function(){return Object.keys(r)},a.resolve=i,n.exports=a,a.id="6f7a"},"71cb":function(n,e,t){"use strict";t.r(e),e["default"]='\x3c!-- MarkdownTOC --\x3e\n\n- [final,static,this,super 关键字总结](#finalstaticthissuper-关键字总结)\n  - [final 关键字](#final-关键字)\n  - [static 关键字](#static-关键字)\n  - [this 关键字](#this-关键字)\n  - [super 关键字](#super-关键字)\n  - [参考](#参考)\n- [static 关键字详解](#static-关键字详解)\n  - [static 关键字主要有以下四种使用场景](#static-关键字主要有以下四种使用场景)\n    - [修饰成员变量和成员方法\\(常用\\)](#修饰成员变量和成员方法常用)\n    - [静态代码块](#静态代码块)\n    - [静态内部类](#静态内部类)\n    - [静态导包](#静态导包)\n  - [补充内容](#补充内容)\n    - [静态方法与非静态方法](#静态方法与非静态方法)\n    - [static{}静态代码块与{}非静态代码块\\(构造代码块\\)](#static静态代码块与非静态代码块构造代码块)\n    - [参考](#参考-1)\n\n\x3c!-- /MarkdownTOC --\x3e\n\n# final,static,this,super 关键字总结\n\n## final 关键字\n\n**final 关键字，意思是最终的、不可修改的，最见不得变化 ，用来修饰类、方法和变量，具有以下特点：**\n\n1. **final 修饰的类不能被继承，final 类中的所有成员方法都会被隐式的指定为 final 方法；**\n\n2. **final 修饰的方法不能被重写；**\n\n3. **final 修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。**\n\n说明：使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。类中所有的 private 方法都隐式地指定为 final。\n\n## static 关键字\n\n**static 关键字主要有以下四种使用场景：**\n\n1. **修饰成员变量和成员方法:** 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被 static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：`类名.静态变量名` `类名.静态方法名()`\n2. **静态代码块:** 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，静态代码块只执行一次.\n3. **静态内部类（static 修饰类的话只能修饰内部类）：** 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非 static 成员变量和方法。\n4. **静态导包(用来导入类中的静态资源，1.5 之后的新特性):** 格式为：`import static` 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。\n\n## this 关键字\n\nthis 关键字用于引用类的当前实例。 例如：\n\n```java\nclass Manager {\n    Employees[] employees;\n\n    void manageEmployees() {\n        int totalEmp = this.employees.length;\n        System.out.println("Total employees: " + totalEmp);\n        this.report();\n    }\n\n    void report() { }\n}\n```\n\n在上面的示例中，this 关键字用于两个地方：\n\n- this.employees.length：访问类 Manager 的当前实例的变量。\n- this.report（）：调用类 Manager 的当前实例的方法。\n\n此关键字是可选的，这意味着如果上面的示例在不使用此关键字的情况下表现相同。 但是，使用此关键字可能会使代码更易读或易懂。\n\n## super 关键字\n\nsuper 关键字用于从子类访问父类的变量和方法。 例如：\n\n```java\npublic class Super {\n    protected int number;\n\n    protected showNumber() {\n        System.out.println("number = " + number);\n    }\n}\n\npublic class Sub extends Super {\n    void bar() {\n        super.number = 10;\n        super.showNumber();\n    }\n}\n```\n\n在上面的例子中，Sub 类访问父类成员变量 number 并调用其父类 Super 的 `showNumber（）` 方法。\n\n**使用 this 和 super 要注意的问题：**\n\n- 在构造器中使用 `super()` 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。\n- this、super 不能用在 static 方法中。\n\n**简单解释一下：**\n\n被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， **this 和 super 是属于对象范畴的东西，而静态方法是属于类范畴的东西**。\n\n## 参考\n\n- https://www.codejava.net/java-core/the-java-language/java-keywords\n- https://blog.csdn.net/u013393958/article/details/79881037\n\n# static 关键字详解\n\n## static 关键字主要有以下四种使用场景\n\n1. 修饰成员变量和成员方法\n2. 静态代码块\n3. 修饰类(只能修饰内部类)\n4. 静态导包(用来导入类中的静态资源，1.5 之后的新特性)\n\n### 修饰成员变量和成员方法(常用)\n\n被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被 static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。\n\n方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。\n\nHotSpot 虚拟机中方法区也常被称为 “永久代”，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。\n\n调用格式：\n\n- `类名.静态变量名`\n- `类名.静态方法名()`\n\n如果变量或者方法被 private 则代表该属性或者该方法只能在类的内部被访问而不能在类的外部被访问。\n\n测试方法：\n\n```java\npublic class StaticBean {\n\n    String name;\n    //静态变量\n    static int age;\n\n    public StaticBean(String name) {\n        this.name = name;\n    }\n    //静态方法\n    static void sayHello() {\n        System.out.println("Hello i am java");\n    }\n    @Override\n    public String toString() {\n        return "StaticBean{"+\n                "name=" + name + ",age=" + age +\n                "}";\n    }\n}\n```\n\n```java\npublic class StaticDemo {\n\n    public static void main(String[] args) {\n        StaticBean staticBean = new StaticBean("1");\n        StaticBean staticBean2 = new StaticBean("2");\n        StaticBean staticBean3 = new StaticBean("3");\n        StaticBean staticBean4 = new StaticBean("4");\n        StaticBean.age = 33;\n        System.out.println(staticBean + " " + staticBean2 + " " + staticBean3 + " " + staticBean4);\n        //StaticBean{name=1,age=33} StaticBean{name=2,age=33} StaticBean{name=3,age=33} StaticBean{name=4,age=33}\n        StaticBean.sayHello();//Hello i am java\n    }\n\n}\n```\n\n### 静态代码块\n\n静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块 —> 非静态代码块 —> 构造方法)。 该类不管创建多少对象，静态代码块只执行一次.\n\n静态代码块的格式是\n\n```\nstatic {\n语句体;\n}\n```\n\n一个类中的静态代码块可以有多个，位置可以随便放，它不在任何的方法体内，JVM 加载类时会执行这些静态的代码块，如果静态代码块有多个，JVM 将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。\n\n![](Java常见关键字总结.assets/88531075.jpg)\n\n静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问.\n\n### 静态内部类\n\n静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：\n\n1.  它的创建是不需要依赖外围类的创建。\n2.  它不能使用任何外围类的非 static 成员变量和方法。\n\nExample（静态内部类实现单例模式）\n\n```java\npublic class Singleton {\n\n    //声明为 private 避免调用默认构造方法创建对象\n    private Singleton() {\n    }\n\n   // 声明为 private 表明静态内部该类只能在该 Singleton 类中被访问\n    private static class SingletonHolder {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n\n    public static Singleton getUniqueInstance() {\n        return SingletonHolder.INSTANCE;\n    }\n}\n```\n\n当 Singleton 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 `getUniqueInstance()`方法从而触发 `SingletonHolder.INSTANCE` 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。\n\n这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。\n\n### 静态导包\n\n格式为：import static\n\n这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法\n\n```java\n\n\n //将Math中的所有静态资源导入，这时候可以直接使用里面的静态方法，而不用通过类名进行调用\n //如果只想导入单一某个静态方法，只需要将*换成对应的方法名即可\n\nimport static java.lang.Math.*;//换成import static java.lang.Math.max;具有一样的效果\n\npublic class Demo {\n  public static void main(String[] args) {\n\n    int max = max(1,2);\n    System.out.println(max);\n  }\n}\n\n```\n\n## 补充内容\n\n### 静态方法与非静态方法\n\n静态方法属于类本身，非静态方法属于从该类生成的每个对象。 如果您的方法执行的操作不依赖于其类的各个变量和方法，请将其设置为静态（这将使程序的占用空间更小）。 否则，它应该是非静态的。\n\nExample\n\n```java\nclass Foo {\n    int i;\n    public Foo(int i) {\n       this.i = i;\n    }\n\n    public static String method1() {\n       return "An example string that doesn\'t depend on i (an instance variable)";\n\n    }\n\n    public int method2() {\n       return this.i + 1;  //Depends on i\n    }\n\n}\n```\n\n你可以像这样调用静态方法：`Foo.method1()`。 如果您尝试使用这种方法调用 method2 将失败。 但这样可行\n\n```java\nFoo bar = new Foo(1);\nbar.method2();\n```\n\n总结：\n\n- 在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。\n- 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制\n\n### `static{}`静态代码块与`{}`非静态代码块(构造代码块)\n\n相同点： 都是在 JVM 加载类时且在构造方法执行之前执行，在类中都可以定义多个，定义多个时按定义的顺序执行，一般在代码块中对一些 static 变量进行赋值。\n\n不同点： 静态代码块在非静态代码块之前执行(静态代码块 -> 非静态代码块 -> 构造方法)。静态代码块只在第一次 new 执行一次，之后不再执行，而非静态代码块在每 new 一次就执行一次。 非静态代码块可在普通方法中定义(不过作用不大)；而静态代码块不行。\n\n> **🐛 修正（参见： [issue #677](https://github.com/Snailclimb/JavaGuide/issues/677)）** ：静态代码块可能在第一次 new 对象的时候执行，但不一定只在第一次 new 的时候执行。比如通过 `Class.forName("ClassDemo")`创建 Class 对象的时候也会执行，即 new 或者 `Class.forName("ClassDemo")` 都会执行静态代码块。\n\n一般情况下,如果有些代码比如一些项目最常用的变量或对象必须在项目启动的时候就执行的时候,需要使用静态代码块,这种代码是主动执行的。如果我们想要设计不需要创建对象就可以调用类中的方法，例如：`Arrays` 类，`Character` 类，`String` 类等，就需要使用静态方法, 两者的区别是 静态代码块是自动执行的而静态方法是被调用的时候才执行的.\n\nExample：\n\n```java\npublic class Test {\n    public Test() {\n        System.out.print("默认构造方法！--");\n    }\n\n    //非静态代码块\n    {\n        System.out.print("非静态代码块！--");\n    }\n\n    //静态代码块\n    static {\n        System.out.print("静态代码块！--");\n    }\n\n    private static void test() {\n        System.out.print("静态方法中的内容! --");\n        {\n            System.out.print("静态方法中的代码块！--");\n        }\n\n    }\n\n    public static void main(String[] args) {\n        Test test = new Test();\n        Test.test();//静态代码块！--静态方法中的内容! --静态方法中的代码块！--\n    }\n}\n```\n\n上述代码输出：\n\n```\n静态代码块！--非静态代码块！--默认构造方法！--静态方法中的内容! --静态方法中的代码块！--\n```\n\n当只执行 `Test.test();` 时输出：\n\n```\n静态代码块！--静态方法中的内容! --静态方法中的代码块！--\n```\n\n当只执行 `Test test = new Test();` 时输出：\n\n```\n静态代码块！--非静态代码块！--默认构造方法！--\n```\n\n非静态代码块与构造函数的区别是： 非静态代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化，因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。\n\n### 参考\n\n- https://blog.csdn.net/chen13579867831/article/details/78995480\n- https://www.cnblogs.com/chenssy/p/3388487.html\n- https://www.cnblogs.com/Qian123/p/5713440.html\n'},7659:function(n,e,t){"use strict";t.r(e),e["default"]='## 1.字符流\n\n### 1.1为什么会出现字符流【理解】\n\n- 字符流的介绍\n\n  由于字节流操作中文不是特别的方便，所以Java就提供字符流\n\n  字符流 = 字节流 + 编码表\n\n- 中文的字节存储方式\n\n  用字节流复制文本文件时，文本文件也会有中文，但是没有问题，原因是最终底层操作会自动进行字节拼接成中文，如何识别是中文的呢？\n\n  汉字在存储的时候，无论选择哪种编码存储，第一个字节都是负数\n\n### 1.2编码表【理解】\n\n- 什么是字符集\n\n  是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等\n\n  l计算机要准确的存储和识别各种字符集符号，就需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBXXX字符集、Unicode字符集等\n\n- 常见的字符集\n\n  - ASCII字符集：\n\n    lASCII：是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符(回车键、退格、换行键等)和可显示字符(英文大小写字符、阿拉伯数字和西文符号) \n\n    基本的ASCII字符集，使用7位表示一个字符，共128字符。ASCII的扩展字符集使用8位表示一个字符，共256字符，方便支持欧洲常用字符。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等\n\n  - GBXXX字符集：\n\n    GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等\n\n  - Unicode字符集：\n\n    UTF-8编码：可以用来表示Unicode标准中任意字符，它是电子邮件、网页及其他存储或传送文字的应用 中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。它使用一至四个字节为每个字符编码\n\n    编码规则： \n\n      128个US-ASCII字符，只需一个字节编码\n\n      拉丁文等字符，需要二个字节编码\n\n      大部分常用字（含中文），使用三个字节编码\n\n      其他极少使用的Unicode辅助字符，使用四字节编码\n\n### 1.3字符串中的编码解码问题【应用】\n\n- 相关方法\n\n  | 方法名                                      | 说明                          |\n  | ---------------------------------------- | --------------------------- |\n  | byte[] getBytes()                        | 使用平台的默认字符集将该 String编码为一系列字节 |\n  | byte[] getBytes(String charsetName)      | 使用指定的字符集将该 String编码为一系列字节   |\n  | String(byte[] bytes)                     | 使用平台的默认字符集解码指定的字节数组来创建字符串   |\n  | String(byte[] bytes, String charsetName) | 通过指定的字符集解码指定的字节数组来创建字符串     |\n\n- 代码演示\n\n  ```java\n  public class StringDemo {\n      public static void main(String[] args) throws UnsupportedEncodingException {\n          //定义一个字符串\n          String s = "中国";\n  \n          //byte[] bys = s.getBytes(); //[-28, -72, -83, -27, -101, -67]\n          //byte[] bys = s.getBytes("UTF-8"); //[-28, -72, -83, -27, -101, -67]\n          byte[] bys = s.getBytes("GBK"); //[-42, -48, -71, -6]\n          System.out.println(Arrays.toString(bys));\n  \n          //String ss = new String(bys);\n          //String ss = new String(bys,"UTF-8");\n          String ss = new String(bys,"GBK");\n          System.out.println(ss);\n      }\n  }\n  ```\n\n### 1.4字符流写数据【应用】\n\n- 介绍\n\n  Writer: 用于写入字符流的抽象父类\n\n  FileWriter: 用于写入字符流的常用子类\n\n\n- 构造方法\n\n  | 方法名                                      | 说明                                       |\n  | ---------------------------------------- | ---------------------------------------- |\n  | FileWriter(File file)                    | 根据给定的 File 对象构造一个 FileWriter 对象          |\n  | FileWriter(File file, boolean append)    | 根据给定的 File 对象构造一个 FileWriter 对象          |\n  | FileWriter(String fileName)              | 根据给定的文件名构造一个 FileWriter 对象               |\n  | FileWriter(String fileName, boolean append) | 根据给定的文件名以及指示是否附加写入数据的 boolean 值来构造 FileWriter 对象 |\n\n\n- 成员方法\n\n  | 方法名                                      | 说明         |\n  | ---------------------------------------- | ---------- |\n  | void   write(int c)                      | 写一个字符      |\n  | void   write(char[] cbuf)                | 写入一个字符数组   |\n  | void write(char[] cbuf, int off, int len) | 写入字符数组的一部分 |\n  | void write(String str)                   | 写一个字符串     |\n  | void write(String str, int off, int len) | 写一个字符串的一部分 |\n\n- 刷新和关闭的方法\n\n  | 方法名     | 说明                                 |\n  | ------- | ---------------------------------- |\n  | flush() | 刷新流，之后还可以继续写数据                     |\n  | close() | 关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据 |\n\n- 代码演示\n\n  ```java\n  public class OutputStreamWriterDemo {\n      public static void main(String[] args) throws IOException {\n          FileWriter fw = new FileWriter("myCharStream\\\\a.txt");\n  \n          //void write(int c)：写一个字符\n  //        fw.write(97);\n  //        fw.write(98);\n  //        fw.write(99);\n  \n          //void writ(char[] cbuf)：写入一个字符数组\n          char[] chs = {\'a\', \'b\', \'c\', \'d\', \'e\'};\n  //        fw.write(chs);\n  \n          //void write(char[] cbuf, int off, int len)：写入字符数组的一部分\n  //        fw.write(chs, 0, chs.length);\n  //        fw.write(chs, 1, 3);\n  \n          //void write(String str)：写一个字符串\n  //        fw.write("abcde");\n  \n          //void write(String str, int off, int len)：写一个字符串的一部分\n  //        fw.write("abcde", 0, "abcde".length());\n          fw.write("abcde", 1, 3);\n  \n          //释放资源\n          fw.close();\n      }\n  }\n  ```\n\n### 1.5字符流读数据【应用】\n\n+ 介绍\n\n  Reader: 用于读取字符流的抽象父类\n\n  FileReader: 用于读取字符流的常用子类\n\n\n+ 构造方法\n\n  | 方法名                         | 说明                                   |\n  | --------------------------- | ------------------------------------ |\n  | FileReader(File file)       | 在给定从中读取数据的 File 的情况下创建一个新 FileReader |\n  | FileReader(String fileName) | 在给定从中读取数据的文件名的情况下创建一个新 FileReader    |\n\n- 成员方法\n\n  | 方法名                   | 说明          |\n  | --------------------- | ----------- |\n  | int read()            | 一次读一个字符数据   |\n  | int read(char[] cbuf) | 一次读一个字符数组数据 |\n\n- 代码演示\n\n  ```java\n  public class InputStreamReaderDemo {\n      public static void main(String[] args) throws IOException {\n     \n          FileReader fr = new FileReader("myCharStream\\\\b.txt");\n  \n          //int read()：一次读一个字符数据\n  //        int ch;\n  //        while ((ch=fr.read())!=-1) {\n  //            System.out.print((char)ch);\n  //        }\n  \n          //int read(char[] cbuf)：一次读一个字符数组数据\n          char[] chs = new char[1024];\n          int len;\n          while ((len = fr.read(chs)) != -1) {\n              System.out.print(new String(chs, 0, len));\n          }\n  \n          //释放资源\n          fr.close();\n      }\n  }\n  ```\n\n### 1.6字符流用户注册案例【应用】\n\n- 案例需求\n\n  将键盘录入的用户名和密码保存到本地实现永久化存储\n\n- 实现步骤\n  - 获取用户输入的用户名和密码\n  - 将用户输入的用户名和密码写入到本地文件中\n  - 关流,释放资源\n\n- 代码实现\n\n  ```java\n  public class CharStreamDemo8 {\n      public static void main(String[] args) throws IOException {\n          //需求: 将键盘录入的用户名和密码保存到本地实现永久化存储\n          //要求：用户名独占一行，密码独占一行\n  \n          //分析：\n          //1，实现键盘录入，把用户名和密码录入进来\n          Scanner sc = new Scanner(System.in);\n          System.out.println("请录入用户名");\n          String username = sc.next();\n          System.out.println("请录入密码");\n          String password = sc.next();\n  \n          //2.分别把用户名和密码写到本地文件。\n          FileWriter fw = new FileWriter("charstream\\\\a.txt");\n          //将用户名和密码写到文件中\n          fw.write(username);\n          //表示写出一个回车换行符 windows \\rn  MacOS \\r  Linux \\n\n          fw.write("\\rn");\n          fw.write(password);\n          //刷新流\n          fw.flush();\n          //3.关流,释放资源\n          fw.close();\n      }\n  }\n  ```\n\n### 1.7字符缓冲流【应用】\n\n- 字符缓冲流介绍\n\n  - BufferedWriter：将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途\n\n  - BufferedReader：从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。 默认值足够大，可用于大多数用途\n\n- 构造方法\n\n  | 方法名                        | 说明          |\n  | -------------------------- | ----------- |\n  | BufferedWriter(Writer out) | 创建字符缓冲输出流对象 |\n  | BufferedReader(Reader in)  | 创建字符缓冲输入流对象 |\n\n- 代码演示\n\n  ```java\n  public class BufferedStreamDemo01 {\n      public static void main(String[] args) throws IOException {\n          //BufferedWriter(Writer out)\n          BufferedWriter bw = new BufferedWriter(new                                                            FileWriter("myCharStream\\\\bw.txt"));\n          bw.write("hello\\rn");\n          bw.write("world\\rn");\n          bw.close();\n  \n          //BufferedReader(Reader in)\n          BufferedReader br = new BufferedReader(new                                                           FileReader("myCharStream\\\\bw.txt"));\n  \n          //一次读取一个字符数据\n  //        int ch;\n  //        while ((ch=br.read())!=-1) {\n  //            System.out.print((char)ch);\n  //        }\n  \n          //一次读取一个字符数组数据\n          char[] chs = new char[1024];\n          int len;\n          while ((len=br.read(chs))!=-1) {\n              System.out.print(new String(chs,0,len));\n          }\n  \n          br.close();\n      }\n  }\n  ```\n\n### 1.8字符缓冲流特有功能【应用】\n\n- 方法介绍\n\n  BufferedWriter：\n\n  | 方法名            | 说明                     |\n  | -------------- | ---------------------- |\n  | void newLine() | 写一行行分隔符，行分隔符字符串由系统属性定义 |\n\n  BufferedReader:\n\n  | 方法名               | 说明                                       |\n  | ----------------- | ---------------------------------------- |\n  | String readLine() | 读一行文字。 结果包含行的内容的字符串，不包括任何行终止字符如果流的结尾已经到达，则为null |\n\n- 代码演示\n\n  ```java\n  public class BufferedStreamDemo02 {\n      public static void main(String[] args) throws IOException {\n  \n          //创建字符缓冲输出流\n          BufferedWriter bw = new BufferedWriter(new                                                          FileWriter("myCharStream\\\\bw.txt"));\n  \n          //写数据\n          for (int i = 0; i < 10; i++) {\n              bw.write("hello" + i);\n              //bw.write("\\rn");\n              bw.newLine();\n              bw.flush();\n          }\n  \n          //释放资源\n          bw.close();\n  \n          //创建字符缓冲输入流\n          BufferedReader br = new BufferedReader(new                                                          FileReader("myCharStream\\\\bw.txt"));\n  \n          String line;\n          while ((line=br.readLine())!=null) {\n              System.out.println(line);\n          }\n  \n          br.close();\n      }\n  }\n  ```\n\n### 1.9字符缓冲流操作文件中数据排序案例【应用】\n\n- 案例需求\n\n  使用字符缓冲流读取文件中的数据，排序后再次写到本地文件\n\n- 实现步骤\n\n  - 将文件中的数据读取到程序中\n  - 对读取到的数据进行处理\n  - 将处理后的数据添加到集合中\n  - 对集合中的数据进行排序\n  - 将排序后的集合中的数据写入到文件中\n\n- 代码实现\n\n  ```java\n  public class CharStreamDemo14 {\n      public static void main(String[] args) throws IOException {\n          //需求：读取文件中的数据，排序后再次写到本地文件\n          //分析：\n          //1.要把文件中的数据读取进来。\n          BufferedReader br = new BufferedReader(new FileReader("charstream\\\\sort.txt"));\n          //输出流一定不能写在这里，因为会清空文件中的内容\n          //BufferedWriter bw = new BufferedWriter(new FileWriter("charstream\\\\sort.txt"));\n  \n          String line = br.readLine();\n          System.out.println("读取到的数据为" + line);\n          br.close();\n  \n          //2.按照空格进行切割\n          String[] split = line.split(" ");//9 1 2 5 3 10 4 6 7 8\n          //3.把字符串类型的数组变成int类型\n          int [] arr = new int[split.length];\n          //遍历split数组，可以进行类型转换。\n          for (int i = 0; i < split.length; i++) {\n              String smallStr = split[i];\n              //类型转换\n              int number = Integer.parseInt(smallStr);\n              //把转换后的结果存入到arr中\n              arr[i] = number;\n          }\n          //4.排序\n          Arrays.sort(arr);\n          System.out.println(Arrays.toString(arr));\n  \n          //5.把排序之后结果写回到本地 1 2 3 4...\n          BufferedWriter bw = new BufferedWriter(new FileWriter("charstream\\\\sort.txt"));\n          //写出\n          for (int i = 0; i < arr.length; i++) {\n              bw.write(arr[i] + " ");\n              bw.flush();\n          }\n          //释放资源\n          bw.close();\n  \n      }\n  }\n  ```\n\n### 1.10IO流小结【理解】\n\n+ IO流小结\n\n  ![01_IO流小结](./day20-IO流02.img/01_IO流小结.png)\n\n\n## 2.转换流\n\n### 2.1字符流中和编码解码问题相关的两个类【理解】\n\n- InputStreamReader：是从字节流到字符流的桥梁,父类是Reader\n\n  ​\t它读取字节，并使用指定的编码将其解码为字符\n\n  ​\t它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集\n\n- OutputStreamWriter：是从字符流到字节流的桥梁,父类是Writer\n\n  ​\t是从字符流到字节流的桥梁，使用指定的编码将写入的字符编码为字节\n\n  ​\t它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集\n\n### 2.2转换流读写数据【应用】\n\n+ 构造方法\n\n  | 方法名                                      | 说明                              |\n  | ---------------------------------------- | ------------------------------- |\n  | InputStreamReader(InputStream in)        | 使用默认字符编码创建InputStreamReader对象   |\n  | InputStreamReader(InputStream in,String chatset) | 使用指定的字符编码创建InputStreamReader对象  |\n  | OutputStreamWriter(OutputStream out)     | 使用默认字符编码创建OutputStreamWriter对象  |\n  | OutputStreamWriter(OutputStream out,String charset) | 使用指定的字符编码创建OutputStreamWriter对象 |\n\n+ 代码演示\n\n  ```java\n  public class ConversionStreamDemo {\n      public static void main(String[] args) throws IOException {\n          //OutputStreamWriter osw = new OutputStreamWriter(new                                             FileOutputStream("myCharStream\\\\osw.txt"));\n          OutputStreamWriter osw = new OutputStreamWriter(new                                              FileOutputStream("myCharStream\\\\osw.txt"),"GBK");\n          osw.write("中国");\n          osw.close();\n  \n          //InputStreamReader isr = new InputStreamReader(new \t                                         FileInputStream("myCharStream\\\\osw.txt"));\n          InputStreamReader isr = new InputStreamReader(new                                                 FileInputStream("myCharStream\\\\osw.txt"),"GBK");\n          //一次读取一个字符数据\n          int ch;\n          while ((ch=isr.read())!=-1) {\n              System.out.print((char)ch);\n          }\n          isr.close();\n      }\n  }\n  ```\n\n## 3.对象操作流\n\n### 3.1对象序列化流【应用】\n\n- 对象序列化介绍\n\n  - 对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象\n  - 这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象中存储的属性等信息\n  - 字节序列写到文件之后，相当于文件中持久保存了一个对象的信息\n  - 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化\n\n- 对象序列化流： ObjectOutputStream\n\n  - 将Java对象的原始数据类型和图形写入OutputStream。 可以使用ObjectInputStream读取（重构）对象。 可以通过使用流的文件来实现对象的持久存储。 如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象 \n\n- 构造方法\n\n  | 方法名                                  | 说明                                       |\n  | ------------------------------------ | ---------------------------------------- |\n  | ObjectOutputStream(OutputStream out) | 创建一个写入指定的OutputStream的ObjectOutputStream |\n\n- 序列化对象的方法\n\n  | 方法名                          | 说明                         |\n  | ---------------------------- | -------------------------- |\n  | void writeObject(Object obj) | 将指定的对象写入ObjectOutputStream |\n\n- 示例代码\n\n  学生类\n\n  ```java\n  public class Student implements Serializable {\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public String toString() {\n          return "Student{" +\n                  "name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class ObjectOutputStreamDemo {\n      public static void main(String[] args) throws IOException {\n          //ObjectOutputStream(OutputStream out)：创建一个写入指定的OutputStream的ObjectOutputStream\n          ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("myOtherStream\\\\oos.txt"));\n\n          //创建对象\n          Student s = new Student("佟丽娅",30);\n\n          //void writeObject(Object obj)：将指定的对象写入ObjectOutputStream\n          oos.writeObject(s);\n\n          //释放资源\n          oos.close();\n      }\n  }\n  ```\n\n- 注意事项\n\n  - 一个对象要想被序列化，该对象所属的类必须必须实现Serializable 接口\n  - Serializable是一个标记接口，实现该接口，不需要重写任何方法\n\n### 3.2对象反序列化流【应用】\n\n- 对象反序列化流： ObjectInputStream\n\n  - ObjectInputStream反序列化先前使用ObjectOutputStream编写的原始数据和对象\n\n- 构造方法\n\n  | 方法名                               | 说明                                    |\n  | --------------------------------- | ------------------------------------- |\n  | ObjectInputStream(InputStream in) | 创建从指定的InputStream读取的ObjectInputStream |\n\n- 反序列化对象的方法\n\n  | 方法名                 | 说明                       |\n  | ------------------- | ------------------------ |\n  | Object readObject() | 从ObjectInputStream读取一个对象 |\n\n- 示例代码\n\n  ```java\n  public class ObjectInputStreamDemo {\n      public static void main(String[] args) throws IOException, ClassNotFoundException {\n          //ObjectInputStream(InputStream in)：创建从指定的InputStream读取的ObjectInputStream\n          ObjectInputStream ois = new ObjectInputStream(new FileInputStream("myOtherStream\\\\oos.txt"));\n  \n          //Object readObject()：从ObjectInputStream读取一个对象\n          Object obj = ois.readObject();\n  \n          Student s = (Student) obj;\n          System.out.println(s.getName() + "," + s.getAge());\n  \n          ois.close();\n      }\n  }\n  ```\n\n### 3.3serialVersionUID&transient【应用】\n\n- serialVersionUID\n\n  - 用对象序列化流序列化了一个对象后，假如我们修改了对象所属的类文件，读取数据会不会出问题呢？\n    - 会出问题，会抛出InvalidClassException异常\n  - 如果出问题了，如何解决呢？\n    - 重新序列化\n    - 给对象所属的类加一个serialVersionUID \n      - private static final long serialVersionUID = 42L;\n\n- transient\n\n  - 如果一个对象中的某个成员变量的值不想被序列化，又该如何实现呢？\n    - 给该成员变量加transient关键字修饰，该关键字标记的成员变量不参与序列化过程\n\n- 示例代码\n\n  学生类\n\n  ```java\n  public class Student implements Serializable {\n      private static final long serialVersionUID = 42L;\n      private String name;\n  //    private int age;\n      private transient int age;\n  \n      public Student() {\n      }\n  \n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n  \n      public String getName() {\n          return name;\n      }\n  \n      public void setName(String name) {\n          this.name = name;\n      }\n  \n      public int getAge() {\n          return age;\n      }\n  \n      public void setAge(int age) {\n          this.age = age;\n      }\n  \n  //    @Override\n  //    public String toString() {\n  //        return "Student{" +\n  //                "name=\'" + name + \'\\\'\' +\n  //                ", age=" + age +\n  //                \'}\';\n  //    }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class ObjectStreamDemo {\n      public static void main(String[] args) throws IOException, ClassNotFoundException {\n  //        write();\n          read();\n      }\n  \n      //反序列化\n      private static void read() throws IOException, ClassNotFoundException {\n          ObjectInputStream ois = new ObjectInputStream(new FileInputStream("myOtherStream\\\\oos.txt"));\n          Object obj = ois.readObject();\n          Student s = (Student) obj;\n          System.out.println(s.getName() + "," + s.getAge());\n          ois.close();\n      }\n  \n      //序列化\n      private static void write() throws IOException {\n          ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("myOtherStream\\\\oos.txt"));\n          Student s = new Student("佟丽娅", 30);\n          oos.writeObject(s);\n          oos.close();\n      }\n  }\n  ```\n\n### 3.4对象操作流练习【应用】\n\n- 案例需求\n\n  创建多个学生类对象写到文件中,再次读取到内存中\n\n- 实现步骤\n\n  - 创建序列化流对象\n  - 创建多个学生对象\n  - 将学生对象添加到集合中\n  - 将集合对象序列化到文件中\n  - 创建反序列化流对象\n  - 将文件中的对象数据,读取到内存中\n\n- 代码实现\n\n  学生类\n\n  ```java\n  public class Student implements Serializable{\n      \n      private static final long serialVersionUID = 2L;\n  \n      private String name;\n      private int age;\n  \n      public Student() {\n      }\n  \n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n  \n      public String getName() {\n          return name;\n      }\n  \n      public void setName(String name) {\n          this.name = name;\n      }\n  \n      public int getAge() {\n          return age;\n      }\n  \n      public void setAge(int age) {\n          this.age = age;\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class Demo03 {\n      /**\n       *  read():\n       *      读取到文件末尾返回值是 -1\n       *  readLine():\n       *      读取到文件的末尾返回值 null\n       *  readObject():\n       *      读取到文件的末尾 直接抛出异常\n       *  如果要序列化的对象有多个,不建议直接将多个对象序列化到文件中,因为反序列化时容易出异常\n       *      建议: 将要序列化的多个对象存储到集合中,然后将集合序列化到文件中\n       */\n      public static void main(String[] args) throws Exception {\n          /*// 序列化\n          //1.创建序列化流对象\n          ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("myCode\\\\oos.txt"));\n          ArrayList<Student> arrayList = new ArrayList<>();\n          //2.创建多个学生对象\n          Student s = new Student("佟丽娅",30);\n          Student s01 = new Student("佟丽娅",30);\n          //3.将学生对象添加到集合中\n          arrayList.add(s);\n          arrayList.add(s01);\n          //4.将集合对象序列化到文件中\n          oos.writeObject(arrayList);\n          oos.close();*/\n  \n          // 反序列化\n        \t//5.创建反序列化流对象\n          ObjectInputStream ois = new ObjectInputStream(new FileInputStream("myCode\\\\oos.txt"));\n        \t//6.将文件中的对象数据,读取到内存中\n          Object obj = ois.readObject();\n          ArrayList<Student> arrayList = (ArrayList<Student>)obj;\n          ois.close();\n          for (Student s : arrayList) {\n              System.out.println(s.getName() + "," + s.getAge());\n          }\n      }\n  }\n  ```\n\n## 4.Properties集合\n\n### 4.1Properties作为Map集合的使用【应用】\n\n- Properties介绍\n\n  - 是一个Map体系的集合类\n  - Properties可以保存到流中或从流中加载\n  - 属性列表中的每个键及其对应的值都是一个字符串\n\n- Properties基本使用\n\n  ```java\n  public class PropertiesDemo01 {\n      public static void main(String[] args) {\n          //创建集合对象\n  //        Properties<String,String> prop = new Properties<String,String>(); //错误\n          Properties prop = new Properties();\n  \n          //存储元素\n          prop.put("itheima001", "佟丽娅");\n          prop.put("itheima002", "赵丽颖");\n          prop.put("itheima003", "刘诗诗");\n  \n          //遍历集合\n          Set<Object> keySet = prop.keySet();\n          for (Object key : keySet) {\n              Object value = prop.get(key);\n              System.out.println(key + "," + value);\n          }\n      }\n  }\n  ```\n\n### 4.2Properties作为Map集合的特有方法【应用】\n\n- 特有方法\n\n  | 方法名                                      | 说明                                       |\n  | ---------------------------------------- | ---------------------------------------- |\n  | Object   setProperty(String key, String value) | 设置集合的键和值，都是String类型，底层调用   Hashtable方法 put |\n  | String   getProperty(String key)         | 使用此属性列表中指定的键搜索属性                         |\n  | Set<String>   stringPropertyNames()      | 从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串         |\n\n- 示例代码\n\n  ```java\n  public class PropertiesDemo02 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Properties prop = new Properties();\n  \n          //Object setProperty(String key, String value)：设置集合的键和值，都是String类型\n          prop.setProperty("itheima001", "佟丽娅");\n          prop.setProperty("itheima002", "赵丽颖");\n          prop.setProperty("itheima003", "刘诗诗");\n  \n          //String getProperty(String key)：使用此属性列表中指定的键搜索属性\n  //        System.out.println(prop.getProperty("itheima001"));\n  //        System.out.println(prop.getProperty("itheima0011"));\n  \n  //        System.out.println(prop);\n  \n          //Set<String> stringPropertyNames()：从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串\n          Set<String> names = prop.stringPropertyNames();\n          for (String key : names) {\n  //            System.out.println(key);\n              String value = prop.getProperty(key);\n              System.out.println(key + "," + value);\n          }\n      }\n  }\n  ```\n\n### 4.3Properties和IO流相结合的方法【应用】\n\n- 和IO流结合的方法\n\n  | 方法名                                      | 说明                                       |\n  | ---------------------------------------- | ---------------------------------------- |\n  | void   load(Reader reader)               | 从输入字符流读取属性列表（键和元素对）                      |\n  | void   store(Writer writer, String comments) | 将此属性列表（键和元素对）写入此   Properties表中，以适合使用   load(Reader)方法的格式写入输出字符流 |\n\n- 示例代码\n\n  ```java\n  public class PropertiesDemo03 {\n      public static void main(String[] args) throws IOException {\n          //把集合中的数据保存到文件\n  //        myStore();\n  \n          //把文件中的数据加载到集合\n          myLoad();\n  \n      }\n  \n      private static void myLoad() throws IOException {\n          Properties prop = new Properties();\n  \n          //void load(Reader reader)：\n          FileReader fr = new FileReader("myOtherStream\\\\fw.txt");\n          prop.load(fr);\n          fr.close();\n  \n          System.out.println(prop);\n      }\n  \n      private static void myStore() throws IOException {\n          Properties prop = new Properties();\n  \n          prop.setProperty("itheima001","佟丽娅");\n          prop.setProperty("itheima002","赵丽颖");\n          prop.setProperty("itheima003","刘诗诗");\n  \n          //void store(Writer writer, String comments)：\n          FileWriter fw = new FileWriter("myOtherStream\\\\fw.txt");\n          prop.store(fw,null);\n          fw.close();\n      }\n  }\n  ```\n\n### 4.4Properties集合练习【应用】\n\n- 案例需求\n\n  在Properties文件中手动写上姓名和年龄,读取到集合中,将该数据封装成学生对象,写到本地文件\n\n- 实现步骤\n\n  - 创建Properties集合,将本地文件中的数据加载到集合中\n  - 获取集合中的键值对数据,封装到学生对象中\n  - 创建序列化流对象,将学生对象序列化到本地文件中\n\n- 代码实现\n\n  学生类\n\n  ```java\n  public class Student implements Serializable {\n      private static final long serialVersionUID = 1L;\n  \n      private String name;\n      private int age;\n  \n      public Student() {\n      }\n  \n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n  \n      public String getName() {\n          return name;\n      }\n  \n      public void setName(String name) {\n          this.name = name;\n      }\n  \n      public int getAge() {\n          return age;\n      }\n  \n      public void setAge(int age) {\n          this.age = age;\n      }\n  \n      @Override\n      public String toString() {\n          return "Student{" +\n                  "name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class Test {\n  \n      public static void main(String[] args) throws IOException {\n        \t//1.创建Properties集合,将本地文件中的数据加载到集合中\n          Properties prop = new Properties();\n          FileReader fr = new FileReader("prop.properties");\n          prop.load(fr);\n          fr.close();\n  \t\t//2.获取集合中的键值对数据,封装到学生对象中\n          String name = prop.getProperty("name");\n          int age = Integer.parseInt(prop.getProperty("age"));\n          Student s = new Student(name,age);\n  \t\t//3.创建序列化流对象,将学生对象序列化到本地文件中\n          ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("a.txt"));\n          oos.writeObject(s);\n          oos.close();\n      }\n  }\n  ```\n\n\n\n'},"79d1":function(n,e,t){"use strict";t.r(e),e["default"]="经历过技术面试的小伙伴想必对这个两个概念已经再熟悉不过了！\n\nGuide哥当年参加面试的时候，不夸张地说，只要问到分布式相关的内容，面试官几乎是必定会问这两个分布式相关的理论。\n\n并且，这两个理论也可以说是小伙伴们学习分布式相关内容的基础了！\n\n因此，小伙伴们非常非常有必要将这理论搞懂，并且能够用自己的理解给别人讲出来。\n\n这篇文章我会站在自己的角度对这两个概念进行解读！\n\n*个人能力有限。如果文章有任何需要改善和完善的地方，欢迎在评论区指出，共同进步！——爱你们的Guide哥*\n\n## CAP理论\n\n[CAP 理论/定理](https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86)起源于 2000年，由加州大学伯克利分校的Eric Brewer教授在分布式计算原理研讨会（PODC）上提出，因此 CAP定理又被称作 **布鲁尔定理（Brewer’s theorem）**\n\n2年后，麻省理工学院的Seth Gilbert和Nancy Lynch 发表了布鲁尔猜想的证明，CAP理论正式成为分布式领域的定理。\n\n### 简介\n\n**CAP** 也就是 **Consistency（一致性）**、**Availability（可用性）**、**Partition Tolerance（分区容错性）** 这三个单词首字母组合。\n\n![](CAP理论.assets/cap.png)\n\nCAP 理论的提出者布鲁尔在提出 CAP 猜想的时候，并没有详细定义 **Consistency**、**Availability**、**Partition Tolerance** 三个单词的明确定义。\n\n因此，对于 CAP 的民间解读有很多，一般比较被大家推荐的是下面 👇 这种版本的解读。\n\n在理论计算机科学中，CAP 定理（CAP theorem）指出对于一个分布式系统来说，当设计读写操作时，只能同时满足以下三点中的两个：\n\n- **一致性（Consistency）** : 所有节点访问同一份最新的数据副本\n- **可用性（Availability）**: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。\n- **分区容错性（Partition tolerance）** : 分布式系统出现网络分区的时候，仍然能够对外提供服务。\n\n**什么是网络分区？**\n\n> 分布式系统中，多个节点之前的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫网络分区。\n\n![partition-tolerance](CAP理论.assets/partition-tolerance.png)\n\n### 不是所谓的“3 选 2”\n\n大部分人解释这一定律时，常常简单的表述为：“一致性、可用性、分区容忍性三者你只能同时达到其中两个，不可能同时达到”。实际上这是一个非常具有误导性质的说法，而且在 CAP 理论诞生 12 年之后，CAP 之父也在 2012 年重写了之前的论文。\n\n> **当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。**\n>\n> 简而言之就是：CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C。\n\n因此，**分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。** 比如  ZooKeeper、HBase 就是 CP 架构，Cassandra、Eureka 就是 AP 架构，Nacos 不仅支持 CP 架构也支持 AP 架构。\n\n**为啥不可能选择 CA 架构呢？** 举个例子：若系统出现“分区”，系统中的某个节点在进行写操作。为了保证 C， 必须要禁止其他节点的读写操作，这就和 A 发生冲突了。如果为了保证 A，其他节点的读写操作正常的话，那就和 C 发生冲突了。\n\n**选择 CP 还是 AP 的关键在于当前的业务场景，没有定论，比如对于需要确保强一致性的场景如银行一般会选择保证 CP 。**\n\n另外，需要补充说明的一点是： **如果网络分区正常的话（系统在绝大部分时候所处的状态），也就说不需要保证 P 的时候，C 和 A 能够同时保证。**\n\n### CAP 实际应用案例\n\n我这里以注册中心来探讨一下 CAP 的实际应用。考虑到很多小伙伴不知道注册中心是干嘛的，这里简单以 Dubbo 为例说一说。\n\n下图是 Dubbo 的架构图。**注册中心 Registry 在其中扮演了什么角色呢？提供了什么服务呢？**\n\n注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。\n\n![](CAP理论.assets/dubbo-architecture.png)\n\n常见的可以作为注册中心的组件有：ZooKeeper、Eureka、Nacos...。\n\n1. **ZooKeeper 保证的是 CP。** 任何时刻对 ZooKeeper 的读请求都能得到一致性的结果，但是， ZooKeeper 不保证每次请求的可用性比如在 Leader 选举过程中或者半数以上的机器不可用的时候服务就是不可用的。\n2. **Eureka 保证的则是 AP。** Eureka 在设计的时候就是优先保证 A （可用性）。在 Eureka 中不存在什么 Leader 节点，每个节点都是一样的、平等的。因此 Eureka 不会像 ZooKeeper 那样出现选举过程中或者半数以上的机器不可用的时候服务就是不可用的情况。 Eureka 保证即使大部分节点挂掉也不会影响正常提供服务，只要有一个节点是可用的就行了。只不过这个节点上的数据可能并不是最新的。\n3. **Nacos 不仅支持 CP 也支持 AP。**\n\n### 总结\n\n在进行分布式系统设计和开发时，我们不应该仅仅局限在 CAP 问题上，还要关注系统的扩展性、可用性等等\n\n在系统发生“分区”的情况下，CAP 理论只能满足 CP 或者 AP。要注意的是，这里的前提是系统发生了“分区”\n\n如果系统没有发生“分区”的话，节点间的网络连接通信正常的话，也就不存在 P 了。这个时候，我们就可以同时保证 C 和 A 了。\n\n总结：**如果系统发生“分区”，我们要考虑选择 CP 还是 AP。如果系统没有发生“分区”的话，我们要思考如何保证 CA 。**\n\n### 推荐阅读\n\n1. [CAP 定理简化](https://medium.com/@ravindraprasad/cap-theorem-simplified-28499a67eab4) （英文，有趣的案例）\n2. [神一样的 CAP 理论被应用在何方](https://juejin.im/post/6844903936718012430) （中文，列举了很多实际的例子）\n3. [请停止呼叫数据库 CP 或 AP ](https://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html) （英文，带给你不一样的思考）\n"},"7ebe":function(n,e,t){"use strict";t.r(e),e["default"]='## 1.xml\n\n### 1.1概述【理解】\n\n+ 万维网联盟(W3C)\n\n  万维网联盟(W3C)创建于1994年，又称W3C理事会。1994年10月在麻省理工学院计算机科学实验室成立。\n  建立者： Tim Berners-Lee (蒂姆·伯纳斯·李)。\n  是Web技术领域最具权威和影响力的国际中立性技术标准机构。\n  到目前为止，W3C已发布了200多项影响深远的Web技术标准及实施指南，\n\n  + 如广为业界采用的超文本标记语言HTML（标准通用标记语言下的一个应用）、\n\n  + 可扩展标记语言XML（标准通用标记语言下的一个子集）\n\n  + 以及帮助残障人士有效获得Web信息的无障碍指南（WCAG）等\n\n    ![01_w3c概述](./day26-基础加强02.img/01_w3c概述.png)\n\n+ xml概述\n\n  XML的全称为(EXtensible Markup Language)，是一种可扩展的标记语言\n  标记语言: 通过标签来描述数据的一门语言(标签有时我们也将其称之为元素)\n  可扩展：标签的名字是可以自定义的,XML文件是由很多标签组成的,而标签名是可以自定义的\n\n+ 作用\n\n  + 用于进行存储数据和传输数据\n  + 作为软件的配置文件\n\n+ 作为配置文件的优势\n\n  + 可读性好\n  + 可维护性高\n\n### 1.2标签的规则【应用】\n\n+ 标签由一对尖括号和合法标识符组成\n\n  ```java\n  <student>\n  ```\n\n+ 标签必须成对出现\n\n  ```java\n  <student> </student>\n  前边的是开始标签，后边的是结束标签\n  ```\n\n+ 特殊的标签可以不成对,但是必须有结束标记\n\n  ```java\n  <address/>\n  ```\n\n+ 标签中可以定义属性,属性和标签名空格隔开,属性值必须用引号引起来\n\n  ```java\n  <student id="1"> </student>\n  ```\n\n+ 标签需要正确的嵌套\n\n  ```java\n  这是正确的: <student id="1"> <name>张三</name> </student>\n  这是错误的: <student id="1"><name>张三</student></name>\n  ```\n\n### 1.3语法规则【应用】\n\n+ 语法规则\n\n  + XML文件的后缀名为：xml\n\n  + 文档声明必须是第一行第一列\n\n    <?xml version=“1.0” encoding=“UTF-8” standalone=“yes”?>\n    version：该属性是必须存在的\n    encoding：该属性不是必须的\n\n    ​\t打开当前xml文件的时候应该是使用什么字符编码表(一般取值都是UTF-8)\n\n    standalone: 该属性不是必须的，描述XML文件是否依赖其他的xml文件，取值为yes/no\n\n  + 必须存在一个根标签，有且只能有一个\n\n  + XML文件中可以定义注释信息\n\n  + XML文件中可以存在以下特殊字符\n\n    ```java\n    &lt; < 小于\n    &gt; > 大于\n    &amp; & 和号\n    &apos; \' 单引号\n    &quot; " 引号\n    ```\n\n  + XML文件中可以存在CDATA区\n\n    <![CDATA[ …内容… ]]>\n\n+ 示例代码\n\n  ```xml\n  <?xml version="1.0" encoding="UTF-8" ?>\n  \x3c!--注释的内容--\x3e\n  \x3c!--本xml文件用来描述多个学生信息--\x3e\n  <students>\n\n      \x3c!--第一个学生信息--\x3e\n      <student id="1">\n          <name>张三</name>\n          <age>23</age>\n          <info>学生&lt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;的信息</info>\n          <message> <![CDATA[内容 <<<<<< >>>>>> ]]]></message>\n      </student>\n\n      \x3c!--第二个学生信息--\x3e\n      <student id="2">\n          <name>李四</name>\n          <age>24</age>\n      </student>\n\n  </students>\n  ```\n\n### 1.4xml解析【应用】\n\n+ 概述\n\n  xml解析就是从xml中获取到数据\n\n+ 常见的解析思想\n\n  DOM(Document Object Model)文档对象模型:就是把文档的各个组成部分看做成对应的对象。\n  会把xml文件全部加载到内存,在内存中形成一个树形结构,再获取对应的值\n\n  ![02_dom解析概述](./day26-基础加强02.img/02_dom解析概述.png)\n\n+ 常见的解析工具\n\n  + JAXP: SUN公司提供的一套XML的解析的API\n  + JDOM: 开源组织提供了一套XML的解析的API-jdom\n  + DOM4J: 开源组织提供了一套XML的解析的API-dom4j,全称：Dom For Java\n  + pull: 主要应用在Android手机端解析XML\n\n+ 解析的准备工作\n\n  1. 我们可以通过网站：https://dom4j.github.io/ 去下载dom4j\n\n     今天的资料中已经提供,我们不用再单独下载了,直接使用即可\n\n  2. 将提供好的dom4j-1.6.1.zip解压,找到里面的dom4j-1.6.1.jar\n\n  3. 在idea中当前模块下新建一个libs文件夹,将jar包复制到文件夹中\n\n  4. 选中jar包 -> 右键 -> 选择add as library即可\n\n+ 需求\n\n  + 解析提供好的xml文件\n  + 将解析到的数据封装到学生对象中\n  + 并将学生对象存储到ArrayList集合中\n  + 遍历集合\n\n+ 代码实现\n\n  ```java\n  <?xml version="1.0" encoding="UTF-8" ?>\n  \x3c!--注释的内容--\x3e\n  \x3c!--本xml文件用来描述多个学生信息--\x3e\n  <students>\n\n      \x3c!--第一个学生信息--\x3e\n      <student id="1">\n          <name>张三</name>\n          <age>23</age>\n      </student>\n\n      \x3c!--第二个学生信息--\x3e\n      <student id="2">\n          <name>李四</name>\n          <age>24</age>\n      </student>\n\n  </students>\n\n  // 上边是已经准备好的student.xml文件\n  public class Student {\n      private String id;\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String id, String name, int age) {\n          this.id = id;\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getId() {\n          return id;\n      }\n\n      public void setId(String id) {\n          this.id = id;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public String toString() {\n          return "Student{" +\n                  "id=\'" + id + \'\\\'\' +\n                  ", name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n  }\n\n  /**\n   * 利用dom4j解析xml文件\n   */\n  public class XmlParse {\n      public static void main(String[] args) throws DocumentException {\n          //1.获取一个解析器对象\n          SAXReader saxReader = new SAXReader();\n          //2.利用解析器把xml文件加载到内存中,并返回一个文档对象\n          Document document = saxReader.read(new File("myxml\\\\xml\\\\student.xml"));\n          //3.获取到根标签\n          Element rootElement = document.getRootElement();\n          //4.通过根标签来获取student标签\n          //elements():可以获取调用者所有的子标签.会把这些子标签放到一个集合中返回.\n          //elements("标签名"):可以获取调用者所有的指定的子标签,会把这些子标签放到一个集合中并返回\n          //List list = rootElement.elements();\n          List<Element> studentElements = rootElement.elements("student");\n          //System.out.println(list.size());\n\n          //用来装学生对象\n          ArrayList<Student> list = new ArrayList<>();\n\n          //5.遍历集合,得到每一个student标签\n          for (Element element : studentElements) {\n              //element依次表示每一个student标签\n    \n              //获取id这个属性\n              Attribute attribute = element.attribute("id");\n              //获取id的属性值\n              String id = attribute.getValue();\n\n              //获取name标签\n              //element("标签名"):获取调用者指定的子标签\n              Element nameElement = element.element("name");\n              //获取这个标签的标签体内容\n              String name = nameElement.getText();\n\n              //获取age标签\n              Element ageElement = element.element("age");\n              //获取age标签的标签体内容\n              String age = ageElement.getText();\n\n  //            System.out.println(id);\n  //            System.out.println(name);\n  //            System.out.println(age);\n\n              Student s = new Student(id,name,Integer.parseInt(age));\n              list.add(s);\n          }\n          //遍历操作\n          for (Student student : list) {\n              System.out.println(student);\n          }\n      }\n  }\n  ```\n\n### 1.5DTD约束【理解】\n\n+ 什么是约束\n\n  用来限定xml文件中可使用的标签以及属性\n\n+ 约束的分类\n\n  + DTD\n  + schema\n\n+ 编写DTD约束\n\n  + 步骤\n\n    1. 创建一个文件，这个文件的后缀名为.dtd\n\n    2. 看xml文件中使用了哪些元素\n\n       <!ELEMENT> 可以定义元素\n\n    3. 判断元素是简单元素还是复杂元素\n\n       简单元素：没有子元素。\n       复杂元素：有子元素的元素；\n\n  + 代码实现\n\n    ```java\n    <!ELEMENT persons (person)>\n    <!ELEMENT person (name,age)>\n    <!ELEMENT name (#PCDATA)>\n    <!ELEMENT age (#PCDATA)>\n    ```\n  ```\n\n  ```\n\n+ 引入DTD约束\n\n  + 引入DTD约束的三种方法\n\n    + 引入本地dtd\n\n      <!DOCTYPE 根元素名称 SYSTEM ‘DTD文件的路径\'>\n\n    + 在xml文件内部引入\n\n      <!DOCTYPE 根元素名称 [ dtd文件内容 ]>\n\n    + 引入网络dtd\n\n      <!DOCTYPE 根元素的名称 PUBLIC "DTD文件名称" "DTD文档的URL">\n\n  + 代码实现\n\n    + 引入本地DTD约束\n\n      ```xml\n      // 这是persondtd.dtd文件中的内容,已经提前写好\n      <!ELEMENT persons (person)>\n      <!ELEMENT person (name,age)>\n      <!ELEMENT name (#PCDATA)>\n      <!ELEMENT age (#PCDATA)>\n\n      // 在person1.xml文件中引入persondtd.dtd约束\n      <?xml version="1.0" encoding="UTF-8" ?>\n      <!DOCTYPE persons SYSTEM \'persondtd.dtd\'>\n\n      <persons>\n          <person>\n              <name>张三</name>\n              <age>23</age>\n          </person>\n\n      </persons>\n      ```\n\n    + 在xml文件内部引入\n\n      ```xml\n      <?xml version="1.0" encoding="UTF-8" ?>\n      <!DOCTYPE persons [\n              <!ELEMENT persons (person)>\n              <!ELEMENT person (name,age)>\n              <!ELEMENT name (#PCDATA)>\n              <!ELEMENT age (#PCDATA)>\n              ]>\n\n      <persons>\n          <person>\n              <name>张三</name>\n              <age>23</age>\n          </person>\n\n      </persons>\n      ```\n\n    + 引入网络dtd\n\n      ```xml\n      <?xml version="1.0" encoding="UTF-8" ?>\n      <!DOCTYPE persons PUBLIC "dtd文件的名称" "dtd文档的URL">\n\n      <persons>\n          <person>\n              <name>张三</name>\n              <age>23</age>\n          </person>\n\n      </persons>\n      ```\n\n+ DTD语法\n\n  + 定义元素\n\n    定义一个元素的格式为：<!ELEMENT 元素名 元素类型>\n    简单元素：\n\n    ​\tEMPTY: 表示标签体为空\n\n    ​\tANY: 表示标签体可以为空也可以不为空\n\n    ​\tPCDATA: 表示该元素的内容部分为字符串\n\n    复杂元素：\n    ​\t直接写子元素名称. 多个子元素可以使用","或者"|"隔开；\n    ​\t","表示定义子元素的顺序 ; "|": 表示子元素只能出现任意一个\n    ​\t"?"零次或一次, "+"一次或多次, "*"零次或多次;如果不写则表示出现一次\n\n    ![03_DTD语法定义元素](./day26-基础加强02.img/03_DTD语法定义元素.png)\n\n\n  + 定义属性\n\n    格式\n\n    定义一个属性的格式为：<!ATTLIST 元素名称 属性名称 属性的类型 属性的约束>\n    属性的类型：\n    ​\tCDATA类型：普通的字符串\n\n    属性的约束:\n\n    ​\t// #REQUIRED： 必须的\n    ​\t// #IMPLIED： 属性不是必需的\n    ​\t// #FIXED value：属性值是固定的\n\n  + 代码实现\n\n    ```java\n    <!ELEMENT persons (person+)>\n    <!ELEMENT person (name,age)>\n    <!ELEMENT name (#PCDATA)>\n    <!ELEMENT age (#PCDATA)>\n    <!ATTLIST person id CDATA #REQUIRED>\n\n    <?xml version="1.0" encoding="UTF-8" ?>\n    <!DOCTYPE persons SYSTEM \'persondtd.dtd\'>\n\n    <persons>\n        <person id="001">\n            <name>张三</name>\n            <age>23</age>\n        </person>\n\n        <person id = "002">\n            <name>张三</name>\n            <age>23</age>\n        </person>\n\n    </persons>\n    ​```\n    ```\n\n### 1.6schema约束【理解】\n\n+ schema和dtd的区别\n\n  1. schema约束文件也是一个xml文件，符合xml的语法，这个文件的后缀名.xsd\n  2. 一个xml中可以引用多个schema约束文件，多个schema使用名称空间区分（名称空间类似于java包名）\n  3. dtd里面元素类型的取值比较单一常见的是PCDATA类型，但是在schema里面可以支持很多个数据类型\n  4. schema 语法更加的复杂\n\n  ![04_schema约束介绍](./day26-基础加强02.img/04_schema约束介绍.png)\n\n+ 编写schema约束\n\n  + 步骤\n\n    1，创建一个文件，这个文件的后缀名为.xsd。\n    2，定义文档声明\n    3，schema文件的根标签为： <schema>\n    4，在<schema>中定义属性：\n    ​\txmlns=http://www.w3.org/2001/XMLSchema\n    5，在<schema>中定义属性 ：\n    ​\ttargetNamespace =唯一的url地址，指定当前这个schema文件的名称空间。\n    6，在<schema>中定义属性 ：\n    ​\telementFormDefault="qualified“，表示当前schema文件是一个质量良好的文件。\n    7，通过element定义元素\n    8，判断当前元素是简单元素还是复杂元素\n\n    ![05_schema约束编写](./day26-基础加强02.img/05_schema约束编写.png)\n\n  + 代码实现\n\n    ```java\n    <?xml version="1.0" encoding="UTF-8" ?>\n    <schema\n        xmlns="http://www.w3.org/2001/XMLSchema"\n        targetNamespace="http://www.itheima.cn/javase"\n        elementFormDefault="qualified"\n    >\n\n        \x3c!--定义persons复杂元素--\x3e\n        <element name="persons">\n            <complexType>\n                <sequence>\n                    \x3c!--定义person复杂元素--\x3e\n                    <element name = "person">\n                        <complexType>\n                            <sequence>\n                                \x3c!--定义name和age简单元素--\x3e\n                                <element name = "name" type = "string"></element>\n                                <element name = "age" type = "string"></element>\n                            </sequence>\n                            \n                        </complexType>\n                    </element>\n                </sequence>\n            </complexType>\n\n        </element>\n\n    </schema>\n\n    ```\n\n+ 引入schema约束\n\n  + 步骤\n\n    1，在根标签上定义属性xmlns="http://www.w3.org/2001/XMLSchema-instance"\n    2，通过xmlns引入约束文件的名称空间\n    3，给某一个xmlns属性添加一个标识，用于区分不同的名称空间\n    ​\t格式为: xmlns:标识=“名称空间地址” ,标识可以是任意的，但是一般取值都是xsi\n    4，通过xsi:schemaLocation指定名称空间所对应的约束文件路径\n    ​\t格式为：xsi:schemaLocation = "名称空间url 文件路径“\n\n  + 代码实现\n\n    ```java\n    <?xml version="1.0" encoding="UTF-8" ?>\n\n    <persons\n        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n        xmlns="http://www.itheima.cn/javase"\n        xsi:schemaLocation="http://www.itheima.cn/javase person.xsd"\n    >\n        <person>\n            <name>张三</name>\n            <age>23</age>\n        </person>\n\n    </persons>\n    ​```\n    ```\n\n+ schema约束定义属性\n\n  + 代码示例\n\n    ```java\n    <?xml version="1.0" encoding="UTF-8" ?>\n    <schema\n        xmlns="http://www.w3.org/2001/XMLSchema"\n        targetNamespace="http://www.itheima.cn/javase"\n        elementFormDefault="qualified"\n    >\n\n        \x3c!--定义persons复杂元素--\x3e\n        <element name="persons">\n            <complexType>\n                <sequence>\n                    \x3c!--定义person复杂元素--\x3e\n                    <element name = "person">\n                        <complexType>\n                            <sequence>\n                                \x3c!--定义name和age简单元素--\x3e\n                                <element name = "name" type = "string"></element>\n                                <element name = "age" type = "string"></element>\n                            </sequence>\n                            \n                            \x3c!--定义属性，required( 必须的)/optional( 可选的)--\x3e\n                            <attribute name="id" type="string" use="required"></attribute>\n                        </complexType>\n                        \n                    </element>\n                </sequence>\n            </complexType>\n        </element>\n        \n    </schema>\n\n    <?xml version="1.0" encoding="UTF-8" ?>\n    <persons\n        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n        xmlns="http://www.itheima.cn/javase"\n        xsi:schemaLocation="http://www.itheima.cn/javase person.xsd"\n    >\n        <person id="001">\n            <name>张三</name>\n            <age>23</age>\n        </person>\n\n    </persons>\n    ​```\n    ```\n\n### 1.7服务器改进【应用】\n\n+ 准备xml文件\n\n  1. 在当前模块下的webapp目录下新建一个文件夹，名字叫WEB-INF\n\n  2. 新建一个xml文件，名字叫web.xml\n\n  3. 将资料中的web.xml文件中引入约束的代码复制到新建的web.xml文件中\n\n  4. 将要解析的数据配置到xml文件中\n\n     ![06_配置要解析的Servlet数据](./day26-基础加强02.img/06_配置要解析的Servlet数据.png)\n\n+ 需求\n\n  把uri和servlet信息放到一个concurrentHashMap集合当中\n  当浏览器请求一个动态资源时，我们会获取uri对应的servlet来处理当前业务\n\n+ 实现步骤\n\n  1. 导入dom4j的jar包\n  2. 定义一个XmlParseServletConfig类实现ParseServletConfig接口\n  3. 在parse方法里面就可以解析xml文件了\n\n+ 代码实现\n\n  ```java\n  // web.xml配置文件中配置的信息\n  <?xml version="1.0" encoding="UTF-8" ?>\n  <web-app xmlns="http://java.sun.com/xml/ns/javaee"\n           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n           xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"\n           version="2.5">\n\n      \x3c!--在以后需要配置servlet的时候，就直接在这里配置就可以了--\x3e\n      <servlet>\n          <servlet-name>LoginServlet</servlet-name>\n          <servlet-class>com.itheima.myservlet.LoginServlet</servlet-class>\n      </servlet>\n\n      <servlet-mapping>\n          <servlet-name>LoginServlet</servlet-name>\n          <url-pattern>/servlet/loginservlet</url-pattern>\n      </servlet-mapping>\n\n  </web-app>\n\n  // 定义一个XmlParseServletConfig类实现ParseServletConfig接口\n  public class XMLParseServletConfig implements ParseServletConfig {\n      //定义web.xml文件的路径\n      private static final String WEB_XML_PATH = "http-dynamic-server/webapp/WEB-INF/web.xml";\n\n  \t//在parse方法里面就可以解析xml文件了\n      @Override\n      public void parse() {\n          try {\n              //1.创建一个解析器对象(注意:如果解析器对象等不能使用,请检查一下jar包是否导入)\n              SAXReader saxReader = new SAXReader();\n\n              //2.利用解析器把xml文件读取到内存中\n              Document document = saxReader.read(new File(WEB_XML_PATH));\n\n              //3.获取根节点元素对象\n              Element rootElement = document.getRootElement();\n\n              //创建一个Map集合，用来存储servlet的配置信息\n              HashMap<String,String> servletInfoHashMap = new HashMap<>();\n\n              //4.获取根元素对象下所有的servlet元素的对象\n              List<Element> servletInfos = rootElement.elements("servlet");\n\n              //5.遍历集合，依次获取到每一个servlet标签对象\n              for (Element servletInfo : servletInfos) {\n                  //servletInfo依次表示每一个servlet标签对象\n\n                  //获取到servlet下的servlet-name元素对象，并且获取标签体内容\n                  String servletName = servletInfo.element("servlet-name").getText();\n                  //获取到servlet下的servlet-class元素对象，并且获取标签体内容\n                  String servletClass = servletInfo.element("servlet-class").getText();\n\n                  servletInfoHashMap.put(servletName,servletClass);\n              }\n\n              //--------------------servlet-mapping--------------------------------------\n              //获取到所有的servlet-mapping标签\n              List<Element> servletMappingInfos = rootElement.elements("servlet-mapping");\n              //遍历集合依次得到每一个servlet-mapping标签\n              for (Element servletMappingInfo : servletMappingInfos) {\n                  //servletMappingInfo依次表示每一个servlet-mapping标签\n\n                  //获取servlet-mapping标签标签中的servlet-name标签的标签体内容\n                  String servletName = servletMappingInfo.element("servlet-name").getText();\n\n                  //获取servlet-mapping标签标签中的url-pattern标签的标签体内容\n                  String urlPattern = servletMappingInfo.element("url-pattern").getText();\n\n                  //通过servletName来获取到servlet的全类名\n                  String servletClassName = servletInfoHashMap.get(servletName);\n\n                  //通过反射来创建这个servlet对象\n                  Class clazz = Class.forName(servletClassName);\n\n                  //获取该类所实现的所有的接口信息,得到的是一个数组\n                  Class[] interfaces = clazz.getInterfaces();\n\n                  //定义一个boolean类型的变量\n                  boolean flag =  false;\n                  //遍历数组\n                  for (Class clazzInfo : interfaces) {\n                      //判断当前所遍历的接口的字节码对象是否和HttpServlet的字节码文件对象相同\n                      if(clazzInfo == HttpServlet.class){\n\n                          //如果相同,就需要更改flag值.结束循环\n                          flag = true;\n                          break;\n                      }\n                  }\n\n                  if(flag){\n                      //true就表示当前的类已经实现了HttpServlet接口\n                      HttpServlet httpServlet = (HttpServlet) clazz.newInstance();\n                      //4.将uri和httpServlet添加到map集合中\n                      ServletConcurrentHashMap.map.put(urlPattern,httpServlet);\n                  }else{\n                      //false就表示当前的类还没有实现HttpServlet接口\n                      throw new NotImplementsHttpServletException(clazz.getName() + "Not Implements HttpServlet");\n                  }\n              }\n          } catch (NotImplementsHttpServletException e) {\n              e.printStackTrace();\n          }catch (Exception e) {\n              e.printStackTrace();\n          }\n      }\n  }\n\n  public class LoaderResourceRunnable implements  Runnable {\n      @Override\n      public void run() {\n  //        //执行parse方法\n  //        ParseServletConfig parseServletConfig = new PropertiesParseServletConfig();\n  //        parseServletConfig.parse();\n\n          ParseServletConfig parseServletConfig = new XMLParseServletConfig();\n          parseServletConfig.parse();\n\n      }\n  }\n  ```\n\n## 2.枚举\n\n### 2.1概述【理解】\n\n为了间接的表示一些固定的值，Java就给我们提供了枚举\n是指将变量的值一一列出来,变量的值只限于列举出来的值的范围内\n\n### 2.2定义格式【应用】\n\n+ 格式\n\n  ```java\n  public enum s {   \n  \t枚举项1,枚举项2,枚举项3;\n  }\n  注意: 定义枚举类要用关键字enum\n  ```\n\n+ 示例代码\n\n  ```java\n  // 定义一个枚举类，用来表示春，夏，秋，冬这四个固定值\n  public enum Season {\n      SPRING,SUMMER,AUTUMN,WINTER;\n  }\n  ```\n\n### 2.3枚举的特点【理解】\n\n+ 特点\n\n  + 所有枚举类都是Enum的子类\n\n  + 我们可以通过"枚举类名.枚举项名称"去访问指定的枚举项\n\n  + 每一个枚举项其实就是该枚举的一个对象\n\n  + 枚举也是一个类，也可以去定义成员变量\n\n  + 枚举类的第一行上必须是枚举项，最后一个枚举项后的分号是可以省略的，但是如果枚举类有其他的东西，这个分号就不能省略。建议不要省略\n\n  + 枚举类可以有构造器，但必须是private的，它默认的也是private的。\n\n    枚举项的用法比较特殊：枚举("");\n\n  + 枚举类也可以有抽象方法，但是枚举项必须重写该方法\n\n+ 示例代码\n\n  ```java\n  public enum Season {\n\n      SPRING("春"){\n\n          //如果枚举类中有抽象方法\n          //那么在枚举项中必须要全部重写\n          @Override\n          public void show() {\n              System.out.println(this.name);\n          }\n\n      },\n\n      SUMMER("夏"){\n          @Override\n          public void show() {\n              System.out.println(this.name);\n          }\n      },\n\n      AUTUMN("秋"){\n          @Override\n          public void show() {\n              System.out.println(this.name);\n          }\n      },\n\n      WINTER("冬"){\n          @Override\n          public void show() {\n              System.out.println(this.name);\n          }\n      };\n\n      public String name;\n\n      //空参构造\n      //private Season(){}\n    \n      //有参构造\n      private Season(String name){\n          this.name = name;\n      }\n    \n      //抽象方法\n      public abstract void show();\n  }\n\n  public class EnumDemo {\n      public static void main(String[] args) {\n          /*\n          1.所有枚举类都是Enum的子类\n          2.我们可以通过"枚举类名.枚举项名称"去访问指定的枚举项\n          3.每一个枚举项其实就是该枚举的一个对象\n          4.枚举也是一个类，也可以去定义成员变量\n          5.枚举类的第一行上必须是枚举项，最后一个枚举项后的分号是可以省略的，\n            但是如果枚举类有其他的东西，这个分号就不能省略。建议不要省略\n          6.枚举类可以有构造器，但必须是private的，它默认的也是private的。\n            枚举项的用法比较特殊：枚举("");\n          7.枚举类也可以有抽象方法，但是枚举项必须重写该方法\n      */\n    \n          //第二个特点的演示\n          //我们可以通过"枚举类名.枚举项名称"去访问指定的枚举项\n          System.out.println(Season.SPRING);\n          System.out.println(Season.SUMMER);\n          System.out.println(Season.AUTUMN);\n          System.out.println(Season.WINTER);\n    \n          //第三个特点的演示\n          //每一个枚举项其实就是该枚举的一个对象\n          Season spring = Season.SPRING;\n      }\n  }\n  ```\n\n### 2.4枚举的方法【应用】\n\n+ 方法介绍\n\n  | 方法名                                      | 说明                 |\n  | ---------------------------------------- | ------------------ |\n  | String name()                            | 获取枚举项的名称           |\n  | int ordinal()                            | 返回枚举项在枚举类中的索引值     |\n  | int compareTo(E  o)                      | 比较两个枚举项，返回的是索引值的差值 |\n  | String toString()                        | 返回枚举常量的名称          |\n  | static <T> T  valueOf(Class<T> type,String  name) | 获取指定枚举类中的指定名称的枚举值  |\n  | values()                                 | 获得所有的枚举项           |\n\n+ 示例代码\n\n  ```java\n  public enum Season {\n      SPRING,SUMMER,AUTUMN,WINTER;\n  }\n\n  public class EnumDemo {\n      public static void main(String[] args) {\n  //        String name() 获取枚举项的名称\n          String name = Season.SPRING.name();\n          System.out.println(name);\n          System.out.println("-----------------------------");\n\n  //        int ordinal() 返回枚举项在枚举类中的索引值\n          int index1 = Season.SPRING.ordinal();\n          int index2 = Season.SUMMER.ordinal();\n          int index3 = Season.AUTUMN.ordinal();\n          int index4 = Season.WINTER.ordinal();\n          System.out.println(index1);\n          System.out.println(index2);\n          System.out.println(index3);\n          System.out.println(index4);\n          System.out.println("-----------------------------");\n\n  //        int compareTo(E o) 比较两个枚举项，返回的是索引值的差值\n          int result = Season.SPRING.compareTo(Season.WINTER);\n          System.out.println(result);//-3\n          System.out.println("-----------------------------");\n\n  //        String toString()   返回枚举常量的名称\n          String s = Season.SPRING.toString();\n          System.out.println(s);\n          System.out.println("-----------------------------");\n\n  //        static <T> T valueOf(Class<T> type,String name)\n  //        获取指定枚举类中的指定名称的枚举值\n          Season spring = Enum.valueOf(Season.class, "SPRING");\n          System.out.println(spring);\n          System.out.println(Season.SPRING == spring);\n          System.out.println("-----------------------------");\n\n  //        values()       获得所有的枚举项\n          Season[] values = Season.values();\n          for (Season value : values) {\n              System.out.println(value);\n          }\n      }\n  }\n  ```\n\n## 3.注解\n\n### 3.1概述【理解】\n\n+ 概述\n\n  对我们的程序进行标注和解释\n\n+ 注解和注释的区别\n\n  + 注释: 给程序员看的\n  + 注解: 给编译器看的\n\n+ 使用注解进行配置配置的优势\n\n  代码更加简洁,方便\n\n### 3.2自定义注解【理解】\n\n+ 格式\n\n  public @interface 注解名称 {\n\n  ​\tpublic 属性类型 属性名() default 默认值 ;\n\n  }\n\n+ 属性类型\n\n  + 基本数据类型\n  + String\n  + Class\n  + 注解\n  + 枚举\n  + 以上类型的一维数组\n\n+ 代码演示\n\n  ```java\n  public @interface Anno2 {\n  }\n\n  public enum Season {\n      SPRING,SUMMER,AUTUMN,WINTER;\n  }\n\n  public @interface Anno1 {\n\n      //定义一个基本类型的属性\n      int a () default 23;\n\n      //定义一个String类型的属性\n      public String name() default "itheima";\n\n      //定义一个Class类型的属性\n      public Class clazz() default Anno2.class;\n\n      //定义一个注解类型的属性\n      public Anno2 anno() default @Anno2;\n\n      //定义一个枚举类型的属性\n      public Season season() default Season.SPRING;\n\n      //以上类型的一维数组\n      //int数组\n      public int[] arr() default {1,2,3,4,5};\n\n      //枚举数组\n      public Season[] seasons() default {Season.SPRING,Season.SUMMER};\n\n      //value。后期我们在使用注解的时候，如果我们只需要给注解的value属性赋值。\n      //那么value就可以省略\n      public String value();\n\n  }\n\n  //在使用注解的时候如果注解里面的属性没有指定默认值。\n  //那么我们就需要手动给出注解属性的设置值。\n  //@Anno1(name = "itheima")\n  @Anno1("abc")\n  public class AnnoDemo {\n  }\n  ```\n\n+ 注意\n\n  如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可\n\n+ 自定义注解案例\n\n  + 需求\n\n    自定义一个注解@Test,用于指定类的方法上,如果某一个类的方法上使用了该注解,就执行该方法\n\n  + 实现步骤\n\n    1. 自定义一个注解Test,并在类中的某几个方法上加上注解\n    2. 在测试类中,获取注解所在的类的Class对象\n    3. 获取类中所有的方法对象\n    4. 遍历每一个方法对象,判断是否有对应的注解\n\n  + 代码实现\n\n    ```java\n    //表示Test这个注解的存活时间\n    @Retention(value = RetentionPolicy.RUNTIME)\n    public @interface Test {\n    }\n\n    public class UseTest {\n\n        //没有使用Test注解\n        public void show(){\n            System.out.println("UseTest....show....");\n        }\n\n        //使用Test注解\n        @Test\n        public void method(){\n            System.out.println("UseTest....method....");\n        }\n\n        //没有使用Test注解\n        @Test\n        public void function(){\n            System.out.println("UseTest....function....");\n        }\n    }\n\n    public class AnnoDemo {\n        public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException {\n            //1.通过反射获取UseTest类的字节码文件对象\n            Class clazz = Class.forName("com.itheima.myanno3.UseTest");\n\n            //创建对象\n            UseTest useTest = (UseTest) clazz.newInstance();\n\n            //2.通过反射获取这个类里面所有的方法对象\n            Method[] methods = clazz.getDeclaredMethods();\n\n            //3.遍历数组，得到每一个方法对象\n            for (Method method : methods) {\n                //method依次表示每一个方法对象。\n                //isAnnotationPresent(Class<? extends Annotation> annotationClass)\n                //判断当前方法上是否有指定的注解。\n                //参数：注解的字节码文件对象\n                //返回值：布尔结果。  true 存在  false 不存在\n                if(method.isAnnotationPresent(Test.class)){\n                    method.invoke(useTest);\n                }\n            }\n        }\n    }\n    ```\n\n### 3.3元注解【理解】\n\n+ 概述\n\n  元注解就是描述注解的注解\n\n+ 元注解介绍\n\n  | 元注解名        | 说明                    |\n  | ----------- | --------------------- |\n  | @Target     | 指定了注解能在哪里使用           |\n  | @Retention  | 可以理解为保留时间(生命周期)       |\n  | @Inherited  | 表示修饰的自定义注解可以被子类继承     |\n  | @Documented | 表示该自定义注解，会出现在API文档里面。 |\n\n+ 示例代码\n\n  ```java\n  @Target({ElementType.FIELD,ElementType.TYPE,ElementType.METHOD})  //指定注解使用的位置（成员变量，类，方法）\n  @Retention(RetentionPolicy.RUNTIME) //指定该注解的存活时间\n  //@Inherited //指定该注解可以被继承\n  public @interface Anno {\n  }\n\n  @Anno\n  public class Person {\n  }\n\n  public class Student extends Person {\n      public void show(){\n          System.out.println("student.......show..........");\n      }\n  }\n\n  public class StudentDemo {\n      public static void main(String[] args) throws ClassNotFoundException {\n          //获取到Student类的字节码文件对象\n          Class clazz = Class.forName("com.itheima.myanno4.Student");\n\n          //获取注解。\n          boolean result = clazz.isAnnotationPresent(Anno.class);\n          System.out.println(result);\n      }\n  }\n\n  ```\n\n### 3.4改写服务器【理解】\n\n+ 需求\n\n  目前项目中Servlet和url对应关系,是配置在xml文件中的,将其改为在Servlet类上通过注解配置实现\n\n+ 实现步骤\n\n  1. 定义一个注解(@WebServlet),注解内有一个属性urlPatterns\n  2. 在servlet类上去使用该注解,来指定当前Servlet的访问路径\n  3. 创建一个注解解析类(AnnoParseServletConfig),该类实现ParseServletConfig接口\n  4. 实现parse方法\n\n+ 代码实现\n\n  ```java\n  @Target(ElementType.TYPE) //指定该注解可以使用在类上\n  @Retention(RetentionPolicy.RUNTIME)//指定该注解的存活时间 --- 为运行期\n  public @interface WebServlet {\n\n      //让用户去指定某一个Servlet在进行访问的时候所对应的请求uri\n      public String urlPatterns();\n  }\n\n  // 这里只给出了LoginServlet的配置,其他Servlet同理\n  @WebServlet(urlPatterns = "/servlet/loginservlet")\n  public class LoginServlet implements HttpServlet{\n      @Override\n      public void service(HttpRequest httpRequest, HttpResponse httpResponse) {\n         //处理\n          System.out.println("LoginServlet处理了登录请求");\n\n         //响应\n          httpResponse.setContentTpye("text/html;charset=UTF-8");\n          httpResponse.write("登录成功");\n      }\n  }\n\n  public class AnnoParseServletConfig implements ParseServletConfig {\n\n      //定义一个servlet路径所对应的常量\n      public static final String SERVLET_PATH = "http-dynamic-server\\\\src\\\\com\\\\itheima\\\\myservlet";\n    \n      //定义包名\n      public static final String SERVLET_PACKAGE_NAME = "com.itheima.myservlet.";\n    \n      @Override\n      public void parse() {\n          //获取类名\n  //  1.获得servlet所在文件夹的路径，并封装成File对象\n          File file = new File(SERVLET_PATH);\n  //  2.调用listFiles方法，获取文件夹下所有的File对象\n          File[] servletFiles = file.listFiles();\n  //  3.遍历数组，获取每一个File对象\n          for (File servletFile : servletFiles) {\n  //  4.获取File对象的名字（后缀名）\n              String servletFileName = servletFile.getName().replace(".java", "");\n  //  5.根据包名 + 类名 得到每一个类的全类名\n             String servletFullName = SERVLET_PACKAGE_NAME + servletFileName;\n              try {\n  //  6.通过全类名获取字节码文件对象\n                  Class servletClazz = Class.forName(servletFullName);\n                  //  7.判断该类是否有WebServlet注解\n                  if(servletClazz.isAnnotationPresent(WebServlet.class)){\n                  //  8.判断该Servlet类是否实现HttpServlet接口\n                      //获取该类所实现的所有的接口信息,得到的是一个数组\n                      Class[] interfaces = servletClazz.getInterfaces();\n    \n                      //定义一个boolean类型的变量\n                      boolean flag =  false;\n                      //遍历数组\n                      for (Class clazzInfo : interfaces) {\n                          //判断当前所遍历的接口的字节码对象是否和HttpServlet的字节码文件对象相同\n                          if(clazzInfo == HttpServlet.class){\n                              //如果相同,就需要更改flag值.结束循环\n                              flag = true;\n                              break;\n                          }\n                      }\n    \n                      if(flag){\n                          //  9.如果满足，则获取注解中的urlPattrens的值，\n                          WebServlet annotation = (WebServlet) servletClazz.getAnnotation(WebServlet.class);\n                          String uri = annotation.urlPatterns();\n    \n                          //  10.创建当前Servlet类对象存入值位置\n                          HttpServlet httpServlet = (HttpServlet) servletClazz.newInstance();\n                          //  11.存入集合的键位置\n                          ServletConcurrentHashMap.map.put(uri,httpServlet);\n                          //\n                      }else{\n                          //  12.如果不满足，抛出异常\n                          //false就表示当前的类还没有实现HttpServlet接口\n                          throw new NotImplementsHttpServletException(servletClazz.getName() + "Not Implements HttpServlet");\n                      }\n                  }\n              } catch (NotImplementsHttpServletException e) {\n                  e.printStackTrace();\n              } catch (Exception e) {\n                  e.printStackTrace();\n              }\n          }\n\n          }\n      }\n\n  public class LoaderResourceRunnable implements  Runnable {\n      @Override\n      public void run() {\n  //        //执行parse方法\n  //        ParseServletConfig parseServletConfig = new PropertiesParseServletConfig();\n  //        parseServletConfig.parse();\n\n  //        ParseServletConfig parseServletConfig = new XMLParseServletConfig();\n  //        parseServletConfig.parse();\n\n          ParseServletConfig parseServletConfig = new AnnoParseServletConfig();\n          parseServletConfig.parse();\n    \n      }\n  }\n  ```\n\n'},"7f76":function(n,e,t){"use strict";t.r(e),e["default"]='## 1.File类\n\n### 1.1File类概述和构造方法【应用】\n\n- File类介绍\n\n  - 它是文件和目录路径名的抽象表示\n  - 文件和目录是可以通过File封装成对象的\n  - 对于File而言,其封装的并不是一个真正存在的文件,仅仅是一个路径名而已.它可以是存在的,也可以是不存在的.将来是要通过具体的操作把这个路径的内容转换为具体存在的\n\n- File类的构造方法\n\n  | 方法名                                 | 说明                               |\n  | ----------------------------------- | -------------------------------- |\n  | File(String   pathname)             | 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例 |\n  | File(String   parent, String child) | 从父路径名字符串和子路径名字符串创建新的   File实例    |\n  | File(File   parent, String child)   | 从父抽象路径名和子路径名字符串创建新的   File实例     |\n\n- 示例代码\n\n  ```java\n  public class FileDemo01 {\n      public static void main(String[] args) {\n          //File(String pathname): 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例\n          File f1 = new File("E:\\\\itcast\\\\java.txt");\n          System.out.println(f1);\n  \n          //File(String parent, String child): 从父路径名字符串和子路径名字符串创建新的 File实例\n          File f2 = new File("E:\\\\itcast","java.txt");\n          System.out.println(f2);\n  \n          //File(File parent, String child): 从父抽象路径名和子路径名字符串创建新的 File实例\n          File f3 = new File("E:\\\\itcast");\n          File f4 = new File(f3,"java.txt");\n          System.out.println(f4);\n      }\n  }\n  ```\n\n### 1.2绝对路径和相对路径【理解】\n\n+ 绝对路径\n\n  是一个完整的路径,从盘符开始\n\n+ 相对路径\n\n  是一个简化的路径,相对当前项目下的路径\n\n+ 示例代码\n\n  ```java\n  public class FileDemo02 {\n      public static void main(String[] args) {\n          // 是一个完整的路径,从盘符开始\n          File file1 = new File("D:\\\\itheima\\\\a.txt");\n  \n          // 是一个简化的路径,从当前项目根目录开始\n          File file2 = new File("a.txt");\n          File file3 = new File("模块名\\\\a.txt");\n      }\n  }\n  ```\n\n### 1.3File类创建功能【应用】\n\n- 方法分类\n\n  | 方法名                            | 说明                               |\n  | ------------------------------ | -------------------------------- |\n  | public boolean createNewFile() | 当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件 |\n  | public boolean mkdir()         | 创建由此抽象路径名命名的目录                   |\n  | public boolean mkdirs()        | 创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录    |\n\n- 示例代码\n\n  ```java\n  public class FileDemo02 {\n      public static void main(String[] args) throws IOException {\n          //需求1：我要在E:\\\\itcast目录下创建一个文件java.txt\n          File f1 = new File("E:\\\\itcast\\\\java.txt");\n          System.out.println(f1.createNewFile());\n          System.out.println("--------");\n  \n          //需求2：我要在E:\\\\itcast目录下创建一个目录JavaSE\n          File f2 = new File("E:\\\\itcast\\\\JavaSE");\n          System.out.println(f2.mkdir());\n          System.out.println("--------");\n  \n          //需求3：我要在E:\\\\itcast目录下创建一个多级目录JavaWEB\\\\HTML\n          File f3 = new File("E:\\\\itcast\\\\JavaWEB\\\\HTML");\n  //        System.out.println(f3.mkdir());\n          System.out.println(f3.mkdirs());\n          System.out.println("--------");\n  \n          //需求4：我要在E:\\\\itcast目录下创建一个文件javase.txt\n          File f4 = new File("E:\\\\itcast\\\\javase.txt");\n  //        System.out.println(f4.mkdir());\n          System.out.println(f4.createNewFile());\n      }\n  }\n  ```\n\n### 1.4File类删除功能【应用】\n\n- 方法分类\n\n  | 方法名                       | 说明                |\n  | ------------------------- | ----------------- |\n  | public boolean   delete() | 删除由此抽象路径名表示的文件或目录 |\n\n- 示例代码\n\n  ```java\n  public class FileDemo03 {\n      public static void main(String[] args) throws IOException {\n  //        File f1 = new File("E:\\\\itcast\\\\java.txt");\n          //需求1：在当前模块目录下创建java.txt文件\n          File f1 = new File("myFile\\\\java.txt");\n  //        System.out.println(f1.createNewFile());\n  \n          //需求2：删除当前模块目录下的java.txt文件\n          System.out.println(f1.delete());\n          System.out.println("--------");\n  \n          //需求3：在当前模块目录下创建itcast目录\n          File f2 = new File("myFile\\\\itcast");\n  //        System.out.println(f2.mkdir());\n  \n          //需求4：删除当前模块目录下的itcast目录\n          System.out.println(f2.delete());\n          System.out.println("--------");\n  \n          //需求5：在当前模块下创建一个目录itcast,然后在该目录下创建一个文件java.txt\n          File f3 = new File("myFile\\\\itcast");\n  //        System.out.println(f3.mkdir());\n          File f4 = new File("myFile\\\\itcast\\\\java.txt");\n  //        System.out.println(f4.createNewFile());\n  \n          //需求6：删除当前模块下的目录itcast\n          System.out.println(f4.delete());\n          System.out.println(f3.delete());\n      }\n  }\n  ```\n\n### 1.5File类判断和获取功能【应用】\n\n- 判断功能\n\n  | 方法名                            | 说明                   |\n  | ------------------------------ | -------------------- |\n  | public   boolean isDirectory() | 测试此抽象路径名表示的File是否为目录 |\n  | public   boolean isFile()      | 测试此抽象路径名表示的File是否为文件 |\n  | public   boolean   exists()    | 测试此抽象路径名表示的File是否存在  |\n\n- 获取功能\n\n  | 方法名                               | 说明                            |\n  | --------------------------------- | ----------------------------- |\n  | public   String getAbsolutePath() | 返回此抽象路径名的绝对路径名字符串             |\n  | public   String getPath()         | 将此抽象路径名转换为路径名字符串              |\n  | public   String getName()         | 返回由此抽象路径名表示的文件或目录的名称          |\n  | public   File[] listFiles()       | 返回此抽象路径名表示的目录中的文件和目录的File对象数组 |\n\n- 示例代码\n\n  ```java\n  public class FileDemo04 {\n      public static void main(String[] args) {\n          //创建一个File对象\n          File f = new File("myFile\\\\java.txt");\n  \n  //        public boolean isDirectory()：测试此抽象路径名表示的File是否为目录\n  //        public boolean isFile()：测试此抽象路径名表示的File是否为文件\n  //        public boolean exists()：测试此抽象路径名表示的File是否存在\n          System.out.println(f.isDirectory());\n          System.out.println(f.isFile());\n          System.out.println(f.exists());\n  \n  //        public String getAbsolutePath()：返回此抽象路径名的绝对路径名字符串\n  //        public String getPath()：将此抽象路径名转换为路径名字符串\n  //        public String getName()：返回由此抽象路径名表示的文件或目录的名称\n          System.out.println(f.getAbsolutePath());\n          System.out.println(f.getPath());\n          System.out.println(f.getName());\n          System.out.println("--------");\n  \n  //        public File[] listFiles()：返回此抽象路径名表示的目录中的文件和目录的File对象数组\n          File f2 = new File("E:\\\\itcast");\n          File[] fileArray = f2.listFiles();\n          for(File file : fileArray) {\n  //            System.out.println(file);\n  //            System.out.println(file.getName());\n              if(file.isFile()) {\n                  System.out.println(file.getName());\n              }\n          }\n      }\n  }\n  ```\n\n### 1.6File类练习一【应用】\n\n+ 案例需求\n\n   在当前模块下的aaa文件夹中创建一个a.txt文件\n\n+ 实现步骤\n\n  + 创建File对象,指向aaa文件夹\n  + 判断aaa文件夹是否存在,如果不存在则创建\n  + 创建File对象,指向aaa文件夹下的a.txt文件\n  + 创建这个文件\n\n+ 代码实现\n\n  ```java\n  public class Test1 {\n      public static void main(String[] args) throws IOException {\n          //练习一：在当前模块下的aaa文件夹中创建一个a.txt文件\n         /* File file = new File("filemodule\\\\aaa\\\\a.txt");\n          file.createNewFile();*/\n          //注意点:文件所在的文件夹必须要存在.\n  \n        \t//1.创建File对象,指向aaa文件夹\n          File file = new File("filemodule\\\\aaa");\n        \t//2.判断aaa文件夹是否存在,如果不存在则创建\n          if(!file.exists()){\n              //如果文件夹不存在,就创建出来\n              file.mkdirs();\n          }\n        \t//3.创建File对象,指向aaa文件夹下的a.txt文件\n          File newFile = new File(file,"a.txt");\n        \t//4.创建这个文件\n          newFile.createNewFile();\n      }\n  }\n  ```\n\n### 1.7File类练习二【应用】\n\n+ 案例需求\n\n  删除一个多级文件夹\n\n+ 实现步骤\n\n  + 定义一个方法,接收一个File对象\n  + 遍历这个File对象,获取它下边的每个文件和文件夹对象\n  + 判断当前遍历到的File对象是文件还是文件夹\n  + 如果是文件,直接删除\n  + 如果是文件夹,递归调用自己,将当前遍历到的File对象当做参数传递\n  + 参数传递过来的文件夹File对象已经处理完成,最后直接删除这个空文件夹\n\n+ 代码实现\n\n  ```java\n  public class Test2 {\n      public static void main(String[] args) {\n          //练习二：删除一个多级文件夹\n          //delete方法\n          //只能删除文件和空文件夹.\n          //如果现在要删除一个有内容的文件夹?\n          //先删掉这个文件夹里面所有的内容.\n          //最后再删除这个文件夹\n  \n          File src = new File("C:\\\\Users\\\\apple\\\\Desktop\\\\src");\n          deleteDir(src);\n      }\n    \n  \t//1.定义一个方法,接收一个File对象\n      private static void deleteDir(File src) {\n          //先删掉这个文件夹里面所有的内容.\n          //递归 方法在方法体中自己调用自己.\n          //注意: 可以解决所有文件夹和递归相结合的题目\n          //2.遍历这个File对象,获取它下边的每个文件和文件夹对象\n          File[] files = src.listFiles();\n          //3.判断当前遍历到的File对象是文件还是文件夹\n          for (File file : files) {\n              //4.如果是文件,直接删除\n              if(file.isFile()){\n                  file.delete();\n              }else{\n                  //5.如果是文件夹,递归调用自己,将当前遍历到的File对象当做参数传递\n                  deleteDir(file);//参数一定要是src文件夹里面的文件夹File对象\n              }\n          }\n          //6.参数传递过来的文件夹File对象已经处理完成,最后直接删除这个空文件夹\n          src.delete();\n      }\n  \n  }\n  ```\n\n### 1.8File类练习三【应用】\n\n+ 案例需求\n\n  统计一个文件夹中每种文件的个数并打印\n\n  打印格式如下：\n\n    \t\t\ttxt:3个\n  \t\n    \t\t\tdoc:4个\n  \t\n    \t\t\tjpg:6个\n  \t\n    \t\t\t …\n\n+ 实现步骤\n\n  + 定义一个方法,参数是HashMap集合用来统计次数和File对象要统计的文件夹\n  + 遍历File对象,获取它下边的每一个文件和文件夹对象\n  + 判断当前File对象是文件还是文件夹\n  + 如果是文件,判断这种类型文件后缀名在HashMap集合中是否出现过\n    + 没出现过,将这种类型文件的后缀名存入集合中,次数存1\n    + 出现过,获取这种类型文件的后缀名出现的次数,对其+1,在存回集合中\n  + 如果是文件夹,递归调用自己,HashMap集合就是参数集合,File对象是当前文件夹对象\n\n+ 代码实现\n\n  ```java\n  public class Test3 {\n      public static void main(String[] args) {\n          //统计一个文件夹中,每种文件出现的次数.\n          //统计 --- 定义一个变量用来统计. ---- 弊端:同时只能统计一种文件\n          //利用map集合进行数据统计,键 --- 文件后缀名  值 ----  次数\n  \n          File file = new File("filemodule");\n          HashMap<String, Integer> hm = new HashMap<>();\n          getCount(hm, file);\n          System.out.println(hm);\n      }\n    \n  \t//1.定义一个方法,参数是HashMap集合用来统计次数和File对象要统计的文件夹\n      private static void getCount(HashMap<String, Integer> hm, File file) {\n        \t//2.遍历File对象,获取它下边的每一个文件和文件夹对象\n          File[] files = file.listFiles();\n          for (File f : files) {\n            \t//3.判断当前File对象是文件还是文件夹\n              if(f.isFile()){\n                \t//如果是文件,判断这种类型文件后缀名在HashMap集合中是否出现过\n                  String fileName = f.getName();\n                  String[] fileNameArr = fileName.split("\\\\.");\n                  if(fileNameArr.length == 2){\n                      String fileEndName = fileNameArr[1];\n                      if(hm.containsKey(fileEndName)){\n                          //出现过,获取这种类型文件的后缀名出现的次数,对其+1,在存回集合中\n                          Integer count = hm.get(fileEndName);\n                          //这种文件又出现了一次.\n                          count++;\n                          //把已经出现的次数给覆盖掉.\n                          hm.put(fileEndName,count);\n                      }else{\n                          // 没出现过,将这种类型文件的后缀名存入集合中,次数存1\n                          hm.put(fileEndName,1);\n                      }\n                  }\n              }else{\n                //如果是文件夹,递归调用自己,HashMap集合就是参数集合,File对象是当前文件夹对象代码实现\n                  getCount(hm,f);\n              }\n          }\n      }\n    \n  }\n  ```\n\n## 2.字节流\n\n### 2.1 IO流概述和分类【理解】\n\n- IO流介绍\n  - IO：输入/输出(Input/Output)\n  - 流：是一种抽象概念,是对数据传输的总称.也就是说数据在设备间的传输称为流,流的本质是数据传输\n  - IO流就是用来处理设备间数据传输问题的.常见的应用: 文件复制; 文件上传; 文件下载\n- IO流的分类\n  - 按照数据的流向\n    - 输入流：读数据\n    - 输出流：写数据\n  - 按照数据类型来分\n    - 字节流\n      - 字节输入流\n      - 字节输出流\n    - 字符流\n      - 字符输入流\n      - 字符输出流\n- IO流的使用场景\n  - 如果操作的是纯文本文件,优先使用字符流\n  - 如果操作的是图片、视频、音频等二进制文件,优先使用字节流\n  - 如果不确定文件类型,优先使用字节流.字节流是万能的流\n\n### 2.2字节流写数据【应用】\n\n- 字节流抽象基类\n\n  - InputStream：这个抽象类是表示字节输入流的所有类的超类\n  - OutputStream：这个抽象类是表示字节输出流的所有类的超类\n  - 子类名特点：子类名称都是以其父类名作为子类名的后缀\n\n- 字节输出流\n\n  - FileOutputStream(String name)：创建文件输出流以指定的名称写入文件\n\n- 使用字节输出流写数据的步骤\n\n  - 创建字节输出流对象(调用系统功能创建了文件,创建字节输出流对象,让字节输出流对象指向文件)\n  - 调用字节输出流对象的写数据方法\n  - 释放资源(关闭此文件输出流并释放与此流相关联的任何系统资源)\n\n- 示例代码\n\n  ```java\n  public class FileOutputStreamDemo01 {\n      public static void main(String[] args) throws IOException {\n          //创建字节输出流对象\n        \t/*\n        \t\t注意点:\n        \t\t\t\t1.如果文件不存在,会帮我们创建\n        \t\t\t\t2.如果文件存在,会把文件清空\n        \t*/\n        \t//FileOutputStream(String name)：创建文件输出流以指定的名称写入文件\n          FileOutputStream fos = new FileOutputStream("myByteStream\\\\fos.txt");\n  \n          //void write(int b)：将指定的字节写入此文件输出流\n          fos.write(97);\n  //        fos.write(57);\n  //        fos.write(55);\n  \n          //最后都要释放资源\n          //void close()：关闭此文件输出流并释放与此流相关联的任何系统资源。\n          fos.close();\n      }\n  }\n  ```\n\n### 2.3字节流写数据的三种方式【应用】\n\n- 写数据的方法分类\n\n  | 方法名                                      | 说明                                       |\n  | ---------------------------------------- | ---------------------------------------- |\n  | void   write(int b)                      | 将指定的字节写入此文件输出流   一次写一个字节数据               |\n  | void   write(byte[] b)                   | 将 b.length字节从指定的字节数组写入此文件输出流   一次写一个字节数组数据 |\n  | void   write(byte[] b, int off, int len) | 将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流   一次写一个字节数组的部分数据 |\n\n- 示例代码\n\n  ```java\n  public class FileOutputStreamDemo02 {\n      public static void main(String[] args) throws IOException {\n          //FileOutputStream(String name)：创建文件输出流以指定的名称写入文件\n          FileOutputStream fos = new FileOutputStream("myByteStream\\\\fos.txt");\n          //FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件\n  //        FileOutputStream fos = new FileOutputStream(new File("myByteStream\\\\fos.txt"));\n  \n          //void write(int b)：将指定的字节写入此文件输出流\n  //        fos.write(97);\n  //        fos.write(98);\n  //        fos.write(99);\n  //        fos.write(100);\n  //        fos.write(101);\n  \n  //        void write(byte[] b)：将 b.length字节从指定的字节数组写入此文件输出流\n  //        byte[] bys = {97, 98, 99, 100, 101};\n          //byte[] getBytes()：返回字符串对应的字节数组\n          byte[] bys = "abcde".getBytes();\n  //        fos.write(bys);\n  \n          //void write(byte[] b, int off, int len)：将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流\n  //        fos.write(bys,0,bys.length);\n          fos.write(bys,1,3);\n  \n          //释放资源\n          fos.close();\n      }\n  }\n  ```\n\n### 2.4字节流写数据的两个小问题【应用】\n\n- 字节流写数据如何实现换行\n\n  - windows:\\rn\n  - linux:\\n\n  - mac:\\r\n\n- 字节流写数据如何实现追加写入\n\n  - public FileOutputStream(String name,boolean append)\n  - 创建文件输出流以指定的名称写入文件。如果第二个参数为true ，则字节将写入文件的末尾而不是开头\n\n- 示例代码\n\n  ```java\n  public class FileOutputStreamDemo03 {\n      public static void main(String[] args) throws IOException {\n          //创建字节输出流对象\n  //        FileOutputStream fos = new FileOutputStream("myByteStream\\\\fos.txt");\n          FileOutputStream fos = new FileOutputStream("myByteStream\\\\fos.txt",true);\n  \n          //写数据\n          for (int i = 0; i < 10; i++) {\n              fos.write("hello".getBytes());\n              fos.write("\\rn".getBytes());\n          }\n  \n          //释放资源\n          fos.close();\n      }\n  }\n  ```\n\n### 2.5字节流写数据加异常处理【应用】\n\n- 异常处理格式\n\n  - try-catch-finally\n\n    ```java\n    try{\n    \t可能出现异常的代码;\n    }catch(异常类名 变量名){\n    \t异常的处理代码;\n    }finally{\n    \t执行所有清除操作;\n    }\n    ```\n\n  - finally特点\n\n    - 被finally控制的语句一定会执行，除非JVM退出\n\n- 示例代码\n\n  ```java\n  public class FileOutputStreamDemo04 {\n      public static void main(String[] args) {\n          //加入finally来实现释放资源\n          FileOutputStream fos = null;\n          try {\n              fos = new FileOutputStream("myByteStream\\\\fos.txt");\n              fos.write("hello".getBytes());\n          } catch (IOException e) {\n              e.printStackTrace();\n          } finally {\n              if(fos != null) {\n                  try {\n                      fos.close();\n                  } catch (IOException e) {\n                      e.printStackTrace();\n                  }\n              }\n          }\n      }\n  }\n  ```\n\n### 2.6字节流读数据(一次读一个字节数据)【应用】\n\n- 字节输入流\n\n  - FileInputStream(String name)：通过打开与实际文件的连接来创建一个FileInputStream,该文件由文件系统中的路径名name命名\n\n- 字节输入流读取数据的步骤\n\n  - 创建字节输入流对象\n  - 调用字节输入流对象的读数据方法\n  - 释放资源\n\n- 示例代码\n\n  ```java\n  public class FileInputStreamDemo01 {\n      public static void main(String[] args) throws IOException {\n          //创建字节输入流对象\n          //FileInputStream(String name)\n          FileInputStream fis = new FileInputStream("myByteStream\\\\fos.txt");\n  \n          int by;\n          /*\n              fis.read()：读数据\n              by=fis.read()：把读取到的数据赋值给by\n              by != -1：判断读取到的数据是否是-1\n           */\n          while ((by=fis.read())!=-1) {\n              System.out.print((char)by);\n          }\n  \n          //释放资源\n          fis.close();\n      }\n  }\n  ```\n\n### 2.7字节流复制文件【应用】\n\n- 案例需求\n\n  ​\t把“E:\\\\itcast\\\\窗里窗外.txt”复制到模块目录下的“窗里窗外.txt”   (文件可以是任意文件)\n\n- 实现步骤\n\n  - 复制文本文件，其实就把文本文件的内容从一个文件中读取出来(数据源)，然后写入到另一个文件中(目的地)\n\n  - 数据源：\n\n    ​\tE:\\\\itcast\\\\窗里窗外.txt --- 读数据 --- InputStream --- FileInputStream \n\n  - 目的地：\n\n    ​\tmyByteStream\\\\窗里窗外.txt --- 写数据 --- OutputStream --- FileOutputStream\n\n- 代码实现\n\n  ```java\n  public class CopyTxtDemo {\n      public static void main(String[] args) throws IOException {\n          //根据数据源创建字节输入流对象\n          FileInputStream fis = new FileInputStream("E:\\\\itcast\\\\窗里窗外.txt");\n          //根据目的地创建字节输出流对象\n          FileOutputStream fos = new FileOutputStream("myByteStream\\\\窗里窗外.txt");\n  \n          //读写数据，复制文本文件(一次读取一个字节，一次写入一个字节)\n          int by;\n          while ((by=fis.read())!=-1) {\n              fos.write(by);\n          }\n  \n          //释放资源\n          fos.close();\n          fis.close();\n      }\n  }\n  ```\n\n### 2.8字节流读数据(一次读一个字节数组数据)【应用】\n\n- 一次读一个字节数组的方法\n\n  - public int read(byte[] b)：从输入流读取最多b.length个字节的数据\n  - 返回的是读入缓冲区的总字节数,也就是实际的读取字节个数\n\n- 示例代码\n\n  ```java\n  public class FileInputStreamDemo02 {\n      public static void main(String[] args) throws IOException {\n          //创建字节输入流对象\n          FileInputStream fis = new FileInputStream("myByteStream\\\\fos.txt");\n  \n          byte[] bys = new byte[1024]; //1024及其整数倍\n          int len;\n        \t//循环读取\n          while ((len=fis.read(bys))!=-1) {\n              System.out.print(new String(bys,0,len));\n          }\n  \n          //释放资源\n          fis.close();\n      }\n  }\n  ```\n\n### 2.9字节流复制文件【应用】\n\n- 案例需求\n\n  ​\t把“E:\\\\itcast\\\\mn.jpg”复制到模块目录下的“mn.jpg”  (文件可以是任意文件去)\n\n- 实现步骤\n\n  - 根据数据源创建字节输入流对象\n  - 根据目的地创建字节输出流对象\n  - 读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组)\n  - 释放资源\n\n- 代码实现\n\n  ```java\n  public class CopyJpgDemo {\n      public static void main(String[] args) throws IOException {\n          //根据数据源创建字节输入流对象\n          FileInputStream fis = new FileInputStream("E:\\\\itcast\\\\mn.jpg");\n          //根据目的地创建字节输出流对象\n          FileOutputStream fos = new FileOutputStream("myByteStream\\\\mn.jpg");\n  \n          //读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组)\n          byte[] bys = new byte[1024];\n          int len;\n          while ((len=fis.read(bys))!=-1) {\n              fos.write(bys,0,len);\n          }\n  \n          //释放资源\n          fos.close();\n          fis.close();\n      }\n  }\n  ```\n\n## 3.字节缓冲流\n\n### 3.1字节缓冲流构造方法【应用】\n\n- 字节缓冲流介绍\n\n  - lBufferOutputStream：该类实现缓冲输出流.通过设置这样的输出流,应用程序可以向底层输出流写入字节,而不必为写入的每个字节导致底层系统的调用\n  - lBufferedInputStream：创建BufferedInputStream将创建一个内部缓冲区数组.当从流中读取或跳过字节时,内部缓冲区将根据需要从所包含的输入流中重新填充,一次很多字节\n\n- 构造方法：\n\n  | 方法名                                    | 说明          |\n  | -------------------------------------- | ----------- |\n  | BufferedOutputStream(OutputStream out) | 创建字节缓冲输出流对象 |\n  | BufferedInputStream(InputStream in)    | 创建字节缓冲输入流对象 |\n\n- 示例代码\n\n  ```java\n  public class BufferStreamDemo {\n      public static void main(String[] args) throws IOException {\n          //字节缓冲输出流：BufferedOutputStream(OutputStream out)\n   \n          BufferedOutputStream bos = new BufferedOutputStream(new \t\t\t\t                                       FileOutputStream("myByteStream\\\\bos.txt"));\n          //写数据\n          bos.write("hello\\rn".getBytes());\n          bos.write("world\\rn".getBytes());\n          //释放资源\n          bos.close();\n      \n  \n          //字节缓冲输入流：BufferedInputStream(InputStream in)\n          BufferedInputStream bis = new BufferedInputStream(new                                                          FileInputStream("myByteStream\\\\bos.txt"));\n  \n          //一次读取一个字节数据\n  //        int by;\n  //        while ((by=bis.read())!=-1) {\n  //            System.out.print((char)by);\n  //        }\n  \n          //一次读取一个字节数组数据\n          byte[] bys = new byte[1024];\n          int len;\n          while ((len=bis.read(bys))!=-1) {\n              System.out.print(new String(bys,0,len));\n          }\n  \n          //释放资源\n          bis.close();\n      }\n  }\n  ```\n\n### 3.2字节缓冲流复制视频【应用】\n\n- 案例需求\n\n  把“E:\\\\itcast\\\\字节流复制图片.avi”复制到模块目录下的“字节流复制图片.avi”\n\n- 实现步骤\n\n  - 根据数据源创建字节输入流对象\n  - 根据目的地创建字节输出流对象\n  - 读写数据，复制视频\n  - 释放资源\n\n- 代码实现\n\n  ```java\n  public class CopyAviDemo {\n      public static void main(String[] args) throws IOException {\n  \n          //复制视频\n  //        method1();\n        \t method2();\n  \n      }\n  \n      //字节缓冲流一次读写一个字节数组\n      public static void method2() throws IOException {\n          BufferedInputStream bis = new BufferedInputStream(new FileInputStream("E:\\\\itcast\\\\字节流复制图片.avi"));\n          BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("myByteStream\\\\字节流复制图片.avi"));\n  \n          byte[] bys = new byte[1024];\n          int len;\n          while ((len=bis.read(bys))!=-1) {\n              bos.write(bys,0,len);\n          }\n  \n          bos.close();\n          bis.close();\n      }\n  \n      //字节缓冲流一次读写一个字节\n      public static void method1() throws IOException {\n          BufferedInputStream bis = new BufferedInputStream(new FileInputStream("E:\\\\itcast\\\\字节流复制图片.avi"));\n          BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("myByteStream\\\\字节流复制图片.avi"));\n  \n          int by;\n          while ((by=bis.read())!=-1) {\n              bos.write(by);\n          }\n  \n          bos.close();\n          bis.close();\n      }\n  \n  }\n  ```\n\n\n\n'},"806b":function(n,e,t){"use strict";t.r(e),e["default"]='> 本文来自公众号：末读代码的投稿，原文地址：https://mp.weixin.qq.com/s/AHWzboztt53ZfFZmsSnMSw  。\n\n上一篇文章介绍了 HashMap 源码，反响不错，也有很多同学发表了自己的观点，这次又来了，这次是 `ConcurrentHashMap ` 了，作为线程安全的HashMap ，它的使用频率也是很高。那么它的存储结构和实现原理是怎么样的呢？\n\n## 1. ConcurrentHashMap 1.7\n\n### 1. 存储结构\n\n> 下图存在一个笔误 Segmeng -> Segment\n\n![Java 7 ConcurrentHashMap 存储结构](ConcurrentHashMap源码+底层数据结构分析.assets/image-20200405151029416.png)\n\nJava 7 中 `ConcurrentHashMap` 的存储结构如上图，`ConcurrnetHashMap` 由很多个 `Segment`  组合，而每一个 `Segment` 是一个类似于 HashMap 的结构，所以每一个 `HashMap` 的内部可以进行扩容。但是 `Segment` 的个数一旦**初始化就不能改变**，默认 `Segment` 的个数是 16 个，你也可以认为 `ConcurrentHashMap` 默认支持最多 16 个线程并发。\n\n### 2. 初始化\n\n通过 ConcurrentHashMap 的无参构造探寻 ConcurrentHashMap 的初始化流程。\n\n```java\n    /**\n     * Creates a new, empty map with a default initial capacity (16),\n     * load factor (0.75) and concurrencyLevel (16).\n     */\n    public ConcurrentHashMap() {\n        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);\n    }\n```\n\n无参构造中调用了有参构造，传入了三个参数的默认值，他们的值是。\n\n```java\n    /**\n     * 默认初始化容量\n     */\n    static final int DEFAULT_INITIAL_CAPACITY = 16;\n\n    /**\n     * 默认负载因子\n     */\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n    /**\n     * 默认并发级别\n     */\n    static final int DEFAULT_CONCURRENCY_LEVEL = 16;\n```\n\n接着看下这个有参构造函数的内部实现逻辑。\n\n```java\n@SuppressWarnings("unchecked")\npublic ConcurrentHashMap(int initialCapacity,float loadFactor, int concurrencyLevel) {\n    // 参数校验\n    if (!(loadFactor > 0) || initialCapacity < 0 || concurrencyLevel <= 0)\n        throw new IllegalArgumentException();\n    // 校验并发级别大小，大于 1<<16，重置为 65536\n    if (concurrencyLevel > MAX_SEGMENTS)\n        concurrencyLevel = MAX_SEGMENTS;\n    // Find power-of-two sizes best matching arguments\n    // 2的多少次方\n    int sshift = 0;\n    int ssize = 1;\n    // 这个循环可以找到 concurrencyLevel 之上最近的 2的次方值\n    while (ssize < concurrencyLevel) {\n        ++sshift;\n        ssize <<= 1;\n    }\n    // 记录段偏移量\n    this.segmentShift = 32 - sshift;\n    // 记录段掩码\n    this.segmentMask = ssize - 1;\n    // 设置容量\n    if (initialCapacity > MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n    // c = 容量 / ssize ，默认 16 / 16 = 1，这里是计算每个 Segment 中的类似于 HashMap 的容量\n    int c = initialCapacity / ssize;\n    if (c * ssize < initialCapacity)\n        ++c;\n    int cap = MIN_SEGMENT_TABLE_CAPACITY;\n    //Segment 中的类似于 HashMap 的容量至少是2或者2的倍数\n    while (cap < c)\n        cap <<= 1;\n    // create segments and segments[0]\n    // 创建 Segment 数组，设置 segments[0]\n    Segment<K,V> s0 = new Segment<K,V>(loadFactor, (int)(cap * loadFactor),\n                         (HashEntry<K,V>[])new HashEntry[cap]);\n    Segment<K,V>[] ss = (Segment<K,V>[])new Segment[ssize];\n    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]\n    this.segments = ss;\n}\n```\n\n总结一下在 Java 7 中 ConcurrnetHashMap 的初始化逻辑。\n\n1. 必要参数校验。\n2. 校验并发级别 concurrencyLevel 大小，如果大于最大值，重置为最大值。无参构造**默认值是 16.**\n3. 寻找并发级别 concurrencyLevel 之上最近的 **2 的幂次方**值，作为初始化容量大小，**默认是 16**。\n4. 记录 segmentShift 偏移量，这个值为【容量 =  2 的N次方】中的 N，在后面 Put 时计算位置时会用到。**默认是 32 - sshift = 28**.\n5. 记录 segmentMask，默认是 ssize - 1 = 16 -1 = 15.\n6. **初始化 segments[0]**，**默认大小为 2**，**负载因子 0.75**，**扩容阀值是 2*0.75=1.5**，插入第二个值时才会进行扩容。\n\n### 3. put\n\n接着上面的初始化参数继续查看 put 方法源码。\n\n```java\n/**\n * Maps the specified key to the specified value in this table.\n * Neither the key nor the value can be null.\n *\n * <p> The value can be retrieved by calling the <tt>get</tt> method\n * with a key that is equal to the original key.\n *\n * @param key key with which the specified value is to be associated\n * @param value value to be associated with the specified key\n * @return the previous value associated with <tt>key</tt>, or\n *         <tt>null</tt> if there was no mapping for <tt>key</tt>\n * @throws NullPointerException if the specified key or value is null\n */\npublic V put(K key, V value) {\n    Segment<K,V> s;\n    if (value == null)\n        throw new NullPointerException();\n    int hash = hash(key);\n    // hash 值无符号右移 28位（初始化时获得），然后与 segmentMask=15 做与运算\n    // 其实也就是把高4位与segmentMask（1111）做与运算\n    int j = (hash >>> segmentShift) & segmentMask;\n    if ((s = (Segment<K,V>)UNSAFE.getObject          // nonvolatile; recheck\n         (segments, (j << SSHIFT) + SBASE)) == null) //  in ensureSegment\n        // 如果查找到的 Segment 为空，初始化\n        s = ensureSegment(j);\n    return s.put(key, hash, value, false);\n}\n\n/**\n * Returns the segment for the given index, creating it and\n * recording in segment table (via CAS) if not already present.\n *\n * @param k the index\n * @return the segment\n */\n@SuppressWarnings("unchecked")\nprivate Segment<K,V> ensureSegment(int k) {\n    final Segment<K,V>[] ss = this.segments;\n    long u = (k << SSHIFT) + SBASE; // raw offset\n    Segment<K,V> seg;\n    // 判断 u 位置的 Segment 是否为null\n    if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u)) == null) {\n        Segment<K,V> proto = ss[0]; // use segment 0 as prototype\n        // 获取0号 segment 里的 HashEntry<K,V> 初始化长度\n        int cap = proto.table.length;\n        // 获取0号 segment 里的 hash 表里的扩容负载因子，所有的 segment 的 loadFactor 是相同的\n        float lf = proto.loadFactor;\n        // 计算扩容阀值\n        int threshold = (int)(cap * lf);\n        // 创建一个 cap 容量的 HashEntry 数组\n        HashEntry<K,V>[] tab = (HashEntry<K,V>[])new HashEntry[cap];\n        if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u)) == null) { // recheck\n            // 再次检查 u 位置的 Segment 是否为null，因为这时可能有其他线程进行了操作\n            Segment<K,V> s = new Segment<K,V>(lf, threshold, tab);\n            // 自旋检查 u 位置的 Segment 是否为null\n            while ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u))\n                   == null) {\n                // 使用CAS 赋值，只会成功一次\n                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))\n                    break;\n            }\n        }\n    }\n    return seg;\n}\n```\n\n上面的源码分析了 ConcurrentHashMap 在 put 一个数据时的处理流程，下面梳理下具体流程。\n\n1. 计算要 put 的 key 的位置，获取指定位置的 Segment。\n\n2. 如果指定位置的 Segment 为空，则初始化这个 Segment.\n\n   **初始化 Segment 流程：**\n\n   1. 检查计算得到的位置的 Segment 是否为null.\n   2. 为 null 继续初始化，使用 Segment[0] 的容量和负载因子创建一个 HashEntry 数组。\n   3. 再次检查计算得到的指定位置的 Segment 是否为null.\n   4. 使用创建的 HashEntry 数组初始化这个 Segment.\n   5. 自旋判断计算得到的指定位置的 Segment 是否为null，使用 CAS 在这个位置赋值为 Segment.\n\n3. Segment.put 插入 key,value 值。\n\n上面探究了获取 Segment 段和初始化 Segment 段的操作。最后一行的 Segment 的 put 方法还没有查看，继续分析。\n\n```java\nfinal V put(K key, int hash, V value, boolean onlyIfAbsent) {\n    // 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。\n    HashEntry<K,V> node = tryLock() ? null : scanAndLockForPut(key, hash, value);\n    V oldValue;\n    try {\n        HashEntry<K,V>[] tab = table;\n        // 计算要put的数据位置\n        int index = (tab.length - 1) & hash;\n        // CAS 获取 index 坐标的值\n        HashEntry<K,V> first = entryAt(tab, index);\n        for (HashEntry<K,V> e = first;;) {\n            if (e != null) {\n                // 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value\n                K k;\n                if ((k = e.key) == key ||\n                    (e.hash == hash && key.equals(k))) {\n                    oldValue = e.value;\n                    if (!onlyIfAbsent) {\n                        e.value = value;\n                        ++modCount;\n                    }\n                    break;\n                }\n                e = e.next;\n            }\n            else {\n                // first 有值没说明 index 位置已经有值了，有冲突，链表头插法。\n                if (node != null)\n                    node.setNext(first);\n                else\n                    node = new HashEntry<K,V>(hash, key, value, first);\n                int c = count + 1;\n                // 容量大于扩容阀值，小于最大容量，进行扩容\n                if (c > threshold && tab.length < MAXIMUM_CAPACITY)\n                    rehash(node);\n                else\n                    // index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头\n                    setEntryAt(tab, index, node);\n                ++modCount;\n                count = c;\n                oldValue = null;\n                break;\n            }\n        }\n    } finally {\n        unlock();\n    }\n    return oldValue;\n}\n```\n\n由于 Segment 继承了 ReentrantLock，所以 Segment 内部可以很方便的获取锁，put 流程就用到了这个功能。\n\n1. tryLock() 获取锁，获取不到使用  **`scanAndLockForPut`** 方法继续获取。\n\n2. 计算 put 的数据要放入的 index 位置，然后获取这个位置上的 HashEntry 。\n\n3. 遍历 put 新元素，为什么要遍历？因为这里获取的 HashEntry 可能是一个空元素，也可能是链表已存在，所以要区别对待。\n\n   如果这个位置上的 **HashEntry 不存在**：\n\n   1. 如果当前容量大于扩容阀值，小于最大容量，**进行扩容**。\n   2. 直接头插法插入。\n\n   如果这个位置上的 **HashEntry 存在**：\n\n   1. 判断链表当前元素 Key 和 hash 值是否和要 put 的 key 和 hash 值一致。一致则替换值\n   2. 不一致，获取链表下一个节点，直到发现相同进行值替换，或者链表表里完毕没有相同的。\n      1. 如果当前容量大于扩容阀值，小于最大容量，**进行扩容**。\n      2. 直接链表头插法插入。\n\n4. 如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null.\n\n这里面的第一步中的 scanAndLockForPut 操作这里没有介绍，这个方法做的操作就是不断的自旋 `tryLock()` 获取锁。当自旋次数大于指定次数时，使用 `lock()` 阻塞获取锁。在自旋时顺表获取下 hash 位置的 HashEntry。\n\n```java\nprivate HashEntry<K,V> scanAndLockForPut(K key, int hash, V value) {\n    HashEntry<K,V> first = entryForHash(this, hash);\n    HashEntry<K,V> e = first;\n    HashEntry<K,V> node = null;\n    int retries = -1; // negative while locating node\n    // 自旋获取锁\n    while (!tryLock()) {\n        HashEntry<K,V> f; // to recheck first below\n        if (retries < 0) {\n            if (e == null) {\n                if (node == null) // speculatively create node\n                    node = new HashEntry<K,V>(hash, key, value, null);\n                retries = 0;\n            }\n            else if (key.equals(e.key))\n                retries = 0;\n            else\n                e = e.next;\n        }\n        else if (++retries > MAX_SCAN_RETRIES) {\n            // 自旋达到指定次数后，阻塞等到只到获取到锁\n            lock();\n            break;\n        }\n        else if ((retries & 1) == 0 &&\n                 (f = entryForHash(this, hash)) != first) {\n            e = first = f; // re-traverse if entry changed\n            retries = -1;\n        }\n    }\n    return node;\n}\n\n```\n\n### 4. 扩容 rehash\n\nConcurrentHashMap 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 index+ oldSize，参数里的 node 会在扩容之后使用链表**头插法**插入到指定位置。\n\n```java\nprivate void rehash(HashEntry<K,V> node) {\n    HashEntry<K,V>[] oldTable = table;\n    // 老容量\n    int oldCapacity = oldTable.length;\n    // 新容量，扩大两倍\n    int newCapacity = oldCapacity << 1;\n    // 新的扩容阀值 \n    threshold = (int)(newCapacity * loadFactor);\n    // 创建新的数组\n    HashEntry<K,V>[] newTable = (HashEntry<K,V>[]) new HashEntry[newCapacity];\n    // 新的掩码，默认2扩容后是4，-1是3，二进制就是11。\n    int sizeMask = newCapacity - 1;\n    for (int i = 0; i < oldCapacity ; i++) {\n        // 遍历老数组\n        HashEntry<K,V> e = oldTable[i];\n        if (e != null) {\n            HashEntry<K,V> next = e.next;\n            // 计算新的位置，新的位置只可能是不便或者是老的位置+老的容量。\n            int idx = e.hash & sizeMask;\n            if (next == null)   //  Single node on list\n                // 如果当前位置还不是链表，只是一个元素，直接赋值\n                newTable[idx] = e;\n            else { // Reuse consecutive sequence at same slot\n                // 如果是链表了\n                HashEntry<K,V> lastRun = e;\n                int lastIdx = idx;\n                // 新的位置只可能是不便或者是老的位置+老的容量。\n                // 遍历结束后，lastRun 后面的元素位置都是相同的\n                for (HashEntry<K,V> last = next; last != null; last = last.next) {\n                    int k = last.hash & sizeMask;\n                    if (k != lastIdx) {\n                        lastIdx = k;\n                        lastRun = last;\n                    }\n                }\n                // ，lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。\n                newTable[lastIdx] = lastRun;\n                // Clone remaining nodes\n                for (HashEntry<K,V> p = e; p != lastRun; p = p.next) {\n                    // 遍历剩余元素，头插法到指定 k 位置。\n                    V v = p.value;\n                    int h = p.hash;\n                    int k = h & sizeMask;\n                    HashEntry<K,V> n = newTable[k];\n                    newTable[k] = new HashEntry<K,V>(h, p.key, v, n);\n                }\n            }\n        }\n    }\n    // 头插法插入新的节点\n    int nodeIndex = node.hash & sizeMask; // add the new node\n    node.setNext(newTable[nodeIndex]);\n    newTable[nodeIndex] = node;\n    table = newTable;\n}\n```\n\n有些同学可能会对最后的两个 for 循环有疑惑，这里第一个 for 是为了寻找这样一个节点，这个节点后面的所有 next 节点的新位置都是相同的。然后把这个作为一个链表赋值到新位置。第二个 for 循环是为了把剩余的元素通过头插法插入到指定位置链表。这样实现的原因可能是基于概率统计，有深入研究的同学可以发表下意见。\n\n### 5. get\n\n到这里就很简单了，get 方法只需要两步即可。\n\n1. 计算得到 key 的存放位置。\n2. 遍历指定位置查找相同 key 的 value 值。\n\n```java\npublic V get(Object key) {\n    Segment<K,V> s; // manually integrate access methods to reduce overhead\n    HashEntry<K,V>[] tab;\n    int h = hash(key);\n    long u = (((h >>> segmentShift) & segmentMask) << SSHIFT) + SBASE;\n    // 计算得到 key 的存放位置\n    if ((s = (Segment<K,V>)UNSAFE.getObjectVolatile(segments, u)) != null &&\n        (tab = s.table) != null) {\n        for (HashEntry<K,V> e = (HashEntry<K,V>) UNSAFE.getObjectVolatile\n                 (tab, ((long)(((tab.length - 1) & h)) << TSHIFT) + TBASE);\n             e != null; e = e.next) {\n            // 如果是链表，遍历查找到相同 key 的 value。\n            K k;\n            if ((k = e.key) == key || (e.hash == h && key.equals(k)))\n                return e.value;\n        }\n    }\n    return null;\n}\n```\n\n## 2. ConcurrentHashMap 1.8\n\n### 1. 存储结构\n\n![Java8 ConcurrentHashMap 存储结构（图片来自 javadoop）](ConcurrentHashMap源码+底层数据结构分析.assets/java8_concurrenthashmap.png)\n\n可以发现 Java8 的 ConcurrentHashMap  相对于 Java7 来说变化比较大，不再是之前的 **Segment 数组 + HashEntry 数组 + 链表**，而是 **Node 数组 + 链表 / 红黑树**。当冲突链表达到一定长度时，链表会转换成红黑树。\n\n### 2. 初始化 initTable\n\n```java\n/**\n * Initializes table, using the size recorded in sizeCtl.\n */\nprivate final Node<K,V>[] initTable() {\n    Node<K,V>[] tab; int sc;\n    while ((tab = table) == null || tab.length == 0) {\n        ／／　如果 sizeCtl < 0 ,说明另外的线程执行CAS 成功，正在进行初始化。\n        if ((sc = sizeCtl) < 0)\n            // 让出 CPU 使用权\n            Thread.yield(); // lost initialization race; just spin\n        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\n            try {\n                if ((tab = table) == null || tab.length == 0) {\n                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY;\n                    @SuppressWarnings("unchecked")\n                    Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n                    table = tab = nt;\n                    sc = n - (n >>> 2);\n                }\n            } finally {\n                sizeCtl = sc;\n            }\n            break;\n        }\n    }\n    return tab;\n}\n```\n\n从源码中可以发现 ConcurrentHashMap 的初始化是通过**自旋和 CAS** 操作完成的。里面需要注意的是变量 `sizeCtl` ，它的值决定着当前的初始化状态。\n\n1. -1  说明正在初始化\n2. -N 说明有N-1个线程正在进行扩容\n3. 表示 table 初始化大小，如果 table 没有初始化\n4. 表示 table 容量，如果 table　已经初始化。\n\n### 3. put\n\n直接过一遍 put 源码。\n\n```java\npublic V put(K key, V value) {\n    return putVal(key, value, false);\n}\n\n/** Implementation for put and putIfAbsent */\nfinal V putVal(K key, V value, boolean onlyIfAbsent) {\n    // key 和 value 不能为空\n    if (key == null || value == null) throw new NullPointerException();\n    int hash = spread(key.hashCode());\n    int binCount = 0;\n    for (Node<K,V>[] tab = table;;) {\n        // f = 目标位置元素\n        Node<K,V> f; int n, i, fh;// fh 后面存放目标位置的元素 hash 值\n        if (tab == null || (n = tab.length) == 0)\n            // 数组桶为空，初始化数组桶（自旋+CAS)\n            tab = initTable();\n        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n            // 桶内为空，CAS 放入，不加锁，成功了就直接 break 跳出\n            if (casTabAt(tab, i, null,new Node<K,V>(hash, key, value, null)))\n                break;  // no lock when adding to empty bin\n        }\n        else if ((fh = f.hash) == MOVED)\n            tab = helpTransfer(tab, f);\n        else {\n            V oldVal = null;\n            // 使用 synchronized 加锁加入节点\n            synchronized (f) {\n                if (tabAt(tab, i) == f) {\n                    // 说明是链表\n                    if (fh >= 0) {\n                        binCount = 1;\n                        // 循环加入新的或者覆盖节点\n                        for (Node<K,V> e = f;; ++binCount) {\n                            K ek;\n                            if (e.hash == hash &&\n                                ((ek = e.key) == key ||\n                                 (ek != null && key.equals(ek)))) {\n                                oldVal = e.val;\n                                if (!onlyIfAbsent)\n                                    e.val = value;\n                                break;\n                            }\n                            Node<K,V> pred = e;\n                            if ((e = e.next) == null) {\n                                pred.next = new Node<K,V>(hash, key,\n                                                          value, null);\n                                break;\n                            }\n                        }\n                    }\n                    else if (f instanceof TreeBin) {\n                        // 红黑树\n                        Node<K,V> p;\n                        binCount = 2;\n                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n                                                       value)) != null) {\n                            oldVal = p.val;\n                            if (!onlyIfAbsent)\n                                p.val = value;\n                        }\n                    }\n                }\n            }\n            if (binCount != 0) {\n                if (binCount >= TREEIFY_THRESHOLD)\n                    treeifyBin(tab, i);\n                if (oldVal != null)\n                    return oldVal;\n                break;\n            }\n        }\n    }\n    addCount(1L, binCount);\n    return null;\n}\n```\n\n1. 根据 key 计算出 hashcode 。\n\n2. 判断是否需要进行初始化。\n\n3. 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。\n\n4. 如果当前位置的 `hashcode == MOVED == -1`,则需要进行扩容。\n\n5. 如果都不满足，则利用 synchronized 锁写入数据。\n\n6. 如果数量大于 `TREEIFY_THRESHOLD` 则要转换为红黑树。\n\n### 4. get\n\nget 流程比较简单，直接过一遍源码。\n\n```java\npublic V get(Object key) {\n    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;\n    // key 所在的 hash 位置\n    int h = spread(key.hashCode());\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (e = tabAt(tab, (n - 1) & h)) != null) {\n        // 如果指定位置元素存在，头结点hash值相同\n        if ((eh = e.hash) == h) {\n            if ((ek = e.key) == key || (ek != null && key.equals(ek)))\n                // key hash 值相等，key值相同，直接返回元素 value\n                return e.val;\n        }\n        else if (eh < 0)\n            // 头结点hash值小于0，说明正在扩容或者是红黑树，find查找\n            return (p = e.find(h, key)) != null ? p.val : null;\n        while ((e = e.next) != null) {\n            // 是链表，遍历查找\n            if (e.hash == h &&\n                ((ek = e.key) == key || (ek != null && key.equals(ek))))\n                return e.val;\n        }\n    }\n    return null;\n}\n```\n\n总结一下 get 过程：\n\n1. 根据 hash 值计算位置。\n2. 查找到指定位置，如果头节点就是要找的，直接返回它的 value.\n3. 如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，查找之。\n4. 如果是链表，遍历查找之。\n\n总结：\n\n总的来说 ConcurrentHashMap 在 Java8 中相对于 Java7 来说变化还是挺大的，\n\n## 3.  总结\n\nJava7 中 ConcurrentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。\n\nJava8 中的 ConcurrentHashMap  使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 **Segment 数组 + HashEntry 数组 + 链表** 进化成了  **Node 数组 + 链表 / 红黑树**，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。\n\n有些同学可能对 Synchronized 的性能存在疑问，其实 Synchronized 锁自从引入锁升级策略后，性能不再是问题，有兴趣的同学可以自己了解下 Synchronized 的**锁升级**。\n'},8187:function(n,e,t){"use strict";t.r(e),e["default"]='# 附件1：POM文件总体配置说明\r\n\r\n```xml\r\n<project xmlns="http://maven.apache.org/POM/4.0.0" \r\nxmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" \r\nxsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd "> \r\n\r\n    \x3c!-- 父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。\r\n         坐标包括group ID，artifact ID和 version。 --\x3e \r\n    <parent> \r\n        \x3c!-- 被继承的父项目的构件标识符 --\x3e \r\n        <artifactId>xxx</artifactId>\r\n\r\n        \x3c!-- 被继承的父项目的全球唯一标识符 --\x3e\r\n        <groupId>xxx</groupId> \r\n\r\n        \x3c!-- 被继承的父项目的版本 --\x3e \r\n        <version>xxx</version>\r\n\r\n        \x3c!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。\r\n             Maven首先在构建当前项目的地方寻找父项目的pom，其次在文件系统的这个位置（relativePath位置），\r\n             然后在本地仓库，最后在远程仓库寻找父项目的pom。 --\x3e \r\n        <relativePath>xxx</relativePath> \r\n    </parent> \r\n\r\n    \x3c!-- 声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，\r\n         这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --\x3e \r\n    <modelVersion> 4.0.0 </modelVersion> \r\n\r\n    \x3c!-- 项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， \r\n         如com.mycompany.app生成的相对路径为：/com/mycompany/app --\x3e \r\n    <groupId>xxx</groupId> \r\n\r\n    \x3c!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID\r\n         和groupID；在某个特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven\r\n         为项目产生的构件包括：JARs，源码，二进制发布和WARs等。 --\x3e \r\n    <artifactId>xxx</artifactId> \r\n\r\n    \x3c!-- 项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --\x3e \r\n    <packaging> jar </packaging> \r\n\r\n    \x3c!-- 项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --\x3e \r\n    <version> 1.0-SNAPSHOT </version> \r\n\r\n    \x3c!-- 项目的名称, Maven产生的文档用 --\x3e \r\n    <name> xxx-maven </name> \r\n\r\n    \x3c!-- 项目主页的URL, Maven产生的文档用 --\x3e \r\n    <url> http://maven.apache.org </url> \r\n\r\n    \x3c!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，\r\n         就可以包含HTML标签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的\r\n         索引页文件，而不是调整这里的文档。 --\x3e \r\n    <description> A maven project to study maven. </description> \r\n\r\n    \x3c!-- 描述了这个项目构建环境中的前提条件。 --\x3e \r\n    <prerequisites> \r\n        \x3c!-- 构建该项目或使用该插件所需要的Maven的最低版本 --\x3e \r\n        <maven></maven> \r\n    </prerequisites> \r\n\r\n    \x3c!-- 项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --\x3e \r\n    <issueManagement> \r\n        \x3c!-- 问题管理系统（例如jira）的名字， --\x3e \r\n        <system> jira </system> \r\n\r\n        \x3c!-- 该项目使用的问题管理系统的URL --\x3e \r\n        <url> http://jira.baidu.com/banseon </url> \r\n    </issueManagement> \r\n\r\n    \x3c!-- 项目持续集成信息 --\x3e \r\n    <ciManagement> \r\n        \x3c!-- 持续集成系统的名字，例如continuum --\x3e \r\n        <system></system> \r\n\r\n        \x3c!-- 该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --\x3e \r\n        <url></url> \r\n\r\n        \x3c!-- 构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --\x3e \r\n        <notifiers> \r\n            \x3c!-- 配置一种方式，当构建中断时，以该方式通知用户/开发者 --\x3e \r\n            <notifier> \r\n                \x3c!-- 传送通知的途径 --\x3e \r\n                <type></type> \r\n\r\n                \x3c!-- 发生错误时是否通知 --\x3e \r\n                <sendOnError></sendOnError> \r\n\r\n                \x3c!-- 构建失败时是否通知 --\x3e \r\n                <sendOnFailure></sendOnFailure> \r\n\r\n                \x3c!-- 构建成功时是否通知 --\x3e \r\n                <sendOnSuccess></sendOnSuccess> \r\n\r\n                \x3c!-- 发生警告时是否通知 --\x3e \r\n                <sendOnWarning></sendOnWarning> \r\n\r\n                \x3c!-- 不赞成使用。通知发送到哪里 --\x3e \r\n                <address></address> \r\n\r\n                \x3c!-- 扩展配置项 --\x3e \r\n                <configuration></configuration> \r\n            </notifier> \r\n        </notifiers> \r\n    </ciManagement> \r\n\r\n    \x3c!-- 项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --\x3e \r\n    <inceptionYear /> \r\n\r\n    \x3c!-- 项目相关邮件列表信息 --\x3e \r\n    <mailingLists> \r\n        \x3c!-- 该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --\x3e \r\n        <mailingList> \r\n            \x3c!-- 邮件的名称 --\x3e \r\n            <name> Demo </name> \r\n\r\n            \x3c!-- 发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --\x3e \r\n            <post> banseon@126.com </post> \r\n\r\n            \x3c!-- 订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --\x3e \r\n            <subscribe> banseon@126.com </subscribe> \r\n\r\n            \x3c!-- 取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --\x3e \r\n            <unsubscribe> banseon@126.com </unsubscribe> \r\n\r\n            \x3c!-- 你可以浏览邮件信息的URL --\x3e \r\n            <archive> http:/hi.baidu.com/banseon/demo/dev/ </archive> \r\n        </mailingList> \r\n    </mailingLists> \r\n\r\n    \x3c!-- 项目开发者列表 --\x3e \r\n    <developers> \r\n        \x3c!-- 某个项目开发者的信息 --\x3e \r\n        <developer> \r\n            \x3c!-- SCM里项目开发者的唯一标识符 --\x3e \r\n            <id> HELLO WORLD </id>\r\n            \r\n            \x3c!-- 项目开发者的全名 --\x3e \r\n            <name> banseon </name> \r\n\r\n            \x3c!-- 项目开发者的email --\x3e \r\n            <email> banseon@126.com </email> \r\n\r\n            \x3c!-- 项目开发者的主页的URL --\x3e \r\n            <url></url> \r\n\r\n            \x3c!-- 项目开发者在项目中扮演的角色，角色元素描述了各种角色 --\x3e \r\n            <roles> \r\n                <role> Project Manager </role> \r\n                <role> Architect </role> \r\n            </roles> \r\n\r\n            \x3c!-- 项目开发者所属组织 --\x3e \r\n            <organization> demo </organization> \r\n\r\n            \x3c!-- 项目开发者所属组织的URL --\x3e \r\n            <organizationUrl> http://hi.baidu.com/xxx </organizationUrl> \r\n\r\n            \x3c!-- 项目开发者属性，如即时消息如何处理等 --\x3e \r\n            <properties> \r\n                <dept> No </dept> \r\n            </properties> \r\n\r\n            \x3c!-- 项目开发者所在时区， -11到12范围内的整数。 --\x3e \r\n            <timezone> -5 </timezone> \r\n        </developer> \r\n    </developers> \r\n\r\n    \x3c!-- 项目的其他贡献者列表 --\x3e \r\n    <contributors> \r\n        \x3c!-- 项目的其他贡献者。参见developers/developer元素 --\x3e \r\n        <contributor> \r\n            \x3c!-- 项目贡献者的全名 --\x3e \r\n            <name></name>\r\n\r\n            \x3c!-- 项目贡献者的email --\x3e\r\n            <email></email>\r\n\r\n            \x3c!-- 项目贡献者的主页的URL --\x3e\r\n            <url></url>\r\n\r\n            \x3c!-- 项目贡献者所属组织 --\x3e\r\n            <organization></organization>\r\n\r\n            \x3c!-- 项目贡献者所属组织的URL --\x3e\r\n            <organizationUrl></organizationUrl>\r\n\r\n            \x3c!-- 项目贡献者在项目中扮演的角色，角色元素描述了各种角色 --\x3e \r\n            <roles> \r\n                <role> Project Manager </role> \r\n                <role> Architect </role> \r\n            </roles>\r\n\r\n            \x3c!-- 项目贡献者所在时区， -11到12范围内的整数。 --\x3e \r\n            <timezone></timezone>\r\n            \r\n            \x3c!-- 项目贡献者属性，如即时消息如何处理等 --\x3e \r\n            <properties> \r\n                <dept> No </dept> \r\n            </properties>  \r\n        </contributor> \r\n    </contributors> \r\n\r\n    \x3c!-- 该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。\r\n         如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --\x3e \r\n    <licenses> \r\n        \x3c!-- 描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --\x3e \r\n        <license> \r\n            \x3c!-- license用于法律上的名称 --\x3e \r\n            <name> Apache 2 </name> \r\n\r\n            \x3c!-- 官方的license正文页面的URL --\x3e \r\n            <url> http://www.baidu.com/banseon/LICENSE-2.0.txt </url> \r\n\r\n            \x3c!-- 项目分发的主要方式： \r\n                    repo，可以从Maven库下载 \r\n                    manual， 用户必须手动下载和安装依赖 --\x3e \r\n            <distribution> repo </distribution> \r\n\r\n            \x3c!-- 关于license的补充信息 --\x3e \r\n            <comments> A business-friendly OSS license </comments> \r\n        </license> \r\n    </licenses> \r\n\r\n    \x3c!-- SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --\x3e \r\n    <scm> \r\n        \x3c!-- SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --\x3e \r\n        <connection> \r\n            scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk)\r\n        </connection> \r\n\r\n        \x3c!-- 给开发者使用的，类似connection元素。即该连接不仅仅只读 --\x3e \r\n        <developerConnection> \r\n            scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk \r\n        </developerConnection> \r\n\r\n        \x3c!-- 当前代码的标签，在开发阶段默认为HEAD --\x3e \r\n        <tag></tag> \r\n\r\n        \x3c!-- 指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --\x3e \r\n        <url> http://svn.baidu.com/banseon </url> \r\n    </scm> \r\n\r\n    \x3c!-- 描述项目所属组织的各种属性。Maven产生的文档用 --\x3e \r\n    <organization> \r\n        \x3c!-- 组织的全名 --\x3e \r\n        <name> demo </name> \r\n\r\n        \x3c!-- 组织主页的URL --\x3e \r\n        <url> http://www.baidu.com/banseon </url> \r\n    </organization> \r\n\r\n    \x3c!-- 构建项目需要的信息 --\x3e \r\n    <build> \r\n        \x3c!-- 该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对\r\n             于pom.xml的相对路径。 --\x3e \r\n        <sourceDirectory></sourceDirectory> \r\n\r\n        \x3c!-- 该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容会\r\n             被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --\x3e \r\n        <scriptSourceDirectory></scriptSourceDirectory> \r\n\r\n        \x3c!-- 该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。\r\n             该路径是相对于pom.xml的相对路径。 --\x3e \r\n        <testSourceDirectory></testSourceDirectory> \r\n\r\n        \x3c!-- 被编译过的应用程序class文件存放的目录。 --\x3e \r\n        <outputDirectory></outputDirectory> \r\n\r\n        \x3c!-- 被编译过的测试class文件存放的目录。 --\x3e \r\n        <testOutputDirectory></testOutputDirectory> \r\n\r\n        \x3c!-- 使用来自该项目的一系列构建扩展 --\x3e \r\n        <extensions> \r\n            \x3c!-- 描述使用到的构建扩展。 --\x3e \r\n            <extension> \r\n                \x3c!-- 构建扩展的groupId --\x3e \r\n                <groupId></groupId> \r\n\r\n                \x3c!-- 构建扩展的artifactId --\x3e \r\n                <artifactId></artifactId> \r\n\r\n                \x3c!-- 构建扩展的版本 --\x3e \r\n                <version></version> \r\n            </extension> \r\n        </extensions> \r\n\r\n        \x3c!-- 当项目没有规定目标（Maven2 叫做阶段）时的默认值 --\x3e \r\n        <defaultGoal></defaultGoal> \r\n\r\n        \x3c!-- 这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在\r\n             最终的打包文件里。 --\x3e \r\n        <resources> \r\n            \x3c!-- 这个元素描述了项目相关或测试相关的所有资源路径 --\x3e \r\n            <resource> \r\n                \x3c!-- 描述了资源的目标路径。该路径相对target/classes目录（例如${project.build.outputDirectory}）。\r\n                     举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为\r\n                    org/apache/maven/messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --\x3e \r\n                <targetPath></targetPath> \r\n\r\n                \x3c!-- 是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素\r\n                     里列出。 --\x3e \r\n                <filtering></filtering>\r\n\r\n                \x3c!-- 描述存放资源的目录，该路径相对POM路径 --\x3e \r\n                <directory></directory>\r\n\r\n                \x3c!-- 包含的模式列表，例如**/*.xml. --\x3e \r\n                <includes>\r\n                    <include></include>\r\n                </includes>\r\n\r\n                \x3c!-- 排除的模式列表，例如**/*.xml --\x3e\r\n                <excludes>\r\n                    <exclude></exclude>\r\n                </excludes>\r\n            </resource> \r\n        </resources> \r\n\r\n        \x3c!-- 这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --\x3e \r\n        <testResources> \r\n            \x3c!-- 这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --\x3e \r\n            <testResource> \r\n                \x3c!-- 描述了测试相关的资源的目标路径。该路径相对target/classes目录（例如${project.build.outputDirectory}）。\r\n                     举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为\r\n                    org/apache/maven/messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --\x3e \r\n                <targetPath></targetPath> \r\n\r\n                \x3c!-- 是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素\r\n                     里列出。 --\x3e \r\n                <filtering></filtering>\r\n\r\n                \x3c!-- 描述存放测试相关的资源的目录，该路径相对POM路径 --\x3e \r\n                <directory></directory>\r\n\r\n                \x3c!-- 包含的模式列表，例如**/*.xml. --\x3e \r\n                <includes>\r\n                    <include></include>\r\n                </includes>\r\n\r\n                \x3c!-- 排除的模式列表，例如**/*.xml --\x3e\r\n                <excludes>\r\n                    <exclude></exclude>\r\n                </excludes> \r\n            </testResource> \r\n        </testResources> \r\n\r\n        \x3c!-- 构建产生的所有文件存放的目录 --\x3e \r\n        <directory></directory> \r\n\r\n        \x3c!-- 产生的构件的文件名，默认值是${artifactId}-${version}。 --\x3e \r\n        <finalName></finalName> \r\n\r\n        \x3c!-- 当filtering开关打开时，使用到的过滤器属性文件列表 --\x3e \r\n        <filters></filters> \r\n\r\n        \x3c!-- 子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本\r\n             地配置都会覆盖这里的配置 --\x3e \r\n        <pluginManagement> \r\n            \x3c!-- 使用的插件列表 。 --\x3e \r\n            <plugins> \r\n                \x3c!-- plugin元素包含描述插件所需要的信息。 --\x3e \r\n                <plugin> \r\n                    \x3c!-- 插件在仓库里的group ID --\x3e \r\n                    <groupId></groupId> \r\n\r\n                    \x3c!-- 插件在仓库里的artifact ID --\x3e \r\n                    <artifactId></artifactId> \r\n\r\n                    \x3c!-- 被使用的插件的版本（或版本范围） --\x3e \r\n                    <version></version> \r\n\r\n                    \x3c!-- 是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该\r\n                         元素才被设置成enabled。 --\x3e \r\n                    <extensions>true/false</extensions> \r\n\r\n                    \x3c!-- 在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --\x3e \r\n                    <executions> \r\n                        \x3c!-- execution元素包含了插件执行需要的信息 --\x3e \r\n                        <execution> \r\n                            \x3c!-- 执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --\x3e \r\n                            <id></id>\r\n\r\n                            \x3c!-- 绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --\x3e \r\n                            <phase></phase>\r\n\r\n                            \x3c!-- 配置的执行目标 --\x3e \r\n                            <goals></goals> \r\n\r\n                            \x3c!-- 配置是否被传播到子POM --\x3e \r\n                            <inherited>true/false</inherited> \r\n\r\n                            \x3c!-- 作为DOM对象的配置 --\x3e \r\n                            <configuration></configuration>\r\n                        </execution> \r\n                    </executions> \r\n\r\n                    \x3c!-- 项目引入插件所需要的额外依赖 --\x3e \r\n                    <dependencies>\r\n                        \x3c!-- 参见dependencies/dependency元素 --\x3e \r\n                        <dependency> \r\n                        </dependency> \r\n                    </dependencies> \r\n\r\n                    \x3c!-- 任何配置是否被传播到子项目 --\x3e \r\n                    <inherited>true/false</inherited>\r\n\r\n                    \x3c!-- 作为DOM对象的配置 --\x3e \r\n                    <configuration></configuration>\r\n                </plugin> \r\n            </plugins> \r\n        </pluginManagement> \r\n\r\n        \x3c!-- 该项目使用的插件列表 。 --\x3e \r\n        <plugins> \r\n            \x3c!-- plugin元素包含描述插件所需要的信息。 --\x3e \r\n            <plugin> \r\n                \x3c!-- 插件在仓库里的group ID --\x3e \r\n                <groupId></groupId> \r\n\r\n                \x3c!-- 插件在仓库里的artifact ID --\x3e \r\n                <artifactId></artifactId> \r\n\r\n                \x3c!-- 被使用的插件的版本（或版本范围） --\x3e \r\n                <version></version> \r\n\r\n                \x3c!-- 是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该\r\n                     元素才被设置成enabled。 --\x3e \r\n                <extensions>true/false</extensions> \r\n\r\n                \x3c!-- 在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --\x3e \r\n                <executions> \r\n                    \x3c!-- execution元素包含了插件执行需要的信息 --\x3e \r\n                    <execution> \r\n                        \x3c!-- 执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --\x3e \r\n                        <id></id>\r\n\r\n                        \x3c!-- 绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --\x3e \r\n                        <phase></phase>\r\n\r\n                        \x3c!-- 配置的执行目标 --\x3e \r\n                        <goals></goals> \r\n\r\n                        \x3c!-- 配置是否被传播到子POM --\x3e \r\n                        <inherited>true/false</inherited> \r\n\r\n                        \x3c!-- 作为DOM对象的配置 --\x3e \r\n                        <configuration></configuration>\r\n                    </execution> \r\n                </executions> \r\n\r\n                \x3c!-- 项目引入插件所需要的额外依赖 --\x3e \r\n                <dependencies>\r\n                    \x3c!-- 参见dependencies/dependency元素 --\x3e \r\n                    <dependency> \r\n                    </dependency> \r\n                </dependencies> \r\n\r\n                \x3c!-- 任何配置是否被传播到子项目 --\x3e \r\n                <inherited>true/false</inherited> \r\n\r\n                \x3c!-- 作为DOM对象的配置 --\x3e \r\n                <configuration></configuration> \r\n            </plugin> \r\n        </plugins>\r\n    </build> \r\n\r\n    \x3c!-- 在列的项目构建profile，如果被激活，会修改构建处理 --\x3e \r\n    <profiles> \r\n        \x3c!-- 根据环境参数或命令行参数激活某个构建处理 --\x3e \r\n        <profile> \r\n            \x3c!-- 构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --\x3e \r\n            <id></id>\r\n\r\n            \x3c!-- 自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它能够\r\n                 在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元\r\n                 素并不是激活profile的唯一方式。 --\x3e \r\n            <activation> \r\n                \x3c!-- profile默认是否激活的标志 --\x3e \r\n                <activeByDefault>true/false</activeByDefault> \r\n\r\n                \x3c!-- 当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本\r\n                     不是以1.4开头的JDK。 --\x3e \r\n                <jdk>jdk版本，如:1.7</jdk> \r\n\r\n                \x3c!-- 当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --\x3e \r\n                <os> \r\n                    \x3c!-- 激活profile的操作系统的名字 --\x3e \r\n                    <name> Windows XP </name> \r\n\r\n                    \x3c!-- 激活profile的操作系统所属家族(如 \'windows\') --\x3e \r\n                    <family> Windows </family> \r\n\r\n                    \x3c!-- 激活profile的操作系统体系结构 --\x3e \r\n                    <arch> x86 </arch> \r\n\r\n                    \x3c!-- 激活profile的操作系统版本 --\x3e \r\n                    <version> 5.1.2600 </version> \r\n                </os> \r\n\r\n                \x3c!-- 如果Maven检测到某一个属性（其值可以在POM中通过${名称}引用），其拥有对应的名称和值，Profile\r\n                     就会被激活。如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹\r\n                     配属性值字段 --\x3e \r\n                <property> \r\n                    \x3c!-- 激活profile的属性的名称 --\x3e \r\n                    <name> mavenVersion </name> \r\n\r\n                    \x3c!-- 激活profile的属性的值 --\x3e \r\n                    <value> 2.0.3 </value> \r\n                </property> \r\n\r\n                \x3c!-- 提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 \r\n                     profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --\x3e \r\n                <file> \r\n                    \x3c!-- 如果指定的文件存在，则激活profile。 --\x3e \r\n                    <exists> /usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ </exists> \r\n\r\n                    \x3c!-- 如果指定的文件不存在，则激活profile。 --\x3e \r\n                    <missing> /usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ </missing> \r\n                </file> \r\n            </activation> \r\n\r\n            \x3c!-- 构建项目所需要的信息。参见build元素 --\x3e \r\n            <build> \r\n                <defaultGoal /> \r\n                <resources> \r\n                    <resource> \r\n                        <targetPath></targetPath>\r\n                        <filtering></filtering>\r\n                        <directory></directory>\r\n                        <includes>\r\n                            <include></include>\r\n                        </includes>\r\n                        <excludes>\r\n                            <exclude></exclude>\r\n                        </excludes>\r\n                    </resource> \r\n                </resources> \r\n                <testResources> \r\n                    <testResource> \r\n                        <targetPath></targetPath>\r\n                        <filtering></filtering>\r\n                        <directory></directory>\r\n                        <includes>\r\n                            <include></include>\r\n                        </includes>\r\n                        <excludes>\r\n                            <exclude></exclude>\r\n                        </excludes> \r\n                    </testResource> \r\n                </testResources> \r\n                <directory></directory>\r\n                <finalName></finalName>\r\n                <filters></filters> \r\n                <pluginManagement> \r\n                    <plugins> \r\n                        \x3c!-- 参见build/pluginManagement/plugins/plugin元素 --\x3e \r\n                        <plugin> \r\n                            <groupId></groupId>\r\n                            <artifactId></artifactId>\r\n                            <version></version>\r\n                            <extensions>true/false</extensions> \r\n                            <executions> \r\n                                <execution> \r\n                                    <id></id>\r\n                                    <phase></phase>\r\n                                    <goals></goals>\r\n                                    <inherited>true/false</inherited>\r\n                                    <configuration></configuration> \r\n                                </execution> \r\n                            </executions> \r\n                            <dependencies> \r\n                                \x3c!-- 参见dependencies/dependency元素 --\x3e \r\n                                <dependency> \r\n                                </dependency> \r\n                            </dependencies> \r\n                            <goals></goals>\r\n                            <inherited>true/false</inherited>\r\n                            <configuration></configuration>\r\n                        </plugin> \r\n                    </plugins> \r\n                </pluginManagement> \r\n                <plugins> \r\n                    \x3c!-- 参见build/pluginManagement/plugins/plugin元素 --\x3e \r\n                    <plugin> \r\n                        <groupId></groupId>\r\n                        <artifactId></artifactId>\r\n                        <version></version>\r\n                        <extensions>true/false</extensions> \r\n                        <executions> \r\n                            <execution> \r\n                                <id></id>\r\n                                <phase></phase>\r\n                                <goals></goals>\r\n                                <inherited>true/false</inherited>\r\n                                <configuration></configuration> \r\n                            </execution> \r\n                        </executions> \r\n                        <dependencies> \r\n                            \x3c!-- 参见dependencies/dependency元素 --\x3e \r\n                            <dependency> \r\n                            </dependency> \r\n                        </dependencies> \r\n                        <goals></goals>\r\n                        <inherited>true/false</inherited>\r\n                        <configuration></configuration> \r\n                    </plugin> \r\n                </plugins> \r\n            </build> \r\n\r\n            \x3c!-- 模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的\r\n                 相对路径 --\x3e \r\n            <modules>\r\n                \x3c!--子项目相对路径--\x3e\r\n                <module></module>\r\n            </modules> \r\n\r\n            \x3c!-- 发现依赖和扩展的远程仓库列表。 --\x3e \r\n            <repositories> \r\n                \x3c!-- 参见repositories/repository元素 --\x3e \r\n                <repository> \r\n                    <releases> \r\n                        <enabled><enabled>\r\n                        <updatePolicy></updatePolicy>\r\n                        <checksumPolicy></checksumPolicy> \r\n                    </releases> \r\n                    <snapshots> \r\n                        <enabled><enabled>\r\n                        <updatePolicy></updatePolicy>\r\n                        <checksumPolicy></checksumPolicy> \r\n                    </snapshots> \r\n                    <id></id>\r\n                    <name></name>\r\n                    <url></url>\r\n                    <layout></layout> \r\n                </repository> \r\n            </repositories> \r\n\r\n            \x3c!-- 发现插件的远程仓库列表，这些插件用于构建和报表 --\x3e \r\n            <pluginRepositories> \r\n                \x3c!-- 包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --\x3e \r\n                <pluginRepository> \r\n                    <releases> \r\n                        <enabled><enabled>\r\n                        <updatePolicy></updatePolicy>\r\n                        <checksumPolicy></checksumPolicy> \r\n                    </releases> \r\n                    <snapshots> \r\n                        <enabled><enabled>\r\n                        <updatePolicy></updatePolicy>\r\n                        <checksumPolicy></checksumPolicy>\r\n                    </snapshots> \r\n                    <id></id>\r\n                    <name></name>\r\n                    <url></url>\r\n                    <layout></layout> \r\n                </pluginRepository> \r\n            </pluginRepositories> \r\n\r\n            \x3c!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的\r\n                 仓库中下载。要获取更多信息，请看项目依赖机制。 --\x3e \r\n            <dependencies> \r\n                \x3c!-- 参见dependencies/dependency元素 --\x3e \r\n                <dependency> \r\n                </dependency> \r\n            </dependencies> \r\n\r\n            \x3c!-- 不赞成使用. 现在Maven忽略该元素. --\x3e \r\n            <reports></reports> \r\n\r\n            \x3c!-- 该元素包括使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看\r\n                 到所有报表的链接。参见reporting元素 --\x3e \r\n            <reporting></reporting> \r\n\r\n            \x3c!-- 参见dependencyManagement元素 --\x3e \r\n            <dependencyManagement> \r\n                <dependencies> \r\n                    \x3c!-- 参见dependencies/dependency元素 --\x3e \r\n                    <dependency> \r\n                    </dependency> \r\n                </dependencies> \r\n            </dependencyManagement> \r\n\r\n            \x3c!-- 参见distributionManagement元素 --\x3e \r\n            <distributionManagement> \r\n            </distributionManagement> \r\n\r\n            \x3c!-- 参见properties元素 --\x3e \r\n            <properties /> \r\n        </profile> \r\n    </profiles> \r\n\r\n    \x3c!-- 模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --\x3e \r\n    <modules>\r\n        \x3c!--子项目相对路径--\x3e\r\n        <module></module>\r\n    </modules> \r\n\r\n    \x3c!-- 发现依赖和扩展的远程仓库列表。 --\x3e \r\n    <repositories> \r\n        \x3c!-- 包含需要连接到远程仓库的信息 --\x3e \r\n        <repository> \r\n            \x3c!-- 如何处理远程仓库里发布版本的下载 --\x3e \r\n            <releases> \r\n                \x3c!-- true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --\x3e \r\n                <enabled><enabled> \r\n\r\n                \x3c!-- 该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），\r\n                     daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --\x3e \r\n                <updatePolicy></updatePolicy> \r\n\r\n                \x3c!-- 当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --\x3e \r\n                <checksumPolicy></checksumPolicy> \r\n            </releases> \r\n\r\n            \x3c!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，\r\n                 为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --\x3e \r\n            <snapshots> \r\n                <enabled><enabled>\r\n                <updatePolicy></updatePolicy>\r\n                <checksumPolicy></checksumPolicy> \r\n            </snapshots> \r\n\r\n            \x3c!-- 远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --\x3e \r\n            <id> banseon-repository-proxy </id> \r\n\r\n            \x3c!-- 远程仓库名称 --\x3e \r\n            <name> banseon-repository-proxy </name> \r\n\r\n            \x3c!-- 远程仓库URL，按protocol://hostname/path形式 --\x3e \r\n            <url> http://192.168.1.169:9999/repository/ </url> \r\n\r\n            \x3c!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认\r\n                 的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --\x3e \r\n            <layout> default </layout> \r\n        </repository> \r\n    </repositories> \r\n\r\n    \x3c!-- 发现插件的远程仓库列表，这些插件用于构建和报表 --\x3e \r\n    <pluginRepositories> \r\n        \x3c!-- 包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --\x3e \r\n        <pluginRepository> \r\n        </pluginRepository> \r\n    </pluginRepositories> \r\n\r\n    \x3c!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。\r\n         要获取更多信息，请看项目依赖机制。 --\x3e \r\n    <dependencies> \r\n        <dependency> \r\n            \x3c!-- 依赖的group ID --\x3e \r\n            <groupId> org.apache.maven </groupId> \r\n\r\n            \x3c!-- 依赖的artifact ID --\x3e \r\n            <artifactId> maven-artifact </artifactId> \r\n\r\n            \x3c!-- 依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --\x3e \r\n            <version> 3.8.1 </version> \r\n\r\n            \x3c!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展\r\n                 名或分类器。类型经常和使用的打包方式对应，尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。\r\n                 如果设置extensions为 true，就可以在plugin里定义新的类型。所以前面的类型的例子不完整。 --\x3e \r\n            <type> jar </type> \r\n\r\n            \x3c!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，\r\n                 如果你想要构建两个单独的构件成JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生\r\n                 成两个单独的JAR构件。 --\x3e \r\n            <classifier></classifier> \r\n\r\n            \x3c!-- 依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 \r\n                - compile ：默认范围，用于编译 \r\n                - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath \r\n                - runtime: 在执行时需要使用 \r\n                - test: 用于test任务时使用 \r\n                - system: 需要外在提供相应的元素。通过systemPath来取得 \r\n                - systemPath: 仅用于范围为system。提供相应的路径 \r\n                - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --\x3e \r\n            <scope> test </scope> \r\n\r\n            \x3c!-- 仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件\r\n                 系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如${java.home}。 --\x3e \r\n            <systemPath></systemPath> \r\n\r\n            \x3c!-- 当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的\r\n                 依赖。此元素主要用于解决版本冲突问题 --\x3e \r\n            <exclusions> \r\n                <exclusion> \r\n                    <artifactId> spring-core </artifactId> \r\n                    <groupId> org.springframework </groupId> \r\n                </exclusion> \r\n            </exclusions> \r\n\r\n            \x3c!-- 可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。\r\n                 可选依赖阻断依赖的传递性。 --\x3e \r\n            <optional> true </optional> \r\n        </dependency> \r\n    </dependencies> \r\n\r\n    \x3c!-- 不赞成使用. 现在Maven忽略该元素. --\x3e \r\n    <reports></reports> \r\n\r\n    \x3c!-- 该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 --\x3e \r\n    <reporting> \r\n        \x3c!-- true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。 --\x3e \r\n        <excludeDefaults /> \r\n\r\n        \x3c!-- 所有产生的报表存放到哪里。默认值是${project.build.directory}/site。 --\x3e \r\n        <outputDirectory /> \r\n\r\n        \x3c!-- 使用的报表插件和他们的配置。 --\x3e \r\n        <plugins> \r\n            \x3c!-- plugin元素包含描述报表插件需要的信息 --\x3e \r\n            <plugin> \r\n                \x3c!-- 报表插件在仓库里的group ID --\x3e \r\n                <groupId></groupId> \r\n                \x3c!-- 报表插件在仓库里的artifact ID --\x3e \r\n                <artifactId></artifactId> \r\n\r\n                \x3c!-- 被使用的报表插件的版本（或版本范围） --\x3e \r\n                <version></version> \r\n\r\n                \x3c!-- 任何配置是否被传播到子项目 --\x3e \r\n                <inherited>true/false</inherited> \r\n\r\n                \x3c!-- 报表插件的配置 --\x3e \r\n                <configuration></configuration> \r\n\r\n                \x3c!-- 一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，\r\n                     有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报\r\n                     表集，对应另一个执行目标 --\x3e \r\n                <reportSets> \r\n                    \x3c!-- 表示报表的一个集合，以及产生该集合的配置 --\x3e \r\n                    <reportSet> \r\n                        \x3c!-- 报表集合的唯一标识符，POM继承时用到 --\x3e \r\n                        <id></id> \r\n\r\n                        \x3c!-- 产生报表集合时，被使用的报表的配置 --\x3e \r\n                        <configuration></configuration> \r\n\r\n                        \x3c!-- 配置是否被继承到子POMs --\x3e \r\n                        <inherited>true/false</inherited> \r\n\r\n                        \x3c!-- 这个集合里使用到哪些报表 --\x3e \r\n                        <reports></reports> \r\n                    </reportSet> \r\n                </reportSets> \r\n            </plugin> \r\n        </plugins> \r\n    </reporting> \r\n\r\n    \x3c!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖\r\n        （必须描述group ID和artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过\r\n            group ID和artifact ID匹配到这里的依赖，并使用这里的依赖信息。 --\x3e \r\n    <dependencyManagement> \r\n        <dependencies> \r\n            \x3c!-- 参见dependencies/dependency元素 --\x3e \r\n            <dependency> \r\n            </dependency> \r\n        </dependencies> \r\n    </dependencyManagement> \r\n\r\n    \x3c!-- 项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者\r\n         把构件部署到远程仓库。 --\x3e \r\n    <distributionManagement> \r\n        \x3c!-- 部署项目产生的构件到远程仓库需要的信息 --\x3e \r\n        <repository> \r\n            \x3c!-- 是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见\r\n                 repositories/repository元素 --\x3e \r\n            <uniqueVersion /> \r\n            <id> banseon-maven2 </id> \r\n            <name> banseon maven2 </name> \r\n            <url> file://${basedir}/target/deploy </url> \r\n            <layout></layout> \r\n        </repository> \r\n\r\n        \x3c!-- 构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见\r\n             distributionManagement/repository元素 --\x3e \r\n        <snapshotRepository> \r\n            <uniqueVersion /> \r\n            <id> banseon-maven2 </id> \r\n            <name> Banseon-maven2 Snapshot Repository </name> \r\n            <url> scp://svn.baidu.com/banseon:/usr/local/maven-snapshot </url> \r\n            <layout></layout>\r\n        </snapshotRepository> \r\n\r\n        \x3c!-- 部署项目的网站需要的信息 --\x3e \r\n        <site> \r\n            \x3c!-- 部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --\x3e \r\n            <id> banseon-site </id> \r\n\r\n            \x3c!-- 部署位置的名称 --\x3e \r\n            <name> business api website </name> \r\n\r\n            \x3c!-- 部署位置的URL，按protocol://hostname/path形式 --\x3e \r\n            <url> \r\n                scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web \r\n            </url> \r\n        </site> \r\n\r\n        \x3c!-- 项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位\r\n             那些不在仓库里的构件（由于license限制）。 --\x3e \r\n        <downloadUrl /> \r\n\r\n        \x3c!-- 如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --\x3e \r\n        <relocation> \r\n            \x3c!-- 构件新的group ID --\x3e \r\n            <groupId></groupId> \r\n\r\n            \x3c!-- 构件新的artifact ID --\x3e \r\n            <artifactId></artifactId> \r\n\r\n            \x3c!-- 构件新的版本号 --\x3e \r\n            <version></version> \r\n\r\n            \x3c!-- 显示给用户的，关于移动的额外信息，例如原因。 --\x3e \r\n            <message></message> \r\n        </relocation> \r\n\r\n        \x3c!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值\r\n             有：none（默认），converted（仓库管理员从Maven 1 POM转换过来），partner（直接从伙伴Maven \r\n             2仓库同步过来），deployed（从Maven 2实例部署），verified（被核实时正确的和最终的）。 --\x3e \r\n        <status></status> \r\n    </distributionManagement> \r\n\r\n    \x3c!-- 以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里\r\n         activation元素的说明）。格式是<name>value</name>。 --\x3e \r\n    <properties>\r\n        <name>value</name>\r\n    </properties> \r\n</project> \r\n```\r\n\r\n\r\n\r\n# 附件2：POM文件单项配置说明\r\n\r\n## localRepository\r\n\r\n```XML\r\n \x3c!-- 本地仓库的路径。默认值为${user.home}/.m2/repository。 --\x3e\r\n <localRepository>usr/local/maven</localRepository>\r\n```\r\n\r\n## interactiveMode\r\n\r\n```XML\r\n \x3c!--Maven是否需要和用户交互以获得输入。如果Maven需要和用户交互以获得输入，则设置成true，反之则应为false。默认为true。--\x3e\r\n <interactiveMode>true</interactiveMode>\r\n```\r\n\r\n## usePluginRegistry\r\n\r\n```XML\r\n\x3c!--Maven是否需要使用plugin-registry.xml文件来管理插件版本。如果需要让Maven使用文件${user.home}/.m2/plugin-registry.xml来管理插件版本，则设为true。默认为false。--\x3e\r\n <usePluginRegistry>false</usePluginRegistry>\r\n```\r\n\r\n## offline\r\n\r\n```XML\r\n \x3c!--表示Maven是否需要在离线模式下运行。如果构建系统需要在离线模式下运行，则为true，默认为false。当由于网络设置原因或者安全因素，构建服务器不能连接远程仓库的时候，该配置就十分有用。 --\x3e\r\n <offline>false</offline>\r\n```\r\n\r\n## pluginGroups\r\n\r\n```XML\r\n\x3c!--当插件的组织Id（groupId）没有显式提供时，供搜寻插件组织Id（groupId）的列表。该元素包含一个pluginGroup元素列表，每个子元素包含了一个组织Id（groupId）。当我们使用某个插件，并且没有在命令行为其提供组织Id（groupId）的时候，Maven就会使用该列表。默认情况下该列表包含了org.apache.maven.plugins和org.codehaus.mojo --\x3e\r\n <pluginGroups>\r\n  \x3c!--plugin的组织Id（groupId） --\x3e\r\n  <pluginGroup>org.codehaus.mojo</pluginGroup>\r\n </pluginGroups>\r\n```\r\n\r\n## proxies\r\n\r\n```XML\r\n\x3c!--用来配置不同的代理，多代理profiles 可以应对笔记本或移动设备的工作环境：通过简单的设置profile id就可以很容易的更换整个代理配置。 --\x3e\r\n <proxies>\r\n  \x3c!--代理元素包含配置代理时需要的信息--\x3e\r\n  <proxy>\r\n   \x3c!--代理的唯一定义符，用来区分不同的代理元素。--\x3e\r\n   <id>myproxy</id>\r\n   \x3c!--该代理是否是激活的那个。true则激活代理。当我们声明了一组代理，而某个时候只需要激活一个代理的时候，该元素就可以派上用处。 --\x3e\r\n   <active>true</active>\r\n   \x3c!--代理的协议。 协议://主机名:端口，分隔成离散的元素以方便配置。--\x3e\r\n   <protocol>http</protocol>\r\n   \x3c!--代理的主机名。协议://主机名:端口，分隔成离散的元素以方便配置。  --\x3e\r\n   <host>proxy.somewhere.com</host>\r\n   \x3c!--代理的端口。协议://主机名:端口，分隔成离散的元素以方便配置。 --\x3e\r\n   <port>8080</port>\r\n   \x3c!--代理的用户名，用户名和密码表示代理服务器认证的登录名和密码。 --\x3e\r\n   <username>proxyuser</username>\r\n   \x3c!--代理的密码，用户名和密码表示代理服务器认证的登录名和密码。 --\x3e\r\n   <password>somepassword</password>\r\n   \x3c!--不该被代理的主机名列表。该列表的分隔符由代理服务器指定；例子中使用了竖线分隔符，使用逗号分隔也很常见。--\x3e\r\n   <nonProxyHosts>*.google.com|ibiblio.org</nonProxyHosts>\r\n  </proxy>\r\n </proxies>\r\n```\r\n\r\n## servers\r\n\r\n```XML\r\n\x3c!--配置服务端的一些设置。一些设置如安全证书不应该和pom.xml一起分发。这种类型的信息应该存在于构建服务器上的settings.xml文件中。--\x3e\r\n <servers>\r\n  \x3c!--服务器元素包含配置服务器时需要的信息 --\x3e\r\n  <server>\r\n   \x3c!--这是server的id（注意不是用户登陆的id），该id与distributionManagement中repository元素的id相匹配。--\x3e\r\n   <id>server001</id>\r\n   \x3c!--鉴权用户名。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。 --\x3e\r\n   <username>my_login</username>\r\n   \x3c!--鉴权密码 。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。密码加密功能已被添加到2.1.0 +。详情请访问密码加密页面--\x3e\r\n   <password>my_password</password>\r\n   \x3c!--鉴权时使用的私钥位置。和前两个元素类似，私钥位置和私钥密码指定了一个私钥的路径（默认是${user.home}/.ssh/id_dsa）以及如果需要的话，一个密语。将来passphrase和password元素可能会被提取到外部，但目前它们必须在settings.xml文件以纯文本的形式声明。 --\x3e\r\n   <privateKey>${usr.home}/.ssh/id_dsa</privateKey>\r\n   \x3c!--鉴权时使用的私钥密码。--\x3e\r\n   <passphrase>some_passphrase</passphrase>\r\n   \x3c!--文件被创建时的权限。如果在部署的时候会创建一个仓库文件或者目录，这时候就可以使用权限（permission）。这两个元素合法的值是一个三位数字，其对应了unix文件系统的权限，如664，或者775。 --\x3e\r\n   <filePermissions>664</filePermissions>\r\n   \x3c!--目录被创建时的权限。 --\x3e\r\n   <directoryPermissions>775</directoryPermissions>\r\n  </server>\r\n </servers>\r\n```\r\n\r\n## mirrors\r\n\r\n```XML\r\n\x3c!--为仓库列表配置的下载镜像列表。高级设置请参阅镜像设置页面 --\x3e\r\n <mirrors>\r\n  \x3c!--给定仓库的下载镜像。 --\x3e\r\n  <mirror>\r\n   \x3c!--该镜像的唯一标识符。id用来区分不同的mirror元素。 --\x3e\r\n   <id>planetmirror.com</id>\r\n   \x3c!--镜像名称 --\x3e\r\n   <name>PlanetMirror Australia</name>\r\n   \x3c!--该镜像的URL。构建系统会优先考虑使用该URL，而非使用默认的服务器URL。 --\x3e\r\n   <url>http://downloads.planetmirror.com/pub/maven2</url>\r\n   \x3c!--被镜像的服务器的id。例如，如果我们要设置了一个Maven中央仓库（http://repo.maven.apache.org/maven2/）的镜像，就需要将该元素设置成central。这必须和中央仓库的id central完全一致。--\x3e\r\n   <mirrorOf>central</mirrorOf>\r\n  </mirror>\r\n </mirrors>\r\n```\r\n\r\n## profiles\r\n\r\n```XML\r\n \x3c!--根据环境参数来调整构建配置的列表。settings.xml中的profile元素是pom.xml中profile元素的裁剪版本。它包含了id，activation, repositories, pluginRepositories和 properties元素。这里的profile元素只包含这五个子元素是因为这里只关心构建系统这个整体（这正是settings.xml文件的角色定位），而非单独的项目对象模型设置。如果一个settings中的profile被激活，它的值会覆盖任何其它定义在POM中或者profile.xml中的带有相同id的profile。 --\x3e\r\n <profiles>\r\n  \x3c!--根据环境参数来调整的构件的配置--\x3e\r\n  <profile>\r\n   \x3c!--该配置的唯一标识符。 --\x3e\r\n   <id>test</id>\r\n```\r\n\r\n## Activation\r\n\r\n```XML\r\n\x3c!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。如POM中的profile一样，profile的力量来自于它能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。settings.xml文件中的activeProfile元素可以包含profile的id。profile也可以通过在命令行，使用-P标记和逗号分隔的列表来显式的激活（如，-P test）。--\x3e\r\n   <activation>\r\n    \x3c!--profile默认是否激活的标识--\x3e\r\n    <activeByDefault>false</activeByDefault>\r\n    \x3c!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。--\x3e\r\n    <jdk>1.5</jdk>\r\n    \x3c!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。--\x3e\r\n    <os>\r\n     \x3c!--激活profile的操作系统的名字 --\x3e\r\n     <name>Windows XP</name>\r\n     \x3c!--激活profile的操作系统所属家族(如 \'windows\')  --\x3e\r\n     <family>Windows</family>\r\n     \x3c!--激活profile的操作系统体系结构  --\x3e\r\n     <arch>x86</arch>\r\n     \x3c!--激活profile的操作系统版本--\x3e\r\n     <version>5.1.2600</version>\r\n    </os>\r\n    \x3c!--如果Maven检测到某一个属性（其值可以在POM中通过${name}引用），其拥有对应的name = 值，Profile就会被激活。如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段--\x3e\r\n    <property>\r\n     \x3c!--激活profile的属性的名称--\x3e\r\n     <name>mavenVersion</name>\r\n     \x3c!--激活profile的属性的值 --\x3e\r\n     <value>2.0.3</value>\r\n    </property>\r\n    \x3c!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。--\x3e\r\n    <file>\r\n     \x3c!--如果指定的文件存在，则激活profile。 --\x3e\r\n     <exists>${basedir}/file2.properties</exists>\r\n     \x3c!--如果指定的文件不存在，则激活profile。--\x3e\r\n     <missing>${basedir}/file1.properties</missing>\r\n    </file>\r\n   </activation>\r\n```\r\n\r\n## Repositories\r\n\r\n```XML\r\n  \x3c!--远程仓库列表，它是Maven用来填充构建系统本地仓库所使用的一组远程项目。 --\x3e\r\n   <repositories>\r\n    \x3c!--包含需要连接到远程仓库的信息 --\x3e\r\n    <repository>\r\n     \x3c!--远程仓库唯一标识--\x3e\r\n     <id>codehausSnapshots</id>\r\n     \x3c!--远程仓库名称 --\x3e\r\n     <name>Codehaus Snapshots</name>\r\n     \x3c!--如何处理远程仓库里发布版本的下载--\x3e\r\n     <releases>\r\n      \x3c!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。  --\x3e\r\n      <enabled>false</enabled>\r\n      \x3c!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --\x3e\r\n      <updatePolicy>always</updatePolicy>\r\n      \x3c!--当Maven验证构件校验文件失败时该怎么做-ignore（忽略），fail（失败），或者warn（警告）。--\x3e\r\n      <checksumPolicy>warn</checksumPolicy>\r\n     </releases>\r\n     \x3c!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素--\x3e\r\n     <snapshots>\r\n      <enabled/><updatePolicy/><checksumPolicy/>\r\n     </snapshots>\r\n     \x3c!--远程仓库URL，按protocol://hostname/path形式 --\x3e\r\n     <url>http://snapshots.maven.codehaus.org/maven2</url>\r\n     \x3c!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --\x3e\r\n     <layout>default</layout>\r\n    </repository>\r\n   </repositories>\r\n   \x3c!--发现插件的远程仓库列表。仓库是两种主要构件的家。第一种构件被用作其它构件的依赖。这是中央仓库中存储的大部分构件类型。另外一种构件类型是插件。Maven插件是一种特殊类型的构件。由于这个原因，插件仓库独立于其它仓库。pluginRepositories元素的结构和repositories元素的结构类似。每个pluginRepository元素指定一个Maven可以用来寻找新插件的远程地址。--\x3e\r\n   <pluginRepositories>\r\n    \x3c!--包含需要连接到远程插件仓库的信息.参见profiles/profile/repositories/repository元素的说明--\x3e\r\n          <pluginRepository>           \r\n     <releases>      \r\n      <enabled/><updatePolicy/><checksumPolicy/>\r\n     </releases>\r\n     <snapshots>\r\n      <enabled/><updatePolicy/><checksumPolicy/>\r\n     </snapshots>\r\n     <id/><name/><url/><layout/>\r\n          </pluginRepository>\r\n        </pluginRepositories>\r\n  </profile>\r\n </profiles>\r\n```\r\n\r\n## activeProfiles\r\n\r\n```XML\r\n\x3c!--手动激活profiles的列表，按照profile被应用的顺序定义activeProfile。 该元素包含了一组activeProfile元素，每个activeProfile都含有一个profile id。任何在activeProfile中定义的profile id，不论环境设置如何，其对应的\r\n        profile都会被激活。如果没有匹配的profile，则什么都不会发生。例如，env-test是一个activeProfile，则在pom.xml（或者profile.xml）中对应id的profile会被激活。如果运行过程中找不到这样一个profile，Maven则会像往常一样运行。 --\x3e\r\n   <activeProfiles>\r\n    <activeProfile>env-test</activeProfile>\r\n   </activeProfiles>\r\n</settings>\r\n```'},8290:function(n,e,t){"use strict";t.r(e),e["default"]='# 1 SpringMVC 概述\r\n\r\n**三层架构**    \r\n\r\n- 表现层：负责数据展示\r\n\r\n-  业务层：负责业务处理\r\n\r\n- 数据层：负责数据操作\r\n\r\n![image-20200426174726083](./SpringMVC-day01/image-20200426174726083.png)\r\n\r\nMVC（Model View Controller），一种用于设计创建Web应用程序表现层的模式\r\n\r\n- Model（模型）：数据模型，用于封装数据\r\n\r\n-  View（视图）：页面视图，用于展示数据\r\n\r\n* jsp  \r\n* html\r\n\r\nController（控制器）：处理用户交互的调度器，用于根据用户需求处理程序逻辑\r\n\r\n* Servlet\r\n* SpringMVC\r\n\r\n![image-20200426180210590](./SpringMVC-day01/image-20200426180210590.png)  \r\n\r\n![image-20200426180348299](./SpringMVC-day01/image-20200426180348299.png)\r\n\r\n\r\n# 2 入门案例\r\n\r\n## 2.1 入门案例制作\r\n\r\n①导入SpringMVC相关坐标\r\n\r\n```xml\r\n\x3c!-- servlet3.1规范的坐标 --\x3e\r\n<dependency>\r\n    <groupId>javax.servlet</groupId>\r\n    <artifactId>javax.servlet-api</artifactId>\r\n    <version>3.1.0</version>\r\n    <scope>provided</scope>\r\n</dependency>\r\n\x3c!--jsp坐标--\x3e\r\n<dependency>\r\n    <groupId>javax.servlet.jsp</groupId>\r\n    <artifactId>jsp-api</artifactId>\r\n    <version>2.1</version>\r\n    <scope>provided</scope>\r\n</dependency>\r\n\x3c!--spring的坐标--\x3e\r\n<dependency>\r\n    <groupId>org.springframework</groupId>\r\n    <artifactId>spring-context</artifactId>\r\n    <version>5.1.9.RELEASE</version>\r\n</dependency>\r\n\x3c!--spring web的坐标--\x3e\r\n<dependency>\r\n    <groupId>org.springframework</groupId>\r\n    <artifactId>spring-web</artifactId>\r\n    <version>5.1.9.RELEASE</version>\r\n</dependency>\r\n\x3c!--springmvc的坐标--\x3e\r\n<dependency>\r\n    <groupId>org.springframework</groupId>\r\n    <artifactId>spring-webmvc</artifactId>\r\n    <version>5.1.9.RELEASE</version>\r\n</dependency>\r\n```\r\n\r\n②定义表现层业务处理器Controller，并配置成spring的bean（等同于Servlet）\r\n\r\n```java\r\n@Controller\r\npublic class UserController {\r\n\r\n    public void save(){\r\n        System.out.println("user mvc controller is running ...");\r\n    }\r\n}\r\n```\r\n\r\n```xml\r\n<?xml version="1.0" encoding="UTF-8"?>\r\n<beans xmlns="http://www.springframework.org/schema/beans"\r\n       xmlns:context="http://www.springframework.org/schema/context"\r\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\r\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\r\n        http://www.springframework.org/schema/context\r\n        http://www.springframework.org/schema/context/spring-context.xsd">\r\n    \x3c!--扫描加载所有的控制类类--\x3e\r\n    <context:component-scan base-package="com.itheima"/>\r\n\r\n</beans>\r\n```\r\n\r\n③web.xml中配置SpringMVC核心控制器，用于将请求转发到对应的具体业务处理器Controller中（等同于Servlet配置）\r\n\r\n```xml\r\n<servlet>\r\n    <servlet-name>DispatcherServlet</servlet-name>\r\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\r\n    <init-param>\r\n        <param-name>contextConfigLocation</param-name>\r\n        <param-value>classpath*:spring-mvc.xml</param-value>\r\n    </init-param>\r\n</servlet>\r\n<servlet-mapping>\r\n    <servlet-name>DispatcherServlet</servlet-name>\r\n    <url-pattern>/</url-pattern>\r\n</servlet-mapping>\r\n```\r\n\r\n④设定具体Controller的访问路径（等同于Servlet在web.xml中的配置）\r\n\r\n```java\r\n//设定当前方法的访问映射地址\r\n@RequestMapping("/save")\r\npublic void save(){\r\n    System.out.println("user mvc controller is running ...");\r\n}\r\n```\r\n\r\n⑤设置返回页面  \r\n\r\n```java\r\n//设定当前方法的访问映射地址\r\n@RequestMapping("/save")\r\n//设置当前方法返回值类型为String，用于指定请求完成后跳转的页面\r\npublic String save(){\r\n    System.out.println("user mvc controller is running ...");\r\n    //设定具体跳转的页面\r\n    return "success.jsp";\r\n}\r\n```\r\n\r\n\r\n\r\n## 2.2 入门案例工作流程分析  \r\n\r\n* 服务器启动\r\n  1. 加载web.xml中DispatcherServlet\r\n  2. 读取spring-mvc.xml中的配置，加载所有com.itheima包中所有标记为bean的类\r\n  3. 读取bean中方法上方标注@RequestMapping的内容\r\n* 处理请求\r\n  1. DispatcherServlet配置拦截所有请求 /\r\n  2. 使用请求路径与所有加载的@RequestMapping的内容进行比对\r\n  3. 执行对应的方法\r\n  4. 根据方法的返回值在webapp目录中查找对应的页面并展示  \r\n\r\n\r\n\r\n## 2.3 SpringMVC 技术架构图\r\n\r\n![image-20200426182959446](./SpringMVC-day01/image-20200426182959446.png)\r\n\r\n\r\n\r\n![image-20200426183024690](./SpringMVC-day01/image-20200426183024690.png)\r\n\r\n\r\n\r\n*  DispatcherServlet：前端控制器， 是整体流程控制的中心，由其调用其它组件处理用户的请求， 有\r\n  效的降低了组件间的耦合性\r\n* HandlerMapping：处理器映射器， 负责根据用户请求找到对应具体的Handler处理器\r\n* Handler：处理器，业务处理的核心类，通常由开发者编写，描述具体的业务\r\n* HandlAdapter：处理器适配器，通过它对处理器进行执行\r\n* View Resolver：视图解析器， 将处理结果生成View视图\r\n* View：视图，最终产出结果， 常用视图如jsp、 html  \r\n\r\n![image-20200426183313406](./SpringMVC-day01/image-20200426183313406.png)\r\n\r\n# 3 基本配置\r\n\r\n## 3.1 常规配置（Controller加载控制）\r\n\r\n* SpringMVC的处理器对应的bean必须按照规范格式开发，未避免加入无效的bean可通过bean加载过滤器进\r\n  行包含设定或排除设定，表现层bean标注通常设定为@Controller  \r\n\r\n**xml方式**\r\n\r\n```xml\r\n<context:component-scan base-package="com.itheima">\r\n    <context:include-filter\r\n                            type="annotation"\r\n                            expression="org.springframework.stereotype.Controller"/>\r\n</context:component-scan>\r\n```\r\n\r\n### 3.1.1 静态资源加载\r\n\r\n```xml\r\n\x3c!--放行指定类型静态资源配置方式--\x3e\r\n<mvc:resources mapping="/img/**" location="/img/"/>\r\n<mvc:resources mapping="/js/**" location="/js/"/>\r\n<mvc:resources mapping="/css/**" location="/css/"/>\r\n\r\n\x3c!--SpringMVC提供的通用资源放行方式--\x3e\r\n<mvc:default-servlet-handler/>\r\n```\r\n\r\n \r\n\r\n### 3.1.2 中文乱码处理 \r\n\r\n  SpringMVC提供专用的中文字符过滤器，用于处理乱码问题  \r\n\r\n  配置在 **web.xml** 里面\r\n\r\n```XML\r\n\x3c!--乱码处理过滤器，与Servlet中使用的完全相同，差异之处在于处理器的类由Spring提供--\x3e\r\n<filter>\r\n    <filter-name>CharacterEncodingFilter</filter-name>\r\n    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\r\n    <init-param>\r\n        <param-name>encoding</param-name>\r\n        <param-value>UTF-8</param-value>\r\n    </init-param>\r\n</filter>\r\n<filter-mapping>\r\n    <filter-name>CharacterEncodingFilter</filter-name>\r\n    <url-pattern>/*</url-pattern>\r\n</filter-mapping>\r\n```\r\n\r\n\r\n\r\n## 3.2 注解驱动\r\n\r\n*   使用注解形式转化SpringMVC核心配置文件为配置类  \r\n\r\n\r\n```java\r\n@Configuration\r\n@ComponentScan(value = "com.itheima",includeFilters =\r\n    @ComponentScan.Filter(type=FilterType.ANNOTATION,classes = {Controller.class})\r\n    )\r\npublic class SpringMVCConfiguration implements WebMvcConfigurer{\r\n    //注解配置放行指定资源格式\r\n//    @Override\r\n//    public void addResourceHandlers(ResourceHandlerRegistry registry) {\r\n//        registry.addResourceHandler("/img/**").addResourceLocations("/img/");\r\n//        registry.addResourceHandler("/js/**").addResourceLocations("/js/");\r\n//        registry.addResourceHandler("/css/**").addResourceLocations("/css/");\r\n//    }\r\n\r\n    //注解配置通用放行资源的格式\r\n    @Override\r\n    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {\r\n        configurer.enable();;\r\n    }\r\n}\r\n```\r\n\r\n*   基于servlet3.0规范，自定义Servlet容器初始化配置类，加载SpringMVC核心配置类  \r\n\r\n\r\n```java\r\npublic class ServletContainersInitConfig extends AbstractDispatcherServletInitializer {\r\n    //创建Servlet容器时，使用注解的方式加载SPRINGMVC配置类中的信息，并加载成WEB专用的\t\t\t           //ApplicationContext对象\r\n    //该对象放入了ServletContext范围，后期在整个WEB容器中可以随时获取调用\r\n    @Override\r\n    protected WebApplicationContext createServletApplicationContext() {\r\n        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();\r\n        ctx.register(SpringMVCConfiguration.class);\r\n        return ctx;\r\n    }\r\n\r\n    //注解配置映射地址方式，服务于SpringMVC的核心控制器DispatcherServlet\r\n    @Override\r\n    protected String[] getServletMappings() {\r\n        return new String[]{"/"};\r\n    }\r\n\r\n    @Override\r\n    protected WebApplicationContext createRootApplicationContext() {\r\n        return null;\r\n    }\r\n\r\n    //乱码处理作为过滤器，在servlet容器启动时进行配置，相关内容参看Servlet零配置相关课程\r\n    @Override\r\n    public void onStartup(ServletContext servletContext) throws ServletException {\r\n        super.onStartup(servletContext);\r\n        CharacterEncodingFilter cef = new CharacterEncodingFilter();\r\n        cef.setEncoding("UTF-8");\r\n        FilterRegistration.Dynamic registration = servletContext.addFilter("characterEncodingFilter", cef);\r\n        registration.addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST,DispatcherType.FORWARD,DispatcherType.INCLUDE),false,"/*");\r\n    }\r\n}\r\n```\r\n\r\n  删除web.xml\r\n  删除spring-mvc.xml  \r\n\r\n **小节**\r\n 基于servlet3.0规范，配置Servlet容器初始化配置类，初始化时加载SpringMVC配置类\r\n 转化SpringMVC核心配置文件\r\n 转化为注解（例如： spring处理器加载过滤）\r\n 转化为bean进行加载\r\n 按照标准接口进行开发并加载（例如：中文乱码处理、静态资源加载过滤）  \r\n\r\n# 4 请求\r\n\r\n## 4.1 普通类型参数传参\r\n\r\n  参数名与处理器方法形参名保持一致  \r\n\r\n  访问URL： http://localhost/requestParam1?name=itheima&age=14  \r\n\r\n```java\r\n@RequestMapping("/requestParam1")\r\npublic String requestParam1(String name ,String age){\r\n    System.out.println("name="+name+",age="+age);\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n **@RequestParam** 的使用\r\n 类型： 形参注解\r\n 位置：处理器类中的方法形参前方\r\n 作用：绑定请求参数与对应处理方法形参间的关系  \r\n\r\n```java\r\n@RequestMapping("/requestParam2")\r\npublic String requestParam2(@RequestParam(\r\n                            name = "userName",\r\n                            required = true,\r\n                            defaultValue = "itheima") String name){\r\n    \r\n    System.out.println("name="+name);\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n## 4.2 POJO类型参数传参\r\n\r\n当POJO中使用简单类型属性时， 参数名称与POJO类属性名保持一致  \r\n\r\n访问URL： http://localhost/requestParam3?name=itheima&age=14  \r\n\r\n**Controller**\r\n\r\n```java\r\n@RequestMapping("/requestParam3")\r\npublic String requestParam3(User user){\r\n    System.out.println("name="+user.getName());\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n**POJO类**\r\n\r\n```java\r\npublic class User {\r\n    private String name;\r\n    private Integer age;\r\n    \r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public Integer getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(Integer age) {\r\n        this.age = age;\r\n    }\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n**参数冲突**\r\n 当POJO类型属性与其他形参出现同名问题时，将被同时赋值\r\n 建议使用@RequestParam注解进行区分\r\n访问URL： http://localhost/requestParam4?name=itheima&**age**=14  \r\n\r\n```java\r\n@RequestMapping("/requestParam4")\r\npublic String requestParam4(User user,String age){\r\n    System.out.println("user.age="+user.getAge()+",age="+age);\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n\r\n\r\n**复杂POJO类型参数**\r\n 当POJO中出现对象属性时，参数名称与对象层次结构名称保持一致  \r\n\r\n  访问URL： http://localhost/requestParam5?address.province=beijing  \r\n\r\n```java\r\npublic class User {\r\n    private String name;\r\n    private Integer age;\r\n\r\n    private Address address;\r\n    \r\n    public Address getAddress() {\r\n        return address;\r\n    }\r\n\r\n    public void setAddress(Address address) {\r\n        this.address = address;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public Integer getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(Integer age) {\r\n        this.age = age;\r\n    }\r\n\r\n}\r\n```\r\n\r\n```java\r\n@RequestMapping("/requestParam5")\r\npublic String requestParam5(User user){\r\n    System.out.println("user.address="+user.getAddress().getProvince());\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n![image-20200426190932459](./SpringMVC-day01/image-20200426190932459.png)\r\n\r\n**当POJO中出现List，保存对象数据，参数名称与对象层次结构名称保持一致，使用数组格式描述集合中对象的位置**  \r\n\r\n访问URL： http://localhost/requestParam7?addresses[0].province=bj&addresses[1].province=tj  \r\n\r\n```java\r\npublic class User {\r\n    private String name;\r\n    private Integer age;\r\n    private List<Address> addresses;\r\n}\r\n\r\npublic class Address {\r\n    private String province;\r\n    private String city;\r\n    private String address;\r\n}\r\n```\r\n\r\n```java\r\n@RequestMapping("/requestParam7")\r\npublic String requestParam7(User user){\r\n    System.out.println("user.addresses="+user.getAddress());\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n **当POJO中出现Map，保存对象数据，参数名称与对象层次结构名称保持一致，使用映射格式描述集合中对象的位置**  \r\n\r\n 访问URL： http://localhost/requestParam8?addressMap[’home’].province=bj&addressMap[’job’].province=tj  \r\n\r\n```java\r\npublic class User {\r\n    private String name;\r\n    private Integer age;\r\n    private Map<String,Address> addressMap;\r\n}\r\npublic class Address {\r\n    private String province;\r\n    private String city;\r\n    private String address;\r\n}\r\n```\r\n\r\n```java\r\n@RequestMapping("/requestParam8")\r\npublic String requestParam8(User user){\r\n    System.out.println("user.addressMap="+user.getAddressMap());\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n## 4.3 数组与集合类型参数传参\r\n\r\n**数组类型参数**\r\n\r\n请求参数名与处理器方法形参名保持一致，且请求参数数量＞ 1个  \r\n\r\n访问URL： http://localhost/requestParam9?nick=Jockme&nick=zahc  \r\n\r\n```java\r\n@RequestMapping("/requestParam9")\r\npublic String requestParam9(String[] nick){\r\n    System.out.println(nick[0]+","+nick[1]);\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n**集合类型参数**\r\n 保存简单类型数据，请求参数名与处理器方法形参名保持一致，且请求参数数量＞ 1个\r\n访问URL： http://localhost/requestParam10?nick=Jockme&nick=zahc\r\n\r\n```java\r\n@RequestMapping("/requestParam10")\r\npublic String requestParam10(@RequestParam("nick") List<String> nick){\r\n    System.out.println(nick);\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n 注意： SpringMVC默认将List作为对象处理，赋值前先创建对象，然后将nick作为对象的属性进行处理。由于\r\nList是接口，无法创建对象，报无法找到构造方法异常；修复类型为可创建对象的ArrayList类型后，对象可\r\n以创建，但没有nick属性，因此数据为空。此时需要告知SpringMVC的处理器nick是一组数据，而不是一个单\r\n一数据。通过@RequestParam注解，将数量大于1个names参数打包成参数数组后， SpringMVC才能识别该数\r\n据格式，并判定形参类型是否为数组或集合，并按数组或集合对象的形式操作数据。  \r\n\r\n **小节**\r\n 请求POJO类型参数获取\r\n POJO的简单属性\r\n POJO的对象属性\r\n POJO的集合属性（存储简单数据）\r\n POJO的集合属性（存储对象数据）\r\n 名称冲突问题  \r\n\r\n## 4.4 类型转换器\r\n\r\nSpringMVC对接收的数据进行自动类型转换，该工作通过Converter接口实现  \r\n\r\n![image-20200426193801059](./SpringMVC-day01/image-20200426193801059.png)\r\n\r\n* **标量转换器**\r\n   StringToBooleanConverter String→Boolean\r\n   ObjectToStringConverter Object→String\r\n   StringToNumberConverterFactory String→Number（ Integer、 Long等）\r\n   NumberToNumberConverterFactory Number子类型之间(Integer、 Long、 Double等)\r\n   StringToCharacterConverter String→java.lang.Character\r\n   NumberToCharacterConverter Number子类型(Integer、 Long、 Double等)→java.lang.Character\r\n   CharacterToNumberFactory java.lang.Character→Number子类型(Integer、 Long、 Double等)\r\n   StringToEnumConverterFactory String→enum类型\r\n   EnumToStringConverter enum类型→String\r\n   StringToLocaleConverter String→java.util.Local\r\n   PropertiesToStringConverter java.util.Properties→String\r\n   StringToPropertiesConverter String→java.util.Properties  \r\n\r\n* **集合、数组相关转换器**\r\n   ArrayToCollectionConverter 数组→集合（ List、 Set）\r\n   CollectionToArrayConverter 集合（ List、 Set） →数组\r\n   ArrayToArrayConverter 数组间\r\n   CollectionToCollectionConverter 集合间（ List、 Set）\r\n   MapToMapConverter Map间\r\n   ArrayToStringConverter 数组→String类型\r\n   StringToArrayConverter String→数组， trim后使用“,”split\r\n   ArrayToObjectConverter 数组→Object\r\n   ObjectToArrayConverter Object→单元素数组\r\n   CollectionToStringConverter 集合（ List、 Set） →String\r\n   StringToCollectionConverter String→集合（ List、 Set）， trim后使用“,”split\r\n   CollectionToObjectConverter 集合→Object\r\n   ObjectToCollectionConverter Object→单元素集合  \r\n*  **默认转换器**\r\n   ObjectToObjectConverter Object间\r\n   IdToEntityConverter Id→Entity\r\n   FallbackObjectToStringConverter Object→String  \r\n\r\n* **SpringMVC对接收的数据进行自动类型转换，该工作通过Converter接口实现**  \r\n\r\n  ![image-20200426194106166](./SpringMVC-day01/image-20200426194106166.png)\r\n\r\n## 4.5 日期类型格式转换  \r\n\r\n* **声明自定义的转换格式并覆盖系统转换格式**  \r\n\r\n  ```xml\r\n  \x3c!--5.启用自定义Converter--\x3e\r\n  <mvc:annotation-driven conversion-service="conversionService"/>\r\n  \x3c!--1.设定格式类型Converter，注册为Bean，受SpringMVC管理--\x3e\r\n  <bean id="conversionService"\r\n        class="org.springframework.format.support.FormattingConversionServiceFactoryBean">\r\n      \x3c!--2.自定义Converter格式类型设定，该设定使用的是同类型覆盖的思想--\x3e\r\n      <property name="formatters">\r\n          \x3c!--3.使用set保障相同类型的转换器仅保留一个，避免冲突--\x3e\r\n          <set>\r\n              \x3c!--4.设置具体的格式类型--\x3e\r\n              <bean class="org.springframework.format.datetime.DateFormatter">\r\n                  \x3c!--5.类型规则--\x3e\r\n                  <property name="pattern" value="yyyy-MM-dd"/>\r\n              </bean>\r\n          </set>\r\n      </property>\r\n  </bean>\r\n  ```\r\n\r\n* **日期类型格式转换（简化版）**\r\n   名称： @DateTimeFormat\r\n   类型： 形参注解、成员变量注解\r\n   位置：形参前面 或 成员变量上方\r\n   作用：为当前参数或变量指定类型转换规则\r\n   范例：  \r\n\r\n  ```java\r\n  public String requestParam12(@DateTimeFormat(pattern = "yyyy-MM-dd") Date date){\r\n      System.out.println("date="+date);\r\n      return "page.jsp";\r\n  }\r\n  ```\r\n\r\n  ```java\r\n  @DateTimeFormat(pattern = "yyyy-MM-dd")\r\n  private Date birthday;\r\n  ```\r\n\r\n* 注意：依赖注解驱动支持  \r\n\r\n    <mvc:annotation-driven />  \r\n\r\n\r\n## 4.6 自定义类型转换器\r\n\r\n* 自定义类型转换器，实现Converter接口，并制定转换前与转换后的类型\r\n\r\n  ```xml\r\n  \x3c!--1.将自定义Converter注册为Bean，受SpringMVC管理--\x3e\r\n  <bean id="myDateConverter" class="com.itheima.converter.MyDateConverter"/>\r\n  \x3c!--2.设定自定义Converter服务bean--\x3e\r\n  <bean id="conversionService"\r\n        class="org.springframework.context.support.ConversionServiceFactoryBean">\r\n      \x3c!--3.注入所有的自定义Converter，该设定使用的是同类型覆盖的思想--\x3e\r\n      <property name="converters">\r\n          \x3c!--4.set保障同类型转换器仅保留一个，去重规则以Converter<S,T>的泛型为准--\x3e\r\n          <set>\r\n              \x3c!--5.具体的类型转换器--\x3e\r\n              <ref bean="myDateConverter"/>\r\n          </set>\r\n      </property>\r\n  </bean>\r\n  ```\r\n\r\n  ```java\r\n  //自定义类型转换器，实现Converter接口，接口中指定的泛型即为最终作用的条件\r\n  //本例中的泛型填写的是String，Date，最终出现字符串转日期时，该类型转换器生效\r\n  public class MyDateConverter implements Converter<String, Date> {\r\n      //重写接口的抽象方法，参数由泛型决定\r\n      public Date convert(String source) {\r\n          DateFormat df = new SimpleDateFormat("yyyy-MM-dd");\r\n          Date date = null;\r\n          //类型转换器无法预计使用过程中出现的异常，因此必须在类型转换器内部捕获，不允许抛出，框架无法预计此类异常如何处理\r\n          try {\r\n              date = df.parse(source);\r\n          } catch (ParseException e) {\r\n              e.printStackTrace();\r\n          }\r\n          return date;\r\n      }\r\n  }\r\n  ```\r\n\r\n  \r\n\r\n* **通过注册自定义转换器，将该功能加入到SpringMVC的转换服务ConverterService中**  \r\n\r\n  ```xml\r\n  \x3c!--开启注解驱动，加载自定义格式化转换器对应的类型转换服务--\x3e\r\n  <mvc:annotation-driven conversion-service="conversionService"/>\r\n  ```\r\n\r\n  \r\n\r\n## 4.7 请求映射 @RequestMapping\r\n\r\n### 4.7.1 方法注解\r\n\r\n* 名称： @RequestMapping\r\n   类型： 方法注解 \r\n   位置：处理器类中的方法定义上方\r\n   作用：绑定请求地址与对应处理方法间的关系\r\n   范例：\r\n   访问路径： /requestURL1  \r\n\r\n```java\r\n@Controller\r\n@RequestMapping("/user")\r\npublic class UserController {\r\n    @RequestMapping("/requestURL2")\r\n    public String requestURL2() {\r\n        return "page.jsp";\r\n    }\r\n}\r\n```\r\n\r\n### 4.7.2 类注解\r\n\r\n**名称： @RequestMapping**\r\n 类型： 类注解\r\n 位置：处理器类定义上方\r\n 作用：为当前处理器中所有方法设定公共的访问路径前缀\r\n 范例：\r\n 访问路径： /user/requestURL1\r\n\r\n```java\r\n@Controller\r\n@RequestMapping("/user")\r\npublic class UserController {\r\n    @RequestMapping("/requestURL2")\r\n    public String requestURL2() {\r\n        return "page.jsp";\r\n    }\r\n}  \r\n```\r\n\r\n* 常用属性\r\n\r\n  ```java\r\n  @RequestMapping(\r\n      value="/requestURL3", //设定请求路径，与path属性、 value属性相同\r\n      method = RequestMethod.GET, //设定请求方式\r\n      params = "name", //设定请求参数条件\r\n      headers = "content-type=text/*", //设定请求消息头条件\r\n      consumes = "text/*", //用于指定可以接收的请求正文类型（MIME类型）\r\n      produces = "text/*" //用于指定可以生成的响应正文类型（MIME类型）\r\n  )\r\n  public String requestURL3() {\r\n      return "/page.jsp";\r\n  }\r\n  ```\r\n\r\n  \r\n\r\n# 5 响应\r\n\r\n## 5.1 页面跳转\r\n\r\n* 转发（默认）\r\n\r\n```java\r\n@RequestMapping("/showPage1")\r\npublic String showPage1() {\r\n    System.out.println("user mvc controller is running ...");\r\n    return "forward:page.jsp";\r\n}\r\n```\r\n\r\n*  重定向\r\n\r\n```\r\n@RequestMapping("/showPage2")\r\npublic String showPage2() {\r\nSystem.out.println("user mvc controller is running ...");\r\nreturn "redirect:page.jsp";\r\n}\r\n```\r\n\r\n 注意：页面访问地址中所携带的   **/**  \r\n\r\n## 5.2 页面访问快捷设定 (InternalResourceViewResolver)\r\n\r\n  展示页面的保存位置通常固定，且结构相似，可以设定通用的访问路径，简化页面配置格式  \r\n\r\n```java\r\n<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">\r\n    <property name="prefix" value="/WEB-INF/pages/"/>\r\n    <property name="suffix" value=".jsp"/>\r\n/bean>\r\n```\r\n\r\n```java\r\npublic String showPage3() {\r\n    return "page";\r\n}\r\n```\r\n\r\n  **如果未设定了返回值，使用void类型，则默认使用访问路径作页面地址的前缀后缀**  \r\n\r\n```java\r\n//最简页面配置方式，使用访问路径作为页面名称，省略返回值\r\n@RequestMapping("/showPage5")\r\npublic void showPage5() {\r\n    System.out.println("user mvc controller is running ...");\r\n}\r\n```\r\n\r\n## 5.3 带数据页面跳转\r\n\r\n*   方式一：使用HttpServletRequest类型形参进行数据传递  \r\n\r\n  ```java\r\n  @RequestMapping("/showPageAndData1")\r\n  public String showPageAndData1(HttpServletRequest request) {\r\n      request.setAttribute("name","itheima");\r\n      return "page";\r\n  }\r\n  ```\r\n\r\n  \r\n\r\n*   方式二：使用Model类型形参进行数据传递  \r\n\r\n  ```java\r\n  @RequestMapping("/showPageAndData2")\r\n  public String showPageAndData2(Model model) {\r\n      model.addAttribute("name","itheima");\r\n      Book book = new Book();\r\n      book.setName("SpringMVC入门实战");\r\n      book.setPrice(66.6d);\r\n      model.addAttribute("book",book);\r\n      return "page";\r\n  }\r\n  ```\r\n\r\n  \r\n\r\n*   方式三：使用ModelAndView类型形参进行数据传递，将该对象作为返回值传递给调用者  \r\n\r\n  ```java\r\n  //使用ModelAndView形参传递参数，该对象还封装了页面信息\r\n  @RequestMapping("/showPageAndData3")\r\n  public ModelAndView showPageAndData3(ModelAndView modelAndView) {\r\n      //ModelAndView mav = new ModelAndView();    替换形参中的参数\r\n      Book book  = new Book();\r\n      book.setName("SpringMVC入门案例");\r\n      book.setPrice(66.66d);\r\n      //添加数据的方式，key对value\r\n      modelAndView.addObject("book",book);\r\n      //添加数据的方式，key对value\r\n      modelAndView.addObject("name","Jockme");\r\n      //设置页面的方式，该方法最后一次执行的结果生效\r\n      modelAndView.setViewName("page");\r\n      //返回值设定成ModelAndView对象\r\n      return modelAndView;\r\n  }\r\n  ```\r\n\r\n## 5.4 返回json数据\r\n\r\n*   方式一：基于response返回数据的简化格式，返回JSON数据  \r\n\r\n  ```java\r\n  //使用jackson进行json数据格式转化\r\n  @RequestMapping("/showData3")\r\n  @ResponseBody\r\n  public String showData3() throws JsonProcessingException {\r\n      Book book  = new Book();\r\n      book.setName("SpringMVC入门案例");\r\n      book.setPrice(66.66d);\r\n  \r\n      ObjectMapper om = new ObjectMapper();\r\n      return om.writeValueAsString(book);\r\n  }\r\n  ```\r\n\r\n*    使用SpringMVC提供的消息类型转换器将对象与集合数据自动转换为JSON数据    \r\n\r\n  ```java\r\n  //使用SpringMVC注解驱动，对标注@ResponseBody注解的控制器方法进行结果转换，由于返回值为引用类型，自动调用jackson提供的类型转换器进行格式转换\r\n  @RequestMapping("/showData4")\r\n  @ResponseBody\r\n  public Book showData4() {\r\n      Book book  = new Book();\r\n      book.setName("SpringMVC入门案例");\r\n      book.setPrice(66.66d);\r\n      return book;\r\n  }\r\n  ```\r\n\r\n    需要手工添加信息类型转换器  \r\n\r\n  ```xml\r\n  <bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter">\r\n      <property name="messageConverters">\r\n          <list>\r\n              <bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"/>\r\n          </list>\r\n      </property>\r\n  </bean\r\n  ```\r\n\r\n*   方式三：使用SpringMVC注解驱动简化配置  \r\n\r\n  ```xml\r\n  \x3c!--开启springmvc注解驱动，对@ResponseBody的注解进行格式增强，追加其类型转换的功能，具体实现由MappingJackson2HttpMessageConverter进行--\x3e\r\n  <mvc:annotation-driven/>\r\n  ```\r\n\r\n  \r\n\r\n# 6 Servlet相关接口-Servlet相关接口替换方案\r\n\r\n  **HttpServletRequest / HttpServletResponse / HttpSession**  \r\n\r\n*   **SpringMVC提供访问原始Servlet接口API的功能，通过形参声明即可**  \r\n\r\n  ```java\r\n  @RequestMapping("/servletApi")\r\n  public String servletApi(HttpServletRequest request,\r\n                           HttpServletResponse response, HttpSession session){\r\n      System.out.println(request);\r\n      System.out.println(response);\r\n      System.out.println(session);\r\n      request.setAttribute("name","itheima");\r\n      System.out.println(request.getAttribute("name"));\r\n      return "page.jsp";\r\n  }\r\n  ```\r\n\r\n*   **Head数据获取**  \r\n\r\n   名称： @RequestHeader\r\n   类型： 形参注解\r\n   位置：处理器类中的方法形参前方\r\n   作用：绑定请求头数据与对应处理方法形参间的关系\r\n   范例：\r\n\r\n  ```java\r\n  @RequestMapping("/headApi")\r\n  public String headApi(@RequestHeader("Accept-Language") String head){\r\n      System.out.println(head);\r\n      return "page.jsp";\r\n  }  \r\n  ```\r\n\r\n*   **Cookie数据获取**  \r\n\r\n   名称： @CookieValue\r\n   类型： 形参注解\r\n   位置：处理器类中的方法形参前方\r\n   作用：绑定请求Cookie数据与对应处理方法形参间的关系\r\n   范例：\r\n\r\n  ```java\r\n  @RequestMapping("/cookieApi")\r\n  public String cookieApi(@CookieValue("JSESSIONID") String jsessionid){\r\n      System.out.println(jsessionid);\r\n      return "page.jsp";\r\n  }  \r\n  ```\r\n\r\n*   **Session数据获取**  \r\n\r\n   名称： @SessionAttribute\r\n   类型： 形参注解\r\n   位置：处理器类中的方法形参前方\r\n   作用：绑定请求Session数据与对应处理方法形参间的关系\r\n   范例：\r\n\r\n  ```java\r\n  @RequestMapping("/sessionApi")\r\n  public String sessionApi(@SessionAttribute("name") String name){\r\n      System.out.println(name);\r\n      return "page.jsp";\r\n  }  \r\n  ```\r\n\r\n*   **Session数据设置（了解）**  \r\n\r\n   名称： @SessionAttributes\r\n   类型： 类注解\r\n   位置：处理器类上方\r\n   作用：声明放入session范围的变量名称，适用于Model类型数据传参\r\n   范例：\r\n\r\n  ```java\r\n  @Controller\r\n  @SessionAttributes(names={"name"})\r\n  public class ServletController {\r\n      @RequestMapping("/setSessionData2")\r\n      public String setSessionDate2(Model model) {\r\n          model.addAttribute("name", "Jock2");\r\n          return "page.jsp";\r\n      }\r\n  }  \r\n  ```\r\n\r\n*   **注解式参数数据封装底层原理**  \r\n\r\n   数据的来源不同，对应的处理策略要进行区分\r\n   Head\r\n   Cookie\r\n   Session\r\n   SpringMVC使用策略模式进行处理分发\r\n   顶层接口： HandlerMethodArgumentResolver\r\n   实现类： ……  '},"82b5":function(n,e,t){"use strict";t.r(e),e["default"]='\x3c!-- TOC --\x3e\n\n- [一文搞懂 RabbitMQ 的重要概念以及安装](#一文搞懂-rabbitmq-的重要概念以及安装)\n  - [一 RabbitMQ 介绍](#一-rabbitmq-介绍)\n    - [1.1 RabbitMQ 简介](#11-rabbitmq-简介)\n    - [1.2 RabbitMQ 核心概念](#12-rabbitmq-核心概念)\n      - [1.2.1 Producer(生产者) 和 Consumer(消费者)](#121-producer生产者-和-consumer消费者)\n      - [1.2.2 Exchange(交换器)](#122-exchange交换器)\n      - [1.2.3 Queue(消息队列)](#123-queue消息队列)\n      - [1.2.4 Broker（消息中间件的服务节点）](#124-broker消息中间件的服务节点)\n      - [1.2.5 Exchange Types(交换器类型)](#125-exchange-types交换器类型)\n        - [① fanout](#-fanout)\n        - [② direct](#-direct)\n        - [③ topic](#-topic)\n        - [④ headers(不推荐)](#-headers不推荐)\n  - [二 安装 RabbitMq](#二-安装-rabbitmq)\n    - [2.1 安装 erlang](#21-安装-erlang)\n    - [2.2 安装 RabbitMQ](#22-安装-rabbitmq)\n\n\x3c!-- /TOC --\x3e\n\n# 一文搞懂 RabbitMQ 的重要概念以及安装\n\n## 一 RabbitMQ 介绍\n\n这部分参考了 《RabbitMQ实战指南》这本书的第 1 章和第 2 章。\n\n### 1.1 RabbitMQ 简介\n\nRabbitMQ 是采用 Erlang 语言实现 AMQP(Advanced Message Queuing Protocol，高级消息队列协议）的消息中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。\n\nRabbitMQ 发展到今天，被越来越多的人认可，这和它在易用性、扩展性、可靠性和高可用性等方面的卓著表现是分不开的。RabbitMQ 的具体特点可以概括为以下几点：\n\n- **可靠性：** RabbitMQ使用一些机制来保证消息的可靠性，如持久化、传输确认及发布确认等。\n- **灵活的路由：** 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能，RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起，也可以通过插件机制来实现自己的交换器。这个后面会在我们讲 RabbitMQ 核心概念的时候详细介绍到。\n- **扩展性：** 多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。\n- **高可用性：** 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队列仍然可用。\n- **支持多种协议：** RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP、MQTT 等多种消息中间件协议。\n- **多语言客户端：** RabbitMQ几乎支持所有常用语言，比如 Java、Python、Ruby、PHP、C#、JavaScript等。\n- **易用的管理界面：** RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。在安装 RabbitMQ 的时候会介绍到，安装好 RabbitMQ 就自带管理界面。\n- **插件机制：** RabbitMQ 提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。感觉这个有点类似 Dubbo 的 SPI机制。\n\n### 1.2 RabbitMQ 核心概念\n\nRabbitMQ 整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。可以把消息传递的过程想象成：当你将一个包裹送到邮局，邮局会暂存并最终将邮件通过邮递员送到收件人的手上，RabbitMQ就好比由邮局、邮箱和邮递员组成的一个系统。从计算机术语层面来说，RabbitMQ 模型更像是一种交换机模型。\n\n下面再来看看图1—— RabbitMQ 的整体模型架构。\n\n![图1-RabbitMQ 的整体模型架构](RabbitMQ入门看这一篇就够了.assets/96388546.jpg)\n\n下面我会一一介绍上图中的一些概念。\n\n#### 1.2.1 Producer(生产者) 和 Consumer(消费者)\n\n- **Producer(生产者)** :生产消息的一方（邮件投递者）\n- **Consumer(消费者)** :消费消息的一方（邮件收件人）\n\n消息一般由 2 部分组成：**消息头**（或者说是标签 Label）和 **消息体**。消息体也可以称为 payLoad ,消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。生产者把消息交由 RabbitMQ 后，RabbitMQ 会根据消息头把消息发送给感兴趣的 Consumer(消费者)。\n\n#### 1.2.2 Exchange(交换器)\n\n在 RabbitMQ 中，消息并不是直接被投递到 **Queue(消息队列)** 中的，中间还必须经过 **Exchange(交换器)** 这一层，**Exchange(交换器)** 会把我们的消息分配到对应的 **Queue(消息队列)** 中。\n\n**Exchange(交换器)** 用来接收生产者发送的消息并将这些消息路由给服务器中的队列中，如果路由不到，或许会返回给 **Producer(生产者)** ，或许会被直接丢弃掉 。这里可以将RabbitMQ中的交换器看作一个简单的实体。\n\n**RabbitMQ 的 Exchange(交换器) 有4种类型，不同的类型对应着不同的路由策略**：**direct(默认)**，**fanout**, **topic**, 和 **headers**，不同类型的Exchange转发消息的策略有所区别。这个会在介绍 **Exchange Types(交换器类型)** 的时候介绍到。\n\nExchange(交换器) 示意图如下：\n\n![Exchange(交换器) 示意图](RabbitMQ入门看这一篇就够了.assets/24007899.jpg)\n\n生产者将消息发给交换器的时候，一般会指定一个 **RoutingKey(路由键)**，用来指定这个消息的路由规则，而这个 **RoutingKey 需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效**。\n\nRabbitMQ 中通过 **Binding(绑定)** 将 **Exchange(交换器)** 与 **Queue(消息队列)** 关联起来，在绑定的时候一般会指定一个 **BindingKey(绑定建)** ,这样 RabbitMQ 就知道如何正确将消息路由到队列了,如下图所示。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和 Queue 的绑定可以是多对多的关系。\n\nBinding(绑定) 示意图：\n\n![Binding(绑定) 示意图](RabbitMQ入门看这一篇就够了.assets/70553134.jpg)\n\n生产者将消息发送给交换器时，需要一个RoutingKey,当 BindingKey 和 RoutingKey 相匹配时，消息会被路由到对应的队列中。在绑定多个队列到同一个交换器的时候，这些绑定允许使用相同的 BindingKey。BindingKey 并不是在所有的情况下都生效，它依赖于交换器类型，比如fanout类型的交换器就会无视，而是将消息路由到所有绑定到该交换器的队列中。\n\n#### 1.2.3 Queue(消息队列)\n\n**Queue(消息队列)** 用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。\n\n**RabbitMQ** 中消息只能存储在 **队列** 中，这一点和 **Kafka** 这种消息中间件相反。Kafka 将消息存储在 **topic（主题）** 这个逻辑层面，而相对应的队列逻辑只是topic实际存储文件中的位移标识。 RabbitMQ 的生产者生产消息并最终投递到队列中，消费者可以从队列中获取消息并消费。\n\n**多个消费者可以订阅同一个队列**，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，这样避免消息被重复消费。\n\n**RabbitMQ** 不支持队列层面的广播消费,如果有广播消费的需求，需要在其上进行二次开发,这样会很麻烦，不建议这样做。\n\n#### 1.2.4 Broker（消息中间件的服务节点）\n\n对于 RabbitMQ 来说，一个 RabbitMQ Broker 可以简单地看作一个 RabbitMQ 服务节点，或者RabbitMQ服务实例。大多数情况下也可以将一个 RabbitMQ Broker 看作一台 RabbitMQ 服务器。\n\n下图展示了生产者将消息存入 RabbitMQ Broker,以及消费者从Broker中消费数据的整个流程。\n\n![消息队列的运转过程](RabbitMQ入门看这一篇就够了.assets/67952922.jpg)\n\n这样图1中的一些关于 RabbitMQ 的基本概念我们就介绍完毕了，下面再来介绍一下 **Exchange Types(交换器类型)** 。\n\n#### 1.2.5 Exchange Types(交换器类型)\n\nRabbitMQ 常用的 Exchange Type 有 **fanout**、**direct**、**topic**、**headers** 这四种（AMQP规范里还提到两种 Exchange Type，分别为 system 与 自定义，这里不予以描述）。\n\n##### ① fanout\n\nfanout 类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中，不需要做任何判断操作，所以 fanout 类型是所有的交换机类型里面速度最快的。fanout 类型常用来广播消息。\n\n##### ② direct\n\ndirect 类型的Exchange路由规则也很简单，它会把消息路由到那些 Bindingkey 与 RoutingKey 完全匹配的 Queue 中。 \n\n![direct 类型交换器](RabbitMQ入门看这一篇就够了.assets/37008021.jpg)\n\n以上图为例，如果发送消息的时候设置路由键为“warning”,那么消息会路由到 Queue1 和 Queue2。如果在发送消息的时候设置路由键为"Info”或者"debug”，消息只会路由到Queue2。如果以其他的路由键发送消息，则消息不会路由到这两个队列中。\n\ndirect 类型常用在处理有优先级的任务，根据任务的优先级把消息发送到对应的队列，这样可以指派更多的资源去处理高优先级的队列。\n\n##### ③ topic\n\n前面讲到direct类型的交换器路由规则是完全匹配 BindingKey 和 RoutingKey ，但是这种严格的匹配方式在很多情况下不能满足实际业务的需求。topic类型的交换器在匹配规则上进行了扩展，它与 direct 类型的交换器相似，也是将消息路由到 BindingKey 和 RoutingKey 相匹配的队列中，但这里的匹配规则有些不同，它约定：\n\n- RoutingKey 为一个点号“．”分隔的字符串（被点号“．”分隔开的每一段独立的字符串称为一个单词），如 “com.rabbitmq.client”、“java.util.concurrent”、“com.hidden.client”;\n- BindingKey 和 RoutingKey 一样也是点号“．”分隔的字符串；\n- BindingKey 中可以存在两种特殊字符串“\\*”和“#”，用于做模糊匹配，其中“\\*”用于匹配一个单词，“#”用于匹配多个单词(可以是零个)。\n\n![topic 类型交换器](RabbitMQ入门看这一篇就够了.assets/73843.jpg)\n\n以上图为例：\n\n- 路由键为 “com.rabbitmq.client” 的消息会同时路由到 Queue1 和 Queue2;\n- 路由键为 “com.hidden.client” 的消息只会路由到 Queue2 中；\n- 路由键为 “com.hidden.demo” 的消息只会路由到 Queue2 中；\n- 路由键为 “java.rabbitmq.demo” 的消息只会路由到 Queue1 中；\n- 路由键为 “java.util.concurrent” 的消息将会被丢弃或者返回给生产者（需要设置 mandatory 参数），因为它没有匹配任何路由键。\n\n##### ④ headers(不推荐)\n\nheaders 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。在绑定队列和交换器时指定一组键值对，当发送消息到交换器时，RabbitMQ会获取到该消息的 headers（也是一个键值对的形式)，对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在。\n\n## 二 安装 RabbitMQ\n\n通过 Docker 安装非常方便，只需要几条命令就好了，我这里是只说一下常规安装方法。\n\n前面提到了 RabbitMQ 是由 Erlang语言编写的，也正因如此，在安装RabbitMQ 之前需要安装 Erlang。\n\n注意：在安装 RabbitMQ 的时候需要注意 RabbitMQ 和 Erlang 的版本关系，如果不注意的话会导致出错，两者对应关系如下:\n\n![RabbitMQ 和 Erlang 的版本关系](RabbitMQ入门看这一篇就够了.assets/RabbitMQ-Erlang.png)\n\n### 2.1 安装 erlang\n\n**1 下载 erlang 安装包**\n\n在官网下载然后上传到 Linux 上或者直接使用下面的命令下载对应的版本。\n\n```shell\n[root@SnailClimb local]#wget https://erlang.org/download/otp_src_19.3.tar.gz\n```\n\nerlang 官网下载：[https://www.erlang.org/downloads](https://www.erlang.org/downloads)  \n\n **2 解压 erlang 安装包**\n\n```shell\n[root@SnailClimb local]#tar -xvzf otp_src_19.3.tar.gz\n```\n\n**3 删除 erlang 安装包**\n\n```shell\n[root@SnailClimb local]#rm -rf otp_src_19.3.tar.gz\n```\n\n**4 安装 erlang 的依赖工具**\n\n```shell\n[root@SnailClimb local]#yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel unixODBC-devel\n```\n\n**5 进入erlang 安装包解压文件对 erlang 进行安装环境的配置**\n\n新建一个文件夹\n\n```shell\n[root@SnailClimb local]# mkdir erlang\n```\n\n对 erlang 进行安装环境的配置\n\n```shell\n[root@SnailClimb otp_src_19.3]# \n./configure --prefix=/usr/local/erlang --without-javac\n```\n\n**6 编译安装**\n\n```shell\n[root@SnailClimb otp_src_19.3]# \nmake && make install\n```\n\n**7 验证一下 erlang 是否安装成功了**\n\n```shell\n[root@SnailClimb otp_src_19.3]# ./bin/erl\n```\n运行下面的语句输出“hello world”\n\n```erlang\n io:format("hello world~n", []).\n```\n![输出“hello world”](RabbitMQ入门看这一篇就够了.assets/49570541.jpg)\n\n大功告成，我们的 erlang 已经安装完成。\n\n**8 配置  erlang 环境变量**\n\n```shell\n[root@SnailClimb etc]# vim profile\n```\n\n追加下列环境变量到文件末尾\n\n```shell\n#erlang\nERL_HOME=/usr/local/erlang\nPATH=$ERL_HOME/bin:$PATH\nexport ERL_HOME PATH\n```\n\n运行下列命令使配置文件`profile`生效\n\n```shell\n[root@SnailClimb etc]# source /etc/profile\n```\n\n输入 erl 查看 erlang 环境变量是否配置正确\n\n```shell\n[root@SnailClimb etc]# erl\n```\n\n![输入 erl 查看 erlang 环境变量是否配置正确](RabbitMQ入门看这一篇就够了.assets/62504246.jpg)\n\n### 2.2 安装 RabbitMQ\n\n**1. 下载rpm** \n\n```shell\nwget https://www.rabbitmq.com/releases/rabbitmq-server/v3.6.8/rabbitmq-server-3.6.8-1.el7.noarch.rpm\n```\n或者直接在官网下载\n\n[https://www.rabbitmq.com/install-rpm.html](https://www.rabbitmq.com/install-rpm.html)\n\n**2. 安装rpm**\n\n```shell\nrpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc\n```\n紧接着执行：\n\n```shell\nyum install rabbitmq-server-3.6.8-1.el7.noarch.rpm\n```\n中途需要你输入"y"才能继续安装。\n\n**3 开启 web 管理插件**\n\n```shell\nrabbitmq-plugins enable rabbitmq_management\n```\n\n**4 设置开机启动**\n\n```shell\nchkconfig rabbitmq-server on\n```\n\n**5. 启动服务**\n\n```shell\nservice rabbitmq-server start\n```\n\n**6. 查看服务状态**\n\n```shell\nservice rabbitmq-server status\n```\n\n**7. 访问 RabbitMQ 控制台**\n\n浏览器访问：http://你的ip地址:15672/\n\n默认用户名和密码：guest/guest; 但是需要注意的是：guest用户只是被容许从localhost访问。官网文档描述如下：\n\n```shell\n“guest” user can only connect via localhost\n```\n\n**解决远程访问 RabbitMQ 远程访问密码错误**\n\n新建用户并授权 \n\n```shell\n[root@SnailClimb rabbitmq]# rabbitmqctl add_user root root\nCreating user "root" ...\n[root@SnailClimb rabbitmq]# rabbitmqctl set_user_tags root administrator\n\nSetting tags for user "root" to [administrator] ...\n[root@SnailClimb rabbitmq]# \n[root@SnailClimb rabbitmq]# rabbitmqctl set_permissions -p / root ".*" ".*" ".*"\nSetting permissions for user "root" in vhost "/" ...\n\n```\n\n再次访问:http://你的ip地址:15672/ ,输入用户名和密码：root root\n\n![RabbitMQ控制台](RabbitMQ入门看这一篇就够了.assets/45835332.jpg)\n\n'},8648:function(n,e,t){"use strict";t.r(e),e["default"]='EL&Filter&Listener-授课\n\n# 1 EL表达式和JSTL\n\n## 1.1 EL表达式\n\n### 1.1.1 EL表达式概述\n\n**基本概念**\n\nEL表达式，全称是Expression Language。意为表达式语言。它是Servlet规范中的一部分，是JSP2.0规范加入的内容。其作用是用于在JSP页面中获取数据，从而让我们的JSP脱离java代码块和JSP表达式。\n\n**基本语法**\n\nEL表达式的语法格式非常简单，写为 <b><font color=\'red\' size=\'5\'>${表达式内容}</font></b>\n\n例如：在浏览器中输出请求域中名称为message的内容。\n\n假定，我们在请求域中存入了一个名称为message的数据（`request.setAttribute("message","EL");`），此时在jsp中获取的方式，如下表显示：\n\n| Java代码块                                                   | JSP表达式                              | EL表达式                              |\n| :----------------------------------------------------------- | :------------------------------------- | :------------------------------------ |\n| `<%<br/> <br/> String message = (String)request.getAttribute("message");<br/> out.write(message);<br/>%>` | `<%=request.getAttribute("message")%>` | <font color=\'red\'>`${message}`</font> |\n\n通过上面我们可以看出，都可以从请求域中获取数据，但是EL表达式写起来是最简单的方式。这也是以后我们在实际开发中，当使用JSP作为视图时，绝大多数都会采用的方式。\n\n### 1.1.2 EL表达式的入门案例\n\n#### 第一步：创建JavaWeb工程\n\n![入门案例1](./EL&Filter&Listener-授课.assets/入门案例1.png)\n\n#### 第二步：创建jsp页面\n\n![入门案例2](./EL&Filter&Listener-授课.assets/入门案例2.png)\n\n#### 第三步：在JSP页面中编写代码\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n  <head>\n    <title>EL表达式入门案例</title>\n  </head>\n  <body>\n    <%--使用java代码在请求域中存入一个名称为message的数据--%>\n    <% request.setAttribute("message","Expression Language");%>\n\n    Java代码块获取：<% out.print(request.getAttribute("message"));%>\n    <br/>\n    JSP表达式获取：<%=request.getAttribute("message")%>\n    <br/>\n    EL表达式获取：${message}\n  </body>\n</html>\n```\n\n#### 第四步：部署工程\n\n![入门案例3](./EL&Filter&Listener-授课.assets/入门案例3.png)\n\n#### 第五步：运行测试\n\n![入门案例4](./EL&Filter&Listener-授课.assets/入门案例4.png)\n\n### 1.1.2 EL表达式基本用法\n\n在前面的概述介绍中，我们介绍了EL表达式的作用，它就是用于获取数据的，那么它是从哪获取数据呢？\n\n#### 1）获取四大域中的数据\n\n它只能从四大域中获取数据，调用的就是`findAttribute(name,value);`方法，根据名称由小到大逐个域中查找，找到就返回，找不到就什么都不显示。\n\n它可以获取对象，可以是对象中关联其他对象，可以是一个List集合，也可以是一个Map集合。具体代码如下：\n\n**创建两个实体类，User和Address**\n\n```java\n/**\n * 用户的实体类\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class User implements Serializable{\n\n\tprivate String name = "黑马程序员";\n\tprivate int age = 18;\n\tprivate Address address = new Address();\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n\tpublic Address getAddress() {\n\t\treturn address;\n\t}\n\tpublic void setAddress(Address address) {\n\t\tthis.address = address;\n\t}\t\n}\n```\n\n```java\n/**\n * 地址的实体类\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class Address implements Serializable {\n\n\tprivate String province = "北京";\n\tprivate String city = "昌平区";\n\tpublic String getProvince() {\n\t\treturn province;\n\t}\n\tpublic void setProvince(String province) {\n\t\tthis.province = province;\n\t}\n\tpublic String getCity() {\n\t\treturn city;\n\t}\n\tpublic void setCity(String city) {\n\t\tthis.city = city;\n\t}\n}\n```\n\n**JSP代码**\n\n```jsp\n<%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%>\n<%@ page import="com.itheima.domain.User" %>\n<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">\n<html>\n\t<head>\n\t\t<title>EL入门</title>\n\t</head>\n\t<body>\n\t\t<%--EL表达式概念：\n\t\t\t\t它是Expression Language的缩写。它是一种替换jsp表达式的语言。\n\t\t\tEL表达式的语法：\n\t\t\t\t${表达式}\n\t\t\t\t表达式的特点：有明确的返回值。\n\t\t\t\tEL表达式就是把内容输出到页面上\n\t\t\tEL表达式的注意事项：\n\t\t\t\t1.EL表达式没有空指针异常\n\t\t\t\t2.EL表达式没有数组下标越界\n\t\t\t\t3.EL表达式没有字符串拼接\n\t\t\tEL表达式的数据获取：\n\t\t\t\t它只能在四大域对象中获取数据，不在四大域对象中的数据它取不到。\n\t\t\t\t它的获取方式就是findAttribute(String name)\n\t\t --%>\n\t\t <br/>-----------获取对象数据---------------------<br/>\n\t\t <% //1.把用户信息存入域中\n\t\t \tUser user = new User();\n\t\t \tpageContext.setAttribute("u",user);\n\t\t  %>\n\t\t  ${u}===============输出的是内存地址<%--就相当于调用此行代码<%=pageContext.findAttribute("u")%> --%><br/>\n\t\t  ${u.name}<%--就相当于调用此行代码<% User user = (User) pageContext.findAttribute("u");out.print(user.getName());%> --%><br/>\n\t\t  ${u.age}\n\t\t <br/>-----------获取关联对象数据------------------<br/>\n\t\t ${u.address}==========输出的address对象的地址<br/>\n\t\t ${u.address.province}${u.address.city}<br/>\n\t\t ${u["address"][\'province\']}\n\t\t <br/>-----------获取数组数据---------------------<br/>\n\t\t <% String[] strs = new String[]{"He","llo","Expression","Language"}; \n\t\t \tpageContext.setAttribute("strs", strs);\n\t\t %>\n\t\t ${strs[0]}==========取的数组中下标为0的元素<br/>\n\t\t ${strs[3]}\n\t\t ${strs[5]}===========如果超过了数组的下标，则什么都不显示<br/>\n\t\t ${strs["2"]}=========会自动为我们转换成下标<br/>\n\t\t ${strs[\'1\']}\n\t\t <br/>-----------获取List集合数据-----------------<br/>\n\t\t <% List<String> list = new ArrayList<String>();\n\t\t \tlist.add("AAA");\n\t\t \tlist.add("BBB");\n\t\t \tlist.add("CCC");\n\t\t \tlist.add("DDD");\n\t\t \tpageContext.setAttribute("list", list);\n\t\t  %>\n\t\t ${list}<br/>\n\t\t ${list[0] }<br/>\n\t\t ${list[3] }<br/>\t \n\t\t <br/>-----------获取Map集合数据------------------<br/>\n\t\t <% Map<String,User> map = new HashMap<String,User>();\n\t\t \tmap.put("aaa",new User());\n\t\t \tpageContext.setAttribute("map", map);\n\t\t  %>\n\t\t  ${map}<br/>\n\t\t  ${map.aaa}<%--获取map的value，是通过get(Key) --%><br/>\n\t\t  ${map.aaa.name}${map.aaa.age}<br/>\n\t\t  ${map["aaa"].name }\n\t</body>\n</html>\n```\n\n运行结果如图：\n\n![eldemo1](./EL&Filter&Listener-授课.assets/eldemo1.png)\n\n#### 2）EL表达式的注意事项\n\n在使用EL表达式时，它帮我们做了一些处理，使我们在使用时可以避免一些错误。它没有空指针异常，没有数组下标越界，没有字符串拼接。\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n  <head>\n    <title>EL表达式的注意事项</title>\n  </head>\n  <body>\n    <%--EL表达式的三个没有--%>\n    第一个：没有空指针异常<br/>\n    <% String str = null;\n       request.setAttribute("testNull",str);\n    %>\n    ${testNull}\n    <hr/>\n    第二个：没有数组下标越界<br/>\n    <% String[] strs = new String[]{"a","b","c"};\n       request.setAttribute("strs",strs);\n    %>\n    取第一个元素：${strs[0]}\n    取第六个元素：${strs[5]}\n    <hr/>\n    第三个：没有字符串拼接<br/>\n    <%--${strs[0]+strs[1]}--%>\n    ${strs[0]}+${strs[1]}\n  </body>\n</html>\n```\n\n运行结果图：\n\n\\\\\n\n#### 3）EL表达式的使用细节\n\nEL表达式除了能在四大域中获取数据，同时它可以访问其他隐式对象，并且访问对象有返回值的方法.\n\n#### 4）EL表达式的运算符\n\nEL表达式中运算符如下图所示，它们都是一目了然的：\n\n![1577782263203](./EL&Filter&Listener-授课.assets/1577782263203.png)\n\n![1577782270585](./EL&Filter&Listener-授课.assets/1577782270585.png)\n\n但是有两个特殊的运算符，使用方式的代码如下：\n\n```jsp\n<%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%>\n<%@ page import="com.itheima.domain.User" %>\n<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">\n<html>\n\t<head>\n\t\t<title>EL两个特殊的运算符</title>\n\t</head>\n\t<body>\n\t\t<%--empty运算符：\n\t\t\t它会判断：对象是否为null，字符串是否为空字符串，集合中元素是否是0个\n\t\t--%>\n\t\t<% String str = null;\n\t\t  String str1 = "";\n\t\t  List<String> slist = new ArrayList<String>();\n\t\t  pageContext.setAttribute("str", str);\n\t\t  pageContext.setAttribute("str1", str1);\n\t\t  pageContext.setAttribute("slist", slist);\n\t\t%>\n\t\t${empty str}============当对象为null返回true<br/>\n\t\t${empty str1 }==========当字符串为空字符串是返回true(注意：它不会调用trim()方法)<br>\n\t\t${empty slist}==========当集合中的元素是0个时，是true\n\t\t<hr/>\n\t\t<%--三元运算符 \n\t\t\t 条件?真:假\n\t\t--%>\n\t\t<% request.setAttribute("gender", "female"); %>\n\t\t<input type="radio" name="gender" value="male" ${gender eq "male"?"checked":""} >男\n\t\t<input type="radio" name="gender" value="female" ${gender eq "female"?"checked":""}>女\n\t</body>\n</html>\n```\n\n运行结果图：\n\n![eldemo4](./EL&Filter&Listener-授课.assets/eldemo4.png)\n\n### 1.1.3 EL表达式的11个隐式对象\n\n#### 1）隐式对象介绍\n\nEL表达式也为我们提供隐式对象，可以让我们不声明直接来使用，十一个对象见下表，需要注意的是，它和JSP的隐式对象不是一回事：\n\n| EL中的隐式对象   | 类型                          | 对应JSP隐式对象 | 备注                                    |\n| ---------------- | ----------------------------- | --------------- | --------------------------------------- |\n| PageContext      | Javax.serlvet.jsp.PageContext | PageContext     | 完全一样                                |\n| ApplicationScope | Java.util.Map                 | 没有            | 应用层范围                              |\n| SessionScope     | Java.util.Map                 | 没有            | 会话范围                                |\n| RequestScope     | Java.util.Map                 | 没有            | 请求范围                                |\n| PageScope        | Java.util.Map                 | 没有            | 页面层范围                              |\n| Header           | Java.util.Map                 | 没有            | 请求消息头key，值是value（一个）        |\n| HeaderValues     | Java.util.Map                 | 没有            | 请求消息头key，值是数组（一个头多个值） |\n| Param            | Java.util.Map                 | 没有            | 请求参数key，值是value（一个）          |\n| ParamValues      | Java.util.Map                 | 没有            | 请求参数key，值是数组（一个名称多个值） |\n| InitParam        | Java.util.Map                 | 没有            | 全局参数，key是参数名称，value是参数值  |\n| Cookie           | Java.util.Map                 | 没有            | Key是cookie的名称，value是cookie对象    |\n\n## 1.2 JSTL\n\n### 1.2.1 JSTL概述\n\n#### 1）简介\n\nJSTL的全称是：JSP Standard Tag Libary。它是JSP中标准的标签库。它是由Apache实现的。\n\n它由以下5个部分组成：\n\n| 组成      | 作用         | 说明                           |\n| --------- | ------------ | ------------------------------ |\n| Core      | 核心标签库。 | 通用逻辑处理                   |\n| Fmt       | 国际化有关。 | 需要不同地域显示不同语言时使用 |\n| Functions | EL函数       | EL表达式可以使用的方法         |\n| SQL       | 操作数据库。 | 不用                           |\n| XML       | 操作XML。    | 不用                           |\n\n#### 2）使用要求\n\n要想使用JSTL标签库，在javaweb工程中需要导入坐标。首先是在工程的WEB-INF目录中创建一个lib目录，接下来把jstl的jar拷贝到lib目录中，最后在jar包上点击右键，然后选择【Add as Libary】添加。如下图所示：\n\n![jstl的jar包](./EL&Filter&Listener-授课.assets/jstl的jar包.png)\n\n### 1.2.2 核心标签库\n\n在我们实际开发中，用到的jstl标签库主要以核心标签库为准，偶尔会用到国际化标签库的标签。下表中把我们经常可能用到的标签列在此处，其余标签库请同学们参考【JSTL标签库.doc】文档。\n\n| 标签名称                             | 功能分类 | 分类       | 作用             |\n| ------------------------------------ | -------- | ---------- | ---------------- |\n| `<c:if>`                             | 流程控制 | 核心标签库 | 用于判断         |\n| `<c:choose> ,<c:when>,<c:otherwise>` | 流程控制 | 核心标签库 | 用于多个条件判断 |\n| `<c:foreache>`                       | 迭代操作 | 核心标签库 | 用于循环遍历     |\n\n### 1.2.3 JSTL使用\n\n```jsp\n<%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%>\n<%--导入jstl标签库 --%>\n<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>\n<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">\n<html>\n  <head>\n    <title>JSTL的常用标签</title>\n  </head>\n  <body>\n    <%-- c:if  c:choose   c:when c:otherwise --%>\n    <% pageContext.setAttribute("score","F"); %>\n    <c:if test="${pageScope.score eq \'A\' }">\n    \t优秀\n    </c:if>\n    <c:if\ttest="${pageScope.score eq \'C\' }">\n    \t一般\n    </c:if>\n    <hr/>\n    <c:choose>\n    \t<c:when test="${pageScope.score eq \'A\' }">\n    \t\tAAA\n    \t</c:when>\n    \t<c:when test="${pageScope.score eq \'B\' }">BBB\n    \t</c:when>\n    \t<c:when test="${pageScope.score eq \'C\' }">CCC\n    \t</c:when>\n    \t<c:when test="${pageScope.score eq \'D\' }">DDD\n    \t</c:when>\n    \t<c:otherwise>其他</c:otherwise>\n    </c:choose>\n    \n    <%-- c:forEach 它是用来遍历集合的\n    \t 属性：\n    \t \titems：要遍历的集合，它可以是EL表达式取出来的\n    \t \tvar：把当前遍历的元素放入指定的page域中。 var的取值就是key,当前遍历的元素就是value\n    \t \t\t注意：它不能支持EL表达式，只能是字符串常量\n    \t \tbegin:开始遍历的索引\n    \t \tend:结束遍历的索引\n    \t \tstep：步长。i+=step\n    \t \tvarStatus：它是一个计数器对象。里面有两个属性，一个是用于记录索引。一个是用于计数。\n    \t \t\t\t   索引是从0开始。计数是从1开始\n    --%>\n    <hr/>\n    <% List<String> list = new ArrayList<String>();\n       list.add("AAA");\n       list.add("BBB");\n       list.add("CCC");\n       list.add("DDD");\n       list.add("EEE");\n       list.add("FFF");\n       list.add("GGG");\n       list.add("HHH");\n       list.add("III");\n       list.add("JJJ");\n       list.add("KKK");\n       list.add("LLL");\n       pageContext.setAttribute("list",list);\n     %>\n\t<c:forEach items="${list}" var="s" begin="1" end="7" step="2">\n    \t${s}<br/>\n    </c:forEach>\n    <hr/>\n    <c:forEach begin="1" end="9" var="num">\n    \t<a href="#">${num}</a>\n    </c:forEach>\n    <hr/>\n    <table>\n    \t<tr>\n    \t\t<td>索引</td>\n    \t\t<td>序号</td>\n    \t\t<td>信息</td>\n    \t</tr>\n    <c:forEach items="${list}" var="s" varStatus="vs">\n    \t<tr>\n    \t\t<td>${vs.index}</td>\n    \t\t<td>${vs.count}</td>\n    \t\t<td>${s}</td>\n    \t</tr>\n    </c:forEach>\n    </table>\n  </body>\n</html>\n```\n\n# 2 Servlet规范中的过滤器-Filter\n\n## 2.1 过滤器入门\n\n### 2.1.1 过滤器概念及作用\n\n过滤器——Filter，它是JavaWeb三大组件之一。另外两个是Servlet和Listener。\n\n它是在2000年发布的Servlet2.3规范中加入的一个接口。是Servlet规范中非常实用的技术。\n\n它可以对web应用中的所有资源进行拦截，并且在拦截之后进行一些特殊的操作。\n\n常见应用场景：URL级别的权限控制；过滤敏感词汇；中文乱码问题等等。\n\n### 2.1.2 过滤器的入门案例\n\n#### 1）前期准备\n\n**创建JavaWeb工程**\n\n![filter_demo1](./EL&Filter&Listener-授课.assets/filter_demo1.png)\n\n**编写和配置接收请求用的Servlet**\n\n```java\n/**\n * 用于接收和处理请求的Servlet\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletDemo1 extends HttpServlet {\n\n    /**\n     * 处理请求的方法\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println("ServletDemo1接收到了请求");\n        req.getRequestDispatcher("/WEB-INF/pages/success.jsp").forward(req,resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n       doGet(req,resp);\n    }\n}\n```\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee\n                      http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"\n         version="3.1"\n         metadata-complete="true">\n    \n    \x3c!--配置Servlet--\x3e\n    <servlet>\n        <servlet-name>ServletDemo1</servlet-name>\n        <servlet-class>com.itheima.web.servlet.ServletDemo1</servlet-class>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>ServletDemo1</servlet-name>\n        <url-pattern>/ServletDemo1</url-pattern>\n    </servlet-mapping>\n</web-app>\n\n```\n\n**编写index.jsp**\n\n```jsp\n<%-- Created by IntelliJ IDEA. --%>\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n  <head>\n    <title>主页面</title>\n  </head>\n  <body>\n    <a href="${pageContext.request.contextPath}/ServletDemo1">访问ServletDemo1</a>\n  </body>\n</html>\n```\n\n**编写success.jsp**\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>成功页面</title>\n</head>\n<body>\n<%System.out.println("success.jsp执行了");%>\n执行成功！\n</body>\n</html>\n\n```\n\n![filter_demo2](./EL&Filter&Listener-授课.assets/filter_demo2.png)\n\n#### 2）过滤器的编写步骤\n\n**编写过滤器**\n\n```java\n/**\n * Filter的入门案例\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class FilterDemo1 implements Filter {\n\n    /**\n     * 过滤器的核心方法\n     * @param request\n     * @param response\n     * @param chain\n     * @throws IOException\n     * @throws ServletException\n     */\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        /**\n         * 如果不写此段代码，控制台会输出两次：FilterDemo1拦截到了请求。\n         */\n        HttpServletRequest req = (HttpServletRequest) request;\n        String requestURI = req.getRequestURI();\n        if (requestURI.contains("favicon.ico")) {\n            return;\n        }\n        System.out.println("FilterDemo1拦截到了请求");\n    }\n}\n```\n\n**配置过滤器**\n\n```xml\n\x3c!--配置过滤器--\x3e\n<filter>\n    <filter-name>FilterDemo1</filter-name>\n    <filter-class>com.itheima.web.filter.FilterDemo1</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>FilterDemo1</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n\n#### 3）测试部署\n\n**部署项目**\n\n![filter_demo3](./EL&Filter&Listener-授课.assets/filter_demo3.png)\n\n**测试结果**\n\n![filter_demo4](./EL&Filter&Listener-授课.assets/filter_demo4.png)\n\n**案例的问题分析及解决**\n\n当我们启动服务，在地址栏输入访问地址后，发现浏览器任何内容都没有，控制台却输出了【FilterDemo1拦截到了请求】，也就是说在访问任何资源的时候，都先经过了过滤器。\n\n这是因为：我们在配置过滤器的拦截规则时，使用了<font color=\'red\' size="5"><b>/*</b></font>,表明访问当前应用下任何资源，此过滤器都会起作用。除了这种全部过滤的规则之外，它还支持特定类型的过滤配置。我们可以稍作调整，就可以不用加上面那段过滤图标的代码了。修改的方式如下：\n\n![filter_demo6](./EL&Filter&Listener-授课.assets/filter_demo6.png)\n\n现在的问题是，我们拦截下来了，点击链接发送请求，运行结果是：\n\n![filter_demo7](./EL&Filter&Listener-授课.assets/filter_demo7.png)\n\n需要对过滤器执行放行操作，才能让他继续执行，那么如何放行的？\n\n我们需要使用`FilterChain`中的`doFilter`方法放行。\n\n![1577953319367](./EL&Filter&Listener-授课.assets/filter_demo5.png)\n\n## 2.2 过滤器的细节\n\n### 2.2.1 过滤器API介绍\n\n#### 1）Filter\n\n![Filter_API](./EL&Filter&Listener-授课.assets/Filter_API.png)\n\n![Filter_API2](./EL&Filter&Listener-授课.assets/Filter_API2.png)\n\n#### 2）FilterConfig\n\n![FilterConfig_API](./EL&Filter&Listener-授课.assets/FilterConfig_API.png)\n\n#### 3）FilterChain\n\n![FilterChain_API](./EL&Filter&Listener-授课.assets/FilterChain_API.png)\n\n### 2.2.2 入门案例过程及生命周期\n\n#### 1）生命周期\n\n**出生——活着——死亡**\n\n**出生：**当应用加载的时候执行实例化和初始化方法。\n\n**活着：**只要应用一直提供服务，对象就一直存在。\n\n**死亡：**当应用卸载时，或者服务器宕机时，对象消亡。\n\n**Filter的实例对象在内存中也只有一份。所以也是单例的。**\n\n#### 2）过滤器核心方法的细节\n\n在`FilterDemo1`的`doFilter`方法添加一行代码，如下：\n\n```java\n/**\n     * 过滤器的核心方法\n     * @param request\n     * @param response\n     * @param chain\n     * @throws IOException\n     * @throws ServletException\n     */\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        /**\n         * 如果不写此段代码，控制台会输出两次：FilterDemo1拦截到了请求。\n\n        HttpServletRequest req = (HttpServletRequest) request;\n        String requestURI = req.getRequestURI();\n        if (requestURI.contains("favicon.ico")) {\n            return;\n        }*/\n        System.out.println("FilterDemo1拦截到了请求");\n        //过滤器放行\n        chain.doFilter(request,response);\n        System.out.println("FilterDemo1放行之后，又回到了doFilter方法");\n    }\n```\n\n测试运行结果，我们发现过滤器放行之后执行完目标资源，仍会回到过滤器中：\n\n![filter_demo8](./EL&Filter&Listener-授课.assets/filter_demo8.png)\n\n### 2.2.3 过滤器初始化参数配置\n\n#### 1）创建过滤器FilterDemo2\n\n```java\n/**\n * Filter的初始化参数配置\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class FilterDemo2 implements Filter {\n\n    private FilterConfig filterConfig;\n\n    /**\n     * 初始化方法\n     * @param filterConfig\n     * @throws ServletException\n     */\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        System.out.println("FilterDemo2的初始化方法执行了");\n        //给过滤器配置对象赋值\n        this.filterConfig = filterConfig;\n    }\n\n    /**\n     * 过滤器的核心方法\n     * @param request\n     * @param response\n     * @param chain\n     * @throws IOException\n     * @throws ServletException\n     */\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n\n        System.out.println("FilterDemo2拦截到了请求");\n        //过滤器放行\n        chain.doFilter(request,response);\n    }\n    \n    /**\n     * 销毁方法\n     */\n    @Override\n    public void destroy() {\n        System.out.println("FilterDemo2的销毁方法执行了");\n    }\n}\n```\n\n#### 2）配置FilterDemo2\n\n```xml\n<filter>\n    <filter-name>FilterDemo2</filter-name>\n    <filter-class>com.itheima.web.filter.FilterDemo2</filter-class>\n    \x3c!--配置过滤器的初始化参数--\x3e\n    <init-param>\n        <param-name>filterInitParamName</param-name>\n        <param-value>filterInitParamValue</param-value>\n    </init-param>\n</filter>\n<filter-mapping>\n    <filter-name>FilterDemo2</filter-name>\n    <url-pattern>/ServletDemo1</url-pattern>\n</filter-mapping>\n```\n\n#### 3）在FilterDemo2的doFilter方法中添加下面的代码\n\n```java\n//根据名称获取过滤器的初始化参数\nString paramValue = filterConfig.getInitParameter("filterInitParamName");\nSystem.out.println(paramValue);\n\n//获取过滤器初始化参数名称的枚举\nEnumeration<String> initNames = filterConfig.getInitParameterNames();\nwhile(initNames.hasMoreElements()){\n    String initName = initNames.nextElement();\n    String initValue = filterConfig.getInitParameter(initName);\n    System.out.println(initName+","+initValue);\n}\n\n//获取ServletContext对象\nServletContext servletContext = filterConfig.getServletContext();\nSystem.out.println(servletContext);\n\n//获取过滤器名称\nString filterName = filterConfig.getFilterName();\nSystem.out.println(filterName);\n```\n\n#### 4）测试运行结果\n\n![FilterConfig_demo](./EL&Filter&Listener-授课.assets/FilterConfig_demo.png)\n\n我们通过这个测试，看到了过滤器的初始化参数配置和获取的使用。但是同学们也肯定发现了，在我们的工程中两个过滤器都起作用了，这就是我们在API中说的链式调用，那么当有多个过滤器，它的执行顺序是什么样的呢？\n\n我们来看下一小节。\n\n### 2.2.5 多个过滤器的执行顺序\n\n#### 1）修改FilterDemo1和FilterDemo2两个过滤器的代码，删掉多余的代码\n\n```java\n/**\n * Filter的入门案例\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class FilterDemo1 implements Filter {\n    /**\n     * 过滤器的核心方法\n     * @param request\n     * @param response\n     * @param chain\n     * @throws IOException\n     * @throws ServletException\n     */\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        \n        System.out.println("FilterDemo1拦截到了请求");\n        //过滤器放行\n        chain.doFilter(request,response);\n    }\n\n    /**\n     * 初始化方法\n     * @param filterConfig\n     * @throws ServletException\n     */\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        System.out.println("FilterDemo1的初始化方法执行了");\n    }\n\n    /**\n     * 销毁方法\n     */\n    @Override\n    public void destroy() {\n        System.out.println("FilterDemo1的销毁方法执行了");\n    }\n}\n```\n\n```java\n/**\n * Filter的初始化参数配置\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class FilterDemo2 implements Filter {\n\n    /**\n     * 初始化方法\n     * @param filterConfig\n     * @throws ServletException\n     */\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        System.out.println("FilterDemo2的初始化方法执行了");\n\n    }\n\n    /**\n     * 过滤器的核心方法\n     * @param request\n     * @param response\n     * @param chain\n     * @throws IOException\n     * @throws ServletException\n     */\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n\n        System.out.println("FilterDemo2拦截到了请求");\n        //过滤器放行\n        chain.doFilter(request,response);\n    }\n\n    /**\n     * 销毁方法\n     */\n    @Override\n    public void destroy() {\n        System.out.println("FilterDemo2的销毁方法执行了");\n    }\n}\n```\n\n#### 2）修改两个过滤器的配置，删掉多余的配置\n\n```xml\n\x3c!--配置过滤器--\x3e\n<filter>\n    <filter-name>FilterDemo1</filter-name>\n    <filter-class>com.itheima.web.filter.FilterDemo1</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>FilterDemo1</filter-name>\n    <url-pattern>/ServletDemo1</url-pattern>\n</filter-mapping>\n\n\n<filter>\n    <filter-name>FilterDemo2</filter-name>\n    <filter-class>com.itheima.web.filter.FilterDemo2</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>FilterDemo2</filter-name>\n    <url-pattern>/ServletDemo1</url-pattern>\n</filter-mapping>\n```\n\n#### 3）测试运行结果\n\n![filter_multi_demo](./EL&Filter&Listener-授课.assets/filter_multi_demo.png)\n\n此处我们看到了多个过滤器的执行顺序，它正好和我们在web.xml中的配置顺序一致，如下图：\n\n![filter_execute_order](./EL&Filter&Listener-授课.assets/filter_execute_order.png)\n\n在过滤器的配置中，有过滤器的声明和过滤器的映射两部分，到底是声明决定顺序，还是映射决定顺序呢？\n\n答案是：<font color=\'red\'><b>`<filter-mapping>`的配置前后顺序决定过滤器的调用顺序，也就是由映射配置顺序决定。</b></font>\n\n### 2.2.6 过滤器的五种拦截行为\n\n我们的过滤器目前拦截的是请求，但是在实际开发中，我们还有请求转发和请求包含，以及由服务器触发调用的全局错误页面。默认情况下过滤器是不参与过滤的，要想使用，需要我们配置。配置的方式如下：\n\n```xml\n\x3c!--配置过滤器--\x3e\n<filter>\n    <filter-name>FilterDemo1</filter-name>\n    <filter-class>com.itheima.web.filter.FilterDemo1</filter-class>\n    \x3c!--配置开启异步支持，当dispatcher配置ASYNC时，需要配置此行--\x3e\n    <async-supported>true</async-supported>\n</filter>\n<filter-mapping>\n    <filter-name>FilterDemo1</filter-name>\n    <url-pattern>/ServletDemo1</url-pattern>\n    \x3c!--过滤请求：默认值。--\x3e\n    <dispatcher>REQUEST</dispatcher>\n    \x3c!--过滤全局错误页面：当由服务器调用全局错误页面时，过滤器工作--\x3e\n    <dispatcher>ERROR</dispatcher>\n    \x3c!--过滤请求转发：当请求转发时，过滤器工作。--\x3e\n    <dispatcher>FORWARD</dispatcher>\n    \x3c!--过滤请求包含：当请求包含时，过滤器工作。它只能过滤动态包含，jsp的include指令是静态包含--\x3e\n    <dispatcher>INCLUDE</dispatcher>\n    \x3c!--过滤异步类型，它要求我们在filter标签中配置开启异步支持--\x3e\n    <dispatcher>ASYNC</dispatcher>\n</filter-mapping>\n```\n\n### 2.2.4 过滤器与Servlet的区别\n\n| 方法/类型                                          | Servlet                                                      | Filter                                                       | 备注                                                         |\n| -------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 初始化                                        方法 | `void   init(ServletConfig);   `                             | `void init(FilterConfig);   `                                | 几乎一样，都是在web.xml中配置参数，用该对象的方法可以获取到。 |\n| 提供服务方法                                       | `void   service(request,response);                                               ` | `void   dofilter(request,response,FilterChain);                                   ` | Filter比Servlet多了一个FilterChain，它不仅能完成Servlet的功能，而且还可以决定程序是否能继续执行。所以过滤器比Servlet更为强大。   在Struts2中，核心控制器就是一个过滤器。 |\n| 销毁方法                                           | `void destroy();`                                            | `void destroy();`                                            |                                                              |\n\n## 2.3 过滤器的使用案例\n\n### 2.3.1 静态资源设置缓存时间过滤器\n\n#### 1） 需求说明\n\n在我们访问html，js，image时，不需要每次都重新发送请求读取资源，就可以通过设置响应消息头的方式，设置缓存时间。但是如果每个Servlet都编写相同的代码，显然不符合我们统一调用和维护的理念。（此处有个非常重要的编程思想：AOP思想，在录制视频时提不提都可以）\n\n因此，我们要采用过滤器来实现功能。\n\n#### 2） 编写步骤\n\n**第一步：创建JavaWeb工程**\n\n![filter2_demo](./EL&Filter&Listener-授课.assets/filter2_demo.png)\n\n**第二步：导入静态资源**\n\n![filter2_demo_staticresource](./EL&Filter&Listener-授课.assets/filter2_demo_staticresource.png)\n\n**第三步：编写过滤器**\n\n```java\n/**\n * 静态资源设置缓存时间\n * \thtml设置为1小时\n *  js设置为2小时\n *  css设置为3小时\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class StaticResourceNeedCacheFilter implements Filter {\n\n    private FilterConfig filterConfig;\n\n    public void init(FilterConfig filterConfig) throws ServletException {\n        this.filterConfig = filterConfig;\n    }\n\n\n    public void doFilter(ServletRequest req, ServletResponse res,\n                         FilterChain chain) throws IOException, ServletException {\n        //1.把doFilter的请求和响应对象转换成跟http协议有关的对象\n        HttpServletRequest  request;\n        HttpServletResponse response;\n        try {\n            request = (HttpServletRequest) req;\n            response = (HttpServletResponse) res;\n        } catch (ClassCastException e) {\n            throw new ServletException("non-HTTP request or response");\n        }\n        //2.获取请求资源URI\n        String uri = request.getRequestURI();\n        //3.得到请求资源到底是什么类型\n        String extend = uri.substring(uri.lastIndexOf(".")+1);//我们只需要判断它是不是html,css,js。其他的不管\n        //4.判断到底是什么类型的资源\n        long time = 60*60*1000;\n        if("html".equals(extend)){\n            //html 缓存1小时\n            String html = filterConfig.getInitParameter("html");\n            time = time*Long.parseLong(html);\n        }else if("js".equals(extend)){\n            //js 缓存2小时\n            String js = filterConfig.getInitParameter("js");\n            time = time*Long.parseLong(js);\n        }else if("css".equals(extend)){\n            //css 缓存3小时\n            String css = filterConfig.getInitParameter("css");\n            time = time*Long.parseLong(css);\n\n        }\n        //5.设置响应消息头\n        response.setDateHeader("Expires", System.currentTimeMillis()+time);\n        //6.放行\n        chain.doFilter(request, response);\n    }\n\n\n    public void destroy() {\n\n    }\n\n}\n```\n\n**第四步：配置过滤器**\n\n```xml\n<filter>\n    <filter-name>StaticResourceNeedCacheFilter</filter-name>\n    <filter-class>com.itheima.web.filter.StaticResourceNeedCacheFilter</filter-class>\n    <init-param>\n        <param-name>html</param-name>\n        <param-value>3</param-value>\n    </init-param>\n    <init-param>\n        <param-name>js</param-name>\n        <param-value>4</param-value>\n    </init-param>\n    <init-param>\n        <param-name>css</param-name>\n        <param-value>5</param-value>\n    </init-param>\n</filter>\n<filter-mapping>\n    <filter-name>StaticResourceNeedCacheFilter</filter-name>\n    <url-pattern>*.html</url-pattern>\n</filter-mapping>\n<filter-mapping>\n    <filter-name>StaticResourceNeedCacheFilter</filter-name>\n    <url-pattern>*.js</url-pattern>\n</filter-mapping>\n<filter-mapping>\n    <filter-name>StaticResourceNeedCacheFilter</filter-name>\n    <url-pattern>*.css</url-pattern>\n</filter-mapping>\n```\n\n#### 3） 测试结果\n\n> 此案例演示时需要注意一下，chrome浏览器刷新时，每次也都会发送请求，所以看不到304状态码。建议用IE浏览器，因为它在刷新时不会再次请求。\n\n![staticresource_demo](./EL&Filter&Listener-授课.assets/staticresource_demo.png)\n\n### 2.3.2 特殊字符过滤器\n\n#### 1）需求说明\n\n在实际开发中，可能会面临一个问题，就是很多输入框都会遇到特殊字符。此时，我们也可以通过过滤器来解决。\n\n例如：\n\n​\t我们模拟一个论坛，有人发帖问：“在HTML中表示水平线的标签是哪个？”。\n\n如果我们在文本框中直接输入`<hr/>`就会出现一条水平线，这个会让发帖人一脸懵。\n\n我们接下来就用过滤器来解决一下。\n\n#### 2）编写步骤\n\n**第一步：创建JavaWeb工程**\n\n沿用第一个案例的工程\n\n**第二步：编写Servlet和JSP**\n\n```java\n/**\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletDemo1 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String content = request.getParameter("content");\n        response.getWriter().write(content);\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n```jsp\n<servlet>\n    <servlet-name>ServletDemo1</servlet-name>\n    <servlet-class>com.itheima.web.servlet.ServletDemo1</servlet-class>\n</servlet>\n<servlet-mapping>\n    <servlet-name>ServletDemo1</servlet-name>\n    <url-pattern>/ServletDemo1</url-pattern>\n</servlet-mapping>\n```\n\n```jsp\n<%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%>\n<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">\n<html>\n<head>\n    <title></title>\n</head>\n<body>\n<form action="${pageContext.request.contextPath}/ServletDemo1" method="POST">\n    回帖：<textarea rows="5" cols="25" name="content"></textarea><br/>\n    <input type="submit" value="发言">\n</form>\n</body>\n</html>\n```\n\n**第三步：编写过滤器**\n\n```java\n\n/**\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class HTMLFilter implements Filter {\n\n    public void init(FilterConfig filterConfig) throws ServletException {\n\n    }\n\n\n    public void doFilter(ServletRequest req, ServletResponse res,\n                         FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest request;\n        HttpServletResponse response;\n        try {\n            request = (HttpServletRequest) req;\n            response = (HttpServletResponse) res;\n        } catch (ClassCastException e) {\n            throw new ServletException("non-HTTP request or response");\n        }\n        //创建一个自己的Request类\n        MyHttpServletRequest2 myrequest = new MyHttpServletRequest2(request);\n        //放行：\n        chain.doFilter(myrequest, response);\n    }\n\n    public void destroy() {\n    }\n}\nclass MyHttpServletRequest2 extends HttpServletRequestWrapper {\n    //提供一个构造方法\n    public MyHttpServletRequest2(HttpServletRequest request){\n        super(request);\n    }\n\n    //重写getParameter方法\n    public String getParameter(String name) {\n        //1.获取出请求正文： 调用父类的获取方法\n        String value = super.getParameter(name);\n        //2.判断value是否有值\n        if(value == null){\n            return null;\n        }\n        return htmlfilter(value);\n    }\n\n    private String htmlfilter(String message){\n        if (message == null)\n            return (null);\n\n        char content[] = new char[message.length()];\n        message.getChars(0, message.length(), content, 0);\n        StringBuilder result = new StringBuilder(content.length + 50);\n        for (int i = 0; i < content.length; i++) {\n            switch (content[i]) {\n                case \'<\':\n                    result.append("&lt;");\n                    break;\n                case \'>\':\n                    result.append("&gt;");\n                    break;\n                case \'&\':\n                    result.append("&amp;");\n                    break;\n                case \'"\':\n                    result.append("&quot;");\n                    break;\n                default:\n                    result.append(content[i]);\n            }\n        }\n        return (result.toString());\n    }\n\n}\n```\n\n**第四步：配置过滤器**\n\n```xml\n<filter>\n    <filter-name>HTMLFilter</filter-name>\n    <filter-class>com.itheima.web.filter.HTMLFilter</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>HTMLFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n\n#### 3）测试结果\n\n![HTMLFilter_demo](./EL&Filter&Listener-授课.assets/HTMLFilter_demo.png)\n\n# 3 Servlet规范中的监听器-Listener\n\n## 3.1 观察者设计模式\n\n在介绍监听器之前，先跟同学们普及一个知识，观察者设计模式。因为所有的监听器都是观察者设计模式的体现。\n\n那什么是观察者设计模式呢？\n\n它是事件驱动的一种体现形式。就好比在做什么事情的时候被人盯着。当对应做到某件事时，触发事件。\n\n观察者模式通常由以下三部分组成：\n\n​            事件源：触发事件的对象。\n\n​\t\t\t事件：触发的动作，里面封装了事件源。\n\n​\t\t\t监听器：当事件源触发事件时，要做的事情。一般是一个接口，由使用者来实现。（此处的思想还涉及了一个涉及模式，我们在JDBC的第二天课程中就给同学们讲解，策略模式）\n\n下图描述了观察者设计模式组成：\n\n![观察者模式](./EL&Filter&Listener-授课.assets/观察者模式.jpg)\n\n## 3.1 Servlet规范中的8个监听器简介\n\n### 3.1.1 监听对象创建的\n\n#### 1）ServletContextListener\n\n```java\n/**\n * 用于监听ServletContext对象创建和销毁的监听器\n * @since v 2.3\n */\n\npublic interface ServletContextListener extends EventListener {\n\n    /**\n     *\t对象创建时执行此方法。该方法的参数是ServletContextEvent事件对象，事件是【创建对象】这个动作\n     *  事件对象中封装着触发事件的来源，即事件源，就是ServletContext\n     */\n    public default void contextInitialized(ServletContextEvent sce) {\n    }\n\n    /**\n     * 对象销毁执行此方法\n     */\n    public default void contextDestroyed(ServletContextEvent sce) {\n    }\n}\n```\n\n#### 2）HttpSessionListener\n\n```java\n/**\n * 用于监听HttpSession对象创建和销毁的监听器\n * @since v 2.3\n */\npublic interface HttpSessionListener extends EventListener {\n\n    /**\n     * 对象创建时执行此方法。\n     */\n    public default void sessionCreated(HttpSessionEvent se) {\n    }\n\n    /**\n     *  对象销毁执行此方法\n     */\n    public default void sessionDestroyed(HttpSessionEvent se) {\n    }\n}\n```\n\n#### 3）ServletRequestListener\n\n```java\n/**\n * 用于监听ServletRequest对象创建和销毁的监听器\n * @since Servlet 2.4\n */\npublic interface ServletRequestListener extends EventListener {\n\n   \t/**\n     *  对象创建时执行此方法。\n     */\n    public default void requestInitialized (ServletRequestEvent sre) {\n    }\n    \n    /**\n     * 对象销毁执行此方法\n     */\n    public default void requestDestroyed (ServletRequestEvent sre) {\n    } \n}\n```\n\n### 3.1.2 监听域中属性发生变化的\n\n#### 1）ServletContextAttributeListener\n\n```java\n/**\n * 用于监听ServletContext域（应用域）中属性发生变化的监听器\n * @since v 2.3\n */\n\npublic interface ServletContextAttributeListener extends EventListener {\n    /**\n     * 域中添加了属性触发此方法。参数是ServletContextAttributeEvent事件对象，事件是【添加属性】。\n     * 事件对象中封装着事件源，即ServletContext。\n     * 当ServletContext执行setAttribute方法时，此方法可以知道，并执行。\n     */\n    public default void attributeAdded(ServletContextAttributeEvent scae) {\n    }\n\n    /**\n     * 域中删除了属性触发此方法\n     */\n    public default void attributeRemoved(ServletContextAttributeEvent scae) {\n    }\n\n    /**\n     * 域中属性发生改变触发此方法\n     */\n    public default void attributeReplaced(ServletContextAttributeEvent scae) {\n    }\n}\n```\n\n#### 2）HttpSessionAttributeListener\n\n```java\n/**\n * 用于监听HttpSession域（会话域）中属性发生变化的监听器\n * @since v 2.3\n */\npublic interface HttpSessionAttributeListener extends EventListener {\n\n    /**\n     * 域中添加了属性触发此方法。\n     */\n    public default void attributeAdded(HttpSessionBindingEvent se) {\n    }\n\n    /**\n     * 域中删除了属性触发此方法\n     */\n    public default void attributeRemoved(HttpSessionBindingEvent se) {\n    }\n\n    /**\n     * 域中属性发生改变触发此方法\n     */\n    public default void attributeReplaced(HttpSessionBindingEvent se) {\n    }\n}\n```\n\n#### 3）ServletRequestAttributeListener\n\n```java\n/**\n * 用于监听ServletRequest域（请求域）中属性发生变化的监听器\n * @since Servlet 2.4\n */\npublic interface ServletRequestAttributeListener extends EventListener {\n    /**\n     * 域中添加了属性触发此方法。\n     */\n    public default void attributeAdded(ServletRequestAttributeEvent srae) {\n    }\n\n    /**\n     * 域中删除了属性触发此方法\n     */\n    public default void attributeRemoved(ServletRequestAttributeEvent srae) {\n    }\n\n    /**\n     * 域中属性发生改变触发此方法\n     */\n    public default void attributeReplaced(ServletRequestAttributeEvent srae) {\n    }\n}\n```\n\n### 3.1.3 和会话相关的两个感知型监听器\n\n此处要跟同学们明确一下，和会话域相关的两个感知型监听器是无需配置的，直接编写代码即可。\n\n#### 1）HttpSessionBinderListener\n\n```java\n/**\n * 用于感知对象和和会话域绑定的监听器\n * 当有数据加入会话域或从会话域中移除，此监听器的两个方法会执行。\n * 加入会话域即和会话域绑定\n * 从会话域移除即从会话域解绑\n */\npublic interface HttpSessionBindingListener extends EventListener {\n\n    /**\n     * 当数据加入会话域时，也就是绑定，此方法执行\n     */\n    public default void valueBound(HttpSessionBindingEvent event) {\n    }\n\n    /**\n     * 当从会话域移除时，也就是解绑，此方法执行\n     */\n    public default void valueUnbound(HttpSessionBindingEvent event) {\n    }\n}\n\n```\n\n#### 2）HttpSessionActivationListener\n\n```java\n/**\n * 用于感知会话域中对象钝化和活化的监听器\n */\npublic interface HttpSessionActivationListener extends EventListener {\n\n    /**\n     * 当会话域中的数据钝化时，此方法执行\n     */\n    public default void sessionWillPassivate(HttpSessionEvent se) {\n    }\n\n    /**\n     * 当会话域中的数据活化时（激活），此方法执行\n     */\n    public default void sessionDidActivate(HttpSessionEvent se) {\n    }\n}\n```\n\n## 3.2 监听器的使用\n\n在实际开发中，我们可以根据具体情况来从这8个监听器中选择使用。感知型监听器由于无需配置，只需要根据实际需求编写代码，所以此处我们就不再演示了。我们在剩余6个中分别选择一个监听对象创建销毁和对象域中属性发生变化的监听器演示一下。\n\n### 3.2.1 ServletContextListener的使用\n\n**第一步：创建工程**\n\n![listener_demo1](./EL&Filter&Listener-授课.assets/listener_demo1.png)\n\n**第二步：编写监听器**\n\n```java\n/**\n * 用于监听ServletContext对象创建和销毁的监听器\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletContextListenerDemo implements ServletContextListener {\n\n    /**\n     * 对象创建时，执行此方法\n     * @param sce\n     */\n    @Override\n    public void contextInitialized(ServletContextEvent sce) {\n        System.out.println("监听到了对象的创建");\n        //1.获取事件源对象\n        ServletContext servletContext = sce.getServletContext();\n        System.out.println(servletContext);\n    }\n\n    /**\n     * 对象销毁时，执行此方法\n     * @param sce\n     */\n    @Override\n    public void contextDestroyed(ServletContextEvent sce) {\n        System.out.println("监听到了对象的销毁");\n    }\n}\n```\n\n**第三步：在web.xml中配置监听器**\n\n```xml\n\x3c!--配置监听器--\x3e\n<listener>\n    <listener-class>com.itheima.web.listener.ServletContextListenerDemo</listener-class>\n</listener>\n```\n\n**第四步：测试结果**\n\n![listener_demo2](./EL&Filter&Listener-授课.assets/listener_demo2.png)\n\n### 3.2.2 ServletContextAttributeListener的使用\n\n**第一步：创建工程**\n\n沿用上一个案例的工程\n\n**第二步：编写监听器**\n\n```java\n/**\n * 监听域中属性发生变化的监听器\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletContextAttributeListenerDemo implements ServletContextAttributeListener {\n\n    /**\n     * 域中添加了数据\n     * @param scae\n     */\n    @Override\n    public void attributeAdded(ServletContextAttributeEvent scae) {\n        System.out.println("监听到域中加入了属性");\n        /**\n         * 由于除了我们往域中添加了数据外，应用在加载时还会自动往域中添加一些属性。\n         * 我们可以获取域中所有名称的枚举，从而看到域中都有哪些属性\n         */\n        \n        //1.获取事件源对象ServletContext\n        ServletContext servletContext = scae.getServletContext();\n        //2.获取域中所有名称的枚举\n        Enumeration<String> names = servletContext.getAttributeNames();\n        //3.遍历名称的枚举\n        while(names.hasMoreElements()){\n            //4.获取每个名称\n            String name = names.nextElement();\n            //5.获取值\n            Object value = servletContext.getAttribute(name);\n            //6.输出名称和值\n            System.out.println("name is "+name+" and value is "+value);\n        }\n    }\n\n    /**\n     * 域中移除了数据\n     * @param scae\n     */\n    @Override\n    public void attributeRemoved(ServletContextAttributeEvent scae) {\n        System.out.println("监听到域中移除了属性");\n    }\n\n    /**\n     * 域中属性发生了替换\n     * @param scae\n     */\n    @Override\n    public void attributeReplaced(ServletContextAttributeEvent scae) {\n        System.out.println("监听到域中属性发生了替换");\n    }\n}\n```\n\n同时，我们还需要借助第一个`ServletContextListenerDemo`监听器，往域中存入数据，替换域中的数据以及从域中移除数据，代码如下：\n\n```java\n/**\n * 用于监听ServletContext对象创建和销毁的监听器\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ServletContextListenerDemo implements ServletContextListener {\n\n    /**\n     * 对象创建时，执行此方法\n     * @param sce\n     */\n    @Override\n    public void contextInitialized(ServletContextEvent sce) {\n        System.out.println("监听到了对象的创建");\n        //1.获取事件源对象\n        ServletContext servletContext = sce.getServletContext();\n        //2.往域中加入属性\n        servletContext.setAttribute("servletContext","test");\n    }\n\n    /**\n     * 对象销毁时，执行此方法\n     * @param sce\n     */\n    @Override\n    public void contextDestroyed(ServletContextEvent sce) {\n        //1.取出事件源对象\n        ServletContext servletContext = sce.getServletContext();\n        //2.往域中加入属性，但是名称仍采用servletContext，此时就是替换\n        servletContext.setAttribute("servletContext","demo");\n        System.out.println("监听到了对象的销毁");\n        //3.移除属性\n        servletContext.removeAttribute("servletContext");\n    }\n}\n```\n\n**第三步：在web.xml中配置监听器**\n\n```xml\n\x3c!--配置监听器--\x3e\n<listener>\n    <listener-class>com.itheima.web.listener.ServletContextListenerDemo</listener-class>\n</listener>\n\n\x3c!--配置监听器--\x3e\n<listener>\n    <listener-class>com.itheima.web.listener.ServletContextAttributeListenerDemo</listener-class>\n</listener>\n```\n\n**第四步：测试结果**\n\n![attributelistener_demo](./EL&Filter&Listener-授课.assets/attributelistener_demo.png)\n\n# 4 综合案例-学生管理系统改造\n\n## 4.1 需求说明\n\n### 4.1.1 解决乱码问题\n\n我们的学生管理系统中，肯定会有请求和响应的中文乱码问题。而乱码问题在学习Servlet的课程中已经讲解了如何解决了。只是在实际开发中，当有很多的Servlet时，肯定不能在每个Servlet中都编写一遍解决乱码的代码。因此，就可以利用我们今天学习的过滤器来实现统一解决请求和响应乱码的问题。\n\n### 4.1.2 检查登录\n\n在学生管理系统中，它包含了学生信息的录入和学生列表的查询，用户（员工）信息的录入以及查询。当然，我们实际的功能可能远远不止这些。但是就已有功能来说，也不是谁都可以通过地址栏直接输入访问的，它应该有权限的控制，只是我们课程在此处没法深入展开讲解权限，但最起码的登录，身份的认证还是必要的。\n\n由此，就引出来一个问题，是在每次访问Servlet时，在Servlet的代码中加入是否认证过身份的判断吗？显然，是不合理的。那么，既然不是在每个Servlet中编写，就应该是统一管理和维护。此时，我们的过滤器就又可以出场了。\n\n### 4.1.3 页面的java代码块和jsp表达式改造\n\n我们今天除了学习了过滤器，还学习了EL表达式和JSTL标签库，它们的出现就是避免我们的JSP页面中有过多的java代码或者jsp表达式。我们要运用今天所学知识改造页面。\n\n## 4.2 案例实现\n\n### 4.2.1 乱码问题过滤器\n\n创建EncodingFilter类，解决乱码\n\n```java\npackage com.itheima.filter;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.annotation.WebFilter;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/*\n    解决全局乱码问题\n */\n@WebFilter("/*")\npublic class EncodingFilter implements Filter{\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) {\n        try{\n            //1.将请求和响应对象转换为和HTTP协议相关\n            HttpServletRequest request = (HttpServletRequest) servletRequest;\n            HttpServletResponse response = (HttpServletResponse) servletResponse;\n\n            //2.设置编码格式\n            request.setCharacterEncoding("UTF-8");\n            response.setContentType("text/html;charset=UTF-8");\n\n            //3.放行\n            filterChain.doFilter(request,response);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n}\n\n```\n\n\n\n### 4.2.2 检查登录过滤器\n\n检查登录，创建LoginFilter 类\n\n```java\npackage com.itheima.filter;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.annotation.WebFilter;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/*\n    检查登录\n */\n@WebFilter(value = {"/addStudent.jsp","/listStudentServlet"})\npublic class LoginFilter implements Filter{\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) {\n        try{\n            //1.将请求和响应对象转换为和HTTP协议相关\n            HttpServletRequest request = (HttpServletRequest) servletRequest;\n            HttpServletResponse response = (HttpServletResponse) servletResponse;\n\n            //2.获取会话域对象中数据\n            Object username = request.getSession().getAttribute("username");\n\n            //3.判断用户名\n            if(username == null || "".equals(username)) {\n                //重定向到登录页面\n                response.sendRedirect(request.getContextPath() + "/login.jsp");\n                return;\n            }\n\n            //4.放行\n            filterChain.doFilter(request,response);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n\n\n### 4.2.3 jsp页面的改造 \n\n​\t1，修改`addStudent.jsp`的虚拟访问路径\n\n```jsp\n<form action="${pageContext.request.contextPath}/addStudentServlet" method="get" autocomplete="off">\n    学生姓名：<input type="text" name="username"> <br>\n    学生年龄：<input type="number" name="age"> <br>\n    学生成绩：<input type="number" name="score"> <br>\n    <button type="submit">保存</button>\n</form>\n```\n\n2，修改`index.jsp`\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>\n<html>\n<head>\n    <title>学生管理系统首页</title>\n</head>\n<body>\n    <%--\n        获取会话域中的数据\n        如果获取到了则显示添加和查看功能的超链接\n        如果没获取到则显示登录功能的超链接\n    --%>\n    <c:if test="${sessionScope.username eq null}">\n        <a href="${pageContext.request.contextPath}/login.jsp">请登录</a>\n    </c:if>\n\n    <c:if test="${sessionScope.username ne null}">\n        <a href="${pageContext.request.contextPath}/addStudent.jsp">添加学生</a>\n        <a href="${pageContext.request.contextPath}/listStudentServlet">查看学生</a>\n    </c:if>\n\n</body>\n</html>\n\n```\n\n3，修改`listStudent.jsp`\n\n```jsp\n<%@ page import="com.itheima.bean.Student" %>\n<%@ page import="java.util.ArrayList" %>\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>\n<html>\n<head>\n    <title>查看学生</title>\n</head>\n<body>\n    <table width="600px" border="1px">\n        <tr>\n            <th>学生姓名</th>\n            <th>学生年龄</th>\n            <th>学生成绩</th>\n        </tr>\n        <c:forEach items="${students}" var="s">\n            <tr align="center">\n                <td>${s.username}</td>\n                <td>${s.age}</td>\n                <td>${s.score}</td>\n            </tr>\n        </c:forEach>\n    </table>\n</body>\n</html>\n\n```\n\n4，修改`login.jsp`\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>学生登录</title>\n</head>\n<body>\n    <form action="${pageContext.request.contextPath}/loginStudentServlet" method="get" autocomplete="off">\n        姓名：<input type="text" name="username"> <br>\n        密码：<input type="password" name="password"> <br>\n        <button type="submit">登录</button>\n    </form>\n</body>\n</html>\n\n```\n\n'},8871:function(n,e,t){var r={"./JAD反编译tricks.md":"a59b","./Java8foreach指南.md":"971c","./Java8教程推荐.md":"5536","./Java8新特性总结.md":"f335","./java8-common-new-features.md":"b0e9","./java新特性总结.md":"465f","./手把手教你定位常见Java性能问题.md":"c2aa"};function a(n){var e=i(n);return t(e)}function i(n){if(!t.o(r,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return r[n]}a.keys=function(){return Object.keys(r)},a.resolve=i,n.exports=a,a.id="8871"},8893:function(n,e,t){"use strict";t.r(e),e["default"]='# Request&Response-授课\n\n# 1 响应对象\n\n## 1.1 响应对象概述\n\n### 1.1.1 关于响应\n\n响应，它表示了服务器端收到请求，同时也已经处理完成，把处理的结果告知用户。简单来说，指的就是服务器把请求的处理结果告知客户端。在B/S架构中，响应就是把结果带回浏览器。\n\n响应对象，顾名思义就是用于在JavaWeb工程中实现上述功能的对象。\n\n### 1.1.2 常用响应对象\n\n响应对象也是是Servlet规范中定义的，它包括了协议无关的和协议相关的。\n\n协议无关的对象标准是：ServletResponse接口\n\n协议相关的对象标准是：HttpServletResponse接口\n\n类结构图如下：\n\n![响应类视图](./Request&Response-授课.assets/响应类视图.png)\n\n我们课程中涉及的响应对象都是和HTTP协议相关的。即使用的是HttpServletResponse接口的实现类。\n\n这里有些同学可能会产生疑问，我们在使用Servlet时，需要定义一个类，然后实现Servlet接口（或者继承它的实现类）。现在我们想要实现响应功能，要不要定义一个类，然后实现HttpServletResponse接口呢？\n\n<b>此问题的答案是否定的，我们无需这么做。</b>我们只需要在自己写的Servlet中直接使用即可，因为这个对象的实现类是由Tomcat提供的，无须我们自定义。同时它还会帮我们把对象创建出来并传入doGet和doPost方法中。\n\n## 1.2 常用方法介绍 \n\n在HttpServletResponse接口中提供了很多方法，接下来我们通过API文档，来了解一下这些方法。\n\n![响应方法详解](./Request&Response-授课.assets/响应方法详解.png)\n\n常用状态码：\n\n| 状态码 |                            说明                            |\n| :----: | :--------------------------------------------------------: |\n|  200   |                          执行成功                          |\n|  302   | 它和307一样，都是用于重定向的状态码。只是307目前已不再使用 |\n|  304   |                 请求资源未改变，使用缓存。                 |\n|  400   |            请求错误。最常见的就是请求参数有问题            |\n|  404   |                       请求资源未找到                       |\n|  405   |                      请求方式不被支持                      |\n|  500   |                     服务器运行内部错误                     |\n\n状态码首位含义：\n\n| 状态码 |    说明    |\n| :----: | :--------: |\n|  1xx   |    消息    |\n|  2xx   |    成功    |\n|  3xx   |   重定向   |\n|  4xx   | 客户端错误 |\n|  5xx   | 服务器错误 |\n\n## 1.3 响应对象的使用示例\n\n### 1.3.1 响应-字节流输出中文问题\n\n```java\n/**\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ResponseDemo1 extends HttpServlet {\n\n    /**\n     * 演示字节流输出的乱码问题\n     */\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        /**\n         * 问题：\n         * \t  String str = "字节流中文乱码问题";\n         * \t     使用字节流输出，会不会产生中文乱码？\n         * 答案：\n         * \t  会产生乱码\n         * 原因：\n         * \tString str = "字节流中文乱码问题"; 在保存时用的是IDEA创建文件使用的字符集UTF-8。\n         * \t到浏览器上显示，chrome浏览器和ie浏览器默认的字符集是GB2312(其实就是GBK)，存和取用的不是同一个码表，就会产生乱码。\n         *\n         * 引申：\n         *   如果产生了乱码，就是存和取用的不是同一个码表\n         * 解决办法：\n         *   把存和取的码表统一。\n         */\n        String str = "字节流输出中文的乱码问题";//UTF-8的字符集，此时浏览器显示也需要使用UTF-8的字符集。\n        //1.拿到字节流输出对象\n        ServletOutputStream sos = response.getOutputStream();\n        /**\n         * 解决办法：\n         * \t第一种解决办法：\n         *      修改浏览器的编码，使用右键——编码——改成UTF-8。(不推荐使用，我们的应用尽量不要求用户取做什么事情)\n         *      ie和火狐浏览器可以直接右键设置字符集。而chrome需要安装插件，很麻烦。\n         * \t第二种解决办法： (不建议使用，因为不好记)\n         *  \t向页面上输出一个meta标签，内容如下： <meta http-equiv="content-type" content="text/html;charset=UTF-8">\n         *      其实它就是指挥了浏览器，使用哪个编码进行显示。\n         *  第三种解决办法：\n         * \t\t设置响应消息头，告知浏览器响应正文的MIME类型和字符集\n         * \t\tresponse.setHeader("Content-Type","text/html;charset=UTF-8");\n         * \t第四种解决办法：我们推荐使用的办法\n         * \t    它的本质就是设置了一个响应消息头\n         *  \tresponse.setContentType("text/html;charset=UTF-8");\n         */\n        //第二种解决办法：sos.write("<meta http-equiv=\'content-type\' content=\'text/html;charset=UTF-8\'>".getBytes());\n        //第三种解决办法：response.setHeader("Content-Type","text/html;charset=UTF-8");\n        //第四种解决办法：\n        response.setContentType("text/html;charset=UTF-8");\n        //2.把str转换成字节数组之后输出到浏览器\n        sos.write(str.getBytes("UTF-8")); \n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n}\n```\n\n![ResponseDemo1](./Request&Response-授课.assets/ResponseDemo1.png)\n\n### 1.3.2 响应-字符流输出中文问题\n\n```java\n/**\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ResponseDemo2 extends HttpServlet {\n\n    /**\n     * 字符流输出中文乱码\n     * @param request\n     * @param response\n     * @throws ServletException\n     * @throws IOException\n     */\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String str = "字符流输出中文乱码";\n        //response.setCharacterEncoding("UTF-8");\n\n        //设置响应正文的MIME类型和字符集\n        response.setContentType("text/html;charset=UTF-8");\n        //1.获取字符输出流\n        PrintWriter out = response.getWriter();\n        //2.使用字符流输出中文\n        /**\n         * 问题：\n         * \tout.write(str); 直接输出，会不会产生乱码\n         * 答案：\n         * \t会产生乱码\n         * 原因：\n         * \t存用的什么码表：UTF-8\n         *  在浏览器取之前，字符流PrintWriter已经获取过一次了，PrintWriter它在取的时候出现了乱码。\n         * \t浏览器取默认用的是GBK。（本地系统字符集）\n         *\n         *  UTF-8(存)————>PrintWriter ISO-8859-1(取)\t\t\t\t\t乱\n         *  PrintWirter ISO-8859-1(存)————>浏览器 GBK(取)\t\t\t\t乱\n         *\n         * 解决办法：\n         * \t改变PrintWriter的字符集，PrintWriter是从response对象中获取的，其实设置response的字符集。\n         *  注意：设置response的字符集，需要在拿流之前。\n         *  response.setCharacterEncoding("UTF-8");\n         *\n         * response.setContentType("text/html;charset=UTF-8");\n         * 此方法，其实是做了两件事：\n         * \t\t1.设置响应对象的字符集（包括响应对象取出的字符输出流）\n         * \t\t2.告知浏览器响应正文的MIME类型和字符集\n         */\n\n        out.write(str);\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n}\n```\n\n![ResponseDemo2](./Request&Response-授课.assets/ResponseDemo2.png)\n\n### 1.3.3 响应-生成验证码\n\n```java\n/**\n * @author 黑马程序员\n * @Company http://www.itheima.com\n *\n */\npublic class ResponseDemo3 extends HttpServlet {\n\n    /**\n     * 输出图片\n     * @param request\n     * @param response\n     * @throws ServletException\n     * @throws IOException\n     */\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        int width = 200;\n        int height = 35;\n        /**\n         * 实现步骤:\n         * \t1.创建图像内存对象\n         *  2.拿到画笔\n         *  3.设置颜色，画矩形边框\n         *  4.设置颜色，填充矩形\n         *  5.设置颜色，画干扰线\n         *  6.设置颜色，画验证码\n         *  7.把内存图像输出到浏览器上\n         */\n        //创建内存图像\n        BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);//参数：宽度，高度 （指的都是像素），使用的格式（RGB）\n        Graphics g = image.getGraphics();//画笔就一根\n\n        //设置颜色\n        g.setColor(Color.BLUE);\n        //画边框\n        g.drawRect(0, 0, width, height);\n\n        //设置颜色\n        g.setColor(Color.GRAY);\n        //填充矩形\n        g.fillRect(1, 1, width-2, height-2);\n\n        //设置颜色\n        g.setColor(Color.WHITE);\n        //拿随机数对象\n        Random r = new Random();\n        //画干扰线 10条\n        for(int i=0;i<10;i++){\n            g.drawLine(r.nextInt(width), r.nextInt(height),r.nextInt(width), r.nextInt(height));\n        }\n\n        //设置颜色\n        g.setColor(Color.RED);\n        //改变字体大小\n        Font font = new Font("宋体", Font.BOLD,30);//参数：1字体名称。2.字体样式 3.字体大小\n        g.setFont(font);//设置字体\n        //画验证码\t4个\n        int x = 35;//第一个数的横坐标是35像素\n        for(int i=0;i<4;i++){\n            //r.nextInt(10)+""这种写法效率是十分低的\n            g.drawString(String.valueOf(r.nextInt(10)), x, 25);\n            x+=35;\n        }\n\n        //输出到浏览器上\n        //参数： 1.内存对象。2.输出的图片格式。3.使用的输出流\n        ImageIO.write(image, "jpg", response.getOutputStream());\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n![ResponseDemo3](./Request&Response-授课.assets/ResponseDemo3.png)\n\n### 1.3.4 设置响应消息头-控制缓存\n\n```java\n/**\n * 设置缓存时间\n * \t使用缓存的一般都是静态资源\n *  动态资源一般不能缓存。\n *  我们现在目前只掌握了Servlet，所以用Servlet做演示\n * @author 黑马程序员\n * @Company http://www.itheima.com\n *\n */\npublic class ResponseDemo4 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String str = "设置缓存时间";\n        /*\n         * 设置缓存时间，其实就是设置响应消息头：Expires 但是值是一个毫秒数。\n         * 使用的是\n         * \tresponse.setDateHeader();\n         *\n         * 缓存1小时，是在当前时间的毫秒数上加上1小时之后的毫秒值\n         */\n        response.setDateHeader("Expires",System.currentTimeMillis()+1*60*60*1000);\n        response.setContentType("text/html;charset=UTF-8");\n        response.getOutputStream().write(str.getBytes());\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n![ResponseDemo4_chrome](./Request&Response-授课.assets/ResponseDemo4_chrome.png)\n\n![ResponseDemo4_ie](./Request&Response-授课.assets/ResponseDemo4_ie.png)\n\n### 1.3.5 设置响应消息头定时刷新\n\n```java\n/**\n * 设置响应消息头：\n * 通过定时刷新演示添加消息头\n * @author 黑马程序员\n * @Company http://www.itheima.com\n *\n */\npublic class ResponseDemo5 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String str = "用户名和密码不匹配，2秒后转向登录页面...";\n        response.setContentType("text/html;charset=UTF-8");\n        PrintWriter out = response.getWriter();\n        out.write(str);\n        //定时刷新，其实就是设置一个响应消息头\n        response.setHeader("Refresh", "2;URL=/login.html");//Refresh设置的时间单位是秒，如果刷新到其他地址，需要在时间后面拼接上地址\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n![ResponseDemo5](./Request&Response-授课.assets/ResponseDemo5.png)\n\n### 1.3.6 请求重定向：注意地址栏发生改变。\n\n```java\n/**\n * 设置响应状态码，实现重定向\n * 重定向的特点：\n * \t 两次请求，地址栏改变，浏览器行为，xxxx\n * @author 黑马程序员\n * @Company http://www.itheima.com\n *\n */\npublic class ResponseDemo6 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        //1.设置响应状态码\n//\t\tresponse.setStatus(302);\n        //2.定向到哪里去: 其实就是设置响应消息头，Location\n//\t\tresponse.setHeader("Location", "ResponseDemo7");\n\n        //使用重定向方法\n        response.sendRedirect("ResponseDemo7");//此行做了什么事，请看上面\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n```java\n/**\n * 重定向的目的地\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class ResponseDemo7 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.getWriter().write("welcome to ResponseDemo7");\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n![ResponseDemo6](./Request&Response-授课.assets/ResponseDemo6.png)\n\n### 1.3.7 响应和消息头组合应用-文件下载\n\n首先，在工程的web目录下新建一个目录uploads，并且拷贝一张图片到目录中，如下图所示：\n\n![文件下载的图片](./Request&Response-授课.assets/文件下载的图片.png)\n\n文件下载的Servlet代码如下：\n\n```java\n/**\n * 文件下载\n * @author 黑马程序员\n * @Company http://www.itheima.com\n *\n */\npublic class ResponseDemo8 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        /*\n         * 文件下载的思路：\n         * \t\t1.获取文件路径\n         * \t\t2.把文件读到字节输入流中\n         * \t\t3.告知浏览器，以下载的方式打开（告知浏览器下载文件的MIME类型）\n         * \t\t4.使用响应对象的字节输出流输出到浏览器上\n         */\n        //1.获取文件路径（绝对路径）\n        ServletContext context = this.getServletContext();\n        String filePath = context.getRealPath("/uploads/6.jpg");//通过文件的虚拟路径，获取文件的绝对路径\n        //2.通过文件路径构建一个字节输入流\n        InputStream in  = new FileInputStream(filePath);\n        //3.设置响应消息头\n        response.setHeader("Content-Type", "application/octet-stream");//注意下载的时候，设置响应正文的MIME类型，用application/octet-stream\n        response.setHeader("Content-Disposition", "attachment;filename=1.jpg");//告知浏览器以下载的方式打开\n        //4.使用响应对象的字节输出流输出\n        OutputStream out = response.getOutputStream();\n        int len = 0;\n        byte[] by = new byte[1024];\n        while((len = in.read(by)) != -1){\n            out.write(by, 0, len);\n        }\n        in.close();\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n![ResponseDemo8](./Request&Response-授课.assets/ResponseDemo8.png)\n\n### 1.3.8 响应对象注意事项\n\n**第一： response得到的字符流和字节流互斥，只能选其一**\n\n**第二：response获取的流不用关闭，由服务器关闭即可**\n\n```java\n/**\n * 使用Response对象获取流时候的注意事项：\n * \t1.我们使用response获取的流，可以不用关闭。服务器会给我们关闭。\n * \t2.在response对象中，字节流和字符流互斥，输出的时候，只能选择一个\n * @author zhy\n *\n */\npublic class ResponseDemo9 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String str = "test";\n        response.getOutputStream().write(str.getBytes());\n        //response.getWriter().write(str);\n//\t\tresponse.getOutputStream().write("haha".getBytes());\n\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n![ResponseDemo9](./Request&Response-授课.assets/ResponseDemo9.png)\n\n# 2 请求对象\n\n## 2.1 请求对象概述\n\n### 2.1.1 关于请求\n\n请求，顾明思议，就是使用者希望从服务器端索取一些资源，向服务器发出询问。在B/S架构中，就是客户浏览器向服务器发出询问。在我们的JavaEE工程中，客户浏览器发出询问，要遵循HTTP协议所规定的。\n\n请求对象，就是在JavaEE工程中，用于发送请求的对象。我们常用的对象就是ServletRequest和HttpServletRequest，它们的区别就是是否和HTTP协议有关。\n\n### 2.1.2 常用请求对象\n\n![请求对象的类试图](./Request&Response-授课.assets/请求对象的类试图.png)\n\n## 2.2 常用方法介绍\n\n![Request方法详解](./Request&Response-授课.assets/Request方法详解.png)\n\n## 2.3 请求对象的使用示例\n\n### 2.3.1 请求对象常用方法1-获取各种路径\n\n```java\n/**\n * 请求对象的各种信息获取\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class RequestDemo1 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        //本机地址：服务器地址\n        String localAddr = request.getLocalAddr();\n        //本机名称：服务器名称\n        String localName = request.getLocalName();\n        //本机端口：服务器端口\n        int localPort = request.getLocalPort();\n        //来访者ip\n        String remoteAddr = request.getRemoteAddr();\n        //来访者主机\n        String remoteHost = request.getRemoteHost();\n        //来访者端口\n        int remotePort = request.getRemotePort();\n        //统一资源标识符\n        String URI = request.getRequestURI();\n        //统一资源定位符\n        String URL = request.getRequestURL().toString();\n        //获取查询字符串\n        String queryString = request.getQueryString();\n        //获取Servlet映射路径\n        String servletPath = request.getServletPath();\n\n        //输出内容\n\t\tSystem.out.println("getLocalAddr() is :"+localAddr);\n\t\tSystem.out.println("getLocalName() is :"+localName);\n\t\tSystem.out.println("getLocalPort() is :"+localPort);\n\t\tSystem.out.println("getRemoteAddr() is :"+remoteAddr);\n\t\tSystem.out.println("getRemoteHost() is :"+remoteHost);\n\t\tSystem.out.println("getRemotePort() is :"+remotePort);\n\t\tSystem.out.println("getRequestURI() is :"+URI);\n\t\tSystem.out.println("getRequestURL() is :"+URL);\n        System.out.println("getQueryString() is :"+queryString);\n        System.out.println("getServletPath() is :"+servletPath);\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n}\n```\n\n### 2.3.2 请求对象常用方法2-获取请求头信息\n\n```java\n/**\n * 获取请求消息头\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class RequestDemo2 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        //1.根据名称获取头的值\t一个消息头一个值\n        String value = request.getHeader("Accept-Encoding");\n        System.out.println("getHeader():"+value);\n\n        //2.根据名称获取头的值\t一个头多个值\n        Enumeration<String> values = request.getHeaders("Accept");\n        while(values.hasMoreElements()){\n            System.out.println("getHeaders():"+values.nextElement());\n        }\n\n        //3.获取请求消息头的名称的枚举\n        Enumeration<String> names = request.getHeaderNames();\n        while(names.hasMoreElements()){\n            String name = names.nextElement();\n            String value1 = request.getHeader(name);\n            System.out.println(name+":"+value1);\n        }\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n### 2.3.3 请求对象常用方法3-获取请求参数（非常重要）\n\n在本小节，我们会讲解HttpServletRequest对象获取请求参数的常用方法，以及把获取到的请求参数封装到实体类中的方式。首先，我们先来创建一个Servlet对象\n\n```java\n/**\n * 封装请求正文到javabean（数据模型）\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class RequestDemo3 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        /*\n         * 把下面\n         *\t\t1）获取请求参数\n         *\t\t2）封装请求参数到实体类中\n         * 中定义的test1到test8逐个添加到此处来运行即可。\n         */\n    }\n \n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n}\n```\n\n接下来，我们在来准备一个表单页面：\n\n```html\n<html>\n<head>\n\t<title>login to request demo 3</title>\n</head>\n<body>\n<form action="/day10_1122_requestresponse/RequestDemo3" method="post">\n\t用户名：<input type="text" name="username" /><br/>\n\t密码：<input type="password" name="password" /><br/>\n\t性别：<input type="radio" name="gender" value="1" checked>男\n\t<input type="radio" name="gender" value="0">女\n\t<br/>\n\t<input type="submit" value="注册" />\n</form>\n</body>\n</html>\n```\n\n现在，我们开始分析HttpServletRequest对象用于获取请求参数的方法：\n\n#### 1）获取请求参数\n\n**getParameter()方法的示例代码**\n\n```java\n/**\n * 获取请求正文，一个名称对应一个值。\t\t\t\t\t\t\t\t没有使用确认密码\n * @param request\n * @param response\n * @throws ServletException\n * @throws IOException\n */\nprivate void test1(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n    //1.获取请求正文\n    String username = request.getParameter("username");\n    String password = request.getParameter("password");\n    String gender = request.getParameter("gender");\n    System.out.println(username+","+password+","+gender);\n}\n```\n\n**getParameterValues()方法的示例代码**\n\n```java\n/**\n * 获取请求正文，一个名称可能对应多个值\t\t\t\t\t\t\t\t\t使用了确认密码\n * @param request\n * @param response\n * @throws ServletException\n * @throws IOException\n*/\nprivate void test2(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n    //1.获取请求正文\n    String username = request.getParameter("username");\n    String[] password = request.getParameterValues("password");//当表单中有多个名称是一样时，得到是一个字符串数组\n    String gender = request.getParameter("gender");\n    System.out.println(username+","+Arrays.toString(password)+","+gender);\n}\n```\n\n```html\n<html>\n<head>\n\t<title>login to request demo 4</title>\n</head>\n<body>\n<form action="/day10_1122_requestresponse/RequestDemo4" method="post" enctype="multipart/form-data">\n\t用户名：<input type="text" name="username" /><br/>\n\t密码：<input type="password" name="password" /><br/>\n\t确认密码：<input type="password" name="password" /><br/>\n\t性别：<input type="radio" name="gender" value="1" checked>男\n\t<input type="radio" name="gender" value="0">女\n\t<br/>\n\t<input type="submit" value="注册" />\n</form>\n</body>\n</html>\n```\n\n**getParameterNames()方法的示例代码**\n\n```java\n/**\n * 获取请求正文，一个名称一个值。但是先要获取正文名称的枚举（key的枚举）\t\t\t\t没有使用确认密码\n * @param request\n * @param response\n * @throws ServletException\n * @throws IOException\n*/\nprivate void test3(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n    //1.获取请求正文名称的枚举\n    Enumeration<String> names = request.getParameterNames();\n    //2.遍历正文名称的枚举\n    while(names.hasMoreElements()){\n        String name = names.nextElement();\n        String value = request.getParameter(name);\n        System.out.println(name+":"+value);\n    }\n}\n```\n\n**总结：**\n\n​\t以上三个方法可以获取表单提交过来的请求参数。\n\n​\t参数的名称是一个字符串，参数的值可能是一个字符串，也可能是一个字符串数组。\n\n#### 2）封装请求参数到实体类中\n\n我们通过上面的方法可以获取到请求参数，但是如果参数过多，在进行传递时，方法的形参定义将会变得非常难看。此时我们应该用一个对象来描述这些参数，它就是实体类。这种类的定义，从基础阶段我们就开始使用了。在基础阶段，我们做过一个学生管理系统，用到了一个Student的类，它就是用于描述一个学生的实体类。\n\n我们现在要做的就是把表单中提交过来的数据填充到实体类中。\n\n**第一种：最简单直接的封装方式**\n\n```java\n/**\n * 封装请求正文到User对象中\t\t\t\t\t\t\t\t\t没有使用确认密码\n * @param request\n * @param response\n * @throws ServletException\n * @throws IOException\n */\nprivate void test4(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n    //1.获取请求正文\n    String username = request.getParameter("username");\n    String password = request.getParameter("password");\n    String gender = request.getParameter("gender");\n    //2.创建一个User对象\n    User user = new User();\n    System.out.println("封装前："+user.toString());\n    //3.把请求正文封装到user对象中\n    user.setUsername(username);\n    user.setPassword(password);\n    user.setGender(gender);\n    System.out.println("封装后："+user.toString());\n}\n```\n\n**第二种：使用反射方式封装**\n\n此种封装的使用要求是，表单`<input>`标签的name属性取值，必须和实体类中定义的属性名称一致。\n\n```java\n/**\n * 封装请求正文到javabean中\t\t\t\t\t\t\t\t\t\t没有使用确认密码\n * 使用反射+内省实现数据模型的封装\n * 内省：是sun公司推出的一套简化反射操作的规范。把javabean中的元素都封装成一个属性描述器。\n * \t        属性描述器中会有字段信息，get和set方法（取值或存值）\n * @param request\n * @param response\n * @throws ServletException\n * @throws IOException\n*/\nprivate void test5(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n    //1.获取请求正文名称的枚举\n    Enumeration<String> names = request.getParameterNames();\n    User user = new User();\n    System.out.println("封装前："+user.toString());\n    //2.遍历正文名称的枚举\n    while(names.hasMoreElements()){\n        String name = names.nextElement();\n        String value = request.getParameter(name);\n        try{\n            //1.拿到User对象中的属性描述器。是谁的属性描述器：是由构造函数的第一个参数决定的。第二个参数是指定javabean的字节码\n            PropertyDescriptor pd = new PropertyDescriptor(name, User.class);//参数指的就是拿哪个类的哪个属性的描述器\n            //2.设置javabean属性的值\n            Method method = pd.getWriteMethod();\n            //3.执行方法\n            method.invoke(user, value);//第一个参数是指的给哪个对象，第二个参数指的是赋什么值\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n    System.out.println("封装后："+user.toString());\n} \n```\n\n**第三种：使用反射封装，同时请求参数的值是一个数组**\n\n此种方式其实就是针对请求参数中包含name属性相同的参数，例如：密码和确认密码，还有爱好。\n\n```java\n/**\n * 获取请求正文的关系映射Map<String,String[]>\t\t\t\t使用确认密码\n * @param request\n * @param response\n * @throws ServletException\n * @throws IOException\n */\nprivate void test6(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n    //1.获取请求正文的映射关系\n    Map<String,String[]> map = request.getParameterMap();\n    //2.遍历集合\n    for(Map.Entry<String,String[]> me : map.entrySet()){\n        String name = me.getKey();\n        String[] value = me.getValue();\n        System.out.println(name+":"+Arrays.toString(value));\n    }\n} \n```\n\n当我们把请求参数获取出来之后，就要考虑如何针对数组的反射了，具体代码如下：\n\n```java\n /**\n * 封装请求正文到javabean。使用的是反射+内省\t\t\t\t\t\t使用了确认密码\n * @param request\n * @param response\n * @throws ServletException\n * @throws IOException\n */\nprivate void test7(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n    //1.获取请求正文的映射关系\n    Map<String,String[]> map = request.getParameterMap();\n    Users user = new Users();\n    System.out.println("封装前："+user.toString());\n    //2.遍历集合\n    for(Map.Entry<String,String[]> me : map.entrySet()){\n        String name = me.getKey();\n        String[] value = me.getValue();\n        try{\n            //1.拿到User对象中的属性描述器。是谁的属性描述器：是由构造函数的第一个参数决定的。第二个参数是指定javabean的字节码\n            PropertyDescriptor pd = new PropertyDescriptor(name, Users.class);//参数指的就是拿哪个类的哪个属性的描述器\n            //2.设置javabean属性的值\n            Method method = pd.getWriteMethod();\n            //3.执行方法\n            //判断参数到底是几个值\n            if(value.length > 1){//最少有2个元素\n                method.invoke(user, (Object)value);//第一个参数是指的给哪个对象，第二个参数指的是赋什么值\n            }else{\n                method.invoke(user, value);//第一个参数是指的给哪个对象，第二个参数指的是赋什么值\n            }\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n    System.out.println("封装后："+user.toString());\n}\n```\n\n当我们写完此种封装方式之后，同学们可以发现，我们绝大多数封装都可以使用这段代码来实现。并且，无论是谁来写这段通用的封装代码，其代码内容都是大同小异的。**那么，我们就可以得出一个很有趣的结论：一般遇到这种情况时，肯定有人帮我们写好了，我们只需要用就行了。**我们后面还会遇到类似这样的情况。\n\n此时，帮我们写好这段封装代码的是apache软件基金会，我们前面学习的tomcat也是它提供的。它里面有一个开源工具包集合commons，里面有很多开源工具类，今天我们就来讲解第一个：<font color=\'red\'><b>commons-beanutils</b></font>。\n\n**第四种：使用apache的commons-beanutils实现封装**\n\n实现代码：\n\n```java\n/**\n * 终极方法：使用beanutils实现请求正文封装到javabean中\t\t\t\t使用了确认密码\n * 要想使用beanutils，需要先导包\n * @param request\n * @param response\n * @throws ServletException\n * @throws IOException\n */\nprivate void test8(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n    Users user = new Users();\n    System.out.println("封装前："+user.toString());\n    try{\n        BeanUtils.populate(user, request.getParameterMap());//就这一句话\n    }catch(Exception e){\n        e.printStackTrace();\n    }\n    System.out.println("封装后："+user.toString());\n}\n```\n\n### 2.3.4 用流的形式读取请求信息\n\n我们除了使用2.3.3小节中获取请求参数之外，还可以使用下面代码中的 方式来获取：\n\n```java\n/**\n * 使用流的方式读取请求正文\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class RequestDemo4 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        //1.获取请求正文的字节输入流\n        ServletInputStream sis = request.getInputStream();\n        //2.读取流中的数据\n        int len = 0;\n        byte[] by = new byte[1024];\n        while((len = sis.read(by)) != -1){\n            System.out.println(new String(by,0,len));\n        }\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n### 2.3.5请求正文中中文编码问题\n\n关于请求中文乱码问题，我们需要分开讨论，第一是POST请求方式，第二是GET方式。\n\n#### 1）POST方式请求\n\n在POST方式请求中，我们的乱码问题可以用如下代码解决：\n\n```java\n/**\n * 请求正文的中文乱码问题\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class RequestDemo5 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        //1.获取请求正文\n\t\t/*POST方式：\n\t\t * 问题：\n\t\t * \t取的时候会不会有乱码\n\t\t * 答案：\n\t\t * \t获取请求正文，会有乱码问题。\n\t\t * \t是在获取的时候就已经乱码了。\n\t\t * 解决办法：\n\t\t * \t 是request对象的编码出问题了\n\t\t *   设置request对象的字符集\n\t\t *   request.setCharacterEncoding("GBK");它只能解决POST的请求方式，GET方式解决不了\n\t\t * 结论：\n\t\t * \t 请求正文的字符集和响应正文的字符集没有关系。各是各的\n\t\t */\n\t\trequest.setCharacterEncoding("UTF-8");\n\t\tString username = request.getParameter("username");\n        //输出到控制台\n\t\tSystem.out.println(username);\n        //输出到浏览器：注意响应的乱码问题已经解决了\n        response.setContentType("text/html;charset=UTF-8");\n        PrintWriter out = response.getWriter();\n        out.write(username);\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n}\n```\n\n#### 2）GET方式请求\n\nGET方式请求的正文是在地址栏中，在Tomcat8.5版本及以后，Tomcat服务器已经帮我们解决了，所以不会有乱码问题了。\n\n而如果我们使用的不是Tomcat服务器，或者Tomcat的版本是8.5以前，那么GET方式仍然会有乱码问题，解决方式如下：（以下代码了解即可，因为我们现在使用的是Tomcat9.0.27版本）\n\n```java\n/**\n * 在Servlet的doGet方法中添加如下代码\n */\npublic void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n   \n\n        /*\n         * GET方式：正文在地址栏\n         * username=%D5%C5%C8%FD\n         * %D5%C5%C8%FD是已经被编过一次码了\n         *\n         * 解决办法：\n         * \t 使用正确的码表对已经编过码的数据进行解码。\n         * \t\t就是把取出的内容转成一个字节数组，但是要使用正确的码表。（ISO-8859-1）\n         * \t 再使用正确的码表进行编码\n         * \t\t把字节数组再转成一个字符串，需要使用正确的码表，是看浏览器当时用的是什么码表\n         */\n        String username = request.getParameter("username");\n        byte[] by = username.getBytes("ISO-8859-1");\n        username = new String(by,"GBK");\n\n        //输出到浏览器：注意响应的乱码问题已经解决了\n        response.setContentType("text/html;charset=UTF-8");\n        PrintWriter out = response.getWriter();\n        out.write(username);\n}\n\npublic void doPost(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n    doGet(request, response);\n}\n```\n\n### 2.3.6 请求转发（与重定向的区别）\n\n在实际开发中，重定向和请求转发都是我们要用到的响应方式，那么他们有什么区别呢？我们通过下面的示例来看一下：\n\n```java\n/**\n * 重定向特点：\n * \t两次请求，浏览器行为，地址栏改变，请求域中的数据会丢失\n * 请求转发：\n * \t一次请求，服务器行为，地址栏不变，请求域中的数据不丢失\n *\n * 请求域的作用范围：\n * \t 当前请求（一次请求）,和当前请求的转发之中\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class RequestDemo6 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        //1.拿到请求调度对象\n        RequestDispatcher rd = request.getRequestDispatcher("/RequestDemo7");//如果是给浏览器看的，/可写可不写。如果是给服务器看的，一般情况下，/都是必须的。\n        //放入数据到请求域中\n        request.setAttribute("CityCode", "bj-010");\n        //2.实现真正的转发操作\n        rd.forward(request, response);//实现真正的转发操作\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n```java\n/**\n * 转发的目的地\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class RequestDemo7 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        //获取请求域中的数据\n        String value = (String)request.getAttribute("CityCode");\n        response.getWriter().write("welcome to request demo 7    "+value);\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n### 2.3.7 请求包含\n\n在实际开发中，我们可能需要把两个Servlet的内容合并到一起来响应浏览器，而同学们都知道HTTP协议的特点是一请求，一响应的方式。所以绝对不可能出现有两个Servlet同时响应方式。那么我们就需要用到请求包含，把两个Servlet的响应内容合并输出。我们看具体使用示例：\n\n```java\n/**\n * 请求包含\n *\n * 它是把两个Servlet的响应内容合并输出。\n * 注意：\n * \t这种包含是动态包含。\n *\n * 动态包含的特点：\n * \t\t各编译各的，只是最后合并输出。\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class RequestDemo8 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.getWriter().write("I am request demo8 ");\n        //1.拿到请求调度对象\n        RequestDispatcher rd = request.getRequestDispatcher("/RequestDemo9");\n        //2.实现包含的操作\n        rd.include(request, response);\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n}\n```\n\n```java\n/**\n * 被包含者\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class RequestDemo9 extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.getWriter().write("include request demo 9 ");\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n### 2.3.8 细节问题\n\n请求转发的注意事项：负责转发的Servlet，转发前后的响应正文丢失，由转发目的地来响应浏览器。\n\n请求包含的注意事项：被包含者的响应消息头丢失。因为它被包含起来了。\n\n# 3 案例中的使用\n\n## 3.1 案例的需求及环境\n\n### 3.1.1 案例需求介绍\n\n在昨天的课程中，我们实现了浏览器发送请求，由Servlet来接收。今天，我们继续对学生管理系统进行升级，通过Servlet来实现学生的新增，删除，修改，查询操作。\n\n新增：Create\n\n查询：Read\n\n修改：Update\n\n删除：Delete\n\n每个单词取第一个字母，组成了CRUD。所以，同学们今后看到CRUD操作，指的就是增删改查。\n\n今天案例的CRUD，我们只关注Servlet接收请求和处理响应，不用过多的去关注真正增删改查操作（因为，我们目前还是把学生信息写到文件中，等web5天课程结束，我们会讲解数据库，它是我们保存数据这类问题的终极解决方案，而保存文件只是个替代品，我们没必要在替代品处消耗太多精力）。\n\n'},"89e5":function(n,e,t){"use strict";t.r(e),e["default"]="\n\n> 本文授权转载自 ： https://ken.io/note/sso-design-implement 作者：ken.io\n>\n> 相关推荐阅读：**[系统的讲解 - SSO单点登录](https://www.imooc.com/article/286710)**\n\n## 一、前言\n\n### 1、SSO说明\n\nSSO英文全称Single Sign On，单点登录。SSO是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。https://baike.baidu.com/item/SSO/3451380\n\n例如访问在网易账号中心（https://reg.163.com/ ）登录之后\n访问以下站点都是登录状态\n\n- 网易直播 [https://v.163.com](https://v.163.com/)\n- 网易博客 [https://blog.163.com](https://blog.163.com/)\n- 网易花田 [https://love.163.com](https://love.163.com/)\n- 网易考拉 [https://www.kaola.com](https://www.kaola.com/)\n- 网易Lofter [http://www.lofter.com](http://www.lofter.com/)\n\n### 2、单点登录系统的好处\n\n1. **用户角度** :用户能够做到一次登录多次使用，无需记录多套用户名和密码，省心。\n2. **系统管理员角度** : 管理员只需维护好一个统一的账号中心就可以了，方便。\n3. **新系统开发角度:** 新系统开发时只需直接对接统一的账号中心即可，简化开发流程，省时。\n\n### 3、设计目标\n\n本篇文章也主要是为了探讨如何设计&实现一个SSO系统\n\n以下为需要实现的核心功能：\n\n- 单点登录\n- 单点登出\n- 支持跨域单点登录\n- 支持跨域单点登出\n\n## 二、SSO设计与实现\n\n### 1、核心应用与依赖\n\n![单点登录（SSO）设计](SSO单点登录看这一篇就够了.assets/sso-system.png-kblb.png)\n\n| 应用/模块/对象   | 说明                                |\n| ---------------- | ----------------------------------- |\n| 前台站点         | 需要登录的站点                      |\n| SSO站点-登录     | 提供登录的页面                      |\n| SSO站点-登出     | 提供注销登录的入口                  |\n| SSO服务-登录     | 提供登录服务                        |\n| SSO服务-登录状态 | 提供登录状态校验/登录信息查询的服务 |\n| SSO服务-登出     | 提供用户注销登录的服务              |\n| 数据库           | 存储用户账户信息                    |\n| 缓存             | 存储用户的登录信息，通常使用Redis   |\n\n### 2、用户登录状态的存储与校验\n\n常见的Web框架对于[Session](https://ken.io/note/session-principle-skill)的实现都是生成一个SessionId存储在浏览器Cookie中。然后将Session内容存储在服务器端内存中，这个 ken.io 在之前[Session工作原理](https://ken.io/note/session-principle-skill)中也提到过。整体也是借鉴这个思路。\n用户登录成功之后，生成AuthToken交给客户端保存。如果是浏览器，就保存在Cookie中。如果是手机App就保存在App本地缓存中。本篇主要探讨基于Web站点的SSO。\n用户在浏览需要登录的页面时，客户端将AuthToken提交给SSO服务校验登录状态/获取用户登录信息\n\n对于登录信息的存储，建议采用Redis，使用Redis集群来存储登录信息，既可以保证高可用，又可以线性扩充。同时也可以让SSO服务满足负载均衡/可伸缩的需求。\n\n| 对象      | 说明                                                         |\n| --------- | ------------------------------------------------------------ |\n| AuthToken | 直接使用UUID/GUID即可，如果有验证AuthToken合法性需求，可以将UserName+时间戳加密生成，服务端解密之后验证合法性 |\n| 登录信息  | 通常是将UserId，UserName缓存起来                             |\n\n### 3、用户登录/登录校验\n\n- 登录时序图\n\n![SSO系统设计-登录时序图](SSO单点登录看这一篇就够了.assets/sso-login-sequence.png-kbrb.png)\n\n按照上图，用户登录后AuthToken保存在Cookie中。 domain=test.com\n浏览器会将domain设置成 .test.com，\n这样访问所有*.test.com的web站点，都会将AuthToken携带到服务器端。\n然后通过SSO服务，完成对用户状态的校验/用户登录信息的获取\n\n- 登录信息获取/登录状态校验\n\n![SSO系统设计-登录信息获取/登录状态校验](SSO单点登录看这一篇就够了.assets/sso-logincheck-sequence.png-kbrb.png)\n\n### 4、用户登出\n\n用户登出时要做的事情很简单：\n\n1. 服务端清除缓存（Redis）中的登录状态\n2. 客户端清除存储的AuthToken\n\n- 登出时序图\n\n![SSO系统设计-用户登出](SSO单点登录看这一篇就够了.assets/sso-logout-sequence.png-kbrb.png)\n\n### 5、跨域登录、登出\n\n前面提到过，核心思路是客户端存储AuthToken，服务器端通过Redis存储登录信息。由于客户端是将AuthToken存储在Cookie中的。所以跨域要解决的问题，就是如何解决Cookie的跨域读写问题。\n\n> **Cookie是不能跨域的** ，比如我一个\n\n解决跨域的核心思路就是：\n\n- 登录完成之后通过回调的方式，将AuthToken传递给主域名之外的站点，该站点自行将AuthToken保存在当前域下的Cookie中。\n- 登出完成之后通过回调的方式，调用非主域名站点的登出页面，完成设置Cookie中的AuthToken过期的操作。\n- 跨域登录（主域名已登录）\n\n![SSO系统设计-跨域登录（主域名已登录）](SSO单点登录看这一篇就够了.assets/sso-crossdomain-login-loggedin-sequence.png-kbrb.png)\n\n- 跨域登录（主域名未登录）\n\n![SSO系统设计-跨域登录（主域名未登录）](SSO单点登录看这一篇就够了.assets/sso-crossdomain-login-unlogin-sequence.png-kbrb.png)\n\n- 跨域登出\n\n![SSO系统设计-跨域登出](SSO单点登录看这一篇就够了.assets/sso-crossdomain-logout-sequence.png-kbrb.png)\n\n## 三、备注\n\n- 关于方案\n\n这次设计方案更多是提供实现思路。如果涉及到APP用户登录等情况，在访问SSO服务时，增加对APP的签名验证就好了。当然，如果有无线网关，验证签名不是问题。\n\n- 关于时序图\n\n时序图中并没有包含所有场景，ken.io只列举了核心/主要场景，另外对于一些不影响理解思路的消息能省就省了。\n"},"8b11":function(n,e,t){"use strict";t.r(e),e["default"]='> 最近重看 Java 枚举，看到这篇觉得还不错的文章，于是简单翻译和完善了一些内容，分享给大家，希望你们也能有所收获。另外，不要忘了文末还有补充哦！\n>\n> ps: 这里发一篇枚举的文章，也是因为后面要发一篇非常实用的关于 SpringBoot 全局异常处理的比较好的实践，里面就用到了枚举。\n>\n> 这篇文章由 JavaGuide 翻译，公众号: JavaGuide,原文地址：https://www.baeldung.com/a-guide-to-java-enums 。\n>\n> 转载请注明上面这段文字。\n\n## 1.概览\n\n在本文中，我们将看到什么是 Java 枚举，它们解决了哪些问题以及如何在实践中使用  Java 枚举实现一些设计模式。\n\nenum关键字在 java5 中引入，表示一种特殊类型的类，其总是继承java.lang.Enum类，更多内容可以自行查看其[官方文档](https://docs.oracle.com/javase/6/docs/api/java/lang/Enum.html)。\n\n枚举在很多时候会和常量拿来对比，可能因为本身我们大量实际使用枚举的地方就是为了替代常量。那么这种方式有什么优势呢？\n\n**以这种方式定义的常量使代码更具可读性，允许进行编译时检查，预先记录可接受值的列表，并避免由于传入无效值而引起的意外行为。**\n\n下面示例定义一个简单的枚举类型 pizza 订单的状态，共有三种 ORDERED, READY, DELIVERED状态:\n\n```java\npackage shuang.kou.enumdemo.enumtest;\n\npublic enum PizzaStatus {\n    ORDERED,\n    READY, \n    DELIVERED; \n}\n```\n\n**简单来说，我们通过上面的代码避免了定义常量，我们将所有和 pizza 订单的状态的常量都统一放到了一个枚举类型里面。**\n\n```java\nSystem.out.println(PizzaStatus.ORDERED.name());//ORDERED\nSystem.out.println(PizzaStatus.ORDERED);//ORDERED\nSystem.out.println(PizzaStatus.ORDERED.name().getClass());//class java.lang.String\nSystem.out.println(PizzaStatus.ORDERED.getClass());//class shuang.kou.enumdemo.enumtest.PizzaStatus\n```\n\n## 2.自定义枚举方法\n\n现在我们对枚举是什么以及如何使用它们有了基本的了解，让我们通过在枚举上定义一些额外的API方法，将上一个示例提升到一个新的水平：\n\n```java\npublic class Pizza {\n    private PizzaStatus status;\n    public enum PizzaStatus {\n        ORDERED,\n        READY,\n        DELIVERED;\n    }\n \n    public boolean isDeliverable() {\n        return getStatus() == PizzaStatus.READY;\n    }\n     \n    // Methods that set and get the status variable.\n}\n```\n\n## 3.使用 == 比较枚举类型\n\n由于枚举类型确保JVM中仅存在一个常量实例，因此我们可以安全地使用 `==` 运算符比较两个变量，如上例所示；此外，`==` 运算符可提供编译时和运行时的安全性。\n\n首先，让我们看一下以下代码段中的运行时安全性，其中 `==` 运算符用于比较状态，并且如果两个值均为null 都不会引发 NullPointerException。相反，如果使用equals方法，将抛出 NullPointerException：\n\n```java\nPizza.PizzaStatus pizza = null;\nSystem.out.println(pizza.equals(Pizza.PizzaStatus.DELIVERED));//空指针异常\nSystem.out.println(pizza == Pizza.PizzaStatus.DELIVERED);//正常运行\n```\n\n对于编译时安全性，我们看另一个示例，两个不同枚举类型进行比较：\n\n```java\nif (Pizza.PizzaStatus.DELIVERED.equals(TestColor.GREEN)); // 编译正常\nif (Pizza.PizzaStatus.DELIVERED == TestColor.GREEN);      // 编译失败，类型不匹配\n```\n\n## 4.在 switch 语句中使用枚举类型\n\n```java\npublic int getDeliveryTimeInDays() {\n    switch (status) {\n        case ORDERED:\n            return 5;\n        case READY:\n            return 2;\n        case DELIVERED:\n            return 0;\n    }\n    return 0;\n}\n```\n\n## 5.枚举类型的属性,方法和构造函数\n\n> 文末有我(JavaGuide)的补充。\n\n你可以通过在枚举类型中定义属性,方法和构造函数让它变得更加强大。\n\n下面，让我们扩展上面的示例，实现从比萨的一个阶段到另一个阶段的过渡，并了解如何摆脱之前使用的if语句和switch语句：\n\n```java\npublic class Pizza {\n \n    private PizzaStatus status;\n    public enum PizzaStatus {\n        ORDERED (5){\n            @Override\n            public boolean isOrdered() {\n                return true;\n            }\n        },\n        READY (2){\n            @Override\n            public boolean isReady() {\n                return true;\n            }\n        },\n        DELIVERED (0){\n            @Override\n            public boolean isDelivered() {\n                return true;\n            }\n        };\n \n        private int timeToDelivery;\n \n        public boolean isOrdered() {return false;}\n \n        public boolean isReady() {return false;}\n \n        public boolean isDelivered(){return false;}\n \n        public int getTimeToDelivery() {\n            return timeToDelivery;\n        }\n \n        PizzaStatus (int timeToDelivery) {\n            this.timeToDelivery = timeToDelivery;\n        }\n    }\n \n    public boolean isDeliverable() {\n        return this.status.isReady();\n    }\n \n    public void printTimeToDeliver() {\n        System.out.println("Time to delivery is " + \n          this.getStatus().getTimeToDelivery());\n    }\n     \n    // Methods that set and get the status variable.\n}\n```\n\n下面这段代码展示它是如何 work 的：\n\n```java\n@Test\npublic void givenPizaOrder_whenReady_thenDeliverable() {\n    Pizza testPz = new Pizza();\n    testPz.setStatus(Pizza.PizzaStatus.READY);\n    assertTrue(testPz.isDeliverable());\n}\n```\n\n## 6.EnumSet and EnumMap\n\n### 6.1. EnumSet\n\n`EnumSet` 是一种专门为枚举类型所设计的 `Set` 类型。\n\n与`HashSet`相比，由于使用了内部位向量表示，因此它是特定 `Enum` 常量集的非常有效且紧凑的表示形式。\n\n它提供了类型安全的替代方法，以替代传统的基于int的“位标志”，使我们能够编写更易读和易于维护的简洁代码。\n\n`EnumSet` 是抽象类，其有两个实现：`RegularEnumSet` 、`JumboEnumSet`，选择哪一个取决于实例化时枚举中常量的数量。\n\n在很多场景中的枚举常量集合操作（如：取子集、增加、删除、`containsAll`和`removeAll`批操作）使用`EnumSet`非常合适；如果需要迭代所有可能的常量则使用`Enum.values()`。\n\n```java\npublic class Pizza {\n \n    private static EnumSet<PizzaStatus> undeliveredPizzaStatuses =\n      EnumSet.of(PizzaStatus.ORDERED, PizzaStatus.READY);\n \n    private PizzaStatus status;\n \n    public enum PizzaStatus {\n        ...\n    }\n \n    public boolean isDeliverable() {\n        return this.status.isReady();\n    }\n \n    public void printTimeToDeliver() {\n        System.out.println("Time to delivery is " + \n          this.getStatus().getTimeToDelivery() + " days");\n    }\n \n    public static List<Pizza> getAllUndeliveredPizzas(List<Pizza> input) {\n        return input.stream().filter(\n          (s) -> undeliveredPizzaStatuses.contains(s.getStatus()))\n            .collect(Collectors.toList());\n    }\n \n    public void deliver() { \n        if (isDeliverable()) { \n            PizzaDeliverySystemConfiguration.getInstance().getDeliveryStrategy()\n              .deliver(this); \n            this.setStatus(PizzaStatus.DELIVERED); \n        } \n    }\n     \n    // Methods that set and get the status variable.\n}\n```\n\n  下面的测试展示了 `EnumSet` 在某些场景下的强大功能：\n\n```java\n@Test\npublic void givenPizaOrders_whenRetrievingUnDeliveredPzs_thenCorrectlyRetrieved() {\n    List<Pizza> pzList = new ArrayList<>();\n    Pizza pz1 = new Pizza();\n    pz1.setStatus(Pizza.PizzaStatus.DELIVERED);\n \n    Pizza pz2 = new Pizza();\n    pz2.setStatus(Pizza.PizzaStatus.ORDERED);\n \n    Pizza pz3 = new Pizza();\n    pz3.setStatus(Pizza.PizzaStatus.ORDERED);\n \n    Pizza pz4 = new Pizza();\n    pz4.setStatus(Pizza.PizzaStatus.READY);\n \n    pzList.add(pz1);\n    pzList.add(pz2);\n    pzList.add(pz3);\n    pzList.add(pz4);\n \n    List<Pizza> undeliveredPzs = Pizza.getAllUndeliveredPizzas(pzList); \n    assertTrue(undeliveredPzs.size() == 3); \n}\n```\n\n### 6.2. EnumMap\n\n`EnumMap`是一个专门化的映射实现，用于将枚举常量用作键。与对应的 `HashMap` 相比，它是一个高效紧凑的实现，并且在内部表示为一个数组:\n\n```java\nEnumMap<Pizza.PizzaStatus, Pizza> map;\n```\n\n让我们快速看一个真实的示例，该示例演示如何在实践中使用它：\n\n```java\nIterator<Pizza> iterator = pizzaList.iterator();\nwhile (iterator.hasNext()) {\n    Pizza pz = iterator.next();\n    PizzaStatus status = pz.getStatus();\n    if (pzByStatus.containsKey(status)) {\n      pzByStatus.get(status).add(pz);\n    } else {\n      List<Pizza> newPzList = new ArrayList<>();\n      newPzList.add(pz);\n      pzByStatus.put(status, newPzList);\n    }\n}\n```\n\n 下面的测试展示了 `EnumMap` 在某些场景下的强大功能：\n\n```java\n@Test\npublic void givenPizaOrders_whenGroupByStatusCalled_thenCorrectlyGrouped() {\n    List<Pizza> pzList = new ArrayList<>();\n    Pizza pz1 = new Pizza();\n    pz1.setStatus(Pizza.PizzaStatus.DELIVERED);\n \n    Pizza pz2 = new Pizza();\n    pz2.setStatus(Pizza.PizzaStatus.ORDERED);\n \n    Pizza pz3 = new Pizza();\n    pz3.setStatus(Pizza.PizzaStatus.ORDERED);\n \n    Pizza pz4 = new Pizza();\n    pz4.setStatus(Pizza.PizzaStatus.READY);\n \n    pzList.add(pz1);\n    pzList.add(pz2);\n    pzList.add(pz3);\n    pzList.add(pz4);\n \n    EnumMap<Pizza.PizzaStatus,List<Pizza>> map = Pizza.groupPizzaByStatus(pzList);\n    assertTrue(map.get(Pizza.PizzaStatus.DELIVERED).size() == 1);\n    assertTrue(map.get(Pizza.PizzaStatus.ORDERED).size() == 2);\n    assertTrue(map.get(Pizza.PizzaStatus.READY).size() == 1);\n}\n```\n\n## 7. 通过枚举实现一些设计模式\n\n### 7.1 单例模式\n\n通常，使用类实现 Singleton 模式并非易事，枚举提供了一种实现单例的简便方法。\n\n《Effective Java 》和《Java与模式》都非常推荐这种方式，使用这种方式实现枚举可以有什么好处呢？\n\n《Effective Java》\n\n> 这种方法在功能上与公有域方法相近，但是它更加简洁，无偿提供了序列化机制，绝对防止多次实例化，即使是在面对复杂序列化或者反射攻击的时候。虽然这种方法还没有广泛采用，但是单元素的枚举类型已经成为实现 Singleton的最佳方法。 —-《Effective Java 中文版 第二版》\n\n《Java与模式》\n\n>  《Java与模式》中，作者这样写道，使用枚举来实现单实例控制会更加简洁，而且无偿地提供了序列化机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。\n\n下面的代码段显示了如何使用枚举实现单例模式：\n\n```java\npublic enum PizzaDeliverySystemConfiguration {\n    INSTANCE;\n    PizzaDeliverySystemConfiguration() {\n        // Initialization configuration which involves\n        // overriding defaults like delivery strategy\n    }\n \n    private PizzaDeliveryStrategy deliveryStrategy = PizzaDeliveryStrategy.NORMAL;\n \n    public static PizzaDeliverySystemConfiguration getInstance() {\n        return INSTANCE;\n    }\n \n    public PizzaDeliveryStrategy getDeliveryStrategy() {\n        return deliveryStrategy;\n    }\n}\n```\n\n如何使用呢？请看下面的代码：\n\n```java\nPizzaDeliveryStrategy deliveryStrategy = PizzaDeliverySystemConfiguration.getInstance().getDeliveryStrategy();\n```\n\n通过 `PizzaDeliverySystemConfiguration.getInstance()` 获取的就是单例的 `PizzaDeliverySystemConfiguration`\n\n### 7.2 策略模式\n\n通常，策略模式由不同类实现同一个接口来实现的。\n\n 这也就意味着添加新策略意味着添加新的实现类。使用枚举，可以轻松完成此任务，添加新的实现意味着只定义具有某个实现的另一个实例。\n\n下面的代码段显示了如何使用枚举实现策略模式：\n\n```java\npublic enum PizzaDeliveryStrategy {\n    EXPRESS {\n        @Override\n        public void deliver(Pizza pz) {\n            System.out.println("Pizza will be delivered in express mode");\n        }\n    },\n    NORMAL {\n        @Override\n        public void deliver(Pizza pz) {\n            System.out.println("Pizza will be delivered in normal mode");\n        }\n    };\n \n    public abstract void deliver(Pizza pz);\n}\n```\n\n给 `Pizza `增加下面的方法：\n\n```java\npublic void deliver() {\n    if (isDeliverable()) {\n        PizzaDeliverySystemConfiguration.getInstance().getDeliveryStrategy()\n          .deliver(this);\n        this.setStatus(PizzaStatus.DELIVERED);\n    }\n}\n```\n\n如何使用呢？请看下面的代码：\n\n```java\n@Test\npublic void givenPizaOrder_whenDelivered_thenPizzaGetsDeliveredAndStatusChanges() {\n    Pizza pz = new Pizza();\n    pz.setStatus(Pizza.PizzaStatus.READY);\n    pz.deliver();\n    assertTrue(pz.getStatus() == Pizza.PizzaStatus.DELIVERED);\n}\n```\n\n## 8. Java 8 与枚举\n\nPizza 类可以用Java 8重写，您可以看到方法 lambda 和Stream API如何使 `getAllUndeliveredPizzas()`和`groupPizzaByStatus()`方法变得如此简洁：\n\n`getAllUndeliveredPizzas()`:\n\n```java\npublic static List<Pizza> getAllUndeliveredPizzas(List<Pizza> input) {\n    return input.stream().filter(\n      (s) -> !deliveredPizzaStatuses.contains(s.getStatus()))\n        .collect(Collectors.toList());\n}\n```\n\n`groupPizzaByStatus()` :\n\n```java\npublic static EnumMap<PizzaStatus, List<Pizza>> \n  groupPizzaByStatus(List<Pizza> pzList) {\n    EnumMap<PizzaStatus, List<Pizza>> map = pzList.stream().collect(\n      Collectors.groupingBy(Pizza::getStatus,\n      () -> new EnumMap<>(PizzaStatus.class), Collectors.toList()));\n    return map;\n}\n```\n\n## 9. Enum 类型的 JSON 表现形式\n\n使用Jackson库，可以将枚举类型的JSON表示为POJO。下面的代码段显示了可以用于同一目的的Jackson批注：\n\n```java\n@JsonFormat(shape = JsonFormat.Shape.OBJECT)\npublic enum PizzaStatus {\n    ORDERED (5){\n        @Override\n        public boolean isOrdered() {\n            return true;\n        }\n    },\n    READY (2){\n        @Override\n        public boolean isReady() {\n            return true;\n        }\n    },\n    DELIVERED (0){\n        @Override\n        public boolean isDelivered() {\n            return true;\n        }\n    };\n \n    private int timeToDelivery;\n \n    public boolean isOrdered() {return false;}\n \n    public boolean isReady() {return false;}\n \n    public boolean isDelivered(){return false;}\n \n    @JsonProperty("timeToDelivery")\n    public int getTimeToDelivery() {\n        return timeToDelivery;\n    }\n \n    private PizzaStatus (int timeToDelivery) {\n        this.timeToDelivery = timeToDelivery;\n    }\n}\n```\n\n我们可以按如下方式使用 `Pizza` 和 `PizzaStatus`：\n\n```java\nPizza pz = new Pizza();\npz.setStatus(Pizza.PizzaStatus.READY);\nSystem.out.println(Pizza.getJsonString(pz));\n```\n\n生成 Pizza 状态以以下JSON展示：\n\n```json\n{\n  "status" : {\n    "timeToDelivery" : 2,\n    "ready" : true,\n    "ordered" : false,\n    "delivered" : false\n  },\n  "deliverable" : true\n}\n```\n\n有关枚举类型的JSON序列化/反序列化（包括自定义）的更多信息，请参阅[Jackson-将枚举序列化为JSON对象。](https://www.baeldung.com/jackson-serialize-enums)\n\n## 10.总结\n\n本文我们讨论了Java枚举类型，从基础知识到高级应用以及实际应用场景，让我们感受到枚举的强大功能。\n\n## 11. 补充\n\n我们在上面讲到了，我们可以通过在枚举类型中定义属性,方法和构造函数让它变得更加强大。\n\n下面我通过一个实际的例子展示一下，当我们调用短信验证码的时候可能有几种不同的用途，我们在下面这样定义：\n\n```java\n\npublic enum PinType {\n\n    REGISTER(100000, "注册使用"),\n    FORGET_PASSWORD(100001, "忘记密码使用"),\n    UPDATE_PHONE_NUMBER(100002, "更新手机号码使用");\n\n    private final int code;\n    private final String message;\n\n    PinType(int code, String message) {\n        this.code = code;\n        this.message = message;\n    }\n\n    public int getCode() {\n        return code;\n    }\n\n    public String getMessage() {\n        return message;\n    }\n\n    @Override\n    public String toString() {\n        return "PinType{" +\n                "code=" + code +\n                ", message=\'" + message + \'\\\'\' +\n                \'}\';\n    }\n}\n```\n\n实际使用：\n\n ```java\nSystem.out.println(PinType.FORGET_PASSWORD.getCode());\nSystem.out.println(PinType.FORGET_PASSWORD.getMessage());\nSystem.out.println(PinType.FORGET_PASSWORD.toString());\n ```\n\nOutput:\n\n```java\n100001\n忘记密码使用\nPinType{code=100001, message=\'忘记密码使用\'}\n```\n\n这样的话，在实际使用起来就会非常灵活方便！\n'},"8b79":function(n,e,t){"use strict";t.r(e),e["default"]='## 何为反射？\n\n如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。\n\n反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。\n\n通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。\n\n## 反射的应用场景了解么？\n\n像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。\n\n但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。\n\n**这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。**\n\n比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 `Method` 来调用指定的方法。\n\n```java\npublic class DebugInvocationHandler implements InvocationHandler {\n    /**\n     * 代理类中的真实对象\n     */\n    private final Object target;\n\n    public DebugInvocationHandler(Object target) {\n        this.target = target;\n    }\n\n\n    public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {\n        System.out.println("before method " + method.getName());\n        Object result = method.invoke(target, args);\n        System.out.println("after method " + method.getName());\n        return result;\n    }\n}\n\n```\n\n另外，像 Java 中的一大利器 **注解** 的实现也用到了反射。\n\n为什么你使用 Spring 的时候 ，一个`@Component`注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 `@Value`注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？\n\n这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。\n\n## 谈谈反射机制的优缺点\n\n**优点** ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利\n\n**缺点** ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。相关阅读：[Java Reflection: Why is it so slow?](https://stackoverflow.com/questions/1392351/java-reflection-why-is-it-so-slow)\n\n## 反射实战\n\n### 获取 Class 对象的四种方式\n\n如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了四种方式获取 Class 对象:\n\n**1.知道具体类的情况下可以使用：**\n\n```java\nClass alunbarClass = TargetObject.class;\n```\n\n但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化\n\n**2.通过 `Class.forName()`传入类的路径获取：**\n\n```java\nClass alunbarClass1 = Class.forName("cn.javaguide.TargetObject");\n```\n\n**3.通过对象实例`instance.getClass()`获取：**\n\n```java\nTargetObject o = new TargetObject();\nClass alunbarClass2 = o.getClass();\n```\n\n**4.通过类加载器`xxxClassLoader.loadClass()`传入类路径获取:**\n\n```java\nClass clazz = ClassLoader.loadClass("cn.javaguide.TargetObject");\n```\n\n通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一些列步骤，静态块和静态对象不会得到执行\n\n### 反射的一些基本操作\n\n**简单用代码演示一下反射的一些操作!**\n\n1.创建一个我们要使用反射操作的类 `TargetObject`。\n\n```java\npackage cn.javaguide;\n\npublic class TargetObject {\n    private String value;\n\n    public TargetObject() {\n        value = "JavaGuide";\n    }\n\n    public void publicMethod(String s) {\n        System.out.println("I love " + s);\n    }\n\n    private void privateMethod() {\n        System.out.println("value is " + value);\n    }\n}\n```\n\n2.使用反射操作这个类的方法以及参数\n\n```java\npackage cn.javaguide;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\npublic class Main {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchFieldException {\n        /**\n         * 获取TargetObject类的Class对象并且创建TargetObject类实例\n         */\n        Class<?> tagetClass = Class.forName("cn.javaguide.TargetObject");\n        TargetObject targetObject = (TargetObject) tagetClass.newInstance();\n        /**\n         * 获取所有类中所有定义的方法\n         */\n        Method[] methods = tagetClass.getDeclaredMethods();\n        for (Method method : methods) {\n            System.out.println(method.getName());\n        }\n        /**\n         * 获取指定方法并调用\n         */\n        Method publicMethod = tagetClass.getDeclaredMethod("publicMethod",\n                String.class);\n\n        publicMethod.invoke(targetObject, "JavaGuide");\n        /**\n         * 获取指定参数并对参数进行修改\n         */\n        Field field = tagetClass.getDeclaredField("value");\n        //为了对类中的参数进行修改我们取消安全检查\n        field.setAccessible(true);\n        field.set(targetObject, "JavaGuide");\n        /**\n         * 调用 private 方法\n         */\n        Method privateMethod = tagetClass.getDeclaredMethod("privateMethod");\n        //为了调用private方法我们取消安全检查\n        privateMethod.setAccessible(true);\n        privateMethod.invoke(targetObject);\n    }\n}\n\n```\n\n输出内容：\n\n```\npublicMethod\nprivateMethod\nI love JavaGuide\nvalue is JavaGuide\n```\n\n**注意** : 有读者提到上面代码运行会抛出 `ClassNotFoundException` 异常,具体原因是你没有下面把这段代码的包名替换成自己创建的 `TargetObject` 所在的包 。\n\n```java\nClass<?> tagetClass = Class.forName("cn.javaguide.TargetObject");\n```\n'},"8c88":function(n,e,t){"use strict";t.r(e),e["default"]='## 1. 继承\n\n### 1.1 继承的实现（掌握）\n\n- 继承的概念\n\n  - 继承是面向对象三大特征之一，可以使得子类具有父类的属性和方法，还可以在子类中重新定义，以及追加属性和方法\n\n- 实现继承的格式\n\n  - 继承通过extends实现\n  - 格式：class 子类 extends 父类 { } \n    - 举例：class Dog extends Animal { }\n\n- 继承带来的好处\n\n  - 继承可以让类与类之间产生关系，子父类关系，产生子父类后，子类则可以使用父类中非私有的成员。\n\n- 示例代码\n\n  ```java\n  public class Fu {\n      public void show() {\n          System.out.println("show方法被调用");\n      }\n  }\n  public class Zi extends Fu {\n      public void method() {\n          System.out.println("method方法被调用");\n      }\n  }\n  public class Demo {\n      public static void main(String[] args) {\n          //创建对象，调用方法\n          Fu f = new Fu();\n          f.show();\n\n          Zi z = new Zi();\n          z.method();\n          z.show();\n      }\n  }\n  ```\n\n### 1.2 继承的好处和弊端（理解）\n\n- 继承好处\n  - 提高了代码的复用性(多个类相同的成员可以放到同一个类中)\n  - 提高了代码的维护性(如果方法的代码需要修改，修改一处即可)\n- 继承弊端\n  - 继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性\n- 继承的应用场景：\n  - 使用继承，需要考虑类与类之间是否存在is..a的关系，不能盲目使用继承\n    - is..a的关系：谁是谁的一种，例如：老师和学生是人的一种，那人就是父类，学生和老师就是子类\n\n### 1.3. Java中继承的特点（掌握）\n\n- Java中继承的特点\n\n  1. Java中类只支持单继承，不支持多继承\n     - 错误范例：class A extends B, C { }\n  2. Java中类支持多层继承\n\n- 多层继承示例代码：\n\n  ```java\n  public class Granddad {\n\n      public void drink() {\n          System.out.println("爷爷爱喝酒");\n      }\n\n  }\n\n  public class Father extends Granddad {\n\n      public void smoke() {\n          System.out.println("爸爸爱抽烟");\n      }\n\n  }\n\n  public class Mother {\n\n      public void dance() {\n          System.out.println("妈妈爱跳舞");\n      }\n\n  }\n  public class Son extends Father {\n  \t// 此时，Son类中就同时拥有drink方法以及smoke方法\n  }\n  ```\n\n## 2. 继承中的成员访问特点\n\n### 2.1 继承中变量的访问特点（掌握）\n\n在子类方法中访问一个变量，采用的是就近原则。\n\n1. 子类局部范围找\n2. 子类成员范围找\n3. 父类成员范围找\n4. 如果都没有就报错(不考虑父亲的父亲…)\n\n- 示例代码\n\n  ```java\n  class Fu {\n      int num = 10;\n  }\n  class Zi {\n      int num = 20;\n      public void show(){\n          int num = 30;\n          System.out.println(num);\n      }\n  }\n  public class Demo1 {\n      public static void main(String[] args) {\n          Zi z = new Zi();\n          z.show();\t// 输出show方法中的局部变量30\n      }\n  }\n  ```\n\n### 2.2 super（掌握）\n\n- this&super关键字：\n  - this：代表本类对象的引用\n  - super：代表父类存储空间的标识(可以理解为父类对象引用)\n- this和super的使用分别\n  - 成员变量：\n    - this.成员变量    -   访问本类成员变量\n    - super.成员变量 -   访问父类成员变量\n  - 成员方法：\n    - this.成员方法  - 访问本类成员方法\n    - super.成员方法 - 访问父类成员方法\n- 构造方法：\n  - this(…)  -  访问本类构造方法\n  - super(…)  -  访问父类构造方法\n\n### 2.3 继承中构造方法的访问特点（理解）\n\n**注意：子类中所有的构造方法默认都会访问父类中无参的构造方法**\n\n​\t子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化，原因在于，每一个子类构造方法的第一条语句默认都是：super()\n\n**问题：如果父类中没有无参构造方法，只有带参构造方法，该怎么办呢？**\n\n```\n1. 通过使用super关键字去显示的调用父类的带参构造方法\n2. 子类通过this去调用本类的其他构造方法,本类其他构造方法再通过super去手动调用父类的带参的构造方法\n\n注意: this(…)super(…) 必须放在构造方法的第一行有效语句，并且二者不能共存\n```\n\n### 2.4 继承中成员方法的访问特点（掌握）\n\n通过子类对象访问一个方法\n\n1. 子类成员范围找\n2. 父类成员范围找\n3. 如果都没有就报错(不考虑父亲的父亲…)\n\n### 2.5 super内存图（理解）\n\n- 对象在堆内存中，会单独存在一块super区域，用来存放父类的数据 \n\n  ![01_super内存图](./day12-继承.img/01_super内存图.png)\n\n### 2.6 方法重写（掌握）\n\n- 1、方法重写概念\n  - 子类出现了和父类中一模一样的方法声明（方法名一样，参数列表也必须一样）\n- 2、方法重写的应用场景\n  - 当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容\n- 3、Override注解\n  - 用来检测当前的方法，是否是重写的方法，起到【校验】的作用\n\n### 2.7 方法重写的注意事项（掌握）\n\n- 方法重写的注意事项\n\n1. 私有方法不能被重写(父类私有成员子类是不能继承的)\n2. 子类方法访问权限不能更低(public > 默认 > 私有)\n3. 静态方法不能被重写,如果子类也有相同的方法,并不是重写的父类的方法\n\n- 示例代码\n\n```java\npublic class Fu {\n    private void show() {\n        System.out.println("Fu中show()方法被调用");\n    }\n\n    void method() {\n        System.out.println("Fu中method()方法被调用");\n    }\n}\n\npublic class Zi extends Fu {\n\n    /* 编译【出错】，子类不能重写父类私有的方法*/\n    @Override\n    private void show() {\n        System.out.println("Zi中show()方法被调用");\n    }\n   \n    /* 编译【出错】，子类重写父类方法的时候，访问权限需要大于等于父类 */\n    @Override\n    private void method() {\n        System.out.println("Zi中method()方法被调用");\n    }\n\n    /* 编译【通过】，子类重写父类方法的时候，访问权限需要大于等于父类 */\n    @Override\n    public void method() {\n        System.out.println("Zi中method()方法被调用");\n    }\n}\n```\n\n### 2.8 权限修饰符 (理解) \n\n![02_权限修饰符](./day12-继承.img/02_权限修饰符.png)\n\n### 2.9 黑马信息管理系统使用继承改进 (掌握) \n\n+ 需求\n\n  把学生类和老师类共性的内容向上抽取,抽取到出一个 Person 父类,让学生类和老师类继承 Person 类\n\n+ 实现步骤\n\n  1. 抽取Person类\n\n  2. 优化StudentController类中，inputStudentInfo方法，将setXxx赋值方式，改进为构造方法初始化\n\n     注意：直接修改这种操作方式，不符合我们开发中的一个原则\n\n     ​\t开闭原则 ( 对扩展开放对修改关闭 ) : 尽量在不更改原有代码的前提下以完成需求 \n\n     解决：重新创建一个OtherStudentController类\n\n     编写新的inputStudentInfo方法\n\n  3. 根据StudentController类、OtherStudentController类，向上抽取出BaseStudentController类\n     再让StudentController类、OtherStudentController类，继承BaseStudentController类\n\n+ 代码实现\n\n  Person类及学生类和老师类\n\n  ```java\n  public class Person {\n      private String id;\n      private String name;\n      private String age;\n      private String birthday;\n\n      public Person() {\n      }\n\n      public Person(String id, String name, String age, String birthday) {\n          this.id = id;\n          this.name = name;\n          this.age = age;\n          this.birthday = birthday;\n      }\n\n      public String getId() {\n          return id;\n      }\n\n      public void setId(String id) {\n          this.id = id;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public String getAge() {\n          return age;\n      }\n\n      public void setAge(String age) {\n          this.age = age;\n      }\n\n      public String getBirthday() {\n          return birthday;\n      }\n\n      public void setBirthday(String birthday) {\n          this.birthday = birthday;\n      }\n  }\n  // Student类\n  public class Student extends Person {\n      public Student() {\n      }\n\n      public Student(String id, String name, String age, String birthday) {\n          super(id, name, age, birthday);\n      }\n  }\n  // Teacher类\n  public class Teacher extends Person {\n      public Teacher() {\n      }\n\n      public Teacher(String id, String name, String age, String birthday) {\n          super(id, name, age, birthday);\n      }\n  }\n  ```\n\n  BaseStudentController类\n\n  ```java\n  public abstract class BaseStudentController {\n      // 业务员对象\n      private StudentService studentService = new StudentService();\n\n      private Scanner sc = new Scanner(System.in);\n\n      // 开启学生管理系统, 并展示学生管理系统菜单\n      public void start() {\n          //Scanner sc = new Scanner(System.in);\n          studentLoop:\n          while (true) {\n              System.out.println("--------欢迎来到 <学生> 管理系统--------");\n              System.out.println("请输入您的选择: 1.添加学生  2.删除学生  3.修改学生  4.查看学生  5.退出");\n              String choice = sc.next();\n              switch (choice) {\n                  case "1":\n                      // System.out.println("添加");\n                      addStudent();\n                      break;\n                  case "2":\n                      // System.out.println("删除");\n                      deleteStudentById();\n                      break;\n                  case "3":\n                      // System.out.println("修改");\n                      updateStudent();\n                      break;\n                  case "4":\n                      // System.out.println("查询");\n                      findAllStudent();\n                      break;\n                  case "5":\n                      System.out.println("感谢您使用学生管理系统, 再见!");\n                      break studentLoop;\n                  default:\n                      System.out.println("您的输入有误, 请重新输入");\n                      break;\n              }\n          }\n      }\n\n      // 修改学生方法\n      public void updateStudent() {\n          String updateId = inputStudentId();\n          Student newStu = inputStudentInfo(updateId);\n          studentService.updateStudent(updateId, newStu);\n\n          System.out.println("修改成功!");\n      }\n\n      // 删除学生方法\n      public void deleteStudentById() {\n          String delId = inputStudentId();\n          // 3. 调用业务员中的deleteStudentById根据id, 删除学生\n          studentService.deleteStudentById(delId);\n          // 4. 提示删除成功\n          System.out.println("删除成功!");\n      }\n\n      // 查看学生方法\n      public void findAllStudent() {\n          // 1. 调用业务员中的获取方法, 得到学生的对象数组\n          Student[] stus = studentService.findAllStudent();\n          // 2. 判断数组的内存地址, 是否为null\n          if (stus == null) {\n              System.out.println("查无信息, 请添加后重试");\n              return;\n          }\n          // 3. 遍历数组, 获取学生信息并打印在控制台\n          System.out.println("学号\\t\\t姓名\\t年龄\\t生日");\n          for (int i = 0; i < stus.length; i++) {\n              Student stu = stus[i];\n              if (stu != null) {\n                  System.out.println(stu.getId() + "\\t" + stu.getName() + "\\t" + stu.getAge() + "\\t\\t" + stu.getBirthday());\n              }\n          }\n      }\n\n      // 添加学生方法\n      public void addStudent() {\n          // StudentService studentService = new StudentService();\n          // 1. 键盘接收学生信息\n          String id;\n          while (true) {\n              System.out.println("请输入学生id:");\n              id = sc.next();\n              boolean flag = studentService.isExists(id);\n              if (flag) {\n                  System.out.println("学号已被占用, 请重新输入");\n              } else {\n                  break;\n              }\n          }\n\n          Student stu = inputStudentInfo(id);\n\n          // 3. 将学生对象,传递给StudentService(业务员)中的addStudent方法\n          boolean result = studentService.addStudent(stu);\n          // 4. 根据返回的boolean类型结果, 在控制台打印成功\\失败\n          if (result) {\n              System.out.println("添加成功");\n          } else {\n              System.out.println("添加失败");\n          }\n      }\n\n      // 键盘录入学生id\n      public String inputStudentId() {\n          String id;\n          while (true) {\n              System.out.println("请输入学生id:");\n              id = sc.next();\n              boolean exists = studentService.isExists(id);\n              if (!exists) {\n                  System.out.println("您输入的id不存在, 请重新输入:");\n              } else {\n                  break;\n              }\n          }\n          return id;\n      }\n\n      // 键盘录入学生信息\n      // 开闭原则: 对扩展内容开放, 对修改内容关闭\n    public Student inputStudentInfo(String id){\n      return null;\n    }\n  }\n  ```\n\n  StudentController类\n\n  ```java\n  public class StudentController extends BaseStudentController {\n\n      private Scanner sc = new Scanner(System.in);\n\n      // 键盘录入学生信息\n      // 开闭原则: 对扩展内容开放, 对修改内容关闭\n      @Override\n      public Student inputStudentInfo(String id) {\n          System.out.println("请输入学生姓名:");\n          String name = sc.next();\n          System.out.println("请输入学生年龄:");\n          String age = sc.next();\n          System.out.println("请输入学生生日:");\n          String birthday = sc.next();\n          Student stu = new Student();\n          stu.setId(id);\n          stu.setName(name);\n          stu.setAge(age);\n          stu.setBirthday(birthday);\n          return stu;\n      }\n  }\n  ```\n\n  OtherStudentController类\n\n  ```java\n  public class OtherStudentController extends BaseStudentController {\n\n      private Scanner sc = new Scanner(System.in);\n\n      // 键盘录入学生信息\n      // 开闭原则: 对扩展内容开放, 对修改内容关闭\n      @Override\n      public Student inputStudentInfo(String id) {\n          System.out.println("请输入学生姓名:");\n          String name = sc.next();\n          System.out.println("请输入学生年龄:");\n          String age = sc.next();\n          System.out.println("请输入学生生日:");\n          String birthday = sc.next();\n          Student stu = new Student(id,name,age,birthday);\n          return stu;\n      }\n  }\n  ```\n\n## 3.抽象类\n\n### 3.1抽象类的概述（理解）\n\n​\t当我们在做子类共性功能抽取时，有些方法在父类中并没有具体的体现，这个时候就需要抽象类了！\n\n​\t在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类！\n\n### 3.2抽象类的特点（记忆）\n\n- 抽象类和抽象方法必须使用 abstract 关键字修饰\n\n  ```java\n  //抽象类的定义\n  public abstract class 类名 {}\n\n  //抽象方法的定义\n  public abstract void eat();\n  ```\n\n- 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类\n\n- 抽象类不能实例化\n\n- 抽象类可以有构造方法\n\n- 抽象类的子类\n\n  ​\t要么重写抽象类中的所有抽象方法\n\n  ​\t要么是抽象类\n\n### 3.3抽象类的案例（应用）\n\n- 案例需求\n\n  ​\t定义猫类(Cat)和狗类(Dog)\n\n  ​\t猫类成员方法：eat（猫吃鱼）drink（喝水…）\n\n  ​\t狗类成员方法：eat（狗吃肉）drink（喝水…）\n\n- 实现步骤\n\n  1. 猫类和狗类中存在共性内容，应向上抽取出一个动物类（Animal）\n  2. 父类Animal中，无法将 eat 方法具体实现描述清楚，所以定义为抽象方法\n  3. 抽象方法需要存活在抽象类中，将Animal定义为抽象类\n  4. 让 Cat 和 Dog 分别继承 Animal，重写eat方法\n  5. 测试类中创建 Cat 和 Dog 对象，调用方法测试\n\n- 代码实现\n\n  - 动物类\n\n  ```java\n  public abstract class Animal {\n      public void drink(){\n          System.out.println("喝水");\n      }\n\n      public Animal(){\n\n      }\n\n      public abstract void eat();\n  }\n  ```\n\n  - 猫类\n\n  ```java\n  public class Cat extends Animal {\n      @Override\n      public void eat() {\n          System.out.println("猫吃鱼");\n      }\n  }\n  ```\n\n  - 狗类\n\n  ```java\n  public class Dog extends Animal {\n      @Override\n      public void eat() {\n          System.out.println("狗吃肉");\n      }\n  }\n  ```\n\n  - 测试类\n\n  ```java\n  public static void main(String[] args) {\n          Dog d = new Dog();\n          d.eat();\n          d.drink();\n\n          Cat c = new Cat();\n          c.drink();\n          c.eat();\n\n          //Animal a = new Animal();\n          //a.eat();\n      }\n  ```\n\n### 3.4模板设计模式 \n\n+ 设计模式\n\n  设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。\n  使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。\n\n+ 模板设计模式\n\n  把抽象类整体就可以看做成一个模板，模板中不能决定的东西定义成抽象方法\n  让使用模板的类（继承抽象类的类）去重写抽象方法实现需求\n\n+ 模板设计模式的优势\n\n  模板已经定义了通用结构，使用者只需要关心自己需要实现的功能即可\n\n+ 示例代码\n\n  模板类\n\n  ```java\n  /*\n      作文模板类\n   */\n  public abstract class CompositionTemplate {\n\n      public final void write(){\n          System.out.println("<<我的爸爸>>");\n\n          body();\n\n          System.out.println("啊~ 这就是我的爸爸");\n\n      }\n\n      public abstract void body();\n  }\n  ```\n\n  实现类A\n\n  ```java\n  public class Tom extends CompositionTemplate {\n\n      @Override\n      public void body() {\n          System.out.println("那是一个秋天, 风儿那么缠绵,记忆中, " +\n                  "那天爸爸骑车接我放学回家,我的脚卡在了自行车链当中, 爸爸蹬不动,他就站起来蹬...");\n      }\n  }\n  ```\n\n  实现类B\n\n  ```java\n  public class Tony extends CompositionTemplate {\n      @Override\n      public void body() {\n\n      }\n\n      /*public void write(){\n\n      }*/\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class Test {\n      public static void main(String[] args) {\n          Tom t = new Tom();\n          t.write();\n      }\n  }\n  ```\n\n### 3.5final（应用）\n\n- fianl关键字的作用\n\n  - final代表最终的意思，可以修饰成员方法，成员变量，类\n\n- final修饰类、方法、变量的效果  \n\n  - fianl修饰类：该类不能被继承（不能有子类，但是可以有父类）\n\n  - final修饰方法：该方法不能被重写\n\n  - final修饰变量：表明该变量是一个常量，不能再次赋值\n\n    + 变量是基本类型,不能改变的是值\n\n    + 变量是引用类型,不能改变的是地址值,但地址里面的内容是可以改变的\n\n    + 举例\n\n      ```java\n      public static void main(String[] args){\n          final Student s = new Student(23);\n        \ts = new Student(24);  // 错误\n       \ts.setAge(24);  // 正确\n      }\n      ```\n\n### 3.6黑马信息管理系统使用抽象类改进 (应用)\n\n+ 需求\n\n  1. 使用抽象类的思想，将BaseStudentController 中的 inputStudentInfo 方法，定义为抽象方法\n  2. 将不希望子类重写的方法，使用 final 进行修饰\n\n+ 代码实现\n\n  BaseStudentController类\n\n  ```java\n  public abstract class BaseStudentController {\n      // 业务员对象\n      private StudentService studentService = new StudentService();\n\n      private Scanner sc = new Scanner(System.in);\n\n      // 开启学生管理系统, 并展示学生管理系统菜单\n      public final void start() {\n          //Scanner sc = new Scanner(System.in);\n          studentLoop:\n          while (true) {\n              System.out.println("--------欢迎来到 <学生> 管理系统--------");\n              System.out.println("请输入您的选择: 1.添加学生  2.删除学生  3.修改学生  4.查看学生  5.退出");\n              String choice = sc.next();\n              switch (choice) {\n                  case "1":\n                      // System.out.println("添加");\n                      addStudent();\n                      break;\n                  case "2":\n                      // System.out.println("删除");\n                      deleteStudentById();\n                      break;\n                  case "3":\n                      // System.out.println("修改");\n                      updateStudent();\n                      break;\n                  case "4":\n                      // System.out.println("查询");\n                      findAllStudent();\n                      break;\n                  case "5":\n                      System.out.println("感谢您使用学生管理系统, 再见!");\n                      break studentLoop;\n                  default:\n                      System.out.println("您的输入有误, 请重新输入");\n                      break;\n              }\n          }\n      }\n\n      // 修改学生方法\n      public final void updateStudent() {\n          String updateId = inputStudentId();\n          Student newStu = inputStudentInfo(updateId);\n          studentService.updateStudent(updateId, newStu);\n\n          System.out.println("修改成功!");\n      }\n\n      // 删除学生方法\n      public final void deleteStudentById() {\n          String delId = inputStudentId();\n          // 3. 调用业务员中的deleteStudentById根据id, 删除学生\n          studentService.deleteStudentById(delId);\n          // 4. 提示删除成功\n          System.out.println("删除成功!");\n      }\n\n      // 查看学生方法\n      public final void findAllStudent() {\n          // 1. 调用业务员中的获取方法, 得到学生的对象数组\n          Student[] stus = studentService.findAllStudent();\n          // 2. 判断数组的内存地址, 是否为null\n          if (stus == null) {\n              System.out.println("查无信息, 请添加后重试");\n              return;\n          }\n          // 3. 遍历数组, 获取学生信息并打印在控制台\n          System.out.println("学号\\t\\t姓名\\t年龄\\t生日");\n          for (int i = 0; i < stus.length; i++) {\n              Student stu = stus[i];\n              if (stu != null) {\n                  System.out.println(stu.getId() + "\\t" + stu.getName() + "\\t" + stu.getAge() + "\\t\\t" + stu.getBirthday());\n              }\n          }\n      }\n\n      // 添加学生方法\n      public final void addStudent() {\n          // StudentService studentService = new StudentService();\n          // 1. 键盘接收学生信息\n          String id;\n          while (true) {\n              System.out.println("请输入学生id:");\n              id = sc.next();\n              boolean flag = studentService.isExists(id);\n              if (flag) {\n                  System.out.println("学号已被占用, 请重新输入");\n              } else {\n                  break;\n              }\n          }\n\n          Student stu = inputStudentInfo(id);\n\n          // 3. 将学生对象,传递给StudentService(业务员)中的addStudent方法\n          boolean result = studentService.addStudent(stu);\n          // 4. 根据返回的boolean类型结果, 在控制台打印成功\\失败\n          if (result) {\n              System.out.println("添加成功");\n          } else {\n              System.out.println("添加失败");\n          }\n      }\n\n      // 键盘录入学生id\n      public String inputStudentId() {\n          String id;\n          while (true) {\n              System.out.println("请输入学生id:");\n              id = sc.next();\n              boolean exists = studentService.isExists(id);\n              if (!exists) {\n                  System.out.println("您输入的id不存在, 请重新输入:");\n              } else {\n                  break;\n              }\n          }\n          return id;\n      }\n\n      // 键盘录入学生信息\n      // 开闭原则: 对扩展内容开放, 对修改内容关闭\n    public abstract Student inputStudentInfo(String id);\n  }\n  ```\n\n## 4.代码块 \n\n### 4.1代码块概述 (理解)\n\n在Java中，使用 { } 括起来的代码被称为代码块\n\n### 4.2代码块分类 (理解) \n\n+ 局部代码块\n\n  + 位置: 方法中定义\n\n  + 作用: 限定变量的生命周期，及早释放，提高内存利用率\n\n  + 示例代码\n\n    ```java\n    public class Test {\n        /*\n            局部代码块\n                位置：方法中定义\n                作用：限定变量的生命周期，及早释放，提高内存利用率\n         */\n        public static void main(String[] args) {\n            {\n                int a = 10;\n                System.out.println(a);\n            }\n\n           // System.out.println(a);\n        }\n    }\n    ```\n\n+ 构造代码块\n\n  + 位置: 类中方法外定义\n\n  + 特点: 每次构造方法执行的时，都会执行该代码块中的代码，并且在构造方法执行前执行\n\n  + 作用: 将多个构造方法中相同的代码，抽取到构造代码块中，提高代码的复用性\n\n  + 示例代码\n\n    ```java\n    public class Test {\n        /*\n            构造代码块:\n                位置：类中方法外定义\n                特点：每次构造方法执行的时，都会执行该代码块中的代码，并且在构造方法执行前执行\n                作用：将多个构造方法中相同的代码，抽取到构造代码块中，提高代码的复用性\n         */\n        public static void main(String[] args) {\n            Student stu1 = new Student();\n            Student stu2 = new Student(10);\n        }\n    }\n\n    class Student {\n\n        {\n            System.out.println("好好学习");\n        }\n\n        public Student(){\n            System.out.println("空参数构造方法");\n        }\n\n        public Student(int a){\n            System.out.println("带参数构造方法...........");\n        }\n    }\n    ```\n\n+ 静态代码块\n\n  + 位置: 类中方法外定义\n\n  + 特点: 需要通过static关键字修饰，随着类的加载而加载，并且只执行一次\n\n  + 作用: 在类加载的时候做一些数据初始化的操作\n\n  + 示例代码\n\n    ```java\n    public class Test {\n        /*\n            静态代码块:\n                位置：类中方法外定义\n                特点：需要通过static关键字修饰，随着类的加载而加载，并且只执行一次\n                作用：在类加载的时候做一些数据初始化的操作\n         */\n        public static void main(String[] args) {\n            Person p1 = new Person();\n            Person p2 = new Person(10);\n        }\n    }\n\n    class Person {\n        static {\n            System.out.println("我是静态代码块, 我执行了");\n        }\n\n        public Person(){\n            System.out.println("我是Person类的空参数构造方法");\n        }\n\n        public Person(int a){\n            System.out.println("我是Person类的带...........参数构造方法");\n        }\n    }\n    ```\n\n### 4.3黑马信息管理系统使用代码块改进 (应用) \n\n+ 需求\n\n  使用静态代码块，初始化一些学生数据\n\n+ 实现步骤\n\n  1. 在StudentDao类中定义一个静态代码块，用来初始化一些学生数据\n  2. 将初始化好的学生数据存储到学生数组中\n\n+ 示例代码\n\n  StudentDao类\n\n  ```java\n  public class StudentDao {\n      // 创建学生对象数组\n      private static Student[] stus = new Student[5];\n\n      static {\n          Student stu1 = new Student("heima001","张三","23","1999-11-11");\n          Student stu2 = new Student("heima002","李四","24","2000-11-11");\n\n          stus[0] = stu1;\n          stus[1] = stu2;\n      }\n\n      // 添加学生方法\n      public boolean addStudent(Student stu) {\n\n          // 2. 添加学生到数组\n          //2.1 定义变量index为-1，假设数组已经全部存满，没有null的元素\n          int index = -1;\n          //2.2 遍历数组取出每一个元素，判断是否是null\n          for (int i = 0; i < stus.length; i++) {\n              Student student = stus[i];\n              if(student == null){\n                  index = i;\n                  //2.3 如果为null，让index变量记录当前索引位置，并使用break结束循环遍历\n                  break;\n              }\n          }\n\n          // 3. 返回是否添加成功的boolean类型状态\n          if(index == -1){\n              // 装满了\n              return false;\n          }else{\n              // 没有装满, 正常添加, 返回true\n              stus[index] = stu;\n              return true;\n          }\n      }\n      // 查看学生方法\n      public Student[] findAllStudent() {\n          return stus;\n      }\n\n      public void deleteStudentById(String delId) {\n          // 1. 查找id在容器中所在的索引位置\n          int index = getIndex(delId);\n          // 2. 将该索引位置,使用null元素进行覆盖\n          stus[index] = null;\n      }\n\n      public int getIndex(String id){\n          int index = -1;\n          for (int i = 0; i < stus.length; i++) {\n              Student stu = stus[i];\n              if(stu != null && stu.getId().equals(id)){\n                  index = i;\n                  break;\n              }\n          }\n          return index;\n      }\n\n      public void updateStudent(String updateId, Student newStu) {\n          // 1. 查找updateId, 在容器中的索引位置\n          int index = getIndex(updateId);\n          // 2. 将该索引位置, 使用新的学生对象替换\n          stus[index] = newStu;\n      }\n  }\n  ```\n\n  ​\n\n'},"8d2d":function(n,e,t){"use strict";t.r(e),e["default"]='大家好，我是 Guide 哥，前段时间答应读者的 **Spring 事务**分析总结终于来了。这部分内容比较重要，不论是对于工作还是面试，但是网上比较好的参考资料比较少。\n\n如果本文有任何不对或者需要完善的地方，请帮忙指出！Guide 哥感激不尽！\n\n## 1. 什么是事务？\n\n**事务是逻辑上的一组操作，要么都执行，要么都不执行。**\n\n_Guide 哥：大家应该都能背上面这句话了，下面我结合我们日常的真实开发来谈一谈。_\n\n我们系统的每个业务方法可能包括了多个原子性的数据库操作，比如下面的 `savePerson()` 方法中就有两个原子性的数据库操作。这些原子性的数据库操作是有依赖的，它们要么都执行，要不就都不执行。\n\n```java\n\tpublic void savePerson() {\n\t\tpersonDao.save(person);\n\t\tpersonDetailDao.save(personDetail);\n\t}\n```\n\n另外，需要格外注意的是：**事务能否生效数据库引擎是否支持事务是关键。比如常用的 MySQL 数据库默认使用支持事务的`innodb`引擎。但是，如果把数据库引擎变为 `myisam`，那么程序也就不再支持事务了！**\n\n事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作就是：\n\n1. 将小明的余额减少 1000 元\n\n2. 将小红的余额增加 1000 元。\n\n万一在这两个操作之间突然出现错误比如银行系统崩溃或者网络故障，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。\n\n```java\npublic class OrdersService {\n\tprivate AccountDao accountDao;\n\n\tpublic void setOrdersDao(AccountDao accountDao) {\n\t\tthis.accountDao = accountDao;\n\t}\n\n  @Transactional(propagation = Propagation.REQUIRED,\n                isolation = Isolation.DEFAULT, readOnly = false, timeout = -1)\n\tpublic void accountMoney() {\n    //小红账户多1000\n\t\taccountDao.addMoney(1000,xiaohong);\n\t\t//模拟突然出现的异常，比如银行中可能为突然停电等等\n    //如果没有配置事务管理的话会造成，小红账户多了1000而小明账户没有少钱\n\t\tint i = 10 / 0;\n\t\t//小王账户少1000\n\t\taccountDao.reduceMoney(1000,xiaoming);\n\t}\n}\n```\n\n另外，数据库事务的 ACID 四大特性是事务的基础，下面简单来了解一下。\n\n## 2. 事务的特性（ACID）了解么?\n\n![](Spring事务总结.assets/bda7231b-ab05-4e23-95ee-89ac90ac7fcf.png)\n\n- **原子性（Atomicity）：** 一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。\n- **一致性（Consistency）：** 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。\n- **隔离性（Isolation）：** 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。\n- **持久性（Durability）:** 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\n\n参考 ：[https://zh.wikipedia.org/wiki/ACID](https://zh.wikipedia.org/wiki/ACID) 。\n\n## 3. 详谈 Spring 对事务的支持\n\n**再提醒一次：你的程序是否支持事务首先取决于数据库 ，比如使用 MySQL 的话，如果你选择的是 innodb 引擎，那么恭喜你，是可以支持事务的。但是，如果你的 MySQL 数据库使用的是 myisam 引擎的话，那不好意思，从根上就是不支持事务的。**\n\n这里再多提一下一个非常重要的知识点： **MySQL 怎么保证原子性的？**\n\n我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行**回滚**，在 MySQL 中，恢复机制是通过 **回滚日志（undo log）** 实现的，所有事务进行的修改都会先先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 **回滚日志** 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。\n\n### 3.1. Spring 支持两种方式的事务管理\n\n#### 1).编程式事务管理\n\n通过 `TransactionTemplate`或者`TransactionManager`手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。\n\n使用`TransactionTemplate` 进行编程式事务管理的示例代码如下：\n\n```java\n@Autowired\nprivate TransactionTemplate transactionTemplate;\npublic void testTransaction() {\n\n        transactionTemplate.execute(new TransactionCallbackWithoutResult() {\n            @Override\n            protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {\n\n                try {\n\n                    // ....  业务代码\n                } catch (Exception e){\n                    //回滚\n                    transactionStatus.setRollbackOnly();\n                }\n\n            }\n        });\n}\n```\n\n使用 `TransactionManager` 进行编程式事务管理的示例代码如下：\n\n```java\n@Autowired\nprivate PlatformTransactionManager transactionManager;\n\npublic void testTransaction() {\n\n  TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());\n          try {\n               // ....  业务代码\n              transactionManager.commit(status);\n          } catch (Exception e) {\n              transactionManager.rollback(status);\n          }\n}\n```\n\n#### 2)声明式事务管理\n\n推荐使用（代码侵入性最小），实际是通过 AOP 实现（基于`@Transactional` 的全注解方式使用最多）。\n\n使用 `@Transactional`注解进行事务管理的示例代码如下：\n\n```java\n@Transactional(propagation=propagation.PROPAGATION_REQUIRED)\npublic void aMethod {\n  //do something\n  B b = new B();\n  C c = new C();\n  b.bMethod();\n  c.cMethod();\n}\n```\n\n### 3.2. Spring 事务管理接口介绍\n\nSpring 框架中，事务管理相关最重要的 3 个接口如下：\n\n- **`PlatformTransactionManager`**： （平台）事务管理器，Spring 事务策略的核心。\n- **`TransactionDefinition`**： 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)。\n- **`TransactionStatus`**： 事务运行状态。\n\n我们可以把 **`PlatformTransactionManager`** 接口可以被看作是事务上层的管理者，而 **`TransactionDefinition`** 和 **`TransactionStatus`** 这两个接口可以看作是事务的描述。\n\n**`PlatformTransactionManager`** 会根据 **`TransactionDefinition`** 的定义比如事务超时时间、隔离级别、传播行为等来进行事务管理 ，而 **`TransactionStatus`** 接口则提供了一些方法来获取事务相应的状态比如是否新事务、是否可以回滚等等。\n\n#### 3.2.1. PlatformTransactionManager:事务管理接口\n\n**Spring 并不直接管理事务，而是提供了多种事务管理器** 。Spring 事务管理器的接口是： **`PlatformTransactionManager`** 。\n\n通过这个接口，Spring 为各个平台如 JDBC(`DataSourceTransactionManager`)、Hibernate(`HibernateTransactionManager`)、JPA(`JpaTransactionManager`)等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。\n\n**`PlatformTransactionManager` 接口的具体实现如下:**\n\n![](Spring事务总结.assets/ae964c2c-7289-441c-bddd-511161f51ee1.png)\n\n`PlatformTransactionManager`接口中定义了三个方法：\n\n```java\npackage org.springframework.transaction;\n\nimport org.springframework.lang.Nullable;\n\npublic interface PlatformTransactionManager {\n    //获得事务\n    TransactionStatus getTransaction(@Nullable TransactionDefinition var1) throws TransactionException;\n    //提交事务\n    void commit(TransactionStatus var1) throws TransactionException;\n    //回滚事务\n    void rollback(TransactionStatus var1) throws TransactionException;\n}\n\n```\n\n**这里多插一嘴。为什么要定义或者说抽象出来`PlatformTransactionManager`这个接口呢？**\n\n主要是因为要将事务管理行为抽象出来，然后不同的平台去实现它，这样我们可以保证提供给外部的行为不变，方便我们扩展。我前段时间分享过：**“为什么我们要用接口？”**\n\n![](Spring事务总结.assets/接口使用原因.png)\n\n#### 3.2.2. TransactionDefinition:事务属性\n\n事务管理器接口 **`PlatformTransactionManager`** 通过 **`getTransaction(TransactionDefinition definition)`** 方法来得到一个事务，这个方法里面的参数是 **`TransactionDefinition`** 类 ，这个类就定义了一些基本的事务属性。\n\n那么什么是 **事务属性** 呢？\n\n事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。\n\n事务属性包含了 5 个方面：\n\n![](Spring事务总结.assets/a616b84d-9eea-4ad1-b4fc-461ff05e951d.png)\n\n`TransactionDefinition` 接口中定义了 5 个方法以及一些表示事务属性的常量比如隔离级别、传播行为等等。\n\n```java\npackage org.springframework.transaction;\n\nimport org.springframework.lang.Nullable;\n\npublic interface TransactionDefinition {\n    int PROPAGATION_REQUIRED = 0;\n    int PROPAGATION_SUPPORTS = 1;\n    int PROPAGATION_MANDATORY = 2;\n    int PROPAGATION_REQUIRES_NEW = 3;\n    int PROPAGATION_NOT_SUPPORTED = 4;\n    int PROPAGATION_NEVER = 5;\n    int PROPAGATION_NESTED = 6;\n    int ISOLATION_DEFAULT = -1;\n    int ISOLATION_READ_UNCOMMITTED = 1;\n    int ISOLATION_READ_COMMITTED = 2;\n    int ISOLATION_REPEATABLE_READ = 4;\n    int ISOLATION_SERIALIZABLE = 8;\n    int TIMEOUT_DEFAULT = -1;\n    // 返回事务的传播行为，默认值为 REQUIRED。\n    int getPropagationBehavior();\n    //返回事务的隔离级别，默认值是 DEFAULT\n    int getIsolationLevel();\n    // 返回事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。\n    int getTimeout();\n    // 返回是否为只读事务，默认值为 false\n    boolean isReadOnly();\n\n    @Nullable\n    String getName();\n}\n```\n\n#### 3.2.3. TransactionStatus:事务状态\n\n`TransactionStatus`接口用来记录事务的状态 该接口定义了一组方法,用来获取或判断事务的相应状态信息。\n\n`PlatformTransactionManager.getTransaction(…)`方法返回一个 `TransactionStatus` 对象。\n\n**TransactionStatus 接口接口内容如下：**\n\n```java\npublic interface TransactionStatus{\n    boolean isNewTransaction(); // 是否是新的事务\n    boolean hasSavepoint(); // 是否有恢复点\n    void setRollbackOnly();  // 设置为只回滚\n    boolean isRollbackOnly(); // 是否为只回滚\n    boolean isCompleted; // 是否已完成\n}\n```\n\n### 3.3. 事务属性详解\n\n_实际业务开发中，大家一般都是使用 `@Transactional` 注解来开启事务，很多人并不清楚这个参数里面的参数是什么意思，有什么用。为了更好的在项目中使用事务管理，强烈推荐好好阅读一下下面的内容。_\n\n#### 3.3.1. 事务传播行为\n\n**事务传播行为是为了解决业务层方法之间互相调用的事务问题**。\n\n当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。\n\n**举个例子！**\n\n我们在 A 类的`aMethod（）`方法中调用了 B 类的 `bMethod()` 方法。这个时候就涉及到业务层方法之间互相调用的事务问题。如果我们的 `bMethod()`如果发生异常需要回滚，如何配置事务传播行为才能让 `aMethod()`也跟着回滚呢？这个时候就需要事务传播行为的知识了，如果你不知道的话一定要好好看一下。\n\n```java\nClass A {\n    @Transactional(propagation=propagation.xxx)\n    public void aMethod {\n        //do something\n        B b = new B();\n        b.bMethod();\n    }\n}\n\nClass B {\n    @Transactional(propagation=propagation.xxx)\n    public void bMethod {\n       //do something\n    }\n}\n```\n\n在`TransactionDefinition`定义中包括了如下几个表示传播行为的常量：\n\n```java\npublic interface TransactionDefinition {\n    int PROPAGATION_REQUIRED = 0;\n    int PROPAGATION_SUPPORTS = 1;\n    int PROPAGATION_MANDATORY = 2;\n    int PROPAGATION_REQUIRES_NEW = 3;\n    int PROPAGATION_NOT_SUPPORTED = 4;\n    int PROPAGATION_NEVER = 5;\n    int PROPAGATION_NESTED = 6;\n    ......\n}\n```\n\n不过如此，为了方便使用，Spring 会相应地定义了一个枚举类：`Propagation`\n\n```java\npackage org.springframework.transaction.annotation;\n\nimport org.springframework.transaction.TransactionDefinition;\n\npublic enum Propagation {\n\n\tREQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),\n\n\tSUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),\n\n\tMANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),\n\n\tREQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),\n\n\tNOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),\n\n\tNEVER(TransactionDefinition.PROPAGATION_NEVER),\n\n\tNESTED(TransactionDefinition.PROPAGATION_NESTED);\n\n\n\tprivate final int value;\n\n\tPropagation(int value) {\n\t\tthis.value = value;\n\t}\n\n\tpublic int value() {\n\t\treturn this.value;\n\t}\n\n}\n\n```\n\n**正确的事务传播行为可能的值如下** ：\n\n**1.`TransactionDefinition.PROPAGATION_REQUIRED`**\n\n使用的最多的一个事务传播行为，我们平时经常使用的`@Transactional`注解默认使用就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。也就是说：\n\n1. 如果外部方法没有开启事务的话，`Propagation.REQUIRED`修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。\n2. 如果外部方法开启事务并且被`Propagation.REQUIRED`的话，所有`Propagation.REQUIRED`修饰的内部方法和外部方法均属于同一事务 ，只要一个方法回滚，整个事务均回滚。\n\n举个例子：如果我们上面的`aMethod()`和`bMethod()`使用的都是`PROPAGATION_REQUIRED`传播行为的话，两者使用的就是同一个事务，只要其中一个方法回滚，整个事务均回滚。\n\n```java\nClass A {\n    @Transactional(propagation=propagation.PROPAGATION_REQUIRED)\n    public void aMethod {\n        //do something\n        B b = new B();\n        b.bMethod();\n    }\n}\n\nClass B {\n    @Transactional(propagation=propagation.PROPAGATION_REQUIRED)\n    public void bMethod {\n       //do something\n    }\n}\n```\n\n**`2.TransactionDefinition.PROPAGATION_REQUIRES_NEW`**\n\n创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，`Propagation.REQUIRES_NEW`修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。\n\n举个例子：如果我们上面的`bMethod()`使用`PROPAGATION_REQUIRES_NEW`事务传播行为修饰，`aMethod`还是用`PROPAGATION_REQUIRED`修饰的话。如果`aMethod()`发生异常回滚，`bMethod()`不会跟着回滚，因为 `bMethod()`开启了独立的事务。但是，如果 `bMethod()`抛出了未被捕获的异常并且这个异常满足事务回滚规则的话,`aMethod()`同样也会回滚，因为这个异常被 `aMethod()`的事务管理机制检测到了。\n\n```java\nClass A {\n    @Transactional(propagation=propagation.PROPAGATION_REQUIRED)\n    public void aMethod {\n        //do something\n        B b = new B();\n        b.bMethod();\n    }\n}\n\nClass B {\n    @Transactional(propagation=propagation.REQUIRES_NEW)\n    public void bMethod {\n       //do something\n    }\n}\n```\n\n**3.`TransactionDefinition.PROPAGATION_NESTED`**:\n\n如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于`TransactionDefinition.PROPAGATION_REQUIRED`。也就是说：\n\n1. 在外部方法未开启事务的情况下`Propagation.NESTED`和`Propagation.REQUIRED`作用相同，修饰的内部方法都会新开启自己的事务，且开启的事务相互独立，互不干扰。\n2. 如果外部方法开启事务的话，`Propagation.NESTED`修饰的内部方法属于外部事务的子事务，外部主事务回滚的话，子事务也会回滚，而内部子事务可以单独回滚而不影响外部主事务和其他子事务。\n\n这里还是简单举个例子：\n\n如果 `aMethod()` 回滚的话，`bMethod()`和`bMethod2()`都要回滚，而`bMethod()`回滚的话，并不会造成 `aMethod()` 和`bMethod()2`回滚。\n\n```java\nClass A {\n    @Transactional(propagation=propagation.PROPAGATION_REQUIRED)\n    public void aMethod {\n        //do something\n        B b = new B();\n        b.bMethod();\n        b.bMethod2();\n    }\n}\n\nClass B {\n    @Transactional(propagation=propagation.PROPAGATION_NESTED)\n    public void bMethod {\n       //do something\n    }\n    @Transactional(propagation=propagation.PROPAGATION_NESTED)\n    public void bMethod2 {\n       //do something\n    }\n}\n```\n\n**4.`TransactionDefinition.PROPAGATION_MANDATORY`**\n\n如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）\n\n这个使用的很少，就不举例子来说了。\n\n**若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚，这里不对照案例讲解了，使用的很少。**\n\n- **`TransactionDefinition.PROPAGATION_SUPPORTS`**: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。\n- **`TransactionDefinition.PROPAGATION_NOT_SUPPORTED`**: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。\n- **`TransactionDefinition.PROPAGATION_NEVER`**: 以非事务方式运行，如果当前存在事务，则抛出异常。\n\n更多关于事务传播行为的内容请看这篇文章：[《太难了~面试官让我结合案例讲讲自己对 Spring 事务传播行为的理解。》](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486668&idx=2&sn=0381e8c836442f46bdc5367170234abb&chksm=cea24307f9d5ca11c96943b3ccfa1fc70dc97dd87d9c540388581f8fe6d805ff548dff5f6b5b&token=1776990505&lang=zh_CN#rd)\n\n#### 3.3.2 事务隔离级别\n\n`TransactionDefinition` 接口中定义了五个表示隔离级别的常量：\n\n```java\npublic interface TransactionDefinition {\n    ......\n    int ISOLATION_DEFAULT = -1;\n    int ISOLATION_READ_UNCOMMITTED = 1;\n    int ISOLATION_READ_COMMITTED = 2;\n    int ISOLATION_REPEATABLE_READ = 4;\n    int ISOLATION_SERIALIZABLE = 8;\n    ......\n}\n```\n\n和事务传播行为这块一样，为了方便使用，Spring 也相应地定义了一个枚举类：`Isolation`\n\n```java\npublic enum Isolation {\n\n\tDEFAULT(TransactionDefinition.ISOLATION_DEFAULT),\n\n\tREAD_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),\n\n\tREAD_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),\n\n\tREPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),\n\n\tSERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);\n\n\tprivate final int value;\n\n\tIsolation(int value) {\n\t\tthis.value = value;\n\t}\n\n\tpublic int value() {\n\t\treturn this.value;\n\t}\n\n}\n```\n\n下面我依次对每一种事务隔离级别进行介绍：\n\n- **`TransactionDefinition.ISOLATION_DEFAULT`** :使用后端数据库默认的隔离级别，MySQL 默认采用的 `REPEATABLE_READ` 隔离级别 Oracle 默认采用的 `READ_COMMITTED` 隔离级别.\n- **`TransactionDefinition.ISOLATION_READ_UNCOMMITTED`** :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**\n- **`TransactionDefinition.ISOLATION_READ_COMMITTED`** : 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**\n- **`TransactionDefinition.ISOLATION_REPEATABLE_READ`** : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生。**\n- **`TransactionDefinition.ISOLATION_SERIALIZABLE`** : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。但是这将严重影响程序的性能。通常情况下也不会用到该级别。\n\n因为平时使用 MySQL 数据库比较多，这里再多提一嘴！\n\nMySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）**。我们可以通过`SELECT @@tx_isolation;`命令来查看，MySQL 8.0 该命令改为`SELECT @@transaction_isolation;`\n\n```sql\nmysql> SELECT @@tx_isolation;\n+-----------------+\n| @@tx_isolation  |\n+-----------------+\n| REPEATABLE-READ |\n+-----------------+\n```\n\n~~这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 **REPEATABLE-READ（可重读）** 事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）** 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 **SERIALIZABLE(可串行化)** 隔离级别。~~\n\n🐛问题更正：**MySQL InnoDB的REPEATABLE-READ（可重读）并不保证避免幻读，需要应用使用加锁读来保证。而这个加锁度使用到的机制就是 Next-Key Locks。**\n\n因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 **READ-COMMITTED(读取提交内容)** ，但是你要知道的是InnoDB 存储引擎默认使用 **REPEAaTABLE-READ（可重读）** 并不会有任何性能损失。\n\nInnoDB 存储引擎在 **分布式事务** 的情况下一般会用到 **SERIALIZABLE(可串行化)** 隔离级别。\n\n🌈拓展一下(以下内容摘自《MySQL技术内幕：InnoDB存储引擎(第2版)》7.7章)：\n\n> InnoDB存储引擎提供了对XA事务的支持，并通过XA事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源（transactional resources）参与到一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的ACID要求又有了提高。另外，在使用分布式事务时，InnoDB存储引擎的事务隔离级别必须设置为SERIALIZABLE。\n\n#### 3.3.3. 事务超时属性\n\n所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 `TransactionDefinition` 中以 int 的值来表示超时时间，其单位是秒，默认值为-1。\n\n#### 3.3.4. 事务只读属性\n\n```java\npackage org.springframework.transaction;\n\nimport org.springframework.lang.Nullable;\n\npublic interface TransactionDefinition {\n    ......\n    // 返回是否为只读事务，默认值为 false\n    boolean isReadOnly();\n\n}\n```\n\n对于只有读取数据查询的事务，可以指定事务类型为 readonly，即只读事务。只读事务不涉及数据的修改，数据库会提供一些优化手段，适合用在有多条数据库查询操作的方法中。\n\n很多人就会疑问了，为什么我一个数据查询操作还要启用事务支持呢？\n\n拿 MySQL 的 innodb 举例子，根据官网 [https://dev.mysql.com/doc/refman/5.7/en/innodb-autocommit-commit-rollback.html](https://dev.mysql.com/doc/refman/5.7/en/innodb-autocommit-commit-rollback.html) 描述：\n\n> MySQL 默认对每一个新建立的连接都启用了`autocommit`模式。在该模式下，每一个发送到 MySQL 服务器的`sql`语句都会在一个单独的事务中进行处理，执行结束后会自动提交事务，并开启一个新的事务。\n\n但是，如果你给方法加上了`Transactional`注解的话，这个方法执行的所有`sql`会被放在一个事务中。如果声明了只读事务的话，数据库就会去优化它的执行，并不会带来其他的什么收益。\n\n如果不加`Transactional`，每条`sql`会开启一个单独的事务，中间被其它事务改了数据，都会实时读取到最新值。\n\n分享一下关于事务只读属性，其他人的解答：\n\n1. 如果你一次执行单条查询语句，则没有必要启用事务支持，数据库默认支持 SQL 执行期间的读一致性；\n2. 如果你一次执行多条查询语句，例如统计查询，报表查询，在这种场景下，多条查询 SQL 必须保证整体的读一致性，否则，在前条 SQL 查询之后，后条 SQL 查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态，此时，应该启用事务支持\n\n#### 3.3.5. 事务回滚规则\n\n这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常（RuntimeException 的子类）时才会回滚，Error 也会导致事务回滚，但是，在遇到检查型（Checked）异常时不会回滚。\n\n![](Spring事务总结.assets/f6c6f0aa-0f26-49e1-84b3-7f838c7379d1.png)\n\n如果你想要回滚你定义的特定的异常类型的话，可以这样：\n\n```java\n@Transactional(rollbackFor= MyException.class)\n```\n\n### 3.4. @Transactional 注解使用详解\n\n#### 1) `@Transactional` 的作用范围\n\n1. **方法** ：推荐将注解使用于方法上，不过需要注意的是：**该注解只能应用到 public 方法上，否则不生效。**\n2. **类** ：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。\n3. **接口** ：不推荐在接口上使用。\n\n#### 2) `@Transactional` 的常用配置参数\n\n`@Transactional`注解源码如下，里面包含了基本事务属性的配置：\n\n```java\n@Target({ElementType.TYPE, ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\npublic @interface Transactional {\n\n\t@AliasFor("transactionManager")\n\tString value() default "";\n\n\t@AliasFor("value")\n\tString transactionManager() default "";\n\n\tPropagation propagation() default Propagation.REQUIRED;\n\n\tIsolation isolation() default Isolation.DEFAULT;\n\n\tint timeout() default TransactionDefinition.TIMEOUT_DEFAULT;\n\n\tboolean readOnly() default false;\n\n\tClass<? extends Throwable>[] rollbackFor() default {};\n\n\tString[] rollbackForClassName() default {};\n\n\tClass<? extends Throwable>[] noRollbackFor() default {};\n\n\tString[] noRollbackForClassName() default {};\n\n}\n```\n\n**`@Transactional` 的常用配置参数总结（只列出了 5 个我平时比较常用的）：**\n\n| 属性名      | 说明                                                                                         |\n| :---------- | :------------------------------------------------------------------------------------------- |\n| propagation | 事务的传播行为，默认值为 REQUIRED，可选的值在上面介绍过                                      |\n| isolation   | 事务的隔离级别，默认值采用 DEFAULT，可选的值在上面介绍过                                     |\n| timeout     | 事务的超时时间，默认值为-1（不会超时）。如果超过该时间限制但事务还没有完成，则自动回滚事务。 |\n| readOnly    | 指定事务是否为只读事务，默认值为 false。                                                     |\n| rollbackFor | 用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型。                               |\n\n#### 3)`@Transactional` 事务注解原理\n\n面试中在问 AOP 的时候可能会被问到的一个问题。简单说下吧！\n\n我们知道，**`@Transactional` 的工作机制是基于 AOP 实现的，AOP 又是使用动态代理实现的。如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理，如果目标对象没有实现了接口,会使用 CGLIB 动态代理。**\n\n多提一嘴：`createAopProxy()` 方法 决定了是使用 JDK 还是 Cglib 来做动态代理，源码如下：\n\n```java\npublic class DefaultAopProxyFactory implements AopProxyFactory, Serializable {\n\n\t@Override\n\tpublic AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {\n\t\tif (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {\n\t\t\tClass<?> targetClass = config.getTargetClass();\n\t\t\tif (targetClass == null) {\n\t\t\t\tthrow new AopConfigException("TargetSource cannot determine target class: " +\n\t\t\t\t\t\t"Either an interface or a target is required for proxy creation.");\n\t\t\t}\n\t\t\tif (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {\n\t\t\t\treturn new JdkDynamicAopProxy(config);\n\t\t\t}\n\t\t\treturn new ObjenesisCglibAopProxy(config);\n\t\t}\n\t\telse {\n\t\t\treturn new JdkDynamicAopProxy(config);\n\t\t}\n\t}\n  .......\n}\n```\n\n如果一个类或者一个类中的 public 方法上被标注`@Transactional` 注解的话，Spring 容器就会在启动的时候为其创建一个代理类，在调用被`@Transactional` 注解的 public 方法的时候，实际调用的是，`TransactionInterceptor` 类中的 `invoke()`方法。这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。\n\n> `TransactionInterceptor` 类中的 `invoke()`方法内部实际调用的是 `TransactionAspectSupport` 类的 `invokeWithinTransaction()`方法。由于新版本的 Spring 对这部分重写很大，而且用到了很多响应式编程的知识，这里就不列源码了。\n\n#### 4)Spring AOP 自调用问题\n\n若同一类中的其他没有 `@Transactional` 注解的方法内部调用有 `@Transactional` 注解的方法，有`@Transactional` 注解的方法的事务会失效。\n\n这是由于`Spring AOP`代理的原因造成的，因为只有当 `@Transactional` 注解的方法在类以外被调用的时候，Spring 事务管理才生效。\n\n`MyService` 类中的`method1()`调用`method2()`就会导致`method2()`的事务失效。\n\n```java\n@Service\npublic class MyService {\n\nprivate void method1() {\n     method2();\n     //......\n}\n@Transactional\n public void method2() {\n     //......\n  }\n}\n```\n\n解决办法就是避免同一类中自调用或者使用 AspectJ 取代 Spring AOP 代理。\n\n#### 5) `@Transactional` 的使用注意事项总结\n\n1.  `@Transactional` 注解只有作用到 public 方法上事务才生效，不推荐在接口上使用；\n2.  避免同一个类中调用 `@Transactional` 注解的方法，这样会导致事务失效；\n3.  正确的设置 `@Transactional` 的 rollbackFor 和 propagation 属性，否则事务可能会回滚失败\n4.  ......\n\n## 4. Reference\n\n1. [总结]Spring 事务管理中@Transactional 的参数:[http://www.mobabel.net/spring 事务管理中 transactional 的参数/](http://www.mobabel.net/spring事务管理中transactional的参数/)\n\n2. Spring 官方文档：[https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html](https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html)\n\n3. 《Spring5 高级编程》\n\n4. 透彻的掌握 Spring 中@transactional 的使用: [https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html](https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html)\n\n5. Spring 事务的传播特性：[https://github.com/love-somnus/Spring/wiki/Spring 事务的传播特性](https://github.com/love-somnus/Spring/wiki/Spring事务的传播特性)\n\n6. [Spring 事务传播行为详解](https://segmentfault.com/a/1190000013341344) ：[https://segmentfault.com/a/1190000013341344](https://segmentfault.com/a/1190000013341344)\n\n7. 全面分析 Spring 的编程式事务管理及声明式事务管理：[https://www.ibm.com/developerworks/cn/education/opensource/os-cn-spring-trans/index.html](https://www.ibm.com/developerworks/cn/education/opensource/os-cn-spring-trans/index.html)\n\n'},"927b":function(n,e,t){"use strict";t.r(e),e["default"]='# Java基础语法\r\n\r\n## 1 类型转换\r\n\r\n在Java中，一些数据类型之间是可以相互转换的。分为两种情况：自动类型转换和强制类型转换。\r\n\r\n### 1.1 隐式转换(理解)\r\n\r\n​\t把一个表示数据范围小的数值或者变量赋值给另一个表示数据范围大的变量。这种转换方式是自动的，直接书写即可。例如：\r\n\r\n```java\r\ndouble num = 10; // 将int类型的10直接赋值给double类型\r\nSystem.out.println(num); // 输出10.0\r\n```\r\n\r\n​\t类型从小到大关系图：\r\n\r\n​\t![](./day02-Java基础语法.img/图片1.png)\r\n\r\n说明：\r\n\r\n1. 整数默认是int类型，byte、short和char类型数据参与运算均会自动转换为int类型。\r\n\r\n```java\r\nbyte b1 = 10;\r\nbyte b2 = 20;\r\nbyte b3 = b1 + b2; \r\n// 第三行代码会报错，b1和b2会自动转换为int类型，计算结果为int，int赋值给byte需要强制类型转换。\r\n// 修改为:\r\nint num = b1 + b2;\r\n// 或者：\r\nbyte b3 = (byte) (b1 + b2);\r\n```\r\n\r\n2. boolean类型不能与其他基本数据类型相互转换。\r\n\r\n### 1.2 强制转换(理解)\r\n\r\n​\t把一个表示数据范围大的数值或者变量赋值给另一个表示数据范围小的变量。\r\n\r\n​\t强制类型转换格式：目标数据类型 变量名 = (目标数据类型)值或者变量;\r\n\r\n​\t例如：\r\n\r\n```java\r\ndouble num1 = 5.5;\r\nint num2 = (int) num1; // 将double类型的num1强制转换为int类型\r\nSystem.out.println(num2); // 输出5（小数位直接舍弃）\r\n```\r\n\r\n### 1.3 类型转换案例(理解)\r\n\r\n案例代码：\r\n\r\n```java\r\nbyte a = 3;\r\nbyte b = 4;\r\nbyte c = a + b; //错误。因为两个byte变量相加，会先提升为int类型\r\nbyte d = 3 + 4; //正确。常量优化机制\r\n```\r\n\r\n常量优化机制：\r\n\r\n​\t在编译时，整数常量的计算会直接算出结果，并且会自动判断该结果是否在byte取值范围内，\r\n\r\n​\t\t在：编译通过\r\n\r\n  \t\t不在：编译失败\r\n\r\n## 2. 运算符\r\n\r\n### 2.1 算术运算符\r\n\r\n#### 2.1.1 运算符和表达式（了解）\r\n\r\n运算符：对常量或者变量进行操作的符号\r\n\r\n表达式：用运算符把常量或者变量连接起来符合java语法的式子就可以称为表达式。\r\n\r\n​                    不同运算符连接的表达式体现的是不同类型的表达式。\r\n\r\n举例说明：\r\n\r\n```java\r\nint a = 10;\r\nint b = 20;\r\nint c = a + b;\r\n```\r\n\r\n  +：是运算符，并且是算术运算符。\r\n\r\n  a + b：是表达式，由于+是算术运算符，所以这个表达式叫算术表达式。\r\n\r\n####  2.1.2 算术运算符(应用)\r\n\r\n| 符号 | 作用 | 说明                         |\r\n| ---- | ---- | ---------------------------- |\r\n| +    | 加   | 参看小学一年级               |\r\n| -    | 减   | 参看小学一年级               |\r\n| *    | 乘   | 参看小学二年级，与“×”相同    |\r\n| /    | 除   | 参看小学二年级，与“÷”相同    |\r\n| %    | 取余 | 获取的是两个数据做除法的余数 |\r\n\r\n注意：\r\n\r\n1. /和%的区别：两个数据做除法，/取结果的商，%取结果的余数。\r\n\r\n2. 整数操作只能得到整数，要想得到小数，必须有浮点数参与运算。\r\n\r\n~~~java\r\nint a = 10;\r\nint b = 3;\r\nSystem.out.println(a / b); // 输出结果3\r\nSystem.out.println(a % b); // 输出结果1\r\n~~~\r\n\r\n#### 2.1.3 字符的“+”操作（理解）\r\n\r\nchar类型参与算术运算，使用的是计算机底层对应的十进制数值。需要我们记住三个字符对应的数值：\r\n\r\n\'a\'  --  97\t\ta-z是连续的，所以\'b\'对应的数值是98，\'c\'是99，依次递加\r\n\r\n\'A\'  --  65\t\tA-Z是连续的，所以\'B\'对应的数值是66，\'C\'是67，依次递加\r\n\r\n\'0\'  --  48\t\t0-9是连续的，所以\'1\'对应的数值是49，\'2\'是50，依次递加\r\n\r\n~~~java\r\n// 可以通过使用字符与整数做算术运算，得出字符对应的数值是多少\r\nchar ch1 = \'a\';\r\nSystem.out.println(ch1 + 1); // 输出98，97 + 1 = 98\r\n\r\nchar ch2 = \'A\';\r\nSystem.out.println(ch2 + 1); // 输出66，65 + 1 = 66\r\n\r\nchar ch3 = \'0\';\r\nSystem.out.println(ch3 + 1); // 输出49，48 + 1 = 49\r\n~~~\r\n\r\n算术表达式中包含不同的基本数据类型的值的时候，整个算术表达式的类型会自动进行提升。\r\n\r\n提升规则：\r\n\r\nbyte类型，short类型和char类型将被提升到int类型，不管是否有其他类型参与运算。\r\n\r\n整个表达式的类型自动提升到与表达式中最高等级的操作数相同的类型\r\n\r\n​       等级顺序：byte,short,char --\x3e int --\x3e long --\x3e float --\x3e double\r\n\r\n例如：\r\n\r\n~~~java\r\nbyte b1 = 10;\r\nbyte b2 = 20;\r\n// byte b3 = b1 + b2; // 该行报错，因为byte类型参与算术运算会自动提示为int，int赋值给byte可能损失精度\r\nint i3 = b1 + b2; // 应该使用int接收\r\nbyte b3 = (byte) (b1 + b2); // 或者将结果强制转换为byte类型\r\n-------------------------------\r\nint num1 = 10;\r\ndouble num2 = 20.0;\r\ndouble num3 = num1 + num2; // 使用double接收，因为num1会自动提升为double类型\r\n~~~\r\n\r\n#### 2.1.4 字符串的“+”操作（理解）\r\n\r\n当“+”操作中出现字符串时，这个”+”是字符串连接符，而不是算术运算。\r\n\r\n~~~java\r\nSystem.out.println("itheima"+ 666); // 输出：itheima666\r\n~~~\r\n\r\n在”+”操作中，如果出现了字符串，就是连接运算符，否则就是算术运算。当连续进行“+”操作时，从左到右逐个执行。\r\n\r\n~~~java\r\nSystem.out.println(1 + 99 + "年黑马");            // 输出：100年黑马\r\nSystem.out.println(1 + 2 + "itheima" + 3 + 4);   // 输出：3itheima34\r\n// 可以使用小括号改变运算的优先级 \r\nSystem.out.println(1 + 2 + "itheima" + (3 + 4)); // 输出：3itheima7\r\n~~~\r\n\r\n#### 2.1.5 数值拆分（应用）\r\n\r\n需求：\r\n\r\n​\t键盘录入一个三位数，将其拆分为个位，十位，百位，打印在控制台\r\n\r\n示例代码：\r\n\r\n```java\r\nimport java.util.Scanner;\r\npublic class Test {\r\n\tpublic static void main(String[] args) {\r\n\t\t// 1：使用Scanner键盘录入一个三位数\r\n\t\tScanner sc = new Scanner(System.in);\r\n\t\tSystem.out.println("请输入一个三位数");\r\n\t\tint num = sc.nextInt();\r\n\t\t// 2：个位的计算：数值 % 10\r\n\t\tint ge = num % 10;\t\t\r\n\t\t// 3：十位的计算：数值 / 10 % 10\r\n\t\tint shi = num / 10 % 10;\t\r\n\t\t// 4：百位的计算：数值 / 100\r\n\t\tint bai = num / 100;\r\n\t\t// 5：将个位, 十位, 百位拼接上正确的字符串, 打印即可\r\n\t\tSystem.out.println("整数"+num+"个位为:" + ge);\r\n\t\tSystem.out.println("整数"+num+"十位为:" + shi);\r\n\t\tSystem.out.println("整数"+num+"百位为:" + bai);\r\n\t\t\r\n\t}\r\n}\r\n```\r\n\r\n### 2.2 自增自减运算符（理解）\r\n\r\n| 符号 | 作用 | 说明        |\r\n| ---- | ---- | ----------- |\r\n| ++   | 自增 | 变量的值加1 |\r\n| --   | 自减 | 变量的值减1 |\r\n\r\n注意事项：\r\n\r\n​\t++和-- 既可以放在变量的后边，也可以放在变量的前边。\r\n\r\n​\t单独使用的时候， ++和-- 无论是放在变量的前边还是后边，结果是一样的。\r\n\r\n​\t参与操作的时候，如果放在变量的后边，先拿变量参与操作，后拿变量做++或者--。\r\n\r\n​\t参与操作的时候，如果放在变量的前边，先拿变量做++或者--，后拿变量参与操作。\r\n\r\n​\t最常见的用法：单独使用。\r\n\r\n```java\r\nint i = 10;\r\ni++; // 单独使用\r\nSystem.out.println("i:" + i); // i:11\r\n\r\nint j = 10;\r\n++j; // 单独使用\r\nSystem.out.println("j:" + j); // j:11\r\n\r\nint x = 10;\r\nint y = x++; // 赋值运算，++在后边，所以是使用x原来的值赋值给y，x本身自增1\r\nSystem.out.println("x:" + x + ", y:" + y); // x:11，y:10\r\n\r\nint m = 10;\r\nint n = ++m; // 赋值运算，++在前边，所以是使用m自增后的值赋值给n，m本身自增1\r\nSystem.out.println("m:" + m + ", m:" + m); // m:11，m:11\r\n```\r\n\r\n练习：\r\n\r\n```java\r\nint x = 10;\r\nint y = x++ + x++ + x++;\r\nSystem.out.println(y); // y的值是多少？\r\n/*\r\n解析，三个表达式都是++在后，所以每次使用的都是自增前的值，但程序自左至右执行，所以第一次自增时，使用的是10进行计算，但第二次自增时，x的值已经自增到11了，所以第二次使用的是11，然后再次自增。。。\r\n所以整个式子应该是：int y = 10 + 11 + 12;\r\n输出结果为33。\r\n*/\r\n注意：通过此练习深刻理解自增和自减的规律，但实际开发中强烈建议不要写这样的代码！小心挨打！\r\n```\r\n\r\n### 2.3 赋值运算符（应用）\r\n\r\n赋值运算符的作用是将一个表达式的值赋给左边，左边必须是可修改的，不能是常量。\r\n\r\n| 符号 | 作用       | 说明                  |\r\n| ---- | ---------- | --------------------- |\r\n| =    | 赋值       | a=10，将10赋值给变量a |\r\n| +=   | 加后赋值   | a+=b，将a+b的值给a    |\r\n| -=   | 减后赋值   | a-=b，将a-b的值给a    |\r\n| *=   | 乘后赋值   | a*=b，将a×b的值给a    |\r\n| /=   | 除后赋值   | a/=b，将a÷b的商给a    |\r\n| %=   | 取余后赋值 | a%=b，将a÷b的余数给a  |\r\n\r\n注意：\r\n\r\n扩展的赋值运算符隐含了强制类型转换。\r\n\r\n~~~java\r\nshort s = 10;\r\ns = s + 10; // 此行代码报出，因为运算中s提升为int类型，运算结果int赋值给short可能损失精度\r\n\r\ns += 10; // 此行代码没有问题，隐含了强制类型转换，相当于 s = (short) (s + 10);\r\n~~~\r\n\r\n### 2.4 关系运算符（应用）\r\n\r\n关系运算符有6种关系，分别为小于、小于等于、大于、等于、大于等于、不等于。\r\n\r\n| 符号 | 说明                                                    |\r\n| ---- | ------------------------------------------------------- |\r\n| ==   | a==b，判断a和b的值是否相等，成立为true，不成立为false   |\r\n| !=   | a!=b，判断a和b的值是否不相等，成立为true，不成立为false |\r\n| >    | a>b，判断a是否大于b，成立为true，不成立为false          |\r\n| >=   | a>=b，判断a是否大于等于b，成立为true，不成立为false     |\r\n| <    | a<b，判断a是否小于b，成立为true，不成立为false          |\r\n| <=   | a<=b，判断a是否小于等于b，成立为true，不成立为false     |\r\n\r\n注意事项：\r\n\r\n​\t关系运算符的结果都是boolean类型，要么是true，要么是false。\r\n\r\n​\t千万不要把“==”误写成“=”，"=="是判断是否相等的关系，"="是赋值。\r\n\r\n~~~java\r\nint a = 10;\r\nint b = 20;\r\nSystem.out.println(a == b); // false\r\nSystem.out.println(a != b); // true\r\nSystem.out.println(a > b); // false\r\nSystem.out.println(a >= b); // false\r\nSystem.out.println(a < b); // true\r\nSystem.out.println(a <= b); // true\r\n\r\n// 关系运算的结果肯定是boolean类型，所以也可以将运算结果赋值给boolean类型的变量\r\nboolean flag = a > b;\r\nSystem.out.println(flag); // 输出false\r\n~~~\r\n\r\n### 2.5 逻辑运算符（应用）\r\n\r\n逻辑运算符把各个运算的关系表达式连接起来组成一个复杂的逻辑表达式，以判断程序中的表达式是否成立，判断的结果是 true 或 false。\r\n\r\n| 符号 | 作用     | 说明                                         |\r\n| ---- | -------- | -------------------------------------------- |\r\n| &    | 逻辑与   | a&b，a和b都是true，结果为true，否则为false   |\r\n| \\|   | 逻辑或   | a\\|b，a和b都是false，结果为false，否则为true |\r\n| ^    | 逻辑异或 | a^b，a和b结果不同为true，相同为false         |\r\n| !    | 逻辑非   | !a，结果和a的结果正好相反                    |\r\n\r\n~~~java\r\n//定义变量\r\nint i = 10;\r\nint j = 20;\r\nint k = 30;\r\n\r\n//& “与”，并且的关系，只要表达式中有一个值为false，结果即为false\r\nSystem.out.println((i > j) & (i > k)); //false & false,输出false\r\nSystem.out.println((i < j) & (i > k)); //true & false,输出false\r\nSystem.out.println((i > j) & (i < k)); //false & true,输出false\r\nSystem.out.println((i < j) & (i < k)); //true & true,输出true\r\nSystem.out.println("--------");\r\n\r\n//| “或”，或者的关系，只要表达式中有一个值为true，结果即为true\r\nSystem.out.println((i > j) | (i > k)); //false | false,输出false\r\nSystem.out.println((i < j) | (i > k)); //true | false,输出true\r\nSystem.out.println((i > j) | (i < k)); //false | true,输出true\r\nSystem.out.println((i < j) | (i < k)); //true | true,输出true\r\nSystem.out.println("--------");\r\n\r\n//^ “异或”，相同为false，不同为true\r\nSystem.out.println((i > j) ^ (i > k)); //false ^ false,输出false\r\nSystem.out.println((i < j) ^ (i > k)); //true ^ false,输出true\r\nSystem.out.println((i > j) ^ (i < k)); //false ^ true,输出true\r\nSystem.out.println((i < j) ^ (i < k)); //true ^ true,输出false\r\nSystem.out.println("--------");\r\n\r\n//! “非”，取反\r\nSystem.out.println((i > j)); //false\r\nSystem.out.println(!(i > j)); //!false，,输出true\r\n~~~\r\n\r\n### 2.6 短路逻辑运算符（理解）\r\n\r\n| 符号 | 作用   | 说明                         |\r\n| ---- | ------ | ---------------------------- |\r\n| &&   | 短路与 | 作用和&相同，但是有短路效果  |\r\n| \\|\\| | 短路或 | 作用和\\|相同，但是有短路效果 |\r\n\r\n在逻辑与运算中，只要有一个表达式的值为false，那么结果就可以判定为false了，没有必要将所有表达式的值都计算出来，短路与操作就有这样的效果，可以提高效率。同理在逻辑或运算中，一旦发现值为true，右边的表达式将不再参与运算。\r\n\r\n- 逻辑与&，无论左边真假，右边都要执行。\r\n\r\n- 短路与&&，如果左边为真，右边执行；如果左边为假，右边不执行。\r\n\r\n- 逻辑或|，无论左边真假，右边都要执行。\r\n\r\n- 短路或||，如果左边为假，右边执行；如果左边为真，右边不执行。\r\n\r\n~~~java\r\nint x = 3;\r\nint y = 4;\r\nSystem.out.println((x++ > 4) & (y++ > 5)); // 两个表达都会运算\r\nSystem.out.println(x); // 4\r\nSystem.out.println(y); // 5\r\n\r\nSystem.out.println((x++ > 4) && (y++ > 5)); // 左边已经可以确定结果为false，右边不参与运算\r\nSystem.out.println(x); // 4\r\nSystem.out.println(y); // 4\r\n~~~\r\n\r\n### 2.7 三元运算符（理解）\r\n\r\n三元运算符语法格式：\r\n\r\n~~~java\r\n关系表达式 ? 表达式1 : 表达式2;\r\n~~~\r\n\r\n解释：问号前面的位置是判断的条件，判断结果为boolean型，为true时调用表达式1，为false时调用表达式2。其逻辑为：如果条件表达式成立或者满足则执行表达式1，否则执行第二个。\r\n\r\n举例：\r\n\r\n~~~java\r\nint a = 10;\r\nint b = 20;\r\nint c = a > b ? a : b; // 判断 a>b 是否为真，如果为真取a的值，如果为假，取b的值\r\n~~~\r\n\r\n### 2.8 三元运算符案例(应用)\r\n\r\n需求：\r\n\r\n​\t一座寺庙里住着三个和尚，已知他们的身高分别为150cm、210cm、165cm，请用程序实现获取这三个和尚的最高身高。\r\n\r\n~~~java\r\npublic class OperatorTest02 {\r\n\tpublic static void main(String[] args) {\r\n\t\t//1：定义三个变量用于保存和尚的身高，单位为cm，这里仅仅体现数值即可。\r\n\t\tint height1 = 150;\r\n\t\tint height2 = 210;\r\n\t\tint height3 = 165;\t\r\n\t\t//2：用三元运算符获取前两个和尚的较高身高值，并用临时身高变量保存起来。\r\n\t\tint tempHeight = height1 > height2 ? height1 : height2;\t\t\r\n\t\t//3：用三元运算符获取临时身高值和第三个和尚身高较高值，并用最大身高变量保存。\r\n\t\tint maxHeight = tempHeight > height3 ? tempHeight : height3;\t\r\n\t\t//4：输出结果\r\n\t\tSystem.out.println("maxHeight:" + maxHeight);\r\n\t}\r\n}\r\n~~~\r\n\r\n## 3. 流程控制语句\r\n\r\n在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。所以，我们必须清楚每条语句的执行流程。而且，很多时候要通过控制语句的执行顺序来实现我们想要的功能。\r\n\r\n### 3.1 流程控制语句分类(了解)\r\n\r\n​\t顺序结构\r\n\r\n​\t分支结构(if, switch)\r\n\r\n​\t循环结构(for, while, do…while)\r\n\r\n### 3.2 顺序结构(了解)\r\n\r\n顺序结构是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。\r\n\r\n顺序结构执行流程图：\r\n\r\n![1545615769372](./day02-Java基础语法.img/图片2.png)\r\n\r\n### 3.3 分支结构之if语句\r\n\r\n#### 3.3.1 if语句格式1（理解）\r\n\r\n~~~java\r\n格式：\r\nif (关系表达式) {\r\n    语句体;\t\r\n}\r\n~~~\r\n\r\n执行流程：\r\n\r\n①首先计算关系表达式的值\r\n\r\n②如果关系表达式的值为true就执行语句体\r\n\r\n③如果关系表达式的值为false就不执行语句体\r\n\r\n④继续执行后面的语句内容\r\n\r\n![1545616039363](./day02-Java基础语法.img/图片3.png)\r\n\r\n示例：\r\n\r\n~~~java\r\npublic class IfDemo {\r\n\tpublic static void main(String[] args) {\r\n\t\tSystem.out.println("开始");\r\n        \r\n\t\t// 如果年龄大于18岁, 就可以上网吧\r\n\t\tint age = 17;\r\n\t\t\r\n\t\tif(age >= 18){\r\n\t\t\t// int a = 10;\r\n\t\t\tSystem.out.println("可以上网吧");\r\n\t\t}\r\n\t\t\t\r\n\t\tSystem.out.println("结束");\r\n\t}\r\n}\r\n~~~\r\n\r\n#### 3.3.2 if语句格式2（理解）\r\n\r\n~~~java\r\n格式：\r\nif (关系表达式) {\r\n    语句体1;\t\r\n} else {\r\n    语句体2;\t\r\n}\r\n~~~\r\n\r\n执行流程：\r\n\r\n①首先计算关系表达式的值\r\n\r\n②如果关系表达式的值为true就执行语句体1\r\n\r\n③如果关系表达式的值为false就执行语句体2\r\n\r\n④继续执行后面的语句内容\r\n\r\n![1545616221283](./day02-Java基础语法.img/图片4.png)\r\n\r\n示例：奇偶数\r\n\r\n​\t任意给出一个整数，请用程序实现判断该整数是奇数还是偶数，并在控制台输出该整数是奇数还是偶数。\r\n\r\n~~~java\r\npublic class Demo2If {\r\n\tpublic static void main(String[] args) {\r\n\t\t// 程序判断一个数, 是奇数还是偶数\r\n\t\tint num = 9;\r\n\t\t\r\n\t\tif(num % 2 == 0){\r\n\t\t\tSystem.out.println("偶数");\r\n\t\t}else{\r\n\t\t\tSystem.out.println("奇数");\r\n\t\t}\r\n\t}\r\n}\r\n~~~\r\n\r\n#### 3.3.3 if语句格式3（理解）\r\n\r\n~~~java\r\n格式：\r\nif (关系表达式1) {\r\n    语句体1;\t\r\n} else if (关系表达式2) {\r\n    语句体2;\t\r\n} \r\n…\r\nelse {\r\n    语句体n+1;\r\n}\r\n~~~\r\n\r\n执行流程：\r\n\r\n①首先计算关系表达式1的值\r\n\r\n②如果值为true就执行语句体1；如果值为false就计算关系表达式2的值\r\n\r\n③如果值为true就执行语句体2；如果值为false就计算关系表达式3的值\r\n\r\n④…\r\n\r\n⑤如果没有任何关系表达式为true，就执行语句体n+1。\r\n\r\n![1545616667104](./day02-Java基础语法.img/图片5.png)\r\n\r\n示例：\r\n\r\n​\t定义一个在0~100之间的变量a, 90~100优秀，80~89良好，70~79中等，60~69及格，0~59请努力加油！\r\n\r\n~~~java\r\npublic class Demo3If {\r\n\tpublic static void main(String[] args){\r\n\t\tint score = 65;\r\n\t\tif(score >= 90 && score <= 100){\r\n\t\t\tSystem.out.println("优秀");\r\n\t\t}else if (score >= 80 && score <= 89){\r\n\t\t\tSystem.out.println("良好");\r\n\t\t}else if (score >= 70 && score <= 79){\r\n\t\t\tSystem.out.println("中等");\r\n\t\t}else if (score >= 60 && score <= 69){\r\n\t\t\tSystem.out.println("及格");\r\n\t\t}else if (score >= 0 && score <= 59){\r\n\t\t\tSystem.out.println("请努力加油");\r\n\t\t}else{\r\n\t\t\tSystem.out.println("成绩有误!");\r\n\t\t}\r\n\t}\r\n}\r\n~~~\r\n\r\n#### 3.3.4 if语句格式3案例（应用）\r\n\r\n需求：小明快要期末考试了，小明爸爸对他说，会根据他不同的考试成绩，送他不同的礼物，假如你可以控制小明的得分，请用程序实现小明到底该获得什么样的礼物，并在控制台输出。\r\n\r\n分析：\r\n\r\n​\t①小明的考试成绩未知，可以使用键盘录入的方式获取值\r\n\r\n​\t②由于奖励种类较多，属于多种判断，采用if...else...if格式实现\r\n\r\n​\t③为每种判断设置对应的条件\r\n\r\n​\t④为每种判断设置对应的奖励\r\n\r\n~~~java\r\nimport java.util.Scanner;\r\npublic class IfTest02 {\r\n\tpublic static void main(String[] args){\r\n\t\t// 1. 使用Scanner录入考试成绩\r\n\t\tScanner sc = new Scanner(System.in);\r\n\t\tSystem.out.println("请输入您的成绩:");\r\n\t\tint score = sc.nextInt();\r\n\t\t// 2. 判断成绩是否在合法范围内 0~100\r\n\t\tif(score >=0 && score <= 100){\r\n\t\t\t// 合法成绩\r\n\t\t\t// 3. 在合法的语句块中判断成绩范围符合哪一个奖励\r\n\t\t\tif(score >= 95 && score <= 100){\r\n\t\t\t\tSystem.out.println("自行车一辆");\r\n\t\t\t}else if(score >= 90 && score <= 94){\r\n\t\t\t\tSystem.out.println("游乐场一次");\r\n\t\t\t}else if(score >= 80 && score <= 89){\r\n\t\t\t\tSystem.out.println("变形金刚一个");\r\n\t\t\t}else {\r\n\t\t\t\tSystem.out.println("挨顿揍, 这座城市又多了一个伤心的人~");\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\t// 非法的话, 给出错误提示\r\n\t\t\tSystem.out.println("您的成绩输入有误!");\r\n\t\t}\r\n\t}\r\n}\r\n~~~'},9390:function(n,e,t){"use strict";t.r(e),e["default"]='## 1.Set集合\n\n### 1.1Set集合概述和特点【应用】\n\n+ 不可以存储重复元素\n+ 没有索引,不能使用普通for循环遍历\n\n### 1.2Set集合的使用【应用】\n\n存储字符串并遍历\n\n```java\npublic class MySet1 {\n    public static void main(String[] args) {\n      \t//创建集合对象\n        Set<String> set = new TreeSet<>();\n      \t//添加元素\n        set.add("ccc");\n        set.add("aaa");\n        set.add("aaa");\n        set.add("bbb");\n\n//        for (int i = 0; i < set.size(); i++) {\n//            //Set集合是没有索引的，所以不能使用通过索引获取元素的方法\n//        }\n      \n      \t//遍历集合\n        Iterator<String> it = set.iterator();\n        while (it.hasNext()){\n            String s = it.next();\n            System.out.println(s);\n        }\n        System.out.println("-----------------------------------");\n        for (String s : set) {\n            System.out.println(s);\n        }\n    }\n}\n```\n\n## 2.TreeSet集合\n\n### 2.1TreeSet集合概述和特点【应用】\n\n+ 不可以存储重复元素\n+ 没有索引\n+ 可以将元素按照规则进行排序\n  + TreeSet()：根据其元素的自然排序进行排序\n  + TreeSet(Comparator comparator) ：根据指定的比较器进行排序\n\n### 2.2TreeSet集合基本使用【应用】\n\n存储Integer类型的整数并遍历\n\n```java\npublic class TreeSetDemo01 {\n    public static void main(String[] args) {\n        //创建集合对象\n        TreeSet<Integer> ts = new TreeSet<Integer>();\n\n        //添加元素\n        ts.add(10);\n        ts.add(40);\n        ts.add(30);\n        ts.add(50);\n        ts.add(20);\n\n        ts.add(30);\n\n        //遍历集合\n        for(Integer i : ts) {\n            System.out.println(i);\n        }\n    }\n}\n```\n\n### 2.3自然排序Comparable的使用【应用】\n\n- 案例需求\n\n  - 存储学生对象并遍历，创建TreeSet集合使用无参构造方法\n  - 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序\n\n- 实现步骤\n\n  1. 使用空参构造创建TreeSet集合\n     + 用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的\n  2. 自定义的Student类实现Comparable接口\n     + 自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(T o)方法\n  3. 重写接口中的compareTo方法\n     + 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写\n\n- 代码实现\n\n  学生类\n\n  ```java\n  public class Student implements Comparable<Student>{\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public String toString() {\n          return "Student{" +\n                  "name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n\n      @Override\n      public int compareTo(Student o) {\n          //按照对象的年龄进行排序\n          //主要判断条件: 按照年龄从小到大排序\n          int result = this.age - o.age;\n          //次要判断条件: 年龄相同时，按照姓名的字母顺序排序\n          result = result == 0 ? this.name.compareTo(o.getName()) : result;\n          return result;\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class MyTreeSet2 {\n      public static void main(String[] args) {\n          //创建集合对象\n          TreeSet<Student> ts = new TreeSet<>();\n  \t    //创建学生对象\n          Student s1 = new Student("zhangsan",28);\n          Student s2 = new Student("lisi",27);\n          Student s3 = new Student("wangwu",29);\n          Student s4 = new Student("zhaoliu",28);\n          Student s5 = new Student("qianqi",30);\n  \t\t//把学生添加到集合\n          ts.add(s1);\n          ts.add(s2);\n          ts.add(s3);\n          ts.add(s4);\n          ts.add(s5);\n  \t\t//遍历集合\n          for (Student student : ts) {\n              System.out.println(student);\n          }\n      }\n  }\n  ```\n\n### 2.4比较器排序Comparator的使用【应用】\n\n- 案例需求\n\n  - 存储老师对象并遍历，创建TreeSet集合使用带参构造方法\n  - 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序\n\n- 实现步骤\n\n  - 用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的\n  - 比较器排序，就是让集合构造方法接收Comparator的实现类对象，重写compare(T o1,T o2)方法\n  - 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写\n\n- 代码实现\n\n  老师类\n\n  ```java\n  public class Teacher {\n      private String name;\n      private int age;\n\n      public Teacher() {\n      }\n\n      public Teacher(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public String toString() {\n          return "Teacher{" +\n                  "name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class MyTreeSet4 {\n      public static void main(String[] args) {\n        \t//创建集合对象\n          TreeSet<Teacher> ts = new TreeSet<>(new Comparator<Teacher>() {\n              @Override\n              public int compare(Teacher o1, Teacher o2) {\n                  //o1表示现在要存入的那个元素\n                  //o2表示已经存入到集合中的元素\n                \n                  //主要条件\n                  int result = o1.getAge() - o2.getAge();\n                  //次要条件\n                  result = result == 0 ? o1.getName().compareTo(o2.getName()) : result;\n                  return result;\n              }\n          });\n  \t\t//创建老师对象\n          Teacher t1 = new Teacher("zhangsan",23);\n          Teacher t2 = new Teacher("lisi",22);\n          Teacher t3 = new Teacher("wangwu",24);\n          Teacher t4 = new Teacher("zhaoliu",24);\n  \t\t//把老师添加到集合\n          ts.add(t1);\n          ts.add(t2);\n          ts.add(t3);\n          ts.add(t4);\n  \t\t//遍历集合\n          for (Teacher teacher : ts) {\n              System.out.println(teacher);\n          }\n      }\n  }\n  ```\n\n### 2.4两种比较方式总结【理解】\n\n+ 两种比较方式小结\n  + 自然排序: 自定义类实现Comparable接口,重写compareTo方法,根据返回值进行排序\n  + 比较器排序: 创建TreeSet对象的时候传递Comparator的实现类对象,重写compare方法,根据返回值进行排序\n  + 在使用的时候,默认使用自然排序,当自然排序不满足现在的需求时,必须使用比较器排序\n+ 两种方式中关于返回值的规则\n  + 如果返回值为负数，表示当前存入的元素是较小值，存左边\n  + 如果返回值为0，表示当前存入的元素跟集合中元素重复了，不存\n  + 如果返回值为正数，表示当前存入的元素是较大值，存右边\n\n## 3.数据结构\n\n### 3.1二叉树【理解】\n\n+ 二叉树的特点\n\n  + 二叉树中,任意一个节点的度要小于等于2\n    + 节点: 在树结构中,每一个元素称之为节点\n    + 度: 每一个节点的子节点数量称之为度\n\n+ 二叉树结构图\n\n  ![01_二叉树结构图](./day17-集合02.img/01_二叉树结构图.png)\n\n### 3.2二叉查找树【理解】\n\n+ 二叉查找树的特点\n\n  + 二叉查找树,又称二叉排序树或者二叉搜索树\n  + 每一个节点上最多有两个子节点\n  + 左子树上所有节点的值都小于根节点的值\n  + 右子树上所有节点的值都大于根节点的值\n\n+ 二叉查找树结构图\n\n  ![02_二叉查找树结构图](./day17-集合02.img/02_二叉查找树结构图.png)\n\n+ 二叉查找树和二叉树对比结构图\n\n  ![03_二叉查找树和二叉树对比结构图](./day17-集合02.img/03_二叉查找树和二叉树对比结构图.png)\n\n+ 二叉查找树添加节点规则\n\n  + 小的存左边\n  + 大的存右边\n  + 一样的不存\n\n  ![04_二叉查找树添加节点规则](./day17-集合02.img/04_二叉查找树添加节点规则.png)\n\n### 3.3平衡二叉树【理解】\n\n+ 平衡二叉树的特点\n\n  + 二叉树左右两个子树的高度差不超过1\n  + 任意节点的左右两个子树都是一颗平衡二叉树\n\n+ 平衡二叉树旋转\n\n  + 旋转触发时机\n\n    + 当添加一个节点之后,该树不再是一颗平衡二叉树\n\n  + 左旋\n\n    + 就是将根节点的右侧往左拉,原先的右子节点变成新的父节点,并把多余的左子节点出让,给已经降级的根节点当右子节点\n\n    ![05_平衡二叉树左旋01](./day17-集合02.img/05_平衡二叉树左旋01.png)\n\n    ![05_平衡二叉树左旋02](./day17-集合02.img/05_平衡二叉树左旋02.png)\n\n  + 右旋\n\n    + 就是将根节点的左侧往右拉,左子节点变成了新的父节点,并把多余的右子节点出让,给已经降级根节点当左子节点\n\n      ![06_平衡二叉树右旋01](./day17-集合02.img/06_平衡二叉树右旋01.png)\n\n      ![06_平衡二叉树右旋02](./day17-集合02.img/06_平衡二叉树右旋02.png)\n\n+ 平衡二叉树和二叉查找树对比结构图\n\n  ![07_平衡二叉树和二叉查找树对比结构图](./day17-集合02.img/07_平衡二叉树和二叉查找树对比结构图.png)\n\n+ 平衡二叉树旋转的四种情况\n\n  + 左左\n\n    + 左左: 当根节点左子树的左子树有节点插入,导致二叉树不平衡\n\n    + 如何旋转: 直接对整体进行右旋即可\n\n      ![08_平衡二叉树左左](./day17-集合02.img/08_平衡二叉树左左.png)\n\n  + 左右\n\n    + 左右: 当根节点左子树的右子树有节点插入,导致二叉树不平衡\n\n    + 如何旋转: 先在左子树对应的节点位置进行左旋,在对整体进行右旋\n\n      ![09_平衡二叉树左右](./day17-集合02.img/09_平衡二叉树左右.png)\n\n  + 右右\n\n    + 右右: 当根节点右子树的右子树有节点插入,导致二叉树不平衡\n\n    + 如何旋转: 直接对整体进行左旋即可\n\n      ![10_平衡二叉树右右](./day17-集合02.img/10_平衡二叉树右右.png)\n\n  + 右左\n\n    + 右左:当根节点右子树的左子树有节点插入,导致二叉树不平衡\n\n    + 如何旋转: 先在右子树对应的节点位置进行右旋,在对整体进行左旋\n\n      ![11_平衡二叉树右左](./day17-集合02.img/11_平衡二叉树右左.png)\n\n### 3.4红黑树【理解】\n\n+ 红黑树的特点\n\n  + 平衡二叉B树\n  + 每一个节点可以是红或者黑\n  + 红黑树不是高度平衡的,它的平衡是通过"自己的红黑规则"进行实现的\n\n+ 红黑树的红黑规则有哪些\n\n  1. 每一个节点或是红色的,或者是黑色的\n\n  2. 根节点必须是黑色\n\n  3. 如果一个节点没有子节点或者父节点,则该节点相应的指针属性值为Nil,这些Nil视为叶节点,每个叶节点(Nil)是黑色的\n\n  4. 如果某一个节点是红色,那么它的子节点必须是黑色(不能出现两个红色节点相连 的情况)\n\n  5. 对每一个节点,从该节点到其所有后代叶节点的简单路径上,均包含相同数目的黑色节点\n\n     ![12_红黑树结构图](./day17-集合02.img/12_红黑树结构图.png)\n\n+ 红黑树添加节点的默认颜色\n\n  + 添加节点时,默认为红色,效率高\n\n    ![13_红黑树添加节点颜色](./day17-集合02.img/13_红黑树添加节点颜色.png)\n\n+ 红黑树添加节点后如何保持红黑规则\n\n  + 根节点位置\n    + 直接变为黑色\n  + 非根节点位置\n    + 父节点为黑色\n      + 不需要任何操作,默认红色即可\n    + 父节点为红色\n      + 叔叔节点为红色\n        1. 将"父节点"设为黑色,将"叔叔节点"设为黑色\n        2. 将"祖父节点"设为红色\n        3. 如果"祖父节点"为根节点,则将根节点再次变成黑色\n      + 叔叔节点为黑色\n        1. 将"父节点"设为黑色\n        2. 将"祖父节点"设为红色\n        3. 以"祖父节点"为支点进行旋转\n\n### 3.5成绩排序案例【应用】\n\n- 案例需求\n\n  - 用TreeSet集合存储多个学生信息(姓名,语文成绩,数学成绩,英语成绩),并遍历该集合\n  - 要求: 按照总分从高到低出现\n\n- 代码实现\n\n  学生类\n\n  ```java\n  public class Student implements Comparable<Student> {\n      private String name;\n      private int chinese;\n      private int math;\n      private int english;\n\n      public Student() {\n      }\n\n      public Student(String name, int chinese, int math, int english) {\n          this.name = name;\n          this.chinese = chinese;\n          this.math = math;\n          this.english = english;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getChinese() {\n          return chinese;\n      }\n\n      public void setChinese(int chinese) {\n          this.chinese = chinese;\n      }\n\n      public int getMath() {\n          return math;\n      }\n\n      public void setMath(int math) {\n          this.math = math;\n      }\n\n      public int getEnglish() {\n          return english;\n      }\n\n      public void setEnglish(int english) {\n          this.english = english;\n      }\n\n      public int getSum() {\n          return this.chinese + this.math + this.english;\n      }\n\n      @Override\n      public int compareTo(Student o) {\n          // 主要条件: 按照总分进行排序\n          int result = o.getSum() - this.getSum();\n          // 次要条件: 如果总分一样,就按照语文成绩排序\n          result = result == 0 ? o.getChinese() - this.getChinese() : result;\n          // 如果语文成绩也一样,就按照数学成绩排序\n          result = result == 0 ? o.getMath() - this.getMath() : result;\n          // 如果总分一样,各科成绩也都一样,就按照姓名排序\n          result = result == 0 ? o.getName().compareTo(this.getName()) : result;\n          return result;\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class TreeSetDemo {\n      public static void main(String[] args) {\n          //创建TreeSet集合对象，通过比较器排序进行排序\n          TreeSet<Student> ts = new TreeSet<Student>();\n          //创建学生对象\n          Student s1 = new Student("jack", 98, 100, 95);\n          Student s2 = new Student("rose", 95, 95, 95);\n          Student s3 = new Student("sam", 100, 93, 98);\n          //把学生对象添加到集合\n          ts.add(s1);\n          ts.add(s2);\n          ts.add(s3);\n\n          //遍历集合\n          for (Student s : ts) {\n              System.out.println(s.getName() + "," + s.getChinese() + "," + s.getMath() + "," + s.getEnglish() + "," + s.getSum());\n          }\n      }\n  }\n  ```\n\n## 4.HashSet集合\n\n### 4.1HashSet集合概述和特点【应用】\n\n+ 底层数据结构是哈希表\n+ 存取无序\n+ 不可以存储重复元素\n+ 没有索引,不能使用普通for循环遍历\n\n### 4.2HashSet集合的基本应用【应用】\n\n存储字符串并遍历\n\n```java\npublic class HashSetDemo {\n    public static void main(String[] args) {\n        //创建集合对象\n        HashSet<String> set = new HashSet<String>();\n\n        //添加元素\n        set.add("hello");\n        set.add("world");\n        set.add("java");\n        //不包含重复元素的集合\n        set.add("world");\n\n        //遍历\n        for(String s : set) {\n            System.out.println(s);\n        }\n    }\n}\n```\n\n### 4.3哈希值【理解】\n\n- 哈希值简介\n\n  ​\t是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值\n\n- 如何获取哈希值\n\n  ​\tObject类中的public int hashCode()：返回对象的哈希码值\n\n- 哈希值的特点\n\n  - 同一个对象多次调用hashCode()方法返回的哈希值是相同的\n  - 默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同\n\n### 4.4哈希表结构【理解】\n\n+ JDK1.8以前\n\n  ​\t数组 + 链表\n\n  ![14_JKD8以前哈希表](./day17-集合02.img/14_JKD8以前哈希表.png)\n\n+ JDK1.8以后\n\n  + 节点个数少于等于8个\n\n    ​\t数组 + 链表\n\n  + 节点个数多于8个\n\n    ​\t数组 + 红黑树\n\n  ![15_JKD8以后哈希表](./day17-集合02.img/15_JKD8以后哈希表.png)\n\n### 4.5HashSet集合存储学生对象并遍历【应用】\n\n- 案例需求\n\n  - 创建一个存储学生对象的集合，存储多个学生对象，使用程序实现在控制台遍历该集合\n  - 要求：学生对象的成员变量值相同，我们就认为是同一个对象\n\n- 代码实现\n\n  学生类\n\n  ```java\n  public class Student {\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public boolean equals(Object o) {\n          if (this == o) return true;\n          if (o == null || getClass() != o.getClass()) return false;\n\n          Student student = (Student) o;\n\n          if (age != student.age) return false;\n          return name != null ? name.equals(student.name) : student.name == null;\n      }\n\n      @Override\n      public int hashCode() {\n          int result = name != null ? name.hashCode() : 0;\n          result = 31 * result + age;\n          return result;\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class HashSetDemo02 {\n      public static void main(String[] args) {\n          //创建HashSet集合对象\n          HashSet<Student> hs = new HashSet<Student>();\n\n          //创建学生对象\n          Student s1 = new Student("林青霞", 30);\n          Student s2 = new Student("张曼玉", 35);\n          Student s3 = new Student("王祖贤", 33);\n\n          Student s4 = new Student("王祖贤", 33);\n\n          //把学生添加到集合\n          hs.add(s1);\n          hs.add(s2);\n          hs.add(s3);\n          hs.add(s4);\n\n          //遍历集合(增强for)\n          for (Student s : hs) {\n              System.out.println(s.getName() + "," + s.getAge());\n          }\n      }\n  }\n  ```\n\n- 总结\n\n  ​\tHashSet集合存储自定义类型元素,要想实现元素的唯一,要求必须重写hashCode方法和equals方法'},9440:function(n,e,t){"use strict";t.r(e),e["default"]='\x3c!--\n * @Date           : 2021-04-14 00:53:12\n * @FilePath       : /jinnian-space/src/pages/java/module/mybatis/md/mybatis-第1天讲义.md\n * @Description    : \n--\x3e\n## Mybatis 基础\n\n\n\n### 一.Mybatis快速入门\n\n#### 1.1 框架介绍\n\n* 框架是一款半成品软件，我们可以基于这个半成品软件继续开发，来完成我们个性化的需求！\n\n* 如图:\n\n  ![1590919723185](./mybatis-第1天讲义.img/1590919723185.png)\n\n​ \n\n#### 1.2 ORM介绍\n\n* ORM(Object Relational Mapping)： 对象关系映射\n\n* 指的是持久化数据和实体对象的映射模式，为了解决面向对象与关系型数据库存在的互不匹配的现象的技术。\n\n* 如图:\n\n  ![1590919786415](./mybatis-第1天讲义.img/1590919786415.png)\n\n* 具体映射关系如下图:\n\n![1590919824416](./mybatis-第1天讲义.img/1590919824416.png)\n\n#### 1.3 原始jdbc操作（查询数据）\n\n![1590915350408](./mybatis-第1天讲义.img/1590915350408.png)\n\n#### 1.4原始jdbc操作（插入数据）\n\n![1590915389449](./mybatis-第1天讲义.img/1590915389449.png)\n\n#### 1.5 原始jdbc操作的分析\n\n* 原始 JDBC 的操作问题分析 \n\n  ​    1.频繁创建和销毁数据库的连接会造成系统资源浪费从而影响系统性能。\n\n    2. sql 语句在代码中硬编码，如果要修改 sql 语句，就需要修改 java 代码，造成代码不易维护。\n    3. 查询操作时，需要手动将结果集中的数据封装到实体对象中。\n    4. 增删改查操作需要参数时，需要手动将实体对象的数据设置到 sql 语句的占位符。 \n\n* 原始 JDBC 的操作问题解决方案 \n\n  ​    1.使用数据库连接池初始化连接资源。 \n\n  2. 将 sql 语句抽取到配置文件中。 \n  3. 使用反射、内省等底层技术，将实体与表进行属性与字段的自动映射    \n\n#### 1.6 什么是Mybatis\n\nmybatis 是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。\n\nmybatis通过xml或注解的方式将要执行的各种 statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。\n\n最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc 进行了封装，屏蔽了jdbc api 底层访问细节，使我们不用与jdbc api 打交道，就可以完成对数据库的持久化操作。\n\nMyBatis官网地址：<http://www.mybatis.org/mybatis-3/> \n\n#### 1.7  Mybatis的快速入门\n\n**MyBatis开发步骤：**\n\n①添加MyBatis的jar包\n\n②创建Student数据表\n\n③编写Studentr实体类 \n\n④编写映射文件StudentMapper.xml\n\n⑤编写核心文件MyBatisConfig.xml\n\n⑥编写测试类\n\n##### 1.7.1  环境搭建\n\n1)导入MyBatis的jar包\n\n* mysql-connector-java-5.1.37-bin.jar\n* mybatis-3.5.3.jar\n* log4j-1.2.17.jar\n\n2)  创建student数据表\n\n![1590916243454](./mybatis-第1天讲义.img/1590916243454.png)\n\n3) 编写Student实体\n\n```java\npublic class Student {\n    private Integer id;\n    private String name;\n    private Integer age;\n    //省略get个set方法\n}\n```\n\n4)编写StudentMapper.xml映射文件\n\n```xml\n<?xml version="1.0" encoding="UTF-8" ?>\n\x3c!--MyBatis的DTD约束--\x3e\n<!DOCTYPE mapper\n        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n\n\x3c!--\n    mapper：核心根标签\n    namespace属性：名称空间\n--\x3e\n<mapper namespace="StudentMapper">\n    \x3c!--\n        select：查询功能的标签\n        id属性：唯一标识\n        resultType属性：指定结果映射对象类型\n        parameterType属性：指定参数映射对象类型\n    --\x3e\n    <select id="selectAll" resultType="student">\n        SELECT * FROM student\n    </select>\n\n    <select id="selectById" resultType="student" parameterType="int">\n        SELECT * FROM student WHERE id = #{id}\n    </select>\n\n    <insert id="insert" parameterType="student">\n        INSERT INTO student VALUES (#{id},#{name},#{age})\n    </insert>\n\n    <update id="update" parameterType="student">\n        UPDATE student SET name = #{name},age = #{age} WHERE id = #{id}\n    </update>\n\n    <delete id="delete" parameterType="int">\n        DELETE FROM student WHERE id = #{id}\n    </delete>\n</mapper>\n```\n\n5) 编写MyBatis核心文件\n\n```xml\n<?xml version="1.0" encoding="UTF-8" ?>\n\x3c!--MyBatis的DTD约束--\x3e\n<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">\n\n\x3c!--configuration 核心根标签--\x3e\n<configuration>\n\n    \x3c!--引入数据库连接的配置文件--\x3e\n    <properties resource="jdbc.properties"/>\n\n    \x3c!--配置LOG4J--\x3e\n    <settings>\n        <setting name="logImpl" value="log4j"/>\n    </settings>\n\n    \x3c!--起别名--\x3e\n    <typeAliases>\n        <typeAlias type="com.itheima.bean.Student" alias="student"/>\n        \x3c!--<package name="com.itheima.bean"/>--\x3e\n    </typeAliases>\n\n    \x3c!--environments配置数据库环境，环境可以有多个。default属性指定使用的是哪个--\x3e\n    <environments default="mysql">\n        \x3c!--environment配置数据库环境  id属性唯一标识--\x3e\n        <environment id="mysql">\n            \x3c!-- transactionManager事务管理。  type属性，采用JDBC默认的事务--\x3e\n            <transactionManager type="JDBC"></transactionManager>\n            \x3c!-- dataSource数据源信息   type属性 连接池--\x3e\n            <dataSource type="POOLED">\n                \x3c!-- property获取数据库连接的配置信息 --\x3e\n                <property name="driver" value="${driver}" />\n                <property name="url" value="${url}" />\n                <property name="username" value="${username}" />\n                <property name="password" value="${password}" />\n            </dataSource>\n        </environment>\n    </environments>\n\n    \x3c!-- mappers引入映射配置文件 --\x3e\n    <mappers>\n        \x3c!-- mapper 引入指定的映射配置文件   resource属性指定映射配置文件的名称 --\x3e\n        <mapper resource="StudentMapper.xml"/>\n    </mappers>\n</configuration>\n\n```\n##### 1.7.2编写dao代码\n```java\n\n    /*\n        查询全部\n     */\n    @Test\n    public void selectAll() throws Exception{\n        //1.加载核心配置文件\n        //InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n        InputStream is = StudentTest01.class.getClassLoader().getResourceAsStream("MyBatisConfig.xml");\n\n        //2.获取SqlSession工厂对象\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n\n        //3.通过SqlSession工厂对象获取SqlSession对象\n        SqlSession sqlSession = sqlSessionFactory.openSession();\n\n        //4.执行映射配置文件中的sql语句，并接收结果\n        List<Student> list = sqlSession.selectList("StudentMapper.selectAll");\n\n        //5.处理结果\n        for (Student stu : list) {\n            System.out.println(stu);\n        }\n\n        //6.释放资源\n        sqlSession.close();\n        is.close();\n    }\n/*\n        新增功能\n     */\n    @Test\n    public void insert() throws Exception{\n        //1.加载核心配置文件\n        InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");\n\n        //2.获取SqlSession工厂对象\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n\n        //3.通过工厂对象获取SqlSession对象\n        //SqlSession sqlSession = sqlSessionFactory.openSession();\n        SqlSession sqlSession = sqlSessionFactory.openSession(true);\n\n        //4.执行映射配置文件中的sql语句，并接收结果\n        Student stu = new Student(5,"周七",27);\n        int result = sqlSession.insert("StudentMapper.insert", stu);\n\n        //5.提交事务\n        //sqlSession.commit();\n\n        //6.处理结果\n        System.out.println(result);\n\n        //7.释放资源\n        sqlSession.close();\n        is.close();\n    }    \n\n```\n\n##### 1.7.3编写测试代码\n\n```java\n/*\n    控制层测试类\n */\npublic class StudentController {\n    //创建业务层对象\n    private StudentService service = new StudentServiceImpl();\n\n    //查询全部功能测试\n    @Test\n    public void selectAll() {\n        List<Student> students = service.selectAll();\n        for (Student stu : students) {\n            System.out.println(stu);\n        }\n    }\n}\n```\n\n#### 1.8 知识小结\n\n* 框架       \n\n   框架是一款半成品软件，我们可以基于框架继续开发，从而完成一些个性化的需求。\n\n* ORM        \n\n  对象关系映射，数据和实体对象的映射。\n\n* MyBatis       \n\n   是一个优秀的基于 Java 的持久层框架，它内部封装了 JDBC。\n\n  \n\n### 二. MyBatis的相关api\n\n#### 2.1 Resources\n\n* org.apache.ibatis.io.Resources：加载资源的工具类。\n\n* 核心方法\n\n  ![1590917572321](./mybatis-第1天讲义.img/1590917572321.png)\n\n#### 2.2 构建器SqlSessionFactoryBuilder\n\n* org.apache.ibatis.session.SqlSessionFactoryBuilder：获取 SqlSessionFactory 工厂对象的功能类\n\n* 核心方法\n\n  ![1590916852504](./mybatis-第1天讲义.img/1590916852504.png)\n\n* 通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象\n\n```java\nString resource = "org/mybatis/builder/mybatis-config.xml"; \nInputStream inputStream = Resources.getResourceAsStream(resource); \nSqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); \nSqlSessionFactory factory = builder.build(inputStream);\n```\n\n其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。\n\n#### 2.3 工厂对象SqlSessionFactory\n\n* org.apache.ibatis.session.SqlSessionFactory：获取 SqlSession 构建者对象的工厂接口。\n\n* 核心api\n\n  ![1590917006637](./mybatis-第1天讲义.img/1590917006637.png)\n\n\n\n#### 2.4 SqlSession会话对象\n\n* org.apache.ibatis.session.SqlSession：构建者对象接口。用于执行 SQL、管理事务、接口代理。\n\n* 核心api\n\n  ![1590917052849](./mybatis-第1天讲义.img/1590917052849.png)\n\nSqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。\n\n### 三.MyBatis 映射配置文件\n\n#### 3.1 映射配置文件介绍\n\n* 映射配置文件包含了数据和对象之间的映射关系以及要执行的 SQL 语句\n\n  ![1590917306615](./mybatis-第1天讲义.img/1590917306615.png)\n\n\n\n#### 3.2 查询功能\n\n*  select：查询功能标签。\n\n* 属性        \n\n   id：唯一标识， 配合名称空间使用。     \n\n   parameterType：指定参数映射的对象类型。       \n\n   resultType：指定结果映射的对象类型。\n\n* SQL 获取参数:        #{属性名}\n\n* 示例\n\n  ![1590917699865](./mybatis-第1天讲义.img/1590917699865.png)\n\n####3.3 新增功能 \n\n- insert：新增功能标签。\n\n- 属性        \n\n  id：唯一标识， 配合名称空间使用。     \n\n  parameterType：指定参数映射的对象类型。       \n\n  resultType：指定结果映射的对象类型。\n\n- SQL 获取参数:        #{属性名}\n\n* 示例\n\n![1590918390112](./mybatis-第1天讲义.img/1590918390112.png)\n\n\n\n#### 3.4 修改功能\n\n- update：修改功能标签。\n\n- 属性        \n\n  id：唯一标识， 配合名称空间使用。     \n\n  parameterType：指定参数映射的对象类型。       \n\n  resultType：指定结果映射的对象类型。\n\n- SQL 获取参数:        #{属性名}\n\n* 示例\n\n![1590918538863](./mybatis-第1天讲义.img/1590918538863.png)\n\n#### 3.5 删除功能\n\n- delete：查询功能标签。\n\n- 属性        \n\n  id：唯一标识， 配合名称空间使用。     \n\n  parameterType：指定参数映射的对象类型。       \n\n  resultType：指定结果映射的对象类型。\n\n- SQL 获取参数:        #{属性名}\n\n* 示例\n\n  ![1590918458329](./mybatis-第1天讲义.img/1590918458329.png)\n\n* 总结： 大家可以发现crud操作，除了标签名称以及sql语句不一样之外，其他属性参数基本一致。\n\n#### 3.6 映射配置文件小结\n\n\n\n![1590918743943](./mybatis-第1天讲义.img/1590918743943.png)\n\n### 四.Mybatis核心配置文件介绍\n\n#### 4.1 核心配置文件介绍\n\n核心配置文件包含了 MyBatis 最核心的设置和属性信息。如数据库的连接、事务、连接池信息等。\n\n如下图:\n\n~~~xml\n<?xml version="1.0" encoding="UTF-8" ?>\n\x3c!--MyBatis的DTD约束--\x3e\n<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">\n\n\x3c!--configuration 核心根标签--\x3e\n<configuration>\n\n    \x3c!--environments配置数据库环境，环境可以有多个。default属性指定使用的是哪个--\x3e\n    <environments default="mysql">\n        \x3c!--environment配置数据库环境  id属性唯一标识--\x3e\n        <environment id="mysql">\n            \x3c!-- transactionManager事务管理。  type属性，采用JDBC默认的事务--\x3e\n            <transactionManager type="JDBC"></transactionManager>\n            \x3c!-- dataSource数据源信息   type属性 连接池--\x3e\n            <dataSource type="POOLED">\n                \x3c!-- property获取数据库连接的配置信息 --\x3e\n                <property name="driver" value="com.mysql.jdbc.Driver" />\n                <property name="url" value="jdbc:mysql:///db1" />\n                <property name="username" value="root" />\n                <property name="password" value="root" />\n            </dataSource>\n        </environment>\n    </environments>\n\n    \x3c!-- mappers引入映射配置文件 --\x3e\n    <mappers>\n        \x3c!-- mapper 引入指定的映射配置文件   resource属性指定映射配置文件的名称 --\x3e\n        <mapper resource="StudentMapper.xml"/>\n    </mappers>\n</configuration>\n~~~\n\n#### 4.2 数据库连接配置文件引入\n\n* properties标签引入外部文件\n\n  ~~~xml\n      \x3c!--引入数据库连接的配置文件--\x3e\n      <properties resource="jdbc.properties"/>\n  ~~~\n\n* 具体使用，如下配置\n\n  ~~~xml\n    \x3c!-- property获取数据库连接的配置信息 --\x3e\n      <property name="driver" value="${driver}" />\n      <property name="url" value="${url}" />\n      <property name="username" value="${username}" />\n      <property name="password" value="${password}" />\n  ~~~\n\n  \n\n#### 4.3 起别名\n\n* <typeAliases>：为全类名起别名的父标签。\n\n* <typeAlias>：为全类名起别名的子标签。\n\n* 属性      \n\n   type：指定全类名      \n\n   alias：指定别名\n\n* <package>：为指定包下所有类起别名的子标签。(别名就是类名)\n\n* 如下图：\n\n  ![1590919106324](./mybatis-第1天讲义.img/1590919106324.png)\n\n* 具体如下配置\n\n  ~~~xml\n      \x3c!--起别名--\x3e\n      <typeAliases>\n          <typeAlias type="com.itheima.bean.Student" alias="student"/>\n          \x3c!--<package name="com.itheima.bean"/>--\x3e\n      </typeAliase\n  ~~~\n\n#### 4.4 总结\n```xml\n核心配置文件包含了MyBatis.最核心的设置和属性信息。如数据库的连接、事务、连接池信息等。\n\n<configuration> :核心根标签。\n<properties> :引入数据库连接信息配置文件标签。\n<typeAliases> :起别名标签。\n<environments>:配置数据库环境标签。\n<environment>:配置数据库信息标签。\n<transactionManager>︰事务管理标签。\n<dataSource>︰数据源标签。\n<property>:数据库连接信息标签。\n<mappers> :引入映射配置文件标签。\n\n```\n\n \n\n### 五.Mybatis传统方式开发\n\n#### 5.1 Dao 层传统实现方式\n\n* 分层思想：控制层(controller)、业务层(service)、持久层(dao)。\n\n* 调用流程\n\n  ![1590919558066](./mybatis-第1天讲义.img/1590919558066.png)\n\n#### 5.2 LOG4J的配置和使用\n\n* 在日常开发过程中，排查问题时难免需要输出 MyBatis 真正执行的 SQL 语句、参数、结果等信息，我们就可以借助 LOG4J 的功能来实现执行信息的输出。\n\n* 使用步骤：\n\n  ![1590919638466](./mybatis-第1天讲义.img/1590919638466.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n'},"963a":function(n,e,t){"use strict";t.r(e),e["default"]='# Cookie&SessionJsp-授课\n\n# 1 会话技术\n\n## 1.1 会话管理概述\n\n### 1.1.1 什么是会话\n\n这里的会话，指的是web开发中的一次通话过程，当打开浏览器，访问网站地址后，会话开始，当关闭浏览器（或者到了过期时间），会话结束。\n\n举个例子：\n\n​\t例如，你在给家人打电话，这时突然有送快递的配送员敲门，你放下电话去开门，收完快递回来后，通话还在保持中，继续说话就行了。\n\n### 1.1.2 会话管理作用\n\n什么时候会用到会话管理呢？最常见的就是购物车，当我们登录成功后，把商品加入到购物车之中，此时我们无论再浏览什么商品，当点击购物车时，那些加入的商品都仍在购物车中。\n\n在我们的实际开发中，还有很多地方都离不开会话管理技术。比如，我们在论坛发帖，没有登录的游客身份是不允许发帖的。所以当我们登录成功后，无论我们进入哪个版块发帖，只要权限允许的情况下，服务器都会认识我们，从而让我们发帖，因为登录成功的信息一直保留在服务器端的会话中。\n\n通过上面的两个例子，我们可以看出，它是为我们共享数据用的，并且是在不同请求间实现数据共享。也就是说，如果我们需要在多次请求间实现数据共享，就可以考虑使用会话管理技术了。\n\n### 1.1.3 会话管理分类\n\n在JavaEE的项目中，会话管理分为两类。分别是：客户端会话管理技术和服务端会话管理技术。\n\n**客户端会话管理技术**\n\n​\t\t它是把要共享的数据保存到了客户端（也就是浏览器端）。每次请求时，把会话信息带到服务器，从而实现多次请求的数据共享。\n\n**服务端会话管理技术**\n\n​\t\t它本质仍是采用客户端会话管理技术，只不过保存到客户端的是一个特殊的标识，并且把要共享的数据保存到了服务端的内存对象中。每次请求时，把这个标识带到服务器端，然后使用这个标识，找到对应的内存空间，从而实现数据共享。\n\n## 1.2 客户端会话管理技术\n\n### 1.2.1 Cookie概述\n\n#### 1）什么是Cookie\n\n它是客户端浏览器的缓存文件，里面记录了客户浏览器访问网站的一些内容。同时，也是HTTP协议请求和响应消息头的一部分（在HTTP协议课程中，我们备注了它很重要）。\n\n#### 2）Cookie的API详解\n\n**作用**\n\n它可以保存客户浏览器访问网站的相关内容（需要客户端不禁用Cookie）。从而在每次访问需要同一个内容时，先从本地缓存获取，使资源共享，提高效率。\n\n**Cookie的属性**\n\n| 属性名称 | 属性作用                 | 是否重要 |\n| -------- | ------------------------ | -------- |\n| name     | cookie的名称             | 必要属性 |\n| value    | cookie的值（不能是中文） | 必要属性 |\n| path     | cookie的路径             | 重要     |\n| domain   | cookie的域名             | 重要     |\n| maxAge   | cookie的生存时间。       | 重要     |\n| version  | cookie的版本号。         | 不重要   |\n| comment  | cookie的说明。           | 不重要   |\n\n**细节**\n\nCookie有大小，个数限制。每个网站最多只能存20个cookie，且大小不能超过4kb。同时，所有网站的cookie总数不超过300个。\n\n当删除Cookie时，设置maxAge值为0。当不设置maxAge时，使用的是浏览器的内存，当关闭浏览器之后，cookie将丢失。设置了此值，就会保存成缓存文件（值必须是大于0的,以秒为单位）。\n\n#### 3）Cookie涉及的常用方法\n\n**创建Cookie**\n\n![Cookie的方法](./Cookie&SessionJsp-授课.assets/Cookie的方法.png)\n\n```java\n/**\n * 通过指定的名称和值构造一个Cookie\n *\n * Cookie的名称必须遵循RFC 2109规范。这就意味着，它只能包含ASCII字母数字字符，\n * 不能包含逗号、分号或空格或以$字符开头。\n * 创建后无法更改cookie的名称。\n *\n * 该值可以是服务器选择发送的任何内容。\n * 它的价值可能只有服务器才感兴趣。\n * 创建之后，可以使用setValue方法更改cookie的值。\n */\npublic Cookie(String name, String value) {\n\tvalidation.validate(name);\n\tthis.name = name;\n\tthis.value = value;\n}\n```\n\n**向浏览器添加Cookie**\n\n![添加Cookie的方法](./Cookie&SessionJsp-授课.assets/添加Cookie的方法.png)\n\n```java\n/**\n * 添加Cookie到响应中。此方法可以多次调用，用以添加多个Cookie。\n */\npublic void addCookie(Cookie cookie);\n```\n\n**从服务器端获取Cookie**\n\n![获取Cookie的方法](./Cookie&SessionJsp-授课.assets/获取Cookie的方法.png)\n\n```java\n/**\n * 这是HttpServletRequest中的方法。\n * 它返回一个Cookie的数组，包含客户端随此请求发送的所有Cookie对象。\n * 如果没有符合规则的cookie，则此方法返回null。\n */\n public Cookie[] getCookies();\n```\n\n### 1.2.2 Cookie的Path细节：浏览器什么时候带给服务器，什么时候不带\n\n#### 1）需求说明\n\n创建一个Cookie，设置Cookie的path，通过不同的路径访问，从而查看请求携带Cookie的情况。\n\n#### 2）案例目的\n\n通过此案例的讲解，同学们可以清晰的描述出，客户浏览器何时带cookie到服务器端，何时不带。\n\n#### 3）案例步骤\n\n**第一步：创建JavaWeb工程**\n\n沿用第一个案例中的工程即可。\n\n**第二步：编写Servlet**\n\n```JAVA\n/**\n * Cookie的路径问题\n * 前期准备：\n * \t1.在demo1中写一个cookie到客户端\n *  2.在demo2和demo3中分别去获取cookie\n *  \tdemo1的Servlet映射是   /servlet/PathQuestionDemo1\n *  \tdemo2的Servlet映射是   /servlet/PathQuestionDemo2\n *  \tdemo3的Servlet映射是   /PathQuestionDemo3\n *\n * @author 黑马程序员\n * @Company http://www.itheima.com\n *\n */\npublic class PathQuestionDemo1 extends HttpServlet {\n\n\tpublic void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\t//1.创建一个Cookie\n\t\tCookie cookie = new Cookie("pathquestion","CookiePathQuestion");\n\t\t//2.设置cookie的最大存活时间\n\t\tcookie.setMaxAge(Integer.MAX_VALUE);\n\t\t//3.把cookie发送到客户端\n\t\tresponse.addCookie(cookie);//setHeader("Set-Cookie","cookie的值")\n\t}\n\n\tpublic void doPost(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\tdoGet(request, response);\n\t}\n}\n\n```\n\n```java\n/**\n * 获取Cookie，名称是pathquestion\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class PathQuestionDemo2 extends HttpServlet {\n\n\tpublic void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\t//1.获取所有的cookie\n\t\tCookie[] cs = request.getCookies();\n\t\t//2.遍历cookie的数组\n\t\tfor(int i=0;cs!=null && i<cs.length;i++){\n\t\t\tif("pathquestion".equals(cs[i].getName())){\n\t\t\t\t//找到了我们想要的cookie，输出cookie的值\n\t\t\t\tresponse.getWriter().write(cs[i].getValue());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void doPost(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\tdoGet(request, response);\n\t}\n}\n```\n\n```java\n/**\n * 获取Cookie，名称是pathquestion\n * @author 黑马程序员\n * @Company http://www.itheima.com\n */\npublic class PathQuestionDemo3 extends HttpServlet {\n\n\tpublic void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\t//1.获取所有的cookie\n\t\tCookie[] cs = request.getCookies();\n\t\t//2.遍历cookie的数组\n\t\tfor(int i=0;cs!=null && i<cs.length;i++){\n\t\t\tif("pathquestion".equals(cs[i].getName())){\n\t\t\t\t//找到了我们想要的cookie，输出cookie的值\n\t\t\t\tresponse.getWriter().write(cs[i].getValue());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void doPost(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\tdoGet(request, response);\n\t}\n}\n```\n\n**第三步：配置Servlet**\n\n```xml\n\x3c!--配置Cookie路径问题案例的Servlet--\x3e\n<servlet>\n    <servlet-name>PathQuestionDemo1</servlet-name>\n    <servlet-class>com.itheima.web.servlet.pathquestion.PathQuestionDemo1</servlet-class>\n</servlet>\n<servlet-mapping>\n    <servlet-name>PathQuestionDemo1</servlet-name>\n    <url-pattern>/servlet/PathQuestionDemo1</url-pattern>\n</servlet-mapping>\n\n<servlet>\n    <servlet-name>PathQuestionDemo2</servlet-name>\n    <servlet-class>com.itheima.web.servlet.pathquestion.PathQuestionDemo2</servlet-class>\n</servlet>\n<servlet-mapping>\n    <servlet-name>PathQuestionDemo2</servlet-name>\n    <url-pattern>/servlet/PathQuestionDemo2</url-pattern>\n</servlet-mapping>\n\n<servlet>\n    <servlet-name>PathQuestionDemo3</servlet-name>\n    <servlet-class>com.itheima.web.servlet.pathquestion.PathQuestionDemo3</servlet-class>\n</servlet>\n<servlet-mapping>\n    <servlet-name>PathQuestionDemo3</servlet-name>\n    <url-pattern>/PathQuestionDemo3</url-pattern>\n</servlet-mapping>\n```\n\n**第四步：部署工程**\n\n沿用第一个案例中的工程部署即可。\n\n#### 4）测试结果\n\n通过分别运行PathQuestionDemo1，2和3这3个Servlet，我们发现由demo1写Cookie，在demo2中可以取到，但是到了demo3中就无法获取了，如下图所示：\n\n![案例2-1](./Cookie&SessionJsp-授课.assets/案例2-1.png)\n\n![案例2-2](./Cookie&SessionJsp-授课.assets/案例2-2.png)\n\n![案例2-3](./Cookie&SessionJsp-授课.assets/案例2-3.png)\n\n#### 5）路径问题的分析及总结\n\n**问题：**\n \t demo2和demo3谁能取到cookie？\n **答案：**\n \t demo2能取到，demo3取不到\n**分析：**\n \t 首先，我们要知道如何确定一个cookie？\n \t 那就是使用cookie的三个属性组合：<font color=\'red\'><b>domain+path+name</b></font>\n \t 这里面，同一个应用的domain是一样的，在我们的案例中都是localhost。\n​      并且，我们取的都是同一个cookie，所以name也是一样的，都是pathquestion。\n​      那么，不一样的只能是path了。但是我们没有设置过cookie的path属性，这就表明path是有默认值的。\n \t 接下来，我们打开这个cookie来看一看，在ie浏览器访问一次PathQuestionDemo1这个Servlet：\n\nCookie中的内容：\n \t\t ![Cookie文件介绍](./Cookie&SessionJsp-授课.assets/Cookie文件介绍.png)\n 我们是通过demo1写的cookie，demo1的访问路径是： http://localhost:9090/servlet/PathQuestionDemo1\n 通过比较两个路径：请求资源地址和cookie的path，可以看出：cookie的path默认值是：请求资源URI，没有资源的部分（在我们的案例中，就是没有PathQuestionDemo1）。\n\n**客户端什么时候带cookie到服务器，什么时候不带？**\n​\t就是看请求资源URI和cookie的path比较。\n\n​\t<font color=\'red\'>请求资源URI.startWith(cookie的path) </font> 如果返回的是true就带，如果返回的是false就不带。\n\n​\t简单的说： 就是看谁的地址更精细\n\n​\t比如：Cookie的path：       /国家\t\t\t/省份\t\t\t/城市\n\n \t\t \t 请求资源URI\t:   \t  /国家\t\t\t/省份\t\t\t\t\t\t\t\t\t\t\t\t\t\t  不带\n \t\t \t 请求资源URI   ：\t   /国家\t\t\t/省份\t\t\t/城市\t\t\t/区县\t\t\t\t带\n\n![案例2-4](./Cookie&SessionJsp-授课.assets/案例2-4.png)\n\n在我们的案例中：\n\n| 访问URL                                                      | URI部分                    | Cookie的Path | 是否携带Cookie | 能否取到Cookie |\n| ------------------------------------------------------------ | -------------------------- | ------------ | -------------- | -------------- |\n| [PathQuestionDemo2](http://localhost:9090/servlet/PathQuestionDemo2) | /servlet/PathQuestionDemo2 | /servlet/    | 带             | 能取到         |\n| [PathQuestionDemo3](http://localhost:9090/PathQuestionDemo3) | /PathQuestionDemo3         | /servlet/    | 不带           | 不能取到       |\n\n## 1.3 服务端会话管理概述\n\n### 1.3.1 HttpSession概述\n\n#### 1）HttpSession对象介绍\n\n它是Servlet规范中提供的一个接口。该接口的实现由Servlet规范的实现提供商提供。我们使用的是Tomcat服务器，它对Servlet规范进行了实现，所以HttpSession接口的实现由Tomcat提供。该对象用于提供一种通过多个页面请求或访问网站来标识用户并存储有关该用户的信息的方法。简单说它就是一个服务端会话对象，用于存储用户的会话数据。\n\n同时，它也是Servlet规范中四大域对象之一的会话域对象。并且它也是用于实现数据共享的。但它与我们之前讲解的应用域和请求域是有区别的。\n\n| 域对象         | 作用范围     | 使用场景                                                     |\n| -------------- | ------------ | ------------------------------------------------------------ |\n| ServletContext | 整个应用范围 | 当前项目中需要数据共享时，可以使用此域对象。                 |\n| ServletRequest | 当前请求范围 | 在请求或者当前请求转发时需要数据共享可以使用此域对象。       |\n| HttpSession    | 会话返回     | 在当前会话范围中实现数据共享。它可以在多次请求中实现数据共享。 |\n\n#### 2）HttpSession的获取\n\n获取HttpSession是通过HttpServletRequest接口中的两个方法获取的，如下图所示：\n\n![获取HttpSession的两个方法](./Cookie&SessionJsp-授课.assets/获取HttpSession的两个方法.png)\n\n这两个方法的区别：\n\n![获取Session的两个方法](./Cookie&SessionJsp-授课.assets/获取Session的两个方法.png)\n\n#### 3）HttpSession的常用方法\n\n![HttpSession方法介绍](./Cookie&SessionJsp-授课.assets/HttpSession方法介绍.png)\n\n### 1.3.2 HttpSession的入门案例\n\n#### 1）需求说明\n\n在请求HttpSessionDemo1这个Servlet时，携带用户名信息，并且把信息保存到会话域中，然后从HttpSessionDemo2这个Servlet中获取登录信息。\n\n#### 2）案例目的\n\n通过本案例的讲解，同学们可以清楚的认识到会话域的作用，即多次请求间的数据共享。因为是两次请求，请求域肯定不一样了，所以不能用请求域实现。\n\n最终掌握HttpSession对象的获取和使用。\n\n#### 3）原理分析\n\nHttpSession，它虽然是服务端会话管理技术的对象，但它本质仍是一个Cookie。是一个由服务器自动创建的特殊的Cookie，Cookie的名称就是JSESSIONID，Cookie的值是服务器分配的一个唯一的标识。\n\n当我们使用HttpSession时，浏览器在没有禁用Cookie的情况下，都会把这个Cookie带到服务器端，然后根据唯一标识去查找对应的HttpSession对象，找到了，我们就可以直接使用了。下图就是我们入门案例中，HttpSession分配的唯一标识，同学们可以看到两次请求的JSESSIONID的值是一样的：\n\n![案例3-5](./Cookie&SessionJsp-授课.assets/案例3-5.png)\n\n### 1.3.3 HttpSession的钝化和活化\n\n**什么是持久态**\n\n​\t\t把长时间不用，但还不到过期时间的HttpSession进行序列化，写到磁盘上。\n\n​\t\t我们把HttpSession持久态也叫做钝化。（与钝化相反的，我们叫活化。）\n\n**什么时候使用持久化**\n\n​\t\t第一种情况：当访问量很大时，服务器会根据getLastAccessTime来进行排序，对长时间不用，但是还没到过期时间的HttpSession进行持久化。\n\n​\t\t第二种情况：当服务器进行重启的时候，为了保持客户HttpSession中的数据，也要对HttpSession进行持久化\n\n**注意**\n\n​\t\tHttpSession的持久化由服务器来负责管理，我们不用关心。\n\n​\t\t只有实现了序列化接口的类才能被序列化，否则不行。\n\n# 2 页面技术\n\n## 2.1 JSP基础\n\n### 2.1.1 JSP简介\n\nJSP全称是Java Server Page，它和Servlet一样，也是sun公司推出的一套开发动态web资源的技术，称为JSP/Servlet规范。JSP的本质其实就是一个Servlet。\n\n### 2.1.2 JSP和HTML以及Servlet的适用场景\n\n| 类别    | 适用场景                                                     |\n| ------- | ------------------------------------------------------------ |\n| HTML    | 只能开发静态资源，不能包含java代码，无法添加动态数据。       |\n| Servlet | 写java代码，可以输出页面内容，但是很不方便，开发效率极低。   |\n| JSP     | 它包括了HTML的展示技术，同时具备Servlet输出动态资源的能力。但是不适合作为控制器来用。 |\n\n### 2.1.3 JSP简单入门\n\n**创建JavaWeb工程**\n\n![案例jsp1](./Cookie&SessionJsp-授课.assets/案例jsp1.png)\n\n**在index.jsp中填写内容**\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n  <head>\n    <title>JSP的入门</title>\n  </head>\n  <body>\n      这是第一个JSP页面\n  </body>\n</html>\n```\n\n**部署项目**\n\n沿用会话管理工程的部署方式即可。\n\n**测试运行**\n\n![案例jsp2](./Cookie&SessionJsp-授课.assets/案例jsp2.png)\n\n### 2.1.4 JSP说明\n\n写在之前： 明确JSP就是一个Servlet。是一个特殊的Servlet。\n\nJSP的原理：\n\n​           客户端提交请求\n\n​\t\t\t\t——Tomcat服务器解析请求地址\n\n​\t\t\t\t\t\t——找到JSP页面\n\n​\t\t\t\t\t\t\t\t——Tomcat将JSP页面翻译成Servlet的java文件\n\n​\t\t\t\t\t\t\t\t\t\t——将翻译好的.java文件编译成.class文件\n\n​\t\t\t\t\t\t\t\t\t\t\t\t——返回到客户浏览器上。\n\n#### 1）执行过程分析图\n\n![Tomcat执行过程](./Cookie&SessionJsp-授课.assets/Tomcat执行过程.png)\n\n#### 2）JSP的.java文件内容分析\n\n当我们打开index.jsp翻译的java文件看到的就是`public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase`类的声明，然后我们在Tomcat的源码中找到类的声明，如下图：\n\n![Tomcat中的HttpJspBase类声明](./Cookie&SessionJsp-授课.assets/Tomcat中的HttpJspBase类声明.png)\n\n这张图一出场，就表明我们写的JSP它本质就是一个HttpServlet了。\n\n![jsp的本质说明](./Cookie&SessionJsp-授课.assets/jsp的本质说明.png)\n\n同时，我们在index_jsp.java文件中找到了输出页面的代码，并且在浏览器端查看源文件，看到的内容是一样的。这也就是说明，我们的浏览器上的内容，在通过jsp展示时，本质都是用out.write()输出出来的。\n\n讲到这里，我们应该清楚的认识到，JSP它是一个特殊的Servlet，主要是用于展示动态数据。它展示的方式是用流把数据输出出来，而我们在使用JSP时，涉及HTML的部分，都与HTML的用法一致，这部分称为jsp中的模板元素，在开发过程中，先写好这些模板元素，因为它们决定了页面的外观。\n\n## 2.2 JSP应用\n\n### 2.2.1 JSP语法\n\n#### 1）Java代码块\n\n在jsp中，可以使用java脚本代码。形式为：<font color=\'red\'><b><% 此处写java代码 %></b></font>\n\n但是，在实际开发中，极少使用此种形式编写java代码。同时需要注意的是：\n\n```jsp\n<%\n\t在里面写java程序脚本需要注意：这里面的内容由tomcat负责翻译，翻译之后是service方法的成员变量\n%>\n```\n\n**示例：**\n\n```jsp\n\x3c!--Java代码块--\x3e\n<% out.println("这是Java代码块");%>\n<hr/>\n```\n\n#### 2）JSP表达式\n\n在jsp中，可以使用特定表达式语法，形式为：<font color=\'red\'><b><%=表达式%></b></font>\n\njsp在翻译完后是out.print(表达式内容);\n\n所以：<%out.print("当前时间);%>和<%="当前时间"%>是一样的。\n\n在实际开发中，这种表达式语法用的也很少使用。\n\n**示例：**\n\n```jsp\n\x3c!--JSP表达式--\x3e\n<%="这是JSP表达式"%><br/>\n就相当于<br/>\n<%out.println("这是没有JSP表达式输出的");%>\n```\n\n#### 3）JSP声明\n\n在JSP中也可以声明一些变量，方法，静态方法，形式为：<font color=\'red\'><b><%! 声明的内容 %></b></font>\n\n使用JSP声明需要注意：\n\n```jsp\n<%! \n\t需要注意的是： 写在里面的内容将会被tomcat翻译成全局的属性或者类方法。\n%>                                    \n```\n\n**示例：**\n\n```jsp\n\x3c!--JSP声明--\x3e\n<%! String str = "声明语法格式";%>\n<%=str%>\n```\n\n#### 4）JSP注释\n\n在使用JSP时，它有自己的注释，形式为：<font color=\'red\'><b><%--注释--%></b></font>\n\n需要注意的是：\n\n​      在Jsp中可以使用html的注释，但是只能注释html元素，不能注释java程序片段和表达式。同时，被html注释部分会参与翻译，并且会在浏览器上显示\n\n​      jsp的注释不仅可以注释java程序片段，也可以注释html元素，并且被jsp注释的部分不会参与翻译成.java文件，也不会在浏览器上显示。\n\n**示例：**\n\n```jsp\n<%--JSP注释--%>\n\x3c!--HTML注释--\x3e\n```\n\n#### 5）语法的示例\n\n**JSP语法完整示例代码**\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>JSP语法</title>\n</head>\n<body>\n\n\x3c!--Java代码块--\x3e\n<% out.println("这是Java代码块");%>\n<hr/>\n\n\x3c!--JSP表达式--\x3e\n<%="这是JSP表达式"%><br/>\n就相当于<br/>\n<%out.println("这是没有JSP表达式输出的");%>\n\n<hr/>\n\x3c!--JSP声明--\x3e\n<%! String str = "声明语法格式";%>\n<%=str%>\n\n<hr/>\n\n<%--JSP注释--%>\n\x3c!--HTML注释--\x3e\n\n</body>\n</html>\n```\n\n**JSP语法运行结果**\n\n![案例jsp3](./Cookie&SessionJsp-授课.assets/案例jsp3.png)\n\n### 2.2.2 JSP指令\n\n#### 1）page指令\n\n**language:**告知引擎，脚本使用的是java，默认是java，支持java。不写也行。\n\n**extends**：告知引擎，JSP对应的Servlet的父类是哪个，不需要写，也不需要改。\n\n**import**：告知引擎，导入哪些包（类）。\n\n​                **注意：引擎会自动导入：java.lang.\\*,javax.servlet.\\*,javax.servlet.http.\\*,javax.servlet.jsp.\\***\n\n​                    **导入的形式：** \n\n​                         **<%@page import=”java.util.Date,java.util.UUID”%>或者：**\n\n​                         **<%@page import=”java.util.Date”%>**\n\n​                         **<%@page import=”java.util.UUID”%>**  **用Eclipse：Alt+/ 自动导入**\n\n**session**：告知引擎是否产生HttpSession对象，即是否在代码中调用request.getSession()。默认是true。\n\n**buffer**：JspWriter用于输出JSP内容到页面上。告知引擎，设定他的缓存大小。默认8kb。\n\n**errorPage**：告知引擎，当前页面出现异常后，应该转发到哪个页面上（路径写法：/代表当前应用）\n\n​                \t**小贴士：当在errorpage上使用了isErrorPage=true之后，ie8有时候不能正常显示**\n\n​            \t\t **配置全局错误页面：web.xml**\n\n\n\n```xml\n<error-page>    \n    <exception-type>java.lang.Exception</exception-type>    \t\t\t\n    <location>/error.jsp</location>\n</error-page>\n<error-page>\n    <error-code>404</error-code>\n    <location>/404.html</location>\n</error-page>                                 \n```\n\n​           \t\t **当使用了全局错误页面，就无须再写errorPage来实现转到错误页面，而是由服务器负责跳转到错误页面。**\n\n**isErrorPage**：告知引擎，是否抓住异常。如果该属性为true，页面中就可以使用exception对象，打印异常的详细信息。默认值是false。\n\n**contentType**：告知引擎，响应正文的MIME类型。contentType="text/html;charset=UTF-8"\n\n​               \t\t\t相当于response.setContentType("text/html;charset=UTF-8");\n\n**pageEncoding**：告知引擎，翻译jsp时（从磁盘上读取jsp文件）所用的码表。pageEncoding="UTF-8"相当于告知引擎用UTF-8读取JSP\n\n**isELIgnored***：告知引擎，是否忽略EL表达式，默认值是false，不忽略。\n\n#### 2）include指令\n\n语法格式：<%@include file="" %>该指令是包含外部页面。 \n\n属性：file，以/开头，就代表当前应用。\n\n**使用示例**\n\n![静态包含1](./Cookie&SessionJsp-授课.assets/静态包含1.png)\n\n**静态包含的特点**\n\n![静态包含2](./Cookie&SessionJsp-授课.assets/静态包含2.png)\n\n#### 3）taglib指令\n\n语法格式：<%taglib uri="" prefix=""%>\n\n作用：该指令用于引入外部标签库。html标签和jsp标签不用引入。\n\n属性：                                                                                   \n\n​       uri：外部标签的URI地址。\n\n​       prefix：使用标签时的前缀。\n\n### 2.2.3 JSP细节\n\n#### 1）九大隐式对象\n\n什么是隐式对象呢？它指的是在jsp中，可以不声明就直接使用的对象。它只存在于jsp中，因为java类中的变量必须要先声明再使用。其实jsp中的隐式对象也并非是未声明，只是它是在翻译成.java文件时声明的。所以我们在jsp中可以直接使用。\n\n| 隐式对象名称 | 类型                                   | 备注                          |\n| ------------ | -------------------------------------- | ----------------------------- |\n| request      | javax.servlet.http.HttpServletRequest  |                               |\n| response     | javax.servlet.http.HttpServletResponse |                               |\n| session      | javax.servlet.http.HttpSession         | Page指令可以控制开关          |\n| application  | javax.servlet.ServletContext           |                               |\n| page         | Java.lang.Object                       | 当前jsp对应的servlet引用实例  |\n| config       | javax.servlet.ServletConfig            |                               |\n| exception    | java.lang.Throwable                    | page指令有开关                |\n| out          | javax.servlet.jsp.JspWriter            | 字符输出流，相当于printwriter |\n| pageContext  | javax.servlet.jsp.PageContext          | 很重要                        |\n\n#### 2）PageContext对象\n\n**简介**\n\n它是JSP独有的对象，Servlet中没有这个对象。本身也是一个域（作用范围）对象，但是它可以操作其他3个域对象中的属性。而且还可以获取其他8个隐式对象。\n\n**生命周期**\n\n它是一个局部变量，所以它的生命周期随着JSP的创建而诞生，随着JSP的结束而消失。每个JSP页面都有一个独立的PageContext。\n\n**常用方法**\n\n![PageContext方法详解](./Cookie&SessionJsp-授课.assets/PageContext方法详解.png)\n\n在上图中，同学们发现没有页面域操作的方法，其实是定义在了PageContext的父类JspContext中，如下图所示：\n\n![JspContext](./Cookie&SessionJsp-授课.assets/JspContext.png)\n\n#### 3）四大域对象\n\n| 域对象名称     | 范围     | 级别                     | 备注                                     |\n| -------------- | -------- | ------------------------ | ---------------------------------------- |\n| PageContext    | 页面范围 | 最小，只能在当前页面用   | 因范围太小，开发中用的很少               |\n| ServletRequest | 请求范围 | 一次请求或当期请求转发用 | 当请求转发之后，再次转发时请求域丢失     |\n| HttpSession    | 会话范围 | 多次请求数据共享时使用   | 多次请求共享数据，但不同的客户端不能共享 |\n| ServletContext | 应用范围 | 最大，整个应用都可以使用 | 尽量少用，如果对数据有修改需要做同步处理 |\n\n### 2.2.4 JSP最佳实战-MVC模型\n\n**Servlet：**擅长处理业务逻辑，不擅长输出显示界面。在web开发中多用于控制程序逻辑（流程）。所以我们称之为：控制器。\n\n**JSP：**擅长显示界面，不擅长处理程序逻辑。在web开发中多用于展示动态界面。所以我们称之为：视图。\n\n例如:               ![1577355748295](./Cookie&SessionJsp-授课.assets/1577355748295.png)                                                                      \n\nM：model      ，通常用于封装数据，封装的是数据模型。\n\nV：view\t       ，通常用于展示数据。动态展示用jsp页面，静态数据展示用html。\n\nC：controller ，通常用于处理请求和响应。一般指的是Servlet。\n\n# 3 综合案例-学生管理系统升级\n\n## 3.1 登录功能实现\n\n### 3.1.1 创建一个web项目，在 web 目录下创建一个 index.jsp。\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>学生管理系统首页</title>\n</head>\n<body>\n    <%--\n        获取会话域中的数据\n        如果获取到了则显示添加和查看功能的超链接\n        如果没获取到则显示登录功能的超链接\n    --%>\n    <% Object username = session.getAttribute("username");\n        if(username == null) {\n    %>\n        <a href="/stu/login.jsp">请登录</a>\n    <%} else {%>\n        <a href="/stu/addStudent.jsp">添加学生</a>\n        <a href="/stu/listStudentServlet">查看学生</a>\n    <%}%>\n</body>\n</html>\n```\n\n\n\n### 3.1.2 在 web 目录下创建一个 login.jsp。实现登录页面\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>学生登录</title>\n</head>\n<body>\n    <form action="/stu/loginStudentServlet" method="get" autocomplete="off">\n        姓名：<input type="text" name="username"> <br>\n        密码：<input type="password" name="password"> <br>\n        <button type="submit">登录</button>\n    </form>\n</body>\n</html>\n\n```\n\n\n\n### 3.1.3 创建 LoginStudentServlet，获取用户名和密码\n\n```java\npackage com.itheima.servlet;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/*\n    学生登录\n */\n@WebServlet("/loginStudentServlet")\npublic class LoginStudentServlet extends HttpServlet{\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //1.获取用户名和密码\n        String username = req.getParameter("username");\n        String password = req.getParameter("password");\n\n        //2.判断用户名\n        if(username == null || "".equals(username)) {\n            //2.1用户名为空 重定向到登录页面\n            resp.sendRedirect("/stu/login.jsp");\n            return;\n        }\n\n        //2.2用户名不为空 将用户名存入会话域中\n        req.getSession().setAttribute("username",username);\n\n        //3.重定向到首页index.jsp\n        resp.sendRedirect("/stu/index.jsp");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n\n```\n\n\n\n##  3.2添加功能实现\n\n### 3.2.1 在 web 目录下创建一个 addStudent.jsp，实现添加学生的表单项\n\n```jsp\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>添加学生</title>\n</head>\n<body>\n<form action="/stu/addStudentServlet" method="get" autocomplete="off">\n    学生姓名：<input type="text" name="username"> <br>\n    学生年龄：<input type="number" name="age"> <br>\n    学生成绩：<input type="number" name="score"> <br>\n    <button type="submit">保存</button>\n</form>\n</body>\n</html>\n\n```\n\n### 3.2.2 创建 AddStudentServlet，获取学生信息并保存到文件中\n\n```java\npackage com.itheima.servlet;\n\nimport com.itheima.bean.Student;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/*\n    实现添加功能\n */\n@WebServlet("/addStudentServlet")\npublic class AddStudentServlet extends HttpServlet{\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //1.获取表单中的数据\n        String username = req.getParameter("username");\n        String age = req.getParameter("age");\n        String score = req.getParameter("score");\n\n        //2.创建学生对象并赋值\n        Student stu = new Student();\n        stu.setUsername(username);\n        stu.setAge(Integer.parseInt(age));\n        stu.setScore(Integer.parseInt(score));\n\n        //3.将学生对象的数据保存到d:\\\\stu.txt文件中\n        BufferedWriter bw = new BufferedWriter(new FileWriter("d:\\\\stu.txt",true));\n        bw.write(stu.getUsername() + "," + stu.getAge() + "," + stu.getScore());\n        bw.newLine();\n        bw.close();\n\n        //4.通过定时刷新功能响应给浏览器\n        resp.setContentType("text/html;charset=UTF-8");\n        resp.getWriter().write("添加成功。2秒后自动跳转到首页...");\n        resp.setHeader("Refresh","2;URL=/stu/index.jsp");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n\n```\n\n## 3.3 查看学生功能\n\n### 3.3.1 创建 ListStudentServlet，读取文件中的学生信息到集合中\n\n```\n1、将集合添加到会话域中\n\n2、重定向到 listStudent.jsp 页面上\n```\n\n\n\n```java\npackage com.itheima.servlet;\n\nimport com.itheima.bean.Student;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.ArrayList;\n\n/*\n    实现查看功能\n */\n@WebServlet("/listStudentServlet")\npublic class ListStudentServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //1.创建字符输入流对象，关联读取的文件\n        BufferedReader br = new BufferedReader(new FileReader("d:\\\\stu.txt"));\n\n        //2.创建集合对象，用于保存Student对象\n        ArrayList<Student> list = new ArrayList<>();\n\n        //3.循环读取文件中的数据，将数据封装到Student对象中。再把多个学生对象添加到集合中\n        String line;\n        while((line = br.readLine()) != null) {\n            //张三,23,95\n            Student stu = new Student();\n            String[] arr = line.split(",");\n            stu.setUsername(arr[0]);\n            stu.setAge(Integer.parseInt(arr[1]));\n            stu.setScore(Integer.parseInt(arr[2]));\n            list.add(stu);\n        }\n\n        //4.将集合对象存入会话域中\n        req.getSession().setAttribute("students",list);\n\n        //5.重定向到学生列表页面\n        resp.sendRedirect("/stu/listStudent.jsp");\n\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req,resp);\n    }\n}\n\n```\n\n### 3.3.2 在 web 目录下创建一个 listStudent.jsp\n\n```jsp\n<%@ page import="com.itheima.bean.Student" %>\n<%@ page import="java.util.ArrayList" %>\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>查看学生</title>\n</head>\n<body>\n    <table width="600px" border="1px">\n        <tr>\n            <th>学生姓名</th>\n            <th>学生年龄</th>\n            <th>学生成绩</th>\n        </tr>\n        <% ArrayList<Student> students = (ArrayList<Student>) session.getAttribute("students");\n            for(Student stu : students) {\n        %>\n            <tr align="center">\n                <td><%=stu.getUsername()%></td>\n                <td><%=stu.getAge()%></td>\n                <td><%=stu.getScore()%></td>\n            </tr>\n        <%}%>\n    </table>\n</body>\n</html>\n\n```\n\n'},"971c":function(n,e,t){"use strict";t.r(e),e["default"]='> 本文由 JavaGuide 翻译，原文地址：https://www.baeldung.com/foreach-java\n\n## 1 概述\n\n在Java 8中引入的*forEach*循环为程序员提供了一种新的，简洁而有趣的迭代集合的方式。\n\n在本文中，我们将看到如何将*forEach*与集合*一起*使用，它采用何种参数以及此循环与增强的*for*循环的不同之处。\n\n## 2 基础知识\n\n```Java\npublic interface Collection<E> extends Iterable<E>\n```\n\nCollection 接口实现了 Iterable 接口，而 Iterable 接口在 Java 8开始具有一个新的 API：\n\n```java\nvoid forEach(Consumer<? super T> action)//对 Iterable的每个元素执行给定的操作，直到所有元素都被处理或动作引发异常。\n```\n\n使用*forEach*，我们可以迭代一个集合并对每个元素执行给定的操作，就像任何其他*迭代器一样。*\n\n例如，迭代和打印字符串集合*的*for循环版本：\n\n```java\nfor (String name : names) {\n    System.out.println(name);\n}\n```\n\n我们可以使用*forEach*写这个 ：\n\n```java\nnames.forEach(name -> {\n    System.out.println(name);\n});\n```\n\n## 3.使用forEach方法\n\n### 3.1 匿名类\n\n我们使用  *forEach*迭代集合并对每个元素执行特定操作。**要执行的操作包含在实现Consumer接口的类中，并作为参数传递给forEach 。**\n\n所述*消费者*接口是一个功能接口(具有单个抽象方法的接口）。它接受输入并且不返回任何结果。\n\nConsumer 接口定义如下：\n\n```java\n@FunctionalInterface\npublic interface Consumer {\n    void accept(T t);\n}\n```\n任何实现，例如，只是打印字符串的消费者：\n\n```java\nConsumer<String> printConsumer = new Consumer<String>() {\n    public void accept(String name) {\n        System.out.println(name);\n    };\n};\n```\n\n可以作为参数传递给*forEach*：\n\n```java\nnames.forEach(printConsumer);\n```\n\n但这不是通过消费者和使用*forEach* API 创建操作的唯一方法。让我们看看我们将使用*forEach*方法的另外2种最流行的方式：\n\n### 3.2 Lambda表达式\n\nJava 8功能接口的主要优点是我们可以使用Lambda表达式来实例化它们，并避免使用庞大的匿名类实现。\n\n由于 Consumer 接口属于函数式接口，我们可以通过以下形式在Lambda中表达它：\n\n```java\n(argument) -> { body }\nname -> System.out.println(name)\nnames.forEach(name -> System.out.println(name));\n```\n\n### 3.3 方法参考\n\n我们可以使用方法引用语法而不是普通的Lambda语法，其中已存在一个方法来对类执行操作：\n\n```java\nnames.forEach(System.out::println);\n```\n\n## 4.forEach在集合中的使用\n\n### 4.1.迭代集合\n\n**任何类型Collection的可迭代  - 列表，集合，队列 等都具有使用forEach的相同语法。**\n\n因此，正如我们已经看到的，迭代列表的元素：\n\n```java\nList<String> names = Arrays.asList("Larry", "Steve", "James");\n \nnames.forEach(System.out::println);\n```\n\n同样对于一组：\n\n```java\nSet<String> uniqueNames = new HashSet<>(Arrays.asList("Larry", "Steve", "James"));\n \nuniqueNames.forEach(System.out::println);\n```\n\n或者让我们说一个*队列*也是一个*集合*：\n\n```java\nQueue<String> namesQueue = new ArrayDeque<>(Arrays.asList("Larry", "Steve", "James"));\n \nnamesQueue.forEach(System.out::println);\n```\n\n### 4.2.迭代Map - 使用Map的forEach\n\nMap没有实现Iterable接口，但它**提供了自己的forEach 变体，它接受BiConsumer**。* \n\n```java\nMap<Integer, String> namesMap = new HashMap<>();\nnamesMap.put(1, "Larry");\nnamesMap.put(2, "Steve");\nnamesMap.put(3, "James");\nnamesMap.forEach((key, value) -> System.out.println(key + " " + value));\n```\n\n### 4.3.迭代一个Map - 通过迭代entrySet\n\n```java\nnamesMap.entrySet().forEach(entry -> System.out.println(entry.getKey() + " " + entry.getValue()));\n```'},"9a8e":function(n,e,t){"use strict";t.r(e),e["default"]="## 1.Git介绍 \n\n### 1.1版本控制(理解)\n\n无论是代码编写，还是文档编写，我们都会遇到对文档内容反复修改的情况\n\n![01_版本控制介绍](./day10-Git.img/01_版本控制介绍.png)\n\n### 1.2开发中存在的问题(理解)\n\n+ 程序员小明负责的模块就要完成了，就在即将提交发布之前的一瞬间，电脑突然蓝屏，硬盘光荣下岗！\n\n几个月来的努力付之东流\n\n​\t![02_开发中的麻烦](./day10-Git.img/02_开发中的麻烦.png)\n\n+ 老王需要在项目中加入一个很复杂的功能，一边尝试，一边修改代码，就这样摸索了一个星期。\n  可是这被改得面目全非的代码已经回不到从前了。\n\n  ![03_开发中的麻烦](./day10-Git.img/03_开发中的麻烦.png)\n\n+ 小明和老王先后从文件服务器上下载了同一个文件\n\n  ![04_开发中的麻烦](./day10-Git.img/04_开发中的麻烦.png)\n\n+ 因项目中Bug过多，导致项目进度拖延，项目经理老徐因此被骂，但不清楚Bug是手下哪一个程序员写的\n\n  ![05_开发中的麻烦](./day10-Git.img/05_开发中的麻烦.png)\n\n+ 开发中要解决的问题\n\n  + 代码备份\n  + 版本控制\n  + 协同工作\n  + 责任追溯\n\n### 1.3SVN版本控制(理解)\n\nSVN是集中式版本控制系统，版本库是集中放在中央服务器的，而开发人员工作的时候，用的都是自己的电脑，\n所以首先要从中央服务器下载最新的版本，然后开发，开发完后，需要把自己开发的代码提交到中央服务器。\n\n+ 服务器单点故障\n\n  将会导致所有人员无法工作\n\n+ 而服务器硬盘损坏\n\n  这意味着，你可能失去了该项目的所有历史记录，这是毁灭性的。\n\n  ![06_svn和git的对比](./day10-Git.img/06_svn和git的对比.png)\n\n### 1.4Git版本控制(理解)\n\nGit是在2005年，Linux系统的创建者Linus Torvalds,为了帮助全球的开发者，维护Linux系统内核的开发\n而开发了自己的开源分布式版本控制工具,分为两种类型的仓库：本地仓库和远程仓库。\n\n+ 每一个客户端都保存了完整的历史记录\n\n  服务器的故障，都可以通过客户端的记录得以恢复。\n\n  ![07_svn和git的对比](./day10-Git.img/07_svn和git的对比.png)\n\n## 2.Git下载和安装 \n\n### 2.1Git的下载(应用)\n\n官网下载地址：https://git-scm.com/downloads\n\n![08_Git的下载](./day10-Git.img/08_Git的下载.png)\n\n### 2.2Git的安装(应用)\n\n1. 双击安装包，进入安装向导界面\n\n   ![09_Git的安装01](./day10-Git.img/09_Git的安装01.png)\n\n2. 指定安装目录\n\n   ![10_Git的安装02](./day10-Git.img/10_Git的安装02.png)\n\n3. 一路next下一步\n\n   ![11_Git的安装03](./day10-Git.img/11_Git的安装03.png)\n\n4. 等待安装\n\n   ![12_Git的安装04](./day10-Git.img/12_Git的安装04.png)\n\n5. 安装完成\n\n   ![13_Git的安装05](./day10-Git.img/13_Git的安装05.png)\n\n6. 安装完成后在电脑桌面（也可以是其他目录）点击右键，如果能够看到如下两个菜单则说明Git安装成功。\n\n   ![14_Git的安装06](./day10-Git.img/14_Git的安装06.png)\n\n7. 运行Git命令客户端，使用git --version 命令，可以查看git版本\n\n   ![15_Git的安装07](./day10-Git.img/15_Git的安装07.png)\n\n### 2.3TortoiseGit的安装(应用)\n\n1. 双击安装包，进入安装向导界面\n\n   ![16_TortiseGit的安装](./day10-Git.img/16_TortiseGit的安装.png)\n\n2. 一路next下一步\n\n   ![17_TortiseGit的安装](./day10-Git.img/17_TortiseGit的安装.png)\n\n3. 指定安装目录\n   ![18_TortiseGit的安装](./day10-Git.img/18_TortiseGit的安装.png)\n\n4. 安装\n\n   ![19_TortiseGit的安装](./day10-Git.img/19_TortiseGit的安装.png)\n\n5. 配置\n\n   ![20_TortiseGit的安装](./day10-Git.img/20_TortiseGit的安装.png)\n\n   ![21_TortiseGit的安装](./day10-Git.img/21_TortiseGit的安装.png)\n\n   ![22_TortiseGit的安装](./day10-Git.img/22_TortiseGit的安装.png)\n\n   ![23_TortiseGit的安装](./day10-Git.img/23_TortiseGit的安装.png)\n\n   ![24_TortiseGit的安装](./day10-Git.img/24_TortiseGit的安装.png)\n\n   ![25_TortiseGit的安装](./day10-Git.img/25_TortiseGit的安装.png)\n\n6. 安装TortoiseGit中文语言包,一路next即可\n\n![26_TortiseGit的安装](./day10-Git.img/26_TortiseGit的安装.png)\n\n7. 配置TortoiseGit中文语言\n\n   ![27_TortiseGit的安装](./day10-Git.img/27_TortiseGit的安装.png)\n\n   ![28_TortiseGit的安装](./day10-Git.img/28_TortiseGit的安装.png)\n\n   ![29_TortiseGit的安装](./day10-Git.img/29_TortiseGit的安装.png)\n\n   ![30_TortiseGit的安装](./day10-Git.img/30_TortiseGit的安装.png)\n\n## 3.Git操作入门 \n\n### 3.1Git基本工作流程(理解)\n\n本地仓库\n\n![31_Git基本工作流程](./day10-Git.img/31_Git基本工作流程.png)\n\n### 3.2Git命令行操作(应用)\n\n+ git常用命令\n\n  | 命令                   | 作用                         |\n  | -------------------- | -------------------------- |\n  | git init             | 初始化，创建 git 仓库              |\n  | git status           | 查看 git 状态 （文件是否进行了添加、提交操作） |\n  | git add 文件名          | 添加，将指定文件添加到暂存区             |\n  | git commit -m '提交信息' | 提交，将暂存区文件提交到历史仓库           |\n  | git log              | 查看日志（ git 提交的历史日志）         |\n\n+ 操作步骤\n\n  1. 创建工作目录、初始化本地 git 仓库\n\n     ![32_Git工作流程](./day10-Git.img/32_Git工作流程.png)\n\n  2. 新建一个 test.txt 文件（暂不执行添加操作）\n\n  3. 使用 status 命令，查看状态\n\n     ![33_Git工作流程](./day10-Git.img/33_Git工作流程.png)\n\n  4. 使用 add 命令添加，并查看状态\n\n     ![34_Git工作流程](./day10-Git.img/34_Git工作流程.png)\n\n  5. 使用 commit 命令，提交到本地历史仓库\n\n     ![35_Git工作流程](./day10-Git.img/35_Git工作流程.png)\n\n  6. 使用 log 命令，查看日志\n\n     ![36_Git工作流程](./day10-Git.img/36_Git工作流程.png)\n\n  7. 修改 test.txt 文件\n\n     ![37_Git工作流程](./day10-Git.img/37_Git工作流程.png)\n\n  8. 添加并提交，查看日志\n\n     ![38_Git工作流程](./day10-Git.img/38_Git工作流程.png)\n\n### 3.3Git图形化工具操作(理解)\n\n1. 创建工作目录、初始化本地 git 仓库\n\n   ![39_Git工作流程](./day10-Git.img/39_Git工作流程.png)\n\n   ![40_Git工作流程](./day10-Git.img/40_Git工作流程.png)\n\n2. 新建一个 test.txt 文件（暂不执行添加操作）\n\n3. 选中文件右键，选择TortoiseGit，之后选择添加\n\n   ![41_Git工作流程](./day10-Git.img/41_Git工作流程.png)\n\n4. 空白处右键,Git提交,提交到本地历史仓库\n\n   ![42_Git工作流程](./day10-Git.img/42_Git工作流程.png)\n\n5. 空白处右键,TortoiseGit,显示日志,可以产看日志信息\n\n   ![43_Git工作流程](./day10-Git.img/43_Git工作流程.png)\n\n6. 修改 test.txt 文件\n\n7. 添加并提交，查看日志\n\n## 4.Git版本管理 \n\n### 4.1历史版本切换(理解)\n\n![44_历史版本切换](./day10-Git.img/44_历史版本切换.png)\n\n+ 准备动作\n\n  1. 查看 my_project 的 log 日志\n     git reflog ：可以查看所有分支的所有操作记录（包括已经被删除的 commit 记录的操作）\n  2. 增加一次新的修改记录\n\n+ 需求: 将代码切换到第二次修改的版本\n\n  指令：git reset --hard 版本唯一索引值\n\n### 4.2分支管理介绍(理解)\n\n+ 分支\n  + 由每次提交的代码，串成的一条时间线\n  + 使用分支意味着你可以把你的工作从开发主线上分离开来,以免影响开发主线\n+ 分支的使用场景\n  1. 周期较长的模块开发\n     假设你准备开发一个新功能，但是需要一个月才能完成\n     第一周写了20%的代码，突然发现原来已经写好的功能出现了一个严重的Bug\n     那现在就需要放下手中的新功能，去修复Bug\n     但这20%的代码不能舍弃，并且也担心丢失，这就需要开启一个新的版本控制。\n  2. 尝试性的模块开发\n     业务人员给我们提出了一个需求，经过我们的思考和分析\n     该需求应该可以使用技术手段进行实现。\n     但是我们还不敢确定，我们就可以去创建一个分支基于分支进行尝试性开发。\n\n\n+ 分支工作流程\n\n  + Master: 指向提交的代码版本\n\n  + Header: 指向当前所使用的的分支\n\n    ![45_分支工作流程介绍](./day10-Git.img/45_分支工作流程介绍.png)\n\n### 4.3分支管理操作(应用)\n\n+ 创建和切换\n\n  创建命令：git branch 分支名\n  切换命令：git checkout 分支名\n\n+ 新分支添加文件\n\n  查看文件命令：ls\n\n  总结：不同分支之间的关系是平行的关系，不会相互影响\n\n+ 合并分支\n\n  合并命令：git merge 分支名\n\n+ 删除分支\n\n  删除命令：git branch -d 分支名\n\n+ 查看分支列表\n\n  查看命令：git branch\n\n## 5.远程仓库\n\n### 5.1远程仓库工作流程(理解)\n\n![46_远程仓库](./day10-Git.img/46_远程仓库.png)\n\n### 5.2远程仓库平台介绍(理解)\n\n+ GitHub\n\n  域名：https://github.com\n  介绍：GitHub是全球最大的开源项目托管平台，俗称大型程序员社区化交友网站\n\n  ​\t    各类好玩有趣的开源项目，只有想不到，没有找不到。\n\n+ 码云\n\n  域名：https://gitee.com\n  介绍：码云是全国最大的开源项目托管平台，良心平台，速度快，提供免费私有库\n\n### 5.3码云的注册(应用)\n\n![47_码云的注册](./day10-Git.img/47_码云的注册.png)\n\n![48_码云的注册](./day10-Git.img/48_码云的注册.png)\n\n![49_码云的注册](./day10-Git.img/49_码云的注册.png)\n\n### 5.4先有本地项目,远程为空(应用)\n\n+ 步骤\n\n  1. 创建本地仓库\n  2. 创建或修改文件，添加（add）文件到暂存区，提交（commit）到本地仓库\n  3. 创建远程仓库\n  4. 推送到远程仓库\n\n+ 创建远程仓库\n\n  ![50_创建远程仓库](./day10-Git.img/50_创建远程仓库.png)\n\n  ![51_创建远程仓库](./day10-Git.img/51_创建远程仓库.png)\n\n+ 生成SSH公钥\n\n  + 推送代码之前，需要先配置SSH公钥\n\n    ![52_配置SSH公钥](./day10-Git.img/52_配置SSH公钥.png)\n\n  + 生成SSH公钥步骤\n\n    1. 设置Git账户\n\n       + git config user.name（查看git账户）\n       + git config user.email（查看git邮箱）\n       + git config --global user.name “账户名”（设置全局账户名）\n       + git config --global user.email “邮箱”（设置全局邮箱）\n       + cd ~/.ssh（查看是否生成过SSH公钥）\n\n       ![53_配置SSH公钥](./day10-Git.img/53_配置SSH公钥.png)\n\n    2. 生成SSH公钥\n\n       + 生成命令: ssh-keygen –t rsa –C “邮箱” ( 注意：这里需要敲3次回车)\n\n       ![54_配置SSH公钥](./day10-Git.img/54_配置SSH公钥.png)\n\n       + 查看命令: cat ~/.ssh/id-rsa.pub\n\n       ![55_配置SSH公钥](./day10-Git.img/55_配置SSH公钥.png)\n\n    3. 设置账户公钥\n\n       ![56_配置SSH公钥](./day10-Git.img/56_配置SSH公钥.png)\n\n       ![57_配置SSH公钥](./day10-Git.img/57_配置SSH公钥.png)\n\n    4. 公钥测试\n\n       + 命令: ssh -T git@gitee.com\n\n       ![58_配置SSH公钥](./day10-Git.img/58_配置SSH公钥.png)\n\n+  推送到远程仓库\n\n  + 步骤\n\n    1. 为远程仓库的URL（网址），自定义仓库名称\n    2. 推送\n\n  + 命令\n       git remote add 远程名称 远程仓库URL\n       git push -u 仓库名称 分支名\n\n    ![59_配置SSH公钥](./day10-Git.img/59_配置SSH公钥.png)\n\n    ![60_配置SSH公钥](./day10-Git.img/60_配置SSH公钥.png)\n\n### 5.5先有远程仓库,本地为空(应用)\n\n+ 步骤\n  1. 将远程仓库的代码，克隆到本地仓库\n    克隆命令：git clone 仓库地址\n  2. 创建新文件，添加并提交到本地仓库\n  3. 推送至远程仓库\n  4. 项目拉取更新\n    拉取命令：git pull 远程仓库名 分支名\n\n### 5.6代码冲突(应用)\n\n+ 产生原因:\n\n  两个程序员操作同一个文件,其中一个程序员在修改文件后,push到远程仓库,另一个程序员应该先pull将最新的代码更新到本地仓库后,在修改代码,之后push到远程仓库,结果他没有先pull将最新的代码更新到本地仓库,而是直接将自己的代码push到远程仓库,这样就可能会导致代码冲突\n\n![61_代码冲突](./day10-Git.img/61_代码冲突.png)\n\n\n\n![62_代码冲突](./day10-Git.img/62_代码冲突.png)\n\n![63_代码冲突](./day10-Git.img/63_代码冲突.png)\n\n+ 如何解决冲突\n\n  <<<<<<<和>>>>>>>中间的内容,就是冲突部分\n\n  1. 修改冲突行，保存，即可解决冲突。\n  2. 重新add冲突文件并commit到本地仓库，重新push到远程\n\n## 6.IDEA集成Git \n\n### 6.1IDEA中配置Git(应用)\n\n1. File -> Settings\n\n![64_IDEA中配置Git](./day10-Git.img/64_IDEA中配置Git.png)\n\n2. Version Control -> Git -> 指定git.exe存放目录\n\n![65_IDEA中配置Git](./day10-Git.img/65_IDEA中配置Git.png)\n\n3. 点击Test测试\n\n![66_IDEA中配置Git](./day10-Git.img/66_IDEA中配置Git.png)\n\n### 6.2创建本地仓库(应用)\n\n1. VCS->Import into Version Control->Create Git Repository\n\n   ![67_创建本地仓库](./day10-Git.img/67_创建本地仓库.png)\n\n2. 选择工程所在的目录,这样就创建好本地仓库了\n\n   ![68_创建本地仓库](./day10-Git.img/68_创建本地仓库.png)\n\n3. 点击git后边的对勾,将当前项目代码提交到本地仓库\n\n   注意: 项目中的配置文件不需要提交到本地仓库中,提交时,忽略掉即可\n\n   ![69_创建本地仓库](./day10-Git.img/69_创建本地仓库.png)\n\n### 6.3版本切换(应用)\n\n+ 方式一: 控制台Version Control->Log->Reset Current Branch...->Reset\n\n  这种切换的特点是会抛弃原来的提交记录\n\n  ![70_版本切换](./day10-Git.img/70_版本切换.png)\n\n+ 方式二:控制台Version Control->Log->Revert Commit->Merge->处理代码->commit\n\n  这种切换的特点是会当成一个新的提交记录,之前的提交记录也都保留\n\n  ![71_版本切换](./day10-Git.img/71_版本切换.png)\n\n  ![72_版本切换](./day10-Git.img/72_版本切换.png)\n\n  ​\t\t![73_版本切换](./day10-Git.img/73_版本切换.png)\n\n\n\n### 6.4分支管理(应用)\n\n+ 创建分支\n\n  VCS->Git->Branches->New Branch->给分支起名字->ok\n\n  ![74_创建分支](./day10-Git.img/74_创建分支.png)\n\n+ 切换分支\n\n  idea右下角Git->选择要切换的分支->checkout\n\n  ![75_切换分支](./day10-Git.img/75_切换分支.png)\n\n+ 合并分支\n\n  VCS->Git->Merge changes->选择要合并的分支->merge\n\n  ![76_合并分支](./day10-Git.img/76_合并分支.png)\n\n  处理分支中的代码\n\n  ![77_合并分支](./day10-Git.img/77_合并分支.png)\n\n  ![78_合并分支](./day10-Git.img/78_合并分支.png)\n\n  ![79_合并分支](./day10-Git.img/79_合并分支.png)\n\n+ 删除分支\n\n  idea右下角->选中要删除的分支->Delete\n\n  ![80_删除分支](./day10-Git.img/80_删除分支.png)\n\n### 6.5本地仓库推送到远程仓库(应用)\n\n1. VCS->Git->Push->点击master Define remote\n\n   ![81_本地仓库推送到远程仓库](./day10-Git.img/81_本地仓库推送到远程仓库.png)\n\n2. 将远程仓库的路径复制过来->Push\n\n   ![82_本地仓库推送到远程仓库](./day10-Git.img/82_本地仓库推送到远程仓库.png)\n\n### 6.6远程仓库克隆到本地仓库(应用)\n\nFile->Close Project->Checkout from Version Control->Git->指定远程仓库的路径->指定本地存放的路径->clone\n\n![83_远程仓库克隆到本地仓库](./day10-Git.img/83_远程仓库克隆到本地仓库.png)\n\n\n\n\n\n\n\n\n\n"},"9d3e":function(n,e,t){"use strict";t.r(e),e["default"]='## 正确使用 equals 方法\n\nObject的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。 \n\n举个例子：\n\n```java\n// 不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常\nString str = null;\nif (str.equals("SnailClimb")) {\n  ...\n} else {\n  ..\n}\n```\n\n运行上面的程序会抛出空指针异常，但是我们把第二行的条件判断语句改为下面这样的话，就不会抛出空指针异常，else 语句块得到执行。：\n\n```java\n"SnailClimb".equals(str);// false \n```\n不过更推荐使用 `java.util.Objects#equals`(JDK7 引入的工具类)。\n\n```java\nObjects.equals(null,"SnailClimb");// false\n```\n我们看一下`java.util.Objects#equals`的源码就知道原因了。\n```java\npublic static boolean equals(Object a, Object b) {\n    // 可以避免空指针异常。如果a=null的话此时a.equals(b)就不会得到执行，避免出现空指针异常。\n    return (a == b) || (a != null && a.equals(b));\n}\n```\n\n**注意：**\n\nReference:[Java中equals方法造成空指针异常的原因及解决方案](https://blog.csdn.net/tick_tock97/article/details/72824894)\n\n- 每种原始类型都有默认值一样，如int默认值为 0，boolean 的默认值为 false，null 是任何引用类型的默认值，不严格的说是所有 Object 类型的默认值。\n- 可以使用 == 或者 != 操作来比较null值，但是不能使用其他算法或者逻辑操作。在Java中`null == null`将返回true。\n- 不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常\n\n## 整型包装类值的比较\n\n所有整型包装类对象值的比较必须使用equals方法。\n\n先看下面这个例子：\n\n```java\nInteger i1 = 40;\nInteger i2 = new Integer(40);\nSystem.out.println(i1==i2);//false\n```\n\n`Integer i1=40` 这一行代码会发生装箱，也就是说这行代码等价于 `Integer i1=Integer.valueOf(40)` 。因此，`i1` 直接使用的是常量池中的对象。而`Integer i1 = new Integer(40)` 会直接创建新的对象。因此，输出 false 。\n\n记住：**所有整型包装类对象之间值的比较，全部使用 `equals()`  方法比较**。\n\n![](Java基础知识疑难点.assets/20210313164740893.png)\n\n**注意：** 如果你的IDE(IDEA/Eclipse)上安装了阿里巴巴的p3c插件，这个插件如果检测到你用 ==的话会报错提示，推荐安装一个这个插件，很不错。\n\n## BigDecimal\n\n### BigDecimal 的用处\n\n《阿里巴巴Java开发手册》中提到：**浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。** 具体原理和浮点数的编码方式有关，这里就不多提了，我们下面直接上实例：\n\n```java\nfloat a = 1.0f - 0.9f;\nfloat b = 0.9f - 0.8f;\nSystem.out.println(a);// 0.100000024\nSystem.out.println(b);// 0.099999964\nSystem.out.println(a == b);// false\n```\n具有基本数学知识的我们很清楚的知道输出并不是我们想要的结果（**精度丢失**），我们如何解决这个问题呢？一种很常用的方法是：**使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作。**\n\n```java\nBigDecimal a = new BigDecimal("1.0");\nBigDecimal b = new BigDecimal("0.9");\nBigDecimal c = new BigDecimal("0.8");\n\nBigDecimal x = a.subtract(b); \nBigDecimal y = b.subtract(c); \n\nSystem.out.println(x); /* 0.1 */\nSystem.out.println(y); /* 0.1 */\nSystem.out.println(Objects.equals(x, y)); /* true */\n```\n\n### BigDecimal 的大小比较\n\n`a.compareTo(b)` : 返回 -1 表示 `a` 小于 `b`，0 表示 `a` 等于 `b` ， 1表示 `a` 大于 `b`。\n\n```java\nBigDecimal a = new BigDecimal("1.0");\nBigDecimal b = new BigDecimal("0.9");\nSystem.out.println(a.compareTo(b));// 1\n```\n### BigDecimal 保留几位小数\n\n通过 `setScale`方法设置保留几位小数以及保留规则。保留规则有挺多种，不需要记，IDEA会提示。\n\n```java\nBigDecimal m = new BigDecimal("1.255433");\nBigDecimal n = m.setScale(3,BigDecimal.ROUND_HALF_DOWN);\nSystem.out.println(n);// 1.255\n```\n\n### BigDecimal 的使用注意事项\n\n注意：我们在使用BigDecimal时，为了防止精度丢失，推荐使用它的 **BigDecimal(String)** 构造方法来创建对象。《阿里巴巴Java开发手册》对这部分内容也有提到如下图所示。\n\n![《阿里巴巴Java开发手册》对这部分BigDecimal的描述](Java基础知识疑难点.assets/BigDecimal-1635566467839.png)\n\n### 总结\n\nBigDecimal 主要用来操作（大）浮点数，BigInteger 主要用来操作大整数（超过 long 类型）。\n\nBigDecimal 的实现利用到了 BigInteger, 所不同的是 BigDecimal 加入了小数位的概念\n\n## 基本数据类型与包装数据类型的使用标准\n\nReference:《阿里巴巴Java开发手册》\n\n- 【强制】所有的 POJO 类属性必须使用包装数据类型。\n- 【强制】RPC 方法的返回值和参数必须使用包装数据类型。\n- 【推荐】所有的局部变量使用基本数据类型。\n\n比如我们如果自定义了一个Student类,其中有一个属性是成绩score,如果用Integer而不用int定义,一次考试,学生可能没考,值是null,也可能考了,但考了0分,值是0,这两个表达的状态明显不一样.\n\n**说明** :POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或者入库检查，都由使用者来保证。\n\n**正例** : 数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。\n\n**反例** : 比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线。所以包装数据类型的 null 值，能够表示额外的信息，如:远程调用失败，异常退出。\n\n'},a105:function(n,e,t){"use strict";t.r(e),e["default"]="> 本文是作者读 《大型网站技术架构》所做的思维导图，在这里分享给各位，公众号(JavaGuide)后台回复：“架构”。即可获得下面图片的源文件以及思维导图源文件！\n\n\x3c!-- MarkdownTOC --\x3e\n\n- [1. 大型网站架构演化](#1-大型网站架构演化)\n- [2. 大型架构模式](#2-大型架构模式)\n- [3. 大型网站核心架构要素](#3-大型网站核心架构要素)\n- [4. 瞬时响应:网站的高性能架构](#4-瞬时响应网站的高性能架构)\n- [5. 万无一失:网站的高可用架构](#5-万无一失网站的高可用架构)\n- [6. 永无止境:网站的伸缩性架构](#6-永无止境网站的伸缩性架构)\n- [7. 随机应变:网站的可扩展性架构](#7-随机应变网站的可扩展性架构)\n- [8. 固若金汤:网站的安全机构](#8-固若金汤网站的安全机构)\n\n\x3c!-- /MarkdownTOC --\x3e\n\n\n### 1. 大型网站架构演化\n\n![1. 大型网站架构演化](8 张图读懂大型网站技术架构.assets/1 大型网站架构演化.png)\n\n### 2. 大型架构模式\n\n![2. 大型架构模式](8 张图读懂大型网站技术架构.assets/2 大型架构模式.png)\n\n### 3. 大型网站核心架构要素\n\n![3. 大型网站核心架构要素](8 张图读懂大型网站技术架构.assets/3 大型网站核心架构要素.png)\n\n### 4. 瞬时响应:网站的高性能架构\n\n![4. 瞬时响应:网站的高性能架构](8 张图读懂大型网站技术架构.assets/4 瞬时响应：网站的高性能架构.png)\n\n### 5. 万无一失:网站的高可用架构\n\n![5. 万无一失:网站的高可用架构](8 张图读懂大型网站技术架构.assets/5 万无一失：网站的高可用架构.png)\n\n### 6. 永无止境:网站的伸缩性架构\n\n![6. 永无止境:网站的伸缩性架构](8 张图读懂大型网站技术架构.assets/6 永无止境：网站的伸缩性架构.png)\n\n### 7. 随机应变:网站的可扩展性架构\n\n![7. 随机应变:网站的可扩展性架构](8 张图读懂大型网站技术架构.assets/7 随机应变：网站的可扩展架构.png)\n\n### 8. 固若金汤:网站的安全机构\n\n![enter image description here](8 张图读懂大型网站技术架构.assets/8 固若金汤：网站的安全架构-1635782948882.png)\n"},a3ca:function(n,e,t){"use strict";t.r(e),e["default"]='点击关注[公众号](#公众号)及时获取笔主最新更新文章，并可免费领取本文档配套的《Java面试突击》以及Java工程师必备学习资源。\n\n\x3c!-- TOC --\x3e\n\n- [控制反转(IoC)和依赖注入(DI)](#控制反转ioc和依赖注入di)\n- [工厂设计模式](#工厂设计模式)\n- [单例设计模式](#单例设计模式)\n- [代理设计模式](#代理设计模式)\n    - [代理模式在 AOP 中的应用](#代理模式在-aop-中的应用)\n    - [Spring AOP 和 AspectJ AOP 有什么区别?](#spring-aop-和-aspectj-aop-有什么区别)\n- [模板方法](#模板方法)\n- [观察者模式](#观察者模式)\n    - [Spring 事件驱动模型中的三种角色](#spring-事件驱动模型中的三种角色)\n        - [事件角色](#事件角色)\n        - [事件监听者角色](#事件监听者角色)\n        - [事件发布者角色](#事件发布者角色)\n    - [Spring 的事件流程总结](#spring-的事件流程总结)\n- [适配器模式](#适配器模式)\n    - [spring AOP中的适配器模式](#spring-aop中的适配器模式)\n    - [spring MVC中的适配器模式](#spring-mvc中的适配器模式)\n- [装饰者模式](#装饰者模式)\n- [总结](#总结)\n- [参考](#参考)\n\n\x3c!-- /TOC --\x3e\n\nJDK 中用到了那些设计模式?Spring 中用到了那些设计模式?这两个问题，在面试中比较常见。我在网上搜索了一下关于 Spring 中设计模式的讲解几乎都是千篇一律，而且大部分都年代久远。所以，花了几天时间自己总结了一下，由于我的个人能力有限，文中如有任何错误各位都可以指出。另外，文章篇幅有限，对于设计模式以及一些源码的解读我只是一笔带过，这篇文章的主要目的是回顾一下 Spring 中的设计模式。\n\nDesign Patterns(设计模式) 表示面向对象软件开发中最好的计算机编程实践。 Spring 框架中广泛使用了不同类型的设计模式，下面我们来看看到底有哪些设计模式?\n\n## 控制反转(IoC)和依赖注入(DI)\n\n**IoC(Inversion of Control,控制反转)** 是Spring 中一个非常非常重要的概念，它不是什么技术，而是一种解耦的设计思想。它的主要目的是借助于“第三方”(Spring 中的 IOC 容器) 实现具有依赖关系的对象之间的解耦(IOC容器管理对象，你只管使用即可)，从而降低代码之间的耦合度。**IOC 是一个原则，而不是一个模式，以下模式（但不限于）实现了IoC原则。**\n\n![ioc-patterns](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ioc-patterns.png)\n\n**Spring IOC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。** IOC 容器负责创建对象，将对象连接在一起，配置这些对象，并从创建中处理这些对象的整个生命周期，直到它们被完全销毁。\n\n在实际项目中一个 Service 类如果有几百甚至上千个类作为它的底层，我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IOC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。关于Spring IOC 的理解，推荐看这一下知乎的一个回答：<https://www.zhihu.com/question/23277575/answer/169698662>  ，非常不错。\n\n**控制反转怎么理解呢?** 举个例子："对象a 依赖了对象 b，当对象 a 需要使用 对象 b的时候必须自己去创建。但是当系统引入了 IOC 容器后， 对象a 和对象 b 之前就失去了直接的联系。这个时候，当对象 a 需要使用 对象 b的时候， 我们可以指定 IOC 容器去创建一个对象b注入到对象 a 中"。 对象 a 获得依赖对象 b 的过程,由主动行为变为了被动行为，控制权反转，这就是控制反转名字的由来。\n\n**DI(Dependecy Inject,依赖注入)是实现控制反转的一种设计模式，依赖注入就是将实例变量传入到一个对象中去。**\n\n## 工厂设计模式\n\nSpring使用工厂模式可以通过 `BeanFactory` 或 `ApplicationContext` 创建 bean 对象。\n\n**两者对比：**\n\n-  `BeanFactory` ：延迟注入(使用到某个 bean 的时候才会注入),相比于`ApplicationContext` 来说会占用更少的内存，程序启动速度更快。\n- `ApplicationContext` ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。`BeanFactory` 仅提供了最基本的依赖注入支持，` ApplicationContext` 扩展了 `BeanFactory` ,除了有`BeanFactory`的功能还有额外更多功能，所以一般开发人员使用` ApplicationContext`会更多。\n\nApplicationContext的三个实现类：\n\n1. `ClassPathXmlApplication`：把上下文文件当成类路径资源。\n2.  `FileSystemXmlApplication`：从文件系统中的 XML 文件载入上下文定义信息。\n3. `XmlWebApplicationContext`：从Web系统中的XML文件载入上下文定义信息。\n\nExample:\n\n```java\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.FileSystemXmlApplicationContext;\n \npublic class App {\n\tpublic static void main(String[] args) {\n\t\tApplicationContext context = new FileSystemXmlApplicationContext(\n\t\t\t\t"C:/work/IOC Containers/springframework.applicationcontext/src/main/resources/bean-factory-config.xml");\n \n\t\tHelloApplicationContext obj = (HelloApplicationContext) context.getBean("helloApplicationContext");\n\t\tobj.getMsg();\n\t}\n}\n```\n\n## 单例设计模式\n\n在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。\n\n**使用单例模式的好处:**\n\n- 对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；\n- 由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。\n\n**Spring 中 bean 的默认作用域就是 singleton(单例)的。** 除了 singleton 作用域，Spring 中 bean 还有下面几种作用域：\n\n- prototype : 每次请求都会创建一个新的 bean 实例。\n- request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。\n- session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。\n- global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话\n\n**Spring 实现单例的方式：**\n\n- xml : `<bean id="userService" class="top.snailclimb.UserService" scope="singleton"/>`\n- 注解：`@Scope(value = "singleton")`\n\n**Spring 通过 `ConcurrentHashMap` 实现单例注册表的特殊方式实现单例模式。Spring 实现单例的核心代码如下**\n\n```java\n// 通过 ConcurrentHashMap（线程安全） 实现单例注册表\nprivate final Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(64);\n\npublic Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {\n        Assert.notNull(beanName, "\'beanName\' must not be null");\n        synchronized (this.singletonObjects) {\n            // 检查缓存中是否存在实例  \n            Object singletonObject = this.singletonObjects.get(beanName);\n            if (singletonObject == null) {\n                //...省略了很多代码\n                try {\n                    singletonObject = singletonFactory.getObject();\n                }\n                //...省略了很多代码\n                // 如果实例对象在不存在，我们注册到单例注册表中。\n                addSingleton(beanName, singletonObject);\n            }\n            return (singletonObject != NULL_OBJECT ? singletonObject : null);\n        }\n    }\n    //将对象添加到单例注册表\n    protected void addSingleton(String beanName, Object singletonObject) {\n            synchronized (this.singletonObjects) {\n                this.singletonObjects.put(beanName, (singletonObject != null ? singletonObject : NULL_OBJECT));\n\n            }\n        }\n}\n```\n\n## 代理设计模式\n\n### 代理模式在 AOP 中的应用\n\nAOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，**却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来**，便于**减少系统的重复代码**，**降低模块间的耦合度**，并**有利于未来的可拓展性和可维护性**。\n\n**Spring AOP 就是基于动态代理的**，如果要代理的对象，实现了某个接口，那么Spring AOP会使用**JDK Proxy**，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用**Cglib** ，这时候Spring AOP会使用 **Cglib** 生成一个被代理对象的子类来作为代理，如下图所示：\n\n![SpringAOPProcess](Spring-Design-Patterns.assets/SpringAOPProcess.jpg)\n\n当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ  ，AspectJ  应该算的上是 Java 生态系统中最完整的 AOP 框架了。\n\n使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。\n\n### Spring AOP 和 AspectJ AOP 有什么区别?\n\n**Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。** Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。\n\n Spring AOP 已经集成了 AspectJ  ，AspectJ  应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ  相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，\n\n如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。\n\n## 模板方法\n\n模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。\n\n```java\npublic abstract class Template {\n    //这是我们的模板方法\n    public final void TemplateMethod(){\n        PrimitiveOperation1();  \n        PrimitiveOperation2();\n        PrimitiveOperation3();\n    }\n\n    protected void  PrimitiveOperation1(){\n        //当前类实现\n    }\n    \n    //被子类实现的方法\n    protected abstract void PrimitiveOperation2();\n    protected abstract void PrimitiveOperation3();\n\n}\npublic class TemplateImpl extends Template {\n\n    @Override\n    public void PrimitiveOperation2() {\n        //当前类实现\n    }\n    \n    @Override\n    public void PrimitiveOperation3() {\n        //当前类实现\n    }\n}\n\n```\n\nSpring 中 `jdbcTemplate`、`hibernateTemplate` 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。\n\n## 观察者模式\n\n观察者模式是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。Spring 事件驱动模型就是观察者模式很经典的一个应用。Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。\n\n### Spring 事件驱动模型中的三种角色\n\n#### 事件角色\n\n `ApplicationEvent` (`org.springframework.context`包下)充当事件的角色,这是一个抽象类，它继承了`java.util.EventObject`并实现了 `java.io.Serializable`接口。\n\nSpring 中默认存在以下事件，他们都是对 `ApplicationContextEvent` 的实现(继承自`ApplicationContextEvent`)：\n\n- `ContextStartedEvent`：`ApplicationContext` 启动后触发的事件;\n- `ContextStoppedEvent`：`ApplicationContext` 停止后触发的事件;\n- `ContextRefreshedEvent`：`ApplicationContext` 初始化或刷新完成后触发的事件;\n- `ContextClosedEvent`：`ApplicationContext` 关闭后触发的事件。\n\n![ApplicationEvent-Subclass](Spring-Design-Patterns.assets/ApplicationEvent-Subclass.png)\n\n#### 事件监听者角色\n\n`ApplicationListener` 充当了事件监听者角色，它是一个接口，里面只定义了一个 `onApplicationEvent（）`方法来处理`ApplicationEvent`。`ApplicationListener`接口类源码如下，可以看出接口定义看出接口中的事件只要实现了 `ApplicationEvent`就可以了。所以，在 Spring中我们只要实现 `ApplicationListener` 接口的 `onApplicationEvent()` 方法即可完成监听事件\n\n```java\npackage org.springframework.context;\nimport java.util.EventListener;\n@FunctionalInterface\npublic interface ApplicationListener<E extends ApplicationEvent> extends EventListener {\n    void onApplicationEvent(E var1);\n}\n```\n\n#### 事件发布者角色\n\n`ApplicationEventPublisher` 充当了事件的发布者，它也是一个接口。\n\n```java\n@FunctionalInterface\npublic interface ApplicationEventPublisher {\n    default void publishEvent(ApplicationEvent event) {\n        this.publishEvent((Object)event);\n    }\n\n    void publishEvent(Object var1);\n}\n\n```\n\n`ApplicationEventPublisher` 接口的`publishEvent（）`这个方法在`AbstractApplicationContext`类中被实现，阅读这个方法的实现，你会发现实际上事件真正是通过`ApplicationEventMulticaster`来广播出去的。具体内容过多，就不在这里分析了，后面可能会单独写一篇文章提到。\n\n### Spring 的事件流程总结\n\n1. 定义一个事件: 实现一个继承自 `ApplicationEvent`，并且写相应的构造函数；\n2. 定义一个事件监听者：实现 `ApplicationListener` 接口，重写 `onApplicationEvent()` 方法；\n3. 使用事件发布者发布消息:  可以通过 `ApplicationEventPublisher  ` 的 `publishEvent()` 方法发布消息。\n\nExample:\n\n```java\n// 定义一个事件,继承自ApplicationEvent并且写相应的构造函数\npublic class DemoEvent extends ApplicationEvent{\n    private static final long serialVersionUID = 1L;\n\n    private String message;\n\n    public DemoEvent(Object source,String message){\n        super(source);\n        this.message = message;\n    }\n\n    public String getMessage() {\n         return message;\n          }\n\n    \n// 定义一个事件监听者,实现ApplicationListener接口，重写 onApplicationEvent() 方法；\n@Component\npublic class DemoListener implements ApplicationListener<DemoEvent>{\n\n    //使用onApplicationEvent接收消息\n    @Override\n    public void onApplicationEvent(DemoEvent event) {\n        String msg = event.getMessage();\n        System.out.println("接收到的信息是："+msg);\n    }\n\n}\n// 发布事件，可以通过ApplicationEventPublisher  的 publishEvent() 方法发布消息。\n@Component\npublic class DemoPublisher {\n\n    @Autowired\n    ApplicationContext applicationContext;\n\n    public void publish(String message){\n        //发布事件\n        applicationContext.publishEvent(new DemoEvent(this, message));\n    }\n}\n\n```\n\n当调用 `DemoPublisher ` 的 `publish()` 方法的时候，比如 `demoPublisher.publish("你好")` ，控制台就会打印出:`接收到的信息是：你好` 。\n\n## 适配器模式\n\n适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。\n\n### spring AOP中的适配器模式\t\n\n我们知道 Spring AOP 的实现是基于代理模式，但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是`AdvisorAdapter ` 。Advice 常用的类型有：`BeforeAdvice`（目标方法调用前,前置通知）、`AfterAdvice`（目标方法调用后,后置通知）、`AfterReturningAdvice`(目标方法执行结束后，return之前)等等。每个类型Advice（通知）都有对应的拦截器:`MethodBeforeAdviceInterceptor`、`AfterReturningAdviceAdapter`、`AfterReturningAdviceInterceptor`。Spring预定义的通知要通过对应的适配器，适配成 `MethodInterceptor`接口(方法拦截器)类型的对象（如：`MethodBeforeAdviceInterceptor` 负责适配 `MethodBeforeAdvice`）。\n\n### spring MVC中的适配器模式\n\n在Spring MVC中，`DispatcherServlet` 根据请求信息调用 `HandlerMapping`，解析请求对应的 `Handler`。解析到对应的 `Handler`（也就是我们平常说的 `Controller` 控制器）后，开始由`HandlerAdapter` 适配器处理。`HandlerAdapter` 作为期望接口，具体的适配器实现类用于对目标类进行适配，`Controller` 作为需要适配的类。\n\n**为什么要在 Spring MVC 中使用适配器模式？** Spring MVC 中的 `Controller` 种类众多，不同类型的 `Controller` 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，`DispatcherServlet` 直接获取对应类型的 `Controller`，需要的自行来判断，像下面这段代码一样：\n\n```java\nif(mappedHandler.getHandler() instanceof MultiActionController){  \n   ((MultiActionController)mappedHandler.getHandler()).xxx  \n}else if(mappedHandler.getHandler() instanceof XXX){  \n    ...  \n}else if(...){  \n   ...  \n}  \n```\n\n假如我们再增加一个 `Controller`类型就要在上面代码中再加入一行 判断语句，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。\n\n## 装饰者模式\n\n装饰者模式可以动态地给对象添加一些额外的属性或行为。相比于使用继承，装饰者模式更加灵活。简单点儿说就是当我们需要修改原有的功能，但我们又不愿直接去修改原有的代码时，设计一个Decorator套在原有代码外面。其实在 JDK 中就有很多地方用到了装饰者模式，比如 `InputStream`家族，`InputStream` 类下有 `FileInputStream` (读取文件)、`BufferedInputStream` (增加缓存,使读取文件速度大大提升)等子类都在不修改`InputStream` 代码的情况下扩展了它的功能。\n\n![装饰者模式示意图](Spring-Design-Patterns.assets/Decorator.jpg)\n\nSpring 中配置 DataSource 的时候，DataSource 可能是不同的数据库和数据源。我们能否根据客户的需求在少修改原有类的代码下动态切换不同的数据源？这个时候就要用到装饰者模式(这一点我自己还没太理解具体原理)。Spring 中用到的包装器模式在类名上含有 `Wrapper`或者 `Decorator`。这些类基本上都是动态地给一个对象添加一些额外的职责\n\n## 总结\n\nSpring 框架中用到了哪些设计模式？\n\n- **工厂设计模式** : Spring使用工厂模式通过 `BeanFactory`、`ApplicationContext` 创建 bean 对象。\n- **代理设计模式** : Spring AOP 功能的实现。\n- **单例设计模式** : Spring 中的 Bean 默认都是单例的。\n- **模板方法模式** : Spring 中 `jdbcTemplate`、`hibernateTemplate` 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。\n- **包装器设计模式** : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。\n- **观察者模式:** Spring 事件驱动模型就是观察者模式很经典的一个应用。\n- **适配器模式** :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配`Controller`。\n- ......\n\n## 参考\n\n- 《Spring技术内幕》\n- <https://blog.eduonix.com/java-programming-2/learn-design-patterns-used-spring-framework/>\n- <http://blog.yeamin.top/2018/03/27/单例模式-Spring单例实现原理分析/>\n- <https://www.tutorialsteacher.com/ioc/inversion-of-control> \n- <https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/observer.html>\n- <https://juejin.im/post/5a8eb261f265da4e9e307230>\n- <https://juejin.im/post/5ba28986f265da0abc2b6084>\n\n'},a445:function(n,e,t){"use strict";t.r(e),e["default"]='## 1. 方法概述\r\n\r\n### 1.1 方法的概念\r\n\r\n​\t方法（method）是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集\r\n\r\n* 注意：\r\n  * 方法必须先创建才可以使用，该过程成为方法定义\r\n  * 方法创建后并不是直接可以运行的，需要手动使用后，才执行，该过程成为方法调用\r\n\r\n## 2. 方法的定义和调用\r\n\r\n### 2.1 无参数方法定义和调用\r\n\r\n* 定义格式：\r\n\r\n  ```java\r\n  public static void 方法名 (   ) {\r\n  \t// 方法体;\r\n  }\r\n  ```\r\n\r\n* 范例：\r\n\r\n  ```java\r\n  public static void method (    ) {\r\n  \t// 方法体;\r\n  }\r\n  ```\r\n\r\n* 调用格式：\r\n\r\n  ```java\r\n  方法名();\r\n  ```\r\n\r\n* 范例：\r\n\r\n  ```java\r\n  method();\r\n  ```\r\n\r\n* 注意：\r\n\r\n  ​\t方法必须先定义，后调用，否则程序将报错\r\n\r\n### 2.2 方法的调用过程\r\n\r\n* 总结：每个方法在被调用执行的时候，都会进入栈内存，并且拥有自己独立的内存空间，方法内部代码调用完毕之后，会从栈内存中弹栈消失。\r\n\r\n  \r\n\r\n### 2.3 方法练习-奇偶数判断\r\n\r\n* 需求：判断一个数是奇数还是偶数\r\n* 代码：\r\n\r\n```java\r\npublic class Demo1Method {\r\n    /*\r\n\r\n        带参数方法的定义格式:\r\n                public static void 方法名  ( 参数 )  { … … }\r\n                public static void 方法名  ( 数据类型 变量名 )  { … … }\r\n\r\n        带参数方法的调用格式:\r\n                方法名 ( 参数 ) ;\r\n                方法名 ( 变量名/常量值 ) ;\r\n\r\n        tips: 参数可以是一个, 也可以是多个.\r\n\r\n        需求: 判断一个数是奇数还是偶数\r\n     */\r\n    public static void main(String[] args) {\r\n        isEvenNumber(10);\r\n    }\r\n\r\n    public static void isEvenNumber(int num){\r\n        if(num % 2 == 0){\r\n            System.out.println("偶数");\r\n        }else{\r\n            System.out.println("奇数");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 3. 带参数方法的定义和调用\r\n\r\n### 3.1 带参数方法定义和调用\r\n\r\n* 定义格式：\r\n\r\n  参数：由数据类型和变量名组成 -  数据类型 变量名\r\n\r\n  参数范例：int a\r\n\r\n  ```java\r\n  public static void 方法名 (参数1) {\r\n  \t方法体;\r\n  }\r\n  \r\n  public static void 方法名 (参数1, 参数2, 参数3...) {\r\n  \t方法体;\r\n  }\r\n  ```\r\n\r\n* 范例：\r\n\r\n  ```java\r\n  public static void isEvenNumber(int number){\r\n      ...\r\n  }\r\n  public static void getMax(int num1, int num2){\r\n      ...\r\n  }\r\n  ```\r\n\r\n  * 注意：\r\n\r\n  \t\t方法定义时，参数中的数据类型与变量名都不能缺少，缺少任意一个程序将报错\r\n\r\n  \t\t方法定义时，多个参数之间使用逗号( ，)分隔\r\n\r\n* 调用格式：\r\n\r\n  ```java\r\n  方法名(参数)；\r\n  \r\n  方法名(参数1,参数2);\r\n  ```\r\n\r\n* 范例：\r\n\r\n  ```java\r\n  isEvenNumber(10);\r\n  \r\n  getMax(10,20);\r\n  ```\r\n\r\n  * 方法调用时，参数的数量与类型必须与方法定义中的设置相匹配，否则程序将报错 \r\n\r\n### 3.2 形参和实参\r\n\r\n1. 形参：方法定义中的参数\r\n\r\n​          等同于变量定义格式，例如：int number\r\n\r\n2. 实参：方法调用中的参数\r\n\r\n​          等同于使用变量或常量，例如： 10  number\r\n\r\n### 3.3 带参数方法的练习-打印n-m之间所有的奇数\r\n\r\n* 需求：设计一个方法（print） 用于打印 n 到 m 之间所有的奇数\r\n* 思路：\r\n\r\n  ​\t1：定义方法，名称为print\r\n          2：为方法添加两个int类型的形参，准备接受调用者传递过来的实参\r\n          3：方法中设计for循环，循环从n开始，到m结束\r\n          4：循环中加入if判断，是奇数，则打印\r\n          5：main方法中调用print方法，传入两个实际参数\r\n* 代码：\r\n\r\n```java\r\npackage com.itheima.method2;\r\n\r\npublic class Demo2Method {\r\n    public static void main(String[] args) {\r\n        // 5：main方法中调用print方法，传入两个实际参数\r\n        print(20,10);\r\n    }\r\n\r\n    //1：定义方法，名称为print\r\n    // 2：为方法添加两个int类型的形参，准备接受调用者传递过来的实参\r\n    public static void print(int n, int m){\r\n        System.out.println(n + "到" + m + "之间的奇数为:");\r\n        // 3：方法中设计for循环，循环从n开始，到m结束\r\n        for(int i = 20; i <= 10; i++){\r\n            // 4：循环中加入if判断，是奇数，则打印\r\n            if(i % 2 == 1){\r\n                System.out.println(i);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n## 4. 带返回值方法的定义和调用\r\n\r\n### 4.1 带返回值方法定义和调用（掌握）\r\n\r\n* 定义格式\r\n\r\n  ```java\r\n  public static 数据类型 方法名 ( 参数 ) { \r\n  \treturn 数据 ;\r\n  }\r\n  ```\r\n\r\n* 范例\r\n\r\n  ```java\r\n  public static boolean isEvenNumber( int number ) {           \r\n  \treturn true ;\r\n  }\r\n  public static int getMax( int a, int b ) {\r\n  \treturn  100 ;\r\n  }\r\n  ```\r\n\r\n  * 注意：\r\n    * 方法定义时return后面的返回值与方法定义上的数据类型要匹配，否则程序将报错\r\n\r\n* 调用格式\r\n\r\n  ```java\r\n  方法名 ( 参数 ) ;\r\n  数据类型 变量名 = 方法名 ( 参数 ) ;\r\n  ```\r\n\r\n* 范例\r\n\r\n  ```java\r\n  isEvenNumber ( 5 ) ;\r\n  boolean  flag =  isEvenNumber ( 5 ); \r\n  ```\r\n\r\n  * 注意：\r\n    * 方法的返回值通常会使用变量接收，否则该返回值将无意义\r\n\r\n### 4.2 带返回值方法的练习-求两个数的最大值(应用)\r\n\r\n* 需求：设计一个方法可以获取两个数的较大值，数据来自于参数\r\n\r\n* 思路：\r\n\r\n  1. 定义一个方法，声明两个形参接收计算的数值，求出结果并返回\r\n  2. 使用 if 语句 得出 a 和 b 之间的最大值，根据情况return具体结果\r\n  3. 在main()方法中调用定义好的方法并使用 【 变量保存 】\r\n\r\n* 代码：\r\n\r\n  ```java\r\n   /*\r\n          需求：设计一个方法可以获取两个数的较大值，数据来自于参数\r\n  \r\n          1. 定义一个方法，声明两个形参接收计算的数值，求出结果并返回\r\n          2. 使用 if 语句 得出 a 和 b 之间的最大值，根据情况return具体结果\r\n          3. 在main()方法中调用定义好的方法并使用 【 变量保存 】\r\n       */\r\n      public static void main(String[] args) {\r\n          // 3. 在main()方法中调用定义好的方法并使用 【 变量保存 】\r\n          System.out.println(getMax(10,20));  // 输出调用\r\n  \r\n          int result = getMax(10,20);\r\n          System.out.println(result);\r\n  \r\n          for(int i = 1; i <= result; i++){\r\n              System.out.println("HelloWorld");\r\n          }\r\n  \r\n      }\r\n  \r\n      // 方法可以获取两个数的较大值\r\n      public static int getMax(int a, int b){\r\n          if(a > b){\r\n              return a;\r\n          }else{\r\n              return b;\r\n          }\r\n      }\r\n  \r\n  }\r\n  \r\n  ```\r\n\r\n## 5. 方法的注意事项\r\n\r\n### 5.1 方法的通用格式（掌握）\r\n\r\n- 格式：\r\n\r\n  ```java\r\n  public static 返回值类型 方法名(参数) {\r\n     方法体; \r\n     return 数据 ;\r\n  }\r\n  ```\r\n\r\n- 解释：\r\n\r\n  - public static \t修饰符，目前先记住这个格式\r\n\r\n    返回值类型\t方法操作完毕之后返回的数据的数据类型\r\n\r\n    ​\t\t\t如果方法操作完毕，没有数据返回，这里写void，而且方法体中一般不写return\r\n\r\n     方法名\t\t调用方法时候使用的标识\r\n\r\n     参数\t\t由数据类型和变量名组成，多个参数之间用逗号隔开\r\n\r\n     方法体\t\t完成功能的代码块\r\n\r\n     return\t\t如果方法操作完毕，有数据返回，用于把数据返回给调用者\r\n\r\n- 定义方法时，要做到两个明确\r\n\r\n  - 明确返回值类型：主要是明确方法操作完毕之后是否有数据返回，如果没有，写void；如果有，写对应的数据类型\r\n  - 明确参数：主要是明确参数的类型和数量\r\n\r\n- 调用方法时的注意：\r\n\r\n  - void类型的方法，直接调用即可\r\n  - 非void类型的方法，推荐用变量接收调用\r\n\r\n\r\n\r\n### 5.2 方法的注意事项\r\n\r\n* 方法不能嵌套定义\r\n\r\n  * 示例代码：\r\n\r\n    ```java\r\n    public class MethodDemo {\r\n        public static void main(String[] args) {\r\n    \r\n        }\r\n    \r\n        public static void methodOne() {\r\n    \t\tpublic static void methodTwo() {\r\n           \t\t// 这里会引发编译错误!!!\r\n        \t}\r\n        }\r\n    }\r\n    ```\r\n\r\n* void表示无返回值，可以省略return，也可以单独的书写return，后面不加数据\r\n\r\n  * 示例代码：\r\n\r\n    ```java\r\n    public class MethodDemo {\r\n        public static void main(String[] args) {\r\n    \r\n        }\r\n        public static void methodTwo() {\r\n            //return 100; 编译错误，因为没有具体返回值类型\r\n            return;\t\r\n            //System.out.println(100); return语句后面不能跟数据或代码\r\n        }\r\n    }\r\n    ```\r\n\r\n## 6. 方法重载\r\n\r\n### 6.1 方法重载\r\n\r\n* 方法重载概念\r\n\r\n  方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载\r\n\r\n  * 多个方法在同一个类中\r\n  * 多个方法具有相同的方法名\r\n  * 多个方法的参数不相同，类型不同或者数量不同\r\n\r\n* 注意：\r\n\r\n  * 重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式\r\n  * 重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载\r\n\r\n* 正确范例：\r\n\r\n  ```java\r\n  public class MethodDemo {\r\n  \tpublic static void fn(int a) {\r\n      \t//方法体\r\n      }\r\n      public static int fn(double a) {\r\n      \t//方法体\r\n      }\r\n  }\r\n  \r\n  public class MethodDemo {\r\n  \tpublic static float fn(int a) {\r\n      \t//方法体\r\n      }\r\n      public static int fn(int a , int b) {\r\n      \t//方法体\r\n      }\r\n  }\r\n  ```\r\n\r\n* 错误范例：\r\n\r\n  ```java\r\n  public class MethodDemo {\r\n  \tpublic static void fn(int a) {\r\n      \t//方法体\r\n      }\r\n      public static int fn(int a) { \t/*错误原因：重载与返回值无关*/\r\n      \t//方法体\r\n      }\r\n  }\r\n  \r\n  public class MethodDemo01 {\r\n      public static void fn(int a) {\r\n          //方法体\r\n      }\r\n  } \r\n  public class MethodDemo02 {\r\n      public static int fn(double a) { /*错误原因：这是两个类的两个fn方法*/\r\n          //方法体\r\n      }\r\n  }\r\n  ```\r\n\r\n### 6.2 方法重载练习\r\n\r\n* 需求：使用方法重载的思想，设计比较两个整数是否相同的方法，兼容全整数类型（byte,short,int,long） \r\n\r\n* 思路：\r\n\r\n  ​\t①定义比较两个数字的是否相同的方法compare()方法，参数选择两个int型参数\r\n\r\n  ​\t②定义对应的重载方法，变更对应的参数类型，参数变更为两个long型参数\r\n\r\n  ​\t③定义所有的重载方法，两个byte类型与两个short类型参数 \r\n\r\n  ​\t④完成方法的调用，测试运行结果 \r\n\r\n* 代码：\r\n\r\n  ```java\r\n  public class MethodTest {\r\n      public static void main(String[] args) {\r\n          //调用方法\r\n          System.out.println(compare(10, 20));\r\n          System.out.println(compare((byte) 10, (byte) 20));\r\n          System.out.println(compare((short) 10, (short) 20));\r\n          System.out.println(compare(10L, 20L));\r\n      }\r\n  \r\n      //int\r\n      public static boolean compare(int a, int b) {\r\n          System.out.println("int");\r\n          return a == b;\r\n      }\r\n  \r\n      //byte\r\n      public static boolean compare(byte a, byte b) {\r\n          System.out.println("byte");\r\n          return a == b;\r\n      }\r\n  \r\n      //short\r\n      public static boolean compare(short a, short b) {\r\n          System.out.println("short");\r\n          return a == b;\r\n      }\r\n  \r\n      //long\r\n      public static boolean compare(long a, long b) {\r\n          System.out.println("long");\r\n          return a == b;\r\n      }\r\n  \r\n  }\r\n  ```\r\n\r\n## 7. 方法的参数传递\r\n\r\n### 7.1 方法参数传递基本类型（理解）\r\n\r\n* 测试代码：\r\n\r\n  ```java\r\n  package com.itheima.param;\r\n  \r\n  public class Test1 {\r\n      /*\r\n           方法参数传递为基本数据类型 :\r\n  \r\n                  传入方法中的, 是具体的数值.\r\n       */\r\n      public static void main(String[] args) {\r\n          int number = 100;\r\n          System.out.println("调用change方法前:" + number);\r\n          change(number);\r\n          System.out.println("调用change方法后:" + number);\r\n      }\r\n  \r\n      public static void change(int number) {\r\n          number = 200;\r\n      }\r\n  }\r\n  \r\n  \r\n  ```\r\n\r\n* 结论：\r\n\r\n  * 基本数据类型的参数，形式参数的改变，不影响实际参数 \r\n\r\n* 结论依据：\r\n\r\n  * 每个方法在栈内存中，都会有独立的栈空间，方法运行结束后就会弹栈消失\r\n\r\n\r\n### 7.2 方法参数传递引用类型\r\n\r\n* 测试代码：\r\n\r\n  ```java\r\n  package com.itheima.param;\r\n  \r\n  public class Test2 {\r\n      /*\r\n           方法参数传递为引用数据类型 :\r\n  \r\n                  传入方法中的, 是内存地址.\r\n       */\r\n      public static void main(String[] args) {\r\n          int[] arr = {10, 20, 30};\r\n          System.out.println("调用change方法前:" + arr[1]);\r\n          change(arr);\r\n          System.out.println("调用change方法后:" + arr[1]);\r\n      }\r\n  \r\n      public static void change(int[] arr) {\r\n          arr[1] = 200;\r\n      }\r\n  }\r\n  ```\r\n\r\n* 结论：\r\n\r\n  * 对于引用类型的参数，形式参数的改变，影响实际参数的值 \r\n\r\n* 结论依据：\r\n\r\n  * 引用数据类型的传参，传入的是地址值，内存中会造成两个引用指向同一个内存的效果，所以即使方法弹栈，堆内存中的数据也已经是改变后的结果 \r\n\r\n\r\n### 7.3 数组遍历\r\n\r\n* 需求：设计一个方法用于数组遍历，要求遍历的结果是在一行上的。例如：[11, 22, 33, 44, 55] \r\n\r\n* 思路：\r\n\r\n  * 因为要求结果在一行上输出，所以这里需要在学习一个新的输出语句System.out.print(“内容”);\r\n\r\n    System.out.println(“内容”); 输出内容并换行\r\n\r\n    System.out.print(“内容”); 输出内容不换行\r\n\r\n    System.out.println(); 起到换行的作用\r\n\r\n  * 定义一个数组，用静态初始化完成数组元素初始化\r\n\r\n  * 定义一个方法，用数组遍历通用格式对数组进行遍历\r\n\r\n  * 用新的输出语句修改遍历操作\r\n\r\n  * 调用遍历方法\r\n\r\n* 代码：\r\n\r\n  ```java\r\n  package com.itheima.test;\r\n  \r\n  public class Test1 {\r\n      /*\r\n          需求：设计一个方法用于数组遍历，要求遍历的结果是在一行上的。例如：[11, 22, 33, 44, 55]\r\n          思路：\r\n              1.定义一个数组，用静态初始化完成数组元素初始化\r\n              2.定义一个方法，对数组进行遍历\r\n              3.遍历打印的时候，数据不换行\r\n              4.调用遍历方法\r\n       */\r\n      public static void main(String[] args) {\r\n          // 1.定义一个数组，用静态初始化完成数组元素初始化\r\n          int[] arr = {11, 22, 33, 44, 55};\r\n          // 4.调用遍历方法\r\n          printArray(arr);\r\n  \r\n          System.out.println("另外一段代码逻辑 ");\r\n      }\r\n  \r\n      /*\r\n          2.定义一个方法，对数组进行遍历\r\n  \r\n          1, 参数           int[] arr\r\n          2, 返回值类型      void\r\n       */\r\n      public static void printArray(int[] arr){\r\n  \r\n          System.out.print("[");\r\n  \r\n          for (int i = 0; i < arr.length; i++) {\r\n  \r\n              if(i == arr.length -1){\r\n                  // 如果满足条件, 说明是最后一个元素, 最后一个元素, 特殊处理\r\n                  System.out.println(arr[i] + "]");\r\n              }else{\r\n                  // 3.遍历打印的时候，数据不换行\r\n                  System.out.print(arr[i] + ", ");\r\n              }\r\n  \r\n  \r\n          }\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n### 7.4 数组最大值\r\n\r\n* 需求：设计一个方法用于获取数组中元素的最大值 \r\n\r\n* 思路：\r\n\r\n  * ①定义一个数组，用静态初始化完成数组元素初始化\r\n  * ②定义一个方法，用来获取数组中的最大值，最值的认知和讲解我们在数组中已经讲解过了\r\n  * ③调用获取最大值方法，用变量接收返回结果\r\n  * ④把结果输出在控制台\r\n\r\n* 代码：\r\n\r\n  ```java\r\n  package com.itheima.test;\r\n  \r\n  public class Test2 {\r\n      /*\r\n          需求：设计一个方法用于获取数组中元素的最大值\r\n  \r\n          思路：\r\n              1.定义一个数组，用静态初始化完成数组元素初始化\r\n              2.定义一个方法，用来获取数组中的最大值\r\n              3.调用获取最大值方法，用变量接收返回结果\r\n              4.把结果输出在控制台\r\n       */\r\n      public static void main(String[] args) {\r\n          // 1.定义一个数组，用静态初始化完成数组元素初始化\r\n          int[] arr = {11, 55, 22, 44, 33};\r\n          // 3.调用获取最大值方法，用变量接收返回结果\r\n          int max = getMax(arr);\r\n          //  4.把结果输出在控制台\r\n          System.out.println(max);\r\n      }\r\n  \r\n      /*\r\n          2.定义一个方法，用来获取数组中的最大值\r\n  \r\n          1, 参数       int[] arr\r\n          2, 返回值类型  int\r\n       */\r\n      public static int getMax(int[] arr){\r\n          int max = arr[0];\r\n          for (int i = 1; i < arr.length; i++) {\r\n              if(max < arr[i]){\r\n                  max = arr[i];\r\n              }\r\n          }\r\n          return max;\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n\r\n\r\n### 7.5 方法同时获取数组最大值和最小值\r\n\r\n- 需求：设计一个方法，该方法能够同时获取数组的最大值，和最小值\r\n\r\n- 注意: return语句, 只能带回一个结果.\r\n\r\n- 代码：\r\n\r\n  ```java\r\n  public class Test3 {\r\n      /*\r\n          需求：设计一个方法，该方法能够同时获取数组的最大值，和最小值\r\n  \r\n          注意: return语句, 只能带回一个结果.\r\n       */\r\n      public static void main(String[] args) {\r\n  \r\n          int[] arr = {11,55,33,22,44};\r\n  \r\n          int[] maxAndMin = getMaxAndMin(arr);\r\n  \r\n          System.out.println(maxAndMin[0]);\r\n          System.out.println(maxAndMin[1]);\r\n  \r\n      }\r\n  \r\n      public static int[] getMaxAndMin(int[] arr){\r\n          int max = arr[0];\r\n          for (int i = 1; i < arr.length; i++) {\r\n              if(max < arr[i]){\r\n                  max = arr[i];\r\n              }\r\n          }\r\n  \r\n          int min = arr[0];\r\n          for (int i = 1; i < arr.length; i++) {\r\n              if(min > arr[i]){\r\n                  min = arr[i];\r\n              }\r\n          }\r\n  \r\n          int[] maxAndMin = {min, max};\r\n  \r\n          return maxAndMin;\r\n      }\r\n  }\r\n  \r\n  ```'},a591:function(n,e,t){"use strict";t.r(e),e["default"]='\x3c!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} --\x3e\n\n\x3c!-- code_chunk_output --\x3e\n\n- [1. 前言](#1-前言)\n- [2. ZooKeeper 介绍](#2-zookeeper-介绍)\n  - [2.1. ZooKeeper 由来](#21-zookeeper-由来)\n  - [2.2. ZooKeeper 概览](#22-zookeeper-概览)\n  - [2.3. ZooKeeper 特点](#23-zookeeper-特点)\n  - [2.4. ZooKeeper 典型应用场景](#24-zookeeper-典型应用场景)\n  - [2.5. 有哪些著名的开源项目用到了 ZooKeeper?](#25-有哪些著名的开源项目用到了-zookeeper)\n- [3. ZooKeeper 重要概念解读](#3-zookeeper-重要概念解读)\n  - [3.1. Data model（数据模型）](#31-data-model数据模型)\n  - [3.2. znode（数据节点）](#32-znode数据节点)\n    - [3.2.1. znode 4 种类型](#321-znode-4种类型)\n    - [3.2.2. znode 数据结构](#322-znode-数据结构)\n  - [3.3. 版本（version）](#33-版本version)\n  - [3.4. ACL（权限控制）](#34-acl权限控制)\n  - [3.5. Watcher（事件监听器）](#35-watcher事件监听器)\n  - [3.6. 会话（Session）](#36-会话session)\n- [4. ZooKeeper 集群](#4-zookeeper-集群)\n  - [4.1. ZooKeeper 集群角色](#41-zookeeper-集群角色)\n  - [4.2. ZooKeeper 集群中的服务器状态](#42-zookeeper-集群中的服务器状态)\n  - [4.3. ZooKeeper 集群为啥最好奇数台？](#43-zookeeper-集群为啥最好奇数台)\n- [5. ZAB 协议和 Paxos 算法](#5-zab-协议和paxos-算法)\n  - [5.1. ZAB 协议介绍](#51-zab-协议介绍)\n  - [5.2. ZAB 协议两种基本的模式：崩溃恢复和消息广播](#52-zab-协议两种基本的模式崩溃恢复和消息广播)\n- [6. 总结](#6-总结)\n- [7. 参考](#7-参考)\n\n\x3c!-- /code_chunk_output --\x3e\n\n## 1. 前言\n\n相信大家对 ZooKeeper 应该不算陌生。但是你真的了解 ZooKeeper 到底有啥用不？如果别人/面试官让你给他讲讲对于 ZooKeeper 的认识，你能回答到什么地步呢？\n\n拿我自己来说吧！我本人曾经使用 Dubbo 来做分布式项目的时候，使用了 ZooKeeper 作为注册中心。为了保证分布式系统能够同步访问某个资源，我还使用 ZooKeeper 做过分布式锁。另外，我在学习 Kafka 的时候，知道 Kafka 很多功能的实现依赖了 ZooKeeper。\n\n前几天，总结项目经验的时候，我突然问自己 ZooKeeper 到底是个什么东西？想了半天，脑海中只是简单的能浮现出几句话：\n\n1. ZooKeeper 可以被用作注册中心、分布式锁；\n2. ZooKeeper 是 Hadoop 生态系统的一员；\n3. 构建 ZooKeeper 集群的时候，使用的服务器最好是奇数台。\n\n由此可见，我对于 ZooKeeper 的理解仅仅是停留在了表面。\n\n所以，通过本文，希望带大家稍微详细的了解一下 ZooKeeper 。如果没有学过 ZooKeeper ，那么本文将会是你进入 ZooKeeper 大门的垫脚砖。如果你已经接触过 ZooKeeper ，那么本文将带你回顾一下 ZooKeeper 的一些基础概念。\n\n另外，本文不光会涉及到 ZooKeeper 的一些概念，后面的文章会介绍到 ZooKeeper 常见命令的使用以及使用 Apache Curator 作为 ZooKeeper 的客户端。\n\n_如果文章有任何需要改善和完善的地方，欢迎在评论区指出，共同进步！_\n\n## 2. ZooKeeper 介绍\n\n### 2.1. ZooKeeper 由来\n\n正式介绍 ZooKeeper 之前，我们先来看看 ZooKeeper 的由来，还挺有意思的。\n\n下面这段内容摘自《从 Paxos 到 ZooKeeper 》第四章第一节，推荐大家阅读一下：\n\n> ZooKeeper 最早起源于雅虎研究院的一个研究小组。在当时，研究人员发现，在雅虎内部很多大型系统基本都需要依赖一个类似的系统来进行分布式协调，但是这些系统往往都存在分布式单点问题。所以，雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架，以便让开发人员将精力集中在处理业务逻辑上。\n>\n> 关于“ZooKeeper”这个项目的名字，其实也有一段趣闻。在立项初期，考虑到之前内部很多项目都是使用动物的名字来命名的（例如著名的 Pig 项目),雅虎的工程师希望给这个项目也取一个动物的名字。时任研究院的首席科学家 RaghuRamakrishnan 开玩笑地说：“在这样下去，我们这儿就变成动物园了！”此话一出，大家纷纷表示就叫动物园管理员吧一一一因为各个以动物命名的分布式组件放在一起，雅虎的整个分布式系统看上去就像一个大型的动物园了，而 ZooKeeper 正好要用来进行分布式环境的协调一一于是，ZooKeeper 的名字也就由此诞生了。\n\n### 2.2. ZooKeeper 概览\n\nZooKeeper 是一个开源的**分布式协调服务**，它的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。\n\n> **原语：** 操作系统或计算机网络用语范畴。是由若干条指令组成的，用于完成一定功能的一个过程。具有不可分割性·即原语的执行必须是连续的，在执行过程中不允许被中断。\n\n**ZooKeeper 为我们提供了高可用、高性能、稳定的分布式数据一致性解决方案，通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。**\n\n另外，**ZooKeeper 将数据保存在内存中，性能是非常棒的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景）。**\n\n### 2.3. ZooKeeper 特点\n\n- **顺序一致性：** 从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。\n- **原子性：** 所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。\n- **单一系统映像 ：** 无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。\n- **可靠性：** 一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。\n\n### 2.4. ZooKeeper 典型应用场景\n\nZooKeeper 概览中，我们介绍到使用其通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。\n\n下面选 3 个典型的应用场景来专门说说：\n\n1. **分布式锁** ： 通过创建唯一节点获得分布式锁，当获得锁的一方执行完相关代码或者是挂掉之后就释放锁。\n2. **命名服务** ：可以通过 ZooKeeper 的顺序节点生成全局唯一 ID\n3. **数据发布/订阅** ：通过 **Watcher 机制** 可以很方便地实现数据发布/订阅。当你将数据发布到 ZooKeeper 被监听的节点上，其他机器可通过监听 ZooKeeper 上节点的变化来实现配置的动态更新。\n\n实际上，这些功能的实现基本都得益于 ZooKeeper 可以保存数据的功能，但是 ZooKeeper 不适合保存大量数据，这一点需要注意。\n\n### 2.5. 有哪些著名的开源项目用到了 ZooKeeper?\n\n1. **Kafka** : ZooKeeper 主要为 Kafka 提供 Broker 和 Topic 的注册以及多个 Partition 的负载均衡等功能。\n2. **Hbase** : ZooKeeper 为 Hbase 提供确保整个集群只有一个 Master 以及保存和提供 regionserver 状态信息（是否在线）等功能。\n3. **Hadoop** : ZooKeeper 为 Namenode 提供高可用支持。\n\n## 3. ZooKeeper 重要概念解读\n\n_破音：拿出小本本，下面的内容非常重要哦！_\n\n### 3.1. Data model（数据模型）\n\nZooKeeper 数据模型采用层次化的多叉树形结构，每个节点上都可以存储数据，这些数据可以是数字、字符串或者是二级制序列。并且。每个节点还可以拥有 N 个子节点，最上层是根节点以“/”来代表。每个数据节点在 ZooKeeper 中被称为 **znode**，它是 ZooKeeper 中数据的最小单元。并且，每个 znode 都一个唯一的路径标识。\n\n强调一句：**ZooKeeper 主要是用来协调服务的，而不是用来存储业务数据的，所以不要放比较大的数据在 znode 上，ZooKeeper 给出的上限是每个结点的数据大小最大是 1M。**\n\n从下图可以更直观地看出：ZooKeeper 节点路径标识方式和 Unix 文件系统路径非常相似，都是由一系列使用斜杠"/"进行分割的路径表示，开发人员可以向这个节点中写入数据，也可以在节点下面创建子节点。这些操作我们后面都会介绍到。\n\n![ZooKeeper 数据模型](zookeeper-intro.assets/znode-structure.png)\n\n### 3.2. znode（数据节点）\n\n介绍了 ZooKeeper 树形数据模型之后，我们知道每个数据节点在 ZooKeeper 中被称为 **znode**，它是 ZooKeeper 中数据的最小单元。你要存放的数据就放在上面，是你使用 ZooKeeper 过程中经常需要接触到的一个概念。\n\n#### 3.2.1. znode 4 种类型\n\n我们通常是将 znode 分为 4 大类：\n\n- **持久（PERSISTENT）节点** ：一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。\n- **临时（EPHEMERAL）节点** ：临时节点的生命周期是与 **客户端会话（session）** 绑定的，**会话消失则节点消失** 。并且，**临时节点只能做叶子节点** ，不能创建子节点。\n- **持久顺序（PERSISTENT_SEQUENTIAL）节点** ：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 `/node1/app0000000001` 、`/node1/app0000000002` 。\n- **临时顺序（EPHEMERAL_SEQUENTIAL）节点** ：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。\n\n#### 3.2.2. znode 数据结构\n\n每个 znode 由 2 部分组成:\n\n- **stat** ：状态信息\n- **data** ： 节点存放的数据的具体内容\n\n如下所示，我通过 get 命令来获取 根目录下的 dubbo 节点的内容。（get 命令在下面会介绍到）。\n\n```shell\n[zk: 127.0.0.1:2181(CONNECTED) 6] get /dubbo\n# 该数据节点关联的数据内容为空\nnull\n# 下面是该数据节点的一些状态信息，其实就是 Stat 对象的格式化输出\ncZxid = 0x2\nctime = Tue Nov 27 11:05:34 CST 2018\nmZxid = 0x2\nmtime = Tue Nov 27 11:05:34 CST 2018\npZxid = 0x3\ncversion = 1\ndataVersion = 0\naclVersion = 0\nephemeralOwner = 0x0\ndataLength = 0\nnumChildren = 1\n```\n\nStat 类中包含了一个数据节点的所有状态信息的字段，包括事务 ID-cZxid、节点创建时间-ctime 和子节点个数-numChildren 等等。\n\n下面我们来看一下每个 znode 状态信息究竟代表的是什么吧！（下面的内容来源于《从 Paxos 到 ZooKeeper 分布式一致性原理与实践》，因为 Guide 确实也不是特别清楚，要学会参考资料的嘛！ ） ：\n\n| znode 状态信息 | 解释                                                         |\n| -------------- | ------------------------------------------------------------ |\n| cZxid          | create ZXID，即该数据节点被创建时的事务 id                   |\n| ctime          | create time，即该节点的创建时间                              |\n| mZxid          | modified ZXID，即该节点最终一次更新时的事务 id               |\n| mtime          | modified time，即该节点最后一次的更新时间                    |\n| pZxid          | 该节点的子节点列表最后一次修改时的事务 id，只有子节点列表变更才会更新 pZxid，子节点内容变更不会更新 |\n| cversion       | 子节点版本号，当前节点的子节点每次变化时值增加 1             |\n| dataVersion    | 数据节点内容版本号，节点创建时为 0，每更新一次节点内容(不管内容有无变化)该版本号的值增加 1 |\n| aclVersion     | 节点的 ACL 版本号，表示该节点 ACL 信息变更次数               |\n| ephemeralOwner | 创建该临时节点的会话的 sessionId；如果当前节点为持久节点，则 ephemeralOwner=0 |\n| dataLength     | 数据节点内容长度                                             |\n| numChildren    | 当前节点的子节点个数                                         |\n\n### 3.3. 版本（version）\n\n在前面我们已经提到，对应于每个 znode，ZooKeeper 都会为其维护一个叫作 **Stat** 的数据结构，Stat 中记录了这个 znode 的三个相关的版本：\n\n- **dataVersion** ：当前 znode 节点的版本号\n- **cversion** ： 当前 znode 子节点的版本\n- **aclVersion** ： 当前 znode 的 ACL 的版本。\n\n### 3.4. ACL（权限控制）\n\nZooKeeper 采用 ACL（AccessControlLists）策略来进行权限控制，类似于 UNIX 文件系统的权限控制。\n\n对于 znode 操作的权限，ZooKeeper 提供了以下 5 种：\n\n- **CREATE** : 能创建子节点\n- **READ** ：能获取节点数据和列出其子节点\n- **WRITE** : 能设置/更新节点数据\n- **DELETE** : 能删除子节点\n- **ADMIN** : 能设置节点 ACL 的权限\n\n其中尤其需要注意的是，**CREATE** 和 **DELETE** 这两种权限都是针对 **子节点** 的权限控制。\n\n对于身份认证，提供了以下几种方式：\n\n- **world** ： 默认方式，所有用户都可无条件访问。\n- **auth** :不使用任何 id，代表任何已认证的用户。\n- **digest** :用户名:密码认证方式： _username:password_ 。\n- **ip** : 对指定 ip 进行限制。\n\n### 3.5. Watcher（事件监听器）\n\nWatcher（事件监听器），是 ZooKeeper 中的一个很重要的特性。ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。\n\n![watcher机制](zookeeper-intro.assets/watche机制.png)\n\n_破音：非常有用的一个特性，都能出小本本记好了，后面用到 ZooKeeper 基本离不开 Watcher（事件监听器）机制。_\n\n### 3.6. 会话（Session）\n\nSession 可以看作是 ZooKeeper 服务器与客户端的之间的一个 TCP 长连接，通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向 ZooKeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的 Watcher 事件通知。\n\nSession 有一个属性叫做：`sessionTimeout` ，`sessionTimeout` 代表会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在`sessionTimeout`规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。\n\n另外，在为客户端创建会话之前，服务端首先会为每个客户端都分配一个 `sessionID`。由于 `sessionID`是 ZooKeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 `sessionID` 的，因此，无论是哪台服务器为客户端分配的 `sessionID`，都务必保证全局唯一。\n\n## 4. ZooKeeper 集群\n\n为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。通常 3 台服务器就可以构成一个 ZooKeeper 集群了。ZooKeeper 官方提供的架构图就是一个 ZooKeeper 集群整体对外提供服务。\n\n![](zookeeper-intro.assets/zookeeper集群.png)\n\n上图中每一个 Server 代表一个安装 ZooKeeper 服务的服务器。组成 ZooKeeper 服务的服务器都会在内存中维护当前的服务器状态，并且每台服务器之间都互相保持着通信。集群间通过 ZAB 协议（ZooKeeper Atomic Broadcast）来保持数据的一致性。\n\n**最典型集群模式： Master/Slave 模式（主备模式）**。在这种模式中，通常 Master 服务器作为主服务器提供写服务，其他的 Slave 服务器从服务器通过异步复制的方式获取 Master 服务器最新的数据提供读服务。\n\n### 4.1. ZooKeeper 集群角色\n\n但是，在 ZooKeeper 中没有选择传统的 Master/Slave 概念，而是引入了 Leader、Follower 和 Observer 三种角色。如下图所示\n\n![](zookeeper-intro.assets/zookeeper集群中的角色.png)\n\nZooKeeper 集群中的所有机器通过一个 **Leader 选举过程** 来选定一台称为 “**Leader**” 的机器，Leader 既可以为客户端提供写服务又能提供读服务。除了 Leader 外，**Follower** 和 **Observer** 都只能提供读服务。Follower 和 Observer 唯一的区别在于 Observer 机器不参与 Leader 的选举过程，也不参与写操作的“过半写成功”策略，因此 Observer 机器可以在不影响写性能的情况下提升集群的读性能。\n\n| 角色     | 说明                                                         |\n| -------- | ------------------------------------------------------------ |\n| Leader   | 为客户端提供读和写的服务，负责投票的发起和决议，更新系统状态。 |\n| Follower | 为客户端提供读服务，如果是写服务则转发给 Leader。参与选举过程中的投票。 |\n| Observer | 为客户端提供读服务，如果是写服务则转发给 Leader。不参与选举过程中的投票，也不参与“过半写成功”策略。在不影响写性能的情况下提升集群的读性能。此角色于 ZooKeeper3.3 系列新增的角色。 |\n\n当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，就会进入 Leader 选举过程，这个过程会选举产生新的 Leader 服务器。\n\n这个过程大致是这样的：\n\n1. **Leader election（选举阶段）**：节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。\n2. **Discovery（发现阶段）** ：在这个阶段，followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议。\n3. **Synchronization（同步阶段）** :同步阶段主要是利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。同步完成之后\n   准 leader 才会成为真正的 leader。\n4. **Broadcast（广播阶段）** :到了这个阶段，ZooKeeper 集群才能正式对外提供事务服务，并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。\n\n### 4.2. ZooKeeper 集群中的服务器状态\n\n- **LOOKING** ：寻找 Leader。\n- **LEADING** ：Leader 状态，对应的节点为 Leader。\n- **FOLLOWING** ：Follower 状态，对应的节点为 Follower。\n- **OBSERVING** ：Observer 状态，对应节点为 Observer，该节点不参与 Leader 选举。\n\n### 4.3. ZooKeeper 集群为啥最好奇数台？\n\nZooKeeper 集群在宕掉几个 ZooKeeper 服务器之后，如果剩下的 ZooKeeper 服务器个数大于宕掉的个数的话整个 ZooKeeper 才依然可用。假如我们的集群中有 n 台 ZooKeeper 服务器，那么也就是剩下的服务数必须大于 n/2。先说一下结论，2n 和 2n-1 的容忍度是一样的，都是 n-1，大家可以先自己仔细想一想，这应该是一个很简单的数学问题了。\n\n比如假如我们有 3 台，那么最大允许宕掉 1 台 ZooKeeper 服务器，如果我们有 4 台的的时候也同样只允许宕掉 1 台。\n假如我们有 5 台，那么最大允许宕掉 2 台 ZooKeeper 服务器，如果我们有 6 台的的时候也同样只允许宕掉 2 台。\n\n综上，何必增加那一个不必要的 ZooKeeper 呢？\n\n### 4.4. ZooKeeper 选举的过半机制防止脑裂\n\n**何为集群脑裂？**\n\n对于一个集群，通常多台机器会部署在不同机房，来提高这个集群的可用性。保证可用性的同时，会发生一种机房间网络线路故障，导致机房间网络不通，而集群被割裂成几个小集群。这时候子集群各自选主导致“脑裂”的情况。\n\n举例说明：比如现在有一个由 6 台服务器所组成的一个集群，部署在了 2 个机房，每个机房 3 台。正常情况下只有 1 个 leader，但是当两个机房中间网络断开的时候，每个机房的 3 台服务器都会认为另一个机房的 3 台服务器下线，而选出自己的 leader 并对外提供服务。若没有过半机制，当网络恢复的时候会发现有 2 个 leader。仿佛是 1 个大脑（leader）分散成了 2 个大脑，这就发生了脑裂现象。脑裂期间 2 个大脑都可能对外提供了服务，这将会带来数据一致性等问题。\n\n**过半机制是如何防止脑裂现象产生的？**\n\nZooKeeper 的过半机制导致不可能产生 2 个 leader，因为少于等于一半是不可能产生 leader 的，这就使得不论机房的机器如何分配都不可能发生脑裂。\n\n## 5. ZAB 协议和 Paxos 算法\n\nPaxos 算法应该可以说是 ZooKeeper 的灵魂了。但是，ZooKeeper 并没有完全采用 Paxos 算法 ，而是使用 ZAB 协议作为其保证数据一致性的核心算法。另外，在 ZooKeeper 的官方文档中也指出，ZAB 协议并不像 Paxos 算法那样，是一种通用的分布式一致性算法，它是一种特别为 Zookeeper 设计的崩溃可恢复的原子消息广播算法。\n\n### 5.1. ZAB 协议介绍\n\nZAB（ZooKeeper Atomic Broadcast 原子广播） 协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。 在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。\n\n### 5.2. ZAB 协议两种基本的模式：崩溃恢复和消息广播\n\nZAB 协议包括两种基本的模式，分别是\n\n- **崩溃恢复** ：当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进入恢复模式并选举产生新的 Leader 服务器。当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该 Leader 服务器完成了状态同步之后，ZAB 协议就会退出恢复模式。其中，**所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和 Leader 服务器的数据状态保持一致**。\n- **消息广播** ：**当集群中已经有过半的 Follower 服务器完成了和 Leader 服务器的状态同步，那么整个服务框架就可以进入消息广播模式了。** 当一台同样遵守 ZAB 协议的服务器启动后加入到集群中时，如果此时集群中已经存在一个 Leader 服务器在负责进行消息广播，那么新加入的服务器就会自觉地进入数据恢复模式：找到 Leader 所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。\n\n关于 **ZAB 协议&Paxos 算法** 需要讲和理解的东西太多了，具体可以看下面这两篇文章：\n\n- [图解 Paxos 一致性协议](http://codemacro.com/2014/10/15/explain-poxos/)\n- [Zookeeper ZAB 协议分析](https://dbaplus.cn/news-141-1875-1.html)\n\n## 6. 总结\n\n1. ZooKeeper 本身就是一个分布式程序（只要半数以上节点存活，ZooKeeper 就能正常服务）。\n2. 为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。\n3. ZooKeeper 将数据保存在内存中，这也就保证了 高吞吐量和低延迟（但是内存限制了能够存储的容量不太大，此限制也是保持 znode 中存储的数据量较小的进一步原因）。\n4. ZooKeeper 是高性能的。 在“读”多于“写”的应用程序中尤其地明显，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）\n5. ZooKeeper 有临时节点的概念。 当创建临时节点的客户端会话一直保持活动，瞬时节点就一直存在。而当会话终结时，瞬时节点被删除。持久节点是指一旦这个 znode 被创建了，除非主动进行 znode 的移除操作，否则这个 znode 将一直保存在 ZooKeeper 上。\n6. ZooKeeper 底层其实只提供了两个功能：① 管理（存储、读取）用户程序提交的数据；② 为用户程序提供数据节点监听服务。\n\n## 7. 参考\n\n1. 《从 Paxos 到 ZooKeeper 分布式一致性原理与实践》\n'},a59b:function(n,e,t){"use strict";t.r(e),e["default"]='[jad](https://varaneckas.com/jad/)反编译工具，已经不再更新，且只支持 JDK1.4，但并不影响其强大的功能。\n\n基本用法：`jad xxx.class`，会生成直接可读的 `xxx.jad` 文件。\n\n## 自动拆装箱\n\n对于基本类型和包装类型之间的转换，通过 xxxValue()和 valueOf()两个方法完成自动拆装箱，使用 jad 进行反编译可以看到该过程：\n\n```java\npublic class Demo {\n  public static void main(String[] args) {\n    int x = new Integer(10);  // 自动拆箱\n    Integer y = x;            // 自动装箱\n  }\n}\n```\n\n反编译后结果：\n\n```java\npublic class Demo\n{\n    public Demo(){}\n\n    public static void main(String args[])\n    {\n        int i = (new Integer(10)).intValue();   // intValue()拆箱\n        Integer integer = Integer.valueOf(i);   // valueOf()装箱\n    }\n}\n```\n\n## foreach 语法糖\n\n在遍历迭代时可以 foreach 语法糖，对于数组类型直接转换成 for 循环：\n\n```java\n// 原始代码\nint[] arr = {1, 2, 3, 4, 5};\n\tfor(int item: arr) {\n    \tSystem.out.println(item);\n\t}\n}\n\n// 反编译后代码\nint ai[] = {\n    1, 2, 3, 4, 5\n};\nint ai1[] = ai;\nint i = ai1.length;\n// 转换成for循环\nfor(int j = 0; j < i; j++)\n{\n    int k = ai1[j];\n    System.out.println(k);\n}\n```\n\n对于容器类的遍历会使用 iterator 进行迭代：\n\n```java\nimport java.io.PrintStream;\nimport java.util.*;\n\npublic class Demo\n{\n    public Demo() {}\n    public static void main(String args[])\n    {\n        ArrayList arraylist = new ArrayList();\n        arraylist.add(Integer.valueOf(1));\n        arraylist.add(Integer.valueOf(2));\n        arraylist.add(Integer.valueOf(3));\n        Integer integer;\n        // 使用的for循环+Iterator，类似于链表迭代：\n        // for (ListNode cur = head; cur != null; System.out.println(cur.val)){\n        //     cur = cur.next;\n    \t// }\n        for(Iterator iterator = arraylist.iterator(); iterator.hasNext(); System.out.println(integer))\n            integer = (Integer)iterator.next();\n    }\n}\n```\n\n## Arrays.asList(T...)\n\n熟悉 Arrays.asList(T...)用法的小伙伴都应该知道，asList()方法传入的参数不能是基本类型的数组，必须包装成包装类型再使用，否则对应生成的列表的大小永远是 1：\n\n```java\nimport java.util.*;\npublic class Demo {\n  public static void main(String[] args) {\n    int[] arr1 = {1, 2, 3};\n    Integer[] arr2 = {1, 2, 3};\n    List lists1 = Arrays.asList(arr1);\n    List lists2 = Arrays.asList(arr2);\n    System.out.println(lists1.size()); // 1\n    System.out.println(lists2.size()); // 3\n  }\n}\n```\n\n从反编译结果来解释，为什么传入基本类型的数组后，返回的 List 大小是 1：\n\n```java\n// 反编译后文件\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Demo\n{\n    public Demo() {}\n\n    public static void main(String args[])\n    {\n        int ai[] = {\n            1, 2, 3\n        };\n        // 使用包装类型，全部元素由int包装为Integer\n        Integer ainteger[] = {\n            Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3)\n        };\n\n        // 注意这里被反编译成二维数组，而且是一个1行三列的二维数组\n        // list.size()当然返回1\n        List list = Arrays.asList(new int[][] { ai });\n        List list1 = Arrays.asList(ainteger);\n        System.out.println(list.size());\n        System.out.println(list1.size());\n    }\n}\n```\n\n从上面结果可以看到，传入基本类型的数组后，会被转换成一个二维数组，而且是**new int\\[1]\\[arr.length]**这样的数组，调用 list.size()当然返回 1。\n\n## 注解\n\nJava 中的类、接口、枚举、注解都可以看做是类类型。使用 jad 来看一下@interface 被转换成什么：\n\n```java\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\n\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Foo{\n  String[] value();\n  boolean bar();\n}\n```\n\n查看反编译代码可以看出：\n\n- 自定义的注解类 Foo 被转换成接口 Foo，并且继承 Annotation 接口\n- 原来自定义接口中的 value()和 bar()被转换成抽象方法\n\n```java\nimport java.lang.annotation.Annotation;\n\npublic interface Foo\n    extends Annotation\n{\n    public abstract String[] value();\n\n    public abstract boolean bar();\n}\n```\n\n注解通常和反射配合使用，而且既然自定义的注解最终被转换成接口，注解中的属性被转换成接口中的抽象方法，那么通过反射之后拿到接口实例，在通过接口实例自然能够调用对应的抽象方法：\n\n```java\nimport java.util.Arrays;\n\n@Foo(value={"sherman", "decompiler"}, bar=true)\npublic class Demo{\n    public static void main(String[] args) {\n        Foo foo = Demo.class.getAnnotation(Foo.class);\n        System.out.println(Arrays.toString(foo.value())); // [sherman, decompiler]\n        System.out.println(foo.bar());                    // true\n    }\n}\n```\n\n## 枚举\n\n通过 jad 反编译可以很好地理解枚举类。\n\n### 空枚举\n\n先定义一个空的枚举类：\n\n```java\npublic enum DummyEnum {\n}\n```\n\n使用 jad 反编译查看结果：\n\n- 自定义枚举类被转换成 final 类，并且继承 Enum\n- 提供了两个参数（name，odinal）的私有构造器，并且调用了父类的构造器。注意即使没有提供任何参数，也会有该构造器，其中 name 就是枚举实例的名称，odinal 是枚举实例的索引号\n- 初始化了一个 private static final 自定义类型的空数组 **\\$VALUES**\n- 提供了两个 public static 方法：\n  - values()方法通过 clone()方法返回内部\\$VALUES 的浅拷贝。这个方法结合私有构造器可以完美实现单例模式，想一想 values()方法是不是和单例模式中 getInstance()方法功能类似\n  - valueOf(String s)：调用父类 Enum 的 valueOf 方法并强转返回\n\n```java\npublic final class DummyEnum extends Enum\n{\n\t// 功能和单例模式的getInstance()方法相同\n    public static DummyEnum[] values()\n    {\n        return (DummyEnum[])$VALUES.clone();\n    }\n\t// 调用父类的valueOf方法，并强转返回\n    public static DummyEnum valueOf(String s)\n    {\n        return (DummyEnum)Enum.valueOf(DummyEnum, s);\n    }\n\t// 默认提供一个私有的两个参数的构造器，并调用父类Enum的构造器\n    private DummyEnum(String s, int i)\n    {\n        super(s, i);\n    }\n\t// 初始化一个private static final的本类空数组\n    private static final DummyEnum $VALUES[] = new DummyEnum[0];\n\n}\n\n```\n\n### 包含抽象方法的枚举\n\n枚举类中也可以包含抽象方法，但是必须定义枚举实例并且立即重写抽象方法，就像下面这样：\n\n```java\npublic enum DummyEnum {\n    DUMMY1 {\n        public void dummyMethod() {\n            System.out.println("[1]: implements abstract method in enum class");\n        }\n    },\n\n    DUMMY2 {\n        public void dummyMethod() {\n            System.out.println("[2]: implements abstract method in enum class");\n        }\n    };\n\n    abstract void dummyMethod();\n\n}\n```\n\n再来反编译看看有哪些变化：\n\n- 原来 final class 变成了 abstract class：这很好理解，有抽象方法的类自然是抽象类\n- 多了两个 public static final 的成员 DUMMY1、DUMMY2，这两个实例的初始化过程被放到了 static 代码块中，并且实例过程中直接重写了抽象方法，类似于匿名内部类的形式。\n- 数组 **\\$VALUES[]** 初始化时放入枚举实例\n\n还有其它变化么？\n\n在反编译后的 DummyEnum 类中，是存在抽象方法的，而枚举实例在静态代码块中初始化过程中重写了抽象方法。在 Java 中，抽象方法和抽象方法重写同时放在一个类中，只能通过内部类形式完成。因此上面第二点应该说成就是以内部类形式初始化。\n\n可以看一下 DummyEnum.class 存放的位置，应该多了两个文件：\n\n- DummyEnum\\$1.class\n- DummyEnum\\$2.class\n\nJava 中.class 文件出现 $ 符号表示有内部类存在，就像OutClass$InnerClass，这两个文件出现也应证了上面的匿名内部类初始化的说法。\n\n```java\nimport java.io.PrintStream;\n\npublic abstract class DummyEnum extends Enum\n{\n    public static DummyEnum[] values()\n    {\n        return (DummyEnum[])$VALUES.clone();\n    }\n\n    public static DummyEnum valueOf(String s)\n    {\n        return (DummyEnum)Enum.valueOf(DummyEnum, s);\n    }\n\n    private DummyEnum(String s, int i)\n    {\n        super(s, i);\n    }\n\n\t// 抽象方法\n    abstract void dummyMethod();\n\n\t// 两个pubic static final实例\n    public static final DummyEnum DUMMY1;\n    public static final DummyEnum DUMMY2;\n    private static final DummyEnum $VALUES[];\n\n \t// static代码块进行初始化\n    static\n    {\n        DUMMY1 = new DummyEnum("DUMMY1", 0) {\n            public void dummyMethod()\n            {\n                System.out.println("[1]: implements abstract method in enum class");\n            }\n        }\n;\n        DUMMY2 = new DummyEnum("DUMMY2", 1) {\n            public void dummyMethod()\n            {\n                System.out.println("[2]: implements abstract method in enum class");\n            }\n        }\n;\n\t\t// 对本类数组进行初始化\n        $VALUES = (new DummyEnum[] {\n            DUMMY1, DUMMY2\n        });\n    }\n}\n```\n\n### 正常的枚举类\n\n实际开发中，枚举类通常的形式是有两个参数（int code，Sring msg）的构造器，可以作为状态码进行返回。Enum 类实际上也是提供了包含两个参数且是 protected 的构造器，这里为了避免歧义，将枚举类的构造器设置为三个，使用 jad 反编译：\n\n最大的变化是：现在的 private 构造器从 2 个参数变成 5 个，而且在内部仍然将前两个参数通过 super 传递给父类，剩余的三个参数才是真正自己提供的参数。可以想象，如果自定义的枚举类只提供了一个参数，最终生成底层代码中 private 构造器应该有三个参数，前两个依然通过 super 传递给父类。\n\n```java\npublic final class CustomEnum extends Enum\n{\n    public static CustomEnum[] values()\n    {\n        return (CustomEnum[])$VALUES.clone();\n    }\n\n    public static CustomEnum valueOf(String s)\n    {\n        return (CustomEnum)Enum.valueOf(CustomEnum, s);\n    }\n\n    private CustomEnum(String s, int i, int j, String s1, Object obj)\n    {\n        super(s, i);\n        code = j;\n        msg = s1;\n        data = obj;\n    }\n\n    public static final CustomEnum FIRST;\n    public static final CustomEnum SECOND;\n    public static final CustomEnum THIRD;\n    private int code;\n    private String msg;\n    private Object data;\n    private static final CustomEnum $VALUES[];\n\n    static\n    {\n        FIRST = new CustomEnum("FIRST", 0, 10010, "first", Long.valueOf(100L));\n        SECOND = new CustomEnum("SECOND", 1, 10020, "second", "Foo");\n        THIRD = new CustomEnum("THIRD", 2, 10030, "third", new Object());\n        $VALUES = (new CustomEnum[] {\n            FIRST, SECOND, THIRD\n        });\n    }\n}\n```\n'},a80a:function(n,e,t){"use strict";t.r(e),e["default"]='# 注解开发\n\n## 1)注解驱动的意义\n\n### 1.1)什么是注解驱动\n\n注解启动时使用注解的形式替代xml配置，将繁杂的spring配置文件从工程中彻底消除掉，简化书写\n\n![1591023265469](./Spring-day02/1591023265469.png)\n\n### 1.2)注解驱动的弊端\n\n- 为了达成注解驱动的目的，可能会将原先很简单的书写，变的更加复杂\n\n- XML中配置第三方开发的资源是很方便的，但使用注解驱动无法在第三方开发的资源中进行编辑，因此会增大开发工作量\n\n![1591023337010](./Spring-day02/1591023337010.png)\n\n\n\n## 2)常用注解\n\n### 2.1)启动注解功能\n\n- 启动注解扫描，加载类中配置的注解项\n\n  ```xml\n  <context:component-scan base-package="packageName"/>\n  ```\n\n- 说明：\n\n  - 在进行包所扫描时，会对配置的包及其子包中所有文件进行扫描\n\n  - 扫描过程是以文件夹递归迭代的形式进行的\n\n  - 扫描过程仅读取合法的java文件\n\n  - 扫描时仅读取spring可识别的注解\n\n  - 扫描结束后会将可识别的有效注解转化为spring对应的资源加入IoC容器\n\n- 注意：\n\n  - 无论是注解格式还是XML配置格式，最终都是将资源加载到IoC容器中，差别仅仅是数据读取方式不同\n\n  - 从加载效率上来说注解优于XML配置文件\n\n### 2.2)bean的定义\n\n- 名称：@Component    @Controller    @Service    @Repository\n\n- 类型：**类注解**\n\n- 位置：类定义上方\n\n- 作用：设置该类为spring管理的bean\n\n- 范例：\n\n  ```java\n  @Component\n  public class ClassName{}\n  ```\n\n- 说明：\n\n  - @Controller、@Service 、@Repository是@Component的衍生注解，功能同@Component\n\n- 相关属性\n  - value（默认）：定义bean的访问id\n\n### 2.3)bean的作用域\n\n- 名称：@Scope\n\n- 类型：**类注解**\n\n- 位置：类定义上方\n\n- 作用：设置该类作为bean对应的scope属性\n\n- 范例：\n\n  ```java\n  @Scope\n  public class ClassName{}\n  ```\n\n- 相关属性\n\n  - value（默认）：定义bean的作用域，默认为singleton\n\n### 2.4)bean的生命周期\n\n- 名称：@PostConstruct、@PreDestroy\n\n- 类型：**方法注解**\n\n- 位置：方法定义上方\n\n- 作用：设置该类作为bean对应的生命周期方法\n\n- 范例：\n\n  ```java\n  @PostConstruct\n  public void init() { System.out.println("init..."); }\n  ```\n\n### 2.5)加载第三方资源\n\n- 名称：@Bean\n\n- 类型：**方法注解**\n\n- 位置：方法定义上方\n\n- 作用：设置该方法的返回值作为spring管理的bean\n\n- 范例：\n\n  ```java\n  @Bean("dataSource")\n  public DruidDataSource createDataSource() {    return ……;    }\n  ```\n\n- 说明：\n\n  - 因为第三方bean无法在其源码上进行修改，使用@Bean解决第三方bean的引入问题\n\n  - 该注解用于替代XML配置中的静态工厂与实例工厂创建bean，不区分方法是否为静态或非静态\n\n  - @Bean所在的类必须被spring扫描加载，否则该注解无法生效\n\n- 相关属性\n  - value（默认）：定义bean的访问id\n\n### 2.6)bean的非引用类型属性注入\n\n- 名称：@Value\n\n- 类型：**属性注解、方法注解**\n\n- 位置：属性定义上方，方法定义上方\n\n- 作用：设置对应属性的值或对方法进行传参\n\n- 范例：\n\n  ```java\n  @Value("${jdbc.username}")\n  private String username;\n  ```\n\n- 说明：\n\n  - value值仅支持非引用类型数据，赋值时对方法的所有参数全部赋值\n\n  - value值支持读取properties文件中的属性值，通过类属性将properties中数据传入类中\n\n  - value值支持SpEL\n\n  - @value注解如果添加在属性上方，可以省略set方法（set方法的目的是为属性赋值）\n\n- 相关属性\n  - value（默认）：定义对应的属性值或参数值\n\n### 2.7)bean的引用类型属性注入\n\n- 名称：@Autowired、@Qualifier\n\n- 类型：**属性注解、方法注解**\n\n- 位置：属性定义上方，方法定义上方\n\n- 作用：设置对应属性的对象或对方法进行引用类型传参\n\n- 范例：\n\n  ```java\n  @Autowired(required = false)\n  @Qualifier("userDao")\n  private UserDao userDao;\n  ```\n\n- 说明：\n\n  - @Autowired默认按类型装配，指定@Qualifier后可以指定自动装配的bean的id\n\n- 相关属性\n  - required：定义该属性是否允许为null\n\n### 2.8)bean的引用类型属性注入\n\n- 名称：@Primary\n\n- 类型：**类注解**\n\n- 位置：类定义上方\n\n- 作用：设置类对应的bean按类型装配时优先装配\n\n- 范例：\n\n  ```java\n  @Primary\n  public class ClassName{}\n  ```\n\n- 说明：\n\n  - @Autowired默认按类型装配，当出现相同类型的bean，使用@Primary提高按类型自动装配的优先级，多个@Primary会导致优先级设置无效\n\n### 2.9)bean的引用类型属性注入\n\n- 名称：@Inject、@Named、@Resource\n\n- 说明：\n  - @Inject与@Named是JSR330规范中的注解，功能与@Autowired和@Qualifier完全相同，适用于不同架构场景\n  - @Resource是JSR250规范中的注解，可以简化书写格式\n\n- @Resource相关属性\n\n  - name：设置注入的bean的id\n\n  - type：设置注入的bean的类型，接收的参数为Class类型\n\n### 2.10)加载properties文件\n\n- 名称：@PropertySource\n\n- 类型：**类注解**\n\n- 位置：类定义上方\n\n- 作用：加载properties文件中的属性值\n\n- 范例：\n\n  ```java\n  @PropertySource(value = "classpath:filename.properties")\n  public class ClassName {\n      @Value("${propertiesAttributeName}")\n      private String attributeName;\n  }\n  ```\n\n- 说明：\n\n  - 不支持*通配格式，一旦加载，所有spring控制的bean中均可使用对应属性值\n\n- 相关属性\n\n  - value（默认）：设置加载的properties文件名\n\n  - ignoreResourceNotFound：如果资源未找到，是否忽略，默认为false\n\n### 2.11)纯注解格式\n\n- 名称：@Configuration、@ComponentScan\n\n- 类型：**类注解**\n\n- 位置：类定义上方\n\n- 作用：设置当前类为spring核心配置加载类\n\n- 范例：\n\n  ```java\n  @Configuration\n  @ComponentScan("scanPackageName")\n  public class SpringConfigClassName{\n  }\n  ```\n\n- 说明：\n\n  - 核心配合类用于替换spring核心配置文件，此类可以设置空的，不设置变量与属性\n\n  - bean扫描工作使用注解@ComponentScan替代\n\n**AnnotationConfigApplicationContext**\n\n- 加载纯注解格式上下文对象，需要使用AnnotationConfigApplicationContext\n\n  ```java\n  AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);\n  ```\n\n### 2.12)第三方bean配置与管理\n\n- 名称：@Import\n\n- 类型：**类注解**\n\n- 位置：类定义上方\n\n- 作用：导入第三方bean作为spring控制的资源\n\n- 范例：\n\n  ```java\n  @Configuration\n  @Import(OtherClassName.class)\n  public class ClassName {\n  }\n  ```\n\n- 说明：\n\n  - @Import注解在同一个类上，仅允许添加一次，如果需要导入多个，使用数组的形式进行设定\n\n  - 在被导入的类中可以继续使用@Import导入其他资源（了解）\n\n  - @Bean所在的类可以使用导入的形式进入spring容器，无需声明为bean\n\n## 3)bean加载控制\n\n### 3.1)依赖加载\n\n(1)@DependsOn\n\n- 名称：@DependsOn\n\n- 类型：类注解、方法注解\n\n- 位置：bean定义的位置（类上或方法上）\n\n- 作用：控制bean的加载顺序，使其在指定bean加载完毕后再加载\n\n- 范例：\n\n  ```java\n  @DependsOn("beanId")\n  public class ClassName {\n  }\n  ```\n\n- 说明：\n\n  - 配置在方法上，使@DependsOn指定的bean优先于@Bean配置的bean进行加载\n\n  - 配置在类上，使@DependsOn指定的bean优先于当前类中所有@Bean配置的bean进行加载\n\n  - 配置在类上，使@DependsOn指定的bean优先于@Component等配置的bean进行加载\n\n- 相关属性\n  - value（默认）：设置当前bean所依赖的bean的id\n\n(2)@Order\n\n- 名称：@Order\n\n- 类型：**配置类注解**\n\n- 位置：配置类定义的位置（类上）\n\n- 作用：控制配置类的加载顺序\n\n- 范例：\n\n  ```java\n  @Order(1)\n  public class SpringConfigClassName {\n  }\n  ```\n\n(3)@Lazy\n\n- 名称：@Lazy\n\n- 类型：**类注解、方法注解**\n\n- 位置：bean定义的位置（类上或方法上）\n\n- 作用：控制bean的加载时机，使其延迟加载\n\n- 范例：\n\n  ```java\n  @Lazy\n  public class ClassName {\n  }\n  ```\n\n### **3.2)依赖加载应用场景**\n\n@DependsOn\n\n- 微信订阅号，发布消息和订阅消息的bean的加载顺序控制\n\n- 双11活动期间，零点前是结算策略A，零点后是结算策略B，策略B操作的数据为促销数据。策略B加载顺序与促销数据的加载顺序\n\n@Lazy\n\n- 程序灾难出现后对应的应急预案处理是启动容器时加载时机\n\n@Order\n\n- 多个种类的配置出现后，优先加载系统级的，然后加载业务级的，避免细粒度的加载控制\n\n\n\n## 4)整合第三方技术\n\n### 4.1)综合案例改版（注解整合MyBatis）\n\n![1591024717408](./Spring-day02/1591024717408.png)\n\n### 4.2)注解整合MyBatis分析\n\n- 业务类使用注解形式声明bean，属性采用注解注入\n\n- 建立独立的配置管理类，分类管理外部资源，根据功能进行分类，并提供对应的方法获取bean\n\n- 使用注解形式启动bean扫描，加载所有注解配置的资源（bean）\n\n- 使用AnnotationConfigApplicationContext对象加载所有的启动配置类，内部使用导入方式进行关联\n\n### 4.3)注解整合MyBatis步骤\n\n1.修改mybatis外部配置文件格式为注解格式\n\n2.业务类使用@Component声明bean，使用@Autowired注入对象\n\n3.建立配置文件JDBCConfig与MyBatisConfig类，并将其导入到核心配置类SpringConfig\n\n4.开启注解扫描\n\n5.使用AnnotationConfigApplicationContext对象加载配置项\n\n### 4.4)综合案例改版（注解整合Junit）\n\n1.Spring接管Junit的运行权，使用Spring专用的Junit类加载器\n\n2.为Junit测试用例设定对应的spring容器：\n\n- 从Spring5.0以后，要求Junit的版本必须是4.12及以上\n\n- Junit仅用于单元测试，不能将Junit的测试类配置成spring的bean，否则该配置将会被打包进入工程中 \n\n\n\n导入Spring整合Junit坐标\n\n```xml\n<dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.12</version>\n</dependency>\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-test</artifactId>\n    <version>5.1.9.RELEASE</version>\n</dependency>\n```\n\nSpring整合Junit测试用例注解格式\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(classes = SpringConfig.class)\npublic class UserServiceTest {\n}\n```\n\n## 5)IoC底层核心原理\n\n### 5.1)IoC核心接口\n\n![1591024936518](./Spring-day02/1591024936518.png)\n\n### **5.2)组件扫描器**\n\n- 开发过程中，需要根据需求加载必要的bean，排除指定bean\n\n![1591024975438](./Spring-day02/1591024975438.png)\n\n### **5.3)设定组件扫描加载过滤器**\n\n- 名称：@ComponentScan\n\n- 类型：**类注解**\n\n- 位置：类定义上方\n\n- 作用：设置spring配置加载类扫描规则\n\n- 范例：\n\n  ```java\n  @ComponentScan(\n      value="com.itheima",\t           //设置基础扫描路径\n      excludeFilters =                          //设置过滤规则，当前为排除过滤\n  \t@ComponentScan.Filter(            //设置过滤器\n  \t    type= FilterType.ANNOTATION,  //设置过滤方式为按照注解进行过滤\n  \t    classes=Repository.class)     //设置具体的过滤项，过滤所有@Repository修饰的bean\n      )\n  ```\n\n​\tincludeFilters：设置包含性过滤器\n\n​\texcludeFilters：设置排除性过滤器\n\n​\ttype：设置过滤器类型\n\n### **5.4)自定义组件过滤器**\n\n- 名称：TypeFilter\n\n- 类型：**接口**\n\n- 作用：自定义类型过滤器\n\n- 范例：\n\n  ```java\n  public class MyTypeFilter implements TypeFilter {\n      public boolean match(MetadataReader mr, MetadataReaderFactory mrf) throws IOException {\n          ClassMetadata cm = metadataReader.getClassMetadata();\n          tring className = cm.getClassName();\n          if(className.equals("com.itheima.dao.impl.BookDaoImpl")){\n              return false;\n          }\n          return false;\n      }\n  }\n  ```\n\n### **5.5)自定义导入器**\n\n- bean只有通过配置才可以进入spring容器，被spring加载并控制\n\n- 配置bean的方式如下：\n\n  - XML文件中使用<bean/>标签配置\n\n  - 使用@Component及衍生注解配置\n\n- 企业开发过程中，通常需要配置大量的bean，需要一种快速高效配置大量bean的方式\n\n**ImportSelector**\n\n- 名称： ImportSelector\n\n- 类型：**接口**\n\n- 作用：自定义bean导入器\n\n- 范例：\n\n  ```java\n  public class MyImportSelector implements ImportSelector {\n      public String[] selectImports(AnnotationMetadata icm) {\n          return new String[]{"com.itheima.dao.impl.AccountDaoImpl"};\n      }\n  }\n  ```\n\n  ```java\n  @Configuration\n  @ComponentScan("com.itheima")\n  @Import(MyImportSelector.class)\n  public class SpringConfig {\n  }\n  ```\n\n### **5.6)自定义注册器**\n\n- 名称：ImportBeanDefinitionRegistrar\n\n- 类型：**接口**\n\n- 作用：自定义bean定义注册器\n\n- 范例：\n\n  ```java\n  public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {\n      public void registerBeanDefinitions(AnnotationMetadata icm, BeanDefinitionRegistry r) {\n          ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(r, false);\n          TypeFilter tf = new TypeFilter() {\n              public boolean match(MetadataReader mr, MetadataReaderFactory mrf) throws IOException {\n                  return true;\n              }\n          };\n          scanner.addIncludeFilter(tf);\n          //scanner.addExcludeFilter(tf);\n          scanner.scan("com.itheima");\n      }\n  }\n  ```\n\n### 5.7)bean初始化过程解析\n\n![1591025338778](./Spring-day02/1591025338778.png)\n\n### 5.8)bean初始化过程解析\n\n- BeanFactoryPostProcessor\n\n  - 作用：定义了在bean工厂对象创建后，bean对象创建前执行的动作，用于对工厂进行创建后业务处理\n\n  - 运行时机：当前操作用于对工厂进行处理，仅运行一次\n\n- BeanPostProcessor\n\n  - 作用：定义了所有bean初始化前后进行的统一动作，用于对bean进行创建前业务处理与创建后业务处理\n\n  - 运行时机：当前操作伴随着每个bean的创建过程，每次创建bean均运行该操作\n\n- InitializingBean\n\n  - 作用：定义了每个bean的初始化前进行的动作，属于非统一性动作，用于对bean进行创建前业务处理\n\n  - 运行时机：当前操作伴随着任意一个bean的创建过程，保障其个性化业务处理\n\n- 注意：上述操作均需要被spring容器加载放可运行\n\n### 5.9)bean初始化过程解析\n\n![1591025440019](./Spring-day02/1591025440019.png)\n\n### 5.10)繁琐的bean初始化过程处理\n\n- FactoryBean\n  - 对单一的bean的初始化过程进行封装，达到简化配置的目的\n\n**FactoryBean与BeanFactory区别**\n\n- FactoryBean：封装单个bean的创建过程\n\n- BeanFactory：Spring容器顶层接口，定义了bean相关的获取操作\n\n'},aaf8:function(n,e,t){"use strict";t.r(e),e["default"]='> 可选标题：工作半年，变量命名不规范，被diss了！\n>\n> 项目组新来的实习生因为变量命名被 “diss” 了！\n\n大家好，这里是热爱分享的 Guide ！\n\n我还记得我刚工作那一段时间， 项目 Code Review 的时候，我经常因为变量命名不规范而被 “diss”!\n\n究其原因还是自己那会经验不足，而且，大学那会写项目的时候不太注意这些问题，想着只要把功能实现出来就行了。\n\n但是，工作中就不一样，为了代码的可读性、可维护性，项目组对于代码质量的要求还是很高的！\n\n前段时间，项目组新来的一个实习生也经常在 Code Review 因为变量命名不规范而被 “diss”，这让我想到自己刚到公司写代码那会的日子。\n\n于是，我就简单写了这篇关于变量命名规范的文章，希望能对同样有此困扰的小伙伴提供一些帮助。\n\n确实，编程过程中，有太多太多让我们头疼的事情了，比如命名、维护其他人的代码、写测试、与其他人沟通交流等等。\n\n据说之前在 Quora 网站，由接近 5000 名程序员票选出来的最难的事情就是“命名”。\n\n大名鼎鼎的《重构》的作者老马（Martin Fowler）曾经在[TwoHardThings](https://martinfowler.com/bliki/TwoHardThings.html)这篇文章中提到过CS 领域有两大最难的事情：一是 **缓存失效** ，一是 **程序命名** 。\n\n![](naming.assets/marting-naming.png)\n\n这个句话实际上也是老马引用别人的，类似的表达还有很多。比如分布式系统领域有两大最难的事情：一是 **保证消息顺序** ，一是 **严格一次传递** 。\n\n![](naming.assets/20210629104844645.png)\n\n今天咱们就单独拎出 “**命名**” 来聊聊！\n\n这篇文章配合我之前发的 [《编码 5 分钟，命名 2 小时？史上最全的 Java 命名规范参考！》](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486449&idx=1&sn=c3b502529ff991c7180281bcc22877af&chksm=cea2443af9d5cd2c1c87049ed15ccf6f88275419c7dbe542406166a703b27d0f3ecf2af901f8&token=999884676&lang=zh_CN#rd) 这篇文章阅读效果更佳哦！\n\n## 为什么需要重视命名？\n\n咱们需要先搞懂为什么要重视编程中的命名这一行为，它对于我们的编码工作有着什么意义。\n\n**为什么命名很重要呢？** 这是因为 **好的命名即是注释，别人一看到你的命名就知道你的变量、方法或者类是做什么的！**\n\n简单来说就是 **别人根据你的命名就能知道你的代码要表达的意思** （不过，前提这个人也要有基本的英语知识，对于一些编程中常见的单词比较熟悉）。\n\n简单举个例子说明一下命名的重要性。\n\n《Clean Code》这本书明确指出：\n\n> **好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。**\n>\n> **若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。**\n>\n> 举个例子：\n>\n> 去掉下面复杂的注释，只需要创建一个与注释所言同一事物的函数即可\n>\n> ```java\n> // check to see if the employee is eligible for full benefits\n> if ((employee.flags & HOURLY_FLAG) && (employee.age > 65))\n> ```\n>\n> 应替换为\n>\n> ```java\n> if (employee.isEligibleForFullBenefits())\n> ```\n\n## 常见命名规则以及适用场景\n\n这里只介绍 3 种最常见的命名规范。\n\n### 驼峰命名法（CamelCase）\n\n驼峰命名法应该我们最常见的一个，这种命名方式使用大小写混合的格式来区别各个单词，并且单词之间不使用空格隔开或者连接字符连接的命名方式\n\n#### 大驼峰命名法（UpperCamelCase）\n\n**类名需要使用大驼峰命名法（UpperCamelCase）**\n\n正例：\n\n```java\nServiceDiscovery、ServiceInstance、LruCacheFactory\n```\n\n反例：\n\n```java\nserviceDiscovery、Serviceinstance、LRUCacheFactory\n```\n\n#### 小驼峰命名法（lowerCamelCase）\n\n**方法名、参数名、成员变量、局部变量需要使用小驼峰命名法（lowerCamelCase）。**\n\n正例：\n\n```java\ngetUserInfo()\ncreateCustomThreadPool()\nsetNameFormat(String nameFormat)\nUservice userService;\n```\n\n反例：\n\n```java\nGetUserInfo()、CreateCustomThreadPool()、setNameFormat(String NameFormat)\nUservice user_service\n```\n\n### 蛇形命名法（snake_case）\n\n**测试方法名、常量、枚举名称需要使用蛇形命名法（snake_case）**\n\n在蛇形命名法中，各个单词之间通过下划线“\\_”连接，比如`should_get_200_status_code_when_request_is_valid`、`CLIENT_CONNECT_SERVER_FAILURE`。\n\n蛇形命名法的优势是命名所需要的单词比较多的时候，比如我把上面的命名通过小驼峰命名法给大家看一下：“shouldGet200StatusCodeWhenRequestIsValid”。\n\n感觉如何？ 相比于使用蛇形命名法（snake_case）来说是不是不那么易读？\n\n正例：\n\n```java\n@Test\nvoid should_get_200_status_code_when_request_is_valid() {\n  ......\n}\n```\n\n反例：\n\n```java\n@Test\nvoid shouldGet200StatusCodeWhenRequestIsValid() {\n  ......\n}\n```\n\n### 串式命名法（kebab-case）\n\n在串式命名法中，各个单词之间通过连接符“-”连接，比如`dubbo-registry`。\n\n建议项目文件夹名称使用串式命名法（kebab-case），比如 dubbo 项目的各个模块的命名是下面这样的。\n\n![](naming.assets/dubbo-naming.png)\n\n## 常见命名规范\n\n### Java 语言基本命名规范\n\n**1、类名需要使用大驼峰命名法（UpperCamelCase）风格。方法名、参数名、成员变量、局部变量需要使用小驼峰命名法（lowerCamelCase）。**\n\n**2、测试方法名、常量、枚举名称需要使用蛇形命名法（snake_case）**，比如`should_get_200_status_code_when_request_is_valid`、`CLIENT_CONNECT_SERVER_FAILURE`。并且，**测试方法名称要求全部小写，常量以及枚举名称需要全部大写。**\n\n**3、项目文件夹名称使用串式命名法（kebab-case），比如`dubbo-registry`。**\n\n**4、包名统一使用小写，尽量使用单个名词作为包名，各个单词通过 "." 分隔符连接，并且各个单词必须为单数。**\n\n正例： `org.apache.dubbo.common.threadlocal`\n\n反例： ~~`org.apache_dubbo.Common.threadLocals`~~\n\n**5、抽象类命名使用 Abstract 开头**。\n\n```java\n//为远程传输部分抽象出来的一个抽象类（出处：Dubbo源码）\npublic abstract class AbstractClient extends AbstractEndpoint implements Client {\n\n}\n```\n\n**6、异常类命名使用 Exception 结尾。**\n\n```java\n//自定义的 NoSuchMethodException（出处：Dubbo源码）\npublic class NoSuchMethodException extends RuntimeException {\n    private static final long serialVersionUID = -2725364246023268766L;\n\n    public NoSuchMethodException() {\n        super();\n    }\n\n    public NoSuchMethodException(String msg) {\n        super(msg);\n    }\n}\n```\n\n**7、测试类命名以它要测试的类的名称开始，以 Test 结尾。**\n\n```java\n//为 AnnotationUtils 类写的测试类（出处：Dubbo源码）\npublic class AnnotationUtilsTest {\n  ......\n}\n```\n\nPOJO 类中布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误。\n\n如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。\n\n### 命名易读性规范\n\n**1、为了能让命名更加易懂和易读，尽量不要缩写/简写单词，除非这些单词已经被公认可以被这样缩写/简写。比如 `CustomThreadFactory` 不可以被写成 ~~`CustomTF` 。**\n\n**2、命名不像函数一样要尽量追求短，可读性强的名字优先于简短的名字，虽然可读性强的名字会比较长一点。** 这个对应我们上面说的第 1 点。\n\n**3、避免无意义的命名，你起的每一个名字都要能表明意思。**\n\n正例：`UserService userService;` `int userCount`;\n\n反例: ~~`UserService service`~~ ~~`int count`~~\n\n**4、避免命名过长（50 个字符以内最好），过长的命名难以阅读并且丑陋。**\n\n**5、不要使用拼音，更不要使用中文。** 不过像 alibaba 、wuhan、taobao 这种国际通用名词可以当做英文来看待。\n\n正例：discount\n\n反例：~~dazhe~~\n\n## Codelf:变量命名神器?\n\n这是一个由国人开发的网站，网上有很多人称其为变量命名神器， 我在实际使用了几天之后感觉没那么好用。小伙伴们可以自行体验一下，然后再给出自己的判断。\n\nCodelf 提供了在线网站版本，网址：[https://unbug.github.io/codelf/](https://unbug.github.io/codelf/)，具体使用情况如下：\n\n我选择了 Java 编程语言，然后搜索了“序列化”这个关键词，然后它就返回了很多关于序列化的命名。\n\n![](naming.assets/Codelf.png)\n\n并且，Codelf 还提供了 VS code 插件，看这个评价，看来大家还是很喜欢这款命名工具的。\n\n![](naming.assets/vscode-codelf.png)\n\n## 相关阅读推荐\n\n1. 《阿里巴巴 Java 开发手册》\n2. 《Clean Code》\n3. Google Java 代码指南：https://google.github.io/styleguide/javaguide.html#s5.1-identifier-name\n4. 告别编码5分钟，命名2小时！史上最全的Java命名规范参考：https://www.cnblogs.com/liqiangchn/p/12000361.html \n\n## 总结\n\n作为一个合格的程序员，小伙伴们应该都知道代码表义的重要性。想要写出高质量代码，好的命名就是第一步！\n\n好的命名对于其他人（包括你自己）理解你的代码有着很大的帮助！你的代码越容易被理解，可维护性就越强，侧面也就说明你的代码设计的也就越好！\n\n在日常编码过程中，我们需要谨记常见命名规范比如类名需要使用大驼峰命名法、不要使用拼音，更不要使用中文......。\n\n另外，国人开发的一个叫做 Codelf 的网站被很多人称为“变量命名神器”，当你为命名而头疼的时候，你可以去参考一下上面提供的一些命名示例。\n\n最后，祝愿大家都不用再为命名而困扰!\n\n'},ab7d:function(n,e,t){var r={"./ArrayList源码+扩容机制分析.md":"240e","./ConcurrentHashMap源码+底层数据结构分析.md":"806b","./HashMap(JDK1.8)源码+底层数据结构分析.md":"d506","./Java集合使用注意事项总结.md":"ee72","./Java集合框架常见面试题.md":"cc1d","./LinkedList源码分析.md":"da37"};function a(n){var e=i(n);return t(e)}function i(n){if(!t.o(r,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return r[n]}a.keys=function(){return Object.keys(r)},a.resolve=i,n.exports=a,a.id="ab7d"},af14:function(n,e,t){"use strict";t.r(e),e["default"]='## 为什么需要定时任务？\n\n我们来看一下几个非常常见的业务场景：\n\n1. 某系统凌晨要进行数据备份。\n2. 某电商平台，用户下单半个小时未支付的情况下需要自动取消订单。\n3. 某媒体聚合平台，每 10 分钟动态抓取某某网站的数据为自己所用。\n4. 某博客平台，支持定时发送文章。\n5. 某基金平台，每晚定时计算用户当日收益情况并推送给用户最新的数据。\n6. ......\n\n这些场景往往都要求我们在某个特定的时间去做某个事情。\n\n## 单机定时任务技术选型\n\n### Timer\n\n`java.util.Timer`是 JDK 1.3 开始就已经支持的一种定时任务的实现方式。\n\n`Timer` 内部使用一个叫做 `TaskQueue` 的类存放定时任务，它是一个基于最小堆实现的优先级队列。`TaskQueue` 会按照任务距离下一次执行时间的大小将任务排序，保证在堆顶的任务最先执行。这样在需要执行任务时，每次只需要取出堆顶的任务运行即可！\n\n`Timer` 使用起来比较简单，通过下面的方式我们就能创建一个 1s 之后执行的定时任务。\n\n```java\n// 示例代码：\nTimerTask task = new TimerTask() {\n    public void run() {\n        System.out.println("当前时间: " + new Date() + "n" +\n                "线程名称: " + Thread.currentThread().getName());\n    }\n};\nSystem.out.println("当前时间: " + new Date() + "n" +\n        "线程名称: " + Thread.currentThread().getName());\nTimer timer = new Timer("Timer");\nlong delay = 1000L;\ntimer.schedule(task, delay);\n\n\n//输出：\n当前时间: Fri May 28 15:18:47 CST 2021n线程名称: main\n当前时间: Fri May 28 15:18:48 CST 2021n线程名称: Timer\n```\n\n不过其缺陷较多，比如一个 `Timer` 一个线程，这就导致 `Timer` 的任务的执行只能串行执行，一个任务执行时间过长的话会影响其他任务（性能非常差），再比如发生异常时任务直接停止（`Timer` 只捕获了 `InterruptedException` ）。\n\n`Timer` 类上的有一段注释是这样写的：\n\n```JAVA\n * This class does not offer real-time guarantees: it schedules\n * tasks using the <tt>Object.wait(long)</tt> method.\n *Java 5.0 introduced the {@code java.util.concurrent} package and\n * one of the concurrency utilities therein is the {@link\n * java.util.concurrent.ScheduledThreadPoolExecutor\n * ScheduledThreadPoolExecutor} which is a thread pool for repeatedly\n * executing tasks at a given rate or delay.  It is effectively a more\n * versatile replacement for the {@code Timer}/{@code TimerTask}\n * combination, as it allows multiple service threads, accepts various\n * time units, and doesn\'t require subclassing {@code TimerTask} (just\n * implement {@code Runnable}).  Configuring {@code\n * ScheduledThreadPoolExecutor} with one thread makes it equivalent to\n * {@code Timer}.\n```\n\n大概的意思就是： `ScheduledThreadPoolExecutor` 支持多线程执行定时任务并且功能更强大，是 `Timer` 的替代品。\n\n### ScheduledExecutorService\n\n`ScheduledExecutorService` 是一个接口，有多个实现类，比较常用的是 `ScheduledThreadPoolExecutor` 。\n\n![](Java定时任务大揭秘.assets/20210607154324712.png)\n\n`ScheduledThreadPoolExecutor` 本身就是一个线程池，支持任务并发执行。并且，其内部使用 `DelayQueue` 作为任务队列。\n\n```java\n// 示例代码：\nTimerTask repeatedTask = new TimerTask() {\n    @SneakyThrows\n    public void run() {\n        System.out.println("当前时间: " + new Date() + "n" +\n                "线程名称: " + Thread.currentThread().getName());\n    }\n};\nSystem.out.println("当前时间: " + new Date() + "n" +\n        "线程名称: " + Thread.currentThread().getName());\nScheduledExecutorService executor = Executors.newScheduledThreadPool(3);\nlong delay  = 1000L;\nlong period = 1000L;\nexecutor.scheduleAtFixedRate(repeatedTask, delay, period, TimeUnit.MILLISECONDS);\nThread.sleep(delay + period * 5);\nexecutor.shutdown();\n//输出：\n当前时间: Fri May 28 15:40:46 CST 2021n线程名称: main\n当前时间: Fri May 28 15:40:47 CST 2021n线程名称: pool-1-thread-1\n当前时间: Fri May 28 15:40:48 CST 2021n线程名称: pool-1-thread-1\n当前时间: Fri May 28 15:40:49 CST 2021n线程名称: pool-1-thread-2\n当前时间: Fri May 28 15:40:50 CST 2021n线程名称: pool-1-thread-2\n当前时间: Fri May 28 15:40:51 CST 2021n线程名称: pool-1-thread-2\n当前时间: Fri May 28 15:40:52 CST 2021n线程名称: pool-1-thread-2\n```\n\n不论是使用 `Timer` 还是 `ScheduledExecutorService` 都无法使用 Cron 表达式指定任务执行的具体时间。\n\n### Spring Task\n\n\n\n我们直接通过 Spring 提供的 `@Scheduled` 注解即可定义定时任务，非常方便！\n\n```java\n/**\n * cron：使用Cron表达式。　每分钟的1，2秒运行\n */\n@Scheduled(cron = "1-2 * * * * ? ")\npublic void reportCurrentTimeWithCronExpression() {\n  log.info("Cron Expression: The time is now {}", dateFormat.format(new Date()));\n}\n\n```\n\n我在大学那会做的一个 SSM 的企业级项目，就是用的 Spring Task 来做的定时任务。\n\n并且，Spring Task 还是支持 **Cron 表达式** 的。Cron 表达式主要用于定时作业(定时任务)系统定义执行时间或执行频率的表达式，非常厉害，你可以通过 Cron 表达式进行设置定时任务每天或者每个月什么时候执行等等操作。咱们要学习定时任务的话，Cron 表达式是一定是要重点关注的。推荐一个在线 Cron 表达式生成器：[http://cron.qqe2.com/](http://cron.qqe2.com/) 。\n\n但是，Spring 自带的定时调度只支持单机，并且提供的功能比较单一。之前写过一篇文章:[《5 分钟搞懂如何在 Spring Boot 中 Schedule Tasks》](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485563&idx=1&sn=7419341f04036a10b141b74624a3f8c9&chksm=cea247b0f9d5cea6440759e6d49b4e77d06f4c99470243a10c1463834e873ca90266413fbc92&token=2133161636&lang=zh_CN#rd) ，不了解的小伙伴可以参考一下。\n\nSpring Task 底层是基于 JDK 的 `ScheduledThreadPoolExecutor` 线程池来实现的。\n\n**优缺点总结：**\n\n- 优点： 简单，轻量，支持 Cron 表达式\n- 缺点 ：功能单一\n\n### 时间轮\n\nKafka、Dubbo、ZooKeeper、Netty 、Caffeine 、Akka 中都有对时间轮的实现。\n\n时间轮简单来说就是一个环形的队列（底层一般基于数组实现），队列中的每一个元素（时间格）都可以存放一个定时任务列表。\n\n时间轮中的每个时间格代表了时间轮的基本时间跨度或者说时间精度，加入时间一秒走一个时间格的话，那么这个时间轮的最高精度就是 1 秒（也就是说 3 s 和 3.9s 会在同一个时间格中）。\n\n下图是一个有 12 个时间格的时间轮，转完一圈需要 12 s。当我们需要新建一个 3s 后执行的定时任务，只需要将定时任务放在下标为 3 的时间格中即可。当我们需要新建一个 9s 后执行的定时任务，只需要将定时任务放在下标为 9 的时间格中即可。\n\n![](Java定时任务大揭秘.assets/20210607171334861.png)\n\n那当我们需要创建一个 13s 后执行的定时任务怎么办呢？这个时候可以引入一叫做 **圈数/轮数** 的概念，也就是说这个任务还是放在下标为 3 的时间格中， 不过它的圈数为 2 。\n\n除了增加圈数这种方法之外，还有一种 **多层次时间轮** （类似手表），Kafka 采用的就是这种方案。\n\n针对下图的时间轮，我来举一个例子便于大家理解。\n\n![](Java定时任务大揭秘.assets/20210607193042151.png)\n\n上图的时间轮，第 1 层的时间精度为 1 ，第 2 层的时间精度为 20 ，第 3 层的时间精度为 400。假如我们需要添加一个 350s 后执行的任务 A 的话（当前时间是 0s），这个任务会被放在第 2 层（因为第二层的时间跨度为 20\\*20=400>350）的第 350/20=17 个时间格子。\n\n当第一层转了 17 圈之后，时间过去了 340s ，第 2 层的指针此时来到第 17 个时间格子。此时，第 2 层第 17 个格子的任务会被移动到第 1 层。\n\n任务 A 当前是 10s 之后执行，因此它会被移动到第 1 层的第 10 个时间格子。\n\n这里在层与层之间的移动也叫做时间轮的升降级。参考手表来理解就好！\n\n \n\n**时间轮比较适合任务数量比较多的定时任务场景，它的任务写入和执行的时间复杂度都是 0（1）。**\n\n## 分布式定时任务技术选型\n\n上面提到的一些定时任务的解决方案都是在单机下执行的，适用于比较简单的定时任务场景比如每天凌晨备份一次数据。\n\n如果我们需要一些高级特性比如支持任务在分布式场景下的分片和高可用的话，我们就需要用到分布式任务调度框架了。\n\n通常情况下，一个定时任务的执行往往涉及到下面这些角色：\n\n- **任务** ： 首先肯定是要执行的任务，这个任务就是具体的业务逻辑比如定时发送文章。\n- **调度器** ：其次是调度中心，调度中心主要负责任务管理，会分配任务给执行器。\n- **执行器** ： 最后就是执行器，执行器接收调度器分派的任务并执行。\n\n### Quartz\n\n \n\n一个很火的开源任务调度框架，完全由`Java`写成。`Quartz` 可以说是 Java 定时任务领域的老大哥或者说参考标准，其他的任务调度框架基本都是基于 `Quartz` 开发的，比如当当网的`elastic-job`就是基于`quartz`二次开发之后的分布式调度解决方案。\n\n使用 `Quartz` 可以很方便地与 `Spring` 集成，并且支持动态添加任务和集群。但是，`Quartz` 使用起来也比较麻烦，API 繁琐。\n\n并且，`Quzrtz` 并没有内置 UI 管理控制台，不过你可以使用 [quartzui](https://github.com/zhaopeiym/quartzui) 这个开源项目来解决这个问题。\n\n另外，`Quartz` 虽然也支持分布式任务。但是，它是在数据库层面，通过数据库的锁机制做的，有非常多的弊端比如系统侵入性严重、节点负载不均衡。有点伪分布式的味道。\n\n**优缺点总结：**\n\n- 优点： 可以与 `Spring` 集成，并且支持动态添加任务和集群。\n- 缺点 ：分布式支持不友好，没有内置 UI 管理控制台、使用麻烦（相比于其他同类型框架来说）\n\n### Elastic-Job\n\n \n\n`Elastic-Job` 是当当网开源的一个基于`Quartz`和`ZooKeeper`的分布式调度解决方案，由两个相互独立的子项目 `Elastic-Job-Lite` 和 `Elastic-Job-Cloud` 组成，一般我们只要使用 `Elastic-Job-Lite` 就好。\n\n`ElasticJob` 支持任务在分布式场景下的分片和高可用、任务可视化管理等功能。\n\n![](Java定时任务大揭秘.assets/20210608080437356.png)\n\nElasticJob-Lite 的架构设计如下图所示：\n\n![](Java定时任务大揭秘.assets/up-a8f63f828666d43009d5d3497bcbd2cfb61.png)\n\n从上图可以看出，`Elastic-Job` 没有调度中心这一概念，而是使用 `ZooKeeper` 作为注册中心，注册中心负责协调分配任务到不同的节点上。\n\nElastic-Job 中的定时调度都是由执行器自行触发，这种设计也被称为去中心化设计（调度和处理都是执行器单独完成）。\n\n```java\n@Component\n@ElasticJobConf(name = "dayJob", cron = "0/10 * * * * ?", shardingTotalCount = 2,\n        shardingItemParameters = "0=AAAA,1=BBBB", description = "简单任务", failover = true)\npublic class TestJob implements SimpleJob {\n    @Override\n    public void execute(ShardingContext shardingContext) {\n        log.info("TestJob任务名：【{}】, 片数：【{}】, param=【{}】", shardingContext.getJobName(), shardingContext.getShardingTotalCount(),\n                shardingContext.getShardingParameter());\n    }\n}\n```\n\n**相关地址：**\n\n- Github 地址：https://github.com/apache/shardingsphere-elasticjob。\n- 官方网站：https://shardingsphere.apache.org/elasticjob/index_zh.html 。\n\n**优缺点总结：**\n\n- 优点 ：可以与 `Spring` 集成、支持分布式、支持集群、性能不错\n- 缺点 ：依赖了额外的中间件比如 Zookeeper（复杂度增加，可靠性降低、维护成本变高）\n\n### XXL-JOB\n\n`XXL-JOB` 于 2015 年开源，是一款优秀的轻量级分布式任务调度框架，支持任务可视化管理、弹性扩容缩容、任务失败重试和告警、任务分片等功能，\n\n![](Java定时任务大揭秘.assets/20210608080550433.png)\n\n根据 `XXL-JOB` 官网介绍，其解决了很多 `Quartz` 的不足。\n\n![](Java定时任务大揭秘.assets/20210607202503193.png)\n\n`XXL-JOB` 的架构设计如下图所示：\n\n![](Java定时任务大揭秘.assets/up-b8ecc6acf651f112c4dfae98243d72adea3.png)\n\n从上图可以看出，`XXL-JOB` 由 **调度中心** 和 **执行器** 两大部分组成。调度中心主要负责任务管理、执行器管理以及日志管理。执行器主要是接收调度信号并处理。另外，调度中心进行任务调度时，是通过自研 RPC 来实现的。\n\n不同于 `Elastic-Job` 的去中心化设计， `XXL-JOB` 的这种设计也被称为中心化设计（调度中心调度多个执行器执行任务）。\n\n和 `Quzrtz` 类似 `XXL-JOB` 也是基于数据库锁调度任务，存在性能瓶颈。不过，一般在任务量不是特别大的情况下，没有什么影响的，可以满足绝大部分公司的要求。\n\n不要被 `XXL-JOB` 的架构图给吓着了，实际上，我们要用 `XXL-JOB` 的话，只需要重写 `IJobHandler` 自定义任务执行逻辑就可以了，非常易用！\n\n```java\n@JobHandler(value="myApiJobHandler")\n@Component\npublic class MyApiJobHandler extends IJobHandler {\n\n    @Override\n    public ReturnT<String> execute(String param) throws Exception {\n        //......\n        return ReturnT.SUCCESS;\n    }\n}\n```\n\n还可以直接基于注解定义任务。\n\n```java\n@XxlJob("myAnnotationJobHandler")\npublic ReturnT<String> myAnnotationJobHandler(String param) throws Exception {\n  //......\n  return ReturnT.SUCCESS;\n}\n```\n\n![](Java定时任务大揭秘.assets/20210607200728212.png)\n\n**相关地址：**\n\n- Github 地址：https://github.com/xuxueli/xxl-job/。\n- 官方介绍：https://www.xuxueli.com/xxl-job/ 。\n\n**优缺点总结：**\n\n- 优点：开箱即用（学习成本比较低）、与 Spring 集成、支持分布式、支持集群、内置了 UI 管理控制台。\n- 缺点：不支持动态添加任务（如果一定想要动态创建任务也是支持的，参见：[xxl-job issue277](https://github.com/xuxueli/xxl-job/issues/277)）。\n\n### PowerJob\n\n非常值得关注的一个分布式任务调度框架，分布式任务调度领域的新星。目前，已经有很多公司接入比如 OPPO、京东、中通、思科。\n\n这个框架的诞生也挺有意思的，PowerJob 的作者当时在阿里巴巴实习过，阿里巴巴那会使用的是内部自研的 SchedulerX（阿里云付费产品）。实习期满之后，PowerJob 的作者离开了阿里巴巴。想着说自研一个 SchedulerX，防止哪天 SchedulerX 满足不了需求，于是 PowerJob 就诞生了。\n\n更多关于 PowerJob 的故事，小伙伴们可以去看看 PowerJob 作者的视频 [《我和我的任务调度中间件》](https://www.bilibili.com/video/BV1SK411A7F3/)。简单点概括就是：“游戏没啥意思了，我要扛起了新一代分布式任务调度与计算框架的大旗！”。\n\n由于 SchedulerX 属于人民币产品，我这里就不过多介绍。PowerJob 官方也对比过其和 QuartZ、XXL-JOB 以及 SchedulerX。\n\n![](Java定时任务大揭秘.assets/up-795f5e9b0d875063717b1ee6a08f2ff1c01.png)\n\n## 总结\n\n这篇文章中，我主要介绍了：\n\n- **定时任务的相关概念** ：为什么需要定时任务、定时任务中的核心角色、分布式定时任务。\n- **定时任务的技术选型** ： XXL-JOB 2015 年推出，已经经过了很多年的考验。XXL-JOB 轻量级，并且使用起来非常简单。虽然存在性能瓶颈，但是，在绝大多数情况下，对于企业的基本需求来说是没有影响的。PowerJob 属于分布式任务调度领域里的新星，其稳定性还有待继续考察。ElasticJob 由于在架构设计上是基于 Zookeeper ，而 XXL-JOB 是基于数据库，性能方面的话，ElasticJob 略胜一筹。\n\n这篇文章并没有介绍到实际使用，但是，并不代表实际使用不重要。我在写这篇文章之前，已经动手写过相应的 Demo。像 Quartz，我在大学那会就用过。不过，当时用的是 Spring 。为了能够更好地体验，我自己又在 Spring Boot 上实际体验了一下。如果你并没有实际使用某个框架，就直接说它并不好用的话，是站不住脚的。\n\n最后，这篇文章要感谢艿艿的帮助，写这篇文章的时候向艿艿询问过一些问题。推荐一篇艿艿写的偏实战类型的硬核文章：[《Spring Job？Quartz？XXL-Job？年轻人才做选择，艿艿全莽~》](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247490679&idx=1&sn=25374dbdcca95311d41be5d7b7db454d&chksm=fa4963c6cd3eead055bb9cd10cca13224bb35d0f7373a27aa22a55495f71e24b8273a7603314&scene=27#wechat_redirect) 。'},b0e9:function(n,e,t){"use strict";t.r(e),e["default"]='# 我，一个10年老程序员，最近才开始用 Java 8 新特性\n\n> 本文来自[cowbi](https://github.com/cowbi)的投稿~\n\nOracle 于 2014 发布了 Java8（jdk1.8），诸多原因使它成为目前市场上使用最多的 jdk 版本。虽然发布距今已将近 7 年，但很多程序员对其新特性还是不够了解，尤其是用惯了 java8 之前版本的老程序员，比如我。\n\n为了不脱离队伍太远，还是有必要对这些新特性做一些总结梳理。它较 jdk.7 有很多变化或者说是优化，比如 interface 里可以有静态方法，并且可以有方法体，这一点就颠覆了之前的认知；`java.util.HashMap` 数据结构里增加了红黑树；还有众所周知的 Lambda 表达式等等。本文不能把所有的新特性都给大家一一分享，只列出比较常用的新特性给大家做详细讲解。更多相关内容请看[官网关于 Java8 的新特性的介绍](https://www.oracle.com/java/technologies/javase/8-whats-new.html)。\n\n## Interface\n\ninterface 的设计初衷是面向抽象，提高扩展性。这也留有一点遗憾，Interface 修改的时候，实现它的类也必须跟着改。\n\n为了解决接口的修改与现有的实现不兼容的问题。新 interface 的方法可以用`default` 或 `static`修饰，这样就可以有方法体，实现类也不必重写此方法。\n\n一个 interface 中可以有多个方法被它们修饰，这 2 个修饰符的区别主要也是普通方法和静态方法的区别。\n\n1. `default`修饰的方法，是普通实例方法，可以用`this`调用，可以被子类继承、重写。\n2. `static`修饰的方法，使用上和一般类静态方法一样。但它不能被子类继承，只能用`Interface`调用。\n\n我们来看一个实际的例子。\n\n```java\npublic interface InterfaceNew {\n    static void sm() {\n        System.out.println("interface提供的方式实现");\n    }\n    static void sm2() {\n        System.out.println("interface提供的方式实现");\n    }\n\n    default void def() {\n        System.out.println("interface default方法");\n    }\n    default void def2() {\n        System.out.println("interface default2方法");\n    }\n    //须要实现类重写\n    void f();\n}\n\npublic interface InterfaceNew1 {\n    default void def() {\n        System.out.println("InterfaceNew1 default方法");\n    }\n}\n```\n\n如果有一个类既实现了 `InterfaceNew` 接口又实现了 `InterfaceNew1`接口，它们都有`def()`，并且 `InterfaceNew` 接口和 `InterfaceNew1`接口没有继承关系的话，这时就必须重写`def()`。不然的话，编译的时候就会报错。\n\n```java\npublic class InterfaceNewImpl implements InterfaceNew , InterfaceNew1{\n    public static void main(String[] args) {\n        InterfaceNewImpl interfaceNew = new InterfaceNewImpl();\n        interfaceNew.def();\n    }\n\n    @Override\n    public void def() {\n        InterfaceNew1.super.def();\n    }\n\n    @Override\n    public void f() {\n    }\n}\n```\n\n**在 Java 8 ，接口和抽象类有什么区别的？**\n\n很多小伙伴认为：“既然 interface 也可以有自己的方法实现，似乎和 abstract class 没多大区别了。”\n\n其实它们还是有区别的\n\n1. interface 和 class 的区别，好像是废话，主要有：\n\n   - 接口多实现，类单继承\n   - 接口的方法是 public abstract 修饰，变量是 public static final 修饰。 abstract class 可以用其他修饰符\n\n2. interface 的方法是更像是一个扩展插件。而 abstract class 的方法是要继承的。\n\n开始我们也提到，interface 新增`default`和`static`修饰的方法，为了解决接口的修改与现有的实现不兼容的问题，并不是为了要替代`abstract class`。在使用上，该用 abstract class 的地方还是要用 abstract class，不要因为 interface 的新特性而将之替换。\n\n**记住接口永远和类不一样。**\n\n## functional interface 函数式接口\n\n**定义**：也称 SAM 接口，即 Single Abstract Method interfaces，有且只有一个抽象方法，但可以有多个非抽象方法的接口。\n\n在 java 8 中专门有一个包放函数式接口`java.util.function`，该包下的所有接口都有 `@FunctionalInterface` 注解，提供函数式编程。\n\n在其他包中也有函数式接口，其中一些没有`@FunctionalInterface` 注解，但是只要符合函数式接口的定义就是函数式接口，与是否有\n\n`@FunctionalInterface`注解无关，注解只是在编译时起到强制规范定义的作用。其在 Lambda 表达式中有广泛的应用。\n\n## Lambda 表达式\n\n接下来谈众所周知的 Lambda 表达式。它是推动 Java 8 发布的最重要新特性。是继泛型(`Generics`)和注解(`Annotation`)以来最大的变化。\n\n使用 Lambda 表达式可以使代码变的更加简洁紧凑。让 java 也能支持简单的*函数式编程*。\n\n> Lambda 表达式是一个匿名函数，java 8 允许把函数作为参数传递进方法中。\n\n### 语法格式\n\n```java\n(parameters) -> expression 或\n(parameters) ->{ statements; }\n```\n\n### Lambda 实战\n\n我们用常用的实例来感受 Lambda 带来的便利\n\n#### 替代匿名内部类\n\n过去给方法传动态参数的唯一方法是使用内部类。比如\n\n**1.`Runnable` 接口**\n\n```java\nnew Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println("The runable now is using!");\n            }\n}).start();\n//用lambda\nnew Thread(() -> System.out.println("It\'s a lambda function!")).start();\n```\n\n**2.`Comperator` 接口**\n\n```java\nList<Integer> strings = Arrays.asList(1, 2, 3);\n\nCollections.sort(strings, new Comparator<Integer>() {\n@Override\npublic int compare(Integer o1, Integer o2) {\n    return o1 - o2;}\n});\n\n//Lambda\nCollections.sort(strings, (Integer o1, Integer o2) -> o1 - o2);\n//分解开\nComparator<Integer> comperator = (Integer o1, Integer o2) -> o1 - o2;\nCollections.sort(strings, comperator);\n```\n\n**3.`Listener` 接口**\n\n```java\nJButton button = new JButton();\nbutton.addItemListener(new ItemListener() {\n@Override\npublic void itemStateChanged(ItemEvent e) {\n   e.getItem();\n}\n});\n//lambda\nbutton.addItemListener(e -> e.getItem());\n```\n\n**4.自定义接口**\n\n上面的 3 个例子是我们在开发过程中最常见的，从中也能体会到 Lambda 带来的便捷与清爽。它只保留实际用到的代码，把无用代码全部省略。那它对接口有没有要求呢？我们发现这些匿名内部类只重写了接口的一个方法，当然也只有一个方法须要重写。这就是我们上文提到的**函数式接口**，也就是说只要方法的参数是函数式接口都可以用 Lambda 表达式。\n\n```java\n@FunctionalInterface\npublic interface Comparator<T>{}\n\n@FunctionalInterface\npublic interface Runnable{}\n```\n\n我们自定义一个函数式接口\n\n```java\n@FunctionalInterface\npublic interface LambdaInterface {\n void f();\n}\n//使用\npublic class LambdaClass {\n    public static void forEg() {\n        lambdaInterfaceDemo(()-> System.out.println("自定义函数式接口"));\n    }\n    //函数式接口参数\n    static void lambdaInterfaceDemo(LambdaInterface i){\n        System.out.println(i);\n    }\n}\n```\n\n#### 集合迭代\n\n```java\nvoid lamndaFor() {\n        List<String> strings = Arrays.asList("1", "2", "3");\n        //传统foreach\n        for (String s : strings) {\n            System.out.println(s);\n        }\n        //Lambda foreach\n        strings.forEach((s) -> System.out.println(s));\n        //or\n        strings.forEach(System.out::println);\n \t\t\t\t//map\n        Map<Integer, String> map = new HashMap<>();\n        map.forEach((k,v)->System.out.println(v));\n}\n```\n\n#### 方法的引用\n\nJava 8 允许使用 `::` 关键字来传递方法或者构造函数引用，无论如何，表达式返回的类型必须是 functional-interface。\n\n```java\npublic class LambdaClassSuper {\n    LambdaInterface sf(){\n        return null;\n    }\n}\n\npublic class LambdaClass extends LambdaClassSuper {\n    public static LambdaInterface staticF() {\n        return null;\n    }\n\n    public LambdaInterface f() {\n        return null;\n    }\n\n    void show() {\n        //1.调用静态函数，返回类型必须是functional-interface\n        LambdaInterface t = LambdaClass::staticF;\n\n        //2.实例方法调用\n        LambdaClass lambdaClass = new LambdaClass();\n        LambdaInterface lambdaInterface = lambdaClass::f;\n\n        //3.超类上的方法调用\n        LambdaInterface superf = super::sf;\n\n        //4. 构造方法调用\n        LambdaInterface tt = LambdaClassSuper::new;\n    }\n}\n```\n\n#### 访问变量\n\n```java\nint i = 0;\nCollections.sort(strings, (Integer o1, Integer o2) -> o1 - i);\n//i =3;\n```\n\nlambda 表达式可以引用外边变量，但是该变量默认拥有 final 属性，不能被修改，如果修改，编译时就报错。\n\n## Stream\n\njava 新增了 `java.util.stream` 包，它和之前的流大同小异。之前接触最多的是资源流，比如`java.io.FileInputStream`，通过流把文件从一个地方输入到另一个地方，它只是内容搬运工，对文件内容不做任何*CRUD*。\n\n`Stream`依然不存储数据，不同的是它可以检索(Retrieve)和逻辑处理集合数据、包括筛选、排序、统计、计数等。可以想象成是 Sql 语句。\n\n它的源数据可以是 `Collection`、`Array` 等。由于它的方法参数都是函数式接口类型，所以一般和 Lambda 配合使用。\n\n### 流类型\n\n1. stream 串行流\n2. parallelStream 并行流，可多线程执行\n\n### 常用方法\n\n接下来我们看`java.util.stream.Stream`常用方法\n\n```java\n/**\n* 返回一个串行流\n*/\ndefault Stream<E> stream()\n\n/**\n* 返回一个并行流\n*/\ndefault Stream<E> parallelStream()\n\n/**\n* 返回T的流\n*/\npublic static<T> Stream<T> of(T t)\n\n/**\n* 返回其元素是指定值的顺序流。\n*/\npublic static<T> Stream<T> of(T... values) {\n    return Arrays.stream(values);\n}\n\n\n/**\n* 过滤，返回由与给定predicate匹配的该流的元素组成的流\n*/\nStream<T> filter(Predicate<? super T> predicate);\n\n/**\n* 此流的所有元素是否与提供的predicate匹配。\n*/\nboolean allMatch(Predicate<? super T> predicate)\n\n/**\n* 此流任意元素是否有与提供的predicate匹配。\n*/\nboolean anyMatch(Predicate<? super T> predicate);\n\n/**\n* 返回一个 Stream的构建器。\n*/\npublic static<T> Builder<T> builder();\n\n/**\n* 使用 Collector对此流的元素进行归纳\n*/\n<R, A> R collect(Collector<? super T, A, R> collector);\n\n/**\n * 返回此流中的元素数。\n*/\nlong count();\n\n/**\n* 返回由该流的不同元素（根据 Object.equals(Object) ）组成的流。\n*/\nStream<T> distinct();\n\n/**\n * 遍历\n*/\nvoid forEach(Consumer<? super T> action);\n\n/**\n* 用于获取指定数量的流，截短长度不能超过 maxSize 。\n*/\nStream<T> limit(long maxSize);\n\n/**\n* 用于映射每个元素到对应的结果\n*/\n<R> Stream<R> map(Function<? super T, ? extends R> mapper);\n\n/**\n* 根据提供的 Comparator进行排序。\n*/\nStream<T> sorted(Comparator<? super T> comparator);\n\n/**\n* 在丢弃流的第一个 n元素后，返回由该流的 n元素组成的流。\n*/\nStream<T> skip(long n);\n\n/**\n* 返回一个包含此流的元素的数组。\n*/\nObject[] toArray();\n\n/**\n* 使用提供的 generator函数返回一个包含此流的元素的数组，以分配返回的数组，以及分区执行或调整大小可能需要的任何其他数组。\n*/\n<A> A[] toArray(IntFunction<A[]> generator);\n\n/**\n* 合并流\n*/\npublic static <T> Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b)\n```\n\n### 实战\n\n本文列出 `Stream` 具有代表性的方法之使用，更多的使用方法还是要看 Api。\n\n```java\n@Test\npublic void test() {\n  List<String> strings = Arrays.asList("abc", "def", "gkh", "abc");\n    //返回符合条件的stream\n    Stream<String> stringStream = strings.stream().filter(s -> "abc".equals(s));\n    //计算流符合条件的流的数量\n    long count = stringStream.count();\n\n    //forEach遍历->打印元素\n    strings.stream().forEach(System.out::println);\n\n    //limit 获取到1个元素的stream\n    Stream<String> limit = strings.stream().limit(1);\n    //toArray 比如我们想看这个limitStream里面是什么，比如转换成String[],比如循环\n    String[] array = limit.toArray(String[]::new);\n\n    //map 对每个元素进行操作返回新流\n    Stream<String> map = strings.stream().map(s -> s + "22");\n\n    //sorted 排序并打印\n    strings.stream().sorted().forEach(System.out::println);\n\n    //Collectors collect 把abc放入容器中\n    List<String> collect = strings.stream().filter(string -> "abc".equals(string)).collect(Collectors.toList());\n    //把list转为string，各元素用，号隔开\n    String mergedString = strings.stream().filter(string -> !string.isEmpty()).collect(Collectors.joining(","));\n\n    //对数组的统计，比如用\n    List<Integer> number = Arrays.asList(1, 2, 5, 4);\n\n    IntSummaryStatistics statistics = number.stream().mapToInt((x) -> x).summaryStatistics();\n    System.out.println("列表中最大的数 : "+statistics.getMax());\n    System.out.println("列表中最小的数 : "+statistics.getMin());\n    System.out.println("平均数 : "+statistics.getAverage());\n    System.out.println("所有数之和 : "+statistics.getSum());\n\n    //concat 合并流\n    List<String> strings2 = Arrays.asList("xyz", "jqx");\n    Stream.concat(strings2.stream(),strings.stream()).count();\n\n    //注意 一个Stream只能操作一次，不能断开，否则会报错。\n    Stream stream = strings.stream();\n    //第一次使用\n    stream.limit(2);\n    //第二次使用\n    stream.forEach(System.out::println);\n    //报错 java.lang.IllegalStateException: stream has already been operated upon or closed\n\n    //但是可以这样, 连续使用\n    stream.limit(2).forEach(System.out::println);\n}\n```\n\n### 延迟执行\n\n在执行返回 `Stream` 的方法时，并不立刻执行，而是等返回一个非 `Stream` 的方法后才执行。因为拿到 `Stream` 并不能直接用，而是需要处理成一个常规类型。这里的 `Stream` 可以想象成是二进制流（2 个完全不一样的东东），拿到也看不懂。\n\n我们下面分解一下 `filter` 方法。\n\n```java\n@Test\npublic void laziness(){\n  List<String> strings = Arrays.asList("abc", "def", "gkh", "abc");\n  Stream<Integer> stream = strings.stream().filter(new Predicate() {\n      @Override\n      public boolean test(Object o) {\n        System.out.println("Predicate.test 执行");\n        return true;\n        }\n      });\n\n   System.out.println("count 执行");\n   stream.count();\n}\n/*-------执行结果--------*/\ncount 执行\nPredicate.test 执行\nPredicate.test 执行\nPredicate.test 执行\nPredicate.test 执行\n```\n\n按执行顺序应该是先打印 4 次「`Predicate.test` 执行」，再打印「`count` 执行」。实际结果恰恰相反。说明 filter 中的方法并没有立刻执行，而是等调用`count()`方法后才执行。\n\n上面都是串行 `Stream` 的实例。并行 `parallelStream` 在使用方法上和串行一样。主要区别是 `parallelStream` 可多线程执行，是基于 ForkJoin 框架实现的，有时间大家可以了解一下 `ForkJoin` 框架和 `ForkJoinPool`。这里可以简单的理解它是通过线程池来实现的，这样就会涉及到线程安全，线程消耗等问题。下面我们通过代码来体验一下并行流的多线程执行。\n\n```java\n@Test\npublic void parallelStreamTest(){\n   List<Integer> numbers = Arrays.asList(1, 2, 5, 4);\n   numbers.parallelStream() .forEach(num->System.out.println(Thread.currentThread().getName()+">>"+num));\n}\n//执行结果\nmain>>5\nForkJoinPool.commonPool-worker-2>>4\nForkJoinPool.commonPool-worker-11>>1\nForkJoinPool.commonPool-worker-9>>2\n```\n\n从结果中我们看到，for-each 用到的是多线程。\n\n### 小结\n\n从源码和实例中我们可以总结出一些 stream 的特点\n\n1. 通过简单的链式编程，使得它可以方便地对遍历处理后的数据进行再处理。\n2. 方法参数都是函数式接口类型\n3. 一个 Stream 只能操作一次，操作完就关闭了，继续使用这个 stream 会报错。\n4. Stream 不保存数据，不改变数据源\n\n## Optional\n\n在[阿里巴巴开发手册关于 Optional 的介绍](https://share.weiyun.com/ThuqEbD5)中这样写到：\n\n> 防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：\n>\n> 1） 返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。\n>\n> 反例：public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE。\n>\n> 2） 数据库的查询结果可能为 null。\n>\n> 3） 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。\n>\n> 4） 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。\n>\n> 5） 对于 Session 中获取的数据，建议进行 NPE 检查，避免空指针。\n>\n> 6） 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。\n>\n> 正例：使用 JDK8 的 Optional 类来防止 NPE 问题。\n\n他建议使用 `Optional` 解决 NPE（`java.lang.NullPointerException`）问题，它就是为 NPE 而生的，其中可以包含空值或非空值。下面我们通过源码逐步揭开 `Optional` 的红盖头。\n\n假设有一个 `Zoo` 类，里面有个属性 `Dog`，需求要获取 `Dog` 的 `age`。\n\n```java\nclass Zoo {\n   private Dog dog;\n}\n\nclass Dog {\n   private int age;\n}\n```\n\n传统解决 NPE 的办法如下：\n\n```java\nZoo zoo = getZoo();\nif(zoo != null){\n   Dog dog = zoo.getDog();\n   if(dog != null){\n      int age = dog.getAge();\n      System.out.println(age);\n   }\n}\n```\n\n层层判断对象非空，有人说这种方式很丑陋不优雅，我并不这么认为。反而觉得很整洁，易读，易懂。你们觉得呢？\n\n`Optional` 是这样的实现的：\n\n```java\nOptional.ofNullable(zoo).map(o -> o.getDog()).map(d -> d.getAge()).ifPresent(age ->\n    System.out.println(age)\n);\n```\n\n是不是简洁了很多呢？\n\n### 如何创建一个 Optional\n\n上例中`Optional.ofNullable`是其中一种创建 Optional 的方式。我们先看一下它的含义和其他创建 Optional 的源码方法。\n\n```java\n/**\n* Common instance for {@code empty()}. 全局EMPTY对象\n*/\nprivate static final Optional<?> EMPTY = new Optional<>();\n\n/**\n* Optional维护的值\n*/\nprivate final T value;\n\n/**\n* 如果value是null就返回EMPTY，否则就返回of(T)\n*/\npublic static <T> Optional<T> ofNullable(T value) {\n   return value == null ? empty() : of(value);\n}\n/**\n* 返回 EMPTY 对象\n*/\npublic static<T> Optional<T> empty() {\n   Optional<T> t = (Optional<T>) EMPTY;\n   return t;\n}\n/**\n* 返回Optional对象\n*/\npublic static <T> Optional<T> of(T value) {\n    return new Optional<>(value);\n}\n/**\n* 私有构造方法，给value赋值\n*/\nprivate Optional(T value) {\n  this.value = Objects.requireNonNull(value);\n}\n/**\n* 所以如果of(T value) 的value是null，会抛出NullPointerException异常，这样貌似就没处理NPE问题\n*/\npublic static <T> T requireNonNull(T obj) {\n  if (obj == null)\n         throw new NullPointerException();\n  return obj;\n}\n```\n\n`ofNullable` 方法和`of`方法唯一区别就是当 value 为 null 时，`ofNullable` 返回的是`EMPTY`，of 会抛出 `NullPointerException` 异常。如果需要把 `NullPointerException` 暴漏出来就用 `of`，否则就用 `ofNullable`。\n\n### `map()`相关方法。\n\n```java\n/**\n* 如果value为null，返回EMPTY，否则返回Optional封装的参数值\n*/\npublic<U> Optional<U> map(Function<? super T, ? extends U> mapper) {\n        Objects.requireNonNull(mapper);\n        if (!isPresent())\n            return empty();\n        else {\n            return Optional.ofNullable(mapper.apply(value));\n        }\n}\n/**\n* 如果value为null，返回EMPTY，否则返回Optional封装的参数值，如果参数值返回null会抛 NullPointerException\n*/\npublic<U> Optional<U> flatMap(Function<? super T, Optional<U>> mapper) {\n        Objects.requireNonNull(mapper);\n        if (!isPresent())\n            return empty();\n        else {\n            return Objects.requireNonNull(mapper.apply(value));\n        }\n}\n```\n\n**`map()` 和 `flatMap()` 有什么区别的？**\n\n**1.参数不一样，`map` 的参数上面看到过，`flatMap` 的参数是这样**\n\n```java\nclass ZooFlat {\n        private DogFlat dog = new DogFlat();\n\n        public DogFlat getDog() {\n            return dog;\n        }\n    }\n\nclass DogFlat {\n        private int age = 1;\n        public Optional<Integer> getAge() {\n            return Optional.ofNullable(age);\n        }\n}\n\nZooFlat zooFlat = new ZooFlat();\nOptional.ofNullable(zooFlat).map(o -> o.getDog()).flatMap(d -> d.getAge()).ifPresent(age ->\n    System.out.println(age)\n);\n```\n\n**2.`flatMap()` 参数返回值如果是 null 会抛 `NullPointerException`，而 `map()` 返回`EMPTY`。**\n\n### 判断 value 是否为 null\n\n```java\n/**\n* value是否为null\n*/\npublic boolean isPresent() {\n    return value != null;\n}\n/**\n* 如果value不为null执行consumer.accept\n*/\npublic void ifPresent(Consumer<? super T> consumer) {\n   if (value != null)\n    consumer.accept(value);\n}\n```\n\n### 获取 value\n\n```java\n/**\n* Return the value if present, otherwise invoke {@code other} and return\n* the result of that invocation.\n* 如果value != null 返回value，否则返回other的执行结果\n*/\npublic T orElseGet(Supplier<? extends T> other) {\n    return value != null ? value : other.get();\n}\n\n/**\n* 如果value != null 返回value，否则返回T\n*/\npublic T orElse(T other) {\n    return value != null ? value : other;\n}\n\n/**\n* 如果value != null 返回value，否则抛出参数返回的异常\n*/\npublic <X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X {\n        if (value != null) {\n            return value;\n        } else {\n            throw exceptionSupplier.get();\n        }\n}\n/**\n* value为null抛出NoSuchElementException，不为空返回value。\n*/\npublic T get() {\n  if (value == null) {\n      throw new NoSuchElementException("No value present");\n  }\n  return value;\n}\n```\n\n### 过滤值\n\n```java\n/**\n* 1. 如果是empty返回empty\n* 2. predicate.test(value)==true 返回this，否则返回empty\n*/\npublic Optional<T> filter(Predicate<? super T> predicate) {\n        Objects.requireNonNull(predicate);\n        if (!isPresent())\n            return this;\n        else\n            return predicate.test(value) ? this : empty();\n}\n```\n\n### 小结\n\n看完 `Optional` 源码，`Optional` 的方法真的非常简单，值得注意的是如果坚决不想看见 `NPE`，就不要用 `of() `、 `get()` 、`flatMap(..)`。最后再综合用一下 `Optional` 的高频方法。\n\n```java\nOptional.ofNullable(zoo).map(o -> o.getDog()).map(d -> d.getAge()).filter(v->v==1).orElse(3);\n```\n\n## Date-Time API\n\n这是对`java.util.Date`强有力的补充，解决了 Date 类的大部分痛点：\n\n1. 非线程安全\n2. 时区处理麻烦\n3. 各种格式化、和时间计算繁琐\n4. 设计有缺陷，Date 类同时包含日期和时间；还有一个 java.sql.Date，容易混淆。\n\n我们从常用的时间实例来对比 java.util.Date 和新 Date 有什么区别。用`java.util.Date`的代码该改改了。\n\n### java.time 主要类\n\n`java.util.Date` 既包含日期又包含时间，而  `java.time` 把它们进行了分离\n\n```java\nLocalDateTime.class //日期+时间 format: yyyy-MM-ddTHH:mm:ss.SSS\nLocalDate.class //日期 format: yyyy-MM-dd\nLocalTime.class //时间 format: HH:mm:ss\n```\n\n### 格式化\n\n**Java 8 之前:**\n\n```java\npublic void oldFormat(){\n\t\tDate now = new Date();\n    //format yyyy-MM-dd HH:mm:ss\n    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");\n    String date  = sdf.format(now);\n    System.out.println(String.format("date format : %s", date));\n\n    //format HH:mm:ss\n    SimpleDateFormat sdft = new SimpleDateFormat("HH:mm:ss");\n    String time = sdft.format(now);\n    System.out.println(String.format("time format : %s", time));\n\n    //format yyyy-MM-dd HH:mm:ss\n    SimpleDateFormat sdfdt = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");\n    String datetime = sdfdt.format(now);\n    System.out.println(String.format("dateTime format : %s", datetime));\n}\n```\n\n**Java 8 之后:**\n\n```java\npublic void newFormat(){\n    //format yyyy-MM-dd\n    LocalDate date = LocalDate.now();\n    System.out.println(String.format("date format : %s", date));\n\n    //format HH:mm:ss\n    LocalTime time = LocalTime.now().withNano(0);\n    System.out.println(String.format("time format : %s", time));\n\n    //format yyyy-MM-dd HH:mm:ss\n    LocalDateTime dateTime = LocalDateTime.now();\n    DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");\n    String dateTimeStr = dateTime.format(dateTimeFormatter);\n    System.out.println(String.format("dateTime format : %s", dateTimeStr));\n}\n```\n\n### 字符串转日期格式\n\n**Java 8 之前:**\n\n```java\n//已弃用\nDate date = new Date("2021-01-26");\n//替换为\nSimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");\nDate date1 = sdf.parse("2021-01-26");\n```\n\n**Java 8 之后:**\n\n```java\nLocalDate date = LocalDate.of(2021, 1, 26);\nLocalDate.parse("2021-01-26");\n\nLocalDateTime dateTime = LocalDateTime.of(2021, 1, 26, 12, 12, 22);\nLocalDateTime.parse("2021-01-26 12:12:22");\n\nLocalTime time = LocalTime.of(12, 12, 22);\nLocalTime.parse("12:12:22");\n```\n\n**Java 8 之前** 转换都需要借助 `SimpleDateFormat` 类，而**Java 8 之后**只需要 `LocalDate`、`LocalTime`、`LocalDateTime`的  `of` 或 `parse` 方法。\n\n### 日期计算\n\n下面仅以**一周后日期**为例，其他单位（年、月、日、1/2 日、时等等）大同小异。另外，这些单位都在 _java.time.temporal.ChronoUnit_ 枚举中定义。\n\n**Java 8 之前:**\n\n```java\npublic void afterDay(){\n     //一周后的日期\n     SimpleDateFormat formatDate = new SimpleDateFormat("yyyy-MM-dd");\n     Calendar ca = Calendar.getInstance();\n     ca.add(Calendar.DATE, 7);\n     Date d = ca.getTime();\n     String after = formatDate.format(d);\n     System.out.println("一周后日期：" + after);\n\n   //算两个日期间隔多少天，计算间隔多少年，多少月方法类似\n     String dates1 = "2021-12-23";\n   String dates2 = "2021-02-26";\n     SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");\n     Date date1 = format.parse(dates1);\n     Date date2 = format.parse(dates2);\n     int day = (int) ((date1.getTime() - date2.getTime()) / (1000 * 3600 * 24));\n     System.out.println(dates2 + "和" + dates2 + "相差" + day + "天");\n     //结果：2021-12-23和2021-12-23相差300天\n}\n```\n\n**Java 8 之后:**\n\n```java\npublic void pushWeek(){\n     //一周后的日期\n     LocalDate localDate = LocalDate.now();\n     //方法1\n     LocalDate after = localDate.plus(1, ChronoUnit.WEEKS);\n     //方法2\n     LocalDate after2 = localDate.plusWeeks(1);\n     System.out.println("一周后日期：" + after);\n\n     //算两个日期间隔多少天，计算间隔多少年，多少月\n     LocalDate date1 = LocalDate.parse("2021-02-26");\n     LocalDate date2 = LocalDate.parse("2021-12-23");\n     Period period = Period.between(date1, date2);\n     System.out.println("date1 到 date2 相隔："\n                + period.getYears() + "年"\n                + period.getMonths() + "月"\n                + period.getDays() + "天");\n\t\t //打印结果是 “date1 到 date2 相隔：0年9月27天”\n     //这里period.getDays()得到的天是抛去年月以外的天数，并不是总天数\n     //如果要获取纯粹的总天数应该用下面的方法\n     long day = date2.toEpochDay() - date1.toEpochDay();\n     System.out.println(date2 + "和" + date2 + "相差" + day + "天");\n     //打印结果：2021-12-23和2021-12-23相差300天\n}\n```\n\n### 获取指定日期\n\n除了日期计算繁琐，获取特定一个日期也很麻烦，比如获取本月最后一天，第一天。\n\n**Java 8 之前:**\n\n```java\npublic void getDay() {\n\n        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");\n        //获取当前月第一天：\n        Calendar c = Calendar.getInstance();\n        c.set(Calendar.DAY_OF_MONTH, 1);\n        String first = format.format(c.getTime());\n        System.out.println("first day:" + first);\n\n        //获取当前月最后一天\n        Calendar ca = Calendar.getInstance();\n        ca.set(Calendar.DAY_OF_MONTH, ca.getActualMaximum(Calendar.DAY_OF_MONTH));\n        String last = format.format(ca.getTime());\n        System.out.println("last day:" + last);\n\n        //当年最后一天\n        Calendar currCal = Calendar.getInstance();\n        Calendar calendar = Calendar.getInstance();\n        calendar.clear();\n        calendar.set(Calendar.YEAR, currCal.get(Calendar.YEAR));\n        calendar.roll(Calendar.DAY_OF_YEAR, -1);\n        Date time = calendar.getTime();\n        System.out.println("last day:" + format.format(time));\n}\n```\n\n**Java 8 之后:**\n\n```java\npublic void getDayNew() {\n    LocalDate today = LocalDate.now();\n    //获取当前月第一天：\n    LocalDate firstDayOfThisMonth = today.with(TemporalAdjusters.firstDayOfMonth());\n    // 取本月最后一天\n    LocalDate lastDayOfThisMonth = today.with(TemporalAdjusters.lastDayOfMonth());\n    //取下一天：\n    LocalDate nextDay = lastDayOfThisMonth.plusDays(1);\n    //当年最后一天\n    LocalDate lastday = today.with(TemporalAdjusters.lastDayOfYear());\n    //2021年最后一个周日，如果用Calendar是不得烦死。\n    LocalDate lastMondayOf2021 = LocalDate.parse("2021-12-31").with(TemporalAdjusters.lastInMonth(DayOfWeek.SUNDAY));\n}\n```\n\n`java.time.temporal.TemporalAdjusters` 里面还有很多便捷的算法，这里就不带大家看 Api 了，都很简单，看了秒懂。\n\n### JDBC 和 java8\n\n现在 jdbc 时间类型和 java8 时间类型对应关系是\n\n1. `Date` ---\x3e `LocalDate`\n2. `Time` ---\x3e `LocalTime`\n3. `Timestamp` ---\x3e `LocalDateTime`\n\n而之前统统对应 `Date`，也只有 `Date`。\n\n### 时区\n\n> 时区：正式的时区划分为每隔经度 15° 划分一个时区，全球共 24 个时区，每个时区相差 1 小时。但为了行政上的方便，常将 1 个国家或 1 个省份划在一起，比如我国幅员宽广，大概横跨 5 个时区，实际上只用东八时区的标准时即北京时间为准。\n\n`java.util.Date` 对象实质上存的是 1970 年 1 月 1 日 0 点（ GMT）至 Date 对象所表示时刻所经过的毫秒数。也就是说不管在哪个时区 new Date，它记录的毫秒数都一样，和时区无关。但在使用上应该把它转换成当地时间，这就涉及到了时间的国际化。`java.util.Date` 本身并不支持国际化，需要借助 `TimeZone`。\n\n```java\n//北京时间：Wed Jan 27 14:05:29 CST 2021\nDate date = new Date();\n\nSimpleDateFormat bjSdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");\n//北京时区\nbjSdf.setTimeZone(TimeZone.getTimeZone("Asia/Shanghai"));\nSystem.out.println("毫秒数:" + date.getTime() + ", 北京时间:" + bjSdf.format(date));\n\n//东京时区\nSimpleDateFormat tokyoSdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");\ntokyoSdf.setTimeZone(TimeZone.getTimeZone("Asia/Tokyo"));  // 设置东京时区\nSystem.out.println("毫秒数:" + date.getTime() + ", 东京时间:" + tokyoSdf.format(date));\n\n//如果直接print会自动转成当前时区的时间\nSystem.out.println(date);\n//Wed Jan 27 14:05:29 CST 2021\n```\n\n在新特性中引入了  `java.time.ZonedDateTime ` 来表示带时区的时间。它可以看成是 `LocalDateTime + ZoneId`。\n\n```java\n//当前时区时间\nZonedDateTime zonedDateTime = ZonedDateTime.now();\nSystem.out.println("当前时区时间: " + zonedDateTime);\n\n//东京时间\nZoneId zoneId = ZoneId.of(ZoneId.SHORT_IDS.get("JST"));\nZonedDateTime tokyoTime = zonedDateTime.withZoneSameInstant(zoneId);\nSystem.out.println("东京时间: " + tokyoTime);\n\n// ZonedDateTime 转 LocalDateTime\nLocalDateTime localDateTime = tokyoTime.toLocalDateTime();\nSystem.out.println("东京时间转当地时间: " + localDateTime);\n\n//LocalDateTime 转 ZonedDateTime\nZonedDateTime localZoned = localDateTime.atZone(ZoneId.systemDefault());\nSystem.out.println("本地时区时间: " + localZoned);\n\n//打印结果\n当前时区时间: 2021-01-27T14:43:58.735+08:00[Asia/Shanghai]\n东京时间: 2021-01-27T15:43:58.735+09:00[Asia/Tokyo]\n东京时间转当地时间: 2021-01-27T15:43:58.735\n当地时区时间: 2021-01-27T15:53:35.618+08:00[Asia/Shanghai]\n```\n\n### 小结\n\n通过上面比较新老 `Date` 的不同，当然只列出部分功能上的区别，更多功能还得自己去挖掘。总之 date-time-api 给日期操作带来了福利。在日常工作中遇到 date 类型的操作，第一考虑的是 date-time-api，实在解决不了再考虑老的 Date。\n\n## 总结\n\n我们梳理总结的 java 8 新特性有\n\n- Interface & functional Interface\n- Lambda\n- Stream\n- Optional\n- Date time-api\n\n这些都是开发当中比较常用的特性。梳理下来发现它们真香，而我却没有更早的应用。总觉得学习 java 8 新特性比较麻烦，一直使用老的实现方式。其实这些新特性几天就可以掌握，一但掌握，效率会有很大的提高。其实我们涨工资也是涨的学习的钱，不学习终究会被淘汰，35 岁危机会提前来临。\n'},b5bb:function(n,e,t){"use strict";t.r(e),e["default"]='## 1.接口\n\n### 1.1黑马信息管理系统集合改进 (应用)\n\n+ 使用数组容器的弊端\n\n  1. 容器长度是固定的，不能根据添加功能自动增长\n  2. 没有提供用于赠删改查的方法\n\n+ 优化步骤\n\n  1. 创建新的StudentDao类，OtherStudentDao\n\n  2. 创建ArrayList集合容器对象\n\n  3. OtherStudentDao中的方法声明，需要跟StudentDao保持一致\n\n     注意：如果不一致，StudentService中的代码就需要进行修改\n\n  4. 完善方法（添加、删除、修改、查看）\n\n  5. 替换StudentService中的Dao对象\n\n+ 代码实现\n\n  OtherStudentDao类\n\n  ```java\n  public class OtherStudentDao {\n      // 集合容器\n      private static ArrayList<Student> stus = new ArrayList<>();\n\n      static {\n          Student stu1 = new Student("heima001","张三","23","1999-11-11");\n          Student stu2 = new Student("heima002","李四","24","2000-11-11");\n\n          stus.add(stu1);\n          stus.add(stu2);\n      }\n\n      // 添加学生方法\n      public boolean addStudent(Student stu) {\n         stus.add(stu);\n         return true;\n      }\n\n      // 查看学生方法\n      public Student[] findAllStudent() {\n\n          Student[] students = new Student[stus.size()];\n\n          for (int i = 0; i < students.length; i++) {\n              students[i] = stus.get(i);\n          }\n\n          return students;\n      }\n\n      public void deleteStudentById(String delId) {\n          // 1. 查找id在容器中所在的索引位置\n          int index = getIndex(delId);\n          stus.remove(index);\n      }\n\n      public int getIndex(String id){\n          int index = -1;\n          for (int i = 0; i < stus.size(); i++) {\n              Student stu = stus.get(i);\n              if(stu != null && stu.getId().equals(id)){\n                  index = i;\n                  break;\n              }\n          }\n          return index;\n      }\n\n      public void updateStudent(String updateId, Student newStu) {\n          // 1. 查找updateId, 在容器中的索引位置\n          int index = getIndex(updateId);\n          stus.set(index, newStu);\n      }\n  }\n  ```\n\n  StudentService类\n\n  ```java\n  public class StudentService {\n      // 创建StudentDao (库管)\n       private OtherStudentDao studentDao = new OtherStudentDao();\n    \t// 其他方法没有变化,此处省略...\n  }    \n  ```\n\n### 1.2黑马信息管理系统抽取Dao (应用)\n\n+ 优化步骤\n\n  1. 将方法向上抽取，抽取出一个父类 （ BaseStudentDao ）\n  2. 方法的功能实现在父类中无法给出具体明确，定义为抽象方法\n  3. 让两个类分别继承 BaseStudentDao ，重写内部抽象方法\n\n+ 代码实现\n\n  BaseStudentDao类\n\n  ```java\n  public abstract class BaseStudentDao {\n      // 添加学生方法\n      public abstract boolean addStudent(Student stu);\n      // 查看学生方法\n      public abstract Student[] findAllStudent();\n      // 删除学生方法\n      public abstract void deleteStudentById(String delId);\n      // 根据id找索引方法\n      public abstract int getIndex(String id);\n      // 修改学生方法\n      public abstract void updateStudent(String updateId, Student newStu);\n  }\n  ```\n\n  StudentDao类\n\n  ```java\n  public class StudentDao extends BaseStudentDao {\n    // 其他内容不变,此处省略\n  }\n  ```\n\n  OtherStudentDao类\n\n  ```java\n  public class OtherStudentDao extends BaseStudentDao {\n    // 其他内容不变,此处省略\n  }\n  ```\n\n### 1.3接口的概述（理解）\n\n+ 接口就是一种公共的规范标准，只要符合规范标准，大家都可以通用。\n+ Java中接口存在的两个意义\n  1. 用来定义规范\n  2. 用来做功能的拓展\n\n### 1.4接口的特点（记忆）\n\n- 接口用关键字interface修饰\n\n  ```java\n  public interface 接口名 {} \n  ```\n\n- 类实现接口用implements表示\n\n  ```java\n  public class 类名 implements 接口名 {}\n  ```\n\n- 接口不能实例化\n\n  ​\t我们可以创建接口的实现类对象使用\n\n- 接口的子类\n\n  ​\t要么重写接口中的所有抽象方法\n\n  ​\t要么子类也是抽象类\n\n### 1.5接口的成员特点（记忆）\n\n- 成员特点\n\n  - 成员变量\n\n    ​\t 只能是常量\n    ​\t 默认修饰符：public static final\n\n  - 构造方法\n\n    ​\t没有，因为接口主要是扩展功能的，而没有具体存在\n\n  - 成员方法\n\n    ​\t只能是抽象方法\n\n    ​\t默认修饰符：public abstract\n\n    ​\t关于接口中的方法，JDK8和JDK9中有一些新特性，后面再讲解\n\n- 代码演示\n\n  - 接口\n\n  ```java\n  public interface Inter {\n      public static final int NUM = 10;\n\n      public abstract void show();\n  }\n  ```\n\n  - 实现类\n\n  ```java\n  class InterImpl implements Inter{\n\n      public void method(){\n          // NUM = 20;\n          System.out.println(NUM);\n      }\n\n      public void show(){\n\n      }\n  }\n  ```\n\n  - 测试类\n\n  ```java\n  public class TestInterface {\n      /*\n          成员变量: 只能是常量 系统会默认加入三个关键字\n                      public static final\n          构造方法: 没有\n          成员方法: 只能是抽象方法, 系统会默认加入两个关键字\n                      public abstract\n       */\n      public static void main(String[] args) {\n          System.out.println(Inter.NUM);\n      }\n    \n  }\n  ```\n\n### 1.6类和接口的关系（记忆）\n\n- 类与类的关系\n\n  ​\t继承关系，只能单继承，但是可以多层继承\n\n- 类与接口的关系\n\n  ​\t实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口\n\n- 接口与接口的关系\n\n  ​\t继承关系，可以单继承，也可以多继承\n\n### 1.7黑马信息管理系统使用接口改进 (应用)\n\n+ 实现步骤\n\n  1. 将 BaseStudentDao 改进为一个接口\n  2. 让 StudentDao 和 OtherStudentDao 去实现这个接口\n\n+ 代码实现\n\n  BaseStudentDao接口\n\n  ```java\n  public interface BaseStudentDao {\n      // 添加学生方法\n      public abstract boolean addStudent(Student stu);\n      // 查看学生方法\n      public abstract Student[] findAllStudent();\n      // 删除学生方法\n      public abstract void deleteStudentById(String delId);\n      // 根据id找索引方法\n      public abstract int getIndex(String id);\n      // 修改学生方法\n      public abstract void updateStudent(String updateId, Student newStu);\n  }\n  ```\n\n  StudentDao类\n\n  ```java\n  public class StudentDao implements BaseStudentDao {\n    // 其他内容不变,此处省略\n  }\n  ```\n\n  OtherStudentDao类\n\n  ```java\n  public class OtherStudentDao implements BaseStudentDao {\n    // 其他内容不变,此处省略\n  }\n  ```\n\n### 1.8黑马信息管理系统解耦合改进 (应用) \n\n+ 实现步骤\n\n  1. 创建factory包，创建 StudentDaoFactory（工厂类）\n  2. 提供 static 修改的 getStudentDao 方法，该方法用于创建StudentDao对象并返回\n\n+ 代码实现\n\n  StudentDaoFactory类\n\n  ```java\n  public class StudentDaoFactory {\n      public static OtherStudentDao getStudentDao(){\n          return new OtherStudentDao();\n      }\n  }\n  ```\n\n  StudentService类\n\n  ```java\n  public class StudentService {\n      // 创建StudentDao (库管)\n      // private OtherStudentDao studentDao = new OtherStudentDao();\n\n      // 通过学生库管工厂类, 获取库管对象\n      private OtherStudentDao studentDao = StudentDaoFactory.getStudentDao();\n  }  \n  ```\n\n## 2.接口组成更新\n\n### 2.1接口组成更新概述【理解】\n\n- 常量\n\n  public static final\n\n- 抽象方法\n\n  public abstract\n\n- 默认方法(Java 8)\n\n- 静态方法(Java 8)\n\n- 私有方法(Java 9)\n\n### 2.2接口中默认方法【应用】\n\n- 格式\n\n  public default 返回值类型 方法名(参数列表) {   }\n\n- 作用\n\n  解决接口升级的问题\n\n- 范例\n\n  ```java\n  public default void show3() { \n  }\n  ```\n\n- 注意事项\n\n  - 默认方法不是抽象方法，所以不强制被重写。但是可以被重写，重写的时候去掉default关键字\n  - public可以省略，default不能省略\n  - 如果实现了多个接口，多个接口中存在相同的方法声明，子类就必须对该方法进行重写\n\n### 2.3接口中静态方法【应用】\n\n- 格式\n\n  public static 返回值类型 方法名(参数列表) {   }\n\n- 范例\n\n  ```java\n  public static void show() {\n  }\n  ```\n\n- 注意事项\n\n  - 静态方法只能通过接口名调用，不能通过实现类名或者对象名调用\n  - public可以省略，static不能省略\n\n### 2.4接口中私有方法【应用】\n\n- 私有方法产生原因\n\n  Java 9中新增了带方法体的私有方法，这其实在Java 8中就埋下了伏笔：Java 8允许在接口中定义带方法体的默认方法和静态方法。这样可能就会引发一个问题：当两个默认方法或者静态方法中包含一段相同的代码实现时，程序必然考虑将这段实现代码抽取成一个共性方法，而这个共性方法是不需要让别人使用的，因此用私有给隐藏起来，这就是Java 9增加私有方法的必然性\n\n- 定义格式\n\n  - 格式1\n\n    private 返回值类型 方法名(参数列表) {   }\n\n  - 范例1\n\n    ```java\n    private void show() {  \n    }\n    ```\n\n  - 格式2\n\n    private static 返回值类型 方法名(参数列表) {   }\n\n  - 范例2\n\n    ```java\n    private static void method() {  \n    }\n    ```\n\n- 注意事项\n\n  - 默认方法可以调用私有的静态方法和非静态方法\n  - 静态方法只能调用私有的静态方法\n\n## 3.多态 \n\n### 3.1多态的概述（记忆）\n\n- 什么是多态\n\n  ​\t同一个对象，在不同时刻表现出来的不同形态\n\n- 多态的前提\n\n  - 要有继承或实现关系\n  - 要有方法的重写\n  - 要有父类引用指向子类对象\n\n- 代码演示\n\n  ```java\n  class Animal {\n      public void eat(){\n          System.out.println("动物吃饭");\n      }\n  }\n\n  class Cat extends Animal {\n      @Override\n      public void eat() {\n          System.out.println("猫吃鱼");\n      }\n  }\n\n  public class Test1Polymorphic {\n      /*\n          多态的前提:\n\n              1. 要有(继承 \\ 实现)关系\n              2. 要有方法重写\n              3. 要有父类引用, 指向子类对象\n       */\n      public static void main(String[] args) {\n          // 当前事物, 是一只猫\n          Cat c = new Cat();\n          // 当前事物, 是一只动物\n          Animal a = new Cat();\n          a.eat();\n\n      }\n  }\n  ```\n\n### 3.2多态中的成员访问特点（记忆）\n\n- 成员访问特点\n\n  - 成员变量\n\n    ​\t编译看父类，运行看父类\n\n  - 成员方法\n\n    ​\t编译看父类，运行看子类\n\n- 代码演示\n\n  ```java\n  class Fu {\n      int num = 10;\n\n      public void method(){\n          System.out.println("Fu.. method");\n      }\n  }\n\n  class Zi extends Fu {\n      int num = 20;\n\n      public void method(){\n          System.out.println("Zi.. method");\n      }\n  }\n\n  public class Test2Polymorpic {\n      /*\n           多态的成员访问特点:\n\n                  成员变量: 编译看左边 (父类), 运行看左边 (父类)\n\n                  成员方法: 编译看左边 (父类), 运行看右边 (子类)\n       */\n      public static void main(String[] args) {\n          Fu f = new Zi();\n          System.out.println(f.num);\n          f.method();\n      }\n  }\n  ```\n\n### 3.3多态的好处和弊端（记忆）\n\n- 好处\n\n  ​\t提高程序的扩展性。定义方法时候，使用父类型作为参数，在使用的时候，使用具体的子类型参与操作\n\n- 弊端\n\n  ​\t不能使用子类的特有成员\n\n### 3.4多态中的转型（应用）\n\n- 向上转型\n\n  ​\t父类引用指向子类对象就是向上转型\n\n- 向下转型\n\n  ​\t格式：子类型 对象名 = (子类型)父类引用;\n\n- 代码演示\n\n  ```java\n  class Fu {\n      public void show(){\n          System.out.println("Fu..show...");\n      }\n  }\n\n  class Zi extends Fu {\n      @Override\n      public void show() {\n          System.out.println("Zi..show...");\n      }\n\n      public void method(){\n          System.out.println("我是子类特有的方法, method");\n      }\n  }\n\n  public class Test3Polymorpic {\n      public static void main(String[] args) {\n          // 1. 向上转型 : 父类引用指向子类对象\n          Fu f = new Zi();\n          f.show();\n          // 多态的弊端: 不能调用子类特有的成员\n          // f.method();\n\n          // A: 直接创建子类对象\n          // B: 向下转型\n\n          // 2. 向下转型 : 从父类类型, 转换回子类类型\n          Zi z = (Zi) f;\n          z.method();\n      }\n  }\n  ```\n\n### 3.5多态中转型存在的风险和解决方案 (应用) \n\n+ 风险\n\n  如果被转的引用类型变量,对应的实际类型和目标类型不是同一种类型,那么在转换的时候就会出现ClassCastException \n\n+ 解决方案\n\n  + 关键字\n\n    instanceof\n\n  + 使用格式\n\n    变量名 instanceof 类型\n\n    通俗的理解：判断关键字左边的变量，是否是右边的类型，返回boolean类型结果\n\n+ 代码演示\n\n  ```java\n  abstract class Animal {\n      public abstract void eat();\n  }\n\n  class Dog extends Animal {\n      public void eat() {\n          System.out.println("狗吃肉");\n      }\n\n      public void watchHome(){\n          System.out.println("看家");\n      }\n  }\n\n  class Cat extends Animal {\n      public void eat() {\n          System.out.println("猫吃鱼");\n      }\n  }\n\n  public class Test4Polymorpic {\n      public static void main(String[] args) {\n          useAnimal(new Dog());\n          useAnimal(new Cat());\n      }\n\n      public static void useAnimal(Animal a){  // Animal a = new Dog();\n                                               // Animal a = new Cat();\n          a.eat();\n          //a.watchHome();\n\n  //        Dog dog = (Dog) a;\n  //        dog.watchHome();  // ClassCastException  类型转换异常\n        \n          // 判断a变量记录的类型, 是否是Dog\n          if(a instanceof Dog){\n              Dog dog = (Dog) a;\n              dog.watchHome();\n          }\n      }\n\n  }\n  ```\n\n### 3.6黑马信息管理系统多态改进 (应用) \n\n+ 实现步骤\n\n  1. StudentDaoFactory类中方法的返回值定义成父类类型BaseStudentDao\n  2. StudentService中接收方法返回值的类型定义成父类类型BaseStudentDao\n\n+ 代码实现\n\n  StudentDaoFactory类\n\n  ```java\n  public class StudentDaoFactory {\n      public static BaseStudentDao getStudentDao(){\n          return new OtherStudentDao();\n      }\n  }\n  ```\n\n  StudentService类\n\n  ```java\n  public class StudentService {\n      // 创建StudentDao (库管)\n      // private OtherStudentDao studentDao = new OtherStudentDao();\n\n      // 通过学生库管工厂类, 获取库管对象\n      private BaseStudentDao studentDao = StudentDaoFactory.getStudentDao();\n  }  \n  ```\n\n## 4.内部类 \n\n### 4.1 内部类的基本使用（理解）\n\n- 内部类概念\n\n  - 在一个类中定义一个类。举例：在一个类A的内部定义一个类B，类B就被称为内部类\n\n- 内部类定义格式\n\n  - 格式&举例：\n\n    ```java\n    /*\n    \t格式：\n        class 外部类名{\n        \t修饰符 class 内部类名{\n        \t\n        \t}\n        }\n    */\n\n    class Outer {\n        public class Inner {\n            \n        }\n    }\n    ```\n\n- 内部类的访问特点 \n\n  - 内部类可以直接访问外部类的成员，包括私有\n  - 外部类要访问内部类的成员，必须创建对象\n\n- 示例代码：\n\n  ```java\n  /*\n      内部类访问特点：\n          内部类可以直接访问外部类的成员，包括私有\n          外部类要访问内部类的成员，必须创建对象\n   */\n  public class Outer {\n      private int num = 10;\n      public class Inner {\n          public void show() {\n              System.out.println(num);\n          }\n      }\n      public void method() {\n          Inner i = new Inner();\n          i.show();\n      }\n  }\n  ```\n\n### 2.2 成员内部类（理解）\n\n- 成员内部类的定义位置\n\n  - 在类中方法，跟成员变量是一个位置\n\n- 外界创建成员内部类格式\n\n  - 格式：外部类名.内部类名 对象名 = 外部类对象.内部类对象;\n  - 举例：Outer.Inner oi = new Outer().new Inner();\n\n- 私有成员内部类\n\n  - 将一个类，设计为内部类的目的，大多数都是不想让外界去访问，所以内部类的定义应该私有化，私有化之后，再提供一个可以让外界调用的方法，方法内部创建内部类对象并调用。\n\n  - 示例代码：\n\n    ```java\n    class Outer {\n        private int num = 10;\n        private class Inner {\n            public void show() {\n                System.out.println(num);\n            }\n        }\n        public void method() {\n            Inner i = new Inner();\n            i.show();\n        }\n    }\n    public class InnerDemo {\n        public static void main(String[] args) {\n    \t\t//Outer.Inner oi = new Outer().new Inner();\n    \t\t//oi.show();\n            Outer o = new Outer();\n            o.method();\n        }\n    }\n    ```\n\n- 静态成员内部类\n\n  + 静态成员内部类访问格式：外部类名.内部类名 对象名 = new 外部类名.内部类名();\n\n  + 静态成员内部类中的静态方法：外部类名.内部类名.方法名();\n\n  + 示例代码\n\n    ```java\n    class Outer {\n        static class Inner {\n            public void show(){\n                System.out.println("inner..show");\n            }\n\n            public static void method(){\n                System.out.println("inner..method");\n            }\n        }\n    }\n\n    public class Test3Innerclass {\n        /*\n            静态成员内部类演示\n         */\n        public static void main(String[] args) {\n            // 外部类名.内部类名 对象名 = new 外部类名.内部类名();\n            Outer.Inner oi = new Outer.Inner();\n            oi.show();\n\n            Outer.Inner.method();\n        }\n    }\n    ```\n\n### 2.3 局部内部类（理解）\n\n- 局部内部类定义位置\n\n  - 局部内部类是在方法中定义的类\n\n- 局部内部类方式方式\n\n  - 局部内部类，外界是无法直接使用，需要在方法内部创建对象并使用\n  - 该类可以直接访问外部类的成员，也可以访问方法内的局部变量\n\n- 示例代码\n\n  ```java\n  class Outer {\n      private int num = 10;\n      public void method() {\n          int num2 = 20;\n          class Inner {\n              public void show() {\n                  System.out.println(num);\n                  System.out.println(num2);\n              }\n          }\n          Inner i = new Inner();\n          i.show();\n      }\n  }\n  public class OuterDemo {\n      public static void main(String[] args) {\n          Outer o = new Outer();\n          o.method();\n      }\n  }\n\n  ```\n\n### 2.4 匿名内部类（应用）\n\n- 匿名内部类的前提\n\n  - 存在一个类或者接口，这里的类可以是具体类也可以是抽象类\n\n- 匿名内部类的格式\n\n  - 格式：new 类名 ( ) {  重写方法 }    new  接口名 ( ) { 重写方法 }\n\n  - 举例： \n\n    ```java\n    new Inter(){\n        @Override\n        public void method(){}\n    } \n    ```\n\n- 匿名内部类的本质\n\n  - 本质：是一个继承了该类或者实现了该接口的子类匿名对象\n\n- 匿名内部类的细节\n\n  - 匿名内部类可以通过多态的形式接受\n\n    ```java\n    Inter i = new Inter(){\n      @Override\n        public void method(){\n            \n        }\n    }\n    ```\n\n- 匿名内部类直接调用方法\n\n  ```java\n  interface Inter{\n      void method();\n  }\n\n  class Test{\n      public static void main(String[] args){\n          new Inter(){\n              @Override\n              public void method(){\n                  System.out.println("我是匿名内部类");\n              }\n          }.method();\t// 直接调用方法\n      }\n  }\n  ```\n\n### 2.4 匿名内部类在开发中的使用（应用）\n\n- 匿名内部类在开发中的使用\n\n  - 当发现某个方法需要，接口或抽象类的子类对象，我们就可以传递一个匿名内部类过去，来简化传统的代码\n\n- 示例代码：\n\n  ```java\n  /*\n      游泳接口\n   */\n  interface Swimming {\n      void swim();\n  }\n\n  public class TestSwimming {\n      public static void main(String[] args) {\n          goSwimming(new Swimming() {\n              @Override\n              public void swim() {\n                  System.out.println("铁汁, 我们去游泳吧");\n              }\n          });\n      }\n\n      /**\n       * 使用接口的方法\n       */\n      public static void goSwimming(Swimming swimming){\n          /*\n              Swimming swim = new Swimming() {\n                  @Override\n                  public void swim() {\n                      System.out.println("铁汁, 我们去游泳吧");\n                  }\n              }\n           */\n          swimming.swim();\n      }\n  }\n  ```\n\n## 5.Lambda表达式\n\n### 5.1体验Lambda表达式【理解】\n\n- 代码演示\n\n  ```java\n  /*\n      游泳接口\n   */\n  interface Swimming {\n      void swim();\n  }\n\n  public class TestSwimming {\n      public static void main(String[] args) {\n          // 通过匿名内部类实现\n          goSwimming(new Swimming() {\n              @Override\n              public void swim() {\n                  System.out.println("铁汁, 我们去游泳吧");\n              }\n          });\n\n          /*  通过Lambda表达式实现\n              理解: 对于Lambda表达式, 对匿名内部类进行了优化\n           */\n          goSwimming(() -> System.out.println("铁汁, 我们去游泳吧"));\n      }\n\n      /**\n       * 使用接口的方法\n       */\n      public static void goSwimming(Swimming swimming) {\n          swimming.swim();\n      }\n  }\n  ```\n\n- 函数式编程思想概述\n\n  在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿数据做操作”\n\n  面向对象思想强调“必须通过对象的形式来做事情”\n\n  函数式思想则尽量忽略面向对象的复杂语法：“强调做什么，而不是以什么形式去做”\n\n  而我们要学习的Lambda表达式就是函数式思想的体现\n\n### 5.2Lambda表达式的标准格式【理解】\n\n- 格式：\n\n  ​\t(形式参数) -> {代码块}\n\n  - 形式参数：如果有多个参数，参数之间用逗号隔开；如果没有参数，留空即可\n  - ->：由英文中画线和大于符号组成，固定写法。代表指向动作\n  - 代码块：是我们具体要做的事情，也就是以前我们写的方法体内容\n\n- 组成Lambda表达式的三要素：\n\n  - 形式参数，箭头，代码块\n\n### 5.3Lambda表达式练习1【应用】\n\n- Lambda表达式的使用前提\n\n  - 有一个接口\n  - 接口中有且仅有一个抽象方法\n\n- 练习描述\n\n  ​\t无参无返回值抽象方法的练习\n\n- 操作步骤\n\n  - 定义一个接口(Eatable)，里面定义一个抽象方法：void eat();\n  - 定义一个测试类(EatableDemo)，在测试类中提供两个方法\n    - 一个方法是：useEatable(Eatable e)\n    - 一个方法是主方法，在主方法中调用useEatable方法\n\n- 示例代码\n\n  ```java\n  //接口\n  public interface Eatable {\n      void eat();\n  }\n  //实现类\n  public class EatableImpl implements Eatable {\n      @Override\n      public void eat() {\n          System.out.println("一天一苹果，医生远离我");\n      }\n  }\n  //测试类\n  public class EatableDemo {\n      public static void main(String[] args) {\n          //在主方法中调用useEatable方法\n          Eatable e = new EatableImpl();\n          useEatable(e);\n\n          //匿名内部类\n          useEatable(new Eatable() {\n              @Override\n              public void eat() {\n                  System.out.println("一天一苹果，医生远离我");\n              }\n          });\n\n          //Lambda表达式\n          useEatable(() -> {\n              System.out.println("一天一苹果，医生远离我");\n          });\n      }\n\n      private static void useEatable(Eatable e) {\n          e.eat();\n      }\n  }\n  ```\n\n### 5.4Lambda表达式练习2【应用】\n\n- 练习描述\n\n  有参无返回值抽象方法的练习\n\n- 操作步骤\n\n  - 定义一个接口(Flyable)，里面定义一个抽象方法：void fly(String s);\n  - 定义一个测试类(FlyableDemo)，在测试类中提供两个方法\n    - 一个方法是：useFlyable(Flyable f)\n    - 一个方法是主方法，在主方法中调用useFlyable方法\n\n- 示例代码\n\n  ```java\n  public interface Flyable {\n      void fly(String s);\n  }\n\n  public class FlyableDemo {\n      public static void main(String[] args) {\n          //在主方法中调用useFlyable方法\n          //匿名内部类\n          useFlyable(new Flyable() {\n              @Override\n              public void fly(String s) {\n                  System.out.println(s);\n                  System.out.println("飞机自驾游");\n              }\n          });\n          System.out.println("--------");\n\n          //Lambda\n          useFlyable((String s) -> {\n              System.out.println(s);\n              System.out.println("飞机自驾游");\n          });\n\n      }\n\n      private static void useFlyable(Flyable f) {\n          f.fly("风和日丽，晴空万里");\n      }\n  }\n  ```\n\n### 5.5Lambda表达式练习3【应用】\n\n- 练习描述\n\n  有参有返回值抽象方法的练习\n\n- 操作步骤\n\n  - 定义一个接口(Addable)，里面定义一个抽象方法：int add(int x,int y);\n  - 定义一个测试类(AddableDemo)，在测试类中提供两个方法\n    - 一个方法是：useAddable(Addable a)\n    - 一个方法是主方法，在主方法中调用useAddable方法\n\n- 示例代码\n\n  ```java\n  public interface Addable {\n      int add(int x,int y);\n  }\n\n  public class AddableDemo {\n      public static void main(String[] args) {\n          //在主方法中调用useAddable方法\n          useAddable((int x,int y) -> {\n              return x + y;\n          });\n\n      }\n\n      private static void useAddable(Addable a) {\n          int sum = a.add(10, 20);\n          System.out.println(sum);\n      }\n  }\n  ```\n\n### 5.6Lambda表达式的省略模式【应用】\n\n- 省略的规则\n\n  - 参数类型可以省略。但是有多个参数的情况下，不能只省略一个\n  - 如果参数有且仅有一个，那么小括号可以省略\n  - 如果代码块的语句只有一条，可以省略大括号和分号，和return关键字\n\n- 代码演示\n\n  ```java\n  public interface Addable {\n      int add(int x, int y);\n  }\n\n  public interface Flyable {\n      void fly(String s);\n  }\n\n  public class LambdaDemo {\n      public static void main(String[] args) {\n  //        useAddable((int x,int y) -> {\n  //            return x + y;\n  //        });\n          //参数的类型可以省略\n          useAddable((x, y) -> {\n              return x + y;\n          });\n\n  //        useFlyable((String s) -> {\n  //            System.out.println(s);\n  //        });\n          //如果参数有且仅有一个，那么小括号可以省略\n  //        useFlyable(s -> {\n  //            System.out.println(s);\n  //        });\n\n          //如果代码块的语句只有一条，可以省略大括号和分号\n          useFlyable(s -> System.out.println(s));\n\n          //如果代码块的语句只有一条，可以省略大括号和分号，如果有return，return也要省略掉\n          useAddable((x, y) -> x + y);\n      }\n\n      private static void useFlyable(Flyable f) {\n          f.fly("风和日丽，晴空万里");\n      }\n\n      private static void useAddable(Addable a) {\n          int sum = a.add(10, 20);\n          System.out.println(sum);\n      }\n  }\n  ```\n\n### 5.7Lambda表达式的使用前提【理解】\n\n- 使用Lambda必须要有接口\n- 并且要求接口中有且仅有一个抽象方法\n\n### 5.8Lambda表达式和匿名内部类的区别【理解】\n\n- 所需类型不同\n  - 匿名内部类：可以是接口，也可以是抽象类，还可以是具体类\n  - Lambda表达式：只能是接口\n- 使用限制不同\n  - 如果接口中有且仅有一个抽象方法，可以使用Lambda表达式，也可以使用匿名内部类\n  - 如果接口中多于一个抽象方法，只能使用匿名内部类，而不能使用Lambda表达式\n- 实现原理不同\n  - 匿名内部类：编译之后，产生一个单独的.class字节码文件\n  - Lambda表达式：编译之后，没有一个单独的.class字节码文件。对应的字节码会在运行的时候动态生成\n\n\n\n'},b642:function(n,e,t){"use strict";t.r(e),e["default"]='## 1.API\r\n\r\n### 1.1 API概述-帮助文档的使用\r\n\r\n- 什么是API\r\n\r\n  ​\tAPI (Application Programming Interface) ：应用程序编程接口\r\n\r\n- java中的API\r\n\r\n  ​\t指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。\r\n\r\n**如何使用API帮助文档 :** \r\n\r\n- 打开帮助文档\r\n\r\n- 找到索引选项卡中的输入框\r\n\r\n- 在输入框中输入Random\r\n\r\n- 看类在哪个包下\r\n\r\n- 看类的描述\r\n\r\n- 看构造方法\r\n\r\n- 看成员方法\r\n\r\n\r\n\r\n### 1.2 键盘录入字符串\r\n\r\n**Scanner类 :**\r\n\r\n​\tnext() : 遇到了空格, 就不再录入数据了 , 结束标记: 空格, tab键\r\n\r\n​\tnextLine() : 可以将数据完整的接收过来 , 结束标记: 回车换行符       \r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.api;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class Demo1Scanner {\r\n    /*\r\n        next() : 遇到了空格, 就不再录入数据了\r\n\r\n                结束标记: 空格, tab键\r\n\r\n        nextLine() : 可以将数据完整的接收过来\r\n\r\n                结束标记: 回车换行符\r\n     */\r\n    public static void main(String[] args) {\r\n        // 1. 创建Scanner对象\r\n        Scanner sc = new Scanner(System.in);\r\n        System.out.println("请输入:");\r\n        // 2. 调用nextLine方法接收字符串\r\n        // ctrl + alt + v : 快速生成方法的返回值\r\n        String s = sc.nextLine();\r\n\r\n        System.out.println(s);\r\n    }\r\n}\r\n\r\n```\r\n\r\n```java\r\npackage com.itheima.api;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class Demo2Scanner {\r\n    /*\r\n        nextInt和nextLine方法配合使用的时候, nextLine方法就没有键盘录入的机会了\r\n\r\n        建议: 今后键盘录入数据的时候, 如果是字符串和整数一起接受, 建议使用next方法接受字符串.\r\n     */\r\n    public static void main(String[] args) {\r\n        Scanner sc = new Scanner(System.in);\r\n        System.out.println("请输入整数:");\r\n        int num = sc.nextInt(); // 10 + 回车换行\r\n        System.out.println("请输入字符串:");\r\n        String s = sc.nextLine();\r\n\r\n\r\n        System.out.println(num);\r\n        System.out.println(s);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## 2. String类\r\n\r\n### 2.1 String概述\r\n\r\n​\t1 String 类在 java.lang 包下，所以使用的时候不需要导包\r\n\r\n​\t2 String 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例也就是说，Java 程序中所有的双引号字符串，都是 String 类的对象\r\n\r\n​\t3 字符串不可变，它们的值在创建后不能被更改\r\n\r\n### 2.2 String类的构造方法\r\n\r\n**常用的构造方法**\r\n\r\n![1590939947722](./day08-常用API.img/1590939947722.png)\r\n\r\n**示例代码**\r\n\r\n```java\r\npackage com.itheima.string;\r\n\r\npublic class Demo2StringConstructor {\r\n    /*\r\n        String类常见构造方法:\r\n\r\n            public String() : 创建一个空白字符串对象，不含有任何内容\r\n            public String(char[] chs) : 根据字符数组的内容，来创建字符串对象\r\n            public String(String original) : 根据传入的字符串内容，来创建字符串对象\r\n            String s = “abc”;  直接赋值的方式创建字符串对象，内容就是abc\r\n\r\n         注意:\r\n                String这个类比较特殊, 打印其对象名的时候, 不会出现内存地址\r\n                而是该对象所记录的真实内容.\r\n\r\n                面向对象-继承, Object类\r\n     */\r\n    public static void main(String[] args) {\r\n        // public String() : 创建一个空白字符串对象，不含有任何内容\r\n        String s1 = new String();\r\n        System.out.println(s1);\r\n\r\n        // public String(char[] chs) : 根据字符数组的内容，来创建字符串对象\r\n        char[] chs = {\'a\',\'b\',\'c\'};\r\n        String s2 = new String(chs);\r\n        System.out.println(s2);\r\n\r\n        // public String(String original) : 根据传入的字符串内容，来创建字符串对象\r\n        String s3 = new String("123");\r\n        System.out.println(s3);\r\n    }\r\n}\r\n```\r\n### 2.4 创建字符串对象的区别对比\r\n\r\n- **通过构造方法创建**\r\n\r\n  ​\t通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同\r\n\r\n- **直接赋值方式创建**\r\n\r\n  ​\t以“”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护\r\n\r\n### 2.5 字符串的比较 \r\n\r\n#### 2.5.1 字符串的比较\r\n\r\n- == 比较基本数据类型：比较的是具体的值\r\n- == 比较引用数据类型：比较的是对象地址值\r\n\r\n**String类 :  public boolean equals(String s)     比较两个字符串内容是否相同、区分大小写**\r\n\r\n**代码 :**\r\n\r\n```java\r\npackage com.itheima.stringmethod;\r\n\r\npublic class Demo1Equals {\r\n    public static void main(String[] args) {\r\n        String s1 = "abc";\r\n        String s2 = "ABC";\r\n        String s3 = "abc";\r\n\r\n        // equals : 比较字符串内容, 区分大小写\r\n        System.out.println(s1.equals(s2));\r\n        System.out.println(s1.equals(s3));\r\n\r\n        // equalsIgnoreCase : 比较字符串内容, 忽略大小写\r\n        System.out.println(s1.equalsIgnoreCase(s2));\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 2.6 用户登录案例【应用】\r\n\r\n**案例需求 :** \r\n\r\n​\t已知用户名和密码，请用程序实现模拟用户登录。总共给三次机会，登录之后，给出相应的提示\r\n\r\n**实现步骤 : **\r\n\r\n1. 已知用户名和密码，定义两个字符串表示即可\r\n2. 键盘录入要登录的用户名和密码，用 Scanner 实现\r\n3. 拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。\r\n4. 字符串的内容比较，用equals() 方法实现\r\n5. 用循环实现多次机会，这里的次数明确，采用for循环实现，并在登录成功的时候，使用break结束循\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class Test1 {\r\n    /*\r\n        需求：已知用户名和密码，请用程序实现模拟用户登录。\r\n              总共给三次机会，登录之后，给出相应的提示\r\n\r\n        思路：\r\n        1. 已知用户名和密码，定义两个字符串表示即可\r\n        2. 键盘录入要登录的用户名和密码，用 Scanner 实现\r\n        3. 拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。\r\n            字符串的内容比较，用equals() 方法实现\r\n        4. 用循环实现多次机会，这里的次数明确，采用for循环实现，并在登录成功的时候，使用break结束循环\r\n\r\n     */\r\n    public static void main(String[] args) {\r\n        // 1. 已知用户名和密码，定义两个字符串表示即可\r\n        String username = "admin";\r\n        String password = "123456";\r\n        // 2. 键盘录入要登录的用户名和密码，用 Scanner 实现\r\n        Scanner sc = new Scanner(System.in);\r\n        // 4. 用循环实现多次机会，这里的次数明确，采用for循环实现\r\n        for(int i = 1; i <= 3; i++){\r\n            System.out.println("请输入用户名:");\r\n            String scUsername = sc.nextLine();\r\n            System.out.println("请输入密码:");\r\n            String scPassword = sc.nextLine();\r\n            // 3. 拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。\r\n            if(username.equals(scUsername) && password.equals(scPassword)){\r\n                System.out.println("登录成功");\r\n                break;\r\n            }else{\r\n                if(i == 3){\r\n                    System.out.println("您的登录次数已达到今日上限, 请明天再来");\r\n                }else{\r\n                    System.out.println("登录失败,您还剩余" + (3-i) +"次机会");\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\n```\r\n\r\n### 2.7 遍历字符串案例【应用】\r\n\r\n**案例需求 :** \r\n\r\n​\t键盘录入一个字符串，使用程序实现在控制台遍历该字符串\r\n\r\n**实现步骤 :** \r\n\r\n1. 键盘录入一个字符串，用 Scanner 实现\r\n2. 遍历字符串，首先要能够获取到字符串中的每一个字符, public char charAt(int index)：返回指定索引处的char值，字符串的索引也是从0开始的\r\n3.  遍历字符串，其次要能够获取到字符串的长度,   public int length()：返回此字符串的长度\r\n4. 遍历打印\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class Test2 {\r\n    /*\r\n        需求：键盘录入一个字符串，使用程序实现在控制台遍历该字符串\r\n\r\n        思路：\r\n        1. 键盘录入一个字符串，用 Scanner 实现\r\n        2. 遍历字符串，首先要能够获取到字符串中的每一个字符\r\n            public char charAt(int index)：返回指定索引处的char值，字符串的索引也是从0开始的\r\n        3. 遍历字符串，其次要能够获取到字符串的长度\r\n            public int length()：返回此字符串的长度\r\n        4. 遍历打印\r\n9\r\n     */\r\n    public static void main(String[] args) {\r\n        //  1. 键盘录入一个字符串，用 Scanner 实现\r\n        Scanner sc = new Scanner(System.in);\r\n        System.out.println("请输入:");\r\n        String s = sc.nextLine();\r\n        // 2. 遍历字符串，首先要能够获取到字符串中的每一个字符\r\n        for(int i = 0; i < s.length(); i++){\r\n            // i : 字符串的每一个索引\r\n            char c = s.charAt(i);\r\n            System.out.println(c);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 2.8 统计字符次数案例【应用】\r\n\r\n**案例需求 :** \r\n\r\n​\t键盘录入一个字符串，使用程序实现在控制台遍历该字符串\r\n\r\n**实现步骤 :** \r\n\r\n1. 键盘录入一个字符串，用 Scanner 实现\r\n2. 将字符串拆分为字符数组 , public char[] toCharArray( )：将当前字符串拆分为字符数组并返回\r\n3. 遍历字符数\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class Test3 {\r\n    /*\r\n       需求：键盘录入一个字符串，使用程序实现在控制台遍历该字符串\r\n\r\n       思路：\r\n       1. 键盘录入一个字符串，用 Scanner 实现\r\n       2. 将字符串拆分为字符数组\r\n                public char[] toCharArray( )：将当前字符串拆分为字符数组并返回\r\n       3. 遍历字符数组\r\n\r\n    */\r\n    public static void main(String[] args) {\r\n        //  1. 键盘录入一个字符串，用 Scanner 实现\r\n        Scanner sc = new Scanner(System.in);\r\n        System.out.println("请输入:");\r\n        String s = sc.nextLine();\r\n        // 2. 将字符串拆分为字符数组\r\n        char[] chars = s.toCharArray();\r\n        // 3. 遍历字符数组\r\n        for (int i = 0; i < chars.length; i++) {\r\n            System.out.println(chars[i]);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 2.9 手机号屏蔽-字符串截取\r\n\r\n**案例需求 :** \r\n\r\n​\t以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽\r\n        最终效果为：156****1234\r\n\r\n**实现步骤 :** \r\n\r\n1. 键盘录入一个字符串，用 Scanner 实现\r\n2. 截取字符串前三位\r\n3. 截取字符串后四位\r\n4. 将截取后的两个字符串，中间加上****进行拼接，输出结果\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class Test5 {\r\n    /*\r\n        需求：以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽\r\n        最终效果为：156****1234\r\n\r\n        思路：\r\n        1. 键盘录入一个字符串，用 Scanner 实现\r\n        2. 截取字符串前三位\r\n        3. 截取字符串后四位\r\n        4. 将截取后的两个字符串，中间加上****进行拼接，输出结果\r\n\r\n     */\r\n    public static void main(String[] args) {\r\n        // 1. 键盘录入一个字符串，用 Scanner 实现\r\n        Scanner sc = new Scanner(System.in);\r\n        System.out.println("请输入手机号:");\r\n        String telString = sc.nextLine();\r\n        // 2. 截取字符串前三位\r\n        String start = telString.substring(0,3);\r\n        // 3. 截取字符串后四位\r\n        String end = telString.substring(7);\r\n        // 4. 将截取后的两个字符串，中间加上****进行拼接，输出结果\r\n        System.out.println(start + "****" + end);\r\n    }\r\n}\r\n```\r\n\r\n### 2.10 敏感词替换-字符串替换\r\n\r\n**案例需求 :** \r\n\r\n​\t键盘录入一个 字符串，如果字符串中包含（TMD），则使用***替换\r\n\r\n**实现步骤 :** \r\n\r\n1. 键盘录入一个字符串，用 Scanner 实现\r\n2. 替换敏感词\r\n               String replace(CharSequence target, CharSequence replacement)\r\n               将当前字符串中的target内容，使用replacement进行替换，返回新的字符串\r\n3. 输出结果\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class Test6 {\r\n    /*\r\n        需求：键盘录入一个 字符串，如果字符串中包含（TMD），则使用***替换\r\n\r\n        思路：\r\n        1. 键盘录入一个字符串，用 Scanner 实现\r\n        2. 替换敏感词\r\n                String replace(CharSequence target, CharSequence replacement)\r\n                将当前字符串中的target内容，使用replacement进行替换，返回新的字符串\r\n        3. 输出结果\r\n\r\n     */\r\n    public static void main(String[] args) {\r\n        // 1. 键盘录入一个字符串，用 Scanner 实现\r\n        Scanner sc = new Scanner(System.in);\r\n        System.out.println("请输入:");\r\n        String s = sc.nextLine();\r\n        // 2. 替换敏感词\r\n        String result = s.replace("TMD","***");\r\n        // 3. 输出结果\r\n        System.out.println(result);\r\n    }\r\n}\r\n```\r\n\r\n### 2.11 切割字符串\r\n\r\n**案例需求 :** \r\n\r\n​\t以字符串的形式从键盘录入学生信息，例如：“张三 , 23”\r\n\r\n​\t从该字符串中切割出有效数据,封装为Student学生对象\r\n\r\n**实现步骤 :** \r\n\r\n1. 编写Student类，用于封装数据\r\n\r\n2. 键盘录入一个字符串，用 Scanner 实现\r\n\r\n3. 根据逗号切割字符串，得到（张三）（23）\r\n\r\n   String[] split(String regex) ：根据传入的字符串作为规则进行切割\r\n   将切割后的内容存入字符串数组中，并将字符串数组返回\r\n\r\n4. 从得到的字符串数组中取出元素内容，通过Student类的有参构造方法封装为对象\r\n\r\n5. 调用对象getXxx方法，取出数据并打印。\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\nimport com.itheima.domain.Student;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class Test7 {\r\n    /*\r\n         需求：以字符串的形式从键盘录入学生信息，例如：“张三 , 23”\r\n                从该字符串中切割出有效数据,封装为Student学生对象\r\n         思路：\r\n            1. 编写Student类，用于封装数据\r\n            2. 键盘录入一个字符串，用 Scanner 实现\r\n            3. 根据逗号切割字符串，得到（张三）（23）\r\n                    String[] split(String regex) ：根据传入的字符串作为规则进行切割\r\n                    将切割后的内容存入字符串数组中，并将字符串数组返回\r\n            4. 从得到的字符串数组中取出元素内容，通过Student类的有参构造方法封装为对象\r\n            5. 调用对象getXxx方法，取出数据并打印。\r\n\r\n     */\r\n    public static void main(String[] args) {\r\n        // 2. 键盘录入一个字符串，用 Scanner 实现\r\n        Scanner sc = new Scanner(System.in);\r\n        System.out.println("请输入学生信息:");\r\n        String stuInfo = sc.nextLine();\r\n        // stuInfo = "张三,23";\r\n        // 3. 根据逗号切割字符串，得到（张三）（23）\r\n        String[] sArr = stuInfo.split(",");\r\n\r\n//        System.out.println(sArr[0]);\r\n//        System.out.println(sArr[1]);\r\n\r\n        // 4. 从得到的字符串数组中取出元素内容，通过Student类的有参构造方法封装为对象\r\n        Student stu = new Student(sArr[0],sArr[1]);\r\n\r\n        // 5. 调用对象getXxx方法，取出数据并打印。\r\n        System.out.println(stu.getName() + "..." + stu.getAge());\r\n    }\r\n}\r\n```\r\n\r\n### 2.12 String方法小结\r\n\r\n**String类的常用方法 :** \r\n\r\n​\tpublic boolean equals(Object anObject)  比较字符串的内容，严格区分大小写\r\n\r\n​\tpublic boolean equalsIgnoreCase(String anotherString)  比较字符串的内容，忽略大小写\r\n\r\n​\tpublic int length()  返回此字符串的长度\r\n\r\n​\tpublic char charAt(int index)  返回指定索引处的 char 值\r\n\r\n​\tpublic char[] toCharArray()  将字符串拆分为字符数组后返回\r\n\r\n​\tpublic String substring(int beginIndex, int endIndex)  根据开始和结束索引进行截取，得到新的字符串（包含头，不包含尾）\r\n\r\n​\tpublic String substring(int beginIndex)  从传入的索引处截取，截取到末尾，得到新的字符串\r\n\r\n​\tpublic String replace(CharSequence target, CharSequence replacement)  使用新值，将字符串中的旧值替换，得到新的字符串\r\n\r\n​\tpublic String[] split(String regex)  根据传入的规则切割字符串，得到字符串数组\r\n\r\n## 3 StringBuilder类\r\n\r\n### 3.1 StringBuilder类概述\r\n\r\n​\t**概述 :** StringBuilder 是一个可变的字符串类，我们可以把它看成是一个容器，这里的可变指的是 StringBuilder 对象中的内容是可变的\r\n\r\n### 3.2 StringBuilder类和String类的区别\r\n\r\n- **String类：**内容是不可变的\r\n- **StringBuilder类：**内容是可变的\r\n\r\n### 3.3StringBuilder类的构造方法\r\n\r\n**常用的构造方法**\r\n\r\n| 方法名                             | 说明                                       |\r\n| ---------------------------------- | ------------------------------------------ |\r\n| public StringBuilder()             | 创建一个空白可变字符串对象，不含有任何内容 |\r\n| public StringBuilder(String   str) | 根据字符串的内容，来创建可变字符串对象     |\r\n\r\n**示例代码**\r\n\r\n```java\r\npublic class StringBuilderDemo01 {\r\n    public static void main(String[] args) {\r\n        //public StringBuilder()：创建一个空白可变字符串对象，不含有任何内容\r\n        StringBuilder sb = new StringBuilder();\r\n        System.out.println("sb:" + sb);\r\n        System.out.println("sb.length():" + sb.length());\r\n\r\n        //public StringBuilder(String str)：根据字符串的内容，来创建可变字符串对象\r\n        StringBuilder sb2 = new StringBuilder("hello");\r\n        System.out.println("sb2:" + sb2);\r\n        System.out.println("sb2.length():" + sb2.length());\r\n    }\r\n}\r\n```\r\n\r\n### 3.4 StringBuilder常用的成员方法\r\n\r\n- **添加和反转方法**\r\n\r\n  | 方法名                                  | 说明                     |\r\n  | --------------------------------------- | ------------------------ |\r\n  | public StringBuilder   append(任意类型) | 添加数据，并返回对象本身 |\r\n  | public StringBuilder   reverse()        | 返回相反的字符序列       |\r\n\r\n- **示例代码**\r\n\r\n```java\r\npublic class StringBuilderDemo01 {\r\n    public static void main(String[] args) {\r\n        //创建对象\r\n        StringBuilder sb = new StringBuilder();\r\n\r\n        //public StringBuilder append(任意类型)：添加数据，并返回对象本身\r\n//        StringBuilder sb2 = sb.append("hello");\r\n//\r\n//        System.out.println("sb:" + sb);\r\n//        System.out.println("sb2:" + sb2);\r\n//        System.out.println(sb == sb2);\r\n\r\n//        sb.append("hello");\r\n//        sb.append("world");\r\n//        sb.append("java");\r\n//        sb.append(100);\r\n\r\n        //链式编程\r\n        sb.append("hello").append("world").append("java").append(100);\r\n\r\n        System.out.println("sb:" + sb);\r\n\r\n        //public StringBuilder reverse()：返回相反的字符序列\r\n        sb.reverse();\r\n        System.out.println("sb:" + sb);\r\n    }\r\n}\r\n```\r\n\r\n### 3.5StringBuilder和String相互转换【应用】\r\n\r\n- **StringBuilder转换为String**\r\n\r\n  ​        public String toString()：通过 toString() 就可以实现把 StringBuilder 转换为 String\r\n\r\n- **String转换为StringBuilder**\r\n\r\n  ​        public StringBuilder(String s)：通过构造方法就可以实现把 String 转换为 StringBuilder\r\n\r\n- **示例代码**\r\n\r\n```java\r\npublic class StringBuilderDemo02 {\r\n    public static void main(String[] args) {\r\n        /*\r\n        //StringBuilder 转换为 String\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append("hello");\r\n\r\n        //String s = sb; //这个是错误的做法\r\n\r\n        //public String toString()：通过 toString() 就可以实现把 StringBuilder 转换为 String\r\n        String s = sb.toString();\r\n        System.out.println(s);\r\n        */\r\n\r\n        //String 转换为 StringBuilder\r\n        String s = "hello";\r\n\r\n        //StringBuilder sb = s; //这个是错误的做法\r\n\r\n        //public StringBuilder(String s)：通过构造方法就可以实现把 String 转换为 StringBuilder\r\n        StringBuilder sb = new StringBuilder(s);\r\n\r\n        System.out.println(sb);\r\n    }\r\n}\r\n```\r\n\r\n### 3.6 StringBuilder拼接字符串案例\r\n\r\n**案例需求 :** \r\n\r\n​\t定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回，调用该方法，\r\n\r\n​\t并在控制台输出结果。例如，数组为int[] arr = {1,2,3}; ，执行方法后的输出结果为：[1, 2, 3]\r\n\r\n**实现步骤 :** \r\n\r\n1. 定义一个 int 类型的数组，用静态初始化完成数组元素的初始化\r\n2. 定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回。\r\n             返回值类型 String，参数列表 int[] arr\r\n3. 在方法中用 StringBuilder 按照要求进行拼接，并把结果转成 String 返回\r\n4. 调用方法，用一个变量接收结果\r\n5. 输出结果\r\n\r\n**代码实现 :** \r\n\r\n```java\r\n/*\r\n    思路：\r\n        1:定义一个 int 类型的数组，用静态初始化完成数组元素的初始化\r\n        2:定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回。\r\n          返回值类型 String，参数列表 int[] arr\r\n        3:在方法中用 StringBuilder 按照要求进行拼接，并把结果转成 String 返回\r\n        4:调用方法，用一个变量接收结果\r\n        5:输出结果\r\n */\r\npublic class StringBuilderTest01 {\r\n    public static void main(String[] args) {\r\n        //定义一个 int 类型的数组，用静态初始化完成数组元素的初始化\r\n        int[] arr = {1, 2, 3};\r\n\r\n        //调用方法，用一个变量接收结果\r\n        String s = arrayToString(arr);\r\n\r\n        //输出结果\r\n        System.out.println("s:" + s);\r\n\r\n    }\r\n\r\n    //定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回\r\n    /*\r\n        两个明确：\r\n            返回值类型：String\r\n            参数：int[] arr\r\n     */\r\n    public static String arrayToString(int[] arr) {\r\n        //在方法中用 StringBuilder 按照要求进行拼接，并把结果转成 String 返回\r\n        StringBuilder sb = new StringBuilder();\r\n\r\n        sb.append("[");\r\n\r\n        for(int i=0; i<arr.length; i++) {\r\n            if(i == arr.length-1) {\r\n                sb.append(arr[i]);\r\n            } else {\r\n                sb.append(arr[i]).append(", ");\r\n            }\r\n        }\r\n\r\n        sb.append("]");\r\n\r\n        String s = sb.toString();\r\n\r\n        return  s;\r\n    }\r\n}\r\n```\r\n\r\n'},b720:function(n,e,t){"use strict";t.r(e),e["default"]='# web综合案例\r\n\r\n## 学习目标\r\n\r\n目标1：完成用户与角色的绑定功能\r\n\r\n目标2：完成登陆功能的快速开发\r\n\r\n目标3：完成登陆用户菜单控制的功能\r\n\r\n目标4：完成登陆用户权限校验的功能\r\n\r\n## 1.  用户与角色\r\n\r\n### 1.1 绑定用户与角色关系数据准备\r\n\r\n（1）在用户模块下的`\\WEB-INF\\pages\\system\\user\\list.jsp`页面中找到`角色`按钮，对应的点击事件和函数的绑定都已完成，`roleList`方法中向后台`UserServelt`发送请求，执行`userRoleList`方法，传递参数用户id\r\n\r\n（2）找到`UserServlet`，添加方法\r\n\r\n```java\r\n@Override\r\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n    String operation = request.getParameter("operation");\r\n    if("list".equals(operation)){\r\n        this.list(request,response);\r\n    }\r\n    //中间的省略\r\n    else if("userRoleList".equals(operation)){\r\n        this.userRoleList(request,response);\r\n    }\r\n}\r\nprivate void userRoleList(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n    String userId = request.getParameter("id");\r\n    User user = userService.findById(userId);\r\n    //将数据加载到指定区域，供页面获取\r\n    request.setAttribute("user,user);\r\n    //获取所有的角色列表\r\n    List<Role> all = roleService.findAllRoleByUserId(userId);\r\n    request.setAttribute("roleList",all);\r\n    //跳转页面\r\n    request.getRequestDispatcher("/WEB-INF/pages/system/user/role.jsp").forward(request,response);\r\n}\r\n```\r\n\r\n同时从`day03`的课程资料中找到：`模块页面\\user\\role.jsp`，拷贝到工程`/WEB-INF/pages/system/user/`目录下\r\n\r\n（3）在`RoleService`接口中添加查询方法，根据用户id查询角色列表\r\n\r\n```java\r\nList<Role> findAllRoleByUserId(String userId);\r\n```\r\n\r\n（4）在对应的实现类中去实现该方法\r\n\r\n```java\r\n@Override\r\npublic List<Role> findAllRoleByUserId(String userId) {\r\n    SqlSession sqlSession = null;\r\n    try{\r\n        //1.获取SqlSession\r\n        sqlSession = MapperFactory.getSqlSession();\r\n        //2.获取Dao\r\n        RoleDao roleDao = MapperFactory.getMapper(sqlSession,RoleDao.class);\r\n        //3.调用Dao层操作\r\n        return roleDao.findAllRoleByUserId(userId);\r\n    }catch (Exception e){\r\n        throw new RuntimeException(e);\r\n        //记录日志\r\n    }finally {\r\n        try {\r\n            TransactionUtil.close(sqlSession);\r\n        }catch (Exception e){\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n（5）在dao接口`RoleDao`中添加查询方法`findAllRoleByUserId`\r\n\r\n```java\r\nList<Role> findAllRoleByUserId(String userId);\r\n```\r\n\r\n（6）在映射配置文件`RoleDao.xml`中添加对应的查询\r\n\r\n```xml\r\n    \x3c!--配置根据ID查询--\x3e\r\n<select id="findAllRoleByUserId" parameterType="java.lang.String" resultMap="BaseResultMap">\r\n\tSELECT\r\n\t\trole_id,\r\n\t\tNAME,\r\n\t\tCASE\r\n\t\t\tWHEN role_id IN (SELECT role_id FROM ss_role_user WHERE user_id = #{\'userId\'})\r\n\t\t\tTHEN \'checked\'\r\n\t\t\tELSE \'\'\r\n\t\tEND\r\n\t\tAS remark\r\n\tFROM\r\n\t\tss_role\r\n</select>\r\n```\r\n\r\n（7）修改页面`/WEB-INF/pages/system/user/role.jsp`，添加checked\r\n\r\n```jsp\r\n<form id="urform" action="${ctx}/system/user?operation=updateRole" method="post">\r\n    <input type="hidden" name="userId" value="${user.id}"/>\r\n    <div class="textbox" id="centerTextbox">\r\n        <div style="text-align:left">\r\n            <c:forEach items="${roleList}" var="role" varStatus="vs">\r\n                <span style="padding:3px;margin-right:30px;width: 160px;display: inline-block">\r\n        <input type="checkbox" name="roleIds" value="${role.id}" ${role.remark}/>${role.name}\r\n                </span>\r\n            </c:forEach>\r\n        </div>\r\n    </div>\r\n</form>\r\n```\r\n\r\n（8）启动项目测试！\r\n\r\n### 1.2 绑定用户与角色关系\r\n\r\n现在要真正去绑定用户与角色的关系，前台页面提交表单后会将用户的id和选择的角色的id传递到后台servlet\r\n\r\n（1）在`UserServlet`中添加新的方法\r\n\r\n```java\r\n@Override\r\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n    String operation = request.getParameter("operation");\r\n    if("list".equals(operation)){\r\n        this.list(request,response);\r\n    }\r\n    //中间的省略\r\n    else if("userRoleList".equals(operation)){\r\n        this.userRoleList(request,response);\r\n    }else if("updateRole".equals(operation)){\r\n        this.updateRole(request,response);\r\n    }\r\n}\r\nprivate void updateRole(HttpServletRequest request, HttpServletResponse response) throws IOException {\r\n    String userId = request.getParameter("userId");\r\n    String[] roleIds = request.getParameterValues("roleIds");\r\n    userService.updateRole(userId,roleIds);\r\n    //跳转回到页面list\r\n    response.sendRedirect(request.getContextPath()+"/system/user?operation=list");\r\n}\r\n```\r\n\r\n（2）在`UserService`接口中添加一个新的方法`updateRole`\r\n\r\n```java\r\nvoid updateRole(String userId, String[] roleIds);\r\n```\r\n\r\n（3）在对应的实现类中去实现\r\n\r\n```java\r\n@Overridepublic void updateRole(String userId, String[] roleIds) {    SqlSession sqlSession = null;    try{        //1.获取SqlSession        sqlSession = MapperFactory.getSqlSession();        //2.获取Dao        UserDao userDao = MapperFactory.getMapper(sqlSession,UserDao.class);        userDao.deleteRole(userId);        for(String roleId : roleIds){            userDao.updateRole(userId,roleId);        }        //4.提交事务        TransactionUtil.commit(sqlSession);    }catch (Exception e){        TransactionUtil.rollback(sqlSession);        throw new RuntimeException(e);        //记录日志    }finally {        try {            TransactionUtil.close(sqlSession);        }catch (Exception e){            e.printStackTrace();        }    }}\r\n```\r\n\r\n（4）在dao接口`UserDao`中添加两个方法\r\n\r\n```java\r\nvoid deleteRole(String userId);void updateRole(@Param("userId") String userId, @Param("roleId")String roleId);\r\n```\r\n\r\n（5）在该接口对应的映射配置文件中添加两个操作\r\n\r\n```xml\r\n\x3c!--配置根据roleId删除关系表数据--\x3e<delete id="deleteRole" parameterType="java.lang.String">    delete from ss_role_user    where user_id = #{userId,jdbcType=VARCHAR}</delete>\x3c!--配置全字段插入，当某个字段没有值时，插入null--\x3e<insert id="updateRole" parameterType="map">    insert into ss_role_user (role_id, user_id)    values (#{roleId,jdbcType=VARCHAR}, #{userId,jdbcType=VARCHAR})</insert>\r\n```\r\n\r\n（6）启动项目进行测试！\r\n\r\n## 2. 登陆\r\n\r\n### 2.1 登陆功能快速开发\r\n\r\n（1）找到项目`webapp/login.jsp`登陆页面，修改form表单提交的action路径\r\n\r\n```html\r\n<form action="${pageContext.request.contextPath}/login?operation=login" method="post"></form>\r\n```\r\n\r\n（2）在后台`UserServlet`添加登陆的方法\r\n\r\n```java\r\n@Overrideprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    String operation = request.getParameter("operation");    if("list".equals(operation)){        this.list(request,response);    }    //中间省略    else if("login".equals(operation)){        this.login(request,response);    }}private void login(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    String email = request.getParameter("email");    String pwd = request.getParameter("password");    User user = userService.login(email,pwd);    if(user != null) {        request.getSession().setAttribute("loginUser", user);        //跳转页面        request.getRequestDispatcher("/WEB-INF/pages/home/main.jsp").forward(request, response);    }else{        response.sendRedirect(request.getContextPath()+"/login.jsp");    }}\r\n```\r\n\r\n（3）在因为层接口`UserService`中添加登陆的方法\r\n\r\n```java\r\n/**     * 根据邮箱和密码登录     * @param email     * @param pwd     * @return     */    User login(String email, String pwd);\r\n```\r\n\r\n（4）在对应的实现类中去实现登陆方法\r\n\r\n```java\r\n@Overridepublic User login(String email, String pwd) {    SqlSession sqlSession = null;    try{        //1.获取SqlSession        sqlSession = MapperFactory.getSqlSession();        //2.获取Dao        UserDao userDao = MapperFactory.getMapper(sqlSession,UserDao.class);        //3.调用Dao层操作        pwd = MD5Util.md5(pwd);        return userDao.findByEmailAndPwd(email,pwd);    }catch (Exception e){        throw new RuntimeException(e);        //记录日志    }finally {        try {            TransactionUtil.close(sqlSession);        }catch (Exception e){            e.printStackTrace();        }    }}\r\n```\r\n\r\n（5）在`UserDao`接口中添加查询方法\r\n\r\n```java\r\nUser findByEmailAndPwd(@Param("email")String email, @Param("password")String pwd);\r\n```\r\n\r\n（6）在`UserDao.xml`中添加查询\r\n\r\n```xml\r\n<select id="findByEmailAndPwd" parameterType="map" resultMap="BaseResultMap">    select    <include refid="Base_Column_List"/>    from ss_user    where email = #{email,jdbcType=VARCHAR} and password = #{password,jdbcType=VARCHAR}</select>\r\n```\r\n\r\n（7）将原本在`webapp/pages/home`下的所有页面统一挪到`/WEB-INF/pages`下，注意是连同`home`目录一起挪\r\n\r\n（8）修改`/WEB-INF/pages/home/main.jsp`内容区的路径\r\n\r\n```jsp\r\n\x3c!-- 内容区域 --\x3e<div class="content-wrapper">    <iframe id="iframe" name="iframe"            style="overflow:visible;"            scrolling="auto"            frameborder="no" height="100%" width="100%"            src="${ctx}/system/user?operation=home"></iframe></div>\r\n```\r\n\r\n（9）在后台`UserServlet`中添加方法\r\n\r\n```java\r\n@Overrideprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    String operation = request.getParameter("operation");    if("list".equals(operation)){        this.list(request,response);    }    //中间省略    else if("home".equals(operation)){        this.home(request,response);    }}private void home(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    request.getRequestDispatcher("/WEB-INF/pages/home/home.jsp").forward(request, response);}\r\n```\r\n\r\n（10）启动项目测试\r\n\r\n### 2.2 用户菜单控制数据准备\r\n\r\n我们先来完成登陆后的注销操作，这是一套的\r\n\r\n（1）找到`/WEB-INF/pages/home/header.jsp`中找到注销，添加请求连接\r\n\r\n```jsp\r\n<div class="pull-right">    <a href="${ctx}/system/user?operation=logout" class="btn btn-default btn-flat">注销</a></div>\r\n```\r\n\r\n（2）在后台`UserServlet`中添加对应的方法logout\r\n\r\n```java\r\n@Overrideprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    String operation = request.getParameter("operation");    if("list".equals(operation)){        this.list(request,response);    }    //中间的省略    else if("login".equals(operation)){        this.login(request,response);    }else if("logout".equals(operation)){        this.logout(request,response);    }else if("home".equals(operation)){        this.home(request,response);    }}private void logout(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    request.getSession().removeAttribute("loginUser");    response.sendRedirect(request.getContextPath()+"/login.jsp");}\r\n```\r\n\r\n（3）在用户登陆的时候需要去查询该用户对应的角色对应的所有模块，因此需要在后台的`UserServlet`中修改用户登陆的方法，添加数据的查询\r\n\r\n```java\r\nprivate void login(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    String email = request.getParameter("email");    String pwd = request.getParameter("password");    User user = userService.login(email,pwd);    if(user != null) {        request.getSession().setAttribute("loginUser", user);        //如果登录成功，加载该用户对应的角色对应的所有模块        List<Module> moduleList = userService.findModuleById(user.getId());        request.setAttribute("moduleList",moduleList);        //跳转页面        request.getRequestDispatcher("/WEB-INF/pages/home/main.jsp").forward(request, response);    }else{        response.sendRedirect(request.getContextPath()+"/login.jsp");    }}\r\n```\r\n\r\n（4）在`UserService`接口中添加方法`findModuleById`\r\n\r\n```java\r\n/**     * 根据用户id查询所有可以操作的菜单对象     * @param id 用户的id     * @return     */    List<Module> findModuleById(String id);\r\n```\r\n\r\n（5）在实现类中去实现该方法\r\n\r\n```java\r\n@Overridepublic List<Module> findModuleById(String id) {    SqlSession sqlSession = null;    try{        //1.获取SqlSession        sqlSession = MapperFactory.getSqlSession();        //2.获取Dao        ModuleDao moduleDao = MapperFactory.getMapper(sqlSession,ModuleDao.class);        //3.调用Dao层操作        return moduleDao.findModuleByUserId(id);    }catch (Exception e){        throw new RuntimeException(e);        //记录日志    }finally {        try {            TransactionUtil.close(sqlSession);        }catch (Exception e){            e.printStackTrace();        }    }}\r\n```\r\n\r\n（6）在`ModuleDao`接口中添加查询方法`findModuleByUserId`\r\n\r\n```java\r\nList<Module> findModuleByUserId(String id);\r\n```\r\n\r\n（7）在`ModuleDao.xml`中添加对应的查询\r\n\r\n```xml\r\n<select id="findModuleByUserId" parameterType="java.lang.String" resultMap="BaseResultMap">        /*userid->用户角色关系表->roleid->角色模块关系表->moduleid->module信息*/        SELECT DISTINCT          m.module_id, m.parent_id, m.name, m.ctype, m.state, m.curl, m.remark        FROM            ss_module AS m,            ss_role_module AS rm,            ss_role_user AS ru        WHERE            m.module_id = rm.module_id        AND\trm.role_id = ru.role_id        AND\tru.user_id = #{id,jdbcType=VARCHAR}    </select>\r\n```\r\n\r\n至此：用户的角色对应的模块数据已查询出来了，后续就是要在页面进行控制展示\r\n\r\n### 2.3 登陆用户菜单控制\r\n\r\n（1）找到`/WEB-INF/pages/home/aside.jsp`页面，添加用户菜单的展示\r\n\r\n```jsp\r\n\x3c!-- sidebar menu: : style can be found in sidebar.less --\x3e<ul class="sidebar-menu">    <li class="header">菜单</li>    <c:forEach items="${moduleList}" var="item">        <c:if test="${item.ctype==0}">            <li class="treeview">                <a href="#">                    <i class="fa fa-cube"></i> <span>${item.name}</span>                    <span class="pull-right-container"><i class="fa fa-angle-left pull-right"></i></span>                </a>                <ul class="treeview-menu">                    <c:forEach items="${moduleList}" var="item2">                        <c:if test="${item2.ctype==1 && item2.parentId == item.id}">                            <li id="${item2.id}">                                <a onclick="setSidebarActive(this)" href="${ctx}/${item2.curl}" target="iframe">                                    <i class="fa fa-circle-o"></i>${item2.name}                                </a>                            </li>                        </c:if>                    </c:forEach>                </ul>            </li>        </c:if>    </c:forEach>\r\n```\r\n\r\n启动项目进行测试\r\n\r\n## 3.权限校验\r\n\r\n### 3.1 获取请求url\r\n\r\n（1）创建过滤器：com.itheima.web.filters.AuthorFilter\r\n\r\n```java\r\n@WebFilter(value = "/*")public class AuthorFilter implements Filter {    private FilterConfig filterConfig;    /**     * 初始化方法，获取过滤器的配置对象     * @param filterConfig     * @throws ServletException     */    @Override    public void init(FilterConfig filterConfig) throws ServletException {        this.filterConfig = filterConfig;    }    @Override    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException {        //1.定义和协议相关的请求和响应对象        HttpServletRequest request ;        HttpServletResponse response;        try{            //2.把参数转换成协议相关的对象            request = (HttpServletRequest)req;            response = (HttpServletResponse)resp;            //1.获取本次操作            String url = request.getRequestURI();            String queryString = request.getQueryString();            //1.当前获取到的url：   /system/dept            url = url.substring(1);            //2.当前获取到的查询参数：operation=list       operation=toEdit&id=100            int index = queryString.indexOf(\'&\');            if(index != -1){                queryString = queryString.substring(0,index);            }            url = url + "?" + queryString;            //2.获取到当前登录人允许的操作            //3.比对本次操作是否在当前登录人允许的操作范围内            //3.1如果允许，放行            //3.2不允许跳转到非法访问页            //6.放行            chain.doFilter(request,response);        }catch (Exception e){            e.printStackTrace();        }    }    @Override    public void destroy() {        //可以做一些清理操作    }}\r\n```\r\n\r\n### 3.2 获取登陆用户可执行操作\r\n\r\n（1）登陆成功后需要将用户的觉得对应的模块信息存放到session，找到`UserServlet`中的登陆方法`login`，\r\n\r\n```java\r\nprivate void login(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    String email = request.getParameter("email");    String pwd = request.getParameter("password");    User user = userService.login(email,pwd);    if(user != null) {        request.getSession().setAttribute("loginUser", user);        //如果登录成功，加载该用户对应的角色对应的所有模块        List<Module> moduleList = userService.findModuleById(user.getId());        request.setAttribute("moduleList",moduleList);        //当前登录用户对应的可操作模块的所有url拼接成一个大的字符串        StringBuffer sbf = new StringBuffer();        for(Module m: moduleList){            sbf.append(m.getCurl());            sbf.append(\',\');        }        request.getSession().setAttribute("authorStr",sbf.toString());        //跳转页面        request.getRequestDispatcher("/WEB-INF/pages/home/main.jsp").forward(request, response);    }else{        response.sendRedirect(request.getContextPath()+"/login.jsp");    }}\r\n```\r\n\r\n（2）修改`AuthorFilter`\r\n\r\n```java\r\n@Overridepublic void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException {    //1.定义和协议相关的请求和响应对象    HttpServletRequest request ;    HttpServletResponse response;    HttpSession session;    try{        //2.把参数转换成协议相关的对象        request = (HttpServletRequest)req;        response = (HttpServletResponse)resp;        session = request.getSession();        //1.获取本次操作        String url = request.getRequestURI();        //.css   .js    .png   .jpg   .index        if(url.endsWith(".css")           || url.endsWith(".js")           || url.endsWith(".png")           || url.endsWith(".jpg")           || url.endsWith("index.jsp")           || url.endsWith("login.jsp")){            chain.doFilter(request,response);            return;        }        String queryString = request.getQueryString();        if(queryString.endsWith("operation=login")){            chain.doFilter(request,response);            return;        }        //1.当前获取到的url：   /system/dept        url = url.substring(1);        //2.当前获取到的查询参数：operation=list       operation=toEdit&id=100        int index = queryString.indexOf(\'&\');        if(index != -1){            queryString = queryString.substring(0,index);        }        url = url + "?" + queryString;        //2.获取到当前登录人允许的操作        String authorStr = session.getAttribute("authorStr").toString();        //3.比对本次操作是否在当前登录人允许的操作范围内        //3.1如果允许，放行        //3.2不允许跳转到非法访问页        //6.放行        chain.doFilter(request,response);    }catch (Exception e){        e.printStackTrace();    }}\r\n```\r\n\r\n（3）启动项目在模块管理功能中去添加一些数据，如下所示\r\n\r\n![](web综合案例_day04.assets/1.png)\r\n\r\n![](web综合案例_day04.assets/2.png)\r\n\r\n![](web综合案例_day04.assets/3.png)\r\n\r\n![](web综合案例_day04.assets/4.png)\r\n\r\n![](web综合案例_day04.assets/5.png)\r\n\r\n然后需要在角色管理中为对应的角色进行授权\r\n\r\n### 3.3 权限校验\r\n\r\n开始授权\r\n\r\n（1）从`day03`的课程资料中找到`模块页面/unauthorized.jsp`，拷贝到项目的`webapp`下即可\r\n\r\n（2）更改`AuthorFilter`，\r\n\r\n```java\r\n@Overridepublic void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException {    HttpServletRequest request ;    HttpServletResponse response;    HttpSession session;    try{        request = (HttpServletRequest)req;        response = (HttpServletResponse)resp;        session = request.getSession();        //1.获取本次操作        String url = request.getRequestURI();        //.css   .js    .png   .jpg   .index        if(url.endsWith(".css")           || url.endsWith(".js")           || url.endsWith(".png")           || url.endsWith(".jpg")           || url.endsWith("index.jsp")           || url.endsWith("unauthorized.jsp")           || url.endsWith("login.jsp")){            chain.doFilter(request,response);            return;        }        String queryString = request.getQueryString();        if(queryString.endsWith("operation=login")           ||queryString.endsWith("operation=home")           ||queryString.endsWith("operation=logout")){            chain.doFilter(request,response);            return;        }        //1.当前获取到的url：   /system/dept        url = url.substring(1);        //2.当前获取到的查询参数：operation=list       operation=toEdit&id=100        int index = queryString.indexOf(\'&\');        if(index != -1){            queryString = queryString.substring(0,index);        }        url = url + "?" + queryString;        //2.获取到当前登录人允许的操作        String authorStr = session.getAttribute("authorStr").toString();        //3.比对本次操作是否在当前登录人允许的操作范围内        if(authorStr.contains(url)){            //3.1如果允许，放行            chain.doFilter(request,response);            return;        }else{            //3.2不允许跳转到非法访问页            response.sendRedirect(request.getContextPath()+"/unauthorized.jsp");        }    }catch (Exception e){        e.printStackTrace();    }}\r\n```\r\n\r\n（3）对于页面上的元素，如果没有操作权限，我们直接让用户看不到即可，怎么操作呢？在页面上做一个判断，我们举一个例子，其他操作都是一样的\r\n\r\n找到`/WEB-INF/pages/system/user/list.jsp`，\r\n\r\n```jsp\r\n<div class="btn-group">    <c:if test="${sessionScope.authorStr.contains(\'system/user?operation=toAdd\')}">        <button type="button" class="btn btn-default" title="新建" onclick=\'location.href="${ctx}/system/user?operation=toAdd"\'><i class="fa fa-file-o"></i> 新建</button>    </c:if>    <button type="button" class="btn btn-default" title="删除" onclick=\'deleteById()\'><i class="fa fa-trash-o"></i> 删除</button>    <button type="button" class="btn btn-default" title="刷新" onclick="window.location.reload();"><i class="fa fa-refresh"></i> 刷新</button>    <c:if test="${sessionScope.authorStr.contains(\'system/user?operation=userRoleList\')}">        <button type="button" class="btn btn-default" title="角色" onclick="roleList()"><i class="fa fa-user-circle-o"></i> 角色</button>    </c:if></div>\r\n```\r\n\r\n（4）启动项目，测试\r\n\r\n'},b85c:function(n,e,t){var r={"./Maven基础.md":"21b0","./Maven高级.md":"5f88","./POM文件帮助文档.md":"8187"};function a(n){var e=i(n);return t(e)}function i(n){if(!t.o(r,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return r[n]}a.keys=function(){return Object.keys(r)},a.resolve=i,n.exports=a,a.id="b85c"},bb51:function(n,e,t){"use strict";t.r(e),e["default"]='## 什么是 RPC?RPC原理是什么?\n\n### **什么是 RPC？**\n\nRPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 HTTP请求 当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题。\n\n### **RPC原理是什么？**\n\n![RPC原理图](服务之间的调用为啥不直接用HTTP而用RPC.assets/37345851.jpg)\n\n1. 服务消费端（client）以本地调用的方式调用远程服务；\n2. 客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：`RpcRequest`；\n3. 客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；\n4. 服务端 Stub（桩）收到消息将消息反序列化为Java对象: `RpcRequest`；\n5. 服务端 Stub（桩）根据`RpcRequest`中的类、方法、方法参数等信息调用本地的方法；\n6. 服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：`RpcResponse`（序列化）发送至消费方；\n7. 客户端 Stub（client stub）接收到消息并将消息反序列化为Java对象:`RpcResponse` ，这样也就得到了最终结果。\n\n下面再贴一个网上的时序图，辅助理解：\n\n![RPC原理时序图](服务之间的调用为啥不直接用HTTP而用RPC.assets/32527396.jpg)\n\n### RPC 解决了什么问题？\n\n从上面对 RPC 介绍的内容中，概括来讲RPC 主要解决了：**让分布式或者微服务系统中不同服务之间的调用像本地调用一样简单。**\n\n### 常见的 RPC 框架总结?\n\n- **RMI（JDK自带）：** JDK自带的RPC，有很多局限性，不推荐使用。\n- **Dubbo:** Dubbo是 阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。目前 Dubbo 已经成为 Spring Cloud Alibaba 中的官方组件。\n- **gRPC** ：gRPC是可以在任何环境中运行的现代开源高性能RPC框架。它可以通过可插拔的支持来有效地连接数据中心内和跨数据中心的服务，以实现负载平衡，跟踪，运行状况检查和身份验证。它也适用于分布式计算的最后一英里，以将设备，移动应用程序和浏览器连接到后端服务。\n- **Hessian：** Hessian是一个轻量级的remoting on http工具，使用简单的方法提供了RMI的功能。 相比WebService，Hessian更简单、快捷。采用的是二进制RPC协议，因为采用的是二进制协议，所以它很适合于发送二进制数据。\n- **Thrift：**  Apache Thrift是Facebook开源的跨语言的RPC通信框架，目前已经捐献给Apache基金会管理，由于其跨语言特性和出色的性能，在很多互联网公司得到应用，有能力的公司甚至会基于thrift研发一套分布式服务框架，增加诸如服务注册、服务发现等功能。\n\n### RPC学习材料\n\n- [跟着 Guide 哥造轮子](https://github.com/Snailclimb/guide-rpc-framework)\n\n## 既有 HTTP ,为啥用 RPC 进行服务调用?\n\n### RPC 只是一种设计而已\n\nRPC 只是一种概念、一种设计，就是为了解决 **不同服务之间的调用问题**, 它一般会包含有 **传输协议** 和 **序列化协议** 这两个。\n\n但是，HTTP  是一种协议，RPC框架可以使用 HTTP协议作为传输协议或者直接使用TCP作为传输协议，使用不同的协议一般也是为了适应不同的场景。\n\n### HTTP 和 TCP\n\n**可能现在很多对计算机网络不太熟悉的朋友已经被搞蒙了，要想真正搞懂，还需要来简单复习一下计算机网络基础知识：**\n\n> 我们通常谈计算机网络的五层协议的体系结构是指：应用层、传输层、网络层、数据链路层、物理层。\n>\n> **应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。** HTTP 属于应用层协议，它会基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过 URL 向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。HTTP协议建立在 TCP 协议之上。\n>\n> **传输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务**。TCP是传输层协议，主要解决数据如何在网络中传输。相比于UDP,**TCP** 提供的是**面向连接**的，**可靠的**数据传输服务。\n\n### RPC框架功能更齐全\n\n成熟的 RPC框架还提供好了“服务自动注册与发现”、"智能负载均衡"、“可视化的服务治理和运维”、“运行期流量调度”等等功能，这些也算是选择\nRPC 进行服务注册和发现的一方面原因吧！\n\n**相关阅读：**\n\n- http://www.ruanyifeng.com/blog/2016/08/http.html （HTTP 协议入门- 阮一峰）\n\n### 一个常见的错误观点\n\n很多文章中还会提到说 HTTP 协议相较于自定义 TCP 报文协议，增加的开销在于连接的建立与断开，但是这个观点已经被否认，下面截取自知乎中一个回答，原回答地址：https://www.zhihu.com/question/41609070/answer/191965937 。\n\n>首先要否认一点 HTTP 协议相较于自定义 TCP 报文协议，增加的开销在于连接的建立与断开。HTTP 协议是支持连接池复用的，也就是建立一定数量的连接不断开，并不会频繁的创建和销毁连接。二一要说的是 HTTP 也可以使用 Protobuf 这种二进制编码协议对内容进行编码，因此二者最大的区别还是在传输协议上。\n\n\n\n'},be8c:function(n,e,t){"use strict";t.r(e),e["default"]='## 1. switch语句\r\n\r\n### 1.1 分支语句switch语句\r\n\r\n* 格式\r\n\r\n  ```java\r\n  switch (表达式) {\r\n  \tcase 1:\r\n  \t\t语句体1;\r\n  \t\tbreak;\r\n  \tcase 2:\r\n  \t\t语句体2;\r\n  \t\tbreak;\r\n  \t...\r\n  \tdefault:\r\n  \t\t语句体n+1;\r\n  \t\tbreak;\r\n  }\r\n  ```\r\n\r\n* 执行流程：\r\n\r\n  * 首先计算出表达式的值 \r\n  * 其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结 束。 \r\n  * 最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。 \r\n\r\n### 1.2 switch案例-减肥计划\r\n\r\n* 需求：键盘录入星期数，显示今天的减肥活动\r\n\r\n```\r\n周一：跑步  \r\n周二：游泳  \r\n周三：慢走  \r\n周四：动感单车\r\n周五：拳击  \r\n周六：爬山  \r\n周日：好好吃一顿 \r\n```\r\n\r\n* 示例代码：\r\n\r\n```java\r\npublic static void main(String[] args){\r\n\t\t// 1. 键盘录入星期数据，使用变量接收\r\n\t\tScanner sc = new Scanner(System.in);\r\n\t\tSystem.out.println("请输入");\r\n\t\tint week = sc.nextInt();\r\n\t\t// 2. 多情况判断，采用switch语句实现\r\n\t\tswitch(week){\r\n\t\t\t// 3. 在不同的case中，输出对应的减肥计划\r\n\t\t\tcase 1:\r\n\t\t\t\tSystem.out.println("跑步");\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tSystem.out.println("游泳");\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tSystem.out.println("慢走");\r\n\t\t\t\tbreak;\r\n\t\t\tcase 4:\r\n\t\t\t\tSystem.out.println("动感单车");\r\n\t\t\t\tbreak;\r\n\t\t\tcase 5:\r\n\t\t\t\tSystem.out.println("拳击");\r\n\t\t\t\tbreak;\r\n\t\t\tcase 6:\r\n\t\t\t\tSystem.out.println("爬山");\r\n\t\t\t\tbreak;\r\n\t\t\tcase 7:\r\n\t\t\t\tSystem.out.println("好好吃一顿");\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tSystem.out.println("您的输入有误");\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n### 1.3 switch语句case穿透\r\n\r\n- 概述 : 如果switch语句中,case省略了break语句, 就会开始case穿透\r\n- 需求 : 键盘录入星期数，输出工作日、休息日 (1-5)工作日，(6-7)休息日\r\n- 示例代码：\r\n\r\n```java\r\n/*\r\ncase穿透是如何产生的?\r\n\t\t\r\n\t\t如果switch语句中,case省略了break语句, 就会开始case穿透.\r\n\t\t\r\n\t\t现象：\r\n\t\t\t当开始case穿透，后续的case就不会具有匹配效果，内部的语句都会执行\r\n\t\t\t直到看见break，或者将整体switch语句执行完毕，才会结束。\r\n*/\r\npublic static void main(String[] args){\r\n\t\tScanner sc = new Scanner(System.in);\r\n\t\tSystem.out.println("请输入星期数:");\r\n\t\tint week = sc.nextInt();\r\n\t\t\r\n\t\tswitch(week){\r\n\t\t\tcase 1:\r\n\t\t\tcase 2:\r\n\t\t\tcase 3:\r\n\t\t\tcase 4:\r\n\t\t\tcase 5:\r\n\t\t\t\tSystem.out.println("工作日");\r\n\t\t\t\tbreak;\r\n\t\t\tcase 6:\r\n\t\t\tcase 7:\r\n\t\t\t\tSystem.out.println("休息日");\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tSystem.out.println("您的输入有误");\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\t\r\n}\r\n```\r\n## 2. for循环\r\n\r\n### 2.1 循环语句-for循环\r\n\r\n* 循环：\r\n\r\n  循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复 执行这个循环体时，需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形 成死循环。 \r\n\r\n* for循环格式：\r\n\r\n```java\r\nfor (初始化语句;条件判断语句;条件控制语句) {\r\n\t循环体语句;\r\n}\r\n```\r\n\r\n* 格式解释：\r\n\r\n  * 初始化语句：  用于表示循环开启时的起始状态，简单说就是循环开始的时候什么样\r\n  * 条件判断语句：用于表示循环反复执行的条件，简单说就是判断循环是否能一直执行下去\r\n  * 循环体语句：  用于表示循环反复执行的内容，简单说就是循环反复执行的事情\r\n  * 条件控制语句：用于表示循环执行中每次变化的内容，简单说就是控制循环是否能执行下去\r\n\r\n* 执行流程：\r\n\r\n  ①执行初始化语句\r\n\r\n  ②执行条件判断语句，看其结果是true还是false\r\n\r\n  ​             如果是false，循环结束\r\n\r\n  ​             如果是true，继续执行\r\n\r\n  ③执行循环体语句\r\n\r\n  ④执行条件控制语句\r\n\r\n  ⑤回到②继续\r\n\r\n### 2.2 for循环案例-输出数据1-5和5-1\r\n\r\n* 需求：在控制台输出1-5和5-1的数据 \r\n* 示例代码：\r\n\r\n```java\r\npublic class ForTest01 {\r\n    public static void main(String[] args) {\r\n\t\t//需求：输出数据1-5\r\n        for(int i=1; i<=5; i++) {\r\n\t\t\tSystem.out.println(i);\r\n\t\t}\r\n\t\tSystem.out.println("--------");\r\n\t\t//需求：输出数据5-1\r\n\t\tfor(int i=5; i>=1; i--) {\r\n\t\t\tSystem.out.println(i);\r\n\t\t}\r\n    }\r\n}\r\n```\r\n\r\n### 2.3 for循环案例-求1-5数据和\r\n\r\n* 需求：求1-5之间的数据和，并把求和结果在控制台输出 \r\n* 示例代码：\r\n\r\n```java\r\npublic class ForTest02 {\r\n    public static void main(String[] args) {\r\n\t\t//求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0\r\n\t\tint sum = 0;\r\n\t\t//从1开始到5结束的数据，使用循环结构完成\r\n\t\tfor(int i=1; i<=5; i++) {\r\n\t\t\t//将反复进行的事情写入循环结构内部\r\n             // 此处反复进行的事情是将数据 i 加到用于保存最终求和的变量 sum 中\r\n\t\t\tsum += i;\r\n\t\t\t/*\r\n\t\t\t\tsum += i;\tsum = sum + i;\r\n\t\t\t\t第一次：sum = sum + i = 0 + 1 = 1;\r\n\t\t\t\t第二次：sum = sum + i = 1 + 2 = 3;\r\n\t\t\t\t第三次：sum = sum + i = 3 + 3 = 6;\r\n\t\t\t\t第四次：sum = sum + i = 6 + 4 = 10;\r\n\t\t\t\t第五次：sum = sum + i = 10 + 5 = 15;\r\n\t\t\t*/\r\n\t\t}\r\n\t\t//当循环执行完毕时，将最终数据打印出来\r\n\t\tSystem.out.println("1-5之间的数据和是：" + sum);\r\n    }\r\n}\r\n```\r\n\r\n* 本题要点：\r\n  * 今后遇到的需求中，如果带有求和二字，请立即联想到求和变量\r\n  * 求和变量的定义位置，必须在循环外部，如果在循环内部则计算出的数据将是错误的\r\n\r\n### 2.4 for循环案例-求1-100偶数和\r\n\r\n* 需求：求1-100之间的偶数和，并把求和结果在控制台输出 }\r\n* 示例代码：\r\n\r\n```java\r\npublic class ForTest03 {\r\n    public static void main(String[] args) {\r\n\t\t//求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0\r\n\t\tint sum = 0;\r\n\t\t//对1-100的数据求和与1-5的数据求和几乎完全一样，仅仅是结束条件不同\r\n\t\tfor(int i=1; i<=100; i++) {\r\n\t\t\t//对1-100的偶数求和，需要对求和操作添加限制条件，判断是否是偶数\r\n\t\t\tif(i%2 == 0) {\r\n\t\t\t\tsum += i;\r\n\t\t\t}\r\n\t\t}\r\n\t\t//当循环执行完毕时，将最终数据打印出来\r\n\t\tSystem.out.println("1-100之间的偶数和是：" + sum);\r\n    }\r\n}\r\n```\r\n\r\n### 2.5 for循环案例-水仙花数\r\n\r\n* 需求：在控制台输出所有的“水仙花数” \r\n* 解释：什么是水仙花数？\r\n  * 水仙花数，指的是一个三位数，个位、十位、百位的数字立方和等于原数\r\n    * 例如`153  3*3*3 + 5*5*5 + 1*1*1 = 153`\r\n* 思路：\r\n  1. 获取所有的三位数，准备进行筛选，最小的三位数为100，最大的三位数为999，使用for循环获取\r\n  2. 获取每一个三位数的个位，十位，百位，做if语句判断是否是水仙花数\r\n* 示例代码\r\n\r\n```java\r\npublic class ForTest04 {\r\n    public static void main(String[] args) {\r\n\t\t//输出所有的水仙花数必然要使用到循环，遍历所有的三位数，三位数从100开始，到999结束\r\n\t\tfor(int i=100; i<1000; i++) {\r\n\t\t\t//在计算之前获取三位数中每个位上的值\r\n\t\t\tint ge = i%10;\r\n\t\t\tint shi = i/10%10;\r\n\t\t\tint bai = i/10/10%10;\r\n\t\t\t\r\n\t\t\t//判定条件是将三位数中的每个数值取出来，计算立方和后与原始数字比较是否相等\r\n\t\t\tif(ge*ge*ge + shi*shi*shi + bai*bai*bai == i) {\r\n\t\t\t\t//输出满足条件的数字就是水仙花数\r\n\t\t\t\tSystem.out.println(i);\r\n\t\t\t}\r\n\t\t}\r\n    }\r\n}\r\n```\r\n\r\n### 2.6 for循环案例-每行打印2个水仙花数(统计)\r\n\r\n* 需求：在控制台输出所有的“水仙花数”，要求每行打印2个\r\n* 示例代码：\r\n\r\n```java\r\npublic class Demo6For {\r\n\t/*\r\n\t\t需求：在控制台输出所有的“水仙花数”，要求每行打印2个\r\n\r\n\t\tSystem.out.print (打印内容);\t打印后不换行\r\n\t\tSystem.out.println(打印内容);\t打印后换行\r\n\r\n\t\t分析:\r\n\t\t\t\r\n\t\t\t1. 定义变量count，用于保存“打印过”的数量，初始值为0\r\n\t\t\t2. 在判定和打印水仙花数的过程中，拼接空格, 但不换行，并在打印后让count变量+1，记录打印过的数量\r\n\t\t\t3. 在每一次count变量+1后，判断是否到达了2的倍数，是的话，换行。\r\n\r\n\t*/\r\n\tpublic static void main(String[] args){\r\n\t\t// 1. 定义变量count，用于保存“打印过”的数量，初始值为0\r\n\t\tint count = 0;\r\n\t\tfor(int i = 100; i <= 999; i++){\r\n\t\t\tint ge = i % 10;\r\n\t\t\tint shi = i / 10 % 10;\r\n\t\t\tint bai = i / 10 / 10 % 10;\r\n\t\t\t\r\n\t\t\tif(\t(ge*ge*ge + shi*shi*shi + bai*bai*bai) == i){\r\n\t\t\t\t//  2. 在判定和打印水仙花数的过程中，拼接空格, 但不换行，并在打印后让count变量+1，记录打印过的数量\r\n\t\t\t\tSystem.out.print(i + " ");\r\n\t\t\t\tcount++;\r\n\t\t\t\t// 3. 在每一次count变量+1后，判断是否到达了2的倍数，是的话，换行\r\n\t\t\t\tif(count % 2 == 0){\r\n\t\t\t\t\tSystem.out.println();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n* 本题要点：\r\n  * 今后如果需求带有统计xxx，请先想到计数器变量\r\n  * 计数器变量定义的位置，必须在循环外部\r\n\r\n## 3. while循环\r\n\r\n### 3.1 循环语句-while循环\r\n\r\n* while循环完整格式：\r\n\r\n  ```java\r\n  初始化语句;\r\n  while (条件判断语句) {\r\n  \t循环体语句;\r\n      条件控制语句;\r\n  }\r\n  ```\r\n\r\n* while循环执行流程：\r\n\r\n  ①执行初始化语句\r\n\r\n  ②执行条件判断语句，看其结果是true还是false\r\n\r\n  ​             如果是false，循环结束\r\n\r\n  ​             如果是true，继续执行\r\n\r\n  ③执行循环体语句\r\n\r\n  ④执行条件控制语句\r\n\r\n  ⑤回到②继续\r\n\r\n* 示例代码：\r\n\r\n```java\r\npublic class WhileDemo {\r\n    public static void main(String[] args) {\r\n        //需求：在控制台输出5次"HelloWorld"\r\n\t\t//for循环实现\r\n\t\tfor(int i=1; i<=5; i++) {\r\n\t\t\tSystem.out.println("HelloWorld");\r\n\t\t}\r\n\t\tSystem.out.println("--------");\r\n\t\t//while循环实现\r\n\t\tint j = 1;\r\n\t\twhile(j<=5) {\r\n\t\t\tSystem.out.println("HelloWorld");\r\n\t\t\tj++;\r\n\t\t}\r\n    }\r\n}\r\n```\r\n\r\n### 3.2 while循环案例-珠穆朗玛峰\r\n\r\n* 需求：世界最高山峰是珠穆朗玛峰(8844.43米=8844430毫米)，假如我有一张足够大的纸，它的厚度是0.1毫米。请问，我折叠多少次，可以折成珠穆朗玛峰的高度?\r\n* 示例代码：\r\n\r\n```java\r\npublic class WhileTest {\r\n    public static void main(String[] args) {\r\n\t\t//定义一个计数器，初始值为0\r\n\t\tint count = 0;\r\n\t\t//定义纸张厚度\r\n\t\tdouble paper = 0.1;\r\n\t\t//定义珠穆朗玛峰的高度\r\n\t\tint zf = 8844430;\r\n\t\t//因为要反复折叠，所以要使用循环，但是不知道折叠多少次，这种情况下更适合使用while循环\r\n\t\t//折叠的过程中当纸张厚度大于珠峰就停止了，因此继续执行的要求是纸张厚度小于珠峰高度\r\n\t\twhile(paper <= zf) {\r\n\t\t\t//循环的执行过程中每次纸张折叠，纸张的厚度要加倍\r\n\t\t\tpaper *= 2;\r\n\t\t\t//在循环中执行累加，对应折叠了多少次\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\t//打印计数器的值\r\n\t\tSystem.out.println("需要折叠：" + count + "次");\r\n    }\r\n}\r\n```\r\n\r\n## 4. 循环细节\r\n\r\n### 4.1 循环语句-dowhile循环\r\n\r\n* 完整格式：\r\n\r\n  ```java\r\n  初始化语句;\r\n  do {\r\n  \t循环体语句;\r\n  \t条件控制语句;\r\n  }while(条件判断语句);\r\n  ```\r\n\r\n* 执行流程：\r\n\r\n  ① 执行初始化语句\r\n\r\n  ② 执行循环体语句\r\n\r\n  ③ 执行条件控制语句\r\n\r\n  ④ 执行条件判断语句，看其结果是true还是false\r\n\r\n  如果是false，循环结束\r\n\r\n  如果是true，继续执行\r\n\r\n  ⑤ 回到②继续\r\n\r\n* 示例代码：\r\n\r\n```java\r\npublic class DoWhileDemo {\r\n    public static void main(String[] args) {\r\n        //需求：在控制台输出5次"HelloWorld"\r\n\t\t//for循环实现\r\n\t\tfor(int i=1; i<=5; i++) {\r\n\t\t\tSystem.out.println("HelloWorld");\r\n\t\t}\r\n\t\tSystem.out.println("--------");\r\n\t\t//do...while循环实现\r\n\t\tint j = 1;\r\n\t\tdo {\r\n\t\t\tSystem.out.println("HelloWorld");\r\n\t\t\tj++;\r\n\t\t}while(j<=5);\r\n    }\r\n}\r\n```\r\n\r\n### 4.2 三种循环的区别\r\n\r\n* 三种循环的区别\r\n  * for循环和while循环先判断条件是否成立，然后决定是否执行循环体（先判断后执行）\r\n  * do...while循环先执行一次循环体，然后判断条件是否成立，是否继续执行循环体（先执行后判断）\r\n* for循环和while的区别\r\n  * 条件控制语句所控制的自增变量，因为归属for循环的语法结构中，在for循环结束后，就不能再次被访问到了\r\n  * 条件控制语句所控制的自增变量，对于while循环来说不归属其语法结构中，在while循环结束后，该变量还可以继续使用\r\n* 死循环（无限循环）的三种格式\r\n  1. for(;;){}\r\n  2. while(true){}\r\n  3. do {} while(true);\r\n\r\n### 4.3 死循环\r\n\r\n- 死循环格式\t\t\r\n\r\n  ```\r\n  for死循环格式 :\r\n  for(;;){\r\n  \r\n  }\r\n  \r\n  while死循环格式 :\r\n  \r\n  while(true){\r\n  \r\n  }\r\n  \r\n  do..while死循环格式 :\r\n  \r\n  do{\r\n  \r\n  }while(true);\r\n  ```\r\n\r\n- 死循环案例\r\n\r\n```java\r\n/*\r\n\t问题: 死循环有应用场景吗?\r\n\t\t\r\n\t\t\t\t例如: 键盘录入一个1-100之间的整数\r\n\t\t\t\t\r\n\t\t\t\t顾虑: 键盘录入是用户操作的, 用户就可能会出现一些误操作的现象\r\n\t\t\r\n*/\r\npublic static void main(String[] args) {\r\n    /*\r\n\t\tfor(;;){\r\n\t\t\tSystem.out.println("我停不下来了~");\r\n\t\t}\r\n\t\t*/\r\n\r\n    /*\r\n\t\twhile(true){\r\n\t\t\tSystem.out.println("我停不下来了~");\r\n\t\t}\r\n\t\t*/\r\n\r\n    do{\r\n        System.out.println("我停不下来了~");\t\r\n    }while(true);\r\n\r\n    System.out.println("看看我能被执行吗?~");\t// 无法访问的语句\r\n}\r\n}\r\n```\r\n\r\n\r\n\r\n### 4.4 跳转控制语句\r\n\r\n* 跳转控制语句（break）\r\n  * 跳出循环，结束循环\r\n* 跳转控制语句（continue）\r\n  * 跳过本次循环，继续下次循环\r\n* 注意： continue只能在循环中进行使用！\r\n\r\n```java\r\npublic class Demo1Continue {\r\n\t/*\r\n\t\tcontinue : 跳过某次循环体内容的执行\r\n\t\t\r\n\t\t注意：使用是基于条件控制, 在循环内部使用.\r\n\t\t\r\n\t\t需求: 模拟电梯上行的过程 1-24层, 4层不停.\r\n\t*/\r\n\tpublic static void main(String[] args){\r\n\t\tfor(int i = 1; i <= 24; i++){\r\n\t\t\tif(i == 4){\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tSystem.out.println(i + "层到了~");\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\n```\r\n\r\n```java\r\npublic class Demo2Break {\r\n\t/*\r\n\t\tbreak : 终止循环体内容的执行\r\n\t\t注意：使用是基于条件控制的\r\n\t\t\t\tbreak语句只能在循环和switch中进行使用.\r\n\t\t\t\t\r\n\t\t需求: 模拟20岁工作到80岁, 60岁退休.\r\n\t*/\r\n\tpublic static void main(String[] args){\r\n\t\tfor(int i = 20; i <= 80; i++){\r\n\t\t\tif(i == 60){\r\n\t\t\t\tbreak;\t\t// 结束整个循环\r\n\t\t\t}\r\n\t\t\tSystem.out.println(i + "岁正在上班");\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\n```\r\n\r\n```java\r\nimport java.util.Scanner;\r\n\r\npublic class Test {\r\n\t/*\r\n\t\t需求：程序运行后，用户可多次查询星期对应的减肥计划，直到输入0，程序结束\r\n\t\t\r\n\t\t步骤:\r\n\t\t\t\r\n\t\t\t1. 不明确用户操作几次, 使用死循环包裹业务逻辑\r\n\t\t\t2. 匹配到0的时候，使用break结束循环死循环\r\n\r\n\t*/\r\n\tpublic static void main (String[] args){\r\n\t\t\r\n\t\tlo:while(true){\r\n\t\t\tSystem.out.println("请输入您要查看的星期数:");\r\n\t\t\tSystem.out.println("(如无需继续查看,请输入0退出程序)");\r\n\t\t\t\r\n\t\t\t// 1. 键盘录入星期数据，使用变量接收\r\n\t\t\tScanner sc = new Scanner(System.in);\r\n\t\t\tint week = sc.nextInt();\r\n\t\t\t// 2. 多情况判断，采用switch语句实现\r\n\t\t\tswitch(week){\r\n\t\t\t\t// 3. 在不同的case中，输出对应的减肥计划\r\n\t\t\t\tcase 0:\r\n\t\t\t\t\tSystem.out.println("感谢您的使用");\r\n\t\t\t\t\tbreak lo;\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\tSystem.out.println("跑步");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\tSystem.out.println("游泳");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 3:\r\n\t\t\t\t\tSystem.out.println("慢走");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 4:\r\n\t\t\t\t\tSystem.out.println("动感单车");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 5:\r\n\t\t\t\t\tSystem.out.println("拳击");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 6:\r\n\t\t\t\t\tSystem.out.println("爬山");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 7:\r\n\t\t\t\t\tSystem.out.println("好好吃一顿");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tSystem.out.println("您的输入有误");\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t}\r\n}\r\n```\r\n\r\n\r\n\r\n## 5. Random\r\n\r\n### 5.1 Random产生随机数（掌握）\r\n\r\n* 概述：\r\n\r\n  * Random类似Scanner，也是Java提供好的API，内部提供了产生随机数的功能\r\n    * API后续课程详细讲解，现在可以简单理解为Java已经写好的代码\r\n\r\n* 使用步骤：\r\n\r\n  1. 导入包\r\n\r\n     import java.util.Random;\r\n\r\n  2. 创建对象\r\n\r\n     Random r = new Random();\r\n\r\n  3. 产生随机数\r\n\r\n     int num = r.nextInt(10);\r\n\r\n     解释： 10代表的是一个范围，如果括号写10，产生的随机数就是0-9，括号写20，参数的随机数则是0-19\r\n\r\n* 示例代码：\r\n\r\n```java\r\nimport java.util.Random;\r\n\r\npublic class Demo1Random {\r\n\t/*\r\n\t\tRandom : 产生随机数\r\n\t\t\r\n\t\t1. 导包\t: import java.util.Random;\r\n\t\t\t\t    导包的动作必须出现在类定义的上面\r\n\r\n\t\t2. 创建对象 : Random r = new Random();\r\n\t\t\t\t\t上面这个格式里面，r 是变量名，可以变，其他的都不允许变\r\n\r\n\t\t3. 获取随机数 : int number = r.nextInt(10);\t//获取数据的范围：[0,10) 包括0,不包括10\r\n\t\t\t\t\t上面这个格式里面，number是变量名，可以变，数字10可以变。其他的都不允许变\r\n\t\t\r\n\t\t需求: 产生随机数1-10之间的\r\n\t*/\r\n\tpublic static void main(String[] args){\r\n\t\t// 2. 创建对象\r\n\t\tRandom r = new Random();\r\n\t\t\r\n\t\tfor(int i = 1; i <= 10; i++){\r\n\t\t\t// 3. 获取随机数\r\n\t\t\tint num = r.nextInt(10) + 1;\t\t// 1-10\r\n\t\t\tSystem.out.println(num);\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t}\r\n}\r\n```\r\n\r\n### 5.3 Random练习-猜数字（应用）\r\n\r\n* 需求：\r\n\r\n  程序自动生成一个1-100之间的数字，使用程序实现猜出这个数字是多少？\r\n\r\n  当猜错的时候根据不同情况给出相应的提示\r\n\r\n  A. 如果猜的数字比真实数字大，提示你猜的数据大了\r\n\r\n  B. 如果猜的数字比真实数字小，提示你猜的数据小了\r\n\r\n  C. 如果猜的数字与真实数字相等，提示恭喜你猜中了\r\n\r\n* 示例代码：\r\n\r\n```java\r\nimport java.util.Scanner;\r\nimport java.util.Random;\r\n\r\npublic class Test {\r\n\t/*\r\n\t\t需求：程序自动生成一个1-100之间的数字，使用程序实现猜出这个数字是多少？\r\n\t\t\t当猜错的时候根据不同情况给出相应的提示\r\n\t\t\t如果猜的数字比真实数字大，提示你猜的数据大了\r\n\t\t\t如果猜的数字比真实数字小，提示你猜的数据小了\r\n\t\t\t如果猜的数字与真实数字相等，提示恭喜你猜中了\r\n\t\t\r\n\t\t1. 准备Random和Scanner对象, 分别用于产生随机数和键盘录入\r\n\t\t2. 使用Random产生一个1-100之间的数, 作为要猜的数\r\n\t\t3. 键盘录入用户猜的的数据\r\n\t\t4. 使用录入的数据(用户猜的数据)和随机数(要猜的数据)进行比较, 并给出提示\r\n\t\t\r\n\t\t5. 以上内容需要多次进行, 但无法预估用户输入几次可以猜测正确, 使用while(true)死循环包裹\r\n\t\t6. 猜对之后, break结束.\r\n\r\n\t*/\r\n\tpublic static void main(String[] args){\r\n\t\t// 1. 准备Random和Scanner对象, 分别用于产生随机数和键盘录入\r\n\t\tRandom r = new Random();\r\n\t\tScanner sc = new Scanner(System.in);\r\n\t\t// 2. 使用Random产生一个1-100之间的数, 作为要猜的数\r\n\t\tint randomNum = r.nextInt(100) + 1;\r\n\t\t\r\n\t\t// 5. 以上内容需要多次进行, 但无法预估用户输入几次可以猜测正确, 使用while(true)死循环包裹\r\n\t\twhile(true){\r\n\t\t\t// 3. 键盘录入用户猜的的数据\r\n\t\t\tSystem.out.println("请输入您猜的数据:");\r\n\t\t\tint num = sc.nextInt();\r\n\t\t\t// 4. 使用录入的数据(用户猜的数据)和随机数(要猜的数据)进行比较, 并给出提示\r\n\t\t\tif(num > randomNum){\r\n\t\t\t\tSystem.out.println("猜大了");\r\n\t\t\t}else if(num < randomNum){\r\n\t\t\t\tSystem.out.println("猜小了");\r\n\t\t\t}else{\r\n\t\t\t\t// 6. 猜对之后, break结束.\r\n\t\t\t\tSystem.out.println("恭喜,猜中了");\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println("感谢您的使用");\r\n\t\t\r\n\t}\r\n}\r\n```\r\n\r\n'},c097:function(n,e,t){"use strict";t.r(e),e["default"]="# 消息队列其实很简单\n\n“RabbitMQ？”“Kafka？”“RocketMQ？”...在日常学习与开发过程中，我们常常听到消息队列这个关键词。我也在我的多篇文章中提到了这个概念。可能你是熟练使用消息队列的老手，又或者你是不懂消息队列的新手，不论你了不了解消息队列，本文都将带你搞懂消息队列的一些基本理论。如果你是老手，你可能从本文学到你之前不曾注意的一些关于消息队列的重要概念，如果你是新手，相信本文将是你打开消息队列大门的一板砖。\n\n## 一 什么是消息队列\n\n我们可以把消息队列看作是一个存放消息的容器，当我们需要使用消息的时候，直接从容器中取出消息供自己使用即可。\n\n![Message queue](message-queue.assets/message-queue-small.png)\n\n消息队列是分布式系统中重要的组件之一。使用消息队列主要是为了通过异步处理提高系统性能和削峰、降低系统耦合性。\n\n我们知道队列 Queue 是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。\n\n## 二 为什么要用消息队列\n\n通常来说，使用消息队列能为我们的系统带来下面三点好处：\n\n1. **通过异步处理提高系统性能（减少响应所需时间）。**\n2. **削峰/限流**\n3. **降低系统耦合性。**\n\n如果在面试的时候你被面试官问到这个问题的话，一般情况是你在你的简历上涉及到消息队列这方面的内容，这个时候推荐你结合你自己的项目来回答。\n\n《大型网站技术架构》第四章和第七章均有提到消息队列对应用性能及扩展性的提升。\n\n### 2.1 通过异步处理提高系统性能（减少响应所需时间）\n\n![通过异步处理提高系统性能](message-queue.assets/Asynchronous-message-queue.png)\n\n将用户的请求数据存储到消息队列之后就立即返回结果。随后，系统再对消息进行消费。\n\n因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此，**使用消息队列进行异步处理之后，需要适当修改业务流程进行配合**，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票。\n\n### 2.2 削峰/限流\n\n**先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉。**\n\n举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：\n\n![削峰](message-queue.assets/削峰-消息队列.png)\n\n### 2.3 降低系统耦合性\n\n使用消息队列还可以降低系统耦合性。我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。还是直接上图吧：\n\n![解耦](message-queue.assets/消息队列-解耦.png)\n\n生产者（客户端）发送消息到消息队列中去，接受者（服务端）处理消息，需要消费的系统直接去消息队列取消息进行消费即可而不需要和其他系统有耦合，这显然也提高了系统的扩展性。\n\n**消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。** 从上图可以看到**消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合**，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。**对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计**。\n\n消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。\n\n另外，为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。\n\n**备注：** 不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的。除了发布-订阅模式，还有点对点订阅模式（一个消息只有一个消费者），我们比较常用的是发布-订阅模式。另外，这两种消息模型是 JMS 提供的，AMQP 协议还提供了 5 种消息模型。\n\n## 三 使用消息队列带来的一些问题\n\n- **系统可用性降低：** 系统可用性在某种程度上降低，为什么这样说呢？在加入 MQ 之前，你不用考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引入 MQ 之后你就需要去考虑了！\n- **系统复杂性提高：** 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！\n- **一致性问题：** 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!\n\n## 四 JMS VS AMQP\n\n### 4.1 JMS\n\n#### 4.1.1 JMS 简介\n\nJMS（JAVA Message Service,java 消息服务）是 java 的消息服务，JMS 的客户端之间可以通过 JMS 服务进行异步的消息传输。**JMS（JAVA Message Service，Java 消息服务）API 是一个消息服务的标准或者说是规范**，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。\n\n**ActiveMQ 就是基于 JMS 规范实现的。**\n\n#### 4.1.2 JMS 两种消息模型\n\n**① 点到点（P2P）模型**\n\n\n\n使用**队列（Queue）**作为消息通信载体；满足**生产者与消费者模式**，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。比如：我们生产者发送 100 条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）\n\n**② 发布/订阅（Pub/Sub）模型**\n\n\n\n发布订阅模型（Pub/Sub） 使用**主题（Topic）**作为消息通信载体，类似于**广播模式**；发布者发布一条消息，该消息通过主题传递给所有的订阅者，**在一条消息广播之后才订阅的用户则是收不到该条消息的**。\n\n#### 4.1.3 JMS 五种不同的消息正文格式\n\nJMS 定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。\n\n- StreamMessage -- Java 原始值的数据流\n- MapMessage--一套名称-值对\n- TextMessage--一个字符串对象\n- ObjectMessage--一个序列化的 Java 对象\n- BytesMessage--一个字节的数据流\n\n### 4.2 AMQP\n\nAMQP，即 Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准 **高级消息队列协议**（二进制应用层协议），是应用层协议的一个开放标准，为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。\n\n**RabbitMQ 就是基于 AMQP 协议实现的。**\n\n### 4.3 JMS vs AMQP\n\n| 对比方向     | JMS                                     | AMQP                                                         |\n| :----------- | :-------------------------------------- | :----------------------------------------------------------- |\n| 定义         | Java API                                | 协议                                                         |\n| 跨语言       | 否                                      | 是                                                           |\n| 跨平台       | 否                                      | 是                                                           |\n| 支持消息类型 | 提供两种消息模型：①Peer-2-Peer;②Pub/sub | 提供了五种消息模型：①direct exchange；②fanout exchange；③topic change；④headers exchange；⑤system exchange。本质来讲，后四种和 JMS 的 pub/sub 模型没有太大差别，仅是在路由机制上做了更详细的划分； |\n| 支持消息类型 | 支持多种消息类型 ，我们在上面提到过     | byte[]（二进制）                                             |\n\n**总结：**\n\n- AMQP 为消息定义了线路层（wire-level protocol）的协议，而 JMS 所定义的是 API 规范。在 Java 体系中，多个 client 均可以通过 JMS 进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而 AMQP 天然具有跨平台、跨语言特性。\n- JMS 支持 TextMessage、MapMessage 等复杂的消息类型；而 AMQP 仅支持 byte[] 消息类型（复杂的类型可序列化后发送）。\n- 由于 Exchange 提供的路由算法，AMQP 可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队列 和 主题/订阅 方式两种。\n\n## 五 常见的消息队列对比\n\n| 对比方向 | 概要                                                         |\n| -------- | ------------------------------------------------------------ |\n| 吞吐量   | 万级的 ActiveMQ 和 RabbitMQ 的吞吐量（ActiveMQ 的性能最差）要比 十万级甚至是百万级的 RocketMQ 和 Kafka 低一个数量级。 |\n| 可用性   | 都可以实现高可用。ActiveMQ 和 RabbitMQ 都是基于主从架构实现高可用性。RocketMQ 基于分布式架构。 kafka 也是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用 |\n| 时效性   | RabbitMQ 基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。其他三个都是 ms 级。 |\n| 功能支持 | 除了 Kafka，其他三个功能都较为完备。 Kafka 功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准 |\n| 消息丢失 | ActiveMQ 和 RabbitMQ 丢失的可能性非常低， RocketMQ 和 Kafka 理论上不会丢失。 |\n\n**总结：**\n\n- ActiveMQ 的社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，不推荐使用。\n- RabbitMQ 在吞吐量方面虽然稍逊于 Kafka 和 RocketMQ ，但是由于它基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 erlang 开发，所以国内很少有公司有实力做 erlang 源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这四种消息队列中，RabbitMQ 一定是你的首选。如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。\n- RocketMQ 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的 MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。RocketMQ 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用 RocketMQ 挺好的\n- Kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。\n\n参考：《Java 工程师面试突击第 1 季-中华石杉老师》"},c1c7:function(n,e,t){"use strict";t.r(e),e["default"]='> 本文基于 Spring Cloud Netflix 。Spring Cloud Alibaba 也是非常不错的选择哦！\n>\n> 授权转载自：https://juejin.im/post/5de2553e5188256e885f4fa3\n\n\n\n首先我给大家看一张图，如果大家对这张图有些地方不太理解的话，我希望你们看完我这篇文章会恍然大悟。\n\n![Spring Cloud 总体架构](spring-cloud.assets/spring-cloud总体架构.jpg)\n\n## 什么是Spring cloud\n\n> 构建分布式系统不需要复杂和容易出错。Spring Cloud 为最常见的分布式系统模式提供了一种简单且易于接受的编程模型，帮助开发人员构建有弹性的、可靠的、协调的应用程序。Spring Cloud 构建于 Spring Boot 之上，使得开发者很容易入手并快速应用于生产中。\n\n官方果然官方，介绍都这么有板有眼的。\n\n我所理解的 `Spring Cloud` 就是微服务系统架构的一站式解决方案，在平时我们构建微服务的过程中需要做如 **服务发现注册** 、**配置中心** 、**消息总线** 、**负载均衡** 、**断路器** 、**数据监控** 等操作，而 Spring Cloud 为我们提供了一套简易的编程模型，使我们能在 Spring Boot 的基础上轻松地实现微服务项目的构建。\n\n## Spring Cloud 的版本\n\n当然这个只是个题外话。\n\n`Spring Cloud` 的版本号并不是我们通常见的数字版本号，而是一些很奇怪的单词。这些单词均为英国伦敦地铁站的站名。同时根据字母表的顺序来对应版本时间顺序，比如：最早 的 `Release` 版本 `Angel`，第二个 `Release` 版本 `Brixton`（英国地名），然后是 `Camden`、 `Dalston`、`Edgware`、`Finchley`、`Greenwich`、`Hoxton`。\n\n## Spring Cloud 的服务发现框架——Eureka\n\n> `Eureka`是基于`REST`（代表性状态转移）的服务，主要在 `AWS` 云中用于定位服务，以实现负载均衡和中间层服务器的故障转移。我们称此服务为`Eureka`服务器。Eureka还带有一个基于 `Java` 的客户端组件 `Eureka Client`，它使与服务的交互变得更加容易。客户端还具有一个内置的负载平衡器，可以执行基本的循环负载平衡。在 `Netflix`，更复杂的负载均衡器将 `Eureka` 包装起来，以基于流量，资源使用，错误条件等多种因素提供加权负载均衡，以提供出色的弹性。\n\n总的来说，`Eureka` 就是一个服务发现框架。何为服务，何又为发现呢？\n\n举一个生活中的例子，就比如我们平时租房子找中介的事情。\n\n在没有中介的时候我们需要一个一个去寻找是否有房屋要出租的房东，这显然会非常的费力，一你找凭一个人的能力是找不到很多房源供你选择，再者你也懒得这么找下去(找了这么久，没有合适的只能将就)。**这里的我们就相当于微服务中的 `Consumer` ，而那些房东就相当于微服务中的 `Provider` 。消费者 `Consumer` 需要调用提供者 `Provider` 提供的一些服务，就像我们现在需要租他们的房子一样。**\n\n但是如果只是租客和房东之间进行寻找的话，他们的效率是很低的，房东找不到租客赚不到钱，租客找不到房东住不了房。所以，后来房东肯定就想到了广播自己的房源信息(比如在街边贴贴小广告)，这样对于房东来说已经完成他的任务(将房源公布出去)，但是有两个问题就出现了。第一、其他不是租客的都能收到这种租房消息，这在现实世界没什么，但是在计算机的世界中就会出现 **资源消耗** 的问题了。第二、租客这样还是很难找到你，试想一下我需要租房，我还需要东一个西一个地去找街边小广告，麻不麻烦？\n\n那怎么办呢？我们当然不会那么傻乎乎的，第一时间就是去找 **中介** 呀，它为我们提供了统一房源的地方，我们消费者只需要跑到它那里去找就行了。而对于房东来说，他们也只需要把房源在中介那里发布就行了。\n\n\n\n那么现在，我们的模式就是这样的了。\n\n![](spring-cloud.assets/24382ce6bbd44932ac38b1accade12d1-new-image2ff8affc-6f1d-49de-a8c3-801e7bad2b11.png)\n\n但是，这个时候还会出现一些问题。\n\n1. 房东注册之后如果不想卖房子了怎么办？我们是不是需要让房东 **定期续约** ？如果房东不进行续约是不是要将他们从中介那里的注册列表中 **移除** 。\n2. 租客是不是也要进行 **注册** 呢？不然合同乙方怎么来呢？\n3. 中介可不可以做 **连锁店** 呢？如果这一个店因为某些不可抗力因素而无法使用，那么我们是否可以换一个连锁店呢？\n\n针对上面的问题我们来重新构建一下上面的模式图\n\n![租房-中介模式图](spring-cloud.assets/租房-中介模式图.jpg)\n\n好了，举完这个:chestnut:我们就可以来看关于 `Eureka` 的一些基础概念了，你会发现这东西理解起来怎么这么简单。:punch::punch::punch:\n\n**服务发现**：其实就是一个“中介”，整个过程中有三个角色：**服务提供者(出租房子的)、服务消费者(租客)、服务中介(房屋中介)**。\n\n**服务提供者**： 就是提供一些自己能够执行的一些服务给外界。\n\n**服务消费者**： 就是需要使用一些服务的“用户”。\n\n**服务中介**： 其实就是服务提供者和服务消费者之间的“桥梁”，服务提供者可以把自己注册到服务中介那里，而服务消费者如需要消费一些服务(使用一些功能)就可以在服务中介中寻找注册在服务中介的服务提供者。\n\n**服务注册 Register**：\n\n官方解释：当 `Eureka` 客户端向 `Eureka Server` 注册时，它提供自身的**元数据**，比如IP地址、端口，运行状况指示符URL，主页等。\n\n结合中介理解：房东 (提供者 `Eureka Client Provider`)在中介 (服务器 `Eureka Server`) 那里登记房屋的信息，比如面积，价格，地段等等(元数据 `metaData`)。\n\n**服务续约 Renew**：\n\n官方解释：**`Eureka` 客户会每隔30秒(默认情况下)发送一次心跳来续约**。 通过续约来告知 `Eureka Server` 该 `Eureka` 客户仍然存在，没有出现问题。 正常情况下，如果 `Eureka Server` 在90秒没有收到 `Eureka` 客户的续约，它会将实例从其注册表中删除。\n\n结合中介理解：房东 (提供者 `Eureka Client Provider`) 定期告诉中介 (服务器 `Eureka Server`) 我的房子还租(续约) ，中介 (服务器`Eureka Server`) 收到之后继续保留房屋的信息。\n\n**获取注册列表信息 Fetch Registries**： \n\n官方解释：`Eureka` 客户端从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务，从而进行远程调用。该注册列表信息定期（每30秒钟）更新一次。每次返回注册列表信息可能与 `Eureka` 客户端的缓存信息不同, `Eureka` 客户端自动处理。如果由于某种原因导致注册列表信息不能及时匹配，`Eureka` 客户端则会重新获取整个注册表信息。 `Eureka` 服务器缓存注册列表信息，整个注册表以及每个应用程序的信息进行了压缩，压缩内容和没有压缩的内容完全相同。`Eureka` 客户端和 `Eureka` 服务器可以使用JSON / XML格式进行通讯。在默认的情况下 `Eureka` 客户端使用压缩 `JSON` 格式来获取注册列表的信息。\n\n结合中介理解：租客(消费者 `Eureka Client Consumer`) 去中介 (服务器 `Eureka Server`) 那里获取所有的房屋信息列表 (客户端列表 `Eureka Client List`) ，而且租客为了获取最新的信息会定期向中介 (服务器 `Eureka Server`) 那里获取并更新本地列表。\n\n**服务下线 Cancel**：\n\n官方解释：Eureka客户端在程序关闭时向Eureka服务器发送取消请求。 发送请求后，该客户端实例信息将从服务器的实例注册表中删除。该下线请求不会自动完成，它需要调用以下内容：`DiscoveryManager.getInstance().shutdownComponent();`\n\n结合中介理解：房东 (提供者 `Eureka Client Provider`) 告诉中介  (服务器 `Eureka Server`) 我的房子不租了，中介之后就将注册的房屋信息从列表中剔除。\n\n**服务剔除 Eviction**：\n\n官方解释：在默认的情况下，**当Eureka客户端连续90秒(3个续约周期)没有向Eureka服务器发送服务续约，即心跳，Eureka服务器会将该服务实例从服务注册列表删除**，即服务剔除。\n\n结合中介理解：房东(提供者 `Eureka Client Provider`) 会定期联系 中介  (服务器 `Eureka Server`) 告诉他我的房子还租(续约)，如果中介  (服务器 `Eureka Server`) 长时间没收到提供者的信息，那么中介会将他的房屋信息给下架(服务剔除)。\n\n下面就是 `Netflix` 官方给出的 `Eureka` 架构图，你会发现和我们前面画的中介图别无二致。\n\n![Eureka架构图](spring-cloud.assets/5d723c49eca1468ab7b89af06743023c-new-imageb8aa3d41-fad4-4b38-add9-c304930ab285.png)\n\n当然，可以充当服务发现的组件有很多：`Zookeeper` ，`Consul` ， `Eureka` 等。\n\n更多关于 `Eureka` 的知识(自我保护，初始注册策略等等)可以自己去官网查看，或者查看我的另一篇文章 [深入理解 Eureka](<https://juejin.im/post/5dd497e3f265da0ba7718018>)。\n\n## 负载均衡之 Ribbon\n\n### 什么是 `RestTemplate`?\n\n不是讲 `Ribbon` 么？怎么扯到了 `RestTemplate` 了？你先别急，听我慢慢道来。\n\n我不听我不听我不听:hear_no_evil::hear_no_evil::hear_no_evil:。\n\n我就说一句！**`RestTemplate`是`Spring`提供的一个访问Http服务的客户端类**，怎么说呢？就是微服务之间的调用是使用的 `RestTemplate` 。比如这个时候我们 消费者B 需要调用 提供者A 所提供的服务我们就需要这么写。如我下面的伪代码。\n\n```java\n@Autowired\nprivate RestTemplate restTemplate;\n// 这里是提供者A的ip地址，但是如果使用了 Eureka 那么就应该是提供者A的名称\nprivate static final String SERVICE_PROVIDER_A = "http://localhost:8081";\n\n@PostMapping("/judge")\npublic boolean judge(@RequestBody Request request) {\n    String url = SERVICE_PROVIDER_A + "/service1";\n    return restTemplate.postForObject(url, request, Boolean.class);\n}\n```\n 如果你对源码感兴趣的话，你会发现上面我们所讲的 `Eureka` 框架中的 **注册**、**续约** 等，底层都是使用的 `RestTemplate` 。\n\n### 为什么需要 Ribbon？\n\n`Ribbon`  是 `Netflix` 公司的一个开源的负载均衡 项目，是一个客户端/进程内负载均衡器，**运行在消费者端**。\n\n我们再举个:chestnut:，比如我们设计了一个秒杀系统，但是为了整个系统的 **高可用** ，我们需要将这个系统做一个集群，而这个时候我们消费者就可以拥有多个秒杀系统的调用途径了，如下图。\n\n<img src="spring-cloud.assets/秒杀系统-ribbon.jpg" style="zoom:50%;" />\n\n如果这个时候我们没有进行一些 **均衡操作** ，如果我们对 `秒杀系统1` 进行大量的调用，而另外两个基本不请求，就会导致 `秒杀系统1` 崩溃，而另外两个就变成了傀儡，那么我们为什么还要做集群，我们高可用体现的意义又在哪呢？\n\n所以 `Ribbon` 出现了，注意我们上面加粗的几个字——**运行在消费者端**。指的是，`Ribbon` 是运行在消费者端的负载均衡器，如下图。\n\n<img src="spring-cloud.assets/秒杀系统-ribbon2.jpg" style="zoom:50%;" />\n\n其工作原理就是 `Consumer` 端获取到了所有的服务列表之后，在其**内部**使用**负载均衡算法**，进行对多个系统的调用。\n\n### Nginx 和 Ribbon 的对比\n\n提到 **负载均衡** 就不得不提到大名鼎鼎的 `Nignx` 了，而和 `Ribbon` 不同的是，它是一种**集中式**的负载均衡器。\n\n何为集中式呢？简单理解就是 **将所有请求都集中起来，然后再进行负载均衡**。如下图。\n\n<img src="spring-cloud.assets/nginx-vs-ribbon1.jpg" style="zoom:50%;" />\n\n我们可以看到 `Nginx` 是接收了所有的请求进行负载均衡的，而对于 `Ribbon` 来说它是在消费者端进行的负载均衡。如下图。\n\n<img src="spring-cloud.assets/nginx-vs-ribbon2.jpg" style="zoom:50%;" />\n\n> 请注意 `Request` 的位置，在 `Nginx` 中请求是先进入负载均衡器，而在 `Ribbon` 中是先在客户端进行负载均衡才进行请求的。\n\n### Ribbon 的几种负载均衡算法\n\n负载均衡，不管 `Nginx` 还是 `Ribbon` 都需要其算法的支持，如果我没记错的话 `Nginx` 使用的是 轮询和加权轮询算法。而在 `Ribbon` 中有更多的负载均衡调度算法，其默认是使用的 `RoundRobinRule` 轮询策略。\n\n* **`RoundRobinRule`**：轮询策略。`Ribbon` 默认采用的策略。若经过一轮轮询没有找到可用的 `provider`，其最多轮询 10 轮。若最终还没有找到，则返回 `null`。\n* **`RandomRule`**: 随机策略，从所有可用的 `provider` 中随机选择一个。\n* **`RetryRule`**: 重试策略。先按照 `RoundRobinRule` 策略获取 `provider`，若获取失败，则在指定的时限内重试。默认的时限为 500 毫秒。\n\n🐦🐦🐦 还有很多，这里不一一举:chestnut:了，你最需要知道的是默认轮询算法，并且可以更换默认的负载均衡算法，只需要在配置文件中做出修改就行。\n\n```yaml\nproviderName:\n  ribbon:\n    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule\n```\n\n当然，在 `Ribbon` 中你还可以**自定义负载均衡算法**，你只需要实现 `IRule` 接口，然后修改配置文件或者自定义 `Java Config` 类。\n\n## 什么是 Open Feign\n\n有了 `Eureka`  ，`RestTemplate` ，`Ribbon`，  我们就可以愉快地进行服务间的调用了，但是使用 `RestTemplate` 还是不方便，我们每次都要进行这样的调用。\n\n```java\n@Autowired\nprivate RestTemplate restTemplate;\n// 这里是提供者A的ip地址，但是如果使用了 Eureka 那么就应该是提供者A的名称\nprivate static final String SERVICE_PROVIDER_A = "http://localhost:8081";\n\n@PostMapping("/judge")\npublic boolean judge(@RequestBody Request request) {\n    String url = SERVICE_PROVIDER_A + "/service1";\n    // 是不是太麻烦了？？？每次都要 url、请求、返回类型的 \n    return restTemplate.postForObject(url, request, Boolean.class);\n}\n```\n\n这样每次都调用 `RestRemplate` 的 `API` 是否太麻烦，我能不能像**调用原来代码一样进行各个服务间的调用呢？**\n\n:bulb::bulb::bulb:聪明的小朋友肯定想到了，那就用 **映射** 呀，就像域名和IP地址的映射。我们可以将被调用的服务代码映射到消费者端，这样我们就可以 **“无缝开发” **啦。\n\n>  `OpenFeign` 也是运行在消费者端的，使用 `Ribbon` 进行负载均衡，所以 `OpenFeign` 直接内置了 `Ribbon`。\n\n在导入了 `Open Feign` 之后我们就可以进行愉快编写  `Consumer` 端代码了。\n\n```java\n// 使用 @FeignClient 注解来指定提供者的名字\n@FeignClient(value = "eureka-client-provider")\npublic interface TestClient {\n    // 这里一定要注意需要使用的是提供者那端的请求相对路径，这里就相当于映射了\n    @RequestMapping(value = "/provider/xxx",\n    method = RequestMethod.POST)\n    CommonResponse<List<Plan>> getPlans(@RequestBody planGetRequest request);\n}\n```\n\n然后我们在 `Controller` 就可以像原来调用 `Service` 层代码一样调用它了。\n\n```java\n@RestController\npublic class TestController {\n    // 这里就相当于原来自动注入的 Service\n    @Autowired\n    private TestClient testClient;\n    // controller 调用 service 层代码\n    @RequestMapping(value = "/test", method = RequestMethod.POST)\n    public CommonResponse<List<Plan>> get(@RequestBody planGetRequest request) {\n        return testClient.getPlans(request);\n    }\n}\n```\n\n## 必不可少的 Hystrix\n\n### 什么是 Hystrix之熔断和降级\n\n> 在分布式环境中，不可避免地会有许多服务依赖项中的某些失败。Hystrix是一个库，可通过添加等待时间容限和容错逻辑来帮助您控制这些分布式服务之间的交互。Hystrix通过隔离服务之间的访问点，停止服务之间的级联故障并提供后备选项来实现此目的，所有这些都可以提高系统的整体弹性。\n\n总体来说 `Hystrix` 就是一个能进行 **熔断** 和 **降级** 的库，通过使用它能提高整个系统的弹性。\n\n那么什么是 熔断和降级 呢？再举个:chestnut:，此时我们整个微服务系统是这样的。服务A调用了服务B，服务B再调用了服务C，但是因为某些原因，服务C顶不住了，这个时候大量请求会在服务C阻塞。\n\n<img src="spring-cloud.assets/Hystrix1.jpg" style="zoom:50%;" />\n\n服务C阻塞了还好，毕竟只是一个系统崩溃了。但是请注意这个时候因为服务C不能返回响应，那么服务B调用服务C的的请求就会阻塞，同理服务B阻塞了，那么服务A也会阻塞崩溃。\n\n> 请注意，为什么阻塞会崩溃。因为这些请求会消耗占用系统的线程、IO 等资源，消耗完你这个系统服务器不就崩了么。\n\n<img src="spring-cloud.assets/Hystrix2.jpg" style="zoom:50%;" />\n\n这就叫 **服务雪崩**。妈耶，上面两个 **熔断** 和 **降级** 你都没给我解释清楚，你现在又给我扯什么 **服务雪崩** ？:tired_face::tired_face::tired_face:\n\n别急，听我慢慢道来。\n\n\n\n不听我也得讲下去！\n\n所谓 **熔断** 就是服务雪崩的一种有效解决方案。当指定时间窗内的请求失败率达到设定阈值时，系统将通过 **断路器** 直接将此请求链路断开。\n\n也就是我们上面服务B调用服务C在指定时间窗内，调用的失败率到达了一定的值，那么 `Hystrix` 则会自动将 服务B与C 之间的请求都断了，以免导致服务雪崩现象。\n\n其实这里所讲的 **熔断** 就是指的 `Hystrix` 中的 **断路器模式** ，你可以使用简单的 `@HystrixCommand` 注解来标注某个方法，这样 `Hystrix` 就会使用 **断路器** 来“包装”这个方法，每当调用时间超过指定时间时(默认为1000ms)，断路器将会中断对这个方法的调用。\n\n当然你可以对这个注解的很多属性进行设置，比如设置超时时间，像这样。\n\n```java\n@HystrixCommand(\n    commandProperties = {@HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds",value = "1200")}\n)\npublic List<Xxx> getXxxx() {\n    // ...省略代码逻辑\n}\n```\n\n但是，我查阅了一些博客，发现他们都将 **熔断** 和 **降级** 的概念混淆了，以我的理解，**降级是为了更好的用户体验，当一个方法调用异常时，通过执行另一种代码逻辑来给用户友好的回复**。这也就对应着 `Hystrix` 的 **后备处理** 模式。你可以通过设置 `fallbackMethod` 来给一个方法设置备用的代码逻辑。比如这个时候有一个热点新闻出现了，我们会推荐给用户查看详情，然后用户会通过id去查询新闻的详情，但是因为这条新闻太火了(比如最近什么*易对吧)，大量用户同时访问可能会导致系统崩溃，那么我们就进行 **服务降级** ，一些请求会做一些降级处理比如当前人数太多请稍后查看等等。\n\n```java\n// 指定了后备方法调用\n@HystrixCommand(fallbackMethod = "getHystrixNews")\n@GetMapping("/get/news")\npublic News getNews(@PathVariable("id") int id) {\n    // 调用新闻系统的获取新闻api 代码逻辑省略\n}\n// \npublic News getHystrixNews(@PathVariable("id") int id) {\n    // 做服务降级\n    // 返回当前人数太多，请稍后查看\n}\n```\n\n### 什么是Hystrix之其他\n\n我在阅读 《Spring微服务实战》这本书的时候还接触到了一个 **舱壁模式** 的概念。在不使用舱壁模式的情况下，服务A调用服务B，这种调用默认的是 **使用同一批线程来执行** 的，而在一个服务出现性能问题的时候，就会出现所有线程被刷爆并等待处理工作，同时阻塞新请求，最终导致程序崩溃。而舱壁模式会将远程资源调用隔离在他们自己的线程池中，以便可以控制单个表现不佳的服务，而不会使该程序崩溃。\n\n具体其原理我推荐大家自己去了解一下，本篇文章中对 **舱壁模式** 不做过多解释。当然还有 **`Hystrix` 仪表盘**，它是**用来实时监控 `Hystrix` 的各项指标信息的**，这里我将这个问题也抛出去，希望有不了解的可以自己去搜索一下。\n\n## 微服务网关——Zuul\n\n> ZUUL 是从设备和 web 站点到 Netflix 流应用后端的所有请求的前门。作为边界服务应用，ZUUL 是为了实现动态路由、监视、弹性和安全性而构建的。它还具有根据情况将请求路由到多个 Amazon Auto Scaling Groups（亚马逊自动缩放组，亚马逊的一种云计算方式） 的能力\n\n在上面我们学习了 `Eureka` 之后我们知道了 *服务提供者*  是 *消费者* 通过 `Eureka Server` 进行访问的，即 `Eureka Server` 是 *服务提供者* 的统一入口。那么整个应用中存在那么多 *消费者* 需要用户进行调用，这个时候用户该怎样访问这些 *消费者工程* 呢？当然可以像之前那样直接访问这些工程。但这种方式没有统一的消费者工程调用入口，不便于访问与管理，而 Zuul 就是这样的一个对于 *消费者* 的统一入口。\n\n> 如果学过前端的肯定都知道 Router 吧，比如 Flutter 中的路由，Vue，React中的路由，用了 Zuul 你会发现在路由功能方面和前端配置路由基本是一个理。:smile: 我偶尔撸撸 Flutter。\n\n大家对网关应该很熟吧，简单来讲网关是系统唯一对外的入口，介于客户端与服务器端之间，用于对请求进行**鉴权**、**限流**、 **路由**、**监控**等功能。\n\n<img src="spring-cloud.assets/zuul-sj22o93nfdsjkdsf.jpg" style="zoom:50%;" />\n\n没错，网关有的功能，`Zuul` 基本都有。而 `Zuul` 中最关键的就是 **路由和过滤器** 了，在官方文档中 `Zuul` 的标题就是\n\n> Router and Filter : Zuul\n\n### Zuul 的路由功能\n\n#### 简单配置\n\n本来想给你们复制一些代码，但是想了想，因为各个代码配置比较零散，看起来也比较零散，我决定还是给你们画个图来解释吧。\n\n> 请不要因为我这么好就给我点赞 :thumbsup: 。 疯狂暗示。\n\n比如这个时候我们已经向 `Eureka Server` 注册了两个 `Consumer` 、三个 `Provicer` ，这个时候我们再加个 `Zuul` 网关应该变成这样子了。\n\n<img src="spring-cloud.assets/zuul-sj22o93nfdsjkdsf2312.jpg" style="zoom:50%;" />\n\nemmm，信息量有点大，我来解释一下。关于前面的知识我就不解释了:neutral_face:。\n\n首先，`Zuul` 需要向 `Eureka` 进行注册，注册有啥好处呢？\n\n你傻呀，`Consumer` 都向 `Eureka Server` 进行注册了，我网关是不是只要注册就能拿到所有 `Consumer` 的信息了？\n\n拿到信息有什么好处呢？\n\n我拿到信息我是不是可以获取所有的 `Consumer` 的元数据(名称，ip，端口)？\n\n拿到这些元数据有什么好处呢？拿到了我们是不是直接可以做**路由映射**？比如原来用户调用 `Consumer1` 的接口 `localhost:8001/studentInfo/update` 这个请求，我们是不是可以这样进行调用了呢？`localhost:9000/consumer1/studentInfo/update` 呢？你这样是不是恍然大悟了？\n\n> 这里的url为了让更多人看懂所以没有使用 restful 风格。\n\n上面的你理解了，那么就能理解关于 `Zuul` 最基本的配置了，看下面。\n\n```yaml\nserver:\n  port: 9000\neureka:\n  client:\n    service-url:\n      # 这里只要注册 Eureka 就行了\n      defaultZone: http://localhost:9997/eureka\n```\n\n然后在启动类上加入 `@EnableZuulProxy` 注解就行了。没错，就是那么简单:smiley:。\n\n#### 统一前缀\n\n这个很简单，就是我们可以在前面加一个统一的前缀，比如我们刚刚调用的是 `localhost:9000/consumer1/studentInfo/update`，这个时候我们在 `yaml` 配置文件中添加如下。\n\n```yaml\nzuul:\n  prefix: /zuul\n```\n\n这样我们就需要通过 `localhost:9000/zuul/consumer1/studentInfo/update` 来进行访问了。\n\n#### 路由策略配置\n\n你会发现前面的访问方式(直接使用服务名)，需要将微服务名称暴露给用户，会存在安全性问题。所以，可以自定义路径来替代微服务名称，即自定义路由策略。\n\n```yaml\nzuul:\n  routes:\n    consumer1: /FrancisQ1/**\n    consumer2: /FrancisQ2/**\n```\n\n这个时候你就可以使用 ` `localhost:9000/zuul/FrancisQ1/studentInfo/update` 进行访问了。\n\n#### 服务名屏蔽\n\n这个时候你别以为你好了，你可以试试，在你配置完路由策略之后使用微服务名称还是可以访问的，这个时候你需要将服务名屏蔽。\n\n```yaml\nzuul:\n  ignore-services: "*"\n```\n\n#### 路径屏蔽\n\n`Zuul` 还可以指定屏蔽掉的路径 URI，即只要用户请求中包含指定的 URI 路径，那么该请求将无法访问到指定的服务。通过该方式可以限制用户的权限。\n\n```yaml\nzuul:\n  ignore-patterns: **/auto/**\n```\n\n这样关于 auto 的请求我们就可以过滤掉了。\n\n> ** 代表匹配多级任意路径\n>\n> *代表匹配一级任意路径\n\n#### 敏感请求头屏蔽\n\n默认情况下，像 `Cookie`、`Set-Cookie` 等敏感请求头信息会被 `zuul` 屏蔽掉，我们可以将这些默认屏蔽去掉，当然，也可以添加要屏蔽的请求头。\n\n### Zuul 的过滤功能 \n\n如果说，路由功能是 `Zuul` 的基操的话，那么**过滤器**就是 `Zuul`的利器了。毕竟所有请求都经过网关(Zuul)，那么我们可以进行各种过滤，这样我们就能实现 **限流**，**灰度发布**，**权限控制** 等等。\n\n#### 简单实现一个请求时间日志打印\n\n要实现自己定义的 `Filter` 我们只需要继承 `ZuulFilter` 然后将这个过滤器类以 `@Component` 注解加入 Spring 容器中就行了。\n\n在给你们看代码之前我先给你们解释一下关于过滤器的一些注意点。\n\n<img src="spring-cloud.assets/zuul-sj22o93nfdsjkdsf2312244.jpg" style="zoom:50%;" />\n\n过滤器类型：`Pre`、`Routing`、`Post`。前置`Pre`就是在请求之前进行过滤，`Routing`路由过滤器就是我们上面所讲的路由策略，而`Post`后置过滤器就是在 `Response` 之前进行过滤的过滤器。你可以观察上图结合着理解，并且下面我会给出相应的注释。\n\n```java\n// 加入Spring容器\n@Component\npublic class PreRequestFilter extends ZuulFilter {\n    // 返回过滤器类型 这里是前置过滤器\n    @Override\n    public String filterType() {\n        return FilterConstants.PRE_TYPE;\n    }\n    // 指定过滤顺序 越小越先执行，这里第一个执行\n    // 当然不是只真正第一个 在Zuul内置中有其他过滤器会先执行\n    // 那是写死的 比如 SERVLET_DETECTION_FILTER_ORDER = -3\n    @Override\n    public int filterOrder() {\n        return 0;\n    }\n    // 什么时候该进行过滤\n    // 这里我们可以进行一些判断，这样我们就可以过滤掉一些不符合规定的请求等等\n    @Override\n    public boolean shouldFilter() {\n        return true;\n    }\n    // 如果过滤器允许通过则怎么进行处理\n    @Override\n    public Object run() throws ZuulException {\n        // 这里我设置了全局的RequestContext并记录了请求开始时间\n        RequestContext ctx = RequestContext.getCurrentContext();\n        ctx.set("startTime", System.currentTimeMillis());\n        return null;\n    }\n}\n```\n\n\n\n```java\n// lombok的日志\n@Slf4j\n// 加入 Spring 容器\n@Component\npublic class AccessLogFilter extends ZuulFilter {\n    // 指定该过滤器的过滤类型\n    // 此时是后置过滤器\n    @Override\n    public String filterType() {\n        return FilterConstants.POST_TYPE;\n    }\n    // SEND_RESPONSE_FILTER_ORDER 是最后一个过滤器\n    // 我们此过滤器在它之前执行\n    @Override\n    public int filterOrder() {\n        return FilterConstants.SEND_RESPONSE_FILTER_ORDER - 1;\n    }\n    @Override\n    public boolean shouldFilter() {\n        return true;\n    }\n    // 过滤时执行的策略\n    @Override\n    public Object run() throws ZuulException {\n        RequestContext context = RequestContext.getCurrentContext();\n        HttpServletRequest request = context.getRequest();\n        // 从RequestContext获取原先的开始时间 并通过它计算整个时间间隔\n        Long startTime = (Long) context.get("startTime");\n        // 这里我可以获取HttpServletRequest来获取URI并且打印出来\n        String uri = request.getRequestURI();\n        long duration = System.currentTimeMillis() - startTime;\n        log.info("uri: " + uri + ", duration: " + duration / 100 + "ms");\n        return null;\n    }\n}\n```\n\n上面就简单实现了请求时间日志打印功能，你有没有感受到 `Zuul` 过滤功能的强大了呢？\n\n没有？好的、那我们再来。\n\n#### 令牌桶限流\n\n当然不仅仅是令牌桶限流方式，`Zuul` 只要是限流的活它都能干，这里我只是简单举个:chestnut:。\n\n<img src="spring-cloud.assets/zuui-令牌桶限流.jpg" alt="令牌桶限流" style="zoom:50%;" />\n\n我先来解释一下什么是 **令牌桶限流** 吧。\n\n首先我们会有个桶，如果里面没有满那么就会以一定 **固定的速率** 会往里面放令牌，一个请求过来首先要从桶中获取令牌，如果没有获取到，那么这个请求就拒绝，如果获取到那么就放行。很简单吧，啊哈哈、\n\n下面我们就通过 `Zuul` 的前置过滤器来实现一下令牌桶限流。\n\n```java\npackage com.lgq.zuul.filter;\n\nimport com.google.common.util.concurrent.RateLimiter;\nimport com.netflix.zuul.ZuulFilter;\nimport com.netflix.zuul.context.RequestContext;\nimport com.netflix.zuul.exception.ZuulException;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.cloud.netflix.zuul.filters.support.FilterConstants;\nimport org.springframework.stereotype.Component;\n\n@Component\n@Slf4j\npublic class RouteFilter extends ZuulFilter {\n    // 定义一个令牌桶，每秒产生2个令牌，即每秒最多处理2个请求\n    private static final RateLimiter RATE_LIMITER = RateLimiter.create(2);\n    @Override\n    public String filterType() {\n        return FilterConstants.PRE_TYPE;\n    }\n\n    @Override\n    public int filterOrder() {\n        return -5;\n    }\n\n    @Override\n    public Object run() throws ZuulException {\n        log.info("放行");\n        return null;\n    }\n\n    @Override\n    public boolean shouldFilter() {\n        RequestContext context = RequestContext.getCurrentContext();\n        if(!RATE_LIMITER.tryAcquire()) {\n            log.warn("访问量超载");\n            // 指定当前请求未通过过滤\n            context.setSendZuulResponse(false);\n            // 向客户端返回响应码429，请求数量过多\n            context.setResponseStatusCode(429);\n            return false;\n        }\n        return true;\n    }\n}\n```\n\n这样我们就能将请求数量控制在一秒两个，有没有觉得很酷？\n\n### 关于 Zuul  的其他\n\n`Zuul` 的过滤器的功能肯定不止上面我所实现的两种，它还可以实现 **权限校验**，包括我上面提到的 **灰度发布** 等等。\n\n当然，`Zuul` 作为网关肯定也存在 **单点问题** ，如果我们要保证 `Zuul` 的高可用，我们就需要进行 `Zuul` 的集群配置，这个时候可以借助额外的一些负载均衡器比如 `Nginx` 。\n\n##Spring Cloud配置管理——Config\n\n### 为什么要使用进行配置管理？\n\n当我们的微服务系统开始慢慢地庞大起来，那么多 `Consumer` 、`Provider` 、`Eureka Server` 、`Zuul` 系统都会持有自己的配置，这个时候我们在项目运行的时候可能需要更改某些应用的配置，如果我们不进行配置的统一管理，我们只能**去每个应用下一个一个寻找配置文件然后修改配置文件再重启应用**。\n\n首先对于分布式系统而言我们就不应该去每个应用下去分别修改配置文件，再者对于重启应用来说，服务无法访问所以直接抛弃了可用性，这是我们更不愿见到的。\n\n那么有没有一种方法**既能对配置文件统一地进行管理，又能在项目运行时动态修改配置文件呢？**\n\n那就是我今天所要介绍的 `Spring Cloud Config` 。\n\n> 能进行配置管理的框架不止 `Spring Cloud Config` 一种，大家可以根据需求自己选择（`disconf`，阿波罗等等）。而且对于 `Config` 来说有些地方实现的不是那么尽人意。\n\n### Config 是什么\n\n> `Spring Cloud Config` 为分布式系统中的外部化配置提供服务器和客户端支持。使用 `Config` 服务器，可以在中心位置管理所有环境中应用程序的外部属性。\n\n简单来说，`Spring Cloud Config` 就是能将各个 应用/系统/模块 的配置文件存放到 **统一的地方然后进行管理**(Git 或者 SVN)。\n\n你想一下，我们的应用是不是只有启动的时候才会进行配置文件的加载，那么我们的 `Spring Cloud Config` 就暴露出一个接口给启动应用来获取它所想要的配置文件，应用获取到配置文件然后再进行它的初始化工作。就如下图。\n\n<img src="spring-cloud.assets/config-ksksks.jpg" style="zoom:50%;" />\n\n当然这里你肯定还会有一个疑问，如果我在应用运行时去更改远程配置仓库(Git)中的对应配置文件，那么依赖于这个配置文件的已启动的应用会不会进行其相应配置的更改呢？\n\n答案是不会的。\n\n什么？那怎么进行动态修改配置文件呢？这不是出现了 **配置漂移** 吗？你个渣男:rage:，你又骗我！\n\n别急嘛，你可以使用 `Webhooks` ，这是  `github` 提供的功能，它能确保远程库的配置文件更新后客户端中的配置信息也得到更新。\n\n噢噢，这还差不多。我去查查怎么用。\n\n慢着，听我说完，`Webhooks` 虽然能解决，但是你了解一下会发现它根本不适合用于生产环境，所以基本不会使用它的。\n\n\n\n而一般我们会使用 `Bus` 消息总线 + `Spring Cloud Config` 进行配置的动态刷新。\n\n## 引出 Spring Cloud Bus\n\n> 用于将服务和服务实例与分布式消息系统链接在一起的事件总线。在集群中传播状态更改很有用（例如配置更改事件）。\n\n你可以简单理解为 `Spring Cloud Bus` 的作用就是**管理和广播分布式系统中的消息**，也就是消息引擎系统中的广播模式。当然作为 **消息总线** 的 `Spring Cloud Bus` 可以做很多事而不仅仅是客户端的配置刷新功能。\n\n而拥有了 `Spring Cloud Bus` 之后，我们只需要创建一个简单的请求，并且加上 `@ResfreshScope` 注解就能进行配置的动态修改了，下面我画了张图供你理解。\n\n<img src="spring-cloud.assets/springcloud-bus-s213dsfsd.jpg" style="zoom:50%;" />\n\n## 总结\n\n这篇文章中我带大家初步了解了 `Spring Cloud` 的各个组件，他们有\n\n* `Eureka` 服务发现框架\n* `Ribbon` 进程内负载均衡器\n* `Open Feign` 服务调用映射\n* `Hystrix` 服务降级熔断器\n* `Zuul` 微服务网关\n* `Config` 微服务统一配置中心\n* `Bus` 消息总线\n\n如果你能这个时候能看懂文首那张图，也就说明了你已经对 `Spring Cloud` 微服务有了一定的架构认识。'},c2aa:function(n,e,t){"use strict";t.r(e),e["default"]='> 本文来自木木匠投稿。\n\n## 手把手教你定位常见 Java 性能问题\n\n## 概述\n\n性能优化一向是后端服务优化的重点，但是线上性能故障问题不是经常出现，或者受限于业务产品，根本就没办法出现性能问题，包括笔者自己遇到的性能问题也不多，所以为了提前储备知识，当出现问题的时候不会手忙脚乱，我们本篇文章来模拟下常见的几个 Java 性能故障，来学习怎么去分析和定位。\n\n## 预备知识\n\n既然是定位问题，肯定是需要借助工具，我们先了解下需要哪些工具可以帮忙定位问题。\n\n**top 命令**\n\n`top`命令使我们最常用的 Linux 命令之一，它可以实时的显示当前正在执行的进程的 CPU 使用率，内存使用率等系统信息。`top -Hp pid` 可以查看线程的系统资源使用情况。\n\n**vmstat 命令**\n\nvmstat 是一个指定周期和采集次数的虚拟内存检测工具，可以统计内存，CPU，swap 的使用情况，它还有一个重要的常用功能，用来观察进程的上下文切换。字段说明如下:\n\n- r: 运行队列中进程数量（当数量大于 CPU 核数表示有阻塞的线程）\n- b: 等待 IO 的进程数量\n- swpd: 使用虚拟内存大小\n- free: 空闲物理内存大小\n- buff: 用作缓冲的内存大小(内存和硬盘的缓冲区)\n- cache: 用作缓存的内存大小（CPU 和内存之间的缓冲区）\n- si: 每秒从交换区写到内存的大小，由磁盘调入内存\n- so: 每秒写入交换区的内存大小，由内存调入磁盘\n- bi: 每秒读取的块数\n- bo: 每秒写入的块数\n- in: 每秒中断数，包括时钟中断。\n- cs: 每秒上下文切换数。\n- us: 用户进程执行时间百分比(user time)\n- sy: 内核系统进程执行时间百分比(system time)\n- wa: IO 等待时间百分比\n- id: 空闲时间百分比\n\n  **pidstat 命令**\n\npidstat 是 Sysstat 中的一个组件，也是一款功能强大的性能监测工具，`top` 和 `vmstat` 两个命令都是监测进程的内存、CPU 以及 I/O 使用情况，而 pidstat 命令可以检测到线程级别的。`pidstat`命令线程切换字段说明如下：\n\n- UID ：被监控任务的真实用户 ID。\n\n- TGID ：线程组 ID。\n\n- TID：线程 ID。\n\n- cswch/s：主动切换上下文次数，这里是因为资源阻塞而切换线程，比如锁等待等情况。\n\n- nvcswch/s：被动切换上下文次数，这里指 CPU 调度切换了线程。\n\n  **jstack 命令**\n\njstack 是 JDK 工具命令，它是一种线程堆栈分析工具，最常用的功能就是使用 `jstack pid` 命令查看线程的堆栈信息，也经常用来排除死锁情况。\n\n**jstat 命令**\n\n它可以检测 Java 程序运行的实时情况，包括堆内存信息和垃圾回收信息，我们常常用来查看程序垃圾回收情况。常用的命令是`jstat -gc pid`。信息字段说明如下：\n\n- S0C：年轻代中 To Survivor 的容量（单位 KB）；\n\n- S1C：年轻代中 From Survivor 的容量（单位 KB）；\n\n- S0U：年轻代中 To Survivor 目前已使用空间（单位 KB）；\n\n- S1U：年轻代中 From Survivor 目前已使用空间（单位 KB）；\n\n- EC：年轻代中 Eden 的容量（单位 KB）；\n\n- EU：年轻代中 Eden 目前已使用空间（单位 KB）；\n\n- OC：老年代的容量（单位 KB）；\n\n- OU：老年代目前已使用空间（单位 KB）；\n\n- MC：元空间的容量（单位 KB）；\n\n- MU：元空间目前已使用空间（单位 KB）；\n\n- YGC：从应用程序启动到采样时年轻代中 gc 次数；\n\n- YGCT：从应用程序启动到采样时年轻代中 gc 所用时间 (s)；\n\n- FGC：从应用程序启动到采样时 老年代（Full Gc）gc 次数；\n\n- FGCT：从应用程序启动到采样时 老年代代（Full Gc）gc 所用时间 (s)；\n\n- GCT：从应用程序启动到采样时 gc 用的总时间 (s)。\n\n  **jmap 命令**\n\njmap 也是 JDK 工具命令，他可以查看堆内存的初始化信息以及堆内存的使用情况，还可以生成 dump 文件来进行详细分析。查看堆内存情况命令`jmap -heap pid`。\n\n**mat 内存工具**\n\nMAT(Memory Analyzer Tool)工具是 eclipse 的一个插件(MAT 也可以单独使用)，它分析大内存的 dump 文件时，可以非常直观的看到各个对象在堆空间中所占用的内存大小、类实例数量、对象引用关系、利用 OQL 对象查询，以及可以很方便的找出对象 GC Roots 的相关信息。\n\n**idea 中也有这么一个插件，就是 JProfiler**。\n\n相关阅读：[《性能诊断利器 JProfiler 快速入门和最佳实践》](https://segmentfault.com/a/1190000017795841)\n\n## 模拟环境准备\n\n基础环境 jdk1.8，采用 SpringBoot 框架来写几个接口来触发模拟场景，首先是模拟 CPU 占满情况\n\n### CPU 占满\n\n模拟 CPU 占满还是比较简单，直接写一个死循环计算消耗 CPU 即可。\n\n```java\n \t/**\n     * 模拟CPU占满\n     */\n    @GetMapping("/cpu/loop")\n    public void testCPULoop() throws InterruptedException {\n        System.out.println("请求cpu死循环");\n        Thread.currentThread().setName("loop-thread-cpu");\n        int num = 0;\n        while (true) {\n            num++;\n            if (num == Integer.MAX_VALUE) {\n                System.out.println("reset");\n            }\n            num = 0;\n        }\n\n    }\n```\n\n请求接口地址测试`curl localhost:8080/cpu/loop`,发现 CPU 立马飙升到 100%\n\n![](手把手教你定位常见Java性能问题.assets/3be5a280b0f5499a80c706c8e5da2a4f-1.png)\n\n通过执行`top -Hp 32805` 查看 Java 线程情况\n\n![](手把手教你定位常见Java性能问题.assets/3d8d5ffd3ada43fb86ef54b05408c656-1.png)\n\n执行 `printf \'%x\' 32826` 获取 16 进制的线程 id，用于`dump`信息查询，结果为 `803a`。最后我们执行`jstack 32805 |grep -A 20 803a`来查看下详细的`dump`信息。\n\n![](手把手教你定位常见Java性能问题.assets/1fb751b0d78b4a3b8d0f528598ae885d-1.png)\n\n这里`dump`信息直接定位出了问题方法以及代码行，这就定位出了 CPU 占满的问题。\n\n### 内存泄露\n\n模拟内存泄漏借助了 ThreadLocal 对象来完成，ThreadLocal 是一个线程私有变量，可以绑定到线程上，在整个线程的生命周期都会存在，但是由于 ThreadLocal 的特殊性，ThreadLocal 是基于 ThreadLocalMap 实现的，ThreadLocalMap 的 Entry 继承 WeakReference，而 Entry 的 Key 是 WeakReference 的封装，换句话说 Key 就是弱引用，弱引用在下次 GC 之后就会被回收，如果 ThreadLocal 在 set 之后不进行后续的操作，因为 GC 会把 Key 清除掉，但是 Value 由于线程还在存活，所以 Value 一直不会被回收，最后就会发生内存泄漏。\n\n```Java\n/**\n     * 模拟内存泄漏\n     */\n    @GetMapping(value = "/memory/leak")\n    public String leak() {\n        System.out.println("模拟内存泄漏");\n        ThreadLocal<Byte[]> localVariable = new ThreadLocal<Byte[]>();\n        localVariable.set(new Byte[4096 * 1024]);// 为线程添加变量\n        return "ok";\n    }\n```\n\n我们给启动加上堆内存大小限制，同时设置内存溢出的时候输出堆栈快照并输出日志。\n\n```bash\njava -jar -Xms500m -Xmx500m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:/tmp/heaplog.log analysis-demo-0.0.1-SNAPSHOT.jar\n```\n\n启动成功后我们循环执行 100 次,`for i in {1..500}; do curl localhost:8080/memory/leak;done`,还没执行完毕，系统已经返回 500 错误了。查看系统日志出现了如下异常：\n\n```\njava.lang.OutOfMemoryError: Java heap space\n```\n\n我们用`jstat -gc pid` 命令来看看程序的 GC 情况。\n\n![](手把手教你定位常见Java性能问题.assets/e9bf831860f442a3a992eef64ebb6a50-1.png)\n\n很明显，内存溢出了，堆内存经过 45 次 Full Gc 之后都没释放出可用内存，这说明当前堆内存中的对象都是存活的，有 GC Roots 引用，无法回收。那是什么原因导致内存溢出呢？是不是我只要加大内存就行了呢？如果是普通的内存溢出也许扩大内存就行了，但是如果是内存泄漏的话，扩大的内存不一会就会被占满，所以我们还需要确定是不是内存泄漏。我们之前保存了堆 Dump 文件，这个时候借助我们的 MAT 工具来分析下。导入工具选择`Leak Suspects Report`，工具直接就会给你列出问题报告。\n\n![](手把手教你定位常见Java性能问题.assets/392e4090c0094657ae29af030d3646e3-1.png)\n\n这里已经列出了可疑的 4 个内存泄漏问题，我们点击其中一个查看详情。\n\n![](手把手教你定位常见Java性能问题.assets/53fd3ee9a1a0448ca1878e865f4e5f96-1.png)\n\n这里已经指出了内存被线程占用了接近 50M 的内存，占用的对象就是 ThreadLocal。如果想详细的通过手动去分析的话，可以点击`Histogram`,查看最大的对象占用是谁，然后再分析它的引用关系，即可确定是谁导致的内存溢出。\n\n![](手把手教你定位常见Java性能问题.assets/ba07b0fee1754ffc943e546a18a3907e-1.png)\n\n上图发现占用内存最大的对象是一个 Byte 数组，我们看看它到底被那个 GC Root 引用导致没有被回收。按照上图红框操作指引，结果如下图：\n\n![](手把手教你定位常见Java性能问题.assets/0605fbf554814a23b80f6351408598be-1.png)\n\n我们发现 Byte 数组是被线程对象引用的，图中也标明，Byte 数组对像的 GC Root 是线程，所以它是不会被回收的，展开详细信息查看，我们发现最终的内存占用对象是被 ThreadLocal 对象占据了。这也和 MAT 工具自动帮我们分析的结果一致。\n\n### 死锁\n\n死锁会导致耗尽线程资源，占用内存，表现就是内存占用升高，CPU 不一定会飙升(看场景决定)，如果是直接 new 线程，会导致 JVM 内存被耗尽，报无法创建线程的错误，这也是体现了使用线程池的好处。\n\n```java\n ExecutorService service = new ThreadPoolExecutor(4, 10,\n            0, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(1024),\n            Executors.defaultThreadFactory(),\n            new ThreadPoolExecutor.AbortPolicy());\n   /**\n     * 模拟死锁\n     */\n    @GetMapping("/cpu/test")\n    public String testCPU() throws InterruptedException {\n        System.out.println("请求cpu");\n        Object lock1 = new Object();\n        Object lock2 = new Object();\n        service.submit(new DeadLockThread(lock1, lock2), "deadLookThread-" + new Random().nextInt());\n        service.submit(new DeadLockThread(lock2, lock1), "deadLookThread-" + new Random().nextInt());\n        return "ok";\n    }\n\npublic class DeadLockThread implements Runnable {\n    private Object lock1;\n    private Object lock2;\n\n    public DeadLockThread1(Object lock1, Object lock2) {\n        this.lock1 = lock1;\n        this.lock2 = lock2;\n    }\n\n    @Override\n    public void run() {\n        synchronized (lock2) {\n            System.out.println(Thread.currentThread().getName()+"get lock2 and wait lock1");\n            try {\n                TimeUnit.MILLISECONDS.sleep(2000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            synchronized (lock1) {\n                System.out.println(Thread.currentThread().getName()+"get lock1 and lock2 ");\n            }\n        }\n    }\n}\n```\n\n我们循环请求接口 2000 次，发现不一会系统就出现了日志错误，线程池和队列都满了,由于我选择的当队列满了就拒绝的策略，所以系统直接抛出异常。\n\n```\njava.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@2760298 rejected from java.util.concurrent.ThreadPoolExecutor@7ea7cd51[Running, pool size = 10, active threads = 10, queued tasks = 1024, completed tasks = 846]\n```\n\n通过`ps -ef|grep java`命令找出 Java 进程 pid，执行`jstack pid` 即可出现 java 线程堆栈信息，这里发现了 5 个死锁，我们只列出其中一个，很明显线程`pool-1-thread-2`锁住了`0x00000000f8387d88`等待`0x00000000f8387d98`锁，线程`pool-1-thread-1`锁住了`0x00000000f8387d98`等待锁`0x00000000f8387d88`,这就产生了死锁。\n\n```JAVA\nJava stack information for the threads listed above:\n===================================================\n"pool-1-thread-2":\n        at top.luozhou.analysisdemo.controller.DeadLockThread2.run(DeadLockThread.java:30)\n        - waiting to lock <0x00000000f8387d98> (a java.lang.Object)\n        - locked <0x00000000f8387d88> (a java.lang.Object)\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n        at java.lang.Thread.run(Thread.java:748)\n"pool-1-thread-1":\n        at top.luozhou.analysisdemo.controller.DeadLockThread1.run(DeadLockThread.java:30)\n        - waiting to lock <0x00000000f8387d88> (a java.lang.Object)\n        - locked <0x00000000f8387d98> (a java.lang.Object)\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n        at java.lang.Thread.run(Thread.java:748)\n\n Found 5 deadlocks.\n```\n\n### 线程频繁切换\n\n上下文切换会导致将大量 CPU 时间浪费在寄存器、内核栈以及虚拟内存的保存和恢复上，导致系统整体性能下降。当你发现系统的性能出现明显的下降时候，需要考虑是否发生了大量的线程上下文切换。\n\n```java\n @GetMapping(value = "/thread/swap")\n    public String theadSwap(int num) {\n        System.out.println("模拟线程切换");\n        for (int i = 0; i < num; i++) {\n            new Thread(new ThreadSwap1(new AtomicInteger(0)),"thread-swap"+i).start();\n        }\n        return "ok";\n    }\npublic class ThreadSwap1 implements Runnable {\n    private AtomicInteger integer;\n\n    public ThreadSwap1(AtomicInteger integer) {\n        this.integer = integer;\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            integer.addAndGet(1);\n            Thread.yield(); //让出CPU资源\n        }\n    }\n}\n```\n\n这里我创建多个线程去执行基础的原子+1 操作，然后让出 CPU 资源，理论上 CPU 就会去调度别的线程，我们请求接口创建 100 个线程看看效果如何，`curl localhost:8080/thread/swap?num=100`。接口请求成功后，我们执行 `vmstat 1 10`，表示每 1 秒打印一次，打印 10 次，线程切换采集结果如下：\n\n```\nprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----\n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n101  0 128000 878384    908 468684    0    0     0     0 4071 8110498 14 86  0  0  0\n100  0 128000 878384    908 468684    0    0     0     0 4065 8312463 15 85  0  0  0\n100  0 128000 878384    908 468684    0    0     0     0 4107 8207718 14 87  0  0  0\n100  0 128000 878384    908 468684    0    0     0     0 4083 8410174 14 86  0  0  0\n100  0 128000 878384    908 468684    0    0     0     0 4083 8264377 14 86  0  0  0\n100  0 128000 878384    908 468688    0    0     0   108 4182 8346826 14 86  0  0  0\n```\n\n这里我们关注 4 个指标，`r`,`cs`,`us`,`sy`。\n\n**r=100**,说明等待的进程数量是 100，线程有阻塞。\n\n**cs=800 多万**，说明每秒上下文切换了 800 多万次，这个数字相当大了。\n\n**us=14**，说明用户态占用了 14%的 CPU 时间片去处理逻辑。\n\n**sy=86**，说明内核态占用了 86%的 CPU，这里明显就是做上下文切换工作了。\n\n我们通过`top`命令以及`top -Hp pid`查看进程和线程 CPU 情况，发现 Java 线程 CPU 占满了，但是线程 CPU 使用情况很平均，没有某一个线程把 CPU 吃满的情况。\n\n```\nPID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND\n 87093 root      20   0 4194788 299056  13252 S 399.7 16.1  65:34.67 java\n```\n\n```\n PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND\n 87189 root      20   0 4194788 299056  13252 R  4.7 16.1   0:41.11 java\n 87129 root      20   0 4194788 299056  13252 R  4.3 16.1   0:41.14 java\n 87130 root      20   0 4194788 299056  13252 R  4.3 16.1   0:40.51 java\n 87133 root      20   0 4194788 299056  13252 R  4.3 16.1   0:40.59 java\n 87134 root      20   0 4194788 299056  13252 R  4.3 16.1   0:40.95 java\n```\n\n结合上面用户态 CPU 只使用了 14%，内核态 CPU 占用了 86%，可以基本判断是 Java 程序线程上下文切换导致性能问题。\n\n我们使用`pidstat`命令来看看 Java 进程内部的线程切换数据，执行`pidstat -p 87093 -w 1 10`,采集数据如下：\n\n```\n11:04:30 PM   UID       TGID       TID   cswch/s nvcswch/s  Command\n11:04:30 PM     0         -     87128      0.00     16.07  |__java\n11:04:30 PM     0         -     87129      0.00     15.60  |__java\n11:04:30 PM     0         -     87130      0.00     15.54  |__java\n11:04:30 PM     0         -     87131      0.00     15.60  |__java\n11:04:30 PM     0         -     87132      0.00     15.43  |__java\n11:04:30 PM     0         -     87133      0.00     16.02  |__java\n11:04:30 PM     0         -     87134      0.00     15.66  |__java\n11:04:30 PM     0         -     87135      0.00     15.23  |__java\n11:04:30 PM     0         -     87136      0.00     15.33  |__java\n11:04:30 PM     0         -     87137      0.00     16.04  |__java\n```\n\n根据上面采集的信息，我们知道 Java 的线程每秒切换 15 次左右，正常情况下，应该是个位数或者小数。结合这些信息我们可以断定 Java 线程开启过多，导致频繁上下文切换，从而影响了整体性能。\n\n**为什么系统的上下文切换是每秒 800 多万，而 Java 进程中的某一个线程切换才 15 次左右？**\n\n系统上下文切换分为三种情况:\n\n1、多任务：在多任务环境中，一个进程被切换出 CPU，运行另外一个进程，这里会发生上下文切换。\n\n2、中断处理：发生中断时，硬件会切换上下文。在 vmstat 命令中是`in`\n\n3、用户和内核模式切换：当操作系统中需要在用户模式和内核模式之间进行转换时，需要进行上下文切换,比如进行系统函数调用。\n\nLinux 为每个 CPU 维护了一个就绪队列，将活跃进程按照优先级和等待 CPU 的时间排序，然后选择最需要 CPU 的进程，也就是优先级最高和等待 CPU 时间最长的进程来运行。也就是 vmstat 命令中的`r`。\n\n那么，进程在什么时候才会被调度到 CPU 上运行呢？\n\n- 进程执行完终止了，它之前使用的 CPU 会释放出来，这时再从就绪队列中拿一个新的进程来运行\n- 为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片被轮流分配给各个进程。当某个进程时间片耗尽了就会被系统挂起，切换到其它等待 CPU 的进程运行。\n- 进程在系统资源不足时，要等待资源满足后才可以运行，这时进程也会被挂起，并由系统调度其它进程运行。\n- 当进程通过睡眠函数 sleep 主动挂起时，也会重新调度。\n- 当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。\n- 发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。\n\n结合我们之前的内容分析，阻塞的就绪队列是 100 左右，而我们的 CPU 只有 4 核，这部分原因造成的上下文切换就可能会相当高，再加上中断次数是 4000 左右和系统的函数调用等，整个系统的上下文切换到 800 万也不足为奇了。Java 内部的线程切换才 15 次，是因为线程使用`Thread.yield()`来让出 CPU 资源，但是 CPU 有可能继续调度该线程，这个时候线程之间并没有切换，这也是为什么内部的某个线程切换次数并不是非常大的原因。\n\n## 总结\n\n本文模拟了常见的性能问题场景，分析了如何定位 CPU100%、内存泄漏、死锁、线程频繁切换问题。分析问题我们需要做好两件事，第一，掌握基本的原理，第二，借助好工具。本文也列举了分析问题的常用工具和命令，希望对你解决问题有所帮助。当然真正的线上环境可能十分复杂，并没有模拟的环境那么简单，但是原理是一样的，问题的表现也是类似的，我们重点抓住原理，活学活用，相信复杂的线上问题也可以顺利解决。\n\n## 参考\n\n1、https://linux.die.net/man/1/pidstat\n\n2、https://linux.die.net/man/8/vmstat\n\n3、https://help.eclipse.org/2020-03/index.jsp?topic=/org.eclipse.mat.ui.help/welcome.html\n\n4、https://www.linuxblogs.cn/articles/18120200.html\n\n5、https://www.tutorialspoint.com/what-is-context-switching-in-operating-system'},c623:function(n,e,t){"use strict";t.r(e),e["default"]="## BASE 理论\n\n[BASE 理论](https://dl.acm.org/doi/10.1145/1394127.1394128)起源于 2008 年， 由eBay的架构师Dan Pritchett在ACM上发表。\n\n### 简介\n\n**BASE** 是 **Basically Available（基本可用）** 、**Soft-state（软状态）** 和 **Eventually Consistent（最终一致性）** 三个短语的缩写。BASE 理论是对 CAP 中一致性 C 和可用性 A 权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。\n\n### BASE 理论的核心思想\n\n即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。\n\n> 也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。\n\n**BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。**\n\n**为什么这样说呢？**\n\nCAP 理论这节我们也说过了：\n\n> 如果系统没有发生“分区”的话，节点间的网络连接通信正常的话，也就不存在 P 了。这个时候，我们就可以同时保证 C 和 A 了。因此，**如果系统发生“分区”，我们要考虑选择 CP 还是 AP。如果系统没有发生“分区”的话，我们要思考如何保证 CA 。**\n\n因此，AP 方案只是在系统发生分区的时候放弃一致性，而不是永远放弃一致性。在分区故障恢复后，系统应该达到最终一致性。这一点其实就是 BASE 理论延伸的地方。\n\n### BASE 理论三要素\n\n![BASE理论三要素](BASE理论.assets/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC81LzI0LzE2MzkxNDgwNmQ5ZTE1YzY)\n\n#### 1. 基本可用\n\n基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。\n\n**什么叫允许损失部分可用性呢？**\n\n- **响应时间上的损失**: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。\n- **系统功能上的损失**：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。\n\n#### 2. 软状态\n\n软状态指允许系统中的数据存在中间状态（**CAP 理论中的数据不一致**），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。\n\n#### 3. 最终一致性\n\n最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。\n\n> 分布式一致性的 3 种级别：\n>\n> 1. **强一致性** ：系统写入了什么，读出来的就是什么。\n>\n> 2. **弱一致性** ：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。\n>\n> 3. **最终一致性** ：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。\n>\n> **业界比较推崇是最终一致性级别，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。**\n\n那实现最终一致性的具体方式是什么呢? [《分布式协议与算法实战》](http://gk.link/a/10rZM) 中是这样介绍：\n\n> - **读时修复** : 在读取数据时，检测数据的不一致，进行修复。比如 Cassandra 的 Read Repair 实现，具体来说，在向 Cassandra 系统查询数据的时候，如果检测到不同节点 的副本数据不一致，系统就自动修复数据。\n> - **写时修复** : 在写入数据，检测数据的不一致时，进行修复。比如 Cassandra 的 Hinted Handoff 实现。具体来说，Cassandra 集群的节点之间远程写数据的时候，如果写失败 就将数据缓存下来，然后定时重传，修复数据的不一致性。\n> -  **异步修复** : 这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。\n\n比较推荐 **写时修复**，这种方式对性能消耗比较低。\n\n### 总结\n\n**ACID 是数据库事务完整性的理论，CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸。**\n"},c63a:function(n,e,t){"use strict";t.r(e),e["default"]='## 第一部分 : IDEA开发工具\r\n\r\n**参见 ：IEDA的安装请参考文件夹PPT中的 04_IDEA.ppt**\r\n\r\n## 1.数组\r\n\r\n### 1.1 数组介绍\r\n\r\n​\t数组就是存储数据长度固定的容器，存储多个数据的数据类型要一致。 \r\n\r\n### 1.2 数组的定义格式\r\n\r\n#### 1.2.1 第一种格式\r\n\r\n​\t数据类型[] 数组名\r\n\r\n​\t示例：\r\n\r\n```java\r\nint[] arr;        \r\ndouble[] arr;      \r\nchar[] arr;\r\n```\r\n\r\n#### 1.2.2 第二种格式\r\n\r\n​\t数据类型 数组名[]\r\n\r\n​\t示例：\r\n\r\n```java\r\nint arr[];\r\ndouble arr[];\r\nchar arr[];\r\n```\r\n\r\n### 1.3 数组的动态初始化\r\n\r\n#### 1.3.1 什么是动态初始化\r\n\r\n​\t数组动态初始化就是只给定数组的长度，由系统给出默认初始化值\r\n\r\n#### 1.3.2 动态初始化格式\r\n\r\n```java\r\n数据类型[] 数组名 = new 数据类型[数组长度];\r\n```\r\n\r\n```java\r\nint[] arr = new int[3];\r\n```\r\n\r\n#### 1.3.3 动态初始化格式详解\r\n\r\n- 等号左边：\r\n\r\n  -  int:数组的数据类型\r\n\r\n  -  []:代表这是一个数组\r\n\r\n  -   arr:代表数组的名称\r\n\r\n- 等号右边：\r\n\r\n    -   new:为数组开辟内存空间\r\n    -   int:数组的数据类型\r\n    -   []:代表这是一个数组\r\n    -   5:代表数组的长度\r\n\r\n**代码 :** \r\n\r\n```java\r\npackage com.itheima.array;\r\n\r\npublic class Demo2Array {\r\n    /*\r\n        数组的动态初始化:\r\n                        在初始化的时候, 需要手动指定数组的长度, 系统会为数组容器分配初始值.\r\n\r\n        动态初始化格式:\r\n                        数据类型[] 数组名 = new 数据类型[数组的长度];\r\n\r\n        注意:\r\n                        打印数组变量的时候, 会打印出数组的内存地址\r\n\r\n        [I@10f87f48 :\r\n\r\n                        @ : 分隔符\r\n                        [ : 当前的空间是一个数组类型\r\n                        I : 当前数组容器中所存储的数据类型\r\n                        10f87f48 : 十六进制内存地址\r\n\r\n                                0 1 2 3 4 5 6 7 8 9 a b c d e f\r\n     */\r\n    public static void main(String[] args) {\r\n        // 数据类型[] 数组名 = new 数据类型[数组的长度];\r\n        // 通过new关键字创建了一个int类型的数组容器, 该容器可以存储5个int类型的整数, 该容器被arr数组变量所记录\r\n        int[] arr = new int[5];\r\n        // [I@10f87f48\r\n        System.out.println(arr);\r\n\r\n        byte[] bArr = new byte[3];\r\n        // [B@b4c966a\r\n        System.out.println(bArr);\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n### 1.4 数组元素访问\r\n\r\n#### 1.4.1 什么是索引\r\n\r\n​\t每一个存储到数组的元素，都会自动的拥有一个编号，从0开始。\r\n\r\n​\t这个自动编号称为数组索引(index)，可以通过数组的索引访问到数组中的元素。 \t\r\n\r\n#### 1.4.2访问数组元素格式\r\n\r\n```java\r\n数组名[索引];\r\n```\r\n\r\n#### 1.4.3示例代码\r\n\r\n```java\r\npackage com.itheima.array;\r\n\r\npublic class Demo3ArrayIndex {\r\n    /*\r\n        数组动态初始化:\r\n                初始化的时候, 手动指定数组长度, 系统会为数组容器分配初始值.\r\n\r\n        数组的元素访问格式:\r\n                数组名[索引]\r\n\r\n                索引: 数组中数据的编号方式, 编号从0开始\r\n                作用: 访问数组容器中的空间位置\r\n\r\n        注意:\r\n                数组在创建完毕后, 即使没有赋值, 也可以取出, 但取出的元素都是默认初始化值.\r\n\r\n     */\r\n    public static void main(String[] args) {\r\n        int[] arr = new int[3];         // 0 1 2\r\n        System.out.println(arr);        // 数组的内存地址  [I@10f87f48\r\n\r\n        // 数组名[索引]  访问数组容器中的空间位置\r\n        System.out.println(arr[0]);     // 0  系统自动分配的默认初始化值\r\n        System.out.println(arr[1]);\r\n        System.out.println(arr[2]);\r\n\r\n        System.out.println("--------------");\r\n\r\n        // 数组名[索引]\r\n        arr[0] = 11;\r\n        arr[1] = 22;\r\n        arr[2] = 33;\r\n\r\n        System.out.println(arr[0]);\r\n        System.out.println(arr[1]);\r\n        System.out.println(arr[2]);\r\n    }\r\n}\r\n```\r\n\r\n### 1.5 内存分配\r\n\r\n#### 1.5.1 内存概述\r\n\r\n​\t内存是计算机中的重要原件，临时存储区域，作用是运行程序。\r\n\r\n​\t我们编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的。\r\n\r\n​\t必须放进内存中才能运行，运行完毕后会清空内存。 \r\n\r\n​\tJava虚拟机要运行程序，必须要对内存进行空间的分配和管理。 \r\n\r\n#### 1.5.2 java中的内存分配\r\n\r\n- 目前我们只需要记住两个内存，分别是：栈内存和堆内存\r\n\r\n| 区域名称   | 作用                                                       |\r\n| ---------- | ---------------------------------------------------------- |\r\n| 寄存器     | 给CPU使用，和我们开发无关。                                |\r\n| 本地方法栈 | JVM在使用操作系统功能的时候使用，和我们开发无关。          |\r\n| 方法区     | 存储可以运行的class文件。                                  |\r\n| 堆内存     | 存储对象或者数组，new来创建的，都存储在堆内存。            |\r\n| 方法栈     | 方法运行时使用的内存，比如main方法运行，进入方法栈中执行。 |\r\n\r\n### 1.6 Java内存分配-一个数组内存图\r\n\r\n![1591007817165](./day04-IDEA&数组.img/1591007817165.png)\r\n\r\n### 1.7 两个数组内存图\r\n\r\n![1591007925899](./day04-IDEA&数组.img/1591007925899.png)\r\n\r\n### 1.8 多个数组指向相同内存图\r\n\r\n![1591007957052](./day04-IDEA&数组.img/1591007957052.png)\r\n\r\n### 1.9 数组的静态初始化\r\n\r\n#### 1.9.1 什么是静态初始化\r\n\r\n​\t在创建数组时，直接将元素确定\t\r\n\r\n#### 1.9.2 静态初始化格式\r\n\r\n- 完整版格式\r\n\r\n  ```java\r\n  数据类型[] 数组名 = new 数据类型[]{元素1,元素2,...};\r\n  ```\r\n\r\n- 简化版格式\r\n\r\n  ```java\r\n  数据类型[] 数组名 = {元素1,元素2,...};\r\n  ```\r\n\r\n#### 1.9.3示例代码\r\n\r\n```java\r\npackage com.itheima.array2;\r\n\r\npublic class Demo1Array {\r\n    /*\r\n        数组静态初始化 : 初始化时指定每个数组元素的初始值，由系统决定数组长度\r\n\r\n        完整格式:\r\n                    数据类型[] 数组名 = new 数据类型[]{数据1,数据2,数据3...};\r\n        简化格式:\r\n                    数据类型[] 数组名 = {数据1,数据2,数据3...};\r\n     */\r\n    public static void main(String[] args) {\r\n        // 数据类型[] 数组名 = new 数据类型[]{数据1,数据2,数据3...};\r\n        int[] arr = new int[]{11,22,33};\r\n        System.out.println(arr[0]);\r\n        System.out.println(arr[1]);\r\n        System.out.println(arr[2]);\r\n\r\n        // 数据类型[] 数组名 = {数据1,数据2,数据3...};\r\n        int[] arr2 = {44,55,66};\r\n        System.out.println(arr2);\r\n        System.out.println(arr2[0]);\r\n        System.out.println(arr2[1]);\r\n        System.out.println(arr2[2]);\r\n\r\n    }\r\n}\r\n```\r\n\r\n### 1.10 数组操作的两个常见问题\r\n\r\n#### 1.10.1 索引越界异常\r\n\r\n- 出现原因\r\n\r\n  ```java\r\n  public class ArrayDemo {\r\n      public static void main(String[] args) {\r\n          int[] arr = new int[3];\r\n          System.out.println(arr[3]);\r\n      }\r\n  }\r\n  ```\r\n\r\n  数组长度为3，索引范围是0~2，但是我们却访问了一个3的索引。\r\n\r\n  程序运行后，将会抛出ArrayIndexOutOfBoundsException 数组越界异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。 \r\n\r\n- 解决方案\r\n\r\n  将错误的索引修改为正确的索引范围即可！\r\n\r\n#### 1.10.2 空指针异常\r\n\r\n- 出现原因\r\n\r\n  ```java\r\n  public class ArrayDemo {\r\n      public static void main(String[] args) {\r\n          int[] arr = new int[3];\r\n  \r\n          //把null赋值给数组\r\n          arr = null;\r\n          System.out.println(arr[0]);\r\n      }\r\n  }\r\n  ```\r\n\r\n  arr = null 这行代码，意味着变量arr将不会在保存数组的内存地址，也就不允许再操作数组了，因此运行的时候会抛出 NullPointerException 空指针异常。在开发中，空指针异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。\r\n\r\n- 解决方案\r\n\r\n  给数组一个真正的堆内存空间引用即可！\r\n\r\n### 1.11 数组遍历\r\n\r\n- 数组遍历：就是将数组中的每个元素分别获取出来，就是遍历。遍历也是数组操作中的基石。\r\n\r\n  ```java\r\n  public class ArrayTest01 {\r\n  \tpublic static void main(String[] args) {\r\n  \t\tint[] arr = { 1, 2, 3, 4, 5 };\r\n  \t\tSystem.out.println(arr[0]);\r\n  \t\tSystem.out.println(arr[1]);\r\n  \t\tSystem.out.println(arr[2]);\r\n  \t\tSystem.out.println(arr[3]);\r\n  \t\tSystem.out.println(arr[4]);\r\n  \t}\r\n  }\r\n  ```\r\n\r\n   以上代码是可以将数组中每个元素全部遍历出来，但是如果数组元素非常多，这种写法肯定不行，因此我们需要改造成循环的写法。数组的索引是 0 到 lenght-1 ，可以作为循环的条件出现。 \r\n\r\n  ```java\r\n  public class ArrayTest01 {\r\n      public static void main(String[] args) {\r\n          //定义数组\r\n          int[] arr = {11, 22, 33, 44, 55};\r\n  \r\n          //使用通用的遍历格式\r\n          for(int x=0; x<arr.length; x++) {\r\n              System.out.println(arr[x]);\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n### 1.12 数组获取最大值\r\n\r\n- 最大值获取：从数组的所有元素中找出最大值。\r\n\r\n- 实现思路：\r\n\r\n  - 定义变量，保存数组0索引上的元素\r\n  - 遍历数组，获取出数组中的每个元素\r\n  - 将遍历到的元素和保存数组0索引上值的变量进行比较\r\n  - 如果数组元素的值大于了变量的值，变量记录住新的值\r\n  - 数组循环遍历结束，变量保存的就是数组中的最大值 \r\n\r\n- 代码实现：\r\n\r\n  ```java\r\n  package com.itheima.test;\r\n  \r\n  import java.util.Scanner;\r\n  \r\n  public class Test2Array {\r\n      /*\r\n          需求: 从数组中查找最大值\r\n  \r\n                  int[] arr = {12,45,98,73,60};\r\n  \r\n          实现步骤:\r\n                  1. 假设数组中的第一个元素为最大值\r\n                  2. 遍历数组, 获取每一个元素, 准备进行比较\r\n                  3. 如果比较的过程中, 出现了比max更大的, 让max记录更大的值\r\n                  4. 循环结束后, 打印最大值.\r\n       */\r\n      public static void main(String[] args) {\r\n          int[] arr = {12,45,98,73,60};\r\n          // 1. 假设数组中的第一个元素为最大值\r\n          int max = arr[0];\r\n          // 2. 遍历数组, 获取每一个元素, 准备进行比较\r\n          for(int i = 1; i < arr.length; i++){\r\n              // 3. 如果比较的过程中, 出现了比max更大的, 让max记录更大的值\r\n              if(arr[i] > max){\r\n                  max = arr[i];\r\n              }\r\n          }\r\n          //  4. 循环结束后, 打印最大值.\r\n          System.out.println("max:" + max);\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n### 1.13 数组元素求和\r\n\r\n- 需求：键盘录入5个整数，存储到数组中，并对数组求和\r\n\r\n- 思路：\r\n      1.创建键盘录入对象，准备键盘录入\r\n      2.定义一个求和变量，准备记录累加后的结果\r\n      3.动态初始化一个长度为5的int数组，准备存储键盘录入的数值\r\n      4.将键盘录入的数值存储到数组中\r\n      5.遍历数组，取出每一个元素，并求和\r\n      6.输出总和\r\n\r\n- 代码实现：\r\n\r\n  ```java\r\n  package com.itheima.test;\r\n  \r\n  import java.util.Scanner;\r\n  \r\n  public class Test3Array {\r\n      /*\r\n          需求：键盘录入5个整数，存储到数组中，并对数组求和\r\n  \r\n          思路：\r\n              1.创建键盘录入对象，准备键盘录入\r\n              2.定义一个求和变量，准备记录累加后的结果\r\n              3.动态初始化一个长度为5的int数组，准备存储键盘录入的数值\r\n              4.将键盘录入的数值存储到数组中\r\n              5.遍历数组，取出每一个元素，并求和\r\n              6.输出总和\r\n       */\r\n      public static void main(String[] args) {\r\n          // 1.创建键盘录入对象，准备键盘录入\r\n          Scanner sc = new Scanner(System.in);\r\n          // 2.定义一个求和变量，准备记录累加后的结果\r\n          int sum = 0;\r\n          // 3.动态初始化一个长度为5的int数组，准备存储键盘录入的数值\r\n          int[] arr = new int[5];\r\n          // 4.将键盘录入的数值存储到数组中\r\n          for(int i = 0; i < arr.length; i++){\r\n              System.out.println("请输入第" + (i+1) + "个整数:");\r\n              //arr[i] = 10;\r\n              arr[i] = sc.nextInt();\r\n          }\r\n  \r\n          // 5.遍历数组，取出每一个元素，并求和\r\n          for (int i = 0; i < arr.length; i++) {\r\n              sum += arr[i];\r\n          }\r\n  \r\n          // 6.输出总和\r\n          System.out.println("sum:" + sum);\r\n  \r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n### 1.14 数组基本查找【应用】\r\n\r\n- 需求：\r\n              已知一个数组 arr = {19, 28, 37, 46, 50}; 键盘录入一个数据，查找该数据在数组中的索引，并在控\r\n              制台输出找到的索引值。\r\n\r\n- 思路：\r\n          1.定义一个数组，用静态初始化完成数组元素的初始化\r\n          2.键盘录入要查找的数据，用一个变量接收\r\n          3.定义一个索引变量，初始值为-1\r\n          4.遍历数组，获取到数组中的每一个元素\r\n          5.拿键盘录入的数据和数组中的每一个元素进行比较，如果值相同，就把该值对应的索引赋值给索引变量，并结束循环\r\n          6.输出索引变量\r\n\r\n- 代码实现：\r\n\r\n  ```java\r\n  public static void main(String[] args) {\r\n          // 1.定义一个数组，用静态初始化完成数组元素的初始化\r\n          int[] arr = {19, 28, 37, 46, 50};\r\n          // 2.键盘录入要查找的数据，用一个变量接收\r\n          Scanner sc = new Scanner(System.in);\r\n          System.out.println("请输入您要查找的元素:");\r\n          int num = sc.nextInt();\r\n          // 3.定义一个索引变量，初始值为-1\r\n          // 假设要查找的数据, 在数组中就是不存在的\r\n          int index = -1;\r\n          // 4.遍历数组，获取到数组中的每一个元素\r\n          for (int i = 0; i < arr.length; i++) {\r\n              // 5.拿键盘录入的数据和数组中的每一个元素进行比较，如果值相同，就把该值对应的索引赋值给索引变量，并结束循环\r\n              if(num == arr[i]){\r\n                  // 如果值相同，就把该值对应的索引赋值给索引变量，并结束循环\r\n                  index = i;\r\n                  break;\r\n              }\r\n          }\r\n          //  6.输出索引变量\r\n          System.out.println(index);\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n### 1.15 评委打分【应用】\r\n\r\n-   需求：在编程竞赛中，有6个评委为参赛的选手打分，分数为0-100的整数分。\r\n                  选手的最后得分为：去掉一个最高分和一个最低分后 的4个评委平均值 (不考虑小数部分)。\r\n\r\n- 思路：\r\n          1.定义一个数组，用动态初始化完成数组元素的初始化，长度为6\r\n          2.键盘录入评委分数\r\n          3.由于是6个评委打分，所以，接收评委分数的操作，用循环\r\n          4.求出数组最大值\r\n          5.求出数组最小值\r\n          6.求出数组总和\r\n          7.按照计算规则进行计算得到平均分\r\n          8.输出平均分\r\n\r\n- 代码实现：\r\n\r\n  ```java\r\n      public static void main(String[] args) {\r\n          // 1.定义一个数组，用动态初始化完成数组元素的初始化，长度为6\r\n          int[] arr = new int[6];\r\n          // 2.键盘录入评委分数\r\n          Scanner sc = new Scanner(System.in);\r\n          //  3.由于是6个评委打分，所以，接收评委分数的操作，用循环\r\n          for (int i = 0; i < arr.length; i++) {\r\n              System.out.println("请输入第" + (i+1) + "个评委的打分:");\r\n              int score = sc.nextInt();\r\n              if(score >= 0 && score <= 100){\r\n                  // 合法的分值\r\n                  arr[i] = score;\r\n              }else{\r\n                  // 非法的分值\r\n                  System.out.println("您的打分输入有误, 请检查是否是0-100之间的");\r\n                  i--;\r\n              }\r\n          }\r\n  \r\n          // 4.求出数组最大值\r\n          int max = arr[0];\r\n          for (int i = 1; i < arr.length; i++) {\r\n              if(max < arr[i]){\r\n                  max = arr[i];\r\n              }\r\n          }\r\n  \r\n          // 5.求出数组最小值\r\n          int min = arr[0];\r\n          for (int i = 1; i < arr.length; i++) {\r\n              if(min > arr[i]){\r\n                  min = arr[i];\r\n              }\r\n          }\r\n  \r\n          // 6.求出数组总和\r\n          int sum = 0;\r\n          for (int i = 0; i < arr.length; i++) {\r\n              sum += arr[i];\r\n          }\r\n  \r\n          // 7.按照计算规则进行计算得到平均分\r\n          int avg = (sum - max - min ) / 4;\r\n  \r\n          // 8.输出平均分\r\n          System.out.println(avg);\r\n      }\r\n  }\r\n  ```\r\n\r\n'},cc1d:function(n,e,t){"use strict";t.r(e),e["default"]='\x3c!-- TOC --\x3e\n\n- [1. 剖析面试最常见问题之 Java 集合框架](#1-剖析面试最常见问题之-java-集合框架)\n  - [1.1. 集合概述](#11-集合概述)\n    - [1.1.1. Java 集合概览](#111-java-集合概览)\n    - [1.1.2. 说说 List, Set, Queue, Map 四者的区别？](#112-说说-list-set-queue-map-四者的区别)\n    - [1.1.3. 集合框架底层数据结构总结](#113-集合框架底层数据结构总结)\n      - [1.1.3.1. List](#1131-list)\n      - [1.1.3.2. Set](#1132-set)\n      - [1.1.3.3 Queue](#1133-queue)\n      - [1.1.3.4. Map](#1134-map)\n    - [1.1.4. 如何选用集合?](#114-如何选用集合)\n    - [1.1.5. 为什么要使用集合？](#115-为什么要使用集合)\n  - [1.2. Collection 子接口之 List](#12-collection-子接口之-list)\n    - [1.2.1. Arraylist 和 Vector 的区别?](#121-arraylist-和-vector-的区别)\n    - [1.2.2. Arraylist 与 LinkedList 区别?](#122-arraylist-与-linkedlist-区别)\n      - [1.2.2.1. 补充内容:双向链表和双向循环链表](#1221-补充内容双向链表和双向循环链表)\n      - [1.2.2.2. 补充内容:RandomAccess 接口](#1222-补充内容randomaccess-接口)\n    - [1.2.3. 说一说 ArrayList 的扩容机制吧](#123-说一说-arraylist-的扩容机制吧)\n  - [1.3. Collection 子接口之 Set](#13-collection-子接口之-set)\n    - [1.3.1. comparable 和 Comparator 的区别](#131-comparable-和-comparator-的区别)\n      - [1.3.1.1. Comparator 定制排序](#1311-comparator-定制排序)\n      - [1.3.1.2. 重写 compareTo 方法实现按年龄来排序](#1312-重写-compareto-方法实现按年龄来排序)\n    - [1.3.2. 无序性和不可重复性的含义是什么](#132-无序性和不可重复性的含义是什么)\n    - [1.3.3. 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同](#133-比较-hashsetlinkedhashset-和-treeset-三者的异同)\n  - [1.4 Collection 子接口之 Queue](#14-collection-子接口之-queue)\n    - [1.4.1 Queue 与 Deque 的区别](#141-queue-与-deque-的区别)\n    - [1.4.2 ArrayDeque 与 LinkedList 的区别](#142-arraydeque-与-linkedlist-的区别)\n    - [1.4.3 说一说 PriorityQueue](#143-说一说-priorityqueue)\n  - [1.5. Map 接口](#15-map-接口)\n    - [1.5.1. HashMap 和 Hashtable 的区别](#151-hashmap-和-hashtable-的区别)\n    - [1.5.2. HashMap 和 HashSet 区别](#152-hashmap-和-hashset-区别)\n    - [1.5.3. HashMap 和 TreeMap 区别](#153-hashmap-和-treemap-区别)\n    - [1.5.4. HashSet 如何检查重复](#154-hashset-如何检查重复)\n    - [1.5.5. HashMap 的底层实现](#155-hashmap-的底层实现)\n      - [1.5.5.1. JDK1.8 之前](#1551-jdk18-之前)\n      - [1.5.5.2. JDK1.8 之后](#1552-jdk18-之后)\n    - [1.5.6. HashMap 的长度为什么是 2 的幂次方](#156-hashmap-的长度为什么是-2-的幂次方)\n    - [1.5.7. HashMap 多线程操作导致死循环问题](#157-hashmap-多线程操作导致死循环问题)\n    - [1.5.8. HashMap 有哪几种常见的遍历方式?](#158-hashmap-有哪几种常见的遍历方式)\n    - [1.5.9. ConcurrentHashMap 和 Hashtable 的区别](#159-concurrenthashmap-和-hashtable-的区别)\n    - [1.5.10. ConcurrentHashMap 线程安全的具体实现方式/底层具体实现](#1510-concurrenthashmap-线程安全的具体实现方式底层具体实现)\n      - [1.5.10.1. JDK1.7（上面有示意图）](#15101-jdk17上面有示意图)\n      - [1.5.10.2. JDK1.8 （上面有示意图）](#15102-jdk18-上面有示意图)\n  - [1.6. Collections 工具类](#16-collections-工具类)\n    - [1.6.1. 排序操作](#161-排序操作)\n    - [1.6.2. 查找,替换操作](#162-查找替换操作)\n    - [1.6.3. 同步控制](#163-同步控制)\n\n\x3c!-- /TOC --\x3e\n\n# 1. 剖析面试最常见问题之 Java 集合框架\n\n## 1.1. 集合概述\n\n### 1.1.1. Java 集合概览\n\nJava 集合， 也叫作容器，主要是由两大接口派生而来：一个是 `Collecton`接口，主要用于存放单一元素；另一个是 `Map` 接口，主要用于存放键值对。对于`Collection` 接口，下面又有三个主要的子接口：`List`、`Set` 和 `Queue`。\n\nJava 集合框架如下图所示：\n\n![](Java集合框架常见面试题.assets/java-collection-hierarchy.png)\n\n\n注：图中只列举了主要的继承派生关系，并没有列举所有关系。比方省略了`AbstractList`, `NavigableSet`等抽象类以及其他的一些辅助类，如想深入了解，可自行查看源码。\n\n### 1.1.2. 说说 List, Set, Queue, Map 四者的区别？\n\n- `List`(对付顺序的好帮手): 存储的元素是有序的、可重复的。\n- `Set`(注重独一无二的性质): 存储的元素是无序的、不可重复的。\n- `Queue`(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。\n- `Map`(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，"x" 代表 key，"y" 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。\n\n### 1.1.3. 集合框架底层数据结构总结\n\n先来看一下 `Collection` 接口下面的集合。\n\n#### 1.1.3.1. List\n\n- `Arraylist`： `Object[]` 数组\n- `Vector`：`Object[]` 数组\n- `LinkedList`： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)\n\n#### 1.1.3.2. Set\n\n- `HashSet`(无序，唯一): 基于 `HashMap` 实现的，底层采用 `HashMap` 来保存元素\n- `LinkedHashSet`: `LinkedHashSet` 是 `HashSet` 的子类，并且其内部是通过 `LinkedHashMap` 来实现的。有点类似于我们之前说的 `LinkedHashMap` 其内部是基于 `HashMap` 实现一样，不过还是有一点点区别的\n- `TreeSet`(有序，唯一): 红黑树(自平衡的排序二叉树)\n\n#### 1.1.3.3 Queue\n- `PriorityQueue`: `Object[]` 数组来实现二叉堆\n- `ArrayQueue`: `Object[]` 数组 + 双指针\n\n再来看看 `Map` 接口下面的集合。\n\n#### 1.1.3.4. Map\n\n- `HashMap`： JDK1.8 之前 `HashMap` 由数组+链表组成的，数组是 `HashMap` 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间\n- `LinkedHashMap`： `LinkedHashMap` 继承自 `HashMap`，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，`LinkedHashMap` 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：[《LinkedHashMap 源码详细分析（JDK1.8）》](https://www.imooc.com/article/22931)\n- `Hashtable`： 数组+链表组成的，数组是 `Hashtable` 的主体，链表则是主要为了解决哈希冲突而存在的\n- `TreeMap`： 红黑树（自平衡的排序二叉树）\n\n### 1.1.4. 如何选用集合?\n\n主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 `Map` 接口下的集合，需要排序时选择 `TreeMap`,不需要排序时就选择 `HashMap`,需要保证线程安全就选用 `ConcurrentHashMap`。\n\n当我们只需要存放元素值时，就选择实现`Collection` 接口的集合，需要保证元素唯一时选择实现 `Set` 接口的集合比如 `TreeSet` 或 `HashSet`，不需要就选择实现 `List` 接口的比如 `ArrayList` 或 `LinkedList`，然后再根据实现这些接口的集合的特点来选用。\n\n### 1.1.5. 为什么要使用集合？\n\n当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组，但是，使用数组存储对象具有一定的弊端，\n因为我们在实际开发中，存储的数据的类型是多种多样的，于是，就出现了“集合”，集合同样也是用来存储多个数据的。\n\n数组的缺点是一旦声明之后，长度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数据的类型；而且，数组存储的数据是有序的、可重复的，特点单一。\n但是集合提高了数据存储的灵活性，Java 集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。\n\n## 1.2. Collection 子接口之 List\n\n### 1.2.1. Arraylist 和 Vector 的区别?\n\n- `ArrayList` 是 `List` 的主要实现类，底层使用 `Object[ ]`存储，适用于频繁的查找工作，线程不安全 ；\n- `Vector` 是 `List` 的古老实现类，底层使用`Object[ ]` 存储，线程安全的。\n\n### 1.2.2. Arraylist 与 LinkedList 区别?\n\n1. **是否保证线程安全：** `ArrayList` 和 `LinkedList` 都是不同步的，也就是不保证线程安全；\n2. **底层数据结构：** `Arraylist` 底层使用的是 **`Object` 数组**；`LinkedList` 底层使用的是 **双向链表** 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）\n3. **插入和删除是否受元素位置的影响：**\n   - `ArrayList` 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行`add(E e)`方法的时候， `ArrayList` 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（`add(int index, E element)`）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。\n   - `LinkedList` 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（`add(E e)`、`addFirst(E e)`、`addLast(E e)`、`removeFirst()` 、 `removeLast()`），近似 O(1)，如果是要在指定位置 `i` 插入和删除元素的话（`add(int index, E element)`，`remove(Object o)`） 时间复杂度近似为 O(n) ，因为需要先移动到指定位置再插入。\n4. **是否支持快速随机访问：** `LinkedList` 不支持高效的随机元素访问，而 `ArrayList` 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于`get(int index)`方法)。\n5. **内存空间占用：** ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。\n\n#### 1.2.2.1. 补充内容:双向链表和双向循环链表\n\n**双向链表：** 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。\n\n> 另外推荐一篇把双向链表讲清楚的文章：[https://juejin.cn/post/6844903648154271757](https://juejin.cn/post/6844903648154271757)\n\n![双向链表](Java集合框架常见面试题.assets/双向链表.png)\n\n**双向循环链表：** 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。\n\n![双向循环链表](Java集合框架常见面试题.assets/双向循环链表.png)\n\n#### 1.2.2.2. 补充内容:RandomAccess 接口\n\n```java\npublic interface RandomAccess {\n}\n```\n\n查看源码我们发现实际上 `RandomAccess` 接口中什么都没有定义。所以，在我看来 `RandomAccess` 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。\n\n在 `binarySearch（)` 方法中，它要判断传入的 list 是否 `RamdomAccess` 的实例，如果是，调用`indexedBinarySearch()`方法，如果不是，那么调用`iteratorBinarySearch()`方法\n\n```java\n    public static <T>\n    int binarySearch(List<? extends Comparable<? super T>> list, T key) {\n        if (list instanceof RandomAccess || list.size()<BINARYSEARCH_THRESHOLD)\n            return Collections.indexedBinarySearch(list, key);\n        else\n            return Collections.iteratorBinarySearch(list, key);\n    }\n```\n\n`ArrayList` 实现了 `RandomAccess` 接口， 而 `LinkedList` 没有实现。为什么呢？我觉得还是和底层数据结构有关！`ArrayList` 底层是数组，而 `LinkedList` 底层是链表。数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n)，所以不支持快速随机访问。，`ArrayList` 实现了 `RandomAccess` 接口，就表明了他具有快速随机访问功能。 `RandomAccess` 接口只是标识，并不是说 `ArrayList` 实现 `RandomAccess` 接口才具有快速随机访问功能的！\n\n### 1.2.3. 说一说 ArrayList 的扩容机制吧\n\n详见笔主的这篇文章:[通过源码一步一步分析 ArrayList 扩容机制](https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList%E6%BA%90%E7%A0%81+%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90)\n\n## 1.3. Collection 子接口之 Set\n\n### 1.3.1. comparable 和 Comparator 的区别\n\n- `comparable` 接口实际上是出自`java.lang`包 它有一个 `compareTo(Object obj)`方法用来排序\n- `comparator`接口实际上是出自 java.util 包它有一个`compare(Object obj1, Object obj2)`方法用来排序\n\n一般我们需要对一个集合使用自定义排序时，我们就要重写`compareTo()`方法或`compare()`方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写`compareTo()`方法和使用自制的`Comparator`方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 `Collections.sort()`.\n\n#### 1.3.1.1. Comparator 定制排序\n\n```java\n        ArrayList<Integer> arrayList = new ArrayList<Integer>();\n        arrayList.add(-1);\n        arrayList.add(3);\n        arrayList.add(3);\n        arrayList.add(-5);\n        arrayList.add(7);\n        arrayList.add(4);\n        arrayList.add(-9);\n        arrayList.add(-7);\n        System.out.println("原始数组:");\n        System.out.println(arrayList);\n        // void reverse(List list)：反转\n        Collections.reverse(arrayList);\n        System.out.println("Collections.reverse(arrayList):");\n        System.out.println(arrayList);\n\n        // void sort(List list),按自然排序的升序排序\n        Collections.sort(arrayList);\n        System.out.println("Collections.sort(arrayList):");\n        System.out.println(arrayList);\n        // 定制排序的用法\n        Collections.sort(arrayList, new Comparator<Integer>() {\n\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return o2.compareTo(o1);\n            }\n        });\n        System.out.println("定制排序后：");\n        System.out.println(arrayList);\n```\n\nOutput:\n\n```\n原始数组:\n[-1, 3, 3, -5, 7, 4, -9, -7]\nCollections.reverse(arrayList):\n[-7, -9, 4, 7, -5, 3, 3, -1]\nCollections.sort(arrayList):\n[-9, -7, -5, -1, 3, 3, 4, 7]\n定制排序后：\n[7, 4, 3, 3, -1, -5, -7, -9]\n```\n\n#### 1.3.1.2. 重写 compareTo 方法实现按年龄来排序\n\n```java\n// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列\n// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他\n// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了\npublic  class Person implements Comparable<Person> {\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        super();\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    /**\n     * T重写compareTo方法实现按年龄来排序\n     */\n    @Override\n    public int compareTo(Person o) {\n        if (this.age > o.getAge()) {\n            return 1;\n        }\n        if (this.age < o.getAge()) {\n            return -1;\n        }\n        return 0;\n    }\n}\n\n```\n\n```java\n    public static void main(String[] args) {\n        TreeMap<Person, String> pdata = new TreeMap<Person, String>();\n        pdata.put(new Person("张三", 30), "zhangsan");\n        pdata.put(new Person("李四", 20), "lisi");\n        pdata.put(new Person("王五", 10), "wangwu");\n        pdata.put(new Person("小红", 5), "xiaohong");\n        // 得到key的值的同时得到key所对应的值\n        Set<Person> keys = pdata.keySet();\n        for (Person key : keys) {\n            System.out.println(key.getAge() + "-" + key.getName());\n\n        }\n    }\n```\n\nOutput：\n\n```\n5-小红\n10-王五\n20-李四\n30-张三\n```\n\n### 1.3.2. 无序性和不可重复性的含义是什么\n\n1、什么是无序性？无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。\n\n2、什么是不可重复性？不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。\n\n### 1.3.3. 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同\n\n`HashSet` 是 `Set` 接口的主要实现类 ，`HashSet` 的底层是 `HashMap`，线程不安全的，可以存储 null 值；\n\n`LinkedHashSet` 是 `HashSet` 的子类，能够按照添加的顺序遍历；\n\n`TreeSet` 底层使用红黑树，元素是有序的，排序的方式有自然排序和定制排序。\n\n## 1.4 Collection 子接口之 Queue\n\n### 1.4.1 Queue 与 Deque 的区别\n\n`Queue` 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 **先进先出（FIFO）** 规则。\n\n`Queue` 扩展了 `Collection` 的接口，根据 **因为容量问题而导致操作失败后处理方式的不同** 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。\n\n| `Queue` 接口| 抛出异常  | 返回特殊值 |\n| ------------ | --------- | ---------- |\n| 插入队尾     | add(E e)  | offer(E e) |\n| 删除队首     | remove()  | poll()     |\n| 查询队首元素 | element() | peek()     |\n\n`Deque` 是双端队列，在队列的两端均可以插入或删除元素。\n\n`Deque` 扩展了 `Queue` 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：\n\n| `Deque` 接口  | 抛出异常      | 返回特殊值      |\n| ------------ | ------------- | --------------- |\n| 插入队首     | addFirst(E e) | offerFirst(E e) |\n| 插入队尾     | addLast(E e)  | offerLast(E e)  |\n| 删除队首     | removeFirst() | pollFirst()     |\n| 删除队尾     | removeLast()  | pollLast()      |\n| 查询队首元素 | getFirst()    | peekFirst()     |\n| 查询队尾元素 | getLast()     | peekLast()      |\n\n事实上，`Deque` 还提供有 `push()` 和 `pop()` 等其他方法，可用于模拟栈。\n\n\n### 1.4.2 ArrayDeque 与 LinkedList 的区别\n\n`ArrayDeque` 和 `LinkedList` 都实现了 `Deque` 接口，两者都具有队列的功能，但两者有什么区别呢？\n\n- `ArrayDeque` 是基于可变长的数组和双指针来实现，而 `LinkedList` 则通过链表来实现。\n\n- `ArrayDeque` 不支持存储 `NULL` 数据，但 `LinkedList` 支持。\n\n- `ArrayDeque` 是在 JDK1.6 才被引入的，而`LinkedList` 早在 JDK1.2 时就已经存在。\n\n- `ArrayDeque` 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 `LinkedList` 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。\n\n从性能的角度上，选用 `ArrayDeque` 来实现队列要比 `LinkedList` 更好。此外，`ArrayDeque` 也可以用于实现栈。\n\n### 1.4.3 说一说 PriorityQueue\n\n`PriorityQueue` 是在 JDK1.5 中被引入的, 其与 `Queue` 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。\n\n这里列举其相关的一些要点：\n\n- `PriorityQueue` 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据\n- `PriorityQueue` 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。\n- `PriorityQueue` 是非线程安全的，且不支持存储 `NULL` 和 `non-comparable` 的对象。\n- `PriorityQueue` 默认是小顶堆，但可以接收一个 `Comparator` 作为构造参数，从而来自定义元素优先级的先后。\n\n`PriorityQueue` 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第K大的数、带权图的遍历等，所以需要会熟练使用才行。\n\n## 1.5. Map 接口\n\n### 1.5.1. HashMap 和 Hashtable 的区别\n\n1. **线程是否安全：** `HashMap` 是非线程安全的，`Hashtable` 是线程安全的,因为 `Hashtable` 内部的方法基本都经过`synchronized` 修饰。（如果你要保证线程安全的话就使用 `ConcurrentHashMap` 吧！）；\n2. **效率：** 因为线程安全的问题，`HashMap` 要比 `Hashtable` 效率高一点。另外，`Hashtable` 基本被淘汰，不要在代码中使用它；\n3. **对 Null key 和 Null value 的支持：** `HashMap` 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 `NullPointerException`。\n4. **初始容量大小和每次扩充容量大小的不同 ：** ① 创建时如果不指定容量初始值，`Hashtable` 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。`HashMap` 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 `HashMap` 会将其扩充为 2 的幂次方大小（`HashMap` 中的`tableSizeFor()`方法保证，下面给出了源代码）。也就是说 `HashMap` 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。\n5. **底层数据结构：** JDK1.8 以后的 `HashMap` 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。\n\n**`HashMap` 中带有初始容量的构造函数：**\n\n```java\n    public HashMap(int initialCapacity, float loadFactor) {\n        if (initialCapacity < 0)\n            throw new IllegalArgumentException("Illegal initial capacity: " +\n                                               initialCapacity);\n        if (initialCapacity > MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor <= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException("Illegal load factor: " +\n                                               loadFactor);\n        this.loadFactor = loadFactor;\n        this.threshold = tableSizeFor(initialCapacity);\n    }\n     public HashMap(int initialCapacity) {\n        this(initialCapacity, DEFAULT_LOAD_FACTOR);\n    }\n```\n\n下面这个方法保证了 `HashMap` 总是使用 2 的幂作为哈希表的大小。\n\n```java\n    /**\n     * Returns a power of two size for the given target capacity.\n     */\n    static final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n```\n\n### 1.5.2. HashMap 和 HashSet 区别\n\n如果你看过 `HashSet` 源码的话就应该知道：`HashSet` 底层就是基于 `HashMap` 实现的。（`HashSet` 的源码非常非常少，因为除了 `clone()`、`writeObject()`、`readObject()`是 `HashSet` 自己不得不实现之外，其他方法都是直接调用 `HashMap` 中的方法。\n\n|               `HashMap`                |                          `HashSet`                           |\n| :------------------------------------: | :----------------------------------------------------------: |\n|           实现了 `Map` 接口            |                       实现 `Set` 接口                        |\n|               存储键值对               |                          仅存储对象                          |\n|     调用 `put()`向 map 中添加元素      |             调用 `add()`方法向 `Set` 中添加元素              |\n| `HashMap` 使用键（Key）计算 `hashcode` | `HashSet` 使用成员对象来计算 `hashcode` 值，对于两个对象来说 `hashcode` 可能相同，所以`equals()`方法用来判断对象的相等性 |\n\n### 1.5.3. HashMap 和 TreeMap 区别\n\n`TreeMap` 和`HashMap` 都继承自`AbstractMap` ，但是需要注意的是`TreeMap`它还实现了`NavigableMap`接口和`SortedMap` 接口。\n\n![](Java集合框架常见面试题.assets/TreeMap继承结构.png)\n\n实现 `NavigableMap` 接口让 `TreeMap` 有了对集合内元素的搜索的能力。\n\n实现`SortedMap`接口让 `TreeMap` 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。示例代码如下：\n\n```java\n/**\n * @author shuang.kou\n * @createTime 2020年06月15日 17:02:00\n */\npublic class Person {\n    private Integer age;\n\n    public Person(Integer age) {\n        this.age = age;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n\n    public static void main(String[] args) {\n        TreeMap<Person, String> treeMap = new TreeMap<>(new Comparator<Person>() {\n            @Override\n            public int compare(Person person1, Person person2) {\n                int num = person1.getAge() - person2.getAge();\n                return Integer.compare(num, 0);\n            }\n        });\n        treeMap.put(new Person(3), "person1");\n        treeMap.put(new Person(18), "person2");\n        treeMap.put(new Person(35), "person3");\n        treeMap.put(new Person(16), "person4");\n        treeMap.entrySet().stream().forEach(personStringEntry -> {\n            System.out.println(personStringEntry.getValue());\n        });\n    }\n}\n```\n\n输出:\n\n```\nperson1\nperson4\nperson2\nperson3\n```\n\n可以看出，`TreeMap` 中的元素已经是按照 `Person` 的 age 字段的升序来排列了。\n\n上面，我们是通过传入匿名内部类的方式实现的，你可以将代码替换成 Lambda 表达式实现的方式：\n\n```java\nTreeMap<Person, String> treeMap = new TreeMap<>((person1, person2) -> {\n  int num = person1.getAge() - person2.getAge();\n  return Integer.compare(num, 0);\n});\n```\n\n**综上，相比于`HashMap`来说 `TreeMap` 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。**\n\n### 1.5.4. HashSet 如何检查重复\n\n以下内容摘自我的 Java 启蒙书《Head first java》第二版：\n\n当你把对象加入`HashSet`时，`HashSet` 会先计算对象的`hashcode`值来判断对象加入的位置，同时也会与其他加入的对象的 `hashcode` 值作比较，如果没有相符的 `hashcode`，`HashSet` 会假设对象没有重复出现。但是如果发现有相同 `hashcode` 值的对象，这时会调用`equals()`方法来检查 `hashcode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让加入操作成功。\n\n在openjdk8中，`HashSet`的`add()`方法只是简单的调用了`HashMap`的`put()`方法，并且判断了一下返回值以确保是否有重复元素。直接看一下`HashSet`中的源码：  \n```java\n// Returns: true if this set did not already contain the specified element\n// 返回值：当set中没有包含add的元素时返回真\npublic boolean add(E e) {\n        return map.put(e, PRESENT)==null;\n}\n```\n\n而在`HashMap`的`putVal()`方法中也能看到如下说明：  \n```java\n// Returns : previous value, or null if none\n// 返回值：如果插入位置没有元素返回null，否则返回上一个元素\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n...\n}\n```\n\n也就是说，在openjdk8中，实际上无论`HashSet`中是否已经存在了某元素，`HashSet`都会直接插入，只是会在`add()`方法的返回值处告诉我们插入前是否存在相同元素。\n\n**`hashCode()`与 `equals()` 的相关规定：**\n\n1. 如果两个对象相等，则 `hashcode` 一定也是相同的\n2. 两个对象相等,对两个 `equals()` 方法返回 true\n3. 两个对象有相同的 `hashcode` 值，它们也不一定是相等的\n4. 综上，`equals()` 方法被覆盖过，则 `hashCode()` 方法也必须被覆盖\n5. `hashCode()`的默认行为是对堆上的对象产生独特值。如果没有重写 `hashCode()`，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。\n\n**==与 equals 的区别**\n\n对于基本类型来说，== 比较的是值是否相等；\n\n对于引用类型来说，== 比较的是两个引用是否指向同一个对象地址（两者在内存中存放的地址（堆内存地址）是否指向同一个地方）；\n\n对于引用类型（包括包装类型）来说，equals 如果没有被重写，对比它们的地址是否相等；如果 equals()方法被重写（例如 String），则比较的是地址里的内容。\n\n### 1.5.5. HashMap 的底层实现\n\n#### 1.5.5.1. JDK1.8 之前\n\nJDK1.8 之前 `HashMap` 底层是 **数组和链表** 结合在一起使用也就是 **链表散列**。**HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) & hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。**\n\n**所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。**\n\n**JDK 1.8 HashMap 的 hash 方法源码:**\n\nJDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。\n\n```java\n    static final int hash(Object key) {\n      int h;\n      // key.hashCode()：返回散列值也就是hashcode\n      // ^ ：按位异或\n      // >>>:无符号右移，忽略符号位，空位都以0补齐\n      return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n  }\n```\n\n对比一下 JDK1.7 的 HashMap 的 hash 方法源码.\n\n```java\nstatic int hash(int h) {\n    // This function ensures that hashCodes that differ only by\n    // constant multiples at each bit position have a bounded\n    // number of collisions (approximately 8 at default load factor).\n\n    h ^= (h >>> 20) ^ (h >>> 12);\n    return h ^ (h >>> 7) ^ (h >>> 4);\n}\n```\n\n相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。\n\n所谓 **“拉链法”** 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。\n\n![jdk1.8之前的内部结构-HashMap](Java集合框架常见面试题.assets/jdk1.8之前的内部结构-HashMap.png)\n\n#### 1.5.5.2. JDK1.8 之后\n\n相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。\n\n![jdk1.8之后的内部结构-HashMap](Java集合框架常见面试题.assets/jdk1.8之后的内部结构-HashMap.png)\n\n> TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。\n\n### 1.5.6. HashMap 的长度为什么是 2 的幂次方\n\n为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ `(n - 1) & hash`”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。\n\n**这个算法应该如何设计呢？**\n\n我们首先可能会想到采用%取余的操作来实现。但是，重点来了：**“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&)操作（也就是说 hash%length==hash&(length-1)的前提是 length 是 2 的 n 次方；）。”** 并且 **采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。**\n\n### 1.5.7. HashMap 多线程操作导致死循环问题\n\n主要原因在于并发下的 Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。\n\n详情请查看：<https://coolshell.cn/articles/9606.html>\n\n### 1.5.8. HashMap 有哪几种常见的遍历方式?\n\n[HashMap 的 7 种遍历方式与性能分析！](https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw)\n\n### 1.5.9. ConcurrentHashMap 和 Hashtable 的区别\n\n`ConcurrentHashMap` 和 `Hashtable` 的区别主要体现在实现线程安全的方式上不同。\n\n- **底层数据结构：** JDK1.7 的 `ConcurrentHashMap` 底层采用 **分段的数组+链表** 实现，JDK1.8 采用的数据结构跟 `HashMap1.8` 的结构一样，数组+链表/红黑二叉树。`Hashtable` 和 JDK1.8 之前的 `HashMap` 的底层数据结构类似都是采用 **数组+链表** 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；\n- **实现线程安全的方式（重要）：** ① **在 JDK1.7 的时候，`ConcurrentHashMap`（分段锁）** 对整个桶数组进行了分割分段(`Segment`)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 **到了 JDK1.8 的时候已经摒弃了 `Segment` 的概念，而是直接用 `Node` 数组+链表+红黑树的数据结构来实现，并发控制使用 `synchronized` 和 CAS 来操作。（JDK1.6 以后 对 `synchronized` 锁做了很多优化）** 整个看起来就像是优化过且线程安全的 `HashMap`，虽然在 JDK1.8 中还能看到 `Segment` 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② **`Hashtable`(同一把锁)** :使用 `synchronized` 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。\n\n**两者的对比图：**\n\n**Hashtable:**\n\n![Hashtable全表锁](Java集合框架常见面试题.assets/HashTable全表锁.png)\n\n<p style="text-align:right;font-size:13px;color:gray">https://www.cnblogs.com/chengxiao/p/6842045.html></p>\n\n**JDK1.7 的 ConcurrentHashMap：**\n\n![JDK1.7的ConcurrentHashMap](Java集合框架常见面试题.assets/ConcurrentHashMap分段锁.jpg)\n\n<p style="text-align:right;font-size:13px;color:gray">https://www.cnblogs.com/chengxiao/p/6842045.html></p>\n\n**JDK1.8 的 ConcurrentHashMap：**\n\n![Java8 ConcurrentHashMap 存储结构（图片来自 javadoop）](Java集合框架常见面试题.assets/java8_concurrenthashmap.png)\n\nJDK1.8 的 `ConcurrentHashMap` 不再是 **Segment 数组 + HashEntry 数组 + 链表**，而是 **Node 数组 + 链表 / 红黑树**。不过，Node 只能用于链表的情况，红黑树的情况需要使用 **`TreeNode`**。当冲突链表达到一定长度时，链表会转换成红黑树。\n\n### 1.5.10. ConcurrentHashMap 线程安全的具体实现方式/底层具体实现\n\n#### 1.5.10.1. JDK1.7（上面有示意图）\n\n首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。\n\n**`ConcurrentHashMap` 是由 `Segment` 数组结构和 `HashEntry` 数组结构组成**。\n\nSegment 实现了 `ReentrantLock`,所以 `Segment` 是一种可重入锁，扮演锁的角色。`HashEntry` 用于存储键值对数据。\n\n```java\nstatic class Segment<K,V> extends ReentrantLock implements Serializable {\n}\n```\n\n一个 `ConcurrentHashMap` 里包含一个 `Segment` 数组。`Segment` 的结构和 `HashMap` 类似，是一种数组和链表结构，一个 `Segment` 包含一个 `HashEntry` 数组，每个 `HashEntry` 是一个链表结构的元素，每个 `Segment` 守护着一个 `HashEntry` 数组里的元素，当对 `HashEntry` 数组的数据进行修改时，必须首先获得对应的 `Segment` 的锁。\n\n#### 1.5.10.2. JDK1.8 （上面有示意图）\n\n`ConcurrentHashMap` 取消了 `Segment` 分段锁，采用 CAS 和 `synchronized` 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）\n\n`synchronized` 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。\n\n## 1.6. Collections 工具类\n\nCollections 工具类常用方法:\n\n1. 排序\n2. 查找,替换操作\n3. 同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)\n\n### 1.6.1. 排序操作\n\n```java\nvoid reverse(List list)//反转\nvoid shuffle(List list)//随机排序\nvoid sort(List list)//按自然排序的升序排序\nvoid sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑\nvoid swap(List list, int i , int j)//交换两个索引位置的元素\nvoid rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面\n```\n\n### 1.6.2. 查找,替换操作\n\n```java\nint binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的\nint max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)\nint max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)\nvoid fill(List list, Object obj)//用指定的元素代替指定list中的所有元素\nint frequency(Collection c, Object o)//统计元素出现次数\nint indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)\nboolean replaceAll(List list, Object oldVal, Object newVal)//用新元素替换旧元素\n```\n\n### 1.6.3. 同步控制\n\n`Collections` 提供了多个`synchronizedXxx()`方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。\n\n我们知道 `HashSet`，`TreeSet`，`ArrayList`,`LinkedList`,`HashMap`,`TreeMap` 都是线程不安全的。`Collections` 提供了多个静态方法可以把他们包装成线程同步的集合。\n\n**最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合。**\n\n方法如下：\n\n```java\nsynchronizedCollection(Collection<T>  c) //返回指定 collection 支持的同步（线程安全的）collection。\nsynchronizedList(List<T> list)//返回指定列表支持的同步（线程安全的）List。\nsynchronizedMap(Map<K,V> m) //返回由指定映射支持的同步（线程安全的）Map。\nsynchronizedSet(Set<T> s) //返回指定 set 支持的同步（线程安全的）set。\n```\n\n'},ce37:function(n,e,t){"use strict";t.r(e),e["default"]='# spring 事务\n\n## 1)事务回顾\n\n### 1.1)什么是事务？\n\n事务指数据库中多个操作合并在一起形成的操作序列\n\n### 1.2)事务的作用\n\n1.当数据库操作序列中个别操作失败时，提供一种方式使数据库状态恢复到正常状态（**A**），保障数据库即使在异常状态下仍能保持数据一致性（**C**）（要么操作前状态，要么操作后状态）。\n\n2.当出现并发访问数据库时，在多个访问间进行相互隔离，防止并发访问操作结果互相干扰（**I**）。\n\n- 事务特征（ACID）\n\n  - 原子性（Atomicity）指事务是一个不可分割的整体，其中的操作要么全执行或全不执行\n\n  - 一致性（Consistency）事务前后数据的完整性必须保持一致\n\n  - 隔离性（Isolation）事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离\n\n  - 持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响\n\n### 1.3)事务的隔离级\n\n- 脏读：允许读取未提交的信息\n\n  - 原因：Read uncommitted\n\n  解决方案： （表级读锁）\n\n![1591321851725](./Spring-day04/1591321851725.png)\n\n- 不可重复读：读取过程中单个数据发生了变化\n  - 解决方案： Repeatable read （行级写锁）\n\n![1591321927034](./Spring-day04/1591321927034.png)\n\n- 幻读：读取过程中数据条目发生了变化\n  - 解决方案： Serializable（表级写锁）\n\n![1591321959641](./Spring-day04/1591321959641.png)\n\n\n\n## 2)事务管理\n\n### 2.1)**Spring**事务核心对象\n\n- J2EE开发使用分层设计的思想进行，对于简单的业务层转调数据层的单一操作，事务开启在业务层或者数据层并无太大差别，当业务中包含多个数据层的调用时，需要在业务层开启事务，对数据层中多个操作进行组合并归属于同一个事务进行处理\n\n- Spring为业务层提供了整套的事务解决方案\n\n  - PlatformTransactionManager\n  - TransactionDefinition\n\n  - TransactionStatus\n\n### **2.2)PlatformTransactionManager**\n\n- 平台事务管理器实现类\n\n  - DataSourceTransactionManager  适用于Spring JDBC或MyBatis\n\n  - HibernateTransactionManager  适用于Hibernate3.0及以上版本\n\n  - JpaTransactionManager  适用于JPA\n\n  - JdoTransactionManager  适用于JDO\n\n  - JtaTransactionManager  适用于JTA\n\n\n\n- JPA（Java Persistence API）Java EE 标准之一，为POJO提供持久化标准规范，并规范了持久化开发的统一API，符合JPA规范的开发可以在不同的JPA框架下运行\n\n- JDO(Java Data Object )是Java对象持久化规范，用于存取某种数据库中的对象，并提供标准化API。与JDBC相比，JDBC仅针对关系数据库进行操作，JDO可以扩展到关系数据库、文件、XML、对象数据库（ODBMS）等，可移植性更强\n\n- JTA（Java Transaction API）Java EE 标准之一，允许应用程序执行分布式事务处理。与JDBC相比，JDBC事务则被限定在一个单一的数据库连接，而一个JTA事务可以有多个参与者，比如JDBC连接、JDO 都可以参与到一个JTA事务中\n\n此接口定义了事务的基本操作\n\n- 获取事务 ：\n\n  ```java\n  TransactionStatus getTransaction(TransactionDefinition definition)\n  ```\n\n- 提交事务 ：\n\n  ```java\n  void commit(TransactionStatus status) \n  ```\n\n- 回滚事务 ：\n\n  ```java\n  void rollback(TransactionStatus status)\n  ```\n\n### **2.3)TransactionDefinition**\n\n此接口定义了事务的基本信息\n\n- 获取事务定义名称\n\n  ```java\n  String getName()\n  ```\n\n- 获取事务的读写属性\n\n  ```java\n  boolean isReadOnly()\n  ```\n\n- 获取事务隔离级别\n\n  ```java\n  int getIsolationLevel()\n  ```\n\n- 获事务超时时间\n\n  ```java\n  int getTimeout()\n  ```\n\n- 获取事务传播行为特征\n\n  ```java\n  int getPropagationBehavior()\n  ```\n\n### **2.4)TransactionStatus**\n\n此接口定义了事务在执行过程中某个时间点上的状态信息及对应的状态操作\n\n![1591322466820](./Spring-day04/1591322466820.png)\n\n### **2.5)事务控制方式**\n\n- 编程式\n\n- 声明式（XML）\n\n- 声明式（注解）\n\n### **2.6)案例说明**\n\n#### 2.6.1)案例说明\n\n银行转账业务说明\n\n银行转账操作中，涉及从A账户到B账户的资金转移操作。数据层仅提供单条数据的基础操作，未设计多账户间的业务操作。\n\n#### 2.6.2)案例环境（基于Spring、Mybatis整合）\n\n- 业务层接口提供转账操作\n\n```java\n/**\n* 转账操作\n* @param outName     出账用户名\n* @param inName      入账用户名\n* @param money       转账金额\n*/\npublic void transfer(String outName,String inName,Double money);\n```\n\n- 业务层实现提供转账操作\n\n```java\npublic void transfer(String outName,String inName,Double money){\n    accountDao.inMoney(outName,money);                                                       accountDao.outMoney(inName,money);\n}\n```\n\n- 数据层提供对应的入账与出账操作\n\n```xml\n<update id="inMoney">\n\tupdate account set money = money + #{money} where name = #{name}\n</update>\n<update id="outMoney">\n\tupdate account set money = money - #{money} where name = #{name}\n</update>\n```\n\n#### **2.6.3)编程式事务**\n\n```java\npublic void transfer(String outName,String inName,Double money){\n    //创建事务管理器\n    DataSourceTransactionManager dstm = new DataSourceTransactionManager();\n    //为事务管理器设置与数据层相同的数据源\n    dstm.setDataSource(dataSource);\n    //创建事务定义对象\n    TransactionDefinition td = new DefaultTransactionDefinition();\n    //创建事务状态对象，用于控制事务执行\n    TransactionStatus ts = dstm.getTransaction(td);\n    accountDao.inMoney(outName,money);\n    int i = 1/0;    //模拟业务层事务过程中出现错误\n    accountDao.outMoney(inName,money);\n    //提交事务\n    dstm.commit(ts);\n}\n```\n\n### 2.7)使用AOP控制事务\n\n将业务层的事务处理功能抽取出来制作成AOP通知，利用环绕通知运行期动态织入\n\n```java\npublic Object tx(ProceedingJoinPoint pjp) throws Throwable {\n    \n    DataSourceTransactionManager dstm = new DataSourceTransactionManager();\n    dstm.setDataSource(dataSource);\n    TransactionDefinition td = new DefaultTransactionDefinition();\n    TransactionStatus ts = dstm.getTransaction(td);\n    Object ret = pjp.proceed(pjp.getArgs());\n    dstm.commit(ts);\n    \n    return ret;\n}\n```\n\n配置AOP通知类，并注入dataSource\n\n```xml\n<bean id="txAdvice" class="com.itheima.aop.TxAdvice">\n    <property name="dataSource" ref="dataSource"/>\n</bean>\n```\n\n使用环绕通知将通知类织入到原始业务对象执行过程中\n\n```xml\n<aop:config>\n    <aop:pointcut id="pt" expression="execution(* *..transfer(..))"/>\n    <aop:aspect ref="txAdvice">\n        <aop:around method="tx" pointcut-ref="pt"/>\n    </aop:aspect>\n</aop:config>\n```\n\n### **2.8声明式事务（XML）**\n\n**AOP**配置事务是否具有特例性？\n\n```java\npublic Object tx(ProceedingJoinPoint pjp) throws Throwable {\n    DataSourceTransactionManager dstm = new DataSourceTransactionManager();\n    dstm.setDataSource(dataSource);\n    TransactionDefinition td = new DefaultTransactionDefinition();\n    TransactionStatus ts = dstm.getTransaction(td);\n    Object ret = pjp.proceed(pjp.getArgs());\n    dstm.commit(ts);\n\n    return ret;\n}\n```\n\n```xml\n<bean id="txAdvice" class="com.itheima.aop.TxAdvice">\n\t<property name="dataSource" ref="dataSource"/>\n</bean>\n```\n\n使用tx命名空间配置事务专属通知类\n\n```xml\n<tx:advice id="txAdvice" transaction-manager="txManager">\n    <tx:attributes>\n        <tx:method name="*" read-only="false" />\n        <tx:method name="get*" read-only="true" />\n        <tx:method name="find*" read-only="true" />\n    </tx:attributes>\n</tx:advice>\n```\n\n使用aop:advisor在AOP配置中引用事务专属通知类\n\n```xml\n<aop:config>\n    <aop:pointcut id="pt" expression="execution(* *..*(..))"/>\n    <aop:advisor advice-ref="txAdvice" pointcut-ref="pt"/>\n</aop:config>\n```\n\n#### 2.8.1)**aop:advice与aop:advisor区别**\n\n- aop:advice配置的通知类可以是普通java对象，不实现接口，也不使用继承关系\n\n- aop:advisor配置的通知类必须实现通知接口\n\n  - MethodBeforeAdvice\n\n  - AfterReturningAdvice\n\n  - ThrowsAdvice\n\n  - ……\n\n#### 2.8.2)tx配置----tx:advice\n\n- 名称：tx:advice\n\n- 类型：**标签**\n\n- 归属：beans标签\n\n- 作用：专用于声明事务通知\n\n- 格式：\n\n  ```xml\n  <beans>\n      <tx:advice id="txAdvice" transaction-manager="txManager">\n      </tx:advice>\n  </beans>\n  ```\n\n- 基本属性：\n\n  - id ：用于配置aop时指定通知器的id\n\n  - transaction-manager ：指定事务管理器bean\n\n#### 2.8.3)tx配置----tx:attributes\n\n- 名称：tx:attributes\n\n- 类型：**标签**\n\n- 归属：tx:advice标签\n\n- 作用：定义通知属性\n\n- 格式：\n\n  ```xml\n  <tx:advice id="txAdvice" transaction-manager="txManager">\n      <tx:attributes>\n      </tx:attributes>\n  </tx:advice>\n  ```\n\n- 基本属性：\n\n  - 无\n\n#### 2.8.4)tx配置----tx:method\n\n- 名称：tx:method\n\n- 类型：**标签**\n\n- 归属：tx:attribute标签\n\n- 作用：设置具体的事务属性\n\n- 格式：\n\n  ```xml\n  <tx:attributes>\n      <tx:method name="*" read-only="false" />\n      <tx:method name="get*" read-only="true" />\n  </tx:attributes>\n  ```\n\n- 说明：\n\n  通常事务属性会配置多个，包含1个读写的全事务属性，1个只读的查询类事务属性\n\n**tx:method属性**\n\n![1591367291135](./Spring-day04/1591367291135.png)\n\n### **2.9)事务传播行为**\n\n- 事务管理员\n\n- 事务协调员\n\n![1591367347482](./Spring-day04/1591367347482.png)\n\n- 事务传播行为描述的是事务协调员对事务管理员所携带事务的处理态度\n\n### **2.10)事务传播行为**\n\n![1591367375088](./Spring-day04/1591367375088.png)\n\n### **2.11)事务传播应用**\n\n- 场景A：生成订单业务\n\n  - 子业务S1：记录日志到数据库表X\n\n  - 子业务S2：保存订单数据到数据库表Y\n\n  - 子业务S3：……\n\n  - 如果S2或S3或……事务提交失败，此时S1是否回滚？如何控制？\n\n  - （S1需要新事务）\n\n- 场景B：生成订单业务\n\n  - 背景1：订单号生成依赖数据库中一个专门用于控制订单号编号生成的表M获取\n\n  - 背景2：每次获取完订单号，表M中记录的编号自增1\n\n  - 子业务S1：从表M中获取订单编号\n\n  - 子业务S2：保存订单数据，订单编号来自于表M\n\n  - 子业务S3：……\n\n  - 如果S2或S3或……事务提交失败，此时S1是否回滚？如何控制？\n\n  - （S1需要新事务）\n\n### **2.12)声明式事务（注解）**\n\n#### 2.12.1)@Transactional\n\n- 名称：@Transactional\n\n- 类型：**方法注解，类注解，接口注解**\n\n- 位置：方法定义上方，类定义上方，接口定义上方\n\n- 作用：设置当前类/接口中所有方法或具体方法开启事务，并指定相关事务属性\n\n- 范例：\n\n  ```java\n  @Transactional(\n      readOnly = false,\n      timeout = -1,\n      isolation = Isolation.DEFAULT,\n      rollbackFor = {ArithmeticException.class, IOException.class},\n      noRollbackFor = {},\n      propagation = Propagation.REQUIRES_NEW\n  )\n  ```\n\n#### 2.12.2)tx:annotation-driven\n\n- 名称：tx:annotation-driven\n\n- 类型：**标签**\n\n- 归属：beans标签\n\n- 作用：开启事务注解驱动，并指定对应的事务管理器\n\n- 范例：\n\n  ```xml\n  <tx:annotation-driven transaction-manager="txManager"/>\n  ```\n\n### **2.13)声明式事务（纯注解驱动）**\n\n- 名称：@EnableTransactionManagement\n\n- 类型：**类注解**\n\n- 位置：Spring注解配置类上方\n\n- 作用：开启注解驱动，等同XML格式中的注解驱动\n\n- 范例：\n\n  ```java\n  @Configuration\n  @ComponentScan("com.itheima")\n  @PropertySource("classpath:jdbc.properties")\n  @Import({JDBCConfig.class,MyBatisConfig.class,TransactionManagerConfig.class})\n  @EnableTransactionManagement\n  public class SpringConfig {\n  }\n  ```\n\n  ```java\n  public class TransactionManagerConfig {\n      @Bean\n      public PlatformTransactionManager getTransactionManager(@Autowired DataSource dataSource){\n          return new DataSourceTransactionManager(dataSource);\n      }\n  }\n  ```\n\n## 3)模板对象\n\n### 3.1)Spring模块对象\n\n![1591368087398](./Spring-day04/1591368087398.png)\n\n- TransactionTemplate\n\n- JdbcTemplate\n\n- RedisTemplate\n\n- RabbitTemplate\n\n- JmsTemplate\n\n- HibernateTemplate\n\n- RestTemplate\n\n### 3.2)JdbcTemplate（了解）\n\n提供标准的sql语句操作API\n\n```java\npublic void save(Account account) {\n    String sql = "insert into account(name,money)values(?,?)";\n    jdbcTemplate.update(sql,account.getName(),account.getMoney());\n}\n```\n\n### 3.3)NamedParameterJdbcTemplate(了解）\n\n提供标准的具名sql语句操作API\n\n```java\npublic void save(Account account) {\n    String sql = "insert into account(name,money)values(:name,:money)";\n    Map pm = new HashMap();\n    pm.put("name",account.getName());\n    pm.put("money",account.getMoney());\n    jdbcTemplate.update(sql,pm);\n}\n```\n\n### **3.4)RedisTemplate**\n\nRedisTemplate对象结构\n\n![1591368270508](./Spring-day04/1591368270508.png)\n\n```java\npublic void changeMoney(Integer id, Double money) {\n    redisTemplate.opsForValue().set("account:id:"+id,money);\n}\npublic Double findMondyById(Integer id) {\n    Object money = redisTemplate.opsForValue().get("account:id:" + id);\n    return new Double(money.toString());\n}\n```\n\n\n\n## 4)事务底层原理解析\n\n### **4.1)策略模式应用**\n\n策略模式（Strategy Pattern）使用不同策略的对象实现不同的行为方式，策略对象的变化导致行为的变化。\n\n![1591368340720](./Spring-day04/1591368340720.png)\n\n策略模式（Strategy Pattern）使用不同策略的对象实现不同的行为方式，策略对象的变化导致行为的变化。\n\n![1591368370924](./Spring-day04/1591368370924.png)\n\n'},d16c:function(n,e,t){"use strict";t.r(e),e["default"]='     \r\n      JAVA 基础\r\n         基本环境 \r\n       \r\n        java SE ME  EE \r\n        跨平台  -- jvm 虚拟机  jvm 虚拟机本身 不能跨平台 java 程序在 不同平台的不同的 jvm 虚拟机  运行\r\n        JRE JDK JVM 作用 \r\n        开发java : 编写代码 编译代码  运行代码 \r\n        JRE : JAVA  Runtime Enviroment   包含 JVM 虚拟机 和 JAVA 核心 类库  \r\n        类= java 文件 ，每个 java 文件是一个 Java 类 \r\n        核心类库：  java 已写好的 非常核心的 代码仓库  ，很多个java  核心 类 文件 \r\n        代码中 会用到 java 存放在 JRE 中 写好的 核心 java 文件 比如： System   String Number \r\n        java 文件的 编译 是使用 java JDK 中的  编译工具 进行编译 ，编译为 jvm 能够识别运行的 程序文件 \r\n        JDK : JAVA development Kit  Java 语言的 软件开发工具包 ，内部包含了 代码的 编译工具和 运行工具 \r\n        流程：1.使用JDK中的编译工具编译 .java  文件到      .class 字节码文件，\r\n              2.使用JDK中的运行工具 将  .class 文件运行在  JVM 虚拟机当中  \r\n        总结：1. 编写代码 需要使用 JRE 中 java 已经写好的 代码 （核心类库）\r\n              2. 编译代码 需要使用 JDK 中 的 编译工具\r\n              3. 运行代码 需要使用 JDK 中 的  运行工具\r\n              4. 代码运行在  JVM 虚拟机当中  \r\n         JDK=( JRE=(JVM 虚拟机 + 核心类库)  + 开发工具=（编译工具 + 运行工具） )    \r\n         系统环境变量 添加变量 Java_Home  D:\\Program Files\\Java\\jdk1.8.0_91\r\n                       path 编辑 新建    %Java_Home%\\bin    %Java_Home%\\jre\\bin           \r\n        javac  AAA.java  执行生成 AAA.class 文件 \r\n        java  AAA    执行 AAA.class 文件 \r\n        main 方法 程序的 入口点\r\n        public static void main(String[] args ){\r\n        }\r\n        public 确保 文件名称和 类名 必须 同名         \r\n        java 关键字  基本  都是小写的\r\n       \r\n      数据类型 \r\n       \r\n           java 有字符串 和 字符 区别  字符串 双引号 任意个字符    字符 单引号 且只能1个字符 \r\n          不同数据类型  占用内存空间\r\n          byte 1 short 2 int 4 long 8     float 4 double 8  char 2 boolean 1 \r\n          引用数据类型： class interface  array\r\n          基本数据类型  整数 浮点数 字符  布尔 \r\n          int a = 1;\r\n          float b = 1.36F; float 类型 不加 F 标识， 则默认 double 类型转换 会报错 丢失精度\r\n          long c = 556188L; long 类型  后面加 L 标识\r\n        数据范围关系 从小到大\r\n        byte, (short=char) , int ,long ,float ,double \r\n        隐式转换 小的直接变大的\r\n        运算过程中，小的会先提升为大的，当类型统一之后，再进行运算 。 同类型 运算\r\n        byte short char 三种数据类型在运算的时候，不管是否有更高的数据类型，都会提升为 int 然后再运算\r\n        也就是 最低隐士转换为 int 类型 ， 结果 最低是 int 类型\r\n        强制转换  大的转小的 强转格式 ： int a=10; byte b= (byte)a;   强转可能丢失精度\r\n        byte d =3+4 ; java 中存在常量优化机制：\r\n         根据常量计算的结果 判定是否在类型范围内，在就编译通过，不在就报错\r\n            java 变量作用域： 只在 变量所在的大括号内有用 \r\n         java 整数相除 结果是整数  10/3 = 3    10/3.0 = 3.333333...\r\n         \t char b = \'a\';\t int c= b +20;  结果  c = 117 ; 字节 a 对应的 ASCII 码表 97 \r\n              1+99+“年” = "100年"\r\n               &  并且 |  或者 ！ 非 ^ 异或      && || 短路 效果\r\n               &  |无论如何 左右都会执行 && || 有短路效果 左边值能确定结果 则 右边不执行\r\n        break continue 只能跳出自己所在的那一层关系。\r\n        如果想要跳出跳过置顶一层，可以加入标号。\r\n        IDEA 目录层级关系： project - module - package - class \r\n        快捷键：\r\n        ctrl+shirt+a    ctrl+alt+v   ctrl+alt+m 包裹方法\r\n        psvm ，sout , alt+1，alt+4 ,ctrl+alt+l ,alt+enter   ,ctrl+b 跟进源码\r\n        数组 int[] arr= new int[30]  初始化定义一个长度是30的数组\r\n             int arr[] =new int[30]\r\n        sout 输出 数组 变量 输出的是 数组的 内存地址 \r\n        java 内存分配： \r\n        栈内存 ： 方法运行时，进入的内存，局部变量都存放于这块内存中，\r\n        堆内存 ： new 出来的内容都会进入堆内存，并且会有对应的地址值\r\n        方法区 ： 字节码文件 .class 加载时进入的内存 \r\n        本地方法栈 ：调用操作系统相关的资源\r\n        寄存器： 交给CPU 去使用\r\n        类的加载过程：\r\n        1.类的字节码文件加载进方法区 main 方法存放在自己吗文件中\r\n        2.main方法被jvm 自动调用进入栈内存中执行\r\n        3. 因为main 方法在 栈内存 ，创建变量 也在 栈内存\r\n        4.new 方法创建的实例放在堆内存中 ， 有 内存地址，并且有默认初始化值。\r\n          把地址值给到 变量。（因此打印数组，打印出来的是内存地址）\r\n        java 数组默认值\r\n        整数型 0  浮点数 0.0 布尔 false 字符  空字符  引用数据类型 null  \r\n        int[] arr=new int[]{5,7,8,999};    \r\n        int[] arr={5,7,8,999};     arr[0]   \r\n        方法定义：\r\n        格式：\r\n         public static void aaa(int num){  //方法体 }\r\n         public static int aaa(int num){   return 100; //方法体 }  int bb = aaa(30);\r\n         public static int[] aaa(int[] arr){   int[] b={1,2,3}    return b //方法体 }  int[] cc = aaa(arr) \r\n        方法和方法之间 是平级 关系 ，不能嵌套定义\r\n        栈内存： 手枪弹夹  先进后出\r\n        方法参数类型 和个数 必须匹配 \r\n        方法的形参，相当于一个局部变量\r\n        方法重载： java 允许 多个个相同方法名，但是形参不同的方法存在。（个数，类型，顺序）\r\n                   Java jvm 会通过 参数去匹配调用哪个方法  \r\n        方法参数传递：\r\n                基本数据类型 ，传递的是值本身，改变传入值，是改变的这个值 ，对其他无影响。不影响原始值\r\n                引用数据类型 ，传递的是 内存地址 。 改变的是堆内存内的数据。会改变传入的数据本身\r\n         原码 反码 补码\r\n         计算机中的数据都是以二进制补码的形式在运算，而补码则是通过反码和原码推算出来的。 \r\n         原码： 看数据 ，反码：转数据 ，补码：运算数据\r\n         原码 ：\r\n         二进制的定点表示法。最高位是符号位。 0 代表正 1代表负值 其余位数表示值的大小\r\n         一个字节等于8个比特位 ，也就是 8个二进制位\r\n         byte b1 = 7  ;   0(符号位)0000111    byte b2 = -7 ; 1(符号位) 0000111\r\n         反码：\r\n         正数的反码与其原码相同 ； 负数的反码与其原码逐位取反（0变1 ， 1 变 0），符号位除外\r\n         补码：\r\n         正数的补码与其原码相同 ； 负数的补码是在其 反码  的末位 加 1 得到的 \r\n         二维数组\r\n         int[][] arr 或者   int arr[][]   或者    int[] arr[]  \r\n          int[][] arr = mew int[30][10];  30个一维数组 ，每个一维数组有10个元素\r\n        \r\n        \r\n            方法执行完成 弹栈消失\r\n        \r\n        \r\n           类文件在方法区 ，对象实例在堆内存 ， \r\n           对象实例的方法地址指向方法区的类文件内的方法\r\n          变量在栈内存，地址指向堆内存中的类的实例对象\r\n           方法的调用， 类的实例对象的方法的调用 会进栈 \r\n          类的主方法 main 方法 会被 jvm 主动调用 ，然后 main 方法 进栈\r\n           代码由上往下执行， 方法顺序进栈  ， 栈内 方法 先进后出。\r\n           最后调用的方法完成执行后 最先消失 \r\n           当方法 执行完成 弹栈 消失\r\n           \r\n    \r\n    基础\r\n        \r\n           单个实例对象的 实例在 堆内存中 ，实例的  成员属性在堆内存，\r\n          成员方法 在方法区 ，但是堆内存中存有 成员方法的内存地址\r\n          成员变量： \r\n          类中方法外的变量 ，有初始默认值 ，堆内存 ，随对象GC 消失\r\n          局部变量：\r\n          类中方法内的变量 ，无初始默认值， 栈内存 ，随着方法的执行完成弹栈消失\r\n          private 权限修饰符 \r\n          私有 保证数据安全 ，需要根基需求提供 set 和 get 方法 获取 和设置 私有 成员属性 \r\n          java 类的 构造方法\r\n          1.方法名称和类名相同，大小写一致\r\n          2.没有返回值类型，连 void 也没有\r\n          3.没有具体的返回值 ，不能 由 return 带回 结果数据\r\n    \r\n          java 类的 构造方法 可以通过 方法的 重载 通过不同的参数 进行 不同 的 初始化\r\n       \r\n       String\r\n       \r\n         "" 创建的字符串  存在 字符串常量池   （在  堆内存 存储 ） 存在则不再创建  ,不可改变\r\n         s1 = "123"  s2 = "123"  s1==s2 结果是true \r\n         new 创建的 每次都是不同的 内存地址 放在 堆内存中 new 创建的  不可能相等\r\n         字符串的加号拼接 ：系统底层会自动创建一个 stringBuilder 对象 ，\r\n         再调用其append 方法完成拼接 。拼接后，再调用toString 方法 转换为 String 类型\r\n         因此  s1="abc"  s2="ab"  s3=s2+"c"   s1==s3   s3 是变量计算拼接 不是常量拼接  返回  false  \r\n         "abc" == "a" + "b" + "c"  返回 true 原因 ：\r\n          a,b,c 都是常量 java 的 常量优化机制 在编译的时候 就把右侧直接计算了\r\n          equals 方法 比较 值是否相等\r\n          String 类型 + 常量字符串 的 字符串拼接每次都会创建 两个对象 ，一个 stringBuilder 一个 string \r\n       \r\n       StringBuilder   一个可变的字符串类   append toString  reverce\r\n       打印string  stringBuilder 集合 类  都不会出现内存地址。  打印数组  会出现 \r\n       集合 ArrayList\r\n       \r\n           Student[] arr = new Student[3]  \r\n    \r\n        集合和数组 对比\r\n        集合类 ：  提供一种存储空间可变的存储模型，容量可变\r\n        数组类 ：   容量是固定的 不可变的 \r\n        ArrayList  list = new ArrayList();\r\n        集合内 可以放任意类型数据      \r\n        泛型\r\n        ArrayList&lt;String&gt;  list = new ArrayList &lt;&gt;();\r\n        集合内 只能放 字符串 String 数据   \r\n        集合常用API :   add remove  set  get size        \r\n       \r\n             高级面向对象 \r\n       \r\n            业务对象类  本身  \r\n            DAO  访问存储数据的数组 或者集合  data access object\r\n            Service  用来 处理业务逻辑 ，服务器内部的 逻辑\r\n            Controller  用来 处理     用户  和网页 的相关 逻辑  \r\n            业务逻辑流程：\r\n            controller 的 addItem 调用 service  的 addItem , service  的 addItem 调用 dao 的 addItem\r\n           与试图打交道的 类 调用 与数据库打交道的类 ，与数据库打交道的类 调用 数据库类\r\n    \r\n            private  static  ， static 修饰的  静态成员属性 在内存中 所有这个类的实例中共享\r\n             一般 存在于方法区中 \r\n       \r\n       继承\r\n       \r\n           继承： 让类鱼类之间产生 父子类关系 ， 子类可以直接使用 父类的非私有的成员  \r\n                  例如 你可以用你爸爸的车 ，但你不能用他的内裤 \r\n                  父类 ： 基类 超类   子类 ： 派生类 \r\n                  public class ZI extends FU { }\r\n            继承好处：复用性，维护性，让类之间产生关系是多态的前台\r\n            继承弊端：继承是侵入性的 ，不灵活 ，子类   必须拥有父类的非私有属性和方法\r\n                      耦合性强   父类中 非私有的东西 不能随便改 随便删除 \r\n            JAVA 只支持 单继承 ，不支持 多继承 ，但是 支持多层继承  \r\n             一个儿子不能 有两个亲爹 ，但是可以 有 爷爷 ， 有十八辈祖宗    \r\n             this  自己的 当前类的  super  父级的   父类的 \r\n             this() 访问本类的构造方法  super()访问父类的构造方法\r\n            子父类同名属性或者方法：    可以通过 this.  读取 自己的 属性方法   ，super. 读取 父级的 属性方法\r\n            \r\n            方法 重写  ， 注解  @Override 检查 是否 正确重写 （必须一模一样）\r\n            \r\n                父类的静态方法，个非静态方法 ， 子类必须一摸一样的名字才能重写 \r\n                \r\n                静态方法不能重写，父子类静态方法同名 ，只是子类将父类中的同名方法隐藏起来了。  就近原则\r\n            \r\n            子类 重写 父类 方法 ， 权限必须大于等于 父类 权限 \r\n            java  四个 权限修饰符   private  小于 默认 小于 protected  小于 public \r\n            private  同一个类中\r\n            默认     同一个包中 子类 无关类\r\n            protected 不同包的子类\r\n            public   不同包的 无关类\r\n    \r\n            子类的  构造方法 会默认调用 super() ；即便是不写 ，也会默认加上。不然子类没办法拿到继承而来的东西\r\n    \r\n            其实每一个类  都继承与 Objiect  类 如果没 指定继承则该类的构造方法 默认 继承自 Object 默认调用 super()\r\n    \r\n            抽象类   abstract\r\n            抽象方法： 将共性的方法 抽取到父类之中后，发现该方法的实现逻辑无法确定，该方法就要可以定义为抽象方法\r\n            抽象类： 如果一个类中 存在 抽象方法 ，那么这个类 就必须 声明为 抽象类\r\n            public  abstract void aa();  \r\n            public  abstract class  A1{}\r\n            public  class A99  extends A1{}\r\n            抽象类 只能被 继承 实现 。 不能创建 实例对象。因为 没有方法体的方法 不能调用。\r\n            抽象类的 子类 必须 重写 父类的  抽象方法 ， 但是 子类也可以把自己变成 抽象类。\r\n            抽象类 不一定有抽象方法， 有抽象方法的类 必定是抽象方法 \r\n    \r\n            抽象类  体现的是 一种  模板设计模式  \r\n            final 关键字 可以修饰 属性 方法 类名   ，final 修饰的 属性方法 将不能重写 ，类不能  继承 ，一般用于  属性 和方法  禁止重写 \r\n            局部代码块 在 方法中定义，限定变量的 生命周期，快速释放，提高内存利用率\r\n             { }  构造代码块 在 类的 构造方法执行之前执行 ，  可以放  构造方法的 公用代码 \r\n             static {}  静态代码块 随着 类的加载而加载，只执行一次， 一般用于数据初始化 ，只在类文件加载的时候执行。和构造方法调用无关\r\n                    \r\n       \r\n       接口\r\n       \r\n           抽象类 可以制定 模板 ，制定一定规则 去让子类去实现\r\n           但是如果某个抽象类的所有方法都是抽象方法的时候，我们就可以将其定义为接口\r\n           接口也是一种引用数据类型， 比抽象类 更加抽象 \r\n           接口的存在有两个重要意义： 1. 规则的定义  2. 程序的扩展性\r\n           public interface AA {}\r\n           接口本身 和 抽象方法一样不能实例化 \r\n           public class AA_ZI implements AA{} \r\n           类不能多继承 ，但是 类 可以实现 多个接口 \r\n           接口 因为是定义规则  ， 接口中的 属性 变量  默认是 final 修饰的 不能被修改 静态的 \r\n           全部的修饰符 是  public static final \r\n           接口没有构造方法 \r\n           接口中可以 使用 default 定义修饰 默认方法 ，默认方法 只要是用于 接口的迭代升级\r\n           类 实现多个接口 ，如果多个接口中有重名的 默认方法 ，  子类 必须重写 这个 方法 \r\n           接口中可以 使用 static 定义修饰 静态 方法  通过 接口名.静态方法名 来调用  \r\n           接口中 可以有  静态 方法  默认方法 私有方法  抽象方法   \r\n    \r\n            继承亲爹 实现干爹  \r\n    \r\n            类和类之间       继承关系   只能 单继承  但是可以 多层继承    你-- 你爹  -你爷爷  - 你十八辈子祖宗\r\n            类和接口之间     实现关系   可以单实现也可以多实现 ，还可以在继承一个类的时候 同时实现多个接口\r\n            接口和接口之间   继承关系   可以单继承也可以多继承            \r\n\r\n\r\n​           \r\n       \r\n       多态\r\n       \r\n           通用对象类型  ，例如 全球 70 亿人 实例 都是 人类 \r\n           多态的前提是  要有 继承 或者实现关系  ，要有方法重写 ，要有父类引用 指向子类对象\r\n    \r\n           Animal a = new Cat();\r\n           多态中的 成员访问 特点\r\n           构造方法：  同继承一样 ，子类会通过  super 访问 父类 构造器\r\n           成员变量： 编译看左边 父类  ， 执行 看左边父类\r\n           成员方法：  编译看左边父类，   执行 看 右边子类\r\n            多态 弊端：  不能调用子类特有 方法 属性\r\n           多态中的 转型\r\n           向上转型  父类引用  指向子类对象     把一个 子类类型  转换为 一个 父类类型   小的转大的  不用强制转换\r\n           向下转型  子类引用  指向父类对象     把一个 父类类型  转换为 一个 子类类型    大的转小的  需要强制类型转换\r\n           instanceof  \r\n           \r\n       \r\n       内部类\r\n       \r\n           Outer.Inner i = new Outer().new Inner();\r\n           匿名内部类\r\n           函数式编程思想\r\n           lambda   箭头 函数   是将 匿名 内部类 的  一个  优化 \r\n           doaaaa( AA a){ a.nn(); }\r\n            doaaaa(new AA(){\r\n                public void nn(){\r\n                    sout("Niubi ")\r\n                }\r\n            })\r\n           doaaaa(()->{  sout("Niubi ") })\r\n           匿名内部类 ，必须 实现一个接口 ，生产 一个实现类的对象 ，重写方法 ，读取重写的方法 ，执行方法  \r\n           这个方法 根本的阐述    传递的是一个函数 ， 箭头函数方式 我们直接传入 的 是 方法的 实体 ，\r\n           把原本的关注点 转到方法的具体实现\r\n           lambda 使用前提：  必须有一个接口  接口中 有且仅有一个 抽象方法 \r\n           这种 根本上 传入的  还是一个 匿名对象，实例的 匿名实现类的 一个具体的 对象\r\n        \r\n        \r\n       \r\n            collection  map   list  arraylist  linkedlist set hashset treeset   HashMap   TreeMap\r\n            数组长度固定， 集合 会自动扩缩容 每次 1.5倍数，长度小于10  是 10\r\n            栈  压栈 弹栈\r\n            队列  入队列             出队列    前端  后端   \r\n            数组   查询快 增删慢   因为 增删 需要 把后面的 每个都平移一位 \r\n            链表    增删快 查询慢  必须 从  头开始查  单向链表\r\n            链表   结点   头结点（地址）数据地址数据地址。。。。。^ 结束  火车一样，每一个结点 都由 数据 和地址组成  \r\n                    链表有头有尾  尾巴 是 一个空地址   ，前一个结点 记录后一个结点的地址值\r\n            双向链表      前一个结点的地址+值+下一个结点的地址   \r\n            linkedlist 链表  增删方法比较特殊 ， 有一些特殊方法 \r\n    \r\n            泛型  \r\n            不写 默认 Object,,提供 编译时候 安全检测机制   \r\n            \r\n            collection  单列集合   list set \r\n            set 没有索引 只能用迭代器  iterator 进行迭代    或者 增强 for 进行魂环 \r\n            hashset  treeset\r\n            treeset 可以对 内部元素 进行 排序 要想使用 treeset 必须 指定 排序规则   自然排序\r\n              内部的 元素 必须 实现 comparable 接口  并且重写 compareTo 方法 \r\n              compareTo  返回 0 则 不存储 ， 大于存右边 ，小于存左边\r\n              字符串也有 compareTo 方法 \r\n              comparator  比较器 类 实现 compare 方法  抽象类\r\n\r\n\r\n            数据结构 树   结点\r\n              二叉树    结点  父节点+当前节点值+左子节点+右子节点 \r\n              二叉树的查询都是从根节点进行查询\r\n              度： 每一个节点的子节点的 数量\r\n              高度， 二叉树的 根节点 到最 末梢结点的 最长层级 ，也就是 分叉 分了 几次+1\r\n    \r\n              普通二叉树     二叉查找树，二叉搜索树\r\n              普通二叉树     左右子节点 大小没关系\r\n              二叉查找树     左子节点小于右边子节点  ，一样的 不存储  ，\r\n              二叉查找树     每一次存储一个值 都要从根节点 开始找路径 进行比较，找到自己的位置 ，\r\n                             可能出现 左右子树高度差的很远\r\n              平衡二叉树     任意左右节点 的 两个子树都是一棵平衡二叉树 ，左右高度相差不超过1\r\n                             左右 旋转 ， 变化根节点，根节点 会变化，普通二叉树 不会变根节点\r\n                             左旋 ，原本根节点的右节点 升为根节点 \r\n                                    新的根节点的 原本的左节点 倒向左侧， 链接旧的的根节点作为右侧，做为右弦\r\n                             右旋 ：和上面的左旋 处处相反\r\n                             左左插入--右旋 ， \r\n                             左右插入--失衡区域左旋，然后整体右旋 ，两次旋转\r\n                             右右插入--左旋\r\n                             右左插入--失衡区域右旋，然后整体左旋\r\n              红黑树         一种自平衡的二叉查找树 ，但不是高度平衡，不是每次都去计算是否平衡，有自己的红黑规则\r\n                             每一个节点 都是 红色 或者黑色\r\n                             根节点必须黑色\r\n                             如果一个节点没有子节点或者父节点，则这个节点相应的值为Nil，被称为叶节点，都是黑色的\r\n                             如果一个节点是红色的，那么它的子节点必须是黑色的，不能出现两个红色的节点相连\r\n                             每一个节点，从该节点到它所有的后代叶节点的简单路径上，都包含相同数目的黑色节点\r\n                             红黑树多了一个颜色属性\r\n                             添加三个默认黑色 调整两次\r\n                             添加三个默认红色 调整1次数\r\n                             红黑树为了提升性能，默认添加数据颜色为红色\r\n                             红黑树  ---旋转 区域小，只旋转了父节点 祖父节点， 把父节点提升祖父节点下降作为父节点的右子节点 ，或者左子节点\r\n                             红黑树 添加数据 需要变色 ，只有在父节点红色，叔叔节点黑色，才会旋转\r\n            \r\n            hashset  \r\n              \r\n                  a.hashCode() 计算 哈希值， 同一个对象的 哈希值 一样的\r\n                  0.75 扩展因子， 满容量的 0.75  则扩容 2倍数\r\n                  集合 ，每个位置 一个哈希 ，如果 相同哈希，则存在同一个位置， 同一个位置总数小于8 采用 链表 ，大于等于8 采用 红黑树\r\n               hashset  必须重写 hashcode 和 equals 方法   \r\n                \r\n            MAP\r\n            Interface Map K,V     \r\n            键值对 ，entry 对象\r\n            hashmap  底层 还是 数组 和 红黑树 ，也有 扩展因子  和 hashset 很类似 \r\n            terrmap  底层 是根据key 排序的 treeset 类似的 原理 \r\n    \r\n            可变参数  （int ...a）  类似 js 的 数组解构， 底层是一个数组，是一种  简便写法\r\n            \r\n            stream  流\r\n            流 操作 可以 过滤 和js 的  过滤一样  相当于读数据中 每个去过滤 执行\r\n            流水线 ，每次操作一波，  流水线 ，准备物料 --\x3e 各种一次次操作加工 --\x3e出货  . 获取流--\x3e 中间方法--\x3e 终结方法\r\n            list1.stream().filter(()->{ }).filter(()->{ }).filter(()->{ }).filter(()->{ }).filter(()->{ }).forEach(()->{})\r\n            list1.stream().filter(()->{ }).filter(()->{ }).filter(()->{ }).filter(()->{ }).filter(()->{ }).xollect(Collectors.toList())\r\n            stream.of()\r\n            limit()  skip() \r\n\r\n\r\n​            \r\n​            \r\n​            \r\n​                       \r\n       \r\n            IO\r\n        \r\n            字节流 写 各种文件类型 \r\n            字符流 写  记事本 txt 文件 \r\n            释放资 源 close     捕获错误\r\n            FileOutputStream   FileInputStream \r\n            字节缓冲流  BufferedOutputStream   BufferedInputStream\r\n            字符输出流   FileWriter   \r\n            字符缓冲流  BufferedWriter   BufferedReader\r\n            转换流\r\n            对象操作流   ObjectOutputStream   ObjectInputStream  \r\n                           对象需要实现 可序列化接口 ，需要抛出各种异常  需要看 demo\r\n                           transient  路过的  序列化跳过字段  例如密码\r\n            properties  \r\n                        MAP       双列集合的操作流  \r\n                        put   setProperty \r\n                        load  加载.property 文件\r\n                        store  存储.property 文件      \r\n                        等号 形式 ，键值对 ，一般作为配置文件  .property 文件\r\n                        搜索  .property 文件 读取   需要关闭 IO 流 \r\n                        \r\n            apche-commons-io\r\n\r\n\r\n​            \r\n        \r\n        多线程\r\n        \r\n            cpu 在 多个 进程中 高速切换， 表征是 同时运行 ，例如电脑 同时 执行很多个软件\r\n            并行： 同一时刻，有多个指令 在多个 CPU 上 同时执行    三个人同时做三件事\r\n            并发： 在同一时刻， 有多个指令 在单个CPU 上交替执行   一个人同时做三件事\r\n    \r\n            进程 线程\r\n            进程： 正在 运行的 软件   ，独立 动态 并发\r\n            线程： 单个进程中的单个顺序控制流 ，一条执行 路径\r\n                   单线程： 一个进程  只有一条执行路径\r\n                   多线程： 一个进程  有多条执行路径 \r\n            多线程的 实现方案\r\n             1.继承 Thread 类   2.实现 Runable 接口 ，调用 Thread 类  3. 利用 callable 和 future 接口实现  ，调用 Thread 类 \r\n             继承 Thread 类   \r\n             继承 线程类 重写 run 方法  创建一个线程对象 ，开启多个线程  t1.start()\r\n             run 方法 没有开启线程 ，只是一般的方法 ， start 方法 开启线程\r\n             实现 Runable 接口\r\n             定义xx类 实现 Runable 接口  重写 run 方法  创建对象 xxa\r\n             创建 Thread 类对象 把  xxa对象 作为构造方法的参数 启动线程\r\n             类 可执行 run 方法      线程 可执行 start 方法   \r\n             琼东一个线程 去 执行 可执行类的 run 方法 \r\n             利用 callable 和 future 接口实现 \r\n             定义一个类 实现 callable 接口  重写 call 方法  创建 aa 对象\r\n             创建 future 接口 的 实现类 ff对象  把aa对象 作为 ff构造方法的参数  FutureTask\r\n             创建 Thread 类对象 ，把 ff对象 作为 构造方法的参数  启动线程\r\n             这种 方式 可以有返回值\r\n    \r\n            传递给 thread 的 参数 必须 实现了  runable 接口\r\n            线程的  get 方法 可以 获取 线程执行完的 返回结果 \r\n            线程 可以自定义  线程名字   setName  getName\r\n            线程   可以  sleep  休眠  时常  \r\n    \r\n            线程调度\r\n            计算机中的 CPU  在任意时刻只能执行一条机器命令。每个线程只有在 获得CPU 的使用权才能执行代码\r\n            各个线程轮流获得CPU的 使用权 ，分别执行各自的任务 \r\n            分时调度模型   ，抢占式调度模型 \r\n            java 使用的是 抢占调度模式  ，每个线程可以 设置 优先级 (10-1)   setPriority\r\n            \r\n            后台线程  守护线程    普通线程执行完成后，守护线程不再执行\r\n            setDaemon   设置为守护线程\r\n    \r\n            线程 安全问题\r\n            三个窗口卖100张电影票 ， 相同票买了很多次 ，出现 负数票号\r\n            执行每一行代码的时候 ，CPU  执行权力 都可能被别的线程 抢走。 \r\n            多线程安全问题是因为多线程操作共享数据造成的\r\n            加锁----------------加锁      \r\n            十个人抢着上一个厕所，抢到的上厕所就立即锁门 ，免得别人进厕所  ，同步执行的代码块，只能单线程，别的只能等 \r\n            多线程安全问题的解决方案基本思想： 让程序没有安全问题的环境\r\n            解决方法：\r\n                    把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可\r\n                    java 提供了同步代码块的方式 来解决\r\n            synchronized(任意锁对象（类的静态成员属性，全部类实例公用的）){多条线程操作的共享数据的代码块} \r\n                                  代码执行会去改变和还原这个锁对象， 锁对象 必须唯一\r\n            synchronized 会自动上锁\r\n                        好处： 线程安全\r\n                        坏处： 线程很多的时候，每个线程都会去判断同步上的锁，很消耗资源，会降低程序的运行效率\r\n            同步方法和同步代码块：\r\n                    同步代码块可以锁住指定的代码，同步方法是锁住方法中的所有代码\r\n                    同步代码块可以指定锁对象，同步方法不能指定锁对象\r\n                    同步方法 的锁对象 是锁定的  this  对象本身\r\n            Lock 锁接口       lock  unlock    自定义 锁定 和解锁方法 ， 方便\r\n            死锁：是指两个或者多个线程相互之间持有对方所需要的 资源，相互等待，无法继续执行。 叉号\r\n                 死锁是多个锁的 嵌套导致\r\n             生产者，消费者     \r\n            wait  notify  notifyAll    等待 通知 唤醒  ，使用 锁对象 去 等待和唤醒\r\n                等待和唤醒机制，需要中间参照    厨师 ，餐桌，顾客\r\n            阻塞队列    \r\n            queue    BlockingQueue    一根管子  通道 ， 一头生产者一头消费者 ， 消息队列\r\n            ArrayBlockingQueue   底层 数组 ，有界限\r\n            LinkedBlockingQueue  底层 链表 ，无界限   最大为 int 的最大 值\r\n            阻塞队列 设置最大值  while 循环 无线 添加  无线读取 ， 超限 报警\r\n            线程池 volatile  threadpool  线程池    executor    submit 提交任务\r\n            线程 生命周期：创建 new： start---就绪 runnable： 有执行资格，无执行权限---运行：抢到执行权 run----结束 死亡 垃圾回收  \r\n            线程  其他状态： 阻塞（有锁 lock blocked） ， 等待（wait） ，计时等待(sleep) ，唤起 就绪 notify  \r\n            线程的每次创建，等待创建和销毁以及等待销毁 都消耗系统资源，因此 线程池 很重要， 就好比碗柜，吃饭拿碗，吃碗放回去\r\n            线程池 执行原理 和 100人食堂吃饭，使用可循环的碗筷一样 ，只不过 这个放碗的碗柜 可以自己制造碗 \r\n            Executors 可以创建 线程池  ，  \r\n            ExecutorService 可以管理线程池 定量或者不限量   poll-1-thread-1  线程池子内的线程的 getName 返回的 样子\r\n            Thread.currentThread().getName()\r\n            ThreadPoolExector  \r\n            核心线程数，最大线程数，空闲线程最大存活时间，时间单位，任务队列，创建线程工厂，任务的拒绝策略\r\n            任务的拒绝策略：1.丢弃并抛异常 2.丢弃不抛异常 3.抛弃队列中等待最久的任务，添加当前任务 4.调用任务的run方法跳过线程池直接执行\r\n             修改了共享数据 ，某些线程不知道修改 ，消息不同步  反复无常 ，不稳定\r\n            共享数据的修改并不能 通知告知 哥哥线程 自己修改了 ， 每个线程也没有每次都去都最新的 ，而是从自己的变量副本读取\r\n            每个线程有自己的独立的线程栈  ，共享数据 ，多个线程共享、  共享数据在每个线程内是变量副本 ，不是时时刻刻从共享数据读取\r\n            volatile  ： 强制要求 每次线程执行的时候 去读取 最新的 共享数据 ，在变量前面 加上 volatile 这个关键字  （不稳定的）\r\n            public static volatile int money = 100000;\r\n            加了 volatile 之后：  同步代码块 synchronized 执行步骤：\r\n             1.线程获得锁 2.清空变量副本 3.拷贝共享变量最新的值到变量副本 4.执行代码 5.将修改后的变量副本中的值赋值给共享数据  6. 释放锁 \r\n    \r\n            原子性： 是指在一次操作或者多次操作中，必须所有的操作全部完整执行才可以，否则所有的操作都不执行，多个操作是一个不可分割的整体\r\n            原子性 ： 比如 银行转账  扣款和到账必须 是一体的 \r\n            volatile  只能保证 最新 ，不能保证原子性     volatile   +   synchronized锁  可以保证 原子性  ， 但是 性能较差\r\n            Atomic 接口  原子类 接口  实现保证原子性，更新 数据  AtomicInterger   以 原子的方式 对值进行修改\r\n            把共享数据  使用 原子类来实现 ， 共享数据的改变使用  使用原子类来操作    ac.incrementAndGet\r\n            原子类 原理 ：  自旋锁 + CAS算法 \r\n                           CAS 算法 有三个操作数 ： 内存值V 旧的预期值A 要修改的值B \r\n                           自旋操作： 当 A==V 修改成功，把V 赋值为B ， 当 A!=V 修改失败 不做任何操作V还是原来的，并且重新获取现在的最新值\r\n                                  这个重新获取的动作就是自旋。  自旋以后重新去执行CAS算法 ，执行运算\r\n                                   \r\n             volatile   +   synchronized锁 与 Atomic  CAS  的区别\r\n                相同点： 多线程情况下都能保证共享数据的安全\r\n                不同点： （悲观锁）synchronized锁 总是从最坏的角度出发 ，认为每次获取的数据的时候别人都可能修改了，因此每次读取共享数据之前都上锁\r\n                         （乐观锁）CAS 从乐观的角度出发，假设每次获取数据别人都不会修改，所以不上同步锁，\r\n                         只不过在每次修改共享数据的时候都会检查一下，别人有没有修改过数据。 （旧的期望值 等不等于  当前的内存值（变量副本中的值））\r\n             hashmap 是线程不安全的 ，多线程环境下存在问题。为了保证数据安全可以使用 hashTable 但是 hashTable 效率低下 \r\n                       hashTable  是 悲观锁 实现 数据安全性 ， 只要有数据改变 ，就锁表\r\n             ConcurrentHashMap 既可以保证线程安全，数据安全 ，又可以保证执行效率    （并发的 hash 双列表 结构） \r\n             ConcurrentHashMap JDK1.7\r\n                        二次哈希 ，也会锁表，但是锁的是单个地址位置上的 hashentry数组 ,不影响其他位置使用\r\n                        第一次会根据 键的哈希值来计算出 在大数组中的应存入的位置，  \r\n                        如果为null ，创建小数组，二次哈希，计算出小数组的存储位置， 存入。 \r\n                        如果不为null,先找到小数组，再计算出小数组中的位置，没有就存，有就比较后存储，\r\n    \r\n             ConcurrentHashMap JDK1.8\r\n                        数组 链表 红黑树  CAS 原子锁  ，只锁 单个位置上的链表或者红黑树\r\n             CountDownLatch (倒数计秒 取插销)  传递需要等待的线程数   很奇怪 的 东西  ， 线程数 ，等待 ，以及通知 。某个线程 干完事说一声\r\n                        CountDownLatch  可以传递给每一个线程， 用于几个线程之间通知 线程执行完毕的状态\r\n                        每个线程执行完 要调用  countdown 方法   ，再等待的线程 wait 等待 ，等它等待的几条线程全部执行完毕，会被自动唤起开始继续执行\r\n                        例如 要等待 三个线程 ，等三个线程都完成了 则 再等待的线程开始执行 ， 底层原理 是一个计数器\r\n            Semaphore     信号标， 通行证 ，令牌 ， 一段时间内 只能去允许 几个线程执行 ， 当某一个执行完成，释放信号，归还通行证， \r\n                         别的等待的就能领取通行证，开始执行。 原理就跟 限定10辆车进入园区一样， 进去拿通行证，出去交还通行证，最多十辆\r\n                         多个线程 共同找同一个管理员：   获取通行证 ， 拿到通行证开始执行 方法块代码，执行完了 ， 归还通行证\r\n\r\n\r\n​            \r\n    \r\n         网络编程  UDP TCP\r\n    \r\n            三要素： IP地址  端口  协议     ，服务运行的 IP , 程序跑的端口 ， 约定的协议\r\n            ping 域名  可以取到 这个域名 的 IP \r\n            IPV4 本身 是 32bit  4个8bit 位置的数组组成   点分 十进制 表示法   127.23.36.23  256 的4次方  42亿个地址左右\r\n            IPV6 是  128个bit 位置  每16个一组 ，分为8组  冒分 十六进制 表示法   2404:3c00:484d:b300:84ff:c8e3:999c:ecf2   \r\n            InetAddress  可以获取 电脑的 相关的 名字属性等  网络相关的  地址 协议 等\r\n            \r\n            UDP 协议  面向无连接的协议 ，不管对方是否建立连接 ，   速度快 最多64K 不安全 容易丢失数据\r\n            TCP 协议  面向有连接的协议 ，速度慢 ，没有大小限制 ，数据安全  \r\n    \r\n            UDP 通讯程序\r\n                DatagramSocket   数据程序通信    指定端口收发数据 。 发送的都是 字节码  接收 可以指定接收容器大小\r\n                发送端：  步骤： 新建socket对象， 新的接收消息存放箱子，  消息打包  ，发送出去 ，释放资源 \r\n                接收端：  步骤： 新建socket对象， 新的接收消息存放箱子，  消息打包  ，从箱子获取消息 ，释放资源 \r\n            UDP 三种通讯形式： 单播， 组播 （局域网） ，广播     \r\n                单播 发送端 指定 接收端 ip 和端口   接收端 接收 指定的 IP端口\r\n                组播 在 224.1.x.x  号段 端口  组播 需要 发送端 和接收端约定 组播地址 ip 和端口\r\n                广播 在 255.255.255.255  号段  端口  接收端 接收指定 端口  ， 广播针对 当前路由器链接的所有电脑\r\n                无论如何  接收端 都需要订阅  或者固定 IP端口  或者是 号段\r\n            TCP 通讯程序\r\n                在客户端和 服务端 各自建立一个 socket 对象\r\n                TCP 发送数据通讯之前 必须保证 连接建立\r\n                客户端    发送数据步骤：\r\n                        1.创建 客户端的 Socket 对象 与指定的 服务端 链接  Socket( host ,port)\r\n                        2.获取输出流 ，写数据   OutputStream \r\n                        3.释放资源  close \r\n                服务端    接收数据步骤：  \r\n                        1.创建服务器端的Socket 对象  ServerSocket(port)\r\n                        2.监听客户端链接，  accept()  如果收到数据则返回一个Socket 对象 ，  死等 阻塞形式的等待\r\n                        3.获取输入流，读数据，并把数据显示在控制台   InputStream \r\n                        4.释放资源   close \r\n    \r\n                注意点：不论是 客户端还是服务器端，有至少有一个写入或者写出流 和 一个 socket 需要 关闭 释放资源 \r\n                        如果是建立链接后多次写入写出 ，则需要使用 socket 去 关闭写入写出流，并且对socket 没有影响 ，不会关闭自己 \r\n                        如果传输中文，需要把字节流转换为 字符缓冲流\r\n                        1. accept 方法是阻塞的 ，作用是等待客户端 链接\r\n                        2. 客户端创建对象并链接服务器，此时是通过三次握手协议保证跟服务器之间的连接\r\n                        3.和UDP 相反， TCP 针对客户端来讲，是往外写，是输出流。 针对服务端来讲，是往里读，是输入流\r\n                        4.服务器 读数据也是阻塞的 ，一直读取\r\n                        5.在客户端关闭输出流的时候， 还会向服务器发送一个结束标记 的动作 信息\r\n                        6.客户端断开链接，通过四次挥手协议保证链接终止\r\n                三次握手： 1.客户端向服务器端发出链接请求 ，等待服务器确认是否可以链接\r\n                           2.服务器端向客户端返回一个相应，告诉客户端收到了请求，你可以链接/或者不能链接\r\n                           3.客户端向服务器端再次发出确认信息， 建立链接  去索要东西\r\n                四次挥手： 1.客户端向服务器发出取消连接请求\r\n                           2.服务器向客户端返回一个响应，表示收到客户端的取消请求\r\n                            中间这里，服务器将最后的数据处理完毕\r\n                           3.服务器向客户端发出确认取消的消息\r\n                           4.客户端再次发送确认消息 ，取消链接      \r\n                文件上传要使用 线程池  多线程 实现\r\n\r\n\r\n\r\n    \r\n        类加载器和 反射\r\n       \r\n            classLoader   类加载器     \r\n            启动类加载器  平台类加载器  系统类加载器  自定义类加载器\r\n            双亲委派模型  默认先由 父加载器加载类文件 \r\n            类加载器，可以去加载文件 返回 字节流 \r\n    \r\n            java的 反射机制   reflect\r\n                   是指再 java 运行状态中，对于任意一个类，都能知道这个类的所有属性和方法\r\n                   对于任意一个对象，都能够调用它的任意属性和方法\r\n                   这种动态获取信息以及动态调用对象的功能称为 java 语言的反射机制\r\n                通过配置文件 动态的加载类名 和方法名字， 进行调用   \r\n            获得 class 对象的三种形式   Student.getClass()  Class.forName(类的全类名)   Student.class  \r\n             使用 反射 获取 类的  constructor field   method  单个对象 的  实例\r\n            利用反射创建对象实例步骤：\r\n                1.forName 获取 class 对象\r\n                2.获取构造方法对象\r\n                3.利用newInstance  创建 类 的 对象\r\n                被 private 修饰的 成员 是不能直接使用的，如果使用反射强行获取并且使用，需要临时取消访问检查\r\n                setAccessible  暴力反射  强行使用\r\n                field  get  set 设置值 必须指定对象 \r\n                method  invoke 运行方法\r\n    \r\n            XML \r\n                小于  &lt;  大于 &gt; 和号 &amp; 单引号 &apos; 双引号 &quot;\r\n                &lt;![CDATA[内容]]&gt;\r\n                XML 解析 ： jaxp   jdom dom4j  pull  \r\n                add as libary\r\n                使用 解析插件  解析xml  获得  document 对象\r\n            DTD  schema\r\n            自定义dtd    自定义 文档定义类型\r\n            !DOCTYPE 跟标签 SYSTEM 本地文件路径\r\n            !DOCTYPE 跟标签 PUBLIC  文件名  文件网络上的路径\r\n            ELEMENT ATTLIST \r\n            schema  .xsd  文件     schema 文档约束文件   更加灵活\r\n            名称空间 约定  顺序 类型\r\n    \r\n            枚举  ENUM \r\n                通过枚举类名.枚举项名称 方式去访问指定的枚举项\r\n                每一个枚举项其实就是该枚举的一个对象\r\n                枚举也是一个类，可以去定义成员变量、\r\n                第一行必须是枚举项\r\n                枚举类可以有构造器 ，必须是 private 的\r\n                枚举类也可以有抽象方法，但是枚举项必须重写这个方法\r\n    \r\n            注解\r\n                deprecated 过时的   suppressWarning 压制警告  retention 注解存活保留时间 生命周期\r\n                注解是给编译器看的 ，代表一些特殊功能\r\n                自定义注解 \r\n                public @interface 注解名称{\r\n                        public 属性类型 属性名() default 默认值;\r\n                }\r\n                自定义注解的 属性 类型 可是是 基本类型， class 类型 注解类型  枚举类型 ，或者这些可选类型的一维数组类型\r\n                在使用注解的时候，如果注解里面的属性没有指定默认值，就需要我们手动给出注解属性的默认值\r\n                @anni(name="但是此时") 针对 value 这个特殊的注解属性，如果只需要给这个属性赋值则可以@ann("杀杀杀")\r\n                利用反射 获取到类的 方法 ，方法是 method 类的 实例 method 有方法判定是否自身有注解\r\n                method 注解包内有 方法判定是否预设了指定的注解 ，从而来判断一个方法是否添加了注解 \r\n                retention  默认 是 只在Java 文件内有效，在 字节码文件  运行时 无效\r\n            元注解 \r\n                描述注解的注解      \r\n                    常用元注解：retention 生命周期  target 使用范围  inherited  可被继承  documented   会出现在API文档\r\n            单元测试 Junit \r\n                @Test   @before  @after  \r\n            日志技术 log4j\r\n                日志体系结构 两套接口 ： JCL slf4j\r\n                可以直接使用 log4j\r\n                也可以使用 slf4j 里面的 api 来获取日志对象，使用 log4j 来实现 slf4j\r\n                好处是 以后更换日志的实现类 代码 基本不用改什么\r\n                log4j 组成：\r\n                    1.loggers 记录器 日志的级别\r\n                    2.appenders 输出源 日志要输出的地方\r\n                    3.layouts 布局 日志输出的格式 \r\n    \r\n     '},d333:function(n,e,t){"use strict";t.r(e),e["default"]='# Tomcat&Http协议-授课\n\n# 1 企业开发简介\n\n## 1.1 JavaEE规范\n\n`JavaEE`规范是`J2EE`规范的新名称，早期被称为`J2EE`规范，其全称是`Java 2 Platform Enterprise Edition`，它是由SUN公司领导、各厂家共同制定并得到广泛认可的工业标准（`JCP`组织成员）。之所以改名为`JavaEE`，目的还是让大家清楚`J2EE`只是`Java`企业应用。在2004年底中国软件技术大会`Ioc`微容器(也就是`Jdon`框架的实现原理)演讲中指出：我们需要一个跨`J2SE/WEB/EJB`的微容器，保护我们的业务核心组件，以延续它的生命力，而不是依赖`J2SE/J2EE`版本.此次`J2EE`改名为`Java EE`，实际也反映出业界这种共同心声。\n\n`JavaEE`规范是很多`Java`开发技术的总称。这些技术规范都是沿用自`J2EE`的。一共包括了13个技术规范。例如：`jsp/servlet`，`jndi`，`jaxp`，`jdbc`，`jni`，`jaxb`，`jmf`，`jta`，`jpa`，`EJB`等。\n\n其中，`JCP`组织的全称是`Java Community Process`。它是一个开放的国际组织，主要由`Java`开发者以及被授权者组成，职能是发展和更新。成立于1998年。官网是：[JCP](https://jcp.org/en/home/index)\n\n`JavaEE`的版本是延续了`J2EE`的版本，但是没有继续采用其命名规则。`J2EE`的版本从1.0开始到1.4结束，而`JavaEE`版本是从`JavaEE 5`版本开始，目前最新的的版本是`JavaEE 8`。\n\n详情请参考：[JavaEE8规范概览](https://www.oracle.com/technetwork/cn/java/javaee/overview/index.html)\n\n## 1.2 Web概述\n\nWeb在英文中的含义是网状物，网络。在计算机领域，它通常指的是后者，即<b>网络</b>。像我们前面接触的`WWW`，它是由3个单词组成的，即：`World Wide Web `，中文含义是<b>万维网</b>。而我们前面学的`HTML`，`CSS`和`JS`的参考文档《`W3School`全套教程》中的`W3C`就是万维网联盟。他们的出现都是为了让我们在网络的世界中获取资源，这些资源的存放之处，我们称之为<b><font color=\'red\'>网站</font></b>。我们通过输入网站的地址（即：网址），就可以访问网站中提供的资源。在网上我们能访问到的内容全是资源（不区分局域网还是广域网）。只不过，不同类型的资源展示的效果不一样。\n\n首先，我们先来介绍资源的分类，它分为静态资源和动态资源。其中：\n\n静态资源指的是，网站中提供给人们展示的资源是一成不变的，也就是说不同人或者在不同时间，看到的内容都是一样的。例如：我们看到的新闻，网站的使用手册，网站功能说明文档等等。而作为开发者，我们编写的`html`,`css`,`js`,图片，多媒体等等都可以称为静态资源。\n\n动态资源它指的是，网站中提供给人们展示的资源是由程序产生的，在不同的时间或者用不同的人员由于身份的不同，所看到的内容是不一样的。例如：我们在12306上购买火车票，火车票的余票数由于时间的变化，会逐渐的减少，直到最后没有余票。还有，我们在`CSDN`上下载资料，只有登录成功后，且积分足够时才能下载。否则就不能下载，这就是访客身份和会员身份的区别。作为开发人员，我们编写的`JSP`，`servlet`，`php`，`ASP`等都是动态资源。\n\n关于广域网和局域网的划分，广域网指的就是万维网，也就是我们说的互联网。局域网是指的是在一定范围之内可以访问的网络，出了这个范围，就不能再使用的网络。\n\n## 1.3 系统结构\n\n### 1.3.1 系统结构简介\n\n在我们前面课程的学习中，开发的都是`Java`工程。这些工程在企业中称之为项目或者产品。项目也好，产品也罢，它是有系统架构的，系统架构的划分有很多种方式。我们今天讨论的是基础结构上的划分。除此之外，还有技术选型划分，部署方式划分等等。\n\n基础结构划分：C/S结构，B/S结构两类。\n\n技术选型划分：Model1模型，Model2模型，MVC模型和三层架构+MVC模型。\n\n部署方式划分：一体化架构，垂直拆分架构，分布式架构，流动计算架构，微服务架构。\n\n### 1.3.2 C/S结构\n\n它指的是客户端——服务器的方式。其中C代表着Client，S代表着服务器。C/S结构的系统设计图如下：\n\n![CS结构图](./Tomcat&Http协议-授课.assets/CS结构图.jpg)\n\n### 1.3.3 B/S结构\n\n它指的是浏览器——服务器的方式。其中B代表着Browser，S代表着服务器。B/S结构的系统设计图如下：\n\n![BS结构图](./Tomcat&Http协议-授课.assets/BS结构图.jpg)\n\n### 1.3.4 两种结构的区别及优略\n\n**两种结构的区别**\n\n第一：硬件环境不同，C/S通常是建立在专用的网络或小范围的网络环境上（即局域网），且必须要安装客户端。而B/S是建立在广域网上的，适应范围强，通常有操作系统和浏览器就行。\n\n第二：C/S结构比B/S结构更安全，因为用户群相对固定，对信息的保护更强。\n\n第三：B/S结构维护升级比较简单，而C/S结构维护升级相对困难。\n\n**优略**\n\n1 C/S：是能充分发挥客户端PC的处理能力，很多工作可以在客户端处理后再提交给服务器。对应的优点就是客户端响应速度快。\n\n2 B/S：总体拥有成本低、维护方便、 分布性强、开发简单，可以不用安装任何专门的软件就能 实现在任何地方进行操作，客户端零维护，系统的扩展非常容易，只要有一台能上网的电脑就能使用。\n\n**关于课程中结构的选择**\n\n<b><font color=\'red\'>我们的课程中涉及的系统结构都是是基于B/S结构。</font></b>\n\n# 2 Tomcat\n\n## 2.1 Tomcat介绍\n\n### 2.1.1 关于服务器\n\n服务器的概念非常的广泛，它可以指代一台特殊的计算机（相比普通计算机运行更快、负载更高、价格更贵），也可以指代用于部署网站的应用。我们这里说的服务器，其实是web服务器，或者应用服务器。它本质就是一个软件，一个应用。作用就是发布我们的应用（工程），让用户可以通过浏览器访问我们的应用。\n\n常见的应用服务器，请看下表：\n\n| 服务器名称  | 说明                                                  |\n| ----------- | ----------------------------------------------------- |\n| weblogic    | 实现了javaEE规范，重量级服务器，又称为javaEE容器      |\n| websphereAS | 实现了javaEE规范，重量级服务器。                      |\n| JBOSSAS     | 实现了JavaEE规范，重量级服务器。免费的。              |\n| Tomcat      | 实现了jsp/servlet规范，是一个轻量级服务器，开源免费。 |\n\n### 2.1.2 Tomcat下载与安装\n\n[Tomcat官网下载地址](http://tomcat.apache.org/)\n\n![tomcat官网](./Tomcat&Http协议-授课.assets/tomcat官网.png)\n\n### 2.1.3 Tomcat各版本所需支持\n\n![Tomcat各版本使用技术支持](./Tomcat&Http协议-授课.assets/Tomcat各版本使用技术支持.png)\n\n### 2.1.4 Tomcat目录结构详解\n\n![tomcat目录结构详解](./Tomcat&Http协议-授课.assets/tomcat目录结构详解.png)\n\n## 2.2 Tomcat基本使用\n\n### 2.2.1 Tomcat启动和停止及问题分析解决\n\n#### 1）启动和停止\n\nTomcat服务器的启动文件在二进制文件目录中：![1574762703742](./Tomcat&Http协议-授课.assets/1574762703742.png)，这两个文件就是Tomcat的启动文件。\n\nTomcat服务器的停止文件也在二进制文件目录中：![1574762805135](./Tomcat&Http协议-授课.assets/1574762805135.png)，这两个文件就是Tomcat的停止文件。\n\n其中`.bat`文件是针对`windows`系统的运行程序，`.sh`文件是针对`linux`系统的运行程序。\n\n#### 2）启动问题\n\n**第一个问题：启动一闪而过**\n\n原因：没有配置环境变量。\n\n解决办法：配置上JAVA_HOME环境变量\n\n**第二个：Address already in use : JVM_Bind**\n\n![1574768107180](./Tomcat&Http协议-授课.assets/1574768107180.png)\n\n原因：端口被占用\n\n解决办法：找到占用该端口的应用\n\n​                    进程不重要：使用cmd命令：netstat -a -o 查看pid  在任务管理器中结束占用端口的进程。\n\n​                    进程很重要：修改自己的端口号。修改的是Tomcat目录下`\\conf\\server.xml`中的配置。\n\n​\t\t\t![1574768222804](./Tomcat&Http协议-授课.assets/1574768222804.png)\n\n**第三个：启动产生很多异常，但能正常启动**\n\n原因：Tomcat中部署着很多项目，每次启动这些项目都会启动。而这些项目中有启动报异常的。\n\n解决办法：\n\n​\t\t\t能找到报异常的项目，就把它从发布目录中移除。\n\n​\t\t\t不能确定报异常的项目，就重新解压一个新的Tomcat。\n\n**第四个：其它问题**\n\n例如：启动产生异常，但是不能正常启动。此时就需要解压一个新的Tomcat启动，来确定是系统问题，还是Tomcat的问题。\n\n所以，此时就需要具体问题，具体分析，然后再对症解决。\n\n### 2.2.2 IDEA集成Tomcat服务器\n\n**第一步**\n\n![IDEA配置Tomcat1](./Tomcat&Http协议-授课.assets/IDEA配置Tomcat1.png)\n\n**第二步**\n\n![IDEA配置Tomcat2](./Tomcat&Http协议-授课.assets/IDEA配置Tomcat2.png)\n\n**第三步**\n\n![IDEA配置Tomcat3](./Tomcat&Http协议-授课.assets/IDEA配置Tomcat3.png)\n\n**第四步**\n\n![IDEA配置Tomcat4](./Tomcat&Http协议-授课.assets/IDEA配置Tomcat4.png)\n\n### 2.2.3 Linux系统安装Tomcat\n\n**第一步：下载tomcat**\n\n参考**2.1.2小节的《Tomcat下载与安装》**进入Tomcat官网，找到对应版本点击`download`进入下载页面，如下图：\n\n![Linux版Tomcat](./Tomcat&Http协议-授课.assets/Linux版Tomcat.png)\n\n**第二步：上传到linux**\n\n在crt上 使用 alt+p \n将windows上的软件拖进去即可(root目录)\n\n**第三步：在 /usr/local 新建一个文件夹tomcat**\n\n```\nmkdir /usr/local/tomcat\n```\n\n**第四步：移动 tomcat...tar.gz 到 /usr/local/tomcat**\n\n```\nmv apache-tomcat-8.5.32.tar.gz /usr/local/tomcat/\n```\n\n**第五步：进入/usr/local/tomcat目录,解压Tomcat**\n\n```\ncd /usr/local/tomcat\ntar -xvf apache-tomcat-8.5.32.tar.gz\n```\n\n**第六步：进入 /usr/local/tomcat/apache-tomcat-8.5.32/bin**\n\n```\ncd /usr/local/tomcat/apache-tomcat-8.5.32/bin\n```\n\n**第七步：启动tomcat**\n\n```\n方式1:\n\tsh startup.sh\n方式2:\n\t./startup.sh\n```\n\n**第八步：修改防火墙的规则 **\n\n```\n方式1:service iptables stop  关闭防火墙(不建议); 用到哪一个端口号就放行哪一个(80,8080,3306...)\n\n方式2:放行8080 端口\n\t修改配置文件\n\t\tcd /etc/sysconfig\n\t\tvi iptables\n\t\t\t复制(yy , p)\t\n\t\t\t\t-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT\n\t\t\t改成\n\t\t\t\t-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT\n\t\t重启加载防火墙或者重启防火墙\n\t\t\tservice iptables reload  \n\t\t\t或者\n\t\t\tservice iptables restart\n```\n\n## 2.3 Tomcat发布应用-JavaWeb应用\n\n### 2.3.1 JavaWeb工程概述\n\n`JavaWeb`应用是一个全新的应用种类。这类应用程序指供浏览器访问的程序，通常也简称为web应用。\n\n一个web应用由多个静态web资源和动态web资源组成，例如：html、css、js文件，jsp文件、java程序、支持jar包、工程配置文件、图片、音视频等等。\n\nWeb应用开发好后，若想供外界访问，需要把web应用所在目录交给Web服务器管理（Tomcat就是Web服务器之一），这个过程称之为虚似目录的映射。\n\n### 2.3.2 JavaWeb应用目录结构详解\n\n![1574768644245](./Tomcat&Http协议-授课.assets/1574768644245.png)\n\n```\nmyapp--------------应用名称\n    1.html\n    css/css.css\n    js/demo.js\n\tWEB-INF--------如果有web.xml或者.class文件时，该目录必须存在，且严格区分大小写。\n\t\t   --------该目录下的资源，客户端是无法直接访问的。\n           --------目录中内容如下：\n        classes目录----------------web应用的class文件（加载顺序：我们的class，lib目录中的jar包，tomcat的lib目录中的jar包。优先级依次降低）\n        lib目录--------------------web应用所需的jar包（tomcat的lib目录下jar为所有应用共享）\n        web.xml-------------------web应用的主配置文件\n```\n\n### 2.3.3 JavaWeb应用的创建\n\n**第一步**\n\n![IDEA创建Javaweb工程](./Tomcat&Http协议-授课.assets/IDEA创建Javaweb工程.png)\n\n**第二步**\n\n![创建Javaweb工程2](./Tomcat&Http协议-授课.assets/创建Javaweb工程2.png)\n\n**第三步**\n\n![创建Javaweb工程3](./Tomcat&Http协议-授课.assets/创建Javaweb工程3.png)\n\n**第四步**\n\n![创建Javaweb工程4](./Tomcat&Http协议-授课.assets/创建Javaweb工程4.png)\n\n### 2.3.4 JavaWeb应用的部署\n\n#### 1）IDEA部署\n\n**第一步**\n\n![IDEA发布工程1](./Tomcat&Http协议-授课.assets/IDEA发布工程1.png)\n\n**第二步**\n\n![IDEA发布工程2](./Tomcat&Http协议-授课.assets/IDEA发布工程2.png)\n\n**第三步**\n\n![IDEA发布工程3-启动服务](./Tomcat&Http协议-授课.assets/IDEA发布工程3-启动服务.png)\n\n#### 2）war包发布\n\n**第一步：使用<b>`jar -cvf war` <font color=\'blue\'>包的名称</font>  <font color=\'purple\'>当前目录中哪些资源要打入war</font></b>**\n\n![jar命令](./Tomcat&Http协议-授课.assets/jar命令.png)\n\n![war包](./Tomcat&Http协议-授课.assets/war包.png)\n\n**第二步：把打好的war拷贝到tomcat的webapps目录中**\n\n![拷贝war包到webapps](./Tomcat&Http协议-授课.assets/拷贝war包到webapps.png)\n\n**第三步：启动服务时，tomcat会自动解压。**\n\n![启动Tomcat自动解压war包](./Tomcat&Http协议-授课.assets/启动Tomcat自动解压war包.png)\n\n### 2.4.1 Tomcat配置虚拟目录\n\n虚拟目录的配置，支持两种方式。第一种是通过在主配置文件中添加标签实现。第二种是通过写一个独立配置文件实现。\n\n第一种方式：在`server.xml`的`<Host>`元素中加一个`<Context path="" docBase=""/>`元素。\n​\t\t\t\t\t `path`：访问资源URI。URI名称可以随便起，但是必须在前面加上一个/\n​\t\t\t\t\t`docBase`：资源所在的磁盘物理地址。\n第二种方式：是写一个独立的`xml`文件，该文件名可以随便起。在文件内写一个`<Context/>`元素。\n​\t\t\t\t\t该文件要放在Tomcat目录中的`conf\\Catalina\\localhost\\`目录下。\n需要注意的是，在使用了独立的配置文件之后，访问资源URI就变成了<b><font color=\'red\'>/+文件的名称</font></b>。而`Context`的`path`属性就失效了。\n\n### 2.4.2 Tomcat配置虚拟主机\n\n在`<Engine>`元素中添加一个`<Host name="" appBase="" unparkWARs="" autoDeploy="" />`，其中：\n​\t\t`name`：指定主机的名称\n​\t\t`appBase`：当前主机的应用发布目录\n​\t\t`unparkWARs`：启动时是否自动解压war包\n​\t\t`autoDeploy`：是否自动发布\n\n配置示例如下：\n\n```xml\n<Host name="www.itcast.cn" appBase="D:\\itcastapps" unpackWARs="true" autoDeploy="true"/>\n\n<Host name="www.itheima.com" appBase="D:\\itheimaapps" unpackWARs="true" autoDeploy="true"/>\n```\n\n### 2.4.3 Tomcat默认项配置\n\n**配置默认端口**\n\nTomcat服务器主配置文件中配置着访问端口，它在配置文件中写的值是：8080。但是它不是Tomcat的默认端口。我们此处说的默认端口是，当使用默认值的时候，端口号可以省略。Tomcat的默认端口是<b><font color=\'red\'>80</font></b>。\n\n配置方式如下：\n\n```xml\n<Connector port="80" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" />\t\t\n```\n\n**配置默认应用**\n\n有两种方式配置默认应用。\n第一种：把要作为默认应用的应用，名称改为`ROOT`。放到`webapps`目录中。\n\n![默认应用1](./Tomcat&Http协议-授课.assets/默认应用1.png)\n\n第二种：写一个独立的配置文件，文件名称为`ROOT.xml`。\n​\t\t\t\t注意：`ROOT`必须大写。当使用了独立的`ROOT.xml`文件时，`webapps`下`ROOT`应用就不是默认应用了。\n\n![默认应用2](./Tomcat&Http协议-授课.assets/默认应用2.png)\n\n**配置默认主页**\n\n首先要明确的是，配置默认主页是针对应用说的。是应用的默认主页。\n在应用的web.xml中配置：\n\n```xml\n<welcome-file-list>\n    <welcome-file>默认主页</welcome-file>\n</welcome-file-list>\n```\n\n例如：\n\n```xml\n<welcome-file-list>\n    <welcome-file>index.html</welcome-file>\n    <welcome-file>index.htm</welcome-file>\n    <welcome-file>index.jsp</welcome-file>\n</welcome-file-list>\n```\n\n# 3 HTTP协议\n\n## 3.1 HTTP协议概述\n\n### 3.1.1 HTTP协议概念\n\nHTTP的全称是：Hyper Text Transfer Protocol，意为 超文本传输协议。它指的是服务器和客户端之间交互必须遵循的一问一答的规则。形容这个规则：问答机制、握手机制。\n\n它规范了请求和响应内容的类型和格式。\n\nHTTP协议是由`W3C`组织管理和维护的。\n\n### 3.1.2 HTTP协议版本\n\n目前HTTP协议主要是1.0版本和1.1版本。这两个版本的区别主要是两个方面。\n\n第一：HTTP1.1版本比1.0版本多了一些消息头。\n\n第二：HTTP1.1版本和1.0版本的执行过程不一样。执行过程如下：\n\n| HTTP1.0            | HTTP1.1                |\n| ------------------ | ---------------------- |\n| 创建连接（TCP/IP） | 创建连接（TCP/IP）     |\n| 发送请求           | 发送请求1              |\n| 得到响应           | 得到响应1              |\n| 关闭连接           | 发送请求2              |\n| 创建连接（TCP/IP） | 得到响应2              |\n| 发送请求           | .......                |\n| 得到响应           | .......                |\n| 关闭连接           | 连接超时或手动关闭连接 |\n\n### 3.1.3 HTTP协议相关说明\n\nHTTP协议概念是客户浏览器和服务器一种一问一答的规则，那么必须要有问有答，而且要先问后答。\n但是我们使用`<script>`,`<link>`和`<img>`标签，没有手动发起请求，但是仍然能从服务器端拿到数据，原因就是：**在浏览器遇到`<script>`,`<link>`,`<img>`标签时会自动发出请求。**\n\n## 3.2 HTTP协议组成\n\n由HTTP协议的概念可知，它分为问和答两部分。其中问指的就是请求部分，而答指的就是响应部分。\n\n### 3.2.1请求部分  \n\n请求行： 永远位于请求的第一行\n请求消息头： 从第二行开始，到第一个空行结束\n请求的正文： 从第一个空行后开始，到正文的结束\n\n![请求部分](./Tomcat&Http协议-授课.assets/请求部分-1574824553003.jpg)\n\n### 3.2.2 响应部分\n\n响应行： 永远位于响应的第一行\n响应消息头： 从第二行开始，到第一个空行结束\n响应的正文： 从第一个空行后开始，到正文的结束\n\n![响应部分](./Tomcat&Http协议-授课.assets/响应部分-1574824560809.jpg)\n\n### 3.3.3 消息头的共性分析\n\n消息头名称首字母大写，多个单词每个单词的首字母都大写。\n多个单词用<b><font color=\'red\'>-</font></b>分隔\n名称和值之间用<b><font color=\'red\'>冒号加空格</font></b>分隔\n多个值之间用<b><font color=\'red\'>逗号加空格</font></b>分隔\n两个头之间用<b><font color=\'red\'>回车</font></b>分隔\n\n## 3.3 请求部分详解\n\n### 3.3.1 请求行详解\n\n请求行：`GET /myapp/2.html HTTP/1.1`\n\n| 内容          | 说明                       |\n| ------------- | -------------------------- |\n| GET           | 请求的方式。（还有POST）   |\n| /myapp/2.html | 请求的资源。               |\n| HTTP/1.1      | 使用的协议，及协议的版本。 |\n\n### 3.3.2 请求消息头详解\n\n| 内容                   | 说明                                                         |\n| ---------------------- | ------------------------------------------------------------ |\n| Accept                 | 告知服务器，客户浏览器所支持的MIME类型。                     |\n| Accept-Encoding        | 告知服务器，客户浏览器所支持的压缩编码格式。最常用的就是gzip压缩。 |\n| Accept-Language        | 告知服务器，客户浏览器所支持的语言。一般都是zh_CN或en_US等。 |\n| Referer                | 告知服务器，当前请求的来源。<br/>只有当前请求有来源的时候，才有这个消息头。从地址栏输入的没有来源。<br/>作用：1 投放广告  2 防盗链 |\n| Content-Type           | 告知服务器，请求正文的MIME类型。                             |\n| Content-Length         | 告知服务器，请求正文的长度。                                 |\n| User-Agent             | 浏览器相关信息                                               |\n| Connection: Keep-Alive | 连接的状态：保持连接                                         |\n| If-Modified-Since      | 告知服务器，客户浏览器缓存文件的最后修改时间。               |\n| Cookie（********）     | 会话管理相关，非常的重要。                                   |\n\n### 3.3.3 请求正文详解\n\n第一：只有post请求方式，才有请求的正文。get方式的正文是在地址栏中的。\n第二：表单的输入域有name属性的才会被提交。不分get和post的请求方式。\n第三：表单的enctype属性取值决定了请求正文的体现形式。概述的含义是：请求正文的MIME编码类型。\n\n| enctype取值                       | 请求正文体现形式                                   | 示例                                                         |\n| --------------------------------- | -------------------------------------------------- | ------------------------------------------------------------ |\n| application/x-www-form-urlencoded | key=value&key=value                                | username=test&password=1234                                  |\n| multipart/form-data               | 此时变成了多部分表单数据。多部分是靠分隔符分隔的。 | -----------------------------7df23a16c0210<br/>Content-Disposition: form-data; name="username"<br/><br/>test<br/>-----------------------------7df23a16c0210<br/>Content-Disposition: form-data; name="password"<br/><br/>1234<br/>-----------------------------7df23a16c0210<br/>Content-Disposition: form-data; name="headfile"; filename="C:\\Users\\zhy\\Desktop\\请求部分.jpg"<br/>Content-Type: image/pjpeg<br/>-----------------------------7df23a16c0210 |\n\n## 3.4 响应部分详解\n\n### 3.4.1 响应行详解\n\n响应行：`HTTP/1.1 200 OK`\n\n| 内容     | 说明             |\n| -------- | ---------------- |\n| HTTP/1.1 | 使用协议的版本。 |\n| 200      | 响应状态码       |\n| OK       | 状态码描述       |\n\n常用状态码介绍：\n\n| 状态码  | 说明                                             |\n| ------- | ------------------------------------------------ |\n| 200     | 一切都OK>                                        |\n| 302/307 | 请求重定向(客户端行为，两次请求，地址栏发生改变) |\n| 304     | 请求资源未发生变化，使用缓存                     |\n| 404     | 请求资源未找到                                   |\n| 500     | 服务器错误                                       |\n\n### 3.4.2 响应消息头详解\n\n| 消息头                  | 说明                                                         |\n| ----------------------- | ------------------------------------------------------------ |\n| Location                | 请求重定向的地址，常与302,307配合使用。                      |\n| Server                  | 服务器相关信息。                                             |\n| Content-Type            | 告知客户浏览器，响应正文的MIME类型。                         |\n| Content-Length          | 告知客户浏览器，响应正文的长度。                             |\n| Content-Encoding        | 告知客户浏览器，响应正文使用的压缩编码格式。常用的gzip压缩。 |\n| Content-Language        | 告知客户浏览器，响应正文的语言。zh_CN或en_US等等。           |\n| Content-Disposition     | 告知客户浏览器，以下载的方式打开响应正文。                   |\n| Refresh                 | 定时刷新                                                     |\n| Last-Modified           | 服务器资源的最后修改时间。                                   |\n| Set-Cookie（*******）   | 会话管理相关，非常的重要                                     |\n| Expires:-1              | 服务器资源到客户浏览器后的缓存时间                           |\n| Catch-Control: no-catch | 不要缓存，//针对http协议1.1版本                              |\n| Pragma:no-catch         | 不要缓存，//针对http协议1.0版本                              |\n\n### 3.4.3 响应正文详解\n\n就和我们在浏览器上右键查看源文件看到的内容是一样的。\n\n```html\n<html>\n    <head>\n        <link rel="stylesheet" href="css.css" type="text/css">\n        <script type="text/javascript" src="demo.js"><\/script>\n    </head>\n    <body>\n        <img src="1.jpg" />\n    </body>\n</html>\n```\n\n# 4 综合案例-Tomcat的具体应用\n\n## 4.1 静态资源案例-门户类网站的部署和访问\n\n### 4.1.1 案例介绍\n\n**需求：**\n\n​\t\t在浏览器中输入地址，访问静态HTML页面。\n\n**细节说明：**\n\n​\t\t把`HTML`和`CSS`课程中制作的页面加入到`JavaWeb`工程中，在Tomcat中部署工程，然后启动Tomcat服务器，并使用浏览器访问。\n\n### 4.1.2 实现步骤\n\n**第一步：创建工程并选择使用的Tomcat版本**\n\n![静态资源工程1](./Tomcat&Http协议-授课.assets/静态资源工程1.png)\n\n![静态资源工程2](./Tomcat&Http协议-授课.assets/静态资源工程2.png)\n\n**第二步：拷贝资源到工程的web目录中**\n\n![静态资源工程3](./Tomcat&Http协议-授课.assets/静态资源工程3.png)\n\n**第三步：在web.xml中配置默认主页**\n\n![静态资源工程4](./Tomcat&Http协议-授课.assets/静态资源工程4.png)\n\n**第四步：部署工程到Tomcat服务器**\n\n![静态资源工程5](./Tomcat&Http协议-授课.assets/静态资源工程5.png)\n\n**第五步：测试浏览器访问**\n\n![静态资源工程6](./Tomcat&Http协议-授课.assets/静态资源工程6.png)\n\n![静态资源工程7](./Tomcat&Http协议-授课.assets/静态资源工程7.png)\n\n## 4.2 动态资源的案例-学生管理系统的部署和访问\n\n### 4.2.1 案例介绍\n\n**需求：**\n\n​\t\t把JavaSE进阶阶段的学生管理系统的服务器改用Tomcat实现。\n\n**细节说明：**\n\n​\t\t把学生管理系统涉及的HTML和样式以及图片文件拷贝到JavaWeb工程中，在Tomcat中部署工程，然后启动Tomcat服务器，并使用浏览器访问。\n\n### 4.2.2 实现步骤\n\n**第一步：创建工程**\n\n![动态资源工程](./Tomcat&Http协议-授课.assets/动态资源工程.png)\n\n![动态资源工程1](./Tomcat&Http协议-授课.assets/动态资源工程1.png)\n\n**第二步：拷贝资源**\n\n![动态资源工程2](./Tomcat&Http协议-授课.assets/动态资源工程2.png)\n\n**第三步：配置默认主页**\n\n![动态资源工程4](./Tomcat&Http协议-授课.assets/动态资源工程4.png)\n\n**第四步：部署项目**\n\n![动态资源工程3](./Tomcat&Http协议-授课.assets/动态资源工程3.png)\n\n### 4.3.2 创建案例中的动态资源-Servlet\n\n#### 1） Servlet简介\n\nServlet翻译成中文是服务端脚本，它是SUN公司推出的一套规范，称为Servlet规范。Servlet规范是JavaEE规范中的一部分。我们可以通过查阅JavaEE规范的API来了解Servlet的基本概念。通过点击[JavaEE8官方文档](https://javaee.github.io/javaee-spec/javadocs/)，就可以看到关于Servlet的内容介绍。\n\n#### 2） 按步骤编写Servlet\n\n**前期准备：在IDEA创建Javaweb工程**\n\n![前期准备](./Tomcat&Http协议-授课.assets/前期准备.png)\n\n**第一步：编写一个普通类实现Servlet接口或者继承GenericServlet类或者继承HttpServlet**\n\n![编写Servlet](./Tomcat&Http协议-授课.assets/编写Servlet.png)\n\n**第二步：重写service方法，输出一句话**\n\n![重写Service方法](./Tomcat&Http协议-授课.assets/重写Service方法.png)\n\n**第三步：在web.xml配置Servlet**\n\n![配置Servlet](./Tomcat&Http协议-授课.assets/配置Servlet.png)\n\n**第四步：启动tomcat服务器测试**\n\n在地址栏输入：http://localhost:8585/crm/studentServlet 测试访问结果 \n\n#### 3）测试访问\n\n![测试访问结果](./Tomcat&Http协议-授课.assets/测试访问结果.png)'},d506:function(n,e,t){"use strict";t.r(e),e["default"]='\x3c!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} --\x3e\n\n\x3c!-- code_chunk_output --\x3e\n\n- [HashMap 简介](#hashmap-简介)\n- [底层数据结构分析](#底层数据结构分析)\n  - [JDK1.8 之前](#jdk18-之前)\n  - [JDK1.8 之后](#jdk18-之后)\n- [HashMap 源码分析](#hashmap-源码分析)\n  - [构造方法](#构造方法)\n  - [put 方法](#put-方法)\n  - [get 方法](#get-方法)\n  - [resize 方法](#resize-方法)\n- [HashMap 常用方法测试](#hashmap-常用方法测试)\n\n\x3c!-- /code_chunk_output --\x3e\n\n\n> 感谢 [changfubai](https://github.com/changfubai) 对本文的改进做出的贡献！\n\n## HashMap 简介\n\nHashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是非线程安全的。\n\n `HashMap` 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个\n\nJDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。 JDK1.8 以后的 `HashMap` 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。\n\n`HashMap` 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， `HashMap` 总是使用 2 的幂作为哈希表的大小。\n\n## 底层数据结构分析\n\n### JDK1.8 之前\n\nJDK1.8 之前 HashMap 底层是 **数组和链表** 结合在一起使用也就是 **链表散列**。\n\nHashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 `(n - 1) & hash` 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。\n\n所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。\n\n**JDK 1.8 HashMap 的 hash 方法源码:**\n\nJDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。\n\n```java\n    static final int hash(Object key) {\n      int h;\n      // key.hashCode()：返回散列值也就是hashcode\n      // ^ ：按位异或\n      // >>>:无符号右移，忽略符号位，空位都以0补齐\n      return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n  }\n```\n\n对比一下 JDK1.7 的 HashMap 的 hash 方法源码.\n\n```java\nstatic int hash(int h) {\n    // This function ensures that hashCodes that differ only by\n    // constant multiples at each bit position have a bounded\n    // number of collisions (approximately 8 at default load factor).\n\n    h ^= (h >>> 20) ^ (h >>> 12);\n    return h ^ (h >>> 7) ^ (h >>> 4);\n}\n```\n\n相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。\n\n所谓 **“拉链法”** 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。\n\n![jdk1.8之前的内部结构](HashMap(JDK1.8)源码+底层数据结构分析.assets/jdk1.8之前的内部结构.png)\n\n### JDK1.8 之后\n\n相比于之前的版本，JDK1.8 以后在解决哈希冲突时有了较大的变化。\n\n当链表长度大于阈值（默认为 8）时，会首先调用 `treeifyBin()`方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 `resize()` 方法对数组扩容。相关源码这里就不贴了，重点关注 `treeifyBin()`方法即可！\n\n![](HashMap(JDK1.8)源码+底层数据结构分析.assets/up-bba283228693dae74e78da1ef7a9a04c684.png)\n\n**类的属性：**\n\n```java\npublic class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable {\n    // 序列号\n    private static final long serialVersionUID = 362498820763181265L;\n    // 默认的初始容量是16\n    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;\n    // 最大容量\n    static final int MAXIMUM_CAPACITY = 1 << 30;\n    // 默认的填充因子\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n    // 当桶(bucket)上的结点数大于这个值时会转成红黑树\n    static final int TREEIFY_THRESHOLD = 8;\n    // 当桶(bucket)上的结点数小于这个值时树转链表\n    static final int UNTREEIFY_THRESHOLD = 6;\n    // 桶中结构转化为红黑树对应的table的最小大小\n    static final int MIN_TREEIFY_CAPACITY = 64;\n    // 存储元素的数组，总是2的幂次倍\n    transient Node<k,v>[] table;\n    // 存放具体元素的集\n    transient Set<map.entry<k,v>> entrySet;\n    // 存放元素的个数，注意这个不等于数组的长度。\n    transient int size;\n    // 每次扩容和更改map结构的计数器\n    transient int modCount;\n    // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容\n    int threshold;\n    // 加载因子\n    final float loadFactor;\n}\n```\n\n- **loadFactor 加载因子**\n\n  loadFactor 加载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。\n\n  **loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值**。\n\n  给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 \\* 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。\n\n- **threshold**\n\n  **threshold = capacity \\* loadFactor**，**当 Size>=threshold**的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 **衡量数组是否需要扩增的一个标准**。\n\n**Node 节点类源码:**\n\n```java\n// 继承自 Map.Entry<K,V>\nstatic class Node<K,V> implements Map.Entry<K,V> {\n       final int hash;// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较\n       final K key;//键\n       V value;//值\n       // 指向下一个节点\n       Node<K,V> next;\n       Node(int hash, K key, V value, Node<K,V> next) {\n            this.hash = hash;\n            this.key = key;\n            this.value = value;\n            this.next = next;\n        }\n        public final K getKey()        { return key; }\n        public final V getValue()      { return value; }\n        public final String toString() { return key + "=" + value; }\n        // 重写hashCode()方法\n        public final int hashCode() {\n            return Objects.hashCode(key) ^ Objects.hashCode(value);\n        }\n\n        public final V setValue(V newValue) {\n            V oldValue = value;\n            value = newValue;\n            return oldValue;\n        }\n        // 重写 equals() 方法\n        public final boolean equals(Object o) {\n            if (o == this)\n                return true;\n            if (o instanceof Map.Entry) {\n                Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n                if (Objects.equals(key, e.getKey()) &&\n                    Objects.equals(value, e.getValue()))\n                    return true;\n            }\n            return false;\n        }\n}\n```\n\n**树节点类源码:**\n\n```java\nstatic final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {\n        TreeNode<K,V> parent;  // 父\n        TreeNode<K,V> left;    // 左\n        TreeNode<K,V> right;   // 右\n        TreeNode<K,V> prev;    // needed to unlink next upon deletion\n        boolean red;           // 判断颜色\n        TreeNode(int hash, K key, V val, Node<K,V> next) {\n            super(hash, key, val, next);\n        }\n        // 返回根节点\n        final TreeNode<K,V> root() {\n            for (TreeNode<K,V> r = this, p;;) {\n                if ((p = r.parent) == null)\n                    return r;\n                r = p;\n       }\n```\n\n## HashMap 源码分析\n\n### 构造方法\n\nHashMap 中有四个构造方法，它们分别如下：\n\n```java\n    // 默认构造函数。\n    public HashMap() {\n        this.loadFactor = DEFAULT_LOAD_FACTOR; // all   other fields defaulted\n     }\n\n     // 包含另一个“Map”的构造函数\n     public HashMap(Map<? extends K, ? extends V> m) {\n         this.loadFactor = DEFAULT_LOAD_FACTOR;\n         putMapEntries(m, false);//下面会分析到这个方法\n     }\n\n     // 指定“容量大小”的构造函数\n     public HashMap(int initialCapacity) {\n         this(initialCapacity, DEFAULT_LOAD_FACTOR);\n     }\n\n     // 指定“容量大小”和“加载因子”的构造函数\n     public HashMap(int initialCapacity, float loadFactor) {\n         if (initialCapacity < 0)\n             throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity);\n         if (initialCapacity > MAXIMUM_CAPACITY)\n             initialCapacity = MAXIMUM_CAPACITY;\n         if (loadFactor <= 0 || Float.isNaN(loadFactor))\n             throw new IllegalArgumentException("Illegal load factor: " + loadFactor);\n         this.loadFactor = loadFactor;\n         this.threshold = tableSizeFor(initialCapacity);\n     }\n```\n\n**putMapEntries 方法：**\n\n```java\nfinal void putMapEntries(Map<? extends K, ? extends V> m, boolean evict) {\n    int s = m.size();\n    if (s > 0) {\n        // 判断table是否已经初始化\n        if (table == null) { // pre-size\n            // 未初始化，s为m的实际元素个数\n            float ft = ((float)s / loadFactor) + 1.0F;\n            int t = ((ft < (float)MAXIMUM_CAPACITY) ?\n                    (int)ft : MAXIMUM_CAPACITY);\n            // 计算得到的t大于阈值，则初始化阈值\n            if (t > threshold)\n                threshold = tableSizeFor(t);\n        }\n        // 已初始化，并且m元素个数大于阈值，进行扩容处理\n        else if (s > threshold)\n            resize();\n        // 将m中的所有元素添加至HashMap中\n        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\n            K key = e.getKey();\n            V value = e.getValue();\n            putVal(hash(key), key, value, false, evict);\n        }\n    }\n}\n```\n\n### put 方法\n\nHashMap 只提供了 put 用于添加元素，putVal 方法只是给 put 方法调用的一个方法，并没有提供给用户使用。\n\n**对 putVal 方法添加元素的分析如下：**\n\n1. 如果定位到的数组位置没有元素 就直接插入。\n2. 如果定位到的数组位置有元素就和要插入的 key 比较，如果 key 相同就直接覆盖，如果 key 不相同，就判断 p 是否是一个树节点，如果是就调用`e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value)`将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。\n\n![ ](HashMap(JDK1.8)源码+底层数据结构分析.assets/put方法.png)\n\n说明:上图有两个小问题：\n\n- 直接覆盖之后应该就会 return，不会有后续操作。参考 JDK8 HashMap.java 658 行（[issue#608](https://github.com/Snailclimb/JavaGuide/issues/608)）。\n- 当链表长度大于阈值（默认为 8）并且 HashMap 数组长度超过 64 的时候才会执行链表转红黑树的操作，否则就只是对数组扩容。参考 HashMap 的 `treeifyBin()` 方法（[issue#1087](https://github.com/Snailclimb/JavaGuide/issues/1087)）。\n\n```java\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    // table未初始化或者长度为0，进行扩容\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    // (n - 1) & hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    // 桶中已经存在元素\n    else {\n        Node<K,V> e; K k;\n        // 比较桶中第一个元素(数组中的结点)的hash值相等，key相等\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n                // 将第一个元素赋值给e，用e来记录\n                e = p;\n        // hash值不相等，即key不相等；为红黑树结点\n        else if (p instanceof TreeNode)\n            // 放入树中\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        // 为链表结点\n        else {\n            // 在链表最末插入结点\n            for (int binCount = 0; ; ++binCount) {\n                // 到达链表的尾部\n                if ((e = p.next) == null) {\n                    // 在尾部插入新结点\n                    p.next = newNode(hash, key, value, null);\n                    // 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法\n                    // 这个方法会根据 HashMap 数组来决定是否转换为红黑树。\n                    // 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    // 跳出循环\n                    break;\n                }\n                // 判断链表中结点的key值与插入的元素的key值是否相等\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    // 相等，跳出循环\n                    break;\n                // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表\n                p = e;\n            }\n        }\n        // 表示在桶中找到key值、hash值与插入元素相等的结点\n        if (e != null) {\n            // 记录e的value\n            V oldValue = e.value;\n            // onlyIfAbsent为false或者旧值为null\n            if (!onlyIfAbsent || oldValue == null)\n                //用新值替换旧值\n                e.value = value;\n            // 访问后回调\n            afterNodeAccess(e);\n            // 返回旧值\n            return oldValue;\n        }\n    }\n    // 结构性修改\n    ++modCount;\n    // 实际大小大于阈值则扩容\n    if (++size > threshold)\n        resize();\n    // 插入后回调\n    afterNodeInsertion(evict);\n    return null;\n}\n```\n\n**我们再来对比一下 JDK1.7 put 方法的代码**\n\n**对于 put 方法的分析如下：**\n\n- ① 如果定位到的数组位置没有元素 就直接插入。\n- ② 如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的 key 比较，如果 key 相同就直接覆盖，不同就采用头插法插入元素。\n\n```java\npublic V put(K key, V value)\n    if (table == EMPTY_TABLE) {\n    inflateTable(threshold);\n}\n    if (key == null)\n        return putForNullKey(value);\n    int hash = hash(key);\n    int i = indexFor(hash, table.length);\n    for (Entry<K,V> e = table[i]; e != null; e = e.next) { // 先遍历\n        Object k;\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue;\n        }\n    }\n\n    modCount++;\n    addEntry(hash, key, value, i);  // 再插入\n    return null;\n}\n```\n\n### get 方法\n\n```java\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n\nfinal Node<K,V> getNode(int hash, Object key) {\n    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (first = tab[(n - 1) & hash]) != null) {\n        // 数组元素相等\n        if (first.hash == hash && // always check first node\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        // 桶中不止一个节点\n        if ((e = first.next) != null) {\n            // 在树中get\n            if (first instanceof TreeNode)\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n            // 在链表中get\n            do {\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n```\n\n### resize 方法\n\n进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。\n\n```java\nfinal Node<K,V>[] resize() {\n    Node<K,V>[] oldTab = table;\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    if (oldCap > 0) {\n        // 超过最大值就不再扩充了，就只好随你碰撞去吧\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        // 没超过最大值，就扩充为原来的2倍\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr << 1; // double threshold\n    }\n    else if (oldThr > 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    else {\n        // signifies using defaults\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    // 计算新的resize上限\n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr;\n    @SuppressWarnings({"rawtypes","unchecked"})\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    table = newTab;\n    if (oldTab != null) {\n        // 把每个bucket都移动到新的buckets中\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                if (e.next == null)\n                    newTab[e.hash & (newCap - 1)] = e;\n                else if (e instanceof TreeNode)\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                else {\n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    do {\n                        next = e.next;\n                        // 原索引\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        // 原索引+oldCap\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    // 原索引放到bucket里\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                    // 原索引+oldCap放到bucket里\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n```\n\n## HashMap 常用方法测试\n\n```java\npackage map;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Set;\n\npublic class HashMapDemo {\n\n    public static void main(String[] args) {\n        HashMap<String, String> map = new HashMap<String, String>();\n        // 键不能重复，值可以重复\n        map.put("san", "张三");\n        map.put("si", "李四");\n        map.put("wu", "王五");\n        map.put("wang", "老王");\n        map.put("wang", "老王2");// 老王被覆盖\n        map.put("lao", "老王");\n        System.out.println("-------直接输出hashmap:-------");\n        System.out.println(map);\n        /**\n         * 遍历HashMap\n         */\n        // 1.获取Map中的所有键\n        System.out.println("-------foreach获取Map中所有的键:------");\n        Set<String> keys = map.keySet();\n        for (String key : keys) {\n            System.out.print(key+"  ");\n        }\n        System.out.println();//换行\n        // 2.获取Map中所有值\n        System.out.println("-------foreach获取Map中所有的值:------");\n        Collection<String> values = map.values();\n        for (String value : values) {\n            System.out.print(value+"  ");\n        }\n        System.out.println();//换行\n        // 3.得到key的值的同时得到key所对应的值\n        System.out.println("-------得到key的值的同时得到key所对应的值:-------");\n        Set<String> keys2 = map.keySet();\n        for (String key : keys2) {\n            System.out.print(key + "：" + map.get(key)+"   ");\n\n        }\n        /**\n         * 如果既要遍历key又要value，那么建议这种方式，因为如果先获取keySet然后再执行map.get(key)，map内部会执行两次遍历。\n         * 一次是在获取keySet的时候，一次是在遍历所有key的时候。\n         */\n        // 当我调用put(key,value)方法的时候，首先会把key和value封装到\n        // Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取\n        // map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来\n        // 调用Entry对象中的getKey()和getValue()方法就能获取键值对了\n        Set<java.util.Map.Entry<String, String>> entrys = map.entrySet();\n        for (java.util.Map.Entry<String, String> entry : entrys) {\n            System.out.println(entry.getKey() + "--" + entry.getValue());\n        }\n\n        /**\n         * HashMap其他常用方法\n         */\n        System.out.println("after map.size()："+map.size());\n        System.out.println("after map.isEmpty()："+map.isEmpty());\n        System.out.println(map.remove("san"));\n        System.out.println("after map.remove()："+map);\n        System.out.println("after map.get(si)："+map.get("si"));\n        System.out.println("after map.containsKey(si)："+map.containsKey("si"));\n        System.out.println("after containsValue(李四)："+map.containsValue("李四"));\n        System.out.println(map.replace("si", "李四2"));\n        System.out.println("after map.replace(si, 李四2):"+map);\n    }\n\n}\n```'},d594:function(n,e,t){"use strict";t.r(e),e["default"]="> 文章很长，点赞再看，养成好习惯😋😋😋\n>\n> [本文由 FrancisQ 老哥投稿！](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485969&idx=1&sn=6bd53abde30d42a778d5a35ec104428c&chksm=cea245daf9d5cccce631f93115f0c2c4a7634e55f5bef9009fd03f5a0ffa55b745b5ef4f0530&token=294077121&lang=zh_CN#rd)\n\n## 消息队列扫盲\n\n消息队列顾名思义就是存放消息的队列，队列我就不解释了，别告诉我你连队列都不知道是啥吧？\n\n所以问题并不是消息队列是什么，而是 **消息队列为什么会出现？消息队列能用来干什么？用它来干这些事会带来什么好处？消息队列会带来副作用吗？**\n\n### 消息队列为什么会出现？\n\n消息队列算是作为后端程序员的一个必备技能吧，因为**分布式应用必定涉及到各个系统之间的通信问题**，这个时候消息队列也应运而生了。可以说分布式的产生是消息队列的基础，而分布式怕是一个很古老的概念了吧，所以消息队列也是一个很古老的中间件了。\n\n### 消息队列能用来干什么？\n\n#### 异步\n\n你可能会反驳我，应用之间的通信又不是只能由消息队列解决，好好的通信为什么中间非要插一个消息队列呢？我不能直接进行通信吗？\n\n很好👍，你又提出了一个概念，**同步通信**。就比如现在业界使用比较多的 `Dubbo` 就是一个适用于各个系统之间同步通信的 `RPC` 框架。\n\n我来举个🌰吧，比如我们有一个购票系统，需求是用户在购买完之后能接收到购买完成的短信。\n\n![](RocketMQ.assets/16ef37fee7e09230.jpg)\n\n我们省略中间的网络通信时间消耗，假如购票系统处理需要 150ms ，短信系统处理需要 200ms ，那么整个处理流程的时间消耗就是 150ms + 200ms = 350ms。\n\n当然，乍看没什么问题。可是仔细一想你就感觉有点问题，我用户购票在购票系统的时候其实就已经完成了购买，而我现在通过同步调用非要让整个请求拉长时间，而短信系统这玩意又不是很有必要，它仅仅是一个辅助功能增强用户体验感而已。我现在整个调用流程就有点 **头重脚轻** 的感觉了，购票是一个不太耗时的流程，而我现在因为同步调用，非要等待发送短信这个比较耗时的操作才返回结果。那我如果再加一个发送邮件呢？\n\n![](RocketMQ.assets/16ef380429cf373e.jpg)\n\n这样整个系统的调用链又变长了，整个时间就变成了550ms。\n\n当我们在学生时代需要在食堂排队的时候，我们和食堂大妈就是一个同步的模型。\n\n我们需要告诉食堂大妈：“姐姐，给我加个鸡腿，再加个酸辣土豆丝，帮我浇点汁上去，多打点饭哦😋😋😋”  咦~~~ 为了多吃点，真恶心。\n\n然后大妈帮我们打饭配菜，我们看着大妈那颤抖的手和掉落的土豆丝不禁咽了咽口水。\n\n最终我们从大妈手中接过饭菜然后去寻找座位了...\n\n回想一下，我们在给大妈发送需要的信息之后我们是 **同步等待大妈给我配好饭菜** 的，上面我们只是加了鸡腿和土豆丝，万一我再加一个番茄牛腩，韭菜鸡蛋，这样是不是大妈打饭配菜的流程就会变长，我们等待的时间也会相应的变长。\n\n\n\n那后来，我们工作赚钱了有钱去饭店吃饭了，我们告诉服务员来一碗牛肉面加个荷包蛋 **(传达一个消息)** ，然后我们就可以在饭桌上安心的玩手机了 **(干自己其他事情)** ，等到我们的牛肉面上了我们就可以吃了。这其中我们也就传达了一个消息，然后我们又转过头干其他事情了。这其中虽然做面的时间没有变短，但是我们只需要传达一个消息就可以干其他事情了，这是一个 **异步** 的概念。\n\n所以，为了解决这一个问题，聪明的程序员在中间也加了个类似于服务员的中间件——消息队列。这个时候我们就可以把模型给改造了。\n\n![](RocketMQ.assets/16ef38124f55eaea.jpg)\n\n这样，我们在将消息存入消息队列之后我们就可以直接返回了(我们告诉服务员我们要吃什么然后玩手机)，所以整个耗时只是 150ms + 10ms = 160ms。\n\n> 但是你需要注意的是，整个流程的时长是没变的，就像你仅仅告诉服务员要吃什么是不会影响到做面的速度的。\n\n#### 解耦\n\n回到最初同步调用的过程，我们写个伪代码简单概括一下。\n\n![](RocketMQ.assets/16ef381a505d3e1f.jpg)\n\n那么第二步，我们又添加了一个发送邮件，我们就得重新去修改代码，如果我们又加一个需求：用户购买完还需要给他加积分，这个时候我们是不是又得改代码？\n\n![](RocketMQ.assets/16ef381c4e1b1ac7.jpg)\n\n如果你觉得还行，那么我这个时候不要发邮件这个服务了呢，我是不是又得改代码，又得重启应用？\n\n\n\n这样改来改去是不是很麻烦，那么 **此时我们就用一个消息队列在中间进行解耦** 。你需要注意的是，我们后面的发送短信、发送邮件、添加积分等一些操作都依赖于上面的 `result` ，这东西抽象出来就是购票的处理结果呀，比如订单号，用户账号等等，也就是说我们后面的一系列服务都是需要同样的消息来进行处理。既然这样，我们是不是可以通过 **“广播消息”** 来实现。\n\n我上面所讲的“广播”并不是真正的广播，而是接下来的系统作为消费者去 **订阅** 特定的主题。比如我们这里的主题就可以叫做 `订票` ，我们购买系统作为一个生产者去生产这条消息放入消息队列，然后消费者订阅了这个主题，会从消息队列中拉取消息并消费。就比如我们刚刚画的那张图，你会发现，在生产者这边我们只需要关注 **生产消息到指定主题中** ，而 **消费者只需要关注从指定主题中拉取消息** 就行了。\n\n![](RocketMQ.assets/16ef382674b66892.jpg)\n\n> 如果没有消息队列，每当一个新的业务接入，我们都要在主系统调用新接口、或者当我们取消某些业务，我们也得在主系统删除某些接口调用。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，接下来收到消息如何处理，是下游的事情，无疑极大地减少了开发和联调的工作量。\n\n#### 削峰\n\n我们再次回到一开始我们使用同步调用系统的情况，并且思考一下，如果此时有大量用户请求购票整个系统会变成什么样？\n\n![](RocketMQ.assets/16ef382a9756bb1c.jpg)\n\n如果，此时有一万的请求进入购票系统，我们知道运行我们主业务的服务器配置一般会比较好，所以这里我们假设购票系统能承受这一万的用户请求，那么也就意味着我们同时也会出现一万调用发短信服务的请求。而对于短信系统来说并不是我们的主要业务，所以我们配备的硬件资源并不会太高，那么你觉得现在这个短信系统能承受这一万的峰值么，且不说能不能承受，系统会不会 **直接崩溃** 了？\n\n短信业务又不是我们的主业务，我们能不能 **折中处理** 呢？如果我们把购买完成的信息发送到消息队列中，而短信系统 **尽自己所能地去消息队列中取消息和消费消息** ，即使处理速度慢一点也无所谓，只要我们的系统没有崩溃就行了。\n\n留得江山在，还怕没柴烧？你敢说每次发送验证码的时候是一发你就收到了的么？\n\n#### 消息队列能带来什么好处？\n\n其实上面我已经说了。**异步、解耦、削峰。** 哪怕你上面的都没看懂也千万要记住这六个字，因为他不仅是消息队列的精华，更是编程和架构的精华。\n\n#### 消息队列会带来副作用吗？\n\n没有哪一门技术是“银弹”，消息队列也有它的副作用。\n\n比如，本来好好的两个系统之间的调用，我中间加了个消息队列，如果消息队列挂了怎么办呢？是不是 **降低了系统的可用性** ？\n\n那这样是不是要保证HA(高可用)？是不是要搞集群？那么我 **整个系统的复杂度是不是上升了** ？\n\n抛开上面的问题不讲，万一我发送方发送失败了，然后执行重试，这样就可能产生重复的消息。\n\n或者我消费端处理失败了，请求重发，这样也会产生重复的消息。\n\n对于一些微服务来说，消费重复消息会带来更大的麻烦，比如增加积分，这个时候我加了多次是不是对其他用户不公平？\n\n那么，又 **如何解决重复消费消息的问题** 呢？\n\n如果我们此时的消息需要保证严格的顺序性怎么办呢？比如生产者生产了一系列的有序消息(对一个id为1的记录进行删除增加修改)，但是我们知道在发布订阅模型中，对于主题是无顺序的，那么这个时候就会导致对于消费者消费消息的时候没有按照生产者的发送顺序消费，比如这个时候我们消费的顺序为修改删除增加，如果该记录涉及到金额的话是不是会出大事情？\n\n那么，又 **如何解决消息的顺序消费问题** 呢？\n\n就拿我们上面所讲的分布式系统来说，用户购票完成之后是不是需要增加账户积分？在同一个系统中我们一般会使用事务来进行解决，如果用 `Spring` 的话我们在上面伪代码中加入 `@Transactional` 注解就好了。但是在不同系统中如何保证事务呢？总不能这个系统我扣钱成功了你那积分系统积分没加吧？或者说我这扣钱明明失败了，你那积分系统给我加了积分。\n\n那么，又如何 **解决分布式事务问题** 呢？\n\n我们刚刚说了，消息队列可以进行削峰操作，那如果我的消费者如果消费很慢或者生产者生产消息很快，这样是不是会将消息堆积在消息队列中？\n\n那么，又如何 **解决消息堆积的问题** 呢？\n\n可用性降低，复杂度上升，又带来一系列的重复消费，顺序消费，分布式事务，消息堆积的问题，这消息队列还怎么用啊😵？\n\n\n\n别急，办法总是有的。\n\n## RocketMQ是什么？\n\n哇，你个混蛋！上面给我抛出那么多问题，你现在又讲 `RocketMQ` ，还让不让人活了？！🤬\n\n别急别急，话说你现在清楚 `MQ` 的构造吗，我还没讲呢，我们先搞明白 `MQ` 的内部构造，再来看看如何解决上面的一系列问题吧，不过你最好带着问题去阅读和了解喔。\n\n`RocketMQ` 是一个 **队列模型** 的消息中间件，具有**高性能、高可靠、高实时、分布式** 的特点。它是一个采用 `Java` 语言开发的分布式的消息系统，由阿里巴巴团队开发，在2016年底贡献给 `Apache`，成为了 `Apache` 的一个顶级项目。 在阿里内部，`RocketMQ` 很好地服务了集团大大小小上千个应用，在每年的双十一当天，更有不可思议的万亿级消息通过 `RocketMQ` 流转。\n\n废话不多说，想要了解 `RocketMQ` 历史的同学可以自己去搜寻资料。听完上面的介绍，你只要知道 `RocketMQ` 很快、很牛、而且经历过双十一的实践就行了！\n\n## 队列模型和主题模型\n\n在谈 `RocketMQ` 的技术架构之前，我们先来了解一下两个名词概念——**队列模型** 和 **主题模型** 。\n\n首先我问一个问题，消息队列为什么要叫消息队列？\n\n你可能觉得很弱智，这玩意不就是存放消息的队列嘛？不叫消息队列叫什么？\n\n的确，早期的消息中间件是通过 **队列** 这一模型来实现的，可能是历史原因，我们都习惯把消息中间件成为消息队列。\n\n但是，如今例如 `RocketMQ` 、`Kafka` 这些优秀的消息中间件不仅仅是通过一个 **队列** 来实现消息存储的。\n\n### 队列模型\n\n就像我们理解队列一样，消息中间件的队列模型就真的只是一个队列。。。我画一张图给大家理解。\n\n![](RocketMQ.assets/16ef3834ae653469.jpg)\n\n在一开始我跟你提到了一个 **“广播”** 的概念，也就是说如果我们此时我们需要将一个消息发送给多个消费者(比如此时我需要将信息发送给短信系统和邮件系统)，这个时候单个队列即不能满足需求了。\n\n当然你可以让 `Producer` 生产消息放入多个队列中，然后每个队列去对应每一个消费者。问题是可以解决，创建多个队列并且复制多份消息是会很影响资源和性能的。而且，这样子就会导致生产者需要知道具体消费者个数然后去复制对应数量的消息队列，这就违背我们消息中间件的 **解耦** 这一原则。\n\n### 主题模型\n\n那么有没有好的方法去解决这一个问题呢？有，那就是 **主题模型** 或者可以称为 **发布订阅模型** 。\n\n> 感兴趣的同学可以去了解一下设计模式里面的观察者模式并且手动实现一下，我相信你会有所收获的。\n\n在主题模型中，消息的生产者称为 **发布者(Publisher)** ，消息的消费者称为 **订阅者(Subscriber)** ，存放消息的容器称为 **主题(Topic)** 。\n\n其中，发布者将消息发送到指定主题中，订阅者需要 **提前订阅主题** 才能接受特定主题的消息。\n\n![](RocketMQ.assets/16ef3837887d9a54sds.jpg)\n\n### RocketMQ中的消息模型\n\n`RocketMQ` 中的消息模型就是按照 **主题模型** 所实现的。你可能会好奇这个 **主题** 到底是怎么实现的呢？你上面也没有讲到呀！\n\n其实对于主题模型的实现来说每个消息中间件的底层设计都是不一样的，就比如 `Kafka` 中的 **分区** ，`RocketMQ` 中的 **队列** ，`RabbitMQ` 中的 `Exchange` 。我们可以理解为 **主题模型/发布订阅模型** 就是一个标准，那些中间件只不过照着这个标准去实现而已。\n\n所以，`RocketMQ` 中的 **主题模型** 到底是如何实现的呢？首先我画一张图，大家尝试着去理解一下。\n\n![](RocketMQ.assets/16ef383d3e8c9788.jpg)\n\n我们可以看到在整个图中有 `Producer Group` 、`Topic` 、`Consumer Group`  三个角色，我来分别介绍一下他们。\n\n- `Producer Group` 生产者组： 代表某一类的生产者，比如我们有多个秒杀系统作为生产者，这多个合在一起就是一个 `Producer Group` 生产者组，它们一般生产相同的消息。\n- `Consumer Group` 消费者组： 代表某一类的消费者，比如我们有多个短信系统作为消费者，这多个合在一起就是一个 `Consumer Group` 消费者组，它们一般消费相同的消息。\n- `Topic` 主题： 代表一类消息，比如订单消息，物流消息等等。\n\n你可以看到图中生产者组中的生产者会向主题发送消息，而 **主题中存在多个队列**，生产者每次生产消息之后是指定主题中的某个队列发送消息的。\n\n每个主题中都有多个队列(分布在不同的 `Broker`中，如果是集群的话，`Broker`又分布在不同的服务器中)，集群消费模式下，一个消费者集群多台机器共同消费一个 `topic` 的多个队列，**一个队列只会被一个消费者消费**。如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。就像上图中 `Consumer1` 和 `Consumer2` 分别对应着两个队列，而 `Consumer3` 是没有队列对应的，所以一般来讲要控制 **消费者组中的消费者个数和主题中队列个数相同** 。\n\n当然也可以消费者个数小于队列个数，只不过不太建议。如下图。\n\n![](RocketMQ.assets/16ef3850c808d707.jpg)\n\n**每个消费组在每个队列上维护一个消费位置** ，为什么呢？\n\n因为我们刚刚画的仅仅是一个消费者组，我们知道在发布订阅模式中一般会涉及到多个消费者组，而每个消费者组在每个队列中的消费位置都是不同的。如果此时有多个消费者组，那么消息被一个消费者组消费完之后是不会删除的(因为其它消费者组也需要呀)，它仅仅是为每个消费者组维护一个 **消费位移(offset)** ，每次消费者组消费完会返回一个成功的响应，然后队列再把维护的消费位移加一，这样就不会出现刚刚消费过的消息再一次被消费了。\n\n![](RocketMQ.assets/16ef3857fefaa079.jpg)\n\n可能你还有一个问题，**为什么一个主题中需要维护多个队列** ？\n\n答案是 **提高并发能力** 。的确，每个主题中只存在一个队列也是可行的。你想一下，如果每个主题中只存在一个队列，这个队列中也维护着每个消费者组的消费位置，这样也可以做到 **发布订阅模式** 。如下图。\n\n![](RocketMQ.assets/16ef38600cdb6d4b.jpg)\n\n但是，这样我生产者是不是只能向一个队列发送消息？又因为需要维护消费位置所以一个队列只能对应一个消费者组中的消费者，这样是不是其他的 `Consumer` 就没有用武之地了？从这两个角度来讲，并发度一下子就小了很多。\n\n所以总结来说，`RocketMQ` 通过**使用在一个 `Topic` 中配置多个队列并且每个队列维护每个消费者组的消费位置** 实现了 **主题模式/发布订阅模式** 。\n\n## RocketMQ的架构图\n\n讲完了消息模型，我们理解起 `RocketMQ` 的技术架构起来就容易多了。\n\n`RocketMQ` 技术架构中有四大角色 `NameServer` 、`Broker` 、`Producer` 、`Consumer` 。我来向大家分别解释一下这四个角色是干啥的。\n\n- `Broker`： 主要负责消息的存储、投递和查询以及服务高可用保证。说白了就是消息队列服务器嘛，生产者生产消息到 `Broker` ，消费者从 `Broker` 拉取消息并消费。\n\n  这里，我还得普及一下关于 `Broker` 、`Topic` 和 队列的关系。上面我讲解了 `Topic` 和队列的关系——一个 `Topic` 中存在多个队列，那么这个 `Topic` 和队列存放在哪呢？\n\n  **一个 `Topic` 分布在多个 `Broker`上，一个 `Broker` 可以配置多个 `Topic` ，它们是多对多的关系**。 \n\n  如果某个 `Topic` 消息量很大，应该给它多配置几个队列(上文中提到了提高并发能力)，并且 **尽量多分布在不同 `Broker` 上，以减轻某个 `Broker` 的压力** 。\n\n  `Topic` 消息量都比较均匀的情况下，如果某个 `broker` 上的队列越多，则该 `broker` 压力越大。\n\n  ![](RocketMQ.assets/16ef38687488a5a4.jpg)\n\n  > 所以说我们需要配置多个Broker。\n\n- `NameServer`： 不知道你们有没有接触过 `ZooKeeper` 和 `Spring Cloud` 中的 `Eureka` ，它其实也是一个 **注册中心** ，主要提供两个功能：**Broker管理** 和 **路由信息管理** 。说白了就是 `Broker` 会将自己的信息注册到 `NameServer` 中，此时 `NameServer` 就存放了很多 `Broker` 的信息(Broker的路由表)，消费者和生产者就从 `NameServer` 中获取路由表然后照着路由表的信息和对应的 `Broker` 进行通信(生产者和消费者定期会向 `NameServer` 去查询相关的 `Broker` 的信息)。\n\n- `Producer`： 消息发布的角色，支持分布式集群方式部署。说白了就是生产者。\n\n- `Consumer`： 消息消费的角色，支持分布式集群方式部署。支持以push推，pull拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制。说白了就是消费者。\n\n听完了上面的解释你可能会觉得，这玩意好简单。不就是这样的么？\n\n![](RocketMQ.assets/16ef386c6d1e8bdb.jpg)\n\n嗯？你可能会发现一个问题，这老家伙 `NameServer` 干啥用的，这不多余吗？直接 `Producer` 、`Consumer` 和 `Broker` 直接进行生产消息，消费消息不就好了么？\n\n但是，我们上文提到过 `Broker` 是需要保证高可用的，如果整个系统仅仅靠着一个 `Broker` 来维持的话，那么这个 `Broker` 的压力会不会很大？所以我们需要使用多个 `Broker` 来保证 **负载均衡** 。\n\n如果说，我们的消费者和生产者直接和多个 `Broker` 相连，那么当 `Broker` 修改的时候必定会牵连着每个生产者和消费者，这样就会产生耦合问题，而 `NameServer` 注册中心就是用来解决这个问题的。\n\n> 如果还不是很理解的话，可以去看我介绍 `Spring Cloud` 的那篇文章，其中介绍了 `Eureka` 注册中心。\n\n当然，`RocketMQ` 中的技术架构肯定不止前面那么简单，因为上面图中的四个角色都是需要做集群的。我给出一张官网的架构图，大家尝试理解一下。\n\n![](RocketMQ.assets/16ef386fa3be1e53.jpg)\n\n其实和我们最开始画的那张乞丐版的架构图也没什么区别，主要是一些细节上的差别。听我细细道来🤨。\n\n第一、我们的 `Broker` **做了集群并且还进行了主从部署** ，由于消息分布在各个 `Broker` 上，一旦某个 `Broker` 宕机，则该`Broker` 上的消息读写都会受到影响。所以 `Rocketmq` 提供了 `master/slave` 的结构，` salve` 定时从 `master` 同步数据(同步刷盘或者异步刷盘)，如果 `master` 宕机，**则 `slave` 提供消费服务，但是不能写入消息** (后面我还会提到哦)。\n\n第二、为了保证 `HA` ，我们的 `NameServer` 也做了集群部署，但是请注意它是 **去中心化** 的。也就意味着它没有主节点，你可以很明显地看出 `NameServer` 的所有节点是没有进行 `Info Replicate` 的，在 `RocketMQ` 中是通过 **单个Broker和所有NameServer保持长连接** ，并且在每隔30秒 `Broker` 会向所有 `Nameserver` 发送心跳，心跳包含了自身的 `Topic` 配置信息，这个步骤就对应这上面的 `Routing Info` 。\n\n第三、在生产者需要向 `Broker` 发送消息的时候，**需要先从 `NameServer` 获取关于 `Broker` 的路由信息**，然后通过 **轮询** 的方法去向每个队列中生产数据以达到 **负载均衡** 的效果。\n\n第四、消费者通过 `NameServer` 获取所有 `Broker` 的路由信息后，向 `Broker` 发送 `Pull` 请求来获取消息数据。`Consumer` 可以以两种模式启动—— **广播（Broadcast）和集群（Cluster）**。广播模式下，一条消息会发送给 **同一个消费组中的所有消费者** ，集群模式下消息只会发送给一个消费者。\n\n## 如何解决 顺序消费、重复消费\n\n其实，这些东西都是我在介绍消息队列带来的一些副作用的时候提到的，也就是说，这些问题不仅仅挂钩于 `RocketMQ` ，而是应该每个消息中间件都需要去解决的。\n\n在上面我介绍 `RocketMQ` 的技术架构的时候我已经向你展示了 **它是如何保证高可用的** ，这里不涉及运维方面的搭建，如果你感兴趣可以自己去官网上照着例子搭建属于你自己的 `RocketMQ` 集群。\n\n> 其实 `Kafka` 的架构基本和 `RocketMQ` 类似，只是它注册中心使用了 `Zookeeper` 、它的 **分区** 就相当于 `RocketMQ` 中的 **队列** 。还有一些小细节不同会在后面提到。\n\n### 顺序消费\n\n在上面的技术架构介绍中，我们已经知道了 **`RocketMQ` 在主题上是无序的、它只有在队列层面才是保证有序** 的。\n\n这又扯到两个概念——**普通顺序** 和 **严格顺序** 。\n\n所谓普通顺序是指 消费者通过 **同一个消费队列收到的消息是有顺序的** ，不同消息队列收到的消息则可能是无顺序的。普通顺序消息在 `Broker` **重启情况下不会保证消息顺序性** (短暂时间) 。\n\n所谓严格顺序是指  消费者收到的 **所有消息** 均是有顺序的。严格顺序消息 **即使在异常情况下也会保证消息的顺序性** 。\n\n但是，严格顺序看起来虽好，实现它可会付出巨大的代价。如果你使用严格顺序模式，`Broker` 集群中只要有一台机器不可用，则整个集群都不可用。你还用啥？现在主要场景也就在 `binlog` 同步。\n\n一般而言，我们的 `MQ` 都是能容忍短暂的乱序，所以推荐使用普通顺序模式。\n\n那么，我们现在使用了 **普通顺序模式** ，我们从上面学习知道了在 `Producer` 生产消息的时候会进行轮询(取决你的负载均衡策略)来向同一主题的不同消息队列发送消息。那么如果此时我有几个消息分别是同一个订单的创建、支付、发货，在轮询的策略下这 **三个消息会被发送到不同队列** ，因为在不同的队列此时就无法使用 `RocketMQ` 带来的队列有序特性来保证消息有序性了。\n\n![](RocketMQ.assets/16ef3874585e096e.jpg)\n\n那么，怎么解决呢？\n\n其实很简单，我们需要处理的仅仅是将同一语义下的消息放入同一个队列(比如这里是同一个订单)，那我们就可以使用 **Hash取模法** 来保证同一个订单在同一个队列中就行了。\n\n### 重复消费\n\nemmm，就两个字—— **幂等** 。在编程中一个*幂等* 操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。比如说，这个时候我们有一个订单的处理积分的系统，每当来一个消息的时候它就负责为创建这个订单的用户的积分加上相应的数值。可是有一次，消息队列发送给订单系统 FrancisQ 的订单信息，其要求是给 FrancisQ 的积分加上 500。但是积分系统在收到 FrancisQ 的订单信息处理完成之后返回给消息队列处理成功的信息的时候出现了网络波动(当然还有很多种情况，比如Broker意外重启等等)，这条回应没有发送成功。\n\n那么，消息队列没收到积分系统的回应会不会尝试重发这个消息？问题就来了，我再发这个消息，万一它又给 FrancisQ 的账户加上 500 积分怎么办呢？\n\n所以我们需要给我们的消费者实现 **幂等** ，也就是对同一个消息的处理结果，执行多少次都不变。\n\n那么如何给业务实现幂等呢？这个还是需要结合具体的业务的。你可以使用 **写入 `Redis`** 来保证，因为 `Redis` 的 `key` 和 `value` 就是天然支持幂等的。当然还有使用 **数据库插入法** ，基于数据库的唯一键来保证重复数据不会被插入多条。\n\n不过最主要的还是需要 **根据特定场景使用特定的解决方案** ，你要知道你的消息消费是否是完全不可重复消费还是可以忍受重复消费的，然后再选择强校验和弱校验的方式。毕竟在 CS 领域还是很少有技术银弹的说法。\n\n而在整个互联网领域，幂等不仅仅适用于消息队列的重复消费问题，这些实现幂等的方法，也同样适用于，**在其他场景中来解决重复请求或者重复调用的问题** 。比如将HTTP服务设计成幂等的，**解决前端或者APP重复提交表单数据的问题** ，也可以将一个微服务设计成幂等的，解决 `RPC` 框架自动重试导致的 **重复调用问题** 。\n\n## 分布式事务\n\n如何解释分布式事务呢？事务大家都知道吧？**要么都执行要么都不执行** 。在同一个系统中我们可以轻松地实现事务，但是在分布式架构中，我们有很多服务是部署在不同系统之间的，而不同服务之间又需要进行调用。比如此时我下订单然后增加积分，如果保证不了分布式事务的话，就会出现A系统下了订单，但是B系统增加积分失败或者A系统没有下订单，B系统却增加了积分。前者对用户不友好，后者对运营商不利，这是我们都不愿意见到的。\n\n那么，如何去解决这个问题呢？\n\n如今比较常见的分布式事务实现有 2PC、TCC 和事务消息(half 半消息机制)。每一种实现都有其特定的使用场景，但是也有各自的问题，**都不是完美的解决方案**。\n\n在 `RocketMQ` 中使用的是 **事务消息加上事务反查机制** 来解决分布式事务问题的。我画了张图，大家可以对照着图进行理解。\n\n![](RocketMQ.assets/16ef38798d7a987f.png)\n\n在第一步发送的 half 消息 ，它的意思是 **在事务提交之前，对于消费者来说，这个消息是不可见的** 。\n\n> 那么，如何做到写入消息但是对用户不可见呢？RocketMQ事务消息的做法是：如果消息是half消息，将备份原消息的主题与消息消费队列，然后 **改变主题** 为RMQ_SYS_TRANS_HALF_TOPIC。由于消费组未订阅该主题，故消费端无法消费half类型的消息，**然后RocketMQ会开启一个定时任务，从Topic为RMQ_SYS_TRANS_HALF_TOPIC中拉取消息进行消费**，根据生产者组获取一个服务提供者发送回查事务状态请求，根据事务状态来决定是提交或回滚消息。\n\n你可以试想一下，如果没有从第5步开始的 **事务反查机制** ，如果出现网路波动第4步没有发送成功，这样就会产生 MQ 不知道是不是需要给消费者消费的问题，他就像一个无头苍蝇一样。在 `RocketMQ` 中就是使用的上述的事务反查来解决的，而在 `Kafka` 中通常是直接抛出一个异常让用户来自行解决。\n\n你还需要注意的是，在 `MQ Server` 指向系统B的操作已经和系统A不相关了，也就是说在消息队列中的分布式事务是——**本地事务和存储消息到消息队列才是同一个事务**。这样也就产生了事务的**最终一致性**，因为整个过程是异步的，**每个系统只要保证它自己那一部分的事务就行了**。\n\n## 消息堆积问题\n\n在上面我们提到了消息队列一个很重要的功能——**削峰** 。那么如果这个峰值太大了导致消息堆积在队列中怎么办呢？\n\n其实这个问题可以将它广义化，因为产生消息堆积的根源其实就只有两个——生产者生产太快或者消费者消费太慢。\n\n我们可以从多个角度去思考解决这个问题，当流量到峰值的时候是因为生产者生产太快，我们可以使用一些 **限流降级** 的方法，当然你也可以增加多个消费者实例去水平扩展增加消费能力来匹配生产的激增。如果消费者消费过慢的话，我们可以先检查 **是否是消费者出现了大量的消费错误** ，或者打印一下日志查看是否是哪一个线程卡死，出现了锁资源不释放等等的问题。\n\n> 当然，最快速解决消息堆积问题的方法还是增加消费者实例，不过 **同时你还需要增加每个主题的队列数量** 。\n>\n> 别忘了在 `RocketMQ` 中，**一个队列只会被一个消费者消费** ，如果你仅仅是增加消费者实例就会出现我一开始给你画架构图的那种情况。\n\n![](RocketMQ.assets/16ef387d939ab66d.jpg)\n\n## 回溯消费\n\n回溯消费是指 `Consumer` 已经消费成功的消息，由于业务上需求需要重新消费，在`RocketMQ` 中， `Broker` 在向`Consumer` 投递成功消息后，**消息仍然需要保留** 。并且重新消费一般是按照时间维度，例如由于 `Consumer` 系统故障，恢复后需要重新消费1小时前的数据，那么 `Broker` 要提供一种机制，可以按照时间维度来回退消费进度。`RocketMQ` 支持按照时间回溯消费，时间维度精确到毫秒。\n\n这是官方文档的解释，我直接照搬过来就当科普了😁😁😁。\n\n## RocketMQ 的刷盘机制\n\n上面我讲了那么多的 `RocketMQ` 的架构和设计原理，你有没有好奇\n\n在 `Topic` 中的 **队列是以什么样的形式存在的？**\n\n**队列中的消息又是如何进行存储持久化的呢？**\n\n我在上文中提到的 **同步刷盘** 和 **异步刷盘** 又是什么呢？它们会给持久化带来什么样的影响呢？\n\n下面我将给你们一一解释。\n\n### 同步刷盘和异步刷盘\n\n![](RocketMQ.assets/16ef387fba311cda.jpg)\n\n如上图所示，在同步刷盘中需要等待一个刷盘成功的 `ACK` ，同步刷盘对 `MQ` 消息可靠性来说是一种不错的保障，但是 **性能上会有较大影响** ，一般地适用于金融等特定业务场景。\n\n而异步刷盘往往是开启一个线程去异步地执行刷盘操作。消息刷盘采用后台异步线程提交的方式进行， **降低了读写延迟** ，提高了 `MQ` 的性能和吞吐量，一般适用于如发验证码等对于消息保证要求不太高的业务场景。\n\n一般地，**异步刷盘只有在 `Broker` 意外宕机的时候会丢失部分数据**，你可以设置 `Broker` 的参数 `FlushDiskType` 来调整你的刷盘策略(ASYNC_FLUSH 或者 SYNC_FLUSH)。\n\n### 同步复制和异步复制\n\n上面的同步刷盘和异步刷盘是在单个结点层面的，而同步复制和异步复制主要是指的 `Borker` 主从模式下，主节点返回消息给客户端的时候是否需要同步从节点。\n\n- 同步复制： 也叫 “同步双写”，也就是说，**只有消息同步双写到主从结点上时才返回写入成功** 。\n- 异步复制： **消息写入主节点之后就直接返回写入成功** 。\n\n然而，很多事情是没有完美的方案的，就比如我们进行消息写入的节点越多就更能保证消息的可靠性，但是随之的性能也会下降，所以需要程序员根据特定业务场景去选择适应的主从复制方案。\n\n那么，**异步复制会不会也像异步刷盘那样影响消息的可靠性呢？**\n\n答案是不会的，因为两者就是不同的概念，对于消息可靠性是通过不同的刷盘策略保证的，而像异步同步复制策略仅仅是影响到了 **可用性** 。为什么呢？其主要原因**是 `RocketMQ` 是不支持自动主从切换的，当主节点挂掉之后，生产者就不能再给这个主节点生产消息了**。\n\n比如这个时候采用异步复制的方式，在主节点还未发送完需要同步的消息的时候主节点挂掉了，这个时候从节点就少了一部分消息。但是此时生产者无法再给主节点生产消息了，**消费者可以自动切换到从节点进行消费**(仅仅是消费)，所以在主节点挂掉的时间只会产生主从结点短暂的消息不一致的情况，降低了可用性，而当主节点重启之后，从节点那部分未来得及复制的消息还会继续复制。\n\n在单主从架构中，如果一个主节点挂掉了，那么也就意味着整个系统不能再生产了。那么这个可用性的问题能否解决呢？**一个主从不行那就多个主从的呗**，别忘了在我们最初的架构图中，每个 `Topic` 是分布在不同 `Broker` 中的。\n\n![](RocketMQ.assets/16ef38687488a5a4.jpg)\n\n但是这种复制方式同样也会带来一个问题，那就是无法保证 **严格顺序** 。在上文中我们提到了如何保证的消息顺序性是通过将一个语义的消息发送在同一个队列中，使用 `Topic` 下的队列来保证顺序性的。如果此时我们主节点A负责的是订单A的一系列语义消息，然后它挂了，这样其他节点是无法代替主节点A的，如果我们任意节点都可以存入任何消息，那就没有顺序性可言了。\n\n而在 `RocketMQ` 中采用了 `Dledger` 解决这个问题。他要求在写入消息的时候，要求**至少消息复制到半数以上的节点之后**，才给客⼾端返回写⼊成功，并且它是⽀持通过选举来动态切换主节点的。这里我就不展开说明了，读者可以自己去了解。\n\n> 也不是说 `Dledger` 是个完美的方案，至少在 `Dledger` 选举过程中是无法提供服务的，而且他必须要使用三个节点或以上，如果多数节点同时挂掉他也是无法保证可用性的，而且要求消息复制半数以上节点的效率和直接异步复制还是有一定的差距的。\n\n### 存储机制\n\n还记得上面我们一开始的三个问题吗？到这里第三个问题已经解决了。\n\n但是，在 `Topic` 中的 **队列是以什么样的形式存在的？队列中的消息又是如何进行存储持久化的呢？** 还未解决，其实这里涉及到了 `RocketMQ` 是如何设计它的存储结构了。我首先想大家介绍 `RocketMQ` 消息存储架构中的三大角色——`CommitLog` 、`ConsumeQueue` 和 `IndexFile` 。\n\n- `CommitLog`： **消息主体以及元数据的存储主体**，存储 `Producer` 端写入的消息主体内容,消息内容不是定长的。单个文件大小默认1G ，文件名长度为20位，左边补零，剩余为起始偏移量，比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是**顺序写入日志文件**，当文件满了，写入下一个文件。\n- `ConsumeQueue`： 消息消费队列，**引入的目的主要是提高消息消费的性能**(我们再前面也讲了)，由于`RocketMQ` 是基于主题 `Topic` 的订阅模式，消息消费是针对主题进行的，如果要遍历 `commitlog` 文件中根据 `Topic` 检索消息是非常低效的。`Consumer` 即可根据 `ConsumeQueue` 来查找待消费的消息。其中，`ConsumeQueue`（逻辑消费队列）**作为消费消息的索引**，保存了指定 `Topic` 下的队列消息在 `CommitLog` 中的**起始物理偏移量 `offset` **，消息大小 `size` 和消息 `Tag` 的 `HashCode` 值。**`consumequeue` 文件可以看成是基于 `topic` 的 `commitlog` 索引文件**，故 `consumequeue` 文件夹的组织方式如下：topic/queue/file三层组织结构，具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。同样 `consumequeue` 文件采取定长设计，每一个条目共20个字节，分别为8字节的 `commitlog` 物理偏移量、4字节的消息长度、8字节tag `hashcode`，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个 `ConsumeQueue`文件大小约5.72M；\n- `IndexFile`： `IndexFile`（索引文件）提供了一种可以通过key或时间区间来查询消息的方法。这里只做科普不做详细介绍。\n\n总结来说，整个消息存储的结构，最主要的就是 `CommitLoq` 和 `ConsumeQueue` 。而 `ConsumeQueue` 你可以大概理解为 `Topic` 中的队列。\n\n![](RocketMQ.assets/16ef3884c02acc72.png)\n\n`RocketMQ` 采用的是 **混合型的存储结构** ，即为 `Broker` 单个实例下所有的队列共用一个日志数据文件来存储消息。有意思的是在同样高并发的 `Kafka` 中会为每个 `Topic` 分配一个存储文件。这就有点类似于我们有一大堆书需要装上书架，`RockeMQ` 是不分书的种类直接成批的塞上去的，而 `Kafka` 是将书本放入指定的分类区域的。\n\n而 `RocketMQ` 为什么要这么做呢？原因是 **提高数据的写入效率** ，不分 `Topic` 意味着我们有更大的几率获取 **成批** 的消息进行数据写入，但也会带来一个麻烦就是读取消息的时候需要遍历整个大文件，这是非常耗时的。\n\n所以，在 `RocketMQ` 中又使用了 `ConsumeQueue` 作为每个队列的索引文件来 **提升读取消息的效率**。我们可以直接根据队列的消息序号，计算出索引的全局位置（索引序号*索引固定⻓度20），然后直接读取这条索引，再根据索引中记录的消息的全局位置，找到消息。\n\n讲到这里，你可能对 `RockeMQ` 的存储架构还有些模糊，没事，我们结合着图来理解一下。\n\n![](RocketMQ.assets/16ef388763c25c62.jpg)\n\nemmm，是不是有一点复杂🤣，看英文图片和英文文档的时候就不要怂，硬着头皮往下看就行。\n\n> 如果上面没看懂的读者一定要认真看下面的流程分析！\n\n首先，在最上面的那一块就是我刚刚讲的你现在可以直接 **把 `ConsumerQueue` 理解为 `Queue`**。\n\n在图中最左边说明了 <font color = red>红色方块 </font> 代表被写入的消息，虚线方块代表等待被写入的。左边的生产者发送消息会指定 `Topic` 、`QueueId` 和具体消息内容，而在 `Broker` 中管你是哪门子消息，他直接 **全部顺序存储到了 CommitLog**。而根据生产者指定的 `Topic` 和 `QueueId` 将这条消息本身在 `CommitLog` 的偏移(offset)，消息本身大小，和tag的hash值存入对应的 `ConsumeQueue` 索引文件中。而在每个队列中都保存了 `ConsumeOffset` 即每个消费者组的消费位置(我在架构那里提到了，忘了的同学可以回去看一下)，而消费者拉取消息进行消费的时候只需要根据 `ConsumeOffset` 获取下一个未被消费的消息就行了。\n\n上述就是我对于整个消息存储架构的大概理解(这里不涉及到一些细节讨论，比如稀疏索引等等问题)，希望对你有帮助。\n\n因为有一个知识点因为写嗨了忘讲了，想想在哪里加也不好，所以我留给大家去思考🤔🤔一下吧。\n\n为什么 `CommitLog` 文件要设计成固定大小的长度呢？提醒：**内存映射机制**。\n\n## 总结\n\n总算把这篇博客写完了。我讲的你们还记得吗😅？\n\n这篇文章中我主要想大家介绍了\n\n1. 消息队列出现的原因\n2. 消息队列的作用(异步，解耦，削峰)\n3. 消息队列带来的一系列问题(消息堆积、重复消费、顺序消费、分布式事务等等)\n4. 消息队列的两种消息模型——队列和主题模式\n5. 分析了 `RocketMQ` 的技术架构(`NameServer` 、`Broker` 、`Producer` 、`Comsumer`)\n6. 结合 `RocketMQ` 回答了消息队列副作用的解决方案\n7. 介绍了 `RocketMQ` 的存储机制和刷盘策略。\n\n等等。。。\n\n> 如果喜欢可以点赞哟👍👍👍。\n"},d5e3:function(n,e,t){"use strict";t.r(e),e["default"]='## 1.案例驱动模式\n\n### 1.1案例驱动模式概述 (理解)\n\n通过我们已掌握的知识点,先实现一个案例,然后找出这个案例中,存在的一些问题,在通过新知识点解决问题\n\n### 1.2案例驱动模式的好处 (理解)\n\n+ 解决重复代码过多的冗余,提高代码的复用性\n+ 解决业务逻辑聚集紧密导致的可读性差,提高代码的可读性\n+ 解决代码可维护性差,提高代码的维护性\n\n## 2.分类思想 \n\n### 2.1分类思想概述 (理解) \n\n分工协作,专人干专事\n\n### 2.2黑马信息管理系统 (理解)\n\n+ Student类  标准学生类,封装键盘录入的学生信息(id , name , age , birthday)\n\n+ StudentDao类  Dao : (Data Access Object 缩写) 用于访问存储数据的数组或集合\n\n+ StudentService类  用来进行业务逻辑的处理(例如: 判断录入的id是否存在)\n\n+ StudentController类  和用户打交道(接收用户需求,采集用户信息,打印数据到控制台)\n\n  ![01_黑马信息管理系统分类](./day11-分类和static.img/01_黑马信息管理系统分类.png)\n\n## 3.分包思想\n\n### 3.1分包思想概述 (理解)\n\n如果将所有的类文件都放在同一个包下,不利于管理和后期维护,所以,对于不同功能的类文件,可以放在不同的包下进行管理\n\n### 3.2包的概述 (记忆)\n\n+ 包\n\n  本质上就是文件夹\n\n+ 创建包\n\n  多级包之间使用 " . " 进行分割\n  多级包的定义规范：公司的网站地址翻转(去掉www)\n  比如：黑马程序员的网站址为www.itheima.com\n  后期我们所定义的包的结构就是：com.itheima.其他的包名\n\n+ 包的命名规则\n\n  字母都是小写\n\n### 3.3包的注意事项 (理解) \n\n+ package语句必须是程序的第一条可执行的代码 \n+ package语句在一个java文件中只能有一个 \n+ 如果没有package,默认表示无包名 \n\n### 3.4类与类之间的访问 (理解) \n\n+ 同一个包下的访问\n\n  不需要导包，直接使用即可\n\n+ 不同包下的访问\n\n  1.import 导包后访问\n\n  2.通过全类名（包名 + 类名）访问\n\n+ 注意：import 、package 、class 三个关键字的摆放位置存在顺序关系\n\n  package 必须是程序的第一条可执行的代码\n\n  import 需要写在 package 下面\n\n  class 需要在 import 下面\n\n## 4.黑马信息管理系统\n\n### 4.1系统介绍 (理解) \n\n![02_黑马信息管理系统介绍](./day11-分类和static.img/02_黑马信息管理系统介绍.png)\n\n### 4.2学生管理系统 (应用) \n\n#### 4.2.1需求说明\n\n+ 添加学生: 键盘录入学生信息(id，name，age，birthday)\n\n  使用数组存储学生信息,要求学生的id不能重复\n\n+ 删除学生: 键盘录入要删除学生的id值,将该学生从数组中移除,如果录入的id在数组中不存在,需要重新录入\n\n+ 修改学生: 键盘录入要修改学生的id值和修改后的学生信息\n\n  将数组中该学生的信息修改,如果录入的id在数组中不存在,需要重新录入\n\n+ 查询学生: 将数组中存储的所有学生的信息输出到控制台\n\n#### 4.2.2实现步骤\n\n+ 环境搭建实现步骤 \n  | 包                                       | 存储的类                   | 作用                   |\n  | --------------------------------------- | ---------------------- | -------------------- |\n  | com.itheima.edu.info.manager.domain     | Student.java           | 封装学生信息               |\n  | com.itheima.edu.info.manager.dao        | StudentDao.java        | 访问存储数据的数组，进行赠删改查（库管） |\n  | com.itheima.edu.info.manager.service    | StudentService.java    | 业务的逻辑处理（业务员）         |\n  | com.itheima.edu.info.manager.controller | StudentController.java | 和用户打交道（客服接待）         |\n  | com.itheima.edu.info.manager.entry      | InfoManagerEntry.java  | 程序的入口类，提供一个main方法    |\n\n+ 菜单搭建实现步骤 \n\n  + 需求\n    + 黑马管理系统菜单搭建\n    + 学生管理系统菜单搭建\n  + 实现步骤\n    1. 展示欢迎页面,用输出语句完成主界面的编写\n    2. 获取用户的选择,用Scanner实现键盘录入数据\n    3. 根据用户的选择执行对应的操作,用switch语句完成操作的选择\n\n+ 添加功能实现步骤 \n\n  ![03_添加功能需求分析](./day11-分类和static.img/03_添加功能需求分析.png)\n\n\n+ 添加功能优化:判断id是否存在\n\n  ![04_判断id是否存在](./day11-分类和static.img/04_判断id是否存在.png)\n\n+ 查询功能实现步骤\n\n  ![05_查询功能需求分析](./day11-分类和static.img/05_查询功能需求分析.png)\n\n+ 删除功能实现步骤\n\n  ![06_删除功能需求分析](./day11-分类和static.img/06_删除功能需求分析.png)\n\n+ 修改功能实现步骤 \n\n  ![07_修改功能需求分析](./day11-分类和static.img/07_修改功能需求分析.png)\n\n+ 系统优化 \n\n  + 把updateStudent和deleteStudentById中录入学生id代码抽取到一个方法(inputStudentId)中\n    该方法的主要作用就是录入学生的id，方法的返回值为String类型\n\n\n  + 把addStudent和updateStudent中录入学生信息的代码抽取到一个方法(inputStudentInfo)中\n    该方法的主要作用就是录入学生的信息，并封装为学生对象，方法的返回值为Student类型 \n\n#### 4.2.3代码实现 \n\n学生类\n\n```java\npublic class Student {\n    private String id;\n    private String name;\n    private String age;\n    private String birthday;\n    String address;\n\n    public Student() {\n    }\n\n    public Student(String id, String name, String age, String birthday) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n        this.birthday = birthday;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getAge() {\n        return age;\n    }\n\n    public void setAge(String age) {\n        this.age = age;\n    }\n\n    public String getBirthday() {\n        return birthday;\n    }\n\n    public void setBirthday(String birthday) {\n        this.birthday = birthday;\n    }\n\n}\n```\n\n程序入口InfoManagerEntry类\n\n```java\npublic class InfoManagerEntry {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            // 主菜单搭建\n            System.out.println("--------欢迎来到黑马信息管理系统--------");\n            System.out.println("请输入您的选择: 1.学生管理  2.老师管理  3.退出");\n            String choice = sc.next();\n            switch (choice) {\n                case "1":\n                    // System.out.println("学生管理");\n                    // 开启学生管理系统\n                    StudentController studentController = new StudentController();\n                    studentController.start();\n                    break;\n                case "2":\n                    System.out.println("老师管理");\n                    TeacherController teacherController = new TeacherController();\n                    teacherController.start();\n                    break;\n                case "3":\n                    System.out.println("感谢您的使用");\n                    // 退出当前正在运行的JVM虚拟机\n                    System.exit(0);\n                    break;\n                default:\n                    System.out.println("您的输入有误, 请重新输入");\n                    break;\n            }\n        }\n    }\n}\n```\n\nStudentController类\n\n```java\npublic class StudentController {\n    // 业务员对象\n    private StudentService studentService = new StudentService();\n\n    private Scanner sc = new Scanner(System.in);\n\n    // 开启学生管理系统, 并展示学生管理系统菜单\n    public void start() {\n        //Scanner sc = new Scanner(System.in);\n        studentLoop:\n        while (true) {\n            System.out.println("--------欢迎来到 <学生> 管理系统--------");\n            System.out.println("请输入您的选择: 1.添加学生  2.删除学生  3.修改学生  4.查看学生  5.退出");\n            String choice = sc.next();\n            switch (choice) {\n                case "1":\n                    // System.out.println("添加");\n                    addStudent();\n                    break;\n                case "2":\n                    // System.out.println("删除");\n                    deleteStudentById();\n                    break;\n                case "3":\n                    // System.out.println("修改");\n                    updateStudent();\n                    break;\n                case "4":\n                    // System.out.println("查询");\n                    findAllStudent();\n                    break;\n                case "5":\n                    System.out.println("感谢您使用学生管理系统, 再见!");\n                    break studentLoop;\n                default:\n                    System.out.println("您的输入有误, 请重新输入");\n                    break;\n            }\n        }\n    }\n\n    // 修改学生方法\n    public void updateStudent() {\n        String updateId = inputStudentId();\n        Student newStu = inputStudentInfo(updateId);\n        studentService.updateStudent(updateId, newStu);\n\n        System.out.println("修改成功!");\n    }\n\n    // 删除学生方法\n    public void deleteStudentById() {\n        String delId = inputStudentId();\n        // 3. 调用业务员中的deleteStudentById根据id, 删除学生\n        studentService.deleteStudentById(delId);\n        // 4. 提示删除成功\n        System.out.println("删除成功!");\n    }\n\n    // 查看学生方法\n    public void findAllStudent() {\n        // 1. 调用业务员中的获取方法, 得到学生的对象数组\n        Student[] stus = studentService.findAllStudent();\n        // 2. 判断数组的内存地址, 是否为null\n        if (stus == null) {\n            System.out.println("查无信息, 请添加后重试");\n            return;\n        }\n        // 3. 遍历数组, 获取学生信息并打印在控制台\n        System.out.println("学号\\t\\t姓名\\t年龄\\t生日");\n        for (int i = 0; i < stus.length; i++) {\n            Student stu = stus[i];\n            if (stu != null) {\n                System.out.println(stu.getId() + "\\t" + stu.getName() + "\\t" + stu.getAge() + "\\t\\t" + stu.getBirthday());\n            }\n        }\n    }\n\n    // 添加学生方法\n    public void addStudent() {\n        // StudentService studentService = new StudentService();\n        // 1. 键盘接收学生信息\n        String id;\n        while (true) {\n            System.out.println("请输入学生id:");\n            id = sc.next();\n            boolean flag = studentService.isExists(id);\n            if (flag) {\n                System.out.println("学号已被占用, 请重新输入");\n            } else {\n                break;\n            }\n        }\n\n        Student stu = inputStudentInfo(id);\n\n        // 3. 将学生对象,传递给StudentService(业务员)中的addStudent方法\n        boolean result = studentService.addStudent(stu);\n        // 4. 根据返回的boolean类型结果, 在控制台打印成功\\失败\n        if (result) {\n            System.out.println("添加成功");\n        } else {\n            System.out.println("添加失败");\n        }\n    }\n\n    // 键盘录入学生id\n    public String inputStudentId() {\n        String id;\n        while (true) {\n            System.out.println("请输入学生id:");\n            id = sc.next();\n            boolean exists = studentService.isExists(id);\n            if (!exists) {\n                System.out.println("您输入的id不存在, 请重新输入:");\n            } else {\n                break;\n            }\n        }\n        return id;\n    }\n\n    // 键盘录入学生信息\n    public Student inputStudentInfo(String id) {\n        System.out.println("请输入学生姓名:");\n        String name = sc.next();\n        System.out.println("请输入学生年龄:");\n        String age = sc.next();\n        System.out.println("请输入学生生日:");\n        String birthday = sc.next();\n        Student stu = new Student();\n        stu.setId(id);\n        stu.setName(name);\n        stu.setAge(age);\n        stu.setBirthday(birthday);\n        return stu;\n    }\n}\n```\n\nStudentService类\n\n```java\npublic class StudentService {\n    // 创建StudentDao (库管)\n    private StudentDao studentDao = new StudentDao();\n    // 添加学生方法\n    public boolean addStudent(Student stu) {\n        // 2. 将学生对象, 传递给StudentDao 库管中的addStudent方法\n        // 3. 将返回的boolean类型结果, 返还给StudentController\n        return studentDao.addStudent(stu);\n    }\n    // 判断学号是否存在方法\n    public boolean isExists(String id) {\n        Student[] stus = studentDao.findAllStudent();\n        // 假设id在数组中不存在\n        boolean exists = false;\n        // 遍历数组, 获取每一个学生对象, 准备进行判断\n        for (int i = 0; i < stus.length; i++) {\n            Student student = stus[i];\n            if(student != null && student.getId().equals(id)){\n                exists = true;\n                break;\n            }\n        }\n\n        return exists;\n    }\n    // 查看学生方法\n    public Student[] findAllStudent() {\n        // 1. 调用库管对象的findAllStudent获取学生对象数组\n        Student[] allStudent = studentDao.findAllStudent();\n        // 2. 判断数组中是否有学生信息 (有: 返回地址,  没有: 返回null)\n        // 思路: 数组中只要存在一个不是null的元素, 那就代表有学生信息\n        boolean flag = false;\n        for (int i = 0; i < allStudent.length; i++) {\n            Student stu = allStudent[i];\n            if(stu != null){\n                flag = true;\n                break;\n            }\n        }\n\n        if(flag){\n            // 有信息\n            return allStudent;\n        }else{\n            // 没有信息\n            return null;\n        }\n\n    }\n\n    public void deleteStudentById(String delId) {\n        studentDao.deleteStudentById(delId);\n    }\n\n    public void updateStudent(String updateId, Student newStu) {\n        studentDao.updateStudent(updateId, newStu);\n    }\n}\n```\n\nStudentDao类\n\n```java\npublic class StudentDao {\n    // 创建学生对象数组\n    private static Student[] stus = new Student[5];\n    // 添加学生方法\n    public boolean addStudent(Student stu) {\n\n        // 2. 添加学生到数组\n        //2.1 定义变量index为-1，假设数组已经全部存满，没有null的元素\n        int index = -1;\n        //2.2 遍历数组取出每一个元素，判断是否是null\n        for (int i = 0; i < stus.length; i++) {\n            Student student = stus[i];\n            if(student == null){\n                index = i;\n                //2.3 如果为null，让index变量记录当前索引位置，并使用break结束循环遍历\n                break;\n            }\n        }\n\n        // 3. 返回是否添加成功的boolean类型状态\n        if(index == -1){\n            // 装满了\n            return false;\n        }else{\n            // 没有装满, 正常添加, 返回true\n            stus[index] = stu;\n            return true;\n        }\n    }\n    // 查看学生方法\n    public Student[] findAllStudent() {\n        return stus;\n    }\n\n    public void deleteStudentById(String delId) {\n        // 1. 查找id在容器中所在的索引位置\n        int index = getIndex(delId);\n        // 2. 将该索引位置,使用null元素进行覆盖\n        stus[index] = null;\n    }\n\n    public int getIndex(String id){\n        int index = -1;\n        for (int i = 0; i < stus.length; i++) {\n            Student stu = stus[i];\n            if(stu != null && stu.getId().equals(id)){\n                index = i;\n                break;\n            }\n        }\n        return index;\n    }\n\n    public void updateStudent(String updateId, Student newStu) {\n        // 1. 查找updateId, 在容器中的索引位置\n        int index = getIndex(updateId);\n        // 2. 将该索引位置, 使用新的学生对象替换\n        stus[index] = newStu;\n    }\n}\n```\n\n### 4.3老师管理系统 (应用) \n\n#### 4.3.1需求说明 \n\n+ 添加老师: 通过键盘录入老师信息(id，name，age，birthday)\n\n  使用数组存储老师信息,要求老师的id不能重复\n\n+ 删除老师: 通过键盘录入要删除老师的id值,将该老师从数组中移除,如果录入的id在数组中不存在,需要重新录入\n\n+ 修改老师: 通过键盘录入要修改老师的id值和修改后的老师信息\n\n  将数组中该老师的信息修改,如果录入的id在数组中不存在,需要重新录入\n\n+ 查询老师: 将数组中存储的所有老师的信息输出到控制台\n\n#### 4.3.2实现步骤 \n\n+ 环境搭建实现步骤\n\n  | 包                                       | 存储的类                                     | 作用                   |\n  | --------------------------------------- | ---------------------------------------- | -------------------- |\n  | com.itheima.edu.info.manager.domain     | Student.java   Teacher.java              | 封装学生信息  封装老师信息       |\n  | com.itheima.edu.info.manager.dao        | StudentDao.java  TeacherDao.java         | 访问存储数据的数组,进行赠删改查（库管） |\n  | com.itheima.edu.info.manager.service    | StudentService.java  TeacherService.java | 业务的逻辑处理（业务员）         |\n  | com.itheima.edu.info.manager.controller | StudentController.java  TeacherController.java | 和用户打交道（客服接待）         |\n  | com.itheima.edu.info.manager.entry      | InfoManagerEntry.java                    | 程序的入口类,提供一个main方法    |\n\n+ 菜单搭建实现步骤\n\n  1. 展示欢迎页面,用输出语句完成主界面的编写\n  2. 获取用户的选择,用Scanner实现键盘录入数据\n  3. 根据用户的选择执行对应的操作,用switch语句完成操作的选择\n\n+ 添加功能实现步骤\n\n  ![10_添加老师功能实现步骤](./day11-分类和static.img/10_添加老师功能实现步骤.png)\n\n+ 查询功能实现步骤\n\n  ![11_查询老师功能实现步骤](./day11-分类和static.img/11_查询老师功能实现步骤.png)\n\n+ 删除功能实现步骤\n\n  ![12_删除老师功能实现步骤](./day11-分类和static.img/12_删除老师功能实现步骤.png)\n\n+ 修改功能实现步骤\n\n  ![13_修改老师功能实现步骤](./day11-分类和static.img/13_修改老师功能实现步骤.png)\n\n+ 系统优化\n\n  + 把updateTeacher和deleteTeacherById中录入老师id代码抽取到一个方法(inputTeacherId)中\n    该方法的主要作用就是录入老师的id,方法的返回值为String类型\n  + 把addTeacher和updateTeacher中录入老师信息的代码抽取到一个方法(inputTeacherInfo)中\n    该方法的主要作用就是录入老师的信息,并封装为老师对象,方法的返回值为Teacher类型\n\n#### 4.3.3代码实现\n\n老师类\n\n```java\npublic class Teacher extends Person{\n\tprivate String id;\n    private String name;\n    private String age;\n    private String birthday;\n    String address;\n\n    public Teacher() {\n    }\n\n    public Teacher(String id, String name, String age, String birthday) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n        this.birthday = birthday;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getAge() {\n        return age;\n    }\n\n    public void setAge(String age) {\n        this.age = age;\n    }\n\n    public String getBirthday() {\n        return birthday;\n    }\n\n    public void setBirthday(String birthday) {\n        this.birthday = birthday;\n    }\n}\n```\n\nTeacherController类\n\n```java\npublic class TeacherController {\n\n    private Scanner sc = new Scanner(System.in);\n    private TeacherService teacherService = new TeacherService();\n\n    public void start() {\n\n        teacherLoop:\n        while (true) {\n            System.out.println("--------欢迎来到 <老师> 管理系统--------");\n            System.out.println("请输入您的选择: 1.添加老师  2.删除老师  3.修改老师  4.查看老师  5.退出");\n            String choice = sc.next();\n            switch (choice) {\n                case "1":\n                    // System.out.println("添加老师");\n                    addTeacher();\n                    break;\n                case "2":\n                    // System.out.println("删除老师");\n                    deleteTeacherById();\n                    break;\n                case "3":\n                    // System.out.println("修改老师");\n                    updateTeacher();\n                    break;\n                case "4":\n                    // System.out.println("查看老师");\n                    findAllTeacher();\n                    break;\n                case "5":\n                    System.out.println("感谢您使用老师管理系统, 再见!");\n                    break teacherLoop;\n                default:\n                    System.out.println("您的输入有误, 请重新输入");\n                    break;\n            }\n        }\n\n    }\n\n    public void updateTeacher() {\n        String id = inputTeacherId();\n\n        Teacher newTeacher = inputTeacherInfo(id);\n\n        // 调用业务员的修改方法\n        teacherService.updateTeacher(id,newTeacher);\n        System.out.println("修改成功");\n    }\n\n    public void deleteTeacherById() {\n\n        String id = inputTeacherId();\n\n        // 2. 调用业务员中的删除方法, 根据id, 删除老师\n        teacherService.deleteTeacherById(id);\n\n        // 3. 提示删除成功\n        System.out.println("删除成功");\n\n\n    }\n\n    public void findAllTeacher() {\n        // 1. 从业务员中, 获取老师对象数组\n        Teacher[] teachers = teacherService.findAllTeacher();\n\n        // 2. 判断数组中是否有元素\n        if (teachers == null) {\n            System.out.println("查无信息, 请添加后重试");\n            return;\n        }\n\n        // 3. 遍历数组, 取出元素, 并打印在控制台\n        System.out.println("学号\\t\\t姓名\\t年龄\\t生日");\n        for (int i = 0; i < teachers.length; i++) {\n            Teacher t = teachers[i];\n            if (t != null) {\n                System.out.println(t.getId() + "\\t" + t.getName() + "\\t" + t.getAge() + "\\t\\t" + t.getBirthday());\n            }\n        }\n    }\n\n    public void addTeacher() {\n        String id;\n        while (true) {\n            // 1. 接收不存在的老师id\n            System.out.println("请输入老师id:");\n            id = sc.next();\n            // 2. 判断id是否存在\n            boolean exists = teacherService.isExists(id);\n\n            if (exists) {\n                System.out.println("id已被占用, 请重新输入:");\n            } else {\n                break;\n            }\n        }\n\n        Teacher t = inputTeacherInfo(id);\n\n        // 5. 将封装好的老师对象, 传递给TeacherService继续完成添加操作\n        boolean result = teacherService.addTeacher(t);\n\n        if (result) {\n            System.out.println("添加成功");\n        } else {\n            System.out.println("添加失败");\n        }\n    }\n\n    // 录入老师id\n    public String inputTeacherId(){\n        String id;\n        while(true){\n            System.out.println("请输入id");\n            id = sc.next();\n            boolean exists = teacherService.isExists(id);\n            if(!exists){\n                System.out.println("您输入的id不存在, 请重新输入:");\n            }else{\n                break;\n            }\n        }\n        return id;\n    }\n\n    // 录入老师信息, 封装为老师对象\n    public Teacher inputTeacherInfo(String id){\n        System.out.println("请输入老师姓名:");\n        String name = sc.next();\n        System.out.println("请输入老师年龄:");\n        String age = sc.next();\n        System.out.println("请输入老师生日:");\n        String birthday = sc.next();\n\n        Teacher t = new Teacher();\n        t.setId(id);\n        t.setName(name);\n        t.setAge(age);\n        t.setBirthday(birthday);\n\n        return t;\n    }\n}\n```\n\nTeacherService类\n\n```java\npublic class TeacherService {\n\n    private TeacherDao teacherDao = new TeacherDao();\n\n    public boolean addTeacher(Teacher t) {\n        return teacherDao.addTeacher(t);\n    }\n\n    public boolean isExists(String id) {\n        // 1. 获取库管对象中的数组\n        Teacher[] teachers = teacherDao.findAllTeacher();\n\n        boolean exists = false;\n\n        // 2. 遍历数组, 取出每一个元素, 进行判断\n        for (int i = 0; i < teachers.length; i++) {\n            Teacher teacher = teachers[i];\n            if(teacher != null && teacher.getId().equals(id)){\n                exists = true;\n                break;\n            }\n        }\n\n        return exists;\n    }\n\n    public Teacher[] findAllTeacher() {\n        Teacher[] allTeacher = teacherDao.findAllTeacher();\n\n        boolean flag = false;\n\n        for (int i = 0; i < allTeacher.length; i++) {\n            Teacher t = allTeacher[i];\n            if(t != null){\n                flag = true;\n                break;\n            }\n        }\n\n        if(flag){\n            return allTeacher;\n        }else{\n            return null;\n        }\n\n    }\n\n    public void deleteTeacherById(String id) {\n        teacherDao.deleteTeacherById(id);\n    }\n\n    public void updateTeacher(String id, Teacher newTeacher) {\n        teacherDao.updateTeacher(id,newTeacher);\n    }\n}\n```\n\nTeacherDao类\n\n```java\npublic class TeacherDao {\n\n    private static Teacher[] teachers = new Teacher[5];\n\n    public boolean addTeacher(Teacher t) {\n        int index = -1;\n        for (int i = 0; i < teachers.length; i++) {\n            Teacher teacher = teachers[i];\n            if(teacher == null){\n                index = i;\n                break;\n            }\n        }\n\n        if(index == -1){\n            return false;\n        }else{\n            teachers[index] = t;\n            return true;\n        }\n\n    }\n\n    public Teacher[] findAllTeacher() {\n        return teachers;\n    }\n\n    public void deleteTeacherById(String id) {\n        // 1. 查询id在数组中的索引位置\n        int index = getIndex(id);\n        // 2. 将该索引位置的元素, 使用null进行替换\n        teachers[index] = null;\n    }\n\n    public int getIndex(String id){\n        int index = -1;\n        for (int i = 0; i < teachers.length; i++) {\n            Teacher t = teachers[i];\n            if(t != null && t.getId().equals(id)){\n                index = i;\n                break;\n            }\n        }\n\n        return index;\n    }\n\n    public void updateTeacher(String id, Teacher newTeacher) {\n        int index = getIndex(id);\n        teachers[index] = newTeacher;\n    }\n}\n```\n\n## 5.static关键字\n\n### 5.1static关键字概述 (理解)\n\nstatic 关键字是静态的意思,是Java中的一个修饰符,可以修饰成员方法,成员变量\n\n### 5.2static修饰的特点 (记忆) \n\n+ 被类的所有对象共享\n\n  是我们判断是否使用静态关键字的条件\n\n+ 随着类的加载而加载，优先于对象存在\n\n  对象需要类被加载后，才能创建\n\n+ 可以通过类名调用\n\n  也可以通过对象名调用\n\n### 5.3static关键字注意事项 (理解)\n\n+ 静态方法只能访问静态的成员\n+ 非静态方法可以访问静态的成员，也可以访问非静态的成员\n+ 静态方法中是没有this关键字 '},d81b:function(n,e,t){"use strict";t.r(e),e["default"]='# 1 异步调用\r\n\r\n## 1.1 发送异步请求（回顾）  \r\n\r\n```js\r\n<a href="javascript:void(0);" id="testAjax">访问controller</a>\r\n<script type="text/javascript" src="/js/jquery-3.3.1.min.js"><\/script>\r\n<script type="text/javascript">\r\n    $(function(){\r\n    $("#testAjax").click(function(){ //为id="testAjax"的组件绑定点击事件\r\n        $.ajax({ //发送异步调用\r\n            type:"POST", //请求方式： POST请求\r\n            url:"ajaxController", //请求参数（也就是请求内容）\r\n            data:\'ajax message\', //请求参数（也就是请求内容）\r\n            dataType:"text", //响应正文类型\r\n            contentType:"application/text", //请求正文的MIME类型\r\n        });\r\n    });\r\n});\r\n<\/script>\r\n```\r\n\r\n## 1.2 接受异步请求参数\r\n\r\n 名称： @RequestBody\r\n 类型： 形参注解\r\n 位置：处理器类中的方法形参前方\r\n 作用：将异步提交数据组织成标准请求参数格式，并赋值给形参\r\n 范例：\r\n\r\n```java\r\n@RequestMapping("/ajaxController")\r\npublic String ajaxController(@RequestBody String message){\r\n    System.out.println(message);\r\n    return "page.jsp";\r\n}  \r\n```\r\n\r\n* 注解添加到Pojo参数前方时，封装的异步提交数据按照Pojo的属性格式进行关系映射\r\n* 注解添加到集合参数前方时，封装的异步提交数据按照集合的存储结构进行关系映射 \r\n\r\n```java\r\n@RequestMapping("/ajaxPojoToController")\r\n//如果处理参数是POJO，且页面发送的请求数据格式与POJO中的属性对应，@RequestBody注解可以自动映射对应请求数据到POJO中\r\n//注意：POJO中的属性如果请求数据中没有，属性值为null，POJO中没有的属性如果请求数据中有，不进行映射\r\npublic String  ajaxPojoToController(@RequestBody User user){\r\n    System.out.println("controller pojo :"+user);\r\n    return "page.jsp";\r\n}\r\n\r\n@RequestMapping("/ajaxListToController")\r\n//如果处理参数是List集合且封装了POJO，且页面发送的数据是JSON格式的对象数组，数据将自动映射到集合参数中\r\npublic String  ajaxListToController(@RequestBody List<User> userList){\r\n    System.out.println("controller list :"+userList);\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n## 1.3 异步请求接受响应数据\r\n\r\n* 方法返回值为Pojo时，自动封装数据成json对象数据\r\n\r\n```java\r\n@RequestMapping("/ajaxReturnJson")\r\n@ResponseBody\r\npublic User ajaxReturnJson(){\r\n    System.out.println("controller return json pojo...");\r\n    User user = new User();\r\n    user.setName("Jockme");\r\n    user.setAge(40);\r\n    return user;\r\n}  \r\n```\r\n\r\n* 方法返回值为List时，自动封装数据成json对象数组数据  \r\n\r\n```java\r\n@RequestMapping("/ajaxReturnJsonList")\r\n@ResponseBody\r\n//基于jackon技术，使用@ResponseBody注解可以将返回的保存POJO对象的集合转成json数组格式数据\r\npublic List ajaxReturnJsonList(){\r\n    System.out.println("controller return json list...");\r\n    User user1 = new User();\r\n    user1.setName("Tom");\r\n    user1.setAge(3);\r\n\r\n    User user2 = new User();\r\n    user2.setName("Jerry");\r\n    user2.setAge(5);\r\n\r\n    ArrayList al = new ArrayList();\r\n    al.add(user1);\r\n    al.add(user2);\r\n\r\n    return al;\r\n}\r\n```\r\n\r\n# 2 异步请求-跨域访问\r\n\r\n## 2.1 跨域访问介绍\r\n\r\n* 当通过域名A下的操作访问域名B下的资源时，称为跨域访问\r\n* 跨域访问时，会出现无法访问的现象   \r\n\r\n![image-20200427162623591](./SpringMVC-day02/image-20200427162623591.png)\r\n\r\n## 2.2 跨域环境搭建\r\n\r\n* 为当前主机添加备用域名\r\n  * 修改windows安装目录中的host文件\r\n  *  格式： ip 域名\r\n* 动态刷新DNS\r\n  *  命令： ipconfig /displaydns\r\n  *  命令： ipconfig /flushdns   \r\n\r\n## 2.3 跨域访问支持  \r\n\r\n 名称： @CrossOrigin\r\n 类型： 方法注解 、 类注解\r\n 位置：处理器类中的方法上方 或 类上方\r\n 作用：设置当前处理器方法/处理器类中所有方法支持跨域访问\r\n 范例：  \r\n\r\n```java\r\n@RequestMapping("/cross")\r\n@ResponseBody\r\n//使用@CrossOrigin开启跨域访问\r\n//标注在处理器方法上方表示该方法支持跨域访问\r\n//标注在处理器类上方表示该处理器类中的所有处理器方法均支持跨域访问\r\n@CrossOrigin\r\npublic User cross(HttpServletRequest request){\r\n    System.out.println("controller cross..."+request.getRequestURL());\r\n    User user = new User();\r\n    user.setName("Jockme");\r\n    user.setAge(39);\r\n    return user;\r\n}\r\n```\r\n\r\n# 3 拦截器\r\n\r\n## 3.1 拦截器概念\r\n\r\n* 请求处理过程解析  \r\n\r\n![image-20200427164038103](./SpringMVC-day02/image-20200427164038103.png)\r\n\r\n 拦截器（ Interceptor）是一种动态拦截方法调用的机制\r\n 作用：\r\n   \t1. 在指定的方法调用前后执行预先设定后的的代码\r\n \t2. 阻止原始方法的执行\r\n\r\n 核心原理： AOP思想\r\n 拦截器链：多个拦截器按照一定的顺序，对原始被调用功能进行增强  \r\n\r\n\r\n\r\n* **拦截器VS过滤器**\r\n   归属不同： Filter属于Servlet技术， Interceptor属于SpringMVC技术\r\n   拦截内容不同： Filter对所有访问进行增强， Interceptor仅针对SpringMVC的访问进行增强  \r\n  \r\n  ![image-20200427164512745](./SpringMVC-day02/image-20200427164512745.png)\r\n\r\n## 3.2 自定义拦截器开发过程\r\n\r\n* 实现HandlerInterceptor接口  \r\n\r\n  ```java\r\n  //自定义拦截器需要实现HandleInterceptor接口\r\n  public class MyInterceptor implements HandlerInterceptor {\r\n      //处理器运行之前执行\r\n      @Override\r\n      public boolean preHandle(HttpServletRequest request,\r\n                               HttpServletResponse response,\r\n                               Object handler) throws Exception {\r\n          System.out.println("前置运行----a1");\r\n          //返回值为false将拦截原始处理器的运行\r\n          //如果配置多拦截器，返回值为false将终止当前拦截器后面配置的拦截器的运行\r\n          return true;\r\n      }\r\n  \r\n      //处理器运行之后执行\r\n      @Override\r\n      public void postHandle(HttpServletRequest request,\r\n                             HttpServletResponse response,\r\n                             Object handler,\r\n                             ModelAndView modelAndView) throws Exception {\r\n          System.out.println("后置运行----b1");\r\n      }\r\n  \r\n      //所有拦截器的后置执行全部结束后，执行该操作\r\n      @Override\r\n      public void afterCompletion(HttpServletRequest request,\r\n                                  HttpServletResponse response,\r\n                                  Object handler,\r\n                                  Exception ex) throws Exception {\r\n          System.out.println("完成运行----c1");\r\n      }\r\n  \r\n      //三个方法的运行顺序为    preHandle -> postHandle -> afterCompletion\r\n      //如果preHandle返回值为false，三个方法仅运行preHandle\r\n  }\r\n  ```\r\n\r\n  \r\n\r\n*   配置拦截器  \r\n\r\n  配置拦截器  \r\n\r\n```xml\r\n<mvc:interceptors>\r\n    <mvc:interceptor>\r\n        <mvc:mapping path="/showPage"/>\r\n        <bean class="com.itheima.interceptor.MyInterceptor"/>\r\n    </mvc:interceptor>\r\n</mvc:interceptors>\r\n```\r\n\r\n  <u>注意：配置顺序为先配置执行位置，后配置执行类</u>  \r\n\r\n## 3.3 拦截器执行流程\r\n\r\n![image-20200427164840131](./SpringMVC-day02/image-20200427164840131.png)\r\n\r\n\r\n\r\n## 3.4 拦截器配置与方法参数\r\n\r\n### 3.4.1 前置处理方法\r\n\r\n原始方法之前运行\r\n\r\n```java\r\npublic boolean preHandle(HttpServletRequest request,\r\n                         HttpServletResponse response,\r\n                         Object handler) throws Exception {\r\n    System.out.println("preHandle");\r\n    return true;\r\n}\r\n```\r\n\r\n* 参数\r\n   request:请求对象\r\n   response:响应对象\r\n   handler:被调用的处理器对象，本质上是一个方法对象，对反射中的Method对象进行了再包装\r\n* 返回值\r\n   返回值为false，被拦截的处理器将不执行  \r\n\r\n### 3.4.2   后置处理方法\r\n\r\n原始方法运行后运行，如果原始方法被拦截，则不执行  \r\n\r\n```java\r\npublic void postHandle(HttpServletRequest request,\r\n                       HttpServletResponse response,\r\n                       Object handler,\r\n                       ModelAndView modelAndView) throws Exception {\r\n    System.out.println("postHandle");\r\n}\r\n```\r\n\r\n 参数\r\n modelAndView:如果处理器执行完成具有返回结果，可以读取到对应数据与页面信息，并进行调整  \r\n\r\n### 3.4.3 完成处理方法\r\n\r\n  拦截器最后执行的方法，无论原始方法是否执行  \r\n\r\n```java\r\npublic void afterCompletion(HttpServletRequest request,\r\n                            HttpServletResponse response,\r\n                            Object handler,\r\n                            Exception ex) throws Exception {\r\n    System.out.println("afterCompletion");\r\n}\r\n```\r\n\r\n 参数\r\n ex:如果处理器执行过程中出现异常对象，可以针对异常情况进行单独处理  \r\n\r\n## 3.5 拦截器配置项  \r\n\r\n```xml\r\n<mvc:interceptors>\r\n    \x3c!--开启具体的拦截器的使用，可以配置多个--\x3e\r\n    <mvc:interceptor>\r\n        \x3c!--设置拦截器的拦截路径，支持*通配--\x3e\r\n        \x3c!--/**         表示拦截所有映射--\x3e\r\n        \x3c!--/*          表示拦截所有/开头的映射--\x3e\r\n        \x3c!--/user/*     表示拦截所有/user/开头的映射--\x3e\r\n        \x3c!--/user/add*  表示拦截所有/user/开头，且具体映射名称以add开头的映射--\x3e\r\n        \x3c!--/user/*All  表示拦截所有/user/开头，且具体映射名称以All结尾的映射--\x3e\r\n        <mvc:mapping path="/*"/>\r\n        <mvc:mapping path="/**"/>\r\n        <mvc:mapping path="/handleRun*"/>\r\n        \x3c!--设置拦截排除的路径，配置/**或/*，达到快速配置的目的--\x3e\r\n        <mvc:exclude-mapping path="/b*"/>\r\n        \x3c!--指定具体的拦截器类--\x3e\r\n        <bean class="MyInterceptor"/>\r\n    </mvc:interceptor>\r\n</mvc:interceptors>\r\n```\r\n\r\n\r\n\r\n## 3.6 多拦截器配置\r\n\r\n![image-20200427171422781](./SpringMVC-day02/image-20200427171422781.png)\r\n\r\n**责任链模式**\r\n 责任链模式是一种行为模式\r\n 特征：\r\n沿着一条预先设定的任务链顺序执行，每个节点具有独立的工作任务\r\n 优势：\r\n独立性：只关注当前节点的任务，对其他任务直接放行到下一节点\r\n隔离性：具备链式传递特征，无需知晓整体链路结构，只需等待请求到达后进行处理即可\r\n灵活性：可以任意修改链路结构动态新增或删减整体链路责任\r\n解耦：将动态任务与原始任务解耦\r\n 弊端：\r\n链路过长时，处理效率低下\r\n可能存在节点上的循环引用现象，造成死循环，导致系统崩溃  \r\n\r\n# 4 异常处理\r\n\r\n## 4.1 异常处理器\r\n\r\n  **HandlerExceptionResolver**接口（异常处理器）  \r\n\r\n```java\r\n@Component\r\npublic class ExceptionResolver implements HandlerExceptionResolver {\r\n    public ModelAndView resolveException(HttpServletRequest request,\r\n                                         HttpServletResponse response,\r\n                                         Object handler,\r\n                                         Exception ex) {\r\n        System.out.println("异常处理器正在执行中");\r\n        ModelAndView modelAndView = new ModelAndView();\r\n        //定义异常现象出现后，反馈给用户查看的信息\r\n        modelAndView.addObject("msg","出错啦！ ");\r\n        //定义异常现象出现后，反馈给用户查看的页面\r\n        modelAndView.setViewName("error.jsp");\r\n        return modelAndView;\r\n    }\r\n}\r\n```\r\n\r\n  根据异常的种类不同，进行分门别类的管理，返回不同的信息  \r\n\r\n```java\r\npublic class ExceptionResolver implements HandlerExceptionResolver {\r\n    @Override\r\n    public ModelAndView resolveException(HttpServletRequest request,\r\n                                         HttpServletResponse response,\r\n                                         Object handler,\r\n                                         Exception ex) {\r\n        System.out.println("my exception is running ...."+ex);\r\n        ModelAndView modelAndView = new ModelAndView();\r\n        if( ex instanceof NullPointerException){\r\n            modelAndView.addObject("msg","空指针异常");\r\n        }else if ( ex instanceof  ArithmeticException){\r\n            modelAndView.addObject("msg","算数运算异常");\r\n        }else{\r\n            modelAndView.addObject("msg","未知的异常");\r\n        }\r\n        modelAndView.setViewName("error.jsp");\r\n        return modelAndView;\r\n    }\r\n}\r\n```\r\n\r\n## 4.2 注解开发异常处理器\r\n\r\n* 使用注解实现异常分类管理\r\n   名称： @ControllerAdvice\r\n   类型： 类注解\r\n   位置：异常处理器类上方\r\n   作用：设置当前类为异常处理器类\r\n   范例：\r\n\r\n```java\r\n@Component\r\n@ControllerAdvice\r\npublic class ExceptionAdvice {\r\n}  \r\n```\r\n\r\n* 使用注解实现异常分类管理\r\n   名称： @ExceptionHandler\r\n   类型： 方法注解\r\n   位置：异常处理器类中针对指定异常进行处理的方法上方\r\n   作用：设置指定异常的处理方式\r\n   范例：\r\n   说明：处理器方法可以设定多个\r\n ```java\r\n@ExceptionHandler(Exception.class)\r\n@ResponseBody\r\npublic String doOtherException(Exception ex){\r\n    return "出错啦，请联系管理员！ ";\r\n}  \r\n ```\r\n\r\n## 4.3 异常处理解决方案\r\n\r\n* 异常处理方案\r\n  * 业务异常：\r\n     发送对应消息传递给用户，提醒规范操作\r\n  * 系统异常：\r\n     发送固定消息传递给用户，安抚用户\r\n     发送特定消息给运维人员，提醒维护\r\n     记录日志\r\n  * 其他异常：\r\n     发送固定消息传递给用户，安抚用户\r\n     发送特定消息给编程人员，提醒维护\r\n     纳入预期范围内\r\n     记录日志  \r\n\r\n## 4.4 自定义异常\r\n\r\n* 异常定义格式\r\n\r\n  ```java\r\n  //自定义异常继承RuntimeException，覆盖父类所有的构造方法\r\n  public class BusinessException extends RuntimeException {\r\n      public BusinessException() {\r\n      }\r\n  \r\n      public BusinessException(String message) {\r\n          super(message);\r\n      }\r\n  \r\n      public BusinessException(String message, Throwable cause) {\r\n          super(message, cause);\r\n      }\r\n  \r\n      public BusinessException(Throwable cause) {\r\n          super(cause);\r\n      }\r\n  \r\n      public BusinessException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\r\n          super(message, cause, enableSuppression, writableStackTrace);\r\n      }\r\n  }\r\n  ```\r\n\r\n* 异常触发方式\r\n\r\n  ```java\r\n  if(user.getName().trim().length()<4) {\r\n      throw new BusinessException("用户名长度必须在2-4位之间，请重新输入！ ");\r\n  }\r\n  ```\r\n\r\n* 通过自定义异常将所有的异常现象进行分类管理，以统一的格式对外呈现异常消息  \r\n\r\n# 5 实用技术\r\n\r\n## 5.1 文件上传下载\r\n\r\n* 上传文件过程分析  \r\n\r\n  ![image-20200427174442939](./SpringMVC-day02/image-20200427174442939.png)\r\n\r\n*   MultipartResolver接口  \r\n\r\n  *  MultipartResolver接口定义了文件上传过程中的相关操作，并对通用性操作进行了封装\r\n  * MultipartResolver接口底层实现类CommonsMultipartResovler\r\n  * CommonsMultipartResovler并未自主实现文件上传下载对应的功能，而是调用了apache的文件上传下载组件  \r\n\r\n  ```xml\r\n  <dependency>\r\n      <groupId>commons-fileupload</groupId>\r\n      <artifactId>commons-fileupload</artifactId>\r\n      <version>1.4</version>\r\n  </dependency>\r\n  ```\r\n\r\n* 文件上传下载实现\r\n\r\n  *   页面表单  \r\n\r\n    ```html\r\n    <form action="/fileupload" method="post" enctype="multipart/form-data">\r\n        上传LOGO： <input type="file" name="file"/><br/>\r\n        <input type="submit" value="上传"/>\r\n    </form>\r\n    ```\r\n\r\n  *   SpringMVC配置  \r\n\r\n    ```xml\r\n    <bean id="multipartResolver"\r\n          class="org.springframework.web.multipart.commons.CommonsMultipartResolver">\r\n    </bean>\r\n    ```\r\n\r\n  *   控制器  \r\n\r\n    ```java\r\n    @RequestMapping(value = "/fileupload")\r\n    public void fileupload(MultipartFile file){\r\n        file.transferTo(new File("file.png"));\r\n    }\r\n    ```\r\n\r\n## 5.2 文件上传注意事项\r\n\r\n1. 文件命名问题， 获取上传文件名，并解析文件名与扩展名\r\n2. 文件名过长问题\r\n3. 文件保存路径\r\n4. 重名问题\r\n\r\n```java\r\n@RequestMapping(value = "/fileupload")\r\n//参数中定义MultipartFile参数，用于接收页面提交的type=file类型的表单，要求表单名称与参数名相同\r\npublic String fileupload(MultipartFile file,MultipartFile file1,MultipartFile file2, HttpServletRequest request) throws IOException {\r\n    System.out.println("file upload is running ..."+file);\r\n    //        MultipartFile参数中封装了上传的文件的相关信息\r\n    //        System.out.println(file.getSize());\r\n    //        System.out.println(file.getBytes().length);\r\n    //        System.out.println(file.getContentType());\r\n    //        System.out.println(file.getName());\r\n    //        System.out.println(file.getOriginalFilename());\r\n    //        System.out.println(file.isEmpty());\r\n    //首先判断是否是空文件，也就是存储空间占用为0的文件\r\n    if(!file.isEmpty()){\r\n        //如果大小在范围要求内正常处理，否则抛出自定义异常告知用户（未实现）\r\n        //获取原始上传的文件名，可以作为当前文件的真实名称保存到数据库中备用\r\n        String fileName = file.getOriginalFilename();\r\n        //设置保存的路径\r\n        String realPath = request.getServletContext().getRealPath("/images");\r\n        //保存文件的方法，指定保存的位置和文件名即可，通常文件名使用随机生成策略产生，避免文件名冲突问题\r\n        file.transferTo(new File(realPath,file.getOriginalFilename()));\r\n    }\r\n    //测试一次性上传多个文件\r\n    if(!file1.isEmpty()){\r\n        String fileName = file1.getOriginalFilename();\r\n        //可以根据需要，对不同种类的文件做不同的存储路径的区分，修改对应的保存位置即可\r\n        String realPath = request.getServletContext().getRealPath("/images");\r\n        file1.transferTo(new File(realPath,file1.getOriginalFilename()));\r\n    }\r\n    if(!file2.isEmpty()){\r\n        String fileName = file2.getOriginalFilename();\r\n        String realPath = request.getServletContext().getRealPath("/images");\r\n        file2.transferTo(new File(realPath,file2.getOriginalFilename()));\r\n    }\r\n    return "page.jsp";\r\n}\r\n```\r\n\r\n## 5.4 Restful风格配置\r\n\r\n### 5.4.1 Rest\r\n\r\n* Rest（ REpresentational State Transfer） 一种网络资源的访问风格，定义了网络资源的访问方式\r\n  * 传统风格访问路径\r\n     http://localhost/user/get?id=1\r\n     http://localhost/deleteUser?id=1\r\n  * Rest风格访问路径\r\n     http://localhost/user/1\r\n* Restful是按照Rest风格访问网络资源\r\n* 优点\r\n   隐藏资源的访问行为，通过地址无法得知做的是何种操作\r\n   书写简化\r\n\r\n### 5.4.2 Rest行为约定方式  \r\n\r\n GET（查询） http://localhost/user/1 GET\r\n POST（保存） http://localhost/user POST\r\n PUT（更新） http://localhost/user PUT\r\n DELETE（删除） http://localhost/user DELETE\r\n**注意：**上述行为是约定方式，约定不是规范，可以打破，所以称Rest风格，而不是Rest规范  \r\n\r\n### 5.4.3 Restful开发入门  \r\n\r\n```java\r\n//设置rest风格的控制器\r\n@RestController\r\n//设置公共访问路径，配合下方访问路径使用\r\n@RequestMapping("/user/")\r\npublic class UserController {\r\n\r\n    //rest风格访问路径完整书写方式\r\n    @RequestMapping("/user/{id}")\r\n    //使用@PathVariable注解获取路径上配置的具名变量，该配置可以使用多次\r\n    public String restLocation(@PathVariable Integer id){\r\n        System.out.println("restful is running ....");\r\n        return "success.jsp";\r\n    }\r\n\r\n    //rest风格访问路径简化书写方式，配合类注解@RequestMapping使用\r\n    @RequestMapping("{id}")\r\n    public String restLocation2(@PathVariable Integer id){\r\n        System.out.println("restful is running ....get:"+id);\r\n        return "success.jsp";\r\n    }\r\n\r\n    //接收GET请求配置方式\r\n    @RequestMapping(value = "{id}",method = RequestMethod.GET)\r\n    //接收GET请求简化配置方式\r\n    @GetMapping("{id}")\r\n    public String get(@PathVariable Integer id){\r\n        System.out.println("restful is running ....get:"+id);\r\n        return "success.jsp";\r\n    }\r\n\r\n    //接收POST请求配置方式\r\n    @RequestMapping(value = "{id}",method = RequestMethod.POST)\r\n    //接收POST请求简化配置方式\r\n    @PostMapping("{id}")\r\n    public String post(@PathVariable Integer id){\r\n        System.out.println("restful is running ....post:"+id);\r\n        return "success.jsp";\r\n    }\r\n\r\n    //接收PUT请求简化配置方式\r\n    @RequestMapping(value = "{id}",method = RequestMethod.PUT)\r\n    //接收PUT请求简化配置方式\r\n    @PutMapping("{id}")\r\n    public String put(@PathVariable Integer id){\r\n        System.out.println("restful is running ....put:"+id);\r\n        return "success.jsp";\r\n    }\r\n\r\n    //接收DELETE请求简化配置方式\r\n    @RequestMapping(value = "{id}",method = RequestMethod.DELETE)\r\n    //接收DELETE请求简化配置方式\r\n    @DeleteMapping("{id}")\r\n    public String delete(@PathVariable Integer id){\r\n        System.out.println("restful is running ....delete:"+id);\r\n        return "success.jsp";\r\n    }\r\n}\r\n```\r\n\r\n```xml\r\n\x3c!--配置拦截器，解析请求中的参数_method，否则无法发起PUT请求与DELETE请求，配合页面表单使用--\x3e\r\n<filter>\r\n    <filter-name>HiddenHttpMethodFilter</filter-name>\r\n    <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>\r\n</filter>\r\n<filter-mapping>\r\n    <filter-name>HiddenHttpMethodFilter</filter-name>\r\n    <servlet-name>DispatcherServlet</servlet-name>\r\n</filter-mapping>\r\n```\r\n\r\n 开启SpringMVC对Restful风格的访问支持过滤器，即可通过页面表单提交PUT与DELETE请求\r\n 页面表单使用隐藏域提交请求类型，参数名称固定为_method，必须配合提交类型method=post使用\r\n\r\n```xml\r\n<form action="/user/1" method="post">\r\n    <input type="hidden" name="_method" value="PUT"/>\r\n    <input type="submit"/>\r\n</form>  \r\n```\r\n\r\n*   Restful请求路径简化配置方式  \r\n\r\n  ```java\r\n  @RestController\r\n  public class UserController {\r\n      @RequestMapping(value = "/user/{id}",method = RequestMethod.DELETE)\r\n      public String restDelete(@PathVariable String id){\r\n          System.out.println("restful is running ....delete:"+id);\r\n          return "success.jsp";\r\n      }\r\n  }  \r\n  ```\r\n\r\n## 5.5 postman工具安装与使用\r\n\r\n**postman** 是  一款可以发送Restful风格请求的工具，方便开发调试。首次运行需要联网注册  \r\n\r\n![image-20200427180851880](./SpringMVC-day02/image-20200427180851880.png)\r\n\r\n'},da37:function(n,e,t){"use strict";t.r(e),e["default"]='\n\x3c!-- MarkdownTOC --\x3e\n\n- [简介](#简介)\n- [内部结构分析](#内部结构分析)\n- [LinkedList源码分析](#linkedlist源码分析)\n    - [构造方法](#构造方法)\n    - [添加（add）方法](#add方法)\n    - [根据位置取数据的方法](#根据位置取数据的方法)\n    - [根据对象得到索引的方法](#根据对象得到索引的方法)\n    - [检查链表是否包含某对象的方法：](#检查链表是否包含某对象的方法：)\n    - [删除（remove/pop）方法](#删除方法)\n- [LinkedList类常用方法测试：](#linkedlist类常用方法测试)\n\n\x3c!-- /MarkdownTOC --\x3e\n\n## <font face="楷体" id="1">简介</font>\n<font color="red">LinkedList</font>是一个实现了<font color="red">List接口</font>和<font color="red">Deque接口</font>的<font color="red">双端链表</font>。 \nLinkedList底层的链表结构使它<font color="red">支持高效的插入和删除操作</font>，另外它实现了Deque接口，使得LinkedList类也具有队列的特性;\nLinkedList<font color="red">不是线程安全的</font>，如果想使LinkedList变成线程安全的，可以调用静态类<font color="red">Collections类</font>中的<font color="red">synchronizedList</font>方法： \n```java\nList list=Collections.synchronizedList(new LinkedList(...));\n```\n## <font face="楷体" id="2">内部结构分析</font>\n**如下图所示：**\n\n![LinkedList内部结构](LinkedList源码分析.assets/LinkedList内部结构.png)\n看完了图之后，我们再看LinkedList类中的一个<font color="red">**内部私有类Node**</font>就很好理解了：\n\n```java\nprivate static class Node<E> {\n        E item;//节点值\n        Node<E> next;//后继节点\n        Node<E> prev;//前驱节点\n\n        Node(Node<E> prev, E element, Node<E> next) {\n            this.item = element;\n            this.next = next;\n            this.prev = prev;\n        }\n    }\n```\n这个类就代表双端链表的节点Node。这个类有三个属性，分别是前驱节点，本节点的值，后继结点。\n\n## <font face="楷体" id="3">LinkedList源码分析</font>\n### <font face="楷体" id="3.1">构造方法</font>\n**空构造方法：**\n```java\n    public LinkedList() {\n    }\n```\n**用已有的集合创建链表的构造方法：**\n```java\n    public LinkedList(Collection<? extends E> c) {\n        this();\n        addAll(c);\n    }\n```\n### <font face="楷体" id="3.2">add方法</font>\n**add(E e)** 方法：将元素添加到链表尾部\n```java\npublic boolean add(E e) {\n        linkLast(e);//这里就只调用了这一个方法\n        return true;\n    }\n```\n\n```java\n   /**\n     * 链接使e作为最后一个元素。\n     */\n    void linkLast(E e) {\n        final Node<E> l = last;\n        final Node<E> newNode = new Node<>(l, e, null);\n        last = newNode;//新建节点\n        if (l == null)\n            first = newNode;\n        else\n            l.next = newNode;//指向后继元素也就是指向下一个元素\n        size++;\n        modCount++;\n    }\n```\n**add(int index,E e)**：在指定位置添加元素\n```java\npublic void add(int index, E element) {\n        checkPositionIndex(index); //检查索引是否处于[0-size]之间\n\n        if (index == size)//添加在链表尾部\n            linkLast(element);\n        else//添加在链表中间\n            linkBefore(element, node(index));\n    }\n```\n<font color="red">linkBefore方法</font>需要给定两个参数，一个<font color="red">插入节点的值</font>，一个<font color="red">指定的node</font>，所以我们又调用了<font color="red">Node(index)去找到index对应的node</font>\n\n**addAll(Collection  c )：将集合插入到链表尾部**\n\n```java\npublic boolean addAll(Collection<? extends E> c) {\n        return addAll(size, c);\n    }\n```\n**addAll(int index, Collection c)：** 将集合从指定位置开始插入\n```java\npublic boolean addAll(int index, Collection<? extends E> c) {\n        //1:检查index范围是否在size之内\n        checkPositionIndex(index);\n\n        //2:toArray()方法把集合的数据存到对象数组中\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        if (numNew == 0)\n            return false;\n\n        //3：得到插入位置的前驱节点和后继节点\n        Node<E> pred, succ;\n        //如果插入位置为尾部，前驱节点为last，后继节点为null\n        if (index == size) {\n            succ = null;\n            pred = last;\n        }\n        //否则，调用node()方法得到后继节点，再得到前驱节点\n        else {\n            succ = node(index);\n            pred = succ.prev;\n        }\n\n        // 4：遍历数据将数据插入\n        for (Object o : a) {\n            @SuppressWarnings("unchecked") E e = (E) o;\n            //创建新节点\n            Node<E> newNode = new Node<>(pred, e, null);\n            //如果插入位置在链表头部\n            if (pred == null)\n                first = newNode;\n            else\n                pred.next = newNode;\n            pred = newNode;\n        }\n\n        //如果插入位置在尾部，重置last节点\n        if (succ == null) {\n            last = pred;\n        }\n        //否则，将插入的链表与先前链表连接起来\n        else {\n            pred.next = succ;\n            succ.prev = pred;\n        }\n\n        size += numNew;\n        modCount++;\n        return true;\n    }    \n```\n上面可以看出addAll方法通常包括下面四个步骤：\n1. 检查index范围是否在size之内\n2. toArray()方法把集合的数据存到对象数组中\n3. 得到插入位置的前驱和后继节点\n4. 遍历数据，将数据插入到指定位置\n\n**addFirst(E e)：** 将元素添加到链表头部\n```java\n public void addFirst(E e) {\n        linkFirst(e);\n    }\n```\n```java\nprivate void linkFirst(E e) {\n        final Node<E> f = first;\n        final Node<E> newNode = new Node<>(null, e, f);//新建节点，以头节点为后继节点\n        first = newNode;\n        //如果链表为空，last节点也指向该节点\n        if (f == null)\n            last = newNode;\n        //否则，将头节点的前驱指针指向新节点，也就是指向前一个元素\n        else\n            f.prev = newNode;\n        size++;\n        modCount++;\n    }\n```\n**addLast(E e)：** 将元素添加到链表尾部，与 **add(E e)** 方法一样\n```java\npublic void addLast(E e) {\n        linkLast(e);\n    }\n```\n### <font face="楷体" id="3.3">根据位置取数据的方法</font>\n**get(int index)：** 根据指定索引返回数据\n```java\npublic E get(int index) {\n        //检查index范围是否在size之内\n        checkElementIndex(index);\n        //调用Node(index)去找到index对应的node然后返回它的值\n        return node(index).item;\n    }\n```\n**获取头节点（index=0）数据方法:**\n```java\npublic E getFirst() {\n        final Node<E> f = first;\n        if (f == null)\n            throw new NoSuchElementException();\n        return f.item;\n    }\npublic E element() {\n        return getFirst();\n    }\npublic E peek() {\n        final Node<E> f = first;\n        return (f == null) ? null : f.item;\n    }\n\npublic E peekFirst() {\n        final Node<E> f = first;\n        return (f == null) ? null : f.item;\n     }\n```\n**区别：**\ngetFirst(),element(),peek(),peekFirst()\n这四个获取头结点方法的区别在于对链表为空时的处理，是抛出异常还是返回null，其中**getFirst()** 和**element()** 方法将会在链表为空时，抛出异常\n\nelement()方法的内部就是使用getFirst()实现的。它们会在链表为空时，抛出NoSuchElementException  \n**获取尾节点（index=-1）数据方法:**\n```java\n public E getLast() {\n        final Node<E> l = last;\n        if (l == null)\n            throw new NoSuchElementException();\n        return l.item;\n    }\n public E peekLast() {\n        final Node<E> l = last;\n        return (l == null) ? null : l.item;\n    }\n```\n**两者区别：**\n**getLast()** 方法在链表为空时，会抛出**NoSuchElementException**，而**peekLast()** 则不会，只是会返回 **null**。\n### <font face="楷体" id="3.4">根据对象得到索引的方法</font>\n**int indexOf(Object o)：** 从头遍历找\n```java\npublic int indexOf(Object o) {\n        int index = 0;\n        if (o == null) {\n            //从头遍历\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (x.item == null)\n                    return index;\n                index++;\n            }\n        } else {\n            //从头遍历\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (o.equals(x.item))\n                    return index;\n                index++;\n            }\n        }\n        return -1;\n    }\n```\n**int lastIndexOf(Object o)：** 从尾遍历找\n```java\npublic int lastIndexOf(Object o) {\n        int index = size;\n        if (o == null) {\n            //从尾遍历\n            for (Node<E> x = last; x != null; x = x.prev) {\n                index--;\n                if (x.item == null)\n                    return index;\n            }\n        } else {\n            //从尾遍历\n            for (Node<E> x = last; x != null; x = x.prev) {\n                index--;\n                if (o.equals(x.item))\n                    return index;\n            }\n        }\n        return -1;\n    }\n```\n### <font face="楷体" id="3.5">检查链表是否包含某对象的方法：</font>\n**contains(Object o)：** 检查对象o是否存在于链表中\n```java\n public boolean contains(Object o) {\n        return indexOf(o) != -1;\n    }\n```\n### <font face="楷体" id="3.6">删除方法</font>\n**remove()** ,**removeFirst(),pop():** 删除头节点\n```\npublic E pop() {\n        return removeFirst();\n    }\npublic E remove() {\n        return removeFirst();\n    }\npublic E removeFirst() {\n        final Node<E> f = first;\n        if (f == null)\n            throw new NoSuchElementException();\n        return unlinkFirst(f);\n    }\n```\n**removeLast(),pollLast():** 删除尾节点\n```java\npublic E removeLast() {\n        final Node<E> l = last;\n        if (l == null)\n            throw new NoSuchElementException();\n        return unlinkLast(l);\n    }\npublic E pollLast() {\n        final Node<E> l = last;\n        return (l == null) ? null : unlinkLast(l);\n    }\n```\n**区别：** removeLast()在链表为空时将抛出NoSuchElementException，而pollLast()方法返回null。\n\n**remove(Object o):** 删除指定元素\n```java\npublic boolean remove(Object o) {\n        //如果删除对象为null\n        if (o == null) {\n            //从头开始遍历\n            for (Node<E> x = first; x != null; x = x.next) {\n                //找到元素\n                if (x.item == null) {\n                   //从链表中移除找到的元素\n                    unlink(x);\n                    return true;\n                }\n            }\n        } else {\n            //从头开始遍历\n            for (Node<E> x = first; x != null; x = x.next) {\n                //找到元素\n                if (o.equals(x.item)) {\n                    //从链表中移除找到的元素\n                    unlink(x);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n```\n当删除指定对象时，只需调用remove(Object o)即可，不过该方法一次只会删除一个匹配的对象，如果删除了匹配对象，返回true，否则false。\n\nunlink(Node<E> x) 方法：\n```java\nE unlink(Node<E> x) {\n        // assert x != null;\n        final E element = x.item;\n        final Node<E> next = x.next;//得到后继节点\n        final Node<E> prev = x.prev;//得到前驱节点\n\n        //删除前驱指针\n        if (prev == null) {\n            first = next;//如果删除的节点是头节点,令头节点指向该节点的后继节点\n        } else {\n            prev.next = next;//将前驱节点的后继节点指向后继节点\n            x.prev = null;\n        }\n\n        //删除后继指针\n        if (next == null) {\n            last = prev;//如果删除的节点是尾节点,令尾节点指向该节点的前驱节点\n        } else {\n            next.prev = prev;\n            x.next = null;\n        }\n\n        x.item = null;\n        size--;\n        modCount++;\n        return element;\n    }\n```\n**remove(int index)**：删除指定位置的元素\n```java\npublic E remove(int index) {\n        //检查index范围\n        checkElementIndex(index);\n        //将节点删除\n        return unlink(node(index));\n    }\n```\n## <font face="楷体" id="4">LinkedList类常用方法测试</font>\n\n```java\npackage list;\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\n\npublic class LinkedListDemo {\n    public static void main(String[] srgs) {\n        //创建存放int类型的linkedList\n        LinkedList<Integer> linkedList = new LinkedList<>();\n        /************************** linkedList的基本操作 ************************/\n        linkedList.addFirst(0); // 添加元素到列表开头\n        linkedList.add(1); // 在列表结尾添加元素\n        linkedList.add(2, 2); // 在指定位置添加元素\n        linkedList.addLast(3); // 添加元素到列表结尾\n        \n        System.out.println("LinkedList（直接输出的）: " + linkedList);\n\n        System.out.println("getFirst()获得第一个元素: " + linkedList.getFirst()); // 返回此列表的第一个元素\n        System.out.println("getLast()获得第最后一个元素: " + linkedList.getLast()); // 返回此列表的最后一个元素\n        System.out.println("removeFirst()删除第一个元素并返回: " + linkedList.removeFirst()); // 移除并返回此列表的第一个元素\n        System.out.println("removeLast()删除最后一个元素并返回: " + linkedList.removeLast()); // 移除并返回此列表的最后一个元素\n        System.out.println("After remove:" + linkedList);\n        System.out.println("contains()方法判断列表是否包含1这个元素:" + linkedList.contains(1)); // 判断此列表包含指定元素，如果是，则返回true\n        System.out.println("该linkedList的大小 : " + linkedList.size()); // 返回此列表的元素个数\n\n        /************************** 位置访问操作 ************************/\n        System.out.println("-----------------------------------------");\n        linkedList.set(1, 3); // 将此列表中指定位置的元素替换为指定的元素\n        System.out.println("After set(1, 3):" + linkedList);\n        System.out.println("get(1)获得指定位置（这里为1）的元素: " + linkedList.get(1)); // 返回此列表中指定位置处的元素\n\n        /************************** Search操作 ************************/\n        System.out.println("-----------------------------------------");\n        linkedList.add(3);\n        System.out.println("indexOf(3): " + linkedList.indexOf(3)); // 返回此列表中首次出现的指定元素的索引\n        System.out.println("lastIndexOf(3): " + linkedList.lastIndexOf(3));// 返回此列表中最后出现的指定元素的索引\n\n        /************************** Queue操作 ************************/\n        System.out.println("-----------------------------------------");\n        System.out.println("peek(): " + linkedList.peek()); // 获取但不移除此列表的头\n        System.out.println("element(): " + linkedList.element()); // 获取但不移除此列表的头\n        linkedList.poll(); // 获取并移除此列表的头\n        System.out.println("After poll():" + linkedList);\n        linkedList.remove();\n        System.out.println("After remove():" + linkedList); // 获取并移除此列表的头\n        linkedList.offer(4);\n        System.out.println("After offer(4):" + linkedList); // 将指定元素添加到此列表的末尾\n\n        /************************** Deque操作 ************************/\n        System.out.println("-----------------------------------------");\n        linkedList.offerFirst(2); // 在此列表的开头插入指定的元素\n        System.out.println("After offerFirst(2):" + linkedList);\n        linkedList.offerLast(5); // 在此列表末尾插入指定的元素\n        System.out.println("After offerLast(5):" + linkedList);\n        System.out.println("peekFirst(): " + linkedList.peekFirst()); // 获取但不移除此列表的第一个元素\n        System.out.println("peekLast(): " + linkedList.peekLast()); // 获取但不移除此列表的第一个元素\n        linkedList.pollFirst(); // 获取并移除此列表的第一个元素\n        System.out.println("After pollFirst():" + linkedList);\n        linkedList.pollLast(); // 获取并移除此列表的最后一个元素\n        System.out.println("After pollLast():" + linkedList);\n        linkedList.push(2); // 将元素推入此列表所表示的堆栈（插入到列表的头）\n        System.out.println("After push(2):" + linkedList);\n        linkedList.pop(); // 从此列表所表示的堆栈处弹出一个元素（获取并移除列表第一个元素）\n        System.out.println("After pop():" + linkedList);\n        linkedList.add(3);\n        linkedList.removeFirstOccurrence(3); // 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表）\n        System.out.println("After removeFirstOccurrence(3):" + linkedList);\n        linkedList.removeLastOccurrence(3); // 从此列表中移除最后一次出现的指定元素（从尾部到头部遍历列表）\n        System.out.println("After removeFirstOccurrence(3):" + linkedList);\n\n        /************************** 遍历操作 ************************/\n        System.out.println("-----------------------------------------");\n        linkedList.clear();\n        for (int i = 0; i < 100000; i++) {\n            linkedList.add(i);\n        }\n        // 迭代器遍历\n        long start = System.currentTimeMillis();\n        Iterator<Integer> iterator = linkedList.iterator();\n        while (iterator.hasNext()) {\n            iterator.next();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println("Iterator：" + (end - start) + " ms");\n\n        // 顺序遍历(随机遍历)\n        start = System.currentTimeMillis();\n        for (int i = 0; i < linkedList.size(); i++) {\n            linkedList.get(i);\n        }\n        end = System.currentTimeMillis();\n        System.out.println("for：" + (end - start) + " ms");\n\n        // 另一种for循环遍历\n        start = System.currentTimeMillis();\n        for (Integer i : linkedList)\n            ;\n        end = System.currentTimeMillis();\n        System.out.println("for2：" + (end - start) + " ms");\n\n        // 通过pollFirst()或pollLast()来遍历LinkedList\n        LinkedList<Integer> temp1 = new LinkedList<>();\n        temp1.addAll(linkedList);\n        start = System.currentTimeMillis();\n        while (temp1.size() != 0) {\n            temp1.pollFirst();\n        }\n        end = System.currentTimeMillis();\n        System.out.println("pollFirst()或pollLast()：" + (end - start) + " ms");\n\n        // 通过removeFirst()或removeLast()来遍历LinkedList\n        LinkedList<Integer> temp2 = new LinkedList<>();\n        temp2.addAll(linkedList);\n        start = System.currentTimeMillis();\n        while (temp2.size() != 0) {\n            temp2.removeFirst();\n        }\n        end = System.currentTimeMillis();\n        System.out.println("removeFirst()或removeLast()：" + (end - start) + " ms");\n    }\n}\n```\n'},e08d:function(n,e,t){var r={"./0.javaweb基础学习路径.md":"49d6","./1.jsp.md":"478a","./14.Web综合案例/web综合案例-day01.md":"24e5","./14.Web综合案例/web综合案例_day02.md":"51bf","./14.Web综合案例/web综合案例_day03.md":"23f3","./14.Web综合案例/web综合案例_day04.md":"b720","./14.Web综合案例/web综合案例day05.md":"22c9","./Cookie&SessionJsp-授课.md":"963a","./EL&Filter&Listener-授课.md":"8648","./Request&Response-授课.md":"8893","./Servlet-授课.md":"6502","./Tomcat&Http协议-授课.md":"d333"};function a(n){var e=i(n);return t(e)}function i(n){if(!t.o(r,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return r[n]}a.keys=function(){return Object.keys(r)},a.resolve=i,n.exports=a,a.id="e08d"},e0c0:function(n,e,t){"use strict";t.r(e),e["default"]='\x3c!--\r\n * @Date           : 2021-04-27 00:23:17\r\n * @FilePath       : /jinnian-space/src/pages/java/module/basics/md/day07-面向对象.md\r\n * @Description    : \r\n--\x3e\r\n## 1. 类和对象\r\n\r\n**面向对象和面向过程的思想对比 : **\r\n\r\n​\t**面向过程 ：**是一种以过程为中心的编程思想，实现功能的每一步，都是自己实现的\r\n\r\n​\t**面向对象 ：**是一种以对象为中心的编程思想，通过指挥对象实现具体的功能\r\n\r\n### 1.1 类和对象的关系\r\n\r\n客观存在的事物皆为对象 ，所以我们也常常说万物皆对象。\r\n\r\n* 类\r\n  * 类的理解\r\n    * 类是对现实生活中一类具有共同属性和行为的事物的抽象\r\n    * 类是对象的数据类型，类是具有相同属性和行为的一组对象的集合\r\n    * 简单理解：类就是对现实事物的一种描述\r\n  * 类的组成\r\n    * 属性：指事物的特征，例如：手机事物（品牌，价格，尺寸）\r\n    * 行为：指事物能执行的操作，例如：手机事物（打电话，发短信）\r\n* 类和对象的关系\r\n  * 类：类是对现实生活中一类具有共同属性和行为的事物的抽象\r\n  * 对象：是能够看得到摸的着的真实存在的实体\r\n  * 简单理解：**类是对事物的一种描述，对象则为具体存在的事物**\r\n\r\n### 1.2 类的定义【应用】\r\n\r\n类的组成是由属性和行为两部分组成\r\n\r\n* **属性：**在类中通过成员变量来体现（类中方法外的变量）\r\n* **行为：**在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可）\r\n\r\n**类的定义步骤：**\r\n\r\n​\t① 定义类\r\n\r\n​\t② 编写类的成员变量\r\n\r\n​\t③ 编写类的成员方法\r\n\r\n```java\r\npublic class Student {\r\n    // 属性 : 姓名, 年龄\r\n    // 成员变量: 跟之前定义变量的格式一样, 只不过位置发生了改变, 类中方法外\r\n    String name;\r\n    int age;\r\n\r\n    // 行为 : 学习\r\n    // 成员方法: 跟之前定义方法的格式一样, 只不过去掉了static关键字.\r\n    public void study(){\r\n        System.out.println("学习");\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 1.3 对象的创建和使用\r\n\r\n* **创建对象的格式：**\r\n  * 类名 对象名 = new 类名();\r\n* **调用成员的格式：**\r\n  * 对象名.成员变量\r\n  * 对象名.成员方法();\r\n* **示例代码 : **\r\n\r\n```java\r\npackage com.itheima.object1;\r\n\r\npublic class TestStudent {\r\n    /*\r\n        创建对象的格式:\r\n                类名 对象名 = new 类名();\r\n        调用成员变量的格式:\r\n                对象名.变量名\r\n        调用成员方法的格式:\r\n                对象名.方法名();\r\n     */\r\n    public static void main(String[] args) {\r\n        // 类名 对象名 = new 类名();\r\n        Student stu = new Student();\r\n        // 对象名.变量名\r\n        // 默认初始化值\r\n        System.out.println(stu.name);  // null\r\n        System.out.println(stu.age);   // 0\r\n\r\n        stu.name = "张三";\r\n        stu.age = 23;\r\n\r\n        System.out.println(stu.name);  // 张三\r\n        System.out.println(stu.age);   // 23\r\n\r\n        // 对象名.方法名();\r\n        stu.study();\r\n        // com.itheima.object1.Student@b4c966a\r\n        // 全类名(包名 + 类名)\r\n        System.out.println(stu);\r\n    }\r\n}\r\n```\r\n\r\n### 1.4 案例-手机类的创建和使用\r\n\r\n**需求 ：**首先定义一个手机类，然后定义一个手机测试类，在手机测试类中通过对象完成成员变量和成员方法的使用\r\n\r\n**分析 ：**\r\n* 成员变量：品牌, 价格\r\n* 成员方法：打电话, 发短信\r\n\r\n* 示例代码：\r\n\r\n```java\r\npackage com.itheima.test1;\r\n\r\npublic class Phone {\r\n    // 品牌, 价格\r\n    String brand;\r\n    int price;\r\n\r\n    // 打电话, 发短信\r\n    public void call(String name){\r\n        System.out.println("给"+name+"打电话");\r\n    }\r\n\r\n    public void sendMessage(){\r\n        System.out.println("群发短信");\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npackage com.itheima.test1;\r\n\r\npublic class TestPhone {\r\n    public static void main(String[] args) {\r\n        // 1. 创建对象\r\n        Phone p = new Phone();\r\n        // 2. 给成员变量进行赋值\r\n        p.brand = "大米";\r\n        p.price = 2999;\r\n        // 3. 打印赋值后的成员变量\r\n        System.out.println(p.brand + "..." + p.price);\r\n        // 4. 调用成员方法\r\n        p.call("阿强");\r\n        p.sendMessage();\r\n    }\r\n}\r\n```\r\n\r\n## 2. 对象内存图\r\n\r\n### 2.1 单个对象内存图【理解】\r\n\r\n* ![1590938666222](./day07-面向对象.img/1590938666222.png)\r\n\r\n\r\n\r\n### 2.2 多个对象内存图【理解】\r\n\r\n* ![1590938693756](./day07-面向对象.img/1590938693756.png)\r\n\r\n* **总结：**\r\n\r\n  多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自的内存区域中，成员方法多个对象共用的一份\r\n\r\n### 2.3 多个对象指向相同内存图【理解】\r\n\r\n![1590938711726](./day07-面向对象.img/1590938711726.png)\r\n\r\n* **总结 :** \r\n\r\n  当多个对象的引用指向同一个内存空间（变量所记录的地址值是一样的）\r\n\r\n  只要有任何一个对象修改了内存中的数据，随后，无论使用哪一个对象进行数据获取，都是修改后的数据。\r\n\r\n\r\n\r\n## 3. 成员变量和局部变量\r\n\r\n### 3.1 成员变量和局部变量的区别\r\n\r\n* **类中位置不同：**成员变量（类中方法外）局部变量（方法内部或方法声明上）\r\n* **内存中位置不同：**成员变量（堆内存）局部变量（栈内存）\r\n* **生命周期不同：**成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，醉着方法的调用完毕而消失）\r\n* **初始化值不同：**成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用）\r\n\r\n## 4. 封装\r\n\r\n### 4.1 private关键字\r\n\r\n​\t**概述 :** private是一个修饰符，可以用来修饰成员（成员变量，成员方法）\r\n\r\n​\t**特点 :** 被private修饰的成员，只能在本类进行访问，针对private修饰的成员变量，如果需要被其他类使用，\t提供相应的操作\r\n\r\n​\t\t提供“get变量名()”方法，用于获取成员变量的值，方法用public修饰\r\n\r\n​\t\t提供“set变量名(参数)”方法，用于设置成员变量的值，方法用public修饰\r\n\r\n​\t**示例代码：**\r\n\r\n```java\r\n/*\r\n    学生类\r\n */\r\nclass Student {\r\n    //成员变量\r\n    String name;\r\n    private int age;\r\n\r\n    //提供get/set方法\r\n    public void setAge(int a) {\r\n        if(a<0 || a>120) {\r\n            System.out.println("你给的年龄有误");\r\n        } else {\r\n            age = a;\r\n        }\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    //成员方法\r\n    public void show() {\r\n        System.out.println(name + "," + age);\r\n    }\r\n}\r\n/*\r\n    学生测试类\r\n */\r\npublic class StudentDemo {\r\n    public static void main(String[] args) {\r\n        //创建对象\r\n        Student s = new Student();\r\n        //给成员变量赋值\r\n        s.name = "林青霞";\r\n        s.setAge(30);\r\n        //调用show方法\r\n        s.show();\r\n    }\r\n}\r\n```\r\n### 4.2 private关键字的使用\r\n\r\n* **需求：**\r\n\r\n  * 定义标准的学生类，要求name和age使用private修饰\r\n  * 并提供set和get方法以及便于显示数据的show方法\r\n  * 测试类中创建对象并使用，最终控制台输出  林青霞，30 \r\n\r\n* **示例代码：**\r\n\r\n  ```java\r\n  /*\r\n      学生类\r\n   */\r\n  class Student {\r\n      //成员变量\r\n      private String name;\r\n      private int age;\r\n  \r\n      //get/set方法\r\n      public void setName(String n) {\r\n          name = n;\r\n      }\r\n  \r\n      public String getName() {\r\n          return name;\r\n      }\r\n  \r\n      public void setAge(int a) {\r\n          age = a;\r\n      }\r\n  \r\n      public int getAge() {\r\n          return age;\r\n      }\r\n  \r\n      public void show() {\r\n          System.out.println(name + "," + age);\r\n      }\r\n  }\r\n  /*\r\n      学生测试类\r\n   */\r\n  public class StudentDemo {\r\n      public static void main(String[] args) {\r\n          //创建对象\r\n          Student s = new Student();\r\n  \r\n          //使用set方法给成员变量赋值\r\n          s.setName("林青霞");\r\n          s.setAge(30);\r\n  \r\n          s.show();\r\n  \r\n          //使用get方法获取成员变量的值\r\n          System.out.println(s.getName() + "---" + s.getAge());\r\n          System.out.println(s.getName() + "," + s.getAge());\r\n  \r\n      }\r\n  }\r\n  ```\r\n\r\n### 4.3 this关键字【应用】\r\n\r\n**概述 :** this修饰的变量用于指代成员变量，其主要作用是（区分局部变量和成员变量的重名问题）\r\n* 方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量\r\n* 方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npublic class Student {\r\n    private String name;\r\n    private int age;\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void show() {\r\n        System.out.println(name + "," + age);\r\n    }\r\n}\r\n```\r\n\r\n### 4.4 this内存原理【理解】\r\n\r\n* **注意 :** this代表当前调用方法的引用，哪个对象调用的方法，this就代表哪一个对象\r\n\r\n* **图解 ：**\r\n\r\n* ![1590938942838](./day07-面向对象.img/1590938942838.png)\r\n\r\n  ![1590938969305](./day07-面向对象.img/1590938969305.png)\r\n\r\n### 4.5 封装思想\r\n\r\n1. **封装概述**\r\n    是面向对象三大特征之一（封装，继承，多态）\r\n    是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的\r\n2. **封装原则**\r\n    将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问\r\n    成员变量private，提供对应的getXxx()/setXxx()方法\r\n3. **封装好处**\r\n    通过方法来控制成员变量的操作，提高了代码的安全性\r\n    把代码用方法进行封装，提高了代码的复用性\r\n\r\n## 5. 构造方法\r\n\r\n### 5.1 构造方法的格式和执行时机\r\n\r\n* **格式注意 :**\r\n  *  方法名与类名相同，大小写也要一致\r\n  * 没有返回值类型，连void都没有\r\n  * 没有具体的返回值（不能由retrun带回结果数据）\r\n* **执行时机 ：**\r\n  * 创建对象的时候调用，每创建一次对象，就会执行一次构造方法\r\n  * 不能手动调用构造方法\r\n* **示例代码：**\r\n\r\n```java\r\nclass Student {\r\n    private String name;\r\n    private int age;\r\n\r\n    //构造方法\r\n    public Student() {\r\n        System.out.println("无参构造方法");\r\n    }\r\n\r\n    public void show() {\r\n        System.out.println(name + "," + age);\r\n    }\r\n}\r\n/*\r\n    测试类\r\n */\r\npublic class StudentDemo {\r\n    public static void main(String[] args) {\r\n        //创建对象\r\n        Student s = new Student();\r\n        s.show();\r\n    }\r\n}\r\n```\r\n\r\n### 5.2 构造方法的作用\r\n\r\n* 用于给对象的数据（属性）进行初始化\r\n\r\n```java\r\npackage com.itheima.constructor;\r\n\r\npublic class Student {\r\n    /*\r\n        格式:\r\n\r\n               1. 方法名需要跟类名相同, 大小写也要一致\r\n               2. 没有返回值类型, 连void都没有\r\n               3. 没有具体的返回值(不能由return带回具体的结果)\r\n     */\r\n\r\n    private String name;\r\n    private int age;\r\n\r\n    // 1. 如果一个类中没有编写任何构造方法, 系统将会提供一个默认的无参数构造方法\r\n    public Student(){}\r\n\r\n    // 2. 如果手动编写了构造方法, 系统就不会再提供默认的无参数构造方法了\r\n    public Student(String name, int age){\r\n        this.name = name;\r\n        this.age = age;\r\n        System.out.println("我是Student类的构造方法");\r\n    }\r\n\r\n    public void show(){\r\n        System.out.println(name + "..." + age);\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npackage com.itheima.constructor;\r\n\r\npublic class TestStudent {\r\n    public static void main(String[] args) {\r\n        Student stu1 = new Student("张三",23);\r\n        stu1.show();\r\n\r\n        Student stu2 = new Student();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 5.3 构造方法的注意事项\r\n\r\n**构造方法的创建 :** \r\n\r\n​\t如果没有定义构造方法，系统将给出一个默认的无参数构造方法\r\n\r\n​\t如果定义了构造方法，系统将不再提供默认的构造方法\r\n\r\n**构造方法的创建 :** \r\n\r\n​\t如果没有定义构造方法，系统将给出一个默认的无参数构造方法如果定义了构造方法，系统将不再提供默认的构造方法\r\n\r\n**推荐的使用方式 :** \r\n\r\n​\t无论是否使用，都手动书写无参数构造方法，和带参数构造方法\r\n\r\n\r\n\r\n### 5.4 标准类的代码编写和使用\r\n\r\n**代码 :** \r\n\r\n```java\r\npackage com.itheima.test3;\r\n\r\n/*\r\n    JavaBean类: 封装数据\r\n */\r\npublic class Student {\r\n    private String name;\r\n    private int age;\r\n\r\n    public Student() {\r\n    }\r\n\r\n    public Student(String name, int age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public void show(){\r\n        System.out.println(name + "..." + age);\r\n    }\r\n}\r\n\r\n```\r\n\r\n```java\r\npackage com.itheima.test3;\r\n\r\npublic class TestStudent {\r\n    public static void main(String[] args) {\r\n        // 1. 无参数构造方法创建对象, 通过setXxx方法给成员变量进行赋值\r\n        Student stu1 = new Student();\r\n        stu1.setName("张三");\r\n        stu1.setAge(23);\r\n        stu1.show();\r\n\r\n        // 2. 通过带参数构造方法, 直接给属性进行赋值\r\n        Student stu2 = new Student("李四",24);\r\n        stu2.show();\r\n    }\r\n}\r\n\r\n```\r\n\r\n'},e602:function(n,e,t){"use strict";t.r(e),e["default"]='# JWT 身份认证优缺点分析以及常见问题解决方案\n\n之前分享了一个使用 Spring Security 实现 JWT 身份认证的 Demo，文章地址：[适合初学者入门 Spring Security With JWT 的 Demo](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485622&idx=1&sn=e9750ed63c47457ba1896db8dfceac6a&chksm=cea2477df9d5ce6b7af20e582c6c60b7408a6459b05b849394c45f04664d1651510bdee029f7&token=684071313&lang=zh_CN&scene=21#wechat_redirect)。 Demo 非常简单，没有介绍到 JWT 存在的一些问题。所以，单独抽了一篇文章出来介绍。为了完成这篇文章，我查阅了很多资料和文献，我觉得应该对大家有帮助。\n\n相关阅读：\n\n- [《一问带你区分清楚Authentication,Authorization以及Cookie、Session、Token》](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485626&idx=1&sn=3247aa9000693dd692de8a04ccffeec1&chksm=cea24771f9d5ce675ea0203633a95b68bfe412dc6a9d05f22d221161147b76161d1b470d54b3&token=684071313&lang=zh_CN&scene=21#wechat_redirect)\n- [适合初学者入门 Spring Security With JWT 的 Demo](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485622&idx=1&sn=e9750ed63c47457ba1896db8dfceac6a&chksm=cea2477df9d5ce6b7af20e582c6c60b7408a6459b05b849394c45f04664d1651510bdee029f7&token=684071313&lang=zh_CN&scene=21#wechat_redirect) \n- [Spring Boot 使用 JWT 进行身份和权限验证](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485640&idx=1&sn=0ff147808318d53b371f16bb730c96ef&chksm=cea24703f9d5ce156ba67662f6f3f482330e8e6ebd9d44c61bf623083e9b941d8a180db6b0ea&token=1533246333&lang=zh_CN#rd)\n\n## Token 认证的优势\n\n 相比于 Session 认证的方式来说，使用 token 进行身份认证主要有下面四个优势：\n\n### 1.无状态\n\ntoken 自身包含了身份验证所需要的所有信息，使得我们的服务器不需要存储 Session 信息，这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。但是，也正是由于 token 的无状态，也导致了它最大的缺点：当后端在token 有效期内废弃一个 token 或者更改它的权限的话，不会立即生效，一般需要等到有效期过后才可以。另外，当用户 Logout 的话，token 也还有效。除非，我们在后端增加额外的处理逻辑。\n\n### 2.有效避免了CSRF 攻击\n\n**CSRF（Cross Site Request Forgery）** 一般被翻译为 **跨站请求伪造**，属于网络攻击领域范围。相比于 SQL 脚本注入、XSS等安全攻击方式，CSRF 的知名度并没有它们高。但是,它的确是每个系统都要考虑的安全隐患，就连技术帝国 Google 的 Gmail 在早些年也被曝出过存在  CSRF 漏洞，这给 Gmail 的用户造成了很大的损失。\n\n那么究竟什么是  **跨站请求伪造** 呢？说简单用你的身份去发送一些对你不友好的请求。举个简单的例子：\n\n小壮登录了某网上银行，他来到了网上银行的帖子区，看到一个帖子下面有一个链接写着“科学理财，年盈利率过万”，小壮好奇的点开了这个链接，结果发现自己的账户少了10000元。这是这么回事呢？原来黑客在链接中藏了一个请求，这个请求直接利用小壮的身份给银行发送了一个转账请求,也就是通过你的 Cookie 向银行发出请求。\n\n```html\n<a src="http://www.mybank.com/Transfer?bankId=11&money=10000">科学理财，年盈利率过万</a>\n```\n\n导致这个问题很大的原因就是： Session 认证中 Cookie 中的 session_id 是由浏览器发送到服务端的，借助这个特性，攻击者就可以通过让用户误点攻击链接，达到攻击效果。\n\n**那为什么 token 不会存在这种问题呢？**\n\n我是这样理解的：一般情况下我们使用 JWT 的话，在我们登录成功获得 token 之后，一般会选择存放在  local storage 中。然后我们在前端通过某些方式会给每个发到后端的请求加上这个 token,这样就不会出现 CSRF 漏洞的问题。因为，即使你点击了非法链接发送了请求到服务端，这个非法请求是不会携带 token 的，所以这个请求将是非法的。\n\n但是这样会存在  XSS 攻击中被盗的风险，为了避免 XSS 攻击，你可以选择将 token 存储在标记为`httpOnly`  的cookie 中。但是，这样又导致了你必须自己提供CSRF保护。\n\n具体采用上面哪种方式存储 token 呢，大部分情况下存放在  local storage 下都是最好的选择，某些情况下可能需要存放在标记为`httpOnly`  的cookie 中会更好。\n\n### 3.适合移动端应用\n\n使用 Session 进行身份认证的话，需要保存一份信息在服务器端，而且这种方式会依赖到 Cookie（需要 Cookie 保存 SessionId），所以不适合移动端。\n\n但是，使用 token 进行身份认证就不会存在这种问题，因为只要 token 可以被客户端存储就能够使用，而且 token 还可以跨语言使用。\n\n### 4.单点登录友好\n\n使用 Session 进行身份认证的话，实现单点登录，需要我们把用户的 Session 信息保存在一台电脑上，并且还会遇到常见的 Cookie 跨域的问题。但是，使用 token 进行认证的话， token 被保存在客户端，不会存在这些问题。\n\n## Token 认证常见问题以及解决办法\n\n### 1.注销登录等场景下 token 还有效\n\n与之类似的具体相关场景有：\n\n1. 退出登录;\n2. 修改密码;\n3. 服务端修改了某个用户具有的权限或者角色；\n4. 用户的帐户被删除/暂停。\n5. 用户由管理员注销；\n\n这个问题不存在于 Session  认证方式中，因为在  Session  认证方式中，遇到这种情况的话服务端删除对应的 Session 记录即可。但是，使用 token 认证的方式就不好解决了。我们也说过了，token 一旦派发出去，如果后端不增加其他逻辑的话，它在失效之前都是有效的。那么，我们如何解决这个问题呢？查阅了很多资料，总结了下面几种方案：\n\n- **将 token 存入内存数据库**：将 token 存入 DB 中，redis 内存数据库在这里是不错的选择。如果需要让某个 token 失效就直接从 redis 中删除这个 token 即可。但是，这样会导致每次使用 token 发送请求都要先从 DB 中查询 token 是否存在的步骤，而且违背了 JWT 的无状态原则。\n- **黑名单机制**：和上面的方式类似，使用内存数据库比如 redis 维护一个黑名单，如果想让某个 token 失效的话就直接将这个 token 加入到 **黑名单** 即可。然后，每次使用 token 进行请求的话都会先判断这个 token 是否存在于黑名单中。\n- **修改密钥 (Secret)** : 我们为每个用户都创建一个专属密钥，如果我们想让某个 token 失效，我们直接修改对应用户的密钥即可。但是，这样相比于前两种引入内存数据库带来了危害更大，比如：1) 如果服务是分布式的，则每次发出新的 token 时都必须在多台机器同步密钥。为此，你需要将密钥存储在数据库或其他外部服务中，这样和 Session 认证就没太大区别了。 2) 如果用户同时在两个浏览器打开系统，或者在手机端也打开了系统，如果它从一个地方将账号退出，那么其他地方都要重新进行登录，这是不可取的。\n- **保持令牌的有效期限短并经常轮换** ：很简单的一种方式。但是，会导致用户登录状态不会被持久记录，而且需要用户经常登录。\n\n对于修改密码后 token 还有效问题的解决还是比较容易的，说一种我觉得比较好的方式：**使用用户的密码的哈希值对 token 进行签名。因此，如果密码更改，则任何先前的令牌将自动无法验证。**\n\n### 2.token 的续签问题\n\ntoken 有效期一般都建议设置的不太长，那么 token 过期后如何认证，如何实现动态刷新 token，避免用户经常需要重新登录？\n\n我们先来看看在 Session 认证中一般的做法：**假如 session 的有效期30分钟，如果 30 分钟内用户有访问，就把 session 有效期延长30分钟。**\n\n1. **类似于 Session 认证中的做法**：这种方案满足于大部分场景。假设服务端给的 token 有效期设置为30分钟，服务端每次进行校验时，如果发现 token 的有效期马上快过期了，服务端就重新生成 token 给客户端。客户端每次请求都检查新旧token，如果不一致，则更新本地的token。这种做法的问题是仅仅在快过期的时候请求才会更新 token ,对客户端不是很友好。\n2. **每次请求都返回新 token** :这种方案的的思路很简单，但是，很明显，开销会比较大。\n3. **token 有效期设置到半夜** ：这种方案是一种折衷的方案，保证了大部分用户白天可以正常登录，适用于对安全性要求不高的系统。\n4. **用户登录返回两个 token** ：第一个是 accessToken ，它的过期时间 token 本身的过期时间比如半个小时，另外一个是 refreshToken 它的过期时间更长一点比如为1天。客户端登录后，将 accessToken和refreshToken 保存在本地，每次访问将 accessToken 传给服务端。服务端校验 accessToken 的有效性，如果过期的话，就将 refreshToken 传给服务端。如果有效，服务端就生成新的 accessToken 给客户端。否则，客户端就重新登录即可。该方案的不足是：1) 需要客户端来配合；2) 用户注销的时候需要同时保证两个 token 都无效；3) 重新请求获取 token 的过程中会有短暂 token 不可用的情况（可以通过在客户端设置定时器，当accessToken 快过期的时候，提前去通过 refreshToken 获取新的accessToken）。\n\n## 总结\n\nJWT 最适合的场景是不需要服务端保存用户状态的场景，如果考虑到 token 注销和 token 续签的场景话，没有特别好的解决方案，大部分解决方案都给 token 加上了状态，这就有点类似 Session 认证了。\n\n##  Reference\n\n- [JWT 超详细分析](https://learnku.com/articles/17883?order_by=vote_count&)\n- https://medium.com/devgorilla/how-to-log-out-when-using-jwt-a8c7823e8a6\n- https://medium.com/@agungsantoso/csrf-protection-with-json-web-tokens-83e0f2fcbcc\n- [Invalidating JSON Web Tokens](https://stackoverflow.com/questions/21978658/invalidating-json-web-tokens)\n\n'},e68d:function(n,e,t){"use strict";t.r(e),e["default"]='## 1.线程池\n\n### 1.1 线程状态介绍\n\n当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。那么Java中的线程存在哪几种状态呢？Java中的线程\n\n状态被定义在了java.lang.Thread.State枚举类中，State枚举类的源码如下：\n\n```java\npublic class Thread {\n    \n    public enum State {\n    \n        /* 新建 */\n        NEW , \n\n        /* 可运行状态 */\n        RUNNABLE , \n\n        /* 阻塞状态 */\n        BLOCKED , \n\n        /* 无限等待状态 */\n        WAITING , \n\n        /* 计时等待 */\n        TIMED_WAITING , \n\n        /* 终止 */\n        TERMINATED;\n    \n\t}\n    \n    // 获取当前线程的状态\n    public State getState() {\n        return jdk.internal.misc.VM.toThreadState(threadStatus);\n    }\n    \n}\n```\n\n通过源码我们可以看到Java中的线程存在6种状态，每种线程状态的含义如下\n\n| 线程状态          | 具体含义                                     |\n| ------------- | ---------------------------------------- |\n| NEW           | 一个尚未启动的线程的状态。也称之为初始状态、开始状态。线程刚被创建，但是并未启动。还没调用start方法。MyThread t = new MyThread()只有线程象，没有线程特征。 |\n| RUNNABLE      | 当我们调用线程对象的start方法，那么此时线程对象进入了RUNNABLE状态。那么此时才是真正的在JVM进程中创建了一个线程，线程一经启动并不是立即得到执行，线程的运行与否要听令与CPU的调度，那么我们把这个中间状态称之为可执行状态(RUNNABLE)也就是说它具备执行的资格，但是并没有真正的执行起来而是在等待CPU的度。 |\n| BLOCKED       | 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。 |\n| WAITING       | 一个正在等待的线程的状态。也称之为等待状态。造成线程等待的原因有两种，分别是调用Object.wait()、join()方法。处于等待状态的线程，正在等待其他线程去执行一个特定的操作。例如：因为wait()而等待的线程正在等待另一个线程去调用notify()或notifyAll()；一个因为join()而等待的线程正在等待另一个线程结束。 |\n| TIMED_WAITING | 一个在限定时间内等待的线程的状态。也称之为限时等待状态。造成线程限时等待状态的原因有三种，分别是：Thread.sleep(long)，Object.wait(long)、join(long)。 |\n| TERMINATED    | 一个完全运行完成的线程的状态。也称之为终止状态、结束状态             |\n\n各个状态的转换，如下图所示：\n\n![1591163781941](./day22-多线程02.img/1591163781941.png)\n\n### 1.2 线程的状态-练习1\n\n**目的 :** 本案例主要演示TIME_WAITING的状态转换。\n\n**需求：**编写一段代码，依次显示一个线程的这些状态：NEW -> RUNNABLE -> TIME_WAITING -> RUNNABLE -> TERMINATED\n\n为了简化我们的开发，本次我们使用匿名内部类结合lambda表达式的方式使用多线程。\n\n**代码实现**\n\n```java\npublic class ThreadStateDemo01 {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        //定义一个内部线程\n        Thread thread = new Thread(() -> {\n            System.out.println("2.执行thread.start()之后，线程的状态：" + Thread.currentThread().getState());\n            try {\n                //休眠100毫秒\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println("4.执行Thread.sleep(long)完成之后，线程的状态：" + Thread.currentThread().getState());\n        });\n\n        //获取start()之前的状态\n        System.out.println("1.通过new初始化一个线程，但是还没有start()之前，线程的状态：" + thread.getState());\n\n        //启动线程\n        thread.start();\n\n        //休眠50毫秒\n        Thread.sleep(50);\n\n        //因为thread1需要休眠100毫秒，所以在第50毫秒，thread处于sleep状态\n        System.out.println("3.执行Thread.sleep(long)时，线程的状态：" + thread.getState());\n\n        //thread1和main线程主动休眠150毫秒，所以在第150毫秒,thread早已执行完毕\n        Thread.sleep(100);\n\n        System.out.println("5.线程执行完毕之后，线程的状态：" + thread.getState() + "\\n");\n\n    }\n\n}\n```\n\n控制台输出\n\n```java\n1.通过new初始化一个线程，但是还没有start()之前，线程的状态：NEW\n2.执行thread.start()之后，线程的状态：RUNNABLE\n3.执行Thread.sleep(long)时，线程的状态：TIMED_WAITING\n4.执行Thread.sleep(long)完成之后，线程的状态：RUNNABLE\n5.线程执行完毕之后，线程的状态：TERMINATED\n```\n\n### \n\n### 1.3 线程的状态-练习2\n\n**目的 :** 本案例主要演示WAITING的状态转换。\n\n**需求 ：**编写一段代码，依次显示一个线程的这些状态：NEW -> RUNNABLE -> WAITING -> RUNNABLE -> TERMINATED\n\n**代码实现 :** \n\n```java\npublic class ThreadStateDemo02 {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        //定义一个对象，用来加锁和解锁\n        Object obj = new Object();\n\n        //定义一个内部线程\n        Thread thread1 = new Thread(() -> {\n            System.out.println("2.执行thread.start()之后，线程的状态：" + Thread.currentThread().getState());\n            synchronized (obj) {\n                try {\n\n                    //thread1需要休眠100毫秒\n                    Thread.sleep(100);\n\n                    //thread1100毫秒之后，通过wait()方法释放obj对象是锁\n                    obj.wait();\n                    \n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println("4.被object.notify()方法唤醒之后，线程的状态：" + Thread.currentThread().getState());\n        });\n\n        //获取start()之前的状态\n        System.out.println("1.通过new初始化一个线程，但是还没有start()之前，线程的状态：" + thread1.getState());\n\n        //启动线程\n        thread1.start();\n\n        //main线程休眠150毫秒\n        Thread.sleep(150);\n\n        //因为thread1在第100毫秒进入wait等待状态，所以第150秒肯定可以获取其状态\n        System.out.println("3.执行object.wait()时，线程的状态：" + thread1.getState());\n\n        //声明另一个线程进行解锁\n        new Thread(() -> {\n            synchronized (obj) {\n                //唤醒等待的线程\n                obj.notify();\n            }\n        }).start();\n\n        //main线程休眠10毫秒等待thread1线程能够苏醒\n        Thread.sleep(10);\n\n        //获取thread1运行结束之后的状态\n        System.out.println("5.线程执行完毕之后，线程的状态：" + thread1.getState() + "\\n");\n\n    }\n\n}\n```\n\n控制台输出结果\n\n```java\n1.通过new初始化一个线程，但是还没有start()之前，线程的状态：NEW\n2.执行thread.start()之后，线程的状态：RUNNABLE\n3.执行object.wait()时，线程的状态：WAITING\n4.被object.notify()方法唤醒之后，线程的状态：RUNNABLE\n5.线程执行完毕之后，线程的状态：TERMINATED\n```\n\n### \n\n### 1.4 线程的状态-练习3\n\n**目的 :**   本案例主要演示BLOCKED的状态转换。\n\n**需求 ：**编写一段代码，依次显示一个线程的这些状态：NEW -> RUNNABLE -> BLOCKED -> RUNNABLE -> TERMINATED\n\n```java\npublic class ThreadStateDemo03 {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        //定义一个对象，用来加锁和解锁\n        Object obj2 = new Object();\n\n        //定义一个线程，先抢占了obj2对象的锁\n        new Thread(() -> {\n            synchronized (obj2) {\n                try {\n                    Thread.sleep(100);              //第一个线程要持有锁100毫秒\n                    obj2.wait();                          //然后通过wait()方法进行等待状态，并释放obj2的对象锁\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n\n        //定义目标线程，获取等待获取obj2的锁\n        Thread thread = new Thread(() -> {\n            System.out.println("2.执行thread.start()之后，线程的状态：" + Thread.currentThread().getState());\n            synchronized (obj2) {\n                try {\n                    Thread.sleep(100);              //thread3要持有对象锁100毫秒\n                    obj2.notify();                        //然后通过notify()方法唤醒所有在ojb2上等待的线程继续执行后续操作\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println("4.阻塞结束后，线程的状态：" + Thread.currentThread().getState());\n        });\n\n        //获取start()之前的状态\n        System.out.println("1.通过new初始化一个线程，但是还没有thread.start()之前，线程的状态：" + thread.getState());\n\n        //启动线程\n        thread.start();\n\n        //先等100毫秒\n        Thread.sleep(50);\n\n        //第一个线程释放锁至少需要100毫秒，所以在第50毫秒时，thread正在因等待obj的对象锁而阻塞\n        System.out.println("3.因为等待锁而阻塞时，线程的状态：" + thread.getState());\n\n        //再等300毫秒\n        Thread.sleep(300);\n\n        //两个线程的执行时间加上之前等待的50毫秒总共是250毫秒，所以第300毫秒，所有的线程都已经执行完毕\n        System.out.println("5.线程执行完毕之后，线程的状态：" + thread.getState());\n\n    }\n\n}\n```\n\n**控制台输出结果**\n\n```java\n1.通过new初始化一个线程，但是还没有thread.start()之前，线程的状态：NEW\n2.执行thread.start()之后，线程的状态：RUNNABLE\n3.因为等待锁而阻塞时，线程的状态：BLOCKED\n4.阻塞结束后，线程的状态：RUNNABLE\n5.线程执行完毕之后，线程的状态：TERMINATED\n```\n\n\n\n### 1.5 线程池-基本原理\n\n**概述 :** \n\n​\t提到池，大家应该能想到的就是水池。水池就是一个容器，在该容器中存储了很多的水。那么什么是线程池呢？线程池也是可以看做成一个池子，在该池子中存储很多个线程。\n\n线程池存在的意义：\n\n​\t系统创建一个线程的成本是比较高的，因为它涉及到与操作系统交互，当程序中需要创建大量生存期很短暂的线程时，频繁的创建和销毁线程对系统的资源消耗有可能大于业务处理是对系\n\n​\t统资源的消耗，这样就有点"舍本逐末"了。针对这一种情况，为了提高性能，我们就可以采用线程池。线程池在启动的时，会创建大量空闲线程，当我们向线程池提交任务的时，线程池就\n\n​\t会启动一个线程来执行该任务。等待任务执行完毕以后，线程并不会死亡，而是再次返回到线程池中称为空闲状态。等待下一次任务的执行。\n\n**线程池的设计思路 :**\n\n1. 准备一个任务容器\n2. 一次性启动多个(2个)消费者线程\n3. 刚开始任务容器是空的，所以线程都在wait\n4. 直到一个外部线程向这个任务容器中扔了一个"任务"，就会有一个消费者线程被唤醒\n5. 这个消费者线程取出"任务"，并且执行这个任务，执行完毕后，继续等待下一次任务的到来\n\n### 1.6 线程池-Executors默认线程池\n\n概述 : JDK对线程池也进行了相关的实现，在真实企业开发中我们也很少去自定义线程池，而是使用JDK中自带的线程池。\n\n我们可以使用Executors中所提供的**静态**方法来创建线程池\n\n​\tstatic ExecutorService newCachedThreadPool()   创建一个默认的线程池\n\tstatic newFixedThreadPool(int nThreads)\t    创建一个指定最多线程数量的线程池\n\n**代码实现 :** \n\n```java\npackage com.itheima.mythreadpool;\n\n\n//static ExecutorService newCachedThreadPool()   创建一个默认的线程池\n//static newFixedThreadPool(int nThreads)\t    创建一个指定最多线程数量的线程池\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class MyThreadPoolDemo {\n    public static void main(String[] args) throws InterruptedException {\n\n        //1,创建一个默认的线程池对象.池子中默认是空的.默认最多可以容纳int类型的最大值.\n        ExecutorService executorService = Executors.newCachedThreadPool();\n        //Executors --- 可以帮助我们创建线程池对象\n        //ExecutorService --- 可以帮助我们控制线程池\n\n        executorService.submit(()->{\n            System.out.println(Thread.currentThread().getName() + "在执行了");\n        });\n\n        //Thread.sleep(2000);\n\n        executorService.submit(()->{\n            System.out.println(Thread.currentThread().getName() + "在执行了");\n        });\n\n        executorService.shutdown();\n    }\n}\n\n```\n\n\n\n### 1.7 线程池-Executors创建指定上限的线程池\n\n**使用Executors中所提供的静态方法来创建线程池**\n\n​\tstatic ExecutorService newFixedThreadPool(int nThreads) : 创建一个指定最多线程数量的线程池\n\n**代码实现 :** \n\n```java\npackage com.itheima.mythreadpool;\n\n//static ExecutorService newFixedThreadPool(int nThreads)\n//创建一个指定最多线程数量的线程池\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\n\npublic class MyThreadPoolDemo2 {\n    public static void main(String[] args) {\n        //参数不是初始值而是最大值\n        ExecutorService executorService = Executors.newFixedThreadPool(10);\n\n        ThreadPoolExecutor pool = (ThreadPoolExecutor) executorService;\n        System.out.println(pool.getPoolSize());//0\n\n        executorService.submit(()->{\n            System.out.println(Thread.currentThread().getName() + "在执行了");\n        });\n\n        executorService.submit(()->{\n            System.out.println(Thread.currentThread().getName() + "在执行了");\n        });\n\n        System.out.println(pool.getPoolSize());//2\n//        executorService.shutdown();\n    }\n}\n\n```\n\n\n\n### 1.8 线程池-ThreadPoolExecutor\n\n**创建线程池对象 :** \n\nThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(核心线程数量,最大线程数量,空闲线程最大存活时间,任务队列,创建线程工厂,任务的拒绝策略);\n\n**代码实现 :** \n\n```java\npackage com.itheima.mythreadpool;\n\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class MyThreadPoolDemo3 {\n//    参数一：核心线程数量\n//    参数二：最大线程数\n//    参数三：空闲线程最大存活时间\n//    参数四：时间单位\n//    参数五：任务队列\n//    参数六：创建线程工厂\n//    参数七：任务的拒绝策略\n    public static void main(String[] args) {\n        ThreadPoolExecutor pool = new ThreadPoolExecutor(2,5,2,TimeUnit.SECONDS,new ArrayBlockingQueue<>(10), Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());\n        pool.submit(new MyRunnable());\n        pool.submit(new MyRunnable());\n\n        pool.shutdown();\n    }\n}\n```\n\n### 1.9 线程池-参数详解\n\n![1591165506516](./day22-多线程02.img/1591165506516.png)\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler)\n    \ncorePoolSize：   核心线程的最大值，不能小于0\nmaximumPoolSize：最大线程数，不能小于等于0，maximumPoolSize >= corePoolSize\nkeepAliveTime：  空闲线程最大存活时间,不能小于0\nunit：           时间单位\nworkQueue：      任务队列，不能为null\nthreadFactory：  创建线程工厂,不能为null      \nhandler：        任务的拒绝策略,不能为null  \n```\n\n\n\n### 1.10 线程池-非默认任务拒绝策略\n\nRejectedExecutionHandler是jdk提供的一个任务拒绝策略接口，它下面存在4个子类。\n\n```java\nThreadPoolExecutor.AbortPolicy: \t\t    丢弃任务并抛出RejectedExecutionException异常。是默认的策略。\nThreadPoolExecutor.DiscardPolicy： \t\t   丢弃任务，但是不抛出异常 这是不推荐的做法。\nThreadPoolExecutor.DiscardOldestPolicy：    抛弃队列中等待最久的任务 然后把当前任务加入队列中。\nThreadPoolExecutor.CallerRunsPolicy:        调用任务的run()方法绕过线程池直接执行。\n```\n\n注：明确线程池对多可执行的任务数 = 队列容量 + 最大线程数\n\n**案例演示1**：演示ThreadPoolExecutor.AbortPolicy任务处理策略\n\n```java\npublic class ThreadPoolExecutorDemo01 {\n\n    public static void main(String[] args) {\n\n        /**\n         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s\n         */\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.AbortPolicy()) ;\n\n        // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用AbortPolicy这个任务处理策略的时候，就会抛出异常\n        for(int x = 0 ; x < 5 ; x++) {\n            threadPoolExecutor.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + "----\x3e> 执行了任务");\n            });\n        }\n    }\n}\n```\n\n**控制台输出结果**\n\n```java\npool-1-thread-1----\x3e> 执行了任务\npool-1-thread-3----\x3e> 执行了任务\npool-1-thread-2----\x3e> 执行了任务\npool-1-thread-3----\x3e> 执行了任务\n```\n\n控制台报错，仅仅执行了4个任务，有一个任务被丢弃了\n\n\n\n**案例演示2**：演示ThreadPoolExecutor.DiscardPolicy任务处理策略\n\n```java\npublic class ThreadPoolExecutorDemo02 {\n    public static void main(String[] args) {\n        /**\n         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s\n         */\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardPolicy()) ;\n\n        // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用DiscardPolicy这个任务处理策略的时候，控制台不会报错\n        for(int x = 0 ; x < 5 ; x++) {\n            threadPoolExecutor.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + "----\x3e> 执行了任务");\n            });\n        }\n    }\n}\n```\n\n**控制台输出结果**\n\n```java\npool-1-thread-1----\x3e> 执行了任务\npool-1-thread-1----\x3e> 执行了任务\npool-1-thread-3----\x3e> 执行了任务\npool-1-thread-2----\x3e> 执行了任务\n```\n\n控制台没有报错，仅仅执行了4个任务，有一个任务被丢弃了\n\n\n\n**案例演示3**：演示ThreadPoolExecutor.DiscardOldestPolicy任务处理策略\n\n```java\npublic class ThreadPoolExecutorDemo02 {\n    public static void main(String[] args) {\n        /**\n         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s\n         */\n        ThreadPoolExecutor threadPoolExecutor;\n        threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardOldestPolicy());\n        // 提交5个任务\n        for(int x = 0 ; x < 5 ; x++) {\n            // 定义一个变量，来指定指定当前执行的任务;这个变量需要被final修饰\n            final int y = x ;\n            threadPoolExecutor.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + "----\x3e> 执行了任务" + y);\n            });     \n        }\n    }\n}\n```\n\n**控制台输出结果**\n\n```java\npool-1-thread-2----\x3e> 执行了任务2\npool-1-thread-1----\x3e> 执行了任务0\npool-1-thread-3----\x3e> 执行了任务3\npool-1-thread-1----\x3e> 执行了任务4\n```\n\n由于任务1在线程池中等待时间最长，因此任务1被丢弃。\n\n\n\n**案例演示4**：演示ThreadPoolExecutor.CallerRunsPolicy任务处理策略\n\n```java\npublic class ThreadPoolExecutorDemo04 {\n    public static void main(String[] args) {\n\n        /**\n         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s\n         */\n        ThreadPoolExecutor threadPoolExecutor;\n        threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.CallerRunsPolicy());\n\n        // 提交5个任务\n        for(int x = 0 ; x < 5 ; x++) {\n            threadPoolExecutor.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + "----\x3e> 执行了任务");\n            });\n        }\n    }\n}\n```\n\n**控制台输出结果**\n\n```java\npool-1-thread-1----\x3e> 执行了任务\npool-1-thread-3----\x3e> 执行了任务\npool-1-thread-2----\x3e> 执行了任务\npool-1-thread-1----\x3e> 执行了任务\nmain----\x3e> 执行了任务\n```\n\n通过控制台的输出，我们可以看到次策略没有通过线程池中的线程执行任务，而是直接调用任务的run()方法绕过线程池直接执行。\n\n## 2. 原子性\n\n### 2.1 volatile-问题\n\n**代码分析 :** \n\n```java\npackage com.itheima.myvolatile;\n\npublic class Demo {\n    public static void main(String[] args) {\n        MyThread1 t1 = new MyThread1();\n        t1.setName("小路同学");\n        t1.start();\n\n        MyThread2 t2 = new MyThread2();\n        t2.setName("小皮同学");\n        t2.start();\n    }\n}\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class Money {\n    public static int money = 100000;\n}\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class MyThread1 extends  Thread {\n    @Override\n    public void run() {\n        while(Money.money == 100000){\n\n        }\n\n        System.out.println("结婚基金已经不是十万了");\n    }\n}\n\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class MyThread2 extends Thread {\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        Money.money = 90000;\n    }\n}\n\n```\n\n**程序问题 :**  女孩虽然知道结婚基金是十万，但是当基金的余额发生变化的时候，女孩无法知道最新的余额。\n\n\n\n### 2.2 volatile解决\n\n**以上案例出现的问题 :**\n\n​\t当A线程修改了共享数据时，B线程没有及时获取到最新的值，如果还在使用原先的值，就会出现问题 \n\n​\t1，堆内存是唯一的，每一个线程都有自己的线程栈。\n\n​\t2 ，每一个线程在使用堆里面变量的时候，都会先拷贝一份到变量的副本中。\n\n​\t3 ，在线程中，每一次使用是从变量的副本中获取的。\n\n**Volatile关键字 :** 强制线程每次在使用的时候，都会看一下共享区域最新的值\n\n**代码实现 :** **使用volatile关键字解决**\n\n```java\npackage com.itheima.myvolatile;\n\npublic class Demo {\n    public static void main(String[] args) {\n        MyThread1 t1 = new MyThread1();\n        t1.setName("小路同学");\n        t1.start();\n\n        MyThread2 t2 = new MyThread2();\n        t2.setName("小皮同学");\n        t2.start();\n    }\n}\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class Money {\n    public static volatile int money = 100000;\n}\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class MyThread1 extends  Thread {\n    @Override\n    public void run() {\n        while(Money.money == 100000){\n\n        }\n\n        System.out.println("结婚基金已经不是十万了");\n    }\n}\n\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class MyThread2 extends Thread {\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        Money.money = 90000;\n    }\n}\n\n```\n\n\n\n### 2.3 synchronized解决\n\n**synchronized解决 :** \n\n​\t1 ，线程获得锁\n\n​\t2 ，清空变量副本\n\n​\t3 ，拷贝共享变量最新的值到变量副本中\n\n​\t4 ，执行代码\n\n​\t5 ，将修改后变量副本中的值赋值给共享数据\n\n​\t6 ，释放锁\n\n**代码实现 :** \n\n```java\npackage com.itheima.myvolatile2;\n\npublic class Demo {\n    public static void main(String[] args) {\n        MyThread1 t1 = new MyThread1();\n        t1.setName("小路同学");\n        t1.start();\n\n        MyThread2 t2 = new MyThread2();\n        t2.setName("小皮同学");\n        t2.start();\n    }\n}\n```\n\n```java\npackage com.itheima.myvolatile2;\n\npublic class Money {\n    public static Object lock = new Object();\n    public static volatile int money = 100000;\n}\n```\n\n```java\npackage com.itheima.myvolatile2;\n\npublic class MyThread1 extends  Thread {\n    @Override\n    public void run() {\n        while(true){\n            synchronized (Money.lock){\n                if(Money.money != 100000){\n                    System.out.println("结婚基金已经不是十万了");\n                    break;\n                }\n            }\n        }\n    }\n}\n```\n\n```java\npackage com.itheima.myvolatile2;\n\npublic class MyThread2 extends Thread {\n    @Override\n    public void run() {\n        synchronized (Money.lock) {\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            Money.money = 90000;\n        }\n    }\n}\n```\n\n\n\n### 2.4 原子性\n\n**概述 :** 所谓的原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行，多个操作是一个不可以分割的整体。\n\n**代码实现 :** \n\n```java\npackage com.itheima.threadatom;\n\npublic class AtomDemo {\n    public static void main(String[] args) {\n        MyAtomThread atom = new MyAtomThread();\n\n        for (int i = 0; i < 100; i++) {\n            new Thread(atom).start();\n        }\n    }\n}\nclass MyAtomThread implements Runnable {\n    private volatile int count = 0; //送冰淇淋的数量\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            //1,从共享数据中读取数据到本线程栈中.\n            //2,修改本线程栈中变量副本的值\n            //3,会把本线程栈中变量副本的值赋值给共享数据.\n            count++;\n            System.out.println("已经送了" + count + "个冰淇淋");\n        }\n    }\n}\n```\n\n**代码总结 :** count++ 不是一个原子性操作, 他在执行的过程中,有可能被其他线程打断\n\n\n\n### 2.5 volatile关键字不能保证原子性\n\n解决方案 : 我们可以给count++操作添加锁，那么count++操作就是临界区中的代码，临界区中的代码一次只能被一个线程去执行，所以count++就变成了原子操作。\n\n```java\npackage com.itheima.threadatom2;\n\npublic class AtomDemo {\n    public static void main(String[] args) {\n        MyAtomThread atom = new MyAtomThread();\n\n        for (int i = 0; i < 100; i++) {\n            new Thread(atom).start();\n        }\n    }\n}\nclass MyAtomThread implements Runnable {\n    private volatile int count = 0; //送冰淇淋的数量\n    private Object lock = new Object();\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            //1,从共享数据中读取数据到本线程栈中.\n            //2,修改本线程栈中变量副本的值\n            //3,会把本线程栈中变量副本的值赋值给共享数据.\n            synchronized (lock) {\n                count++;\n                System.out.println("已经送了" + count + "个冰淇淋");\n            }\n        }\n    }\n}\n```\n\n\n\n### 2.6 原子性_AtomicInteger\n\n概述：java从JDK1.5开始提供了java.util.concurrent.atomic包(简称Atomic包)，这个包中的原子操作类提供了一种用法简单，性能高效，线程安全地更新一个变量的方式。因为变\n\n量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性(字段)。本次我们只讲解\n\n使用原子的方式更新基本类型，使用原子的方式更新基本类型Atomic包提供了以下3个类：\n\nAtomicBoolean： 原子更新布尔类型\n\nAtomicInteger：   原子更新整型\n\nAtomicLong：\t原子更新长整型\n\n以上3个类提供的方法几乎一模一样，所以本节仅以AtomicInteger为例进行讲解，AtomicInteger的常用方法如下：\n\n```java\npublic AtomicInteger()：\t   \t\t\t    初始化一个默认值为0的原子型Integer\npublic AtomicInteger(int initialValue)：  初始化一个指定值的原子型Integer\n\nint get():   \t\t\t \t\t\t\t获取值\nint getAndIncrement():      \t\t\t 以原子方式将当前值加1，注意，这里返回的是自增前的值。\nint incrementAndGet():     \t\t\t\t 以原子方式将当前值加1，注意，这里返回的是自增后的值。\nint addAndGet(int data):\t\t\t\t 以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。\nint getAndSet(int value):   \t\t\t 以原子方式设置为newValue的值，并返回旧值。\n```\n\n**代码实现 :**\n\n```java\npackage com.itheima.threadatom3;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class MyAtomIntergerDemo1 {\n//    public AtomicInteger()：\t               初始化一个默认值为0的原子型Integer\n//    public AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integer\n    public static void main(String[] args) {\n        AtomicInteger ac = new AtomicInteger();\n        System.out.println(ac);\n\n        AtomicInteger ac2 = new AtomicInteger(10);\n        System.out.println(ac2);\n    }\n\n}\n```\n\n```java\npackage com.itheima.threadatom3;\n\nimport java.lang.reflect.Field;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class MyAtomIntergerDemo2 {\n//    int get():   \t\t \t\t获取值\n//    int getAndIncrement():     以原子方式将当前值加1，注意，这里返回的是自增前的值。\n//    int incrementAndGet():     以原子方式将当前值加1，注意，这里返回的是自增后的值。\n//    int addAndGet(int data):\t 以原子方式将参数与对象中的值相加，并返回结果。\n//    int getAndSet(int value):  以原子方式设置为newValue的值，并返回旧值。\n    public static void main(String[] args) {\n//        AtomicInteger ac1 = new AtomicInteger(10);\n//        System.out.println(ac1.get());\n\n//        AtomicInteger ac2 = new AtomicInteger(10);\n//        int andIncrement = ac2.getAndIncrement();\n//        System.out.println(andIncrement);\n//        System.out.println(ac2.get());\n\n//        AtomicInteger ac3 = new AtomicInteger(10);\n//        int i = ac3.incrementAndGet();\n//        System.out.println(i);//自增后的值\n//        System.out.println(ac3.get());\n\n//        AtomicInteger ac4 = new AtomicInteger(10);\n//        int i = ac4.addAndGet(20);\n//        System.out.println(i);\n//        System.out.println(ac4.get());\n\n        AtomicInteger ac5 = new AtomicInteger(100);\n        int andSet = ac5.getAndSet(20);\n        System.out.println(andSet);\n        System.out.println(ac5.get());\n    }\n}\n```\n\n\n\n### 2.7 AtomicInteger-内存解析\n\n**AtomicInteger原理 :** 自旋锁  + CAS 算法\n\n**CAS算法：**\n\n​\t有3个操作数（内存值V， 旧的预期值A，要修改的值B）\n\n​\t当旧的预期值A == 内存值   此时修改成功，将V改为B                 \n\n​\t当旧的预期值A！=内存值   此时修改失败，不做任何操作                 \n\n​\t并重新获取现在的最新值（这个重新获取的动作就是自旋）\n\n### 2.8 AtomicInteger-源码解析\n\n**代码实现 :**\n\n```java\npackage com.itheima.threadatom4;\n\npublic class AtomDemo {\n    public static void main(String[] args) {\n        MyAtomThread atom = new MyAtomThread();\n\n        for (int i = 0; i < 100; i++) {\n            new Thread(atom).start();\n        }\n    }\n}\n```\n\n```java\npackage com.itheima.threadatom4;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class MyAtomThread implements Runnable {\n    //private volatile int count = 0; //送冰淇淋的数量\n    //private Object lock = new Object();\n    AtomicInteger ac = new AtomicInteger(0);\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            //1,从共享数据中读取数据到本线程栈中.\n            //2,修改本线程栈中变量副本的值\n            //3,会把本线程栈中变量副本的值赋值给共享数据.\n            //synchronized (lock) {\n//                count++;\n//                ac++;\n            int count = ac.incrementAndGet();\n            System.out.println("已经送了" + count + "个冰淇淋");\n           // }\n        }\n    }\n}\n\n```\n\n**源码解析 :** \n\n```java\n\n//先自增，然后获取自增后的结果\npublic final int incrementAndGet() {\n        //+ 1 自增后的结果\n        //this 就表示当前的atomicInteger（值）\n        //1    自增一次\n        return U.getAndAddInt(this, VALUE, 1) + 1;\n}\n\npublic final int getAndAddInt(Object o, long offset, int delta) {\n        //v 旧值\n        int v;\n        //自旋的过程\n        do {\n            //不断的获取旧值\n            v = getIntVolatile(o, offset);\n            //如果这个方法的返回值为false，那么继续自旋\n            //如果这个方法的返回值为true，那么自旋结束\n            //o 表示的就是内存值\n            //v 旧值\n            //v + delta 修改后的值\n        } while (!weakCompareAndSetInt(o, offset, v, v + delta));\n            //作用：比较内存中的值，旧值是否相等，如果相等就把修改后的值写到内存中，返回true。表示修改成功。\n            //                                 如果不相等，无法把修改后的值写到内存中，返回false。表示修改失败。\n            //如果修改失败，那么继续自旋。\n        return v;\n}\n```\n\n\n\n### 2.9 悲观锁和乐观锁\n\n**synchronized和CAS的区别 :** \n\n**相同点：**在多线程情况下，都可以保证共享数据的安全性。\n\n**不同点：**synchronized总是从最坏的角度出发，认为每次获取数据的时候，别人都有可能修改。所以在每                       次操作共享数据之前，都会上锁。（悲观锁）\n\n​\tcas是从乐观的角度出发，假设每次获取数据别人都不会修改，所以不会上锁。只不过在修改共享数据的时候，会检查一下，别人有没有修改过这个数据。\n\n​\t如果别人修改过，那么我再次获取现在最新的值。            \n\n​\t 如果别人没有修改过，那么我现在直接修改共享数据的值.(乐观锁）\n\n\n\n## 3. 并发工具类\n\n### 3.1 并发工具类-Hashtable\n\n​\t**Hashtable出现的原因 :** 在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。\n\n**代码实现 :** \n\n```java\npackage com.itheima.mymap;\n\nimport java.util.HashMap;\nimport java.util.Hashtable;\n\npublic class MyHashtableDemo {\n    public static void main(String[] args) throws InterruptedException {\n        Hashtable<String, String> hm = new Hashtable<>();\n\n        Thread t1 = new Thread(() -> {\n            for (int i = 0; i < 25; i++) {\n                hm.put(i + "", i + "");\n            }\n        });\n\n\n        Thread t2 = new Thread(() -> {\n            for (int i = 25; i < 51; i++) {\n                hm.put(i + "", i + "");\n            }\n        });\n\n        t1.start();\n        t2.start();\n\n        System.out.println("----------------------------");\n        //为了t1和t2能把数据全部添加完毕\n        Thread.sleep(1000);\n\n        //0-0 1-1 ..... 50- 50\n\n        for (int i = 0; i < 51; i++) {\n            System.out.println(hm.get(i + ""));\n        }//0 1 2 3 .... 50\n\n\n    }\n}\n```\n\n\n\n### 3.2 并发工具类-ConcurrentHashMap基本使用\n\n​\t**ConcurrentHashMap出现的原因 :** 在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。\n\n基于以上两个原因我们可以使用JDK1.5以后所提供的ConcurrentHashMap。\n\n**体系结构 :** \n\n![1591168965857](./day22-多线程02.img/1591168965857.png)\n\n**总结 :** \n\n​\t1 ，HashMap是线程不安全的。多线程环境下会有数据安全问题\n\n​\t2 ，Hashtable是线程安全的，但是会将整张表锁起来，效率低下\n\n​\t3，ConcurrentHashMap也是线程安全的，效率较高。     在JDK7和JDK8中，底层原理不一样。\n\n**代码实现 :** \n\n```java\npackage com.itheima.mymap;\n\nimport java.util.Hashtable;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class MyConcurrentHashMapDemo {\n    public static void main(String[] args) throws InterruptedException {\n        ConcurrentHashMap<String, String> hm = new ConcurrentHashMap<>(100);\n\n        Thread t1 = new Thread(() -> {\n            for (int i = 0; i < 25; i++) {\n                hm.put(i + "", i + "");\n            }\n        });\n\n\n        Thread t2 = new Thread(() -> {\n            for (int i = 25; i < 51; i++) {\n                hm.put(i + "", i + "");\n            }\n        });\n\n        t1.start();\n        t2.start();\n\n        System.out.println("----------------------------");\n        //为了t1和t2能把数据全部添加完毕\n        Thread.sleep(1000);\n\n        //0-0 1-1 ..... 50- 50\n\n        for (int i = 0; i < 51; i++) {\n            System.out.println(hm.get(i + ""));\n        }//0 1 2 3 .... 50\n    }\n}\n```\n\n\n\n### 3.3 并发工具类-ConcurrentHashMap1.7原理\n\n![1591169254280](./day22-多线程02.img/1591169254280.png)\n\n### 3.4 并发工具类-ConcurrentHashMap1.8原理\n\n![1591169338256](./day22-多线程02.img/1591169338256.png)\n\n**总结 :** \n\n​\t1，如果使用空参构造创建ConcurrentHashMap对象，则什么事情都不做。     在第一次添加元素的时候创建哈希表\n\n​\t2，计算当前元素应存入的索引。\n\n​\t3，如果该索引位置为null，则利用cas算法，将本结点添加到数组中。\n\n​\t4，如果该索引位置不为null，则利用volatile关键字获得当前位置最新的结点地址，挂在他下面，变成链表。\t\t\n\n​\t5，当链表的长度大于等于8时，自动转换成红黑树6，以链表或者红黑树头结点为锁对象，配合悲观锁保证多线程操作集合时数据的安全性\n\n### 3.5 并发工具类-CountDownLatch\n\n**CountDownLatch类 :** \t\t\n\n| 方法                               | 解释               |\n| -------------------------------- | ---------------- |\n| public CountDownLatch(int count) | 参数传递线程数，表示等待线程数量 |\n| public void await()              | 让线程等待            |\n| public void countDown()          | 当前线程执行完毕         |\n\n**使用场景：** 让某一条线程等待其他线程执行完毕之后再执行\n\n**代码实现 :** \n\n```java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class ChileThread1 extends Thread {\n\n    private CountDownLatch countDownLatch;\n    public ChileThread1(CountDownLatch countDownLatch) {\n        this.countDownLatch = countDownLatch;\n    }\n\n    @Override\n    public void run() {\n        //1.吃饺子\n        for (int i = 1; i <= 10; i++) {\n            System.out.println(getName() + "在吃第" + i + "个饺子");\n        }\n        //2.吃完说一声\n        //每一次countDown方法的时候，就让计数器-1\n        countDownLatch.countDown();\n    }\n}\n\n```\n\n```java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class ChileThread2 extends Thread {\n\n    private CountDownLatch countDownLatch;\n    public ChileThread2(CountDownLatch countDownLatch) {\n        this.countDownLatch = countDownLatch;\n    }\n    @Override\n    public void run() {\n        //1.吃饺子\n        for (int i = 1; i <= 15; i++) {\n            System.out.println(getName() + "在吃第" + i + "个饺子");\n        }\n        //2.吃完说一声\n        //每一次countDown方法的时候，就让计数器-1\n        countDownLatch.countDown();\n    }\n}\n\n```\n\n```java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class ChileThread3 extends Thread {\n\n    private CountDownLatch countDownLatch;\n    public ChileThread3(CountDownLatch countDownLatch) {\n        this.countDownLatch = countDownLatch;\n    }\n    @Override\n    public void run() {\n        //1.吃饺子\n        for (int i = 1; i <= 20; i++) {\n            System.out.println(getName() + "在吃第" + i + "个饺子");\n        }\n        //2.吃完说一声\n        //每一次countDown方法的时候，就让计数器-1\n        countDownLatch.countDown();\n    }\n}\n\n```\n\n```java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class MotherThread extends Thread {\n    private CountDownLatch countDownLatch;\n    public MotherThread(CountDownLatch countDownLatch) {\n        this.countDownLatch = countDownLatch;\n    }\n\n    @Override\n    public void run() {\n        //1.等待\n        try {\n            //当计数器变成0的时候，会自动唤醒这里等待的线程。\n            countDownLatch.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        //2.收拾碗筷\n        System.out.println("妈妈在收拾碗筷");\n    }\n}\n\n```\n\n```java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class MyCountDownLatchDemo {\n    public static void main(String[] args) {\n        //1.创建CountDownLatch的对象，需要传递给四个线程。\n        //在底层就定义了一个计数器，此时计数器的值就是3\n        CountDownLatch countDownLatch = new CountDownLatch(3);\n        //2.创建四个线程对象并开启他们。\n        MotherThread motherThread = new MotherThread(countDownLatch);\n        motherThread.start();\n\n        ChileThread1 t1 = new ChileThread1(countDownLatch);\n        t1.setName("小明");\n\n        ChileThread2 t2 = new ChileThread2(countDownLatch);\n        t2.setName("小红");\n\n        ChileThread3 t3 = new ChileThread3(countDownLatch);\n        t3.setName("小刚");\n\n        t1.start();\n        t2.start();\n        t3.start();\n    }\n}\n```\n\n**总结 :** \n\n​\t1. CountDownLatch(int count)：参数写等待线程的数量。并定义了一个计数器。\n\n​\t2. await()：让线程等待，当计数器为0时，会唤醒等待的线程\n\n​\t3. countDown()： 线程执行完毕时调用，会将计数器-1。\n\n### 3.6 并发工具类-Semaphore\n\n**使用场景 :** \n\n​\t可以控制访问特定资源的线程数量。\n\n**实现步骤 :** \n\n​\t1，需要有人管理这个通道\n\n​\t2，当有车进来了，发通行许可证\n\n​\t3，当车出去了，收回通行许可证\n\n​\t4，如果通行许可证发完了，那么其他车辆只能等着\n\n**代码实现 :** \n\n```java\npackage com.itheima.mysemaphore;\n\nimport java.util.concurrent.Semaphore;\n\npublic class MyRunnable implements Runnable {\n    //1.获得管理员对象，\n    private Semaphore semaphore = new Semaphore(2);\n    @Override\n    public void run() {\n        //2.获得通行证\n        try {\n            semaphore.acquire();\n            //3.开始行驶\n            System.out.println("获得了通行证开始行驶");\n            Thread.sleep(2000);\n            System.out.println("归还通行证");\n            //4.归还通行证\n            semaphore.release();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n```java\npackage com.itheima.mysemaphore;\n\npublic class MySemaphoreDemo {\n    public static void main(String[] args) {\n        MyRunnable mr = new MyRunnable();\n\n        for (int i = 0; i < 100; i++) {\n            new Thread(mr).start();\n        }\n    }\n}\n```\n\n\n\n'},e6d3:function(n,e,t){"use strict";t.r(e),e["default"]='## 1.Map集合\n\n### 1.1Map集合概述和特点【理解】\n\n- Map集合概述\n\n  ```java\n  interface Map<K,V>  K：键的类型；V：值的类型\n  ```\n\n- Map集合的特点\n\n  - 双列集合,一个键对应一个值\n  - 键不可以重复,值可以重复\n\n- Map集合的基本使用\n\n  ```java\n  public class MapDemo01 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String,String> map = new HashMap<String,String>();\n\n          //V put(K key, V value) 将指定的值与该映射中的指定键相关联\n          map.put("itheima001","林青霞");\n          map.put("itheima002","张曼玉");\n          map.put("itheima003","王祖贤");\n          map.put("itheima003","柳岩");\n\n          //输出集合对象\n          System.out.println(map);\n      }\n  }\n  ```\n\n### 1.2Map集合的基本功能【应用】\n\n- 方法介绍\n\n  | 方法名                                 | 说明                 |\n  | ----------------------------------- | ------------------ |\n  | V   put(K key,V   value)            | 添加元素               |\n  | V   remove(Object key)              | 根据键删除键值对元素         |\n  | void   clear()                      | 移除所有的键值对元素         |\n  | boolean containsKey(Object key)     | 判断集合是否包含指定的键       |\n  | boolean containsValue(Object value) | 判断集合是否包含指定的值       |\n  | boolean isEmpty()                   | 判断集合是否为空           |\n  | int size()                          | 集合的长度，也就是集合中键值对的个数 |\n\n- 示例代码\n\n  ```java\n  public class MapDemo02 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String,String> map = new HashMap<String,String>();\n\n          //V put(K key,V value)：添加元素\n          map.put("张无忌","赵敏");\n          map.put("郭靖","黄蓉");\n          map.put("杨过","小龙女");\n\n          //V remove(Object key)：根据键删除键值对元素\n  //        System.out.println(map.remove("郭靖"));\n  //        System.out.println(map.remove("郭襄"));\n\n          //void clear()：移除所有的键值对元素\n  //        map.clear();\n\n          //boolean containsKey(Object key)：判断集合是否包含指定的键\n  //        System.out.println(map.containsKey("郭靖"));\n  //        System.out.println(map.containsKey("郭襄"));\n\n          //boolean isEmpty()：判断集合是否为空\n  //        System.out.println(map.isEmpty());\n\n          //int size()：集合的长度，也就是集合中键值对的个数\n          System.out.println(map.size());\n\n          //输出集合对象\n          System.out.println(map);\n      }\n  }\n  ```\n\n### 1.3Map集合的获取功能【应用】\n\n- 方法介绍\n\n  | 方法名                              | 说明           |\n  | -------------------------------- | ------------ |\n  | V   get(Object key)              | 根据键获取值       |\n  | Set<K>   keySet()                | 获取所有键的集合     |\n  | Collection<V>   values()         | 获取所有值的集合     |\n  | Set<Map.Entry<K,V>>   entrySet() | 获取所有键值对对象的集合 |\n\n- 示例代码\n\n  ```java\n  public class MapDemo03 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String, String> map = new HashMap<String, String>();\n\n          //添加元素\n          map.put("张无忌", "赵敏");\n          map.put("郭靖", "黄蓉");\n          map.put("杨过", "小龙女");\n\n          //V get(Object key):根据键获取值\n  //        System.out.println(map.get("张无忌"));\n  //        System.out.println(map.get("张三丰"));\n\n          //Set<K> keySet():获取所有键的集合\n  //        Set<String> keySet = map.keySet();\n  //        for(String key : keySet) {\n  //            System.out.println(key);\n  //        }\n\n          //Collection<V> values():获取所有值的集合\n          Collection<String> values = map.values();\n          for(String value : values) {\n              System.out.println(value);\n          }\n      }\n  }\n  ```\n\n### 1.4Map集合的遍历(方式1)【应用】\n\n- 遍历思路\n\n  - 我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合\n    - 把所有的丈夫给集中起来\n    - 遍历丈夫的集合，获取到每一个丈夫\n    - 根据丈夫去找对应的妻子\n\n- 步骤分析\n\n  - 获取所有键的集合。用keySet()方法实现\n  - 遍历键的集合，获取到每一个键。用增强for实现  \n  - 根据键去找值。用get(Object key)方法实现\n\n- 代码实现\n\n  ```java\n  public class MapDemo01 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String, String> map = new HashMap<String, String>();\n\n          //添加元素\n          map.put("张无忌", "赵敏");\n          map.put("郭靖", "黄蓉");\n          map.put("杨过", "小龙女");\n\n          //获取所有键的集合。用keySet()方法实现\n          Set<String> keySet = map.keySet();\n          //遍历键的集合，获取到每一个键。用增强for实现\n          for (String key : keySet) {\n              //根据键去找值。用get(Object key)方法实现\n              String value = map.get(key);\n              System.out.println(key + "," + value);\n          }\n      }\n  }\n  ```\n\n### 1.5Map集合的遍历(方式2)【应用】\n\n- 遍历思路\n\n  - 我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合\n    - 获取所有结婚证的集合\n    - 遍历结婚证的集合，得到每一个结婚证\n    - 根据结婚证获取丈夫和妻子\n\n- 步骤分析\n\n  - 获取所有键值对对象的集合\n    - Set<Map.Entry<K,V>> entrySet()：获取所有键值对对象的集合\n  - 遍历键值对对象的集合，得到每一个键值对对象\n    - 用增强for实现，得到每一个Map.Entry\n  - 根据键值对对象获取键和值\n    - 用getKey()得到键\n    - 用getValue()得到值\n\n- 代码实现\n\n  ```java\n  public class MapDemo02 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String, String> map = new HashMap<String, String>();\n\n          //添加元素\n          map.put("张无忌", "赵敏");\n          map.put("郭靖", "黄蓉");\n          map.put("杨过", "小龙女");\n\n          //获取所有键值对对象的集合\n          Set<Map.Entry<String, String>> entrySet = map.entrySet();\n          //遍历键值对对象的集合，得到每一个键值对对象\n          for (Map.Entry<String, String> me : entrySet) {\n              //根据键值对对象获取键和值\n              String key = me.getKey();\n              String value = me.getValue();\n              System.out.println(key + "," + value);\n          }\n      }\n  }\n  ```\n\n## 2.HashMap集合\n\n### 2.1HashMap集合概述和特点【理解】\n\n+ HashMap底层是哈希表结构的\n+ 依赖hashCode方法和equals方法保证键的唯一\n+ 如果键要存储的是自定义对象，需要重写hashCode和equals方法\n\n### 2.2HashMap集合应用案例【应用】\n\n- 案例需求\n\n  - 创建一个HashMap集合，键是学生对象(Student)，值是居住地 (String)。存储多个元素，并遍历。\n  - 要求保证键的唯一性：如果学生对象的成员变量值相同，我们就认为是同一个对象\n\n- 代码实现\n\n  学生类\n\n  ```java\n  public class Student {\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public boolean equals(Object o) {\n          if (this == o) return true;\n          if (o == null || getClass() != o.getClass()) return false;\n\n          Student student = (Student) o;\n\n          if (age != student.age) return false;\n          return name != null ? name.equals(student.name) : student.name == null;\n      }\n\n      @Override\n      public int hashCode() {\n          int result = name != null ? name.hashCode() : 0;\n          result = 31 * result + age;\n          return result;\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class HashMapDemo {\n      public static void main(String[] args) {\n          //创建HashMap集合对象\n          HashMap<Student, String> hm = new HashMap<Student, String>();\n\n          //创建学生对象\n          Student s1 = new Student("林青霞", 30);\n          Student s2 = new Student("张曼玉", 35);\n          Student s3 = new Student("王祖贤", 33);\n          Student s4 = new Student("王祖贤", 33);\n\n          //把学生添加到集合\n          hm.put(s1, "西安");\n          hm.put(s2, "武汉");\n          hm.put(s3, "郑州");\n          hm.put(s4, "北京");\n\n          //遍历集合\n          Set<Student> keySet = hm.keySet();\n          for (Student key : keySet) {\n              String value = hm.get(key);\n              System.out.println(key.getName() + "," + key.getAge() + "," + value);\n          }\n      }\n  }\n  ```\n\n## 3.TreeMap集合\n\n### 3.1TreeMap集合概述和特点【理解】\n\n+ TreeMap底层是红黑树结构\n+ 依赖自然排序或者比较器排序,对键进行排序\n+ 如果键存储的是自定义对象,需要实现Comparable接口或者在创建TreeMap对象时候给出比较器排序规则\n\n### 3.2TreeMap集合应用案例一【应用】\n\n+ 案例需求\n\n  + 创建一个TreeMap集合,键是学生对象(Student),值是籍贯(String),学生属性姓名和年龄,按照年龄进行排序并遍历\n  + 要求按照学生的年龄进行排序,如果年龄相同则按照姓名进行排序\n\n+ 代码实现\n\n  学生类\n\n  ```java\n  public class Student implements Comparable<Student>{\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public String toString() {\n          return "Student{" +\n                  "name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n\n      @Override\n      public int compareTo(Student o) {\n          //按照年龄进行排序\n          int result = o.getAge() - this.getAge();\n          //次要条件，按照姓名排序。\n          result = result == 0 ? o.getName().compareTo(this.getName()) : result;\n          return result;\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class Test1 {\n      public static void main(String[] args) {\n        \t// 创建TreeMap集合对象\n          TreeMap<Student,String> tm = new TreeMap<>();\n        \n  \t\t// 创建学生对象\n          Student s1 = new Student("xiaohei",23);\n          Student s2 = new Student("dapang",22);\n          Student s3 = new Student("xiaomei",22);\n        \n  \t\t// 将学生对象添加到TreeMap集合中\n          tm.put(s1,"江苏");\n          tm.put(s2,"北京");\n          tm.put(s3,"天津");\n        \n  \t\t// 遍历TreeMap集合,打印每个学生的信息\n          tm.forEach(\n                  (Student key, String value)->{\n                      System.out.println(key + "---" + value);\n                  }\n          );\n      }\n  }\n  ```\n\n### 3.3TreeMap集合应用案例二【应用】\n\n- 案例需求\n\n  - 给定一个字符串,要求统计字符串中每个字符出现的次数。\n  - 举例: 给定字符串是“aababcabcdabcde”,在控制台输出: “a(5)b(4)c(3)d(2)e(1)”\n\n- 代码实现\n\n  ```java\n  public class Test2 {\n      public static void main(String[] args) {\n        \t// 给定字符串\n          String s = "aababcabcdabcde";\n  \t\t// 创建TreeMap集合对象,键是Character,值是Integer\n          TreeMap<Character,Integer> tm = new TreeMap<>();\n\n          //遍历字符串，得到每一个字符\n          for (int i = 0; i < s.length(); i++) {\n              //c依次表示字符串中的每一个字符\n              char c = s.charAt(i);\n            \t// 判断当前遍历到的字符是否在集合中出现过\n              if(!tm.containsKey(c)){\n                  //表示当前字符是第一次出现。\n                  tm.put(c,1);\n              }else{\n                  //存在，表示当前字符已经出现过了\n                  //先获取这个字符已经出现的次数\n                  Integer count = tm.get(c);\n                  //自增，表示这个字符又出现了依次\n                  count++;\n                  //将自增后的结果再次添加到集合中。\n                  tm.put(c,count);\n              }\n          }\n          //  a（5）b（4）c（3）d（2）e（1）\n          //System.out.println(tm);\n          tm.forEach(\n                  (Character key,Integer value)->{\n                      System.out.print(key + "（" + value + "）");\n                  }\n          );\n      }\n  }\n  ```\n\n## 4.可变参数\n\n### 4.1可变参数【应用】\n\n- 可变参数介绍\n\n  - 可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了\n  - 方法的参数类型已经确定,个数不确定,我们可以使用可变参数\n\n- 可变参数定义格式\n\n  ```java\n  修饰符 返回值类型 方法名(数据类型… 变量名) {  }\n  ```\n\n- 可变参数的注意事项\n\n  - 这里的变量其实是一个数组\n  - 如果一个方法有多个参数，包含可变参数，可变参数要放在最后\n\n- 可变参数的基本使用\n\n  ```java\n  public class ArgsDemo01 {\n      public static void main(String[] args) {\n          System.out.println(sum(10, 20));\n          System.out.println(sum(10, 20, 30));\n          System.out.println(sum(10, 20, 30, 40));\n\n          System.out.println(sum(10,20,30,40,50));\n          System.out.println(sum(10,20,30,40,50,60));\n          System.out.println(sum(10,20,30,40,50,60,70));\n          System.out.println(sum(10,20,30,40,50,60,70,80,90,100));\n      }\n\n  //    public static int sum(int b,int... a) {\n  //        return 0;\n  //    }\n\n      public static int sum(int... a) {\n          int sum = 0;\n          for(int i : a) {\n              sum += i;\n          }\n          return sum;\n      }\n  }\n  ```\n\n### 4.2创建不可变集合【理解】\n\n+ 方法介绍\n\n  + 在List、Set、Map接口中,都存在of方法,可以创建一个不可变的集合\n    + 这个集合不能添加,不能删除,不能修改\n    + 但是可以结合集合的带参构造,实现集合的批量添加\n  + 在Map接口中,还有一个ofEntries方法可以提高代码的阅读性\n    + 首先会把键值对封装成一个Entry对象,再把这个Entry对象添加到集合当中\n\n+ 示例代码\n\n  ```java\n  public class MyVariableParameter4 {\n      public static void main(String[] args) {\n          // static <E>  List<E>  of(E…elements)  创建一个具有指定元素的List集合对象\n          //static <E>  Set<E>  of(E…elements)    创建一个具有指定元素的Set集合对象\n          //static <K , V>   Map<K，V>  of(E…elements) 创建一个具有指定元素的Map集合对象\n\n          //method1();\n          //method2();\n          //method3();\n          //method4();\n\n      }\n\n      private static void method4() {\n          Map<String, String> map = Map.ofEntries(\n                  Map.entry("zhangsan", "江苏"),\n                  Map.entry("lisi", "北京"));\n          System.out.println(map);\n      }\n\n      private static void method3() {\n          Map<String, String> map = Map.of("zhangsan", "江苏", "lisi", "北京", "wangwu", "天津");\n          System.out.println(map);\n      }\n\n      private static void method2() {\n          //传递的参数当中，不能存在重复的元素。\n          Set<String> set = Set.of("a", "b", "c", "d","a");\n          System.out.println(set);\n      }\n\n      private static void method1() {\n          List<String> list = List.of("a", "b", "c", "d");\n          System.out.println(list);\n          //list.add("Q");\n          //list.remove("a");\n          //list.set(0,"A");\n          //System.out.println(list);\n\n  //        ArrayList<String> list2 = new ArrayList<>();\n  //        list2.add("aaa");\n  //        list2.add("aaa");\n  //        list2.add("aaa");\n  //        list2.add("aaa");\n\n          //集合的批量添加。\n          //首先是通过调用List.of方法来创建一个不可变的集合，of方法的形参就是一个可变参数。\n          //再创建一个ArrayList集合，并把这个不可变的集合中所有的数据，都添加到ArrayList中。\n          ArrayList<String> list3 = new ArrayList<>(List.of("a", "b", "c", "d"));\n          System.out.println(list3);\n      }\n  }\n  ```\n\n## 5.Stream流\n\n### 5.1体验Stream流【理解】\n\n- 案例需求\n\n  按照下面的要求完成集合的创建和遍历\n\n  - 创建一个集合，存储多个字符串元素\n  - 把集合中所有以"张"开头的元素存储到一个新的集合\n  - 把"张"开头的集合中的长度为3的元素存储到一个新的集合\n  - 遍历上一步得到的集合\n\n- 原始方式示例代码\n\n  ```java\n  public class StreamDemo {\n      public static void main(String[] args) {\n          //创建一个集合，存储多个字符串元素\n          ArrayList<String> list = new ArrayList<String>();\n\n          list.add("林青霞");\n          list.add("张曼玉");\n          list.add("王祖贤");\n          list.add("柳岩");\n          list.add("张敏");\n          list.add("张无忌");\n\n          //把集合中所有以"张"开头的元素存储到一个新的集合\n          ArrayList<String> zhangList = new ArrayList<String>();\n\n          for(String s : list) {\n              if(s.startsWith("张")) {\n                  zhangList.add(s);\n              }\n          }\n\n  //        System.out.println(zhangList);\n\n          //把"张"开头的集合中的长度为3的元素存储到一个新的集合\n          ArrayList<String> threeList = new ArrayList<String>();\n\n          for(String s : zhangList) {\n              if(s.length() == 3) {\n                  threeList.add(s);\n              }\n          }\n\n  //        System.out.println(threeList);\n\n          //遍历上一步得到的集合\n          for(String s : threeList) {\n              System.out.println(s);\n          }\n          System.out.println("--------");\n\n          //Stream流来改进\n  //        list.stream().filter(s -> s.startsWith("张")).filter(s -> s.length() == 3).forEach(s -> System.out.println(s));\n          list.stream().filter(s -> s.startsWith("张")).filter(s -> s.length() == 3).forEach(System.out::println);\n      }\n  }\n  ```\n\n- 使用Stream流示例代码\n\n  ```java\n  public class StreamDemo {\n      public static void main(String[] args) {\n          //创建一个集合，存储多个字符串元素\n          ArrayList<String> list = new ArrayList<String>();\n\n          list.add("林青霞");\n          list.add("张曼玉");\n          list.add("王祖贤");\n          list.add("柳岩");\n          list.add("张敏");\n          list.add("张无忌");\n\n          //Stream流来改进\n          list.stream().filter(s -> s.startsWith("张")).filter(s -> s.length() == 3).forEach(System.out::println);\n      }\n  }\n  ```\n\n- Stream流的好处\n\n  - 直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤姓张、过滤长度为3、逐一打印\n  - Stream流把真正的函数式编程风格引入到Java中\n  - 代码简洁\n\n### 5.2Stream流的常见生成方式【应用】\n\n- Stream流的思想\n\n  ![01_Stream流思想](./day18-集合03.img/01_Stream流思想.png)\n\n- Stream流的三类方法\n\n  + 获取Stream流\n    + 创建一条流水线,并把数据放到流水线上准备进行操作\n  + 中间方法\n    + 流水线上的操作\n    + 一次操作完毕之后,还可以继续进行其他操作\n  + 终结方法\n    + 一个Stream流只能有一个终结方法\n    + 是流水线上的最后一个操作\n\n- 生成Stream流的方式\n\n  - Collection体系集合\n\n    使用默认方法stream()生成流， default Stream<E> stream()\n\n  - Map体系集合\n\n    把Map转成Set集合，间接的生成流\n\n  - 数组\n\n    通过Arrays中的静态方法stream生成流\n\n  - 同种数据类型的多个数据\n\n    通过Stream接口的静态方法of(T... values)生成流\n\n- 代码演示\n\n  ```java\n  public class StreamDemo {\n      public static void main(String[] args) {\n          //Collection体系的集合可以使用默认方法stream()生成流\n          List<String> list = new ArrayList<String>();\n          Stream<String> listStream = list.stream();\n\n          Set<String> set = new HashSet<String>();\n          Stream<String> setStream = set.stream();\n\n          //Map体系的集合间接的生成流\n          Map<String,Integer> map = new HashMap<String, Integer>();\n          Stream<String> keyStream = map.keySet().stream();\n          Stream<Integer> valueStream = map.values().stream();\n          Stream<Map.Entry<String, Integer>> entryStream = map.entrySet().stream();\n\n          //数组可以通过Arrays中的静态方法stream生成流\n          String[] strArray = {"hello","world","java"};\n          Stream<String> strArrayStream = Arrays.stream(strArray);\n        \n        \t//同种数据类型的多个数据可以通过Stream接口的静态方法of(T... values)生成流\n          Stream<String> strArrayStream2 = Stream.of("hello", "world", "java");\n          Stream<Integer> intStream = Stream.of(10, 20, 30);\n      }\n  }\n  ```\n\n### 5.3Stream流中间操作方法【应用】\n\n- 概念\n\n  中间操作的意思是,执行完此方法之后,Stream流依然可以继续执行其他操作\n\n- 常见方法\n\n  | 方法名                                      | 说明                                       |\n  | ---------------------------------------- | ---------------------------------------- |\n  | Stream<T> filter(Predicate predicate)    | 用于对流中的数据进行过滤                             |\n  | Stream<T> limit(long maxSize)            | 返回此流中的元素组成的流，截取前指定参数个数的数据                |\n  | Stream<T> skip(long n)                   | 跳过指定参数个数的数据，返回由该流的剩余元素组成的流               |\n  | static <T> Stream<T> concat(Stream a, Stream b) | 合并a和b两个流为一个流                             |\n  | Stream<T> distinct()                     | 返回由该流的不同元素（根据Object.equals(Object) ）组成的流 |\n\n- filter代码演示\n\n  ```java\n  public class StreamDemo01 {\n      public static void main(String[] args) {\n          //创建一个集合，存储多个字符串元素\n          ArrayList<String> list = new ArrayList<String>();\n\n          list.add("林青霞");\n          list.add("张曼玉");\n          list.add("王祖贤");\n          list.add("柳岩");\n          list.add("张敏");\n          list.add("张无忌");\n\n          //需求1：把list集合中以张开头的元素在控制台输出\n          list.stream().filter(s -> s.startsWith("张")).forEach(System.out::println);\n          System.out.println("--------");\n\n          //需求2：把list集合中长度为3的元素在控制台输出\n          list.stream().filter(s -> s.length() == 3).forEach(System.out::println);\n          System.out.println("--------");\n\n          //需求3：把list集合中以张开头的，长度为3的元素在控制台输出\n          list.stream().filter(s -> s.startsWith("张")).filter(s -> s.length() == 3).forEach(System.out::println);\n      }\n  }\n  ```\n\n- limit&skip代码演示\n\n  ```java\n  public class StreamDemo02 {\n      public static void main(String[] args) {\n          //创建一个集合，存储多个字符串元素\n          ArrayList<String> list = new ArrayList<String>();\n\n          list.add("林青霞");\n          list.add("张曼玉");\n          list.add("王祖贤");\n          list.add("柳岩");\n          list.add("张敏");\n          list.add("张无忌");\n\n          //需求1：取前3个数据在控制台输出\n          list.stream().limit(3).forEach(System.out::println);\n          System.out.println("--------");\n\n          //需求2：跳过3个元素，把剩下的元素在控制台输出\n          list.stream().skip(3).forEach(System.out::println);\n          System.out.println("--------");\n\n          //需求3：跳过2个元素，把剩下的元素中前2个在控制台输出\n          list.stream().skip(2).limit(2).forEach(System.out::println);\n      }\n  }\n  ```\n\n- concat&distinct代码演示\n\n  ```java\n  public class StreamDemo03 {\n      public static void main(String[] args) {\n          //创建一个集合，存储多个字符串元素\n          ArrayList<String> list = new ArrayList<String>();\n\n          list.add("林青霞");\n          list.add("张曼玉");\n          list.add("王祖贤");\n          list.add("柳岩");\n          list.add("张敏");\n          list.add("张无忌");\n\n          //需求1：取前4个数据组成一个流\n          Stream<String> s1 = list.stream().limit(4);\n\n          //需求2：跳过2个数据组成一个流\n          Stream<String> s2 = list.stream().skip(2);\n\n          //需求3：合并需求1和需求2得到的流，并把结果在控制台输出\n  //        Stream.concat(s1,s2).forEach(System.out::println);\n\n          //需求4：合并需求1和需求2得到的流，并把结果在控制台输出，要求字符串元素不能重复\n          Stream.concat(s1,s2).distinct().forEach(System.out::println);\n      }\n  }\n  ```\n\n### 5.4Stream流终结操作方法【应用】\n\n- 概念\n\n  终结操作的意思是,执行完此方法之后,Stream流将不能再执行其他操作\n\n- 常见方法\n\n  | 方法名                           | 说明           |\n  | ----------------------------- | ------------ |\n  | void forEach(Consumer action) | 对此流的每个元素执行操作 |\n  | long count()                  | 返回此流中的元素数    |\n\n- 代码演示\n\n  ```java\n  public class StreamDemo {\n      public static void main(String[] args) {\n          //创建一个集合，存储多个字符串元素\n          ArrayList<String> list = new ArrayList<String>();\n\n          list.add("林青霞");\n          list.add("张曼玉");\n          list.add("王祖贤");\n          list.add("柳岩");\n          list.add("张敏");\n          list.add("张无忌");\n\n          //需求1：把集合中的元素在控制台输出\n  //        list.stream().forEach(System.out::println);\n\n          //需求2：统计集合中有几个以张开头的元素，并把统计结果在控制台输出\n          long count = list.stream().filter(s -> s.startsWith("张")).count();\n          System.out.println(count);\n      }\n  }\n  ```\n\n### 5.5Stream流的收集操作【应用】\n\n- 概念\n\n  对数据使用Stream流的方式操作完毕后,可以把流中的数据收集到集合中\n\n- 常用方法\n\n  | 方法名                            | 说明        |\n  | ------------------------------ | --------- |\n  | R collect(Collector collector) | 把结果收集到集合中 |\n\n- 工具类Collectors提供了具体的收集方式\n\n  | 方法名                                      | 说明            |\n  | ---------------------------------------- | ------------- |\n  | public static <T> Collector toList()     | 把元素收集到List集合中 |\n  | public static <T> Collector toSet()      | 把元素收集到Set集合中  |\n  | public static  Collector toMap(Function keyMapper,Function valueMapper) | 把元素收集到Map集合中  |\n\n- 代码演示\n\n  ```java\n  public class CollectDemo {\n      public static void main(String[] args) {\n          //创建List集合对象\n          List<String> list = new ArrayList<String>();\n          list.add("林青霞");\n          list.add("张曼玉");\n          list.add("王祖贤");\n          list.add("柳岩");\n\n          /*\n          //需求1：得到名字为3个字的流\n          Stream<String> listStream = list.stream().filter(s -> s.length() == 3);\n\n          //需求2：把使用Stream流操作完毕的数据收集到List集合中并遍历\n          List<String> names = listStream.collect(Collectors.toList());\n          for(String name : names) {\n              System.out.println(name);\n          }\n          */\n\n          //创建Set集合对象\n          Set<Integer> set = new HashSet<Integer>();\n          set.add(10);\n          set.add(20);\n          set.add(30);\n          set.add(33);\n          set.add(35);\n\n          /*\n          //需求3：得到年龄大于25的流\n          Stream<Integer> setStream = set.stream().filter(age -> age > 25);\n\n          //需求4：把使用Stream流操作完毕的数据收集到Set集合中并遍历\n          Set<Integer> ages = setStream.collect(Collectors.toSet());\n          for(Integer age : ages) {\n              System.out.println(age);\n          }\n          */\n          //定义一个字符串数组，每一个字符串数据由姓名数据和年龄数据组合而成\n          String[] strArray = {"林青霞,30", "张曼玉,35", "王祖贤,33", "柳岩,25"};\n\n          //需求5：得到字符串中年龄数据大于28的流\n          Stream<String> arrayStream = Stream.of(strArray).filter(s -> Integer.parseInt(s.split(",")[1]) > 28);\n\n          //需求6：把使用Stream流操作完毕的数据收集到Map集合中并遍历，字符串中的姓名作键，年龄作值\n          Map<String, Integer> map = arrayStream.collect(Collectors.toMap(s -> s.split(",")[0], s -> Integer.parseInt(s.split(",")[1])));\n\n          Set<String> keySet = map.keySet();\n          for (String key : keySet) {\n              Integer value = map.get(key);\n              System.out.println(key + "," + value);\n          }\n      }\n  }\n  ```\n\n### 5.6Stream流综合练习【应用】\n\n- 案例需求\n\n  现在有两个ArrayList集合，分别存储6名男演员名称和6名女演员名称，要求完成如下的操作\n\n  - 男演员只要名字为3个字的前三人\n  - 女演员只要姓林的，并且不要第一个\n  - 把过滤后的男演员姓名和女演员姓名合并到一起\n  - 把上一步操作后的元素作为构造方法的参数创建演员对象,遍历数据\n\n  演员类Actor已经提供，里面有一个成员变量，一个带参构造方法，以及成员变量对应的get/set方法\n\n- 代码实现\n\n  演员类\n\n  ```java\n  public class Actor {\n      private String name;\n\n      public Actor(String name) {\n          this.name = name;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class StreamTest {\n      public static void main(String[] args) {\n          //创建集合\n          ArrayList<String> manList = new ArrayList<String>();\n          manList.add("周润发");\n          manList.add("成龙");\n          manList.add("刘德华");\n          manList.add("吴京");\n          manList.add("周星驰");\n          manList.add("李连杰");\n\n          ArrayList<String> womanList = new ArrayList<String>();\n          womanList.add("林心如");\n          womanList.add("张曼玉");\n          womanList.add("林青霞");\n          womanList.add("柳岩");\n          womanList.add("林志玲");\n          womanList.add("王祖贤");\n    \n          /*\n          //男演员只要名字为3个字的前三人\n          Stream<String> manStream = manList.stream().filter(s -> s.length() == 3).limit(3);\n    \n          //女演员只要姓林的，并且不要第一个\n          Stream<String> womanStream = womanList.stream().filter(s -> s.startsWith("林")).skip(1);\n    \n          //把过滤后的男演员姓名和女演员姓名合并到一起\n          Stream<String> stream = Stream.concat(manStream, womanStream);\n    \n          //把上一步操作后的元素作为构造方法的参数创建演员对象,遍历数据\n  //        stream.map(Actor::new).forEach(System.out::println);\n          stream.map(Actor::new).forEach(p -> System.out.println(p.getName()));\n          */\n    \n          Stream.concat(manList.stream().filter(s -> s.length() == 3).limit(3),\n                  womanList.stream().filter(s -> s.startsWith("林")).skip(1)).map(Actor::new).\n                  forEach(p -> System.out.println(p.getName()));\n      }\n  }\n  ```\n\n\n'},e8ec:function(n,e,t){"use strict";t.r(e),e["default"]='点击关注[公众号](#公众号)及时获取笔主最新更新文章，并可免费领取本文档配套的《Java面试突击》以及Java工程师必备学习资源。\n\n\x3c!-- MarkdownTOC --\x3e\n\n- [Servlet总结](#servlet总结)\n- [阐述Servlet和CGI的区别?](#阐述servlet和cgi的区别)\n    - [CGI的不足之处:](#cgi的不足之处)\n    - [Servlet的优点：](#servlet的优点)\n- [Servlet接口中有哪些方法及Servlet生命周期探秘](#servlet接口中有哪些方法及servlet生命周期探秘)\n- [get和post请求的区别](#get和post请求的区别)\n- [什么情况下调用doGet\\(\\)和doPost\\(\\)](#什么情况下调用doget和dopost)\n- [转发（Forward）和重定向（Redirect）的区别](#转发forward和重定向redirect的区别)\n- [自动刷新\\(Refresh\\)](#自动刷新refresh)\n- [Servlet与线程安全](#servlet与线程安全)\n- [JSP和Servlet是什么关系](#jsp和servlet是什么关系)\n- [JSP工作原理](#jsp工作原理)\n- [JSP有哪些内置对象、作用分别是什么](#jsp有哪些内置对象、作用分别是什么)\n- [Request对象的主要方法有哪些](#request对象的主要方法有哪些)\n- [request.getAttribute\\(\\)和 request.getParameter\\(\\)有何区别](#requestgetattribute和-requestgetparameter有何区别)\n- [include指令include的行为的区别](#include指令include的行为的区别)\n- [JSP九大内置对象，七大动作，三大指令](#jsp九大内置对象，七大动作，三大指令)\n- [讲解JSP中的四种作用域](#讲解jsp中的四种作用域)\n- [如何实现JSP或Servlet的单线程模式](#如何实现jsp或servlet的单线程模式)\n- [实现会话跟踪的技术有哪些](#实现会话跟踪的技术有哪些)\n- [Cookie和Session的的区别](#cookie和session的的区别)\n\n\x3c!-- /MarkdownTOC --\x3e\n\n## Servlet总结\n\n在Java Web程序中，**Servlet**主要负责接收用户请求 `HttpServletRequest`,在`doGet()`,`doPost()`中做相应的处理，并将回应`HttpServletResponse`反馈给用户。**Servlet** 可以设置初始化参数，供Servlet内部使用。一个Servlet类只会有一个实例，在它初始化时调用`init()`方法，销毁时调用`destroy()`方法**。**Servlet需要在web.xml中配置（MyEclipse中创建Servlet会自动配置），**一个Servlet可以设置多个URL访问**。**Servlet不是线程安全**，因此要谨慎使用类变量。\n\n## 阐述Servlet和CGI的区别?\n\n### CGI的不足之处:\n\n1，需要为每个请求启动一个操作CGI程序的系统进程。如果请求频繁，这将会带来很大的开销。\n\n2，需要为每个请求加载和运行一个CGI程序，这将带来很大的开销 \n\n3，需要重复编写处理网络协议的代码以及编码，这些工作都是非常耗时的。\n\n### Servlet的优点:\n\n1，只需要启动一个操作系统进程以及加载一个JVM，大大降低了系统的开销\n\n2，如果多个请求需要做同样处理的时候，这时候只需要加载一个类，这也大大降低了开销\n\n3，所有动态加载的类可以实现对网络协议以及请求解码的共享，大大降低了工作量。\n\n4，Servlet能直接和Web服务器交互，而普通的CGI程序不能。Servlet还能在各个程序之间共享数据，使数据库连接池之类的功能很容易实现。\n\n补充：Sun Microsystems公司在1996年发布Servlet技术就是为了和CGI进行竞争，Servlet是一个特殊的Java程序，一个基于Java的Web应用通常包含一个或多个Servlet类。Servlet不能够自行创建并执行，它是在Servlet容器中运行的，容器将用户的请求传递给Servlet程序，并将Servlet的响应回传给用户。通常一个Servlet会关联一个或多个JSP页面。以前CGI经常因为性能开销上的问题被诟病，然而Fast CGI早就已经解决了CGI效率上的问题，所以面试的时候大可不必信口开河的诟病CGI，事实上有很多你熟悉的网站都使用了CGI技术。\n\n参考：《javaweb整合开发王者归来》P7\n\n## Servlet接口中有哪些方法及Servlet生命周期探秘\nServlet接口定义了5个方法，其中**前三个方法与Servlet生命周期相关**：\n\n- `void init(ServletConfig config) throws ServletException`\n- `void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException`\n- `void destroy()`\n- `java.lang.String getServletInfo()`\n- `ServletConfig getServletConfig()`\n\n**生命周期：** **Web容器加载Servlet并将其实例化后，Servlet生命周期开始**，容器运行其**init()方法**进行Servlet的初始化；请求到达时调用Servlet的**service()方法**，service()方法会根据需要调用与请求对应的**doGet或doPost**等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的**destroy()方法**。**init方法和destroy方法只会执行一次，service方法客户端每次请求Servlet都会执行**。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。\n\n参考：《javaweb整合开发王者归来》P81\n\n## get和post请求的区别\n\nget和post请求实际上是没有区别，大家可以自行查询相关文章（参考文章：[https://www.cnblogs.com/logsharing/p/8448446.html](https://www.cnblogs.com/logsharing/p/8448446.html)，知乎对应的问题链接：[get和post区别？](https://www.zhihu.com/question/28586791)）！\n\n可以把 get 和 post 当作两个不同的行为，两者并没有什么本质区别，底层都是 TCP 连接。 get请求用来从服务器上获得资源，而post是用来向服务器提交数据。比如你要获取人员列表可以用 get 请求，你需要创建一个人员可以用 post 。这也是 Restful  API 最基本的一个要求。\n\n推荐阅读：\n\n- https://www.zhihu.com/question/28586791\n- https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&mid=100000054&idx=1&sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd\n\n## 什么情况下调用doGet()和doPost()\nForm标签里的method的属性为get时调用doGet()，为post时调用doPost()。\n\n## 转发(Forward)和重定向(Redirect)的区别\n\n**转发是服务器行为，重定向是客户端行为。**\n\n**转发（Forward）**\n通过RequestDispatcher对象的forward（HttpServletRequest request,HttpServletResponse response）方法实现的。RequestDispatcher可以通过HttpServletRequest 的getRequestDispatcher()方法获得。例如下面的代码就是跳转到login_success.jsp页面。\n```java\n     request.getRequestDispatcher("login_success.jsp").forward(request, response);\n```\n**重定向（Redirect）**  是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过 `HttpServletResponse` 的 `setStatus(int status)` 方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。\n\n1. **从地址栏显示来说**\n\nforward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.\nredirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.\n\n2. **从数据共享来说**\n\nforward:转发页面和转发到的页面可以共享request里面的数据.\nredirect:不能共享数据.\n\n3. **从运用地方来说**\n\nforward:一般用于用户登陆的时候,根据角色转发到相应的模块.\nredirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等\n\n4. 从效率来说\n\nforward:高.\nredirect:低.\n\n## 自动刷新(Refresh)\n自动刷新不仅可以实现一段时间之后自动跳转到另一个页面，还可以实现一段时间之后自动刷新本页面。Servlet中通过HttpServletResponse对象设置Header属性实现自动刷新例如：\n```java\nResponse.setHeader("Refresh","5;URL=http://localhost:8080/servlet/example.htm");\n```\n其中5为时间，单位为秒。URL指定就是要跳转的页面（如果设置自己的路径，就会实现每过5秒自动刷新本页面一次）\n\n\n## Servlet与线程安全\n**Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题。** 解决的办法是尽量不要定义name属性，而是要把name变量分别定义在doGet()和doPost()方法内。虽然使用synchronized(name){}语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。\n注意：多线程的并发的读写Servlet类属性会导致数据不同步。但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此Servlet里的只读属性最好定义为final类型的。\n\n参考：《javaweb整合开发王者归来》P92\n\n\n\n## JSP和Servlet是什么关系\n其实这个问题在上面已经阐述过了，Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然这个说法是很片面且不够准确的。JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。\n\n## JSP工作原理\nJSP是一种Servlet，但是与HttpServlet的工作方式不太一样。HttpServlet是先由源代码编译为class文件后部署到服务器下，为先编译后部署。而JSP则是先部署后编译。JSP会在客户端第一次请求JSP文件时被编译为HttpJspPage类（接口Servlet的一个子类）。该类会被服务器临时存放在服务器工作目录里面。下面通过实例给大家介绍。\n工程JspLoginDemo下有一个名为login.jsp的Jsp文件，把工程第一次部署到服务器上后访问这个Jsp文件，我们发现这个目录下多了下图这两个东东。\n.class文件便是JSP对应的Servlet。编译完毕后再运行class文件来响应客户端请求。以后客户端访问login.jsp的时候，Tomcat将不再重新编译JSP文件，而是直接调用class文件来响应客户端请求。\n![JSP工作原理](J2EE基础知识.assets/1.png)\n由于JSP只会在客户端第一次请求的时候被编译 ，因此第一次请求JSP时会感觉比较慢，之后就会感觉快很多。如果把服务器保存的class文件删除，服务器也会重新编译JSP。\n\n开发Web程序时经常需要修改JSP。Tomcat能够自动检测到JSP程序的改动。如果检测到JSP源代码发生了改动。Tomcat会在下次客户端请求JSP时重新编译JSP，而不需要重启Tomcat。这种自动检测功能是默认开启的，检测改动会消耗少量的时间，在部署Web应用的时候可以在web.xml中将它关掉。\n\n参考：《javaweb整合开发王者归来》P97\n\n## JSP有哪些内置对象、作用分别是什么\n[JSP内置对象 - CSDN博客 ](http://blog.csdn.net/qq_34337272/article/details/64310849 ) \n\nJSP有9个内置对象：\n- request：封装客户端的请求，其中包含来自GET或POST请求的参数；\n- response：封装服务器对客户端的响应；\n- pageContext：通过该对象可以获取其他对象；\n- session：封装用户会话的对象；\n- application：封装服务器运行环境的对象；\n- out：输出服务器响应的输出流对象；\n- config：Web应用的配置对象；\n- page：JSP页面本身（相当于Java程序中的this）；\n- exception：封装页面抛出异常的对象。\n\n\n## Request对象的主要方法有哪些\n- setAttribute(String name,Object)：设置名字为name的request 的参数值 \n- getAttribute(String name)：返回由name指定的属性值 \n- getAttributeNames()：返回request 对象所有属性的名字集合，结果是一个枚举的实例 \n- getCookies()：返回客户端的所有 Cookie 对象，结果是一个Cookie 数组 \n- getCharacterEncoding() ：返回请求中的字符编码方式 = getContentLength() ：返回请求的 Body的长度 \n- getHeader(String name) ：获得HTTP协议定义的文件头信息 \n- getHeaders(String name) ：返回指定名字的request Header 的所有值，结果是一个枚举的实例 \n- getHeaderNames() ：返回所以request Header 的名字，结果是一个枚举的实例 \n- getInputStream() ：返回请求的输入流，用于获得请求中的数据 \n- getMethod() ：获得客户端向服务器端传送数据的方法 \n- getParameter(String name) ：获得客户端传送给服务器端的有 name指定的参数值 \n- getParameterNames() ：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例 \n- getParameterValues(String name)：获得有name指定的参数的所有值 \n- getProtocol()：获取客户端向服务器端传送数据所依据的协议名称 \n- getQueryString() ：获得查询字符串 \n- getRequestURI() ：获取发出请求字符串的客户端地址 \n- getRemoteAddr()：获取客户端的 IP 地址 \n- getRemoteHost() ：获取客户端的名字 \n- getSession([Boolean create]) ：返回和请求相关 Session \n- getServerName() ：获取服务器的名字 \n- getServletPath()：获取客户端所请求的脚本文件的路径 \n- getServerPort()：获取服务器的端口号 \n- removeAttribute(String name)：删除请求中的一个属性 \n\n## request.getAttribute()和 request.getParameter()有何区别\n**从获取方向来看：**\n\n`getParameter()`是获取 POST/GET 传递的参数值；\n\n`getAttribute()`是获取对象容器中的数据值；\n\n**从用途来看：**\n\n`getParameter()`用于客户端重定向时，即点击了链接或提交按扭时传值用，即用于在用表单或url重定向传值时接收数据用。\n\n`getAttribute()` 用于服务器端重定向时，即在 sevlet 中使用了 forward 函数,或 struts 中使用了\nmapping.findForward。 getAttribute 只能收到程序用 setAttribute 传过来的值。\n\n另外，可以用 `setAttribute()`,`getAttribute()` 发送接收对象.而 `getParameter()` 显然只能传字符串。\n`setAttribute()` 是应用服务器把这个对象放在该页面所对应的一块内存中去，当你的页面服务器重定向到另一个页面时，应用服务器会把这块内存拷贝另一个页面所对应的内存中。这样`getAttribute()`就能取得你所设下的值，当然这种方法可以传对象。session也一样，只是对象在内存中的生命周期不一样而已。`getParameter()`只是应用服务器在分析你送上来的 request页面的文本时，取得你设在表单或 url 重定向时的值。\n\n**总结：**\n\n`getParameter()`返回的是String,用于读取提交的表单中的值;（获取之后会根据实际需要转换为自己需要的相应类型，比如整型，日期类型啊等等）\n\n`getAttribute()`返回的是Object，需进行转换,可用`setAttribute()`设置成任意对象，使用很灵活，可随时用\n\n## include指令include的行为的区别\n**include指令：** JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。 语法格式如下： \n<%@ include file="文件相对 url 地址" %>\n\ni**nclude动作：** `<jsp:include>`动作元素用来包含静态和动态的文件。该动作把指定文件插入正在生成的页面。语法格式如下：\n<jsp:include page="相对 URL 地址" flush="true" />\n\n## JSP九大内置对象，七大动作，三大指令\n[JSP九大内置对象，七大动作，三大指令总结](http://blog.csdn.net/qq_34337272/article/details/64310849)\n\n## 讲解JSP中的四种作用域\nJSP中的四种作用域包括page、request、session和application，具体来说：\n- **page**代表与一个页面相关的对象和属性。\n- **request**代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。\n- **session**代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。\n- **application**代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。\n\n## 如何实现JSP或Servlet的单线程模式\n对于JSP页面，可以通过page指令进行设置。\n`<%@page isThreadSafe="false"%>`\n\n对于Servlet，可以让自定义的Servlet实现SingleThreadModel标识接口。\n\n说明：如果将JSP或Servlet设置成单线程工作模式，会导致每个请求创建一个Servlet实例，这种实践将导致严重的性能问题（服务器的内存压力很大，还会导致频繁的垃圾回收），所以通常情况下并不会这么做。\n\n## 实现会话跟踪的技术有哪些\n1. **使用Cookie**\n\n向客户端发送Cookie\n```java\nCookie c =new Cookie("name","value"); //创建Cookie \nc.setMaxAge(60*60*24); //设置最大时效，此处设置的最大时效为一天\nresponse.addCookie(c); //把Cookie放入到HTTP响应中\n```\n从客户端读取Cookie\n```java\nString name ="name"; \nCookie[]cookies =request.getCookies(); \nif(cookies !=null){ \n   for(int i= 0;i<cookies.length;i++){ \n    Cookie cookie =cookies[i]; \n    if(name.equals(cookis.getName())) \n    //something is here. \n    //you can get the value \n    cookie.getValue(); \n       \n   }\n }\n\n```\n**优点:** 数据可以持久保存，不需要服务器资源，简单，基于文本的Key-Value\n\n**缺点:** 大小受到限制，用户可以禁用Cookie功能，由于保存在本地，有一定的安全风险。\n\n2. URL 重写\n\n在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以标识一个会话。 \n\n**优点：** 在Cookie被禁用的时候依然可以使用\n\n**缺点：** 必须对网站的URL进行编码，所有页面必须动态生成，不能用预先记录下来的URL进行访问。\n\n3.隐藏的表单域\n```html\n<input type="hidden" name ="session" value="..."/>\n```\n\n**优点：** Cookie被禁时可以使用\n\n**缺点：** 所有页面必须是表单提交之后的结果。\n\n4. HttpSession\n\n\n 在所有会话跟踪技术中，HttpSession对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建 HttpSession，每个用户可以访问他自己的HttpSession。可以通过HttpServletRequest对象的getSession方 法获得HttpSession，通过HttpSession的setAttribute方法可以将一个值放在HttpSession中，通过调用 HttpSession对象的getAttribute方法，同时传入属性名就可以获取保存在HttpSession中的对象。与上面三种方式不同的 是，HttpSession放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的Servlet容器可以在内存将满时将HttpSession 中的对象移到其他存储设备中，但是这样势必影响性能。添加到HttpSession中的值可以是任意Java对象，这个对象最好实现了 Serializable接口，这样Servlet容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。\n## Cookie和Session的的区别\n\nCookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。\n\n **Cookie 一般用来保存用户信息** 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。**Session 的主要作用就是通过服务端记录用户的状态。** 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。\n\nCookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。\n\nCookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。\n\n'},e92a:function(n,e,t){"use strict";t.r(e),e["default"]="## 分布式 ID\n\n### 何为 ID？\n\n日常开发中，我们需要对系统中的各种数据使用 ID 唯一表示，比如用户 ID 对应且仅对应一个人，商品 ID 对应且仅对应一件商品，订单 ID 对应且仅对应一个订单。\n\n![](分布式ID.assets/up-79beb853b8319f850638c9708f83039dfda.png)\n\n我们现实生活中也有各种 ID，比如身份证 ID 对应且仅对应一个人、地址 ID 对应且仅对应\n\n简单来说，**ID 就是数据的唯一标识**。\n\n### 何为分布式 ID？\n\n分布式 ID 是分布式系统下的 ID。分布式 ID 不存在与现实生活中，属于计算机系统中的一个概念。\n\n我简单举一个分库分表的例子。\n\n我司的一个项目，使用的是单机 MySQL 。但是，没想到的是，项目上线一个月之后，随着使用人数越来越多，整个系统的数据量将越来越大。\n\n单机 MySQL 已经没办法支撑了，需要进行分库分表（推荐 Sharding-JDBC）。\n\n在分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。**我们如何为不同的数据节点生成全局唯一主键呢？**\n\n![](分布式ID.assets/up-d78d9d5362c71f4713a090baf7ec65d2b6d.png)\n\n这个时候就需要生成**分布式 ID**了。\n\n### 分布式 ID 需要满足哪些要求?\n\n![](分布式ID.assets/20210610082309988.png)\n\n分布式 ID 作为分布式系统中必不可少的一环，很多地方都要用到分布式 ID。\n\n一个最基本的分布式 ID 需要满足下面这些要求：\n\n- **全局唯一** ：ID 的全局唯一性肯定是首先要满足的！\n- **高性能** ： 分布式 ID 的生成速度要快，对本地资源消耗要小。\n- **高可用** ：生成分布式 ID 的服务要保证可用性无限接近于 100%。\n- **方便易用** ：拿来即用，使用方便，快速接入！\n\n除了这些之外，一个比较好的分布式 ID 还应保证：\n\n- **安全** ：ID 中不包含敏感信息。\n- **有序递增** ：如果要把 ID 存放在数据库的话，ID 的有序性可以提升数据库写入速度。并且，很多时候 ，我们还很有可能会直接通过 ID 来进行排序。\n- **有具体的业务含义** ：生成的 ID 如果能有具体的业务含义，可以让定位问题以及开发更透明化（通过 ID 就能确定是哪个业务）。\n- **独立部署** ：也就是分布式系统单独有一个发号器服务，专门用来生成分布式 ID。这样就生成 ID 的服务可以和业务相关的服务解耦。不过，这样同样带来了网络调用消耗增加的问题。总的来说，如果需要用到分布式 ID 的场景比较多的话，独立部署的发号器服务还是很有必要的。\n\n## 分布式 ID 常见解决方案\n\n### 数据库\n\n#### 数据库主键自增\n\n这种方式就比较简单直白了，就是通过关系型数据库的自增主键产生来唯一的 ID。\n\n![](分布式ID.assets/20210610081957287.png)\n\n以 MySQL 举例，我们通过下面的方式即可。\n\n**1.创建一个数据库表。**\n\n```sql\nCREATE TABLE `sequence_id` (\n  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,\n  `stub` char(10) NOT NULL DEFAULT '',\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `stub` (`stub`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n```\n\n`stub` 字段无意义，只是为了占位，便于我们插入或者修改数据。并且，给 `stub` 字段创建了唯一索引，保证其唯一性。\n\n**2.通过 `replace into` 来插入数据。**\n\n```java\nBEGIN;\nREPLACE INTO sequence_id (stub) VALUES ('stub');\nSELECT LAST_INSERT_ID();\nCOMMIT;\n```\n\n插入数据这里，我们没有使用 `insert into` 而是使用 `replace into` 来插入数据，具体步骤是这样的：\n\n1)第一步： 尝试把数据插入到表中。\n\n2)第二步： 如果主键或唯一索引字段出现重复数据错误而插入失败时，先从表中删除含有重复关键字值的冲突行，然后再次尝试把数据插入到表中。\n\n这种方式的优缺点也比较明显：\n\n- **优点** ：实现起来比较简单、ID 有序递增、存储消耗空间小\n- **缺点** ： 支持的并发量不大、存在数据库单点问题（可以使用数据库集群解决，不过增加了复杂度）、ID 没有具体业务含义、安全问题（比如根据订单 ID 的递增规律就能推算出每天的订单量，商业机密啊！ ）、每次获取 ID 都要访问一次数据库（增加了对数据库的压力，获取速度也慢）\n\n#### 数据库号段模式\n\n数据库主键自增这种模式，每次获取 ID 都要访问一次数据库，ID 需求比较大的时候，肯定是不行的。\n\n如果我们可以批量获取，然后存在在内存里面，需要用到的时候，直接从内存里面拿就舒服了！这也就是我们说的 **基于数据库的号段模式来生成分布式 ID。**\n\n数据库的号段模式也是目前比较主流的一种分布式 ID 生成方式。像滴滴开源的[Tinyid](https://github.com/didi/tinyid/wiki/tinyid%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D) 就是基于这种方式来做的。不过，TinyId 使用了双号段缓存、增加多 db 支持等方式来进一步优化。\n\n以 MySQL 举例，我们通过下面的方式即可。\n\n**1.创建一个数据库表。**\n\n```sql\nCREATE TABLE `sequence_id_generator` (\n  `id` int(10) NOT NULL,\n  `current_max_id` bigint(20) NOT NULL COMMENT '当前最大id',\n  `step` int(10) NOT NULL COMMENT '号段的长度',\n  `version` int(20) NOT NULL COMMENT '版本号',\n  `biz_type`    int(20) NOT NULL COMMENT '业务类型',\n   PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n```\n\n`current_max_id` 字段和`step`字段主要用于获取批量 ID，获取的批量 id 为： `current_max_id ~ current_max_id+step`。\n\n![](分布式ID.assets/20210610081149228.png)\n\n`version` 字段主要用于解决并发问题（乐观锁）,`biz_type` 主要用于表示业余类型。\n\n**2.先插入一行数据。**\n\n```sql\nINSERT INTO `sequence_id_generator` (`id`, `current_max_id`, `step`, `version`, `biz_type`)\nVALUES\n\t(1, 0, 100, 0, 101);\n```\n\n**3.通过 SELECT 获取指定业务下的批量唯一 ID**\n\n```sql\nSELECT `current_max_id`, `step`,`version` FROM `sequence_id_generator` where `biz_type` = 101\n```\n\n结果：\n\n```\nid\tcurrent_max_id\tstep\tversion\tbiz_type\n1\t0\t100\t1\t101\n```\n\n**4.不够用的话，更新之后重新 SELECT 即可。**\n\n```sql\nUPDATE sequence_id_generator SET current_max_id = 0+100, version=version+1 WHERE version = 0  AND `biz_type` = 101\nSELECT `current_max_id`, `step`,`version` FROM `sequence_id_generator` where `biz_type` = 101\n```\n\n结果：\n\n```\nid\tcurrent_max_id\tstep\tversion\tbiz_type\n1\t100\t100\t1\t101\n```\n\n相比于数据库主键自增的方式，**数据库的号段模式对于数据库的访问次数更少，数据库压力更小。**\n\n另外，为了避免单点问题，你可以从使用主从模式来提高可用性。\n\n**数据库号段模式的优缺点:**\n\n- **优点** ：ID 有序递增、存储消耗空间小\n- **缺点** ：存在数据库单点问题（可以使用数据库集群解决，不过增加了复杂度）、ID 没有具体业务含义、安全问题（比如根据订单 ID 的递增规律就能推算出每天的订单量，商业机密啊！ ）\n\n#### NoSQL\n\n![](分布式ID.assets/2021061008245858.png)\n\n一般情况下，NoSQL 方案使用 Redis 多一些。我们通过 Redis 的 `incr` 命令即可实现对 id 原子顺序递增。\n\n```bash\n127.0.0.1:6379> set sequence_id_biz_type 1\nOK\n127.0.0.1:6379> incr sequence_id_biz_type\n(integer) 2\n127.0.0.1:6379> get sequence_id_biz_type\n\"2\"\n```\n\n为了提高可用性和并发，我们可以使用 Redis Cluser。Redis Cluser 是 Redis 官方提供的 Redis 集群解决方案（3.0+版本）。\n\n除了 Redis Cluser 之外，你也可以使用开源的 Redis 集群方案[Codis](https://github.com/CodisLabs/codis) （大规模集群比如上百个节点的时候比较推荐）。\n\n除了高可用和并发之外，我们知道 Redis 基于内存，我们需要持久化数据，避免重启机器或者机器故障后数据丢失。Redis 支持两种不同的持久化方式：**快照（snapshotting，RDB）**、**只追加文件（append-only file, AOF）**。 并且，Redis 4.0 开始支持 **RDB 和 AOF 的混合持久化**（默认关闭，可以通过配置项 `aof-use-rdb-preamble` 开启）。\n\n关于 Redis 持久化，我这里就不过多介绍。不了解这部分内容的小伙伴，可以看看 [JavaGuide 对于 Redis 知识点的总结](https://snailclimb.gitee.io/javaguide/#/docs/database/Redis/redis-all)。\n\n**Redis 方案的优缺点：**\n\n- **优点** ： 性能不错并且生成的 ID 是有序递增的\n- **缺点** ： 和数据库主键自增方案的缺点类似\n\n除了 Redis 之外，MongoDB ObjectId 经常也会被拿来当做分布式 ID 的解决方案。\n\n![](分布式ID.assets/20210207103320582.png)\n\nMongoDB ObjectId 一共需要 12 个字节存储：\n\n- 0~3：时间戳\n- 3~6： 代表机器 ID\n- 7~8：机器进程 ID\n- 9~11 ：自增值\n\n**MongoDB 方案的优缺点：**\n\n- **优点** ： 性能不错并且生成的 ID 是有序递增的\n- **缺点** ： 需要解决重复 ID 问题（当机器时间不对的情况下，可能导致会产生重复 ID） 、有安全性问题（ID 生成有规律性）\n\n### 算法\n\n#### UUID\n\nUUID 是 Universally Unique Identifier（通用唯一标识符） 的缩写。UUID 包含 32 个 16 进制数字（8-4-4-4-12）。\n\nJDK 就提供了现成的生成 UUID 的方法，一行代码就行了。\n\n```java\n//输出示例：cb4a9ede-fa5e-4585-b9bb-d60bce986eaa\nUUID.randomUUID()\n```\n\n[RFC 4122](https://tools.ietf.org/html/rfc4122) 中关于 UUID 的示例是这样的：\n\n![](分布式ID.assets/20210202110824430.png)\n\n我们这里重点关注一下这个 Version(版本)，不同的版本对应的 UUID 的生成规则是不同的。\n\n5 种不同的 Version(版本)值分别对应的含义（参考[维基百科对于 UUID 的介绍](https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%A0%81)）：\n\n- **版本 1** : UUID 是根据时间和节点 ID（通常是 MAC 地址）生成；\n- **版本 2** : UUID 是根据标识符（通常是组或用户 ID）、时间和节点 ID 生成；\n- **版本 3、版本 5** : 版本 5 - 确定性 UUID 通过散列（hashing）名字空间（namespace）标识符和名称生成；\n- **版本 4** : UUID 使用[随机性](https://zh.wikipedia.org/wiki/随机性)或[伪随机性](https://zh.wikipedia.org/wiki/伪随机性)生成。\n\n下面是 Version 1 版本下生成的 UUID 的示例：\n\n![](分布式ID.assets/20210202113013477.png)\n\nJDK 中通过 `UUID` 的 `randomUUID()` 方法生成的 UUID 的版本默认为 4。\n\n```java\nUUID uuid = UUID.randomUUID();\nint version = uuid.version();// 4\n```\n\n另外，Variant(变体)也有 4 种不同的值，这种值分别对应不同的含义。这里就不介绍了，貌似平时也不怎么需要关注。\n\n需要用到的时候，去看看维基百科对于 UUID 的 Variant(变体) 相关的介绍即可。\n\n从上面的介绍中可以看出，UUID 可以保证唯一性，因为其生成规则包括 MAC 地址、时间戳、名字空间（Namespace）、随机或伪随机数、时序等元素，计算机基于这些规则生成的 UUID 是肯定不会重复的。\n\n虽然，UUID 可以做到全局唯一性，但是，我们一般很少会使用它。\n\n比如使用 UUID 作为 MySQL 数据库主键的时候就非常不合适：\n\n- 数据库主键要尽量越短越好，而 UUID 的消耗的存储空间比较大（32 个字符串，128 位）。\n- UUID 是无顺序的，InnoDB 引擎下，数据库主键的无序性会严重影响数据库性能。\n\n最后，我们再简单分析一下 **UUID 的优缺点** （面试的时候可能会被问到的哦！） :\n\n- **优点** ：生成速度比较快、简单易用\n- **缺点** ： 存储消耗空间大（32 个字符串，128 位） 、 不安全（基于 MAC 地址生成 UUID 的算法会造成 MAC 地址泄露)、无序（非自增）、没有具体业务含义、需要解决重复 ID 问题（当机器时间不对的情况下，可能导致会产生重复 ID）\n\n#### Snowflake(雪花算法)\n\nSnowflake 是 Twitter 开源的分布式 ID 生成算法。Snowflake 由 64 bit 的二进制数字组成，这 64bit 的二进制被分成了几部分，每一部分存储的数据都有特定的含义：\n\n- **第 0 位**： 符号位（标识正负），始终为 0，没有用，不用管。\n- **第 1~41 位** ：一共 41 位，用来表示时间戳，单位是毫秒，可以支撑 2 ^41 毫秒（约 69 年）\n- **第 42~52 位** ：一共 10 位，一般来说，前 5 位表示机房 ID，后 5 位表示机器 ID（实际项目中可以根据实际情况调整）。这样就可以区分不同集群/机房的节点。\n- **第 53~64 位** ：一共 12 位，用来表示序列号。 序列号为自增值，代表单台机器每毫秒能够产生的最大 ID 数(2^12 = 4096),也就是说单台机器每毫秒最多可以生成 4096 个 唯一 ID。\n\n![](分布式ID.assets/up-a7e54a77b5ab1d9fa16d5ae3a3c50c5aee9.png)\n\n如果你想要使用 Snowflake 算法的话，一般不需要你自己再造轮子。有很多基于 Snowflake 算法的开源实现比如美团 的 Leaf、百度的 UidGenerator，并且这些开源实现对原有的 Snowflake 算法进行了优化。\n\n另外，在实际项目中，我们一般也会对 Snowflake 算法进行改造，最常见的就是在 Snowflake 算法生成的 ID 中加入业务类型信息。\n\n我们再来看看 Snowflake 算法的优缺点 ：\n\n- **优点** ：生成速度比较快、生成的 ID 有序递增、比较灵活（可以对 Snowflake 算法进行简单的改造比如加入业务 ID）\n- **缺点** ： 需要解决重复 ID 问题（依赖时间，当机器时间不对的情况下，可能导致会产生重复 ID）。\n\n### 开源框架\n\n#### UidGenerator(百度)\n\n[UidGenerator](https://github.com/baidu/uid-generator) 是百度开源的一款基于 Snowflake(雪花算法)的唯一 ID 生成器。\n\n不过，UidGenerator 对 Snowflake(雪花算法)进行了改进，生成的唯一 ID 组成如下。\n\n![](分布式ID.assets/up-ad5b9dd0077a949db923611b2450277e406.png)\n\n可以看出，和原始 Snowflake(雪花算法)生成的唯一 ID 的组成不太一样。并且，上面这些参数我们都可以自定义。\n\nUidGenerator 官方文档中的介绍如下：\n\n![](分布式ID.assets/up-358b1a4cddb3675018b8595f66ece9cae88.png)\n\n自 18 年后，UidGenerator 就基本没有再维护了，我这里也不过多介绍。想要进一步了解的朋友，可以看看 [UidGenerator 的官方介绍](https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md)。\n\n#### Leaf(美团)\n\n**[Leaf](https://github.com/Meituan-Dianping/Leaf)** 是美团开源的一个分布式 ID 解决方案 。这个项目的名字 Leaf（树叶） 起源于德国哲学家、数学家莱布尼茨的一句话： “There are no two identical leaves in the world”（世界上没有两片相同的树叶） 。这名字起得真心挺不错的，有点文艺青年那味了！\n\n![](分布式ID.assets/20210422145229617.png)\n\nLeaf 提供了 **号段模式** 和 **Snowflake(雪花算法)** 这两种模式来生成分布式 ID。并且，它支持双号段，还解决了雪花 ID 系统时钟回拨问题。不过，时钟问题的解决需要弱依赖于 Zookeeper 。\n\nLeaf 的诞生主要是为了解决美团各个业务线生成分布式 ID 的方法多种多样以及不可靠的问题。\n\nLeaf 对原有的号段模式进行改进，比如它这里增加了双号段避免获取 DB 在获取号段的时候阻塞请求获取 ID 的线程。简单来说，就是我一个号段还没用完之前，我自己就主动提前去获取下一个号段（图片来自于美团官方文章：[《Leaf——美团点评分布式 ID 生成系统》](https://tech.meituan.com/2017/04/21/mt-leaf.html)）。\n\n![](分布式ID.assets/20210422144846724.png)\n\n根据项目 README 介绍，在 4C8G VM 基础上，通过公司 RPC 方式调用，QPS 压测结果近 5w/s，TP999 1ms。\n\n#### Tinyid(滴滴)\n\n[Tinyid](https://github.com/didi/tinyid) 是滴滴开源的一款基于数据库号段模式的唯一 ID 生成器。\n\n数据库号段模式的原理我们在上面已经介绍过了。**Tinyid 有哪些亮点呢？**\n\n为了搞清楚这个问题，我们先来看看基于数据库号段模式的简单架构方案。（图片来自于 Tinyid 的官方 wiki:[《Tinyid 原理介绍》](https://github.com/didi/tinyid/wiki/tinyid%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D)）\n\n![](分布式ID.assets/up-4afc0e45c0c86ba5ad645d023dce11e53c2.png)\n\n在这种架构模式下，我们通过 HTTP 请求向发号器服务申请唯一 ID。负载均衡 router 会把我们的请求送往其中的一台 tinyid-server。\n\n这种方案有什么问题呢？在我看来（Tinyid 官方 wiki 也有介绍到），主要由下面这 2 个问题：\n\n- 获取新号段的情况下，程序获取唯一 ID 的速度比较慢。\n- 需要保证 DB 高可用，这个是比较麻烦且耗费资源的。\n\n除此之外，HTTP 调用也存在网络开销。\n\nTinyid 的原理比较简单，其架构如下图所示：\n\n![](分布式ID.assets/up-53f74cd615178046d6c04fe50513fee74ce.png)\n\n相比于基于数据库号段模式的简单架构方案，Tinyid 方案主要做了下面这些优化：\n\n- **双号段缓存** ：为了避免在获取新号段的情况下，程序获取唯一 ID 的速度比较慢。 Tinyid 中的号段在用到一定程度的时候，就会去异步加载下一个号段，保证内存中始终有可用号段。\n- **增加多 db 支持** ：支持多个 DB，并且，每个 DB 都能生成唯一 ID，提高了可用性。\n- **增加 tinyid-client** ：纯本地操作，无 HTTP 请求消耗，性能和可用性都有很大提升。\n\nTinyid 的优缺点这里就不分析了，结合数据库号段模式的优缺点和 Tinyid 的原理就能知道。\n\n## 分布式 ID 生成方案总结\n\n这篇文章中，我基本上已经把最常见的分布式 ID 生成方案都总结了一波。\n\n除了上面介绍的方式之外，像 ZooKeeper 这类中间件也可以帮助我们生成唯一 ID。**没有银弹，一定要结合实际项目来选择最适合自己的方案。**"},ec20:function(n,e,t){"use strict";t.r(e),e["default"]='\n\x3c!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} --\x3e\n\n\x3c!-- code_chunk_output --\x3e\n\n- [1. 前言](#1-前言)\n- [2. ZooKeeper 安装和使用](#2-zookeeper-安装和使用)\n  - [2.1. 使用Docker 安装 zookeeper](#21-使用docker-安装-zookeeper)\n  - [2.2. 连接 ZooKeeper 服务](#22-连接-zookeeper-服务)\n  - [2.3. 常用命令演示](#23-常用命令演示)\n    - [2.3.1. 查看常用命令(help 命令)](#231-查看常用命令help-命令)\n    - [2.3.2. 创建节点(create 命令)](#232-创建节点create-命令)\n    - [2.3.3. 更新节点数据内容(set 命令)](#233-更新节点数据内容set-命令)\n    - [2.3.4. 获取节点的数据(get 命令)](#234-获取节点的数据get-命令)\n    - [2.3.5. 查看某个目录下的子节点(ls 命令)](#235-查看某个目录下的子节点ls-命令)\n    - [2.3.6. 查看节点状态(stat 命令)](#236-查看节点状态stat-命令)\n    - [2.3.7. 查看节点信息和状态(ls2 命令)](#237-查看节点信息和状态ls2-命令)\n    - [2.3.8. 删除节点(delete 命令)](#238-删除节点delete-命令)\n- [3. ZooKeeper Java客户端 Curator简单使用](#3-zookeeper-java客户端-curator简单使用)\n  - [3.1. 连接 ZooKeeper 客户端](#31-连接-zookeeper-客户端)\n  - [3.2. 数据节点的增删改查](#32-数据节点的增删改查)\n    - [3.2.1. 创建节点](#321-创建节点)\n    - [3.2.2. 删除节点](#322-删除节点)\n    - [3.2.3. 获取/更新节点数据内容](#323-获取更新节点数据内容)\n    - [3.2.4. 获取某个节点的所有子节点路径](#324-获取某个节点的所有子节点路径)\n\n\x3c!-- /code_chunk_output --\x3e\n\n\n## 1. 前言\n\n这篇文章简单给演示一下 ZooKeeper 常见命令的使用以及 ZooKeeper Java客户端 Curator 的基本使用。介绍到的内容都是最基本的操作，能满足日常工作的基本需要。\n\n如果文章有任何需要改善和完善的地方，欢迎在评论区指出，共同进步！\n\n## 2. ZooKeeper 安装和使用\n\n### 2.1. 使用Docker 安装 zookeeper\n\n**a.使用 Docker 下载 ZooKeeper**\n\n```shell\ndocker pull zookeeper:3.5.8\n```\n\n**b.运行 ZooKeeper**\n\n```shell\ndocker run -d --name zookeeper -p 2181:2181 zookeeper:3.5.8\n```\n\n### 2.2. 连接 ZooKeeper 服务\n\n**a.进入ZooKeeper容器中**\n\n先使用 `docker ps` 查看 ZooKeeper 的 ContainerID，然后使用 `docker exec -it ContainerID /bin/bash` 命令进入容器中。\n\n**b.先进入 bin 目录,然后通过  `./zkCli.sh -server 127.0.0.1:2181`命令连接ZooKeeper 服务**\n\n```bash\nroot@eaf70fc620cb:/apache-zookeeper-3.5.8-bin# cd bin\n```\n\n如果你看到控制台成功打印出如下信息的话，说明你已经成功连接 ZooKeeper 服务。\n\n![](zookeeper-in-action.assets/连接ZooKeeper服务.png)\n\n### 2.3. 常用命令演示\n\n#### 2.3.1. 查看常用命令(help 命令)\n\n通过 `help` 命令查看 ZooKeeper 常用命令\n\n#### 2.3.2. 创建节点(create 命令)\n\n通过 `create` 命令在根目录创建了 node1 节点，与它关联的字符串是"node1"\n\n```shell\n[zk: 127.0.0.1:2181(CONNECTED) 34] create /node1 “node1”\n```\n\n通过 `create` 命令在根目录创建了 node1 节点，与它关联的内容是数字 123\n\n```shell\n[zk: 127.0.0.1:2181(CONNECTED) 1] create /node1/node1.1 123\nCreated /node1/node1.1\n```\n\n#### 2.3.3. 更新节点数据内容(set 命令)\n\n```shell\n[zk: 127.0.0.1:2181(CONNECTED) 11] set /node1 "set node1"\n```\n\n#### 2.3.4. 获取节点的数据(get 命令)\n\n`get` 命令可以获取指定节点的数据内容和节点的状态,可以看出我们通过 `set` 命令已经将节点数据内容改为 "set node1"。\n\n```shell\nset node1\ncZxid = 0x47\nctime = Sun Jan 20 10:22:59 CST 2019\nmZxid = 0x4b\nmtime = Sun Jan 20 10:41:10 CST 2019\npZxid = 0x4a\ncversion = 1\ndataVersion = 1\naclVersion = 0\nephemeralOwner = 0x0\ndataLength = 9\nnumChildren = 1\n\n```\n\n#### 2.3.5. 查看某个目录下的子节点(ls 命令)\n\n通过 `ls` 命令查看根目录下的节点\n\n```shell\n[zk: 127.0.0.1:2181(CONNECTED) 37] ls /\n[dubbo, ZooKeeper, node1]\n```\n\n通过 `ls` 命令查看 node1 目录下的节点\n\n```shell\n[zk: 127.0.0.1:2181(CONNECTED) 5] ls /node1\n[node1.1]\n```\n\nZooKeeper 中的 ls 命令和 linux 命令中的 ls 类似， 这个命令将列出绝对路径 path 下的所有子节点信息（列出 1 级，并不递归）\n\n#### 2.3.6. 查看节点状态(stat 命令)\n\n通过 `stat` 命令查看节点状态\n\n```shell\n[zk: 127.0.0.1:2181(CONNECTED) 10] stat /node1\ncZxid = 0x47\nctime = Sun Jan 20 10:22:59 CST 2019\nmZxid = 0x47\nmtime = Sun Jan 20 10:22:59 CST 2019\npZxid = 0x4a\ncversion = 1\ndataVersion = 0\naclVersion = 0\nephemeralOwner = 0x0\ndataLength = 11\nnumChildren = 1\n```\n\n上面显示的一些信息比如 cversion、aclVersion、numChildren 等等，我在上面 “znode(数据节点)的结构” 这部分已经介绍到。\n\n#### 2.3.7. 查看节点信息和状态(ls2 命令)\n\n`ls2` 命令更像是  `ls` 命令和 `stat` 命令的结合。 `ls2` 命令返回的信息包括 2 部分：\n\n1. 子节点列表 \n2. 当前节点的 stat 信息。\n\n```shell\n[zk: 127.0.0.1:2181(CONNECTED) 7] ls2 /node1\n[node1.1]\ncZxid = 0x47\nctime = Sun Jan 20 10:22:59 CST 2019\nmZxid = 0x47\nmtime = Sun Jan 20 10:22:59 CST 2019\npZxid = 0x4a\ncversion = 1\ndataVersion = 0\naclVersion = 0\nephemeralOwner = 0x0\ndataLength = 11\nnumChildren = 1\n\n```\n\n#### 2.3.8. 删除节点(delete 命令)\n\n这个命令很简单，但是需要注意的一点是如果你要删除某一个节点，那么这个节点必须无子节点才行。\n\n```shell\n[zk: 127.0.0.1:2181(CONNECTED) 3] delete /node1/node1.1\n```\n\n在后面我会介绍到 Java 客户端 API 的使用以及开源 ZooKeeper 客户端 ZkClient 和 Curator 的使用。\n\n## 3. ZooKeeper Java客户端 Curator简单使用\n\nCurator 是Netflix公司开源的一套 ZooKeeper Java客户端框架，相比于 Zookeeper 自带的客户端 zookeeper 来说，Curator 的封装更加完善，各种 API 都可以比较方便地使用。\n\n![](zookeeper-in-action.assets/curator.png)\n\n下面我们就来简单地演示一下 Curator 的使用吧！\n\nCurator4.0+版本对ZooKeeper 3.5.x支持比较好。开始之前，请先将下面的依赖添加进你的项目。\n\n```xml\n<dependency>\n    <groupId>org.apache.curator</groupId>\n    <artifactId>curator-framework</artifactId>\n    <version>4.2.0</version>\n</dependency>\n<dependency>\n    <groupId>org.apache.curator</groupId>\n    <artifactId>curator-recipes</artifactId>\n    <version>4.2.0</version>\n</dependency>\n```\n\n### 3.1. 连接 ZooKeeper 客户端\n\n通过 `CuratorFrameworkFactory` 创建 `CuratorFramework` 对象，然后再调用  `CuratorFramework` 对象的 `start()` 方法即可！\n\n```java\nprivate static final int BASE_SLEEP_TIME = 1000;\nprivate static final int MAX_RETRIES = 3;\n\n// Retry strategy. Retry 3 times, and will increase the sleep time between retries.\nRetryPolicy retryPolicy = new ExponentialBackoffRetry(BASE_SLEEP_TIME, MAX_RETRIES);\nCuratorFramework zkClient = CuratorFrameworkFactory.builder()\n    // the server to connect to (can be a server list)\n    .connectString("127.0.0.1:2181")\n    .retryPolicy(retryPolicy)\n    .build();\nzkClient.start();\n```\n\n对于一些基本参数的说明：\n\n- `baseSleepTimeMs`：重试之间等待的初始时间\n- `maxRetries` ：最大重试次数\n- `connectString` ：要连接的服务器列表\n- `retryPolicy` ：重试策略\n\n### 3.2. 数据节点的增删改查\n\n#### 3.2.1. 创建节点\n\n我们在 [ZooKeeper常见概念解读](./zookeeper-intro.md) 中介绍到，我们通常是将 znode 分为 4 大类：\n\n- **持久（PERSISTENT）节点** ：一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。\n- **临时（EPHEMERAL）节点** ：临时节点的生命周期是与 **客户端会话（session）** 绑定的，**会话消失则节点消失** 。并且，临时节点 **只能做叶子节点** ，不能创建子节点。\n- **持久顺序（PERSISTENT_SEQUENTIAL）节点** ：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 `/node1/app0000000001` 、`/node1/app0000000002` 。\n- **临时顺序（EPHEMERAL_SEQUENTIAL）节点** ：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。\n\n你在使用的ZooKeeper 的时候，会发现  `CreateMode` 类中实际有 7种 znode 类型 ，但是用的最多的还是上面介绍的 4 种。\n\n**a.创建持久化节点**\n\n你可以通过下面两种方式创建持久化的节点。\n\n```java\n//注意:下面的代码会报错，下文说了具体原因\nzkClient.create().forPath("/node1/00001");\nzkClient.create().withMode(CreateMode.PERSISTENT).forPath("/node1/00002");\n```\n\n但是，你运行上面的代码会报错，这是因为的父节点`node1`还未创建。\n\n你可以先创建父节点 `node1` ，然后再执行上面的代码就不会报错了。\n\n```java\nzkClient.create().forPath("/node1");\n```\n\n更推荐的方式是通过下面这行代码， **`creatingParentsIfNeeded()` 可以保证父节点不存在的时候自动创建父节点，这是非常有用的。**\n\n```java\nzkClient.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath("/node1/00001");\n```\n\n**b.创建临时节点**\n\n```java\nzkClient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath("/node1/00001");\n```\n\n**c.创建节点并指定数据内容**\n\n```java\nzkClient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath("/node1/00001","java".getBytes());\nzkClient.getData().forPath("/node1/00001");//获取节点的数据内容，获取到的是 byte数组\n```\n\n**d.检测节点是否创建成功**\n\n```java\nzkClient.checkExists().forPath("/node1/00001");//不为null的话，说明节点创建成功\n```\n\n#### 3.2.2. 删除节点\n\n**a.删除一个子节点**\n\n```java\nzkClient.delete().forPath("/node1/00001");\n```\n\n**b.删除一个节点以及其下的所有子节点**\n\n```java\nzkClient.delete().deletingChildrenIfNeeded().forPath("/node1");\n```\n\n#### 3.2.3. 获取/更新节点数据内容\n\n```java\nzkClient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath("/node1/00001","java".getBytes());\nzkClient.getData().forPath("/node1/00001");//获取节点的数据内容\nzkClient.setData().forPath("/node1/00001","c++".getBytes());//更新节点数据内容\n```\n\n#### 3.2.4. 获取某个节点的所有子节点路径\n\n```java\nList<String> childrenPaths = zkClient.getChildren().forPath("/node1");\n```\n\n\n\n\n\n'},ee72:function(n,e,t){"use strict";t.r(e),e["default"]='这篇文章我根据《阿里巴巴 Java 开发手册》总结了关于集合使用常见的注意事项以及其具体原理。\n\n强烈建议小伙伴们多多阅读几遍，避免自己写代码的时候出现这些低级的问题。\n\n## 集合判空\n\n《阿里巴巴 Java 开发手册》的描述如下：\n\n> **判断所有集合内部的元素是否为空，使用 `isEmpty()` 方法，而不是 `size()==0` 的方式。**\n\n这是因为 `isEmpty()` 方法的可读性更好，并且时间复杂度为 O(1)。\n\n绝大部分我们使用的集合的 `size()` 方法的时间复杂度也是 O(1)，不过，也有很多复杂度不是 O(1) 的，比如 `java.util.concurrent` 包下的某些集合（`ConcurrentLinkedQueue` 、`ConcurrentHashMap`...）。\n\n下面是 `ConcurrentHashMap` 的 `size()` 方法和 `isEmpty()` 方法的源码。\n\n```java\npublic int size() {\n    long n = sumCount();\n    return ((n < 0L) ? 0 :\n            (n > (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :\n            (int)n);\n}\nfinal long sumCount() {\n    CounterCell[] as = counterCells; CounterCell a;\n    long sum = baseCount;\n    if (as != null) {\n        for (int i = 0; i < as.length; ++i) {\n            if ((a = as[i]) != null)\n                sum += a.value;\n        }\n    }\n    return sum;\n}\npublic boolean isEmpty() {\n    return sumCount() <= 0L; // ignore transient negative values\n}\n```\n\n## 集合转 Map\n\n《阿里巴巴 Java 开发手册》的描述如下：\n\n> **在使用 `java.util.stream.Collectors` 类的 `toMap()` 方法转为 `Map` 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。**\n\n```java\nclass Person {\n    private String name;\n    private String phoneNumber;\n     // getters and setters\n}\n\nList<Person> bookList = new ArrayList<>();\nbookList.add(new Person("jack","18163138123"));\nbookList.add(new Person("martin",null));\n// 空指针异常\nbookList.stream().collect(Collectors.toMap(Person::getName, Person::getPhoneNumber));\n```\n\n下面我们来解释一下原因。\n\n首先，我们来看 `java.util.stream.Collectors` 类的 `toMap()` 方法 ，可以看到其内部调用了 `Map` 接口的 `merge()` 方法。\n\n```java\npublic static <T, K, U, M extends Map<K, U>>\nCollector<T, ?, M> toMap(Function<? super T, ? extends K> keyMapper,\n                            Function<? super T, ? extends U> valueMapper,\n                            BinaryOperator<U> mergeFunction,\n                            Supplier<M> mapSupplier) {\n    BiConsumer<M, T> accumulator\n            = (map, element) -> map.merge(keyMapper.apply(element),\n                                          valueMapper.apply(element), mergeFunction);\n    return new CollectorImpl<>(mapSupplier, accumulator, mapMerger(mergeFunction), CH_ID);\n}\n```\n\n`Map` 接口的 `merge()` 方法如下，这个方法是接口中的默认实现。\n\n> 如果你还不了解 Java 8 新特性的话，请看这篇文章：[《Java8 新特性总结》](https://mp.weixin.qq.com/s/ojyl7B6PiHaTWADqmUq2rw) 。\n\n```java\ndefault V merge(K key, V value,\n        BiFunction<? super V, ? super V, ? extends V> remappingFunction) {\n    Objects.requireNonNull(remappingFunction);\n    Objects.requireNonNull(value);\n    V oldValue = get(key);\n    V newValue = (oldValue == null) ? value :\n               remappingFunction.apply(oldValue, value);\n    if(newValue == null) {\n        remove(key);\n    } else {\n        put(key, newValue);\n    }\n    return newValue;\n}\n```\n\n`merge()` 方法会先调用 `Objects.requireNonNull()` 方法判断 value 是否为空。\n\n```java\npublic static <T> T requireNonNull(T obj) {\n    if (obj == null)\n        throw new NullPointerException();\n    return obj;\n}\n```\n\n## 集合遍历\n\n《阿里巴巴 Java 开发手册》的描述如下：\n\n> **不要在 foreach 循环里进行元素的 `remove/add` 操作。remove 元素请使用 `Iterator` 方式，如果并发操作，需要对 `Iterator` 对象加锁。**\n\n通过反编译你会发现 foreach 语法糖底层其实还是依赖 `Iterator` 。不过， `remove/add` 操作直接调用的是集合自己的方法，而不是 `Iterator` 的 `remove/add`方法\n\n这就导致 `Iterator` 莫名其妙地发现自己有元素被 `remove/add` ，然后，它就会抛出一个 `ConcurrentModificationException` 来提示用户发生了并发修改异常。这就是单线程状态下产生的 **fail-fast 机制**。\n\n> **fail-fast 机制** ：多个线程对 fail-fast 集合进行修改的时候，可能会抛出`ConcurrentModificationException`。 即使是单线程下也有可能会出现这种情况，上面已经提到过。\n\nJava8 开始，可以使用 `Collection#removeIf()`方法删除满足特定条件的元素,如\n\n```java\nList<Integer> list = new ArrayList<>();\nfor (int i = 1; i <= 10; ++i) {\n    list.add(i);\n}\nlist.removeIf(filter -> filter % 2 == 0); /* 删除list中的所有偶数 */\nSystem.out.println(list); /* [1, 3, 5, 7, 9] */\n```\n\n除了上面介绍的直接使用 `Iterator` 进行遍历操作之外，你还可以：\n\n- 使用普通的 for 循环\n- 使用 fail-safe 的集合类。`java.util`包下面的所有的集合类都是 fail-fast 的，而`java.util.concurrent`包下面的所有的类都是 fail-safe 的。\n- ......\n\n## 集合去重\n\n《阿里巴巴 Java 开发手册》的描述如下：\n\n> **可以利用 `Set` 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 `List` 的 `contains()` 进行遍历去重或者判断包含操作。**\n\n这里我们以 `HashSet` 和 `ArrayList` 为例说明。\n\n```java\n// Set 去重代码示例\npublic static <T> Set<T> removeDuplicateBySet(List<T> data) {\n\n    if (CollectionUtils.isEmpty(data)) {\n        return new HashSet<>();\n    }\n    return new HashSet<>(data);\n}\n\n// List 去重代码示例\npublic static <T> List<T> removeDuplicateByList(List<T> data) {\n\n    if (CollectionUtils.isEmpty(data)) {\n        return new ArrayList<>();\n\n    }\n    List<T> result = new ArrayList<>(data.size());\n    for (T current : data) {\n        if (!result.contains(current)) {\n            result.add(current);\n        }\n    }\n    return result;\n}\n\n```\n\n两者的核心差别在于 `contains()` 方法的实现。\n\n`HashSet` 的 `contains()` 方法底部依赖的 `HashMap` 的 `containsKey()` 方法，时间复杂度接近于 O（1）（没有出现哈希冲突的时候为 O（1））。\n\n```java\nprivate transient HashMap<E,Object> map;\npublic boolean contains(Object o) {\n    return map.containsKey(o);\n}\n```\n\n我们有 N 个元素插入进 Set 中，那时间复杂度就接近是 O (n)。\n\n`ArrayList` 的 `contains()` 方法是通过遍历所有元素的方法来做的，时间复杂度接近是 O(n)。\n\n```java\npublic boolean contains(Object o) {\n    return indexOf(o) >= 0;\n}\npublic int indexOf(Object o) {\n    if (o == null) {\n        for (int i = 0; i < size; i++)\n            if (elementData[i]==null)\n                return i;\n    } else {\n        for (int i = 0; i < size; i++)\n            if (o.equals(elementData[i]))\n                return i;\n    }\n    return -1;\n}\n\n```\n\n我们的 `List` 有 N 个元素，那时间复杂度就接近是 O (n^2)。\n\n## 集合转数组\n\n《阿里巴巴 Java 开发手册》的描述如下：\n\n> **使用集合转数组的方法，必须使用集合的 `toArray(T[] array)`，传入的是类型完全一致、长度为 0 的空数组。**\n\n`toArray(T[] array)` 方法的参数是一个泛型数组，如果 `toArray` 方法中没有传递任何参数的话返回的是 `Object`类 型数组。\n\n```java\nString [] s= new String[]{\n    "dog", "lazy", "a", "over", "jumps", "fox", "brown", "quick", "A"\n};\nList<String> list = Arrays.asList(s);\nCollections.reverse(list);\n//没有指定类型的话会报错\ns=list.toArray(new String[0]);\n```\n\n由于 JVM 优化，`new String[0]`作为`Collection.toArray()`方法的参数现在使用更好，`new String[0]`就是起一个模板的作用，指定了返回数组的类型，0 是为了节省空间，因为它只是为了说明返回的类型。详见：<https://shipilev.net/blog/2016/arrays-wisdom-ancients/>\n\n## 数组转集合\n\n《阿里巴巴 Java 开发手册》的描述如下：\n\n> **使用工具类 `Arrays.asList()` 把数组转换成集合时，不能使用其修改集合相关的方法， 它的 `add/remove/clear` 方法会抛出 `UnsupportedOperationException` 异常。**\n\n我在之前的一个项目中就遇到一个类似的坑。\n\n`Arrays.asList()`在平时开发中还是比较常见的，我们可以使用它将一个数组转换为一个 `List` 集合。\n\n```java\nString[] myArray = {"Apple", "Banana", "Orange"};\nList<String> myList = Arrays.asList(myArray);\n//上面两个语句等价于下面一条语句\nList<String> myList = Arrays.asList("Apple","Banana", "Orange");\n```\n\nJDK 源码对于这个方法的说明：\n\n```java\n/**\n  *返回由指定数组支持的固定大小的列表。此方法作为基于数组和基于集合的API之间的桥梁，\n  * 与 Collection.toArray()结合使用。返回的List是可序列化并实现RandomAccess接口。\n  */\npublic static <T> List<T> asList(T... a) {\n    return new ArrayList<>(a);\n}\n```\n\n下面我们来总结一下使用注意事项。\n\n**1、`Arrays.asList()`是泛型方法，传递的数组必须是对象数组，而不是基本类型。**\n\n```java\nint[] myArray = {1, 2, 3};\nList myList = Arrays.asList(myArray);\nSystem.out.println(myList.size());//1\nSystem.out.println(myList.get(0));//数组地址值\nSystem.out.println(myList.get(1));//报错：ArrayIndexOutOfBoundsException\nint[] array = (int[]) myList.get(0);\nSystem.out.println(array[0]);//1\n```\n\n当传入一个原生数据类型数组时，`Arrays.asList()` 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时 `List` 的唯一元素就是这个数组，这也就解释了上面的代码。\n\n我们使用包装类型数组就可以解决这个问题。\n\n```java\nInteger[] myArray = {1, 2, 3};\n```\n\n**2、使用集合的修改方法: `add()`、`remove()`、`clear()`会抛出异常。**\n\n```java\nList myList = Arrays.asList(1, 2, 3);\nmyList.add(4);//运行时报错：UnsupportedOperationException\nmyList.remove(1);//运行时报错：UnsupportedOperationException\nmyList.clear();//运行时报错：UnsupportedOperationException\n```\n\n`Arrays.asList()` 方法返回的并不是 `java.util.ArrayList` ，而是 `java.util.Arrays` 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。\n\n```java\nList myList = Arrays.asList(1, 2, 3);\nSystem.out.println(myList.getClass());//class java.util.Arrays$ArrayList\n```\n\n下图是 `java.util.Arrays$ArrayList` 的简易源码，我们可以看到这个类重写的方法有哪些。\n\n```java\n  private static class ArrayList<E> extends AbstractList<E>\n        implements RandomAccess, java.io.Serializable\n    {\n        ...\n\n        @Override\n        public E get(int index) {\n          ...\n        }\n\n        @Override\n        public E set(int index, E element) {\n          ...\n        }\n\n        @Override\n        public int indexOf(Object o) {\n          ...\n        }\n\n        @Override\n        public boolean contains(Object o) {\n           ...\n        }\n\n        @Override\n        public void forEach(Consumer<? super E> action) {\n          ...\n        }\n\n        @Override\n        public void replaceAll(UnaryOperator<E> operator) {\n          ...\n        }\n\n        @Override\n        public void sort(Comparator<? super E> c) {\n          ...\n        }\n    }\n```\n\n我们再看一下`java.util.AbstractList`的 `add/remove/clear` 方法就知道为什么会抛出 `UnsupportedOperationException` 了。\n\n```java\npublic E remove(int index) {\n    throw new UnsupportedOperationException();\n}\npublic boolean add(E e) {\n    add(size(), e);\n    return true;\n}\npublic void add(int index, E element) {\n    throw new UnsupportedOperationException();\n}\n\npublic void clear() {\n    removeRange(0, size());\n}\nprotected void removeRange(int fromIndex, int toIndex) {\n    ListIterator<E> it = listIterator(fromIndex);\n    for (int i=0, n=toIndex-fromIndex; i<n; i++) {\n        it.next();\n        it.remove();\n    }\n}\n```\n\n**那我们如何正确的将数组转换为 `ArrayList` ?**\n\n1、手动实现工具类\n\n```java\n//JDK1.5+\nstatic <T> List<T> arrayToList(final T[] array) {\n  final List<T> l = new ArrayList<T>(array.length);\n\n  for (final T s : array) {\n    l.add(s);\n  }\n  return l;\n}\n\n\nInteger [] myArray = { 1, 2, 3 };\nSystem.out.println(arrayToList(myArray).getClass());//class java.util.ArrayList\n```\n\n2、最简便的方法\n\n```java\nList list = new ArrayList<>(Arrays.asList("a", "b", "c"))\n```\n\n3、使用 Java8 的 `Stream`(推荐)\n\n```java\nInteger [] myArray = { 1, 2, 3 };\nList myList = Arrays.stream(myArray).collect(Collectors.toList());\n//基本类型也可以实现转换（依赖boxed的装箱操作）\nint [] myArray2 = { 1, 2, 3 };\nList myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());\n```\n\n4、使用 Guava\n\n对于不可变集合，你可以使用[`ImmutableList`](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java)类及其[`of()`](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L101)与[`copyOf()`](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L225)工厂方法：（参数不能为空）\n\n```java\nList<String> il = ImmutableList.of("string", "elements");  // from varargs\nList<String> il = ImmutableList.copyOf(aStringArray);      // from array\n```\n\n对于可变集合，你可以使用[`Lists`](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java)类及其[`newArrayList()`](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java#L87)工厂方法：\n\n```java\nList<String> l1 = Lists.newArrayList(anotherListOrCollection);    // from collection\nList<String> l2 = Lists.newArrayList(aStringArray);               // from array\nList<String> l3 = Lists.newArrayList("or", "string", "elements"); // from varargs\n```\n\n5、使用 Apache Commons Collections\n\n```java\nList<String> list = new ArrayList<String>();\nCollectionUtils.addAll(list, str);\n```\n\n6、 使用 Java9 的 `List.of()`方法\n\n```java\nInteger[] array = {1, 2, 3};\nList<Integer> list = List.of(array);\n```'},eeb7:function(n,e,t){var r={"./JDBC-01-授课笔记.md":"f112","./JDBC-02-授课笔记.md":"4ca9"};function a(n){var e=i(n);return t(e)}function i(n){if(!t.o(r,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return r[n]}a.keys=function(){return Object.keys(r)},a.resolve=i,n.exports=a,a.id="eeb7"},ef4a:function(n,e,t){"use strict";t.r(e),e["default"]='## 1.Debug模式\r\n\r\n### 1.1 什么是Debug模式\r\n\r\n是供程序员使用的程序调试工具，它可以用于查看程序的执行流程，也可以用于追踪程序执行过程来调试程序。\r\n\r\n### 1.2 Debug介绍与操作流程\r\n\r\n- 如何加断点\r\n\r\n  - 选择要设置断点的代码行，在行号的区域后面单击鼠标左键即可\r\n\r\n- 如何运行加了断点的程序\r\n\r\n  - 在代码区域右键Debug执行\r\n\r\n- 看哪里\r\n\r\n  - 看Debugger窗口\r\n\r\n  - 看Console窗口\r\n\r\n- 点哪里\r\n\r\n  - 点Step Into (F7)这个箭头，也可以直接按F7\r\n\r\n- 如何删除断点\r\n\r\n  - 选择要删除的断点，单击鼠标左键即可\r\n\r\n  - 如果是多个断点，可以每一个再点击一次。也可以一次性全部删除\r\n\r\n\r\n## 2. 进制的介绍与书写格式\r\n\r\n### 2.1 进制的介绍与书写格式\r\n\r\n代码 : \r\n\r\n```java\r\npublic class Demo1 {\r\n    /*\r\n        十进制：Java中，数值默认都是10进制，不需要加任何修饰。\r\n        二进制：数值前面以0b开头，b大小写都可以。\r\n        八进制：数值前面以0开头。\r\n        十六进制：数值前面以0x开头，x大小写都可以。\r\n\r\n        注意: 书写的时候, 虽然加入了进制的标识, 但打印在控制台展示的都是十进制数据.\r\n     */\r\n    public static void main(String[] args) {\r\n        System.out.println(10);\r\n        System.out.println("二进制数据0b10的十进制表示为:" + 0b10);\r\n        System.out.println("八进制数据010的十进制表示为:" + 010);\r\n        System.out.println("十六进制数据0x10的十进制表示为:" + 0x10);\r\n    }\r\n}\r\n```\r\n\r\n### 2.2 任意进制到十进制的转换\r\n\r\n![1590937009286](./day06-Debug&基础练习.img/1590937009286.png)\r\n\r\n![1590937024104](./day06-Debug&基础练习.img/1590937024104.png) \r\n\r\n\r\n\r\n\r\n\r\n### 2.3 进制转换-十进制到任意进制转换\r\n\r\n​\t**2.3.1 : 十进制到二进制的转换**\r\n\r\n​\t公式：除基取余使用源数据，不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着拼起来即可。\r\n\r\n​\t需求：将十进制数字11，转换为2进制。\r\n\r\n​\t实现方式：源数据为11，使用11不断的除以基数，也就是2，直到商为0。\r\n\r\n![1590936221838](./day06-Debug&基础练习.img/1590936221838.png)\r\n\r\n​\t**2.3.2 : 十进制到十六进制的转换**\r\n\r\n​\t公式：除基取余使用源数据，不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着拼起来即可。\r\n\r\n​\t需求：将十进制数字60，转换为16进制。\r\n\r\n​\t实现方式：源数据为60，使用60不断的除以基数，也就是16，直到商为0。\r\n\r\n![1590936342865](./day06-Debug&基础练习.img/1590936342865.png)\r\n\r\n​\t结论：十进制到任意进制的转换\r\n\r\n​\t公式：除基取余使用源数据，不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着\t拼起来即可\r\n\r\n### 2.4  快速进制转换法\r\n\r\n​\t8421码：\r\n\r\n​\t8421码又称BCD码，是BCD代码中最常用的一种BCD： (Binary-Coded Decimal‎) 二进制码十进制数在这种编码方式中，每一位二进制值的1都是代表一个固定数值，把每一位的1代表的十进制数加起来得到的结果就是它所代表的十进制数。\r\n\r\n​\t![1590936493344](./day06-Debug&基础练习.img/1590936493344.png)\r\n\r\n\r\n\r\n![1590936529957](./day06-Debug&基础练习.img/1590936529957.png)\r\n\r\n![1590936548060](./day06-Debug&基础练习.img/1590936548060.png)\r\n\r\n### 2.5  原码反码补码\r\n\r\n前言 : 计算机中的数据，都是以二进制补码的形式在运算，而补码则是通过反码和原码推算出来的\r\n\r\n**原码 **:（可直观看出数据大小）\r\n\r\n就是二进制定点表示法，即最高位为符号位，【0】表示正，【1】表示负，其余位表示数值的大小。\r\n\r\n通过一个字节表示+7和-7，代码：byte b1 = 7;   byte b2 = -7;一个字节等于8个比特位，也就是8个二进制位\t\r\n\r\n0(符号位)\t0000111 \t\r\n\r\n1(符号位)\t0000111\r\n\r\n**反码 :** 正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。\r\n\r\n**补码 :** （数据以该状态进行运算）正数的补码与其原码相同；负数的补码是在其反码的末位加1。\r\n\r\n\r\n\r\n![1590936726746](./day06-Debug&基础练习.img/1590936726746.png)\r\n\r\n![1590936745245](./day06-Debug&基础练习.img/1590936745245.png)\r\n\r\n\r\n\r\n### 2.6 位运算-基本位运算符\r\n\r\n```java\r\npackage com.itheima.demo;\r\n\r\npublic class Demo2 {\r\n    /*\r\n        位运算:\r\n\r\n            位运算符指的是二进制位的运算，先将十进制数转成二进制后再进行运算。\r\n            在二进制位运算中，1表示true，0表示false。\r\n\r\n             & 位与 : 遇false则false, 遇0则0\r\n\r\n                        00000000 00000000 00000000 00000110     // 6的二进制\r\n                     &  00000000 00000000 00000000 00000010     // 2的二进制\r\n                    -----------------------------------------\r\n                        00000000 00000000 00000000 00000010     // 结果: 2\r\n\r\n             | 位或 : 遇true则true, 遇1则1\r\n\r\n             ^ 位异或 : 相同为false, 不同为true\r\n\r\n             ~ 取反 : 全部取反, 0变1, 1变0  (也包括符号位)\r\n\r\n                    00000000 00000000 00000000 00000110         // 6的二进制补码\r\n                  ~ 11111111 11111111 11111111 11111001\r\n\r\n                  -                                   1         // -1求反码\r\n                   ------------------------------------\r\n                    11111111 11111111 11111111 11111000         // 反码推原码\r\n\r\n                    10000000 00000000 00000000 00000111         // -7\r\n     */\r\n    public static void main(String[] args) {\r\n        System.out.println(6 & 2);\r\n        System.out.println(~6);\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n### 2.7 位运算-位移运算符\r\n\r\n**位运算概述 :**  位运算符指的是二进制位的运算，先将十进制数转成二进制后再进行运算。在二进制位运算中，1表示true，0表示false。\r\n\r\n**位运算符介绍 :** ![1590937235620](./day06-Debug&基础练习.img/1590937235620.png)\r\n\r\n**代码 :** \r\n\r\n```java\r\npackage com.itheima.demo;\r\n\r\npublic class Demo3 {\r\n    /*\r\n       位移运算符:\r\n\r\n               << 有符号左移运算，二进制位向左移动, 左边符号位丢弃, 右边补齐0\r\n                        运算规律: 向左移动几位, 就是乘以2的几次幂\r\n\r\n                                12 << 2\r\n\r\n                                (0)0000000 00000000 00000000 000011000  // 12的二进制\r\n\r\n       -----------------------------------------------------------------------------\r\n               >> 有符号右移运算，二进制位向右移动, 使用符号位进行补位\r\n                        运算规律: 向右移动几位, 就是除以2的几次幂\r\n\r\n                                000000000 00000000 00000000 0000001(1)  // 3的二进制\r\n\r\n       -----------------------------------------------------------------------------\r\n\r\n                >>> 无符号右移运算符,  无论符号位是0还是1，都补0\r\n\r\n                                010000000 00000000 00000000 00000110  // -6的二进制\r\n\r\n     */\r\n    public static void main(String[] args) {\r\n        System.out.println(12 << 1);  // 24\r\n        System.out.println(12 << 2);  // 48\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n```java\r\npackage com.itheima.demo;\r\n\r\npublic class Demo4 {\r\n    /*\r\n        ^ 运算符的特点\r\n\r\n                一个数, 被另外一个数, 异或两次, 该数本身不变\r\n     */\r\n    public static void main(String[] args) {\r\n        System.out.println(10 ^ 5 ^ 10);\r\n    }\r\n}\r\n\r\n```\r\n\r\n## 3.基础练习\r\n\r\n### 3.1 数据交换\r\n\r\n**案例需求**\r\n\r\n​\t已知两个整数变量a = 10，b = 20，使用程序实现这两个变量的数据交换\r\n        最终输出a = 20，b = 10;\r\n\r\n**代码实现**\r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\npublic class Test1 {\r\n    /*\r\n        需求：已知两个整数变量a = 10，b = 20，使用程序实现这两个变量的数据交换\r\n        最终输出a = 20，b = 10;\r\n\r\n\r\n        思路：\r\n        1. 定义一个三方变量temp，将a原本记录的值，交给temp记录 （a的值，不会丢了）\r\n        2. 使用 a 变量记录 b 的值，（第一步交换完毕，b的值也丢不了了）\r\n        3. 使用 b 变量记录 temp的值，也就是a原本的值 （交换完毕）\r\n        4. 输出 a 和 b 变量即可\r\n     */\r\n    /*\r\n        动态初始化格式：\r\n\r\n            数据类型[][] 变量名 = new 数据类型[m][n];\r\n            m表示这个二维数组，可以存放多少个一维数组\r\n            n表示每一个一维数组，可以存放多少个元素\r\n     */\r\n    public static void main(String[] args) {\r\n        int a = 10;\r\n        int b = 20;\r\n\r\n        // 将a原本记录的值，交给temp记录 （a的值，不会丢了）\r\n        int temp = a;\r\n        // 用 a 变量记录 b 的值，（第一步交换完毕，b的值也丢不了了）\r\n        a = b;\r\n        // 使用 b 变量记录 temp的值，也就是a原本的值 （交换完毕）\r\n        b = temp;\r\n\r\n        // 输出 a 和 b 变量即可\r\n        System.out.println("a=" + a);\r\n        System.out.println("b=" + b);\r\n    }\r\n}\r\n```\r\n\r\n### 3.2 数组反转【应用】\r\n\r\n**案例需求 :** \r\n\r\n​\t已知一个数组 arr = {19, 28, 37, 46, 50}; 用程序实现把数组中的元素值交换，\r\n\r\n​\t交换后的数组 arr = {50, 46, 37, 28, 19}; 并在控制台输出交换后的数组元素\r\n\r\n**实现步骤 :** \r\n\r\n \t1. 定义两个变量, start和end来表示开始和结束的指针.          \r\n\r\n2. 确定交换条件, start < end 允许交换          \r\n3. 循环中编写交换逻辑代码         \r\n4. 每一次交换完成, 改变两个指针所指向的索引 start++, end--          \r\n5. 循环结束后, 遍历数组并打印, 查看反转后的数组\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\npublic class Test2 {\r\n    /*\r\n        需求：已知一个数组 arr = {19, 28, 37, 46, 50}; 用程序实现把数组中的元素值交换，\r\n          交换后的数组 arr = {50, 46, 37, 28, 19}; 并在控制台输出交换后的数组元素。\r\n\r\n        步骤:\r\n              1. 定义两个变量, start和end来表示开始和结束的指针.\r\n              2. 确定交换条件, start < end 允许交换\r\n              3. 循环中编写交换逻辑代码\r\n              4. 每一次交换完成, 改变两个指针所指向的索引 start++, end--\r\n              5. 循环结束后, 遍历数组并打印, 查看反转后的数组\r\n     */\r\n    public static void main(String[] args) {\r\n        int[] arr = {19, 28, 37, 46, 50};\r\n        //  1. 定义两个变量, start和end来表示开始和结束的指针.\r\n        int start = 0;\r\n        int end = arr.length -1;\r\n        //  2. 确定交换条件, start < end 允许交换\r\n        // 4. 每一次交换完成, 改变两个指针所指向的索引 start++, end--\r\n        // for(int start = 0, end = arr.length -1; start < end; start++, end--)\r\n        for( ; start < end; start++, end--){\r\n            // 3. 循环中编写交换逻辑代码\r\n            int temp = arr[start];\r\n            arr[start] = arr[end];\r\n            arr[end] = temp;\r\n        }\r\n\r\n        for (int i = 0; i < arr.length; i++) {\r\n            System.out.println(arr[i]);\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 3.3 二维数组概述\r\n\r\n​\t**概述 :**  二维数组也是一种容器，不同于一维数组，该容器存储的都是一维数组容器\r\n\r\n### 3.4 二维数组动态初始化\r\n\r\n```java\r\n动态初始化格式：\r\n\r\n数据类型[][] 变量名 = new 数据类型[m][n];\r\nm表示这个二维数组，可以存放多少个一维数组\r\nn表示每一个一维数组，可以存放多少个元素\r\n```\r\n\r\n```java\r\npackage com.itheima.demo;\r\n\r\npublic class Demo1Array {\r\n    /*\r\n        动态初始化格式：\r\n\r\n            数据类型[][] 变量名 = new 数据类型[m][n];\r\n            m表示这个二维数组，可以存放多少个一维数组\r\n            n表示每一个一维数组，可以存放多少个元素\r\n     */\r\n    public static void main(String[] args) {\r\n        // 数据类型[][] 变量名 = new 数据类型[m][n];\r\n        int[][] arr = new int[3][3];\r\n        /*\r\n            [[I@10f87f48\r\n\r\n            @ : 分隔符\r\n            10f87f48 : 十六进制内存地址\r\n            I : 数组中存储的数据类型\r\n            [[ : 几个中括号就代表的是几维数组\r\n         */\r\n        System.out.println(arr);\r\n\r\n        /*\r\n            二维数组存储一维数组的时候, 存储的是一维数组的内存地址\r\n         */\r\n        System.out.println(arr[0]);\r\n        System.out.println(arr[1]);\r\n        System.out.println(arr[2]);\r\n\r\n        System.out.println(arr[0][0]);\r\n        System.out.println(arr[1][1]);\r\n        System.out.println(arr[2][2]);\r\n\r\n        // 向二维数组中存储元素\r\n        arr[0][0] = 11;\r\n        arr[0][1] = 22;\r\n        arr[0][2] = 33;\r\n\r\n        arr[1][0] = 11;\r\n        arr[1][1] = 22;\r\n        arr[1][2] = 33;\r\n\r\n        arr[2][0] = 11;\r\n        arr[2][1] = 22;\r\n        arr[2][2] = 33;\r\n\r\n        // 从二维数组中取出元素并打印\r\n        System.out.println(arr[0][0]);\r\n        System.out.println(arr[0][1]);\r\n        System.out.println(arr[0][2]);\r\n        System.out.println(arr[1][0]);\r\n        System.out.println(arr[1][1]);\r\n        System.out.println(arr[1][2]);\r\n        System.out.println(arr[2][0]);\r\n        System.out.println(arr[2][1]);\r\n        System.out.println(arr[2][2]);\r\n    }\r\n}\r\n```\r\n\r\n### 3.5  二维数组访问元素的细节问题\r\n\r\n问题 :  二维数组中存储的是一维数组, 那能不能存入 [提前创建好的一维数组] 呢 ?\r\n\r\n答 : 可以的\r\n\r\n#### 代码实现\r\n\r\n```java\r\npackage com.itheima.demo;\r\n\r\npublic class Demo2Array {\r\n    /*\r\n        问题: 二维数组中存储的是一维数组, 那能不能存入 [提前创建好的一维数组] 呢 ?\r\n        答 : 可以的\r\n     */\r\n    public static void main(String[] args) {\r\n        int[] arr1 = {11,22,33};\r\n        int[] arr2 = {44,55,66};\r\n        int[] arr3 = {77,88,99,100};\r\n\r\n        int[][] arr = new int[3][3];\r\n\r\n        arr[2][3] = 100;\r\n\r\n        arr[0] = arr1;\r\n        arr[1] = arr2;\r\n        arr[2] = arr3;\r\n\r\n        System.out.println(arr[1][2]);\r\n        System.out.println(arr[2][3]);\r\n    }\r\n}\r\n```\r\n\r\n### 3.6 二维数组静态初始化\r\n\r\n \t**完整格式 :** 数据类型[][] 变量名 = new 数据类型[][]{ {元素1, 元素2...} , {元素1, 元素2...} \r\n\r\n \t**简化格式 :**  数据类型[][] 变量名 = { {元素1, 元素2...} , {元素1, 元素2...} ...};\r\n\r\n**代码实现 : **\r\n\r\n```java\r\npackage com.itheima.demo;\r\n\r\npublic class Demo3Array {\r\n    /*\r\n        完整格式：数据类型[][] 变量名 = new 数据类型[][]{ {元素1, 元素2...} , {元素1, 元素2...} ...};\r\n\r\n        简化格式: 数据类型[][] 变量名 = { {元素1, 元素2...} , {元素1, 元素2...} ...};\r\n     */\r\n    public static void main(String[] args) {\r\n        int[] arr1 = {11,22,33};\r\n        int[] arr2 = {44,55,66};\r\n\r\n        int[][] arr = {{11,22,33}, {44,55,66}};\r\n        System.out.println(arr[0][2]);\r\n\r\n        int[][] array = {arr1,arr2};\r\n        System.out.println(array[0][2]);\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 3.7 二维数组遍历\r\n\r\n**需求 :**   \r\n\r\n​\t已知一个二维数组 arr = {{11, 22, 33}, {33, 44, 55}};\r\n\r\n​\t遍历该数组，取出所有元素并打印\r\n\r\n**步骤 :** \r\n\r\n \t1. 遍历二维数组，取出里面每一个一维数组\r\n \t2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\npublic class Test1 {\r\n    /*\r\n        需求:\r\n\r\n            已知一个二维数组 arr = {{11, 22, 33}, {33, 44, 55}};\r\n            遍历该数组，取出所有元素并打印\r\n\r\n        步骤:\r\n            1. 遍历二维数组，取出里面每一个一维数组\r\n            2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素\r\n     */\r\n    public static void main(String[] args) {\r\n        int[][] arr = {{11, 22, 33}, {33, 44, 55}};\r\n\r\n        // 1. 遍历二维数组，取出里面每一个一维数组\r\n        for (int i = 0; i < arr.length; i++) {\r\n            //System.out.println(arr[i]);\r\n            // 2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素\r\n            //int[] temp = arr[i];\r\n            for (int j = 0; j < arr[i].length; j++) {\r\n                System.out.println(arr[i][j]);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 3.8 二维数组求和\r\n\r\n**需求 :**\r\n\r\n \t某公司季度和月份统计的数据如下：单位(万元)\r\n\t第一季度：22,66,44\r\n\t第二季度：77,33,88\r\n\t第三季度：25,45,65\r\n\t第四季度：11,66,99\r\n\r\n **步骤 :**\t\r\n\r\n1. 定义求和变量，准备记录最终累加结果\r\n2. 使用二维数组来存储数据，每个季度是一个一维数组，再将4个一维数组装起来\r\n3. 遍历二维数组，获取所有元素，累加求和\r\n4. 输出最终结果\r\n\r\n**代码实现 :** \r\n\r\n```java\r\npackage com.itheima.test;\r\n\r\npublic class Test2 {\r\n    /*\r\n        需求:\r\n            某公司季度和月份统计的数据如下：单位(万元)\r\n            第一季度：22,66,44\r\n            第二季度：77,33,88\r\n            第三季度：25,45,65\r\n            第四季度：11,66,99\r\n\r\n        步骤:\r\n            1. 定义求和变量，准备记录最终累加结果\r\n            2. 使用二维数组来存储数据，每个季度是一个一维数组，再将4个一维数组装起来\r\n            3. 遍历二维数组，获取所有元素，累加求和\r\n            4. 输出最终结果\r\n     */\r\n    public static void main(String[] args) {\r\n        // 1. 定义求和变量，准备记录最终累加结果\r\n        int sum = 0;\r\n        // 2. 使用二维数组来存储数据，每个季度是一个一维数组，再将4个一维数组装起来\r\n        int[][] arr = { {22,66,44} , {77,33,88} , {25,45,65} , {11,66,99}};\r\n        // 3. 遍历二维数组，获取所有元素，累加求和\r\n        for (int i = 0; i < arr.length; i++) {\r\n            for(int j = 0; j < arr[i].length; j++){\r\n                sum += arr[i][j];\r\n            }\r\n        }\r\n        // 4. 输出最终结果\r\n        System.out.println(sum);\r\n    }\r\n}\r\n```\r\n'},efed:function(n,e,t){"use strict";t.r(e),e["default"]='> 本篇文章是JavaGuide收集自网络，原出处不明。\n\nMyBatis 技术内幕系列博客，从原理和源码角度，介绍了其内部实现细节，无论是写的好与不好，我确实是用心写了，由于并不是介绍如何使用 MyBatis 的文章，所以，一些参数使用细节略掉了，我们的目标是介绍 MyBatis 的技术架构和重要组成部分，以及基本运行原理。\n\n博客写的很辛苦，但是写出来却不一定好看，所谓开始很兴奋，过程很痛苦，结束很遗憾。要求不高，只要读者能从系列博客中，学习到一点其他博客所没有的技术点，作为作者，我就很欣慰了，我也读别人写的博客，通常对自己当前研究的技术，是很有帮助的。\n\n尽管还有很多可写的内容，但是，我认为再写下去已经没有意义，任何其他小的功能点，都是在已经介绍的基本框架和基本原理下运行的，只有结束，才能有新的开始。写博客也积攒了一些经验，源码多了感觉就是复制黏贴，源码少了又觉得是空谈原理，将来再写博客，我希望是“精炼博文”，好读好懂美观读起来又不累，希望自己能再写一部开源分布式框架原理系列博客。\n\n有胆就来，我出几道 MyBatis 面试题，看你能回答上来几道（都是我出的，可不是网上找的）。\n\n#### 1、#{}和\\${}的区别是什么？\n\n注：这道题是面试官面试我同事的。\n\n答：\n\n- `${}`是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如\\${driver}会被静态替换为`com.mysql.jdbc.Driver`。\n- `#{}`是 sql 的参数占位符，MyBatis 会将 sql 中的`#{}`替换为?号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的?号占位符设置参数值，比如 ps.setInt(0, parameterValue)，`#{item.name}` 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 `param.getItem().getName()`。\n\n#### 2、Xml 映射文件中，除了常见的 select|insert|update|delete 标签之外，还有哪些标签？\n\n注：这道题是京东面试官面试我时问的。\n\n答：还有很多其他的标签，`<resultMap>`、`<parameterMap>`、`<sql>`、`<include>`、`<selectKey>`，加上动态 sql 的 9 个标签，`trim|where|set|foreach|if|choose|when|otherwise|bind`等，其中<sql>为 sql 片段标签，通过`<include>`标签引入 sql 片段，`<selectKey>`为不支持自增的主键生成策略标签。\n\n#### 3、最佳实践中，通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？\n\n注：这道题也是京东面试官面试我被问的。\n\n答：Dao 接口，就是人们常说的 `Mapper`接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中`MappedStatement`的 id 值，接口方法内的参数，就是传递给 sql 的参数。`Mapper`接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个`MappedStatement`，举例：`com.mybatis3.mappers.StudentDao.findStudentById`，可以唯一找到 namespace 为`com.mybatis3.mappers.StudentDao`下面`id = findStudentById`的`MappedStatement`。在 MyBatis 中，每一个`<select>`、`<insert>`、`<update>`、`<delete>`标签，都会被解析为一个`MappedStatement`对象。\n\n~~Dao 接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。~~\n\nDao 接口里的方法可以重载，但是Mybatis的XML里面的ID不允许重复。\n\nMybatis版本3.3.0，亲测如下：\n\n```java\n/**\n * Mapper接口里面方法重载\n */\npublic interface StuMapper {\n\n\tList<Student> getAllStu();\n    \n\tList<Student> getAllStu(@Param("id") Integer id);\n}\n```\n\n然后在 `StuMapper.xml` 中利用Mybatis的动态sql就可以实现。\n\n```java\n\t<select id="getAllStu" resultType="com.pojo.Student">\n \t\tselect * from student\n\t\t<where>\n\t\t\t<if test="id != null">\n\t\t\t\tid = #{id}\n\t\t\t</if>\n\t\t</where>\n \t</select>\n```\n\n能正常运行，并能得到相应的结果，这样就实现了在Dao接口中写重载方法。\n\n**Mybatis 的 Dao 接口可以有多个重载方法，但是多个接口对应的映射必须只有一个，否则启动会报错。**\n\n相关 issue ：[更正：Dao 接口里的方法可以重载，但是Mybatis的XML里面的ID不允许重复！](https://github.com/Snailclimb/JavaGuide/issues/1122)。\n\nDao 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行`MappedStatement`所代表的 sql，然后将 sql 执行结果返回。\n\n##### ==补充：==\n\nDao接口方法可以重载，但是需要满足以下条件：\n\n1. 仅有一个无参方法和一个有参方法\n2. 多个有参方法时，参数数量必须一致。且使用相同的 `@Param` ，或者使用 `param1` 这种\n\n测试如下：\n\n`PersonDao.java`\n\n```java\nPerson queryById();\n\nPerson queryById(@Param("id") Long id);\n\nPerson queryById(@Param("id") Long id, @Param("name") String name);\n```\n\n`PersonMapper.xml`\n\n```xml\n<select id="queryById" resultMap="PersonMap">\n    select\n      id, name, age, address\n    from person\n    <where>\n        <if test="id != null">\n            id = #{id}\n        </if>\n        <if test="name != null and name != \'\'">\n            name = #{name}\n        </if>\n    </where>\n    limit 1\n</select>\n```\n\n`org.apache.ibatis.scripting.xmltags.DynamicContext.ContextAccessor#getProperty`方法用于获取`<if>`标签中的条件值\n\n```java\npublic Object getProperty(Map context, Object target, Object name) {\n  Map map = (Map) target;\n\n  Object result = map.get(name);\n  if (map.containsKey(name) || result != null) {\n    return result;\n  }\n\n  Object parameterObject = map.get(PARAMETER_OBJECT_KEY);\n  if (parameterObject instanceof Map) {\n    return ((Map)parameterObject).get(name);\n  }\n\n  return null;\n}\n```\n\n`parameterObject`为map，存放的是Dao接口中参数相关信息。\n\n`((Map)parameterObject).get(name)`方法如下\n\n```java\npublic V get(Object key) {\n  if (!super.containsKey(key)) {\n    throw new BindingException("Parameter \'" + key + "\' not found. Available parameters are " + keySet());\n  }\n  return super.get(key);\n}\n```\n\n1. `queryById()`方法执行时，`parameterObject`为null，`getProperty`方法返回null值，`<if>`标签获取的所有条件值都为null，所有条件不成立，动态sql可以正常执行。\n2. `queryById(1L)`方法执行时，`parameterObject`为map，包含了`id`和`param1`两个key值。当获取`<if>`标签中`name`的属性值时，进入`((Map)parameterObject).get(name)`方法中，map中key不包含`name`，所以抛出异常。\n3. `queryById(1L,"1")`方法执行时，`parameterObject`中包含`id`,`param1`,`name`,`param2`四个key值，`id`和`name`属性都可以获取到，动态sql正常执行。\n\n#### 4、MyBatis 是如何进行分页的？分页插件的原理是什么？\n\n注：我出的。\n\n答：**(1)** MyBatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页；**(2)** 可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，**(3)** 也可以使用分页插件来完成物理分页。\n\n分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。\n\n举例：`select _ from student`，拦截 sql 后重写为：`select t._ from （select \\* from student）t limit 0，10`\n\n#### 5、简述 MyBatis 的插件运行原理，以及如何编写一个插件。\n\n注：我出的。\n\n答：MyBatis 仅可以编写针对 `ParameterHandler`、`ResultSetHandler`、`StatementHandler`、`Executor` 这 4 种接口的插件，MyBatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 `InvocationHandler` 的 `invoke()`方法，当然，只会拦截那些你指定需要拦截的方法。\n\n实现 MyBatis 的 Interceptor 接口并复写` intercept()`方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。\n\n#### 6、MyBatis 执行批量插入，能返回数据库主键列表吗？\n\n注：我出的。\n\n答：能，JDBC 都能，MyBatis 当然也能。\n\n#### 7、MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？\n\n注：我出的。\n\n答：MyBatis 动态 sql 可以让我们在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能，MyBatis 提供了 9 种动态 sql 标签 `trim|where|set|foreach|if|choose|when|otherwise|bind`。\n\n其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。\n\n#### 8、MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？\n\n注：我出的。\n\n答：第一种是使用`<resultMap>`标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，MyBatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，MyBatis 一样可以正常工作。\n\n有了列名与属性名的映射关系后，MyBatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。\n\n#### 9、MyBatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。\n\n注：我出的。\n\n答：能，MyBatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把 `selectOne()`修改为 `selectList()`即可；多对多查询，其实就是一对多查询，只需要把 `selectOne()`修改为 `selectList()`即可。\n\n关联对象查询，有两种实现方式，一种是单独发送一个 sql 去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用 join 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql 查询，就可以把主对象和其关联对象查出来。\n\n那么问题来了，join 查询出来 100 条记录，如何确定主对象是 5 个，而不是 100 个？其去重复的原理是`<resultMap>`标签内的`<id>`子标签，指定了唯一确定一条记录的 id 列，MyBatis 根据<id>列值来完成 100 条记录的去重复功能，`<id>`可以有多个，代表了联合主键的语意。\n\n同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。\n\n举例：下面 join 查询出来 6 条记录，一、二列是 Teacher 对象列，第三列为 Student 对象列，MyBatis 去重复处理后，结果为 1 个老师 6 个学生，而不是 6 个老师 6 个学生。\n\n| t_id | t_name  | s_id |\n| ---- | ------- | ---- |\n| 1    | teacher | 38   |\n| 1    | teacher | 39   |\n| 1    | teacher | 40   |\n| 1    | teacher | 41   |\n| 1    | teacher | 42   |\n| 1    | teacher | 43   |\n\n#### 10、MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？\n\n注：我出的。\n\n答：MyBatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在 MyBatis 配置文件中，可以配置是否启用延迟加载 `lazyLoadingEnabled=true|false。`\n\n它的原理是，使用` CGLIB` 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 `a.getB().getName()`，拦截器 `invoke()`方法发现 `a.getB()`是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 `a.getB().getName()`方法的调用。这就是延迟加载的基本原理。\n\n当然了，不光是 MyBatis，几乎所有的包括 Hibernate，支持延迟加载的原理都是一样的。\n\n#### 11、MyBatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？\n\n注：我出的。\n\n答：不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复；毕竟 namespace 不是必须的，只是最佳实践而已。\n\n原因就是 namespace+id 是作为 `Map<String, MappedStatement>`的 key 使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然也就不同。\n\n#### 12、MyBatis 中如何执行批处理？\n\n注：我出的。\n\n答：使用 BatchExecutor 完成批处理。\n\n#### 13、MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？\n\n注：我出的\n\n答：MyBatis 有三种基本的 Executor 执行器，**`SimpleExecutor`、`ReuseExecutor`、`BatchExecutor`。**\n\n**`SimpleExecutor`：**每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。\n\n**`ReuseExecutor`：**执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map<String, Statement>内，供下一次使用。简言之，就是重复使用 Statement 对象。\n\n**`BatchExecutor`：**执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。\n\n作用范围：Executor 的这些特点，都严格限制在 SqlSession 生命周期范围内。\n\n#### 14、MyBatis 中如何指定使用哪一种 Executor 执行器？\n\n注：我出的\n\n答：在 MyBatis 配置文件中，可以指定默认的 ExecutorType 执行器类型，也可以手动给 `DefaultSqlSessionFactory` 的创建 SqlSession 的方法传递 ExecutorType 类型参数。\n\n#### 15、MyBatis 是否可以映射 Enum 枚举类？\n\n注：我出的\n\n答：MyBatis 可以映射枚举类，不单可以映射枚举类，MyBatis 可以映射任何对象到表的一列上。映射方式为自定义一个 `TypeHandler`，实现 `TypeHandler` 的 `setParameter()`和 `getResult()`接口方法。`TypeHandler` 有两个作用，一是完成从 javaType 至 jdbcType 的转换，二是完成 jdbcType 至 javaType 的转换，体现为 `setParameter()`和 `getResult()`两个方法，分别代表设置 sql 问号占位符参数和获取列查询结果。\n\n#### 16、MyBatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？\n\n注：我出的\n\n答：虽然 MyBatis 解析 Xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可以定义在任何地方，MyBatis 都可以正确识别。\n\n原理是，MyBatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，MyBatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，MyBatis 会重新解析那些被标记为未解析的标签，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。\n\n#### 17、简述 MyBatis 的 Xml 映射文件和 MyBatis 内部数据结构之间的映射关系？\n\n注：我出的\n\n答：MyBatis 将所有 Xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部。在 Xml 映射文件中，`<parameterMap>`标签会被解析为 `ParameterMap` 对象，其每个子元素会被解析为 ParameterMapping 对象。`<resultMap>`标签会被解析为 `ResultMap` 对象，其每个子元素会被解析为 `ResultMapping` 对象。每一个`<select>、<insert>、<update>、<delete>`标签均会被解析为 `MappedStatement` 对象，标签内的 sql 会被解析为 BoundSql 对象。\n\n#### 18、为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？\n\n注：我出的\n\n答：Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 MyBatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。\n\n面试题看似都很简单，但是想要能正确回答上来，必定是研究过源码且深入的人，而不是仅会使用的人或者用的很熟的人，以上所有面试题及其答案所涉及的内容，在我的 MyBatis 系列博客中都有详细讲解和原理分析。\n'},f112:function(n,e,t){"use strict";t.r(e),e["default"]='\x3c!--\r\n * @Date           : 2021-04-12 16:03:11\r\n * @FilePath       : /jinnian-space/src/pages/java/module/jdbc/md/JDBC-01-授课笔记.md\r\n * @Description    : \r\n--\x3e\r\n# JDBC-01-授课笔记\r\n\r\n### 一、JDBC快速入门\r\n\r\n#### 1.jdbc的概念\r\n \r\n\r\n- JDBC（Java DataBase Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系型数据库提供统一访问，它是由一组用Java语言编写的类和接口组成的。\r\n\r\n#### 2.jdbc的本质\r\n\r\n- 其实就是java官方提供的一套规范(接口)。用于帮助开发人员快速实现不同关系型数据库的连接！\r\n\r\n#### 3.jdbc的快速入门程序\r\n\r\n1. 导入jar包\r\n\r\n2. 注册驱动\r\n\r\n   ```java\r\n   Class.forName("com.mysql.jdbc.Driver");\r\n   ```\r\n\r\n3. 获取连接\r\n\r\n   ```java\r\n   Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/db2", "root", "root");\r\n   ```\r\n\r\n4. 获取执行者对象\r\n\r\n   ```java\r\n   Statement stat = con.createStatement();\r\n   ```\r\n\r\n5. 执行sql语句，并接收返回结果\r\n\r\n   ```java\r\n   String sql = "SELECT * FROM user";\r\n   ResultSet rs = stat.executeQuery(sql);\r\n   ```\r\n\r\n6. 处理结果\r\n\r\n   ```java\r\n   while(rs.next()) {\r\n       System.out.println(rs.getInt("id") + "\\t" + rs.getString("name"));\r\n   }\r\n   ```\r\n\r\n7. 释放资源\r\n\r\n   ```java\r\n   con.close();\r\n   stat.close();\r\n   rs.close();\r\n   ```\r\n\r\n### 二、JDBC各个功能类详解\r\n\r\n#### 1.DriverManager\r\n\r\n- DriverManager：驱动管理对象\r\n\r\n  - 注册驱动(告诉程序该使用哪一个数据库驱动)\r\n\r\n    - static void registerDriver(Driver driver)：注册与给定的驱动程序 DriverManager \r\n    - 写代码使用：Class.forName("com.mysql.jdbc.Driver");\r\n    - 通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块\r\n\r\n    ```java\r\n    static {\r\n    \ttry {\r\n    \t\tjava.sql.DriverManager.registerDriver(new Driver());\r\n    \t} catch (SQLException E) {\r\n    \t\tthrow new RuntimeException("Can\'t register driver!");\r\n    \t}\r\n    }\r\n    ```\r\n\r\n    - 注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。在jar包中，存在一个java.sql.Driver配置文件，文件中指定了com.mysql.jdbc.Driver\r\n\r\n  - 获取数据库连接(获取到数据库的连接并返回连接对象)\r\n\r\n    - static Connection getConnection(String url, String user, String password);\r\n      - 返回值：Connection数据库连接对象\r\n      - 参数\r\n        - url：指定连接的路径。语法：jdbc:mysql://ip地址(域名):端口号/数据库名称\r\n        - user：用户名\r\n        - password：密码\r\n\r\n#### 2.Connection\r\n\r\n- Connection：数据库连接对象\r\n  - 获取执行者对象\r\n    - 获取普通执行者对象：Statement createStatement();\r\n    - 获取预编译执行者对象：PreparedStatement prepareStatement(String sql);\r\n  - 管理事务\r\n    - 开启事务：setAutoCommit(boolean autoCommit);     参数为false，则开启事务。\r\n    - 提交事务：commit();\r\n    - 回滚事务：rollback();\r\n  - 释放资源\r\n    - 立即将数据库连接对象释放：void close();\r\n\r\n#### 3.Statement\r\n\r\n- Statement：执行sql语句的对象\r\n  - 执行DML语句：int executeUpdate(String sql);\r\n    - 返回值int：返回影响的行数。\r\n    - 参数sql：可以执行insert、update、delete语句。\r\n  - 执行DQL语句：ResultSet executeQuery(String sql);\r\n    - 返回值ResultSet：封装查询的结果。\r\n    - 参数sql：可以执行select语句。\r\n  - 释放资源\r\n    - 立即将执行者对象释放：void close();\r\n\r\n#### 4.ResultSet\r\n\r\n- ResultSet：结果集对象\r\n  - 判断结果集中是否还有数据：boolean next();\r\n    - 有数据返回true，并将索引向下移动一行\r\n    - 没有数据返回false\r\n  - 获取结果集中的数据：XXX getXxx("列名");\r\n    - XXX代表数据类型(要获取某列数据，这一列的数据类型)\r\n    - 例如：String getString("name");          int getInt("age");\r\n  - 释放资源\r\n    - 立即将结果集对象释放：void close();\r\n\r\n### 三、JDBC案例student学生表的CRUD\r\n\r\n#### 1.数据准备\r\n\r\n- 数据库和数据表\r\n\r\n```mysql\r\n-- 创建db14数据库\r\nCREATE DATABASE db14;\r\n\r\n-- 使用db14数据库\r\nUSE db14;\r\n\r\n-- 创建student表\r\nCREATE TABLE student(\r\n\tsid INT PRIMARY KEY AUTO_INCREMENT,\t-- 学生id\r\n\tNAME VARCHAR(20),\t\t\t\t\t-- 学生姓名\r\n\tage INT,\t\t\t\t\t\t\t-- 学生年龄\r\n\tbirthday DATE\t\t\t\t\t\t-- 学生生日\r\n);\r\n\r\n-- 添加数据\r\nINSERT INTO student VALUES (NULL,\'张三\',23,\'1999-09-23\'),(NULL,\'李四\',24,\'1998-08-10\'),(NULL,\'王五\',25,\'1996-06-06\'),(NULL,\'赵六\',26,\'1994-10-20\');\r\n```\r\n\r\n- 实体类\r\n  - Student类，成员变量对应表中的列\r\n  - 注意：所有的基本数据类型需要使用包装类，以防null值无法赋值\r\n\r\n```java\r\npackage com.itheima02.domain;\r\n\r\nimport java.util.Date;\r\n\r\npublic class Student {\r\n    private Integer sid;\r\n    private String name;\r\n    private Integer age;\r\n    private Date birthday;\r\n\r\n    public Student() {\r\n    }\r\n\r\n    public Student(Integer sid, String name, Integer age, Date birthday) {\r\n        this.sid = sid;\r\n        this.name = name;\r\n        this.age = age;\r\n        this.birthday = birthday;\r\n    }\r\n\r\n    public Integer getSid() {\r\n        return sid;\r\n    }\r\n\r\n    public void setSid(Integer sid) {\r\n        this.sid = sid;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public Integer getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(Integer age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public Date getBirthday() {\r\n        return birthday;\r\n    }\r\n\r\n    public void setBirthday(Date birthday) {\r\n        this.birthday = birthday;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return "Student{" +\r\n                "sid=" + sid +\r\n                ", name=\'" + name + \'\\\'\' +\r\n                ", age=" + age +\r\n                ", birthday=" + birthday +\r\n                \'}\';\r\n    }\r\n}\r\n```\r\n\r\n#### 2.需求一：查询全部\r\n\r\n- 持久层\r\n\r\n```java\r\n/*\r\n     查询所有学生信息\r\n*/\r\n@Override\r\npublic ArrayList<Student> findAll() {\r\n    ArrayList<Student> list = new ArrayList<>();\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    ResultSet rs = null;\r\n    try{\r\n        //1.注册驱动\r\n        Class.forName("com.mysql.jdbc.Driver");\r\n\r\n        //2.获取数据库连接\r\n        con = DriverManager.getConnection("jdbc:mysql://192.168.59.129:3306/db14", "root", "itheima");\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        String sql = "SELECT * FROM student";\r\n        rs = stat.executeQuery(sql);\r\n\r\n        //5.处理结果集\r\n        while(rs.next()) {\r\n            Integer sid = rs.getInt("sid");\r\n            String name = rs.getString("name");\r\n            Integer age = rs.getInt("age");\r\n            Date birthday = rs.getDate("birthday");\r\n\r\n            //封装Student对象\r\n            Student stu = new Student(sid,name,age,birthday);\r\n\r\n            //将student对象保存到集合中\r\n            list.add(stu);\r\n        }\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        if(con != null) {\r\n            try {\r\n                con.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if(stat != null) {\r\n            try {\r\n                stat.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if(rs != null) {\r\n            try {\r\n                rs.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n    //将集合对象返回\r\n    return list;\r\n}\r\n```\r\n\r\n- 业务层\r\n\r\n```java\r\n/*\r\n    查询所有学生信息\r\n*/\r\n@Override\r\npublic ArrayList<Student> findAll() {\r\n    return dao.findAll();\r\n}\r\n```\r\n\r\n- 控制层\r\n\r\n```java\r\n/*\r\n    查询所有学生信息\r\n*/\r\n@Test\r\npublic void findAll() {\r\n    ArrayList<Student> list = service.findAll();\r\n    for(Student stu : list) {\r\n        System.out.println(stu);\r\n    }\r\n}\r\n```\r\n\r\n#### 3.需求二：条件查询\r\n\r\n- 持久层\r\n\r\n```java\r\n/*\r\n    条件查询，根据id查询学生信息\r\n*/\r\n@Override\r\npublic Student findById(Integer id) {\r\n    Student stu = new Student();\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    ResultSet rs = null;\r\n    try{\r\n        //1.注册驱动\r\n        Class.forName("com.mysql.jdbc.Driver");\r\n\r\n        //2.获取数据库连接\r\n        con = DriverManager.getConnection("jdbc:mysql://192.168.59.129:3306/db14", "root", "itheima");\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        String sql = "SELECT * FROM student WHERE sid=\'"+id+"\'";\r\n        rs = stat.executeQuery(sql);\r\n\r\n        //5.处理结果集\r\n        while(rs.next()) {\r\n            Integer sid = rs.getInt("sid");\r\n            String name = rs.getString("name");\r\n            Integer age = rs.getInt("age");\r\n            Date birthday = rs.getDate("birthday");\r\n\r\n            //封装Student对象\r\n            stu.setSid(sid);\r\n            stu.setName(name);\r\n            stu.setAge(age);\r\n            stu.setBirthday(birthday);\r\n        }\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        if(con != null) {\r\n            try {\r\n                con.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if(stat != null) {\r\n            try {\r\n                stat.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if(rs != null) {\r\n            try {\r\n                rs.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n    //将对象返回\r\n    return stu;\r\n}\r\n```\r\n\r\n- 业务层\r\n\r\n```java\r\n/*\r\n    条件查询，根据id查询学生信息\r\n*/\r\n@Override\r\npublic Student findById(Integer id) {\r\n    return dao.findById(id);\r\n}\r\n```\r\n\r\n- 控制层\r\n\r\n```java\r\n/*\r\n    条件查询，根据id查询学生信息\r\n*/\r\n@Test\r\npublic void findById() {\r\n    Student stu = service.findById(3);\r\n    System.out.println(stu);\r\n}\r\n```\r\n\r\n#### 4.需求三：新增数据\r\n\r\n- 持久层\r\n\r\n```java\r\n/*\r\n      添加学生信息\r\n*/\r\n@Override\r\npublic int insert(Student stu) {\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    int result = 0;\r\n    try{\r\n        //1.注册驱动\r\n        Class.forName("com.mysql.jdbc.Driver");\r\n\r\n        //2.获取数据库连接\r\n        con = DriverManager.getConnection("jdbc:mysql://192.168.59.129:3306/db14", "root", "itheima");\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        Date d = stu.getBirthday();\r\n        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");\r\n        String birthday = sdf.format(d);\r\n        String sql = "INSERT INTO student VALUES (\'"+stu.getSid()+"\',\'"+stu.getName()+"\',\'"+stu.getAge()+"\',\'"+birthday+"\')";\r\n        result = stat.executeUpdate(sql);\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        if(con != null) {\r\n            try {\r\n                con.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if(stat != null) {\r\n            try {\r\n                stat.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n    //将结果返回\r\n    return result;\r\n}\r\n```\r\n\r\n- 业务层\r\n\r\n```java\r\n/*\r\n    新增学生信息\r\n*/\r\n@Override\r\npublic int insert(Student stu) {\r\n    return dao.insert(stu);\r\n}\r\n```\r\n\r\n- 控制层\r\n\r\n```java\r\n/*\r\n  \t新增学生信息\r\n*/\r\n@Test\r\npublic void insert() {\r\n    Student stu = new Student(5,"周七",27,new Date());\r\n    int result = service.insert(stu);\r\n    if(result != 0) {\r\n        System.out.println("新增成功");\r\n    }else {\r\n        System.out.println("新增失败");\r\n    }\r\n}\r\n```\r\n\r\n#### 5.需求四：修改数据\r\n\r\n- 持久层\r\n\r\n```java\r\n/*\r\n    修改学生信息\r\n*/\r\n@Override\r\npublic int update(Student stu) {\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    int result = 0;\r\n    try{\r\n        //1.注册驱动\r\n        Class.forName("com.mysql.jdbc.Driver");\r\n\r\n        //2.获取数据库连接\r\n        con = DriverManager.getConnection("jdbc:mysql://192.168.59.129:3306/db14", "root", "itheima");\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        Date d = stu.getBirthday();\r\n        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");\r\n        String birthday = sdf.format(d);\r\n        String sql = "UPDATE student SET sid=\'"+stu.getSid()+"\',name=\'"+stu.getName()+"\',age=\'"+stu.getAge()+"\',birthday=\'"+birthday+"\' WHERE sid=\'"+stu.getSid()+"\'";\r\n        result = stat.executeUpdate(sql);\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        if(con != null) {\r\n            try {\r\n                con.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if(stat != null) {\r\n            try {\r\n                stat.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n    //将结果返回\r\n    return result;\r\n}\r\n```\r\n\r\n- 业务层\r\n\r\n```java\r\n/*\r\n    修改学生信息\r\n*/\r\n@Override\r\npublic int update(Student stu) {\r\n    return dao.update(stu);\r\n}\r\n```\r\n\r\n- 控制层\r\n\r\n```java\r\n/*\r\n    修改学生信息\r\n*/\r\n@Test\r\npublic void update() {\r\n    Student stu = service.findById(5);\r\n    stu.setName("周七七");\r\n\r\n    int result = service.update(stu);\r\n    if(result != 0) {\r\n        System.out.println("修改成功");\r\n    }else {\r\n        System.out.println("修改失败");\r\n    }\r\n}\r\n```\r\n\r\n#### 6.需求五：删除数据\r\n\r\n- 持久层\r\n\r\n```java\r\n/*\r\n    删除学生信息\r\n*/\r\n@Override\r\npublic int delete(Integer id) {\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    int result = 0;\r\n    try{\r\n        //1.注册驱动\r\n        Class.forName("com.mysql.jdbc.Driver");\r\n\r\n        //2.获取数据库连接\r\n        con = DriverManager.getConnection("jdbc:mysql://192.168.59.129:3306/db14", "root", "itheima");\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        String sql = "DELETE FROM student WHERE sid=\'"+id+"\'";\r\n        result = stat.executeUpdate(sql);\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        if(con != null) {\r\n            try {\r\n                con.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if(stat != null) {\r\n            try {\r\n                stat.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n    //将结果返回\r\n    return result;\r\n}\r\n```\r\n\r\n- 业务层\r\n\r\n```java\r\n/*\r\n    删除学生信息\r\n*/\r\n@Override\r\npublic int delete(Integer id) {\r\n    return dao.delete(id);\r\n}\r\n```\r\n\r\n- 控制层\r\n\r\n```java\r\n/*\r\n    删除学生信息\r\n*/\r\n@Test\r\npublic void delete() {\r\n    int result = service.delete(5);\r\n\r\n    if(result != 0) {\r\n        System.out.println("删除成功");\r\n    }else {\r\n        System.out.println("删除失败");\r\n    }\r\n}\r\n```\r\n\r\n### 四、JDBC工具类\r\n\r\n#### 1.工具类的抽取\r\n\r\n- 配置文件(在src下创建config.properties)\r\n\r\n```properties\r\ndriverClass=com.mysql.jdbc.Driver\r\nurl=jdbc:mysql://localhost:3306/db14\r\nusername=root\r\npassword=itheima\r\n```\r\n\r\n- 工具类\r\n\r\n```java\r\n/*\r\n    JDBC工具类\r\n */\r\npublic class JDBCUtils {\r\n    //1.私有构造方法\r\n    private JDBCUtils(){};\r\n\r\n    //2.声明配置信息变量\r\n    private static String driverClass;\r\n    private static String url;\r\n    private static String username;\r\n    private static String password;\r\n    private static Connection con;\r\n\r\n    //3.静态代码块中实现加载配置文件和注册驱动\r\n    static{\r\n        try{\r\n            //通过类加载器返回配置文件的字节流\r\n            InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream("config.properties");\r\n\r\n            //创建Properties集合，加载流对象的信息\r\n            Properties prop = new Properties();\r\n            prop.load(is);\r\n\r\n            //获取信息为变量赋值\r\n            driverClass = prop.getProperty("driverClass");\r\n            url = prop.getProperty("url");\r\n            username = prop.getProperty("username");\r\n            password = prop.getProperty("password");\r\n\r\n            //注册驱动\r\n            Class.forName(driverClass);\r\n\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    //4.获取数据库连接的方法\r\n    public static Connection getConnection() {\r\n        try {\r\n            con = DriverManager.getConnection(url,username,password);\r\n        } catch (SQLException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        return con;\r\n    }\r\n\r\n    //5.释放资源的方法\r\n    public static void close(Connection con, Statement stat, ResultSet rs) {\r\n        if(con != null) {\r\n            try {\r\n                con.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if(stat != null) {\r\n            try {\r\n                stat.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if(rs != null) {\r\n            try {\r\n                rs.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void close(Connection con, Statement stat) {\r\n        close(con,stat,null);\r\n    }\r\n}\r\n```\r\n\r\n#### 2.使用工具类优化student表的CRUD\r\n\r\n- 查询全部\r\n\r\n```java\r\n/*\r\n    查询所有学生信息\r\n*/\r\n@Override\r\npublic ArrayList<Student> findAll() {\r\n    ArrayList<Student> list = new ArrayList<>();\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    ResultSet rs = null;\r\n    try{\r\n\r\n        con = JDBCUtils.getConnection();\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        String sql = "SELECT * FROM student";\r\n        rs = stat.executeQuery(sql);\r\n\r\n        //5.处理结果集\r\n        while(rs.next()) {\r\n            Integer sid = rs.getInt("sid");\r\n            String name = rs.getString("name");\r\n            Integer age = rs.getInt("age");\r\n            Date birthday = rs.getDate("birthday");\r\n\r\n            //封装Student对象\r\n            Student stu = new Student(sid,name,age,birthday);\r\n\r\n            //将student对象保存到集合中\r\n            list.add(stu);\r\n        }\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        JDBCUtils.close(con,stat,rs);\r\n    }\r\n    //将集合对象返回\r\n    return list;\r\n}\r\n```\r\n\r\n- 条件查询\r\n\r\n```java\r\n/*\r\n    条件查询，根据id查询学生信息\r\n*/\r\n@Override\r\npublic Student findById(Integer id) {\r\n    Student stu = new Student();\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    ResultSet rs = null;\r\n    try{\r\n\r\n        con = JDBCUtils.getConnection();\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        String sql = "SELECT * FROM student WHERE sid=\'"+id+"\'";\r\n        rs = stat.executeQuery(sql);\r\n\r\n        //5.处理结果集\r\n        while(rs.next()) {\r\n            Integer sid = rs.getInt("sid");\r\n            String name = rs.getString("name");\r\n            Integer age = rs.getInt("age");\r\n            Date birthday = rs.getDate("birthday");\r\n\r\n            //封装Student对象\r\n            stu.setSid(sid);\r\n            stu.setName(name);\r\n            stu.setAge(age);\r\n            stu.setBirthday(birthday);\r\n        }\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        JDBCUtils.close(con,stat,rs);\r\n    }\r\n    //将对象返回\r\n    return stu;\r\n}\r\n```\r\n\r\n- 新增数据\r\n\r\n```java\r\n/*\r\n     添加学生信息\r\n*/\r\n@Override\r\npublic int insert(Student stu) {\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    int result = 0;\r\n    try{\r\n        con = JDBCUtils.getConnection();\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        Date d = stu.getBirthday();\r\n        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");\r\n        String birthday = sdf.format(d);\r\n        String sql = "INSERT INTO student VALUES (\'"+stu.getSid()+"\',\'"+stu.getName()+"\',\'"+stu.getAge()+"\',\'"+birthday+"\')";\r\n        result = stat.executeUpdate(sql);\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        JDBCUtils.close(con,stat);\r\n    }\r\n    //将结果返回\r\n    return result;\r\n}\r\n```\r\n\r\n- 修改数据\r\n\r\n```java\r\n/*\r\n     修改学生信息\r\n*/\r\n@Override\r\npublic int update(Student stu) {\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    int result = 0;\r\n    try{\r\n        con = JDBCUtils.getConnection();\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        Date d = stu.getBirthday();\r\n        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");\r\n        String birthday = sdf.format(d);\r\n        String sql = "UPDATE student SET sid=\'"+stu.getSid()+"\',name=\'"+stu.getName()+"\',age=\'"+stu.getAge()+"\',birthday=\'"+birthday+"\' WHERE sid=\'"+stu.getSid()+"\'";\r\n        result = stat.executeUpdate(sql);\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        JDBCUtils.close(con,stat);\r\n    }\r\n    //将结果返回\r\n    return result;\r\n}\r\n```\r\n\r\n- 删除数据\r\n\r\n```java\r\n/*\r\n   删除学生信息\r\n*/\r\n@Override\r\npublic int delete(Integer id) {\r\n    Connection con = null;\r\n    Statement stat = null;\r\n    int result = 0;\r\n    try{\r\n        con = JDBCUtils.getConnection();\r\n\r\n        //3.获取执行者对象\r\n        stat = con.createStatement();\r\n\r\n        //4.执行sql语句，并且接收返回的结果集\r\n        String sql = "DELETE FROM student WHERE sid=\'"+id+"\'";\r\n        result = stat.executeUpdate(sql);\r\n\r\n    } catch(Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //6.释放资源\r\n        JDBCUtils.close(con,stat);\r\n    }\r\n    //将结果返回\r\n    return result;\r\n}\r\n```\r\n\r\n#### 3.student表的CRUD整合页面\r\n\r\n- 用户表的数据准备\r\n\r\n```mysql\r\n-- 创建用户表\r\nCREATE TABLE USER(\r\n\tuid VARCHAR(50) PRIMARY KEY,\t-- 用户id\r\n\tucode VARCHAR(50),\t\t\t\t-- 用户标识\r\n\tloginname VARCHAR(100),\t\t\t-- 登录用户名\r\n\tPASSWORD VARCHAR(100),\t\t\t-- 登录密码\r\n\tusername VARCHAR(100),\t\t\t-- 用户名\r\n\tgender VARCHAR(10),\t\t\t\t-- 用户性别\r\n\tbirthday DATE,\t\t\t\t\t-- 出生日期\r\n\tdutydate DATE                   -- 入职日期\r\n);\r\n\r\n-- 添加一条测试数据\r\nINSERT INTO `user` VALUES (\'11111111\', \'zhangsan001\', \'zhangsan\', \'1234\', \'张三\', \'男\', \'2008-10-28\', \'2018-10-28\');\r\n```\r\n\r\n- 将student表的dao层操作复制到项目中的dao层即可\r\n\r\n```java\r\npublic class StudentDaoImpl implements StudentDao {\r\n\r\n    /*\r\n        查询所有学生信息\r\n     */\r\n    @Override\r\n    public ArrayList<Student> findAll() {\r\n        Connection con = null;\r\n        Statement stat = null;\r\n        ResultSet rs = null;\r\n        ArrayList<Student> list = new ArrayList<>();\r\n        try {\r\n            //1.获取连接\r\n            con = JDBCUtils.getConnection();\r\n\r\n            //2.获取执行者对象\r\n            stat = con.createStatement();\r\n\r\n            //3.执行sql语句，并接收结果\r\n            String sql = "SELECT * FROM student";\r\n            rs = stat.executeQuery(sql);\r\n\r\n            //4.处理结果，将每条记录封装成一个Student对象。将多个Student对象保存到集合中\r\n            while(rs.next()) {\r\n                Integer sid = rs.getInt("sid");\r\n                String name = rs.getString("name");\r\n                Integer age = rs.getInt("age");\r\n                Date birthday = rs.getDate("birthday");\r\n\r\n                Student stu = new Student(sid,name,age,birthday);\r\n\r\n                list.add(stu);\r\n            }\r\n\r\n        } catch (SQLException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //5.释放资源\r\n            JDBCUtils.close(con,stat,rs);\r\n        }\r\n\r\n        return list;\r\n    }\r\n\r\n    /*\r\n        条件查询，根据id查询学生信息\r\n     */\r\n    @Override\r\n    public Student findById(Integer id) {\r\n        Connection con = null;\r\n        Statement stat = null;\r\n        ResultSet rs = null;\r\n        Student stu = new Student();\r\n        try {\r\n            //1.获取连接\r\n            con = JDBCUtils.getConnection();\r\n\r\n            //2.获取执行者对象\r\n            stat = con.createStatement();\r\n\r\n            //3.执行sql语句，并接收结果\r\n            String sql = "SELECT * FROM student WHERE sid=\'"+id+"\'";\r\n            rs = stat.executeQuery(sql);\r\n\r\n            //4.处理结果，将记录封装成一个Student对象。\r\n            if(rs.next()) {\r\n                Integer sid = rs.getInt("sid");\r\n                String name = rs.getString("name");\r\n                Integer age = rs.getInt("age");\r\n                Date birthday = rs.getDate("birthday");\r\n\r\n                stu.setSid(sid);\r\n                stu.setName(name);\r\n                stu.setAge(age);\r\n                stu.setBirthday(birthday);\r\n            }\r\n\r\n        } catch (SQLException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //5.释放资源\r\n            JDBCUtils.close(con,stat,rs);\r\n        }\r\n\r\n        return stu;\r\n    }\r\n\r\n    /*\r\n        新增学生信息\r\n     */\r\n    @Override\r\n    public int insert(Student stu) {\r\n        Connection con = null;\r\n        Statement stat = null;\r\n        int result = 0;\r\n        try{\r\n            //1.获取连接\r\n            con = JDBCUtils.getConnection();\r\n\r\n            //2.获取执行者对象\r\n            stat = con.createStatement();\r\n\r\n            //3.执行sql语句，并接收结果\r\n            Date date = stu.getBirthday();\r\n            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");\r\n            String birthday = sdf.format(date);\r\n            String sql = "INSERT INTO student VALUES (null,\'"+stu.getName()+"\',\'"+stu.getAge()+"\',\'"+birthday+"\')";\r\n            result = stat.executeUpdate(sql);\r\n\r\n        } catch (SQLException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //4.释放资源\r\n            JDBCUtils.close(con,stat);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /*\r\n        修改学生信息\r\n     */\r\n    @Override\r\n    public int update(Student stu) {\r\n        Connection con = null;\r\n        Statement stat = null;\r\n        int result = 0;\r\n        try{\r\n            //1.获取连接\r\n            con = JDBCUtils.getConnection();\r\n\r\n            //2.获取执行者对象\r\n            stat = con.createStatement();\r\n\r\n            //3.执行sql语句，并接收结果\r\n            Date date = stu.getBirthday();\r\n            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");\r\n            String birthday = sdf.format(date);\r\n            String sql = "UPDATE student SET sid=\'"+stu.getSid()+"\',name=\'"+stu.getName()+"\',age=\'"+stu.getAge()+"\',birthday=\'"+birthday+"\' WHERE sid=\'"+stu.getSid()+"\'";\r\n            result = stat.executeUpdate(sql);\r\n\r\n        } catch (SQLException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //4.释放资源\r\n            JDBCUtils.close(con,stat);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /*\r\n        删除学生信息\r\n     */\r\n    @Override\r\n    public int delete(Integer id) {\r\n        Connection con = null;\r\n        Statement stat = null;\r\n        int result = 0;\r\n        try{\r\n            //1.获取连接\r\n            con = JDBCUtils.getConnection();\r\n\r\n            //2.获取执行者对象\r\n            stat = con.createStatement();\r\n\r\n            //3.执行sql语句，并接收结果\r\n            String sql = "DELETE FROM student WHERE sid=\'"+id+"\'";\r\n            result = stat.executeUpdate(sql);\r\n\r\n        } catch (SQLException e) {\r\n            e.printStackTrace();\r\n        }  finally {\r\n            //4.释放资源\r\n            JDBCUtils.close(con,stat);\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n### 五、SQL注入攻击\r\n\r\n#### 1.sql注入攻击的演示\r\n\r\n- 在登录界面，输入一个错误的用户名或密码，也可以登录成功\r\n\r\n![06](./JDBC-01-授课笔记.assets/06.png)\r\n\r\n#### 2.sql注入攻击的原理\r\n\r\n- 按照正常道理来说，我们在密码处输入的所有内容，都应该认为是密码的组成\r\n- 但是现在Statement对象在执行sql语句时，将一部分内容当做查询条件来执行了\r\n\r\n#### 3.PreparedStatement的介绍\r\n\r\n- 预编译sql语句的执行者对象。在执行sql语句之前，将sql语句进行提前编译。明确sql语句的格式后，就不会改变了。剩余的内容都会认为是参数！参数使用?作为占位符\r\n- 为参数赋值的方法：setXxx(参数1,参数2);\r\n  - 参数1：?的位置编号(编号从1开始)\r\n  - 参数2：?的实际参数\r\n- 执行sql语句的方法\r\n  - 执行insert、update、delete语句：int executeUpdate();\r\n  - 执行select语句：ResultSet executeQuery();\r\n\r\n#### 4.PreparedStatement的使用\r\n\r\n```java\r\n/*\r\n\t 使用PreparedStatement的登录方法，解决注入攻击\r\n*/\r\n@Override\r\npublic User findByLoginNameAndPassword(String loginName, String password) {\r\n    //定义必要信息\r\n    Connection conn = null;\r\n    PreparedStatement pstm = null;\r\n    ResultSet rs = null;\r\n    User user = null;\r\n    try {\r\n        //1.获取连接\r\n        conn = JDBCUtils.getConnection();\r\n        //2.创建操作SQL对象\r\n        String sql = "SELECT * FROM user WHERE loginname=? AND password=?";\r\n        pstm = conn.prepareStatement(sql);\r\n        //3.设置参数\r\n        pstm.setString(1,loginName);\r\n        pstm.setString(2,password);\r\n        System.out.println(sql);\r\n        //4.执行sql语句，获取结果集\r\n        rs = pstm.executeQuery();\r\n        //5.获取结果集\r\n        if (rs.next()) {\r\n            //6.封装\r\n            user = new User();\r\n            user.setUid(rs.getString("uid"));\r\n            user.setUcode(rs.getString("ucode"));\r\n            user.setUsername(rs.getString("username"));\r\n            user.setPassword(rs.getString("password"));\r\n            user.setGender(rs.getString("gender"));\r\n            user.setDutydate(rs.getDate("dutydate"));\r\n            user.setBirthday(rs.getDate("birthday"));\r\n            user.setLoginname(rs.getString("loginname"));\r\n        }\r\n        //7.返回\r\n        return user;\r\n    }catch (Exception e){\r\n        throw new RuntimeException(e);\r\n    }finally {\r\n        JDBCUtils.close(conn,pstm,rs);\r\n    }\r\n}\r\n```\r\n\r\n#### 5.使用PreparedStatement优化student表的CRUD（作业）\r\n\r\n```java\r\npublic class StudentDaoImpl implements StudentDao {\r\n\r\n    @Override\r\n    public ArrayList<Student> findAll() {\r\n        //定义必要信息\r\n        Connection conn = null;\r\n        PreparedStatement pstm = null;\r\n        ResultSet rs = null;\r\n        ArrayList<Student> students = null;\r\n        try {\r\n            //1.获取连接\r\n            conn = JDBCUtils.getConnection();\r\n            //2.获取操作对象\r\n            pstm = conn.prepareStatement("select * from student");\r\n            //3.执行sql语句，获取结果集\r\n            rs = pstm.executeQuery();\r\n            //4.遍历结果集\r\n            students = new ArrayList<Student>();\r\n            while (rs.next()) {\r\n                //5.封装\r\n                Student student = new Student();\r\n                student.setSid(rs.getInt("sid"));\r\n                student.setName(rs.getString("name"));\r\n                student.setAge(rs.getInt("age"));\r\n                student.setBirthday(rs.getDate("birthday"));\r\n                //加入到集合中\r\n                students.add(student);\r\n            }\r\n            //6.返回\r\n            return students;\r\n        }catch (Exception e){\r\n            throw new RuntimeException(e);\r\n        }finally {\r\n            JDBCUtils.close(conn,pstm,rs);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public Student findById(Integer sid) {\r\n        //定义必要信息\r\n        Connection conn = null;\r\n        PreparedStatement pstm = null;\r\n        ResultSet rs = null;\r\n        Student student = null;\r\n        try {\r\n            //1.获取连接\r\n            conn = JDBCUtils.getConnection();\r\n            //2.获取操作对象\r\n            pstm = conn.prepareStatement("select * from student where sid = ? ");\r\n            pstm.setInt(1,sid);\r\n            //3.执行sql语句，获取结果集\r\n            rs = pstm.executeQuery();\r\n            //4.遍历结果集\r\n            if (rs.next()) {\r\n                //5.封装\r\n                student = new Student();\r\n                student.setSid(rs.getInt("sid"));\r\n                student.setName(rs.getString("name"));\r\n                student.setAge(rs.getInt("age"));\r\n                student.setBirthday(rs.getDate("birthday"));\r\n            }\r\n            //6.返回\r\n            return student;\r\n        }catch (Exception e){\r\n            throw new RuntimeException(e);\r\n        }finally {\r\n            JDBCUtils.close(conn,pstm,rs);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int insert(Student student) {\r\n        //定义必要信息\r\n        Connection conn = null;\r\n        PreparedStatement pstm = null;\r\n        int result = 0;\r\n        try {\r\n            //1.获取连接\r\n            conn = JDBCUtils.getConnection();\r\n            //2.获取操作对象\r\n            pstm = conn.prepareStatement("insert into student(sid,name,age,birthday)values(null,?,?,?)");\r\n            //3.设置参数\r\n            //pstm.setInt(1,null);\r\n            pstm.setString(1,student.getName());\r\n            pstm.setInt(2,student.getAge());\r\n            pstm.setDate(3,new Date(student.getBirthday().getTime()));\r\n            //4.执行sql语句\r\n            result = pstm.executeUpdate();\r\n        }catch (Exception e){\r\n            throw new RuntimeException(e);\r\n        }finally {\r\n            JDBCUtils.close(conn,pstm);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public int update(Student student) {\r\n        //定义必要信息\r\n        Connection conn = null;\r\n        PreparedStatement pstm = null;\r\n        int result = 0;\r\n        try {\r\n            //1.获取连接\r\n            conn = JDBCUtils.getConnection();\r\n            //2.获取操作对象\r\n            pstm = conn.prepareStatement("update student set name=?,age=?,birthday=? where sid=? ");\r\n            //3.设置参数\r\n            pstm.setString(1,student.getName());\r\n            pstm.setInt(2,student.getAge());\r\n            pstm.setDate(3,new Date(student.getBirthday().getTime()));\r\n            pstm.setInt(4,student.getSid());\r\n            //4.执行sql语句\r\n            result = pstm.executeUpdate();\r\n        }catch (Exception e){\r\n            throw new RuntimeException(e);\r\n        }finally {\r\n            JDBCUtils.close(conn,pstm);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public int delete(Integer sid) {\r\n        //定义必要信息\r\n        Connection conn = null;\r\n        PreparedStatement pstm = null;\r\n        int result = 0;\r\n        try {\r\n            //1.获取连接\r\n            conn = JDBCUtils.getConnection();\r\n            //2.获取操作对象\r\n            pstm = conn.prepareStatement("delete from student where sid=? ");\r\n            //3.设置参数\r\n            pstm.setInt(1,sid);\r\n            //4.执行sql语句\r\n            result = pstm.executeUpdate();\r\n        }catch (Exception e){\r\n            throw new RuntimeException(e);\r\n        }finally {\r\n            JDBCUtils.close(conn,pstm);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n### 六、综合案例-课程表批量新增加事务管理\r\n\r\n#### 1.service层\r\n\r\n- 接口\r\n\r\n```java\r\n/*\r\n\t 批量添加\r\n*/\r\nvoid batchAdd(List<User> users);\r\n```\r\n\r\n- 实现类\r\n\r\n```java\r\n/*\r\n      事务要控制在此处\r\n*/\r\n@Override\r\npublic void batchAdd(List<User> users) {\r\n    //获取数据库连接\r\n    Connection connection = JDBCUtils.getConnection();\r\n    try {\r\n        //开启事务\r\n        connection.setAutoCommit(false);\r\n        for (User user : users) {\r\n            //1.创建ID,并把UUID中的-替换\r\n            String uid = UUID.randomUUID().toString().replace("-", "").toUpperCase();\r\n            //2.给user的uid赋值\r\n            user.setUid(uid);\r\n            //3.生成员工编号\r\n            user.setUcode(uid);\r\n\r\n            //模拟异常\r\n            //int n = 1 / 0;\r\n\r\n            //4.保存\r\n            userDao.save(connection,user);\r\n        }\r\n        //提交事务\r\n        connection.commit();\r\n    }catch (Exception e){\r\n        try {\r\n            //回滚事务\r\n            connection.rollback();\r\n        }catch (Exception ex){\r\n            ex.printStackTrace();\r\n        }\r\n        e.printStackTrace();\r\n    }finally {\r\n        JDBCUtils.close(connection,null,null);\r\n    }\r\n}\r\n```\r\n\r\n#### 2.dao层\r\n\r\n- 接口\r\n\r\n```java\r\n/**\r\n\t支持事务的添加\r\n*/\r\nvoid save(Connection connection,User user);\r\n```\r\n\r\n- 实现类\r\n\r\n```java\r\n/*\r\n       支持事务的添加\r\n*/\r\n@Override\r\npublic void save(Connection connection, User user) {\r\n    //定义必要信息\r\n    PreparedStatement pstm = null;\r\n    try {\r\n        //1.获取连接\r\n        connection = JDBCUtils.getConnection();\r\n        //2.获取操作对象\r\n        pstm = connection.prepareStatement("insert into user(uid,ucode,loginname,password,username,gender,birthday,dutydate)values(?,?,?,?,?,?,?,?)");\r\n        //3.设置参数\r\n        pstm.setString(1,user.getUid());\r\n        pstm.setString(2,user.getUcode());\r\n        pstm.setString(3,user.getLoginname());\r\n        pstm.setString(4,user.getPassword());\r\n        pstm.setString(5,user.getUsername());\r\n        pstm.setString(6,user.getGender());\r\n        pstm.setDate(7,new Date(user.getBirthday().getTime()));\r\n        pstm.setDate(8,new Date(user.getDutydate().getTime()));\r\n        //4.执行sql语句，获取结果集\r\n        pstm.executeUpdate();\r\n    }catch (Exception e){\r\n        throw new RuntimeException(e);\r\n    }finally {\r\n        JDBCUtils.close(null,pstm,null);\r\n    }\r\n}\r\n```\r\n\r\n'},f335:function(n,e,t){"use strict";t.r(e),e["default"]='点击关注[公众号](#公众号)及时获取笔主最新更新文章，并可免费领取本文档配套的《Java面试突击》以及Java工程师必备学习资源。\n\n随着 Java 8 的普及度越来越高，很多人都提到面试中关于Java 8 也是非常常问的知识点。应各位要求和需要，我打算对这部分知识做一个总结。本来准备自己总结的，后面看到Github 上有一个相关的仓库，地址：\n[https://github.com/winterbe/java8-tutorial](https://github.com/winterbe/java8-tutorial)。这个仓库是英文的，我对其进行了翻译并添加和修改了部分内容，下面是正文了。\n\n\x3c!-- MarkdownTOC --\x3e\n\n- [Java 8 Tutorial](#java-8-tutorial)\n    - [接口的默认方法\\(Default Methods for Interfaces\\)](#接口的默认方法default-methods-for-interfaces)\n    - [Lambda表达式\\(Lambda expressions\\)](#lambda表达式lambda-expressions)\n    - [函数式接口\\(Functional Interfaces\\)](#函数式接口functional-interfaces)\n    - [方法和构造函数引用\\(Method and Constructor References\\)](#方法和构造函数引用method-and-constructor-references)\n    - [Lamda 表达式作用域\\(Lambda Scopes\\)](#lamda-表达式作用域lambda-scopes)\n      - [访问局部变量](#访问局部变量)\n      - [访问字段和静态变量](#访问字段和静态变量)\n      - [访问默认接口方法](#访问默认接口方法)\n    - [内置函数式接口\\(Built-in Functional Interfaces\\)](#内置函数式接口built-in-functional-interfaces)\n      - [Predicate](#predicate)\n      - [Function](#function)\n      - [Supplier](#supplier)\n      - [Consumer](#consumer)\n      - [Comparator](#comparator)\n  - [Optional](#optional)\n  - [Streams\\(流\\)](#streams流)\n    - [Filter\\(过滤\\)](#filter过滤)\n    - [Sorted\\(排序\\)](#sorted排序)\n    - [Map\\(映射\\)](#map映射)\n    - [Match\\(匹配\\)](#match匹配)\n    - [Count\\(计数\\)](#count计数)\n    - [Reduce\\(规约\\)](#reduce规约)\n  - [Parallel Streams\\(并行流\\)](#parallel-streams并行流)\n    - [Sequential Sort\\(串行排序\\)](#sequential-sort串行排序)\n    - [Parallel Sort\\(并行排序\\)](#parallel-sort并行排序)\n  - [Maps](#maps)\n  - [Date API\\(日期相关API\\)](#date-api日期相关api)\n    - [Clock](#clock)\n    - [Timezones\\(时区\\)](#timezones时区)\n    - [LocalTime\\(本地时间\\)](#localtime本地时间)\n    - [LocalDate\\(本地日期\\)](#localdate本地日期)\n    - [LocalDateTime\\(本地日期时间\\)](#localdatetime本地日期时间)\n  - [Annotations\\(注解\\)](#annotations注解)\n  - [Where to go from here?](#where-to-go-from-here)\n\n\x3c!-- /MarkdownTOC --\x3e\n\n\n# Java 8 Tutorial \n\n欢迎阅读我对Java 8的介绍。本教程将逐步指导您完成所有新语言功能。 在简短的代码示例的基础上，您将学习如何使用默认接口方法，lambda表达式，方法引用和可重复注释。 在本文的最后，您将熟悉最新的 API 更改，如流，函数式接口(Functional Interfaces)，Map 类的扩展和新的 Date API。 没有大段枯燥的文字，只有一堆注释的代码片段。\n\n\n### 接口的默认方法(Default Methods for Interfaces)\n\nJava 8使我们能够通过使用 `default` 关键字向接口添加非抽象方法实现。 此功能也称为[虚拟扩展方法](http://stackoverflow.com/a/24102730)。\n\n第一个例子：\n\n```java\ninterface Formula{\n\n    double calculate(int a);\n\n    default double sqrt(int a) {\n        return Math.sqrt(a);\n    }\n\n}\n```\n\nFormula 接口中除了抽象方法计算接口公式还定义了默认方法 `sqrt`。 实现该接口的类只需要实现抽象方法 `calculate`。 默认方法`sqrt` 可以直接使用。当然你也可以直接通过接口创建对象，然后实现接口中的默认方法就可以了，我们通过代码演示一下这种方式。\n\n```java\npublic class Main {\n\n  public static void main(String[] args) {\n    // 通过匿名内部类方式访问接口\n    Formula formula = new Formula() {\n        @Override\n        public double calculate(int a) {\n            return sqrt(a * 100);\n        }\n    };\n\n    System.out.println(formula.calculate(100));     // 100.0\n    System.out.println(formula.sqrt(16));           // 4.0\n\n  }\n\n}\n```\n\n formula 是作为匿名对象实现的。该代码非常容易理解，6行代码实现了计算 `sqrt(a * 100)`。在下一节中，我们将会看到在 Java 8 中实现单个方法对象有一种更好更方便的方法。\n\n**译者注：** 不管是抽象类还是接口，都可以通过匿名内部类的方式访问。不能通过抽象类或者接口直接创建对象。对于上面通过匿名内部类方式访问接口，我们可以这样理解：一个内部类实现了接口里的抽象方法并且返回一个内部类对象，之后我们让接口的引用来指向这个对象。\n\n### Lambda表达式(Lambda expressions)\n\n首先看看在老版本的Java中是如何排列字符串的：\n\n```java\nList<String> names = Arrays.asList("peter", "anna", "mike", "xenia");\n\nCollections.sort(names, new Comparator<String>() {\n    @Override\n    public int compare(String a, String b) {\n        return b.compareTo(a);\n    }\n});\n```\n\n只需要给静态方法` Collections.sort` 传入一个 List 对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给 `sort` 方法。\n\n在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：\n\n```java\nCollections.sort(names, (String a, String b) -> {\n    return b.compareTo(a);\n});\n```\n\n可以看出，代码变得更短且更具有可读性，但是实际上还可以写得更短：\n\n```java\nCollections.sort(names, (String a, String b) -> b.compareTo(a));\n```\n\n对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点：\n\n```java\nnames.sort((a, b) -> b.compareTo(a));\n```\n\nList 类本身就有一个 `sort` 方法。并且Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还有什么其他用法。\n\n### 函数式接口(Functional Interfaces)\n\n**译者注：** 原文对这部分解释不太清楚，故做了修改！\n\nJava 语言设计者们投入了大量精力来思考如何使现有的函数友好地支持Lambda。最终采取的方法是：增加函数式接口的概念。**“函数式接口”是指仅仅只包含一个抽象方法,但是可以有多个非抽象方法(也就是上面提到的默认方法)的接口。** 像这样的接口，可以被隐式转换为lambda表达式。`java.lang.Runnable` 与 `java.util.concurrent.Callable` 是函数式接口最典型的两个例子。Java 8增加了一种特殊的注解`@FunctionalInterface`,但是这个注解通常不是必须的(某些情况建议使用)，只要接口只包含一个抽象方法，虚拟机会自动判断该接口为函数式接口。一般建议在接口上使用`@FunctionalInterface` 注解进行声明，这样的话，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的，如下图所示\n\n![@FunctionalInterface 注解](Java8新特性总结.assets/@FunctionalInterface.png)\n\n示例：\n\n```java\n@FunctionalInterface\npublic interface Converter<F, T> {\n  T convert(F from);\n}\n```\n\n```java\n    // TODO 将数字字符串转换为整数类型\n    Converter<String, Integer> converter = (from) -> Integer.valueOf(from);\n    Integer converted = converter.convert("123");\n    System.out.println(converted.getClass()); //class java.lang.Integer\n```\n\n**译者注：** 大部分函数式接口都不用我们自己写，Java8都给我们实现好了，这些接口都在java.util.function包里。\n\n### 方法和构造函数引用(Method and Constructor References)\n\n前一节中的代码还可以通过静态方法引用来表示：\n\n```java\n    Converter<String, Integer> converter = Integer::valueOf;\n    Integer converted = converter.convert("123");\n    System.out.println(converted.getClass());   //class java.lang.Integer\n```\nJava 8允许您通过`::`关键字传递方法或构造函数的引用。 上面的示例显示了如何引用静态方法。 但我们也可以引用对象方法：\n\n```java\nclass Something {\n    String startsWith(String s) {\n        return String.valueOf(s.charAt(0));\n    }\n}\n```\n\n```java\nSomething something = new Something();\nConverter<String, String> converter = something::startsWith;\nString converted = converter.convert("Java");\nSystem.out.println(converted);    // "J"\n```\n\n接下来看看构造函数是如何使用`::`关键字来引用的，首先我们定义一个包含多个构造函数的简单类：\n\n```java\nclass Person {\n    String firstName;\n    String lastName;\n\n    Person() {}\n\n    Person(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n    }\n}\n```\n接下来我们指定一个用来创建Person对象的对象工厂接口：\n\n```java\ninterface PersonFactory<P extends Person> {\n    P create(String firstName, String lastName);\n}\n```\n\n这里我们使用构造函数引用来将他们关联起来，而不是手动实现一个完整的工厂：\n\n```java\nPersonFactory<Person> personFactory = Person::new;\nPerson person = personFactory.create("Peter", "Parker");\n```\n我们只需要使用 `Person::new` 来获取Person类构造函数的引用，Java编译器会自动根据`PersonFactory.create`方法的参数类型来选择合适的构造函数。\n\n### Lambda 表达式作用域(Lambda Scopes)\n\n#### 访问局部变量\n\n我们可以直接在 lambda 表达式中访问外部的局部变量：\n\n```java\nfinal int num = 1;\nConverter<Integer, String> stringConverter =\n        (from) -> String.valueOf(from + num);\n\nstringConverter.convert(2);     // 3\n```\n\n但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确：\n\n```java\nint num = 1;\nConverter<Integer, String> stringConverter =\n        (from) -> String.valueOf(from + num);\n\nstringConverter.convert(2);     // 3\n```\n\n不过这里的 num 必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译：\n\n```java\nint num = 1;\nConverter<Integer, String> stringConverter =\n        (from) -> String.valueOf(from + num);\nnum = 3;//在lambda表达式中试图修改num同样是不允许的。\n```\n\n#### 访问字段和静态变量\n\n与局部变量相比，我们对lambda表达式中的实例字段和静态变量都有读写访问权限。 该行为和匿名对象是一致的。\n\n```java\nclass Lambda4 {\n    static int outerStaticNum;\n    int outerNum;\n\n    void testScopes() {\n        Converter<Integer, String> stringConverter1 = (from) -> {\n            outerNum = 23;\n            return String.valueOf(from);\n        };\n\n        Converter<Integer, String> stringConverter2 = (from) -> {\n            outerStaticNum = 72;\n            return String.valueOf(from);\n        };\n    }\n}\n```\n\n#### 访问默认接口方法\n\n还记得第一节中的 formula 示例吗？ `Formula` 接口定义了一个默认方法`sqrt`，可以从包含匿名对象的每个 formula 实例访问该方法。 这不适用于lambda表达式。\n\n无法从 lambda 表达式中访问默认方法,故以下代码无法编译：\n\n```java\nFormula formula = (a) -> sqrt(a * 100);\n```\n\n### 内置函数式接口(Built-in Functional Interfaces)\n\nJDK 1.8 API包含许多内置函数式接口。 其中一些接口在老版本的 Java 中是比较常见的比如： `Comparator` 或`Runnable`，这些接口都增加了`@FunctionalInterface`注解以便能用在 lambda 表达式上。\n\n但是 Java 8 API 同样还提供了很多全新的函数式接口来让你的编程工作更加方便，有一些接口是来自 [Google Guava](https://code.google.com/p/guava-libraries/) 库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。\n\n#### Predicate\n\nPredicate 接口是只有一个参数的返回布尔类型值的 **断言型** 接口。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）：\n\n**译者注：** Predicate 接口源码如下\n\n```java\npackage java.util.function;\nimport java.util.Objects;\n\n@FunctionalInterface\npublic interface Predicate<T> {\n    \n    // 该方法是接受一个传入类型,返回一个布尔值.此方法应用于判断.\n    boolean test(T t);\n\n    //and方法与关系型运算符"&&"相似，两边都成立才返回true\n    default Predicate<T> and(Predicate<? super T> other) {\n        Objects.requireNonNull(other);\n        return (t) -> test(t) && other.test(t);\n    }\n    // 与关系运算符"!"相似，对判断进行取反\n    default Predicate<T> negate() {\n        return (t) -> !test(t);\n    }\n    //or方法与关系型运算符"||"相似，两边只要有一个成立就返回true\n    default Predicate<T> or(Predicate<? super T> other) {\n        Objects.requireNonNull(other);\n        return (t) -> test(t) || other.test(t);\n    }\n   // 该方法接收一个Object对象,返回一个Predicate类型.此方法用于判断第一个test的方法与第二个test方法相同(equal).\n    static <T> Predicate<T> isEqual(Object targetRef) {\n        return (null == targetRef)\n                ? Objects::isNull\n                : object -> targetRef.equals(object);\n    }\n```\n\n示例：\n\n```java\nPredicate<String> predicate = (s) -> s.length() > 0;\n\npredicate.test("foo");              // true\npredicate.negate().test("foo");     // false\n\nPredicate<Boolean> nonNull = Objects::nonNull;\nPredicate<Boolean> isNull = Objects::isNull;\n\nPredicate<String> isEmpty = String::isEmpty;\nPredicate<String> isNotEmpty = isEmpty.negate();\n```\n\n#### Function\n\nFunction 接口接受一个参数并生成结果。默认方法可用于将多个函数链接在一起（compose, andThen）：\n\n**译者注：** Function  接口源码如下\n\n```java\n\npackage java.util.function;\n \nimport java.util.Objects;\n \n@FunctionalInterface\npublic interface Function<T, R> {\n    \n    //将Function对象应用到输入的参数上，然后返回计算结果。\n    R apply(T t);\n    //将两个Function整合，并返回一个能够执行两个Function对象功能的Function对象。\n    default <V> Function<V, R> compose(Function<? super V, ? extends T> before) {\n        Objects.requireNonNull(before);\n        return (V v) -> apply(before.apply(v));\n    }\n    // \n    default <V> Function<T, V> andThen(Function<? super R, ? extends V> after) {\n        Objects.requireNonNull(after);\n        return (T t) -> after.apply(apply(t));\n    }\n \n    static <T> Function<T, T> identity() {\n        return t -> t;\n    }\n}\n```\n\n\n\n```java\nFunction<String, Integer> toInteger = Integer::valueOf;\nFunction<String, String> backToString = toInteger.andThen(String::valueOf);\nbackToString.apply("123");     // "123"\n```\n\n#### Supplier\n\nSupplier 接口产生给定泛型类型的结果。 与 Function 接口不同，Supplier 接口不接受参数。\n\n```java\nSupplier<Person> personSupplier = Person::new;\npersonSupplier.get();   // new Person\n```\n\n#### Consumer\n\nConsumer 接口表示要对单个输入参数执行的操作。\n\n```java\nConsumer<Person> greeter = (p) -> System.out.println("Hello, " + p.firstName);\ngreeter.accept(new Person("Luke", "Skywalker"));\n```\n\n#### Comparator\n\nComparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法：\n\n```java\nComparator<Person> comparator = (p1, p2) -> p1.firstName.compareTo(p2.firstName);\n\nPerson p1 = new Person("John", "Doe");\nPerson p2 = new Person("Alice", "Wonderland");\n\ncomparator.compare(p1, p2);             // > 0\ncomparator.reversed().compare(p1, p2);  // < 0\n```\n\n## Optional\n\nOptional不是函数式接口，而是用于防止 NullPointerException 的漂亮工具。这是下一节的一个重要概念，让我们快速了解一下Optional的工作原理。\n\nOptional 是一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是有时却什么也没有返回，而在Java 8中，你应该返回 Optional 而不是 null。\n\n译者注：示例中每个方法的作用已经添加。\n\n```java\n//of()：为非null的值创建一个Optional\nOptional<String> optional = Optional.of("bam");\n// isPresent()： 如果值存在返回true，否则返回false\noptional.isPresent();           // true\n//get()：如果Optional有值则将其返回，否则抛出NoSuchElementException\noptional.get();                 // "bam"\n//orElse()：如果有值则将其返回，否则返回指定的其它值\noptional.orElse("fallback");    // "bam"\n//ifPresent()：如果Optional实例有值则为其调用consumer，否则不做处理\noptional.ifPresent((s) -> System.out.println(s.charAt(0)));     // "b"\n```\n\n推荐阅读：[[Java8]如何正确使用Optional](https://blog.kaaass.net/archives/764)\n\n## Streams(流)\n\n`java.util.Stream` 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如` java.util.Collection` 的子类，List 或者 Set， Map 不支持。Stream 的操作可以串行执行或者并行执行。\n\n首先看看Stream是怎么用，首先创建实例代码需要用到的数据List：\n\n```java\nList<String> stringList = new ArrayList<>();\nstringList.add("ddd2");\nstringList.add("aaa2");\nstringList.add("bbb1");\nstringList.add("aaa1");\nstringList.add("bbb3");\nstringList.add("ccc");\nstringList.add("bbb2");\nstringList.add("ddd1");\n```\n\nJava 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。下面几节将详细解释常用的Stream操作：\n\n### Filter(过滤)\n\n过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于**中间操作**，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。\n\n```java\n        // 测试 Filter(过滤)\n        stringList\n                .stream()\n                .filter((s) -> s.startsWith("a"))\n                .forEach(System.out::println);//aaa2 aaa1\n```\n\nforEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。\n\n### Sorted(排序)\n\n排序是一个 **中间操作**，返回的是排序好后的 Stream。**如果你不指定一个自定义的 Comparator 则会使用默认排序。**\n\n```java\n        // 测试 Sort (排序)\n        stringList\n                .stream()\n                .sorted()\n                .filter((s) -> s.startsWith("a"))\n                .forEach(System.out::println);// aaa1 aaa2\n```\n\n需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringList是不会被修改的：\n\n```java\n    System.out.println(stringList);// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1\n```\n\n### Map(映射)\n\n中间操作 map 会将元素根据指定的 Function 接口来依次将元素转成另外的对象。\n\n下面的示例展示了将字符串转换为大写字符串。你也可以通过map来将对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。\n\n```java\n        // 测试 Map 操作\n        stringList\n                .stream()\n                .map(String::toUpperCase)\n                .sorted((a, b) -> b.compareTo(a))\n                .forEach(System.out::println);// "DDD2", "DDD1", "CCC", "BBB3", "BBB2", "BBB1", "AAA2", "AAA1"\n```\n\n\n\n### Match(匹配)\n\nStream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是 **最终操作** ，并返回一个 boolean 类型的值。\n\n```java\n        // 测试 Match (匹配)操作\n        boolean anyStartsWithA =\n                stringList\n                        .stream()\n                        .anyMatch((s) -> s.startsWith("a"));\n        System.out.println(anyStartsWithA);      // true\n\n        boolean allStartsWithA =\n                stringList\n                        .stream()\n                        .allMatch((s) -> s.startsWith("a"));\n\n        System.out.println(allStartsWithA);      // false\n\n        boolean noneStartsWithZ =\n                stringList\n                        .stream()\n                        .noneMatch((s) -> s.startsWith("z"));\n\n        System.out.println(noneStartsWithZ);      // true\n```\n\n\n\n### Count(计数)\n\n计数是一个 **最终操作**，返回Stream中元素的个数，**返回值类型是 long**。\n\n```java\n      //测试 Count (计数)操作\n        long startsWithB =\n                stringList\n                        .stream()\n                        .filter((s) -> s.startsWith("b"))\n                        .count();\n        System.out.println(startsWithB);    // 3\n```\n\n### Reduce(规约)\n\n这是一个 **最终操作** ，允许通过指定的函数来将stream中的多个元素规约为一个元素，规约后的结果是通过Optional 接口表示的：\n\n```java\n        //测试 Reduce (规约)操作\n        Optional<String> reduced =\n                stringList\n                        .stream()\n                        .sorted()\n                        .reduce((s1, s2) -> s1 + "#" + s2);\n\n        reduced.ifPresent(System.out::println);//aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2\n```\n\n\n\n**译者注：** 这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于`Integer sum = integers.reduce(0, (a, b) -> a+b);`也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。\n\n```java\n// 字符串连接，concat = "ABCD"\nString concat = Stream.of("A", "B", "C", "D").reduce("", String::concat); \n// 求最小值，minValue = -3.0\ndouble minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min); \n// 求和，sumValue = 10, 有起始值\nint sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);\n// 求和，sumValue = 10, 无起始值\nsumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();\n// 过滤，字符串连接，concat = "ace"\nconcat = Stream.of("a", "B", "c", "D", "e", "F").\n filter(x -> x.compareTo("Z") > 0).\n reduce("", String::concat);\n```\n\n上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。更多内容查看： [IBM：Java 8 中的 Streams API 详解](https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html) \n\n## Parallel Streams(并行流)\n\n前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。\n\n下面的例子展示了是如何通过并行Stream来提升性能：\n\n首先我们创建一个没有重复元素的大表：\n\n```java\nint max = 1000000;\nList<String> values = new ArrayList<>(max);\nfor (int i = 0; i < max; i++) {\n    UUID uuid = UUID.randomUUID();\n    values.add(uuid.toString());\n}\n```\n\n我们分别用串行和并行两种方式对其进行排序，最后看看所用时间的对比。\n\n### Sequential Sort(串行排序)\n\n```java\n//串行排序\nlong t0 = System.nanoTime();\nlong count = values.stream().sorted().count();\nSystem.out.println(count);\n\nlong t1 = System.nanoTime();\n\nlong millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);\nSystem.out.println(String.format("sequential sort took: %d ms", millis));\n```\n\n```\n1000000\nsequential sort took: 709 ms//串行排序所用的时间\n```\n\n### Parallel Sort(并行排序)\n\n```java\n//并行排序\nlong t0 = System.nanoTime();\n\nlong count = values.parallelStream().sorted().count();\nSystem.out.println(count);\n\nlong t1 = System.nanoTime();\n\nlong millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);\nSystem.out.println(String.format("parallel sort took: %d ms", millis));\n\n```\n\n```java\n1000000\nparallel sort took: 475 ms//串行排序所用的时间\n```\n\n上面两个代码几乎是一样的，但是并行版的快了 50% 左右，唯一需要做的改动就是将 `stream()` 改为`parallelStream()`。\n\n## Maps\n\n前面提到过，Map 类型不支持 streams，不过Map提供了一些新的有用的方法来处理一些日常任务。Map接口本身没有可用的 `stream()`方法，但是你可以在键，值上创建专门的流或者通过 `map.keySet().stream()`,`map.values().stream()`和`map.entrySet().stream()`。\n\n此外,Maps 支持各种新的和有用的方法来执行常见任务。\n\n```java\nMap<Integer, String> map = new HashMap<>();\n\nfor (int i = 0; i < 10; i++) {\n    map.putIfAbsent(i, "val" + i);\n}\n\nmap.forEach((id, val) -> System.out.println(val));//val0 val1 val2 val3 val4 val5 val6 val7 val8 val9\n```\n\n`putIfAbsent` 阻止我们在null检查时写入额外的代码;`forEach`接受一个 consumer 来对 map 中的每个元素操作。\n\n此示例显示如何使用函数在 map 上计算代码：\n\n```java\nmap.computeIfPresent(3, (num, val) -> val + num);\nmap.get(3);             // val33\n\nmap.computeIfPresent(9, (num, val) -> null);\nmap.containsKey(9);     // false\n\nmap.computeIfAbsent(23, num -> "val" + num);\nmap.containsKey(23);    // true\n\nmap.computeIfAbsent(3, num -> "bam");\nmap.get(3);             // val33\n```\n\n接下来展示如何在Map里删除一个键值全都匹配的项：\n\n```java\nmap.remove(3, "val3");\nmap.get(3);             // val33\nmap.remove(3, "val33");\nmap.get(3);             // null\n```\n\n另外一个有用的方法：\n\n```java\nmap.getOrDefault(42, "not found");  // not found\n```\n\n对Map的元素做合并也变得很容易了：\n\n```java\nmap.merge(9, "val9", (value, newValue) -> value.concat(newValue));\nmap.get(9);             // val9\nmap.merge(9, "concat", (value, newValue) -> value.concat(newValue));\nmap.get(9);             // val9concat\n```\n\nMerge 做的事情是如果键名不存在则插入，否则对原键对应的值做合并操作并重新插入到map中。\n\n## Date API(日期相关API)\n\nJava 8在 `java.time` 包下包含一个全新的日期和时间API。新的Date API与Joda-Time库相似，但它们不一样。以下示例涵盖了此新 API 的最重要部分。译者对这部分内容参考相关书籍做了大部分修改。\n\n**译者注(总结)：**\n\n- Clock 类提供了访问当前日期和时间的方法，Clock 是时区敏感的，可以用来取代 `System.currentTimeMillis()` 来获取当前的微秒数。某一个特定的时间点也可以使用 `Instant` 类来表示，`Instant` 类也可以用来创建旧版本的`java.util.Date` 对象。\n\n- 在新API中时区使用 ZoneId 来表示。时区可以很方便的使用静态方法of来获取到。 抽象类`ZoneId`（在`java.time`包中）表示一个区域标识符。 它有一个名为`getAvailableZoneIds`的静态方法，它返回所有区域标识符。\n\n- jdk1.8中新增了 LocalDate 与 LocalDateTime等类来解决日期处理方法，同时引入了一个新的类DateTimeFormatter 来解决日期格式化问题。可以使用Instant代替 Date，LocalDateTime代替 Calendar，DateTimeFormatter 代替 SimpleDateFormat。\n\n  \n\n### Clock\n\nClock 类提供了访问当前日期和时间的方法，Clock 是时区敏感的，可以用来取代 `System.currentTimeMillis()` 来获取当前的微秒数。某一个特定的时间点也可以使用 `Instant` 类来表示，`Instant` 类也可以用来创建旧版本的`java.util.Date` 对象。\n\n```java\nClock clock = Clock.systemDefaultZone();\nlong millis = clock.millis();\nSystem.out.println(millis);//1552379579043\nInstant instant = clock.instant();\nSystem.out.println(instant);\nDate legacyDate = Date.from(instant); //2019-03-12T08:46:42.588Z\nSystem.out.println(legacyDate);//Tue Mar 12 16:32:59 CST 2019\n```\n\n### Timezones(时区)\n\n在新API中时区使用 ZoneId 来表示。时区可以很方便的使用静态方法of来获取到。 抽象类`ZoneId`（在`java.time`包中）表示一个区域标识符。 它有一个名为`getAvailableZoneIds`的静态方法，它返回所有区域标识符。\n\n```java\n//输出所有区域标识符\nSystem.out.println(ZoneId.getAvailableZoneIds());\n\nZoneId zone1 = ZoneId.of("Europe/Berlin");\nZoneId zone2 = ZoneId.of("Brazil/East");\nSystem.out.println(zone1.getRules());// ZoneRules[currentStandardOffset=+01:00]\nSystem.out.println(zone2.getRules());// ZoneRules[currentStandardOffset=-03:00]\n```\n\n### LocalTime(本地时间)\n\nLocalTime 定义了一个没有时区信息的时间，例如 晚上10点或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：\n\n```java\nLocalTime now1 = LocalTime.now(zone1);\nLocalTime now2 = LocalTime.now(zone2);\nSystem.out.println(now1.isBefore(now2));  // false\n\nlong hoursBetween = ChronoUnit.HOURS.between(now1, now2);\nlong minutesBetween = ChronoUnit.MINUTES.between(now1, now2);\n\nSystem.out.println(hoursBetween);       // -3\nSystem.out.println(minutesBetween);     // -239\n```\n\nLocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串.\n\n```java\nLocalTime late = LocalTime.of(23, 59, 59);\nSystem.out.println(late);       // 23:59:59\nDateTimeFormatter germanFormatter =\n    DateTimeFormatter\n        .ofLocalizedTime(FormatStyle.SHORT)\n        .withLocale(Locale.GERMAN);\n\nLocalTime leetTime = LocalTime.parse("13:37", germanFormatter);\nSystem.out.println(leetTime);   // 13:37\n```\n\n### LocalDate(本地日期)\n\nLocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。\n\n```java\nLocalDate today = LocalDate.now();//获取现在的日期\nSystem.out.println("今天的日期: "+today);//2019-03-12\nLocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);\nSystem.out.println("明天的日期: "+tomorrow);//2019-03-13\nLocalDate yesterday = tomorrow.minusDays(2);\nSystem.out.println("昨天的日期: "+yesterday);//2019-03-11\nLocalDate independenceDay = LocalDate.of(2019, Month.MARCH, 12);\nDayOfWeek dayOfWeek = independenceDay.getDayOfWeek();\nSystem.out.println("今天是周几:"+dayOfWeek);//TUESDAY\n```\n\n从字符串解析一个 LocalDate 类型和解析 LocalTime 一样简单,下面是使用  `DateTimeFormatter` 解析字符串的例子：\n\n```java\n    String str1 = "2014==04==12 01时06分09秒";\n        // 根据需要解析的日期、时间字符串定义解析所用的格式器\n        DateTimeFormatter fomatter1 = DateTimeFormatter\n                .ofPattern("yyyy==MM==dd HH时mm分ss秒");\n\n        LocalDateTime dt1 = LocalDateTime.parse(str1, fomatter1);\n        System.out.println(dt1); // 输出 2014-04-12T01:06:09\n\n        String str2 = "2014$$$四月$$$13 20小时";\n        DateTimeFormatter fomatter2 = DateTimeFormatter\n                .ofPattern("yyy$$$MMM$$$dd HH小时");\n        LocalDateTime dt2 = LocalDateTime.parse(str2, fomatter2);\n        System.out.println(dt2); // 输出 2014-04-13T20:00\n\n```\n\n再来看一个使用 `DateTimeFormatter` 格式化日期的示例\n\n```java\nLocalDateTime rightNow=LocalDateTime.now();\nString date=DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(rightNow);\nSystem.out.println(date);//2019-03-12T16:26:48.29\nDateTimeFormatter formatter=DateTimeFormatter.ofPattern("YYYY-MM-dd HH:mm:ss");\nSystem.out.println(formatter.format(rightNow));//2019-03-12 16:26:48\n```\n\n**🐛 修正（参见： [issue#1157](https://github.com/Snailclimb/JavaGuide/issues/1157)）**：使用 `YYYY` 显示年份时，会显示当前时间所在周的年份，在跨年周会有问题。一般情况下都使用 `yyyy`，来显示准确的年份。\n\n跨年导致日期显示错误示例：\n\n```java\nLocalDateTime rightNow = LocalDateTime.of(2020, 12, 31, 12, 0, 0);\nString date= DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(rightNow);\n// 2020-12-31T12:00:00\nSystem.out.println(date);\nDateTimeFormatter formatterOfYYYY = DateTimeFormatter.ofPattern("YYYY-MM-dd HH:mm:ss");\n// 2021-12-31 12:00:00\nSystem.out.println(formatterOfYYYY.format(rightNow));\n\nDateTimeFormatter formatterOfYyyy = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");\n// 2020-12-31 12:00:00\nSystem.out.println(formatterOfYyyy.format(rightNow));\n```\n\n从下图可以更清晰的看到具体的错误，并且 IDEA 已经智能地提示更倾向于使用  `yyyy` 而不是  `YYYY` 。\n\n![](Java8新特性总结.assets/2021042717491413.png)\n\n### LocalDateTime(本地日期时间)\n\nLocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime 和 LocalTime还有 LocalDate 一样，都是不可变的。LocalDateTime 提供了一些能访问具体字段的方法。\n\n```java\nLocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);\n\nDayOfWeek dayOfWeek = sylvester.getDayOfWeek();\nSystem.out.println(dayOfWeek);      // WEDNESDAY\n\nMonth month = sylvester.getMonth();\nSystem.out.println(month);          // DECEMBER\n\nlong minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);\nSystem.out.println(minuteOfDay);    // 1439\n```\n\n只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的`java.util.Date`。\n\n```java\nInstant instant = sylvester\n        .atZone(ZoneId.systemDefault())\n        .toInstant();\n\nDate legacyDate = Date.from(instant);\nSystem.out.println(legacyDate);     // Wed Dec 31 23:59:59 CET 2014\n```\n\n格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式：\n\n```java\nDateTimeFormatter formatter =\n    DateTimeFormatter\n        .ofPattern("MMM dd, yyyy - HH:mm");\nLocalDateTime parsed = LocalDateTime.parse("Nov 03, 2014 - 07:13", formatter);\nString string = formatter.format(parsed);\nSystem.out.println(string);     // Nov 03, 2014 - 07:13\n```\n\n和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。\n关于时间日期格式的详细信息在[这里](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html)。\n\n## Annotations(注解)\n\n在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。\n首先定义一个包装类Hints注解用来放置一组具体的Hint注解：\n\n```java\n@Retention(RetentionPolicy.RUNTIME)\n@interface Hints {\n    Hint[] value();\n}\n@Repeatable(Hints.class)\n@interface Hint {\n    String value();\n}\n```\n\nJava 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下`@Repeatable`即可。\n\n例 1: 使用包装类当容器来存多个注解（老方法）\n\n```java\n@Hints({@Hint("hint1"), @Hint("hint2")})\nclass Person {}\n```\n\n例 2：使用多重注解（新方法）\n\n```java\n@Hint("hint1")\n@Hint("hint2")\nclass Person {}\n```\n\n第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息：\n\n```java\nHint hint = Person.class.getAnnotation(Hint.class);\nSystem.out.println(hint);                   // null\nHints hints1 = Person.class.getAnnotation(Hints.class);\nSystem.out.println(hints1.value().length);  // 2\n\nHint[] hints2 = Person.class.getAnnotationsByType(Hint.class);\nSystem.out.println(hints2.length);          // 2\n```\n\n即便我们没有在 `Person`类上定义 `@Hints`注解，我们还是可以通过 `getAnnotation(Hints.class) `来获取 `@Hints`注解，更加方便的方法是使用 `getAnnotationsByType` 可以直接获取到所有的`@Hint`注解。\n另外Java 8的注解还增加到两种新的target上了：\n\n```java\n@Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})\n@interface MyAnnotation {}\n```\n\n## Where to go from here?\n\n关于Java 8的新特性就写到这了，肯定还有更多的特性等待发掘。JDK 1.8里还有很多很有用的东西，比如`Arrays.parallelSort`, `StampedLock`和`CompletableFuture`等等。\n\n'},f4e4:function(n,e,t){"use strict";t.r(e),e["default"]='## 1.网络编程入门\n\n### 1.1 网络编程概述【理解】\n\n- 计算机网络\n\n  是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统\n\n- 网络编程\n\n  在网络通信协议下，不同计算机上运行的程序，可以进行数据传输\n\n### 1.2 网络编程三要素【理解】\n\n- IP地址\n\n  要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识\n\n- 端口\n\n  网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识\n\n- 协议\n\n  通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。常见的协议有UDP协议和TCP协议\n\n### 1.3 IP地址【理解】\n\nIP地址：是网络中设备的唯一标识\n\n- IP地址分为两大类\n\n  - IPv4：是给每个连接在网络上的主机分配一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每个IP地址长32bit，也就是4个字节。例如一个采用二进制形式的IP地址是“11000000 10101000 00000001 01000010”，这么长的地址，处理起来也太费劲了。为了方便使用，IP地址经常被写成十进制的形式，中间使用符号“.”分隔不同的字节。于是，上面的IP地址可以表示为“192.168.1.66”。IP地址的这种表示法叫做“点分十进制表示法”，这显然比1和0容易记忆得多\n\n  - IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。为了扩大地址空间，通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，这样就解决了网络地址资源数量不够的问题\n\n- DOS常用命令：\n\n  - ipconfig：查看本机IP地址\n\n  - ping IP地址：检查网络是否连通\n\n- 特殊IP地址：\n  - 127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用\n\n### 1.4 InetAddress【应用】\n\nInetAddress：此类表示Internet协议（IP）地址\n\n- 相关方法\n\n  | 方法名                                      | 说明                               |\n  | ---------------------------------------- | -------------------------------- |\n  | static InetAddress getByName(String host) | 确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址 |\n  | String getHostName()                     | 获取此IP地址的主机名                      |\n  | String getHostAddress()                  | 返回文本显示中的IP地址字符串                  |\n\n- 代码演示\n\n  ```java\n  public class InetAddressDemo {\n      public static void main(String[] args) throws UnknownHostException {\n  \t\t//InetAddress address = InetAddress.getByName("itheima");\n          InetAddress address = InetAddress.getByName("192.168.1.66");\n\n          //public String getHostName()：获取此IP地址的主机名\n          String name = address.getHostName();\n          //public String getHostAddress()：返回文本显示中的IP地址字符串\n          String ip = address.getHostAddress();\n\n          System.out.println("主机名：" + name);\n          System.out.println("IP地址：" + ip);\n      }\n  }\n  ```\n\n\n### 1.5 端口和协议【理解】\n\n- 端口\n\n  - 设备上应用程序的唯一标识\n\n- 端口号\n\n  - 用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败\n\n- 协议\n\n  - 计算机网络中，连接和通信的规则被称为网络通信协议\n\n- UDP协议\n  - 用户数据报协议(User Datagram Protocol)\n  - UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。\n  - 由于使用UDP协议消耗系统资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输\n  - 例如视频会议通常采用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议\n\n- TCP协议\n\n  - 传输控制协议 (Transmission Control Protocol)\n\n  - TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”\n\n  - 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠\n\n    第一次握手，客户端向服务器端发出连接请求，等待服务器确认\n\n    第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求\n\n    第三次握手，客户端再次向服务器端发送确认信息，确认连接\n\n  - 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛。例如上传文件、下载文件、浏览网页等\n\n## 2.UDP通信程序\n\n### 2.1 UDP发送数据【应用】\n\n- Java中的UDP通信\n  - UDP协议是一种不可靠的网络协议，它在通信的两端各建立一个Socket对象，但是这两个Socket只是发送，接收数据的对象，因此对于基于UDP协议的通信双方而言，没有所谓的客户端和服务器的概念\n  - Java提供了DatagramSocket类作为基于UDP协议的Socket\n\n- 构造方法\n\n  | 方法名                                      | 说明                           |\n  | ---------------------------------------- | ---------------------------- |\n  | DatagramSocket()                         | 创建数据报套接字并将其绑定到本机地址上的任何可用端口   |\n  | DatagramPacket(byte[] buf,int len,InetAddress add,int port) | 创建数据包,发送长度为len的数据包到指定主机的指定端口 |\n\n- 相关方法\n\n  | 方法名                            | 说明          |\n  | ------------------------------ | ----------- |\n  | void send(DatagramPacket p)    | 发送数据报包      |\n  | void close()                   | 关闭数据报套接字    |\n  | void receive(DatagramPacket p) | 从此套接字接受数据报包 |\n\n- 发送数据的步骤\n  - 创建发送端的Socket对象(DatagramSocket)\n  - 创建数据，并把数据打包\n  - 调用DatagramSocket对象的方法发送数据\n  - 关闭发送端\n\n- 代码演示\n\n  ```java\n  public class SendDemo {\n      public static void main(String[] args) throws IOException {\n          //创建发送端的Socket对象(DatagramSocket)\n          // DatagramSocket() 构造数据报套接字并将其绑定到本地主机上的任何可用端口\n          DatagramSocket ds = new DatagramSocket();\n\n          //创建数据，并把数据打包\n          //DatagramPacket(byte[] buf, int length, InetAddress address, int port)\n          //构造一个数据包，发送长度为 length的数据包到指定主机上的指定端口号。\n          byte[] bys = "hello,udp,我来了".getBytes();\n\n          DatagramPacket dp = new DatagramPacket(bys,bys.length,InetAddress.getByName("127.0.0.1"),10086);\n\n          //调用DatagramSocket对象的方法发送数据\n          //void send(DatagramPacket p) 从此套接字发送数据报包\n          ds.send(dp);\n\n          //关闭发送端\n          //void close() 关闭此数据报套接字\n          ds.close();\n      }\n  }\n  ```\n\n### 2.2UDP接收数据【应用】\n\n- 接收数据的步骤\n  - 创建接收端的Socket对象(DatagramSocket)\n  - 创建一个数据包，用于接收数据\n  - 调用DatagramSocket对象的方法接收数据\n  - 解析数据包，并把数据在控制台显示\n  - 关闭接收端\n\n- 构造方法\n\n  | 方法名                                 | 说明                               |\n  | ----------------------------------- | -------------------------------- |\n  | DatagramPacket(byte[] buf, int len) | 创建一个DatagramPacket用于接收长度为len的数据包 |\n\n- 相关方法\n\n  | 方法名               | 说明                   |\n  | ----------------- | -------------------- |\n  | byte[]  getData() | 返回数据缓冲区              |\n  | int  getLength()  | 返回要发送的数据的长度或接收的数据的长度 |\n\n- 示例代码\n\n  ```java\n  public class ReceiveDemo {\n      public static void main(String[] args) throws IOException {\n        \t//创建接收端的Socket对象(DatagramSocket)\n        \tDatagramSocket ds = new DatagramSocket(12345);\n\n        \t//创建一个数据包，用于接收数据\n        \tbyte[] bys = new byte[1024];\n        \tDatagramPacket dp = new DatagramPacket(bys, bys.length);\n\n        \t//调用DatagramSocket对象的方法接收数据\n        \tds.receive(dp);\n\n        \t//解析数据包，并把数据在控制台显示\n        \tSystem.out.println("数据是：" + new String(dp.getData(), 0,                                             dp.getLength()));\n          }\n      }\n  }\n  ```\n\n### 2.3UDP通信程序练习【应用】\n\n- 案例需求\n\n  UDP发送数据：数据来自于键盘录入，直到输入的数据是886，发送数据结束\n\n  UDP接收数据：因为接收端不知道发送端什么时候停止发送，故采用死循环接收\n\n- 代码实现\n\n  ```java\n  /*\n      UDP发送数据：\n          数据来自于键盘录入，直到输入的数据是886，发送数据结束\n   */\n  public class SendDemo {\n      public static void main(String[] args) throws IOException {\n          //创建发送端的Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket();\n          //键盘录入数据\n          Scanner sc = new Scanner(System.in);\n          while (true) {\n            \tString s = sc.nextLine();\n              //输入的数据是886，发送数据结束\n              if ("886".equals(s)) {\n                  break;\n              }\n              //创建数据，并把数据打包\n              byte[] bys = s.getBytes();\n              DatagramPacket dp = new DatagramPacket(bys, bys.length, InetAddress.getByName("192.168.1.66"), 12345);\n\n              //调用DatagramSocket对象的方法发送数据\n              ds.send(dp);\n          }\n          //关闭发送端\n          ds.close();\n      }\n  }\n\n  /*\n      UDP接收数据：\n          因为接收端不知道发送端什么时候停止发送，故采用死循环接收\n   */\n  public class ReceiveDemo {\n      public static void main(String[] args) throws IOException {\n          //创建接收端的Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket(12345);\n          while (true) {\n              //创建一个数据包，用于接收数据\n              byte[] bys = new byte[1024];\n              DatagramPacket dp = new DatagramPacket(bys, bys.length);\n              //调用DatagramSocket对象的方法接收数据\n              ds.receive(dp);\n              //解析数据包，并把数据在控制台显示\n              System.out.println("数据是：" + new String(dp.getData(), 0, dp.getLength()));\n          }\n          //关闭接收端\n  //        ds.close();\n      }\n  }\n  ```\n\n\n### 2.4UDP三种通讯方式【理解】\n\n+ 单播\n\n  单播用于两个主机之间的端对端通信\n\n+ 组播\n\n  组播用于对一组特定的主机进行通信\n\n+ 广播\n\n  广播用于一个主机对整个局域网上所有主机上的数据通信\n\n### 2.5UDP组播实现【理解】\n\n+ 实现步骤\n\n  + 发送端\n    1. 创建发送端的Socket对象(DatagramSocket)\n    2. 创建数据，并把数据打包(DatagramPacket)\n    3. 调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址)\n    4. 释放资源\n  + 接收端\n    1. 创建接收端Socket对象(MulticastSocket)\n    2. 创建一个箱子,用于接收数据\n    3. 把当前计算机绑定一个组播地址\n    4. 将数据接收到箱子中\n    5. 解析数据包,并打印数据\n    6. 释放资源\n\n+ 代码实现\n\n  ```java\n  // 发送端\n  public class ClinetDemo {\n      public static void main(String[] args) throws IOException {\n          // 1. 创建发送端的Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket();\n          String s = "hello 组播";\n          byte[] bytes = s.getBytes();\n          InetAddress address = InetAddress.getByName("224.0.1.0");\n          int port = 10000;\n          // 2. 创建数据，并把数据打包(DatagramPacket)\n          DatagramPacket dp = new DatagramPacket(bytes,bytes.length,address,port);\n          // 3. 调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址)\n          ds.send(dp);\n          // 4. 释放资源\n          ds.close();\n      }\n  }\n  // 接收端\n  public class ServerDemo {\n      public static void main(String[] args) throws IOException {\n          // 1. 创建接收端Socket对象(MulticastSocket)\n          MulticastSocket ms = new MulticastSocket(10000);\n          // 2. 创建一个箱子,用于接收数据\n          DatagramPacket dp = new DatagramPacket(new byte[1024],1024);\n          // 3. 把当前计算机绑定一个组播地址,表示添加到这一组中.\n          ms.joinGroup(InetAddress.getByName("224.0.1.0"));\n          // 4. 将数据接收到箱子中\n          ms.receive(dp);\n          // 5. 解析数据包,并打印数据\n          byte[] data = dp.getData();\n          int length = dp.getLength();\n          System.out.println(new String(data,0,length));\n          // 6. 释放资源\n          ms.close();\n      }\n  }\n  ```\n\n### 2.6UDP广播实现【理解】\n\n+ 实现步骤\n\n  + 发送端\n    1. 创建发送端Socket对象(DatagramSocket)\n    2. 创建存储数据的箱子,将广播地址封装进去\n    3. 发送数据\n    4. 释放资源\n  + 接收端\n    1. 创建接收端的Socket对象(DatagramSocket)\n    2. 创建一个数据包，用于接收数据\n    3. 调用DatagramSocket对象的方法接收数据\n    4. 解析数据包，并把数据在控制台显示\n    5. 关闭接收端\n\n+ 代码实现\n\n  ```java\n  // 发送端\n  public class ClientDemo {\n      public static void main(String[] args) throws IOException {\n        \t// 1. 创建发送端Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket();\n  \t\t// 2. 创建存储数据的箱子,将广播地址封装进去\n          String s = "广播 hello";\n          byte[] bytes = s.getBytes();\n          InetAddress address = InetAddress.getByName("255.255.255.255");\n          int port = 10000;\n          DatagramPacket dp = new DatagramPacket(bytes,bytes.length,address,port);\n  \t\t// 3. 发送数据\n          ds.send(dp);\n  \t\t// 4. 释放资源\n          ds.close();\n      }\n  }\n  // 接收端\n  public class ServerDemo {\n      public static void main(String[] args) throws IOException {\n          // 1. 创建接收端的Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket(10000);\n          // 2. 创建一个数据包，用于接收数据\n          DatagramPacket dp = new DatagramPacket(new byte[1024],1024);\n          // 3. 调用DatagramSocket对象的方法接收数据\n          ds.receive(dp);\n          // 4. 解析数据包，并把数据在控制台显示\n          byte[] data = dp.getData();\n          int length = dp.getLength();\n          System.out.println(new String(data,0,length));\n          // 5. 关闭接收端\n          ds.close();\n      }\n  }\n  ```\n\n\n## 3.TCP通信程序\n\n### 3.1TCP发送数据【应用】\n\n- Java中的TCP通信\n\n  - Java对基于TCP协议的的网络提供了良好的封装，使用Socket对象来代表两端的通信端口，并通过Socket产生IO流来进行网络通信。\n  - Java为客户端提供了Socket类，为服务器端提供了ServerSocket类\n\n- 构造方法\n\n  | 方法名                                  | 说明                      |\n  | ------------------------------------ | ----------------------- |\n  | Socket(InetAddress address,int port) | 创建流套接字并将其连接到指定IP指定端口号   |\n  | Socket(String host, int port)        | 创建流套接字并将其连接到指定主机上的指定端口号 |\n\n- 相关方法\n\n  | 方法名                            | 说明         |\n  | ------------------------------ | ---------- |\n  | InputStream  getInputStream()  | 返回此套接字的输入流 |\n  | OutputStream getOutputStream() | 返回此套接字的输出流 |\n\n- 示例代码\n\n  ```java\n  public class ClientDemo {\n      public static void main(String[] args) throws IOException {\n          //创建客户端的Socket对象(Socket)\n          //Socket(String host, int port) 创建流套接字并将其连接到指定主机上的指定端口号\n          Socket s = new Socket("127.0.0.1",10000);\n\n          //获取输出流，写数据\n          //OutputStream getOutputStream() 返回此套接字的输出流\n          OutputStream os = s.getOutputStream();\n          os.write("hello,tcp,我来了".getBytes());\n\n          //释放资源\n          s.close();\n      }\n  }\n  ```\n\n### 3.2TCP接收数据【应用】\n\n- 构造方法\n\n  | 方法名                     | 说明               |\n  | ----------------------- | ---------------- |\n  | ServletSocket(int port) | 创建绑定到指定端口的服务器套接字 |\n\n- 相关方法\n\n  | 方法名             | 说明              |\n  | --------------- | --------------- |\n  | Socket accept() | 监听要连接到此的套接字并接受它 |\n\n- 注意事项\n\n  1. accept方法是阻塞的,作用就是等待客户端连接\n  2. 客户端创建对象并连接服务器,此时是通过三次握手协议,保证跟服务器之间的连接\n  3. 针对客户端来讲,是往外写的,所以是输出流\n     针对服务器来讲,是往里读的,所以是输入流\n  4. read方法也是阻塞的\n  5. 客户端在关流的时候,还多了一个往服务器写结束标记的动作\n  6. 最后一步断开连接,通过四次挥手协议保证连接终止\n\n- 三次握手和四次挥手\n\n  - 三次握手\n\n    ![07_TCP三次握手](./day23-网络编程01.img/07_TCP三次握手.png)\n\n  - 四次挥手\n\n    ![08_TCP四次挥手](./day23-网络编程01.img/08_TCP四次挥手.png)\n\n\n- 示例代码\n\n  ```java\n  public class ServerDemo {\n      public static void main(String[] args) throws IOException {\n          //创建服务器端的Socket对象(ServerSocket)\n          //ServerSocket(int port) 创建绑定到指定端口的服务器套接字\n          ServerSocket ss = new ServerSocket(10000);\n\n          //Socket accept() 侦听要连接到此套接字并接受它\n          Socket s = ss.accept();\n\n          //获取输入流，读数据，并把数据显示在控制台\n          InputStream is = s.getInputStream();\n          byte[] bys = new byte[1024];\n          int len = is.read(bys);\n          String data = new String(bys,0,len);\n          System.out.println("数据是：" + data);\n\n          //释放资源\n          s.close();\n          ss.close();\n      }\n  }\n  ```\n\n### 3.3TCP程序练习【应用】\n\n- 案例需求\n\n  客户端：发送数据，接受服务器反馈\n\n  服务器：收到消息后给出反馈\n\n- 案例分析\n  - 客户端创建对象，使用输出流输出数据\n  - 服务端创建对象，使用输入流接受数据\n  - 服务端使用输出流给出反馈数据\n  - 客户端使用输入流接受反馈数据\n\n- 代码实现\n\n  ```java\n  // 客户端\n  public class ClientDemo {\n      public static void main(String[] args) throws IOException {\n          Socket socket = new Socket("127.0.0.1",10000);\n\n          OutputStream os = socket.getOutputStream();\n          os.write("hello".getBytes());\n         // os.close();如果在这里关流,会导致整个socket都无法使用\n          socket.shutdownOutput();//仅仅关闭输出流.并写一个结束标记,对socket没有任何影响\n          \n          BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n          String line;\n          while((line = br.readLine())!=null){\n              System.out.println(line);\n          }\n          br.close();\n          os.close();\n          socket.close();\n      }\n  }\n  // 服务器\n  public class ServerDemo {\n      public static void main(String[] args) throws IOException {\n          ServerSocket ss = new ServerSocket(10000);\n\n          Socket accept = ss.accept();\n\n          InputStream is = accept.getInputStream();\n          int b;\n          while((b = is.read())!=-1){\n              System.out.println((char) b);\n          }\n\n          System.out.println("看看我执行了吗?");\n\n          BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream()));\n          bw.write("你谁啊?");\n          bw.newLine();\n          bw.flush();\n\n          bw.close();\n          is.close();\n          accept.close();\n          ss.close();\n      }\n  }\n  ```\n\n### 3.4TCP程序文件上传练习【应用】\n\n- 案例需求\n\n  客户端：数据来自于本地文件，接收服务器反馈\n\n  服务器：接收到的数据写入本地文件，给出反馈\n\n- 案例分析\n  - 创建客户端对象，创建输入流对象指向文件，每读一次数据就给服务器输出一次数据，输出结束后使用shutdownOutput()方法告知服务端传输结束\n  - 创建服务器对象，创建输出流对象指向文件，每接受一次数据就使用输出流输出到文件中，传输结束后。使用输出流给客户端反馈信息\n  - 客户端接受服务端的回馈信息\n\n- 相关方法\n\n  | 方法名                   | 说明                 |\n  | --------------------- | ------------------ |\n  | void shutdownInput()  | 将此套接字的输入流放置在“流的末尾” |\n  | void shutdownOutput() | 禁止用此套接字的输出流        |\n\n- 代码实现\n\n  ```java\n  // 客户端\n  public class ClientDemo {\n      public static void main(String[] args) throws IOException {\n          Socket socket = new Socket("127.0.0.1",10000);\n\n          //是本地的流,用来读取本地文件的.\n          BufferedInputStream bis = new BufferedInputStream(new FileInputStream("socketmodule\\\\ClientDir\\\\1.jpg"));\n\n          //写到服务器 --- 网络中的流\n          OutputStream os = socket.getOutputStream();\n          BufferedOutputStream bos = new BufferedOutputStream(os);\n\n          int b;\n          while((b = bis.read())!=-1){\n              bos.write(b);//通过网络写到服务器中\n          }\n          bos.flush();\n          //给服务器一个结束标记,告诉服务器文件已经传输完毕\n          socket.shutdownOutput();\n\n          BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n          String line;\n          while((line = br.readLine()) !=null){\n              System.out.println(line);\n          }\n          bis.close();\n          socket.close();\n      }\n  }\n  // 服务器\n  public class ServerDemo {\n      public static void main(String[] args) throws IOException {\n          ServerSocket ss = new ServerSocket(10000);\n\n          Socket accept = ss.accept();\n\n          //网络中的流,从客户端读取数据的\n          BufferedInputStream bis = new BufferedInputStream(accept.getInputStream());\n          //本地的IO流,把数据写到本地中,实现永久化存储\n          BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("socketmodule\\\\ServerDir\\\\copy.jpg"));\n\n          int b;\n          while((b = bis.read()) !=-1){\n              bos.write(b);\n          }\n\n          BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream()));\n          bw.write("上传成功");\n          bw.newLine();\n          bw.flush();\n\n          bos.close();\n          accept.close();\n          ss.close();\n      }\n  }\n  ```\n\n### 3.5TCP程序服务器优化【应用】\n\n- 优化方案一\n\n  + 需求\n\n    服务器只能处理一个客户端请求，接收完一个图片之后，服务器就关闭了。\n\n  + 解决方案\n\n    使用循环\n\n  + 代码实现\n\n    ```java\n    // 服务器代码如下,客户端代码同上个案例,此处不再给出\n    public class ServerDemo {\n        public static void main(String[] args) throws IOException {\n            ServerSocket ss = new ServerSocket(10000);\n\n            while (true) {\n                Socket accept = ss.accept();\n\n                //网络中的流,从客户端读取数据的\n                BufferedInputStream bis = new BufferedInputStream(accept.getInputStream());\n                //本地的IO流,把数据写到本地中,实现永久化存储\n                BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("optimizeserver\\\\ServerDir\\\\copy.jpg"));\n\n                int b;\n                while((b = bis.read()) !=-1){\n                    bos.write(b);\n                }\n\n                BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream()));\n                bw.write("上传成功");\n                bw.newLine();\n                bw.flush();\n\n                bos.close();\n                accept.close();\n            }\n            //ss.close();\n            \n        }\n    }\n    ```\n\n- 优化方案二\n\n  + 需求\n\n    第二次上传文件的时候，会把第一次的文件给覆盖。\n\n  + 解决方案\n\n    UUID. randomUUID()方法生成随机的文件名\n\n  + 代码实现\n\n    ```java\n    // 服务器代码如下,客户端代码同上个案例,此处不再给出\n    public class ServerDemo {\n        public static void main(String[] args) throws IOException {\n            ServerSocket ss = new ServerSocket(10000);\n\n            while (true) {\n                Socket accept = ss.accept();\n\n                //网络中的流,从客户端读取数据的\n                BufferedInputStream bis = new BufferedInputStream(accept.getInputStream());\n                //本地的IO流,把数据写到本地中,实现永久化存储\n                BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("optimizeserver\\\\ServerDir\\\\" + UUID.randomUUID().toString() + ".jpg"));\n\n                int b;\n                while((b = bis.read()) !=-1){\n                    bos.write(b);\n                }\n\n                BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream()));\n                bw.write("上传成功");\n                bw.newLine();\n                bw.flush();\n\n                bos.close();\n                accept.close();\n            }\n            //ss.close();\n\n        }\n    }\n    ```\n\n- 优化方案三\n\n  - 需求\n\n    使用循环虽然可以让服务器处理多个客户端请求。但是还是无法同时跟多个客户端进行通信。\n\n  - 解决方案\n\n    开启多线程处理\n\n  - 代码实现\n\n    ```java\n    // 线程任务类\n    public class ThreadSocket implements Runnable {\n        private Socket acceptSocket;\n\n        public ThreadSocket(Socket accept) {\n            this.acceptSocket = accept;\n        }\n      \n        @Override\n        public void run() {\n            BufferedOutputStream bos = null;\n            try {\n                //网络中的流,从客户端读取数据的\n                BufferedInputStream bis = new BufferedInputStream(acceptSocket.getInputStream());\n                //本地的IO流,把数据写到本地中,实现永久化存储\n                bos = new BufferedOutputStream(new FileOutputStream("optimizeserver\\\\ServerDir\\\\" + UUID.randomUUID().toString() + ".jpg"));\n\n                int b;\n                while((b = bis.read()) !=-1){\n                    bos.write(b);\n                }\n              \n                BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(acceptSocket.getOutputStream()));\n                bw.write("上传成功");\n                bw.newLine();\n                bw.flush();\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                if(bos != null){\n                    try {\n                        bos.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n\n                if (acceptSocket != null){\n                    try {\n                        acceptSocket.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n    // 服务器代码\n    public class ServerDemo {\n        public static void main(String[] args) throws IOException {\n            ServerSocket ss = new ServerSocket(10000);\n\n            while (true) {\n                Socket accept = ss.accept();\n                ThreadSocket ts = new ThreadSocket(accept);\n                new Thread(ts).start();\n            }\n            //ss.close();\n        }\n    }\n    ```\n\n- 优化方案四\n\n  - 需求\n\n    使用多线程虽然可以让服务器同时处理多个客户端请求。但是资源消耗太大。\n\n  - 解决方案\n\n    加入线程池\n\n  - 代码实现\n\n    ```java\n    // 服务器代码如下,线程任务类代码同上,此处不再给出\n    public class ServerDemo {\n        public static void main(String[] args) throws IOException {\n            ServerSocket ss = new ServerSocket(10000);\n            ThreadPoolExecutor pool = new ThreadPoolExecutor(\n                    3,//核心线程数量\n                    10,   //线程池的总数量\n                    60,   //临时线程空闲时间\n                    TimeUnit.SECONDS, //临时线程空闲时间的单位\n                    new ArrayBlockingQueue<>(5),//阻塞队列\n                    Executors.defaultThreadFactory(),//创建线程的方式\n                    new ThreadPoolExecutor.AbortPolicy()//任务拒绝策略\n            );\n\n            while (true) {\n                Socket accept = ss.accept();\n                ThreadSocket ts = new ThreadSocket(accept);\n                //new Thread(ts).start();\n                pool.submit(ts);\n            }\n            //ss.close();\n        }\n    }\n    ```\n\n\n## 4.NIO\n\n### 4.1概述【理解】\n\n+ BIO\n\n  Blocking IO,阻塞型IO\n\n+ NIO\n\n  No Blocking IO,非阻塞型IO\n\n+ 阻塞IO的弊端\n\n  在等待的过程中,什么事也做不了\n\n+ 非阻塞IO的好处\n\n  不需要一直等待,当一切就绪了再去做\n\n### 4.2NIO与BIO的区别【理解】\n\n+ 区别一\n\n  BIO是阻塞的，NIO是非阻塞的\n\n+ 区别二\n\n  BIO是面向流的，NIO是面向缓冲区的\n\n  BIO中数据传输是单向的，NIO中的缓冲区是双向的\n\n### 4.3NIO三大模块【理解】\n\n+ 缓冲区\n\n  用来存储数据\n\n+ 通道\n\n  用来建立连接和传输数据\n\n+ 选择器\n\n  监视通道状态\n\n  ![09_三大模块](./day23-网络编程01.img/09_三大模块.png)\n\n### 4.4NIO创建缓冲区对象【应用】\n\n+ 方法介绍\n\n  | 方法名                                    | 说明                |\n  | -------------------------------------- | ----------------- |\n  | static  ByteBuffer  allocate(长度)       | 创建byte类型的缓冲区      |\n  | static  ByteBuffer  wrap(byte[] array) | 创建一个有内容的byte类型缓冲区 |\n\n+ 代码示例\n\n  ```java\n  public class CreateByteBufferDemo1 {\n      public static void main(String[] args) {\n          //method1();\n\n          //method2();\n\n          ByteBuffer wrap = ByteBuffer.wrap("aaa".getBytes());\n          for (int i = 0; i < 3; i++) {\n              System.out.println(wrap.get());\n          }\n      }\n\n      private static void method2() {\n          byte [] bytes = {97,98,99};\n          ByteBuffer byteBuffer2 = ByteBuffer.wrap(bytes);\n          //缓冲区的长度3\n          //缓冲区里面的内容就是字节数组的内容.\n          for (int i = 0; i < 3; i++) {\n              System.out.println(byteBuffer2.get());\n          }\n          System.out.println(byteBuffer2.get());\n      }\n\n      private static void method1() {\n          ByteBuffer byteBuffer1 = ByteBuffer.allocate(5);\n          //get\n          for (int i = 0; i < 5; i++) {\n              System.out.println(byteBuffer1.get());\n          }\n          System.out.println(byteBuffer1.get());\n      }\n  }\n  ```\n\n### 4.5NIO缓冲区添加数据【应用】\n\n+ 方法介绍\n\n  ![10_NIO缓冲区添加数据](./day23-网络编程01.img/10_NIO缓冲区添加数据.png)\n\n+ 代码示例\n\n  ```java\n  public class ByteBufferDemo2 {\n      public static void main(String[] args) {\n  //        int position()\t\t  当前要操作的索引\n  //        int limit() \t\t  最多能操作到哪个索引\n  //        int capacity()\t\t  缓冲区的总长度\n          ByteBuffer byteBuffer = ByteBuffer.allocate(10);\n          System.out.println(byteBuffer.position());//0\n          System.out.println(byteBuffer.limit());//10\n          System.out.println(byteBuffer.capacity());//10\n\n  //        put(byte b)\t\t  一次添加一个字节\n  //        byteBuffer.put((byte) 97);\n  //        System.out.println(byteBuffer.position());\n  //        System.out.println(byteBuffer.limit());\n  //        System.out.println(byteBuffer.capacity());\n\n  //        put(byte[] src)\t\t 一次添加一个字节数组\n  //        byteBuffer.put("aaa".getBytes());\n  //        System.out.println(byteBuffer.position());//3\n  //        System.out.println(byteBuffer.limit());//10\n  //        System.out.println(byteBuffer.capacity());//10\n\n  //        position(int newPosition) 修改position\n  //        byteBuffer.position(1);\n\n  //        limit(int newLimit)\t  修改limit\n  //        byteBuffer.limit(5);\n  //        System.out.println(byteBuffer.position());\n  //        System.out.println(byteBuffer.limit());\n  //        System.out.println(byteBuffer.capacity());\n\n  //        int remaining()\t\t  还有多少能操作\n  //        boolean hasRemaining()\t  是否还有能操作的\n\n          byteBuffer.put("0123456789".getBytes());\n          System.out.println(byteBuffer.remaining());\n          System.out.println(byteBuffer.hasRemaining());\n      }\n  }\n  ```\n\n### 4.6NIO缓冲区获取数据【应用】\n\n+ 方法介绍\n\n  | 方法名              | 介绍                  |\n  | ---------------- | ------------------- |\n  | flip()           | 切换读写模式（写à读）         |\n  | get()            | 读一个字节               |\n  | get(byte[]  dst) | 读多个字节               |\n  | get(int  index)  | 读指定索引的字节            |\n  | rewind()         | 将position设置为0，可以重复读 |\n  | clear()          | 数据读写完毕（读->写）        |\n  | array()          | 将缓冲区转换成字节数组返回       |\n\n+ 代码示例\n\n  ```java\n  public class ByteBufferDemo3 {\n      public static void main(String[] args) {\n          ByteBuffer byteBuffer = ByteBuffer.allocate(10);\n          byteBuffer.put("abc".getBytes());\n\n  //        flip()  切换读写模式（写读）\n          byteBuffer.flip();\n  //        get()   读一个字节\n  //        while(byteBuffer.limit() != byteBuffer.position()){\n  //            System.out.println((char) byteBuffer.get());\n  //        }\n\n          for (int i = 0; i < byteBuffer.limit(); i++) {\n              System.out.println((char) byteBuffer.get());\n          }\n\n  //        get(byte[] dst) 读多个字节\n  //        byte [] bytes = new byte[byteBuffer.limit()];\n  //        byteBuffer.get(bytes);\n  //        System.out.println(new String(bytes));\n\n  //        get(int index)  读指定索引的字节\n  //        System.out.println((char) byteBuffer.get(0));\n\n  //        rewind()    将position设置为0，可以重复读\n  //        byteBuffer.rewind();\n  //        for (int i = 0; i < byteBuffer.limit(); i++) {\n  //            System.out.println((char) byteBuffer.get());\n  //        }\n\n  //        clear()     数据读写完毕（读->写）\n          byteBuffer.clear();\n          byteBuffer.put("qqq".getBytes());\n  //        array()     将缓冲区转换成字节数组返回\n\n          byte[] bytes = byteBuffer.array();\n          System.out.println(new String(bytes));\n      }\n  }\n  ```\n\n### 4.7小结【理解】\n\n1. 需求：我要把数据写到缓冲区中。\n\n   数据是从外面进入到缓冲区的，所以缓冲区在做读数据的操作。\n\n2. 需求：我要把数据从缓冲区中读出来。\n\n   数据是从缓冲区里面到外面的。所以缓冲区在做写数据的操作。\n\n3. capacity：容量（长度）\n   limit：   界限（最多能读/写到哪里）\n   posotion：位置（读/写哪个索引）\n\n4. 获取缓冲区里面数据之前，需要调用flip方法\n\n5. 再次写数据之前，需要调用clear方法，\n\n   但是数据还未消失，等再次写入数据，被覆盖了才会消失。\n\n'},f6cb:function(n,e,t){"use strict";t.r(e),e["default"]='![](RESTfulAPI简明教程.assets/2021050713553862.png)\n\n大家好，我是 Guide哥！\n\n这篇文章简单聊聊后端程序员必备的 RESTful API 相关的知识。\n\n开始正式介绍 RESTful API 之前，我们需要首先搞清 ：**API 到底是什么？**\n\n## 何为 API？\n\n![](RESTfulAPI简明教程.assets/20210507153833945.png)\n\n**API（Application Programming Interface）** 翻译过来是应用程序编程接口的意思。\n\n我们在进行后端开发的时候，主要的工作就是为前端或者其他后端服务提供 API 比如查询用户数据的 API 。\n\n![](RESTfulAPI简明教程.assets/20210507130629538.png)\n\n但是， API 不仅仅代表后端系统暴露的接口，像框架中提供的方法也属于 API 的范畴。\n\n为了方便大家理解，我再列举几个例子 🌰：\n\n1. 你通过某电商网站搜索某某商品，电商网站的前端就调用了后端提供了搜索商品相关的 API。\n2. 你使用 JDK 开发 Java 程序，想要读取用户的输入的话，你就需要使用 JDK 提供的 IO 相关的 API。\n3. ......\n\n你可以把 API 理解为程序与程序之间通信的桥梁，其本质就是一个函数而已。另外，API 的使用也不是没有章法的，它的规则由（比如数据输入和输出的格式）API 提供方制定。\n\n## 何为 RESTful API？\n\n**RESTful API** 经常也被叫做 **REST API**，它是基于 REST 构建的 API。这个 REST 到底是什么，我们后文在讲，涉及到的概念比较多。\n\n如果你看 RESTful API 相关的文章的话一般都比较晦涩难懂，主要是因为 REST 涉及到的一些概念比较难以理解。但是，实际上，我们平时开发用到的 RESTful API 的知识非常简单也很容易概括！\n\n举个例子，如果我给你下面两个 API 你是不是立马能知道它们是干什么用的！这就是 RESTful API 的强大之处！\n\n```\nGET    /classes：列出所有班级\nPOST   /classes：新建一个班级\n```\n\n**RESTful API 可以让你看到 URL+Http Method 就知道这个 URL 是干什么的，让你看到了 HTTP 状态码（status code）就知道请求结果如何。**\n\n像咱们在开发过程中设计 API 的时候也应该至少要满足 RESTful API 的最基本的要求（比如接口中尽量使用名词，使用 `POST` 请求创建资源，`DELETE` 请求删除资源等等，示例：`GET /notes/id`：获取某个指定 id 的笔记的信息）。\n\n## 解读 REST\n\n**REST** 是 `REpresentational State Transfer` 的缩写。这个词组的翻译过来就是“**表现层状态转化**”。\n\n这样理解起来甚是晦涩，实际上 REST 的全称是 **Resource Representational State Transfer** ，直白地翻译过来就是 **“资源”在网络传输中以某种“表现形式”进行“状态转移”** 。如果还是不能继续理解，请继续往下看，相信下面的讲解一定能让你理解到底啥是 REST 。\n\n我们分别对上面涉及到的概念进行解读，以便加深理解，实际上你不需要搞懂下面这些概念，也能看懂我下一部分要介绍到的内容。不过，为了更好地能跟别人扯扯 “RESTful API”我建议你还是要好好理解一下！\n\n- **资源（Resource）** ：我们可以把真实的对象数据称为资源。一个资源既可以是一个集合，也可以是单个个体。比如我们的班级 classes 是代表一个集合形式的资源，而特定的 class 代表单个个体资源。每一种资源都有特定的 URI（统一资源标识符）与之对应，如果我们需要获取这个资源，访问这个 URI 就可以了，比如获取特定的班级：`/class/12`。另外，资源也可以包含子资源，比如 `/classes/classId/teachers`：列出某个指定班级的所有老师的信息\n- **表现形式（Representational）**："资源"是一种信息实体，它可以有多种外在表现形式。我们把"资源"具体呈现出来的形式比如 `json`，`xml`，`image`,`txt` 等等叫做它的"表现层/表现形式"。\n- **状态转移（State Transfer）** ：大家第一眼看到这个词语一定会很懵逼？内心 BB：这尼玛是啥啊？ 大白话来说 REST 中的状态转移更多地描述的服务器端资源的状态，比如你通过增删改查（通过 HTTP 动词实现）引起资源状态的改变。ps:互联网通信协议 HTTP 协议，是一个无状态协议，所有的资源状态都保存在服务器端。\n\n综合上面的解释，我们总结一下什么是 RESTful 架构：\n\n1. 每一个 URI 代表一种资源；\n2. 客户端和服务器之间，传递这种资源的某种表现形式比如 `json`，`xml`，`image`,`txt` 等等；\n3. 客户端通过特定的 HTTP 动词，对服务器端资源进行操作，实现"表现层状态转化"。\n\n## RESTful API 规范\n\n![](RESTfulAPI简明教程.assets/20210507154007779.png)\n\n### 动作\n\n- `GET`：请求从服务器获取特定资源。举个例子：`GET /classes`（获取所有班级）\n- `POST` ：在服务器上创建一个新的资源。举个例子：`POST /classes`（创建班级）\n- `PUT` ：更新服务器上的资源（客户端提供更新后的整个资源）。举个例子：`PUT /classes/12`（更新编号为 12 的班级）\n- `DELETE` ：从服务器删除特定的资源。举个例子：`DELETE /classes/12`（删除编号为 12 的班级）\n- `PATCH` ：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新），使用的比较少，这里就不举例子了。\n\n### 路径（接口命名）\n\n路径又称"终点"（endpoint），表示 API 的具体网址。实际开发中常见的规范如下：\n\n1. **网址中不能有动词，只能有名词，API 中的名词也应该使用复数。** 因为 REST 中的资源往往和数据库中的表对应，而数据库中的表都是同种记录的"集合"（collection）。如果 API 调用并不涉及资源（如计算，翻译等操作）的话，可以用动词。比如：`GET /calculate?param1=11&param2=33` 。\n2. **不用大写字母，建议用中杠 - 不用下杠 \\_** 。比如邀请码写成 `invitation-code`而不是 ~~invitation_code~~ 。\n3. **善用版本化 API**。当我们的 API 发生了重大改变而不兼容前期版本的时候，我们可以通过 URL 来实现版本化，比如 `http://api.example.com/v1`、`http://apiv1.example.com` 。版本不必非要是数字，只是数字用的最多，日期、季节都可以作为版本标识符，项目团队达成共识就可。\n4. **接口尽量使用名词，避免使用动词。** RESTful API 操作（HTTP Method）的是资源（名词）而不是动作（动词）。\n\nTalk is cheap！来举个实际的例子来说明一下吧！现在有这样一个 API 提供班级（class）的信息，还包括班级中的学生和教师的信息，则它的路径应该设计成下面这样。\n\n```\nGET    /classes：列出所有班级\nPOST   /classes：新建一个班级\nGET    /classes/{classId}：获取某个指定班级的信息\nPUT    /classes/{classId}：更新某个指定班级的信息（一般倾向整体更新）\nPATCH  /classes/{classId}：更新某个指定班级的信息（一般倾向部分更新）\nDELETE /classes/{classId}：删除某个班级\nGET    /classes/{classId}/teachers：列出某个指定班级的所有老师的信息\nGET    /classes/{classId}/students：列出某个指定班级的所有学生的信息\nDELETE /classes/{classId}/teachers/{ID}：删除某个指定班级下的指定的老师的信息\n```\n\n反例：\n\n```\n/getAllclasses\n/createNewclass\n/deleteAllActiveclasses\n```\n\n理清资源的层次结构，比如业务针对的范围是学校，那么学校会是一级资源:`/schools`，老师: `/schools/teachers`，学生: `/schools/students` 就是二级资源。\n\n### 过滤信息（Filtering）\n\n如果我们在查询的时候需要添加特定条件的话，建议使用 url 参数的形式。比如我们要查询 state 状态为 active 并且 name 为 guidegege 的班级：\n\n```\nGET    /classes?state=active&name=guidegege\n```\n\n比如我们要实现分页查询：\n\n```\nGET    /classes?page=1&size=10 //指定第1页，每页10个数据\n```\n\n### 状态码（Status Codes）\n\n**状态码范围：**\n\n| 2xx：成功 | 3xx：重定向    | 4xx：客户端错误  | 5xx：服务器错误 |\n| --------- | -------------- | ---------------- | --------------- |\n| 200 成功  | 301 永久重定向 | 400 错误请求     | 500 服务器错误  |\n| 201 创建  | 304 资源未修改 | 401 未授权       | 502 网关错误    |\n|           |                | 403 禁止访问     | 504 网关超时    |\n|           |                | 404 未找到       |                 |\n|           |                | 405 请求方法不对 |                 |\n\n## RESTful 的极致 HATEOAS\n\n> **RESTful 的极致是 hateoas ，但是这个基本不会在实际项目中用到。**\n\n上面是 RESTful API 最基本的东西，也是我们平时开发过程中最容易实践到的。实际上，RESTful API 最好做到 Hypermedia，即返回结果中提供链接，连向其他 API 方法，使得用户不查文档，也知道下一步应该做什么。\n\n比如，当用户向 `api.example.com` 的根目录发出请求，会得到这样一个返回结果\n\n```javascript\n{"link": {\n  "rel":   "collection https://www.example.com/classes",\n  "href":  "https://api.example.com/classes",\n  "title": "List of classes",\n  "type":  "application/vnd.yourformat+json"\n}}\n```\n\n上面代码表示，文档中有一个 `link` 属性，用户读取这个属性就知道下一步该调用什么 API 了。`rel` 表示这个 API 与当前网址的关系（collection 关系，并给出该 collection 的网址），`href` 表示 API 的路径，title 表示 API 的标题，`type` 表示返回类型 `Hypermedia API` 的设计被称为[HATEOAS](http://en.wikipedia.org/wiki/HATEOAS)。\n\n在 Spring 中有一个叫做 HATEOAS 的 API 库，通过它我们可以更轻松的创建出符合 HATEOAS 设计的 API。相关文章：\n\n- [在 Spring Boot 中使用 HATEOAS](https://blog.aisensiy.me/2017/06/04/spring-boot-and-hateoas/)\n- [Building REST services with Spring](https://spring.io/guides/tutorials/rest/) (Spring 官网 )\n- [An Intro to Spring HATEOAS](https://www.baeldung.com/spring-hateoas-tutorial)\n- [spring-hateoas-examples](https://github.com/spring-projects/spring-hateoas-examples/tree/master/hypermedia)\n- [Spring HATEOAS](https://spring.io/projects/spring-hateoas#learn) (Spring 官网 )\n\n## 参考\n\n- https://RESTfulapi.net/\n\n- https://www.ruanyifeng.com/blog/2014/05/restful_api.html\n\n- https://juejin.im/entry/59e460c951882542f578f2f0\n\n- https://phauer.com/2016/testing-RESTful-services-java-best-practices/\n\n- https://www.seobility.net/en/wiki/REST_API\n\n- https://dev.to/duomly/rest-api-vs-graphql-comparison-3j6g\n'},f9f1:function(n,e,t){"use strict";t.r(e),e["default"]="### 限流的算法有哪些？\n\n简单介绍 4 种非常好理解并且容易实现的限流算法！\n\n下图的图片不是 Guide 哥自己画的哦！图片来源于 InfoQ 的一篇文章[《分布式服务限流实战，已经为你排好坑了》](https://www.infoq.cn/article/Qg2tX8fyw5Vt-f3HH673)。\n\n#### 固定窗口计数器算法\n\n该算法规定我们单位时间处理的请求数量。比如我们规定我们的一个接口一分钟只能访问10次的话。使用固定窗口计数器算法的话可以这样实现：给定一个变量counter来记录处理的请求数量，当1分钟之内处理一个请求之后counter+1，1分钟之内的如果counter=10的话，后续的请求就会被全部拒绝。等到 1分钟结束后，将counter回归成0，重新开始计数（ps：只要过了一个周期就将counter回归成0）。\n\n这种限流算法无法保证限流速率，因而无法保证突然激增的流量。比如我们限制一个接口一分钟只能访问10次的话，前半分钟一个请求没有接收，后半分钟接收了10个请求。\n\n![固定窗口计数器算法](limit-request.assets/8ded7a2b90e1482093f92fff555b3615.png)\n\n#### 滑动窗口计数器算法\n\n该算法算的上是固定窗口计数器算法的升级版。滑动窗口计数器算法相比于固定窗口计数器算法的优化在于：它把时间以一定比例分片。例如我们的接口限流每分钟处理60个请求，我们可以把 1 分钟分为60个窗口。每隔1秒移动一次，每个窗口一秒只能处理 不大于 60(请求数)/60（窗口数） 的请求， 如果当前窗口的请求计数总和超过了限制的数量的话就不再处理其他请求。\n\n很显然：当滑动窗口的格子划分的越多，滑动窗口的滚动就越平滑，限流的统计就会越精确。\n\n![滑动窗口计数器算法](limit-request.assets/ae4d3cd14efb8dc7046d691c90264715.png)\n\n#### 漏桶算法\n\n我们可以把发请求的动作比作成注水到桶中，我们处理请求的过程可以比喻为 **漏桶漏水** 。我们往桶中以任意速率流入水，以一定速率流出水。当水超过桶容量则丢弃，因为桶容量是不变的，保证了整体的速率。\n\n如果想要实现这个算法的话也很简单，准备一个队列用来保存请求，然后我们定期从队列中拿请求来执行就好了。\n\n![漏桶算法](limit-request.assets/75938d1010138ce66e38c6ed0392f103.png)\n\n#### 令牌桶算法\n\n令牌桶算法也比较简单。和漏桶算法一样，我们的主角还是桶（这限流算法和桶过不去啊）。不过现在桶里装的是令牌了，请求在被处理之前需要拿到一个令牌，请求处理完毕之后将这个令牌丢弃（删除）。\n\n我们根据限流大小，按照一定的速率往桶里添加令牌即可！\n\n![令牌桶算法](limit-request.assets/eca0e5eaa35dac938c673fecf2ec9a93.png)\n\n**漏桶算法 vs 令牌桶算法** ： \n\n \n"},fc69:function(n,e,t){"use strict";t.r(e),e["default"]='一篇短小的文章，面试经常遇到的这个问题。本文主要包括下面这些内容：\n\n1. 高可用的定义\n2. 哪些情况可能会导致系统不可用？\n3. 有哪些提高系统可用性的方法？只是简单的提一嘴，更具体内容在后续的文章中介绍，就拿限流来说，你需要搞懂：何为限流？如何限流？为什么要限流？如何做呢？说一下原理？。\n\n## 什么是高可用？可用性的判断标准是啥？\n\n**高可用描述的是一个系统在大部分时间都是可用的，可以为我们提供服务的。高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的。**\n\n**一般情况下，我们使用多少个 9 来评判一个系统的可用性，比如 99.9999% 就是代表该系统在所有的运行时间中只有 0.0001% 的时间是不可用的，这样的系统就是非常非常高可用的了！当然，也会有系统如果可用性不太好的话，可能连 9 都上不了。**\n\n除此之外，系统的可用性还可以用某功能的失败次数与总的请求次数之比来衡量，比如对网站请求 1000 次，其中有 10 次请求失败，那么可用性就是 99%。\n\n## 哪些情况会导致系统不可用？\n\n1. 黑客攻击；\n2. 硬件故障，比如服务器坏掉。\n3. 并发量/用户请求量激增导致整个服务宕掉或者部分服务不可用。\n4. 代码中的坏味道导致内存泄漏或者其他问题导致程序挂掉。\n5. 网站架构某个重要的角色比如 Nginx 或者数据库突然不可用。\n6. 自然灾害或者人为破坏。\n7. ......\n\n## 有哪些提高系统可用性的方法？\n\n### 1. 注重代码质量，测试严格把关\n\n我觉得这个是最最最重要的，代码质量有问题比如比较常见的内存泄漏、循环依赖都是对系统可用性极大的损害。大家都喜欢谈限流、降级、熔断，但是我觉得从代码质量这个源头把关是首先要做好的一件很重要的事情。如何提高代码质量？比较实际可用的就是 CodeReview，不要在乎每天多花的那 1 个小时左右的时间，作用可大着呢！\n\n另外，安利这个对提高代码质量有实际效果的宝贝：\n\n1. sonarqube ：保证你写出更安全更干净的代码！（ps: 目前所在的项目基本都会用到这个插件）。\n2. Alibaba 开源的 Java 诊断工具 Arthas 也是很不错的选择。\n3. IDEA 自带的代码分析等工具进行代码扫描也是非常非常棒的。\n\n### 2.使用集群，减少单点故障\n\n先拿常用的 Redis 举个例子！我们如何保证我们的 Redis 缓存高可用呢？答案就是使用集群，避免单点故障。当我们使用一个 Redis 实例作为缓存的时候，这个 Redis 实例挂了之后，整个缓存服务可能就挂了。使用了集群之后，即使一台 Redis 实例挂了，不到一秒就会有另外一台 Redis 实例顶上。\n\n### 3.限流\n\n流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。——来自 alibaba-[Sentinel](https://github.com/alibaba/Sentinel "Sentinel") 的 wiki。\n\n### 4.超时和重试机制设置\n\n一旦用户请求超过某个时间的得不到响应，就抛出异常。这个是非常重要的，很多线上系统故障都是因为没有进行超时设置或者超时设置的方式不对导致的。我们在读取第三方服务的时候，尤其适合设置超时和重试机制。一般我们使用一些 RPC 框架的时候，这些框架都自带的超时重试的配置。如果不进行超时设置可能会导致请求响应速度慢，甚至导致请求堆积进而让系统无法再处理请求。重试的次数一般设为 3 次，再多次的重试没有好处，反而会加重服务器压力（部分场景使用失败重试机制会不太适合）。\n\n### 5.熔断机制\n\n超时和重试机制设置之外，熔断机制也是很重要的。 熔断机制说的是系统自动收集所依赖服务的资源使用情况和性能指标，当所依赖的服务恶化或者调用失败次数达到某个阈值的时候就迅速失败，让当前系统立即切换依赖其他备用服务。 比较常用的流量控制和熔断降级框架是 Netflix 的 Hystrix 和 alibaba 的 Sentinel。\n\n### 6.异步调用\n\n异步调用的话我们不需要关心最后的结果，这样我们就可以用户请求完成之后就立即返回结果，具体处理我们可以后续再做，秒杀场景用这个还是蛮多的。但是，使用异步之后我们可能需要 **适当修改业务流程进行配合**，比如**用户在提交订单之后，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功**。除了可以在程序中实现异步之外，我们常常还使用消息队列，消息队列可以通过异步处理提高系统性能（削峰、减少响应所需时间）并且可以降低系统耦合性。\n\n### 7.使用缓存\n\n如果我们的系统属于并发量比较高的话，如果我们单纯使用数据库的话，当大量请求直接落到数据库可能数据库就会直接挂掉。使用缓存缓存热点数据，因为缓存存储在内存中，所以速度相当地快！\n\n### 8.其他\n\n1. **核心应用和服务优先使用更好的硬件**\n2. **监控系统资源使用情况增加报警设置。**\n3. **注意备份，必要时候回滚。**\n4. **灰度发布：** 将服务器集群分成若干部分，每天只发布一部分机器，观察运行稳定没有故障，第二天继续发布一部分机器，持续几天才把整个集群全部发布完毕，期间如果发现问题，只需要回滚已发布的一部分服务器即可\n5. **定期检查/更换硬件：** 如果不是购买的云服务的话，定期还是需要对硬件进行一波检查的，对于一些需要更换或者升级的硬件，要及时更换或者升级。\n6. .....(想起来再补充！也欢迎各位欢迎补充！)\n\n## 总结\n\n![如何设计高可用系统？](如何设计一个高可用系统要考虑哪些地方.assets/如何设计高可用的系统？.png)\n'},fcfb:function(n,e,t){"use strict";t.r(e),e["default"]='## 1.时间日期类\n\n### 1.1 Date类（应用）\n\n+ 计算机中时间原点\n\n  1970年1月1日 00:00:00\n\n+ 时间换算单位\n\n  1秒 = 1000毫秒\n\n+ Date类概述\n\n  Date 代表了一个特定的时间，精确到毫秒\n\n+ Date类构造方法\n\n  | 方法名                    | 说明                                  |\n  | ---------------------- | ----------------------------------- |\n  | public Date()          | 分配一个 Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒 |\n  | public Date(long date) | 分配一个 Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数 |\n\n+ 示例代码\n\n  ```java\n  public class DateDemo01 {\n      public static void main(String[] args) {\n          //public Date()：分配一个 Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒\n          Date d1 = new Date();\n          System.out.println(d1);\n\n          //public Date(long date)：分配一个 Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数\n          long date = 1000*60*60;\n          Date d2 = new Date(date);\n          System.out.println(d2);\n      }\n  }\n  ```\n\n### 1.2 Date类常用方法（应用）\n\n- 常用方法\n\n  | 方法名                            | 说明                                 |\n  | ------------------------------ | ---------------------------------- |\n  | public long getTime()          | 获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值 |\n  | public void setTime(long time) | 设置时间，给的是毫秒值                        |\n\n- 示例代码\n\n  ```java\n  public class DateDemo02 {\n      public static void main(String[] args) {\n          //创建日期对象\n          Date d = new Date();\n\n          //public long getTime():获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值\n  //        System.out.println(d.getTime());\n  //        System.out.println(d.getTime() * 1.0 / 1000 / 60 / 60 / 24 / 365 + "年");\n\n          //public void setTime(long time):设置时间，给的是毫秒值\n  //        long time = 1000*60*60;\n          long time = System.currentTimeMillis();\n          d.setTime(time);\n\n          System.out.println(d);\n      }\n  }\n  ```\n\n### 1.3 SimpleDateFormat类（应用）\n\n- SimpleDateFormat类概述\n\n  ​\tSimpleDateFormat是一个具体的类，用于以区域设置敏感的方式格式化和解析日期。\n\n  ​\t我们重点学习日期格式化和解析\n\n- SimpleDateFormat类构造方法\n\n  | 方法名                                     | 说明                                  |\n  | --------------------------------------- | ----------------------------------- |\n  | public   SimpleDateFormat()             | 构造一个SimpleDateFormat，使用默认模式和日期格式    |\n  | public SimpleDateFormat(String pattern) | 构造一个SimpleDateFormat使用给定的模式和默认的日期格式 |\n\n- SimpleDateFormat类的常用方法\n\n  - 格式化(从Date到String)\n    - public final String format(Date date)：将日期格式化成日期/时间字符串\n  - 解析(从String到Date)\n    - public Date parse(String source)：从给定字符串的开始解析文本以生成日期\n\n- 示例代码\n\n  ```java\n  public class SimpleDateFormatDemo {\n      public static void main(String[] args) throws ParseException {\n          //格式化：从 Date 到 String\n          Date d = new Date();\n  //        SimpleDateFormat sdf = new SimpleDateFormat();\n          SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");\n          String s = sdf.format(d);\n          System.out.println(s);\n          System.out.println("--------");\n\n          //从 String 到 Date\n          String ss = "2048-08-09 11:11:11";\n          //ParseException\n          SimpleDateFormat sdf2 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");\n          Date dd = sdf2.parse(ss);\n          System.out.println(dd);\n      }\n  }\n  ```\n\n### 1.4 时间日期类练习 (应用) \n\n+ 需求\n\n  秒杀开始时间是2020年11月11日 00:00:00,结束时间是2020年11月11日 00:10:00,用户小贾下单时间是2020年11月11日 00:03:47,用户小皮下单时间是2020年11月11日 00:10:11,判断用户有没有成功参与秒杀活动\n\n+ 实现步骤\n\n  1. 判断下单时间是否在开始到结束的范围内\n  2. 把字符串形式的时间变成毫秒值\n\n+ 代码实现\n\n  ```java\n  public class DateDemo5 {\n      public static void main(String[] args) throws ParseException {\n          //开始时间：2020年11月11日 0:0:0\n          //结束时间：2020年11月11日 0:10:0\n\n          //小贾2020年11月11日 0:03:47\n          //小皮2020年11月11日 0:10:11\n\n          //1.判断两位同学的下单时间是否在范围之内就可以了。\n\n          //2.要把每一个时间都换算成毫秒值。\n\n          String start = "2020年11月11日 0:0:0";\n          String end = "2020年11月11日 0:10:0";\n\n          String jia = "2020年11月11日 0:03:47";\n          String pi = "2020年11月11日 0:10:11";\n\n          SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");\n          long startTime = sdf.parse(start).getTime();\n          long endTime = sdf.parse(end).getTime();\n\n  //        System.out.println(startTime);\n  //        System.out.println(endTime);\n          long jiaTime = sdf.parse(jia).getTime();\n          long piTime = sdf.parse(pi).getTime();\n\n          if(jiaTime >= startTime && jiaTime <= endTime){\n              System.out.println("小贾同学参加上了秒杀活动");\n          }else{\n              System.out.println("小贾同学没有参加上秒杀活动");\n          }\n\n          System.out.println("------------------------");\n\n          if(piTime >= startTime && piTime <= endTime){\n              System.out.println("小皮同学参加上了秒杀活动");\n          }else{\n              System.out.println("小皮同学没有参加上秒杀活动");\n          }\n\n      }\n    \n  }\n  ```\n\n## 2.JDK8时间日期类 \n\n### 2.1 JDK8新增日期类 (理解) \n\n+ LocalDate       表示日期（年月日）  \n+ LocalTime       表示时间（时分秒）\n+ LocalDateTime    表示时间+ 日期 （年月日时分秒）\n\n### 2.2 LocalDateTime创建方法 (应用) \n\n+ 方法说明\n\n  | 方法名                                      | 说明                              |\n  | ---------------------------------------- | ------------------------------- |\n  | public static LocalDateTime now()        | 获取当前系统时间                        |\n  | public static LocalDateTime of  (年, 月 , 日, 时, 分, 秒) | 使用指定年月日和时分秒初始化一个LocalDateTime对象 |\n\n+ 示例代码\n\n  ```java\n  public class JDK8DateDemo2 {\n      public static void main(String[] args) {\n          LocalDateTime now = LocalDateTime.now();\n          System.out.println(now);\n\n          LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 11, 11, 11);\n          System.out.println(localDateTime);\n      }\n  }\n  ```\n\n### 2.3 LocalDateTime获取方法 (应用)\n\n+ 方法说明\n\n  | 方法名                             | 说明               |\n  | ------------------------------- | ---------------- |\n  | public int getYear()            | 获取年              |\n  | public int getMonthValue()      | 获取月份（1-12）       |\n  | public int getDayOfMonth()      | 获取月份中的第几天（1-31）  |\n  | public int getDayOfYear()       | 获取一年中的第几天（1-366） |\n  | public DayOfWeek getDayOfWeek() | 获取星期             |\n  | public int getMinute()          | 获取分钟             |\n  | public int getHour()            | 获取小时             |\n\n+ 示例代码\n\n  ```java\n  public class JDK8DateDemo3 {\n      public static void main(String[] args) {\n          LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 11, 11, 20);\n          //public int getYear()           获取年\n          int year = localDateTime.getYear();\n          System.out.println("年为" +year);\n          //public int getMonthValue()     获取月份（1-12）\n          int month = localDateTime.getMonthValue();\n          System.out.println("月份为" + month);\n\n          Month month1 = localDateTime.getMonth();\n  //        System.out.println(month1);\n\n          //public int getDayOfMonth()     获取月份中的第几天（1-31）\n          int day = localDateTime.getDayOfMonth();\n          System.out.println("日期为" + day);\n\n          //public int getDayOfYear()      获取一年中的第几天（1-366）\n          int dayOfYear = localDateTime.getDayOfYear();\n          System.out.println("这是一年中的第" + dayOfYear + "天");\n\n          //public DayOfWeek getDayOfWeek()获取星期\n          DayOfWeek dayOfWeek = localDateTime.getDayOfWeek();\n          System.out.println("星期为" + dayOfWeek);\n\n          //public int getMinute()        获取分钟\n          int minute = localDateTime.getMinute();\n          System.out.println("分钟为" + minute);\n          //public int getHour()           获取小时\n    \n          int hour = localDateTime.getHour();\n          System.out.println("小时为" + hour);\n      }\n  }\n  ```\n\n### 2.4 LocalDateTime转换方法 (应用)\n\n+ 方法说明\n\n  | 方法名                              | 说明                |\n  | -------------------------------- | ----------------- |\n  | public LocalDate  toLocalDate () | 转换成为一个LocalDate对象 |\n  | public LocalTime toLocalTime ()  | 转换成为一个LocalTime对象 |\n\n+ 示例代码\n\n  ```java\n  public class JDK8DateDemo4 {\n      public static void main(String[] args) {\n          LocalDateTime localDateTime = LocalDateTime.of(2020, 12, 12, 8, 10, 12);\n          //public LocalDate toLocalDate ()    转换成为一个LocalDate对象\n          LocalDate localDate = localDateTime.toLocalDate();\n          System.out.println(localDate);\n\n          //public LocalTime toLocalTime ()    转换成为一个LocalTime对象\n          LocalTime localTime = localDateTime.toLocalTime();\n          System.out.println(localTime);\n      }\n  }\n  ```\n\n### 2.5 LocalDateTime格式化和解析 (应用)\n\n+ 方法说明\n\n  | 方法名                                      | 说明                                     |\n  | ---------------------------------------- | -------------------------------------- |\n  | public String format (指定格式)              | 把一个LocalDateTime格式化成为一个字符串             |\n  | public LocalDateTime parse (准备解析的字符串, 解析格式) | 把一个日期字符串解析成为一个LocalDateTime对象          |\n  | public static DateTimeFormatter ofPattern(String pattern) | 使用指定的日期模板获取一个日期格式化器DateTimeFormatter对象 |\n\n+ 示例代码\n\n  ```java\n  public class JDK8DateDemo5 {\n      public static void main(String[] args) {\n          //method1();\n          //method2();\n      }\n\n      private static void method2() {\n          //public static LocalDateTime parse (准备解析的字符串, 解析格式) 把一个日期字符串解析成为一个LocalDateTime对象\n          String s = "2020年11月12日 13:14:15";\n          DateTimeFormatter pattern = DateTimeFormatter.ofPattern("yyyy年MM月dd日 HH:mm:ss");\n          LocalDateTime parse = LocalDateTime.parse(s, pattern);\n          System.out.println(parse);\n      }\n\n      private static void method1() {\n          LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 12, 13, 14, 15);\n          System.out.println(localDateTime);\n          //public String format (指定格式)   把一个LocalDateTime格式化成为一个字符串\n          DateTimeFormatter pattern = DateTimeFormatter.ofPattern("yyyy年MM月dd日 HH:mm:ss");\n          String s = localDateTime.format(pattern);\n          System.out.println(s);\n      }\n  }\n  ```\n\n### 2.6 LocalDateTime增加或者减少时间的方法 (应用)\n\n+ 方法说明\n\n  | 方法名                                      | 说明      |\n  | ---------------------------------------- | ------- |\n  | public LocalDateTime plusYears (long years) | 添加或者减去年 |\n  | public LocalDateTime plusMonths(long months) | 添加或者减去月 |\n  | public LocalDateTime plusDays(long days) | 添加或者减去日 |\n  | public LocalDateTime plusHours(long hours) | 添加或者减去时 |\n  | public LocalDateTime plusMinutes(long minutes) | 添加或者减去分 |\n  | public LocalDateTime plusSeconds(long seconds) | 添加或者减去秒 |\n  | public LocalDateTime plusWeeks(long weeks) | 添加或者减去周 |\n\n+ 示例代码\n\n  ```java\n  /**\n   * JDK8 时间类添加或者减去时间的方法\n   */\n  public class JDK8DateDemo6 {\n      public static void main(String[] args) {\n          //public LocalDateTime plusYears (long years)   添加或者减去年\n\n          LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 13, 14, 15);\n          //LocalDateTime newLocalDateTime = localDateTime.plusYears(1);\n          //System.out.println(newLocalDateTime);\n\n          LocalDateTime newLocalDateTime = localDateTime.plusYears(-1);\n          System.out.println(newLocalDateTime);\n      }\n  }\n  ```\n\n### 2.7 LocalDateTime减少或者增加时间的方法 (应用)\n\n+ 方法说明\n\n  | 方法名                                      | 说明      |\n  | ---------------------------------------- | ------- |\n  | public LocalDateTime  minusYears (long years) | 减去或者添加年 |\n  | public LocalDateTime  minusMonths(long months) | 减去或者添加月 |\n  | public LocalDateTime minusDays(long days) | 减去或者添加日 |\n  | public LocalDateTime minusHours(long hours) | 减去或者添加时 |\n  | public LocalDateTime minusMinutes(long minutes) | 减去或者添加分 |\n  | public LocalDateTime minusSeconds(long seconds) | 减去或者添加秒 |\n  | public LocalDateTime minusWeeks(long weeks) | 减去或者添加周 |\n\n+ 示例代码\n\n  ```java\n  /**\n   * JDK8 时间类减少或者添加时间的方法\n   */\n  public class JDK8DateDemo7 {\n      public static void main(String[] args) {\n          //public LocalDateTime minusYears (long years)  减去或者添加年\n          LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 13, 14, 15);\n          //LocalDateTime newLocalDateTime = localDateTime.minusYears(1);\n          //System.out.println(newLocalDateTime);\n\n          LocalDateTime newLocalDateTime = localDateTime.minusYears(-1);\n          System.out.println(newLocalDateTime);\n\n      }\n  }\n  ```\n\n### 2.8 LocalDateTime修改方法 (应用)\n\n+ 方法说明\n\n  | 方法名                                      | 说明               |\n  | ---------------------------------------- | ---------------- |\n  | public LocalDateTime withYear(int year)  | 直接修改年            |\n  | public LocalDateTime withMonth(int month) | 直接修改月            |\n  | public LocalDateTime withDayOfMonth(int dayofmonth) | 直接修改日期(一个月中的第几天) |\n  | public LocalDateTime withDayOfYear(int dayOfYear) | 直接修改日期(一年中的第几天)  |\n  | public LocalDateTime withHour(int hour)  | 直接修改小时           |\n  | public LocalDateTime withMinute(int minute) | 直接修改分钟           |\n  | public LocalDateTime withSecond(int second) | 直接修改秒            |\n\n+ 示例代码\n\n  ```java\n  /**\n   * JDK8 时间类修改时间\n   */\n  public class JDK8DateDemo8 {\n      public static void main(String[] args) {\n          //public LocalDateTime withYear(int year)   修改年\n          LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 13, 14, 15);\n         // LocalDateTime newLocalDateTime = localDateTime.withYear(2048);\n         // System.out.println(newLocalDateTime);\n\n          LocalDateTime newLocalDateTime = localDateTime.withMonth(20);\n          System.out.println(newLocalDateTime);\n\n      }\n  }\n  ```\n\n### 2.9 Period (应用)\n\n+ 方法说明\n\n  | 方法名                                     | 说明          |\n  | --------------------------------------- | ----------- |\n  | public static Period between(开始时间,结束时间) | 计算两个“时间"的间隔 |\n  | public int getYears()                   | 获得这段时间的年数   |\n  | public int getMonths()                  | 获得此期间的总月数   |\n  | public int getDays()                    | 获得此期间的天数    |\n  | public long toTotalMonths()             | 获取此期间的总月数   |\n\n+ 示例代码\n\n  ```java\n  /**\n   *  计算两个时间的间隔\n   */\n  public class JDK8DateDemo9 {\n      public static void main(String[] args) {\n          //public static Period between(开始时间,结束时间)  计算两个"时间"的间隔\n\n          LocalDate localDate1 = LocalDate.of(2020, 1, 1);\n          LocalDate localDate2 = LocalDate.of(2048, 12, 12);\n          Period period = Period.between(localDate1, localDate2);\n          System.out.println(period);//P28Y11M11D\n\n          //public int getYears()         获得这段时间的年数\n          System.out.println(period.getYears());//28\n          //public int getMonths()        获得此期间的月数\n          System.out.println(period.getMonths());//11\n          //public int getDays()          获得此期间的天数\n          System.out.println(period.getDays());//11\n\n          //public long toTotalMonths()   获取此期间的总月数\n          System.out.println(period.toTotalMonths());//347\n\n      }\n  }\n  ```\n\n### 2.10 Duration (应用)\n\n+ 方法说明\n\n  | 方法名                                      | 说明          |\n  | ---------------------------------------- | ----------- |\n  | public static Durationbetween(开始时间,结束时间) | 计算两个“时间"的间隔 |\n  | public long toSeconds()                  | 获得此时间间隔的秒   |\n  | public int toMillis()                    | 获得此时间间隔的毫秒  |\n  | public int toNanos()                     | 获得此时间间隔的纳秒  |\n\n+ 示例代码\n\n  ```java\n  /**\n   *  计算两个时间的间隔\n   */\n  public class JDK8DateDemo10 {\n      public static void main(String[] args) {\n          //public static Duration between(开始时间,结束时间)  计算两个“时间"的间隔\n\n          LocalDateTime localDateTime1 = LocalDateTime.of(2020, 1, 1, 13, 14, 15);\n          LocalDateTime localDateTime2 = LocalDateTime.of(2020, 1, 2, 11, 12, 13);\n          Duration duration = Duration.between(localDateTime1, localDateTime2);\n          System.out.println(duration);//PT21H57M58S\n          //public long toSeconds()\t       获得此时间间隔的秒\n          System.out.println(duration.toSeconds());//79078\n          //public int toMillis()\t           获得此时间间隔的毫秒\n          System.out.println(duration.toMillis());//79078000\n          //public int toNanos()             获得此时间间隔的纳秒\n          System.out.println(duration.toNanos());//79078000000000\n      }\n  }\n  ```\n\n## 3.异常\n\n### 3.1 异常（记忆）\n\n- 异常的概述\n\n  ​\t异常就是程序出现了不正常的情况\n\n- 异常的体系结构\n\n  ![01_异常体系结构](./day15-常用API02.img/01_异常体系结构.png)\n\n### 3.2 编译时异常和运行时异常的区别（记忆）\n\n- 编译时异常\n\n  - 都是Exception类及其子类\n  - 必须显示处理，否则程序就会发生错误，无法通过编译\n\n- 运行时异常\n\n  - 都是RuntimeException类及其子类\n  - 无需显示处理，也可以和编译时异常一样处理\n\n- 图示\n\n  ![02_编译时异常和运行时异常](./day15-常用API02.img/02_编译时异常和运行时异常.png)\n\n### 3.3 JVM默认处理异常的方式（理解）\n\n- 如果程序出现了问题，我们没有做任何处理，最终JVM 会做默认的处理，处理方式有如下两个步骤：\n  - 把异常的名称，错误原因及异常出现的位置等信息输出在了控制台\n  - 程序停止执行\n\n### 3.4 查看异常信息 (理解) \n\n控制台在打印异常信息时,会打印异常类名,异常出现的原因,异常出现的位置\n\n我们调bug时,可以根据提示,找到异常出现的位置,分析原因,修改异常代码\n\n![03_查看异常信息](./day15-常用API02.img/03_查看异常信息.png)\n\n### 3.5 throws方式处理异常（应用）\n\n- 定义格式\n\n  ```java\n  public void 方法() throws 异常类名 {\n      \n  }\n  ```\n\n- 示例代码\n\n  ```java\n  public class ExceptionDemo {\n      public static void main(String[] args) throws ParseException{\n          System.out.println("开始");\n  //        method();\n            method2();\n\n          System.out.println("结束");\n      }\n\n      //编译时异常\n      public static void method2() throws ParseException {\n          String s = "2048-08-09";\n          SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");\n          Date d = sdf.parse(s);\n          System.out.println(d);\n      }\n\n      //运行时异常\n      public static void method() throws ArrayIndexOutOfBoundsException {\n          int[] arr = {1, 2, 3};\n          System.out.println(arr[3]);\n      }\n  }\n  ```\n\n- 注意事项\n\n  - 这个throws格式是跟在方法的括号后面的\n  - 编译时异常必须要进行处理，两种处理方案：try...catch …或者 throws，如果采用 throws 这种方案，在方法上进行显示声明,将来谁调用这个方法谁处理\n  - 运行时异常因为在运行时才会发生,所以在方法后面可以不写,运行时出现异常默认交给jvm处理\n\n### 3.6 throw抛出异常 (应用) \n\n+ 格式\n\n  throw new 异常();\n\n+ 注意\n\n  这个格式是在方法内的，表示当前代码手动抛出一个异常，下面的代码不用再执行了\n\n+ throws和throw的区别\n\n  | throws                  | throw                 |\n  | ----------------------- | --------------------- |\n  | 用在方法声明后面，跟的是异常类名        | 用在方法体内，跟的是异常对象名       |\n  | 表示声明异常，调用该方法有可能会出现这样的异常 | 表示手动抛出异常对象，由方法体内的语句处理 |\n\n+ 示例代码\n\n  ```java\n  public class ExceptionDemo8 {\n      public static void main(String[] args) {\n          //int [] arr = {1,2,3,4,5};\n          int [] arr = null;\n          printArr(arr);//就会 接收到一个异常.\n                          //我们还需要自己处理一下异常.\n      }\n\n      private static void printArr(int[] arr) {\n          if(arr == null){\n              //调用者知道成功打印了吗?\n              //System.out.println("参数不能为null");\n              throw new NullPointerException(); //当参数为null的时候\n                                              //手动创建了一个异常对象,抛给了调用者,产生了一个异常\n          }else{\n              for (int i = 0; i < arr.length; i++) {\n                  System.out.println(arr[i]);\n              }\n          }\n      }\n\n  }\n  ```\n\n### 3.7 try-catch方式处理异常（应用）\n\n- 定义格式\n\n  ```java\n  try {\n  \t可能出现异常的代码;\n  } catch(异常类名 变量名) {\n  \t异常的处理代码;\n  }\n  ```\n\n- 执行流程\n\n  - 程序从 try 里面的代码开始执行\n  - 出现异常，就会跳转到对应的 catch 里面去执行\n  - 执行完毕之后，程序还可以继续往下执行\n\n- 示例代码\n\n  ```java\n  public class ExceptionDemo01 {\n      public static void main(String[] args) {\n          System.out.println("开始");\n          method();\n          System.out.println("结束");\n      }\n\n      public static void method() {\n          try {\n              int[] arr = {1, 2, 3};\n              System.out.println(arr[3]);\n              System.out.println("这里能够访问到吗");\n          } catch (ArrayIndexOutOfBoundsException e) {\n              System.out.println("你访问的数组索引不存在，请回去修改为正确的索引");\n          }\n      }\n  }\n  ```\n\n- 注意\n\n  1. 如果 try 中没有遇到问题，怎么执行？\n\n     会把try中所有的代码全部执行完毕,不会执行catch里面的代码\n\n  2. 如果 try 中遇到了问题，那么 try 下面的代码还会执行吗？\n\n     那么直接跳转到对应的catch语句中,try下面的代码就不会再执行了\n     当catch里面的语句全部执行完毕,表示整个体系全部执行完全,继续执行下面的代码\n\n  3. 如果出现的问题没有被捕获，那么程序如何运行？\n\n     那么try...catch就相当于没有写.那么也就是自己没有处理.\n     默认交给虚拟机处理.\n\n  4. 同时有可能出现多个异常怎么处理？\n\n     出现多个异常,那么就写多个catch就可以了.\n     注意点:如果多个异常之间存在子父类关系.那么父类一定要写在下面\n\n### 3.8 Throwable成员方法（应用）\n\n- 常用方法\n\n  | 方法名                           | 说明                     |\n  | ----------------------------- | ---------------------- |\n  | public String getMessage()    | 返回此 throwable 的详细消息字符串 |\n  | public String toString()      | 返回此可抛出的简短描述            |\n  | public void printStackTrace() | 把异常的错误信息输出在控制台         |\n\n- 示例代码\n\n  ```java\n  public class ExceptionDemo02 {\n      public static void main(String[] args) {\n          System.out.println("开始");\n          method();\n          System.out.println("结束");\n      }\n\n      public static void method() {\n          try {\n              int[] arr = {1, 2, 3};\n              System.out.println(arr[3]); //new ArrayIndexOutOfBoundsException();\n              System.out.println("这里能够访问到吗");\n          } catch (ArrayIndexOutOfBoundsException e) { //new ArrayIndexOutOfBoundsException();\n  //            e.printStackTrace();\n\n              //public String getMessage():返回此 throwable 的详细消息字符串\n  //            System.out.println(e.getMessage());\n              //Index 3 out of bounds for length 3\n\n              //public String toString():返回此可抛出的简短描述\n  //            System.out.println(e.toString());\n              //java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\n\n              //public void printStackTrace():把异常的错误信息输出在控制台\n              e.printStackTrace();\n  //            java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\n  //            at com.itheima_02.ExceptionDemo02.method(ExceptionDemo02.java:18)\n  //            at com.itheima_02.ExceptionDemo02.main(ExceptionDemo02.java:11)\n\n          }\n      }\n  }\n  ```\n\n### 3.9 异常的练习 (应用) \n\n+ 需求\n\n  键盘录入学生的姓名和年龄,其中年龄为18 - 25岁,超出这个范围是异常数据不能赋值.需要重新录入,一直录到正确为止\n\n+ 实现步骤\n\n  1. 创建学生对象\n  2. 键盘录入姓名和年龄，并赋值给学生对象\n  3. 如果是非法数据就再次录入\n\n+ 代码实现\n\n  学生类\n\n  ```java\n  public class Student {\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          if(age >= 18 && age <= 25){\n              this.age = age;\n          }else{\n              //当年龄不合法时,产生一个异常\n              throw new RuntimeException("年龄超出了范围");\n          }\n      }\n\n      @Override\n      public String toString() {\n          return "Student{" +\n                  "name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class ExceptionDemo12 {\n      public static void main(String[] args) {\n          // 键盘录入学生的姓名和年龄,其中年龄为 18 - 25岁,\n          // 超出这个范围是异常数据不能赋值.需要重新录入,一直录到正确为止。\n\n          Student s = new Student();\n\n          Scanner sc = new Scanner(System.in);\n          System.out.println("请输入姓名");\n          String name = sc.nextLine();\n          s.setName(name);\n         while(true){\n             System.out.println("请输入年龄");\n             String ageStr = sc.nextLine();\n             try {\n                 int age = Integer.parseInt(ageStr);\n                 s.setAge(age);\n                 break;\n             } catch (NumberFormatException e) {\n                 System.out.println("请输入一个整数");\n                 continue;\n             } catch (AgeOutOfBoundsException e) {\n                 System.out.println(e.toString());\n                 System.out.println("请输入一个符合范围的年龄");\n                 continue;\n             }\n             /*if(age >= 18 && age <=25){\n                 s.setAge(age);\n                 break;\n             }else{\n                 System.out.println("请输入符合要求的年龄");\n                 continue;\n             }*/\n         }\n          System.out.println(s);\n\n      }\n  }\n  ```\n\n### 3.10 自定义异常（应用）\n\n+ 自定义异常概述\n\n  当Java中提供的异常不能满足我们的需求时,我们可以自定义异常\n\n+ 实现步骤\n\n  1. 定义异常类\n  2. 写继承关系\n  3. 提供空参构造\n  4. 提供带参构造\n\n+ 代码实现\n\n  异常类\n\n  ```java\n  public class AgeOutOfBoundsException extends RuntimeException {\n      public AgeOutOfBoundsException() {\n      }\n\n      public AgeOutOfBoundsException(String message) {\n          super(message);\n      }\n  }\n  ```\n\n  学生类\n\n  ```java\n  public class Student {\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          if(age >= 18 && age <= 25){\n              this.age = age;\n          }else{\n              //如果Java中提供的异常不能满足我们的需求,我们可以使用自定义的异常\n              throw new AgeOutOfBoundsException("年龄超出了范围");\n          }\n      }\n\n      @Override\n      public String toString() {\n          return "Student{" +\n                  "name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class ExceptionDemo12 {\n      public static void main(String[] args) {\n          // 键盘录入学生的姓名和年龄,其中年龄为 18 - 25岁,\n          // 超出这个范围是异常数据不能赋值.需要重新录入,一直录到正确为止。\n\n          Student s = new Student();\n\n          Scanner sc = new Scanner(System.in);\n          System.out.println("请输入姓名");\n          String name = sc.nextLine();\n          s.setName(name);\n         while(true){\n             System.out.println("请输入年龄");\n             String ageStr = sc.nextLine();\n             try {\n                 int age = Integer.parseInt(ageStr);\n                 s.setAge(age);\n                 break;\n             } catch (NumberFormatException e) {\n                 System.out.println("请输入一个整数");\n                 continue;\n             } catch (AgeOutOfBoundsException e) {\n                 System.out.println(e.toString());\n                 System.out.println("请输入一个符合范围的年龄");\n                 continue;\n             }\n             /*if(age >= 18 && age <=25){\n                 s.setAge(age);\n                 break;\n             }else{\n                 System.out.println("请输入符合要求的年龄");\n                 continue;\n             }*/\n         }\n          System.out.println(s);\n\n      }\n  }\n  ```\n\n\n## 4.Optional\n\n### 4.1获取对象(应用)\n\n+ Optional概述\n\n  可能包含或不包含非null值的容器对象\n\n+ 方法介绍\n\n  | 方法名                                      | 说明                                       |\n  | ---------------------------------------- | ---------------------------------------- |\n  | static <T> Optional<T> of(T value)       | 获取一个Optional对象，封装的是非null值的对象             |\n  | static <T> Optional<T> ofNullable(T value) | 获取一个Optional对象，Optional封装的值对象可以是null也可以不是null |\n\n+ 示例代码\n\n  ```java\n  public class OptionalDemo1 {\n      public static void main(String[] args) {\n          //method1();\n\n          //public static <T> Optional<T> ofNullable(T value)\n          //获取一个Optional对象，Optional封装的值对象可以是null也可以不是null\n          //Student s = new Student("zhangsan",23);\n          Student s = null;\n          //ofNullable方法，封装的对象可以是null，也可以不是null。\n          Optional<Student> optional = Optional.ofNullable(s);\n\n          System.out.println(optional);\n      }\n\n      private static void method1() {\n          //static <T> Optional<T> of(T value)    获取一个Optional对象，封装的是非null值的对象\n\n          //Student s = new Student("zhangsan",23);\n          Student s = null;\n          //Optional可以看做是一个容器，里面装了一个引用数据类型的对象。\n          //返回值就是Optional的对象\n          //如果使用of方法，封装的对象如果为空，那么还是会抛出空指针异常\n          Optional<Student> optional1 = Optional.of(s);\n          System.out.println(optional1);\n      }\n  }\n  ```\n\n### 4.2常用方法(应用)\n\n+ 方法介绍\n\n  | 方法名                 | 说明                                   |\n  | ------------------- | ------------------------------------ |\n  | T get()             | 如果存在值,返回值,否则抛出NoSuchElementException |\n  | boolean isPresent() | 如果存在值,则返回true,否则为false               |\n\n+ 示例代码\n\n  ```java\n  public class OptionalDemo2 {\n      public static void main(String[] args) {\n          //get() 如果存在值，返回值，否则抛出NoSuchElementException\n          //public boolean isPresent()    判断Optional所封装的对象是否不为空，如果不为空返回true , 否则返回false\n\n          //Student s = new Student("zhangsan",23);\n          Student s = null;\n          Optional<Student> optional = Optional.ofNullable(s);\n          //如果封装的是一个null，那么通过get方法再次获取会抛出NoSuchElementException。\n          if(optional.isPresent()){\n              Student student = optional.get();\n              System.out.println(student);\n          }else{\n              System.out.println("Optional封装的对象为空");\n          }\n      }\n  }\n  ```\n\n### 4.3处理空指针的方法(应用)\n\n+ 方法介绍\n\n  | 方法名                                      | 说明                               |\n  | ---------------------------------------- | -------------------------------- |\n  | T orElse(T other)                        | 如果不为空,则返回具体的值,否则返回参数中的值          |\n  | T orElseGet(Supplier<? extends T> supplier) | 如果不为空,则返回具体的值,否则返回由括号中函数产生的结果    |\n  | void ifPresent (Consumer<? super T> action) | 如果不为空,则使用该值执行给定的操作,否则不执行任何操作     |\n  | void ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction) | 如果不为空,则使用该值执行给定的操作,否则执行给定的基于空的操作 |\n\n+ 示例代码\n\n  ```java\n  public class OptionalDemo3 {\n      public static void main(String[] args) {\n          //method1();\n\n          //method2();\n          //method3();\n          //method4();\n\n      }\n\n      private static void method4() {\n          //Student s = new Student("zhangsan",23);\n          Student s = null;\n          Optional<Student> optional = Optional.ofNullable(s);\n          //public void ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction)、\n          //如果不为空，则使用该值执行给定的操作，否则执行给定的基于空的操作。\n          optional.ifPresentOrElse(student -> System.out.println(student),\n                  ()->System.out.println("为空了"));\n      }\n\n      private static void method3() {\n          //Student s = new Student("zhangsan",23);\n          Student s = null;\n          Optional<Student> optional = Optional.ofNullable(s);\n          //ifPresent (Consumer<? super T> action)\n          //如果不为空，则使用该值执行给定的操作，否则不执行任何操作\n          optional.ifPresent(student -> System.out.println(student));\n      }\n\n      private static void method2() {\n          Student s = new Student("zhangsan",23);\n          //Student s = null;\n          Optional<Student> optional = Optional.ofNullable(s);\n          //orElseGet(Supplier<? extends T> supplier)\n          //如果不为空，则返回具体的值，否则返回由括号中函数产生的结果\n\n          Student student = optional.orElseGet(()-> new Student("lisi" , 24));\n          System.out.println(student);\n      }\n\n      private static void method1() {\n          //Student s = new Student("zhangsan",23);\n          Student s = null;\n          Optional<Student> optional = Optional.ofNullable(s);\n          //orElse(T other) 如果不为空，则返回具体的值，否则返回参数中的值\n          Student student = optional.orElse(new Student("lisi", 24));\n          System.out.println(student);\n      }\n  }\n  ```\n\n  ​'},fd4e:function(n,e,t){"use strict";t.r(e),e["default"]='# JAVA核心知识点最详细版（面试必备）\r\n\r\n- \r\n  \\1. JVM、JRE及JDK的关系 ＊＊\r\n\r\n- \\2. JAVA语言特点　＊＊\r\n\r\n- \\3. JAVA和C++的区别　＊＊\r\n\r\n- \\4. Java的基本数据类型 　＊＊\r\n\r\n- \\5. 隐式(自动)类型转换和显示(强制)类型转换　＊＊\r\n\r\n- \\6. 自动装箱与拆箱 ＊＊\r\n\r\n- - String(不是基本数据类型)\r\n  - \\7. String的不可变性  ＊＊＊\r\n  - \\8. 字符型常量和字符串常量的区别 ＊\r\n  - \\9. 什么是字符串常量池？＊\r\n  - \\10. String 类的常用方法都有哪些？＊＊\r\n  - \\11. String和StringBuffer、StringBuilder的区别是什么？＊＊＊\r\n\r\n- \\12. switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上 ＊\r\n\r\n- \\13. Java语言采用何种编码方案？有何特点？＊\r\n\r\n- \\14. 访问修饰符 ＊＊\r\n\r\n- \\15. 运算符　＊\r\n\r\n- - 关键字\r\n  - \\16. static关键字　＊＊＊\r\n  - \\17. final 关键字　＊＊＊\r\n  - \\18. final finally finalize区别　＊＊＊\r\n  - \\19. this关键字　＊＊\r\n  - \\20. super关键字 ＊＊\r\n  - \\21. this与super的区别　＊＊\r\n  - \\22. break ,continue ,return 的区别及作用　＊＊\r\n\r\n- \\23. 面向对象和面向过程的区别　＊＊\r\n\r\n- \\24. 面向对象三大特性(封装、继承、多态)　＊＊＊\r\n\r\n- \\25. 面向对象五大基本原则是什么　＊＊\r\n\r\n- \\26. 抽象类和接口的对比　＊＊＊\r\n\r\n- \\27. 在Java中定义一个不做事且没有参数的构造方法的作用　＊\r\n\r\n- \\28. 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是 ＊\r\n\r\n- \\29. 一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？ ＊\r\n\r\n- \\30. 构造方法有哪些特性？　＊＊\r\n\r\n- \\31. 变量　＊＊\r\n\r\n- \\32. 内部类　＊＊\r\n\r\n- 重写与重载　＊＊＊\r\n\r\n- - \\33. 重载和重写的区别\r\n  - \\34. 构造器（constructor）是否可被重写（override）\r\n  - \\35. 重载的方法能否根据返回类型进行区分？为什么？\r\n\r\n- \\36. == 和 equals 的区别　＊＊＊\r\n\r\n- \\37. hashCode 与 equals（为什么重写equals方法后，hashCode方法也必须重写）　＊＊＊\r\n\r\n- \\38. Java 中是值传递还是引用传递，还是两者共存　＊＊\r\n\r\n- \\39. IO流　＊\r\n\r\n- \\40. BIO,NIO,AIO 有什么区别?　＊＊\r\n\r\n- \\41. 反射　＊＊＊\r\n\r\n- \\42. JAVA异常　＊＊＊\r\n\r\n- \\43. JAVA注解　＊＊\r\n\r\n- \\44. JAVA泛型　＊＊＊\r\n\r\n- \\45. JAVA序列化　＊＊\r\n\r\n- \\46. 深拷贝与浅拷贝　＊＊＊\r\n\r\n- \\47. 常见的Object方法　＊＊＊\r\n\r\n往期内容：\r\n\r\n- [面试官：请用五种方法来实现多线程交替打印问题](http://mp.weixin.qq.com/s?__biz=MzA4NjU1MzA2MQ==&mid=2647724685&idx=1&sn=0c4d54e897753b6ff2b67c4e214c28ba&chksm=87e34a07b094c311e5ed6d1d791d5d8e30ecd6c0975dbcdb1dfeab24b7c24614e6f6c119e365&scene=21#wechat_redirect)\r\n- [并发编程高频面试题第一弹](http://mp.weixin.qq.com/s?__biz=MzA4NjU1MzA2MQ==&mid=2647724650&idx=1&sn=361a6102991e5123a5a94727143aaca3&chksm=87e34ae0b094c3f6ec01c245b38312163af096c2b019e1dd89961279980655f49eb890bb9307&scene=21#wechat_redirect)\r\n- [技术岗面试中的一些常见问题](http://mp.weixin.qq.com/s?__biz=MzA4NjU1MzA2MQ==&mid=2647724575&idx=1&sn=1cb6f9974485a4fee9faaf6f12612132&chksm=87e34a95b094c383b055b18360f75df627aa2d8fa19678b2ae5386134af641ec5c2c06a49378&scene=21#wechat_redirect)\r\n\r\n## 1. JVM、JRE及JDK的关系 ＊＊\r\n\r\nJDK（Java Development Kit）是针对Java开发员的产品，是整个Java的核心，包括了Java运行环境JRE、Java工具和Java基础类库。\r\n\r\nJava Runtime Environment（JRE）是运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。\r\n\r\nJVM是Java Virtual Machine（Java虚拟机）的缩写，是整个java实现跨平台的最核心的部分，能够运行以Java语言写作的软件程序。\r\n\r\n**简单来说就是JDK是Java的开发工具，JRE是Java程序运行所需的环境，JVM是Java虚拟机．它们之间的关系是JDK包含JRE和JVM，JRE包含JVM．**\r\n\r\n## 2. JAVA语言特点　＊＊\r\n\r\n- Java是一种面向对象的语言\r\n- Java通过Java虚拟机实现了平台无关性，一次编译，到处运行\r\n- 支持多线程\r\n- 支持网络编程\r\n- 具有较高的安全性和可靠性\r\n\r\n## 3. JAVA和C++的区别　＊＊\r\n\r\n> 面试时记住前四个就行了\r\n\r\n- Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。\r\n- Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。\r\n- Java 支持自动垃圾回收，而 C++ 需要手动回收。\r\n- Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。\r\n- Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操 作符重载，而 C++ 可以。\r\n- Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。\r\n\r\n## 4. Java的基本数据类型 　＊＊\r\n\r\n> 注意`String`不是基本数据类型\r\n\r\n|     类型     | 关键字  | 包装器类型 | 占用内存(字节)(**重要**) |         取值范围          |  默认值  |\r\n| :----------: | :-----: | :--------: | :----------------------: | :-----------------------: | :------: |\r\n|    字节型    |  byte   |    Byte    |            1             | -128(-2^7)  ~  127(2^7-1) |    0     |\r\n|    短整型    |  short  |   Short    |            2             |     -2^15  ~  2^15-1      |    0     |\r\n|     整型     |   int   |  Integer   |            4             |     -2^31  ~  2^31-1      |    0     |\r\n|    长整型    |  long   |    Long    |            8             |     -2^63  ~  2^63-1      |    0L    |\r\n| 单精度浮点型 |  float  |   Float    |            4             |    3.4e-45  ~  1.4e38     |   0.0F   |\r\n| 双精度浮点型 | double  |   Double   |            8             |   4.9e-324  ~  1.8e308    |   0.0D   |\r\n|    字符型    |  char   | Character  |            2             |                           | \'\\u0000\' |\r\n|    布尔型    | boolean |  Boolean   |            1             |        true/flase         |  flase   |\r\n\r\n## 5. 隐式(自动)类型转换和显示(强制)类型转换　＊＊\r\n\r\n- 隐式(自动)类型转换：从存储范围小的类型到存储范围大的类型。`byte`→`short(char)`→`int`→`long`→`float`→`double`\r\n- 显示(强制)类型转换：从存储范围大的类型到存储范围小的类型。`double`→`float`→`long`→`int`→`short(char)`→`byte`。该类类型转换很可能存在精度的损失。\r\n\r\n看一个经典的代码\r\n\r\n```\r\nshort s = 1;\r\ns = s + 1;\r\n```\r\n\r\n这是会报错的，因为1是`int`型，`s+1`会自动转换为`int`型，将`int`型直接赋值给`short`型会报错。\r\n\r\n做一下修改即可避免报错\r\n\r\n```\r\nshort s = 1;\r\ns = (short)(s + 1);\r\n```\r\n\r\n或这样写，因为`s += 1`会自动进行强制类型转换\r\n\r\n```\r\nshort s = 1;\r\ns += 1;\r\n```\r\n\r\n## 6. 自动装箱与拆箱 ＊＊\r\n\r\n- 装箱：将基本类型用包装器类型包装起来\r\n\r\n- 拆箱：将包装器类型转换为基本类型\r\n\r\n  > 这个地方有很多易混淆的地方，但在面试中问到的频率一般，笔试的选择题中经常出现，还有一个`String`创建对象和这个比较像，很容易混淆，在下文可以看到\r\n\r\n- 下面这段代码的输出结果是什么？\r\n\r\n  ```\r\n  public class Main {\r\n      public static void main(String[] args) {\r\n          \r\n              Integer a = 100;\r\n              Integer b = 100;\r\n              Integer c = 128;\r\n              Integer d = 128;\r\n  \r\n              System.out.println(a==b);\r\n              System.out.println(c==d);\r\n      }\r\n  }\r\n  ```\r\n\r\n  ```\r\n  true\r\n  false\r\n  ```\r\n\r\n  很多人看到这个结果会很疑惑，为什么会是一个`true`一个`flase`．其实从源码中可以很容易找到原因．首先找到`Integer`方法中的`valueOf`方法\r\n\r\n  ```\r\n  public static Integer valueOf(int i) {\r\n        if (i >= IntegerCache.low && i <= IntegerCache.high)\r\n          return IntegerCache.cache[i + (-IntegerCache.low)];\r\n        return new Integer(i);\r\n    }\r\n  ```\r\n\r\n  可以看到当不满足`if`语句中的条件，就会重新创建一个对象返回，那结果必然不相等。继续打开`IntegerCache`可以看到\r\n\r\n  ```\r\n      private static class IntegerCache {\r\n            static final int low = -128;\r\n          static final int high;\r\n            static final Integer cache[];\r\n    \r\n            static {\r\n                // high value may be configured by property\r\n                int h = 127;\r\n                String integerCacheHighPropValue =\r\n                    sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");\r\n                if (integerCacheHighPropValue != null) {\r\n                    try {\r\n                        int i = parseInt(integerCacheHighPropValue);\r\n                        i = Math.max(i, 127);\r\n                        // Maximum array size is Integer.MAX_VALUE\r\n                        h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\r\n                    } catch( NumberFormatException nfe) {\r\n                        // If the property cannot be parsed into an int, ignore it.\r\n                    }\r\n                }\r\n                high = h;\r\n    \r\n                cache = new Integer[(high - low) + 1];\r\n                int j = low;\r\n                for(int k = 0; k < cache.length; k++)\r\n                    cache[k] = new Integer(j++);\r\n    \r\n                // range [-128, 127] must be interned (JLS7 5.1.7)\r\n                assert IntegerCache.high >= 127;\r\n            }\r\n    \r\n            private IntegerCache() {}\r\n        }\r\n  ```\r\n\r\n  代码挺长，大概说的就是在通过`valueOf`方法创建`Integer`对象的时候，如果数值在[-128,127]之间，便返回指向`IntegerCache.cache`中已经存在的对象的引用；否则创建一个新的`Integer`对象。所以上面代码中`a`与`b`相等，`c`与`d`不相等。\r\n\r\n- 再看下面的代码会输出什么\r\n\r\n  ```\r\n  public class Main {\r\n      public static void main(String[] args) {\r\n  \r\n              Double a = 1.0;\r\n              Double b = 1.0;\r\n              Double c = 2.0;\r\n              Double d = 2.0;\r\n  \r\n              System.out.println(a==b);\r\n              System.out.println(c==d);\r\n  \r\n      }\r\n  }\r\n  ```\r\n\r\n  ```\r\n  flase\r\n  flase\r\n  ```\r\n\r\n  采用同样的方法，可以看到`Double`的`valueOf`方法，每次返回都是重新`new`一个新的对象，所以上面代码中的结果都不想等。\r\n\r\n  ```\r\n  public static Double valueOf(double d) {\r\n            return new Double(d);\r\n  }\r\n  ```\r\n\r\n- 最后再看这段代码的输出结果\r\n\r\n  ```\r\n  public class Main {\r\n      public static void main(String[] args) {\r\n  \r\n          Boolean a = false;\r\n          Boolean b = false;\r\n          Boolean c = true;\r\n          Boolean d = true;\r\n  \r\n          System.out.println(a==b);\r\n          System.out.println(c==d);\r\n      }\r\n  }\r\n  ```\r\n\r\n  ```\r\n  true\r\n  true\r\n  ```\r\n\r\n  老方法继续看`valueOf`方法\r\n\r\n  ```\r\n  public static Boolean valueOf(boolean b) {\r\n          return (b ? TRUE : FALSE);\r\n      }\r\n  ```\r\n\r\n  再看看`TRUE`和`FALSE`是个什么东西，是两个静态成员属性。\r\n\r\n  ```\r\n  public static final Boolean TRUE = new Boolean(true);\r\n  public static final Boolean FALSE = new Boolean(false);\r\n  ```\r\n\r\n**说下结论 **：`Integer`、`Short`、`Byte`、`Character`、`Long`这几个类的`valueOf`方法的实现是类似的。`Double`、`Float`的`valueOf`方法的实现是类似的。然后是`Boolean`的`valueOf`方法是单独一组的。\r\n\r\n- `Integer i = new Integer(xxx)`和`Integer i =xxx`的区别\r\n\r\n  这两者的区别主要是第一种会触发自动装箱，第二者不会\r\n\r\n  最后看看下面这段程序的输出结果\r\n\r\n  ```\r\n  public class Main {\r\n      public static void main(String[] args) {\r\n          Integer a = 1;\r\n          Integer b = 2;\r\n          Integer c = 3;\r\n          Long g = 3L;\r\n          int int1 = 12;\r\n          int int2 = 12;\r\n          Integer integer1 = new Integer(12);\r\n          Integer integer2 = new Integer(12);\r\n          Integer integer3 = new Integer(1);\r\n  \r\n          System.out.println("c==(a+b) ->"+ (c==(a+b)));\r\n          System.out.println("g==(a+b) ->" + (g==(a+b)));\r\n          System.out.println( "c.equals(a+b) ->" + (c.equals(a+b)));\r\n          System.out.println( "g.equals(a+b) ->" + (g.equals(a+b)));\r\n          System.out.println("int1 == int2 -> " + (int1 == int2));\r\n          System.out.println("int1 == integer1 -> " + (int1 == integer1));\r\n          System.out.println("integer1 == integer2 -> " + (integer1 == integer2));\r\n          System.out.println("integer3 == a1 -> " + (integer3 == a));\r\n      }\r\n  }\r\n  ```\r\n\r\n  ```\r\n  c==(a+b) ->true\r\n  g==(a+b) ->true\r\n  c.equals(a+b) ->true\r\n  g.equals(a+b) ->false\r\n  int1 == int2 -> true\r\n  int1 == integer1 -> true\r\n  integer1 == integer2 -> false\r\n  integer3 == a1 -> false\r\n  ```\r\n\r\n  下面简单解释这些结果。\r\n\r\n  1.当 "=="运算符的两个操作数都是包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。所以`c==a+b`，`g==a+b`为`true`。\r\n\r\n  2.而对于`equals`方法会先触发自动拆箱过程，再触发自动装箱过程。也就是说a+b，会先各自调用`intValue`方法，得到了加法运算后的数值之后，便调用`Integer.valueOf`方法，再进行`equals`比较。所以`c.equals(a+b)`为`true`。而对于`g.equals(a+b)`，`a+b`会先拆箱进行相加运算，在装箱进行`equals`比较，但是装箱后为`Integer`，`g`为`Long`，所以`g.equals(a+b)`为`false`。\r\n\r\n  3.`int1 == int2`为`true`无需解释，`int1 == integer1`，在进行比较时，`integer1`会先进行一个拆箱操作变成`int`型在进行比较，所以`int1 == integer1`为`true`。\r\n\r\n  4.`integer1 == integer2`->`false`。`integer1`和`integer2`都是通过`new`关键字创建的，可以看成两个对象，所以`integer1 == integer2` 为`false`。`integer3 == a1` -> `false` , `integer3`是一个对象类型，而`a1`是一个常量它们存放内存的位置不一样，所以`integer3 == a1`为`false`，具体原因可学习下java的内存模型。\r\n\r\n### String(不是基本数据类型)\r\n\r\n### 7. String的不可变性  ＊＊＊\r\n\r\n在 Java 8 中，`String` 内部使用 `char` 数组存储数据。并且被声明为`final`，因此它不可被继承。\r\n\r\n```\r\npublic final class String implements java.io.Serializable, Comparable<String>, CharSequence { \r\n private final char value[];\r\n}\r\n```\r\n\r\n为什么`Strin`g`要设计成不可变的呢（不可变性的好处）:\r\n\r\n1.可以缓存 `hash` 值（）\r\n\r\n因为 `String` 的`hash`值经常被使用，例如`String` 用做 `HashMap` 的 `key`。不可变的特性可以使得 `hash`值也不可变， 因此只需要进行一次计算。\r\n\r\n2.常量池优化\r\n\r\n`String` 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。\r\n\r\n3.线程安全\r\n\r\n`String` 不可变性天生具备线程安全，可以在多个线程中安全地使用。\r\n\r\n### 8. 字符型常量和字符串常量的区别 ＊\r\n\r\n1. 形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符\r\n2. 含义上: 字符常量相当于一个整形值(ASCII值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)\r\n3. 占内存大小 字符常量占两个字节 字符串常量占若干个字节(至少一个字符结束标志)\r\n\r\n### 9. 什么是字符串常量池？＊\r\n\r\n字符串常量池位于堆内存中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串，在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。\r\n\r\n### 10. String 类的常用方法都有哪些？＊＊\r\n\r\n> 面试时一般不会问，但面试或笔试写字符串相关的算法题经常会涉及到，还是得背一背（以下大致是按使用频率优先级排序）\r\n\r\n- `length()`：返回字符串长度\r\n- `charAt()`：返回指定索引处的字符\r\n- `substring()`：截取字符串\r\n- `trim()`：去除字符串两端空白\r\n- `split()`：分割字符串，返回一个分割后的字符串数组。\r\n- `replace()`：字符串替换。\r\n- `indexOf()`：返回指定字符的索引。\r\n- `toLowerCase()`：将字符串转成小写字母。\r\n- `toUpperCase()`：将字符串转成大写字符。\r\n\r\n### 11. String和StringBuffer、StringBuilder的区别是什么？＊＊＊\r\n\r\n1.可变性\r\n\r\n`String`不可变，`StringBuilder`和`StringBuffer`是可变的\r\n\r\n2.线程安全性\r\n\r\n`String`由于是不可变的，所以线程安全。`StringBuffer`对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。 `StringBuilder`并没有对方法进行加同步锁，所以是非线程安全的。\r\n\r\n3.性能\r\n\r\n```\r\nStringBuilder` > `StringBuffer` > `String\r\n```\r\n\r\n> 为了方便记忆，总结如下\r\n\r\n|               | 是否可变 | 是否安全 | 性能 |\r\n| :-----------: | :------: | :------: | :--: |\r\n|    String     |  不可变  |   安全   |  低  |\r\n| StringBuilder |   可变   |  不安全  |  高  |\r\n| StringBuffer  |   可变   |   安全   | 较高 |\r\n\r\n## 12. switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上 ＊\r\n\r\n`switch`可以作用于`char` `byte` `short` `int`及它们对应的包装类型，`switch`不可作用于`long` `double` `float` `boolean`及他们的包装类型。在 JDK1.5之后可以作用于枚举类型，在JDK1.7之后可作用于`String`类型。\r\n\r\n## 13. Java语言采用何种编码方案？有何特点？＊\r\n\r\nJava语言采用Unicode编码标准，它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。\r\n\r\n## 14. 访问修饰符 ＊＊\r\n\r\n在Java编程语言中有四种权限访问控制符，这四种访问权限的控制符能够控制类中成员的可见性。其中类有两种`public`、`default`。而方法和变量有 4 种：`public`、`default`、`protected`、`private`。\r\n\r\n- **public** : 对所有类可见。使用对象：类、接口、变量、方法\r\n\r\n- **protected** : 对同一包内的类和所有子类可见。使用对象：变量、方法。**注意：不能修饰类（外部类）**。\r\n\r\n- **default** : 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。\r\n\r\n- **private** : 在同一类内可见。使用对象：变量、方法。**注意：不能修饰类（外部类）**\r\n\r\n  |  修饰符   | 当前类 | 同包内 | 子类(同包) | 其他包 |\r\n  | :-------: | :----: | :----: | :--------: | :----: |\r\n  |  public   |   Y    |   Y    |     Y      |   Y    |\r\n  | protected |   Y    |   Y    |     Y      |   N    |\r\n  |  default  |   Y    |   Y    |     Y      |   N    |\r\n  |  private  |   Y    |   N    |     N      |   N    |\r\n\r\n## 15. 运算符　＊\r\n\r\n- **&&和&**\r\n\r\n  `&&`和`&`都可以表示逻辑与，但他们是有区别的，共同点是他们两边的条件都成立的时候最终结果才是`true`；不同点是`&&`只要是第一个条件不成立为`false`，就不会再去判断第二个条件，最终结果直接为`false`，而`&`判断的是所有的条件。\r\n\r\n- **||和|**\r\n\r\n  `||`和`|`都表示逻辑或，共同点是只要两个判断条件其中有一个成立最终的结果就是`true`，区别是`||`只要满足第一个条件，后面的条件就不再判断，而`|`要对所有的条件进行判断。\r\n\r\n### 关键字\r\n\r\n### 16. static关键字　＊＊＊\r\n\r\n`static`关键字的主要用途**就是方便在没有创建对象时调用方法和变量和优化程序性能**\r\n\r\n**1.static变量（静态变量）**\r\n\r\n用`static`修饰的变量被称为静态变量，也被称为类变量，可以直接通过类名来访问它。静态变量被所有的对象共享，在内存中只有一个副本，仅当在类初次加载时会被初始化，而非静态变量在创建对象的时候被初始化，并且存在多个副本，各个对象拥有的副本互不影响。\r\n\r\n**2.static方法(静态方法)**\r\n\r\n`static`方法不依赖于任何对象就可以进行访问，在`static`方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用，但是在非静态成员方法中是可以访问静态成员方法/变量的。\r\n\r\n```\r\npublic class Main {\r\n    public static String s1 = "s1";//静态变量\r\n    String s2  = "s2";\r\n    public void fun1(){\r\n        System.out.println(s1);\r\n        System.out.println(s2);\r\n    }\r\n    \r\n    public static void fun2(){\r\n        System.out.println(s1);\r\n        System.out.println(s2);//此处报错，静态方法不能调用非静态变量\r\n    }\r\n}\r\n```\r\n\r\n**3.static代码块（静态代码块）**\r\n\r\n静态代码块的主要用途是可以用来优化程序的性能，因为它只会在类加载时加载一次，很多时候会将一些只需要进行一次的初始化操作都放在`static`代码块中进行。如果程序中有多个`static`块，在类初次被加载的时候，会按照`static`块的顺序来执行每个`static`块。\r\n\r\n```\r\npublic class Main {\r\n    static {\r\n        System.out.println("hello,word");\r\n    }\r\n    public static void main(String[] args) {\r\n        Main m = new Main();\r\n    }\r\n}\r\n```\r\n\r\n**4.可以通过this访问静态成员变量吗？（可以）**\r\n\r\n`this`代表当前对象，可以访问静态变量，而静态方法中是不能访问非静态变量,也不能使用`this`引用。\r\n\r\n**5.初始化顺序**\r\n\r\n静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。如果存在继承关系的话，初始化顺序为**父类中的静态变量和静态代码块——子类中的静态变量和静态代码块——父类中的实例变量和普通代码块——父类的构造函数——子类的实例变量和普通代码块——子类的构造函数**\r\n\r\n### 17. final 关键字　＊＊＊\r\n\r\n`final`关键字主要用于修饰类，变量，方法。\r\n\r\n1. 类：被`final`修饰的类不可以被继承\r\n2. 方法：被`final`修饰的方法不可以被重写\r\n3. 变量：被`final`修饰的变量是基本类型，变量的数值不能改变；被修饰的变量是引用类型，变量便不能在引用其他对象，但是变量所引用的对象本身是可以改变的。\r\n\r\n```\r\npublic class Main {\r\n    int a = 1;\r\n    public static void main(String[] args) {\r\n        final int b = 1;\r\n        b = 2;//报错\r\n        final Main m = new Main();\r\n        m.a = 2;//不报错,可以改变引用类型变量所指向的对象\r\n    }\r\n} \r\n```\r\n\r\n### 18. final finally finalize区别　＊＊＊\r\n\r\n- `final`主要用于修饰类，变量，方法\r\n- `finally`一般作用在`try-catch`代码块中，在处理异常的时候，通常我们将一定要执行的代码方法`finally`代码块 中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。\r\n- `finalize`是一个属于`Object`类的一个方法，该方法一般由垃圾回收器来调用，当我们调用`System.gc()`方法的时候，由垃圾回收器调用`finalize()`，回收垃圾，但Java语言规范并不保证`inalize`方法会被及时地执行、而且根本不会保证它们会被执行。\r\n\r\n### 19. this关键字　＊＊\r\n\r\n> 重点掌握前三种即可\r\n\r\n1.`this`关键字可用来引用当前类的实例变量。主要用于形参与成员名字重名，用`this`来区分。\r\n\r\n```\r\npublic Person(String name, int age) {\r\n    this.name = name;\r\n    this.age = age;\r\n}\r\n```\r\n\r\n2.`this`关键字可用于调用当前类方法。\r\n\r\n```\r\npublic class Main {\r\n    public void fun1(){\r\n        System.out.println("hello,word");\r\n    }\r\n    public void fun2(){\r\n        this.fun1();//this可省略\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Main m = new Main();\r\n        m.fun2();\r\n    }\r\n}\r\n```\r\n\r\n3.`this()`可以用来调用当前类的构造函数。(注意：`this()`一定要放在构造函数的第一行，否则编译不通过)\r\n\r\n```\r\nclass Person{\r\n    private String name;\r\n    private int age;\r\n    \r\n    public Person() {\r\n    }\r\n \r\n    public Person(String name) {\r\n        this.name = name;\r\n    }\r\n    public Person(String name, int age) {\r\n        this(name);\r\n        this.age = age;\r\n    }\r\n}\r\n```\r\n\r\n4.`this`关键字可作为调用方法中的参数传递。\r\n\r\n5.`this`关键字可作为参数在构造函数调用中传递。\r\n\r\n6.`this`关键字可用于从方法返回当前类的实例。super\r\n\r\n### 20. super关键字 ＊＊\r\n\r\n1.`super`可以用来引用直接父类的实例变量。和`this`类似，主要用于区分父类和子类中相同的字段\r\n\r\n2.`super`可以用来调用直接父类构造函数。(注意：`super()`一定要放在构造函数的第一行，否则编译不通过)\r\n\r\n3.`super`可以用来调用直接父类方法。\r\n\r\n```\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        Child child = new Child("Father","Child");\r\n        child.test();\r\n    }\r\n}\r\n\r\nclass Father{\r\n    protected String name;\r\n\r\n    public Father(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public void Say(){\r\n        System.out.println("hello,child");\r\n    }\r\n\r\n}\r\n\r\nclass Child extends Father{\r\n    private String name;\r\n\r\n    public Child(String name1, String name2) {\r\n        super(name1);      //调用直接父类构造函数\r\n        this.name = name2;\r\n    }\r\n\r\n    public void test(){\r\n        System.out.println(this.name);\r\n        System.out.println(super.name);  //引用直接父类的实例变量\r\n        super.Say();      //调用直接父类方法\r\n    }\r\n}\r\n```\r\n\r\n### 21. this与super的区别　＊＊\r\n\r\n- 相同点：\r\n\r\n- 1. `super()`和`this()`都必须在构造函数的第一行进行调用，否则就是错误的\r\n  2. `this()`和`super()`都指的是对象，所以，均不可以在`static`环境中使用。\r\n\r\n- 不同点：\r\n\r\n- 1. `super()`主要是对父类构造函数的调用，`this()`是对重载构造函数的调用\r\n  2. `super()`主要是在继承了父类的子类的构造函数中使用，是在不同类中的使用；`this()`主要是在同一类的不同构造函数中的使用\r\n\r\n### 22. break ,continue ,return 的区别及作用　＊＊\r\n\r\n- `break`结束当前的循环体\r\n- `continue`结束本次循环,进入下一次循环\r\n- `return`结束当前方法\r\n\r\n## 23. 面向对象和面向过程的区别　＊＊\r\n\r\n- 面向过程\r\n\r\n  优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源。\r\n\r\n  缺点：没有面向对象易维护、易复用、易扩展\r\n\r\n- 面向对象\r\n\r\n  优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护\r\n\r\n  缺点：性能比面向过程低\r\n\r\n## 24. 面向对象三大特性(封装、继承、多态)　＊＊＊\r\n\r\n- 封装\r\n\r\n  **封装就是隐藏对象的属性和实现细节，仅对外公开接口**，控制在程序中属性的读和修改的访问级别。\r\n\r\n- 继承\r\n\r\n  **继承就是子类继承父类的特征和行为**，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。\r\n\r\n- 多态（重要）\r\n\r\n  多态是同一个行为具有多个不同表现形式或形态的能力。这句话不是很好理解，可以看这个解释，在Java语言中，多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。\r\n\r\n  在Java中实现多态的三个必要条件：继承、重写、向上转型。继承和重写很好理解，向上转型是指在多态中需要将子类的引用赋给父类对象。\r\n\r\n  ```\r\n  public class Main {\r\n      public static void main(String[] args) {\r\n            Person person = new Student(); //向上转型\r\n            person.run();\r\n      }\r\n  }\r\n  \r\n  class Person {\r\n      public void run() {\r\n          System.out.println("Person");\r\n      }\r\n  }\r\n  \r\n  class Student extends Person {   //继承\r\n      @Override \r\n      public void run() {         //重载\r\n          System.out.println("Student");\r\n      }\r\n  }\r\n  ```\r\n\r\n  运行结果为\r\n\r\n  ```\r\n  Student\r\n  ```\r\n\r\n## 25. 面向对象五大基本原则是什么　＊＊\r\n\r\n- **单一职责原则（Single-Resposibility Principle）**\r\n\r\n  **一个类，最好只做一件事，只有一个引起它的变化。**单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。\r\n\r\n- **开放封闭原则（Open-Closed principle）**\r\n\r\n  **软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。**\r\n\r\n- **里氏替换原则** **（Liskov-Substituion Principle）**\r\n\r\n  **子类必须能够替换其基类。**这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。\r\n\r\n- **依赖倒置原则（Dependecy-Inversion Principle）**\r\n\r\n  **依赖于抽象。**具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。\r\n\r\n- **接口隔离原则（Interface-Segregation Principle）**\r\n\r\n  **使用多个小的专门的接口，而不要使用一个大的总接口。**\r\n\r\n## 26. 抽象类和接口的对比　＊＊＊\r\n\r\n在Java语言中，`abstract class`和`interface`是支持抽象类定义的两种机制。抽象类：用来捕捉子类的通用特性的。接口：抽象方法的集合。\r\n\r\n**相同点：**\r\n\r\n- 接口和抽象类都不能实例化\r\n- 都包含抽象方法，其子类都必须覆写这些抽象方法\r\n\r\n**不同点：**\r\n\r\n|    类型    |                            抽象类                            |                          接口                          |\r\n| :--------: | :----------------------------------------------------------: | :----------------------------------------------------: |\r\n|    定义    |                        abstract class                        |                       Interface                        |\r\n|    实现    |        extends(需要提供抽象类中所有声明的方法的实现)         |    implements（需要提供接口中所有声明的方法的实现）    |\r\n|    继承    | 抽象类可以继承一个类和实现多个接口；子类只可以继承一个抽象类 | 接口只可以继承接口（一个或多个）；子类可以实现多个接口 |\r\n| 访问修饰符 |      抽象方法可以有public、protected和default这些修饰符      |   接口方法默认修饰符是public。你不可以使用其它修饰符   |\r\n|   构造器   |                      抽象类可以有构造器                      |                    接口不能有构造器                    |\r\n|  字段声明  |                 抽象类的字段声明可以是任意的                 |         接口的字段默认都是 static 和 final 的          |\r\n\r\n## 27. 在Java中定义一个不做事且没有参数的构造方法的作用　＊\r\n\r\nJava程序存在继承，在执行子类的构造方法时，如果没有用`super()`来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。如果父类只定义了有参数的构造函数，而子类的构造函数没有用`super`调用父类那个特定的构造函数，就会出错。\r\n\r\n## 28. 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是 ＊\r\n\r\n帮助子类做初始化工作。\r\n\r\n## 29. 一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？ ＊\r\n\r\n主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。\r\n\r\n## 30. 构造方法有哪些特性？　＊＊\r\n\r\n- 方法名称和类同名\r\n- 不用定义返回值类型\r\n- 不可以写`retrun`语句\r\n- 构造方法可以被重载\r\n\r\n## 31. 变量　＊＊\r\n\r\n- 类变量：独立于方法之外的变量，用`static`修饰。\r\n\r\n- 实例变量：独立于方法之外的变量，不过没有 `static` 修饰。\r\n\r\n- 局部变量：类的方法中的变量。\r\n\r\n- 成员变量：成员变量又称全局变量，可分为类变量和实例变量，有`static`修饰为类变量，没有`static`修饰为实例变量。\r\n\r\n  |          |       类变量       |       实例变量       |         局部变量         |\r\n  | :------: | :----------------: | :------------------: | :----------------------: |\r\n  | 定义位置 |    类中，方法外    |     类中，方法外     |          方法中          |\r\n  |  初始值  |    有默认初始值    |     有默认初始值     |       无默认初始值       |\r\n  | 存储位置 |       方法区       |          堆          |            栈            |\r\n  | 生命周期 | 类何时被加载和卸载 | 实例何时被创建及销毁 | 方法何时被调用及结束调用 |\r\n\r\n## 32. 内部类　＊＊\r\n\r\n内部类包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类\r\n\r\n- 成员内部类\r\n\r\n  1.成员内部类定义为位于另一个类的内部，成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括`private`成员和静态成员）。\r\n\r\n  ```\r\n  class Outer{\r\n      private double a = 0;\r\n      public static int b =1;\r\n      public Outer(double a) {\r\n          this.a = a;\r\n      }\r\n  \r\n      class Inner {     //内部类\r\n          public void fun() {\r\n              System.out.println(a);\r\n              System.out.println(b);\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n  2.当成员内部类拥有和外部类同名的成员变量或者方法时，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：外部类.`this`.成员变量\r\n\r\n  3.在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问。\r\n\r\n  4.成员内部类是依附外部类而存在的，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：\r\n\r\n  ```\r\n  class Outter{\r\n      private double a = 0;\r\n      public static int b =1;\r\n      public Outter(){}\r\n      public Outter(double a) {\r\n          this.a = a;\r\n          Inner inner = new Inner();\r\n          inner.fun();     //调用内部类的方法\r\n      }\r\n  \r\n  \r\n      class Inner {     //内部类\r\n          int b = 2;\r\n          public void fun() {\r\n              System.out.println(a);\r\n              System.out.println(b);            //访问内部类的b\r\n              System.out.println(Outter.this.b);//访问外部类的b\r\n          }\r\n      }\r\n  }\r\n  public class Main{\r\n      public static void main(String[] args) {\r\n          Outter outter = new Outter();\r\n          Outter.Inner inner = outter.new Inner(); //创建内部类的对象\r\n      }\r\n  }\r\n  ```\r\n\r\n- 局部内部类\r\n\r\n  局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。\r\n\r\n  ```\r\n  class Outter {\r\n  \r\n      private int outter_a = 1;\r\n      private static int static_b = 2;\r\n  \r\n      public void test1(){\r\n          int inner_c =3;\r\n          class Inner {\r\n              private void fun(){\r\n                  System.out.println(outter_a);\r\n                  System.out.println(static_b);\r\n                  System.out.println(inner_c);\r\n              }\r\n          }\r\n          Inner  inner = new Inner(); //创建局部内部类\r\n          inner.fun();\r\n      }\r\n      public static void test2(){\r\n          int inner_d =3;\r\n          class Inner {\r\n              private void fun(){\r\n                   System.out.println(outter_a); //编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量\r\n                  System.out.println(static_b);\r\n                  System.out.println(inner_d);\r\n              }\r\n          }\r\n          Inner  inner = new Inner();\r\n          inner.fun();\r\n      }\r\n  }\r\n  ```\r\n\r\n- 匿名内部类\r\n\r\n  匿名内部类只没有名字的内部类，在日常开发中使用较多。使用匿名内部类的前提条件：必须继承一个父类或实现一个接口。\r\n\r\n  ```\r\n  interface Person {\r\n      public void fun();\r\n  }\r\n  class Demo {\r\n      public static void main(String[] args) {\r\n           new Person() {\r\n              public void fun() {\r\n                  System.out.println("hello,word");\r\n              }\r\n          }.fun();\r\n      }\r\n  }\r\n  ```\r\n\r\n- 静态内部类\r\n\r\n  静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字`static`。静态内部类是不需要依赖于外部类的，并且它不能使用外部类的非`static`成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非`static`成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。\r\n\r\n  ```\r\n  class Outter {\r\n      int a = 1;\r\n      static int b = 2;\r\n      public Outter() {\r\n  \r\n      }\r\n  \r\n      static class Inner {\r\n          public Inner() {\r\n              System.out.println(a);//报错，静态内部类不能访问非静态变量\r\n              System.out.println(b);\r\n          }\r\n      }\r\n  \r\n  }\r\n  public class Main{\r\n      public static void main(String[] args) {\r\n          Outter.Inner inner = new Outter.Inner();\r\n      }\r\n  }\r\n  ```\r\n\r\n- 内部类的优点：\r\n\r\n- 1. 内部类不为同一包的其他类所见，具有很好的封装性；\r\n  2. 匿名内部类可以很方便的定义回调。\r\n  3. 每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。\r\n  4. 内部类有效实现了“多重继承”，优化 java 单继承的缺陷。\r\n\r\n- 局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上`final`？\r\n\r\n  ```\r\n  public class Main {\r\n      public static void main(String[] args)  {\r\n           \r\n      }\r\n       \r\n      public void fun(final int b) {\r\n          final int a = 10;\r\n          new Thread(){\r\n              public void run() {\r\n                  System.out.println(a);\r\n                  System.out.println(b);\r\n              };\r\n          }.start();\r\n      }\r\n  }\r\n  ```\r\n\r\n  对于变量`a`可以从生命周期的角度理解，局部变量直接存储在栈中，当方法执行结束后，非`final`的局部变量就被销毁，而局部内部类对局部变量的引用依然存在，如果局部内部类要调用没有`final`修饰的局部变量时，就会造成生命周期不一致出错。\r\n\r\n  对于变量`b`，其实是将`fun`方法中的变量`b`以参数的形式对匿名内部类中的拷贝（变量`b`的拷贝）进行赋值初始化。在`run`方法中访问的变量`b`根本就不是`test`方法中的局部变量`b`，而是一个拷贝值，所以不存在生命周期不一致的问题，但如果在`run`方法中修改变量`b`的值会导致数据不一致，所以需要加`final`修饰。\r\n\r\n## 重写与重载　＊＊＊\r\n\r\n### 33. 重载和重写的区别\r\n\r\n- 重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分。\r\n- 重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为`private`则子类中就不是重写。\r\n\r\n### 34. 构造器（constructor）是否可被重写（override）\r\n\r\n构造器可以被重载，不能被重写\r\n\r\n### 35. 重载的方法能否根据返回类型进行区分？为什么？\r\n\r\n不能，因为调用时不能指定类型信息，编译器不知道你要调用哪个函数。\r\n\r\n## 36. == 和 equals 的区别　＊＊＊\r\n\r\n- ==\r\n\r\n  对于基本数据类型，`==`比较的是值；对于引用数据类型，`==`比较的是内存地址。\r\n\r\n- eauals\r\n\r\n  对于没有重写`equals`方法的类，`equals`方法和`==`作用类似；对于重写过`equals`方法的类，`equals`比较的是值。\r\n\r\n## 37. hashCode 与 equals（为什么重写equals方法后，hashCode方法也必须重写）　＊＊＊\r\n\r\n- equals\r\n\r\n  先看下`String`类中重写的`equals`方法。\r\n\r\n  ```\r\n      public boolean equals(Object anObject) {\r\n          if (this == anObject) {\r\n              return true;\r\n          }\r\n          if (anObject instanceof String) {\r\n              String anotherString = (String)anObject;\r\n              int n = value.length;\r\n              if (n == anotherString.value.length) {\r\n                  char v1[] = value;\r\n                  char v2[] = anotherString.value;\r\n                  int i = 0;\r\n                  while (n-- != 0) {\r\n                      if (v1[i] != v2[i])\r\n                          return false;\r\n                      i++;\r\n                  }\r\n                  return true;\r\n              }\r\n          }\r\n          return false;\r\n      }\r\n  ```\r\n\r\n  从源码中可以看到：\r\n\r\n- 1. `equals`方法首先比较的是内存地址，如果内存地址相同，直接返回`true`；如果内存地址不同，再比较对象的类型，类型不同直接返回`false`；类型相同，再比较值是否相同；值相同返回`true`，值不同返回`false`。总结一下，`equals`会比较**内存地址、对象类型、以及值**，内存地址相同，`equals`一定返回`true`；对象类型和值相同，`equals`方法一定返回`true`。\r\n  2. 如果没有重写`equals`方法，那么`equals`和`==`的作用相同，比较的是对象的地址值。\r\n\r\n- `hashCode`\r\n\r\n  `hashCode`方法返回对象的散列码，返回值是`int`类型的散列码。散列码的作用是确定该对象在哈希表中的索引位置。\r\n\r\n  关于`hashCode`有一些约定：\r\n\r\n- 1. 两个对象相等，则`hashCode`一定相同。\r\n  2. 两个对象有相同的`hashCode`值，它们不一定相等。\r\n  3. `hashCode()`方法默认是对堆上的对象产生独特值，如果没有重写`hashCode()`方法，则该类的两个对象的`hashCode`值肯定不同\r\n\r\n- 为什么重写`equals`方法后，`hashCode`方法也必须重写\r\n\r\n- 1. 根据规定，两个对象相等，`hashCode`值也许相同，所以重写`equals`方法后，`hashCode`方法也必须重写（面试官肯定不是想听这个答案）\r\n  2. `hashCode`在具有哈希机制的集合中起着非常关键的作用，比如`HashMap`、`HashSet`等。以`HashSet`为例，`HashSet`的特点是存储元素时无序且唯一，在向`HashSet`中添加对象时，首先会计算对象的`HashCode`值来确定对象的存储位置，如果该位置没有其他对象，直接将该对象添加到该位置；如果该存储位置有存储其他对象（新添加的对象和该存储位置的对象的`HashCode`值相同），调用`equals`方法判断两个对象是否相同，如果相同，则添加对象失败，如果不相同，则会将该对象重新散列到其他位置。所以重写`equals`方法后，`hashCode`方法不重写的话，会导致所有对象的`HashCode`值都不相同，都能添加成功，那么`HashSet`中会出现很多重复元素，`HashMap`也是同理（因为`HashSet`的底层就是通过`HashMap`实现的），会出现大量相同的`Key`（`HashMap`中的`key`是唯一的，但不同的`key`可以对应相同的`value`）。所以重写`equals`方法后，`hashCode`方法也必须重写。同时因为两个对象的`hashCode`值不同，则它们一定不相等，所以先计算对象的`hashCode`值可以在一定程度上判断两个对象是否相等，提高了集合的效率。总结一下，一共两点：**第一，在`HashSet`等集合中，不重写`hashCode`方法会导致其功能出现问题；第二，可以提高集合效率。**\r\n\r\n## 38. Java 中是值传递还是引用传递，还是两者共存　＊＊\r\n\r\n> 这是一个很容易搞混又很难解释清楚的问题，先说结论，Java中只有值传递\r\n\r\n先看这样一段代码\r\n\r\n```\r\npublic class Main{\r\n    public static void main(String[] args) {\r\n        int a = 1;\r\n        printValue(a);\r\n        System.out.println("a:" + a);\r\n    }\r\n    public static void printValue(int b){\r\n        b = 2;\r\n        System.out.println("b:"+ b);\r\n    }\r\n}\r\n```\r\n\r\n输出\r\n\r\n```\r\nb:2\r\na:1\r\n```\r\n\r\n可以看到将`a`的值传到`printValue`方法中，并将其值改为2。但方法调用结束后，`a`的值还是1，并未发生改变，所以这种情况下为值传递。\r\n\r\n再看这段代码\r\n\r\n```\r\npublic class Main{\r\n    public static void main(String[] args) {\r\n        Preson p = new Preson();\r\n        p.name = "zhangsan";\r\n        printValue(p);\r\n        System.out.println("p.name: " + p.name);\r\n    }\r\n    public static void printValue(Preson q){\r\n        q.name = "lisi";\r\n        System.out.println("q.name: "+ q.name);\r\n    }\r\n}\r\nclass Preson{\r\n    public String name;\r\n}\r\n```\r\n\r\n输出结果\r\n\r\n```\r\nq.name: lisi\r\np.name: lisi\r\n```\r\n\r\n在将`p`传入`printValue`方法后，方法调用结束，`p`的`name`属性竟然被改变了！所以得出结论，参数为基本类型为值传递，参数为引用类型为时为引用传递。这个结论是错误的，下面来看看判断是值传递还是值传递的关键是什么，先看定义\r\n\r\n- 值传递：是指在调用函数时将实际参数**复制一份**传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。\r\n- 引用传递：是指在调用函数时将实际参数的**地址**直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。\r\n\r\n从定义中可以明显看出，区分是值传递还是引用传递主要是看**向方法中传递的是实际参数的副本还是实际参数的地址**。上面第一个例子很明显是值传递，其实第二个例子中向`printValue`方法中传递的是一个引用的副本，只是这个**副本引用和原始的引用指向的同一个对象**，所以副本引用修改过对象属性后，通过原始引用查看对象属性肯定也是被修改过的。换句话说，`printValue`方法中修改的是副本引用指向的对象的属性，不是引用本身，如果修改的是引用本身，那么原始引用肯定不受影响。看下面这个例子\r\n\r\n```\r\npublic class Main{\r\n    public static void main(String[] args) {\r\n        Preson p = new Preson();\r\n        p.name = "zhangsan";\r\n        printValue(p);\r\n        System.out.println("p.name: " + p.name);\r\n    }\r\n    public static void printValue(Preson q){\r\n        q = new Preson();\r\n        q.name = "lisi";\r\n        System.out.println("q.name: "+ q.name);\r\n    }\r\n}\r\nclass Preson{\r\n    public String name;\r\n}\r\n```\r\n\r\n输出结果\r\n\r\n```\r\nq.name: lisi\r\np.name: zhangsan\r\n```\r\n\r\n可以看到将`p`传入`printValue`方法后，`printValue`方法调用结束后，`p`的属性`name`没有改变，这是因为**在`printValue`方法中并没有改变副本引用`q`所指向的对象，而是改变了副本引用`q`本身，将副本引用`q`指向了另一个对象并对这个对象的属性进行修改**，所以原始引用`p`所指向的对象不受影响。所以证明Java中只存在值传递。\r\n\r\n## 39. IO流　＊\r\n\r\nJava IO流主要可以分为输入流和输出流。按照照操作单元划分，可以划分为字节流和字符流。按照流的角色划分为节点流和处理流。\r\n\r\nJava I0流的40多个类都是从4个抽象类基类中派生出来的。\r\n\r\n- InputStream：字节输入流\r\n- Reader：字符输入流\r\n- OutputStream：字节输出流\r\n- Writer：字符输出流\r\n\r\n## 40. BIO,NIO,AIO 有什么区别?　＊＊\r\n\r\n- **BIO (Blocking I/O)：**服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制来改善。BIO方式适用于连接数目比较小且固定的架构，这种方式对服务端资源要求比较高，并发局限于应用中，在jdk1.4以前是唯一的io\r\n\r\n- **NIO (New I/O)：**服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有IO请求时才启动一个线程进行处理。NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，jdk1,4开始支持\r\n\r\n- **AIO (Asynchronous I/O)：**服务器实现模式为一个有效请求一个线程，客户端的IO请求都是由操作系统先完成了再通知服务器用其启动线程进行处理。AIO方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，jdk1.7开始支持。\r\n\r\n  这些概念看着比较枯燥，可以从这个经典的烧开水的例子去理解\r\n\r\n  **BIO ：**来到厨房，开始烧水，并坐在水壶面前一直等着水烧开。\r\n\r\n  **NIO**：来到厨房，开始烧水，但是我们不一直坐在水壶前面等，而是做些其他事，然后每隔几分钟到厨房看一下水有没有烧开。\r\n\r\n  **AIO**：来到厨房，开始烧水，我们不一直坐在水壶前面等，而是在水壶上面装个开关，水烧开之后它会通知我。\r\n\r\n## 41. 反射　＊＊＊\r\n\r\nJAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。\r\n\r\nJava获取Class对象的三种方式\r\n\r\n```\r\nclass Person {\r\n    public String name = "zhangsan";\r\n    public Person() {\r\n    }\r\n}\r\npublic class Main{\r\n    public static void main(String[] args) throws ClassNotFoundException {\r\n //方式1\r\n     Person p1 = new Person();\r\n     Class c1 = p1.getClass();\r\n     //方式2\r\n    Class c2 = Person.class;\r\n    //方式3可能会抛出ClassNotFoundException异常\r\n    Class c3 = Class.forName("com.company");\r\n    }\r\n}\r\n```\r\n\r\n因为在一个类在 JVM 中只会有一个 `Class` 实例，所以对`c1`、`c2`、`c3`进行`equals`比较时返回的都是`true`。\r\n\r\n**反射优缺点：**\r\n\r\n- 优点：运行期类型的判断，动态加载类，提高代码灵活度。\r\n- 缺点：性能比直接的java代码要慢很多。\r\n\r\n**反射应用场景：**\r\n\r\n1. Java的很多框架都用到了反射，例如`Spring`中的xml的配置模式等\r\n2. 动态代理设计模式也采用了反射机制\r\n\r\n## 42. JAVA异常　＊＊＊\r\n\r\n异常主要分为`Error`和`Exception`两种\r\n\r\n- Error：`Error`类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理。\r\n- EXception：`Exception`以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。\r\n\r\n异常框图\r\n\r\n![image](\\JAVA核心知识点最详细版.assets\\66.png)\r\n\r\n除了以上的分类，异常还能分为非检查异常和检查异常\r\n\r\n- **非检查异常**（unckecked exception）：**该类异常包括运行时异常（RuntimeException及其子类）和错误（Error）。**编译器不会进行检查并且不要求必须处理的异常，也就说当程序中出现此类异常时，即使我们没有`try-catch`捕获它，也没有使用`throws`抛出该异常，编译也会正常通过。因为这样的异常发生的原因很可能是代码写的有问题。\r\n- **检查异常**（checked exception）：**除了`Error`和 `RuntimeException`的其它异常。**这是编译器要求必须处理的异常。这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，所以必须处理这些异常。\r\n\r\n> 下面来看下`try{}catch(){}finally{}`和`return`之间的“恩恩怨怨”，这里有些乱，面试时问的也不是很多，实在记不住就算啦。还是先看代码猜结果。\r\n\r\n```\r\npublic class Main{\r\n    public static void main(String[] args) {\r\n        int a = test1();\r\n        System.out.println(a);\r\n        int b = test2();\r\n        System.out.println(b);\r\n        int c = test3();\r\n        System.out.println(c);\r\n        int d = test4();\r\n        System.out.println(d);\r\n        int e = test5();\r\n        System.out.println(e);\r\n    }\r\n    public static int test1(){\r\n        int a = 1;\r\n        try{\r\n            a = 2;\r\n            return a;\r\n        }catch(Exception e){\r\n            System.out.println("hello,test1");\r\n            a = 3;\r\n        }finally{\r\n            a = 4;\r\n        }\r\n        return a;\r\n    }\r\n    //输出 2\r\n    \r\n    \r\n    public static int test2(){\r\n        int a = 1;\r\n        try{\r\n            a = 2;\r\n            return a;\r\n        }catch(Exception e){\r\n            System.out.println("hello,test2");\r\n            a = 3;\r\n            return a;\r\n        }finally{\r\n            a = 4;\r\n        }\r\n    }\r\n    //输出 2\r\n    \r\n    \r\n    public static int test3(){\r\n        int a = 1;\r\n        try{\r\n            a = 2/0;\r\n            return a;\r\n        }catch(Exception e){\r\n            System.out.println("hello,test3");\r\n            a = 3;\r\n        }finally{\r\n            a = 4;\r\n        }\r\n        return a;\r\n    }\r\n    //输出 hello,test3 \r\n    // 4\r\n    \r\n    \r\n    public static int test4(){\r\n        int a = 1;\r\n        try{\r\n            a = 2/0;\r\n            return a;\r\n        }catch(Exception e){\r\n            System.out.println("hello,test4");\r\n            a = 3;\r\n            return a;\r\n        }finally{\r\n            a = 4;\r\n        }\r\n    }\r\n    //输出 hello,test4\r\n    // 3\r\n    \r\n    public static int test5(){\r\n        int a = 1;\r\n        try{\r\n            a = 2/0;\r\n            return a;\r\n        }catch(Exception e){\r\n            a = 3;\r\n            return a;\r\n        }finally{\r\n            a = 4;\r\n            return a;\r\n        }\r\n    }\r\n    \r\n    //输出 4\r\n}\r\n```\r\n\r\n如果没有仔细的研究过，应该好多会猜错，下面总结下规律。\r\n\r\n1. 从前三个例子可以看出如果`try{}`中的代码没有异常，`catch(){}`代码块中的代码不会执行。所以如果`try{}`和`catch(){}`都含有`return`时，无异常执行`try{}`中的`return`，存在异常执行`catch(){}`的`return`。\r\n2. 不管任何情况，就算`try{}`或`catch(){}`中含有`return`，`finally{}`中的代码一定会执行，那么为什么`test1`、`test2`、`test3`中的结果不是4呢，因为虽然`finally`是在`return`后面的表达式运算之后执行的，但此时并没有返回运算之后的值，而是把值保存起来，不管`finally`对该值做任何的改变，返回的值都不会改变，依然返回保存起来的值。也就是说方法的返回值是在`finally`运算之前就确定了的。\r\n3. 如果`return`的数据是引用数据类型，而在`finally`中对该引用数据类型的属性值的改变起作用，`try`中的`return`语句返回的就是在`finally`中改变后的该属性的值。这个不理解可以看看上面提到的Java的值传递的问题。\r\n4. 如果`finally{}`中含有`return`，会导致程序提前退出，不在执行`try{}`或`catch(){}`中的`return`。所以`test5`返回的值是4。\r\n\r\n最后总计一下`try{}catch(){}finally{}`的执行顺序。\r\n\r\n1. 先执行`try`中的语句，包括`return`后面的表达式；\r\n2. 有异常时,执行`catch`中的语句，包括`return`后面的表达式，无异常跳过`catch`语句；\r\n3. 然后执行`finally`中的语句，如果`finally`里面有`return`语句，执行`return`语句，程序结束；\r\n4. `finally{}`中没有`return`时，无异常执行`try`中的`return`，如果有异常时则执行`catch`中的`return`。前两步执行的`return`只是确定返回的值，程序并未结束，`finally{}`执行之后，最后将前两步确定的`return`的返回值返回。\r\n\r\n## 43. JAVA注解　＊＊\r\n\r\n> 面试问的不多，但是在使用框架开发时会经常使用，但东西太多了，这里只是简单介绍下概念。\r\n\r\n`Annotation`注解可以看成是java中的一种标记记号，用来给java中的类，成员，方法，参数等任何程序元素添加一些额外的说明信息，同时不改变程序语义。注解可以分为三类：基本注解，元注解，自定义注解\r\n\r\n- 标准注解\r\n\r\n- 1. @Deprecated：该注解用来说明程序中的某个元素（类，方法，成员变量等）已经不再使用，如果使用的话的编译器会给出警告。\r\n  2. @SuppressWarnings(value=“”)：用来抑制各种可能出现的警告。\r\n  3. @Override：用来说明子类方法覆盖了父类的方法，保护覆盖方法的正确使用\r\n\r\n- 元注解（元注解也称为元数据注解，是对注解进行标注的注解，元注解更像是一种对注解的规范说明，用来对定义的注解进行行为的限定。例如说明注解的生存周期，注解的作用范围等）\r\n\r\n- 1. @Target(value=“ ”)：该注解是用来限制注解的使用范围的，即该注解可以用于哪些程序元素。\r\n  2. @Retention(value=“ ”)：用于说明注解的生存周期\r\n  3. @Documnent：用来说明指定被修饰的注解可以被javadoc.exe工具提取进入文档中，所有使用了该注解进行标注的类在生成API文档时都在包含该注解的说明。\r\n  4. @Inherited：用来说明使用了该注解的父类，其子类会自动继承该注解。\r\n  5. @Repeatable：java1.8新出的元注解，如果需要在给程序元素使用相同类型的注解，则需将该注解标注上。\r\n\r\n- 自定义注解：用@Interface来声明注解。\r\n\r\n## 44. JAVA泛型　＊＊＊\r\n\r\nJava 泛型是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。\r\n\r\n- 泛型擦除（这是面试考察泛型时经常问到的问题）\r\n\r\n  Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。看下面代码\r\n\r\n  ```\r\n  public class Main{\r\n      public static void main(String[] args) {\r\n          ArrayList<Integer> arrayList1 = new ArrayList<>();\r\n          ArrayList<String> arrayList2 = new ArrayList<>();\r\n  \r\n          System.out.println(arrayList1.getClass() == arrayList2.getClass());\r\n      }\r\n  }\r\n  ```\r\n\r\n  输出结果\r\n\r\n  ```\r\n  true\r\n  ```\r\n\r\n  可以看到`ArrayList<Integer>`和`ArrayList<String>`的原始类型是相同，在编译成字节码文件后都会变成`List`，JVM看到的只有`List`，看不到泛型信息，这就是泛型的类型擦除。再看下面这段代码\r\n\r\n  ```\r\n  public class Main{\r\n      public static void main(String[] args) throws Exception {\r\n          ArrayList<Integer> arrayList = new ArrayList<>();\r\n          arrayList.add(1);\r\n          arrayList.getClass().getMethod("add", Object.class).invoke(arrayList, "a");\r\n          System.out.println(arrayList.get(0));\r\n          System.out.println(arrayList.get(1));\r\n      }\r\n  }\r\n  ```\r\n\r\n  输出\r\n\r\n  ```\r\n  1\r\n  a\r\n  ```\r\n\r\n  可以看到通过反射进行`add`操作，`ArrayList<Integer>`竟然可以存储字符串，这是因为在反射就是在运行期调用的`add`方法，在运行期泛型信息已经被擦除。\r\n\r\n- 既然存在类型擦除，那么Java是如何保证在`ArrayList<Integer>`添加字符串会报错呢？\r\n\r\n  Java编译器是通过先检查代码中泛型的类型，然后在进行类型擦除，再进行编译。\r\n\r\n## 45. JAVA序列化　＊＊\r\n\r\n- 序列化：将对象写入到IO流中\r\n\r\n- 反序列化：从IO流中恢复对象\r\n\r\n- 序列化的意义：将Java对象转换成字节序列，这些字节序列更加便于通过网络传输或存储在磁盘上，在需要时可以通过反序列化恢复成原来的对象。\r\n\r\n- 实现方式：\r\n\r\n- 1. 实现**Serializable**接口\r\n  2. 实现**Externalizable**接口\r\n\r\n- 序列化的注意事项：\r\n\r\n- 1. 对象的类名、实例变量会被序列化；方法、类变量、`transient`实例变量都不会被序列化。\r\n  2. 某个变量不被序列化，可以使用`transient`修饰。\r\n  3. 序列化对象的引用类型成员变量，也必须是可序列化的，否则，会报错。\r\n  4. 反序列化时必须有序列化对象的`class`文件。\r\n\r\n## 46. 深拷贝与浅拷贝　＊＊＊\r\n\r\n- 深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，两个引用指向两个对象，但对象内容相同。\r\n\r\n- 浅拷贝：对基本数据类型进行值传递，对引用数据类型复制一个引用指向原始引用的对象，就是复制的引用和原始引用指向同一个对象。\r\n\r\n  具体区别看下图\r\n\r\n  ![image](\\JAVA核心知识点最详细版.assets\\67.png)\r\n\r\n- 深拷贝的实现方式\r\n\r\n- 1. 重载`clone`方法\r\n\r\n     ```\r\n      public class Main{\r\n         public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException, CloneNotSupportedException {\r\n             Address s = new Address("天津");\r\n             Person p = new Person("张三", 23, s);\r\n             System.out.println("克隆前的地址：" + p.getAddress().getName());\r\n             Person cloneP = (Person) p.clone();\r\n             cloneP.getAddress().setName("北京");\r\n             System.out.println("克隆后的地址：" + cloneP.getAddress().getName());\r\n         }\r\n     }\r\n     \r\n     class Address implements Cloneable {\r\n         private String city;\r\n         public Address(String name){\r\n             this.city = name;\r\n     }\r\n         @Override\r\n         protected Object clone() throws CloneNotSupportedException {\r\n                 return super.clone();\r\n         }\r\n         public String getName() {\r\n             return city;\r\n     \r\n         }\r\n         public void setName(String name) {\r\n             this.city = name;\r\n     \r\n         }\r\n     }\r\n     class Person implements Cloneable{\r\n         private String name;\r\n         private int age;\r\n         private Address address;\r\n         public Person(String name, int age, Address address){\r\n             this.name = name;\r\n             this.age = age;\r\n             this.address = address;\r\n     \r\n         }\r\n         @Override\r\n         public Object clone() throws CloneNotSupportedException {\r\n               Person  person = (Person) super.clone();\r\n               person.address = (Address)address.clone();\r\n             return person;\r\n         }\r\n         public String getName() {\r\n             return name;\r\n         }\r\n         public void setName(String name) {\r\n             this.name = name;\r\n         }\r\n         public int getAge() {\r\n             return age;\r\n         }\r\n         public void setAge(int age) {\r\n             this.age = age;\r\n         }\r\n         public Address getAddress() {\r\n             return address;\r\n         }\r\n         public void setAddress(Address address) {\r\n             this.address = address;\r\n         }\r\n     }\r\n     ```\r\n\r\n     输出\r\n\r\n     ```\r\n     克隆前的地址：天津\r\n     克隆后的地址：北京\r\n     ```\r\n\r\n     其实就是`Person`类和`Address`类都要重写`clone`方法，这里面需要注意的一点是`super.clone()`为浅克隆，所以在在`Person`类中重写`clone`方法时，`address`对象需要调用`address.clone()`重新赋值，因为`address`类型为引用类型。\r\n\r\n  2. 序列化\r\n\r\n     ```\r\n     public class Main{\r\n         public static void main(String[] args) throws IOException, ClassNotFoundException {\r\n             Address s = new Address("天津");\r\n             Person p = new Person("张三", 23, s);\r\n             System.out.println("克隆前的地址：" + p.getAddress().getName());\r\n             Person cloneP = (Person) p.deepClone();\r\n             cloneP.getAddress().setName("北京");\r\n             System.out.println("克隆后的地址：" + cloneP.getAddress().getName());\r\n         }\r\n     }\r\n     \r\n     class Address implements Serializable{\r\n         private String city;\r\n         public Address(String name){\r\n             this.city = name;\r\n         }\r\n     \r\n         public String getName() {\r\n             return city;\r\n     \r\n         }\r\n         public void setName(String name) {\r\n             this.city = name;\r\n     \r\n         }\r\n     }\r\n     class Person implements Serializable{\r\n         private String name;\r\n         private int age;\r\n         private Address address;\r\n         public Person(String name, int age, Address address){\r\n             this.name = name;\r\n             this.age = age;\r\n             this.address = address;\r\n     \r\n         }\r\n     \r\n         public Object deepClone() throws IOException, ClassNotFoundException {        \r\n             ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n             ObjectOutputStream oos = new ObjectOutputStream(bos);\r\n             oos.writeObject(this);        \r\n             ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());\r\n             ObjectInputStream ois = new ObjectInputStream(bis);\r\n             return ois.readObject();\r\n         }\r\n     \r\n         public String getName() {\r\n             return name;\r\n         }\r\n         public void setName(String name) {\r\n             this.name = name;\r\n         }\r\n         public int getAge() {\r\n             return age;\r\n         }\r\n         public void setAge(int age) {\r\n             this.age = age;\r\n         }\r\n         public Address getAddress() {\r\n             return address;\r\n         }\r\n         public void setAddress(Address address) {\r\n             this.address = address;\r\n         }\r\n     }\r\n     ```\r\n\r\n     输出\r\n\r\n     ```\r\n     克隆前的地址：天津\r\n     克隆后的地址：北京\r\n     ```\r\n\r\n## 47. 常见的Object方法　＊＊＊\r\n\r\n> 这些方法都很重要，面试经常会问到，要结合其他知识将这些方法理解透彻\r\n\r\n- `Object clone()`：创建与该对象的类相同的新对象\r\n- `boolean equals(Object)`：比较两对象是否相等\r\n- `void finalize()`：当垃圾回收器确定不存在对该对象的更多引用时，对象垃圾回收器调用该方法\r\n- `Class getClass()`：返回一个对象运行时的实例类\r\n- `int hashCode()`：返回该对象的散列码值\r\n- `void notify()`：唤醒等待在该对象的监视器上的一个线程\r\n- `void notifyAll()`：唤醒等待在该对象的监视器上的全部线程\r\n- `String toString()`：返回该对象的字符串表示\r\n- `void wait()`：在其他线程调用此对象的 `notify()` 方法或 `notifyAll()`方法前，导致当前线程等待'}}]);