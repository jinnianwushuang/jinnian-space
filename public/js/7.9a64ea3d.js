(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[7],{"09a5":function(n,r,e){"use strict";e.r(r),r["default"]="# mysql┃多个角度说明sql优化\r\n\r\n## **目录**\r\n\r\n· \r\n\r\n目录\r\n\r\n· \r\n\r\n· \r\n\r\n前言\r\n\r\n· \r\n\r\n· \r\n\r\n正文\r\n\r\n· \r\n\r\n§ \r\n\r\n1.表结构优化●\r\n\r\n§ \r\n\r\n§ \r\n\r\n1.1拆分字段\r\n\r\n§ \r\n\r\n§ \r\n\r\n1.2字段类型的选择\r\n\r\n§ \r\n\r\n§ \r\n\r\n1.3字段类型大小的限制\r\n\r\n§ \r\n\r\n§ \r\n\r\n1.4合理的增加冗余字段\r\n\r\n§ \r\n\r\n§ \r\n\r\n1.5新建字段一定要有默认值\r\n\r\n§ \r\n\r\n§ \r\n\r\n2.索引方面●\r\n\r\n§ \r\n\r\n§ \r\n\r\n2.1索引字段的选择\r\n\r\n§ \r\n\r\n§ \r\n\r\n2.2利用好mysql支持的索引下推，覆盖索引等功能\r\n\r\n§ \r\n\r\n§ \r\n\r\n2.3唯一索引和普通索引的选择\r\n\r\n§ \r\n\r\n§ \r\n\r\n3.查询语句方面●\r\n\r\n§ \r\n\r\n§ \r\n\r\n3.1避免索引失效\r\n\r\n§ \r\n\r\n§ \r\n\r\n3.2合理的书写where条件字段顺序\r\n\r\n§ \r\n\r\n§ \r\n\r\n3.3小表驱动大表\r\n\r\n§ \r\n\r\n§ \r\n\r\n3.4可以使用force index()防止优化器选错索引\r\n\r\n§ \r\n\r\n§ \r\n\r\n4.分库分表●\r\n\r\n§ \r\n\r\n· \r\n\r\n结语\r\n\r\n· \r\n\r\n## **前言**\r\n\r\n  mysql的优化是我们经常都会提到的一个话题，也是重中之重，在很多大厂中会有专门的DBA来做这件事情，甚至更过分的是连应届生的招聘岗位要求上都写了需要懂一点sql优化，最近moon一直在写关于mysql的文章，包括之前写的索引相关，其实也都是为了这篇文章做个铺垫，所以你懂了吗，今天我将从表结构、索引、查询语句、分库分表这四个维度来和大家聊聊，在工作中，怎么进行sql优化？\r\n\r\n## **正文**\r\n\r\n### **1.表结构优化●**\r\n\r\n  优化sql最基本的条件时要有一张表，那么我们怎么通过一张表来达到sql语句优化的目的呢？\r\n\r\n### **1.1拆分字段**\r\n\r\n我们给出一个场景，想象自己是一家包子铺老板，每天都要结账，于是肯定会有一张账户余额表，来记录包子铺的总资产\r\n\r\nCREATE TABLE `accout_balance` (\r\n `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键',\r\n `account` varchar(64) NOT NULL DEFAULT '' COMMENT '账户',\r\n `balance` decimal(16,2) DEFAULT NULL COMMENT '余额',\r\n PRIMARY KEY (`id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4;\r\n\r\n  可是后来包子铺的生意做的越来越好，老板陆陆续续开了几百家店，后来居然做成了全国连锁店。\r\n\r\n  老板很开心，但是他发现了一个问题，由于生意太火爆，所以**每时每刻都会有人结账，而且他们的系统越来越卡了**，这是为什么？\r\n\r\n  我们来分析下:\r\n\r\n  每时每刻都会有人结账，结账后会修改accout_balance(账户余额表)的balance(余额)字段，所以这张表是一张热表，而每一次修改都会开启一个事务（update语句就相当于一个事务），所以在高并发的情况下，问题显而易见，**针对同一行数据**，**一个事务必须要等上另一个事务执行完成之后才能执行自己的更新语句**，所以越来越慢。(行锁)\r\n\r\n  那么我们怎么针对这种情况来优化呢？moon的思路是控制并发度。\r\n\r\n  我们目前的情况是几百家分店都会操作这同一行记录，那么我们就可以把这一行记录分成多行，也就是说，把账户的余额分成N份,这样每次增加的时候选择其中的一条记录增加，冲突的概率也变成了之前的N分之一。\r\n\r\n### **1.2字段类型的选择**\r\n\r\n  这种优化应该是比较常见的，我们就长话短说。\r\n\r\n  **比如针对UUID这种数据我们可以直接使用**char(36)**来作为该字段的类型，或者说在表示boolean这种数据格式的时候，我们就可以直接使用**tinyint(2)**作为我们的字段类型**，在我们提前可预知字段的大小的时候，最好在类型上直接限制，避免浪费存储空间占用。\r\n\r\n### **1.3字段类型大小的限制**\r\n\r\n  这点在我们公司的sql建表规范上就会明确写到。\r\n\r\n  我这里简单的举个例子，比如varchar，要使用varchar(255),这里会有几点考量：\r\n\r\n  **一**.**255刚好会消耗**一个字节**的存储单元**，但是256会导致消耗两个字节的存储单元。(这个针对UTF-8编码)\r\n\r\n  **二**.如果你要在varchar上建立索引，255会是一个完全索引，而266以上只能用到最左前缀（**MySQL的每个单表中所创建的**索引长度是有限制的**,且对不同存储引擎下的表有不同的限制。**myisam表**，单列索引，最大长度不能超过1000 bytes，否则会报警，但是创建成功，最终创建的是前缀索引。**innodb表**，单列索引，超过 767 bytes的，给出warning，最终索引创建成功，取前缀索引（取前 255 字符）**），最左前缀的弊端就是无法用到mysql提供的覆盖索引的加速功能了。\r\n\r\n  **三**.此外在onlineddl的时候，255以下可以用inplace的方式，256需要rebuild。(**Inplace方式:这是原生MySQL 5.5，以及innodb_plugin中提供的创建索引的方式。所谓Inplace，也就是**索引创建在原表上直接进行**，不会拷贝临时表。相对于Copy Table方式，这是一个进步。Inplace方式创建索引，创建过程中，原表同样可读的，但是不可写。**)\r\n\r\n### **1.4合理的增加冗余字段**\r\n\r\n  在我们刚开始学习mysql的时候，就会了解到数据库的三范式，**而在实际的使用过程中，为了性能，我们也可以抛弃数据库的三范式**。\r\n\r\n  moon在之前的公司就有这样的问题，一条sql语句要连5张表，正常一个查询下来可能要1分多钟，所以这条sql太重了，而在moon的细心观察下发现，其中两张表都只用到了其中一个字段，然后我就和DBA商量下将这两个字段冗余到了其它的两个表中(业务有关联)，结果这条sql语句的执行时间就变成了十几秒。\r\n\r\n### **1.5新建字段一定要有默认值**\r\n\r\n**好处如下**：\r\n\r\n  **1.节省空间。**\r\n\r\n  大体看上去，好像设置可以为空的时候更节省空间，但实际上，他比NOT NULL要多占用一个bit的空间，用来判断该字段是否为空。\r\n\r\n  **2.索引失效索引分裂**\r\n\r\n  引用到null，索引会失效。还看到一个说法：空更新到非空时，如果空间不足，有可能会引起索引分裂。\r\n\r\n  **3.减少因空值出现的计算错误等**\r\n\r\n  count()在遇到null值时，这条记录不会计算在内。\r\n\r\n### **2.索引方面●**\r\n\r\n### **2.1索引字段的选择**\r\n\r\n  一般情况下，可以通过慢查询日志选择出一些热sql语句，**给select条件后以及where条件后的字段加索引**。\r\n\r\n### **2.2利用好mysql支持的索引下推，覆盖索引等功能**\r\n\r\nselect a from user where b = 5；\r\n\r\n  此时给a和b字段增加索引，这样可以利用mysql的覆盖索引加速的功能，省去了回表的过程。\r\n\r\nselect a from user where c = 5 and d > 5；\r\n\r\n  此时给c和d字段增加索引，也可以在判断的时候也能利用到索引下推的功能，也就是说mysql在判断c=5后，发现d也是索引，会直接找到d判断d>5，如果不给d增加索引此时也是需要回表的。\r\n\r\n  其次对于组合索引：\r\n  (a,b)这种索引一旦建立，就不需要再给a建立索引了，mysql的最左前缀原则支持组合索引或者字符串类型的索引最左N个单位的索引建立。反之，如果你此刻建立的是(a，b)索引，但是你的业务却还需要一个b的单独索引，那么就可以考虑给b单独新建索引了。如果现在你的表中只有a索引，但是业务需求需要(a，b)索引，一定要记得，**先增加索引，然后再建立索引**，不然**可能会导致服务挂掉**。moon有个朋友的同事，在新增索引的时候，选择了先删除，后增加，这样就导致的在删除后到新增前的这段空白期，出现了很多慢查询sql，同时请求量有很大，业务无法在短时间内处理完，只能慢慢等待，最后导致服务挂掉。\r\n\r\n### **2.3唯一索引和普通索引的选择**\r\n\r\n  如果我们**能在业务意义上保证某个字段是唯一的**，并且这张表又是一个**经常写入数据**的表，那么这里moon推荐你用普通索引，而不是唯一索引，原因如下：\r\n  **一**.在读取数据的时候，普通索引在查到满足第一个条件的记录后，会继续查找下一个记录，直到第一个不满足条件的记录。而唯一索引，查找到第一个满足条件的记录时，就直接停止了。这样看来其实唯一索引更好，但是实际观察来看，这种性能的差异微乎其微，况且我们还可以在**查询语句上用limit 1**来限制。重点是第二点。\r\n  **二**.在更新过程中，普通索引的更新因为不用考虑唯一性，会将这次更新操作直接写入change buffer中，之后会定期或者再次访问到这个数据页的时候持久化到磁盘当中。而唯一索引的更新不能用change bufer，原因是要在表中判断是否已经有该条记录，所以会有一个将数据页读入内存的IO操作，而IO操作又是很消耗资源的。\r\n\r\n### **3.查询语句方面●**\r\n\r\n### **3.1避免索引失效**\r\n\r\n  **一**.最佳左前缀法则（带头索引不能死，中间索引不能断\r\n\r\n  **二**.不要在索引上做任何操作（计算、函数、自动/手动类型转换），不然会导致索引失效而转向全表扫描\r\n\r\n  **三**.不能继续使用索引中范围条件（bettween、<、>、in等）右边的列，如：\r\n\r\nselect a from user where c > 5 and b = 4；\r\n\r\n  **四**.索引字段上使用（！= 或者 < >）判断时，会导致索引失效而转向全表扫描\r\n\r\n  **五**.索引字段上使用 is null / is not null 判断时，会导致索引失效而转向全表扫描。\r\n\r\n  **六**.索引字段使用like以通配符开头（‘%字符串’）时，会导致索引失效而转向全表扫描，也是最左前缀原则。\r\n\r\n  **七**.索引字段是字符串，但查询时不加单引号，会导致索引失效而转向全表扫描\r\n\r\n  **八**.索引字段使用 or 时，会导致索引失效而转向全表扫描\r\n\r\n### **3.2合理的书写where条件字段顺序**\r\n\r\n  这里其实也是最左前缀原则。在一些后需维护开发工作中，可以观察表中的联合索引，当你新写的sql有where条件时，尽量在where条件的书写顺序**按照联合索引的顺序**。\r\n\r\n### **3.3小表驱动大表**\r\n\r\n  join查询在有索引条件下，**驱动表有索引不会使用到索引，被驱动表建立索引会使用到索引**。\r\n\r\n  MySQL 表关联的算法是 Nest Loop Join，是通过驱动表的结果集作为循环基础数据，然后一条一条地通过该结果集中的数据作为过滤条件到下一个表中查询数据，然后合并结果。如果还有第三个参与Join，则再通过前两个表的Join结果集作为循环基础数据，再一次通过循环查询条件到第三个表中查询数据，如此往复。所以，**小表驱动大表所建立的连接次数也远比大表驱动小表所建立的连接次数要小的多**。\r\n\r\n  可以通过EXPLAIN分析来判断在sql中谁是驱动表，EXPLAIN语句分析出来的第一行的表即是驱动表。\r\n\r\n### **3.4可以使用force index()防止优化器选错索引**\r\n\r\n  在我们确定要使用某个索引的时候可以使用force index()强制只用某个索引，避免在某些情况下优化器选择错误导致查询效率降低。\r\n\r\n  优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。\r\n\r\n  优化器会结合是否使用临时表、是否排序、扫描行数等因素进行综合判断。\r\n\r\n  当然是用force index 也是有弊端的，如果你的索引发生了变化，而你的sql语句没有即使更改，那么这里就会报错。\r\n\r\n### **4.分库分表●**\r\n\r\n  **在以上你能做到优化的极致条件下，由于数据量很大，可能还是会面临着慢查询的情况出现**，那么这时候我们就要考虑分库分表了。\r\n\r\n  moon这里简单的和大家举个例子:\r\n\r\n  一家做客服系统的公司，业务量很大，客户很多，每天可能有上千万的数据量，如果你将这些数据都放在一张表里面，毫无疑问，会死的很惨。这时候我们可以考虑和业务相关的方式来进行分表，**比如说你有10000家客户，你可以每一百家客户放在一张表上**，这样平均下来一天该表可能只能几十万条数据，这样是可以接受的。但是时间久了，你会发现之前的数据都是没有用的，客户关心的都是最新产生的数据，那么我们就可以分库，**将这些客户不关心的数据放在这个冷库中**，以提高线上热数据的查询效率。\r\n\r\n \r\n\r\n# mysql┃explain 都不会用？怎么优化？\r\n\r\n## **目录**\r\n\r\n\r\n\r\n------\r\n\r\n\r\n\r\n· \r\n\r\n目录\r\n\r\n· \r\n\r\n· \r\n\r\n前言\r\n\r\n· \r\n\r\n· \r\n\r\n正文\r\n\r\n· \r\n\r\n§ \r\n\r\n什么是explain？\r\n\r\n§ \r\n\r\n§ \r\n\r\nexplaing该怎么使用\r\n\r\n§ \r\n\r\n§ \r\n\r\nexplain输出格式字段详解\r\n\r\n§ \r\n\r\n· \r\n\r\n结语\r\n\r\n· \r\n\r\n## **前言**\r\n\r\n\r\n\r\n------\r\n\r\n\r\n\r\n  现在的java开发人员越来越多，竞争也越来越激烈，moon在某钩招聘网站上发布了一个岗位需求，不到短短1天就收到20多份简历，大部分都是应届一年两年的，新鲜血液越来越多，我们也要不断的提升自己才能够不被挤下去，大家可以看下各大网站的java岗位3年以上的招聘需求：\r\n\r\n![img](mysql多个角度说明sql优化.assets/wpsD551.tmp.png)![img](mysql多个角度说明sql优化.assets/wpsD552.tmp.png)![img](mysql多个角度说明sql优化.assets/wpsD553.tmp.png) \r\n\r\n<<< 左右滑动见更多 >>>\r\n\r\n\r\n  大部分java开发岗位都会有写到数据库相关，会把sql优化作为一个重要的岗位要求之一，由此可见sql优化的重要性。\r\n\r\n  mysql调优是一块很大的挑战，并且有很多维度可以优化比如事务方面，表结构方面等等。\r\n\r\n  今天我们就来聊一聊最基本的，如何针对某条sql语句优化，以及explain执行计划的使用。\r\n\r\n## **正文**\r\n\r\n\r\n\r\n------\r\n\r\n\r\n\r\n### **什么是explain？**\r\n\r\n  **explain**是MYSQL提供的一个命令，它可以用来分析select语句，并且输出相应的分析结果，使得开发人员可以针对输出结果来对sql语句进行特定的优化。\r\n\r\n### **explaing该怎么使用**\r\n\r\n  explain的使用很简单，只需要在s需要执行的语句前加上explain就可以了\r\n\r\n**例如**：\r\n\r\nexplain select gab_table_id from gravity_plan_operate_record where ID = 7\r\n\r\n### **explain输出格式字段详解**\r\n\r\n  我们准备两张表\r\n\r\nCREATE TABLE `user` (\r\n `id` bigint(20) NOT NULL AUTO_INCREMENT,\r\n `name` varchar(64) NOT NULL DEFAULT '',\r\n `age` int(11) DEFAULT NULL,\r\n PRIMARY KEY (`id`),\r\n KEY `idx_name` (`name`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\r\n\r\nCREATE TABLE `order` (\r\n `id` bigint(20) NOT NULL AUTO_INCREMENT,\r\n `user_id` bigint(20) DEFAULT '0',\r\n `product_name` varchar(50) NOT NULL DEFAULT '',\r\n `productor` varchar(30) DEFAULT '',\r\n PRIMARY KEY (`id`),\r\n KEY `idx_user_id_product_name` (`user_id`,`product_name`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\r\n\r\n我们在这两张表中都插入一些数据\r\n\r\nINSERT INTO user (name, age) VALUES ('xy是的s', 11);\r\nINSERT INTO user (name, age) VALUES ('a的撒风', 10);\r\nINSERT INTO user (name, age) VALUES ('asdfb', 13);\r\nINSERT INTO user (name, age) VALUES ('csadf', 20);\r\nINSERT INTO user (name, age) VALUES ('dsaf', 14);\r\nINSERT INTO user (name, age) VALUES ('exzcv', 44);\r\nINSERT INTO user (name, age) VALUES ('fgw', 18);\r\nINSERT INTO user (name, age) VALUES ('gbht', 17);\r\nINSERT INTO user (name, age) VALUES ('hbfd', 14);\r\nINSERT INTO user (name, age) VALUES ('ibdfsb', 15);\r\n\r\nINSERT INTO tuya_gravity.order (user_id, product_name, productor) VALUES (111, 'qqq', 'aaa');\r\nINSERT INTO tuya_gravity.order (user_id, product_name, productor) VALUES (111, '234', 'aaa');\r\nINSERT INTO tuya_gravity.order (user_id, product_name, productor) VALUES (1333, 'qqq', 'cc');\r\nINSERT INTO tuya_gravity.order (user_id, product_name, productor) VALUES (222, '444', 'aaa');\r\nINSERT INTO tuya_gravity.order (user_id, product_name, productor) VALUES (2222, '555', 'cc');\r\nINSERT INTO tuya_gravity.order (user_id, product_name, productor) VALUES (333, '444', 'dd');\r\nINSERT INTO tuya_gravity.order (user_id, product_name, productor) VALUES (333, 'qerwq', 'cc');\r\nINSERT INTO tuya_gravity.order (user_id, product_name, productor) VALUES (643, 'vdvd', 'qq');\r\nINSERT INTO tuya_gravity.order (user_id, product_name, productor) VALUES (922, 'vdvd', 'qq');\r\n\r\n左边为 order表  右边为 user表\r\n\r\n![img](mysql多个角度说明sql优化.assets/wpsD554.tmp.png)我们看下explain到底会输出哪些东西\r\n\r\nexplain select * from user where id = 4\r\n\r\n下图就是explain输出的内容，我们来一一解析下\r\n![img](mysql多个角度说明sql优化.assets/wpsD564.tmp.png)\r\n\r\n**各列的含义如下**:\r\n\r\n· \r\n\r\n**id**: SELECT 查询的标识符\r\n\r\n· \r\n\r\n· \r\n\r\n**select_type**: SELECT 查询的类型.\r\n\r\n· \r\n\r\n§ **simple**：进行不需要Union操作或不含子查询的简单select查询时，响应查询语句的select_type 即为simple\r\n\r\n§ **primary**：一个需要Union操作或含子查询的select查询执行计划中，位于最外层的select_type即为primary。与simple一样，select_type为primary的单位select查询也只存在1个，位于查询最外侧的select单位查询的select_type为primary\r\n\r\n§ **union**：由union操作联合而成的单位select查询中，除第一个外，第二个以后的所有单位select查询的select_type都为union。union的第一个单位select的select_type不是union，而是DERIVED。它是一个临时表，用于存储联合（Union）后的查询结果。\r\n\r\n§ **DEPENDENT UNION dependent**：与UNION  select_type一样，dependent union出现在union或union all 形成的集合查询中。此处的dependent表示union或union all联合而成的单位查询受外部影响。下列查询中，两个select 查询用union联合起来，所一union出阿信在select_type中，从in所包含的子查询中可以看到，两个查询通过union连接在一起。MariaDB中，不会在默认优化器模式下先处理IN（subquery）查询内部的子查询，而是读取外部的employees数据表，再执行子查询时，dependent关键字就会出现在select_type中。\r\n\r\n§ **union result**：union result为包含union结果的数据表。MariaDB中，union all或union（DISTINCT）查询会将所有union结果创建为临时表。执行计划中，该临时表所在行为select_type为union result。由于union result在实际查询中不是单位查询，所以没有单独的id值。\r\n\r\n§ **SUBQUERY**：子查询中第一个select\r\n\r\n§ **DEPENDENT SUBQUERY**：子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.\r\n\r\n· \r\n\r\n**table**: 查询的是哪个表\r\n\r\n· \r\n\r\n· \r\n\r\n**partitions**: 匹配的分区\r\n\r\n· \r\n\r\n· \r\n\r\n**type**: 通过 type 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等.\r\n\r\n· \r\n\r\n§ **system**：表中只有一条数据. 这个类型是特殊的 const 类型.\r\n\r\n§ **const**：针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可. 例如下面的这个查询, 它使用了主键索引, 因此 type 就是 const 类型的.\r\n\r\nexplain select * from user where id = 4\r\n\r\n![img](mysql多个角度说明sql优化.assets/wpsD565.tmp.png) \r\n\r\n· **eq_ref**：此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:\r\n\r\nEXPLAIN SELECT * FROM user, tuya_gravity.order WHERE user.id = tuya_gravity.order.user_id\r\n\r\n![img](mysql多个角度说明sql优化.assets/wpsD566.tmp.png) \r\n\r\n· **ref**：此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询. 例如下面这个例子中, 就使用到了 ref 类型的查询:\r\n\r\nEXPLAIN SELECT * FROM user, tuya_gravity.order WHERE user.id = tuya_gravity.order.user_id AND tuya_gravity.order.user_id = 5\r\n\r\n![img](mysql多个角度说明sql优化.assets/wpsD567.tmp.png) \r\n\r\n· **range**：表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, IN() 操作中. 当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个.\r\n\r\nEXPLAIN SELECT * FROM user WHERE id BETWEEN 1 AND 11\r\n\r\n![img](mysql多个角度说明sql优化.assets/wpsD568.tmp.png) \r\n\r\n· **index**：表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据. index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index.\r\n\r\nEXPLAIN SELECT name FROM user\r\n\r\n![img](mysql多个角度说明sql优化.assets/wpsD569.tmp.png) \r\n\r\n· **all**：表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免. 下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.\r\n\r\nEXPLAIN SELECT age FROM user WHERE age = 20\r\n\r\n![img](mysql多个角度说明sql优化.assets/wpsD56A.tmp.png) \r\n\r\n· \r\n\r\n**possible_keys**: 此次查询中可能选用的索引\r\n\r\n· \r\n\r\n· \r\n\r\n**key**: 此次查询中确切使用到的索引.\r\n\r\n· \r\n\r\n· \r\n\r\n**key_len**: 表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.\r\n\r\n· \r\n\r\n· \r\n\r\n**ref**: 哪个字段或常数与 key 一起被使用\r\n\r\n· \r\n\r\n· \r\n\r\n**rows**: 显示此查询一共扫描了多少行. 这个是一个估计值.\r\n\r\n· \r\n\r\n· \r\n\r\n**filtered**: 表示此查询条件所过滤的数据的百分比\r\n\r\n· \r\n\r\n· \r\n\r\n**extra**: 额外信息\r\n\r\n· \r\n\r\n§ **Using filesort**:当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.\r\n\r\nEXPLAIN SELECT id FROM tuya_gravity.order ORDER BY product_name\r\n\r\n![img](mysql多个角度说明sql优化.assets/wpsD56B.tmp.png)    这个时候我们是没有用到索引的，如果改成ORDER BY user_id, product_name就可以利用我们的最左前缀原则用到索引了，例如\r\n\r\nEXPLAIN SELECT id FROM tuya_gravity.order ORDER BY user_id,product_name\r\n\r\n![img](mysql多个角度说明sql优化.assets/wpsD56C.tmp.png) \r\n\r\n· **Using index**:\"覆盖索引扫描\", 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错\r\n\r\n· **Using temporary**:查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.\r\n\r\n "},"1b62":function(n,r,e){"use strict";e.d(r,"d",(function(){return c})),e.d(r,"c",(function(){return m})),e.d(r,"a",(function(){return _})),e.d(r,"b",(function(){return C})),e("4de4"),e("c975");var a=e("448a"),t=e.n(a),o=["/第1阶段-运维基本功（升级7.6版本）/01运维概述与Linux系统安装.pdf","/第1阶段-运维基本功（升级7.6版本）/02Linux基础命令.pdf"],s="linux/heima-Linux云计算",c={name:"Container",data:function(){return{prefix:s,book_options:o,book_options_all:[],show:!0,book:o[0],src:""}},created:function(){this.book_options_all=t()(this.book_options),this.src=this.$utils.compute_book_src(this.prefix+this.book)},watch:{book:function(n,r){n&&this.change_book()}},methods:{change_book:function(){console.log("this.book",this.book),this.src=this.$utils.compute_book_src(this.prefix+this.book)},filterFn:function(n,r){var e=this;r(""!==n?function(){var r=n.toLowerCase();e.book_options=e.book_options_all.filter((function(n){return n.toLowerCase().indexOf(r)>-1}))}:function(){e.book_options=e.book_options_all})}}},i=e("ded3"),d=e.n(i),p=e("2f62"),m={data:function(){return{tab:"",tab_level:1,is_active:!1}},computed:d()({},Object(p["c"])(["get_current_selected_right_menu"])),created:function(){this.is_active=!0,this.fix_right_menu_config()},watch:{tab:function(){this.tab||this.fix_right_menu_config()},get_current_selected_right_menu:function(n,r){this.tab=this.get_current_selected_right_menu["t"+this.tab_level]}},methods:d()(d()({},Object(p["b"])(["set_right_menu_fix_config"])),{},{fix_right_menu_config:function(){this.set_right_menu_fix_config({tl:this.tab_level,tabs:this.tabs||[],tv:this.tab||this.tabs[0]["value"]})}}),beforeDestroy:function(){this.is_active=!1}},b=(e("99af"),e("d81d"),e("fb6a"),e("a434"),e("07ac"),function(){var n=this,r=n.$createElement,e=n._self._c||r;return e("div",{staticClass:"q-my-md q-mx-sm"},[e("div",{staticClass:"q-mb-md row q-gutter-x-md q-gutter-y-sm"},[e("q-select",{staticStyle:{width:"300px"},attrs:{dense:"",filled:"","use-input":"","hide-selected":"","fill-input":"","input-debounce":"0",options:n.topic_options_filtered},on:{filter:n.filterFn,"filter-abort":n.abortFilterFn,input:n.handle_topic_change},scopedSlots:n._u([{key:"before",fn:function(){return[n._v("\n        主题\n      ")]},proxy:!0}]),model:{value:n.topic,callback:function(r){n.topic=r},expression:"topic"}}),e("q-select",{staticStyle:{width:"300px"},attrs:{dense:"",filled:"",options:n.column_options},on:{input:n.handle_column_change},scopedSlots:n._u([{key:"before",fn:function(){return[n._v("\n        列数\n      ")]},proxy:!0}]),model:{value:n.column,callback:function(r){n.column=r},expression:"column"}})],1),e("q-markup-table",{attrs:{dense:""}},[e("thead",[e("tr",[e("th",{staticClass:"text-left text-weight-bolder  ",attrs:{colspan:n.column}},[n._v("\n          "+n._s(n.table_title?n.table_title+"------":"")+"当前词条数量："+n._s(n.word_total)+"\n        ")])])]),e("tbody",[n._l(n.table_data,(function(r,a){return[n.compute_if_show(r)?e("tr",{key:a,class:n.compute_topic_options_style(r)},n._l(n.column,(function(a){return e("td",{key:a,staticClass:"text-left"},[n._v("\n            "+n._s(r[a-1])+"\n          ")])})),0):n._e()]}))],2)])],1)}),f=[],l=(e("caad"),e("a9e3"),e("2532"),{data:function(){return{topic:"全部",column:2,topic_options_filtered:[],topic_options_all:[]}},props:{table_title:{type:String,default:""},word_total:{type:Number,default:0},topic_options:{type:Array,default:function(){return[]}},column_options:{type:Array,default:function(){return[]}},table_data:{type:Array,default:function(){return[]}},show_empty_line:!1},watch:{topic_options:function(n,r){this.init_topic_options_related()},column_options:function(n,r){this.init_column()}},created:function(){this.init_topic_options_related(),this.init_column(),this.handle_column_change(),this.handle_topic_change()},methods:{init_topic_options_related:function(){this.topic_options_all=t()(this.topic_options),this.topic_options_filtered=t()(this.topic_options)},filterFn:function(n,r,e){var a=this;console.log("this.topic_options_all",this.topic_options_all),setTimeout((function(){r((function(){if(""===n)a.topic_options_filtered=t()(a.topic_options_all);else{var r=n.toLowerCase();a.topic_options_filtered=a.topic_options_all.filter((function(n){return n.toLowerCase().indexOf(r)>-1}))}a.$forceUpdate()}),(function(r){""!==n&&r.options.length>0&&(r.setOptionIndex(-1),r.moveOptionSelection(1,!0))}))}),300)},abortFilterFn:function(){},handle_column_change:function(){this.$emit("handle_column_change",this.column)},handle_topic_change:function(){this.$emit("handle_topic_change",this.topic)},init_column:function(){var n=this.$q.platform.is.desktop,r=window.innerWidth;r=n?r-200:r-100,r=r<370?370:r,console.log("ww",r);var e=Math.ceil(r/350);e=e<1?1:e,r<400&&(e=1),e=e>8?8:e,this.column=e},compute_topic_options_style:function(n){var r="",e=1==n.length&&this.topic_options.includes(n[0]);return r=e?"bg-teal-4":"",r},compute_if_show:function(n){if(this.show_empty_line)return!0;var r=n.filter((function(n){return n}));return r.length>0}}}),g=l,h=e("2877"),k=Object(h["a"])(g,b,f,!1,null,"4e74a874",null),u=k.exports,_={components:{excelTable:u},data:function(){return{workSheetsFromFile:[[{data:[]}]],table_title:"",column:8,word_total:0,table_data:[],table_data_all:[],column_options:[1,2,3,4,5,6,7,8],exclude_topic_options:!0,show_empty_line:!1,topic:"",topic_options:[]}},created:function(){this.init_workSheetsFromFile()},methods:{init_workSheetsFromFile:function(){},handle_column_change:function(n){this.column=n,this.init_data()},handle_topic_change:function(n){this.topic=n,console.log("this.topic----",this.topic),this.compute_table_data_show_and_word_total()},rebuild_arr_reduce_empty_line:function(n){var r=[[""]];return n.map((function(n){var e=n.filter((function(n){return n})),a=e.length;if(a)r.push(n);else{var t=r[r.length-1].filter((function(n){return n})).length,o=r[r.length-1].length;o>0&&t>0&&r.push([""])}})),r},init_data:function(){var n=this;console.log("workSheetsFromFile --------",this.workSheetsFromFile);var r=[],e={},a=[];this.workSheetsFromFile.map((function(n){r=r.concat(n["data"])}));var o=this.$lodash.cloneDeep(r[0].filter((function(n){return n})));o.map((function(n,r){e["key_"+r]={title:n,words_raw:[]}})),this.exclude_topic_options&&r.splice(0,1),r.map((function(n,r){n.map((function(n,r){e["key_"+r]["words_raw"].push(n)}))})),console.log("final_obj------------",e);var s=Object.values(e);s.map((function(r,e){a.push([r["title"]]),a=a.concat(n.$lodash.chunk(r["words_raw"],n.column)),a=a.concat([[""]])})),this.topic_options=["全部"].concat(t()(o)),this.table_data_all=this.rebuild_arr_reduce_empty_line(a),this.compute_table_data_show_and_word_total(),console.log("  this.table_data_all   ",this.table_data_all)},compute_table_data_show_and_word_total:function(){var n=[],r=[],e=0;if(r=this.$lodash.cloneDeep(this.table_data_all),console.log(" table_data--------",r),"全部"==this.topic)n=r;else{var a=this.topic_options.indexOf(this.topic),t=a==this.topic_options.length-1,o=t?"":this.topic_options[a+1],s=this.find_topic_index(this.topic),c=o?this.find_topic_index(o):r.length;n=r.slice(s,c)}n.map((function(n){var r=n.filter((function(n){return n})).length;e+=r})),this.word_total=e,this.table_data=n},find_topic_index:function(n){for(var r=0,e=0;e<this.table_data_all.length;e++){var a=this.table_data_all[e];if(1==a.length&&a[0]&&a[0]==n){r=e;break}}return r}}},C=(e("7db0"),e("ac1f"),e("1276"),{data:function(){return{relative_path:"",tab:"",tabs:[],MainComponent:"",img_prefix:"./img/linux/heima-Linux云计算/讲义/"}},methods:{extendMarkdown:function(n){var r=this;console.log(n.renderer.rules);var e=n.renderer.rules.html_block;n.renderer.rules.html_block=function(n,a,t,o,s){var c=n[a];if(console.log("1"),c.content.includes("<img")){console.log("token-- ",c);var i="";i=c.content;var d=i.split('src="'),p="",m=d[1];d[0],r.img_prefix,d[1],p=m.includes("http")?d[0]+' src="'+m:d[0]+' src="'+r.img_prefix+m,c.content=p}return c.attrSet("class","q-markdown--token  "),e(n,a,t,o,s)},n.renderer.rules.image=function(n,e,a,t,o){var s=n[e];console.log("3"),s.attrSet("class","q-markdown--image"),console.log("token--- "+e+"-----",s);var c=s.attrGet("src");return console.log(c),c.includes("http")?s.attrSet("src",c):s.attrSet("src",r.img_prefix+c),o.renderToken(n,e,a)}},compute_img_prefix:function(){var n=this;if(this.MainComponent){var r=this.tabs.find((function(r){return r["value"]==n.tab}));if(r&&r["modules_obj"]){var e=this.relative_path;this.img_prefix="."+e+(r["modules_obj"]["relative_folder"]||"")}else this.img_prefix="."+relative_path}}}})},"1c42":function(n,r,e){"use strict";e.r(r),r["default"]="# 分布式事务的解决方案\r\n\r\n# **什么是分布式事务**\r\n\r\n分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器**「分别位于不同的分布式系统的不同节点之上」**。\r\n\r\n一个大的操作由N多的小的操作共同完成。而这些小的操作又分布在不同的服务上。针对于这些操作，**「要么全部成功执行，要么全部不执行」**。\r\n\r\n# **为什么会有分布式事务？**\r\n\r\n举个例子：\r\n\r\n![img](分布式事务的解决方案.assets/wps7B79.tmp.png) \r\n\r\n转账是最经典的分布式事务场景，假设用户 A 使用银行 app 发起一笔跨行转账给用户 B，银行系统首先扣掉用户 A 的钱，然后增加用户 B 账户中的余额。\r\n\r\n如果其中某个步骤失败，此时就有可能会出现 2 种**「异常」**情况：\r\n\r\no 1.用户 A 的账户扣款成功，用户 B 账户余额增加失败\r\n\r\no 2.用户 A 账户扣款失败，用户 B 账户余额增加成功。\r\n\r\n对于银行系统来说，以上 2 种情况都是**「不允许发生」**，此时就需要事务来保证转账操作的成功。\r\n\r\n在**「单体应用」**中，我们只需要贴上@Transactional注解就可以开启事务来保证整个操作的**「原子性」**。\r\n\r\n但是看似以上简单的操作，在实际的应用架构中，不可能是单体的服务，我们会把这一系列操作交给**「N个服务」**去完成，也就是拆分成为**「分布式微服务架构」**。\r\n\r\n![img](分布式事务的解决方案.assets/wps7B7A.tmp.png) \r\n\r\n比如下订单服务，扣库存服务等等，必须要**「保证不同服务状态结果的一致性」**，于是就出现了分布式事务。\r\n\r\n# **分布式理论**\r\n\r\n## **CAP定理**\r\n\r\n在一个分布式系统中，以下三点特性无法同时满足，**「鱼与熊掌不可兼得」**\r\n\r\n一致性（C）：\r\n在分布式系统中的所有数据备份，**「在同一时刻是否拥有同样的值」**。（等同于所有节点访问同一份最新的数据副本）\r\n\r\n可用性（A）：\r\n在集群中一部分节点**「故障」**后，集群整体**「是否还能响应」**客户端的读写请求。（对数据更新具备高可用性）\r\n\r\n分区容错性（P）：\r\n即使出现**「单个组件无法可用,操作依然可以完成」**。\r\n\r\n具体地讲在分布式系统中，在任何数据库设计中，一个Web应用**「至多只能同时支持上面的两个属性」**。显然，任何横向扩展策略都要依赖于数据分区。因此，设计人员必须在一致性与可用性之间做出选择。\r\n\r\n## **BASE理论**\r\n\r\n在分布式系统中，我们往往追求的是可用性，它的重要程序比一致性要高，那么如何实现高可用性呢？\r\n\r\n前人已经给我们提出来了另外一个理论，就是BASE理论，它是用来对CAP定理进行进一步扩充的。BASE理论指的是：\r\n\r\no **「Basically Available（基本可用）」**\r\n\r\no **「Soft state（软状态）」**\r\n\r\no **「Eventually consistent（最终一致性）」**\r\n\r\nBASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。\r\n\r\n# **分布式事务解决方案**\r\n\r\n## **两阶段提交（2PC）**\r\n\r\n熟悉mysql的同学对两阶段提交应该颇为熟悉，mysql的事务就是通过**「日志系统」**来完成两阶段提交的。\r\n\r\n两阶段协议可以用于单机集中式系统，由事务管理器协调多个资源管理器；也可以用于分布式系统，**「由一个全局的事务管理器协调各个子系统的局部事务管理器完成两阶段提交」**。\r\n\r\n![img](分布式事务的解决方案.assets/wps7B7B.tmp.png) \r\n\r\n这个协议有**「两个角色」**，\r\n\r\nA节点是事务的协调者，B和C是事务的参与者。\r\n\r\n事务的提交分成两个阶段\r\n\r\n第一个阶段是**「投票阶段」**\r\n\r\no 1.协调者首先将命令**「写入日志」**\r\n\r\no 2. **「发一个prepare命令」**给B和C节点这两个参与者\r\n\r\no 3.B和C收到消息后，根据自己的实际情况，**「判断自己的实际情况是否可以提交」**\r\n\r\no 4.将处理结果**「记录到日志」**系统\r\n\r\no 5.将结果**「返回」**给协调者\r\n\r\n![img](分布式事务的解决方案.assets/wps7B8C.tmp.png) \r\n\r\n第二个阶段是**「决定阶段」**\r\n\r\n当A节点收到B和C参与者所有的确认消息后\r\n\r\no **「判断」**所有协调者**「是否都可以提交」**\r\n\r\n§ 如果可以则**「写入日志」**并且发起commit命令\r\n\r\n§ 有一个不可以则**「写入日志」**并且发起abort命令\r\n\r\no 参与者收到协调者发起的命令，**「执行命令」**\r\n\r\no 将执行命令及结果**「写入日志」**\r\n\r\no **「返回结果」**给协调者\r\n\r\n#### **可能会存在哪些问题？**\r\n\r\no \r\n\r\n**「单点故障」**：一旦事务管理器出现故障，整个系统不可用\r\n\r\no \r\n\r\no \r\n\r\n**「数据不一致」**：在阶段二，如果事务管理器只发送了部分 commit 消息，此时网络发生异常，那么只有部分参与者接收到 commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。\r\n\r\no \r\n\r\no \r\n\r\n**「响应时间较长」**：整个消息链路是串行的，要等待响应结果，不适合高并发的场景\r\n\r\no \r\n\r\no \r\n\r\n**「不确定性」**：当事务管理器发送 commit 之后，并且此时只有一个参与者收到了 commit，那么当该参与者与事务管理器同时宕机之后，重新选举的事务管理器无法确定该条消息是否提交成功。\r\n\r\no \r\n\r\n## **三阶段提交（3PC）**\r\n\r\n三阶段提交又称3PC，相对于2PC来说增加了CanCommit阶段和超时机制。如果段时间内没有收到协调者的commit请求，那么就会自动进行commit，解决了2PC单点故障的问题。\r\n\r\n但是性能问题和不一致问题仍然没有根本解决。下面我们还是一起看下三阶段流程的是什么样的？\r\n\r\no \r\n\r\n第一阶段：**「CanCommit阶段」**这个阶段所做的事很简单，就是协调者询问事务参与者，你是否有能力完成此次事务。\r\n\r\no \r\n\r\n§ 如果都返回yes，则进入第二阶段\r\n\r\n§ 有一个返回no或等待响应超时，则中断事务，并向所有参与者发送abort请求\r\n\r\no \r\n\r\n第二阶段：**「PreCommit阶段」**此时协调者会向所有的参与者发送PreCommit请求，参与者收到后开始执行事务操作，并将Undo和Redo信息记录到事务日志中。参与者执行完事务操作后（此时属于未提交事务的状态），就会向协调者反馈“Ack”表示我已经准备好提交了，并等待协调者的下一步指令。\r\n\r\no \r\n\r\no \r\n\r\n第三阶段：**「DoCommit阶段」**在阶段二中如果所有的参与者节点都可以进行PreCommit提交，那么协调者就会从“预提交状态”转变为“提交状态”。然后向所有的参与者节点发送\"doCommit\"请求，参与者节点在收到提交请求后就会各自执行事务提交操作，并向协调者节点反馈“Ack”消息，协调者收到所有参与者的Ack消息后完成事务。相反，如果有一个参与者节点未完成PreCommit的反馈或者反馈超时，那么协调者都会向所有的参与者节点发送abort请求，从而中断事务。\r\n\r\no \r\n\r\n## **补偿事务（TCC）**\r\n\r\nTCC其实就是采用的补偿机制，其核心思想是：**「针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作」**。它分为三个阶段：\r\n\r\n**「Try,Confirm,Cancel」**\r\n\r\no Try阶段主要是对**「业务系统做检测及资源预留」**，其主要分为两个阶段\r\n\r\n§ Confirm 阶段主要是对**「业务系统做确认提交」**，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。\r\n\r\n§ Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，**「预留资源释放」**。\r\n\r\n比如下一个订单减一个库存：\r\n\r\n![img](分布式事务的解决方案.assets/wps7B8D.tmp.png) \r\n\r\n执行流程：\r\n\r\no Try阶段：订单系统将当前订单状态设置为支付中，库存系统校验当前剩余库存数量是否大于1，然后将可用库存数量设置为库存剩余数量-1，\r\n\r\n§ 如果Try阶段**「执行成功」**，执行Confirm阶段，将订单状态修改为支付成功，库存剩余数量修改为可用库存数量\r\n\r\n§ 如果Try阶段**「执行失败」**，执行Cancel阶段，将订单状态修改为支付失败，可用库存数量修改为库存剩余数量\r\n\r\nTCC 事务机制相比于上面介绍的2PC，解决了其几个缺点：\r\n\r\no 1.**「解决了协调者单点」**，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。\r\n\r\no 2.**「同步阻塞」**：引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。\r\n\r\no 3.**「数据一致性」**，有了补偿机制之后，由业务活动管理器控制一致性\r\n\r\n总之，TCC 就是通过代码人为实现了两阶段提交，不同的业务场景所写的代码都不一样，并且很大程度的**「增加」**了业务代码的**「复杂度」**，因此，这种模式并不能很好地被复用。\r\n\r\n## **本地消息表**\r\n\r\n \r\n\r\n![img](分布式事务的解决方案.assets/wps7B8E.tmp.png) \r\n\r\n执行流程：\r\n\r\n \r\n\r\no \r\n\r\n消息生产方，需要额外建一个消息表，并**「记录消息发送状态」**。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。\r\n\r\no \r\n\r\n§ 如果消息发送失败，会进行重试发送。\r\n\r\no \r\n\r\n消息消费方，需要**「处理」**这个**「消息」**，并完成自己的业务逻辑。\r\n\r\no \r\n\r\n§ 如果是**「业务上面的失败」**，可以给生产方**「发送一个业务补偿消息」**，通知生产方进行回滚等操作。\r\n\r\n§ 此时如果本地事务处理成功，表明已经处理成功了\r\n\r\n§ 如果处理失败，那么就会重试执行。\r\n\r\no \r\n\r\n生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。\r\n\r\no \r\n\r\n## **消息事务**\r\n\r\n消息事务的原理是将两个事务**「通过消息中间件进行异步解耦」**，和上述的本地消息表有点类似，但是是通过消息中间件的机制去做的，其本质就是'将本地消息表封装到了消息中间件中'。\r\n\r\n执行流程：\r\n\r\no 发送prepare消息到消息中间件\r\n\r\no 发送成功后，执行本地事务\r\n\r\n§ 如果事务执行成功，则commit，消息中间件将消息下发至消费端\r\n\r\n§ 如果事务执行失败，则回滚，消息中间件将这条prepare消息删除\r\n\r\no 消费端接收到消息进行消费，如果消费失败，则不断重试\r\n\r\n这种方案也是实现了**「最终一致性」**，对比本地消息表实现方案，不需要再建消息表，**「不再依赖本地数据库事务」**了，所以这种方案更适用于高并发的场景。目前市面上实现该方案的**「只有阿里的 RocketMQ」**。\r\n\r\n## **最大努力通知**\r\n\r\n最大努力通知的方案实现比较简单，适用于一些最终一致性要求较低的业务。\r\n\r\n执行流程：\r\n\r\no 系统 A 本地事务执行完之后，发送个消息到 MQ；\r\n\r\no 这里会有个专门消费 MQ 的服务，这个服务会消费 MQ 并调用系统 B 的接口；\r\n\r\no 要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B, 反复 N 次，最后还是不行就放弃。\r\n\r\n## **Sagas 事务模型**\r\n\r\nSaga事务模型又叫做长时间运行的事务\r\n\r\n其核心思想是**「将长事务拆分为多个本地短事务」**，由Saga事务协调器协调，如果正常结束那就正常完成，如果**「某个步骤失败，则根据相反顺序一次调用补偿操作」**。\r\n\r\nSeata框架中一个分布式事务包含3种角色：\r\n\r\n**「Transaction Coordinator (TC)」**：事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚。**「Transaction Manager (TM)」**：控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议。**「Resource Manager (RM)」**：控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚。\r\n\r\nseata框架**「为每一个RM维护了一张UNDO_LOG表」**，其中保存了每一次本地事务的回滚数据。\r\n\r\n具体流程：1.首先TM 向 TC 申请**「开启一个全局事务」**，全局事务**「创建」**成功并生成一个**「全局唯一的 XID」**。\r\n\r\n2.XID 在微服务调用链路的上下文中传播。\r\n\r\n3.RM 开始执行这个分支事务，RM首先解析这条SQL语句，**「生成对应的UNDO_LOG记录」**。下面是一条UNDO_LOG中的记录，UNDO_LOG表中记录了分支ID，全局事务ID，以及事务执行的redo和undo数据以供二阶段恢复。\r\n\r\n4.RM在同一个本地事务中**「执行业务SQL和UNDO_LOG数据的插入」**。在提交这个本地事务前，RM会向TC**「申请关于这条记录的全局锁」**。\r\n\r\n如果申请不到，则说明有其他事务也在对这条记录进行操作，因此它会在一段时间内重试，重试失败则回滚本地事务，并向TC汇报本地事务执行失败。\r\n\r\n6.RM在事务提交前，**「申请到了相关记录的全局锁」**，然后直接提交本地事务，并向TC**「汇报本地事务执行成功」**。此时全局锁并没有释放，全局锁的释放取决于二阶段是提交命令还是回滚命令。\r\n\r\n7.TC根据所有的分支事务执行结果，向RM**「下发提交或回滚」**命令。\r\n\r\no \r\n\r\nRM如果**「收到TC的提交命令」**，首先**「立即释放」**相关记录的全局**「锁」**，然后把提交请求放入一个异步任务的队列中，马上返回提交成功的结果给 TC。异步队列中的提交请求真正执行时，只是删除相应 UNDO LOG 记录而已。\r\n\r\no \r\n\r\no \r\n\r\nRM如果**「收到TC的回滚命令」**，则会开启一个本地事务，通过 XID 和 Branch ID 查找到相应的 UNDO LOG 记录。将 UNDO LOG 中的后镜与当前数据进行比较，\r\n\r\no \r\n\r\n§ 如果不同，说明数据被当前全局事务之外的动作做了修改。这种情况，需要根据配置策略来做处理。\r\n\r\n§ 如果相同，根据 UNDO LOG 中的前镜像和业务 SQL 的相关信息生成并执行回滚的语句并执行，然后提交本地事务达到回滚的目的，最后释放相关记录的全局锁。\r\n\r\n**总结**\r\n\r\n本文介绍了分布式事务的一些基础理论，并对常用的分布式事务方案进行了讲解。\r\n\r\n分布式事务本身就是一个技术难题，业务中具体使用哪种方案还是需要不同的业务特点自行选择，但是我们也会发现，分布式事务会大大的提高流程的复杂度，会带来很多额外的开销工作，**「代码量上去了，业务复杂了，性能下跌了」**。\r\n\r\n所以，当我们真实开发的过程中，能不使用分布式事务就不使用。\r\n\r\n "},3686:function(n,r,e){"use strict";e.d(r,"a",(function(){return i})),e("e260"),e("a15b"),e("d81d"),e("fb6a"),e("4e82"),e("d3b7"),e("ac1f"),e("1276"),e("ddb0");var a=e("ded3"),t=e.n(a),o=e("6821"),s=(e("d958"),function(n){if(!n)return"";var r="",e=n.split("/");return e.shift(),e.pop(),r=e.join("/"),r?"/"+r+"/":""}),c=function(n){n=n||"";var r=n.split("/"),e=r.length;return r[e-1]},i=function(n){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"md",e=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];console.log("当前 require.context---",n),console.log("当前 field_components.keys()---",n.keys());var i=n.keys(),d={},p=[],m={},b=[];return i.map((function(a){var t=a.slice(2,a.length-r.length-1),c="module_"+o(a);b.push(t),m[t]={value:c,relative_path:a,relative_folder:s(a)},console.log("x---",a),d[c]=e?"\n            <div>\n            <code>\n              ".concat(n(a).default,"\n            </code>\n            </div>\n            "):n(a).default})),b.sort((function(n,r){return parseFloat(n)-parseFloat(r)})),b.map((function(n){p.push({label:a?c(n):n,value:m[n]["value"],modules_obj:t()({},m[n])})})),console.log("all_components------------",d),console.log("all_modules---------------",p),{all_components:d,all_modules:p}}},4095:function(n,r,e){var a={"./Redis 主从哨兵集群.md":"cef9","./java-learning-website-blog.md":"fb56","./jvm垃圾回收.md":"d03b","./jvm对象的创建过程内存布局.md":"c0e1","./mysql多个角度说明sql优化.md":"09a5","./《面试八股文》之 JVM 20卷.md":"c486","./《面试八股文》之 Java 基础 34 卷.md":"97a8","./《面试八股文》之 Kafka 21卷.md":"da8d","./《面试八股文》之Dubbo17卷.md":"8c64","./《面试八股文》之Zookeeper12卷.md":"cfe0","./《面试八股文》之网络19卷.md":"83b6","./公众号历史文章汇总.md":"7c2d","./分布式事务的解决方案.md":"1c42","./散乱.md":"d1e8"};function t(n){var r=o(n);return e(r)}function o(n){if(!e.o(a,n)){var r=new Error("Cannot find module '"+n+"'");throw r.code="MODULE_NOT_FOUND",r}return a[n]}t.keys=function(){return Object.keys(a)},t.resolve=o,n.exports=t,t.id="4095"},"44af":function(n,r,e){"use strict";e.r(r);var a=function(){var n=this,r=n.$createElement,e=n._self._c||r;return e("div",[e("q-markdown",{attrs:{extend:n.extendMarkdown,src:n.MainComponent}})],1)},t=[],o=e("3686"),s=e("1b62"),c=Object(o["a"])(e("4095"),"md",!0),i=c.all_components,d=c.all_modules,p={mixins:[s["c"],s["b"]],data:function(){return{img_prefix:"./books/other/",tab:d[0].value,tab_level:1,MainComponent:i[d[0].value],tabs:d}},watch:{tab:function(n,r){this.MainComponent=i[this.tab]}}},m=p,b=e("2877"),f=Object(b["a"])(m,a,t,!1,null,"1cd20c6a",null);r["default"]=f.exports},"7c2d":function(n,r,e){"use strict";e.r(r),r["default"]="## 热文\n\n\n\n- [盘点阿里巴巴 15 款开发者工具](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485159&idx=1&sn=c97c087c45ad6dfc0ef61d80a9d0f702&scene=21#wechat_redirect)\n- [蚂蚁金服2019实习生面经总结(已拿口头offer)](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485147&idx=1&sn=90e525a83a451d8c20298a7ef2d35ab9&scene=21#wechat_redirect)\n- [一千行 MySQL 学习笔记](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485025&idx=1&sn=1f4e19fc77af28f6795feff6ce7465b9&scene=21#wechat_redirect)\n- [可能是把Java内存区域讲的最清楚的一篇文章](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485068&idx=1&sn=c37267fe59978dbfcd6a9a54eee1c502&scene=21#wechat_redirect)\n- [搞定 JVM 垃圾回收就是这么简单](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484877&idx=1&sn=f54d41b68f0cd6cc7c0348a2fddbda9f&chksm=cea24a06f9d5c3102bfef946ba6c7cc5df9a503ccb14b9b141c54e179617e4923c260c0b0a01&token=1082669959&lang=zh_CN&scene=21#wechat_redirect)\n- [【原创】Java学习路线以及方法推荐](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485290&idx=1&sn=569fa9724aae83bff3a353aefc5b7f1c&scene=21#wechat_redirect)\n- [技术面试复习大纲](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485505&idx=1&sn=f7d916334c078bc3fdc2933f889b5016&chksm=cea2478af9d5ce9cafcfe9a053e49e84296d8b1929f79844bba59c8c3d8b56753f34a2c2f6a9&token=1701499214&lang=zh_CN&scene=21#wechat_redirect)\n\n## Java\n\n\n### 必看书籍\n\n- [Java学习必备书籍推荐终极版！](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485113&idx=1&sn=e4dd1bb22778e4e9139bf29d98a7492b&chksm=cea24972f9d5c064e5b454b84b9bc0d42f4aec007f20f79b564398e6dec7c0cdcda0e64193b5&token=1482344439&lang=zh_CN&scene=21#wechat_redirect)\n\n### 基础\n\n- [关于Java基础你不得不会的34个问题](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485015&idx=1&sn=5daa243c3359b88fc88b951f9d08b273&chksm=cea2499cf9d5c08a7698559a2fc27078c6b35856bc2d3588172bf64708c115d4b35d3de80cd9&token=1913747689&lang=zh_CN&scene=21#wechat_redirect)\n- [剖析面试最常见问题之 Java 基础知识](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485173&idx=1&sn=9605f89ed0893b674d14b0c8cf4dc942&chksm=cea2493ef9d5c028a969bb89b53f48fbdd72b975319a844319e3111b15d5dbbc350d91ea5b5a&token=1667678311&lang=zh_CN&scene=21#wechat_redirect)\n\n### Java8新特性\n\n- [Java 8 新特性最佳指南](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484744&idx=1&sn=9db31dca13d327678845054af75efb74&chksm=cea24a83f9d5c3956f4feb9956b068624ab2fdd6c4a75fe52d5df5dca356a016577301399548&token=1082669959&lang=zh_CN&scene=21#wechat_redirect)\n- [看完这篇文章，别说自己不会用Lambda表达式了！](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485425&idx=1&sn=3cc01bc7c42549b6b6aa62b3656e02d1&chksm=cea2483af9d5c12cd10174dac4465a631b14a6d6a09495b018a98e01c698e86368d26b3be03d&token=1667678311&lang=zh_CN&scene=21#wechat_redirect)\n\n### JVM\n\n- [Java内存区域](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485068&idx=1&sn=c37267fe59978dbfcd6a9a54eee1c502&scene=21#wechat_redirect)\n- [垃圾回收](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484877&idx=1&sn=f54d41b68f0cd6cc7c0348a2fddbda9f&chksm=cea24a06f9d5c3102bfef946ba6c7cc5df9a503ccb14b9b141c54e179617e4923c260c0b0a01&token=1082669959&lang=zh_CN&scene=21#wechat_redirect)\n- [谈Java类文件结构](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485250&idx=2&sn=33793bcce3f2ff31b83cf2f9c32df153&scene=21#wechat_redirect)\n- [类加载过程](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485264&idx=2&sn=8c97f7e7d7ad36bc50e713572dbd1529&scene=21#wechat_redirect)\n\n### 并发编程\n\n- [并发编程面试必备：JUC 中的 Atomic 原子类总结](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484834&idx=1&sn=7d3835091af8125c13fc6db765f4c5bd&chksm=cea24a69f9d5c37ff88a8328214cb48b06afb9dc82e46cd924d2595f109ea28922212f9e653c&token=1082669959&lang=zh_CN&scene=21#wechat_redirect)\n- [并发编程面试必备：AQS 原理以及 AQS 同步组件总结](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484832&idx=1&sn=f902febd050eac59d67fc0804d7e1ad5&chksm=cea24a6bf9d5c37d6b505fe1d43e4fb709729149f1f77344b4a0f5956cab5020a2e102f2adf2&token=1082669959&lang=zh_CN&scene=21#wechat_redirect)\n- [BATJ都爱问的多线程面试题](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484831&idx=1&sn=e22d2832a436dbb94233272429d4c4c4&chksm=cea24a54f9d5c3420e96aa94e3d893f4cf825852fff0b4a7e4e241cc229f4666f3dc4d53955e&token=1082669959&lang=zh_CN&scene=21#wechat_redirect)\n- [通俗易懂，JDK 并发容器总结](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484797&idx=1&sn=e28462eec497e38053d9fb9ba17ff022&chksm=cea24ab6f9d5c3a05b5ad36111e93d824ce964442366bc8add1cd77cb432057e4995592c8024&token=1082669959&lang=zh_CN&scene=21#wechat_redirect)\n\n### 代码质量\n\n- [八点建议助您写出优雅的Java代码](https://mp.weixin.qq.com/s/o3BGTdAa8VufcIKU0ScBqA)\n- [十分钟搞懂Java效率工具Lombok使用与原理](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485385&idx=2&sn=a7c3fb4485ffd8c019e5541e9b1580cd&chksm=cea24802f9d5c1144eee0da52cfc0cc5e8ee3590990de3bb642df4d4b2a8cd07f12dd54947b9&token=1667678311&lang=zh_CN#rd)\n- [如何写出让同事无法维护的代码？](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485413&idx=2&sn=70336d94018ad93d67cfacb4aeceb01b&chksm=cea2482ef9d5c1382d8a009e2ecd680c3b6ac3c7c02810af8901970e69c431273113ca7e4447&token=1667678311&lang=zh_CN#rd)\n- [Code Review最佳实践](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485494&idx=1&sn=c7f160fd1bb13a20b887493003acbbf9&chksm=cea247fdf9d5ceebf3b98bd7c524d0ecc672d4bcb10a70fae90390abd862538aa3283c93375b&token=1701499214&lang=zh_CN&scene=21#wechat_redirect)\n- [后端开发必备的 RestFul API 知识](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485510&idx=1&sn=e9273322ae638c8465a606737109ab97&chksm=cea2478df9d5ce9b58b9ff1f1e2ecca99e961b911adcec3d5a579b41e01151160cfb2891d91b&token=1701499214&lang=zh_CN&scene=21#wechat_redirect)\n\n## 网络\n\n- [搞定计算机网络面试，看这篇就够了（补充版）](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484889&idx=1&sn=5f9e6f5c29f9514701c246573d15d9fa&chksm=cea24a12f9d5c3041efd5cf864eb69b76aea6ef9c000a72b16d54794aab97d4fb53515a77147&token=1082669959&lang=zh_CN#rd)\n\n## 系统设计\n\n### Spring\n\n- [Spring常见问题总结（补充版）](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485576&idx=1&sn=f993349f12650a68904e1d99d2465131&chksm=cea24743f9d5ce55ffe543a0feaf2c566382024b625b59283482da6ab0cbcf2a3c9dc5b64a53&token=2133161636&lang=zh_CN#rd)\n- [面试官:“谈谈Spring中都用到了那些设计模式?”。](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485303&idx=1&sn=9e4626a1e3f001f9b0d84a6fa0cff04a&chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&token=1667678311&lang=zh_CN#rd)\n- [可能是最漂亮的Spring事务管理详解](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484943&idx=1&sn=46b9082af4ec223137df7d1c8303ca24&chksm=cea249c4f9d5c0d2b8212a17252cbfb74e5fbe5488b76d829827421c53332326d1ec360f5d63&token=1082669959&lang=zh_CN#rd)\n- [SpringMVC 工作原理详解](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484846&idx=1&sn=490014ea65669c1a1e73e25d7b9fa569&chksm=cea24a65f9d5c373d31d6cdd61297db21de63462c1c03c34b7025a0d0b93f1182b2ad7e33cab&token=1082669959&lang=zh_CN#rd)\n- [Spring编程式和声明式事务实例讲解](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484942&idx=1&sn=b0d9e6f1af243bbf7f34ede5a6d2277d&chksm=cea249c5f9d5c0d3da9206b753bb7734d47d8d8b43edcc02bdf6f139e34e1db512cf5ed32217&token=1082669959&lang=zh_CN#rd)\n- [一文轻松搞懂Spring中bean的作用域与生命周期](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484865&idx=2&sn=178c6e64e6c12172e77efdd669eb86a7&chksm=cea24a0af9d5c31c389ae7817613a336f00c330021f73c90afe383c8caf6ea07a9e1f949c68d&token=1082669959&lang=zh_CN#rd)\n\n### SpringBoot\n\n- [超详细，新手都能看懂 ！使用SpringBoot+Dubbo 搭建一个简单的分布式服务](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484809&idx=1&sn=a789eba40404e6501d51b24345b28906&chksm=cea24a42f9d5c3544babde7f33790fc54f02ebc2f589ce9fa116bbb9c7b0c0cfb1bc314d17de&token=1082669959&lang=zh_CN#rd)\n- [基于 SpringBoot2.0+优雅整合 SpringBoot+Mybatis](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484805&idx=2&sn=0e148af5baebae53b3fd365cff689046&chksm=cea24a4ef9d5c35862efc9c67b0619f7e8ade4b75e1001189ededccd8fd35ca5cd19fda074b9&token=1082669959&lang=zh_CN#rd)\n- [新手也能实现，基于SpirngBoot2.0+ 的 SpringBoot+Mybatis 多数据源配置](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484803&idx=1&sn=9179890db39721a59bb815b7f985ec2d&chksm=cea24a48f9d5c35e73d3df4b29d340e1a4c76d43b220c0f9535e77b43a74ff049ee7b89a4a38&token=1082669959&lang=zh_CN#rd)\n- [SpringBoot 整合 阿里云OSS 存储服务，快来免费搭建一个自己的图床](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484801&idx=1&sn=22d97f9c963d45820559d7226874e33f&chksm=cea24a4af9d5c35cac3177921801287b1ad983eabb6e18cf30302fc235b7f699401510ea2a59&token=1082669959&lang=zh_CN#rd)\n- [Spring Boot 实现热部署的一种简单方式](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485586&idx=2&sn=01788bf8c64de91d085a01c1f4f5159d&chksm=cea24759f9d5ce4fe914aa43e517f16b7f4066de3096be09d01500596ca63ad9f1eef4b8fffa&token=2133161636&lang=zh_CN#rd)\n- [SpringBoot 处理异常的几种常见姿势](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485568&idx=2&sn=c5ba880fd0c5d82e39531fa42cb036ac&chksm=cea2474bf9d5ce5dcbc6a5f6580198fdce4bc92ef577579183a729cb5d1430e4994720d59b34&token=2133161636&lang=zh_CN#rd)\n- [5分钟搞懂如何在Spring Boot中Schedule Tasks](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485563&idx=1&sn=7419341f04036a10b141b74624a3f8c9&chksm=cea247b0f9d5cea6440759e6d49b4e77d06f4c99470243a10c1463834e873ca90266413fbc92&token=2133161636&lang=zh_CN#rd)\n\n### MyBatis\n\n- [面试官:“谈谈MyBatis中都用到了那些设计模式?”。](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485369&idx=1&sn=a493d646e126cd1c19ce9f1fc9c724c9&chksm=cea24872f9d5c16462d82f033699d7ad3177964100f8c8958ce9b8e0872e246f552ae6ac423f&token=1667678311&lang=zh_CN#rd)\n\n## 数据库\n\n### MySQL\n\n- [MySQL知识点总结[修订版]](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485390&idx=1&sn=43511395093d2e0deb64f89c8af1805e&chksm=cea24805f9d5c113026292c7681238b1c65c09958588aa5c70e37249e384f5c965f87ef438ad&token=1667678311&lang=zh_CN#rd)\n- [【思维导图-索引篇】搞定数据库索引就是这么简单](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484848&idx=1&sn=77a0e6e82944ec385f5df17e91ce3bf2&chksm=cea24a7bf9d5c36d4b289cccb017292f9f36da9f3c887fd2b93ecd6af021fcf30121ba09799f&token=1082669959&lang=zh_CN#rd)\n- [一条SQL语句在MySQL中如何执行的](https://mp.weixin.qq.com/s/QU4-RSqVC88xRyMA31khMg)\n- [一文带你轻松搞懂事务隔离级别(图文详解)](https://mp.weixin.qq.com/s/WhK3SrkMDTj1_o2zp64ArQ)\n- [详记一次MySQL千万级大表优化过程！](https://mp.weixin.qq.com/s/SbpM_q_-nIKJn7_TSmrW8A)\n\n### Redis\n\n- [史上最全Redis高可用技术解决方案大全](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484850&idx=1&sn=3238360bfa8105cf758dcf7354af2814&chksm=cea24a79f9d5c36fb2399aafa91d7fb2699b5006d8d037fe8aaf2e5577ff20ae322868b04a87&token=1082669959&lang=zh_CN#rd)\n- [redis 总结——重构版](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484858&idx=1&sn=8e222ea6115e0b69cac91af14d2caf36&chksm=cea24a71f9d5c367148dccec3d5ddecf5ecd8ea096b5c5ec32f22080e66ac3c343e99151c9e0&token=1082669959&lang=zh_CN#rd)\n\n## 面试相关\n\n- [面试中常见的几道智力题 来看看你会做几道？](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484923&idx=1&sn=e1fd890a1a7290f996dc8d7ca4b2d599&chksm=cea24a30f9d5c326f5498929decb7b2d9e39d8806b74c823ccf46fe9fba778d5d9aa644292db&token=1082669959&lang=zh_CN#rd)\n- [面试中常见的几道智力题 来看看你会做几道（2）？](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484917&idx=1&sn=8587b384b42927618067c0e3a56083a9&chksm=cea24a3ef9d5c328a5fd97441de1ccfaf42f9296e5f491b1fa4be9422431d6f26dac36a75e16&token=1082669959&lang=zh_CN#rd)\n- [[算法总结] 搞定 BAT 面试——几道常见的子符串算法题](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484869&idx=1&sn=785d0dce653aa1abdbc542007da830e8&chksm=cea24a0ef9d5c31853ae1114844041f12daf88ef753fb019980e466f32922c50d332e1d1fc2c&token=1082669959&lang=zh_CN#rd)\n- [[BAT面试必备] ——几道常见的链表算法题](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484862&idx=1&sn=015a4eb2f66978010d68c1305a46cfb5&chksm=cea24a75f9d5c363683aadf3ac434b8baf9ff5be8d2939d7875ebb3a742780b568a0926a2cc4&token=1082669959&lang=zh_CN#rd)\n- [如何判断一个元素在亿级数据中是否存在？](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484796&idx=1&sn=25c190a95ac53b81063f7acda936c994&chksm=cea24ab7f9d5c3a1819605008bfc92834eddf37ca3ad24b913fab558b5d00ed5306c5d6aab55&token=1082669959&lang=zh_CN#rd)\n- [可能是一份最适合你的后端面试指南（部分内容前端同样适用）](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484840&idx=1&sn=cf4611ac290ae3cbb381fe52aa76b60b&chksm=cea24a63f9d5c375215f7539ff0f3d6320f091d5f8b73e95c724ec9a31d3b5baa98c3f5a1012&token=1082669959&lang=zh_CN#rd)\n- [GitHub 上四万 Star 大佬的求职回忆](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484802&idx=1&sn=58e204718559f6cf94d3d9cd9614ebc2&chksm=cea24a49f9d5c35f8d53f79801aea21fdd3c06ff4b6c16167e8211f627eea8c5a0ce334fd240&token=1082669959&lang=zh_CN#rd)\n- [这7个问题，可能大部分Java程序员都比较关心吧！](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484786&idx=1&sn=4f61c62c0213602a106ce20db7768a93&chksm=cea24ab9f9d5c3afe7b5c90f6a8782adef93e916a46685aa8c46b752fddadf88273748c7f1ab&token=1082669959&lang=zh_CN#rd)\n- [2018年BATJ面试题精选](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484774&idx=1&sn=2aaaafcecd2bc6b519a11fa0fc1f66fa&chksm=cea24aadf9d5c3bb69359b0973930387885de75b444837df4f34ac14eebbabe498605660ae48&token=1082669959&lang=zh_CN#rd)\n- [一位大佬的亲身经历总结：简历和面试的技巧](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485409&idx=1&sn=47b09ec432929306d39762b13364b04b&chksm=cea2482af9d5c13cc91e8e679f0b823e667b616866519af1523d1d8b4e550cfdaa2f57b21bf3&token=1667678311&lang=zh_CN#rd)\n- [包装严重的IT行业，作为面试官，我是如何甄别应聘者的包装程度](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485404&idx=1&sn=b0c5b9e55bb6f7e71585c1b2e769fd87&chksm=cea24817f9d5c101cfa45a5d2707445030259f030d91f48c068450c5a280457ee25fa51b3f24&token=1667678311&lang=zh_CN#rd)\n- [面试官：你是如何使用JDK来实现自己的缓存（支持高并发）？](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485347&idx=1&sn=8da3919089909d39dbf0745225ca0dad&chksm=cea24868f9d5c17eaec7eba2a4a3b63ed46dff87cb08b3f5d491e96890d8f375735cfcc77562&token=1667678311&lang=zh_CN#rd)\n\n### 面经\n\n- [5面阿里，终获offer](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484747&idx=1&sn=bff601fd1d314f670cb44171ea1925dd&chksm=cea24a80f9d5c396619acaa9f77207019f72d43749559b5a401359915e01b51598a687c48203&token=1082669959&lang=zh_CN#rd)\n- [记一次蚂蚁金服的面试经历](https://mp.weixin.qq.com/s/LIhtyspty9Kz1qRg1b8N-w)\n- [2019年蚂蚁金服、头条、拼多多的面试总结](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485167&idx=1&sn=a35fad235a6bb2b6e31f1ff37e72bfd7&chksm=cea24924f9d5c032cbbeffc87cd366e9aa7b209897a26ad5c7f7b1b766b3c34a2c9b6870006c&token=1667678311&lang=zh_CN#rd)\n- [蚂蚁金服2019实习生面经总结(已拿口头offer)](https://mp.weixin.qq.com/s/ktq2UOvi5qI1FymWIgp8jw)\n- [2019年蚂蚁金服面经（已拿Offer）！附答案！！](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485251&idx=1&sn=21e5da0d76dd71d165f19015ebeba780&chksm=cea24888f9d5c19e041a145e6da3d4fa94f63b34c71d43f10c29340c7d51a4a23971904d19b5&token=1667678311&lang=zh_CN#rd)\n\n### 备战面试系列\n\n- [【备战春招/秋招系列】程序员的简历就该这样写](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484830&amp;idx=1&amp;sn=2e868311f79f4a52a0f3be383050c810&source=41#wechat_redirect)\n- [【备战春招/秋招系列】初出茅庐的程序员该如何准备面试？](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484829&idx=1&sn=29e0e08d9da0f343f14c16bb3ac92beb&chksm=cea24a56f9d5c340ecb67a186b3c8fb5ef30ff481bfbdec3249f2145b3f376fd2d6dc19fbefc&token=1082669959&lang=zh_CN#rd)\n- [【备战春招/秋招系列】Java程序员必备书单](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484826&idx=1&sn=cf015aca00e420d476c3cb456a11d994&chksm=cea24a51f9d5c34730dcdb538c99cb58d23496ebe8c51fb191dd629ab28c802f97662aef3366&token=1082669959&lang=zh_CN#rd)\n- [【备战春招/秋招系列】面试官问你“有什么问题问我吗？”，你该如何回答？](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484755&idx=1&sn=4a09256062642c714f83ed03cb083846&chksm=cea24a98f9d5c38e8e040c332bf58ccac48a93190e059b9f39e4249eae579b8d32238cea88dd&token=1082669959&lang=zh_CN#rd)\n- [【备战春招/秋招系列】美团面经总结基础篇 （附详解答案）](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484825&idx=1&sn=a0ec65a5f2b268a6f4d22c3bb9790126&chksm=cea24a52f9d5c344922e4dcd4b9650d63ad5c4d843208e3fb7f21bcffa144a6bab0d748cdfbb&token=1082669959&lang=zh_CN#rd)\n- [【备战春招/秋招系列】美团面经总结进阶篇 （附详解答案）](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484822&idx=1&sn=efefe8a5a1ff9a54a57601edab134a04&chksm=cea24a5df9d5c34b36e8b12beb574ca31ae771de3881237c4f02be61b52e38f763d2d6137dd3&token=1082669959&lang=zh_CN#rd)\n- [【备战春招/秋招系列】美团Java面经总结终结篇 （附详解答案）](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484815&idx=1&sn=4dd1a280fb95c59366c73897c77049fb&chksm=cea24a44f9d5c3524b301ecf313382ea78b6ac821b4d5e9f9cf51346fc10839c1e234e7cb3ed&token=1082669959&lang=zh_CN#rd)\n\n### 面试现场\n\n- [【面试现场】如何实现可以获取最小值的栈？](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484863&idx=2&sn=ac674bb0cf29b782aa0e6e9365defa4b&chksm=cea24a74f9d5c362b22459ceda77e635366a17175cd30bbdce14bc729e5417b137175a90331b&token=1082669959&lang=zh_CN#rd)\n- [【面试现场】为什么要分稳定排序和非稳定排序？](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484856&idx=2&sn=af47a53a913b42b064a6e158d165fd2f&chksm=cea24a73f9d5c365084c65d30372f1ae35893ad3ec751da71e14ce5fda07b17ab5f0da90f663&token=1082669959&lang=zh_CN#rd)\n- [【面试现场】如何找到字符串中的最长回文子串？](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484855&idx=1&sn=e75a06c56fe3b8802f18b04ef4df1c43&chksm=cea24a7cf9d5c36ab8090506442fa131a3d332343e953567c5f78dbef5aed0b6ed317b25af9f&token=1082669959&lang=zh_CN#rd)\n- [【面试现场】如何在10亿数中找出前1000大的数](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484845&idx=1&sn=6a235c6181c0f46630a9a22ef762a23b&chksm=cea24a66f9d5c3709e9618a1e418535d467053273123b81fda3897b4431a02a105703fd22644&token=1082669959&lang=zh_CN#rd)\n\n## 算法\n\n- [【算法技巧】位运算装逼指南](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485292&idx=1&sn=330e7f8c972bd7ed368aca7ccb434493&chksm=cea248a7f9d5c1b1f5387adbda961f0aa02c6f575fd9367937b9c15be1b241222b340f61dc5e&token=1667678311&lang=zh_CN#rd)\n\n## Github 热门Java项目推荐\n\n- [近几个月Github上最热门的Java项目一览](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484908&idx=1&sn=a95d37194f03b7e4aae1612e1785bf44&chksm=cea24a27f9d5c331d818fa1b2b564f9d5e9ff245a969a50e98944b909d6e45c0ebde544f982e&token=1082669959&lang=zh_CN#rd)（2018-07-20）\n- [推荐10个Java方向最热门的开源项目（8月）](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484876&idx=1&sn=3cab92ee5bda6b47bf7232724461f6a3&chksm=cea24a07f9d5c31106d0806b1bd8bae8821511b0a32879fb4f4b3bec7823db1f62e23821b07b&token=1082669959&lang=zh_CN#rd)( 2018-08-28)\n- [Github上 Star 数相加超过 7w+ 的三个面试相关的仓库推荐](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484819&idx=1&sn=6d83101ee504a6ab19ef07fb32650876&chksm=cea24a58f9d5c34ef9f3a7374c5147b1ff85e18ca4e59e21c4edf7d63bc1bd8c5c241e0c532b&token=1082669959&lang=zh_CN#rd)（ 2018-11-17）\n- [11月 Github Trending 榜最热门的 10 个 Java 项目](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484805&idx=1&sn=acee5bd6c3f861c65be3a2fb8843e1f5&chksm=cea24a4ef9d5c358c263cb4605acc6b6254635c28c496a9a10aee0dc80293f457a9af2e90d1c&token=1082669959&lang=zh_CN#rd)（ 2018-12-01）\n- [盘点一下Github上开源的Java面试/学习相关的仓库，看完弄懂薪资至少增加10k](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484789&idx=1&sn=2ad9fabb8fc7fae3bd3756ea05594344&chksm=cea24abef9d5c3a889b6cb8e00cb18abbb694d189c84a24fa1ed337ad4c56194cd39316dc6a5&token=1082669959&lang=zh_CN#rd)( 2018-12-24)\n- [12月GithubTrending榜Java项目总结，多了几个新面孔](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484784&idx=1&sn=3c98b2e6aa97014a8fb4bf837be40f52&chksm=cea24abbf9d5c3ad3ab779749f6a75ed9bc4321986056a65f5f04033c9cc626a382ebe597278&token=1082669959&lang=zh_CN#rd)（2019-01-02）\n- [1月份Github上收获最多star的10个项目](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484761&idx=1&sn=db6441c08f5ae8d75978384108cc852d&chksm=cea24a92f9d5c3846858a91aa7dc6b258f91407e2a22a1c7b2e46a8e5dd4d9a9ef443eed3b0e&token=1082669959&lang=zh_CN#rd)(2019-02-01)\n- [2019年2月份Github上收获最多Star的10个Java项目](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484749&idx=1&sn=a66a1e3707839454539d93499dcadfad&chksm=cea24a86f9d5c3902d07fc4614347606200536ddf9ee7464fe12bbbce5c1bd186ad9894f13e3&token=1082669959&lang=zh_CN#rd)（2019-03-05）\n- [3月Github最热门的10个Java开源项目](https://mp.weixin.qq.com/s/HYXFWeko2tGPCWhy-yrtEw)\n- [五一假期充电指南：4月Github最热门的Java项目推荐](https://mp.weixin.qq.com/s/3485Z0cbD1FvcWZMQTnRsw)\n\n## 架构\n\n- [8 张图读懂大型网站技术架构](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484863&idx=1&sn=8b7c8ce77f5927564d69587688114c79&chksm=cea24a74f9d5c362b7140d18bfc198e7f39572b938e597d1725e4dcf541a12b33d8db6ac1b45&token=1082669959&lang=zh_CN#rd)\n- [【面试精选】关于大型网站系统架构你不得不懂的10个问题](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484760&idx=1&sn=c41df36f538ab3d8907e23bf8f6d2cd5&chksm=cea24a93f9d5c3851f8a699fdf068f767e3571c38e1b2995297a3e5725f9ad024c6de2bcb100&token=1082669959&lang=zh_CN#rd)\n- [分布式系统的经典基础理论](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484941&idx=1&sn=e0812a9ccfde06550e24c23c4bb5ef1d&chksm=cea249c6f9d5c0d0bd16fc26c7af606c775868f1f06d81fbff2f8093d2a686c3b3befe9b971c&token=1082669959&lang=zh_CN#rd)\n- [软件开发的七条原则](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484938&idx=1&sn=597b1aec42d22caad051b3694816fb27&chksm=cea249c1f9d5c0d73bcedc02499cb44822f6b5ab9dcccd7f1a03f830aed158a1b9abec416efc&token=1082669959&lang=zh_CN#rd)\n- [关于分布式计算的一些概念](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484935&idx=2&sn=2394583a73b41cca431e392a28b0b4cb&chksm=cea249ccf9d5c0da5d1d4b8cf2dffb00ae1b6b605afe6da426112f3208898c2cca6249865146&token=1082669959&lang=zh_CN#rd)\n\n## 工具\n\n- [Git入门看这一篇就够了！](https://mp.weixin.qq.com/s/ylyHOuEPX4tDvOc7-SxMmw)\n- [团队开发中的 Git 实践](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485550&idx=1&sn=a0fa847b009c3c8c60c20773f0870dbf&chksm=cea247a5f9d5ceb317906f37d7dfbd44aebbe2206764cd8b50a25110c3125c7be3507ce3729e&token=2133161636&lang=zh_CN#rd)\n- [IDEA中的Git操作，看这一篇就够了！](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485578&idx=1&sn=8f8ab9d597e1448053e5da380fff3e54&chksm=cea24741f9d5ce5791722dd3da12dfa3de5aa9d742e0cc78d0b72a89d75a48e6d84512265c30&token=2133161636&lang=zh_CN#rd)\n- [一文搞懂如何在Intellij IDEA中使用Debug，超级详细！](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485250&idx=1&sn=9e1f270996441094104a06fc909c60f5&chksm=cea24889f9d5c19fbc6024779ca476a3ee141efa457fc86cc8c33a8f06a1c2b1e7b4922426c2&token=1667678311&lang=zh_CN#rd)\n- [十分钟搞懂Java效率工具Lombok使用与原理](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485385&idx=2&sn=a7c3fb4485ffd8c019e5541e9b1580cd&chksm=cea24802f9d5c1144eee0da52cfc0cc5e8ee3590990de3bb642df4d4b2a8cd07f12dd54947b9&token=913106598&lang=zh_CN&scene=21#wechat_redirect)\n\n## 效率\n\n- [推荐几个可以提升工作效率的Chrome插件](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485315&idx=1&sn=f5e91a9386a6911acbff4d7721065563&chksm=cea24848f9d5c15ec3bc0efab93351ca7481a609e901d9c9c07816a7a9737cdcdc1b5f6497db&token=1667678311&lang=zh_CN#rd)\n\n## 思维开阔\n\n- [不就是个短信登录API嘛，有这么复杂吗？](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485181&idx=1&sn=7a7a7ce0671e8c5456add8da098501c2&chksm=cea24936f9d5c020fa1e339a819a17e7ae6099f1c5072d9ea235cf9fca45437d96cb117f7f10&token=1667678311&lang=zh_CN#rd)\n\n## 进阶\n\n- [可能是把Docker的概念讲的最清楚的一篇文章](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484921&idx=1&sn=d40518712a04b3c37d7c8fcd3e696e90&chksm=cea24a32f9d5c3243db78a227ba4e77618e679bbc856cf1974fccbd474c44847672f21658147&token=1082669959&lang=zh_CN#rd)\n- [后端必备——数据通信知识(RPC、消息队列)一站式总结](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484920&idx=1&sn=c7167df0b36522935896565973d02cc9&chksm=cea24a33f9d5c325fc663c95ebc221060ae2d5eeee254472558a99fdfc2837b31d3b9ae51a12&token=1082669959&lang=zh_CN#rd)\n- [可能是全网把 ZooKeeper 概念讲的最清楚的一篇文章](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484868&idx=1&sn=af1e49c5f7dc89355255a4d46bafc005&chksm=cea24a0ff9d5c3195a690d2c85f09cd8901717674f52e10b0e6fd588d69de15de76b8184307d&token=1082669959&lang=zh_CN#rd)\n- [外行人都能看懂的SpringCloud，错过了血亏！](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484813&idx=1&sn=d87c01aff031f35be6b88a61f5782da5&chksm=cea24a46f9d5c35023a54e20fa1319b4cd31c33b094e2fd161bb8667ab77b8b403af62cfb3b5&token=1082669959&lang=zh_CN#rd)\n- [关于 Dubbo 的重要入门知识点总结](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484753&idx=1&sn=32d987bf9f6208e30326877b111cad61&chksm=cea24a9af9d5c38cc7eb4d9bfeaa07e72003a1bf304a0fedc3fabb2a87f01c98b5a7d1c80d53&token=1082669959&lang=zh_CN#rd)\n- [Java 工程师成神之路 | 2019正式版](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484759&idx=1&sn=5a706091c1db2b585f0a93c75bca14da&chksm=cea24a9cf9d5c38a245bdc63a0c90934b02f582c34a8dfb4ef01cd149d4829d799cb9e9bd464&token=1082669959&lang=zh_CN#rd)\n- [聊一聊开发常用小工具](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484769&idx=1&sn=0968ce79f4d31d982b9f1ce24b051432&chksm=cea24aaaf9d5c3bc5feb0ef4e814990c9e108b72a0691193b1dda29642ee2ff74da5026016f6&token=1082669959&lang=zh_CN#rd)\n- [新手也能看懂，消息队列其实很简单](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484794&idx=1&sn=61585fe69eedb3654ee2f9c9cd67e1a1&chksm=cea24ab1f9d5c3a7fd07dd49244f69fc85a5a523ee5353fc9e442dcad2ca0dd1137ed563fcbe&token=1082669959&lang=zh_CN#rd)\n\n## 杂文闲记\n\n- [一只准准程序员的唠叨](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484932&idx=1&sn=a4f3057ecd4412cb8b18e92058b29680&chksm=cea249cff9d5c0d97580310f6666a4e0c42cfd1ba13dd759850e489c9386dce8c5c35b0a1a95&token=1082669959&lang=zh_CN#rd)(2018-06-09)\n- [说几件近期的小事](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484900&idx=1&sn=745e8f6027da369ef5f8e349cb5d6657&chksm=cea24a2ff9d5c339c925322ffacdc72dd37bda63238dfb3452540085c1695681e2e79070e2a7&token=1082669959&lang=zh_CN#rd)(2018-08-02)\n- [选择技术方向都要考虑哪些因素](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484898&idx=1&sn=fd2ebf9ffd37ab5de1de09cd3272ac0a&chksm=cea24a29f9d5c33fa48f5a57de864cd9382a730578fb18d78b7f06b45504aede18b235b9bc9e&token=1082669959&lang=zh_CN#rd)（2018-08-04）\n- [结束了我短暂的秋招，说点自己的感受](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484842&idx=1&sn=4489dfab0ef2479122b71407855afc71&chksm=cea24a61f9d5c3774a8ed67c5fcc3234cb0741fbe831152986e5d1c8fb4f36a003f4fb2f247e&token=1082669959&lang=zh_CN#rd)（2018-10-22）\n- [【周日闲谈】最近想说的几件小事](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484818&idx=1&sn=e14b0a08537456eb15ba49cf5e70ff74&chksm=cea24a59f9d5c34fe0a9e0567d867b85a81d1f19b0ea8e6a3c14161e436508de9adfeb2a5e6a&token=1082669959&lang=zh_CN#rd)(2018-11-18)\n- [做公众号这一年的经历和一件“大事”](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484746&idx=1&sn=a519a9e3d638bff5c65008f7de167e4b&chksm=cea24a81f9d5c397ca9ac5668ba6cb18b38065e0e282a34ebc077a2dea98de3f1eb285ea5f09&token=1082669959&lang=zh_CN#rd)(2019-03-10)\n- [几经周折，公众号终于留言功能啦！](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485007&idx=1&sn=096a436cd6a9251c23b8effc3cfa5076&chksm=cea24984f9d5c092d1f7740d1c3e0ea347562ba0aa597507ce275c5bdf1c8bd608328ee756ba&token=1082669959&lang=zh_CN#rd)(2019-03-15)\n- [写在毕业季的大学总结！细数一下大学干过的“傻事”。](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485358&idx=1&sn=3aaf1163fe13351e06c76b70f2bd33bd&chksm=cea24865f9d5c1735b51c707c8f5ade16af7eca304540205ab0fb1284f99034d418b9858d7db&token=1667678311&lang=zh_CN#rd) (2019-06-11)\n- [入职一个月的职场小白,谈谈自己这段时间的感受](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485540&idx=1&sn=4492eece8f7738e99350118040e14a79&chksm=cea247aff9d5ceb9e7c67f418d8a8518c550fd7dd269bf2c9bdef83309502273b4b9f1e7021f&token=1333232257&lang=zh_CN&scene=21#wechat_redirect)\n\n## 其他好文推荐\n\n- [谈恋爱也要懂https](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484821&idx=1&sn=e6ce4ec607a6c9b20edbd64fbeb0f6c5&chksm=cea24a5ef9d5c3480d3de284fc1038b51c2464152e25a350960efd81acd21f71d7e0eeb78c77&token=1082669959&lang=zh_CN#rd)\n- [快速入门大厂后端面试必备的 Shell 编程](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484810&idx=1&sn=0b622ae617b863ef1cc3a32c17b8b755&chksm=cea24a41f9d5c357199073c1e4692b7da7dcbd1809cf634a6cfec8c64c12250efc5274992f06&token=1082669959&lang=zh_CN#rd)\n- [为什么阿里巴巴禁止工程师直接使用日志系统(Log4j、Logback)中的 API](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484808&idx=1&sn=4774ecc18069e4ddc85f68877cff1ae3&chksm=cea24a43f9d5c35520a454d51e72c6084d38f505969835011f4dd36f76c78303af46780802c9&token=1082669959&lang=zh_CN#rd)\n- [一文搞懂 RabbitMQ 的重要概念以及安装](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484792&idx=1&sn=d34fdbb6cb21c231361038a7317ac2a4&chksm=cea24ab3f9d5c3a5c742de10cd0f7c77425b2144c86d2515d3e5d2011f4d16af12110c2de986&token=1082669959&lang=zh_CN#rd)\n- [漫话：如何给女朋友解释什么是RPC](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484795&idx=1&sn=64eb2dcac07cf6904ca79b14f408df9e&chksm=cea24ab0f9d5c3a6970c3fbbdcaa16d5230b51abed9bacd1cd2ea3192cccea4aba0ef2d1a9de&token=1082669959&lang=zh_CN#rd)\n- [Java人才市场年度盘点：转折与终局](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484779&idx=1&sn=a930b09a1783bca68e927cbe7d7a54a6&chksm=cea24aa0f9d5c3b6864ab3585a4cc5de1fa89ffc07538f2c55382776bfee0c369d7d74af7c79&token=1082669959&lang=zh_CN#rd)\n- [Github 上日获 800多 star 的阿里微服务架构分布式事务解决方案 FESCAR开源啦](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484776&idx=2&sn=bcd1cf6d72653bfff83724f1dbae0425&chksm=cea24aa3f9d5c3b5e9667f1e15f295d323efb3b2c8da6c9059f5e8b5e176b9cb1bf80cd1a78f&token=1082669959&lang=zh_CN#rd)\n- [Cloud Toolkit新版本发布，开发效率 “biu” 起来了](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484771&idx=2&sn=0eef929baacca950099ea8651f0e5cb2&chksm=cea24aa8f9d5c3bed5f359e6da981ac950dca8f31a93f1fe321d7de7908d843855604e79a4da&token=1082669959&lang=zh_CN#rd)\n- [我觉得技术人员该有的提问方式](https://mp.weixin.qq.com/s/eTEah5WOdfC3EAPbhpOKBA)"},"83b6":function(n,r,e){"use strict";e.r(r),r["default"]="# 《面试八股文》之网络19卷\r\n1.TCP/IP 网络模型有几层？分别有什么用？\r\n2.介绍一下 HTTP 协议吧\r\n3.GET 和 POST有什么区别？\r\n4.PING 的作用？\r\n5.常见的 HTTP 状态码有哪些\r\n6.HTTP1.1 和 HTTP1.0 的区别有哪些？\r\n7.HTTPS 和 HTTP 的区别是什么？\r\n8.HTTP2 和 HTTP1.1 的区别是什么？\r\n9.HTTP3 和 HTTP2 的区别是什么？\r\n10.TCP 建立连接的过程是怎样的？\r\n11.为什么是三次握手？？？\r\n12.TCP 断开连接的过程是怎样的？\r\n13.第四次挥手为什么要等待2MSL(60s)\r\n14.为什么是四次挥手？\r\n15.TCP 滑动窗⼝是什么？\r\n16.发送方一直发送数据，但是接收方处理不过来怎么办？（流量控制）\r\n17.TCP 半连接队列和全连接队列是什么？\r\n18.粘包/拆包是怎么发生的？怎么解决这个问题？\r\n19.浏览器地址栏输入网站按回车后发生了什么？\r\n------\r\n## **1.TCP/IP 网络模型有几层？分别有什么用？**\r\n![img](《面试八股文》之网络19卷.assets/wps379E.tmp.png) \r\nTCP/IP网络模型总共有**五层**\r\n**1.应用层**:我们能接触到的就是应用层了，手机，电脑这些这些设备都属于应用层。\r\n**2.传输层**:就是**为应用层提供网络支持**的，当设备作为接收⽅时，传输层则要负责把数据包传给应⽤，但是⼀台设备上可能会有很多应⽤在接收或者传输数据，因此需要⽤⼀个编号将应⽤区分开来，这个编号就是**端⼝**。所以 **TCP 和 UDP 协议就是在这一层的**\r\n**3.网络层**:是**负责传输数据的**，最常使用的 ip 协议就在该层，⽹络层负责将数据从⼀个设备传输到另⼀个设备，世界上有很多设备，⽹络层需要有区分设备的编号。我们⼀般⽤ **IP 地址**给设备进⾏编号\r\n**4.数据链路层**:每⼀台设备的⽹卡都会有⼀个 MAC 地址，它就是⽤来唯⼀标识设备的。路由器计算出了下⼀个⽬的地 IP 地址，再通过 ARP 协议找到该⽬的地的 MAC 地址，这样就知道这个 IP 地址是哪个设备的了。路由器就是通过数据链路层来知道这个 ip 地址是属于哪个设备的，它主要**为⽹络层提供链路级别传输的服务**。\r\n**5.物理层**:当数据准备要从设备发送到⽹络的时候，需要把数据包转换成电信号，让其可以在物理介质中传输，它**主要是为数据链路层提供⼆进制传输的服务**。\r\n## **2.介绍一下 HTTP 协议吧**\r\n![img](《面试八股文》之网络19卷.assets/wps379F.tmp.png) \r\nHTTP 协议是**基于 TCP 协议**实现的，它是一个**超文本传输协议**，其实就是一个简单的请求-响应协议，它**指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应**。\r\n它主要是**负责点对点之间通信**的。\r\n**超文本**就是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本。比如说html，内部定义了很多图片视频的链接，放在浏览器上就呈现出了画面。\r\n**协议**就是约定俗称的东西，比如说 moon 要给读者送一本书，读者那里只接受顺丰快递，那么 moon 觉得可以，发快递的时候选择的顺丰，那么我们彼此之间共同约定好的就叫做协议。\r\n**传输**这个就很好理解了，比如刚才举的例子，将书发给读者，要通过骑车或者飞机的方式，传递的这个过程就是运输。\r\n## **3.GET 和 POST有什么区别？**\r\n**GET 和 POST 本质上就是 TCP 链接，并无差别。**\r\n**但是由于 HTTP 的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。**\r\n| **区别**   | **GET**                                                | **POST**                                     |\r\n| ---------------- | ------------------------------------------------------------ | -------------------------------------------------- |\r\n| 数据传输方式     | 从服务器获取数据                                             | 向服务器提交数据                                   |\r\n| 对数据长度的限制 | 当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符） | 无限制                                             |\r\n| 对数据类型的限制 | 只允许 ASCII 字符                                            | 无限制                                             |\r\n| 安全性           | 较差，所发送的数据是 URL 的一部分，会显示在网页上            | 较好 参数不会被保存在浏览器历史或 WEB 服务器日志中 |\r\n| 可见性           | 显示在 URL 上                                                | 不显示                                             |\r\n| 收藏为书签       | 可以                                                         | 不可以                                             |\r\n| 历史记录         | 可以被保留在历史记录当中                                     | 不可以被保留                                       |\r\n| 缓存             | 能被缓存                                                     | 不可以被缓存                                       |\r\n## **4.PING 的作用？**\r\nPING 主要的作用就是**测试在两台主机之间能否建立连接**，如果 PING 不通就无法建立连接。\r\n它其实就是向目的主机发送多个 ICMP 回送请求报文\r\n· 如果没有响应则无法建立连接\r\n· 如果有响应就可以根据目的主机返回的回送报文的时间和成功响应的次数估算出数据包**往返时间及丢包率**\r\n## **5.常见的 HTTP 状态码有哪些**\r\n| **1xx** | **信息，服务器收到请求，需要请求者继续执行操作** |\r\n| ------------- | ------------------------------------------------------ |\r\n| 2xx           | 成功，操作被成功接收并处理                             |\r\n| 3xx           | 重定向，需要进一步的操作以完成请求                     |\r\n| 4xx           | 客户端错误，请求包含语法错误或无法完成请求             |\r\n| 5xx           | 服务器错误，服务器在处理请求的过程中发生了错误         |\r\n## **6.HTTP1.1 和 HTTP1.0 的区别有哪些？**\r\n![img](《面试八股文》之网络19卷.assets/wps37A0.tmp.png) \r\n· 1.**长链接**\r\n§ 早期 HTTP1.0 的每一次请求都伴随着一次三次握手的过程，并且是**串行的请求**，增加了不必要的性能开销\r\n§ HTTP1.1 **新增了长链接**的通讯方式，减少了性能损耗\r\n· 2.**管道**\r\n§ HTTP1.0 只有串行发送，没有管道\r\n§ HTTP1.1 增加了**管道**的概念，使得在同一个 TCP 链接当中可以同时发出多个请求\r\n· 3.**断点续传**\r\n§ HTTP1.0 **不支持断点续传**\r\n§ HTTP1.1 新增了 **range** 字段，用来指定数据字节位置，开启了断点续传的时代\r\n· 4.**Host头处理**\r\n§ HTTP1.0 任务主机只有一个节点，所以并**没有传 HOST**\r\n§ HTTP1.1 时代，虚拟机技术越来越发达，一台机器上也有可能有很多节点，故**增加了 HOST 信息**\r\n· 5.**缓存处理**\r\n§ 在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准\r\n§ HTTP1.1则**引入了更多的缓存控制策略**例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。\r\n· 6.**错误状态响应码**\r\n§ 在HTTP1.1中**新增了24个错误状态响应码**，如410（Gone）表示服务器上的某个资源被永久性的删除等。\r\n## **7.HTTPS 和 HTTP 的区别是什么？**\r\n![img](《面试八股文》之网络19卷.assets/wps37A1.tmp.png) \r\n· 1.**SSL安全协议**\r\n§ HTTP 是超⽂本传输协议，信息是**明⽂传输**，存在安全⻛险的问题。\r\n§ HTTPS 则解决 HTTP 不安全的缺陷，在TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS 安全协议，使得报⽂能够**加密传输**。\r\n· 2.**建立连接**\r\n§ HTTP 连接建⽴相对简单， TCP **三次握⼿**之后便可进⾏ HTTP 的报⽂传输。\r\n§ HTTPS 在 TCP **三次握⼿**之后，还需进⾏ **SSL/TLS** 的**握⼿**过程，才可进⼊加密报⽂传输。\r\n· 3.**端口号**\r\n§ HTTP 的端⼝号是 **80**。\r\n§ HTTPS 的端⼝号是 **443**。\r\n· 4.**CA证书**\r\n§ **HTTPS 协议需要向 CA（证书权威。机构）申请数字证书**来保证服务器的身份是可信的。\r\n## **8.HTTP2 和 HTTP1.1 的区别是什么？**\r\n![img](《面试八股文》之网络19卷.assets/wps37B1.tmp.png) \r\n1.**头部压缩**\r\n§ 在 HTTP2 当中，如果你发出了**多个请求**，并且它们的**头部(header)是相同的**，那么 HTTP2 协议会帮你**消除同样的部分**。(其实就是在客户端和服务端维护一张索引表来实现)\r\n2.**二进制格式**\r\n§ HTTP1.1 采用**明文**的形式\r\n§ HTTP/2 全⾯采⽤了**⼆进制格式**，头信息和数据体都是⼆进制\r\n3.**数据流**\r\n§ HTTP/2 的数据包不是按顺序发送的，同⼀个连接⾥⾯连续的数据包，可能属于不同的回应。(对数据包做了标记，标志其属于哪一个请求，其中规定客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数。**客户端还可以指定数据流的优先级**，优先级⾼的请求，服务器就先响应该请求)\r\n4.**IO多路复用**\r\n§ 如:在⼀个连接中，服务器收到了客户端 A 和 B 的两个请求，但是发现在处理 A 的过程中⾮常耗时，索性就先回应 A 已经处理好的部分，再接着回应 B 请求，最后再回应 A 请求剩下的部分。\r\n§ HTTP/2 可以**在⼀个连接中并发多个请求或回应**。\r\n5.**服务器推送**\r\n§ 服务器可以主动向客户端发送请求\r\n## **9.HTTP3 和 HTTP2 的区别是什么？**\r\n![img](《面试八股文》之网络19卷.assets/wps37B2.tmp.png) \r\n· 1.**协议不同**\r\n§ HTTP2 是基于 **TCP** 协议实现的\r\n§ HTTP3 是基于 **UDP** 协议实现的\r\n· 2.**QUIC**\r\n§ **HTTP3 新增了 QUIC 协议**来实现可靠性的传输\r\n· 3.**握手次数**\r\n§ HTTP2 是基于 HTTPS 实现的，建立连接需要先进行 TCP 3次握手，然后再进行 TLS 3次握手，**总共6次握手**\r\n§ HTTP3 只需要 QUIC 的**3次握手**\r\n## **10.TCP 建立连接的过程是怎样的？**\r\n![img](《面试八股文》之网络19卷.assets/wps37B3.tmp.png) \r\n第一次握手:A 的 TCP 进程创建一个 传输控制块 TCB ，然后向 B 发出连接请求报文段。之后将同步位 **SYN 设置为 1**，同时选择一个初始序列号 **seq=x**，这时客户端 A 进入到 **SYN-SENT（同步已发送**）状态。\r\n第二次握手:B 收到连接请求报文段，如果同意建立连接，则向 A 发送确认。在确认报文段中 **同步位 SYN=1、确认位 ACK=1、确认号 ack=x+1**，同时也为自己选择一个初始序列号 **seq=y**，这时服务器 B 进入 SYN-RCVID 状态。\r\n第三次握手:A 收到 B 的确认以后，再向 B 发出确认。确认报文 **ACK=1、确认号ack=y+1**。这时A进入到 ESTAB-LISHED 状态。**当B接收到A的确认后，也进入 ESTAB-LISHED 状态。连接建立完成**\r\n## **11.为什么是三次握手？？？**\r\n![img](《面试八股文》之网络19卷.assets/wps37B4.tmp.png) \r\n· 1.为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误\r\n§ 如果客户端连续发送多次 SYN 建⽴连接的报⽂，如果出现了**网络拥堵**，可能会有**旧连接先于新连接到达**的情况，就可能会出现**连接覆盖**，要避免这种情况，最少需要三次握手\r\n· 2.三次握⼿正好避免资源浪费\r\n§ 三次握⼿就已经是理论上**建立可靠连接的最小次数**了，所以不需要更多的连接\r\n· 3.同步双⽅初始序列号\r\n§ 同步序列号(可以鉴别重复数序，按序接受等)其实并不要三次握手，只要一来一回两次就可以了\r\n## **12.TCP 断开连接的过程是怎样的？**\r\n![img](《面试八股文》之网络19卷.assets/wps37B5.tmp.png) \r\n第一次挥手:A 先发送连接释放报文段，段首部的终止控制位 **FIN=1**，序号**seq=u**（等于**A前面发送数据的最后一个序号加1**）；然后 A 进入 FIN-WAIT-1（终止等待1）状态，等待 B 的确认。\r\n第二次挥手:B 收到 A 的连接释放报文段后，立刻发出确认报文段，确认号 **ack=u+1**，序号 **seq=v**（等于 **B 前面发送数据的最后一个序号加1**）；然后 B 进入 CLOSE-WAIT（关闭等待）状态。\r\n第三次挥手:A 收到 B 的确认报文段后进入到 FIN-WAIT-2（终止等待2）状态，继续等待 B 发出连接释放报文段；\r\n§ 若 B 已经没有数据要发送，B 就会向 A 发送连接释放报文段，段首部的终止控制位 **FIN=1**，序号 **seq=w**（半关闭状态可能又发送了一些数据），确认号 **ack=u+1**，这时B进入 **LAST-ACK**（最后确认）状态，等待A的确认。\r\n第四次挥手:A收到B的连接释放报文段并发出确认，确认段中 确认位 **ACK=1**，确认号 **ack=w+1**，序号 **seq=u+1**；然后 A 进入到**TIME-WAIT**（时间等待）状态。当 B 再接收到该确认段后，B 就进入 **CLOSED** 状态。\r\n## **13.第四次挥手为什么要等待2MSL(60s)**\r\n![img](《面试八股文》之网络19卷.assets/wps37B6.tmp.png) \r\n首先 2MSL 的时间是从客户端(A)接收到 **FIN 后发送 ACK 开始计时**的。如果**在 TIME-WAIT 时间内**，因为客户端(A)的 ACK **没有传输**到服务端(B)，客户端(A)又接收到了服务端(B)重发的 FIN 报文，那么 2MSL **时间会被重置**。等待 2MSL 原因如下\r\n· 1.**得原来连接的数据包消失**\r\n§ 1）如果B没有收到自己的ACK，会超时重传FiN那么A再次接到重传的FIN，会再次发送ACK\r\n§ 2）如果B收到自己的ACK，也不会再发任何消息，\r\n§ 在最后一次挥手后 A 并不知道 B 是否接到自己的 信息\r\n包括 ACK 是以上哪两种情况，A 都需要等待，要取这两种情况等待时间的最大值，以应对最坏的情况发生，这个最坏情况是：去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)。这刚好是2MSL，这个时间，足以**使得原来连接的数据包在网络中消失**。\r\n· 2.**保证 ACK 能被服务端接收到从而正确关闭链接**\r\n§ 因为这个 ACK 是有可能丢失的，会导致服务器收不到对 FIN-ACK 确认报文。假设客户端不等待 2MSL ，而是在发送完 ACK 之后直接释放关闭，一但这个 ACK 丢失的话，服务器就**无法正常的进入关闭连接状态**。\r\n## **14.为什么是四次挥手？**\r\n![img](《面试八股文》之网络19卷.assets/wps37C7.tmp.png) \r\n因为 tcp 可以在发送数据的同时也能接受数据，要实现可靠的连接关闭，A 发出结束报文 FIN，收到 B 确认后 A 知道自己没有数据需要发送了，B 知道 A 不再发送数据了，自己也不会接收数据了，**但是此时 A 还是可以接收数据，B 也可以发送数据**；当 B 发出 FIN 报文的时候此时两边才会真正的断开连接，读写分开。\r\n## **15.TCP 滑动窗⼝是什么？**\r\n![img](《面试八股文》之网络19卷.assets/wps37C8.tmp.png) \r\nTCP 是**每发送⼀个数据，都要进⾏⼀次确认应答**。只有上一个收到了回应才发送下一个，这样**效率会非常低**，因此**引进了滑动窗口**的概念.\r\n其实就是在发送方**设立一个缓存区间**，将已发送但未收到确认的消息**缓存**起来，**假如一个窗口可以发送 5 个 TCP 段**，那么发送方就可以连续发送 5 个 TCP 段，然后就会将这 5 个 TCP 段的数据缓存起来，这 5 个 TCP 段是有序的，只要后面的消息收到了 ACK ，那么不管前面的是否有收到 ACK,都代表成功，**窗⼝⼤⼩是由接收方决定的**。\r\n窗⼝⼤⼩就是指**不需要等待应答，还可以发送数据的大小**。\r\n## **16.发送方一直发送数据，但是接收方处理不过来怎么办？（流量控制）**\r\n如果接收方处理不过来，发送方就会触发重试机制再次发送数据，然而这个是有性能损耗的，为了解决这个问题，TCP 就提出了流量控制，为的就是**让发送方知道接受方的处理能力**。\r\n也就是说，每次接收方接受到数据后会**将剩余可处理数据的大小告诉发送方**。\r\n比如接受方滑动窗口可用大小为400字节，发送方发送过来100字节的数据，那么接收方剩余可用滑动窗口大小就为300字节，这是发送方就知道下次返送数据的大小范围了。\r\n但是这里有一个问题，数据会存放在缓冲区，但是这个**缓冲区是操作系统控制的，当系统繁忙的时候，会缩减缓冲区减小，可能就会造成丢包的问题**。\r\n![img](《面试八股文》之网络19卷.assets/wps37C9.tmp.png) \r\n如: 发送方接收方窗口大小各为200字节，发送方发送100字节的给接收方，此时双方各剩100字节，但是此时操作系统非常忙，将接收方的缓存区减少了50字节，这时接收方就会告诉发送方，我还有50字节可用，但是在接收方发送到达之前，发送方是不知道的，只会看到自己还有100字节可用，那么就继续发送数据，如果发送了80字节数据，那么接收方缓存区大小为50字节，就会丢失30字节的数据，也就是会发生丢包现象。\r\n我们会发现，这个问题发生的原因就是减少了缓存，又收缩了窗口大小，所以 TCP 是**不允许同时减少缓存⼜收缩窗⼝**的。\r\n## **17.TCP 半连接队列和全连接队列是什么？**\r\n![img](《面试八股文》之网络19卷.assets/wps37CA.tmp.png) \r\n服务端收到客户端发出的 SYN 请求后，会把这个连接信息存储到**半链接队列(SYN 队列)**。\r\n服务端收到第三次握⼿的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到**全连接队列**(accept 队列)，等待进程调⽤ accept 函数时把连接取出来。\r\n这两个队列都是有大小限制的，当超过容量后就会将链接丢弃，或者返回 RST 包。\r\n## **18.粘包/拆包是怎么发生的？怎么解决这个问题？**\r\nTCP 发送数据时会根据 TCP 缓冲区的实际情况进行包的划分，一个完整的包**可能会被 TCP 拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送**，这就是 TCP 粘包和拆包问题。\r\n![img](《面试八股文》之网络19卷.assets/wps37CB.tmp.png) \r\n发生 TCP **粘包**的**原因**:\r\n· 1.**发送的数据小于 TCP 缓冲区大小**，TCP将缓冲区中的数据(数据属于多条业务内容)一次发送出去可能就会发生粘包。\r\n· 2.接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。\r\n发生 TCP **拆包**的**原因**:\r\n· 1.**待发送数据大于最大报文长度**，TCP 在传输前将进行拆包。\r\n· 2.**发送的数据大于 TCP 发送缓冲区剩余空间大小**，将会发生拆包。\r\n**解决方案**:\r\n![img](《面试八股文》之网络19卷.assets/wps37CC.tmp.png) \r\n1.**发送端给每个数据包添加包首部**，首部中包含数据包的长度，这样接收端在接收到数据后，通过该字段就可以知道每个数据包的实际长度了。\r\n2.发送端将每个数据包**设置固定长度**，这样接收端每次从读取固定长度的数据把每个数据包拆分开。\r\n3.可以在数据包之间**设置边界**，如添加特殊符号，接收端可以通过这个特殊符号来拆分包。\r\n## **19.浏览器地址栏输入网站按回车后发生了什么？**\r\n![img](《面试八股文》之网络19卷.assets/wps37DD.tmp.png) \r\n· 1:**解析网址**,生成 HTTP 请求信息\r\n· 2:根据 DNS 服务器**查询真实请求的 IP 地址**，如果本地服务器有缓存则直接返回\r\n· 3:得到了 IP 以后，向服务器**发送 TCP 连接**，TCP 连接经过三次握手。\r\n· 4:接受 TCP 报文后，对**连接进行处理**，对 HTTP 协议解析\r\n· 5:服务器**返回响应**\r\n· **6:浏览器**接受响应，显示页面，渲染页面**\r\n"},"8c64":function(n,r,e){"use strict";e.r(r),r["default"]='# 《面试八股文》之Dubbo17卷\r\n\r\n**目录**\r\n\r\n1.Dubbo是什么？RPC又是什么？\r\n2.Dubbo能做什么？\r\n3.能说下Dubbo的总体的调用过程吗？\r\n4.说说Dubbo 支持哪些协议，每种协议的应用场景和优缺点\r\n5.Dubbo中都用到哪些设计模式？\r\n6.如果Dubbo中provider提供的服务由多个版本怎么办？\r\n7.服务暴露的流程是怎么样的？\r\n8.服务引用的流程是怎么样的？\r\n9.Dubbo的注册中心有哪些？\r\n10.聊聊Dubbo SPI机制？\r\n11.Dubbo的SPi和JAVA的SPI有什么区别？\r\n12.有哪些负载均衡策略？\r\n13.集群容错方式有哪些？\r\n14.说说Dubbo的分层？\r\n15.服务提供者能实现失效踢出是什么原理？\r\n16.为什么要通过代理对象通信？？\r\n17.怎么设计一个RPC框架？\r\n------\r\n## **1.Dubbo是什么？RPC又是什么？**\r\n**Dubbo是一个分布式服务框架**，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。\r\n**RPC（Remote Procedure Call）**—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底>层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络>通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发>送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为>止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户>端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。有多种 RPC模式和执行。\r\n![img](《面试八股文》之Dubbo17卷.assets/wpsE4F9.tmp.png) \r\n我们用一种通俗易懂的语言解释它，**远程调用就是本地机器调用远程机器的一个方法，远程机器返回结果的过程**。\r\n**为什么要这么做？**\r\n主要原因是由于单台服务的性能已经无法满足我们了，在这个流量剧增的时代，只有**多台服务器**才能支撑起来现有的用户体系，\r\n而在这种体系下，服务越来越多，逐渐演化出了现在这种微服务化的RPC框架。\r\n------\r\n## **2. Dubbo能做什么？**\r\nDubbo的核心功能主要包含:\r\n![img](《面试八股文》之Dubbo17卷.assets/wpsE4FA.tmp.png) \r\n1. **远程通讯:dubbo-remoting**模块， 提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。\r\n1. **集群容错**: 提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。\r\n1. **自动发现**: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。\r\n------\r\n## **3.能说下Dubbo的总体的调用过程吗？**\r\n调用过程图：\r\n![img](《面试八股文》之Dubbo17卷.assets/wpsE50A.tmp.png) \r\n· 1.Proxy持有一个Invoker对象，**使用Invoker调用**\r\n· 2.之后通过**Cluster进行负载容错**，失败重试\r\n· 3.调用Directory**获取远程服务的Invoker**列表\r\n· 4.负载均衡\r\n§ 用户**配置了路由规则**，则根据路由规则过滤获取到的Invoker列表\r\n§ 用户没**有配置路由规则或配置路由后还有很多节点**，则使用LoadBalance方法做负载均衡，选用一个可以调用的Invoker\r\n· 5.**经过一个一个过滤器链**，通常是处理上下文、限流、计数等。\r\n· 6.会**使用Client做数据传输**\r\n· 7.**私有化协议的构造**(Codec)\r\n· 8.进行**序列化**\r\n· 9.服务端收到这个Request请求，将其**分配到ThreadPool**中进行处理\r\n· 10.**Server来处理这些Request**\r\n· 11.根据**请求查找对应的Exporter**\r\n· 12.之后**经过**一个服务提供者端的**过滤器链**\r\n· 13.然后找到接口实现并**真正的调用**，将请求结果返回\r\n------\r\n## **4.说说Dubbo 支持哪些协议，每种协议的应用场景和优缺点**\r\n![img](《面试八股文》之Dubbo17卷.assets/wpsE50B.tmp.png) \r\n· \r\n**1.dubbo** 单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议 TCP，异步，Hessian 序列化\r\n**2.rmi** 采用 JDK 标准的 rmi 协议实现，传输参数和返回参数对象需要实现Serializable 接口，使用 java 标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议 TCP。多个短连接，TCP 协议传输，同步传输，适用常规的远程服务调用和 rmi 互 操作。在依赖低版本的 Common-Collections 包，java 序列化存在安全漏洞\r\n**3.webservice** 基于 WebService 的远程调用协议，集成 CXF 实现，提供和原生 WebService 的互操作。多个短连接，基于 HTTP 传输，同步传输，适用系统集成和跨语言调用；\r\n**4.http** 基于 Http 表单提交的远程调用协议，使用 Spring 的 HttpInvoke 实 现。多个短连接，传输协议 HTTP，传入参数大小混合，提供者个数多于消 费者，需要给应用程序和浏览器 JS 调用\r\n**5.hessian** 集成 Hessian 服务，基于 HTTP 通讯，采用 Servlet 暴露服务，Dubbo 内嵌 Jetty 作为服务器时默认实现，提供与 Hession 服务互操作。多个短连接，同步 HTTP 传输，Hessian 序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件；\r\n**6.memcache** 基于 memcached 实现的 RPC 协议\r\n**7.redis** 基于 redis 实现的 RPC 协议\r\n· \r\n------\r\n## **5.Dubbo中都用到哪些设计模式？**\r\n![img](《面试八股文》之Dubbo17卷.assets/wpsE50C.tmp.png) \r\n**责任链模式**:\r\n责任链模式在Dubbo中发挥的作用举足轻重，就像是Dubbo框架的骨架。Dubbo的调用链组织是用责任链模式串连起来的。责任链中的每个节点实现Filter接口，然后由ProtocolFilterWrapper，将所有Filter串连起来。Dubbo的许多功能都是通过Filter扩展实现的，比如监控、日志、缓存、安全、telnet以及RPC本身都是。\r\n**观察者模式**:\r\nDubbo中使用观察者模式最典型的例子是RegistryService。消费者在初始化的时候回调用subscribe方法，注册一个观察者，如果观察者引用的服务地址列表发生改变，就会通过NotifyListener通知消费者。此外，Dubbo的InvokerListener、ExporterListener 也实现了观察者模式，只要实现该接口，并注册，就可以接收到consumer端调用refer和provider端调用export的通知。\r\n**修饰器模式**:\r\nDubbo中还大量用到了修饰器模式。比如ProtocolFilterWrapper类是对Protocol类的修饰。在export和refer方法中，配合责任链模式，把Filter组装成责任链，实现对Protocol功能的修饰。其他还有ProtocolListenerWrapper、 ListenerInvokerWrapper、InvokerWrapper等。\r\n**工厂方法模式**:\r\nCacheFactory的实现采用的是工厂方法模式。CacheFactory接口定义getCache方法，然后定义一个AbstractCacheFactory抽象类实现CacheFactory，并将实际创建cache的createCache方法分离出来，并设置为抽象方法。这样具体cache的创建工作就留给具体的子类去完成。\r\n**抽象工厂模式**:\r\nProxyFactory及其子类是Dubbo中使用抽象工厂模式的典型例子。ProxyFactory提供两个方法，分别用来生产Proxy和Invoker（这两个方法签名看起来有些矛盾，因为getProxy方法需要传入一个Invoker对象，而getInvoker方法需要传入一个Proxy对象，看起来会形成循环依赖，但其实两个方式使用的场景不一样）。AbstractProxyFactory实现了ProxyFactory接口，作为具体实现类的抽象父类。然后定义了JdkProxyFactory和JavassistProxyFactory两个具体类，分别用来生产基于jdk代理机制和基于javassist代理机制的Proxy和Invoker。\r\n**适配器模式**:\r\n为了让用户根据自己的需求选择日志组件，Dubbo自定义了自己的Logger接口，并为常见的日志组件（包括jcl, jdk, log4j, slf4j）提供相应的适配器。并且利用简单工厂模式提供一个LoggerFactory，客户可以创建抽象的Dubbo自定义Logger，而无需关心实际使用的日志组件类型。在LoggerFactory初始化时，客户通过设置系统变量的方式选择自己所用的日志组件，这样提供了很大的灵活性。\r\n**代理模式**:\r\nDubbo consumer使用Proxy类创建远程服务的本地代理，本地代理实现和远程服务一样的接口，并且屏蔽了网络通信的细节，使得用户在使用本地代理的时候，感觉和使用本地服务一样。\r\n------\r\n## **6.如果Dubbo中provider提供的服务由多个版本怎么办？**\r\n可以直接通过Dubbo配置中的version版本来控制多个版本即可。\r\n比如：\r\n<dubbo:service interface="com.xxxx.rent.service.IDemoService" ref="iDemoServiceFirst" version="1.0.0"/>\r\n<dubbo:service interface="com.xxxx.rent.service.IDemoService" ref="iDemoServiceSecond" version="1.0.1"/>\r\n老版本 version=1.0.0, 新版本version=1.0.1\r\n------\r\n## **7.服务暴露的流程是怎么样的？**\r\n![img](《面试八股文》之Dubbo17卷.assets/wpsE50D.tmp.png) \r\n1.通过ServiceConfig解析标签，创建dubbo标签解析器来**解析dubbo的标签**，容器创建完成之后，**触发ContextRefreshEvent事件回调开始暴露服务**\r\n2.通过proxyFactory.getInvoker方法，并利用**javassist或DdkProxyFactory来进行动态代理**，将服务暴露接口**封装成invoke**r对象，里面包含了需要执行的方法的对象信息和具体的URL地址。\r\n3.再通过DubboProtocol的实现把包装后的**invoker转换成exporter**，\r\n4.然后**启动服务器server**，监听端口\r\n5.最后RegistryProtocol保存URL地址和invoker的映射关系，同时**注册到服务中心**\r\n![img](《面试八股文》之Dubbo17卷.assets/wpsE50E.tmp.png) \r\n------\r\n## **8.服务引用的流程是怎么样的？**\r\n1.首先客户端根据config文件信息从注册中心**订阅服务**，首次会全量**缓存到本地**，后续的更新会监听动态更新到本地。\r\n2.之后DubboProtocol**根据provider**的地址和接口信息**连接到服务端**server，**开启客户端clien**t，然后创建invoker\r\n3.之后通过invoker为服务接口**生成代理对象**，这个代理对象用于远程调用provider，至此完成了服务引用\r\n![img](《面试八股文》之Dubbo17卷.assets/wpsE50F.tmp.png) \r\n------\r\n## **9.Dubbo的注册中心有哪些？**\r\n![img](《面试八股文》之Dubbo17卷.assets/wpsE510.tmp.png) \r\nZookeeper、Redis、Multicast、Simple 等都可以作为Dubbo的注册中心\r\n------\r\n## **10.聊聊Dubbo SPI机制？**\r\nSPI(Service Provider Interface)，是一种**服务发现机制**，其实就是将结构的实现类写入配置当中，在服务加载的时候将配置文件独处，加载实现类，这样就可以在运行的时候，**动态的帮助接口替换实现类**。\r\nDubbo的SPI其实是对java的SPI进行了一种增强,可以按需加载实现类之外，增加了 IOC 和 AOP 的特性，还有**自适应扩展**机制。\r\nSPI在dubbo应用很多，包括协议扩展、集群扩展、路由扩展、序列化扩展等等。\r\nDubbo对于文件目录的配置分为了**三类**。\r\n· 1.META-INF/services/ 目录：该目录下的 SPI 配置文件是为了用来兼容 Java SPI 。\r\n· 2.META-INF/dubbo/ 目录：该目录存放用户自定义的 SPI 配置文件。\r\nkey=com.xxx.xxx\r\n· 3.META-INF/dubbo/internal/ 目录：该目录存放 Dubbo 内部使用的 SPI 配置文件。\r\n------\r\n## **11.Dubbo的SPi和JAVA的SPI有什么区别？**\r\n![img](《面试八股文》之Dubbo17卷.assets/wpsE521.tmp.png) \r\n**Java Spi**\r\n· Java SPI 在查找扩展实现类的时候遍历 SPI 的配置文件并且将实现类**全部实例化**\r\n**Dubbo Spi**\r\n· 1，对 Dubbo 进行扩展，不需要改动 Dubbo 的源码\r\n· 2，延迟加载，可以一次**只加载自己想要加载的**扩展实现。\r\n· 3，增加了对扩展点 IOC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。\r\n· 4，Dubbo 的扩展机制能很好的支持第三方 IoC 容器，默认支持 Spring Bean。\r\n------\r\n## **12.有哪些负载均衡策略？**\r\n**1.加权随机**：比如我们有三台服务器[A, B, C]，给他们设置权重为[4, 5, 6]，然后讲这三个数平铺在水平线上,和为15。\r\n然后在15以内生成一个随机数，0～4是服务器A，4～9是服务器B，9～15是服务器C\r\n![img](《面试八股文》之Dubbo17卷.assets/wpsE522.tmp.png) \r\n**2.最小活跃数**：每个服务提供者对应一个活跃数 active，初始情况下，所有服务提供者活跃数均为0。每收到一个请求，活跃数加1，完成请求后则将活跃数减1。在服务运行一段时间后，性能好的服务提供者处理请求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求。\r\n![img](《面试八股文》之Dubbo17卷.assets/wpsE523.tmp.png) \r\n**3.一致性hash**：\r\n· 首先求出memcached服务器（节点）的哈希值，并将其配置到0～2的32次方的圆（continuum）上。\r\n· 然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。\r\n· 然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。如果超过2的32次方仍然找不到服务器，就会保存到第一台memcached服务器上。\r\n![img](《面试八股文》之Dubbo17卷.assets/wpsE524.tmp.png) \r\n**4.加权轮询**：比如我们有三台服务器[A, B, C]，给他们设置权重为[4, 5, 6]，那么假如总共有15次请求，那么会有4次落在A服务器，5次落在B服务器，6次落在C服务器。\r\n![img](《面试八股文》之Dubbo17卷.assets/wpsE525.tmp.png) \r\n------\r\n## **13.集群容错方式有哪些？**\r\n1.**Failover Cluster失败自动切换**：dubbo的默认容错方案，当调用失败时自动切换到其他可用的节点，具体的重试次数和间隔时间可用通过引用服务的时候配置，默认重试次数为1是只调用一次。\r\n2.**Failback Cluster失败自动恢复**：在调用失败，记录日志和调用信息，然后返回空结果给consumer，并且通过定时任务每隔5秒对失败的调用进行重试\r\n3.**Failfast Cluster快速失败**：只会调用一次，失败后立刻抛出异常\r\n4.**Failsafe Cluster失败安全**：调用出现异常，记录日志不抛出，返回空结果\r\n5.**Forking Cluster并行调用多个服务提供者**：通过线程池创建多个线程，并发调用多个provider，结果保存到阻塞队列，只要有一个provider成功返回了结果，就会立刻返回结果\r\n6.**Broadcast Cluster广播模式**：逐个调用每个provider，如果其中一台报错，在循环调用结束后，抛出异常。\r\n------\r\n## **14.说说Dubbo的分层？**\r\n分层图：\r\n![img](《面试八股文》之Dubbo17卷.assets/wpsE526.tmp.png)从大的范围来说，dubbo分为三层\r\n· **business**业务逻辑层由我们自己来提供接口和实现还有一些配置信息\r\n· **RPC**层就是真正的RPC调用的核心层，封装整个RPC的调用过程、负载均衡、集群容错、代理\r\n· **remoting**则是对网络传输协议和数据转换的封装。\r\nService和Config两层可以认为是**API**层，主要提供给**API使用者**，使用者只需要配置和完成业务代码就可以了。\r\n后面所有的层级是**SPI**层，主 要提供给扩展者使用主要是用来做**Dubbo的二次开发**扩展功能。\r\n再划分到更细的层面，就是图中的10层模式。\r\n------\r\n## **15.服务提供者能实现失效踢出是什么原理？**\r\n服务失效踢出基于**Zookeeper的临时节点**原理。\r\nZookeeper中节点是有生命周期的，具体的生命周期取决于节点的类型，节点主要分为**持久节点**(Persistent)和**临时节点**(Ephemeral) 。\r\n------\r\n## **16.为什么要通过代理对象通信？？**\r\n![img](《面试八股文》之Dubbo17卷.assets/wpsE527.tmp.png) \r\n其实主要就是为了将调用细节封装起来，将调用远程方法变得和调用本地方法一样简单，还可以做一些其他方面的增强，比如负载均衡，容错机制，过滤操作，调用数据的统计。\r\n------\r\n## **17.怎么设计一个RPC框架？**\r\n关于这个问题，其实核心考察点就是你**对于RPC框架的理解**，一个成熟的RPC框架**可以完成哪些功能**，其实当我们看过一两个RPC框架后，就可以对这个问题回答个七七八八了，我们来举个例子。\r\n![img](《面试八股文》之Dubbo17卷.assets/wpsE529.tmp.png) \r\n1.首先我们得需要一个**注册中心**，去管理消费者和提供者的节点信息，这样才会有消费者和提供才可以去订阅服务，注册服务。\r\n2.当有了注册中心后，可能会有很多个provider节点，那么我们肯定会有一个**负载均衡**模块来负责节点的调用，至于用户指定路由规则可以使一个额外的优化点。\r\n3.具体的调用肯定会需要牵扯到通信协议，所以需要一个模块来对**通信协议进行封装**，网络传输还要考虑序列化。\r\n4.当调用失败后怎么去处理？所以我们还需要一个**容错模块**，来负责失败情况的处理。\r\n5.其实做完这些一个基础的模型就已经搭建好了，我们还可以有更多的优化点，比如一些请求**数据的监控，配置信息的处理，日志信息的处理**等等。\r\n这其实就是一个比较基本的RPC框架的大体思路，大家有没有get到？\r\n'},"97a8":function(n,r,e){"use strict";e.r(r),r["default"]='# 《面试八股文》之 Java 基础 34 卷\r\n\r\n1.介绍一下 java 吧\r\n2.java 有哪些数据类型？\r\n3.接口和抽象类有什么区别？\r\n4.重载和重写什么区别？\r\n5.常见的异常有哪些？\r\n6.异常要怎么解决？\r\n7.arrayList 和 linkedList 的区别？\r\n8.hashMap 1.7 和 hashMap 1.8 的区别？\r\n9.hashMap 线程不安全体现在哪里？\r\n10.那么 hashMap 线程不安全怎么解决？\r\n11.concurrentHashMap 1.7 和 1.8 有什么区别\r\n12.介绍一下 hashset 吧\r\n13.什么是泛型？\r\n14.泛型擦除是什么？\r\n15.说说进程和线程的区别？\r\n16.volatile 有什么作用？\r\n17.什么是包装类？为什么需要包装类？\r\n18.Integer a = 1000，Integer b = 1000，a==b 的结果是什么？那如果 a，b 都为1，结果又是什么？\r\n19.JMM 是什么？\r\n20.创建对象有哪些方式\r\n21.讲讲单例模式懒汉式吧\r\n22.volatile 有什么作用\r\n23.怎么保证线程安全？\r\n24.synchronized 锁升级的过程\r\n25.cas 是什么？\r\n26.聊聊 ReentrantLock 吧\r\n27.多线程的创建方式有哪些？\r\n28.线程池有哪些参数？\r\n29.线程池的执行流程？\r\n30.线程池的拒绝策略有哪些？\r\n31.介绍一下四种引用类型?\r\n32.深拷贝、浅拷贝是什么？\r\n33.聊聊 ThreadLocal 吧\r\n34.一个对象的内存布局是怎么样的?\r\n------\r\n## **1.介绍一下 java 吧**\r\njava 是一门**「开源的跨平台的面向对象的」**计算机语言.\r\n![img](《面试八股文》之 Java 基础 34 卷.assets/wpsFE9.tmp.png) \r\n跨平台是因为 java 的 class 文件是运行在虚拟机上的,其实跨平台的,而**「虚拟机是不同平台有不同版本」**,所以说 java 是跨平台的.\r\n面向对象有几个特点:\r\n![img](《面试八股文》之 Java 基础 34 卷.assets/wpsFEA.tmp.png) \r\n\\1. 1.**「封装」**\r\n§ 两层含义：一层含义是把对象的属性和行为看成一个密不可分的整体，将这两者\'封装\'在一个不可分割的**「独立单元」**(即对象)中\r\n§ 另一层含义指\'信息隐藏，把不需要让外界知道的信息隐藏起来，有些对象的属性及行为允许外界用户知道或使用，但不允许更改，而另一些属性或行为，则不允许外界知晓，或只允许使用对象的功能，而尽可能**「隐藏对象的功能实现细节」**。\r\n**「优点」**:\r\n1.良好的封装能够**「减少耦合」**，符合程序设计追求\'高内聚，低耦合\'\r\n2.**「类内部的结构可以自由修改」**\r\n3.可以对成员变量进行更**「精确的控制」**\r\n4.**「隐藏信息」**实现细节\r\n\\1. 2.**「继承」**\r\n§ 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。\r\n**「优点」**:\r\n1.提高类代码的**「复用性」**\r\n2.提高了代码的**「维护性」**\r\n\\1. 3.**「多态」**\r\n§ 1.**「方法重载」**：在一个类中，允许多个方法使用同一个名字，但方法的参数不同，完成的功能也不同。\r\n§ 2.**「对象多态」**：子类对象可以与父类对象进行转换，而且根据其使用的子类不同完成的功能也不同（重写父类的方法）。\r\n§ 多态是同一个行为具有多个不同表现形式或形态的能力。Java语言中含有方法重载与对象多态两种形式的多态：\r\n**「优点」**\r\n\\1. **「消除类型之间的耦合关系」**\r\n\\2. **「可替换性」**\r\n\\3. **「可扩充性」**\r\n\\4. **「接口性」**\r\n\\5. **「灵活性」**\r\n\\6. **「简化性」**\r\n## **2.java 有哪些数据类型？**\r\n![img](《面试八股文》之 Java 基础 34 卷.assets/wpsFFA.tmp.png) \r\njava 主要有两种数据类型\r\no 1.**「基本数据类型」**\r\n§ byte,short,int,long属于数值型中的整数型\r\n§ float,double属于数值型中的浮点型\r\n§ char属于字符型\r\n§ boolean属于布尔型\r\n§ 基本数据有**「八个」**,\r\no 2.**「引用数据类型」**\r\n§ 引用数据类型有**「三个」**,分别是类,接口和数组\r\n## **3.接口和抽象类有什么区别？**\r\no 1.接口是抽象类的变体，**「接口中所有的方法都是抽象的」**。而抽象类是声明方法的存在而不去实现它的类。\r\no 2.接口可以多继承，抽象类不行。\r\no 3.接口定义方法，不能实现，默认是 **「public abstract」**，而抽象类可以实现部分方法。\r\no 4.接口中基本数据类型为 **「public static final」** 并且需要给出初始值，而抽类象不是的。\r\n## **4.重载和重写什么区别？**\r\n重写：\r\no 1.参数列表必须**「完全与被重写的方法」**相同，否则不能称其为重写而是重载.\r\no 2.**「返回的类型必须一直与被重写的方法的返回类型相同」**，否则不能称其为重写而是重载。\r\no 3.访问**「修饰符的限制一定要大于被重写方法的访问修饰符」**\r\no 4.重写方法一定**「不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常」**。\r\n重载：\r\no 1.必须具有**「不同的参数列表」**；\r\no 2.可以有不同的返回类型，只要参数列表不同就可以了；\r\no 3.可以有**「不同的访问修饰符」**；\r\no 4.可以抛出**「不同的异常」**；\r\n## **5.常见的异常有哪些？**\r\no NullPointerException 空指针异常\r\no ArrayIndexOutOfBoundsException 索引越界异常\r\no InputFormatException 输入类型不匹配\r\no SQLException SQL异常\r\no IllegalArgumentException 非法参数\r\no NumberFormatException 类型转换异常 等等....\r\n## **6.异常要怎么解决？**\r\nJava标准库内建了一些通用的异常，这些类以Throwable为顶层父类。\r\nThrowable又派生出**「Error类和Exception类」**。\r\n错误：Error类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出现。因此，程序员应该关注Exception为父类的分支下的各种异常类。\r\n异常：Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。\r\n处理方法:\r\no 1.**「try()catch(){}」**\r\ntry{\r\n// 程序代码\r\n}catch(ExceptionName e1){\r\n//Catch 块\r\n}\r\no 2.**「throw」**\r\n§ throw 关键字作用是抛出一个异常，抛出的时候是抛出的是一个异常类的实例化对象，在异常处理中，try 语句要捕获的是一个异常对象，那么此异常对象也可以自己抛出\r\no 3.**「throws」**\r\n§ 定义一个方法的时候可以使用 throws 关键字声明。使用 throws 关键字声明的方法表示此方法不处理异常，而交给方法调用处进行处理。\r\n## **7.arrayList 和 linkedList 的区别？**\r\n![img](《面试八股文》之 Java 基础 34 卷.assets/wpsFFB.tmp.png) \r\no \r\n1.ArrayList 是实现了基于**「数组」**的，存储空间是连续的。LinkedList 基于**「链表」**的，存储空间是不连续的。（LinkedList 是双向链表）\r\n2.对于**「随机访问」** get 和 set ，ArrayList 觉得优于 LinkedList，因为 LinkedList 要移动指针。\r\n3.对于**「新增和删除」**操作 add 和 remove ，LinedList 比较占优势，因为 ArrayList 要移动数据。\r\n4.同样的数据量 LinkedList 所占用空间可能会更小，因为 ArrayList 需要**「预留空间」**便于后续数据增加，而 LinkedList 增加数据只需要**「增加一个节点」**\r\no \r\n## **8.hashMap 1.7 和 hashMap 1.8 的区别？**\r\n只记录**「重点」**\r\n| **不同点** | **hashMap 1.7**          | **hashMap 1.8**          |\r\n| ---------------- | ------------------------------ | ------------------------------ |\r\n| 数据结构         | 数组+链表                      | 数组+链表+红黑树               |\r\n| 插入数据的方式   | 头插法                         | 尾插法                         |\r\n| hash 值计算方式  | 9次扰动处理(4次位运算+5次异或) | 2次扰动处理(1次位运算+1次异或) |\r\n| 扩容策略         | 插入前扩容                     | 插入后扩容                     |\r\n## **9.hashMap 线程不安全体现在哪里？**\r\n在 **「hashMap1.7 中扩容」**的时候，因为采用的是头插法，所以会可能会有循环链表产生，导致数据有问题，在 1.8 版本已修复，改为了尾插法\r\n在任意版本的 hashMap 中，如果在**「插入数据时多个线程命中了同一个槽」**，可能会有数据覆盖的情况发生，导致线程不安全。\r\n## **10.那么 hashMap 线程不安全怎么解决？**\r\n![img](《面试八股文》之 Java 基础 34 卷.assets/wpsFFC.tmp.png) \r\no 一.给 hashMap **「直接加锁」**,来保证线程安全\r\no 二.使用 **「hashTable」**,比方法一效率高,其实就是在其方法上加了 synchronized 锁\r\no 三.使用 **「concurrentHashMap」** , 不管是其 1.7 还是 1.8 版本,本质都是**「减小了锁的粒度,减少线程竞争」**来保证高效.\r\n## **11.concurrentHashMap 1.7 和 1.8 有什么区别**\r\n只记录**「重点」**\r\n| **不同点** | **concurrentHashMap 1.7** | **concurrentHashMap 1.8**    |\r\n| ---------------- | ------------------------------- | ---------------------------------- |\r\n| 锁粒度           | 基于segment                     | 基于entry节点                      |\r\n| 锁               | reentrantLock                   | synchronized                       |\r\n| 底层结构         | Segment + HashEntry + Unsafe    | Synchronized + CAS + Node + Unsafe |\r\n## **12.介绍一下 hashset 吧**\r\n![img](《面试八股文》之 Java 基础 34 卷.assets/wpsFFD.tmp.png) \r\n上图是 set 家族整体的结构，\r\nset 继承于 Collection 接口，是一个**「不允许出现重复元素，并且无序的集合」**.\r\nHashSet 是**「基于 HashMap 实现」**的，底层**「采用 HashMap 来保存元素」**\r\n元素的哈希值是通过元素的 hashcode 方法 来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较 equals 方法 如果 equls 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。\r\n## **13.什么是泛型？**\r\n泛型:**「把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型」**\r\n## **14.泛型擦除是什么？**\r\n因为泛型其实只是在编译器中实现的而虚拟机并不认识泛型类项，所以要在虚拟机中将泛型类型进行擦除。也就是说，**「在编译阶段使用泛型，运行阶段取消泛型，即擦除」**。擦除是将泛型类型以其父类代替，如String 变成了Object等。其实在使用的时候还是进行带强制类型的转化，只不过这是比较安全的转换，因为在编译阶段已经确保了数据的一致性。\r\n## **15.说说进程和线程的区别？**\r\n**「进程是系统资源分配和调度的基本单位」**，它能并发执行较高系统资源的利用率.\r\n**「线程」**是**「比进程更小」**的能独立运行的基本单位,创建、销毁、切换成本要小于进程,可以减少程序并发执行时的时间和空间开销，使得操作系统具有更好的并发性。\r\n## **16.volatile 有什么作用？**\r\n![img](《面试八股文》之 Java 基础 34 卷.assets/wpsFFE.tmp.png) \r\no **「1.保证内存可见性」**\r\n§ 可见性是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果，另一个线程马上就能看到。\r\no **「2.禁止指令重排序」**\r\n§ cpu 是和缓存做交互的，但是由于 cpu 运行效率太高，所以会不等待当前命令返回结果从而继续执行下一个命令，就会有乱序执行的情况发生\r\n## **17.什么是包装类？为什么需要包装类？**\r\n**「Java 中有 8 个基本类型，分别对应的 8 个包装类」**\r\no byte -- Byte\r\no boolean -- Boolean\r\no short -- Short\r\no char -- Character\r\no int -- Integer\r\no long -- Long\r\no float -- Float\r\no double -- Double\r\n**「为什么需要包装类」**:\r\no 基本数据类型方便、简单、高效，但泛型不支持、集合元素不支持\r\no 不符合面向对象思维\r\no 包装类提供很多方法，方便使用，如 Integer 类 toHexString(int i)、parseInt(String s) 方法等等\r\n## **18.Integer a = 1000，Integer b = 1000，a==b 的结果是什么？那如果 a，b 都为1，结果又是什么？**\r\nInteger a = 1000，Integer b = 1000，a==b 结果为**「false」**\r\nInteger a = 1，Integer b = 1，a==b 结果为**「true」**\r\n这道题主要考察 Integer 包装类缓存的范围,**「在-128~127之间会缓存起来」**,比较的是直接缓存的数据,在此之外比较的是对象\r\n## **19.JMM 是什么？**\r\n![img](《面试八股文》之 Java 基础 34 卷.assets/wpsFFF.tmp.png) \r\nJMM 就是 **「Java内存模型」**(java memory model)。因为在不同的硬件生产商和不同的操作系统下，内存的访问有一定的差异，所以会造成相同的代码运行在不同的系统上会出现各种问题。所以java内存模型(JMM)**「屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的并发效果」**。\r\nJava内存模型规定所有的变量都存储在主内存中，包括实例变量，静态变量，但是不包括局部变量和方法参数。每个线程都有自己的工作内存，线程的工作内存保存了该线程用到的变量和主内存的副本拷贝，线程对变量的操作都在工作内存中进行。**「线程不能直接读写主内存中的变量」**。\r\n每个线程的工作内存都是独立的，**「线程操作数据只能在工作内存中进行，然后刷回到主存」**。这是 Java 内存模型定义的线程基本工作方式。\r\n## **20.创建对象有哪些方式**\r\n有**「五种创建对象的方式」**\r\no 1、new关键字\r\nPerson p1 = new Person();\r\no 2.Class.newInstance\r\nPerson p1 = Person.class.newInstance();\r\no 3.Constructor.newInstance\r\nConstructor<Person> constructor = Person.class.getConstructor();\r\nPerson p1 = constructor.newInstance();\r\no 4.clone\r\nPerson p1 = new Person();\r\nPerson p2 = p1.clone();\r\no 5.反序列化\r\nPerson p1 = new Person();\r\nbyte[] bytes = SerializationUtils.serialize(p1);\r\nPerson p2 = (Person)SerializationUtils.deserialize(bytes);\r\n## **21.讲讲单例模式懒汉式吧**\r\n直接贴代码\r\n// 懒汉式\r\npublic class Singleton {\r\n// 延迟加载保证多线程安全\r\n  Private volatile static Singleton singleton;\r\n  private **Singleton**(){}\r\n  public static Singleton **getInstance**(){\r\n    **if**(singleton == null){\r\n      synchronized(Singleton.class){\r\n        **if**(singleton == null){\r\n          singleton = new Singleton();\r\n        }\r\n      }\r\n    }\r\n    return singleton;\r\n  }\r\n}\r\no 使用 volatile 是**「防止指令重排序，保证对象可见」**，防止读到半初始化状态的对象\r\no 第一层if(singleton == null) 是为了防止有多个线程同时创建\r\no synchronized 是加锁防止多个线程同时进入该方法创建对象\r\no 第二层if(singleton == null) 是防止有多个线程同时等待锁，一个执行完了后面一个又继续执行的情况\r\n## **22.volatile 有什么作用**\r\n![img](《面试八股文》之 Java 基础 34 卷.assets/wps1010.tmp.png) \r\no 1.**「保证内存可见性」**\r\n§ 当一个被volatile关键字修饰的变量被一个线程修改的时候，其他线程可以立刻得到修改之后的结果。当一个线程向被volatile关键字修饰的变量**「写入数据」**的时候，虚拟机会**「强制它被值刷新到主内存中」**。当一个线程**「读取」**被volatile关键字修饰的值的时候，虚拟机会**「强制要求它从主内存中读取」**。\r\no 2.**「禁止指令重排序」**\r\n§ 指令重排序是编译器和处理器为了高效对程序进行优化的手段，cpu  是与内存交互的，而 cpu 的效率想比内存高很多，所以 cpu 会在不影响最终结果的情况下，不等待返回结果直接进行后续的指令操作，而 volatile 就是给相应代码加了**「内存屏障」**，在屏障内的代码禁止指令重排序。\r\n## **23.怎么保证线程安全？**\r\no 1.synchronized关键字\r\n§ 可以用于代码块，方法（静态方法，同步锁是当前字节码对象；实例方法，同步锁是实例对象）\r\no 2.lock锁机制\r\nLock lock = new ReentrantLock();\r\nlock. lock();\r\ntry {\r\n  System. out. println("获得锁");\r\n} catch (Exception e) {\r\n} finally {\r\n  System. out. println("释放锁");\r\n  lock. unlock();\r\n}\r\n## **24.synchronized 锁升级的过程**\r\n在 Java1.6 之前的版本中，synchronized 属于重量级锁，效率低下，**「锁是」** cpu 一个**「总量级的资源」**，每次获取锁都要和 cpu 申请，非常消耗性能。\r\n在 **「jdk1.6 之后」** Java 官方对从 JVM 层面对 synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了，Jdk1.6 之后，为了减少获得锁和释放锁所带来的性能消耗，引入了偏向锁和轻量级锁，**「增加了锁升级的过程」**，由无锁->偏向锁->自旋锁->重量级锁![img](《面试八股文》之 Java 基础 34 卷.assets/wps1011.tmp.png)\r\n增加锁升级的过程主要是**「减少用户态到核心态的切换，提高锁的效率，从 jvm 层面优化锁」**\r\n## **25.cas 是什么？**\r\ncas 叫做 CompareAndSwap，**「比较并交换」**，很多地方使用到了它，比如锁升级中自旋锁就有用到，主要是**「通过处理器的指令来保证操作的原子性」**，它主要包含三个变量：\r\no **「1.变量内存地址」**\r\no **「2.旧的预期值 A」**\r\no **「3.准备设置的新值 B」**\r\n当一个线程需要修改一个共享变量的值，完成这个操作需要先取出共享变量的值，赋给 A，基于 A 进行计算，得到新值 B，在用预期原值 A 和内存中的共享变量值进行比较，**「如果相同就认为其他线程没有进行修改」**，而将新值写入内存\r\n![img](《面试八股文》之 Java 基础 34 卷.assets/wps1012.tmp.png) \r\n**「CAS的缺点」**\r\no \r\n**「CPU开销比较大」**：在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，又因为自旋的时候会一直占用CPU，如果CAS一直更新不成功就会一直占用，造成CPU的浪费。\r\n**「ABA 问题」**：比如线程 A 去修改 1 这个值，修改成功了，但是中间 线程 B 也修改了这个值，但是修改后的结果还是 1，所以不影响 A 的操作，这就会有问题。可以用**「版本号」**来解决这个问题。\r\n**「只能保证一个共享变量的原子性」**\r\no \r\n## **26.聊聊 ReentrantLock 吧**\r\nReentrantLock 意为**「可重入锁」**，说起 ReentrantLock 就不得不说 AQS ，因为其底层就是**「使用 AQS 去实现」**的。\r\nReentrantLock有两种模式，一种是公平锁，一种是非公平锁。\r\no 公平模式下等待线程入队列后会严格按照队列顺序去执行\r\no 非公平模式下等待线程入队列后有可能会出现插队情况\r\n**「公平锁」**\r\n![img](《面试八股文》之 Java 基础 34 卷.assets/wps1013.tmp.png) \r\no 第一步：**「获取状态的 state 的值」**\r\n§ 如果 state=0 即代表锁没有被其它线程占用，执行第二步。\r\n§ 如果 state!=0 则代表锁正在被其它线程占用，执行第三步。\r\no 第二步：**「判断队列中是否有线程在排队等待」**\r\n§ 如果不存在则直接将锁的所有者设置成当前线程，且更新状态 state 。\r\n§ 如果存在就入队。\r\no 第三步：**「判断锁的所有者是不是当前线程」**\r\n§ 如果是则更新状态 state 的值。\r\n§ 如果不是，线程进入队列排队等待。\r\n**「非公平锁」**\r\n![img](《面试八股文》之 Java 基础 34 卷.assets/wps1014.tmp.png) \r\no 获取状态的 state 的值\r\n§ 如果 state=0 即代表锁没有被其它线程占用，则设置当前锁的持有者为当前线程，该操作用 CAS 完成。\r\n§ 如果不为0或者设置失败，代表锁被占用进行下一步。\r\no 此时**「获取 state 的值」**\r\n§ 如果是，则给state+1，获取锁\r\n§ 如果不是，则进入队列等待\r\n§ 如果是0，代表刚好线程释放了锁，此时将锁的持有者设为自己\r\n§ 如果不是0，则查看线程持有者是不是自己\r\n## **27.多线程的创建方式有哪些？**\r\no 1、**「继承Thread类」**，重写run()方法\r\npublic class Demo extends Thread{\r\n  //重写父类Thread的run()\r\n  public void **run**() {\r\n  }\r\n  public static void main(String[] args) {\r\n    Demo d1 = new Demo();\r\n    Demo d2 = new Demo();\r\n    d1.start();\r\n    d2.start();\r\n  }\r\n}\r\no 2.**「实现Runnable接口」**，重写run()\r\npublic class Demo2 implements Runnable{\r\n  //重写Runnable接口的run()\r\n  public void **run**() {\r\n  }\r\n  public static void main(String[] args) {\r\n    Thread t1 = new Thread(new Demo2());\r\n    Thread t2 = new Thread(new Demo2());\r\n    t1.start();\r\n    t2.start();\r\n  }\r\n}\r\no 3.**「实现 Callable 接口」**\r\npublic class Demo implements Callable<String>{\r\n  public String call() throws Exception {\r\n    System.out.println("正在执行新建线程任务");\r\n    Thread.sleep(2000);\r\n    return "结果";\r\n  }\r\n  public static void main(String[] args) throws InterruptedException, ExecutionException {\r\n    Demo d = new Demo();\r\n    FutureTask<String> task = new FutureTask<>(d);\r\n    Thread t = new Thread(task);\r\n    t.start();\r\n    //获取任务执行后返回的结果\r\n    String result = task.get();\r\n  }\r\n}\r\no 4.**「使用线程池创建」**\r\npublic class Demo {\r\n  public static void main(String[] args) {\r\n    Executor threadPool = Executors.newFixedThreadPool(5);\r\n    **for**(int i = 0 ;i < 10 ; i++) {\r\n      threadPool.execute(new **Runnable**() {\r\n        public void **run**() {\r\n          //todo\r\n        }\r\n      });\r\n    }\r\n  }\r\n}\r\n## **28.线程池有哪些参数？**\r\no \r\n**「1.corePoolSize」**：**「核心线程数」**，线程池中始终存活的线程数。\r\n**「2.maximumPoolSize」**: **「最大线程数」**，线程池中允许的最大线程数。\r\n**「3.keepAliveTime」**: **「存活时间」**，线程没有任务执行时最多保持多久时间会终止。\r\n**「4.unit」**: **「单位」**，参数keepAliveTime的时间单位，7种可选。\r\n**「5.workQueue」**: 一个**「阻塞队列」**，用来存储等待执行的任务，均为线程安全，7种可选。\r\n**「6.threadFactory」**: **「线程工厂」**，主要用来创建线程，默及正常优先级、非守护线程。\r\n**「7.handler」**：**「拒绝策略」**，拒绝处理任务时的策略，4种可选，默认为AbortPolicy。\r\no \r\n## **29.线程池的执行流程？**\r\n![img](《面试八股文》之 Java 基础 34 卷.assets/wps1024.tmp.png) \r\no 判断线程池中的线程数**「是否大于设置的核心线程数」**\r\n§ 如果**「没有满」**，则**「放入队列」**，等待线程空闲时执行任务\r\n§ 如果队列已经**「满了」**，则判断**「是否达到了线程池设置的最大线程数」**\r\n§ 如果**「没有达到」**，就**「创建新线程」**来执行任务\r\n§ 如果已经**「达到了」**最大线程数，则**「执行指定的拒绝策略」**\r\n§ 如果**「小于」**，就**「创建」**一个核心线程来执行任务\r\n§ 如果**「大于」**，就会**「判断缓冲队列是否满了」**\r\n## **30.线程池的拒绝策略有哪些？**\r\no **「AbortPolicy」**：直接丢弃任务，抛出异常，这是默认策略\r\no **「CallerRunsPolicy」**：只用调用者所在的线程来处理任务\r\no **「DiscardOldestPolicy」**：丢弃等待队列中最旧的任务，并执行当前任务\r\no **「DiscardPolicy」**：直接丢弃任务，也不抛出异常\r\n## **31.介绍一下四种引用类型?**\r\no **「强引用 StrongReference」**\r\nObject obj = new Object(); \r\n//只要obj还指向Object对象，Object对象就不会被回收\r\n垃圾回收器不会回收被引用的对象，哪怕内存不足时，JVM 也会直接抛出 OutOfMemoryError，除非赋值为 null。\r\no **「软引用 SoftReference」**\r\n软引用是用来描述一些非必需但仍有用的对象。在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。\r\no **「弱引用 WeakReference」**\r\n弱引用的引用强度比软引用要更弱一些，无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收。\r\no **「虚引用 PhantomReference」**\r\n虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用，NIO 的堆外内存就是靠其管理。\r\n## **32.深拷贝、浅拷贝是什么？**\r\no 浅拷贝并不是真的拷贝，只是**「复制指向某个对象的指针」**，而不复制对象本身，新旧对象还是共享同一块内存。\r\no 深拷贝会另外**「创造一个一模一样的对象」**，新对象跟原对象不共享内存，修改新对象不会改到原对象。\r\n## **33.聊聊 ThreadLocal 吧**\r\no ThreadLocal其实就是**「线程本地变量」**，他会在每个线程都创建一个副本，那么在线程之间访问内部副本变量就行了，做到了线程之间互相隔离。![img](《面试八股文》之 Java 基础 34 卷.assets/wps1025.tmp.png)\r\no ThreadLocal 有一个**「静态内部类 ThreadLocalMap」**，ThreadLocalMap 又包含了一个 Entry 数组，**「Entry 本身是一个弱引用」**，他的 key 是指向 ThreadLocal 的弱引用，**「弱引用的目的是为了防止内存泄露」**,如果是强引用那么除非线程结束,否则无法终止,可能会有内存泄漏的风险。\r\no 但是这样还是会存在内存泄露的问题，假如 key 和 ThreadLocal 对象被回收之后，entry 中就存在 key 为 null ，但是 value 有值的 entry 对象，但是永远没办法被访问到，同样除非线程结束运行。**「解决方法就是调用 remove 方法删除 entry 对象」**。\r\n## **34.一个对象的内存布局是怎么样的?**\r\n![img](《面试八股文》之 Java 基础 34 卷.assets/wps1036.tmp.png)对象内存布局\r\no **「1.对象头」**: 对象头又分为 **「MarkWord」** 和 **「Class Pointer」** 两部分。\r\n§ **「MarkWord」**:包含一系列的标记位，比如轻量级锁的标记位，偏向锁标记位,gc记录信息等等。\r\n§ **「ClassPointer」**:用来指向对象对应的 Class 对象（其对应的元数据对象）的内存地址。在 32 位系统占 4 字节，在 64 位系统中占 8 字节。\r\no **「2.Length」**:只在数组对象中存在，用来记录数组的长度，占用 4 字节\r\no **「3.Instance data」**: 对象实际数据，对象实际数据包括了对象的所有成员变量，其大小由各个成员变量的大小决定。(这里不包括静态成员变量，因为其是在方法区维护的)\r\no **「4.Padding」**:Java 对象占用空间是 8 字节对齐的，即所有 Java 对象占用 bytes 数必须是 8 的倍数,是因为当我们从磁盘中取一个数据时，不会说我想取一个字节就是一个字节，都是按照一块儿一块儿来取的，这一块大小是 8 个字节，所以为了完整，padding 的作用就是补充字节，**「保证对象是 8 字节的整数倍」**。\r\n'},c0e1:function(n,r,e){"use strict";e.r(r),r["default"]="# jvm对象的创建过程内存布局\r\n\r\n **1.对象的创建过程**\r\n\r\n  **2.对象的内存布局**\r\n\r\n## **对象的创建过程**\r\n\r\n**以下内容基于HotSpot VM 分代模型**\r\n\r\n![img](jvm对象的创建过程内存布局.assets/wps8995.tmp.png) \r\n\r\n这张图其实就能完整的说明一个对象的创建过程到底发生了什么，很多朋友可能一下看不懂，那么我们就跟着左上角的一步一步来：\r\n\r\n\\1. **一个对象new出来先判断线程栈是否能分配下**\r\n\r\n· 如果能分配下，直接分配在栈中。\r\n\r\n· 如果分配不下则进行第二步。\r\n\r\n\\2. **判断该对象是否足够大**\r\n\r\n· 如果足够大，则直接进入老年代。\r\n\r\n· 如果不够大，则进行第三步。\r\n\r\n\\3. **判断创建对象的线程的TLAB（本地线程缓冲区）空间是否足够**\r\n\r\n· 如果足够，直接分配在TLAB中。\r\n\r\n· 如果不够，则进入Eden区中其他空间。然后进行第四步。\r\n\r\n\\4. **GC清除**\r\n\r\n· 如果清除掉了该对象，则直接结束。\r\n\r\n· 如果没有清除掉对象，进行第5步。\r\n\r\n\\5. **此刻对象进入Survivor 1 区，判断年龄是否足够大**\r\n\r\n· 如果年龄足够大，则直接进入old区域。\r\n\r\n· 如果年龄不够大，则进入Survivor 2 区，然后进入第4步，循环往复。\r\n\r\n  通过这张流程图和步骤解析大家应该对一个对象的创建过程有一个很清晰的概念了，但是其中还是有很多小细节会被忽略，为什么jvm会在对象的创建过程中大作文章，会分这么多种情况？为了让大家更深入的能够理解它，我们就再来看看下面这几个问题：\r\n\r\n\\1. **为什么对象会选择先分配在栈中？**\r\n\r\n  首先栈是线程私有的,将对象优先分配在栈中,**可以通过pop直接将对象的所有信息,空间直接清除**，当线程消亡的时候也可以直接清理这一块儿TLAB区域。\r\n\r\n\\1. **为什么jvm会让大对象会直接进入老年代？**\r\n\r\n  大对象需要连续的空间来存储,如果不存入老年代对jvm说就可能是一个负担，**如果没有足够的空间就有可能导致提前触发gc来清理空间来安置大对象**。\r\n\r\n\\1. **为什么会选择先进入TLAB？**\r\n\r\n  TLAB是线程本地缓冲区，**TLAB的好处就是防止不同线程创建对象选择同一块儿内存区域而产生竞争**，会使其概率大大减少。\r\n\r\n\\1. **为什么会有两个Survivor区？并且存活且年龄不够大的对象会从一个Survivor区转到另一个Survivor区？**\r\n\r\n  根据根可达算法，jvm会从开始寻找到所有正在使用的对象，没有使用的就是垃圾,通常情况下，**很多对象都是用完就抛弃的**，所以真正在Survivor区长时间存活的对象非常少，**将这部分对象从一个Survivor区转到另一个Survivor区后，就可以直接对这个Survivor区进行全量的空间回收了**，效率会很高。\r\n\r\n## **对象的内存布局**\r\n\r\n  作者可不是标题党，哈哈，所以我们回到文章的标题，Object o = new Object();到底占用多少个字节？这道题的目的其实就是考验看你对对象的内存布局了解的是否清晰，先上图:\r\n\r\n![img](jvm对象的创建过程内存布局.assets/wps89A5.tmp.png) \r\n\r\n  在java中对象的内存布局分为两种情况，非数组对象和数组对象，**数组对象和非数组对象的区别就是需要额外的空间存储数组的长度length**。\r\n\r\n##### **对象头**\r\n\r\n  对象头又分为MarkWord和Class Pointer两部分。\r\n\r\n· \r\n\r\nMarkWord:包含一系列的标记位，比如轻量级锁的标记位，偏向锁标记位,gc记录信息等等，**在32位系统占4字节，在64位系统中占8字节**。\r\n\r\n· \r\n\r\n· \r\n\r\nClassPointer:用来指向对象对应的Class对象（其对应的元数据对象）的内存地址。**在32位系统占4字节，在64位系统中占8字节**。\r\n\r\n· \r\n\r\n· \r\n\r\nLength:只在数组对象中存在，用来记录数组的长度，占用4字节\r\n\r\n· \r\n\r\n##### **Interface data**\r\n\r\n· Interface data:对象实际数据，对象实际数据**包括了对象的所有成员变量，其大小由各个成员变量的大小决定**。(这里**不包括静态成员变量**，因为其是在方法区维护的)\r\n\r\n##### **Padding**\r\n\r\n· Padding:Java对象占用空间是8字节对齐的，即所有Java对象占用bytes数必须是8的倍数,是因为当我们从磁盘中取一个数据时，不会说我想取一个字节就是一个字节，都是按照一块儿一块儿来取的，这一块大小是8个字节，所以为了完整，**padding的作用就是补充字节，保证对象是8字节的整数倍**。\r\n\r\n  moon在上文特意标注了32位系统和64位系统不同区域占用空间大小的区别，这是因为**对象指针在64位JVM下的寻址更长**，所以想比32位会多出来更多占用空间。\r\n\r\n  但是现在假设一个场景，公司现在项目部署的机器是32位的，你们老板要让你将项目迁移到64位的系统上，但是又因为64位系统比32位系统要多出更多占用空间，怎么办，因为正常来说我们是不需要这一部分多余空间的，所以jvm已经帮你考虑好了，那就是**指针压缩**。\r\n\r\n#### **指针压缩**\r\n\r\n  -XX:+UseCompressedOops 这个参数就是JVM提供给你的解决方案，可以压缩指针，将占用的空间压缩为原来的一半，起到节约空间的作用，classpointer参数大小就受到其影响。\r\n\r\n#### **Object o = new Object()到底占用多少个字节？**\r\n\r\n  通过刚才内存布局的学习后，这个问题就很好回答了，面试官其实就是想问你对象的内存布局是怎样的，我们这里就针对这个问题的结果分析下，这里分两种情况：\r\n\r\n· \r\n\r\n**在开启指针压缩的情况下**，markword占用8字节，classpoint占用4字节，Interface data无数据，总共是12字节，由于对象需要为8的整数倍，Padding会补充4个字节，总共占用16字节的存储空间。\r\n\r\n· \r\n\r\n· \r\n\r\n**在没有指针的情况下**，markword占用8字节，classpoint占用8字节，Interface data无数据，总共是16字节。\r\n\r\n· \r\n\r\n#  jvm┃java内存区域\r\n\r\n## **目录**\r\n\r\n· \r\n\r\n目录\r\n\r\n· \r\n\r\n· \r\n\r\n前言\r\n\r\n· \r\n\r\n· \r\n\r\n正文\r\n\r\n· \r\n\r\n§ \r\n\r\n1.程序计数器\r\n\r\n§ \r\n\r\n§ \r\n\r\n2.虚拟机栈\r\n\r\n§ \r\n\r\n§ \r\n\r\n3.本地方法栈\r\n\r\n§ \r\n\r\n§ \r\n\r\n4.堆\r\n\r\n§ \r\n\r\n§ \r\n\r\n5.方法区\r\n\r\n§ \r\n\r\n§ \r\n\r\n6.直接内存\r\n\r\n§ \r\n\r\n· \r\n\r\n结语\r\n\r\n· \r\n\r\n \r\n\r\n## **前言**\r\n\r\n  在java的使用过程当中，我们会发现java的内存是自己释放的，并不像C、C++代码那样，每一块儿内存都需要程序员自己去维护，但是在如此便捷的同时可能也会出现很多问题，比如**内存溢出**，**内存泄漏**更不好排查了，所以今天的文章中，moon会带大家先了解**java的内存区域的到底是怎样的**，以及**各个组件的作用是什么**，让你一点一点翻越虚拟机内存管理这座大山。\r\n\r\n \r\n\r\n## **正文**\r\n\r\n  我们先来看一张图：\r\n\r\n![img](jvm对象的创建过程内存布局.assets/wpsB9C5.tmp.png) \r\n\r\n  这张图就是一个java虚拟机运行时数据图，**深色区域代表是线程共享的区域**，java程序在运行的过程中会把他管理的内存划分为若干个不同的数据区域，每一块儿的数据区域所负责的功能都是不同的，他们也有不同的创建时间和销毁时间，本文将会从这张图开始一一展开，清晰的告诉你每一个模块的作用。\r\n\r\n### **1.程序计数器**\r\n\r\n  程序计数器就像是控制城市交通的红绿灯一样，是整个系统的中枢。在jvm中，它就是程序控制流的指示器，**循环，跳转，异常处理，线程的恢复**等工作都需要依赖程序计数器去完成。\r\n  **程序计数器是线程私有的**，它的生命周期是和线程保持一致的，我们知道，N个核心数的CPU在同一时刻，最多有N个线程同时运行，在我们真实的使用过程中可能会创建很多线程，**jvm的多线程其实是通过线程轮流切换，分配处理器执行时间来实现的**。既然涉及的线程切换，所以每条线程必须有一个独立的程序计数器。\r\n\r\n### **2.虚拟机栈**\r\n\r\n  虚拟机栈，其描述的就是线程内存模型，也可以称作线程栈，也是每个线程私有的，生命周期与线程保持一致。在每个方法执行的时候，jvm都会同步创建一个栈帧去存储**局部变量表，操作数栈，动态连接，方法出口等信息**。一个方法的生命周期就贯彻了一个栈帧从入栈到出栈的全部过程。  **局部变量表**应该是我们接触的最多的，**里面存储了java的8大基本数据类型**（byte、short、char、int、float、long、double、boolean）、**对象引用**(reference类型，不是对象本身，是指向对象的引用)和**returnAddress类型**（指向一条字节码指令的地址）。局部变量表的存储单位是**局部变量槽**(slot)，long和double类型会占据两个变量槽，其余类型只占用一个，但是每一个变量槽的大小是由jvm自己决定的。\r\n\r\n### **3.本地方法栈**\r\n\r\n  本地方法栈的概念很好理解，我们知道，java底层用了很多c的代码去实现，而其调用c端的方法上都会有native，代表**本地方法**服务，而本地方法栈就是为其服务的。\r\n\r\n### **4.堆**\r\n\r\n  堆可以说是**jvm中最大的一块儿内存区域**了，**它是所有线程共享**的，不管你是初学者还是资深开发，多少都会听说过堆，毕竟几乎所有的对象都会在堆中分配。\r\n\r\n  **我们先从分配内存的角度看看堆是怎么样的**：![img](jvm对象的创建过程内存布局.assets/wpsB9D6.tmp.png)  其实这就是一个最真实的堆，可能有些同学会觉得我说的不对，应该还有新生代，老年代，永久代，伊甸区，servivor区等等。这种说法基于某种逻辑上说是对的，但是并不是标准，它只是某些垃圾回收器的设计理念，需要新生代，老年代收集器搭配才能工作。\r\n\r\n  我们来说说**TLAB(thread  local allocation buffer)**,TLAB的数量和线程数是一一对应的，也就是说，TLAB是线程私有的，在堆空间中分配，**对象会首先存放在这个线程私有的TLAB中**，可以提升线程分配的效率。\r\n\r\n### **5.方法区**\r\n\r\n  方法区也是所有线程共享的区域，它存储了被jvm加载的类型信息、常量、静态变量等数据。\r\n  **运行时常量池**就是方法区的一部分，编译期生成的各种字面量与符号引用就存储在其中。\r\n\r\n### **6.直接内存**\r\n\r\n  **这部分数据并不是jvm运行时数据区的一部分**，nio就会使用到直接内存，也可以说堆外内存，**通常会配合虚引用一起去使用**，就是为了资源释放，会将堆外内存开辟空间的信息存储到一个队列中，然后GC会去清理这部分空间。\r\n\r\n  堆外内存优势在 IO 操作上，对于网络 IO，使用 Socket 发送数据时，能够节省堆内存到堆外内存的数据拷贝，所以性能更高。看过 Netty 源码的同学应该了解，**Netty 使用堆外内存池来实现零拷贝技术**。对于磁盘 IO 时，也可以使用内存映射，来提升性能。另外，更重要的几乎不用考虑堆内存烦人的 GC 问题。但是既然是内存。也会受到本机总内存的限制，\r\n\r\n "},c486:function(n,r,e){"use strict";e.r(r),r["default"]='# 《面试八股文》之 JVM 20卷\r\n\r\n1.说说 JVM 内存区域\r\n2.垃圾对象是怎么找到的？\r\n3.GC Roots 有哪些?\r\n4.java 有哪四种引用类型?\r\n5.说一说分代收集理论\r\n6.垃圾收集算法有哪些?\r\n7.什么是 STW ?\r\n8.为什么需要 STW?\r\n9.垃圾回收器是怎样寻找 GC Roots 的？\r\n10.OopMap 是做什么的?有什么好处?\r\n11.什么是安全点?\r\n12.安全区域是什么?解决了什么问题\r\n13.常见的垃圾回收器?\r\n14.说说三色标记\r\n15.什么情况下会发生栈内存溢出？\r\n16.如何排查 OOM 的问题？\r\n17.说一说类加载机制是什么?加载的过程又是怎么样的?\r\n18.介绍一下双亲委派模型,它的好处是什么?\r\n19.说一说对象的栈上分配吧?\r\n20.说一说对象的内存布局是怎样的?\r\n------\r\n## **1.说说 JVM 内存区域**\r\n![img](《面试八股文》之 JVM 20卷.assets/wps24E3.tmp.png)JVM 内存区域\r\n这张图就是一个 JVM 运行时数据图，**「紫色区域代表是线程共享的区域」**，JAVA 程序在运行的过程中会把他管理的内存划分为若干个不同的数据区域，**「每一块儿的数据区域所负责的功能都是不同的，他们也有不同的创建时间和销毁时间」**。\r\no \r\n**「1.程序计数器」**\r\no \r\n§ 程序计数器是**「程序控制流的指示器，循环，跳转，异常处理，线程的恢复等工作都需要依赖程序计数器去完成」**。程序计数器是**「线程私有」**的，它的**「生命周期是和线程保持一致」**的，我们知道，N 个核心数的 CPU 在同一时刻，最多有  N个线程同时运行，在我们真实的使用过程中可能会创建很多线程，JVM 的多线程其实是通过线程轮流切换，分配处理器执行时间来实现的。既然涉及的线程切换，所以每条线程必须有一个独立的程序计数器。\r\no \r\n**「2.虚拟机栈」**\r\no \r\n§ 虚拟机栈，其描述的就是线程内存模型，**「也可以称作线程栈」**，也是每个**「线程私有」**的，**「生命周期与线程保持一致」**。在每个方法执行的时候，jvm 都会同步创建一个栈帧去存储局部变量表，操作数栈，动态连接，方法出口等信息。一个方法的生命周期就贯彻了一个栈帧从入栈到出栈的全部过程。\r\no \r\n**「3.本地方法栈」**本地方法栈的概念很好理解，我们知道，java底层用了很多c的代码去实现，而其调用c端的方法上都会有native，代表本地方法服务，而本地方法栈就是为其服务的。\r\n**「4.堆」**堆可以说是jvm中最大的一块儿内存区域了，它是所有线程共享的，不管你是初学者还是资深开发，多少都会听说过堆，毕竟几乎所有的对象都会在堆中分配。\r\n**「5.方法区」**\r\no \r\n§ 方法区也是所有**「线程共享」**的区域，它**「存储」**了被 jvm 加载的**「类型信息、常量、静态变量等数据」**。运行时常量池就是方法区的一部分，编译期生成的各种字面量与符号引用就存储在其中。\r\no \r\n**「6.直接内存」**\r\no \r\n§ 这部分数据并**「不是 jvm 运行时数据区的一部分」**，nio 就会使用到直接内存，也可以说**「堆外内存」**，通常会**「配合虚引用一起去使用」**，就是为了资源释放，会将堆外内存开辟空间的信息存储到一个队列中，然后GC会去清理这部分空间。堆外内存优势在 IO 操作上，对于网络 IO，使用 Socket 发送数据时，能够节省堆内存到堆外内存的数据拷贝，所以性能更高。看过 Netty 源码的同学应该了解，Netty 使用堆外内存池来实现零拷贝技术。对于磁盘 IO 时，也可以使用内存映射，来提升性能。另外，更重要的几乎不用考虑堆内存烦人的 GC 问题。但是既然是内存。也会受到本机总内存的限制，\r\n## **2.垃圾对象是怎么找到的？**\r\no **「1.引用计数算法」**\r\n就是给对象添加一个计数器\r\no 每当有一个地方引用它的时候，计数器就加1\r\no 每当有一个引用失效的时候，计数器就减1\r\n「**「当计数器的值为0的时候，那么该对象就是垃圾了」**」这种方案的原理很简单，而且判定的效率也非常高，但是却可能会有其他的额外情况需要考虑。\r\n![img](《面试八股文》之 JVM 20卷.assets/wps24F4.tmp.png)相互引用\r\n比如两个「**「对象循环引用」**」，a 对象引用了 b 对象，b 对象也引用了 a 对象，a、b 对象却没有再被其他对象所引用了，其实正常来说这两个对象已经是垃圾了，因为没有其他对象在使用了，但是计数器内的数值却不是 0，所以引用计数算法就无法回收它们。这种算法是比较「**「直接的找到垃圾」**」，然后去回收，也被称为"直接垃圾收集"。\r\no **「2.根可达算法」**\r\n这也是「**「JVM 默认使用」**」的寻找垃圾算法它的原理就是定义了一系列的根，我们把它称为 **「「"GC Roots"」」** ，从 **「「"GC Roots"」」** 开始往下进行搜索，走过的路径我们把它称为 **「「"引用链"」」** ，当一个对象到 **「「"GC Roots"」」** 之间没有任何引用链相连时，那么这个对象就可以被当做垃圾回收了。\r\n![img](《面试八股文》之 JVM 20卷.assets/wps24F5.tmp.png)root search\r\n如图，「**「根可达算法」**」就可以「**「避免」**」计数器算法不好解决的「**「循环引用问题」**」，Object 6、Object 7、Object 8彼此之前有引用关系，但是**「没有与「"GC Roots"」 相连，那么就会被当做垃圾所回收」**。\r\n## **3.GC Roots 有哪些?**\r\n在java中，有「**「固定的GC Roots 对象」**」和「**「不固定的临时GC Roots对象」**:」\r\n「**「固定的GC Roots:」**」\r\no 1.在「**「虚拟机栈(栈帧的本地变量表)中所引用的对象」**」，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。\r\no 在方法区中「类静态属性引用的对象」，譬如 Java 类的**「引用静态变量」**。\r\no 在方法区中「**「常量引用的对象」**」，譬如字符串常量池中的引用。\r\no 在方法区栈中 **「「JNI (譬如 Native 方法)引用的对象」」**。\r\no Java **「「虚拟机内部的引用」」**，如基本数据类型对应的 Class 对象，一些常驻的异常对象(空指针异常、OOM等)，还有类加载器。\r\no 所有「**「被 Synchronized 持有的对象」**」。\r\no 反应 Java 虚拟机内部情况的 **「「JMXBean、JVMTI 中注册的回调本地代码缓存等」」**。\r\n「**「临时GC Roots:」**」\r\no 「**「为什么会有临时的 GC Roots ？」**」:目前的垃圾回收大部分都是「**「分代收集和局部回收」**」，如果只针对某一部分区域进行局部回收，那么就必须要考虑的「**「当前区域的对象有可能正被其他区域的对象所引用」**」，这时候就要将这部分关联的对象也添加到 GC Roots 中去来确保根可达算法的准确性。这种算法是利用了「**「逆向思维」**」，找到使用的对象，剩下的就是垃圾，也被称为"间接垃圾收集"。\r\n## **4.java 有哪四种引用类型?**\r\no **「1.强引用」**\r\n"Object o = new Object()" 就是一种强引用关系，这也是我们在代码中最常用的一种引用关系。无论任何情况下，只要强引用关系还存在，垃圾回收器就不会回收掉被引用的对象。\r\no **「2.软引用」**\r\n当内存空间不足时，就会回收软引用对象。\r\n// 软引用  \r\nSoftReference<String> softRef = new SoftReference<String>(str);\r\n软引用用来描述那些有用但是没必要的对象。\r\no **「3.弱引用」**\r\n弱引用要比软引用更弱一点，它「**「只能够存活到下次垃圾回收之前」**」。也就是说，垃圾回收器开始工作，会回收掉所有只被弱引用关联的对象。\r\nWeakReference<String> weakRef = new WeakReference<String>(str);\r\n在 **「ThreadLocal」** 中就使用了弱引用来防止内存泄漏。\r\no **「4.虚引用」**\r\n虚引用是最弱的一种引用关系，它的唯一作用是用来作为一种通知。如零拷贝(Zero Copy)，开辟了堆外内存，虚引用在这里使用，会将这部分信息存储到一个队列中，以便于后续对堆外内存的回收管理。\r\n## **5.说一说分代收集理论**\r\n大多数的垃圾回收器都遵循了分代收集的理论进行设计，它建立在两个分代假说之上:\r\no **「「弱分代假说」」**:绝大多数对象都是朝生夕灭的。\r\no **「「强分代假说」」**:熬过越多次数垃圾回收过程的对象就越难消亡。\r\n这两种假说的设计原则都是相同的:垃圾收集器「**「应该将jvm划分出不同的区域」**」，把那些较难回收的对象放在一起（一般指老年代），这个区域的垃圾回收频率就可以降低，减少垃圾回收的开销。剩下的区域(一般指新生代)可以用较高的频率去回收，并且只需要去关心那些存活的对象，也不用标记出需要回收的垃圾，这样就能够以较低的代价去完成垃圾回收。\r\no **「「跨代引用假说」」**：如果某个新生代的对象存在了跨代引用，但是老年代的对象是很难消亡的，那么随着时间的推移，这个新生代对象也会慢慢晋升为老年代对象，那么这种跨代引用也就被消除了。\r\n由于跨代引用是很少的，所以我们不应该为了少量的跨代引用去扫描整个老年代的数据，只需要在新生代对象建立一个「**「记忆集」**」来记录引用信息。记忆集:「**「将老年代分为若干个小块，每块区域中有 N 个对象」**」，在对象引用信息发生变动的时候来维护记忆集数据的准确性，这样每次发生了 「**「"Minor GC"」**」 的时候只需要将记忆集中的对象添加到 「**「"GC Roots"」**」 中就可以了。\r\n## **6.垃圾收集算法有哪些?**\r\n总共有三种\r\no **「1.标记清除算法」**\r\n这种算法的实现是很简单的，有两种方式\r\no 1.标记出垃圾，然后清理掉\r\no 2.标记出存货的对象，回收其他空间\r\n![img](《面试八股文》之 JVM 20卷.assets/wps24F6.tmp.png)标记清除算法\r\n这种算法有两个**「缺点」**\r\no \r\n1.随着对象越来越多，那么所需要消耗的时间就会越来越多\r\n2.标记清除后会导致碎片化，如果有大对象分配很有可能分配不下而出发另一次的垃圾收集动作\r\n**「2.标记复制算法」**\r\no \r\n这种算法解决了第一种算法碎片化的问题。就是「**「开辟两块完全相同的区域」**」，对象只在其中一篇区域内分配，然后「**「标记」**」出那些「**「存活的对象，按顺序整体移到另外一个空间」**」，如下图，可以看到回收后的对象是排列有序的，这种操作只需要移动指针就可以完成，效率很高，「**「之后就回收移除前的空间」**」。\r\n![img](《面试八股文》之 JVM 20卷.assets/wps24F7.tmp.png)标记复制算法\r\n这种算法的缺点也是很明显的\r\no \r\n浪费过多的内存，使现有的「**「可用空间变为」**」原先的「**「一半」**」\r\n**「3.标记整理算法」**\r\no \r\n这种算法可以说是结合了前两种算法，既有标记删除，又有整理功能。\r\n![img](《面试八股文》之 JVM 20卷.assets/wps24F8.tmp.png)标记整理算法\r\n这种算法就是通过标记清除算法找到存活的对象，然后将所有「**「存活的对象，向空间的一端移动」**」，然后回收掉其他的内存。\r\n## **7.什么是 STW ?**\r\nJava 中「**「Stop-The-World机制简称 STW」**」 ，是在执行垃圾收集算法时，Java 应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。**「Java 中一种全局暂停现象，全局停顿」**，所有 Java 代码停止，native 代码可以执行，但不能与 JVM 交互。\r\n## **8.为什么需要 STW?**\r\n在 java 应用程序中「**「引用关系」**」是不断发生「**「变化」**」的，那么就会有会有很多种情况来导致「**「垃圾标识」**」出错。想想一下如果 Object a  目前是个垃圾，GC 把它标记为垃圾，但是在清除前又有其他对象指向了 Object a，那么此刻 Object a 又不是垃圾了，那么如果没有 STW 就要去无限维护这种关系来去采集正确的信息。再举个例子，到了秋天，道路上洒满了金色的落叶，环卫工人在打扫街道，却永远也无法打扫干净，因为总会有不断的落叶。\r\n## **9.垃圾回收器是怎样寻找 GC Roots 的？**\r\n我们在前面说明了根可达算法是通过 GC Roots 来找到存活的对象的，也定义了 GC Roots，那么垃圾回收器是怎样寻找GC Roots 的呢？首先，**「「为了保证结果的准确性，GC Roots枚举时是要在STW的情况下进行的」」**，但是由于 JAVA 应用越来越大，所以也不能逐个检查每个对象是否为 GC Root，那将消耗大量的时间。一个很自然的想法是，能不能用空间换时间，在某个时候把栈上代表引用的位置全部记录下来，这样到真正 GC 的时候就可以直接读取，而不用再一点一点的扫描了。事实上，大部分主流的虚拟机也正是这么做的，比如 HotSpot ，它使用一种叫做 **「「OopMap」」** 的数据结构来记录这类信息。\r\n## **10.OopMap 是做什么的?有什么好处?**\r\n我们知道，一个线程意味着一个栈，一个栈由多个栈帧组成，一个栈帧对应着一个方法，一个方法里面可能有多个安全点。gc 发生时，程序首先运行到最近的一个安全点停下来，然后更新自己的 OopMap ，记下栈上哪些位置代表着引用。枚举根节点时，递归遍历每个栈帧的 OopMap ，通过栈中记录的被引用对象的内存地址，即可找到这些对象（ GC Roots ）。使用 OopMap 可以「**「避免全栈扫描」**」，加快枚举根节点的速度。但这并不是它的全部用意。它的另外一个更根本的作用是，可以帮助 HotSpot 实现准确式 GC (即使用准确式内存管理，虚拟机可用知道内存中某个位置的数据具体是什么类型) 。\r\n## **11.什么是安全点?**\r\n从线程角度看，安全点可以理解成是在「**「代码执行过程中」**」的一些「**「特殊位置」**」，当线程执行到这些位置的时候，说明「**「虚拟机当前的状态是安全」**」的。比如：「**「方法调用、循环跳转、异常跳转等这些地方才会产生安全点」**」。如果有需要，可以在这个位置暂停，比如发生GC时，需要暂停所有活动线程，但是线程在这个时刻，还没有执行到一个安全点，所以该线程应该继续执行，到达下一个安全点的时候暂停，等待 GC 结束。那么如何让线程在垃圾回收的时候都跑到最近的安全点呢？这里有「**「两种方式」**」：\r\no **「抢先式中断」**\r\n§ 抢先式中断：就是在stw的时候，先让所有线程「**「完全中断」**」，如果中断的地方不在安全点上，然后「**「再激活」**」，「**「直到运行到安全点的位置」**」再中断。\r\no **「主动式中断」**\r\n§ 主动式中断：在安全点的位置打一个标志位，每个线程执行都去轮询这个标志位，如果为真，就在最近的安全点挂起。\r\n## **12.安全区域是什么?解决了什么问题**\r\n刚刚说到了主动式中断,但是如果有些线程处于sleep状态怎么办呢？\r\n为了解决这种问题，又引入了安全区域的概念安全区域是指「**「在一段代码片中，引用关系不会发生改变」**」，实际上就是一个安全点的拓展。当线程执行到安全区域时，首先标识自己已进入安全区域，那样，当在这段时间里 JVM 要发起 GC 时，就不用管标识自己为“安全区域”状态的线程了，该线程只能乖乖的等待根节点枚举完或者整个GC过程完成之后才能继续执行。\r\n## **13.常见的垃圾回收器?**\r\n前面和大家聊了很多垃圾收集算法，所以在真正实践的时候会有多种选择，垃圾回收器就是真正的实践者，接下来就和大家聊聊10种垃圾回收器\r\n![img](《面试八股文》之 JVM 20卷.assets/wps2508.tmp.png) \r\no **「1.Serial」**\r\nSerial是一个「**「单线程」**」的垃圾回收器，「**「采用复制算法负责新生代」**」的垃圾回收工作，可以与 CMS 垃圾回收器一起搭配工作。\r\n![img](《面试八股文》之 JVM 20卷.assets/wps2509.tmp.png)Serial\r\n在 STW 的时候「**「只会有一条线程」**」去进行垃圾收集的工作，所以可想而知，它的效率会比较慢。但是他确是所有垃圾回收器里面消耗额外内存最小的，没错，就是因为简单。\r\no **「2.ParNew」**\r\nParNew 是一个「**「多线程」**」的垃圾回收器，**「采用复制算法负责新生代」**的垃圾回收工作，可以与CMS垃圾回收器一起搭配工作。\r\n![img](《面试八股文》之 JVM 20卷.assets/wps250A.tmp.png)ParNew\r\n它其实就是 Serial 的多线程版本，主要区别就是在 STW 的时候可以用多个线程去清理垃圾。\r\no **「3.Pararllel Scavenge」**\r\nPararllel Scavenge 是一个「**「多线程」**」的垃圾回收器，「**「采用复制算法负责新生代」**」的垃圾回收工作，可以与 Serial Old ， Parallel Old 垃圾回收器一起搭配工作。\r\n![img](《面试八股文》之 JVM 20卷.assets/wps250B.tmp.png)Pararllel Scavenge\r\n是与 ParNew 类似，都是用于年轻代回收的使用复制算法的并行收集器，与 ParNew 不同的是，Parallel Scavenge 的「**「目标是达到一个可控的吞吐量」**」。吞吐量=程序运行时间/（程序运行时间+GC时间）。如程序运行了99s，GC耗时1s，吞吐量=99/（99+1）=99%。Parallel Scavenge 提供了两个参数用以精确控制吞吐量，分别是用以控制最大 GC 停顿时间的 -XX:MaxGCPauseMillis 及直接控制吞吐量的参数 -XX:GCTimeRatio.「**「停顿时间越短就越适合需要与用户交互的程序」**」，良好的响应速度能提升用户体验，而高吞吐量则可以高效的利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。\r\no **「4.Serial Old」**\r\nSerial Old 是一个「**「单线程」**」的垃圾回收器，「**「采用标记整理算法负责老年代」**」的垃圾回收工作，有可能还会配合 「**「CMS」**」 一起工作。\r\n![img](《面试八股文》之 JVM 20卷.assets/wps250C.tmp.png) \r\n其实它就是 Serial 的老年代版本，整体链路和 Serial 大相径庭。\r\no **「5.Parallel Old」**\r\nParallel Old 是一个「**「多线程」**」的垃圾回收器，「**「采用标记整理算法负责新生代」**」的垃圾回收工作，可以与 Parallel Scavenge 垃圾回收器一起搭配工作。\r\n![img](《面试八股文》之 JVM 20卷.assets/wps250D.tmp.png) \r\nParallel Old 是 Pararllel Scavenge 的老年代版本，它的设计思路也是以吞吐量优先的，ps+po 是很常用的一种组合。\r\no **「6.CMS」**\r\nCMS可以说是一款具有"跨时代"意义的垃圾回收器，支持了和用户线程一起工作，做到了**「一起并发回收垃圾」**的"壮举"。\r\n![img](《面试八股文》之 JVM 20卷.assets/wps250E.tmp.png)CMS\r\no \r\n**「1.初始标记」**\r\n初始标记只是标记出来「**「和 GC Roots 直接关联」**」的对象，整个速度是非常快的，为了保证标记的准确，这部分会在 「**「STW」**」 的状态下运行。\r\n**「2.并发标记」**\r\n并发标记这个阶段会直接根据第一步关联的对象找到「**「所有的引用」**」关系，这一部分时刻用户线程「**「并发运行」**」的，虽然耗时较长，但是不会有很大的影响。\r\n**「3.重新标记」**\r\n重新标记是为了解决第二步并发标记所导致的标错情况，这里简单举个例子：并发标记时a没有被任何对象引用，此时垃圾回收器将该对象标位垃圾，在之后的标记过程中，a又被其他对象引用了，这时候如果不进行重新标记就会发生「**「误清除」**」。这部分内容也是在「**「STW」**」的情况下去标记的。\r\n**「4.并发清除」**\r\n这一步就是最后的清除阶段了，将之前「**「真正确认为垃圾的对象回收」**」，这部分会和用户线程一起并发执行。\r\no \r\nCMS的「**「三个缺点」**」：\r\no \r\n**「1.影响用户线程的执行效率」**\r\no \r\n§ CMS默认启动的回收线程数是（处理器核心数 + 3）/ 4 ,由于是和用户线程一起并发清理，那么势必会影响到用户线程的执行速度，并且这个影响「**「随着核心线程数的递减而增加」**」。所以 JVM 提供了一种 "「**「增量式并发收集器」**」"的 CMS 变种，主要是用来减少垃圾回收线程独占资源的时间，所以会感觉到回收时间变长，这样的话「**「单位时间内处理垃圾的效率就会降低」**」，也是一种缓和的方案。\r\no \r\n**「2.会产生"浮动垃圾"」**\r\no \r\n§ 之前说到 CMS 真正清理垃圾是和用户线程一起进行的，在「**「清理」**」这部分垃圾的时候「**「用户线程会产生新的垃圾」**」，这部分垃圾就叫做浮动垃圾，并且只能等着下一次的垃圾回收再清除。\r\no \r\n**「3.会产生碎片化的空间」**\r\no \r\n§ CMS 是使用了标记删除的算法去清理垃圾的，而这种算法的缺点就是会产生「**「碎片化」**」，后续可能会「**「导致大对象无法分配」**」从而触发「**「和 Serial Old 一起配合使用」**」来处理碎片化的问题，当然这也处于 「**「STW」**」的情况下，所以当 java 应用非常庞大时，如果采用了 CMS 垃圾回收器，产生了碎片化，那么在 STW 来处理碎片化的时间会非常之久。\r\no \r\n**「7.G1」**\r\no \r\nG1(Garbage First)：顾名思义，「**「垃圾回收第一」**」，官方对它的评价是在垃圾回收器技术上具有「**「里程碑式」**」的成果。G1 回收的目标不再是整个新生代，不再是整个老年代，也不再是整个堆了。G1 可以「**「面向堆内存的任何空间来进行」**」回收，衡量的标准也不再是根据年代来区分，而是哪块「**「空间的垃圾最多就回收哪」**」块儿空间，这也符合 G1 垃圾回收器的名字，垃圾第一，这就是 G1 的 「**「Mixed GC」**」 模式。当然我的意思是「**「垃圾回收不根据年代来区分」**」，但是 G1 还是「**「根据年代来设计」**」的，我们先来看下 G1 对于堆空间的划分：\r\n![img](《面试八股文》之 JVM 20卷.assets/wps251F.tmp.png)G1\r\nG1 垃圾回收器把堆划分成一个个「**「大小相同的Region」**」，每个 Region 都会扮演一个角色，H、S、E、O。E代表伊甸区，S代表 Survivor 区，H代表的是 Humongous(G1用来分配「**「大对象的区域」**」，对于 Humongous 也分配不下的超大对象，会分配在连续的 N 个 Humongous 中)，剩余的深蓝色代表的是 Old 区，灰色的代表的是空闲的 region。在 HotSpot 的实现中，整个堆被划分成2048左右个 Region。每个 Region 的大小在1-32MB之间，具体多大取决于堆的大小。在并发标记垃圾时也会产生新的对象，G1 对于这部分对象的处理是这样的：将 Region 「**「新增一块并发回收过程中分配对象的空间」**」，并为此设计了两个 TAMS(Top at Mark Start)指针，这块区域专门用来在并发时分配新对象，有对象新增只需要将 TAMS 指针移动下就可以了，并且这些「**「新对象默认是标记为存活」**」，这样就「**「不会干扰到标记过程」**」。\r\n![img](《面试八股文》之 JVM 20卷.assets/wps2520.tmp.png) \r\n但是这种方法也会有个问题，有可能「**「垃圾回收的速度小于新对象分配的速度」**」，这样会导致 "Full GC" 而产生长时间的 STW。在 G1 的设计理念里，「**「最小回收单元是 Region」**」，每次回收的空间大小都是Region的N倍，那么G1是「**「怎么选择要回收哪块儿区域」**」的呢？G1 会跟踪各个 Region 区域内的垃圾价值，和回收空间大小回收时间有关，然后「**「维护一个优先级列表」**」，来收集那些价值最高的Reigon区域。\r\n#### **执行的步骤：**\r\no \r\n**「初始标记」**：\r\no \r\n§ 标记出来 GC Roots 能「**「直接关联」**」到的对象\r\n§ 修改 TAMS 的值以便于并发回收时新对象分配\r\n§ 是在 Minor GC 时期(**「「STW」」**)完成的\r\no \r\n**「并发标记」**：\r\no \r\n§ 根据刚刚关联的对像扫描整个对象引用图，和用户线程**「并发执行」**\r\n§ 记录 SATB(原始快照) 在并发时有引用的值\r\no \r\n**「最终标记」**：\r\no \r\n§ 处于 **「「STW」」**，处理第二步遗留下来的少量 SATB(原始快照) 记录\r\no \r\n**「筛选回收」**：\r\no \r\n§ 维护之前提到的优先级列表\r\n§ 根据「**「优先级列表」**」，「**「用户设置的最大暂停时间」**」来回收 Region\r\n§ 将需要回收的 Region 内存活的对象「**「复制」**」到不需要回收的 Region区域内，然后回收需要回收的 Region\r\n§ 这部分是处于 「**「STW」**」 下执行，并且是多线程的\r\n## **14.说说三色标记**\r\n这里我们又提到了一个概念叫做 **「「SATB 原始快照」」**，关于SATB会延伸出有一个概念，**「「三色标记算法」」**，也就是垃圾回收器标记垃圾的时候使用的算法，这里我们简单说下：将对象分为「**「三种颜色」**」：\r\no 白色：没被 GC 访问过的对象(被 GC 标记完后还是白色代表是垃圾)\r\no 黑丝：存活的对象\r\no 灰色：被 GC 访问过的对象，但是对象引用链上至少还有一个引用没被扫描过\r\n我们知道在 **「「并发标记」」** 的时候 **「「可能会」」** 出现 **「「误标」」** 的情况，这里举两个例子：\r\no 1.刚开始标记为 **「「垃圾」」** 的对象，但是在并发标记过程中 **「「变为了存活对象」」**\r\no 2.刚开始标记为 **「「存活」」** 的对象，但是在并发标记过程中  **「「变为了垃圾对象」」**\r\n第一种情况影响还不算很大，只是相当于垃圾没有清理干净，待下一次清理的时候再清理一下就好了。第二种情况就危险了，正在使 **「「用的对象的突然被清理掉」」** 了，后果会很严重。那么 **「「产生上述第二种情况的原因」」** 是什么呢？\r\no 1.**「「新增」」** 一条或多条 **「「黑色到白色」」** 对象的新引用\r\no 2.删除 **「「了」」** 灰色 **「「对象」」** 到该白色对象 **「「的直接」」** 引用或间接引用。\r\n当这两种情况 **「「都满足」」** 的时候就会出现这种问题了。所以为了解决这个问题，引入了 **「「增量更新」」** (Incremental Update)和 **「「原始快照」」** (SATB)的方案：\r\no 增量更新破坏了第一个条件：**「「增加新引用时记录」」** 该引用信息，在后续 STW 扫描中重新扫描(CMS的使用方案)。\r\no 原始快照破坏了第二个条件：**「「删除引用时记录下来」」**，在后续 STW 扫描时将这些记录过的灰色对象为根再扫描一次(G1的使用方案)。\r\n## **15.什么情况下会发生栈内存溢出？**\r\nJava 栈内存溢出可能抛出两种异常，两种异常虽然都发生在栈内存，但是两者导致内存溢出的根本原因是不一样的：\r\no \r\n1.**「如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量的时候」**，Java 虚拟机将抛出一个 StackOverFlowError 异常。\r\n2.如果 Java 虚拟机栈可以动态拓展，并且扩展的动作已经尝试过，但是目前**「无法申请到足够的内存去完成拓展，或者在建立新线程的时候没有足够的内存去创建对应的虚拟机栈」**，那 Java 虚拟机将会抛出一个 OutOfMemoryError 异常。\r\no \r\n## **16.如何排查 OOM 的问题？**\r\no 1.增加两个参数 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof，当 OOM 发生时自动 dump 堆内存信息到指定目录；\r\no 2.同时 jstat 查看监控 JVM 的内存和 GC 情况，先观察问题大概出在什么区域；\r\no 3.使用工具载入到 dump 文件，分析大对象的占用情况。\r\n## **17.说一说类加载机制是什么?加载的过程又是怎么样的?**\r\n**「类加载机制」**:\r\no Java 虚拟机**「把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被 Jvm 可以直接使用的类型」**，这个过程就可以成为虚拟机的类加载机制。\r\n![img](《面试八股文》之 JVM 20卷.assets/wps2521.tmp.png) \r\n这是一张很经典的图，标明了一个类的生命周期，而很多人一眼看过去就以为明白了类的生命周期，但是这只是其中一种情况。\r\n真实情况是**「加载、验证、准备、初始化、卸载这五个阶段的顺序是确定的，是依次有序的」**。但是**「解析阶段有可能会在初始化之后才会进行」**，这是**「为了支持 Java 动态绑定」**的特性。\r\n**「动态绑定」**:\r\no **「在运行时根据具体对象的类型进行绑定」**。提供了一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。\r\n## **18.介绍一下双亲委派模型,它的好处是什么?**\r\n![img](《面试八股文》之 JVM 20卷.assets/wps2522.tmp.png) \r\n**「双亲委派模型」**：\r\no 简而言之，就是说一个类加载器收到了类加载的请求，不会自己先加载，而是把它**「交给自己的父类去加载，层层迭代」**。\r\n用上图来说明就是如果应用程序类加载器收到了一个类加载的请求，会先给扩展类加载器，然后再给启动类加载器，如果启动类加载器无法完成这个类加载的请求，再返回给扩展类加载器，如果扩展类加载器也无法完成，就返回给应用类加载器。\r\n**「好处:」**\r\no 说这个问题前我要先和大家说一个概念，**「Jvm 中类的唯一性是由类本身和加载这个类的类加载器决定的」**，简单的说，如果有个a类，如果被两个不同的类加载器加载，那么他们必不相等。你看到这里会不会想到所有类的父类都是 Object 是怎么实现的了吗？是因为无论哪一个类加载器加载 Object 类，都会交给最顶层的启动类加载器去加载，这样就**「保证了 Object 类在 Jvm 中是唯一的」**。\r\n## **19.说一说对象的栈上分配吧?**\r\n如果所有对象都分配在堆中那么会给 GC 带来许多不必要的压力,比如有些对象的生命周期只是在当前线程中，为了减少临时对象在堆内分配的数量，就**「可以在在栈上分配」**，随着线程的消亡而消亡。当然栈上空间必须充足,否则也无法分配，在判断是否能分配到栈上的另一条件就是要经过逃逸分析，\r\n**「逃逸分析(Escape Analysis)」**:\r\no 简单来讲就是：Java Hotspot 虚拟机判断这个新对象是否只会被当前线程引用，并且决定是否能够在 Java 堆上分配内存。\r\n## **20.说一说对象的内存布局是怎样的?**\r\n![img](《面试八股文》之 JVM 20卷.assets/wps2523.tmp.png)对象内存布局\r\no **「1.对象头」**: 对象头又分为 **「MarkWord」** 和 **「Class Pointer」** 两部分。\r\n§ **「MarkWord」**:包含一系列的标记位，比如轻量级锁的标记位，偏向锁标记位,gc记录信息等等。\r\n§ **「ClassPointer」**:用来指向对象对应的 Class 对象（其对应的元数据对象）的内存地址。在 32 位系统占 4 字节，在 64 位系统中占 8 字节。\r\no **「2.Length」**:只在数组对象中存在，用来记录数组的长度，占用 4 字节\r\no **「3.Instance data」**: 对象实际数据，对象实际数据包括了对象的所有成员变量，其大小由各个成员变量的大小决定。(这里不包括静态成员变量，因为其是在方法区维护的)\r\no **「4.Padding」**:Java 对象占用空间是 8 字节对齐的，即所有 Java 对象占用 bytes 数必须是 8 的倍数,是因为当我们从磁盘中取一个数据时，不会说我想取一个字节就是一个字节，都是按照一块儿一块儿来取的，这一块大小是 8 个字节，所以为了完整，padding 的作用就是补充字节，**「保证对象是 8 字节的整数倍」**。\r\n'},cef9:function(n,r,e){"use strict";e.r(r),r["default"]="# Redis 主从哨兵集群\r\n\r\n## **前言碎语**\r\n\r\n说起 Redis 应该没有人会陌生了吧，作为开发中最最最最最最最常用的 nosql，它的重要性不言而喻。\r\n\r\nRedis有三种集群模式，第一个就是主从模式，第二种“哨兵”模式，第三种是 Cluster 集群模式。(准确的说应该是四种，单机模式，但是基本上只适用于自己玩玩，这里就不说了)\r\n\r\n今天就和大家细细聊聊这三种模式。\r\n\r\n## **主从复制**\r\n\r\n![img](主从哨兵集群.assets/wps859C.tmp.png) \r\n\r\n当其中一台服务器更新之后，服务器会自动的将这台更新的**数据同步到另外一台服务器**上。\r\n\r\n通过持久化的功能，redis可以保证就算是服务宕机重启了，也只有少量的数据会丢失。但是在真实的使用场景当中，如果真的只有一台服务器，并且恰好宕机了，那么就会导致整个服务都不可用，因此redis提供了集群的方式来部署，可以避免这种问题。\r\n\r\n在主从复制这种集群部署模式中，我们会将**数据库分为两类**，第一种称为**主数据库**(master)，另一种称为**从数据库**(slave)。\r\n\r\n**主**数据库会**负责**我们整个系统中的**读写**操作，**从**数据库会**负责**我们整个数据库中的**读**操作。\r\n\r\n其中在职场开发中的真实情况是，我们会让主数据库只负责写操作，让从数据库只负责读操作，就是为了**读写分离**，**减轻服务器的压力**。\r\n\r\n但是我在实际开发中会遇到一种情况，该数据是个热点数据，我们知道，数据同步一定是会耗时的，那么当一个**热点数据进入master中**，**而slave没有来得及更新**，再去读这个数据就会造成**数据不一致**现象，所以当时我的方案就是直接去读master节点，这个逻辑同样适用于mysql主从中出现的问题。\r\n\r\n## **主从同步原理**\r\n\r\n· 当一个从数据库启动时，它会向主数据库发送一个**SYNC命令**\r\n\r\n· master收到后，在后台**保存快照**，也就是我们说的RDB持久化，当然保存快照是需要消耗时间的，并且redis是单线程的(redis后面也支持了多线程，这里我们先不讲)，**在保存快照期间redis收到的命令会缓存起来**，快照完成后会将缓存的命令以及快照一起打包发给slave节点，从而保证主从数据库的一致性。\r\n\r\n· 从数据库接受到快照以及缓存的命令后会将这部分数据**写入到硬盘上的临时文件**当中，写入完成后会用这份文件去替换掉RDB快照文件，当然，这个操作是不会阻塞的，可以继续接收命令执行，具体原因其实就是fork了一个子进程，用子进程去完成了这些功能。\r\n\r\n因为不会阻塞，所以，这部分初始化完成后，当主数据库执行了改变数据的命令后，会异步的给slave，这也就是我们说的**复制同步阶段**，这个阶段会**贯穿在整个主从同步**的过程中，直到主从同步结束后，复制同步才会终止。\r\n\r\n### **那么我上文提到的数据不一致的现象又是怎么回事呢？**\r\n\r\n是因为redis采用了**乐观复制**的策略:\r\n\r\n**容忍一定时间内主从数据库的数据是不一致的，但是会保证最终的结果一致**。\r\n\r\n所以当主从复制发生时，正常情况下的命令都会在主数据库完成，然后直接反回给客户端，这样我们的性能就不会受到影响了，因为这里是主数据库先完成命令，那么就会产生其他问题。\r\n\r\n**举个例子**，假如现在有1个master，6个slave，现在只有两个slave完成了同步，master写了新命令，在master准备将此命令传输给其他slave时，此刻其他的slave断电了，那么就会造成**数据不一致**的现象发生。\r\n\r\n所以redis针对这种情况作了两个配置\r\n\r\nmin-slaves-to-write  2  (只有2个及以上的从数据库连接到了主数据库时，master库才是可写的)\r\n\r\nmin-slaves-max-lag  10 (10秒slave没有和master进行交互就认为丢失链接)\r\n\r\n## **无硬盘复制**\r\n\r\n我们刚刚说了主从之间是通过RDB快照来交互的，虽然看来逻辑很简单，但是还是**会存在一些问题**:\r\n\r\n· 1.master**禁用了RDB快照**时，发生了主从同步(复制初始化)操作，也会生成RDB快照，但是之后如果master发成了重启，就会用RDB快照去恢复数据，这份数据可能已经很久了，中间就会丢失数据\r\n\r\n· 2.在这种一主多从的结构中，master每次和slave同步数据都要进行一次快照，从而在硬盘中生成RDB文件，会**影响性能**\r\n\r\n为了解决这种问题，redis在后续的更新中也加入了无硬盘复制功能，也就是说**直接通过网络发送给slave**，避免了和硬盘交互，但是也是有io消耗的。\r\n\r\n## **增量复制**\r\n\r\n### **为什么会有增量复制？**\r\n\r\n刚刚我们说了复制的原理，但是他的缺点是很明显的，就是在**断开主从链接后，即使你只发生了一条数据变化，也需要将所有的数据通过SYNC命令用RDB将所有的数据同步给slave**，但是其实并不需要同步所有的数据，只需要将改变的这小部分数据同步给slave就好了\r\n\r\n**所以为了解决这个问题，redis就有了增量复制。**\r\n\r\n这个原理其实是很简单的，学过kafka 的小伙伴应该知道，kafka消费是通过偏移量来计算的，redis的增量复制也是如此。\r\n\r\nmaster会**记下每个slave的id**，在复制期间，如果有新消息，会将新消息(其实是新的命令，当然只包括让数据放生变动的命令，如 set  这种 )**存放在一个固定大小的循环队列中**，这个大小是可以配置的，当然这时候发送的就是PSYNC命令了，然后master会在复制完成后将这部分数据发送给slave，这样就在很大程度上保证了数据一致性。\r\n\r\n## **哨兵模式**\r\n\r\n上文咱们说主从复制，在这种一主多从的结构中，我们让主从数据库做到了读写分离，也让从数据库能够完成数据备份的功能，可是也留下了一个比较严重的问题，当**master挂了之后，只能由运维人员重新选择一个slave升级成master，然后继续提供服务**。\r\n\r\n想想一下，你国庆正放假，躺在三亚的海边沐浴着阳光，享受着香槟，突然你们boss给你来了个电话，说线上的master挂了，是不是会心里一句mmp？？？，所以，redis为了你考虑，在redis2.6版本中，他来了他来了--------**哨兵模式**\r\n\r\n## **什么是哨兵？**\r\n\r\n顾名思义，哨兵其实就是放哨的，它主要会有完成**两个功能**。\r\n\r\n· \r\n\r\n1.监控整个主数据库和从数据库，观察它们是否正常运行\r\n\r\n· \r\n\r\n· \r\n\r\n2.当主数据库发生异常时，自动的将从数据库升级为主数据库，继续保证整个服务的稳定\r\n\r\n· \r\n\r\n哨兵其实是一个独立的进程，如下图\r\n\r\n![img](主从哨兵集群.assets/wps859D.tmp.png) \r\n\r\n当然，上图只是一个哨兵存在时的情况，但在现实中还会有两个，甚至**更多哨兵存在**的情况\r\n\r\n![img](主从哨兵集群.assets/wps859E.tmp.png) \r\n\r\n## **实现原理**\r\n\r\n当一个哨兵进程启动时，它会先**通过配置文件，找我们的主数据库**，当然，我们这里也只需要配置其监控的主数据库就好，之后哨兵会自动发现所有复制该主数据库的从数据库，当然**一个哨兵是可以监控多个redis系统**的，同时，多个哨兵也可以同时监控一个redis系统的，这里moon先给大家灌输下这个概念，大家理解下，详细的我会在后文提到。\r\n\r\n哨兵进程启动后后会和master建立两条链接\r\n\r\n· 1.用来获取其他同样在监控着此redis系统的哨兵信息\r\n\r\n· 2.发送一个info命令来获取此redis系统master本身的信息\r\n\r\n当和master完成链接建立后，该哨兵就会定时的做以下三件事情\r\n\r\n· 1.每10秒会向master和slave发送info命令\r\n\r\n· 2.每2秒会向master和slave发送自己的信息\r\n\r\n· 3.每1秒会向master，slave以及其他同样在监控着此redis系统的哨兵发送ping命令\r\n\r\n以上三个操作可是说**是哨兵的核心**了，下面就着重介绍一下这三个命令\r\n\r\n首先，**info命令可以让哨兵获取到当前数据库的信息**，比如运行id，复制信息等等，从而**实现新节点的自动发现**，从数据库的信息正是从info命令中获取的，获取从数据库信息后，就会和从数据库建立两条链接，和主数据库建立的链接是完全一样的，之后就会每**10s向主从数据库发送info**命令，当有新的从数据库加入时，就会从info命令中发现了，从而将这个新的slave加入自己的监控列表中。\r\n\r\n当然如果有新的哨兵加入到了监控中，其他哨兵也是从这个info命令中获取的。\r\n\r\n于此，就完成了对数据库以及其他哨兵的自动发现和监控，是不是很easy呢？？\r\n\r\n以上讲了**自动发现数据库和其他的哨兵节点**，之后哨兵就开始了它的工作，就是去监控这些数据库和节点有没有停止，哨兵就会每隔一段时间向这些节点发送PING命令，如果一段时间没有收到回复后，那么这个哨兵就会认为该节点已经挂了，我们将其称为**主观下线**。\r\n\r\n如果该节点是master，哨兵就会向其他节点询问，看其他节点时候也认为该master挂了，我们可以认为他们在投票，当票数达到了一定的次数，那么哨兵就认为该节点真的挂了，我们成为**客观下线**，然后哨兵之间就会选举，选出一个领头的哨兵对主从数据库发起故障的修复。\r\n\r\n## **哨兵选举过程**\r\n\r\n· 1.第一个发现该master挂了的哨兵，向每个哨兵发送命令，让对方选举自己成为领头哨兵\r\n\r\n· 2.其他哨兵如果没有选举过他人，就会将这一票投给第一个发现该master挂了的哨兵\r\n\r\n· 3.第一个发现该master挂了的哨兵如果发现由超过一半哨兵投给自己，并且其数量也超过了设定的quoram参数，那么该哨兵就成了领头哨兵\r\n\r\n· 4.如果多个哨兵同时参与这个选举，那么就会重复该过程，知道选出一个领头哨兵\r\n\r\n**选出领头哨兵后，就开始了故障修复，会从选出一个从数据库作为新的master**\r\n\r\n## **master选举过程**\r\n\r\n· 1.从所有在线的从数据库中，选择优先级最高的从数据库\r\n\r\n· 2.如果有多个优先级高的从数据库，那么就会判断其偏移量，选择偏移量最小的从数据库，这里的偏移量就是增量复制的\r\n\r\n· 3.如果还是有相同条件的从数据库，就会选择运行id较小的从数据库升级为master\r\n\r\n## **cluster集群模式**\r\n\r\n在redis3.0版本中支持了cluster集群部署的方式，这种集群部署的方式能**自动将数据进行分片，每个master上放一部分数据**，提供了内置的高可用服务，即使某个master挂了，服务还可以正常地提供，我们先来看张图：\r\n\r\n![img](主从哨兵集群.assets/wps85AF.tmp.png) \r\n\r\n使用cluster集群模式，只需要将每个数据库节点的cluster-enabled配置选项打开即可，但是每个cluster集群**至少要保证有3个主数据库**才能正常运行。\r\n\r\n## **cluster集群模式是怎么存放数据的？**\r\n\r\n一个cluster集群中**总共有16384个节点**，集群会将这16384个节点平均分配给每个节点，当然，我这里的节点指的是每个**主节点**，就如同下图：\r\n\r\n![img](主从哨兵集群.assets/wps85B0.tmp.png) \r\n\r\n \r\n\r\n## **键是如何和16384个插槽做关联的？**\r\n\r\nredis将每个redis的键的键名有效部分使用CRC16算法计算出散列值，然后与16384取余数，这样的就可以使每个键能够尽量的**均匀分布**在16384个插槽中。\r\n\r\n## **插槽是如何和节点做关联的?**\r\n\r\n· 1.插槽之前**没有被分配过**，现在想分配给指定节点\r\n\r\n· 2.插槽之前**被分配过**，现在想移动指定节点\r\n\r\n第一种情况可以通过cluster add slot s 命令来实现\r\n\r\n第二种情况的原理相对麻烦一点，但是redis也提供的便捷的方式去操作，我们可以使用redis-trib.rb去实现\r\n\r\n## **如何获取与插槽对应的节点？**\r\n\r\n当客户端向redis集群中的任意一个节点发送命令后，该节点都会判断当前键的信息是否存在于当前节点：\r\n\r\n· \r\n\r\n如果**存在**，那么就会像单机的reids一样执行命令。\r\n\r\n· \r\n\r\n· \r\n\r\n如果**不存在**，就会返回一个move重定向请求，告诉客户端负责该数据的节点是哪一个，然后客户端会向该节点发送命令再次请求获取数据\r\n\r\n· \r\n\r\n## **新节点的加入**\r\n\r\n需要通过cluster meet命令来实现:\r\n\r\ncluster meet ip port\r\n\r\nip port 是我们已运行的redis集群中**任意一个节点的地址和端口号**，新节点在客户端输入命令后，会与命令中的节点**进行握手**，握手后，命令中的集群节点会将这个新节点的**信息分享给集群**中的每一个节点。\r\n\r\n## **故障恢复**\r\n\r\n判断故障的逻辑其实与哨兵模式有点类似，在集群中，每个节点都会**定期的向其他节点发送ping命令**，通过有没有收到回复来判断其他节点是否已经下线。\r\n\r\n如果长时间没有回复，那么发起ping命令的节点就会认为目标节点疑似下线，也可以和哨兵一样称作主观下线，当然也需要集群中**一定数量的节点都认为该节点下线**才可以，我们来说说具体过程：\r\n\r\n· 1。当A节点发现目标节点**疑似下线**，就会向集群中的其他节点散播消息，其他节点就会向目标节点发送命令，判断目标节点是否下线\r\n\r\n· 2.如果集群中**半数以上**的节点都认为目标节点下线，就会对目标节点标记为下线，从而告诉其他节点，让目标节点在整个集群中都下线\r\n\r\n## **如何提高redis的读写能力**\r\n\r\n这个问题也是我们之前抛出来的问题，我们放一张图大家就会很容易明白了：\r\n\r\n![img](主从哨兵集群.assets/wps85B1.tmp.jpg) \r\n\r\n提高写能力只需要**横向扩容master**\r\n\r\n提高读能力只需要**横向扩容slave**\r\n\r\n## **结语**\r\n\r\n关于这三种部署的方式，基本上在我知道的公司都毫无疑问直接选择cluster模式，当然具体的选择还是要看公司的规模了，毕竟技术服务于业务，选择合适于当前业务的，就是最好的。\r\n\r\n "},cfe0:function(n,r,e){"use strict";e.r(r),r["default"]='# 《面试八股文》之Zookeeper12卷\r\n1.Zookeeper 是什么？能做什么？\r\n2.说说 Zookeeper 的数据结构吧\r\n3.Znode里面都存储了什么？\r\n4.Zookeeper 的系统架构又是怎么样的？\r\n5.那你继续给我讲讲 ZAB 协议吧\r\n6.Zookeeper初始化是如何进行Leader选举的？\r\n7.如果Leader挂了，进入崩溃恢复，怎么选举Leader？\r\n8.说说Wather监听机制和它的原理？\r\n9.Zookeeper有哪些特性呢？\r\n10.Zookeeper 如何识别请求的先后顺序？\r\n11.选举 leader 后是怎么进行数据同步的\r\n12.Zookeeper 会有数据不一致的情况发生吗？\r\n------\r\n## **1.Zookeeper 是什么？能做什么？**\r\nZookeeper 是一个**开源的**，是用于维护配置信息，命名，提供**分布式**同步和提供组服务的集中式服务。\r\n![img](《面试八股文》之Zookeeper12卷.assets/wpsC2.tmp.png) \r\n可以基于 Zookeeper 实现诸如**数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列**等功能。\r\n![img](《面试八股文》之Zookeeper12卷.assets/wpsC3.tmp.png) \r\nZookeeper 最常用的一个使用场景就是作为**注册中心**，生产者将自己提供的服务注册到 Zookeeper，然后消费者从 Zookeeper 中**拿到生产者的服务列表信息**，然后再去**调用生产者**的内容数据，比如 **Dubbo，Kafka** 都是使用 Zookeeper 作为注册中心的。\r\n## **2.说说 Zookeeper 的数据结构吧**\r\n![img](《面试八股文》之Zookeeper12卷.assets/wpsC4.tmp.png) \r\nZooKeeper 提供的名称空间与标准文件系统的名称空间非常相似。名称是由斜杠（“ /”）分隔的一系列路径元素。ZooKeeper 命名空间中的每个 znode 均由路径标识。**每个 znode 都有一个父对象**，其路径是 znode 的前缀，元素少一个；此规则的例外是 root（“ /”），它没有父项。此外，与标准文件系统完全一样，**如果 znode 有子节点，则无法删除它**。\r\nZooKeeper 与标准文件系统之间的主要区别在于，**每个 znode 都可以具有与之关联的数据**（每个文件也可以是目录，反之亦然），并且 znode 限于它们可以拥有的数据量。ZooKeeper 旨在存储协调数据：状态信息，配置，位置信息等。这种元信息通常以千字节（如果不是字节）来度量。**ZooKeeper 具有1M的内置完整性检查，以防止将其用作大型数据存储**，但是通常，它用于存储小得多的数据。\r\n![img](《面试八股文》之Zookeeper12卷.assets/wpsC5.tmp.png) \r\n**Znode的三种类型:**\r\n· **持久节点**（persistent node）节点会被持久\r\n· **临时节点**（ephemeral node），客户端断开连接后，ZooKeeper 会自动删除临时节点\r\n· **顺序节点**（sequential node），每次创建顺序节点时，ZooKeeper 都会在路径后面自动添加上10位的数字，从1开始，最大是2147483647 （2^32-1）\r\n![img](《面试八股文》之Zookeeper12卷.assets/wpsC6.tmp.png) \r\n**Znode的四种形式:**\r\n· **持久节点**:如 create /test/a  "hello"，通过 create参数指定为持久节点\r\n· **持久顺序节点**:通过 create -s参数指定为顺序节点\r\n· **临时节点**:通过 create -e参数指定为顺序节点\r\n· **临时顺序节点**:通过 create -s -e参数指定为临时及顺序节点\r\n## **3.Znode里面都存储了什么？**\r\nZnode包含了**存储数据(data)**、**访问权限(acl)**、**子节点引用(child)**、**节点状态信息(stat)**\r\n![img](《面试八股文》之Zookeeper12卷.assets/wpsC7.tmp.png) \r\n· **data**: znode存储的业务数据信息\r\n· **acl**: 记录客户端对znode节点的访问权限，如IP等。\r\n· **child**: 当前节点的子节点引用\r\n· **stat**: 包含Znode节点的状态信息，比如事务id、版本号、时间戳等等。\r\n## **4.Zookeeper 的系统架构又是怎么样的？**\r\n![img](《面试八股文》之Zookeeper12卷.assets/wpsC8.tmp.png) \r\nZooKeeper 分为**服务器端**（Server） 和**客户端**（Client），客户端可以连接到整个 ZooKeeper 服务的任意服务器上（除非 leaderServes 参数被显式设置，leader 不允许接受客户端连接），客户端使用并维护一个 **TCP 连接**，通过这个连接发送请求、接受响应、获取观察的事件以及发送信息。\r\n组成 ZooKeeper 服务的服务器必须彼此了解。它们维护一个内存中的状态图像，以及持久存储中的事务日志和快照，只要**大多数服务器可用，ZooKeeper 服务就可用**；\r\n![img](《面试八股文》之Zookeeper12卷.assets/wpsD8.tmp.png) \r\nZookeeper 集群中**Server有三种角色**，Leader、Follower 和 Observer\r\n· **Leader**:负责投投票的发起与决议，更新系统状态，写数据\r\n· **Follower**:用于接收客户端请求并用来返回结果，在选主过程中参与投票\r\n· **Observer**:可以接受客户端连接，将**写请求转发给leader**节点，但是不参与投票过程，只**同步leader状态**，主要存在目的就是**为了提高读取效率**\r\n将 server 分为三种是为了**避免太多的从节点参与过半写**的过程，导致影响性能，这样 Zookeeper 只要使用一个几台机器的小集群就可以实现高性能了，如果要横向扩展的话，只需要增加 Observer 节点即可。\r\nZookeeper 建议集群节点个数为奇数，只要**超过一半的机器**能够正常提供服务，那么整个集群都是可用的状态。\r\nZooKeeper 启动时，将从实例中选举一个 leader，**Leader 负责处理数据更新**等操作，一个更新操作成功的标志是当且仅当大多数 Server 在内存中成功修改数据。每个 Server 在内存中存储了一份数据。\r\nZookeeper 的数据一致性是依靠**ZAB协议**完成的。\r\n## **5.那你继续给我讲讲 ZAB 协议吧**\r\nZAB（ZooKeeper Atomic Broadcast 原子广播） 协议是为 ZooKeeper 特殊设计的一种**支持崩溃恢复**的原子广播协议。在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。\r\nZAB 协议包括有两种模式，分别是 **崩溃恢复和消息广播**。\r\n崩溃恢复:当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进人恢复模式并**选举产生新的 Leader** 服务器。当选举产生了新的 Leader 服务器，同时集群中已经有**过半的机器与该 Leader 服务器完成了状态同步**之后，ZAB 协议**就会退出恢复模式**。剩下未同步完成的机器会继续同步，**直到同步完成并加入集群后该节点的服务才可用**。\r\n消息广播:当集群中**已经有过半的 Follower 服务器完成了和 Leader 服务器的状态同步**，那么整个服务框架就可以**进人消息广播模式**了。当一台同样遵守 ZAB 协议的服务器启动后加人到集群中时，如果此时集群中**已经存在一个 Leader 服务器在负责进行消息广播**，那么新加人的服务器就会**自觉地进人数据恢复模式**：找到 Leader 所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。ZooKeeper 设计成**只允许唯一的一个 Leader 服务器来进行事务请求**的处理。Leader 服务器在接收到客户端的事务请求后，会生成对应的事务提案并发起一轮广播协议；而如果集群中的**其他机器接收到客户端的事务**请求，那么这些非 Leader 服务器会**首先将这个事务请求转发给 Leader** 服务器。\r\n## **6.Zookeeper初始化是如何进行Leader选举的？**\r\n![img](《面试八股文》之Zookeeper12卷.assets/wpsD9.tmp.png) \r\n在集群初始化阶段，只有两台以以上的 ZK 启动才会发生leader选举，过程如下：\r\n(1) **每个 Server 发出一个投票**。初始选举 ZK1 和 ZK2 都会将自己作为 Leader 服务器来进行投票，每次投票会包含所推举的服务器的(**myid, ZXID**)，此时 ZK1 的投票为(1, 0)，ZK2 的投票为(2, 0)，然后各自**将这个投票发给集群中其他机器**。\r\n(2) 收到投票。集群的每个服务器收到投票后，首先**判断**该投票的**有效性**，如检查是否是本轮投票、是否来自 LOOKING 状态的服务器。\r\n(3) 处理投票。每个发起投票的服务器需要**将别人的投票和自己的投票进行比较**，规则如下:\r\n§ 优先检查 ZXID。**ZXID 比较大的服务器优先作为 Leader**。**如果 ZXID 相同**，那么就比较 myid。**myid 较大的服务器作为Leader服务器**。\r\n(4) 统计投票。每次投票后，服务器都会统计投票信息，**判断是否已经有过半机器接受到相同的投票信息**，对于 ZK1、ZK2 而言，都统计出集群中已经有两台机器接受了(2, 0)的投票信息，此时便认为已经选出 ZK2 作为Leader。\r\n(5) 改变服务器状态。**一旦确定了 Leader，每个服务器就会更新自己的状态**，如果是Follower，那么就变更为 FOLLOWING，如果是 Leader，就变更为 LEADING。当新的 Zookeeper 节点 ZK3 启动时，发现已经有 Leader 了，不再选举，直接将直接的状态从 LOOKING 改为 FOLLOWING。\r\n## **7.如果Leader挂了，进入崩溃恢复，怎么选举Leader？**\r\n![img](《面试八股文》之Zookeeper12卷.assets/wpsDA.tmp.png) \r\n1.**变更状态**。Leader 挂后，余下的非 Observer 服务器都会讲自己的服务器状态变更为 LOOKING，然后开始进入 Leader 选举过程。\r\n2.每个**非 Observer** 的 Server 会**发出一个投票**。和启动过程一致。\r\n3.**接收**来自各个服务器的**投票**。与启动时过程相同。\r\n4.**处理投票**。与启动时过程相同。\r\n5.**统计投票**。与启动时过程相同。\r\n6.**改变服务器的状态**。与启动时过程相同。\r\n## **8.说说Wather监听机制和它的原理？**\r\n![img](《面试八股文》之Zookeeper12卷.assets/wpsDB.tmp.png) \r\n具体的步骤如下:\r\n· **服务注册**：Provider 启动时，会向 zookeeper 服务端**注册服务信息**，也就是创建一个节点。\r\n· **服务发现**：Consumer 启动时，根据自身配置的依赖服务信息，向 zookeeper 服务端获取注册的服务信息并**设置 watch 监听**，获取到注册的服务信息之后，将服务提供者的信息**缓存在本地**，并进行服务的调用。\r\n· **服务通知**：一旦服务提供者因某种原因宕机不再提供服务之后，客户端与 zookeeper **服务端断开**连接，zookeeper 服务端上服务提供者对应服务**节点会被删除**，随后 zookeeper 服务端会**异步向所有注册了该服务，且设置了 watch 监听的服务消费者**发出节点被删除的通知，消费者根据**收到的通知拉取最新服务列表**，**更新本地缓存**的服务列表。\r\n简单的理解就是 client 会对某个 znode 注册一个 watcher 事件，当该 **znode 发生变化**时，这些 client 会**收到 ZooKeeper 的通知**。\r\n四个特性：\r\n· 一次性：一旦一个Wather**触发**之后，Zookeeper**就会**将它从存储中**移除**，**如果还要继续监听**这个节点，就**需要**我们在客户端的监听回调中，**再次**对节点的监听watch事件**设置为True**。否则客户端只能接收到一次该节点的变更通知\r\n· 客户端串行：客户端的**Wather回调处理是串行同步**的过程，不要因为一个Wather的逻辑阻塞整个客户端\r\n· 轻量：Wather通知的单位是WathedEvent，**只包含通知状态、事件类型和节点路径，不包含具体的事件内容**，具体的时间内容需要客户端主动去重新获取数据\r\n· 异步:  Zookeeper服务器**发送watcher的通知事件到客户端是异步**的，不能期望能够监控到节点每次的变化，Zookeeper只能保证最终的一致性，而无法保证强一致性。\r\n## **9.Zookeeper有哪些特性呢？**\r\n![img](《面试八股文》之Zookeeper12卷.assets/wpsDC.tmp.png) \r\n· **顺序一致性**：leader会根据请求顺序生成 ZXID 来严格保证请求顺序的下发执行。\r\n· **原子性**：所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，要么成功，要么就失败。\r\n· **单一视图**：无论客户端连到哪一个 ZooKeeper 服务器上，看到的数据都是一致的。\r\n· **可靠性**：一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会被一直保留下来。\r\n· **实时性**：Zookeeper 仅仅能保证在段时间内客户端最终一定能够从服务端上读取到最新的数据状态。\r\n## **10.Zookeeper 如何识别请求的先后顺序？**\r\n![img](《面试八股文》之Zookeeper12卷.assets/wpsDD.tmp.png) \r\nLeader 收到请求之后，会将每个请求分配一个全局唯一递增的事务ID：zxid，然后把请求放入到一个 **FIFO 的队列**中，之后就会按照 FIFO 的策略发送给所有的 Follower。\r\n## **11.选举 leader 后是怎么进行数据同步的**\r\n![img](《面试八股文》之Zookeeper12卷.assets/wpsDE.tmp.png) \r\n前面提到写数据是由 leader 负责的，而 leader 会将每个请求分配一个 ZXID，放入一个队列中，依次执行，每次 leader  执行完一个请求后，会记录下执行的这个 ZXID。\r\n我们将这个队列中最大的 ZXID 称为 **maxZXID**，最小的 ZXID 称为 **minZXID**。\r\n将 Observer 和 follower 中最新的 ZXID **称为lastSyncZXID**\r\n**proposal :** **l其实就是将请求中的一些信息如请求头，请求体以及 ZXID 等信息封装到 proposal对象当中**\r\n**1.差异化同步**\r\n§ 1).leader 向 Observer 和 follower 发送 DIFF 指令，之后就开始差异化同步\r\n§ 2).然后把差异数据 提议 proposal 发送给 Observer 和 follower , Observer 和 follower 返回ACK表示已经完成了同步\r\n§ 3).只要集群中过半的 Observer 和 follower 响应了 ACK 就发送一个 UPTODATE 命令\r\n§ 4).leader 返回 ACK，同步流程结束\r\n§ \r\n**触发条件**:minZXID < lastSyncZXID < maxZXID\r\n§ \r\n§ \r\n**同步过程**:\r\n§ \r\n**2.回滚同步**\r\n§ 1).直接回滚到 maxZXID\r\n§ **触发条件** maxZXID < lastSyncZXID\r\n§ **举个例子**：a，b，c三台服务服务器 a是leader，此时队列里面最大的 ZXID 为100，a 收到请求，该 ZXID 为101，还没来得及发送同步数据 a 就挂了，b 变为leader，然后 a 恢复了，此时就需要 a 先将之前 ZXID 为101的数据回滚\r\n§ **同步过程**:\r\n**3.回滚+差异化同步**\r\n§ 1).Observer 和 follower 将数据回滚\r\n§ 2).进行差异化同步\r\n§ **触发条件**:如果Leader刚生成一个proposal，还没有来得及发送出去，此时Leader宕机，重新选举之后作为Follower，但是新的Leader没有这个proposal数据\r\n§ **举个例子**：a，b，c三台服务服务器 a是leader，此时队列里面最大的 ZXID 为100，a 收到请求，该 ZXID 为101，还没来得及发送同步数据 a 就挂了，b 变为leader，b 又处理了3个请求，则 b 队列中最大的 ZXID 为103，然后 a 恢复了，此时就需要 a 先将之前 ZXID 为101的数据回滚，再进行同步\r\n§ **同步过程**:\r\n**4.全量同步**\r\n§ 1).lastSyncZXID < minZXID\r\n§ 2).Leader服务器上没有缓存队列，并且lastSyncZXID!=maxZXID\r\n§ **触发条件**\r\n§ **同步过程**：leader 向 Observer 和 follower 发送SNAP命令，进行数据全量同步\r\n## **12.Zookeeper 会有数据不一致的情况发生吗？**\r\n还是会有的，因为 Zookeeper 采用的是**过半写**机制，意味着**3台服务器只要有两台写成功就代表整个集群写成功**，如果刚好有请求打在这台还**未写的服务器**上就查询不到该数据，就会有数据不一致的情况产生。\r\n'},d03b:function(n,r,e){"use strict";e.r(r),r["default"]='# jvm垃圾回收\r\n\r\n垃圾是怎么找到的？\r\nOopMap有什么作用？\r\n为什么需要STW？\r\n记忆集有什么作用？\r\n常用的7种垃圾回收器都有哪些？？\r\n三色标记算法？\r\nCMS为什么会产生碎片化？\r\nG1居然会引起Full GC？\r\n......\r\n\r\n## **垃圾对象是怎么找到的？**\r\n\r\n### **引用计数算法**\r\n\r\n就是给对象添加一个计数器\r\n\r\no 每当有一个地方引用它的时候，计数器就加1\r\n\r\no 每当有一个引用失效的时候，计数器就减1\r\n\r\n**「当计数器的值为0的时候，那么该对象就是垃圾了」**\r\n\r\n这种方案的原理很简单，而且判定的效率也非常高，但是却可能会有其他的额外情况需要考虑。![img](jvm垃圾回收.assets/wps2F0C.tmp.png)\r\n\r\n比如两个**「对象循环引用」**，a对象引用了b对象，b对象也引用了a对象，a、b对象却没有再被其他对象所引用了，其实正常来说这两个对象已经是垃圾了，因为没有其他对象在使用了，但是计数器内的数值却不是0，所以引用计数算法就无法回收它们。\r\n\r\n这种算法是比较**「直接的找到垃圾」**，然后去回收，也被称为"直接垃圾收集"。\r\n\r\n### **根可达算法**\r\n\r\n这也是**「jvm默认使用」**的寻找垃圾算法\r\n\r\n它的原理就是定义了一系列的根，我们把它称为 **「"GC Roots"」** ，从 **「"GC Roots"」** 开始往下进行搜索，走过的路径我们把它称为 **「"引用链"」** ，当一个对象到 **「"GC Roots"」** 之间没有任何引用链相连时，那么这个对象就可以被当做垃圾回收了。\r\n\r\n![img](jvm垃圾回收.assets/wps2F0D.tmp.png) \r\n\r\n如图，**「根可达算法」**就可以**「避免」**计数器算法不好解决的**「循环引用问题，Object 6、Object 7、Object 8」**彼此之前有引用关系，但是没有与 **「"GC Roots"」** 相连，那么就会被当做垃圾所回收。\r\n\r\n在java中，有**「固定的GC Roots 对象」**和**「不固定的临时GC Roots对象:」**\r\n\r\n**「固定的GC Roots:」**\r\n\r\no 1.在**「虚拟机栈(栈帧的本地变量表)中所引用的对象」**，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。\r\n\r\no 在方法区中**「类静态属性引用的对象」**，譬如 Java 类的引用静态变量。\r\n\r\no 在方法区中**「常量引用的对象」**，譬如字符串常量池中的引用。\r\n\r\no 在方法区栈中 **「JNI (譬如 Native 方法)引用的对象」**。\r\n\r\no Java **「虚拟机内部的引用」**，如基本数据类型对应的 Class 对象，一些常驻的异常对象(空指针异常、OOM等)，还有类加载器。\r\n\r\no 所有**「被 Synchronized 持有的对象」**。\r\n\r\no 反应 Java 虚拟机内部情况的 **「JMXBean、JVMTI 中注册的回调本地代码缓存等」**。\r\n\r\n**「临时GC Roots:」**\r\n\r\n**「为什么会有临时的 GC Roots ？」**\r\n\r\n目前的垃圾回收大部分都是**「分代收集和局部回收」**，如果只针对某一部分区域进行局部回收，那么就必须要考虑的**「当前区域的对象有可能正被其他区域的对象所引用」**，这时候就要将这部分关联的对象也添加到 GC Roots 中去来确保根可达算法的准确性。\r\n\r\n这种算法是利用了**「逆向思维」**，找到使用的对象，剩下的就是垃圾，也被称为"间接垃圾收集"。\r\n\r\n## **四种引用类型**\r\n\r\n### **强引用**\r\n\r\n"Object o = new Object()" 就是一种强引用关系，这也是我们在代码中最常用的一种引用关系。\r\n\r\n无论任何情况下，只要强引用关系还存在，垃圾回收器就不会回收掉被引用的对象。\r\n\r\n### **软引用**\r\n\r\n当内存空间不足时，就会回收软引用对象。\r\n\r\nString str = new String("abc");\r\n**// 软引用**\r\nSoftReference<String> softRef = new SoftReference<String>(str);\r\n\r\n软引用用来描述那些有用但是没必要的对象。\r\n\r\n### **弱引用**\r\n\r\n弱引用要比软引用更弱一点，它**「只能够存活到下次垃圾回收之前」**。\r\n\r\n也就是说，垃圾回收器开始工作，会回收掉所有只被弱引用关联的对象。\r\n\r\n**//弱引用**\r\nWeakReference<String> weakRef = new WeakReference<String>(str);\r\n\r\n在ThreadLocal中就使用了弱引用来防止内存泄漏。\r\n\r\n### **虚引用**\r\n\r\n虚引用是最弱的一种引用关系，它的唯一作用是用来作为一种通知。\r\n\r\n如零拷贝(Zero Copy)，开辟了堆外内存，虚引用在这里使用，会将这部分信息存储到一个队列中，以便于后续对堆外内存的回收管理。\r\n\r\n## **分代收集理论**\r\n\r\n大多数的垃圾回收器都遵循了分代收集的理论进行设计，它建立在两个分代假说之上:\r\n\r\no **「弱分代假说」**:绝大多数对象都是朝升夕灭的。\r\n\r\no **「强分代假说」**:熬过越多次数垃圾回收过程的对象就越难消亡。\r\n\r\n这两种假说的设计原则都是相同的:\r\n\r\n垃圾收集器**「应该将jvm划分出不同的区域」**，把那些较难回收的对象放在一起（一般指老年代），这个区域的垃圾回收频率就可以降低，减少垃圾回收的开销。剩下的区域(一般指新生代)可以用较高的频率去回收，并且只需要去关心那些存活的对象，也不用标记出需要回收的垃圾，这样就能够以较低的代价去完成垃圾回收。\r\n\r\no **「跨代引用假说」**：如果某个新生代的对象存在了跨代引用，但是老年代的对象是很难消亡的，那么随着时间的推移，这个新生代对象也会慢慢晋升为老年代对象，那么这种跨代引用也就被消除了。\r\n\r\n由于跨代引用是很少的，所以我们不应该为了少量的跨代引用去扫描整个老年代的数据，只需要在新生代对象建立一个**「记忆集」**来记录引用信息。\r\n\r\n记忆集:**「将老年代分为若干个小块，每块区域中有N个对象」**，在对象引用信息发生变动的时候来维护记忆集数据的准确性，这样每次发生了 **「"Minor GC"」** 的时候只需要将记忆集中的对象添加到 **「"GC Roots"」** 中就可以了。\r\n\r\n## **三种垃圾收集算法**\r\n\r\n### **标记清除算法**\r\n\r\n这种算法的实现是很简单的，有两种方式\r\n\r\no 1.标记出垃圾，然后清理掉\r\n\r\no 2.标记出存货的对象，回收其他空间\r\n\r\n![img](jvm垃圾回收.assets/wps2F0E.tmp.png) \r\n\r\n这种算法有两个缺点\r\n\r\no 1.随着对象越来越多，那么所需要消耗的时间就会越来越多\r\n\r\no 2.标记清除后会导致碎片化，如果有大对象分配很有可能分配不下而出发另一次的垃圾收集动作\r\n\r\n### **标记复制算法**\r\n\r\n这种算法解决了第一种算法碎片化的问题。\r\n\r\n就是**「开辟两块完全相同的区域」**，对象只在其中一篇区域内分配，然后**「标记」**出那些**「存活的对象，按顺序整体移到另外一个空间」**，如下图，可以看到回收后的对象是排列有序的，这种操作只需要移动指针就可以完成，效率很高，**「之后就回收移除前的空间」**。\r\n\r\n![img](jvm垃圾回收.assets/wps2F0F.tmp.png) \r\n\r\n这种算法的缺点也是很明显的\r\n\r\no 浪费过多的内存，使现有的**「可用空间变为」**原先的**「一半」**\r\n\r\n### **标记整理算法**\r\n\r\n这种算法可以说是结合了前两种算法，既有标记删除，又有整理功能。\r\n\r\n![img](jvm垃圾回收.assets/wps2F20.tmp.png) \r\n\r\n这种算法就是通过标记清除算法找到存活的对象，然后将所有**「存活的对象，向空间的一端移动」**，然后回收掉其他的内存。\r\n\r\n但是这种算法却有一个缺点，就是在移动对象的时候必须要暂停用户的应用程序(**「STW」**)才能移动。\r\n\r\n## **STW**\r\n\r\nJava 中**「Stop-The-World机制简称 STW」** ，是在执行垃圾收集算法时，Java 应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。Java 中一种全局暂停现象，全局停顿，所有 Java 代码停止，native 代码可以执行，但不能与 JVM 交互。\r\n\r\n### **为什么需要STW**\r\n\r\n在 java 应用程序中**「引用关系」**是不断发生**「变化」**的，那么就会有会有很多种情况来导致**「垃圾标识」**出错。\r\n\r\n想想一下如果 Object a  目前是个垃圾，GC 把它标记为垃圾，但是在清除前又有其他对象指向了 Object a，那么此刻 Object a 又不是垃圾了，那么如果没有 STW 就要去无限维护这种关系来去采集正确的信息。\r\n\r\n再举个例子，到了秋天，道路上洒满了金色的落叶，环卫工人在打扫街道，却永远也无法打扫干净，因为总会有不断的落叶。\r\n\r\n## **垃圾回收器是怎样寻找 GC Roots 的？**\r\n\r\n我们在前面说明了根可达算法是通过 GC Roots 来找到存活的对象的，也定义了 GC Roots，那么垃圾回收器是怎样寻找GC Roots 的呢？\r\n\r\n首先，**「为了保证结果的准确性，GC Roots枚举时是要在STW的情况下进行的」**，但是由于java应用越来越大，所以也不能逐个检查每个对象是否为GC Root，那将消耗大量的时间。\r\n\r\n一个很自然的想法是，能不能用空间换时间，在某个时候把栈上代表引用的位置全部记录下来，这样到真正 gc 的时候就可以直接读取，而不用再一点一点的扫描了。事实上，大部分主流的虚拟机也正是这么做的，比如 HotSpot ，它使用一种叫做 **「OopMap」** 的数据结构来记录这类信息。\r\n\r\n### **OopMap**\r\n\r\n我们知道，一个线程意味着一个栈，一个栈由多个栈帧组成，一个栈帧对应着一个方法，一个方法里面可能有多个安全点。gc 发生时，程序首先运行到最近的一个安全点停下来，然后更新自己的 OopMap ，记下栈上哪些位置代表着引用。枚举根节点时，递归遍历每个栈帧的 OopMap ，通过栈中记录的被引用对象的内存地址，即可找到这些对象（ GC Roots ）。\r\n\r\n使用 OopMap 可以**「避免全栈扫描」**，加快枚举根节点的速度。但这并不是它的全部用意。它的另外一个更根本的作用是，可以帮助 HotSpot 实现准确式 GC (即使用准确式内存管理，虚拟机可用知道内存中某个位置的数据具体是什么类型) 。\r\n\r\n### **安全点**\r\n\r\n从线程角度看，安全点可以理解成是在**「代码执行过程中」**的一些**「特殊位置」**，当线程执行到这些位置的时候，说明**「虚拟机当前的状态是安全」**的。\r\n\r\n比如：**「方法调用、循环跳转、异常跳转等这些地方才会产生安全点」**。\r\n\r\n如果有需要，可以在这个位置暂停，比如发生GC时，需要暂停所有活动线程，但是线程在这个时刻，还没有执行到一个安全点，所以该线程应该继续执行，到达下一个安全点的时候暂停，等待GC结束。\r\n\r\n那么如何让线程在垃圾回收的时候都跑到最近的安全点呢？这里有**「两种方式」**：\r\n\r\no 抢先式中断\r\n\r\no 主动式中断\r\n\r\n抢先式中断：就是在stw的时候，先让所有线程**「完全中断」**，如果中断的地方不在安全点上，然后**「再激活」**，**「直到运行到安全点的位置」**再中断。\r\n\r\n主动式中断：在安全点的位置打一个标志位，每个线程执行都去轮询这个标志位，如果为真，就在最近的安全点挂起。\r\n\r\n但是如果有些线程处于sleep状态怎么办呢？\r\n\r\n### **安全区域**\r\n\r\n为了解决这种问题，又引入了安全区域的概念\r\n\r\n安全区域是指**「在一段代码片中，引用关系不会发生改变」**，实际上就是一个安全点的拓展。当线程执行到安全区域时，首先标识自己已进入安全区域，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为“安全区域”状态的线程了，该线程只能乖乖的等待根节点枚举完或者整个GC过程完成之后才能继续执行。\r\n\r\n## **聊聊垃圾回收器**\r\n\r\n前面和大家聊了很多垃圾收集算法，所以在真正实践的时候会有多种选择，垃圾回收器就是真正的实践者，接下来就和大家聊聊10种垃圾回收器\r\n\r\n![img](jvm垃圾回收.assets/wps2F21.tmp.png) \r\n\r\n### **Serial**\r\n\r\nSerial是一个**「单线程」**的垃圾回收器，**「采用复制算法负责新生代」**的垃圾回收工作，可以与CMS垃圾回收器一起搭配工作。\r\n\r\n![img](jvm垃圾回收.assets/wps2F22.tmp.png) \r\n\r\n在STW的时候**「只会有一条线程」**去进行垃圾收集的工作，所以可想而知，它的效率会比较慢。\r\n\r\n但是他确是所有垃圾回收器里面消耗额外内存最小的，没错，就是因为简单。\r\n\r\n### **ParNew**\r\n\r\nParNew 是一个**「多线程」**的垃圾回收器，**「采用复制算法负责新生代」**的垃圾回收工作，可以与CMS垃圾回收器一起搭配工作。\r\n\r\n![img](jvm垃圾回收.assets/wps2F23.tmp.png) \r\n\r\n它其实就是 Serial 的多线程版本，主要区别就是在 STW 的时候可以用多个线程去清理垃圾。\r\n\r\n### **Pararllel Scavenge**\r\n\r\nPararllel Scavenge 是一个**「多线程」**的垃圾回收器，**「采用复制算法负责新生代」**的垃圾回收工作，可以与 Serial Old ， Parallel Old 垃圾回收器一起搭配工作。\r\n\r\n![img](jvm垃圾回收.assets/wps2F24.tmp.png) \r\n\r\n是与ParNew类似，都是用于年轻代回收的使用复制算法的并行收集器，与ParNew不同的是，Parallel Scavenge的**「目标是达到一个可控的吞吐量」**。\r\n\r\n吞吐量=程序运行时间/（程序运行时间+GC时间）。\r\n\r\n如程序运行了99s，GC耗时1s，吞吐量=99/（99+1）=99%。Parallel Scavenge提供了两个参数用以精确控制吞吐量，分别是用以控制最大GC停顿时间的-XX:MaxGCPauseMillis及直接控制吞吐量的参数-XX:GCTimeRatio.\r\n\r\n**「停顿时间越短就越适合需要与用户交互的程序」**，良好的响应速度能提升用户体验，而高吞吐量则可以高效的利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。\r\n\r\n### **Serial Old**\r\n\r\nSerial Old 是一个**「单线程」**的垃圾回收器，**「采用标记整理算法负责老年代」**的垃圾回收工作，有可能还会配合 **「CMS」** 一起工作。\r\n\r\n![img](jvm垃圾回收.assets/wps2F25.tmp.png) \r\n\r\n其实它就是 Serial 的老年代版本，整体链路和 Serial 大相径庭。\r\n\r\n### **Parallel Old**\r\n\r\nParallel Old 是一个**「多线程」**的垃圾回收器，**「采用标记整理算法负责新生代」**的垃圾回收工作，可以与 Parallel Scavenge 垃圾回收器一起搭配工作。\r\n\r\n![img](jvm垃圾回收.assets/wps2F36.tmp.png) \r\n\r\nParallel Old 是 Pararllel Scavenge 的老年代版本，它的设计思路也是以吞吐量优先的，ps+po也是很常用的一种组合。\r\n\r\n### **CMS**\r\n\r\nCMS可以说是一款具有"跨时代"意义的垃圾回收器，支持了和用户线程一起工作，做到了**「一起并发回收垃圾」**的"壮举"。\r\n\r\n![img](jvm垃圾回收.assets/wps2F37.tmp.png) \r\n\r\no 1.初始标记\r\n\r\n§ 初始标记只是标记出来**「和 GC Roots 直接关联」**的对象，整个速度是非常快的，为了保证标记的准确，这部分会在 **「STW」** 的状态下运行。\r\n\r\no 2.并发标记\r\n\r\n§ 并发标记这个阶段会直接根据第一步关联的对象找到**「所有的引用」**关系，这一部分时刻用户线程**「并发运行」**的，虽然耗时较长，但是不会有很大的影响。\r\n\r\no 3.重新标记\r\n\r\n§ 重新标记是为了解决第二步并发标记所导致的标错情况，这里简单举个例子：并发标记时a没有被任何对象引用，此时垃圾回收器将该对象标位垃圾，在之后的标记过程中，a又被其他对象引用了，这时候如果不进行重新标记就会发生**「误清除」**。\r\n\r\n§ 这部分内容也是在 **「STW」** 的情况下去标记的。\r\n\r\no 4.并发清除\r\n\r\n§ 这一步就是最后的清除阶段了，将之前**「真正确认为垃圾的对象回收」**，这部分会和用户线程一起并发执行。\r\n\r\nCMS的**「三个缺点」**：\r\n\r\no 1.影响用户线程的执行效率\r\n\r\n§ CMS默认启动的回收线程数是（处理器核心数 + 3）/ 4 ,由于是和用户线程一起并发清理，那么势必会影响到用户线程的执行速度，并且这个影响**「随着核心线程数的递减而增加」**。所以 JVM 提供了一种 "**「增量式并发收集器」**"的 CMS 变种，主要是用来减少垃圾回收线程独占资源的时间，所以会感觉到回收时间变长，这样的话**「单位时间内处理垃圾的效率就会降低」**，也是一种缓和的方案。\r\n\r\no 2.会产生"浮动垃圾"\r\n\r\n§ 之前说到 CMS 真正清理垃圾是和用户线程一起进行的，在**「清理」**这部分垃圾的时候**「用户线程会产生新的垃圾」**，这部分垃圾就叫做浮动垃圾，并且只能等着下一次的垃圾回收再清除。\r\n\r\no 3.会产生碎片化的空间\r\n\r\n§ CMS 是使用了标记删除的算法去清理垃圾的，而这种算法的缺点就是会产生**「碎片化」**，后续可能会**「导致大对象无法分配」**从而触发**「和 Serial Old 一起配合使用」**来处理碎片化的问题，当然这也处于 **「STW」** 的情况下，所以当 java 应用非常庞大时，如果采用了 CMS 垃圾回收器，产生了碎片化，那么在 STW 来处理碎片化的时间会非常之久。\r\n\r\n### **G1**\r\n\r\nG1(Garbage First)：顾名思义，**「垃圾回收第一」**，官方对它的评价是在垃圾回收器技术上具有**「里程碑式」**的成果。\r\n\r\nG1回收的目标不再是整个新生代，不再是整个老年代，也不再是整个堆了。G1可以**「面向堆内存的任何空间来进行」**回收，衡量的标准也不再是根据年代来区分，而是哪块**「空间的垃圾最多就回收哪」**块儿空间，这也符合G1垃圾回收器的名字，垃圾第一，这就是G1的 **「Mixed GC」** 模式。\r\n\r\n当然我的意思是**「垃圾回收不根据年代来区分」**，但是G1还是**「根据年代来设计」**的，我们先来看下G1对于堆空间的划分：\r\n\r\n![img](jvm垃圾回收.assets/wps2F38.tmp.png) \r\n\r\nG1 垃圾回收器把堆划分成一个个**「大小相同的Region」**，每个 Region 都会扮演一个角色，H、S、E、O。\r\n\r\nE代表伊甸区，S代表 Survivor 区，H代表的是 Humongous(G1用来分配**「大对象的区域」**，对于 Humongous 也分配不下的超大对象，会分配在连续的N个 Humongous 中)，剩余的深蓝色代表的是 Old 区，灰色的代表的是空闲的 region。\r\n\r\n在 HotSpot 的实现中，整个堆被划分成2048左右个 Region。每个 Region 的大小在1-32MB之间，具体多大取决于堆的大小。\r\n\r\n在并发标记垃圾时也会产生新的对象，G1对于这部分对象的处理是这样的：\r\n\r\n将 Region **「新增一块并发回收过程中分配对象的空间」**，并为此设计了两个 TAMS(Top at Mark Start)指针，这块区域专门用来在并发时分配新对象，有对象新增只需要将 TAMS 指针移动下就可以了，并且这些**「新对象默认是标记为存活」**，这样就**「不会干扰到标记过程」**。\r\n\r\n![img](jvm垃圾回收.assets/wps2F39.tmp.png) \r\n\r\n但是这种方法也会有个问题，有可能**「垃圾回收的速度小于新对象分配的速度」**，这样会导致 "Full GC" 而产生长时间的 STW。\r\n\r\n在 G1 的设计理念里，**「最小回收单元是 Region」** ，每次回收的空间大小都是Region的N倍，那么G1是**「怎么选择要回收哪块儿区域」**的呢？\r\n\r\nG1 会跟踪各个 Region 区域内的垃圾价值，和回收空间大小回收时间有关，然后**「维护一个优先级列表」**，来收集那些价值最高的Reigon区域。\r\n\r\n#### **执行的步骤：**\r\n\r\no 初始标记：\r\n\r\n§ 标记出来 GC Roots 能**「直接关联」**到的对象\r\n\r\n§ 修改 TAMS 的值以便于并发回收时新对象分配\r\n\r\n§ 是在 Minor GC 时期(**「STW」**)完成的\r\n\r\no 并发标记：\r\n\r\n§ 根据刚刚关联的对像扫描整个对象引用图，和用户线程**「并发执行」**\r\n\r\n§ 记录 SATB(原始快照) 在并发时有引用的值\r\n\r\no 最终标记：\r\n\r\n§ 处于 **「STW」**，处理第二步遗留下来的少量 SATB(原始快照) 记录\r\n\r\no 筛选回收：\r\n\r\n§ 维护之前提到的优先级列表\r\n\r\n§ 根据**「优先级列表」**，**「用户设置的最大暂停时间」**来回收 Region\r\n\r\n§ 将需要回收的 Region 内存活的对象**「复制」**到不需要回收的 Region区域内，然后回收需要回收的 Region\r\n\r\n§ 这部分是处于 **「STW」** 下执行，并且是多线程的\r\n\r\n#### **三色标记**\r\n\r\n这里我们又提到了一个概念叫做 **「SATB 原始快照」**，关于SATB会延伸出有一个概念，**「三色标记算法」**，也就是垃圾回收器标记垃圾的时候使用的算法，这里我们简单说下：\r\n\r\n将对象分为**「三种颜色」**：\r\n\r\no 白色：没被 GC 访问过的对象(被 GC 标记完后还是白色代表是垃圾)\r\n\r\no 黑丝：存活的对象\r\n\r\no 灰色：被 GC 访问过的对象，但是对象引用链上至少还有一个引用没被扫描过\r\n\r\n我们知道在**「并发标记」**的时候**「可能会」**出现**「误标」**的情况，这里举两个例子：\r\n\r\no 1.刚开始标记为**「存活」**的对象，但是在并发标记过程中**「变为了垃圾对象」**\r\n\r\no 2.刚开始标记为**「垃圾」**的对象，但是在并发标记过程中**「变为了存活对象」**\r\n\r\n第一种情况影响还不算很大，只是相当于垃圾没有清理干净，待下一次清理的时候再清理一下就好了。\r\n\r\n第二种情况就危险了，正在使**「用的对象的突然被清理掉」**了，后果会很严重。\r\n\r\n那么**「产生上述第二种情况的原因」**是什么呢？\r\n\r\no 1.**「新增」**一条或多条**「黑色到白色」**对象的**新引用\r\n\r\no 2.删除**「了」**灰色**「对象」**到该白色对象**「的直接」**引用**或间接引用。\r\n\r\n当这两种情况**「都满足」**的时候就会出现这种问题了。\r\n\r\n所以为了解决这个问题，引入了**「增量更新」**(Incremental Update)和**「原始快照」**(SATB)的方案：\r\n\r\n增量更新破坏了第一个条件：**「增加新引用时记录」**该引用信息，在后续 STW 扫描中重新扫描(CMS的使用方案)。\r\n\r\n原始快照破坏了第二个条件：**「删除引用时记录下来」**，在后续 STW 扫描时将这些记录过的灰色对象为根再扫描一次(G1的使用方案)。\r\n\r\n## **结尾的唠叨**\r\n\r\n今天聊的这些东西应该能够帮你把堆垃圾回收的整体链路打通，其实关于垃圾回收器，我们这里只介绍了最常用的7中，是因为剩下的 Shenandoah，ZGC，Epsilon这些垃圾回收器，每个拿出来讲解都是可以单独成一篇文章的(其实是我也没有太深入了解哈哈，还不能够写成文章)，作者这里就不再添加到这篇文章了，后续有机会我会单独成文去写这些垃圾回收器。\r\n\r\n '},d1e8:function(n,r,e){"use strict";e.r(r),r["default"]=" \r\n\r\nhttps://github.com/Meituan-Dianping/Logan\r\n\r\nhttp://caibaojian.com/some-fe\r\n\r\nhttps://www.jianshu.com/p/91cf0071c1f6\r\n\r\nhttps://www.infoq.cn/article/event-tracking-in-zhihu\r\n\r\n"},da8d:function(n,r,e){"use strict";e.r(r),r["default"]='# 《面试八股文》之 Kafka 21卷\r\n· \r\n1.什么是消息中间件？\r\n2.kafka 是什么？有什么作用？\r\n3.kafka 的架构是怎么样的？\r\n4.Kafka Replicas是怎么管理的？\r\n5.如何确定当前能读到哪一条消息？\r\n6.生产者发送消息有哪些模式？\r\n7.发送消息的分区策略有哪些？\r\n8.Kafka 支持读写分离吗？为什么？\r\n9.那 Kafka 是怎么去实现负载均衡的？\r\n10.Kafka 的负责均衡会有什么问题呢？\r\n11.Kafka 的可靠性是怎么保证的？\r\n12.Kafka 的消息消费方式有哪些？\r\n13.分区再分配是做什么的？解决了什么问题？\r\n14.副本 leader 是怎么选举的？\r\n15.分区数越多越好吗？吞吐量就会越高吗？\r\n16.如何增强消费者的消费能力？\r\n17.消费者与 topic 的分区分配策略有哪些？\r\n18.kafka 控制器是什么？有什么作用\r\n19.kafka 控制器是怎么进行选举的？\r\n20.kafka 为什么这么快？\r\n21.什么情况下 kafka 会丢失消息？\r\n## **1.什么是消息中间件？**\r\n消息中间件是基于队列与消息传递技术，在网络环境中为应用系统提供**同步或异步、可靠的**消息传输的支撑性软件系统。\r\n消息中间件利用**高效可靠**的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。\r\n## **2.kafka 是什么？有什么作用？**\r\nKafka 是一个分布式的流式处理平台，它以高吞吐、可持久化、可水平扩展、支持流数据处理等多种特性而被广泛使用\r\n![img](《面试八股文》之 Kafka 21卷.assets/wpsC919.tmp.png) \r\n主要功能体现于三点：\r\n· **消息系统**：kafka与传统的消息中间件都具备**系统解耦、冗余存储、流量削峰、缓冲、异步通信、扩展性、可恢复性**等功能。与此同时，kafka还提供了大多数消息系统难以实现的消息顺序性保障及回溯性消费的功能。\r\n· **存储系统**：kafka把**消息持久化到磁盘**，相比于其他基于内存存储的系统而言，有效的降低了消息丢失的风险。这得益于其消息持久化和多副本机制。也可以将kafka作为长期的存储系统来使用，只需要把对应的数据保留策略设置为“永久”或启用主题日志压缩功能。\r\n· **流式处理平台**：kafka为流行的流式处理框架提供了可靠的数据来源，还提供了一个完整的流式处理框架，比如窗口、连接、变换和聚合等各类操作。\r\n## **3.kafka 的架构是怎么样的？**\r\n![img](《面试八股文》之 Kafka 21卷.assets/wpsC91A.tmp.png) \r\n一个典型的 kafka 体系架构包括若干 **Producer**、若干 **Consumer**、以及一个 **Zookeeper** 集群（在2.8.0版本中移，除了 Zookeeper,通过 **KRaft** 进行自己的集群管理）\r\nProducer 将消息发送到 Broker，Broker 负责将受到的消息存储到磁盘中，而 Consumer 负责从 Broker 订阅并消费消息。\r\nKafka 基本概念：\r\n· **Producer** ：生产者，负责将消息发送到 Broker\r\n· **Consumer** ：消费者，从 Broker 接收消息\r\n· **Consumer Group** ：消费者组，由**多个 Consumer 组成**。消费者组内每个消费者负责消费不同分区的数据，**一个分区只能由一个组内消费者消费**；消费者组之间互不影响。所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。\r\n· **Broker** ：可以看做一个独立的 **Kafka 服务节点或 Kafka 服务实例**。如果一台服务器上只部署了一个 Kafka 实例，那么我们也可以将 Broker 看做一台 Kafka 服务器。\r\n· **Topic** ：一个逻辑上的概念，包含很多 Partition，**同一个 Topic 下的 Partiton 的消息内容是不相同的**。\r\n· **Partition** ：为了实现扩展性，一个非常大的 topic **可以分布到多个 broker 上，一个 topic 可以分为多个 partition**，每个 partition 是一个有序的队列。\r\n· **Replica** ：副本，**同一分区的不同副本保存的是相同的消息**，为保证集群中的某个节点发生故障时，该节点上的 partition 数据不丢失，且 kafka 仍然能够继续工作，kafka 提供了副本机制，一个 topic 的每个分区都有若干个副本，一个 leader 和若干个 follower。\r\n· **Leader** ：每个分区的多个副本中的"主副本"，**生产者以及消费者只与 Leader 交互**。\r\n· **Follower** ：每个分区的多个副本中的"从副本"，**负责实时从 Leader 中同步数据，保持和 Leader 数据的同步**。Leader 发生故障时，从 Follower 副本中重新选举新的 Leader 副本对外提供服务。\r\n## **4.Kafka Replicas是怎么管理的？**\r\n![img](《面试八股文》之 Kafka 21卷.assets/wpsC91B.tmp.png) \r\n· AR:分区中的**所有 Replica 统称为 AR**\r\n· ISR:所有与 Leader 副本**保持一定程度同步**的Replica(包括 Leader 副本在内)组成 ISR\r\n· OSR:与 Leader 副本**同步滞后过多的** Replica 组成了 OSR\r\nLeader 负责维护和跟踪 ISR 集合中所有 Follower 副本的滞后状态，当 Follower 副本落后过多时，就会将其放入 OSR 集合，当 Follower 副本追上了 Leader 的进度时，就会将其放入 ISR 集合。\r\n默认情况下，**只有 ISR 中的副本才有资格晋升为 Leader**。\r\n## **5.如何确定当前能读到哪一条消息？**\r\n分区相当于一个日志文件，我们先简单介绍几个概念\r\n![img](《面试八股文》之 Kafka 21卷.assets/wpsC91C.tmp.png) \r\n如上图是一个分区日志文件\r\n· 标识**共有7条消息**，offset (消息偏移量)分别是0~6\r\n· 0 代表这个日志文件的**开始**\r\n· HW(High Watermark) 为4，0~3 代表这个日志文件**可以消费的区间**，消费者只能消费到这四条消息\r\n· LEO 代表即将要写入消息的偏移量 offset\r\n**分区 ISR 集合中的每个副本都会维护自己的 LEO，而 ISR 集合中最小的LEO 即为分区的 HW**\r\n![img](《面试八股文》之 Kafka 21卷.assets/wpsC91D.tmp.png) \r\n如上图: 三个分区副本都是 ISR集合当中的，最小的 LEO 为 3，就代表分区的 HW 为3，所以当前分区只能消费到 0~2 之间的三条数据，如下图\r\n![img](《面试八股文》之 Kafka 21卷.assets/wpsC91E.tmp.png) \r\n## **6.生产者发送消息有哪些模式？**\r\n总共有三种模式\r\n· 1.**发后即忘**（fire-and-forget）\r\n§ 它只管往 Kafka 里面发送消息，但是**不关心消息是否正确到达**，这种方式的效率最高，但是可靠性也最差，比如当发生某些不可充实异常的时候会造成消息的丢失\r\n· 2.**同步**（sync）\r\n§ producer.send()返回一个Future对象，调用get()方法变回进行同步等待，就知道消息是否发送成功，**发送一条消息需要等上个消息发送成功后才可以继续发送**\r\n· 3.**异步**（async）\r\n§ Kafka支持 producer.send() 传入一个回调函数，消息不管成功或者失败都会调用这个回调函数，这样就算是异步发送，我们也知道消息的发送情况，然后再回调函数中选择记录日志还是重试都取决于调用方\r\n## **7.发送消息的分区策略有哪些？**\r\n![img](《面试八股文》之 Kafka 21卷.assets/wpsC92F.tmp.png) \r\n· 1.轮询：**依次**将消息发送该topic下的所有分区，如果在创建消息的时候 key 为 null，Kafka 默认采用这种策略。\r\n· 2.key 指定分区：在创建消息是 key 不为空，并且使用默认分区器，Kafka 会将 key 进行 hash，然后**根据hash值映射到指定的分区上**。这样的好处是 key 相同的消息会在一个分区下，Kafka 并不能保证全局有序，但是在每个分区下的消息是有序的，按照顺序存储，按照顺序消费。在保证同一个 key 的消息是有序的，这样基本能满足消息的顺序性的需求。但是**如果 partation 数量发生变化，那就很难保证 key 与分区之间的映射关系了**。\r\n· 3.自定义策略：实现 Partitioner 接口就能自定义分区策略。\r\n· 4.指定 Partiton 发送\r\n## **8.Kafka 支持读写分离吗？为什么？**\r\nKafka 是**不支持读写分离**的，那么读写分离的好处是什么？主要就是让一个节点去承担另一个节点的负载压力，也就是能做到一定程度的负载均衡，而且 Kafka 不通过读写分离也可以一定程度上去实现负载均衡。\r\n但是对于 Kafka 的架构来说，读写分离有两个很大的**缺点**\r\n![img](《面试八股文》之 Kafka 21卷.assets/wpsC930.tmp.png) \r\n· 1.数据不一致的问题:读写分离必然涉及到数据的同步，只要是**不同节点之间的数据同步**，必然**会有数据不一致的问题**存在。\r\n· 2.延时问题:由于 Kafka 独特的数据处理方式，导致如果将数据从一个节点同步到另一个节点必然会经过**主节点磁盘和从节点磁盘**，对一些延时性要求较高的应用来说，并不太适用\r\n## **9.那 Kafka 是怎么去实现负载均衡的？**\r\nKafka 的负责均衡主要是**通过分区来实现**的，我们知道 Kafka 是**主写主读**的架构，如下图:\r\n![img](《面试八股文》之 Kafka 21卷.assets/wpsC931.tmp.png) \r\n共三个 broker ，里面各有三个副本，总共有三个 partation， 深色的是 leader，浅色的是 follower，上下灰色分别代表生产者和消费者，虚线代表 follower 从 leader 拉取消息。\r\n我们从这张图就可以很明显的看出来，**每个 broker 都有消费者拉取消息，每个 broker 也都有生产者发送消息，每个 broker 上的读写负载都是一样的**，这也说明了 kafka 独特的架构方式可以通过主写主读来实现负载均衡。\r\n## **10.Kafka 的负责均衡会有什么问题呢？**\r\nkafka的负载均衡在绝对理想的状况下可以实现，但是会有某些情况出现一定程度上的负载不均衡![img](《面试八股文》之 Kafka 21卷.assets/wpsC932.tmp.png)\r\n· 1.**broker 端分配不均**:当创建 topic 的时候可能会出现某些 broker 分配到的分区数多，而有些 broker 分配的分区少，这就导致了 leader 多副本不均。\r\n· 2.**生产者写入消息不均**:生产者可能只对某些 broker 中的 leader 副本进行大量的写入操作，而对其他的 leader 副本不闻不问。\r\n· 3.**消费者消费不均**:消费者可能只对某些 broker 中的 leader 副本进行大量的拉取操作，而对其他的 leader 副本不闻不问。\r\n· 4.**leader 副本切换不均**：当主从副本切换或者分区副本进行了重分配后，可能会导致各个 broker 中的 leader 副本分配不均匀。\r\n## **11.Kafka 的可靠性是怎么保证的？**\r\n![img](《面试八股文》之 Kafka 21卷.assets/wpsC933.tmp.png) \r\n**1.acks**\r\n这个参数用来指定分区中有多少个副本收到这条消息，生产者才认为这条消息是写入成功的，这个参数有三个值：\r\n· 1.acks = 1，默认为1。生产者发送消息，**只要 leader 副本成功写入消息，就代表成功**。这种方案的问题在于，当返回成功后，如果 leader 副本和 follower 副本还**没有来得及同步**，leader 就崩溃了，那么在选举后新的 leader 就没有这条**消息，也就丢失了**。\r\n· 2.acks = 0。生产者发送消息后直接算写入成功，不需要等待响应。这个方案的问题很明显，**只要服务端写消息时出现任何问题，都会导致消息丢失**。\r\n· 3.acks = -1 或 acks = all。生产者发送消息后，需要等待 ISR 中的所有副本都成功写入消息后才能收到服务端的响应。毫无疑问这种方案的**可靠性是最高**的，但是如果 ISR 中只有leader 副本，那么就和 acks = 1 毫无差别了。\r\n**2.消息发送的方式**\r\n第6问中我们提到了生产者发送消息有三种方式，发完即忘，同步和异步。我们可以**通过同步或者异步**获取响应结果，**失败做重试**来保证消息的可靠性。\r\n**3.手动提交位移**\r\n默认情况下，当消费者消费到消息后，就会自动提交位移。但是如果消费者消费出错，没有进入真正的业务处理，那么就可能会导致这条消息消费失败，从而丢失。我们可以开启手动提交位移，等待业务正常处理完成后，再提交offset。\r\n**4.通过副本 LEO 来确定分区 HW**\r\n可参考第五问\r\n## **12.Kafka 的消息消费方式有哪些？**\r\n一般消息消费有两种模式，推和拉。Kafka的消费是属于**拉模式**的，而此模式的消息消费方式有**两种，点对点和发布订阅**。![img](《面试八股文》之 Kafka 21卷.assets/wpsC934.tmp.png)\r\n· 1.**点对点**:如果所有消费者属于同一个消费组，那么所有的消息都会被均匀的投递给每一个消费者，**每条消息只会被其中一个消费者消费**。\r\n![img](《面试八股文》之 Kafka 21卷.assets/wpsC935.tmp.png) \r\n· 2.**发布订阅**:如果所有消费者属于不同的消费组，那么所有的消息都会被投递给每一个消费者，**每个消费者都会收到该消息**。\r\n## **13.分区再分配是做什么的？解决了什么问题？**\r\n分区再分配主要是用来**维护 kafka 集群的负载均衡**\r\n既然是分区再分配，那么 kafka 分区有什么问题呢？\r\n![img](《面试八股文》之 Kafka 21卷.assets/wpsC945.tmp.png) \r\n· 问题1:当集群中的一个节点下线了\r\n§ 如果该节点的分区是单副本的,那么分区将会变得不可用\r\n§ 如果是多副本的，就会进行 leader 选举，在其他机器上选举出新的 leader\r\n**kafka 并不会将这些失效的分区迁移到其他可用的 broker 上**，这样就会影响集群的负载均衡，甚至也会影响服务的可靠性和可用性\r\n![img](《面试八股文》之 Kafka 21卷.assets/wpsC946.tmp.png) \r\n· 问题2:当集群新增 broker 时，只有新的主题分区会分配在该 broker 上，而老的主题分区不会分配在该 broker 上，就造成了**老节点和新节点之间的负载不均衡**。\r\n为了解决该问题就出现了分区再分配，它可以在集群扩容，broker 失效的场景下进行分区迁移。\r\n**分区再分配的原理就是通化控制器给分区新增新的副本，然后通过网络把旧的副本数据复制到新的副本上，在复制完成后，将旧副本清除。** 当然，为了不影响集群正常的性能，在此复制期间还会有一些列保证性能的操作，比如**复制限流**。\r\n## **14.副本 leader 是怎么选举的？**\r\n当分区 leader 节点崩溃时，其中一个 follower 节点会成为新的 leader 节点，这样会**导致集群的负载不均衡，从而影响服务的健壮性和稳定性**。\r\n如下:\r\nTopic: test Partation:0 Leader:1 Replicas:1,2,0 Isr:1,2,0\r\nTopic: test Partation:1 Leader:2 Replicas:2,0,1 Isr:2,0,1\r\nTopic: test Partation:2 Leader:0 Replicas:0,1,2 Isr:0,1,2\r\n我们可以看到\r\n· 0 分区 1 是 leader\r\n· 1 分区 2 是 leader\r\n· 2 分区 0 是 leader\r\n如果此时中间的**节点重启**\r\nTopic: test Partation:0 Leader:1 Replicas:1,2,0 Isr:1,0,2\r\nTopic: test Partation:1 Leader:0 Replicas:2,0,1 Isr:0,1,2\r\nTopic: test Partation:2 Leader:0 Replicas:0,1,2 Isr:0,1,2\r\n我们又可以看到:\r\n· 0 分区 1 是 leader\r\n· 1 分区 0 是 leader\r\n· 2 分区 0 是 leader\r\n我们会发现，原本 1 分区有两个 ledaer，经过重启后 leader 都消失了，如此就**负载不均衡**了。\r\n为了解决这种问题，就引入了优先副本的概念\r\n优先副本就是说在 AR 集合中的第一个副本。比如分区 2 的 AR 为 0，1，2，那么分区 2 的优先副本就为0。理想情况下优先副本就是 leader 副本。优先副本选举就是促使优先副本成为 leader 副本，从而维护集群的负载均衡。\r\n## **15.分区数越多越好吗？吞吐量就会越高吗？**\r\n一般类似于这种问题的答案，都是持否定态度的。\r\n但是可以说，**在一定条件下，分区数的数量是和吞吐量成正比的，分区数和性能也是成正比的**。\r\n那么为什么说超过了一定限度，就会对性能造成影响呢？原因如下:\r\n![img](《面试八股文》之 Kafka 21卷.assets/wpsC947.tmp.png) \r\n**1.客户端/服务器端需要使用的内存就越多**\r\n· 服务端在很多组件中都维护了分区级别的缓存，分区数越大，**缓存成本**也就越大。\r\n· 消费端的消费线程数是和分区数挂钩的，分区数越大消费线程数也就越多，**线程的开销成本**也就越大\r\n· 生产者发送消息有缓存的概念，会为每个分区缓存消息，当积累到一定程度或者时间时会将消息发送到分区，**分区越多，这部分的缓存**也就越大\r\n**2.文件句柄的开销**\r\n**每个 partition 都会对应磁盘文件系统的一个目录**。在 Kafka 的数据日志文件目录中，每个日志数据段都会分配两个文件，一个索引文件和一个数据文件。**每个 broker 会为每个日志段文件打开一个 index 文件句柄和一个数据文件句柄**。因此，随着 partition 的增多，所需要保持打开状态的文件句柄数也就越多，最终可能超过底层操作系统配置的文件句柄数量限制。\r\n**3.越多的分区可能增加端对端的延迟**\r\nKafka 会将分区 HW 之前的消息暴露给消费者。**分区越多则副本之间的同步数量就越多**，在默认情况下，每个 broker 从其他 broker 节点进行数据副本复制时，该 broker 节点只会为此工作分配一个线程，该线程需要完成该 broker 所有 partition 数据的复制。\r\n**4.降低高可用性**\r\n在第 13 问我们提到了分区再分配，会将数据复制到另一份副本当中，**分区数量越多，那么恢复时间也就越长**，而如果发生宕机的 broker 恰好是 controller 节点时：在这种情况下，新 leader 节点的选举过程在 controller 节点恢复到新的 broker 之前不会启动。controller 节点的错误恢复将会自动地进行，但是新的 controller 节点需要从 zookeeper 中读取每一个 partition 的元数据信息用于初始化数据。例如，假设一个Kafka 集群存在 10000个partition，从 zookeeper 中恢复元数据时每个 partition 大约花费 2 ms，则 controller 的恢复将会增加约 20 秒的不可用时间窗口。\r\n## **16.如何增强消费者的消费能力？**\r\n· 1.可以考虑增加 topic 的分区数，并且同时提升消费组的消费者数量，消费者数=分区数。\r\n· 2.如果是消费者消费不及时，可以采用多线程的方式进行消费，并且优化业务方法流程，同样的分区数，为什么人家并发那么高，你的就不行？？\r\n## ** **17.消费者与 topic 的分区分配策略有哪些？**\r\n![img](《面试八股文》之 Kafka 21卷.assets/wpsC948.tmp.png) \r\n**1.RangeAssignor 分配策略**\r\n该分配策略是按照**消费者总数和分区总数进行整除运算**来获得一个跨度，然后分区按照跨度来进行平均分配，尽可能保证分区均匀的分配给所有的消费者。\r\n对于每个 topic，该策略会讲消费者组内所有订阅这个主题的消费者**按照名称的字典顺序排序**，然后为每个消费者划分固定过的区域，**如果不够平均分配，那么字典排序考前的就会多分配一个分区**。\r\n比如 2 个消费者属于一个消费者组，有 2 个 topic t1，t2，每个 topic 都有 3 个分区，p1，p2，p3，那么分配的情况如下:\r\n 消费者A:t0-p0，t0-p1，t1-p0，t1-p1，\r\n 消费者B:t0-p2，t1-p2\r\n这样就会出现非配不均匀的情况\r\n**2.RoundRobinAssignor 分配策略**\r\n该分配策略是**按将消费者组内所有消费者及消费者订阅的所有主题的分区按照字典排序，然后通过轮询的方式分配给每个消费者**。\r\n比如有 3 个消费者 A，B，C，订阅了 3 个 topic ，t0，t1，t2，每个 topic 各有 3 个分区 p0，p1，p2。如果 A 订阅了 t0，B 订阅了 t0 和 t1，C 订阅了 t0，t1，t2，那么分配的情况如下:\r\n 消费者A:t0-p0\r\n 消费者B:t1-p0\r\n 消费者C:t1-p1，t2-p0，t2-p1，t2-p2\r\n这样也会出现分配不均匀的情况，按照订阅情况来讲完全可以吧 t1p1 分配给消费者B\r\n**3.StickyAssignor分配策略**\r\n这种分配策略有两个目的\r\n· 1.分区的分配要尽可能的均匀\r\n· 2.分区的分配尽可能的与上次分配的保持相同。\r\n当两者发生冲突时，第一个目标优先于第二个目标。\r\n假设消费组内有3个消费者：**C0、C1、C2**\r\n它们都订阅了4个主题：**t0、t1、t2、t3**\r\n并且每个主题有2个分区，也就是说整个消费组订阅了，**t0p0、t0p1、t1p0、t1p1、t2p0、t2p1、t3p0、t3p1** 这8个分区\r\n最终的分配结果如下：\r\n消费者C0：t0p0、t1p1、t3p0\r\n消费者C1：t0p1、t2p0、t3p1\r\n消费者C2：t1p0、t2p1\r\n这样初看上去似乎与采用RoundRobinAssignor策略所分配的结果相同\r\n此时假设消费者C1脱离了消费组，那么消费组就会执行再平衡操作，进而消费分区会重新分配。如果采用RoundRobinAssignor策略，那么此时的分配结果如下：\r\n消费者C0：t0p0、t1p0、t2p0、t3p0\r\n消费者C2：t0p1、t1p1、t2p1、t3p1\r\n如分配结果所示，RoundRobinAssignor策略会按照消费者C0和C2进行重新轮询分配。而如果此时使用的是StickyAssignor策略，那么分配结果为：\r\n消费者C0：t0p0、t1p1、t3p0、t2p0\r\n消费者C2：t1p0、t2p1、t0p1、t3p1\r\n可以看到分配结果中保留了上一次分配中对于消费者C0和C2的所有分配结果，并将原来消费者C1的“负担”分配给了剩余的两个消费者C0和C2，最终C0和C2的分配还保持了均衡。\r\n**如果发生分区重分配，那么对于同一个分区而言有可能之前的消费者和新指派的消费者不是同一个，对于之前消费者进行到一半的处理还要在新指派的消费者中再次复现一遍，这显然很浪费系统资源。StickyAssignor策略如同其名称中的“sticky”一样，让分配策略具备一定的“粘性”，尽可能地让前后两次分配相同，进而减少系统资源的损耗以及其它异常情况的发生**。\r\n到目前为止所分析的都是消费者的订阅信息都是相同的情况，我们来看一下订阅信息不同的情况下的处理。\r\n举例：同样消费组内有3个消费者：**C0、C1、C2**\r\n集群中有3个主题 **t0、t1、t2**\r\n这3个主题分别有 **1、2、3**个分区\r\n也就是说集群中有 **t0p0、t1p0、t1p1、t2p0、t2p1、t2p2** 这6个分区\r\n消费者**C0订阅了主题t0，消费者C1订阅了主题t0和t1，消费者C2订阅了主题t0、t1和t2**\r\n如果此时采用RoundRobinAssignor策略：\r\n消费者C0：t0p0\r\n消费者C1：t1p0\r\n消费者C2：t1p1、t2p0、t2p1、t2p2\r\n如果此时采用的是StickyAssignor策略：\r\n消费者C0：t0p0\r\n消费者C1：t1p0、t1p1\r\n消费者C2：t2p0、t2p1、t2p2\r\n此时消费者C0脱离了消费组，那么RoundRobinAssignor策略的分配结果为：\r\n消费者C1：t0p0、t1p1\r\n消费者C2：t1p0、t2p0、t2p1、t2p2\r\nStickyAssignor策略，那么分配结果为：\r\n消费者C1：t1p0、t1p1、t0p0\r\n消费者C2：t2p0、t2p1、t2p2\r\n可以看到StickyAssignor策略保留了消费者C1和C2中原有的5个分区的分配：\r\nt1p0、t1p1、t2p0、t2p1、t2p2。\r\n从结果上看StickyAssignor策略比另外两者分配策略而言显得更加的优异，这个策略的代码实现也是异常复杂。\r\n**4.自定义分区分配策略**\r\n可以通过实现 org.apache.kafka.clients.consumer.internals.PartitionAssignor 接口来实现\r\n## **18.kafka 控制器是什么？有什么作用**\r\n在 Kafka 集群中会有一个或多个 broker，其中有一个 broker 会被选举为控制器，**它负责管理整个集群中所有分区和副本的状态**，kafka 集群中**只能有一个控制器**。\r\n· 当某个分区的 leader 副本出现故障时，由控制器负责**为该分区选举新的 leader 副本**。\r\n· 当检测到某个分区的ISR集合发生变化时，由控制器负责**通知所有 broker 更新其元数据信息**。\r\n· 当为某个 topic 增加分区数量时，由控制器**负责分区的重新分配**。\r\n## **19.kafka 控制器是怎么进行选举的？**\r\nkafka 中的控制器选举工作**依赖于 Zookeeper**，成功竞选成为控制器的 broker 会在Zookeeper中创建/controller临时节点。\r\n每个 broker 启动的时候会去尝试读取/controller 节点的 brokerid的值\r\n· **如果**读取到的 **brokerid 的值不为-1**，表示已经有其他broker 节点成功竞选为控制器，所以当前 broker **就会放弃竞选**；\r\n如果Zookeeper中**不存在**/controller 节点，**或者**这个节点的数据**异常**，那么**就会尝试去创建**/controller 节点，**创建成功的那个 broker 就会成为控制器**。\r\n每个 broker 都会在内存中保存当前控制器的 brokerid 值，这个值可以标识为 activeControllerId。\r\nZookeeper 中还有一个与控制器有关的/controller_epoch 节点，这个节点是**持久节点**，节点中存放的是一个整型的 controller_epoch 值。controller_epoch 值用于**记录控制器发生变更的次数**。\r\ncontroller_epoch 的**初始值为1**，即集群中的第一个控制器的纪元为1，当控制器发生变更时，**每选出一个新的控制器就将该字段值加1**。\r\n每个和控制器交互的请求都会携带 controller_epoch 这个字段，\r\n· **如果请求的 controller_epoch 值**小于**内存中的 controller_epoch值**，**则**认为这个请求是向已经过期的控制器发送的请求，那么这个请求会**被认定为无效的请求**。\r\n· 如果请求的 controller_epoch 值**大于**内存中的 controller_epoch值，那么说明**已经有新的控制器当选**了\r\n## **20.kafka 为什么这么快？**\r\n![img](《面试八股文》之 Kafka 21卷.assets/wpsC949.tmp.png) \r\n· \r\n**1.顺序读写**\r\n· \r\n磁盘分为顺序读写与随机读写，基于磁盘的随机读写确实很慢，但磁盘的顺序读写性能却很高，kafka 这里采用的就是顺序读写。\r\n**2.Page Cache**\r\n· \r\n为了优化读写性能，Kafka 利用了操作**系统本身的 Page Cache**，就是利用操作系统自身的内存而不是JVM空间内存。\r\n**3.零拷贝**\r\n· \r\nKafka使用了零拷贝技术，也就是**直接将数据从内核空间的读缓冲区直接拷贝到内核空间的 socket 缓冲区**，然后再写入到 NIC 缓冲区，避免了在内核空间和用户空间之间穿梭。\r\n**4.分区分段+索引**\r\n· \r\nKafka 的 message 是按 topic分 类存储的，topic 中的数据又是按照一个一个的 partition 即分区存储到不同 broker 节点。每个 partition 对应了操作系统上的一个文件夹，partition 实际上又是按照segment分段存储的。\r\n· \r\n通过这种分区分段的设计，Kafka 的 message 消息实际上是分布式存储在一个一个小的 segment 中的，每次文件操作也是直接操作的 segment。为了进一步的查询优化，Kafka 又默认为分段后的数据文件建立了索引文件，就是文件系统上的.index文件。这种分区分段+索引的设计，不仅提升了数据读取的效率，同时也提高了数据操作的并行度。\r\n**5.批量读写**\r\n· \r\nKafka **数据读写也是批量的而不是单条的**,这样可以避免在网络上频繁传输单个消息带来的延迟和带宽开销。假设网络带宽为10MB/S，一次性传输10MB的消息比传输1KB的消息10000万次显然要快得多。\r\n**6.批量压缩**\r\n· \r\nKafka 把所有的消息都变成一个**批量的文件**，并且进行合理的**批量压缩**，减少网络 IO 损耗，通过 mmap 提高 I/O 速度，写入数据的时候由于单个Partion是末尾添加所以速度最优；读取数据的时候配合 sendfile 进行直接读取。\r\n· \r\n## **21.什么情况下 kafka 会丢失消息？**\r\nKafka 有三次消息传递的过程：生产者发消息给 Broker，Broker 同步消息和持久化消息，Broker 将消息传递给消费者。\r\n![img](《面试八股文》之 Kafka 21卷.assets/wpsC94A.tmp.png) \r\n这其中每一步都有可能丢失消息.\r\n· \r\n1.生产者发送数据: 在第 11 问中的 acks中有说到\r\n· \r\n§ 当 acks 为 0，**只要服务端写消息时出现任何问题，都会导致消息丢失**。\r\n§ 当 acks 配置为 1 时，生产者发送消息，只要 leader 副本成功写入消息，就代表成功。这种方案的问题在于，当返回成功后，**如果 leader 副本和 follower 副本还没有来得及同步，leader 就崩溃了，那么在选举后新的 leader 就没有这条消息，也就丢失了**。\r\n· \r\n2.Broker 存储数据:kafka 通过 Page Cache 将数据写入磁盘。\r\n· \r\n§ Page Cache 就是当往磁盘文件写入的时候，系统会先将数据流写入缓存中，但是**什么时候将缓存的数据写入文件中是由操作系统自行决定**。所以**如果此时机器突然挂了，也是会丢失消息的**。\r\n· \r\n3.消费者消费数据:在开启**自动提交 offset** 时，只要消费者消费到消息，那么就会自动提交偏移量，**如果业务还没有来得及处理，那么消息就会丢失**。\r\n· \r\n'},fb56:function(n,r,e){"use strict";e.r(r),r["default"]='## 推荐两个视频学习网站\n\n### 慕课网\n\n第一个推荐的学习网站应该是慕课网（慕课网私聊我打钱哈！），在我初学的时候，这个网站对我的帮助挺大的，里面有很多免费的课程，也有很多付费的课程。如果你没有特殊的需求，一般免费课程就够自己学的了。\n\n\n\n### 哔哩哔哩\n\n想不到弹幕追番/原创视频小站也被推荐了吧！不得不说哔哩哔哩上面的学习资源还是很多的，现在有很多年轻人都在上面学习呢！哈哈哈 大部分年轻人最爱的小破站可是受到过央视表扬的。被誉为年轻人学习的首要阵地，哔哩哔哩干杯！\n\n不过在哔哩哔哩上面越靠前的视频就是最好的视频或者说最适合你的视频，也是要筛选一下的。\n\n\n\n### 极客时间\n\n主打付费学习的一个付费学习社区（极客时间私聊我打钱哈！）。不过课程的质量大部分都挺高的，我自己也看了里面很多的课程，并且很多课程都是 Java 领域大佬级别的人物将的。\n\n\n\n## 推荐一些文字类型学习网站/博客\n\n### Github\n\n最牛逼的程序员交流网站！！！没有之一。一定要多逛逛！上面有很多好东西，比如我搜索 Java（它竟然给我返回贼多 javascript 的项目，啥意思？？？）\n\n\n\n比如我搜索女装，emm....然后就出来了这些东西，捂住眼睛，不敢看！\n\n\n\n### 菜鸟教程\n\n对于新手入门来说很不错的网站，大部分教程都是针对的入门级别。优点是网站教程内容比较完善并且内容质量也是有保障的。\n\n\n\n### w3cschool\n\n和菜鸟教程类似的一个网站，里面的教程也很齐全。\n\n\n\n### Stackoverflow\n\n**Stack Overflow**是一个程序设计领域的问答网站，网站允许注册用户提出或回答问题。和知乎很像，重大的一点不同是 Stack Overflow 可以对问题进行打分。\n\n\n\n### leetcode\n\n网站地址：https://leetcode-cn.com/\n\n工作之余没事去刷个算法题，岂不是美滋滋。\n\n\n\n### 一些不错的技术交流社区推荐\n\n1. **掘金**：[https://juejin.im/](https://juejin.im/ "https://juejin.im/") 。\n2. **segmentfault** ： [https://segmentfault.com/](https://segmentfault.com/ "https://segmentfault.com/")\n3. **博客园** ： [https://www.cnblogs.com/](https://www.cnblogs.com/ "https://www.cnblogs.com/")\n4. **慕课网手记** ：[https://www.imooc.com/article](https://www.imooc.com/article "https://www.imooc.com/article")\n5. **知乎** ：[https://www.zhihu.com/](https://www.zhihu.com/ "https://www.zhihu.com/")\n\n### 一些不错的博客/Github 推荐\n\n- SnailClimb 的 Github ：[https://github.com/Snailclimb](https://github.com/Snailclimb "https://github.com/Snailclimb") 。（自荐一波哈！主要专注在 Java 基础和进阶、Spring、Spring Boot、Java 面试这方面。）\n- 徐靖峰个人博客 ：[https://www.cnkirito.moe/](https://www.cnkirito.moe/ "https://www.cnkirito.moe/")（探讨 Java 生态的知识点，内容覆盖分布式服务治理、微服务、性能调优、各类源码分析）\n- 田小波：[http://www.tianxiaobo.com/](http://www.tianxiaobo.com/ "http://www.tianxiaobo.com/") （Java 、Spring 、MyBatis 、Dubbo）\n- 周立的博客： [http://www.itmuch.com/](http://www.itmuch.com/ "http://www.itmuch.com/")（Spring Cloud、Docker、Kubernetes，及其相关生态的技术）\n- Hollis: [https://www.hollischuang.com/](https://www.hollischuang.com/ "https://www.hollischuang.com/") (Java 后端)\n- 方志朋的专栏 ： [https://www.fangzhipeng.com/](https://www.fangzhipeng.com/ "https://www.fangzhipeng.com/") （Java 面试 Java 并发 openresty kubernetes Docker 故事 )\n- 纯洁的微笑 : [http://www.ityouknow.com/](http://www.ityouknow.com/ "http://www.ityouknow.com/") （Java、SpringBoot、Spring Cloud）\n- 芋道源码： [http://www.iocoder.cn/](http://www.iocoder.cn/ "http://www.iocoder.cn/") (专注源码)。\n- 欢迎自荐\n- ......\n'}}]);