(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[2],{"0e36":function(t,n,e){"use strict";e.r(n);var a=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+(n+1),label:n+1+"."+t.text}})})),1),e("m"+t.tab,{tag:"component"})],1)},r=[],s=e("9523"),o=e.n(s),l=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n   rrrrrrrrrrrrrrrrrrrr\n")])},i=[],c={},p=c,b=e("2877"),u=Object(b["a"])(p,l,i,!1,null,"40a3f836",null),v=u.exports,g=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    yyyyyyyyyyyyyyyyyyyyyyyy\n")])},m=[],_={},d=_,h=Object(b["a"])(d,g,m,!1,null,"a6c54f82",null),f=h.exports,y=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},S=[],w={},k=w,x=Object(b["a"])(k,y,S,!1,null,"4fa42ff2",null),C=x.exports,j=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},P=[],T={},E=T,O=Object(b["a"])(E,j,P,!1,null,"a38c6170",null),M=O.exports,A=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},N=[],I={},D=I,z=Object(b["a"])(D,A,N,!1,null,"f77492ee",null),$=z.exports,R=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},J=[],L={},H=L,q=Object(b["a"])(H,R,J,!1,null,"5a519dca",null),F=q.exports,W=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},B=[],U={},G=U,V=Object(b["a"])(G,W,B,!1,null,"305d850b",null),X=V.exports,Q=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Y=[],K={},Z=K,tt=Object(b["a"])(Z,Q,Y,!1,null,"06696c4c",null),nt=tt.exports,et={components:{m1:v,m2:f,m3:C,m4:M,m5:$,m6:F,m7:X,m8:nt},data:function(){return o()({tab:1,tabs:[1,2,3,4,5,6,7,8]},"tabs",[{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"}])}},at=et,rt=Object(b["a"])(at,a,r,!1,null,"22b3ef2e",null);n["default"]=rt.exports},1651:function(t,n,e){"use strict";var a=e("2512"),r=e.n(a);r.a},"168d":function(t,n,e){"use strict";e.r(n);var a=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+t.value,label:n+1+"."+t.label}})})),1),e(""+t.tab,{tag:"component"})],1)},r=[],s=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+t.value,label:n+1+"."+t.label}})})),1),e("m"+t.tab,{tag:"component"})],1)},o=[],l=e("9523"),i=e.n(l),c=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},p=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("h4",[t._v("C#有用的网站")]),e("ul",{staticClass:"list"},[e("li",[e("a",{attrs:{target:"_blank",rel:"nofollow",href:"http://msdn.microsoft.com/en-us/library/67ef8sbd.aspx"}},[t._v("C# Programming Guide")]),t._v(" - 介绍了有关关键的 C# 语言特征以及如何通过 .NET 框架访问 C# 的详细信息。")]),e("li",[e("a",{attrs:{target:"_blank",rel:"nofollow",href:"https://visualstudio.microsoft.com/zh-hans/downloads/"}},[t._v("Visual Studio")]),t._v(" - 下载作为 C# 集成开发环境的 Visual Studio 的最新版本。")]),e("li",[e("a",{attrs:{target:"_blank",rel:"nofollow",href:"http://www.mono-project.com/Main_Page"}},[t._v("Go Mono")]),t._v(" - Mono 是一个允许开发人员简单地创建跨平台应用程序的软件平台。")]),e("li",[e("a",{attrs:{target:"_blank",rel:"nofollow",href:"http://en.wikipedia.org/wiki/C_Sharp_(programming_language)"}},[t._v("C Sharp (programming language) ")]),t._v(" - 维基百科解释 C#（编程语言）。")])])])}],b={},u=b,v=e("2877"),g=Object(v["a"])(u,c,p,!1,null,"ee34ceaa",null),m=g.exports,_=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    yyyyyyyyyyyyyyyyyyyyyyyy\n")])},d=[],h={},f=h,y=Object(v["a"])(f,_,d,!1,null,"1a983f6b",null),S=y.exports,w=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},k=[],x={},C=x,j=Object(v["a"])(C,w,k,!1,null,"d876bb4a",null),P=j.exports,T=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},E=[],O={},M=O,A=Object(v["a"])(M,T,E,!1,null,"69d0899c",null),N=A.exports,I=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},D=[],z={},$=z,R=Object(v["a"])($,I,D,!1,null,"3fdc70dd",null),J=R.exports,L=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},H=[],q={},F=q,W=Object(v["a"])(F,L,H,!1,null,"15e8581e",null),B=W.exports,U=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},G=[],V={},X=V,Q=Object(v["a"])(X,U,G,!1,null,"28178142",null),Y=Q.exports,K=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Z=[],tt={},nt=tt,et=Object(v["a"])(nt,K,Z,!1,null,"7bffb2c0",null),at=et.exports,rt={components:{m1:m,m2:S,m3:P,m4:N,m5:J,m6:B,m7:Y,m8:at},data:function(){return i()({tab:1,tabs:[1,2,3,4,5,6,7,8]},"tabs",[{label:"基础",value:"m1"},{label:"C#",value:"m2"},{label:"C#",value:"m3"},{label:"C#",value:"m4"},{label:"C#",value:"m5"},{label:"C#",value:"m6"},{label:"C#",value:"m7"},{label:"C#",value:"m8"}])}},st=rt,ot=Object(v["a"])(st,s,o,!1,null,"1e749cba",null),lt=ot.exports,it=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+(n+1),label:n+1+"."+t.text}})})),1),e("m"+t.tab,{tag:"component"})],1)},ct=[],pt=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n   rrrrrrrrrrrrrrrrrrrr\n")])},bt=[],ut={},vt=ut,gt=Object(v["a"])(vt,pt,bt,!1,null,"68607f2a",null),mt=gt.exports,_t=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    yyyyyyyyyyyyyyyyyyyyyyyy\n")])},dt=[],ht={},ft=ht,yt=Object(v["a"])(ft,_t,dt,!1,null,"442309cb",null),St=yt.exports,wt=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},kt=[],xt={},Ct=xt,jt=Object(v["a"])(Ct,wt,kt,!1,null,"9993f80a",null),Pt=jt.exports,Tt=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Et=[],Ot={},Mt=Ot,At=Object(v["a"])(Mt,Tt,Et,!1,null,"ed7c2988",null),Nt=At.exports,It=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Dt=[],zt={},$t=zt,Rt=Object(v["a"])($t,It,Dt,!1,null,"5f4dd27d",null),Jt=Rt.exports,Lt=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Ht=[],qt={},Ft=qt,Wt=Object(v["a"])(Ft,Lt,Ht,!1,null,"3559b9be",null),Bt=Wt.exports,Ut=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Gt=[],Vt={},Xt=Vt,Qt=Object(v["a"])(Xt,Ut,Gt,!1,null,"0b65a0ff",null),Yt=Qt.exports,Kt=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Zt=[],tn={},nn=tn,en=Object(v["a"])(nn,Kt,Zt,!1,null,"3d1cef80",null),an=en.exports,rn={components:{m1:mt,m2:St,m3:Pt,m4:Nt,m5:Jt,m6:Bt,m7:Yt,m8:an},data:function(){return i()({tab:1,tabs:[1,2,3,4,5,6,7,8]},"tabs",[{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"}])}},sn=rn,on=Object(v["a"])(sn,it,ct,!1,null,"75677eba",null),ln=on.exports,cn=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+(n+1),label:n+1+"."+t.text}})})),1),e("m"+t.tab,{tag:"component"})],1)},pn=[],bn=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n   rrrrrrrrrrrrrrrrrrrr\n")])},un=[],vn={},gn=vn,mn=Object(v["a"])(gn,bn,un,!1,null,"49098ae2",null),_n=mn.exports,dn=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    yyyyyyyyyyyyyyyyyyyyyyyy\n")])},hn=[],fn={},yn=fn,Sn=Object(v["a"])(yn,dn,hn,!1,null,"1bcaa4c3",null),wn=Sn.exports,kn=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},xn=[],Cn={},jn=Cn,Pn=Object(v["a"])(jn,kn,xn,!1,null,"7eb90db3",null),Tn=Pn.exports,En=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},On=[],Mn={},An=Mn,Nn=Object(v["a"])(An,En,On,!1,null,"54c4f4f4",null),In=Nn.exports,Dn=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},zn=[],$n={},Rn=$n,Jn=Object(v["a"])(Rn,Dn,zn,!1,null,"2ad0dc35",null),Ln=Jn.exports,Hn=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},qn=[],Fn={},Wn=Fn,Bn=Object(v["a"])(Wn,Hn,qn,!1,null,"00dcc376",null),Un=Bn.exports,Gn=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Vn=[],Xn={},Qn=Xn,Yn=Object(v["a"])(Qn,Gn,Vn,!1,null,"522eaa92",null),Kn=Yn.exports,Zn=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},te=[],ne={},ee=ne,ae=Object(v["a"])(ee,Zn,te,!1,null,"a616dc10",null),re=ae.exports,se={components:{m1:_n,m2:wn,m3:Tn,m4:In,m5:Ln,m6:Un,m7:Kn,m8:re},data:function(){return i()({tab:1,tabs:[1,2,3,4,5,6,7,8]},"tabs",[{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"}])}},oe=se,le=Object(v["a"])(oe,cn,pn,!1,null,"717108bc",null),ie=le.exports,ce={components:{C3:lt,other:ln,tool:ie},data:function(){return{tab:"C3",tabs:[{label:"C#",value:"C3"},{label:"添加",value:"other"},{label:"删除",value:"tool"}]}}},pe=ce,be=Object(v["a"])(pe,a,r,!1,null,"75a8f402",null);n["default"]=be.exports},"1c0f":function(t,n,e){"use strict";e.r(n);var a=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+t,label:n+1+"."+t}})})),1),e(""+t.tab,{tag:"component"})],1)},r=[],s=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+(n+1),label:n+1+"."+t.text}})})),1),e("m"+t.tab,{tag:"component"})],1)},o=[],l=e("9523"),i=e.n(l),c=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},p=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("p",[t._v("\n\nCMD命令：开始－>运行－>键入cmd或command（在命令行里可以看到系统版本、文件系统版本）"),e("br"),t._v("\nchcp 修改默认字符集"),e("br"),t._v("\nchcp 936默认中文"),e("br"),t._v("\nchcp 65001"),e("br"),t._v("\n1. appwiz.cpl：程序和功能\n2. calc：启动计算器\n"),e("br"),e("br"),t._v("\n5. chkdsk.exe：Chkdsk磁盘检查（管理员身份运行命令提示符）\n"),e("br"),t._v("\n6. cleanmgr: 打开磁盘清理工具\n\n\n9. cmd.exe：CMD命令提示符\n10. 自动关机命令\n 　 Shutdown -s -t 600：表示600秒后自动关机\n 　 shutdown -a ：可取消定时关机\n 　 Shutdown -r -t 600：表示600秒后自动重启\n 　"),e("br"),e("br"),t._v("\n12. CompMgmtLauncher：计算机管理\n13. compmgmt.msc：计算机管理\n14. credwiz：备份或还原储存的用户名和密码\n"),e("br"),t._v("\n16. control：控制面版\n17. dcomcnfg：打开系统组件服务\n19. devmgmt.msc：设备管理器\n20. desk.cpl：屏幕分辨率\n21. dfrgui：优化驱动器   Windows 7→dfrg.msc：磁盘碎片整理程序\n22. dialer：电话拨号程序\n23. diskmgmt.msc：磁盘管理\n24. dvdplay：DVD播放器\n25. dxdiag：检查DirectX信息\n26. eudcedit：造字程序\n27. eventvwr：事件查看器\n28. explorer：打开资源管理器\n29. Firewall.cpl：Windows防火墙\n"),e("br"),t._v("\n31. fsmgmt.msc：共享文件夹管理器\n32. gpedit.msc：组策略\n33. hdwwiz.cpl：设备管理器\n34. inetcpl.cpl：Internet属性\n35. intl.cpl：区域\n36. iexpress：木马捆绑工具，系统自带\n37. joy.cpl：游戏控制器\n38. logoff：注销命令\n39. lusrmgr.msc：本地用户和组\n40. lpksetup：语言包安装/删除向导，安装向导会提示下载语言包\n41. lusrmgr.msc：本机用户和组\n42. main.cpl：鼠标属性\n43. mmsys.cpl：声音\n\n45. mem.exe：显示内存使用情况（如果直接运行无效，可以先管理员身份运行命令提示符，在命令提示符里输入mem.exe>d:a.txt 即可打开d盘查看a.txt，里面的就是内存使用情况了。当然什么盘什么文件名可自己决定。）\n"),e("br"),e("br"),e("br"),t._v("\n47. mmc：打开控制台\n48. mobsync：同步命令\n\n 50. Msconfig.exe：系统配置实用程序\n51. msdt：微软支持诊断工具\n52. msinfo32：系统信息\n53. mspaint：画图\n54. Msra：Windows远程协助\n55. mstsc：远程桌面连接\n56. NAPCLCFG.MSC：客户端配置\n57. ncpa.cpl：网络连接\n58. narrator：屏幕“讲述人”\n59. Netplwiz：高级用户帐户控制面板，设置登陆安全相关的选项\n60. netstat : an(TC)命令检查接口\n61. notepad：打开记事本\n62. Nslookup：IP地址侦测器\n63. odbcad32：ODBC数据源管理器\n"),e("br"),t._v("\n64. OptionalFeatures：打开“打开或关闭Windows功能”对话框\n"),e("br"),e("br"),t._v("\n65. osk：打开屏幕键盘\n66. perfmon.msc：计算机性能监测器\n67. perfmon：计算机性能监测器\n68. PowerShell：提供强大远程处理能力\n69. printmanagement.msc：打印管理\n70. powercfg.cpl：电源选项\n71. psr：问题步骤记录器\n72. Rasphone：网络连接\n73. Recdisc：创建系统修复光盘\n74. Resmon：资源监视器\n75. Rstrui：系统还原\n76. regedit.exe：注册表\n77. regedt32：注册表编辑器\n78. rsop.msc：组策略结果集\n79. sdclt：备份状态与配置，就是查看系统是否已备份\n80. secpol.msc：本地安全策略\n81. services.msc：本地服务设置\n82. sfc /scannow：扫描错误并复原/windows文件保护\n83. sfc.exe：系统文件检查器\n84. shrpubw：创建共享文件夹\n85. sigverif：文件签名验证程序\n86. slui：Windows激活，查看系统激活信息\n87. slmgr.vbs -dlv ：显示详细的许可证信息\n 　 slmgr.vbs -dli ：显示许可证信息\n 　 slmgr.vbs -xpr ：当前许可证截止日期\n 　 slmgr.vbs -dti ：显示安装ID 以进行脱机激\n 　 slmgr.vbs -ipk ：(Product Key)安装产品密钥\n 　 slmgr.vbs -ato ：激活Windows\n　 slmgr.vbs -cpky ：从注册表中清除产品密钥（防止泄露引起的攻击）\n 　 slmgr.vbs -ilc ：(License file)安装许可证\n 　 slmgr.vbs -upk ：卸载产品密钥\n 　 slmgr.vbs -skms ：(name[ort] )批量授权\n88. snippingtool：截图工具，支持无规则截图\n89. soundrecorder：录音机，没有录音时间的限制\n90. StikyNot：便笺\n91. sysdm.cpl：系统属性\n92. sysedit：系统配置编辑器\n93. syskey：系统加密，一旦加密就不能解开，保护系统的双重密码\n94. taskmgr：任务管理器（旧版）\n95. TM任务管理器（新版）\n96. taskschd.msc：任务计划程序\n97. timedate.cpl：日期和时间\n98. UserAccountControlSettings用户账户控制设置\n99. utilman：辅助工具管理器\n100. wf.msc：高级安全Windows防火墙\n101. WFS：Windows传真和扫描\n102. wiaacmgr：扫描仪和照相机向导\n103. winver：关于Windows\n 104. wmimgmt.msc：打开windows管理体系结构(WMI)\n 105. write：写字板\n106. wscui.cpl：操作中心\n107. wscript：windows脚本宿主设置\n108. wuapp：Windows更新"),e("br"),e("br"),t._v("\n1. gpedit.msc-----组策略"),e("br"),t._v("\n\n2. sndrec32-------录音机"),e("br"),t._v("\n\n3. Nslookup-------IP地址侦测器 ，是一个 监测网络中 DNS 服务器是否能正确实现域名解析的命令行工具。 它在 Windows NT/2000/XP 中均可使用 , 但在 Windows 98 中却没有集成这一个工具。"),e("br"),t._v("\n\n4. explorer-------打开资源管理器\n\n5. logoff---------注销命令"),e("br"),t._v("\n\n6. shutdown-------60秒倒计时关机命令"),e("br"),t._v("\n\n7. lusrmgr.msc----本机用户和组"),e("br"),t._v("\n\n8. services.msc---本地服务设置"),e("br"),t._v("\n\n9. oobe/msoobe /a----检查XP是否激活"),e("br"),t._v("\n\n10. notepad--------打开记事本\n\n\n"),e("br"),e("br"),e("br"),e("br"),t._v("\n11. cleanmgr-------垃圾整理"),e("br"),t._v("\n\n12. net start messenger----开始信使服务"),e("br"),t._v("\n\n13. compmgmt.msc---计算机管理"),e("br"),t._v("\n\n14. net stop messenger-----停止信使服务"),e("br"),t._v("\n\n15. conf-----------启动netmeeting"),e("br"),t._v("\n\n16. dvdplay--------DVD播放器"),e("br"),t._v("\n\n17. charmap--------启动字符映射表"),e("br"),t._v("\n\n18. diskmgmt.msc---磁盘管理实用程序"),e("br"),t._v("\n\n19. calc-----------启动计算器"),e("br"),t._v("\n\n20. dfrg.msc-------磁盘碎片整理程序"),e("br"),t._v("\n\n21. chkdsk.exe-----Chkdsk磁盘检查"),e("br"),t._v("\n\n22. devmgmt.msc--- 设备管理器\n\n23. regsvr32 /u *.dll----停止dll文件运行"),e("br"),t._v("\n\n24. drwtsn32------ 系统医生"),e("br"),t._v("\n\n25. rononce -p----15秒关机"),e("br"),t._v("\n\n26. dxdiag---------检查DirectX信息"),e("br"),t._v("\n\n27. regedt32-------注册表编辑器\n\n28. Msconfig.exe---系统配置实用程序"),e("br"),t._v("\n\n29. rsop.msc-------组策略结果集"),e("br"),t._v("\n\n30. mem.exe--------显示内存使用情况"),e("br"),t._v("\n\n31. regedit.exe----注册表"),e("br"),t._v("\n\n32. winchat--------XP自带局域网聊天"),e("br"),t._v("\n\n33. progman--------程序管理器"),e("br"),t._v("\n\n34. winmsd---------系统信息"),e("br"),t._v("\n\n35. perfmon.msc----计算机性能监测程序"),e("br"),t._v("\n\n36. winver---------检查Windows版本"),e("br"),t._v("\n\n37. sfc /scannow-----扫描错误并复原"),e("br"),t._v("\n\n38. taskmgr-----任务管理器（2000/xp/2003"),e("br"),t._v("\n\n39. winver---------检查Windows版本"),e("br"),t._v("\n\n40. wmimgmt.msc----打开windows管理体系结构(WMI)"),e("br"),t._v("\n\n41. wupdmgr--------windows更新程序"),e("br"),t._v("\n\n42. wscript--------windows脚本宿主设置"),e("br"),t._v("\n\n43. write----------写字板"),e("br"),t._v("\n\n44. winmsd---------系统信息"),e("br"),t._v("\n\n45. wiaacmgr-------扫描仪和照相机向导"),e("br"),t._v("\n\n46. winchat--------XP自带局域网聊天"),e("br"),t._v("\n\n47. mem.exe--------显示内存使用情况"),e("br"),t._v("\n\n48. Msconfig.exe---系统配置实用程序"),e("br"),t._v("\n\n49. mplayer2-------简易widnows media player"),e("br"),t._v("\n\n50. mspaint--------画图板"),e("br"),t._v("\n\n51. mstsc----------远程桌面连接"),e("br"),t._v("\n\n52. mplayer2-------媒体播放机"),e("br"),t._v("\n\n53. magnify--------放大镜实用程序"),e("br"),t._v("\n\n54. mmc------------打开控制台"),e("br"),t._v("\n\n55. mobsync--------同步命令"),e("br"),t._v("\n\n56. dxdiag---------检查DirectX信息"),e("br"),t._v("\n\n57. iexpress-------木马捆绑工具，系统自带 58. fsmgmt.msc-----共享文件夹管理器"),e("br"),t._v("\n\n59. utilman--------辅助工具管理器"),e("br"),t._v("\n\n60. diskmgmt.msc---磁盘管理实用程序"),e("br"),t._v("\n\n61. dcomcnfg-------打开系统组件服务"),e("br"),t._v("\n\n62. ddeshare-------打开DDE共享设置"),e("br"),t._v("\n\n110. osk------------打开屏幕键盘\n\n111. odbcad32-------ODBC数据源管理器"),e("br"),t._v("\n\n112. oobe/msoobe /a----检查XP是否激活 114. logoff---------注销命令"),e("br"),t._v("\n\n66. notepad--------打开记事本"),e("br"),t._v("\n\n67. nslookup-------网络管理的工具向导"),e("br"),t._v("\n\n68. ntbackup-------系统备份和还原"),e("br"),t._v("\n\n69. narrator-------屏幕“讲述人”"),e("br"),t._v("\n\n70. ntmsmgr.msc----移动存储管理器"),e("br"),t._v("\n\n71. ntmsoprq.msc---移动存储管理员操作请求"),e("br"),t._v("\n\n72. netstat -an----(TC)命令检查接口"),e("br"),t._v("\n\n73. syncapp--------创建一个公文包"),e("br"),t._v("\n\n74. sysedit--------系统配置编辑器"),e("br"),t._v("\n\n75. sigverif-------文件签名验证程序"),e("br"),t._v("\n\n76. ciadv.msc------索引服务程序"),e("br"),t._v("\n\n77. shrpubw--------创建共享文件夹"),e("br"),t._v("\n\n78. secpol.msc-----本地安全策略"),e("br"),t._v("\n\n79. syskey---------系统加密，一旦加密就不能解开，保护windows xp系统的双重密码"),e("br"),t._v("\n\n80. services.msc---本地服务设置"),e("br"),t._v("\n\n81. Sndvol32-------音量控制程序"),e("br"),t._v("\n\n82. sfc.exe--------系统文件检查器"),e("br"),t._v("\n\n83. sfc /scannow---windows文件保护"),e("br"),t._v("\n\n84. ciadv.msc------索引服务程序"),e("br"),t._v("\n\n85. tourstart------xp简介（安装完成后出现的漫游xp程序）"),e("br"),t._v("\n\n86. taskmgr--------任务管理器"),e("br"),t._v("\n\n87. eventvwr-------事件查看器"),e("br"),t._v("\n\n88. eudcedit-------造字程序"),e("br"),t._v("\n\n89. compmgmt.msc---计算机管理"),e("br"),t._v("\n\n90. packager-------对象包装程序"),e("br"),t._v("\n\n91. perfmon.msc----计算机性能监测程序"),e("br"),t._v("\n\n92. charmap--------启动字符映射表"),e("br"),t._v("\n\n93. cliconfg-------SQL SERVER 客户端网络实用程序"),e("br"),t._v("\n\n94. Clipbrd--------剪贴板查看器"),e("br"),t._v("\n\n95. conf-----------启动netmeeting"),e("br"),t._v("\n\n96. certmgr.msc----证书管理实用程序"),e("br"),t._v("\n\n97. regsvr32 /u *.dll----停止dll文件运行"),e("br"),t._v("\n\n98. regsvr32 /u zipfldr.dll------取消ZIP支持"),e("br"),t._v("\n\n99. cmd.exe--------CMD命令提示符"),e("br"),t._v("\n\n100. chkdsk.exe-----Chkdsk磁盘检查"),e("br"),t._v("\n\n1.磁盘操作，fdisk 隐含 参数 /mbr 重建主引导记录fdisk /mbr 重建主引导记录fdisk 在DOS7.0以后增加了/cmbr参数，可在挂接多个物理硬盘时，重建排序在后面的硬盘的主引导记录，例如：fdisk /cmbr 2，可重写第二个硬盘的主引导记录。（在使用时要十分小心，避免把好的硬盘引导记录损坏）format 参数： /q 快速格式化 /u 不可恢复 /autotest 不提示 /s 创建 MS-DOS 引导盘 format c: /q /u /autotest"),e("br"),t._v("\n2.目录操作DIR [目录名或文件名] [/S][/W][/P][/A] 列出目录 参数: /s 查找子目录/w 只显示文件名 /p 分页/a 显示隐藏文件 DIR format.exe /s查找该盘的format.exe文件并报告位置MD (MKDIR) [目录名] 创建目录 MKDIR HELLOWORLD 创建HELLOWORLD目录\n　　CD (CHDIR) [目录名] PS:可以使用相对目录或绝对目录 进入目录 CD AA 进入当前文件夹下的AA目录,cd .. 进入上一个文件夹cd \\返回根目录;cd c:\\windows 进入c:\\windows文件夹RD ( RMDIR) [目录名] 删除目录 RD HELLOWORLD 删除HELLOWORLD目录"),e("br"),t._v("\n3.文件操作删除目录及其文件： rmdir [目录名或文件名] [/S][/W][/P][/A] 。例 rmdir c:\\qqdownload/s 删除C盘的qqdownload目录。del [目录名或文件名] [/f][/s][/q] 删除 参数:/f 删除只读文件/s 删除该目录及其下的所有内容 /q 删除前不确认del c:\\del /s /q 自动删除c盘的del目录。copy [源文件或目录] [目标目录] 复制文件 copy d:\\pwin98\\*.* c:\\presetup 将d盘的pwin98的所有文件复制到c盘的presetup下。attrib [参数][源文件或目录] 文件属性操作命令，attrib命令可以列出或修改磁盘上文件的属性，文件属性包括文档（A）、只读(R)、隐藏(H)、系统(S)，例如：attrib -h -r -s io.sys 执行这一命令后，将把DOS系统文件io.sys文件的只读、隐藏、系统属性去掉，这时将可以直接通过dir命令看到io.sys文件。attrib +h +r +s autoexec.bat将为自动批处理文件增加以上属性。"),e("br"),t._v("\n4.内存操作debug 调试内存 参数 -w [文件名] 写入二进制文件 -o [地址1] [地址2] 输出内存 -q 退出 exp:o 70 10[return] o 71 01[return] 01[return] q[return] DOS下通过写70h/71h PORT改变BIOS密码在CMOS中存放的对应位置的值,用以清除AWARD BIOS密码.debug 还可以破解硬盘保护卡等,但只可以在纯DOS下用。"),e("br"),t._v("\n5.分区操作给磁盘分区，一般都会分成四个区，磁盘分区由主分区、扩展分区、逻辑分区组成。PQ和Acronis Disk Director这两个工具都可以在不丢失数据的情况下对分区进行调整大小，以及合并等操作，XP系统的话你用PQ，WIN7系统的话用Acronis Disk Director 操作基本一样，可以去网上找教程来看看，再不重装系统的情况下都能调整分区大小，但是建议你还是先备份下数据再调整，毕竟对硬盘直接进行的操作有一定的危险性。"),e("br"),t._v('\nnet use ipipc$ " " /user:" " 建立IPC空链接'),e("br"),t._v('\n\nnet use ipipc$ "密码" /user:"用户名" 建立IPC非空链接'),e("br"),t._v('\n\nnet use h: ipc$ "密码" /user:"用户名" 直接登陆后映射对方C：到本地为H:'),e("br"),t._v("\n\nnet use h: ipc$ 登陆后映射对方C：到本地为H:"),e("br"),t._v("\n\nnet use ipipc$ /del 删除IPC链接"),e("br"),t._v("\n\nnet use h: /del 删除映射对方到本地的为H:的映射"),e("br"),t._v("\n\nnet user 用户名　密码　/add 建立用户"),e("br"),t._v("\n\nnet user guest /active:yes 激活guest用户"),e("br"),t._v("\n\nnet user 查看有哪些用户"),e("br"),t._v("\n\nnet user 帐户名 查看帐户的属性"),e("br"),t._v("\n\nnet localgroup administrators 用户名 /add 把“用户”添加到管理员中使其具有管理员权限"),e("br"),t._v("\n\nnet start 查看开启了哪些服务"),e("br"),t._v("\n\nnet start 服务名　开启服务；(如:net start telnet， net start schedule)"),e("br"),t._v("\n\nnet stop 服务名 停止某服务"),e("br"),t._v("\n\nnet time 目标ip 查看对方时间"),e("br"),t._v("\n\nnet time 目标ip /set 设置本地计算机时间与“目标IP”主机的时间同步,加上参数/yes可取消确认信息"),e("br"),t._v("\n\nnet view 查看本地局域网内开启了哪些共享"),e("br"),t._v("\n\nnet view ip 查看对方局域网内开启了哪些共享"),e("br"),t._v("\n\nnet config 显示系统网络设置"),e("br"),t._v("\n\nnet logoff 断开连接的共享"),e("br"),t._v("\n\nnet pause 服务名 暂停某服务"),e("br"),t._v('\n\nnet send ip "文本信息" 向对方发信息'),e("br"),t._v("\n\nnet ver 局域网内正在使用的网络连接类型和信息"),e("br"),t._v("\n\nnet share 查看本地开启的共享"),e("br"),t._v("\n\nnet share ipc$ 开启ipc$共享"),e("br"),t._v("\n\nnet share ipc$ /del 删除ipc$共享"),e("br"),t._v("\n\nnet share c$ /del 删除C：共享"),e("br"),t._v("\n\nnet user guest 12345 用guest用户登陆后用将密码改为12345"),e("br"),t._v("\n\nnet password 密码 更改系统登陆密码"),e("br"),t._v("\n\nnetstat -a 查看开启了哪些端口,常用netstat -an"),e("br"),t._v("\n\nnetstat -n 查看端口的网络连接情况，常用netstat -an"),e("br"),t._v("\n\nnetstat -v 查看正在进行的工作"),e("br"),t._v("\n\nnetstat -p 协议名 例：netstat -p tcq/ip 查看某协议使用情况"),e("br"),t._v("\n\nnetstat -s 查看正在使用的所有协议使用情况"),e("br"),t._v("\n\nnbtstat -A ip 对方136到139其中一个端口开了的话，就可查看对方最近登陆的用户名"),e("br"),t._v("\n\ntracert -参数 ip(或计算机名) 跟踪路由（数据包），参数：“-w数字”用于设置超时间隔。"),e("br"),t._v("\n\nping ip(或域名) 向对方主机发送默认大小为32字节的数据，参数：“-l[空格]数据包大小”；“-n发送数据次数”；“-t”指一直ping。"),e("br"),t._v("\n\nping -t -l 65550 ip 死亡之ping(发送大于64K的文件并一直ping就成了死亡之ping)"),e("br"),t._v("\n\nipconfig (winipcfg) 用于windows NT及XP(windows 95 98)查看本地ip地址，ipconfig可用参数“/all”显示全部配置信息"),e("br"),t._v("\n\ntlist -t 以树行列表显示进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内)"),e("br"),t._v("\n\nkill -F 进程名 加-F参数后强制结束某进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内)"),e("br"),t._v("\n\ndel -F 文件名 加-F参数后就可删除只读文件,/AR、/AH、/AS、/AA分别表示删除只读、隐藏、系统、存档文件，"),e("br"),t._v("\n/A-R、/A-H、/A-S、/A-A表示删除除只读、隐藏、系统、存档以外的文件。例如“DEL/AR *.*”表示删除当前目录下所有只读文件，“DEL/A-S *.*”表示删除当前目录下除系统文件以外的所有文件"),e("br"),t._v("\n\ndel /S /Q 目录 或用：rmdir /s /Q 目录 /S删除目录及目录下的所有子目录和文件。同时使用参数/Q 可取消删除操作时的系统确认就直接删除。（二个命令作用相同）"),e("br"),t._v("\n\nmove 盘符路径要移动的文件名　存放移动文件的路径移动后文件名 移动文件,用参数/y将取消确认移动目录存在相同文件的提示就直接覆盖"),e("br"),t._v('\n\nfc one.txt two.txt > 3st.txt 对比二个文件并把不同之处输出到3st.txt文件中，"> "和"> >" 是重定向命令'),e("br"),t._v("\n\nat id号 开启已注册的某个计划任务"),e("br"),t._v("\n\nat /delete 停止所有计划任务，用参数/yes则不需要确认就直接停止"),e("br"),t._v("\n\nat id号 /delete 停止某个已注册的计划任务"),e("br"),t._v("\n\nat 查看所有的计划任务"),e("br"),t._v("\n\nat ip time 程序名(或一个命令) /r 在某时间运行对方某程序并重新启动计算机"),e("br"),t._v("\n\nfinger username @host 查看最近有哪些用户登陆"),e("br"),t._v("\n\ntelnet ip 端口 远和登陆服务器,默认端口为23"),e("br"),t._v("\n\nopen ip 连接到IP（属telnet登陆后的命令）"),e("br"),t._v("\n\ntelnet 在本机上直接键入telnet 将进入本机的telnet"),e("br"),t._v("\n\ncopy 路径文件名1　路径文件名2 /y 复制文件1到指定的目录为文件2，用参数/y就同时取消确认你要改写一份现存目录文件"),e("br"),t._v("\n\ncopy c:srv.exe ipadmin$ 复制本地c:srv.exe到对方的admin下"),e("br"),t._v("\n\ncopy 1st.jpg/b+2st.txt/a 3st.jpg 将2st.txt的内容藏身到1st.jpg中生成3st.jpg新的文件，注：2st.txt文件头要空三排，参数：/b指二进制文件，/a指ASCLL格式文件"),e("br"),t._v("\n\ncopy ipadmin$svv.exe c: 或:copyipadmin$*.* 复制对方admini$共享下的srv.exe文件（所有文件）至本地C："),e("br"),t._v("\n\nxcopy 要复制的文件或目录树　目标地址目录名 复制文件和目录树，用参数/Y将不提示覆盖相同文件"),e("br"),t._v("\n\n用参数/e才可连目录下的子目录一起复制到目标地址下。"),e("br"),t._v("\n\ntftp -i 自己IP(用肉机作跳板时这用肉机IP) get server.exec:server.exe 登陆后，"),e("br"),t._v("\n将“IP”的server.exe下载到目标主机c:server.exe 参数：-i指以二进制模式传送，如传送exe文件时用，如不加-i 则以ASCII模式（传送文本文件模式）进行传送"),e("br"),t._v("\n\ntftp -i 对方IP　put c:server.exe 登陆后，上传本地c:server.exe至主机"),e("br"),t._v("\n\nftp ip 端口 用于上传文件至服务器或进行文件操作，默认端口为21。bin指用二进制方式传送（可执行文件进）；默认为ASCII格式传送(文本文件时)"),e("br"),t._v("\n\nroute print 显示出IP路由，将主要显示网络地址Network addres，子网掩码Netmask，网关地址Gateway addres，接口地址Interface"),e("br"),t._v("\n\narp 查看和处理ARP缓存，ARP是名字解析的意思，负责把一个IP解析成一个物理性的MAC地址。arp -a将显示出全部信息"),e("br"),t._v("\n\nstart 程序名或命令 /max 或/min 新开一个新窗口并最大化（最小化）运行某程序或命令"),e("br"),t._v("\n\nmem 查看cpu使用情况"),e("br"),t._v("\n\nattrib 文件名(目录名) 查看某文件（目录）的属性"),e("br"),t._v("\n\nattrib 文件名 -A -R -S -H 或 +A +R +S +H 去掉(添加)某文件的 存档，只读，系统，隐藏 属性；用+则是添加为某属性"),e("br"),t._v("\n\ndir 查看文件，参数：/Q显示文件及目录属系统哪个用户，/T:C显示文件创建时间，/T:A显示文件上次被访问时间，/T:W上次被修改时间"),e("br"),t._v("\n\ndate /t 、 time /t 使用此参数即“DATE/T”、“TIME/T”将只显示当前日期和时间，而不必输入新日期和时间"),e("br"),t._v("\n\nset 指定环境变量名称=要指派给变量的字符 设置环境变量"),e("br"),t._v("\n\nset 显示当前所有的环境变量"),e("br"),t._v("\n\nset p(或其它字符) 显示出当前以字符p(或其它字符)开头的所有环境变量"),e("br"),t._v("\n\npause 暂停批处理程序，并显示出：请按任意键继续...."),e("br"),t._v("\n\nif 在批处理程序中执行条件处理（更多说明见if命令及变量）"),e("br"),t._v("\n\ngoto 标签 将cmd.exe导向到批处理程序中带标签的行（标签必须单独一行，且以冒号打头，例如：“：start”标签）"),e("br"),t._v("\n\ncall 路径批处理文件名 从批处理程序中调用另一个批处理程序 （更多说明见call /?）"),e("br"),t._v("\n\nfor 对一组文件中的每一个文件执行某个特定命令（更多说明见for命令及变量）"),e("br"),t._v("\n\necho on或off 打开或关闭echo，仅用echo不加参数则显示当前echo设置"),e("br"),t._v("\n\necho 信息 在屏幕上显示出信息"),e("br"),t._v('\n\necho 信息 >> pass.txt 将"信息"保存到pass.txt文件中'),e("br"),t._v('\n\nfindstr "Hello" aa.txt 在aa.txt文件中寻找字符串hello'),e("br"),t._v("\n\nfind 文件名 查找某文件"),e("br"),t._v("\n\ntitle 标题名字 更改CMD窗口标题名字"),e("br"),t._v("\n\ncolor 颜色值 设置cmd控制台前景和背景颜色；0=黑、1=蓝、2=绿、3=浅绿、4=红、5=紫、6=黄、7=白、8=灰、9=淡蓝、A=淡绿、B=淡浅绿、C=淡红、D=淡紫、E=淡黄、F=亮白"),e("br"),t._v("\n\nprompt 名称 更改cmd.exe的显示的命令提示符(把C:、D:统一改为：EntSky )"),e("br"),t._v("\n\nver 在DOS窗口下显示版本信息\n\nwinver 弹出一个窗口显示版本信息（内存大小、系统版本、补丁版本、计算机名）"),e("br"),t._v("\n\nformat 盘符 /FS:类型 格式化磁盘,类型:FAT、FAT32、NTFS ,例：Format D: /FS:NTFS"),e("br"),t._v("\n\nmd　目录名 创建目录"),e("br"),t._v("\n\nreplace 源文件　要替换文件的目录 替换文件"),e("br"),t._v("\n\nren 原文件名　新文件名 重命名文件名"),e("br"),t._v("\n\ntree 以树形结构显示出目录，用参数-f 将列出第个文件夹中文件名称"),e("br"),t._v("\n\ntype 文件名 显示文本文件的内容"),e("br"),t._v("\n\nmore 文件名 逐屏显示输出文件"),e("br"),t._v("\n\ndoskey 要锁定的命令=字符"),e("br"),t._v("\n\ndoskey 要解锁命令= 为DOS提供的锁定命令(编辑命令行，重新调用win2k命令，并创建宏)。如：锁定dir命令：doskey dir=entsky (不能用doskey dir=dir)；解锁：doskey dir="),e("br"),t._v("\n\ntaskmgr 调出任务管理器"),e("br"),t._v("\n\nchkdsk /F D: 检查磁盘D并显示状态报告；加参数/f并修复磁盘上的错误"),e("br"),t._v("\n\ntlntadmn telnt服务admn,键入tlntadmn选择3，再选择8,就可以更改telnet服务默认端口23为其它任何端口"),e("br"),t._v("\n\nexit 退出cmd.exe程序或目前，用参数/B则是退出当前批处理脚本而不是cmd.exe"),e("br"),t._v("\n\npath 路径可执行文件的文件名 为可执行文件设置一个路径。"),e("br"),t._v("\n\ncmd 启动一个win2K命令解释窗口。参数：/eff、/en 关闭、开启命令扩展；更我详细说明见cmd /?"),e("br"),t._v("\n\nregedit /s 注册表文件名 导入注册表；参数/S指安静模式导入，无任何提示；"),e("br"),t._v("\n\nregedit /e 注册表文件名 导出注册表"),e("br"),t._v("\n\ncacls 文件名　参数 显示或修改文件访问控制列表（ACL）——针对NTFS格式时。"),e("br"),t._v("\n参数：/D 用户名:设定拒绝某用户访问；/P 用户名:perm 替换指定用户的访问权限；"),e("br"),t._v("\n/G 用户名:perm 赋予指定用户访问权限；Perm 可以是: N 无，R 读取， W 写入， C 更改(写入)，F 完全控制；例：cacls D: est.txt /D pub 设定d: est.txt拒绝pub用户访问。"),e("br"),t._v("\n\ncacls 文件名 查看文件的访问用户权限列表"),e("br"),t._v("\n\nREM 文本内容 在批处理文件中添加注解"),e("br"),t._v("\n\nnetsh 查看或更改本地网络配置情况"),e("br"),e("br")])])}],b={},u=b,v=e("2877"),g=Object(v["a"])(u,c,p,!1,null,"789b5eac",null),m=g.exports,_=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    yyyyyyyyyyyyyyyyyyyyyyyy\n")])},d=[],h={},f=h,y=Object(v["a"])(f,_,d,!1,null,"498c9f06",null),S=y.exports,w=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},k=[],x={},C=x,j=Object(v["a"])(C,w,k,!1,null,"90f215c0",null),P=j.exports,T=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},E=[],O={},M=O,A=Object(v["a"])(M,T,E,!1,null,"e4da473e",null),N=A.exports,I=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},D=[],z={},$=z,R=Object(v["a"])($,I,D,!1,null,"639ec3a2",null),J=R.exports,L=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},H=[],q={},F=q,W=Object(v["a"])(F,L,H,!1,null,"39aaaae3",null),B=W.exports,U=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},G=[],V={},X=V,Q=Object(v["a"])(X,U,G,!1,null,"0fb69224",null),Y=Q.exports,K=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Z=[],tt={},nt=tt,et=Object(v["a"])(nt,K,Z,!1,null,"347b0d36",null),at=et.exports,rt={components:{m1:m,m2:S,m3:P,m4:N,m5:J,m6:B,m7:Y,m8:at},data:function(){return i()({tab:1,tabs:[1,2,3,4,5,6,7,8]},"tabs",[{text:"CMD命令"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"}])}},st=rt,ot=Object(v["a"])(st,s,o,!1,null,"3a1b7ae4",null),lt=ot.exports,it=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+t.value,label:n+1+"."+t.label}})})),1),e(""+t.tab,{tag:"component"})],1)},ct=[],pt=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},bt=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("pre",[t._v("        在mac下npm install的错误处理\nsudo －s      权限问题\n\ncommand+shift+G，前往文件夹\ncommand+shift+. 显示隐藏文件\nopen ~/.bash_profile .  打开文件\nsource ~/.bash_profile   立即生效\nPATH=$PATH:~/.composer/vendor/bin  添加 path\n\n\nmac 终端 一些命令\n\nsudo －s      权限问题\ncd downloads\nmkdir  生成文件夹\ncd    进入 \ncd ../server\nls    列出当前文件夹下的文件夹\ntouch js/class/test.js   创建test 文件，并 初始化\ntouch views/index.ejs  初始化创建 入口 模板文件\n\nclear   清空 \n    ")]),e("pre",[t._v("        mac退出bash-32\n        https://blog.csdn.net/qingtian12138/article/details/68065272\n\n今天准备学Scala，配环境的时候，不知道怎么弄得，晕晕乎乎把终端root了，打开就显示bash-32，不显示当前工作路径了，输入exit也没用，打开还是bash, 搜了一下午解决方案，都不好使，咨询了大神，终于弄好了，下面记录下来。\n出现这种情况的原因是进了shell环境，我们首先检查终端是不是一打开就默认进shell环境，\n左上角打开终端的偏好设置，将shell的打开方式那一栏选命令\n\n\n然后重启终端，看看问题是不是解决了，如果还是不行，接着下一步\n输入vi ~/.bash_profile\n打开配置文件，输入i进入编辑页面，在最后一行加入\nexport PS1='[\\u@\\h \\w]\\$'\n\n然后按Esc退出编辑模式，输入大写ZZ保存退出。\n然后执行\nsource ~/.bash_profile\n重启终端，问题解决！\n\n\n其实呢，加进去的那一行是bash可识别的转义序列\nbash可识别的转义序列有下面这些：\n\\u 用户名\n\\h 主机名第一部分\n\\H 主机名全称\n\\w 当前工作目录（如 “/home/username/mywork”）\n\\W 当前工作目录的“基名 (basename)”（如 “mywork”)\n\\t 24 小时制时间\n\\T 12 小时制时间\n\\@ 带有 am/pm 的 12 小时制时间\n\\d “Sat Dec 18″ 格式的日期\n\\s shell 的名称（如 “bash”)\n\\v bash 的版本（如 2.04）\n\\V Bash 版本（包括补丁级别）\n\\n 换行符\n\\r 回车符\n\\\\ 反斜杠\n\\a ASCII 响铃字符（也可以键入 07）\n\\e ASCII 转义字符（也可以键入 33)\n这个序列应该出现在不移动光标的字符序列（如颜色转义序列）之前。它使bash能够正确计算自动换行。\n这个序列应该出现在非打印字符序列之后。\n知道了全部的转义序列，就可以对自己的终端提示符进行定制了。\n\n\n    ")])])}],ut={},vt=ut,gt=Object(v["a"])(vt,pt,bt,!1,null,"db8584be",null),mt=gt.exports,_t=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},dt=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("h4",[t._v("Mac电脑Tomcat下载及安装(详细)")]),e("pre",[t._v("           1.打开Apache Tomcat官网,选择你需要的版本进行下载:\n地址http://tomcat.apache.org/download-70.cgi\n\n2.解压apache-tomcat-7.0.82文件,最好把他放入/Library(资源库中)\nmac寻找library资源库\n\n(1).点击finder--\x3e用户--\x3e你电脑的名字--\x3e资源库(有的也叫/Library)\n\n\n\n(2).有些苹果将library目录隐藏起来了，要进入那个目录，需要用到一定的技巧。 \n\n打开Finder，按下shift+command+g，输入“~/Library”（输入引号里面的），再按回车就到了。\n\n3.配置Tomcat\n\n(1).对目录进行权限设置：\n\n打开终端输入  sudo chmod 755 Library/tomcat/bin/*.sh  回车，设置文件的读写执行权限；(这里需要输入管理员密码)\n\n为了方便使用把这里把解压后的apache-tomcat-7.0.82重新命名为tomcat.\n\nsudo chmod 755 (你Tomcat解压的位置,可以直接拖拽放入)/bin/*.sh\n\n注释:sudo通常为系统超级管理员755 代表用户对该文件拥有读，写，执行的权限，\n同组其他人员拥有执行和读的权限，没有写的权限，其他用户的权限和同组人员权限一样。777代表，user,group ,others ,都有读写和可执行权限。\n\n(2).启动Tomcat      \n\n启动方法一:在终端中输入 sudo sh startup.sh\n\n若出现如下提示则表示安装并运行成功： \n\n\n启动方法二:在Library/tomcat/bin中找到startup.sh文件,把文件拖入到终端中回车启动\n\n\n4.验证Tomcat是否启动\n\n打开你的safari,然后在网址输入框输入http://localhost:8080/回车\n\n如果能正常打开tomcat首页，说明tomcat 配置启动成功:\n--------------------- \n\n       ")])])}],ht={},ft=ht,yt=Object(v["a"])(ft,_t,dt,!1,null,"bc6d13e4",null),St=yt.exports,wt=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},kt=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("pre",[t._v('        Mac安装、配置Maven\n2017年09月16日 21:15:52 东陆之滇 阅读数：22536\n 版权声明：欢迎转载，但是请附上原文链接! https://blog.csdn.net/zixiao217/article/details/78006599\nMac下安装maven步骤如下：\n下载maven， http://maven.apache.org/download.cgi 下载 \n\n\n我们选择binary zip archive 的类型 。\n解压maven 解压下载好的maven’，将目录丢到终端命令去获取文件路径。设置path： \nvi ~/.bash_profile \n添加maven的路径，将下载好的maven资源引入path 中：\nexport M2_HOME=/Users/byronyy/Documents/zixiao217/jobsoftwares/apache-maven-3.5.0\nexport PATH=$PATH:$M2_HOME/bin\n1\n2\n使path设置生效 \n设置path后，使用以下命令使之生效： \nsource ~/.bash_profile\n查看maven配置是否生效 \n使用 man -v 命令查看mvn命令是否ok\n mvn -v\nApache Maven 3.5.0 (ff8f5e7444045639af65f6095c62210b5713f426; 2017-04-04T03:39:06+08:00)\nMaven home: /Users/byronyy/Documents/zixiao217/jobsoftwares/apache-maven-3.5.0\nJava version: 1.8.0_144, vendor: Oracle Corporation\nJava home: /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre\nDefault locale: zh_CN, platform encoding: UTF-8\nOS name: "mac os x", version: "10.12.6", arch: "x86_64", family: "mac"\n1\n2\n3\n4\n5\n6\n7\n我们看到maven安装并设置ok了。接下来可以使用maven构建应用了。\n')])])}],xt={},Ct=xt,jt=Object(v["a"])(Ct,wt,kt,!1,null,"f6c9236a",null),Pt=jt.exports,Tt=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Et=[],Ot={},Mt=Ot,At=Object(v["a"])(Mt,Tt,Et,!1,null,"4942b3d4",null),Nt=At.exports,It=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Dt=[],zt={},$t=zt,Rt=Object(v["a"])($t,It,Dt,!1,null,"1f4e9b15",null),Jt=Rt.exports,Lt=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Ht=[],qt={},Ft=qt,Wt=Object(v["a"])(Ft,Lt,Ht,!1,null,"154afb54",null),Bt=Wt.exports,Ut=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Gt=[],Vt={},Xt=Vt,Qt=Object(v["a"])(Xt,Ut,Gt,!1,null,"69332cd2",null),Yt=Qt.exports,Kt=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Zt=[],tn={},nn=tn,en=Object(v["a"])(nn,Kt,Zt,!1,null,"bd1b5e50",null),an=en.exports,rn={components:{m1:mt,m2:St,m3:Pt,m4:Nt,m5:Jt,m6:Bt,m7:Yt,m8:an},data:function(){return{tab:"m1",tabs:[{label:"基本",value:"m1"},{label:"基本",value:"m2"},{label:"基本",value:"m3"},{label:"基本",value:"m4"},{label:"基本",value:"m5"},{label:"基本",value:"m6"},{label:"基本",value:"m7"},{label:"基本",value:"m8"}]}}},sn=rn,on=Object(v["a"])(sn,it,ct,!1,null,"c89a65c6",null),ln=on.exports,cn={components:{win:lt,mac:ln},data:function(){return{tab:"win",tabs:["win","mac"]}}},pn=cn,bn=Object(v["a"])(pn,a,r,!1,null,"55359218",null);n["default"]=bn.exports},"221b":function(t,n,e){"use strict";e.r(n);var a=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+t.value,label:n+1+"."+t.label}})})),1),e(""+t.tab,{tag:"component"})],1)},r=[],s=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",t._l(t.books,(function(n,a){return e("div",{key:a},[e("a",{attrs:{href:t.compute_book_path(n),target:"_blank",rel:"noopener noreferrer"}},[t._v(t._s(t.compute_book_name(n)))])])})),0)},o=[],l=(e("28a5"),{data:function(){return{bookshelf_prefix:"https://jinnianwushuang.github.io/jinnian-space/"}},methods:{compute_book_path:function(t){return"".concat(this.bookshelf_prefix).concat(t.trim())},compute_book_name:function(t){var n=t.split("/");return n[n.length-1]}}}),i={mixins:[l],data:function(){return{books:["books/web/jinnian-web-2020-01-13.xmind","books/web/阮一峰JavaScript基础总结.xmind"]}}},c=i,p=e("2877"),b=Object(p["a"])(c,s,o,!1,null,"3cb387ca",null),u=b.exports,v=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{staticClass:"q-pa-md"},[e("div",{staticClass:"q-mb-md  "},[t._v("总书本 数量："+t._s(t.book_num)+"    ")]),e("div",{staticClass:"q-mb-md  "},[t._v("总书本 项目数：   "+t._s(t.book_to_buy.length))]),e("q-markup-table",[e("thead",[e("tr",{staticClass:"text-left"},[e("th",{},[t._v("分类")]),e("th",{},[t._v("语种")]),e("th",{},[t._v("名字")]),e("th",{},[t._v("是否套装")]),e("th",{},[t._v("本数")]),e("th",{},[t._v("是否已购买")]),e("th",{},[t._v("购买日期")])])]),e("tbody",t._l(t.book_to_buy,(function(n,a){return e("tr",{key:a},[e("td",{},[t._v(t._s(n.type))]),e("td",{},[t._v(t._s(t.compute_lang_str(n.lang)))]),e("td",{},[t._v(" "+t._s(n.name))]),e("td",{},[t._v(" "+t._s(n.series?"是":"否"))]),e("td",{},[t._v(" "+t._s(n.num))]),e("td",{},[t._v(" "+t._s(1==n.buy?"是":"否"))]),e("td",{},[t._v(" "+t._s(n.date))])])})),0)])],1)},g=[],m=[{type:"科普",lang:"zh",name:"中国国家地理百科全书",series:!0,num:10,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"环球国家地理百科全书",series:!0,num:10,buy:1,date:"2020-10-23"},{type:"小说",lang:"en",name:"哈利波特(1-7)",series:!0,num:7,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"BBC科普--地球-行星的力量",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"BBC科普--海洋-深水探秘",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"BBC科普--生命-非常的世界",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"BBC宇宙科普--宇宙起源",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"BBC宇宙科普--宇宙之光",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"BBC宇宙科普--宇宙星辰",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"BBC--4K海洋百科 蓝色星球二",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"BBC--飞跃地球",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"BBC--地球脉动",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"BBC--地球脉动2 -奇迹世界",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"BBC--冰冻星球",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"BBC--生命的故事",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"BBC--俯瞰地球",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"天文摄影指南",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"DK博物大百科",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经典科普",lang:"zh",name:"世界科普10本-几何原本",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经典科普",lang:"zh",name:"世界科普10本-物种起源",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经典科普",lang:"zh",name:"世界科普10本-自然史",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经典科普",lang:"zh",name:"世界科普10本-相对论",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经典科普",lang:"zh",name:"世界科普10本-基因论",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经典科普",lang:"zh",name:"世界科普10本-人在自然界的位置",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经典科普",lang:"zh",name:"世界科普10本-天体运行论",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经典科普",lang:"zh",name:"世界科普10本-自然哲学之数学原理",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经典科普",lang:"zh",name:"世界科普10本-通俗天文学",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经典科普",lang:"zh",name:"世界科普10本-海陆的起源",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"地球与太空--太空传奇",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"地球与太空--行星全书",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"地球与太空--星座全书",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"地球与太空--从粒子到宇宙",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"地球与太空--地球与太空",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"太空--纸上天文馆",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"简史--今日简史",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"简史--万物简史",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"简史--时间简史",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"简史--未来简史",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"简史--人类简史",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"科普",lang:"zh",name:"简史--宇宙简史",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"人生原则",lang:"zh",name:"原则--原则",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"人生原则",lang:"zh",name:"原则--阿里巴巴人力资源管理",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"人生原则",lang:"zh",name:"原则--阿米巴经管理",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"人生原则",lang:"zh",name:"原则--华为人力资源管理",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"人生原则",lang:"zh",name:"原则--稻盛和夫给年轻人的忠告",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"人生原则",lang:"zh",name:"原则--格局",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"人生原则",lang:"zh",name:"原则--见识",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"人生原则",lang:"zh",name:"原则--情商",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"人生原则",lang:"zh",name:"原则--眼界",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"人生原则",lang:"zh",name:"原则--策略",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"思维训练",lang:"zh",name:"思维训练--思维导图",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"思维训练",lang:"zh",name:"思维训练--思维风暴",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"思维训练",lang:"zh",name:"思维训练--最强大脑",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"思维训练",lang:"zh",name:"思维训练--高效记忆法",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"思维训练",lang:"zh",name:"思维训练--超级记忆术",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"思维训练",lang:"zh",name:"思维训练--锻炼思维的逻辑游戏",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"思维训练",lang:"zh",name:"思维训练--逆转思维",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"思维训练",lang:"zh",name:"思维训练--认知天性",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"思维训练",lang:"zh",name:"思维训练--挑战大脑的侦探推理游戏",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"思维训练",lang:"zh",name:"思维训练--超级学习力",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"思维训练",lang:"zh",name:"思维训练--自控力",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"戴尔卡耐基心理学",lang:"zh",name:"戴尔卡耐基--人性的弱点",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"戴尔卡耐基心理学",lang:"zh",name:"戴尔卡耐基--人性的突破",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"戴尔卡耐基心理学",lang:"zh",name:"戴尔卡耐基--卡耐基传",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"戴尔卡耐基心理学",lang:"zh",name:"戴尔卡耐基--语言的艺术",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"戴尔卡耐基心理学",lang:"zh",name:"戴尔卡耐基--人生箴言",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"戴尔卡耐基心理学",lang:"zh",name:"戴尔卡耐基--林肯外传",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"创业心理学",lang:"zh",name:"创业心理学--低风险创业",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"创业心理学",lang:"zh",name:"创业心理学--塔木德",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"创业心理学",lang:"zh",name:"创业心理学--羊皮卷",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"创业心理学",lang:"zh",name:"创业心理学--领导力法则",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"创业心理学",lang:"zh",name:"创业心理学--狼道",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"创业心理学",lang:"zh",name:"创业心理学--玩的就是心计",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"创业心理学",lang:"zh",name:"创业心理学--微表情心理学",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"创业心理学",lang:"zh",name:"创业心理学--沃顿谈判课",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"创业心理学",lang:"zh",name:"创业心理学--沃尔森法则",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"创业心理学",lang:"zh",name:"创业心理学--吉德林法则",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"华为企业管理",lang:"zh",name:"华为任正非--华为方法",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"华为企业管理",lang:"zh",name:"华为任正非--华为创新管理",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"华为企业管理",lang:"zh",name:"华为任正非--华为管理哲学",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"华为企业管理",lang:"zh",name:"华为任正非--华为离职江湖",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"华为企业管理",lang:"zh",name:"华为任正非--神坛在坐华为往右",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"华为企业管理",lang:"zh",name:"华为任正非--华为的冬天",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"华为企业管理",lang:"zh",name:"华为任正非--以奋斗着为本",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"华为企业管理",lang:"zh",name:"华为任正非--以客户为中心",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"华为企业管理",lang:"zh",name:"华为任正非--天道酬勤",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"华为企业管理",lang:"zh",name:"华为任正非--致新员工书",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"华为企业管理",lang:"zh",name:"华为任正非--华为之秘",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"华为企业管理",lang:"zh",name:"华为任正非--任正非",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"华为企业管理",lang:"zh",name:"华为任正非--世界极客任正非",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"管理",lang:"zh",name:"管理--不懂带团队，你就自己累",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"管理",lang:"zh",name:"管理--管理三要：能识人会用人懂管理",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"管理",lang:"zh",name:"管理--领导力法则",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"管理",lang:"zh",name:"管理--如何说，员工才会听",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"管理",lang:"zh",name:"管理--高情商管理，三分管人，七分做人",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经济学",lang:"zh",name:"经济学--博弈论",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经济学",lang:"zh",name:"经济学--经济常识一本全",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经济学",lang:"zh",name:"经济学--经济学（越简单越实用）",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经济学",lang:"zh",name:"经济学--你的第一本金融学",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经济学",lang:"zh",name:"经济学--北大经济课",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"经济学",lang:"zh",name:"经济学--国富论",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"投资管理",lang:"zh",name:"生活和工作原则--瑞达利著",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"投资管理",lang:"zh",name:"债务危机--瑞达利著",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"北大金书",lang:"zh",name:"人生金书系列--北大经济课",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"北大金书",lang:"zh",name:"人生金书系列--北大人文课",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"北大金书",lang:"zh",name:"人生金书系列--北大投资课",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"北大金书",lang:"zh",name:"人生金书系列--北大金融课",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"北大金书",lang:"zh",name:"人生金书系列--经济学一本通",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"北大金书",lang:"zh",name:"人生金书系列--北大口才课",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"北大金书",lang:"zh",name:"人生金书系列--北大国学课",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"北大金书",lang:"zh",name:"人生金书系列--北大心理课",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"北大金书",lang:"zh",name:"人生金书系列--北大管理课",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"北大金书",lang:"zh",name:"人生金书系列--北大哲学课",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"哈弗管理",lang:"zh",name:"哈弗管理全集--管理者手册",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"哈弗管理",lang:"zh",name:"哈弗管理全集--企业培训管理",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"哈弗管理",lang:"zh",name:"哈弗管理全集--生产与品质管理",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"哈弗管理",lang:"zh",name:"哈弗管理全集--办公行政管理",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"哈弗管理",lang:"zh",name:"哈弗管理全集--市场营销管理",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"哈弗管理",lang:"zh",name:"哈弗管理全集--人力资源管理",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"哈弗管理",lang:"zh",name:"哈弗管理全集--财务管理",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"哈弗管理",lang:"zh",name:"哈弗管理全集--投资管理",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"财经",lang:"zh",name:"财经人物传记--巴菲特",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"财经",lang:"zh",name:"财经人物传记--李嘉诚",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"财经",lang:"zh",name:"财经人物传记--乔布斯",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"财经",lang:"zh",name:"财经人物传记--德鲁克说管理",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"财经",lang:"zh",name:"财经人物传记--科特勒营销全书",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"商界",lang:"zh",name:"商界40年--弄潮儿",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"商界",lang:"zh",name:"商界40年--先行者",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"商界",lang:"zh",name:"商界40年--梦想家",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"商界",lang:"zh",name:"商界40年--逐鹿人",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"营销-淘宝",lang:"zh",name:"营销淘宝--淘宝天猫开店一本通",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"营销-淘宝",lang:"zh",name:"营销淘宝--淘宝天猫SEO",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"营销-淘宝",lang:"zh",name:"营销淘宝--社群营销",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"营销-淘宝",lang:"zh",name:"营销淘宝--从零开始学运营",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"营销-淘宝",lang:"zh",name:"营销淘宝--营销策划食用技巧",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"营销-淘宝",lang:"zh",name:"营销淘宝--别输在不懂营销上",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"处世智慧",lang:"zh",name:"处世智慧--鬼谷子",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"处世智慧",lang:"zh",name:"处世智慧--羊皮卷",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"处世智慧",lang:"zh",name:"处世智慧--墨菲定律",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"处世智慧",lang:"zh",name:"处世智慧--人性的弱点",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"处世智慧",lang:"zh",name:"处世智慧--狼道",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"处世智慧",lang:"zh",name:"处世智慧--口才三绝",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"处世智慧",lang:"zh",name:"处世智慧--为人三会",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"处世智慧",lang:"zh",name:"处世智慧--修心三不",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"处世智慧",lang:"zh",name:"处世智慧--格局",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"处世智慧",lang:"zh",name:"处世智慧--高情商办事就让人舒服",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"处世智慧",lang:"zh",name:"处世智慧--人际关系心理学",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"处世智慧",lang:"zh",name:"处世智慧--跟任何人都能聊得来",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"计算机",lang:"en",name:"计算机--计算机程序设计艺术-基本算法",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"计算机",lang:"en",name:"计算机--计算机程序设计艺术-半数值算法",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"计算机",lang:"en",name:"计算机--计算机程序设计艺术-排序与查找",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"计算机",lang:"en",name:"计算机--计算机程序设计艺术-组合算法",series:!0,num:1,buy:1,date:"2020-10-23"},{type:"计算机",lang:"zh",name:"计算机--计算机科学技术百科全书",series:!1,num:1,buy:1,date:"2020-10-23"},{type:"国学",lang:"zh",name:"国学---资治通鉴",series:!0,num:16,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---二十四史",series:!0,num:24,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---孙子兵法与三十六计",series:!0,num:6,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---四书五经",series:!0,num:6,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---红楼梦",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---西游记",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---水浒传",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---三国演义",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---唐诗鉴赏辞典",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---宋词鉴赏辞典",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---元曲鉴赏辞典",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---历代辞赋鉴赏辞典",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---诗经楚辞鉴赏辞典",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---先秦两汉魏晋南北朝诗歌鉴赏辞典",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---元明清诗歌鉴赏辞典",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"国学",lang:"zh",name:"国学---古代诗词鉴赏辞典",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---林清玄散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---老舍散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---宗璞散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---鲁迅散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---余光中散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---朱自清散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---余秋雨散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---张晓风散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---粱衡散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---冯骥才散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---巴金散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---毕淑敏散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---冰心散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---丁立梅散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---史铁生散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---汪曾祺散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---沈从文散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"名家散文",lang:"zh",name:"散文---贾平凹散文精选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"历史",lang:"zh",name:"历史---世界文明孤独史-人类精神的伟大起源",series:!0,num:2,buy:1,date:"2020-10-24"},{type:"历史",lang:"zh",name:"历史---看得见的世界史---24册",series:!0,num:24,buy:1,date:"2020-10-24"},{type:"传记",lang:"zh",name:"毛泽东传",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"传记",lang:"zh",name:"周恩来传",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"传记",lang:"zh",name:"邓小平传",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"传记",lang:"zh",name:"蒋介石传",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"画传",lang:"zh",name:"故宫院长说故宫",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"画传",lang:"zh",name:"故宫院长说皇宫",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"画传",lang:"zh",name:"唐伯虎画传",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"画传",lang:"zh",name:"郑板桥画传",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"画传",lang:"zh",name:"鲁迅画传",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---弗兰肯斯坦",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---美丽新世界",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---格列佛游记",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---远大前程",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---鲁滨逊漂流记",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---理智与情感",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---双城记",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---傲慢与偏见",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---纯真年代",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---睡谷传说 英伦见闻录",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---木偶奇遇记",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---返老还童 菲茨杰拉德短篇小说选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---爱伦·坡短篇小说选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---丧钟为谁而鸣",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---嘉莉妹妹",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---菊与刀",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---乞力马扎罗的雪海明威短篇小说集",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---欧·亨利短篇小说选集",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---房龙地理",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---人类的故事",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---人猿泰山",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---马克·吐温短篇小说选集",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---瓦尔登湖",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---杰克·伦敦小说选野性的呼唤海狼",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---永别了,武器",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---老人与海",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---变色龙契诃夫短篇小说选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---论自由（严复译文卷 ）",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---本杰明·富兰克林自传",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---钢铁是怎样炼成的",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---雪莱抒情诗选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---都柏林人",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---少年维特之烦恼",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---社会学研究（严复译文卷）",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---勃朗夫人抒情十四行诗集",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---培根散文集",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---莎士比亚长诗 精韵全译",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---国富论（严复译文卷  上册）",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---国富论（严复译文卷  下册）",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---海蒂",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---泰戈尔诗歌集新月集飞鸟集",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---地心游记",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---欧也妮·葛朗台",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---名人传",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---高老头",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---昆虫记",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---包法利夫人",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---茶花女",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---海底两万里",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---羊脂球:莫泊桑短篇小说选",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---八十天环游地球",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---道林格雷的画像",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"中英对照名著",lang:"zh_en",name:"中英对照全译本---绿山墙的安妮",series:!1,num:1,buy:1,date:"2020-10-24"},{type:"小说",lang:"en",name:"冰与火之歌---A song of ice and fire",series:!0,num:5,buy:1,date:"2020-10-25"},{type:"工具书",lang:"en",name:"说文解字",series:!0,num:5,buy:1,date:"2020-10-26"},{type:"工具书",lang:"en",name:"汉字树",series:!0,num:8,buy:1,date:"2020-10-26"}],_={mixins:[l],data:function(){return{book_to_buy:m}},computed:{book_num:function(){var t=0;return m.map((function(n){t+=n.num})),t}},methods:{compute_lang_str:function(t){var n="";switch(t){case"en":n="英语";break;case"zh":n="中文";break;case"zh_en":n="中英双语";break;default:break}return n}}},d=_,h=Object(p["a"])(d,v,g,!1,null,"72dae812",null),f=h.exports,y=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n\n\nssss\n\n ")])},S=[],w={mixins:[l]},k=w,x=Object(p["a"])(k,y,S,!1,null,"2132ccbf",null),C=x.exports,j=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("table",{},[e("tbody",[e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510088278       ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("弗兰肯斯坦  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("24.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787519204204 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("美丽新世界  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("27.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510036682 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("格列佛游记  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("26.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787519246716 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("远大前程  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("66.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787506297004 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("鲁滨逊漂流记  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("18.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510010330 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("理智与情感  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("24.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787506294843 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("双城记  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("29.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787506296991 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("傲慢与偏见 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v(" 22.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510040023 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("纯真年代  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("28.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510099397 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("睡谷传说 英伦见闻录  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("29.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510033643")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("木偶奇遇记  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("14.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510088261 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("返老还童 菲茨杰拉德短篇小说选    \n                 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("24.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510032394 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("爱伦·坡短篇小说选  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("24.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510046001 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("丧钟为谁而鸣  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("39.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510032417 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("嘉莉妹妹  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("38.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510099380 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("菊与刀  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("31.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510041006 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("乞力马扎罗的雪海明威短篇小说集 \n          ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("29.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787506299350 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("欧·亨利短篇小说选集  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("19.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510022975 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("房龙地理  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("29.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510023651 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("人类的故事  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("29.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787519207199 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("人猿泰山  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("29.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787506299367 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("马克·吐温短篇小说选集  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("15.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510031458 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("瓦尔登湖  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("26.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510027833 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("杰克·伦敦小说选野性的呼唤海狼 \n          ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("29.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510044755 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("永别了,武器  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("26.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510027888 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("老人与海  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("12")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510045998 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("变色龙契诃夫短篇小说选  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("28.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510036330 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("论自由（严复译文卷 中英对照全译本） ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("19.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510031472 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("本杰明·富兰克林自传  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("16.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787519205430 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("钢铁是怎样炼成的  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("43.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510092220 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("雪莱抒情诗选  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("49.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510089244 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("都柏林人  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("22.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787506294850 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("少年维特之烦恼  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("15.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510040030 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("社会学研究（严复译文卷 中英对照全译本） ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("36.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510087417 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("勃朗*夫人抒情十四行诗集  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("18.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510040061 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("培根散文集  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("18.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510091797 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("莎士比亚长诗 精韵全译  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("34.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510041020 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("国富论（严复译文卷 中英对照全译本 套装上下册）\n          ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("75")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787519245115 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("海蒂  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("41.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510018633 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("泰戈尔诗歌集新月集飞鸟集  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("12.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510040047 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("地心游记  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("23.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510034640 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("欧也妮·葛朗台  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("18.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510044809 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("名人传  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("27.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510034633 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("高老头  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("24.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787519216337 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("昆虫记  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("32.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510033674 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("包法利夫人  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("29.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510032370 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("茶花女  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("18.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510031465 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("海底两万里  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("26.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510067112 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("羊脂球:莫泊桑短篇小说选  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("25.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510017636 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("八十天环游地球  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("18.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510044779 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("道林??格雷的画像  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("22.8")])],1)]),e("tr",[e("td",[e("font",{attrs:{size:"4"}},[t._v("9787510032387 ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("绿山墙的安妮  ")])],1),e("td",[e("font",{attrs:{size:"4"}},[t._v("25.8")])],1)])])])])},P=[],T={mixins:[l]},E=T,O=(e("b047"),Object(p["a"])(E,j,P,!1,null,"239e9e49",null)),M=O.exports,A=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n\n\nssss\n\n ")])},N=[],I={mixins:[l]},D=I,z=Object(p["a"])(D,A,N,!1,null,"851c4f7e",null),$=z.exports,R=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n\n\nssss\n\n ")])},J=[],L={mixins:[l]},H=L,q=Object(p["a"])(H,R,J,!1,null,"e8dd43fc",null),F=q.exports,W=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n\n\nssss\n\n ")])},B=[],U={mixins:[l]},G=U,V=Object(p["a"])(G,W,B,!1,null,"59b0e3c3",null),X=V.exports,Q=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n\n\nssss\n\n ")])},Y=[],K={mixins:[l]},Z=K,tt=Object(p["a"])(Z,Q,Y,!1,null,"27d06984",null),nt=tt.exports,et={components:{m1:u,m2:f,m3:C,m4:M,m5:$,m6:F,m7:X,m8:nt},data:function(){return{tab:"m1",tabs:[{label:"web",value:"m1"},{label:"书架书单",value:"m2"},{label:"未开发",value:"m3"},{label:"未开发",value:"m4"},{label:"未开发",value:"m5"},{label:"未开发",value:"m6"},{label:"未开发",value:"m7"},{label:"未开发",value:"m8"}]}}},at=et,rt=Object(p["a"])(at,a,r,!1,null,"4cc266dc",null);n["default"]=rt.exports},2512:function(t,n,e){},"2cff":function(t,n,e){"use strict";e.r(n);var a=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+(n+1),label:n+1+"."+t.text}})})),1),e("m"+t.tab,{tag:"component"})],1)},r=[],s=e("9523"),o=e.n(s),l=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n   rrrrrrrrrrrrrrrrrrrr\n")])},i=[],c={},p=c,b=e("2877"),u=Object(b["a"])(p,l,i,!1,null,"45d65e80",null),v=u.exports,g=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    yyyyyyyyyyyyyyyyyyyyyyyy\n")])},m=[],_={},d=_,h=Object(b["a"])(d,g,m,!1,null,"4f1f7416",null),f=h.exports,y=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},S=[],w={},k=w,x=Object(b["a"])(k,y,S,!1,null,"14faaf11",null),C=x.exports,j=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},P=[],T={},E=T,O=Object(b["a"])(E,j,P,!1,null,"29f2d35c",null),M=O.exports,A=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},N=[],I={},D=I,z=Object(b["a"])(D,A,N,!1,null,"7ddb04da",null),$=z.exports,R=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},J=[],L={},H=L,q=Object(b["a"])(H,R,J,!1,null,"d1c33658",null),F=q.exports,W=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},B=[],U={},G=U,V=Object(b["a"])(G,W,B,!1,null,"6d2a4c15",null),X=V.exports,Q=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Y=[],K={},Z=K,tt=Object(b["a"])(Z,Q,Y,!1,null,"43363356",null),nt=tt.exports,et={components:{m1:v,m2:f,m3:C,m4:M,m5:$,m6:F,m7:X,m8:nt},data:function(){return o()({tab:1,tabs:[1,2,3,4,5,6,7,8]},"tabs",[{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"}])}},at=et,rt=Object(b["a"])(at,a,r,!1,null,"a2eda0d8",null);n["default"]=rt.exports},"3afd":function(t,n,e){"use strict";e.r(n);var a=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+(n+1),label:n+1+"."+t.text}})})),1),e("m"+t.tab,{tag:"component"})],1)},r=[],s=e("9523"),o=e.n(s),l=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n   rrrrrrrrrrrrrrrrrrrr\n")])},i=[],c={},p=c,b=e("2877"),u=Object(b["a"])(p,l,i,!1,null,"71009b84",null),v=u.exports,g=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    yyyyyyyyyyyyyyyyyyyyyyyy\n")])},m=[],_={},d=_,h=Object(b["a"])(d,g,m,!1,null,"aca6b992",null),f=h.exports,y=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},S=[],w={},k=w,x=Object(b["a"])(k,y,S,!1,null,"48c9940f",null),C=x.exports,j=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},P=[],T={},E=T,O=Object(b["a"])(E,j,P,!1,null,"1ed57b50",null),M=O.exports,A=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},N=[],I={},D=I,z=Object(b["a"])(D,A,N,!1,null,"163d3ade",null),$=z.exports,R=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},J=[],L={},H=L,q=Object(b["a"])(H,R,J,!1,null,"6a256c5c",null),F=q.exports,W=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},B=[],U={},G=U,V=Object(b["a"])(G,W,B,!1,null,"be0d9dda",null),X=V.exports,Q=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Y=[],K={},Z=K,tt=Object(b["a"])(Z,Q,Y,!1,null,"77051854",null),nt=tt.exports,et={components:{m1:v,m2:f,m3:C,m4:M,m5:$,m6:F,m7:X,m8:nt},data:function(){return o()({tab:1,tabs:[1,2,3,4,5,6,7,8]},"tabs",[{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"}])}},at=et,rt=Object(b["a"])(at,a,r,!1,null,"79daca34",null);n["default"]=rt.exports},4067:function(t,n,e){"use strict";e.r(n);var a=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+(n+1),label:n+1+"."+t.text}})})),1),e("m"+t.tab,{tag:"component"})],1)},r=[],s=e("9523"),o=e.n(s),l=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n   rrrrrrrrrrrrrrrrrrrr\n")])},i=[],c={},p=c,b=e("2877"),u=Object(b["a"])(p,l,i,!1,null,"d98af63a",null),v=u.exports,g=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    yyyyyyyyyyyyyyyyyyyyyyyy\n")])},m=[],_={},d=_,h=Object(b["a"])(d,g,m,!1,null,"d516a09c",null),f=h.exports,y=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},S=[],w={},k=w,x=Object(b["a"])(k,y,S,!1,null,"693d9418",null),C=x.exports,j=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},P=[],T={},E=T,O=Object(b["a"])(E,j,P,!1,null,"bd25c596",null),M=O.exports,A=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},N=[],I={},D=I,z=Object(b["a"])(D,A,N,!1,null,"77790476",null),$=z.exports,R=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},J=[],L={},H=L,q=Object(b["a"])(H,R,J,!1,null,"4d84ebb7",null),F=q.exports,W=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},B=[],U={},G=U,V=Object(b["a"])(G,W,B,!1,null,"2390d2f8",null),X=V.exports,Q=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Y=[],K={},Z=K,tt=Object(b["a"])(Z,Q,Y,!1,null,"0cc68b8e",null),nt=tt.exports,et={components:{m1:v,m2:f,m3:C,m4:M,m5:$,m6:F,m7:X,m8:nt},data:function(){return o()({tab:1,tabs:[1,2,3,4,5,6,7,8]},"tabs",[{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"}])}},at=et,rt=Object(b["a"])(at,a,r,!1,null,"b0231f44",null);n["default"]=rt.exports},"42b8":function(t,n,e){"use strict";e.r(n);var a=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+t.value,label:n+1+"."+t.label}})})),1),e(""+t.tab,{tag:"component"})],1)},r=[],s=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},o=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("pre",[t._v("          添加系统变量\nC:\\Program Files\\MySQL\\MySQL Server 8.0\\bin\n\nnet start mysql\n\nmysql restart\n\n\n\n　一、启动方式\n　　1、使用 service 启动：service mysqld start\n　　2、使用 mysqld 脚本启动：/etc/inint.d/mysqld start\n　　3、使用 safe_mysqld 启动：safe_mysqld&\n　　二、停止\n　　1、使用 service 启动：service mysqld stop\n　　2、使用 mysqld 脚本启动：/etc/inint.d/mysqld stop\n　　3、mysqladmin shutdown\n　　三、重启\n　　1、使用 service 启动：service mysqld restart\n　　2、使用 mysqld 脚本启动：/etc/inint.d/mysqld restart\n      ")]),e("hr"),e("pre",[t._v('mysql  my.ini\n\n          [mysql]\ndefault-character-set=utf8\n\n[mysqld]\nport = 3306\ndefault_authentication_plugin=mysql_native_password\nbasedir="C:/Program Files/MySQL/MySQL Server 8.0/"\ndatadir="C:/Program Files/MySQL/MySQL Server 8.0/data/"\ncharacter-set-server = utf8\ndefault-storage-engine = MyISAM\n      ')]),e("hr"),e("pre",[t._v('          mysql  my.ini\n\n          [client]\n#password=your_password\nport=3306\nsocket=/tmp/mysql.sock\n\n[mysqld]\nport=3306\nsocket=/tmp/mysql.sock\nkey_buffer_size=256M\nmax_allowed_packet=512M\ntable_open_cache=256\nsort_buffer_size=1M\nread_buffer_size=1M\nread_rnd_buffer_size=4M\nmyisam_sort_buffer_size=64M\nthread_cache_size=8\n\nsecure-file-priv=""\nexplicit_defaults_for_timestamp=1\ndatadir= "C:/laragon/data/mysql"\n\n\n[mysqldump]\nquick\nmax_allowed_packet=512M\n\n      ')])])}],l={},i=l,c=e("2877"),p=Object(c["a"])(i,s,o,!1,null,"b5c8781c",null),b=p.exports,u=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},v=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("pre",[t._v("         mysql 安装了最新版本8.x版本后的报错： the server requested authentication method unknown to the client\n2018年07月22日 13:11:38 youcijibi 阅读数 10613\n一，在MySQL 8.0.11中，caching_sha2_password是默认的身份验证插件，而不是以往的mysql_native_password。有关此更改对服务器操作的影响以及服务器与客户端和连接器的兼容性的信息，请参阅caching_sha2_password作为首选的身份验证插件。(翻译自https://dev.mysql.com/doc/refman/8.0/en/caching-sha2-pluggable-authentication.html）\n今天在新服务上配置安装mysql8.0.11时，像往常一样设置mysql密码，设置成功后在shell下输入mysql -u root -p，再输入密码能正常进入，但在phpmyadmin或直接用http://php.net/manual/zh/mysqli.real-connect.php上的连接，均提示无法连接，具体报错信息为\nmysqli_real_connect(): The server requested authentication method unknown to the client [sha256_password]  \n \n搜了一圈，找到官方文档才发现从8.0.11版本起，不再像mysql5.7及以前版本那样，设置用户密码时默认的验证方式为caching_sha2_password，如果发现升级mysql8.0.11后原有的程序不能连接mysql，可迅速在mysql command line client客户端用下面的命令设置成mysql5.7及以前版本的密码验证方式，同时MYSQL8.0.11下修改密码的方式与原先也不大一样，原先的部分修改密码的命令在mysql8.0.11下不能使用。\n> use mysql  \n> ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '你的密码';  \n> FLUSH PRIVILEGES;            \n二，\n \nmysql 安装了最新版本8.0.11后创建用户并授权后，授权的用户连接数据库提示\nThe server requested authentication method unknown to the client\n查阅一些相关的资料后发现是由于新版本的mysql账号密码解锁机制不一致导致的\n解决办法：\n删除创建的用户和授权，\n找到mysql配置文件并加入\ndefault_authentication_plugin=mysql_native_password\n变为原来的验证方式，然后从新创建用户并授权即可\n或\nmysql -uroot -p\n \nuse mysql;\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '你的密码';\n三\nThe caching_sha2_password and sha256_password authentication plugins provide more secure \npassword encryption than the mysql_native_password plugin, and caching_sha2_password provides better performance than sha256_password. \nDue to these superior security and performance characteristics of caching_sha2_password, it is as of MySQL 8.0 the preferred authentication plugin,\n and is also the default authentication plugin rather than mysql_native_password.\n翻译：caching_sha2_password和sha256_password认证插件比mysql_native_password插件提供的密码加密更加安全，并且caching_sha2_password加密比sha256_password的加密性能更好。\n由于caching_sha2_password这样优秀的安全和性能特性，让他作为MySQL8.0的首选认证插件，这也是默认的认证插件插件而不是mysql_native_password。\n具体你可以访问这个caching_sha2_password Compatibility Issues and Solutions来了解，已经使用了新的加密方式，访问不了的解决方法，简单总结一下就是\n1、将加密方式改为旧的，在配置文件my.conf中添加如下：\n[mysqld]\ndefault_authentication_plugin=mysql_native_password\n2、使用支持新的加密方式的客户端（Client），比如等于或高于8.0.4版本的libmysqlclient\n3、使用支持新的加密方式的连接驱动（Connector）：\nMySQL Connector/C++ 1.1.11 or higher or 8.0.7 or higher.\n \nMySQL Connector/J 8.0.9 or higher.\n \nMySQL Connector/NET 8.0.10 or higher (through the classic MySQL protocol).\n \nMySQL Connector/Node.js 8.0.9 or higher.\n \nPHP: the X DevAPI PHP extension (mysql_xdevapi) supports caching_sha2_password.\n4、使用了新的加密方式，改为旧的加密方式，而root用户也要进行相应的更改才可以，因为root用户还是新的加方式，所以使用alter语句改为重置密码来覆盖新的加密方式的密码：\nALTER USER 'root'@'localhost'\n  IDENTIFIED WITH mysql_native_password\n  BY 'password';\npassword是你将要设置的root用户的密码。\n参考文章：Changes Affecting Upgrades to MySQL 8.0\n     ")])])}],g={},m=g,_=Object(c["a"])(m,u,v,!1,null,"3c7ec510",null),d=_.exports,h=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},f=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("h4",[t._v("mysql 简单命令")]),e("pre",[t._v("         CREATE TABLE `o2o`.`Untitled`  (\n  `area_id` int(2) NOT NULL AUTO_INCREMENT,\n  `area_name` varchar(255) NOT NULL,\n  `priority` int(2) NOT NULL DEFAULT 0,\n  `create_time` datetime(0) NULL DEFAULT NULL,\n  `last_edit_time` datetime(0) NULL DEFAULT NULL,\n  PRIMARY KEY (`area_id`),\n\tunique key `UK_AREA`(`area_name`)\n)engine=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 ;\n\n     ")]),e("pre",[t._v("         加入服务\n加入 环境变量\n管理员启动 CMD\nmysql -u root -p  输入密码\n命令行要带 ； \nddl\ndml\ndql\ndcl\n\n\ncreate database web01; 创建\ncreate database web01 default character set utf8;\nshow create database web01; 查看结构\nuse web01;  database changed;  使用表\nselect database(); 查看当前正在操作的库 \n\ncreat table user(\nuid int(32) primary key auto_increment,\nuname varchar(32),\nupassword varchar(32)\n);\nshow tables; 展示所有表\ndesc user; 显示user表的详细信息\ndrop table user; 删除表\n改变my.ini 文件重启 mysql 服务 ，防止乱码，设置字符集utf8\nset uname gbk;  在 cmd 中 改变单列数据编码，防止中文乱码，只在CMD显示上有效\nalter table user add uage int(32) not null; 添加一列\nalter table user modify uage varchar(100) null; 改变列属性\nalter table user uage uinfo varchar(100) null; 改变列名\nalter table user drop uinfo; 删除列\n\ninsert into user(uid,uname,upasswod) values(null,'name1','pass1');\ninsert into user values(null,'q','w'); 全字段插入\nupdate user set uname='po', upassword='p1' where uid=5; 更新表数值\ndelete from user where uid=2;\ntruncate table user; 摧毁表并重建一张一样字段的表 ，不可回滚，本质上是两张表\nstart trancation;开启事务\nrollback;  回滚 \n\nselect [distinct] * | 列名... from  表 [where 条件]。\n select *  from user as p; 表别名查询\nselect pname as pn from product ;列别名查询\nselect distinct pq from product; 去掉重复值查询\nselect pname,pr+12 from product; 带运算查询\nselect * from pr where pid>45; 条件查询\nselect * from  pro  where pname like '_新%'； 格式 占位符查询 第二个字是新\nselect * from  pro where pid in (4,8,9,52,44,63);  in  范围查询\nselect * from pro where pr is null ; 根据空值查询 \n and or  not 逻辑查询  where not (pr>100);\n 排序\nselect * from pro where pname like '_新%' order by price desc; 排序\n聚合 sum() avg() count(*) max() min()\nselect sum(price) from pro; 聚合\n分组\nselect cid ,count(*) from product group by cid;\nselect cid ,avg(price) from product group by having avg(price)>60\n根据cid分组，分组统计每组商品的平均价格，并且平均价格大于60；\n\n\n\n\n\n\n\n\n\n\n\n\n     ")])])}],y={},S=y,w=Object(c["a"])(S,h,f,!1,null,"b736cd14",null),k=w.exports,x=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{},[e("q-markdown",{attrs:{src:t.MainComponent}})],1)},C=[],j="# redis\n\n## Redis\n\n### 启动Redis服务\n\n- redis-server（默认配置）\n- redis-server --configKey1 configValue1 --configKey2 configValue2（根据配置项启动）\n- redis-server /opt/redis/redis.conf（配置文件启动）\n\n### 连接Redis服务器\n\n- redis-cli -h {host} -p {port} (交互方式)\n- redis-cli -h {host} -p {port} {command}\t(命令方式)\n\n### 停止Redis服务\n\n- redis-cli shutdown nosave|save（断开与客户端连接、持久化文件生成）\n- kill -9 redis（强制杀死Redis服务）\n\n### 全局命令\n\n- keys * ：查看所有键\n- dbsize:  键总数\n- exists key: \t检查键是否存在\n- del key [key ...]:\t删除键\n- expire key seconds:\t设置键过期时间\n- ttl key:\t查看键剩余过期时间 \n- type key: 获取键的数据结构类型\n\n\t- string\n\t- list\n\t- set\n\t- zset\n\t- hash\n\n- object encoding key:\t查询键的内部编码\n\n### 字符串\n\n- set key value [ex seconds] [px milliseconds] [nx|xx]:\t设置值\n- get key:\t获取值\n- mset key value [key value ...]:\t批量设置值\n- mget key [key...]:\t\t批量获取值\n- incr key:\t值自增\n\n\t- 值不是整数，报错\n\t- 键不存在，默认为0，自增后返回1\n\t- 值是整数，返回自增后的结果\n\n- decr: 值自减\n- incrby、decrby、incrbyfloat\n- append key value: 追加值\n- strlen key: 字符串长度\n- getset: 设置并返回原值\n- setrange key offeset value: 设置指定位置的字符\n- getrange key start end：获取部分字符串\n\n### 哈希\n\n- hset key field value：\t设置值\n- hget key field:\t获取值\n- hdel key field [field ...]:\t\t删除field\n- hlen key:\t计算field个数\n- hmget key field [field ...]:\t批量获取\n- hmset key field [field value ...]:\t批量设置\n- hexists key field:\t\t检查field是否存在\n- hkeys key:\t\t获取所有field\n- hvals key：\t\t获取所有value\n- hgetall key:\t\t获取所有field-value\n- hincrby key field、hincrbyfloat key field\n- hstrlen key field:\t\t计算value的字符串长度\n\n### 列表\n\n- 添加\n\n\t- rpush key value [value...]:\t从右边插入元素\n\t- lpush key value [value...]:\t从左边插入元素\n\t- linsert key before/after pivot value:\t在值为pivot的前面或后面插入元素\n\n- 查找\n\n\t- lrange key start end:\t获取指定范围内的元素列表\n\t- lindex key index:\t获取列表指定索引下标的元素\n\t- llen key:\t获取列表长度\n\n- 删除\n\n\t- lpop key:\t从列表左侧弹出元素\n\t- rpop key:\t从列表右侧弹出元素\n\t- lrem  key count value:\t删除值等于value的元素\n\n\t\t- count>0:\t从左到右，删除最多count个元素\n\t\t- count<0:\t从右往左，删除最多count绝对值个元素\n\t\t- count=0:\t删除所有元素\n\n\t- ltrim key start end:\t按照索引范围修剪列表\n\n- 修改\n\n\t- lset key index newValue:\t修改指定索引下标的元素\n\n- 阻塞\n\n\t- blpop/brpop key [key...] timeout\n\n\t\t- 列表为空\n\n\t\t\t- timeout=n:\tn秒后返回\n\t\t\t- timeout=0\n\n\t\t\t\t- 客户端一直阻塞\n\t\t\t\t- 如果列表有值插入则立即返回\n\n\t\t- 列表非空\n\n\t\t\t- 客户端立即返回\n\n\t\t- brpop两点注意\n\n\t\t\t- 多个键，brpop会从左往右遍历键，一旦有一个键能弹出元素，客户端立即返回\n\t\t\t- 多个客户端对一个键执行brpop，最先执行brpop命令的客户端可以获取到弹出的值\n\n### 集合\n\n- sadd key member [...member]:\t添加元素\n- srem key member [...member]:\t删除元素\n- sismember key member:\t判断是否为集合元素\n- scard key:\t计算集合大小\n- srandmember key [count]:\t随机返回count个元素\n- spop key [count]:\t随机弹出count个元素\n- smembers key: 返回集合所有元素\n- sinter key [key...]:\t返回多个集合交集\n- sunion key [key...]:\t返回多个集合并集\n- sdiff key [key...]:\t返回多个集合差集\n- sinterstore/sunionstore/sdiffstore destination key [...key]:\t将返回的集合存储在destination中\n\n### 有序集合\n\n- zadd key [NX|XX] [CH] [INCR] score member [...score member]:\t添加元素\n\n\t- NX: 添加\n\t- XX：更新\n\t- CH：返回这次操作后发生变化的个数\n\t- INCR：对score做增加\n\n- zrem key member [...member]:\t删除元素\n- zcard key:\t计算有序集合大小\n- zscore key member:\t返回某个元素的分数\n- zrank/zrevrank key member:\t返回某个元素的排名(升序、降序)\n- zincrby key increment member:\t增加成员分数\n- zrange/zrevrange key start end:\t返回指定排名（升序、降序）范围内的元素\n- zrangebyscore/zrevrangebyscore key mix max:\t返回指定分数（升序、降序）范围内的元素\n- zcount key min max:\t返回指定分数范围成员个数\n- zremrangebyrank key start end:\t删除指定排名内的升序元素\n- zremrangebyscore key min max:\t删除指定分数范围内的元素\n- zinterstore destination numkeys key [...key] [weights weight [...weight]] [aggrerate sum|min|max]:\t交集\n- zunionstore destination numkeys key [...key] [weights weight [...weight]] [aggrerate sum|min|max]:\t\t并集\n\n## 核心\n\n### Redis\n\n- 单线程模型\n\n\t- 请求\n\n\t\t- 步骤\n\n\t\t\t- 发送命令\n\t\t\t- 执行命令\n\t\t\t- 返回结果\n\n\t\t- 重点\n\n\t\t\t- 一条命令从客户端达到服务端不会立刻被执行， 所有命令都会进入一个队列中，然后逐个执行。\n\n- 单线程为什么可以这么快\n\n\t- 纯内存访问\n\t- 非阻塞I/O，Redis使用epoll作为I/O多路复用技术的实现，加上Redis自身的时间处理模型（Redis Event Loop）\n\t- 避免线程切换和静态条件的消耗\n\n## 数据结构\n\n### 字符串\n\n- 内部编码\n\n\t- int：\t8个字节的长整型\n\t- embstr：小于等于39个字节的字符串\n\t- raw：大于39个字节的字符串\n\n- 使用场景\n\n\t- 缓存：Redis作为缓存层，MySQL作为存储层。\n\n\t\t- 加速读写和降低后端压力的作用\n\n\t- 计数：使用Redis作为计数的基础工具。\n\n\t\t- 实现快速计数、查询缓存且数据可以异步落地到其他数据源\n\n\t- 共享Session：使用Redis将用户的Session集中管理。\n\n\t\t- 出于负载均衡的考虑，分布式服务会将用户的访问均衡到不同服务器，用户每刷新一次就有可能发现需要重新登录\n\n\t- 限速：限制用户单位时间内访问次数\n\n### 哈希\n\n- 内部编码\n\n\t- ziplist(压缩表)\n\t- hashtable（哈希表）\n\n- 使用场景\n\n\t- 缓存用户信息\n\n### 列表\n\n- 内部编码\n\n\t- ziplist\n\t- linkedlist\n\n- 使用场景\n\n\t- 消息队列\n\n\t\t- 生产者使用lpush从列表左侧插入元素，消费者使用brpop命令阻塞式的‘抢’列表尾部的元素\n\n\t- 文章列表\n\n\t\t- 存储用户文章列表，分页获取文章\n\n### 集合\n\n- 内部编码\n\n\t- intset:\n\t- hashtable:\n\n- 使用场景\n\n\t- 用户标签\n\n### 有序集合\n\n- 内部编码\n\n\t- ziplist\n\t- skiplist\n\n- 使用场景\n\n\t- 排行榜系统\n\n*XMind: ZEN - Trial Version*",P={data:function(){return{MainComponent:j}}},T=P,E=Object(c["a"])(T,x,C,!1,null,"54908566",null),O=E.exports,M=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},A=[],N={},I=N,D=Object(c["a"])(I,M,A,!1,null,"2967efe7",null),z=D.exports,$=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},R=[],J={},L=J,H=Object(c["a"])(L,$,R,!1,null,"011851b0",null),q=H.exports,F=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},W=[],B={},U=B,G=Object(c["a"])(U,F,W,!1,null,"5500832e",null),V=G.exports,X=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Q=[],Y={},K=Y,Z=Object(c["a"])(K,X,Q,!1,null,"a8e8b4ac",null),tt=Z.exports,nt={components:{m1:b,m2:d,m3:k,m4:O,m5:z,m6:q,m7:V,m8:tt},data:function(){return{tab:"m1",tabs:[{label:"基本",value:"m1"},{label:"常见错误",value:"m2"},{label:"常规语句",value:"m3"},{label:"基本",value:"m4"},{label:"基本",value:"m5"},{label:"基本",value:"m6"},{label:"基本",value:"m7"},{label:"基本",value:"m8"}]}}},et=nt,at=Object(c["a"])(et,a,r,!1,null,"69bbcfea",null);n["default"]=at.exports},"44af":function(t,n,e){"use strict";e.r(n);var a=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+t.value,label:n+1+"."+t.label}})})),1),e(""+t.tab,{tag:"component"})],1)},r=[],s=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},o=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("br"),e("a",{attrs:{href:"https://www.infoq.cn/article/event-tracking-in-zhihu"}},[t._v("数据埋点太难！知乎的做法有何可借鉴之处")]),e("br"),e("a",{attrs:{href:"https://github.com/Meituan-Dianping/Logan"}},[t._v("美团 Logan")])])}],l={},i=l,c=e("2877"),p=Object(c["a"])(i,s,o,!1,null,"199185c0",null),b=p.exports,u=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},v=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("a",{attrs:{href:"http://caibaojian.com/some-fe"}},[t._v("http://caibaojian.com/some-fe")]),e("br"),e("a",{attrs:{href:"https://www.jianshu.com/p/91cf0071c1f6"}},[t._v("https://www.jianshu.com/p/91cf0071c1f6")])])}],g={},m=g,_=Object(c["a"])(m,u,v,!1,null,"2152820d",null),d=_.exports,h=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},f=[],y={},S=y,w=Object(c["a"])(S,h,f,!1,null,"486cbcb2",null),k=w.exports,x=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},C=[],j={},P=j,T=Object(c["a"])(P,x,C,!1,null,"9c54ee30",null),E=T.exports,O=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},M=[],A={},N=A,I=Object(c["a"])(N,O,M,!1,null,"f03d1fae",null),D=I.exports,z=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},$=[],R={},J=R,L=Object(c["a"])(J,z,$,!1,null,"5ded576a",null),H=L.exports,q=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},F=[],W={},B=W,U=Object(c["a"])(B,q,F,!1,null,"33f93eab",null),G=U.exports,V=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},X=[],Q={},Y=Q,K=Object(c["a"])(Y,V,X,!1,null,"0a0525ec",null),Z=K.exports,tt={components:{m1:b,m2:d,m3:k,m4:E,m5:D,m6:H,m7:G,m8:Z},data:function(){return{tab:"m1",tabs:[{label:"未开发",value:"m1"},{label:"未开发",value:"m2"},{label:"未开发",value:"m3"},{label:"未开发",value:"m4"},{label:"未开发",value:"m5"},{label:"未开发",value:"m6"},{label:"未开发",value:"m7"},{label:"未开发",value:"m8"}]}}},nt=tt,et=Object(c["a"])(nt,a,r,!1,null,"0c3f52dc",null);n["default"]=et.exports},6303:function(t,n,e){},"73ca":function(t,n,e){"use strict";var a=e("6303"),r=e.n(a);r.a},"7b7b":function(t,n,e){"use strict";e.r(n);var a=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+t,label:n+1+"."+t}})})),1),e(""+t.tab,{tag:"component"})],1)},r=[],s=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+(n+1),label:n+1+"."+t.text}})})),1),e("m"+t.tab,{tag:"component"})],1)},o=[],l=e("9523"),i=e.n(l),c=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},p=[],b={},u=b,v=e("2877"),g=Object(v["a"])(u,c,p,!1,null,"18a549e7",null),m=g.exports,_=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},d=[],h={},f=h,y=Object(v["a"])(f,_,d,!1,null,"229d9db0",null),S=y.exports,w=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},k=[],x={},C=x,j=Object(v["a"])(C,w,k,!1,null,"7685cf2e",null),P=j.exports,T=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},E=[],O={},M=O,A=Object(v["a"])(M,T,E,!1,null,"ca6e00ac",null),N=A.exports,I=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},D=[],z={},$=z,R=Object(v["a"])($,I,D,!1,null,"70d4e6eb",null),J=R.exports,L=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},H=[],q={},F=q,W=Object(v["a"])(F,L,H,!1,null,"46e0ce2c",null),B=W.exports,U=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},G=[],V={},X=V,Q=Object(v["a"])(X,U,G,!1,null,"1cecb56d",null),Y=Q.exports,K=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Z=[],tt={},nt=tt,et=Object(v["a"])(nt,K,Z,!1,null,"1a0ec6a4",null),at=et.exports,rt={components:{m1:m,m2:S,m3:P,m4:N,m5:J,m6:B,m7:Y,m8:at},data:function(){return i()({tab:1,tabs:[1,2,3,4,5,6,7,8]},"tabs",[{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"}])}},st=rt,ot=Object(v["a"])(st,s,o,!1,null,"1ae4247f",null),lt=ot.exports,it=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+t.value,label:n+1+"."+t.label}})})),1),e(""+t.tab,{tag:"component"})],1)},ct=[],pt=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+t.value,label:n+1+"."+t.label}})})),1),e("div",{staticClass:"q-mx-lg"},[e(""+t.tab,{tag:"component"})],1)],1)},bt=[],ut=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},vt=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("pre",[t._v("          搜索：机器码，电流开关与存储关系，字节码，内存和机械存储（ram，rom），堆栈，内存缓冲区，汇编语言，低级语言，高级语言，解释执行，编译执行，web发展历史，\n流程控制语句，数据类型，数据结构，操作系统，虚拟机，浏览器内核区别，webAPP，原生应用，服务器，物理机，集群，cdn，dns，tcp，http，dtd，\n\n一二：\n（概念性，不深入。个人接受能力。）\n(现阶段，自认为)\n学习方法：类比，逻辑思维能力。概观 与 盲人摸象\n 技术：\nDTD\nXml\nnode type\n浏览器渲染机制\n（html tree +  css tree => render tree =>layout =>painting ->{reflow repaint}）\n \n表现：一切皆为块。（1px -> html 油画，层叠）\n结构：树，对象。\n \n数据结构\n树状结构\n \n消息驱动，事件驱动和数据驱动\n \n结构，管道\n面向结构编程\n面向过程编程\n面向对象编程\n面向接口编程\n \n适度封装，抽象提取\n（插件：预留 API ）\n \n类数组\n （char ,string）(dom)\n\nES6\nhttp://es6.ruanyifeng.com\n（set map … 正则 fill object.assign repeat ）\n(理解： proxy  iterator 异步 模块) （单线程 和异步 promise）\n延伸：（从字节码到高级语言）\n\n其他：\n数据可视化，JQUI, 淘宝移动端适配，VW布局 ，模板，\nnginx,sourcetree,filezila\n调试 :json  mock e2e ,es6 \n \n单页应用开发\n理解 ： 单文件状态管理  MVC MVVM  \n MVC MVVM : 虚拟DOM  节点 diff （angular 脏检查 遍历所有 diff） innerHtml\nwatcher\n组件 （object.defineproperty getter setter）\n 全局注册， 变量挂载， 命名空间 （NG） \n订阅  分发 \nVuecli+ vueRouter+ vuex  ：  loader,编译， 热刷新，热加载，内存\nElementui  mint ui  // vux\n讲解：企业级 代码结构\n\n\n最后搜索ansi，utf-8，万国码，mvc，mvvm，api，模板，包管理，懒加载，热刷新，und，pwa，spa，ssr，响应式原理\n\n      ")])])}],gt={},mt=gt,_t=Object(v["a"])(mt,ut,vt,!1,null,"47e80e84",null),dt=_t.exports,ht=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{},[e("q-markdown",{attrs:{src:t.MainComponent}})],1)},ft=[],yt="# 存储\n\n## 【Cookie】说说Cookie与Web Storage的区别\n\n### Cookie\n\n- （1）什么是Cookie？\n\n\t- （1）cookie是指某些网站为了辨别用户身份而存储在用户本地终端上的数据（通常经过加密）。\n\t- （2）cookie是存储于访问者的计算机中的变量。每当同一台计算机通过浏览器请求同一个页面时，就会发送这个 cookie 。\n\t- （3）通俗的说就是当一个用户通过HTTP协议访问一个服务器的时候，这个服务器会将一些key/Value键值对返回给客户端浏览器，并给这些数据加上一些限制条件，在条件符合时这个用户下次访问这个服务器的时候，数据又被完整的带回给服务器。\n\t- （4）cookie是浏览器提供的一种机制，可以由 Javascript 对其进行控制，而不是 javascript 本身的性质。\n\n- （2）HTTP 无状态\n\n\t- HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。\n\t- 而cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。\n\n- （3）Cookie 的不可跨域名性\n\n\t- cookie是存于用户硬盘的一个文件，这个文件通常对应于一个域名。cookie可以跨越同一个域名下的多个网页，但不能跨越多个域名使用。\n\n- （4）Cookie 的缺点\n\n\t- 1.Cookie体积过大会造成请求和响应速度变慢。\n\t- 2.默认浏览器会任何请求都把cookie带上去，哪怕是静态资源。\n\t- 3.Cookie可以在前后端修改，数据容易篡改或伪造。\n\t- 4.Cookie对于敏感数据的保护基本是无效的。\n\t- 5.有些用户是禁用掉cookie的\n\n### Session\n\n- 除了cookie，web应用程序中还经常使用session来记录客户端的登录状态。不同于cookie，session保存在服务器上。session相当于程序在服务器上建立一份客户档案，客户来访时只需要查询客户档案表就可以了。\n\n### WebStorage\n\n- 定义与引入原因\n\n\t- WebStorage是HTML5中本地存储的解决方案之一，在 html5 中的 WebStorage 概念引入并不是为取代 cookie 而制定的标准，cookie 作为HTTP协议的一部分用来处理客户端和服务器通信是不可或缺的， session正是依赖于实现的客户端状态保持。\n\t- WebStorage的意图在于解决本地本来不应该用 cookie 做，却不得不用cookie的本地存储。\n\n- WebStorage 的优势\n\n\t- （1）从容量上讲WebStorage一般浏览器提供5M的存储空间。\n\t- （2）安全性上WebStorage 并不作为 HTTP header 发送的浏览器，所以相对安全。\n\t- （3）从流量上讲，因为WebStorage不传送到服务器，所以不必要的流量可以节省。\n\n- Local Storage与Session Storage的区别\n\n\t- Session Storage\n\n\t\t- 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此 sessionStorage 不是一种长久化的本地存储，仅仅是会话级别的存储。\n\n\t- Local Storage\n\n\t\t- 除非主动删除数据，否则数据是永远不会过期的。\n\n### Cookie和Session的区别\n\n- session 保存在服务器，客户端不知道其中的信息；cookie 保存在客户端，服务器能够知道其中的信息。\n- session 中保存的是对象，cookie 中保存的是字符串。\n- session 不能区分路径，同一个用户在访问一个网站期间，所有的session在任何地方都可以访问到。而 cookie 中如果设置了路径参数，那么同一个网站不同路径下的 cookie 互相是不可以访问的。\n- cookie 不是很安全，本人可以分析存放在本地的 COOKIE 并进行 COOKIE欺骗\n- session 会在一定时间内保存在服务器上。当访问增多，会占用你服务器的性能。考虑到减轻服务器性能方面，应该使用 COOKIE。\n- 单个 cookie 保存的数据不能超过 4k ，很多浏览器都限制一个站点最多保存 20 个 cookie。\n- session 是通过 cookie来工作的。\n\n### Cookie与Web Storage的区别\n\n- 共同点：\n\n\t- 都是保存在浏览器端，且同源的。\n\n- 区别：\n\n\t- （1）是否在请求中携带\n\n\t\t- cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。\n\n\t- （2）cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。\n\t- （3）存储大小限制也不同\n\n\t\t- cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。\n\n\t- （4）数据有效期不同\n\n\t\t- sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；\n\t\t- localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；\n\t\t- Cookie：只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。\n\n\t- （5）作用域不同\n\n\t\t- sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；\n\t\t- localStorage 在所有同源窗口中都是共享的；\n\t\t- Cookie也是在所有同源窗口中都是共享的。\n\n\t- （6）Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。\n\t- （7）Web Storage 的 api 接口使用更方便。\n\n## 浏览器数据持久化存储\n\n### HTTP文件缓存\n\n### LocalStorage\n\n- html5的一种本地缓存方案，主要用于浏览器端保存体积较大的数据\n- 在不同浏览器中有长度限制且各不相同\n- 单个域名下localStorage的大小是有限制的，但是可以用iframe的方式使用多个域名来突破单个页面下localtorage存储数据的最大限制。\n- 使用浏览器多个标签页打开同个域名时，localStorage内容一般是共享的。\n- 设置localStorage存储记录：localStorage.setItem(key, value)\n- 获取localStorage存储记录：localStorage.getItem(key)\n- 删除该域名下单条localStorage存储记录：localStorage.removeItem(key)\n- 删除该域名下所有localStorage存储记录：localStorage.clear()\n\n### SessionStorage\n\n- sessionStorage在浏览器关闭时会自动清空，不能进行客户端的持久化数据存储。\n- sessionStorage的API和localStorage完全相同\n\n### indexDB\n\n- 一个可在客户端存储大量结构化数据并且能在这些数据上使用索引进行高性能检索的一套API\n\n### WebSQL\n\n- 浏览器端用于存储较大量数据的缓存机制，只有较新版本的Chrome浏览器支持该机制，并以一个独立浏览器端数据存储规范的形式出现。\n- WebSQL数据库API实际上不是HTML5规范的组成部分，目前只是一种特定的浏览器特性，而且WebSQL在HTML5之前就已经存在，是单独的规范。\n- WebSQL将数据以数据库二维表的形式存储在客户端，可以根据需要使用JavaScript去读取。\n- WebSQL与其他存储方式的区别：localStorage和Cookie以键值对的形式存在，WebSQL为了更便于检索，允许SQL语句的查询。\n- WebSQL可以让浏览器实现小型数据库存储功能，而且使用的数据库是集成在浏览器里面的。\n- openDatabase()方法可以打开已经存在的数据库，不存在则创建\nopenDatabase()中的五个参数分别为数据库名、版本号、描述、数据库大小、创建回调（即使创建回调为null也可以创建数据库）\n- transaction()方法允许根据情况控制执行事务提交或回滚\n- executeSql()用于执行真实的SQL查询语句\n\n### Cookie\n\n- 网站为了辨别用户身份或Session跟踪而存储在用户浏览器端的数据\n- Cookie信息一般会通过HTTP请求发送到服务器端\n- 一条Cookie记录主要由键、值、域、过期时间和大小组成，一般用于保存用户的网站认证信息\n- 浏览器端通过document.cookie来获取cookie\n\n### CacheStorage\n\n- cacheStorage是在ServiceWorker规范中定义的，可用于保存每个ServiceWorker声明的Cache对象，是未来可能用来代替Application Cache的离线方案。\n- caches.has()检查如果包含 Cache 对象，则返回一个 promise 对象\n- caches.open() 打开一个 Cache 对象，并返回一个 promise 对象\n- caches.delete()删除 Cache 对象，成功则返回一个 promise 对象，否则返回 false\n- caches.keys()含有 keys 中字符串的任意一个，则返回一个 promise 对象\n- caches.match()匹配 key 中含有该字符串的 cache 对象，返回一个 promise 对象\n\n### Application Cache\n\n- Application Cache是一种允许浏览器通过manifest配置文件在本地有选择性地存储JavaScript、CSS、图片等静态资源的文件级缓存机制。当页面不是首次打开时，通过一个特定的manifest文件配置描述来选择读取本地Application Cache里面的文件。\n- 离线浏览。通过manifest配置描述来读取本地文件，用户可在离线时浏览完整的页面内容。\n- 快速加载。由于缓存资源为本地资源，因此页面加载速度较快。\n- 服务器负载小。只有在文件资源更新时，浏览器才会从服务器端下载，这样就减小了服 务器资源请求的压力\n\n*XMind: ZEN - Trial Version*",St={data:function(){return{MainComponent:yt}}},wt=St,kt=Object(v["a"])(wt,ht,ft,!1,null,"7fb8b309",null),xt=kt.exports,Ct=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},jt=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("h4",{staticClass:"post"},[e("header",{staticClass:"post-header"},[e("h4",{staticClass:"post-title"},[t._v("\n          从输入 URL 到获取页面的过程 \n        ")])]),e("div",{staticClass:"post-body"},[e("h4",{attrs:{id:"正文之前"}},[t._v("正文之前")]),e("blockquote",[e("p",[t._v("\n            最近正好在学习计算机网络，先整理个最入门，但是包含很多知识点的问题\n            —— 从输入域名或 URL\n            到获取页面，究竟经历了什么。把这个问题弄懂，也就代表着我们可以初步地明白"),e("strong",[t._v("网上冲浪")]),t._v("是如何进行的的\n          ")]),e("p",[t._v("\n            这个过程，如果要概括，也就几句话的事，但是其中包含的知识点还是比较多的：\n          ")]),e("ol",[e("li",[t._v("域名、URL 和 URI")]),e("li",[t._v("域名 和 IP 地址")]),e("li",[t._v("DNS 查询")]),e("li",[t._v("TCP 连接建立")]),e("li",[t._v("HTTP 请求与响应")]),e("li",[t._v("TCP 连接关闭")]),e("li",[t._v("服务器渲染页面")])]),e("p",[t._v("\n            这篇文章讲述 1、2、3、5 四个部分，关于 TCP\n            的部分，由于篇幅较大，需要另起一篇文章\n          ")])]),e("h4",{attrs:{id:"正文"}},[t._v("正文")]),e("h4",{attrs:{id:"1-域名url-和-uri"}},[t._v("1. 域名、URL 和 URI")]),e("p",[t._v("\n          首先要搞清楚这两个概念，"),e("strong",[t._v("域名")]),t._v("，是一台计算机，或一组计算机在"),e("strong",[t._v("网络上")]),t._v("的名称。"),e("strong",[t._v("Domain Name")]),t._v("，顾名思义，Domain 代表着你的计算机，或者你的计算机组，"),e("strong",[t._v("Name")]),t._v("\n          就代表着名称\n        ")]),e("p",[t._v("\n          关于 URL(Uniform Resource Locator) 和 URI(Uniform Resource\n          Identifier)，这两者都是用于定位资源的，区别就是：URI\n          是统一资源标志符，单凭 URI\n          就能够精准定位某个资源（比如用身份证号就能够识别中国的每一个居民），而\n          URL，是统一资源定位符，就是有考虑范围的资源（比如身份证号的前六位，就是根据地区来分的）\n        ")]),e("p",[t._v("\n          举个例子：据说全中国有 29\n          万个张伟，那么，除了用身份证号来确定是哪一个张伟，还能怎么判断呢？这时候就需要划分地区了，比如福建省福州市的张伟，这时候可能还是有好多个张伟，那就加上比如\n          xxxx 年 xx 月 xx\n          日出生的张伟，如果这时候还能有重复，那就再加上一些其他条件（学历，政治面貌等等），就能够定位到具体的某一个张伟了，这些条件组合在一起，就是一条\n          URL\n        ")]),e("p",[t._v("\n          URL 是 URI 的一个子集，每条 URL 都能够定位到一个独一无二的资源，它符合\n          URI 的定义，但是 URL != URI，这一点需要记清楚\n        ")]),e("p",[t._v("\n          现在回到网页上，域名只是网站的入口（比如说主页），如果你要在这主页上点击一个链接，进行页面跳转，就需要靠\n          URL 来指定资源的位置，这样才能获取，如果 URL 无效，就会弹出\n          "),e("strong",[t._v("404 Not Found")]),t._v("，比如你进入\n          https://cn.bing.com/，这时候就是依据域名来找到主页，然后你搜索张伟，就会有一条挺长的\n          URL 来跳转到搜索结果页面\n        ")]),e("h4",{attrs:{id:"2-域名-和-ip-地址"}},[t._v("2. 域名 和 IP 地址")]),e("p",[t._v("\n          前面说到，域名是计算机或计算机组在网络上的名称，但是并不是每一台计算机都有绑定了域名，但是，每一台"),e("strong",[t._v("接入网络")]),t._v("的计算机都有一个\n          IP 地址 (Internet Protocol address)，用这个 IP\n          地址就能够定位到一台服务器，或一组服务器，如果服务器没有绑定域名，只要有它的\n          IP 地址，还是可以进行访问的\n        ")]),e("p",[t._v("\n          我们在上网时，如果要直接访问某个网站，都是输入域名就可以了，但是在定位服务器时，都是要靠\n          IP 地址来进行的，从域名到 IP 地址，这二者的转换就引出了一个新的概念 ——\n          DNS(Domain Name System)\n        ")]),e("p",[t._v("\n          当我们输入域名时，浏览器会根据这个域名在浏览去缓存的 IP\n          地址中去查找，如果找不到，就到 OS 中去查找缓存的 IP\n          地址，如果还是找不到，就会去 ISP（Internet service\n          provider），也就是运营商（电信，铁通之类的）的服务器里查找，如果还是找不到，就要去根域名服务器查找\n        ")]),e("p",[t._v("\n          关于运营商域名服务器以及根域名服务器的 IP\n          地址，在你电脑的网络设置里可以看到：\n        ")]),e("p",[e("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/3426615-e50598f8b81b8412.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}})]),e("p",[t._v("\n          DNS 服务器里有两个 IP 地址，一个是中国电信的\n          (ISP)，一个是位于美国的服务器（根域名服务器）\n        ")]),e("p",[e("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/3426615-1a759f618a4f90ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}})]),e("p",[e("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/3426615-bfa0361e4e4e43f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}})]),e("p",[t._v("\n          另外，关于 DNS\n          缓存，每一次的查询，都会缓存下来，先说浏览器缓存，这里以 Chrome\n          为例，输入 "),e("strong",[t._v("chrome://net-internals/#dns")]),t._v(" 就会得到\n          Chrome 的 DNS 缓存。然后是 OS 的缓存，在命令行中输入\n          "),e("strong",[t._v("ipconfig /displaydns")]),t._v(" 就会得到 OS 中的缓存：\n        ")]),e("p",[e("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/3426615-9f839dd421780b02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}})]),e("h4",{attrs:{id:"3-dns-查询"}},[t._v("3. DNS 查询")]),e("p",[t._v("\n          在说 DNS\n          查询之前，需要先说一下域名服务器的种类，有根服务器、顶级域名服务器、权威域名服务器和本地域名服务器\n        ")]),e("p",[t._v("\n          在 DNS 查询的时候，首先查询本地域名服务器，也就是 ISP 提供的 DNS\n          服务器，如果找不到，这时候就有两种查询方式：\n        ")]),e("ol",[e("li",[t._v("\n            递归查询 客户端发出请求，本地 DNS 服务器代替客户端去查询其它 DNS\n            服务器，然后由本地 DNS 返回最终结果给客户端\n          ")]),e("li",[t._v("\n            迭代查询 本地 DNS\n            服务器并不能返回完整的结果，它只能给你一部分信息（比如它只知道要去\n            yyy 服务器上才找得到 xxx），然后又带着这个信息去 yyy 服务器上查找\n          ")])]),e("p",[t._v("手绘一张草图，意思一下：")]),e("p",[e("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/3426615-ba4ea5930ea9512e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}})]),e("p",[t._v("\n          至于 DNS 解析，上面介绍的只是最基本的知识，关于\n          DNS，还会另起一篇文章来说明\n        ")]),e("h4",{attrs:{id:"4-tcp-连接建立"}},[t._v("4. TCP 连接建立")]),e("p",[t._v("\n          在找到目标服务器的 IP\n          地址之后，就要开始通信了，既然是通信，就要双方消息同步（如果双方说话都不在一个频道，这不能叫通信），这里就要引出另一个应用层协议\n          —— TCP(Transmission Control Protocol)，传输控制协议\n        ")]),e("p",[t._v("TCP 是基于连接的 —— 在通信开始之前建立连接，结束时断开连接")]),e("h4",{attrs:{id:"5-http-请求与响应"}},[t._v("5. HTTP 请求与响应")]),e("p",[t._v("\n          连接建立之后，就可以开始传输了，采用 Http 协议，这里简单分析一下 Http\n          请求和响应的报文：\n        ")]),e("p",[t._v("Http 请求报文，一共有 4 个部分（包含一个空行）：")]),e("p",[e("strong",[t._v("1. 请求行 (request-line)")])]),e("p",[t._v("请求行包含了请求的方法，资源的位置，以及协议的版本，举个例子：")]),e("p",[e("code",{staticClass:"highlighter-rouge"},[t._v("GET /index.html HTTP/1.1")])]),e("p",[t._v("\n          采用 GET 的方式，请求得到 index.html 这个页面，采用 HTTP/1.1\n          版本的协议\n        ")]),e("p",[e("strong",[t._v("2. 请求头部 (headers)")])]),e("p",[t._v("头部是有多个 Key-Value 组成的，常见的有：")]),e("div",{staticClass:"highlighter-rouge"},[e("div",{staticClass:"highlight"},[e("pre",{staticClass:"highlight"},[e("code",[t._v("Accept:xxx （接受的数据类型）\nAccept-Charset:xxx （接受的编码格式）\nAccept-Language:xxx （接受的语言）\nUser-Agent:xxx （浏览器类型）\nCookie:xxx=yyy （所使用的 Cookie）\nConnection:close/keep-alive （连接状态：关闭/保持连接）\n......\n")])])])]),e("p",[e("strong",[t._v("3. 空行 (blank line)")])]),e("p",[t._v("\n          这个空行是一定要有的，它是用来区分请求头部和请求数据的，它代表着不再有头部的\n          Key-Value 键值对，接下来是请求数据了\n        ")]),e("p",[e("strong",[t._v("4. 请求数据 (request-body)")])]),e("p",[t._v("\n          请求主体一般是用于 POST\n          方法提交数据，例如最常见的表单提交，就是在请求主体写入\n          "),e("code",{staticClass:"highlighter-rouge"},[t._v("Content-Type= multipart/form-data")]),t._v("`\n        ")]),e("p",[t._v("Http 响应报文，也是分为 4 个部分（包含一个空行）：")]),e("p",[e("strong",[t._v("1. 状态行 (status-line)")])]),e("p",[t._v("\n          状态行中包含着协议版本，状态码以及文本描述，状态码和文本描述就代表了服务器所返回的响应结果是怎样的，这里给出大致的描述：\n        ")]),e("div",{staticClass:"highlighter-rouge"},[e("div",{staticClass:"highlight"},[e("pre",{staticClass:"highlight"},[e("code",[t._v("2XX：成功\n3XX：重定向\n4XX：客户端错误\n5XX：服务器错误\n")])])])]),e("p",[t._v("最常见的就是：200 (OK) 和 404 (Not Found) 了")]),e("p",[e("strong",[t._v("2. 响应头部 (headers)")])]),e("p",[t._v("与请求头部类似，也是 Key-Value 键值对的组合")]),e("p",[e("strong",[t._v("3. 空行 (blank line)")])]),e("p",[t._v("用来分隔响应头部和响应正文")]),e("p",[e("strong",[t._v("4. 响应正文")])]),e("p",[t._v("\n          响应正文中，如果之前请求的是数据，就返回数据，如果请求的是网页，就返回\n          HTML 代码\n        ")]),e("h4",{attrs:{id:"6-tcp-连接关闭"}},[t._v("6. TCP 连接关闭")]),e("p",[t._v("在通信结束之后，需要将连接关闭，这时候就是 TCP 四次挥手的场景了")]),e("p",[t._v("\n          从输入 URL\n          到获取页面的过程，看上去就短短几个步骤，其中涵盖的知识点还是挺多的，接下来就是\n          TCP 的三握四挥以及状态转换图的文章了\n        ")]),e("hr")]),e("footer",{staticClass:"post-footer"},[e("div",{staticClass:"post-tags"}),e("div",{staticClass:"post-nav"},[e("div",{staticClass:"post-nav-next post-nav-item"},[e("i",{staticClass:"fa fa-chevron-left"}),e("a",{attrs:{href:"https://www.dazhuanlan.com/2020/01/03/5e0f18011ae36/",rel:"next"}},[t._v("本站粒子背景的嵌入心得(暂)｜XiongQi’s Blog")])]),e("div",{staticClass:"post-nav-prev post-nav-item"},[e("a",{attrs:{href:"https://www.dazhuanlan.com/2020/01/03/5e0f17fd24664/",rel:"prev"}},[t._v("Git强制删除提交到远程版本库的数据或版本记录")]),e("i",{staticClass:"fa fa-chevron-right"})])])]),e("div",{staticClass:"crp_related "},[e("h4",[t._v("相关文章")]),e("ul",[e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/11/22/5dd75eb724dc5/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("从输入 URL 到页面加载完成的过程中都发生了什么事情？")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/11/19/5dd3896ac6f2b/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("从输入 URL 到页面展示到底发生了什么")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/12/05/5de8a3d9ec83d/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("从输入 URL 到页面加载")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/12/06/5de9efdd9515e/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("TODO 从输入 URL 到页面加载完成的过程中都发生了什么事情？")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/12/30/5e09d77a65fe7/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("从输入 URL 到页面加载完成的过程中都发生了什么(转自知乎)")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2020/01/02/5e0db9a320de4/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("「转」从输入 URL 到页面加载的过程 ·\n                心有多大，舞台就有多大")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/10/07/5d9a9ef2138b5/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("TCP 的三握四挥 - 李汉祥的博客")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/12/27/5e05c078b330b/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("二叉树的几种遍历方式（附 LeetCode 水题） - 李汉祥的博客")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/12/30/5e09815a1218d/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("Java基础知识梳理（六）—— 初识 HashMap - 李汉祥的博客")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2020/01/03/5e0ec33826c6c/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("Java基础知识梳理（五）从源码了解字符串 - 李汉祥的博客")])])])]),e("div",{staticClass:"crp_clear"})])])])}],Pt={},Tt=Pt,Et=Object(v["a"])(Tt,Ct,jt,!1,null,"abd93eaa",null),Ot=Et.exports,Mt=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},At=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("h4",{staticClass:"post"},[e("header",{staticClass:"post-header"},[e("h4",{staticClass:"post-title"},[t._v("\n\t\t\t「 CSS 」display属性居然有这么多\t\t")]),e("div",{staticClass:"post-meta"},[e("span",{staticClass:"post-time"},[e("span",{staticClass:"post-meta-item-icon"},[e("i",{staticClass:"fa fa-calendar-o"})]),e("span",{staticClass:"post-meta-item-text"},[t._v("发表于")]),e("time",{attrs:{datetime:"2020-01-03"}},[t._v("2020-01-03")])]),e("span",{staticClass:"post-category"},[t._v("\n\t\t\t\t | \n\t\t\t\t"),e("span",{staticClass:"post-meta-item-icon"},[e("i",{staticClass:"fa fa-folder-o"})]),e("span",{staticClass:"post-meta-item-text"},[t._v("分类于")]),e("span",[e("a",{attrs:{href:"https://www.dazhuanlan.com/frontend/",rel:"category tag"}},[t._v("前端")])])]),e("span",{staticClass:"post-comments-count"},[t._v("\n\t\t\t\t | \n\t\t\t\t"),e("span",{staticClass:"post-comments-count"},[t._v("没有评论")])])])]),e("div",{staticClass:"post-body"},[e("p",[t._v("思考一个简单的问题，如何用原生js实现元素的显示隐藏，也就是jQuery中show和hide方法。")]),e("p",[t._v("你肯定觉得特别简单，隐藏的话，直接"),e("code",[t._v("el.style.display='none';")])]),e("p",[t._v("那显示呢？"),e("code",[t._v("el.style.display='block'")]),t._v("？"),e("br")]),e("p",[t._v("display属性是css中最基本的属性。除了常用的"),e("code",[t._v("inline")]),t._v("，"),e("code",[t._v("inline-block")]),t._v("，"),e("code",[t._v("block")]),t._v("，"),e("code",[t._v("none")]),t._v("，其实display还有很多属性值。")]),e("p",[t._v("这个属性决定了元素的显示类型，也指定了元素怎么生成盒模型。")]),e("p",[t._v("分为外部显示类型和内部显示类型")]),e("figure",{staticClass:"highlight css"},[e("table",[e("tbody",[e("tr",[e("td",{staticClass:"gutter"},[e("pre",[e("span",{staticClass:"line"},[t._v("1")]),e("br"),e("span",{staticClass:"line"},[t._v("2")]),e("br"),e("span",{staticClass:"line"},[t._v("3")]),e("br"),e("span",{staticClass:"line"},[t._v("4")]),e("br"),e("span",{staticClass:"line"},[t._v("5")]),e("br"),e("span",{staticClass:"line"},[t._v("6")]),e("br"),e("span",{staticClass:"line"},[t._v("7")]),e("br"),e("span",{staticClass:"line"},[t._v("8")]),e("br"),e("span",{staticClass:"line"},[t._v("9")]),e("br"),e("span",{staticClass:"line"},[t._v("10")]),e("br"),e("span",{staticClass:"line"},[t._v("11")]),e("br"),e("span",{staticClass:"line"},[t._v("12")]),e("br"),e("span",{staticClass:"line"},[t._v("13")]),e("br"),e("span",{staticClass:"line"},[t._v("14")]),e("br"),e("span",{staticClass:"line"},[t._v("15")]),e("br"),e("span",{staticClass:"line"},[t._v("16")]),e("br"),e("span",{staticClass:"line"},[t._v("17")]),e("br"),e("span",{staticClass:"line"},[t._v("18")]),e("br"),e("span",{staticClass:"line"},[t._v("19")]),e("br"),e("span",{staticClass:"line"},[t._v("20")]),e("br"),e("span",{staticClass:"line"},[t._v("21")]),e("br"),e("span",{staticClass:"line"},[t._v("22")]),e("br"),e("span",{staticClass:"line"},[t._v("23")]),e("br"),e("span",{staticClass:"line"},[t._v("24")]),e("br"),e("span",{staticClass:"line"},[t._v("25")]),e("br"),e("span",{staticClass:"line"},[t._v("26")]),e("br"),e("span",{staticClass:"line"},[t._v("27")]),e("br"),e("span",{staticClass:"line"},[t._v("28")]),e("br"),e("span",{staticClass:"line"},[t._v("29")]),e("br"),e("span",{staticClass:"line"},[t._v("30")]),e("br"),e("span",{staticClass:"line"},[t._v("31")]),e("br"),e("span",{staticClass:"line"},[t._v("32")]),e("br"),e("span",{staticClass:"line"},[t._v("33")]),e("br"),e("span",{staticClass:"line"},[t._v("34")]),e("br"),e("span",{staticClass:"line"},[t._v("35")]),e("br"),e("span",{staticClass:"line"},[t._v("36")]),e("br"),e("span",{staticClass:"line"},[t._v("37")]),e("br"),e("span",{staticClass:"line"},[t._v("38")]),e("br"),e("span",{staticClass:"line"},[t._v("39")]),e("br"),e("span",{staticClass:"line"},[t._v("40")]),e("br"),e("span",{staticClass:"line"},[t._v("41")]),e("br"),e("span",{staticClass:"line"},[t._v("42")]),e("br"),e("span",{staticClass:"line"},[t._v("43")]),e("br"),e("span",{staticClass:"line"},[t._v("44")]),e("br"),e("span",{staticClass:"line"},[t._v("45")]),e("br"),e("span",{staticClass:"line"},[t._v("46")]),e("br"),e("span",{staticClass:"line"},[t._v("47")]),e("br"),e("span",{staticClass:"line"},[t._v("48")]),e("br"),e("span",{staticClass:"line"},[t._v("49")]),e("br"),e("span",{staticClass:"line"},[t._v("50")]),e("br"),e("span",{staticClass:"line"},[t._v("51")]),e("br"),e("span",{staticClass:"line"},[t._v("52")]),e("br"),e("span",{staticClass:"line"},[t._v("53")]),e("br"),e("span",{staticClass:"line"},[t._v("54")]),e("br"),e("span",{staticClass:"line"},[t._v("55")]),e("br"),e("span",{staticClass:"line"},[t._v("56")]),e("br"),e("span",{staticClass:"line"},[t._v("57")]),e("br"),e("span",{staticClass:"line"},[t._v("58")]),e("br"),e("span",{staticClass:"line"},[t._v("59")]),e("br"),e("span",{staticClass:"line"},[t._v("60")]),e("br"),e("span",{staticClass:"line"},[t._v("61")]),e("br"),e("span",{staticClass:"line"},[t._v("62")]),e("br"),e("span",{staticClass:"line"},[t._v("63")]),e("br")])]),e("td",{staticClass:"code"},[e("pre",[e("span",{staticClass:"line"}),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"comment"},[t._v("/* 在流式布局中的角色:行内元素还是块级元素 */")])]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("block")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("inline")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("run-in")]),t._v("; "),e("span",{staticClass:"comment"},[t._v("/* 大多数浏览器都不支持 */")])]),e("br"),e("span",{staticClass:"line"}),e("br"),e("span",{staticClass:"line"}),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"comment"},[t._v("/* <display-inside> values */")])]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"comment"},[t._v("/* 元素内部内容的格式化上下文的类型 */")])]),e("br"),e("span",{staticClass:"line"},[t._v("display: flow; // ??")]),e("br"),e("span",{staticClass:"line"},[t._v("display: ruby;// ??")]),e("br"),e("span",{staticClass:"line"}),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("flow-root")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("table")]),t._v(";"),e("span",{staticClass:"comment"},[t._v("/* 内部是table布局 */")])]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("flex")]),t._v(";"),e("span",{staticClass:"comment"},[t._v("/* 内部是flex布局 */")])]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("grid")]),t._v(";"),e("span",{staticClass:"comment"},[t._v("/* 内部是grid布局 */")])]),e("br"),e("span",{staticClass:"line"}),e("br"),e("span",{staticClass:"line"}),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"comment"},[t._v("/* <display-outside> plus <display-inside> values */")])]),e("br"),e("span",{staticClass:"line"},[t._v("display: block flow; // 可以写两个吗？")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("inline")]),t._v(" "),e("span",{staticClass:"selector-tag"},[t._v("table")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("flex")]),t._v(" "),e("span",{staticClass:"selector-tag"},[t._v("run-in")]),t._v(";")]),e("br"),e("span",{staticClass:"line"}),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"comment"},[t._v("/* <display-listitem> values */")])]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"comment"},[t._v("/* 将这个元素的外部显示类型变为 block，并将内部显示类型变为多个 list-item inline 盒。*/")])]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("list-item")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("list-item")]),t._v(" "),e("span",{staticClass:"selector-tag"},[t._v("block")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("list-item")]),t._v(" "),e("span",{staticClass:"selector-tag"},[t._v("inline")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("list-item")]),t._v(" "),e("span",{staticClass:"selector-tag"},[t._v("flow")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("list-item")]),t._v(" "),e("span",{staticClass:"selector-tag"},[t._v("flow-root")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("list-item")]),t._v(" "),e("span",{staticClass:"selector-tag"},[t._v("block")]),t._v(" "),e("span",{staticClass:"selector-tag"},[t._v("flow")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("list-item")]),t._v(" "),e("span",{staticClass:"selector-tag"},[t._v("block")]),t._v(" "),e("span",{staticClass:"selector-tag"},[t._v("flow-root")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("flow")]),t._v(" "),e("span",{staticClass:"selector-tag"},[t._v("list-item")]),t._v(" "),e("span",{staticClass:"selector-tag"},[t._v("block")]),t._v(";")]),e("br"),e("span",{staticClass:"line"}),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"comment"},[t._v("/* <display-internal> values */")])]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("table-row-group")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("table-header-group")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("table-footer-group")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("table-row")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("table-cell")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("table-column-group")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("table-column")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("table-caption")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("ruby-base")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("ruby-text")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("ruby-base-container")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("ruby-text-container")]),t._v(";")]),e("br"),e("span",{staticClass:"line"}),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"comment"},[t._v("/* <display-box> values */")])]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"comment"},[t._v("/* 是否显示 */")])]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("contents")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("none")]),t._v(";")]),e("br"),e("span",{staticClass:"line"}),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"comment"},[t._v("/* <display-legacy> values */")])]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("inline-block")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("inline-table")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("inline-flex")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("inline-grid")]),t._v(";")]),e("br"),e("span",{staticClass:"line"}),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"comment"},[t._v("/* Global values */")])]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("inherit")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("initial")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("unset")]),t._v(";")]),e("br")])])])])])])]),e("footer",{staticClass:"post-footer"},[e("div",{staticClass:"post-tags"}),e("div",{staticClass:"post-nav"},[e("div",{staticClass:"post-nav-next post-nav-item"},[e("i",{staticClass:"fa fa-chevron-left"}),e("a",{attrs:{href:"https://www.dazhuanlan.com/2020/01/03/5e0edc461967d/",rel:"next"}},[t._v("celery学习笔记（二）——celery快速入门")])]),e("div",{staticClass:"post-nav-prev post-nav-item"},[e("a",{attrs:{href:"https://www.dazhuanlan.com/2020/01/03/5e0edc409da9d/",rel:"prev"}},[t._v("singleton")]),e("i",{staticClass:"fa fa-chevron-right"})])])]),e("div",{staticClass:"crp_related "},[e("h4",[t._v("相关文章")]),e("ul",[e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/11/15/5dce6d7da3283/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("css 命名：BEM, scoped css, css modules 与 css-in-js")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/13/385e4f756cb7/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("[CSS] CSS 之父使用 CSS 制作书籍")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/12/16/5df6dfdae6438/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("CSS reset 和 CSS normalize.css")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/04/4fe740d5172b/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("CSS Button Designer (CSS 按钮懒人设计器)")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/04/6ba49d13248b/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("［CSS］CSS Friendly Control Adapters&ndash;Menu…")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/09/fbf938e67dce/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("[CSS] CSS Web Note")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/10/2c8b2b94de53/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("[CSS] CSS 笔记")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/13/ace05a626434/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("[CSS] CSS 之父写的书")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/19/79c4f77a60f8/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("[ASP.NET][CSS](note)Web 服务器控件和 CSS 模式")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/07/03/cssdivnote%e5%9c%a8-ie8-firefox-chrome-css-%e7%bd%ae%e4%b8%ad%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%95/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("[CSS][div](note)在 IE8 FireFox Chrome CSS 置中解决方法")])])])]),e("div",{staticClass:"crp_clear"})])])])}],Nt={},It=Nt,Dt=Object(v["a"])(It,Mt,At,!1,null,"0a2f5e78",null),zt=Dt.exports,$t=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},Rt=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("section",{staticClass:"ouvJEz"},[e("h4",{staticClass:"_1RuRku"},[t._v("浏览器渲染原理与过程")]),e("article",{staticClass:"_2rhmJa"},[e("h4",[t._v("浏览器如何渲染网页")]),e("p",[t._v("\n        要了解浏览器渲染页面的过程，首先得知道一个名词——关键渲染路径。关键渲染路径是指浏览器从最初接收请求来的HTML、CSS、javascript等资源，然后解析、构建树、渲染布局、绘制，最后呈现给客户能看到的界面这整个过程。"),e("br"),t._v("\n        用户看到页面实际上可以分为两个阶段：页面内容加载完成和页面资源加载完成，分别对应于"),e("code",[t._v("DOMContentLoaded")]),t._v("和"),e("code",[t._v("Load")]),t._v("。\n      ")]),e("ul",[e("li",[e("code",[t._v("DOMContentLoaded")]),t._v("事件触发时，仅当DOM加载完成，不包括样式表，图片等\n        ")]),e("li",[e("code",[t._v("load")]),t._v("事件触发时，页面上所有的DOM，样式表，脚本，图片都已加载完成\n        ")])]),e("p",[t._v("浏览器渲染的过程主要包括以下五步：")]),e("ol",[e("li",[t._v("浏览器将获取的HTML文档解析成DOM树。")]),e("li",[t._v("处理CSS标记，构成层叠样式表模型CSSOM(CSS Object Model)。")]),e("li",[t._v("\n          将DOM和CSSOM合并为渲染树("),e("code",[t._v("rendering tree")]),t._v(")将会被创建，代表一系列将被渲染的对象。\n        ")]),e("li",[t._v("\n          渲染树的每个元素包含的内容都是计算过的，它被称之为布局"),e("code",[t._v("layout")]),t._v("。浏览器使用一种流式处理的方法，只需要一次绘制操作就可以布局所有的元素。\n        ")]),e("li",[t._v("\n          将渲染树的各个节点绘制到屏幕上，这一步被称为绘制"),e("code",[t._v("painting")]),t._v("。\n        ")])]),e("p",[t._v("\n        需要注意的是，以上五个步骤并不一定一次性顺序完成，比如DOM或CSSOM被修改时，亦或是哪个过程会重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。而在实际情况中，JavaScript和CSS的某些操作往往会多次修改DOM或者CSSOM。\n      ")]),e("div",{staticClass:"image-view",attrs:{"data-width":"624","data-height":"289"}},[e("img",{attrs:{src:"statics/web/web/basic/m5/1.webp",alt:""}})]),e("h4",[t._v("浏览器渲染网页的具体流程")]),e("h4",[t._v("构建DOM树")]),e("p",[t._v("\n        当浏览器接收到服务器响应来的HTML文档后，会遍历文档节点，生成DOM树。"),e("br"),t._v("\n        需要注意以下几点：\n      ")]),e("ul",[e("li",[t._v("DOM树在构建的过程中可能会被CSS和JS的加载而执行阻塞")]),e("li",[e("code",[t._v("display:none")]),t._v("的元素也会在DOM树中")]),e("li",[t._v("注释也会在DOM树中")]),e("li",[e("code",[t._v("script")]),t._v("标签会在DOM树中")])]),e("p",[t._v("\n        无论是DOM还是CSSOM，都是要经过"),e("code",[t._v("Bytes→characters→tokens→nodes→objectmodel")]),t._v("这个过程。\n      ")]),e("div",{staticClass:"image-view",attrs:{"data-width":"800","data-height":"443"}},[e("img",{attrs:{src:"statics/web/web/basic/m5/2.webp",alt:""}})]),e("p",[t._v("\n        当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。\n      ")]),e("h4",[t._v("构建CSSOM规则树")]),e("p",[t._v("\n        浏览器解析CSS文件并生成CSSOM，每个CSS文件都被分析成一个StyleSheet对象，每个对象都包含CSS规则。CSS规则对象包含对应于CSS语法的选择器和声明对象以及其他对象。"),e("br"),t._v("\n        在这个过程需要注意的是：\n      ")]),e("ul",[e("li",[t._v("CSS解析可以与DOM解析同时进行。")]),e("li",[t._v("CSS解析与"),e("code",[t._v("script")]),t._v("的执行互斥 。")]),e("li",[t._v("\n          在Webkit内核中进行了"),e("code",[t._v("script")]),t._v("执行优化，只有在JS访问CSS时才会发生互斥。\n        ")])]),e("h4",[t._v("构建渲染树（Render Tree）")]),e("p",[t._v("\n        通过DOM树和CSS规则树，浏览器就可以通过它两构建渲染树了。浏览器会先从DOM树的根节点开始遍历每个可见节点，然后对每个可见节点找到适配的CSS样式规则并应用。"),e("br"),t._v("\n        有以下几点需要注意：\n      ")]),e("ul",[e("li",[t._v("Render Tree和DOM Tree不完全对应")]),e("li",[e("code",[t._v("display: none")]),t._v("的元素不在Render Tree中")]),e("li",[e("code",[t._v("visibility: hidden")]),t._v("的元素在Render Tree中")])]),e("div",{staticClass:"image-view",attrs:{"data-width":"711","data-height":"415"}},[e("img",{attrs:{src:"statics/web/web/basic/m5/3.webp",alt:""}})]),e("p",[t._v("\n        渲染树生成后，还是没有办法渲染到屏幕上，渲染到屏幕需要得到各个节点的位置信息，这就需要布局（Layout）的处理了。\n      ")]),e("h4",[t._v("渲染树布局(layout of the render tree)")]),e("p",[t._v("\n        布局阶段会从渲染树的根节点开始遍历，由于渲染树的每个节点都是一个Render\n        Object对象，包含宽高，位置，背景色等样式信息。所以浏览器就可以通过这些样式信息来确定每个节点对象在页面上的确切大小和位置，布局阶段的输出就是我们常说的盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。需要注意的是：\n      ")]),e("ul",[e("li",[e("code",[t._v("float")]),t._v("元素，"),e("code",[t._v("absoulte")]),t._v("元素，"),e("code",[t._v("fixed")]),t._v("元素会发生位置偏移。\n        ")]),e("li",[t._v("我们常说的脱离文档流，其实就是脱离Render Tree。")])]),e("h4",[t._v("渲染树绘制（Painting the render tree）")]),e("p",[t._v("\n        在绘制阶段，浏览器会遍历渲染树，调用渲染器的"),e("code",[t._v("paint()")]),t._v("方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的UI后端组件完成的。\n      ")]),e("h4",[t._v("浏览器渲染网页的那些事儿")]),e("h4",[t._v("浏览器主要组件结构")]),e("div",{staticClass:"image-view",attrs:{"data-width":"400","data-height":"271"}},[e("img",{attrs:{src:"statics/web/web/basic/m5/4.webp",alt:""}})]),e("p",[t._v("\n        渲染引擎主要有两个：webkit和Gecko"),e("br"),t._v("\n        Firefox使用Geoko，Mozilla自主研发的渲染引擎。Safari和Chrome都使用webkit。Webkit是一款开源渲染引擎，它本来是为linux平台研发的，后来由Apple移植到Mac及Windows上。"),e("br"),t._v("\n        虽然主流浏览器渲染过程叫法有区别，但是主要流程还是相同的。\n      ")]),e("h4",[t._v("渲染阻塞")]),e("p",[t._v("\n        JS可以操作DOM来修改DOM结构，可以操作CSSOM来修改节点样式，这就导致了浏览器在遇到"),e("code",[t._v("<script>")]),t._v("标签时，DOM构建将暂停，直至脚本完成执行，然后继续构建DOM。如果脚本是外部的，会等待脚本下载完毕，再继续解析文档。现在可以在"),e("code",[t._v("script")]),t._v("标签上增加属性"),e("code",[t._v("defer")]),t._v("或者"),e("code",[t._v("async")]),t._v("。脚本解析会将脚本中改变DOM和CSS的地方分别解析出来，追加到DOM树和CSSOM规则树上。\n      ")]),e("p",[t._v("\n        每次去执行JavaScript脚本都会严重地阻塞DOM树的构建，如果JavaScript脚本还操作了CSSOM，而正好这个CSSOM还没有下载和构建，浏览器甚至会延迟脚本执行和构建DOM，直至完成其CSSOM的下载和构建。所以，"),e("code",[t._v("script")]),t._v("标签的位置很重要。\n      ")]),e("p",[t._v("\n        JS阻塞了构建DOM树，也阻塞了其后的构建CSSOM规则树，整个解析进程必须等待JS的执行完成才能够继续，这就是所谓的JS阻塞页面。\n      ")]),e("p",[t._v("\n        由于CSSOM负责存储渲染信息，浏览器就必须保证在合成渲染树之前，CSSOM是完备的，这种完备是指所有的CSS（内联、内部和外部）都已经下载完，并解析完，只有CSSOM和DOM的解析完全结束，浏览器才会进入下一步的渲染，这就是CSS阻塞渲染。\n      ")]),e("p",[t._v("\n        CSS阻塞渲染意味着，在CSSOM完备前，页面将一直处理白屏状态，这就是为什么样式放在"),e("code",[t._v("head")]),t._v("中，仅仅是为了更快的解析CSS，保证更快的首次渲染。\n      ")]),e("p",[t._v("\n        需要注意的是，即便你没有给页面任何的样式声明，CSSOM依然会生成，默认生成的CSSOM自带浏览器默认样式。\n      ")]),e("p",[t._v("\n        当解析HTML的时候，会把新来的元素插入DOM树里面，同时去查找CSS，然后把对应的样式规则应用到元素上，查找样式表是按照从右到左的顺序去匹配的。\n      ")]),e("p",[t._v("\n        例如："),e("code",[t._v("div p {font-size: 16px}")]),t._v("，会先寻找所有"),e("code",[t._v("p")]),t._v("标签并判断它的父标签是否为"),e("code",[t._v("div")]),t._v("之后才会决定要不要采用这个样式进行渲染）。"),e("br"),t._v("\n        所以，我们平时写CSS时，尽量用"),e("code",[t._v("id")]),t._v("和"),e("code",[t._v("class")]),t._v("，千万不要过渡层叠。\n      ")]),e("h4",[t._v("回流和重绘（reflow和repaint）")]),e("p",[t._v("\n        我们都知道HTML默认是流式布局的，但CSS和JS会打破这种布局，改变DOM的外观样式以及大小和位置。因此我们就需要知道两个概念："),e("code",[t._v("replaint")]),t._v("和"),e("code",[t._v("reflow")]),t._v("。\n      ")]),e("h5",[t._v("reflow（回流）")]),e("p",[t._v("\n        当浏览器发现布局发生了变化，这个时候就需要倒回去重新渲染，大家称这个回退的过程叫"),e("code",[t._v("reflow")]),t._v("。"),e("code",[t._v("reflow")]),t._v("会从"),e("code",[t._v("html")]),t._v("这个"),e("code",[t._v("root frame")]),t._v("开始递归往下，依次计算所有的结点几何尺寸和位置，以确认是渲染树的一部分发生变化还是整个渲染树。"),e("code",[t._v("reflow")]),t._v("几乎是无法避免的，因为只要用户进行交互操作，就势必会发生页面的一部分的重新渲染，且通常我们也无法预估浏览器到底会"),e("code",[t._v("reflow")]),t._v("哪一部分的代码，因为他们会相互影响。\n      ")]),e("h5",[t._v("repaint（重绘）")]),e("p",[e("code",[t._v("repaint")]),t._v("则是当我们改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸和位置没有发生改变。\n      ")]),e("p",[t._v("\n        需要注意的是，"),e("code",[t._v("display:none")]),t._v("会触发"),e("code",[t._v("reflow")]),t._v("，而"),e("code",[t._v("visibility: hidden")]),t._v("属性则并不算是不可见属性，它的语义是隐藏元素，但元素仍然占据着布局空间，它会被渲染成一个空框。所以"),e("code",[t._v("visibility:hidden")]),t._v("只会触发"),e("code",[t._v("repaint")]),t._v("，因为没有发生位置变化。\n      ")]),e("p",[t._v("\n        另外有些情况下，比如修改了元素的样式，浏览器并不会立刻"),e("code",[t._v("reflow")]),t._v("或"),e("code",[t._v("repaint")]),t._v("一次，而是会把这样的操作积攒一批，然后做一次"),e("code",[t._v("reflow")]),t._v("，这又叫异步"),e("code",[t._v("reflow")]),t._v("或增量异步"),e("code",[t._v("reflow")]),t._v("。但是在有些情况下，比如"),e("code",[t._v("resize")]),t._v("窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行"),e("code",[t._v("reflow")]),t._v("。\n      ")]),e("h5",[t._v("引起reflow")]),e("p",[t._v("\n        现代浏览器会对回流做优化，它会等到足够数量的变化发生，再做一次批处理回流。\n      ")]),e("ul",[e("li",[t._v("页面第一次渲染（初始化）")]),e("li",[t._v("DOM树变化（如：增删节点）")]),e("li",[t._v("Render树变化（如："),e("code",[t._v("padding")]),t._v("改变）")]),e("li",[t._v("浏览器窗口"),e("code",[t._v("resize")])]),e("li",[t._v("获取元素的某些属性")])]),e("p",[t._v("\n        浏览器为了获得正确的值也会提前触发回流，这样就使得浏览器的优化失效了，这些属性包括"),e("code",[t._v("offsetLeft、offsetTop、offsetWidth、offsetHeight、\n          scrollTop/Left/Width/Height、clientTop/Left/Width/Height")]),t._v("、调用了"),e("code",[t._v("getComputedStyle()")]),t._v("。\n      ")]),e("h5",[t._v("引起repaint")]),e("p",[e("code",[t._v("reflow")]),t._v("回流必定引起"),e("code",[t._v("repaint")]),t._v("重绘，重绘可以单独触发。"),e("br"),t._v("\n        背景色、颜色、字体改变（注意：字体大小发生变化时，会触发回流）\n      ")]),e("h5",[t._v("减少reflow、repaint触发次数")]),e("ul",[e("li",[t._v("\n          用"),e("code",[t._v("transform")]),t._v("做形变和位移可以减少"),e("code",[t._v("reflow")])]),e("li",[t._v("避免逐个修改节点样式，尽量一次性修改")]),e("li",[t._v("\n          使用"),e("code",[t._v("DocumentFragment")]),t._v("将需要多次修改的DOM元素缓存，最后一次性"),e("code",[t._v("append")]),t._v("到真实DOM中渲染\n        ")]),e("li",[t._v("\n          可以将需要多次修改的DOM元素设置"),e("code",[t._v("display:none")]),t._v("，操作完再显示。（因为隐藏元素不在"),e("code",[t._v("render")]),t._v("树内，因此修改隐藏元素不会触发回流重绘）\n        ")]),e("li",[t._v("避免多次读取某些属性")]),e("li",[t._v("\n          通过绝对位移将复杂的节点元素脱离文档流，形成新的Render\n          Layer，降低回流成本\n        ")])]),e("h4",[t._v("几条关于优化渲染效率的建议")]),e("p",[t._v("结合上文有以下几点可以优化渲染效率。")]),e("ul",[e("li",[t._v("合法地去书写HTML和CSS ，且不要忘了文档编码类型。")]),e("li",[t._v("\n          样式文件应当在"),e("code",[t._v("head")]),t._v("标签中，而脚本文件在"),e("code",[t._v("body")]),t._v("结束前，这样可以防止阻塞的方式。\n        ")]),e("li",[t._v("简化并优化CSS选择器，尽量将嵌套层减少到最小。")]),e("li",[t._v("\n          DOM\n          的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。\n        ")]),e("li",[t._v("\n          如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。\n        ")]),e("li",[t._v("\n          不要一条条地改变样式，而要通过改变"),e("code",[t._v("class")]),t._v("，或者"),e("code",[t._v("csstext")]),t._v("属性，一次性地改变样式。\n        ")]),e("li",[t._v("尽量用"),e("code",[t._v("transform")]),t._v("来做形变和位移")]),e("li",[t._v("\n          尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式。比如，操作"),e("code",[t._v("Document Fragment")]),t._v("对象，完成后再把这个对象加入DOM。再比如，使用"),e("code",[t._v("cloneNode()")]),t._v("方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。\n        ")]),e("li",[t._v("\n          先将元素设为"),e("code",[t._v("display: none")]),t._v("（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。\n        ")]),e("li",[e("code",[t._v("position")]),t._v("属性为"),e("code",[t._v("absolute")]),t._v("或"),e("code",[t._v("fixed")]),t._v("的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。\n        ")]),e("li",[t._v("\n          只在必要的时候，才将元素的"),e("code",[t._v("display")]),t._v("属性为可见，因为不可见的元素不影响重排和重绘。另外，"),e("code",[t._v("visibility : hidden")]),t._v("的元素只对重绘有影响，不影响重排。"),e("br"),t._v("\n          使用"),e("code",[t._v("window.requestAnimationFrame()")]),t._v("、"),e("code",[t._v("window.requestIdleCallback()")]),t._v("这两个方法调节重新渲染。\n        ")])])]),e("div")])])}],Jt={},Lt=Jt,Ht=Object(v["a"])(Lt,$t,Rt,!1,null,"a035a634",null),qt=Ht.exports,Ft=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},Wt=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("h2",[t._v("从输入URL到页面加载的过程")]),e("h3",[t._v("多进程的浏览器")]),e("ul",[e("li",[t._v("浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程）")])]),e("p",[t._v("进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等")]),e("pre",[e("code",[t._v("- Browser进程：浏览器的主进程（负责协调、主控），只有一个\n- 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建\n- GPU进程：最多一个，用于3D绘制\n- 浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）\n")])]),e("ul",[e("li",[e("p",[t._v("多线程的浏览器内核")]),e("ul",[e("li",[e("p",[t._v("每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程")]),e("ul",[e("li",[t._v("GUI线程")]),e("li",[t._v("JS引擎线程")]),e("li",[t._v("事件触发线程")]),e("li",[t._v("定时器线程")]),e("li",[t._v("网络请求线程")])])])])])]),e("h3",[t._v("解析URL")]),e("ul",[e("li",[e("p",[t._v("输入URL后，会进行解析（URL的本质就是统一资源定位符）")]),e("ul",[e("li",[e("p",[t._v("URL一般包括几大部分：")]),e("ul",[e("li",[t._v("protocol，协议头，譬如有http，ftp等")]),e("li",[t._v("host，主机域名或IP地址")]),e("li",[t._v("port，端口号")]),e("li",[t._v("path，目录路径")]),e("li",[t._v("query，即查询参数")]),e("li",[t._v("fragment，即#后的hash值，一般用来定位到某个位置")])])]),e("li",[e("p",[t._v("网络请求都是单独的线程")]),e("ul",[e("li",[t._v("每次网络请求时都需要开辟单独的线程进行，譬如如果URL解析到http协议，就会新建一个网络线程去处理资源下载")])])])])])]),e("p",[t._v("因此浏览器会根据解析出得协议，开辟一个网络线程，前往请求资源（这里，暂时理解为是浏览器内核开辟的，如有错误，后续修复）")]),e("h3",[t._v("开启网络线程到发出一个完整的http请求")]),e("ul",[e("li",[e("p",[t._v("DNS查询得到IP")]),e("ul",[e("li",[e("p",[t._v("如果输入的是域名，需要进行dns解析成IP，大致流程：")]),e("ul",[e("li",[t._v("如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host")]),e("li",[t._v("如果本地没有，就向dns域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的IP")])])])])]),e("li",[e("p",[t._v("tcp/ip请求")]),e("ul",[e("li",[e("p",[t._v("http的本质就是tcp/ip请求")]),e("ul",[e("li",[e("p",[t._v("tcp将http长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输")]),e("ul",[e("li",[e("p",[t._v("三次握手的步骤：（抽象派）")]),e("ul",[e("li",[t._v("客户端：hello，你是server么？\n服务端：hello，我是server，你是client么\n客户端：yes，我是client")]),e("li",[t._v("建立连接成功后，接下来就正式传输数据")])])])])]),e("li",[e("p",[t._v("待到断开连接时，需要进行四次挥手（因为是全双工的，所以需要四次挥手）")]),e("ul",[e("li",[e("p",[t._v("四次挥手的步骤：（抽象派）")]),e("ul",[e("li",[t._v("主动方：我已经关闭了向你那边的主动通道了，只能被动接收了\n被动方：收到通道关闭的信息\n被动方：那我也告诉你，我这边向你的主动通道也关闭了\n主动方：最后收到数据，之后双方无法通信")])])])])])])]),e("li",[e("p",[t._v("tcp/ip的并发限制")]),e("ul",[e("li",[t._v("浏览器对同一域名下并发的tcp连接是有限制的（2-10个不等）")])])])])])]),e("p",[t._v("而且在http1.0中往往一个资源下载就需要对应一个tcp/ip请求")]),e("p",[t._v("所以针对这个瓶颈，又出现了很多的资源优化方案")]),e("pre",[e("code",[t._v("- get和post的区别\n\n\t- get和post虽然本质都是tcp/ip，但两者除了在http层面外，在tcp/ip层面也有区别。\n")])]),e("p",[t._v("get会产生一个tcp数据包，post两个")]),e("pre",[e("code",[t._v("\t\t- get请求时，浏览器会把headers和data一起发送出去，服务器响应200（返回数据），\n\t\t- post请求时，浏览器先发送headers，服务器响应100 continue，\n\t\t- 浏览器再发送data，服务器响应200（返回数据）。\n")])]),e("ul",[e("li",[e("p",[t._v("五层因特网协议栈")]),e("ul",[e("li",[e("p",[t._v("一个概念： 从客户端发出http请求到服务器接收，中间会经过一系列的流程。")]),e("ul",[e("li",[t._v("从应用层的发送http请求，到传输层通过三次握手建立tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。")])])])])])]),e("p",[t._v("当然，服务端的接收就是反过来的步骤")]),e("pre",[e("code",[t._v("- 1.应用层(dns,http) DNS解析成IP并发送http请求\n")])]),e("p",[t._v("2.传输层(tcp,udp) 建立tcp连接（三次握手）")]),e("p",[t._v("3.网络层(IP,ARP) IP寻址")]),e("p",[t._v("4.数据链路层(PPP) 封装成帧")]),e("p",[t._v("5.物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）")]),e("h3",[t._v("从服务器接收到请求到对应后台接收到请求")]),e("ul",[e("li",[e("p",[t._v("负载均衡")]),e("ul",[e("li",[t._v("用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了nginx控制负载均衡），\n然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的HTTP响应，并将它反馈给用户")])])]),e("li",[e("p",[t._v("后台的处理")]),e("ul",[e("li",[e("p",[t._v("一般后台都是部署到容器中的，所以一般为：")]),e("ul",[e("li",[t._v("先是容器接受到请求（如tomcat容器）")]),e("li",[t._v("然后对应容器中的后台程序接收到请求（如java程序）")]),e("li",[t._v("然后就是后台会有自己的统一处理，处理完后响应响应结果")])])]),e("li",[e("p",[t._v("概括下：")]),e("ul",[e("li",[t._v("一般有的后端是有统一的验证的，如安全拦截，跨域验证")]),e("li",[t._v("如果这一步不符合规则，就直接返回了相应的http报文（如拒绝请求等）")]),e("li",[t._v("然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）")]),e("li",[t._v("等程序执行完毕后，就会返回一个http响应包（一般这一步也会经过多层封装）")]),e("li",[t._v("然后就是将这个包从后端发送到前端，完成交互")])])])])]),e("li",[e("p",[t._v("后台和前台的http交互")]),e("ul",[e("li",[e("p",[t._v("http报文结构")]),e("ul",[e("li",[e("p",[t._v("报文一般包括了：通用头部，请求/响应头部，请求/响应体")]),e("ul",[e("li",[e("p",[t._v("通用头部")]),e("ul",[e("li",[e("p",[t._v("这也是开发人员见过的最多的信息，包括如下：")]),e("ul",[e("li",[e("p",[t._v("Request Url: 请求的web服务器地址")])]),e("li",[e("p",[t._v("Request Method: 请求方式（Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）")]),e("ul",[e("li",[t._v("HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。")]),e("li",[t._v("HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。")])])]),e("li",[e("p",[t._v("Status Code: 请求的返回状态码，如200代表成功")]),e("ul",[e("li",[t._v("200——表明该请求被成功地完成，所请求的资源发送回客户端")]),e("li",[t._v("304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存")]),e("li",[t._v("400——客户端请求有错（譬如可以是安全模块拦截）")]),e("li",[t._v("401——请求未经授权")]),e("li",[t._v("403——禁止访问（譬如可以是未登录时禁止）")]),e("li",[t._v("404——资源未找到")]),e("li",[t._v("500——服务器内部错误")]),e("li",[t._v("503——服务不可用")]),e("li",[t._v("1xx——指示信息，表示请求已接收，继续处理")]),e("li",[t._v("2xx——成功，表示请求已被成功接收、理解、接受")]),e("li",[t._v("3xx——重定向，要完成请求必须进行更进一步的操作")]),e("li",[t._v("4xx——客户端错误，请求有语法错误或请求无法实现")]),e("li",[t._v("5xx——服务器端错误，服务器未能实现合法的请求")])])]),e("li",[e("p",[t._v("Remote Address: 请求的远程服务器地址（会转为IP）")])])])])])]),e("li",[e("p",[t._v("请求/响应头部")]),e("ul",[e("li",[e("p",[t._v("常用的请求头部（部分）：")]),e("ul",[e("li",[t._v("Accept: 接收类型，表示浏览器支持的MIME类型\n（对标服务端返回的Content-Type）\nAccept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收\nContent-Type：客户端发送出去实体内容的类型\nCache-Control: 指定请求和响应遵循的缓存机制，如no-cache\nIf-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中\nExpires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间\nMax-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中\nIf-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中\nCookie: 有cookie并且同域访问时会自动带上\nConnection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive\nHost：请求的服务器URL\nOrigin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私\nReferer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)\nUser-Agent：用户客户端的一些必要信息，如UA头部等")])])]),e("li",[e("p",[t._v("常用的响应头部（部分）：")]),e("ul",[e("li",[t._v("Access-Control-Allow-Headers: 服务器端允许的请求Headers\nAccess-Control-Allow-Methods: 服务器端允许的请求方法\nAccess-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）\nContent-Type：服务端返回的实体内容的类型\nDate：数据从服务器发送的时间\nCache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档\nLast-Modified：请求资源的最后修改时间\nExpires：应该在什么时候认为文档已经过期,从而不再缓存它\nMax-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效\nETag：请求变量的实体标签的当前值\nSet-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端\nKeep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）\nServer：服务器的一些相关信息")])])])])]),e("li",[e("p",[t._v("请求/响应实体")]),e("ul",[e("li",[t._v("http请求时，除了头部，还有消息实体，一般来说")])])])])])])])])])]),e("p",[t._v("请求实体中会将一些需要的参数都放入进入（用于post请求）。")]),e("p",[t._v("譬如实体中可以放参数的序列化形式（a=1&b=2这种），或者直接放表单对象（Form Data对象，上传时可以夹杂参数以及文件），等等")]),e("p",[t._v("而一般响应实体中，就是放服务端需要传给客户端的内容")]),e("p",[t._v("一般现在的接口请求时，实体中就是对于的信息的json格式，而像页面请求这种，里面就是直接放了一个html字符串，然后浏览器自己解析并渲染。")]),e("pre",[e("code",[t._v("\t\t- CRLF\n\n\t\t\t- CRLF（Carriage-Return Line-Feed），意思是回车换行，一般作为分隔符存在\n")])]),e("p",[t._v("请求头和实体消息之间有一个CRLF分隔，响应头部和响应实体之间用一个CRLF分隔")]),e("p",[t._v("一般来说（分隔符类别）：")]),e("p",[t._v("CRLF->Windows-style\nLF->Unix Style\nCR->Mac Style")]),e("ul",[e("li",[e("p",[t._v("cookie以及优化")]),e("ul",[e("li",[e("p",[t._v("cookie是浏览器的一种本地存储方式，一般用来帮助客户端和服务端通信的，常用来进行身份校验，结合服务端的session使用。")]),e("ul",[e("li",[e("p",[t._v("场景如下（简述）：")]),e("ul",[e("li",[t._v("在登陆页面，用户登陆了")])])])])])])])]),e("p",[t._v("此时，服务端会生成一个session，session中有对于用户的信息（如用户名、密码等）")]),e("p",[t._v("然后会有一个sessionid（相当于是服务端的这个session对应的key）")]),e("p",[t._v("然后服务端在登录页面中写入cookie，值就是:jsessionid=xxx")]),e("p",[t._v("然后浏览器本地就有这个cookie了，以后访问同域名下的页面时，自动带上cookie，自动检验，在有效时间内无需二次登陆。")]),e("ul",[e("li",[e("p",[t._v("gzip压缩")]),e("ul",[e("li",[t._v("首先，明确gzip是一种压缩格式，需要浏览器支持才有效（不过一般现在浏览器都支持），\n而且gzip压缩效率很好（高达70%左右）")])])])]),e("p",[t._v("然后gzip一般是由apache、tomcat等web服务器开启")]),e("p",[t._v("当然服务器除了gzip外，也还会有其它压缩格式（如deflate，没有gzip高效，且不流行）")]),e("p",[t._v("所以一般只需要在服务器上开启了gzip压缩，然后之后的请求就都是基于gzip压缩格式的，\n非常方便。")]),e("ul",[e("li",[e("p",[t._v("长连接与短连接")]),e("ul",[e("li",[e("p",[t._v("首先看tcp/ip层面的定义：")]),e("ul",[e("li",[t._v("长连接：一个tcp/ip连接上可以连续发送多个数据包，在tcp连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）")]),e("li",[t._v("短连接：通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接")])])]),e("li",[e("p",[t._v("然后在http层面：")]),e("ul",[e("li",[t._v("http1.0中，默认使用的是短连接，也就是说，浏览器没进行一次http操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接")]),e("li",[t._v("http1.1起，默认使用长连接，使用长连接会有这一行Connection: keep-alive，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输http的tcp连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接")])])]),e("li",[e("p",[t._v("keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效")])])])]),e("li",[e("p",[t._v("http 2.0")]),e("ul",[e("li",[e("p",[t._v("http2.0不是https，它相当于是http的下一代规范（譬如https的请求可以是http2.0规范的）")])]),e("li",[e("p",[t._v("然后简述下http2.0与http1.1的显著不同点：")]),e("ul",[e("li",[t._v("http1.1中，每请求一个资源，都是需要开启一个tcp/ip连接的，所以对应的结果是，每一个资源对应一个tcp/ip请求，由于tcp/ip本身有并发数限制，所以当资源一多，速度就显著慢下来")]),e("li",[t._v("http2.0中，一个tcp/ip请求可以请求多个资源，也就是说，只要一次tcp/ip请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。")])])]),e("li",[e("p",[t._v("http2.0的一些特性：")]),e("ul",[e("li",[t._v("多路复用（即一个tcp/ip连接可以请求多个资源）")]),e("li",[t._v("首部压缩（http头部压缩，减少体积）")]),e("li",[t._v("二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）")]),e("li",[t._v("服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）")]),e("li",[t._v("请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）")])])])])]),e("li",[e("p",[t._v("https")]),e("ul",[e("li",[e("p",[t._v("https就是安全版本的http，譬如一些支付等操作基本都是基于https的，因为http请求的安全系数太低了。")]),e("ul",[e("li",[t._v("简单来看，https与http的区别就是： 在请求前，会建立ssl链接，确保接下来的通信都是加密的，无法被轻易截取分析")])])]),e("li",[e("p",[t._v("SSL/TLS的握手流程，如下（简述）：")]),e("ul",[e("li",[e("ol",{attrs:{start:""}},[e("li",[t._v("浏览器请求建立SSL链接，并向服务端发送一个随机数–Client random和客户端支持的加密方法，比如RSA加密，此时是明文传输。 ")])])]),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[t._v("服务端从中选出一组加密算法与Hash算法，回复一个随机数–Server random，并将自己的身份信息以证书的形式发回给浏览器\n（证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息）")])])]),e("li",[e("ol",{attrs:{start:"3"}},[e("li",[t._v("浏览器收到服务端的证书后")])]),e("ul",[e("li",[e("ul",[e("li",[t._v("验证证书的合法性（颁发机构是否合法，证书中包含的网址是否和正在访问的一样），如果证书信任，则浏览器会显示一个小锁头，否则会有提示")])])]),e("li",[e("ul",[e("li",[t._v("用户接收证书后（不管信不信任），浏览会生产新的随机数–Premaster secret，然后证书中的公钥以及指定的加密方法加密"),e("code",[t._v("Premaster secret")]),t._v("，发送给服务器。")])])]),e("li",[e("ul",[e("li",[t._v("利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key-"),e("code",[t._v("session key")])])])]),e("li",[e("ul",[e("li",[t._v("使用约定好的HASH算法计算握手消息，并使用生成的"),e("code",[t._v("session key")]),t._v("对消息进行加密，最后将之前生成的所有信息发送给服务端。")])])])])]),e("li",[e("ol",{attrs:{start:"4"}},[e("li",[t._v("服务端收到浏览器的回复")])]),e("ul",[e("li",[e("ul",[e("li",[t._v("利用已知的加解密方式与自己的私钥进行解密，获取"),e("code",[t._v("Premaster secret")])])])]),e("li",[e("ul",[e("li",[t._v("和浏览器相同规则生成"),e("code",[t._v("session key")])])])]),e("li",[e("ul",[e("li",[t._v("使用"),e("code",[t._v("session key")]),t._v("解密浏览器发来的握手消息，并验证Hash是否与浏览器发来的一致")])])]),e("li",[e("ul",[e("li",[t._v("使用"),e("code",[t._v("session key")]),t._v("加密一段握手消息，发送给浏览器")])])])])]),e("li",[e("ol",{attrs:{start:"5"}},[e("li",[t._v("浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，")])])])])])])]),e("li",[e("p",[t._v("单独拎出来的缓存问题，http的缓存")]),e("ul",[e("li",[e("p",[t._v("强缓存与弱缓存")]),e("ul",[e("li",[e("p",[t._v("缓存可以简单的划分成两种类型：强缓存（200 from cache）与协商缓存（304）")]),e("ul",[e("li",[e("p",[t._v("区别简述如下：")]),e("ul",[e("li",[e("p",[t._v("强缓存（200 from cache）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求")]),e("ul",[e("li",[t._v("但是对于强缓存，在未过期时，必须更新资源路径才能发起新的请求（更改了路径相当于是另一个资源了，这也是前端工程化中常用到的技巧）")])])]),e("li",[e("p",[t._v("协商缓存（304）时，浏览器会向服务端发起http请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存")]),e("ul",[e("li",[t._v("对于协商缓存，使用Ctrl + F5强制刷新可以使得缓存无效")])])])])])])])])]),e("li",[e("p",[t._v("缓存头部简述")]),e("ul",[e("li",[e("p",[t._v("属于强缓存控制的：")]),e("ul",[e("li",[t._v("（http1.1）Cache-Control/Max-Age")]),e("li",[t._v("（http1.0）Pragma/Expires")])])]),e("li",[e("p",[t._v("属于协商缓存控制的：")]),e("ul",[e("li",[t._v("（http1.1）If-None-Match/E-tag")]),e("li",[t._v("（http1.0）If-Modified-Since/Last-Modified")])])]),e("li",[e("p",[t._v("头部的区别")]),e("ul",[e("li",[e("p",[t._v("http1.0中的缓存控制：")]),e("ul",[e("li",[t._v("Pragma：严格来说，它不属于专门的缓存控制头部，但是它设置no-cache时可以让本地强缓存失效（属于编译控制，来实现特定的指令，主要是因为兼容http1.0，所以以前又被大量应用）")]),e("li",[t._v("Expires：服务端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires一般对应服务器端时间，如Expires：Fri, 30 Oct 1998 14:19:41")]),e("li",[t._v("If-Modified-Since/Last-Modified：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-Modified-Since，而服务端的是Last-Modified，它的作用是，在发起请求时，如果If-Modified-Since和Last-Modified匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。Last-Modified，顾名思义，指的是文件最后的修改时间，而且只能精确到1s以内")])])]),e("li",[e("p",[t._v("http1.1中的缓存控制：")]),e("ul",[e("li",[t._v("Cache-Control：缓存控制头部，有no-cache、max-age等多种取值")]),e("li",[t._v("Max-Age：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age是Cache-Control头部的值，不是独立的头部，譬如Cache-Control: max-age=3600，而且它值得是绝对时间，由浏览器自己计算")]),e("li",[t._v("If-None-Match/E-tag：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-None-Match，而服务端的是E-tag，同样，发出请求后，如果If-None-Match和E-tag匹配，则代表内容未变，通知浏览器使用本地缓存，和Last-Modified不同，E-tag更精确，它是类似于指纹一样的东西，基于FileEtag INode Mtime Size生成，也就是说，只要文件变，指纹就会变，而且没有1s精确度的限制。")])])]),e("li",[e("p",[t._v("Max-Age相比Expires？")]),e("ul",[e("li",[e("p",[t._v("Expires使用的是服务器端的时间")]),e("ul",[e("li",[t._v("客户端时间和服务端不同步")])])])])])])])])])])])]),e("p",[t._v("那这样，可能就会出问题了，造成了浏览器本地的缓存无用或者一直无法过期")]),e("p",[t._v("所以一般http1.1后不推荐使用Expires")]),e("pre",[e("code",[t._v("\t\t\t- 而Max-Age使用的是客户端本地时间的计算，因此不会有这个问题\n\t\t\t- 注意，如果同时启用了Cache-Control与Expires，Cache-Control优先级高。\n\n\t\t- E-tag相比Last-Modified？\n\n\t\t\t- Last-Modified：\n\n\t\t\t\t- 表明服务端的文件最后何时改变的\n\t\t\t\t- 它有一个缺陷就是只能精确到1s，\n\t\t\t\t- 然后还有一个问题就是有的服务端的文件会周期性的改变，导致缓存失效\n\n\t\t\t- E-tag：\n\n\t\t\t\t- 是一种指纹机制，代表文件相关指纹\n\t\t\t\t- 只有文件变才会变，也只要文件变就会变，\n\t\t\t\t- 也没有精确时间的限制，只要文件一遍，立马E-tag就不一样了\n\n\t\t\t- 如果同时带有E-tag和Last-Modified，服务端会优先检查E-tag\n")])]),e("h3",[t._v("解析页面流程")]),e("ul",[e("li",[e("p",[t._v("流程简述")]),e("ul",[e("li",[e("p",[t._v("浏览器内核拿到内容后，渲染步骤大致可以分为以下几步：")]),e("ul",[e("li",[e("ol",{attrs:{start:""}},[e("li",[t._v("解析HTML，构建DOM树")])]),e("ul",[e("li",[e("p",[t._v("解析HTML到构建出DOM当然过程可以简述如下：")]),e("ul",[e("li",[e("p",[t._v("Bytes → characters → tokens → nodes → DOM")]),e("ul",[e("li",[e("p",[t._v("譬如假设有这样一个HTML页面：")]),e("ul",[e("li")])])])])])])])])])])]),e("p",[t._v("Hello "),e("span",[t._v("web performance")]),t._v(" students!")]),e("div",[e("img",{attrs:{src:"awesome-photo.jpg"}})]),e("pre",[e("code",[t._v("\t\t\t\t- 列举其中的一些重点过程：\n\n\t\t\t\t\t- 1. Conversion转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符\n\t\t\t\t\t- 2. Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集\n\t\t\t\t\t- 3. Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则\n\t\t\t\t\t- 4. DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样\n\t\t\t\t\t- 例如：body对象的父节点就是HTML对象，然后段略p对象的父节点就是body对象\n\n\t\t\t\t- 最后的DOM树如下：\n\n- 2. 解析CSS，生成CSS规则树\n\n\t- CSS规则树的生成也是类似。简述为：\n\n\t\t- Bytes → characters → tokens → nodes → CSSOM\n\n\t\t\t- style.css内容如下：\n\n\t\t\t\t- body { font-size: 16px }\n")])]),e("p",[t._v("p { font-weight: bold }\nspan { color: red }\np span { display: none }\nimg { float: right }")]),e("pre",[e("code",[t._v("\t\t\t\t\t- 最终的CSSOM树就是：\n\n- 3. 合并DOM树和CSS规则，生成render树\n\n\t- 当DOM树和CSSOM都有了后，就要开始构建渲染树了\n")])])])]),e("p",[t._v("一般来说，渲染树和DOM树相对应的，但不是严格意义上的一一对应")]),e("p",[t._v("因为有一些不可见的DOM元素不会插入到渲染树中，如head这种不可见的标签或者display: none等")]),e("pre",[e("code",[t._v("\t- 4. 布局render树（Layout/reflow），负责各元素尺寸、位置的计算\n\n\t\t- 有了render树，接下来就是开始渲染，基本流程如下：\n\n\t\t\t- 重要的四个步骤就是：\n\n\t\t\t\t- 1. 计算CSS样式\n\t\t\t\t- 2. 构建渲染树\n\t\t\t\t- 3. 布局，主要定位坐标和大小，是否换行，各种position overflow z-index属性\n\t\t\t\t- 4. 绘制，将图像绘制出来\n\n\t\t\t- 图中的线与箭头代表通过js动态修改了DOM或CSS，导致了重新布局（Layout）或渲染（Repaint）\n\t\t\t- Layout和Repaint的概念是有区别的：\n\n\t\t\t\t- Layout，也称为Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树\n\t\t\t\t- Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了\n\n\t\t\t- 什么会引起回流？\n\n\t\t\t\t- 1.页面渲染初始化\n\t\t\t\t- 2.DOM结构改变，比如删除了某个节点\n\t\t\t\t- 3.render树变化，比如减少了padding\n\t\t\t\t- 4.窗口resize\n\t\t\t\t- 5.最复杂的一种：获取某些属性，引发回流，\n")])]),e("p",[t._v("很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，\n但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括")]),e("pre",[e("code",[t._v("\t\t\t\t\t-     （1）offset(Top/Left/Width/Height)\n\t\t\t\t\t-      (2) scroll(Top/Left/Width/Height)\n\t\t\t\t\t-      (3) cilent(Top/Left/Width/Height)\n\t\t\t\t\t-      (4) width,height\n\t\t\t\t\t-      (5) 调用了getComputedStyle()或者IE的currentStyle\n\n\t\t\t- 回流优化方案\n\n\t\t\t\t- 减少逐项更改样式，最好一次性更改style，或者将样式定义为class并一次性更新\n\t\t\t\t- 避免循环操作dom，创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document\n\t\t\t\t- 避免多次读取offset等属性。无法避免则将它们缓存到变量\n\t\t\t\t- 将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高\n\n\t- 5. 绘制render树（paint），绘制页面像素信息\n\t- 6. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上\n")])])])}],Bt={},Ut=Bt,Gt=Object(v["a"])(Ut,Ft,Wt,!1,null,"ccc1014a",null),Vt=Gt.exports,Xt=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},Qt=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("h2",[t._v("重排和重绘")]),e("h3",[t._v("（1）写在前面：")]),e("ul",[e("li",[t._v("浏览器使用流式布局模型 (Flow Based Layout)。")]),e("li",[t._v("浏览器会把HTML解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就产生了Render Tree。")]),e("li",[t._v("有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。")]),e("li",[t._v("由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。")]),e("li",[t._v("重排（CPU）必将引起重绘（GPU），重绘不一定会引起重排。")])]),e("h3",[t._v("（2）重排（reflow）")]),e("ul",[e("li",[e("p",[t._v("定义")]),e("ul",[e("li",[t._v("当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为重排。")])])]),e("li",[e("p",[t._v("会导致重排的操作：")]),e("ul",[e("li",[t._v("页面首次渲染")]),e("li",[t._v("浏览器窗口大小发生改变")]),e("li",[t._v("元素尺寸或位置发生改变")]),e("li",[t._v("元素内容变化（文字数量或图片大小等等）")]),e("li",[t._v("元素字体大小变化")]),e("li",[t._v("添加或者删除可见的DOM元素")]),e("li",[t._v("激活CSS伪类（例如：:hover）")]),e("li",[t._v("查询某些属性或调用某些方法")])])]),e("li",[e("p",[t._v("一些常用且会导致重排的属性和方法：")]),e("ul",[e("li",[t._v("clientWidth、clientHeight、clientTop、clientLeft")]),e("li",[t._v("offsetWidth、offsetHeight、offsetTop、offsetLeft")]),e("li",[t._v("scrollWidth、scrollHeight、scrollTop、scrollLeft")]),e("li",[t._v("scrollIntoView()、scrollIntoViewIfNeeded()")]),e("li",[t._v("getComputedStyle()")]),e("li",[t._v("getBoundingClientRect()")]),e("li",[t._v("scrollTo()")])])])]),e("h3",[t._v("（3）重绘 (Repaint)")]),e("ul",[e("li",[t._v("当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。")])]),e("h3",[t._v("（4）什么情况会触发重排和重绘？")]),e("ul",[e("li",[t._v("添加、删除、更新 DOM 节点")]),e("li",[t._v("通过 display: none 隐藏一个 DOM 节点-触发重排和重绘")]),e("li",[t._v("通过 visibility: hidden 隐藏一个 DOM 节点-只触发重绘，因为没有几何变化")]),e("li",[t._v("移动或者给页面中的 DOM 节点添加动画")]),e("li",[t._v("添加一个样式表，调整样式属性")]),e("li",[t._v("用户行为，例如调整窗口大小，改变字号，或者滚动。")])]),e("h3",[t._v("（5）性能影响")]),e("ul",[e("li",[e("p",[t._v("重排比重绘的代价要更高。")])]),e("li",[e("p",[t._v("现代浏览器对频繁的重排和重绘进行了优化")]),e("ul",[e("li",[t._v("有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。")]),e("li",[t._v("浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。")])])]),e("li",[e("p",[t._v("获取布局的操作，会导致队列刷新，浏览器的优化效果也就没有了。要避免在布局信息改变时，获取下列属性")]),e("ul",[e("li",[t._v("clientWidth、clientHeight、clientTop、clientLeft")]),e("li",[t._v("offsetWidth、offsetHeight、offsetTop、offsetLeft")]),e("li",[t._v("scrollWidth、scrollHeight、scrollTop、scrollLeft")]),e("li",[t._v("width、height")]),e("li",[t._v("getComputedStyle()")]),e("li",[t._v("getBoundingClientRect()")])])])]),e("h3",[t._v("（6）如何避免")]),e("ul",[e("li",[e("p",[t._v("CSS")]),e("ul",[e("li",[t._v("（1）避免使用table布局。")]),e("li",[t._v("（2）尽可能在DOM树的最末端改变class。")]),e("li",[t._v("（3）避免设置多层内联样式。")]),e("li",[t._v("（4）将动画效果应用到position属性为absolute或fixed的元素上。")]),e("li",[t._v("（5）避免使用CSS表达式（例如：calc()）。")])])]),e("li",[e("p",[t._v("JavaScript")]),e("ul",[e("li",[e("ol",{attrs:{start:""}},[e("li",[t._v("合并多次的DOM操作为单次的DOM操作")])]),e("ul",[e("li",[e("p",[t._v("（1）避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。")]),e("ul",[e("li",[t._v("方案2比方案1稍微有一些性能上的损耗，因为它需要查询CSS类。但方案2的维护性最好，")]),e("li",[t._v("类似的操作还有通过innerHTML接口修改DOM元素的内容。不要直接通过此接口来拼接HTML代码，而是以字符串方式拼接好代码后，一次性赋值给DOM元素的innerHTML接口。")])])])])]),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[t._v("把DOM元素离线或隐藏后修改")])]),e("p",[t._v("把DOM元素从页面流中脱离或隐藏，这样处理后，只会在DOM元素脱离和添加时，或者是隐藏和显示时才会造成页面的重绘或回流，对脱离了页面布局流的DOM元素操作就不会导致页面的性能问题。这种方式适合那些需要大批量修改DOM元素的情况。具体的方式主要有三种：")]),e("ul",[e("li",[e("p",[t._v("（2）避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。")]),e("ul",[e("li",[t._v("文档片段是一个轻量级的document对象，并不会和特定的页面关联。通过在文档片段上进行DOM操作，可以降低DOM操作对页面性能的影响，这 种方式是创建一个文档片段，并在此片段上进行必要的DOM操作，操作完成后将它附加在页面中。对页面性能的影响只存在于最后把文档片段附加到页面的这一步 操作上。")])])]),e("li",[e("p",[t._v("（3）也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。")]),e("ul",[e("li",[t._v("这种方式是通过隐藏页面的DOM元素，达到在页面中移除元素的效果，经过大量的DOM操作后恢复元素原来的display样式。对于这类会引起页面重绘或回流的操作，就只有隐藏和显示DOM元素这两个步骤了。")])])]),e("li",[e("p",[t._v("（4）避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。")]),e("ul",[e("li",[t._v("这种方式是把页面上的DOM元素克隆一份到内存中，然后再在内存中操作克隆的元素，操作完成后使用此克隆元素替换页面中原来的DOM元素。这样一来，影响性能的操作就只是最后替换元素的这一步操作了，在内存中操作克隆元素不会引起页面上的性能损耗。")])])])])]),e("li",[e("ol",{attrs:{start:"3"}},[e("li",[t._v("设置具有动画效果的DOM元素的position属性为fixed或absolute")])]),e("ul",[e("li",[e("p",[t._v("（5）对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。")]),e("ul",[e("li",[t._v("把页面中具有动画效果的元素设置为绝对定位，使得元素脱离页面布局流，从而避免了页面频繁的回流，只涉及动画元素自身的回流了。这种做法可以提高动 画效果的展示性能。如果把动画元素设置为绝对定位并不符合设计的要求，则可以在动画开始时将其设置为绝对定位，等动画结束后恢复原始的定位设置。在很多的 网站中，页面的顶部会有大幅的广告展示，一般会动画展开和折叠显示。如果不做性能的优化，这个效果的性能损耗是很明显的。使用这里提到的优化方案，则可以 提高性能。")])])])])]),e("li",[e("ol",{attrs:{start:"4"}},[e("li",[t._v("谨慎取得DOM元素的布局信息")])]),e("ul",[e("li",[e("p",[t._v("获取DOM的布局信息会有性能的损耗，所以如果存在重复调用，最佳的做法是尽量把这些值缓存在局部变量中。")])]),e("li",[e("p",[t._v("示例")]),e("ul",[e("li",[t._v("如上的代码中，会在一个循环中反复取得一个元素的offsetTop值，事实上，在此代码中该元素的offsetTop值并不会变更，所以会存在不必要的性能损耗。优化的方案是在循环外部取得元素的offsetTop值，相比较之前的方案，此方案只是调用了一遍元素的offsetTop值。")])])]),e("li",[e("p",[t._v("浏览器会优化连续的DOM操作")]),e("ul",[e("li",[t._v("因为取得DOM元素的布局信息会强制浏览器刷新渲染树，并且可能会导致页面的重绘或回流，所以在有大批量DOM操作时，应避免获取DOM元素 的布局信息，使得浏览器针对大批量DOM操作的优化不被破坏。如果需要这些布局信息，最好是在DOM操作之前就取得。")]),e("li",[t._v("如果把取得DOM元素的布局信息提前，因为浏览器会优化连续的DOM操作，所以实际上只会有一次的页面回流出现")])])])])])])])])])}],Yt={},Kt=Yt,Zt=Object(v["a"])(Kt,Xt,Qt,!1,null,"616d4240",null),tn=Zt.exports,nn=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},en=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("h1",[t._v("跨域")]),e("h2",[t._v("常见浏览器跨域的解决方式大概6种")]),e("h3",[t._v("跨域请求")]),e("ul",[e("li",[t._v("1.jsonp 需要目标服务器配合一个callback函数。")]),e("li",[t._v("2.CORS  需要服务器设置header ：Access-Control-Allow-Origin。")]),e("li",[t._v("3.nginx反向代理 这个方法一般很少有人提及，但是他可以不用目标服务器配合，不过需要你搭建一个中转nginx服务器，用于转发请求。")])]),e("h3",[t._v("访问跨域的页面")]),e("ul",[e("li",[t._v("4.window.name+iframe 需要目标服务器响应window.name。")]),e("li",[t._v("5.window.location.hash+iframe 同样需要目标服务器作处理。")]),e("li",[t._v("6.html5的 postMessage+iframe 这个也是需要目标服务器或者说是目标页面写一个postMessage，主要侧重于前端通讯。")])]),e("h2",[t._v("浏览器同源政策及其规避方法")]),e("h3",[t._v("同源策略限制范围")]),e("ul",[e("li",[t._v("（1） Cookie、LocalStorage 和 IndexDB 无法读取。")]),e("li",[t._v("（2） DOM 无法获得。")]),e("li",[t._v("（3） AJAX 请求不能发送。")])]),e("h3",[t._v("Cookie")]),e("ul",[e("li",[e("p",[t._v("解决")]),e("ul",[e("li",[t._v("两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享 Cookie。")]),e("li",[t._v("举例来说，A网页是"),e("a",{staticClass:"url",attrs:{href:"http://w1.example.com/a.html",target:"_blank"}},[t._v("http://w1.example.com/a.html")]),t._v("，B网页是"),e("a",{staticClass:"url",attrs:{href:"http://w2.example.com/b.html",target:"_blank"}},[t._v("http://w2.example.com/b.html")]),t._v("，那么只要设置相同的document.domain，两个网页就可以共享Cookie。")]),e("li",[t._v("document.domain = 'example.com';\n----\x3e现在，A网页通过脚本设置一个 Cookie。document.cookie = \"test1=hello\";\n----\x3eB网页就可以读到这个 Cookie。var allCookie = document.cookie;")])])]),e("li",[e("p",[t._v("注意")]),e("ul",[e("li",[t._v("注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。")])])])]),e("h3",[t._v("iframe")]),e("ul",[e("li",[e("p",[t._v("问题")]),e("ul",[e("li",[t._v("如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。")])])]),e("li",[e("p",[t._v("解决")]),e("ul",[e("li",[e("p",[t._v("同源的情况")]),e("ul",[e("li",[t._v("如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的document.domain属性，就可以规避同源政策，拿到DOM。")]),e("li",[t._v("iframe访问父页面可通过window.parent得到父窗口的window对象，通过open打开的可以用window.opener，进而得到父窗口的任何东西；父窗口如果和iframe同源的，那么可通过iframe.contentWindow得到iframe的window对象")])])]),e("li",[e("p",[t._v("对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。")]),e("ul",[e("li",[e("p",[t._v("片段识别符（fragment identifier）")]),e("ul",[e("li",[e("p",[t._v("定义")]),e("ul",[e("li",[t._v("片段标识符（fragment identifier）指的是，URL的#号后面的部分，比如"),e("a",{staticClass:"url",attrs:{href:"http://example.com/x.html#fragment",target:"_blank"}},[t._v("http://example.com/x.html#fragment")]),t._v("的#fragment。如果只是改变片段标识符，页面不会重新刷新。")])])]),e("li",[e("p",[t._v("用法")])])])]),e("li",[e("p",[t._v("window.name")]),e("ul",[e("li",[e("p",[t._v("定义")]),e("ul",[e("li",[t._v("浏览器窗口有window.name属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。")])])]),e("li",[e("p",[t._v("用法")])]),e("li",[e("p",[t._v("优缺点")]),e("ul",[e("li",[t._v("这种方法的优点是，window.name容量很大，可以放置非常长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能")])])])])]),e("li",[e("p",[t._v("跨文档通信API（Cross-document messaging）")]),e("ul",[e("li",[e("p",[t._v("定义")]),e("ul",[e("li",[t._v("这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。")]),e("li",[t._v("举例来说，父窗口"),e("a",{staticClass:"url",attrs:{href:"http://aaa.com",target:"_blank"}},[t._v("http://aaa.com")]),t._v("向子窗口"),e("a",{staticClass:"url",attrs:{href:"http://bbb.com",target:"_blank"}},[t._v("http://bbb.com")]),t._v("发消息，调用postMessage方法就可以了。")])])]),e("li",[e("p",[t._v("语法")]),e("ul",[e("li",[t._v("otherWindow.postMessage(message, targetOrigin);")])])]),e("li",[e("p",[t._v("基本使用")]),e("ul",[e("li",[e("p",[t._v('postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即"协议 + 域名 + 端口"。也可以设为*，表示不限制域名，向所有窗口发送。')])]),e("li",[e("p",[t._v("父窗口和子窗口都可以通过message事件，监听对方的消息。")])]),e("li",[e("p",[t._v("message事件的事件对象event，提供以下三个属性。")]),e("ul",[e("li",[t._v("event.source：发送消息的窗口")]),e("li",[t._v("event.origin: 消息发向的网址")]),e("li",[t._v("event.data: 消息内容")])])])])])])])])])])])]),e("h3",[t._v("AJAX")]),e("ul",[e("li",[e("p",[t._v("除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。")])]),e("li",[e("p",[t._v("JSONP")]),e("ul",[e("li",[e("p",[t._v("基本思想")]),e("ul",[e("li",[t._v("它的基本思想是，网页通过添加一个<script>元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。")])])]),e("li",[e("p",[t._v("应用")]),e("ul",[e("li",[t._v("首先，网页动态插入<script>元素，由它向跨源网址发出请求。")]),e("li",[t._v("上面代码通过动态添加<script>元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。")]),e("li",[t._v("服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。")]),e("li",[t._v("由于<script>元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。")])])]),e("li",[e("p",[t._v("优缺点")]),e("ul",[e("li",[e("p",[t._v("优点")]),e("ul",[e("li",[t._v("兼容性好，可以在更古老的浏览器中运行")])])]),e("li",[e("p",[t._v("缺点")]),e("ul",[e("li",[t._v("只支持GET")])])])])]),e("li",[e("p",[t._v("总结")])])])]),e("li",[e("p",[t._v("WebSocket")]),e("ul",[e("li",[e("p",[t._v("基本思想")]),e("ul",[e("li",[t._v("WebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。")])])])])]),e("li",[e("p",[t._v("CORS")]),e("ul",[e("li",[e("p",[t._v("简单请求（simple request）")]),e("ul",[e("li",[e("p",[t._v("满足条件")]),e("ul",[e("li",[e("p",[t._v("（1) 请求方法是以下三种方法之一：")]),e("ul",[e("li",[t._v("HEAD")]),e("li",[t._v("GET")]),e("li",[t._v("POST")])])]),e("li",[e("p",[t._v("（2）HTTP的头信息不超出以下几种字段：")]),e("ul",[e("li",[t._v("Accept")]),e("li",[t._v("Accept-Language")]),e("li",[t._v("Content-Language")]),e("li",[t._v("Last-Event-ID")]),e("li",[t._v("Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain")])])])])]),e("li",[e("p",[t._v("基本流程")]),e("ul",[e("li",[e("p",[t._v("（1）对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。")]),e("ul",[e("li",[t._v("上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。")])])]),e("li",[e("p",[t._v("（2）如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。")])]),e("li",[e("p",[t._v("（3）如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。")]),e("ul",[e("li",[e("p",[t._v("上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。")]),e("ul",[e("li",[e("p",[t._v("（1）Access-Control-Allow-Origin")]),e("ul",[e("li",[t._v("该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。")])])]),e("li",[e("p",[t._v("（2）Access-Control-Allow-Credentials")]),e("ul",[e("li",[t._v("该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。")])])]),e("li",[e("p",[t._v("（3）Access-Control-Expose-Headers")])])])])])])])])])]),e("li",[e("p",[t._v("非简单请求（not-so-simple request）")]),e("ul",[e("li",[e("p",[t._v("满足条件")]),e("ul",[e("li",[t._v("非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。")])])]),e("li",[e("p",[t._v("基本流程")]),e("ul",[e("li",[t._v('（1）非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。要求服务器确认可以这样请求。')]),e("li",[t._v("（2）浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。")]),e("li",[t._v('"预检"请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。')])])])])]),e("li",[e("p",[t._v("关于Node.js对于CORS的后端配置")])]),e("li",[e("p",[t._v("实例")]),e("ul",[e("li",[t._v("请注意，代码与之前的区别就在于相对路径换成了其他域的绝对路径，也就是你要跨域访问的接口地址。")])])]),e("li",[e("p",[t._v("总结")])])])]),e("li",[e("p",[t._v("正常的AJAX请求")])])]),e("h2",[t._v("跨域与安全")]),e("h3",[t._v("1.两个误区")]),e("ul",[e("li",[t._v("1.并不是动态请求就会有跨域的问题，跨域只存在于浏览器端，不存在于安卓/ios/Node.js/python/ java等其它环境")]),e("li",[t._v("2.跨域并不是请求发不出去了，跨域请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了")])]),e("h3",[t._v("2.同源策略具体限制些什么呢？")]),e("ul",[e("li",[e("ol",{attrs:{start:""}},[e("li",[t._v("不能向工作在不同源的的服务请求数据（client to server）")])])]),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[t._v("无法获取不同源的document/cookie等BOM和DOM，可以说任何有关另外一个源的信息都无法得到 （client to client）")])])])]),e("h3",[t._v("3.为什么会有同源策略呢？")]),e("ul",[e("li",[e("ol",{attrs:{start:""}},[e("li",[t._v("为什么要限制不同源发请求？")])]),e("ul",[e("li",[t._v("假设用户登陆了bank.com，同时打开了evil.com，如果没有任何限制，evil.com可以向bank.com请求到任何信息，进而就可以在evil.com向bank.com发转账请求等。")])])]),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[t._v("为什么限制跨域的DOM读取？")])]),e("ul",[e("li",[t._v("如果不限制的话，那么很容易就可以伪装其它的网站，如套一个iframe或者通过window.open的方法，从而得到用户的操作和输入，如账户、密码。")])])])]),e("h3",[t._v("4.跨域常用方法【CORS】")]),e("ul",[e("li",[e("p",[t._v("定义")]),e("ul",[e("li",[t._v("只要浏览器检测到响应头带上了CORS，并且允许的源包括了本网站，那么就不会拦截请求响应。")])])]),e("li",[e("p",[t._v("CORS把请求分为两种")]),e("ul",[e("li",[e("p",[t._v("一种是简单请求")])]),e("li",[e("p",[t._v("一种是需要触发预检请求")]),e("ul",[e("li",[e("p",[t._v("条件")]),e("ul",[e("li",[t._v("（1）使用了除GET/POST/HEAD之外的请求方式，如PUT/DELETE")]),e("li",[t._v("（2）使用了除Content-Type/Accept等几个常用的http头")])])]),e("li",[e("p",[t._v("预检请求使用OPTIONS方式去检查当前请求是否安全")]),e("ul",[e("li",[t._v("代码里面只发了一个请求，但在控制台看到了两个请求，第一个是OPTIONS，服务端返回：")]),e("li",[t._v("返回头里面包含了允许的请求头、请求方式、源，以及预检请求的有效期，上图是设置了20天，在这个有效期内就不用再发一个options的请求，实际上浏览器有一个最长时间，如Chrome是5分钟。如果在预检请求检测到当前请求不符合服务端设定的要求，则不会发出去了直接抛异常，这个时候就不用去发“复杂”的请求了。")]),e("li",[t._v("如本源不在允许的源范围内，则会抛异常，无法获取返回结果：")])])])])])])]),e("li",[e("p",[t._v("为了支持CORS，nginx可以这么配")])])]),e("h3",[t._v("5.跨域常用的方法【JSONP】")]),e("ul",[e("li",[e("p",[t._v("原理")]),e("p",[t._v('当需要通讯时，本站脚本创建一个<script>元素，地址指向第三方的API网址，形如：    script src="http://www.example.net/api?param1=1" /script      并提供一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。     第三方产生的响应为json数据的包装（故称之为jsonp，即json padding），形如：     callback({"name":"hax","gender":"Male"})     这样浏览器会调用callback函数，并传递解析后json对象作为参数。本站脚本可在callback函数里处理所传入的数据。')]),e("p",[t._v(" ")]),e("ul",[e("li",[t._v("JSONP是利用了script标签能够跨域， jsonp本身就是一个get请求，而script节点本身也是一个get请求")]),e("li",[t._v('凡是拥有"src"这个属性的标签都拥有跨域的能力，比如<script>、'),e("img"),t._v("、<iframe>")]),e("li",[t._v("代码先定义一个全局函数，然后把这个函数名通过callback参数添加到script标签的src，script的src就是需要跨域的请求，然后这个请求返回可执行的JS文本：")]),e("li",[t._v("由于它是一个js，并且已经定义了upldateList函数，所以能正常执行，并且跨域的数据通过传参得到。这就是JSONP的原理。")])])]),e("li",[e("p",[t._v("跨站请求伪造（CSRF）")]),e("ul",[e("li",[e("p",[t._v("原理")]),e("ul",[e("li",[t._v("由于script/iframe/img等标签的请求默认是能带上cookie（cookie里面带上了登陆验证的票token），用这些标签发请求是能够绕过同源策略的，因此就可以利用这些标签做跨站请求伪造（CSRF）")]),e("li",[t._v("如果相应的网站支持GET请求，或者没有做进一步的防护措施，那么如果用户在另外一个页面登陆过了，再打开一个“有毒”的网站就中招了")])])])])])]),e("h3",[t._v("6.总结及注意")]),e("ul",[e("li",[e("p",[t._v("注意")]),e("ul",[e("li",[e("p",[t._v("1.子域如mail.hello.com要跨hello.com的时候，可以显式地设置子域的document.domain值为父域的domain（或多个子域互相读取cookie）：")]),e("ul",[e("li",[t._v("这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。")])])]),e("li",[e("p",[t._v("2.websocket是不受同源策略限制的，没有跨域的问题。")])]),e("li",[e("p",[t._v("3.CSS的字体文件是会有跨域问题，指定CORS就能加载其它源的字体文件（通常是放在cdn上的）。")])]),e("li",[e("p",[t._v("4.canvas动态加载的外部image，也是需要指定CORS头才能进行图片处理，否则只能画不能读取。")])]),e("li",[e("p",[t._v("5.还可以通过window.name来实现跨域")]),e("ul",[e("li",[t._v("在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。")])])])])]),e("li",[e("p",[t._v("总结")]),e("ul",[e("li",[t._v("跨域分为两种，一种是跨域请求，另一种访问跨域的页面，跨域请求可以通过CORS/JSONP等方法进行访问，跨域的页面主要通过postMesssage的方式。由于跨域请求不但能发出去还能带上cookie，所以要规避跨站请求伪造攻击的风险，特别是涉及到钱的那种请求。")])])])])])}],an={},rn=an,sn=Object(v["a"])(rn,nn,en,!1,null,"5b30c35b",null),on=sn.exports,ln=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{},[e("q-markdown",{attrs:{src:t.MainComponent}})],1)},cn=[],pn="# bom\n\n## BOM浏览器对象模型\n\n### 提供很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关\n\n### BOM的核心对象：windows对象\n\n- 全局作用域\n\n\t- 即是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象。\n\t- 所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法\n\t- 全局变量不能通过delete操作符删除，而直接在window对象上定义的属性可以\n\n- 窗口关系及框架\n\n\t- 如果页面中包含框架，则每个框架都拥有自己的window对象\n\t- 在frames集合中可以通过数值索引（从0开始从左到右从上到下排序）或框架名称来访问window对象\n\t- top对象始终指向最外层的框架，即浏览器窗口\n\n\t\t- top.frames[ 1]\n\n\t- window对象指向所在框架的特定实例\n\n\t\t- window.frame[ 1]\n\n\t- parent对象指向当前框架的直接上层框架\n\t- self对象始终指向window，可以和window对象互换使用\n\n- 窗口位置\n\n\t- 确定和修改window对象位置\n\n\t\t- 跨浏览器取得窗口左边和上边的位置\n\n\t\t\t- screenLeft和screenRight属性\n\n\t\t\t\t- IE/Safari/Opera/Chrome\n\n\t\t\t- screenX和screenY属性\n\n\t\t\t\t- FireFox/Safari/Chrome\n\n\t\t- 精确移动窗口位置\n\n\t\t\t- moveTo()方法\n\n\t\t\t\t- 新位置的x, y坐标值\n\n\t\t\t\t\t- window.movwTo(200, 300)\n\n\t\t\t- moveBy()方法\n\n\t\t\t\t- 接受在水平和垂直方向上移动的像素值两个参数\n\n\t\t\t\t\t- window.movwBy(-50, 100)\n\n\t\t\t- moveBy()和moveTo()都可能被浏览器禁用且不适用于框架，只能对最外层window对象使用\n\n- 窗口大小\n\n\t- 跨浏览器确定窗口大小\n\n\t\t- IE9+/FireFox/Safari/Opera/Chrome\n\n\t\t\t- innerWidth/innerHeight/outerWidth/outerHeight四个属性\n\t\t\t- outerWidth/outerHeight\n\n\t\t\t\t- IE9+/FireFox/Safari中返回浏览器窗口本身尺寸\n\t\t\t\t- Opera中表示页面视图容器大小\n\n\t\t\t- innerWidth/innerHeight\n\n\t\t\t\t- 页面视图区大小（减去边框宽度）\n\n\t- 调整浏览器窗口大小\n\n\t\t- resizeTo()方法\n\n\t\t\t- 接受浏览器窗口的新高度和宽度两个参数\n\n\t\t- resizeBy()方法\n\n\t\t\t- 接受浏览器新窗口的高度和宽度之差两个参数\n\n\t\t- resizeBy()和resizeTo()都可能被浏览器禁用且不适用于框架，只能对最外层window对象使用\n\n- 导航和打开窗口\n\n\t- window.open()方法\n\n\t\t- 打开新的浏览器窗口或导航到特定url\n\t\t- 接受四个参数：要加载的URL、窗口目标、一个特性字符串和一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值\n\t\t- 弹出窗口\n\n\t\t\t- window.open(\"http://……\", \"topFrame\")\n\n\t\t\t\t- 有名为topFrame的框架或窗口则在其中加载这个URL\n\t\t\t\t- 若无则创建新窗口并命名为topFrame\n\t\t\t\t- 第二个参数可以是 _self/_parent/_top/_blank\n\n\t\t\t- 第二个参数不是已存在框架或窗口\n\n\t\t\t\t- 根据第三个参数创建新窗口或标签页\n\n\t\t\t\t\t- 无第三个参数则打开全部默认设置的新窗口\n\n\t\t\t\t- 不打开新窗口则忽略第三个参数\n\n\t\t\t- 有的浏览器默认不允许针对主浏览器窗口调整大小或移动位置，但允许对通过window.open()创建的窗口调整\n\t\t\t- .opener属性保存打开window对象的原始窗口对象\n\n\t\t\t\t- var wroxWin=window.open('#', 'wropWindow'); alert(wropWin.opener==window;) //true\n\n\t\t- 安全限制：许多浏览器限制弹出窗口的实现配置\n\t\t- 弹出窗口屏蔽程序\n\n\t\t\t- 检测是否被屏蔽\n\n- 间歇调用和超时调用\n\n\t- 超时调用\n\n\t\t- 指定的时间过后执行代码\n\t\t- 使用window对象的setTimeout()方法\n\n\t\t\t- 两个参数：要执行的参数，以毫秒表示的时间\n\n\t\t\t\t- setTimeout(function(){ alert(\"hello\");}, 1000);\n\t\t\t\t- 第二个参数表示过多久把当前任务添加到队列中，若队列不为空则等前面代码执行完了执行\n\n\t\t\t- 返回一个数值ID表示超时调用，可通过此ID取消超时调用\n\n\t\t\t\t- ClearTimeout(timeoutId);\n\n\t- 间歇调用\n\n\t\t- 按照指定时间间隔重复执行代码\n\t\t- setInterval()方法\n\n\t\t\t- 使用方法与setTimeout()方法相同\n\n\t\t- 开发环境下后一个间歇调用可能会在前一个间歇调用结束之前启动。所以一般使用超时调用，很少使用间歇调用\n\n- 系统对话框\n\n\t- 浏览器调用系统对话框方法：alert()/confirm()/prompt()\n\n\t\t- 打开的对话框是同步和模态的，打开时代码会停止执行\n\n\t- 与网页无关，不包含HTML，由操作系统和浏览器设置决定外观\n\t- alert()方法一般显示警告信息，只有确定按钮\n\t- confirm()方法有确认和取消按钮，返回true和false值\n\t- prompt()方法生成提示框，可以输入文本\n\n\t\t- 接受要显示给用户的文本提示和文本输入域默认值两个参数\n\t\t- 单击ok返回文本输入域值，单击cancel返回null\n\n\t- 通过javascript可以打开查找和打印对话框\n\n\t\t- window.print(); window.find();\n\n### location对象\n\n- 提供与当前窗口中加载文档有关信息和一些导航功能\n- 即是window对象又是document对象\n- 将URL解析为独立片段，开发人员可以通过不同属性访问这些片段\n\n\t- hash属性\n\n\t\t- 返回URL中的hash（#后跟0或多个字符）\n\n\t- host属性\n\n\t\t- 返回服务器名称和端口号\n\n\t- hostname属性\n\n\t\t- 返回不带端口号的服务器名称\n\n\t- href属性\n\n\t\t- 返回当前加载页面完整URL\n\n\t- ……\n\n- 查询字符串参数\n- 位置操作\n\n\t- 改变浏览器位置并生成新历史记录\n\n\t\t- assign()方法\n\n\t\t\t- location.assign('URL');\n\t\t\t- 将location.href或window.location设置为一个URL也会调用assign()方法\n\n\t\t- 修改location对象的其他属性也可以改变当前加载页面\n\t\t- 使用replace()方法不会在历史记录中生成新纪录，用户无法回到前一个页面\n\t\t- reload()方法重新加载当前页面\n\n\t\t\t- location.reload(true); 强制从服务器重新加载\n\t\t\t- 位于reload()方法之后的代码受网络延迟或系统资源因素影响可能不会执行，一般将其放在代码最后一行\n\n### navigator对象\n\n- 提供客户端浏览器信息，是识别客户端浏览器的事实标准\n- 检测插件\n\n\t- 非IE浏览器：使用plugins数组\n\n\t\t- 数组属性\n\n\t\t\t- name，插件名字\n\t\t\t- description：插件描述\n\t\t\t- filename：插件文件名\n\t\t\t- length：插件所处理的MIME类型数量\n\n\t\t- hasPlugin()函数\n\n\t\t\t- 接受要检测的插件名作为参数\n\t\t\t- 可以在FireFox/Opera/Safari/Chrome中使用这种方法\n\n\t- IE浏览器\n\n\t\t- 使用专有ActiveXObject类型并尝试创建一个特定插件的实例\n\n\t\t\t- IE使用COM对象方式实现插件\n\n\t\t\t\t- COM对象使用唯一标识符来标识\n\n\t\t\t- hasIEPlugin()函数\n\n\t\t\t\t- 接收一个COM标识符为参数\n\t\t\t\t- 在try-catch语句中进行实例化\n\n\t- 典型做法：针对每个插件分别创建检测函数\n\n- 注册处理程序\n\n\t- FireFox2为navigator对象新增registerContentHandler()和registerProtocolHandler()方法\n\n\t\t- 可以让一个站点指明它可以处理的特定类型的信息\n\n\t- registerContentHandler()方法\n\n\t\t- 三个参数：要处理的MIME类型、可以处理该类型的页面的URL、应用程序名称\n\n\t- registerProtocolHandler()方法\n\n\t\t- 三个参数：要处理的协议、处理该协议的页面的URL、应用程序名称\n\n### screen对象\n\n- 基本上只用于表明客户端的能力\n\n\t- 包括浏览器窗口外部显示器信息如像素宽度和高度等\n\n- 每个浏览器中的screen对象包含不同属性\n- 有时用于调整浏览器窗口大小\n\n### history对象\n\n- 保存用户上网的历史记录\n\n\t- 因为history对象是window对象的属性，所以每个浏览器窗口、标签页乃至每个框架都有自己的history对象与特定window对象关联\n\t- 出于安全考虑，开发者无法得知用户浏览过的URL\n\n- go()方法\n\n\t- 可以在用户历史记录中任意跳转，向前或向后\n\t- 接受表示向前或向后跳转的页面数的整数值作为一个参数\n\n\t\t- history.go(-1); 后退一页\n\t\t- history.go(2); 前进两页\n\n\t- 接受一个字符串作为参数跳转到最近的包含该字符串的位置\n\n\t\t- history.go('wrox.com'); 可能前进或后退\n\n\t- back()/forword()方法代替go()，后退或前进一步\n\n- length属性\n\n\t- 检测当前页面是不是用户历史记录中第一个页面\n\n\t\t- if (history.length==0){};\n\n## BOM\n\n### 说明：window对象上面的属性和方法\n\n### 方法\n\n- 1.onload\n\n\t- 页面加载完（等在静态资源加载完成），才执行这个函数\n\n- 2.定时器\n\n\t- 一次性定时器\n\n\t\t- 1.setTimeout:（函数，毫秒数）\n\n\t\t\t- 返回值：返回这个定时器的id\n\n\t\t- 2 clearTimeout（定时器的id） 停止\n\n\t- 永久性定时器\n\n\t\t- 1.setInterval：（函数，毫秒数）\n\n\t\t\t- 返回值：返回这个定时器的id\n\n\t\t- 2 clearInterval（定时器的id） 清除永久定时器\n\n- 3.location\n\n\t- 负责管理浏览器地址相关的行为和信息的对象\n\n\t\t- 例：window.location.href = \"http://www.baidu.com\"\n\n- 4.localStorage\n\n\t- 实现数据本地化，刷新后还在\n\t- 1.setItem(键，值)\n\t- 2.getItem（键）------没有值，返回null\n\t- 3.removeItem（键）\n\t- 4.clear() 清除全部\n\n- 5.JSON\n\n\t- 介绍：\n\n\t\t- 1.本质是有一定格式的字符串\n\t\t- 2.BOM上的方法\n\n\t- 方法：\n\n\t\t- 1.JSON.stringify(对象);\n\n\t\t\t- 把对象转为字符串\n\n\t\t- 2.JSON.parse(json格式字符串);\n\n\t\t\t- JSON格式的字符串转为对象\n\n",bn={data:function(){return{MainComponent:pn}}},un=bn,vn=Object(v["a"])(un,ln,cn,!1,null,"781ba51c",null),gn=vn.exports,mn=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{},[e("q-markdown",{attrs:{src:t.MainComponent}})],1)},_n=[],dn='# dom\n\n## DOM事件机制\n\n### 事件代理（委托）\n\n- 由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。\n\n  - 减少内存消耗，提高性能\n  - 动态绑定事件\n\n### Event对象常见应用\n\n- event.preventDefault\n\n  - 默认事件行为将不会触发\n\n- event.stopPropagation\n\n  - 阻止事件冒泡到父元素，阻止任何父事件处理程序被执行。\n\n- stopImmediatePropagation\n\n  - 既能阻止事件向父元素冒泡，也能阻止元素同事件类型的其它监听器被触发。\n\n- event.target & event.currentTarget\n\n  - event.target\n\n    - 指向引起触发事件的元素\n\n      - 一个目标元素\n\n  - event.currentTarget\n\n    - 返回绑定事件的元素\n\n      - 目标元素+冒泡经过元素\n\n  - 包含所有与事件有关的信息\n  - this始终等于currentTarget的值\n\n### DOM事件模型和事件流\n\n- 事件模型\n\n  - 捕获\n  - 冒泡\n\n- 事件传播\n\n  - 捕获阶段\n  - 目标阶段\n  - 冒泡阶段\n\n### DOM事件级别\n\n- DOM0级事件\n\n  - 不允许给一个元素绑定多个事件\n  - 事件方法在事件行为的冒泡阶段执行\n\n- DOM2级事件\n\n  - IE9以上\n\n    - addEventListener\n\n      - event-name\n\n        - 事件名称\n\n      - callback\n\n        - 回调函数，参数为当前事件对象event\n\n      - useCapture\n\n        - 默认是false，代表事件句柄在冒泡阶段执行\n\n    - removeEventListener\n\n      - 绑定的函数最好是声明函数变量，这样才能将同一个函数传入\n\n    - 事件程序作用域是依附元素作用域\n\n  - IE9以下\n\n    - attachEvent\n    - detachEvent\n\n      - 绑定的函数最好是声明函数变量，这样才能将同一个函数传入\n\n    - 第一个事件名称前要加on。\n    - 因为IE9以下是不支持事件捕获的，所以也没有第三个参数。\n    - 事件处理程序的作用域是全局作用域\n\n- DOM3级事件\n\n  - UI事件\n\n    - load\n    - sroll\n\n  - 焦点事件\n\n    - blur\n    - focus\n\n  - 鼠标事件\n\n    - dblclick\n    - mouseup\n\n  - 滚轮事件\n\n    - mousewheel\n\n  - 文本事件\n\n    - textInput\n\n  - 键盘事件\n\n    - keydown\n    - keypress\n\n  - 合成事件\n\n    - compositionstart\n\n  - 变动事件\n\n    - DOMsubtreeModified\n\n  - 自定义事件\n\n## DOM\n\n### 1.获取DOM\n\n- 1.节点(元素对象，DOM节点)\n\n  - 1.返回DOM节点\n\n    - 1.getElementById("id名")\n    - 2.querySelector("CSS名")\n\n  - 2.返回伪数组\n\n    - 1.getElementByTagName("标签名")\n    - 2.getElementByClassName（"类名"）\n    - 3.querySelectorAll("CSS名")\n\n- 2.DOM样式\n\n  - 1.dom.style.color\n\n    - 1.DOM只能操作行内样式\n\n  - 2.window.getComputedStyle(box)  括号中填写元素对象，DOM节点，\n\n    - 1.返回的属性值为字符串\n    - 2.返回所有（无论是行内还是非行内）的样式集合/对象\n\n### 2.注册事件\n\n- 1.点击事件（元素对象，DOM节点）\n\n  - click\n\n- 2.焦点事件\n\n  - focus\n\n    - 获取焦点\n\n      - 注册给有光标的标签\n\n  - blur\n\n    - 失去焦点\n\n      - 注册给有光标的标签\n\n- 3.鼠标事件\n\n  - mousedown\n\n    - 鼠标点下\n\n  - mousemove\n\n    - 鼠标移动\n\n  - mouseup\n\n    - 鼠标松开\n\n  - mouseover《==》mouseenter\n\n    - 鼠标移入，后者不支持冒泡\n\n  - mouseout《==》mouseleave\n\n    - 鼠标移除，后者不支持冒泡\n\n- 4.键盘事件\n\n  - keydown\n\n    - 按键按下\n\n  - keyup\n\n    - 按键抬起\n\n- 5.滚动事件\n\n  - scroll 当元素滚动的时候执行\n\n- 6.动画结束后触发事件（只能用addEventListener）\n\n  - 1.transitionend\n\n    - 元素过度结束时执行\n\n  - 2.animationed\n\n    - 元素帧动画结束时执行\n\n- 7.触摸事件（移动端）\n\n  - 1.touch（刚刚触摸）\n  - 2.touchmove（手指滑动）\n  - 3.touchend（手指离开）\n\n- 8.存在多次注册事件，容易被后者覆盖，解决方法：\n\n  - 例：btn.addEventListener("click",function()\n   console.log(1);\n)\n\n### 3.属性\n\n- 1.自定义属性\n\n  - 说明：把数据存储到对应元素的身上使用的属性，没有特别功能，仅是需要，返回值是 对象\n  - 1.用法\n\n    - 1.定义： data-  开头的\n    - 2.取值：例如：console.log(dom_div.dataset.name)\n\n- 2.相关方法（推荐用于自定义属性操作）\n\n  - 1.getAttribute("属性名称") -----获取\n  - 2.setAttribute("属性名","属性值")-----设置\n  - 3.removeAttribute("属性名称")------删除\n\n- 3.标准属性\n\n  - 说明：html中出现的，具有特别功能的属性\n  - 1.ckecked\n\n    - 说明：开关属性，只有两种状态的属性\n\n  - 2.class\n\n    - 1.className\n    - 2.classList(类名)\n\n      - 1.add（新增）\n      - 2.remove(移除)\n      - 3.toggle（切换类名）\n\n  - 3.style\n\n    - 例如：img-src，a-href，id，class等\n\n  - 4.value\n  - 5.src\n  - 6.disabled\n\n    - 按钮是否被禁用\n\n- 4.获取\n\n  - 1.父元素.children\n\n    - 获取子元素：可以得到某个元素之下的所有的子元素的集合，一个伪数组\n\n  - 2.父元素 childNodes\n\n    - 获取子元素：可以得到所有的子元素，\n    - 需要注意的是，<ul>\n       <li></li>\n    <ul>\n会得到 text,li，text\n\n  - 3.元素.parentNode\n\n    - 获取父元素：返回一个\n\n  - 4.元素.firstElementChild\n\n    - 获取第一个子元素\n\n  - 5.元素.lastElementChild\n\n    - 获取最后一个子元素\n\n  - 6.获取兄弟元素\n\n    - 1.元素.nextElementSibling  -  得到下一个兄弟元素\n    - 2.元素.previousElementSibling - 得到上一个兄弟元素\n\n### 4.创建\n\n- 1.innerHTML\n\n  - 1.设置html结构    2.会覆盖\n\n- 2.document.write()\n\n  - 会覆盖\n\n- 3.document.createElement()\n\n  - 创建标签节点\n\n- 4.document.createAttribute(元素属性)\n\n  - 创建属性节点\n\n- 5.document.createTextNode(文本内容)\n\n  - 创建文本节点\n\n- 6.insertAdjacentHTML(\'位置\',Html结构)\n\n### 5.修改\n\n- 1.innerHTML   结构\n- 2.innerText  文本内容\n\n### 6.添加\n\n- 父节点 .appendChild(新DOM节点)：从后添加新的DOM节点\n- 父节点 .insertBefore(新的DOM节点，插入之前的DOM节点)，在某个子元素之前，添加新的DOM节点\n\n### 7.其他操作\n\n- 1.替换元素\n\n  - 父节点.replaceChild(新的节点,旧的子节点)\n\n- 2.克隆元素\n\n  - 元素.cloneNode(true或false);  返回一份新的克隆后的元素\n\n### 8.innerText和textContent比较\n\n- 相同点：\n\n  - 获取的都是Text文本\n\n- 不同点：\n\n  - 1.innerText基本没有兼容问题/textContent属性在ie低版本中不支持\n  - 2.innerText（野路子，但是兼容性好,推荐使用）/textContent标准属性（官宣）\n\n## 事件\n\n### 1.事件三要素\n\n- 1.事件源\n\n  - 被触发的元素\n\n- 2.事件类型\n\n  - 如何触发的事件\n\n- 3.事件处理程序\n\n  - 事件发生后的结果\n\n### 2.事件的三个阶段（事件流）\n\n- 1.捕获\n\n  - 从根部往目标DOM节点上，一层一层的找，捕获是用户点击了那个DOM节点。\n\n- 2.到达目标\n- 3.冒泡\n\n  - 从目标节点到根节点\n\n- 冒泡执行\n\n  - 事件默认是在冒泡阶段执行；当我们目标DOM节点注册了事件，冒泡往上的DOM节点也注册了同样的事件话，也会执行\n\n### 3.事件对象\n\n- 说明：一个集合体，用来描述点击的行为(点击位置，点击了谁，注册给谁)\n- 1.clientX/Y 相对于当前窗口\n- 2.pageX/Y 相对于body左上角\n- 3.target 点击了那个DOM节点，返回哪个DOM节点\n- 4.currenTarget 返回事件源（事件源：事件给谁注册了，这就是那个源头）\n- 5.offset系列\n\n  - 1.offsetLeft\n\n    - box距左的距离\n\n      - 找参考的父亲，父辈元素没有定位，继续往上找，直至body\n\n  - 2.offsetTop\n\n    - box距上的距离\n\n      - 找参考的父亲，父辈元素没有定位，继续往上找，直至body\n\n  - 3.offsetWidth\n\n    - 获取DOM节点的宽度\n\n  - 4.offsetHeight\n\n    - 获取DOM节点的高度\n\n- 6.可视区域（padding+content）\n\n  - 1.元素.clientHeight\n  - 2.元素.clientWidth\n\n- 5.触摸点\n\n  - 1.对象.touches(屏上面的触摸点)\n  - 2.对象.targetTouches(元素上面的触摸点)\n  - 3.对象.changedTouches（变化的触摸点）\n\n- 6.阻止冒泡（为了更好的用户体验）\n\n  - 1.例：btn.addEventListener(\'click\',function(e)){\n  e.stopPropagation();\n}\n  - 2.canceBubble（） --------只支持IE\n\n- 7.阻止默认行为：（e.prventDefault()）\n\n  - 1.禁止鼠标右键  \n例: document.oncontextmenu = function(e){\n      e.prventDefault()\n}\n  - 2.a标签跳转等\n\n    - 1.（也可以使用 return false）\n    - 2. javascript:void(0)\n\n### 4.事件解绑\n\n- 1. 例：begin.onclick = null；\n- 2.例：begin.removeEventListener("click",fn)\n\n### 5.事件委托\n\n- 1.把事件注册在父级的元素上\n- 2.利用事件冒泡执行，当事件传播到已经注册了事件的父级元素身上\n- 3.判断触发事件DOM(e.target)节点是否是指定的元素 例:e.target.nodeName ==\'li\'\n\n  - 若是 则继续\n  - 若不是 则什么都不做\n\n## 【DOM相关】JavaScript获取元素的位置与尺寸\n\n### （1）获取元素的尺寸\n\n- 0. 【elem.style.width（可写）】CSS写入的宽高\n\n  - jQuery-【$().width()】\n\n- 1.【clientHeight】内宽高—— 内边距 + 内容框（如果有滚动条，还需要减去滚动条的宽度）\n\n  - jQuery-【$().innerwidth()】\n\n- 2.【offsetHeight】 外宽高—— 边框 + 内边距 + 内容框\n\n  - jQuery-【$().outerwidth()】\n\n- 3.【scrollHeight】 用来计算可滚动容器的大小，包括不可见的部分，当然，scrollHeight 的值需要加上 padding 的值。\n\n  - 例子\n\n    - 图\n\n    - 解释\n\n      - 此时滚动条的宽度是 17px，根据前面的介绍，滚动条时占用 padding 和 content 宽度的，而 17px 大于 padding 的 10px，故还有 7px 会占据 content。\n      - 分析一下，offsetHeight 的值是 124，padding 10px，滚动条虽然存在，但是占了 padding 和内容的空间，offsetHeight 的值是 4+20+76 = 124px。scrollHeight 的值是可滚动的范围加上padding 值，同样不包括滚动条，即 150+20 = 170px。clientHeight 的值是可见区域，但是不包括滚动条的值（滚动条。。。），所以20+100-17 = 79px。\n      - 其实也不是非常复杂。这个时候可以得出滚动条宽度的计算：offsetHeight 减去 border 和 clientHeight 的和就是滚动条宽度。\n\n- 4.【getComputedStyle】获取元素内容的尺寸（最终计算后的结果）\n\n  - 使用\n\n    - window.getComputedStyle(ele， boolean)\n    - document.defaultView.getComputedStyle(ele， boolean)\n    - window.getComputedStyle(elem, null).getPropertyValue("height")\n    - 接受两个参数：要取得计算样式的元素和一个伪元素字符串（例如“:after”）。如果不需要伪元素信息，第二个参数可以是null。getComputerStyle()方法返回一个CSSStyleDeclaration对象，其中包含当前元素的所有计算的样式。\n\n  - 图\n\n  - 注意\n\n    - 在有滚动条的情况下，该属性返回的宽高为，CSS宽高减去滚动条的宽高\n\n  - 延伸\n\n    - getComputedStyle会引起回流，因为它需要获取祖先节点的一些信息进行计算（譬如宽高等），所以用的时候慎用，回流会引起性能问题。然后合适的话会将话题引导回流，重绘，浏览器渲染原理等等。当然也可以列举一些其它会引发回流的操作，如offsetXXX，scrollXXX，clientXXX，currentStyle等等\n\n  - 与elem.style的区别\n\n- 5.【elem.getBoundingClientRect()】获取元素宽高 等同于 offsetHeight——边框 + 内边距 + 内容框\n\n### （2）获取元素的位置\n\n- 1.【elem.getBoundingClientRect()】只读、相对于视口（浏览器窗口）\n\n  - 方法返回元素的大小及其相对于视口的位置。返回值是一个 DOMRect 对象\n  - DOMRect 对象包含了一组用于描述边框的只读属性——left、top、right和bottom，单位为像素。除了 width 和 height 外的属性都是相对于视口的左上角位置而言的\n  - 图\n\n  - 绝对位置-相对于当前document元素的位置-jQuery 【$().offset().top】\n\n    - 再加上滚动距离，就可以得到绝对位置（不管页面怎么滚动永远为元素离文档的距离）\n    - 注意\n\n      - 页面指定了DTD，即指定了DOCTYPE时，使用document.documentElement。\n      - 页面没有DTD，即没指定DOCTYPE时，使用document.body。\n\n  - 此处的left与top指的是position的left和top加上元素的margin，即指的是元素的边框距离浏览器窗口的值，如没有定位，那么即为元素margin的值\n\n- 2.【elem.offsetTop（可写）】子元素距离父元素的距离，即子元素的边框到父元素的边框的距离（子元素的margin + 父元素的padding）\n\n### （3）获取客户端以及屏幕高度\n\n- （1）screen.width\n\n  - 显示器的水平方向的像素时，不随着我们浏览器窗口的变化而变化，是用设备像素衡量的\n\n- （2）window.innerWidth\n\n  - window.innerWidth指的是浏览器窗口的宽度，是可以变化的，所以使用的是CSS像素\n  - 100%缩放下\n\n    - 可以发现在100%缩放情况下，window.innerWidth的值为1192，window.innerHeight的值为455\n\n  - 200%缩放下\n\n    - 因为window.innerWidth是用CSS像素衡量的，放大两倍之后，浏览器窗口只能看到之前一半的内容，所以window.innerWidth是之前的一半\n\n- （3）document.documentElement.clientWidth\n\n  - 指的是网页可见区域高的宽度，与window.innerWidth的区别就只差了一个滚动条（不包含滚动条）\n\n- （4）document.documentElement.offsetWidth\n\n  - 取得html标签的宽度\n  - 与clientwidth的区别\n\n    - 看到没document.documentElement.offsetHeight此时为0，我打开调试定位了下，发现此时html高度确实是为0，而document.documentElement.clientHeight此时为455，是viewport的高度，只不过此时viewport的高度和window.innerHeight相等\n\n- （5）document.documentElement.scrollHeight\n\n  - 网页正文全文高\n\n- （6）document.documentElement.scrollTop\n\n  - 网页被卷去的高\n\n### （4）移动端的三个viewport理论\n\n- layout viewport\n\n  - 介绍\n\n    - 布局layout，和PC端的viewport很像，PC端的viewport的宽由浏览器窗口的宽决定的，用户可以通过拖动窗口或者缩放改变viewport的大小，但是在移动端则不同，在IOS中layout viewport默认大小980px，在android中layout viewport为800px，很明显这两个值都大于我们浏览器的可视区域宽度。我们可以通过document.documentElement.clientWidth来获取layout viewport的宽度\n\n  - 直观\n\n- visual viewport\n\n  - 介绍\n\n    - 有了layout viewport，我们还需要一个viewport来表示我们浏览器可视区域的大小，这个就是visual viewport。visual viewport的宽度可以通过window.innerWidth获取\n    - 移动端浏览器为了不让用户通过缩放和滑动就能看到整个网页的内容，默认情况下会将visual viewport进行缩放到layout viewport一样大小，这也就解释了为什么PC端设计的网页在手机上浏览会缩小，其实这是跟移动浏览器默认的行为有关系\n\n  - 直观\n\n- ideal viewport\n\n  - 设备理想viewport，有以下几个要求：\n\n    - 用户不需要缩放和滚动条就能查看所有内容\n    - 文字大小合适，不会因为在高分辨率手机下就显示过小而看不清，图片也一样\n\n  - 这个viewport就叫做ideal viewport。但是不同的设备的ideal viewport不一样，有320px，有360px的，还有384px的......\n  - 如何获得\n\n    - （1）layout viewport能被设置成ideal viewport。width=device-width和initial-scale=1指令可以做到。\n    - （2）所有的scale指令都是相对于ideal viewport的。无视layout viewport设置了多少，所以maximum-scale=3意味着最大的缩放值是ideal viewport的300%\n\n\n',hn={data:function(){return{MainComponent:dn}}},fn=hn,yn=Object(v["a"])(fn,mn,_n,!1,null,"20c352b0",null),Sn=yn.exports,wn=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{},[e("q-markdown",{attrs:{src:t.MainComponent}})],1)},kn=[],xn='# 浏览器\n\n## 从输入URL到页面加载的过程\n\n### 多进程的浏览器\n\n- 浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程）\n\n进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等\n\n\t- Browser进程：浏览器的主进程（负责协调、主控），只有一个\n\t- 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建\n\t- GPU进程：最多一个，用于3D绘制\n\t- 浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）\n\n- 多线程的浏览器内核\n\n\t- 每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程\n\n\t\t- GUI线程\n\t\t- JS引擎线程\n\t\t- 事件触发线程\n\t\t- 定时器线程\n\t\t- 网络请求线程\n\n### 解析URL\n\n- 输入URL后，会进行解析（URL的本质就是统一资源定位符）\n\n\t- URL一般包括几大部分：\n\n\t\t- protocol，协议头，譬如有http，ftp等\n\t\t- host，主机域名或IP地址\n\t\t- port，端口号\n\t\t- path，目录路径\n\t\t- query，即查询参数\n\t\t- fragment，即#后的hash值，一般用来定位到某个位置\n\n\t- 网络请求都是单独的线程\n\n\t\t- 每次网络请求时都需要开辟单独的线程进行，譬如如果URL解析到http协议，就会新建一个网络线程去处理资源下载\n\n因此浏览器会根据解析出得协议，开辟一个网络线程，前往请求资源（这里，暂时理解为是浏览器内核开辟的，如有错误，后续修复）\n\n### 开启网络线程到发出一个完整的http请求\n\n- DNS查询得到IP\n\n\t- 如果输入的是域名，需要进行dns解析成IP，大致流程：\n\n\t\t- 如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host\n\t\t- 如果本地没有，就向dns域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的IP\n\n- tcp/ip请求\n\n\t- http的本质就是tcp/ip请求\n\n\t\t- tcp将http长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输\n\n\t\t\t- 三次握手的步骤：（抽象派）\n\n\t\t\t\t- 客户端：hello，你是server么？\n服务端：hello，我是server，你是client么\n客户端：yes，我是client\n\t\t\t\t- 建立连接成功后，接下来就正式传输数据\n\n\t\t- 待到断开连接时，需要进行四次挥手（因为是全双工的，所以需要四次挥手）\n\n\t\t\t- 四次挥手的步骤：（抽象派）\n\n\t\t\t\t- 主动方：我已经关闭了向你那边的主动通道了，只能被动接收了\n被动方：收到通道关闭的信息\n被动方：那我也告诉你，我这边向你的主动通道也关闭了\n主动方：最后收到数据，之后双方无法通信\n\n\t- tcp/ip的并发限制\n\n\t\t- 浏览器对同一域名下并发的tcp连接是有限制的（2-10个不等）\n\n而且在http1.0中往往一个资源下载就需要对应一个tcp/ip请求\n\n所以针对这个瓶颈，又出现了很多的资源优化方案\n\n\t- get和post的区别\n\n\t\t- get和post虽然本质都是tcp/ip，但两者除了在http层面外，在tcp/ip层面也有区别。\n\nget会产生一个tcp数据包，post两个\n\n\t\t\t- get请求时，浏览器会把headers和data一起发送出去，服务器响应200（返回数据），\n\t\t\t- post请求时，浏览器先发送headers，服务器响应100 continue，\n\t\t\t- 浏览器再发送data，服务器响应200（返回数据）。\n\n- 五层因特网协议栈\n\n\t- 一个概念： 从客户端发出http请求到服务器接收，中间会经过一系列的流程。\n\n\t\t- 从应用层的发送http请求，到传输层通过三次握手建立tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。\n\n当然，服务端的接收就是反过来的步骤\n\n\t- 1.应用层(dns,http) DNS解析成IP并发送http请求\n\n2.传输层(tcp,udp) 建立tcp连接（三次握手）\n\n3.网络层(IP,ARP) IP寻址\n\n4.数据链路层(PPP) 封装成帧\n\n5.物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）\n\n### 从服务器接收到请求到对应后台接收到请求\n\n- 负载均衡\n\n\t- 用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了nginx控制负载均衡），\n然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的HTTP响应，并将它反馈给用户\n\n- 后台的处理\n\n\t- 一般后台都是部署到容器中的，所以一般为：\n\n\t\t- 先是容器接受到请求（如tomcat容器）\n\t\t- 然后对应容器中的后台程序接收到请求（如java程序）\n\t\t- 然后就是后台会有自己的统一处理，处理完后响应响应结果\n\n\t- 概括下：\n\n\t\t- 一般有的后端是有统一的验证的，如安全拦截，跨域验证\n\t\t- 如果这一步不符合规则，就直接返回了相应的http报文（如拒绝请求等）\n\t\t- 然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）\n\t\t- 等程序执行完毕后，就会返回一个http响应包（一般这一步也会经过多层封装）\n\t\t- 然后就是将这个包从后端发送到前端，完成交互\n\n- 后台和前台的http交互\n\n\t- http报文结构\n\n\t\t- 报文一般包括了：通用头部，请求/响应头部，请求/响应体\n\n\t\t\t- 通用头部\n\n\t\t\t\t- 这也是开发人员见过的最多的信息，包括如下：\n\n\t\t\t\t\t- Request Url: 请求的web服务器地址\n\t\t\t\t\t- Request Method: 请求方式（Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）\n\n\t\t\t\t\t\t- HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。\n\t\t\t\t\t\t- HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。\n\n\t\t\t\t\t- Status Code: 请求的返回状态码，如200代表成功\n\n\t\t\t\t\t\t- 200——表明该请求被成功地完成，所请求的资源发送回客户端\n\t\t\t\t\t\t- 304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存\n\t\t\t\t\t\t- 400——客户端请求有错（譬如可以是安全模块拦截）\n\t\t\t\t\t\t- 401——请求未经授权\n\t\t\t\t\t\t- 403——禁止访问（譬如可以是未登录时禁止）\n\t\t\t\t\t\t- 404——资源未找到\n\t\t\t\t\t\t- 500——服务器内部错误\n\t\t\t\t\t\t- 503——服务不可用\n\t\t\t\t\t\t- 1xx——指示信息，表示请求已接收，继续处理\n\t\t\t\t\t\t- 2xx——成功，表示请求已被成功接收、理解、接受\n\t\t\t\t\t\t- 3xx——重定向，要完成请求必须进行更进一步的操作\n\t\t\t\t\t\t- 4xx——客户端错误，请求有语法错误或请求无法实现\n\t\t\t\t\t\t- 5xx——服务器端错误，服务器未能实现合法的请求\n\n\t\t\t\t\t- Remote Address: 请求的远程服务器地址（会转为IP）\n\n\t\t\t- 请求/响应头部\n\n\t\t\t\t- 常用的请求头部（部分）：\n\n\t\t\t\t\t- Accept: 接收类型，表示浏览器支持的MIME类型\n（对标服务端返回的Content-Type）\nAccept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收\nContent-Type：客户端发送出去实体内容的类型\nCache-Control: 指定请求和响应遵循的缓存机制，如no-cache\nIf-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中\nExpires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间\nMax-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中\nIf-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中\nCookie: 有cookie并且同域访问时会自动带上\nConnection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive\nHost：请求的服务器URL\nOrigin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私\nReferer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)\nUser-Agent：用户客户端的一些必要信息，如UA头部等\n\n\t\t\t\t- 常用的响应头部（部分）：\n\n\t\t\t\t\t- Access-Control-Allow-Headers: 服务器端允许的请求Headers\nAccess-Control-Allow-Methods: 服务器端允许的请求方法\nAccess-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）\nContent-Type：服务端返回的实体内容的类型\nDate：数据从服务器发送的时间\nCache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档\nLast-Modified：请求资源的最后修改时间\nExpires：应该在什么时候认为文档已经过期,从而不再缓存它\nMax-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效\nETag：请求变量的实体标签的当前值\nSet-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端\nKeep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）\nServer：服务器的一些相关信息\n\n\t\t\t- 请求/响应实体\n\n\t\t\t\t- http请求时，除了头部，还有消息实体，一般来说\n\n请求实体中会将一些需要的参数都放入进入（用于post请求）。\n\n譬如实体中可以放参数的序列化形式（a=1&b=2这种），或者直接放表单对象（Form Data对象，上传时可以夹杂参数以及文件），等等\n\n而一般响应实体中，就是放服务端需要传给客户端的内容\n\n一般现在的接口请求时，实体中就是对于的信息的json格式，而像页面请求这种，里面就是直接放了一个html字符串，然后浏览器自己解析并渲染。\n\n\t\t\t- CRLF\n\n\t\t\t\t- CRLF（Carriage-Return Line-Feed），意思是回车换行，一般作为分隔符存在\n\n请求头和实体消息之间有一个CRLF分隔，响应头部和响应实体之间用一个CRLF分隔\n\n一般来说（分隔符类别）：\n\nCRLF->Windows-style\nLF->Unix Style\nCR->Mac Style\n\n- cookie以及优化\n\n\t- cookie是浏览器的一种本地存储方式，一般用来帮助客户端和服务端通信的，常用来进行身份校验，结合服务端的session使用。\n\n\t\t- 场景如下（简述）：\n\n\t\t\t- 在登陆页面，用户登陆了\n\n此时，服务端会生成一个session，session中有对于用户的信息（如用户名、密码等）\n\n然后会有一个sessionid（相当于是服务端的这个session对应的key）\n\n然后服务端在登录页面中写入cookie，值就是:jsessionid=xxx\n\n然后浏览器本地就有这个cookie了，以后访问同域名下的页面时，自动带上cookie，自动检验，在有效时间内无需二次登陆。\n\n- gzip压缩\n\n\t- 首先，明确gzip是一种压缩格式，需要浏览器支持才有效（不过一般现在浏览器都支持），\n而且gzip压缩效率很好（高达70%左右）\n\n然后gzip一般是由apache、tomcat等web服务器开启\n\n当然服务器除了gzip外，也还会有其它压缩格式（如deflate，没有gzip高效，且不流行）\n\n所以一般只需要在服务器上开启了gzip压缩，然后之后的请求就都是基于gzip压缩格式的，\n非常方便。\n\n- 长连接与短连接\n\n\t- 首先看tcp/ip层面的定义：\n\n\t\t- 长连接：一个tcp/ip连接上可以连续发送多个数据包，在tcp连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）\n\t\t- 短连接：通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接\n\n\t- 然后在http层面：\n\n\t\t- http1.0中，默认使用的是短连接，也就是说，浏览器没进行一次http操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接\n\t\t- http1.1起，默认使用长连接，使用长连接会有这一行Connection: keep-alive，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输http的tcp连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接\n\n\t-  keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效\n\n- http 2.0\n\n\t- http2.0不是https，它相当于是http的下一代规范（譬如https的请求可以是http2.0规范的）\n\t- 然后简述下http2.0与http1.1的显著不同点：\n\n\t\t- http1.1中，每请求一个资源，都是需要开启一个tcp/ip连接的，所以对应的结果是，每一个资源对应一个tcp/ip请求，由于tcp/ip本身有并发数限制，所以当资源一多，速度就显著慢下来\n\t\t- http2.0中，一个tcp/ip请求可以请求多个资源，也就是说，只要一次tcp/ip请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。\n\n\t- http2.0的一些特性：\n\n\t\t- 多路复用（即一个tcp/ip连接可以请求多个资源）\n\t\t- 首部压缩（http头部压缩，减少体积）\n\t\t- 二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）\n\t\t- 服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）\n\t\t- 请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）\n\n- https\n\n\t- https就是安全版本的http，譬如一些支付等操作基本都是基于https的，因为http请求的安全系数太低了。\n\n\t\t- 简单来看，https与http的区别就是： 在请求前，会建立ssl链接，确保接下来的通信都是加密的，无法被轻易截取分析\n\n\t- SSL/TLS的握手流程，如下（简述）：\n\n\t\t- 1. 浏览器请求建立SSL链接，并向服务端发送一个随机数–Client random和客户端支持的加密方法，比如RSA加密，此时是明文传输。 \n\t\t- 2. 服务端从中选出一组加密算法与Hash算法，回复一个随机数–Server random，并将自己的身份信息以证书的形式发回给浏览器\n（证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息）\n\t\t- 3. 浏览器收到服务端的证书后\n\n\t\t\t- - 验证证书的合法性（颁发机构是否合法，证书中包含的网址是否和正在访问的一样），如果证书信任，则浏览器会显示一个小锁头，否则会有提示\n\t\t\t-     - 用户接收证书后（不管信不信任），浏览会生产新的随机数–Premaster secret，然后证书中的公钥以及指定的加密方法加密`Premaster secret`，发送给服务器。\n\t\t\t-     - 利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key-`session key`\n\t\t\t-     - 使用约定好的HASH算法计算握手消息，并使用生成的`session key`对消息进行加密，最后将之前生成的所有信息发送给服务端。\n\n\t\t- 4. 服务端收到浏览器的回复\n\n\t\t\t- - 利用已知的加解密方式与自己的私钥进行解密，获取`Premaster secret`\n\t\t\t-     - 和浏览器相同规则生成`session key`\n\t\t\t-     - 使用`session key`解密浏览器发来的握手消息，并验证Hash是否与浏览器发来的一致\n\t\t\t-     - 使用`session key`加密一段握手消息，发送给浏览器\n\n\t\t- 5. 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，\n\n- 单独拎出来的缓存问题，http的缓存\n\n\t- 强缓存与弱缓存\n\n\t\t- 缓存可以简单的划分成两种类型：强缓存（200 from cache）与协商缓存（304）\n\n\t\t\t- 区别简述如下：\n\n\t\t\t\t- 强缓存（200 from cache）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求\n\n\t\t\t\t\t- 但是对于强缓存，在未过期时，必须更新资源路径才能发起新的请求（更改了路径相当于是另一个资源了，这也是前端工程化中常用到的技巧）\n\n\t\t\t\t- 协商缓存（304）时，浏览器会向服务端发起http请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存\n\n\t\t\t\t\t- 对于协商缓存，使用Ctrl + F5强制刷新可以使得缓存无效\n\n\t- 缓存头部简述\n\n\t\t- 属于强缓存控制的：\n\n\t\t\t- （http1.1）Cache-Control/Max-Age\n\t\t\t- （http1.0）Pragma/Expires\n\n\t\t- 属于协商缓存控制的：\n\n\t\t\t- （http1.1）If-None-Match/E-tag\n\t\t\t- （http1.0）If-Modified-Since/Last-Modified\n\n\t\t- 头部的区别\n\n\t\t\t- http1.0中的缓存控制：\n\n\t\t\t\t- Pragma：严格来说，它不属于专门的缓存控制头部，但是它设置no-cache时可以让本地强缓存失效（属于编译控制，来实现特定的指令，主要是因为兼容http1.0，所以以前又被大量应用）\n\t\t\t\t- Expires：服务端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires一般对应服务器端时间，如Expires：Fri, 30 Oct 1998 14:19:41\n\t\t\t\t- If-Modified-Since/Last-Modified：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-Modified-Since，而服务端的是Last-Modified，它的作用是，在发起请求时，如果If-Modified-Since和Last-Modified匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。Last-Modified，顾名思义，指的是文件最后的修改时间，而且只能精确到1s以内\n\n\t\t\t- http1.1中的缓存控制：\n\n\t\t\t\t- Cache-Control：缓存控制头部，有no-cache、max-age等多种取值\n\t\t\t\t- Max-Age：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age是Cache-Control头部的值，不是独立的头部，譬如Cache-Control: max-age=3600，而且它值得是绝对时间，由浏览器自己计算\n\t\t\t\t- If-None-Match/E-tag：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-None-Match，而服务端的是E-tag，同样，发出请求后，如果If-None-Match和E-tag匹配，则代表内容未变，通知浏览器使用本地缓存，和Last-Modified不同，E-tag更精确，它是类似于指纹一样的东西，基于FileEtag INode Mtime Size生成，也就是说，只要文件变，指纹就会变，而且没有1s精确度的限制。\n\n\t\t\t- Max-Age相比Expires？\n\n\t\t\t\t- Expires使用的是服务器端的时间\n\n\t\t\t\t\t- 客户端时间和服务端不同步\n\n那这样，可能就会出问题了，造成了浏览器本地的缓存无用或者一直无法过期\n\n所以一般http1.1后不推荐使用Expires\n\n\t\t\t\t- 而Max-Age使用的是客户端本地时间的计算，因此不会有这个问题\n\t\t\t\t- 注意，如果同时启用了Cache-Control与Expires，Cache-Control优先级高。\n\n\t\t\t- E-tag相比Last-Modified？\n\n\t\t\t\t- Last-Modified：\n\n\t\t\t\t\t- 表明服务端的文件最后何时改变的\n\t\t\t\t\t- 它有一个缺陷就是只能精确到1s，\n\t\t\t\t\t- 然后还有一个问题就是有的服务端的文件会周期性的改变，导致缓存失效\n\n\t\t\t\t- E-tag：\n\n\t\t\t\t\t- 是一种指纹机制，代表文件相关指纹\n\t\t\t\t\t- 只有文件变才会变，也只要文件变就会变，\n\t\t\t\t\t- 也没有精确时间的限制，只要文件一遍，立马E-tag就不一样了\n\n\t\t\t\t- 如果同时带有E-tag和Last-Modified，服务端会优先检查E-tag\n\n### 解析页面流程\n\n- 流程简述\n\n\t- 浏览器内核拿到内容后，渲染步骤大致可以分为以下几步：\n\n\t\t- 1. 解析HTML，构建DOM树\n\n\t\t\t- 解析HTML到构建出DOM当然过程可以简述如下：\n\n\t\t\t\t- Bytes → characters → tokens → nodes → DOM\n\n\t\t\t\t\t- 譬如假设有这样一个HTML页面：\n\n\t\t\t\t\t\t- <html>\n  <head>\n    <meta name="viewport" content="width=device-width,initial-scale=1">\n    <link href="style.css" rel="stylesheet">\n    <title>Critical Path</title>\n  </head>\n  <body>\n    <p>Hello <span>web performance</span> students!</p>\n    <div><img src="awesome-photo.jpg"></div>\n  </body>\n</html>\n\n\t\t\t\t\t\t- 列举其中的一些重点过程：\n\n\t\t\t\t\t\t\t- 1. Conversion转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符\n\t\t\t\t\t\t\t- 2. Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集\n\t\t\t\t\t\t\t- 3. Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则\n\t\t\t\t\t\t\t- 4. DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样\n\t\t\t\t\t\t\t- 例如：body对象的父节点就是HTML对象，然后段略p对象的父节点就是body对象\n\n\t\t\t\t\t\t- 最后的DOM树如下：\n\n\t\t- 2. 解析CSS，生成CSS规则树\n\n\t\t\t- CSS规则树的生成也是类似。简述为：\n\n\t\t\t\t- Bytes → characters → tokens → nodes → CSSOM\n\n\t\t\t\t\t- style.css内容如下：\n\n\t\t\t\t\t\t- body { font-size: 16px }\np { font-weight: bold }\nspan { color: red }\np span { display: none }\nimg { float: right }\n\n\t\t\t\t\t\t\t- 最终的CSSOM树就是：\n\n\t\t- 3. 合并DOM树和CSS规则，生成render树\n\n\t\t\t- 当DOM树和CSSOM都有了后，就要开始构建渲染树了\n\n一般来说，渲染树和DOM树相对应的，但不是严格意义上的一一对应\n\n因为有一些不可见的DOM元素不会插入到渲染树中，如head这种不可见的标签或者display: none等\n\n\t\t- 4. 布局render树（Layout/reflow），负责各元素尺寸、位置的计算\n\n\t\t\t- 有了render树，接下来就是开始渲染，基本流程如下：\n\n\t\t\t\t- 重要的四个步骤就是：\n\n\t\t\t\t\t- 1. 计算CSS样式\n\t\t\t\t\t- 2. 构建渲染树\n\t\t\t\t\t- 3. 布局，主要定位坐标和大小，是否换行，各种position overflow z-index属性\n\t\t\t\t\t- 4. 绘制，将图像绘制出来\n\n\t\t\t\t- 图中的线与箭头代表通过js动态修改了DOM或CSS，导致了重新布局（Layout）或渲染（Repaint）\n\t\t\t\t- Layout和Repaint的概念是有区别的：\n\n\t\t\t\t\t- Layout，也称为Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树\n\t\t\t\t\t- Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了\n\n\t\t\t\t- 什么会引起回流？\n\n\t\t\t\t\t- 1.页面渲染初始化\n\t\t\t\t\t- 2.DOM结构改变，比如删除了某个节点\n\t\t\t\t\t- 3.render树变化，比如减少了padding\n\t\t\t\t\t- 4.窗口resize\n\t\t\t\t\t- 5.最复杂的一种：获取某些属性，引发回流，\n很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，\n但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括\n\n\t\t\t\t\t\t-     （1）offset(Top/Left/Width/Height)\n\t\t\t\t\t\t-      (2) scroll(Top/Left/Width/Height)\n\t\t\t\t\t\t-      (3) cilent(Top/Left/Width/Height)\n\t\t\t\t\t\t-      (4) width,height\n\t\t\t\t\t\t-      (5) 调用了getComputedStyle()或者IE的currentStyle\n\n\t\t\t\t- 回流优化方案\n\n\t\t\t\t\t- 减少逐项更改样式，最好一次性更改style，或者将样式定义为class并一次性更新\n\t\t\t\t\t- 避免循环操作dom，创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document\n\t\t\t\t\t- 避免多次读取offset等属性。无法避免则将它们缓存到变量\n\t\t\t\t\t- 将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高\n\n\t\t- 5. 绘制render树（paint），绘制页面像素信息\n\t\t- 6. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上\n',Cn={data:function(){return{MainComponent:xn}}},jn=Cn,Pn=Object(v["a"])(jn,wn,kn,!1,null,"206056d2",null),Tn=Pn.exports,En={components:{m1:dt,m2:xt,m3:Ot,m4:zt,m5:qt,m6:Vt,m7:tn,m8:on,m9:gn,m10:Sn,m11:Tn},data:function(){return{tab:"m1",tabs:[{label:"基本",value:"m1"},{label:"存储",value:"m2"},{label:"从输入 URL 到获取页面的过程",value:"m3"},{label:"从输入 URL 到获取页面的过程",value:"m11"},{label:"浏览器渲染原理与过程",value:"m5"},{label:"从输入URL到页面加载的过程",value:"m6"},{label:"重排和重绘 ",value:"m7"},{label:"跨域",value:"m8"},{label:"bom",value:"m9"},{label:"dom",value:"m10"}]}}},On=En,Mn=Object(v["a"])(On,pt,bt,!1,null,"512f5486",null),An=Mn.exports,Nn=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+t.value,label:n+1+"."+t.label}})})),1),e("div",{staticClass:"q-mx-lg"},[e(""+t.tab,{tag:"component"})],1)],1)},In=[],Dn=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},zn=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("article",{staticClass:"post"},[e("header",{staticClass:"post-header"},[e("h4",{staticClass:"post-title"},[t._v("\n\t\t\t分析比较opacity:0、visibility:hidden、display:none的区别、优劣及适用场景\t\t")])]),e("div",{staticClass:"post-body"},[e("hr"),e("h4",{attrs:{id:"三个属性分别是什么？"}},[e("a",{staticClass:"headerlink",attrs:{href:"#三个属性分别是什么？",title:"三个属性分别是什么？"}}),t._v("三个属性分别是什么？")]),e("ol",{staticClass:"ui list"},[e("li",[e("h4",{attrs:{id:"opacity-（filter-alpha（opacity-0-100））–-MDN详细讲解"}},[e("a",{staticClass:"headerlink",attrs:{href:"#opacity-（filter-alpha（opacity-0-100））–-MDN详细讲解",title:"opacity （filter: alpha（opacity = 0-100））–  MDN详细讲解"}}),t._v("opacity （filter: alpha（opacity = 0-100））–  "),e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/CSS/opacity",target:"_blank",rel:"external noopener noreferrer"}},[t._v("MDN详细讲解")])]),e("ol",[e("li",[t._v("定义：指定了一个元素的透明度")]),e("li",[t._v("值：number类型的值，0~1，如果超过范围，则按最接近的范围值展示，如值为999的时候，是按1展示。默认为1，同样，值为-999时，是按0展示")]),e("li",[t._v("兼容性：很好。除了IE9之前（详细到各浏览器版本号就看文档")]),e("li",[t._v("关注点：什么是透明，是否还存在文档流中，对子元素影响呢？")])])]),e("li",[e("h4",{attrs:{id:"visibility-–-MDN详细讲解"}},[e("a",{staticClass:"headerlink",attrs:{href:"#visibility-–-MDN详细讲解",title:"visibility – MDN详细讲解"}}),t._v("visibility – "),e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/CSS/visibility",target:"_blank",rel:"external noopener noreferrer"}},[t._v("MDN详细讲解")])]),e("ol",[e("li",[t._v("定义：显示或隐藏元素而不更改文档的布局。其中collapse值，还可以隐藏table中的行或列。")]),e("li",[t._v("值：关键值有三个，分别如下。"),e("ol",[e("li",[t._v("___visible，默认值，正常展示")]),e("li",[t._v("___hidden，隐藏元素，不改变布局，但子元素如果设置为visibility: visible，则该子元素可见（很有意思的一个属性）")]),e("li",[t._v("___collapse，应用于table表格。")])])]),e("li",[t._v("兼容性：css2的属性，应该都能兼容吧（没Windows")]),e("li",[t._v("关注点：和opacity的透明度有什么区别？")])])]),e("li",[e("h4",{attrs:{id:"display-–-MDN详细讲解"}},[e("a",{staticClass:"headerlink",attrs:{href:"#display-–-MDN详细讲解",title:"display –  MDN详细讲解"}}),t._v("display –  "),e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/CSS/display#display_none",target:"_blank",rel:"external noopener noreferrer"}},[t._v("MDN详细讲解")])]),e("ol",[e("li",[t._v("定义：指定了元素的显示类型，包含两类基础特征，"),e("strong",[t._v("用于指定元素怎样生成盒模型。")]),e("strong",[t._v("外部显示类型")]),t._v("定义了元素怎么参与流式布局的处理。"),e("strong",[t._v("内部显示类型")]),t._v("定义了子元素的布局方式， 详细可以看看"),e("a",{attrs:{href:"[https://developer.mozilla.org/zh-CN/docs/Web/CSS/display#%E8%AF%AD%E6%B3%95](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display#语法"}},[t._v("语法部分")]),t._v(")")]),e("li",[t._v("值：很多值，其中 none 属于 display-box。被设置成none的元素，将从可访问性树中移除，包括其子元素在内。")]),e("li",[t._v("兼容性：基本支持")]),e("li",[t._v("关注点：对页面重绘有没性能影响？是否可与别的属性连用？")])])]),e("li",[e("h4",{attrs:{id:"表格对比"}},[e("a",{staticClass:"headerlink",attrs:{href:"#表格对比",title:"表格对比"}}),t._v("表格对比")])])]),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}}),e("th",{staticStyle:{"text-align":"center"}},[t._v("opacity: 0")]),e("th",{staticStyle:{"text-align":"center"}},[t._v("visibility: hidden")]),e("th",{staticStyle:{"text-align":"center"}},[t._v("display:none")])])]),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("是否存在页面中")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("存在")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("存在")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("不存在")])]),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("子元素设置该属性其他值是否还能展示")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("不可以")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("可以")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("不可以")])]),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("自身绑定的事件是否能触发")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("能")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("不能")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("不能")])]),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("是否影响遮挡元素的事件触发")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("影响")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("不影响")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("不影响")])]),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("改变属性值是否影响页面重绘")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("不一定")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("一定")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("一定")])]),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("改变属性值是否影响回流")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("不会")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("会")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("会")])]),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("该属性是否支持transition")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("支持")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("支持")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("不支持")])])])]),e("h4",{attrs:{id:"三者的优劣和应用场景"}},[e("a",{staticClass:"headerlink",attrs:{href:"#三者的优劣和应用场景",title:"三者的优劣和应用场景"}}),t._v("三者的优劣和应用场景")]),e("ol",{staticClass:"ui list"},[e("li",[e("h4",{attrs:{id:"绑定事件"}},[e("a",{staticClass:"headerlink",attrs:{href:"#绑定事件",title:"绑定事件"}}),t._v("绑定事件")]),e("ol",[e("li",[t._v("opacity：从表格可得知，opacity的隐藏，只是透明度100%，看不见了，但还在页面中且可以通过z-index等方式遮挡其他元素，同时绑在在该元素上的事件依旧能触发。应用场景可以有：移动端使用input、select加div，自定义样式，其中input、select层级在div上面，并设置opacity为0")]),e("li",[t._v("visibility：这个属性是隐藏，意味着不能聚焦了还占据页面空间。但其子元素可以设置属性值为visible，就能正常显示。应用场景：父元素隐藏，子元素根据一定条件某些展示某些隐藏。可以做一个闪闪发光的星空？")]),e("li",[t._v("display none就不存在页面中了，可以理解为完全的消失。优点即应用场景，如果是流式布局，让一个元素隐藏且不占据空间，就使用这个属性值了。")])])]),e("li",[e("h4",{attrs:{id:"性能方面"}},[e("a",{staticClass:"headerlink",attrs:{href:"#性能方面",title:"性能方面"}}),t._v("性能方面")]),e("ol",[e("li",[t._v("opacity由于只是透明度变化，就还好，visibility是元素隐藏，需要重绘，disable是元素消失，也是需要。")]),e("li",[t._v("应用方面，需要频繁切换状态时，在display和opacity中，可以选择后者，不频繁时，none也可以。")])])])]),e("hr"),e("p",[t._v("遇到新的理解再补充")])]),e("footer",{staticClass:"post-footer"},[e("div",{staticClass:"post-tags"}),e("div",{staticClass:"post-nav"},[e("div",{staticClass:"post-nav-next post-nav-item"},[e("i",{staticClass:"fa fa-chevron-left"}),e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/10/16/5da67f4fa356d/",rel:"next"}},[t._v("Python编程快速上手 学习笔记(二) 电话号码和 E-mail 地址提取程序")])]),e("div",{staticClass:"post-nav-prev post-nav-item"},[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/10/16/5da67f420626e/",rel:"prev"}},[t._v("使用 Navicate 建库建表")]),e("i",{staticClass:"fa fa-chevron-right"})])])]),e("div",{staticClass:"crp_related "},[e("h4",[t._v("相关文章")]),e("ul",[e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/21/c43af3906bad/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("Display:none 与 Visibility:hidden 的不同")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/02/ef068fe32f45/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("CSS visibility Property")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/18/4c6e1210668e/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("如何用 Boolean 属性进行 控件的 Visibility DataBinding -…")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/10/19/5daa7cb4e1751/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("Page Visibility API")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/02/06af71905ee4/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v('jquery validate ":hidden"')])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/13/170787d58f89/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("[SQL SERVER]SQL2016-hidden memory consumer")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/16/04b790e62594/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("DIV Show &amp; Hidden")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/21/0cbe607d8d39/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("GridView Hidden Column Problem")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/10/04/5d976896087c0/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("Hidden Persuasion Chapter01 承认拒绝技术")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/10/09/5d9d7021e85a3/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("透過 IIS 來設定 Hidden Segments")])])])]),e("div",{staticClass:"crp_clear"})])])])}],$n={},Rn=$n,Jn=Object(v["a"])(Rn,Dn,zn,!1,null,"d0130308",null),Ln=Jn.exports,Hn=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{},[e("q-markdown",{attrs:{src:t.MainComponent}})],1)},qn=[],Fn='# css                                   \n## CSS属性\n### 定位\n- position\n\t- static                                                                                                                                               \n\t  static：\n\t  对象遵循常规流。此时4个定位偏移属性不会被                                                                                                                                                             应用。\n\t- relative\n\t  对象遵循常规流，并且参照自身在常规流中的位置通过top，right，bottom，left这4个定位偏移属性进行偏移时不会影响常规流中的任何元素。\n\t- absolute\n\t  对象脱离常规流，此时偏移属性参照的是离自身最近的定位祖先元素，如果没有定位的祖先元素，则一直回溯到body元素。盒子的偏移位置不影响常规流中的任何元素，其margin不与其他任何margin折叠。\n\t- fixed\n\t  fixed：\n\t  与absolute一致，但偏移定位是以窗口为参考。当出现滚动条时，对象不会随着滚动。\n\t- sticky\n\t  对象在常态时遵循常规流。它就像是relative和fixed的合体，当在屏幕中时按常规流排版，当卷动到屏幕外时则表现如fixed。该属性的表现是现实中你见到的吸附效果。（CSS3）\n- z-index\n\t- auto\n\t  元素在当前层叠上下文中的层叠级别是0。元素不会创建新的局部层叠上下文，除非它是根元素。\n\t- <integer>\n\t  用整数值来定义堆叠级别。可以为负值。\n### 布局\n- display\n\t- none\n\t  与visibility属性的hidden值不同，其不为被隐藏的对象保留其物理空间\n\t- inline\n\t  内联元素\n\t- block\n\t  块元素\n\t- inline-block\n\t  内联块元素\n\t- .......\n- float\n  none | left | right\n  当一个元素是绝对定位元素或者定义了display为none时，float定义不生效。\n- clear\n  none(默认) | left | right | both\n- visibility\n  visible(默认) | hidden | collapse\n  collapse：\n  主要用来隐藏表格的行或列。隐藏的行或列能够被其他内容使用。对于表格外的其他对象，其作用等同于hidden。\n  定义了元素是否可见。\n  注意：与display属性不同，visibility会为隐藏的元素保留其占据的物理空间\n  如果希望某个元素为可见，其父元素也必须是可见的。\n- overflow\n  visible | hidden | scroll | auto | clip\n  适用范围：块容器，伸缩盒容器，grid容器\n  visible：\n  对溢出内容不做处理，内容可能会超出容器。\n  hidden：\n  隐藏溢出容器的内容且不出现滚动条。\n  scroll：\n  隐藏溢出容器的内容，溢出的内容可以通过滚动呈现。\n  auto：\n  当内容没有溢出容器时不出现滚动条，当内容溢出容器时出现滚动条，按需出现滚动条。textarea元素的overflow默认值就是auto。\n  clip：\n  与hidden一样，clip也被用来隐藏溢出容器的内容且不出现滚动条。不同的地方在于，clip是一个完全禁止滚动的容器，而hidden仍然可以通过编程机制让内容可以滚动。\n  注意：scroll 与 auto 的区别：scroll 无论溢出如否都存在滚动条\n### 尺寸与补白\n- width\n  <length> | <percentage> | auto(默认)\n  对于img元素来说，若仅指定此属性，其height值将会根据图片源尺寸进行等比例缩放。\n- height\n  定义了元素内容区（Content Area）的高度\n  对于img元素来说，若仅指定此属性，其width值将会根据图片源尺寸进行等比例缩放。\n- padding\n  padding：[ <length> | <percentage> ]{1,4}\n- margin\n  margin折叠常规认知：\n  margin折叠只发生在块级元素上；\n  浮动元素的margin不与任何margin发生折叠；\n  设置了属性overflow且值为非visible的块级元素，将不与它的子元素发生margin折叠；\n  绝对定位元素的margin不与任何margin发生折叠；\n  根元素的margin不与其它任何margin发生折叠；\n### 背景与边框\n- border\n\t- border\n\t  border：<line-width> || <line-style> || <color>\n\t- box-shadow\n\t  语法：\n\t  box-shadow：none | <shadow> [ , <shadow> ]*\n\t  <shadow> = inset? && <length>{2,4} && <color>?\n\t  none：\n\t  无阴影\n\t  <length>①：\n\t  第 1 个长度值定义元素的阴影水平偏移值。正值，阴影出现在元素右侧；负值，则阴影出现在元素左侧\n\t  <length>②：\n\t  第 2 个长度值定义元素的阴影垂直偏移值。正值，阴影出现在元素底部；负值，则阴影出现在元素顶部\n\t  <length>③：\n\t  第 3 个长度值定义元素的阴影模糊值半径（如果提供了）。该值越大阴影边缘越模糊，若该值为0，阴影边缘不出现模糊。不允许负值\n\t  <length>④：\n\t  第 4 个长度值定义元素的阴影外延值（如果提供了）。正值，阴影将向四面扩展；负值，则阴影向里收缩\n\t  <color>：\n\t  定义元素阴影的颜色。如果该值未定义，阴影颜色将默认取当前最近的文本颜色\n\t  inset：\n\t  定义元素的阴影类型为内阴影。该值为空时，则元素的阴影类型为外阴影\n\t- border-radius\n\t  语法：\n\t  border-radius：[ <length> | <percentage> ]{1,4} [ / [ <length> | <percentage> ]{1,4} ]?\n\t  border-radius属性提供 2 个参数，参数间以/分隔，每个参数允许设置 1~4 个参数值，第 1 个参数表示水平半径或半轴，第 2 个参数表示垂直半径或半轴，如第 2 个参数值省略未定义，则直接复制第 1 个参数值。\n\t  注意（对角原则）：水平半径或半轴：如果提供全部四个参数值，将按上左 top-left、上右 top-right、下右 bottom-right、下左 bottom-left的顺序作用于四个角；提供三个，第一个用于top-left，第二个用于top-right和bottom-left，第三个用于bottom-right；提供两个，第一个用于top-left和bottom-right，第二个用于top-right和bottom-left；只提供一个，将用于全部的四个角。\n- background\n\t- background\n\t- ......\n### 颜色与透明度\n- color\n- opacity\n### 字体\n- font\n- font-style\n  font-style：normal | italic | oblique\n  normal：\n  指定文本字体样式为正常的字体\n  italic：\n  指定文本字体样式为斜体。对于没有设计斜体的特殊字体，如果要使用斜体外观将应用oblique\n  oblique：\n  指定文本字体样式为倾斜的字体。人为的使文字倾斜，而不是去选取字体中的斜体字\n- font-weight\n  font-weight：normal | bold | bolder | lighter | <integer>\n  <integer>：\n  用数字表示文本字体粗细。取值范围：100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900\n- font-size\n- font-family\n  font-family：[ <family-name> | <generic-family> ] #\n  <family-name> = arial | georgia | verdana | helvetica | simsun and etc.\n  <generic-family> = cursive | fantasy | monospace | serif | sans-serif\n### 文本\n- line-height\n  语法：\n  line-height：normal | <length> | <percentage> | <number>\n  normal：\n  允许内容顶开或溢出指定的容器边界。\n  <length>：\n  用长度值指定行高。不允许负值。\n  <percentage>：\n  用百分比指定行高，其百分比基于文本的font-size进行换算。不允许负值。\n  <number>：\n  用乘积因子指定行高。不允许负值\n- text-indent\n  语法：\n  text-indent：[ <length> | <percentage> ] && hanging? && each-line?\n- text-align\n  语法：\n  text-align：start | end | left | right | center | justify | match-parent | justify-all\n- text-transform\n  语法：\n  text-transform：none | capitalize | uppercase | lowercase | full-width\n- text-decoration\n  text-decoration：text-decoration-line || text-decoration-style || text-decoration-color\n### 变换\n- transform\n  语法：\n  transform：none | <transform-function>+\n  transform-function list:\n  更多信息请参考：\n  http://css.doyoe.com/\n## CSS布局\n### 页面布局技术细节\n- 浮动、定位、CSS表格、弹性盒子、网格\n### 布局分类\n- 正常流布局\n- 浮动float\n\t- 整列浮动的实现\n- 定位技术\n\t- 静态定位\n\t- 相对定位(Relative positioning)：允许我们相对元素在正常的文档流中的位置移动它——包括将两个元素叠放在页面上。\n\t\t- 这对于微调和精准设计(design pinpointing)非常有用\n\t- 绝对定位(Absolute positioning)：将元素完全从页面的正常布局流中移出，类似将它单独放在一个图层中. 我们可以将元素相对于页面的 <html> 元素边缘固定，或者相对于离元素最近的被定位的祖先元素(ancestor element)。\n\t\t- 绝对定位在创建复杂布局效果时非常有用，例如通过标签显示和隐藏的内容面板或者通过按钮控制滑动到屏幕中的信息面板.\n\t- 固定定位(Fixed positioning)与绝对定位非常类似，除了它是将一个元素相对浏览器视口固定，而不是相对另外一个元素。 在创建类似页面滚动总是处于页面上方的导航菜单时非常有用。\n- CSS表格\n- 弹性盒子\n- 网格布局Grid\n\t- 属性\n\t\t- display属性\n\t\t\t- grid\n\t\t\t- inline-grid\n\t\t- grid-template-columns、grid-template-row属性\n\t\t\t- 定义列宽、行高\n\t\t\t- 关键字\n\t\t\t\t- repeat\n\t\t\t\t- auto-fill\n\t\t\t\t- fr\n\t\t\t\t- minmax\n\t\t\t\t- auto\n\t\t\t\t- 设置网格线名称\n\t\t\t- 实例\n\t\t\t\t- 两栏布局\n\t\t\t\t\t- .wrapper{display: grid; grid-template-columns: 70% 30%}\n\t\t\t\t- 12栏布局\n\t\t\t\t\t- .wrapper{display: grid; grid-template-columns: repeat(12, 1fr)}\n\t\t- grid-gap\n\t\t\t- grid-row-gap\n\t\t\t- grid-column-grap\n\t\t- grid-template-areas属性\n\t\t\t- 网格允许指定区域，一个区域由一个或者多个单元格组成，属性用于定义\n\t\t- grid-auto-flow\n\t\t\t- 定义之元素放置顺序\n\t\t- justify-items、align-items属性、place-items属性\n\t\t- justify-content、aligin-content、place-content\n\t\t- grid-auto-column、grid-auto-rows\n\t\t- grid-template属性\n\t- item属性\n\t\t- grid-column-start、grid-column-end、grid-row-start、grid-row-end\n\t\t- grid-column属性、grid-row属性\n\t\t\t- grid-column\n\t\t\t\t- grid-column: 1/4;表示从第一根列线到第四根列线\n\t\t\t- grid-row\n\t\t- grid-area属性\n\t\t\t- 根据grid-area-template的定义确定item的位置\n\t\t\t- <row-start>/<column-start>/<row-end>/<column-end>\n\t\t- justyfy-self、align-self、place-self\n\t\t\t- 用于设置单个单元格内容的位置\n## SASS\n### 1.变量的声明和引用\n- $符号，变量建议使用中划线链接\n### 2.嵌套规则\n- 普通嵌套规则\n  // before\n  #content article h1 { color: #333 }\n  #content article p { margin-bottom: 1.4em }\n  #content aside { background-color: #EEE }\n  // after\n  #content {\n    article {\n      h1 { color: #333 }\n      p { margin-bottom: 1.4em }\n    }\n    aside { background-color: #EEE }\n  }\n- 父选择器标识符&\n- 群组选择器的嵌套\n- 子组合选择器和同层组合选择器： >、 +和~\n- 嵌套属性\n  nav {\n    border: {\n    style: solid;\n    width: 1px;\n    color: #ccc;\n    }\n  }\n### 3.导入sass文件\n- 导入方法： @import\n- 怎样使用sass部分文件\n\t- 使用下划线开头的“局部文件”\n- 默认变量值\n\t- ！default\n\t  你希望导入sass库文件的人，可以定制修改sass库文件中的某些字。使用sass的!default标签可以实现。\n\t  !default: 若这个变量被声明赋值了，就是声明值，否则则使用默认值\n- 嵌套导入\n\t- @import命令写在css规则内\n\t\t- .blue-theme {@import "blue-theme"}\n- 原生css导入\n\t- sass兼容css语法，改.css文件名为.scss\n### 4.静默注释\n- 静默格式/* ....*/，其内容不会出现在生成的css文件中\n### 5.混入器\n- 如何声明：@mixin; 引用： @include\n- mixin可以包含css规则\n- mixin传参\n\t- @mixin link-colors($normal, $hover, $visited) {\n  color: $normal;\n  &:hover { color: $hover; }\n  &:visited { color: $visited; }\n}\n\t- 设置默认参数：@mixin link-colors(\n    $normal,\n    $hover: $normal,\n    $visited: $normal\n  )\n{\n  color: $normal;\n  &:hover { color: $hover; }\n  &:visited { color: $visited; }\n}\n### 6.继承\n- @extend继承\n## CSS3\n###  opicity 和 rgba的区别\n- opacity只能设定整个元素的透明值，而alpha通道可以特定对元素的某个属性设定透明值，比如上面的背景、边框、文字等\n### transform变形\n- transform: rotate(angle); 旋转\n\t- 如：transform: rotate(9deg)\n- transform: translate(length); 平移\n\t- transform: translate(100px,50px); 水平垂直同时移动\n\t- transform: translateX(100px); 水平移动\n\t- transform: translateY(50px); 垂直移动\n- transform: scale(number); 缩放\n\t- transform: scale(2,1.5); 水平垂直同时缩放\n\t- transform: scaleX(2); 水平缩放\n\t- transform: scaleY(2); 垂直缩放\n- transform: skew(angle); 扭曲\n\t- transform: skew(30deg,10deg); 水平垂直同时扭曲\n\t- transform: skewX(30deg); 水平扭曲\n\t- transform: skewY(30deg); 垂直扭曲\n- transform: matrix(<number>,<number>,<number>,<number>,<number>,<number>); 矩阵\n- transform-origin(X,Y): length; 改变元素变换基点\n### rem单位\n- font size of the root element\n\t- px、em、rem的区别\n\t\t- px，像素，相对长度单位，相对于屏幕分辨率\n\t\t- em，相对长度单位，相对父节点的字体尺寸，如未设置则相对于浏览器默认字体尺寸\n\t\t\t- 一般浏览器默认值为16px\n\t\t- rem仍然是相对长度单位，但只相对于HTML根元素\n\t- 通过修改根元素就可以成比例地调整所有字体尺寸\n\t- 设置 html{ font-size: 10px; } 则1rem=10px\n### fixed布局\n- 任何一个容器都可以指定为Flex布局 display: flex;\n- 行内元素也可以指定为Flex布局 display: inline-flex;\n- 设置为flex布局后子元素的float、clear、vertical-align属性将失效\n- 采用flex布局的元素称为flex container，简称容器，它的所有子元素自动成为容器成员，称为flex item，简称项目\n\t- 容器默认存在两根轴\n\t\t- 水平的主轴（main axis），开始位置为main start，结束位置为main end\n\t\t- 垂直的主轴（cross axis），开始位置为cross start，结束位置为cross end\n\t\t- 项目默认按主轴排列\n\t\t- 单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size\n\t- 可以在容器上设置6种属性\n\t\t- flex-direction\n\t\t\t- flex-direction决定主轴的方向（即项目的排列方向）\n\t\t\t\t- flex-direction: row; 默认值，主轴水平方向，以左端为起点\n\t\t\t\t- flex-direction: row-reverse;  主轴水平方向，以右端为起点\n\t\t\t\t- flex-direction: column; 主轴垂直方向，以左端为起点\n\t\t\t\t- flex-direction: column-reverse; 主轴垂直方向，以右端为起点\n\t\t- flex-wrap\n\t\t\t- flex-wrap定义如何换行\n\t\t\t\t- flex-wrap: nowrap; 默认值，不许换行\n\t\t\t\t- flex-wrap: wrap; 换行，第一排在上方\n\t\t\t\t- flex-wrap: wrap-reverse; 换行，第一排在下方\n\t\t- flex-flow\n\t\t\t- flex-direction和flex-wrap的缩写\n\t\t\t\t- flex-flow:<flex-direction> <flex-wrap>; 如flex-flow: row-reverse nowrap; \n\t\t- justify-content\n\t\t\t- justify-content定义在主轴上的对齐方式\n\t\t\t\t- justify-content: flex-start; 默认值，左对齐\n\t\t\t\t- justify-content: flex-end; 右对齐\n\t\t\t\t- justify-content: center; 居中\n\t\t\t\t- justify-content: space-between; 两端对齐\n\t\t\t\t- justify-content: space-around; 项目之间间隔相等\n\t\t- align-items\n\t\t\t- align-items定义在交叉轴上的对齐方式\n\t\t\t\t- align-items: flex-start; 交叉轴起点对齐\n\t\t\t\t- align-items: flex-end; 交叉轴终点对齐\n\t\t\t\t- align-items: center; 交叉轴中点对齐\n\t\t\t\t- align-items: baseline; 第一行文字的基线对齐\n\t\t\t\t- align-items: stretch; 默认值，若项目未设置高度或为auto，将占满整个容器高度\n\t\t- align-content\n\t\t\t- align-content定义多根轴的对齐方式\n\t\t\t\t- flex-start、flex-end、center、space-between、space-around、stretch（默认值）\n\t- 可以在项目上设置6种属性\n\t\t- order\n\t\t\t- order定义项目的排列顺序\n\t\t\t\t- order: <integer>; 数值越小排列越靠前，默认值0\n\t\t- flex-grow\n\t\t\t- flex-grow定义项目的放大比例\n\t\t\t\t- flex-grow: <number>; 默认为0\n\t\t- flex-shrink\n\t\t\t- flex-shrink定义项目的缩小比例\n\t\t\t\t- flex-shrink: <number>; 默认为1，负值无效\n\t\t- flex-basis\n\t\t\t- flex-basis定义在分配空余空间之前项目占据的主轴空间\n\t\t\t\t- flex-basis: <length>; ，默认值为auto\n\t\t- flex\n\t\t\t- flex-grow、flex-shrink和flex-basis的缩写\n\t\t\t\t- flex: <flex-grow> <flex-shrink> <flex-basis>; 建议优先使用这个属性\n\t\t- align-self\n\t\t\t- align-self允许单个项目拥有与其他项目不同的对齐方式，可覆盖align-items\n\t\t\t\t- 可取6个值，除了默认值auto都与align-items相同\n### animate动画\n- animate是一个简写属性，用于设置6大动画属性\n\t- animate-name 规定@keyframes动画名称\n\t\t- animate-name: keyframename; 动画名称\n\t\t- animate-name: none; 无动画效果，可用于覆盖来自级联的动画\n\t- animate-duration: time; 一个动画周期持续的时间，默认值为0\n\t- animation-timing-function 速度曲线\n\t\t- ease，默认值，以低速开始加速，结束前变慢\n\t\t- ease-in，以低速开始\n\t\t- ease-out，以低速结束\n\t\t- ease-in-out，以低速开始结束\n\t\t- linear，整个过程速度不变\n\t\t- cubic-bezier(n,n,n)，以cubic bezier函数来生成一个速度函数，可能的值是1到0\n\t- animation-delay:time; 何时开始，允许负值\n\t- animation-iteration-count播放次数\n\t\t- n，播放次数，默认值1\n\t\t- infinite，无限次播放\n\t- animation-direction规定动画在下一周期是否逆向播放\n\t\t- normal，默认值，正常播放\n\t\t- alternate，轮流反向播放\n- animation-play-state规定动画正在运行还是暂停\n\t- paused，已暂停\n\t- running，正在播放\n- @keyframes规则创建动画\n\t- @keyframes keyframename{ keyframes-selector{css-styles;}} \n\t\t- 如：@keyframes myfirstmove{ 0%{ top:0px; background:red; } 100%{ top:100px; background:yellow; }}\n- animation-fill-mode规定动画在播放之前或之后，其动画效果是否可见\n\t- none，不改变默认行为\n\t- forwards当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）\n\t- backwards在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）\n### transition过渡\n- transition是一个简写属性，用于设置4个过渡属性\n\t- transition-property: width; 用于设置产生变形的CSS属性\n\t- transition-duration: time; 用于设置过渡时间，是必须设置的，否则不会产生过渡效果\n\t- transition-timing-function类似于animate-timing-function\n\t- transition-delay: time; 效果开始前需要等待的时间\n### media queries\n- 工作方式\n\t- 直接在link中判断设备尺寸然后引用不同的css文件\n\t- link rel="stylesheet" type="text/css" href="#" media="screen and (min-width:400px ) and (max-width:600px)"\n\t- 直接写在style标签里\n\t- @media screen and (max-width:600px){ } \n- media属性中\n\t- 十种media type：all、screen、print、tv、handheld等\n\t- 关键字：and、only（限定某种媒体）、not（排除某种媒体）\n\t- 媒体特性，放在一对（）中，如(min-width:600px)\n## 盒模型\n### 标准盒模型\n- 元素的width、height只包含内容content，不包含border和padding的值；\n- 盒子的大小由元素的宽高、边框和内边距决定\n### 转换\n- box-sizing\n\t- content-box\n\t- border-box\n\t\t- 若想控制元素总宽高保持固定，这个设置很有用。\n### IE盒模型\n- 元素的width、height不仅包括content，还包括border和padding\n- 盒子的大小取决width、height，修改border和padding值不能改变盒子的大小\n### 注意\n- 元素的宽（width）、高（height）、边框（border）、内边距（padding）、外边距（margin）都是盒子模型的重要组成部分，但是盒子模型的大小只与元素的宽高、边框、内间距有关，外边距只影响盒子所占外围空间的大小。\n## 雪碧图优缺点\n### 减少图片请求次数\n### 提高页面加载速度\n- 合成的图片相比不合成图片大小综合要小\n### 影响浏览器缩放功能\n- 相邻图片会被露出来\n- 大图片会有性能下降问题\n### css编写困难\n### 拼图维护麻烦\n### css图片不能被打印\n- 除非在@media添加print声明\n### 最大问题就是内存的使用\n- 图片留有无用的空白\n## 元素居中方法汇总\n### 水平居中\n- 文本、图片\n\t- 容器中设置：text-align:center\n- 块级元素\n\t- ( 如果宽度固定)margin: auto法------margin: 0 auto （对浮动及绝对定位元素无效,另：这里的0 其实可以是任意值）\n\t- （如果宽度不固定）新增包裹元素法----设置包裹元素为浮动float:left;position:relative;left:50%,再设置其自身position:relative;left:-50% 或right:50%即可（该50%其实是相对包裹元素的宽度而并非其自身的宽度！另外该方法不适合垂直居中！！！除非高度固定才可以。）\n\t- 父元素相对定位，子元素绝对定位法（详见《垂直居中》中的块级元素部分）\n\t- （对于多个块级元素） inline-block法 ：其父元素设置text-align:center,其自身设置display:inline-block，使用inline-block注意清除由其带来的空隙及使用 vertical-align属性！\n### 垂直居中（或水平垂直居中）\n- 单行文本\n\t- （如果父元素高度固定）line-height法------父元素的height与父元素的line-height相等\n\t- （如果父元素高度不固定）上下padding法------父元素的上下padding相等\n- 多行文本\n\t- （如果父元素高度固定）vertical-align法------父元素设置display:table-cell;vertical-align:middle\n\t- （如果父元素高度不固定）上下padding法------父元素的上下padding相等\n- 块级元素\n\t- 如果尺寸固定\n\t\t- 负margin法------父元素设置position为relative，子元素position为absolute，top,left为：50%，margin-left,margin-top各为其自身宽或高的一半的负数。\n\t\t- calc法------同上，父元素设置position为relative，子元素position为absolute，top,left为：50%，采用calc（50%-其自身宽或高的一半）\n\t\t- transform法------同上，父元素设置position为relative，子元素position为absolute，top,left为：50%，并使用 transform: translate(-50%, -50%);\n\t\t- 4个0法------ 还是父元素设置position为relative，子元素position为absolute，其它见上面的代码\n\t- 如果尺寸不固定\n\t\t- transform法------父元素设置position为relative，子元素position为absolute，top,left为：50%，并使用 transform: translate(-50%, -50%);\n\t\t- display:table-cell法------ 父元素 display:table-cell; vertical-align:middle\n\t\t- flex法------父元素align-items:center;justify-content:center\n\t\t- 伪类法------在父元素中增加一个高度为100%的空元素，其他详见代码\n- 图片\n\t- display:table-cell法------display:table-cell;             vertical-align:middle\n\t- 伪类法------在父元素中增加一个高度为100%的空元素，其他详见代码\n\t- js处理设置上下边距相等\n## 网格布局\n### CSS网格属性总结\n- 网格容器（父元素）\n\t- display\n\t\t- grid\n\t\t- inline-grid\n\t\t- subgrid（行列大小会继承父级网格容器）\n\t- grid-template-columns、grid-template-rows\n\t\t- 网格线名称\n\t\t- 长度值、百分比或者fr\n\t- grid-template-areas\n\t\t- grid-area-name\n\t\t- . （点号） 代表一个空的网格单位\n\t\t- none 不定义网格区域\n\t- grid-template\n\t\t- none：将三个属性设为初始值\n\t\t- subgrid：将grid-template-columns及grid-template-rows的值设为subgrid，将grid-template-areas设为初始值\n\t\t- <grid-template-rows> / <grid-template-columns>将grid-template-rows和grid-template-columns设置为相应的值，并将grid-template-areas设为none\n\t- grid-column-gap/grid-row-gap\n\t\t- 长度值\n\t- grid-gap\n\t\t- <grid-row-gap> <grid-column-gap>长度值\n\t- justify-items（注意与justify-content的区别）\n\t\t- start\n\t\t- end\n\t\t- center\n\t\t- stretch\n\t- align-items\n\t\t- start\n\t\t- end\n\t\t- center\n\t\t- stretch\n\t- justify-content( 注意与flex中的justify-content区别，这里不是表示里面的内容 )\n\t\t- start\n\t\t- end\n\t\t- center\n\t\t- stretch\n\t\t- space-between\n\t\t- space-around\n\t\t- space-evenly\n\t- align-content\n\t\t- start\n\t\t- end\n\t\t- center\n\t\t- stretch\n\t\t- space-between\n\t\t- space-around\n\t\t- space-evenly\n\t- grid-auto-columns / grid-auto-rows\n\t\t- 长度值/百分比/fr\n\t- grid-auto-flow\n\t\t- row\n\t\t- column\n\t\t- row dense\n\t\t- column dense\n\t- grid\n\t\t- none\n\t\t\t- 将所有子属性设置为其初始值\n\t\t- <grid-template-rows> / <grid-template-columns>\n\t\t\t- 将grid-template-rows 和 grid-template-columns分别设置为指定值，将其他子属性设置为其初始值\n\t\t\t\t- 例子（上下两个是等效的）\n\t\t- <grid-auto-flow> [<grid-auto-rows> [ / <grid-auto-columns>] ] \n\t\t\t- 如果省略了grid-auto-columns，则它被设置为由grid-auto-rows指定的值。如果两个都被省略，他们会被设置为初始值\n\t\t\t\t- 例子（上下两个是等效的）\n\t\t-  <grid-template-areas> <grid-template-rows> / <grid-template-columns>\n\t\t\t- 一次性设置所有值，设置后其他属性均为默认值\n\t\t\t\t- 例子\n- 网格项（子元素）\n\t- grid-column-start / grid-column-end / grid-row-start / grid-row-end\n\t\t- 网格线名称\n\t\t- span <number> 该网格项将跨越所提供的网格轨道数量\n\t\t- span <name> 该网格项将跨越到它所提供的名称位置\n\t\t- auto：表示自动放置，自动跨度，默认会扩展一个网格轨道的宽度或高度\n\t- grid-column / grid-row\n\t\t- <start-line> / <end-line>\n\t\t\t- 含义\n\t\t\t\t- grid-column-start + grid-column-end 和 grid-row-start + grid-row-end的简写\n\t\t\t- 语法示范\n\t\t\t\t- 示范\n\t\t\t- 举例\n\t\t\t\t- 例子\n\t- grid-area\n\t\t- <name> ：自定义的名称，以便被grid-template-areas属性创建的模版所引用\n\t\t- <row-start> / <column-start> / <row-end> / <column-end>：数字或网格线名称（其实这里还有 比如  grid-row-start:1 ; grid-column-start:2等价的表达 ）\n\t- justify-self\n\t\t- start\n\t\t- end\n\t\t- center\n\t\t- stretch（默认值）\n\t- align-self\n\t\t- start\n\t\t- end\n\t\t- center\n\t\t- stretch（默认值）\n### CSS网格布局基本概念（mdn版）\n- 网格容器\n\t- （父元素）使用 display:grid 或者display:inline-grid\n- 网格轨道\n\t- （父元素）使用 grid-template-columns 和grid-template-rows属性来定义列和行\n\t- 单位：px或者百分比或者fr 如：grid-template-rows:1fr 1fr 1fr\n\t- 在轨道清单中使用repeat()来标记重复部分或者整个轨道列表\n\t\t- grid-template-rows:1fr 1fr 1fr 可以改写为grid-template-rows: repeat( 3, 1fr )\n\t\t- grid-template-rows: 20px 1fr 1fr 20px 可以改写为grid-template-rows:  20px  repeat( 2, 1fr ) 20px\n\t\t- 传入轨道列表 ：grid-template-rows: 1fr 2fr  1fr 2fr 1fr 2fr  可以改写为grid-template-rows:  repeat( 3, 1fr 2fr ) \n\t- （父元素）隐式和显式网格\n\t\t- grid-auto-rows （行  其实它控制的是元素的高度 --别搞混淆了）\n\t\t- grid-auto-columns （列 其实它控制的是元素的宽度--别搞混淆了）\n\t- 轨道大小和minmax()\n\t\t- grid-auto-rows :minmax(100px, auto) （其表示最小高度是100px，最大高度自适应）\n- 网格线\n\t- （子元素）跨轨道放置网格项目\n\t\t- grid-column-start , grid-column-end , grid-row-start ,grid-row-end\n\t\t- 比如  列线1-列线4，行线1至行线2  我们可以写成： grid-column-start:1 ; grid-column-end:4 ; grid-row-start:1 ;grid-row-end:2; 或者直接简写成 grid-column: 1/4 ;grid-row:1/2;\n- 网格单元\n\t- 最小单位\n- 网格区域\n\t-   （父元素） grid-template-areas\n\t- （子元素）grid-areas\n- 网格间距\n\t- （父元素）grid-column-gap、grid-row-gap 或者合并简写：grid-gap\n- 嵌套网格\n- 使用z-index控制层级\n\t- 原本覆盖的顺序遵循文档流的原始顺序原则即： 后来者居上的原则\n## Css2D-3D\n### 1.过渡效果transition\n- 说明：过渡是从一种状态到另外一种状态, 过渡需要触发条件, 通常过渡都是写在开始状态\n- transition-property\n\t- 规定哪些属性需要过渡\nall 默认值 全部属性过渡，多个属性过渡,用逗号隔开\n- transition-duration\n\t- 过渡的时间 默认值 0s\n- transition-timing-function\n\t- 过渡的运动曲线\nease 默认值 逐渐慢下来\nlinear  均速\n- transition-delay\n\t- 过渡的延迟\n- 连写：transition: all 1s linear 0s\n### 2.2D转换\n- 1.位移 transform：translate(-50%,-50%)\n\t- 优点：对自盒子不用计算向上和向左移动多少\n\t- 特点：若仅仅只是识位移，盒子不会脱标，盒子原有的位置还在标准流中\n- 2.旋转 transform：rotate(45deg)\n\t- 正=>顺时针\n\t- 负=>逆时针\n- 3.旋转点 transform-origin：水平 垂直\n\t- 可以设置方位名称，也可以设置具体数值\n- 3.缩放/扩大 transform：scale（number，number）\n\t- 1.大于0小于1=>缩放\n\t- 2.大于1=>扩大\n### 3.动画\n- 1.定义动画 @keyframs 名称 {\n\t0%{\n    }，\n\t100%{\n    }\n}\n- 2.指定动画名称 animation-name\n- 3.完成一个周期所需要的时间 animation-duration\n- 4.动画的运动曲线 linear匀速 ease缓冲 steps步长  animation-timing-function: linear\n- 5.次数 infinite无线循环 animation-iteration-count:infinite\n- 6.是否你想播放，如果想逆向播放的前提是 次数需要大于2次  animation-direction:alternate\n- 7.结束之后的状态 在哪里 animation-fill-mode: forwards\n- 8.延迟几秒开始 animation-delay: 3s\n- 9.暂停 animation-play-state: paused\n### 4.3D转换\n- 1.位移：transform：translate(x,y,z)\n\t- 1.x轴 正值向右，负值向左\n\t- 2.y轴 正值向下，负值向上\n\t- 3.z轴 正值向前，负值向后 \n\t- 注意：如果要设置多个轴时，不要分开设置，要写在同一个transform中\n- 2.旋转\n\t- transform：- transform: rotateX(角度); \n    - transform: rotateY(角度); \n    - transform: rotateZ(角度); \n- 注意：\n\t- 1.视距越大，物体越小，*视距越小，物体越大\n\t- 2.translateZ值越大，物体越大，translateZ越小，物体越小\n\t- 3.translateZ一定要与perspective 一起使用，近大远小\n\t- 4.左手法则\n\t\t- 1.X正值=>右\n\t\t- 2.Y正值=>下\n## 移动端\n### 移动端（流式）布局\n- 1.移动端相关知识\n\t- 1.什么是物理像素\n\t\t- 答：屏幕分辨率\n\t- 2.什么是开发像素\n\t\t- 答：css像素px 就是开发像素\n\t- 3.开发像素在PC端和屏幕分辨率比例是一致吗？\n\t\t- 答：一致\n\t- 4.开发像素在移动端和屏幕分辨率比例一致吗？\n\t\t- 答：不一定一致，因为物理像素比可能不一样\n\t- 5.什么是物理像素比？\n\t\t- 答：1个物理像素=多个开发像素\n\t- 6，物理像素比的影响\n\t\t- 答：未来图片在移动端，因为物理像素比的存在，图片可能会放大而失真，影响用户体验，所以设计素材人员，在设计图片时，以多倍的方式设置\n- 2.盒子模型 box-sizing\n\t- 1.传统盒子（content-box）\n\t\t- 盒子大小：内容+padding+border\n\t\t\t- 缺点：盒子要是保持原来的大小，需要自己计算width 和 height\n\t- 2.CSS3盒子（border-box）\n\t\t- 盒子大小：内容（内容+padding+border）\n\t\t\t- 优点：盒子的内容会自动适应模型的变化\n- 3.扩展（H5新增标签）\n\t- 1.header 头部标签\n\t- 2.footer 底部标签\n\t- 3.section 区块标签\n\t- 4.article 文本内容标签\n\t- 5.aside 侧边标签\n\t- 6.nav 导航标签\n\t- 注意：以上标签均可用div代替，但是div没有语义\n- 4.京东移动端案例：（注意事项）\n\t- 1.视口配置-理想视口（记得要写，写在字符编码下方即可）\n\t\t-  <meta name="viewport" content="width=device-width, user-scalable=no,initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">\n\t- 2.初始化样式\n\t\t- normalize.css\n### 移动端flex（弹性）布局\n- 1.设置主轴方向（flex-direction）\n\t- 1.row水平\n\t- 2.column垂直\n\t- 3.row-reverse 反向/column-reverse 反向\n- 2.设置主轴上子元素的排列方式（justify-content）\n\t- 1.flex-start 从头开始\n\t- 2.flex-end 从尾部开始\n\t- 3.center 居中\n\t- 4.space-around 平分间距\n\t- 5.space-between 两端对齐中间自动填充\n- 3.设置子元素是否换行（flex-wrap）\n\t- 1.nowrap 不换行（默认）\n\t- 2.wrap 换行\n- 4.设置侧轴上的子元素排列方式（单行 ）（aligin-items）\n\t- 1.flex-start 从上到下\n\t- 2.flex-end 从下到上\n\t- 3.center 居中\n\t- 4.stretch 拉伸（不能设置高度）\n- 5.设置侧轴上的子元素的排列方式（多行）（align-content）\n\t- 1.flex-start （默认值在侧轴的头部开始）\n\t- 2.flex -end （在侧轴的尾部开始排列）\n\t- 3.center （在侧轴中间显示）\n\t- 4.space-around （子项在侧轴平分剩余部分）\n\t- 5.space-between 子项在侧轴先分布在两头，在平分剩余空间\n\t- 6.stretch 设置子项元素高度平分父元素高度\n- 6.flex属性 \n\t- 1.flex 属性定义子项目==分配容器的剩余空间==，用flex来表示占多少==份数==。\n\t- 2.align-self 控制子项自己在侧轴上的排列方式\n\t- 3.order 属性定义项目的排列顺序/数值越小，排列越靠前，默认为0。\n### 移动端（rem布局）\n- 1.单位\n\t- 1.em\n\t\t- 基于父亲的字体的大小\n\t- 2.rem\n\t\t- 基于Html 字体的大小（绝对唯一控制）\n- 2.媒体查询\n\t- 作用：查询屏幕，相应屏幕变化\n\t- 档位划分 例：@media screen and （min-width）\n\t- 等比：在各个挡位下，比例一直不变，变化的是rem后面的值\n- 3.less\n\t- 是一种css的扩展语言，辅助css计算使用\n- 4.flexible.js\n\t- 引入此js 可以实现等比变化，不会一抽一抽的\n### 响应式布局（PC，手机，pad）\n- 1.档位划分\n\t- w<768  超小屏幕（xs : extra small）\n\t- 768<= w <992  小屏设备\n\t- 992<= w <1200  中等屏幕\n\t- 1200<=w  大宽屏设备（lg: large）\n- 2.bootstrap\n\t- 1.栅格系统\n\t\t- 1.在各个档位下，控制子元素布局不同；将版心宽度均分为  12份\n\t- 2.特点\n\t\t- 1.盒子有左右15padding\n\t\t- 2.盒子 col-lg：有左右15padding\n\t\t- 3.去除15padding：加div.row （左右负 -15px margin 值）\n\t- 3.作用：左右偏移，居中\n- 3.备注\n\t- 1.向下：涉及向下布局，需要手动写媒体查询\n\t- 2.只要涉及隐藏，就要用到响应式工具  \n\t\t- 例如：hidden-xs 只是xs时隐藏\n\t\t- 例如：visible-xs  知识xs时显示\n## BFC\n### 触发BFC（一个新的BFC可以通过给容器添加任何一个触发BFC的CSS样式来创建）\n- float的值不为none\n- position的值不为static或者relative\n\t- 关于position定位\n\t\t- static定位\n\t\t\t- 　static定位是HTML元素的默认值，即没有定位，元素出现在正常的流中\n\t\t- fixed固定定位\n\t\t\t- fixed定位是指元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会滚动，且fixed定位使元素的位置与文档流无关，因此不占据空间，且它会和其他元素发生重叠。\n\t\t\t- 兼容性\n\t\t- relative相对定位\n\t\t\t- 相对定位元素的定位是相对它自己的正常位置的定位。\n\t\t\t- 即使相对元素的内容移动了，但是预留空间的元素仍然保存在正常流动\n\t\t- absolute绝对定位\n\t\t\t- 绝对定位的元素相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于<html>。\n\t\t- sticky粘性定位\n\t\t\t- 粘性定位是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。\n\t\t\t- 实例\n\t\t\t\t- 在 viewport 视口滚动到元素 top 距离小于 10px 之前，元素为相对定位。之后，元素将固定在与顶部距离 10px 的位置，直到 viewport 视口回滚到阈值以下。\n\t\t\t- 实现条件\n\t\t\t\t- 须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。\n- display的值为 table-cell, table-caption, inline-block, flex, 或者 inline-flex中的其中一个\n- overflow的值不为visible\n### BFC的约束规则\n- 1，BFC内元素垂直方向的边距会发生重叠（当兄弟元素的外边距不一样时，将以最大的那个外边距为准。）\n- 2，BFC的区域不会与浮动元素的BOX重叠（清除浮动）\n- 3，BFC在页面上是一个容器，外面的元素不会影响到里面的元素\n- 4，计算BFC元素高度时，即使是浮动元素也会参与计算\n- 5，每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界）\n### BFC应用\n- 使用BFC来防止外边距折叠\n\t- 毗邻块盒子的垂直外边距折叠只有他们是在同一BFC时才会发生。如果他们属于不同的BFC，他们之间的外边距将不会折叠。所以通过创建一个新的BFC我们可以防止外边距折叠。\n- 使用BFC来包含浮动\n\t- 很多时候我们会碰到这种情况，一个容器里有浮动元素。由于这个原因，容器元素没有高度，它的浮动孩子将会脱离页面的常规流。我们通常使用清除浮动来解决这个问题，最受欢迎的方法是使用一个clearfix的伪类元素。但我们同样可以通过定义一个BFC来达到这个目的。\n- 使用BFC来防止文字环绕\n\t- 给p标签创建BFC即可\n- 在多列布局中使用BFC\n\t- 如果我们正在创建的一个多列布局占满了整个容器的宽度，在某些浏览器中最后一列有时候将会被挤到下一行。会发生这样可能是因为浏览器舍入（取整）了列的宽度使得总和的宽度超过了容器的宽度。然而，如果我们在一个列的布局中建立了一个新的BFC，它将会在前一列填充完之后的后面占据所剩余的空间。\n## CSS3新特性\n### 文字阴影（text-shadow）\n### 边框\n- 圆角（border-radius）\n\t- 是一个简写属性，用于设置四个 border-*-radius 属性。\n- 边框阴影： box-shadow\n\t- box-shadow: 水平阴影的位置 垂直阴影的位置 模糊距离 阴影的尺寸 阴影的颜色 内嵌;\n### 盒子模型（box-sizing）\n### 渐变：linear-gradient、radial-gradient\n### 过渡：transition，可实现动画\n### 自定义动画\n### 在CSS3中唯一引入的伪元素是 ：selection.\n- ::selection 选择器匹配被用户选取的选取是部分。\n- 只能向 ::selection 选择器应用少量 CSS 属性：color、background、cursor 以及 outline。\n### 媒体查询\n### 2D转换：transform：translate(x，y) rotate(x，y) skew(x，y) scale(x，y)\n### 3D转换\n### 新增的伪类\n- p:first-of-type 选择属于其父元素的首个 <p> 元素的每个 <p> 元素。\n- p:last-of-type 选择属于其父元素的最后 <p> 元素的每个 <p> 元素。\n- p:only-of-type 选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。\n- p:only-child 选择属于其父元素的唯一子元素的每个 <p> 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 <p> 元素。 :enabled、:disabled 控制表单控件的禁用状态。\n- :checked，单选框或复选框被选中。html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？\n## 【CSS】内联块元素与<IMG>标签\n### display：inline\n- 特点\n\t- (1)、和其他元素都在一行上；\n\t- (2)、元素的高度、宽度、行高及顶部和底部边距不可设置；（仅可设置左右边距）\n\t- (3)、元素的宽度就是它包含的文字或图片的宽度，不可改变。\n- 示例\n### display：block\n- 特点\n\t- (1)、每个块级元素都从新的一行开始，并且其后的元素也另起一行。（一个块级元素独占一行）;\n\t- (2)、元素的高度、宽度、行高以及顶和底边距都可设置;\n\t- (3)、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。\n- 示例\n### display：inline-block\n- 特点\n\t- (1)、和其他元素都在一行上；\n\t- (2)、元素的高度、宽度、行高以及顶和底边距都可设置\n- 示例\n### 额外\n- （1）<img>元素是内联还是块级元素？\n\t- img属于行内替换元素。height/width/padding/margin均可用。效果等于块元素。（等同于inline-block）\n\t- 行内非替换元素，例如, height/width/padding top、bottom/margin top、bottom均无效果。只能用padding left、right和padding left、right改变宽度。\n- （2）插入img下面会有空白\n\t- 现象\n\t- 解决\n\t\t- 1、给图片img标签display:block\n\t\t- 2、定义图片img标签vertical-align:bottom，vertical-align:middle，vertical-align:top。\n\t\t- 3、定义容器里的字体大小font-size为0。\n\t- 原理：img元素底部为何有空白？\n\t\t- 要理解CSS对于 display: inline 元素的 vertical-align 各个值的含义。vertical-align 的默认值是 baseline，这是一个西文排版才有的概念\n\t\t- 对比一下 vertical-align 的另外两个常见值，top 和 bottom\n\t\t\t- 可以看到，baseline 和 bottom 之间有一定的距离。实际上，inline 的图片下面那一道空白正是 baseline 和 bottom 之间的这段距离。即使只有图片没有文字，只要是 inline 的图片这段空白都会存在。\n\t\t- 到这里就比较明显了，要去掉这段空白，最直接的办法是将图片的 vertical-align 设置为其他值。如果在同一行里有文字混排的话，那应该是用 bottom 或是 middle 比较好。\n\t\t- 另外，top 和 bottom 之间的值即为 line-height。假如把 line-height 设置为0，那么 baseline 与 bottom 之间的距离也变为0，那道空白也就不见了。如果没有设置 line-height，line-height 的默认值是基于 font-size 的，视渲染引擎有所不同，但一般是乘以一个系数（比如1.2）。因此，在没有设置 line-height 的情况下把 font-size 设为0也可以达到同样的效果。当然，这样做的后果就是不能图文混排了。\n## Flex布局总结\n### Flex之前\n### 一种新的布局方式\n- 1.块级布局侧重垂直方向、行内布局侧重水平方向，flex布局是与方向无关的\n- 2.flex布局可以实现空间自动分配、自动对齐\n- 3.flex适用于简单的线性布局，更复杂的布局要交给grid布局\n### 基本概念\n- flex container 的属性(父元素)\n\t- flex-direction\t方向\n\t\t- row\t按行排列\n\t\t- row-revervse\t  按行反向排列\n\t\t- column\t按列排列\n\t\t- column-revervse 按列反向排列\n\t- flex-wrap\t换行\n\t\t- wrap\t折行\n\t\t- nowrap\t不折行\n\t- flex-flow\t上面两个的简写\n\t- justify-content\t主轴方向对齐方式\n\t\t- space-between 多余空间放置中间\n\t\t- space-around  空间放置周围\n\t\t- flex-start  全部向起点靠拢\n\t\t- flex-end  全部向终点靠拢\n\t\t- center  全部往中间靠拢\n\t- align-items\t侧轴对齐方式\n\t\t- stretch  在子元素高度不写死的情况下，按最高元素高度对齐\n\t\t- flex-start  所有元素按照顶部水平线对齐\n\t\t- flex-end  所有元素按照其底部水平线对齐\n\t\t- center  所有元素按照中间水平线对齐\n\t\t- baseline  项目的第一行文字的基线对齐。（较少使用）\n\t- align-content\t多行/列内容对齐方式（用的较少）\n\t\t- space-between  行与行之间的空隙平均分配\n\t\t- space-around  空间放置两边\n\t\t- flex-start  全部向侧轴起点靠拢\n\t\t- flex-end  全部向侧轴终点靠拢\n\t\t- stretch（默认值）  轴线占满整个侧轴\n- flex item的属性（子元素）\n\t- flex-grow  增长比例（空间过多时）\n\t- flex-shrink  收缩比例（空间不够时）\n\t- flex-basis  默认大小时（一般不用）\n\t- flex  以上三个的缩写\n\t- order  顺序（代替双飞翼）\n\t- align-self  自身的对齐方式\n### 使用Flex布局\n- 1.手机页面布局（tapbar+main+tabs）\n- 2.产品列表（ul>li*9）\n- 3.PC页面居中\n- 4.完美居中\n## CSS中的百分数都是相对于谁\n### （1）第一类——定位类\n- absolute\n\t- left、right是相对于参照物的width，top和bottom是相对于参照物的height\n- relative\n\t- left、right是相对于父元素的width，top和bottom是相对于参照物的height\n- fixed\n\t- 它是相对于视窗定位的，那么自然%的参照物便是视窗了。\n### （2）第二类——盒子模型\n- margin&padding\n\t- 如果设置了%值，那么他们参照的是父元素的宽度\n- border-radius\n\t- 盒子自身的宽高\n### （3）第三类——背景值\n- background-size\n\t- 盒子自身的宽高：background-size:100% 100%;\n- background-position\n\t- 这个属性比较特殊，他不是参照原盒子的宽高值，而是原盒子的宽高值减去背景图片的宽高值所得到的剩余值，更为形象的说，下面这两个属性值是等价的："center center"和"50% 50%"，如果你设置了后者，背景图片会自动居中，不用像定位那样还需要transform偏移了。\n### （4）第四类——transform\n- translate3d()\n\t- 这个属性的含义就是在指定方向上进行2d偏移，它的参照物是自身的宽高。而transform3d()的第三个属性，指的是在z轴上的偏移，因为z-index的默认值是auto，所以%值并不能起作用，也就是说对translateZ()赋予百分比的值是无意义的。\n### （5）第五类——字体\n- font-size\n\t- 和height一样，是参照父盒子的字体大小的\n- line-height\n\t- 是给定的百分比值乘以元素最后计算出的字体大小\n- text-indent\n\t- 参照的是父元素的width\n### 总结\n- 相对于父盒子：\n\t- 参照父元素对应属性的有：width、height、font-size\n\t- 参照父元素的width的有：padding、margin、text-indent\n\t- 【特殊】position：relativeleft、right是相对于父元素的width，top和bottom是相对于参照物的height\n- 相对于盒子自身：\n\t- 盒子模型中的border-radius；\n\t- 背景中的background-size；\n\t- 在transform变换中，translate()、transform-origin、scale()还有我们拓展的与transform相似的zoom属性，他们都是参照自身的；\n\t- line-height行高与它的字体大小有关，所以参照的就是自身的font-size。\n- 相对于定位元素：\n\t- position：absolute、position：fixed;\n## 【css选择器】css选择器与优先级\n### 选择器\n- 基本选择器\n\t- *\t 通配选择器 \t选择文档中所以HTML元素\n\t- E\t 元素选择器\t选择指定类型的HTML元素\n\t- #id\t ID选择器\t选择指定ID属性值为“id”的任意类型元素\n\t- .class\t 类选择器\t选择指定class属性值为“class”的任意类型的任意多个元素\n\t-  div,span,img {color:Red}      群组选择器     即具有相同样式的标签分组显示\n- 层次选择器\n\t- E  F\t后代选择器\t选择匹配的F元素，且匹配的F元素被包含在匹配的E元素内\n\t- E>F\t子选择器\t选择匹配的F元素，且匹配的F元素所匹配的E元素的子元素\n\t- E+F\t相邻兄弟选择器\t选择匹配的F元素，且匹配的F元素紧位于匹配的E元素的后面\n\t- E~F\t通用选择器\t选择匹配的F元素，且位于匹配的E元素后的所有匹配的F元素\n- 动态伪类选择器\n\t- E:link\t    链接伪类选择器  选择匹配的E元素，而且匹配元素被定义了超链接并未被访问过。常用于链接描点上\n\t- E:visited   链接伪类选择器  选择匹配的E元素，而且匹配元素被定义了超链接并已被访问过。常用于链接描点上\n\t- E:active   选择匹配的E元素，且匹配元素被激活。常用于链接描点和按钮上\n\t- E:hover\t  选择匹配的E元素，且用户鼠标停留在元素E上。IE6及以下浏览器仅支持a:hover\n\t- E:focus    选择匹配的E元素，而且匹配元素获取焦点\n- 目标伪类选择器\n\t- E:target\t选择匹配E的所有元素，且匹配元素被相关URL指向\n- 元素状态伪类选择器\n\t- E:checked\t选中状态伪类选择器\t匹配选中的复选按钮或者单选按钮表单元素\n\t- E:enabled\t启用状态伪类选择器\t匹配所有启用的表单元素\n\t- E:disabled\t不可用状态伪类选择器\t匹配所有禁用的表单元素\n- 结构伪类选择器\n\t- E:fisrt-child\t作为父元素的第一个子元素的元素E。与E:nth-child(1)等同\n\t- E:last-child\t作为父元素的最后一个子元素的元素E。与E:nth-last-child(1)等同\n\t- E:root\t选择匹配元素E所在文档的根元素。在HTML文档中，根元素始终是html，此时该选择器与html类型选择器匹配的内容相同\n\t- E F:nth-child(n)\t选择父元素E的第n个子元素F。其中n可以是整数（1，2，3）、关键字（even，odd）、可以是公式（2n+1）,而且n值起始值为1，而不是0.\n\t- E F:nth-last-child(n)\t选择父元素E的倒数第n个子元素F。此选择器与E:nth-child(n)选择器计算顺序刚好相反，但使用方法都是一样的，其中：nth-last-child(1)始终匹配最后一个元素，与last-child等同\n\t- E:nth-of-type(n)\t选择父元素内具有指定类型的第n个E元素\n\t- E:nth-last-of-type(n)\t选择父元素内具有指定类型的倒数第n个E元素\n\t- E:first-of-type\t选择父元素内具有指定类型的第一个E元素，与E:nth-of-type(1)等同\n\t- E:last-of-tye\t选择父元素内具有指定类型的最后一个E元素，与E:nth-last-of-type(1)等同\n\t- E:only-child\t选择父元素只包含一个子元素，且该子元素匹配E元素\n\t- E:only-of-type\t选择父元素只包含一个同类型子元素，且该子元素匹配E元素\n\t- E:empty\t选择没有子元素的元素，而且该元素也不包含任何文本节点\n\t- 注意\n\t\t- （1），“ul>li:nth-child(3)”表达的并不是一定选择列表ul元素中的第3个子元素li，仅有列表ul中第3个li元素前不存在其他的元素，命题才有意义，否则不会改变列表第3个li元素的样式。\n\t\t- （2），:nth-child(n)  中参数只能是n，不可以用其他字母代替。\n\t\t- （3），:nth-child(odd) 选择的是奇数项，而使用:nth-last-child(odd) 选择的却是偶数项\n- 否定伪类选择器\n\t- E:not(F)\t匹配所有除元素F外的E元素\n- 属性选择器语法\n\t- [attribute]\t用于选取带有指定属性的元素。\n\t- [attribute=value]\t用于选取带有指定属性和值的元素。\n\t- [attribute~=value]\t用于选取属性值中包含指定词汇的元素。\n\t- [attribute|=value]\t用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。\n\t- [attribute^=value]\t匹配属性值以指定值开头的每个元素。\n\t- [attribute$=value]\t匹配属性值以指定值结尾的每个元素。\n\t- [attribute*=value]\t匹配属性值中包含指定值的每个元素。\n### 选择器优先级\n- 第一优先级：无条件优先的属性只需要在属性后面使用！important。它会覆盖页面内任何位置定义的元素样式。ie6不支持该属性。\n- 第二优先级：在html中给元素标签加style，即内联样式。该方法会造成css难以管理，所以不推荐使用。\n- 第三优先级：由一个或多个id选择器来定义。例如，#id{margin:0;}会覆盖.classname{margin:3pxl}\n- 第四优先级：由一个或多个类选择器、属性选择器、伪类选择器定义。如.classname{margin:3px}会覆盖div{margin:6px;}（伪类选择器 = 属性选择器 > 类选择器）\n- 第五优先级：由一个或多个标签选择器定义。如div{marigin:6px;}覆盖*{margin:10px；}\n- 第六优先级：通配选择器，如*{marigin:6px;}\n### 权重\n- 内联样式（1000）\n- ID选择符（0100）\n- 类、伪类、属性选择符（0010）\n- 类型、伪元素选择符（0001）\n- 通配符、相邻选择符等（0000）\n- 继承（没有权重）\n## 【清除浮动】CSS清除浮动的方法\n### （1）在浮动元素下添加一个空的div，并且为其设置了样式clear:both;\n- 这个规则只能影响使用清除的元素本身，不能影响其他元素,clear了隐藏div的both\n- 我们是通过在别的元素上清除浮动来实现撑开高度的， 而不是在浮动元素上\n### （2）通过BFC清除浮动引起的高度塌陷，原理是BFC在计算高度的时候会连同浮动元素的高度一起计算\n### （3）使用CSS中clearfix的after伪元素\n- 关于::after和::before的理解\n\t- 概述\n\t\t- 这两个伪元素相当于是对当前元素的装潢，他们并不是节点，不会出现在dom树中，但是在显示上具备节点的效果。\n\t- 使用\n\t\t- （1）::after和::before的使用很简单，可以认为其所在元素上存在一前一后的两个的元素，这两个元素默认是内联元素，但我们可以为其增添样式。\n\t\t- （2）必须设置content，否则这两个伪元素是无法显示出来的。而content属性，会作为这两个伪元素的内容嵌入他们中。\n\t\t- （3）::after和::before是虚拟元素，不会影响真正元素的所在文档的位置，对:first-child或者:last-child这种伪类选择不会造成影响。\n\t- 操作\n\t\t- ::after和::before是虚拟节点，而不是正在的节点，不在documont里面找到对应Node对象\n\t\t- console.log( document.querySelector("ul").childNodes)；得到的是一个只有3个节点的NodeList对象，而两个伪元素并不在对象中。因为::after和::before不是真正的节点，所以我们取不到他们，也不发设置点击等用户事件。\n\t\t- 可以通过css的接口获取其样式属性\n\t- ::after和::before使用的经验\n\t\t- 1.间隔符用法\n\t\t- 2.做border三角图标（常考）\n\t\t- 3.字符图标\n\t\t- 4.webfont的图标\n\t\t- 5.做单位、标签、表单必填标准\n\t\t- 7.实现一些标签对placeholder的支持\n\t\t- 8.实现文字图片居中对齐\n\t\t- 9.清除浮动\n\t- 总体可以分为四种用法：\n\t\t- 1.用css创建装饰性元素\n\t\t- 2.用css创建用于布局的元素，实现特殊布局的特殊需要\n\t\t- 3.做显示图标的实现手段\n\t\t- 4.配合attr显示属性值\n\t- 伪类与伪元素的差异\n\t\t- 伪类\n\t\t\t- 定义\n\t\t\t\t- CSS 伪类用于向某些选择器添加特殊的效果。\n\t\t\t- 功能\n\t\t\t\t- 获取不存在与DOM树中的信息。比如<a>标签的:link、visited等，这些信息不存在与DOM树结构中，只能通过CSS选择器来获取；\n\t\t\t\t- 获取不能被常规CSS选择器获取的信息。比如伪类:target，它的作用是匹配文档(页面)的URI中某个标志符的目标元素，例如我们可以通过如下代码来实现页面内的区域跳转：\n\t\t- 伪元素\n\t\t\t- 定义\n\t\t\t\t- 伪元素在DOM树中创建了一些抽象元素，这些抽象元素是不存在于文档语言里的（可以理解为html源码）\n\t\t\t\t- 通俗来说\n\t\t\t\t\t- 伪元素创建了一个虚拟容器，这个容器不包含任何DOM元素，但是可以包含内容。\n\t\t- 总结一下伪类与伪元素的特性及其区别：\n\t\t\t- （1）伪类本质上是为了弥补常规CSS选择器的不足，以便获取到更多信息；\n\t\t\t- （2）伪元素本质上是创建了一个有内容的虚拟容器；\n\t\t\t- （3）CSS3中伪类和伪元素的语法不同；\n\t\t\t- （4）可以同时使用多个伪类，而只能同时使用一个伪元素；\n## 【布局】CSS中的左右两栏定宽，中间自适应布局方案\n### 浮动布局\n  .container .left {         \n            float: left;\n            width: 200px;\n            background-color: orange;        \n            }\n        .container .main {         \n            background-color: rgb(0, 255, 106);           \n        }\n        .container .right {         \n            float: right;\n            width: 200px;\n            background-color: rgb(76, 0, 255);            \n        }\n<div class="container">\n        <div class=\'left\'>111111</div>\n        <div class="right">1111111</div>\n        <div class=\'center\'>111111111</div>\n    </div>\n- 左右浮动，中间不用浮动，DOM上中间要放最后\n### 定位布局\n        .container>div{\n            position: absolute;\n        }\n        .left{\n            left:0;\n            width: 300px;\n            background: red;\n        }\n         .center{\n            left: 300px;\n            right: 300px;\n            background: yellow;\n        }\n        .right{\n            right:0;\n            width: 300px;\n            background: blue;\n        }\n        <div class="left"></div>\n        <div class="center"></div>\n        <div class="right"></div>\n- 首先三个盒子都得绝对定位，左left：0，右right：0，中left：300px；right：300px，DOM正常\n### Flex布局\n       .container{\n            display: flex;\n        }\n        .left{\n            width: 300px;\n            background: red;\n        }\n        .center{\n            flex:1;\n            background: yellow;\n        }\n         .right{\n            width: 300px;\n            background: blue;\n        }\n- 父元素display：flex；左右设置宽度，中间flex：1，DOM正常\n### Grid布局\n.layout.grid .left-center-right{\n            width:100%;\n            display: grid;\n            grid-template-rows: 100px;\n            grid-template-columns: 300px auto 300px;\n        }\n        .layout.grid .left-center-right>div{\n        }\n        .layout.grid .left{\n            background: red;\n        }\n        .layout.grid .center{\n            background: yellow;\n        }\n        .layout.grid .right{\n            background: blue;\n        }\n### 表格布局\n      .container{\n            width:100%;\n            height: 100px;\n            display: table;\n        }\n        .containter>div{\n            display: table-cell;\n        }\n        .left{\n            width: 300px;\n            background: red;\n        }\n       .center{\n            background: yellow;\n        }\n         .right{\n            width: 300px;\n            background: blue;\n        }\n- 给父元素设置display：table；三个盒子都设置display：table-cell；左右设置宽度，DOM正常\n### 圣杯布局\n<template>\n<header>header</header>\n<section class="wrapper">\n    <section class="col main">main</section>\n    <aside class="col left">left</aside>\n    <aside class="col right">right</aside>\n</section>\n<footer>footer</footer>\n</template>\n- 诞生缘由\n\t- 希望中部 main 部分优先显示的话，是可以做布局优化的。提前即可优先渲染\n- 存在缺陷\n\t- 如果将浏览器无限变窄，「圣杯」将会「破碎」掉。当 main 部分的宽小于 left 部分时就会发生布局混乱。\n- CSS部分\n- 要点\n\t- （1）父元素设置左右padding，并创建BFC（设置overflow：hidden或其他）或使用伪元素清除浮动\n\t- （2）为三个盒子设置position：relative；float：left\n\t- （3）中间盒子宽度100%，左右定宽\n\t- （4）为左盒子设置margin-left：-100%，left：-100px；右盒子设置margin-left：-100px，right：-定宽px\n### 双飞翼布局\n<header>header</header>\n<section class="wrapper">\n    <section class="col main">\n        <section class="main-wrap">main</section>\n    </section>\n    <aside class="col left">left</aside>\n    <aside class="col right">right</aside>\n</section>\n<footer>footer</footer>\n- css部分\n- 缺点\n\t- 多加一层 dom 树节点，增加了 css 样式规则表和 dom 树合并成布局树的计算量\n- 要点\n\t- （1）父元素BFC清除浮动\n\t- （2）三个盒子全部左浮动\n\t- （3）中间main盒子宽度100%，其父盒子左右margin为定宽\n\t- （4）左盒子margin-left：-100%，右盒子margin-left：-定宽px\n### 选用情况\n',Wn={data:function(){return{MainComponent:Fn}}},Bn=Wn,Un=Object(v["a"])(Bn,Hn,qn,!1,null,"2581e55c",null),Gn=Un.exports,Vn=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},Xn=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("h4",{staticClass:"post"},[e("header",{staticClass:"post-header"},[e("h4",{staticClass:"post-title"},[t._v("\n\t\t\t「 CSS 」display属性居然有这么多\t\t")]),e("div",{staticClass:"post-meta"},[e("span",{staticClass:"post-time"},[e("span",{staticClass:"post-meta-item-icon"},[e("i",{staticClass:"fa fa-calendar-o"})]),e("span",{staticClass:"post-meta-item-text"},[t._v("发表于")]),e("time",{attrs:{datetime:"2020-01-03"}},[t._v("2020-01-03")])]),e("span",{staticClass:"post-category"},[t._v("\n\t\t\t\t | \n\t\t\t\t"),e("span",{staticClass:"post-meta-item-icon"},[e("i",{staticClass:"fa fa-folder-o"})]),e("span",{staticClass:"post-meta-item-text"},[t._v("分类于")]),e("span",[e("a",{attrs:{href:"https://www.dazhuanlan.com/frontend/",rel:"category tag"}},[t._v("前端")])])]),e("span",{staticClass:"post-comments-count"},[t._v("\n\t\t\t\t | \n\t\t\t\t"),e("span",{staticClass:"post-comments-count"},[t._v("没有评论")])])])]),e("div",{staticClass:"post-body"},[e("p",[t._v("思考一个简单的问题，如何用原生js实现元素的显示隐藏，也就是jQuery中show和hide方法。")]),e("p",[t._v("你肯定觉得特别简单，隐藏的话，直接"),e("code",[t._v("el.style.display='none';")])]),e("p",[t._v("那显示呢？"),e("code",[t._v("el.style.display='block'")]),t._v("？"),e("br")]),e("p",[t._v("display属性是css中最基本的属性。除了常用的"),e("code",[t._v("inline")]),t._v("，"),e("code",[t._v("inline-block")]),t._v("，"),e("code",[t._v("block")]),t._v("，"),e("code",[t._v("none")]),t._v("，其实display还有很多属性值。")]),e("p",[t._v("这个属性决定了元素的显示类型，也指定了元素怎么生成盒模型。")]),e("p",[t._v("分为外部显示类型和内部显示类型")]),e("figure",{staticClass:"highlight css"},[e("table",[e("tbody",[e("tr",[e("td",{staticClass:"gutter"},[e("pre",[e("span",{staticClass:"line"},[t._v("1")]),e("br"),e("span",{staticClass:"line"},[t._v("2")]),e("br"),e("span",{staticClass:"line"},[t._v("3")]),e("br"),e("span",{staticClass:"line"},[t._v("4")]),e("br"),e("span",{staticClass:"line"},[t._v("5")]),e("br"),e("span",{staticClass:"line"},[t._v("6")]),e("br"),e("span",{staticClass:"line"},[t._v("7")]),e("br"),e("span",{staticClass:"line"},[t._v("8")]),e("br"),e("span",{staticClass:"line"},[t._v("9")]),e("br"),e("span",{staticClass:"line"},[t._v("10")]),e("br"),e("span",{staticClass:"line"},[t._v("11")]),e("br"),e("span",{staticClass:"line"},[t._v("12")]),e("br"),e("span",{staticClass:"line"},[t._v("13")]),e("br"),e("span",{staticClass:"line"},[t._v("14")]),e("br"),e("span",{staticClass:"line"},[t._v("15")]),e("br"),e("span",{staticClass:"line"},[t._v("16")]),e("br"),e("span",{staticClass:"line"},[t._v("17")]),e("br"),e("span",{staticClass:"line"},[t._v("18")]),e("br"),e("span",{staticClass:"line"},[t._v("19")]),e("br"),e("span",{staticClass:"line"},[t._v("20")]),e("br"),e("span",{staticClass:"line"},[t._v("21")]),e("br"),e("span",{staticClass:"line"},[t._v("22")]),e("br"),e("span",{staticClass:"line"},[t._v("23")]),e("br"),e("span",{staticClass:"line"},[t._v("24")]),e("br"),e("span",{staticClass:"line"},[t._v("25")]),e("br"),e("span",{staticClass:"line"},[t._v("26")]),e("br"),e("span",{staticClass:"line"},[t._v("27")]),e("br"),e("span",{staticClass:"line"},[t._v("28")]),e("br"),e("span",{staticClass:"line"},[t._v("29")]),e("br"),e("span",{staticClass:"line"},[t._v("30")]),e("br"),e("span",{staticClass:"line"},[t._v("31")]),e("br"),e("span",{staticClass:"line"},[t._v("32")]),e("br"),e("span",{staticClass:"line"},[t._v("33")]),e("br"),e("span",{staticClass:"line"},[t._v("34")]),e("br"),e("span",{staticClass:"line"},[t._v("35")]),e("br"),e("span",{staticClass:"line"},[t._v("36")]),e("br"),e("span",{staticClass:"line"},[t._v("37")]),e("br"),e("span",{staticClass:"line"},[t._v("38")]),e("br"),e("span",{staticClass:"line"},[t._v("39")]),e("br"),e("span",{staticClass:"line"},[t._v("40")]),e("br"),e("span",{staticClass:"line"},[t._v("41")]),e("br"),e("span",{staticClass:"line"},[t._v("42")]),e("br"),e("span",{staticClass:"line"},[t._v("43")]),e("br"),e("span",{staticClass:"line"},[t._v("44")]),e("br"),e("span",{staticClass:"line"},[t._v("45")]),e("br"),e("span",{staticClass:"line"},[t._v("46")]),e("br"),e("span",{staticClass:"line"},[t._v("47")]),e("br"),e("span",{staticClass:"line"},[t._v("48")]),e("br"),e("span",{staticClass:"line"},[t._v("49")]),e("br"),e("span",{staticClass:"line"},[t._v("50")]),e("br"),e("span",{staticClass:"line"},[t._v("51")]),e("br"),e("span",{staticClass:"line"},[t._v("52")]),e("br"),e("span",{staticClass:"line"},[t._v("53")]),e("br"),e("span",{staticClass:"line"},[t._v("54")]),e("br"),e("span",{staticClass:"line"},[t._v("55")]),e("br"),e("span",{staticClass:"line"},[t._v("56")]),e("br"),e("span",{staticClass:"line"},[t._v("57")]),e("br"),e("span",{staticClass:"line"},[t._v("58")]),e("br"),e("span",{staticClass:"line"},[t._v("59")]),e("br"),e("span",{staticClass:"line"},[t._v("60")]),e("br"),e("span",{staticClass:"line"},[t._v("61")]),e("br"),e("span",{staticClass:"line"},[t._v("62")]),e("br"),e("span",{staticClass:"line"},[t._v("63")]),e("br")])]),e("td",{staticClass:"code"},[e("pre",[e("span",{staticClass:"line"}),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"comment"},[t._v("/* 在流式布局中的角色:行内元素还是块级元素 */")])]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("block")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("inline")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("run-in")]),t._v("; "),e("span",{staticClass:"comment"},[t._v("/* 大多数浏览器都不支持 */")])]),e("br"),e("span",{staticClass:"line"}),e("br"),e("span",{staticClass:"line"}),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"comment"},[t._v("/* <display-inside> values */")])]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"comment"},[t._v("/* 元素内部内容的格式化上下文的类型 */")])]),e("br"),e("span",{staticClass:"line"},[t._v("display: flow; // ??")]),e("br"),e("span",{staticClass:"line"},[t._v("display: ruby;// ??")]),e("br"),e("span",{staticClass:"line"}),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("flow-root")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("table")]),t._v(";"),e("span",{staticClass:"comment"},[t._v("/* 内部是table布局 */")])]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("flex")]),t._v(";"),e("span",{staticClass:"comment"},[t._v("/* 内部是flex布局 */")])]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("grid")]),t._v(";"),e("span",{staticClass:"comment"},[t._v("/* 内部是grid布局 */")])]),e("br"),e("span",{staticClass:"line"}),e("br"),e("span",{staticClass:"line"}),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"comment"},[t._v("/* <display-outside> plus <display-inside> values */")])]),e("br"),e("span",{staticClass:"line"},[t._v("display: block flow; // 可以写两个吗？")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("inline")]),t._v(" "),e("span",{staticClass:"selector-tag"},[t._v("table")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("flex")]),t._v(" "),e("span",{staticClass:"selector-tag"},[t._v("run-in")]),t._v(";")]),e("br"),e("span",{staticClass:"line"}),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"comment"},[t._v("/* <display-listitem> values */")])]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"comment"},[t._v("/* 将这个元素的外部显示类型变为 block，并将内部显示类型变为多个 list-item inline 盒。*/")])]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("list-item")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("list-item")]),t._v(" "),e("span",{staticClass:"selector-tag"},[t._v("block")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("list-item")]),t._v(" "),e("span",{staticClass:"selector-tag"},[t._v("inline")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("list-item")]),t._v(" "),e("span",{staticClass:"selector-tag"},[t._v("flow")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("list-item")]),t._v(" "),e("span",{staticClass:"selector-tag"},[t._v("flow-root")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("list-item")]),t._v(" "),e("span",{staticClass:"selector-tag"},[t._v("block")]),t._v(" "),e("span",{staticClass:"selector-tag"},[t._v("flow")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("list-item")]),t._v(" "),e("span",{staticClass:"selector-tag"},[t._v("block")]),t._v(" "),e("span",{staticClass:"selector-tag"},[t._v("flow-root")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("flow")]),t._v(" "),e("span",{staticClass:"selector-tag"},[t._v("list-item")]),t._v(" "),e("span",{staticClass:"selector-tag"},[t._v("block")]),t._v(";")]),e("br"),e("span",{staticClass:"line"}),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"comment"},[t._v("/* <display-internal> values */")])]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("table-row-group")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("table-header-group")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("table-footer-group")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("table-row")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("table-cell")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("table-column-group")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("table-column")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("table-caption")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("ruby-base")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("ruby-text")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("ruby-base-container")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("ruby-text-container")]),t._v(";")]),e("br"),e("span",{staticClass:"line"}),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"comment"},[t._v("/* <display-box> values */")])]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"comment"},[t._v("/* 是否显示 */")])]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("contents")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("none")]),t._v(";")]),e("br"),e("span",{staticClass:"line"}),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"comment"},[t._v("/* <display-legacy> values */")])]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("inline-block")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("inline-table")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("inline-flex")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("inline-grid")]),t._v(";")]),e("br"),e("span",{staticClass:"line"}),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"comment"},[t._v("/* Global values */")])]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("inherit")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("initial")]),t._v(";")]),e("br"),e("span",{staticClass:"line"},[e("span",{staticClass:"selector-tag"},[t._v("display")]),t._v(": "),e("span",{staticClass:"selector-tag"},[t._v("unset")]),t._v(";")]),e("br")])])])])])])]),e("footer",{staticClass:"post-footer"},[e("div",{staticClass:"post-tags"}),e("div",{staticClass:"post-nav"},[e("div",{staticClass:"post-nav-next post-nav-item"},[e("i",{staticClass:"fa fa-chevron-left"}),e("a",{attrs:{href:"https://www.dazhuanlan.com/2020/01/03/5e0edc461967d/",rel:"next"}},[t._v("celery学习笔记（二）——celery快速入门")])]),e("div",{staticClass:"post-nav-prev post-nav-item"},[e("a",{attrs:{href:"https://www.dazhuanlan.com/2020/01/03/5e0edc409da9d/",rel:"prev"}},[t._v("singleton")]),e("i",{staticClass:"fa fa-chevron-right"})])])]),e("div",{staticClass:"crp_related "},[e("h4",[t._v("相关文章")]),e("ul",[e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/11/15/5dce6d7da3283/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("css 命名：BEM, scoped css, css modules 与 css-in-js")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/13/385e4f756cb7/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("[CSS] CSS 之父使用 CSS 制作书籍")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/12/16/5df6dfdae6438/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("CSS reset 和 CSS normalize.css")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/04/4fe740d5172b/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("CSS Button Designer (CSS 按钮懒人设计器)")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/04/6ba49d13248b/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("［CSS］CSS Friendly Control Adapters&ndash;Menu…")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/09/fbf938e67dce/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("[CSS] CSS Web Note")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/10/2c8b2b94de53/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("[CSS] CSS 笔记")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/13/ace05a626434/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("[CSS] CSS 之父写的书")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/19/79c4f77a60f8/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("[ASP.NET][CSS](note)Web 服务器控件和 CSS 模式")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/07/03/cssdivnote%e5%9c%a8-ie8-firefox-chrome-css-%e7%bd%ae%e4%b8%ad%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%95/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("[CSS][div](note)在 IE8 FireFox Chrome CSS 置中解决方法")])])])]),e("div",{staticClass:"crp_clear"})])])])}],Qn={},Yn=Qn,Kn=Object(v["a"])(Yn,Vn,Xn,!1,null,"3f2d866b",null),Zn=Kn.exports,te=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},ne=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("h3",[t._v("var() 变量 ")]),e("pre",[t._v("    var()函数可以代替元素中任何属性中的值的任何部分。\n    var()函数不能作为属性名、选择器或者其他除了属性值之外的值。\n    （这样做通常会产生无效的语法或者一个没有关联到变量的值。）\n\n语法\n方法的第一个参数是要替换的自定义属性的名称。函数的可选第二个参数用作回退值。\n如果第一个参数引用的自定义属性无效，则该函数将使用第二个值。\n\nvar( custom-property-name , declaration-value? )\n\n\n:root {\n  --main-bg-color: pink;\n}\n\nbody {\n  background-color: var(--main-bg-color);\n}\n/* 后备值 */\n\n/* 在父元素样式中 */\n.component {\n  --text-color: #080; /* header-color 并没有被设定 */\n}\n\n/* 在 component 的样式中： */\n.component .header {\n  color: var(--header-color, blue); /* 此处 color 被回退到 blue */\n}\n\n.component .text {\n  color: var(--text-color, black);\n}\n")])])}],ee={},ae=ee,re=Object(v["a"])(ae,te,ne,!1,null,"7a88142a",null),se=re.exports,oe=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{},[e("q-markdown",{attrs:{src:t.MainComponent}})],1)},le=[],ie="\r\n\r\n## 1、变量 $ 使用\r\n\r\n我们可以通过变量来复用属性值，比如颜色、边框大小、图片路径等，这样可以做到更改一处，从而进行全局更改，从而实现“换肤”的功能。\r\n\r\n**实例1：我们的组件库，利用变量配置，进行统一更改组件的颜色、字体大小等（换肤）：**\r\n\r\n```\r\n$color-primary: #3ecacb;\r\n$color-success: #4fc48d;\r\n$color-warning: #f3d93f;\r\n$color-danger: #f6588e;\r\n$color-info: #27c6fa;\r\n```\r\n\r\n**实例2：图片的配置及全局引入**\r\n\r\n`Scss`中图片的使用，可能存在以下2个问题：\r\n\r\n（1）如果样式文件和使用该样式文件的`vue`文件不在同一目录会出现图片找不到\r\n\r\n（2）如果将图片路径配置变量写在`vue`文件的`style`中，但是该写法导致图片和样式分离\r\n\r\n我们可以采用将图片路径写成配置文件，然后进行全局引入，这样可以统一更改图片路径（并且该方法只会在使用相应图片时进行加载，不会导致额外性能问题）：\r\n\r\n```\r\n$common-path: './primary/assets/img/';\r\n$icon-see: $common-path+'icon-see.png';\r\n$icon-play: $common-path+'icon-play.png';\r\n$icon-comment: $common-path+'icon-comment.png';\r\n$icon-checkbox: $common-path+'icon-checkbox.png';\r\n```\r\n\r\n## 2、[@import](https://github.com/import) 导入Scss文件\r\n\r\n（1）`Css`中的`@import`规则，它允许在一个`css`文件中导入其他`css`文件。然而，后果是只有执行到`@import`时，浏览器才会去下载其他`css`文件，这导致页面加载起来特别慢。\r\n\r\n（2）`Scss`中的`@import`规则，不同的是，`scss`的`@import`规则在生成`css`文件时就把相关文件导入进来。这意味着所有相关的样式被归纳到了同一个`css`文件中，而无需发起额外的下载请求。\r\n\r\n**实例1：组件库中统一将组件的样式文件`import`进`index.sccs`中**，然后如果项目中有使用组件库的地方只需要在项目的入口处，引入`index.scss`文件，如下所示在`index.scss`文件中引入各组件的样式文件：\r\n\r\n```\r\n@import \"./base.scss\";\r\n@import \"./webupload.scss\";\r\n@import \"./message-hint.scss\";\r\n```\r\n\r\n## 3、局部文件命名的使用\r\n\r\n`scss`局部文件的文件名以下划线开头。这样，`scss`就不会在编译时单独编译这个文件输出`css`，而只把这个文件用作导入。在使用`scss`时，混合器`mixins`是最适合的使用场景，因为混合器不需要单独编译输出`css`文件。\r\n\r\n**实例1：将混合器的名称写成局部文件命名的方式，如下图所示**\r\n\r\n[![img](https://camo.githubusercontent.com/0785f0d677a7ea4da791cbd99953ebeb49d3e7ff/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f32322f313638373634303035653337336531383f696d61676556696577322f302f772f313238302f682f3936302f666f726d61742f776562702f69676e6f72652d6572726f722f31)](https://camo.githubusercontent.com/0785f0d677a7ea4da791cbd99953ebeb49d3e7ff/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f32322f313638373634303035653337336531383f696d61676556696577322f302f772f313238302f682f3936302f666f726d61742f776562702f69676e6f72652d6572726f722f31)\r\n\r\n## 4、Scss的嵌套功能和父选择器标识符\r\n\r\n我们可以使用嵌套功能和父选择器标识符 & 来缩减重复的代码，特别如果你`CSS`类采用`BEM`命名规范，样式类命名存在冗长的问题。使用此功能，能解决`BEM`命名冗长的问题，且样式可读性更高。\r\n\r\n**实例1：嵌套功能和父选择器标识符 & 解决BEM冗长问题：**\r\n\r\n```\r\n.tea-assignhw { \r\n &__top {  \r\n  margin: 0;  \r\n} \r\n &__content { \r\n   padding-left: 45px; \r\n }  \r\n&__gradeselect { \r\n   width: 158px;  \r\n }\r\n}\r\n```\r\n\r\n**实例2：**嵌套中使用子选择器、兄弟选择器和伪类选择器\r\n\r\n**（1）子选择器**\r\n\r\n```\r\n&__hint {\r\n  margin: 20px;  \r\n  font-size: 14px;  \r\n  > p:first-child { \r\n     font-weight: bold;  \r\n }\r\n}\r\n```\r\n\r\n**（2）兄弟选择器**\r\n\r\n```\r\n&__input { \r\n width: 220px; \r\n & + span {   \r\n   margin-left: 10px;  \r\n }\r\n}\r\n```\r\n\r\n**（3）伪类选择器**\r\n\r\n```\r\n&__browse {\r\n  background: url($btn-search) no-repeat;  \r\n&:hover {   \r\n  background: url($btn-search) -80px 0 no-repeat;  \r\n}  \r\n&:visited {  \r\n  background: url($btn-search) -160px 0 no-repeat; \r\n }\r\n}\r\n```\r\n\r\n## 5、[@mixin](https://github.com/mixin) 混合器和 [@extend](https://github.com/extend) 指令的使用\r\n\r\n变量使你能够复用属性值，但如果想要复用一大段规则呢？传统的做法是，如果在样式表\r\n\r\n中发现重复，就会把公共的规则抽离出来放到新的`CSS`类中。\r\n\r\n在`Scss`中可以使用混合器`@mixin`和`@extend`继承指令来解决以上提到的复用一大段规则的场景。但两者的使用场景又有啥区别呢？\r\n\r\n（1）`@mixin`主要的优势就是它能够接受参数。如果想传递参数，你会很自然地选择`@mixin`而不是[@extend](https://github.com/extend)，因为`@extend`不能够接受参数\r\n\r\n（2）因为混合器规则都混入到其他类中，所以在输出的样式表中不能完全避免重复。选择器继承的意思就是让一个选择器能够复用另一个选择器的所有样式，但又不重复输出这些样式属性；即使用`@extend`产生 [DRY CSS](https://link.juejin.im/?target=http%3A%2F%2Fvanseodesign.com%2Fcss%2Fdry-principles%2F)风格的代码（Don't repeat yourself）\r\n\r\n综上所述，如果你需要传参数，只能使用`@mixin`混合器，否则用`@extend`继承来实现更优。\r\n\r\n**实例1：[@mixin](https://github.com/mixin)混合器的使用**\r\n\r\n```\r\n@mixin paneactive($image, $level, $vertical) { \r\n  background: url($image) no-repeat $level $vertical;  \r\n  height: 100px;  \r\n  width: 30px; \r\n  position: relative;  \r\n  top: 50%;\r\n}\r\n&--left-active {  \r\n  @include paneactive($btn-flip, 0, 0);\r\n}\r\n&--right-active { \r\n  @include paneactive($btn-flip, 0, -105px);\r\n}\r\n```\r\n\r\n**实例2：[@extend](https://github.com/extend)继承的使用**\r\n\r\n```\r\n.common-mod {  \r\n  height: 250px;  \r\n  width: 50%;  \r\n  background-color: #fff;  \r\n  text-align: center;\r\n}\r\n&-mod { \r\n  @extend .common-mod;  \r\n  float: right;\r\n}\r\n&-mod2 { \r\n  @extend .common-mod;\r\n}\r\n```\r\n\r\n## 6、[@mixin](https://github.com/mixin) 混合器默认参数值的使用\r\n\r\n在`@include`混合器时不必传入所有的参数，我们可以给参数指定一个默认值，如果所需要传的参数是 默认值，则`@include`时可以省略该参数；如果所需要传的参数不是默认值，则`@include`时则传入新的参数。\r\n\r\n**实例1：[@mixin](https://github.com/mixin)混合器默认参数值的使用**\r\n\r\n```\r\n@mixin pane($dir: left) {  \r\n  width: 35px; \r\n  display: block;  \r\n  float: $dir;  \r\n  background-color: #f1f1f1;\r\n}\r\n&__paneleft { \r\n  @include pane;\r\n}\r\n&__paneright {\r\n  @include pane(right);\r\n}\r\n```\r\n\r\n## 7、#{} 插值的使用\r\n\r\n通过 #{} 插值语句可以在选择器或属性名中使用变量。当有两个页面的样式类似时，我们会将类似的样式抽取成页面混合器，但两个不同的页面样式的命名名称根据`BEM`命名规范不能一样，这时我们可使用插值进行动态命名。\r\n\r\n**实例1：页面级混合器中的类名利用#{}插值进行动态设置**\r\n\r\n```\r\n@mixin home-content($class) { \r\n .#{$class} {   \r\n   position: relative;    \r\n   background-color: #fff;    \r\n   overflow-x: hidden;    \r\n   overflow-y: hidden;    \r\n &--left {     \r\n    margin-left: 160px;  \r\n }    \r\n &--noleft {  \r\n    margin-left: 0;  \r\n } \r\n }\r\n}\r\n```\r\n\r\n## 8、运算的使用\r\n\r\n`SassScript` 支持数字的加减乘除、取整等运算 (+, -, *, /, %)\r\n\r\n**实例1：input组件根据输入框的高度设置左右内边距，如下所示：**\r\n\r\n```\r\n.ps-input { \r\n   display: block;  \r\n   &__inner {   \r\n    -webkit-appearance: none;  \r\n     padding-left: #{$--input-height + 10\r\n   };    \r\n     padding-right: #{$--input-height + 10\r\n   };    \r\n  }\r\n}\r\n```\r\n\r\n## 9、相关scss自带函数的应用\r\n\r\n`scss`自带一些函数，例如`hsl`、`mix`函数等。\r\n\r\n**实例1：button组件的点击后颜色是将几种颜色根据一定的比例混合在一起，生成另一种颜色。**如下所示：\r\n\r\n```\r\n&:focus { \r\n  color: mix($--color-white, $--color-primary, $--button-hover-tint-percent);  \r\n  border-color: transparent;  \r\n  background-color: transparent;}\r\n&:active {  \r\n  color: mix($--color-black, $--color-primary, $--button-active-shade-percent); \r\n  border-color: transparent;  background-color: transparent;\r\n}\r\n```\r\n\r\n## 10、相关scss自带函数的应用\r\n\r\n`@for`指令可以在限制的范围内重复输出样式，每次按变量的值对输出结果进行变动。\r\n\r\n**实例1：例如项目中需要设置hwicon类底下第2到8个div子节点需设置样式**，如下所示：\r\n\r\n```\r\n@for $i from 2 through 8 {  \r\n.com-hwicon {    \r\n > div:nth-child(#{$i}) {   \r\n   position: relative;    \r\n   float: right;   \r\n  }  \r\n }\r\n}\r\n```\r\n\r\n## 11、each遍历、map数据类型、@mixin/[@include](https://github.com/include)混合器、#{}插值 结合使用\r\n\r\n可通过结合`each`遍历、`map`数据类型、`@mixin/@include`混合器、#{}插值，从而生成不同的选择器类，并且每个选择器类中的背景图片不同，如下所示：\r\n\r\n```\r\n$img-list: (  \r\n (accessimg, $papers-access),   \r\n (folderimg, $papers-folder),  \r\n (bmpimg, $papers-bmp),   \r\n (xlsimg, $papers-excel),   \r\n (xlsximg, $papers-excel),   \r\n (gifimg, $papers-gif),  \r\n (jpgimg, $papers-jpg),   \r\n (unknownimg, $papers-unknown)\r\n);\r\n\r\n@each $label, $value in $img-list { \r\n .com-hwicon__#{$label} {\r\n    @include commonImg($value); \r\n }\r\n}\r\n```\r\n\r\n",ce={data:function(){return{MainComponent:ie}}},pe=ce,be=Object(v["a"])(pe,oe,le,!1,null,"1cb638cc",null),ue=be.exports,ve=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},ge=[],me={},_e=me,de=Object(v["a"])(_e,ve,ge,!1,null,"52b39067",null),he=de.exports,fe=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},ye=[],Se={},we=Se,ke=Object(v["a"])(we,fe,ye,!1,null,"28bf77a8",null),xe=ke.exports,Ce=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},je=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("p",[t._v("\n             1:53:39\nhttps://mp.weixin.qq.com/tmpl/0_4912712-zh_CN-zip.html  "),e("br"),t._v("\n\n 1:54:52\n埋点文章 https://github.com/ceerqingting/issueBlog/issues/14 "),e("br"),t._v("\n\n 1:55:09\nhttps://www.infoq.cn/article/event-tracking-in-zhihu  "),e("br")]),e("a",{attrs:{href:"https://www.dazhuanlan.com/"}},[t._v("https://www.dazhuanlan.com/")])])}],Pe={},Te=Pe,Ee=Object(v["a"])(Te,Ce,je,!1,null,"03383912",null),Oe=Ee.exports,Me={components:{m1:Ln,m2:Gn,m3:Zn,m4:se,m5:ue,m6:he,m7:xe,m8:Oe},data:function(){return{tab:"m1",tabs:[{label:"显隐",value:"m1"},{label:"全面梳理",value:"m2"},{label:"display",value:"m3"},{label:"var()",value:"m4"},{label:"SASS总结",value:"m5"}]}}},Ae=Me,Ne=Object(v["a"])(Ae,Nn,In,!1,null,"751bd512",null),Ie=Ne.exports,De=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+t.value,label:n+1+"."+t.label}})})),1),e("div",{staticClass:"q-mx-lg"},[e(""+t.tab,{tag:"component"})],1)],1)},ze=[],$e=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},Re=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("div",{staticClass:"post"},[e("h4",{staticClass:"postTitle"},[t._v("\n     javascript中的12种循环遍历方法1\n    ")]),e("div",{staticClass:"clear"}),e("div",{staticClass:"postBody"},[e("div",{staticClass:"blogpost-body ",attrs:{id:"cnblogs_post_body"}},[e("p",[t._v("1：for循环")]),e("p",[t._v("let arr = [1,2,3];")]),e("p",[t._v("for(let i =0;i<arr.length;i++){")]),e("p",[t._v("console.log(i,arr[i])")]),e("p",[t._v("}")]),e("p",[t._v("//for循环是js中最常用的一个循环工具，经常用来数组的循环遍历，")]),e("p",[t._v("2：for in循环")]),e("p",[t._v("let obj = {name: 'xiao' ,age:'24'}")]),e("p",[t._v("for(let i in obj){")]),e("p",[t._v("console.log(i,obj[i]);")]),e("p",[t._v("}")]),e("p",[t._v("\n          //for in 循环主要用于遍历普通对象，i 代表对象的 key 值，obj[i]\n          代表对应的\n          value,当用它来遍历数组时候，多数情况下也能达到同样的效果，但是你不要这么做，这是有风险的，因为\n          i\n          输出为字符串形式，而不是数组需要的数字下标，这意味着在某些情况下，会发生字符串运算，导致数据错误，比如：'52'+1\n          = '521' 而不是我们需要的 53。另外 for in\n          循环的时候，不仅遍历自身的属性，还会找到 prototype\n          上去，所以最好在循环体内加一个判断，就用\n          obj[i].hasOwnProperty(i)，这样就避免遍历出太多不需要的属性。\n        ")]),e("p",[t._v("3：while循环")]),e("div",{staticClass:"line number1 index0 alt2"},[e("code",{staticClass:"js plain"},[t._v("let cars=[")]),e("code",{staticClass:"js string"},[t._v('"BMW"')]),e("code",{staticClass:"js plain"},[t._v(",")]),e("code",{staticClass:"js string"},[t._v('"Volvo"')]),e("code",{staticClass:"js plain"},[t._v(",")]),e("code",{staticClass:"js string"},[t._v('"Saab"')]),e("code",{staticClass:"js plain"},[t._v(",")]),e("code",{staticClass:"js string"},[t._v('"Ford"')]),e("code",{staticClass:"js plain"},[t._v("];")])]),e("div",{staticClass:"line number2 index1 alt1"},[e("span",{staticStyle:{"font-family":"monospace"}},[t._v("let")]),t._v(" "),e("code",{staticClass:"js plain"},[t._v("i=0;")])]),e("div",{staticClass:"line number3 index2 alt2"},[e("code",{staticClass:"js keyword"},[t._v("while")]),e("code",{staticClass:"js plain"},[t._v("(cars[i])")])]),e("div",{staticClass:"line number4 index3 alt1"},[e("code",{staticClass:"js plain"},[t._v("{")])]),e("div",{staticClass:"line number5 index4 alt2"},[e("code",{staticClass:"js plain"},[t._v("console.log(cars[i] + ")]),e("code",{staticClass:"js string"},[t._v('"<br>"')]),e("code",{staticClass:"js plain"},[t._v(")")])]),e("div",{staticClass:"line number6 index5 alt1"},[e("code",{staticClass:"js plain"},[t._v("i++;")])]),e("div",{staticClass:"line number7 index6 alt2"},[e("code",{staticClass:"js plain"},[t._v("};")])]),e("div",{staticClass:"line number7 index6 alt2"},[t._v("4：do while循环")]),e("div",{staticClass:"line number7 index6 alt2"},[e("div",{staticClass:"line number1 index0 alt2"},[e("code",{staticClass:"js plain"},[t._v("let i = 3;")])]),e("div",{staticClass:"line number2 index1 alt1"},[e("code",{staticClass:"js keyword"},[t._v("do")]),e("code",{staticClass:"js plain"},[t._v("{")])]),e("div",{staticClass:"line number3 index2 alt2"},[e("code",{staticClass:"js spaces"},[t._v(" ")]),e("code",{staticClass:"js plain"},[t._v("console.log(i)")])]),e("div",{staticClass:"line number4 index3 alt1"},[e("code",{staticClass:"js spaces"},[t._v(" ")]),e("code",{staticClass:"js plain"},[t._v("i--;")])]),e("div",{staticClass:"line number5 index4 alt2"},[e("code",{staticClass:"js plain"},[t._v("}")])]),e("div",{staticClass:"line number6 index5 alt1"},[e("code",{staticClass:"js keyword"},[t._v("while")]),e("code",{staticClass:"js plain"},[t._v("(i>0)")])]),e("div",{staticClass:"line number6 index5 alt1"},[t._v("\n            //do while 循环是 while\n            循环的一个变体，它首先执行一次操作，然后才进行条件判断，是 true\n            的话再继续执行操作，是 false 的话循环结束。\n          ")]),e("div",{staticClass:"line number6 index5 alt1"},[t._v("5：Array forEach循环")]),e("div",{staticClass:"line number6 index5 alt1"},[e("div",{staticClass:"line number1 index0 alt2"},[e("code",{staticClass:"js plain"},[t._v("let arr = [1,2,3];")])]),e("div",{staticClass:"line number2 index1 alt1"},[e("code",{staticClass:"js plain"},[t._v("arr.forEach(")]),e("code",{staticClass:"js keyword"},[t._v("function")]),e("code",{staticClass:"js plain"},[t._v("(i,index){")])]),e("div",{staticClass:"line number3 index2 alt2"},[e("code",{staticClass:"js spaces"},[t._v(" ")]),e("code",{staticClass:"js plain"},[t._v("console.log(i,index)")])]),e("div",{staticClass:"line number4 index3 alt1"},[e("code",{staticClass:"js plain"},[t._v("})")])]),e("div",{staticClass:"line number4 index3 alt1"},[t._v("\n              //forEach循环，循环数组中每一个元素并采取操作， 没有返回值，\n              可以不用知道数组长度,他有三个参数，只有第一个是必需的，代表当前下标下的\n              value。\n              "),e("p",[t._v("\n                另外请注意，forEach\n                循环在所有元素调用完毕之前是不能停止的，它没有 break\n                语句，如果你必须要停止，可以尝试 try catch\n                语句，就是在要强制退出的时候，抛出一个 error 给 catch\n                捕捉到，然后在 catch 里面\n                return，这样就能中止循环了，如果你经常用这个方法，最好自定义一个这样的\n                forEach 函数在你的库里。\n              ")]),e("p",[t._v("6：Array map（)方法")]),e("p",[t._v("let  arr = [1,2,3];")]),e("p",[t._v("let tt = arr.map(function(i){")]),e("p",[t._v("console.log(i);")]),e("p",[t._v("return i*2;")]),e("p",[t._v("})")]),e("p",[t._v("\n                //map()\n                方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。"),e("br"),t._v("注意：map\n                和 forEach 方法都是只能用来遍历数组，不能用来遍历普通对象。\n              ")]),e("p",[t._v("7:Array filter()方法")]),e("p",[t._v("let arr = [1,2,3];")]),e("p",[t._v("let tt= arr.filter(function(i){")]),e("p",[t._v("return i > 1;")]),e("p",[t._v("})")]),e("p",[t._v("\n                //filter 方法是 Array\n                对象内置方法，它会返回通过过滤的元素，不改变原来的数组。\n              ")]),e("p",[t._v("8:Array some()方法")]),e("p",[t._v("let arr =[1,2,3];")]),e("p",[t._v("let tt = arr.some(function(i){")]),e("p",[t._v("return i > 1;")]),e("p",[t._v("})")]),e("p",[t._v("\n                //some()\n                方法用于检测数组中的元素是否满足指定条件（函数提供）,返回\n                boolean 值，不改变原数组。\n              ")]),e("p",[t._v("9:Array every()方法")]),e("p",[t._v("let arr = [1,2,3];")]),e("p",[t._v("let tt = arr.some(function(i){")]),e("p",[t._v("return i > 1;")]),e("p",[t._v("})")]),e("p",[t._v("\n                //every()\n                方法用于检测数组所有元素是否都符合指定条件（通过函数提供），返回\n                boolean 值，不改变原数组。\n              ")]),e("p",[t._v("10:Array reduce()方法")]),e("p",[t._v("let arr = [1,2,3];")]),e("p",[t._v("let ad = arr.reduce(function(i,j){")]),e("p",[t._v("return i + j;")]),e("p",[t._v("})")]),e("p",[t._v("\n                //reduce()\n                方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。\n              ")]),e("p",[t._v("11:Array reduceRight()方法")]),e("p",[t._v("let arr = [1,2,3];")]),e("p",[t._v("let ad = arr.reduceRight(function(i,j){")]),e("p",[t._v("return i + j;")]),e("p",[t._v("})")]),e("p",[t._v("\n                //reduceRight()方法,和 reduce()\n                功能是一样的，它是从数组的末尾处向前开始计算。\n              ")]),e("p",[t._v("12:for of 循环")]),e("p",[t._v("let arr = ['name','age'];")]),e("p",[t._v("for(let i of arr){")]),e("p",[t._v("console.log(i);")]),e("p",[t._v("}")]),e("p",[t._v("\n                //for of 循环是 Es6 中新增的语句，用来替代 for in 和\n                forEach，它允许你遍历 Arrays（数组）, Strings（字符串）,\n                Maps（映射）, Sets（集合）等可迭代(Iterable\n                data)的数据结构,注意它的兼容性。\n              ")])])])])])])])])}],Je={},Le=Je,He=Object(v["a"])(Le,$e,Re,!1,null,"21e470b1",null),qe=He.exports,Fe=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},We=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("article",{staticClass:"post"},[e("header",{staticClass:"post-header"},[e("h4",{staticClass:"post-title"},[t._v("\n          什么是Event Loop？\n        ")])]),e("div",{staticClass:"post-body"},[e("h4",[t._v("\n    \n          为什么JavaScript是单线程？\n        ")]),e("p",[t._v("\n          JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。\n        ")]),e("p",[t._v("\n          JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？\n        ")]),e("p",[t._v("\n          所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。\n        ")]),e("p",[t._v("\n          为了利用多核CPU的计算能力，HTML5提出Web\n          Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。\n        ")]),e("h4",{attrs:{id:"任务队列"}},[e("a",{staticClass:"headerlink",attrs:{href:"#任务队列",title:"任务队列"}}),t._v("任务队列\n        ")]),e("p",[t._v("\n          单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。\n        ")]),e("p",[t._v("\n          如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。\n        ")]),e("p",[t._v("\n          JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。\n        ")]),e("p",[t._v("\n          于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task\n          queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。\n        ")]),e("p",[t._v("\n          具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）\n        ")]),e("ol",[e("li",[t._v("\n            所有同步任务都在主线程上执行，形成一个执行栈（execution context\n            stack）。\n          ")]),e("li",[t._v("\n            主线程之外，还存在一个”任务队列”（task\n            queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。\n          ")]),e("li",[t._v("\n            一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。\n          ")]),e("li",[t._v("主线程不断重复上面的第三步。")])]),e("p",[t._v("下图就是主线程和任务队列的示意图。")]),e("p",[t._v("任务队列")]),e("p",[t._v("\n          只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。\n        ")]),e("p",[t._v("这个过程会不断重复。")]),e("h4",{attrs:{id:"事件和回调函数"}},[e("a",{staticClass:"headerlink",attrs:{href:"#事件和回调函数",title:"事件和回调函数"}}),t._v("事件和回调函数\n        ")]),e("p",[t._v("\n          “任务队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。\n        ")]),e("p",[t._v("\n          “任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。\n        ")]),e("p",[t._v("\n          所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。\n        ")]),e("p",[t._v("\n          “任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。\n        ")]),e("h4",{attrs:{id:"Event-Loop"}},[e("a",{staticClass:"headerlink",attrs:{href:"#Event-Loop",title:"Event Loop"}}),t._v("Event\n          Loop\n        ")]),e("p",[t._v("\n          主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event\n          Loop（事件循环）。\n        ")]),e("p",[t._v("\n          为了更好地理解Event Loop，请看下图（转引自Philip Roberts的演讲《Help,\n          I’m stuck in an event-loop》）。\n        ")]),e("p",[t._v("\n          上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在”任务队列”中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。\n        ")]),e("p",[t._v("\n          执行栈中的代码（同步任务），总是在读取”任务队列”（异步任务）之前执行。请看下面这个例子。\n        ")]),e("pre",[e("code",[t._v("var req = new XMLHttpRequest();\nreq.open('GET', url);    \nreq.onload = function (){};    \nreq.onerror = function (){};    \nreq.send();\n")])]),e("p",[t._v("\n          上面代码中的req.send方法是Ajax操作向服务器发送数据，它是一个异步任务，意味着只有当前脚本的所有代码执行完，系统才会去读取”任务队列”。所以，它与下面的写法等价。\n        ")]),e("pre",[e("code",[t._v("var req = new XMLHttpRequest();\nreq.open('GET', url);\nreq.send();\nreq.onload = function (){};    \nreq.onerror = function (){};   \n")])]),e("p",[t._v("\n          也就是说，指定回调函数的部分（onload和onerror），在send()方法的前面或后面无关紧要，因为它们属于执行栈的一部分，系统总是执行完它们，才会去读取”任务队列”。\n        ")]),e("h4",{attrs:{id:"定时器"}},[e("a",{staticClass:"headerlink",attrs:{href:"#定时器",title:"定时器"}}),t._v("定时器\n        ")]),e("p",[t._v("\n          除了放置异步任务的事件，”任务队列”还可以放置定时事件，即指定某些代码在多少时间之后执行。这叫做”定时器”（timer）功能，也就是定时执行的代码。\n        ")]),e("p",[t._v("\n          定时器功能主要由setTimeout()和setInterval()这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行。以下主要讨论setTimeout()。\n        ")]),e("p",[t._v("\n          setTimeout()接受两个参数，第一个是回调函数，第二个是推迟执行的毫秒数。\n        ")]),e("pre",[e("code",[t._v("console.log(1);\nsetTimeout(function(){console.log(2);},1000);\nconsole.log(3);\n")])]),e("p",[t._v("\n          上面代码的执行结果是1，3，2，因为setTimeout()将第二行推迟到1000毫秒之后执行。\n        ")]),e("p",[t._v("\n          如果将setTimeout()的第二个参数设为0，就表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。\n        ")]),e("pre",[e("code",[t._v("setTimeout(function(){console.log(1);}, 0);\nconsole.log(2);\n")])]),e("p",[t._v("\n          上面代码的执行结果总是2，1，因为只有在执行完第二行以后，系统才会去执行”任务队列”中的回调函数。\n        ")]),e("p",[t._v("\n          总之，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。"),e("br"),t._v("HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout()。\n        ")]),e("p",[t._v("\n          需要注意的是，setTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。\n        ")]),e("h4",{attrs:{id:"Node-js的Event-Loop"}},[e("a",{staticClass:"headerlink",attrs:{href:"#Node-js的Event-Loop",title:"Node.js的Event Loop"}}),t._v("Node.js的Event Loop\n        ")]),e("p",[t._v("\n          Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。"),e("br"),t._v("请看下面的示意图（作者@BusyRich）。\n        ")]),e("p",[t._v("Node.js")]),e("p",[t._v("根据上图，Node.js的运行机制如下。")]),e("ol",[e("li",[t._v("V8引擎解析JavaScript脚本。")]),e("li",[t._v("解析后的代码，调用Node API。")]),e("li",[t._v("\n            libuv库负责Node\n            API的执行。它将不同的任务分配给不同的线程，形成一个Event\n            Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。\n          ")]),e("li",[t._v("V8引擎再将结果返回给用户。")])]),e("p",[t._v("\n          除了setTimeout和setInterval这两个方法，Node.js还提供了另外两个与”任务队列”有关的方法：process.nextTick和setImmediate。它们可以帮助我们加深对”任务队列”的理解。\n        ")]),e("p",[t._v("\n          process.nextTick方法可以在当前”执行栈”的尾部—-下一次Event\n          Loop（主线程读取”任务队列”）之前—-触发回调函数。也就是说，它指定的任务总是发生在所有异步任务之前。setImmediate方法则是在当前”任务队列”的尾部添加事件，也就是说，它指定的任务总是在下一次Event\n          Loop时执行，这与setTimeout(fn, 0)很像。请看下面的例子（via\n          StackOverflow）。\n        ")]),e("pre",[e("code",[t._v("process.nextTick(function A() {\n    console.log(1);\n    process.nextTick(function B(){console.log(2);});\n});\n\nsetTimeout(function timeout() {\n    console.log('TIMEOUT FIRED');\n}, 0)\n// 1\n// 2\n// TIMEOUT FIRED\n")])]),e("p",[t._v("\n          上面代码中，由于process.nextTick方法指定的回调函数，总是在当前”执行栈”的尾部触发，所以不仅函数A比setTimeout指定的回调函数timeout先执行，而且函数B也比timeout先执行。这说明，如果有多个process.nextTick语句（不管它们是否嵌套），将全部在当前”执行栈”执行。\n        ")]),e("p",[t._v("现在，再看setImmediate。")]),e("pre",[e("code",[t._v("setImmediate(function A() {\n    console.log(1);\n    setImmediate(function B(){console.log(2);});\n});\n\nsetTimeout(function timeout() {\n    console.log('TIMEOUT FIRED');\n}, 0);\n")])]),e("p",[t._v("\n          上面代码中，setImmediate与setTimeout(fn,0)各自添加了一个回调函数A和timeout，都是在下一次Event\n          Loop触发。那么，哪个回调函数先执行呢？答案是不确定。运行结果可能是1–TIMEOUT\n          FIRED–2，也可能是TIMEOUT FIRED–1–2。\n        ")]),e("p",[t._v("\n          令人困惑的是，Node.js文档中称，setImmediate指定的回调函数，总是排在setTimeout前面。实际上，这种情况只发生在递归调用的时候。\n        ")]),e("pre",[e("code",[t._v("setImmediate(function (){\n    setImmediate(function A() {\n    console.log(1);\n    setImmediate(function B(){console.log(2);});\n});\n\nsetTimeout(function timeout() {\n    console.log('TIMEOUT FIRED');\n}, 0);\n});\n// 1\n// TIMEOUT FIRED\n// 2\n")])]),e("p",[t._v("\n          上面代码中，setImmediate和setTimeout被封装在一个setImmediate里面，它的运行结果总是1–TIMEOUT\n          FIRED–2，这时函数A一定在timeout前面触发。至于2排在TIMEOUT\n          FIRED的后面（即函数B在timeout后面触发），是因为setImmediate总是将事件注册到下一轮Event\n          Loop，所以函数A和timeout是在同一轮Loop执行，而函数B在下一轮Loop执行。\n        ")]),e("p",[t._v("\n          我们由此得到了process.nextTick和setImmediate的一个重要区别：多个process.nextTick语句总是在当前”执行栈”一次执行完，多个setImmediate可能则需要多次loop才能执行完。事实上，这正是Node.js\n          10.0版添加setImmediate方法的原因，否则像下面这样的递归调用process.nextTick，将会没完没了，主线程根本不会去读取”事件队列”！\n        ")]),e("pre",[e("code",[t._v("process.nextTick(function foo() {\n    process.nextTick(foo);\n});\n")])]),e("p",[t._v("\n          事实上，现在要是你写出递归的process.nextTick，Node.js会抛出一个警告，要求你改成setImmediate。\n        ")]),e("p",[t._v("\n          另外，由于process.nextTick指定的回调函数是在本次”事件循环”触发，而setImmediate指定的是在下次”事件循环”触发，所以很显然，前者总是比后者发生得早，而且执行效率也高（因为不用检查”任务队列”）。\n        ")])]),e("footer",{staticClass:"post-footer"},[e("div",{staticClass:"post-tags"}),e("div",{staticClass:"post-nav"},[e("div",{staticClass:"post-nav-next post-nav-item"},[e("i",{staticClass:"fa fa-chevron-left"}),e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/11/06/5dc2c545b1c36/",rel:"next"}},[t._v("笔记23")])]),e("div",{staticClass:"post-nav-prev post-nav-item"},[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/11/06/5dc2c4f9a8f83/",rel:"prev"}},[t._v("Hexo Build")]),e("i",{staticClass:"fa fa-chevron-right"})])])]),e("div",{staticClass:"crp_related "},[e("h4",[t._v("相关文章")]),e("ul",[e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/04/98fb83cd7703/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("[Javascript] for loop vs for-in loop 与性能改善")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/30/5d914e8611fc2/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("for loop vs for-in loop 與效能改善")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/02/ed62ffaa05bc/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("[ASP.NET] for loop 与 foreach")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/04/2cdae5cc2626/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("Self referencing loop detected for property")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/04/1c1dc87e826f/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("[cmd命令学习心得]循环(for loop)")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/04/da5085d3ca0f/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("Flex Multi-URLLoader with For Loop")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/05/ca322d7f295d/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("[MSSQL][PLSQL]FOR LOOP")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/09/12/cdaa76e25a15/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("[Sass][Visual Studio] SASS 进阶使用 (Media, color…")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/07/03/vb6vbavb-net-%e5%86%8d%e8%b0%88-timer-%e6%8e%a7%e4%bb%b6-%e6%97%b6%e9%97%b4%e5%88%86%e8%be%a8%e7%8e%87%e8%bf%87%e4%bd%8e%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%95%ef%bc%88%e4%ba%8c%ef%bc%89/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("[VB6][VBA][VB.net] 再谈 Timer 控件 -\n                时间分辨率过低的解决方法（二）用…")])])]),e("li",[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/07/03/teaching-silverlight-30%e7%a7%92%e5%bf%ab%e9%80%9f%e5%bb%ba%e7%ab%8b%e6%b8%b8%e6%88%8f%e5%be%aa%e7%8e%af-game-loop/",target:"_blank"}},[e("span",{staticClass:"crp_title"},[t._v("[Teaching] [Silverlight] 30秒快速建立游戏循环 (Game Loop)")])])])]),e("div",{staticClass:"crp_clear"})])])])}],Be={},Ue=Be,Ge=Object(v["a"])(Ue,Fe,We,!1,null,"243e6c94",null),Ve=Ge.exports,Xe=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{},[e("q-markdown",{attrs:{src:t.MainComponent}})],1)},Qe=[],Ye='# js\n\n## 作用域\n\n### 执行上下文\n\n- 变量对象 AO\n\n\t- 变量对象是与执行上下文相关的数据作用域\n\n\t\t- 全局上下文\n\n\t\t\t- 变量对象即全局对象\n\n\t\t- 函数上下文\n\n\t\t\t- 活动对象，是由引擎实现的，在执行上下文中被激活\n\n\t\t- AO（活动变量） = VO（变量对象 + function parameters + arguments\n\n\t- 变量对象在执行过程中的变化\n\n\t\t- 进入执行上下文\n\n\t\t\t- 创建变量对象\n\n\t\t- 代码执行\n\n\t\t\t- 顺序执行代码，修改上下文变量的值\n\n\t\t- 执行完毕，上下文弹出\n\n\t- 函数的所有形参\n\t- 函数声明\n\t- 变量声明\n\n- 作用域链 Scope\n\n\t- 函数被创建，保存函数父作用域到函数[[scope]]属性\n\t- 函数执行，进入上下文吗，函数作用域压入栈\n\t- 复制函数[[scope]]属性，创建作用域链\n\t- 用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明\n\t- 将活动对象压入  函数作用域链顶端\n\t- 开始执行函数，随着函数的执行，修改 AO 的属性值\n\t- 函数执行完毕，函数上下文从执行上下文栈中弹出\n\n- this\n\n\t- 简单的理解 this 为调用函数的对象\n\n- 执行上下文\n\n\t- JavaScript代码被解析和执行时所在环境的抽象概念\n\t- 执行上下文的类型\n\n\t\t- 全局执行上下文\n\n\t\t\t- 只有一个，浏览器中的全局对象window，this执行这个全局对象\n\n\t\t- 函数执行上下文\n\n\t\t\t- 存在无数个，在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文\n\n\t\t- Eval函数执行上下文\n\n\t\t\t- 指运行在eval函数中的代码，不建议使用\n\n\t- 执行栈也叫调用栈\n\n\t\t- 用于存储在代码执行期间创建的所有执行上下文\n\t\t- 首次运行会创建一个全局的执行上下文，push到当前的执行栈中，每当有函数调用，引擎都会为该函数创建一个新的函数执行上下文并push到当前执行栈的栈顶。\n\t\t- 栈顶函数运行完成后，会将其pop出栈，执行下一个栈顶函数\n\n\t- 执行上下文的创建\n\n\t\t- 创建阶段\n\n\t\t\t- 确定this\n\t\t\t- 词法环境\n\n\t\t\t\t- 环境记录\n\n\t\t\t\t\t- 存储变量和函数声明的实际位置\n\n\t\t\t\t- 对外部环境的引用\n\n\t\t\t\t\t- 可以访问的外部词法环境\n\n\t\t\t- 变量环境\n\n\t\t\t\t- 也是一个词法环境\n\n\t\t\t\t\t- 主要区别变量使用var声明、而词法环境用let、const声明\n\n\t\t- 执行阶段\n\n\t\t\t- 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值\n\t\t\t- 在代码执行阶段，会再次修改变量对象的属性值\n\n### 提升\n\n- 提升\n\n\t- 引擎会 在解释 JavaScript 代码之前首先对其进行编译。编译阶段找到所有声明,用合适的作用域将它们关联起来\n\t- var a = 2; 会被拆成两个阶段进行，var a （编译阶段）a=2（执行阶段），这个过程就叫作 提升\n\t- 一个普通块内部的函数声明通常会被提升到所在作用域的顶部\n\t- 每个作用域 都会进行提升操作\n\n- 函数优先\n\n\t- 函数会首先被提升,然后才是变量\n\n### 词法作用域\n\n- 词法阶段\n\n\t- 词法作用域都只由函数被声明时所处的位置决定\n\t- 作用域查找会在找到第一个匹配的标识符时停止（遮蔽效应）\n\n- 欺骗词法\n\n\t- 欺骗词法作用域会导致性能 下降，不是好主意\n\t- eval\n\t- with\n\n### 函数作用域和块作用域\n\n- 隐藏内部实现\n\n\t- 从所写的代码中挑选出一个任意的片段,然后用函数声明对它进行包装（隐藏代码）\n\t- 规避冲突：“隐藏”作用域中的变量和函数所带来的另一个好处,是可以避免同名标识符之间的冲突\n\t- 规避冲突方法\n\n\t\t- 命名空间\n\t\t- 模块管理\n\n- 函数作用域\n\n\t- 匿名函数，最熟悉的场景可能就是回调参数\n\n\t\t- 匿名函数在栈追踪中不会显示出有意义的函数名,使得调试很困难。\n\t\t- 如果没有函数名,当函数需要引用自身时只能使用已经 过期 的 arguments.callee 引用\n\t\t- 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名\n\n\t- 立即执行函数表达式，IIFE\n\n\t\t- 普遍的进阶用法是把它们当作函数调用并传递参数进去\n\t\t- IIFE 还有一种变化的用途是倒置代码的运行顺序\n\n- 块作用域\n\n\t- with 关键字是 块作用域的一 个例子\n\t- try / catch 的 catch 分句会创建一个块作 用域\n\t-  ES6 引入了新的 let 关键字\n\t- ES6 还引入了 const , 同样可以用来创建块作用域变量\n\t- 另一个块作用域非常有用的原因和闭包及回收内存垃圾的回收机制相关\n\n### 作用域\n\n- 能够储存变量当中的值,并且能在之后对这个 值进行访问或修改\n- 编译原理\n\n\t- 分词/词法分析：这个过程会将由字符组成的字符串分解成(对编程语言来说)有意义的代码块\n\t- 解析/语法分析:将词法单元流(数组)转换成一个由元素逐级嵌套所组成的代表了程序语法\n结构的树(抽象语法树 AST)\n\t- 代码生成:将 AST 转换为可执行代码的过程称被称为代码生成\n\t- javascript 编译过程发生在代码执行前几微妙\n\t- JavaScript 引擎用尽了各种办法(比如 JIT, 可以延 迟编译甚至实施重编译)来保证性能最佳。\n\n- 作用域\n\n\t- 几个概念\n\n\t\t- 编译器\n\t\t- 引擎\n\t\t- 作用域\n\n\t- var a = 2;\n\n\t\t- 编译器会询问作用域是否已经有一个该名称的变量\n\n\t\t\t- 如果是,编译器会忽略该声明\n\t\t\t- 否则,要求作用域在当前集合声明一个新变量 a\n\n\t\t- 接下来编译器会为引擎生成运行时所需的代码，处理 a=2 的赋值操作\n\n\t- 引擎查找变量规则\n\n\t\t- LHS，当变量出现在赋值操作的左侧时进行LHS查询\n\t\t- RHS,出现在右侧时进行RHS查询\n\n\t- 作用域嵌套\n\n\t\t- 引擎从当前的执行作用域开始查找变量,如果找不到, 就向上一级继续查找\n\n### 作用域闭包\n\n- javascript 中闭包无处不在,你只需要能够识别并拥抱它\n- 闭包概念\n\n\t- 闭包：函数是在当前词法作用 域之外执行\n\t- 闭包阻止了引擎有垃圾回收器用来释放不再使用的内存空间\n\t- 函数不在定义词法中执行，但是依然保持对该词法的引用，这个引用叫做闭包\n\n- 模块\n\n\t- 最常见的实现模块模式的方法通常被称为 模块暴露\n\t- 必须有外部的封闭函数,每次调用都会创建一个新的模块 实例\n\t- 封闭函数必须返回至少一个内部函数\n\t- 大多数模块依赖加载器 / 管理器本质上都是将这种模块定义封装进一个友好的 API。\n\t- ES6 会将文件当作独立 的模块来处理\n\n\t\t- 每个模块都可以导入其他模块或特定的 API 成员\n\t\t- 同样也可以导出自己的 API 成员\n\n## this\n\n### this 的误解\n\n- 隐式传递一个对象的引用\n- this 在任何情况下都不指向函数的词法作用域\n- this 是在函数运行时，创建上下文的时候确定的\n\n### this 的绑定规则\n\n- 默认绑定\n\n\t- 使用不带任何修饰的函数引用进行调用的\n\n- 隐式绑定\n\n\t- 调用位置是否有上下文对象\n\t- 隐式丢失\n\n\t\t- 通常发生在对象赋值的情况\n\n- 显式绑定\n\n\t- 使用函数的 call(..) 和 apply(..) 方法\n\t- 硬绑定\n\n- new 绑定\n\n\t- 创建(或者说构造)一个全新的对象。\n\t- 这个新对象会被执行[[原型]]连接。\n\t- 这个新对象会绑定到函数调用的 this\n\t- 如果函数没有返回其他对象,那么 new 表达式中的函数调用会自动返回这个新对象\n\n### 箭头函数 this 指向\n\n- 根据外层(函数或者全局)作用域来决 定 this\n\n## 原型\n\n###   [[Prototype]]\n\n- JavaScript 中的对象有一个特殊的内置属性，是对于其他对象的引 用\n- 对象访问属性会触发[[Get]]操作，如果无法在本身找到需要的属性\n如果没有就要使用对象的 [[Prototype]] 链了\n- 任何可以通过原型链访问到的属性都会被枚举\n- 所有 普通 的 [[Prototype]] 链最终都会指向内置的 Object.prototype 。\n- 属性的设置（例如赋值操作）\n\n\t- 属性不存在于原型链上层，新属性会被直接添加到对象上\n\t- （普通访问属性）属性存在于原型链上层，创建（屏蔽属性）新属性\n\t- 标记为只读( writable:false )属性存在于原型链上，不会进行赋值，不发生屏蔽\n\t- 新属性在原型链上以setter 的形式纯在，调用 setter ，不添加新属性，不发生屏蔽\n\n### “类”\n\n- JavaScript 中 只有 对象。\n- “ 类 ” 函数\n\n\t- 所有的函数默认都会拥有一个 名为 prototype 的公有并且不可枚举的属性,它会指向另一个对象\n\t- javascript 可以创建多个对象，并将他们关联到同一个原型\n\t- function Foo(){...}; var a=new Foo();造成了a.[[prototype]]==Foo.prototype(实例与原型的关联)\n\t- javascript 和传统的面向对象的继承不太一样，不会将“类”复制到“实例”中，而是通过原型链将他们关联起来\n\n- ”构造函数“\n\n\t- Foo.prototype 默认(在代码中第一行声明时!)有一个公有并且不可枚举的属性 .constructor\n\t- 函数本身并不是构造函数，new 关键字，把函数变成“构造函数”\n\n- 技术\n\n\t- constructor 并不表示被构造\n\t- Foo.prototype.constructor === Foo;    a.constructor === Foo\n\n### （原型）继承\n\n- Object.create(..) 会凭空创建一个“新”对象并把新对象内部的 [[Prototype]] 关联到你指定的对象\n- 通过.__proto__ 属性修改对象关联\n- 判断对象是否委托关联某个函数，instanceof 操作符的左操作数是一个普通的对象,右操作数是一个函数\n\n### 对象关联\n\n- [[Prototype]] 机制就是存在于对象中的一个内部链接, 它会引用其他 对象。\n- var bar = Object.create( foo );  Object.create(..) 会创建一个新对象( bar )并把它关联到我们指定的对象( foo )\n\n## 数据类型\n\n### 类型\n\n- Undefined\n\n\t- 只有一个值：undefined，变量不需要显性设置为undefined值\n\t- undefined 指没有值(missing value)，指从未赋值\n\t- void 并不改变表达式的结果,只是让表达式不返回值\n\t- undefined 是一个内置标识符 它的值为 undefined，通过 void 运算符即可得到该值\n\t- 声明但未初始化的变量和未声明的变量都返回undefined\n\n- Null\n\n\t- 空对象指针，只有一个值null\n\t- null 指空值(empty value)，指曾赋过值,但是目前没有值\n\t- typeof 返回"object"，准备用于保存对象的变量初始化时最好为null\n\t- undefined值派生自null值，undefined==null返回true\n\n- Boolean\n\n\t- 两个字面值true和false，ECMAScript中所有类型的值都有与这两个值等价的值\n\t- 不同数据类型转换为Boolean\n\n\t\t- String类型：任何非空字符串可转换为true，""(空字符串)转换为false\n\t\t- Number：任何非零数字值可转换为true，0和NaN转换为false\n\t\t- Object：任何对象可转换为true，null转换为false\n\t\t- Undefined：n/a（not applicable，“不适用”）可转换为true，undefined可转换为false\n\n- Number\n\n\t- 数字语法\n\n\t\t- 包括“整数”和带小数的十进制数\n\t\t- 数字前后的 0 都可以省略\n\t\t- 特别大和特别小的数字默认用指数格式显示\n\t\t- tofixed(..) 方法可指定小数部分的显示位数\n\t\t- toPrecision(..) 方法用来指定 有效数位 的显示位数\n\t\t- 小数点是一种运算符，常见一种数字调用函数方式 42..tofixed(3)\n\t\t- 数字常量还可以用其他格式来表示,如二进制、八进制和十六进制\n\n\t- 较小的数值\n\n\t\t- 0.1 + 0.2 === 0.3; // false\n\t\t- 如何判断 0.1 + 0.2 的值是否和 0.3相等 \n\t\t- 最常见的方法是设置一个误差范围值, 通常称为“机器精度”\n\n\t-  整数的安全范围\n\n\t\t- 能够被“安全”呈现的最大整数是 2^53 - 1\n\t\t- 最小整数是 -（2^53 - 1）\n\t\t- 需 要 处 理 一 些 比 较 大 的 数 字，（转存）保存成字符串\n\n\t- 整数检测\n\n\t\t- 使用 ES6 中的 Number.isInteger(..) 方法\n\t\t- return typeof num == "number" && num % 1 == 0;\n\t\t- 可以使用 ES6 中的 Number.isSafeInteger(..)\n\t\t- return Number.isInteger( num ) && Math.abs( num ) <= Number.MAX_SAFE_INTEGER;\n\n\t- 32 位有符号整数\n\n\t\t- 是有些数字操作(如数位操作)只适用于 32 位数字\n\n\t- 整数\n\n\t\t- 进制表示格式\n\n\t\t\t- 十进制\n\t\t\t- 八进制字面值第一位为0，然后是八进制数字序列（0~7）\n\t\t\t- 十六进制前两位为0x，后面跟十六进制数字（0~f），字母大小写都可以\n\n\t\t- 进行算术计算时所有以八进制和十六进制表示的数值都将被转换为十进制\n\n\t- 浮点数值\n\n\t\t- 浮点数值必须有一个小数点，小数点后必须有至少一位小数，最高精度是17位小数\n\t\t- e表示法（科学记数法）：3.125e7=3.125*10^7=31250000\n\t\t- 浮点数值计算会产生舍入误差如0.1+0.2=0.30000000000000004不等于0.3，所以不要用特定浮点数值进行测试\n\n\t- NaN（非数值）\n\n\t\t- 表示一个本来要返回数值的操作数未返回数值的情况\n\t\t- 任何涉及NaN的操作都会返回NaN，同时NaN与任何数值包括自身都不相等（NaN==NaN返回false）\n\t\t- isNaN()函数：接收一个值后，尝试将其转换为数值。不能被转换为数值的值会导致这个函数返回true\n\n\t- 无穷数 Infinity\n\t- 零值\n\n\t\t- JavaScript 有一个常规的 0 (也叫作 +0 )和一个 -0\n\n\t- 特殊等式\n\n\t\t- NaN 和自身不相等\n\t\t- -0 等于 0\n\t\t- ES6中新加入了一个工具方法 Object.is(..) 来判断两个值是否绝对相等\n\n\t- 数值转换函数\n\n\t\t- parseInt()\n\t\t- Number()\n\t\t- parseFloat()\n\n- String\n\n\t- 以引号（单双引号都可以但是要配对）表示\n\t- 字符串一旦创建，值就不可变\n\t- 字符串和数组的确很相似,它们都是类数组\n\t- JavaScript 中字符串是不可变的, 而数组是可变的\n\t- 通过“借用”数 组的非变更方法来处理字符串\n\t- 转换为字符串\n\n\t\t- toString()方法，适用于数值、布尔值、对象和字符串值\n\n\t\t\t- 调用数值的toString()方法时可以传递一个参数，来输出以二进制、八进制等进制格式表示的字符串\n\n- 数组\n\n\t- 数组可以容纳任何类型的值\n\t- 使用delete删除数组内容，但是数组的长度不会变化\n\t- 字符串键值能够被强制类型转换为十进制数字的话,它 就会被当作数字索引来处理\n\t- 有时需要将类数组转换为真正的数组\n\n- symbol（es6 新增）\n\n### 引用类型（对象定义）\n\n- Object类型 \n\n\t- 创建方法\n\n\t\t- 使用new操作符跟Object构造函数\n\n\t\t\t- var person=new Object(); person.name="Nick"; person.age=29;\n\n\t\t- 对象字面量表示法\n\n\t\t\t- var person={ name: "Nick", age:29}; 花括号内可以为空，属性名可以使用字符串如"name": "Nick"\n\n\t- 对象的内容（属性）\n\n\t\t- 对象的内容（属性）\n\t\t- 属性名永远都是字符串。\n\t\t- 对象的“方法”：对函数的一种引用\n\t\t- 复制对象\n\n\t\t\t- 深拷贝\n\t\t\t- 浅拷贝\n\n\t\t- 属性描述符\n\n\t\t\t- writable (可写)\n\t\t\t- enumerable (可枚举)\n\t\t\t- configurable (可配置)\n\n\t\t-   [[Get]]\n\n\t\t\t-  myObject.a 在 myObject 上实际上是实现了 [[Get]] 操作\n\n\t\t-   [[Put]]\n\n\t\t\t- 并非在赋值的时候触发，具体逻辑在原型链里做分析\n\n\t\t- 使用 getter 和 setter 部分改写默认操作（运用在单个属性上）\n\n\t\t\t- getter 是一个隐藏函数,会在获取属性值时调用\n\t\t\t- setter 也是一个隐藏 函数,会在设置属性值时调用\n\n\t\t- hasOwnProperty(..) 方法检查属性是否存在\n\t\t- 不可变\n\n\t\t\t- Object.seal(..)\n\t\t\t- Object.preventExtensions(..)\n\t\t\t- Object.freeze(..)\n\n\t\t- 属性遍历\n\n\t- 访问方法\n\n\t\t- 点表示法 person.name\n\t\t- 属性名中包含易导致语法错误的字符或使用变量时可以用方括号表示法 person["first name"]\n\n- Array类型\n\n\t- 数组的每一项可以保存任何类型的数据\n\t- 创建方法\n\n\t\t- 使用Array构造函数\n\n\t\t\t- var colors= new Array(); new操作符可省略，可以给构造函数传递要保存的项目数量，该数量会自动成为length属性的值\n\n\t\t- 数组字面量表示法\n\n\t\t\t- var colors=["red", "blue", "green" ]\n\n\t- 数组的length属性可以修改，通过设置这个属性可以从数组末尾移除或添加项\n\n\t\t- 利用length属性的值也可以方便地添加新项，因为数组最后一项的索引始终是length-1\n\t\t- var colors=["red", "blue", "green" ]; colors[colors.length]= "black"; colors[colors.length]= "brown";\n\n\t- 检测方法\n\n\t\t- Array.isArray()\n\t\t- instanceof只适用于一个全局执行环境\n\n\t- 转换方法\n\n\t\t- toLocaleString()/toString()/valueOf()\n\n\t- 栈方法（Last-In-First-Out后进先出）\n\n\t\t- push()方法：接受任意数量的参数，逐个添加到数组末尾并返回修改后的数组长度\n\t\t- pop()方法：从数组末尾移除最后一项，减少数组的length值并返回移除的项\n\n\t- 队列方法FIFO（先进先出）\n\n\t\t- shift()方法：移除数组中的第一个项，减少数组长度并返回移除的项\n\t\t- shift()方法和push()方法合用可以像使用队列一样使用数组\n\t\t- unshift()方法：在数组前端添加任意个项并返回数组的length\n\t\t- unshift()方法与pop()方法合用可以从反方向模拟队列\n\n\t- 重排序方法\n\n\t\t- reverse()方法：反转数组项的顺序\n\t\t- sort()方法：按升序排列数组项\n\n\t\t\t- 通过调用每个数组项的toString()方法来比较得到的字符串，很多情况下不符合要求\n\t\t\t- 可以接收一个比较函数作为参数，方便指定数组项排序\n\n\t- 操作方法\n\n\t\t- contact()方法基于当前数组所有项创建一个新数组\n\n\t\t\t- var colors2=colors1.concat("yellow", ["black", "brown"]); 返回新构建的数组\n\n\t\t- slice()方法基于当前数组的一个或多个项创建一个新数组\n\n\t\t\t- var colors2=colors1.slice(1);一个参数情况下返回该参数指定位置到当前数组末尾所有项\n\t\t\t-  var colors3=colors1.slice(1, 4); 两个参数情况下返回起始位置和结束位置之间的项，不包括结束位置的项\n\n\t\t- splice()方法\n\n\t\t\t- 删除\n\n\t\t\t\t- 指定2个参数：要删除的第一项的位置和要删除的项数，删除任意数量的项\n\n\t\t\t\t\t- .splice(1, 4);\n\n\t\t\t- 插入\n\n\t\t\t\t- 指定3个参数：起始位置、0（要删除的项数）、要插入的项\n\n\t\t\t\t\t- .splice(2, 0, "yellow", "orange");\n\n\t\t\t- 替换\n\n\t\t\t\t- 指定3个参数：起始位置、要删除的项数、要插入的项\n\n\t- 位置方法\n\n\t\t- indexOf()方法\n\n\t\t\t- 接收两个参数，分别表示要检索的项和索引起始位置\n\n\t\t- LastindexOf()方法\n\n\t\t\t- 同上\n\n\t- 迭代方法\n\n\t\t- every()\n\t\t- filter()\n\t\t- forEach()\n\t\t- map()\n\t\t- some()\n\n\t- 归并方法\n\n- Date类型\n\n\t- 创建方法\n\n\t\t- 使用new操作符和Date构造函数\n\n\t\t\t- var now= new Date();\n\t\t\t- 传参数的方法\n\n\t\t\t\t- Date.parse()方法\n\n\t\t\t\t\t- 接受一个表示日期的字符串，尝试根据字符串返回相应日期的毫秒数，未定义支持的日期格式\n\t\t\t\t\t- var someDate= new Date(Date.parse("May 25, 2004")); 如字符串不能表示日期，返回NaN\n\t\t\t\t\t- var someDate=new Date("May 25, 2004);直接将表示日期的字符串传给Date函数会在后台直接调用Date.parse()方法\n\n\t\t\t\t- Date.UTC()方法\n\n\t\t\t\t\t- var someDate=new Date(Date.UTC(2005,4,5,17,55,55));\n\t\t\t\t\t- 参数分别是年、月、日、小时、分钟、秒、毫秒等，其中月份从0开始\n\t\t\t\t\t- 也可以直接将表示日期的字符串传给Date函数\n\n\t\t- Date.now()返回表示调用这个函数的日期和时间\n\n### 值和类型\n\n- JavaScript 中的变量是没有类型的, 只有值才有\n- 变量可以随时持有任何类型的值\n- undefi ned 和 undeclared\n\n\t- 变量在未持有值的时候为 undefined\n\t- 还没有在作用域中声明 过的变量,是 undeclared 的\n\t- “undefined”和“is not defined”是两码事\n\n-   typeof  Undeclared\n\n\t- 会检查变量是否已被声明\n\t- 访问不存在的对象属性不会产生 ReferenceError 错误\n\n## 原生函数\n\n### 常用的原生函数有\n\n- String()\n- Number()\n- Boolean()\n- Array()\n- Object()\n- Function()\n- RegExp()\n- Date()\n- Error()\n- Symbol()——ES6 中新加入的!\n\n### 内部属性[[class]]\n\n- 所有 typeof 返回值为 "object" 的对象(如数组)都包含一个内部属性 [[Class]]\n\n### 封装对象包装\n\n- 基 本 类 型 值 没 有 .length 和 .toString() 这样的属性和方法,需要通过封装对象才能访问\n- 封装对象释疑  !new Boolean( false ) //false\n\n### 拆封\n\n- 如果想要得到封装对象中的基本类型值,可以使用 valueOf() 函数\n\n### 原生函数作为构造函数\n\n-   Array(..)\n\n\t- Array 构造函数只带一个数字参数的时候,该参数会被作为数组的预设长度\n\t- 包含至少一个“空单元”的数组称为“稀疏数组”\n\t- 可以通过 delete b[1] 在数组 b 中制造出一个空单元\n\t- 永远不要 创建和使用空单元数组\n\n- Object(..)、Function(..) 和 RegExp(..)\n\n\t- 尽量不要使用 Object(..) / Function(..) / RegExp(..)\n\t- 使用 new Object() 来创建对象,必须逐一设置属性\n\t- 构造函数 Function 只在极少数情况下很有用,比如动态定义函数参数和函数体的时候\n\t- 强烈建议使用常量形式(如 /^a*b+/g )来定义正则表达式\n\n- Date(..) 和 Error(..)\n\n\t- Date(..) 可以带参数,用来指定日期和时间,而不带 参数的话则使用当前的日期和时间。\n\t- 创建错误对象(error object)主要是为了获得当前运行栈的上下文\n\n- Symbol(..)\n\n\t- 符号是具有唯一性的特殊值(并 非绝对),用它来命名对象属性不容易导致重名\n\t- 不能带 new 关键 字,否则会出错:\n\n- 原生原型\n\n\t- 原生构造函数有自己的 .prototype 对象,如 Array.prototype 、 String.prototype 等\n\t- 将原型作为默认值，例如：, RegExp.prototype 是一个“空”的正则表达式\n\n## 强制类型转换\n\n### 值类型转换\n\n- 将值从一种类型转换为另一种类型通常称为 类型转换（显示）\n\n\t- 类型转换发生在静态类型语言的编译阶段\n\n- 隐式的情况称为 强制类型转换\n\n\t- 强制类型转换则发生在动态类型语言的运行时\n\n### 抽象值操作\n\n- ToString\n\n\t- 它负责处理非字符串到字符串的强制类型转换\n\t- 对普通对象来说, 除非自行定义, 否则 toString() ( Object.prototype.toString() )返回 内部 属性 [[Class]] 的值\n\t- 数组的默认 toString() 方法经过了重新定义, 将所有单元字符串化以后再用 "," 连接起 来\n\t- 工具函数 JSON.stringify(..) 在将JSON对象序列化为字符串时也用到了 ToString\n\t- JSON.stringify(..) 在对象中遇到 undefined 、 function 和 symbol 时会自动将其忽略，在数组中则返回 null\n\t- toJSON() 应该“返回一个能够被字符串化的安全的 JSON 值”, 而不是“返回 一个 JSON 字符串”\n\t- 字符串、数字、布尔值和 null 的 JSON.stringify(..) 规则与 ToString 基本相同\n\t- 如果传递给 JSON.stringify(..) 的对象中定义了 toJSON() 方法, 那么该方法会在字符 串化前调用,以便将对象转换为安全的 JSON 值\n\n- ToNumber\n\n\t- 对象(包括数组)会首先被转换为相应的基本类型值\n\t- 处理失败 时返回 NaN\n\t- 检查该值是否有 valueOf() 方法\n\n\t\t- 如果有\n\n\t\t\t- 使用该值进行强制类型转换\n\n\t\t- 如果没有\n\n\t\t\t- 使用 toString() 的返回值(如果存在)来进行强制类型转换。\n\n- ToBoolean\n\n\t- 可以被强制类型转换为 false 的值\n\t- 其他(被强制类型转换为 true 的值)\n\t- 假值\n\n\t\t- undefined\n\t\t- null\n\t\t- false\n\t\t- +0、-0和 NaN\n\t\t- “ ”\n\n\t- 假值对象\n\n\t\t- document.all \n\n\t- 真值\n\n\t\t- 假值列表之外的值\n\n### 显式强制类型转换\n\n- 字符串和数字之间转换\n\n\t- 日期显式转换为数字\n\n\t\t- +new Date();\n\n\t- 奇特的 ~ 运算符\n\n\t\t- 字位运算符(如 | 和 ~ )和某些特殊数字一起使用时会产生\n类似强制类型转换的效果\n\n\t- 字位截除\n\n\t\t- 使用 ~~ 来截除数字值的小数部分\n\n- 显式解析数字字符串\n\n\t- 解析非字符串\n\n\t\t- parseInt(..) 会根据字符串的第一个字符来自行决定基数\n\n- 显式转换为布尔值\n\n\t- 三元运算符\n\t- if 判断\n\t- ！！强制转换\n\n### 隐式强制类型转换\n\n- 隐式地简化\n\n\t- 隐式强制类 型转换同样可以用来提高代码可读性\n\n- 字符串和数字之间的隐式强制类型转换\n\n\t- 根据 ToPrimitive 抽象操作规则, a + "" 会对 a 调用 valueOf() 方法,然后通过 ToString 抽象 操作将返回值转换为字符串\n\t- - 是数字减法运算符,因此 “3.14” - 0 会将 “3.14” 强制类型转换为数字。\n\n- 布尔值到数字的隐式强制类型转换\n\n\t- 复杂的布尔逻辑转换为数字加法\n\n-  隐式强制类型转换为布尔值\n\n\t- if (..)\n\t- for ( .. ; .. ; .. )\n\t- while (..) 和 do..while(..)\n\t- ? :\n\t- 逻辑运算符 || (逻辑或)和 && (逻辑与)左边的操作数\n\n- || 和 &&\n- 符号的强制类型转换\n\n\t- 从符号到字符串的 显式 强制类型转换,然而 隐式 强制类型转换会产生错误\n\n### 宽松相等和严格相等\n\n- == 允许在相等比较中进行强制类型转换,而 === 不允许\n- 相等比较操作的性能\n\n\t- 然强制类型转换确实要多花点时间, 但仅仅是微秒级 (百万分之一秒)的差别而已\n\n- 抽象相等\n\n\t- NaN 不等于NaN\n\t- +0 等于-0\n\t- == 在比较两个不同类型的值时会发生 隐式 强制类型转换\n\t- true 和 false 与其他类型之间的相等比较\n\t- == 对不同的类型组合处理方式不同 \n\t- 在 == 中 null 和 undefined 相等\n\t- 对象和非对象之间的相等比较\n\n\t\t- 对对象调用 ToPromitive 抽象操作，拆分封装对象\n\n-  比较少见的情况\n\n\t- 返回其他数字\n\t- 假值的相等比较\n\t- 极端情况\n\t- 完整性检查\n\t- 安全运用隐式强制类型转换\n\n### 抽象关系比较\n\n- 比较双方都是字符串\n\n\t- 则按字母顺序来进行比较\n\n- 和其他情况\n\n\t- 比较双方首先调用 ToPrimitive ,如果结果出现非字符串,就根据 ToNumber 规则将双方强 制类型转换为数字来进行比较。\n\n- 相等比较有严格相等,关系比较却没有“严格关系比较”\n\n## 语法\n\n### 语句和表达式\n\n- 语句相当于句子, 表达式相当于短语\n- var b = a 称为“声明语句”\n- b = a (不带 var )叫作“赋值表达式”\n- 语句的结果值\n\n\t- 在控制台中输入 var a = 42 会得到结果值 undefined\n\t- 代码中是没有办法获得这个结果值\n\t- 代码块，返回最后一条语句的结果值\n\t- 多个赋值语句串联时 ,赋值表达式(和语句)的结果值就 能派上用场\n\n- 表达式副作用\n\n\t- 递增运算符 ++ 和递减运算符 -- 都是一元运算符\n\t- ++a++ 会产生 ReferenceError 错误, 因为运算符需要将产生的副作用赋值给 一个变量\n\n- 上下文规则\n\n\t- 大括号\n\t- 代码块\n\t- 对象解构\n\t- else if 和可选代码块\n\n### 运算符优先级\n\n- 短路\n\n\t- && 和 || 运算符的“短路”\n\t- 如果从左边的操作数能够得出结果,就可以忽略右边的操作数\n\n- 更强的绑定\n\n\t- a && b || c ? c || b ? a : c && b : a\n\n- 关联\n- 释疑\n\n\t- 编写程序时要将两者结合起来,既要依赖运算符 优先级 关联规则\n\t- 也要适当使用 ( ) 自行控制方式\n\n### 自动分号\n\n- 有时 JavaScript 会自动为代码行补上缺失的分号, 即自动分号插入\n- , ASI 只在换行符处起作用,而不会在代码行的中间插入分号\n- ASI 实际上是一个“纠错”(error correction)机制\n- 建议在所有需要的地方加上分号,将对 ASI  的依赖降到最低\n\n### 错误\n\n- 在编译阶段发现的代码错误叫作“早期错误”\n- 这些错误在代码执行之前是无法用 try..catch 来捕获的，还会导致解析/编译 失败。\n- 非法正则产生早期错误\n- 语法规定赋值对象必须是一个标识符\n- 严格模式中,函数的参数不能重名\n- ES6 规范定义了一个新概念,暂时性死区\n\n### 函数参数\n\n- 在 ES6 中,如果参数被省略或者值为 undefined ,则取该参数的默认值\n- 如果向参数传递 undefined ，会出现一个undefined 单元，而不是默认值\n- 向函数传递参数时, arguments 数组中的对应单元会和命名参数建立关联\n\n### try..finally\n\n- finally 中的代码总是会在 try 之后执行,如果有 catch 的话则在 catch 之后执行\n- try 中的 return ，函数执行完毕后悔将函数的返回值设置为 return 的值\n- 如果 finally 中抛出异常(无论是有意还是无意),函数就会在此处终止\n\n###   switch\n\n- 可以把它看作 if..else if..else.. 的简化版本\n\n## 回调\n\n### 　continuation\n\n- 回调函数包裹或者说封装了程序的延续（continuation）\n- 代码变得更加难以理解、追踪、调试和维护\n\n### 顺序的大脑\n\n- 并行执行多个任务时，实际上极有可能是在进行快速的上下文切换\n- 异步事件并发机制很相似\n- JavaScript 程序中总是有很多噪声，使得代码更加杂乱回调地狱理解起来很难\n- 顺序阻塞式的大脑计划行为无法很好地映射到面向回调的异步代码\n\n### 信任问题\n\n- 控制反转 （inversion of control），也就是把自己程序一部分的执行控制交给某个第三方\n- 对于被传给你无法信任的工具的每个回调，你都将不得不创建大量的混乱逻辑\n- 回调最大的问题是控制反转，它会导致信任链的完全断裂\n- 没有应用某种逻辑来解决所有这些控制反转导致的信任问题\n那你的代码现在已经有了 bug\n\n### 省点回调\n\n- 为了更优雅地处理错误，有些 API 设计提供了分离回调 \n- 回调可以实现你想要的功能，但是要付出很多努力，代码也会变得笨重\n\n## ajax\n\n### Ajax\n\n- 请求\n\n\t- 流程\n\n\t\t- 1.创建浏览器内置的对象 XMLHttpRequest\n\t\t- 2.调用xhr对象的open方法，设置请求方式和请求的url\n\t\t- 3.调用xhr对象的send方法，向服务器发送请求\n\t\t- 4.当请求响应整个过程结束，然后接收服务器响应的结果（返回的数据）\n\n\t\t\t- 使用xhr的response属性来接收服务器响应的结果\n\n\t- 方式\n\n\t\t- get\n\n\t\t\t- 说明：一般用户从服务器获取数据\n\t\t\t- 参数：需要在设置url的时候将参数传递\n\n\t\t\t\t- 例子：?nam=xxx&sex=yyy\n\n\t\t\t- 缓存：\n\n\t\t\t\t- 说明：在get的请求方式下，IE浏览器会出现缓存现象\n\t\t\t\t- 解决办法：接收动态参数\n\n\t\t- post\n\n\t\t\t- 说明：把数据提交给服务器\n\t\t\t- 参数：需要在send发送请求处添加参数\n\n\t\t\t\t- 例子：xhr.send(\'name=zhangsan&age=18\')\n\n\t\t\t- 注意：\n\n\t\t\t\t- post会比get请求多一行代码：xhr.setRequestHeader(\'Content-Type\', \'application/x-www-form-urlencoded\')\n\n- 响应数据格式\n\n\t- JSON\n\n\t\t- 本质：字符串\n\t\t- 注意点：\n\n\t\t\t- 1.JSON 中属性名称必须用“双引号”包裹\n\t\t\t- 2.JSON 中表述字符串（值）必须使用双引号\n\t\t\t- 3.JSON 中不能有注释\n\t\t\t- 4.JSON 没有 undefined 这个值\n\n\t- XML\n\n\t\t-  可扩展标记语言\n\n\t\t\t- 1.只有一个根标签\n\t\t\t- 2.区分大小写\n\t\t\t- 3.标签必须闭合\n\t\t\t- 4.属性值必须加引号\n\n\t- HTML\n\n\t\t- 超文本标记语言\n\n- 模板引擎\n\n\t- 使用的原因：可以更容易更高效的将数据渲染到HTML字符串中\n\t- 使用步骤：\n\n\t\t- 1.引入template-web.js文件\n\t\t- 2.定义模板，一定要指定script的id和type属性\n\t\t- 3.调用template函数，为模板分配数据，template函数有两个参数一个返回值\n\t1）. 参数1：模板的id\n\t2）. 参数2：分配的数据，必须是一个JS对象的形式\n\t3）. 一个返回值：是数据和模板标签组合好的结果\n\n\t- 调用方式：\n\n\t\t- 普通流：var\n\t\t- 条件：if age > 18\n\t\t- 循环：each arr\n\n- 异步&同步\n\n\t- 同步\n\n\t\t- 例：一个人在同一个时刻只能做一件事情，在执行一些耗时的操作的时候，不能去做别的事，只是等待\n\n\t- 异步\n\n\t\t- 例：在执行一些耗时的操作的时候，同时去做别的事，而不是等待\n\n\t- xhr.open（请求参数，请求url，boolean） \n\n\t\t- 第三个参数即为false同步，true异步（默认）\n\n- XHR对象其他API\n\n\t- 1.readyState\n\n\t\t- 状态 xhr.readyState\n\n\t\t\t- 0\n\n\t\t\t\t- 代理（XHR）被创建，但尚未调用 `open()` 方法。\n\n\t\t\t- 1\n\n\t\t\t\t- open()` 方法已经被调用，建立了连接。\n\n\t\t\t- 2\n\n\t\t\t\t- send()` 方法已经被调用，并且已经可以获取状态行和响应头。\n\n\t\t\t- 3\n\n\t\t\t\t- 响应体（服务器返回的数据）下载中， `responseText` 属性可能已经包含部分数据。\n\n\t\t\t- 4\n\n\t\t\t\t- 响应体（服务器返回的数据）下载完成，可以直接使用 `responseText`或response 获取完整的结果。\n\n\t- 2.onreadystatechange\n\n\t\t- 1.每当XHR对象的状态发生变化的时候，就会触发这个事件\n\t\t- 2.xhr对象分块接收数据\n\n\t- 3.progress( 过程，进度)\n\n\t\t- 1.onload -- 当readyState等于4的时候触发。只有请求成功了才触发。\n\t\t- 2.onprogress -- 当readyState等于3的时候触发（数据正在返回途中的时候触发）\n\t\t- 3.onloadstart() -- 当开始发送请求的时候触发，要放到send之前\n\t\t- 4.onloadend() -- 当请求响应过程结束的时候触发。无论成功还是失败都会触发。\n\n\t- XHR对象的兼容方案\n\n\t\t- 解释：XMLHttpRequest 在老版本浏览器（IE5/6）中有兼容问题\n\t\t- 书写：var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(\'Microsoft.XMLHTTP\')\n\n\t- responseType\n\n\t\t- 1.“”  -- 空，表示文本，\n\t\t- 2.text -- 文本\n\t\t- 3.json -- JSON格式数据\n\t\t- 4.document -- 文档对象\n\n- jQuery封装\n\n\t- 格式：\n\n\t\t-     $.ajax({\n     type: \'GET\', // 请求方式\n     url: \'/query-get\',\n     data: {id: 333, age: 666, name: \'zs\'}, // 发送给接口的数据，可以写成对象，jQuery内部会自动将对象转成字符串\n    dataType: \'json\', // 如同 responseType。\n    success: function (res) {\n        console.log(res);\n    }\n});\n\n\t- 常用参数：\n\n\t\t- cache: 设置ie浏览器的缓存问题， cache: false 不缓存\n\t\t- url：请求地址\n\t\t- type：请求方法，默认为 `get\n\t\t- dataType：预期服务端响应数据类型\n\t\t- contentType：请求体内容类型，如果是POST请求，默认 `application/x-www-form-urlencoded\n\t\t- data：（object|string）传递到服务端的数据\n\t\t- timeout：请求超时时间\n\t\t- beforeSend：请求发起之前触发\n\t\t- complete：请求完成触发（不管成功与否）\n\t\t- success：请求成功之后触发（响应状态码 200）\n\t\t- error：请求失败触发\n\t\t- processData：是否让jQuery帮我们将发送给服务器的数据进行处理（默认：true表示将对象处理成字符串）\n\n\t- 快捷方法\n\n\t\t- $.get(url, [data], [callback], [dataType])\n\t\t- $.post(url, [data], [callback], [dataType])\n\n\t- 全局事件处理\n\n\t\t- 语法：\n\n\t\t\t- $.ajaxSetup({事件: 处理函数, 事件:处理函数, ...});\n\n\t\t- 示例\n\n\t\t\t- // 设置全局事件处理\n$.ajaxSetup({\n    // 设置发送请求前的事件\n    beforeSend: function () {\n        // 这里可以提示，玩命加载中...\n    },\n    // 设置完全接收响应数据后的事件\n    complete: function () {\n        // 这里可以去掉“玩命加载中...”\n    }\n});\n\n- FormData对象\n\n\t- 说明：主要用于表单发送数据\n\t- 使用方式：\n\n\t\t- 例如：var form = $(\'form\').get(0);\n          var fd = new FormData(form);\n\n\t- 注意事项：\n\n\t\t- 使用FormData的时候，form表单中的各项必须有name属性。没有name属性是收集不到数据的\n\n- 补充知识点：\n\n\t- 1.?id=457 问怎么可以拿到457\n 答：str.replace(/\\D/g,""); 使用正则将非数字剔除掉\n\t- 2.location.search  返回/设置当前的url的查询部分\n\t- 3.confirm（“你确定么”） 返回boolean\n\t- 4.console.log（）会在浏览器控制台打印出信息\n   console.dir（）可以显示一个对象所有的方法和属性\n\n## 一些容易混淆的小概念\n\n### undefined 与 not defined\n\n- 例子\n\n\t- 在c语言里面，会去严格区分声明(declared)和定义(defined),而在JS里，is not defined却会让人误以为是声明了没有定义的变量，但是实际上，却是没有声明，这个地方用ReferenceError: b is not declared\n\n- 理解\n\n\t- 某开发者想要声明两个变量，一个值类型为number的A,一个值类型为string的B，他在程序里写了\n\n\t- 这个时候实际上就是变量A去\'继承\'了type为\'undefined\'的值，B没有声明,现在就不知道继承哪种值，称为undeclared\n\n\t- 这个时候这位开发者写入\n\n\t- 那么就变成了\n\n\t- 所以此时typeof A会得到’number’，B目前存在于开发者的脑子里，所以为undeclared\n\n### 为什么[] == ![]为true？\n\n- （1）首先![] 转换为false，此时比较[] == false\n- （2）[]是对象，false转换为number，就是0，此时比较[] == 0;\n- （3）[] == 0将[]转换为字符串，就是"" == 0，然后""转换为字符串，就是0 == 0，即最终为true\n- == 的转换机制，先调用valueof，不行再调用toString\n\n### 手写原生Ajax请求\n\n- Ajax请求\n\n\t- 在这里， 我们创建了一个能向服务器发出 HTTP 请求的类的实例。然后调用其 open 方法，其中第一个参数是 HTTP 请求方法，第二个参数是请求页面的 URL。第三个参数是true（异步）或 false（同步）；最后，我们调用参数为 null 的 send 方法。假如使用 POST 请求方法（这里我们使用了 GET），那么 send 方法 的参数应该包含任何你想发送的数据。\n\n- 处理响应\n\n### Object.create 的模拟实现\n\n- 将传入的对象作为创建的对象的原型\n- 详解Object.create(null)\n\n\t- Object.create()的定义\n\n\t\t- Object.create(proto,[propertiesObject])\n\t\t- proto:新创建对象的原型对象\n\t\t- propertiesObject:可选。要添加到新对象的可枚举（新添加的属性是其自身的属性，而不是其原型链上的属性）的属性。\n\n\t- Object.creat()的使用\n\n\t- Object.create()、{…}的区别\n\n\t\t- 先看看我们经常使用的{}创建的对象是什么样子的\n\n\t\t\t- 在chrome控制台打印如下\n\n\t\t\t- 新创建的对象继承了Object自身的方法，如hasOwnProperty、toString等，在新对象上可以直接使用。\n\n\t\t- 再看看使用Object.create()创建对象\n\n\t\t\t- Object.creat(null)\n\n\t\t\t\t- 在chrome控制台打印如下\n\n\t\t\t\t- 新创建的对象除了自身属性a之外，原型链上没有任何属性，也就是没有继承Object的任何东西，此时如果我们调用o.toString()会报Uncaught TypeError的错误。\n\n\t\t\t- Object.creat({})\n\n\t\t\t\t- 在chrome控制台打印如下\n\n\t\t\t\t- 这样创建的对象和使用{}创建对象已经很相近了，但是还是有一点区别：多了一层proto嵌套。\n\n\t\t\t-  Object.create(Object.prototype)\n\n\t\t\t\t- chrome控制台打印如下\n\n\t- Object.create(null)的使用场景\n\n\t\t- 进一步比较一下Object.create(null)和{}创建控对象的区别\n\n\t\t- 使用场景\n\n\t\t\t- 使用create创建的对象，没有任何属性，显示No properties，我们可以把它当作一个非常纯净的map来使用，我们可以自己定义hasOwnProperty、toString方法，不管是有意还是不小心，我们完全不必担心会将原型链上的同名方法覆盖掉。\n\n\t\t- 举个例子\n\n\t\t- 另一个使用create(null)的理由是，在我们使用for..in循环的时候会遍历对象原型链上的属性，使用create(null)就不必再对属性进行检查了，当然，我们也可以直接使用Object.keys[]。\n\n\t- 总结\n\n\t\t- 你需要一个非常干净且高度可定制的对象当作数据字典的时候；\n\t\t- 想节省hasOwnProperty带来的一丢丢性能损失并且可以偷懒少些一点代码的时候\n\t\t- 其他时候，请用{}\n\n### New 关键字的内部实现\n\n- 当我们使用 new 操作符时，生成的实例对象拥有了 _proto_属性。在 new 的过程中，新对象被添加了 _proto_ 并且链接到构造函数的原型上。\n\n- New()的过程\n\n\t- （1）新生成了一个对象\n\t- （2）链接到原型\n\t- （3）绑定 this\n\t- （4）返回新对象\n\n- New()的实现\n\n\t- 最初版\n\n\t\t- 代码\n\n\t\t- 理解\n\n\t\t\t- （1）用new Object() 的方式新建了一个对象 obj\n\t\t\t- （2）取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数\n\t\t\t- （3）将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性\n\t\t\t- （4）使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性\n\t\t\t- （5）返回 obj\n\n\t- 完整版\n\n\t\t- 起源\n\n\t\t\t- 如果构造函数有返回值\n\n\t\t\t\t- 返回值是对象\n\n\t\t\t\t\t- 构造函数返回了一个对象，在实例 person 中只能访问返回的对象中的属性。\n\n\t\t\t\t- 返回值是基本类型\n\n\t\t\t\t\t- 结果完全颠倒过来，这次尽管有返回值，但是相当于没有返回值进行处理。\n\n\t\t- 还需要判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么。\n\n### js 中的 !! 与 ~~\n\n- !!\n\n\t- 将操作数转化为布尔类型。\n\n\t- 实际上等效于 Boolean 被当做函数调用的效果\n\n- ~~\n\n\t- 将操作数转化为 32 位有符号整数。\n\n\t- 如果你需要将一个参数转化为 32 位有符号整数，那么 ~~ 将是最简便的方式。不过要切记，它会损失精度，包括小数和整数部分。\n\t- 按位非操作符~\n\n\t\t- 作用是将数值比特位中的 1 变成 0，0 变成 1。\n',Ke={data:function(){return{MainComponent:Ye}}},Ze=Ke,ta=Object(v["a"])(Ze,Xe,Qe,!1,null,"305d37b4",null),na=ta.exports,ea=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{},[e("q-markdown",{attrs:{src:t.MainComponent}})],1)},aa=[],ra="# js2\n\n## JavaScript 高级\n\n### 编程思想：\n\n- 面向过程：\n\n\t- 什么是面向过程？\n\n\t\t- 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了\n\n\t- 优缺点：\n\n\t\t- 优点：性能比面向对象高，步骤练习紧密\n\t\t- 缺点：不好维护，不易多次使用及扩展\n\n- 面向对象：\n\n\t- 什么是面向对象？\n\n\t\t- 面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作\n\n\t- 三大特性：\n\n\t\t- 1.封装性\n\t\t- 2.继承性\n\t\t- 3.多态性\n\n\t- 优缺点：\n\n\t\t- 优点：易维护，可复用，可扩展，灵活性高\n\t\t- 缺点：性能没有面向过程高\n\n### 类和对象\n\n- ES6\n\n\t- 对象\n\n\t\t- 什么是对象？\n\n\t\t\t- 对象是具体的\n\n\t- 类\n\n\t\t- 什么是类？\n\n\t\t\t- 类模拟抽象的，泛指的\n\n\t\t- 创建类\n\n\t\t\t- 例：class 类名 {\n                                                }      类名首字母要大些\n\n\t\t- constructor构造函数\n\n\t\t\t- 例：class Star {\n\tconstructor (uname,age){\n\t\tthis.uname = uname;\n\t\tthis.age = age;\n\t}\n}\n\n\t\t\t\t- 注意：1.类里面的方法不带function，直接写既可\n\t\t\t\t- 2.类中定义属性，调用方法都得用this\n\t\t\t\t- 3.方法之间不能加逗号分隔\n\n\t\t- 继承：\n\n\t\t\t- extends\n\n\t\t- super关键字：\n\n\t\t\t- 用于访问和调用对象父类上的函数\n\n\t\t\t\t- 注意：子类在构造函数中使用super, 必须放到this 前面(必须先调用父类的构造方法,在使用子类构造方法）\n\n\t\t- 三个比较重要的注意点：\n\n\t\t\t- 在ES6中类没有变量提升，所以必须先定义类，才能通过类实例化对象.\n\t\t\t- 类里面的共有属性和方法一定要加this使用.\n\t\t\t- this指向的问题\n\n\t\t\t\t- 方法里面的this，谁调用，this就代表谁\n\t\t\t\t- 构造方法里面的this，代表当前实例对象\n\n- ES5\n\n\t- 成员\n\n\t\t- 1.静态成员\n\n\t\t\t- 不需要实例对象调用属性（不需要new）\n\n\t\t- 2.实例成员\n\n\t\t\t- 需要实例对象调用属性（需要new）\n\n\t- 构造函数原型（prototype 原型对象-构造函数的一个属性）\n\n\t\t- 1.所有的属性都要写在构造函数里面\n\t\t- 2.所有的方法都要写在原型对象里面\n\n\t- 对象原型:简称“原型”（__proto__）\n\n\t\t- 1.每一个对象都有一个原型\n\t\t- 2.作用是指向原型对象prototype\n\n\t- 构造函数 constructor\n\n\t\t- 作用：指回原来的构造函数\n\n\t- 继承：\n\n\t\t- 属性继承\n\n\t\t\t- call(this,m,n)-------m,n为不确定参数，参数个数可变\n\n\t\t- 方法继承\n\n\t\t\t- 原理：1.子类的原型对象 《=》父类的实例对象\n\t\t\t- 2.继承完毕之后，子类的constructor的指向已经不见，需要将子类的custructor手动指回\n\n### 函数\n\n- 声明方式\n\n\t- 1.命名函数\n\n\t\t- function fn（）{}\n\n\t- 2.匿名函数\n\n\t\t- var fn = function(){}\n\n\t- 3.new function函数\n\n\t\t- var fn = new Function('a', 'b', 'console.log(a + b)')\n\n- 调用：\n\n\t- 1.普通函数\n\n\t\t- function fn() {\n\tconsole.log('人生的巅峰');\n}\nfn();\n\n\t- 2.对象的方法\n\n\t\t- var o = {\n  sayHi: function() {\n  \tconsole.log('人生的巅峰');\n  }\n}\no.sayHi();\n\n\t- 3.构造函数\n\n\t\t- function Star() {};\nnew Star();\n\n\t- 4.绑定事件函数\n\n\t\t- btn.onclick = function(){}\n\n\t- 5.定时器函数\n\n\t\t- setInterval(function() {}, 1000); \n\n\t\t\t- 注意：非定时器的代码要快于定时器代码（即使定时器代码时间为0）\n\n\t- 6.立即执行函数(自调用函数)\n\n\t\t- (function (){\n\tconsole.log('自调函数');\n})();\n\n- this\n\n\t- 指向\n\n\t\t- 1.普通函数\n\n\t\t\t- window\n\n\t\t- 2.对象函数\n\n\t\t\t- 该方法所属的对象\n\n\t\t- 3.构造函数\n\n\t\t\t- new出来的实例对象\n\n\t\t- 4.绑定事件函数\n\n\t\t\t- 事件源，绑定时间对象\n\n\t\t- 5.定时器函数\n\n\t\t\t- window\n\n\t\t- 6.立即执行函数（自调用函数）\n\n\t\t\t- window\n\n\t- 改变指向\n\n\t\t- 1.call（this，m，n…………）\n\n\t\t\t- 参数:\n\n\t\t\t\t- 参数使用，逗号分隔开\n\n\t\t\t- 应用场景:\n\n\t\t\t\t- 父子继承上面\n\n\t\t- 2.apply（this，[m，n…………]）\n\n\t\t\t- 参数：\n\n\t\t\t\t- 参数使用[] 数组包含上\n\n\t\t\t- 应用场景：\n\n\t\t\t\t- 常常跟数组有关系，例如：借助Math种的最大值，最小值，求出数组中的最大值，最小值\n\n\t\t- 3.bind（this，m，n…………）\n\n\t\t\t- 参数\n\n\t\t\t\t- 参数使用，逗号分隔开\n\n\t\t\t- 应用场景\n\n\t\t\t\t- 不调用函数，并且还想改变this的指向\n\n- 模式：\n\n\t- 正常模式：\n\t- 严格模式：\n\n\t\t- 1.声明：\n\n\t\t\t- “use strict”\n\n\t\t- 2.使用位置\n\n\t\t\t- 1.函数的顶端（使当前的函数声明为严格模式）\n\t\t\t- 2.脚本的顶端（是脚本声明为严格模式）\n\n\t\t- 3.注意事项\n\n\t\t\t- 1.变量\n\n\t\t\t\t- 1.变量声明中，必须加var\n\t\t\t\t- 2.不准删除变量\n\n\t\t\t- 2.this的指向：\n\n\t\t\t\t- 正常模式：\n\n\t\t\t\t\t- 在全局的作用域下，函数中的this，指向的是window\n\n\t\t\t\t- 严格模式：\n\n\t\t\t\t\t- 在全局的作用域下，函数中的this，是undefined\n\n\t\t\t- 3.函数变化\n\n\t\t\t\t- 1.函数不能有重复函数\n\t\t\t\t- 2.非函数体内不能含有函数体\n\n- 高阶函数：\n\n\t- 1.将函数当作值传入参数\n\t- 2.将函数当作返回值返回\n\n- 闭包\n\n\t- 一个作用域访问另一个作用域内的局部变量\n\n### 递归\n\n- 什么是？\n\n\t- 函数调用函数本身\n\n- 深拷贝与浅拷贝\n\n\t- 浅拷贝\n\n\t\t- 第一层：简单数据类型\n\n\t\t\t- 扩展：ES6新增方法Object.assign(“新的”，“源的”)\n\n\t- 深拷贝\n\n\t\t- 实现复杂类型的赋值，切记不能直接赋值，考虑复杂类型地址的问题\n\n- 补充知识：\n\n\t- instenceof 判断是不是数组或者对象\n\n### 正则表达式\n\n- 什么是？\n\n\t- 匹配字符串，检索，验证，表单验证\n\n- 创建方式\n\n\t- 1.var reg = new RegExp(/abc/)\n\t- 2.var reg = /abc/\n\n- 组成\n\n\t- 简单字符和特殊字符【元字符】\n\n- 边界符\n\n\t- n表示匹配行首的文本\n\t- $表示匹配行尾的文本\n\n- 中括号\n\n\t- 例：var reg = /^[abc]$/    也可以写成    var reg = /^[a|b|c]$/\n\n\t\t- a或b或c\n\t\t- 多选1\n\n\t- ^   这个需要注意一下：括号外边是边界符，里面是取反的意思\n\n- 量词符\n\n\t- *\n\n\t\t- 重复0次或者多次\n\n\t- .\n\n\t\t- 任意的\n\n\t- +\n\n\t\t- 最少一次\n\n\t- ？\n\n\t\t- 重复0次或者1次\n\n\t- {n}\n\n\t\t- 重复n次\n\n\t- {n，}\n\n\t\t- 重复n次或者更多次\n\n\t- {n，m}\n\n\t\t- 重复n到m次\n\n- 括号总结\n\n\t- 大括号\n\n\t\t- 量词符\n\n\t\t\t- 表示重复里面的次数\n\n\t- 中括号\n\n\t\t- 匹配括号中的任意字符\n\n\t- 小括号\n\n\t\t- 表示优先级\n\n## 一些重点问题\n\n### 【ES6】Promise解决了什么问题及使用\n\n- 【异步】Promise真正解决了什么？\n\n\t- 解决了回调地狱？\n\n\t\t- “回调地狱”所说的嵌套其实是指异步的嵌套。它带来了两个问题：可读性的问题和捕获错误问题。\n\n\t- 回调地狱的真正问题不是缩进\n\n\t\t- 可读性的问题\n\n\t\t\t- 代码逻辑书写顺序与执行顺序不一致，不利于阅读与维护。\n\t\t\t- 异步操作的顺序变更时，需要大规模的代码重构。\n\t\t\t- 回调函数基本都是匿名函数，bug 追踪困难。\n\n\t\t- 捕获错误问题\n\n\t\t\t- 控制反转\n\n\t\t\t\t- 在回调函数中，控制权被交给了第三方，由第三方决定什么时候调用回调以及如何调用回调。\n\n\t\t\t- 根本问题\n\n\t\t\t\t- 回调函数真正的问题是剥夺了程序员使用return和throw等捕捉错误和返回值的能力\n\t\t\t\t- 程序的执行流程是基于一个函数在执行过程中调用另一个函数时候会产生函数调用栈，而回调函数不是运行在栈上的，因此不能使用return和throw。\n\n\t\t\t- 代码的脆弱\n\n\t\t\t\t- 假设是这两个函数有顺序依赖的关系，我们要让A发生后B才执行，我们要把它们连接到一起的话只能手工硬编码\n\t\t\t\t- 这种方法会使得代码脆弱，你要在回调中捕获错误，必须在这个回调函数中创建大量逻辑来判断处理这些可能的情况，但这毫无疑问地会严重影响代码的可读性与开发效率。\n\n\t\t\t- 举例\n\n\t\t\t\t- 比如Ajax，可能会出现很多问题\n\n\t\t\t\t\t- 对于回调过早的问题\n\t\t\t\t\t- 对于回调过晚或没有调用的问题\n\t\t\t\t\t- 对于回调次数太少或太多的问题\n\n\t\t\t- 业界其他方案\n\n\t\t\t\t- （1）分离回调\n\n\t\t\t\t\t- 一个用于成功的处理函数，一个用于错误的处理函数！\n\n\t\t\t\t- （2）error-first风格，nodejs\n\n\t\t\t\t\t- 回调第一个参数作为错误对象(if exists)。 如果成功，error为 清空/置假 ，如果失败，if(err)为真。\n\n\t\t\t\t- 问题\n\n\t\t\t\t\t- 但这并没有解决 重复调用回调的问题。 你可能同时得到成功或失败的结果！ 或者都没有！ \n\t\t\t\t\t- 事实上：你需要额外的写更多的逻辑来处理回调过快或者失败或者太慢的问题， \n\n\t- 问题的解决\n\n\t\t- 如何解决可读性的问题\n\n\t\t\t- 链式调用相当于给了你一张可以把解题思路清晰记录下来的草稿纸，你不在需要用脑子去记忆执行顺序。\n\n\t\t- 如何解决捕获错误问题\n\n\t\t\t- Promise并没有取消控制反转，而是把反转出去的控制再反转一次，也就是反转了控制反转。\n\t\t\t- 与普通的回调的方式的区别\n\n\t\t\t\t- 普通的方式\n\n\t\t\t\t\t- 回调成功之后的操作直接写在了回调函数里面，而这些操作的调用由第三方控制。\n\n\t\t\t\t- Promise的方式\n\n\t\t\t\t\t- 回调只负责成功之后的通知，而回调成功之后的操作放在了then的回调里面，由Promise精确控制。\n\t\t\t\t\t- 反转控制反转\n\n\t\t\t\t\t\t- Promise 其实应验了 CS 的名言【所有问题都可以通过加一层中间层来解决】。在解决回调嵌套的问题中，Promise 就充当了一个中间层，用来【把回调造成的控制反转再反转回去】\n\n\t\t\t\t\t- 异步前后\n\n\t\t\t\t\t\t- 在使用 Promise 的例子中，控制流分为了两个部分：触发异步前的逻辑通过 new传入 Promise，而异步操作完成后的逻辑则传入 Promise 的 then 接口中。通过这种方式，第一方业务和第三方库的相应逻辑都由 Promise 来调用，进而在 Promise 中解决异步编程中可能出现的各种问题。\n\n\t\t\t\t\t- 接近观察者模式\n\n\t\t\t\t\t\t- 这种模式其实和观察者模式是接近的。下面的代码将 resolve / then 换成了 publish / subscribe ，将通过 new Promise 生成的 Promise 换成了通过 observe 生成的 observable 实例。可以发现，这种调用同样做到了回调嵌套的解耦。这就是 Promise 魔法的关键之一。\n\n\t\t\t- 解决传统回调的问题\n\n\t\t\t\t- 对于回调过早的问题\n\n\t\t\t\t\t- Promise不必担心，因为即使是立即完成的promise，对一个promise调用then的时候，即使这个promise已经resolution，提供给then的回调也总是异步调用的\n\t\t\t\t\t- 不需要setTimeout(,,0) hack, Promise不会导致竞态。\n\n\t\t\t\t- 对于回调过晚或没有调用的问题\n\n\t\t\t\t\t- Promise本身不会回调过晚，只要决议了，它就会按照规定运行。Promise创建对象调用resolve() 或reject() 的时候， 这个promise的then(…)注册的观察回调会被自动调度。 \n\t\t\t\t\t- 至于服务器或者网络的问题，并不是Promise能解决的，一般这种情况会使用Promise的竞态APIPromise.race加一个超时的时间\n\n\t\t\t\t\t\t- race()是一个解决如果Promise永远不能被resolved的解决方法\n\n\t\t\t\t- 对于回调次数太少或太多的问题\n\n\t\t\t\t\t- 回调被调用的正确次数应该是1。Promise的定义方式使得它只能被resolved 一次，如果处于某种原因。Promise创建的代码试图call resolve(…) or reject(..)多次， 那这个promise只会接收第一次resolved，并忽略后面的调用。 \n\n\t\t\t- Promise A+规范\n\n\t\t\t\t- 1. 如果promise被resolve，它要不是success就是failure，不可能同时存在。\n\t\t\t\t- 2. 一旦promise被resolve，它就再也不会被resolve(不会出现重复调用)。\n\t\t\t\t- 3. 如果promise返回了成功的信息，那么你绑定在成功事件上的回调会得到这个消息。\n\t\t\t\t- 4. 如果发生了错误，promise会收到一个带有错误信息的错误通知。\n\t\t\t\t- 5. 无论promise最后的结果是什么(success或者failure)，他就不会改变了，你总是可以获得这个消息只要你不销毁promise。\n\n- 【异步】Promise的使用以及了解\n\n\t- （1）了解 Promise 吗？\n\n\t\t- Promise 是异步编程的一种解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。现已被 ES6 纳入进规范中。\n\n\t- （2）Promise 解决的痛点是什么？\n\n\t\t- 在 Promise 出现以前，我们处理一个异步网络请求，大概是这样：\n\n\t\t\t- 我们基本上还要对每次请求的结果进行一些处理，代码会更加臃肿，在一个团队中，代码 review 以及后续的维护将会是一个很痛苦的过程。\n\n\t\t- 回调地狱带来的负面作用有以下几点：\n\n\t\t\t- 代码臃肿。\n\t\t\t- 可读性差。\n\t\t\t- 耦合度过高，可维护性差。\n\t\t\t- 代码复用性差。\n\t\t\t- 容易滋生 bug。\n\t\t\t- 只能在回调里处理异常。\n\n\t\t- 出现了问题，自然就会有人去想办法。这时，就有人思考了，能不能用一种更加友好的代码组织方式，解决异步嵌套的问题。\n\n\t- （3）Promise 解决的痛点还有其他方法可以解决吗？如果有，请列举。\n\t- （4）Promise 如何使用？\n\n\t\t-  Promise 的常规写法：\n\n\t\t\t- 比较一下这种写法和上面的回调式的写法。我们不难发现，Promise 的写法更为直观，并且能够在外层捕获异步函数的异常信息。\n\n\t\t- 用法举例\n\n\t\t\t- 一，需求方法步骤\n\n\t\t\t\t- 你先去超市买菜。\n\t\t\t\t- 用超市买回来的菜做饭。\n\t\t\t\t- 将做好的饭菜送到老婆单位。\n\t\t\t\t- 送到单位后打电话告诉我。\n\n\t\t\t- 二，写好函数\n\n\t\t\t- 三，利用promise实现功能\n\n\t\t\t- 注意：请一定要谨记：如果我们的后续任务是异步任务的话，必须return 一个 新的 promise 对象。如果后续任务是同步任务，只需 return 一个结果即可。\n\n我们上面举的例子，除了电话通知我是一个同步任务，其余的都是异步任务，异步任务 return 的是 promise对象。\n\n\t\t- 使用总结\n\n\t\t\t- \n（1）首先初始化一个 Promise 对象，可以通过两种方式创建， 这两种方式都会返回一个 Promise 对象。\n\n\t\t\t\t- 1、new Promise(fn)\n\t\t\t\t- 2、Promise.resolve(fn)\n\n\t\t\t- （2）然后调用上一步返回的 promise 对象的 then 方法，注册回调函数。\n\n\t\t\t\t- then 中的回调函数可以有一个参数，也可以不带参数。如果 then 中的回调函数依赖上一步的返回结果，那么要带上参数。比如\n\t\t\t- （3）最后注册 catch 异常处理函数，处理前面回调中可能抛出的异常。\n\n\t- （5）Promise 常用的方法，方法的作用？\n\n\t\t- Promise.resolve(value)\n\n\t\t\t- 有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用。\n\n\t\t\t\t- Promise.resolve等价于下面的写法。\n\n\t\t\t- 1、如果这个值是个thenable（即带有then方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态（指 resolved/rejected/pending/settled）\n\n\t\t\t- 2、如果传入的 value 本身就是 promise 对象，则该对象作为 Promise.resolve 方法的返回值返回。\n\n\t\t\t- 3、其他情况以该值为成功状态返回一个 promise 对象。\n\n\t\t- Promise.reject(value)\n\n\t\t\t- 与 resolve 唯一的不同是，返回的 promise 对象的状态为 rejected。\n\n\t\t- Promise.then\n\n\t\t\t- 为 promise 注册回调函数，函数形式：fn(vlaue){}，value 是上一个任务的返回结果，then 中的函数一定要 return 一个结果或者一个新的 Promise 对象，才可以让之后的then 回调接收。\n\n\t\t- Promise.catch\n\n\t\t\t- 捕获异常，函数形式：fn(err){}, err 是 catch注册 之前的回调抛出的异常信息。\n\n\t\t- Promise.race\n\n\t\t\t- 多个promise 任务同时执行，只返回最先执行完的 Promise 任务的结果。 \n\n\t\t- Promise.all\n\n\t\t\t- 多个promise 任务同时执行，返回所有promise 任务的执行结果。\n\n\t- （6）Promise 在事件循环中的执行过程是怎样的？\n\t- （7）Promise 的升级\n\n\t\t- ES6 出现了 generator 以及 async/await 语法，使异步处理更加接近同步代码写法，可读性更好，同时异常捕获和同步代码的书写趋于一致。\n\t- （8）能不能手写一个 Promise 的polyfill。\n\n### 【ES6】说出你知道的ES6新特性\n\n- ES6常考问题\n\n\t- 为什么const定义一个数组与对象，仍然可以对其操作?\n\n\t\t- const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。\n\t\t- 对于简单类型的数据（数值、字符串、布尔值）\n\n\t\t\t- 值就保存在变量指向的那个内存地址，因此等同于常量。\n\n\t\t- 对于复合类型的数据（主要是对象和数组）\n\n\t\t\t- 变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了\n\t\t\t- 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。\n\n\t\t\t- 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。\n\n\t\t\t- 如果真的想将对象冻结，应该使用Object.freeze方法。\n\n\t\t\t\t- 上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。\n\t\t\t\t- 除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。\n\n- Promise\n\n\t- 什么是Promise？\n\n\t\t- 传统的异步编程最大的特点就是地狱般的回调嵌套，一旦嵌套次数过多，就很容易使我们的代码难以理解和维护。而Promise则可以让我们通过链式调用的方法去解决回调嵌套的问题，使我们的代码更容易理解和维护，而且Promise还增加了许多有用的特性，让我们处理异步编程得心应手。\n\t\t- 传统的异步回调函数\n\n\t\t\t- （1）每个回调函数，都会无法确定另一个回调函数会在何时会被调用，因为这个控制权不在当前这个程序之中。\n\t\t\t- （2）每个回调函数，都或多或少的依赖于上一个回调函数执行的时间和数据\n\t\t\t- 问题\n\n\t\t\t\t- 基于这两点，我们就会发现，一旦你需要这样去编写代码，就必须保证你的上一个回调函数在下一个回调函数之前进行。我们还可以发现，它们之间缺乏一种约定，就是一旦上一个发生了，无论是正确还是错误，都会通知对应的回调函数的约定。\n\n\t- 如何创建Promise？\n\n\t\t- 代码示例\n\n\t\t- 代码解释\n\n\t\t\t- （1）因为Promise是一个构造函数，所以我们使用了new操作符来创建promise。\n\t\t\t- （2）构造函数Promise的参数是一个函数（暂时叫它func），这个函数（func）有两个参数resolve和reject，它们分别是两个函数，这两个函数的作用就是将promise的状态从pending（等待）转换为resolved（已解决）或者从pending（等待）转换为rejected（已失败）。\n\t\t\t- （3）创建后的promise有一些方法，then和catch。当然我们也可以人为的在Promise函数上添加一些满足我们自己需求的方法，方便每一个promise对象使用。\n\n\t\t- 理解Promise\n\n\t\t\t- Promise函数体的内部包裹着一个异步的请求或者操作或者函数；然后我们可以在这个异步的操作完成的时候使用resolve函数将我们获得的结果传递出去，或者使用reject函数将错误的消息传递出去。\n\n\t- Promise对象的一些方法\n\n\t\t- then方法\n\n\t\t\t- 初步了解\n\n\t\t\t\t- 可以通过使用then方法将上一步返回的结果获取过来（不管是resolved还是rejected）\n\n\t\t\t- then方法的使用\n\n\t\t\t\t- 示例1\n\n\t\t\t\t\t- 也就是说，我们在创建p这个Promise对象的时候，通过函数resolve传递出去的结果可以被p的第一个then方法中的第一个函数捕获然后作为它的参数。通过函数reject传递出去的结果可以被p的第一个then方法中的第二个函数捕获然后作为它的参数。\n\n\t\t\t\t- （1）then方法可以接受两个函数作为参数，第一个函数是用来处理resolve的结果，第二个是可选的，用来处理reject的结果。\n\t\t\t\t- 示例2\n\n\t\t\t\t\t- 一旦创建一个Promise对象之后，我们就可以使用then方法来进行链式的调用，而且我们可以把每一次的结果都返还给下一个then方法，然后在下一个then方法中对这个值进行处理。每一个then方法中都可以再次新创建一个Promise对象，然后返还给下一个then方法处理。\n\n\t\t\t\t- （2）还可以在每一个then方法中创建新的Promise，然后将这个Promise对象返回，之后我们就可以在后面的then方法中继续对这个对象进行操作。\n\n\t\t- catch方法\n\n\t\t\t- 初步了解\n\n\t\t\t\t- 这个方法其实是then方法的一种特例，这个特例就是：.then(null, rejection)，相当于我们不使用then方法的第一个函数，只是用第二个函数；catch函数比较简单，就是用来捕获之前的then方法里面的异常\n\n\t\t- all方法\n\n\t\t\t- 初步了解\n\n\t\t\t\t- \nPromise.all方法用来包装许多个Promise实例，然后组成了一个新的Promise对象\n\t\t\t\t- 新的Promise对象的状态由前面几个被包裹的Promise对象的状态决定，如果前面的Promise都被resolve了，那么新的Promise的状态也是resolve的；只要有一个Promise被reject了，那么组成的新的Promise的状态也是reject的。\n\n\t\t\t- 方法的使用\n\n\t\t- race方法\n\n\t\t\t- 初步了解\n\n\t\t\t\t- 和上面的Promise.all有点类似，都是包装许多的Promise对象，然后组成了一个新的Promise对象\n\t\t\t\t- 但是使用Promise.race的含义是：只要包裹的的Promise对象中有一个的状态发生了改变，那么组成的这个新的Promise对象的状态就是上面那个率先改变的Promise实例的状态。\n\n\t\t\t- 方法的使用\n\n\t\t- resolve方法\n\n\t\t\t- 初步了解\n\n\t\t\t\t- 主要是将一个值转变为一个Promise对象，然后使它具有Promise的一些方法和特性，为了满足我们一些特殊情况下的要求。\n\n\t\t\t- 方法的使用\n\n\t\t- reject方法\n\n\t\t\t- 初步了解\n\n\t\t\t\t- 和Promise.resolve方法一样，只不过通过Promise.reject方法产生的Promise对象的状态是rejected的，\n\n- let与const\n\n\t- （1）在同一个块级作用域中，不允许重复定义。\n\t- （2）const定义的变量不允许二次修改。\n\t- （3）let和const定义的变量会形成块级作用域\n\t- （4）它们定义的变量不存在变量提升，以及存在暂时性死区\n\n- 函数的变化——箭头函数，剩余参数，参数默认值\n\n\t- 箭头函数\n\n\t\t- 规则\n\n\t\t\t- （1）变量如果只有一个的时候，可以省略()\n\t\t\t- （2）如果是只有一句返回语句时，可以直接省略{return }这一部分\n\t\t\t- （3）因为它本身叫做arrow，所以每次都必须带上=>符号\n\n\t\t- 注意事项\n\n\t\t\t- （1）箭头函数不能作为构造函数\n\n\t\t\t- （2）箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域。（取决于箭头函数定义时的作用域，不受apply，call，bind影响）\n\n\t\t\t- （3）箭头函数没有arguments。\n\n\t- rest剩余参数\n\n\t\t- ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。\n\t\t- 注意\n\n\t\t\t- （1）与扩展运算符相反\n\n\t\t\t\t- 扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。\n\n\t\t\t- （2）rest 参数之后不能再有其他参数（即只能是最后一个参数）\n\t\t\t- （3）arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组\n\n\t- 参数默认值\n\n\t\t- ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。\n\n- 数组——解构赋值、二进制数组\n\n\t- 解构赋值\n\n\t\t- 注意\n\n\t\t\t- （1）必须保证有赋值的过程。\n\n\t\t\t- （2）左边内容部分的结构必须与右边保持一致。\n\n\t\t- 使用\n\n\t\t\t- （1）默认值的使用。\n\n\t\t\t- （2）在变量中使用解构赋值\n\n\t- 二进制数组\n\n- 字符串——模版字符串、startsWith、endsWith\n\n\t- startWith\n\n\t\t- 用法\n\n\t\t\t- 返回值为boolean型，然后去匹配字符串开头的部分\n\n\t\t- 使用\n\n\t\t\t- 这个API仅仅在一些场景下起到一定的便捷。比方说，我们需要去匹配一个URL的协议头是什么时，我们往往需要用到这种方式。\n\n\t- endsWith\n\n\t\t- 用法\n\n\t\t\t- 返回值是boolean类型，然后去匹配字符串的结尾。\n\n\t\t- 使用\n\n\t\t\t- 这种情况的使用场景是，往往我们需要为上传的文件准备图标，那么我们就可以根据后缀来确定图标。\n\n- Class和extends\n\n\t- ES6的class是一种更简洁的语法糖，JS面向对象编程依然是基于原型实现的\n\n\t\t- ES5中声明类的方式\n\n\t\t- 利用class语法糖\n\n\t- extends类的继承，我们可以用extends扩展一个类并继承它的行为，在构造函数中，也可以通过super关键字引用父类的构造函数\n\n### 【This】JavaScript This 关键字的理解？以及call、apply、bind\n\n- this\n\n\t- （1）this的定义\n\n\t\t- this是在执行上下文创建时确定的一个在执行过程中不可更改的变量。\n\t\t- 执行上下文\n\n\t\t\t- 就是JavaScript引擎在执行一段代码之前将代码内部会用到的一些变量、函数、this提前声明然后保存在变量对象中的过程。\n\t\t\t- 这个'代码片段'包括：全局代码(script标签内部的代码)、函数内部代码、eval内部代码。而我们所熟知的作用域链也会在保存在这里，以一个类数组的形式存储在对应函数的[[Scopes]]属性中。\n\n\t\t- this的多变性\n\n\t\t\t- this只在函数调用阶段确定，也就是执行上下文创建的阶段进行赋值，保存在变量对象中。这个特性也导致了this的多变性:即当函数在不同的调用方式下都可能会导致this的值不同。\n\n\t- （2）严格模式与非严格模式下\n\n\t\t- 当函数独立调用的时候，在严格模式下它的this指向undefined，在非严格模式下，当this指向undefined的时候，自动指向全局对象(浏览器中就是window)\n\n\t- （3）函数的四种调用方式\n\n\t\t- 在全局环境或是普通函数中直接调用\n\n\t\t\t- 需要特别注意的情况\n\n\t\t\t\t- window, 自执行函数调用时,没有宿主对象,默认是window\n\t\t\t\t- 解释，自执行函数需要外部函数调用才会执行\n\n\t\t\t\t- 与此种情况相同（当函数独立调用的时候，在严格模式下它的this指向undefined，在非严格模式下，当this指向undefined的时候，自动指向全局对象(浏览器中就是window)。）\n\n\t\t- 作为对象的方法\n\n\t\t\t- 需要注意隐式丢失\n\n\t\t\t\t- （1）\n\n\t\t\t\t- （2）\n\n\t\t\t\t- obj对象的属性存储的是对该匿名函数的一个引用，可以理解为一个指针。当赋值给其他变量的时候，并没有单独开辟内存空间存储新的函数，而是让其存储了一个指针，此时的obj2就是一个指向匿名函数的指针，调用obj2，相当于直接调用fun，\n\n\t\t- 使用apply和call\n\t\t- 作为构造函数\n\n\t\t\t- 使用new命令时，它后面的函数调用就不是正常的调用，而是依次执行下面的步骤。\n\n\t\t\t\t- （1）创建一个空对象，作为将要返回的对象实例\n\t\t\t\t- （2）将这个空对象的原型，指向构造函数的prototype属性\n\t\t\t\t- （3）将这个空对象赋值给函数内部的this关键字\n\t\t\t\t- （4）开始执行构造函数内部的代码，并且返回这个对象\n\n\t\t\t- 当this碰到return时\n\n\t\t\t\t- 如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。\n\t- （4）箭头函数\n\n\t\t- （1）箭头函数中的this固定，箭头函数是根据外层（函数或者全局）作用域来决定this\n\n\t\t\t- 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。this对象的指向是可变的，但是在箭头函数中，它是固定的。\n\n\t\t- （2）实质上箭头函数没有自己的this，不能作为构造函数\n\n\t\t\t- this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。\n\n\t\t- （3）由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。\n\t\t- 理解\n\n\t\t\t- 1.箭头函数作为对象的方法\n\n\t\t\t\t- 作用域根据外层，即对象所在作用域\n\n\t\t\t- 2.箭头函数作为函数的返回值或者构造函数的方法\n\n\t\t\t\t- 作用域根据外层，即其父函数本身的函数作用域\n\n\t\t\t- 3.箭头函数作为回调函数\n\n\t\t\t\t- 一层箭头函数\n\n\t\t\t\t- 多层嵌套的箭头函数\n\n\t\t\t\t- 复杂情况: 普通函数和箭头函数混杂嵌套\n\n\t\t\t\t- 严格模式下的情况\n\n- bind与call，apply的区别\n\n\t- \nbind 返回的是一个函数,并没有执行原函数,只是这个函数的this指向了你给的参数\n\t- apply ，call是执行函数,这个函数的this指向了你给的第一个参数\n\n### 【闭包】什么是闭包及其应用场景\n\n- 关于闭包的黄金理解\n\n\t- （1）JavaScript中的闭包，无非就是变量解析的过程。\n\n\t  每次定义一个函数，都会产生一个作用域链（scope chain）。当JavaScript寻找变量varible时（这个过程称为变量解析），总会优先在当前作用域链的第一个对象中查找属性varible ，如果找到，则直接使用这个属性；否则，继续查找下一个对象的是否存在这个属性；这个过程会持续直至找到这个属性或者最终未找到引发错误为止。\n\n\t  \n\n\t- （2）JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。\n\n- 闭包的形成与变量的作用域以及变量的生存周期密切相关\n\n\t- 变量的作用域\n\n\t\t- （1）全局作用域\n\t\t- （2）函数作用域\n\n\t- 变量的生存周期\n\n\t\t- （1）对于全局作用域来说，生命周期是永久的，除非你主动销毁\n\t\t- （2）对于函数内的局部变量来说，随着函数调用的结束而被销毁\n\t\t- 当创建闭包时，函数执行完毕，局部变量并没有消失，这是因为在闭包里返回了一个函数的引用，它可以访问调用到原闭包（外层）函数所产生的环境，而局部变量一直处于这个环境之中，既然局部变量所在的函数还能被外界所访问到，这个局部变量就有了不被销毁的理由，在这里产生了一个闭包结构，局部变量的生命看起来被延续了\n\n- 闭包的应用\n\n\t- （1）管理私有变量和私有方法，将对变量（状态）的变化封装在安全的环境中\n\t- （2）将代码封装成一个闭包形式，等待时机成熟的时候再使用，比如实现柯里化和反柯里化\n\n\t\t- 函数柯里化\n\n\t\t\t- 柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。\n\n- 闭包引发的问题\n\n\t- \n闭包和内存泄露有关系的地方是，使用闭包的同时比较容易造成循环引用，如果闭包的作用域链中保存着一些DOM节点，这时候就有可能造成内存泄漏\n\n\t\t- 解决：把循环引用中的变量设为null即可，即为切断变量和它此前引用的值之间的连接，当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存\n\t\t- 举个例子\n\n\t\t- 解决\n\n\t- 关于JS内存泄露\n\n\t\t- （1）什么是内存泄漏？\n\n\t\t\t- 程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。\n\t\t\t- 对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。\n\t\t\t- 不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。\n\n\t\t- （2）垃圾回收机制\n\n\t\t\t- 存在理由\n\n\t\t\t\t- 有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。\n\t\t\t\t- 这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为\"垃圾回收机制\"（garbage collector）。\n\n\t\t\t- JS中的垃圾回收机制\n\n\t\t\t\t- （1）标记清除（现代浏览器使用）\n\n\t\t\t\t\t- 通常javascript通过标记变量的状态来判断是否被回收,当变量在函数中被声明时标记进入环境,在函数执行结束时,环境被销毁标记离开环境等待回收.只要不释放进入环境的变量,他在环境中的任何位置任何时刻都可以被访问,就不会被垃圾回收机所回收.\n\n\t\t\t\t\t- 标记清除算法将“不再使用的对象”定义为“无法达到的对象”\n\n\t\t\t\t\t\t- 简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。\n\n\t\t\t\t\t- 问题\n\n\t\t\t\t\t\t- 对现代浏览器来说，唯一要注意的就是明确切断需要回收的对象与根部的联系。有时候这种联系并不明显，且因为标记清除算法的强壮性，这个问题较少出现。最常见的内存泄露一般都与DOM元素绑定有关：\n\n\t\t\t\t\t\t\t- div元素已经从DOM树中清除，也就是说从DOM树的根部无法触及该div元素了。但是请注意，div元素同时也绑定了email对象。所以只要email对象还存在，该div元素将一直保存在内存中。\n\n\t\t\t\t- （2）引用计数（IE）\n\n\t\t\t\t\t- javascript去维护一张表,存储内存中资源的引用次数,资源被引用+1,结束引用或者函数执行完毕结束作用域,引用次数-1,引用次数由1到0时不会执行,节省开销,直接标记\n\n\t\t\t\t\t- 问题\n\n\t\t\t\t\t\t- 这个方式存在一个比较大的问题就是循环引用，就是说A对象包含一个指向B的指针，对象B也包含一个指向A的引用。 这就可能造成大量内存得不到回收（内存泄露），因为它们的引用次数永远不可能是 0 。\n\t\t\t\t\t\t- 例子\n\n\t\t\t\t\t\t\t- 执行这段代码的时候，将匿名函数对象赋值给el的onclick属性；然后匿名函数内部又引用了el对象，存在循环引用，所以不能被回收；\n\n\t\t\t\t\t\t- 解决方法：\n\n\t\t- （3）内存泄漏的识别方法\n\n\t\t\t- 1、经验方法\n\n\t\t\t\t- 如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。 这要我们实时查看内存占用。\n\n\t\t\t- 2、浏览器方法\n\n\t\t\t\t- 1）打开开发者工具，选择 Timeline 面板\n\t\t\t\t- 2）在顶部的Capture字段里面勾选 Memory\n\t\t\t\t- 3）点击左上角的录制按钮。\n\t\t\t\t- 4）在页面上进行各种操作，模拟用户的使用情况。\n\t\t\t\t- 4）一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。\n\t\t\t\t- 如果内存占用基本平稳，接近水平，就说明不存在内存泄漏。 反之，就是内存泄漏了。\n\n\t\t\t- 3、命令行方法\n\n\t\t\t\t- 命令行可以使用 Node 提供的 process.memoryUsage 方法。（判断内存泄漏，以heapUsed字段为准。）\n\t\t\t\t\t- rss（resident set size）：所有内存占用，包括指令区和堆栈。\n\t\t\t\t\t- heapTotal：\"堆\"占用的内存，包括用到的和没用到的。\n\t\t\t\t\t- heapUsed：用到的堆的部分。\n\t\t\t\t\t- external： V8 引擎内部的 C++ 对象占用的内存。\n\n\t\t- （4）WeakMap\n\n\t\t\t- 问题的提出\n\n\t\t\t\t- 及时清除引用非常重要。但是，你不可能记得那么多，有时候一疏忽就忘了，所以才有那么多内存泄漏。\n\t\t\t\t- 最好能有一种方法，在新建引用的时候就声明，哪些引用必须手动清除，哪些引用可以忽略不计，当其他引用消失以后，垃圾回收机制就可以释放内存。这样就能大大减轻程序员的负担，你只要清除主要引用就可以了。\n\n\t\t\t- ES6的弱引用\n\n\t\t\t\t- ES6 考虑到了这一点，推出了两种新的数据结构：WeakSet 和 WeakMap。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个\"Weak\"，表示这是弱引用。\n\n\t\t\t- 使用\n\n\t\t\t\t- 解释\n\n\t\t\t\t\t- 先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。\n\t\t\t\t\t- 也就是说，DOM 节点对象的引用计数是1，而不是2。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。\n\n\t\t\t\t- 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。\n\n### 【防抖与节流】JS中的函数防抖与节流\n\n- 函数防抖\n\n\t- 解释\n\n\t\t- 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。\n\n\t- 实现\n\n- 函数节流\n\n\t- 解释\n\n\t\t- 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。\n\n\t- 实现\n\n- 区别以及应用场景\n\n\t- 区别\n\n\t\t- 假设，我们观察的总时间为10秒钟，规定1秒作为一次事件的最小间隔时间。\n\n\t\t\t- 如果触发事件的频率是 0.5s/次，那么\n\n\t\t\t\t- 函数防抖\n\n\t\t\t\t\t- 因为始终没法等一秒钟就被再次触发了，所以最终没有一次事件是成功的。\n\n\t\t\t\t- 函数节流\n\n\t\t\t\t\t- 因为控制了最多一秒一次，频率为0.5s/次，所以每一秒钟就有一次事件作废。最终控制成1s/次\n\n\t\t\t- 如果触发事件的频率是 2s/次，那么\n\n\t\t\t\t- 函数防抖\n\n\t\t\t\t\t- 因为2s/次已经大于了规定的最小时间，所以每计时两秒便触发一次。\n\n\t\t\t\t- 函数节流\n\n\t\t\t\t\t- 同样，2s/次 大于了最小时间规定，所以每一次触发都生效。\n\n\t- 应用场景\n\n\t\t- 函数防抖（哪些时候对于连续的事件响应我们只需要执行一次回调？）\n\n\t\t\t- 适合多次事件一次响应的情况\n\n\t\t\t\t- \n（1）文本输入的验证（连续输入文字后发送 AJAX 请求进行验证，验证一次就好）\n\t\t\t\t- （2）判断scroll是否滑到底部，滚动事件+函数防抖\n\t\t\t\t- （3）调节浏览器size，监听resize()函数\n\n\t\t\t\t\t- 对于浏览器窗口，每做一次 resize 操作，发送一个请求，很显然，我们需要监听 resize 事件，但是和 mousemove 一样，每缩小（或者放大）一次浏览器，实际上会触发 N 多次的 resize 事件，用节流？节流只能保证定时触发，我们一次就好，这就要用去抖。\n\n\t\t\t- 简单的说，函数去抖就是对于一定时间段的连续的函数调用，只让其执行一次。\n\n\t\t- 函数节流（哪些时候我们需要间隔一定时间触发回调来控制函数调用频率？）\n\n\t\t\t- 适合大量事件按时间做平均分配触发\n\n\t\t\t\t- （1）DOM 元素的拖拽功能实现（mousemove）\n\n\t\t\t\t\t- 实现一个原生的拖拽功能（不能用 H5 Drag&Drop API），需要一路监听 mousemove 事件，在回调中获取元素当前位置，然后重置 dom 的位置（样式改变）。如果我们不加以控制，每移动一定像素而触发的回调数量是会非常惊人的，回调中又伴随着 DOM 操作，继而引发浏览器的重排与重绘，性能差的浏览器可能就会直接假死，这样的用户体验是非常糟糕的。我们需要做的是降低触发回调的频率，比如让它 500ms 触发一次，或者 200ms，甚至 100ms，这个阈值不能太大，太大了拖拽就会失真，也不能太小，太小了低版本浏览器可能就会假死，这样的解决方案就是函数节流，英文名字叫「throttle」。\n\n\t\t\t\t- （2）射击游戏的 mousedown/keydown 事件（单位时间只能发射一颗子弹）\n\t\t\t\t- （3）计算鼠标移动的距离（mousemove）\n\t\t\t\t- （4）Canvas 模拟画板功能（mousemove）\n\t\t\t\t- （5）搜索联想（keyup）\n\t\t\t\t- （6）监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次\n\n\t\t\t- 函数节流的核心是，让一个函数不要执行得太频繁，减少一些过快的调用来节流。\n\n### 【深浅拷贝】JavaScript 对象的浅拷贝和深拷贝区别？\n\n- 怎么判断两个对象相等？\n\n\t- 浅度比较\n\n\t\t- 使用JSON.stringify序列化一个对象时\n\n\t\t\t- （1）序列化后的属性出现的顺序是不定的，除了数组中的元素-其按数组中位置顺序序列化\n\t\t\t- （2）Boolean/Number/String对象转成其原始值\n\t\t\t- （3）如果属性值为undefined、函数对象，symbol(ES6中新类型)，那么这个属性要么在序列化的时候被忽略，要么被转成null（当在数组中出现时）\n\t\t\t- （4）以symbol类型为属性key的属性被完全忽略\n\t\t\t- （5）不可枚举的属性也被忽略\n\n\t- 深度比较\n\n\t\t- underscore中的eq函数源码\n\n- 浅拷贝\n\n\t- 定义\n\n\t\t- 只会将对象的各个属性进行依次复制，并不会进行递归复制，而js存储对象都是存地址的，所以浅复制会导致old.c和new.c 指向同一块内存地址；会导致引用。\n\n\t- 实现\n\n\t\t- （1）简单的赋值语句\n\n\t\t- （2）Object.assign(目标对象，源对象)\n\n\t\t\t- Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign() 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。\n\n- 深拷贝\n\n\t- 定义\n\n\t\t- 它不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上。这就不会存在上面old和new的c属性指向同一个对象的问题。\n\n\t- 实现\n\n\t\t- （1）JSON.parse()方法\n\n\t\t\t- 使用JSON.stringify进行序列化，JSON.parse进行反序列化，实现\"偷懒版\"的深复制\n\t\t\t- 坏处：\n\n\t\t\t\t- （1）它会抛弃对象的constructor。也就是深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成Object。\n\t\t\t\t- （2）这种方法能正确处理的对象只有 Number, String, Boolean, Array, 扁平对象，即那些能够被 json 直接表示的数据结构。RegExp对象是无法通过这种方式深拷贝。\n\t\t\t\t- （3）用此法无法深复制对象中的方法\n\n\t\t\t\t\t- 原因是 一个对象 上可能还有很多其他的无法被转为json string的东西\n\n\t\t\t\t- （4）通过 deep clone 一般都是有限定复制层次的，一般情况下不会无限层的复制下去。如果使用 JSON 方式来复制，通常不能控制层次。\n\n\t\t\t- JSON.parse()是怎么实现深拷贝的？\n\n\t\t\t\t- var a = JSON.stringify(oldObject)  \n// a是一个oldObject序列化后得到的字符串 和 oldObject没任何关系的新对象\n\t\t\t\t- var b = JSON.parse(a); \n// b 是从字符串a反序列化为一个全新的对象 所以 不但和a没关系 和oldObject更没关系\n\t\t\t\t- 序列化是一种将对象以一连串的字节描述的过程；反序列化是一种将这些字节重建成一个对象的过程\n\n\t\t- （2）使用递归拷贝\n\n\t\t\t- 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况\n\n\t\t- （3）$.extend()的深拷贝和浅拷贝\n\n\t\t\t- 用法\n\n\t\t\t- $.extend()的浅拷贝\n\n\t\t\t\t- 如果第二个参数对象有的属性第一个参数对象也有，那么不会进行相同参数内部的比较，直接将第一个对象的相同参数覆盖。\n\n\t\t\t- $.extend()的深拷贝\n\n\t\t\t\t- ：如果第二个参数对象有的属性第一个参数对象也有，还要继续在这个相同的参数向下一层找，比较相同参数的对象中是否还有不一样的属性，如果有，将其继承到第一个对象，如果没有，则覆盖。\n\n- 区别？\n\n\t- \n浅复制只复制一层对象的属性，而深复制则递归复制了所有层级。浅复制是对对象地址的复制，而深复制则是让其指向不同的堆内存\n\t- 浅拷贝\n\n\t\t- 深拷贝\n\n- 堆内存与栈内存\n\n\t- 为什么会有栈内存和堆内存之分？\n\n\t\t- 通常与垃圾回收机制有关。为了使程序运行时占用的内存最小。\n\t\t- stack为自动分配的内存空间，它由系统自动释放；而heap则是动态分配的内存，大小不定也不会自动释放。　\n\n\t- 什么存于栈内存？什么存于堆内存？\n\n\t\t- 当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；\n\t\t- 当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。\n\n\t- 区别\n\n\t\t- 栈中存储的是基础变量以及一些对象的引用变量，基础变量的值是存储在栈中，而引用变量存储在栈中的是指向堆中的数组或者对象的地址，这就是为何修改引用类型总会影响到其他指向这个地址的引用变量。\n\n### 【事件流】什么是事件流，事件代理委托原理\n\n- 事件流\n\n\t- 定义\n\n\t\t-  事件流描述的是从页面中接受事件的顺序\n\t\t- document.querySelector(）\n\n\t\t\t- 如果没有找到匹配元素，则返回 null，如果找到多个匹配元素，则返回第一个匹配到的元素。\n\n\t\t- target.addEventListener(type, listener[, useCapture])\n\n\t\t\t- 接受三个参数。\n\n\t\t\t\t- type：事件名称，大小写敏感。\n\t\t\t\t- listener：监听函数。事件发生时，会调用该监听函数。\n\t\t\t\t- useCapture：布尔值，表示监听函数是否在捕获阶段（capture）触发，默认为false（监听函数只在冒泡阶段被触发）。\n\n\t- 事件捕获的三个阶段\n\n\t\t- 事件捕获阶段\n\t\t- 目标阶段\n\t\t- 事件冒泡阶段\n\n\t- Event对象的常见应用\n\n\t\t- 取消事件的默认行为\n\n\t\t\t- event.preventDefault()\n\n\t\t- 取消事件的进一步捕获或冒泡\n\n\t\t\t- event.stopPropagation()\n\n\t\t- 处理事件响应优先级\n\n\t\t\t- event.stopImmediatePropagation()\n\n\t\t- 当前被绑定事件的对象\n\n\t\t\t- event.currentTarget\n\n\t\t- 当前被点击的对象\n\n\t\t\t- event.target\n\n- 事件的代理\n\n\t- 原理\n\n\t\t- 事件代理就是在祖先级DOM元素绑定一个事件，当触发子孙级DOM元素的事件时，利用事件流的原理来触发绑定在祖先级DOM的事件。\n\n\t- 检查事件源event.target\n\n### 【面试：JS运行机制】\n\n- 【面试：JS 执行机制】这一次，彻底弄懂 JavaScript 执行机制\n\n\t- 关于多线程\n\n\t\t- 一切javascript版的\"多线程\"都是用单线程模拟出来的\n\n\t- javascript事件循环\n\n\t\t- 同步任务\n\n\t\t\t- 当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。\n\n\t\t- 异步任务\n\n\t\t\t- 而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。\n\n\t\t\t- （1）同步和异步任务分别进入不同的执行\"场所\"，同步的进入主线程，异步的进入Event Table并注册函数。\n\t\t\t- （2）当指定的事情完成时，Event Table会将这个函数移入Event Queue（事件队列）。\n\t\t\t- （3）主线程内的任务执行完毕为空，会去Event Queue（事件队列）读取对应的回调函数，进入主线程执行。\n\t\t\t- （4）上述过程会不断重复，也就是常说的Event Loop(事件循环)。\n\n\t\t- 怎么知道主线程执行栈为空啊？\n\n\t\t\t- js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。\n\n- 【面试：JS 执行机制】从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理\n\n\t- 区分进程和线程\n\n\t\t- \n- 进程是一个工厂，工厂有它的独立资源 -> 系统分配的内存（独立的一块内存）\n\t\t- - 工厂之间相互独立 -> 进程之间相互独立\n\t\t- - 线程是工厂中的工人，多个工人协作完成任务 -> 多个线程在进程中协作完成任务\n\t\t- - 工厂内有一个或多个工人 -> 一个进程由一个或多个线程组成\n\t\t- - 工人之间共享空间 -> 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）\n\t\t- 线程与进程\n\n\t\t\t- \n进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）\n\t\t\t- 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）\n\n\t\t- tips\n\n\t\t\t- \n不同进程之间也可以通信，不过代价较大\n\t\t\t- 现在，一般通用的叫法：单线程与多线程，都是指在一个进程内的单和多。（所以核心还是得属于一个进程才行）\n\n\t- 浏览器是多进程的\n\n\t\t- 初步认知\n\n\t\t\t- \n浏览器是多进程的\n\t\t\t- 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）\n\t\t\t- 简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。\n\n\t\t- 浏览器都包含哪些进程？\n\n\t\t\t- Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有\n\n\t\t\t\t- 负责浏览器界面显示，与用户交互。如前进，后退等\n\t\t\t\t- 负责各个页面的管理，创建和销毁其他进程\n\t\t\t\t- 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上\n\t\t\t\t- 网络资源的管理，下载等\n\n\t\t\t- 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建\n\t\t\t- GPU进程：最多一个，用于3D绘制等\n\t\t\t- 浏览器渲染进程（浏览器内核）（Render进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为页面渲染，脚本执行，事件处理等\n\n\t\t- 浏览器多进程的优势\n\n\t\t\t- 避免单个page crash影响整个浏览器\n\t\t\t- 避免第三方插件crash影响整个浏览器\n\t\t\t- 多进程充分利用多核优势\n\t\t\t- 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性\n\t\t\t- 简单理解\n\n\t\t\t\t- 如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。当然，内存等资源消耗也会更大，有点空间换时间的意思。\n\n\t\t\t\t\t- orw83p\n\n\t\t- 重点是浏览器内核（Renderer渲染进程）\n\n\t\t\t- 初步认知\n\n\t\t\t\t- 对于普通的前端操作来说，最终要的是渲染进程，页面的渲染，JS的执行，事件的循环，都在这个进程内进行\n\n\t\t\t- 该进程包含线程有：\n\n\t\t\t\t- GUI渲染线程\n\n\t\t\t\t\t- 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。\n\t\t\t\t\t- 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行\n\t\t\t\t\t- 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。\n\n\t\t\t\t- JS引擎线程\n\n\t\t\t\t\t- \n也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）\n\t\t\t\t\t- JS引擎线程负责解析Javascript脚本，运行代码。\n\t\t\t\t\t- JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序\n\t\t\t\t\t- 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。\n\n\t\t\t\t- 事件触发线程\n\n\t\t\t\t\t- \n归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）\n\t\t\t\t\t- 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中\n\t\t\t\t\t- 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理\n\t\t\t\t\t- 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）\n\n\t\t\t\t- 定时触发器线程\n\n\t\t\t\t\t- \n传说中的setInterval与setTimeout所在线程\n\t\t\t\t\t- 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）\n\t\t\t\t\t- 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）\n\t\t\t\t\t- 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。\n\n\t\t\t\t- 异步http请求线程\n\n\t\t\t\t\t- \n在XMLHttpRequest在连接后是通过浏览器新开一个线程请求\n\t\t\t\t\t- 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。\n\n\t\t- Browser进程和浏览器内核（Renderer进程）的通信过程\n\n\t\t\t- 初步理解\n\n\t\t\t\t- \n如果自己打开任务管理器，然后打开一个浏览器，就可以看到：任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程）\n\n\t\t\t- 整个过程\n\n\t\t\t\t- Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程\n\t\t\t\t- Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染\n\n\t\t\t\t\t- 渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染\n\t\t\t\t\t- 当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）\n\t\t\t\t\t- 最后Render进程将结果传递给Browser进程\n\n\t\t\t\t- Browser进程接收到结果并将结果绘制出来\n\n\t- 梳理浏览器内核中线程之间的关系\n\n\t\t- GUI渲染线程与JS引擎线程互斥\n\n\t\t\t- \n由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。\n\t\t\t- 因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。\n\n\t\t- JS阻塞页面加载\n\n\t\t\t- \n假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。 然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。\n\t\t\t- 所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。\n\n\t\t- WebWorker，JS的多线程？\n\n\t\t\t- 初步理解\n\n\t\t\t\t- 前文中有提到JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？\n\n\t\t\t- Web Worker\n\n\t\t\t\t- \n创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）\n\t\t\t\t- JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）\n\t\t\t\t- 所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程，只待计算出结果后，将结果通信给主线程即可，perfect!\n\n\t\t\t- WebWorker与SharedWorker\n\n\t\t\t\t- Web Worker\n\n\t\t\t\t\t- WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享\n\t\t\t\t\t- 所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。\n\n\t\t\t\t- SharedWorker\n\n\t\t\t\t\t- SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用\n\t\t\t\t\t- 所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。\n\n\t\t\t\t- 本质上就是进程和线程的区别。SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程\n\n\t- 简单梳理下浏览器渲染流程\n\n\t\t- 前期工作\n\n\t\t\t- 浏览器输入url，浏览器主进程接管，开一个下载线程，然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，随后将内容通过RendererHost接口转交给Renderer进程\n\n- 浏览器渲染流程开始\n\n\t\t- 浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤\n\n\t\t\t- 解析html建立dom树\n\t\t\t- 解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）\n\t\t\t- 布局render树（Layout/reflow），负责各元素尺寸、位置的计算\n\t\t\t- 绘制render树（paint），绘制页面像素信息\n\t\t\t- 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。\n\t\t\t- 渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了\n\n\t\t- load事件与DOMContentLoaded事件的先后\n\n\t\t\t- 当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。 (譬如如果有async加载的脚本就不一定完成)\n\t\t\t- 当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。 （渲染完毕了）\n\t\t\t- 顺序是：DOMContentLoaded -> load\n\n\t\t- CSS加载（头部引入CSS时）是否会阻塞DOM树渲染？\n\n\t\t  因为你加载css的时候，可能会修改下面DOM节点的样式，\n\n\t\t  如果css加载不阻塞render树渲染的话，那么当css加载完之后，\n\n\t\t  render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。\n\n\t\t  所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后，\n\n\t\t  在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。\n\n\t\t\t- css是由单独的下载线程异步下载的。\n\t\t\t- css加载不会阻塞DOM树解析（异步加载时DOM照常构建）\n\t\t\t- 但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）\n\n\t\t- 普通图层和复合图层\n\n\t\t\t- 浏览器渲染的图层一般包含两大类：普通图层以及复合图层\n\t\t\t- 首先，普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中）\n\t\t\t- 其次，absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层。\n\t\t\t- 然后，可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源 （当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）\n\t\t\t- 可以简单理解下：GPU中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒\n\t\t\t- 【重点！！！】如何变成复合图层（硬件加速）\n\n\t\t\t\t- （1）最常用的方式：translate3d、translateZ\n\t\t\t\t- （2）opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）\n\t\t\t\t- （3）will-chang属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）\n\t\t\t\t- （4）<video><iframe><canvas><webgl>等元素\n\t\t\t\t- （5）其它，譬如以前的flash插件\n\n\t\t\t- absolute和硬件加速的区别\n\n\t\t\t\t- absolute虽然可以脱离普通文档流，但是无法脱离默认复合层。所以，就算absolute中信息改变时不会改变普通文档流中render树，但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。（浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的）\n\t\t\t\t- 而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层 （当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）\n\n\t\t\t- 复合图层的作用？\n\n\t\t\t\t- 一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能\n\t\t\t\t- 但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡\n\n\t- 从Event Loop谈JS的运行机制\n\n\t\t- 发生时机\n\n\t\t\t- 到此时，已经是属于浏览器页面初次渲染完毕后的事情，JS引擎的一些运行机制分析。\n\n\t\t- Event Loop（事件循环机制的核心是：JS引擎线程和事件触发线程）\n\n\t\t\t- JS分为同步任务和异步任务\n\t\t\t- 同步任务都在主线程上执行，形成一个执行栈\n\t\t\t- 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。\n\t\t\t- 一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。\n\n\t\t- 单独说说定时器\n\n\t\t\t- 为什么需要定时器线程？\n\n\t\t\t\t- 为什么要单独的定时器线程？因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时。\n\n\t\t\t- 什么时候会用到定时器线程？\n\n\t\t\t\t- 当使用setTimeout或setInterval时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。\n\n\t\t\t- 代码的执行情况\n\n\t\t\t- setTimeout而不是setInterval\n\n\t\t\t\t- setTimeout\n\n\t\t\t\t\t- 每次setTimeout计时到后就会去执行，然后执行一段时间后才会继续setTimeout，中间就多了误差 （误差多少与代码执行时间有关）\n\n\t\t\t\t- setInterval\n\n\t\t\t\t\t- setInterval则是每次都精确的隔一段时间推入一个事件 （但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了）\n\t\t\t\t\t- JS引擎会对setInterval进行优化，如果当前事件队列中有setInterval的回调，不会重复添加。不过，仍然是有很多问题。。。\n\n\t\t\t- 事件循环进阶：macrotask与microtask\n\n\t\t\t\t- 初步认识\n\n\t\t\t\t\t- \nJS中分为两种任务类型：macrotask和microtask，在ECMAScript中，microtask称为jobs，macrotask可称为task\n\n\t\t\t\t- macrotask（又称之为宏任务）\n\n\t\t\t\t\t- 可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）\n\t\t\t\t\t- 每一个task会从头到尾将这个任务执行完毕，不会执行其它\n\t\t\t\t\t- 浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染 （task->渲染->task->...）\n\n\t\t\t\t- microtask（又称为微任务）\n\n\t\t\t\t\t- 可以理解是在当前 task 执行结束后立即执行的任务\n\t\t\t\t\t- 也就是说，在当前task任务后，下一个task之前，在渲染之前\n\t\t\t\t\t- 所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染\n\t\t\t\t\t- 也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）\n\n\t\t\t\t- 什么样的场景会形成macrotask和microtask？\n\n\t\t\t\t\t- macrotask：主进程，setTimeout，setInterval，setImmediate, I/O, rendering等（可以看到，事件队列中的每一个事件都是一个macrotask）\n\t\t\t\t\t- microtask：Promise，process.nextTick，Object.observe, MutationObserver等\n\n\t\t\t\t- 各自使用时机？\n\n\t\t\t\t\t- 至于什么时候需要使用 microtask 呢? 我觉得这个问题很好地指出两者(macrotask, microtask)的不同, 在你觉得需要将这个异步任务同步化的时候, 就使用\nmicrotask , 否则就使用 macrotask.换种说法, 也就是这个任务你需要尽可能快地执行, 就使用 microtask.\n\n\t\t\t\t- 补充：在node环境下，process.nextTick的优先级高于Promise，也就是可以简单理解为：在宏任务结束后会先执行微任务队列中的nextTickQueue部分，然后才会执行微任务中的Promise部分。\n\t\t\t\t- 小测试加补充：setTimeout触发时机不明，受机器与运行环境影响很大，产生很多不确定的因素。\n\n### 【异步设计】探寻JavaScript的异步设计（理解性）\n\n- 开始\n\n\t- 一切得先从CPU开始讲起，CPU的指令执行速度是远高于硬盘读取速度和主存读取速度的。而I/O操作就会涉及到硬盘存取和主存读取，常见的I/O操作有文件I/O,网络I/O。(I/O = Input / Output)。\n\t- 所以，观察以下这一段伪代码：\n\n\t\t- 在CPU眼中，他会把代码看成这两部分：\n\n\t\t\t- 绿色部分因为不涉及到I/O操作，所以CPU执行速度超快，但是当运行到红色部分时，却是一个非常耗时的操作，而这段时间，CPU是处于一个’无所事事’的状态（DMA获取总线控制权之后一切I/O与CPU无关），因为文件如果没有读取进来，下面的工作也无法开展。\n\n\t- 同步在这里的意思，即书写代码的顺序就是代码执行的顺序，如果JavaScript设计成同步的话，那么当执行到openFile这一行的时候，将会等待该I/O操作完成CPU才继续往下执行。\n\n\t\t- 设想一下，当发送Ajax请求(网络I/O)的时候，整个页面被阻塞无法操作将会是多差的体验。\n\t\t- 而诸如鼠标点击事件，滑动事件，失焦事件，在CPU看来，都是处理得特别慢的事件（虽然对我们来说是一瞬间的事情），如果将JavaScript设计成同步，也会特别浪费CPU性能。\n\n\t- 而阻塞和非阻塞关注CPU在I/O发生时的工作情况\n\n\t\t- 怎样理解阻塞非阻塞与同步异步的区别？\n\n\t\t\t- 1.同步与异步\n\n\t\t\t\t- 概述\n\n\t\t\t\t\t- 同步和异步关注的是消息通信机制\n\n\t\t\t\t- 同步\n\n\t\t\t\t\t- 就是在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了。\n\t\t\t\t\t- 换句话说，就是由*调用者*主动等待这个*调用*的结果。\n\n\t\t\t\t- 异步\n\n\t\t\t\t\t- 相反，*调用*在发出之后，这个调用就直接返回了，所以没有返回结果。\n\t\t\t\t\t- 换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在*调用*发出后，*被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用。\n\n\t\t\t\t- 举个通俗的例子\n\n\t\t\t\t\t- 你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下\"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。\n\t\t\t\t\t- 而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。\n\n\t\t\t- 2. 阻塞与非阻塞\n\n\t\t\t\t- 概述\n\n\t\t\t\t\t- 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.\n\n\t\t\t\t- 阻塞\n\n\t\t\t\t\t- 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。\n\n\t\t\t\t- 非阻塞\n\n\t\t\t\t\t- 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。\n\n\t\t\t\t- 还是上面的例子\n\n\t\t\t\t\t- 你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果\n\t\t\t\t\t- 如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。\n\t\t\t\t\t- 在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。\n\n\t\t\t- 阻塞和非阻塞，应该描述的是一种状态，同步与非同步描述的是行为方式\n\n\t\t- 阻塞式\n\n\t\t\t- 在上面这个读取文件的例子中，如果在读取文件的同时，该线程被‘挂起’（可以理解为进程的阻塞态），CPU不在关注这个线程直到结果被返回，属于阻塞式\n\n\t\t- 非阻塞式\n\n\t\t\t- 如果在读取文件的同时，CPU会时不时关注并检查一遍结果是否返回，则属于非阻塞式\n\n\t- 异步则解决了代码被耗时任务阻止其往下执行的缺点\n\n- 多线程异步有着比较好的解决方案\n\n\t- （1）给涉及到I/O操作的部分新开一个线程执行\n\t- （2）主线程不等待继续往下执行\n\t- （3）I/O线程执行完之后将结果写回公共区并通知主线程(也可以是主线程去轮询)\n\t- （3）主线程执行其回调\n\n- JavaScript是一门单线程语言，本身无法提供多线程，那么是通过怎样的机制来实现异步的？\n\n\t- 先给出答案\n\n\t\t- JavaScript通过事件循环和浏览器各线程协调共同实现异步\n\n\t- JavaScript认为任务分为两种\n\n\t\t- 一种是全由CPU决定完成速度的任务，我们称其为同步任务。\n\t\t- 一种是由多种因素（如硬盘读取速度，网速，点击反馈速度）决定完成速度的任务，我们称其为异步任务。\n\t\t- 举个简单的例子\n\n\t\t\t- 函数声明，for循环，变量声明，赋值操作等都可以属于同步任务\n\t\t\t- 读取文件，网络请求，网页事件都看做异步任务\n\n\t- 事件循环\n\n\t\t- JavaScript将所有的异步任务都会放进一个队列里面，在执行完所有的同步任务之后，会去队列中找到最先进入队列的异步任务执行。\n\n\t\t- 仔细观察上图，结合浏览器多线程设计：\n\n\t\t\t- JavaScript线程首先执行同步任务\n\t\t\t- 在执行完同步任务之后，会去异步任务队列的队头取出任务执行\n\t\t\t- 浏览器各个线程会在事件触发且完成事件之后将回调函数写入异步队列（先进先出队列）\n\n\t\t- 事件循环\n\n\t\t\t- 因为诸如事件触发，http请求都是耗时无法直接确定的任务，也就是说JavaScript线程无法得知异步的任务回调函数究竟什么时候会写入异步任务队列，那么这个地方，就需要一个机制，去时刻轮询这个任务队列，这就是事件循环(event loop)\n\n- 讨论下为什么这样设计\n\n\t- 因为JavaScript的工作环境是一个典型的异步应用场景：充斥着各种ajax事件和浏览器事件。各个事件的触发时间和得到反馈的时间都不得而知，如果设计成同步语言，将会带来极差的浏览器使用体验。\n\t- 浏览器需要做的事情太多了，一手需要负责渲染，一手需要负责http请求，一手还需要执行JavaScript，将JavaScript设计成单线程不仅能够让浏览器更好地控制各个线程，同时对开发者来说也更简单。多线程涉及到锁，临界区，冲突解决的学习成本还是比较高的。\n\n### 【执行机制】JS执行机制与异步队列\n\n- Event Loop\n\n\t- 一个 Event Loop 中，可以有一个或者多个任务队列(task queue)，一个任务队列便是一系列有序任务(task)的集合；每个任务都有一个任务源(task source)，源自同一个任务源的 task 必须放到同一个任务队列，从不同源来的则被添加到不同队列。\n\n- 每一次循环tick，分为四个关键步骤\n\n\t- 在此次 tick 中选择最先进入队列的任务(oldest task)，如果有则执行(一次)\n\t- 检查是否存在 Microtasks，如果存在则不停地执行，直至清空 Microtasks Queue\n\t- 更新 render\n\t- 主线程重复执行上述步骤\n\n- 任务可分为 （macro）task 和 microtask 两类\n\n\t- 不同的API注册的异步任务会依次进入自身对应的队列中，然后等待 Event Loop 将它们依次压入执行栈中执行。\n\t- (marco)task主要包括\n\n\t\t- script(整体代码)、setTimeout、setInterval、I/O、UI交互事件、setImmediate(Node.js 环境)\n\n\t- microtask主要包含\n\n\t\t- Promise、MutaionObserver、process.nextTick(Node.js 环境)\n\n- 任务源\n\n\t- setTimeout/Promise 等API便是任务源，而进入任务队列的是他们指定的具体执行任务。来自不同任务源的任务会进入到不同的任务队列。其中setTimeout与setInterval是同源的。\n\n- 示例\n\n\t- 代码\n\n\t- 步骤\n\n\t\t- （1）事件循环从宏任务(macrotask)队列开始，这个时候，宏任务队列中，只有一个script(整体代码)任务；当遇到任务源(task source)时，则会先分发任务到对应的任务队列中去。\n\n\t\t- （2）然后遇到了 console 语句，直接输出 script start。输出之后，script 任务继续往下执行，遇到 setTimeout，其作为一个宏任务源，则会先将其任务分发到对应的队列中：\n\n\t\t- （3）script 任务继续往下执行，遇到 Promise 实例。Promise 构造函数中的第一个参数，是在 new 的时候执行，构造函数执行时，里面的参数进入执行栈执行；而后续的 .then 则会被分发到 microtask 的 Promise 队列中去。所以会先输出 promise1，然后执行 resolve，将 then1 分配到对应队列。\n\n构造函数继续往下执行，又碰到 setTimeout，然后将对应的任务分配到对应队列：\n\n\t\t- （4）script任务继续往下执行，最后只有一句输出了 script end，至此，全局任务就执行完毕了。\n\n根据上述，每次执行完一个宏任务之后，会去检查是否存在 Microtasks；如果有，则执行 Microtasks 直至清空 Microtask Queue。\n\n因而在script任务执行完毕之后，开始查找清空微任务队列。此时，微任务中，只有 Promise 队列中的一个任务 then1，因此直接执行就行了，执行结果输出 then1。当所有的 microtast 执行完毕之后，表示第一轮的循环就结束了。\n\n\t\t- （5）这个时候就得开始第二轮的循环。第二轮循环仍然从宏任务 macrotask开始。此时，有两个宏任务：timeout1 和 timeout2。\n\n取出 timeout1 执行，输出 timeout1。此时微任务队列中已经没有可执行的任务了，直接开始第三轮循环：\n\n\t\t- （6）第三轮循环依旧从宏任务队列开始。此时宏任务中只有一个 timeout2，取出直接输出即可。\n\n这个时候宏任务队列与微任务队列中都没有任务了，所以代码就不会再输出其他东西了。那么例子的输出结果就显而易见：\n\n- Promise的特殊情况\n\n\t- 代码\n\n\t- 结果\n\n\t\t- 4321\n\n\t- 为什么 t2 会先执行呢？理由如下：\n\n\t\t- 实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行\n\t\t- Promise.resolve 方法允许调用时不带参数，直接返回一个resolved 状态的 Promise 对象。立即 resolved 的 Promise 对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。\n\n## 生成器\n\n### 打破完整运行\n\n- 一个假定：一个函数一旦开始执行,就会运行到结束,期间不会有其他代码能够打断它并插入其间\n- ES6 引入了一个新的函数类型,它并不符合这种运行到结 束的特性。这类新的函数被称为生成器\n- 生成器就是一类特殊的函数,可以一次或多次启动和停止,并不一定非得要完成\n- 除了能够接受参数并提供返回值之外,生成器甚至提供了更强大更引人注目的内建消息输 入输出能力\n- :每次构建一个 迭代器 ,实际上就隐式构建了生 成器的一个实例,通过这个 迭代器 来控制的是这个生成器实例\n\n### 生成器产生值\n\n- 迭代器 是一个定 义良好的接口, 用于从一个生产者一步步得到一系列值\n- 的一个术语是 iterable (可迭代),即指一个包含可以在迭代器的值上迭代的迭代器的对象\n- iterable 必须支持一个函数,其名称 是专门的 ES6 符号值 Symbol.iterator 。 调用这个函数时, 它会返回一个迭代器\n- 把生成器看作一个值的生产 者,我们通过迭代器接口的 next() 调用一次提取出一个值\n- for..of 循环的“异常结束”(也就是“提前终 止”),通常由 break 、 return 或者未捕获异常引起,会向生成器的迭代器发送一个信号使 其终止\n- 可以在外部通过 return(..) 手工终止生成器的迭代器实例\n\n###  异步迭代生成器\n\n- 异步作为实现细节抽象了出去,使得我们可以以同步顺序的形式追 踪流程控制\n- 不仅能够从异步函数调用得到看似同步的返回值,还 可以同步捕获来自这些异步函数调用的错误\n\n### 生成器 +Promise\n\n- 获得 Promise 和生成器最大效用的最自然的方法就 是 yield 出来一个 Promise, 然后通过这个 Promise 来控制生成器的迭代器\n- await 了一个 Promise, async 函数就会自动获知要做什么,它会暂停这个函数(就 像生成器一样),直到 Promise 决议\n- Promise 所有的并发能力在生成器 +Promise 方法中都可以使用\n- 使用生成器实现异步的方法的全部要点在于创建简单、顺序、看似同步的代码,将异步的 细节尽可能隐藏起来\n\n### 生成器委托\n\n- 从一个生成器调用另一个生成器,使用辅助函数 run()\n- yield 委托 的具体语法是: yield * __(注意多出来的 * )\n- yield 委托的主要目的是代码组织,以达到与普通函数调用的对称\n- 保持生成器分离有助于程序的可读性、可维护性和可调试性\n- yield 委托是如何不只用于迭代器控制工作,也用于双向消息传递工 作的呢\n- 错误和异常也是双向传递的\n-  异步委托\n\n\t- 调用 yield *function()\n\n- 递归委托\n\n\t- 使用 委托实现异步的生成器 递归 ,即一个 yield 委托到它自身的生成器\n\n### 生成器并发\n\n- 两个实例 都是各自的响应一回来就取得了数据, 然后每个实例再次 yield , 用于控制传递的目的\n- runAll(..) 的工具\n\n### 形实转换程序\n\n- JavaScript 中的 thunk 是指一个用于调用另外一个函数的函数,没有任何参数\n- 你用一个函数定义封装函数调用,包括需要的任何参数,来定义这个调用的执 行,那么这个封装函数就是一个形实转换程序之后在执行这个 thunk 时,最终就是调用 了原始的函数\n\n### ES6 之前的生成器\n\n- 手工转换\n\n\t- 生成器是如何 工作的推导练习\n\n- 自动转换\n\n\t- 自动把 ES6 生成器转化为前面小节中我们推导出来的 结果那样的生成器的代码\n\n## 混合对象“类”\n\n### 类理论\n\n- 数据结构：把数据以及和它相关的行为打包\n- 面向对象编程\n\n\t- 实例化\n\t- 继承\n\t- 多态\n\t- 多态\n\n### JavaScript中的 “ 类 ”\n\n-  JavaScript 只有一些近似类的语法元素（语法糖）\n\n### 类的机制\n\n- “类”和“实例”\n\n\t- 建筑蓝图和实际建筑\n\n- 类的继承\n\n\t- 继承通用 的特性并根据自身类别修改某些特性\n\n- 多态\n\n\t- 多态性取决于你是在哪个类的实例中引用它\n\n- 多重继承\n\n### 在继承或者实例化时JavaScript 的对象机制并不会 自动 执行复制行为，它们会被 关联起来\n\n## 继承\n\n### 【继承】JavaScript 各种继承方式优缺点对比\n\n- （1）原型对象\n\n\t- 1.无论什么时候，只要创建一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性指向 prototype 属性所在的函数。\n\n\t- 2.当我们用构造函数创建一个实例时，也会为这个实例创建一个 __proto__ 属性，这个__proto__ 属性是一个指针指向构造函数的原型对象\n\n- （2）重写原型对象\n\n\t- 我们经常用一个包含所有属性和方法的对象字面量来重写整个原型对象\n\t- 如果将 Person.prototype 设置为一个新对象，而这个对象中没有constructor属性，这导致 constructor 属性不再指向 Person，而是指向 Object。\n\n\t- 所以如果 constructor 的值很重要，我们可以像下面这样特意将它设置回设置回适当的值\n\n- （3）原型链及原型链继承\n\n\t- 解释清楚\n\n\t\t- 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针(constructor)，而实例都包含一个指向原型对象的内部指针(__proto__)。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个构造函数的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。\n\n\t- 例子\n\n\t\t- 理解\n\n\t\t\t- 上面的代码中Sub.prototype = new Super();通过创建Super的实例，并将该实例赋值给Sub.prototype来实现继承。此时存在于Super的实例和原型对象中的所有属性和方法，也都存在于Sub.prototype中。instanse的__proto__属性指向Sub的原型对象Sub.prototype，Sub原型对象的__proto__属性又指向Super的原型对象Super.prototype。\n\n\t- 1.原型链搜索机制\n\n\t\t- 当访问一个实例的属性时，首先会在该实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链继承的情况下，搜索过程就得以沿着原型链继续向上查找，直到找到该属性为止，或者搜索到最高级的原型链Object.prototype中，任然没有找到则返回undefined。就拿上面的例子来说，调用instance.getSuperValue()会经历三个搜索步骤：1）搜索实例；2）搜索Sub.prototype;3）搜索Super.prototype，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链的末端才会停下。\n\n\t- 2.原型链继承的缺陷\n\n\t\t- 理解\n\n\t\t\t- 原型链继承最大的问题是来自包含引用类型值的原型。引用类型值的原型属性会被所有实例共享。而这正是为什么要在构造函数中，而不是原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。\n\n\t\t- 例子\n\n\t\t\t- 解释\n\n\t\t\t\t- 上面的代码中，Super 构造函数定义了一个colors 属性，该属性是一个数组。Super 的每个实例都会有各自包含自己数组的colors 属性。当Sub 通过原型链继承了Super之后，Sub.prototype 就变成了Super 的一个实例，因此它也拥有了一个它自己的colors 属性。结果是所有的Sub 实例都会共享这一个colors 属性。\n\n\t\t- 原型链的第二个问题是没有办法在不影响所有对象实例的情况下，给超类的构造函数传递参数。\n\n- （4）构造函数继承（经典继承）\n\n\t- 理解\n\n\t\t- 即在子类构造函数的中调用父类构造函数，此时当构建一个子类实例时，此实例也会拥有父类实例的属性和方法。\n\n\t- 例子\n\n\t\t- 解释\n\n\t\t\t- 上面的代码，当构建Sub的实例时，也会调用Super 的构造函数，这样就会在新Sub对象上执行Super()函数中定义的所有对象初始化代码。结果，Sub 的每个实例就都会具有自己的colors 属性的副本了。\n\n\t- 构造函数继承的缺陷\n\n\t\t- 如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数服用就无从谈起。而且，在超类原型中定义的方法，对子类而已也是不可见的。\n\n- （5）组合继承\n\n\t- 原理\n\n\t\t- 是指将原型链和构造函数的相结合，发挥二者之长的一种继承模式。其思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，即通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。\n\n\t- 例子\n\n\t\t- 解释\n\n\t\t\t- 在上面的例子中，Sup构造函数定义了两个属性：name和colors。Sup的原型定义了一个方法sayName()。Sub构造函数在调用Sup构造函数时传入了name参数，紧接着又定义了它自己的属性age。然后，将Sup的实例赋值给Sub的原型，然后又在该新原型上定义了sayAge()方法。这样就可以让两个不同的Sub 实例即分别拥有自己的属性————包括colors 属性，又可以使用相同的方法了。\n\t\t\t- 组合继承避免了原型链和构造函数的缺陷，融合了它们的优点，是JavaScript中最常用的继承模式。\n\n\t- 美中不足\n\n\t\t- 上面的代码中调用了两次父类构造函数。Sub.prototype = new Super(); 第一次调用父类构造函数时，将Sup父类构造函数的实例赋值给了Sub子类的原型对象Sub.prototype。此时也会将父类构造函数实例上的属性赋值给子类的原型对象Sub.prototype。而第二次是在子类的构造函数中调用父类的构造函数 Super.call(this)，此时会将父类构造函数实例上的属性赋值给子类的构造函数的实例。根据原型链搜索原则，实例上的属性会屏蔽原型链上的属性。因此我们没有必要将父类构造函数实例的属性赋值给子类的原型对象，这是浪费资源而又没有意义的行为。\n\n- （6）优化后的组合继承\n\n\t- 例子一\n\n\t\t- 解释\n\n\t\t\t- 上面的例子通过将父类的原型对象直接赋值给一个中间构造函数的原型对象，然后将这个中间构造函数的实例赋值给子类的原型对象Sub.prototype，从而完成原型链继承。它的高效性体现在只调用了一个父类构造函数Super，并且原型链保持不变。\n\n\t- 例子二\n\n\t\t- 解释\n\n\t\t\t- 还有一种简便的写法是采用ES5的Object.create()方法来替代中间构造函数，其实原理都是一样的\n\n- （7）更简单的继承方式\n\n\t- 简要理解\n\n\t\t- 直接将子类的原型对象(prototype)上的__proto__指向父类的的原型对象(prototype)，这种方式没有改变子类的原型对象，所\b以子类原型对象\b上的constructor属性还是\b指向子类的构造函数，而且当子类的实例在子类的原型对象上没有搜索到\b对应的属性或方法时，它会通过子类原型对象上的__proto__属性，继续在父类的\b原型对象上搜索对应的属性或方法\n\n\t- 例子\n\n- （8）Object.setPrototypeOf()\n\n\t- 理解\n\n\t\t- Object.setPrototypeOf()是ECMAScript 6最新草案中的方法，相对于 Object.prototype.proto ，它被认为是修改对象原型更合适的方法\n\n\t- 例子\n\n- （9）类的静态方法继承\n\n\t- 理解\n\n\t\t- 上面所有的继承方法都没有实现类的静态方法继承，而在ES6的class继承中，子类是可以继承父类的静态方法的。我们可通过Object.setPrototypeOf()来实现类的静态方法继承，非常简单\n\n\t- 例子\n\n### JavaScript8种继承方式\n\n- 继承需要实现两点\n\n\t- 父类实例上的属性和方法\n\t- 父类原型对象上的属性和方法\n\n- 原型链继承\n\n\t- 关键代码\n\n\t\t- p = new Parent('father');\n\t\t- Child.prototype = p;\n\n\t- 优点\n\n\t\t- 可以调用原型链上的方法\n\t\t- 可以获取父类实例的属性\n\t\t- 可以直接修改父类实例属性\n\t\t- 可以通过子类实例修改父类上的引用类型\n\n\t- 缺点\n\n\t\t- 修改父类实例属性，所有原型链上的对象的属性都会被影响\n\t\t- 修改父类实例引用类型，其他对象也会受影响\n\t\t- 调用子类构造函数时，不能像父类构造函数传递参数\n\n- 借用构造函数继承\n\n\t- 关键代码\n\n\t\t- function Child(name) {\n  Parent.call(this, name)\n}\n\n\t- 关键思路\n\n\t\t- 把本来父类构造函数中指向父类实例的this，通过在子类构造函数中call(this)把上下文修改为子类实例。也就是把父类实例的属性复制一份给子类实例\n\n\t- 优点\n\n\t\t- 可以在call()中向父类构造函数传递参数\n\t\t- 可以访问父类实例上的属性，但是是自己的，并不是._proto_指向的。\n\t\t- 修改父类属性不会影响其他子类实例\n\n\t- 缺点\n\n\t\t- 因为没有原型链，所以子类实例实际上是不能访问到父类原型对象上的属性和方法\n\t\t- 每次创建一次实例都会创建一遍构造函数的方法\n\t\t- 方法都在构造函数中定义，因此，函数的复用就无从谈起。\n\n- 组合继承\n\n\t- 关键代码\n\n\t\t- 1.借用构造函数\n\n\t\t\t- function Child1(name) {\n  Father.call(this, name)\n  // 注意，要先 call 父构造函数，再定义子类实例自己的属性\n  // 否则子类实例属性会被父类实例同名属性覆盖\n  this.age = 10\n}\n\n\n\t\t- 2.添加原型链\n\n\t\t\t- \n// 修改原型对象\nChild1.prototype = f\n// 修改原型对象的构造函数\nChild1.prototype.constructor = Child1\n\n\t- 关键思想\n\n\t\t- 复制一份父类实例的属性到子类实例上\n\t\t- 将子类实例添加到原型链上\n\n\t- 优点\n\n\t\t- 可以向父类构造函数传参\n\t\t- 可以通过原型链访问父类属性\n\t\t- 可以修改父类属性而不影响其他子类实例\n\n\t- 缺点\n\n\t\t- 会调用两次父构造函数。\n\t\t- 一个子类实例将会持有两份父类实例的数据。\n\n- 原型式继承\n\n\t- 关键思想\n\n\t\t- 比较原型链继承\n\n\t\t\t- 原型链继承，是先在子类构造函数定义好了实例属性，再new一个父类实例，把子类构造函数的原型指向该实例\n\t\t\t- 原型式继承，已经有了一个父类实例，最后也同样把子类构造函数的原型指向该实例，只不过在中间定义子类构造函数的时候，定义了一个空的函数\n\n\t- 关键代码\n\n\t\t- 通过Object.create()来创建子类实例\n\n\t\t\t- // 为一个对象生成子类实例的函数。其实 Object.create() 就是这样实现的\nfunction object(obj){\n  // 传入的参数 obj 就相当于是父类实例\n  // F 就相当于子类构造函数，不过是空的，啥也没\n  function F(){}\n  // 把子类构造函数的原型对象设置为父类实例\n  F.prototype = obj\n  // 调用子类构造函数，创建一个实例并返回\n  return new F()\n}\n\t\t\t- // 为一个对象生成子类实例的函数。其实 Object.create() 就是这样实现的\nfunction object(obj){\n  // 传入的参数 obj 就相当于是父类实例\n  // F 就相当于子类构造函数，不过是空的，啥也没\n  function F(){}\n  // 把子类构造函数的原型对象设置为父类实例\n  F.prototype = obj\n  // 调用子类构造函数，创建一个实例并返回\n  return new F()\n}\n\n\t- 缺点\n\n\t\t- 子类修改引用类型，父类的引用属性也会改变\n\n\t- 优点\n\n\t\t- 与原型链继承最大的区别就是在定义子类构造函数的时候定义了一个空函数\n\t\t- 在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的。\n\n- 混入式继承mixin\n\n\t- 说白了就是把一个对象的属性复制到另一个对象上去。\n\t- 通过混入的方式为子类实例添加父类原型对象的属性\n\n\t\t- // 创建一个没有实例属性的 Mother 的实例\nm = Object.create(Mother.prototype)\n// 修改 Me 的原型对象，现在 Me 位于 Mother 实例的原型链上了\nMe.prototype = m\n// 修改构造函数\nMe.prototype.constructor = Me\n// 再把 Father 原型对象上的属性方法复制到 Me 的原型对象 m 上\n// 现在，虽然 Me 的实例并不在 Father 实例的原型链上\n// 但是也可以访问 Father.prototype 上的属性方法\nObject.assign(Me.prototype, Father.prototype)\n\nme = new Me()\nconsole.log(me)\n\n- ES6 extends\n\n\t- 实现思路和寄生组合继承是一样的\n\n- 寄生组合式继承\n\n\t- 关键思路\n\n\t\t- 利用Object.create()的“使用现有的对象来提供新建对象的_proto_”特性，来消除组合式继承的子类具有两份父类属性的缺点\n\t\t- 这两份数据中，通过 Father.call(this) 复制到子类实例 c 上的这一份是真正需要的，而 c.__proto__ 上的这一份是多余的，是把子类实例放到原型链上时产生的副作用。\n\t\t- 让子类实例在原型链上，但是不能让父类实例的属性位于原型链上\n\n\t- 关键代码\n\n\t\t- function Parent(name) {\n  this.name = name\n  this.age = 40\n  this.relation = ['grandma', 'grandpa']\n}\nParent.prototype.say = function () {\n  console.log(this.name)\n}\nfunction Child(name) {\n  Parent.call(this, name)\n}\n\n// 开始实现继承\n// Object.create 创建没有实例属性的父类实例\np = Object.create(Parent.prototype)\n// 修改子类构造函数原型对象\nChild.prototype = p\n// 这里的 p 只是个普通对象，没有 constructor 属性，手动添加一下\np.constructor = Child\n\n- 寄生式继承\n\n\t- 关键思路\n\n\t\t- 在原型式继承生成子类实例后，在返回之前处理了子类实例，增加了一些属性或方法\n\n\t- 代码\n\n\t\t- 关键代码\n\n\t\t\t- function createAnother(original){\n  // 使用前面的 object 函数，生成了一个子类实例\n  var clone = object(original)\n  // 先在子类实例上添加一点属性或方法\n  clone.sayHi = function(){\n    console.log(\"hi\")\n  }\n  // 再返回\n  return clone\n}\n\n### 行为委托（原型继承）\n\n- 面向委托（原型）的设计\n\n\t- JavaScript中这个机制（原型继承）的本质就是 对象之间的关联关系 。\n\t- 关联风格\n\n\t\t- 委托中最好把状态保存在委托者（原型）上\n\t\t- 避免在原型链的不同级别中使用相同的命名\n\t\t- 静止相互委托\n\n- 类与对象\n\n\t- 传统的类与对象的开发，需要在父类中定义基础方，然后在子类中重写（丑陋的伪多态）\n\t- 委托控件，在对象之间建立关联，定义不同的具有描述性的方法名\n\n- 提升\n\n\t- 更简洁的设计\n\n\t- 内省\n\n\t\t- 自省就是检查实例的类型\n\n*XMind: ZEN - Trial Version*",sa={data:function(){return{MainComponent:ra}}},oa=sa,la=Object(v["a"])(oa,ea,aa,!1,null,"64fae3ff",null),ia=la.exports,ca=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{},[e("q-markdown",{attrs:{src:t.MainComponent}})],1)},pa=[],ba="# es6\n\n## let 和 const 命令\n\n### let 命令\n\n- 声明的变量，只在let命令所在的代码块内有效\n- for循环的计数器，就很合适使用let命令\n- let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错\n- 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响\n- 如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域\n- “暂时性死区”也意味着typeof不再是一个百分之百安全的操作\n- let不允许在相同作用域内，重复声明同一个变量\n- ES6 引入了块级作用域，明确允许在块级作用域之中声明函数\n\n### const 命令\n\n- const声明一个只读的常量。一旦声明，常量的值就不能改变\n- const一旦声明变量，就必须立即初始化，不能留到以后赋值\n- const的作用域与let命令相同：只在声明所在的块级作用域内有效\n- const命令声明的常量也是不提升，同样存在暂时性死区\n- const声明的常量，也与let一样不可重复声明\n- const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。\n- ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令\n后面章节还会提到，另外两种声明变量的方法：import命令和class命令\n\n### 顶级对象属性\n\n- var命令和function命令声明的全局变量，依旧是顶层对象的属性；\n- 另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性\n\n## 变量的解构赋值\n\n### 数组的解构赋值\n\n- ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构\n- 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值\n- 如果解构不成功，变量的值就等于undefined\n- 不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组\n- 对于 Set 结构，也可以使用数组的解构赋值\n- 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值\n- 解构赋值允许指定默认值\n\n\t- 只有当一个数组成员严格等于undefined，默认值才会生效\n\n- 默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值\n\n### 对象的解构赋值\n\n- 对象的属性没有次序，变量必须与属性同名，才能取到正确的值\n- 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量\n- 与数组一样，解构也可以用于嵌套结构的对象\n- 对象的解构也可以指定默认值\n\n\t- 默认值生效的条件是，对象的属性值严格等于undefined\n\n- 如果解构失败，变量的值等于undefined\n- 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错\n- 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构\n\n### 字符串的解构赋值\n\n- 字符串被转换成了一个类似数组的对象\n- 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值\n\n### 数值和布尔值的解构赋值\n\n- 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象\n- 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象\n- 由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错\n\n### 函数参数的解构赋值\n\n- undefined就会触发函数参数的默认值\n\n### 圆括号问题\n\n- ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号\n- 建议只要有可能，就不要在模式中放置圆括号\n- 可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。\n\n### 用途\n\n- 交换变量的值\n- 从函数返回多个值\n- 函数参数的定义\n- 提取 JSON 数据\n- 函数参数的默认值\n- 遍历 Map 结构\n- 输入模块的指定方法\n\n### 变量的结构赋值\n\n- 数组\n\n\t- 解析不成功值就是undefined\n\t- 不完全结构，结构依然可以成功\n\t- 不是可遍历结构报错\n\t- 允许指定默认值、===判断undefined时赋值\n\t- 按次序\n\n- 对象\n\n\t- 变量名必须与属性名同名\n\t- 解构失败时为undefined\n\t- 解构赋值可以取到继承的属性\n\t- 结构模式时嵌套的对象，子对象所在的父属性不存在，那么将会报错\n\t- 对象也可以指定默认值\n\t- 以申明的变量用于解构赋值要加圆括号\n\t- 数组时特殊的对象，因此可以对数组进行对象的属性的解构\n\n- 字符串\n\n\t- 字符串被转换成一个类似的数组对象\n\t- 有length属性，可以对这个属性赋值\n\n- 数值和布尔值\n\n\t- 如果等号右边是数值和布尔值，则会先转为对象\n\n\t\t- let {toString: s} = 123;\ns === Number.prototype.toString // true\n\t\t- let {toString: s} = true;\ns === Boolean.prototype.toString // true\n\n\t- 由于undefined和null无法转为对象，所以对它们进行解构赋值会报错\n\n- 函数参数\n- 圆括号\n\n\t- 不适用\n\n\t\t- 变量声明语句\n\t\t- 函数参数\n\t\t- 赋值语句的模式\n\n\t- 适用\n\n\t\t- 赋值语句的非模式部分\n\n- 用途\n\n\t- 交换变量的值\n\t- 从函数返回多个值\n\t- 函数参数的定义\n\t- 提取JSON数据\n\t- 函数参数的默认值\n\t- 遍历Map结构\n\n\t\t- let [key,value] of map\n\n\t- 输入模块的指定方法\n\n## 字符串的扩展\n\n### 字符的 Unicode 表示法\n\n- JavaScript 允许采用\\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点\n- ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符\n\n### codePointAt()\n\n- JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节\n- 对于这种4个字节的字符，charAt方法无法读取整个字符，charCodeAt方法只能分别返回前两个字节和后两个字节的值\n- ES6 提供了codePointAt方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。\n- 对于那些两个字节储存的常规字符，它的返回结果与charCodeAt方法相同\n- codePointAt方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString方法转换一下\n\n### String.fromCodePoint()\n\n- ES5 提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字符\n- ES6 提供了String.fromCodePoint方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode方法的不足\n- 如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回\n\n### 字符串的遍历器接口\n\n- ES6 为字符串添加了遍历器接口，使得字符串可以被for...of循环遍历\n- 这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点\n\n### at()\n\n- ES5 对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符\n- 有一个提案，提出字符串实例的at方法，可以识别 Unicode 编号大于0xFFFF的字符，返回正确的字符\n\n### normalize()\n\n- ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化\n\n### includes(), startsWith(), endsWith()\n\n- JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中\n- includes()：返回布尔值，表示是否找到了参数字符串\n- startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部\n- endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部\n\n### repeat()\n\n- repeat方法返回一个新字符串，表示将原字符串重复n次\n- 参数如果是小数，会被取整\n- 如果repeat的参数是负数或者Infinity，会报错\n- 如果参数是 0 到-1 之间的小数\n\n### padStart()，padEnd()\n\n- 如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全\n- padStart和padEnd一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串\n- 如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串\n- 如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串\n- 如果省略第二个参数，默认使用空格补全长度\n\n### matchAll()\n\n- matchAll方法返回一个正则表达式在当前字符串的所有匹配\n\n### 模板字符串\n\n- 模板字符串（template string）是增强版的字符串，用反引号（`）标识\n- 如果在模板字符串中需要使用反引号，则前面要用反斜杠转义\n- 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中\n- 模板字符串中嵌入变量，需要将变量名写在${}之中\n- 模板字符串之中还能调用函数\n- 模板字符串甚至还能嵌套。\n\n### 实例：模板编译\n\n- 该模板使用<%...%>放置 JavaScript 代码，使用<%= ... %>输出 JavaScript 表达式\n\n### 标签模板\n\n- “标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容\n\n### String.raw()\n\n- String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）\n的字符串，对应于替换变量后的模板字符串\n\n### 模板字符串的限制\n\n- 模板字符串默认会将字符串转义，导致无法嵌入其他语言\n\n## 正则的扩展\n\n### RegExp 构造函数\n\n- 第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符\n- 第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝\n- ES5 不允许此时使用第二个参数添加修饰符，否则会报错\n- ES6 改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符\n\n### 字符串的正则方法\n\n- 字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()\n\n### u 修饰符\n\n- ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\\uFFFF的 Unicode 字符\n- 点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符\n- 对于码点大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符\n- ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词\n- 使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的 Unicode 字符\n- u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的 Unicode 字符\n\n### RegExp.prototype.unicode 属性\n\n- 正则实例对象新增unicode属性，表示是否设置了u修饰符\n\n### y 修饰符\n\n- ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符\n\n### RegExp.prototype.sticky 属性\n\n- 与y修饰符相匹配，ES6 的正则实例对象多了sticky属性，表示是否设置了y修饰符\n\n### RegExp.prototype.flags 属性\n\n- ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符\n\n### s 修饰符：dotAll 模式\n\n- 正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外\n- 一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符\n- 这被称为dotAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式\n\n### 后行断言\n\n- ”先行断言“指的是，x只有在y前面才匹配，必须写成/x(?=y)/\n- “后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成/(?<=y)x/\n\n### Unicode 属性类\n\n- ES2018 引入了一种新的类的写法\\p{...}和\\P{...}，允许正则表达式匹配符合 Unicode 某种属性的所有字符\n\n### 具名组匹配\n\n- 正则表达式使用圆括号进行组匹配\n- 有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值\n- 如果要在正则表达式内部引用某个“具名组匹配”，可以使用\\k<组名>的写法\n\n### String.prototype.matchAll\n\n- 如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出\n\n## 数值的扩展\n\n### 二进制和八进制表示法\n\n- ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示\n\n### Number.isFinite(), Number.isNaN()\n\n- Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity\n- Number.isNaN()用来检查一个值是否为NaN，如果参数类型不是NaN，Number.isNaN一律返回false\n- 传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效\n- Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false\n\n### Number.parseInt(), Number.parseFloat()\n\n- ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变\n\n### Number.isInteger()\n\n- Number.isInteger()用来判断一个数值是否为整数\n- JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值\n\n### Number.EPSILON\n\n- ES6 在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差\n- Number.EPSILON实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了\n\n### 安全整数和 Number.isSafeInteger()\n\n- JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值\n- Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内\n\n### Math 对象的扩展\n\n- ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用\n- Math.trunc方法用于去除一个数的小数部分，返回整数部分\n- Math.sign方法用来判断一个数到底是正数、负数、还是零\n- Math.cbrt方法用于计算一个数的立方根\n- JavaScript 的整数使用 32 位二进制形式表示，Math.clz32方法返回一个数的 32 位无符号整数形式有多少个前导 0\n- Math.imul方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数\n- Math.fround方法返回一个数的32位单精度浮点数形式\n- Math.hypot方法返回所有参数的平方和的平方根\n- Math.expm1(x)返回 ex - 1，即Math.exp(x) - 1\n- Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN\n- Math.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN\n- Math.log2(x)返回以 2 为底的x的对数。如果x小于 0，则返回 NaN\n- Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）\n- Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）\n- Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）\n- Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）\n- Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）\n- Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）\n\n### 指数运算符\n\n- ES2016 新增了一个指数运算符（**）\n- 指数运算符可以与等号结合，形成一个新的赋值运算符（**=）\n\n## 函数的扩展\n\n### 函数参数的默认值\n\n- ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面\n- 参数变量是默认声明的，所以不能用let或const再次声明。\n- 使用参数默认值时，函数不能有同名参数\n- 参数默认值是惰性求值的\n- 参数默认值可以与解构赋值的默认值，结合起来使用\n- 默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined\n- 如果传入undefined，将触发该参数等于默认值，null则没有这个效果\n- 指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数\n- 指定了默认值后，length属性将失真\n- 利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误\n\n### rest 参数\n\n- ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了\n- rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用\n\n### 严格模式\n\n- ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，\n那么函数内部就不能显式设定为严格模式，否则会报错\n- 设定全局性的严格模式，这是合法的\n- 函数包在一个无参数的立即执行函数里面\n\n### name 属性\n\n- 函数的name属性，返回该函数的函数名。\n- 如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名\n- 如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的name属性都返回这个具名函数原本的名字\n- Function构造函数返回的函数实例，name属性的值为anonymous\n- bind返回的函数，name属性值会加上bound前缀\n\n### 箭头函数\n\n- ES6 允许使用“箭头”（=>）定义函数\n- 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分\n- 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回\n- （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。\n- （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。\n- （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。\n- （4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数\n- 箭头函数内部，还可以再使用箭头函数\n\n### 双冒号运算符\n\n- 现在有一个提案，提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用\n- 函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数\n- 该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面\n- 如果双冒号运算符的运算结果，还是一个对象，就可以采用链式写法\n\n### 尾调用优化\n\n- 尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数\n- 尾调用不一定出现在函数尾部，只要是最后一步操作即可\n- 如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存\n- 函数调用自身，称为递归。如果尾调用自身，就称为尾递归\n\n### 函数参数的尾逗号\n\n- ES2017 允许函数的最后一个参数有尾逗号（trailing comma）\n\n## 数组的扩展\n\n### 扩展运算符\n\n- 扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列\n- 由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了\n- 数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组\n- 扩展运算符提供了数组合并的新写法。\n- 扩展运算符可以与解构赋值结合起来，用于生成数组\n- 扩展运算符还可以将字符串转为真正的数组。\n- 任何 Iterator 接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组\n- Map 和 Set 结构，Generator 函数\n\n### Array.from()\n\n- Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map\n- Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组\n\n### Array.of()\n\n- Array.of方法用于将一组值，转换为数组\n- 这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异\n- Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载\n\n### 数组实例的 copyWithin()\n\n- 数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组\n\n### 数组实例的 find() 和 findIndex()\n\n- 数组实例的find方法，用于找出第一个符合条件的数组成员\n- 它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员\n- 如果没有符合条件的成员，则返回undefined\n- 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1\n- 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象\n\n### 数组实例的 fill()\n\n- fill方法使用给定值，填充一个数组。\n- 如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象\n\n### 数组实例的 entries()，keys() 和 values()\n\n- ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组\n- 它们都返回一个遍历器对象，可以用for...of循环进行遍历\n- 如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历\n\n### 数组实例的 includes()\n\n- Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似\n- Map 和 Set 数据结构有一个has方法，需要注意与includes区分\n\n### 数组的空位\n\n- 数组的空位指，数组的某一个位置没有任何值\n- Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位\n- 扩展运算符（...）也会将空位转为undefined\n- copyWithin()会连空位一起拷贝\n- fill()会将空位视为正常的数组位置\n- for...of循环也会遍历空位\n- entries()、keys()、values()、find()和findIndex()会将空位处理成undefined\n\n## 对象的扩展\n\n### 属性的简洁表示法\n\n- ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。\n\n### 属性名表达式\n\n- JavaScript 定义对象的属性，有两种方法\n- 方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内\n- 注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]\n\n### 方法的 name 属性\n\n- 函数的name属性，返回函数名。对象方法也是函数，因此也有name属性\n- 如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，\n而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set\n- bind方法创造的函数，name属性返回bound加上原函数的名字；\n- Function构造函数创造的函数，name属性返回anonymous\n- 如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述\n\n### Object.is()\n\n- 用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致\n- 不同之处只有两个：一是+0不等于-0，二是NaN等于自身\n\n### Object.assign()\n\n- Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）\n- 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性\n- 如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过\n- 这意味着，如果undefined和null不在首参数，就不会报错\n- Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）\n- Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用\n- 遇到同名属性，Object.assign的处理方法是替换，而不是添加\n- Object.assign可以用来处理数组，但是会把数组视为对象\n- Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制\n- 为对象添加属性\n- 为对象添加方法\n- 克隆对象\n- 合并多个对象\n- 为属性指定默认值\n\n### 属性的可枚举性和遍历\n\n- 对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为\n- Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象\n- for...in循环：只遍历对象自身的和继承的可枚举的属性。\n- Object.keys()：返回对象自身的所有可枚举的属性的键名。\n- JSON.stringify()：只串行化对象自身的可枚举的属性。\n- Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性\n- 引入“可枚举”（enumerable）这个概念的最初目的，就是让某些属性可以规避掉for...in操作，不然所有内部属性和方法都会被遍历到\n- 属性的遍历\n\n\t- for...in\n\t- Object.keys(obj)\n\t- Object.getOwnPropertyNames(obj)\n\t- Object.getOwnPropertySymbols(obj)\n\t- Reflect.ownKeys(obj)\n\t- 首先遍历所有数值键，按照数值升序排列。\n\t- 其次遍历所有字符串键，按照加入时间升序排列。\n\t- 最后遍历所有 Symbol 键，按照加入时间升序排列。\n\n### Object.getOwnPropertyDescriptors()\n\n- ES2017 引入了Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象\n- 该方法的引入目的，主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题\n\n### __proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()\n\n- ES6 规定__proto__只有浏览器要部署，其他环境不用部署\n- __proto__属性（前后各两个下划线），用来读取或设置当前对象的prototype对象\n- Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的prototype对象，返回参数对象本身\n- 该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象\n\n### super 关键字\n\n- ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象\n- super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错\n\n### Object.keys()，Object.values()，Object.entries()\n\n- ES5 引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名\n- ES2017 引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for...of循环使用\n- Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值\n- 返回数组的成员顺序\n- Object.values会过滤属性名为 Symbol 值的属性\n- Object.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组\n\n### 对象的扩展运算符\n\n- 运算符（...）ES2018 将这个运算符引入了对象\n- 对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面\n- 由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象\n- 解构赋值必须是最后一个参数，否则会报错\n\n## Symbol\n\n### 概述\n\n- ES5 的对象属性名都是字符串，这容易造成属性名的冲突\n- Symbol的引入，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突\n- 它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）\n- Symbol函数前不能使用new命令，否则会报错\n- Symbol 值不是对象，所以不能添加属性\n- Symbol 值不能与其他类型的值进行运算，会报错\n- Symbol 值可以显式转为字符串\n- Symbol 值也可以转为布尔值，但是不能转为数值\n\n### 作为属性名的 Symbol\n\n- 由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性\n- Symbol 值作为对象属性名时，不能用点运算符\n\n### 实例：消除魔术字符串\n\n- 魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值\n- 常用的消除魔术字符串的方法，就是把它写成一个变量。\n\n### 属性名的遍历\n\n- Symbol 作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回\n- 有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名\n- Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和 Symbol 键名\n\n### Symbol.for()，Symbol.keyFor()\n\n- 我们希望重新使用同一个 Symbol 值，Symbol.for方法可以做到这一点\n- 它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值\n- 如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值\n- Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值\n- Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key\n\n### 实例：模块的 Singleton 模式\n\n- Singleton 模式指的是调用一个类，任何时候返回的都是同一个实例\n- 如果键名使用Symbol方法生成，那么外部将无法引用这个值，当然也就无法改写。\n\n### 内置的 Symbol 值\n\n- 除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法\n- 对象的Symbol.hasInstance属性，指向一个内部方法\n- 对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开\n- 对象的Symbol.species属性，指向一个构造函数。创建衍生对象时，会使用该属性\n- 对象的Symbol.match属性，指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值\n- 对象的Symbol.replace属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值\n- 对象的Symbol.search属性，指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值\n- 对象的Symbol.split属性，指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值\n- 对象的Symbol.iterator属性，指向该对象的默认遍历器方法。\n- 对象的Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值\n- 对象的Symbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，\n如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型\n- 对象的Symbol.unscopables属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除\n\n## Set 和 Map 数据结构\n\n### Set\n\n- ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值\n- 上面代码向 Set 实例添加了两个NaN，但是只能加入一个。这表明，在 Set 内部，两个NaN是相等\n- Set.prototype.constructor：构造函数，默认就是Set函数。\n- Set.prototype.size：返回Set实例的成员总数\n- add(value)：添加某个值，返回 Set 结构本身。\n- delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。\n- has(value)：返回一个布尔值，表示该值是否为Set的成员。\n- clear()：清除所有成员，没有返回值。\n- keys()：返回键名的遍历器\n- values()：返回键值的遍历器\n- entries()：返回键值对的遍历器\n- forEach()：使用回调函数遍历每个成员\n\n### WeakSet\n\n- WeakSet 结构与 Set 类似，也是不重复的值的集合\n- WeakSet 的成员只能是对象，而不能是其他类型的值\n- WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中\n- WeakSet 是一个构造函数，可以使用new命令，创建 WeakSet 数据结构\n- WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。\n- WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。\n- WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。\n- WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了\n\n### Map\n\n- 它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键\n- 事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数\n- size属性返回 Map 结构的成员总数。\n- set方法设置键名key对应的键值为value，然后返回整个 Map 结构。\n- get方法读取key对应的键值，如果找不到key，返回undefined\n- has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中\n- delete方法删除某个键，返回true。如果删除失败，返回false\n- clear方法清除所有成员，没有返回值\n- keys()：返回键名的遍历器。\n- values()：返回键值的遍历器。\n- entries()：返回所有成员的遍历器。\n- forEach()：遍历 Map 的所有成员。\n\n### WeakMap\n\n- WeakMap结构与Map结构类似，也是用于生成键值对的集合。\n- WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名\n- WeakMap的键名所指向的对象，不计入垃圾回收机制\n- WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有keys()、values()和entries()方法），也没有size属性\n- WeakMap只有四个方法可用：get()、set()、has()、delete()\n\n## Proxy\n\n### 概述\n\n- Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程\n- ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例\n\n### Proxy 实例的方法\n\n- get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy['foo']。\n- set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。\n- has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。\n- deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。\n- ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。\n- getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。\n- defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。\n- preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。\n- getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。\n- isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。\n- setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。\n- apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。\n- construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。\n\n### Proxy.revocable()\n\n- Proxy.revocable方法返回一个可取消的 Proxy 实例。\n\n### this 问题\n\n- 虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致\n\n### 实例：Web 服务的客户端\n\n- Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端\n\n## Reflect\n\n### 概述\n\n- Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API\n-  将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上\n- 修改某些Object方法的返回结果，让其变得更合理\n- 让Object操作都变成函数行为\n- Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法\n\n### 静态方法\n\n- Reflect.apply(target, thisArg, args)\n- Reflect.construct(target, args)\n- Reflect.get(target, name, receiver)\n- Reflect.set(target, name, value, receiver)\n- Reflect.defineProperty(target, name, desc)\n- Reflect.deleteProperty(target, name)\n- Reflect.has(target, name)\n- Reflect.ownKeys(target)\n- Reflect.isExtensible(target)\n- Reflect.preventExtensions(target)\n- Reflect.getOwnPropertyDescriptor(target, name)\n- Reflect.getPrototypeOf(target)\n- Reflect.setPrototypeOf(target, prototype)\n\n### 实例：使用 Proxy 实现观察者模式\n\n- 观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行\n\n## Promise\n\n### Promise 的含义\n\n- Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大\n- 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）\n- 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected\n\n### 基本用法\n\n- ES6 规定，Promise对象是一个构造函数，用来生成Promise实例\n\n### Promise.prototype.then()\n\n- Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的\n- 可以采用链式写法，即then方法后面再调用另一个then方法\n\n### Promise.prototype.catch()\n\n- Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数\n- Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止\n\n### Promise.prototype.finally()\n\n- finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作\n\n### Promise.all()\n\n- Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例\n- （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。\n- （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。\n\n### Promise.race()\n\n- Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例\n- 只要其中之中有一个实例率先改变状态，状态就跟着改变\n\n### Promise.resolve()\n\n- 有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用\n- 参数是一个 Promise 实例\n- 参数是一个thenable对象\n- 参数不是具有then方法的对象，或根本就不是对象\n- 不带有任何参数\n\n### Promise.reject()\n\n- Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected\n\n### 应用\n\n- 我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。\n- 使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。\n\n### Promise.try()\n\n- Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码\n\n## Iterator 和 for...of 循环\n\n### Iterator（遍历器）的概念\n\n- 一种统一的接口机制，来处理所有不同的数据结构\n- 为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作\n- 一是为各种数据结构，提供一个统一的、简便的访问接口；\n- 二是使得数据结构的成员能够按某种次序排列；\n- 三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费\n\n### 默认 Iterator 接口\n\n- Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for...of循环\n- 一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”\n\n### 调用 Iterator 接口的场合\n\n- 有一些场合会默认调用 Iterator 接口（即Symbol.iterator方法），除了下文会介绍的for...of循环，还有几个别的场合\n- 对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法。\n- 扩展运算符（...）也会调用默认的 Iterator 接口。\n- yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口\n- for...of\n- Array.from()\n- Map(), Set(), WeakMap(), WeakSet()（比如new Map([['a',1],['b',2]])）\n- Promise.all()\n- Promise.race()\n\n### 字符串的 Iterator 接口\n\n- 字符串是一个类似数组的对象，也原生具有 Iterator 接口。\n\n### Iterator 接口与 Generator 函数\n\n- Symbol.iterator方法的最简单实现，还是使用下一章要介绍的 Generator 函数\n\n### 遍历器对象的 return()，throw()\n\n- 遍历器对象除了具有next方法，还可以具有return方法和throw方法\n- return方法的使用场合是，如果for...of循环提前退出\n- throw方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法\n\n### for...of 循环\n\n- 一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for...of循环遍历它的成员\n- for...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串\n\n## async 函数\n\n### 含义\n\n- async 函数是什么？一句话，它就是 Generator 函数的语法糖\n- 一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已\n- Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器\n- async和await，比起星号和yield，语义更清楚了\n- co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值\n- async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了\n\n### 基本用法\n\n- async函数返回一个 Promise 对象，可以使用then方法添加回调函数\n- 由于async函数返回的是 Promise 对象，可以作为await命令的参数\n\n### 语法\n\n- async函数的语法规则总体上比较简单，难点是错误处理机制。\n- async函数返回一个 Promise 对象。\n- async函数内部return语句返回的值，会成为then方法回调函数的参数\n- async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误\n- 正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象\n- 如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject\n- 如果有多个await命令，可以统一放在try...catch结构中\n\n### async 函数的实现原理\n\n- async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里\n\n## es6函数\n\n### 函数参数的默认值\n\n- 判断函数是否赋值是是否全等于undefined\n- 简洁，利于阅读，未来代码优化\n- 函数体里不能用let或const再次声明\n- 参数不能有同名参数\n- 不是传值，而是每次都重新计算默认值表达式的值\n- 应该是尾参数，非尾参数设置默认值，是没法省略的，除非显示指定undefined\n- 函数length属性会失真，rest和默认值参数，以及默认值之后的参数都将不被计算\n- 参数形成一个单独的作用域，不设置默认值是不出现。初始化结束后，作用域消失\n\n### rest参数（...变量名）\n\n- 是一个真实的参数\n- rest参数之后不能再有其他参数，否则报错\n- 函数的length属性不包括rest参数\n\n### 严格模式\n\n- 使用默认值，解构赋值、扩展运算符的函数内部都不能显示设定为严格模式否则会报错\n- 因为先执行函数参数再执行函数体，但是在函数体内才知道是否应该以严格模式执行\n- 解决办法\n\n\t- 全局使用严格模式\n\t- 将函数包含在严格模式的无参数立即执行函数里面\n\n### name属性\n\n- (new Function).name // \"anonymous\"\n- bind返回的函数，name属性值会加上bound前缀。\n\n### 箭头函数\n\n- 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象\n- 不可以当作构造函数，不可以使用new命令，否则会抛出一个错误\n- 不可以使用arguments对象，该对象在函数体内不存在，如果要用可以使用rest参数代替\n- 不可以使用yield命令，因此箭头函数不能用作Generator函数\n- this在箭头函数中是固定的，并不是因为内部有绑定this的机制，实际原因是箭头函数根本没有自己的this\n- arguments、super、new.target也不存在箭头函数之中\n- 不能用call、apply、bind去改变this 的指向\n- 不适用在对象属性中使用箭头函数的this因为对象不构成单独的作用域\n- 不适用需要动态this的时候\n\n### 尾调用优化\n\n- 最后一步是调用另一个函数，另个函数不能用到这个函数的变量\n- 函数调用会在内存形成一个调用帧，保存调用位置和内部变量等信息，尾调用不需要保留外层函数的调用帧，取代外层函数调用帧，大大节省内存\n- 尾调用优化只在严格模式下开启，正常模式下无效\n- 因为正常模式下有这两个变量，可以跟踪函数的调用栈。\n\n\t- arguments\n\t- caller\n\n- 正常模式下可以使用蹦床函数实现优化\n\n### Function.prototype.toString()返回代码本身，明确要求返回一模一样的原始代码\n\n### catch命令的参数可以省略\n\n### es2017允许函数最后一个参数有逗号\n\n## Event Loop\n\n### 执行栈\n\n- JavaScript执行时，同步任务会排好队，在主程序上按照顺序执行，排队的地方叫做执行栈\n\n### 任务队列\n\n- JavaScript对异步任务不会停下来等待，而是将其挂起，继续执行执行栈中的同步任务，当异步任务有返回结果（通常是回调函数）时，异步任务会加入与执行栈不一样的队列，即任务队列\n- 微任务\n\n\t- promise.then\n\t- process.nextTick\n\n- 宏任务\n\n\t- script（整体代码）\n\t- setTimeout\n\t- setInterval\n\t- setImmediate\n\t- promise中的executor\n\n### Event执行顺序\n\n- 1.主程序\n- 2.微任务\n- 3.宏任务\n\n### async/await\n\n- 仅仅影响函数内的执行\n- await的下一个语句相当与执行promise.then\n\n### promise.then\n\n- 链式调用会被EventLoop中的其他事件插队\n- 分别调用不会，会将then中的回调函数push到一个数组后批量执行\n\n## Promise\n\n### Promise\n\n- 什么是Promise\n\n\t- Promise 的决议结果可能是拒绝而不是完成\n\t- Promise 封装了依赖于时间的状态——等待底层值的完成或拒绝\n\n- 具有 then 方法的鸭子类型\n\n\t- 在 Promise 系统中就会被误认为是一个 thenable, 这可能会导 致非常难以追踪的 bug\n\t- 这种 类型检查 (type check)一般用术语 鸭子类型 (duck typing)来表示\n\t- 对象上有 then(..) 函数，或则他的原型上有 then()函数\n\n- Promise 信任问题\n\n\t- 对一个 Promise 调用 then(..) 的时候, 即使这个 Promise 已经决议, 提供给 then(..) 的回调也总会被异步调用\n\t- 一个 Promise 决议后, 这个 Promise 上所有的通过 then(..) 注册的回调都会在下一个异步时机点上依次被立即调用\n\t-  两个独立Promise 上链接的回调的相对顺序无法可靠预测\n\t- 如果 Promise 本身永远不被决议呢，Promise 提供了一个方案：有一个输出信号,防止其永久挂住程序\n\t- Promise 的定义方式使得它只能被决议一次\n\t- Promise 至多只能有一个决议值(完成或拒绝)\n\t- 如果使用多个参数调用 resovle(..) 或者 reject(..) ,第一个参数之 后的所有参数都会被默默忽略\n\t- 如果拒绝一个 Promise 并给出一个理由，这个值就会被传给拒绝回调\n\t- 如果在 Promise 的创建过程中或在查看其决议 结果过程中的任何时间点上出现了一个 JavaScript 异常错误\n\t- 如果向 Promise.resolve(..) 传递一个非 Promise、非 thenable 的立即值,就会得到一个用 这个值填充的 promise\n\t- Promise这种模式通过可信任的语义把回调作为参数传递，把控制权放在了一个可信任的系统\n\n- 链式流\n\n\t- 我们可以把多个 Promise 连接到一起以表示一系列异步 步骤\n\t- Promise 规范化了异步, 并封装了时间相关值的状态,使得我们能够把它们以这种有用的方式链接到一起\n\t- 调用Promise的then(..)会自动创建一个新的 Promise 从调用返回\n\t- 在完成或拒绝处理函数内部,如果返回一个值或抛出一个异常,新返回的(可链接的)\n\nPromise 就相应地决议\n\t- 如果完成或拒绝处理函数返回一个 值是什么,都会成为当前 then(..)\n\nPromise, 它将会被展开,这样一来,不管它的决议 返回的链接 Promise 的决议值\n\t- 术语 决议 (resolve)、 完成 (fulfill)和 拒绝 (reject),\n\n- 错误处理\n\n\t- try..catch 当然很好, 但是无法跨异步操作工作\n\t- 模式化的错误处理方式，error-first 回调 风格\n\t-  Promise 没有采用 流行的 error-first 回调设计风格,而是使用了分离回调(split-callback)风格。\n\t- Promise 错误处理就是一个“绝望的陷阱”设计，它假定你想要 Promise 状态吞掉所有的错误\n\t- 浏览器在它被垃圾回收的时候 其中有拒绝,浏览器就能够确保这是一个真正的未捕获错误,进而可以确定应该将其报告 到开发者终端\n\t- 如果一个 Promise 被拒绝的话,默认情况下会向开发者终端报告这个事实\n\t- 需要等待一段时间才能使用或查看它的拒绝结果, 调用 defer() , 这样就不会有全局报告出现\n\n- Promise 模式\n\n\t- 并行执行   Promise.all([ .. ])\n\t- 如果这些 promise 中有任何一个被拒绝的话,主 Promise.all([ .. ]) promise 就会立 即被拒绝,并丢弃来自其他所有 promise 的全部结果\n\t- “第一个跨过终点线的 Promise” ,而抛弃其他 Promise\n\t- 一旦有任何一个 Promise 决议为完成, 就会完成;一旦有任何一个 Promise 决议为拒绝,它就会拒绝。\n\t- none([ .. ]) 这个模式类似于 all([ .. ]) ,不过完成和拒绝的情况互换了。所有的 拒绝,即拒绝转化为完成值,反之亦然。\n\t- any([ .. ]) Promise 都要被 这个模式与 all([ .. ]) 类似,但是会忽略拒绝,所以只需要完成一个而不是全部\n\t- first([ .. ]) 这个模式类似于与 any([ .. 的任何拒绝和完成。\n\t- last([ .. ]) 这个模式类似于 first([ .. ]) ,但却是只有最后一个完成胜出\n\t- 有些时候会需要在一列 Promise 中迭代, 并对所有 Promise 都执行某个任务,并发迭代，map()\n\n- Promise API 概述\n\n\t- new Promise(..) 构造器,接受两个参数，reject(..) 就是拒绝这个 promise;但 resolve(..) 既可能完成 promise\n\t- Promise.resolve(..) 和 Promise.reject(..)\n\t- then(..) 和 catch(..)\n\n\t\t- then(..) 接受一个或两个参数:第一个用于完成回调,第二个用于拒绝回调\n\t\t- catch(..) 只接受一个拒绝回调作为参数,并自动替换默认完成 回调\n\n\t- Promise.all([ .. ]) 和 Promise.race([ .. ])\n\n\t\t- 对 Promise.all([ .. ]) 来说,只有传入的所有 promise 都完成,返回 promise 才能完成\n\t\t- 对 Promise.race([ .. ]) 来说,只有第一个决议的 promise(完成或拒绝)取胜, \n并且其 决议结果成为返回 promise 的决议。\n\n- Promise 局限性\n\n\t-  顺序错误处理\n\n\t\t- 即 Promise 链中的错误很容易被 无意中默默忽略掉\n\t\t- 没有把整个链标识为一个个体的实体,这意味着没有外部方法可以用于观 察可能发生的错误\n\n\t- 单一值\n\n\t\t- Promise 只能有一个完成值或一个拒绝理由\n\n\t- 单决议\n\n\t\t- :Promise 只能被决议一次(完成或拒绝)\n\n\t- 惯性\n\n\t\t- 开发者需要刻意的改变编程习惯,因为 Promise 不会从目前的编码方式中自 然而然地衍生出来\n\n\t- 无法取消的 Promise\n\n\t\t- 一旦创建了一个 Promise 并为其注册了完成和 / 或拒绝处理函数,如果出现某种情况使得 这个任务悬而未决的话,\n你也没有办法从外部停止它的进程\n\n\t- Promise 性能\n\n\t\t- Promise 进行的动作要多一些,这自然意味着它也会稍慢一些。\n\n### Promise\n\n- 特点\n\n\t- 对象状态不受外界影响，只有异步操作的结果可以决定当前的状态\n\n\t\t- pending\n\t\t- fulfilled\n\t\t- rejected\n\n\t- 状态一旦改变，就不会再变\n\t- 无法取消Promise，一旦新建就立即执行\n\t- 如果不设置回调函数，内部抛出的错误无法反应到外部\n\t- 处于pending时，无法得知目前进展到哪一个阶段了（刚刚开始还是即将完成）\n\n- 含义\n\n\t- 是一个对象/容器，保存某个未来才会结束事件的结果\n\n- 基础用法\n\n\t- new Promise时，需要传递一个executor执行器，执行器立即执行\n\t- executor接收两个参数，分别是resolve和reject\n\t- promise只能从pending到rejected或者从pending到fulfilled\n\t- promise的状态一旦确认，就不会再改变\n\t- reject方法的作用，等同于抛出错误\n\n- then\n\n\t- 定义在Promise.prototype上\n\t- 接收两个参数（可以缺省）\n\n\t\t- promise成功的回调\n\t\t- promise失败的回调\n\n\t- 如果调用then时，promise已经成功，则执行成功的回调函数，并将promise的值作为参数传递进去\n\t- 如果调用then时，promise已经失败，则执行失败的回调函数，并将promise失败的原因作为参数传递进去\n\t- 如果promise的状态是pending，则将两个回调函数存放起来，等待状态确定后，再一次将对应的函数执行（发布订阅）\n\t- promise可以then多次，promise的then返回一个promise \n\t- 如果then返回的是一个结果，那么就会把这个结果作为参数传递给下一个then的成功回调函数\n\t- 如果then中抛出了异常，那么就会把这个异常作为参数，传递给下一个then的失败回调函数\n\t- 如果then返回的是一个promise，那么需要等待这个promise执行完，如果promise返回成功则进入下一个then的成功，如果失败，就进入下个个then的失败\n\n- then与catch返回值return不能是promise本身，否则会造成死循环\n- catch\n\n\t- 定义在Promise.prototype上，用于指定发生错误时的回调函数\n\t- 如果catch之前的promise抛错错误（包括catch之前的then抛出错误也会被捕获）那么状态就会变为rejected，就会调用catch指定的回调函数，处理这个错误\n\t- reject方法的作用，等同于抛出错误\n\t- resolve之后再抛出错误是无效的，因为状态一旦改变，变不会再变\n\t- Promise对象的错误具有冒泡性质，会一直向后传递，直到被捕获位置\n\t- 一般不在then方法里面定义reject状态的回调函数，而是在then的外面使用catch，这样可以捕获then执行中的错误\n\t- 如果没有catch方法则promise对象抛出的错误不会传递到外层代码，即不会有任何的反应\n\t- catch后接then方法，如果没有抛出错误则会跳过catch直接执行then\n\t- catch方法后还可以调用catch\n\n- finally\n\n\t- 定义在Promise.prototype上，无论Promise的状态如何，都会执行（es2018）\n\t- 不依赖Promise的执行结果，所以不就受任何参数\n\n- Promise.all()\n\n\t- 构造函数上的方法，用来将多个Promise的实例，包装成一个新的Promise的实例\n\t- 接收（一般为数组）一个具有Iterator接口的参数，参数返回成员都是Promise的实例\n\t- 如果参数不是Promise的实例，则会调用Primise.resolve方法，将参数转为Promise的实例\n\t- 只有参数实例的状态都变成fulfilled，状态才会变成fulfilled，此时参数的返回值组成一个数组传给实例的回调函数\n\t- 只要参数实例有一个状态变成rejected，实例状态就会变成rejected，此时第一个被rejected的参数实例的返回值就会传递给实例的回调函数\n\t- 参数实例中有catch方法且执行了的话，该参数实例会变成resolved，Promise.all()的catch方法也不会被执行\n\n- Promise.race()\n\n\t- 参数与Promise.all()一样，如果不是Promise实例则会调用Promise.resolve\n\t- 只要参数实例之中有一个实例率先改变状态则实例状态就跟着改变，率先改变的参数实例的返回值会传递给实例的回调函数\n\n- Promise.resolve()\n\n\t- 将现有对象转为Promise对象\n\t- 等价于 new Promise（resolve=>resolve('foo')）\n\t- 参数是一个Promise的实例则不做任何修改，原封不动的返回实例\n\t- 参数是一个thenable的对象（具有then方法的对象），会将这个对象转为Promise对象，然后立即执行thenable对象的then 方法\n\t- 参数不是thenable对象或者不是对象，则返回一个新的Promise对象状态为resolved，Promise.reolved方法的参数会同时传给回调函数\n\t- 不带参数，直接返回一个resolved状态的对象，在本轮事件循环结束时执行\n\n- Promise.reject()\n\n\t- 返回一个Promise实例，状态为rejected\n\t- 参数会原封不动的作为rejected的理由，变成后续方法的参数（不会立即执行thenable对象的then方法）\n\n- Promise.try()\n\n\t- 现有的提案还未通过，同步函数同步执行，异步函数异步执行。\n\t- 也可以使用立即执行函数里面使用async或者Promise实现\n\n## Generator\n\n### Generator\n\n- 概念\n\n\t- Generator函数是一个状态机，封装了多个内部状态\n\t- 返回一个遍历器对象代表函数的内部指针，可以一次遍历Generator函数内部的每个状态\n\t- function与函数名之间有星号*，内部使用yield表达式\n\t- yield是暂停执行的标志，next方法可以恢复执行\n\t- next()方法返回带有value、done属性的对象\n\t- 将Generator赋值给对象的Symbol.iterator属性，从而使对象具有iterator接口\n\t- for...of循环可以自动遍历Generator函数运行时生成的iterator对象。\n\t- 不是构造函数，所以实例对象拿不到this上的属性，函数绑定在对象上面时候可以使用this：F.call(obj)，两个对象统一的实现是F.call(F.prototype)\n\n- yield\n\n\t-  遇到yield表达式，暂停执行后面的操作，yield后面的表达式的值作为返回对象的value属性的值\n\t- 下一次掉用next方法再继续往下执行，直到遇到下一个yield表达式\n\t- 如果没有yield表达式，就一直运行到函数结束，一直到return\n\t- 如果没有return则返回对象的value属性值为undefined\n\t- next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值\n\t- yield在另一个表达式中必须用圆括号括起来\n\n- throw\n\n\t- 每个Generator函数返回的遍历对象都有一个throw方法，可以再函数体外抛出错误，然后再Generator函数体内捕获\n\t- 可以接受一个参数，会被catch语句接收，建议抛出Error对象的实例\n\t- 如果Generator函数内部没有部署try...catch那么会被外部的try...catch代码块捕获\n\t- 如果外部和内部都没有部署try...catch代码块，那么程序会报错，直接中断执行\n\t- 如果错误要被捕获，generator对象必须至少执行过一次next方法\n\t- 第一次next方法相当于启动执行generator函数的内部代码\n\t- throw方法被捕获后，会附带执行下一条的yield表达式，也就是会附带执行一次next方法\n\n- return\n\n\t- 可以返回给定的值，并且终结遍历Generator函数\n\t- 如果函数内部有try...finally代码块，且正在执行try代码块，那么return会推迟到finally代码块执行完再执行\n\t- return、next、throw都是让Generator函数恢复执行，并且使用不同的语句替换yield表达式\n\n- yield*\n\n\t- 用来在一个Generator函数里面执行另一个Generator函数，会自动遍历，如果不带星只会返回遍历器对象\n\t- 等同于部署了一个for...of循环，会自动遍历有Iterator的对象，比如数组\n\n- 上下文\n\n\t- 一般代码运行会产生一个全局上下文环境（context，又称运行环境），包含了当前所有的变量和对象，执行代码是又会在当前上下文环境的上层产生一个运行的上下文，变成当前的上下文，由此形成上下文环境的堆栈，最后产生的上下文环境首先执行完成，退出堆栈，然后在执行完成它下层的上下文，直至所有代码执行完成，堆栈清空\n\t- 而Generator函数的上下文一旦遇到yield就会暂时退出堆栈，里面的所有变量和对象会冻结在当前状态，等到next是，上下文环境会重新加入调用栈，冻结的变量和对象恢复执行\n\n- 协程\n\n\t- 可以并行执行、交换执行权的线程就称为协程\n\t- 子例程只有当前调用子函数完全执行完毕，才会结束执行父函数\n\t- Generator函数属于半协程，如果是完全执行的协程，那么任何函数都可以让暂停的协程继续执行\n\t- 普通线程是抢先式的，优先由运行环境决定，协程式合作式的，执行权由协程自己分配\n\t- 协程好处就是抛出错误的时候可以找到原始的调用栈。\n\n- 应用\n\n\t- 异步操作的同步化表达\n\t- 状态机\n\t- 控制流管理\n\t- 部署Iterator接口\n\t- 作为数据结构\n\n- 异步应用\n\n\t- 传统方法\n\n\t\t- 回调函数\n\t\t- 事件监听\n\t\t- 发布/订阅\n\n\t- 异步\n\n\t\t- 一个任务不连续完成\n\t\t- 先执行第一段，然后转而执行其他任务，等做好了准备在回过头执行第二段\n\t\t- 回调函数就是将任务的第二段单独写在一个函数里\n\t\t- Promise最大问题是代码冗余\n\n\t- 协程\n\n\t\t- 异步任务是A协程\n\t\t- 协程A开始执行\n\t\t- 协程A执行到一半，进入暂停，执行权转移到协程B\n\t\t- 一段时间后，协程B交还执行权\n\t\t- 协程A恢复执行\n\n\t- Thunk函数\n\n\t\t- 是自动执行Generator函数的一种方法\n\t\t- 实现传名调用，即参数用到的时候才求值\n\t\t- 将多参数函数替换成一个只接受回调函数作为参数的单参数函数\n\n### Generator 函数的异步应用\n\n- 传统方法\n\n\t- 回调函数\n\t- 事件监听\n\t- 发布/订阅\n\t- Promise 对象\n\n- 基本概念\n\n\t- 所谓\"异步\"，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段\n\t- 所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数\n\t- Promise 对象是一种新的写法，允许将回调函数的嵌套，改成链式调用\n\n- Generator 函数\n\n\t- 第一步，协程A开始执行。\n\t- 第二步，协程A执行到一半，进入暂停，执行权转移到协程B。\n\t- 第三步，（一段时间后）协程B交还执行权。\n\t- 第四步，协程A恢复执行。\n\t- Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）\n\t- Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因\n\n- Thunk 函数\n\n\t- Thunk 函数是自动执行 Generator 函数的一种方法\n\t- Thunk 函数的定义，它是“传名调用”的一种实现策略，用来替换某个表达式\n\t- 生产环境的转换器，建议使用 Thunkify 模块\n\n- co 模块\n\n\t- co 模块可以让你不用编写 Generator 函数的执行器\n\t- （1）回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。\n\t- （2）Promise 对象。将异步操作包装成 Promise 对象，用then方法交回执行权。\n\n### Generator 函数的语法\n\n- 简介\n\n\t- Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同\n\t- 语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态\n\t- 执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数\n\t- 一是，function关键字与函数名之间有一个星号\n\t- 二是，函数体内部使用yield表达式，定义不同的内部状态\n\t- 总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象\n\n- next 方法的参数\n\n\t- yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值\n\t- 由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的\n\t- 如果想要第一次调用next方法时，就能够输入值，可以在 Generator 函数外面再包一层\n\n- for...of 循环\n\n\t- for...of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法\n\t- 利用for...of循环，可以写出遍历任意对象（object）的方法\n\n- Generator.prototype.throw()\n\n\t- Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获\n\t- 不要混淆遍历器对象的throw方法和全局的throw命令\n\t- throw方法抛出的错误要被内部捕获，前提是必须至少执行过一次next方法\n\n- Generator.prototype.return()\n\n\t- Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数\n\t- 如果return方法调用时，不提供参数，则返回值的value属性为undefined\n\t- Generator 函数内部有try...finally代码块，那么return方法会推迟到finally代码块执行完再执行\n\n- next()、throw()、return() 的共同点\n\n\t- 它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换yield表达式\n\t- next()是将yield表达式替换成一个值。\n\t- throw()是将yield表达式替换成一个throw语句\n\t- return()是将yield表达式替换成一个return语句\n\n- yield* 表达式\n\n\t- 如果在 Generator 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的\n\t- 用到yield*表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数\n\t- 任何数据结构只要有 Iterator 接口，就可以被yield*遍历\n\n- 作为对象属性的 Generator 函数\n\n\t- 属性前面有一个星号，表示这个属性是一个 Generator 函数\n\n- Generator 函数的this\n\n\t- Generator 函数也不能跟new命令一起用，会报错\n\t- 生成一个空对象，使用call方法绑定 Generator 函数内部的this\n\n- 含义\n\n\t- Generator 是实现状态机的最佳结构\n\t- 。Generator 函数被称为“半协程”（semi-coroutine），意思是只有 Generator 函数的调用者，才能将程序的执行权还给 Generator 函数\n\t- Generator 执行产生的上下文环境，一旦遇到yield命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态\n\n- 应用\n\n\t- Generator 可以暂停函数执行，返回任意表达式的值\n\n",ua={data:function(){return{MainComponent:ba}}},va=ua,ga=Object(v["a"])(va,ca,pa,!1,null,"62589146",null),ma=ga.exports,_a=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{},[e("q-markdown",{attrs:{src:t.MainComponent}})],1)},da=[],ha="# es62\n\n## Iterator 和 for...of 循环\n\n### JS表示“集合”的数据结构\n\n- 数组（Array）\n- 对象（Object）\n- Map\n- Set\n\n### 遍历器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。\n\n- Iterator 的作用\n\n\t- 一是为各种数据结构，提供一个统一的、简便的访问接口；\n\t- 二是使得数据结构的成员能够按某种次序排列；\n\t- 三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费\n\n- 遍历过程\n\n\t- （1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。\n\t- （2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。\n\t- （3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。\n\t- （4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。\n\t- 每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。\n\n### 默认 Iterator 接口\n\n- ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性\n\n\t- Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名Symbol.iterator，它是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内（参见《Symbol》一章）。\n\n\t\t- const obj = {\n  [Symbol.iterator] : function () {\n    return {\n      next: function () {\n        return {\n          value: 1,\n          done: true\n        };\n      }\n    };\n  }\n};\n\n### 原生具备 Iterator 接口的数据结构如下。\n\n- Array\n\n\t- 下面的例子是数组的Symbol.iterator属性\n\n\t\t- let arr = ['a', 'b', 'c'];\nlet iter = arr[Symbol.iterator]();\n\niter.next() // { value: 'a', done: false }\niter.next() // { value: 'b', done: false }\niter.next() // { value: 'c', done: false }\niter.next() // { value: undefined, done: true }\n\n- Map\n- Set\n- String\n- TypedArray\n- 函数的 arguments 对象\n- NodeList 对象\n\n### 调用 Iterator 接口的场合\n\n- （1）解构赋值\n\n\t- 对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法。\n\n\t\t- let set = new Set().add('a').add('b').add('c');\n\nlet [x,y] = set;\n// x='a'; y='b'\n\nlet [first, ...rest] = set;\n// first='a'; rest=['b','c'];\n\n- （2）扩展运算符\n\n\t- 扩展运算符（...）也会调用默认的 Iterator 接口。\n\n\t\t- // 例一\nvar str = 'hello';\n[...str] //  ['h','e','l','l','o']\n\n// 例二\nlet arr = ['b', 'c'];\n['a', ...arr, 'd']\n// ['a', 'b', 'c', 'd']\n\n\t\t\t- 实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。\n也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。\n\n\t\t\t\t- let arr = [...iterable];\n\n- （3）yield*\n\n\t- yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。\n\n\t\t- let generator = function* () {\n  yield 1;\n  yield* [2,3,4];\n  yield 5;\n};\n\nvar iterator = generator();\n\niterator.next() // { value: 1, done: false }\niterator.next() // { value: 2, done: false }\niterator.next() // { value: 3, done: false }\niterator.next() // { value: 4, done: false }\niterator.next() // { value: 5, done: false }\niterator.next() // { value: undefined, done: true }\n\n- （4）其他场合\n\n\t- 由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实\n都调用了遍历器接口。下面是一些例子。\n\n\t\t- for...of\nArray.from()\nMap(), Set(), WeakMap(), WeakSet()（比如new Map([['a',1],['b',2]])）\nPromise.all()\nPromise.race()\n\n### 字符串的 Iterator 接口\n\n- 字符串是一个类似数组的对象，也原生具有 Iterator 接口。\n\n\t- var someString = \"hi\";\ntypeof someString[Symbol.iterator]\n// \"function\"\n\nvar iterator = someString[Symbol.iterator]();\n\niterator.next()  // { value: \"h\", done: false }\niterator.next()  // { value: \"i\", done: false }\niterator.next()  // { value: undefined, done: true }\n\n\t\t- 上面代码中，调用Symbol.iterator方法返回一个遍历器对象，在这个遍历器上可以调用 next 方法，实现对于字符串的遍历。\n\n可以覆盖原生的Symbol.iterator方法，达到修改遍历器行为的目的。\n\n\t\t\t- var str = new String(\"hi\");\n\n[...str] // [\"h\", \"i\"]\n\nstr[Symbol.iterator] = function() {\n  return {\n    next: function() {\n      if (this._first) {\n        this._first = false;\n        return { value: \"bye\", done: false };\n      } else {\n        return { done: true };\n      }\n    },\n    _first: true\n  };\n};\n\n[...str] // [\"bye\"]\nstr // \"hi\"\n\n### Iterator 接口与 Generator 函数\n\n- Symbol.iterator方法的最简单实现，还是使用下一章要介绍的 Generator 函数。\n\n\t- let myIterable = {\n  [Symbol.iterator]: function* () {\n    yield 1;\n    yield 2;\n    yield 3;\n  }\n}\n[...myIterable] // [1, 2, 3]\n\n// 或者采用下面的简洁写法\n\nlet obj = {\n  * [Symbol.iterator]() {\n    yield 'hello';\n    yield 'world';\n  }\n};\n\nfor (let x of obj) {\n  console.log(x);\n}\n// \"hello\"\n// \"world\"\n\n\t\t- 上面代码中，Symbol.iterator方法几乎不用部署任何代码，只要用 yield 命令\n给出每一步的返回值即可。\n\n### 遍历器对象的 return()，throw()\n\n- 遍历器对象除了具有next方法，还可以具有return方法和throw方法。如果你自己写遍历器对象生成函数，那么next方法是必须部署的，return方法和throw方法是否部署是可选的。\n\nreturn方法的使用场合是，如果for...of循环提前退出（通常是因为出错，或者有break语句），就会调用return方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。\n\n\t- function readLinesSync(file) {\n  return {\n    [Symbol.iterator]() {\n      return {\n        next() {\n          return { done: false };\n        },\n        return() {\n          file.close();\n          return { done: true };\n        }\n      };\n    },\n  };\n}\n\n\t\t- 上面代码中，函数readLinesSync接受一个文件对象作为参数，返回一个遍历器对象，其中除了next方法，还部署了return方法。\n下面的两种情况，都会触发执行return方法。\n\n\t\t\t- // 情况一\nfor (let line of readLinesSync(fileName)) {\n  console.log(line);\n  break;\n}\n\n// 情况二\nfor (let line of readLinesSync(fileName)) {\n  console.log(line);\n  throw new Error();\n}\n\n### for...of 循环\n\n- ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for...of循环，作为遍历所有数据结构的统一的方法。\n\n一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for...of循环遍历它的成员。也就是说，for...of循环内部调用的是数据结构的Symbol.iterator方法。\n\nfor...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。\n\n\t- 数组\n\n\t\t- 数组原生具备iterator接口（即默认部署了Symbol.iterator属性），for...of循环\n本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。\n\n\t\t\t- const arr = ['red', 'green', 'blue'];\n\nfor(let v of arr) {\n  console.log(v); // red green blue\n}\n\nconst obj = {};\nobj[Symbol.iterator] = arr[Symbol.iterator].bind(arr);\n\nfor(let v of obj) {\n  console.log(v); // red green blue\n}\n\n\t\t\t\t- 上面代码中，空对象obj部署了数组arr的Symbol.iterator属性，结果obj的for...of循环，产生了与arr完全一样的结果。\n\nfor...of循环可以代替数组实例的forEach方法。\n\n\t\t\t\t\t- const arr = ['red', 'green', 'blue'];\n\narr.forEach(function (element, index) {\n  console.log(element); // red green blue\n  console.log(index);   // 0 1 2\n});\n\n\t\t\t\t\t\t- JavaScript 原有的for...in循环，只能获得对象的键名，不能直接获取键值。ES6 提供for...of循环，允许遍历获得键值。\n\t\t\t\t\t\t- var arr = ['a', 'b', 'c', 'd'];\n\nfor (let a in arr) {\n  console.log(a); // 0 1 2 3\n}\n\nfor (let a of arr) {\n  console.log(a); // a b c d\n}\n\t\t\t\t\t\t- 上面代码表明，for...in循环读取键名，for...of循环读取键值。如果要通过for...of循环，获取数组的索引，可以借助数组实例的entries方法和keys方法（参见《数组的扩展》一章）。\n\nfor...of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟for...in循环也不一样。\n\t\t\t\t\t\t- let arr = [3, 5, 7];\narr.foo = 'hello';\n\nfor (let i in arr) {\n  console.log(i); // \"0\", \"1\", \"2\", \"foo\"\n}\n\nfor (let i of arr) {\n  console.log(i); //  \"3\", \"5\", \"7\"\n}\n\t\t\t\t\t\t- 上面代码中，for...of循环不会返回数组arr的foo属性。\n\n\t- Set 和 Map 结构\n\n\t\t- Set 和 Map 结构也原生具有 Iterator 接口，可以直接使用for...of循环。\n\n\t\t\t- var engines = new Set([\"Gecko\", \"Trident\", \"Webkit\", \"Webkit\"]);\nfor (var e of engines) {\n  console.log(e);\n}\n// Gecko\n// Trident\n// Webkit\n\nvar es6 = new Map();\nes6.set(\"edition\", 6);\nes6.set(\"committee\", \"TC39\");\nes6.set(\"standard\", \"ECMA-262\");\nfor (var [name, value] of es6) {\n  console.log(name + \": \" + value);\n}\n// edition: 6\n// committee: TC39\n// standard: ECMA-262\n\t\t\t- 上面代码演示了如何遍历 Set 结构和 Map 结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值。\n\t\t\t- let map = new Map().set('a', 1).set('b', 2);\nfor (let pair of map) {\n  console.log(pair);\n}\n// ['a', 1]\n// ['b', 2]\n\nfor (let [key, value] of map) {\n  console.log(key + ' : ' + value);\n}\n// a : 1\n// b : 2\n\n\t- 计算生成的数据结构\n\n\t\t- 有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。\n\nentries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用entries方法。\nkeys() 返回一个遍历器对象，用来遍历所有的键名。\nvalues() 返回一个遍历器对象，用来遍历所有的键值。\n这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。\n\n\t\t\t- let arr = ['a', 'b', 'c'];\nfor (let pair of arr.entries()) {\n  console.log(pair);\n}\n// [0, 'a']\n// [1, 'b']\n// [2, 'c']\n\n\t- 类似数组的对象\n\n\t\t- 类似数组的对象包括好几类。下面是for...of循环用于字符串、DOM NodeList 对象、arguments对象的例子。\n\n\t\t\t- // 字符串\nlet str = \"hello\";\n\nfor (let s of str) {\n  console.log(s); // h e l l o\n}\n\n// DOM NodeList对象\nlet paras = document.querySelectorAll(\"p\");\n\nfor (let p of paras) {\n  p.classList.add(\"test\");\n}\n\n// arguments对象\nfunction printArgs() {\n  for (let x of arguments) {\n    console.log(x);\n  }\n}\nprintArgs('a', 'b');\n// 'a'\n// 'b'\n\t\t\t- 并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用Array.from方法将其转为数组。\n\t\t\t- let arrayLike = { length: 2, 0: 'a', 1: 'b' };\n\n// 报错\nfor (let x of arrayLike) {\n  console.log(x);\n}\n\n// 正确\nfor (let x of Array.from(arrayLike)) {\n  console.log(x);\n}\n\n\t- 对象\n\n\t\t- 对于普通的对象，for...of结构不能直接使用，会报错，必须部署了 \nIterator 接口后才能使用。但是，这样情况下，for...in循环依然可以用来遍历键名。\n\n\t\t\t- let es6 = {\n  edition: 6,\n  committee: \"TC39\",\n  standard: \"ECMA-262\"\n};\n\nfor (let e in es6) {\n  console.log(e);\n}\n// edition\n// committee\n// standard\n\nfor (let e of es6) {\n  console.log(e);\n}\n// TypeError: es6[Symbol.iterator] is not a function\n\n\t- 与其他遍历语法的比较\n\n\t\t- 以数组为例，JavaScript 提供多种遍历语法。最原始的写法就是for循环。\n\n\t\t\t- for (var index = 0; index < myArray.length; index++) {\n  console.log(myArray[index]);\n}\n\n\t\t- 这种写法比较麻烦，因此数组提供内置的forEach方法。\n\n\t\t\t- myArray.forEach(function (value) {\n  console.log(value);\n});\n\t\t\t- 这种写法的问题在于，无法中途跳出forEach循环，break命令或return命令都不能奏效。\n\n\t\t- for...in循环可以遍历数组的键名。\n\n\t\t\t- for (var index in myArray) {\n  console.log(myArray[index]);\n}\n\n\t\t\t\t- for...in循环有几个缺点。\n\n\t\t\t\t\t- 数组的键名是数字，但是for...in循环是以字符串作为键名“0”、“1”、“2”等等。\n\t\t\t\t\t- for...in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。\n\t\t\t\t\t- 某些情况下，for...in循环会以任意顺序遍历键名。\n\t\t\t\t\t- 总之，for...in循环主要是为遍历对象而设计的，不适用于遍历数组。\n\n\t\t- for...of循环相比上面几种做法，有一些显著的优点。\n\n\t\t\t- for (let value of myArray) {\n  console.log(value);\n}\n\n\t\t\t\t- 有着同for...in一样的简洁语法，但是没有for...in那些缺点。\n\t\t\t\t- 不同于forEach方法，它可以与break、continue和return配合使用。\n\t\t\t\t- 提供了遍历所有数据结构的统一操作接口。\n\t\t\t\t- 下面是一个使用 break 语句，跳出for...of循环的例子。\n\n\t\t\t\t\t- for (var n of fibonacci) {\n  if (n > 1000)\n    break;\n  console.log(n);\n}\n\n\t\t\t\t\t\t- 上面的例子，会输出斐波纳契数列小于等于 1000 的项。如果当前项大于 1000，就会使用break语句跳出for...of循环。\n\n## Generator 函数的语法\n\n### 基本概念\n\n- Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。\n\nGenerator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。\n\n执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\n\n形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。\n- function* helloWorldGenerator() {\n  yield 'hello';\n  yield 'world';\n  return 'ending';\n}\n\nvar hw = helloWorldGenerator();\n- 上面代码定义了一个 Generator 函数helloWorldGenerator，它内部有两个yield表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。\n\n下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。\n- hw.next()\n// { value: 'hello', done: false }\n\nhw.next()\n// { value: 'world', done: false }\n\nhw.next()\n// { value: 'ending', done: true }\n\nhw.next()\n// { value: undefined, done: true }\n\n- 上面代码一共调用了四次next方法。\n\n第一次调用，Generator 函数开始执行，直到遇到第一个yield表达式为止。next方法返回一个对象，它的value属性就是当前yield表达式的值hello，done属性的值false，表示遍历还没有结束。\n\n第二次调用，Generator 函数从上次yield表达式停下的地方，一直执行到下一个yield表达式。next方法返回的对象的value属性就是当前yield表达式的值world，done属性的值false，表示遍历还没有结束。\n\n第三次调用，Generator 函数从上次yield表达式停下的地方，一直执行到return语句（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），done属性的值true，表示遍历已经结束。\n\n第四次调用，此时 Generator 函数已经运行完毕，next方法返回对象的value属性为undefined，done属性为true。以后再调用next方法，返回的都是这个值。\n\n总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。\n- function * foo(x, y) { ··· }\nfunction *foo(x, y) { ··· }\nfunction* foo(x, y) { ··· }\nfunction*foo(x, y) { ··· }\n由于 Generator 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在function关键字后面。本书也采用这种写法。\n\n### yield 表达式\n\n- 由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。\n\n\n\n\t- 遍历器对象的next方法的运行逻辑如下。\n\n\t\t- （1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。\n\t\t- （2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。\n\t\t- （3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。\n\t\t- （4）如果该函数没有return语句，则返回的对象的value属性值为undefined。\n\t\t- 需要注意的是，yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。\n\t\t- function* gen() {\n  yield  123 + 456;\n}\n\n\t\t- 上面代码中，yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值。\n\nyield表达式与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield表达式。正常函数只能返回一个值，因为只能执行一次return；Generator 函数可以返回一系列的值，因为可以有任意多个yield。从另一个角度看，也可以说 Generator 生成了一系列的值，这也就是它的名称的来历（英语中，generator 这个词是“生成器”的意思）。\n\t\t- Generator 函数可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数。\n\t\t- function* f() {\n  console.log('执行了！')\n}\n\nvar generator = f();\n\nsetTimeout(function () {\n  generator.next()\n}, 2000);\n\t\t- 上面代码中，函数f如果是普通函数，在为变量generator赋值时就会执行。但是，函数f是一个 Generator 函数，就变成只有调用next方法时，函数f才会执行。\n\n另外需要注意，yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。\n\n- 与 Iterator 接口的关系\n\n\t- 任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。\n\n由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。\n\n\t\t- var myIterable = {};\nmyIterable[Symbol.iterator] = function* () {\n  yield 1;\n  yield 2;\n  yield 3;\n};\n\n[...myIterable] // [1, 2, 3]\n\t\t- 上面代码中，Generator 函数赋值给Symbol.iterator属性，从而使得myIterable对象具有了 Iterator 接口，可以被...运算符遍历了。\n\n\t- Generator 函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。\n\n\t\t- function* gen(){\n  // some code\n}\n\nvar g = gen();\n\ng[Symbol.iterator]() === g\n// true\n\n\t\t\t- 上面代码中，gen是一个 Generator 函数，调用它会生成一个遍历器对象g。它的Symbol.iterator属性，也是一个遍历器对象生成函数，执行后返回它自己。\n\n- next 方法的参数\n\n\t- yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。\n\n\t\t- function* f() {\n  for(var i = 0; true; i++) {\n    var reset = yield i;\n    if(reset) { i = -1; }\n  }\n}\n\nvar g = f();\n\ng.next() // { value: 0, done: false }\ng.next() // { value: 1, done: false }\ng.next(true) // { value: 0, done: false }\n\t\t- 上面代码先定义了一个可以无限运行的 Generator 函数f，如果next方法没有参数，每次运行到yield表达式，变量reset的值总是undefined。当next方法带一个参数true时，变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。\n\n这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。\n\t\t- function* foo(x) {\n  var y = 2 * (yield (x + 1));\n  var z = yield (y / 3);\n  return (x + y + z);\n}\n\nvar a = foo(5);\na.next() // Object{value:6, done:false}\na.next() // Object{value:NaN, done:false}\na.next() // Object{value:NaN, done:true}\n\nvar b = foo(5);\nb.next() // { value:6, done:false }\nb.next(12) // { value:8, done:false }\nb.next(13) // { value:42, done:true }\n\t\t- 上面代码中，第二次运行next方法的时候不带参数，导致 y 的值等于2 * undefined（即NaN），除以 3 以后还是NaN，因此返回对象的value属性也等于NaN。第三次运行Next方法的时候不带参数，所以z等于undefined，返回对象的value属性等于5 + NaN + undefined，即NaN。\n\n如果向next方法提供参数，返回结果就完全不一样了。上面代码第一次调用b的next方法时，返回x+1的值6；第二次调用next方法，将上一次yield表达式的值设为12，因此y等于24，返回y / 3的值8；第三次调用next方法，将上一次yield表达式的值设为13，因此z等于13，这时x等于5，y等于24，所以return语句的值等于42。\n\n注意，由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。V8 引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。\n\n- for...of 循环\n\n\t- for...of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。\n\n\t\t- function* foo() {\n  yield 1;\n  yield 2;\n  yield 3;\n  yield 4;\n  yield 5;\n  return 6;\n}\n\nfor (let v of foo()) {\n  console.log(v);\n}\n// 1 2 3 4 5\n\n\t- 利用for...of循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口，\n无法使用for...of循环，通过 Generator 函数为它加上这个接口，就可以用了。\n\n\t\t- function* objectEntries(obj) {\n  let propKeys = Reflect.ownKeys(obj);\n\n  for (let propKey of propKeys) {\n    yield [propKey, obj[propKey]];\n  }\n}\n\nlet jane = { first: 'Jane', last: 'Doe' };\n\nfor (let [key, value] of objectEntries(jane)) {\n  console.log(`${key}: ${value}`);\n}\n// first: Jane\n// last: Doe\n\n\t- 除了for...of循环以外，扩展运算符（...）、解构赋值和Array.from方法内部调用的，都是遍历器接口。\n这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。\n\n\t\t- function* numbers () {\n  yield 1\n  yield 2\n  return 3\n  yield 4\n}\n\n// 扩展运算符\n[...numbers()] // [1, 2]\n\n// Array.from 方法\nArray.from(numbers()) // [1, 2]\n\n// 解构赋值\nlet [x, y] = numbers();\nx // 1\ny // 2\n\n// for...of 循环\nfor (let n of numbers()) {\n  console.log(n)\n}\n// 1\n// 2\n\n- Generator.prototype.throw() \n\n\t- Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。\n\n\t\t- var g = function* () {\n  try {\n    yield;\n  } catch (e) {\n    console.log('内部捕获', e);\n  }\n};\n\nvar i = g();\ni.next();\n\ntry {\n  i.throw('a');\n  i.throw('b');\n} catch (e) {\n  console.log('外部捕获', e);\n}\n// 内部捕获 a\n// 外部捕获 b\n\t\t- 上面代码中，遍历器对象i连续抛出两个错误。第一个错误被 Generator 函数体内的catch语句捕获。i第二次抛出错误，由于 Generator 函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的catch语句捕获。\n\t\t- throw方法可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象的实例。\n\t\t- var g = function* () {\n  try {\n    yield;\n  } catch (e) {\n    console.log(e);\n  }\n};\n\nvar i = g();\ni.next();\ni.throw(new Error('出错了！'));\n// Error: 出错了！(…)\n\n## async 函数\n\n### 含义\n\n- ES2017 标准引入了 async 函数，使得异步操作变得更加方便。\n\nasync 函数是什么？一句话，它就是 Generator 函数的语法糖。\n\n前文有一个 Generator 函数，依次读取两个文件。\n\n\t- const fs = require('fs');\n\nconst readFile = function (fileName) {\n  return new Promise(function (resolve, reject) {\n    fs.readFile(fileName, function(error, data) {\n      if (error) return reject(error);\n      resolve(data);\n    });\n  });\n};\n\nconst gen = function* () {\n  const f1 = yield readFile('/etc/fstab');\n  const f2 = yield readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n\t- 写成async函数，就是下面这样。\n\t- const asyncReadFile = async function () {\n  const f1 = await readFile('/etc/fstab');\n  const f2 = await readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n\t- 一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。\n\n### async函数对 Generator 函数的改进，体现在以下四点。\n\n- （1）内置执行器。\n\nGenerator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。\n\n\t- asyncReadFile();\n\n\t\t- 上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。\n\n- （2）更好的语义。\n\nasync和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。\n- 3）更广的适用性。\n\nco模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。\n- 4）返回值是 Promise。\n\nasync函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。\n\n进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。\n\n### 基本用法\n\n- async函数返回一个 Promise 对象，可以使用then方法添加回调函数。\n当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。\n\n\t- async function getStockPriceByName(name) {\n  const symbol = await getStockSymbol(name);\n  const stockPrice = await getStockPrice(symbol);\n  return stockPrice;\n}\n\ngetStockPriceByName('goog').then(function (result) {\n  console.log(result);\n});\n\n### 语法\n\n- 返回 Promise 对象\n\n\t- async函数返回一个 Promise 对象。\n\nasync函数内部return语句返回的值，会成为then方法回调函数的参数。\n\n\t\t- async function f() {\n  return 'hello world';\n}\n\nf().then(v => console.log(v))\n// \"hello world\"\n\n\t\t\t- 上面代码中，函数f内部return命令返回的值，会被then方法回调函数接收到。\n\n- Promise 对象的状态变化\n\n\t- async function getTitle(url) {\n  let response = await fetch(url);\n  let html = await response.text();\n  return html.match(/<title>([\\s\\S]+)<\\/title>/i)[1];\n}\ngetTitle('https://tc39.github.io/ecma262/').then(console.log)\n// \"ECMAScript 2017 Language Specification\"\n\n\t\t- 上面代码中，函数getTitle内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行then方法里面的console.log。\n\n\n\n- await 命令\n\n\t- 正常情况下，await命令后面是一个 Promise 对象。如果不是，就返回对应的值。\n\n\t\t- async function f() {\n  // 等同于\n  // return 123;\n  return await 123;\n}\n\nf().then(v => console.log(v))\n// 123\n\n\t- await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。\n\n\t\t- async function f() {\n  await Promise.reject('出错了');\n}\n\nf()\n.then(v => console.log(v))\n.catch(e => console.log(e))\n// 出错了\n\t\t- 注意，上面代码中，await语句前面没有return，但是reject方法的参数依然传入了catch方法的回调函数。这里如果在await前面加上return，效果是一样的。\n\t\t- 只要一个await语句后面的 Promise 变为reject，那么整个async函数都会中断执行。\n\t\t- async function f() {\n  await Promise.reject('出错了');\n  await Promise.resolve('hello world'); // 不会执行\n}\n\t\t- 有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在try...catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。\n\t\t- async function f() {\n  try {\n    await Promise.reject('出错了');\n  } catch(e) {\n  }\n  return await Promise.resolve('hello world');\n}\n\nf()\n.then(v => console.log(v))\n// hello world\n\t\t- 另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。\n\t\t- async function f() {\n  await Promise.reject('出错了')\n    .catch(e => console.log(e));\n  return await Promise.resolve('hello world');\n}\n\nf()\n.then(v => console.log(v))\n// 出错了\n// hello world\n\n- 错误处理\n\n\t- 如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。\n\n\t\t- async function f() {\n  await new Promise(function (resolve, reject) {\n    throw new Error('出错了');\n  });\n}\n\nf()\n.then(v => console.log(v))\n.catch(e => console.log(e))\n// Error：出错了\n\t\t- 上面代码中，async函数f执行后，await后面的 Promise 对象会抛出一个错误对象，导致catch方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。\n\t\t- 防止出错的方法，也是将其放在try...catch代码块之中\n\t\t- async function f() {\n  try {\n    await new Promise(function (resolve, reject) {\n      throw new Error('出错了');\n    });\n  } catch(e) {\n  }\n  return await('hello world');\n}\n\t\t- 如果有多个await命令，可以统一放在try...catch结构中。\n\t\t- async function main() {\n  try {\n    const val1 = await firstStep();\n    const val2 = await secondStep(val1);\n    const val3 = await thirdStep(val1, val2);\n\n    console.log('Final: ', val3);\n  }\n  catch (err) {\n    console.error(err);\n  }\n}\n\n- 使用注意点\n\n\t- 第一点，前面已经说过，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try...catch代码块中。\n\n\t\t- async function myFunction() {\n  try {\n    await somethingThatReturnsAPromise();\n  } catch (err) {\n    console.log(err);\n  }\n}\n\n// 另一种写法\n\nasync function myFunction() {\n  await somethingThatReturnsAPromise()\n  .catch(function (err) {\n    console.log(err);\n  });\n}\n\n\t- 第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。\n\n\t\t- let foo = await getFoo();\nlet bar = await getBar();\n\t\t- 上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。\n\t\t- // 写法一\nlet [foo, bar] = await Promise.all([getFoo(), getBar()]);\n\n// 写法二\nlet fooPromise = getFoo();\nlet barPromise = getBar();\nlet foo = await fooPromise;\nlet bar = await barPromise;\n\t\t- 上面两种写法，getFoo和getBar都是同时触发，这样就会缩短程序的执行时间。\n\n\t- 第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。\n\n\t\t- async function dbFuc(db) {\n  let docs = [{}, {}, {}];\n\n  // 报错\n  docs.forEach(function (doc) {\n    await db.post(doc);\n  });\n}\n\t\t- 上面代码会报错，因为await用在普通函数之中了。但是，如果将forEach方法的参数改成async函数，也有问题。\n\t\t- function dbFuc(db) { //这里不需要 async\n  let docs = [{}, {}, {}];\n\n  // 可能得到错误结果\n  docs.forEach(async function (doc) {\n    await db.post(doc);\n  });\n}\n\t\t- 上面代码可能不会正常工作，原因是这时三个db.post操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。\n\t\t- async function dbFuc(db) {\n  let docs = [{}, {}, {}];\n\n  for (let doc of docs) {\n    await db.post(doc);\n  }\n}\n\n### async 函数的实现原理\n\n- async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。\n\n\t- async function fn(args) {\n  // ...\n}\n\n// 等同于\n\nfunction fn(args) {\n  return spawn(function* () {\n    // ...\n  });\n}\n\t- 所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器。\n\t- spawn函数的实现，基本就是前文自动执行器的翻版\n\t- function spawn(genF) {\n  return new Promise(function(resolve, reject) {\n    const gen = genF();\n    function step(nextF) {\n      let next;\n      try {\n        next = nextF();\n      } catch(e) {\n        return reject(e);\n      }\n      if(next.done) {\n        return resolve(next.value);\n      }\n      Promise.resolve(next.value).then(function(v) {\n        step(function() { return gen.next(v); });\n      }, function(e) {\n        step(function() { return gen.throw(e); });\n      });\n    }\n    step(function() { return gen.next(undefined); });\n  });\n}\n\n## Class 的基本语法\n\n### 简介\n\n- JavaScript 语言中，生成实例对象的传统方法是通过构造函数\n\n\t- function Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.toString = function () {\n  return '(' + this.x + ', ' + this.y + ')';\n};\n\nvar p = new Point(1, 2);\n\t- 上面的代码用 ES6 的class改写，就是下面这样。\n\t- //定义类\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n}\n\t- 定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。\n\n- ES6 的类，完全可以看作构造函数的另一种写法。\n\n\t- class Point {\n  // ...\n}\n\ntypeof Point // \"function\"\nPoint === Point.prototype.constructor // true\n\t- 上面代码表明，类的数据类型就是函数，类本身就指向构造函数。\n\t- 使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。\n\t- 构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。\n\n\t\t- class Point {\n  constructor() {\n    // ...\n  }\n\n  toString() {\n    // ...\n  }\n\n  toValue() {\n    // ...\n  }\n}\n\n// 等同于\n\nPoint.prototype = {\n  constructor() {},\n  toString() {},\n  toValue() {},\n};\n\n\t- 在类的实例上面调用方法，其实就是调用原型上的方法。\n\n\t\t- class B {}\nlet b = new B();\n\nb.constructor === B.prototype.constructor // true\n\t\t- 上面代码中，b是B类的实例，它的constructor方法就是B类原型的constructor方法。\n\n\t- 由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。\n\n\t\t- class Point {\n  constructor(){\n    // ...\n  }\n}\n\nObject.assign(Point.prototype, {\n  toString(){},\n  toValue(){}\n});\n\n\t- prototype对象的constructor属性，直接指向“类”的本身，这与 ES5 的行为是一致的。\n\n\t\t- Point.prototype.constructor === Point // true\n\n\t- 另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。\n\n\t\t- class Point {\n  constructor(x, y) {\n    // ...\n  }\n\n  toString() {\n    // ...\n  }\n}\n\nObject.keys(Point.prototype)\n// []\nObject.getOwnPropertyNames(Point.prototype)\n// [\"constructor\",\"toString\"]\n\t\t- 上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致。\n\n- 类的属性名，可以采用表达式。\n\n\t- let methodName = 'getArea';\n\nclass Square {\n  constructor(length) {\n    // ...\n  }\n\n  [methodName]() {\n    // ...\n  }\n}\n\t- 上面代码中，Square类的方法名getArea，是从表达式得到的。\n\n### 严格模式\n\n- 类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。\n\n考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。\n\n### constructor 方法\n\n- constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。\n\n\t- class Point {\n}\n\n// 等同于\nclass Point {\n  constructor() {}\n}\n\n- constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。\n\n\t- class Foo {\n  constructor() {\n    return Object.create(null);\n  }\n}\n\nnew Foo() instanceof Foo\n// false\n\t- 上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。\n\n- 类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。\n\n\t- class Foo {\n  constructor() {\n    return Object.create(null);\n  }\n}\n\nFoo()\n// TypeError: Class constructor Foo cannot be invoked without 'new'\n\n### 类的实例对象\n\n- 生成类的实例对象的写法，与 ES5 完全一样，也是使用new命令。前面说过，如果忘记加上new，像函数那样调用Class，将会报错。\n\n\t- class Point {\n  // ...\n}\n\n// 报错\nvar point = Point(2, 3);\n\n// 正确\nvar point = new Point(2, 3);\n\n- 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。\n\n\t- //定义类\nclass Point {\n\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n\n}\n\nvar point = new Point(2, 3);\n\npoint.toString() // (2, 3)\n\npoint.hasOwnProperty('x') // true\npoint.hasOwnProperty('y') // true\npoint.hasOwnProperty('toString') // false\npoint.__proto__.hasOwnProperty('toString') // true\n\t- 上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与 ES5 的行为保持一致。\n\t- 与 ES5 一样，类的所有实例共享一个原型对象。\n\n\t\t- var p1 = new Point(2,3);\nvar p2 = new Point(3,2);\n\np1.__proto__ === p2.__proto__\n//true\n\t\t- 上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以__proto__属性是相等的。\n\n这也意味着，可以通过实例的__proto__属性为“类”添加方法。\n\t\t- __proto__ 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。\n\t\t- var p1 = new Point(2,3);\nvar p2 = new Point(3,2);\n\np1.__proto__.printName = function () { return 'Oops' };\n\np1.printName() // \"Oops\"\np2.printName() // \"Oops\"\n\nvar p3 = new Point(4,2);\np3.printName() // \"Oops\"\n\t\t- 上面代码在p1的原型上添加了一个printName方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。\n\n### Class 表达式 \n\n- 与函数一样，类也可以使用表达式的形式定义。\n\n\t- const MyClass = class Me {\n  getClassName() {\n    return Me.name;\n  }\n};\n\t- 上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在 Class 的内部代码可用，指代当前类。\n\t- let inst = new MyClass();\ninst.getClassName() // Me\nMe.name // ReferenceError: Me is not defined\n\t- 上面代码表示，Me只在 Class 内部有定义。\n\n如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。\n\t- const MyClass = class { /* ... */ };\n\n- 采用 Class 表达式，可以写出立即执行的 Class。\n\n\t- let person = new class {\n  constructor(name) {\n    this.name = name;\n  }\n\n  sayName() {\n    console.log(this.name);\n  }\n}('张三');\n\nperson.sayName(); // \"张三\"\n\n### 不存在变量提升\n\n- 类不存在变量提升（hoist），这一点与 ES5 完全不同。\n\n\t- new Foo(); // ReferenceError\nclass Foo {}\n\t- 上面代码中，Foo类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。\n\n- {\n  let Foo = class {};\n  class Bar extends Foo {\n  }\n}\n\n\t- 上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。\n\n### 私有方法和私有属性\n\n- 现有的方法\n\n\t- 私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。\n\n一种做法是在命名上加以区别。\n\n\t\t- class Widget {\n\n  // 公有方法\n  foo (baz) {\n    this._bar(baz);\n  }\n\n  // 私有方法\n  _bar(baz) {\n    return this.snaf = baz;\n  }\n\n  // ...\n}\n\t\t- 上面代码中，_bar方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。\n\t\t- 另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。\n\t\t- class Widget {\n  foo (baz) {\n    bar.call(this, baz);\n  }\n\n  // ...\n}\n\nfunction bar(baz) {\n  return this.snaf = baz;\n}\n\t\t- 上面代码中，foo是公有方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。\n\t\t- 还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。\n\t\t- const bar = Symbol('bar');\nconst snaf = Symbol('snaf');\n\nexport default class myClass{\n\n  // 公有方法\n  foo(baz) {\n    this[bar](baz);\n  }\n\n  // 私有方法\n  [bar](baz) {\n    return this[snaf] = baz;\n  }\n\n  // ...\n};\n\t\t- 上面代码中，bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。\n\n### this 的指向 \n\n- 类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。\n\n\t- class Logger {\n  printName(name = 'there') {\n    this.print(`Hello ${name}`);\n  }\n\n  print(text) {\n    console.log(text);\n  }\n}\n\nconst logger = new Logger();\nconst { printName } = logger;\nprintName(); // TypeError: Cannot read property 'print' of undefined\n\n\t- 上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。\n\t- 一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。\n\t- class Logger {\n  constructor() {\n    this.printName = this.printName.bind(this);\n  }\n\n  // ...\n}\n\t- 另一种解决方法是使用箭头函数。\n\t- class Logger {\n  constructor() {\n    this.printName = (name = 'there') => {\n      this.print(`Hello ${name}`);\n    };\n  }\n\n  // ...\n}\n\n### name 属性 \n\n- 由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。\n\n\t- class Point {}\nPoint.name // \"Point\"\n\n\t\t- name属性总是返回紧跟在class关键字后面的类名。\n\n### Class 的取值函数（getter）和存值函数（setter）\n\n- 与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。\n\n\t- class MyClass {\n  constructor() {\n    // ...\n  }\n  get prop() {\n    return 'getter';\n  }\n  set prop(value) {\n    console.log('setter: '+value);\n  }\n}\n\nlet inst = new MyClass();\n\ninst.prop = 123;\n// setter: 123\n\ninst.prop\n// 'getter'\n\t- 上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了\n\n- 存值函数和取值函数是设置在属性的 Descriptor 对象上的。\n\n\t- class CustomHTMLElement {\n  constructor(element) {\n    this.element = element;\n  }\n\n  get html() {\n    return this.element.innerHTML;\n  }\n\n  set html(value) {\n    this.element.innerHTML = value;\n  }\n}\n\nvar descriptor = Object.getOwnPropertyDescriptor(\n  CustomHTMLElement.prototype, \"html\"\n);\n\n\"get\" in descriptor  // true\n\"set\" in descriptor  // true\n\t- 上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与 ES5 完全一致。\n\n### Class 的 Generator 方法\n\n- 如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。\n\n\t- class Foo {\n  constructor(...args) {\n    this.args = args;\n  }\n  * [Symbol.iterator]() {\n    for (let arg of this.args) {\n      yield arg;\n    }\n  }\n}\n\nfor (let x of new Foo('hello', 'world')) {\n  console.log(x);\n}\n// hello\n// world\n\t- 上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个 Generator 函数。Symbol.iterator方法返回一个Foo类的默认遍历器，for...of循环会自动调用这个遍历器。\n\n### Class 的静态方法\n\n- 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。\n\n\t- class Foo {\n  static classMethod() {\n    return 'hello';\n  }\n}\n\nFoo.classMethod() // 'hello'\n\nvar foo = new Foo();\nfoo.classMethod()\n// TypeError: foo.classMethod is not a function\n\t- 上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。\n\t- 注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。\n\t- class Foo {\n  static bar () {\n    this.baz();\n  }\n  static baz () {\n    console.log('hello');\n  }\n  baz () {\n    console.log('world');\n  }\n}\n\nFoo.bar() // hello\n\t- 上面代码中，静态方法bar调用了this.baz，这里的this指的是Foo类，而不是Foo的实例，等同于调用Foo.baz。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。\n\t- 父类的静态方法，可以被子类继承。\n\t- class Foo {\n  static classMethod() {\n    return 'hello';\n  }\n}\n\nclass Bar extends Foo {\n}\n\nBar.classMethod() // 'hello'\n\t- 上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。\n\t- 静态方法也是可以从super对象上调用的。\n\t- class Foo {\n  static classMethod() {\n    return 'hello';\n  }\n}\n\nclass Bar extends Foo {\n  static classMethod() {\n    return super.classMethod() + ', too';\n  }\n}\n\nBar.classMethod() // \"hello, too\"\n\n### Class 的静态属性和实例属性\n\n- 静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。\n\n\t- class Foo {\n}\n\nFoo.prop = 1;\nFoo.prop // 1\n\t- 目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。\n\t- // 以下两种写法都无效\nclass Foo {\n  // 写法一\n  prop: 2\n\n  // 写法二\n  static prop: 2\n}\n\nFoo.prop // undefined\n\n- 目前有一个静态属性的提案，对实例属性和静态属性都规定了新的写法。\n\n\t- （1）类的实例属性\n\n\t\t- 类的实例属性可以用等式，写入类的定义之中。\n\n\t\t\t- class MyClass {\n  myProp = 42;\n\n  constructor() {\n    console.log(this.myProp); // 42\n  }\n}\n\t\t\t- 上面代码中，myProp就是MyClass的实例属性。在MyClass的实例上，可以读取这个属性。\n\t\t\t- 以前，我们定义实例属性，只能写在类的constructor方法里面。\n\t\t\t- class ReactCounter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n}\n\t\t\t- 有了新的写法以后，可以不在constructor方法里面定义。\n\t\t\t- class ReactCounter extends React.Component {\n  state = {\n    count: 0\n  };\n}\n\n\t- 类的静态属性\n\n\t\t- 类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。\n\n\t\t\t- class MyClass {\n  static myStaticProp = 42;\n\n  constructor() {\n    console.log(MyClass.myStaticProp); // 42\n  }\n}\n\n\t\t- 同样的，这个新写法大大方便了静态属性的表达。\n\n\t\t\t- // 老写法\nclass Foo {\n  // ...\n}\nFoo.prop = 1;\n\n// 新写法\nclass Foo {\n  static prop = 1;\n}\n\t\t\t- 上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。\n\n### new.target 属性\n\n- new是从构造函数生成实例对象的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。\n\n\t- function Person(name) {\n  if (new.target !== undefined) {\n    this.name = name;\n  } else {\n    throw new Error('必须使用 new 命令生成实例');\n  }\n}\n\n// 另一种写法\nfunction Person(name) {\n  if (new.target === Person) {\n    this.name = name;\n  } else {\n    throw new Error('必须使用 new 命令生成实例');\n  }\n}\n\nvar person = new Person('张三'); // 正确\nvar notAPerson = Person.call(person, '张三');  // 报错\n\t- 上面代码确保构造函数只能通过new命令调用。\n\n- Class 内部调用new.target，返回当前 Class。\n\n\t- class Rectangle {\n  constructor(length, width) {\n    console.log(new.target === Rectangle);\n    this.length = length;\n    this.width = width;\n  }\n}\n\nvar obj = new Rectangle(3, 4); // 输出 true\n\n- 需要注意的是，子类继承父类时，new.target会返回子类。\n\n\t- 利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。\n\n\t\t- class Shape {\n  constructor() {\n    if (new.target === Shape) {\n      throw new Error('本类不能实例化');\n    }\n  }\n}\n\nclass Rectangle extends Shape {\n  constructor(length, width) {\n    super();\n    // ...\n  }\n}\n\nvar x = new Shape();  // 报错\nvar y = new Rectangle(3, 4);  // 正确\n\t\t- 上面代码中，Shape类不能被实例化，只能用于继承。\n\n注意，在函数外部，使用new.target会报错。\n\n## Class 的继承\n\n### 简介\n\n- Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。\n\n\t- class Point {\n}\n\nclass ColorPoint extends Point {\n}\n\t- 上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。\n\t- class ColorPoint extends Point {\n  constructor(x, y, color) {\n    super(x, y); // 调用父类的constructor(x, y)\n    this.color = color;\n  }\n\n  toString() {\n    return this.color + ' ' + super.toString(); // 调用父类的toString()\n  }\n}\n\t- 上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。\n\t- 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。\n\t- class Point { /* ... */ }\n\nclass ColorPoint extends Point {\n  constructor() {\n  }\n}\n\nlet cp = new ColorPoint(); // ReferenceError\n\t- 上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。\n\t- ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。\n\t- 如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。\n\n\t\t- class ColorPoint extends Point {\n}\n\n// 等同于\nclass ColorPoint extends Point {\n  constructor(...args) {\n    super(...args);\n  }\n}\n\n\t- 另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。\n\n\t\t- class Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    this.color = color; // ReferenceError\n    super(x, y);\n    this.color = color; // 正确\n  }\n}\n\t\t- 上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。\n\t\t- 下面是生成子类实例的代码。\n\t\t- let cp = new ColorPoint(25, 8, 'green');\n\ncp instanceof ColorPoint // true\ncp instanceof Point // true\n\t\t- 上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与 ES5 的行为完全一致。\n\t\t- 最后，父类的静态方法，也会被子类继承。\n\t\t- class A {\n  static hello() {\n    console.log('hello world');\n  }\n}\n\nclass B extends A {\n}\n\nB.hello()  // hello world\n\t\t- 上面代码中，hello()是A类的静态方法，B继承A，也继承了A的静态方法。\n\n### Object.getPrototypeOf()\n\n- Object.getPrototypeOf方法可以用来从子类上获取父类。\n\n\t- Object.getPrototypeOf(ColorPoint) === Point\n// true\n\t- 因此，可以使用这个方法判断，一个类是否继承了另一个类。\n\n### super 关键字\n\n- super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。\n\n\t- 第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。\n\n\t\t- class A {}\n\nclass B extends A {\n  constructor() {\n    super();\n  }\n}\n\t\t- 上面代码中，子类B的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。\n\t\t- 注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。\n\t\t- class A {\n  constructor() {\n    console.log(new.target.name);\n  }\n}\nclass B extends A {\n  constructor() {\n    super();\n  }\n}\nnew A() // A\nnew B() // B\n\t\t- 上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。\n\t\t- 作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。\n\t\t- class A {}\n\nclass B extends A {\n  m() {\n    super(); // 报错\n  }\n}\n\n\t- 第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。\n\n\t\t- class A {\n  p() {\n    return 2;\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    console.log(super.p()); // 2\n  }\n}\n\nlet b = new B();\n\t\t- 上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。\n\t\t- ES6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。\n\t\t- class A {\n  constructor() {\n    this.x = 1;\n  }\n  print() {\n    console.log(this.x);\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    this.x = 2;\n  }\n  m() {\n    super.print();\n  }\n}\n\nlet b = new B();\nb.m() // 2\n\t\t- 上面代码中，super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()内部的this指向子类B的实例，导致输出的是2，而不是1。也就是说，实际上执行的是super.print.call(this)。\n\n由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。\n\t\t- class A {\n  constructor() {\n    this.x = 1;\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    this.x = 2;\n    super.x = 3;\n    console.log(super.x); // undefined\n    console.log(this.x); // 3\n  }\n}\n\nlet b = new B();\n\t\t- 上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。\n\t\t- 如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。\n\t\t- class Parent {\n  static myMethod(msg) {\n    console.log('static', msg);\n  }\n\n  myMethod(msg) {\n    console.log('instance', msg);\n  }\n}\n\nclass Child extends Parent {\n  static myMethod(msg) {\n    super.myMethod(msg);\n  }\n\n  myMethod(msg) {\n    super.myMethod(msg);\n  }\n}\n\nChild.myMethod(1); // static 1\n\nvar child = new Child();\nchild.myMethod(2); // instance 2\n\t\t- 上面代码中，super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。\n\t\t- 另外，在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。\n\t\t- class A {\n  constructor() {\n    this.x = 1;\n  }\n  static print() {\n    console.log(this.x);\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    this.x = 2;\n  }\n  static m() {\n    super.print();\n  }\n}\n\nB.x = 3;\nB.m() // 3\n\t\t- 上面代码中，静态方法B.m里面，super.print指向父类的静态方法。这个方法里面的this指向的是B，而不是B的实例。\n\t\t- 注意，使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。\n\t\t- class A {}\n\nclass B extends A {\n  constructor() {\n    super();\n    console.log(super); // 报错\n  }\n}\n\t\t- 上面代码中，console.log(super)当中的super，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明super的数据类型，就不会报错。\n\t\t- class A {}\n\nclass B extends A {\n  constructor() {\n    super();\n    console.log(super.valueOf() instanceof B); // true\n  }\n}\n\nlet b = new B();\n\t\t- 上面代码中，super.valueOf()表明super是一个对象，因此就不会报错。同时，由于super使得this指向B的实例，所以super.valueOf()返回的是一个B的实例。\n\t\t- 最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。\n\t\t- var obj = {\n  toString() {\n    return \"MyObject: \" + super.toString();\n  }\n};\n\nobj.toString(); // MyObject: [object Object]\n\n### 类的 prototype 属性和__proto__属性\n\n- 大多数浏览器的 ES5 实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。\n\n\t- （1）子类的__proto__属性，表示构造函数的继承，总是指向父类。\n\t- （2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。\n\n\t\t- class A {\n}\n\nclass B extends A {\n}\n\nB.__proto__ === A // true\nB.prototype.__proto__ === A.prototype // true\n\t\t- 上面代码中，子类B的__proto__属性指向父类A，子类B的prototype属性的__proto__属性指向父类A的prototype属性。\n这样的结果是因为，类的继承是按照下面的模式实现的。\n\t\t- class A {\n}\n\nclass B {\n}\n\n// B 的实例继承 A 的实例\nObject.setPrototypeOf(B.prototype, A.prototype);\n\n// B 继承 A 的静态属性\nObject.setPrototypeOf(B, A);\n\nconst b = new B();\n\t\t- 《对象的扩展》一章给出过Object.setPrototypeOf方法的实现。\n\t\t- Object.setPrototypeOf = function (obj, proto) {\n  obj.__proto__ = proto;\n  return obj;\n}\n\t\t- 因此，就得到了上面的结果。\n\t\t- Object.setPrototypeOf(B.prototype, A.prototype);\n// 等同于\nB.prototype.__proto__ = A.prototype;\n\nObject.setPrototypeOf(B, A);\n// 等同于\nB.__proto__ = A;\n\t\t- 这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（__proto__属性）是父类（A）；作为一个构造函数，子类（B）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。\n\t\t- Object.create(A.prototype);\n// 等同于\nB.prototype.__proto__ = A.prototype;\n\t\t- extends关键字后面可以跟多种类型的值。\n\n\t\t\t- class B extends A {\n}\n\t\t\t- 上面代码的A，只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性（除了Function.prototype函数），因此A可以是任意函数。\n\n\t\t- 下面，讨论两种情况。第一种，子类继承Object类。\n\n\t\t\t- class A extends Object {\n}\n\nA.__proto__ === Object // true\nA.prototype.__proto__ === Object.prototype // true\n\t\t\t- 这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。\n\n\t\t- 第二种情况，不存在任何继承。\n\n\t\t\t- class A {\n}\n\nA.__proto__ === Function.prototype // true\nA.prototype.__proto__ === Object.prototype // true\n\t\t\t- 这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Function.prototype。但是，A调用后返回一个空对象（即Object实例），所以A.prototype.__proto__指向构造函数（Object）的prototype属性。\n\n\t\t- 实例的 __proto__ 属性 \n\n\t\t\t- 子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。\n\n\t\t\t\t- var p1 = new Point(2, 3);\nvar p2 = new ColorPoint(2, 3, 'red');\n\np2.__proto__ === p1.__proto__ // false\np2.__proto__.__proto__ === p1.__proto__ // true\n\t\t\t\t- 上面代码中，ColorPoint继承了Point，导致前者原型的原型是后者的原型。\n\n因此，通过子类实例的__proto__.__proto__属性，可以修改父类实例的行为。\n\t\t\t\t- p2.__proto__.__proto__.printName = function () {\n  console.log('Ha');\n};\n\np1.printName() // \"Ha\"\n\t\t\t\t- 上面代码在ColorPoint的实例p2上向Point类添加方法，结果影响到了Point的实例p1。\n\n### 原生构造函数的继承\n\n- 原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。\n\n\t- Boolean()\nNumber()\nString()\nArray()\nDate()\nFunction()\nRegExp()\nError()\nObject()\n\t- 以前，这些原生构造函数是无法继承的，比如，不能自己定义一个Array的子类。\n\t- function MyArray() {\n  Array.apply(this, arguments);\n}\n\nMyArray.prototype = Object.create(Array.prototype, {\n  constructor: {\n    value: MyArray,\n    writable: true,\n    configurable: true,\n    enumerable: true\n  }\n});\n\t- 上面代码定义了一个继承 Array 的MyArray类。但是，这个类的行为与Array完全不一致。\n\t- var colors = new MyArray();\ncolors[0] = \"red\";\ncolors.length  // 0\n\ncolors.length = 0;\ncolors[0]  // \"red\"\n\t- 之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过Array.apply()或者分配给原型对象都不行。原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。\n\t- ES5 是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，Array构造函数有一个内部属性[[DefineOwnProperty]]，用来定义新属性时，更新length属性，这个内部属性无法在子类获取，导致子类的length属性行为不正常。\n\t- 下面的例子中，我们想让一个普通对象继承Error对象。\n\t- var e = {};\n\nObject.getOwnPropertyNames(Error.call(e))\n// [ 'stack' ]\n\nObject.getOwnPropertyNames(e)\n// []\n\t- 上面代码中，我们想通过Error.call(e)这种写法，让普通对象e具有Error对象的实例属性。但是，Error.call()完全忽略传入的第一个参数，而是返回一个新对象，e本身没有任何变化。这证明了Error.call(e)这种写法，无法继承原生构造函数。\n\n- ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。\n\n\t- class MyArray extends Array {\n  constructor(...args) {\n    super(...args);\n  }\n}\n\nvar arr = new MyArray();\narr[0] = 12;\narr.length // 1\n\narr.length = 0;\narr[0] // undefined\n\t- 上面代码定义了一个MyArray类，继承了Array构造函数，因此就可以从MyArray生成数组的实例。这意味着，ES6 可以自定义原生数据结构（比如Array、String等）的子类，这是 ES5 无法做到的。\n\n上面这个例子也说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。\n\t- class VersionedArray extends Array {\n  constructor() {\n    super();\n    this.history = [[]];\n  }\n  commit() {\n    this.history.push(this.slice());\n  }\n  revert() {\n    this.splice(0, this.length, ...this.history[this.history.length - 1]);\n  }\n}\n\nvar x = new VersionedArray();\n\nx.push(1);\nx.push(2);\nx // [1, 2]\nx.history // [[]]\n\nx.commit();\nx.history // [[], [1, 2]]\n\nx.push(3);\nx // [1, 2, 3]\nx.history // [[], [1, 2]]\n\nx.revert();\nx // [1, 2]\n\t- 上面代码中，VersionedArray会通过commit方法，将自己的当前状态生成一个版本快照，存入history属性。revert方法用来将数组重置为最新一次保存的版本。除此之外，VersionedArray依然是一个普通数组，所有原生的数组方法都可以在它上面调用。\n\t- 下面是一个自定义Error子类的例子，可以用来定制报错时的行为。\n\n\t\t- class ExtendableError extends Error {\n  constructor(message) {\n    super();\n    this.message = message;\n    this.stack = (new Error()).stack;\n    this.name = this.constructor.name;\n  }\n}\n\nclass MyError extends ExtendableError {\n  constructor(m) {\n    super(m);\n  }\n}\n\nvar myerror = new MyError('ll');\nmyerror.message // \"ll\"\nmyerror instanceof Error // true\nmyerror.name // \"MyError\"\nmyerror.stack\n// Error\n//     at MyError.ExtendableError\n//     ...\n\t\t- 注意，继承Object的子类，有一个行为差异。\n\t\t- class NewObj extends Object{\n  constructor(){\n    super(...arguments);\n  }\n}\nvar o = new NewObj({attr: true});\no.attr === true  // false\n\t\t- 上面代码中，NewObj继承了Object，但是无法通过super方法向父类Object传参。这是因为 ES6 改变了Object构造函数的行为，一旦发现Object方法不是通过new Object()这种形式调用，ES6 规定Object构造函数会忽略参数。\n\n### Mixin 模式的实现\n\n- Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。\n\n\t- const a = {\n  a: 'a'\n};\nconst b = {\n  b: 'b'\n};\nconst c = {...a, ...b}; // {a: 'a', b: 'b'}\n\t- 上面代码中，c对象是a对象和b对象的合成，具有两者的接口。\n\t- 下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。\n\n\t\t- function mix(...mixins) {\n  class Mix {}\n\n  for (let mixin of mixins) {\n    copyProperties(Mix.prototype, mixin); // 拷贝实例属性\n    copyProperties(Mix.prototype, Reflect.getPrototypeOf(mixin)); // 拷贝原型属性\n  }\n\n  return Mix;\n}\n\nfunction copyProperties(target, source) {\n  for (let key of Reflect.ownKeys(source)) {\n    if ( key !== \"constructor\"\n      && key !== \"prototype\"\n      && key !== \"name\"\n    ) {\n      let desc = Object.getOwnPropertyDescriptor(source, key);\n      Object.defineProperty(target, key, desc);\n    }\n  }\n}\n\t\t- 上面代码的mix函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。\n\t\t- class DistributedEdit extends mix(Loggable, Serializable) {\n  // ...\n}\n\n## 修饰器\n\n### 类的修饰\n\n- 许多面向对象的语言都有修饰器（Decorator）函数，用来修改类的行为。目前，有一个提案将这项功能，引入了 ECMAScript。\n\n\t- @testable\nclass MyTestableClass {\n  // ...\n}\n\nfunction testable(target) {\n  target.isTestable = true;\n}\n\nMyTestableClass.isTestable // true\n\t- 上面代码中，@testable就是一个修饰器。它修改了MyTestableClass这个类的行为，为它加上了静态属性isTestable。testable函数的参数target是MyTestableClass类本身。\n\n- 基本上，修饰器的行为就是下面这样。\n\n\t- @decorator\nclass A {}\n\n// 等同于\n\nclass A {}\nA = decorator(A) || A;\n\t- 也就是说，修饰器是一个对类进行处理的函数。修饰器函数的第一个参数，就是所要修饰的目标类。\n\t- function testable(target) {\n  // ...\n}\n\t- 上面代码中，testable函数的参数target，就是会被修饰的类。\n\t- 如果觉得一个参数不够用，可以在修饰器外面再封装一层函数。\n\t- function testable(isTestable) {\n  return function(target) {\n    target.isTestable = isTestable;\n  }\n}\n\n@testable(true)\nclass MyTestableClass {}\nMyTestableClass.isTestable // true\n\n@testable(false)\nclass MyClass {}\nMyClass.isTestable // false\n\n\t\t- 上面代码中，修饰器testable可以接受参数，这就等于可以修改修饰器的行为。\n\n- 注意，修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。也就是说，修饰器本质就是编译时执行的函数。\n- 前面的例子是为类添加一个静态属性，如果想添加实例属性，可以通过目标类的prototype对象操作。\n\n\t- function testable(target) {\n  target.prototype.isTestable = true;\n}\n\n@testable\nclass MyTestableClass {}\n\nlet obj = new MyTestableClass();\nobj.isTestable // true\n\t- // mixins.js\nexport function mixins(...list) {\n  return function (target) {\n    Object.assign(target.prototype, ...list)\n  }\n}\n\n// main.js\nimport { mixins } from './mixins'\n\nconst Foo = {\n  foo() { console.log('foo') }\n};\n\n@mixins(Foo)\nclass MyClass {}\n\nlet obj = new MyClass();\nobj.foo() // 'foo'\n\t- 上面代码中，修饰器函数testable是在目标类的prototype对象上添加属性，因此就可以在实例上调用。\n\n- 下面是另外一个例子。\n\n\t- 上面代码通过修饰器mixins，把Foo对象的方法添加到了MyClass的实例上面。可以用Object.assign()模拟这个功能。\n\t- const Foo = {\n  foo() { console.log('foo') }\n};\n\nclass MyClass {}\n\nObject.assign(MyClass.prototype, Foo);\n\nlet obj = new MyClass();\nobj.foo() // 'foo'\n\t- 实际开发中，React 与 Redux 库结合使用时，常常需要写成下面这样。\n\t- class MyReactComponent extends React.Component {}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);\n\t- 有了装饰器，就可以改写上面的代码。\n\t- @connect(mapStateToProps, mapDispatchToProps)\nexport default class MyReactComponent extends React.Component {}\n\n### 方法的修饰\n\n- 修饰器不仅可以修饰类，还可以修饰类的属性。\n\n\t- class Person {\n  @readonly\n  name() { return `${this.first} ${this.last}` }\n}\n\t- 上面代码中，修饰器readonly用来修饰“类”的name方法。\n\n修饰器函数readonly一共可以接受三个参数。\n\t- function readonly(target, name, descriptor){\n  // descriptor对象原来的值如下\n  // {\n  //   value: specifiedFunction,\n  //   enumerable: false,\n  //   configurable: true,\n  //   writable: true\n  // };\n  descriptor.writable = false;\n  return descriptor;\n}\n\nreadonly(Person.prototype, 'name', descriptor);\n// 类似于\nObject.defineProperty(Person.prototype, 'name', descriptor);\n\t- 修饰器第一个参数是类的原型对象，上例是Person.prototype，修饰器的本意是要“修饰”类的实例，但是这个时候实例还没生成，所以只能去修饰原型（这不同于类的修饰，那种情况时target参数指的是类本身）；第二个参数是所要修饰的属性名，第三个参数是该属性的描述对象。\n\t- 另外，上面代码说明，修饰器（readonly）会修改属性的描述对象（descriptor），然后被修改的描述对象再用来定义属性。\n\t- 下面是另一个例子，修改属性描述对象的enumerable属性，使得该属性不可遍历。\n\t- class Person {\n  @nonenumerable\n  get kidCount() { return this.children.length; }\n}\n\nfunction nonenumerable(target, name, descriptor) {\n  descriptor.enumerable = false;\n  return descriptor;\n}\n\t- 下面的@log修饰器，可以起到输出日志的作用。\n\t- class Math {\n  @log\n  add(a, b) {\n    return a + b;\n  }\n}\n\nfunction log(target, name, descriptor) {\n  var oldValue = descriptor.value;\n\n  descriptor.value = function() {\n    console.log(`Calling ${name} with`, arguments);\n    return oldValue.apply(this, arguments);\n  };\n\n  return descriptor;\n}\n\nconst math = new Math();\n\n// passed parameters should get logged now\nmath.add(2, 4);\n\n- 修饰器有注释的作用。\n\n\t- @testable\nclass Person {\n  @readonly\n  @nonenumerable\n  name() { return `${this.first} ${this.last}` }\n}\n\t- 从上面代码中，我们一眼就能看出，Person类是可测试的，而name方法是只读和不可枚举的。\n\t- 下面是使用 Decorator 写法的组件，看上去一目了然。\n\t- @Component({\n  tag: 'my-component',\n  styleUrl: 'my-component.scss'\n})\nexport class MyComponent {\n  @Prop() first: string;\n  @Prop() last: string;\n  @State() isVisible: boolean = true;\n\n  render() {\n    return (\n      <p>Hello, my name is {this.first} {this.last}</p>\n    );\n  }\n}\n\t- 如果同一个方法有多个修饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。\n\t- function dec(id){\n  console.log('evaluated', id);\n  return (target, property, descriptor) => console.log('executed', id);\n}\n\nclass Example {\n    @dec(1)\n    @dec(2)\n    method(){}\n}\n// evaluated 1\n// evaluated 2\n// executed 2\n// executed 1\n\t- 上面代码中，外层修饰器@dec(1)先进入，但是内层修饰器@dec(2)先执行。\n\t- 除了注释，修饰器还能用来类型检查。所以，对于类来说，这项功能相当有用。从长期来看，它将是 JavaScript 代码静态分析的重要工具。\n\n### 为什么修饰器不能用于函数\n\n- 修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。\n- var counter = 0;\n\nvar add = function () {\n  counter++;\n};\n\n@add\nfunction foo() {\n}\n- 上面的代码，意图是执行后counter等于 1，但是实际上结果是counter等于 0。因为函数提升，使得实际执行的代码是下面这样。\n- @add\nfunction foo() {\n}\n\nvar counter;\nvar add;\n\ncounter = 0;\n\nadd = function () {\n  counter++;\n};\n- 下面是另一个例子。\n- var readOnly = require(\"some-decorator\");\n\n@readOnly\nfunction foo() {\n}\n- 上面代码也有问题，因为实际执行是下面这样。\n- var readOnly;\n\n@readOnly\nfunction foo() {\n}\n\nreadOnly = require(\"some-decorator\");\n- 总之，由于存在函数提升，使得修饰器不能用于函数。类是不会提升的，所以就没有这方面的问题。\n\n另一方面，如果一定要修饰函数，可以采用高阶函数的形式直接执行。\n- function doSomething(name) {\n  console.log('Hello, ' + name);\n}\n\nfunction loggingDecorator(wrapped) {\n  return function() {\n    console.log('Starting');\n    const result = wrapped.apply(this, arguments);\n    console.log('Finished');\n    return result;\n  }\n}\n\nconst wrapped = loggingDecorator(doSomething);\n\n### core-decorators.js\n\n- core-decorators.js是一个第三方模块，提供了几个常见的修饰器，通过它可以更好地理解修饰器。\n\n\t- （1）@autobind\n\n\t\t- autobind修饰器使得方法中的this对象，绑定原始对象。\n\n\t\t\t- import { autobind } from 'core-decorators';\n\nclass Person {\n  @autobind\n  getPerson() {\n    return this;\n  }\n}\n\nlet person = new Person();\nlet getPerson = person.getPerson;\n\ngetPerson() === person;\n// true\n\n\t- （2）@readonly\n\n\t\t- readonly修饰器使得属性或方法不可写。\n\n\t\t\t- import { readonly } from 'core-decorators';\n\nclass Meal {\n  @readonly\n  entree = 'steak';\n}\n\nvar dinner = new Meal();\ndinner.entree = 'salmon';\n// Cannot assign to read only property 'entree' of [object Object]\n\n\t- （3）@override\n\n\t\t- override修饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。\n\n\t\t\t- import { override } from 'core-decorators';\n\nclass Parent {\n  speak(first, second) {}\n}\n\nclass Child extends Parent {\n  @override\n  speak() {}\n  // SyntaxError: Child#speak() does not properly override Parent#speak(first, second)\n}\n\n// or\n\nclass Child extends Parent {\n  @override\n  speaks() {}\n  // SyntaxError: No descriptor matching Child#speaks() was found on the prototype chain.\n  //\n  //   Did you mean \"speak\"?\n}\n\n\t- （4）@deprecate (别名@deprecated)\n\n\t\t- deprecate或deprecated修饰器在控制台显示一条警告，表示该方法将废除。\n\n\t\t\t- import { deprecate } from 'core-decorators';\n\nclass Person {\n  @deprecate\n  facepalm() {}\n\n  @deprecate('We stopped facepalming')\n  facepalmHard() {}\n\n  @deprecate('We stopped facepalming', { url: 'http://knowyourmeme.com/memes/facepalm' })\n  facepalmHarder() {}\n}\n\nlet person = new Person();\n\nperson.facepalm();\n// DEPRECATION Person#facepalm: This function will be removed in future versions.\n\nperson.facepalmHard();\n// DEPRECATION Person#facepalmHard: We stopped facepalming\n\nperson.facepalmHarder();\n// DEPRECATION Person#facepalmHarder: We stopped facepalming\n//\n//     See http://knowyourmeme.com/memes/facepalm for more details.\n//\n\n\t- （5）@suppressWarnings\n\n\t\t- suppressWarnings修饰器抑制deprecated修饰器导致的console.warn()调用。但是，异步代码发出的调用除外。\n\n\t\t\t- import { suppressWarnings } from 'core-decorators';\n\nclass Person {\n  @deprecated\n  facepalm() {}\n\n  @suppressWarnings\n  facepalmWithoutWarning() {\n    this.facepalm();\n  }\n}\n\nlet person = new Person();\n\nperson.facepalmWithoutWarning();\n// no warning is logged\n\n### 使用修饰器实现自动发布事件\n\n- 我们可以使用修饰器，使得对象的方法被调用时，自动发出一个事件。\n\n\t- const postal = require(\"postal/lib/postal.lodash\");\n\nexport default function publish(topic, channel) {\n  const channelName = channel || '/';\n  const msgChannel = postal.channel(channelName);\n  msgChannel.subscribe(topic, v => {\n    console.log('频道: ', channelName);\n    console.log('事件: ', topic);\n    console.log('数据: ', v);\n  });\n\n  return function(target, name, descriptor) {\n    const fn = descriptor.value;\n\n    descriptor.value = function() {\n      let value = fn.apply(this, arguments);\n      msgChannel.publish(topic, value);\n    };\n  };\n}\n\t- 上面代码定义了一个名为publish的修饰器，它通过改写descriptor.value，使得原方法被调用时，会自动发出一个事件。它使用的事件“发布/订阅”库是Postal.js。\n\t- 它的用法如下。\n\t- // index.js\nimport publish from './publish';\n\nclass FooComponent {\n  @publish('foo.some.message', 'component')\n  someMethod() {\n    return { my: 'data' };\n  }\n  @publish('foo.some.other')\n  anotherMethod() {\n    // ...\n  }\n}\n\nlet foo = new FooComponent();\n\nfoo.someMethod();\nfoo.anotherMethod();\n\t- 以后，只要调用someMethod或者anotherMethod，就会自动发出一个事件。\n\t- $ bash-node index.js\n频道:  component\n事件:  foo.some.message\n数据:  { my: 'data' }\n\n频道:  /\n事件:  foo.some.other\n数据:  undefined\n\n### Mixin \n\n- 在修饰器的基础上，可以实现Mixin模式。所谓Mixin模式，就是对象继承的一种替代方案，中文译为“混入”（mix in），意为在一个对象之中混入另外一个对象的方法。\n\n\t- 请看下面的例子。\n\n\t\t- const Foo = {\n  foo() { console.log('foo') }\n};\n\nclass MyClass {}\n\nObject.assign(MyClass.prototype, Foo);\n\nlet obj = new MyClass();\nobj.foo() // 'foo'\n\t\t- 上面代码之中，对象Foo有一个foo方法，通过Object.assign方法，可以将foo方法“混入”MyClass类，导致MyClass的实例obj对象都具有foo方法。这就是“混入”模式的一个简单实现。\n\n\t- 下面，我们部署一个通用脚本mixins.js，将 Mixin 写成一个修饰器。\n\n\t\t- export function mixins(...list) {\n  return function (target) {\n    Object.assign(target.prototype, ...list);\n  };\n}\n\t\t- 然后，就可以使用上面这个修饰器，为类“混入”各种方法。\n\t\t- import { mixins } from './mixins';\n\nconst Foo = {\n  foo() { console.log('foo') }\n};\n\n@mixins(Foo)\nclass MyClass {}\n\nlet obj = new MyClass();\nobj.foo() // \"foo\"\n\t\t- 通过mixins这个修饰器，实现了在MyClass类上面“混入”Foo对象的foo方法。\n\t\t- 不过，上面的方法会改写MyClass类的prototype对象，如果不喜欢这一点，也可以通过类的继承实现 Mixin。\n\t\t- class MyClass extends MyBaseClass {\n  /* ... */\n}\n\t\t- 上面代码中，MyClass继承了MyBaseClass。如果我们想在MyClass里面“混入”一个foo方法，一个办法是在MyClass和MyBaseClass之间插入一个混入类，这个类具有foo方法，并且继承了MyBaseClass的所有方法，然后MyClass再继承这个类。\n\t\t- let MyMixin = (superclass) => class extends superclass {\n  foo() {\n    console.log('foo from MyMixin');\n  }\n};\n\t\t- 上面代码中，MyMixin是一个混入类生成器，接受superclass作为参数，然后返回一个继承superclass的子类，该子类包含一个foo方法。\n\t\t- 接着，目标类再去继承这个混入类，就达到了“混入”foo方法的目的。\n\t\t- class MyClass extends MyMixin(MyBaseClass) {\n  /* ... */\n}\n\nlet c = new MyClass();\nc.foo(); // \"foo from MyMixin\"\n\t\t- 如果需要“混入”多个方法，就生成多个混入类。\n\t\t- class MyClass extends Mixin1(Mixin2(MyBaseClass)) {\n  /* ... */\n}\n\t\t- 这种写法的一个好处，是可以调用super，因此可以避免在“混入”过程中覆盖父类的同名方法\n\n\t\t\t- let Mixin1 = (superclass) => class extends superclass {\n  foo() {\n    console.log('foo from Mixin1');\n    if (super.foo) super.foo();\n  }\n};\n\nlet Mixin2 = (superclass) => class extends superclass {\n  foo() {\n    console.log('foo from Mixin2');\n    if (super.foo) super.foo();\n  }\n};\n\nclass S {\n  foo() {\n    console.log('foo from S');\n  }\n}\n\nclass C extends Mixin1(Mixin2(S)) {\n  foo() {\n    console.log('foo from C');\n    super.foo();\n  }\n}\n\t\t\t- 上面代码中，每一次混入发生时，都调用了父类的super.foo方法，导致父类的同名方法没有被覆盖，行为被保留了下来。\n\t\t\t- new C().foo()\n// foo from C\n// foo from Mixin1\n// foo from Mixin2\n// foo from S\n\n### Trait\n\n- Trait 也是一种修饰器，效果与 Mixin 类似，但是提供更多功能，比如防止同名方法的冲突、排除混入某些方法、为混入的方法起别名等等。\n\n下面采用traits-decorator这个第三方模块作为例子。这个模块提供的traits修饰器，不仅可以接受对象，还可以接受 ES6 类作为参数。\n\n\t- import { traits } from 'traits-decorator';\n\nclass TFoo {\n  foo() { console.log('foo') }\n}\n\nconst TBar = {\n  bar() { console.log('bar') }\n};\n\n@traits(TFoo, TBar)\nclass MyClass { }\n\nlet obj = new MyClass();\nobj.foo() // foo\nobj.bar() // bar\n\t- 上面代码中，通过traits修饰器，在MyClass类上面“混入”了TFoo类的foo方法和TBar对象的bar方法。\n\n- Trait 不允许“混入”同名方法。\n\n\t- import { traits } from 'traits-decorator';\n\nclass TFoo {\n  foo() { console.log('foo') }\n}\n\nconst TBar = {\n  bar() { console.log('bar') },\n  foo() { console.log('foo') }\n};\n\n@traits(TFoo, TBar)\nclass MyClass { }\n// 报错\n// throw new Error('Method named: ' + methodName + ' is defined twice.');\n//        ^\n// Error: Method named: foo is defined twice.\n\t- 上面代码中，TFoo和TBar都有foo方法，结果traits修饰器报错。\n\t- 一种解决方法是排除TBar的foo方法。\n\t- import { traits, excludes } from 'traits-decorator';\n\nclass TFoo {\n  foo() { console.log('foo') }\n}\n\nconst TBar = {\n  bar() { console.log('bar') },\n  foo() { console.log('foo') }\n};\n\n@traits(TFoo, TBar::excludes('foo'))\nclass MyClass { }\n\nlet obj = new MyClass();\nobj.foo() // foo\nobj.bar() // bar\n\t- 上面代码使用绑定运算符（::）在TBar上排除foo方法，混入时就不会报错了。\n\t- 另一种方法是为TBar的foo方法起一个别名。\n\t- import { traits, alias } from 'traits-decorator';\n\nclass TFoo {\n  foo() { console.log('foo') }\n}\n\nconst TBar = {\n  bar() { console.log('bar') },\n  foo() { console.log('foo') }\n};\n\n@traits(TFoo, TBar::alias({foo: 'aliasFoo'}))\nclass MyClass { }\n\nlet obj = new MyClass();\nobj.foo() // foo\nobj.aliasFoo() // foo\nobj.bar() // bar\n\t- alias和excludes方法，可以结合起来使用。\n\t- @traits(TExample::excludes('foo','bar')::alias({baz:'exampleBaz'}))\nclass MyClass {}\n\n### Babel 转码器的支持\n\n- 目前，Babel 转码器已经支持 Decorator。\n\n\t- 首先，安装babel-core和babel-plugin-transform-decorators。由于后者包括在babel-preset-stage-0之中，所以改为安装babel-preset-stage-0亦可。\n\t- $ npm install babel-core babel-plugin-transform-decorators\n\t- 然后，设置配置文件.babelrc。\n\t- {\n  \"plugins\": [\"transform-decorators\"]\n}\n\t- 这时，Babel 就可以对 Decorator 转码了。\n\n## Module 的语法\n\n### 概述\n\n- 历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。\n\n在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。\n\nES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。\n- // CommonJS模块\nlet { stat, exists, readFile } = require('fs');\n\n// 等同于\nlet _fs = require('fs');\nlet stat = _fs.stat;\nlet exists = _fs.exists;\nlet readfile = _fs.readfile;\n- 上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。\n- ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。\n- // ES6模块\nimport { stat, exists, readFile } from 'fs';\n- 上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。\n- 由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。\n- 除了静态加载带来的各种好处，ES6 模块还有以下好处。\n\n\t- 不再需要UMD模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。\n\t- 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性。\n\t- 不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。\n\n### 严格模式\n\n- ES6 的模块自动采用严格模式，不管你有没有在模块头部加上\"use strict\";。\n- 严格模式主要有以下限制。\n\n\t- 变量必须声明后再使用\n\t- 函数的参数不能有同名属性，否则报错\n\t- 不能使用with语句\n\t- 不能对只读属性赋值，否则报错\n\t- 不能使用前缀 0 表示八进制数，否则报错\n\t- 不能删除不可删除的属性，否则报错\n\t- 不能删除变量delete prop，会报错，只能删除属性delete global[prop]\n\t- eval不会在它的外层作用域引入变量\n\t- eval和arguments不能被重新赋值\n\t- arguments不会自动反映函数参数的变化\n\t- 不能使用arguments.callee\n\t- 不能使用arguments.caller\n\t- 禁止this指向全局对象\n\t- 不能使用fn.caller和fn.arguments获取函数调用的堆栈\n\t- 增加了保留字（比如protected、static和interface）\n\n### export 命令\n\n- 模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。\n- 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个 JS 文件，里面使用export命令输出变量。\n- // profile.js\nexport var firstName = 'Michael';\nexport var lastName = 'Jackson';\nexport var year = 1958;\n- 上面代码是profile.js文件，保存了用户信息。ES6 将其视为一个模块，里面用export命令对外部输出了三个变量。\n- export的写法，除了像上面这样，还有另外一种。\n- // profile.js\nvar firstName = 'Michael';\nvar lastName = 'Jackson';\nvar year = 1958;\n\nexport {firstName, lastName, year};\n- 上面代码在export命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在var语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。\n- export命令除了输出变量，还可以输出函数或类（class）。\n\n\t- export function multiply(x, y) {\n  return x * y;\n};\n\t- 上面代码对外输出一个函数multiply。\n\n- 通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。\n\n\t- function v1() { ... }\nfunction v2() { ... }\n\nexport {\n  v1 as streamV1,\n  v2 as streamV2,\n  v2 as streamLatestVersion\n};\n\t- 上面代码使用as关键字，重命名了函数v1和v2的对外接口。重命名后，v2可以用不同的名字输出两次。\n\n- 需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。\n\n\t- // 报错\nexport 1;\n\n// 报错\nvar m = 1;\nexport m;\n\t- 上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量m，还是直接输出 1。1只是一个值，不是接口。正确的写法是下面这样。\n\t- // 写法一\nexport var m = 1;\n\n// 写法二\nvar m = 1;\nexport {m};\n\n// 写法三\nvar n = 1;\nexport {n as m};\n\t- 上面三种写法都是正确的，规定了对外的接口m。其他脚本可以通过这个接口，取到值1。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。\n\t- 同样的，function和class的输出，也必须遵守这样的写法。\n\t- // 报错\nfunction f() {}\nexport f;\n\n// 正确\nexport function f() {};\n\n// 正确\nfunction f() {}\nexport {f};\n\t- 另外，export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。\n\t- export var foo = 'bar';\nsetTimeout(() => foo = 'baz', 500);\n\t- 这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新\n\t- 最后，export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的import命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。\n\t- function foo() {\n  export default 'bar' // SyntaxError\n}\nfoo()\n\t- 上面代码中，export语句放在函数之中，结果报错。\n\n### import 命令\n\n- 使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。\n\n\t- // main.js\nimport {firstName, lastName, year} from './profile.js';\n\nfunction setName(element) {\n  element.textContent = firstName + ' ' + lastName;\n}\n\t- 上面代码的import命令，用于加载profile.js文件，并从中输入变量。import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。\n\t- 如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。\n\t- import { lastName as surname } from './profile.js';\n\t- import命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。\n\t- import {a} from './xxx.js'\n\na = {}; // Syntax Error : 'a' is read-only;\n\t- 上面代码中，脚本加载了变量a，对其重新赋值就会报错，因为a是一个只读的接口。但是，如果a是一个对象，改写a的属性是允许的。\n\t- import {a} from './xxx.js'\n\na.foo = 'hello'; // 合法操作\n\t- 上面代码中，a的属性可以成功改写，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，轻易不要改变它的属性。\n\t- import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。\n\t- import {myMethod} from 'util';\n\t- 上面代码中，util是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。\n\t- 注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。\n\t- foo();\n\nimport { foo } from 'my_module';\n\t- 上面的代码不会报错，因为import的执行早于foo的调用。这种行为的本质是，import命令是编译阶段执行的，在代码运行之前。\n\t- 由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。\n\t- // 报错\nimport { 'f' + 'oo' } from 'my_module';\n\n// 报错\nlet module = 'my_module';\nimport { foo } from module;\n\n// 报错\nif (x === 1) {\n  import { foo } from 'module1';\n} else {\n  import { foo } from 'module2';\n}\n\t- 上面三种写法都会报错，因为它们用到了表达式、变量和if结构。在静态分析阶段，这些语法都是没法得到值的。\n\n- 最后，import语句会执行所加载的模块，因此可以有下面的写法。\n\n\t- import 'lodash';\n\t- 上面代码仅仅执行lodash模块，但是不输入任何值。\n\t- 如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。\n\t- import 'lodash';\nimport 'lodash';\n\t- 上面代码加载了两次lodash，但是只会执行一次。\n\t- import { foo } from 'my_module';\nimport { bar } from 'my_module';\n\n// 等同于\nimport { foo, bar } from 'my_module';\n\t- 上面代码中，虽然foo和bar在两个语句中加载，但是它们对应的是同一个my_module实例。也就是说，import语句是 Singleton 模式。\n\n目前阶段，通过 Babel 转码，CommonJS 模块的require命令和 ES6 模块的import命令，可以写在同一个模块里面，但是最好不要这样做。因为import在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。\n\n### 模块的整体加载\n\n- 除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。\n\n\t- 下面是一个circle.js文件，它输出两个方法area和circumference。\n\n\t\t- // circle.js\n\nexport function area(radius) {\n  return Math.PI * radius * radius;\n}\n\nexport function circumference(radius) {\n  return 2 * Math.PI * radius;\n}\n\t\t- 现在，加载这个模块。\n\t\t- // main.js\n\nimport { area, circumference } from './circle';\n\nconsole.log('圆面积：' + area(4));\nconsole.log('圆周长：' + circumference(14));\n\t\t- 上面写法是逐一指定要加载的方法，整体加载的写法如下。\n\t\t- import * as circle from './circle';\n\nconsole.log('圆面积：' + circle.area(4));\nconsole.log('圆周长：' + circle.circumference(14));\n\t\t- 注意，模块整体加载所在的那个对象（上例是circle），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。\n\t\t- import * as circle from './circle';\n\n// 下面两行都是不允许的\ncircle.foo = 'hello';\ncircle.area = function () {};\n\n### export default 命令\n\n- 从前面的例子可以看出，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。\n为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。\n- // export-default.js\nexport default function () {\n  console.log('foo');\n}\n- 上面代码是一个模块文件export-default.js，它的默认输出是一个函数。\n- 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。\n- // import-default.js\nimport customName from './export-default';\ncustomName(); // 'foo'\n- 上面代码的import命令，可以用任意名称指向export-default.js输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时import命令后面，不使用大括号。\n- export default命令用在非匿名函数前，也是可以的。\n\n\t- // export-default.js\nexport default function foo() {\n  console.log('foo');\n}\n\n// 或者写成\n\nfunction foo() {\n  console.log('foo');\n}\n\nexport default foo;\n\t- 上面代码中，foo函数的函数名foo，在模块外部是无效的。加载的时候，视同匿名函数加载。\n\n- 下面比较一下默认输出和正常输出。\n\n\t- // 第一组\nexport default function crc32() { // 输出\n  // ...\n}\n\nimport crc32 from 'crc32'; // 输入\n\n// 第二组\nexport function crc32() { // 输出\n  // ...\n};\n\nimport {crc32} from 'crc32'; // 输入\n\t- 上面代码的两组写法，第一组是使用export default时，对应的import语句不需要使用大括号；第二组是不使用export default时，对应的import语句需要使用大括号。\n\t- export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应export default命令。\n\t- 本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。\n\t- // modules.js\nfunction add(x, y) {\n  return x * y;\n}\nexport {add as default};\n// 等同于\n// export default add;\n\n// app.js\nimport { default as foo } from 'modules';\n// 等同于\n// import foo from 'modules';\n\n### export 与 import 的复合写法\n\n- 如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。\n\n\t- export { foo, bar } from 'my_module';\n\n// 可以简单理解为\nimport { foo, bar } from 'my_module';\nexport { foo, bar };\n\t- 上面代码中，export和import语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，foo和bar实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用foo和bar。\n\t- 模块的接口改名和整体输出，也可以采用这种写法。\n\n\t\t- // 接口改名\nexport { foo as myFoo } from 'my_module';\n\n// 整体输出\nexport * from 'my_module';\n\n\t- 默认接口的写法如下。\n\n\t\t- export { default } from 'foo';\n\n\t- 具名接口改为默认接口的写法如下。\n\n\t\t- export { es6 as default } from './someModule';\n\n// 等同于\nimport { es6 } from './someModule';\nexport default es6;\n\n\t- 同样地，默认接口也可以改名为具名接口。\n\n\t\t- export { default as es6 } from './someModule';\n\n\t- 下面三种import语句，没有对应的复合写法。\n\n\t\t- import * as someIdentifier from \"someModule\";\nimport someIdentifier from \"someModule\";\nimport someIdentifier, { namedIdentifier } from \"someModule\";\n\n\t\t- 为了做到形式的对称，现在有提案，提出补上这三种复合写法。\n\t\t- export * as someIdentifier from \"someModule\";\nexport someIdentifier from \"someModule\";\nexport someIdentifier, { namedIdentifier } from \"someModule\";\n\n### 模块的继承\n\n- 模块之间也可以继承。\n\n\t- 假设有一个circleplus模块，继承了circle模块。\n\n\t\t- // circleplus.js\n\nexport * from 'circle';\nexport var e = 2.71828182846;\nexport default function(x) {\n  return Math.exp(x);\n}\n\t\t- 上面代码中的export *，表示再输出circle模块的所有属性和方法。注意，export *命令会忽略circle模块的default方法。然后，上面代码又输出了自定义的e变量和默认方法。\n\n这时，也可以将circle的属性或方法，改名后再输出。\n\t\t- // circleplus.js\n\nexport { area as circleArea } from 'circle';\n\t\t- 上面代码表示，只输出circle模块的area方法，且将其改名为circleArea。\n\n加载上面模块的写法如下。\n\t\t- // main.js\n\nimport * as math from 'circleplus';\nimport exp from 'circleplus';\nconsole.log(exp(math.e));\n\n\t\t- 上面代码中的import exp表示，将circleplus模块的默认方法加载为exp方法。\n\n### 跨模块常量\n\n- 本书介绍const命令的时候说过，const声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。\n\n\t- // constants.js 模块\nexport const A = 1;\nexport const B = 3;\nexport const C = 4;\n\n// test1.js 模块\nimport * as constants from './constants';\nconsole.log(constants.A); // 1\nconsole.log(constants.B); // 3\n\n// test2.js 模块\nimport {A, B} from './constants';\nconsole.log(A); // 1\nconsole.log(B); // 3\n\n- 如果要使用的常量非常多，可以建一个专门的constants目录，将各种常量写在不同的文件里面，保存在该目录下。\n\n\t- // constants/db.js\nexport const db = {\n  url: 'http://my.couchdbserver.local:5984',\n  admin_username: 'admin',\n  admin_password: 'admin password'\n};\n\n// constants/user.js\nexport const users = ['root', 'admin', 'staff', 'ceo', 'chief', 'moderator'];\n\t- 然后，将这些文件输出的常量，合并在index.js里面。\n\t- // constants/index.js\nexport {db} from './db';\nexport {users} from './users';\n\t- 使用的时候，直接加载index.js就可以了。\n\t- // script.js\nimport {db, users} from './constants/index';\n\n### import()\n\n- 简介\n\n\t- 前面介绍过，import命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（import命令叫做“连接” binding 其实更合适）。所以，下面的代码会报错。\n\n// 报错\nif (x === 2) {\n  import MyModual from './myModual';\n}\n上面代码中，引擎处理import语句是在编译时，这时不会去分析或执行if语句，所以import语句放在if代码块之中毫无意义，因此会报句法错误，而不是执行时错误。也就是说，import和export命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中）。\n\n这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果import命令要取代 Node 的require方法，这就形成了一个障碍。因为require是运行时加载模块，import命令无法取代require的动态加载功能。\n\nconst path = './' + fileName;\nconst myModual = require(path);\n上面的语句就是动态加载，require到底加载哪一个模块，只有运行时才知道。import命令做不到这一点。\n\t- 因此，有一个提案，建议引入import()函数，完成动态加载。\n\n\t\t- import(specifier)\n\t\t- 上面代码中，import函数的参数specifier，指定所要加载的模块的位置。import命令能够接受什么参数，import()函数就能接受什么参数，两者区别主要是后者为动态加载。\n\nimport()返回一个 Promise 对象。下面是一个例子。\n\t\t- const main = document.querySelector('main');\n\nimport(`./section-modules/${someVariable}.js`)\n  .then(module => {\n    module.loadPageInto(main);\n  })\n  .catch(err => {\n    main.textContent = err.message;\n  });\n\t\t- import()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，import()函数与所加载的模块没有静态连接关系，这点也是与import语句不相同。import()类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载。\n\t\t- 适用场合\n\n\t\t\t- （1）按需加载。\n\n\t\t\t\t- import()可以在需要的时候，再加载某个模块。\n\n\t\t\t\t\t- button.addEventListener('click', event => {\n  import('./dialogBox.js')\n  .then(dialogBox => {\n    dialogBox.open();\n  })\n  .catch(error => {\n    /* Error handling */\n  })\n});\n\t\t\t\t\t- 上面代码中，import()方法放在click事件的监听函数之中，只有用户点击了按钮，才会加载这个模块\n\n\t\t\t- （2）条件加载\n\n\t\t\t\t- import()可以放在if代码块，根据不同的情况，加载不同的模块。\n\n\t\t\t\t\t- if (condition) {\n  import('moduleA').then(...);\n} else {\n  import('moduleB').then(...);\n}\n\t\t\t\t\t- 上面代码中，如果满足条件，就加载模块 A，否则加载模块 B。\n\n\t\t\t- 3）动态的模块路径\n\n\t\t\t\t- import()允许模块路径动态生成。\n\n\t\t\t\t\t- import(f())\n.then(...);\n\t\t\t\t\t- 上面代码中，根据函数f的返回结果，加载不同的模块。\n\n\t\t- 注意点\n\n\t\t\t- import()加载模块成功以后，这个模块会作为一个对象，当作then方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口。\n\n\t\t\t\t- import('./myModule.js')\n.then(({export1, export2}) => {\n  // ...·\n});\n\t\t\t\t- 上面代码中，export1和export2都是myModule.js的输出接口，可以解构获得。\n\n\t\t\t- 如果模块有default输出接口，可以用参数直接获得。\n\n\t\t\t\t- import('./myModule.js')\n.then(myModule => {\n  console.log(myModule.default);\n});\n\t\t\t\t- 上面的代码也可以使用具名输入的形式。\n\t\t\t\t- import('./myModule.js')\n.then(({default: theDefault}) => {\n  console.log(theDefault);\n});\n\t\t\t\t- 如果想同时加载多个模块，可以采用下面的写法。\n\t\t\t\t- Promise.all([\n  import('./module1.js'),\n  import('./module2.js'),\n  import('./module3.js'),\n])\n.then(([module1, module2, module3]) => {\n   ···\n});\n\t\t\t\t- import()也可以用在 async 函数之中。\n\t\t\t\t- async function main() {\n  const myModule = await import('./myModule.js');\n  const {export1, export2} = await import('./myModule.js');\n  const [module1, module2, module3] =\n    await Promise.all([\n      import('./module1.js'),\n      import('./module2.js'),\n      import('./module3.js'),\n    ]);\n}\nmain();\n\n- 自由主题\n\n- 自由主题\n\n- 自由主题\n\n## Module 的加载实现\n\n### 浏览器加载\n\n- 传统方法 \n\n\t- HTML 网页中，浏览器通过script标签加载 JavaScript 脚本。\n\n\t\t- \x3c!-- 页面内嵌的脚本 --\x3e\n&lt;script type=\"application/javascript\">\n  // module code\n&lt;/script&amp;gt; 标签加载\n\n\x3c!-- 外部脚本 --\x3e\n&lt;script type=\"application/javascript\" src=\"path/to/myModule.js\">\n&lt;/script&amp;gt;\n\t\t- 上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此type=\"application/javascript\"可以省略。\n\n\t\t\t- 默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到&lt;script&gt;标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。\n\n如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。\n\t\t\t- &lt;script src=\"path/to/myModule.js\" defer>&lt;/script&amp;gt;\n&lt;script src=\"path/to/myModule.js\" async>&lt;/script&amp;gt;\n\t\t\t- 上面代码中，&lt;script&gt;标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。\n\ndefer与async的区别是：defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。\n\n- 加载规则\n\n\t- 浏览器加载 ES6 模块，也使用&lt;script&gt;标签，但是要加入type=\"module\"属性。\n\n\t\t- &lt;script type=\"module\" src=\"./foo.js\">&lt;/script&amp;gt;\n\t\t- 上面代码在网页中插入一个模块foo.js，由于type属性设为module，所以浏览器知道这是一个 ES6 模块\n\t\t- 浏览器对于带有type=\"module\"的&lt;script&gt;，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了&lt;script&gt;标签的defer属性。\n\t\t- &lt;script type=\"module\" src=\"./foo.js\">&lt;/script&amp;gt;\n\x3c!-- 等同于 --\x3e\n&lt;script type=\"module\" src=\"./foo.js\" defer>&lt;/script&amp;gt;\n\t\t- 如果网页有多个&lt;script type=\"module\">，它们会按照在页面出现的顺序依次执行。\n\t\t- &lt;script&gt;标签的async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。\n\t\t- &lt;script type=\"module\" src=\"./foo.js\" async>&lt;/script&amp;gt;\n\t\t- 一旦使用了async属性，&lt;script type=\"module\">就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。\n\t\t- ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。\n\t\t- &lt;script type=\"module\">\n  import utils from \"./utils.js\";\n\n  // other code\n&lt;/script&amp;gt;\n\t\t- 对于外部的模块脚本（上例是foo.js），有几点需要注意。\n\n\t\t\t- 代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。\n\t\t\t- 模块脚本自动采用严格模式，不管有没有声明use strict。\n\t\t\t- 模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。\n\t\t\t- 模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。\n\t\t\t- 同一个模块如果加载多次，将只执行一次。\n\n\t\t- 下面是一个示例模块。\n\n\t\t\t- import utils from 'https://example.com/js/utils.js';\n\nconst x = 1;\n\nconsole.log(x === window.x); //false\nconsole.log(this === undefined); // true\n\t\t\t- 利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中。\n\t\t\t- const isNotModuleScript = this !== undefined;\n\n### ES6 模块与 CommonJS 模块的差异\n\n- ES6 模块与 CommonJS 模块有两个重大差异。\n\n\t- CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。\n\t- CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。\n\n- 第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。\n- 下面重点解释第一个差异。\n\n\t- CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件lib.js的例子。\n\n\t\t- // lib.js\nvar counter = 3;\nfunction incCounter() {\n  counter++;\n}\nmodule.exports = {\n  counter: counter,\n  incCounter: incCounter,\n};\n\t\t- 上面代码输出内部变量counter和改写这个变量的内部方法incCounter。然后，在main.js里面加载这个模块。\n\t\t- // main.js\nvar mod = require('./lib');\n\nconsole.log(mod.counter);  // 3\nmod.incCounter();\nconsole.log(mod.counter); // 3\n\t\t- 上面代码说明，lib.js模块加载以后，它的内部变化就影响不到输出的mod.counter了。这是因为mod.counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。\n\t\t- // lib.js\nvar counter = 3;\nfunction incCounter() {\n  counter++;\n}\nmodule.exports = {\n  get counter() {\n    return counter\n  },\n  incCounter: incCounter,\n};\n\t\t- 上面代码中，输出的counter属性实际上是一个取值器函数。现在再执行main.js，就可以正确读取内部变量counter的变动了。\n\t\t- $ node main.js\n3\n4\n\n\t- ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。\n\n\t\t- 还是举上面的例子。\n\n\t\t\t- // lib.js\nexport let counter = 3;\nexport function incCounter() {\n  counter++;\n}\n\n// main.js\nimport { counter, incCounter } from './lib';\nconsole.log(counter); // 3\nincCounter();\nconsole.log(counter); // 4\n\t\t\t- 上面代码说明，ES6 模块输入的变量counter是活的，完全反应其所在模块lib.js内部的变化。\n\n\t\t- 再举一个出现在export一节中的例子。\n\n\t\t\t- // m1.js\nexport var foo = 'bar';\nsetTimeout(() => foo = 'baz', 500);\n\n// m2.js\nimport {foo} from './m1.js';\nconsole.log(foo);\nsetTimeout(() => console.log(foo), 500);\n\t\t\t- 上面代码中，m1.js的变量foo，在刚加载时等于bar，过了 500 毫秒，又变为等于baz。\n\t\t\t- 让我们看看，m2.js能否正确读取这个变化。\n\t\t\t- $ babel-node m2.js\n\nbar\nbaz\n\t\t\t- 上面代码表明，ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。\n\n\t\t- 由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。\n\n\t\t\t- // lib.js\nexport let obj = {};\n\n// main.js\nimport { obj } from './lib';\n\nobj.prop = 123; // OK\nobj = {}; // TypeError\n\t\t\t- 上面代码中，main.js从lib.js输入变量obj，可以对obj添加属性，但是重新赋值就会报错。因为变量obj指向的地址是只读的，不能重新赋值，这就好比main.js创造了一个名为obj的const变量。\n\t\t\t- 最后，export通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。\n\t\t\t- // mod.js\nfunction C() {\n  this.sum = 0;\n  this.add = function () {\n    this.sum += 1;\n  };\n  this.show = function () {\n    console.log(this.sum);\n  };\n}\n\nexport let c = new C();\n\t\t\t- 上面的脚本mod.js，输出的是一个C的实例。不同的脚本加载这个模块，得到的都是同一个实例。\n\t\t\t- // x.js\nimport {c} from './mod';\nc.add();\n\n// y.js\nimport {c} from './mod';\nc.show();\n\n// main.js\nimport './x';\nimport './y';\n\t\t\t- 现在执行main.js，输出的是1。\n\t\t\t- $ babel-node main.js\n1\n\t\t\t- 这就证明了x.js和y.js加载的都是C的同一个实例。\n\n### Node 加载\n\n- 概述\n\n\t- Node 对 ES6 模块的处理比较麻烦，因为它有自己的 CommonJS 模块格式，与 ES6 模块格式是不兼容的。目前的解决方案是，将两者分开，ES6 模块和 CommonJS 采用各自的加载方案。\n\nNode 要求 ES6 模块采用.mjs后缀文件名。也就是说，只要脚本文件里面使用import或者export命令，那么就必须采用.mjs后缀名。require命令不能加载.mjs文件，会报错，只有import命令才可以加载.mjs文件。反过来，.mjs文件里面也不能使用require命令，必须使用import。\n\n目前，这项功能还在试验阶段。安装 Node v8.5.0 或以上版本，要用--experimental-modules参数才能打开该功能。\n\t- $ node --experimental-modules my-app.mjs\n\t- 为了与浏览器的import加载规则相同，Node 的.mjs文件支持 URL 路径。\n\t- import './foo?query=1'; // 加载 ./foo 传入参数 ?query=1\n\t- 上面代码中，脚本路径带有参数?query=1，Node 会按 URL 规则解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有:、%、#、?等特殊字符，最好对这些字符进行转义。\n\n目前，Node 的import命令只支持加载本地模块（file:协议），不支持加载远程模块。\n\t- 如果模块名不含路径，那么import命令会去node_modules目录寻找这个模块。\n\t- import 'baz';\nimport 'abc/123';\n\t- 如果模块名包含路径，那么import命令会按照路径去寻找这个名字的脚本文件。\n\t- import 'file:///etc/config/app.json';\nimport './foo';\nimport './foo?search';\nimport '../bar';\nimport '/baz';\n\t- 如果脚本文件省略了后缀名，比如import './foo'，Node 会依次尝试四个后缀名：./foo.mjs、./foo.js、./foo.json、./foo.node。如果这些脚本文件都不存在，Node 就会去加载./foo/package.json的main字段指定的脚本。如果./foo/package.json不存在或者没有main字段，那么就会依次加载./foo/index.mjs、./foo/index.js、./foo/index.json、./foo/index.node。如果以上四个文件还是都不存在，就会抛出错误。\n\n最后，Node 的import命令是异步加载，这一点与浏览器的处理方法相同。\n\n- 内部变量 \n\n\t- ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。\n\n\t\t- 首先，就是this关键字。ES6 模块之中，顶层的this指向undefined；CommonJS 模块的顶层this指向当前模块，这是两者的一个重大差异。\n\t\t- 其次，以下这些顶层变量在 ES6 模块之中都是不存在的。\n\n\t\t\t- arguments\n\t\t\t- require\n\t\t\t- module\n\t\t\t- exports\n\t\t\t- __filename\n\t\t\t- __dirname\n\n\t\t- 如果你一定要使用这些变量，有一个变通方法，就是写一个 CommonJS 模块输出这些变量，然后再用 ES6 模块加载这个 CommonJS 模块。但是这样一来，该 ES6 模块就不能直接用于浏览器环境了，所以不推荐这样做。\n\n\t\t\t- // expose.js\nmodule.exports = {__dirname};\n\n// use.mjs\nimport expose from './expose.js';\nconst {__dirname} = expose;\n\t\t\t- 上面代码中，expose.js是一个 CommonJS 模块，输出变量__dirname，该变量在 ES6 模块之中不存在。ES6 模块加载expose.js，就可以得到__dirname。\n\n- ES6 模块加载 CommonJS 模块\n\n\t- CommonJS 模块的输出都定义在module.exports这个属性上面。Node 的import命令加载 CommonJS 模块，Node 会自动将module.exports属性，当作模块的默认输出，即等同于export default xxx。\n\n\t\t- 下面是一个 CommonJS 模块。\n\n\t\t\t- // a.js\nmodule.exports = {\n  foo: 'hello',\n  bar: 'world'\n};\n\n// 等同于\nexport default {\n  foo: 'hello',\n  bar: 'world'\n};\n\t\t\t- import命令加载上面的模块，module.exports会被视为默认输出，即import命令实际上输入的是这样一个对象{ default: module.exports }。\n\t\t\t- 所以，一共有三种写法，可以拿到 CommonJS 模块的module.exports。\n\t\t\t- // 写法一\nimport baz from './a';\n// baz = {foo: 'hello', bar: 'world'};\n\n// 写法二\nimport {default as baz} from './a';\n// baz = {foo: 'hello', bar: 'world'};\n\n// 写法三\nimport * as baz from './a';\n// baz = {\n//   get default() {return module.exports;},\n//   get foo() {return this.default.foo}.bind(baz),\n//   get bar() {return this.default.bar}.bind(baz)\n// }\n\t\t\t- 上面代码的第三种写法，可以通过baz.default拿到module.exports。foo属性和bar属性就是可以通过这种方法拿到了module.exports。\n\n\t\t- 下面是一些例子\n\n\t\t\t- // b.js\nmodule.exports = null;\n\n// es.js\nimport foo from './b';\n// foo = null;\n\nimport * as bar from './b';\n// bar = { default:null };\n\n\t\t\t\t- 上面代码中，es.js采用第二种写法时，要通过bar.default这样的写法，才能拿到module.exports。\n\n\t\t\t- // c.js\nmodule.exports = function two() {\n  return 2;\n};\n\n// es.js\nimport foo from './c';\nfoo(); // 2\n\nimport * as bar from './c';\nbar.default(); // 2\nbar(); // throws, bar is not a function\n\n\t\t\t\t- 上面代码中，bar本身是一个对象，不能当作函数调用，只能通过bar.default调用。\n\n\t\t\t- CommonJS 模块的输出缓存机制，在 ES6 加载方式下依然有效。\n\n\t\t\t\t- // foo.js\nmodule.exports = 123;\nsetTimeout(_ => module.exports = null);\n\n\t\t\t\t\t- 上面代码中，对于加载foo.js的脚本，module.exports将一直是123，而不会变成null。\n\n\t\t\t- 由于 ES6 模块是编译时确定输出接口，CommonJS 模块是运行时确定输出接口，所以采用import命令加载 CommonJS 模块时，不允许采用下面的写法。\n\n\t\t\t\t- // 不正确\nimport { readFile } from 'fs';\n\n\t\t\t\t\t- 上面的写法不正确，因为fs是 CommonJS 格式，只有在运行时才能确定readFile接口，而import命令要求编译时就确定这个接口。解决方法就是改为整体输入。\n\t\t\t\t\t- // 正确的写法一\nimport * as express from 'express';\nconst app = express.default();\n\n// 正确的写法二\nimport express from 'express';\nconst app = express();\n\n- CommonJS 模块加载 ES6 模块\n\n\t- CommonJS 模块加载 ES6 模块，不能使用require命令，而要使用import()函数。ES6 模块的所有输出接口，会成为输入对象的属性。\n\n\t\t- // es.mjs\nlet foo = { bar: 'my-default' };\nexport default foo;\n\n// cjs.js\nconst es_namespace = await import('./es.mjs');\n// es_namespace = {\n//   get default() {\n//     ...\n//   }\n// }\nconsole.log(es_namespace.default);\n// { bar:'my-default' }\n\t\t- 上面代码中，default接口变成了es_namespace.default属性。\n\t\t- 下面是另一个例子。\n\t\t- // es.js\nexport let foo = { bar:'my-default' };\nexport { foo as bar };\nexport function f() {};\nexport class c {};\n\n// cjs.js\nconst es_namespace = await import('./es');\n// es_namespace = {\n//   get foo() {return foo;}\n//   get bar() {return foo;}\n//   get f() {return f;}\n//   get c() {return c;}\n// }\n\n### 循环加载\n\n- “循环加载”（circular dependency）指的是，a脚本的执行依赖b脚本，而b脚本的执行又依赖a脚本。\n\n\t- // a.js\nvar b = require('b');\n\n// b.js\nvar a = require('a');\n\t- 通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。\n\n但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现a依赖b，b依赖c，c又依赖a这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。\n\n对于 JavaScript 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。\n\n- CommonJS 模块的加载原理\n\n\t- CommonJS 的一个模块，就是一个脚本文件。require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。\n\n\t\t- {\n  id: '...',\n  exports: { ... },\n  loaded: true,\n  ...\n}\n\t\t- 上面代码就是 Node 内部加载模块后生成的一个对象。该对象的id属性是模块名，exports属性是模块输出的各个接口，loaded属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。\n\t\t- 以后需要用到这个模块的时候，就会到exports属性上面取值。即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。\n\n- CommonJS 模块的循环加载\n\n\t- CommonJS 模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被\"循环加载\"，就只输出已经执行的部分，还未执行的部分不会输出\n\n\t\t- 让我们来看，Node 官方文档里面的例子。脚本文件a.js代码如下。\n\n\t\t\t- exports.done = false;\nvar b = require('./b.js');\nconsole.log('在 a.js 之中，b.done = %j', b.done);\nexports.done = true;\nconsole.log('a.js 执行完毕');\n\t\t\t- 上面代码之中，a.js脚本先输出一个done变量，然后加载另一个脚本文件b.js。注意，此时a.js代码就停在这里，等待b.js执行完毕，再往下执行。\n\t\t\t- 再看b.js的代码。\n\t\t\t- exports.done = false;\nvar a = require('./a.js');\nconsole.log('在 b.js 之中，a.done = %j', a.done);\nexports.done = true;\nconsole.log('b.js 执行完毕');\n\t\t\t- 上面代码之中，b.js执行到第二行，就会去加载a.js，这时，就发生了“循环加载”。系统会去a.js模块对应对象的exports属性取值，可是因为a.js还没有执行完，从exports属性只能取回已经执行的部分，而不是最后的值。\n\t\t\t- a.js已经执行的部分，只有一行。\n\t\t\t- exports.done = false;\n\t\t\t- 因此，对于b.js来说，它从a.js只输入一个变量done，值为false。\n\n然后，b.js接着往下执行，等到全部执行完毕，再把执行权交还给a.js。于是，a.js接着往下执行，直到执行完毕。我们写一个脚本main.js，验证这个过程。\n\t\t\t- var a = require('./a.js');\nvar b = require('./b.js');\nconsole.log('在 main.js 之中, a.done=%j, b.done=%j', a.done, b.done);\n\t\t\t- 执行main.js，运行结果如下。\n\n\t\t\t\t- $ node main.js\n\n在 b.js 之中，a.done = false\nb.js 执行完毕\n在 a.js 之中，b.done = true\na.js 执行完毕\n在 main.js 之中, a.done=true, b.done=true\n\n\t\t\t- 上面的代码证明了两件事。一是，在b.js之中，a.js没有执行完毕，只执行了第一行。二是，main.js执行到第二行时，不会再次执行b.js，而是输出缓存的b.js的执行结果，即它的第四行。\n\t\t\t- exports.done = true;\n\t\t\t- 总之，CommonJS 输入的是被输出值的拷贝，不是引用。\n\n另外，由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。\n\n\t\t\t\t- var a = require('a'); // 安全的写法\nvar foo = require('a').foo; // 危险的写法\n\nexports.good = function (arg) {\n  return a.foo('good', arg); // 使用的是 a.foo 的最新值\n};\n\nexports.bad = function (arg) {\n  return foo('bad', arg); // 使用的是一个部分加载时的值\n};\n\t\t\t\t- 上面代码中，如果发生循环加载，require('a').foo的值很可能后面会被改写，改用require('a')会更保险一点。\n\n- ES6 模块的循环加载 \n\n\t- ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用import从一个模块加载变量（即import foo from 'foo'），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。\n\n\t\t- 请看下面这个例子。\n\n\t\t\t- // a.mjs\nimport {bar} from './b';\nconsole.log('a.mjs');\nconsole.log(bar);\nexport let foo = 'foo';\n\n// b.mjs\nimport {foo} from './a';\nconsole.log('b.mjs');\nconsole.log(foo);\nexport let bar = 'bar';\n\t\t\t- 上面代码中，a.mjs加载b.mjs，b.mjs又加载a.mjs，构成循环加载。执行a.mjs，结果如下。\n\t\t\t- $ node --experimental-modules a.mjs\nb.mjs\nReferenceError: foo is not defined\n\t\t\t- 上面代码中，执行a.mjs以后会报错，foo变量未定义，这是为什么？\n\n让我们一行行来看，ES6 循环加载是怎么处理的。首先，执行a.mjs以后，引擎发现它加载了b.mjs，因此会优先执行b.mjs，然后再执行a.mjs。接着，执行b.mjs的时候，已知它从a.mjs输入了foo接口，这时不会去执行a.mjs，而是认为这个接口已经存在了，继续往下执行。执行到第三行console.log(foo)的时候，才发现这个接口根本没定义，因此报错。\n\n解决这个问题的方法，就是让b.mjs运行的时候，foo已经有定义了。这可以通过将foo写成函数来解决。\n\t\t\t- // a.mjs\nimport {bar} from './b';\nconsole.log('a.mjs');\nconsole.log(bar());\nfunction foo() { return 'foo' }\nexport {foo};\n\n// b.mjs\nimport {foo} from './a';\nconsole.log('b.mjs');\nconsole.log(foo());\nfunction bar() { return 'bar' }\nexport {bar};\n\n\t\t\t\t- 这时再执行a.mjs就可以得到预期结果。\n\n\t\t\t\t\t- $ node --experimental-modules a.mjs\nb.mjs\nfoo\na.mjs\nbar\n\n\t\t\t- 这是因为函数具有提升作用，在执行import {bar} from './b'时，函数foo就已经有定义了，所以b.mjs加载的时候不会报错。这也意味着，如果把函数foo改写成函数表达式，也会报错。\n\n\t\t\t\t- // a.mjs\nimport {bar} from './b';\nconsole.log('a.mjs');\nconsole.log(bar());\nconst foo = () => 'foo';\nexport {foo};\n\t\t\t\t- 上面代码的第四行，改成了函数表达式，就不具有提升作用，执行就会报错。\n\n## 编程风格\n\n### 块级作用域\n\n- （1）let 取代 var\n- （2）全局常量和线程安全\n\n\t- 在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。\n\n\t\t- const优于let有几个原因。\n\n\t\t\t- 一个是const可以提醒阅读程序的人，这个变量不应该改变\n\t\t\t- 另一个是const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算\n\t\t\t- 最后一个原因是 JavaScript 编译器会对const进行优化，所以多使用const，有利于提高程序的运行效率，也就是说let和const的本质区别，其实是编译器内部的处理不同。\n\n\t\t- // bad\nvar a = 1, b = 2, c = 3;\n\n// good\nconst a = 1;\nconst b = 2;\nconst c = 3;\n\n// best\nconst [a, b, c] = [1, 2, 3];\n\t\t- const声明常量还有两个好处\n\n\t\t\t- 一是阅读代码的人立刻会意识到不应该修改这个值\n\t\t\t- 二是防止了无意间修改变量值所导致的错误。\n\n\t\t- 所有的函数都应该设置为常量。\n\n### 字符串\n\n- 静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。\n\n\t- // bad\nconst a = \"foobar\";\nconst b = 'foo' + a + 'bar';\n\n// acceptable\nconst c = `foobar`;\n\n// good\nconst a = 'foobar';\nconst b = `foo${a}bar`;\n\n### 解构赋值\n\n- 使用数组成员对变量赋值时，优先使用解构赋值。\n\n\t- const arr = [1, 2, 3, 4];\n\n// bad\nconst first = arr[0];\nconst second = arr[1];\n\n// good\nconst [first, second] = arr;\n\n- 函数的参数如果是对象的成员，优先使用解构赋值。\n\n\t- // bad\nfunction getFullName(user) {\n  const firstName = user.firstName;\n  const lastName = user.lastName;\n}\n\n// good\nfunction getFullName(obj) {\n  const { firstName, lastName } = obj;\n}\n\n// best\nfunction getFullName({ firstName, lastName }) {\n}\n\n- 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。\n\n\t- // bad\nfunction processInput(input) {\n  return [left, right, top, bottom];\n}\n\n// good\nfunction processInput(input) {\n  return { left, right, top, bottom };\n}\n\nconst { left, right } = processInput(input);\n\n### 对象\n\n- 单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。\n\n\t- // bad\nconst a = { k1: v1, k2: v2, };\nconst b = {\n  k1: v1,\n  k2: v2\n};\n\n// good\nconst a = { k1: v1, k2: v2 };\nconst b = {\n  k1: v1,\n  k2: v2,\n};\n\n- 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。\n\n\t- // bad\nconst a = {};\na.x = 3;\n\n// if reshape unavoidable\nconst a = {};\nObject.assign(a, { x: 3 });\n\n// good\nconst a = { x: null };\na.x = 3;\n\n- 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。\n\n\t- // bad\nconst obj = {\n  id: 5,\n  name: 'San Francisco',\n};\nobj[getKey('enabled')] = true;\n\n// good\nconst obj = {\n  id: 5,\n  name: 'San Francisco',\n  [getKey('enabled')]: true,\n};\n\t- 上面代码中，对象obj的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建obj的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。\n\n- 另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。\n\n\t- var ref = 'some value';\n\n// bad\nconst atom = {\n  ref: ref,\n\n  value: 1,\n\n  addValue: function (value) {\n    return atom.value + value;\n  },\n};\n\n// good\nconst atom = {\n  ref,\n\n  value: 1,\n\n  addValue(value) {\n    return atom.value + value;\n  },\n};\n\n### 数组\n\n- 使用扩展运算符（...）拷贝数组。\n\n\t- // bad\nconst len = items.length;\nconst itemsCopy = [];\nlet i;\n\nfor (i = 0; i < len; i++) {\n  itemsCopy[i] = items[i];\n}\n\n// good\nconst itemsCopy = [...items];\n\n- 使用 Array.from 方法，将类似数组的对象转为数组。\n\n\t- const foo = document.querySelectorAll('.foo');\nconst nodes = Array.from(foo);\n\n### Map 结构\n\n- 注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要key: value的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。\n\n\t- let map = new Map(arr);\n\nfor (let key of map.keys()) {\n  console.log(key);\n}\n\nfor (let value of map.values()) {\n  console.log(value);\n}\n\nfor (let item of map.entries()) {\n  console.log(item[0], item[1]);\n}\n\n### Class\n\n- 总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解。\n\n\t- // bad\nfunction Queue(contents = []) {\n  this._queue = [...contents];\n}\nQueue.prototype.pop = function() {\n  const value = this._queue[0];\n  this._queue.splice(0, 1);\n  return value;\n}\n\n// good\nclass Queue {\n  constructor(contents = []) {\n    this._queue = [...contents];\n  }\n  pop() {\n    const value = this._queue[0];\n    this._queue.splice(0, 1);\n    return value;\n  }\n}\n\n- 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。\n\n\t- // bad\nconst inherits = require('inherits');\nfunction PeekableQueue(contents) {\n  Queue.apply(this, contents);\n}\ninherits(PeekableQueue, Queue);\nPeekableQueue.prototype.peek = function() {\n  return this._queue[0];\n}\n\n// good\nclass PeekableQueue extends Queue {\n  peek() {\n    return this._queue[0];\n  }\n}\n\n### 模块\n\n- 首先，Module 语法是 JavaScript 模块的标准写法，坚持使用这种写法。使用import取代require。\n\n\t- // bad\nconst moduleA = require('moduleA');\nconst func1 = moduleA.func1;\nconst func2 = moduleA.func2;\n\n// good\nimport { func1, func2 } from 'moduleA';\n\n- 使用export取代module.exports。\n\n\t- // commonJS的写法\nvar React = require('react');\n\nvar Breadcrumbs = React.createClass({\n  render() {\n    return <nav />;\n  }\n});\n\nmodule.exports = Breadcrumbs;\n\n// ES6的写法\nimport React from 'react';\n\nclass Breadcrumbs extends React.Component {\n  render() {\n    return <nav />;\n  }\n};\n\nexport default Breadcrumbs;\n\t- 如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，export default与普通的export不要同时使用。\n\n- 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。\n\n\t- // bad\nimport * as myObject from './importModule';\n\n// good\nimport myObject from './importModule';\n\n- 如果模块默认输出一个函数，函数名的首字母应该小写。\n\n\t- function makeStyleGuide() {\n}\n\nexport default makeStyleGuide;\n\n- 如果模块默认输出一个对象，对象名的首字母应该大写。\n\n\t- const StyleGuide = {\n  es6: {\n  }\n};\n\nexport default StyleGuide;\n\n### ESLint 的使用\n\n- ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。\n\n\t- 首先，安装 ESLint。\n\n\t\t- $ npm i -g eslint\n\n\t- 然后，安装 Airbnb 语法规则，以及 import、a11y、react 插件。\n\n\t\t- $ npm i -g eslint-config-airbnb\n$ npm i -g eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react\n\n\t- 最后，在项目的根目录下新建一个.eslintrc文件，配置 ESLint。\n\n\t\t- {\n  \"extends\": \"eslint-config-airbnb\"\n}\n\n\t- 现在就可以检查，当前项目的代码是否符合预设的规则。\n\n\t\t- index.js文件的代码如下。\n\n\t\t\t- var unusued = 'I have no purpose!';\n\nfunction greet() {\n    var message = 'Hello, World!';\n    alert(message);\n}\n\ngreet();\n\t\t\t- 使用 ESLint 检查这个文件，就会报出错误。\n\t\t\t- $ eslint index.js\nindex.js\n  1:1  error  Unexpected var, use let or const instead          no-var\n  1:5  error  unusued is defined but never used                 no-unused-vars\n  4:5  error  Expected indentation of 2 characters but found 4  indent\n  4:5  error  Unexpected var, use let or const instead          no-var\n  5:5  error  Expected indentation of 2 characters but found 4  indent\n\n✖ 5 problems (5 errors, 0 warnings)\n\t\t\t- 上面代码说明，原文件有五个错误，其中两个是不应该使用var命令，而要使用let或const；一个是定义了变量，却没有使用；另外两个是行首缩进为 4 个空格，而不是规定的 2 个空格。\n\n### 函数\n\n- 立即执行函数可以写成箭头函数的形式。\n\n\t- (() => {\n  console.log('Welcome to the Internet.');\n})();\n\n- 那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 this。\n\n\t- // bad\n[1, 2, 3].map(function (x) {\n  return x * x;\n});\n\n// good\n[1, 2, 3].map((x) => {\n  return x * x;\n});\n\n// best\n[1, 2, 3].map(x => x * x);\n\n- 箭头函数取代Function.prototype.bind，不应再用 self/_this/that 绑定 this。\n\n\t- // bad\nconst self = this;\nconst boundMethod = function(...params) {\n  return method.apply(self, params);\n}\n\n// acceptable\nconst boundMethod = method.bind(this);\n\n// best\nconst boundMethod = (...params) => method.apply(this, params);\n\t- 简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。\n\n- 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。\n\n\t- // bad\nfunction divide(a, b, option = false ) {\n}\n\n// good\nfunction divide(a, b, { option = false } = {}) {\n}\n\n- 不要在函数体内使用 arguments 变量，使用 rest 运算符（...）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。\n\n\t- // bad\nfunction concatenateAll() {\n  const args = Array.prototype.slice.call(arguments);\n  return args.join('');\n}\n\n// good\nfunction concatenateAll(...args) {\n  return args.join('');\n}\n\n- 使用默认值语法设置函数参数的默认值。\n\n\t- // bad\nfunction handleThings(opts) {\n  opts = opts || {};\n}\n\n// good\nfunction handleThings(opts = {}) {\n  // ...\n}\n\n",fa={data:function(){return{MainComponent:ha}}},ya=fa,Sa=Object(v["a"])(ya,_a,da,!1,null,"6659124a",null),wa=Sa.exports,ka=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},xa=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("div",{staticClass:"line number1 index0 alt2"},[e("code",{staticClass:"javascript plain"},[t._v("str.replace(/")]),e("code",{staticClass:"javascript keyword"},[t._v("class")]),e("code",{staticClass:"javascript plain"},[t._v('=[\\"|')]),e("code",{staticClass:"javascript string"},[t._v("'](.*?)[\\\"|'")]),e("code",{staticClass:"javascript plain"},[t._v("].*?/g, ")]),e("code",{staticClass:"javascript string"},[t._v("''")]),e("code",{staticClass:"javascript plain"},[t._v(")")])])])}],Ca={},ja=Ca,Pa=Object(v["a"])(ja,ka,xa,!1,null,"5ca6e3ab",null),Ta=Pa.exports,Ea=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{},[e("q-markdown",{attrs:{src:t.MainComponent}})],1)},Oa=[],Ma="# Jquery\n\n## 1.优点\n\n### 1.隐私迭代\n\n- 自动遍历元素\n\n### 2.链式编程\n\n- 用白话说：可以一直点下去\n\n## 2.入口函数（如果写在html的上面，一定要有入口函数）\n\n### 1.$（function () { } ）\n\n### 2.$(document).ready（function（）{ } ）\n\n## 3.顶级对象\n\n### $\n\n## 4.相互转换\n\n### 1.DOM对象==>jQuery对象\n\n- 例如：$(btn)\n\n\t- 注意（）括号里面直接使用DOM对象，不用加‘’引号\n\n### 2.jQuery==>DOM对象\n\n- 1.$('input')[0]\n- 2.$('input').get[0]\n\n## 5.方法\n\n### 1.获取索引\n\n- index()\n\n\t- 可以获取当前伪数组的索引\n\n### 2.属性操作\n\n- 1.基本（固有）属性\n\n\t- prop();\n\n\t\t- 1.一个值伪获取\n\t\t- 2.二个值伪设置\n\n- 2.自定义属性\n\n\t- attr();\n\n\t\t- 1.一个值伪获取\n\t\t- 2.二个值伪设置\n\n### 3.内容文本值\n\n- 1.html() \n\n\t- 大多数 双标签使用\n\n- 2.text()\n\n\t- 大多数 双标签使用\n\n- 3.val()\n\n\t- 大多数 表单使用\n\n### 4.获取祖先元素\n\n- parents()\n\n### 5.遍历\n\n- 1.遍历元素\n\n\t- jQuery对象.each(function(参数1，参数2){\n})\n参数1：每个元素的索引号\n参数2：这里是DOM的元素对象，需要转为JQ的对象\n\n- 2.遍历数据\n\n\t- $.each（遍历谁，function(){\n}）\n参数1：是每个元素的索引号;   \n参数2：遍历内容\n\n### 6.元素操作\n\n- 1.创建元素\n\n\t- $(\"<li></li>\")\n\n- 2.添加元素（父子关系）\n\n\t- append();\n\t- prepend();\n\n- 3.外部添加（兄弟关系）\n\n\t- after();\n\t- before();\n\n- 4.删除元素\n\n\t- remove（）把整个元素i清空\n\t- empty（）把内容i清空\n\t- html('')=>添加空的字符串\n\n## 6.选择器\n\n### 1.基本\n\n- 1.标签名 $('div')\n- 2.id名$('#div')\n- 3.* $('*')\n- 4.class名 $('.box')\n- 5.获取多个 $('p,img')\n- 6.交集 $('p.c1')\n- 7.子代 $('p>span')\n- 8.后代 $('p span')\n\n### 2.筛选选择器\n\n- 1.第一个元素 $('li:first')\n- 2.最后一个元素 $('li:last')\n- 3.\"索引\"为2的元素 $('li:eq(2)')\n- 4.索引为奇数 $('li:odd')\n- 5.索引为偶数 $('li:even')\n\n### 3.筛选方法\n\n- 1.父级 \n\n\t- $('li.parent()')\n\n- 2.子级\n\n\t- $(’li‘).children()\n\t- 一个儿子 $(’li‘).children(‘p’)\n\n- 3.后代级\n\n\t- $('li').find('p')\n\n- 4.兄弟\n\n\t- $('li').siblings()\n\n- 5.前面兄弟\n\n\t- $('li c4').nextAll()\n\n- 6.后面兄弟\n\n\t- $('li c4').prveAll()\n\n- 7.判断某个元素是否有哪个类名(返回值booleqan)\n\n\t-  $('li').hasClass('c2')   \n\n- 8.指定索引方法【推荐】\n\n\t- $('li').eq(2)\n\n## 7.样式操作\n\n### 1.直接操作\n\n- 单一操作\n\n\t- $(‘div’).css('width',100)\n\n- 多种样式一起改变（传入对象）\n\n\t- $('div').css({\n\twidth:200,\n\theight:200,\n})\n\n### 2.类名操作\n\n- 1.添加\n\n\t- $('div').addCLass(‘类名’)\n\n- 2.删除\n\n\t- $('div').removeCLass(‘类名’)\n\n- 3.切换\n\n\t- $('div').toggleClassCLass(‘类名’)\n\n## 8.效果\n\n### 1.显示隐藏（三个参数均可以省略）\n\n- 1.显示\n\n\t- show('时间','切换效果','回调函数')\n\n- 2.隐藏\n\n\t- hide('时间','切换效果','回调函数')\n\n- 3.切换\n\n\t- toggle('时间','切换效果','回调函数')\n\n### 2.滑动效果（三个参数均可以省略）\n\n- 1.向下滑\n\n\t- slideDown('时间','切换效果','回调函数')\n\n- 2.向上滑\n\n\t- slideUp('时间','切换效果','回调函数')\n\n- 3.切换\n\n\t- slideToggle('时间','切换效果','回调函数')\n\n### 3.事件切换\n\n- hover（function（），function（））\n\n\t- 1.第一个参数，鼠标进入\n\t- 2.第二个参数，鼠标移除\n\t- 注意：如果参数只写一个，则鼠标进入和离开的时候都会触发他\n\t- (不支持冒泡)mouseencter <==> mouseover（支持冒泡）\n\t- （不支持冒泡）mouseleave <==> mouseout（支持冒泡）\n\n### 4.淡入淡出效果\n\n- 1.淡入\n\n\t- fadeIn('时间','切换效果','回调函数')\n\n- 2.淡出\n\n\t- fadeOut('时间','切换效果','回调函数')\n\n- 3.切换\n\n\t- fadeToggle('时间','切换效果','回调函数')\n\n- 4.淡入/出到某个程度\n\n\t- fadeTo('时间','透明度','切换效果','回调函数')  ====>前两个参数必须写\n\n### 5.自定义动画\n\n- animate('params','速度','切换效果','回调函数')\n\n\t- params(更改的样式)\n\n\t\t- 1.必须写\n\t\t- 2.对象形式\n\t\t- 3.不可以设置颜色\n\n### 6.动画队列及其停止排队方法\n\n- stop()\n\n## 9.jQuery尺寸\n\n### width（）；\n\n### height （）；\n\n### innerWidth（）；\n\n### innerHeight();\n\n### outerWidth();\n\n### outerHeight();\n\n### outerWidth(true);\n\n### outerHeight(true);\n\n## 10.jQuery位置\n\n### 1.offset（）；\n\n- 1.距离文档的距离\n- 2.返回值是一个对象\n- 3.可以设置\n\n### 2.position（）\n\n- 1.距离带有定位父元素的距离\n- 2.返回值是一个对象\n- 3.不可以设置\n\n### 3.scrollTop();\n\n- 卷起上部分的距离\n\n### 4.scrollLeft();\n\n- 卷据做部分的距离\n\n## 11.jQuery事件\n\n### 1.事件注册\n\n- element.事件（function(){}）\n\n### 2.绑定事件\n\n- on的方式\n\n\t- 1.element.on（‘事件’，‘元素’，‘fn’）\n\t- 2.element.on（{\n\tclick:function(){},\n    mouseover:function(){}\n}）\n\n\t\t- 优势:1.可以绑定多个事件，多个处理事件处理程序\n       2.可以完成事件委派（委托）\n       3.动态添加的元素也享有事件，需要事件委派\n\n\t- 3.element.one('click','fn')\n\n\t\t- 事件只完成1次\n\n### 2.解绑事件\n\n- 1.$('div').off();\n\n\t- div身上的全部事件解绑\n\n- 2.$('div').off('click')\n\n\t- div身上的click事件解绑\n\n- 3.$('div').off('click','li')\n\n\t- 解绑事件委托\n\n### 3.自动触发事件\n\n- 1.element.click();\n- 2.element.tigger('click')\n\n\t- 自动触发，不需要点击\n\n- 3.element.tiggerHandler('click');\n\n\t- 不会触发元素的默认行为\n\n## 13.事件对象\n\n### 1.阻止默认行为：\n\n- 1.event.preventDefault()\n- 2.return  false \n\n### 2.阻止冒泡：\n\n-  event.stopPropagation()\n\n",Aa={data:function(){return{MainComponent:Ma}}},Na=Aa,Ia=Object(v["a"])(Na,Ea,Oa,!1,null,"5066c7d2",null),Da=Ia.exports,za=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{},[e("q-markdown",{attrs:{src:t.MainComponent}})],1)},$a=[],Ra="# 阮一峰JavaScript基础总结\n\n## 阮一峰·JS基 础语法部分\n\n### 基本语法\n\n- switch不进行类型转换\n\n- 三元运算符\n\n- break与continue语句\n\n- 标签：Label\n\n### 数据类型\n\n- 六种主要数据类型\n\n\t- 字符串，数值，布尔值，null，undefined，对象\n\t- ES6新增Symbol\n\n- JavaScript确定值类型的三种方法\n\n\t- typeof运算符\n\n\t\t- 一共六种类型，注意6，7。对于Array,Null等特殊对象使用typeof一律返回object，这正是typeof的局限性，typeof只能区分值类型的，不能区分引用类型\n\t\t- 注意使用typeof得到的六种结果为：number，function，object，string，undefined，boolean\n\n\t- instanceof运算符\n\n\t\t- instanceof：用于判断 引用类型 属于哪个构造函数的方法\n\t- Object.prototype.toString方法\n\n- null与undefined\n\n\t- 区别：null是一个表示“空”的对象，转为数值时为0；undefined是一个表示”此处无定义”的原始值，转为数值时为NaN。\n\n\t- 用法与含义\n\n- 布尔值\n\n\t- 哪些运算符会返回布尔值？\n\n\t\t- 两元逻辑运算符： && (And)，|| (Or)\n\t\t- 前置逻辑运算符： ! (Not)\n\t\t- 相等运算符：===，!==，==，!=\n\t\t- 比较运算符：>，>=，<，<=\n\n\t- 转换规则\n\n\t\t- 除了下面六个值被转为false，其他值都视为true。\n\t\t- undefined，null，false，0，NaN，\"\"或''（空字符串）\n\n### 数值\n\n- 整数和浮点数\n\n\t- JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。\n\n\t- JavaScript语言底层没有整数\n\t- 涉及到小数的比较与运算要特别小心\n\n- 数值范围\n\n\t-  JavaScript 能够表示的数值范围为2的1024次方到2的-1023次方（开区间），超出这个范围的数无法表示\n\t- 正向溢出\n\n\t- 负向溢出\n\n\t- JavaScript 提供Number对象的MAX_VALUE和MIN_VALUE属性，返回可以表示的具体的最大值和最小值。\n\n\t\t- Number.MAX_VALUE // 1.7976931348623157e+308\n\t\t- Number.MIN_VALUE // 5e-324\n\n- 数值进制\n\n\t- 十进制：没有前导0的数值。\n\t- 八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。\n\t- 十六进制：有前缀0x或0X的数值。\n\t- 二进制：有前缀0b或0B的数值。\n\n- 正负零的唯一区别\n\n- NaN\n\n\t- 含义\n\n\t\t- 数据类型依然属于Number，主要出现在将字符串解析成数字出错的场合。另外，一些数学函数的运算结果会出现NaN。0除以0也会得到NaN。\n\n\t- 运算规则\n\n\t\t- NaN不等于任何值，包括它本身。\n\t\t- 数组的indexOf方法内部使用的是严格相等运算符，所以该方法对NaN不成立。\n\n\t\t- NaN在布尔运算时被当作false。\n\t\t- NaN与任何数（包括它自己）的运算，得到的都是NaN。\n\n- 相关方法\n\n\t- parseInt()\n\n\t\t- \n该方法用于将字符串转为整数。返回值只有两种可能，要么是一个十进制整数，要么是NaN。\n\n1）如果字符串头部有空格，空格会被自动去除。\n\n2）如果parseInt的参数不是字符串，则会先转为字符串再转换。\n\n3）字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。\n\t\t- 对于自动转科学计数法的情况\n\n\t\t- 进制转换\n\n\t\t\t- parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。\n\t\t\t- 第一个参数自转字符串引发进制转换的错误\n\n\t- parseFloat()\n\n\t\t- \n该方法用于将一个字符串转为浮点数。\n\t\t- parseFloat()在转化NaN不同于Number()，如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN。尤其注意！parseFloat会将空字符串转为NaN。\n\n\t- isNaN()\n\n\t\t- \nisNaN方法可以用来判断一个值是否为NaN。\n\t\t- 可以令isNaN()返回true的情况：NaN、字符串、对象、数组\n\n\t\t- 使用\n\n\t\t\t- 使用isNaN之前，最好判断一下数据类型。\n\n\t\t\t\t- function myIsNaN(value) {\n  return typeof value === 'number' && isNaN(value);\n}\n\n\t\t- 替代\n\n\t\t\t- 判断isNaN更可靠的方法是，利用NaN为唯一不等于自身的值的这个特点，进行判断。\n\n\t\t\t\t- function myIsNaN(value) {\n  return value !== value;\n}\n\n\t- isFinite()\n\n\t\t- isFinite方法返回一个布尔值，表示某个值是否为正常的数值。\n\t\t- 除了Infinity、-Infinity和NaN这三个值会返回false，isFinite对于其他的数值都会返回true。\n\n\t\t\t- isFinite(Infinity) // false\n\t\t\t- isFinite(-Infinity) // false\n\t\t\t- isFinite(NaN) // false\n\t\t\t- isFinite(-1) // true\n\n### 字符串\n\n- 定义\n\n\t- 字符串默认只能写在一行内，分成多行将会报错。\n\n\t- 如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。\n\n- 转义\n\n\t- 反斜杠的特殊用法\n\n- 字符串与数组的相似性\n\n\t- 字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。\n\t- 如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。\n\n- length属性\n\n\t- length属性返回字符串的长度，该属性也是无法改变的。\n\n- 字符集\n\n\t- JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。\n\nJavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成\\uxxxx的形式，其中xxxx代表该字符的 Unicode 码点。比如，\\u00A9代表版权符号。\n\t- 对于码点在U+10000到U+10FFFF之间的字符，JavaScript 总是认为它们是两个字符（length属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是不正确的。\n\n- Base64转码\n\n  有时，文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。\n\n\t- 定义\n\n\t\t- \n一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符\n\n\t- 使用目的\n\n\t\t- 不是为了加密，而是为了不出现特殊字符，简化程序的处理。\n\n\t- JavaScript 原生提供两个 Base64 相关的方法。\n\n\t\t- btoa()：任意值转为 Base64 编码\n\t\t- atob()：Base64 编码转为原来的值\n\t- 注意\n\n\t\t- 这两个方法不适合非 ASCII 码的字符\n\t\t- 要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。\n\n### 对象\n\n- 键名\n\n\t- \n如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。\n\n- 对象的引用\n\n\t- 如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。\n\n\t- 此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。\n\n- 表达式还是语句\n\n\t- 如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。\n\n- 属性的操作\n\n\t- 属性读取\n\n\t\t- \n请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。\n\n\t\t- 注意，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。\n\n\t- 查看所有属性\n\n\t\t- 查看一个对象本身的所有属性，可以使用Object.keys方法。\n\n\t- delete 命令\n\n\t\t- delete命令用于删除对象的属性，删除成功后返回true。\n\n\t\t- 注意，删除一个不存在的属性，delete不报错，而且返回true。不能根据delete命令的结果，认定某个属性是存在的。\n\n\t\t- 只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。\n\n\t\t- 需要注意的是，delete命令只能删除对象本身的属性，无法删除继承的属性\n\n\t- in 运算符\n\n\t\t- \nin运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true\n\t\t- in运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。\n\n\t- for…in 循环\n\n\t\t- for...in循环用来遍历一个对象的全部属性。\n\n\t\t- 注意点\n\n\t\t\t- 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。\n\t\t\t- 它不仅遍历对象自身的属性，还遍历继承的属性。\n\n\t\t- 使用\n\n\t\t\t- 使用for...in的时候，应该结合使用hasOwnProperty方法，在循环内部判断一下，某个属性是否为对象自身的属性。\n\n\t- with 语句\n\n\t\t- 作用\n\n\t\t\t- 操作同一个对象的多个属性时，提供一些书写的方便。\n\n\t\t- 注意\n\n\t\t\t- 如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。\n\n### 数组\n\n- 定义\n\n\t- 任何类型的数据，都可以放入数组。\n\n- length 属性\n\n\t- length属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。清空数组的一个有效方法，就是将length属性设为0。\n\t- 如果人为设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。当length属性设为大于数组个数时，读取新增的位置都会返回undefined\n\t- 注意\n\n\t\t- 由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响length属性的值。\n\n- in 运算符\n\n\t- \n检查某个键名是否存在的运算符in，适用于对象，也适用于数组。\n\n- for…in 循环和数组的遍历\n\n\t- for...in不仅会遍历数组所有的数字键，还会遍历非数字键。\n\t- 不推荐使用for...in遍历数组。数组的遍历可以考虑使用for循环或while循环。\n\n\t- foreach方法\n\n\t\t- 数组的forEach方法，也可以用来遍历数组\n\n- 数组的空位\n\n\t- 数组的空位在length属性中有体现，并且是可以读取的，返回undefined。\n\t- 注意\n\n\t\t- 数组的某个位置是空位，与某个位置是undefined，是不一样的。如果是空位，使用数组的forEach方法、for...in结构、以及Object.keys方法进行遍历，空位都会被跳过。\n\t\t- 如果某个位置是undefined，遍历的时候就不会被跳过。\n\n- “类似数组的对象”使用数组方法\n\n\t- 1）数组的slice方法可以将“类似数组的对象”变成真正的数组。\n\n\t\t- var arr = Array.prototype.slice.call(arrayLike);\n\n\t- 2）就是通过call()把数组的方法放到对象上面。\n\n\t  注意，这种方法比直接使用数组原生的forEach要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的forEach方法。\n\n### 函数\n\n- 递归\n\n\t- 函数可以调用自身，这就是递归（recursion）\n\n- 变量提升\n\n\t- 如果同时采用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义。\n\n- 不能在条件语句中声明函数\n\n\t- 根据 ES5 的规范，不得在非函数的代码块中声明函数，最常见的情况就是if和try语句。\n- 函数的属性和方法\n\n\t- name 属性\n\n\t\t- 函数的name属性返回函数的名字。\n\t\t- 用处\n\n\t\t\t- name属性的一个用处，就是获取参数函数的名字。\n\n\t- length 属性\n\n\t\t- \n函数的length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。\n\t\t- length属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的”方法重载“\n\n\t- toString()\n\n\t\t- \n函数的toString方法返回一个字符串，内容是函数的源码。\n\n- 函数的参数\n\n\t- 参数的省略\n\n\t\t- 需要注意的是，函数的length属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。\n\t\t- 没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入undefined。\n\n\t- 参数的传递\n\n\t\t- 原始类型的值（数值、字符串、布尔值），传递方式是传值传递（在函数体内修改参数值，不会影响到函数外部。）\n\t\t- 参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（内部修改参数，将会影响到原始值。）\n\n\t\t- 注意！如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。\n\n- arguments 对象\n\n\t- 定义\n\n\t\t- \n这个对象只有在函数体内部，才可以使用。\n\n\t- argument.length\n\n\t\t- 通过arguments对象的length属性，可以判断函数调用时到底带几个参数。\n\n\t- 与数组的关系\n\n\t\t- 虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。\n\t\t- 让argument对象使用数组方法\n\n\t\t\t- 如果要让arguments对象使用数组方法，真正的解决方法是将arguments转为真正的数组。下面是两种常用的转换方法：slice方法和逐一填入新数组。\n\n\t- callee 属性\n\n\t\t- arguments对象带有一个callee属性，返回它所对应的原函数。\n- 闭包\n\n\t- 闭包的作用\n\n\t\t- 1.读取函数内部的变量，并让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。\n\n\t\t- 2.封装对象的私有属性和私有方法。\n\n\t- 注意\n\n\t\t- 注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。\n\n- eval 命令\n\n\t- 定义\n\n\t\t- eval命令的作用是，将字符串当作语句执行。\n\n\t- 性质\n\n\t\t- 放在eval中的字符串，应该有独自存在的意义，不能用来与eval以外的命令配合使用。\n\t\t- eval没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。\n\n\t- 与eval()相类似的\n\n### 运算符\n\n- 数值运算符\n\n\t- 数值运算符的作用在于可以将任何值转为数值（与Number函数的作用相同）。\n\n- 指数运算符\n\n- 字符串的比较\n\n\t- JavaScript 引擎内部首先比较字符串中首字符的 Unicode 码点。如果相等，再比较第二个字符的 Unicode 码点，以此类推。\n\n- 非字符串的比较\n\n\t- （1）原始类型的值\n\n\t\t- 先转成数值再比较。\n\n\t- （2）对象\n\n\t\t- 如果运算子是对象，会转为原始类型的值，再进行比较。\n\t\t- 对象转换成原始类型的值，算法是先调用valueOf方法；如果返回的还是对象，再接着调用toString方法，\n\n\t- （3）undefined == null // true;  undefined === null //false\n\n- 且运算符（&&）\n\n\t- 运算规则\n\n\t\t- 如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。\n\n\t- 取代if结构\n\n\t- 多个连用\n\n\t\t- 且运算符可以多个连用，这时返回第一个布尔值为false的表达式的值。\n- 或运算符（||）\n\n\t- 或运算符常用于为一个变量设置默认值。\n- 逗号运算符\n\n\t- 逗号运算符用于对两个表达式求值，并返回后一个表达式的值。\n### 数据类型转换\n\n- 强制转换\n\n\t- Number()\n\n\t\t- 定义\n\n\t\t\t- 使用Number函数，可以将任意类型的值转化成数值。\n\n\t\t- 参数为原始类型的值\n\n\t\t\t- 只要有一个字符无法转成数值，整个字符串就会被转为NaN。\n\t\t- 参数为对象\n\n\t\t\t- Number方法的参数是对象时，将返回NaN，除非是包含单个数值的数组。\n\n\t- String()\n\n\t\t- （1）原始类型值\n\n\t\t\t- 数值：转为相应的字符串。\n\t\t\t- 字符串：转换后还是原来的值。\n\t\t\t- 布尔值：true转为字符串\"true\"，false转为字符串\"false\"。\n\t\t\t- undefined：转为字符串\"undefined\"。\n\t\t\t- null：转为字符串\"null\"。\n\n\t\t- （2）对象\n\n\t\t\t- String方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。\n\n\t- Boolean()\n\n\t\t- 除了以下五个值的转换结果为false，其他的值全部为true。\n\n\t\t\t- undefined\n\t\t\t- null\n\t\t\t- -0或+0\n\t\t\t- NaN\n\t\t\t- ''（空字符串）\n\n\t\t- 注意\n\n\t\t\t- 所有对象（包括空对象）的转换结果都是true，甚至连false对应的布尔对象new Boolean(false)也是true\n- 自动转换\n\n\t- !! expression\n\n- 对象类型转换\n\n\t- valueOf（）\n\n\t- toString（）\n\n### 错误处理机制\n\n- Error 实例对象\n\n\t- message属性：错误提示信息\n\t- name属性：错误名称（非标准属性）\n\t- stack属性：错误的堆栈（非标准属性）\n\n- Error的6个派生对象\n\n\t- SyntaxError 对象\n\n\t\t- SyntaxError对象是解析代码时发生的语法错误。\n\n\t- ReferenceError 对象\n\n\t\t- ReferenceError对象是引用一个不存在的变量时发生的错误。\n\t\t- 另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值。\n\n\t- RangeError 对象\n\n\t\t- RangeError对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。\n\n\t- TypeError 对象\n\n\t\t- TypeError对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。\n\n\t- URIError 对象\n\n\t\t- URIError对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。\n\n\t- EvalError 对象\n\n\t\t- eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。\n\n- throw 语句\n\n\t- 定义\n\n\t\t- throw语句的作用是手动中断程序执行，抛出一个错误。实际上，throw可以抛出任何类型的值。也就是说，它的参数可以是任何值\n\n- try…catch 结构\n\n\t- 定义\n\n\t\t- try代码块抛出错误（上例用的是throw语句），JavaScript 引擎就立即把代码的执行，转到catch代码块，或者说错误被catch代码块捕获了。catch接受一个参数，表示try代码块抛出的值。\n\n## 阮一峰·JS标 准库\n\n### Object对象\n\n- 概述\n\n\t- JavaScript 的所有其他对象都继承自Object对象，即那些对象都是Object的实例。\n\t- Object对象的原生方法\n\n\t\t- Object本身的方法（静态方法）\n\n\t\t- Object的实例方法。\n\n- Object作为函数的用法：Object()\n\n\t- Object作为工具函数\n\n\t\t- 如果参数是原始类型的值，Object方法将其转为对应的包装对象的实例\n\n\t\t- 如果Object方法的参数是一个对象，它总是返回该对象，即不用转换。\n\n\t\t\t- 利用这一点，可以写一个判断变量是否为对象的函数。\n\t- Object 作为构造函数\n\n\t\t- Object构造函数的首要用途，是直接通过它来生成新对象，通过var obj = new Object()的写法生成新对象，与字面量的写法var obj = {}是等价的。\n\t\t- 与其作为工具函数的用法相似，但是Object(value)与new Object(value)两者的语义是不同的，Object(value)表示将value转成一个对象，new Object(value)则表示新生成一个对象，它的值是value。\n\n- Object 的静态方法\n\n\t- （0）遍历对象的属性的两种方法\n\n\t\t- Object.keys方法只返回可枚举的属性，Object.getOwnPropertyNames方法还返回不可枚举的属性名。\n\n\t- （1）对象属性模型的相关方法\n\n\t\t- Object.getOwnPropertyDescriptor()：获取某个属性的描述对象。\n\t\t- Object.defineProperty()：通过描述对象，定义某个属性。\n\t\t- Object.defineProperties()：通过描述对象，定义多个属性。\n\n\t- （2）控制对象状态的方法\n\n\t\t- Object.preventExtensions()：防止对象扩展。\n\t\t- Object.isExtensible()：判断对象是否可扩展。\n\t\t- Object.seal()：禁止对象配置。\n\t\t- Object.isSealed()：判断一个对象是否可配置。\n\t\t- Object.freeze()：冻结一个对象。\n\t\t- Object.isFrozen()：判断一个对象是否被冻结。\n\n\t- （3）原型链相关方法\n\n\t\t- Object.create()：该方法可以指定原型对象和属性，返回一个新的对象。\n\t\t- Object.getPrototypeOf()：获取对象的Prototype对象。\n\n- Object 的实例方法\n\n\t- Object.prototype.valueOf()：返回当前对象对应的值。\n\n\t\t- valueOf方法的作用是返回一个对象的“值”，默认情况下返回对象本身。\n\t- Object.prototype.toString()：返回当前对象对应的字符串形式。\n\n\t\t- toString方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串。\n\n\t\t- 数组、字符串、函数、Date 对象都分别部署了自定义的toString方法，覆盖了Object.prototype.toString方法。\n\n\t\t- toString() 的应用：判断数据类型\n\n\t\t\t- 概述\n\n\t\t\t- 应用\n\n\t\t\t- 不同数据类型的Object.prototype.toString方法返回值如下。即利用这个特性可以做一个准确的类型判断。\n\n\t\t\t\t- 数值：返回[object Number]。\n\t\t\t\t- 字符串：返回[object String]。\n\t\t\t\t- 布尔值：返回[object Boolean]。\n\t\t\t\t- undefined：返回[object Undefined]。\n\t\t\t\t- null：返回[object Null]。\n\t\t\t\t- 数组：返回[object Array]。\n\t\t\t\t- arguments 对象：返回[object Arguments]。\n\t\t\t\t- 函数：返回[object Function]。\n\t\t\t\t- Error 对象：返回[object Error]。\n\t\t\t\t- Date 对象：返回[object Date]。\n\t\t\t\t- RegExp 对象：返回[object RegExp]。\n\t\t\t\t- 其他对象：返回[object Object]。\n\n\t- Object.prototype.toLocaleString()：返回当前对象对应的本地字符串形式。\n\n\t\t- Array.prototype.toLocaleString()\n\t\t- Number.prototype.toLocaleString()\n\t\t- Date.prototype.toLocaleString()\n\n\t- Object.prototype.hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。\n\n\t\t- Object.prototype.hasOwnProperty方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。\n\t- Object.prototype.isPrototypeOf()：判断当前对象是否为另一个对象的原型。\n\t- Object.prototype.propertyIsEnumerable()：判断某个属性是否可枚举。\n\n### Array 对象\n\n- 作为构造函数\n\n\t- Array构造函数有一个很大的缺陷，就是不同的参数，会导致它的行为不一致。\n\n\t- 不建议使用它生成新数组，直接使用数组字面量是更好的做法。\n\n\t\t- var arr = new Array(1, 2); // bad\n\t\t- var arr = [1, 2]; // good\n\n- 静态方法\n\n\t- Array.isArray()\n\n\t\t- Array.isArray方法返回一个布尔值，表示参数是否为数组。它可以弥补typeof运算符的不足\n- 实例方法\n\n\t- valueOf()，toString()\n\t- push()，pop()\n\n\t\t- push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。\n\n\t\t- pop方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组\n\n\t\t- 对空数组使用pop方法，不会报错，而是返回undefined。\n\n\t\t- push和pop结合使用，就构成了“后进先出”的栈结构（stack）。\n\n\t- shift()，unshift()\n\n\t\t- shift方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。\n\n\t\t- shift方法可以遍历并清空一个数组。\n\n\t\t- push和shift结合使用，就构成了“先进先出”的队列结构（queue）。\n\t\t- unshift方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。\n\n\t- join()\n\n\t\t- join方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。\n\n\t\t- 如果数组成员是undefined或null或空位，会被转成空字符串。\n\n\t\t- 通过call方法，这个方法也可以用于字符串或类似数组的对象。\n\n\t- concat()\n\n\t\t- concat方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。\n\n\t\t- 除了数组作为参数，concat也接受其他类型的值作为参数，添加到目标数组尾部。\n\n\t\t- 如果数组成员包括对象，concat方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是新数组拷贝的是对象的引用。\n\n\t- reverse()\n\n\t\t- reverse方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。\n\t- slice()\n\n\t\t- slice方法用于提取目标数组的一部分，返回一个新数组，原数组不变。\n\t\t- 它的第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。\n\n\t\t- 如果slice方法的参数是负数，则表示倒数计算的位置。\n\n\t\t- slice方法的一个重要应用，是将类似数组的对象转为真正的数组。\n\n\t- splice()\n\n\t\t- splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。\n\t\t- splice的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。\n\n\t\t\t- arr.splice(start, count, addElement1, addElement2, ...);\n\t\t- 起始位置如果是负数，就表示从倒数位置开始删除。\n\t\t- 如果只是单纯地插入元素，splice方法的第二个参数可以设为0。\n\n\t\t- 如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。\n\n\t- sort()\n\n\t\t- sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。\n\t\t- sort方法不是按照大小排序，而是按照字典顺序。也就是说，数值会被先转成字符串，再按照字典顺序进行比较，所以101排在11的前面。\n\n\t\t- 如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数。\n\n\t- map()\n\n\t\t- map方法对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。\n\n\t\t- map方法接受一个函数作为参数。该函数调用时，map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。\n\n\t\t- map方法不仅可以用于数组，还可以用于字符串，用来遍历字符串的每个字符。但是，不能直接使用，而要通过函数的call方法间接使用，或者先将字符串转为数组，然后使用。\n\n\t\t- map方法还可以接受第二个参数，表示回调函数执行时this所指向的对象。\n\n\t\t- 如果数组有空位，map方法的回调函数在这个位置不会执行，不会跳过undefined和null，但是会跳过数组的空位。\n\n\t- forEach()\n\n\t\t- forEach方法与map方法很相似，也是遍历数组的所有成员，执行某种操作，但是forEach方法一般不返回值，只用来操作数据。如果需要有返回值，一般使用map方法。\n\t\t- forEach方法的参数与map方法一致，也是一个函数，数组的所有成员会依次执行该函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。\n\n\t\t- forEach方法也可以接受第二个参数，用来绑定回调函数的this关键字。\n\n\t\t- 注意，forEach方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用for循环。\n\t\t- forEach方法不会跳过undefined和null，但会跳过空位。\n\t\t- forEach方法也可以用于类似数组的对象和字符串。\n\n\t- filter()\n\n\t\t- filter方法的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。\n\n\t\t- filter方法的参数函数可以接受三个参数，第一个参数是当前数组成员的值，这是必需的，后两个参数是可选的，分别是当前数组成员的位置和整个数组。\n\n\t\t- filter方法还可以接受第二个参数，指定测试函数所在的上下文对象（即this对象）。\n\n\t- some()，every()\n\n\t\t- 这两个方法类似“断言”（assert），用来判断数组成员是否符合某种条件。\n\t\t- 它们接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。\n\t\t- some()\n\n\t\t\t- some方法是只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。\n\n\t\t- every()\n\n\t\t\t- every方法则是所有数组成员的返回值都是true，才返回true，否则false。\n\n\t\t- 注意，对于空数组，some方法返回false，every方法返回true，回调函数都不会执行。\n\t\t- some和every方法还可以接受第二个参数，用来绑定函数中的this关键字。\n\n\t- reduce()，reduceRight()\n\n\t\t- 定义\n\n\t\t\t- reduce方法和reduceRight方法依次处理数组的每个成员，最终累计为一个值。\n\n\t\t- 差别\n\n\t\t\t- 它们的差别是，reduce是从左到右处理（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。\n\n\t\t- 参数\n\n\t\t\t- 这两个方法的第一个参数都是一个函数。该函数接受以下四个参数。这四个参数之中，只有前两个是必须的，后两个则是可选的。\n\n\t\t\t\t- 累积变量，默认为数组的第一个成员\n\t\t\t\t- 当前变量，默认为数组的第二个成员\n\t\t\t\t- 当前位置（从0开始）\n\t\t\t\t- 原数组\n\n\t\t- 示例\n\n\t\t\t- 求数组成员之和。\n\n\t\t\t- 利用reduce方法，可以写一个数组求和的sum方法。\n\n\t\t- 如果要对累积变量指定初值，可以把它放在reduce方法和reduceRight方法的第二个参数。第二个参数相当于设定了默认值，处理空数组时尤其有用。\n\n\t\t- 由于reduce方法依次处理每个元素，所以实际上还可以用它来搜索某个元素。比如，下面代码是找出长度最长的数组元素。\n\n\t- indexOf()，lastIndexOf()\n\n\t\t- indexOf()\n\n\t\t\t- indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。\n\n\t\t\t- indexOf方法还可以接受第二个参数，表示搜索的开始位置。\n\n\t\t- lastIndexOf()\n\n\t\t\t- lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。\n\n\t\t- 注意，如果数组中包含NaN，这两个方法不适用，即无法确定数组成员是否包含NaN。\n\n\t- 链式使用\n\n\t\t- 上面这些数组方法之中，有不少返回的还是数组，所以可以链式使用。\n### 包装对象\n\n- 包装对象的定义\n\n\t- 有人说，JavaScript 语言“一切皆对象”。这是因为数组和函数本质上都是对象，就连三种原始类型的值——数值、字符串、布尔值——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”。\n\n\t- 所谓“包装对象”，就是分别与数值、字符串、布尔值相对应的Number、String、Boolean三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。\n\t- 这三个对象作为构造函数使用（带有new）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有new），可以将任意类型的值，转为原始类型的值。\n\n- 包装对象实例的方法\n\n\t- 包装对象实例可以使用Object对象提供的原生方法，主要是valueOf方法和toString方法。\n\n\t\t- valueOf()\n\n\t\t- toString()\n\n- 原始类型的自动转换\n\n\t- 定义\n\n\t\t- 原始类型的值，可以自动当作对象调用，即调用各种对象的方法和参数。这时，JavaScript引擎会自动将原始类型的值转为包装对象，在使用后立刻销毁。\n\n\t\t\t- 上面代码中，abc是一个字符串，本身不是对象，不能调用length属性。JavaScript引擎自动将其转为包装对象，在这个对象上调用length属性。调用结束后，这个临时对象就会被销毁。这就叫原始类型的自动转换。\n\n\t- 内部属性[[PrimitiveValue]]\n\n\t\t- 上面代码中，字符串abc的包装对象有每个位置的值、有length属性、还有一个内部属性[[PrimitiveValue]]保存字符串的原始值。这个[[PrimitiveValue]]内部属性，外部是无法调用，仅供ValueOf或toString这样的方法内部调用。\n\n\t- 这个临时对象是只读的，无法修改。所以，字符串无法添加新属性。\n\n\t- 另一方面，调用结束后，临时对象会自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。如果想要为字符串添加属性，只有在它的原型对象String.prototype上定义\n\t- 这种原始类型值可以直接调用的方法还有很多（详见后文对各包装对象的介绍），除了前面介绍过的valueOf和toString方法，还包括三个包装对象各自定义在原型上的方法。。\n\n- 自定义方法\n\n\t- 三种包装对象还可以在原型上添加自定义方法和属性，供原始类型的值直接调用。\n\n- 注意\n\n\t- 注意，false对应的包装对象实例，布尔运算结果也是true。是因为false对应的包装对象实例是一个对象，进行逻辑运算时，被自动转化成布尔值true（因为所有对象对应的布尔值都是true）\n\n### Number对象\n\n- 概述\n\n\t- Number对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。\n\t- 作为构造函数时，它用于生成值为数值的对象。\n\n\t\t- var n = new Number(1);\ntypeof n // \"object\"\n\n\t- 作为工具函数时，它可以将任何类型的值转为数值。\n\n\t\t- Number(true) // 1\n\n- Number对象的属性\n\n\t- Number对象拥有以下一些属性。\n\n\t\t- Number.POSITIVE_INFINITY：正的无限，指向Infinity。\n\t\t- Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。\n\t\t- Number.NaN：表示非数值，指向NaN。\n\t\t- Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。\n\t\t- Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。\n\t\t- Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。\n\t\t- Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。\n\n- Number 对象实例的方法\n\n\t- Number.prototype.toString()\n\n\t\t- 将一个数值转为字符串形式。toString方法可以接受一个参数，表示输出的进制。\n\n\t- Number.prototype.toFixed()\n\n\t\t- toFixed方法用于将一个数转为指定位数的小数，返回这个小数对应的字符串。\n\n\t- Number.prototype.toExponential()\n\n\t\t- toExponential方法用于将一个数转为科学计数法形式。\n\n\t- Number.prototype.toPrecision()\n\n\t\t- toPrecision方法用于将一个数转为指定位数的有效数字。\n\n- 自定义方法\n\n\t- 与其他对象一样，Number.prototype对象上面可以自定义方法，被Number的实例继承。\n### String对象\n\n- 概述\n\n\t- \nString对象是JavaScript原生提供的三个包装对象之一，用来生成字符串的包装对象。\n\t- 实际上，字符串的包装对象是一个类似数组的对象（即很像数组，但是实质上不是数组）。\n\t- 当做构造函数使用\n\t- 还可以当作工具方法使用，将任意类型的值转为字符串。\n\n- 静态方法\n\n\t- \nString.fromCharCode()\n\n\t\t- 该方法的参数是一系列Unicode码点，返回对应的字符串。\n\t\t- 注意，该方法不支持Unicode码点大于0xFFFF的字符，即传入的参数不能大于0xFFFF。\n\n- 实例对象的属性和方法\n\n\t- length属性返回字符串的长度。\n\n\t\t- 'abc'.length // 3\n\n\t- charAt()\n\n\t\t- charAt方法返回指定位置的字符，参数是从0开始编号的位置。\n\n\t\t- 这个方法完全可以用数组下标替代。\n\t\t- 如果参数为负数，或大于等于字符串的长度，charAt返回空字符串。\n\n\t- charCodeAt()\n\n\t\t- charCodeAt方法返回给定位置字符的Unicode码点（十进制表示），相当于String.fromCharCode()的逆操作。\n\n\t- concat()\n\n\t\t- concat方法用于连接两个字符串，返回一个新字符串，不改变原字符串。\n\n\t\t- 该方法可以接受多个参数。\n\n\t\t\t- 'a'.concat('b', 'c') // \"abc\"\n\n\t\t- 如果参数不是字符串，concat方法会将其先转为字符串，然后再连接。\n\n\t- slice()\n\n\t\t- slice方法用于从原字符串取出子字符串并返回，不改变原字符串。\n\t\t- 它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。\n\n\t\t\t- 'JavaScript'.slice(0, 4) // \"Java\"\n\n\t\t- 如果省略第二个参数，则表示子字符串一直到原字符串结束。\n\n\t\t\t- 'JavaScript'.slice(4) // \"Script\"\n\n\t\t- 如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。\n\t\t- 如果第一个参数大于第二个参数，slice方法返回一个空字符串。\n\n\t- substring()\n\n\t\t- substring方法用于从原字符串取出子字符串并返回，不改变原字符串。它与slice作用相同，但有一些奇怪的规则，因此不建议使用这个方法，优先使用slice。\n\t\t- 如果第二个参数大于第一个参数，substring方法会自动更换两个参数的位置。\n\t\t- 如果参数是负数，substring方法会自动将负数转为0。\n\n\t- substr()\n\n\t\t- substr方法用于从原字符串取出子字符串并返回，不改变原字符串。\n\t\t- substr方法的第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。\n\t\t- 如果省略第二个参数，则表示子字符串一直到原字符串的结束。\n\t\t- 如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。\n\n\t- indexOf()，lastIndexOf()\n\n\t\t- 这两个方法用于确定一个字符串在另一个字符串中的位置，都返回一个整数，表示匹配开始的位置。如果返回-1，就表示不匹配。两者的区别在于，indexOf从字符串头部开始匹配，lastIndexOf从尾部开始匹配。\n\n\t\t- 它们还可以接受第二个参数，对于indexOf方法，第二个参数表示从该位置开始向后匹配；对于lastIndexOf，第二个参数表示从该位置起向前匹配。\n\n\t- trim()\n\n\t\t- trim方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。该方法去除的不仅是空格，还包括制表符（\\t、\\v）、换行符（\\n）和回车符（\\r）。\n\n\t\t\t- '\\r\\nabc \\t'.trim() // 'abc'\n\n\t- toLowerCase()，toUpperCase()\n\n\t\t- \ntoLowerCase方法用于将一个字符串全部转为小写，toUpperCase则是全部转为大写。它们都返回一个新字符串，不改变原字符串。\n\t\t- 这个方法也可以将布尔值或数组转为大写字符串，但是需要通过call方法使用。\n\n\t- localeCompare()\n\n\t\t- localeCompare方法用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。\n\n\t- match()\n\n\t\t- match方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。\n\n\t\t- 返回数组还有index属性和input属性，分别表示匹配字符串开始的位置和原始字符串。\n\n\t\t- match方法还可以使用正则表达式作为参数\n\n\t- search()\n\n\t\t- search方法的用法等同于match，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。\n\n\t\t\t- 'cat, bat, sat, fat'.search('at') // 1\n\n\t\t- search方法还可以使用正则表达式作为参数\n\n\t- replace()\n\n\t\t- replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。\n\t- split()\n\n\t\t- split方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。\n\n\t\t\t- 'a|b|c'.split('|') // [\"a\", \"b\", \"c\"]\n\n\t\t- 如果分割规则为空字符串，则返回数组的成员是原字符串的每一个字符。\n\n\t\t\t- 'a|b|c'.split('') // [\"a\", \"|\", \"b\", \"|\", \"c\"]\n\n\t\t- 如果省略参数，则返回数组的唯一成员就是原字符串。\n\n\t\t- 如果满足分割规则的两个部分紧邻着（即中间没有其他字符），则返回数组之中会有一个空字符串。\n\n\t\t- split方法还可以接受第二个参数，限定返回数组的最大成员数。\n\n### Math对象\n\n- 概述\n\n\t- Math是JavaScript的内置对象，提供一系列数学常数和数学方法。该对象不是构造函数，不能生成实例，所有的属性和方法都必须在Math对象上调用。\n\n- 属性\n\n\t- Math.E：常数e。\n\t- Math.LN2：2的自然对数。\n\t- Math.LN10：10的自然对数。\n\t- Math.LOG2E：以2为底的e的对数。\n\t- Math.LOG10E：以10为底的e的对数。\n\t- Math.PI：常数Pi。\n\t- Math.SQRT1_2：0.5的平方根。\n\t- Math.SQRT2：2的平方根。\n\n- 方法\n\n\t- Math.abs()：绝对值\n\n\t\t- Math.abs方法返回参数值的绝对值。\n\n\t- Math.ceil()：向上取整\n\n\t\t- Math.ceil方法接受一个参数，返回大于该参数的最小整数。\n\n\t- Math.floor()：向下取整\n\n\t\t- Math.floor方法接受一个参数，返回小于该参数的最大整数。\n\n\t- Math.max()：最大值\nMath.min()：最小值\n\n\t\t- Math.max方法和Math.min方法都可以接受多个参数，Math.max返回其中最大的参数，Math.min返回最小的参数。有趣的是, Math.min 不传参数返回 Infinity, Math.max 不传参数返回 -Infinity。\n\n\t- Math.pow()：指数运算\n\n\t\t- Math.pow方法返回以第一个参数为底数、第二个参数为幂的指数值。\n\n\t- Math.sqrt()：平方根\n\n\t\t- Math.sqrt方法返回参数值的平方根。如果参数是一个负值，则返回NaN。\n\n\t- Math.log()：自然对数\n\n\t\t- Math.log方法返回以e为底的自然对数值。\n\n\t- Math.exp()：e的指数\n\n\t\t- Math.exp方法返回常数e的参数次方。\n\n\t- Math.round()：四舍五入\n\n\t\t- Math.round方法用于四舍五入。\n\t\t- 注意，它对负数的处理（主要是对0.5的处理）。\n\n\t- Math.random()：随机数\n\n\t\t- Math.random()返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。\n\n\t- 三角函数方法\n\n\t\t- Math.sin()：返回参数的正弦\n\t\t- Math.cos()：返回参数的余弦\n\t\t- Math.tan()：返回参数的正切\n\t\t- Math.asin()：返回参数的反正弦（弧度值）\n\t\t- Math.acos()：返回参数的反余弦（弧度值）\n\t\t- Math.atan()：返回参数的反正切（弧度值）\n\n### Date对象\n\n- 概述\n\n\t- \nDate对象是JavaScript提供的日期和时间的操作接口。它可以表示的时间范围是，1970年1月1日00:00:00前后的各1亿天（单位为毫秒）。\n\t- Date对象可以作为普通函数直接调用，无论有没有参数，总是返回一个代表当前时间的字符串。\n\n- 作为构造函数使用\n\n\t- 不传参数\n\n\t\t- 对它使用new命令，会返回一个Date对象的实例。如果不加参数，生成的就是代表当前时间的对象。\n\t- 传参数\n\n\t\t- （1）new Date(milliseconds)\n\n\t\t\t- Date对象接受从1970年1月1日00:00:00 UTC开始计算的毫秒数作为参数。这意味着如果将Unix时间戳（单位为秒）作为参数，必须将Unix时间戳乘以1000。\n\n\t\t- （2）new Date(datestring)\n\n\t\t\t- Date对象还接受一个日期字符串作为参数，返回所对应的时间。所有可以被Date.parse()方法解析的日期字符串，都可以当作Date对象的参数。\n\t\t\t- 注意\n\n\t\t\t\t- 在ES5之中，如果日期采用连词线（-）格式分隔，且具有前导0（即YYYY-MM-DD），JavaScript会认为这是一个ISO格式的日期字符串，导致返回的时间是以UTC时区计算的。\n\n\t\t- （3）new Date(year, month [, day, hours, minutes, seconds, ms])\n\n\t\t\t- Date对象还可以接受多个整数作为参数，依次表示年、月、日、小时、分钟、秒和毫秒。如果采用这种格式，最少需要提供两个参数（年和月），其他参数都是可选的，默认等于0。因为如果只使用“年”这一个参数，Date对象会将其解释为毫秒数。\n\n- 日期的运算\n\n\t- 类型转换时，Date对象的实例如果转为数值，则等于对应的毫秒数；如果转为字符串，则等于对应的日期字符串。所以，两个日期对象进行减法运算，返回的就是它们间隔的毫秒数；进行加法运算，返回的就是连接后的两个字符串。\n\n- Date对象的静态方法\n\n\t- Date.now()\n\n\t\t- Date.now方法返回当前距离1970年1月1日 00:00:00 UTC的毫秒数（Unix时间戳乘以1000）。\n\n\t- Date.parse()\n\n\t\t- Date.parse方法用来解析日期字符串，返回距离1970年1月1日 00:00:00的毫秒数。\n\t\t- 其解析的参数最好为YYYY-MM-DDTHH:mm:ss.sssZ格式\n\t\t- 如果解析失败，返回NaN。\n\n\t- Date.UTC()\n\n\t\t- 默认情况下，Date对象返回的都是当前时区的时间。Date.UTC方法可以返回UTC时间（世界标准时间）。该方法接受年、月、日等变量作为参数，返回当前距离1970年1月1日 00:00:00 UTC的毫秒数。\n\n- Date实例对象的方法\n\n\t- to类：从Date对象返回一个字符串，表示指定的时间。\n\t- get类：获取Date对象的日期和时间。\n\n\t- set类：设置Date对象的日期和时间。\n\n### RegExp对象\n\n- 概述\n\n\t- 新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束。\n\n\t- 另一种是使用 RegExp 构造函数。\n\n\t- 它们的主要区别是：第一种方法在编译时新建正则表达式，第二种方法在运行时新建正则表达式。\n\t- RegExp 构造函数还可以接受第二个参数，表示修饰符\n\n\t- 正则对象生成以后，有两种使用方式：\n\n\t\t- 正则对象的方法：将字符串作为参数，比如regex.test(string)。\n\t\t- 字符串对象的方法：将正则对象作为参数，比如string.match(regex)。\n\n- 正则对象的属性和方法\n\n\t- 属性\n\n\t\t- 正则对象的属性分成两类。\n\t\t- 一类是修饰符相关，返回一个布尔值，表示对应的修饰符是否设置。\n\n\t\t\t- ignoreCase：返回一个布尔值，表示是否设置了i修饰符，该属性只读。\n\t\t\t- global：返回一个布尔值，表示是否设置了g修饰符，该属性只读。\n\t\t\t- multiline：返回一个布尔值，表示是否设置了m修饰符，该属性只读。\n\n\t\t- 另一类是与修饰符无关的属性，主要是下面两个。\n\n\t\t\t- lastIndex：返回下一次开始搜索的位置。该属性可读写，但是只在设置了g修饰符时有意义。\n\t\t\t- source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。\n\n\t- test()\n\n\t\t- 正则对象的test方法返回一个布尔值，表示当前模式是否能匹配参数字符串。\n\n\t\t- 如果正则表达式带有g修饰符，则每一次test方法都从上一次结束的位置开始向后匹配。\n\n\t\t- 如果正则模式是一个空字符串，则匹配所有字符串。\n\n\t- exec()\n\n\t\t- 正则对象的exec方法，可以返回匹配结果。如果发现匹配，就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null。\n\n\t\t- 圆括号，组匹配\n\n\t\t\t- 如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的length属性等于组匹配的数量再加1。\n\n\t\t- exec方法的返回数组还包含以下两个属性：\n\n\t\t\t- input：整个原字符串。\n\t\t\t- index：整个模式匹配成功的开始位置（从0开始计数）\n\n\t\t- 如果正则表达式加上g修饰符，则可以使用多次exec方法，下一次搜索的位置从上一次匹配成功结束的位置开始。\n\n\t\t- 利用g修饰符允许多次匹配的特点，可以用一个循环完成全部匹配。\n\n\t\t- 正则对象的lastIndex属性不仅可读，还可写。一旦手动设置了lastIndex的值，就会从指定位置开始匹配。但是，这只在设置了g修饰符的情况下，才会有效。\n\n\t\t- 如果正则对象是一个空字符串，则exec方法会匹配成功，但返回的也是空字符串。\n\n- 字符串对象的方法\n\n\t- 字符串对象的方法之中，有4种与正则对象有关。\n\n\t\t- match()：返回一个数组，成员是所有匹配的子字符串。\n\t\t- search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。\n\t\t- replace()：按照给定的正则表达式进行替换，返回替换后的字符串。\n\t\t- split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。\n\n\t- String.prototype.match()\n\n\t\t- 字符串对象的match方法对字符串进行正则匹配，返回匹配结果。\n\n\t\t- 如果正则表达式带有g修饰符，则该方法与正则对象的exec方法行为不同，会一次性返回所有匹配成功的结果。\n\n\t- String.prototype.search()\n\n\t\t- 字符串对象的search方法，返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1。\n\n\t\t- 该方法会忽略g修饰符。\n\n\t- String.prototype.replace()\n\n\t\t- 字符串对象的replace方法可以替换匹配的值。它接受两个参数，第一个是搜索模式，第二个是替换的内容。\n\n\t\t\t- str.replace(search, replacement)\n\n\t\t- 搜索模式如果不加g修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。\n\n\t\t- replace方法的一个应用，就是消除字符串首尾两端的空格。\n\n\t\t- 参数\n\n\t\t\t- replace方法的第二个参数可以使用美元符号$，用来指代所替换的内容。\n\n\t\t\t\t- $& 指代匹配的子字符串。\n\t\t\t\t- $` 指代匹配结果前面的文本。\n\t\t\t\t- $' 指代匹配结果后面的文本。\n\t\t\t\t- $n 指代匹配成功的第n组内容，n是从1开始的自然数。\n\t\t\t\t- $$ 指代美元符号$。\n\n\t\t\t- replace方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值。\n\n\t- String.prototype.split()\n\n\t\t- 字符串对象的split方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。\n\n\t\t\t- str.split(separator, [limit])\n\n\t\t- 该方法接受两个参数，第一个参数是分隔规则，第二个参数是返回数组的最大成员数。\n\n- 匹配规则\n\n\t- 字面量字符和元字符\n\n\t\t- 大部分字符在正则表达式中，就是字面的含义，比如/a/匹配a，/b/匹配b。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的a和b），那么它们就叫做“字面量字符”\n\t\t- 除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”（metacharacters），主要有以下几个。\n\n\t\t\t- （1）点字符（.)\n\n\t\t\t\t- 点字符（.）匹配除回车（\\r）、换行(\\n) 、行分隔符（\\u2028）和段分隔符（\\u2029）以外的所有字符。\n\t\t\t- （2）位置字符\n\n\t\t\t\t- 位置字符用来提示字符所处的位置，主要有两个字符。\n\n\t\t\t\t\t- ^ 表示字符串的开始位置\n\t\t\t\t\t- $ 表示字符串的结束位置\n\n\t\t\t- （3）选择符（|）\n\n\t\t\t\t- 竖线符号（|）在正则表达式中表示“或关系”（OR），即cat|dog表示匹配cat或dog。\n\n\t\t\t\t- 多个选择符可以联合使用。\n\t\t\t\t- 选择符会包括它前后的多个字符，比如/ab|cd/指的是匹配ab或者cd，而不是指匹配b或者c。如果想修改这个行为，可以使用圆括号。\n\n\t\t\t- 其他的元字符还包括\\\\、\\*、+、?、()、[]、{}等，将在下文解释。\n\n\t- 转义符\n\n\t\t- 正则表达式中那些有特殊含义的字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配加号，就要写成\\+。\n\t\t- 正则模式中，需要用斜杠转义的，一共有12个字符：^、.、[、$、(、)、|、*、+、?、{和\\\\。需要特别注意的是，如果使用RegExp方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。\n\n\t- 字符类\n\n\t\t- 定义\n\n\t\t\t- 字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[xyz] 表示x、y、z之中任选一个匹配。\n\n\t\t- 有两个字符在字符类中有特殊含义。\n\n\t\t\t- （1）脱字符（^）\n\n\t\t\t\t- 如果方括号内的第一个字符是[^]，则表示除了字符类之中的字符，其他字符都可以匹配。比如，[^xyz]表示除了x、y、z之外都可以匹配。\n\t\t\t\t- 如果方括号内没有其他字符，即只有[^]，就表示匹配一切字符，其中包括换行符，而点号（.）是不包括换行符的。\n\t\t\t\t- 注意，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。\n\n\t\t\t- （2）连字符（-）\n\n\t\t\t\t- 某些情况下，对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。比如，[abc]可以写成[a-c]，[0123456789]可以写成[0-9]，同理[A-Z]表示26个大写字母。\n\t- 预定义模式\n\n\t\t- 预定义模式指的是某些常见模式的简写方式。\n\n\t\t\t- \\d 匹配0-9之间的任一数字，相当于[0-9]。\n\t\t\t- \\D 匹配所有0-9以外的字符，相当于[^0-9]。\n\t\t\t- \\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。\n\t\t\t- \\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。\n\t\t\t- \\s 匹配空格（包括制表符、空格符、断行符等），相等于[\\t\\r\\n\\v\\f]。\n\t\t\t- \\S 匹配非空格的字符，相当于[^\\t\\r\\n\\v\\f]。\n\t\t\t- \\b 匹配词的边界。\n\t\t\t- \\B 匹配非词边界，即在词的内部。\n\n\t- 重复类\n\n\t\t- 模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。\n\t- 量词符\n\n\t\t- 量词符用来设定某个模式出现的次数。\n\n\t\t\t- ? 问号表示某个模式出现0次或1次，等同于{0, 1}。\n\t\t\t- * 星号表示某个模式出现0次或多次，等同于{0,}。\n\t\t\t- + 加号表示某个模式出现1次或多次，等同于{1,}。\n\n\t- 贪婪模式\n\n\t\t- 定义\n\n\t\t\t- 默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。\n\t\t- 如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。\n\n\t\t- 除了非贪婪模式的加号，还有非贪婪模式的星号（*）。\n\n\t\t\t- *?：表示某个模式出现0次或多次，匹配时采用非贪婪模式。\n\t\t\t- +?：表示某个模式出现1次或多次，匹配时采用非贪婪模式。\n\n\t- 修饰符\n\n\t\t- 修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。可以单个使用，也可以多个一起使用。\n\t\t- （1）g修饰符\n\n\t\t\t- 默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。g修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。\n\n\t\t- （2）i修饰符\n\n\t\t\t- 默认情况下，正则对象区分字母的大小写，加上i修饰符以后表示忽略大小写（ignorecase）。\n\n\t\t- （3）m修饰符\n\n\t\t\t- m修饰符表示多行模式（multiline），会修改^和$的行为。默认情况下（即不加m修饰符时），^和$匹配字符串的开始处和结尾处，加上m修饰符以后，^和$还会匹配行首和行尾，即^和$会识别换行符（\\n）。\n\n\t- 组匹配\n\n\t\t- （1）概述\n\n\t\t\t- \n正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。\n\t\t- 在正则表达式内部，可以用\\n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号。\n\t\t- （2）非捕获组\n\n\t\t\t- (?:x)称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。\n\t\t\t- 非捕获组的作用请考虑这样一个场景，假定需要匹配foo或者foofoo，正则表达式就应该写成/(foo){1, 2}/，但是这样会占用一个组匹配。这时，就可以使用非捕获组，将正则表达式改为/(?:foo){1, 2}/，它的作用与前一个正则是一样的，但是不会单独输出括号内部的内容。\n\n\t\t- （3）先行断言\n\n\t\t\t- x(?=y)称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成/\\d+(?=%)/。\n\n\t\t- （4）先行否定断言\n\n\t\t\t- x(?!y)称为先行否定断言（Negative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成/\\d+(?!%)/。\n\n### JSON对象\n\n- JSON.stringify()\n\n\t- 基本用法\n\n\t\t- JSON.stringify方法用于将一个值转为字符串。该字符串符合 JSON 格式，并且可以被JSON.parse方法还原。\n\t\t- 需要注意的是，对于原始类型的字符串，转换结果会带双引号。\n\t\t- 如果原始对象中，有一个成员的值是undefined、函数或 XML 对象，这个成员会被过滤。\n\t\t- 如果数组的成员是undefined、函数或 XML 对象，则这些值被转成null。\n\t\t- 正则对象会被转成空对象。\n\n\t- 第二个参数\n\n\t\t- JSON.stringify方法还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。这个类似“白名单”的数组，只对对象的属性有效，对数组无效。\n\n\t\t- 第二个参数还可以是一个函数，用来更改JSON.stringify的默认行为。\n\n\t- 第三个参数\n\n\t\t- JSON.stringify还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。\n\n\t- toJSON 方法\n\n\t\t- 如果对象有自定义的toJSON方法，那么JSON.stringify会使用这个方法的返回值作为参数，而忽略原对象的其他属性。\n\n- JSON.parse()\n\n\t- JSON.parse方法用于将JSON字符串转化成对象。\n\n\t- JSON.parse方法可以接受一个处理函数，用法与JSON.stringify方法类似。\n\n### console对象\n\n### 属性描述对象\n\n- 概述\n\n\t- JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为“属性描述对象”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。\n\t- 属性描述对象提供6个元属性。\n\n\t\t- （1）value\n\n\t\t\t- value是该属性的属性值，默认为undefined。\n\n\t\t- （2）writable\n\n\t\t\t- writable是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为true。\n\n\t\t- （3）enumerable\n\n\t\t  具体来说，如果一个属性的enumerable为false，下面三个操作不会取到该属性。\n\n\t\t  \n\n\t\t  for..in循环\n\n\t\t  Object.keys方法\n\n\t\t  JSON.stringify方法\n\n\t\t\t- enumerable是一个布尔值，表示该属性是否可遍历，默认为true。如果设为false，会使得某些操作（比如for...in循环、Object.keys()）跳过该属性。\n\n\t\t- （4）configurable\n\n\t\t\t- configurable是一个布尔值，表示可配置性，默认为true。如果设为false，将阻止某些操作改写该属性，比如无法删除该属性，也不得改变该属性的属性描述对象（value属性除外）。也就是说，configurable属性控制了属性描述对象的可写性。\n\n\t\t\t\t- 可配置性决定了目标属性是否可以被删除（delete）。\n\n\t\t- （5）get\n\n\t\t\t- get是一个函数，表示该属性的取值函数（getter），默认为undefined。\n\n\t\t- （6）set\n\n\t\t\t- set是一个函数，表示该属性的存值函数（setter），默认为undefined。\n\n- Object.getOwnPropertyDescriptor()\n\n\t- Object.getOwnPropertyDescriptor方法可以获取属性描述对象。它的第一个参数是一个对象，第二个参数是一个字符串，对应该对象的某个属性名。\n\t- 注意，Object.getOwnPropertyDescriptor方法只能用于对象自身的属性，不能用于继承的属性。\n\n- Object.getOwnPropertyNames()\n\n\t- Object.getOwnPropertyNames方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。\n- Object.defineProperty()，Object.defineProperties()\n\n\t- Object.defineProperty方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象，它的用法如下。\n\t- Object.defineProperty方法接受三个参数，依次如下。\n\n\t\t- 属性所在的对象\n\t\t- 属性名（它应该是一个字符串）\n\t\t- 属性描述对象\n\n\t- 如果属性已经存在，Object.defineProperty方法相当于更新该属性的属性描述对象。\n\t- 注意，一旦定义了取值函数get（或存值函数set），就不能将writable属性设为true，或者同时定义value属性，否则会报错。\n\n- Object.prototype.propertyIsEnumerable()\n\n\t- 实例对象的propertyIsEnumerable方法返回一个布尔值，用来判断某个属性是否可遍历。\n- 存取器\n\n\t- 定义\n\n\t\t- 除了直接定义以外，属性还可以用存取器（accessor）定义。其中，存值函数称为setter，使用属性描述对象的set属性；取值函数称为getter，使用属性描述对象的get属性。\n\n\t- 一旦对目标属性定义了存取器，那么存取的时候，都将执行对应的函数。利用这个功能，可以实现许多高级特性，比如某个属性禁止赋值。\n\n\t- JavaScript 还提供了存取器的另一种写法。\n\n\t- 注意，取值函数get不能接受参数，存值函数set只能接受一个参数（即属性的值）。\n\t- 存取器往往用于，属性的值依赖对象内部数据的场合。\n\n- 对象的拷贝\n- 控制对象状态\n\n\t- 概述\n\n\t\t- 有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供了三种冻结方法，最弱的一种是Object.preventExtensions，其次是Object.seal，最强的是Object.freeze。\n\n\t- Object.preventExtensions()\n\n\t\t- Object.preventExtensions方法可以使得一个对象无法再添加新的属性。\n\n\t\t- Object.isExtensible()\n\n\t\t\t- Object.isExtensible方法用于检查一个对象是否使用了Object.preventExtensions方法。也就是说，检查是否可以为一个对象添加属性。\n\n\t- Object.seal()\n\n\t\t- Object.seal方法使得一个对象既无法添加新属性，也无法删除旧属性。Object.seal只是禁止新增或删除属性，并不影响修改某个属性的值。\n\n\t\t- Object.isSealed()\n\n\t\t\t- Object.isSealed方法用于检查一个对象是否使用了Object.seal方法。\n\n\t- Object.freeze()\n\n\t\t- Object.freeze方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。\n\n\t\t- Object.isFrozen()\n\n\t\t\t- Object.isFrozen方法用于检查一个对象是否使用了Object.freeze方法。\n\n\t- 局限性\n\n\t\t- 上面的三个方法锁定对象的可写性有一个漏洞：可以通过改变原型对象，来为对象增加属性。\n\n\t\t- 另外一个局限是，如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容。\n\n## 阮一峰·JS面向对 象编程\n\n### 构造函数与 new 命令\n\n- 对象是什么\n\n\t- （1）对象是单个实物的抽象。\n\t- （2）对象是一个容器，封装了属性（property）和方法（method）。\n\n- 构造函数\n\n\t- 典型的面向对象编程语言（比如 C++ 和 Java），存在“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。\n\t- JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成对象的函数。它提供模板，描述对象的基本结构。一个构造函数，可以生成多个对象，这些对象都有相同的结构。\n\t- 构造函数的特点有两个。\n\n\t\t- 函数体内部使用了this关键字，代表了所要生成的对象实例。\n\t\t- 生成对象的时候，必需用new命令，调用Vehicle函数。\n\n- new 命令\n\n\t- 基本用法\n\n\t\t- new命令的作用，就是执行构造函数，返回一个实例对象。\n\n\t\t\t- new命令执行时，构造函数内部的this，就代表了新生成的实例对象\n\n\t\t- 使用new命令时，根据需要，构造函数也可以接受参数。\n\n\t\t- new命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。\n\t\t- 如果忘了使用new命令，直接调用构造函数会发生什么事？\n\n\t\t\t- 这种情况下，构造函数就变成了普通函数，并不会生成实例对象。而且由于后面会说到的原因，this这时代表全局对象，将造成一些意想不到的结果。\n\n\t\t\t- 解决方法\n\n\t\t\t\t- 一个解决办法是，在构造函数内部使用严格模式，即第一行加上use strict。\n\t\t\t\t- 另一个解决办法，是在构造函数内部判断是否使用new命令，如果发现没有使用，则直接返回一个实例对象。\n\n\t- new 命令的原理\n\n\t\t- 概述\n\n\t\t\t- 使用new命令时，它后面的函数调用就不是正常的调用，而是依次执行下面的步骤。\n\t\t\t- （1）创建一个空对象，作为将要返回的对象实例\n\t\t\t- （2）将这个空对象的原型，指向构造函数的prototype属性\n\t\t\t- （3）将这个空对象赋值给函数内部的this关键字\n\t\t\t- （4）开始执行构造函数内部的代码\n\n\t\t- 原理\n\n\t\t\t- 构造函数内部，this指的是一个新生成的空对象，所有针对this的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即this对象），将其“构造”为需要的样子。\n\n\t\t- 构造函数有return的情况\n\n\t\t\t- 如果构造函数内部有return语句，而且return后面跟着一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。\n\n\t\t- 构造函数没有this而使用new来构造的情况\n\n\t\t\t- 如果对普通函数（内部没有this关键字的函数）使用new命令，则会返回一个空对象。\n\n\t\t- new命令简化的内部流程\n\n\t- new.target\n\n\t\t- 定义\n\n\t\t\t- 函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined。\n\n\t\t- 使用\n\n\t\t\t- 使用这个属性，可以判断函数调用的时候，是否使用new命令。\n\n\t- 使用 Object.create() 创建实例对象\n\n\t\t- 使用Object.create()方法，直接以某个实例对象作为模板，生成一个新的实例对象。\n### this 关键字\n\n- 使用场合\n\n\t- （1）全局环境\n\n\t\t- 在全局环境使用this，它指的就是顶层对象window。\n\n\t- （2）构造函数\n\n\t\t- 构造函数中的this，指的是实例对象。\n\n\t- （3）对象的方法\n\n\t\t- 当 A 对象的方法被赋予 B 对象，该方法中的this就从指向 A 对象变成了指向 B 对象。所以要特别小心，将某个对象的方法赋值给另一个对象，会改变this的指向。\n\n- 使用注意点\n\n\t- （1）避免多层 this\n\n\t\t- 一个解决方法是在第二层改用一个指向外层this的变量。\n\n\t\t- JavaScript 提供了严格模式，也可以硬性避免这种问题。在严格模式下，如果函数内部的this指向顶层对象，就会报错。\n\n\t- （2）避免数组处理方法中的this\n\n\t\t- 数组的map和foreach方法，允许提供一个函数作为参数。这个函数内部不应该使用this。\n\n\t\t\t- 解决这个问题的一种方法，是使用中间变量。\n\n\t\t\t- 另一种方法是将this当作foreach方法的第二个参数，固定它的运行环境。\n\n\t- （3）避免回调函数中的this\n\n\t\t- 回调函数中的this往往会改变指向，最好避免使用。\n\n- 绑定 this 的方法\n\n\t- 概述\n\n\t\t- JavaScript提供了call、apply、bind这三个方法，来切换/固定this的指向。\n\n\t- function.prototype.call()\n\n\t\t- 函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。\n\t\t- call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。\n\n\t\t- call的第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数。\n\t\t- 应用\n\n\t\t\t- call方法的一个应用是调用对象的原生方法。\n\n\t- function.prototype.apply()\n\n\t\t- apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。func.apply(thisValue, [arg1, arg2, ...])\n\t\t- 应用\n\n\t\t\t- （1）找出数组最大元素\n\n\t\t\t  var a = [10, 2, 4, 15, 9];\n\n\t\t\t  \n\n\t\t\t  Math.max.apply(null, a)\n\n\t\t\t  // 15\n\n\t\t\t\t- JavaScript不提供找出数组最大元素的函数。结合使用apply方法和Math.max方法，就可以返回数组的最大元素。\n\n\t\t\t- （2）将数组的空元素变为undefined\n\n\t\t\t  Array.apply(null, [\"a\",,\"b\"])\n\n\t\t\t  // [ 'a', undefined, 'b' ]\n\n\t\t\t\t- 空元素与undefined的差别在于，数组的forEach方法会跳过空元素，但是不会跳过undefined。因此，遍历内部元素的时候，会得到不同的结果。\n\n\t\t\t- （3）转换类似数组的对象\n\n\t\t\t  Array.prototype.slice.apply({0:1,length:1})\n\n\t\t\t  // [1]\n\n\t\t\t  \n\n\t\t\t  Array.prototype.slice.apply({0:1})\n\n\t\t\t  // []\n\n\t\t\t  \n\n\t\t\t  Array.prototype.slice.apply({0:1,length:2})\n\n\t\t\t  // [1, undefined]\n\n\t\t\t  \n\n\t\t\t  Array.prototype.slice.apply({length:1})\n\n\t\t\t  // [undefined]\n\n\t\t\t\t- 上面代码的apply方法的参数都是对象，但是返回结果都是数组，这个方法起作用的前提是，被处理的对象必须有length属性，以及相对应的数字键。\n\n\t\t\t- （4）绑定回调函数的对象\n\n\t\t\t  var o = new Object();\n\n\t\t\t  \n\n\t\t\t  o.f = function () {\n\n\t\t\t    console.log(this === o);\n\n\t\t\t  }\n\n\t\t\t  \n\n\t\t\t  var f = function (){\n\n\t\t\t    o.f.apply(o);\n\n\t\t\t    // 或者 o.f.call(o);\n\n\t\t\t  };\n\n\t\t\t  \n\n\t\t\t  $('#button').on('click', f);\n\n\t- function.prototype.bind()\n\n\t\t- 概述\n\n\t\t\t- bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。\n\n\t\t- bind比call方法和apply方法更进一步的是，除了绑定this以外，还可以绑定原函数的参数。\n\n\t\t- 如果bind方法的第一个参数是null或undefined，等于将this绑定到全局对象，函数运行时this指向顶层对象（在浏览器中为window）。\n\t\t- bind方法有一些使用注意点。\n\n\t\t\t- （1）每一次返回一个新函数\n\n\t\t\t\t- 监听事件的时候，不能写成下面这样。element.addEventListener('click', o.m.bind(o));\nclick事件绑定bind方法生成的一个匿名函数。这样会导致无法取消绑定\n\t\t\t\t- 正确的方法是写成下面这样：\n\n\t\t\t\t\t- var listener = o.m.bind(o);\nelement.addEventListener('click', listener);\n//  ...\nelement.removeEventListener('click', listener);\n\n\t\t\t- （2）结合回调函数使用\n\n\t\t\t\t- 回调函数是JavaScript最常用的模式之一，但是一个常见的错误是，将包含this的方法直接当作回调函数。\n\t\t\t\t- 还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。这些函数内部的this指向，很可能也会出错。\n\n\t\t\t- （3）结合call方法使用\n\n\t\t\t\t- 利用bind方法，可以改写一些JavaScript原生方法的使用形式，以数组的slice方法为例。\n\n\t\t\t- （4）与call，apply的区别\n\n\t\t\t\t- call和apply都是改变上下文中的this并立即执行这个函数，bind方法可以让对应的函数想什么时候调就什么时候调用，并且可以将参数在执行的时候添加，这是它们的区别\n\n### prototype 对象\n\n- 概述\n\n\t- 通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。\n\n- prototype 属性的作用\n\n\t- JavaScript 的每个对象都继承另一个对象，后者称为“原型”（prototype）对象\n\t- 原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在所有实例对象上。\n\n\t\t- 当实例对象本身没有某个属性或方法的时候，它会到构造函数的prototype属性指向的对象，去寻找该属性或方法。这就是原型对象的特殊之处。\n\t\t- 如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。\n\n\t- 总结\n\n\t\t- 原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象。\n\n- 原型链\n\n\t- 原型链的作用\n\n\t\t- “原型链”的作用是，读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的Object.prototype还是找不到，则返回undefined。\n\n\t- 对于性能的影响\n\n\t\t- 需要注意的是，一级级向上，在原型链寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。\n\n\t- 举例\n\n\t\t- 如果让某个函数的prototype属性指向一个数组，就意味着该函数可以当作数组的构造函数，因为它生成的实例对象都可以通过prototype属性调用数组方法。\n\n- constructor 属性\n\n\t- prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。\n\n\t- 由于constructor属性定义在prototype对象上面，意味着可以被所有实例对象继承。\n\t- 作用\n\n\t\t- constructor属性的作用，是分辨原型对象到底属于哪个构造函数。\n\n\t- 应用\n\n\t\t- 有了constructor属性，就可以从实例新建另一个实例。\n\n\t\t- 这使得在实例方法中，调用自身的构造函数成为可能。\n\n\t\t\t- Constr.prototype.createCopy = function () {\n  return new this.constructor();\n};\n\n\t- 注意\n\n\t\t- 修改原型对象时，一般要同时校正constructor属性的指向。\n\n- instanceof 运算符\n\n\t- instanceof运算符返回一个布尔值，表示某个对象是否为指定的构造函数的实例。\n\n\t- 它会检查右边构建函数的原型对象（prototype），是否在左边对象的原型链上。\n\n\t- 由于instanceof对整个原型链上的对象都有效，因此同一个实例对象，可能会对多个构造函数都返回true。\n\n\t- 注意\n\n\t\t- instanceof运算符在判断类型的值时只能用于对象，不适用原始类型的值。\n\t\t- 对于undefined和null，instanceOf运算符总是返回false。\n\n- Object.getPrototypeOf()\n\n\t- Object.getPrototypeOf方法返回一个对象的原型。这是获取原型对象的标准方法。\n\n- Object.setPrototypeOf()\n\n\t- Object.setPrototypeOf方法可以为现有对象设置原型，返回一个新对象。\n\t- Object.setPrototypeOf方法接受两个参数，第一个是现有对象，第二个是原型对象。\n\n- Object.create()\n\n\t- 由来\n\n\t\t- 生成实例对象的常用方法，就是使用new命令，让构造函数返回一个实例。但是很多时候，只能拿到一个实例对象，它可能根本不是由构建函数生成的，那么能不能从一个实例对象，生成另一个实例对象呢？\n\n\t- 概述\n\n\t\t- JavaScript 提供了Object.create方法，用来满足这种需求。该方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。该实例完全继承原型对象的属性。\n\n\t- 手动实现Object.create()\n\n\t\t\t- Object.create方法的实质是新建一个构造函数F，然后让F.prototype属性指向参数对象obj，最后返回一个F的实例，从而实现让该实例继承obj的属性。\n\n\t- 注意\n\n\t\t- 如果想要生成一个不继承任何属性（比如没有toString和valueOf方法）的对象，可以将Object.create的参数设为null。\n\n\t\t- 使用Object.create方法的时候，必须提供对象原型，即参数不能为空，或者不是对象，否则会报错。\n\t\t- Object.create方法生成的对象，继承了它的原型对象的构造函数。\n\n- Object.prototype.isPrototypeOf()\n\n\t- 对象实例的isPrototypeOf方法，用来判断一个对象是否是另一个对象的原型。\n\n\t- 只要某个对象处在原型链上，isPrototypeOf都返回true。\n\n- Object.prototype.__proto__\n\n\t- 概述\n\n\t\t- __proto__属性（前后各两个下划线）可以改写某个对象的原型对象。\n\n\t- 注意事项\n\n\t\t- 根据语言标准，__proto__属性只有浏览器才需要部署，其他环境可以没有这个属性，而且前后的两根下划线，表示它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用Object.getPrototypeof()（读取）和Object.setPrototypeOf()（设置），进行原型对象的读写操作。\n\n- 获取原型对象方法的比较\n\n\t- 获取实例对象obj的原型对象，有三种方法。\n\n\t\t- obj.__proto__\n\t\t- obj.constructor.prototype\n\t\t- Object.getPrototypeOf(obj)\n\n\t- 上面三种方法之中，前两种都不是很可靠。最新的ES6标准规定，__proto__属性只有浏览器才需要部署，其他环境可以不部署。而obj.constructor.prototype在手动改变原型对象时，可能会失效。\n\t- 推荐使用第三种Object.getPrototypeOf方法，获取原型对象。\n\n### Object 对象与继承\n\n- Object.getOwnPropertyNames()\n\n\t- 定义\n\n\t\t- Object.getOwnPropertyNames方法返回一个数组，成员是对象本身的所有属性的键名，不包含继承的属性键名。\n\n\t- 与Object.keys()对比\n\n\t\t- 对象本身的属性之中，有的是可以枚举的（enumerable），有的是不可以枚举的，Object.getOwnPropertyNames方法返回所有键名。只获取那些可以枚举的属性，使用Object.keys方法。\n\n- Object.prototype.hasOwnProperty()\n\n\t- 定义\n\n\t\t- 对象实例的hasOwnProperty方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上。\n\n\t- 特点\n\n\t\t- hasOwnProperty方法是JavaScript之中唯一一个处理对象属性时，不会遍历原型链的方法。\n\n- 对象的拷贝\n\n\t- 初步认识\n\n\t\t- 如果要拷贝一个对象，需要做到下面两件事情。\n\n\t\t\t- 确保拷贝后的对象，与原对象具有同样的prototype原型对象。\n\t\t\t- 确保拷贝后的对象，与原对象具有同样的属性。\n\n\t- ES5版本\n\n\t  function copyObject(orig) {\n\n\t  -  var copy = Object.create(Object.getPrototypeOf(orig));\n\n\t   -  copyOwnPropertiesFrom(copy, orig);\n\n\t   -  return copy;\n\n\t  }\n\n\t  \n\n\t  function copyOwnPropertiesFrom(target, source) {\n\n\t    Object\n\n\t    .getOwnPropertyNames(source)\n\n\t    .forEach(function(propKey) {\n\n\t      var desc = Object.getOwnPropertyDescriptor(source, propKey);\n\n\t      Object.defineProperty(target, propKey, desc);\n\n\t    });\n\n\t    return target;\n\n\t  }\n\n\t- 另一种更简单的写法，是利用 ES2017 才引入标准的Object.getOwnPropertyDescriptors方法。\n\n\t  function copyObject(orig) {\n\n\t    return Object.create(\n\n\t      Object.getPrototypeOf(orig),\n\n\t      Object.getOwnPropertyDescriptors(orig)\n\n\t    );\n\n\t  }\n\n### 面向对象编程的模式\n\n- 构造函数的继承（注意是构造函数之间的继承，和构造函数通过new关键字生成实例是不一样的）\n\n\t- 写法一：让一个构造函数继承另一个构造函数，是非常常见的需求。这可以分成两步实现。\n\n\t\t- 第一步是在子类的构造函数中，调用父类的构造函数。（注意没有new，相当于普通函数，借用了他的属性而已，这一步相当于拷贝了父构造函数的属性且this为子构造函数下的this）\n\n\t\t\t\t- 第一步为复制属性\n\n\t\t- 第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型（使用creat是为了不让子构造函数的原型对象影响到父构造函数的原型对象，后两行是指定修改子构造函数为其实例的构造函数，修改原型对象时，一般要同时校正constructor属性的指向。以及自定义方法）\n\n\t\t\t\t- 第二步为继承父构造函数原型对象上的方法\n\n\t- 写法二：直接让Sub.prototype等于一个父类实例。\n\n\t\t- Sub.prototype = new Super();\n\t\t- 上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以不推荐使用这种写法。\n\n\t- 举例说明\n\n\t\t- 整体继承\n\n\t\t- 单个方法的继承\n\n- 多重继承（Mixin混入）\n\n\t- 概述\n\n\t\t- JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。\n\t\t- Object.assign({},obj,obj1);\n\n\t\t\t- 花括号叫目标对象，后面的obj、obj1是源对象。对象合并是指：将源对象里面的属性添加到目标对象中去，若两者的属性名有冲突，后面的将会覆盖前面的\n\n\t- 实例\n\n\t\t\t- 子类S同时继承了父类M1和M2。这种模式又称为 Mixin（混入）。\n\n- 模块\n\n\t- 基本的实现方法\n\n\t\t- 概述\n\n\t\t\t- 模块是实现特定功能的一组属性和方法的封装。\n\n\t\t- 可以把模块写成一个对象，所有的模块成员都放到这个对象里面。\n\n\t\t\t- 上面的函数m1和m2，都封装在module1对象里。使用的时候，就是调用这个对象的属性。\n\n\t\t\t\t- module1.m1();\n\n\t\t\t- 但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。\n\n\t\t\t\t- module1._count = 5;\n\n\t- 封装私有变量：构造函数的写法\n\n\t\t- 可以利用构造函数，封装私有变量。\n\n\t\t\t- 这种方法将私有变量封装在构造函数中，违反了构造函数与实例对象相分离的原则。并且，非常耗费内存。\n\t\t\t- 这种方法将私有变量放入实例对象中，好处是看上去更自然，但是它的私有变量可以从外部读写，不是很安全。\n\n\t- 封装私有变量：立即执行函数的写法\n\n\t\t- 使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。\n\n\t\t\t- 使用上面的写法，外部代码无法读取内部的_count变量。\n\n\t- 模块的扩展模式\n\n\t\t- 如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）。\n\n\t\t\t- 上面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。\n\n\t\t- 在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽扩展模式”（Loose augmentation）。\n\n\t\t\t- 与”扩展模式”相比，“宽扩展模式”就是“立即执行函数”的参数可以是空对象。\n\n\t- 输入全局变量\n\n\t\t- 独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。\n\t\t- 为了在模块内部调用全局变量，必须显式地将其他变量输入模块。\n\n\t\t\t- 上面的module1模块需要使用jQuery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module1。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。\n\n## 阮一峰·JS语法 专题\n\n### 定时器\n\n- setTimeout()\n\n  过了一定时间执行一次，只执行一次。比如隔一秒后执行一次，过了十万八千秒后也只在第一秒执行了一次，仅有的一次\n\n\t- 参数\n\n\t\t- 除了前两个参数，setTimeout还允许添加更多的参数。它们将被传入推迟执行的函数（回调函数）。\n\n\t- 需要注意的地方\n\n\t\t- 如果被setTimeout推迟执行的回调函数是某个对象的方法，那么该方法中的this关键字将指向全局环境，而不是定义时所在的那个对象。\n\n- setInterval()\n\n  每间隔一定时间执行一次，循环往复。比如每隔一秒执行一次，六十秒过后执行了60次\n\n\t- 应用\n\n\t\t- 一个通过setInterval方法实现网页动画的例子\n\n\t\t- setInterval的一个常见用途是实现轮询。下面是一个轮询URL的Hash值是否发生变化的例子。\n\n\t- 注意\n\n\t\t- setInterval指定的是“开始执行”之间的间隔，并不考虑每次任务执行本身所消耗的时间。因此实际上，两次执行之间的间隔会小于指定的时间。比如，setInterval指定每100ms执行一次，每次执行需要5ms，那么第一次执行结束后95毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要105毫秒，那么它结束后，下一次执行就会立即开始。\n\n\t- 用setTimeOut代替\n\n\t\t- 为了确保两次执行之间有固定的间隔，可以不用setInterval，而是每次执行结束后，使用setTimeout指定下一次执行的具体时间。\n\n- clearTimeout()，clearInterval()\n\n\t- 函数防抖\n\n\t\t- 就是如果用户连续击键，就会连续触发keydown事件，造成大量的Ajax通信。这是不必要的，而且很可能会发生性能问题。正确的做法应该是，设置一个门槛值，表示两次Ajax通信的最小间隔时间。如果在设定的时间内，发生新的keydown事件，则不触发Ajax通信，并且重新开始计时。如果过了指定时间，没有发生新的keydown事件，将进行Ajax通信将数据发送出去。\n\t\t- 这种做法叫做debounce（防抖动）方法，用来返回一个新函数。只有当两次触发之间的时间间隔大于事先设定的值，这个新函数才会运行实际的任务。假定两次Ajax通信的间隔不小于2500毫秒，上面的代码可以改写成下面这样。\n\n\t\t\t- $('textarea').on('keydown', ajaxAction);\n\t\t\t- $('textarea').on('keydown', debounce(ajaxAction, 2500))\n\t\t- 注意\n\n\t\t\t- 现实中，最好不要设置太多个setTimeout和setInterval，它们耗费CPU。比较理想的做法是，将要推迟执行的代码都放在一个函数里，然后只对这个函数使用setTimeout或setInterval。\n\n- 应用\n\n\t- 它的一大应用是，可以调整事件的发生顺序。比如，网页开发中，某个事件先发生在子元素，然后冒泡到父元素，即子元素的事件回调函数，会早于父元素的事件回调函数触发。如果，我们先让父元素的事件回调函数先发生，就要用到setTimeout(f, 0)。\n\n\t- 用户自定义的回调函数，通常在浏览器的默认动作之前触发。比如，用户在输入框输入文本，keypress事件会在浏览器接收文本之前触发。因此，下面的回调函数是达不到目的的。\n\n\t- 由于setTimeout(f,0)实际上意味着，将任务放到浏览器最早可得的空闲时段执行，所以那些计算量大、耗时长的任务，常常会被放到几个小部分，分别放到setTimeout(f,0)里面执行。\n\n\t\t\t- 上面代码有两种写法，都是改变一个网页元素的背景色。写法一会造成浏览器“堵塞”，因为JavaScript执行速度远高于DOM，会造成大量DOM操作“堆积”，而写法二就不会，这就是setTimeout(f, 0)的好处。\n\t\t\t- 另一个使用这种技巧的例子是代码高亮的处理。如果代码块很大，一次性处理，可能会对性能造成很大的压力，那么将其分成一个个小块，一次处理一块，比如写成setTimeout(highlightNext, 50)的样子，性能压力就会减轻。\n\n### Promise对象\n\n- JavaScript的异步执行\n\n\t- 概述\n\n\t\t- JavaScript 语言本身并不慢，慢的是读写外部数据，比如等待 Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。\n\t\t- 异步模式\n\n\t\t\t- “异步模式”中，每一个任务分成两段，第一段代码包含对外部数据的请求，第二段代码被写成一个回调函数，包含了对外部数据的处理。第一段代码执行完，不是立刻执行第二段代码，而是将程序的执行权交给第二个任务。等到外部数据返回了，再由系统通知执行第二段代码。所以，程序的执行顺序与任务的排列顺序是不一致的、异步的。\n\n\t- 回调函数\n\n\t\t- 定义\n\n\t\t\t- 假定有两个函数f1和f2，后者必须等到前者执行完成，才能执行。这时，可以考虑改写f1，把f2写成f1的回调函数。\n\n\t\t- 优缺点\n\n\t\t\t- 回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），使得程序结构混乱、流程难以追踪（尤其是回调函数嵌套的情况），而且每个任务只能指定一个回调函数。\n\n\t- 事件监听\n\n\t\t- 定义\n\n\t\t\t- \n另一种思路是采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。\n\n\t\t- 做法\n\n\t\t\t- 还是以f1和f2为例。首先，为f1绑定一个事件（这里采用的jQuery的写法）。\n\n\t\t\t\t- f1.on('done', f2);\n\n\t\t\t- 上面这行代码的意思是，当f1发生done事件，就执行f2。然后，对f1进行改写：\n\n\t\t\t\t- function f1(){\n  setTimeout(function () {\n    // f1的任务代码\n    f1.trigger('done');\n  }, 1000);\n}\n\n\t\t\t- 上面代码中，f1.trigger('done')表示，执行完成后，立即触发done事件，从而开始执行f2。\n\n\t\t- 优缺点\n\n\t\t\t- 这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合“（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。\n\n\t- 发布/订阅\n\n\t\t- 定义\n\n\t\t\t- “事件”完全可以理解成”信号”，如果存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式“，又称”观察者模式“。\n\n\t\t- 实现（采用一个插件来实现）\n\n\t\t\t- 首先，f2向”信号中心”jQuery订阅”done”信号。\n\n\t\t\t- 然后，f1进行如下改写：\n\n\t\t\t- f2完成执行后，也可以取消订阅（unsubscribe）。\n\n\t\t- 优缺点\n\n\t\t\t- 这种方法的性质与”事件监听”类似，但是明显优于后者。因为我们可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。\n\n- 异步操作的流程控制\n\n\t- 初步认识\n\n\t\t- 如果有多个异步操作，就存在一个流程控制的问题：确定操作执行的顺序，以后如何保证遵守这种顺序。\n\t\t- 回调函数的嵌套\n\n\t\t\t- async函数是一个异步任务，非常耗时，每次执行需要1秒才能完成，然后再调用回调函数。\n\n\t\t\t- 如果有6个这样的异步任务，需要全部完成后，才能执行下一步的final函数。\n\n\t\t\t- 只能采用6个回调函数的嵌套，不仅写起来麻烦，易出错，且难维护\n\n\t- 串行执行\n\n\t\t- 我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。\n\t\t\t- 此处定义的async第一个参数是异步任务的参数，第二个参数是异步任务的回调函数，这里回调函数直接在调用的时候才定义\n\n\t\t- 上面代码中，函数series就是串行函数，它会依次执行异步任务，所有任务都完成后，才会执行final函数。items数组保存每一个异步任务的参数，results数组保存每一个异步任务的运行结果。\n\n\t- 并行执行\n\n\t\t- 流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行final函数。\n\t\t- 上面代码中，forEach方法会同时发起6个异步任务，等到它们全部完成以后，才会执行final函数。\n\t\t- 优缺点\n\n\t\t\t- 并行执行的好处是效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。\n\n\n\n\t\t- 所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行n个异步任务。这样就避免了过分占用系统资源。\n\t\t- 上面代码中，最多只能同时运行两个异步任务。变量running记录当前正在运行的任务数，只要低于门槛值，就再启动一个新的任务，如果等于0，就表示所有任务都执行完了，这时就执行final函数。\n\n- Promise对象\n\n\t- 简介\n\n\t\t- Promise 对象是 CommonJS 工作组提出的一种规范，目的是为异步操作提供统一接口。\n\t\t- 初步认识\n\n\t\t\t- 首先，它是一个对象，也就是说与其他JavaScript对象的用法，没有什么两样；其次，它起到代理作用（proxy），充当异步操作与回调函数之间的中介。它使得异步操作具备同步操作的接口，使得程序具备正常的同步运行的流程，回调函数不必再一层层嵌套。\n\n\t\t- 三种状态\n\n\t\t\t- 异步操作未完成（pending）\n\t\t\t- 异步操作成功（fulfilled）\n\t\t\t- 异步操作失败（rejected）\n\n\t\t- 使用\n\n\t\t\t- 它的思想是，每一个异步任务立刻返回一个Promise对象，由于是立刻返回，所以可以采用同步操作的流程。这个Promises对象有一个then方法，允许指定回调函数，在异步任务完成后调用。\n\n\t\t\t\t- 比如，异步操作f1返回一个Promise对象，它的回调函数f2写法如下。\n\n\t\t\t\t- 这种写法对于多层嵌套的回调函数尤其方便。\n\n\t\t- 总结\n\n\t\t\t- 总的来说，传统的回调函数写法使得代码混成一团，变得横向发展而不是向下发展。Promises规范就是为了解决这个问题而提出的，目标是使用正常的程序流程（同步），来处理异步操作。它先返回一个Promise对象，后面的操作以同步的方式，寄存在这个对象上面。等到异步操作有了结果，再执行前期寄放在它上面的其他操作。\n\n\t- Promise接口\n\n\t\t- Promise接口的基本思想是，异步任务返回一个Promise对象。\n\t\t- Promise对象的最终结果只有两种。\n\n\t\t\t- 异步操作成功，Promise对象传回一个值，状态变为resolved。\n\t\t\t- 异步操作失败，Promise对象抛出一个错误，状态变为rejected。\n\n\t\t- 回调函数then\n\n\t\t\t- Promise对象使用then方法添加回调函数。then方法可以接受两个回调函数，第一个是异步操作成功时（变为resolved状态）时的回调函数，第二个是异步操作失败（变为rejected）时的回调函数（可以省略）。一旦状态改变，就调用相应的回调函数。\n\n\t\t\t- then方法可以链式使用。\n\n- Promise的应用\n\n*XMind: ZEN - Trial Version*",Ja={data:function(){return{MainComponent:Ra}}},La=Ja,Ha=Object(v["a"])(La,za,$a,!1,null,"003063ce",null),qa=Ha.exports,Fa=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{},[e("q-markdown",{attrs:{src:t.MainComponent}})],1)},Wa=[],Ba="# ts\n\n## TypeScript语法\n\n### 基本数据类型\n\n- 布尔值\n\n\t- let isDone:boolean = false;\n\t- let createdByBoolean:boolean = Boolean(1);\n\t- 区别于let newBool:boolean = new Boolean(1);  返回的是Boolean对象\n\n- 数字类型\n\n\t- let decLiteral: number = 6;\n\n- 字符串\n\n\t- let myName: string = 'Tom';\n\t- 模板字符串 let sentence: string = `Hello, my name is ${myName}\n\n- 空值\n\n\t- 用void表示没有任何返回值的函数  \nfunction alertName(): void {\n    alert('My name is Tom');\n}\n\t- void 类型只能被赋值为 undefined 和 null;\n\n\t\t- let unusable: void = undefined;\n\n- null\n\n\t- let n: null = null;\n\t- let num: number = undefined;\n\n- undefined\n\n\t- let u: undefined = undefined;\n\n### 对象类型\n\n- 对象\n\n\t- 接口（Interfaces）\n\n\t\t- 用法1：用于对类的一部分行为进行抽象\n\n\t\t  https://ts.xcatliu.com/advanced/class-and-interfaces.html\n\n\t\t- 用法2：对「对象的形状（Shape）」进行描述。\n\n\t\t\t- 属性名必须完全一致：\ninterface Person {\n    name: string;\n    age: number;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25\n};\n\n\t\t\t\t- 注意：定义的变量比接口多或者少 都是不允许的\n\n\t\t\t- 可选属性：\ninterface Person {\n    name: string;\n    age?: number;\n}\n\nlet tom: Person = {\n    name: 'Tom'\n};\n\n\t\t\t\t- 注意：这时仍然不允许添加未定义的属性\n\n\t\t\t- 任意属性：\ninterface Person {\n    name: string;\n    age?: number;\n    [propName: string]: string;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25,\n    gender: 'male'\n};\n\n\t\t\t\t- 注意：一旦定义了任意属性，那么确定属性和可选属性都必须是它的子属性：\n\n\t\t\t\t\t- interface Person {\n    name: string;\n    age?: number;\n    [propName: string]: string;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25,\n    gender: 'male'\n};\n//报错  \n//因为任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了\n\n\t\t\t- 只读属性：\ninterface Person {\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n}\n\nlet tom: Person = {\n    id: 89757,\n    name: 'Tom',\n    gender: 'male'\n};\n\ntom.id = 9527;//报错\n\n\n\t\t\t\t- 注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：\n\n\t\t- 写法：接口一般首字母大写。有的编程语言中会建议接口的名称加上 I 前缀。\n\n\t\t\t- [C#]\npublic interface IServiceProvider\npublic interface IFormatable\n\n- 数组\n\n\t- 定义方式\n\n\t\t- 「类型 + 方括号」表示法\n\n\t\t\t- let fibonacci: number[] = [1, 1, 2, 3, 5];\n\n\t\t- 数组泛型 Array Generic  （Array<elemType>）\n\n\t\t\t- let fibonacci: Array<number> = [1, 1, 2, 3, 5];\n\n\t\t- 用接口表示数组\n\n\t\t\t- interface NumberArray {\n    [index: number]: number;\n}\nlet fibonacci: NumberArray = [1, 1, 2, 3, 5];\n\n\t- 常见用法\n\n\t\t- 使用any，来表示允许数组中出现任意类型\n\n\t\t\t- let list: any[] = ['Xcat Liu', 25, { website: 'http://xcatliu.com' }];\n\n\t\t- 类数组（Array-like Object 不是数组类型）\n\n\t\t\t- function sum() {\n    let args: number[] = arguments;\n}\n//报错\n\t\t\t- 常见的类数组都有自己的接口定义，如 IArguments, NodeList, HTMLCollection 等：\nfunction sum() {\n    let args: IArguments = arguments;\n}\n\n- 函数\n\n\t- 函数声明\n\n\t\t- function sum(x: number, y: number): number {\n    return x + y;\n}\n\n\t\t\t- 注意：注意，输入多余的（或者少于要求的）参数，是不被允许的\n\n\t\t\t\t- function sum(x: number, y: number): number {\n    return x + y;\n}\nsum(1, 2, 3);\n\n\t- 函数表达式\n\n\t\t- let mySum: (x: number, y: number) => number = function (x: number, y: number): number {\n    return x + y;\n};\n\n\t\t\t- 注意：在 TypeScript 的类型定义中，=> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。\n\n\t- 接口\n\n\t\t- interface SearchFunc {\n    (source: string, subString: string): boolean;\n}\n\nlet mySearch: SearchFunc;\nmySearch = function(source: string, subString: string) {\n    return source.search(subString) !== -1;\n}\n\n\t- 可选参数\n\n\t\t- function buildName(firstName: string, lastName?: string) {\n    if (lastName) {\n        return firstName + ' ' + lastName;\n    } else {\n        return firstName;\n    }\n}\nlet tomcat = buildName('Tom', 'Cat');\nlet tom = buildName('Tom');\n\n\t\t\t- 注意：可选参数必须写在必选参数后面\n\n\t- 参数默认值\n\n\t\t- TypeScript 会将添加了默认值的参数识别为可选参数\n（此时，有默认值的参数就是可选的了，并且参数位置也不受「可选参数必须接在必需参数后面」的限制）\n\n\t\t\t- function buildName(firstName: string = 'Tom', lastName: string) {\n    return firstName + ' ' + lastName;\n}\nlet tomcat = buildName('Tom', 'Cat');\nlet cat = buildName(undefined, 'Cat');\n\n\t- 剩余参数\n\n\t\t- ES6 中，可以使用 ...rest 的方式获取函数中的剩余参数\n\n\t\t\t- function push(array: any[], ...items: any[]) {\n    items.forEach(function(item) {\n        array.push(item);\n    });\n}\nlet a = [];\npush(a, 1, 2, 3);\n\n\t- 重载\n\n\t\t- 重载允许一个函数接受不同数量或类型的参数时，作出不同的处理\n\n\t\t\t- function reverse(x: number): number;\nfunction reverse(x: string): string;\nfunction reverse(x: number | string): number | string {\n    if (typeof x === 'number') {\n        return Number(x.toString().split('').reverse().join(''));\n    } else if (typeof x === 'string') {\n        return x.split('').reverse().join('');\n    }\n}\n\n### 任意类型 Any\n\n- 赋值\n\n\t- 在赋值过程中，可以被赋值为任意类型\n\n- 属性和方法\n\n\t- 可访问Any上的任意属性和任何方法\n\n- 未声明类型的变量\n\n\t- 变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型\n\n\t\t- let something;\n等同于：let something:any;\n\n### 联合类型 Union Types\n\n- 定义：表示取值可以为多种类型中的一种\n\n\t- let myFavoriteNumber: string | number;\n\n- 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法\n\n\t- function getLength(something: string | number): number {\n    return something.toString();\n // return something.toString(); 报错\n}\n\n- 被赋值时：根据类型推论的规则推断出一个类型\n\n\t- let myFavoriteNumber: string | number;\nmyFavoriteNumber = 'seven';\nconsole.log(myFavoriteNumber.length); // 5\nmyFavoriteNumber = 7;\nconsole.log(myFavoriteNumber.length); // 编译时报错\n\n### 元组 Tuple\n\n- 用法1：表示一个已知元素数量和类型的数组，各元素的类型不必相同\n\n\t-   let x: [string, number];\n  x = ['hello', 10]; // OK\n\n\t\t- 注意：当直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元组类型中指定的项。\n\n- 用法2：当访问一个越界的元素，会使用联合类型替代\n\n\t- x[3] = 'world'; // OK, 字符串可以赋值给(string | number)类型\n\nconsole.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toString\n\nx[6] = true; // Error, 布尔不是(string | number)类型\n\n\t\t- 注意：当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型\n\n### 枚举 enum\n\n- 用法：用于取值被限定在一定范围内的场景\n- 类型\n\n\t- 常数项（普通枚举）\n\n\t\t- 声明\n\n\t\t\t- enum Days {Sun, Mon, Tue, Wed, Thu, Fri, Sat};\n\n\t\t\t\t- 枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射\n\n\t\t- 手动赋值\n\n\t\t\t- enum Days {Sun = 7, Mon = 1, Tue, Wed, Thu, Fri, Sat};\n\n\t\t\t\t- 未手动赋值的枚举项会接着上一个枚举项递增1\n\n\t\t- 手动赋值的枚举项不是数字\n\n\t\t\t- enum Days {Sun = 7, Mon, Tue, Wed, Thu, Fri, Sat = <any>\"S\"};\n\n\t\t- 重复赋值\n\n\t\t\t- enum Days {Sun = 3, Mon = 1, Tue, Wed, Thu, Fri, Sat};\n\nconsole.log(Days[\"Sun\"] === 3); // true\nconsole.log(Days[\"Wed\"] === 3); // true\nconsole.log(Days[3] === \"Sun\"); // false\nconsole.log(Days[3] === \"Wed\"); // true\n\n\t\t\t\t- 后赋值的会覆盖先赋值的\n\n\t- 计算所得项（普通枚举）\n\n\t\t- enum Color {Red, Green, Blue = \"blue\".length};\n//\"blue\".length 就是一个计算所得项\n\n\t\t\t- 注意：如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错\n\n\t- 常数枚举\n\n\t\t- 使用：用 const enum 定义的枚举类型\n\n\t\t\t- const enum Directions {\n    Up,\n    Down,\n    Left,\n    Right\n}\nlet directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\n\n\n\t\t- 与普通枚举的区别：它会在编译阶段被删除，并且不能包含计算成员\n\n\t\t\t- 编译结果：\nvar directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];\n\n\t- 外部枚举\n\n\t\t- 使用：用 declare enum 定义的枚举类型\n\n### 字符串字面量类型\n\n- 用法：用来约束取值只能是某几个字符串中的一个\n\n\t- type EventNames = 'click' | 'scroll' | 'mousemove';\nfunction handleEvent(ele: Element, event: EventNames) {\n    // do something\n}\n\nhandleEvent(document.getElementById('hello'), 'scroll');  // 没问题\nhandleEvent(document.getElementById('world'), 'dbclick'); // 报错，event 不能为 'dbclick'\n\n### 类 Class\n\n- 访问修饰符(限制 属性和方法的可访问性)\n\n\t- public\n\n\t\t- 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的\n\n\t- private\n\n\t\t- 修饰的属性或方法是私有的，不能在声明它的类的外部访问\n\n\t- protected\n\n\t\t- 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的\n\n- 抽象类（abstract）\n\n\t- 特点\n\n\t\t- 抽象类是不允许被实例化的\n\t\t- 抽象类中的抽象方法必须被子类实现\n\n\t- demo\n\n\t\t- abstract class Animal {\n    public name;\n    public constructor(name) {\n        this.name = name;\n    }\n    public abstract sayHi();\n}\n\nclass Cat extends Animal {\n    public sayHi() {\n        console.log(`Meow, My name is ${this.name}`);\n    }\n}\n\nlet cat = new Cat('Tom');\n\n- 类型定义\n\n\t- let a: Animal = new Animal('Jack');\n\n## 运行时\n\n### 类型推论\n\n- 定义：如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型\n- 使用场景：\n\n\t- 已赋值\n\n\t\t- TypeScript 会在没有明确的指定类型的时候推测出一个类型\n\n\t- 未赋值\n\n\t\t- 如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查\n\n### 类型断言（Type Assertion）\n\n- 定义：用来手动指定一个值的类型\n- 语法\n\n\t- <类型>值\n\n\t\t- function getLength(something: string | number): number {\n    if ((<string>something).length) {\n        return (<string>something).length;\n    } else {\n        return something.toString().length;\n    }\n}\n\n\t- 值 as 类型\n\n### 使用第三方库时\n\n- 如：在 TypeScript 中，我们并不知道 $ 或 jQuery 是什么东西\n\n\t- 声明\n\n\t\t- declare var jQuery: (string) => any;\n\n\t- 引用声明\n\n\t\t- /// <reference path=\"./jQuery.d.ts\" /> 三斜杠指令\n\njQuery('#foo');\n\n### 内置对象\n\n- 定义：根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准。\n- ECMAScript\n\n\t- Boolean\n\t- Error\n\t- Date\n\t- RegExp\n\n- DOM和BOM\n\n\t- Document\n\t- HTMLElement\n\t- Event\n\t- NodeList \n\n### 类型别名\n\n- 用法：用来给一个类型起个新名字。\n\n\t- type Name = string;\ntype NameResolver = () => string;\ntype NameOrResolver = Name | NameResolver;\nfunction getName(n: NameOrResolver): Name {\n    if (typeof n === 'string') {\n        return n;\n    } else {\n        return n();\n    }\n}\n\n*XMind: ZEN - Trial Version*",Ua={data:function(){return{MainComponent:Ba}}},Ga=Ua,Va=Object(v["a"])(Ga,Fa,Wa,!1,null,"6323c072",null),Xa=Va.exports,Qa={components:{m1:qe,m2:Ve,m3:na,m4:ia,m5:ma,m6:wa,m7:Ta,m8:Da,m9:qa,m10:Xa},data:function(){return{tab:"m1",tabs:[{label:"循环遍历",value:"m1"},{label:"Event Loop",value:"m2"},{label:"js基础",value:"m3"},{label:"js高阶",value:"m4"},{label:"es6归纳1",value:"m5"},{label:"es6归纳2",value:"m6"},{label:"阮一峰JavaScript基础总结",value:"m9"},{label:"jquery",value:"m8"},{label:"ts",value:"m10"},{label:"正则",value:"m7"}]}}},Ya=Qa,Ka=Object(v["a"])(Ya,De,ze,!1,null,"2c9b2a00",null),Za=Ka.exports,tr=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+t.value,label:n+1+"."+t.label}})})),1),e("div",{staticClass:"q-mx-lg"},[e(""+t.tab,{tag:"component"})],1)],1)},nr=[],er=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{},[e("q-markdown",{attrs:{src:t.MainComponent}})],1)},ar=[],rr="# http\n\n## Web 及网络协议基础\n\n### 网络基础TCP/IP\n\n- 通常使用的网络是在TCP/IP协议族的基础上运作的，HTTP属于他内部的一个子集\n- 把与互联网相关联的协议集合起来总称为 TCP/IP\n- TCP/IP 协议族按层次分别分为以下 4 层:应用层、传输层、网络层和数据链路层\n- 发送端在层与层之间传输数据时,每经过一层时必定会被打上一个该层所属的首部信息。\n反之,接收端在层 与层传输数据时,每经过一层时会把对应的首部消去\n\n### 与 HTTP 关系密切的协议：IP、TCP和DNS\n\n- IP 协议的作用是把各种数据包传送给对方\n- IP 地址指明了节点被分配到的地址,MAC 地址是指网卡所属的固定地址。\n- 在进行中转时,会利用下一站中转设备的 MAC 地址来搜索下一 个中转目标。这时,会采用 ARP 协议\n- 无论哪台计算机、哪台网络设备,它们都无法全面掌握互联网中的细节\n- 按层次分,TCP 位于传输层,提供可靠的字节流服务。\n- 将大块数据分割成以报文段为单位的数据包进行管理\n- TCP 协 议为了更容易传送大数据才把数据分割\n- TCP 协议采用了三次握手(three-way handshaking)策略\n\n\t-  若在握手过程中某个阶段莫名中断，TCP 协议\n会再次以相同的顺序发送相同的数据包\n\n- DNS 协议提供通过域名查找 IP 地址,或逆向从 IP 地址反查域名 的服务\n\n### URL 和 URL\n\n- URL 正是使用 Web 浏览器等访问 Web 页面时需要输入的网页地址\n- URI 就是由某个协议方案表示的资源的定位标识符\n\n## 构建 Web 内容的技术\n\n### HTML\n\n- HTML5 标准不仅解决了浏览器之间的兼容性问题,并且可把文本作为数据对待,更容易复用,动画等效果也 变得更生动。\n- CSS(Cascading Style Sheets,层叠样式表)可以指定如何展现 HTML 内的各种元素,属于样式表标准之一\n- 所谓动态 HTML(Dynamic HTML),是指使用客户端脚本语言将静态的 HTML 内容变成动态的技术的总 称。\n- DOM 是用以操作 HTML 文档和 XML 文档的 API(\n\n### Web 应用\n\n- Web 应用是指通过 Web 功能提供的应用程序\n- CGI(Common Gateway Interface,通用网关接口)是指 Web 服务器在接收到客户端发送过来的请求后转发 给程序的一组机制\n- 随着 CGI 的普及,每次请求都要启动新 CGI 程序的 CGI 运行机制逐渐变成了性能瓶颈,\n所以之后 Servlet 和 mod_perl 等可直接在 Web 服务器上运行的程序才得以开发、普及\n\n### 数据发布的格式及语言\n\n- XML(eXtensible Markup Language,可扩展标记语言)是一种可按应用目标进行扩展的通用标记语言\n- RSS(简易信息聚合,也叫聚合内容)和 Atom 都是发布新闻或博客日志等更新信息文档的格式的总称\n- JSON(JavaScript Object Notation)是一种以 JavaScript(ECMAScript)的对象表示法为基础的轻量级数据 标记语言\n\n## 基于 HTTP 的功能追加协议\n\n### 消除HTTP 瓶颈的 SPDY\n\n- 其开发目标旨在解决 HTTP 的性能瓶颈,缩短 Web 页面的加载时间(50%)\n- 一条连接上只可发送一个请求。\n-  请求只能从客户端开始。 客户端不可以接收除响应以外的指令。\n-  请求 / 响应首部未经压缩就发送。 首部信息越多延迟越大。\n-  发送冗长的首部。 每次互相发送相同的首部造成的浪费较多。\n-  可任意选择数据压缩格式。 非强制压缩发送。\n- SPDY 没有完全改写 HTTP 协议,而是在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作\n- 多路复用流\n\n\t- 通过单一的 TCP 连接,可以无限制处理多个 HTTP 请求\n\n- 赋予请求优先级\n\n\t- SPDY 不仅可以无限制地并发处理请求,还可以给请求逐个分配优先级顺序\n\n- 压缩 HTTP 首部\n\n\t- 压缩 HTTP 请求和响应的首部\n\n- 推送功能\n\n\t- 支持服务器主动向客户端推送数据的功能\n\n- 服务器提示功能\n\n\t- 服务器可以主动提示客户端请求所需的资源\n\n- SPDY 的确是一种可有效消除 HTTP 瓶颈的技术,但很多 Web 网站存在的问题并非仅仅是由 HTTP 瓶颈所 导致\n\n### 使用浏览器进行全双工通信的WebSocket\n\n- 一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接,之后所有的通信都依靠这个专用协议进 行。\n- 连接的发起方仍是客户端,而一旦确立 WebSocket 通信连接,不 论服务器还是客户端,任意一方都可直接向对方发送报文\n- 支持由服务器向客户端推送数据的推送功能。\n- 和 HTTP 相比,不但每次连接时的总开销减少, 而且由于 WebSocket 的首部信息很小,通信量也相应减少了\n\n### 期盼已久的HTTP/2.0\n\n- HTTP/2.0 的目标是改善用户在使用 Web 时的速度体验。\n\n### Web 服务器管理文件的 WebDAV\n\n- 一 个可对 Web 服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统\n\n## HTTP 报文内的 HTTP信息\n\n### HTTP 报文\n\n- 用于 HTTP 协议交互的信息被称为 HTTP 报文\n- HTTP 报文大致可分为报文首部和报文主体两块\n\n### 报文结构\n\n- 请求行\n- 状态行\n- 首部字段\n- 其他\n\n### 编码提升传输速率\n\n- 通过在传 输时编码,能有效地处理大量的访问请求。但是,编码的操作需要计算机来完成,因此会消耗更多的 CPU 等 资源\n- 报文\n\n\t- 是 HTTP 通信中的基本单位,由 8 位组字节流(octet sequence,其中 octet 为 8 个比特)组成,通过 HTTP 通信传输\n\n- 实体\n\n\t- 作为请求或响应的有效载荷数据(补充项)被传输,其内容由实体首部和实体主体组成\n\n- 向待发送邮件内增加附件时,为了使邮件容量变小,我们会先用 ZIP 压缩文件之后再添加附件发送\n- 常用的内容编码有以下几种\n\n\t- gzip( GNU zip)\n\t- compress( UNIX 系统的标准压缩)\n\t- deflate ( zlib)\n\t- identity(不进行编码)\n\n- 在 HTTP 通信过程中,请求的编码实体资源尚未全部传输完成之前,浏览器无法显示请求页面。\n\n### 发送多种数据的多部分对象集合\n\n- 在 MIME 扩展中会使用一种称为多部分对象集合(Multipart)的方法,来容纳多份不同类型的数据\n- 多部分对象集合包含的对象\n\n\t- multipart/form-data\n\t- multipart/byteranges\n\t- multipart/form-data\n\t- multipart/byteranges\n\n- 在 HTTP 报文中使用多部分对象集合时,需要在首部字段里加上 Content-type\n\n### 获取部分内容的范围请求\n\n- 执行范围请求时,会用到首部字段 Range 来指定资源的 byte 范围。\n\n### 内容协商返回最合适的内容\n\n- 当浏览器的默认语言为英语或中文,访问相同 URI 的 Web 页面时,则会显示对应的英语版或中文版的 Web 页面。这样的机制称为内容协商(\n- 内容协商机制是指客户端和服务器端就响应的资源内容进行交涉,然后提供给客户端最为适合的资源\n- 由服务器端进行内容协商。以请求的首部字段为参考,在服务器端自动处理\n- 由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择\n- 是服务器驱动和客户端驱动的结合体,是由服务器端和客户端各自进行内容协商的一种方法\n- Accept Accept-Charset Accept-Encoding Accept-Language Content-Language\n\n## 与 HTTP 协作的 Web 服务器\n\n### 用单台虚拟主机实现多个域名\n\n- HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点\n\n### 通信数据转发程序 :代理、网关、隧道\n\n- 代理\n\n\t- 代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器\n\t- 缓存代理\n\t- 透明代理\n\n- 网关\n\n\t- 利用网关可以由 HTTP 请求转化为其他协议通信\n\n- 隧道\n\n\t- 隧道的目的是确保 客户端能与服务器进行安全的通信\n\n### 保存资源的缓存\n\n- 代理服务器\n\n\t- 缓存是指代理服务器或客户端本地磁盘内保存的资源副本\n\n- 缓存的有效期限\n\n\t- 即使存在缓存,也会因为客户端的要求、缓存的有效期等因素,向源服务器确认资源的有效性\n\n- 客户端的缓存\n\n\t- 浏览器缓存如果有效,就不必再向服务器请求相同的资源了,可以直接从本地磁盘内读取\n\n## HTTP 头部\n\n###   HTTP 报文的结构\n\n- 在请求中,HTTP 报文由方法、URI、HTTP 版本、HTTP 首部字段等部分构成。\n- 在响应中,HTTP 报文由 HTTP 版本、状态码(数字和原因短语)、HTTP 首部字段 3 部分构成\n\n### HTTP 首部字段\n\n- HTTP 首部字段是由首部字段名和字段值构成的,中间用冒号“:” 分隔。\n- 字段值对应单个 HTTP 首部字段可以有多个值\n- 4 种 HTTP 首部字段类型\n\n\t- 通用首部字段( General Header Fields)\n\t- 请求首部字段( Request Header Fields)\n\t- 响应首部字段( Response Header Fields)\n\t- 实体首部字段( Entity Header Fields)\n\n### HTTP/1.1 首部字段一览\n\n- Cache-Control\n\n\t- 控制缓存行为\n\n- Connection\n\n\t- 逐跳首部、连接的管理\n\n- Date\n\n\t- 创建报文的日期时间\n\n- Pragma\n\n\t- 报文指令\n\n- Trailer\n\n\t- 报文末端的首部一览\n\n- Transfer-Encoding\n\n\t- 指定报文主体的传输编码方式\n\n- Upgrade\n\n\t- 升级为其他协议\n\n- Via\n\n\t- 代理服务器的相关信息\n\n- Warning\n\n\t- 错误通知\n\n- Accept\n\n\t- 用户代理可处理的媒体类型\n\n- Accept-Charset\n\n\t- 优先的字符集\n\n- Accept-Encoding\n\n\t- 优先的内容编码\n\n- Accept-Language\n\n\t- 优先的语言(自然语言)\n\n- Authorization\n\n\t- Web认证信息\n\n- Expect\n\n\t- 期待服务器的特定行为\n\n- From\n\n\t- 用户的电子邮箱地址\n\n- Host\n\n\t- 请求资源所在服务器\n\n- If-Match\n\n\t- 比较实体标记(ETag)\n\n- If-Modified-Since\n\n\t- 比较资源的更新时间\n\n- If-None-Match\n\n\t- 比较实体标记(与 If-Match 相反)\n\n- If-Range\n\n\t- 资源未更新时发送实体 Byte 的范围请求\n\n- If-Unmodified-Since\n\n\t- 比较资源的更新时间(与If-Modified-Since相反)\n\n- Max-Forwards\n\n\t- 最大传输逐跳数\n\n- Proxy-Authorization\n\n\t- 代理服务器要求客户端的认证信息\n\n- Range\n\n\t- 实体的字节范围请求\n\n- Referer\n\n\t- 对请求中 URI 的原始获取方\n\n- TE\n\n\t- 传输编码的优先级\n\n- User-Agent\n\n\t- HTTP 客户端程序的信息\n\n- Accept-Ranges\n\n\t- 是否接受字节范围请求\n\n- Age\n\n\t- 推算资源创建经过时间\n\n- ETag\n\n\t- 资源的匹配信息\n\n- Location\n\n\t- 令客户端重定向至指定URI\n\n- Proxy-Authenticate\n\n\t- 代理服务器对客户端的认证信息\n\n- Retry-After\n\n\t- 对再次发起请求的时机要求\n\n- Server\n\n\t- HTTP服务器的安装信息\n\n- Vary\n\n\t- 代理服务器缓存的管理信息\n\n- WWW-Authenticate\n\n\t- 服务器对客户端的认证信息\n\n- Allow\n\n\t- 资源可支持的HTTP方法\n\n- Content-Encoding\n\n\t- 实体主体适用的编码方式\n\n- Content-Language\n\n\t- 实体主体的自然语言\n\n- Content-Length\n\n\t- 实体主体的大小(单位:字节)\n\n- Content-Location\n\n\t- 替代对应资源的URI\n\n- Content-MD5\n\n\t- 实体主体的报文摘要\n\n- Content-Range\n\n\t- 实体主体的位置范围\n\n- Content-Type\n\n\t- 实体主体的媒体类型\n\n- Expires\n\n\t- 实体主体过期的日期时间\n\n- Last-Modified\n\n\t- 资源的最后修改日期时间\n\n- 还有 Cookie、 Set-Cookie 和 Content-Disposition 等在其他 RFC 中定义的首部字段,它们的使用频率也很高\n\n### End-to-end 首部和 Hop-by-hop 首部\n\n- 端到端首部( End-to-end Header)\n- 逐跳首部( Hop-by-hop Header)\n\n## 确保 Web 安全的 HTTPS\n\n### HTTP 的缺点\n\n- 通信使用明文(不加密), 内容可能会被窃听\n- 不验证通信方的身份, 因此有可能遭遇伪装\n- 无法证明报文的完整性, 所以有可能已遭篡改\n\n### HTTP+ 加密 + 认证 + 完整性保护 =HTTPS\n\n- 我们把添加了加密及认证机制 的 HTTP 称为 HTTPS\n- 只是 HTTP 通信接口部分用 SSL(Secure Socket Layer)和TLS(Transport Layer Security)协议代替而已\n- SSL 是独立于 HTTP 的协议,所以不光是 HTTP 协议,其他运行在应用层的 SMTP 和 Telnet 等协议均可配 合 SSL 协议使用\n- SSL 采用一种叫做公开密钥加密(Public-key cryptography)的加密处理方式\n- 加密和解密都会用到密钥。没有密钥就无法对密码解密,反过来说,任何人只要持有密钥就能解密了\n- 加密和解密同用一个密钥的方式称为共享密钥加密(Common key crypto system),也被叫做对称密钥 加密\n- 公开密钥加密使用一对非对称的密钥。一把叫做私有密钥(private key),另一把叫做公开密钥(public key)\n- HTTPS 采用混合加密机制\n- 数字证书认证机构(CA,Certificate Authority)和其相关机关颁发的公开密 钥证书\n\n## 返回结果的 HTTP 状态码\n\n### 状态码的职责\n\n- 当客户端向服务器端发送请求时,描述返回的请求结果\n\n### 状态码的大致分类\n\n- 1XX\n\n\t- 信息性状态码\n\n\t\t- 接收的请求正在处理\n\n- 2XX\n\n\t- 成功状态码\n\n\t\t- 请求正常处理完毕\n\n- 3XX\n\n\t- 重定向状态码\n\n\t\t- 需要进行附加操作以完成请求\n\n- 4XX\n\n\t- 客户端错误状态码\n\n\t\t- 服务器无法处理请求\n\n- 5XX\n\n\t- 服务器错误状态码\n\n\t\t- 服务器处理请求出错\n\n### 2XX 成功\n\n- 200 OK\n\n\t- 表示从客户端发来的请求在服务器端被正常处理了\n\n- 204 No Content\n\n\t- 该状态码代表服务器接收的请求已成功处理,但在返回的响应报文中不含实体的主体部分\n\n- 206 Partial Content\n\n\t- 该状态码表示客户端进行了范围请求,而服务器成功执行了这部分的 GET 请求\n\n### 3XX 重定向\n\n- 301 Moved Permanently\n\n\t- 永久性重定向。该状态码表示请求的资源已被分配了新的 URI,以后应使用资源现在所指的 URI。\n\n- 302 Found\n\n\t- 临时性重定向。该状态码表示请求的资源已被分配了新的 URI,希望用户(本次)能使用新的 URI 访问\n\n- 303 See Other\n\n\t- 该状态码表示由于请求对应的资源存在着另一个 URI,应使用 GET 方法定向获取请求的资源\n\t- 303 状态码和 302 Found 状态码有着相同的功能,但 303 状态码明确表示客户端应当采用 GET 方法获取资 源\n\n- 304 Not Modified\n\n\t- 该状态码表示客户端发送附带条件的请求 2 时,服务器端允许请求访问资源,但未满足条件的情况\n\n- 307 Temporary Redirect\n\n\t- 临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET\n\n### 4XX 客户端错误\n\n- 400 Bad Request\n\n\t- 该状态码表示请求报文中存在语法错误\n\n- 401 Unauthorized\n\n\t- 该状态码表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息\n\n- 403 Forbidden\n\n\t- 该状态码表明对请求资源的访问被服务器拒绝了\n\n- 404 Not Found\n\n\t- 该状态码表明服务器上无法找到请求的资源\n\n### 5XX 服务器错误\n\n- 500 Internal Server Error\n\n\t- 该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障\n\n- 503 Service Unavailable\n\n\t- 该状态码表明服务器暂时处于超负载或正在进行停机维护,现在无法处理请求\n\n## 确认访问用户身份的认证\n\n### 何为认证\n\n- 密码:只有本人才会知道的字符串信息。\n- 动态令牌:仅限本人持有的设备内显示的一次性密码\n- 数字证书:仅限本人(终端)持有的信息\n- 生物认证:指纹和虹膜等本人的生理信息。\n- IC 卡等:仅限本人持有的信息\n- BASIC 认证(基本认证)\n- DIGEST 认证(摘要认证)\n- SSL 客户端认证\n- FormBase 认证(基于表单认证)\n\n### BASIC 认证\n\n- BASIC 认证(基本认证)是从 HTTP/1.0 就定义的认证方式。\n- BASIC 认证使用上不够便捷灵活,且达不到多数 Web 网站期望的安全性等级,因此它并不常用。\n- 步骤 1: 当请求的资源需要 BASIC 认证时,服务器会随状态码 401 Authorization Required,返回带 WWW-Authenticate 首部字段的响应\n- 步骤 2: 接收到状态码 401 的客户端为了通过 BASIC 认证,需要将用户 ID 及密码发送给服务器\n- 步骤3：接收到包含首部字段 Authorization 请求的服务器,会对认证信息的正确性进行验证\n\n### DIGEST 认证\n\n- DIGEST 认证同样使用质询 / 响应的 方式(challenge/response),但不会像 BASIC 认证那样直接发送明文密码。\n- 步骤 1: 请求需认证的资源时,服务器会随着状态码 401 Authorization Required,返 回带 WWW-Authenticate 首部字段的响应\n- 步骤 2: 接收到 401 状态码的客户端,返回的响应中包含 DIGEST 认证必须的首部字段 Authorization 信 息。\n- 步骤 3: 接收到包含首部字段 Authorization 请求的服务器,会确认认证信息的正确性。\n\n### SSL 客户端认证\n\n- SSL 客户端认证是借由 HTTPS 的客户端证书完成认证的方式。\n- 步骤 1: 接收到需要认证资源的请求,服务器会发送 Certificate Request 报文,要求客户端提供客户端证 书。\n- 步骤 2: 用户选择将发送的客户端证书后,客户端会把客户端证书信息以 Client Certificate 报文方式发送给 服务器。\n- 步骤 3: 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥,然后开始 HTTPS 加密通 信。\n\n###  基于表单认证\n\n- 认证多半为基于表单认证\n- 基于表单认证的标准规范尚未有定论,一般会使用 Cookie 来管理 Session(会话)\n- 步骤 1: 客户端把用户 ID 和密码等登录信息放入报文的实体部分,通常是以 POST 方法把请求发送给服务 器。\n- 步骤 2: 服务器会发放用以识别用户的 Session ID。会在首部字段 Set-Cookie 内写入 Session ID\n- 步骤 3: 客户端接收到从服务器端发来的 Session ID 后,会将其作为 Cookie 保存在本地\n\n## TCP/IP协议族\n\n### 是互联网相关的各类协议族的总称\n\n- 协议就是计算机与网络设备之间互相同通信的规则\n- http属于他内部的一个子集\n\n### 通信传输流\n\n- 发送端从应用层往下走，接收端从链路层往上走\n- 发送端在层与层之间传输数据时，每经过一层必定会被打上一个该层所属的首部信息\n- 接收端在层与层之间传输数据时，每经过一层会把对应的首部去掉\n- 这种数据信息包装的做法称为封装\n\n### 负责传输的IP协议\n\n- 把各种数据包传送给对方（两个重要的条件）\n\n\t- IP地址（节点被分配的地址）\n\t- MAC地址（网卡所属的固定地址）\n\n### 确保可靠性的TCP协议\n\n- 提供可靠的字节流服务，把数据准确可靠的传给对方\n- 为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理（为了传输大的数据）\n- 三次握手\n\n\t- 客户端发送SYN给服务端，（同步请求）\n\t- 服务端发送SYN/ACK（同步请求和确认）\n\t- 客户端发送ACK（确认）\n\t- 若在某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包\n\n### DNS域名解析服务\n\n- 通过域名查找IP地址或逆向从IP查找域名的服务\n\n### URI与URL\n\n- URI统一资源标识符，标识资源\n- URL统一资源定位符、是URI的子集，标识资源地址\n\n###  分层管理\n\n- 链路层\n\n\t- 用来处理网络连接的硬件部分\n\n- 传输层\n\n\t- 为应用层提供网络连接中的两台计算机之间的数据传输\n\t- TCP传输控制协议\n\t- UDP用户数据报协议\n\t- 将应用层的数据进行分割，并在各个报文打上标记序号及端口号后发给网络层\n\n- 网络层\n\n\t- 处理在网络上流动的数据包，数据包是网路传输协议的最小数据单位，规定通过怎么的路径到达目的地。\n\t- 增加作为通信目的地的MAC地址后转发给链路层\n\n- 应用层\n\n\t- 决定了向用户提供的应用服务时通信的活动\n\t- FTP文件传输协议\n\t- DNS域名系统\n\n- 分层次的好处\n\n\t- 应变不同需求\n\n\t\t- 当需求不同的时候不需要改变所有整体、只需要修改相应的层次就行了。\n\n\t- 分工明确\n\n\t\t- 只需要考虑分配给自己的任务\n\n## 简单HTTP协议\n\n### 客户端与服务端通讯\n\n- 在两台计算机之间使用 HTTP 协议通信时,在一条通信线路上必定有一端是客户端,另一端则是服务器端\n- 请求必定由客户端发出, 而服务器端回复响应\n- 请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的\n- 响应报文基本上由协议版本、状态码(表示请求成功或失败的数字代码)、用以解释状态码的原因短语、可 选的响应首部字段以及实体主体构成\n\n### 请求报文的构成\n\n- 方法/URI/协议版本\n- 请求首部字段\n- 内容实体\n\n### HTTP是不保存状态的协议\n\n- 协议自身不具备保存之前发送过的请求或相应的功能\n- HTTP/1.1虽然无状态协议，但是引入Cookies之后可以管理状态了\n- 无状态的优点是可以减少服务器的CPU以及内存资源的消耗\n- Cookies技术通过在请求和响应报文中写入Cookies来控制客户端的状态\n- 在服务端发送的响应报文内添加Set-Cookies的首部字段信息，通知客户端保存Cookies。当下次客户端发送请求时，客户端会自动在请求报文中加入Cookies值后发送出去\n\n### 告知服务器意图的HTTP方法\n\n- GET：获取资源\n\n\t- 使用GET方法请求访问已被URI识别的资源\n\n- POST：传输实体的主体\n\n\t- 虽然GET也可以但是一般不使用GET，POST的主要目的不是获取响应的主体内容\n\n- PUT：传输文件\n\n\t- 像FTP协议的文件上传一样，要求在请求的报文 主体中包含文件内容，然后保存到请求URI指定的位置，\n\n- HEAD：获取报文首部\n\n\t- 用于确认URI的有效性和资源更新的日期时间等\n\t- 和GET一样但是不返回报文主体\n\n- DELETE删除文件\n\n\t- 请求删除URI指定的资源\n\n- OPTIONS：询问支持的方法\n\n\t- 用来查询针对请求URI指定资源支持的方法\n\n- TRACE：追踪路径\n\n\t- 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服 务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最 后接收到请求的服务器端则返回状态码 200 OK 的响应。 \n\t- 客户端通过TRACE方法查询发送出去的请求是怎么样被加工修改的。\n\t- 请求想要连接到源目标服务器可能会通过代理中转，TRACES方法就是用来确认连接过程中发生的一系列操作\n\t- 容易引发XST扩展追踪攻击\n\n- CONNECT：要求用隧道协议连接代理\n\n\t- 要求与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信\n\t- 主要使用SSL安全套接层和TLS传输安全协议把通信内容加密后经网络隧道传输\n\t- CONNECT 代理服务器名：端口号 HTTP版本\n\n### 持久连接节省通信量\n\n- HTTP/1.1新增keep-alive方法\n- 特点：只要任意一端没有明确提出断开连接，则保持TCP连接状态\n- HTTP 协议的初始版本中,每进行一次 HTTP 通信就要断开一次 TCP 连接\n- 持久连接的特点是,只要任意 一端没有明确提出断开连接,则保持 TCP 连接状态\n- 持久连接使得多数请求以管线化(pipelining)方式发送成为可能\n- 减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务端的负载\n- HTTP/1.1中所有的连接默认都是持久连接\n\n### 使用 Cookie 的状态管理\n\n- HTTP 是无状态协议,它不对之前发生过的请求和响应的状态进行管理\n- Cookie 技术通过在请 求和响应报文中写入 Cookie 信息来控制客户端的状态\n- Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息,通知客户端保存 Cookie\n- 当下次客户端再往该服务器发送请求时,客户端会自动在请求报文中加入 Cookie 值后发送出去\n\n### 管线化\n\n- 持久连接使得多数请求以管线化方式发送成为可能\n- 能够做到同时并行发送多个请求，不需要一个接一个地等待响应了\n\n## WebSocket与HTTP\n\n### 相同点\n\n- 基于TCP的可靠传输\n- 都是应用层协议\n\n### 不同点\n\n- WebSocket\n\n\t- 双向通信协议，模拟Socket协议\n\t- 可以双向发送或接受信息\n\n- HTTP\n\n\t- 单向发送信息或接受信息\n\t- 浏览器向服务器发起连接\n\t- 服务器预先不知道这个连接\n\n### 联系\n\n- web Socket建立握手时，数据是通过HTTP传输的\n- 建立之后不需要HTTP协议\n\n### Socket\n\n- 应用层与TCP/IP协议族通信的中间软件抽象层\n- 它是一组接口，提供一套调用TCP/IP协议的API\n- Socket是传输控制层接口，WebSocket是应用层协议。\n\n## DNS原理\n\n### 递归查询\n\n- 客户端问本地DNS服务器\n- 本地DNS服务器问根域名服务器\n- 根域名服务器问顶级域名服务器\n- 顶级域名服务器问主域名服务器\n\n### 迭代查询\n\n- 客户端询问本地DNS服务器\n- 客户端问根域名服务器\n- 客户端问顶级域名服务器\n- 客户端问主域名服务器\n\n### 域名系统\n\n- DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议\n\n\t- 区域传送时使用TCP\n\n\t\t- 辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动\n\t\t- 如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。\n\n\t- 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可\n\n### 查找顺序\n\n- 浏览器缓存\n\n\t- 根据本地DNS服务器的设置，采用递归或者迭代查询，直至解析完成。\n\n- 系统缓存\n\n\t- 检查自己本地的hosts文件是否有这个网址映射关系\n\n-  路由器缓存\n\n\t- 进入路由器缓存中检查\n\n- 本地DNS解析器缓存，是否有这个网址映射关系\n- 根据本地DNS服务器的设置，采用递归或者迭代查询，直至解析完成。\n\n## http/http2\n\n### http1.x缺点\n\n- 对同一个域名的并发连接最多只能2个，而平均一个页面有40个资源\n- 线头阻塞，同一个连接请求，需要一个接一个串行发送和接受\n- 请求和响应的头部信息大，无法压缩\n- 不能控制响应的优先级\n- 只能单项请求\n\n### http2\n\n- 传输内容使用二进制协议，在应用层和传输层之间增加了二进制分帧层\n- 使用帧作为最小传输单位\n\n\t- 所有的帧以固定的9个八位字节头部开头，随后是一个可变长的的有效载荷\n\n- 多路复用\n- 服务器推送\n- 优先级与依赖性\n- 可重置\n\n\t- RST_STREAM 帧来中断\n\n- 流量控制\n\n## HTTP与HTTPS的区别\n\n### HTTP\n\n- 运行在TCP上\n- 明文传输\n- 端口80\n- 工作在应用层\n\n### 证书+数字签名\n\n- 网站信息加密后通过第三方机构的私钥再次加密生成数字签名\n- 数字证书=网站信息+数字签名\n- 因为数字签名的存在，会导致客户端验证签名不匹配，这样就防止了中间人替换公钥的问题\n- 安全拿到服务器的公钥之后，使用公钥对随机生成的对称密钥进行加密传输给服务器，此后的数据将使用对称加密的方式进行传输\n\n### 对称加密\n\n- 加密和解密用同一个密钥的加密方式\n- 传输的密钥会被劫持\n\n### HTTPS\n\n- CA证书\n\n\t- 免费证书少\n\n- SSL/TLS加密\n\n\t- 加密后运行在TCP上\n\n- 端口443\n- 防止运营商劫持\n- 工作在传输层\n\n### 非对称加密\n\n- 私钥加密的内容，公钥可以解开\n- 公钥加密的内容，只有私钥可以解开\n- 私钥存在服务端，公钥发送到客户端，客户端用公钥加密\n- 这样的传输方式公钥容易被中间人篡改\n\n## 面向前端的CDN原理\n\n### （1）为什么需要CDN\n\n- 根本上的原因是\n\n\t- 网站需要提高访问速度，HTTP传输时延对web的访问速度的影响很大，在绝大多数情况下是起决定性作用的，这是由TCP/IP协议的一些特点决定的。物理层上的原因是光速有限、信道有限，协议上的原因有丢包、慢启动、拥塞控制等。\n\n- 最简单的做法\n\n\t- 当然就是多设置几个服务器，让终端用户离服务器“更近”。典型的例子是各类下载网站在不同地域不同运营商设置镜像站，或者是像Google那样设置多个数据中心。\n\t- 问题\n\n\t\t- 一是多地部署时的困难\n\t\t- 二是一致性没法保障\n\t\t- 三则是管理困难、成本很高\n\t\t- 实际上，在排除多地容灾等特殊需求的情况下，对大多数公司这种做法是不太可取的。\n\n- CDN\n\n\t- CDN是一种公共服务，他本身有很多台位于不同地域、接入不同运营商的服务器，而所谓的使用CDN实质上就是让CDN作为网站的门面，用户访问到的是CDN服务器，而不是直接访问到网站。由于CDN内部对TCP的优化、对静态资源的缓存、预取，加上用户访问CDN时，会被智能地分配到最近的节点，降低大量延迟，让访问速度可以得到很大提升。\n\n### （2）CDN的原理\n\n- CDN做了什么？\n\n\t- CDN做了两件事，一是让用户访问最近的节点，二是从缓存或者源站获取资源\n\n- 访问 CDN的过程\n\n\t- 流程图\n\n\t- 1.首先访问本地的 DNS ，如果没有命中，继续递归或者迭代查找，直到命中拿到对应的 IP 地址。 \n\n\t\t- 这个过程中，有一个 CNAME 的过程，我们访问 CDN 资源的地址一般是 a.cloud.com 或者类似的地址，是一个公司的访问 CDN 的专用地址。但是我们用的 cdn 的服务却是第三方的，即其实资源在他们的地址上比如 tencent.cdn。这时候就需要在 dns 查询的时候，需要把我们访问 a.cloud.com的地址映射到 tencent.cdn 的地址上，然后拿着映射后的地址再去走一遍 DNS 解析，成功之后才获取到第三方提供的全局负载均衡系统的 IP。再继续走后面的流程。\n\n\t- 2.拿到对应的 IP 地址之后服务器端发送请求到目的地址。注意这里返回的不直接是 cdn 服务器的 IP 地址，而是全局负载均衡系统的 IP 地址\n\t- 4.全局负载均衡系统会根据客户端的 IP地址和请求的 url 和相应的区域负载均衡系统通信\n\t- 5.区域负载均衡系统拿着这两个东西获取距离客户端最近且有相应资源的cdn 缓存服务器的地址，返回给全局负载均衡系统 \n\t- 6.全局负载均衡系统返回确定的 cdn 缓存服务器的地址给客户端。\n\t- 7.客户端请求缓存服务器上的文件\n\n- 通俗理解\n\n\t- 其实 CDN就是个放服务端资源的一个仓库。康师傅的泡面如果不是有家门口的小卖部，我们就得去人家的工厂门口拿。有了小卖部，我们只需要去一个卖康师傅或者有货的小卖部拿，就是这个道理。\n\n- 回源\n\n\t- 当 CDN 缓存服务器中没有符合客户端要求的资源的时候，缓存服务器会请求上一级缓存服务器，以此类推，直到获取到。最后如果还是没有，就会回到我们自己的服务器去获取资源。 那都有哪些时候会回源呢？没有资源，资源过期，访问的资源是不缓存资源等都会导致回源。\n\t- 专业术语\n\n\t\t- 边缘节点：指距离最终用户接入具有较少的中间环节的网络节点\n\n### （3）资源的过期如何判定？cdn 是如何更新数据的？\n\n- 资源过期时间就是根据我们老生常谈的请求头部来判定。\n- CDN更新数据分两种，主动（PUSH）和被动（PULL）。被动刚才我们已经提到过了，利用回源就可以被动在途经的 CDN 节点缓存数据。 而主动指的是，我们从服务器主动往 CDN 推送数据。\n\n## 【HTTPS】HTTPS与HTTP的区别，以及HTTP2\n\n### HTTP与HTTPS的区别\n\n- （1）HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。\n- （2）HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。\n- （3）HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。\n- （4）HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。\n\n### HTTPS中的对称加密与非对称加密\n\n- 非对称加密，XX网站生成公钥和私钥，公钥发给别人进行信息传输加密，私钥留在本地进行获取信息解码。公钥用于信息发送，私钥用于信息接收\n- 对称加密与非对称加密\n\n\t- 对称加密就是加密与解密的秘钥是相同的。而非对称加密就是公钥加密的内容，必须用私钥才能解密，私钥加密的内容，必须用公钥才能解密。\n\n- 加密图解\n\n- 加密过程\n\n\t- （1）server生成一个公钥和私钥，把公钥发送给第三方认证机构（CA）；\n\t- （2）CA把公钥进行MD5加密，生成数字签名；再把数字签名用CA的私钥进行加密，生成数字证书。CA会把这个数字证书返回给server；\n\t- （3）server拿到数字证书之后，就把它传送给浏览器；\n\t- （4）浏览器会对数字证书进行验证，首先，浏览器本身会内置CA的公钥，会用这个公钥对数字证书解密，验证是否是受信任的CA生成的数字证书；\n\t- （5）验证成功后，浏览器会随机生成对称秘钥，用server的公钥加密这个对称秘钥，再把加密的对称秘钥传送给server；\n\t- （6）server收到对称秘钥，会用自己的私钥进行解密，之后，它们之间的通信就用这个对称秘钥进行加密，来维持通信。\n\n### 谷歌2012年提出SPDY方案\n\n- SPDY可以说是综合了HTTPS和HTTP两者有点于一体的传输协议，主要解决：\n- （1）降低延迟\n\n\t- 针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。\n\t- 多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。\n\n- （2）请求优先级\n\n\t- 多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。\n\t- SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。\n\n- （3）header压缩\n\n\t- HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。\n\n- （4）基于HTTPS的加密协议传输\n- （5）服务端推送（server push）\n\n\t- 采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。\n\n- SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。\n\n### HTTP2：SPDY的升级版\n\n- 基于SPDY设计，与其不同之处\n\n\t- HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS\n\t- HTTP2.0 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE\n\n- HTTP2 新特性\n\n\t- 新的二进制格式（Binary Format）\n\n\t\t- HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。\n\n\t- 多路复用（MultiPlexing）\n\n\t\t- 即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。\n\t\t- 原理图\n\n\t- header压缩\n\n\t\t- HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。\n\n\t- 服务端推送（server push）\n\n## 【TCP、UDP】互联网协议\n\n### TCP 三次握手和四次挥手\n\n- 定义\n\n\t- 三次握手与四次挥手分别对应TCP连接建立过程与断开过程，先上TCP报文格式\n\n- 字段介绍\n\n\t- （1）序号\n\n\t\t- Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。\n\n\t- （2）确认序号\n\n\t\t- Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。\n\n\t- （3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等\n\n\t\t- （A）URG：紧急指针（urgent pointer）有效。\n\t\t- （B）ACK：确认序号有效。\n\t\t- （C）PSH：接收方应该尽快将这个报文交给应用层。\n\t\t- （D）RST：重置连接。\n\t\t- （E）SYN：发起一个新连接。\n\t\t- （F）FIN：释放一个连接。\n\n- 三次握手\n\n\t- 简明理解\n\n\t\t- 第一次握手：Client什么都不能确认；Server确认了对方发送正常\n\t\t- 第二次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：自己接收正常，对方发送正常\n\t\t- 第三次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：自己发送、接收正常，对方发送接收正常\n\n\t- 实际过程\n\n\t\t- A对B说：我的序号是x，我要向你请求连接；（第一次握手，发送SYN包，然后进入SYN-SEND状态）\n\t\t- B听到之后对A说：我收到你的序号x了，我给你返回一个x+1，我的序号是y，期待你下一句序号是y+1的话（意思就是收到了序号为y的话，即ack=y+1），同意建立连接。（第二次握手，发送ACK-SYN包，然后进入SYN-RCVD状态）\n\t\t- A听到B说同意建立连接之后，对B说：与确认你同意与我连接（ack=y+1,ACK=1,seq=x+1）。（第三次握手，A已进入ESTABLISHED状态）\n\t\t- B听到A的确认之后，也进入ESTABLISHED状态。\n\n\t- 为什么要有三次握手？\n\n\t\t- 两次握手的问题\n\n\t\t\t- 两次握手的问题在于服务器端不知道一个SYN是否是无效的\n\t\t\t- 假设只有两次握手，比如图中的1，2步，当A想要建立连接时发送一个SYN，然后等待ACK，结果这个SYN因为网络问题没有及时到达B，所以A在一段时间内没收到ACK后，在发送一个SYN，B也成功收到，然后A也收到ACK，这时A发送的第一个SYN终于到了B，对于B来说这是一个新连接请求，然后B又为这个连接申请资源，返回ACK，然而这个SYN是个无效的请求，A收到这个SYN的ACK后也并不会理会它，而B却不知道，B会一直为这个连接维持着资源，造成资源的浪费\n\n\t\t- 三次握手可以保证任何一次握手出现问题，都是可以被发现或补救的\n\n\t\t\t- 因为客户端会给服务器回复第二次握手，也意味着服务器会等待客户端的第三次握手，如果第三次握手迟迟不来，服务器便会认为这个SYN是无效的，释放相关资源。\n\n\t\t- 一句话：“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”\n\n- 四次挥手\n\n\t- 实际过程\n\n\t\t- 1.A与B交谈结束之后，A要结束此次会话，对B说：我要关闭连接了（seq=u,FIN=1）。（第一次挥手，A进入FIN-WAIT-1）\n\t\t- 2.B收到A的消息后说：确认，你要关闭连接了。（seq=v,ack=u+1,ACK=1）（第二次挥手，B进入CLOSE-WAIT）\n\t\t- 3.A收到B的确认后,等了一段时间，因为B可能还有话要对他说。（此时A进入FIN-WAIT-2）\n\t\t- 4.B说完了他要说的话（只是可能还有话说）之后，对A说，我要关闭连接了。（seq=w, ack=u+1,FIN=1，ACK=1）(第三次挥手)\n\t\t- 5.A收到B要结束连接的消息后说：已收到你要关闭连接的消息。（seq=u+1,ack=w+1,ACK=1）(第四次挥手，然后A进入CLOSED)\n\t\t- 6.B收到A的确认后，也进入CLOSED。\n\n\t-  为什么要四次挥手？\n\n\t\t- 根本原因是，一方发送FIN只表示自己发完了所有要发的数据，但还允许对方继续把没发完的数据发过来。\n\n### TCP、UDP协议区别\n\n- 1，TCP是面向连接的协议，UDP是无连接协议； \n\n\t- 对于面向连接的： 两个人打电话时，双方确认并建立连接后才能进行通信。 \n\t- 对于面向无连接的：在邮局寄信时，你只需要将信放在邮筒里，不需要给收件人通知，收件人也不知道你给他寄信了\n\n- 2，TCP无界，UDP有界； \n\n\t- TCP通过字节流传输，即TCP将应用程序看成是一连串的无结构的字节流。每个TCP套接口有一个发送缓冲区，如果字节流太长时，TCP会将其拆分进行发送。当字节流太短时，TCP会等待缓冲区中的字节流达到一定程度时再构成报文发送出去，TCP发给对方的数据，对方在收到数据时必须给矛确认，只有在收到对方的确认时，本方TCP才会把TCP发送缓冲区中的数据删除。 \n\t- 而UDP传输报文的方式是由应用程序控制的，应用层交给UDP多长的报文，UDP照样发送，既不拆分，也不合并，而是保留这些报文的边界，即一次发送一个报文。 \n\n- 3，TCP可靠，UDP不可靠； \n- 4，TCP有序，UDP无序； \n\n\t- 消息在传输过程中可能会乱序，后发送的消息可能会先到达，TCP会对其进行重排序，UDP不会。\n\n- 5，TCP有流量控制（以及拥塞处理），UDP没有； \n\n\t- 流量控制\n\n\t\t- TCP利用滑动窗口机制在TCP连接上实现对发送方的流量控制， 如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。 \n\t\t- 滑动窗口\n\n\t- 拥塞处理\n\n\t\t- 防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。 \n\n\t- 拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接受数据。而前者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。\n\t- 当出现网络抖动时，TCP会自觉降低发送速度，他会努力维护次序，但udp依然保持速度不变\n\n- 应用场景\n\n\t- TCP应用场景\n\n\t\t- 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。\n\n\t- UDP应用场景\n\n\t\t- 效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。\n\n## WEBSOCKET \n\n### （1）基于 HTTP 协议的方案的本质缺陷\n\n- 在浏览器与服务器通信间，传统的 HTTP 请求在某些场景下并不理想，比如实时聊天、实时性的小游戏等等，其面临主要两个缺点：\n\n\t- 无法做到消息的「实时性\n\t- 服务端无法主动推送信息\n\n- 其基于 HTTP 的主要解决方案有：\n\n\t- 基于 ajax 的轮询：客户端定时或者动态相隔短时间内不断向服务端请求接口，询问服务端是否有新信息；其缺点也很明显：多余的空请求（浪费资源）、数据获取有延时；\n\t- Long Poll：其采用的是阻塞性的方案，客户端向服务端发起 ajax 请求，服务端挂起该请求不返回数据直到有新的数据，客户端接收到数据之后再次执行 Long Poll；该方案中每个请求都挂起了服务器资源，在大量连接的场景下是不可接受的；\n\n- 本质缺陷即「被动性」，服务端无法下推消息，仅能由客户端发起请求不断询问是否有新的消息，同时对于客户端与服务端都存在性能消耗。\n\n### （2）WebSocket 是 HTML5 中提出的新的网络协议标准\n\n- 初步了解\n\n\t- WebSocket 是 HTML5 开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。 \n\t-  在 WebSocket API 中，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。\n\n- 特点\n\n\t- （1）建立于 TCP 协议之上的应用层；\n\t- （2）一旦建立连接（直到断开或者出错），服务端与客户端握手后则一直保持连接状态，是持久化连接；\n\t- （3）服务端可通过实时通道主动下发消息；\n\t- （4）数据接收的「实时性（相对）」与「时序性」；\n\n### （3）Websocket实践\n\n- 浏览器提供原生对象\n\n\t- 在浏览器中使用 Websocket 非常简单，在支持 Websocket 的浏览器中提供了原生的 WebSocekt 对象，其中对于消息的接收与数据帧处理在浏览器中已经封装好了。\n\n- 服务端实现\n\n\t- 使用 Websocket 需要服务端与客户端都提供相应能力，这里基于 Node.js 和 ws 简单建立一个服务端 Websocket 接口：\n\n\t- （1）在 8080 端口中监听了 express 的请求与 Websocket 请求，因为他们本身协议（http(s):// 与 ws(s)://）不同，因此不会冲突。\n\t- （2）同时在代码中可以看到其首先监听了 connection 事件（建立连接触发），在其回调中监听 message 事件（接收到消息）并立即 send 一条数据。\n\n- 浏览器实现\n\n\t- Websocket API\n\n\t\t- 浏览器中提供了原生类 WebSocket ，使用 new 关键字实例化它：\n\n\t\t\t- new  WebSocket(String url,optional String | [] protocols);\n\n\t\t- （1）接收两个参数：\n\n\t\t\t- url 表示需要连接的地址，比如：ws://localhost:8080；\n\t\t\t- protocols 可选参数，可以是一个字符串或者一个数组，用来表示子协议，这样做可以让一个服务器实现多种 WebSocket 子协议；\n\n\t\t- （2）实例化对象提供两个方法：\n\n\t\t\t- send 接收一个 String|ArrayBuffer|Blob 数据，作为数据发送到服务端；\n\t\t\t- close 接收一个（可选）的 code（关闭状态号，默认为 1000） 与一个（可选）的字符串（表示断开原因），客户端主动断开连接；\n\n\t\t- （3）连接状态：\n\n\t\t\t- WebSocket 类提供了一些常量表示连接状态：\n\n\t\t\t\t- WebSocket.CONNECTING 0 连接还没开启；\n\t\t\t\t- WebSocket.OPEN 1 连接已开启并准备好进行通信；\n\t\t\t\t- WebSocket.CLOSING 3 连接正在关闭的过程中；\n\t\t\t\t- WebSocket.CLOSED 4 连接已经关闭，或者连接无法建立；\n\n\t\t\t- WebSocket 的实例对象中提供了 readyState 属性来判断当前状态；\n\n\t\t- （4）实例化对象中可以监听到以下事件：\n\n\t\t\t- open 连接打开的回调事件，这时 readyState 变为 OPEN；\n\t\t\t- message 收到消息的回调事件，同时回调函数接收到一个 MessageEvent 数据；\n\t\t\t- close 连接关闭的回调事件，这时 readyState 变为 CLOSED；\n\t\t\t- error 建立与连接过程发生错误的回调事件；\n\n\t- 具体代码\n\n\t- 控制台中可以看到：\n\n\t\t- 首先触发 open 事件，之后每次发送数据服务端都会回复数据，因此触发了 message 事件，当发送 10 次之后浏览器主动断开连接，因此触发 close 事件；这里最后一次发送之后未收到服务端回复也是因为客户端立即断开了连接；\n\n- 事件与数据\n\n\t- 对 WebSocket 实例监听事件有两种方式，这里以 message 事件为例：\n\n\t\t- 对 onmessage 属性直接赋值，正如以上：ws.onmessage = function () {};；\n\t\t- 使用 addEventListener 监听事件，如：ws.addEventListener('message', function () {})；\n\n\t- 在 message 回调函数中得到 MessageEvent 类型参数 e ，我们需要的数据可以通过 e.data 获取；\n\t- 需要注意的一点是：\n\n\t\t- 不论服务端与客户端，其接受到的数据都是序列化后的字符串（当然也有 ArrayBuffer|Blob 类型数据），很多时候我们需要解析处理数据，比如 JSON.parse(e.data)；\n\n- 连接稳定性\n\n\t- 由于网络环境复杂，某些情况会出现断开连接或者连接出错，需要我们在 close 或者 error 事件中监听非正常断开并重连；\n\t- 由于一些原因在 error 时浏览器并不会响应回调事件，因此稳妥的做法还需要在 open 之后开启一个定时任务去判断当前的连接状态 readyState ，在出现异常情况下尝试重连；\n\n- 心跳\n\n\t- websocket规范定义了心跳机制，一方可以通过发送ping（opcode 0x9）消息给另一方，另一方收到ping后应该尽可能快的返回pong（0xA）。\n\t- 心跳机制是用于检测连接的对方在线状态，因此如果没有心跳，那么无法判断一方还在连接状态中，一些网络层比如 nginx 或者浏览器层会主动断开连接，\n\t- 在 JavaScript 中，WebSocket 并没有开放 ping/pong 的 API ，虽然浏览器自带了心跳处理，然而不同厂商的实现也不尽相同，因此需要在我们开发时候与服务端约定好一个自实现的心跳机制；\n\t- 比如浏览器中，检测到 open 事件后，启动一个定时任务，每次发送数据 0x9 给服务端，而服务端返回 0xA 作为响应；\n\t- 实践下来，心跳的定时任务一般是相隔 15-20 秒发送一次。\n\n### （4）网络协议\n\n- WebSocket与网络协议的关系\n\n\t- 前文说到，Websocket 是建立与 TCP 之上，那么其与 HTTP 协议有和关系呢？\n\t- Websocket 连接分为建连阶段与连接阶段，在建立连接阶段借助于 HTTP ，而在连接阶段则与 HTTP 无关。\n\n- 建立连接阶段\n\n\t- 从浏览器的 Network 中，找到 ws 连接，可以看到：\n\n\t- 这是一个标准的 HTTP 请求，相比于我们常见的 HTTP 请求协议，请求头中多了几个字段：\n\n\t\t- Connection 为 Upgrade ，Upgrade 为 websocket ，表示告知 Nginx 与 Apache 等服务器该次连接并非为 HTTP 连接，实质上是一个 websocket ，因此服务器会转发到相应的 websocket 任务处理；\n\t\t- Sec-WebSocket-Key 是一个 Base64 encode 的值，由浏览器随机生成的，用于验证服务器连接的正确性；\n\t\t- Sec-WebSocket-Versio 表示为使用的 websocket 服务版本；\n\n\t- 响应头中：\n\n\t\t- 可以看到其返回状态码为 101 ，表示切换协议；\n\t\t- Upgrade 与 Connection 用于回复客户端表示已经切换协议成功；\n\t\t- Sec-WebSocket-Accept 字段与 Sec-WebSocket-Key 相对应，用于验证服务的正确性；\n\n- 连接阶段\n\n\t- 当通过 HTTP 建立连接握手后，接下来则是真正的 Websocket 连接了，其基于 TCP 收发数据，Websocket 封装并开放接口。\n\n- WSS\n\n\t- 在 HTTP 协议中，很多时候为了加密与安全需要使用 HTTPS 请求（HTTP + TCL）；相应的，在 Websocket 协议中，也是可以使用加密传输的 —— wss ，比如 wss://localhost:8080。\n\t- 使用的也是与 HTTPS 一样的证书，在这里一般是交由 Nginx 等服务层去做证书处理。\n\n",sr={data:function(){return{MainComponent:rr}}},or=sr,lr=Object(v["a"])(or,er,ar,!1,null,"5e646b3c",null),ir=lr.exports,cr=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{},[e("q-markdown",{attrs:{src:t.MainComponent}})],1)},pr=[],br="# 前后端通信\n\n## 常用请求方法\n\n### HTTP 0.9\n\n- GET\n\n### HTTP1.0\n\n- POST\n- HEAD\n\n\t- 描述\n\n\t\t- HEAD方法和GET方法一样，知识不返回豹纹的主体部分，用于确认URI的有效性及资源更新的日期时间等。\n\n\t- 具体\n\n\t\t- （1）可以在不获取资源的情况下很快地就能了解到资源的情况，比如其类型，其文件大小，\n\t\t- （2）也可以通过响应码查看是否存在该资源，\n\t\t- （3）也可以检测资源是否被修改了。\n\n\t- HEAD方法和GET方法的区别： GET方法有实体，HEAD方法无实体。\n\n### HTTP1.1\n\n- PUT\n\n\t- 描述\n\n\t\t- PUT方法用来传输文件，就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存在请求URI指定的位置。但是HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全问题，故一般不用。\n\n\t- 什么时候用POST或PUT？\n\n\t\t- 取决于这个REST服务的行为是否是idempotent（等幂）的（一个方法重复执行多次，产生的效果是一样的）\n\t\t- 假如我们发送两个http://superblogging/blogs/post/Sample请求，服务器端是什么样的行为？如果产生了两个博客帖子，那就说明这个服务不是idempotent的，因为多次使用产生了副作用了嘛；如果后一个请求把第一个请求覆盖掉了，那这个服务就是idempotent的。前一种情况，应该使用POST方法，后一种情况，应该使用PUT方法。\n\n- DELETE\n\n\t- 描述\n\n\t\t-  指明客户端想让服务器删除某个资源，与PUT方法相反，按URI删除指定资源\n\n\t- 响应\n\n\t\t- （1）如果响应里包含描述成功的实体，响应应该是200（Ok）\n\t\t- （2）如果DELETE动作没有通过，应该以202（已接受）响应\n\t\t- （3）如果DELETE方法请求已经通过了，但响应不包含实体，那么应该以204（无内容）响应。\n\n- CONNECT\n\n\t- 描述\n\n\t\t- \nCONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。\n\n- OPTIONS\n\n\t- 描述\n\n\t\t- OPTIONS 方法请求 Web 服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法。(有些服务器可能只支持对一些特殊类型的对象使用特定的操作)。\n\t\t- 通过使用 OPTIONS，客户端可以在与服务器进行交互之前，确定服务器的能力，这样它就可以更方便地与具备不同特性的代理和服务器进行互操作了。\n\t\t- 这为客户端应用程序提供了一种手段，使其不用实际访问那些资源就能判定访问各种资源的最优方式。\n\n- TRACE\n\n\t- 描述\n\n\t\t- \nTRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。\n\t\t- TRACE 响应的 Content-Type 为 message/http，状态为 200 OK。\n\n\t- 原理\n\n\t\t- \nTRACE 请求会在目的服务器端发起一个 环回 诊断。行程最后一站的服务器会弹回一条 TRACE 响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看在所有中间 HTTP 应用程序组成的请求 / 响应链上，原始报文是否，以及如何被毁坏或修改过。\n\n### HTTP1.1 扩展\n\n- PATCH\n\n\t- 描述\n\n\t\t- PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：\n\n\t\t\t- PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。\n\t\t\t- 当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。\n\n## GET、POST方法区别\n\n### （1）GET在浏览器回退时是无害的，而POST会再次提交请求。\n\n### （2）GET产生的URL地址可以被Bookmark，而POST不可以。\n\n### （3）GET请求会被浏览器主动cache，而POST不会，除非手动设置。\n\n### （4）GET请求只能进行url编码，而POST支持多种编码方式。\n\n### （5）GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。\n\n### （6）GET请求在URL中传送的参数是有长度限制的，而POST么有。\n\n### （7）对参数的数据类型，GET只接受ASCII字符，而POST没有限制。\n\n### （8）GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。\n\n### （9）GET参数通过URL传递，POST放在Request body中。\n\n### （10）GET产生一个TCP数据包；POST产生两个TCP数据包。\n\n- 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；\n- 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。\n\n## 常用content-type类型\n\n### （1）application/x-www-form-urlencoded \n\n- 描述\n\n\t- 1）浏览器的原生form表单\n\t- 2） 提交的数据按照 key1=val1&key2=val2 的方式进行编码，key和val都进行了URL转码\n\n- 具体\n\n### （2）multipart/form-data\n\n- 描述\n\n\t- 主要用于上传文件。（使用表单上传文件时，必须让 form 的 enctype 等于这个值。）\n\n首先生成一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。\n\n\t- 消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 --boundary 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。\n\t- 如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 --boundary-- 标示结束。\n\n- 具体\n\n### （3）application/json\n\n- 描述\n\n\t- Json格式⽀支持比键值对复杂地多的数据，适合restful的接⼝口。\n\n- 具体\n\n### （4）text/html、text/plain、text/xml\n\n- HTML格式、纯文本格式、XML格式\n\n## 常见状态码含义\n\n### 1xx\n\n- 100（Continue/继续）\n\n\t- 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。\n\n- 101（Switching Protocols/切换协议）\n\n\t- 请求者已要求服务器切换协议，服务器已确认并准备切换。主要用于websocket，也可以用于http2的升级。\n\n### 2xx\n\n- 200（OK/正常）\n\n\t- 服务器已经成功处理了请求。通常，这表示服务器提供了请求的网页。\n\n- 201（Created/已创建）\n\n\t- 请求成功并且服务器创建了新的资源\n\n- 202（Accepted/已接受）\n\n\t- 服务器已接受请求，但尚未处理\n\n- 203 (Non-Authoritative Information/非官方信息)\n\n\t- 服务器已经成功处理了请求，但返回的信息可能来自另一来源\n\n- 204（NO Content/无内容）\n\n\t- 服务器成功处理了请求，但没有返回任何内容\n\n- 205 (Reset Content/重置内容)\n\n\t- 服务器成功处理了请求，但没有返回任何内容\n\n- 206 (Partial Content/局部内容)\n\n\t- 该状态码表示客户端进行了请求，请求资源的某一部分，而服务器成功执行了这部分的 GET 请求，响应报文中包含由 Content-Range 指定范围的实体内容\n\n### 3xx\n\n- 300（Multiple Choices/多重选择）\n\n\t-  针对请求，服务器可执行多种操作。服务器可根据请求者（user agent）选择一项操作，或提供操作列表供请求者选择。\n\n- 301（Moved Permanently/永久重定向）\n\n\t- 永久性重定向\n\n- 302（Found/临时重定向）\n\n\t- 临时性重定向\n\n- 303 （See Other/参见其他信息）\n\n\t- 该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。\n\t- 303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。 \n\n- 304（Not Modified/未修改）\n\n\t- 自动上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页的内容（协商缓存）\n\n- 305（Use Proxy/使用代理）\n\n\t- 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理\n\n- 307（Temporary Redirect /临时重定向）\n\n\t- 用于HSTS跳转。全称HTTP严格传输安全（HTTP Strict Transport Security，縮寫：HSTS）。功能是要求浏览器下次访问该站点时使用HTTPS来访问，而不再需要先是HTTP再转HTTPS。这样可以避免SSL剥离攻击，具体使用方法是在服务器响应头中添加 Strict-Transport-Security，可以设置 max-age\n\t- SSL剥离攻击（攻击HTTPS）\n\n\t\t- 描述\n\n\t\t\t- 即攻击者在用户使用http访问的过程中进行攻击，对服务器冒充自己是用户，在攻击者和服务器中使用https访问，在用户和服务器中使用http访问。\n\n\t\t- 另一种攻击号称安全的HTTPS的方法是：SSL挟持\n\n\t\t\t- 大概就是信任第三方的安全证书，这点被利用于代理软件监听https。\n\n### 4xx\n\n- 400（Bad Request/错误请求）\n\n\t- 服务器不理解请求的语法\n\n- 401（Unauthorized/未验证）\n\n\t- 请求要求身份验证。对于需要登录的网页，服务器可能返回此响应\n\n- 403（Forbidden/禁止）\n\n\t- 没有权限请求，表示除非拥有授权，否则服务器拒绝提供所请求的资源。\n\n- 404（Not Found/未找到）\n\n\t- 服务器找不到请求的网页\n\n- 405 (Method Not Allowed/方法未允许)\n\n\t- 禁用请求中指定的方法\n\n- 406 (Not Acceptable/无法访问)\n\n\t- 表示请求资源的MIME类型与客户端中Accept头信息中指定的类型不一致，无法使用请求的内容特性响应请求的网页\n\n- 407 (Proxy Authentication Required/代理服务器认证要求)\n\n\t- 与401状态有些相似，只是这个状态用于代理服务器。该状态指出客户端必须通过代理服务器的认证。代理服务器返回一个Proxy-Authenticate响应头信息给客户端，这会引起客户端使用带有Proxy-Authorization请求的头信息重新连接。\n\n- 408 (Request Timeout/请求超时)\n\n\t- 是指服务端等待客户端发送请求的时间过长。\n\n- 409 (Conflict/冲突)：\n\n\t- 该状态通常与PUT请求一同使用，常被用于试图上传版本不正确的文件时。\n\n- 410 (Gone/已经不存在)\n\n\t- 告诉客户端所请求的文档已经不存在并且没有更新的地址。410状态不同于404，410是在指导文档已被移走的情况下使用，而404则用于未知原因的无法访问。\n\n- 411 (Length Required/需要数据长度)\n\n\t- 服务器不接受不含有效内容长度标头字段的请求，除非客户端发送Content-Length头信息指出发送给服务器的数据的大小。\n\n- 412 (Precondition Failed/未满足前提条件)\n\n\t- 服务器未满足请求者在请求者设置的其中一个前提条件\n\n- 413 (Request Entity Too Large/请求实体过大)\n\n\t- 服务器无法处理请求，因为请求实体过大，超出了服务器的处理能力\n\n- 414 (Request URI Too Long/请求URI过长)\n\n\t- 请求的URI（通常为网址）过长，服务器无法处理\n\n- 415 (Unsupported Media Type/不支持的媒体类型)\n\n\t- 请求的格式不受请求页面的支持\n\n- 416 (Requested Range Not Satisfiable/请求范围无法满足)\n\n\t- 表示客户端包含了一个服务器无法满足的Range头信息的请求，如果页面无法提供请求的范围，则服务器会返回此状态码\n\n- 417 (Expectation Failed/期望失败)\n\n\t- 如果服务器得到一个带有100-continue值的Expect请求头信息，这是指客户端正在询问是否可以在后面的请求中发送附件。在这种情况下，服务器也会用该状态(417)告诉浏览器服务器不接收该附件或用100 (SC_CONTINUE)状态告诉客户端可以继续发送附件\n\n### 5xx\n\n- 500 (Internal Server Error/服务器内部错误)\n\n\t- 服务器遇到错误，无法完成请求\n\n- 501 (Not Implemented/未实现)\n\n\t- 服务器不具备完成此请求中要求的功能。例如，服务器无法识别请求方法时可能会返回此代码，或者客户端执行了如PUT这样的服务器并不支持的命令。\n\n- 502 (Bad Gateway/错误的网关)\n\n\t- 服务器作为网关或代理，从上游服务器无法收到无效响应\n\n- 503 (Service Unavailable/服务器不可用)\n\n\t- 服务器目前无法使用（由于超载或者停机维护）。通常，这只是暂时状态\n\n- 504 (Gateway Timeout/网关超时)\n\n\t- 服务器作为网关代理，但是没有及时从上游服务器收到请求\n\n- 505 (HTTP Version Not Supported/不支持的 HTTP 版本)\n\n\t- 服务器并不支持在请求中所标明 HTTP 版本\n\n*XMind: ZEN - Trial Version*",ur={data:function(){return{MainComponent:br}}},vr=ur,gr=Object(v["a"])(vr,cr,pr,!1,null,"0ff8b3cd",null),mr=gr.exports,_r=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},dr=[],hr={},fr=hr,yr=Object(v["a"])(fr,_r,dr,!1,null,"2b8607ad",null),Sr=yr.exports,wr=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},kr=[],xr={},Cr=xr,jr=Object(v["a"])(Cr,wr,kr,!1,null,"0191eeee",null),Pr=jr.exports,Tr=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Er=[],Or={},Mr=Or,Ar=Object(v["a"])(Mr,Tr,Er,!1,null,"50c453a2",null),Nr=Ar.exports,Ir=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Dr=[],zr={},$r=zr,Rr=Object(v["a"])($r,Ir,Dr,!1,null,"a4ac8520",null),Jr=Rr.exports,Lr=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Hr=[],qr={},Fr=qr,Wr=Object(v["a"])(Fr,Lr,Hr,!1,null,"f894b69e",null),Br=Wr.exports,Ur=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Gr=[],Vr={},Xr=Vr,Qr=Object(v["a"])(Xr,Ur,Gr,!1,null,"59c18bf2",null),Yr=Qr.exports,Kr={components:{m1:ir,m2:mr,m3:Sr,m4:Pr,m5:Nr,m6:Jr,m7:Br,m8:Yr},data:function(){return{tab:"m1",tabs:[{label:"http基本",value:"m1"},{label:"前后端通信",value:"m2"}]}}},Zr=Kr,ts=Object(v["a"])(Zr,tr,nr,!1,null,"cb5d7a8c",null),ns=ts.exports,es=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+t.value,label:n+1+"."+t.label}})})),1),e("div",{staticClass:"q-mx-lg"},[e(""+t.tab,{tag:"component"})],1)],1)},as=[],rs=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},ss=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("div",[e("a",{attrs:{href:"https://blog.csdn.net/aSuncat/article/details/88674643",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://blog.csdn.net/aSuncat/article/details/88674643")]),e("br"),e("a",{attrs:{href:"https://www.cnblogs.com/chenwenhao/p/11258895.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.cnblogs.com/chenwenhao/p/11258895.html")])]),e("div",{staticClass:"htmledit_views"},[e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("1、")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("v-model是什么？ vue中标签怎么绑定事件？")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("答：")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("v-model这个指令只能用在表单元素上，可以用他进行双向数据绑定。")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("<input @click=doLog() />")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[t._v("2"),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("mvvm框架是什么？")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("说说对双向数据绑定的理解？")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("jquery）的区别是什么？哪些场景适合？")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("mvvm")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("的")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("m")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("v经过数据改变后的html、")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("vm")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("就是")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("连接数据和视图，")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("用来实现双向绑定")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v(":一个变了另外一个跟着变了，例如：视图一个绑定了模型的节点有变化，模型对应的值会跟着变")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("vue数据驱动，通过数据来显示视图层而不是节点操作。")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("场景：数据操作比较多的场景，更加便捷")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("3、自定义指令")]),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("vue对象的directive方法里面有两个参数，一个是指令名称，另外一个是函数。组件内定义指令（局部定义指令）：directives")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("bind（绑定事件触发）、inserted(节点插入的时候触发)、update（组件内相关更新）、")]),e("span",{staticStyle:{color:"rgb(85,85,85)"}},[t._v("componentUpdated")]),e("span",{staticStyle:{color:"rgb(85,85,85)"}},[t._v("（")]),e("span",{staticStyle:{color:"rgb(85,85,85)"}},[t._v("被绑定元素所在模板完成一次更新周期时调用")]),e("span",{staticStyle:{color:"rgb(85,85,85)"}},[t._v("）、")]),e("span",{staticStyle:{color:"rgb(85,85,85)"}},[t._v("unbind")]),e("span",{staticStyle:{color:"rgb(85,85,85)"}},[t._v("（")]),e("span",{staticStyle:{color:"rgb(85,85,85)"}},[t._v("只调用一次，指令与元素解绑时调用")]),e("span",{staticStyle:{color:"rgb(85,85,85)"}},[t._v("）")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("el、binding")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("4、")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("4种vue当中的指令和它的用法？")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("答：")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("v-if：判断是否隐藏；v-for：数据循环出来；v-bind:class：绑定一个属性；v-model：实现双向绑定")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("5、")]),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("vue生命周期的理解？")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("/后：\n        在beforeCreated阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("/后：当data变化时，会触发beforeUpdate和updated方法。")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("6、")]),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("\n          vue 组件")]),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("答：首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("使用")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("Vue")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v(".component")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("方法注册组件。子组件需要数据，可以在")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("props")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("emit")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("方法。")])]),e("p",[e("strong",[t._v("7、"),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("Vue.js内置的指令，用什么开头？")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("v-开头的")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[t._v("8、CSS隐藏元素的几种方法？说出他们的区别")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}}),e("p",{staticStyle:{background:"rgb(255,255,255)"}}),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("\n      opacity:0 透明度为0，占物理位置\n    ")]),e("p",{staticStyle:{background:"rgb(255,255,255)"}}),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("\n      9、"),e("strong",[t._v("CSS清除浮动的几种方法（至少两种）")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("clear属性的空元素")]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("CSS的overflow属性；")]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("\n      CSS的:after伪元素"),e("span",{staticStyle:{color:"rgb(44,44,44)"}}),t._v("；\n    ")]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[t._v("10、例举3种强制类型转换?")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("parseInt,parseFloat,number")]),e("h4",[e("strong",[t._v("11、")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("pop")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("()")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}}),e("span",{staticStyle:{color:"rgb(51,51,51)"}}),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("push")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}}),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("shift")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("()")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}}),e("span",{staticStyle:{color:"rgb(51,51,51)"}}),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("unshift")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("() ")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("有什么区别")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("?")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}}),e("p",{staticStyle:{background:"rgb(255,255,255)"}}),e("p",{staticStyle:{background:"rgb(255,255,255)"}}),e("p",[t._v("12、"),e("strong",[t._v("提交表单，有几种方式")])]),e("p",[e("span",{staticStyle:{color:"rgb(75,75,75)",background:"rgb(255,255,255)"}},[t._v("submit")]),t._v("提交，"),e("span",{staticStyle:{color:"rgb(75,75,75)",background:"rgb(255,255,255)"}},[t._v("Ajax提交form表单")])]),e("p",[e("strong")]),e("p",[e("strong",[t._v("13、定义一个div，让其在页面中，垂直居中显示")])]),e("p"),e("p"),e("p"),e("p"),e("p"),e("p",[t._v("height:200px;")]),e("p",[t._v("margin-left:-250px;")]),e("p",[t._v("margin-top:-100px;")]),e("p",[t._v("background:red;")]),e("p",[t._v("}")]),e("p"),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("1")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("4")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("active-class是哪个组件的属性？嵌套路由怎么定义？")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("vue-router模块的router-")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("link")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("组件。")]),e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("children数组来定义子路由")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("15")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("vue-router的动态路由？怎么获取传过来的动态参数？")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("router目录下的index.js文件中，对path属性加上/:")]),e("span",{staticStyle:{color:"rgb(0,134,179)"}},[t._v("id")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("router对象的params.")]),e("span",{staticStyle:{color:"rgb(0,134,179)"}},[t._v("id")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("16")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("vue-router有哪几种导航钩子？")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("router.beforeEach(")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("to")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v(",")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("from")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v(",")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("next")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v(")，")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("作用：跳转前进行判断拦截。第二种：组件内的钩子；第三种：单独路由独享组件")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("1")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("7")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("vue-router是什么？它有哪些组件？")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("vue用来写路由一个插件。router-link、router-")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("view")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("18、")]),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("vuex的？")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("vuex可以理解为一种")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("状态管理的")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("开发模式或")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("者")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("框架")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("，")]),e("span",{staticStyle:{color:"rgb(85,85,85)",background:"rgb(255,255,255)"}},[t._v("data中的属性需要共享给其他vue组件使用")]),e("span",{staticStyle:{color:"rgb(85,85,85)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(51,51,51)"}}),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[e("span",{staticStyle:{"font-family":"'华文仿宋'"}},[t._v("为")]),t._v("state")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("store中； 改变状态的方式是提交mutations，这是个同步的事物；\n        异步逻辑应该封装在action中")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("。")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("19、")]),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("vuex有哪几种属性？")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v(" State、 Getter、Mutation 、")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("Action")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}}),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("Module")])])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}},[t._v("state => 基本数据")]),e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}},[t._v("(")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("数据源存放地")]),e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}},[t._v(")")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[e("br")]),e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}},[t._v("getters => 从基本数据派生")]),e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[e("br")]),e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[e("br")]),e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[e("br")]),e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}},[t._v("modules => 模块化Vuex")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(238,238,238)"}},[t._v("20、")]),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("5、Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("vuex 的")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("state")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("里。")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("action里，方便复用")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("21")]),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("axios是什么？怎么使用？")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("npm install axios -")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("-save")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("装好，")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("js中使用")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("import")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v(".")]),e("span",{staticStyle:{color:"rgb(0,134,179)"}},[t._v("get")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v(".post。返回在.then函数中如果成功，失败则是在.")]),e("span",{staticStyle:{color:"rgb(0,134,179)"}},[t._v("catch")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("函数中")])]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}})])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("22")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("axios+tp5进阶中，调用axios.post(‘api/user’)是进行的什么操作？axios.put(‘api/user/8′)呢？")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("答：添加用户操作，更新操作。")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("23")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("RESTful API？怎么使用?")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("api的标准，无状态请求。请求的路由地址是固定的，")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("tp5则先路由配置中把资源路由配置好。标准有：")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}}),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v(".post")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}}),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v(".put")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}}),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v(".delete")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("24")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("vuex是什么？怎么使用？哪种功能场景使用它？")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("vue框架中状态管理。在main.js引入store，注入。")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("store")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v(".js")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("….. ")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("export")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("25")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("、")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("webpack?")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}})])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("答：")]),e("span",{staticStyle:{color:"rgb(47,47,47)",background:"rgb(255,255,255)"}},[t._v("WebPack可以看做是")]),e("strong",[e("span",{staticStyle:{color:"rgb(47,47,47)",background:"rgb(255,255,255)"}})]),e("span",{staticStyle:{color:"rgb(47,47,47)",background:"rgb(255,255,255)"}},[t._v("JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v(".vue文件的一个加载器，")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("将")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("template/")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("js")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("/style转换成")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("js")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("模块。")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("用途：")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("js")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("es6、style样式可以scss或less、template可以加jade等")])]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}})])]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}})])]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("26、说几个ajax返回error的原因")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("1、")]),e("span",{staticStyle:{color:"rgb(75,75,75)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("dataType")]),e("span",{staticStyle:{color:"rgb(75,75,75)",background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v("dataType类型和前台写的不一致会跳入error")])]),e("p",[e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v("jquery1.4之后对json的格式要求非常严格，json格式错误也会跳入error")])]),e("p",[e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v("2、")]),e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v("data不能不写")])]),e("p",[e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v('data为空也一定要传"{}"；不然返回的是xml格式的。')])]),e("p",[e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v("3")]),e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v(".")]),e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v("、")]),e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v("传递的参数")])]),e("p",[e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v("ajax支持的编码格式")])]),e("p",[e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v("4、")]),e("span",{staticStyle:{color:"rgb(75,75,75)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v("路径不能有中文")])]),e("p",[e("span",{staticStyle:{color:"rgb(75,75,75)",background:"rgb(255,255,255)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v("27、")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("XMLHttpRequest")]),e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v("XMLHttpRequest.readyState: 状态码的意思")])])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v("0 － （未初始化）还没有调用send()方法")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v("1 － （载入）已调用send()方法，正在发送请求")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v("2 － （载入完成）send()方法执行完成，已经接收到全部响应内容")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v("3 － （交互）正在解析响应内容")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v("4 － （完成）响应内容解析完成，可以在客户端调用了")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(75,75,75)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v("28、")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("vue.cli项目中src目录每个文件夹和文件的用法？")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("答：")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("assets")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("文件夹是放静态资源；")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("components")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("是放组件；")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("router")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v(";")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}})]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v(".vue")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("是一个应用主组件；")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("main")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v(".js")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("是入口文件")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v("29、")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("components目录新建你的组件文件（")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("smithButton.vue），script一定要export\n        ")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("default {")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("第二步：在需要用的页面（组件）中导入：")]),e("strong",[e("span",{staticStyle:{color:"rgb(153,153,153)"}},[t._v("import")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}}),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("smithButton ")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("from ‘../components/")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("smithButton.vue’")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("vue的子组件的components属性上面,components:{")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("smithButton}")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("template视图view中使用，<")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("smith-button> ")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}}),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("smith-button>")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("问题有：")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("smithButton命名，使用的时候则smith-button。")])])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v("30、")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("element.ui吗？说下它其中两个组件的使用方法？")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("答：使用过")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("；")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("用过一个布局的，它是由")]),e("span",{staticStyle:{color:"rgb(0,128,128)"}},[t._v("24")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v(":span后面带的数字它占")]),e("span",{staticStyle:{color:"rgb(0,128,128)"}},[t._v("24")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v(":offset是它的间距，后面也是跟数字，也是从")]),e("span",{staticStyle:{color:"rgb(0,128,128)"}},[t._v("24")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("份里面取的。")])]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("input")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("el-")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("input")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("，后面")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("type")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("跟上一个属性就是显示不同按钮的类型，有默认的")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("default")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("success（成功的）、warning（警告）、danger（危险）、info（）、primary（）")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("31、")]),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("vue框架？")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("答：")]),e("span",{staticStyle:{color:"rgb(0,128,128)"}},[t._v("1")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("、数据信息量比较多的。")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,128,128)"}},[t._v("2")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("web和app应用多端共用一套界面的项目，因为使用vue.cli+webpack后的前端目录，非常有利于项目的跨平台部署。")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v("32、")]),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("PC端项目你会在哪些场景使用Vue框架？")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("vue为什么解决这些问题呢？")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("dom操作")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("js和html都会有列表的html布局，迭代很困难。再一个dom节点的大面积添加会影响性能。")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("v-for在view层一个地方遍历数据即可")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("。")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("vue通过Virtual Dom就是在")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("js中模拟DOM对象树来优化DOM操作。")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(75,75,75)"}})])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v("33、call（） 和 apply（） 的作用和区别？")])])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v("答：")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("blackCat.say.call(whiteDog)")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}})]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("call(thisObj，arg1,arg2)")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(51,51,51)"}}),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("A")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("pply(thisObj，[arg1,arg2])")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(51,51,51)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("34、举例说ES6有哪些的新功能？")])])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(75,75,75)"}})])]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v("35")]),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[t._v("ajax请求的时候get 和post方式的区别")])])]),e("p",[e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("G")]),e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("et 一般用于获取信息")])]),e("p",[e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("URL传递参数")])]),e("p",[e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("2000字符")])]),e("p",[e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("P")]),e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("ost 一般用于修改服务器资源（新建，或者 修改）")])]),e("p",[e("span",{staticStyle:{background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{background:"rgb(255,255,255)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v("36、")]),e("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[t._v("JavaScript中如何检测一个变量是一个String类型？请写出函数实现\n        ")])])]),e("p",[e("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[t._v("return typeof(obj) == ")]),e("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[t._v("“")]),e("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[t._v("string")]),e("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[t._v("”")]),e("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[t._v(";\n      ")])]),e("p",[e("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[t._v("}")])]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[t._v("37、")]),e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("JSON 的了解？")])]),e("br"),e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("JSON(JavaScript Object Notation)\n        是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单,\n        易于读写, 占用带宽小。")]),e("br"),e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("{'age':'12', 'name':'back'}")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(44,44,44)"}},[t._v("38")]),t._v("如何阻止事件冒泡和默认事件")])]),e("p",[e("strong",[t._v("阻止事件冒泡：")]),e("span",{staticStyle:{background:"rgb(248,248,255)"}},[t._v("event.stopPropagation();\n      ")])]),e("p",[e("span",{staticStyle:{background:"rgb(248,248,255)"}}),e("strong",[t._v("默认事件：")]),e("span",{staticStyle:{background:"rgb(248,248,255)"}},[t._v("event.preventDefault();")])]),e("p",[e("span",{staticStyle:{background:"rgb(248,248,255)"}}),e("strong",[e("span",{staticStyle:{background:"rgb(248,248,255)"}},[t._v("return")]),e("span",{staticStyle:{background:"rgb(248,248,255)"}}),e("span",{staticStyle:{background:"rgb(248,248,255)"}},[t._v("false")])]),e("span",{staticStyle:{background:"rgb(248,248,255)"}})]),e("p",[e("span",{staticStyle:{background:"rgb(248,248,255)"}})]),e("p",{attrs:{align:"justify"}},[e("strong",[e("span",{staticStyle:{color:"rgb(44,44,44)",background:"rgb(255,255,255)"}},[t._v("39、")]),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("A")]),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("jax数据格式")])])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}},[t._v("HTML、XML 或 JSON")]),e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}})]),e("p",{attrs:{align:"justify"}},[e("strong",[e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v("40、")]),t._v("window.load和$(document).ready()的区别")])]),e("p"),e("p",[t._v("Dom就绪就可以访问，但并不意味着，元素所有的关联文件已经下载完毕。")]),e("p"),e("p",[e("strong",[t._v("41、"),e("span",{staticStyle:{color:"rgb(44,44,44)"}},[t._v("css定义")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("@media ")]),e("span",{staticStyle:{color:"rgb(44,44,44)"}},[t._v("screen")]),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(44,44,44)"}},[t._v("@media")]),e("span",{staticStyle:{color:"rgb(44,44,44)"}}),e("span",{staticStyle:{color:"rgb(44,44,44)"}},[t._v("(min-width:768px) and (max-width:979px)")])]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(44,44,44)"}})])]),e("p",[t._v("42"),e("strong",[t._v("$this 和this区别")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("this，表示当前的上下文对象是一个html对象，可以调用html对象所拥有的属性和方法。")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[e("br")]),e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("$(this),代表的上下文对象是一个jquery的上下文对象，可以调用jquery的方法和属性值。")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("h4",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("43、")]),e("br")]),t._v("CSS"),e("br"),t._v("JS"),e("br"),t._v("\n      CSS 表达式（Expression）"),e("br"),t._v("\n      JavaScript 和 CSS"),e("br"),t._v("\n      JavaScript 和 CSS"),e("br"),t._v("\n      <link> 代替 @import"),e("br"),e("br"),t._v("DOM访问\n    ")]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("\n      优化图像css定位，图片全部保存在一张PNG8格式上）"),e("br"),t._v("favicon.ico要小而且可缓存\n    ")]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[t._v("44、ajax请求时，如何解析json数据")])]),e("p",[t._v("eval parse,鉴于安全性考虑 使用parse更靠谱")]),e("p",[e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("JSON.parse(jsonstr); //可以将JSON字符串反序列化成JSON对象")])]),e("p",[e("span",{staticStyle:{background:"rgb(255,255,255)"}}),e("strong")]),e("p"),e("h4",[e("strong",[t._v("45、"),e("span",{staticStyle:{color:"rgb(44,48,51)"}},[t._v("CSS实现三栏自适应布局（两边宽度固定，中间自适应）")])])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(153,51,0)"}}),e("strong",[e("span",{staticStyle:{color:"rgb(153,51,0)"}},[t._v("<div")])]),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("id")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(0,0,255)"}},[t._v('"box"')]),e("strong",[e("span",{staticStyle:{color:"rgb(153,51,0)"}},[t._v(">")])]),e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",{staticStyle:{background:"rgb(248,248,248)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("strong",[e("span",{staticStyle:{color:"rgb(153,51,0)"}},[t._v("<div")])]),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("id")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(0,0,255)"}},[t._v('"left_box"')]),e("strong",[e("span",{staticStyle:{color:"rgb(153,51,0)"}},[t._v("></div>")])]),e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("strong",[e("span",{staticStyle:{color:"rgb(153,51,0)"}},[t._v("<div")])]),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("id")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(0,0,255)"}},[t._v('"center_box"')]),e("strong",[e("span",{staticStyle:{color:"rgb(153,51,0)"}},[t._v("></div>")])]),e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",{staticStyle:{background:"rgb(248,248,248)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("strong",[e("span",{staticStyle:{color:"rgb(153,51,0)"}},[t._v("<div")])]),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("id")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(0,0,255)"}},[t._v('"right_box"')]),e("strong",[e("span",{staticStyle:{color:"rgb(153,51,0)"}},[t._v("></div>")])]),e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("strong",[e("span",{staticStyle:{color:"rgb(153,51,0)"}},[t._v("</div>")])]),e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(92,92,92)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("#box")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("{")]),e("strong",[e("span",{staticStyle:{color:"rgb(0,102,153)"}},[t._v("width")])]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v(":")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("100%")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v(";")]),e("strong",[e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("display")])]),e("span",{staticStyle:{color:"rgb(255,0,0)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("strong",[e("span",{staticStyle:{color:"rgb(0,102,153)"}},[t._v("height")])]),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("100px")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",{staticStyle:{background:"rgb(248,248,248)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("#left")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("_box,")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("#right")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("_box{")]),e("strong",[e("span",{staticStyle:{color:"rgb(0,102,153)"}},[t._v("width")])]),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("200px")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v(";")]),e("strong",[e("span",{staticStyle:{color:"rgb(0,102,153)"}},[t._v("height")])]),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("100px")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("#center")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("flex:")]),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("1")]),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v(";")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("strong",[e("span",{staticStyle:{color:"rgb(0,102,153)"}},[t._v("height")])]),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("100px")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("h4",[e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("46、")]),e("span",{staticStyle:{color:"rgb(44,48,51)"}},[t._v("CSS3中各个浏览器内核兼容的设置")])])]),e("p",{staticStyle:{background:"rgb(248,248,248)"}},[e("span",{staticStyle:{color:"rgb(255,0,0)"}}),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("-moz-")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(255,0,0)"}}),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("-ms-")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",{staticStyle:{background:"rgb(248,248,248)"}},[e("span",{staticStyle:{color:"rgb(255,0,0)"}}),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("-webkit-")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(255,0,0)"}}),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("-o-")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",[t._v("\n      IE9以下的浏览器不支持HTML5标签，所以需要导入一个html5.js补丁，原理是通过JS来生成HTML5新标签对象。\n    ")]),e("p",[t._v("\n      CSS都会用media query（响应式设计），IE8以下的浏览器不支持media\n      query，这会导致@media\n      声明的CSS不能生效，因此要导入一个css3-mediaqueries.js补丁。\n    ")]),e("p",[t._v("如下：")]),e("p",[e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("\x3c!--[if lte IE 8]> ")])]),e("p",[e("span",{staticStyle:{color:"rgb(255,0,0)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(255,0,0)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(255,0,0)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("<![endif]--\x3e")])]),e("p",[t._v("\n      /*\n      因为条件注释只对IE10以下版本有效（IE11已经取消支持），所以在其他现代浏览器里面会自动忽略，不会加载，因此不会有性能问题\n      */\n    ")]),e("p",[t._v("\n      /*\n      因为IE9以下浏览器不支持CSS3，IE9支持一部分，因此不能显示一些CSS3的过渡效果，对此有两种办法，一种是忽略，也就是降级或者是差异化设计。\n    ")]),e("p",[t._v("\n      jquery的动画替代，引入方法可以是条件注释，也可以通过检测Navigator来判断IE版本\n      */\n    ")]),e("h4",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[e("strong",[e("br"),t._v("47、"),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("什么是层叠顺序")])])]),e("p"),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(248,248,248)"}},[t._v("border")]),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("/")]),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(248,248,248)"}},[t._v("background")]),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",[e("strong",[t._v("48、三角形的绘制")])]),e("p",[e("strong")]),e("p",{staticStyle:{background:"rgb(221,237,251)"}},[e("br"),t._v("#triangle-up {"),e("br"),e("br"),e("br"),e("br"),e("br"),e("br"),t._v("}\n    ")]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[t._v("49、CSS3有哪些新特性？")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("\n      CSS3实现圆角（border-radius:8px），阴影（box-shadow:10px），"),e("br"),t._v("text-shadow），线性渐变（gradient），变换（transform）\n    ")]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("\n      Transform： rotate(9deg) //旋转\n    ")]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("scale(0.85,0.90) //缩放")]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("translate(0px,-30px) //定位")]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("skew(-9deg,0deg) //倾斜")]),e("p",{staticStyle:{background:"rgb(255,255,255)"}}),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("50、")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("什么是响应式设计？")])])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("它是关于网页制作的过程中让不同的设备有不同的尺寸和不同的功能。响应式设计是让所有的人能在这些设备上让网站运行正常")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("51、写一段css3动画，在5s内，div背景色从red变为blue")])])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("div")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("{")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("width:100px;")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("height:100px;")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("background:red;")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("animation:myfirst 5s;")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("}")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("@keyframes myfirst")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("{")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("from {background:red;}")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("to {background:yellow;}")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("}")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",{attrs:{align:"justify"}},[e("strong",[t._v("52、Bootstrap的特性")])]),e("p",[t._v("响应式设计")]),e("p",[t._v("栅格布局")]),e("p",[t._v("完整的类库")]),e("p",[t._v("jQuery插件")]),e("p",[e("strong",[t._v("html5和css3,所以对浏览器有要求，IE必须9以上。")])]),e("p",[e("strong")]),e("p",{attrs:{align:"justify"}},[e("strong",[t._v("53、什么是boostrap")])]),e("p",[t._v("\n      Bootstrap是基于html、css、javascript的前端框架，为实现应用程序迅速开发的一套前端框架包\n    ")]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("54")])]),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("strong",[e("span",{staticStyle:{color:"rgb(34,34,34)"}},[t._v("div+css的布局较table布局有什么优点？")])])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(34,34,34)"}},[t._v(" css文件。")]),e("span",{staticStyle:{color:"rgb(34,34,34)"}},[e("br")]),e("span",{staticStyle:{color:"rgb(34,34,34)"}},[t._v("页面加载速度更快、结构化清晰、页面显示简洁。")]),e("span",{staticStyle:{color:"rgb(34,34,34)"}},[e("br")]),e("span",{staticStyle:{color:"rgb(34,34,34)"}},[t._v("表现与结构相分离。")]),e("span",{staticStyle:{color:"rgb(34,34,34)"}},[e("br")]),e("span",{staticStyle:{color:"rgb(34,34,34)"}},[t._v("seo）搜索引擎更友好，排名更容易靠前。")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("55、")]),e("strong",[e("span",{staticStyle:{color:"rgb(34,34,34)"}},[t._v("一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。")])])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(34,34,34)"}},[t._v("1、")]),e("span",{staticStyle:{color:"rgb(34,34,34)"}},[t._v("图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(34,34,34)"}},[t._v("2、")]),e("span",{staticStyle:{color:"rgb(34,34,34)"}},[t._v("如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(34,34,34)"}},[t._v("3、")]),e("span",{staticStyle:{color:"rgb(34,34,34)"}},[t._v("css图片，可以使用CSSsprite，SVGsprite，Iconfont、Base64等技术。")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(34,34,34)"}},[t._v("4、")]),e("span",{staticStyle:{color:"rgb(34,34,34)"}},[t._v("如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(34,34,34)"}},[t._v("5、")]),e("span",{staticStyle:{color:"rgb(34,34,34)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("55")])]),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("CSS3")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("新增伪类有那些？")])])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}},[t._v("\n        p 元素")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("。")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}},[t._v("\n        p 元素")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("。")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}},[t._v("\n        p 元素")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("。")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v(":checked，单选框或复选框被选中。")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("56、")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("Cookie, LocalStorage 与 SessionStorage")])]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("三者的异同")])]),e("table",{attrs:{border:"1",cellspacing:"0"}},[e("tbody",[e("tr",[e("td",{staticStyle:{background:"rgb(241,241,241)"}},[e("p",{attrs:{align:"center"}},[e("strong",[e("span",{staticStyle:{color:"rgb(102,102,102)"}},[t._v("特性")])])])]),e("td",{staticStyle:{background:"rgb(241,241,241)"}},[e("p",{attrs:{align:"center"}},[e("strong",[e("span",{staticStyle:{color:"rgb(102,102,102)"}},[t._v("Cookie")])])])]),e("td",{staticStyle:{background:"rgb(241,241,241)"}},[e("p",{attrs:{align:"center"}},[e("strong",[e("span",{staticStyle:{color:"rgb(102,102,102)"}},[t._v("localStorage")])])])]),e("td",{staticStyle:{background:"rgb(241,241,241)"}},[e("p",{attrs:{align:"center"}},[e("strong",[e("span",{staticStyle:{color:"rgb(102,102,102)"}},[t._v("sessionStorage")])])])])]),e("tr",[e("td",{staticStyle:{background:"rgb(255,255,255)"}},[e("p",[e("span",{staticStyle:{color:"rgb(102,102,102)"}},[t._v("数据的生命期")])])]),e("td",{staticStyle:{background:"rgb(255,255,255)"}},[e("p",[e("span",{staticStyle:{color:"rgb(102,102,102)"}},[t._v("一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效")])])]),e("td",{staticStyle:{background:"rgb(255,255,255)"}},[e("p",[e("span",{staticStyle:{color:"rgb(102,102,102)"}},[t._v("除非被清除，否则永久保存")])])]),e("td",{staticStyle:{background:"rgb(255,255,255)"}},[e("p",[e("span",{staticStyle:{color:"rgb(102,102,102)"}},[t._v("仅在当前会话下有效，关闭页面或浏览器后被清除")])])])]),e("tr",[e("td",[e("p",[e("span",{staticStyle:{color:"rgb(102,102,102)"}},[t._v("存放数据大小")])])]),e("td",[e("p",[e("span",{staticStyle:{color:"rgb(102,102,102)"}},[t._v("4K左右")])])]),e("td",{attrs:{width:"342",colspan:"2"}},[e("p",[e("span",{staticStyle:{color:"rgb(102,102,102)"}},[t._v("一般为5MB")])])])]),e("tr",[e("td",{staticStyle:{background:"rgb(255,255,255)"}},[e("p",[e("span",{staticStyle:{color:"rgb(102,102,102)"}},[t._v("与服务器端通信")])])]),e("td",{staticStyle:{background:"rgb(255,255,255)"}},[e("p",[e("span",{staticStyle:{color:"rgb(102,102,102)"}},[t._v("每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题")])])]),e("td",{staticStyle:{background:"rgb(255,255,255)"},attrs:{width:"342",colspan:"2"}},[e("p",[e("span",{staticStyle:{color:"rgb(102,102,102)"}},[t._v("仅在客户端（即浏览器）中保存，不参与和服务器的通信")])])])])])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("57、")]),e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v("高度坍塌产生的原因？如何解决？")])])]),e("p",[e("span",{staticStyle:{color:"rgb(75,75,75)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(75,75,75)"}},[e("br")]),e("span",{staticStyle:{color:"rgb(75,75,75)",background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(75,75,75)",background:"rgb(255,255,255)"}},[t._v("overflow: hidden;")])]),e("p",[e("span",{staticStyle:{color:"rgb(75,75,75)",background:"rgb(255,255,255)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("58、http状态码")])])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("200 - 请求成功")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("301 - 资源（网页等）被永久转移到其它URL")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("404 - 请求的资源（网页等）不存在")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("500 - 内部服务器错误")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",[e("strong",[t._v("59、px和em，rem的区别")])]),e("p",[t._v("\n      px是一个绝对字体大小，"),e("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}},[t._v("em是根据其父元素的字体大小来设置")]),t._v("1em=16px。那么12px=0.75em,\n      10px=0.625em，但是用em计算相对复杂；CSS3提供了rem，它也是个相对单位，"),e("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}},[t._v("rem只相对跟节点<html>计算")]),e("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",{staticStyle:{background:"rgb(248,248,248)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("16")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("=")]),e("span",{staticStyle:{color:"rgb(0,0,255)"}},[t._v("62")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",{staticStyle:{background:"rgb(248,248,248)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",{staticStyle:{background:"rgb(248,248,248)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("10")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("=")]),e("span",{staticStyle:{color:"rgb(0,0,255)"}},[t._v("1")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",[e("strong")]),e("p",[e("strong")]),e("p",[e("strong",[t._v("60、div垂直居中")])]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}},[t._v("<")]),e("span",{staticStyle:{color:"rgb(86,156,214)"}},[t._v("style")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}}),e("span",{staticStyle:{color:"rgb(156,220,254)"}},[t._v("type")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}},[t._v("=")]),e("span",{staticStyle:{color:"rgb(206,145,120)"}},[t._v('"text/css"')]),e("span",{staticStyle:{color:"rgb(212,212,212)"}}),e("span",{staticStyle:{color:"rgb(156,220,254)"}},[t._v("rel")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}},[t._v("=")]),e("span",{staticStyle:{color:"rgb(206,145,120)"}},[t._v('"stylesheet"')]),e("span",{staticStyle:{color:"rgb(128,128,128)"}},[t._v(">")])]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(215,186,125)"}},[t._v(".table")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}})]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(156,220,254)"}},[t._v("display")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}},[t._v(": ")]),e("span",{staticStyle:{color:"rgb(206,145,120)"}},[t._v("table")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}},[t._v(";")])]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(156,220,254)"}},[t._v("margin")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}},[t._v(": ")]),e("span",{staticStyle:{color:"rgb(181,206,168)"}},[t._v("5px")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}},[t._v(";")])]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(156,220,254)"}},[t._v("width")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}},[t._v(": ")]),e("span",{staticStyle:{color:"rgb(181,206,168)"}},[t._v("500px")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}},[t._v(";")])]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(156,220,254)"}},[t._v("height")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}},[t._v(": ")]),e("span",{staticStyle:{color:"rgb(181,206,168)"}},[t._v("300px")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}},[t._v(";")])]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(156,220,254)"}},[t._v("background-color")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}},[t._v(": ")]),e("span",{staticStyle:{color:"rgb(206,145,120)"}},[t._v("#ccc")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}},[t._v(";")])]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}})]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}})]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(215,186,125)"}},[t._v(".cell")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}})]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(156,220,254)"}},[t._v("display")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}},[t._v(": ")]),e("span",{staticStyle:{color:"rgb(206,145,120)"}},[t._v("table-cell")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}},[t._v(";")])]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(156,220,254)"}},[t._v("padding")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}},[t._v(": ")]),e("span",{staticStyle:{color:"rgb(181,206,168)"}},[t._v("10px")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}},[t._v(";")])]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(156,220,254)"}},[t._v("vertical-align")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}},[t._v(": ")]),e("span",{staticStyle:{color:"rgb(206,145,120)"}},[t._v("middle")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}},[t._v(";")])]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(96,139,78)"}},[t._v("/*该属性是定义行内元素垂直对齐的，只有行内元素会生效。在表单元格中，这个属性会设置单元格框中的单元格内容的对齐方式。*/")])]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}})]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(128,128,128)"}},[t._v("</")]),e("span",{staticStyle:{color:"rgb(86,156,214)"}},[t._v("style")]),e("span",{staticStyle:{color:"rgb(128,128,128)"}},[t._v(">")])]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(128,128,128)"}},[t._v("<")]),e("span",{staticStyle:{color:"rgb(86,156,214)"}},[t._v("div")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}}),e("span",{staticStyle:{color:"rgb(156,220,254)"}},[t._v("class")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}},[t._v("=")]),e("span",{staticStyle:{color:"rgb(206,145,120)"}},[t._v('"table"')]),e("span",{staticStyle:{color:"rgb(128,128,128)"}},[t._v(">")])]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(128,128,128)"}},[t._v("<")]),e("span",{staticStyle:{color:"rgb(86,156,214)"}},[t._v("div")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}}),e("span",{staticStyle:{color:"rgb(156,220,254)"}},[t._v("class")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}},[t._v("=")]),e("span",{staticStyle:{color:"rgb(206,145,120)"}},[t._v('"cell"')]),e("span",{staticStyle:{color:"rgb(128,128,128)"}},[t._v(">")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}},[t._v("内容内容内容内容内容内内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容")]),e("span",{staticStyle:{color:"rgb(128,128,128)"}},[t._v("</")]),e("span",{staticStyle:{color:"rgb(86,156,214)"}},[t._v("div")]),e("span",{staticStyle:{color:"rgb(128,128,128)"}},[t._v(">")])]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(128,128,128)"}},[t._v("</")]),e("span",{staticStyle:{color:"rgb(86,156,214)"}},[t._v("div")]),e("span",{staticStyle:{color:"rgb(128,128,128)"}},[t._v(">")])]),e("p",[e("strong")]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",[e("strong",[e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("61、")]),e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("html5有哪些新特性？如何区分 HTML 和 HTML5？")])]),e("span",{staticStyle:{background:"rgb(255,255,255)"}}),e("br"),e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("HTML5 现在已经不是 SGML\n        的子集，主要是关于图像，位置，存储，多任务等功能的增加。")]),e("br"),e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("(1)绘画 canvas;")]),e("br"),e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("(2)用于媒介回放的 video 和 audio 元素;")]),e("br"),e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("(3)本地离线存储 localStorage\n        长期存储数据，浏览器关闭后数据不丢失;")]),e("br"),e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("(4)sessionStorage 的数据在浏览器关闭后自动删除;")]),e("br"),e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("(5)语意化更好的内容元素，比如\n        article、footer、header、nav、section;")]),e("br"),e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("(6)表单控件，calendar、date、time、email、url、search;")])]),e("p",[t._v("\n      区别："),e("strong",[e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("<!DOCTYPE html")]),e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v(">")])])]),e("p",[e("strong",[e("span",{staticStyle:{background:"rgb(255,255,255)"}})])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[t._v("62、"),e("span",{staticStyle:{color:"rgb(44,44,44)"}},[t._v("CSS选择符CSS选择符有哪些？")])])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(57,57,57)",background:"rgb(250,247,239)"}}),e("span",{staticStyle:{color:"rgb(57,57,57)",background:"rgb(250,247,239)"}}),e("span",{staticStyle:{color:"rgb(57,57,57)",background:"rgb(250,247,239)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}}),e("p",[e("strong",[e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("63、")]),t._v("如何消除一个数组里面重复的元素？")])]),e("table",{attrs:{border:"0",cellspacing:"2"}},[e("tbody",[e("tr",[e("td",[e("p"),e("p"),e("p"),e("p"),e("p"),e("p"),e("p"),e("p"),e("p"),e("p")]),e("td",[e("p",[t._v("// 方法一：")]),e("p",[t._v("var arr1 =[1,2,2,2,3,3,3,4,5,6],")]),e("p",[t._v("var arr2 = [];")]),e("p",[t._v("var len = arr1.length;")]),e("p",[t._v("for(var i = 0;i<len; i++){")]),e("p"),e("p"),e("p"),e("p",[t._v("}")]),e("p",[t._v("document.write(arr2); // 1,2,3,4,5,6")]),e("p")])])])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[t._v("64、"),e("span",{staticStyle:{color:"rgb(44,44,44)"}})])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("js中有六种数据类型，包括五种基本数据类型（Number,String,Boolean,Undefined,Null）,和一种复杂数据类型（Object）。")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("65、")]),t._v("ajax的优点")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("1")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("、最大的一点是页面无刷新，在页面内与服务器通信，给用户的体验非常好。")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("2")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("、使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("3")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("、可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("ajax")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("的原则是")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("“")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("按需取数据")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("”")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("，可以最大程度的减少冗余请求，和响应对服务器造成的负担。")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("66、")]),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("XMLhttprequest对象")]),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("ajax工作原理、核心思想）")])]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[e("br")]),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("Ajax的核心是JavaScript对象XmlHttpRequest。它是一种支持异步请求的技术。简而言之，XmlHttpRequest使您可以使用JavaScript向服务器提出请求并处理响应，而不阻塞用户。通过XMLHttpRequest对象，Web开发人员可以在页面加载以后进行页面的局部更新。")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("67、npm是什么？\n        ")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("NPM是随同NodeJS一起安装的包管理工具")]),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("NPM服务器下载别人编写的第三方包到本地使用")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("B")]),e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("ower用法相同")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("68、css省略号怎么写")])])]),e("p",[e("span",{staticStyle:{color:"rgb(75,75,75)"}},[t._v("单行")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(75,75,75)"}}),e("span",{staticStyle:{color:"rgb(0,0,255)"}},[t._v("overflow")]),e("span",{staticStyle:{color:"rgb(43,145,175)"}},[t._v(":hidden;")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(43,145,175)"}}),e("span",{staticStyle:{color:"rgb(0,0,255)"}},[t._v("text-overflow")]),e("span",{staticStyle:{color:"rgb(43,145,175)"}},[t._v(":ellipsis;")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(43,145,175)"}}),e("span",{staticStyle:{color:"rgb(0,0,255)"}},[t._v("white-space")]),e("span",{staticStyle:{color:"rgb(43,145,175)"}},[t._v(":nowrap")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,255)"}},[t._v("<")]),e("span",{staticStyle:{color:"rgb(0,0,255)"}},[t._v("div")]),e("span",{staticStyle:{color:"rgb(0,0,255)"}}),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("id=")]),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v('"con"')]),e("span",{staticStyle:{color:"rgb(0,0,255)"}},[t._v(">")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,255)"}}),e("span",{staticStyle:{color:"rgb(0,0,255)"}},[t._v("span")]),e("span",{staticStyle:{color:"rgb(0,0,255)"}}),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("id=")]),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v('"txt"')]),e("span",{staticStyle:{color:"rgb(0,0,255)"}},[t._v(">文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略</")]),e("span",{staticStyle:{color:"rgb(0,0,255)"}},[t._v("span>")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,255)"}}),e("span",{staticStyle:{color:"rgb(0,0,255)"}},[t._v("<")]),e("span",{staticStyle:{color:"rgb(0,0,255)"}},[t._v("span")]),e("span",{staticStyle:{color:"rgb(0,0,255)"}}),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("class=")]),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v('"t"')]),e("span",{staticStyle:{color:"rgb(0,0,255)"}},[t._v("></")]),e("span",{staticStyle:{color:"rgb(0,0,255)"}},[t._v("span>")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,255)"}},[t._v("</")]),e("span",{staticStyle:{color:"rgb(0,0,255)"}},[t._v("div>")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,255)"}},[t._v("<")]),e("span",{staticStyle:{color:"rgb(0,0,255)"}},[t._v("style>")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,255)"}},[t._v("#txt")]),e("span",{staticStyle:{color:"rgb(0,0,255)"}},[t._v("{")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,255)"}}),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v("display:")]),e("span",{staticStyle:{color:"rgb(163,21,21)"}}),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v("inline-block")]),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v(";")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(163,21,21)"}}),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v("height:")]),e("span",{staticStyle:{color:"rgb(163,21,21)"}}),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v("40px")]),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v(";")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(163,21,21)"}}),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v("width:")]),e("span",{staticStyle:{color:"rgb(163,21,21)"}}),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v("250px")]),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v(";")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(163,21,21)"}}),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v("line-height:")]),e("span",{staticStyle:{color:"rgb(163,21,21)"}}),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v("20px")]),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v(";")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(163,21,21)"}}),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v("overflow:")]),e("span",{staticStyle:{color:"rgb(163,21,21)"}}),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v("hidden")]),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v(";")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(163,21,21)"}}),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v("font-size:")]),e("span",{staticStyle:{color:"rgb(163,21,21)"}}),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v("16px")]),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v(";")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v("}")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v(".t")]),e("span",{staticStyle:{color:"rgb(43,145,175)"}},[t._v(":after")]),e("span",{staticStyle:{color:"rgb(43,145,175)"}},[t._v("{")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(43,145,175)"}}),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v("display:")]),e("span",{staticStyle:{color:"rgb(163,21,21)"}}),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v("inline")]),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v(";")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(163,21,21)"}}),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v("content:")]),e("span",{staticStyle:{color:"rgb(163,21,21)"}}),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v('"..."')]),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v(";")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(163,21,21)"}}),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v("font-size:")]),e("span",{staticStyle:{color:"rgb(163,21,21)"}}),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v("16px")]),e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v(";")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(163,21,21)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(163,21,21)"}},[t._v("}")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,255)"}},[t._v("</")]),e("span",{staticStyle:{color:"rgb(0,0,255)"}},[t._v("style>")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("69、什么是闭包")])])]),e("p",[e("span",{staticStyle:{color:"rgb(26,26,26)",background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(26,26,26)",background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v('<button type="button"\n        onclick="myFunction()">计数!</button>')])]),e("p",[e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v('<p id="demo">0</p>')])]),e("p",[e("span",{staticStyle:{color:"rgb(255,0,0)",background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("<script>")])]),e("p",[e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("var add = (function () {")])]),e("p",[e("span",{staticStyle:{background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("return function () { ")])]),e("p",[e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("return counter += 1;")])]),e("p",[e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("}")])]),e("p",[e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("})();")])]),e("p",[e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("function myFunction(){")])]),e("p",[e("span",{staticStyle:{background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("}")])]),e("p",[e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("<\/script>")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("70、less用过吗？用哪些特性")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("mixin）、")]),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("71")])]),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),e("strong",[e("span",{staticStyle:{color:"rgb(57,57,57)",background:"rgb(250,247,239)"}})])]),e("p",[e("span",{staticStyle:{color:"rgb(57,57,57)",background:"rgb(250,247,239)"}},[t._v("CSS")]),e("span",{staticStyle:{color:"rgb(57,57,57)",background:"rgb(250,247,239)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(57,57,57)",background:"rgb(250,247,239)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(57,57,57)",background:"rgb(250,247,239)"}},[t._v("72、")]),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("css的预编译。")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("使用步骤：")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("npm 下三个loader（sass-loader、css-loader、node-sass）")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("build目录找到webpack")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v(".base.config.js")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("extends属性中加一个拓展")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v(".scss")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("module属性")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("style标签加上lang属性 ，例如：lang=”scss”")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v(":")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,128,128)"}},[t._v("1")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("$变量名称=值）；")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,128,128)"}},[t._v("2")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("、可以用混合器，例如（）")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,128,128)"}},[t._v("3")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("、可以嵌套")])]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("73、SVN是什么？")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("74、怎么理解前后端分离？")])])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("前后端分离的核心：后台提供数据，前端负责显示")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("75、")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("Ajax处理跨域的方式有三种：代理、jsonp、XHR2")])])]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("76、什么是node.js？")])])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("JavaScript")]),t._v("，具有超强的高并发能力\n    ")]),e("p",[e("span",{staticStyle:{color:"rgb(102,102,102)"}},[t._v("Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程。而每个线程需要耗费大约2MB内存。也就是说，理论上，一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。")])]),e("p",[e("span",{staticStyle:{color:"rgb(102,102,102)"}},[t._v("Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("77、http协议")])])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}}),e("a",{attrs:{href:"http://www.abc.com:8080",rel:"nofollow"}},[e("u",[e("span",{staticStyle:{color:"rgb(0,0,255)",background:"rgb(255,255,255)"}},[t._v("http://www.abc.com:8080")])])])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",[e("a",{attrs:{href:"http://www.abc.com",rel:"nofollow"}},[e("u",[e("span",{staticStyle:{color:"rgb(0,0,255)",background:"rgb(255,255,255)"}},[t._v("www.abc.com")])])]),e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("78、字符串插值")])])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",[e("strong",[e("span",{staticStyle:{background:"rgb(255,255,255)"}},[t._v("79、")]),t._v("字符串常用方法")])]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[t._v("slice方法返回字符串的片段")])]),e("span",{staticStyle:{color:"rgb(34,34,34)"}},[e("br")]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[t._v('var str = "ABCDEF";')]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(34,34,34)"}},[e("br")]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[t._v("str.slice(2,4);")]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(34,34,34)"}},[e("br")]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[t._v("CD")]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[t._v("substring方法返回位于String对象中指定位置的子字符串。")])]),e("span",{staticStyle:{color:"rgb(34,34,34)"}},[e("br")]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[t._v('var str = "ABCDEF";')]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(34,34,34)"}},[e("br")]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[t._v("str.substring(2,4); // 或 str.substring(4,2);")]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(34,34,34)"}},[e("br")]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[t._v("CD")]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[t._v("Split")])]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),e("strong",[e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}})]),e("span",{staticStyle:{color:"rgb(34,34,34)"}},[e("br")]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[t._v('var str = "AA BB CC DD EE FF";')]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(34,34,34)"}},[e("br")]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[t._v('alert(str.split(" "，3));')]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(34,34,34)"}},[e("br")]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(34,34,34)"}},[e("br")]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[t._v("AA,BB,CC")]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[t._v("concat方法返回字符串值")])]),e("span",{staticStyle:{color:"rgb(34,34,34)"}},[e("br")]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[t._v('var str = "ABCDEF";')]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(34,34,34)"}},[e("br")]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[t._v('str.concat("ABCDEF","ABC");')]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(34,34,34)"}},[e("br")]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[t._v("ABCDEFABCDEFABC")]),e("strong")]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[t._v("indexOf方法放回String对象内第一次出现子字符串位置")])]),e("span",{staticStyle:{color:"rgb(34,34,34)"}},[e("br")]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[t._v('var str = "ABCDECDF";')]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(34,34,34)"}},[e("br")]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[t._v('str.indexOf("CD"，1); // 由1位置从左向右查找 123...')]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(34,34,34)"}},[e("br")]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[t._v("2")]),e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(34,34,34)",background:"rgb(255,255,255)"}},[t._v("80、")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v(" (BOM)")])])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("BOM 的方法和属性")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v(" window 对象的属性。")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v(" window 对象的方法。")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("Window 子对象")])])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("document 对象")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("frames 对象")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("history 对象")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("location 对象")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("navigator 对象")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("screen 对象")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}},[t._v("81、DOM")]),e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}}),e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}},[t._v("HTML 文档对象模型")])]),e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}},[t._v("\n        DOM，可以访问所有的 HTML 元素，连同它们所包含的文本和属性")])]),e("p",[e("span",{staticStyle:{color:"rgb(102,102,102)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[t._v("82、js 定时器有以下两个方法：")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("setInterval()\n        ：按照指定的周期（以毫秒计）来调用函数或计算表达式。方法会不停地调用函数，直到\n        clearInterval() 被调用或窗口被关闭。")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("setTimeout() ：在指定的毫秒数后调用函数或计算表达式。")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(51,51,51)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("83、MVVM和MVC的区别")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("MVVM中的View 和 ViewModel可以互相通信。也就是可以互相调用。")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[e("br")]),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("MVC中的是单向通信。也就是View跟Model，必须通过Controller来承上启下")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("84、服务端渲染，英文缩写")]),e("span",{staticStyle:{color:"rgb(85,85,85)",background:"rgb(255,255,255)"}},[t._v("SSR")])])]),e("p",[e("span",{staticStyle:{color:"rgb(85,85,85)",background:"rgb(255,255,255)"}},[t._v("Vue.js原来是开发SPA（单页应用）的，但是随着技术的普及，很多人想用Vue开发多页应用，并在服务端完成渲染。可以用Nuxt.js实现，她简化了SSR的开发难度。还可以直接用命令把我们制作的vue项目生成为静态html。")])]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(85,85,85)",background:"rgb(255,255,255)"}})])]),e("p",[e("span",{staticStyle:{color:"rgb(85,85,85)",background:"rgb(255,255,255)"}},[t._v("SPA（单页应用）不利于搜索引擎的SEO操作。比如你作一个新闻网站，流量的一个主要来源是通过百度、谷歌、bing这些搜索引擎，但是它们对SPA的抓取并不好，特别是百度根本没法抓取到SPA的内容页面，所以我们必须把我们的应用在服务端渲染成适合搜索引擎抓取的页面，再下载到客户端。那Nuxt.js适合作新闻、博客、电影、咨询这样的需要搜索引擎提供流量的项目。")])]),e("p",[e("span",{staticStyle:{color:"rgb(85,85,85)",background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(85,85,85)",background:"rgb(255,255,255)"}},[t._v("85、")]),e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})])]),e("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[t._v("\n      webapp就一个HTML文件，里面的各个功能页面是JavaScript通过hash或者history\n      api来进行路由，并通过ajax 拉取数据实现响应功能。\n    ")]),e("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[e("strong",[t._v("优点")]),t._v("：\n    ")]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("分离前后端关注点，前端负责界面显示，后端负责数据存储和计算，各司其职，不会把前后端的逻辑混杂在一起；")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("减轻服务器压力，服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍；")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("Web界面、手机、平板等多种客户端；")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[e("strong",[t._v("缺点")]),t._v("：\n    ")]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("SEO问题，现在可以通过Prerender等技术解决一部分；")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("前进、后退、地址栏等，需要程序进行管理；")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("书签，需要程序来提供支持；")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("86 、ES6定义类和继承")])])]),e("p",{staticStyle:{background:"rgb(246,246,246)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(26,26,26)"}},[t._v("class")])]),e("span",{staticStyle:{color:"rgb(26,26,26)"}}),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("//")]),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("定义类")])]),e("p",{staticStyle:{background:"rgb(246,246,246)"}},[e("span",{staticStyle:{color:"rgb(26,26,26)"}}),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("//")]),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("构造函数")])]),e("p",{staticStyle:{background:"rgb(246,246,246)"}},[e("span",{staticStyle:{color:"rgb(26,26,26)"}}),e("strong",[e("span",{staticStyle:{color:"rgb(26,26,26)"}},[t._v("this")])]),e("span",{staticStyle:{color:"rgb(26,26,26)"}},[t._v(".name ")]),e("strong",[e("span",{staticStyle:{color:"rgb(26,26,26)"}},[t._v("=")])]),e("span",{staticStyle:{color:"rgb(26,26,26)"}})]),e("p",{staticStyle:{background:"rgb(246,246,246)"}},[e("span",{staticStyle:{color:"rgb(26,26,26)"}})]),e("p",{staticStyle:{background:"rgb(246,246,246)"}},[e("span",{staticStyle:{color:"rgb(26,26,26)"}})]),e("p",{staticStyle:{background:"rgb(246,246,246)"}},[e("span",{staticStyle:{color:"rgb(26,26,26)"}})]),e("p",{staticStyle:{background:"rgb(246,246,246)"}},[e("span",{staticStyle:{color:"rgb(26,26,26)"}}),e("strong",[e("span",{staticStyle:{color:"rgb(26,26,26)"}},[t._v("return")])]),e("span",{staticStyle:{color:"rgb(26,26,26)"}}),e("strong",[e("span",{staticStyle:{color:"rgb(26,26,26)"}},[t._v("this")])]),e("span",{staticStyle:{color:"rgb(26,26,26)"}},[t._v(".name;")])]),e("p",{staticStyle:{background:"rgb(246,246,246)"}},[e("span",{staticStyle:{color:"rgb(26,26,26)"}})]),e("p",{staticStyle:{background:"rgb(246,246,246)"}},[e("span",{staticStyle:{color:"rgb(26,26,26)"}},[t._v("}")])]),e("p",{staticStyle:{background:"rgb(246,246,246)"}},[e("span",{staticStyle:{color:"rgb(26,26,26)"}})]),e("p",{staticStyle:{background:"rgb(246,246,246)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(26,26,26)"}},[t._v("class")])]),e("span",{staticStyle:{color:"rgb(26,26,26)"}}),e("strong",[e("span",{staticStyle:{color:"rgb(26,26,26)"}},[t._v("extends")])]),e("span",{staticStyle:{color:"rgb(26,26,26)"}}),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("//")]),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("继承")])]),e("p",{staticStyle:{background:"rgb(246,246,246)"}},[e("span",{staticStyle:{color:"rgb(26,26,26)"}})]),e("p",{staticStyle:{background:"rgb(246,246,246)"}},[e("span",{staticStyle:{color:"rgb(26,26,26)"}}),e("strong",[e("span",{staticStyle:{color:"rgb(26,26,26)"}},[t._v("this")])]),e("span",{staticStyle:{color:"rgb(26,26,26)"}},[t._v(".grade ")]),e("strong",[e("span",{staticStyle:{color:"rgb(26,26,26)"}},[t._v("=")])]),e("span",{staticStyle:{color:"rgb(26,26,26)"}}),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("// ReferenceError")]),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("：如果没有")]),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("super")]),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("直接调用")]),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("this. Grade,")]),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("会报错")])]),e("p",{staticStyle:{background:"rgb(246,246,246)"}},[e("span",{staticStyle:{color:"rgb(26,26,26)"}}),e("strong",[e("span",{staticStyle:{color:"rgb(26,26,26)"}},[t._v("super")])]),e("span",{staticStyle:{color:"rgb(26,26,26)"}}),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("//")]),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("子类必须在")]),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("constructor")]),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("方法中调用")]),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("super")]),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("，否则新建实例会报错，因为子类没有自己的")]),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("this")]),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("对象")])]),e("p",{staticStyle:{background:"rgb(246,246,246)"}},[e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("super ")]),e("span",{staticStyle:{color:"rgb(255,0,0)"}},[t._v("作为函数调用时代表父类的构造函数")])]),e("p",{staticStyle:{background:"rgb(246,246,246)"}},[e("span",{staticStyle:{color:"rgb(26,26,26)"}}),e("strong",[e("span",{staticStyle:{color:"rgb(26,26,26)"}},[t._v("this")])]),e("span",{staticStyle:{color:"rgb(26,26,26)"}},[t._v(".grade ")]),e("strong",[e("span",{staticStyle:{color:"rgb(26,26,26)"}},[t._v("=")])]),e("span",{staticStyle:{color:"rgb(26,26,26)"}})]),e("p",{staticStyle:{background:"rgb(246,246,246)"}},[e("span",{staticStyle:{color:"rgb(26,26,26)"}})]),e("p",{staticStyle:{background:"rgb(246,246,246)"}},[e("span",{staticStyle:{color:"rgb(26,26,26)"}})]),e("p",{staticStyle:{background:"rgb(246,246,246)"}},[e("span",{staticStyle:{color:"rgb(26,26,26)"}}),e("strong",[e("span",{staticStyle:{color:"rgb(26,26,26)"}},[t._v("return")])]),e("span",{staticStyle:{color:"rgb(26,26,26)"}}),e("strong",[e("span",{staticStyle:{color:"rgb(26,26,26)"}},[t._v("this")])]),e("span",{staticStyle:{color:"rgb(26,26,26)"}},[t._v(".grade;")])]),e("p",{staticStyle:{background:"rgb(246,246,246)"}},[e("span",{staticStyle:{color:"rgb(26,26,26)"}})]),e("p",{staticStyle:{background:"rgb(246,246,246)"}},[e("span",{staticStyle:{color:"rgb(26,26,26)"}},[t._v("}")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(26,26,26)"}},[t._v("Student(“Bill” , 5)")])]),e("p",[e("span",{staticStyle:{color:"rgb(26,26,26)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(26,26,26)"}},[t._v("87、样式权重")])])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v(": style=””，权值为1000。")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("ID选择器，如：#content，权值为100。")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v(".content，权值为10。")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("div p，权值为1。")])]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}},[t._v("<")]),e("span",{staticStyle:{color:"rgb(86,156,214)"}},[t._v("style")]),e("span",{staticStyle:{color:"rgb(128,128,128)"}},[t._v(">")])]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(215,186,125)"}},[t._v("#aaa")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}})]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(156,220,254)"}},[t._v("color")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}},[t._v(": ")]),e("span",{staticStyle:{color:"rgb(206,145,120)"}},[t._v("red")])]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}})]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(215,186,125)"}},[t._v(".bbb")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}})]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(156,220,254)"}},[t._v("color")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}},[t._v(": ")]),e("span",{staticStyle:{color:"rgb(206,145,120)"}},[t._v("blue")])]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}})]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(215,186,125)"}},[t._v("div p")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}})]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(156,220,254)"}},[t._v("color")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}},[t._v(": #")]),e("span",{staticStyle:{color:"rgb(206,145,120)"}},[t._v("pink")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}},[t._v(";")])]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}})]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(128,128,128)"}},[t._v("</")]),e("span",{staticStyle:{color:"rgb(86,156,214)"}},[t._v("style")]),e("span",{staticStyle:{color:"rgb(128,128,128)"}},[t._v(">")])]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}},[t._v("</")]),e("span",{staticStyle:{color:"rgb(86,156,214)"}},[t._v("head")]),e("span",{staticStyle:{color:"rgb(128,128,128)"}},[t._v(">")])]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}},[t._v("<")]),e("span",{staticStyle:{color:"rgb(86,156,214)"}},[t._v("body")]),e("span",{staticStyle:{color:"rgb(128,128,128)"}},[t._v(">")])]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(128,128,128)"}},[t._v("<")]),e("span",{staticStyle:{color:"rgb(86,156,214)"}},[t._v("div")]),e("span",{staticStyle:{color:"rgb(128,128,128)"}},[t._v(">")])]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(128,128,128)"}},[t._v("<")]),e("span",{staticStyle:{color:"rgb(86,156,214)"}},[t._v("p")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}}),e("span",{staticStyle:{color:"rgb(156,220,254)"}},[t._v("id")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}},[t._v("=")]),e("span",{staticStyle:{color:"rgb(206,145,120)"}},[t._v('"aaa"')]),e("span",{staticStyle:{color:"rgb(212,212,212)"}}),e("span",{staticStyle:{color:"rgb(156,220,254)"}},[t._v("class")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}},[t._v("=")]),e("span",{staticStyle:{color:"rgb(206,145,120)"}},[t._v('"bbb"')]),e("span",{staticStyle:{color:"rgb(212,212,212)"}}),e("span",{staticStyle:{color:"rgb(156,220,254)"}},[t._v("style")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}},[t._v("=")]),e("span",{staticStyle:{color:"rgb(206,145,120)"}},[t._v('"color:green"')]),e("span",{staticStyle:{color:"rgb(128,128,128)"}},[t._v(">")]),e("span",{staticStyle:{color:"rgb(212,212,212)"}},[t._v("我的大学生活")]),e("span",{staticStyle:{color:"rgb(128,128,128)"}},[t._v("</")]),e("span",{staticStyle:{color:"rgb(86,156,214)"}},[t._v("p")]),e("span",{staticStyle:{color:"rgb(128,128,128)"}},[t._v(">")])]),e("p",{staticStyle:{background:"rgb(30,30,30)"}},[e("span",{staticStyle:{color:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(128,128,128)"}},[t._v("</")]),e("span",{staticStyle:{color:"rgb(86,156,214)"}},[t._v("div")]),e("span",{staticStyle:{color:"rgb(128,128,128)"}},[t._v(">")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("3个规则,：")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("1，如果样式上加有!important标记，例如：")])]),e("table",{attrs:{border:"0",cellspacing:"0"}},[e("tbody",[e("tr",[e("td",[e("p")]),e("td",[e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}})])])])])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("那么始终采用这个标记的样式。")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("2，匹配的内容按照CSS权重排序，权重大的优先；")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("3，如果权重也一样，按照它在CSS样式表里声明的顺序，后声明的优先，例如：")])]),e("table",{attrs:{border:"0",cellspacing:"0"}},[e("tbody",[e("tr",[e("td",[e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}})])]),e("td",[e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)"}})])])])])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("color: red。")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("88、undefined和null区别")])])]),e("p",{staticStyle:{background:"rgb(245,245,213)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(17,17,17)"}},[t._v('null表示"没有对象"，即该处不应该有值。')])]),e("span",{staticStyle:{color:"rgb(17,17,17)"}},[t._v("典型用法是：")])]),e("p",{staticStyle:{background:"rgb(245,242,240)"}},[e("span",{staticStyle:{color:"rgb(17,17,17)"}},[t._v("1） 作为函数的参数，表示该函数的参数不是对象。")])]),e("p",{staticStyle:{background:"rgb(245,245,213)"}},[e("strong",[e("span",{staticStyle:{color:"rgb(17,17,17)"}},[t._v('undefined表示"缺少值"，就是此处应该有一个值，但是还没有定义。')])]),e("span",{staticStyle:{color:"rgb(17,17,17)"}},[t._v("典型用法是：")])]),e("p",{staticStyle:{background:"rgb(245,242,240)"}},[e("span",{staticStyle:{color:"rgb(17,17,17)"}},[t._v("1）变量被声明了，但没有赋值时，就等于undefined。")])]),e("p",{staticStyle:{background:"rgb(245,242,240)"}},[e("span",{staticStyle:{color:"rgb(17,17,17)"}},[t._v("2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。")])]),e("p",{staticStyle:{background:"rgb(245,242,240)"}},[e("span",{staticStyle:{color:"rgb(17,17,17)"}},[t._v("3）对象没有赋值的属性，该属性的值为undefined。")])]),e("p",{staticStyle:{background:"rgb(245,242,240)"}},[e("span",{staticStyle:{color:"rgb(17,17,17)"}},[t._v("4）函数没有返回值时，默认返回undefined。")])]),e("p",{staticStyle:{background:"rgb(245,242,240)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",{staticStyle:{background:"rgb(245,242,240)"}},[e("span",{staticStyle:{color:"rgb(0,119,170)"}},[t._v("var")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(153,153,153)"}},[t._v(";")])]),e("p",{staticStyle:{background:"rgb(245,242,240)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("i")]),e("span",{staticStyle:{color:"rgb(112,128,144)"}})]),e("p",{staticStyle:{background:"rgb(245,242,240)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",{staticStyle:{background:"rgb(245,242,240)"}},[e("span",{staticStyle:{color:"rgb(0,119,170)"}},[t._v("function")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(17,17,17)"}},[t._v("f")]),e("span",{staticStyle:{color:"rgb(153,153,153)"}},[t._v("(")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("x")]),e("span",{staticStyle:{color:"rgb(153,153,153)"}},[t._v("){")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("console")]),e("span",{staticStyle:{color:"rgb(153,153,153)"}},[t._v(".")]),e("span",{staticStyle:{color:"rgb(17,17,17)"}},[t._v("log")]),e("span",{staticStyle:{color:"rgb(153,153,153)"}},[t._v("(")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("x")]),e("span",{staticStyle:{color:"rgb(153,153,153)"}},[t._v(")}")])]),e("p",{staticStyle:{background:"rgb(245,242,240)"}},[e("span",{staticStyle:{color:"rgb(17,17,17)"}},[t._v("f")]),e("span",{staticStyle:{color:"rgb(153,153,153)"}},[t._v("()")]),e("span",{staticStyle:{color:"rgb(112,128,144)"}})]),e("p",{staticStyle:{background:"rgb(245,242,240)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",{staticStyle:{background:"rgb(245,242,240)"}},[e("span",{staticStyle:{color:"rgb(0,119,170)"}},[t._v("var")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(166,127,89)"}},[t._v("=")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(0,119,170)"}},[t._v("new")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(17,17,17)"}},[t._v("Object")]),e("span",{staticStyle:{color:"rgb(153,153,153)"}},[t._v("();")])]),e("p",{staticStyle:{background:"rgb(245,242,240)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("o")]),e("span",{staticStyle:{color:"rgb(153,153,153)"}},[t._v(".")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("p")]),e("span",{staticStyle:{color:"rgb(112,128,144)"}})]),e("p",{staticStyle:{background:"rgb(245,242,240)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",{staticStyle:{background:"rgb(245,242,240)"}},[e("span",{staticStyle:{color:"rgb(0,119,170)"}},[t._v("var")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(166,127,89)"}},[t._v("=")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}}),e("span",{staticStyle:{color:"rgb(17,17,17)"}},[t._v("f")]),e("span",{staticStyle:{color:"rgb(153,153,153)"}},[t._v("();")])]),e("p",{staticStyle:{background:"rgb(245,242,240)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("x")]),e("span",{staticStyle:{color:"rgb(112,128,144)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("89、")]),e("span",{staticStyle:{background:"rgb(204,255,255)"}},[t._v("HTML")])]),e("span",{staticStyle:{background:"rgb(204,255,255)"}},[t._v("HTML元素标记的内容。")])]),e("p",[e("strong",[t._v("<header></header>")]),e("span",{staticStyle:{background:"rgb(204,255,255)"}})]),e("p",[e("strong",[t._v("<nav></nav>")]),e("span",{staticStyle:{background:"rgb(204,255,255)"}})]),e("p",[e("strong",[t._v("<section></section>")]),e("span",{staticStyle:{background:"rgb(204,255,255)"}})]),e("p",[e("strong",[t._v("<footer></footer>")]),e("span",{staticStyle:{background:"rgb(204,255,255)"}},[t._v("body时，才是整个页面的页脚。")])]),e("h4",{staticStyle:{background:"rgb(255,255,255)"}},[e("strong",[e("span",{staticStyle:{background:"rgb(204,255,255)"}},[t._v("90、")])]),e("a",{attrs:{href:"http://www.cnblogs.com/sunhe/p/4994058.html",rel:"nofollow"}},[e("u",[e("span",{staticStyle:{color:"rgb(33,117,155)"}},[t._v("Doctype作用，标准模式与兼容模式的区别")])])])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("<!DOCTYPE>声明位于位于HTML文档中的第一行，处于 <html>\n        标签之前。告知浏览器的解析器用什么文档标准解析这个文档。")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("标")]),e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("\n        JS运作模式都是以该浏览器支持的最高标准运行。")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"}},[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v(",模拟老式浏览器的行为以防止站点无法工作。")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",{attrs:{align:"justify"}},[e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)"}},[t._v("91、各种浏览器内核")])])]),e("p",{attrs:{align:"justify"}},[e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("Trident")])]),e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("Internet\n        Explorer，又称其为IE内核。（IE、傲游、世界之窗浏览器、腾讯TT）")])]),e("p",{attrs:{align:"justify"}},[e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("Gecko")])]),e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("Firefox")])]),e("p",{attrs:{align:"justify"}},[e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("WebKit")])]),e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("Safari、Chrome")])]),e("p",{attrs:{align:"justify"}},[e("strong",[e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("Presto")])]),e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}},[t._v("OperaPresto")])]),e("p",[e("span",{staticStyle:{color:"rgb(51,51,51)",background:"rgb(255,255,255)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}},[t._v("92")]),e("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}})])]),e("p",[e("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}},[e("br")]),e("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}}),e("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}},[e("br")]),e("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}},[t._v("a. ")]),e("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}},[t._v("b. ")]),e("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}},[t._v("c. ")]),e("span",{staticStyle:{color:"rgb(68,68,68)",background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)"}})]),e("p",[e("strong",[t._v("93、attr()和prop()的区别")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}})]),e("p",[e("strong",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("94、")]),e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}},[t._v("data-*")]),e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}})])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("H")]),e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(255,255,255)"}},[t._v("tml5的自定义属性，")]),e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}})]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}},[t._v("\n        JavaScript 中利用，以创建更好的用户体验")])]),e("p",[e("span",{staticStyle:{color:"rgb(0,0,0)",background:"rgb(253,252,248)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[e("strong",[e("span",{staticStyle:{color:"rgb(88,88,88)",background:"rgb(253,252,248)"}},[t._v("95、")]),e("span",{staticStyle:{color:"rgb(51,51,51)"}},[t._v("Quirks(怪癖）模式是什么？它和Standards（标准）模式有什么区别")])]),e("span",{staticStyle:{color:"rgb(88,88,88)"}},[t._v("区别：")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[e("span",{staticStyle:{color:"rgb(88,88,88)"}},[t._v("总体会有布局、样式解析和脚本执行三个方面的区别。")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[e("span",{staticStyle:{color:"rgb(88,88,88)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[e("span",{staticStyle:{color:"rgb(88,88,88)"}})]),e("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[e("span",{staticStyle:{color:"rgb(88,88,88)"}},[t._v("Standards模式下，给<span>等行内元素设置wdith和height都不会生效，而在quirks模式下，则会生效。")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[e("span",{staticStyle:{color:"rgb(88,88,88)"}},[t._v("standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的")])]),e("p",{staticStyle:{background:"rgb(255,255,255)"},attrs:{align:"justify"}},[e("span",{staticStyle:{color:"rgb(88,88,88)"}})])])])}],os={},ls=os,is=Object(v["a"])(ls,rs,ss,!1,null,"75347789",null),cs=is.exports,ps=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},bs=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("h2",[t._v("【Vue】双向数据绑定原理")]),e("h3",[t._v("单向绑定与双向绑定")]),e("ul",[e("li",[t._v("单向绑定非常简单，就是把Model绑定到View，当我们用JavaScript代码更新Model时，View就会自动更新。")]),e("li",[t._v("如果用户更新了View，Model的数据也自动被更新了，这种情况就是双向绑定")])]),e("h3",[t._v("几种实现双向绑定的做法")]),e("ul",[e("li",[e("p",[t._v("发布者-订阅者模式（backbone.js）")])]),e("li",[e("p",[t._v("脏值检查（angular.js）")]),e("ul",[e("li",[e("p",[t._v("通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下")]),e("ul",[e("li",[t._v("DOM事件，譬如用户输入文本，点击按钮等。( ng-click )")]),e("li",[t._v("XHR响应事件 ( $http )")]),e("li",[t._v("浏览器Location变更事件 ( $location )")]),e("li",[t._v("Timer事件( $timeout , $interval )")]),e("li",[t._v("执行 $digest() 或 $apply()")])])])])]),e("li",[e("p",[t._v("数据劫持（vue.js）")]),e("ul",[e("li",[t._v("vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。")])])])]),e("h3",[t._v("Vue双向数据绑定实现思路")]),e("ul",[e("li",[e("p",[t._v("1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者 ")])]),e("li",[e("p",[t._v("2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 ")])]),e("li",[e("p",[t._v("3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图 ")])]),e("li",[e("p",[t._v("4、mvvm入口函数，整合以上三者")])]),e("li",[e("p",[t._v("另一种解释")]),e("ul",[e("li",[t._v("首先，需要利用Object.defineProperty，将要观察的对象，转化成getter/setter，以便拦截对象赋值与取值操作，称之为Observer；")]),e("li",[t._v("需要将DOM解析，提取其中的指令与占位符，并赋与不同的操作，称之为Compiler；")]),e("li",[t._v("需要将Compile的解析结果，与Observer所观察的对象连接起来，建立关系，在Observer观察到对象数据变化时，接收通知，同时更新DOM，称之为Watcher；")]),e("li",[t._v("最后，需要一个公共入口对象，接收配置，协调上述三者，称为Vue;")])])]),e("li",[e("p",[t._v("条件")]),e("ul",[e("li",[t._v("把一个普通对象传给 Vue 实例作为它的 data 选项，Vue.js 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。这是 ES5 特性，不能打补丁实现，这便是为什么 Vue.js 不支持 IE8 及更低版本。")])])])]),e("h3",[t._v("具体实现")]),e("ul",[e("li",[e("p",[t._v("（1）实现Observer")]),e("p",[t._v("利用Obeject.defineProperty()来监听属性变动 那么将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上\tsetter和getter 这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。")]),e("ul",[e("li",[t._v("（1）将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter，这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。")]),e("li",[t._v("（2）监听到变化之后就是怎么通知订阅者了，所以接下来我们需要实现一个消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发notify，再调用订阅者的update方法，")]),e("li",[t._v("（3）那么问题来了，谁是订阅者？怎么往订阅器添加订阅者？ 没错，上面的思路整理中我们已经明确订阅者应该是Watcher, 而且var dep = new Dep();是在 defineReactive方法内部定义的，所以想通过dep添加订阅者，就必须要在闭包内操作，所以我们可以在getter里面动手脚")])])]),e("li",[e("p",[t._v("（2）实现Compile")]),e("p",[t._v("compile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图，")]),e("p",[t._v(" ")]),e("ul",[e("li",[e("p",[t._v("思路")]),e("ul",[e("li",[t._v("compile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图，")])])]),e("li",[e("p",[t._v("（1）因为遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将跟节点el转换成文档碎片fragment进行解析编译操作，解析完成，再将fragment添加回原来的真实dom节点中")])]),e("li",[e("p",[t._v("（2）compileElement方法将遍历所有节点及其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定")])]),e("li",[e("p",[t._v('这里通过递归遍历保证了每个节点及子节点都会解析编译到，包括了{{}}表达式声明的文本节点。指令的声明规定是通过特定前缀的节点属性来标记，如<span v-text="content" other-attr中v-text便是指令，而other-attr不是指令，只是普通的属性。 监听数据、绑定更新函数的处理是在compileUtil.bind()这个方法中，通过new Watcher()添加回调来接收数据变化的通知')])])])]),e("li",[e("p",[t._v("（3）实现Watcher")]),e("ul",[e("li",[e("p",[t._v("Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是")]),e("ul",[e("li",[t._v("1、在自身实例化时往属性订阅器(dep)里面添加自己 ")]),e("li",[t._v("2、自身必须有一个update()方法 ")]),e("li",[t._v("3、待属性变动dep.notify()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。 ")])])]),e("li",[e("p",[t._v("实例化Watcher的时候，调用get()方法，通过Dep.target = watcherInstance标记订阅者是当前watcher实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep添加当前watcher实例，从而在属性值有变化的时候，watcherInstance就能收到更新通知。")])])])]),e("li",[e("p",[t._v("（4）实现MVVM")]),e("ul",[e("li",[t._v("MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。")]),e("li",[t._v("一个简单的MVVM构造器是这样子")])])])]),e("h3",[t._v("用Object.defineProperty()简易实现一个双向绑定")])])}],us={},vs=us,gs=Object(v["a"])(vs,ps,bs,!1,null,"3e4811d1",null),ms=gs.exports,_s=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},ds=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("h2",[t._v("【Vue监听缺陷】Vue数组下标以及增删对象属性无法响应式")]),e("h3",[t._v("对于数组的监听")]),e("ul",[e("li",[e("p",[t._v("首先，Vue.js是基于Object.defineProperty对对象实现“响应式化”，而对于数组，Vue.js提供的方法是重写push、pop、shift、unshift、splice、sort、reverse这七个数组方法。")]),e("ul",[e("li",[t._v("直接重写数组")]),e("li",[t._v("def的作用就是重新定义对象属性的value值")]),e("li",[t._v("理解版，即在使用原生数组方法结果之后，发布改变与观察新增的元素，再返回值")]),e("li",[t._v("理解版中的dosomething在源码中的代码")])])]),e("li",[e("p",[t._v("Vue 不能检测以下变动的数组")]),e("ul",[e("li",[e("p",[t._v("（1）当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue，")])]),e("li",[e("p",[t._v("（2）当你修改数组的长度时，例如：vm.items.length = newLength")])]),e("li",[e("p",[t._v("解释")]),e("ul",[e("li",[t._v("Vue不能检测到对象的添加或者删除。然而Vue在初始化实例时就对属性执行了setter/getter转化过程，所以属性必须开始就在对象上，这样才能让Vue转化它。 ")]),e("li",[t._v("数组中index都可以看做是属性，当我们添加属性并赋值时，Vue并不能检测到对象中属性的添加或者删除，但是其的确是添加或删除了，故我们可以通过console看到变化，所以就没有办法做到响应式；")])])])])]),e("li",[e("p",[t._v("解决")]),e("ul",[e("li",[t._v("数组索引设置")]),e("li",[t._v("修改数组长度")])])])]),e("h3",[t._v("Vue 不能检测对象属性的添加或删除")]),e("ul",[e("li",[e("p",[t._v("现象")]),e("ul",[e("li",[t._v("对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。")])])]),e("li",[e("p",[t._v("解决")]),e("ul",[e("li",[e("p",[t._v("为已有对象赋予单个新属性")]),e("ul",[e("li",[t._v("可以使用 Vue.set(object, key, value) 方法向嵌套对象添加响应式属性。")])])]),e("li",[e("p",[t._v("为已有对象赋予多个新属性")]),e("ul",[e("li",[t._v("用两个对象的属性创建一个新的对象")])])])])])]),e("h3",[t._v("Vue.set()原理")]),e("ul",[e("li",[e("p",[t._v("作用")]),e("ul",[e("li",[t._v("Vue.set()向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 (比如 this.myObject.newProperty = 'hi')")])])]),e("li",[e("p",[t._v("实现原理")]),e("ul",[e("li",[e("p",[t._v("Vue.set()和this.$set()这两个api的实现原理基本一模一样，都是使用了set函数。set函数是从 ../observer/index 文件中导出的，区别在于Vue.set()是将set函数绑定在Vue构造函数上，this.$set()是将set函数绑定在Vue原型上。")])]),e("li",[e("p",[t._v("关键代码分析")]),e("ul",[e("li",[e("p",[t._v("数组的实现原理")]),e("ul",[e("li",[e("p",[t._v("Vue中的数组与普通的JS数组")]),e("ul",[e("li",[e("p",[t._v("Vue")])]),e("li",[e("p",[t._v("普通")])]),e("li",[e("p",[t._v("区别")]),e("ul",[e("li",[t._v("普通JS中数组的原型是指向Array.prototype，也就是说 arrJs."),e("strong",[t._v("proto")]),t._v(" == Array.prototype。")]),e("li",[t._v("Vue中数组的原型指向的一个对象，这个对象上面只有7个push、pop等方法，并且这个对象上的原型才是指向的Array.prototype。所以我们在vue中调用数组的push、pop等方法时其实不是直接调用的数组原型给我们提供的push、pop等方法，而是调用的arrayMethods给我们提供的push、pop等方法。这里你可以理解成vue在arrayMethods对象中做过了特殊处理，如果你调用了arrayMethods提供的push、pop等7个方法，那么它会触发当前收集的依赖（这里收集的依赖可以暂时理解成渲染函数），导致页面重新渲染。")])])])])]),e("li",[e("p",[t._v("实现原理")]),e("ul",[e("li",[t._v("其实Vue.set()对于数组的处理其实就是调用了splice方法……我倒")])])])])]),e("li",[e("p",[t._v("对象的实现原理")]),e("ul",[e("li",[t._v("defineReactive(ob.value, key, val)的意思是给新加的属性添加依赖，以后再直接修改这个新的属性的时候就会触发页面渲染。")]),e("li",[t._v("ob.dep.notify()这句代码的意思是触发当前的依赖（这里的依赖依然可以理解成渲染函数），所以页面就会进行重新渲染。")])])])])])])])])])}],hs={},fs=hs,ys=Object(v["a"])(fs,_s,ds,!1,null,"38146920",null),Ss=ys.exports,ws=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},ks=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("h2",[t._v("【Vue】对于Virtual Dom的理解")]),e("h3",[t._v("虚拟DOM与真实DOM的区别")]),e("ul",[e("li",[e("p",[t._v("1.虚拟DOM不会进行排版与重绘操作")])]),e("li",[e("p",[t._v("2.虚拟DOM进行频繁修改，然后一次性比较并修改真实DOM中需要改的部分（注意！），最后并在真实DOM中进行排版与重绘，减少过多DOM节点排版与重绘损耗")])]),e("li",[e("p",[t._v("3.真实DOM频繁排版与重绘的效率是相当低的")])]),e("li",[e("p",[t._v("4.虚拟DOM有效降低大面积（真实DOM节点）的重绘与排版，因为最终与真实DOM比较差异，可以只渲染局部（同2）")])]),e("li",[e("p",[t._v("损耗计算")]),e("ul",[e("li",[e("p",[t._v("使用虚拟DOM的损耗计算：")]),e("ul",[e("li",[t._v("总损耗 = 虚拟DOM增删改 + （与Diff算法效率有关）真实DOM差异增删改 + （较少的节点）排版与重绘")])])]),e("li",[e("p",[t._v("直接使用真实DOM的损耗计算：")]),e("ul",[e("li",[t._v("总损耗 = 真实DOM完全增删改 + （可能较多的节点）排版与重绘")])])])])]),e("li",[e("p",[t._v("总之，一切为了减弱频繁的大面积重绘引发的性能问题，不同框架不一定需要虚拟DOM，关键看框架是否频繁会引发大面积的DOM操作")])])]),e("h3",[t._v("Virtual DOM算法")]),e("ul",[e("li",[e("p",[t._v("初步了解")]),e("ul",[e("li",[e("p",[t._v("（1）真实DOM是很慢的")]),e("ul",[e("li",[t._v("如果我们把一个简单的div元素的属性都打印出来，你会看到：")]),e("li",[t._v("而这仅仅是第一层。真正的 DOM 元素非常庞大，这是因为标准就是这么设计的。而且操作它们的时候你要小心翼翼，轻微的触碰可能就会导致页面重排，这可是杀死性能的罪魁祸首。")])])]),e("li",[e("p",[t._v("（2）相对于 DOM 对象，原生的 JavaScript 对象处理起来更快，而且更简单。DOM 树上的结构、属性信息我们都可以很容易地用 JavaScript 对象表示出来：")])])])]),e("li",[e("p",[t._v("Virtual DOM 算法几个步骤")]),e("ul",[e("li",[e("p",[t._v("（1）用 JavaScript 对象结构表示 DOM 树的结构；然后用这个对象树构建一个真正的 DOM 树，插到文档当中")])]),e("li",[e("p",[t._v("（2）当状态变更的时候，重新构造一棵新的对象树。然后用新的对象树和旧的对象树进行比较，记录两棵对象树差异")])]),e("li",[e("p",[t._v("（3）把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了")])]),e("li",[e("p",[t._v("总结理解")]),e("ul",[e("li",[t._v("Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。")])])])])])]),e("h3",[t._v("【diff算法】Virtual Dom以及Diff算法")]),e("ul",[e("li",[e("p",[t._v("（1）创建真实Dom的代价很大")]),e("ul",[e("li",[t._v("使用document.CreateElement 和 document.CreateTextNode创建的就是真实节点。")]),e("li",[t._v("我们可以做个试验。打印出一个空元素的第一层属性，可以看到标准让元素实现的东西太多了。如果每次都重新生成新的元素，对性能是巨大的浪费。")])])]),e("li",[e("p",[t._v("（2）Virtual Dom的解决思路")]),e("ul",[e("li",[e("p",[t._v("通俗易懂的来说就是用一个简单的对象去代替复杂的dom对象。")])]),e("li",[e("p",[t._v("举例")]),e("ul",[e("li",[t._v("我们在body里插入一个class为a的div。")]),e("li",[t._v("对于这个div我们可以用一个简单的对象mydivVirtual代表它，它存储了对应dom的一些重要参数，在改变dom之前，会先比较相应虚拟dom的数据，如果需要改变，才会将改变应用到真实dom上。")])])])])]),e("li",[e("p",[t._v("（3）为什么不直接修改Dom而需要加一层Virtual Dom呢？")]),e("ul",[e("li",[t._v("很多时候手工优化dom确实会比virtual dom效率高，对于比较简单的dom结构用手工优化没有问题，但当页面结构很庞大，结构很复杂时，手工优化会花去大量时间，而且可维护性也不高，不能保证每个人都有手工优化的能力。至此，virtual dom的解决方案应运而生，")]),e("li",[t._v("virtual dom很多时候都不是最优的操作，但它具有普适性，在效率、可维护性之间达平衡。")]),e("li",[t._v("virtual dom 另一个重大意义就是提供一个中间层，js去写ui，ios安卓之类的负责渲染，就像reactNative一样。")])])]),e("li",[e("p",[t._v("（4）分析Diff")]),e("ul",[e("li",[e("p",[t._v("Vue和React的虚拟DOM的Diff算法大致相同，其核心是基于两个简单的假设：")]),e("ul",[e("li",[e("ol",{attrs:{start:""}},[e("li",[t._v("两个相同的组件产生类似的DOM结构，不同的组件产生不同的DOM结构。")])])]),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[t._v("同一层级的一组节点，他们可以通过唯一的id进行区分。")])])])])]),e("li",[e("p",[t._v("Diff算法特点：当页面的数据发生变化时，Diff算法只会比较同一层级的节点：")]),e("ul",[e("li",[t._v("1.如果节点类型不同，直接干掉前面的节点，再创建并插入新的节点，不会再比较这个节点以后的子节点了。")]),e("li",[t._v("2.如果节点类型相同，则会重新设置该节点的属性，从而实现节点的更新。")])])])])]),e("li",[e("p",[t._v("（5）传统Diff算法与Vue中的Diff算法")]),e("ul",[e("li",[e("p",[t._v("传统的Diff算法")]),e("ul",[e("li",[t._v("传统算法就是对每个节点一一对比，循环遍历所有的子节点，然后判断子节点的更新状态，分别为remove、add、change。如果before的子节点仍有子节点依旧顺次执行。")])])]),e("li",[e("p",[t._v("Vue中的Diff算法")]),e("ul",[e("li",[t._v("传统 diff 算法的复杂度为 O(n^3)，单纯从demo看，复杂度不到n3，但实际上。React 通过制定大胆的策略，将 O(n^3) 复杂度的问题转换成 O(n) 复杂度的问题。")])])])])])])])}],xs={},Cs=xs,js=Object(v["a"])(Cs,ws,ks,!1,null,"034a80a0",null),Ps=js.exports,Ts=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},Es=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("h2",[t._v("vue-router")]),e("h3",[t._v("基础")]),e("ul",[e("li",[e("p",[t._v("Vue.router基础")]),e("ul",[e("li",[e("p",[t._v("开始")]),e("ul",[e("li",[e("p",[t._v("作用：创建单页应用")])]),e("li",[e("p",[t._v("例子")]),e("ul",[e("li",[t._v("实例1（简单）")]),e("li",[t._v("实例2（复杂但有说明--命名路由中的例子）")])])])])]),e("li",[e("p",[t._v("动态路由匹配")]),e("ul",[e("li",[e("p",[t._v("基本知识")]),e("ul",[e("li",[e("p",[t._v("说明")]),e("ul",[e("li",[t._v("动态路由以冒号开头；通过$route.params可以访问相对应的值")])])]),e("li",[e("p",[t._v("例子")]),e("ul",[e("li",[t._v("实例")])])])])]),e("li",[e("p",[t._v("响应路由参数的变化")]),e("ul",[e("li",[e("p",[t._v("想对路由变化（从预设的路由A切换值预设的路由B）做出反应，可采用watch")])]),e("li",[e("p",[t._v("例子")]),e("ul",[e("li",[t._v("实例")])])])])]),e("li",[e("p",[t._v("高级匹配模式")])]),e("li",[e("p",[t._v("匹配优先级")]),e("ul",[e("li",[t._v("有时一个路径会有多个路由，这时以最先定义的路由优先级最高的原则来处理")])])])])]),e("li",[e("p",[t._v("嵌套路由")]),e("ul",[e("li",[e("p",[t._v("例子")]),e("ul",[e("li",[t._v("实例")])])])])]),e("li",[e("p",[t._v("编程式导航")]),e("ul",[e("li",[t._v("router.push(location)")]),e("li",[t._v("router.replace(location)")]),e("li",[t._v("router.go(n)")])])]),e("li",[e("p",[t._v("命名路由")]),e("ul",[e("li",[e("p",[t._v("注意事项")]),e("ul",[e("li",[t._v("1、需要命名（to及routes里都要有name属性）")]),e("li",[t._v("2、router-link 里的to 需要加v-bind")])])]),e("li",[e("p",[t._v("例子")]),e("ul",[e("li",[t._v("实例")])])])])]),e("li",[e("p",[t._v("命名视图")]),e("ul",[e("li",[e("p",[t._v("作用")]),e("ul",[e("li",[t._v("可以在界面中拥有多个单独命名的视图router-view ,而不是只有一个单独的出口")])])]),e("li",[e("p",[t._v("注意事项")]),e("ul",[e("li",[t._v("1、如果router-view没有设置名字，那么默认为default")]),e("li",[t._v("2、此时的component应该为复数即components")])])]),e("li",[e("p",[t._v("例子")]),e("ul",[e("li",[t._v("实例")])])])])]),e("li",[e("p",[t._v("重定向和别名")]),e("ul",[e("li",[e("p",[t._v("重定向")]),e("ul",[e("li",[e("p",[t._v("类型")]),e("ul",[e("li",[e("p",[t._v("参数为单纯的一个链接")]),e("ul",[e("li",[t._v("实例")])])]),e("li",[e("p",[t._v("参数为一个命名的路由")])]),e("li",[e("p",[t._v("参数为一个方法")])])])])])]),e("li",[e("p",[t._v("别名")]),e("ul",[e("li",[e("p",[t._v("例子")]),e("ul",[e("li",[t._v("实例")])])])])])])]),e("li",[e("p",[t._v("HTML5 History模式")]),e("ul",[e("li",[e("p",[t._v("好处")]),e("ul",[e("li",[t._v("vue-router默认使用的是hash模式，如果不想觉得hash模式（#）丑陋可以使用history模式；")])])]),e("li",[e("p",[t._v("注意事项")]),e("ul",[e("li",[e("p",[t._v("需要后台配置支持，否则可能会返回404了")]),e("ul",[e("li",[e("p",[t._v("后台配置例子")]),e("ul",[e("li",[t._v("实例")])])])])])])]),e("li",[e("p",[t._v("用法举例")]),e("ul",[e("li",[t._v("实例")])])]),e("li",[e("p",[t._v("其它建议")]),e("ul",[e("li",[e("p",[t._v("为了不让服务器给出404错误，可以给个警告。")]),e("ul",[e("li",[e("p",[t._v("非node.js后台")]),e("ul",[e("li",[t._v("实例")])])]),e("li",[e("p",[t._v("node.js后台")]),e("ul",[e("li",[t._v("可以在后台匹配路由，没匹配到时给出404，从而实现fallback")])])])])])])])])])])])]),e("h3",[t._v("进阶")]),e("ul",[e("li",[e("p",[t._v("导航钩子")]),e("ul",[e("li",[e("p",[t._v("作用")]),e("ul",[e("li",[t._v("用来拦截导航，让它完成跳转或取消")])])]),e("li",[e("p",[t._v("执行钩子的方式")]),e("ul",[e("li",[e("p",[t._v("全局钩子（beforeEach）")]),e("ul",[e("li",[e("p",[t._v("使用方法")]),e("ul",[e("li",[t._v("说明")])])]),e("li",[e("p",[t._v("例子")]),e("ul",[e("li",[t._v("实例--代码")]),e("li",[t._v("实例--运行结果")])])])])]),e("li",[e("p",[t._v("某个路由独享的钩子（beforeEnter）")]),e("ul",[e("li",[e("p",[t._v("与全局before钩子的方法参数一样")])]),e("li",[e("p",[t._v("使用方法")]),e("ul",[e("li",[e("p",[t._v("官网简介")])]),e("li",[e("p",[t._v("例子")]),e("ul",[e("li",[t._v("实例")])])])])])])]),e("li",[e("p",[t._v("组件内的钩子（beforeRouteEnter/Update/Leave）")]),e("ul",[e("li",[e("p",[t._v("使用方法")]),e("ul",[e("li",[t._v("官网例子")])])]),e("li",[e("p",[t._v("注意事项")]),e("ul",[e("li",[t._v("使用beforeRouteEnter无法访问组件实例this；不过可以通过传一个回调给next来访问组件实例")])])])])])])])])])])])}],Os={},Ms=Os,As=Object(v["a"])(Ms,Ts,Es,!1,null,"6c561e5c",null),Ns=As.exports,Is=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},Ds=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("h2",[t._v("前后端路由及前端路由的实现")]),e("h3",[t._v("前后端路由")]),e("ul",[e("li",[e("p",[t._v("传统的服务端路由")]),e("ul",[e("li",[e("p",[t._v("根据客户端请求的不同网址，返回不同的网页内容")])]),e("li",[e("p",[t._v("现象")]),e("ul",[e("li",[t._v("1、会造成服务器压力增加")]),e("li",[t._v("2、每次都重新请求，响应较慢、用户体验下降")])])])])]),e("li",[e("p",[t._v("前端路由")]),e("ul",[e("li",[t._v("在URL地址改变的过程中，通过JS来实现不同UI之间的切换（JS对DOM的操作），而不再向服务器重新请求页面，只通过AJAX向服务端请求数据，对用户来说这种无刷新的、即时响应是更好的体验。")]),e("li",[t._v("路由是映射关系，URL与处理函数的对应关系")])])])]),e("h3",[t._v("前端路由的实现方式")]),e("ul",[e("li",[e("p",[t._v("方法一：基于hash（location.hash+hashchange事件）")]),e("ul",[e("li",[e("p",[t._v("（1）hash满足以下几个特性，才使得其可以实现前端路由")]),e("ul",[e("li",[t._v("（1）url中hash值的变化并不会重新加载页面，因为hash是用来指导浏览器行为的，对服务端是无用的，所以不会包括在http请求中。")]),e("li",[t._v("（2）hash值的改变，都会在浏览器的访问历史中增加一个记录，也就是能通过浏览器的回退、前进按钮控制hash的切换")]),e("li",[t._v("（3）我们可以通过hashchange事件，监听到hash值的变化，从而响应不同路径的逻辑处理。")]),e("li",[t._v("如此一来，我们就可以在hashchange事件里，根据hash值来更新对应的视图，但不会去重新请求页面，同时呢，也在history里增加了一条访问记录，用户也仍然可以通过前进后退键实现UI的切换。")])])]),e("li",[e("p",[t._v("（2）触发hash值的变化有两种方法")]),e("ul",[e("li",[e("p",[t._v("1、通过a标签，设置href属性，当标签点击之后，地址栏会改变，同时会触发hashchange事件")]),e("ul",[e("li",[e("a",{attrs:{href:"#kaola"}},[t._v("to KAOLA")])])])]),e("li",[e("p",[t._v("2、通过JS直接赋值给location.hash，也会改变URL，触发hashchange事件")]),e("ul",[e("li",[t._v('location.hash="#kaola"')])])])])]),e("li",[e("p",[t._v("（3）hash实现简易Router代码")]),e("ul",[e("li",[e("p",[t._v("route")]),e("ul",[e("li",[t._v("route是一条路由，是将一个URL路径和一个处理函数相关联，是一条url和函数的映射规则，如上面代码中通过原型上的route可以设置一条路由规则，将一个path和其callback关联起来。")])])]),e("li",[e("p",[t._v("routes")]),e("ul",[e("li",[t._v("router则更像是一个容器，或者说一种机制，它管理了一组route。简单来说，route只是进行了URL和函数的映射，而在当接收到一个URL之后，去路由映射表中查找相应的函数，这个过程是由router来处理的，如上面代码，Router管理传入的route，并且在hash改变的时候，根据当前的url响应其对应的函数。")])])])])])])]),e("li",[e("p",[t._v("方法二：基于History新API（history.pushState()+popState事件）")]),e("ul",[e("li",[e("p",[t._v("History对象")]),e("ul",[e("li",[e("p",[t._v("history.pushState")]),e("ul",[e("li",[e("p",[t._v("用于在浏览历史中添加历史记录,但是并不触发跳转,此方法接受三个参数")]),e("ul",[e("li",[t._v("state:一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数。如果不需要这个对象，可以填null。")]),e("li",[t._v("title：新页面的标题，但是所有浏览器目前都忽略这个值，填空字符串l。")]),e("li",[t._v("url：新的URL不一定是绝对路径；如果是相对路径，它将以当前URL为基准；传入的URL与当前URL应该是同源的，否则，pushState()会抛出异常。")])])])])]),e("li",[e("p",[t._v("history.replaceState")]),e("ul",[e("li",[t._v("方法的参数与pushState方法一模一样，区别是它修改浏览历史中当前纪录,而非添加记录,同样不触发跳转。")])])]),e("li",[e("p",[t._v("popstate事件")]),e("ul",[e("li",[t._v("每当同一个文档的浏览历史（即history对象）出现变化时，就会触发popstate事件。")]),e("li",[t._v("注意，仅仅调用pushState()方法或replaceState()方法 ，并不会触发该事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用History.back()、History.forward()、History.go()方法时才会触发。另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。")])])])])]),e("li",[e("p",[t._v("代码")]),e("ul",[e("li",[t._v("当我们在历史记录中切换时就会触发 popstate 事件，可以在事件中还原当前state对应的UI。")])])])])])]),e("h3",[t._v("监听浏览器的后退按钮事件")]),e("ul",[e("li",[e("p",[t._v("（1）如果后退是跳转到另一个全新的页面")]),e("ul",[e("li",[t._v("实际上有很多事件都会触发 onbeforeunload，比如刷新、点击链接前往新的页面等。这里应该还是在页面加载完成比如 window.onload 事件里使用 history.pushState 推一条记录进栈，同时监听 window.onpopstate 事件")])])]),e("li",[e("p",[t._v("（2）如果整个页面是一个SPA，History API模式")]),e("ul",[e("li",[t._v("使用的是 pushState/replaceState 来实现的导航，那么当浏览器回退的时候会触发 window 上的 popstate 事件。这时需要监听 window.onpopstate 事件;")])])]),e("li",[e("p",[t._v("（3）如果整个页面是一个SPA，Hash模式")]),e("ul",[e("li",[e("p",[t._v("使用的是基于 hashChange 实现的导航，那么这个时候就比较麻烦。因为页面根据 hash 正常变化跳转（导航）的时候也会触发 popstate 事件，所以不能简单的监听 popstate 事件来做出判断。")])]),e("li",[e("p",[t._v("思路")]),e("ul",[e("li",[t._v("因为后退按钮属于浏览器的UI，并不属于任何一个页面，所以如果当鼠标在当前页面外时，监听的 popstate 事件被触发，那么认为用户点击了浏览器的后退按钮 (这里的判断鼠标是否在当前页面里是通过监听 document.onmouseleave 和 document.onmouseenter事件)；另外答案里还绑定了对 Backspace 键的监听，因为某些浏览器默认当页面焦点不属于输入域时触发的是后退操作。这个方法基本可以满足大多数情况，但是如果用户是通过鼠标侧键 (常见于游戏鼠标) 来实现的后退操作，那么可能就无法监听了。")])])]),e("li",[e("p",[t._v("Location对象")]),e("ul",[e("li",[e("p",[t._v("Location.reload([bForceGet]) - 刷新当前页面")]),e("ul",[e("li",[t._v('bForceGet为可选参数， 默认为 false，从浏览器的缓存里取当前页。true，从服务端取最新的页面, 相当于客户端点击 F5("刷新") 。')])])]),e("li",[e("p",[t._v("Location.replace(url) - 当前页面跳转到指定的URL")]),e("ul",[e("li",[t._v("并且用该URL替换当前的历史纪录，这样浏览历史记录中就只有一个页面，后退按钮永远处于失效状态，用户也就无法进行后退了。")])])]),e("li",[e("p",[t._v("Location.assign(url) - 当前页面跳转到指定的URL")]),e("ul",[e("li",[t._v("和使用location.href=URL是一样的。会产生历史记录。")])])])])])])]),e("li",[e("p",[t._v("考虑前进/后退的差别")]),e("ul",[e("li",[t._v("其实前进按钮也会触发 popstate 事件。如果是使用了 HTML5 的 history api 的单页应用，可以在 pushState 的时候给要入栈的状态对象加上一个字段来区分历史栈中每个状态的先后顺序，比如 pushState({s: 'a.html', index: 0}, '', 'a.html') 和 pushState({s: 'b.html', index: 1}, '', 'b.html')，这样当点击浏览器前进后退按钮的时候我们可以通过比较 e.state.index 和当前 history.state.index 的值来判断具体是入栈还是出栈")])])])])])}],zs={},$s=zs,Rs=Object(v["a"])($s,Is,Ds,!1,null,"0bd584f4",null),Js=Rs.exports,Ls=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},Hs=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("h2",[t._v("Vue的diff算法")]),e("h3",[t._v("以对象的形式模拟树形结构")]),e("h3",[t._v("diff过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的dom打补丁")]),e("h3",[t._v("比较新旧节点的时候，只会在同层级进行")]),e("h3",[t._v("5种节点比较情况")]),e("ul",[e("li",[t._v("oldVnode===vnode，引用一致，认为没有变化")]),e("li",[t._v("新旧节点text不为空，且不相等则将Node.textContent = vnode.text")]),e("li",[t._v("只有新的节点有子节点则在老节点中添加子节点")]),e("li",[t._v("新节点没有子节点，老节点有子节点则删除")]),e("li",[t._v("子节点不为空且不相等则updateChildren")])]),e("h3",[t._v("updateChild")]),e("ul",[e("li",[e("p",[t._v("将旧节点的子节点和新节点的子节点提取出来")])]),e("li",[e("p",[t._v("新旧节点头尾各有两个指针，变量相互比较，四种比较方式")]),e("ul",[e("li",[t._v("oldS、oldE、S、E两两做sameVnode比较，有四种比较方式，当其中两个能匹配上那么真实dom中的相应节点会移到Vnode相应的位置")]),e("li",[t._v("匹配成功后，指针往中间移动")])])]),e("li",[e("p",[t._v("上一步比较没有匹配，有key的话会用key进行比较")]),e("ul",[e("li",[t._v("根据就节点的key生成一张hash表")]),e("li",[t._v("新节点的头尾与hash表做匹配判断是都相等")]),e("li",[t._v("如果匹配成功将就节点匹配的节点移到相应的位置")]),e("li",[t._v("如果匹配不成功则直接生成新节点插入")]),e("li",[t._v("如果没有key只会进行四种比较，指针中间的节点就做不到复用了")])])]),e("li",[e("p",[t._v("结束条件")]),e("ul",[e("li",[t._v("旧节点的头指针大于尾指针则将多余的新节点根据index添加到dom中")]),e("li",[t._v("新节点的头指针大于尾指针，那么将旧节点的头尾指针之间的节点删除")])])])]),e("h3",[t._v("sameVnode")]),e("ul",[e("li",[e("p",[t._v("比较两个节点是否相同")]),e("ul",[e("li",[t._v("key相同")]),e("li",[t._v("tag（当前节点的标签名）相同")]),e("li",[t._v("isComment（是否为注释节点）相同")]),e("li",[t._v("当标签是"),e("input"),t._v("的时候，type必须相同")]),e("li",[t._v("是否data（当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息）都有定义")])])])])])}],qs={},Fs=qs,Ws=Object(v["a"])(Fs,Ls,Hs,!1,null,"5b9ea61e",null),Bs=Ws.exports,Us=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},Gs=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("h4",[t._v("关于前端高级工程师面试")]),e("br"),e("pre",[t._v("\r\n"),e("h5",[t._v(" 一：基础知识")]),t._v("\r\nVue 基本的双向绑定实现原理"),e("br"),t._v("\r\nvue 生命周期 每个状态差别。"),e("br"),t._v("\r\n生命周期中何时能操作提取 DOM 样式属性？何时请求 API 渲染？为什么？ 销毁之前一般要处理哪些东西？"),e("br"),t._v("\r\n为什么要处理？到底是什么原因导致这种弊端存在？"),e("br"),t._v("\r\nVue 自定义指令实现基本底层原理？"),e("br"),t._v("\r\nVue mixin 原理 你是如何使用的 ？"),e("br"),t._v("\r\n如何做到路由无改变情况下点击菜单栏，当前页面局部刷新？\r\nInject 是否用过？Observe 是否用过？（这两个问题 牵扯高级部分，水平一般的也不会问。）\r\nVue 父子，兄弟组件传参问题。有哪些方法可以实现？你能说出几种？ 跨多个打开页面数据共享呢？\r\n说出几种实现途径。不论前后端都可以说 Vue 中如何监听调用原生 window 事件？ \r\n你是如何使用 VUE，UMD？还是 cli 方式？ Cli?2.x?3.x?常用配置?差别？\r\nVuex 的根本实现原理？\r\n你说熟悉 jquery，那你能否解释一下：事件派发，事件委托的原理？\r\nVue-router 的两种模式，深度解释一下。和 H5 新的 API 有何关联？ Vue-router 的路由拦截 或者叫 守护。\r\n你在项目中如何使用？全局的，局部的，权限的。\r\nVue-router 本质上是一种什么东西？（个人认为是哈希参照表,jJSON 配置文件）\r\n你们的前后端交互数据传输，使用的什么？是否做过封装？\r\nAxios,前后拦截封装，如何发送 formdata ，文件类型数据？\r\nES6 你开发中常用的一些方法，详细解释一下。\r\nES6 和 ES5 本质底层差别不大，大部分是语法糖。你对于语法糖怎么看？\r\n闭包原理？实际开发中你是如何使用？一般用来做什么？\r\n存储问题，几种存储的区别。\r\n跨域问题，解决方案，每种方案原理？ \r\nBootstrap 等 UI 框架栅栏布局原理。\r\nFlex 几个重要属性，或者讲出来可以对实现什么？\r\n数组的常用操作？\r\nObject.assign 是深拷贝还是浅拷贝？\r\n作用域链\r\n")]),e("pre",[t._v("\r\n"),e("h5",[t._v("二扩展层面")]),t._v("\r\nJs 本身存在一定局限性，在实际开法中，可能需要自己做一些常用工具函数的封装。 \r\n你是否用过插件，或者 js 扩展库，或者讲一讲自己的常用封装。 \r\n如果让你现在写一个常用的，对象的深层拷贝，讲一讲你的思路。\r\n如果让你现在写一个常用的，对象的深层合并（并去重），讲一讲你的思路。\r\n递归，如何跳出递归？你是否用过？ 运行种换肤问题。\r\nVuecli 多入口。 一般不问。\r\nVuecli webpack 你是逗深入了解 过？ 图片压缩，代码压缩， 文件名，等，这些一般略过。\r\n目前前端开发面向终端较多，各种设备，你是否有使用过跨多端开发框架。\r\n讲一讲 （跨多端框架很重要，跨多端输出工具其次） 和你配合开发过项目的前后端交互的后台开发语言有哪些？ \r\n你们的项目如何部署的？ \r\n你是否掌握其他后端可开发语言，如果会，讲一讲你的前后端独立开发怎么进行。\r\n也会稍微问一些语言的共通性，也就是相似的地方。 \r\n（一般的中上等以上的工程师，都基本会一些其他语言）\r\n"),e("h5",[t._v("三架构层次")]),t._v("\r\n你是否有过中大型项目独立开发经验？讲一讲，你是如何进行架构设计的。\r\n代码规范层次。 你做过这么多项目，是否有过封装，有哪些方向的封装，讲一讲。\r\n如果现在让你写一套样式库，你打算如何入手。\r\n超大型项目，运行种换肤问题。\r\n页面防抖问题，说根本。\r\n你是否写过通用函数封装，讲一讲都做过哪些？功用是什么，为什么需要这种封装？ \r\n你是都对你所使用的的 UI 框架二次优化过，讲一讲。 \r\n多个项目开发，你是否认为多数项目在操作层面的代码方面上有一定的相似性，你是逗做过 抽离封装，可以跨多个项目使用。深入讲一讲。 \r\n模块化开发，狭义上来讲是说组件。深层来理解，很多东西都可以分为模块，而大型项目 不进行模块化开发，几乎不可能。\r\n请从各个方面讲一讲，如果让你负责开发超大型项目，技 术架构方面你会如何处理？或者有什么想法都可以说说。\r\n前端静态化部署。 \r\n伪静态\r\n如果一套代码 应对一百个网站，每个网站存在一定差异性，如何规划？如何同步上新？\r\nSSR 问题。  \r\n首屏优化。网络很差的情况下如何首屏优化。 \r\nCDN 加速问题。 分布式问题 如果项目需要你用前端来写爬虫，你如何规划？\r\n"),e("h5",[t._v("四工作流和管理问题")]),t._v("\r\n这个也就是聊一聊谈谈，一般很少能到这一块的。\r\n工作流和管理，一部分是你是否有过协作 开发经验、大公司开发经验、管理多人负责项目经验。\r\n"),e("h5",[t._v("五技术主管和总监")]),t._v("\r\n技术主管和总监根本和以上这些都不在一个层次，属于管理层，但是基本都是可开发出身。\r\n技术能力基本肯定是真正的全栈，多语言精通的。还要能把握方向，懂得各部分沟通交流，熟悉工作和管理流程。 \r\n小公司的 就不谈这个问题了，没那么多要求。\r\n")])])}],Vs={},Xs=Vs,Qs=Object(v["a"])(Xs,Us,Gs,!1,null,"f2721552",null),Ys=Qs.exports,Ks=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},Zs=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("h3",[t._v("nextTick")]),e("ul",[e("li",[e("p",[t._v("（1）为什么要有nextTick？")]),e("ul",[e("li",[e("p",[t._v("现象")]),e("ul",[e("li",[t._v("这段脚本执行我们猜测会依次打印：1、2、3。但是实际效果中，只会输出一次：3。")])])]),e("li",[e("p",[t._v("原因")]),e("ul",[e("li",[t._v("现在有这样的一种情况，mounted的时候test的值会被++循环执行1000次。 每次++时，都会根据响应式触发setter->Dep->Watcher->update->run。 如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。")]),e("li",[t._v("所以Vue实现了一个queue队列，在下一个Tick（或者是当前Tick的微任务阶段）的时候会统一执行queue中Watcher的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行1000次Watcher的run。最终更新视图只会直接将test对应的DOM的0变成1000。 保证更新视图操作DOM的动作是在当前栈执行完以后下一个Tick（或者是当前Tick的微任务阶段）的时候调用，大大优化了性能。")])])])])]),e("li",[e("p",[t._v("（2）nextTick用法示例")]),e("ul",[e("li",[t._v("模板")]),e("li",[t._v("Vue实例")]),e("li",[t._v("结果")]),e("li",[t._v("msg1和msg3显示的内容还是变换之前的，而msg2显示的内容是变换之后的。其根本原因是因为Vue中DOM更新是异步的")])])]),e("li",[e("p",[t._v("（3）nextTick的应用场景")]),e("ul",[e("li",[e("p",[t._v("1.在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中")]),e("ul",[e("li",[t._v("在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted()钩子函数，因为该钩子函数执行时所有的DOM挂载和渲染都已完成，此时在该钩子函数中进行任何DOM操作都不会有问题 。")])])]),e("li",[e("p",[t._v("2.在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。")])])])]),e("li",[e("p",[t._v("（4）nextTick的版本区别")]),e("ul",[e("li",[t._v("在 Vue 2.4 之前的版本，nextTick 几乎都是基于 micro task 实现的，但由于 micro task 的执行优先级非常高，在某些场景下它甚至要比事件冒泡还要快，就会导致一些诡异的问题，如 issue #4521、#6690、#6566；但是如果全部都改成 macro task，对一些有重绘和动画的场景也会有性能影响，如 issue #6813。所以最终 nextTick 采取的策略是默认走 micro task，对于一些 DOM 交互事件，如 v-on 绑定的事件回调函数的处理，会强制走 macro task。")])])])])])}],to={},no=to,eo=Object(v["a"])(no,Ks,Zs,!1,null,"0918f452",null),ao=eo.exports,ro=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{},[e("q-markdown",{attrs:{src:t.MainComponent}})],1)},so=[],oo="# mv*\n\n## MVC\n\n### MVC表面概念\n\n- Model（模型）---\x3e数据层（数据保存）\n\n\t- 需要运算的数据（以计算器为例）\n\n- View（视图）---\x3e视图层（用户界面）\n\n\t- 按钮及显示屏（以计算器为例）\n\n- Controller（控制）---\x3e控制层（业务逻辑）\n\n\t- 处理加减乘除内部的运算步骤 （以计算器为例）\n\n### 好处\n\n- 三者之间紧密联系但又相互独立，一个层面进行重构时不影响其他层面\n\n### 示意图\n\n- 从view接受指令\n- 从controller接受指令\n\n### 通信特点\n\n- 所有通信都是单向的\n\n## MVP\n\n### MVP表面概念\n\n- Model（模型）---\x3e数据层（数据保存）\n- View（视图）---\x3e视图层（用户界面）\n- Presenter（主持）---\x3e主持层\n\n### 示意图\n\n### 通信特点\n\n- 各部分通信都是双向的\n- view和model不发生关系，都是通过presenter\n- view非常薄，不部署任何业务逻辑，因此称为“被动视图”，即没有任何主动性。presenter非常厚，所有逻辑都部署在那里\n\n## MVVM\n\n### MVVM表面概念\n\n- Model（模型）---\x3e数据层（数据保存）\n- View（视图）---\x3e视图层（用户界面）\n- ViewModel\n\n### 示意图\n\n### 通信特点\n\n- 与MVP基本一致，唯一的区别就是MVVM采用了双向数据绑定，view的变化会自动反映在ViewModel上，反之亦然。\n\n",lo={data:function(){return{MainComponent:oo}}},io=lo,co=Object(v["a"])(io,ro,so,!1,null,"7d9116d8",null),po=co.exports,bo={components:{m1:cs,m2:ms,m3:Ss,m4:Ps,m5:Ns,m6:Js,m7:Bs,m8:Ys,m9:ao,m10:po},data:function(){return{tab:"m1",tabs:[{label:"mv*",value:"m10"},{label:"基本",value:"m1"},{label:"双向绑定原理",value:"m2"},{label:"监听缺陷",value:"m3"},{label:"Virtual Dom",value:"m4"},{label:"vue-router",value:"m5"},{label:"前后端路由",value:"m6"},{label:"diff算法",value:"m7"},{label:"nextTick",value:"m9"},{label:"面试",value:"m8"}]}}},uo=bo,vo=Object(v["a"])(uo,es,as,!1,null,"414b9b54",null),go=vo.exports,mo=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+t.value,label:n+1+"."+t.label}})})),1),e("div",{staticClass:"q-mx-lg"},[e(""+t.tab,{tag:"component"})],1)],1)},_o=[],ho=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{},[e("q-markdown",{attrs:{src:t.MainComponent}})],1)},fo=[],yo="# react\n\n## React\n\n### 概述\n\n- React 是一个用于构建用户界面的 JAVASCRIPT 库。\n- React主要用于构建UI，很人多认为 React 是 MVC 中的 V（视图）。\n- React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。\n- React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。\n\n### 特点\n\n- 1.声明式设计 −React采用声明范式，可以轻松描述应用。\n- 2.高效 −React通过对DOM的模拟，最大限度地减少与DOM的交互。\n- 3.灵活 −React可以与已知的库或框架很好地配合。\n- 4.JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。\n- 5.组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。\n- 6.单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。\n\n### React JSX\n\n- JSX 是 React 的核心组成部分，它使用 XML 标记的方式去直接声明界面，界面组件之间可以互相嵌套\n- 优点：\n\n\t- JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化。\n\t- 它是类型安全的，在编译过程中就能发现错误。\n\t- 使用 JSX 编写模板更加简单快速。\n\n- 用法\n\n\t- JSX 看起来类似 HTML ，我们可以看下实例:\n\n\t\t- ReactDOM.render(\n\t<h1>Hello, world!</h1>,\n\tdocument.getElementById('example')\n);\n\n\t- 独立文件\n\t- JavaScript 表达式\n\n\t\t- 我们可以在 JSX 中使用 JavaScript 表达式。表达式写在花括号 {} 中。实例如下：\n\n\t\t\t- ReactDOM.render(\n\t<div>\n\t  <h1>{1+1}</h1>\n\t</div>\n\t,\n\tdocument.getElementById('example')\n);\n\n\t- 在 JSX 中不能使用 if else 语句，单可以使用 conditional (三元运算) 表达式来替代。\n\t- 样式\n\n\t\t- React 推荐使用内联样式。我们可以使用 camelCase 语法来设置内联样式. React 会在指定元素数字后自动添加 px 。以下实例演示了为 h1 元素添加 myStyle 内联样式：\n\n\t\t\t- var myStyle = {\n\tfontSize: 100,\n\tcolor: '#FF0000'\n};\nReactDOM.render(\n\t<h1 style = {myStyle}>W3Cschool教程</h1>,\n\tdocument.getElementById('example')\n);\n\n\t- 注释\n\n\t\t- 注释需要写在花括号中\n\n\t\t\t- ReactDOM.render(\n\t<div>\n    <h1>W3Cschool教程</h1>\n    {/*注释...*/}\n \t</div>,\n\tdocument.getElementById('example')\n);\n\n\t- 数组\n\n\t\t- JSX 允许在模板中插入数组，数组会自动展开所有成员：\n\n\t\t\t- var arr = [\n  <h1>W3Cschool教程</h1>,\n  <h2>从W3Cschool开始！</h2>,\n];\nReactDOM.render(\n  <div>{arr}</div>,\n  document.getElementById('example')\n);\n\n### State(状态)\n\n- React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。\n\n\t- 当用户点击组件，导致状态变化，this.setState 方法就修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件\n\n### Props\n\n- state 和 props 主要的区别在于 props 是不可变的，而 state 可以根据与用户交互来改变。\n- State 和 Props\n\n\t- 我们可以在父组件中设置 state， 并通过在子组件上使用 props 将其传递到子组件上。\n\n- Props 验证\n\n\t- Props 验证使用 propTypes，它可以保证我们的应用组件被正确使用，React.PropTypes 提供很多验证器 (validator) 来验证传入数据是否有效。当向 props 传入无效数据时，JavaScript 控制台会抛出警告。\n\n\t\t- var title = \"W3Cschool教程\";\n// var title = 123;\nvar MyTitle = React.createClass({\n  propTypes: {\n    title: React.PropTypes.string.isRequired,\n  },\n\n  render: function() {\n     return <h1> {this.props.title} </h1>;\n   }\n});\nReactDOM.render(\n    <MyTitle title={title} />,\n    document.getElementById('example')\n);\n\n\t- 更多验证器说明如下：\n\n\t\t- propTypes: {\n    // 可以声明 prop 为指定的 JS 基本数据类型，默认情况，这些数据是可选的\n   optionalArray: React.PropTypes.array,\n    optionalBool: React.PropTypes.bool,\n    optionalFunc: React.PropTypes.func,\n    optionalNumber: React.PropTypes.number,\n    optionalObject: React.PropTypes.object,\n    optionalString: React.PropTypes.string,\n\n    // 可以被渲染的对象 numbers, strings, elements 或 array\n    optionalNode: React.PropTypes.node,\n\n    //  React 元素\n    optionalElement: React.PropTypes.element,\n\n    // 用 JS 的 instanceof 操作符声明 prop 为类的实例。\n    optionalMessage: React.PropTypes.instanceOf(Message),\n\n    // 用 enum 来限制 prop 只接受指定的值。\n    optionalEnum: React.PropTypes.oneOf(['News', 'Photos']),\n\n    // 可以是多个对象类型中的一个\n    optionalUnion: React.PropTypes.oneOfType([\n      React.PropTypes.string,\n      React.PropTypes.number,\n      React.PropTypes.instanceOf(Message)\n    ]),\n\n    // 指定类型组成的数组\n    optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number),\n\n    // 指定类型的属性构成的对象\n    optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number),\n\n    // 特定 shape 参数的对象\n    optionalObjectWithShape: React.PropTypes.shape({\n      color: React.PropTypes.string,\n      fontSize: React.PropTypes.number\n    }),\n\n    // 任意类型加上 `isRequired` 来使 prop 不可空。\n    requiredFunc: React.PropTypes.func.isRequired,\n\n    // 不可空的任意类型\n    requiredAny: React.PropTypes.any.isRequired,\n\n    // 自定义验证器。如果验证失败需要返回一个 Error 对象。不要直接使用 `console.warn` 或抛异常，因为这样 `oneOfType` 会失效。\n    customProp: function(props, propName, componentName) {\n      if (!/matchme/.test(props[propName])) {\n        return new Error('Validation failed!');\n      }\n    }\n  },\n\n### React 组件 API\n\n- 设置状态：setState\n\n\t- setState(object nextState[, function callback])\n\n\t\t- nextState，将要设置的新状态，该状态会和当前的state合并\n\t\t- callback，可选参数，回调函数。该函数会在setState设置成功，且组件重新渲染后调用。\n\t\t- 合并nextState和当前state，并重新渲染组件。setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法。\n\t\t- 关于setState\n\n\t\t\t- 不能在组件内部通过this.state修改状态，因为该状态会在调用setState()后被替换。\n\t\t\t- setState()并不会立即改变this.state，而是创建一个即将处理的state。setState()并不一定是同步的，为了提升性能React会批量执行state和DOM渲染。\n\t\t\t- setState()总是会触发一次组件重绘，除非在shouldComponentUpdate()中实现了一些条件渲染逻辑。\n\n- 替换状态：replaceState\n\n\t- replaceState(object nextState[, function callback])\n\n\t\t- nextState，将要设置的新状态，该状态会替换当前的state。\n\t\t- callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。\n\t\t- replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。\n\n- 设置属性：setProps\n\n\t- setProps(object nextProps[, function callback])\n\n\t\t- nextProps，将要设置的新属性，该状态会和当前的props合并\n\t\t- callback，可选参数，回调函数。该函数会在setProps设置成功，且组件重新渲染后调用。\n\t\t- props相当于组件的数据流，它总是会从父组件向下传递至所有的子组件中。\n\t\t- 当和一个外部的JavaScript应用集成时，我们可能会需要向组件传递数据或通知React.render()组件需要重新渲染，可以使用setProps()。\n\n更新组件，我可以在节点上再次调用React.render()，也可以通过setProps()方法改变组件属性，触发组件重新渲染。\n\n- 替换属性：replaceProps\n\n\t- replaceProps(object nextProps[, function callback])\n\n\t\t- nextProps，将要设置的新属性，该属性会替换当前的props。\n\t\t- callback，可选参数，回调函数。该函数会在replaceProps设置成功，且组件重新渲染后调用。\n\t\t- replaceProps()方法与setProps类似，但它会删除原有props\n\n- 强制更新：forceUpdate\n\n\t- forceUpdate([function callback])\n\n\t\t- callback，可选参数，回调函数。该函数会在组件render()方法调用后调用。\n\t\t- forceUpdate()方法会使组件调用自身的render()方法重新渲染组件，组件的子组件也会调用自己的render()。但是，组件重新渲染时，依然会读取this.props和this.state，如果状态没有改变，那么React只会更新DOM。\n\nforceUpdate()方法适用于this.props和this.state之外的组件重绘（如：修改了this.state后），通过该方法通知React需要调用render()\n\n一般来说，应该尽量避免使用forceUpdate()，而仅从this.props和this.state中读取状态并由React触发render()调用。\n\n- 获取DOM节点：findDOMNode\n\n\t- DOMElement findDOMNode()\n\n\t\t- 返回值：DOM元素DOMElement\n\n\t\t\t- 如果组件已经挂载到DOM中，该方法返回对应的本地浏览器 DOM 元素。当render返回null 或 false时，\nthis.findDOMNode()也会返回null。从DOM 中读取值的时候，该方法很有用，如：获取表单字段的值和做一些 DOM 操作。\n\n- 判断组件挂载状态：isMounted\n\n\t- bool isMounted()\n\n\t\t- 返回值：true或false，表示组件是否已挂载到DOM中\n\n\t\t\t- isMounted()方法用于判断组件是否已挂载到DOM中。可以使用该方法保证了setState()和forceUpdate()在异步场景下的调用不会出错。\n\n### React 组件生命周期\n\n- React 组件的生命周期函数，又叫钩子函数，它能响应不同的状态。\n\n\t- 组件的生命周期可分成三个状态：\n\n\t\t- Mounting：已插入真实 DOM\n\t\t- Updating：正在被重新渲染\n\t\t- Unmounting：已移出真实 DOM\n\n\t- 生命周期的方法有：\n\n\t\t- componentWillMount 在渲染前调用,在客户端也在服务端。\n\t\t- componentDidMount : 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。\n 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异部操作阻塞UI)。\n\t\t- componentWillReceiveProps 在组件接收到一个新的prop时被调用。这个方法在初始化render时不会被调用。\n\t\t- shouldComponentUpdate 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。 \n可以在你确认不需要更新组件时使用。\n\t\t- componentWillUpdate在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。\n\t\t- componentDidUpdate 在组件完成更新后立即调用。在初始化时不会被调用。\n\t\t- componentWillUnmount在组件从 DOM 中移除的时候立刻被调用。\n\n### React AJAX\n\n- React 组件的数据可以通过 componentDidMount 方法中的 Ajax 来获取，当从服务端获取数据库可以将数据存储在 state 中，再用 this.setState 方法重新渲染 UI。\n- 当使用异步加载数据时，在组件卸载前使用 componentWillUnmount 来取消未完成的请求。\n\n### React Refs\n\n- React 支持一种非常特殊的属性 Ref ，你可以用来绑定到 render() 输出的任何组件上。\n- 这个特殊的属性允许你引用 render() 返回的相应的支撑实例（ backing instance ）。这样就可以确保在任何时间总是拿到正确的实例。\n- ref 属性的值可以是一个字符串也可以是一个函数。\n- 使用方法\n\n\t- 绑定一个 ref 属性到 render 的返回值上：\n\n\t\t- <input ref=\"myInput\" />\n\n\t\t\t- 在其它代码中，通过 this.refs 获取支撑实例:\n\n\t\t\t\t- var input = this.refs.myInput;\nvar inputValue = input.value;\nvar inputRect = input.getBoundingClientRect();\n\n## Redux\n\n### 三个基本原则\n\n- 整个应用只有唯一一个可信数据源，也就是只有一个 Store\n- State 只能通过触发 Action 来更改\n- State 的更改必须写成纯函数，也就是每次更改总是返回一个新的 State，在 Redux 里这种函数称为 Reducer\n\n### Actions\n\n- Action 很简单，就是一个单纯的包含 { type, payload } 的对象，type 是一个常量用来标示动作类型，payload 是这个动作携带的数据。Action 需要通过 store.dispatch() 方法来发送。\n\n\t- 比如一个最简单的 action：\n\n\t\t- {\n  type: 'ADD_TODO',\n  text: 'Build my first Redux app'\n}\n\n\t- 一般来说，会使用函数（Action Creators）来生成 action，这样会有更大的灵活性，Action Creators 是一个 pure function，它最后会返回一个 action 对象：\n\n\t\t- function addTodo(text) {\n  return {\n    type: 'ADD_TODO',\n    text\n  }\n}\n\t\t- 所以现在要触发一个动作只要调用 dispatch: dispatch(addTodo(text))\n稍后会讲到如何拿到 store.dispatch\n\n### Reducers\n\n- Reducer 用来处理 Action 触发的对状态树的更改。\n- 所以一个 reducer 函数会接受 oldState 和 action 两个参数，返回一个新的 state：(oldState, action) => newState。一个简单的 reducer 可能类似这样：\n\n\t- const initialState = {\n  a: 'a',\n  b: 'b'\n};\n\nfunction someApp(state = initialState, action) {\n  switch (action.type) {\n    case 'CHANGE_A':\n      return { ...state, a: 'Modified a' };\n    case 'CHANGE_B':\n      return { ...state, b: action.payload };\n    default:\n      return state\n  }\n}\n\t- 值得注意的有两点：\n\n\t\t- 我们用到了 object spread 语法 确保不会更改到 oldState 而是返回一个 newState\n\t\t- 对于不需要处理的 action，直接返回 oldState\n\n- Reducer 也是 pure function，这点非常重要，所以绝对不要在 reducer 里面做一些引入 side-effects 的事情，比如：\n\n\t- 直接修改 state 参数对象\n\t- 请求 API\n\t- 调用不纯的函数，比如 Data.now() Math.random()\n\n- 因为 Redux 里面只有一个 Store，对应一个 State 状态，所以整个 State 对象就是由一个 reducer 函数管理，但是如果所有的状态更改逻辑都放在这一个 reducer 里面，显然会变得越来越巨大，越来越难以维护。得益于纯函数的实现，我们只需要稍微变通一下，让状态树上的每个字段都有一个 reducer 函数来管理就可以拆分成很小的 reducer 了：\n\n\t- function someApp(state = {}, action) {\n  return {\n    a: reducerA(state.a, action),\n    b: reducerB(state.b, action)\n  };\n}\n\t- Redux 提供了一个工具函数 combineReducers 来简化这种 reducer 合并：\n\n\t\t- import { combineReducers } from 'redux';\n\nconst someApp = combineReducers({\n  a: reducerA,\n  b: reducerB\n});\n\n### Store\n\n- 现在有了 Action 和 Reducer，Store 的作用就是连接这两者，Store 的作用有这么几个：\n\n\t- Hold 住整个应用的 State 状态树\n\t- 提供一个 getState() 方法获取 State\n\t- 提供一个 dispatch() 方法发送 action 更改 State\n\t- 提供一个 subscribe() 方法注册回调函数监听 State 的更改\n\n- 创建一个 Store 很容易，将 root reducer 函数传递给 createStore 方法即可：\n\n\t- import { createStore } from 'redux';\nimport someApp from './reducers';\nlet store = createStore(someApp);\n\n// 你也可以额外指定一个初始 State（initialState），这对于服务端渲染很有用\n// let store = createStore(someApp, window.STATE_FROM_SERVER);\n\n\t\t- 现在我们就拿到了 store.dispatch，可以用来分发 action 了：\n\n\t\t\t- let unsubscribe = store.subscribe(() => console.log(store.getState()));\n\n// Dispatch\nstore.dispatch({ type: 'CHANGE_A' });\nstore.dispatch({ type: 'CHANGE_B', payload: 'Modified b' });\n\n// Stop listening to state updates\nunsubscribe();\n\n### Data Flow\n\n- 以上提到的 store.dispatch(action) -> reducer(state, action) -> store.getState() 其实就构成了一个“单向数据流”，我们再来总结一下。\n\n\t- 1. 调用 store.dispatch(action)\n\n\t\t- Action 是一个包含 { type, payload } 的对象，它描述了“发生了什么”，比如：\n\n\t\t\t- { type: 'LIKE_ARTICLE', articleID: 42 }\n{ type: 'FETCH_USER_SUCCESS', response: { id: 3, name: 'Mary' } }\n{ type: 'ADD_TODO', text: 'Read the Redux docs.' }\n\n\t\t- 你可以在任何地方调用 store.dispatch(action)，比如组件内部，Ajax 回调函数里面等等。\n\n\t- 2. Action 会触发给 Store 指定的 root reducer\n\n\t\t- root reducer 会返回一个完整的状态树，State 对象上的各个字段值可以由各自的 reducer 函数处理并返回新的值。\n\n\t\t\t- reducer 函数接受 (state, action) 两个参数\n\t\t\t- reducer 函数判断 action.type 然后处理对应的 action.payload 数据来更新并返回一个新的 state\n\n\t- 3. Store 会保存 root reducer 返回的状态树\n\n\t\t- 新的 State 会替代旧的 State，然后所有 store.subscribe(listener) 注册的回调函数会被调用，在回调函数里面可以通过 store.getState() 拿到新的 State。\n\n### 在 React 应用中使用 Redux\n\n- 和 Flux 类似，Redux 也是需要注册一个回调函数 store.subscribe(listener) 来获取 State 的更新，然后我们要在 listener 里面调用 setState() 来更新 React 组件。\nRedux 官方提供了 react-redux 来简化 React 和 Redux 之间的绑定，不再需要像 Flux 那样手动注册／解绑回调函数。\n- <Provider>\n\n\t- <Provider> 作为一个容器组件，用来接受 Store，并且让 Store 对子组件可用，用法如下：\n\n\t\t- import { render } from 'react-dom';\nimport { Provider } from 'react-redux';\nimport App from './app';\n\nrender(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n);\n\t\t- 这时候 <Provider> 里面的子组件 <App /> 才可以使用 connect 方法关联 store。\n\t\t- <Provider> 的实现很简单，他利用了 React 一个（暂时）隐藏的特性 Contexts，Context 用来传递一些父容器的属性对所有子孙组件可见，在某些场景下面避免了用 props 传递多层组件的繁琐，\n\n- Connect\n\n\t- connect() 这个方法略微复杂一点，主要是因为它的用法非常灵活：connect([mapStateToProps], mapDispatchToProps], [mergeProps], [options])，它最多接受4个参数，都是可选的，并且这个方法调用会返回另一个函数，这个返回的函数来接受一个组件类作为参数，最后才返回一个和 Redux store 关联起来的新组件，类似这样：\n\n\t\t- class App extends Component { ... }\n\nexport default connect()(App);\n\n\t\t\t- 这样就可以在 App 这个组件里面通过 props 拿到 Store 的 dispatch 方法，但是注意现在的 App 没有监听 Store 的状态更改，如果要监听 Store 的状态更改，必须要指定 mapStateToProps 参数。\n\n\t\t\t\t- [mapStateToProps(state, [ownProps]): stateProps]: 第一个可选参数是一个函数，只有指定了这个参数，这个关联（connected）组件才会监听 Redux Store 的更新，每次更新都会调用 mapStateToProps 这个函数，返回一个字面量对象将会合并到组件的 props 属性。 ownProps 是可选的第二个参数，它是传递给组件的 props，当组件获取到新的 props 时，ownProps 都会拿到这个值并且执行 mapStateToProps 这个函数。\n\t\t\t\t- [mapDispatchProps(dispatch, [ownProps]): dispatchProps]: 这个函数用来指定如何传递 dispatch 给组件，在这个函数里面直接 dispatch action creator，返回一个字面量对象将会合并到组件的 props 属性，这样关联组件可以直接通过 props 调用到 action， Redux 提供了一个 bindActionCreators() 辅助函数来简化这种写法。 如果省略这个参数，默认直接把 dispatch 作为 props 传入。ownProps 作用同上。\n\n*XMind: ZEN - Trial Version*",So={data:function(){return{MainComponent:yo}}},wo=So,ko=Object(v["a"])(wo,ho,fo,!1,null,"be6a93a6",null),xo=ko.exports,Co={components:{m1:xo},data:function(){return{tab:"m1",tabs:[{label:"react",value:"m1"}]}}},jo=Co,Po=Object(v["a"])(jo,mo,_o,!1,null,"a63105b6",null),To=Po.exports,Eo=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+t.value,label:n+1+"."+t.label}})})),1),e("div",{staticClass:"q-mx-lg"},[e(""+t.tab,{tag:"component"})],1)],1)},Oo=[],Mo=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},Ao=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("article",{staticClass:"post"},[e("header",{staticClass:"post-header"},[e("h4",{staticClass:"post-title"},[t._v("\n        前端测试、性能监测、自动化集成方案\n      ")])]),e("div",{staticClass:"post-body"},[e("h5",{attrs:{id:"一、前端性能监测方案"}},[e("a",{staticClass:"headerlink",attrs:{href:"#一、前端性能监测方案",title:"一、前端性能监测方案"}}),t._v("一、前端性能监测方案\n      ")]),e("p",[e("strong",[t._v("性能监测：")])]),e("ol",[e("li",[e("p",[e("strong",[t._v("chrome 的 performance：")]),e("br"),t._v("DNS 查询耗时\n            ：domainLookupEnd - domainLookupStart"),e("br"),t._v("TCP 链接耗时\n            ：connectEnd - connectStart\n          ")]),e("p",[t._v("\n            request 请求耗时 ：responseEnd - responseStart"),e("br"),t._v("解析 dom\n            树耗时 ： domComplete - domInteractive"),e("br"),t._v("白屏时间\n            ：responseStart - navigationStart"),e("br"),t._v("domready\n            时间(用户可操作时间节点) ：domContentLoadedEventEnd -\n            navigationStart"),e("br"),t._v("onload 时间(总下载时间) ：loadEventEnd -\n            navigationStart"),e("br"),t._v("获取所有资源请求的时间数据,这个函数返回一个按\n            startTime 排序的对象数组 getEntries: ƒ getEntries()\n          ")])]),e("li",[e("p",[e("strong",[t._v("Google 的 Lighthouse 插件")])])]),e("li",[e("p",[e("strong",[t._v("网页性能测试分析工具-PageSpeed Insights （插件）、Page Speed\n              Online（网页）")]),e("br"),t._v("Pagespeed 测试工具出自\n            google，通过分析网页的内容来提供网站加载速度优化建议。PageSpeed\n            Insights 是一款可以分析网页打开速度的谷歌浏览器插件，通过\n            PageSpeed Insights\n            插件的分析并给出相应的优化建议，网站开发人员可以找出网站速度的瓶颈所在，并相应的网站优化，带给用户更好的用户体验。\n          ")])]),e("li",[e("p",[e("strong",[t._v("Yslow")])])]),e("li",[e("p",[e("strong",[t._v("Pingdom：")]),t._v("测试网站所有对象的加载时间（HTML，images，JavaScript，CSS，嵌入式框架等）。\n            您还可以检查网站每个元素的加载速度并改善加载缓慢的项目。\n            在测试结果中，可以看到网站每个元素的加载时间报告，元素的大小和元素的总数量。\n          ")])]),e("li",[e("p",[e("strong",[t._v("GTmetrix：")]),t._v("结合了最流行的 Firefox 性能组件 YSlow\n            的和谷歌网页速度测试工具。 Gtmetrix\n            给你提供改进网站速度的建议，虽然 YSlow\n            的和谷歌网页的速度测试的建议是针对 Firefox\n            的，也可以适用于其他浏览器。\n          ")])]),e("li",[e("p",[e("strong",[t._v("Light Speed Now")]),e("br"),t._v("测试你的网站的速度性能，并把测试报告发送给到你的邮箱。\n          ")])]),e("li",[e("p",[e("strong",[t._v("Load Impact")]),e("br"),t._v("Loadimpact\n            对于一个每天有成千上万的游客访问的大型网站来说是个非常重要的工具。\n            一个免费帐户允许你模拟 50\n            个用户访问的压力测试，还要更多的话你就必须升级高级账号。\n          ")])]),e("li",[e("p",[e("strong",[t._v("Site-Perf")]),e("br"),t._v("它模拟浏览器下载图片，CSS，JS\n            和其他文件，在报告中你可以看到先加载网站的哪些页以及加载时间。\n            这是十分有用的性能报告，可以用来查找到提高你的网站的载入速度需要改善的元素。\n          ")])])]),e("h5",{attrs:{id:"二、前端单元测试和持续集成"}},[e("a",{staticClass:"headerlink",attrs:{href:"#二、前端单元测试和持续集成",title:"二、前端单元测试和持续集成"}}),t._v("二、前端单元测试和持续集成\n      ")]),e("p",[t._v("一个测试体系大体应该包含四部分")]),e("ul",[e("li",[t._v("测试运行器 Test Runner: edp-test karma")]),e("li",[t._v("测试框架 Testing Framework: jasmine mocha qunit Jest")]),e("li",[t._v("断言库 Assertion library: expect.js should chai")]),e("li",[t._v("覆盖率 Coverage library: istanbul")])]),e("p",[e("strong",[t._v("Mocha/Karma+Travis.CI 的前端测试工作流")])]),e("ol",[e("li",[e("strong",[t._v("mocha")]),t._v("\n          是一个功能丰富的前端测试框架。所谓”测试框架”，就是运行测试的工具。通过它，可以为\n          JavaScript 应用添加测试，从而保证代码的质量。mocha 既可以基于\n          Node.js 环境运行\n          也可以在浏览器环境运行。欲了解更多可去官方网站进行学习。\n        ")]),e("li",[e("strong",[t._v("Karma")]),t._v("：一个基于 Node.js 的 JavaScript\n          测试执行过程管理工具（Test Runner）。该工具可用于测试所有主流 Web\n          浏览器，也可集成到 CI（Continuous\n          integration）工具，也可和其他代码编辑器一起使用。这个测试工具的一个强大特性就是，它可以监控文件的变化，然后自行执行，通过\n          console.log 显示测试结果。Karma\n          的一个强大特性就是，它可以监控一套文件的变换，并立即开始测试已保存的文件，用户无需离开文本编辑器。测试结果通常显示在命令行中，而非代码编辑器。这也就让\n          Karma 基本可以和任何 JS 编辑器一起使用。\n        ")]),e("li",[e("strong",[t._v("Travis.CI:")]),t._v(" 提供的是持续集成服务（Continuous\n          Integration，简称 CI）。它绑定 Github\n          上面的项目，只要有新的代码，就会自动抓取。然后，提供一个运行环境，执行测试，完成构建，还能部署到服务器。\n        ")])])]),e("footer",{staticClass:"post-footer"},[e("div",{staticClass:"post-tags"}),e("div",{staticClass:"post-nav"},[e("div",{staticClass:"post-nav-next post-nav-item"},[e("i",{staticClass:"fa fa-chevron-left"}),e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/11/03/5dbe6b5ecbdd4/",rel:"next"}},[t._v("Hexo")])]),e("div",{staticClass:"post-nav-prev post-nav-item"},[e("a",{attrs:{href:"https://www.dazhuanlan.com/2019/11/03/5dbe6b271cc66/",rel:"prev"}},[t._v("源码看JAVA【二十九】AtomicLong")]),e("i",{staticClass:"fa fa-chevron-right"})])])]),e("div",{attrs:{id:"crp_related"}})])])}],No={},Io=No,Do=Object(v["a"])(Io,Mo,Ao,!1,null,"976bfb52",null),zo=Do.exports,$o=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{},[e("q-markdown",{attrs:{src:t.MainComponent}})],1)},Ro=[],Jo='# 算法\n\n## 什么是时间复杂度\n\n### （1）语句频度\n\n- 算法就是你解决问题的方法，而你用这个方法解决这个问题所执行的语句次数，称为语句频度或者时间频度，记为T(n)。\n- 在上面提到的时间频度T(n)中，n是指算法的规模，n不断的变化，T(n)就会不断的变化，而这些变化的规律是怎样的呢？于是我们引入了时间复杂度的概念。\n\n### （2）时间复杂度\n\n- 算法中某个函数有n次基本操作重复执行，用T(n)表示，现在有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。通俗一点讲，其实所谓的时间复杂度，就是找了一个同样曲线类型的函数f(n)来表示这个算法的在n不断变大时的趋势 。当输入量n逐渐加大时，时间复杂性的极限情形称为算法的“渐近时间复杂性”。 \n\n### （3）大O记法\n\n- 在这种描述中使用的基本参数是 n，即问题实例的规模，把复杂性或运行时间表达为n的函数。这里的“O”表示量级 (order)，比如说“二分检索是 O(logn)的”,也就是说它需要“通过logn量级的步骤去检索一个规模为n的数组”记法 O ( f(n) )表示当 n增大时，运行时间至多将以正比于 f(n)的速度增长。 \n\n### （4）简单算法的时间复杂度举例\n\n- O(1)的算法是一些运算次数为常数的算法。\n\n\t- 例如：temp=a;a=b;b=temp;\n\t- 上面语句共三条操作，单条操作的频度为1，即使他有成千上万条操作，也只是个较大常数，这一类的时间复杂度为O(1)。\n\n- O(n)的算法是一些线性算法。\n\n\t- sum=0；                 \nfor(i=0;i<n;i++)       \nsum++；\n\t- 上面代码中第一行频度1，第二行频度为n，第三行频度为n，所以f(n)=n+n+1=2n+1。所以时间复杂度O(n)。这一类算法中操作次数和n正比线性增长。\n\n- O(logn) 一个算法如果能在每个步骤去掉一半数据元素，如二分检索，通常它就取 O(logn)时间。\n\n\t- int i=1; \nwhile (i<=n) \ni=i*2; \n\t- 上面代码设第三行的频度是f(n),   则：2的f(n)次方<=n;f(n)<=log₂n，取最大值f(n)= log₂n，所以T(n)=O(log₂n ) 。\n\n- O(n²)（n的k次方的情况）最常见的就是平时的对数组进行排序的各种简单算法都是O(n²)，例如直接插入排序的算法。而像矩阵相乘算法运算则是O(n³)。\n\n\t- sum=0；                \nfor(i=0;i<n;i++)  \n  for(j=0;j<n;j++) \n    sum++；\n\t- 第一行频度1，第二行n，第三行n²，第四行n²，T(n)=2n²+n+1 =O(n²)\n\n- O(2的n次方) 比如求具有n个元素集合的所有子集的算法 \n- O(n!) 比如求具有N个元素的全排列的算法\n\n### （5）时间复杂度按n越大算法越复杂来排\n\n- 常数阶O(1)、对数阶O(logn)、线性阶O(n)、线性对数阶O(nlogn)、平方阶O(n²)、立方阶O(n³)、……k次方阶O(n的k次方)、指数阶O(2的n次方)。\n\n### （6）最坏情况的时间和期望时间\n\n- 比如说快速排序，最坏情况运行时间是 O(n²)，但期望时间是O(nlogn)。但是我们只要通过一些手段，可以避免最坏情况发生，所以在实际情况中，精心设计的快速排序都能以期望时间运行。\n\n## 【栈，队列，链表】用JavaScript实现\n\n### 栈\n\n- 栈的特点是只能在某一端添加或删除数据，遵循先进后出的原则\n- 实现\n\n### 队列\n\n- 队列一个线性结构，特点是在某一端添加数据，在另一端删除数据，遵循先进先出的原则。\n- 实现\n\n\t- 单链队列\n\n\t- 循环队列\n\n\t\t- 因为单链队列在出队操作的时候需要 O(n) 的时间复杂度，所以引入了循环队列。循环队列的出队操作平均是 O(1) 的时间复杂度。\n### 链表\n\n- 头节点\n\n- 插入节点\n\n- 删除节点\n\n- 链表的设计（简易版）\n\n\t- 单向链表\n\n\t\t- 我们设计链表包含两个类，一个是 Node 类用来表示节点，另一个事 LinkedList 类提供插入节点、删除节点等一些操作。\n\t\t- Node类\n\n\t\t\t- Node类包含两个属性： element 用来保存节点上的数据，next 用来保存指向下一个节点的链接\n\t\t- LinkedList类\n\n\t\t\t- LinkedList类提供了对链表进行操作的方法，包括插入删除节点，查找给定的值等。值得注意的是，它只有一个 属性，那就是使用一个 Node 对象来保存该链表的头节点。\n\t\t- 具体方法的实现\n\n\t\t\t- find：查找给定节点\n\n\t\t\t- insert：向链表插入一个节点\n\n\t\t\t- display：显示链表\n\n\t\t\t- remove：从链表中删除一个节点\n\n\t\t\t\t- 从链表中删除节点时，我们先要找个待删除节点的前一个节点，找到后，我们修改它的 next 属性，使其不在指向待删除的节点，而是待删除节点的下一个节点。那么，我们就得需要定义一个 findPrevious 方法遍历链表，检查每一个节点的下一个节点是否存储待删除的数据。如果找到，返回该节点，这样就可以修改它的 next 属性了。 \n\t- 双向链表\n\n\t- 循环链表\n\n\t\t- 循环链表和单链表相似，节点类型都是一样，唯一的区别是，在创建循环链表的时候，让其头节点的 next 属性执行它本身，即，head.next = head;\n\t\t- 这种行为会导致链表中每个节点的 next 属性都指向链表的头节点，换句话说，也就是链表的尾节点指向了头节点，形成了一个循环链表\n## 【排序算法】优雅的 JAVASCRIPT 排序算法（ES6）\n\n### 总结\n\n- 名词解释\n\n\t- n: 数据规模\n\t- k:“桶”的个数\n\t- In-place: 占用常数内存，不占用额外内存\n\t- Out-place: 占用额外内存\n\t- 稳定性：排序后2个相等键值的顺序和排序之前它们的顺序相同\n\n\t\t- 1、堆排序、快速排序、希尔排序、直接选择排序不是稳定的排序算法；\n\t\t- 2、基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法。\n\t\t- 稳定排序在给定相同输入时具有确定性输出，这对于调试和测试可能很重要。\n\n### 冒泡排序（Bubble Sort）\n\n- 须知\n\n\t- 还有一种优化算法，就是立一个flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。\n\n- 工作原理\n\n\t- （1）比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n\t- （2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n\t- （3）针对所有的元素重复以上的步骤，除了最后一个。\n\t- （4）持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n\n- 什么时候最快（Best Cases）：\n\n\t- 当输入的数据已经是正序时\n\n- 什么时候最慢（Worst Cases）：\n\n\t- 当输入的数据是反序时\n\n- JavaScript代码\n\n### 选择排序（Selection Sort）\n\n- 须知\n\n\t- 在时间复杂度上表现最稳定的排序算法之一，因为无论什么数据进去都是O(n²)的时间复杂度。。。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。\n\n- 工作原理\n\n\t- 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n\n- JavaScript代码\n\n### 插入排序（Insertion Sort）\n\n- 须知\n\n\t- 插入排序的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。\n\t- 插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。\n\n- 工作原理\n\n\t- （1）从第一个元素开始，该元素可以认为已经被排序\n\t- （2）取出下一个元素，在已经排序的元素序列中从后向前扫描\n\t- （3）如果该元素（已排序）大于新元素，将该元素移到下一位置\n\t- （4）重复步骤3，直到找到已排序的元素小于或者等于新元素的位置\n\t- （5）将新元素插入到该位置后\n\t- （6）重复步骤2~5\n\n- JavaScript代码\n\n### 快速排序（Quick Sort）\n\n- 须知\n\n\t- 又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。\n\n- 原理\n\n\t- （1）在数据集之中，选择一个元素作为"基准"（pivot）。\n\t- （2）所有小于"基准"的元素，都移到"基准"的左边；所有大于"基准"的元素，都移到"基准"的右边。\n\t- （3）对"基准"左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。\n\t- 理解此版本的核心函数（分区并返回基准下标的函数）\n\n\t\t- 即除首项（left先做基准值）后面的所有项依次与首项基准值作比较，注意如果不大于基准值的话，i会持续增加，而index不会，所以找到比基准值小的项时，就让它的位置i与之前记录的index（此时index为最早发现的大于基准值的下标）交换，以此操作遍历完数组，最后在将，基准值与大小区分界的小数交换，即可完成分区\n\n- JavaScript代码\n\n*XMind: ZEN - Trial Version*',Lo={data:function(){return{MainComponent:Jo}}},Ho=Lo,qo=Object(v["a"])(Ho,$o,Ro,!1,null,"3ccf625c",null),Fo=qo.exports,Wo=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{},[e("q-markdown",{attrs:{src:t.MainComponent}})],1)},Bo=[],Uo="# 调试\n\n## 调试9法\n\n### 1、理解系统\n\n- 阅读手册\n\n\t- 除草机温度过高，未通读手册\n\n- 逐字逐句阅读 整个手册\n\n\t- 因为有的关键信息正好可能被你遗漏了\n\n- 查阅手册\n\n\t- 有些东西不要凭自己的记忆，要翻阅资料进行确认\n\n- 知道什么是正常的\n\n\t- 知道什么是正常的 会帮助你注意什么不是正常的   还有基础知识很关键，手册是假定你知道某些基础知识的\n\n- 知道工作流程\n\n\t- 知道系统的整个架构及各个模块或环节的工作流程\n\n- 了解你的工具，包括工具的局限性\n\n\t- 调试工具\n\t- 开发工具\n\t- 编译器和链接器等\n\n### 2、制造失败\n\n- 原因\n\n\t- 可以观察失败时的具体情况\n\t- 可以专心查找原因，准确地知道问题在什么条件下发生\n\n\t\t- 应从各个因素考虑\n\n\t- 可以判断bug是否已经被修复\n\n- 注意点\n\n\t- 从头开始\n\n\t\t- 因为有的bug 仅仅在某个复杂的状态下才发生，因此必须仔细注意机器在执行各个步骤时的状态\n\n\t- 不要模拟失败（也就是模拟失败机理本身，如书中写的保存文档丢失图片的例子），而是引发失败（也就是模拟发生失败的条件，如放大效果法---书中提到的窗户喷水 或者自动化(过程/测试)法---书中提到的自动移动仪器的例子）\n\t- 在引发失败时不要画蛇添足\n\t- 不要 轻易说出“那不可能发生”\n\n\t\t- 汽车启动 和冰淇淋的例子\n\n\t- 永远不要丢掉调试（测试）工具\n\n- 如何处理间歇性bug\n\n\t- 出现间歇性bug的原因\n\n\t\t- 存在你没注意到或者无法控制的因素，如初始条件、输入数据等（没完全弄清楚失败是如何发生的，不知道完整的、准确的条件）\n\t\t- 测试者是否清醒\n\n\t- 找到那些你没有注意到或者不可控的可能的影响因子，并大量测试这些影响因子的不同状态或条件\n\t- （1、查找不受你控制的条件；2、记录每一件事情，并找到间歇性bug的特征）\n\n- 如果做了所有尝试，间歇性bug还存在\n\n\t- 仔细观察失败\n\t- 不要盲目的相信统计数据\n\t- 是bug已经修复了 还是运气好导致它暂时没有发生\n\n### 3、不要想（猜测），而要看\n\n- 观察失败\n\n\t- 一定要亲眼看到bug发生的实际情况，而不是靠猜测，观察往往比猜测更快的找到答案；猜测虽然看起来是个捷径，但它不会带你找到问题的根源\n\n\t\t- 楼栋管理员把插座拔掉的例子\n\t\t- 换新水泵的例子\n\n- 查看细节\n\n\t- 一直观察，直到把问题的原因锁定在几种可能性之内\n\n- 问题忽隐忽现\n\n\t- 在调试间歇性bug时，观察底层的失败细节有一个好处就是 看到底层的失败细节后，当你认为已修复bug时，很容易证明确实已修复，你不必依靠统计数据就可以看到错误不再发生。\n\n- 对系统进行插装\n\n\t- 设计插装工具（测试点）\n\n\t\t- 调试模式编译的情况下\n\n\t\t\t- 源代码调试器来观察程序的运行\n\n\t\t- 发布模式编译的情况下\n\n\t\t\t- 在性能监视器中输入各种有意义的变量，以便在运行时观察它们\n\n\t- 过后构建插装\n\t- 不要害怕深入研究\n\t- 添加外部插装\n\t- 日常生活中的插装\n\n\t\t- 体温计\n\t\t- X光透视\n\t\t- 水温计、压力计\n\n- 海森堡 测不准原理\n\n\t- 测量一个粒子的位置和测量它向哪个位置运动，这两者当中有一个测量得越精确，另一个就越测不准\n\t- 不要让仪器影响了系统\n\n- 猜测只是为了确定搜索的重点目标\n\n\t- 不要想，而要看并不是真的意味着不能做任何猜想\n\t- 不要过分相信你的猜测，它们往往偏离了方向\n\t- 例外的情况：如果某些问题比其他问题更容易出现（出现的概率大）或者比其他问题更易于修复，则应该首先检查这些问题；（易发生且易修复，则可以直接尝试修复它，而不需要真正看到失败的细节）\n\n\t\t- 灯不亮的例子\n\n\t\t\t- 灯或者开关坏了\n\n\t\t- 电热水器的例子\n\n\t\t\t- 内部保险丝或者跳闸了\n\n### 4、分而治之\n\n- 缩小搜索范围\n\n\t- 确定范围\n\t- 确定你位于bug的哪一侧\n\n\t\t- 如果你所在的位置有排放物。则排放管就在上游，如果没有，则在下游\n\n- 插入易于识别的模式\n\n\t- 从干净、清澈的水开始，以便当排放物进入河流中时很容易看到它\n\n- 从有问题的分支开始查找问题\n\n\t- 如果从正确的部分开始验证，那么需要验证的地方太多了\n\n- 修复已知的bug\n\n\t- bug相互保护，相互隐藏\n\n- 首先消除噪音干扰\n\n### 5、一次只改一个地方\n\n- 使用步枪而不是用散弹枪（控制变量法）\n- 用双手抓住黄铜杆（核潜艇）\n\n\t- 如果不清楚具体发生了什么问题就试图修复bug，会很危险！\n\n- 一次只改变一个测试\n\n\t- 如果所做的更改没有起到预期作用 应该把它改回去（  汽车不启动的例子--N档 P档 钥匙没有转到位 ）\n\n- 与正常系统进行对比\n- 确定自从上次正常工作以来你改变了什么\n\n\t- 不一定是最近一次的修改导致的，有可能很早就影响了\n\t- 唱片机 唱头的例子\n\n### 6、跟踪记录(保持审计跟踪)\n\n- 记下你的每次操作、顺序和结果\n\n\t- 要描述的非常清楚，以实物过敏为例，什么时候吃了什么有什么反应等\n\n- 魔鬼隐藏在细节中\n\n\t- 没穿鞋子 感到电击 的例子\n\t- 视频压缩芯片崩溃是由于格子寸衫造成的例子\n\n- 把事件关联到一起\n\n\t- 将某些症状与其他症状或调试信息关联起来是非常有用的\n\n- 用于设计的 审计跟踪（指源代码版本管理工具） 在测试中也非常有用\n- 好记性不如烂笔头\n\n### 7、检查是否犯了哪些低级错误 (检查插头)\n\n- 怀疑自己的假设\n\n\t- 通常，问题发生在较低的层次上，也就是你可能犯了低级错误，如汽车启动不了 可能是没油了，而不是化油器的问题\n\n- 从头开始检查\n\n\t- 如 使用除草机之前，你是否按了3次primer\n\n- 对工具进行测试\n\n\t- 编译器是否是二进制的例子\n\t- 燃料油表是否被粘住了的例子\n\n### 8、 求助( 获取全新观点)\n\n- 寻求帮助\n\n\t- 获得全新观点\n\n\t\t- 有时候向别人解释问题也会使你有全新的认识，因为对事件进行组织的过程迫使你跳出你原来的思维模式（（这里有点类似 小黄鸭调试法））\n\n\t- 询问专家\n\t- 听取别人的经验\n\n\t\t- 刹车灯保险丝断掉 跟车顶灯线露出的例子\n\t\t- 维修机器，敲击方法的例子\n\n- 到哪里寻求帮助\n\n\t- 同事\n\t- 供应商\n\t- 网络\n\t- 书店\n\n- 放下面子\n\n\t- 专家也可能出错\n\t- 以除掉bug为自豪，而不要非得以自己除掉bug才为自豪\n\n- 报名症状而不是理论\n\n\t- 不要把理论告诉帮助你的人而是现象，否则他可能被你拉到你的思维定势中，导致有些关键的细节被忽略了\n\n- 把症状的每个细节也描述清楚并别遗漏了\n- 让帮助你的人复现bug\n- 即使不十分肯定也可以提出来\n\n### 9、如果你不修复bug，它将依然存在\n\n- 检查问题确实已经被修复\n\n\t- 汽车低档位熄火的例子---原因是滤油器而不是线路问题\n\n- 检查确实是修复措施解决了问题\n\n\t- 检查方法是 你修复了问题后，取消这个修复，看bug是否再现，如果再现了，再把修复加上，再次验证问题是否已被修复\n\n- bug从来不会自己消失\n- 从根本上解决问题\n\n\t- 收音机变压器的例子\n\n- 对过程进行修复\n\n\t- 不要只是擦掉地上的油，而是要纠正设计机器的方式（四个螺钉而不是两个）\n\n*XMind: ZEN - Trial Version*",Go={data:function(){return{MainComponent:Uo}}},Vo=Go,Xo=Object(v["a"])(Vo,Wo,Bo,!1,null,"0de4db0e",null),Qo=Xo.exports,Yo=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{},[e("q-markdown",{attrs:{src:t.MainComponent}})],1)},Ko=[],Zo='# 性能\n\n## 程序性能\n\n### Web Worker\n\n- JavaScript 当前并没有任何支持多线程执行的功能。\n- 程序中每一个这样的独立的多线程部分被称为一个（Web）Worker\n- Worker 之间以及它们和主程序之间，不会共享任何作用域或资源\n- 专用 Worker 和创建它的程序之间是一对一的关系，通过 meaasge 通信\n- 在 Worker 内部是无法访问主程序的任何资源的\n- 以执行网络操 作（Ajax、WebSockets）以及设定定时 器\n- 可以访问几个重要的全局变量和功能的本地复 本\n- 需要在线程之间通过事件机制传递大量的信息，可能是双向的\n- SharedWorker 可以共享的中心 worker\n- 在共享 Worker 内部，必须要处理额外的一个事件："connect"\n\n### 　SIMD\n\n- 单指令多数据（SIMD）是一种数据并行 （data parallelism）方式\n- SIMD JavaScript 计划向 JavaScript 代码暴露短向量类型和 API\n\n### asm.js\n\n- asm.js（http://asmjs.org ）这个标签是指 JavaScript 语言中可以高度优化的一个子集。\n- 现有的程序可以从asm.js 风格的优化得益而无需特意做什么\n- 关于 asm.js 优化，首先要理解的是类型和强制类型转换\n- var a= 42；var b = a | 0;\n- 对 JavaScript 性能影响最大的因素是内存分配、垃圾收集和作用域访问。\n- 对特定的任务处理提供一种优化方法，比如数学运算\n\n## 性能测试与调优\n\n### 性能测试\n\n- 简单的数学平均值绝对不足以对你要外推到整个应用范围的性能作出判断\n- 一个统计学上有效的性能测试工具，名为 Benchmark.js\n\n### 　环境为王\n\n- 现代引擎要比我们凭直觉进行的推导复杂得多\n- 引擎可能不会优化这样无关紧要的代码，但是在系统已经在运行更复杂的程序时可能会\n- 倾向于激进的优化。\n\n### jsPerf.com\n\n- 交叉引用多个浏览器上的测试运行结果\n- 测试结果就会被收集并持久化，累积的测试结果会被图形化\n\n### 写好测试\n\n- 要写好测试，需要认真分析和思考两个测试用例之间有什么区别，以及这些区别是有意 还是无意 的\n- 编写更好更清晰的测试\n- 不要试图窄化到真实代码的微小片段\n\n### 微性能\n\n- 有时候编译器可能会决定执行与你所写的不同的代码，不只是顺序不同，实际内容也会不同\n- 花费在优化关键路径上的时间不是浪费，不管节省的时间多么少\n- 而花在非关键路径优化上的时间都不值得，不管节省的时间多么多\n\n### 尾调用优化\n\n- 尾调用就是一个出现在另一个函数“结尾”处的函数调用\n- 调用一个新的函数需要额外的一块预留内存来管理调用栈，称为栈帧，尾部调用可以使用上一个函数的栈帧\n- 有了 TCO，尾调用的递归函数本质上就可以任意运行，因为再也不需要使用额外的内存！\n\n## JavaScript性能\n\n### 脚本阻塞\n\n- 减少JavaScript文件大小并限制HTTP请求数量\n- 将外链JavaScript放置页面底部加载\n- defer: 本元素所含的脚本不会修改,因此代码能安全地延迟执行，页面加载完成后执行\n- async：下载完成后自动执行，采用并行下载，下载过程中不会发生阻塞（同defer）\n- 动态脚本加载：操作DOM添加 script，所有的外链都是非阻塞加载，且加载完后会立即执行（FireFox和Opera会等所有动态脚本元素加载完后再执行）\n- IE中的script标签加载生命周期,只需监测带星号的状态\n\n\t- uninitialized\n\t- loading\n\t- loaded(*)\n\t- interactive\n\t- complete(*)\n\n### 数据存取\n\n- 作用域\n\n\t- 全局作用域\n\t- 局部作用域\n\n\t\t- 函数作用域\n\n\t\t\t- 创建函数时，它的作用域链插入了一个对象变量，这个对象变量包含该作用域下声明的所有的变量\n\t\t\t- 执行函数时，创建一个执行环境（执行上下文），执行结束执行环境就被销毁。（call stack）\n\n\t\t- 块状语句\n\n\t- 作用域链\n\n\t\t- 每个执行环境都有自己的作用域链，用解析标识符，如果当前作用域没有该标识符，则在上一级作用域查询，直到全局作用域。查询结束后，会创建一个活动对象（作为函数运行时的变量对象，然后此对象被推入作用域链最前端；执行环境被销毁，活动对象也随之销毁），正是这个查询过程影响了性能。\n\n\t- 改变作用域链\n\n\t\t- try...catch\n\n\t\t\t- catch语句会把错误对象推入作用域链最前端\n\n\t\t- with\n\n\t\t\t- 创建一个新的变量对象并将其推入作用域链最前端\n\n\t\t- eval\n\n\t\t\t- 动态作用域\n\n- 闭包\n\n\t- 闭包的[[scope]]属性包含了与执行环境作用域链相同的对象引用。函数的活动对象会随着执行环境一起销毁，但引入闭包后，由于引用仍然存在于闭包的[[scope]]属性中，所以此活动对象无法被销毁。\n\n- 原型\n\n\t- 原型、原型链可参照作用域链，表现和原理极其类似。\n\n### 算法和流程控制\n\n- 循环\n\n\t- 过程式\n\n\t\t- for in（也会遍历原型属性，bad）\n\t\t- for\n\t\t- while\n\t\t- do while\n\t\t- for of（ES6）\n\n\t- 基于函数的迭代普遍慢于过程式迭代\n\t- 避免for in，减少每次迭代处理的事务，减少迭代的次数\n\n- 条件语句和查找表\n\n\t- 根据场景需要，选择合适的方案。通常switch优于ifelsel，当判断条件很多时，使用查找表更优。\n\n- 递归和迭代\n\n\t- 大多数浏览器有调用栈限制，考虑用迭代替代一些递归\n\t- 缓存前一个计算结果供后续计算使用\n\n### 管理JavaScript运行时间\n\n- 浏览器UI线程（单线程）\n\n\t- 执行JavaScript代码\n\t- 更新用户界面（重排重绘）\n\n- 定时器\n\n\t- 用定时器将执行JavaScript代码的时间让给浏览器更新UI，然后再执行JavaScript代码\n\t- 注意事项\n\n\t\t- 设置的时间只是说明，在那个时间后 定时器绑定的事件才加入任务队列，并非是执行该事件。\n\n\t- 将耗时长的任务分割为一堆子任务\n\n- Web Workers\n\n\t- 未绑定UI线程，所以可在UI线程外执行特定的代码\n\t- 通过postMessage message来进行页面与Web Workers的通信\n\n- 注意事项\n\n\t- JavaScript脚本运行时间不应超过100ms\n\n### 事件循环\n\n- https://geniusfunny.github.io/2018/06/27/event-loop/\n\n### Ajax\n\n- 数据传输\n\n\t- 请求数据\n\n\t\t- 动态脚本注入\n\t\t- XMLHttpRequest\n\t\t- Multipart XHR\n\n\t\t\t- 无法缓存\n\t\t\t- 通过readystate为3来进行XHR流式处理\n\n\t- 发送数据\n\n\t\t- XHR\n\t\t- 信标（Beancons）\n\n- 数据格式\n\n\t- XML\n\t- Xpath\n\t- JSON\n\t- JSON-P\n\t- HTML\n\t- 自定义格式\n\n- 性能指南\n\n\t- 数据缓存\n\n\t\t- 设置HTTP头信息\n\t\t- 本地数据存储\n\n### 编程实践\n\n- 双重求值\n\n\t- 在程序中提取一个包含代码的字符串，然后动态执行它。\n\n- 使用Object/Array直接量\n- 延迟加载\n\n\t- 当一个函数在页面不会立刻调用时\n\n- 条件预加载\n\n\t- 当一个函数马上就要用到并且整个页面周期中频繁出现\n\n- 使用语言中快速的一部分\n\n\t- 位操作\n\t- 原生方法\n\n###  构建及部署\n\n- 合并多个JavaScript文件以减少HTTP请求\n- JavaScript压缩（剥离与运行无关的代码）\n- 在服务器端压缩JavaScript文件（Gzip）\n- 设置HTTP响应头来缓存JavaScript文件（协商缓存、强制缓存）\n- 使用CDN（内容分发网络）提供JavaScript文件\n\n## 前端性能指南\n\n### 减少HTTP请求\n\n- 图片\n\n\t- 图片地图（合并图片，一张图片上关联多个url，目标url取决于用户点击图片位置，常见于导航栏）\n\t- CSS Sprites（合并图片，然后使用background-position将HTML元素放到背景图片中期望的位置）\n\t- 内联图片（data:URL，有大小限制且比转化后比占据空间比原图大1/3，内联在页面时不会被缓存，但可缓存在样式表内部）\n\n- 合并脚本和样式表\n\n\t- 多个脚本合并为1个脚本，多个样式表合并为1个样式表\n\n### 使用内容分发网络（CDN）\n\n- CDN是一组分布在多个不同地理位置的Web服务器\n- 就近访问、全局负载均衡流量\n- 其目的是通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络"边缘"，使用户可以就近取得所需的内容，解决Internet网络拥塞状况，提高用户访问网站的响应速度。\n\n### 使用浏览器缓存(Cache-Control/Expires)\n\n### 压缩\n\n- Accept-Encoding: gzip, deflate\n- 考虑代理缓存及浏览器压缩支持\n\n### 将样式表放置顶部\n\n- 在样式表还在加载中时，浏览器不会构建呈现树。（详情见页面构建流程）\n\n### 将脚本放在底部\n\n- HTTP1.1规范建议一个主机名只能并行下载2个资源（除脚本），所以将资源分布到多个主机名（建议2个，更多的并行下载会消耗更多的CPU、网络）。\n- 脚本可能会使用document.write等方法修改页面内容，所以浏览器会等待，确保页面能够适当的布局。\n\n### 避免CSS表达式\n\n### 使用外部JavaScript和CSS\n\n- 外部JavaScript和CSS可以被浏览器缓存\n- 左右因素：页面浏览量、空缓存vs完整缓存、组件重用\n- 加载后下载：页面加载后，通过创建对应的DOM元素并赋予指定的URL来实现\n- 动态内联：通过cookie来反馈浏览器中的缓存给服务端，供其智能匹配内联/外部\n\n### 通过使用Keep-Alive和较少的域名来减少DNS查询\n\n### 精简JavaScript代码（删除空白字符、注释）、混淆JavaScript代码（除此之外会修改原代码）\n\n### 避免重定向（redirect会阻塞所有请求）\n\n### 去除重复的JavaScript脚本\n\n## 只有10%～20%的最终用户响应时间花在接受所请求的HTML文档上，剩余80%～90%的时间花在为HTML文档所引用的所有组件（图片、脚本、样式表、Flash等）\n\n*XMind: ZEN - Trial Version*',tl={data:function(){return{MainComponent:Zo}}},nl=tl,el=Object(v["a"])(nl,Yo,Ko,!1,null,"da28672c",null),al=el.exports,rl=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{},[e("q-markdown",{attrs:{src:t.MainComponent}})],1)},sl=[],ol="## 现代前端技术解析\n\n### 前端与协议\n\n- HTTP协议\n- 前端实时协议\n\n\t- WebSocket通信机制\n\t- Poll(轮询)和Long-poll(长轮询)\n\n\t\t- Poll即浏览器采用定时向服务器发送请求轮询的方法不断发送或拉取消息。\n\t\t- HTTP请求可以设置一个较长的Timeout等待时间，这样网络轮询请求就可以维持一段较长的时间后返回结果，这也就是Long-poll（长轮询）的基本思路。服务器只要在这段长轮询时间内进行响应，请求便会立即返回结果；如果这段时间服务器没有返回，浏览器端将自动响应超时并重新发起一个长轮询请求。\n\n\t- 前端DDP协议\n\n\t\t- DDP（Distributed Data Protocol，分布式数据协议）是一种新型的客户端与服务器端的实时通信协议，由于兼容性的原因，目前使用还不广泛。\n\n- RESTful数据协议规范\n\n\t- REST（Representational State Transfer，表述性状态转化）并不是某一种具体的协议，而是定义了一种网络应用软件之间的架构关系并提出了一套与之对应的网络之间交互调用的规则。\n\t- 换种方式理解，RESTful是一种软件架构之间交互调用数据的协议风格规范，它建议以一种通用的方式来定义和管理数据交互调用接口。\n\n- 与Native交互协议\n\n### 前端三层结构与应用\n\n- HTML结构层基础\n\n\t- Web语义化标签\n\n\t\t- 用正确的标签做正确的事情。\n\t\t- HTML语义化能让页面内容更具结构化且更加清晰，便于浏览器和搜索引擎进行解析，因此在兼容条件下，要尽量使用带有语义化结构标签。\n\t\t- 即使在没有样式CSS的情况下，网页内容也应该是有序的文档格式显示，并且是容易阅读的。\n\t\t- 使项目维护人员更容易对网站进行分块，便于阅读理解。语义化的标签使用，能让开发者更容易区分标签元素中的内容\n\n\t- HTML糟糕的部分\n\n\t\t- Web语义化规范并不是在任何时候都需要严格遵守的，有时直接使用甚至会产生一些副作用。\n\n\t- AMP HTML\n\n\t\t- 流动网页提速（Accelerated Mobile Pages，AMP）是google推行的一个提升页面资源载入效率的HTML提议规范。基本思路有两点：使用严格受限的高效HTML标签以及使用静态网页缓存技术来提高网络访问静态资源的性能和用户体验。\n\n- 前端结构层演进\n\n\t- XML与HTML简述\n\n\t\t- 可扩展标记语言（Extentsible Markup Language，XML）是用来描述网络上存储数据的一种特殊文本标记格式。\n\t\t- HTML则是从SGML的基础上演化而来的另一种文本标记语言，一般用于网络上数据的展示。\n\n\t- HTML5标准\n\t- HTML Web Component\n\n- 浏览器脚本演进历史\n\n\t- CoffeeScript时代 --\x3e ECMAScript标准概述 --\x3e TypeScript概述 --\x3e JavaScript衍生脚本\n\n- JavaScript标准实践\n\n\t- ES5\n\t- ES6\n\n\t\t- let和const使用场景：模块内不变的引用和常量，一般使用const定义；可变的变量或引用使用let声明；var仅用于声明函数整个作用域内需要使用的变量。\n\t\t- 字符串模板\n\t\t- 解构赋值\n\t\t- 数组新特性\n\t\t- 函数参数\n\n\t\t\t- 默认参数\n\t\t\t- 不定参数\n\t\t\t- 扩展参数\n\n\t\t- 箭头函数\n\t\t- 增强对象\n\t\t- 类\n\t\t- 模块module\n\t\t- 循环与迭代器Iterator\n\n\t\t\t- for...of\n\t\t\t- Iterator\n\n\t\t- 生成器Generator\n\t\t- 集合类型Map+Set+WeakMap+WeakSet\n\t\t- Promise、Symbol、Proxy增强类型\n\t\t- 统一码\n\t\t- 进制数支持\n\n\t\t\t- 二进制（b）\n\t\t\t- 八进制（o）\n\n\t\t- Reflect对象和tail calls尾调用\n\n\t- ES7+\n\n\t\t- 幂指数操作符**\n\t\t- Array.prototype.includes\n\t\t- 异步函数async/await\n\t\t- SIMD\n\n\t- TypeScript\n\n\t\t- 强类型支持\n\t\t- Decorator装饰器特性\n\n- 前端表现层基础\n\n\t- CSS选择器与属性\n\n\t\t- CSS选择器\n\n\t\t\t- CSS中选择器属性优先级顺序为！important>内联样式（权重1000）> id选择器（权重100）>类选择器（权重10）>元素选择器（权重1）\n\t\t\t- 伪元素：::before，::after\n\t\t\t- 伪类：visited、:hover、:first-child、:nth-child、:enable、:checked\n\n\t\t- CSS属性\n\n\t\t\t- 布局类属性：position类、弹性布局fex、浮动float、对齐align\n\t\t\t- 几何类属性：盒模型相关（margin、padding、width、heigh、border）、box-shadow、渐变gradient、backgroud类、transform类\n\t\t\t- 文本类属性：font类、line-height、color类、text类（text-decoration、text-indent、textoverflow）、white-space、user-select、text-shawdow等\n\t\t\t- 动画类属性：以css3为主的transition、animation等\n\t\t\t- 查询类：Media query和IE Hack等\n\n- 前端界面技术\n\n\t- CSS样式统一化\n\n\t\t- reset：将不同浏览器中标签元素的默认样式全部清除，消除不同浏览器下默认样式的差异性\n\t\t- normalize：在整站样式基本确定的情况下对标签元素统一使用同一个默认样式规则\n\t\t- neat\n\n\t- css预处理\n\n\t\t- 预处理技术\n\n\t\t\t- sass\n\t\t\t- less\n\t\t\t- stylus\n\t\t\t- postCss：是一个用 JavaScript 工具和插件转换 CSS 代码的工具\n\n\t\t- 预处理工具特性\n\n\t\t\t- 变量声明和计算。方便一次赋值和随处使用，并能进行简单运算，提高开发管理效率。\n\t\t\t- 语法表达式。例如if-else条件语句、for循环等简单语法的设计能让页面CSS规则的生成更加灵活。\n\t\t\t- 函数处理。方便多次计算的地方能统一复用，例如函数处理和Mixin等特性。\n\t\t\t- 属性的继承。元素类属性的继承在开发样式相似但略微不同的多个模块的过程中非常有用，可以减少大量重复代码。\n\t\t\t- 兼容性补全。类似autoprefixer这种功能，让开发者不用过多关注不同浏览器的兼容问题，处理多个浏览器兼容性的代码能在预处理阶段自动生成补全，让一些问题的处理方式对开发者透明。\n\n\t- 表现层动画实现\n\n\t\t- JavaScript直接实现动画：其主要思想是通过JavaScript的setInterval方法或setTimeout方法的回调函数来持续调用改变某个元素的CSS样式以达到元素样式持续变化的结果\n\t\t- 可伸缩矢量图形（Scalable Vector Graphics，SVG）动画\n\t\t- CSS3 transition\n\t\t- CSS3 animation\n\t\t- Canvas动画\n\t\t- requestAnimationFrame\n\n- 响应式网站开发技术\n\n\t- 响应式页面实现概述\n\n\t\t- 实现方法\n\n\t\t\t- 通过前端或后端判断userAgent来跳转不同的页面完成不同设备浏览器的适配，也就是维护两个不同的站点来根据用户设备进行对应的跳转\n\t\t\t- 使用media query媒体查询等手段，让页面根据不同设备浏览器自动改变页面的布局和显示，但不做跳转\n\n\t- 结构层响应式\n\n\t\t- 结构层数据内容响应式：根据不同平台浏览器的情况加载不同的异步静态JavaScript，然后异步渲染不同的模块内容，生成不同的表现层结构来实现\n\t\t- 后端数据渲染响应式\n\t\t- 结构层媒体响应式\n\n\t- 表现层响应式\n\n\t\t- 响应式布局：\n\n\t\t\t- 一种是桌面端浏览器优先，扩展到移动端浏览器适配\n\t\t\t- 另一种则是以移动端浏览器优先，扩展到桌面端浏览器适配\n\n\t\t- 屏幕适配布局：在移动端解决内容按照不同屏幕大小自动等比例缩放的一种布局计算方式\n\n\t- 行为层响应式\n\n### 现代前端交互框架\n\n- 直接DOM操作时代\n\n\t- 节点查询型：getElementById、getElementsByName、getElementsByClassName、getElementsByTagName、querySelector、querySelectorAll\n\t- 节点创建型：createElement、createDocumentFragment、createTextNode、cloneNode\n\t- 节点修改型：appendChild、replaceChild、removeChild、insertBefore、innerHTML\n\t- 节点关系型：parentNode、previousSibling、childNodes\n\t- 节点属性型：innerHTML、attributes、getAttribute、setAttribute、getComputedStyle\n\t- 内容加载型：XMLHttpRequest、ActiveX\n\n- MV*交互模式\n\n\t- 前端MVC模式\n\t- 前端MVP模式\n\t- 前端MVVM模式\n\t- 数据变更检测示例\n\n\t\t- 手动触发绑定\n\t\t- 脏检测机制\n\t\t- 前端数据对象劫持(Hijacking)\n\t\t- ECMAScript 6 Proxy\n\n- Virtual DOM交互模式\n\n\t- Virtual DOM设计理念\n\t- Virtual DOM的核心实现\n\n\t\t- 创建Virtual DOM：把一段HTML字符串文本解析成一个能够描述它的JavaScript对象\n\t\t- 对比两个Virtual DOM生成差异化Virtual DOM\n\t\t- 将差异化Virtual DOM渲染到页面上\n\n- 前端MNV*时代\n\n\t- MNV*模式简介：这种使用JavaScript调用原生控件或事件绑定来生成应用程序的交互模式称为前端MNV＊开发模式\n\t- MNV*模式实现原理\n\n### 前端项目与技术实践\n\n- 前端开发规范\n- 前端组件规范\n\n\t- UI组件规范\n\n\t\t- UI层风格统一化。UI层风格统一化避免了不同页面的差异化设计风格，能让用户使用Web站点的不同网页外观风格是一致的。\n\t\t- 增加UI层复用性。使用UI规范的情况下，UI层代码复用性增强，可以提高开发效率，相同功能的结构和样式不用重复实现。\n\t\t- 更符合用户的体验习惯。例如红色按钮统一用来表示警告，绿色按钮统一表示安全或成功操作等。\n\t\t- 增加了开发规范的统一性。遵循统一的规范，避免重复开发，避免产生多种风格的代码。\n\n\t- 模块化规范\n\n\t\t- AMD（异步模块定义）：AMD是运行在浏览器端的模块化异步加载规范，主要以requireJS为代表，基本原理是定义define和require方法异步请求对应的javascript模块文件到浏览器端运行。模块执行导出时可以使用函数中的return返回结果。\n\t\t- CMD（通用模块定义）：CMD是Seajs提出的一种模块化规范，在浏览器端调用类似CommonJS的书写方式来进行模块引用，但却不是完全的CommonJS规范。\nCMD遵循按需执行依赖的原则\n\t\t- CommonJS：CommonJS是Node端使用的JavaScript模块化规范，使用require进行模块引入，并使用modules.exports来定义模块导出。\n\t\t- import/export\n\n\t- 项目组件化设计规范\n\n\t\t- Web Component组件化\n\t\t- MVVM框架组件化\n\t\t- Virtual DOM的组件化方案\n\t\t- 基于目录管理的通用组件化实践\n\n- 自动化构建\n\n\t- 自动化构建的目的：对文件进行模块化引入、依赖分析、资源合并、压缩优化、文件嵌入、路径替换、生成资源包等多种操作，这样就能完成很多原本需要手动完成的事情，极大地提高开发效率\n\t- 自动化构建原理：读取入口文件→分析模块引用→按照引用加载模块→模块文件编译处理→模块文件合并→文件优化处理→写入生成目录\n\t- 构建工具设计的问题\n\n\t\t- 模块分析引入\n\t\t- 模块化规范支持\n\t\t- CSS编译、自动合并图片\n\t\t- HTML、JavaScript、CSS资源压缩优化\n\t\t- HTML路径分析替换\n\t\t- 区分开发和上线目录环境\n\t\t- 异步文件打包方案\n\t\t- 文件目录白名单设置\n\n- 前端性能优化\n\n\t- 前端性能测试\n\t- 桌面浏览器前端优化策略\n\t- 移动端浏览器前端优化\n\n- 前端用户数据分析\n\n\t- 用户访问统计\n\t- 用户行为分析\n\t- 前端日志上报\n\t- 前端性能分析上报\n\n- 前端搜索引擎优化基础\n- 前端协作\n\n## 高效的组件化规范\n\n### 组件之间独立、松耦合。组件之间的HTML、JavaScript、CSS之间相互独立，尽量不重复，相同部分通过父级或基础组件来实现，最大限度减少重复代码。\n\n### 组件间嵌套使用。组件可以嵌套使用，但嵌套后仍然是独立、松耦合的。\n\n### 组件间通信。主要指组件之间的函数调用或通信，例如A组件完成某个操作后希望B组件执行某个行为，这种情况就可以使用监听或观察者模式在B组件中注册该行为的事件监听或加入观察者，然后选择合适的时机在A组件中触发这个事件监听或通知观察者来触发B组件中的行为操作，而不是在A组件中直接拿到B组件的引用并直接进 行操作，因为这样组件之间的行为就会产生耦合。\n\n### 组件公用部分设计。组件的公用部分应该被抽离出来形成基础库，用来增加代码的复用性。\n\n### 组件的构建打包。构建工具能够自动解析和打包组件内容。\n\n### 异步组件的加载模式。在移动端，通常考虑到页面首屏，异步的场景应用非常广泛，所有异步组件不能和同步组件一起处理。这时可以将异步组件区别于普通组件的目录存放，并在打包构建时进行异步打包处理。\n\n### 组件继承与复用性。对于类似的组件要做到基础组件复用来减少重复编码。\n\n### 私有组件的统一管理。为了提高协作效率，可以通过搭建私有源的方式来统一管理组件库，例如使用包管理工具等。但这点即使在大的团队里面也很难实施，因为业务组件的实现常常需要定制化而且经常变更，这样维护组件库成本反而更大，目前可以做的是将公用的组件模块使用私有源管理起来。\n\n### 根据特定场景进行扩展或自定义。如果当前的组件框架不能满足需求，我们应该能够很便捷地拓展新的框架和样式，这样就能适应更多的场景需求。比如在通过目录管理组件的方案下，既可以使用MVVM框架进行开发，也可以使用Virtual DOM框架进行开发，但要保持基本的规范结构不变。\n\n*XMind: ZEN - Trial Version*",ll={data:function(){return{MainComponent:ol}}},il=ll,cl=Object(v["a"])(il,rl,sl,!1,null,"40f5b21a",null),pl=cl.exports,bl=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{},[e("q-markdown",{attrs:{src:t.MainComponent}})],1)},ul=[],vl='# 安全\n\n## Web安全\n\n### XSS\n\n- 危害\n\n\t- Cookie劫持\n\t- 构造POST、GET请求\n\t- XSS钓鱼\n\t- 识别用户浏览器、识别用户安装的软件\n\t- CSS History Hack\n\t- 获取用户真实IP\n\t- XSS Worm\n\n- 构造\n\n\t- 利用字符编码\n\t- 绕过长度限制\n\t- base标签\n\t- window.name\n\n- 防御\n\n\t- HttpOnly\n\t- 输入检查\n\t- 输出检查\n\n### CSRF\n\n- 危害\n\n\t- 伪造请求\n\t- CSRF Worm\n\n- 防御\n\n\t- 验证码\n\t- Referer Check\n\t- Anti CSRF Token\n\n### ClickJacking\n\n- 危害\n\n\t- 视觉欺骗，诱导用户在该网页上操作\n\t- 图片覆盖攻击\n\t- 拖拽劫持和数据窃取\n\t- 触屏劫持\n\n- 构造\n\n\t- 调整iframe页面的位置，是用户恰好点击在iframe页面的一些功能性按钮上\n\n- 防御\n\n\t- frame busting\n\t- X-Frame-Options(优)\n\n### 注入攻击\n\n- SQL注入\n- 数据库攻击技巧\n- 正确防御SQL注入\n- 其他注入攻击\n\n### 文件上传漏洞\n\n- 一般场景\n\n\t- 上传Web脚本能够被服务器解析\n\n- 解决方案\n\n\t- 文件上传目录设置为不可执行\n\t- 判断文件类型\n\t- 使用随机数改写文件名和文件路径\n\t- 单独设置文件服务器的域名\n\n### 认证与会话\n\n### 拒绝服务攻击\n\n### 浏览器\n\n- 同源策略\n\n\t- 端口号、IP地址、子域名、协议必须相同的两个origin才为同源。\n\t- 跨域\n\n\t\t- window.name\n\t\t- jsonp\n\t\t- nginx转发\n\t\t- Node中间层\n\t\t- 配置CORS\n\t\t- websocket\n\n- Cookie策略\n\n\t- Cookie种类\n\n\t\t- Session Cookie\n\n\t\t\t- 存于浏览器进程的内存空间里（服务端不设置Expire和max-age时触发）\n\n\t\t- Third-party Cookie\n\n\t\t\t- 存于本地\n\n\t\t- 浏览器从一个域的页面加载另外一个域的资源，部分浏览器会阻止Third-party Cookie的发送\n\n### HTML5安全\n\n- 新标签、新事件可能带来新XSS攻击\n\n\t- 例如vedio的onloadedmetadata、ondurationchange等\n\n- 设置iframe的sandbox属性来增强应用使用iframe安全性\n\n\t- allow-same-origin\n\t- allow-top-navigation\n\t- allow-forms\n\t- allow-scripts\n\n- Link Type: noreferrer\n\n\t- 给link标签设置rel=\'noreferrer\'后，浏览器请求时将不再发送referrer\n\n- Canvas\n\n\t- 可以识别图片验证码\n\n- CORS\n- postMessage\n\n\t- postMessage允许每一个window对象向其他窗口发送文本消息，从而实现跨窗口的消息传递。\n\n- Web Storage\n\n## JWT(Json Web token)\n\n### （1）认识JWT\n\n- jwt是为了在网络应用环境传递声明而执行的一种基于json的开放标准。\n- jwt被用来在身份提供者和服务提供者间传递被认证的用户身份信息，简单来说，就是用来验证身份的手段，例如登录校验，像我们之前用的cookie。\n- jwt可以使用HMAC算法或者是RSA的公私秘钥对来进行签名，来保证信息的可靠性。\n\n### （2）应用场景\n\n- 在例如身份验证场景中，用户一旦登录，接下来的每个请求都会包含jwt，用来验证身份信息。由于通信双方使用jwt对数据进行编码，它的信息是经过签名的，所以可以确保信息的安全性。\n\n### （3）JWT对比cookie\n\n- Cookie缺点\n\n\t- 客户端发请求给服务器，服务器种植cookie后，每次请求都会带上cookie，浪费带宽\n\t- cookie不能跨服务器访问，不支持跨域\n\t- 服务器要对登录的用户对象进行存储，浪费服务器内存\n\n- JWT优点\n\n\t- （1）jwt是不基于状态的，不需要每次请求都带上token，节约流量\n\t- （2）可以跨服务端，可以共用\n\t- （3）体积小，因而传输速度快\n\t- （4）传输方式多样，可以通过 URL/POST 参数/HTTP 头部 等方式传输\n\t- （4）严谨的结构化。它自身（在 payload 中）就包含了所有与用户相关的验证消息，如用户可访问路由、访问有效期等信息，服务器无需再去连接数据库验证信息的有效性，并且 payload 支持为你的应用而定制化\n\t- （5）支持跨域验证，多应用于单点登录。\n\n\t\t- 单点登录（Single Sign On）：在多个应用系统中，用户只需登陆一次，就可以访问所有相互信任的应用。\n\t\t- 用户登陆之后，服务器会返回给他一个 token，由他保存在本地，在这之后的对服务器的访问都要带上这串 JWT ,来获得访问服务器相关路由、服务及资源的权限。比如单点登录就比较多地使用了 JWT，因为它的体积小，并且简单处理（使用 HTTP 头带上 Bearer 属性 + token ）就可以支持跨域操作。\n\n\t- （6）比 cookie 更支持原生移动端应用\n\n\t\t- 原生的移动应用对 cookie 与 session 的支持不够好，而对 token 的方式支持较好。\n\n\t- （7）验证解耦，无需使用特定的身份验证方案， token 可以在任何地方生成\n\n\t\t- 只要拥有生成 token 所需的验证信息，在何处都可以调用 token 生成接口，无需繁琐的耦合的验证操作，可谓是一次生成，永久使用。\n\n\t- （8）充分依赖无状态 API ，契合 RESTful 设计原则\n\n\t\t- 有状态\n\n\t\t\t- server 保存了 client 的请求状态， server 会通过 client 传递的 sessionID 在其 session 作用域内找到之前交互的信息并应答。\n\n\t\t- 无状态\n\n\t\t\t- 无状态是 RESTful 架构设计的一个非常主要的原则。无状态 API 的每一个请求都是独立的，它要求由客户端保存所有需要的认证信息，每次发请求都要带上自己的状态\n\n\t- （9）易于实现 CDN，将静态资源分布式管理\n\n\t\t- 在传统的 session 验证中，服务端必须保存 session ID，用于与用户传过来的 cookie 验证。而在一开始保存 session ID 时， 只会保存在一台服务器上，所以只能由一个 server 应答，就算其他服务器有空闲也无法应答，因此也利用不到分布式服务器的优点。\n\t\t- 而 JWT 依赖的是在客户端本地保存验证信息，不需要利用服务器保存的信息来验证，所以任意一台服务器都可以应答，服务器的资源也被较好地利用。\n\n### （4）JWT结构\n\n- Header头部\n\n\t- { typ:\'jwt\' ,alg:\'HS256\' }\n alg:当前用的什么算法加密的；使用Base64Url编码组成了JWT结构的第一部分\n\n- PlyLoad负载\n\n\t- 存放有效信息的地方\n\n- Signature签名\n\n\t- 创建签名需要使用编码后的header和payload以及一个秘钥；例如如果希望使用HMAC SHA256算法，那么签名应该使用下列方式创建\n\t- HMACSHA256( base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)\n\n- 完整的jwt格式的输出是以 . 分隔的三段Base64编码 密钥secret是保存在服务端的，服务端会根据这个密钥进行生成token和验证，所以需要保护好。\n\n### （5）例子\n\n- 流程图\n\n- 流程\n\n\t- （1）首先，拥有某网站账号的某 client 使用自己的账号密码发送 post 请求 login\n\t- （2）由于这是首次接触，server 会校验账号与密码是否合法，如果一致，则根据密钥生成一个 token 并返回\n\t- （3）client 收到这个 token 并保存在本地的 localStorage。\n\t- （4）在这之后，需要访问一个受保护的路由或资源时，而只要附加上你保存在本地的 token（通常使用 Bearer 属性放在 Header 的 Authorization 属性中），server 会检查这个 token 是否仍有效，以及其中的校验信息是否正确，再做出相应的响应。\n\n### 理解 JSON Web Tokens (JWT) 的 5 个简单步骤\n\n- JWT的定义\n\n\t- JSON Web令牌（JWT）是一种 JSON 对象（双引号字符串被认为是有效的 JSON 对象），是一套开放的标准定义的两方之间表示一组信息的安全方式。 JWT 由头部（header），负载（payload）和签名（signature）组成。\n\t- 简单地说，JWT只是一个具有以下格式的字符串：\n\n- 实际场景\n\n\t- 此示例中的三个不同的实体是用户，应用程序服务器和身份验证服务器。 验证服务器将向用户提供 JWT。 使用 JWT，用户可以安全地与应用程序通信。\n\n\t\t- 在该示例中，用户首先使用认证服务器的登录系统登录认证服务器（例如，用户名和密码，Facebook登录，Google登录等）。 然后，身份验证服务器创建 JWT并将其发送给用户。 当用户对应用程序进行 API 调用时，用户将传递 JWT 以及 API 调用。 在这个实例中，应用程序服务器将可以验证传入的 JWT 是否是由身份验证服务器创建的（验证过程将在稍后更详细地说明）。当用户使用附加的 JWT 进行API 调用时，应用程序可以使用 JWT 来验证该 API 调用是否来自经过身份验证的用户。\n\n- 构建JWT\n\n\t- Step 1. 创建 Header\n\n\t\t- JWT 的 Header 部分包含有关如何计算 JWT 签名的信息，是一个以下形式的 JSON 对象\n\n\t\t- 在上面的 JSON 中，“typ”键的值指定对象是JWT，“alg”键的值指定用于创建 JWT 签名的算法。 在示例中，我们使用 HMAC-SHA256算法（一种使用密钥的散列算法）来计算签名\n\n\t- Step 2. 创建 Payload\n\n\t\t- JWT 的 payload 部分时是存储在 JWT 内的数据。在我们的示例中，身份验证服务器创建一个JWT，其中存储有用户信息，特别是用户ID。\n\n\t\t- 在我们的示例中，我们只将一个声明放入 payload 中。 你可以根据需要添加任意数量的声明。JWT 规定了7个官方字段，供选用。\n\n\t\t\t- iss (issuer)：签发人\n\t\t\t- exp (expiration time)：过期时间\n\t\t\t- sub (subject)：主题\n\t\t\t- aud (audience)：受众\n\t\t\t- nbf (Not Before)：生效时间\n\t\t\t- iat (Issued At)：签发时间\n\t\t\t- jti (JWT ID)：编号\n\n\t\t- 除了官方字段，你还可以在这个部分定义私有字段。请记住，数据的大小将影响JWT的总体大小，这通常不是问题，但过大的 JWT 可能会对性能产生负面影响并导致延迟。\n\n\t- Step 3. 创建 Signature\n\n\t\t- 使用某算法，其所做的是 base64url 对在步骤1和2中创建的header和payload进行编码。然后，算法将得到的编码字符串用“点”（.）连在一起。\n\n\t\t- 在示例中，header 和 payload 被 base64url 编码，然后，在加入周期的编码头和编码有效载荷上应用带有密钥的指定签名算法，我们得到签名所需的散列数据。 在我们的例子中，这意味着在数据字符串上应用 HS256 算法，并将密钥设置为字符串“secret”，以获取 hashedData字符串。 之后，通过base64url 编码 hashedData 字符串\n\n\t- Step 4. 把 JWT 的三个部分组合在一起\n\n\t\t- 我们只需要组合以上的三个部分，用点（.）分隔它们。\n\n\t\t\t- // JWT Token\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ.-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM\n\n\t- Step 5. 校验 JWT\n\n\t\t- 在我们的示例中，我们使用的是由 HS256 算法签名的JWT，其中只有身份验证服务器和应用服务器知道密钥。当应用程序设置其身份验证过程时，应用程序服务器从身份验证服务器接收密钥。由于应用程序知道密钥，当用户对应用程序进行带有 JWT 附加的 API 调用时，应用程序可以执行与 JWT 上的步骤3相同的签名算法。然后，应用程序可以验证从其自己的哈希操作获得的签名是否与 JWT 本身上的签名匹配（即，它与由认证服务器创建的 JWT 签名匹配）。如果签名匹配，则表示 JWT 有效，表示 API 调用来自可信源。否则，如果签名不匹配，则表示收到的 JWT 无效，这可能是对应用程序的潜在攻击的指示。因此，通过验证 JWT，应用程序在其自身和用户之间添加了一层信任。\n\n- JWT 如何保护我们的数据？\n\n\t- 要理解使用 JWT 的目的不是以任何方式隐藏或模糊数据，而是为了证明发送的数据是由真实的来源创建的。\n\t- 由于 JWT 仅被签名和编码，并且由于 JWT 未加密，因此 JWT 不能保证敏感数据的安全性。\n\n## Web 的攻击技术\n\n### 针对 Web 的攻击技术\n\n- 简单的 HTTP 协议本身并不存在安全性问题,因此协议本身几乎不会成为攻击的对象\n- 在运作的 Web 应用背后却隐藏着各种容易被攻击者滥 用的安全漏洞的 Bug\n- 在 Web 应用中,从浏览器那接收到的 HTTP 请求的全部内容,都可以在客户端自由地变更、篡改\n- 在 HTTP 请求报文内加载攻击代码,就能发起对 Web 应用的攻击\n- 主动攻击(active attack)是指攻击者通过直接访问 Web 应用,把攻击代码传入的攻击模式\n- 被动攻击(passive attack)是指利用圈套策略执行攻击代码的攻击模式。\n\n### 因输出值转义不完全引发的安全漏洞\n\n- 跨站脚本攻击(Cross-Site Scripting,XSS)是指通过存在安全漏洞的 Web 网站注册用户的浏览器内运行非 法的 HTML 标签或 JavaScript 进行的一种攻击\n- 利用虚假输入表单骗取用户个人信息。\n- 利用脚本窃取用户的 Cookie 值, 被害者在不知情的情况下, 帮助攻击者发送恶意请求。\n- 显示伪造的文章或图片\n- 跨站脚本攻击案例\n- 在动态生成 HTML 处发生\n- 对用户 Cookie 的窃取攻击\n- SQL 注入(SQL Injection)是指针对 Web 应用使用的数据库,通过运行非法的 SQL 而产生的攻击。\n- 非法查看或篡改数据库内的数据\n- 规避认证\n- 执行和数据库服务器业务关联的程序等\n- OS 命令注入攻击(OS Command Injection)是指通过 Web 应用,执行非法的操作系统命令达到攻击的目 的\n- HTTP 首部注入攻击(HTTP Header Injection)是指攻击者通过在响应首部字段内插入换行,添加任意响应首部或主体的一种攻击。\n- 设置任何 Cookie 信息\n- 重定向至任意 URL\n- 显示任意的主体( HTTP 响应截断攻击)\n- HTTP 首部注入攻击案例\n- 邮件首部注入(Mail Header Injection)是指 Web 应用中的邮件发送功能,攻击者通过向邮件首部 To 或 Subject 内任意添加非法内容发起的攻击\n- 目录遍历(Directory Traversal)攻击是指对本无意公开的文件目录,通过非法截断其目录路径后,达成访问 目的的一种攻击\n- 远程文件包含漏洞(Remote File Inclusion)是指当部分脚本内容需要从其他文件读入时,攻击者利用指定外 部服务器的 URL充当依赖文件,让脚本读取之后,就可运行任意脚本的一种攻击\n\n### 因设置或设计上的缺陷引发的安全漏洞\n\n- 强制浏览\n\n\t- 强制浏览(Forced Browsing)安全漏洞是指,从安置在 Web 服务器的公开目录下的文件中,浏览那些原本 非自愿公开的文件\n\t- 泄露顾客的个人信息等重要情报\n\t- 泄露原本需要具有访问权限的用户才可查阅的信息内容\n\t- 泄露未外连到外界的文件\n\n- 不正确的错误消息处理\n\n\t- Web 应用不必在用户的浏览画面上展现详细的错误消息。对攻击者来说,详细的错误消息有可能给他们下一 次攻击以提示\n\n- 开放重定向\n\n\t- 开放重定向(Open Redirect)是一种对指定的任意 URL 作重定向跳转的功能。\n\n### 因会话管理疏忽引发的安全漏洞\n\n- 会话劫持(Session Hijack)是指攻击者通过某种手段拿到了用户的会话 ID,并非法使用此会话 ID 伪装成用 户,达到攻击的目的\n- 对以窃取目标会话 ID 为主动攻击手段的会话劫持而言,会话固定攻击(Session Fixation)攻击会强制用户 使用攻击者指定的会话 ID,属于被动攻击。\n- 跨站点请求伪造(Cross-Site Request Forgeries,CSRF)攻击是指攻击者通过设置好的陷阱,强制对已完 成认证的用户进行非预期的个人信息或设定信息等某些状态更新,属于被动攻击。\n\n### 其他安全漏洞\n\n- 密码破解攻击(Password Cracking)即算出密码,突破认证\n- 通过网络的密码试错\n\n\t- 穷举法\n\t- 字典攻击\n\n- 对已加密密码的破解(指攻击者入侵系统, 已获得加密或散列处理的密码数据的情况)\n- 点击劫持(Clickjacking)是指利用透明的按钮或链接做成陷阱,覆盖在 Web 页面之上。然后诱使用户在不 知情的情况下,点击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装(UI Redressing)。\n- DoS 攻击(Denial of Service attack)是一种让运行中的服务呈停止状态的攻击\n- 后门程序(Backdoor)是指开发设置的隐藏入口,可不按正常步骤使用受限功能\n\n## web安全机制\n\n### 基础安全知识\n\n- XSS(跨站脚本攻击)\n\n\t- XSS通常是由带有页面可解析内容的数据未经处理直接插入到页面上解析导致的。\n\t- 存储型XSS的攻击脚本常常是由前端提交的数据未经处理直接存储到数据库然后从数据库中读取出来后又直接插入到页面中所导致的\n\t- 反射型XSS可能是在网页URL参数中注入了可解析内容的数据而导致的，如果直接获取URL中不合法的并插入页面中则可能出现页面上的XSS攻击\n\t- MXSS（也叫DOM XSS）则是在渲染DOM属性时将攻击脚本插入DOM属性中被解析而导致的\n\t- XSS主要的防范方法是验证输入到页面上所有内容来源数据是否安全，如果可能含有脚本标签等内容则需要进行必要的转义。\n\n- SQL(结构化查询语言)注入\n\n\t- SQL注入攻击主要是因为页面提交数据到服务器端后，在服务器端未进行数据验证就将数据直接拼接到SQL语句中执行，因此产生执行与预期不同的现象。\n\t- 主要防范措施是对前端网页提交的数据内容进行严格的检查校验。\n\n- CSRF(跨站请求伪造)\n\n\t- CSRF是指非源站点按照源站点的数据请求格式提交非法数据给源站点服务器的一种攻击方法。\n\t- 非源站点在取到用户登录验证信息的情况下，可以直接对源站点的某个数据接口进行提交，如果源站点对该提交请求的数据来源未经验证，该请求可能被成功执行，这其实并不合理。通常比较安全的是通过页面Token（令牌）提交验证的方式来验证请求是否为源站点页面提交的，来阻止跨站伪请求的发生。\n\n### 请求劫持与HTTPS\n\n- DNS劫持\n\n\t- DNS劫持通常是指攻击者劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致用户对该域名地址的访问由原IP地址转入到修改后的指定IP地址的现象，其结果就是让正确的网址不能解析或被解析指向另一网站IP，实现获取用户资料或者破坏原有网站正常服务的目的。DNS劫持一般通过篡改DNS服务器上的域名解析记录，来返回给用户一个错误的DNS查询结果实现。\n\t- DNS劫持症状可能为在某些地区的用户在成功连接宽带网络后，访问域名为www.a.com的网站，出现的却是www.b.com网站的内容，因为DNS服务器www.a.com域名的解析结果被修改指向了www.b.com网站指向的IP地址。\n\n- HTTP劫持\n\n\t- HTTP劫持是指，在用户浏览器与访问的目的服务器之间所建立的网络数据传输通道中从网关或防火墙层上监视特定数据信息，当满足一定的条件时，就会在正常的数据包中插入或修改成为攻击者设计的网络数据包，目的是让用户浏览器解释“错误”的数据，或者以弹出新窗 口的形式在使用者浏览器界面上展示宣传性广告或者直接显示某块其他的内容。\n\t- 这种情况下一般用户请求源网站的IP地址及网站加载的内容和脚本都是正确的，但是在网站内容请求返回的过程中，可能被ISP（Internet Service Provider，互联网服务提供商）劫持修改，最终在浏览器页面上添加显示一些广告等内容信息。\n\n- 对于这些情况，网站开发者常常就无法通过修改网站代码程序等手段来进行防范了。请求劫持唯一可行的预防方法就是尽量使用HTTPS协议来访问目标网站。\n\n### HTTPS协议通信过程\n\n- HTTPS协议是通过加入SSL（Secure Sockets Layer）层来加密HTTP数据进行安全传输的HTTP协议，同时启用默认的443端口进行数据传输。\n- 公钥（Public Key）与私钥（Private Key）是通过一种加密算法得到的密钥对（即一个公钥和一个与之匹配的私钥），公钥是密钥对中公开的部分，私钥则是非公开的部分。公钥通常用于会话加密、验证数字签名或者加密可以用相应私钥解密的数据。通过这种算法得到的密钥对保证是唯一的。使用这个密钥对的时候，如果用其中一个密钥加密一段数据，则必须用另一个密钥解密。\n\n### HTTPS协议解析\n\n- HTTPS请求报文和HTTP的请求报文区别不大，但是在请求的头部域字段多了upgrade-insecure-requests，该头部字段指令很关键，它可以用于让页面打开的后续请求自动从 HTTP请求升级到HTTPS请求。否则如果使用HTTPS来加载HTML文件，而HTML中加载的是HTTP链接的资源文件，则会产生Mixed Content类型的错误，并且无法加载资源。\n- 在服务器端响应头域中也要加入下面的头域来返回给浏览器，否则浏览器默认安全显示策略会阻塞内容并提示block-all-mixed-content类型的错误。\nheader("Content-Security-Policy: upgrade-insecure-requests") ;\n\n### 浏览器Web安全控制\n\n- X-XSS-Protection\n\n\t- 这个head消息头设置主要是用来防止浏览器中的反射性XSS问题的发生，通过这种方式可以在浏览器层面增加前端网页的安全性。\n\t- X-XSS-Protection通常设置如下。\n\nX-XSS-Protection: 1;\nmode=block 0 –关闭对浏览器的xss防护；1 –开启xss防护\nmode=block可以开启XSS防护并通知浏览器阻止而不是过滤用户注入的XSS脚本\n\n- Strict-Transport-Security\n\n\t- Strict Transport Security（STS）是一种用来配置浏览器和服务器之间安全通信的机制，主要用来防止中间者攻击，因为它强制所有的通信都使用HTTPS，在普通的HTTP报文请求中配置STS是没有作用的，而且攻击者也能更改这些值。\n\t- 为了防止这样的现象发生，很多浏览器内置了一个配置STS的站点列表，在Chrome浏览器下可以通过访问chrome://net-internals/#hsts查看浏览器中站点的STS列表，一般STS的配置实现如下。\n\nmax-age=31536000 –告诉浏览器将域名缓存到STS列表中，只有这些特定域名下的资源内容才允许被加载，时\n间是一年\nmax-age=31536000;\nincludeSubDomains;\npreload; –告诉浏览器将域名缓存到STS列表里面并且包含所有的子域名，并可支持预加载，时间是一年\nmax-age= 0 –告诉浏览器移除在STS缓存里的域名，或者不保存当前域名\n\n- Content-Security-Policy\n\n\t- 我们简称它为CSP，这是一种由开发者定义的安全策略性声明，通过CSP所约束的的规则设定，浏览器只可以加载指定可信的域名来源的内容（这里的内容可以是脚本、图片、iframe、font、style等等远程资源）。通过CSP协定，Web只能加载指定安全域名下的资源文件，保证运行时的内容总处于一个安全的环境中。\n\n- Access-Control-Allow-Origin\n\n\t- Access-Control-Allow-Origin是从Cross Origin Resource Sharing（CORS）中分离出来的。这个头部设置是决定哪些网站可以访问当前服务器资源的设置，通过定义一个通配符或域名来决定是单一的网站还是所有网站可以访问服务器的资源。\n\t- 需要注意的是，如果服务器端定义了通配符“＊”，那么服务端的Access-Control-Allow-Credentials（是否允许请求时携带验证信息）选项就无效了，此时用户浏览器中的不同域Cookie信息将默认不会在服务器请求里发送（即如果需要实现带Cookie进行跨域请求，则要明确地配置允许来源的域，使用任意域的配置是不合法的）。\n\nAccess-Control-Allow-Origin : * *– 通配符允许任何远程资源来访问 Access-Control-Allow-Origin\n的内容  \nhttp://www.domain.com – 只允许特定站点才能访问当前资源\n\t- Access-Control-Allow-Origin常常作为跨域共享设置的一种实现方式，其他常用的跨域手段还有： JSONP(JSON with Padding)、 script标签跨域、 window.postMessage、修改 document.domain跨子域、 window.name跨域和 WebSocket跨域等。\n\n##  XSS\n\n### 跨站脚本攻击(Cross Site Scripting)，缩写为XSS\n\n- （1）XSS的定义：跨域脚本注入，攻击者通过某种方式将恶意代码注入到网页上，然后其他用户观看到被注入的页面内容后会受到特定攻击\n\n\t- 恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。\n\n- （2）XSS的原理\n\n\t- 1.攻击者对含有漏洞的服务器发起XSS攻击（注入JS代码）。\n\t- 2.诱使受害者打开受到攻击的服务器URL。\n\t- 3.受害者在Web浏览器中打开URL，恶意脚本执行。\n\n- （3）XSS的攻击方式\n\n\t- 1.反射型：（直接通过URL注入，而且很多浏览器都自带防御）\n\n\t\t- 发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS随响应内容一起返回给浏览器，最后浏览器解析执行XSS代码，这个过程就像一次发射，所以叫反射型XSS\n\t\t- 反射型XSS漏洞的攻击步骤\n\n\t\t\t- （1） 用户正常登录Web应用程序，登录成功会得到一个会话信息的cookie：\n\n\t\t\t- （2） 攻击者将含有攻击代码的URL发送给被攻击人；\n\n\t\t\t- （3） 用户打开攻击者发送过来的ULR；\n\t\t\t- （4） Web应用程序执行用户发出的请求；\n\t\t\t- （5） 后台对URL参数未做任何过滤处理，返回给客户端，前端直接从url上获取参数，会导致URL上的js代码执行\n\t\t\t- （6） 例子中攻击者使用的攻击代码作用是将用户的cookie信息发送到cookie_save.php这个文件来记录下来；\n\t\t\t- （7） 攻击者在得到用户的cookie信息后，将可以利用这些信息来劫持用户的会话。以该用户的身份进行登录。\n\n\t- 2.存储型：（存储到DB后读取时注入）\n\n\t\t- 存储型XSS和反射型的XSS差别就在于，存储型的XSS提交的代码会存储在服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交XSS代码。\n\n\t- 3. DOM-based XSS\n\n\t\t- 代码\n\n\t\t- 理解\n\n- （4）XSS的防御措施\n\n\t- （1）输出进行编码：\n\n\t\t- HTML实体编码\n\n\t\t\t- 在 HTML 中，某些字符是预留的，比如不能使用小于号（<）和大于号（>），这是因为浏览器会误认为它们是标签。如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。当然还另一个重要原因，有些字符在 ASCII 字符集中没有定义，因此需要使用字符实体来表示，比如中文。\n\t\t\t- 最常见的五种实体编码\n\n\t\t- 和输入过滤类似，不过是从输出上着手，数据输出到页面时，经过HtmlEncoder等工具编码，这样就不会存在直接输出可执行的脚本了\n\n\t- （2）输入过滤：\n\n\t\t- 不信任用户的任何输入，过滤其中的“<”、“>”、“/”等可能导致脚本注入的特殊字符， 或者过滤“script”、“javascript”等脚本关键字，或者对输入数据的长度进行限制等等， 还得考虑攻击者使用十六进制编码来输入脚本的方式。\n\t\t- 而在一些前端框架中，都会有一份 decodingMap， 用于对用户输入所包含的特殊字符或标签进行编码或过滤，如 <，>，script，防止 XSS 攻击：\n\n\t- （3）Cookie设置http-only（防止劫取 Cookie）：\n\n\t\t- HttpOnly 最早由微软提出，至今已经成为一个标准。浏览器将禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。\n\t\t- 上文有说到，攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。\n\n\t- （4）Cookie防盗：\n\n\t\t- 在 Cookie 中防止放入用户名和密码，对 Cookie 信息进行 MD5 等算法进行多次散列存放，必要时还要对 ip 和 cookie 进行绑定，一旦检测异常，立马让用户重新登录；\n\n## CSRF\n\n### CSRF（跨站请求伪造）（cross-site request forgery）\n\n- （1）CSRF的定义：冒用用户身份，进行恶意操作\n\n\t-  攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。\n\n- （2）CSRF的原理\n\n\t- 1. 用户打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；\n\t- 2.在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；\n\t- 3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；\n\t- 4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；\n\t- 5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 \n\t- CSRF攻击的本质原因 ：CSRF 攻击时源于 WEB 的隐式身份验证机制！WEB 的身份验证机制虽然可以保证一个请求是来自某个用户的浏览器，但无法保证该请求是经过用户批准发送的。\n\n- （3）CSRF的攻击手段\n\n\t-  1.譬如在网站内的图片资源中潜入恶意的转账操作\n\n\t-  2.构建恶意的隐藏表单，并通过脚本提交恶意请求\n\n\t- 【注意】\n\n\t\t- 从头到尾，攻击网站都没有获取到过 cookie，都是通过浏览器间接实现（利用Web的cookie隐式身份验证机制），所以HttpOnly并不会影响这个攻击\n\n\t- 【例子】（必看）\n\n\t\t- （1）假设有一个 bbs 站点：http://www.c.com，当登录后的用户发起如下 GET 请求时，会删除 ID 指定的帖子\n\n\t\t\t- 如发起 http://www.c.com:8002/content/delete/87343 请求时，会删除 id 为 87343 的帖子。当用户登录之后，会设置如下 cookie\n\n\t\t- （2）然后构造一个页面 A\n\n\t\t- （3）页面 A 使用了一个 img 标签，其地址指向了删除用户帖子的链接\n\n\t\t- （4）可以看到，当登录用户访问攻击者的网站时，会向 www.c.com 发起一个删除用户帖子的请求。此时若用户在切换到 www.c.com 的帖子页面刷新，会发现ID 为 87343 的帖子已经被删除。\n\t\t- 深刻理解\n\n\t\t\t- 由于 Cookie 中包含了用户的认证信息，当用户访问攻击者准备的攻击环境时，攻击者就可以对服务器发起 CSRF 攻击。在这个攻击过程中，攻击者借助受害者的 Cookie 骗取服务器的信任，但并不能拿到 Cookie，也看不到 Cookie 的内容。而对于服务器返回的结果，由于浏览器同源策略的限制，攻击者也无法进行解析。因此，攻击者无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。\n\n- （4）常见的CSRF防御手段\n\n\t- 1.利用Token来防御\n\n\t  CSRF 攻击之所以能够成功，是因为攻击者可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 Cookie 中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的 Cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求\n\n\t\t- 当客户端请求页面时，服务器会生成一个随机数Token，并且将Token放置到session当中，然后将Token发给客户端（一般通过构造hidden表单）。下次客户端提交请求时，Token会随着表单一起提交到服务器端。 \n\t\t- 然后，如果应用于"anti csrf攻击"，则服务器端会对Token值进行验证，判断是否和session中的Token值相等，若相等，则可以证明请求有效，不是伪造的。 \n\n\t- 2.检测referer\n\n\t\t- referer是什么？\n\n\t\t\t- 根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。通过 Referer Check，可以检查请求是否来自合法的"源"。\n\n\t\t- 场景\n\n\t\t\t- 比如，如果用户要删除自己的帖子，那么先要登录 www.c.com，然后找到对应的页面，发起删除帖子的请求。此时，Referer 的值是 http://www.c.com；当请求是从 www.a.com 发起时，Referer 的值是 http://www.a.com 了。因此，要防御 CSRF 攻击，只需要对于每一个删帖请求验证其 Referer 值，如果是以 www.c.com 开头的域名，则说明该请求是来自网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是 CSRF 攻击，可以拒绝该请求。\n\n\t\t- 代码\n\n\t\t\t- 针对上文的例子，可以在服务端增加如下代码：\n\n\t\t- 存在问题\n\n\t\t\t- 后台在进行删除操作之前先判断referer，如果不是本域的请求，则直接拒绝，这种做法很有效。但是，想想这样一个场景：如果博客允许评论里面插图，攻击者完全可以将 img插入到原网站中，这样refer还是在当下域名，博客依然会被删除。所有可能引入链接的html标签都是不可信的，如script、link，后台过滤策略一定要考虑到。\n\n\t- CSRF 防御主要是过滤那些非法伪造的请求来源。\n\n- （5）CSRF与AJAX的关系\n\n\t- 分析AJAX中带cookie验证的情况：\n\n\t\t- 1. AJAX受到浏览器的同源策略限制\n\t\t- 2. AJAX默认无法请求跨域的接口（当然后台可以配置`Access-Control-Allow-Origin: *`之类的允许所有的跨域请求）\n\t\t- 3. AJAX请求无法携带跨域cookie（如果强行开启withCredentials，必须服务端配合认证，无法用作攻击）\n\n\t- CSRF与AJAX无关\n\n*XMind: ZEN - Trial Version*',gl={data:function(){return{MainComponent:vl}}},ml=gl,_l=Object(v["a"])(ml,bl,ul,!1,null,"0c013aca",null),dl=_l.exports,hl=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{},[e("q-markdown",{attrs:{src:t.MainComponent}})],1)},fl=[],yl="# 缓存\n\n## 缓存详解\n\n### （1）缓存的好处\n\n- 缓解服务器压力(不用每次去请求资源)；\n- 提升性能(打开本地资源速度当然比请求回来再打开要快得多)；\n- 减少带宽消耗；\n\n### （2）缓存的种类\n\n- 宏观分类\n\n\t- 私有缓存\n\n\t\t- 私有缓存就是用户专享的，各级代理不能缓存的缓存\n\n\t- 共享缓存\n\n\t\t- 共享缓存就是那些能被各级代理缓存的缓存\n\n- 微观分类\n\n\t- 1. 浏览器缓存\n\n\t\t- 浏览器缓存存在的意义就是当用户点击back按钮或是再次去访问某个页面的时候能够更快的响应。尤其是在多页应用的网站中，如果你在多个页面使用了一张相同的图片，那么缓存这张图片就变得特别的有用。\n\n\t- 2. 代理服务器缓存\n\n\t\t- 代理服务器缓存原理和浏览器端类似，但规模要大得多，因为是为成千上万的用户提供缓存机制，大公司和大型的ISP提供商通常会将它们设立在防火墙上或是作为一个独立的设备来运营。\n\n\t- 3. 网关缓存\n\n\t  CDNS(网络内容分发商)分布网关缓存到整个（或部分）互联网上，并出售缓存服务给需要的网站，比如国内的七牛云、又拍云都有这种服务。\n\n\t\t- 也被称为代理缓存或反向代理缓存，网关也是一个中间服务器，网关缓存一般是网站管理员自己部署，从让网站拥有更好的性能\n\n### （3）浏览器的缓存策略\n\n- 缓存的目标：\n\n\t- （1）一个检索请求的成功响应: \n\n\t\t- 对于 GET请求，响应状态码为：200，则表示为成功。一个包含例如HTML文档，图片，或者文件的响应；\n\n\t- （2）不变的重定向: \n\n\t\t- 响应状态码：301；\n\n\t- （3）可用缓存响应：响应状态码：\n\n\t\t- 304，这个存在疑问，Chrome会缓存304中的缓存设置，Firefox；\n\n\t- （4）错误响应: \n\n\t\t- 响应状态码：404 的一个页面；\n\n\t- （5）不完全的响应: \n\n\t\t- 响应状态码 206，只返回局部的信息；\n\n\t- （6）除了 GET 请求外，如果匹配到作为一个已被定义的cache键名的响应；\n\n- 浏览器怎么确定一个资源该不该缓存？\n\n\t- 浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。\n\t- 响应头！响应头！响应头！\n\n- 1.强缓存阶段\n\n\t- 浏览器第一次请求时\n\n\t\t- 这就是强缓存阶段，当浏览器再次试图访问这个CSS文件，发现有这个文件的缓存，那么就判断根据上一次的响应判断是否过期，如果没过期，使用缓存。加载文件，OVER！\n\t\t- 浏览器表现\n\n\t\t\t- Firefox浏览器表现为一个灰色的200状态码。Chrome浏览器状态码表现为:200 (from disk cache)或是200 OK (from memory cache)\n\n\t- 浏览器在请求某一资源时，会先获取该资源缓存的header信息，判断是否命中强缓存（cache-control和expires信息），若命中直接从缓存中获取资源信息，包括缓存header信息；本次请求根本就不会与服务器进行通信；\n\t- 强缓存如何重新加载缓存缓存过的资源\n\n\t  使用强缓存时，浏览器不会发送请求到服务端，根据设置的缓存时间浏览器一直从缓存中获取资源，在这期间若资源产生了变化，浏览器就在缓存期内就一直得不到最新的资源，那么如何防止这种事情发生呢？\n\n\t\t- 通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源。\n\n- 2.协商缓存阶段\n\n\t- 浏览器后续在进行请求时\n\n\t\t- 当响应过期了，ETag和Last-Modified就该闪亮登场了。Last-Modified，这个字段是文件最后一次修改的时间；ETag呢？ETag是对文件的一个标记\n\n\t- 利用这两个字段浏览器可以进入协商缓存阶段，当浏览器再次试图访问这个CSS文件，发现缓存过期，于是会在本次请求的请求头里携带If-Moified-Since和If-None-Match这两个字段（前者的值为上次响应的Last-Modified的时间，后者的值为上一次返回的ETag的值），服务器通过这两个字段来判断资源是否有修改，如果有修改则返回状态码200和新的内容，如果没有修改返回状态码304，浏览器收到200状态码，该咋处理就咋处理(相当于首次访问这个文件了)，发现返回304，于是知道了本地缓存虽然过期但仍然可以用，于是加载本地缓存。然后根据新的返回的响应头来设置缓存。\n\t- 注意：304和缓存的区别\n\n\t\t- 缓存不会发起请求了，直接从内存或者硬盘中获得\n\t\t- 304依然会发起请求与响应，只不过响应的第四部分不用再次下载了，因为没有更改，所以还是第一次下载的资源。\n\n## HTTP缓存\n\n### 前端缓存主要是分为HTTP缓存和浏览器缓存。其中HTTP缓存是在HTTP请求传输时用到的缓存，主要在服务器代码上设置；而浏览器缓存则主要由前端开发在前端js上进行设置。\n\n### 三 强制缓存\n\n- 强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种，如下：\n\n  > **①不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致），如下图：**\n  \n  ![img](https:////upload-images.jianshu.io/upload_images/13277068-5d97a99c4925bc4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/649/format/webp)\n  \n  > **②存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存，如下图**\n  \n  ![img](https:////upload-images.jianshu.io/upload_images/13277068-f791d19193c7f86a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/687/format/webp)\n  \n  > **③存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果，如下图**\n  \n  ![img](https:////upload-images.jianshu.io/upload_images/13277068-93e7c967e142e04a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/662/format/webp)\n  \n  > **那么强制缓存的缓存规则是什么？**\n\n- 当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。\n- Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。\n- 到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义。\n- ①HTTP响应报文中expires的时间值，是一个绝对值\n- ②HTTP响应报文中Cache-Control为max-age=600，是相对值\n- 由于Cache-Control的优先级比expires高，那么直接根据Cache-Control的值进行缓存，意思就是说在600秒内再次发起该请求，则会直接使用缓存结果，强制缓存生效。\n- 在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于expires是更好的选择，所以同时存在时，只有Cache-Control生效。\n- from memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –> disk –> 服务器请求。\n- 那么接下来我们一起详细分析一下缓存读取问题，这里仍让以我的博客为例进行分析：\n- 在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。\n\n### 缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。\n\n### 四 协商缓存\n\n- ①协商缓存生效，返回304，\n- ②协商缓存失效，返回200和请求结果结果，\n- 同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。\n- Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间，如下。\n- If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件，如下。\n- Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，如下。\n- If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200，如下。\n- 注：Etag / If-None-Match优先级高于Last-Modified / If-Modified-Since，同时存在则只有Etag / If-None-Match生效。对于协商缓存，使用 Ctrl+F5强制刷新可以使得缓存无效。但是对于强缓存，在未过期时，必须更新资源路径才能发起新的请求（更改了路径相当于是另一个资源了，这也是前端工程化中常用到的技巧）。\n- 强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存，主要过程如下：\n\n### 二、缓存过程分析\n\n- 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识\n- 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中\n\n### 对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。\n\n![img](https:////upload-images.jianshu.io/upload_images/13277068-efe830b68127838c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp)\n\n缓存类型图解\n\n\n\n## https://www.jianshu.com/p/256d0873c398\n\n## 浏览器缓存 \n\n### 就是本地存储\n\n*XMind: ZEN - Trial Version*",Sl={data:function(){return{MainComponent:yl}}},wl=Sl,kl=Object(v["a"])(wl,hl,fl,!1,null,"df3fb43a",null),xl=kl.exports,Cl=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{},[t._v("\n   \n===\n  ")])},jl=[],Pl={components:{},data:function(){return{}}},Tl=Pl,El=Object(v["a"])(Tl,Cl,jl,!1,null,"586089e6",null),Ol=El.exports,Ml={components:{m1:zo,m2:Fo,m3:Qo,m4:al,m5:pl,m6:dl,m7:xl,m8:Ol},data:function(){return{tab:"m1",tabs:[{label:"前端性能监测方案",value:"m1"},{label:"算法",value:"m2"},{label:"调试",value:"m3"},{label:"性能",value:"m4"},{label:"现代前端技术解析",value:"m5"},{label:"安全",value:"m6"},{label:"缓存",value:"m7"}]}}},Al=Ml,Nl=Object(v["a"])(Al,Eo,Oo,!1,null,"012e9392",null),Il=Nl.exports,Dl=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+t.value,label:n+1+"."+t.label}})})),1),e("div",{staticClass:"q-mx-lg"},[e(""+t.tab,{tag:"component"})],1)],1)},zl=[],$l=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},Rl=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("h1",[t._v("git")]),e("h2",[t._v("git工作流程")]),e("h3",[t._v("工作流程")]),e("h2",[t._v("git常用操作命令")]),e("h3",[t._v("git创建仓库")]),e("ul",[e("li",[e("p",[t._v("git init")])]),e("li",[e("p",[t._v("git clone")]),e("p",[t._v("格式：")]),e("p",[t._v("git clonerepo [directory]")]),e("p",[t._v("参数说明：")]),e("p",[t._v("repo:Git 仓库。")]),e("p",[t._v("directory:本地目录。")])])]),e("h3",[t._v("git基本操作")]),e("ul",[e("li",[e("p",[t._v("获取与创建项目命令")]),e("ul",[e("li",[t._v("git init")]),e("li",[t._v("git clone")])])]),e("li",[e("p",[t._v("基本快照")]),e("ul",[e("li",[e("p",[t._v("git add")]),e("p",[t._v("git add 命令可将该文件添加到缓存")])]),e("li",[e("p",[t._v("git status")]),e("p",[t._v("git status 以查看在你上次提交之后是否有修改。")])]),e("li",[e("p",[t._v("git diff")]),e("p",[t._v("执行 git diff 来查看执行 git status 的结果的详细信息。")]),e("p",[t._v(" ")]),e("p",[t._v("尚未缓存的改动：git diff")]),e("p",[t._v("查看已缓存的改动： git diff --cached")]),e("p",[t._v("查看已缓存的与未缓存的所有改动：git diff HEAD")]),e("p",[t._v("显示摘要而非整个 diff：git diff --stat")])]),e("li",[e("p",[t._v("git commit")]),e("p",[t._v("使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit 将缓存区内容添加到仓库中。")]),e("p",[t._v(" ")]),e("p",[t._v("注意：常用格式:")]),e("p",[t._v('git commit -m  "content"')])]),e("li",[e("p",[t._v("git reset HEAD")]),e("p",[t._v("git reset HEAD 命令用于取消已缓存的内容。")])]),e("li",[e("p",[t._v("git rm")]),e("p",[t._v("如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 Changes not staged for commit 的提示。")]),e("p",[t._v(" ")]),e("p",[t._v("要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。")]),e("p",[t._v("git rm file")]),e("p",[t._v(" ")]),e("p",[t._v("如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f")]),e("p",[t._v("git rm -f file")]),e("p",[t._v(" ")]),e("p",[t._v("如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 --cached 选项即可")]),e("p",[t._v("git rm --cached file")])])])])]),e("h3",[t._v("git 分支管理")]),e("ul",[e("li",[e("p",[t._v("列出分支")]),e("ul",[e("li",[t._v("git branch")])])]),e("li",[e("p",[t._v("切换分支")]),e("ul",[e("li",[t._v("git checkout")])])]),e("li",[e("p",[t._v("创建分支")]),e("ul",[e("li",[e("p",[t._v("git checkout -b (branchname)")]),e("p",[t._v("我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。")])])])]),e("li",[e("p",[t._v("删除分支")]),e("ul",[e("li",[t._v("git branch -d (branchname)")])])]),e("li",[e("p",[t._v("合并分支")]),e("ul",[e("li",[t._v("git merge")])])]),e("li",[e("p",[t._v("合并冲突")])])]),e("h3",[t._v("git查看提交历史")]),e("ul",[e("li",[e("p",[t._v("git log")]),e("p",[t._v("用 --oneline 选项来查看历史记录的简洁的版本。\n$ git log --oneline\n用 --graph 选项，查看历史中什么时候出现了分支、合并。\ngit log --oneline --graph\n你也可以用 '--reverse'参数来逆向显示所有日志\ngit log --reverse --oneline\n指定用户的提交日志可以使用命令：git log --author \ngit log --author=Linus --oneline -5\n如果你要指定日期，可以执行几个选项：--since 和 --before，但是你也可以用 --until 和 --after\n$ git log --oneline --before={3.weeks.ago} --after={2010-04-18} --no-merges")])])]),e("h2",[t._v("Git")]),e("h3",[t._v("Git 设置")]),e("ul",[e("li",[e("p",[t._v("配置 user.name 和 user.email")]),e("ul",[e("li",[e("p",[t._v("命令")]),e("ul",[e("li",[t._v("git config --global user.name 'theon'")]),e("li",[t._v("git config --global user.email 'xien.xiaohongshu.com'")])])]),e("li",[e("p",[t._v("config 的三个作用域")]),e("ul",[e("li",[t._v("--local 只对某个仓库有效")]),e("li",[t._v("--global 对当前用户的所有仓库有效")]),e("li",[t._v("--system 对系统所有登陆的用户有效")])])]),e("li",[e("p",[t._v("显示 config 的配置，加 --list")]),e("ul",[e("li",[t._v("git config --list --local")]),e("li",[t._v("git config --list --global")]),e("li",[t._v("git config --list --system")])])])])]),e("li",[e("p",[t._v(".git 文件解析")]),e("ul",[e("li",[e("p",[t._v("HEAD")]),e("ul",[e("li",[e("p",[t._v("ref: refs/heads/master")]),e("ul",[e("li",[t._v("引用 ：本地仓库 正处于哪个分支 ")])])]),e("li",[e("p",[t._v("不跟任何的分支挂钩 如果处于分离头指针的状态，指向最近的一次 commit")])])])]),e("li",[e("p",[t._v("config ")]),e("ul",[e("li",[t._v("当前工作路径下的 配置信息")])])]),e("li",[e("p",[t._v("refs")]),e("ul",[e("li",[e("p",[t._v("heads")]),e("ul",[e("li",[t._v("落脚于某次 commit")])])]),e("li",[e("p",[t._v("tags (标签/里程碑)")]),e("ul",[e("li",[t._v("使用场景： 记录重要信息 比如 1.0 发版")])])])])]),e("li",[e("p",[t._v("其他命令")]),e("ul",[e("li",[e("p",[t._v("查看 git文件的 类型，使用参数 -t")]),e("ul",[e("li",[t._v("git cat-file -t  80565b73e7d2f0a2b5b9667c0b34")])])]),e("li",[e("p",[t._v("查看  git 文件的内容 参数 -p")]),e("ul",[e("li",[t._v("git cat-file -p  xxxxcommit_hash")])])]),e("li",[e("p",[t._v("查看 文件夹中是否有内容")]),e("ul",[e("li",[t._v("find .git/objects -type f")])])])])])])]),e("li",[e("p",[t._v("git 图形化界面")]),e("ul",[e("li",[e("p",[t._v("查看所有分支的log")]),e("ul",[e("li",[t._v("gitk --all")])])])])])]),e("h3",[t._v("基础")]),e("ul",[e("li",[e("p",[t._v("建立 git 仓库")]),e("ul",[e("li",[e("p",[t._v("把已有本地项目纳入 git 管理")]),e("ul",[e("li",[e("p",[t._v("cd 文件夹")]),e("ul",[e("li",[t._v("git init")])])])])]),e("li",[e("p",[t._v("新建 使用 git 来管理的项目")]),e("ul",[e("li",[e("p",[t._v("cd 文件夹")]),e("ul",[e("li",[e("p",[t._v("git init  my_project ")]),e("ul",[e("li",[t._v("cd my_project")])])])])])])])])]),e("li",[e("p",[t._v("提交")]),e("ul",[e("li",[e("p",[t._v("添加到暂存区")]),e("ul",[e("li",[e("p",[t._v("添加 已经被git跟踪的文件")]),e("ul",[e("li",[t._v("git add -u")])])]),e("li",[e("p",[t._v("添加 指定文件 ")]),e("ul",[e("li",[t._v("git  add styles/style.css")])])])])]),e("li",[e("p",[t._v("从暂存区删除")]),e("ul",[e("li",[t._v("git rm readme")])])]),e("li",[e("p",[t._v("把工作区的内容 直接创建到 版本历史库里面")]),e("ul",[e("li",[t._v("git commit -am'Add test'")])])]),e("li",[e("p",[t._v("清理 当前暂存区的 所有变更")]),e("ul",[e("li",[t._v("git reset --hard")])])]),e("li",[e("p",[t._v("重命名文件")]),e("ul",[e("li",[t._v("git mv readme readme.md")])])]),e("li",[e("p",[t._v("修改 commit 提交信息")]),e("ul",[e("li",[e("p",[t._v("修改最近的一次提交的信息 ")]),e("ul",[e("li",[t._v("git commit --amend")])])]),e("li",[e("p",[t._v("修改任意提交的信息( 变基 )")]),e("ul",[e("li",[e("p",[t._v("git rebase -i commitId (要选择 想更改的这次commit 的父亲级 commitId，作为 commitId)")])]),e("li",[e("p",[t._v("commit 对应的文件  以及文件内容 不会发生变化")]),e("ul",[e("li",[t._v("tree中的 blob 是没有发生变化的")])])]),e("li",[e("p",[t._v("r ,rewrite")]),e("ul",[e("li",[t._v("修改某一次的提交记录")])])]),e("li",[e("p",[t._v("s, squash")]),e("ul",[e("li",[t._v("修改 提交信息 并且合并到上一次提交")])])]),e("li",[e("p",[t._v("ommit 次数不够用时，可以复制 一次父亲级 commitId 放到交互式界面 第一行,让别的记录往里面融合")]),e("ul",[e("li",[t._v("git rebase --continue")])])])])])])])])]),e("li",[e("p",[t._v("查看 版本演变历史")]),e("ul",[e("li",[e("p",[t._v("提交记录")]),e("ul",[e("li",[e("p",[t._v("查看当前分支的历史")]),e("ul",[e("li",[t._v("git log")])])]),e("li",[e("p",[t._v("简洁版 一行显示的 ")]),e("ul",[e("li",[t._v("git log --oneline")]),e("li",[t._v("git log --oneline --all")])])]),e("li",[e("p",[t._v("最近的 n 次提交记录")]),e("ul",[e("li",[t._v("git log -n4 --oneline")]),e("li",[t._v("git  log --oneline --all -n4")])])]),e("li",[e("p",[t._v("查看所有分支的历史")]),e("ul",[e("li",[t._v("git log --all")]),e("li",[t._v("git log --all --graph")])])])])])])]),e("li",[e("p",[t._v("比较 diff")]),e("ul",[e("li",[e("p",[t._v("比较具体的两次 commit")]),e("ul",[e("li",[t._v("git diff commithash1  commitxxxhash2")])])]),e("li",[e("p",[t._v("比较暂存区和上一次提交状态（HEAD）  之间的区别")]),e("ul",[e("li",[t._v("git diff --cached")])])]),e("li",[e("p",[t._v("比较的是 工作区和暂存区的区别")]),e("ul",[e("li",[e("p",[t._v("git diff")]),e("ul",[e("li",[t._v("git diff -- readme.md ")])])])])]),e("li",[e("p",[t._v("指代 commit")]),e("ul",[e("li",[e("p",[t._v("git diff HEAD HEAD^")]),e("ul",[e("li",[t._v("比较上次提交 和 上上次提交的差异")])])]),e("li",[e("p",[t._v("git diff HEAD HEAD^^")]),e("ul",[e("li",[t._v("比较上次提交  和 上上上次提交的差异")])])])])]),e("li",[e("p",[t._v("比较两个分支之间的区别")]),e("ul",[e("li",[e("p",[t._v("git diff  master temp")])]),e("li",[e("p",[t._v("git diff master temp -- index.html")])]),e("li",[e("p",[t._v("git diff ce9a7907 d7d5dbd -- index.html ")]),e("ul",[e("li",[t._v("对不同分支上的不同 commit 的提交 做比较")])])])])])])]),e("li",[e("p",[t._v("变更")]),e("ul",[e("li",[e("p",[t._v("reset")]),e("ul",[e("li",[e("p",[t._v("改暂存区")]),e("ul",[e("li",[e("p",[t._v("把暂存区 恢复成 HEAD")]),e("ul",[e("li",[e("p",[t._v("git reset HEAD")]),e("ul",[e("li",[t._v("git diff --cached")])])]),e("li",[e("p",[t._v("git reset HEAD -- readme.md index.html")])])])]),e("li",[e("p",[t._v("恢复到某一次 commit")]),e("ul",[e("li",[t._v("git reset --hard commitId")])])])])])])]),e("li",[e("p",[t._v("checkout")]),e("ul",[e("li",[e("p",[t._v("改工作区")]),e("ul",[e("li",[e("p",[t._v("把工作区内容 恢复成  暂存区")]),e("ul",[e("li",[t._v("git checkout -- index.html")])])])])])])])])]),e("li",[e("p",[t._v("临时存储")]),e("ul",[e("li",[e("p",[t._v("存储")]),e("ul",[e("li",[t._v("git stash")])])]),e("li",[e("p",[t._v("从 存储 中取出放到工作区 + 存储信息保留 可以反复使用")]),e("ul",[e("li",[t._v("git stash apply")])])]),e("li",[e("p",[t._v("从 存储 中取出放到工作区 + 存储信息出栈  无法找到原有的记录")]),e("ul",[e("li",[t._v("git stash pop")])])]),e("li",[e("p",[t._v("git stash list")]),e("ul",[e("li",[t._v("查看 堆栈")])])])])]),e("li",[e("p",[t._v("hash 值长短问题")]),e("ul",[e("li",[t._v("只要 hash 值足够说明唯一性，即可")])])]),e("li",[e("p",[t._v("删除文件")]),e("ul",[e("li",[e("p",[t._v("git rm readme.md")]),e("ul",[e("li",[t._v("把文件 从工作区删除 并在暂存区 也删除")])])])])]),e("li",[e("p",[t._v(".gitignore")]),e("ul",[e("li",[e("p",[t._v("abc")]),e("ul",[e("li",[t._v("文件名是 abc 和 abc 文件夹下的内容  都不放入 git版本库")])])]),e("li",[e("p",[t._v("abc/")]),e("ul",[e("li",[t._v("git 只管理 abc 文件夹下的文件")])])])])]),e("li",[e("p",[t._v("git 仓库的备份")]),e("ul",[e("li",[e("p",[t._v("传输协议")]),e("ul",[e("li",[e("p",[t._v("本地协议")]),e("ul",[e("li",[e("p",[t._v("哑协议")]),e("ul",[e("li",[t._v("/path/to/repo.git")])])]),e("li",[e("p",[t._v("智能协议")]),e("ul",[e("li",[t._v("file:///path/to/repo.git")])])])])]),e("li",[e("p",[t._v("http / https")]),e("ul",[e("li",[e("a",{staticClass:"url",attrs:{href:"http://git-server.com:port/path/to/repo.git",target:"_blank"}},[t._v("http://git-server.com:port/path/to/repo.git")])])])]),e("li",[e("p",[t._v("ssh 协议")]),e("ul",[e("li",[e("a",{staticClass:"url",attrs:{href:"mailto:user@git-server.com",target:"_blank"}},[t._v("user@git-server.com")]),t._v(":path/to/repo.git")])])])])])])])]),e("h3",[t._v("分支操作")]),e("ul",[e("li",[e("p",[t._v("查看本地分支")]),e("ul",[e("li",[t._v("git branch -v")])])]),e("li",[e("p",[t._v("分离头指针(detached HEAD)")]),e("ul",[e("li",[t._v("即当前变更 未跟任何的分支挂钩")]),e("li",[t._v("切换到别的分支时，若不与某个分支挂钩，可能会被 git 当成辣鸡清除")])])]),e("li",[e("p",[t._v("删除分支")]),e("ul",[e("li",[t._v("git branch -D db6964b")])])])]),e("h2",[t._v("Git流程梳理与理解 ")]),e("h3",[t._v("Git的四个区域")]),e("ul",[e("li",[e("p",[t._v("工作区")]),e("ul",[e("li",[t._v("本地电脑存放项目文件的地方，比如learnGitProject文件夹；")])])]),e("li",[e("p",[t._v("暂存区（Index/Stage）")]),e("ul",[e("li",[t._v("在使用git管理项目文件的时候，其本地的项目文件会多出一个.git的文件夹，将这个.git文件夹称之为版本库。其中.git文件夹中包含了两个部分，一个是暂存区（Index或者Stage）,顾名思义就是暂时存放文件的地方，通常使用add命令将工作区的文件添加到暂存区里；")])])]),e("li",[e("p",[t._v("本地仓库")]),e("ul",[e("li",[t._v(".git文件夹里还包括git自动创建的master分支，并且将HEAD指针指向master分支。使用commit命令可以将暂存区中的文件添加到本地仓库中；")])])]),e("li",[e("p",[t._v("远程仓库")]),e("ul",[e("li",[t._v("不是在本地仓库中，项目代码在远程git服务器上，比如项目放在github上，就是一个远程仓库，通常使用clone命令将远程仓库拷贝到本地仓库中，开发后推送到远程仓库中即可；")])])])]),e("h3",[t._v("git工作区、暂存区和版本库")]),e("ul",[e("li",[e("p",[t._v("图示")]),e("ul",[e("li",[e("p",[t._v("工作区")]),e("p",[t._v("工作区：就是你在电脑里能看到的目录。")])]),e("li",[e("p",[t._v("暂存区")]),e("p",[t._v('暂存区：英文叫stage, 或index。一般存放在 ".git目录下" 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。')])]),e("li",[e("p",[t._v("版本库")]),e("p",[t._v("版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。")])]),e("li",[e("p",[t._v("子主题 4")])])])])]),e("h3",[t._v("Git常用操作命令")]),e("ul",[e("li",[e("p",[t._v("工作区上的操作命令")]),e("ul",[e("li",[e("p",[t._v("新建仓库")]),e("ul",[e("li",[e("p",[t._v("（1）将工作区中的项目文件使用git进行管理，即创建一个新的本地仓库：git init；")])]),e("li",[e("p",[t._v("（2）从远程git仓库复制项目：git clone  url ")]),e("ul",[e("li",[t._v("克隆项目时如果想定义新的项目名，可以在clone命令后指定新的项目名：git clone git://github.com/wasd/example.git mygit")])])])])]),e("li",[e("p",[t._v("提交")]),e("ul",[e("li",[e("p",[t._v("（1）提交工作区所有文件到暂存区")]),e("ul",[e("li",[t._v("git add .")])])]),e("li",[e("p",[t._v("（2）提交工作区中指定文件到暂存区")]),e("ul",[e("li",[t._v("git add  file1   file2  ...")])])]),e("li",[e("p",[t._v("（3）提交工作区中某个文件夹中所有文件到暂存区")]),e("ul",[e("li",[t._v("git add [dir]")])])])])]),e("li",[e("p",[t._v("撤销")]),e("ul",[e("li",[e("p",[t._v("（1）删除工作区文件，并且也从暂存区删除对应文件的记录")]),e("ul",[e("li",[t._v("git rm  file1 file2 ")])])]),e("li",[e("p",[t._v("（2）从暂存区中删除文件，但是工作区依然还有该文件")]),e("ul",[e("li",[t._v("git rm --cached file")])])]),e("li",[e("p",[t._v("（3）取消暂存区已经暂存的文件")]),e("ul",[e("li",[t._v("git reset HEAD file...")])])]),e("li",[e("p",[t._v("（4）撤销上一次对文件的操作")]),e("ul",[e("li",[t._v("git checkout --file。要确定上一次对文件的修改不再需要，如果想保留上一次的修改以备以后继续工作，可以使用stashing和分支来处理")])])])])]),e("li",[e("p",[t._v("更新文件")]),e("ul",[e("li",[e("p",[t._v("重命名文件，并将已改名文件提交到暂存区")]),e("ul",[e("li",[t._v("git mv [file-original] [file-renamed]")])])])])]),e("li",[e("p",[t._v("查新信息")]),e("ul",[e("li",[e("p",[t._v("（1）查询当前工作区所有文件的状态")]),e("ul",[e("li",[t._v("git status")])])]),e("li",[e("p",[t._v("（2）比较工作区中当前文件和暂存区之间的差异，也就是修改之后还没有暂存的内容：git diff；指定文件在工作区和暂存区上差异比较")]),e("ul",[e("li",[t._v("git diff [file-name]")])])])])])])]),e("li",[e("p",[t._v("暂存区上的操作命令")]),e("ul",[e("li",[e("p",[t._v("提交文件到版本库")]),e("ul",[e("li",[e("p",[t._v("（1）将暂存区中的文件提交到本地仓库中，即打上新版本")]),e("ul",[e("li",[t._v('git commit -m "commit_info"')])])]),e("li",[e("p",[t._v("（2）将所有已经使用git管理过的文件暂存后一并提交，跳过add到暂存区的过程")]),e("ul",[e("li",[t._v('git commit -a -m "commit_info"')])])]),e("li",[e("p",[t._v("（3）提交文件时，发现漏掉几个文件，或者注释写错了，可以撤销上一次提交")]),e("ul",[e("li",[t._v("git commit --amend")])])])])]),e("li",[e("p",[t._v("查看信息")]),e("ul",[e("li",[e("p",[t._v("（1）比较暂存区与上一版本的差异")]),e("ul",[e("li",[t._v("git diff --cached")])])]),e("li",[e("p",[t._v("（2）指定文件在暂存区和本地仓库的不同")]),e("ul",[e("li",[t._v("git diff [file-name] --cached")])])]),e("li",[e("p",[t._v("（3）查看提交历史")]),e("ul",[e("li",[t._v("git log；参数-p展开每次提交的内容差异，用-2显示最近的两次更新，如git log -p -2;")])])])])]),e("li",[e("p",[t._v("分支管理")]),e("ul",[e("li",[e("p",[t._v("创建与合并分支")]),e("ul",[e("li",[e("p",[t._v("（1）查看分支")]),e("ul",[e("li",[t._v("git branch")])])]),e("li",[e("p",[t._v("（2）创建分支")]),e("ul",[e("li",[t._v("git branch [name]")])])]),e("li",[e("p",[t._v("（3）切换分支")]),e("ul",[e("li",[t._v("git checkout [name]")])])]),e("li",[e("p",[t._v("（4）创建+切换分支")]),e("ul",[e("li",[t._v("git checkout -b [name]")])])]),e("li",[e("p",[t._v("（5）合并某分支到当前分支")]),e("ul",[e("li",[t._v("git merge [name]")])])]),e("li",[e("p",[t._v("（6）删除分支")]),e("ul",[e("li",[t._v("git branch -d [name]")])])])])]),e("li",[e("p",[t._v("解决冲突")]),e("ul",[e("li",[t._v('当一个分支与另一个分支有冲突时，如使用merge语句进行合并，那么则需要手动解决冲突，git status也可以告诉我们冲突的文件，Git用<<<<<<<，=======，>>>>>>>标记出不同分支的内容，我们修改如下后提交：$ git add readme.txt \n$ git commit -m "conflict fixed"，最后，删除feature1分支：$ git branch -d feature1')])])]),e("li",[e("p",[t._v("BUG分支")]),e("ul",[e("li",[t._v("修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；")]),e("li",[t._v("当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。")])])]),e("li",[e("p",[t._v("Feature分支")]),e("ul",[e("li",[t._v("开发一个新feature，最好新建一个分支；")]),e("li",[t._v("如果要丢弃一个没有被合并过的分支，可以通过git branch -D [name]强行删除。")])])]),e("li",[e("p",[t._v("多人协作")]),e("ul",[e("li",[e("p",[t._v("（1）首先，可以试图用git push origin [branch-name]推送自己的修改；")])]),e("li",[e("p",[t._v("（2）如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；")])]),e("li",[e("p",[t._v("（3）如果合并有冲突，则解决冲突，并在本地提交；")])]),e("li",[e("p",[t._v("（4）没有冲突或者解决掉冲突后，再用git push origin [branch-name]推送就能成功！")])]),e("li",[e("p",[t._v("如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to [branch-name] origin/[branch-name]。")])]),e("li",[e("p",[t._v("小结")]),e("ul",[e("li",[t._v("查看远程库信息，使用git remote -v；")]),e("li",[t._v("本地新建的分支如果不推送到远程，对其他人就是不可见的；")]),e("li",[t._v("从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；")]),e("li",[t._v("在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；")]),e("li",[t._v("建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；")]),e("li",[t._v("从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。")])])]),e("li",[e("p",[t._v("示例")]),e("ul",[e("li",[t._v("【成员一： 初始仓库操作】")]),e("li",[t._v("【成员一： 建立dev分支操作】")]),e("li",[t._v("【成员二：改动dev分支操作】")]),e("li",[t._v("【成员一：之后再改动dev分支】")])])])])])])]),e("li",[e("p",[t._v("复杂分支操作")]),e("ul",[e("li",[e("p",[t._v("（1）把远程分支合并到当前分支")]),e("ul",[e("li",[t._v("git merge [remote-name]/[branch-name]，如git merge origin/serverfix；")]),e("li",[t._v("如果是单线的历史分支不存在任何需要解决的分歧，只是简单的将HEAD指针前移，所以这种合并过程可以称为快进（Fast forward），而如果是历史分支是分叉的，会以当前分叉的两个分支作为两个祖先，创建新的提交对象；如果在合并分支时，遇到合并冲突需要人工解决后，再才能提交；")])])]),e("li",[e("p",[t._v("（2）在远程分支的基础上创建新的本地分支")]),e("ul",[e("li",[t._v("git checkout -b [branch-name] [remote-name]/[branch-name]，如git checkout -b serverfix origin/serverfix;")])])]),e("li",[e("p",[t._v("（3）从远程分支checkout出来的本地分支，称之为跟踪分支。")]),e("ul",[e("li",[t._v("在跟踪分支上向远程分支上推送内容：git push。该命令会自动判断应该向远程仓库中的哪个分支推送数据")]),e("li",[t._v("在跟踪分支上合并远程分支：git pull")])])]),e("li",[e("p",[t._v("（4）将一个分支里提交的改变移到基底分支上重放一遍")]),e("ul",[e("li",[t._v("git rebase [rebase-branch] [branch-name]，如git rebase master server；将特性分支server提交的改变在基底分支master上重演一遍；使用rebase操作最大的好处是像在单个分支上操作的，提交的修改历史也是一根线；")]),e("li",[t._v("如果想把基于一个特性分支上的另一个特性分支变基到其他分支上，可以使用--onto操作：git rebase --onto [rebase-branch]  [feature branch] [sub-feature-branch]，如git rebase --onto master server client；")]),e("li",[t._v("使用rebase操作应该遵循的原则是：一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行rebase操作；")])])])])])])]),e("li",[e("p",[t._v("本地仓库上的操作")]),e("ul",[e("li",[e("p",[t._v("查看本地仓库关联的远程仓库")]),e("ul",[e("li",[t._v("git remote -v")]),e("li",[t._v("在克隆完每个远程仓库后，远程仓库默认为origin;加上-v的参数后，会显示远程仓库的url地址；")])])]),e("li",[e("p",[t._v("为本地仓库添加远程关联仓库，一般会取一个简短的别名")]),e("ul",[e("li",[e("p",[t._v("git remote add [remote-name] [url]，比如：git remote add example git://github.com/example/example.git;")]),e("ul",[e("li",[t._v("不过一般都起 origin")])])]),e("li",[e("p",[t._v("了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。")])])])]),e("li",[e("p",[t._v("将本地仓库某分支推送到远程仓库上")]),e("ul",[e("li",[e("p",[t._v("git push [remote-name] [branch-name]，如git push origin master")]),e("ul",[e("li",[t._v("git push -u origin master第一次从本地仓库推送空的远程仓库时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。")])])]),e("li",[e("p",[t._v("如果想将本地分支推送到远程仓库的不同名分支")]),e("ul",[e("li",[t._v("git push  remote-name   local-branch : remote-branch ，如git push origin serverfix:awesomebranch")])])]),e("li",[e("p",[t._v("如果想删除远程分支")]),e("ul",[e("li",[t._v("git push [romote-name] : remote-branch ，如git push origin :serverfix。这里省略了本地分支，也就相当于将空白内容推送给远程分支，就等于删掉了远程分支。")])])])])]),e("li",[e("p",[t._v("从远程仓库中抓取本地仓库中没有的更新")]),e("ul",[e("li",[t._v("git fetch [remote-name]，如git fetch origin")]),e("li",[t._v("使用fetch只是将远端数据拉到本地仓库，并不自动合并到当前工作分支，只能人工合并。（只更新了commit id，git fetch命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。）如果设置了某个分支关联到远程仓库的某个分支的话，可以使用git pull来拉去远程分支的数据，然后将远端分支自动合并到本地仓库中的当前分支；")])])]),e("li",[e("p",[t._v("查看远程仓库的详细信息")]),e("ul",[e("li",[t._v("git remote show origin")])])]),e("li",[e("p",[t._v("版本回退")]),e("ul",[e("li",[e("p",[t._v("在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。")]),e("ul",[e("li",[t._v("git reset --hard HEAD^")])])]),e("li",[e("p",[t._v("回到未来")]),e("ul",[e("li",[t._v("git reset --hard 1094a （可使用git reflog来查看commit ID）")])])])])])])])]),e("h3",[t._v("忽略文件.gitignore")]),e("ul",[e("li",[t._v("一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。")])]),e("p",[e("em",[t._v("XMind: ZEN - Trial Version")])])])}],Jl={},Ll=Jl,Hl=Object(v["a"])(Ll,$l,Rl,!1,null,"6b0bf3de",null),ql=Hl.exports,Fl=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},Wl=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("h1",[t._v("webpack")]),e("h2",[t._v("Webpack4.0")]),e("h3",[t._v("Webpack初探")]),e("ul",[e("li",[e("p",[t._v("webpack安装方式")]),e("ul",[e("li",[t._v("全局安装：npm install webpack -g")]),e("li",[t._v("局部安装：npm instatll webpack -D")]),e("li",[t._v("安装指定版本：npm intatll webpack@版本号")])])]),e("li",[e("p",[t._v("webpack配置")]),e("ul",[e("li",[e("p",[t._v("默认配置文件webpack.config.js")]),e("ul",[e("li",[t._v("node核心模块path")]),e("li",[t._v("局部安装运行打包，npx webpack")]),e("li",[t._v("// 文件内容\nconst path = require('path');\nmodule.exports = {\nentry: './index.js',\noutput: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'bundle')\n}\n}")])])]),e("li",[e("p",[t._v("以webpackconfig.js为配置文件进行打包： npx webpack --config webpackconfig.js")])]),e("li",[e("p",[t._v("运行webpack")]),e("ul",[e("li",[t._v("全局安装时，webpack index.js")]),e("li",[t._v("局部安装时，npx webpack index.js")]),e("li",[t._v("在package.json的scripts中简化打包命令后，npm run bundle -> webpack")])])]),e("li",[e("p",[t._v("webpack-cli作用：在命令行中使用webpack")])])])]),e("li",[e("p",[t._v("浅析webpack打包输出内容")]),e("ul",[e("li",[e("p",[t._v("在配置文件中，增加mode配置")]),e("ul",[e("li",[t._v("mode为production时，打包文件压缩")]),e("li",[t._v("mode为development时，打包文件不压缩")]),e("li",[t._v("mode默认为production，配置文件中没有mode配置，打包代码时会出现警告")])])])])])]),e("h3",[t._v("Webpack的核心概念")]),e("ul",[e("li",[e("p",[t._v("loader预处理文件，可以打包除js之外的任何静态资源")]),e("ul",[e("li",[e("p",[t._v("打包图片资源")]),e("ul",[e("li",[e("p",[t._v("file-loader")]),e("ul",[e("li",[e("p",[t._v("配置项：options")]),e("ul",[e("li",[t._v("name")]),e("li",[t._v("outputPath")])])]),e("li",[e("p",[t._v("占位符：placeholders")]),e("ul",[e("li",[t._v("文件名称：[name]")]),e("li",[t._v("文件后缀：[ext]")]),e("li",[t._v("hash值：[hash]")])])])])]),e("li",[e("p",[t._v("url-loader")]),e("ul",[e("li",[t._v("与file-loader功能类似")]),e("li",[t._v("比file-loader多一个limit配置项，大于limit值，与file-loader功能一样单独打包；小于limit值，以base64形式打包进js文件")])])])])]),e("li",[e("p",[t._v("打包样式资源")]),e("ul",[e("li",[e("p",[t._v("style-loader")]),e("ul",[e("li",[t._v("将JS字符串生成为style节点")])])]),e("li",[e("p",[t._v("css-loader")]),e("ul",[e("li",[e("p",[t._v("作用：将CSS转化成CommonJS模块")])]),e("li",[e("p",[t._v("options")]),e("ul",[e("li",[t._v("局部作用域css：modules")]),e("li",[t._v("在css-loader前应用的loader的数量：importLoaders")])])])])]),e("li",[e("p",[t._v("postcss-loader")])]),e("li",[e("p",[t._v("sass-loader")]),e("ul",[e("li",[t._v("将Sass编译成CSS")])])]),e("li",[e("p",[t._v("less-loader")]),e("ul",[e("li",[t._v("将Less编译成CSS")])])])])]),e("li",[e("p",[t._v("打包字体资源")]),e("ul",[e("li",[t._v("file-loader")])])])])]),e("li",[e("p",[t._v("plugins可以在webpack运行到某个时刻的时候，帮你做一些事情")]),e("ul",[e("li",[t._v("htmlWebpackPlugin会在打包结束后，自动生成一个html文件，并把打包生成的js自动引入到这个html文件中")]),e("li",[t._v("cleanWebpackPlugin在打包之前删除打包输出文件夹（dist）")]),e("li",[t._v("学习plugin：谷歌或百度所需功能需要使用plugin，查找相关api学习使用")])])]),e("li",[e("p",[t._v("entry与output")]),e("ul",[e("li",[e("p",[t._v("entry")]),e("ul",[e("li",[t._v("{\nmain: './src/index.js',\nsub: './src/index.js'\n}")])])]),e("li",[e("p",[t._v("output")]),e("ul",[e("li",[t._v("filename：'[name].js'，占位符[name]表示输出文件名称与entry的key值一致")]),e("li",[t._v("publicPath：指定在浏览器中引用时输出目录的公共url，如"),e("a",{staticClass:"url",attrs:{href:"http://www.cdn.com/main.js",target:"_blank"}},[t._v("http://www.cdn.com/main.js")]),t._v("，"),e("a",{staticClass:"url",attrs:{href:"http://www.cdn.com/sub.js",target:"_blank"}},[t._v("http://www.cdn.com/sub.js")])])])])])]),e("li",[e("p",[t._v("sourceMap映射打包文件与原始文件关系")]),e("ul",[e("li",[t._v("devtool: 'none'，有错误信息时显示在dist文件夹下文件中的报错位置")]),e("li",[t._v("devtool: 'source-map'，生成映射关系文件，有错误信息时显示在源文件中的报错位置")]),e("li",[t._v("devtool: 'inline-source-map'，在打包文件最后生成映射关系字符串")]),e("li",[t._v("devtool: 'cheap-module-eval-source-map'（devlopment环境使用）")]),e("li",[t._v("devtool: 'cheap-module-source-map'（production环境使用）")])])]),e("li",[e("p",[t._v("WebpackDevServer提升开发效率")]),e("ul",[e("li",[e("p",[t._v("webpack --watch   监控到webpack打包代码变化，自动执行打包过程，不会起一个服务器，不能进行ajax调试，不能自动打开浏览器")])]),e("li",[e("p",[t._v("安装webpack-dev-server模块")])]),e("li",[e("p",[t._v("webpack-dev-server --open     启动服务器，监听代码变化，自动刷新浏览器")])]),e("li",[e("p",[t._v("不用WebpackDevServer，使用webpack-dev-middleware配合express自己写WebpackDevServer")])]),e("li",[e("p",[t._v("使用webpack的两种方式")]),e("ul",[e("li",[t._v("在node中使用webpack")]),e("li",[t._v("在命令行中使用webpack")])])])])]),e("li",[e("p",[t._v("Hot Module Replacement")]),e("ul",[e("li",[t._v("在devServer中设置hot，hotOnly")]),e("li",[t._v("在plugins中引入HotModuleReplacementPlugin")]),e("li",[t._v("要通过import引入文件，通过require引入文件HMR失效")]),e("li",[t._v("module.hot.accept")])])]),e("li",[e("p",[t._v("使用Babel处理ES6语法")]),e("ul",[e("li",[e("p",[t._v("babel官网："),e("a",{staticClass:"url",attrs:{href:"https://babeljs.io",target:"_blank"}},[t._v("https://babeljs.io")])])]),e("li",[e("p",[t._v("Setup中查找webpack，参照文档在webpack中使用babel")])]),e("li",[e("p",[t._v("将ES6转成ES5")]),e("ul",[e("li",[e("p",[t._v("业务代码引入polyfill")]),e("ul",[e("li",[t._v("在Docs中找到polyfill，参照文档引入polyfill")]),e("li",[t._v("在presets中使用配置useBuiltIns: 'usage'，根据需要引入polyfill内容")])])]),e("li",[e("p",[t._v("在库项目代码/类库中使用transform-runtime，避免polyfill问题，polyfill污染全局环境，plugin-transform-runtime以闭包形式注入/间接帮助组件引入对应内容，不存在全局污染概念")])])])])])])]),e("h3",[t._v("Webpack的高级概念")]),e("ul",[e("li",[e("p",[t._v("Tree Shaking")]),e("ul",[e("li",[e("p",[t._v("引入模块时，不引入所有代码，只引入需要代码")])]),e("li",[e("p",[t._v("只支持ES Module引入")])]),e("li",[e("p",[t._v("模式")]),e("ul",[e("li",[e("p",[t._v("development")]),e("ul",[e("li",[t._v("// webpack.config.js中配置\noptimization: {\nusedExports: true\n}")]),e("li",[t._v('// pacakge.js中配置\n"sideEffects": false')])])]),e("li",[e("p",[t._v("production")]),e("ul",[e("li",[t._v("// webpack.config.js中修改配置\ndevtool: 'cheap-module-source-map'")]),e("li",[t._v('// pacakge.js中配置\n"sideEffects": false')])])])])])])]),e("li",[e("p",[t._v("Development和Production模式的区分打包")]),e("ul",[e("li",[t._v("根据开发环境与生产环境创建不同配置文件，提取公共文件")]),e("li",[t._v("webpack-merge模块合并公共配置文件与不同模式文件")])])]),e("li",[e("p",[t._v("Webpack 和Code Splitting")]),e("ul",[e("li",[e("p",[t._v("同步代码分割：optimization配置")])]),e("li",[e("p",[t._v("异步代码分割")]),e("ul",[e("li",[t._v("安装模块：babel-plugin-dynamic-import-webpack")]),e("li",[t._v('.babelrc中配置：plugins: ["dynamic-import-webpack"]')])])])])]),e("li",[e("p",[t._v("SplitChunksPlugin配置参数详解")])]),e("li",[e("p",[t._v("Lazy Loading懒加载")])])]),e("h2",[t._v("Webpack 4.0基本配置")]),e("h3",[t._v("entry")]),e("ul",[e("li",[e("p",[t._v("作用：指示webpack应该使用哪个模块，来作为构建其内部依赖图的开始")])]),e("li",[e("p",[t._v("配置")]),e("ul",[e("li",[e("p",[t._v("单入口")])]),e("li",[e("p",[t._v("多入口")]),e("ul",[e("li",[t._v("entry")]),e("li",[t._v("new HtmlWebpackPlugin()")])])])])])]),e("h3",[t._v("output")]),e("ul",[e("li",[e("p",[t._v("作用：output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件")])]),e("li",[e("p",[t._v("配置")]),e("ul",[e("li",[e("p",[t._v("path : 想要bundle生成到哪里")]),e("ul",[e("li",[t._v("原理：path模块是一个Node.js核心模块，用于操作文件路径")])])]),e("li",[e("p",[t._v("filename:告诉webpack bundle的名称")])])])]),e("li",[e("p",[t._v("常见使用场景")]),e("ul",[e("li",[e("p",[t._v("自动生成引用所有打包完的output JS的HTML入口文件")]),e("ul",[e("li",[t._v("html-webpack-plugin")])])]),e("li",[e("p",[t._v("清除打包文件")]),e("ul",[e("li",[t._v("clean-webpack-plugin")])])])])])]),e("h3",[t._v("loader")]),e("ul",[e("li",[e("p",[t._v("作用：让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）")])]),e("li",[e("p",[t._v("配置")]),e("ul",[e("li",[t._v("test：用于标识出应该被对应的 loader 进行转换的某个或某些文件")]),e("li",[t._v("use : 表示进行转换时，应该使用哪个 loader")])])]),e("li",[e("p",[t._v("常见使用场景")]),e("ul",[e("li",[e("p",[t._v("加载 CSS")]),e("ul",[e("li",[e("p",[t._v("style-loader")]),e("ul",[e("li",[t._v("将所有的样式嵌入到dom的style属性当中")])])]),e("li",[e("p",[t._v("css-loader")]),e("ul",[e("li",[t._v("将css当中的 @import 和 url(...) 解析成 import / require 引入")])])]),e("li",[e("p",[t._v("sass-loader")]),e("ul",[e("li",[t._v("将代码sass编译成css")])])])])]),e("li",[e("p",[t._v("加载图片/字体")]),e("ul",[e("li",[t._v("file-loader")])])]),e("li",[e("p",[t._v("加载数据文件（(JSON, CSV, TSV, XML）")]),e("ul",[e("li",[t._v("csv-loader（csv|tsv）")]),e("li",[t._v("xml-loader（xml）")])])])])])]),e("h3",[t._v("plugins")]),e("ul",[e("li",[e("p",[t._v("作用：插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。")])]),e("li",[e("p",[t._v("配置")]),e("ul",[e("li",[e("p",[t._v("plugins：想使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中")]),e("ul",[e("li",[t._v("new : 通过new操作符来创建一个插件的实例  如 ： new HtmlWebpackPlugin({template: './src/index.html'})")]),e("li",[t._v("option : 多数插件可以通过选项(option)来自定义   如：new webpack.optimize.UglifyJsPlugin()")])])])])])]),e("h3",[t._v("mode")]),e("ul",[e("li",[e("p",[t._v("作用：设置mode参数，来启用相应模式下的webpack内置的优化")])]),e("li",[e("p",[t._v("配置")]),e("ul",[e("li",[t._v("development")]),e("li",[t._v("production")])])])]),e("h3",[t._v("devtool")]),e("ul",[e("li",[e("p",[t._v("常见使用场景")]),e("ul",[e("li",[e("p",[t._v("找到报错源文件的位置")]),e("ul",[e("li",[t._v("inline-source-map")])])]),e("li",[e("p",[t._v("webpack自动重新编译修改后的模块,但是要手动刷新页面")]),e("ul",[e("li",[t._v("webpack --watch")])])]),e("li",[e("p",[t._v("实时重新加载(live reloading)")]),e("ul",[e("li",[t._v("webpack-dev-server")])])])])])]),e("h3",[t._v("devServer")]),e("h2",[t._v("Webpack核心概念")]),e("h3",[t._v("核心概念")]),e("ul",[e("li",[e("p",[t._v("Webpack 启动后会从 Entry 里配置的 Module 开始递归解析 Entry 依赖的所有 Module。 每找到一个 Module， 就会根据配置的Loader去找出对应的转换规则，对 Module 进行转换后，再解析出当前 Module 依赖的 Module。 这些模块会以 Entry 为单位进行分组，一个 Entry 和其所有依赖的 Module 被分到一个组也就是一个 Chunk。最后 Webpack 会把所有 Chunk 转换成文件输出。 在整个流程中 Webpack 会在恰当的时机执行 Plugin 里定义的逻辑。")])]),e("li",[e("p",[t._v("Entry")]),e("ul",[e("li",[t._v("入口，webpack执行构建的第一步将从Entry开始，可抽象理解为输入")])])]),e("li",[e("p",[t._v("Module")]),e("ul",[e("li",[t._v("模块，在webpacl中一切皆为模块，一个模块对应一个文件，webpack会从配置的Entry开始递归找出所有依赖的模块")])])]),e("li",[e("p",[t._v("Chunk")]),e("ul",[e("li",[t._v("代码块，一个chunk由多个模块组合而成，用于将代码合并和分割")])])]),e("li",[e("p",[t._v("Loader")]),e("ul",[e("li",[t._v("模块转换器，用于把模块原内容按照需求转换为需要的新内容")])])]),e("li",[e("p",[t._v("Plugin")]),e("ul",[e("li",[t._v("扩展插件，在webpack构建流程中的特定时机注入扩展逻辑来改变构建结果和想要做的事情")])])]),e("li",[e("p",[t._v("Output")]),e("ul",[e("li",[t._v("输入结果，在webpack经过一系列处理并得到最终想要的代码然后输出结果")])])])]),e("h3",[t._v("详细拆分")]),e("ul",[e("li",[e("p",[t._v("1.Entry")]),e("ul",[e("li",[e("p",[t._v("context")]),e("ul",[e("li",[t._v("用来解决配置文件和入口文件不再同一层结构，列如我们配置文件在config，入口文件在根目录，则如下配置")])])]),e("li",[e("p",[t._v("单页面(SPA)Entry入口")]),e("ul",[e("li",[t._v("最简单的单页面(SPA)Entry入口，将main.js引入，并根据main.js中引用和依赖的模块开始解析")])])]),e("li",[e("p",[t._v("多页面(MPA)Entry入口")]),e("ul",[e("li",[t._v("多页面(MPA)Entry入口，将多个文件引入，当然一般是读取指定文件夹内的入口文件，然后引入")]),e("li",[t._v("如果是单页面(传入的是字符串或字符串数组)，则chunk会被命名为main，如果是多页面(传入一个对象)，则每个键(key)会是chunk的名称，描述了chunk的入口起点")])])])])]),e("li",[e("p",[t._v("2.Output")]),e("ul",[e("li",[e("p",[t._v("初步了解")]),e("ul",[e("li",[t._v("Object类型， 指示webpack如何去输出，以及在哪里输出你的bundle、asset 和其他你所打包或使用 webpack 载入的任何内容")])])]),e("li",[e("p",[t._v("path")]),e("ul",[e("li",[t._v("输出目录对应一个绝对路径")])])]),e("li",[e("p",[t._v("pathinfo")]),e("ul",[e("li",[t._v("boolean类型， 默认false，作用是告诉webpack在bundle中引入所包含模块信息的相关注释，不应用于生产环境(production)，对开发环境(development)极其有用")])])]),e("li",[e("p",[t._v("publicPath")]),e("ul",[e("li",[t._v("主要作用是针对打包后的文件里面的静态文件路径处理")])])]),e("li",[e("p",[t._v("filename")]),e("ul",[e("li",[e("p",[t._v("定义每个输出bundle的名称，这些bundle将写入output.path选项指定的目录下")])]),e("li",[e("p",[t._v("（1）单入口")]),e("ul",[e("li",[t._v("对于单入口Entry，filename是一个静态名称")])])]),e("li",[e("p",[t._v("（2）多入口")]),e("ul",[e("li",[t._v("但是在webpack中我们会用到代码拆分、各种插件plugin或多入口Entry创建多个bundle，这样我们就应该给每个bundle一个唯一的名称")])])]),e("li",[e("p",[t._v("（3）使用内部chunk id")])]),e("li",[e("p",[t._v("（4）唯一hash生成")])]),e("li",[e("p",[t._v("（5）使用基于每个 chunk 内容的 hash")])])])])])]),e("li",[e("p",[t._v("3.Module模块")]),e("ul",[e("li",[e("p",[t._v("初步了解")]),e("ul",[e("li",[t._v("处理项目中应用的不同模块，主要配置皆在Rules中，匹配到请求的规则数组，这些规则能够对模块应用loader，或者修改解析器parser")])])]),e("li",[e("p",[t._v("Module.noParse")]),e("ul",[e("li",[t._v("防止webpack解析的时候，将规则匹配成功的文件进行解析和忽略大型的library来对性能的优化，在被忽略的文件中不应该含有import、require和define的调用")])])]),e("li",[e("p",[t._v("Rules")]),e("ul",[e("li",[e("p",[t._v("创建模块时，匹配请求的规则数组")])]),e("li",[e("p",[t._v("Rule条件")]),e("ul",[e("li",[e("p",[t._v("resource(请求文件的绝对路径)、issuer(被请求资源的模块文件的绝对路径，导入时的位置)，比如一个文件A导入文件B，resource是/B，issuer是/A是导入文件时的位置，而不是真正的位置，在规则中，test/include/exclude/resource对resource匹配，而issuer只对issuer匹配")])]),e("li",[e("p",[t._v("Test/include/exclude/resource/issuer的用法和区别")]),e("ul",[e("li",[t._v("代码")]),e("li",[t._v("test：一般是提供一个正则表达式或正则表达式的数组，绝对路径符合这个正则的则意味着满足这个条件")]),e("li",[t._v("include：是一个字符串或者字符串数组，指定目录中的文件需要走这个规则")]),e("li",[t._v("exclude：同样是一个字符串或者字符串数组，指定目录中的文件不需要走这个规则")]),e("li",[t._v("resource：就是对text/include/exclude的一个对象包装，和他们单独写没有区别")]),e("li",[t._v("issuer：和resource有异曲同工的作用，不过区别在于它是将这个rule应用于哪个文件以及这个文件所导入的所有依赖文件")])])])])]),e("li",[e("p",[t._v("额外选项")]),e("ul",[e("li",[e("p",[t._v("resourceQuery")]),e("ul",[e("li",[t._v("和resource用法一样，不过针对的是匹配结果'?'后面的路径参数，可以调用resource中的text等")])])]),e("li",[e("p",[t._v("oneOf")]),e("ul",[e("li",[t._v("表示对该资源只应用第一个匹配的规则，一般结合resourceQuery")]),e("li",[t._v("path/to/foo.png?inline: 会匹配url-loader")]),e("li",[t._v("path/to/foo.png?other:会匹配file-loader")]),e("li",[t._v("path/to/foo.png: 会匹配file-loader")])])]),e("li",[e("p",[t._v("useEntry")]),e("ul",[e("li",[t._v("object类型，包含着每一个loader并且对应loader的配置文件")]),e("li",[t._v("options会传入loader，可以理解为loader的选项")])])]),e("li",[e("p",[t._v("use")]),e("ul",[e("li",[t._v("是对useEntry的集合，并且对每一个入口指定使用一个loader")])])])])])])])])]),e("li",[e("p",[t._v("4.Resolve解析")]),e("ul",[e("li",[e("p",[t._v("初步了解")]),e("ul",[e("li",[t._v("主要用来模块如何被解析，给webpack提供默认值")])])]),e("li",[e("p",[t._v("alias")]),e("ul",[e("li",[t._v("object类型，主要用来让import和require调用更方便，设置初始路径")])])]),e("li",[e("p",[t._v("enforceExtension")]),e("ul",[e("li",[t._v("Boolean类型， 默认false，表示引用不需要扩展名，为true时，import、require中引用必须加扩展名")])])]),e("li",[e("p",[t._v("extensions")]),e("ul",[e("li",[t._v("Array 自动解析不需要扩展名")])])]),e("li",[e("p",[t._v("modules")]),e("ul",[e("li",[t._v("Array webpack解析模块的时候需要搜索的目录，一般用于优先搜索和非node_modules文件中的自定义模块")])])])])]),e("li",[e("p",[t._v("5.Loader")]),e("ul",[e("li",[e("p",[t._v("概述")]),e("ul",[e("li",[t._v("通过使用不同的Loader，Webpack可以要把不同的文件都转成JS文件,比如CSS、ES6/7、JSX等，一般用于module的use中")])])])])]),e("li",[e("p",[t._v("6.Plugin插件")]),e("ul",[e("li",[t._v("Array 扩展webpack，在webpack构建流程中的特定时机注入扩展逻辑来改变构建结果和想要做的事情")])])]),e("li",[e("p",[t._v("7.webpack-dev-server")]),e("ul",[e("li",[t._v("开发中的server，webpack-dev-server可以快速搭建起本地服务，具体使用查看 webpack-dev-server")])])]),e("li",[e("p",[t._v("8.Devtool")]),e("ul",[e("li",[t._v("此选项控制是否生成，以及如何生成，官方推荐 SourceMapDevToolPlugin 和 source-map-loader 建议看官方文档 Devtool 主要用来控制打包品质和在dev环境的调试便捷度和编译的快慢")])])]),e("li",[e("p",[t._v("9.Watch")]),e("ul",[e("li",[t._v("webpack 可以监听文件变化，当它们修改后会重新编译和 HotModuleReplacementPlugin 有相似之处，监听文件变动热启动")])])])]),e("h2",[t._v("Webpack深入执行原理")]),e("h3",[t._v("（1）Webpack运行机制")]),e("ul",[e("li",[e("p",[t._v("运行过程")]),e("ul",[e("li",[t._v("初始化配置参数 -> 绑定事件钩子回调 -> 确定Entry逐一遍历 -> 使用loader编译文件 -> 输出文件")])])]),e("li",[e("p",[t._v("Webpack事件流")]),e("ul",[e("li",[e("p",[t._v("生产线")]),e("ul",[e("li",[t._v("Webpack 通过 Tapable 来组织这条复杂的生产线。 Webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条生产线中，去改变生产线的运作。 Webpack 的事件流机制保证了插件的有序性，使得整个系统扩展性很好。")]),e("li",[t._v("Webpack 就像一条生产线，要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的，多个流程之间有存在依赖关系，只有完成当前处理后才能交给下一个流程去处理。 插件就像是一个插入到生产线中的一个功能，在特定的时机对生产线上的资源做处理。")])])]),e("li",[e("p",[t._v("事件流")]),e("ul",[e("li",[t._v("我们将webpack事件流理解为webpack构建过程中的一系列事件，他们分别表示着不同的构建周期和状态，我们可以像在浏览器上监听click事件一样监听事件流上的事件，并且为它们挂载事件回调。我们也可以自定义事件并在合适时机进行广播，这一切都是使用了webpack自带的模块 Tapable 进行管理的。我们不需要自行安装 Tapable ，在webpack被安装的同时它也会一并被安装，如需使用，我们只需要在文件里直接 require 即可。")])])]),e("li",[e("p",[t._v("Tapable")]),e("ul",[e("li",[t._v("Tapable的原理其实就是我们在前端进阶过程中都会经历的EventEmit，通过发布者-订阅者模式实现")])])])])]),e("li",[e("p",[t._v("Webpack运行流程详解")]),e("ul",[e("li",[e("p",[t._v("总结图")])]),e("li",[e("p",[t._v("（1）初始化参数，绑定回调")]),e("ul",[e("li",[t._v("首先，webpack会读取你在命令行传入的配置以及项目里的 webpack.config.js 文件，初始化本次构建的配置参数，并且执行配置文件中的插件实例化语句，生成Compiler传入plugin的apply方法，为webpack事件流挂上自定义钩子。")])])]),e("li",[e("p",[t._v("（2）遍历入口")]),e("ul",[e("li",[t._v("webpack开始读取配置的Entries，递归遍历所有的入口文件")])])]),e("li",[e("p",[t._v("（3）使用loader编译文件")]),e("ul",[e("li",[t._v("Webpack进入其中一个入口文件，开始compilation过程。先使用用户配置好的loader对文件内容进行编译（buildModule），我们可以从传入事件回调的compilation上拿到module的resource（资源路径）、loaders（经过的loaders）等信息；之后，再将编译好的文件内容使用acorn解析生成AST静态语法树（normalModuleLoader），分析文件的依赖关系逐个拉取依赖模块并重复上述过程，最后将所有模块中的require语法替换成"),e("strong",[t._v("webpack_require")]),t._v("来模拟模块化操作。")])])]),e("li",[e("p",[t._v("（4）输出文件")]),e("ul",[e("li",[t._v("emit阶段，所有文件的编译及转化都已经完成，包含了最终输出的资源，我们可以在传入事件回调的compilation.assets 上拿到所需数据，其中包括即将输出的资源、代码块Chunk等等信息。")])])]),e("li",[e("p",[t._v("【AST】什么是AST？")]),e("ul",[e("li",[e("p",[t._v("定义")]),e("ul",[e("li",[t._v("是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。比如，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现；而类似于 if-condition-then 这样的条件跳转语句，可以使用带有两个分支的节点来表示。")])])]),e("li",[e("p",[t._v("例子")])]),e("li",[e("p",[t._v("目的")]),e("ul",[e("li",[t._v("转换成AST的目的就是将我们书写的字符串文件转换成计算机更容易识别的数据结构，这样更容易提取其中的关键信息，而这棵树在计算机上的表现形式，其实就是一个单纯的Object。")])])]),e("li",[e("p",[t._v("计算机眼中的语句")]),e("ul",[e("li",[t._v("示例是一个简单的声明赋值语句，经过AST转化后各部分内容的含义就更为清晰明了了。")])])])])])])]),e("li",[e("p",[t._v("webpack输出结果解析")]),e("ul",[e("li",[e("p",[t._v("未设置splitChuck")]),e("ul",[e("li",[t._v("如果我们没有设置splitChunk，我们只会在dist目录下看到一个main.js输出文件，过滤掉没用的注释还有一些目前不需要去考虑的Funciton，得到的代码大概是这样")]),e("li",[t._v("我们都知道其实webpack在浏览器实现模块化的本质就是将所有的代码都注入到同一个JS文件里，现在我们可以清晰明了地看出webpack最后生成的也不过只是一个IIFE，我们引入的所有模块都被一个function给包起来组装成一个对象，这个对象作为IIFE的实参被传递进去。")])])]),e("li",[e("p",[t._v("设置splitChuck")]),e("ul",[e("li",[t._v("如果我们配置了splitChunk，这时候输出的文件就和你的Chunk挂钩了")]),e("li",[t._v("这时候，IIFE的形参也变成了摆设，所有我们的模块都被放在了一个名为 webpackJsonp 的全局数组上，通过IIFE里的 webpackJsonpCallback 来处理数据。")])])])])]),e("li",[e("p",[t._v("总结")]),e("ul",[e("li",[t._v("纵观webpack构建流程，我们可以发现整个构建过程主要花费时间的部分也就是递归遍历各个entry然后寻找依赖逐个编译的过程，每次递归都需要经历 String->AST->String 的流程，经过loader还需要处理一些字符串或者执行一些JS脚本，介于node.js单线程的壁垒，webpack构建慢一直成为它饱受诟病的原因。")]),e("li",[t._v("利用了node.js原生的cluster模块去开辟多进程执行构建，不过在4之后大家就可以不用去纠结这一问题了，多进程构建已经被集成在webpack本身上了，除了增量编译，这也是4之所以能大幅度提升构建效率的原因之一。")])])])]),e("h3",[t._v("（2）编写自定义webpack loader")]),e("ul",[e("li",[e("p",[t._v("在Webpack中起编译作用的是loader")]),e("ul",[e("li",[t._v("在你不知道loader的本质之前你一定会觉得这是个很高大上的东西，正如计算机学科里的编译原理一样，里面一定有许多繁杂的操作。但实际上，loader只是一个普通的funciton，他会传入匹配到的文件内容(String)，你只需要对这些字符串做些处理就好了。")])])]),e("li",[e("p",[t._v("一个最简单的loader实例")]),e("ul",[e("li",[e("p",[t._v("代码")])]),e("li",[e("p",[t._v("使用")]),e("ul",[e("li",[t._v("使用它的方式和babel-loader一样，只需要在webpack.config.js的module.rules数组里加上这么一个对象就好了")])])]),e("li",[e("p",[t._v("效果")]),e("ul",[e("li",[t._v("这样，loader会去匹配所有以.js后缀结尾的文件并在内容前追加{};这样一段代码，我们可以在输出文件中看到效果")]),e("li",[t._v("所以，拿到了文件内容，你想对字符串进行怎样得处理都由你自定义～你可以引入babel库加个 babel(content) ，这样就实现了编译，也可以引入uglifyjs对文件内容进行字符串压缩，一切工作都由你自己定义。")])])])])])]),e("h3",[t._v("（3）编写自定义webpack plugin")]),e("ul",[e("li",[e("p",[t._v("Webpack plugin起到的作用，就是为Webpack Hook事件挂载回调，或者执行指定脚本。它实际上和webpack loader一样简单，其实它只是一个带有apply方法的class。")])]),e("li",[e("p",[t._v("一个简单的plugin实例")]),e("ul",[e("li",[e("p",[t._v("代码")])]),e("li",[e("p",[t._v("使用")]),e("ul",[e("li",[t._v("只需要在webpack.config.js 里 require 并实例化就可以了")])])]),e("li",[e("p",[t._v("理解")]),e("ul",[e("li",[t._v("每次我们需要使用某个plugin的时候都需要new一下实例化，自然，实例过程中传递的参数，也就成为了我们的构造函数里拿到的options了")]),e("li",[t._v("而实例化所有plugin的时机，便是在webpack初始化所有参数的时候，也就是事件流开始的时候。所以，如果配合 shell.js 等工具库，我们就可以在这时候执行文件操作等相关脚本，这就是webpack plugin所做的事情。")]),e("li",[t._v("如果你想在指定时机执行某些脚本，自然可以使用在webpack事件流上挂载回调的方法，在回调里执行你所需的操作。")])])])])])])])}],Bl={},Ul=Bl,Gl=Object(v["a"])(Ul,Fl,Wl,!1,null,"ed7c1526",null),Vl=Gl.exports,Xl=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{},[e("q-markdown",{attrs:{src:t.MainComponent}})],1)},Ql=[],Yl=e("ecbb"),Kl={data:function(){return{MainComponent:Yl["a"]}}},Zl=Kl,ti=Object(v["a"])(Zl,Xl,Ql,!1,null,"4f10a23f",null),ni=ti.exports,ei=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},ai=[],ri={},si=ri,oi=Object(v["a"])(si,ei,ai,!1,null,"eb2c2004",null),li=oi.exports,ii=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},ci=[],pi={},bi=pi,ui=Object(v["a"])(bi,ii,ci,!1,null,"6075d73f",null),vi=ui.exports,gi=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},mi=[],_i={},di=_i,hi=Object(v["a"])(di,gi,mi,!1,null,"3681be80",null),fi=hi.exports,yi=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Si=[],wi={},ki=wi,xi=Object(v["a"])(ki,yi,Si,!1,null,"0c8da5c1",null),Ci=xi.exports,ji=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},Pi=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("p",[t._v("综合类")]),e("p",[t._v("综合类 地址")]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/sb19871023/p/3894452.html",target:"_blank"}},[t._v("前端知识体系")])]),e("p",[e("a",{attrs:{href:"https://github.com/JacksonTian/fks",target:"_blank"}},[t._v("前端知识结构")])]),e("p",[e("a",{attrs:{href:"https://github.com/unruledboy/WebFrontEndStack",target:"_blank"}},[t._v("Web前端开发大系概览")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/unruledboy/p/WebFrontEndStack.html",target:"_blank"}},[t._v("Web前端开发大系概览-中文版")])]),e("p",[t._v("Web Front-end Stack v2.2 Web Front-end Stack v2.2")]),e("p",[e("a",{attrs:{href:"https://github.com/justjavac/free-programming-books-zh_CN",target:"_blank"}},[t._v("免费的编程中文书籍索引")])]),e("p",[e("a",{attrs:{href:"https://github.com/dypsilon/frontend-dev-bookmarks",target:"_blank"}},[t._v("前端书籍")])]),e("p",[e("a",{attrs:{href:"https://github.com/vhf/free-programming-books",target:"_blank"}},[t._v("前端免费书籍大全")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/sb19871023/p/3894452.html",target:"_blank"}},[t._v("前端知识体系")])]),e("p",[e("a",{attrs:{href:"https://github.com/justjavac/free-programming-books-zh_CN",target:"_blank"}},[t._v("免费的编程中文书籍索引")])]),e("p",[e("a",{attrs:{href:"http://study.163.com/course/introduction/224014.htm",target:"_blank"}},[t._v("智能社 - 精通JavaScript开发")])]),e("p",[e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript",target:"_blank"}},[t._v("重新介绍 JavaScript（JS 教程）")])]),e("p",[e("a",{attrs:{href:"http://v.163.com/special/opencourse/bianchengdaolun.html",target:"_blank"}},[t._v("麻省理工学院公开课：计算机科学及编程导论")])]),e("p",[e("a",{attrs:{href:"http://segmentfault.com/a/1190000002640298",target:"_blank"}},[t._v("JavaScript中的this陷阱的最全收集--没有之一")])]),e("p",[e("a",{attrs:{href:"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.html",target:"_blank"}},[t._v("JS函数式编程指南")])]),e("p",[e("a",{attrs:{href:"http://liubin.github.io/promises-book",target:"_blank"}},[t._v("JavaScript Promise迷你书（中文版）")])]),e("p",[e("a",{attrs:{href:"https://github.com/AlloyTeam/Mars",target:"_blank"}},[t._v("腾讯移动Web前端知识库")])]),e("p",[e("a",{attrs:{href:"https://github.com/Front-End-Developers-Hunan/Front-End-Develop-Guide",target:"_blank"}},[t._v("Front-End-Develop-Guide 前端开发指南")])]),e("p",[e("a",{attrs:{href:"https://li-xinyang.gitbooks.io/frontend-notebook/content",target:"_blank"}},[t._v("前端开发笔记本")])]),e("p",[e("a",{attrs:{href:"https://github.com/nieweidong/fetool",target:"_blank"}},[t._v("大前端工具集 - 聂微东")])]),e("p",[e("a",{attrs:{href:"https://dwqs.gitbooks.io/frontenddevhandbook/content",target:"_blank"}},[t._v("前端开发者手册")])]),e("p",[t._v("入门类")]),e("p",[t._v("入门类 地址")]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/jikey/p/3613082.html",target:"_blank"}},[t._v("前端入门教程")])]),e("p",[e("a",{attrs:{href:"http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000",target:"_blank"}},[t._v("瘳雪峰的Javascript教程")])]),e("p",[e("a",{attrs:{href:"http://www.imooc.com/view/11",target:"_blank"}},[t._v("jQuery基础教程")])]),e("p",[e("a",{attrs:{href:"http://www.imooc.com/view/506",target:"_blank"}},[t._v("前端工程师必备的PS技能——切图篇")])]),e("p",[e("a",{attrs:{href:"https://github.com/qiu-deqing/FE-learning",target:"_blank"}},[t._v("结合个人经历总结的前端入门方法")])]),e("p",[t._v("工具类")]),e("p",[t._v("工具类 地址")]),e("p",[e("a",{attrs:{href:"http://f2er.club/",target:"_blank"}},[t._v("前端人的俱乐部")])]),e("p",[e("a",{attrs:{href:"http://www.jeffjade.com/2015/12/15/2015-04-17-toss-sublime-text/#",target:"_blank"}},[t._v("如何优雅地使用Sublime\n                    Text")])]),e("p",[e("a",{attrs:{href:"http://www.jeffjade.com/2016/03/03/2016-03-02-how-to-use-atom/",target:"_blank"}},[t._v("新编码神器Atom使用纪要")])]),e("p",[e("a",{attrs:{href:"http://www.imooc.com/learn/93",target:"_blank"}},[t._v("css sprite 雪碧图制作")])]),e("p",[e("a",{attrs:{href:"http://www.imooc.com/learn/390",target:"_blank"}},[t._v("版本控制入门 – 搬进 Github")])]),e("p",[e("a",{attrs:{href:"http://www.imooc.com/learn/30",target:"_blank"}},[t._v("Grunt-beginner前端自动化工具")])]),e("p",[e("a",{attrs:{href:"https://github.com/judasn/IntelliJ-IDEA-Tutorial",target:"_blank"}},[t._v("IntelliJ IDEA 简体中文专题教程")])]),e("p",[e("a",{attrs:{href:"http://t.cn/8kZZ1Uy",target:"_blank"}},[t._v("Webstorm,InterllIdea,Phpstorm")])]),e("p",[e("a",{attrs:{href:"https://github.com/jikeytang/sublime-text",target:"_blank"}},[t._v("SublimeText")])]),e("p",[e("a",{attrs:{href:"https://atom.io",target:"_blank"}},[t._v("Atom")])]),e("p",[e("a",{attrs:{href:"https://code.visualstudio.com",target:"_blank"}},[t._v("visual studio code")])]),e("p",[t._v("综合效果搜索平台")]),e("p",[t._v("综合效果搜索平台 地址")]),e("p",[e("a",{attrs:{href:"http://zoommyapp.com/",target:"_blank"}},[t._v("zoommyapp.com")])]),e("p",[e("a",{attrs:{href:"https://unsplash.com/",target:"_blank"}},[t._v("unsplash.com")])]),e("p",[e("a",{attrs:{href:"https://www.pinterest.com/",target:"_blank"}},[t._v("www.pinterest.com")])]),e("p",[e("a",{attrs:{href:"http://nos.twnsnd.co",target:"_blank"}},[t._v("New Old Stock")])]),e("p",[e("a",{attrs:{href:"http://www.jq22.com",target:"_blank"}},[t._v("效果网")])]),e("p",[e("a",{attrs:{href:"http://huaban.com/",target:"_blank"}},[t._v("花瓣网")])]),e("p",[e("a",{attrs:{href:"http://www.topit.me/",target:"_blank"}},[t._v("优美图")])]),e("p",[e("a",{attrs:{href:"http://codepen.io/",target:"_blank"}},[t._v("codepen")])]),e("p",[e("a",{attrs:{href:"http://www.17sucai.com",target:"_blank"}},[t._v("17素材")])]),e("p",[e("a",{attrs:{href:"http://699pic.com/",target:"_blank"}},[t._v("摄图网")])]),e("p",[e("a",{attrs:{href:"http://microjs.com",target:"_blank"}},[t._v("常用的JavaScript代码片段")])]),e("p",[t._v("周报类")]),e("p",[t._v("周报类 地址")]),e("p",[e("a",{attrs:{href:"http://old.75team.com/weekly/",target:"_blank"}},[t._v("奇舞周刊")])]),e("p",[e("a",{attrs:{href:"http://weekly.manong.io",target:"_blank"}},[t._v("码农周刊")])]),e("p",[e("a",{attrs:{href:"http://www.kancloud.cn/jsfront/month/82796",target:"_blank"}},[t._v("JS前端开发群月报")])]),e("p",[e("a",{attrs:{href:"http://www.css88.com",target:"_blank"}},[t._v("WEB前端开发")])]),e("p",[e("a",{attrs:{href:"http://www.jstips.co",target:"_blank"}},[t._v("A JS tip per day!")])]),e("p",[e("a",{attrs:{href:"https://github.com/PaicHyperionDev/MobileDevWeekly",target:"_blank"}},[t._v("平安科技移动开发二队技术周报")])]),e("p",[t._v("开发中心")]),e("p",[t._v("开发中心 地址")]),e("p",[e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript",target:"_blank"}},[t._v("mozilla js参考")])]),e("p",[e("a",{attrs:{href:"https://developer.chrome.com/extensions/api_index.html",target:"_blank"}},[t._v("chrome开发中心（chrome的内核已转向blink）")])]),e("p",[e("a",{attrs:{href:"https://developer.apple.com/library/safari/navigation",target:"_blank"}},[t._v("safari开发中心")])]),e("p",[e("a",{attrs:{href:"https://msdn.microsoft.com/zh-cn/library/d1et7k7c",target:"_blank"}},[t._v("microsoft js参考")])]),e("p",[e("a",{attrs:{href:"http://sanshi.me/articles/JavaScript-Garden-CN/html/index.html",target:"_blank"}},[t._v("js秘密花园")])]),e("p",[e("a",{attrs:{href:"http://bonsaiden.github.io/JavaScript-Garden/zh",target:"_blank"}},[t._v("js秘密花园")])]),e("p",[e("a",{attrs:{href:"http://www.w3help.org",target:"_blank"}},[t._v("w3help")])]),e("p",[t._v("Nodejs")]),e("p",[t._v("Nodejs 地址")]),e("p",[e("a",{attrs:{href:"http://liuqing.pw",target:"_blank"}},[t._v("nodejs 篇幅比较巨大")])]),e("p",[e("a",{attrs:{href:"https://github.com/alsotang/node-lessons",target:"_blank"}},[t._v("Node.js 包教不包会")])]),e("p",[e("a",{attrs:{href:"http://www.rainweb.cn/article/category/Nodejs",target:"_blank"}},[t._v("篇幅比较少")])]),e("p",[e("a",{attrs:{href:"http://www.w3cfuns.com/article-5598538-1-1.html",target:"_blank"}},[t._v("node express 入门教程")])]),e("p",[e("a",{attrs:{href:"http://my.oschina.net/u/568264/blog/193773",target:"_blank"}},[t._v("nodejs定时任务")])]),e("p",[e("a",{attrs:{href:"http://60sky.com",target:"_blank"}},[t._v("一个nodejs博客")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/yexiaochai/p/3536547.html",target:"_blank"}},[t._v("【NodeJS 学习笔记04】新闻发布系统")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/qqloving/p/3541099.html",target:"_blank"}},[t._v("过年7天乐，学nodejs 也快乐")])]),e("p",[e("a",{attrs:{href:"https://github.com/nqdeng/7-days-nodejs",target:"_blank"}},[t._v("七天学会NodeJS")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/zhongweiv/p/nodejs_events.html",target:"_blank"}},[t._v("Nodejs学习笔记（二）--- 事件模块")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/liusuqi/p/3735491.html",target:"_blank"}},[t._v("nodejs入门")])]),e("p",[e("a",{attrs:{href:"https://github.com/zensh/jsgen",target:"_blank"}},[t._v("angularjs nodejs")])]),e("p",[e("a",{attrs:{href:"http://blog.fens.me/series-nodejs",target:"_blank"}},[t._v("从零开始nodejs系列文章")])]),e("p",[e("a",{attrs:{href:"http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb",target:"_blank"}},[t._v("理解nodejs")])]),e("p",[e("a",{attrs:{href:"http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop",target:"_blank"}},[t._v("nodejs事件轮询")])]),e("p",[e("a",{attrs:{href:"http://www.nodebeginner.org/index-zh-cn.html",target:"_blank"}},[t._v("node入门")])]),e("p",[e("a",{attrs:{href:"http://ourjs.com/detail/53e1f281c5910a9806000001",target:"_blank"}},[t._v("nodejs cms")])]),e("p",[e("a",{attrs:{href:"http://ourjs.com/detail/529ca5950cb6498814000005",target:"_blank"}},[t._v("Node初学者入门，一本全面的NodeJS教程")])]),e("p",[e("a",{attrs:{href:"http://www.barretlee.com/blog/2015/10/07/debug-nodejs-in-command-line",target:"_blank"}},[t._v("NodeJS的代码调试和性能调优")])]),e("p",[t._v("综合API")]),e("p",[t._v("综合API 地址")]),e("p",[e("a",{attrs:{href:"http://www.javascripting.com",target:"_blank"}},[t._v("javascripting")])]),e("p",[e("a",{attrs:{href:"http://microjs.com",target:"_blank"}},[t._v("各种流行库搜索")])]),e("p",[e("a",{attrs:{href:"http://www.runoob.com",target:"_blank"}},[t._v("runoob.com-包含各种API集合")])]),e("p",[e("a",{attrs:{href:"http://tool.oschina.net/apidocs",target:"_blank"}},[t._v("开源中国在线API文档合集")])]),e("p",[e("a",{attrs:{href:"http://devdocs.io",target:"_blank"}},[t._v("devdocs")])]),e("p",[t._v("Ecmascript")]),e("p",[t._v("Ecmascript 地址")]),e("p",[e("a",{attrs:{href:"https://leanpub.com/understandinges6/read",target:"_blank"}},[t._v("Understanding ECMAScript 6 - Nicholas C.\n                    Zakas")])]),e("p",[e("a",{attrs:{href:"https://leanpub.com/exploring-es6/read",target:"_blank"}},[t._v("exploring-es6")])]),e("p",[e("a",{attrs:{href:"https://github.com/es6-org/exploring-es6",target:"_blank"}},[t._v("exploring-es6翻译")])]),e("p",[e("a",{attrs:{href:"http://es6-org.github.io/exploring-es6",target:"_blank"}},[t._v("exploring-es6翻译后预览")])]),e("p",[e("a",{attrs:{href:"http://es6.ruanyifeng.com",target:"_blank"}},[t._v("阮一峰 es6")])]),e("p",[e("a",{attrs:{href:"http://javascript.ruanyifeng.com",target:"_blank"}},[t._v("阮一峰 Javascript")])]),e("p",[e("a",{attrs:{href:"http://yanhaijing.com/es5",target:"_blank"}},[t._v("ECMA-262，第 5 版")])]),e("p",[e("a",{attrs:{href:"http://es5.github.io",target:"_blank"}},[t._v("es5")])]),e("p",[t._v("Js template")]),e("p",[t._v("Js template 地址")]),e("p",[e("a",{attrs:{href:"http://garann.github.io/template-chooser",target:"_blank"}},[t._v("template-chooser")])]),e("p",[e("a",{attrs:{href:"https://github.com/aui/artTemplate",target:"_blank"}},[t._v("artTemplate")])]),e("p",[e("a",{attrs:{href:"https://github.com/aui/tmodjs/blob/master/README.md",target:"_blank"}},[t._v("tomdjs")])]),e("p",[e("a",{attrs:{href:"http://juicer.name/docs/docs_zh_cn.html",target:"_blank"}},[t._v("淘宝模板juicer模板")])]),e("p",[e("a",{attrs:{href:"http://koen301.github.io/fxtpl",target:"_blank"}},[t._v("Fxtpl v1.0 繁星前端模板引擎")])]),e("p",[e("a",{attrs:{href:"http://laytpl.layui.com",target:"_blank"}},[t._v("laytpl")])]),e("p",[e("a",{attrs:{href:"https://github.com/mozilla/nunjucks",target:"_blank"}},[t._v("mozilla - nunjucks")])]),e("p",[e("a",{attrs:{href:"https://github.com/PaulGuo/Juicer",target:"_blank"}},[t._v("Juicer")])]),e("p",[e("a",{attrs:{href:"http://akdubya.github.io/dustjs",target:"_blank"}},[t._v("dustjs")])]),e("p",[e("a",{attrs:{href:"http://ecomfe.github.io/etpl",target:"_blank"}},[t._v("etpl")])]),e("p",[t._v("CSS")]),e("p",[t._v("CSS 地址")]),e("p",[e("a",{attrs:{href:"http://tympanus.net/codrops/css_reference",target:"_blank"}},[t._v("CSS 语法参考")])]),e("p",[e("a",{attrs:{href:"http://isux.tencent.com/css3/index.html",target:"_blank"}},[t._v("CSS3动画手册")])]),e("p",[e("a",{attrs:{href:"http://isux.tencent.com/css3/tools.html",target:"_blank"}},[t._v("腾讯css3动画制作工具")])]),e("p",[e("a",{attrs:{href:"http://linxz.github.io/tianyizone",target:"_blank"}},[t._v("志爷css小工具集合")])]),e("p",[e("a",{attrs:{href:"http://www.note12.com/category/blog/2014-6-5/538fe0a9f786f1b7019a4dfb",target:"_blank"}},[t._v("css3 js\n                    移动大杂烩")])]),e("p",[e("a",{attrs:{href:"http://bouncejs.com",target:"_blank"}},[t._v("bouncejs 触摸库")])]),e("p",[e("a",{attrs:{href:"http://fian.my.id/Waves",target:"_blank"}},[t._v("css3 按钮动画")])]),e("p",[e("a",{attrs:{href:"http://daneden.github.io/animate.css",target:"_blank"}},[t._v("animate.css")])]),e("p",[e("a",{attrs:{href:"http://www.alloyteam.com/2015/10/8536",target:"_blank"}},[t._v("全局CSS的终结(狗带 [译]")])]),e("p",[e("a",{attrs:{href:"http://browserhacks.com",target:"_blank"}},[t._v("browserhacks")])]),e("p",[t._v("Angularjs")]),e("p",[t._v("Angularjs 地址")]),e("p",[e("a",{attrs:{href:"https://github.com/dolymood/AngularLearning",target:"_blank"}},[t._v("Angular.js 的一些学习资源")])]),e("p",[e("a",{attrs:{href:"http://angularjs.cn",target:"_blank"}},[t._v("angularjs中文社区")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/xuwenmin888/p/3739096.html",target:"_blank"}},[t._v("Angularjs源码学习")])]),e("p",[e("a",{attrs:{href:"http://www.ifeenan.com/?c=AngularJS",target:"_blank"}},[t._v("Angularjs源码学习")])]),e("p",[e("a",{attrs:{href:"http://angular-ui.github.io/bootstrap",target:"_blank"}},[t._v("angular对bootstrap的封装")])]),e("p",[e("a",{attrs:{href:"https://cnodejs.org/topic/51404e0f069911196d2e3923",target:"_blank"}},[t._v("angularjs + nodejs")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/lvdabao/tag/AngularJs",target:"_blank"}},[t._v("吕大豹 Angularjs")])]),e("p",[e("a",{attrs:{href:"http://www.infoq.com/cn/news/2013/02/angular-web-app",target:"_blank"}},[t._v("AngularJS 最佳实践")])]),e("p",[e("a",{attrs:{href:"http://www.lovelucy.info/angularjs-best-practices.html",target:"_blank"}},[t._v("Angular的一些扩展指令")])]),e("p",[e("a",{attrs:{href:"https://github.com/Pasvaz/bindonce",target:"_blank"}},[t._v("Angular数据绑定原理")])]),e("p",[e("a",{attrs:{href:"https://github.com/angular-ui",target:"_blank"}},[t._v("一些扩展Angular UI组件")])]),e("p",[e("a",{attrs:{href:"http://voidcanvas.com/emberjs-vs-angularjs-performance-testing",target:"_blank"}},[t._v("Ember和AngularJS的性能测试")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/powertoolsteam/p/angularjs-introdection.html",target:"_blank"}},[t._v("带你走近AngularJS -\n                    基本功能介绍")])]),e("p",[e("a",{attrs:{href:"http://angular.duapp.com/docs/guide",target:"_blank"}},[t._v("Angularjs开发指南")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/amosli/p/3710648.html",target:"_blank"}},[t._v("Angularjs学习")])]),e("p",[e("a",{attrs:{href:"http://www.rainweb.cn/article/angularjs-jquery.html",target:"_blank"}},[t._v("不要带着jQuery的思维去学习AngularJS")])]),e("p",[e("a",{attrs:{href:"http://wangjiatao.diandian.com/?tag=angularjs",target:"_blank"}},[t._v("angularjs 学习笔记")])]),e("p",[e("a",{attrs:{href:"http://www.angularjs.cn/T008",target:"_blank"}},[t._v("angularjs 开发指南")])]),e("p",[e("a",{attrs:{href:"https://github.com/jmcunningham/AngularJS-Learning",target:"_blank"}},[t._v("angularjs 英文资料")])]),e("p",[e("a",{attrs:{href:"http://angular-ui.github.io/bootstrap",target:"_blank"}},[t._v("angular bootstrap")])]),e("p",[e("a",{attrs:{href:"https://github.com/opitzconsulting/jquery-mobile-angular-adapter",target:"_blank"}},[t._v("angular jq\n                    mobile")])]),e("p",[e("a",{attrs:{href:"http://mgcrea.github.io/angular-strap",target:"_blank"}},[t._v("angular ui")])]),e("p",[e("a",{attrs:{href:"http://www.tuicool.com/articles/7ZZVr2",target:"_blank"}},[t._v("整合jQuery Mobile+AngularJS经验谈")])]),e("p",[e("a",{attrs:{href:"http://blog.jobbole.com/46589/",target:"_blank"}},[t._v("有jQuery背景，该如何用AngularJS编程思想")])]),e("p",[e("a",{attrs:{href:"http://each.sinaapp.com/angular",target:"_blank"}},[t._v("AngularJS在线教程")])]),e("p",[e("a",{attrs:{href:"http://www.zouyesheng.com/angular.html",target:"_blank"}},[t._v("angular学习笔记")])]),e("p",[t._v("React")]),e("p",[t._v("React 地址")]),e("p",[e("a",{attrs:{href:"http://www.react-china.org",target:"_blank"}},[t._v("react.js 中文论坛")])]),e("p",[e("a",{attrs:{href:"https://facebook.github.io/react/index.html",target:"_blank"}},[t._v("react.js 官方网址")])]),e("p",[e("a",{attrs:{href:"https://facebook.github.io/react/docs/getting-started.html",target:"_blank"}},[t._v("react.js 官方文档")])]),e("p",[e("a",{attrs:{href:"http://material-ui.com/#",target:"_blank"}},[t._v("react.js material UI")])]),e("p",[e("a",{attrs:{href:"http://touchstonejs.io",target:"_blank"}},[t._v("react.js TouchstoneJS UI")])]),e("p",[e("a",{attrs:{href:"http://amazeui.org/react",target:"_blank"}},[t._v("react.js amazeui UI")])]),e("p",[e("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2015/03/react.html",target:"_blank"}},[t._v("React 入门实例教程 - 阮一峰")])]),e("p",[e("a",{attrs:{href:"http://wiki.jikexueyuan.com/project/react-native",target:"_blank"}},[t._v("React Native 中文版")])]),e("p",[e("a",{attrs:{href:"http://www.html-js.com/article/Fakefish%203053",target:"_blank"}},[t._v("Webpack 和 React 小书 - 前端乱炖")])]),e("p",[e("a",{attrs:{href:"https://fakefish.github.io/react-webpack-cookbook",target:"_blank"}},[t._v("Webpack 和 React 小书 - gitbook")])]),e("p",[e("a",{attrs:{href:"https://github.com/webpack/webpack",target:"_blank"}},[t._v("webpack")])]),e("p",[e("a",{attrs:{href:"http://html-js.com/article/3009",target:"_blank"}},[t._v("Webpack，101入门体验")])]),e("p",[e("a",{attrs:{href:"http://html-js.com/article/3113",target:"_blank"}},[t._v("webpack入门教程")])]),e("p",[e("a",{attrs:{href:"http://segmentfault.com/a/1190000003499526",target:"_blank"}},[t._v("基于webpack搭建前端工程解决方案探索")])]),e("p",[e("a",{attrs:{href:"http://www.piliyu.com",target:"_blank"}},[t._v("React原创实战视频教程")])]),e("p",[t._v("vue")]),e("p",[t._v("vue 地址")]),e("p",[e("a",{attrs:{href:"http://cn.vuejs.org",target:"_blank"}},[t._v("Vue")])]),e("p",[e("a",{attrs:{href:"http://forum.vuejs.org",target:"_blank"}},[t._v("Vue 论坛")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/aaronjs/p/3660102.html",target:"_blank"}},[t._v("Vue 入门指南")])]),e("p",[e("a",{attrs:{href:"http://segmentfault.com/a/1190000000411057",target:"_blank"}},[t._v("Vue 的一些资源索引")])]),e("p",[e("a",{attrs:{href:"https://github.com/vuejs/awesome-vue",target:"_blank"}},[t._v("awesome-vue")])]),e("p",[t._v("移动端API")]),e("p",[t._v("移动端API 地址")]),e("p",[e("a",{attrs:{href:"https://github.com/jtyjty99999/mobileTech",target:"_blank"}},[t._v("99移动端知识集合")])]),e("p",[e("a",{attrs:{href:"https://github.com/AlloyTeam/Mars",target:"_blank"}},[t._v("移动端前端开发知识库")])]),e("p",[e("a",{attrs:{href:"http://caibaojian.com/mobile-web-bug.html",target:"_blank"}},[t._v("移动前端的一些坑和解决方法（外观表现）")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/PeunZhang/p/3407453.html",target:"_blank"}},[t._v("【原】移动web资源整理")])]),e("p",[e("a",{attrs:{href:"http://mweb.baidu.com/zeptoapi",target:"_blank"}},[t._v("zepto 1.0 中文手册")])]),e("p",[e("a",{attrs:{href:"http://www.html-5.cn/Manual/Zepto",target:"_blank"}},[t._v("zepto 1.0 中文手册")])]),e("p",[e("a",{attrs:{href:"http://www.css88.com/doc/zeptojs_api",target:"_blank"}},[t._v("zepto 1.1.2")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/sky000/archive/2013/03/29/2988952.html",target:"_blank"}},[t._v("zepto 中文注释")])]),e("p",[e("a",{attrs:{href:"http://app-framework-software.intel.com/api.php",target:"_blank"}},[t._v("jqmobile 手册")])]),e("p",[e("a",{attrs:{href:"https://github.com/maxzhang/maxzhang.github.com/issues",target:"_blank"}},[t._v("移动浏览器开发集合")])]),e("p",[e("a",{attrs:{href:"https://github.com/hoosin/mobile-web-favorites",target:"_blank"}},[t._v("移动开发大杂烩")])]),e("p",[t._v("jQuery")]),e("p",[t._v("jQuery 地址")]),e("p",[e("a",{attrs:{href:"http://www.jquery123.com",target:"_blank"}},[t._v("jQuery API 中文文档")])]),e("p",[e("a",{attrs:{href:"http://hemin.cn/jq",target:"_blank"}},[t._v("hemin 在线版")])]),e("p",[e("a",{attrs:{href:"http://www.css88.com/jqapi-1.9/on",target:"_blank"}},[t._v("css88 jq api")])]),e("p",[e("a",{attrs:{href:"http://www.css88.com/jquery-ui-api",target:"_blank"}},[t._v("css88 jqui api")])]),e("p",[e("a",{attrs:{href:"http://learn.jquery.com",target:"_blank"}},[t._v("学习jquery")])]),e("p",[e("a",{attrs:{href:"http://james.padolsey.com/jquery",target:"_blank"}},[t._v("jquery 源码查找")])]),e("p",[t._v("D3")]),e("p",[t._v("D3 地址")]),e("p",[e("a",{attrs:{href:"https://github.com/mbostock/d3/wiki/Tutorials",target:"_blank"}},[t._v("d3 Tutorials")])]),e("p",[e("a",{attrs:{href:"https://github.com/mbostock/d3/wiki/Gallery",target:"_blank"}},[t._v("Gallery")])]),e("p",[e("a",{attrs:{href:"http://datavisual.lofter.com/post/40cf3a_188e535",target:"_blank"}},[t._v("lofter")])]),e("p",[e("a",{attrs:{href:"http://alanland.iteye.com/blog/1878595",target:"_blank"}},[t._v("iteye")])]),e("p",[e("a",{attrs:{href:"http://javascript.ruanyifeng.com/library/d3.html",target:"_blank"}},[t._v("ruanyifeng")])]),e("p",[t._v("Requriejs")]),e("p",[t._v("Requriejs 地址")]),e("p",[e("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2012/10/javascript_module.html",target:"_blank"}},[t._v("Javascript模块化编程（一）：模块的写法")])]),e("p",[e("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html",target:"_blank"}},[t._v("Javascript模块化编程（二）：AMD规范")])]),e("p",[e("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2012/11/require_js.html",target:"_blank"}},[t._v("Javascript模块化编程（三）：require.js的用法")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/snandy/archive/2012/05/22/2513652.html",target:"_blank"}},[t._v("RequireJS入门（一）")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/snandy/archive/2012/05/23/2513712.html",target:"_blank"}},[t._v("RequireJS入门（二）")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/snandy/archive/2012/06/08/2538001.html",target:"_blank"}},[t._v("RequireJS进阶（三）")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/yexiaochai/p/3632580.html",target:"_blank"}},[t._v("requrie源码学习")])]),e("p",[e("a",{attrs:{href:"http://www.oschina.net/translate/getting-started-with-the-requirejs-library",target:"_blank"}},[t._v("requrie\n                    入门指南")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/yexiaochai/p/3214926.html",target:"_blank"}},[t._v("requrieJS 学习笔记")])]),e("p",[e("a",{attrs:{href:"http://cyj.me/why-seajs/requirejs/",target:"_blank"}},[t._v("requriejs 其一")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/yexiaochai/p/3221081.html",target:"_blank"}},[t._v("require backbone结合")])]),e("p",[t._v("Seajs")]),e("p",[t._v("Seajs 地址")]),e("p",[e("a",{attrs:{href:"http://seajs.org",target:"_blank"}},[t._v("seajs")])]),e("p",[e("a",{attrs:{href:"http://cyj.me/why-seajs/zh",target:"_blank"}},[t._v("seajs 中文手册")])]),e("p",[t._v("Less,sass")]),e("p",[t._v("Less,sass 地址")]),e("p",[e("a",{attrs:{href:"http://www.w3cplus.com/sassguide",target:"_blank"}},[t._v("sass")])]),e("p",[e("a",{attrs:{href:"http://www.sass.hk",target:"_blank"}},[t._v("sass教程-sass中国")])]),e("p",[e("a",{attrs:{href:"http://sass.bootcss.com",target:"_blank"}},[t._v("Sass 中文文档")])]),e("p",[e("a",{attrs:{href:"http://less.bootcss.com",target:"_blank"}},[t._v("less")])]),e("p",[t._v("Markdown")]),e("p",[t._v("Markdown 地址")]),e("p",[e("a",{attrs:{href:"http://wowubuntu.com/markdown",target:"_blank"}},[t._v("Markdown 语法说明 (简体中文版")])]),e("p",[e("a",{attrs:{href:"https://github.com/LearnShare/Learning-Markdown/blob/master/README.md",target:"_blank"}},[t._v("markdown入门参考")])]),e("p",[e("a",{attrs:{href:"https://www.gitbook.com",target:"_blank"}},[t._v("gitbook")])]),e("p",[e("a",{attrs:{href:"https://www.zybuluo.com/mdeditor",target:"_blank"}},[t._v("mdeditor")])]),e("p",[e("a",{attrs:{href:"https://stackedit.io",target:"_blank"}},[t._v("stackedit")])]),e("p",[e("a",{attrs:{href:"http://bh-lay.github.io/mditor",target:"_blank"}},[t._v("mditor")])]),e("p",[e("a",{attrs:{href:"https://github.com/lepture/editor",target:"_blank"}},[t._v("lepture-editor")])]),e("p",[e("a",{attrs:{href:"https://github.com/jbt/markdown-editor",target:"_blank"}},[t._v("markdown-editor")])]),e("p",[e("a",{attrs:{href:"https://www.zybuluo.com",target:"_blank"}},[t._v("作业部落")])]),e("p",[t._v("兼容性")]),e("p",[t._v("兼容性 地址")]),e("p",[e("a",{attrs:{href:"http://kangax.github.io/compat-table/es6",target:"_blank"}},[t._v("esma 兼容列表")])]),e("p",[e("a",{attrs:{href:"http://jigsaw.w3.org/css-validator/validator.html.zh-cn",target:"_blank"}},[t._v("W3C CSS验证服务")])]),e("p",[e("a",{attrs:{href:"http://caniuse.com/#index",target:"_blank"}},[t._v("caniuse")])]),e("p",[e("a",{attrs:{href:"http://csscreator.com/properties",target:"_blank"}},[t._v("csscreator")])]),e("p",[e("a",{attrs:{href:"https://msdn.microsoft.com/zh-cn/library/cc351024",target:"_blank"}},[t._v("microsoft")])]),e("p",[e("a",{attrs:{href:"http://www.responsinator.com",target:"_blank"}},[t._v("在线测兼容-移动端")])]),e("p",[e("a",{attrs:{href:"https://www.manymo.com/emulators",target:"_blank"}},[t._v("emulators")])]),e("p",[t._v("UI相关")]),e("p",[t._v("UI相关 地址")]),e("p",[e("a",{attrs:{href:"http://v3.bootcss.com",target:"_blank"}},[t._v("bootcss")])]),e("p",[e("a",{attrs:{href:"http://www.w3cplus.com/MetroUICSS",target:"_blank"}},[t._v("MetroUICSS")])]),e("p",[e("a",{attrs:{href:"http://semantic-ui.com",target:"_blank"}},[t._v("semantic")])]),e("p",[e("a",{attrs:{href:"http://alexwolfe.github.io/Buttons",target:"_blank"}},[t._v("Buttons")])]),e("p",[e("a",{attrs:{href:"http://hiloki.github.io/kitecss",target:"_blank"}},[t._v("kitecss")])]),e("p",[e("a",{attrs:{href:"http://www.pintuer.com",target:"_blank"}},[t._v("pintuer")])]),e("p",[e("a",{attrs:{href:"http://amazeui.org",target:"_blank"}},[t._v("amazeui")])]),e("p",[e("a",{attrs:{href:"http://www.worldhello.net/gotgithub/index.html",target:"_blank"}},[t._v("worldhello")])]),e("p",[e("a",{attrs:{href:"http://igit.linuxtoy.org/contents.html",target:"_blank"}},[t._v("linuxtoy")])]),e("p",[e("a",{attrs:{href:"http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn",target:"_blank"}},[t._v("gitmagic")])]),e("p",[e("a",{attrs:{href:"http://rogerdudler.github.io/git-guide/index.zh.html",target:"_blank"}},[t._v("rogerdudler")])]),e("p",[e("a",{attrs:{href:"http://gitref.justjavac.com",target:"_blank"}},[t._v("gitref")])]),e("p",[e("a",{attrs:{href:"http://git-scm.com/book/zh",target:"_blank"}},[t._v("book")])]),e("p",[e("a",{attrs:{href:"http://gogojimmy.net/2012/01/17/how-to-use-git-1-git-basic",target:"_blank"}},[t._v("gogojimmy")])]),e("p",[t._v("其它API")]),e("p",[t._v("其它API 地址")]),e("p",[e("a",{attrs:{href:"http://segmentfault.com/bookmark/1230000002521721",target:"_blank"}},[t._v("HTTP API 设计指南")])]),e("p",[t._v("javascript流行库汇总 javascriptoo")]),e("p",[e("a",{attrs:{href:"http://niceue.com/validator/demo/index.php",target:"_blank"}},[t._v("验证api")])]),e("p",[e("a",{attrs:{href:"http://www.css88.com/doc/underscore",target:"_blank"}},[t._v("underscore 中文手册")])]),e("p",[e("a",{attrs:{href:"http://www.html-js.com/article/Underscorejs-source-code-analysis-of-underscorejs-source-code-analysis%203031",target:"_blank"}},[t._v("underscore源码分析")])]),e("p",[e("a",{attrs:{href:"http://yalishizhude.github.io/tags/underscore",target:"_blank"}},[t._v("underscore源码分析-亚里士朱德的博客")])]),e("p",[e("a",{attrs:{href:"http://underscorejs.org",target:"_blank"}},[t._v("underscrejs en api")])]),e("p",[e("a",{attrs:{href:"https://lodash.com",target:"_blank"}},[t._v("lodash - underscore的代替品")])]),e("p",[e("a",{attrs:{href:"http://extjs-doc-cn.github.io/ext4api",target:"_blank"}},[t._v("ext4api")])]),e("p",[e("a",{attrs:{href:"http://www.csser.com/tools/backbone/backbone.js.html",target:"_blank"}},[t._v("backbone 中文手册")])]),e("p",[e("a",{attrs:{href:"http://dev.qwrap.com/resource/js/_docs/_youa/#/qw/base/loadJs_.htm",target:"_blank"}},[t._v("qwrap手册")])]),e("p",[e("a",{attrs:{href:"http://easings.net/zh-cn",target:"_blank"}},[t._v("缓动函数")])]),e("p",[e("a",{attrs:{href:"http://www.w3school.com.cn/svg/svg_reference.asp",target:"_blank"}},[t._v("svg 中文参考")])]),e("p",[e("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/SVG",target:"_blank"}},[t._v("svg mdn参考")])]),e("p",[e("a",{attrs:{href:"https://github.com/gabelerner/canvg",target:"_blank"}},[t._v("svg 导出 canvas")])]),e("p",[e("a",{attrs:{href:"https://github.com/exupero/saveSvgAsPng",target:"_blank"}},[t._v("svg 导出 png")])]),e("p",[e("a",{attrs:{href:"http://www.zamzar.com/convert/ai-to-svg",target:"_blank"}},[t._v("ai-to-svg")])]),e("p",[e("a",{attrs:{href:"https://github.com/machao/localStorage",target:"_blank"}},[t._v("localStorage 库")])]),e("p",[t._v("图表类")]),e("p",[t._v("图表类 地址")]),e("p",[e("a",{attrs:{href:"http://www.hcharts.cn/api/index.php",target:"_blank"}},[t._v("Highcharts 中文API")])]),e("p",[e("a",{attrs:{href:"http://api.highcharts.com/highcharts",target:"_blank"}},[t._v("Highcharts 英文API")])]),e("p",[e("a",{attrs:{href:"http://echarts.baidu.com/",target:"_blank"}},[t._v("ECharts 百度的图表软件")])]),e("p",[e("a",{attrs:{href:"http://lbs.amap.com/api",target:"_blank"}},[t._v("高德地图")])]),e("p",[e("a",{attrs:{href:"http://paperjs.org",target:"_blank"}},[t._v("开源的矢量图脚本框架")])]),e("p",[e("a",{attrs:{href:"http://jvectormap.com",target:"_blank"}},[t._v("svg 地图")])]),e("p",[t._v("正则")]),e("p",[t._v("正则 地址")]),e("p",[e("a",{attrs:{href:"http://segmentfault.com/a/1190000002471140",target:"_blank"}},[t._v("JS正则表达式元字符")])]),e("p",[e("a",{attrs:{href:"http://deerchao.net/tutorials/regex/regex.htm",target:"_blank"}},[t._v("正则表达式30分钟入门教程")])]),e("p",[e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions",target:"_blank"}},[t._v("MDN-正则表达式")])]),e("p",[e("a",{attrs:{href:"http://javascript.ruanyifeng.com/stdlib/regexp.html",target:"_blank"}},[t._v("ruanyifeng - RegExp对象")])]),e("p",[e("a",{attrs:{href:"http://div.io/topic/764?page=1",target:"_blank"}},[t._v("小胡子哥 - 进阶正则表达式")])]),e("p",[e("a",{attrs:{href:"https://github.com/Cedriking/is.js/blob/master/is.js",target:"_blank"}},[t._v("is.js")])]),e("p",[e("a",{attrs:{href:"http://regexper.com",target:"_blank"}},[t._v("正则在线测试")])]),e("p",[t._v("前端")]),e("p",[t._v("前端 地址")]),e("p",[e("a",{attrs:{href:"http://alloyteam.github.io/CodeGuide",target:"_blank"}},[t._v("通过分析github代码库总结出来的工程师代码书写习惯")])]),e("p",[e("a",{attrs:{href:"http://codeguide.bootcss.com",target:"_blank"}},[t._v("HTML&CSS编码规范 by @mdo")])]),e("p",[e("a",{attrs:{href:"http://www.alloyteam.com/2011/10/css-on-team-naming/",target:"_blank"}},[t._v("团队合作的css命名规范-腾讯AlloyTeam前端团队")])]),e("p",[e("a",{attrs:{href:"http://yuwenhui.github.io",target:"_blank"}},[t._v("前端编码规范之js - by yuwenhui")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/hustskyking/p/javascript-spec.html",target:"_blank"}},[t._v("前端编码规范之js - by 李靖")])]),e("p",[e("a",{attrs:{href:"http://zhibimo.com/read/Ashu/front-end-style-guide",target:"_blank"}},[t._v("前端开发规范手册")])]),e("p",[e("a",{attrs:{href:"https://github.com/yuche/javascript#table-of-contents",target:"_blank"}},[t._v("Airbnb JavaScript\n                    编码规范（简体中文版）")])]),e("p",[e("a",{attrs:{href:"http://www.zhihu.com/question/20351507",target:"_blank"}},[t._v("AMD与CMD规范的区别")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/tugenhua0707/p/3507957.html",target:"_blank"}},[t._v("AMD与CMD规范的区别")])]),e("p",[e("a",{attrs:{href:"http://docs.kissyui.com/1.4/docs/html/tutorials/style-guide/kissy-source-style.html",target:"_blank"}},[t._v("KISSY 源码规范")])]),e("p",[e("a",{attrs:{href:"http://codeguide.bootcss.com",target:"_blank"}},[t._v("bt编码规范")])]),e("p",[e("a",{attrs:{href:"https://github.com/Suxiaogang/Code_Guide",target:"_blank"}},[t._v("规范加强版")])]),e("p",[e("a",{attrs:{href:"http://blog.jobbole.com/79075",target:"_blank"}},[t._v("前端代码规范 及 最佳实践")])]),e("p",[e("a",{attrs:{href:"http://coderlmn.github.io/code-standards",target:"_blank"}},[t._v("百度前端规范")])]),e("p",[e("a",{attrs:{href:"http://isobar-idev.github.io/code-standards",target:"_blank"}},[t._v("百度前端规范")])]),e("p",[e("a",{attrs:{href:"http://zhuanlan.zhihu.com/fuyun/19884834",target:"_blank"}},[t._v("百度前端规范")])]),e("p",[e("a",{attrs:{href:"https://github.com/gf-rd/es6-coding-style",target:"_blank"}},[t._v("ECMAScript6 编码规范--广发证券前端团队")])]),e("p",[e("a",{attrs:{href:"http://blog.jobbole.com/79484",target:"_blank"}},[t._v("JavaScript 风格指南/编码规范（Airbnb公司版）")])]),e("p",[e("a",{attrs:{href:"http://nec.netease.com/standard",target:"_blank"}},[t._v("网易前端开发规范")])]),e("p",[e("a",{attrs:{href:"http://www.75team.com/archives/1049",target:"_blank"}},[t._v("css模块")])]),e("p",[e("a",{attrs:{href:"https://github.com/ecomfe/spec",target:"_blank"}},[t._v("前端规范资源列表")])]),e("p",[t._v("PHP")]),e("p",[t._v("PHP 地址")]),e("p",[e("a",{attrs:{href:"http://segmentfault.com/a/1190000000443795",target:"_blank"}},[t._v("最流行的PHP 代码规范")])]),e("p",[e("a",{attrs:{href:"https://github.com/hfcorriez/fig-standards/blob/zh_CN/%E6%8E%A5%E5%8F%97/PSR-2-coding-style-guide.md",target:"_blank"}},[t._v("最流行的PHP 代码规范")])]),e("p",[t._v("各大公司开源项目")]),e("p",[t._v("各大公司开源项目 地址")]),e("p",[e("a",{attrs:{href:"https://code.facebook.com/projects/web",target:"_blank"}},[t._v("Facebook Projects")])]),e("p",[e("a",{attrs:{href:"http://fex.baidu.com",target:"_blank"}},[t._v("百度web前端研发部")])]),e("p",[e("a",{attrs:{href:"http://efe.baidu.com",target:"_blank"}},[t._v("百度EFE")])]),e("p",[e("a",{attrs:{href:"https://github.com/fex-team",target:"_blank"}},[t._v("百度github")])]),e("p",[e("a",{attrs:{href:"http://www.alloyteam.com",target:"_blank"}},[t._v("alloyteam")])]),e("p",[e("a",{attrs:{href:"http://alloyteam.github.io",target:"_blank"}},[t._v("alloyteam-github")])]),e("p",[e("a",{attrs:{href:"https://github.com/AlloyTeam/AlloyGameEngine",target:"_blank"}},[t._v("alloyteam-AlloyGameEngine")])]),e("p",[e("a",{attrs:{href:"http://alloyteam.github.io/AlloyDesigner",target:"_blank"}},[t._v("AlloyDesigner")])]),e("p",[e("a",{attrs:{href:"http://www.alloyteam.com/2015/06/h5-jiao-hu-ye-bian-ji-qi-aeditor-jie-shao",target:"_blank"}},[t._v("H5交互页编辑器AEditor介绍")])]),e("p",[e("a",{attrs:{href:"http://aeditor.alloyteam.com",target:"_blank"}},[t._v("AEditor")])]),e("p",[e("a",{attrs:{href:"http://forum.maka.im/wordpress",target:"_blank"}},[t._v("maka")])]),e("p",[e("a",{attrs:{href:"https://github.com/fenbility/weekly-feed",target:"_blank"}},[t._v("值得订阅的weekly")])]),e("p",[e("a",{attrs:{href:"http://cube.qq.com",target:"_blank"}},[t._v("腾讯html5")])]),e("p",[e("a",{attrs:{href:"http://75team.github.io",target:"_blank"}},[t._v("奇舞团开源项目")])]),e("p",[e("a",{attrs:{href:"http://ued.qunar.com",target:"_blank"}},[t._v("Qunar UED")])]),e("p",[e("a",{attrs:{href:"http://scrat.io",target:"_blank"}},[t._v("Scrat")])]),e("p",[t._v("常用")]),e("p",[t._v("常用 地址")]),e("p",[e("a",{attrs:{href:"http://www.zhangxinxu.com/wordpress/2013/12/iebetter-js-make-ie6-ie8-like-modern-browser-ie9-chrome",target:"_blank"}},[t._v("ieBetter.js-让IE6-IE8拥有IE9+,Chrome等浏览器特性")])]),e("p",[e("a",{attrs:{href:"http://mottie.github.io/Keyboard",target:"_blank"}},[t._v("模拟键盘")])]),e("p",[e("a",{attrs:{href:"https://github.com/hotoo/pinyin",target:"_blank"}},[t._v("拼音")])]),e("p",[e("a",{attrs:{href:"https://github.com/mc-zone/IDValidator",target:"_blank"}},[t._v("中国个人身份证号验证")])]),e("p",[t._v("算法")]),e("p",[t._v("算法 地址")]),e("p",[e("a",{attrs:{href:"https://github.com/Ralph-Wang/algorithm.in.js",target:"_blank"}},[t._v("数据结构与算法 JavaScript 描述. 章节练习")])]),e("p",[e("a",{attrs:{href:"https://github.com/twobin/twobinSort",target:"_blank"}},[t._v("常见排序算法（JS版）")])]),e("p",[e("a",{attrs:{href:"https://github.com/luofei2011/jsAgm/blob/master/js/sort.js",target:"_blank"}},[t._v("经典排序")])]),e("p",[e("a",{attrs:{href:"https://github.com/hechangmin/jssort",target:"_blank"}},[t._v("常见排序算法-js版本")])]),e("p",[e("a",{attrs:{href:"https://github.com/lightningtgc/JavaScript-Algorithms",target:"_blank"}},[t._v("JavaScript 算法与数据结构 精华集")])]),e("p",[e("a",{attrs:{href:"http://www.nowcoder.com/live/courses",target:"_blank"}},[t._v("面试常考算法题精讲")])]),e("p",[t._v("移动端")]),e("p",[t._v("移动端 地址")]),e("p",[e("a",{attrs:{href:"https://github.com/ftlabs/fastclick",target:"_blank"}},[t._v("fastclick")])]),e("p",[e("a",{attrs:{href:"https://github.com/mmastrac/jquery-noclickdelay",target:"_blank"}},[t._v("no-click-delay")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/lcw/p/3619181.html",target:"_blank"}},[t._v("【敏捷开发】Android团队开发规范")])]),e("p",[e("a",{attrs:{href:"http://www.jianshu.com/p/4390f4fe19b3",target:"_blank"}},[t._v("Android 开发规范与应用")])]),e("p",[e("a",{attrs:{href:"https://github.com/ychow/ionic-guide",target:"_blank"}},[t._v("ionic")])]),e("p",[t._v("JSON")]),e("p",[t._v("JSON 地址")]),e("p",[e("a",{attrs:{href:"http://beta.json-generator.com",target:"_blank"}},[t._v("模拟生成JSON数据")])]),e("p",[e("a",{attrs:{href:"http://jsonp.afeld.me",target:"_blank"}},[t._v("返回跨域JSONAPI")])]),e("p",[t._v("焦点图")]),e("p",[t._v("焦点图 地址")]),e("p",[e("a",{attrs:{href:"https://github.com/koen301/myfocus",target:"_blank"}},[t._v("myfocus")])]),e("p",[e("a",{attrs:{href:"http://www.chhua.com/myfocus",target:"_blank"}},[t._v("myfocus-官方演示站")])]),e("p",[e("a",{attrs:{href:"http://www.superslide2.com",target:"_blank"}},[t._v("SuperSlidev2.1 -- 大话主席")])]),e("p",[e("a",{attrs:{href:"http://www.bujichong.com/sojs/soChange/index.html",target:"_blank"}},[t._v("soChange")])]),e("p",[t._v("Ext, EasyUI, J-UI 及其它各种UI方案")]),e("p",[t._v("Ext, EasyUI, J-UI 及其它各种UI方案 地址")]),e("p",[e("a",{attrs:{href:"https://www.sencha.com/products/extjs",target:"_blank"}},[t._v("extjs")])]),e("p",[e("a",{attrs:{href:"http://docs.sencha.com/extjs/4.0.7",target:"_blank"}},[t._v("ext4英文api")])]),e("p",[e("a",{attrs:{href:"http://extjs-doc-cn.github.io/ext4api",target:"_blank"}},[t._v("ext4中文api")])]),e("p",[e("a",{attrs:{href:"http://jquery-easyui.googlecode.com/svn/trunk/src",target:"_blank"}},[t._v("jquery easyui 未压缩源代码")])]),e("p",[e("a",{attrs:{href:"http://jui.org",target:"_blank"}},[t._v("J-UI")])]),e("p",[e("a",{attrs:{href:"http://dcloudio.github.io/mui",target:"_blank"}},[t._v("MUI-最接近原生APP体验的高性能前端框架")])]),e("p",[t._v("Amaze UI 中国首个开源 HTML5 跨屏前端框架")]),e("p",[e("a",{attrs:{href:"http://m.sui.taobao.org",target:"_blank"}},[t._v("淘宝 HTML5 前端框架")])]),e("p",[e("a",{attrs:{href:"http://docs.kissyui.com",target:"_blank"}},[t._v("KISSY - 阿里前端JavaScript库")])]),e("p",[e("a",{attrs:{href:"http://nej.netease.com",target:"_blank"}},[t._v("网易Nej - Nice Easy Javascript")])]),e("p",[e("a",{attrs:{href:"http://demos.telerik.com/kendo-ui/mvvm/index",target:"_blank"}},[t._v("Kendo UI MVVM Demo")])]),e("p",[e("a",{attrs:{href:"http://www.bootcss.com",target:"_blank"}},[t._v("Bootstrap")])]),e("p",[e("a",{attrs:{href:"http://smartui.chinamzz.com",target:"_blank"}},[t._v("Smart UI")])]),e("p",[e("a",{attrs:{href:"http://developer.yahoo.com/yui/grids",target:"_blank"}},[t._v("雅虎UI - CSS UI")])]),e("p",[t._v("页面 社会化 分享功能")]),e("p",[t._v("页面 社会化 分享功能 地址")]),e("p",[e("a",{attrs:{href:"http://share.baidu.com",target:"_blank"}},[t._v("百度分享")])]),e("p",[e("a",{attrs:{href:"http://jiathis.com",target:"_blank"}},[t._v("JiaThis")])]),e("p",[e("a",{attrs:{href:"http://developer.baidu.com/soc/share",target:"_blank"}},[t._v("社会化分享组件")])]),e("p",[e("a",{attrs:{href:"http://www.mob.com/#/index",target:"_blank"}},[t._v("ShareSDK 轻松实现社会化功能")])]),e("p",[e("a",{attrs:{href:"http://dev.umeng.com/social/android/quick-integration",target:"_blank"}},[t._v("友盟分享")])]),e("p",[t._v("富文本编辑器")]),e("p",[t._v("富文本编辑器 地址")]),e("p",[e("a",{attrs:{href:"https://www.tinymce.com",target:"_blank"}},[t._v("功能齐全 tinymce")])]),e("p",[e("a",{attrs:{href:"http://ueditor.baidu.com/website",target:"_blank"}},[t._v("百度 ueditor")])]),e("p",[e("a",{attrs:{href:"http://ckeditor.com",target:"_blank"}},[t._v("经典的ckeditor")])]),e("p",[e("a",{attrs:{href:"http://kindeditor.net",target:"_blank"}},[t._v("经典的kindeditor")])]),e("p",[e("a",{attrs:{href:"http://www.bootcss.com/p/bootstrap-wysiwyg",target:"_blank"}},[t._v("wysiwyg")])]),e("p",[e("a",{attrs:{href:"http://integ.github.io/BachEditor",target:"_blank"}},[t._v("一个有情怀的编辑器。Bach's Editor")])]),e("p",[e("a",{attrs:{href:"https://github.com/mycolorway/simditor",target:"_blank"}},[t._v("tower用的编辑器")])]),e("p",[e("a",{attrs:{href:"https://github.com/summernote/summernote",target:"_blank"}},[t._v("summernote 编辑器")])]),e("p",[e("a",{attrs:{href:"http://neilj.github.io/Squire",target:"_blank"}},[t._v("html5编辑器")])]),e("p",[e("a",{attrs:{href:"http://lab.hustlzp.com/XEditor",target:"_blank"}},[t._v("XEditor")])]),e("p",[e("a",{attrs:{href:"https://github.com/wangfupeng1988/wangEditor",target:"_blank"}},[t._v("wangEditor")])]),e("p",[t._v("前端概述")]),e("p",[t._v("前端概述 地址")]),e("p",[e("a",{attrs:{href:"http://www.awesomes.cn",target:"_blank"}},[t._v("前端工具大全")])]),e("p",[e("a",{attrs:{href:"https://github.com/fouber/blog/issues/10?from=timeline&isappinstalled=0#",target:"_blank"}},[t._v("什么是前端工程化")])]),e("p",[t._v("Gulp")]),e("p",[t._v("Gulp 地址")]),e("p",[e("a",{attrs:{href:"http://gulpjs.com",target:"_blank"}},[t._v("Gulp官网")])]),e("p",[e("a",{attrs:{href:"http://www.gulpjs.com.cn",target:"_blank"}},[t._v("Gulp中文网")])]),e("p",[e("a",{attrs:{href:"https://github.com/Platform-CUF/use-gulp",target:"_blank"}},[t._v("gulp资料收集")])]),e("p",[e("a",{attrs:{href:"http://javascript.ruanyifeng.com/tool/gulp.html",target:"_blank"}},[t._v("Gulp：任务自动管理工具 - ruanyifeng")])]),e("p",[e("a",{attrs:{href:"http://gulpjs.com/plugins",target:"_blank"}},[t._v("Gulp插件")])]),e("p",[e("a",{attrs:{href:"http://www.jeffjade.com/2015/11/25/2015-11-25-toss-gulp/",target:"_blank"}},[t._v("Gulp探究折腾之路(I)")])]),e("p",[e("a",{attrs:{href:"http://www.jeffjade.com/2016/01/19/2016-01-19-toss-gulp/",target:"_blank"}},[t._v("Gulp折腾之路(II)")])]),e("p",[e("a",{attrs:{href:"http://www.ido321.com/1622.html",target:"_blank"}},[t._v("Gulp不完全入门教程")])]),e("p",[e("a",{attrs:{href:"https://github.com/hjzheng/CUF_meeting_knowledge_share/issues/33",target:"_blank"}},[t._v("为什么使用gulp?")])]),e("p",[e("a",{attrs:{href:"http://www.dbpoo.com/getting-started-with-gulp",target:"_blank"}},[t._v("Gulp安装及配合组件构建前端开发一体化")])]),e("p",[e("a",{attrs:{href:"https://github.com/nimojs/gulp-book",target:"_blank"}},[t._v("Gulp 入门指南")])]),e("p",[e("a",{attrs:{href:"https://github.com/nimojs/blog/issues/19",target:"_blank"}},[t._v("Gulp 入门指南 - nimojs")])]),e("p",[e("a",{attrs:{href:"http://www.imooc.com/video/5692",target:"_blank"}},[t._v("Gulp in Action")])]),e("p",[e("a",{attrs:{href:"http://www.w3ctech.com/topic/134",target:"_blank"}},[t._v("Gulp开发教程（翻译）")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/2050/p/4198792.html",target:"_blank"}},[t._v("前端构建工具gulpjs的使用介绍及技巧")])]),e("p",[t._v("Grunt")]),e("p",[t._v("Grunt 地址")]),e("p",[e("a",{attrs:{href:"http://gruntjs.com",target:"_blank"}},[t._v("gruntjs")])]),e("p",[e("a",{attrs:{href:"http://www.gruntjs.net",target:"_blank"}},[t._v("Grunt中文网")])]),e("p",[t._v("Fis")]),e("p",[t._v("Fis 地址")]),e("p",[e("a",{attrs:{href:"http://fex-team.github.io/fis-site/index.html",target:"_blank"}},[t._v("fis 官网")])]),e("p",[e("a",{attrs:{href:"http://fis.baidu.com",target:"_blank"}},[t._v("fis")])]),e("p",[t._v("pc图轮")]),e("p",[t._v("pc图轮 地址")]),e("p",[e("a",{attrs:{href:"http://www.jsfoot.com/jquery/demo/2011-09-20/192.html",target:"_blank"}},[t._v("单屏轮播sochange")])]),e("p",[e("a",{attrs:{href:"http://bxslider.com/examples/carousel-demystified",target:"_blank"}},[t._v("左右按钮多图切换")])]),e("p",[e("a",{attrs:{href:"https://github.com/alvarotrigo/fullPage.js",target:"_blank"}},[t._v("fullpage全屏轮播")])]),e("p",[t._v("移动端图轮")]),e("p",[t._v("移动端图轮 地址")]),e("p",[e("a",{attrs:{href:"http://www.swipejs.com",target:"_blank"}},[t._v("无缝切换")])]),e("p",[e("a",{attrs:{href:"http://www.idangero.us/swiper",target:"_blank"}},[t._v("滑屏效果")])]),e("p",[e("a",{attrs:{href:"https://github.com/peunzhang/fullpage",target:"_blank"}},[t._v("全屏fullpage")])]),e("p",[e("a",{attrs:{href:"https://github.com/qiqiboy/touchslider",target:"_blank"}},[t._v("单个图片切换")])]),e("p",[e("a",{attrs:{href:"https://github.com/peunzhang/slip.js",target:"_blank"}},[t._v("单个全屏切换")])]),e("p",[e("a",{attrs:{href:"http://touch.code.baidu.com/examples.html?qq-pf-to=pcqq.group",target:"_blank"}},[t._v("百度的切换库")])]),e("p",[e("a",{attrs:{href:"https://github.com/peunzhang/iSlider",target:"_blank"}},[t._v("单个全屏切换")])]),e("p",[e("a",{attrs:{href:"https://github.com/saw/touch-interfaces",target:"_blank"}},[t._v("滑屏效果")])]),e("p",[e("a",{attrs:{href:"http://baijs.com/tinycircleslider",target:"_blank"}},[t._v("旋转拖动设置")])]),e("p",[e("a",{attrs:{href:"http://touchslider.com",target:"_blank"}},[t._v("类似于swipe切换")])]),e("p",[e("a",{attrs:{href:"http://www.swiper.com.cn/demo/index.html",target:"_blank"}},[t._v("支持多种形式的触摸滑动")])]),e("p",[e("a",{attrs:{href:"https://github.com/joker-ye/main/blob/master/wap/index.html",target:"_blank"}},[t._v("滑屏效果")])]),e("p",[e("a",{attrs:{href:"http://www.superslide2.com",target:"_blank"}},[t._v("大话主席pc移动图片轮换")])]),e("p",[e("a",{attrs:{href:"https://github.com/hahnzhu/parallax.js",target:"_blank"}},[t._v("滑屏效果")])]),e("p",[e("a",{attrs:{href:"https://github.com/yanhaijing/zepto.fullpage",target:"_blank"}},[t._v("基于zepto的fullpage")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/plums/archive/2013/01/10/WebApp-fixed-width-layout-of-multi-terminal-adapter-since.html",target:"_blank"}},[t._v("[WebApp]定宽网页设计下，固定宽度布局开发WebApp并实现多终端下WebApp布局自适应")])]),e("p",[e("a",{attrs:{href:"http://loo2k.com/blog/detecting-wechat-client",target:"_blank"}},[t._v("判断微信客户端的那些坑")])]),e("p",[e("a",{attrs:{href:"https://github.com/JefferyWang/nativeShare.js",target:"_blank"}},[t._v("可以通过javascript直接调用原生分享的工具")])]),e("p",[e("a",{attrs:{href:"http://www.jiathis.com/help/html/weixin-share-code",target:"_blank"}},[t._v("JiaThis 分享到微信代码")])]),e("p",[e("a",{attrs:{href:"http://fex.baidu.com/blog/2015/05/cross-mobile",target:"_blank"}},[t._v("聊聊移动端跨平台开发的各种技术")])]),e("p",[e("a",{attrs:{href:"http://www.zhihu.com/question/29922082",target:"_blank"}},[t._v("前端自动化测试")])]),e("p",[e("a",{attrs:{href:"http://ajccom.github.io/niceslider",target:"_blank"}},[t._v("多种轮换图片")])]),e("p",[e("a",{attrs:{href:"https://mango.github.io/slideout",target:"_blank"}},[t._v("滑动侧边栏")])]),e("p",[t._v("文件上传")]),e("p",[t._v("文件上传 地址")]),e("p",[e("a",{attrs:{href:"http://fex.baidu.com/webuploader",target:"_blank"}},[t._v("百度上传组件")])]),e("p",[e("a",{attrs:{href:"https://blueimp.github.io/jQuery-File-Upload",target:"_blank"}},[t._v("上传")])]),e("p",[e("a",{attrs:{href:"http://www.hdfu.net",target:"_blank"}},[t._v("flash 头像上传")])]),e("p",[e("a",{attrs:{href:"http://www.dropzonejs.com",target:"_blank"}},[t._v("图片上传预览")])]),e("p",[e("a",{attrs:{href:"http://elemefe.github.io/image-cropper",target:"_blank"}},[t._v("图片裁剪")])]),e("p",[e("a",{attrs:{href:"http://www.shearphoto.com",target:"_blank"}},[t._v("图片裁剪-shearphoto")])]),e("p",[e("a",{attrs:{href:"http://www.oschina.net/project/tag/284/jquery-image-tools?lang=0&os=0&sort=view&p=2",target:"_blank"}},[t._v("jQuery图片处理")])]),e("p",[t._v("模拟select")]),e("p",[t._v("模拟select 地址")]),e("p",[e("a",{attrs:{href:"http://aui.github.io/popupjs/doc/selectbox.html",target:"_blank"}},[t._v("糖饼 select")])]),e("p",[e("a",{attrs:{href:"https://github.com/rmm5t/jquery-flexselect",target:"_blank"}},[t._v("flexselect")])]),e("p",[e("a",{attrs:{href:"http://loudev.com",target:"_blank"}},[t._v("双select")])]),e("p",[e("a",{attrs:{href:"http://select2.github.io",target:"_blank"}},[t._v("select2")])]),e("p",[t._v("取色插件")]),e("p",[t._v("取色插件 地址")]),e("p",[e("a",{attrs:{href:"http://www.jq22.com/plugin/367",target:"_blank"}},[t._v("类似 Photoshop 的界面取色插件")])]),e("p",[e("a",{attrs:{href:"https://github.com/jquery/jquery-color",target:"_blank"}},[t._v("jquery color")])]),e("p",[e("a",{attrs:{href:"http://www.oschina.net/project/tag/287/color-picker",target:"_blank"}},[t._v("取色插件集合")])]),e("p",[e("a",{attrs:{href:"https://github.com/mattfarina/farbtastic",target:"_blank"}},[t._v("farbtastic 圆环＋正方形")])]),e("p",[t._v("城市联动")]),e("p",[t._v("城市联动 地址")]),e("p",[e("a",{attrs:{href:"http://www.ijquery.cn/?p=360",target:"_blank"}},[t._v("jquery.cityselect.js基于jQuery+JSON的省市或自定义联动效果")])]),e("p",[t._v("剪贴板")]),e("p",[t._v("剪贴板 地址")]),e("p",[e("a",{attrs:{href:"https://github.com/zeroclipboard/zeroclipboard",target:"_blank"}},[t._v("剪贴板")])]),e("p",[e("a",{attrs:{href:"http://zenorocha.github.io/clipboard.js",target:"_blank"}},[t._v("clipboard 最新的剪切方案")])]),e("p",[e("a",{attrs:{href:"https://github.com/zenorocha/clipboard.js",target:"_blank"}},[t._v("不是Flash的剪贴板")])]),e("p",[t._v("简繁转换")]),e("p",[t._v("简繁转换 地址")]),e("p",[e("a",{attrs:{href:"https://github.com/BYVoid/OpenCC",target:"_blank"}},[t._v("简繁转换")])]),e("p",[t._v("表格 Grid")]),e("p",[t._v("表格 Grid 地址")]),e("p",[e("a",{attrs:{href:"http://facebook.github.io/fixed-data-table",target:"_blank"}},[t._v("facebook表格")])]),e("p",[e("a",{attrs:{href:"http://handsontable.com",target:"_blank"}},[t._v("类似于Excel编辑表格-handsontable")])]),e("p",[e("a",{attrs:{href:"http://bootstrap-table.wenzhixin.net.cn",target:"_blank"}},[t._v("bootstrap-table插件")])]),e("p",[e("a",{attrs:{href:"https://www.datatables.net",target:"_blank"}},[t._v("datatables")])]),e("p",[t._v("在线演示")]),e("p",[t._v("在线演示 地址")]),e("p",[e("a",{attrs:{href:"http://runjs.cn",target:"_blank"}},[t._v("js 在线编辑 - runjs")])]),e("p",[e("a",{attrs:{href:"http://jsbin.com",target:"_blank"}},[t._v("js 在线编辑 - jsbin")])]),e("p",[e("a",{attrs:{href:"http://codepen.io",target:"_blank"}},[t._v("js 在线编辑 - codepen")])]),e("p",[e("a",{attrs:{href:"http://jsfiddle.net",target:"_blank"}},[t._v("js 在线编辑 - jsfiddle")])]),e("p",[e("a",{attrs:{href:"http://ideone.com",target:"_blank"}},[t._v("java 在线编辑 - runjs")])]),e("p",[e("a",{attrs:{href:"http://code.hcharts.cn",target:"_blank"}},[t._v("js 在线编辑 - hcharts")])]),e("p",[e("a",{attrs:{href:"http://jsdm.com",target:"_blank"}},[t._v("js 在线编辑 - jsdm")])]),e("p",[e("a",{attrs:{href:"http://sqlfiddle.com",target:"_blank"}},[t._v("sql 在线编辑 - sqlfiddle")])]),e("p",[e("a",{attrs:{href:"https://thimble.mozilla.org",target:"_blank"}},[t._v("mozilla 在线编辑器")])]),e("p",[t._v("常规优化")]),e("p",[t._v("常规优化 地址")]),e("p",[e("a",{attrs:{href:"http://www.infoq.com/cn/articles/javascript-high-performance-animation-and-page-rendering",target:"_blank"}},[t._v("Javascript高性能动画与页面渲染")])]),e("p",[e("a",{attrs:{href:"http://isux.tencent.com/h5-performance.html",target:"_blank"}},[t._v("移动H5前端性能优化指南")])]),e("p",[e("a",{attrs:{href:"http://ued.5173.com/?p=1731",target:"_blank"}},[t._v("5173首页前端性能优化实践")])]),e("p",[e("a",{attrs:{href:"http://www.uisdc.com/front-end-performance-for-web-designers-and-front-end-developers",target:"_blank"}},[t._v("给网页设计师和前端开发者看的前端性能优化")])]),e("p",[e("a",{attrs:{href:"http://www.orzpoint.com/profiling-css-and-optimization-notes",target:"_blank"}},[t._v("复杂应用的 CSS\n                    性能分析和优化建议")])]),e("p",[t._v("张鑫旭——前端性能 张鑫旭——前端性能")]),e("p",[e("a",{attrs:{href:"http://www.xiaoqiang.org/javascript/font-end-performance-monitor.html",target:"_blank"}},[t._v("前端性能监控总结")])]),e("p",[t._v("网站性能优化之CSS无图片技术 网站性能优化之CSS无图片技术")]),e("p",[t._v("web前端性能优化进阶路 web前端性能优化进阶路")]),e("p",[e("a",{attrs:{href:"http://my.eoe.cn/tuwandou/archive/4544.html",target:"_blank"}},[t._v("前端技术：网站性能优化之CSS无图片技术")])]),e("p",[e("a",{attrs:{href:"http://www.baiduux.com/blog/2011/02/15/browser-loading",target:"_blank"}},[t._v("浏览器的加载与页面性能优化")])]),e("p",[e("a",{attrs:{href:"http://www.w3ctech.com/p/1503",target:"_blank"}},[t._v("页面加载中的图片性能优化")])]),e("p",[t._v("Hey——前端性能 Hey——前端性能")]),e("p",[t._v("html优化 html优化")]),e("p",[t._v("99css——性能 99css——性能")]),e("p",[e("a",{attrs:{href:"http://www.yslow.net/category.php?cid=20",target:"_blank"}},[t._v("Yslow——性能优化")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/yslow",target:"_blank"}},[t._v("YSLOW中文介绍")])]),e("p",[e("a",{attrs:{href:"http://www.360ito.com/article/40.html",target:"_blank"}},[t._v("转一篇Yahoo关于网站性能优化的文章，兼谈本站要做的优化")])]),e("p",[e("a",{attrs:{href:"http://www.360doc.com/content/10/0928/09/2588264_56971287.shtml",target:"_blank"}},[t._v("Yahoo!团队实践分享：网站性能")])]),e("p",[e("a",{attrs:{href:"http://blog.jiasule.com/i/153",target:"_blank"}},[t._v("网站性能优化指南：什么使我们的网站变慢？")])]),e("p",[e("a",{attrs:{href:"http://www.powereasy.net/helpyou/knowledge/ecommerce/9593.html",target:"_blank"}},[t._v("网站性能优化实践，减少加载时间，提高用户体验")])]),e("p",[e("a",{attrs:{href:"http://www.umtry.com/archives/747.html",target:"_blank"}},[t._v("浅谈网站性能优化 前端篇")])]),e("p",[e("a",{attrs:{href:"http://www.adinnet.cn/blog/designview/2012-7-12/678.html",target:"_blank"}},[t._v("前端重构实践之如何对网站性能优化？")])]),e("p",[e("a",{attrs:{href:"http://www.gbin1.com/technology/javascript/20130708-front-end-performance-optimization-9",target:"_blank"}},[t._v("前端性能优化：使用媒体查询加载指定大小的背景图片")])]),e("p",[e("a",{attrs:{href:"http://www.mykuer.com/post/factors-that-affect-the-speed-of-web-site-open.html",target:"_blank"}},[t._v("网站性能系列博文")])]),e("p",[e("a",{attrs:{href:"http://tgideas.qq.com/webplat/info/news_version3/804/808/811/m579/201109/41355.shtml",target:"_blank"}},[t._v("加载，不只是少一点点")])]),e("p",[e("a",{attrs:{href:"http://mzhou.me/article/95310",target:"_blank"}},[t._v("前端性能的测试与优化")])]),e("p",[e("a",{attrs:{href:"http://www.gbin1.com/technology/html/20130217-tips-for-speed-up-page-loading",target:"_blank"}},[t._v("分享网页加载速度优化的一些技巧？")])]),e("p",[e("a",{attrs:{href:"http://www.f2es.com/images-bytes-opt",target:"_blank"}},[t._v("页面加载中的图片性能优化")])]),e("p",[e("a",{attrs:{href:"http://www.tcreator.info/webSchool/website/Front-end-Opt-Yslow.html",target:"_blank"}},[t._v("web前端优化(基于Yslow")])]),e("p",[e("a",{attrs:{href:"https://www.qianduan.net/website-performance-optimization-tool.html",target:"_blank"}},[t._v("网站性能优化工具大全")])]),e("p",[e("a",{attrs:{href:"http://www.alloyteam.com/2012/10/high-performance-html",target:"_blank"}},[t._v("【高性能前端1】高性能HTML")])]),e("p",[e("a",{attrs:{href:"http://www.alloyteam.com/2012/10/high-performance-css",target:"_blank"}},[t._v("【高性能前端2】高性能CSS")])]),e("p",[e("a",{attrs:{href:"http://coolshell.cn/articles/6470.html",target:"_blank"}},[t._v("由12306谈谈网站前端性能和后端性能优化")])]),e("p",[t._v("AlloyTeam——前端优化 AlloyTeam——前端优化")]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/developersupport/p/3248695.html",target:"_blank"}},[t._v("毫秒必争，前端网页性能最佳实践")])]),e("p",[e("a",{attrs:{href:"http://blog.sina.com.cn/s/blog_6e9d2e0701017kvu.html",target:"_blank"}},[t._v("网站性能工具Yslow的使用方法")])]),e("p",[e("a",{attrs:{href:"http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part1",target:"_blank"}},[t._v("前端工程与性能优化（上）：静态资源版本更新与缓存")])]),e("p",[e("a",{attrs:{href:"http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part2",target:"_blank"}},[t._v("前端工程与性能优化（下）：静态资源管理与模板框架")])]),e("p",[e("a",{attrs:{href:"http://blog.jobbole.com/48369",target:"_blank"}},[t._v("HTTPS连接的前几毫秒发生了什么")])]),e("p",[e("a",{attrs:{href:"http://uicss.cn/yslow/#more-12319",target:"_blank"}},[t._v("Yslow")])]),e("p",[e("a",{attrs:{href:"http://blog.smartbear.com/web-performance/essential-web-performance-metrics-a-primer-part-1",target:"_blank"}},[t._v("Essential Web Performance Metrics — A Primer, Part 1")])]),e("p",[e("a",{attrs:{href:"http://blog.smartbear.com/performance/essential-web-performance-metrics-part-2",target:"_blank"}},[t._v("Essential Web Performance Metrics — Part 2")])]),e("p",[e("a",{attrs:{href:"http://jayli.github.io/blog/data/2011/12/23/yuislide.html",target:"_blank"}},[t._v("YUISlide,针对移动设备的动画性能优化")])]),e("p",[e("a",{attrs:{href:"http://joelglovier.com/improving-site-performance",target:"_blank"}},[t._v("Improving Site Performance")])]),e("p",[e("a",{attrs:{href:"http://segmentfault.com/a/1190000000367899",target:"_blank"}},[t._v("让网站提速的最佳前端实践")])]),e("p",[e("a",{attrs:{href:"http://sixrevisions.com/web-development/why-website-speed-is-important",target:"_blank"}},[t._v("Why Website\n                    Speed is Important")])]),e("p",[e("a",{attrs:{href:"https://www.devbridge.com/articles/need-for-speed-how-to-improve-your-website-performance",target:"_blank"}},[t._v("Need for Speed – How to Improve your Website Performance")])]),e("p",[e("a",{attrs:{href:"https://github.com/amfe/article/issues/1",target:"_blank"}},[t._v("阿里无线前端性能优化指南 (Pt.1 加载期优化")])]),e("p",[t._v("优化工具")]),e("p",[t._v("优化工具 地址")]),e("p",[e("a",{attrs:{href:"http://www.html-js.com/article/3083",target:"_blank"}},[t._v("JavaScript 性能分析新工具 OneProfile")])]),e("p",[e("a",{attrs:{href:"http://www.html-js.com/article/3091",target:"_blank"}},[t._v("JavaScript 堆内存分析新工具 OneHeap")])]),e("p",[t._v("在线工具")]),e("p",[t._v("在线工具 地址")]),e("p",[e("a",{attrs:{href:"https://developers.google.com/speed/pagespeed/insights",target:"_blank"}},[t._v("google在线工具")])]),e("p",[e("a",{attrs:{href:"http://www.alibench.com",target:"_blank"}},[t._v("阿里测")])]),e("p",[e("a",{attrs:{href:"http://itest.aliyun.com",target:"_blank"}},[t._v("阿里-免费测试服务")])]),e("p",[e("a",{attrs:{href:"https://github.com/alibaba/f2etest",target:"_blank"}},[t._v("阿里-F2etest多浏览器兼容性测试解决方案")])]),e("p",[e("a",{attrs:{href:"http://jsperf.com",target:"_blank"}},[t._v("js性能测试")])]),e("p",[t._v("前端架构")]),e("p",[t._v("前端架构 地址")]),e("p",[e("a",{attrs:{href:"http://www.zhihu.com/topic/19612641",target:"_blank"}},[t._v("技术架构")])]),e("p",[e("a",{attrs:{href:"http://saito.im/note/The-Architecture-of-F2E",target:"_blank"}},[t._v("前端架构")])]),e("p",[e("a",{attrs:{href:"http://www.zhihu.com/question/24092572",target:"_blank"}},[t._v("如何成为前端架构师")])]),e("p",[e("a",{attrs:{href:"http://hikejun.com/sharing/2010webrebuild/?file=fe-infrastructure.html",target:"_blank"}},[t._v("关于前端架构-张克军")])]),e("p",[e("a",{attrs:{href:"http://www.zhihu.com/question/25583350",target:"_blank"}},[t._v("百度腾讯offer比较（腾讯游戏VS百度基础架构）")])]),e("p",[t._v("推荐作品")]),e("p",[t._v("推荐作品 地址")]),e("p",[e("a",{attrs:{href:"https://gist.github.com/wintercn",target:"_blank"}},[t._v("winter代码片段需要FQ")])]),e("p",[e("a",{attrs:{href:"http://www.fgm.cc/learn",target:"_blank"}},[t._v("fgm")])]),e("p",[e("a",{attrs:{href:"https://github.com/hongru/hongru.github.com",target:"_blank"}},[t._v("岑安作品集")])]),e("p",[e("a",{attrs:{href:"http://kmdjs.github.io",target:"_blank"}},[t._v("当耐特demo集合")])]),e("p",[e("a",{attrs:{href:"http://www.laoshu133.com/Lab",target:"_blank"}},[t._v("米空格 js作品")])]),e("p",[e("a",{attrs:{href:"http://koen301.github.io",target:"_blank"}},[t._v("myFocus")])]),e("p",[e("a",{attrs:{href:"http://panxuepeng.github.io/seajslib",target:"_blank"}},[t._v("SeaJS组件库")])]),e("p",[e("a",{attrs:{href:"http://yanhaijing.com/myProject",target:"_blank"}},[t._v("颜海镜作品")])]),e("p",[e("a",{attrs:{href:"http://jo2.org/category/myworks",target:"_blank"}},[t._v("脚儿网作品")])]),e("p",[e("a",{attrs:{href:"http://www.cnitblog.com/yemoo/category/3107.html",target:"_blank"}},[t._v("javascript个人作品")])]),e("p",[e("a",{attrs:{href:"http://bbs.miaov.com/forum.php?mod=viewthread&tid=7790",target:"_blank"}},[t._v("妙味的雷东升游戏作品")])]),e("p",[e("a",{attrs:{href:"http://bbs.csdn.net/topics/380227212",target:"_blank"}},[t._v("javascript作品集")])]),e("p",[e("a",{attrs:{href:"https://github.com/TooBug/works",target:"_blank"}},[t._v("云五笔，灰度产生生成工具")])]),e("p",[e("a",{attrs:{href:"http://koen301.github.io",target:"_blank"}},[t._v("项目主页")])]),e("p",[e("a",{attrs:{href:"http://zaole.net",target:"_blank"}},[t._v("个性的作品主页")])]),e("p",[e("a",{attrs:{href:"http://static.tingall.com/v2/player",target:"_blank"}},[t._v("播放器")])]),e("p",[e("a",{attrs:{href:"http://ucren.com/blog/demos",target:"_blank"}},[t._v("ucren js demos 集")])]),e("p",[e("a",{attrs:{href:"http://www.zhinengshe.com/works_list.html",target:"_blank"}},[t._v("智能社")])]),e("p",[e("a",{attrs:{href:"http://demos.shizuwu.cn",target:"_blank"}},[t._v("实例陈列架")])]),e("p",[e("a",{attrs:{href:"http://zoye.sinaapp.com/demo",target:"_blank"}},[t._v("zoye demo")])]),e("p",[e("a",{attrs:{href:"http://lab.yuanwai.wang",target:"_blank"}},[t._v("王员外")])]),e("p",[e("a",{attrs:{href:"http://pingfan1990.sinaapp.com",target:"_blank"}},[t._v("平凡")])]),e("p",[e("a",{attrs:{href:"http://www.lovewebgames.com",target:"_blank"}},[t._v("jyg 游戏案例")])]),e("p",[e("a",{attrs:{href:"http://www.helloweba.com/list.html",target:"_blank"}},[t._v("很多jquery插件")])]),e("p",[e("a",{attrs:{href:"http://www.bujichong.com/sojs/api/index.html",target:"_blank"}},[t._v("不羁虫 - soJs 作品系列")])]),e("p",[e("a",{attrs:{href:"http://frozenui.github.io/case.html",target:"_blank"}},[t._v("frozenui")])]),e("p",[e("a",{attrs:{href:"http://js-game.github.io/othello",target:"_blank"}},[t._v("黑白棋")])]),e("p",[e("a",{attrs:{href:"http://yansm.github.io/fromone/index.html",target:"_blank"}},[t._v("fromone")])]),e("p",[e("a",{attrs:{href:"http://pazguille.me",target:"_blank"}},[t._v("pazguille")])]),e("p",[e("a",{attrs:{href:"https://github.com/zmmbreeze/DeadSimpleVideoPlayer",target:"_blank"}},[t._v("Html5 VideoPlayer")])]),e("p",[e("a",{attrs:{href:"http://a-jie.github.io/Proton/#example",target:"_blank"}},[t._v("Proton 烟花")])]),e("p",[t._v("简历模板")]),e("p",[t._v("简历模板 地址")]),e("p",[e("a",{attrs:{href:"http://learnshare.github.io/about/index.html",target:"_blank"}},[t._v("不错的个人简历")])]),e("p",[e("a",{attrs:{href:"http://hcy2367.github.io/resume",target:"_blank"}},[t._v("简历")])]),e("p",[e("a",{attrs:{href:"http://ncuey.sinaapp.com/CrispElite/",target:"_blank"}},[t._v("张伦")])]),e("p",[e("a",{attrs:{href:"https://github.com/hacke2/ResumeSample",target:"_blank"}},[t._v("简历")])]),e("p",[e("a",{attrs:{href:"http://blog.dandyweng.com/2013/07/how-my-website-was-created",target:"_blank"}},[t._v("翁天信")])]),e("p",[e("a",{attrs:{href:"http://www.webhek.com/misc/interactive-resume",target:"_blank"}},[t._v("动画方式的简历")])]),e("p",[e("a",{attrs:{href:"http://www.linqing07.com/resume.html",target:"_blank"}},[t._v("组件丰富简历")])]),e("p",[e("a",{attrs:{href:"http://www.mojianli.com/resume/view",target:"_blank"}},[t._v("简历池")])]),e("p",[e("a",{attrs:{href:"http://www.haorooms.com/about",target:"_blank"}},[t._v("haorooms博客")])]),e("p",[e("a",{attrs:{href:"http://cv.youngdze.com",target:"_blank"}},[t._v("Justin Young")])]),e("p",[t._v("面试题")]),e("p",[t._v("面试题 地址")]),e("p",[e("a",{attrs:{href:"http://www.nowcoder.com/discuss/3196",target:"_blank"}},[t._v("那几个月在找工作（百度，网易游戏）")])]),e("p",[e("a",{attrs:{href:"http://www.html-js.com/article/1743",target:"_blank"}},[t._v("2014最新面试题")])]),e("p",[e("a",{attrs:{href:"http://www.w3cfuns.com/thread-5598563-2-1.html",target:"_blank"}},[t._v("阿里前端面试题")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/imwtr/p/4685546.html",target:"_blank"}},[t._v("2016校招内推 -- 阿里巴巴前端 -- 三面面试经历")])]),e("p",[e("a",{attrs:{href:"http://www.w3cfuns.com/article-5599657-1-1.html",target:"_blank"}},[t._v("腾讯面试题")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/lvdabao/p/3660707.html",target:"_blank"}},[t._v("年后跳槽那点事：乐视+金山+360面试之行")])]),e("p",[e("a",{attrs:{href:"http://fatesinger.com/2722.html",target:"_blank"}},[t._v("阿里前端面试题上线")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/52cik/p/js-question-lg.html",target:"_blank"}},[t._v("拉勾网js面试题")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/allenxing/p/3724382.html",target:"_blank"}},[t._v("前端面试")])]),e("p",[e("a",{attrs:{href:"http://mianshiti.diandian.com",target:"_blank"}},[t._v("Web开发笔试面试题 大全")])]),e("p",[e("a",{attrs:{href:"http://segmentfault.com/a/1190000000465431",target:"_blank"}},[t._v("前端开发面试题")])]),e("p",[e("a",{attrs:{href:"https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions",target:"_blank"}},[t._v("2014最新前端面试题")])]),e("p",[e("a",{attrs:{href:"https://github.com/fex-team/interview-questions",target:"_blank"}},[t._v("百度面试")])]),e("p",[e("a",{attrs:{href:"http://www.w3cfuns.com/forum.php?mod=forumdisplay&fid=51&filter=typeid&typeid=177",target:"_blank"}},[t._v("面试题")])]),e("p",[e("a",{attrs:{href:"https://github.com/darcyclarke/Front-end-Developer-Interview-Questions/tree/master/Chinese",target:"_blank"}},[t._v("前端工作面试问题")])]),e("p",[e("a",{attrs:{href:"http://segmentfault.com/a/1190000000465431",target:"_blank"}},[t._v("前端开发面试题")])]),e("p",[t._v("5个经典的前端面试问题 5个经典的前端面试问题")]),e("p",[e("a",{attrs:{href:"http://segmentfault.com/a/1190000002562454",target:"_blank"}},[t._v("最全前端面试问题及答案总结")])]),e("p",[e("a",{attrs:{href:"http://www.html-js.com/article/Large-search-front-team-column%202961",target:"_blank"}},[t._v("如何面试一名前端开发工程师？")])]),e("p",[e("a",{attrs:{href:"https://github.com/hawx1993/Front-end-Interview-questions",target:"_blank"}},[t._v("史上最全 前端开发面试问题及答案整理")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/xiaoruo/p/4665163.html",target:"_blank"}},[t._v("前端实习生面试总结")])]),e("p",[e("a",{attrs:{href:"https://github.com/hawx1993/Front-end-Interview-questions",target:"_blank"}},[t._v("史上最全 前端开发面试问题及答案整理")])]),e("p",[e("a",{attrs:{href:"http://blog.jobbole.com/78738",target:"_blank"}},[t._v("BAT及各大互联网公司2014前端笔试面试题：JavaScript篇")])]),e("p",[e("a",{attrs:{href:"https://github.com/paddingme/Front-end-Web-Development-Interview-Question",target:"_blank"}},[t._v("前端开发面试题大收集")])]),e("p",[e("a",{attrs:{href:"https://github.com/qiu-deqing/FE-interview",target:"_blank"}},[t._v("收集的前端面试题和答案")])]),e("p",[e("a",{attrs:{href:"http://www.zhihu.com/question/19568008",target:"_blank"}},[t._v("如何面试前端工程师")])]),e("p",[e("a",{attrs:{href:"https://github.com/markyun/My-blog/blob/master/Front-end-Developer-Questions/Questions-and-Answers/README.md",target:"_blank"}},[t._v("前端开发面试题")])]),e("p",[e("a",{attrs:{href:"http://www.nowcoder.com/discuss?type=2",target:"_blank"}},[t._v("牛客网-笔试面经")])]),e("p",[t._v("iconfont")]),e("p",[t._v("iconfont 地址")]),e("p",[e("a",{attrs:{href:"http://www.zhihu.com/question/21253343",target:"_blank"}},[t._v("中文字体")])]),e("p",[e("a",{attrs:{href:"http://iconfont.cn",target:"_blank"}},[t._v("淘宝字库")])]),e("p",[e("a",{attrs:{href:"http://mux.alimama.com/fonts",target:"_blank"}},[t._v("字体")])]),e("p",[e("a",{attrs:{href:"http://iconfont.cn/help/platform.html",target:"_blank"}},[t._v("制作教程")])]),e("p",[e("a",{attrs:{href:"http://www.zhangxinxu.com/wordpress/?s=icomoon",target:"_blank"}},[t._v("zhangxinxu-icommon")])]),e("p",[e("a",{attrs:{href:"https://icomoon.io/app",target:"_blank"}},[t._v("icommon")])]),e("p",[e("a",{attrs:{href:"http://imooc.com/learn/243",target:"_blank"}},[t._v("用字体在网页中画ICON图标(推荐教程")])]),e("p",[e("a",{attrs:{href:"http://font-spider.org",target:"_blank"}},[t._v("字体压缩工具")])]),e("p",[t._v("Fiddler")]),e("p",[t._v("Fiddler 地址")]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/tugenhua0707/p/4623317.html",target:"_blank"}},[t._v("Fiddler调式使用知多少(一深入研究")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/strick/p/4570006.html",target:"_blank"}},[t._v("微信fiddle")])]),e("p",[e("a",{attrs:{href:"http://gaoboy.com/article/26.html",target:"_blank"}},[t._v("微信fiddle")])]),e("p",[t._v("Chrome")]),e("p",[t._v("Chrome 地址")]),e("p",[e("a",{attrs:{href:"https://developer.chrome.com/devtools",target:"_blank"}},[t._v("Google Chrome 官方")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/constantince/p/4565261.html",target:"_blank"}},[t._v("Chrome - 基础")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/constantince/p/4579121.html",target:"_blank"}},[t._v("Chrome - 进阶")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/constantince/p/4585983.html",target:"_blank"}},[t._v("Chrome - 性能")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/constantince/p/4607497.html",target:"_blank"}},[t._v("Chrome - 性能进阶")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/constantince/p/4624241.html",target:"_blank"}},[t._v("Chrome - 移动")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/liyunhua/p/4544738.html",target:"_blank"}},[t._v("Chrome - 使用技巧")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/Wayou/p/chrome-console-tips-and-tricks.html",target:"_blank"}},[t._v("Chrome -\n                    Console控制台不完全指南")])]),e("p",[e("a",{attrs:{href:"http://c7sky.com/chrome-devtools-workspace.html",target:"_blank"}},[t._v("Chrome - Workspace使浏览器变成IDE")])]),e("p",[e("a",{attrs:{href:"http://www.html-js.com/article/Nothing-blind%202975",target:"_blank"}},[t._v("network面板")])]),e("p",[e("a",{attrs:{href:"http://anti-code.com/devtools-cheatsheet",target:"_blank"}},[t._v("chrome开发工具快捷键")])]),e("p",[e("a",{attrs:{href:"http://www.html-js.com/article/2327",target:"_blank"}},[t._v("chrome调试工具常用功能整理")])]),e("p",[e("a",{attrs:{href:"http://www.iinterest.net/2014/05/09/chrome-dev-tool-workspace",target:"_blank"}},[t._v("Chrome 开发工具 Workspace\n                    使用")])]),e("p",[e("a",{attrs:{href:"http://www.cppblog.com/deercoder/archive/2011/10/22/158886.html",target:"_blank"}},[t._v("Chrome神器Vimium快捷键学习记录")])]),e("p",[e("a",{attrs:{href:"http://www.w3cplus.com/sassguide/debug.html",target:"_blank"}},[t._v("sass调试-w3cplus")])]),e("p",[e("a",{attrs:{href:"http://www.w3cplus.com/tools/how-to-use-chrome-devtools-like-a-pro.html",target:"_blank"}},[t._v("如何更专业的使用Chrome开发者工具-w3cplus")])]),e("p",[e("a",{attrs:{href:"http://sentsin.com/web/253.html",target:"_blank"}},[t._v("chrome调试canvas")])]),e("p",[e("a",{attrs:{href:"https://developer.chrome.com/devtools/index",target:"_blank"}},[t._v("chrome profiles1")])]),e("p",[e("a",{attrs:{href:"http://h5dev.uc.cn/article-25-1.html",target:"_blank"}},[t._v("chrome profiles2")])]),e("p",[e("a",{attrs:{href:"http://www.oschina.net/translate/performance-optimisation-with-timeline-profiles",target:"_blank"}},[t._v("chrome profiles3")])]),e("p",[e("a",{attrs:{href:"https://developer.chrome.com/devtools/docs/mobile-emulation",target:"_blank"}},[t._v("chrome移动版调试")])]),e("p",[e("a",{attrs:{href:"http://ued.taobao.org/blog/2012/06/debug-with-chrome-dev-tool",target:"_blank"}},[t._v("chrome调试")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/QLeelulu/archive/2011/08/28/2156402.html",target:"_blank"}},[t._v("chrome的调试")])]),e("p",[e("a",{attrs:{href:"https://developer.chrome.com/devtools/docs/commandline-api",target:"_blank"}},[t._v("chrome console 命令详解")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/leonkao/p/3809655.html",target:"_blank"}},[t._v("查看事件绑定1")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/xiaoyao2011/p/3447421.html",target:"_blank"}},[t._v("查看事件绑定2")])]),e("p",[e("a",{attrs:{href:"http://segmentfault.com/a/1190000000683599",target:"_blank"}},[t._v("神器——Chrome开发者工具(一")])]),e("p",[e("a",{attrs:{href:"https://xinranliu.me/2015-05-22-qiqu-performance",target:"_blank"}},[t._v("奇趣百科性能优化(Chrome DevTools 中的\n                    Timeline Profils 等工具使用介绍")])]),e("p",[e("a",{attrs:{href:"http://frontenddev.org/link/15-tips-of-chrome-developer-tools.html",target:"_blank"}},[t._v("chrome 开发者工具的 15\n                    个小技巧")])]),e("p",[e("a",{attrs:{href:"http://1ke.co/course/361",target:"_blank"}},[t._v("Chrome开发者工具不完全指南")])]),e("p",[e("a",{attrs:{href:"http://segmentfault.com/a/1190000003882567",target:"_blank"}},[t._v("Chrome 开发者工具使用技巧")])]),e("p",[t._v("Firebug")]),e("p",[t._v("Firebug 地址")]),e("p",[e("a",{attrs:{href:"http://www.imooc.com/learn/137",target:"_blank"}},[t._v("firebug视频教程")])]),e("p",[e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Tools/WebIDE",target:"_blank"}},[t._v("firefox 模拟器")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/ctriphire/p/4116207.html",target:"_blank"}},[t._v("console.log 命令详解")])]),e("p",[e("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2008/06/firebug_tutorial.html",target:"_blank"}},[t._v("Firebug入门指南")])]),e("p",[e("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2011/03/firebug_console_tutorial.html",target:"_blank"}},[t._v("Firebug控制台详解")])]),e("p",[t._v("移动,微信调试")]),e("p",[t._v("移动,微信调试 地址")]),e("p",[e("a",{attrs:{href:"https://openstf.github.io",target:"_blank"}},[t._v("浏览器端调试安卓")])]),e("p",[e("a",{attrs:{href:"http://yujiangshui.com/multidevice-frontend-debug",target:"_blank"}},[t._v("移动端前端开发调试")])]),e("p",[e("a",{attrs:{href:"https://github.com/yujiangshui/CN-Chrome-DevTools/blob/remote-debugging/md/Use-Tools/remote-debugging.md",target:"_blank"}},[t._v("使用 Chrome 远程调试 Android 设备")])]),e("p",[e("a",{attrs:{href:"http://plus.uc.cn/document/webapp/doc5.html",target:"_blank"}},[t._v("mac移动端调试")])]),e("p",[e("a",{attrs:{href:"http://www.mihtool.com",target:"_blank"}},[t._v("mac移动端调试")])]),e("p",[e("a",{attrs:{href:"http://thx.github.io/mobile/debugging-in-mobile",target:"_blank"}},[t._v("无线调试攻略")])]),e("p",[e("a",{attrs:{href:"http://yanhaijing.com/mobile/2014/12/17/web-debug-for-mobile",target:"_blank"}},[t._v("无线调试攻略")])]),e("p",[e("a",{attrs:{href:"http://www.jianshu.com/p/ccf124f1f74b",target:"_blank"}},[t._v("屌爆了,完美调试 微信webview(x5")])]),e("p",[t._v("微信调试的那些事 微信调试的那些事")]),e("p",[e("a",{attrs:{href:"http://jsconsole.com",target:"_blank"}},[t._v("远程console")])]),e("p",[e("a",{attrs:{href:"http://blog.qqbrowser.cc",target:"_blank"}},[t._v("微信调试工具")])]),e("p",[e("a",{attrs:{href:"https://github.com/jieyou/remote_inspect_web_on_real_device",target:"_blank"}},[t._v("各种真机远程调试方法汇总")])]),e("p",[t._v("iOS Simulator")]),e("p",[t._v("iOS Simulator 地址")]),e("p",[t._v("Simulator iOS_Simulator_Guide-Introduction")]),e("p",[e("a",{attrs:{href:"http://www.crifan.com/intro_ios_simulator_in_xcode_and_usage_summary",target:"_blank"}},[t._v("iOS\n                    Simulator的介绍和使用心得")])]),e("p",[t._v("img")]),e("p",[t._v("img 地址")]),e("p",[e("a",{attrs:{href:"http://preloaders.net/en/circular",target:"_blank"}},[t._v("loading img")])]),e("p",[e("a",{attrs:{href:"http://zhitu.isux.us",target:"_blank"}},[t._v("智图-图片优化平台")])]),e("p",[e("a",{attrs:{href:"https://tinypng.com",target:"_blank"}},[t._v("在线png优化")])]),e("p",[t._v("生成二维码")]),e("p",[t._v("生成二维码 地址")]),e("p",[e("a",{attrs:{href:"http://cli.im",target:"_blank"}},[t._v("生成二维码")])]),e("p",[t._v("浏览器同步")]),e("p",[t._v("浏览器同步 地址")]),e("p",[e("a",{attrs:{href:"https://github.com/leeluolee/puer",target:"_blank"}},[t._v("puer")])]),e("p",[e("a",{attrs:{href:"http://livereload.com",target:"_blank"}},[t._v("liveReload")])]),e("p",[e("a",{attrs:{href:"http://getf5.com",target:"_blank"}},[t._v("f5")])]),e("p",[e("a",{attrs:{href:"http://geek100.com/2608",target:"_blank"}},[t._v("File Watchers")])]),e("p",[t._v("在线PPT制作")]),e("p",[t._v("在线PPT制作 地址")]),e("p",[t._v("nodePPT nodePPT")]),e("p",[e("a",{attrs:{href:"http://www.jeffjade.com/2015/10/15/2015-10-16-cleaver-make-ppt/",target:"_blank"}},[t._v("Cleaver快速制作网页PPT")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/Darren_code/archive/2013/01/04/impressjs.html",target:"_blank"}},[t._v("impress.js")])]),e("p",[e("a",{attrs:{href:"https://github.com/ksky521/nodePPT",target:"_blank"}},[t._v("PPT")])]),e("p",[e("a",{attrs:{href:"https://github.com/hakimel/reveal.js",target:"_blank"}},[t._v("reveal")])]),e("p",[e("a",{attrs:{href:"https://github.com/Seldaek/slippy",target:"_blank"}},[t._v("slippy")])]),e("p",[t._v("前端导航网站")]),e("p",[t._v("前端导航网站 地址")]),e("p",[e("a",{attrs:{href:"http://uxbees.com/index.html",target:"_blank"}},[t._v("界面清爽的前端导航")])]),e("p",[e("a",{attrs:{href:"http://whycss.com",target:"_blank"}},[t._v("前端导航")])]),e("p",[e("a",{attrs:{href:"http://www.daqianduan.com/nav",target:"_blank"}},[t._v("前端网址导航")])]),e("p",[e("a",{attrs:{href:"http://sentsin.com/daohang",target:"_blank"}},[t._v("前端名录")])]),e("p",[e("a",{attrs:{href:"http://123.jser.us",target:"_blank"}},[t._v("前端导航")])]),e("p",[e("a",{attrs:{href:"http://www.css88.com/nav",target:"_blank"}},[t._v("前端开发资源")])]),e("p",[e("a",{attrs:{href:"http://www.haourl.cn",target:"_blank"}},[t._v("网址导航")])]),e("p",[e("a",{attrs:{href:"http://code.ciaoca.com",target:"_blank"}},[t._v("前端开发仓库 - 众多效果的收集地")])]),e("p",[e("a",{attrs:{href:"https://github.com/jnoodle/f2e-collect",target:"_blank"}},[t._v("前端资源导航")])]),e("p",[e("a",{attrs:{href:"http://f2e.im/static/pages/nav/index.html",target:"_blank"}},[t._v("F2E 前端导航")])]),e("p",[t._v("常用CDN")])])}],Ti={},Ei=Ti,Oi=(e("73ca"),Object(v["a"])(Ei,ji,Pi,!1,null,"74831d10",null)),Mi=Oi.exports,Ai={components:{m1:ql,m2:Vl,m3:ni,m4:li,m5:vi,m6:fi,m7:Ci,m8:Mi},data:function(){return{tab:"m1",tabs:[{label:"git",value:"m1"},{label:"webpack",value:"m2"},{label:"nginx",value:"m3"},{label:"基本",value:"m4"},{label:"基本",value:"m5"},{label:"基本",value:"m6"},{label:"基本",value:"m7"},{label:"基本",value:"m8"}]}}},Ni=Ai,Ii=Object(v["a"])(Ni,Dl,zl,!1,null,"61495d6f",null),Di=Ii.exports,zi={components:{basics:An,css:Ie,js:Za,http:ns,vue:go,other:Il,tool:Di,react:To},data:function(){return{tab:"basics",tabs:[{label:"basics",value:"basics"},{label:"css",value:"css"},{label:"js",value:"js"},{label:"http",value:"http"},{label:"vue",value:"vue"},{label:"react",value:"react"},{label:"other",value:"other"},{label:"tool",value:"tool"}]}}},$i=zi,Ri=Object(v["a"])($i,it,ct,!1,null,"4cdd1c9e",null),Ji=Ri.exports,Li=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+(n+1),label:n+1+"."+t.text}})})),1),e("m"+t.tab,{tag:"component"})],1)},Hi=[],qi=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Fi=[],Wi={},Bi=Wi,Ui=Object(v["a"])(Bi,qi,Fi,!1,null,"370967c9",null),Gi=Ui.exports,Vi=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Xi=[],Qi={},Yi=Qi,Ki=Object(v["a"])(Yi,Vi,Xi,!1,null,"0d154f0a",null),Zi=Ki.exports,tc=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},nc=[],ec={},ac=ec,rc=Object(v["a"])(ac,tc,nc,!1,null,"39bd936a",null),sc=rc.exports,oc=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},lc=[],ic={},cc=ic,pc=Object(v["a"])(cc,oc,lc,!1,null,"8da5c4e8",null),bc=pc.exports,uc=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},vc=[],gc={},mc=gc,_c=Object(v["a"])(mc,uc,vc,!1,null,"e18df666",null),dc=_c.exports,hc=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},fc=[],yc={},Sc=yc,wc=Object(v["a"])(Sc,hc,fc,!1,null,"6544ec0e",null),kc=wc.exports,xc=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Cc=[],jc={},Pc=jc,Tc=Object(v["a"])(Pc,xc,Cc,!1,null,"3b50d34f",null),Ec=Tc.exports,Oc=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Mc=[],Ac={},Nc=Ac,Ic=Object(v["a"])(Nc,Oc,Mc,!1,null,"115cba90",null),Dc=Ic.exports,zc={components:{m1:Gi,m2:Zi,m3:sc,m4:bc,m5:dc,m6:kc,m7:Ec,m8:Dc},data:function(){return i()({tab:1,tabs:[1,2,3,4,5,6,7,8]},"tabs",[{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"}])}},$c=zc,Rc=Object(v["a"])($c,Li,Hi,!1,null,"f3a76c80",null),Jc=Rc.exports,Lc={components:{web:Ji,ios:lt,android:Jc},data:function(){return{tab:"web",tabs:["web","ios","android"]}}},Hc=Lc,qc=Object(v["a"])(Hc,a,r,!1,null,"36cebbac",null);n["default"]=qc.exports},"7ebcb":function(t,n,e){"use strict";e.r(n);var a=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+(n+1),label:n+1+"."+t.text}})})),1),e("m"+t.tab,{tag:"component"})],1)},r=[],s=e("9523"),o=e.n(s),l=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n   rrrrrrrrrrrrrrrrrrrr\n")])},i=[],c={},p=c,b=e("2877"),u=Object(b["a"])(p,l,i,!1,null,"9c63039c",null),v=u.exports,g=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    yyyyyyyyyyyyyyyyyyyyyyyy\n")])},m=[],_={},d=_,h=Object(b["a"])(d,g,m,!1,null,"08432fc3",null),f=h.exports,y=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},S=[],w={},k=w,x=Object(b["a"])(k,y,S,!1,null,"71db3503",null),C=x.exports,j=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},P=[],T={},E=T,O=Object(b["a"])(E,j,P,!1,null,"47e71c44",null),M=O.exports,A=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},N=[],I={},D=I,z=Object(b["a"])(D,A,N,!1,null,"1df30385",null),$=z.exports,R=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},J=[],L={},H=L,q=Object(b["a"])(H,R,J,!1,null,"18022a74",null),F=q.exports,W=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},B=[],U={},G=U,V=Object(b["a"])(G,W,B,!1,null,"6bea5bf2",null),X=V.exports,Q=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Y=[],K={},Z=K,tt=Object(b["a"])(Z,Q,Y,!1,null,"bfd28d70",null),nt=tt.exports,et={components:{m1:v,m2:f,m3:C,m4:M,m5:$,m6:F,m7:X,m8:nt},data:function(){return o()({tab:1,tabs:[1,2,3,4,5,6,7,8]},"tabs",[{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"}])}},at=et,rt=Object(b["a"])(at,a,r,!1,null,"4d253e9c",null);n["default"]=rt.exports},"7ec5":function(t,n,e){"use strict";e.r(n);var a=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{staticClass:"q-mx-lg"},[e("div",{staticClass:"text-h5 q-my-md"},[t._v("路在脚下")]),e("q-timeline",{attrs:{color:"secondary"}},t._l(t.record,(function(n,a){return e("q-timeline-entry",{key:"record_note__tmleline"+a,attrs:{title:n.date}},[e("div",[t._v("\n         "+t._s(n.note)+"\n        ")])])})),1)],1)},r=[],s=[{date:"2020-10-26 21:27:41",note:"书架 加入书籍"},{date:"2020-10-26 00:34:16",note:"书架 加入书籍"},{date:"2020-10-23 03:04:00",note:"书架 加入书籍"},{date:"2020-10-10 02:41:11",note:"node   加入 全栈项目依赖"},{date:"2020-10-10 02:32:16",note:"linux   加入 shell 基础"},{date:"2020-08-29 02:15:49",note:"web  css 加入 SASS总结"},{date:"2020-08-29 01:31:47",note:"linux 加入部分内容"}],o={data:function(){return{record:s}}},l=o,i=e("2877"),c=Object(i["a"])(l,a,r,!1,null,"7bb02516",null);n["default"]=c.exports},"84df":function(t,n,e){"use strict";e.r(n);var a=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+(n+1),label:n+1+"."+t.text}})})),1),e("m"+t.tab,{tag:"component"})],1)},r=[],s=e("9523"),o=e.n(s),l=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n   rrrrrrrrrrrrrrrrrrrr\n")])},i=[],c={},p=c,b=e("2877"),u=Object(b["a"])(p,l,i,!1,null,"68ac946d",null),v=u.exports,g=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    yyyyyyyyyyyyyyyyyyyyyyyy\n")])},m=[],_={},d=_,h=Object(b["a"])(d,g,m,!1,null,"491e7330",null),f=h.exports,y=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},S=[],w={},k=w,x=Object(b["a"])(k,y,S,!1,null,"ae421804",null),C=x.exports,j=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},P=[],T={},E=T,O=Object(b["a"])(E,j,P,!1,null,"7eeadb3f",null),M=O.exports,A=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},N=[],I={},D=I,z=Object(b["a"])(D,A,N,!1,null,"54f6c280",null),$=z.exports,R=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},J=[],L={},H=L,q=Object(b["a"])(H,R,J,!1,null,"2b02a9c1",null),F=q.exports,W=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},B=[],U={},G=U,V=Object(b["a"])(G,W,B,!1,null,"010e9102",null),X=V.exports,Q=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Y=[],K={},Z=K,tt=Object(b["a"])(Z,Q,Y,!1,null,"51cb0f7a",null),nt=tt.exports,et={components:{m1:v,m2:f,m3:C,m4:M,m5:$,m6:F,m7:X,m8:nt},data:function(){return o()({tab:1,tabs:[1,2,3,4,5,6,7,8]},"tabs",[{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"}])}},at=et,rt=Object(b["a"])(at,a,r,!1,null,"58306039",null);n["default"]=rt.exports},"8e7f":function(t,n,e){"use strict";e.r(n);var a=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+(n+1),label:n+1+"."+t.text}})})),1),e("m"+t.tab,{tag:"component"})],1)},r=[],s=e("9523"),o=e.n(s),l=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n   rrrrrrrrrrrrrrrrrrrr\n")])},i=[],c={},p=c,b=e("2877"),u=Object(b["a"])(p,l,i,!1,null,"0abafd36",null),v=u.exports,g=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    yyyyyyyyyyyyyyyyyyyyyyyy\n")])},m=[],_={},d=_,h=Object(b["a"])(d,g,m,!1,null,"ccff9720",null),f=h.exports,y=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},S=[],w={},k=w,x=Object(b["a"])(k,y,S,!1,null,"cdfea214",null),C=x.exports,j=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},P=[],T={},E=T,O=Object(b["a"])(E,j,P,!1,null,"6f0c9637",null),M=O.exports,A=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},N=[],I={},D=I,z=Object(b["a"])(D,A,N,!1,null,"45187d78",null),$=z.exports,R=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},J=[],L={},H=L,q=Object(b["a"])(H,R,J,!1,null,"1b2464b9",null),F=q.exports,W=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},B=[],U={},G=U,V=Object(b["a"])(G,W,B,!1,null,"1d9f680c",null),X=V.exports,Q=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Y=[],K={},Z=K,tt=Object(b["a"])(Z,Q,Y,!1,null,"7187998a",null),nt=tt.exports,et={components:{m1:v,m2:f,m3:C,m4:M,m5:$,m6:F,m7:X,m8:nt},data:function(){return o()({tab:1,tabs:[1,2,3,4,5,6,7,8]},"tabs",[{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"}])}},at=et,rt=Object(b["a"])(at,a,r,!1,null,"3d50bcb2",null);n["default"]=rt.exports},9227:function(t,n,e){"use strict";e.r(n);var a=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+(n+1),label:n+1+"."+t.text}})})),1),e("m"+t.tab,{tag:"component"})],1)},r=[],s=e("9523"),o=e.n(s),l=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n   rrrrrrrrrrrrrrrrrrrr\n")])},i=[],c={},p=c,b=e("2877"),u=Object(b["a"])(p,l,i,!1,null,"2415d40c",null),v=u.exports,g=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    yyyyyyyyyyyyyyyyyyyyyyyy\n")])},m=[],_={},d=_,h=Object(b["a"])(d,g,m,!1,null,"74ec34fb",null),f=h.exports,y=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},S=[],w={},k=w,x=Object(b["a"])(k,y,S,!1,null,"bb9ca26a",null),C=x.exports,j=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},P=[],T={},E=T,O=Object(b["a"])(E,j,P,!1,null,"783d960c",null),M=O.exports,A=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},N=[],I={},D=I,z=Object(b["a"])(D,A,N,!1,null,"4e497d4d",null),$=z.exports,R=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},J=[],L={},H=L,q=Object(b["a"])(H,R,J,!1,null,"2455648e",null),F=q.exports,W=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},B=[],U={},G=U,V=Object(b["a"])(G,W,B,!1,null,"0b3d6862",null),X=V.exports,Q=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Y=[],K={},Z=K,tt=Object(b["a"])(Z,Q,Y,!1,null,"5f2599e0",null),nt=tt.exports,et={components:{m1:v,m2:f,m3:C,m4:M,m5:$,m6:F,m7:X,m8:nt},data:function(){return o()({tab:1,tabs:[1,2,3,4,5,6,7,8]},"tabs",[{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"}])}},at=et,rt=Object(b["a"])(at,a,r,!1,null,"24e2967e",null);n["default"]=rt.exports},a210:function(t,n,e){"use strict";e.r(n);var a=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+(n+1),label:n+1+"."+t.text}})})),1),e("m"+t.tab,{tag:"component"})],1)},r=[],s=e("9523"),o=e.n(s),l=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n   rrrrrrrrrrrrrrrrrrrr\n")])},i=[],c={},p=c,b=e("2877"),u=Object(b["a"])(p,l,i,!1,null,"12710b2c",null),v=u.exports,g=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    yyyyyyyyyyyyyyyyyyyyyyyy\n")])},m=[],_={},d=_,h=Object(b["a"])(d,g,m,!1,null,"4df3af09",null),f=h.exports,y=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},S=[],w={},k=w,x=Object(b["a"])(k,y,S,!1,null,"cdaa2706",null),C=x.exports,j=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},P=[],T={},E=T,O=Object(b["a"])(E,j,P,!1,null,"6f36d3be",null),M=O.exports,A=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},N=[],I={},D=I,z=Object(b["a"])(D,A,N,!1,null,"4542baff",null),$=z.exports,R=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},J=[],L={},H=L,q=Object(b["a"])(H,R,J,!1,null,"1b4ea240",null),F=q.exports,W=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},B=[],U={},G=U,V=Object(b["a"])(G,W,B,!1,null,"1d4aecfe",null),X=V.exports,Q=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Y=[],K={},Z=K,tt=Object(b["a"])(Z,Q,Y,!1,null,"71331e7c",null),nt=tt.exports,et={components:{m1:v,m2:f,m3:C,m4:M,m5:$,m6:F,m7:X,m8:nt},data:function(){return o()({tab:1,tabs:[1,2,3,4,5,6,7,8]},"tabs",[{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"}])}},at=et,rt=Object(b["a"])(at,a,r,!1,null,"40c4daf8",null);n["default"]=rt.exports},b047:function(t,n,e){"use strict";var a=e("fa2e"),r=e.n(a);r.a},bbaf:function(t,n,e){"use strict";e.r(n);var a=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+t.value,label:n+1+"."+t.label}})})),1),e("div",{staticClass:"q-mx-lg"},[e(""+t.tab,{tag:"component"})],1)],1)},r=[],s=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{},[e("q-markdown",{attrs:{src:t.MainComponent}})],1)},o=[],l="# node\n\n## 模块机制\n\n### CommonJS 规范\n\n- CommonJS 规范\n\n\t- 模块引用\n\t- 模块定义\n\t- 模块标识\n\n- 规范涵盖了模块\n\n\t- 二进制\n\t- Buffer\n\t- 字符集编码\n\t- I/O流\n\t- 进程环境\n\t- 文件系统\n\t- 套接字\n\t- 单元测试\n\t- Web服务器网关接口\n\t-  包管理\n\n### Node 的模块实现\n\n- 模块\n\n\t- 核心模块\n\t- 文件模块\n\t- Node对引入过的模块都会进行缓存,以减少二次引入时的开销\n\n- 模块标识符分析\n\n\t- 核心模块\n\t- 路径形式的文件模块\n\t- 自定义模块\n\n- 模块路径分析\n\n\t- Node在定位文件模块的具体文件时制定的查找策略,具体表现为一个路径组成的数组\n\t- 逐个尝试模块路径中的路径,直到找到目标文件为止\n\t- 沿路径向上逐级递归,直到根目录下的node_modules目录\n\n- 文件定位\n\n\t- 文件扩展名分析\n\n\t\t- Node会按.js、.json、.node的次序补 足扩展名,依次尝试\n\n\t- 目录分析和包\n\n\t\t- require()通过分析文件扩展名之后,可能没有查找到对应文件，得到一个目录\n\n- 模块编译\n\n\t- Node会新建一个模块对 象,然后根据路径载入并编译\n\t- .js文件。通过fs模块同步读取文件后编译执行\n\t- .node文件。这是用C/C++编写的扩展文件,通过dlopen()方法加载最后编译生成的文件\n\t- .json文件。通过fs模块同步读取文件后,用JSON.parse()解析返回结果\n\t- 其余扩展名文件。它们都被当做.js文件载入\n\t- 在编译的过程中,Node对获取的JavaScript文件内容进行了头尾包装\n\t- (function (exports, require, module, __filename, __dirname) {\\n,在尾部添加了\\n});\n\n### 核心模块\n\n- 核心模块 其实分为C/C++编写的和JavaScript编写的两部分\n\n\t- 其中C/C++文件存放在Node项目的src目录下\n\t- JavaScript文件存放在lib目录下\n\n- 1.转存为C/C++代码\n\n\t- Node采用了V8附带的js2c.py工具,将所有内置的JavaScript代码转换 成C++里的数组\n\n- 2.编译JavaScript核心模块\n\n\t- 与文件模块 有区别的地方在于:获取源代码的方式及缓存执行结果的位置\n\n- 那些由纯C/C++编写的部分统一称为内建模块\n- 1. 内建模块的组织形式\n\n\t- C/C++编写,性能上优于脚本语言\n\t- 被直接加载进内存中，无需文件定位编译，可直接执行\n\n- 2. 内建模块的导出\n\n\t- Node在启动时,会生成一个全局变量process,并提供Binding()方法来协助加载内建模块。\n\n### C/C++扩展模块\n\n- C/C++扩展模块属于文件模块中的一类\n- 一个平台下的.node文件在另一个平台下是无法加载执行的，必须重新编译\n- 前提条件\n\n\t- GYP项目生成工具\n\t- V8引擎C++库\n\t- libuv库\n\t- Node内部库\n\t- 其他库\n\n- 模块编写：C/C++扩展模块与内建模块的套路一样,将方法挂载在target对象上,然后通过NODE_MODULE 声明即可\n- 模块编译，在GYP工具的帮助下，编译过程会根据平台不同,分别通过make或vcbuild进行编译\n- 模块加载：require()方法通过解 析标识符、路径分析、文件定位,然后加载执行即可\n\n### 模块调用栈\n\n- JavaScript核心模块\n\n\t- 作为C/C++内建模块的封装层和桥接层, 供文件模块调用\n\t- 纯粹的功能模块\n\n### 包与 NPM\n\n- 在模块之外,包和 NPM则是将模块联系起来的一种机制\n- 包结构\n\n\t- 是一个存档文件\n\n- 包描述文件与NPM\n\n\t- 用于表达非代码相关的信息,package.json\n\n- NPM常用功能\n\n\t- 帮助完成了第三方模块的发布、安装和依赖等\n\t- 可以帮助用户快速安装和管理依赖包\n\n- 局域NPM\n\n\t- 企业搭建自己的NPM仓库\n\t- 享受到模块开发带来的低耦合和项目组织上的好处\n\t- 考虑到模块保密性的问题\n\n- NPM潜在问题\n\n\t- 包的质量\n\t- 安全性\n\n### 前后端共用模块\n\n- AMD规范是CommonJS模块规范的一个延伸\n- CMD规范与AMD规范的主要区别在于定义模块和依赖引入的部分\n\n## node简介\n\n### Node 的诞生历程\n\n### Node 的命名与起源\n\n- JavaScript比C的开发门槛要低\n- 比Lua的历史包袱要少\n- 有广泛的事件驱动方面的应用\n- 为其导入非阻塞I/O库 没有额外阻力\n- JavaScript引 擎V8摘得性能第一的桂冠\n- 为什么叫Node：每一个Node进程都构成这个网络应 用中的一个节点\n\n### Node 带来的意义\n\n- Node打破了过去JavaScript只能在浏览器中运行的局面\n- 大大降低前后端转换所需要的上下文交换代价\n\n### Node 的特点\n\n- 异步I/O\n- 事件与回调函数\n- 单线程\n- 跨平台\n\n### Node 应用场景\n\n- I/O密集型\n- 是否不擅长CPU密集型业务\n- 与遗留系统和平共处\n- 分布式应用\n\n## Cheney算法\n\n### semispace （From）空间\n\n- 使用中,对象分配时分配到 From 空间\n- 存活对象复制到To空间，空间角色交换\n\n## 异步I/O\n\n### 为什么要异步 I/O\n\n- 在跨网络的结构下,并发已经是现代编程中的标准配备了\n- 在浏览器中 JavaScript 执行与 UI 渲染共用一个线程\n- 前端通过异步可以消除掉UI阻塞的现象\n- 采用异步并发下载资源\n- 多线程的代价在于创建 线程和执行期线程上下文切换的开销较大\n- 但是串行执行的缺点在于性能\n- Node在两者之间给出了它的方案\n\n\t- 利用单线程,远离多线程死锁、状态同步等问题\n\t- 利用异 步I/O,让单线程远离阻塞,以更好地使用CPU\n\n### 异步 I/O 实现现状\n\n- 非阻塞I/O跟阻塞I/O的差别为调用之后会立即返回\n- 阻塞I/O造成CPU等待浪费\n- 非阻塞带来的麻烦却是需要轮询去确 认是否完全完成数据获取\n\n\t- read\n\t- select\n\t- poll\n\t- epoll\n\t- kqueue\n\n### Node 的异步 I/O\n\n- 事件循环\n\n\t- 在进程启动时,Node便会创建事件循环，循环执行事件关联的回调\n\n- 观察者\n\n\t- 每个事件循环中有一个或者多个观察者，观察者决定是否要执行事件\n\n- 请求对象\n\n\t- 从JavaScript发起调用到内核执行完I/O操作的 过渡过程中的中间对象\n\n- 执行回调\n\n\t- 组装好请求对象、送入I/O线程池等待执行,实际上完成了异步I/O的第一部分,回调通知是 第二部分。\n\n### 非 I/O 的异步 API\n\n- 定时器\n\n\t- 实现原理与异步I/O比较类似,只是不需要I/O线程池的参与\n\t- 定时器的问题在于,它并非精确的\n\n- process.nextTick()\n\n\t- setTimeout(fn, 0) 的 方式较为 浪费性能。 实际上, process.nextTick()方法的操作相对较为轻量\n\t- 每次调用process.nextTick()方法,只会将回调函数放入队列中,在下一轮Tick时取出执行\n\n- setImmediate\n\n\t- process.nextTick()中的回调函数执行的优先级要高于setImmediate()\n\n### 事件驱动与高性能服务器\n\n- 事件驱动的实质,即 通过主循环加事件触发的方式来运行程序\n- 事件循环是异步实现的核心,它 与浏览器中的执行模型基本保持了一致\n\n## 异步编程\n\n### 函数式编程\n\n- 高阶函数\n\n\t- 高阶函数则是可以把函数作为参数,或是将函数作为返回值的函数,\n\t- 除了通 常意义的函数调用返回外,还形成了一种后续传递风格\n\t- 在自定义事件实例中,通过为相同事件注册不同的回调函数,可以很灵活地处理业务逻辑\n\n- 偏函数用法\n\n\t- 通过指定部分参数来产生一个新的定制函数的形式就是偏函数\n\n### 异步编程的优势与难点\n\n- 优势\n\n\t- Node带来的最大特性莫过于基于事件驱动的非阻塞I/O模型\n\t- 只要合理利用Node的异步模型与V8的高性能,就可以充分 发挥CPU和I/O资源的优势\n\n- 难点\n\n\t- try/catch的功效在此异步编程中不会发挥任何作用\n\t- 函数嵌套过深\n\t- 阻塞代码\n\t- 多线程编程\n\t- 异步转同步\n\n### 异步编程解决方案\n\n- 事件发布/订阅模式\n\n\t- 事件发布/订阅模式可以实现一个事件与多 个回调函数的关联,这些回调函数又称为事件侦听器\n\n- Promise/Deferred模式\n\n\t- Promise通过封装异步调用,实现了正向用例和反向用例的分离以及逻辑处理延迟,\n\n- 流程控制库\n\n\t- 尾触发：需要手工调用才能持续执行后续调用的，关键字 next\n\t- 流程控制模块async\n\n\t\t- 异步的串行执行\n\t\t- 异步的并行执行\n\t\t- 自动依赖处理\n\n\t- 流程控制库 Step\n\n\t\t- 并行任务执行\n\t\t- 结果分组\n\n\t- 异步编程方案wind\n\n\t\t- 异步任务定义\n\t\t- $await()与任务模型\n\t\t- 异步方法转换辅助函数\n\n### 异步并发控制\n\n- bagpipe的解决方案\n\n\t- 通过一个队列来控制并发量\n\t- 如果当前活跃(指调用发起但未执行回调)的异步调用量小于限定值,从队列中取出执行\n\t- 如果活跃调用达到限定值,调用暂时存放在队列中\n\t- 每个异步调用结束时,从队列中取出新的异步调用执行\n\t- 拒绝模式\n\t- 超时控制\n\n- async的解决方案\n\n\t- async也提供了一个方法用于处理异步调用的限制:parallelLimit()。\n\t- parallelLimit()方法的缺陷在于无法动态地增加并行任务\n\n## 内存控制\n\n### v8垃圾回收机制与内存限制\n\n-  内存问题\n\n\t- Node是 一个构建在Chrome的JavaScript运行时上的平台\n\t- 内存控制正是在海量请求和长时间运行的前提下进行探讨的\n\t- 在Node中通过JavaScript 使用内存时就会发现只能使用部分内存（无法操作大内存对象，例如读取2G的文件）\n\n- V8限制内存的原因\n\n\t- 开始是为浏览器设置的，不太可能会存在用到大量内存的场景\n\t- V8的垃圾回收机制限制，不控制内存会导致垃圾回收时间加长，阻塞 js 线程执行\n\n- V8 的对象分配\n\n\t- 在V8中,所有的JavaScript对象都是通过堆来进行分配的\n\t- 根据对象的存货时间将内存的垃圾回收进行不同的分代，分别施以高效算法\n\t- 老生代中的对象为存活时间较长或常驻内存的对象\n\t- 新生代中的对象为存活时间较短的对象\n\n- V8 的垃圾回收机制\n\n\t- Scavenge算法：就是通过将存活对象在两个 semispace空间之间进行复制\n\t- Mark-Sweep算法：通过标记活对象，清理死亡对象\n\t- Mark-Compact算法，将或对象移动到老生代一端，解决内存碎片问题\n\t- V8主要使用Mark-Sweep,在空间不足以对从新 生代中晋升过来的对象进行分配时才使用Mark-Compact。\n\t- 垃圾回收需要将应用逻辑暂停下来即“全停顿”\n\t- 垃圾回收的优化\n\n\t\t- 拆分全停顿，应用执行一小会，垃圾回收执行一个拆分\n\t\t- 延迟清理\n\t\t- 增量式整理\n\n### 高效使用内存\n\n- 作用域\n\n\t- 函数执行结束后，函数作用域被销毁，函数作用域中声明的变量也销毁\n\t- 全局作用域需要直到 进程退出才能释放\n\t- 如果需要释放常驻内 存的对象,可以通过delete操作来删除引用关系。或者将变量重新赋值,让旧的对象脱离引用关系。\n\n- 闭包\n\n\t- 作用域链上的对象访问只能向上,这样外部无法向内部访问\n\t- 实现外部作用域访问内部作用域中变量的方法叫做闭包\n\t- 闭包使得外部作用域对闭包定义的词法作用域有引用，因此词法作用域不会释放，内存也不会释放\n\t- 在正常的JavaScript执行中,无法立即回收的内存有闭包和全局变量引用这两种情况\n\n### 内存指标\n\n- 进程的内存总共有几部分\n\n\t- rss 进程的常驻内存部分\n\t- 交换区\n\t- 文件系统\n\n- process.memoryUsage() 可以查看内存使用情况\n\n\t- 堆中的内存用量总是小于进程的常驻内存用量，即内存并非都是通过V8分配的\n\n- os.totalmem() 可以查看系统的总内存\n- os.freemem() 可以查看系统的闲置内存\n\n### 内存泄露\n\n- 慎将内存当做缓存\n\n\t- 在node 中一旦一个对象被缓存起来，就会被放到老生代中\n\t- 长期存在的对象会使得垃圾回收扫描整理的时候对这些对象做无用功\n\t- 由于模块的缓存机制,模块是常驻老生代的\n\t- 采用进程外的缓存,进程自身不存储状态\n\n- 关注队列外状态\n\n\t- 一旦消费速度低于生产速度, 将会形成堆积\n\t- 启用超时模式时,调用加入到队列中就 开始计时,超时就直接响应一个超时错误\n\t- 拒绝模式时,当队列拥塞时,新到来的调用会直 接响应拥塞错误\n\n### 内存泄露排查\n\n- node-heapdump\n- node-memwatch\n- 通过对堆内存进行分析而找到\n\n### 大内存应用\n\n- 由于Node的内存限制,操作大文件 也需要小心,好在Node提供了stream模块用于处理大文件。\n\n## 理解Buffer\n\n### Buffer 结构\n\n- Buffer所占用的内存不是通过V8分配的,属于堆外内存\n- Buffer受Array类型的影响很大,可以访问length属性得到长度,也可以通过下标访问元素\n- Node在内存的使用上应用的是在C++ 层面申请内存、在JavaScript中分配内存的策略\n- Node采用了slab动态内存管理分配机制\n\n### Buffer 的转换\n\n- 字符串转Buffer\n\n\t- 通过构造函数转换的Buffer对象,存储的只能是一种编码类型\n\t- 一个Buffer对象可以存储不同编码类型的字符串转码的值\n\n- Buffer转字符串\n\n\t- Buffer对象的toString()可以将Buffer对象转换为字 符串\n\n- Buffer不支持的编码类型\n\n\t- 只有少数的几种编码类型可以 在字符串和Buffer之间转换\n\t- Buffer提供了一个isEncoding()函数来判断编码是否支持转换\n\t- 对于不支持的编码类型,可以借助Node生态圈中的模块完成转换\n\n### Buffer 的拼接\n\n- 乱码是如何产生的\n\n\t- 文件可读流在读取时会逐个读取Buffer\n\t- 对于任意长度的Buffer而言,宽字节字符串都有 可能存在被截断的情况\n\n- setEncoding()与string_decoder()\n\n\t- 让data事件中传递的不再是一个Buffer对象,而是编码后的字符串\n\t- 可读流对象在内部设置了一个decoder对象,进行Buffer到字符串的解码,然后传递给调用者\n\n- 正确拼接Buffer\n\n\t- 正确的拼接方式是用一个数组来存储接收到的所有Buffer片段并记录下所有片段的总长度\n\t- 然后调用 Buffer.concat() 方法生成一个合并的Buffer对象\n\n### Buffer 与性能\n\n- 通过预先转换静态内容为Buffer对象,可以有效地减少CPU的重复使用,节省服务器资源\n- 动态内容和静态内容分离,静态内容部分可以通 过预先转换为Buffer的方式,使性能得到提升\n- 尽量只读取Buffer,然后直接传输,不做额外的转换,避免损耗\n\n## 网络编程\n\n### 构建TCP 服务\n\n- 创建 TCP 服务器\n\n\t- TCP全名为传输控制协议，在OSI模型(由七层组成,分别为物理层、数据链结层、\n网络层、 传输层、会话层、表示层、应用层)中属于传输层协议。\n\t- 3次握手创建会话\n\t- 服务 器端和客户端分别提供一个套接字,这两个套接字共同形成一个连接\n\n- TCP 服务的事件\n\n\t- 服务器事件，listening，connection，close，error\n\t- 连接事件，data，end，connect，drain，error，close，timeout\n\t- TCP针对网络中的小数据包有一定的优化策略:Nagle算法\n\n### 构建UDP服务\n\n- UDP\n\n\t- 在 UDP 中,一个套接字可以与多个 UDP 服务通信\n\t- UDP 又称用户数据包协议,与 TCP 一样同属于网络传输层\n\t- 无须连接,资源消耗低,处理快速且灵活\n\n- 若想让UDP套接字接收网络消息,只要调用dgram.bind(port, [address])方法对网卡和端口 进行绑定即可\n- UDP 是一个EventEmitter的实例,而非Stream 的实例，具有自定义事件，message，listening，close，error\n\n### 构建HTTP服务\n\n- HTTP\n\n\t- HTTP的全称是超文本传输协议\n\t- HTTP构建在TCP之上,属于应用层协议\n\n- HTTP报文\n\n\t- 第一部分内容为经典的 TCP的3次握手过程\n\t- 第二部分是在完成握手之后,客户端向服务器端发送请求报文\n\t- 第三部分是服务器端完成处理后,向客户端发送响应内容,包括响应头和响应体\n\t- 最后部分是结束会话的信息\n\n- HTTP客户端事件，response，socket，connect，upgrade，protocols，continue\n\n### 构建 WebSocket 服务\n\n- WebSocket\n\n\t- WebSocket客户端基于事件的编程模型与Node中自定义事件相差无几\n\t- WebSocket实现了客户端与服务器端之间的长连接\n\t- 客户端与服务器端只建立一个TCP连接,可以使用更少的连接。\n\t- WebSocket服务器端可以推送数据到客户端\n\t- 有更轻量级的协议头,减少数据传送量\n\n- WebSocket握手\n\n\t- upgrade\n\t- 切换协议\n\n- WebSocket数据传输\n\n\t- 为了安全考虑,客户端需要对发送的数据帧进行掩码处理\n\n### 网络服务与安全\n\n- SSL作为一种安全协议,它在传输层提供对网络连接加密的功能\n- Node在网络安全模块\n\n\t- crypto\n\n\t\t- 主要用于加 密解密,SHA1、MD5等加密算法都在其中有体现,\n\n\t- tls\n\n\t\t- TLS/SSL是一个公钥/私钥的结构,它是一个非对称的结构\n\t\t- 公钥用来加密要传输的数据,私钥用来解密接收到的数据\n\t\t- 为了防止中间人攻击,TLS/SSL引入了数字证书来进行认证\n\t\t- 创建服务器端\n\n\t\t\t- 创建一个安全的TCP服务\n\t\t\t- 测试证书是否正常\n\n\t\t- TLS客户端\n\n\t\t\t- 启动客户端的过程中,用到了为客户端生成的私钥、证书、CA证书\n\n\t- https\n\n\t\t- HTTPS服务就是工作在TLS/SSL上的HTTP\n\t\t- 1. 准备证书\n\t\t- 2. 创建HTTPS服务\n\t\t- 3. HTTPS客户端\n\n## 构建Web应用\n\n### 基础功能\n\n- 请求方法\n\n\t- 最常见的请求方法是GET和POST,除此之外,还有HEAD、DELETE、PUT、CONNECT 等方法\n\t- PUT代表新建一个资源,POST表示要更新一个资源,GET表示查看一个资源, 而DELETE表示删除一个资源\n\n- 路径解析\n\n\t- 客户端代理(浏览器)会将这个地址解析成报文,将路径和查询部分放在报文第一行\n\n- 查询字符串\n\n\t- 这个字符串会跟随在路径后,形成请求报文首行的第二部分\n\n- Cookie\n\n\t- 能记录服务器与客户端之间的状态\n\t- 设置的Cookie过多,将会导致报头较 大\n\n\t\t- 减小Cookie的大小\n\t\t- 为静态组件使用不同的域名\n\t\t- 减少DNS查询\n\n\t- path\n\t- Expires和Max-Age是\n\t- HttpOnly\n\t- Secure\n\n- Session\n\n\t- Session的数据只保留在服务器端,客户 端无法修改\n\t- 基于Cookie来实现用户和数据的映射\n\t- 通过查询字符串来实现浏览器端和服务器端数据的对应\n\n- 缓存\n\n\t- 设置缓存\n\n\t\t- 添加Expires 或Cache-Control 到报文头中\n\t\t- 配置 ETags\n\t\t- 让Ajax 可缓存\n\n\t- 清除缓存\n\n\t\t- 路径中跟随Web应用的版本号\n\t\t- 路径中跟随该文件内容的hash值\n\n- Basic认证\n\n\t- 当客户端与服务器端进行请求时,允许通过用户名和密码实现的一种身份认证 方式\n\n### 数据上传\n\n- 表单数据\n\n\t- Content-Type: application/x-www-form-urlencoded\n\n- 其他格式\n\n\t- JSON类型的值为 Content-Type：application/json\n\t- XML的值为 Content-Type：application/xml\n\n- 附件上传\n\n\t- Content-Type: multipart/form-data\n\n- 数据上传与安全\n\n\t- 内存限制\n\n\t\t- 限制上传内容的大小\n\t\t- 通过流式解析,将数据流导向到磁盘中，Node只保留文件路径等小数据\n\n\t- CSRF\n\n### 路由解析\n\n- 文件路径型\n\n\t- 静态文件\n\t- 动态文件\n\n- MVC\n\n\t- 控制器(Controller),一组行为的集合\n\t- 模型(Model),数据相关的操作和封装\n\t- 视图(View),视图的渲染\n\t- 路由解析,根据URL寻找到对应的控制器和行为\n\t- 行为调用相关的模型,进行数据操作\n\t- 数据操作结束后,调用视图和相关数据进行页面渲染,输出到客户端\n\n- RESTful\n\n\t- 请求方法作为逻辑分发的单元\n\t- 将服务器端提供的内容实体看作一个资源\n\t- 操作行为主要体现在行为上,主要使用的请求方法是POST和GET\n\n### 中间件\n\n- 异常处理\n\n\t- 为next()方法添加err参数,并捕获中间件直接抛出的同步异常\n\t- 中间件异步产生的异常需要自己 传递出来\n\n- 中间件与性能\n\n\t- 编写高效的中间件\n\t- 合理使用路由\n\n### 页面渲染\n\n- 内容响应\n\n\t- MIME\n\t- 附件下载\n\t- 响应JSON\n\t- 响应跳转\n\n- 视图渲染\n\n\t- 在动态页面技术中,最终的视图是由 模板和数据共同生成出来的\n\n- 模板\n\n\t- 模板语言\n\t- 包含模板语言的模板文件\n\t- 拥有动态数据的数据对象\n\t- 模板引擎\n\t- 模板引擎\n\n\t\t- 模板编译\n\n\t- with的应用\n\n\t\t- 模板安全\n\n\t- 模板逻辑\n\t- 集成文件系统\n\t- 子模板\n\t- 布局视图\n\t- 模板性能\n\n- Bigpipe\n\n\t- 前端加载技术,它的提出主要是为了解决重数据页面 的加载速度问题\n\t- Bigpipe是一个需要前后端配合实现的优化技术\n\n\t\t- 页面布局框架\n\t\t- 持续数据输出\n\t\t- 前端渲染\n\n\t- Bigpipe将网页布局和数据渲染分离\n\n## 玩转进程\n\n### 服务模型的变迁\n\n- 石器时代:同步\n\n\t- 服务模式是一次只为一个请求服务\n\n- 青铜时代:复制进程\n\n\t- 通过进程的复制同时服务更多的请求和用 户\n\n- 白银时代:多线程\n\n\t- 让一个线程服务一个请求，并且线程之间可以共享数据\n\n- 黄金时代:事件驱动\n\n\t- 为了解决高并发问题,基于事件驱动的服务模型出现了\n\n### 多进程架构\n\n- 理想状态下每个 进程各自利用一个CPU,以此实现多核CPU的利用\n- 创建子进程\n\n\t- child_process模块给予Node可以随意创建子进程(child_process)的能力\n\n- 进程间通信\n\n\t- 主线程与工作线程之间通过onmessage()和postMessage()进行通信\n子进程对象则由send()方法实现主进程向子进程发送数据\n\n- 句柄传递\n\n\t- 一种可以用来标识资源的引用,它的内部包含了指向对象的文件描述 符\n\n### 集群稳定之路\n\n- 进程事件\n\n\t- message\n\t- error\n\t- exit\n\t- close\n\t- disconnect\n\n- 自动重启\n\n\t- 自杀信号\n\t- 限量重启\n\n- 负载均衡\n\n\t- 操作系统的抢占式策略，闲着的进程对到来的请求进行争抢,谁抢到谁服务\n\n- 状态共享\n\n\t- 数据共享：第三方数据存储\n\t- 主动通知\n\n### Cluster 模块\n\n- Cluster 工作原理\n\n\t- 事实上cluster模块就是child_process和net模块的组合应用\n\n- Cluster 事件\n\n\t- fork\n\t- online\n\t- listening\n\t- disconnect\n\t- exit\n\t- setup\n\n## 测试\n\n### 单元测试\n\n- 测试代码的原则\n\n\t- 单一职责\n\t- 接口抽象\n\t- 层次分离\n\n- 单元测试介绍\n\n\t- 断言\n\t- 测试框架\n\t- 测试代码的文件组织\n\t- 测试用例\n\t- 测试覆盖率\n\t- mock\n\t- 私有方法的测试\n\n- 工程化与自动化\n\n\t- 工程化\n\t- 持续集成\n\n### 性能测试\n\n- 基准测试\n\n\t- 基准测试要统计的就是在多少 时间内执行了多少次某个方法\n\n- 压力测试\n\n\t- 会对网络接口进行压力测试以判断网络接口 的性能\n\n- 基准测试驱动开发\n\n\t- 写基准测试\n\t- 写/改代码\n\t- 收集数据\n\t- 找出问题\n\t- 回到第2步(写/改代码)\n\n## 产品化\n\n### 项目工程化\n\n- 目录结构\n\n\t- 常见的Web应用都是以MVC为主要框架的,其余部分在这个基础上进行扩展\n\n- 构建工具\n\n\t- 合并静态文件、压缩文件大小、打包应用、编译模块\n\t- 工具\n\n\t\t- Makefile\n\t\t- Grunt\n\n- 编码规范\n\n\t- 为团队统一良好的编码风格,有助于帮助 提升代码的可读性,进而提升可维护性\n\t- 文档式的约定\n\t- 代码提交时的强制检查\n\n- 代码审查\n\n\t- 代码审查需要耗费一定的精力,一些可以自动化完成的工作可以交由工具来自动完成\n\n### 部署流程\n\n- 部署环境\n\n\t- 开发环境\n\t- 测试环境\n\t- 预发布环境\n\t- 线上环境\n\n- 部署操作\n\n\t- 停止进程和重启进程\n\n### 性能\n\n- 动静分离\n\n\t- 将图片、脚本、样式表和多媒体等静态文件都引导到专业的静态文件服务器 上,让Node只处理动态请求即可\n\n- 启用缓存\n\n\t- 在缓存的帮助下,却能够消减同步I/O 带来的时间浪费\n\n- 多进程架构\n\n\t- 充分利用多核CPU, 更是可以建立机制让Node进程更加健壮,以保障Web应用持续服务\n\n- 读写分离\n\n\t- 将数据库进行主从设计,这样读数据操作不再受到写入的影响,降低了性能的影响\n\n### 日志\n\n- 通过 记录日志来定位问题是一种成本较小的方式\n- 访问日志\n\n\t- 可以置入一些用户信息,用以跟踪一些数据,比如某个登录用户太过密集地访问某个页 面等,\n他有可能是一个机器人,在爬取网页中的数据\n\n- 异常日志\n\n\t- 异常日志通常用来记录那些意外产生的异常错误\n\n- 日志与数据库\n\n\t- ,将日志分析和日志记录这两个步骤分离开来是较好的选择\n\n- 分割日志\n\n\t- 线上业务可能访问量巨大,产生的日志也可能是大量的\n\n### 监控报警\n\n- 监控\n\n\t- 为了将一些重要指标采样记录下来,一旦这些指标发生较大变化\n可以配 合报警系统将问题反馈到负责人那\n\t- 日志监控\n\t- 响应时间\n\t- 进程监控\n\t- 磁盘监控\n\t- 内存监控\n\t- CPU占用监控\n\t- CPU load监控\n\t- I/O负载\n\t- 网络监控\n\t- 应用状态监控\n\t- DNS监控\n\n- 报警的实现\n\n\t- 邮件报警\n\t- 短信或电话报警\n\n### 稳定性\n\n- 为了更好的稳定性,典型的水 平扩展方式就是多进程、多机器、多机房、容灾备份\n\n### 异构共存\n\n- Node能够通过协议 与已有的系统很好地异构共存\n\n## 参照\n\n## nodejs 详细\n\n### Node.js\n\n- Node.js 事件循环\n\n\t- 事件驱动程序\n\n\t\t- Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。\n\n\t\t  当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。\n\t\t  \n\t\t  这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO）\n\t\t  \n\t\t  在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。\n\t\t  \n\t\t  \n\n\t- Node.js 事件\n\n\t\t- Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。\n\n\t\t  Node.js 里面的许多对象都会分发事件：一个net.Server对象会在每次有新连接时分发一个事件， 一个fs.readStream对象会在文件被打开的时候发出一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。 你可以通过require(\"events\");来访问该模块。\n\t\t  \n\t\t  下面我们用一个简单的例子说明 EventEmitter 的用法：\n\t\t  \n\t\t  ``` null\n\t\t  - //event.js \n\t\t  ```\n\t\t  \n\t\t  var EventEmitter = require('events').EventEmitter;\n\t\t  var event = new EventEmitter();\n\t\t  event.on('some_event', function() {\n\t\t  console.log('some_event occured.');\n\t\t  });\n\t\t  setTimeout(function() {\n\t\t  event.emit('some_event');\n\t\t  }, 1000);\n\t\t  \n\t\t  \n\n\t\t- EventEmitter介绍\n\n\t\t\t- events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就 是事件发射与事件监听器功能的封装。EventEmitter 的每个事件由一个事件名和若干个参 数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。\n\n\t\t\t  当事件发射时，注册到这个事件的事件监听器被依次调用，事件参数作 为回调函数参数传递。\n\t\t\t  \n\t\t\t  ``` null\n\t\t\t  \t- 让我们以下面的例子解释这个过程：\n\t\t\t  \n\t\t\t  \t\t- var events = require('events'); \n\t\t\t  ```\n\t\t\t  \n\t\t\t  var emitter = new events.EventEmitter();\n\t\t\t  emitter.on('someEvent', function(arg1, arg2) {\n\t\t\t  console.log('listener1', arg1, arg2);\n\t\t\t  });\n\t\t\t  emitter.on('someEvent', function(arg1, arg2) {\n\t\t\t  console.log('listener2', arg1, arg2);\n\t\t\t  });\n\t\t\t  emitter.emit('someEvent', 'byvoid', 1991);\n\t\t\t  \n\t\t\t  \n\n\t\t- EventEmitter常用的API\n\n\t\t\t- EventEmitter.on(event, listener)、emitter.addListener(event, listener)为指定事件注册一个监听器，接收一个字符串 event 和一个回调函数 listener。\n\n\t\t\t\t- server.on('connection', function (stream) {\nconsole.log('someone connected!');\n});\n\n\t\t\t- EventEmitter.emit(event, [arg1], [arg2], [...]) 发射 event 事件，传 递若干可选参数到事件监听器的参数表。\n\t\t\t- EventEmitter.once(event, listener) 为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。\n\n\t\t\t\t- server.once('connection', function (stream) {\nconsole.log('Ah, we have our first user!');\n});\n\n\t\t\t- EventEmitter.removeListener(event, listener) 移除指定事件的某个监听 器，listener 必须是该事件已经注册过的监听器。\n\n\t\t\t\t- var callback = function(stream) {\nconsole.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback);\n\n\t\t\t- EventEmitter.removeAllListeners([event]) 移除所有事件的所有监听器， 如果指定 event，则移除指定事件的所有监听器。\n\n\t\t- error 事件\n\n\t\t\t- EventEmitter 定义了一个特殊的事件 error，它包含了\"错误\"的语义，我们在遇到 异常的时候通常会发射 error 事件。当 error 被发射时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并打印调用栈。我们一般要为会发射 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：\n\n\t\t\t\t- var events = require('events');\nvar emitter = new events.EventEmitter();\nemitter.emit('error');\n\n\t\t- 继承 EventEmitter\n\n\t\t\t- 大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。\n\n\t\t\t  为什么要这样做呢？原因有两点：\n\t\t\t  \n\t\t\t  首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发射应该是一个对象的方法。\n\t\t\t  \n\t\t\t  其次JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。\n\t\t\t  \n\t\t\t  \n\n- Node.js Buffer(缓冲区)\n\n\t- JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。\n\n\t  但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。\n\t  \n\t  在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。\n\t  \n\t  \n\n\t- 创建 Buffer 类\n\n\t\t- 创建长度为 10 字节的 Buffer 实例：\nvar buf = new Buffer(10);\n\t\t- 通过给定的数组创建 Buffer 实例：\nvar buf = new Buffer([10, 20, 30, 40, 50]);\n\t\t- 通过一个字符串来创建 Buffer 实例：\nvar buf = new Buffer(\"www.w3cschool.cn\", \"utf-8\");\n\n\t- 写入缓冲区\n\n\t\t- 写入 Node 缓冲区的语法如下所示：\n\n\t\t\t- buf.write(string[, offset[, length]][, encoding])\n\n\t\t\t\t- 参数描述如下：\n\n\t\t\t\t\t- string - 写入缓冲区的字符串。\n\t\t\t\t\t- offset - 缓冲区开始写入的索引值，默认为 0 。\n\t\t\t\t\t- length - 写入的字节数，默认为 buffer.length\n\t\t\t\t\t- encoding - 使用的编码。默认为 'utf8' 。\n\n\t\t\t\t- 返回值\n\n\t\t\t\t\t- 返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串\n\n\t\t\t\t- 实例\n\n\t\t\t\t\t- buf = new Buffer(256);\nlen = buf.write(\"www.w3cschool.cn\");\n\n\t\t\t\t\t  console.log(\"写入字节数 : \"+  len);\n\t\t\t\t\t  \n\t\t\t\t\t  ``` null\n\t\t\t\t\t  \t\t\t- 执行以上代码，输出结果为：\n\t\t\t\t\t  \n\t\t\t\t\t  \t\t\t\t- $node main.js\n\t\t\t\t\t  ```\n\t\t\t\t\t  \n\t\t\t\t\t  写入字节数 : 16\n\t\t\t\t\t  \n\t\t\t\t\t  \n\n\t- 从缓冲区读取数据\n\n\t\t- 写入 Node 缓冲区的语法如下所示：\n\n\t\t\t- buf.write(string[, offset[, length]][, encoding])\n\n\t\t\t\t- 参数描述如下：\n\n\t\t\t\t\t- encoding - 使用的编码。默认为 'utf8' 。\n\t\t\t\t\t- start - 指定开始读取的索引位置，默认为 0。\n\t\t\t\t\t- end - 结束位置，默认为缓冲区的末尾。\n\n\t\t\t\t- 返回值\n\n\t\t\t\t\t- 解码缓冲区数据并使用指定的编码返回字符串。\n\n\t\t\t\t- 实例\n\n\t\t\t\t\t- buf = new Buffer(26);\nfor (var i = 0 ; i < 26 ; i++) {\nbuf[i] = i + 97;\n}\n\n\t\t\t\t\t  console.log( buf.toString('ascii'));       // 输出: abcdefghijklmnopqrstuvwxyz\n\t\t\t\t\t  console.log( buf.toString('ascii',0,5));   // 输出: abcde\n\t\t\t\t\t  console.log( buf.toString('utf8',0,5));    // 输出: abcde\n\t\t\t\t\t  console.log( buf.toString(undefined,0,5)); // 使用 'utf8' 编码, 并输出: abcde\n\t\t\t\t\t  \n\t\t\t\t\t  ``` null\n\t\t\t\t\t  \t\t\t- 执行以上代码，输出结果为：\n\t\t\t\t\t  \n\t\t\t\t\t  \t\t\t\t- $ node main.js\n\t\t\t\t\t  ```\n\t\t\t\t\t  \n\t\t\t\t\t  abcdefghijklmnopqrstuvwxyz\n\t\t\t\t\t  abcde\n\t\t\t\t\t  abcde\n\t\t\t\t\t  abcde\n\t\t\t\t\t  \n\t\t\t\t\t  \n\n\t- 将 Buffer 转换为 JSON 对象\n\n\t\t- 将 Node Buffer 转换为 JSON 对象的函数语法格式如下：\n\n\t\t\t- buf.toJSON()\n\t\t\t- 返回值\n\n\t\t\t\t- 返回 JSON 对象。\n\n\t\t\t- 实例\n\n\t\t\t\t- var buf = new Buffer('www.w3cschool.cn');\nvar json = buf.toJSON(buf);\n\n\t\t\t\t  console.log(json);\n\t\t\t\t  \n\t\t\t\t  ``` null\n\t\t\t\t  \t\t- 执行以上代码，输出结果为：\n\t\t\t\t  \n\t\t\t\t  \t\t\t- { type: 'Buffer',\n\t\t\t\t  ```\n\t\t\t\t  \n\t\t\t\t  data: [ 119, 119, 119, 46, 119, 51, 99, 115, 99, 104, 111, 111, 108, 46, 99, 110 ] }\n\t\t\t\t  \n\t\t\t\t  \n\n\t- 缓冲区合并\n\n\t\t- Node 缓冲区合并的语法如下所示：\n\n\t\t\t- Buffer.concat(list[, totalLength])\n\n\t\t\t\t- 参数描述如下：\n\n\t\t\t\t\t- list - 用于合并的 Buffer 对象数组列表。\n\t\t\t\t\t- totalLength - 指定合并后Buffer对象的总长度。\n\n\t\t\t\t- 返回值\n\n\t\t\t\t\t- 返回一个多个成员合并的新 Buffer 对象。\n\n\t\t\t\t- 实例\n\n\t\t\t\t\t- var buffer1 = new Buffer('W3Cschool教程 ');\nvar buffer2 = new Buffer('www.w3cschool.cn');\nvar buffer3 = Buffer.concat([buffer1,buffer2]);\nconsole.log(\"buffer3 内容: \" + buffer3.toString());\n\n\t\t\t\t\t\t- 执行以上代码，输出结果为：\n\n\t\t\t\t\t\t\t- buffer3 内容: W3Cschool教程 www.w3cschool.cn\n\n\t- 缓冲区比较\n\n\t\t- Node Buffer 比较的函数语法如下所示, 该方法在 Node.js v0.12.2 版本引入：\n\n\t\t\t- buf.compare(otherBuffer);\n\n\t\t\t\t- 参数描述如下：\n\n\t\t\t\t\t- otherBuffer - 与 buf 对象比较的另外一个 Buffer 对象。\n\n\t\t\t\t- 返回值\n\n\t\t\t\t\t- 返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。\n\n\t\t\t\t- 实例\n\n\t\t\t\t\t- var buffer1 = new Buffer('ABC');\nvar buffer2 = new Buffer('ABCD');\nvar result = buffer1.compare(buffer2);\n\n\t\t\t\t\t  if(result < 0) {\n\t\t\t\t\t  console.log(buffer1 + \" 在 \" + buffer2 + \"之前\");\n\t\t\t\t\t  }else if(result == 0){\n\t\t\t\t\t  console.log(buffer1 + \" 与 \" + buffer2 + \"相同\");\n\t\t\t\t\t  }else {\n\t\t\t\t\t  console.log(buffer1 + \" 在 \" + buffer2 + \"之后\");\n\t\t\t\t\t  }\n\t\t\t\t\t  \n\t\t\t\t\t  ``` null\n\t\t\t\t\t  \t\t\t- 执行以上代码，输出结果为：\n\t\t\t\t\t  \n\t\t\t\t\t  \t\t\t\t- ABC在ABCD之前\n\t\t\t\t\t  ```\n\t\t\t\t\t  \n\t\t\t\t\t  \n\n\t- 拷贝缓冲区\n\n\t\t- Node 缓冲区拷贝语法如下所示：\n\n\t\t\t- buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])\n\n\t\t\t\t- 参数描述如下：\n\n\t\t\t\t\t- targetBuffer - 要拷贝的 Buffer 对象。\n\t\t\t\t\t- targetStart - 数字, 可选, 默认: 0\n\t\t\t\t\t- sourceStart - 数字, 可选, 默认: 0\n\t\t\t\t\t- sourceEnd - 数字, 可选, 默认: buffer.length\n\n\t\t\t\t- 返回值\n\n\t\t\t\t\t- 没有返回值。\n\n\t\t\t\t- 实例\n\n\t\t\t\t\t- var buffer1 = new Buffer('ABC');\n// 拷贝一个缓冲区\nvar buffer2 = new Buffer(3);\nbuffer1.copy(buffer2);\nconsole.log(\"buffer2 content: \" + buffer2.toString());\n\n\t\t\t\t\t\t- 执行以上代码，输出结果为：\n\n\t\t\t\t\t\t\t- buffer2 content: ABC\n\n\t- 缓冲区裁剪\n\n\t\t- Node 缓冲区裁剪语法如下所示：\n\n\t\t\t- buf.slice([start[, end]])\n\n\t\t\t\t- 参数\n\n\t\t\t\t\t- start - 数字, 可选, 默认: 0\n\t\t\t\t\t- end - 数字, 可选, 默认: buffer.length\n\n\t\t\t\t- 返回值\n\n\t\t\t\t\t- 返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。\n\n\t\t\t\t- 实例\n\n\t\t\t\t\t- var buffer1 = new Buffer('youj');\n// 剪切缓冲区\nvar buffer2 = buffer1.slice(0,2);\nconsole.log(\"buffer2 content: \" + buffer2.toString());\n\n\t\t\t\t\t\t- 执行以上代码，输出结果为：\n\n\t\t\t\t\t\t\t- buffer2 content: yo\n\n\t- 缓冲区长度\n\n\t\t- Node 缓冲区长度计算语法如下所示：\n\n\t\t\t- buf.length;\n\n\t\t\t\t- 返回值\n\n\t\t\t\t\t- 返回 Buffer 对象所占据的内存长度。\n\n\t\t\t\t- 实例\n\n\t\t\t\t\t- var buffer = new Buffer('www.w3cschool.cn');\n//  缓冲区长度\nconsole.log(\"buffer length: \" + buffer.length);\n\n\t\t\t\t\t\t- 执行以上代码，输出结果为：\n\n\t\t\t\t\t\t\t- buffer length: 16\n\n- Node.js Stream(流)\n\n\t- 概述\n\n\t\t- tream 是 Node.js 中非常重要的一个模块，应用广泛。\n\n\t\t  Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。\n\t\t  \n\t\t  该抽象接口是可读、可写或是既可读又可写的，通过这些接口，我们可以和磁盘文件、套接字、HTTP请求来交互，实现数据从一个地方流动到另一个地方的功能。\n\t\t  \n\t\t  \n\n\t- 类型\n\n\t\t- Readable - 可读操作。\n\t\t- Writable - 可写操作。\n\t\t- Duplex - 可读可写操作.\n\t\t- Transform - 操作被写入数据，然后读出结果。\n\n\t- 事件\n\n\t\t- data - 当有数据可读时触发。\n\t\t- end - 没有更多的数据可读时触发。\n\t\t- error - 在接收和写入过程中发生错误时触发。\n\t\t- finish - 所有数据已被写入到底层系统时触发。\n\n\t- Node.js Stream(流)\n\n\t\t- 从流中读取数据\n\n\t\t\t- 创建 input.txt 文件，内容如下：\n\n\t\t\t\t- W3Cschool教程官网地址：www.w3cschool.cn\n\n\t\t\t- 创建 main.js 文件, 代码如下：\n\n\t\t\t\t- var fs = require(\"fs\");\nvar data = '';\n\n\t\t\t\t  // 创建可读流\n\t\t\t\t  var readerStream = fs.createReadStream('input.txt');\n\t\t\t\t  \n\t\t\t\t  // 设置编码为 utf8。\n\t\t\t\t  readerStream.setEncoding('UTF8');\n\t\t\t\t  \n\t\t\t\t  // 处理流事件 --\x3e data, end, and error\n\t\t\t\t  readerStream.on('data', function(chunk) {\n\t\t\t\t  data += chunk;\n\t\t\t\t  });\n\t\t\t\t  \n\t\t\t\t  readerStream.on('end',function(){\n\t\t\t\t  console.log(data);\n\t\t\t\t  });\n\t\t\t\t  \n\t\t\t\t  readerStream.on('error', function(err){\n\t\t\t\t  console.log(err.stack);\n\t\t\t\t  });\n\t\t\t\t  \n\t\t\t\t  console.log(\"程序执行完毕\");\n\t\t\t\t  \n\t\t\t\t  ``` null\n\t\t\t\t  - 以上代码执行结果如下：\n\t\t\t\t  \n\t\t\t\t  \t- 程序执行完毕\n\t\t\t\t  ```\n\t\t\t\t  \n\t\t\t\t  W3Cschool教程官网地址：www.w3cschool.cn\n\t\t\t\t  \n\t\t\t\t  \n\n\t\t- 写入流\n\n\t\t\t- 创建 main.js 文件, 代码如下：\n\n\t\t\t\t- var fs = require(\"fs\");\nvar data = 'W3Cschool教程官网地址：www.w3cschool.cn';\n\n\t\t\t\t  // 创建一个可以写入的流，写入到文件 output.txt 中\n\t\t\t\t  var writerStream = fs.createWriteStream('output.txt');\n\t\t\t\t  \n\t\t\t\t  // 使用 utf8 编码写入数据\n\t\t\t\t  writerStream.write(data,'UTF8');\n\t\t\t\t  \n\t\t\t\t  // 标记文件末尾\n\t\t\t\t  writerStream.end();\n\t\t\t\t  \n\t\t\t\t  // 处理流事件 --\x3e data, end, and error\n\t\t\t\t  writerStream.on('finish', function() {\n\t\t\t\t  console.log(\"写入完成。\");\n\t\t\t\t  });\n\t\t\t\t  \n\t\t\t\t  writerStream.on('error', function(err){\n\t\t\t\t  console.log(err.stack);\n\t\t\t\t  });\n\t\t\t\t  \n\t\t\t\t  console.log(\"程序执行完毕\");\n\t\t\t\t  \n\t\t\t\t  ``` null\n\t\t\t\t  - 以上程序会将 data 变量的数据写入到 output.txt 文件中。代码执行结果如下：\n\t\t\t\t  \n\t\t\t\t  \t- $ node main.js \n\t\t\t\t  ```\n\t\t\t\t  \n\t\t\t\t  程序执行完毕\n\t\t\t\t  写入完成。\n\t\t\t\t  \n\t\t\t\t  ``` null\n\t\t\t\t  - 查看 output.txt 文件的内容：\n\t\t\t\t  \n\t\t\t\t  \t- $ cat output.txt \n\t\t\t\t  ```\n\t\t\t\t  \n\t\t\t\t  W3Cschool教程官网地址：www.w3cschool.cn\n\t\t\t\t  \n\t\t\t\t  \n\n\t\t- 管道流\n\n\t\t\t- 管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。\n\t\t\t- 以下实例我们通过读取一个文件内容并将内容写入到另外一个文件中。\n\n\t\t\t\t- 设置 input.txt 文件内容如下：\n\n\t\t\t\t\t- W3Cschool教程官网地址：www.w3cschool.cn\n管道流操作实例\n\n\t\t\t\t- 创建 main.js 文件, 代码如下：\n\n\t\t\t\t\t- var fs = require(\"fs\");\n\n\t\t\t\t\t  // 创建一个可读流\n\t\t\t\t\t  var readerStream = fs.createReadStream('input.txt');\n\t\t\t\t\t  \n\t\t\t\t\t  // 创建一个可写流\n\t\t\t\t\t  var writerStream = fs.createWriteStream('output.txt');\n\t\t\t\t\t  \n\t\t\t\t\t  // 管道读写操作\n\t\t\t\t\t  // 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中\n\t\t\t\t\t  readerStream.pipe(writerStream);\n\t\t\t\t\t  \n\t\t\t\t\t  console.log(\"程序执行完毕\");\n\t\t\t\t\t  \n\t\t\t\t\t  ``` null\n\t\t\t\t\t  \t- 代码执行结果如下：\n\t\t\t\t\t  \n\t\t\t\t\t  \t\t- $ node main.js \n\t\t\t\t\t  ```\n\t\t\t\t\t  \n\t\t\t\t\t  程序执行完毕\n\t\t\t\t\t  \n\t\t\t\t\t  ``` null\n\t\t\t\t\t  \t- 查看 output.txt 文件的内容：\n\t\t\t\t\t  \n\t\t\t\t\t  \t\t- $ cat output.txt \n\t\t\t\t\t  ```\n\t\t\t\t\t  \n\t\t\t\t\t  W3Cschool教程官网地址：www.w3cschool.cn\n\t\t\t\t\t  管道流操作实例\n\t\t\t\t\t  \n\t\t\t\t\t  \n\n\t\t- 链式流\n\n\t\t\t- 链式是通过连接输出流到另外一个流并创建多个对个流操作链的机制。链式流一般用于管道操作。\n\n\t\t\t  接下来我们就是用管道和链式来压缩和解压文件。\n\t\t\t  - 创建 compress.js 文件, 代码如下：\n\t\t\t  \n\t\t\t  ``` null\n\t\t\t  \t- var fs = require(\"fs\");\n\t\t\t  ```\n\t\t\t  \n\t\t\t  var zlib = require('zlib');\n\t\t\t  \n\t\t\t  // 压缩 input.txt 文件为 input.txt.gz\n\t\t\t  fs.createReadStream('input.txt')\n\t\t\t  .pipe(zlib.createGzip())\n\t\t\t  .pipe(fs.createWriteStream('input.txt.gz'));\n\t\t\t  \n\t\t\t  console.log(\"文件压缩完成。\");\n\t\t\t  \n\t\t\t  ``` null\n\t\t\t  - 代码执行结果如下：\n\t\t\t  \n\t\t\t  \t- $ node compress.js \n\t\t\t  ```\n\t\t\t  \n\t\t\t  文件压缩完成。\n\t\t\t  \n\t\t\t  ``` null\n\t\t\t  - 执行完以上操作后，我们可以看到当前目录下生成了 input.txt 的压缩文件 input.txt.gz。\n\t\t\t  - 接下来，让我们来解压该文件，创建 decompress.js 文件，代码如下：\n\t\t\t  \n\t\t\t  \t- var fs = require(\"fs\");\n\t\t\t  ```\n\t\t\t  \n\t\t\t  var zlib = require('zlib');\n\t\t\t  \n\t\t\t  // 解压 input.txt.gz 文件为 input.txt\n\t\t\t  fs.createReadStream('input.txt.gz')\n\t\t\t  .pipe(zlib.createGunzip())\n\t\t\t  .pipe(fs.createWriteStream('input.txt'));\n\t\t\t  \n\t\t\t  console.log(\"文件解压完成。\");\n\t\t\t  \n\t\t\t  ``` null\n\t\t\t  - 代码执行结果如下：\n\t\t\t  \n\t\t\t  \t- $ node decompress.js \n\t\t\t  ```\n\t\t\t  \n\t\t\t  文件解压完成。\n\t\t\t  \n\t\t\t  \n\n- Node.js 模块系统\n\n\t- 概述\n\n\t\t- 为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。\n\t\t- 模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。\n换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。\n\n\t- 创建模块\n\n\t\t- 在 Node.js 中，创建一个模块非常简单，如下我们创建一个 'main.js' 文件，代码如下:\n\n\t\t\t- var hello = require('./hello');\nhello.world();\n\n\t\t\t  以上实例中，代码 require('./hello') 引入了当前目录下的hello.js文件（./ 为当前目录，node.js默认后缀为js）。\n\t\t\t  \n\t\t\t  ``` null\n\t\t\t  \t- Node.js 提供了exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。\n\t\t\t  \n\t\t\t  \t\t- 接下来我们就来创建hello.js文件，代码如下\n\t\t\t  \n\t\t\t  \t\t\t- exports.world = function() {\n\t\t\t  ```\n\t\t\t  \n\t\t\t  console.log('Hello World');\n\t\t\t  }\n\t\t\t  \n\t\t\t  ``` null\n\t\t\t  \t\t\t\t- 有时候我们只是想把一个对象封装到模块中，格式如下：\n\t\t\t  \n\t\t\t  \t\t\t\t\t- module.exports = function() {\n\t\t\t  ```\n\t\t\t  \n\t\t\t  // ...\n\t\t\t  }\n\t\t\t  \n\t\t\t  ``` null\n\t\t\t  \t\t\t\t\t\t- //hello.js \n\t\t\t  ```\n\t\t\t  \n\t\t\t  function Hello() {\n\t\t\t  var name;\n\t\t\t  this.setName = function(thyName) {\n\t\t\t  name = thyName;\n\t\t\t  };\n\t\t\t  this.sayHello = function() {\n\t\t\t  console.log('Hello ' + name);\n\t\t\t  };\n\t\t\t  };\n\t\t\t  module.exports = Hello;\n\t\t\t  \n\t\t\t  ``` null\n\t\t\t  \t\t\t\t\t\t\t- 这样就可以直接获得这个对象了：\n\t\t\t  \n\t\t\t  \t\t\t\t\t\t\t\t- //main.js \n\t\t\t  ```\n\t\t\t  \n\t\t\t  var Hello = require('./hello');\n\t\t\t  hello = new Hello();\n\t\t\t  hello.setName('BYVoid');\n\t\t\t  hello.sayHello();\n\t\t\t  \n\t\t\t  ``` null\n\t\t\t  \t\t\t\t\t\t\t\t\t- 模块接口的唯一变化是使用 module.exports = Hello 代替了exports.world = function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。\n\t\t\t  ```\n\t\t\t  \n\t\t\t  *XMind: ZEN - Trial Version*\n\t\t\t  \n\t\t\t  \n\n*XMind: ZEN - Trial Version*",i={data:function(){return{MainComponent:l}}},c=i,p=e("2877"),b=Object(p["a"])(c,s,o,!1,null,"1dcf4475",null),u=b.exports,v=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},g=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("pre",[t._v("           "),e("code",[t._v('\n\n           \n{\n  "name": "node-web-fullstack",\n  "version": "0.0.1",\n  "description": "锦年node全栈学习项目",\n  "productName": "锦年fullstack",\n  "author": "jinnianwushuang ",\n  "private": true,\n  "main": "server.js",\n  "apidoc":{\n    "name": "锦年node全栈学习项目API",\n    "version": "0.1.0",\n    "description": "明日复明日，万事成蹉跎。",\n    "title": "锦年node全栈学习项目API",\n    "url": "http://192.168.0.36:19090"\n  },\n  "scripts": {\n    "test": "echo \\"No test specified\\" && exit 0",\n    "start-makedoc": "apidoc -i app/ -o apidoc/",\n    "start-docpage": " http-server ./apidoc -a 192.168.0.36 -p 19092 -s -o ",\n    "start-docpage-b": "http-server ./apidoc -a 192.168.0.36 -p 19092 -s -o ",\n    "start-server": "nodemon --harmony  server.js",\n    "start-webpage": "quasar dev",\n    "start-doc-s": "run-s start-makedoc start-docpage",\n    "start-fullstack-p": "run-p  start-server  start-webpage",\n    "init-env": "node init.js",\n    "start": "run-s  init-env   start2",\n    "start2": "run-p   start-fullstack-p start-doc-s"\n  },\n  "dependencies": {\n    "@quasar/extras": "^1.0.0",\n    "axios": "^0.18.1",\n    "body-parser": "^1.19.0",\n    "core-js": "^3.6.5",\n    "cors": "^2.8.5",\n    "express": "^4.17.1",\n    "lodash": "^4.17.20",\n    "log4js": "^6.3.0",\n    "md5": "^2.3.0",\n    "mongoose": "^5.8.10",\n    "mongoose-paginate-v2": "^1.3.9",\n    "quasar": "^1.0.0",\n    "vue-i18n": "^8.0.0"\n  },\n  "devDependencies": {\n    "@quasar/app": "^2.0.0",\n    "apidoc": "^0.25.0",\n    "http-server": "^0.12.3",\n    "nodemon": "^2.0.4",\n    "npm-run-all": "^4.1.5"\n  },\n  "browserslist": [\n    "ie >= 11",\n    "last 10 Chrome versions",\n    "last 10 Firefox versions",\n    "last 4 Edge versions",\n    "last 7 Safari versions",\n    "last 8 Android versions",\n    "last 8 ChromeAndroid versions",\n    "last 8 FirefoxAndroid versions",\n    "last 10 iOS versions",\n    "last 5 Opera versions"\n  ],\n  "engines": {\n    "node": ">= 10.18.1",\n    "npm": ">= 6.13.4",\n    "yarn": ">= 1.21.1"\n  }\n}\n\n')]),t._v("\n       ")])])}],m={},_=m,d=Object(p["a"])(_,v,g,!1,null,"6454dfc7",null),h=d.exports,f=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{},[e("div",{staticClass:" markdown-body"}),e("MainComponent")],1)},y=[],S=e("ecbb"),w={components:{MainComponent:S["a"]},data:function(){return{}}},k=w,x=Object(p["a"])(k,f,y,!1,null,"7ac95ce9",null),C=x.exports,j=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},P=[],T={},E=T,O=Object(p["a"])(E,j,P,!1,null,"a7c14b9c",null),M=O.exports,A=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},N=[],I={},D=I,z=Object(p["a"])(D,A,N,!1,null,"fba97d1a",null),$=z.exports,R=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},J=[],L={},H=L,q=Object(p["a"])(H,R,J,!1,null,"583728b4",null),F=q.exports,W=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("json-api-viewer",{attrs:{title:"QPdfviewer API",json:t.json}})],1)},B=[],U=e("c533"),G={data:function(){return{json:U}}},V=G,X=Object(p["a"])(V,W,B,!1,null,"172c1d70",null),Q=X.exports,Y=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},K=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("p",[t._v("综合类")]),e("p",[t._v("综合类 地址")]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/sb19871023/p/3894452.html",target:"_blank"}},[t._v("前端知识体系")])]),e("p",[e("a",{attrs:{href:"https://github.com/JacksonTian/fks",target:"_blank"}},[t._v("前端知识结构")])]),e("p",[e("a",{attrs:{href:"https://github.com/unruledboy/WebFrontEndStack",target:"_blank"}},[t._v("Web前端开发大系概览")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/unruledboy/p/WebFrontEndStack.html",target:"_blank"}},[t._v("Web前端开发大系概览-中文版")])]),e("p",[t._v("Web Front-end Stack v2.2 Web Front-end Stack v2.2")]),e("p",[e("a",{attrs:{href:"https://github.com/justjavac/free-programming-books-zh_CN",target:"_blank"}},[t._v("免费的编程中文书籍索引")])]),e("p",[e("a",{attrs:{href:"https://github.com/dypsilon/frontend-dev-bookmarks",target:"_blank"}},[t._v("前端书籍")])]),e("p",[e("a",{attrs:{href:"https://github.com/vhf/free-programming-books",target:"_blank"}},[t._v("前端免费书籍大全")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/sb19871023/p/3894452.html",target:"_blank"}},[t._v("前端知识体系")])]),e("p",[e("a",{attrs:{href:"https://github.com/justjavac/free-programming-books-zh_CN",target:"_blank"}},[t._v("免费的编程中文书籍索引")])]),e("p",[e("a",{attrs:{href:"http://study.163.com/course/introduction/224014.htm",target:"_blank"}},[t._v("智能社 - 精通JavaScript开发")])]),e("p",[e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript",target:"_blank"}},[t._v("重新介绍 JavaScript（JS 教程）")])]),e("p",[e("a",{attrs:{href:"http://v.163.com/special/opencourse/bianchengdaolun.html",target:"_blank"}},[t._v("麻省理工学院公开课：计算机科学及编程导论")])]),e("p",[e("a",{attrs:{href:"http://segmentfault.com/a/1190000002640298",target:"_blank"}},[t._v("JavaScript中的this陷阱的最全收集--没有之一")])]),e("p",[e("a",{attrs:{href:"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.html",target:"_blank"}},[t._v("JS函数式编程指南")])]),e("p",[e("a",{attrs:{href:"http://liubin.github.io/promises-book",target:"_blank"}},[t._v("JavaScript Promise迷你书（中文版）")])]),e("p",[e("a",{attrs:{href:"https://github.com/AlloyTeam/Mars",target:"_blank"}},[t._v("腾讯移动Web前端知识库")])]),e("p",[e("a",{attrs:{href:"https://github.com/Front-End-Developers-Hunan/Front-End-Develop-Guide",target:"_blank"}},[t._v("Front-End-Develop-Guide 前端开发指南")])]),e("p",[e("a",{attrs:{href:"https://li-xinyang.gitbooks.io/frontend-notebook/content",target:"_blank"}},[t._v("前端开发笔记本")])]),e("p",[e("a",{attrs:{href:"https://github.com/nieweidong/fetool",target:"_blank"}},[t._v("大前端工具集 - 聂微东")])]),e("p",[e("a",{attrs:{href:"https://dwqs.gitbooks.io/frontenddevhandbook/content",target:"_blank"}},[t._v("前端开发者手册")])]),e("p",[t._v("入门类")]),e("p",[t._v("入门类 地址")]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/jikey/p/3613082.html",target:"_blank"}},[t._v("前端入门教程")])]),e("p",[e("a",{attrs:{href:"http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000",target:"_blank"}},[t._v("瘳雪峰的Javascript教程")])]),e("p",[e("a",{attrs:{href:"http://www.imooc.com/view/11",target:"_blank"}},[t._v("jQuery基础教程")])]),e("p",[e("a",{attrs:{href:"http://www.imooc.com/view/506",target:"_blank"}},[t._v("前端工程师必备的PS技能——切图篇")])]),e("p",[e("a",{attrs:{href:"https://github.com/qiu-deqing/FE-learning",target:"_blank"}},[t._v("结合个人经历总结的前端入门方法")])]),e("p",[t._v("工具类")]),e("p",[t._v("工具类 地址")]),e("p",[e("a",{attrs:{href:"http://f2er.club/",target:"_blank"}},[t._v("前端人的俱乐部")])]),e("p",[e("a",{attrs:{href:"http://www.jeffjade.com/2015/12/15/2015-04-17-toss-sublime-text/#",target:"_blank"}},[t._v("如何优雅地使用Sublime\n                    Text")])]),e("p",[e("a",{attrs:{href:"http://www.jeffjade.com/2016/03/03/2016-03-02-how-to-use-atom/",target:"_blank"}},[t._v("新编码神器Atom使用纪要")])]),e("p",[e("a",{attrs:{href:"http://www.imooc.com/learn/93",target:"_blank"}},[t._v("css sprite 雪碧图制作")])]),e("p",[e("a",{attrs:{href:"http://www.imooc.com/learn/390",target:"_blank"}},[t._v("版本控制入门 – 搬进 Github")])]),e("p",[e("a",{attrs:{href:"http://www.imooc.com/learn/30",target:"_blank"}},[t._v("Grunt-beginner前端自动化工具")])]),e("p",[e("a",{attrs:{href:"https://github.com/judasn/IntelliJ-IDEA-Tutorial",target:"_blank"}},[t._v("IntelliJ IDEA 简体中文专题教程")])]),e("p",[e("a",{attrs:{href:"http://t.cn/8kZZ1Uy",target:"_blank"}},[t._v("Webstorm,InterllIdea,Phpstorm")])]),e("p",[e("a",{attrs:{href:"https://github.com/jikeytang/sublime-text",target:"_blank"}},[t._v("SublimeText")])]),e("p",[e("a",{attrs:{href:"https://atom.io",target:"_blank"}},[t._v("Atom")])]),e("p",[e("a",{attrs:{href:"https://code.visualstudio.com",target:"_blank"}},[t._v("visual studio code")])]),e("p",[t._v("综合效果搜索平台")]),e("p",[t._v("综合效果搜索平台 地址")]),e("p",[e("a",{attrs:{href:"http://zoommyapp.com/",target:"_blank"}},[t._v("zoommyapp.com")])]),e("p",[e("a",{attrs:{href:"https://unsplash.com/",target:"_blank"}},[t._v("unsplash.com")])]),e("p",[e("a",{attrs:{href:"https://www.pinterest.com/",target:"_blank"}},[t._v("www.pinterest.com")])]),e("p",[e("a",{attrs:{href:"http://nos.twnsnd.co",target:"_blank"}},[t._v("New Old Stock")])]),e("p",[e("a",{attrs:{href:"http://www.jq22.com",target:"_blank"}},[t._v("效果网")])]),e("p",[e("a",{attrs:{href:"http://huaban.com/",target:"_blank"}},[t._v("花瓣网")])]),e("p",[e("a",{attrs:{href:"http://www.topit.me/",target:"_blank"}},[t._v("优美图")])]),e("p",[e("a",{attrs:{href:"http://codepen.io/",target:"_blank"}},[t._v("codepen")])]),e("p",[e("a",{attrs:{href:"http://www.17sucai.com",target:"_blank"}},[t._v("17素材")])]),e("p",[e("a",{attrs:{href:"http://699pic.com/",target:"_blank"}},[t._v("摄图网")])]),e("p",[e("a",{attrs:{href:"http://microjs.com",target:"_blank"}},[t._v("常用的JavaScript代码片段")])]),e("p",[t._v("周报类")]),e("p",[t._v("周报类 地址")]),e("p",[e("a",{attrs:{href:"http://old.75team.com/weekly/",target:"_blank"}},[t._v("奇舞周刊")])]),e("p",[e("a",{attrs:{href:"http://weekly.manong.io",target:"_blank"}},[t._v("码农周刊")])]),e("p",[e("a",{attrs:{href:"http://www.kancloud.cn/jsfront/month/82796",target:"_blank"}},[t._v("JS前端开发群月报")])]),e("p",[e("a",{attrs:{href:"http://www.css88.com",target:"_blank"}},[t._v("WEB前端开发")])]),e("p",[e("a",{attrs:{href:"http://www.jstips.co",target:"_blank"}},[t._v("A JS tip per day!")])]),e("p",[e("a",{attrs:{href:"https://github.com/PaicHyperionDev/MobileDevWeekly",target:"_blank"}},[t._v("平安科技移动开发二队技术周报")])]),e("p",[t._v("开发中心")]),e("p",[t._v("开发中心 地址")]),e("p",[e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript",target:"_blank"}},[t._v("mozilla js参考")])]),e("p",[e("a",{attrs:{href:"https://developer.chrome.com/extensions/api_index.html",target:"_blank"}},[t._v("chrome开发中心（chrome的内核已转向blink）")])]),e("p",[e("a",{attrs:{href:"https://developer.apple.com/library/safari/navigation",target:"_blank"}},[t._v("safari开发中心")])]),e("p",[e("a",{attrs:{href:"https://msdn.microsoft.com/zh-cn/library/d1et7k7c",target:"_blank"}},[t._v("microsoft js参考")])]),e("p",[e("a",{attrs:{href:"http://sanshi.me/articles/JavaScript-Garden-CN/html/index.html",target:"_blank"}},[t._v("js秘密花园")])]),e("p",[e("a",{attrs:{href:"http://bonsaiden.github.io/JavaScript-Garden/zh",target:"_blank"}},[t._v("js秘密花园")])]),e("p",[e("a",{attrs:{href:"http://www.w3help.org",target:"_blank"}},[t._v("w3help")])]),e("p",[t._v("Nodejs")]),e("p",[t._v("Nodejs 地址")]),e("p",[e("a",{attrs:{href:"http://liuqing.pw",target:"_blank"}},[t._v("nodejs 篇幅比较巨大")])]),e("p",[e("a",{attrs:{href:"https://github.com/alsotang/node-lessons",target:"_blank"}},[t._v("Node.js 包教不包会")])]),e("p",[e("a",{attrs:{href:"http://www.rainweb.cn/article/category/Nodejs",target:"_blank"}},[t._v("篇幅比较少")])]),e("p",[e("a",{attrs:{href:"http://www.w3cfuns.com/article-5598538-1-1.html",target:"_blank"}},[t._v("node express 入门教程")])]),e("p",[e("a",{attrs:{href:"http://my.oschina.net/u/568264/blog/193773",target:"_blank"}},[t._v("nodejs定时任务")])]),e("p",[e("a",{attrs:{href:"http://60sky.com",target:"_blank"}},[t._v("一个nodejs博客")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/yexiaochai/p/3536547.html",target:"_blank"}},[t._v("【NodeJS 学习笔记04】新闻发布系统")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/qqloving/p/3541099.html",target:"_blank"}},[t._v("过年7天乐，学nodejs 也快乐")])]),e("p",[e("a",{attrs:{href:"https://github.com/nqdeng/7-days-nodejs",target:"_blank"}},[t._v("七天学会NodeJS")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/zhongweiv/p/nodejs_events.html",target:"_blank"}},[t._v("Nodejs学习笔记（二）--- 事件模块")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/liusuqi/p/3735491.html",target:"_blank"}},[t._v("nodejs入门")])]),e("p",[e("a",{attrs:{href:"https://github.com/zensh/jsgen",target:"_blank"}},[t._v("angularjs nodejs")])]),e("p",[e("a",{attrs:{href:"http://blog.fens.me/series-nodejs",target:"_blank"}},[t._v("从零开始nodejs系列文章")])]),e("p",[e("a",{attrs:{href:"http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb",target:"_blank"}},[t._v("理解nodejs")])]),e("p",[e("a",{attrs:{href:"http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop",target:"_blank"}},[t._v("nodejs事件轮询")])]),e("p",[e("a",{attrs:{href:"http://www.nodebeginner.org/index-zh-cn.html",target:"_blank"}},[t._v("node入门")])]),e("p",[e("a",{attrs:{href:"http://ourjs.com/detail/53e1f281c5910a9806000001",target:"_blank"}},[t._v("nodejs cms")])]),e("p",[e("a",{attrs:{href:"http://ourjs.com/detail/529ca5950cb6498814000005",target:"_blank"}},[t._v("Node初学者入门，一本全面的NodeJS教程")])]),e("p",[e("a",{attrs:{href:"http://www.barretlee.com/blog/2015/10/07/debug-nodejs-in-command-line",target:"_blank"}},[t._v("NodeJS的代码调试和性能调优")])]),e("p",[t._v("综合API")]),e("p",[t._v("综合API 地址")]),e("p",[e("a",{attrs:{href:"http://www.javascripting.com",target:"_blank"}},[t._v("javascripting")])]),e("p",[e("a",{attrs:{href:"http://microjs.com",target:"_blank"}},[t._v("各种流行库搜索")])]),e("p",[e("a",{attrs:{href:"http://www.runoob.com",target:"_blank"}},[t._v("runoob.com-包含各种API集合")])]),e("p",[e("a",{attrs:{href:"http://tool.oschina.net/apidocs",target:"_blank"}},[t._v("开源中国在线API文档合集")])]),e("p",[e("a",{attrs:{href:"http://devdocs.io",target:"_blank"}},[t._v("devdocs")])]),e("p",[t._v("Ecmascript")]),e("p",[t._v("Ecmascript 地址")]),e("p",[e("a",{attrs:{href:"https://leanpub.com/understandinges6/read",target:"_blank"}},[t._v("Understanding ECMAScript 6 - Nicholas C.\n                    Zakas")])]),e("p",[e("a",{attrs:{href:"https://leanpub.com/exploring-es6/read",target:"_blank"}},[t._v("exploring-es6")])]),e("p",[e("a",{attrs:{href:"https://github.com/es6-org/exploring-es6",target:"_blank"}},[t._v("exploring-es6翻译")])]),e("p",[e("a",{attrs:{href:"http://es6-org.github.io/exploring-es6",target:"_blank"}},[t._v("exploring-es6翻译后预览")])]),e("p",[e("a",{attrs:{href:"http://es6.ruanyifeng.com",target:"_blank"}},[t._v("阮一峰 es6")])]),e("p",[e("a",{attrs:{href:"http://javascript.ruanyifeng.com",target:"_blank"}},[t._v("阮一峰 Javascript")])]),e("p",[e("a",{attrs:{href:"http://yanhaijing.com/es5",target:"_blank"}},[t._v("ECMA-262，第 5 版")])]),e("p",[e("a",{attrs:{href:"http://es5.github.io",target:"_blank"}},[t._v("es5")])]),e("p",[t._v("Js template")]),e("p",[t._v("Js template 地址")]),e("p",[e("a",{attrs:{href:"http://garann.github.io/template-chooser",target:"_blank"}},[t._v("template-chooser")])]),e("p",[e("a",{attrs:{href:"https://github.com/aui/artTemplate",target:"_blank"}},[t._v("artTemplate")])]),e("p",[e("a",{attrs:{href:"https://github.com/aui/tmodjs/blob/master/README.md",target:"_blank"}},[t._v("tomdjs")])]),e("p",[e("a",{attrs:{href:"http://juicer.name/docs/docs_zh_cn.html",target:"_blank"}},[t._v("淘宝模板juicer模板")])]),e("p",[e("a",{attrs:{href:"http://koen301.github.io/fxtpl",target:"_blank"}},[t._v("Fxtpl v1.0 繁星前端模板引擎")])]),e("p",[e("a",{attrs:{href:"http://laytpl.layui.com",target:"_blank"}},[t._v("laytpl")])]),e("p",[e("a",{attrs:{href:"https://github.com/mozilla/nunjucks",target:"_blank"}},[t._v("mozilla - nunjucks")])]),e("p",[e("a",{attrs:{href:"https://github.com/PaulGuo/Juicer",target:"_blank"}},[t._v("Juicer")])]),e("p",[e("a",{attrs:{href:"http://akdubya.github.io/dustjs",target:"_blank"}},[t._v("dustjs")])]),e("p",[e("a",{attrs:{href:"http://ecomfe.github.io/etpl",target:"_blank"}},[t._v("etpl")])]),e("p",[t._v("CSS")]),e("p",[t._v("CSS 地址")]),e("p",[e("a",{attrs:{href:"http://tympanus.net/codrops/css_reference",target:"_blank"}},[t._v("CSS 语法参考")])]),e("p",[e("a",{attrs:{href:"http://isux.tencent.com/css3/index.html",target:"_blank"}},[t._v("CSS3动画手册")])]),e("p",[e("a",{attrs:{href:"http://isux.tencent.com/css3/tools.html",target:"_blank"}},[t._v("腾讯css3动画制作工具")])]),e("p",[e("a",{attrs:{href:"http://linxz.github.io/tianyizone",target:"_blank"}},[t._v("志爷css小工具集合")])]),e("p",[e("a",{attrs:{href:"http://www.note12.com/category/blog/2014-6-5/538fe0a9f786f1b7019a4dfb",target:"_blank"}},[t._v("css3 js\n                    移动大杂烩")])]),e("p",[e("a",{attrs:{href:"http://bouncejs.com",target:"_blank"}},[t._v("bouncejs 触摸库")])]),e("p",[e("a",{attrs:{href:"http://fian.my.id/Waves",target:"_blank"}},[t._v("css3 按钮动画")])]),e("p",[e("a",{attrs:{href:"http://daneden.github.io/animate.css",target:"_blank"}},[t._v("animate.css")])]),e("p",[e("a",{attrs:{href:"http://www.alloyteam.com/2015/10/8536",target:"_blank"}},[t._v("全局CSS的终结(狗带 [译]")])]),e("p",[e("a",{attrs:{href:"http://browserhacks.com",target:"_blank"}},[t._v("browserhacks")])]),e("p",[t._v("Angularjs")]),e("p",[t._v("Angularjs 地址")]),e("p",[e("a",{attrs:{href:"https://github.com/dolymood/AngularLearning",target:"_blank"}},[t._v("Angular.js 的一些学习资源")])]),e("p",[e("a",{attrs:{href:"http://angularjs.cn",target:"_blank"}},[t._v("angularjs中文社区")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/xuwenmin888/p/3739096.html",target:"_blank"}},[t._v("Angularjs源码学习")])]),e("p",[e("a",{attrs:{href:"http://www.ifeenan.com/?c=AngularJS",target:"_blank"}},[t._v("Angularjs源码学习")])]),e("p",[e("a",{attrs:{href:"http://angular-ui.github.io/bootstrap",target:"_blank"}},[t._v("angular对bootstrap的封装")])]),e("p",[e("a",{attrs:{href:"https://cnodejs.org/topic/51404e0f069911196d2e3923",target:"_blank"}},[t._v("angularjs + nodejs")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/lvdabao/tag/AngularJs",target:"_blank"}},[t._v("吕大豹 Angularjs")])]),e("p",[e("a",{attrs:{href:"http://www.infoq.com/cn/news/2013/02/angular-web-app",target:"_blank"}},[t._v("AngularJS 最佳实践")])]),e("p",[e("a",{attrs:{href:"http://www.lovelucy.info/angularjs-best-practices.html",target:"_blank"}},[t._v("Angular的一些扩展指令")])]),e("p",[e("a",{attrs:{href:"https://github.com/Pasvaz/bindonce",target:"_blank"}},[t._v("Angular数据绑定原理")])]),e("p",[e("a",{attrs:{href:"https://github.com/angular-ui",target:"_blank"}},[t._v("一些扩展Angular UI组件")])]),e("p",[e("a",{attrs:{href:"http://voidcanvas.com/emberjs-vs-angularjs-performance-testing",target:"_blank"}},[t._v("Ember和AngularJS的性能测试")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/powertoolsteam/p/angularjs-introdection.html",target:"_blank"}},[t._v("带你走近AngularJS -\n                    基本功能介绍")])]),e("p",[e("a",{attrs:{href:"http://angular.duapp.com/docs/guide",target:"_blank"}},[t._v("Angularjs开发指南")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/amosli/p/3710648.html",target:"_blank"}},[t._v("Angularjs学习")])]),e("p",[e("a",{attrs:{href:"http://www.rainweb.cn/article/angularjs-jquery.html",target:"_blank"}},[t._v("不要带着jQuery的思维去学习AngularJS")])]),e("p",[e("a",{attrs:{href:"http://wangjiatao.diandian.com/?tag=angularjs",target:"_blank"}},[t._v("angularjs 学习笔记")])]),e("p",[e("a",{attrs:{href:"http://www.angularjs.cn/T008",target:"_blank"}},[t._v("angularjs 开发指南")])]),e("p",[e("a",{attrs:{href:"https://github.com/jmcunningham/AngularJS-Learning",target:"_blank"}},[t._v("angularjs 英文资料")])]),e("p",[e("a",{attrs:{href:"http://angular-ui.github.io/bootstrap",target:"_blank"}},[t._v("angular bootstrap")])]),e("p",[e("a",{attrs:{href:"https://github.com/opitzconsulting/jquery-mobile-angular-adapter",target:"_blank"}},[t._v("angular jq\n                    mobile")])]),e("p",[e("a",{attrs:{href:"http://mgcrea.github.io/angular-strap",target:"_blank"}},[t._v("angular ui")])]),e("p",[e("a",{attrs:{href:"http://www.tuicool.com/articles/7ZZVr2",target:"_blank"}},[t._v("整合jQuery Mobile+AngularJS经验谈")])]),e("p",[e("a",{attrs:{href:"http://blog.jobbole.com/46589/",target:"_blank"}},[t._v("有jQuery背景，该如何用AngularJS编程思想")])]),e("p",[e("a",{attrs:{href:"http://each.sinaapp.com/angular",target:"_blank"}},[t._v("AngularJS在线教程")])]),e("p",[e("a",{attrs:{href:"http://www.zouyesheng.com/angular.html",target:"_blank"}},[t._v("angular学习笔记")])]),e("p",[t._v("React")]),e("p",[t._v("React 地址")]),e("p",[e("a",{attrs:{href:"http://www.react-china.org",target:"_blank"}},[t._v("react.js 中文论坛")])]),e("p",[e("a",{attrs:{href:"https://facebook.github.io/react/index.html",target:"_blank"}},[t._v("react.js 官方网址")])]),e("p",[e("a",{attrs:{href:"https://facebook.github.io/react/docs/getting-started.html",target:"_blank"}},[t._v("react.js 官方文档")])]),e("p",[e("a",{attrs:{href:"http://material-ui.com/#",target:"_blank"}},[t._v("react.js material UI")])]),e("p",[e("a",{attrs:{href:"http://touchstonejs.io",target:"_blank"}},[t._v("react.js TouchstoneJS UI")])]),e("p",[e("a",{attrs:{href:"http://amazeui.org/react",target:"_blank"}},[t._v("react.js amazeui UI")])]),e("p",[e("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2015/03/react.html",target:"_blank"}},[t._v("React 入门实例教程 - 阮一峰")])]),e("p",[e("a",{attrs:{href:"http://wiki.jikexueyuan.com/project/react-native",target:"_blank"}},[t._v("React Native 中文版")])]),e("p",[e("a",{attrs:{href:"http://www.html-js.com/article/Fakefish%203053",target:"_blank"}},[t._v("Webpack 和 React 小书 - 前端乱炖")])]),e("p",[e("a",{attrs:{href:"https://fakefish.github.io/react-webpack-cookbook",target:"_blank"}},[t._v("Webpack 和 React 小书 - gitbook")])]),e("p",[e("a",{attrs:{href:"https://github.com/webpack/webpack",target:"_blank"}},[t._v("webpack")])]),e("p",[e("a",{attrs:{href:"http://html-js.com/article/3009",target:"_blank"}},[t._v("Webpack，101入门体验")])]),e("p",[e("a",{attrs:{href:"http://html-js.com/article/3113",target:"_blank"}},[t._v("webpack入门教程")])]),e("p",[e("a",{attrs:{href:"http://segmentfault.com/a/1190000003499526",target:"_blank"}},[t._v("基于webpack搭建前端工程解决方案探索")])]),e("p",[e("a",{attrs:{href:"http://www.piliyu.com",target:"_blank"}},[t._v("React原创实战视频教程")])]),e("p",[t._v("vue")]),e("p",[t._v("vue 地址")]),e("p",[e("a",{attrs:{href:"http://cn.vuejs.org",target:"_blank"}},[t._v("Vue")])]),e("p",[e("a",{attrs:{href:"http://forum.vuejs.org",target:"_blank"}},[t._v("Vue 论坛")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/aaronjs/p/3660102.html",target:"_blank"}},[t._v("Vue 入门指南")])]),e("p",[e("a",{attrs:{href:"http://segmentfault.com/a/1190000000411057",target:"_blank"}},[t._v("Vue 的一些资源索引")])]),e("p",[e("a",{attrs:{href:"https://github.com/vuejs/awesome-vue",target:"_blank"}},[t._v("awesome-vue")])]),e("p",[t._v("移动端API")]),e("p",[t._v("移动端API 地址")]),e("p",[e("a",{attrs:{href:"https://github.com/jtyjty99999/mobileTech",target:"_blank"}},[t._v("99移动端知识集合")])]),e("p",[e("a",{attrs:{href:"https://github.com/AlloyTeam/Mars",target:"_blank"}},[t._v("移动端前端开发知识库")])]),e("p",[e("a",{attrs:{href:"http://caibaojian.com/mobile-web-bug.html",target:"_blank"}},[t._v("移动前端的一些坑和解决方法（外观表现）")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/PeunZhang/p/3407453.html",target:"_blank"}},[t._v("【原】移动web资源整理")])]),e("p",[e("a",{attrs:{href:"http://mweb.baidu.com/zeptoapi",target:"_blank"}},[t._v("zepto 1.0 中文手册")])]),e("p",[e("a",{attrs:{href:"http://www.html-5.cn/Manual/Zepto",target:"_blank"}},[t._v("zepto 1.0 中文手册")])]),e("p",[e("a",{attrs:{href:"http://www.css88.com/doc/zeptojs_api",target:"_blank"}},[t._v("zepto 1.1.2")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/sky000/archive/2013/03/29/2988952.html",target:"_blank"}},[t._v("zepto 中文注释")])]),e("p",[e("a",{attrs:{href:"http://app-framework-software.intel.com/api.php",target:"_blank"}},[t._v("jqmobile 手册")])]),e("p",[e("a",{attrs:{href:"https://github.com/maxzhang/maxzhang.github.com/issues",target:"_blank"}},[t._v("移动浏览器开发集合")])]),e("p",[e("a",{attrs:{href:"https://github.com/hoosin/mobile-web-favorites",target:"_blank"}},[t._v("移动开发大杂烩")])]),e("p",[t._v("jQuery")]),e("p",[t._v("jQuery 地址")]),e("p",[e("a",{attrs:{href:"http://www.jquery123.com",target:"_blank"}},[t._v("jQuery API 中文文档")])]),e("p",[e("a",{attrs:{href:"http://hemin.cn/jq",target:"_blank"}},[t._v("hemin 在线版")])]),e("p",[e("a",{attrs:{href:"http://www.css88.com/jqapi-1.9/on",target:"_blank"}},[t._v("css88 jq api")])]),e("p",[e("a",{attrs:{href:"http://www.css88.com/jquery-ui-api",target:"_blank"}},[t._v("css88 jqui api")])]),e("p",[e("a",{attrs:{href:"http://learn.jquery.com",target:"_blank"}},[t._v("学习jquery")])]),e("p",[e("a",{attrs:{href:"http://james.padolsey.com/jquery",target:"_blank"}},[t._v("jquery 源码查找")])]),e("p",[t._v("D3")]),e("p",[t._v("D3 地址")]),e("p",[e("a",{attrs:{href:"https://github.com/mbostock/d3/wiki/Tutorials",target:"_blank"}},[t._v("d3 Tutorials")])]),e("p",[e("a",{attrs:{href:"https://github.com/mbostock/d3/wiki/Gallery",target:"_blank"}},[t._v("Gallery")])]),e("p",[e("a",{attrs:{href:"http://datavisual.lofter.com/post/40cf3a_188e535",target:"_blank"}},[t._v("lofter")])]),e("p",[e("a",{attrs:{href:"http://alanland.iteye.com/blog/1878595",target:"_blank"}},[t._v("iteye")])]),e("p",[e("a",{attrs:{href:"http://javascript.ruanyifeng.com/library/d3.html",target:"_blank"}},[t._v("ruanyifeng")])]),e("p",[t._v("Requriejs")]),e("p",[t._v("Requriejs 地址")]),e("p",[e("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2012/10/javascript_module.html",target:"_blank"}},[t._v("Javascript模块化编程（一）：模块的写法")])]),e("p",[e("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html",target:"_blank"}},[t._v("Javascript模块化编程（二）：AMD规范")])]),e("p",[e("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2012/11/require_js.html",target:"_blank"}},[t._v("Javascript模块化编程（三）：require.js的用法")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/snandy/archive/2012/05/22/2513652.html",target:"_blank"}},[t._v("RequireJS入门（一）")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/snandy/archive/2012/05/23/2513712.html",target:"_blank"}},[t._v("RequireJS入门（二）")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/snandy/archive/2012/06/08/2538001.html",target:"_blank"}},[t._v("RequireJS进阶（三）")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/yexiaochai/p/3632580.html",target:"_blank"}},[t._v("requrie源码学习")])]),e("p",[e("a",{attrs:{href:"http://www.oschina.net/translate/getting-started-with-the-requirejs-library",target:"_blank"}},[t._v("requrie\n                    入门指南")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/yexiaochai/p/3214926.html",target:"_blank"}},[t._v("requrieJS 学习笔记")])]),e("p",[e("a",{attrs:{href:"http://cyj.me/why-seajs/requirejs/",target:"_blank"}},[t._v("requriejs 其一")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/yexiaochai/p/3221081.html",target:"_blank"}},[t._v("require backbone结合")])]),e("p",[t._v("Seajs")]),e("p",[t._v("Seajs 地址")]),e("p",[e("a",{attrs:{href:"http://seajs.org",target:"_blank"}},[t._v("seajs")])]),e("p",[e("a",{attrs:{href:"http://cyj.me/why-seajs/zh",target:"_blank"}},[t._v("seajs 中文手册")])]),e("p",[t._v("Less,sass")]),e("p",[t._v("Less,sass 地址")]),e("p",[e("a",{attrs:{href:"http://www.w3cplus.com/sassguide",target:"_blank"}},[t._v("sass")])]),e("p",[e("a",{attrs:{href:"http://www.sass.hk",target:"_blank"}},[t._v("sass教程-sass中国")])]),e("p",[e("a",{attrs:{href:"http://sass.bootcss.com",target:"_blank"}},[t._v("Sass 中文文档")])]),e("p",[e("a",{attrs:{href:"http://less.bootcss.com",target:"_blank"}},[t._v("less")])]),e("p",[t._v("Markdown")]),e("p",[t._v("Markdown 地址")]),e("p",[e("a",{attrs:{href:"http://wowubuntu.com/markdown",target:"_blank"}},[t._v("Markdown 语法说明 (简体中文版")])]),e("p",[e("a",{attrs:{href:"https://github.com/LearnShare/Learning-Markdown/blob/master/README.md",target:"_blank"}},[t._v("markdown入门参考")])]),e("p",[e("a",{attrs:{href:"https://www.gitbook.com",target:"_blank"}},[t._v("gitbook")])]),e("p",[e("a",{attrs:{href:"https://www.zybuluo.com/mdeditor",target:"_blank"}},[t._v("mdeditor")])]),e("p",[e("a",{attrs:{href:"https://stackedit.io",target:"_blank"}},[t._v("stackedit")])]),e("p",[e("a",{attrs:{href:"http://bh-lay.github.io/mditor",target:"_blank"}},[t._v("mditor")])]),e("p",[e("a",{attrs:{href:"https://github.com/lepture/editor",target:"_blank"}},[t._v("lepture-editor")])]),e("p",[e("a",{attrs:{href:"https://github.com/jbt/markdown-editor",target:"_blank"}},[t._v("markdown-editor")])]),e("p",[e("a",{attrs:{href:"https://www.zybuluo.com",target:"_blank"}},[t._v("作业部落")])]),e("p",[t._v("兼容性")]),e("p",[t._v("兼容性 地址")]),e("p",[e("a",{attrs:{href:"http://kangax.github.io/compat-table/es6",target:"_blank"}},[t._v("esma 兼容列表")])]),e("p",[e("a",{attrs:{href:"http://jigsaw.w3.org/css-validator/validator.html.zh-cn",target:"_blank"}},[t._v("W3C CSS验证服务")])]),e("p",[e("a",{attrs:{href:"http://caniuse.com/#index",target:"_blank"}},[t._v("caniuse")])]),e("p",[e("a",{attrs:{href:"http://csscreator.com/properties",target:"_blank"}},[t._v("csscreator")])]),e("p",[e("a",{attrs:{href:"https://msdn.microsoft.com/zh-cn/library/cc351024",target:"_blank"}},[t._v("microsoft")])]),e("p",[e("a",{attrs:{href:"http://www.responsinator.com",target:"_blank"}},[t._v("在线测兼容-移动端")])]),e("p",[e("a",{attrs:{href:"https://www.manymo.com/emulators",target:"_blank"}},[t._v("emulators")])]),e("p",[t._v("UI相关")]),e("p",[t._v("UI相关 地址")]),e("p",[e("a",{attrs:{href:"http://v3.bootcss.com",target:"_blank"}},[t._v("bootcss")])]),e("p",[e("a",{attrs:{href:"http://www.w3cplus.com/MetroUICSS",target:"_blank"}},[t._v("MetroUICSS")])]),e("p",[e("a",{attrs:{href:"http://semantic-ui.com",target:"_blank"}},[t._v("semantic")])]),e("p",[e("a",{attrs:{href:"http://alexwolfe.github.io/Buttons",target:"_blank"}},[t._v("Buttons")])]),e("p",[e("a",{attrs:{href:"http://hiloki.github.io/kitecss",target:"_blank"}},[t._v("kitecss")])]),e("p",[e("a",{attrs:{href:"http://www.pintuer.com",target:"_blank"}},[t._v("pintuer")])]),e("p",[e("a",{attrs:{href:"http://amazeui.org",target:"_blank"}},[t._v("amazeui")])]),e("p",[e("a",{attrs:{href:"http://www.worldhello.net/gotgithub/index.html",target:"_blank"}},[t._v("worldhello")])]),e("p",[e("a",{attrs:{href:"http://igit.linuxtoy.org/contents.html",target:"_blank"}},[t._v("linuxtoy")])]),e("p",[e("a",{attrs:{href:"http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn",target:"_blank"}},[t._v("gitmagic")])]),e("p",[e("a",{attrs:{href:"http://rogerdudler.github.io/git-guide/index.zh.html",target:"_blank"}},[t._v("rogerdudler")])]),e("p",[e("a",{attrs:{href:"http://gitref.justjavac.com",target:"_blank"}},[t._v("gitref")])]),e("p",[e("a",{attrs:{href:"http://git-scm.com/book/zh",target:"_blank"}},[t._v("book")])]),e("p",[e("a",{attrs:{href:"http://gogojimmy.net/2012/01/17/how-to-use-git-1-git-basic",target:"_blank"}},[t._v("gogojimmy")])]),e("p",[t._v("其它API")]),e("p",[t._v("其它API 地址")]),e("p",[e("a",{attrs:{href:"http://segmentfault.com/bookmark/1230000002521721",target:"_blank"}},[t._v("HTTP API 设计指南")])]),e("p",[t._v("javascript流行库汇总 javascriptoo")]),e("p",[e("a",{attrs:{href:"http://niceue.com/validator/demo/index.php",target:"_blank"}},[t._v("验证api")])]),e("p",[e("a",{attrs:{href:"http://www.css88.com/doc/underscore",target:"_blank"}},[t._v("underscore 中文手册")])]),e("p",[e("a",{attrs:{href:"http://www.html-js.com/article/Underscorejs-source-code-analysis-of-underscorejs-source-code-analysis%203031",target:"_blank"}},[t._v("underscore源码分析")])]),e("p",[e("a",{attrs:{href:"http://yalishizhude.github.io/tags/underscore",target:"_blank"}},[t._v("underscore源码分析-亚里士朱德的博客")])]),e("p",[e("a",{attrs:{href:"http://underscorejs.org",target:"_blank"}},[t._v("underscrejs en api")])]),e("p",[e("a",{attrs:{href:"https://lodash.com",target:"_blank"}},[t._v("lodash - underscore的代替品")])]),e("p",[e("a",{attrs:{href:"http://extjs-doc-cn.github.io/ext4api",target:"_blank"}},[t._v("ext4api")])]),e("p",[e("a",{attrs:{href:"http://www.csser.com/tools/backbone/backbone.js.html",target:"_blank"}},[t._v("backbone 中文手册")])]),e("p",[e("a",{attrs:{href:"http://dev.qwrap.com/resource/js/_docs/_youa/#/qw/base/loadJs_.htm",target:"_blank"}},[t._v("qwrap手册")])]),e("p",[e("a",{attrs:{href:"http://easings.net/zh-cn",target:"_blank"}},[t._v("缓动函数")])]),e("p",[e("a",{attrs:{href:"http://www.w3school.com.cn/svg/svg_reference.asp",target:"_blank"}},[t._v("svg 中文参考")])]),e("p",[e("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/SVG",target:"_blank"}},[t._v("svg mdn参考")])]),e("p",[e("a",{attrs:{href:"https://github.com/gabelerner/canvg",target:"_blank"}},[t._v("svg 导出 canvas")])]),e("p",[e("a",{attrs:{href:"https://github.com/exupero/saveSvgAsPng",target:"_blank"}},[t._v("svg 导出 png")])]),e("p",[e("a",{attrs:{href:"http://www.zamzar.com/convert/ai-to-svg",target:"_blank"}},[t._v("ai-to-svg")])]),e("p",[e("a",{attrs:{href:"https://github.com/machao/localStorage",target:"_blank"}},[t._v("localStorage 库")])]),e("p",[t._v("图表类")]),e("p",[t._v("图表类 地址")]),e("p",[e("a",{attrs:{href:"http://www.hcharts.cn/api/index.php",target:"_blank"}},[t._v("Highcharts 中文API")])]),e("p",[e("a",{attrs:{href:"http://api.highcharts.com/highcharts",target:"_blank"}},[t._v("Highcharts 英文API")])]),e("p",[e("a",{attrs:{href:"http://echarts.baidu.com/",target:"_blank"}},[t._v("ECharts 百度的图表软件")])]),e("p",[e("a",{attrs:{href:"http://lbs.amap.com/api",target:"_blank"}},[t._v("高德地图")])]),e("p",[e("a",{attrs:{href:"http://paperjs.org",target:"_blank"}},[t._v("开源的矢量图脚本框架")])]),e("p",[e("a",{attrs:{href:"http://jvectormap.com",target:"_blank"}},[t._v("svg 地图")])]),e("p",[t._v("正则")]),e("p",[t._v("正则 地址")]),e("p",[e("a",{attrs:{href:"http://segmentfault.com/a/1190000002471140",target:"_blank"}},[t._v("JS正则表达式元字符")])]),e("p",[e("a",{attrs:{href:"http://deerchao.net/tutorials/regex/regex.htm",target:"_blank"}},[t._v("正则表达式30分钟入门教程")])]),e("p",[e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions",target:"_blank"}},[t._v("MDN-正则表达式")])]),e("p",[e("a",{attrs:{href:"http://javascript.ruanyifeng.com/stdlib/regexp.html",target:"_blank"}},[t._v("ruanyifeng - RegExp对象")])]),e("p",[e("a",{attrs:{href:"http://div.io/topic/764?page=1",target:"_blank"}},[t._v("小胡子哥 - 进阶正则表达式")])]),e("p",[e("a",{attrs:{href:"https://github.com/Cedriking/is.js/blob/master/is.js",target:"_blank"}},[t._v("is.js")])]),e("p",[e("a",{attrs:{href:"http://regexper.com",target:"_blank"}},[t._v("正则在线测试")])]),e("p",[t._v("前端")]),e("p",[t._v("前端 地址")]),e("p",[e("a",{attrs:{href:"http://alloyteam.github.io/CodeGuide",target:"_blank"}},[t._v("通过分析github代码库总结出来的工程师代码书写习惯")])]),e("p",[e("a",{attrs:{href:"http://codeguide.bootcss.com",target:"_blank"}},[t._v("HTML&CSS编码规范 by @mdo")])]),e("p",[e("a",{attrs:{href:"http://www.alloyteam.com/2011/10/css-on-team-naming/",target:"_blank"}},[t._v("团队合作的css命名规范-腾讯AlloyTeam前端团队")])]),e("p",[e("a",{attrs:{href:"http://yuwenhui.github.io",target:"_blank"}},[t._v("前端编码规范之js - by yuwenhui")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/hustskyking/p/javascript-spec.html",target:"_blank"}},[t._v("前端编码规范之js - by 李靖")])]),e("p",[e("a",{attrs:{href:"http://zhibimo.com/read/Ashu/front-end-style-guide",target:"_blank"}},[t._v("前端开发规范手册")])]),e("p",[e("a",{attrs:{href:"https://github.com/yuche/javascript#table-of-contents",target:"_blank"}},[t._v("Airbnb JavaScript\n                    编码规范（简体中文版）")])]),e("p",[e("a",{attrs:{href:"http://www.zhihu.com/question/20351507",target:"_blank"}},[t._v("AMD与CMD规范的区别")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/tugenhua0707/p/3507957.html",target:"_blank"}},[t._v("AMD与CMD规范的区别")])]),e("p",[e("a",{attrs:{href:"http://docs.kissyui.com/1.4/docs/html/tutorials/style-guide/kissy-source-style.html",target:"_blank"}},[t._v("KISSY 源码规范")])]),e("p",[e("a",{attrs:{href:"http://codeguide.bootcss.com",target:"_blank"}},[t._v("bt编码规范")])]),e("p",[e("a",{attrs:{href:"https://github.com/Suxiaogang/Code_Guide",target:"_blank"}},[t._v("规范加强版")])]),e("p",[e("a",{attrs:{href:"http://blog.jobbole.com/79075",target:"_blank"}},[t._v("前端代码规范 及 最佳实践")])]),e("p",[e("a",{attrs:{href:"http://coderlmn.github.io/code-standards",target:"_blank"}},[t._v("百度前端规范")])]),e("p",[e("a",{attrs:{href:"http://isobar-idev.github.io/code-standards",target:"_blank"}},[t._v("百度前端规范")])]),e("p",[e("a",{attrs:{href:"http://zhuanlan.zhihu.com/fuyun/19884834",target:"_blank"}},[t._v("百度前端规范")])]),e("p",[e("a",{attrs:{href:"https://github.com/gf-rd/es6-coding-style",target:"_blank"}},[t._v("ECMAScript6 编码规范--广发证券前端团队")])]),e("p",[e("a",{attrs:{href:"http://blog.jobbole.com/79484",target:"_blank"}},[t._v("JavaScript 风格指南/编码规范（Airbnb公司版）")])]),e("p",[e("a",{attrs:{href:"http://nec.netease.com/standard",target:"_blank"}},[t._v("网易前端开发规范")])]),e("p",[e("a",{attrs:{href:"http://www.75team.com/archives/1049",target:"_blank"}},[t._v("css模块")])]),e("p",[e("a",{attrs:{href:"https://github.com/ecomfe/spec",target:"_blank"}},[t._v("前端规范资源列表")])]),e("p",[t._v("PHP")]),e("p",[t._v("PHP 地址")]),e("p",[e("a",{attrs:{href:"http://segmentfault.com/a/1190000000443795",target:"_blank"}},[t._v("最流行的PHP 代码规范")])]),e("p",[e("a",{attrs:{href:"https://github.com/hfcorriez/fig-standards/blob/zh_CN/%E6%8E%A5%E5%8F%97/PSR-2-coding-style-guide.md",target:"_blank"}},[t._v("最流行的PHP 代码规范")])]),e("p",[t._v("各大公司开源项目")]),e("p",[t._v("各大公司开源项目 地址")]),e("p",[e("a",{attrs:{href:"https://code.facebook.com/projects/web",target:"_blank"}},[t._v("Facebook Projects")])]),e("p",[e("a",{attrs:{href:"http://fex.baidu.com",target:"_blank"}},[t._v("百度web前端研发部")])]),e("p",[e("a",{attrs:{href:"http://efe.baidu.com",target:"_blank"}},[t._v("百度EFE")])]),e("p",[e("a",{attrs:{href:"https://github.com/fex-team",target:"_blank"}},[t._v("百度github")])]),e("p",[e("a",{attrs:{href:"http://www.alloyteam.com",target:"_blank"}},[t._v("alloyteam")])]),e("p",[e("a",{attrs:{href:"http://alloyteam.github.io",target:"_blank"}},[t._v("alloyteam-github")])]),e("p",[e("a",{attrs:{href:"https://github.com/AlloyTeam/AlloyGameEngine",target:"_blank"}},[t._v("alloyteam-AlloyGameEngine")])]),e("p",[e("a",{attrs:{href:"http://alloyteam.github.io/AlloyDesigner",target:"_blank"}},[t._v("AlloyDesigner")])]),e("p",[e("a",{attrs:{href:"http://www.alloyteam.com/2015/06/h5-jiao-hu-ye-bian-ji-qi-aeditor-jie-shao",target:"_blank"}},[t._v("H5交互页编辑器AEditor介绍")])]),e("p",[e("a",{attrs:{href:"http://aeditor.alloyteam.com",target:"_blank"}},[t._v("AEditor")])]),e("p",[e("a",{attrs:{href:"http://forum.maka.im/wordpress",target:"_blank"}},[t._v("maka")])]),e("p",[e("a",{attrs:{href:"https://github.com/fenbility/weekly-feed",target:"_blank"}},[t._v("值得订阅的weekly")])]),e("p",[e("a",{attrs:{href:"http://cube.qq.com",target:"_blank"}},[t._v("腾讯html5")])]),e("p",[e("a",{attrs:{href:"http://75team.github.io",target:"_blank"}},[t._v("奇舞团开源项目")])]),e("p",[e("a",{attrs:{href:"http://ued.qunar.com",target:"_blank"}},[t._v("Qunar UED")])]),e("p",[e("a",{attrs:{href:"http://scrat.io",target:"_blank"}},[t._v("Scrat")])]),e("p",[t._v("常用")]),e("p",[t._v("常用 地址")]),e("p",[e("a",{attrs:{href:"http://www.zhangxinxu.com/wordpress/2013/12/iebetter-js-make-ie6-ie8-like-modern-browser-ie9-chrome",target:"_blank"}},[t._v("ieBetter.js-让IE6-IE8拥有IE9+,Chrome等浏览器特性")])]),e("p",[e("a",{attrs:{href:"http://mottie.github.io/Keyboard",target:"_blank"}},[t._v("模拟键盘")])]),e("p",[e("a",{attrs:{href:"https://github.com/hotoo/pinyin",target:"_blank"}},[t._v("拼音")])]),e("p",[e("a",{attrs:{href:"https://github.com/mc-zone/IDValidator",target:"_blank"}},[t._v("中国个人身份证号验证")])]),e("p",[t._v("算法")]),e("p",[t._v("算法 地址")]),e("p",[e("a",{attrs:{href:"https://github.com/Ralph-Wang/algorithm.in.js",target:"_blank"}},[t._v("数据结构与算法 JavaScript 描述. 章节练习")])]),e("p",[e("a",{attrs:{href:"https://github.com/twobin/twobinSort",target:"_blank"}},[t._v("常见排序算法（JS版）")])]),e("p",[e("a",{attrs:{href:"https://github.com/luofei2011/jsAgm/blob/master/js/sort.js",target:"_blank"}},[t._v("经典排序")])]),e("p",[e("a",{attrs:{href:"https://github.com/hechangmin/jssort",target:"_blank"}},[t._v("常见排序算法-js版本")])]),e("p",[e("a",{attrs:{href:"https://github.com/lightningtgc/JavaScript-Algorithms",target:"_blank"}},[t._v("JavaScript 算法与数据结构 精华集")])]),e("p",[e("a",{attrs:{href:"http://www.nowcoder.com/live/courses",target:"_blank"}},[t._v("面试常考算法题精讲")])]),e("p",[t._v("移动端")]),e("p",[t._v("移动端 地址")]),e("p",[e("a",{attrs:{href:"https://github.com/ftlabs/fastclick",target:"_blank"}},[t._v("fastclick")])]),e("p",[e("a",{attrs:{href:"https://github.com/mmastrac/jquery-noclickdelay",target:"_blank"}},[t._v("no-click-delay")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/lcw/p/3619181.html",target:"_blank"}},[t._v("【敏捷开发】Android团队开发规范")])]),e("p",[e("a",{attrs:{href:"http://www.jianshu.com/p/4390f4fe19b3",target:"_blank"}},[t._v("Android 开发规范与应用")])]),e("p",[e("a",{attrs:{href:"https://github.com/ychow/ionic-guide",target:"_blank"}},[t._v("ionic")])]),e("p",[t._v("JSON")]),e("p",[t._v("JSON 地址")]),e("p",[e("a",{attrs:{href:"http://beta.json-generator.com",target:"_blank"}},[t._v("模拟生成JSON数据")])]),e("p",[e("a",{attrs:{href:"http://jsonp.afeld.me",target:"_blank"}},[t._v("返回跨域JSONAPI")])]),e("p",[t._v("焦点图")]),e("p",[t._v("焦点图 地址")]),e("p",[e("a",{attrs:{href:"https://github.com/koen301/myfocus",target:"_blank"}},[t._v("myfocus")])]),e("p",[e("a",{attrs:{href:"http://www.chhua.com/myfocus",target:"_blank"}},[t._v("myfocus-官方演示站")])]),e("p",[e("a",{attrs:{href:"http://www.superslide2.com",target:"_blank"}},[t._v("SuperSlidev2.1 -- 大话主席")])]),e("p",[e("a",{attrs:{href:"http://www.bujichong.com/sojs/soChange/index.html",target:"_blank"}},[t._v("soChange")])]),e("p",[t._v("Ext, EasyUI, J-UI 及其它各种UI方案")]),e("p",[t._v("Ext, EasyUI, J-UI 及其它各种UI方案 地址")]),e("p",[e("a",{attrs:{href:"https://www.sencha.com/products/extjs",target:"_blank"}},[t._v("extjs")])]),e("p",[e("a",{attrs:{href:"http://docs.sencha.com/extjs/4.0.7",target:"_blank"}},[t._v("ext4英文api")])]),e("p",[e("a",{attrs:{href:"http://extjs-doc-cn.github.io/ext4api",target:"_blank"}},[t._v("ext4中文api")])]),e("p",[e("a",{attrs:{href:"http://jquery-easyui.googlecode.com/svn/trunk/src",target:"_blank"}},[t._v("jquery easyui 未压缩源代码")])]),e("p",[e("a",{attrs:{href:"http://jui.org",target:"_blank"}},[t._v("J-UI")])]),e("p",[e("a",{attrs:{href:"http://dcloudio.github.io/mui",target:"_blank"}},[t._v("MUI-最接近原生APP体验的高性能前端框架")])]),e("p",[t._v("Amaze UI 中国首个开源 HTML5 跨屏前端框架")]),e("p",[e("a",{attrs:{href:"http://m.sui.taobao.org",target:"_blank"}},[t._v("淘宝 HTML5 前端框架")])]),e("p",[e("a",{attrs:{href:"http://docs.kissyui.com",target:"_blank"}},[t._v("KISSY - 阿里前端JavaScript库")])]),e("p",[e("a",{attrs:{href:"http://nej.netease.com",target:"_blank"}},[t._v("网易Nej - Nice Easy Javascript")])]),e("p",[e("a",{attrs:{href:"http://demos.telerik.com/kendo-ui/mvvm/index",target:"_blank"}},[t._v("Kendo UI MVVM Demo")])]),e("p",[e("a",{attrs:{href:"http://www.bootcss.com",target:"_blank"}},[t._v("Bootstrap")])]),e("p",[e("a",{attrs:{href:"http://smartui.chinamzz.com",target:"_blank"}},[t._v("Smart UI")])]),e("p",[e("a",{attrs:{href:"http://developer.yahoo.com/yui/grids",target:"_blank"}},[t._v("雅虎UI - CSS UI")])]),e("p",[t._v("页面 社会化 分享功能")]),e("p",[t._v("页面 社会化 分享功能 地址")]),e("p",[e("a",{attrs:{href:"http://share.baidu.com",target:"_blank"}},[t._v("百度分享")])]),e("p",[e("a",{attrs:{href:"http://jiathis.com",target:"_blank"}},[t._v("JiaThis")])]),e("p",[e("a",{attrs:{href:"http://developer.baidu.com/soc/share",target:"_blank"}},[t._v("社会化分享组件")])]),e("p",[e("a",{attrs:{href:"http://www.mob.com/#/index",target:"_blank"}},[t._v("ShareSDK 轻松实现社会化功能")])]),e("p",[e("a",{attrs:{href:"http://dev.umeng.com/social/android/quick-integration",target:"_blank"}},[t._v("友盟分享")])]),e("p",[t._v("富文本编辑器")]),e("p",[t._v("富文本编辑器 地址")]),e("p",[e("a",{attrs:{href:"https://www.tinymce.com",target:"_blank"}},[t._v("功能齐全 tinymce")])]),e("p",[e("a",{attrs:{href:"http://ueditor.baidu.com/website",target:"_blank"}},[t._v("百度 ueditor")])]),e("p",[e("a",{attrs:{href:"http://ckeditor.com",target:"_blank"}},[t._v("经典的ckeditor")])]),e("p",[e("a",{attrs:{href:"http://kindeditor.net",target:"_blank"}},[t._v("经典的kindeditor")])]),e("p",[e("a",{attrs:{href:"http://www.bootcss.com/p/bootstrap-wysiwyg",target:"_blank"}},[t._v("wysiwyg")])]),e("p",[e("a",{attrs:{href:"http://integ.github.io/BachEditor",target:"_blank"}},[t._v("一个有情怀的编辑器。Bach's Editor")])]),e("p",[e("a",{attrs:{href:"https://github.com/mycolorway/simditor",target:"_blank"}},[t._v("tower用的编辑器")])]),e("p",[e("a",{attrs:{href:"https://github.com/summernote/summernote",target:"_blank"}},[t._v("summernote 编辑器")])]),e("p",[e("a",{attrs:{href:"http://neilj.github.io/Squire",target:"_blank"}},[t._v("html5编辑器")])]),e("p",[e("a",{attrs:{href:"http://lab.hustlzp.com/XEditor",target:"_blank"}},[t._v("XEditor")])]),e("p",[e("a",{attrs:{href:"https://github.com/wangfupeng1988/wangEditor",target:"_blank"}},[t._v("wangEditor")])]),e("p",[t._v("前端概述")]),e("p",[t._v("前端概述 地址")]),e("p",[e("a",{attrs:{href:"http://www.awesomes.cn",target:"_blank"}},[t._v("前端工具大全")])]),e("p",[e("a",{attrs:{href:"https://github.com/fouber/blog/issues/10?from=timeline&isappinstalled=0#",target:"_blank"}},[t._v("什么是前端工程化")])]),e("p",[t._v("Gulp")]),e("p",[t._v("Gulp 地址")]),e("p",[e("a",{attrs:{href:"http://gulpjs.com",target:"_blank"}},[t._v("Gulp官网")])]),e("p",[e("a",{attrs:{href:"http://www.gulpjs.com.cn",target:"_blank"}},[t._v("Gulp中文网")])]),e("p",[e("a",{attrs:{href:"https://github.com/Platform-CUF/use-gulp",target:"_blank"}},[t._v("gulp资料收集")])]),e("p",[e("a",{attrs:{href:"http://javascript.ruanyifeng.com/tool/gulp.html",target:"_blank"}},[t._v("Gulp：任务自动管理工具 - ruanyifeng")])]),e("p",[e("a",{attrs:{href:"http://gulpjs.com/plugins",target:"_blank"}},[t._v("Gulp插件")])]),e("p",[e("a",{attrs:{href:"http://www.jeffjade.com/2015/11/25/2015-11-25-toss-gulp/",target:"_blank"}},[t._v("Gulp探究折腾之路(I)")])]),e("p",[e("a",{attrs:{href:"http://www.jeffjade.com/2016/01/19/2016-01-19-toss-gulp/",target:"_blank"}},[t._v("Gulp折腾之路(II)")])]),e("p",[e("a",{attrs:{href:"http://www.ido321.com/1622.html",target:"_blank"}},[t._v("Gulp不完全入门教程")])]),e("p",[e("a",{attrs:{href:"https://github.com/hjzheng/CUF_meeting_knowledge_share/issues/33",target:"_blank"}},[t._v("为什么使用gulp?")])]),e("p",[e("a",{attrs:{href:"http://www.dbpoo.com/getting-started-with-gulp",target:"_blank"}},[t._v("Gulp安装及配合组件构建前端开发一体化")])]),e("p",[e("a",{attrs:{href:"https://github.com/nimojs/gulp-book",target:"_blank"}},[t._v("Gulp 入门指南")])]),e("p",[e("a",{attrs:{href:"https://github.com/nimojs/blog/issues/19",target:"_blank"}},[t._v("Gulp 入门指南 - nimojs")])]),e("p",[e("a",{attrs:{href:"http://www.imooc.com/video/5692",target:"_blank"}},[t._v("Gulp in Action")])]),e("p",[e("a",{attrs:{href:"http://www.w3ctech.com/topic/134",target:"_blank"}},[t._v("Gulp开发教程（翻译）")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/2050/p/4198792.html",target:"_blank"}},[t._v("前端构建工具gulpjs的使用介绍及技巧")])]),e("p",[t._v("Grunt")]),e("p",[t._v("Grunt 地址")]),e("p",[e("a",{attrs:{href:"http://gruntjs.com",target:"_blank"}},[t._v("gruntjs")])]),e("p",[e("a",{attrs:{href:"http://www.gruntjs.net",target:"_blank"}},[t._v("Grunt中文网")])]),e("p",[t._v("Fis")]),e("p",[t._v("Fis 地址")]),e("p",[e("a",{attrs:{href:"http://fex-team.github.io/fis-site/index.html",target:"_blank"}},[t._v("fis 官网")])]),e("p",[e("a",{attrs:{href:"http://fis.baidu.com",target:"_blank"}},[t._v("fis")])]),e("p",[t._v("pc图轮")]),e("p",[t._v("pc图轮 地址")]),e("p",[e("a",{attrs:{href:"http://www.jsfoot.com/jquery/demo/2011-09-20/192.html",target:"_blank"}},[t._v("单屏轮播sochange")])]),e("p",[e("a",{attrs:{href:"http://bxslider.com/examples/carousel-demystified",target:"_blank"}},[t._v("左右按钮多图切换")])]),e("p",[e("a",{attrs:{href:"https://github.com/alvarotrigo/fullPage.js",target:"_blank"}},[t._v("fullpage全屏轮播")])]),e("p",[t._v("移动端图轮")]),e("p",[t._v("移动端图轮 地址")]),e("p",[e("a",{attrs:{href:"http://www.swipejs.com",target:"_blank"}},[t._v("无缝切换")])]),e("p",[e("a",{attrs:{href:"http://www.idangero.us/swiper",target:"_blank"}},[t._v("滑屏效果")])]),e("p",[e("a",{attrs:{href:"https://github.com/peunzhang/fullpage",target:"_blank"}},[t._v("全屏fullpage")])]),e("p",[e("a",{attrs:{href:"https://github.com/qiqiboy/touchslider",target:"_blank"}},[t._v("单个图片切换")])]),e("p",[e("a",{attrs:{href:"https://github.com/peunzhang/slip.js",target:"_blank"}},[t._v("单个全屏切换")])]),e("p",[e("a",{attrs:{href:"http://touch.code.baidu.com/examples.html?qq-pf-to=pcqq.group",target:"_blank"}},[t._v("百度的切换库")])]),e("p",[e("a",{attrs:{href:"https://github.com/peunzhang/iSlider",target:"_blank"}},[t._v("单个全屏切换")])]),e("p",[e("a",{attrs:{href:"https://github.com/saw/touch-interfaces",target:"_blank"}},[t._v("滑屏效果")])]),e("p",[e("a",{attrs:{href:"http://baijs.com/tinycircleslider",target:"_blank"}},[t._v("旋转拖动设置")])]),e("p",[e("a",{attrs:{href:"http://touchslider.com",target:"_blank"}},[t._v("类似于swipe切换")])]),e("p",[e("a",{attrs:{href:"http://www.swiper.com.cn/demo/index.html",target:"_blank"}},[t._v("支持多种形式的触摸滑动")])]),e("p",[e("a",{attrs:{href:"https://github.com/joker-ye/main/blob/master/wap/index.html",target:"_blank"}},[t._v("滑屏效果")])]),e("p",[e("a",{attrs:{href:"http://www.superslide2.com",target:"_blank"}},[t._v("大话主席pc移动图片轮换")])]),e("p",[e("a",{attrs:{href:"https://github.com/hahnzhu/parallax.js",target:"_blank"}},[t._v("滑屏效果")])]),e("p",[e("a",{attrs:{href:"https://github.com/yanhaijing/zepto.fullpage",target:"_blank"}},[t._v("基于zepto的fullpage")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/plums/archive/2013/01/10/WebApp-fixed-width-layout-of-multi-terminal-adapter-since.html",target:"_blank"}},[t._v("[WebApp]定宽网页设计下，固定宽度布局开发WebApp并实现多终端下WebApp布局自适应")])]),e("p",[e("a",{attrs:{href:"http://loo2k.com/blog/detecting-wechat-client",target:"_blank"}},[t._v("判断微信客户端的那些坑")])]),e("p",[e("a",{attrs:{href:"https://github.com/JefferyWang/nativeShare.js",target:"_blank"}},[t._v("可以通过javascript直接调用原生分享的工具")])]),e("p",[e("a",{attrs:{href:"http://www.jiathis.com/help/html/weixin-share-code",target:"_blank"}},[t._v("JiaThis 分享到微信代码")])]),e("p",[e("a",{attrs:{href:"http://fex.baidu.com/blog/2015/05/cross-mobile",target:"_blank"}},[t._v("聊聊移动端跨平台开发的各种技术")])]),e("p",[e("a",{attrs:{href:"http://www.zhihu.com/question/29922082",target:"_blank"}},[t._v("前端自动化测试")])]),e("p",[e("a",{attrs:{href:"http://ajccom.github.io/niceslider",target:"_blank"}},[t._v("多种轮换图片")])]),e("p",[e("a",{attrs:{href:"https://mango.github.io/slideout",target:"_blank"}},[t._v("滑动侧边栏")])]),e("p",[t._v("文件上传")]),e("p",[t._v("文件上传 地址")]),e("p",[e("a",{attrs:{href:"http://fex.baidu.com/webuploader",target:"_blank"}},[t._v("百度上传组件")])]),e("p",[e("a",{attrs:{href:"https://blueimp.github.io/jQuery-File-Upload",target:"_blank"}},[t._v("上传")])]),e("p",[e("a",{attrs:{href:"http://www.hdfu.net",target:"_blank"}},[t._v("flash 头像上传")])]),e("p",[e("a",{attrs:{href:"http://www.dropzonejs.com",target:"_blank"}},[t._v("图片上传预览")])]),e("p",[e("a",{attrs:{href:"http://elemefe.github.io/image-cropper",target:"_blank"}},[t._v("图片裁剪")])]),e("p",[e("a",{attrs:{href:"http://www.shearphoto.com",target:"_blank"}},[t._v("图片裁剪-shearphoto")])]),e("p",[e("a",{attrs:{href:"http://www.oschina.net/project/tag/284/jquery-image-tools?lang=0&os=0&sort=view&p=2",target:"_blank"}},[t._v("jQuery图片处理")])]),e("p",[t._v("模拟select")]),e("p",[t._v("模拟select 地址")]),e("p",[e("a",{attrs:{href:"http://aui.github.io/popupjs/doc/selectbox.html",target:"_blank"}},[t._v("糖饼 select")])]),e("p",[e("a",{attrs:{href:"https://github.com/rmm5t/jquery-flexselect",target:"_blank"}},[t._v("flexselect")])]),e("p",[e("a",{attrs:{href:"http://loudev.com",target:"_blank"}},[t._v("双select")])]),e("p",[e("a",{attrs:{href:"http://select2.github.io",target:"_blank"}},[t._v("select2")])]),e("p",[t._v("取色插件")]),e("p",[t._v("取色插件 地址")]),e("p",[e("a",{attrs:{href:"http://www.jq22.com/plugin/367",target:"_blank"}},[t._v("类似 Photoshop 的界面取色插件")])]),e("p",[e("a",{attrs:{href:"https://github.com/jquery/jquery-color",target:"_blank"}},[t._v("jquery color")])]),e("p",[e("a",{attrs:{href:"http://www.oschina.net/project/tag/287/color-picker",target:"_blank"}},[t._v("取色插件集合")])]),e("p",[e("a",{attrs:{href:"https://github.com/mattfarina/farbtastic",target:"_blank"}},[t._v("farbtastic 圆环＋正方形")])]),e("p",[t._v("城市联动")]),e("p",[t._v("城市联动 地址")]),e("p",[e("a",{attrs:{href:"http://www.ijquery.cn/?p=360",target:"_blank"}},[t._v("jquery.cityselect.js基于jQuery+JSON的省市或自定义联动效果")])]),e("p",[t._v("剪贴板")]),e("p",[t._v("剪贴板 地址")]),e("p",[e("a",{attrs:{href:"https://github.com/zeroclipboard/zeroclipboard",target:"_blank"}},[t._v("剪贴板")])]),e("p",[e("a",{attrs:{href:"http://zenorocha.github.io/clipboard.js",target:"_blank"}},[t._v("clipboard 最新的剪切方案")])]),e("p",[e("a",{attrs:{href:"https://github.com/zenorocha/clipboard.js",target:"_blank"}},[t._v("不是Flash的剪贴板")])]),e("p",[t._v("简繁转换")]),e("p",[t._v("简繁转换 地址")]),e("p",[e("a",{attrs:{href:"https://github.com/BYVoid/OpenCC",target:"_blank"}},[t._v("简繁转换")])]),e("p",[t._v("表格 Grid")]),e("p",[t._v("表格 Grid 地址")]),e("p",[e("a",{attrs:{href:"http://facebook.github.io/fixed-data-table",target:"_blank"}},[t._v("facebook表格")])]),e("p",[e("a",{attrs:{href:"http://handsontable.com",target:"_blank"}},[t._v("类似于Excel编辑表格-handsontable")])]),e("p",[e("a",{attrs:{href:"http://bootstrap-table.wenzhixin.net.cn",target:"_blank"}},[t._v("bootstrap-table插件")])]),e("p",[e("a",{attrs:{href:"https://www.datatables.net",target:"_blank"}},[t._v("datatables")])]),e("p",[t._v("在线演示")]),e("p",[t._v("在线演示 地址")]),e("p",[e("a",{attrs:{href:"http://runjs.cn",target:"_blank"}},[t._v("js 在线编辑 - runjs")])]),e("p",[e("a",{attrs:{href:"http://jsbin.com",target:"_blank"}},[t._v("js 在线编辑 - jsbin")])]),e("p",[e("a",{attrs:{href:"http://codepen.io",target:"_blank"}},[t._v("js 在线编辑 - codepen")])]),e("p",[e("a",{attrs:{href:"http://jsfiddle.net",target:"_blank"}},[t._v("js 在线编辑 - jsfiddle")])]),e("p",[e("a",{attrs:{href:"http://ideone.com",target:"_blank"}},[t._v("java 在线编辑 - runjs")])]),e("p",[e("a",{attrs:{href:"http://code.hcharts.cn",target:"_blank"}},[t._v("js 在线编辑 - hcharts")])]),e("p",[e("a",{attrs:{href:"http://jsdm.com",target:"_blank"}},[t._v("js 在线编辑 - jsdm")])]),e("p",[e("a",{attrs:{href:"http://sqlfiddle.com",target:"_blank"}},[t._v("sql 在线编辑 - sqlfiddle")])]),e("p",[e("a",{attrs:{href:"https://thimble.mozilla.org",target:"_blank"}},[t._v("mozilla 在线编辑器")])]),e("p",[t._v("常规优化")]),e("p",[t._v("常规优化 地址")]),e("p",[e("a",{attrs:{href:"http://www.infoq.com/cn/articles/javascript-high-performance-animation-and-page-rendering",target:"_blank"}},[t._v("Javascript高性能动画与页面渲染")])]),e("p",[e("a",{attrs:{href:"http://isux.tencent.com/h5-performance.html",target:"_blank"}},[t._v("移动H5前端性能优化指南")])]),e("p",[e("a",{attrs:{href:"http://ued.5173.com/?p=1731",target:"_blank"}},[t._v("5173首页前端性能优化实践")])]),e("p",[e("a",{attrs:{href:"http://www.uisdc.com/front-end-performance-for-web-designers-and-front-end-developers",target:"_blank"}},[t._v("给网页设计师和前端开发者看的前端性能优化")])]),e("p",[e("a",{attrs:{href:"http://www.orzpoint.com/profiling-css-and-optimization-notes",target:"_blank"}},[t._v("复杂应用的 CSS\n                    性能分析和优化建议")])]),e("p",[t._v("张鑫旭——前端性能 张鑫旭——前端性能")]),e("p",[e("a",{attrs:{href:"http://www.xiaoqiang.org/javascript/font-end-performance-monitor.html",target:"_blank"}},[t._v("前端性能监控总结")])]),e("p",[t._v("网站性能优化之CSS无图片技术 网站性能优化之CSS无图片技术")]),e("p",[t._v("web前端性能优化进阶路 web前端性能优化进阶路")]),e("p",[e("a",{attrs:{href:"http://my.eoe.cn/tuwandou/archive/4544.html",target:"_blank"}},[t._v("前端技术：网站性能优化之CSS无图片技术")])]),e("p",[e("a",{attrs:{href:"http://www.baiduux.com/blog/2011/02/15/browser-loading",target:"_blank"}},[t._v("浏览器的加载与页面性能优化")])]),e("p",[e("a",{attrs:{href:"http://www.w3ctech.com/p/1503",target:"_blank"}},[t._v("页面加载中的图片性能优化")])]),e("p",[t._v("Hey——前端性能 Hey——前端性能")]),e("p",[t._v("html优化 html优化")]),e("p",[t._v("99css——性能 99css——性能")]),e("p",[e("a",{attrs:{href:"http://www.yslow.net/category.php?cid=20",target:"_blank"}},[t._v("Yslow——性能优化")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/yslow",target:"_blank"}},[t._v("YSLOW中文介绍")])]),e("p",[e("a",{attrs:{href:"http://www.360ito.com/article/40.html",target:"_blank"}},[t._v("转一篇Yahoo关于网站性能优化的文章，兼谈本站要做的优化")])]),e("p",[e("a",{attrs:{href:"http://www.360doc.com/content/10/0928/09/2588264_56971287.shtml",target:"_blank"}},[t._v("Yahoo!团队实践分享：网站性能")])]),e("p",[e("a",{attrs:{href:"http://blog.jiasule.com/i/153",target:"_blank"}},[t._v("网站性能优化指南：什么使我们的网站变慢？")])]),e("p",[e("a",{attrs:{href:"http://www.powereasy.net/helpyou/knowledge/ecommerce/9593.html",target:"_blank"}},[t._v("网站性能优化实践，减少加载时间，提高用户体验")])]),e("p",[e("a",{attrs:{href:"http://www.umtry.com/archives/747.html",target:"_blank"}},[t._v("浅谈网站性能优化 前端篇")])]),e("p",[e("a",{attrs:{href:"http://www.adinnet.cn/blog/designview/2012-7-12/678.html",target:"_blank"}},[t._v("前端重构实践之如何对网站性能优化？")])]),e("p",[e("a",{attrs:{href:"http://www.gbin1.com/technology/javascript/20130708-front-end-performance-optimization-9",target:"_blank"}},[t._v("前端性能优化：使用媒体查询加载指定大小的背景图片")])]),e("p",[e("a",{attrs:{href:"http://www.mykuer.com/post/factors-that-affect-the-speed-of-web-site-open.html",target:"_blank"}},[t._v("网站性能系列博文")])]),e("p",[e("a",{attrs:{href:"http://tgideas.qq.com/webplat/info/news_version3/804/808/811/m579/201109/41355.shtml",target:"_blank"}},[t._v("加载，不只是少一点点")])]),e("p",[e("a",{attrs:{href:"http://mzhou.me/article/95310",target:"_blank"}},[t._v("前端性能的测试与优化")])]),e("p",[e("a",{attrs:{href:"http://www.gbin1.com/technology/html/20130217-tips-for-speed-up-page-loading",target:"_blank"}},[t._v("分享网页加载速度优化的一些技巧？")])]),e("p",[e("a",{attrs:{href:"http://www.f2es.com/images-bytes-opt",target:"_blank"}},[t._v("页面加载中的图片性能优化")])]),e("p",[e("a",{attrs:{href:"http://www.tcreator.info/webSchool/website/Front-end-Opt-Yslow.html",target:"_blank"}},[t._v("web前端优化(基于Yslow")])]),e("p",[e("a",{attrs:{href:"https://www.qianduan.net/website-performance-optimization-tool.html",target:"_blank"}},[t._v("网站性能优化工具大全")])]),e("p",[e("a",{attrs:{href:"http://www.alloyteam.com/2012/10/high-performance-html",target:"_blank"}},[t._v("【高性能前端1】高性能HTML")])]),e("p",[e("a",{attrs:{href:"http://www.alloyteam.com/2012/10/high-performance-css",target:"_blank"}},[t._v("【高性能前端2】高性能CSS")])]),e("p",[e("a",{attrs:{href:"http://coolshell.cn/articles/6470.html",target:"_blank"}},[t._v("由12306谈谈网站前端性能和后端性能优化")])]),e("p",[t._v("AlloyTeam——前端优化 AlloyTeam——前端优化")]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/developersupport/p/3248695.html",target:"_blank"}},[t._v("毫秒必争，前端网页性能最佳实践")])]),e("p",[e("a",{attrs:{href:"http://blog.sina.com.cn/s/blog_6e9d2e0701017kvu.html",target:"_blank"}},[t._v("网站性能工具Yslow的使用方法")])]),e("p",[e("a",{attrs:{href:"http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part1",target:"_blank"}},[t._v("前端工程与性能优化（上）：静态资源版本更新与缓存")])]),e("p",[e("a",{attrs:{href:"http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part2",target:"_blank"}},[t._v("前端工程与性能优化（下）：静态资源管理与模板框架")])]),e("p",[e("a",{attrs:{href:"http://blog.jobbole.com/48369",target:"_blank"}},[t._v("HTTPS连接的前几毫秒发生了什么")])]),e("p",[e("a",{attrs:{href:"http://uicss.cn/yslow/#more-12319",target:"_blank"}},[t._v("Yslow")])]),e("p",[e("a",{attrs:{href:"http://blog.smartbear.com/web-performance/essential-web-performance-metrics-a-primer-part-1",target:"_blank"}},[t._v("Essential Web Performance Metrics — A Primer, Part 1")])]),e("p",[e("a",{attrs:{href:"http://blog.smartbear.com/performance/essential-web-performance-metrics-part-2",target:"_blank"}},[t._v("Essential Web Performance Metrics — Part 2")])]),e("p",[e("a",{attrs:{href:"http://jayli.github.io/blog/data/2011/12/23/yuislide.html",target:"_blank"}},[t._v("YUISlide,针对移动设备的动画性能优化")])]),e("p",[e("a",{attrs:{href:"http://joelglovier.com/improving-site-performance",target:"_blank"}},[t._v("Improving Site Performance")])]),e("p",[e("a",{attrs:{href:"http://segmentfault.com/a/1190000000367899",target:"_blank"}},[t._v("让网站提速的最佳前端实践")])]),e("p",[e("a",{attrs:{href:"http://sixrevisions.com/web-development/why-website-speed-is-important",target:"_blank"}},[t._v("Why Website\n                    Speed is Important")])]),e("p",[e("a",{attrs:{href:"https://www.devbridge.com/articles/need-for-speed-how-to-improve-your-website-performance",target:"_blank"}},[t._v("Need for Speed – How to Improve your Website Performance")])]),e("p",[e("a",{attrs:{href:"https://github.com/amfe/article/issues/1",target:"_blank"}},[t._v("阿里无线前端性能优化指南 (Pt.1 加载期优化")])]),e("p",[t._v("优化工具")]),e("p",[t._v("优化工具 地址")]),e("p",[e("a",{attrs:{href:"http://www.html-js.com/article/3083",target:"_blank"}},[t._v("JavaScript 性能分析新工具 OneProfile")])]),e("p",[e("a",{attrs:{href:"http://www.html-js.com/article/3091",target:"_blank"}},[t._v("JavaScript 堆内存分析新工具 OneHeap")])]),e("p",[t._v("在线工具")]),e("p",[t._v("在线工具 地址")]),e("p",[e("a",{attrs:{href:"https://developers.google.com/speed/pagespeed/insights",target:"_blank"}},[t._v("google在线工具")])]),e("p",[e("a",{attrs:{href:"http://www.alibench.com",target:"_blank"}},[t._v("阿里测")])]),e("p",[e("a",{attrs:{href:"http://itest.aliyun.com",target:"_blank"}},[t._v("阿里-免费测试服务")])]),e("p",[e("a",{attrs:{href:"https://github.com/alibaba/f2etest",target:"_blank"}},[t._v("阿里-F2etest多浏览器兼容性测试解决方案")])]),e("p",[e("a",{attrs:{href:"http://jsperf.com",target:"_blank"}},[t._v("js性能测试")])]),e("p",[t._v("前端架构")]),e("p",[t._v("前端架构 地址")]),e("p",[e("a",{attrs:{href:"http://www.zhihu.com/topic/19612641",target:"_blank"}},[t._v("技术架构")])]),e("p",[e("a",{attrs:{href:"http://saito.im/note/The-Architecture-of-F2E",target:"_blank"}},[t._v("前端架构")])]),e("p",[e("a",{attrs:{href:"http://www.zhihu.com/question/24092572",target:"_blank"}},[t._v("如何成为前端架构师")])]),e("p",[e("a",{attrs:{href:"http://hikejun.com/sharing/2010webrebuild/?file=fe-infrastructure.html",target:"_blank"}},[t._v("关于前端架构-张克军")])]),e("p",[e("a",{attrs:{href:"http://www.zhihu.com/question/25583350",target:"_blank"}},[t._v("百度腾讯offer比较（腾讯游戏VS百度基础架构）")])]),e("p",[t._v("推荐作品")]),e("p",[t._v("推荐作品 地址")]),e("p",[e("a",{attrs:{href:"https://gist.github.com/wintercn",target:"_blank"}},[t._v("winter代码片段需要FQ")])]),e("p",[e("a",{attrs:{href:"http://www.fgm.cc/learn",target:"_blank"}},[t._v("fgm")])]),e("p",[e("a",{attrs:{href:"https://github.com/hongru/hongru.github.com",target:"_blank"}},[t._v("岑安作品集")])]),e("p",[e("a",{attrs:{href:"http://kmdjs.github.io",target:"_blank"}},[t._v("当耐特demo集合")])]),e("p",[e("a",{attrs:{href:"http://www.laoshu133.com/Lab",target:"_blank"}},[t._v("米空格 js作品")])]),e("p",[e("a",{attrs:{href:"http://koen301.github.io",target:"_blank"}},[t._v("myFocus")])]),e("p",[e("a",{attrs:{href:"http://panxuepeng.github.io/seajslib",target:"_blank"}},[t._v("SeaJS组件库")])]),e("p",[e("a",{attrs:{href:"http://yanhaijing.com/myProject",target:"_blank"}},[t._v("颜海镜作品")])]),e("p",[e("a",{attrs:{href:"http://jo2.org/category/myworks",target:"_blank"}},[t._v("脚儿网作品")])]),e("p",[e("a",{attrs:{href:"http://www.cnitblog.com/yemoo/category/3107.html",target:"_blank"}},[t._v("javascript个人作品")])]),e("p",[e("a",{attrs:{href:"http://bbs.miaov.com/forum.php?mod=viewthread&tid=7790",target:"_blank"}},[t._v("妙味的雷东升游戏作品")])]),e("p",[e("a",{attrs:{href:"http://bbs.csdn.net/topics/380227212",target:"_blank"}},[t._v("javascript作品集")])]),e("p",[e("a",{attrs:{href:"https://github.com/TooBug/works",target:"_blank"}},[t._v("云五笔，灰度产生生成工具")])]),e("p",[e("a",{attrs:{href:"http://koen301.github.io",target:"_blank"}},[t._v("项目主页")])]),e("p",[e("a",{attrs:{href:"http://zaole.net",target:"_blank"}},[t._v("个性的作品主页")])]),e("p",[e("a",{attrs:{href:"http://static.tingall.com/v2/player",target:"_blank"}},[t._v("播放器")])]),e("p",[e("a",{attrs:{href:"http://ucren.com/blog/demos",target:"_blank"}},[t._v("ucren js demos 集")])]),e("p",[e("a",{attrs:{href:"http://www.zhinengshe.com/works_list.html",target:"_blank"}},[t._v("智能社")])]),e("p",[e("a",{attrs:{href:"http://demos.shizuwu.cn",target:"_blank"}},[t._v("实例陈列架")])]),e("p",[e("a",{attrs:{href:"http://zoye.sinaapp.com/demo",target:"_blank"}},[t._v("zoye demo")])]),e("p",[e("a",{attrs:{href:"http://lab.yuanwai.wang",target:"_blank"}},[t._v("王员外")])]),e("p",[e("a",{attrs:{href:"http://pingfan1990.sinaapp.com",target:"_blank"}},[t._v("平凡")])]),e("p",[e("a",{attrs:{href:"http://www.lovewebgames.com",target:"_blank"}},[t._v("jyg 游戏案例")])]),e("p",[e("a",{attrs:{href:"http://www.helloweba.com/list.html",target:"_blank"}},[t._v("很多jquery插件")])]),e("p",[e("a",{attrs:{href:"http://www.bujichong.com/sojs/api/index.html",target:"_blank"}},[t._v("不羁虫 - soJs 作品系列")])]),e("p",[e("a",{attrs:{href:"http://frozenui.github.io/case.html",target:"_blank"}},[t._v("frozenui")])]),e("p",[e("a",{attrs:{href:"http://js-game.github.io/othello",target:"_blank"}},[t._v("黑白棋")])]),e("p",[e("a",{attrs:{href:"http://yansm.github.io/fromone/index.html",target:"_blank"}},[t._v("fromone")])]),e("p",[e("a",{attrs:{href:"http://pazguille.me",target:"_blank"}},[t._v("pazguille")])]),e("p",[e("a",{attrs:{href:"https://github.com/zmmbreeze/DeadSimpleVideoPlayer",target:"_blank"}},[t._v("Html5 VideoPlayer")])]),e("p",[e("a",{attrs:{href:"http://a-jie.github.io/Proton/#example",target:"_blank"}},[t._v("Proton 烟花")])]),e("p",[t._v("简历模板")]),e("p",[t._v("简历模板 地址")]),e("p",[e("a",{attrs:{href:"http://learnshare.github.io/about/index.html",target:"_blank"}},[t._v("不错的个人简历")])]),e("p",[e("a",{attrs:{href:"http://hcy2367.github.io/resume",target:"_blank"}},[t._v("简历")])]),e("p",[e("a",{attrs:{href:"http://ncuey.sinaapp.com/CrispElite/",target:"_blank"}},[t._v("张伦")])]),e("p",[e("a",{attrs:{href:"https://github.com/hacke2/ResumeSample",target:"_blank"}},[t._v("简历")])]),e("p",[e("a",{attrs:{href:"http://blog.dandyweng.com/2013/07/how-my-website-was-created",target:"_blank"}},[t._v("翁天信")])]),e("p",[e("a",{attrs:{href:"http://www.webhek.com/misc/interactive-resume",target:"_blank"}},[t._v("动画方式的简历")])]),e("p",[e("a",{attrs:{href:"http://www.linqing07.com/resume.html",target:"_blank"}},[t._v("组件丰富简历")])]),e("p",[e("a",{attrs:{href:"http://www.mojianli.com/resume/view",target:"_blank"}},[t._v("简历池")])]),e("p",[e("a",{attrs:{href:"http://www.haorooms.com/about",target:"_blank"}},[t._v("haorooms博客")])]),e("p",[e("a",{attrs:{href:"http://cv.youngdze.com",target:"_blank"}},[t._v("Justin Young")])]),e("p",[t._v("面试题")]),e("p",[t._v("面试题 地址")]),e("p",[e("a",{attrs:{href:"http://www.nowcoder.com/discuss/3196",target:"_blank"}},[t._v("那几个月在找工作（百度，网易游戏）")])]),e("p",[e("a",{attrs:{href:"http://www.html-js.com/article/1743",target:"_blank"}},[t._v("2014最新面试题")])]),e("p",[e("a",{attrs:{href:"http://www.w3cfuns.com/thread-5598563-2-1.html",target:"_blank"}},[t._v("阿里前端面试题")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/imwtr/p/4685546.html",target:"_blank"}},[t._v("2016校招内推 -- 阿里巴巴前端 -- 三面面试经历")])]),e("p",[e("a",{attrs:{href:"http://www.w3cfuns.com/article-5599657-1-1.html",target:"_blank"}},[t._v("腾讯面试题")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/lvdabao/p/3660707.html",target:"_blank"}},[t._v("年后跳槽那点事：乐视+金山+360面试之行")])]),e("p",[e("a",{attrs:{href:"http://fatesinger.com/2722.html",target:"_blank"}},[t._v("阿里前端面试题上线")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/52cik/p/js-question-lg.html",target:"_blank"}},[t._v("拉勾网js面试题")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/allenxing/p/3724382.html",target:"_blank"}},[t._v("前端面试")])]),e("p",[e("a",{attrs:{href:"http://mianshiti.diandian.com",target:"_blank"}},[t._v("Web开发笔试面试题 大全")])]),e("p",[e("a",{attrs:{href:"http://segmentfault.com/a/1190000000465431",target:"_blank"}},[t._v("前端开发面试题")])]),e("p",[e("a",{attrs:{href:"https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions",target:"_blank"}},[t._v("2014最新前端面试题")])]),e("p",[e("a",{attrs:{href:"https://github.com/fex-team/interview-questions",target:"_blank"}},[t._v("百度面试")])]),e("p",[e("a",{attrs:{href:"http://www.w3cfuns.com/forum.php?mod=forumdisplay&fid=51&filter=typeid&typeid=177",target:"_blank"}},[t._v("面试题")])]),e("p",[e("a",{attrs:{href:"https://github.com/darcyclarke/Front-end-Developer-Interview-Questions/tree/master/Chinese",target:"_blank"}},[t._v("前端工作面试问题")])]),e("p",[e("a",{attrs:{href:"http://segmentfault.com/a/1190000000465431",target:"_blank"}},[t._v("前端开发面试题")])]),e("p",[t._v("5个经典的前端面试问题 5个经典的前端面试问题")]),e("p",[e("a",{attrs:{href:"http://segmentfault.com/a/1190000002562454",target:"_blank"}},[t._v("最全前端面试问题及答案总结")])]),e("p",[e("a",{attrs:{href:"http://www.html-js.com/article/Large-search-front-team-column%202961",target:"_blank"}},[t._v("如何面试一名前端开发工程师？")])]),e("p",[e("a",{attrs:{href:"https://github.com/hawx1993/Front-end-Interview-questions",target:"_blank"}},[t._v("史上最全 前端开发面试问题及答案整理")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/xiaoruo/p/4665163.html",target:"_blank"}},[t._v("前端实习生面试总结")])]),e("p",[e("a",{attrs:{href:"https://github.com/hawx1993/Front-end-Interview-questions",target:"_blank"}},[t._v("史上最全 前端开发面试问题及答案整理")])]),e("p",[e("a",{attrs:{href:"http://blog.jobbole.com/78738",target:"_blank"}},[t._v("BAT及各大互联网公司2014前端笔试面试题：JavaScript篇")])]),e("p",[e("a",{attrs:{href:"https://github.com/paddingme/Front-end-Web-Development-Interview-Question",target:"_blank"}},[t._v("前端开发面试题大收集")])]),e("p",[e("a",{attrs:{href:"https://github.com/qiu-deqing/FE-interview",target:"_blank"}},[t._v("收集的前端面试题和答案")])]),e("p",[e("a",{attrs:{href:"http://www.zhihu.com/question/19568008",target:"_blank"}},[t._v("如何面试前端工程师")])]),e("p",[e("a",{attrs:{href:"https://github.com/markyun/My-blog/blob/master/Front-end-Developer-Questions/Questions-and-Answers/README.md",target:"_blank"}},[t._v("前端开发面试题")])]),e("p",[e("a",{attrs:{href:"http://www.nowcoder.com/discuss?type=2",target:"_blank"}},[t._v("牛客网-笔试面经")])]),e("p",[t._v("iconfont")]),e("p",[t._v("iconfont 地址")]),e("p",[e("a",{attrs:{href:"http://www.zhihu.com/question/21253343",target:"_blank"}},[t._v("中文字体")])]),e("p",[e("a",{attrs:{href:"http://iconfont.cn",target:"_blank"}},[t._v("淘宝字库")])]),e("p",[e("a",{attrs:{href:"http://mux.alimama.com/fonts",target:"_blank"}},[t._v("字体")])]),e("p",[e("a",{attrs:{href:"http://iconfont.cn/help/platform.html",target:"_blank"}},[t._v("制作教程")])]),e("p",[e("a",{attrs:{href:"http://www.zhangxinxu.com/wordpress/?s=icomoon",target:"_blank"}},[t._v("zhangxinxu-icommon")])]),e("p",[e("a",{attrs:{href:"https://icomoon.io/app",target:"_blank"}},[t._v("icommon")])]),e("p",[e("a",{attrs:{href:"http://imooc.com/learn/243",target:"_blank"}},[t._v("用字体在网页中画ICON图标(推荐教程")])]),e("p",[e("a",{attrs:{href:"http://font-spider.org",target:"_blank"}},[t._v("字体压缩工具")])]),e("p",[t._v("Fiddler")]),e("p",[t._v("Fiddler 地址")]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/tugenhua0707/p/4623317.html",target:"_blank"}},[t._v("Fiddler调式使用知多少(一深入研究")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/strick/p/4570006.html",target:"_blank"}},[t._v("微信fiddle")])]),e("p",[e("a",{attrs:{href:"http://gaoboy.com/article/26.html",target:"_blank"}},[t._v("微信fiddle")])]),e("p",[t._v("Chrome")]),e("p",[t._v("Chrome 地址")]),e("p",[e("a",{attrs:{href:"https://developer.chrome.com/devtools",target:"_blank"}},[t._v("Google Chrome 官方")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/constantince/p/4565261.html",target:"_blank"}},[t._v("Chrome - 基础")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/constantince/p/4579121.html",target:"_blank"}},[t._v("Chrome - 进阶")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/constantince/p/4585983.html",target:"_blank"}},[t._v("Chrome - 性能")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/constantince/p/4607497.html",target:"_blank"}},[t._v("Chrome - 性能进阶")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/constantince/p/4624241.html",target:"_blank"}},[t._v("Chrome - 移动")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/liyunhua/p/4544738.html",target:"_blank"}},[t._v("Chrome - 使用技巧")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/Wayou/p/chrome-console-tips-and-tricks.html",target:"_blank"}},[t._v("Chrome -\n                    Console控制台不完全指南")])]),e("p",[e("a",{attrs:{href:"http://c7sky.com/chrome-devtools-workspace.html",target:"_blank"}},[t._v("Chrome - Workspace使浏览器变成IDE")])]),e("p",[e("a",{attrs:{href:"http://www.html-js.com/article/Nothing-blind%202975",target:"_blank"}},[t._v("network面板")])]),e("p",[e("a",{attrs:{href:"http://anti-code.com/devtools-cheatsheet",target:"_blank"}},[t._v("chrome开发工具快捷键")])]),e("p",[e("a",{attrs:{href:"http://www.html-js.com/article/2327",target:"_blank"}},[t._v("chrome调试工具常用功能整理")])]),e("p",[e("a",{attrs:{href:"http://www.iinterest.net/2014/05/09/chrome-dev-tool-workspace",target:"_blank"}},[t._v("Chrome 开发工具 Workspace\n                    使用")])]),e("p",[e("a",{attrs:{href:"http://www.cppblog.com/deercoder/archive/2011/10/22/158886.html",target:"_blank"}},[t._v("Chrome神器Vimium快捷键学习记录")])]),e("p",[e("a",{attrs:{href:"http://www.w3cplus.com/sassguide/debug.html",target:"_blank"}},[t._v("sass调试-w3cplus")])]),e("p",[e("a",{attrs:{href:"http://www.w3cplus.com/tools/how-to-use-chrome-devtools-like-a-pro.html",target:"_blank"}},[t._v("如何更专业的使用Chrome开发者工具-w3cplus")])]),e("p",[e("a",{attrs:{href:"http://sentsin.com/web/253.html",target:"_blank"}},[t._v("chrome调试canvas")])]),e("p",[e("a",{attrs:{href:"https://developer.chrome.com/devtools/index",target:"_blank"}},[t._v("chrome profiles1")])]),e("p",[e("a",{attrs:{href:"http://h5dev.uc.cn/article-25-1.html",target:"_blank"}},[t._v("chrome profiles2")])]),e("p",[e("a",{attrs:{href:"http://www.oschina.net/translate/performance-optimisation-with-timeline-profiles",target:"_blank"}},[t._v("chrome profiles3")])]),e("p",[e("a",{attrs:{href:"https://developer.chrome.com/devtools/docs/mobile-emulation",target:"_blank"}},[t._v("chrome移动版调试")])]),e("p",[e("a",{attrs:{href:"http://ued.taobao.org/blog/2012/06/debug-with-chrome-dev-tool",target:"_blank"}},[t._v("chrome调试")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/QLeelulu/archive/2011/08/28/2156402.html",target:"_blank"}},[t._v("chrome的调试")])]),e("p",[e("a",{attrs:{href:"https://developer.chrome.com/devtools/docs/commandline-api",target:"_blank"}},[t._v("chrome console 命令详解")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/leonkao/p/3809655.html",target:"_blank"}},[t._v("查看事件绑定1")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/xiaoyao2011/p/3447421.html",target:"_blank"}},[t._v("查看事件绑定2")])]),e("p",[e("a",{attrs:{href:"http://segmentfault.com/a/1190000000683599",target:"_blank"}},[t._v("神器——Chrome开发者工具(一")])]),e("p",[e("a",{attrs:{href:"https://xinranliu.me/2015-05-22-qiqu-performance",target:"_blank"}},[t._v("奇趣百科性能优化(Chrome DevTools 中的\n                    Timeline Profils 等工具使用介绍")])]),e("p",[e("a",{attrs:{href:"http://frontenddev.org/link/15-tips-of-chrome-developer-tools.html",target:"_blank"}},[t._v("chrome 开发者工具的 15\n                    个小技巧")])]),e("p",[e("a",{attrs:{href:"http://1ke.co/course/361",target:"_blank"}},[t._v("Chrome开发者工具不完全指南")])]),e("p",[e("a",{attrs:{href:"http://segmentfault.com/a/1190000003882567",target:"_blank"}},[t._v("Chrome 开发者工具使用技巧")])]),e("p",[t._v("Firebug")]),e("p",[t._v("Firebug 地址")]),e("p",[e("a",{attrs:{href:"http://www.imooc.com/learn/137",target:"_blank"}},[t._v("firebug视频教程")])]),e("p",[e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Tools/WebIDE",target:"_blank"}},[t._v("firefox 模拟器")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/ctriphire/p/4116207.html",target:"_blank"}},[t._v("console.log 命令详解")])]),e("p",[e("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2008/06/firebug_tutorial.html",target:"_blank"}},[t._v("Firebug入门指南")])]),e("p",[e("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2011/03/firebug_console_tutorial.html",target:"_blank"}},[t._v("Firebug控制台详解")])]),e("p",[t._v("移动,微信调试")]),e("p",[t._v("移动,微信调试 地址")]),e("p",[e("a",{attrs:{href:"https://openstf.github.io",target:"_blank"}},[t._v("浏览器端调试安卓")])]),e("p",[e("a",{attrs:{href:"http://yujiangshui.com/multidevice-frontend-debug",target:"_blank"}},[t._v("移动端前端开发调试")])]),e("p",[e("a",{attrs:{href:"https://github.com/yujiangshui/CN-Chrome-DevTools/blob/remote-debugging/md/Use-Tools/remote-debugging.md",target:"_blank"}},[t._v("使用 Chrome 远程调试 Android 设备")])]),e("p",[e("a",{attrs:{href:"http://plus.uc.cn/document/webapp/doc5.html",target:"_blank"}},[t._v("mac移动端调试")])]),e("p",[e("a",{attrs:{href:"http://www.mihtool.com",target:"_blank"}},[t._v("mac移动端调试")])]),e("p",[e("a",{attrs:{href:"http://thx.github.io/mobile/debugging-in-mobile",target:"_blank"}},[t._v("无线调试攻略")])]),e("p",[e("a",{attrs:{href:"http://yanhaijing.com/mobile/2014/12/17/web-debug-for-mobile",target:"_blank"}},[t._v("无线调试攻略")])]),e("p",[e("a",{attrs:{href:"http://www.jianshu.com/p/ccf124f1f74b",target:"_blank"}},[t._v("屌爆了,完美调试 微信webview(x5")])]),e("p",[t._v("微信调试的那些事 微信调试的那些事")]),e("p",[e("a",{attrs:{href:"http://jsconsole.com",target:"_blank"}},[t._v("远程console")])]),e("p",[e("a",{attrs:{href:"http://blog.qqbrowser.cc",target:"_blank"}},[t._v("微信调试工具")])]),e("p",[e("a",{attrs:{href:"https://github.com/jieyou/remote_inspect_web_on_real_device",target:"_blank"}},[t._v("各种真机远程调试方法汇总")])]),e("p",[t._v("iOS Simulator")]),e("p",[t._v("iOS Simulator 地址")]),e("p",[t._v("Simulator iOS_Simulator_Guide-Introduction")]),e("p",[e("a",{attrs:{href:"http://www.crifan.com/intro_ios_simulator_in_xcode_and_usage_summary",target:"_blank"}},[t._v("iOS\n                    Simulator的介绍和使用心得")])]),e("p",[t._v("img")]),e("p",[t._v("img 地址")]),e("p",[e("a",{attrs:{href:"http://preloaders.net/en/circular",target:"_blank"}},[t._v("loading img")])]),e("p",[e("a",{attrs:{href:"http://zhitu.isux.us",target:"_blank"}},[t._v("智图-图片优化平台")])]),e("p",[e("a",{attrs:{href:"https://tinypng.com",target:"_blank"}},[t._v("在线png优化")])]),e("p",[t._v("生成二维码")]),e("p",[t._v("生成二维码 地址")]),e("p",[e("a",{attrs:{href:"http://cli.im",target:"_blank"}},[t._v("生成二维码")])]),e("p",[t._v("浏览器同步")]),e("p",[t._v("浏览器同步 地址")]),e("p",[e("a",{attrs:{href:"https://github.com/leeluolee/puer",target:"_blank"}},[t._v("puer")])]),e("p",[e("a",{attrs:{href:"http://livereload.com",target:"_blank"}},[t._v("liveReload")])]),e("p",[e("a",{attrs:{href:"http://getf5.com",target:"_blank"}},[t._v("f5")])]),e("p",[e("a",{attrs:{href:"http://geek100.com/2608",target:"_blank"}},[t._v("File Watchers")])]),e("p",[t._v("在线PPT制作")]),e("p",[t._v("在线PPT制作 地址")]),e("p",[t._v("nodePPT nodePPT")]),e("p",[e("a",{attrs:{href:"http://www.jeffjade.com/2015/10/15/2015-10-16-cleaver-make-ppt/",target:"_blank"}},[t._v("Cleaver快速制作网页PPT")])]),e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/Darren_code/archive/2013/01/04/impressjs.html",target:"_blank"}},[t._v("impress.js")])]),e("p",[e("a",{attrs:{href:"https://github.com/ksky521/nodePPT",target:"_blank"}},[t._v("PPT")])]),e("p",[e("a",{attrs:{href:"https://github.com/hakimel/reveal.js",target:"_blank"}},[t._v("reveal")])]),e("p",[e("a",{attrs:{href:"https://github.com/Seldaek/slippy",target:"_blank"}},[t._v("slippy")])]),e("p",[t._v("前端导航网站")]),e("p",[t._v("前端导航网站 地址")]),e("p",[e("a",{attrs:{href:"http://uxbees.com/index.html",target:"_blank"}},[t._v("界面清爽的前端导航")])]),e("p",[e("a",{attrs:{href:"http://whycss.com",target:"_blank"}},[t._v("前端导航")])]),e("p",[e("a",{attrs:{href:"http://www.daqianduan.com/nav",target:"_blank"}},[t._v("前端网址导航")])]),e("p",[e("a",{attrs:{href:"http://sentsin.com/daohang",target:"_blank"}},[t._v("前端名录")])]),e("p",[e("a",{attrs:{href:"http://123.jser.us",target:"_blank"}},[t._v("前端导航")])]),e("p",[e("a",{attrs:{href:"http://www.css88.com/nav",target:"_blank"}},[t._v("前端开发资源")])]),e("p",[e("a",{attrs:{href:"http://www.haourl.cn",target:"_blank"}},[t._v("网址导航")])]),e("p",[e("a",{attrs:{href:"http://code.ciaoca.com",target:"_blank"}},[t._v("前端开发仓库 - 众多效果的收集地")])]),e("p",[e("a",{attrs:{href:"https://github.com/jnoodle/f2e-collect",target:"_blank"}},[t._v("前端资源导航")])]),e("p",[e("a",{attrs:{href:"http://f2e.im/static/pages/nav/index.html",target:"_blank"}},[t._v("F2E 前端导航")])]),e("p",[t._v("常用CDN")])])}],Z={},tt=Z,nt=(e("1651"),Object(p["a"])(tt,Y,K,!1,null,"66618e5c",null)),et=nt.exports,at={components:{m1:u,m2:h,m3:C,m4:M,m5:$,m6:F,m7:Q,m8:et},data:function(){return{tab:"m1",tabs:[{label:"node",value:"m1"},{label:"全栈项目 依赖",value:"m2"}]}}},rt=at,st=Object(p["a"])(rt,a,r,!1,null,"5a91dfbd",null);n["default"]=st.exports},cb77:function(t,n,e){"use strict";var a=e("e4d8"),r=e.n(a);r.a},e4d8:function(t,n,e){},e516:function(t,n,e){"use strict";e.r(n);var a=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+t.value,label:n+1+"."+t.label}})})),1),e("div",{staticClass:"q-mx-lg"},[e(""+t.tab,{tag:"component"})],1)],1)},r=[],s=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},o=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("div",[e("p",[t._v("\n\n打开终端：ctrl+alt+t"),e("br"),t._v("\n清屏：ctrl+l"),e("br"),t._v("\n在终端在退出锁定：ctrl+c"),e("br"),e("br"),e("br"),t._v("\n目录：又称为文件夹，是包含所有的文件"),e("br"),t._v("\n目录创建规则："),e("br"),t._v("\n1、大小是256"),e("br"),t._v("\n2、不能包含特殊字符"),e("br"),t._v("\n3、见名知义 "),e("br"),t._v("\n路径：是反应目录和文件的位置"),e("br"),t._v("\n[绝对位置]文件位置：windows：盘符：\\文件夹\\文件.avi"),e("br"),t._v("\n\t linux: /home/主文件夹/0520/day01/a"),e("br"),e("br"),t._v("\n[相对位置]当前目录所在位置为 0520 ./day01/a "),e("br"),t._v("\n\t\tday03 ../day01/a"),e("br"),e("br"),t._v("\n\t.\\c...\\01jibi\\biji.txt"),e("br"),t._v("\n\t..\\c...\\01biji\\biji.txt"),e("br"),e("br"),e("br"),t._v("\n文件：在计算机中一切皆文件 "),e("br"),t._v("\n在windows中区分文件可以通过扩展名来区分 .exe .txt .ppt"),e("br"),t._v("\n在Linux中文件没有扩展名 可以通过颜色区分 也可以通过命令来区分 file 文件名"),e("br"),e("br"),t._v("\n在Linux中文件分为："),e("br"),t._v("\n普通文件"),e("br"),t._v("\n目录文件"),e("br"),t._v("\n设备文件   字符设备文件 块设备文件"),e("br"),t._v("\n管道文件"),e("br"),t._v("\n链接文件"),e("br"),e("br"),t._v("\n文件权限："),e("br"),t._v("\n读【r】read"),e("br"),t._v("\n写【w】write"),e("br"),t._v("\n执行【x】execute"),e("br"),e("br"),t._v("\nd rwx rwx rwx 分为三组"),e("br"),t._v("\nd 目录 成为文件类型"),e("br"),t._v("\n第一组：文件的所属用户"),e("br"),t._v("\n第二组：文件的所属组"),e("br"),t._v("\n第三组：其他用户"),e("br"),e("br"),t._v("\nLinux命令："),e("br"),t._v("\n格式 ：命令 选项  参数 "),e("br"),e("br"),t._v("\n帮助："),e("br"),t._v("\n命令 --help"),e("br"),t._v("\nman 命令"),e("br"),e("br"),t._v("\n快捷键："),e("br"),t._v("\ntab 智能补全   如果没有重复的选项 自动补全 如果有重复项 按两下tab 显示列表"),e("br"),t._v("\n↑ ↓ 历史记录 查看之前敲过的命令 关闭后还会提示 但是同时打开两个终端 相互不会提示"),e("br"),e("br"),t._v("\n常用命令："),e("br"),t._v("\nls 【查看文件】"),e("br"),t._v("\n格式："),e("br"),t._v("\nls -a 查看所有文件包含隐藏文件"),e("br"),t._v("\nls -l 以列表形式查看文件，不包含隐藏文件"),e("br"),t._v("\nls -lh 以列表形式查看文件，不包含隐藏文件 ，按照1024倍数显示{KB MB GB}"),e("br"),t._v("\nls -all以列表形式查看文件，包含隐藏文件 快捷方式【ll】"),e("br"),e("br"),t._v("\n通配符："),e("br"),t._v("\n【*】 匹配任意多个字符【0-256】  a*  一个以上字符 256一下 "),e("br"),t._v("\n【?】 匹配任意一个字符  a？ 两个字符"),e("br"),t._v("\n【[a-z]】 区间法 匹配a到z的所有字符 只能确定一个字符"),e("br"),t._v("\n【[abcde]】 穷举法 权值法 匹配abcde的所有字符 只能确定一个字符"),e("br"),e("br"),e("br"),t._v("\n切换工作目录："),e("br"),t._v("\ncd 【切换工作目录】cd 目录"),e("br"),t._v("\n格式："),e("br"),t._v("\ncd 切换到用户主目录"),e("br"),t._v("\ncd ~ 切换到当前用户的主目录"),e("br"),t._v("\ncd .. 切换到上级目录 "),e("br"),t._v("\ncd .  切换到当前目录"),e("br"),t._v("\ncd -  切换到上一次目录"),e("br"),e("br"),e("br"),t._v("\n创建目录："),e("br"),t._v("\nmkdir 目录名 -p 递归创建"),e("br"),t._v("\nrmdir 目录名  目录一定是空的"),e("br"),t._v("\nrm 文件  -i询问 -r 递归传出"),e("br"),e("br"),e("br"),t._v("\n链接："),e("br"),t._v("\n格式："),e("br"),t._v("\nln 源文件 链接文件 硬链接"),e("br"),t._v("\nln -s 源文件 链接文件 软连接"),e("br"),t._v("\n硬链接文件占磁盘空间 但是删除源文件不会影响硬链接文件"),e("br"),t._v("\n软链接文件不占磁盘空间 但是删除源文件会影响软链接文件"),e("br"),e("br"),t._v("\n硬链接和拷贝（复制）区别 无论你修改了哪一个链接之后的文件 两个文件都会改变 保持一致  但是拷贝不会"),e("br"),t._v("\n1、改变软链接文件就是相当于间接的改变了源文件"),e("br"),t._v("\n2、查看文件时默认链接数为1 如果有链接一次递增"),e("br"),t._v("\n3、如果创建的软链接文件和源文件在不同的目录下，需要使用绝对路径"),e("br"),e("br"),e("br"),t._v("\n文本搜索："),e("br"),t._v("\ngrep  '搜索内容' 文件名"),e("br"),t._v("\n-n 显示行号"),e("br"),t._v("\n-v 反选"),e("br"),t._v("\n-i 忽略大小写"),e("br"),e("br"),t._v("\n通配符："),e("br"),t._v("\n【^a】以a为起始的字符搜索文件"),e("br"),t._v("\n【a$】以a为结尾的字符搜索文件"),e("br"),t._v("\n【.】 配匹任意一个非换行的字符"),e("br"),t._v("\n【*】匹配任意字符（大于0的整数）"),e("br"),e("br"),t._v("\n文件搜索："),e("br"),t._v("\nfind 目录 参数 文件名（可以使用通配符）"),e("br"),t._v("\n-name 文件名"),e("br"),t._v("\n-size 大小"),e("br"),t._v("\n-perm rwx"),e("br"),e("br"),e("br"),t._v("\n归档："),e("br"),t._v("\ntar -cvf 归档文件名.tar 文件1 文件2  目录1 目录2"),e("br"),t._v("\n解归档："),e("br"),t._v("\ntar -xvf 归档文件名.tar  -C 路径"),e("br"),e("br"),t._v("\n压缩："),e("br"),t._v("\ngzip 归档文件名.tar  生成了一个文件 归档文件名.tar.gz 文件大小小于归档文件大小 归档文件名.tar不存在了"),e("br"),t._v("\n解压缩："),e("br"),t._v("\ngzip -d 归档文件名.tar.gz 生成了一个文件 归档文件名.tar"),e("br"),e("br"),e("br"),t._v("\n一步归档压缩："),e("br"),t._v("\ntar -czvf 文件名.tar.gz 文件1 文件2 目录1 目录2"),e("br"),e("br"),t._v("\n一步解归档压缩："),e("br"),t._v("\ntar -xzvf 文件名.tar.gz -C 路径"),e("br"),e("br"),t._v("\nbzip2压缩："),e("br"),t._v("\ntar -cjvf 文件名.tar.bz2 文件1 文件2 目录1 目录2"),e("br"),t._v("\nbzip2解压缩："),e("br"),t._v("\ntar -xjvf 文件名.tar.bz2 -C 路径"),e("br"),e("br"),t._v("\nzip压缩："),e("br"),t._v("\nzip 文件名 文件1 文件2 目录1 目录2  生成一个文件为：文件名.zip"),e("br"),t._v("\nunzip解压缩："),e("br"),t._v("\nunzip 文件名.zip -C 路径"),e("br"),e("br")])]),e("div",[e("img",{attrs:{src:"statics/linux/01_Linux介绍和基本操作.pngv",alt:"",srcset:""}})])])}],l={},i=l,c=e("2877"),p=Object(c["a"])(i,s,o,!1,null,"52dc25f3",null),b=p.exports,u=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},v=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("pre",[t._v('         用户权限：\nsu 切换用户账户\n格式：\n【su 用户名 】\n【su】 切换到root\n【su root】 切换到root\n【su -】 切换到root用户 同时切换到root目录\n\n添加组：\n【groupadd 组名】  添加组  需要用户权限\n删除组\n【groupdel 组名】  删除组  需要用户权限和清空组成员\n修改用户所在组：\n【usermod -g 组名 用户名1 用户名2】需要用户权限\n\n添加用户：\n【useradd -d /home/目录 用户名 -g 组名 -m】新建用户 设置用户主目录和设置组名 并自动创建  需要用户权限\n\n设置密码：\n【passwd 用户名】设置密码 需要用户权限\n\n删除用户：\n【userdel -r 用户名】 删除用户递归删除该用户所有文件 需要用户权限\n\n修改文件权限：\n字符法格式：【chmod -u|g|o|a +|- rwc 文件1 文件2】\nd rwx r-x r-x\nu user +|- rwx\ng group +|- rwx\no other +|- rwx\na all +|- rwx\nchmod u + x\n数字法格式：\n r w x\n 0 0 0  ---  0\n 0 0 1  --x  1\n 0 1 0  -w-  2\n 0 1 1  -wx  3\n 1 0 0  r--  4\n 1 0 1  r-x  5\n 1 1 0  rw-  6\n 1 1 1  rwx  7\n\n\n【chmod 372 文件名1 文件名2】\n\nrwx rwx rwx\n421 421 421\n\nrw- r-x r--\n\n-wx rwx -w-\n\nr--------\n\nrw- rw- r--\nchmod 6 6 4  a.txt\n\n\n修改文件所有者：\n【chown 用户名 文件1 文件2 目录1 目录2】需要用户权限\n修改文件组：\n【chgrp 组名 文件1 文件2 目录1 目录2】需要用户权限\n\n\n编辑器：\nVI编辑器有两个模式：文本编辑模式 命令行处理模式\n进入编辑器：\n1、vi 文件名  2、vim \n操作编辑器：\n【i】在光标当前位置插入\n【a】在光标右侧位置插入\n【o】在光标下一行位置开启新的一行插入\n【O】在光标上一行位置开启新的一行插入\n【I】在光标当前行行首插入\n【A】在光标当前行行尾插入\n\n退出编辑器：\n【ZZ】保存退出\n【:wq】保存退出\n【:x】保存退出\n【:w 文件名】保存到指定文件中\n【:q】 保存退出 针对未修改的文件 注意：未保存文件会提示 无法退出\n【:q!】 强制退出  退出 不保存\n【:! 命令】暂时离开vi 执行其他命令\n\n案例：\n打开vi  源文件.c\n进入插入模式 \n#include stdio.h\n\nint main(void)\n{\n\tprintf("hello world!\\n");\n\treturn 0;\n}\n退出保存\n\n编译程序\ngcc -o 可执行程序  源文件.c\n\n./可执行程序\n\n编辑器操作：\n【[n]x】删除光标位置后面n个字符\n【[n]X】删除光标位置前面n个字符\n【D】删除光标所在位置后面到行尾的所有字符\n【[n]dd】删除光标所在行及下面n行   剪切\n【p】在光标下一行粘贴\n【[n]yy】复制光标所在行及下面n行 \n【dG】删除光标所在行到文件结尾\n【J】合并光标所在行和下一行 中间用空格连接\n【.】执行上一次命令行操作\n【u】撤销\n\n\n编辑器定位：\n【ctrl+b】回滚 行号减小\n【ctrl+f】前滚 行号增加\n【gg】定位在文件第一行行首\n【G】定位在文件最后一行行首\n【:$】定位在文件最后一行行首\n【[n]G | [n]gg】定位在m行\n注意：在查找一些特殊含义的字符时，需要加上转义字符\n【/内容】查找\n【n】查找下一个\n【N】查找上一个\n【?】查找上一次的所搜内容\n【/^word】 查找以word开头的内容\n【/word$】 查找以word结尾的内容\n【/.】查找任意一个字符\n【/*】查找任意多个字符\n\n编辑器替换：\n【r】替换光标所在位置的字符\n【:r 文件名】在光标当前行的下一行插入一个文件 每次添加只能添加一个文件\n【:s/a/b/g】将光标所在行的a替换为b\n【:g/a/s//b/g】将文件中所有a替换为b\n【:n1,n2s/a/b/g】将行区间n1到n2的行中所有的a替换为b\n\n编辑器设置：\n【:set ic】搜索时不区分大小写\n【:set noic】搜索时区分大小写\n\n\n     ')])])}],g={},m=g,_=Object(c["a"])(m,u,v,!1,null,"654313e9",null),d=_.exports,h=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},f=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("div",[t._v("  使用 Linux 服务器集群管理面板   appnode 类似的 工具 可以快速 部署 ")]),e("div",[t._v("yum -y install epel-release ")]),e("div",[t._v("yum -y install nginx ")]),e("pre",[t._v("         service  nginx  restart\n          systemctl restart nginx.service\n\n    ")])])}],y={},S=y,w=Object(c["a"])(S,h,f,!1,null,"8f09a02a",null),k=w.exports,x=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{staticClass:"container q-pa-lg"},[e("q-pdfviewer",{attrs:{src:t.src,type:"html5","content-class":"fit container","inner-content-class":"fit container"},model:{value:t.show,callback:function(n){t.show=n},expression:"show"}})],1)},C=[],j={name:"Container",data:function(){return{show:!0,src:"statics/linux/pdf/Linux学习笔记.pdf"}}},P=j,T=(e("cb77"),Object(c["a"])(P,x,C,!1,null,"3efa0c9a",null)),E=T.exports,O=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{},[e("q-markdown",{attrs:{src:t.MainComponent}})],1)},M=[],A='# Shell\n\n## shell程序的种类\n\n### Bourne Shell（/usr/bin/sh或/bin/sh）\n\n### Bourne Again Shell（/bin/bash）\n\n- 大多数Linux 系统默认\n\n### C Shell（/usr/bin/csh）\n\n### K Shell（/usr/bin/ksh）\n\n### Shell for Root（/sbin/sh）\n\n## 运行脚本的方法\n\n### 作为可执行程序\n\n- chmod +x ./test.sh\n\n\t- #使脚本具有执行权限\n\n- ./test.sh\n\n\t- #执行脚本\n\n### 作为解释器参数\n\n- /bin/sh test.sh\n\n## 基本语法\n\n### #!\n\n#!/bin/bash\n\n- 指定解析脚本的程序\n\n### 变量\n\n- 定义变量\n\n\t- 变量名 = 变量值\n\n\t  your_name="runoob.com"\n\n\t- 命名规范\n\n\t\t- 变量名和等号之间不能有空格\n\t\t- 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头\n\t\t- 不能使用bash里的关键字（可用help命令查看保留关键字）\n\n- 使用变量\n\n\t- 在变量名前面加美元符号（花括号是为了区分变量的边界）\n\n\t\t- echo $your_name\n\t\t- echo ${your_name}\n\n- 只读变量\n\n\t-  readonly 命令\n\n\t  myUrl="http://www.google.com"\r\r\n\t  readonly myUrl\r\r\n\t  myUrl="http://www.runoob.com"\n\n- 删除变量\n\n\t- unset 命令\n\n\t  #!/bin/sh\r\r\n\t  myUrl="http://www.runoob.com"\r\r\n\t  unset myUrl\r\r\n\t  echo $myUrl\n\n- 变量的类型\n\n\t- 局部变量\n\n\t\t- 在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量\n\n\t- 环境变量\n\n\t\t- 所有的程序，包括shell启动的程序，都能访问环境变量\n\n\t\t\t- 可用export定义\n\n\t- shell变量 \n\n\t\t- 是由shell程序设置的特殊变量\n\n### 数据类型\n\n- 字符串\n\n\t- 单引号\n\n\t\t- 任何字符都会原样输出，单引号字符串中的变量是无效的\n\t\t- 不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用\n\n\t- 双引号\n\n\t  your_name=\'runoob\'\r\r\n\t  str="Hello, I know you are \\"$your_name\\"! \\n"\r\r\n\t  echo -e $str\n\n\t\t- 可以有变量，可以出现转义字符\n\n\t- 拼接字符串\n\n\t  your_name="runoob"\r\r\n\t  # 使用双引号拼接\r\r\n\t  greeting="hello, "$your_name" !"\r\r\n\t  greeting_1="hello, ${your_name} !"\r\r\n\t  echo $greeting  $greeting_1\r\r\n\t  # 使用单引号拼接\r\r\n\t  greeting_2=\'hello, \'$your_name\' !\'\r\r\n\t  greeting_3=\'hello, ${your_name} !\'\r\r\n\t  echo $greeting_2  $greeting_3\r\r\n\t  \r\r\n\t  \r\r\n\t  \r\r\n\t  输出结果：\r\r\n\t  hello, runoob ! hello, runoob !\r\r\n\t  hello, runoob ! hello, ${your_name} !\n\n\t- 字符串处理\n\n\t\t- 获取字符串长度\n\n\t\t  string="abcd"\r\r\n\t\t  echo ${#string} #输出 4\n\n\t\t\t- ${#变量名}\n\n\t\t- 提取子字符串\n\n\t\t  #第 2 个字符开始截取 4 个字符\r\r\n\t\t  string="runoob is a great site"\r\r\n\t\t  echo ${string:1:4} # 输出 unoo\n\n\t\t\t- ${变量名：开始位置：截取长度}\n\n\t\t- 查找子字符串\n\n\t\t  #查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)：\r\r\n\t\t  string="runoob is a great site"\r\r\n\t\t  echo `expr index "$string" io`  # 输出 4\n\n\t\t\t- expr index "$s变量名"  查找规则\n\n- 数组\n\n\t- 定义数组\n\n\t\t- 数组名=(值1 值2 ... 值n)\n\n\t\t  array_name=(value0 value1 value2 value3)\r\r\n\t\t  \r\r\n\t\t  or\r\r\n\t\t  \r\r\n\t\t  array_name=(\r\r\n\t\t  value0\r\r\n\t\t  value1\r\r\n\t\t  value2\r\r\n\t\t  value3\r\r\n\t\t  )\r\r\n\t\t  \r\r\n\t\t  or\r\r\n\t\t  \r\r\n\t\t  array_name[0]=value0\r\r\n\t\t  array_name[1]=value1\r\r\n\t\t  array_name[n]=valuen\n\n\t- 读取数组\n\n\t\t- 获取数组单个元素\n\n\t\t\t- ${数组名[下标]}\n\n\t\t\t  valuen=${array_name[n]}\n\n\t\t- 获取数组中的所有元素\n\n\t\t\t-  ${数组名[@]}\n\n\t- 获取数组长度\n\n\t  # 取得数组元素的个数\r\r\n\t  length=${#array_name[@]}\r\r\n\t  # 或者\r\r\n\t  length=${#array_name[*]}\r\r\n\t  # 取得数组单个元素的长度\r\r\n\t  lengthn=${#array_name[n]}\n\n\t\t- ${#数组名[@]}\n\t\t- ${#数组名[*]}\n\n### 注释\n\n- 单行注释\n\n\t- #\n\n- 多行注释\n\n\t- :<<注释标记符     要注释的内容。。。    注释标记符\n\n\t  :<<\'\r\r\n\t  注释内容...\r\r\n\t  注释内容...\r\r\n\t  注释内容...\r\r\n\t  \'\r\r\n\t  \r\r\n\t  or\r\r\n\t  \r\r\n\t  :<<!\r\r\n\t  注释内容...\r\r\n\t  注释内容...\r\r\n\t  注释内容...\r\r\n\t  !\r\r\n\t  \r\r\n\t  or\r\r\n\t  \r\r\n\t  :<<EOF\r\r\n\t  注释内容...\r\r\n\t  注释内容...\r\r\n\t  注释内容...\r\r\n\t  EOF\n\n### 给脚本传递参数\n\ntest.sh脚本\r\r\necho "Shell 传递参数实例！";\r\r\necho "执行的文件名：$0";\r\r\necho "第一个参数为：$1";\r\r\necho "第二个参数为：$2";\r\r\necho "第三个参数为：$3";\r\r\n\r\r\n传递参数\r\r\nsh test.sh 1 2 3\r\r\n\r\r\n\r\r\n输出\r\r\n执行的文件名：test.sh\r\r\n第一个参数为：1\r\r\n第二个参数为：2\r\r\n第三个参数为：3\r\r\n\t\n\n- 传递方式\n\n\t- sh test.sh 1 2 3\n\n- 脚本中获取传递参数\n\n\t- $#\n\n\t\t- 传递到脚本的参数个数\n\n\t- $*、$@\n\n\t\t- 显示所有向脚本传递的参数\n\n\t\t\t- 如"$*"，以"$1 $2 … $n"的形式输出所有参数。\n\t\t\t- 如"$@"，以"$1" "$2" … "$n" 的形式输出所有参数。\n\n\t- $$\n\n\t\t- 脚本运行的当前进程ID号\n\n- $*和$@的区别\n\n  echo "-- \\$* 演示 ---"\r\r\n  for i in "$*"; do\r\r\n      echo $i\r\r\n  done\r\r\n  \r\r\n  echo "-- \\$@ 演示 ---"\r\r\n  for i in "$@"; do\r\r\n      echo $i\r\r\n  done\n\n\t-  " * " 等价于 "1 2 3"（传递了一个参数），而 "@" 等价于 "1" "2" "3"（传递了三个参数）\n\n- read 命令\n\n  read firstStr secondStr\r\r\n  echo "第一个参数:$firstStr; 第二个参数:$secondStr"\r\r\n  \r\r\n  \r\r\n  运行：\r\r\n  sh test.sh  一 二 三 四\r\r\n  \r\r\n  \r\r\n  输出：\r\r\n  第一个参数:一; 第二个参数:二 三 四\n\n\t- 接收并定义传递的参数\n\n### 运算符\n\n- 概述：原生bash不支持简单的数学运算，要借助表达式计算工具完成运算\n\n  #!/bin/bash\r\r\n  \r\r\n  val=`expr 2 + 2`\r\r\n  echo "两数之和为 : $val"\n\n- 算术运算符\n\n\t- +\t加法\t`expr $a + $b` 结果为 30。\n\t- -\t减法\t`expr $a - $b` 结果为 -10。\n\t- *\t乘法\t`expr $a \\* $b` 结果为  200。\n\t- /\t除法\t`expr $b / $a` 结果为 2。\n\t- %\t取余\t`expr $b % $a` 结果为 0。\n\t- =\t赋值\ta=$b 将把变量 b 的值赋给 a。\n\t- ==\t相等。用于比较两个数字，相同则返回 true。\t[ $a == $b ] 返回 false。\n\t- !=\t不相等。用于比较两个数字，不相同则返回 true。\t[ $a != $b ] 返回 true。\n\n- 关系运算符\n\n  if [ $a -eq $b ]\r\r\n  then\r\r\n     echo "$a -eq $b : a 等于 b"\r\r\n  else\r\r\n     echo "$a -eq $b: a 不等于 b"\r\r\n  fi\n\n\t- -eq\t检测两个数是否相等，相等返回 true。\t[ $a -eq $b ] 返回 false。\n\t- -ne\t检测两个数是否不相等，不相等返回 true。\t[ $a -ne $b ] 返回 true。\n\t- -gt\t检测左边的数是否大于右边的，如果是，则返回 true。\t[ $a -gt $b ] 返回 false。\n\t- -lt\t检测左边的数是否小于右边的，如果是，则返回 true。\t[ $a -lt $b ] 返回 true。\n\t- -ge\t检测左边的数是否大于等于右边的，如果是，则返回 true。\t[ $a -ge $b ] 返回 false。\n\t- -le\t检测左边的数是否小于等于右边的，如果是，则返回 true。\t[ $a -le $b ] 返回 true。\n\n- 布尔运算符\n\n\t- !\t非运算，表达式为 true 则返回 false，否则返回 true。\t[ ! false ] 返回 true。\n\t- -o\t或运算，有一个表达式为 true 则返回 true。\t[ $a -lt 20 -o $b -gt 100 ] 返回 true。\n\t- -a\t与运算，两个表达式都为 true 才返回 true。\t[ $a -lt 20 -a $b -gt 100 ] 返回 false。\n\n- 逻辑运算符\n\n\t- &&\t逻辑的 AND\t[[ $a -lt 100 && $b -gt 100 ]] 返回 false\n\t- ||\t逻辑的 OR\t[[ $a -lt 100 || $b -gt 100 ]] 返回 true\n\n- 字符串运算符\n\n\t- =\t检测两个字符串是否相等，相等返回 true。\t[ $a = $b ] 返回 false。\n\t- !=\t检测两个字符串是否相等，不相等返回 true。\t[ $a != $b ] 返回 true。\n\t- -z\t检测字符串长度是否为0，为0返回 true。\t[ -z $a ] 返回 false。\n\t- -n\t检测字符串长度是否为0，不为0返回 true。\t[ -n "$a" ] 返回 true。\n\t- $\t检测字符串是否为空，不为空返回 true。\t[ $a ] 返回 true。\n\n- 文件测试运算符\n\n\t- -b file\t检测文件是否是块设备文件，如果是，则返回 true。\t[ -b $file ] 返回 false。\n\t- -c file\t检测文件是否是字符设备文件，如果是，则返回 true。\t[ -c $file ] 返回 false。\n\t- -d file\t检测文件是否是目录，如果是，则返回 true。\t[ -d $file ] 返回 false。\n\t- -f file\t检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。\t[ -f $file ] 返回 true。\n\t- -g file\t检测文件是否设置了 SGID 位，如果是，则返回 true。\t[ -g $file ] 返回 false。\n\t- -k file\t检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。\t[ -k $file ] 返回 false。\n\t- -p file\t检测文件是否是有名管道，如果是，则返回 true。\t[ -p $file ] 返回 false。\n\t- -u file\t检测文件是否设置了 SUID 位，如果是，则返回 true。\t[ -u $file ] 返回 false。\n\t- -r file\t检测文件是否可读，如果是，则返回 true。\t[ -r $file ] 返回 true。\n\t- -w file\t检测文件是否可写，如果是，则返回 true。\t[ -w $file ] 返回 true。\n\t- -x file\t检测文件是否可执行，如果是，则返回 true。\t[ -x $file ] 返回 true。\n\t- -s file\t检测文件是否为空（文件大小是否大于0），不为空返回 true。\t[ -s $file ] 返回 true。\n\t- -e file\t检测文件（包括目录）是否存在，如果是，则返回 true。\t[ -e $file ] 返回 true。\n\n- 使用[]执行基本运算\n\n  #!/bin/bash\r\r\n  \r\r\n  a=5\r\r\n  b=6\r\r\n  \r\r\n  result=$[a+b] # 注意等号两边不能有空格\r\r\n  echo "result 为： $result"\n\n### 输出命令\n\n- echo命令\n\n\t- echo\n\n\t\t- 普通输出\n\n\t- echo -e\n\n\t  echo -e "OK! \\n" # -e 开启转义\r\r\n\t  echo "It is a test"\n\n\t\t- 接受转义字符输出\n\n\t- 输出类型\n\n\t\t- 单引号\n\t\t- 双引号\n\t\t- 反单引号\n\n\t\t  echo `date`\r\r\n\t\t  \r\r\n\t\t  输出：\r\r\n\t\t  Thu Jul 24 10:08:46 CST 2014\r\r\n\t\t  \n\n\t\t- 无符号\n\n- printf命令\n\n\t- 语法结构：printf  format-string  [arguments...]\n\n\t  printf "%-10s %-8s %-4s\\n" 姓名 性别 体重kg  \r\r\n\t  printf "%-10s %-8s %-4.2f\\n" 郭靖 男 66.1234 \r\r\n\t  printf "%-10s %-8s %-4.2f\\n" 杨过 男 48.6543 \r\r\n\t  printf "%-10s %-8s %-4.2f\\n" 郭芙 女 47.9876 \r\r\n\t  \r\r\n\t  \r\r\n\t  输出：\r\r\n\t  姓名     性别   体重kg\r\r\n\t  郭靖     男      66.12\r\r\n\t  杨过     男      48.65\r\r\n\t  郭芙     女      47.99\n\n\t\t- format-string: 为格式控制字符串\n\t\t- arguments: 为参数列表\n\n\t- 格式替换符\n\n\t\t- %d\n\n\t\t\t- 十进制整数\n\n\t\t- %s\n\n\t\t\t- 字符串或者字符型\n\n\t\t- %c\n\n\t\t\t- 字符串或者字符型\n\n\t\t- %f\n\n\t\t\t- 数字型、浮点型\n\n- 转义字符\n\n\t- \\a\t警告字符，通常为ASCII的BEL字符\n\t- \\b\t后退\n\t- \\c\t抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略\n\t- \\f\t换页（formfeed）\n\t- \\n\t换行\n\t- \\r\t回车（Carriage return）\n\t- \\t\t水平制表符\n\t- \\v\t垂直制表符\n\t- \\\\\t一个字面上的反斜杠字符\n\t- \\ddd\t表示1到3位数八进制值的字符。仅在格式字符串中有效\n\t- \\0ddd\t表示1到3位的八进制值字符\n\n### test命令\n\n- 概述：用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试\n- 数值测试\n\n  num1=100\r\r\n  num2=100\r\r\n  if test $[num1] -eq $[num2]\r\r\n  then\r\r\n      echo \'两个数相等！\'\r\r\n  else\r\r\n      echo \'两个数不相等！\'\r\r\n  fi\n\n\t- -eq\t等于则为真\n\t- -ne\t不等于则为真\n\t- -gt\t大于则为真\n\t- -ge\t大于等于则为真\n\t- -lt\t小于则为真\n\t- -le\t小于等于则为真\n\n- 字符串测试\n\n  num1="ru1noob"\r\r\n  num2="runoob"\r\r\n  if test $num1 = $num2\r\r\n  then\r\r\n      echo \'两个字符串相等!\'\r\r\n  else\r\r\n      echo \'两个字符串不相等!\'\r\r\n  fi\n\n\t- =\t等于则为真\n\t- !=\t不相等则为真\n\t- -z 字符串\t字符串的长度为零则为真\n\t- -n 字符串\t字符串的长度不为零则为真\n\n- 文件测试\n\n  cd /bin\r\r\n  if test -e ./bash\r\r\n  then\r\r\n      echo \'文件已存在!\'\r\r\n  else\r\r\n      echo \'文件不存在!\'\r\r\n  fi\n\n\t- -e 文件名\t如果文件存在则为真\n\t- -r 文件名\t如果文件存在且可读则为真\n\t- -w 文件名\t如果文件存在且可写则为真\n\t- -x 文件名\t如果文件存在且可执行则为真\n\t- -s 文件名\t如果文件存在且至少有一个字符则为真\n\t- -d 文件名\t如果文件存在且为目录则为真\n\t- -f 文件名\t如果文件存在且为普通文件则为真\n\t- -c 文件名\t如果文件存在且为字符型特殊文件则为真\n\t- -b 文件名\t如果文件存在且为块特殊文件则为真\n\n- 结合布尔运算符\n\n  cd /bin\r\r\n  if test -e ./notFile -o -e ./bash\r\r\n  then\r\r\n      echo \'至少有一个文件存在!\'\r\r\n  else\r\r\n      echo \'两个文件都不存在\'\r\r\n  fi\n\n\t- ( -a )、或( -o )、非( ! )\n\n### 流程控制\n\n- if\n\n  a=10\r\r\n  b=20\r\r\n  if [ $a == $b ]\r\r\n  then\r\r\n     echo "a 等于 b"\r\r\n  elif [ $a -gt $b ]\r\r\n  then\r\r\n     echo "a 大于 b"\r\r\n  elif [ $a -lt $b ]\r\r\n  then\r\r\n     echo "a 小于 b"\r\r\n  else\r\r\n     echo "没有符合的条件"\r\r\n  fi\r\r\n  \n\n\t- 语法格式\n\n\t  if condition1\r\r\n\t  then\r\r\n\t      command1\r\r\n\t  elif condition2 \r\r\n\t  then \r\r\n\t      command2\r\r\n\t  else\r\r\n\t      commandN\r\r\n\t  fi\n\n\t\t- if then、elif then、else、fi\n\n- case\n\n  echo \'输入 1 到 4 之间的数字:\'\r\r\n  echo \'你输入的数字为:\'\r\r\n  read aNum\r\r\n  case $aNum in\r\r\n      1)  echo \'你选择了 1\'\r\r\n      ;;\r\r\n      2)  echo \'你选择了 2\'\r\r\n      ;;\r\r\n      3)  echo \'你选择了 3\'\r\r\n      ;;\r\r\n      4)  echo \'你选择了 4\'\r\r\n      ;;\r\r\n      *)  echo \'你没有输入 1 到 4 之间的数字\'\r\r\n      ;;\r\r\n  esac\n\n\t- 语法格式\n\n\t  case 值 in\r\r\n\t  模式1)\r\r\n\t      command1\r\r\n\t      command2\r\r\n\t      ...\r\r\n\t      commandN\r\r\n\t      ;;\r\r\n\t  模式2）\r\r\n\t      command1\r\r\n\t      command2\r\r\n\t      ...\r\r\n\t      commandN\r\r\n\t      ;;\r\r\n\t  esac\t\n\n\t\t- case in、;;、csac\n\n### 循环\n\n- for\n\n  for loop in 1 2 3 4 5\r\r\n  do\r\r\n      echo "The value is: $loop"\r\r\n  done\n\n\t- 语法结构\n\n\t  for var in item1 item2 ... itemN\r\r\n\t  do\r\r\n\t      command1\r\r\n\t      command2\r\r\n\t      ...\r\r\n\t      commandN\r\r\n\t  done\n\n\t\t- for in、do、done\n\n- while\n\n  #!/bin/bash\r\r\n  int=1\r\r\n  while(( $int<=5 ))\r\r\n  do\r\r\n      echo $int\r\r\n      let "int++"\r\r\n  done\n\n\t- 语法结构\n\n\t  while condition\r\r\n\t  do\r\r\n\t      command\r\r\n\t  done\t\n\n\t\t- while、do、done\n\n- until\n\n\t- 与while相反，循环执行一系列命令直至条件为 true 时停止\n\t- 语法格式\n\n\t  until condition\r\r\n\t  do\r\r\n\t      command\r\r\n\t  done\n\n\t\t- until、do、done\n\n- 跳出循环\n\n\t- break命令\n\n\t  #!/bin/bash\r\r\n\t  while :\r\r\n\t  do\r\r\n\t      echo -n "输入 1 到 5 之间的数字:"\r\r\n\t      read aNum\r\r\n\t      case $aNum in\r\r\n\t          1|2|3|4|5) echo "你输入的数字为 $aNum!"\r\r\n\t          ;;\r\r\n\t          *) echo "你输入的数字不是 1 到 5 之间的! 游戏结束"\r\r\n\t              break\r\r\n\t          ;;\r\r\n\t      esac\r\r\n\t  done\n\n- 进入下一轮循环\n\n\t- continue命令\n\n\t  #!/bin/bash\r\r\n\t  while :\r\r\n\t  do\r\r\n\t      echo -n "输入 1 到 5 之间的数字: "\r\r\n\t      read aNum\r\r\n\t      case $aNum in\r\r\n\t          1|2|3|4|5) echo "你输入的数字为 $aNum!"\r\r\n\t          ;;\r\r\n\t          *) echo "你输入的数字不是 1 到 5 之间的!"\r\r\n\t              continue\r\r\n\t              echo "游戏结束"\r\r\n\t          ;;\r\r\n\t      esac\r\r\n\t  done\n\n### 函数\n\n- 语法格式\n\n  [ function ] funname [()]\r\r\n  {\r\r\n  \r\r\n      action;\r\r\n  \r\r\n      [return int;]\r\r\n  \r\r\n  }\n\n- 不带参数函数\n\n  funWithReturn(){\r\r\n      echo "这个函数会对输入的两个数字进行相加运算..."\r\r\n      echo "输入第一个数字: "\r\r\n      read aNum\r\r\n      echo "输入第二个数字: "\r\r\n      read anotherNum\r\r\n      echo "两个数字分别为 $aNum 和 $anotherNum !"\r\r\n      return $(($aNum+$anotherNum))\r\r\n  }\r\r\n  funWithReturn\r\r\n  echo "输入的两个数字之和为 $? !"\n\n- 带参数函数\n\n  funWithParam(){\r\r\n      echo "第一个参数为 $1 !"\r\r\n      echo "第二个参数为 $2 !"\r\r\n      echo "第十个参数为 $10 !"\r\r\n      echo "第十个参数为 ${10} !"\r\r\n      echo "第十一个参数为 ${11} !"\r\r\n      echo "参数总数有 $# 个!"\r\r\n      echo "作为一个字符串输出所有参数 $* !"\r\r\n  }\r\r\n  funWithParam 1 2 3 4 5 6 7 8 9 34 73\r\r\n  \r\r\n  \r\r\n  输出：\r\r\n  第一个参数为 1 !\r\r\n  第二个参数为 2 !\r\r\n  第十个参数为 10 !\r\r\n  第十个参数为 34 !\r\r\n  第十一个参数为 73 !\r\r\n  参数总数有 11 个!\r\r\n  作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !\n\n- 参数的获取\n\n\t- $#\t传递到脚本的参数个数\n\t- $*\t以一个单字符串显示所有向脚本传递的参数\n\t- $$\t脚本运行的当前进程ID号\n\t- $!\t后台运行的最后一个进程的ID号\n\t- $@\t与$*相同，但是使用时加引号，并在引号中返回每个参数。\n\t- $-\t显示Shell使用的当前选项，与set命令功能相同。\n\t- $?\t显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。\n\n### 文件包含\n\n- . filename   或者   source filename\n\n  test1.sh：\r\r\n  url="http://www.runoob.com"\r\r\n  \r\r\n  \r\r\n  \r\r\n  test2.sh：\r\r\n  . ./test1.sh\r\r\n  # 或者使用以下包含文件代码\r\r\n  # source ./test1.sh\r\r\n  \r\r\n  echo "菜鸟教程官网地址：$url"\r\r\n  \r\r\n  \r\r\n  运行test2输出：\r\r\n  菜鸟教程官网地址：http://www.runoob.com\n\n*XMind: ZEN - Trial Version*',N={data:function(){return{MainComponent:A}}},I=N,D=Object(c["a"])(I,O,M,!1,null,"64313e19",null),z=D.exports,$=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},R=[],J={},L=J,H=Object(c["a"])(L,$,R,!1,null,"eef9dd64",null),q=H.exports,F=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},W=[],B={},U=B,G=Object(c["a"])(U,F,W,!1,null,"5e8ef88f",null),V=G.exports,X=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Q=[],Y={},K=Y,Z=Object(c["a"])(K,X,Q,!1,null,"349adfd0",null),tt=Z.exports,nt={components:{m1:b,m2:d,m3:k,m4:E,m5:z,m6:q,m7:V,m8:tt},data:function(){return{tab:"m1",tabs:[{label:"基础",value:"m1"},{label:"vim",value:"m2"},{label:"实际",value:"m3"},{label:"学习笔记",value:"m4"},{label:"shell基础",value:"m5"},{label:"未开发",value:"m6"},{label:"未开发",value:"m7"},{label:"未开发",value:"m8"}]}}},et=nt,at=Object(c["a"])(et,a,r,!1,null,"75b974c9",null);n["default"]=at.exports},ecbb:function(t,n,e){"use strict";n["a"]="# nginx\n\n## 正向代理与反向代理\n\n### 同域的要求\n\n- 1.协议相同\n- 2.域名相同\n- 3.端口相同\n\n### 正向代理与反向代理\n\n- 正向代理\n\n\t- 解释\n\n\t\t- 意思是一个位于客户端和目标服务器(target server)之间的服务器，为了从目标服务器取得内容，客户端向代理发送一个请求并指定目标(目标服务器)，然后代理向目标服务器转交请求并将获得的内容返回给客户端。\n\n\t- 通俗地说\n\n\t\t- 「客户端」可以看作一个黑社会大佬，「目标服务器」可以看作一家饭店，「代理服务器」可以看作小弟。\n\t\t- 「老大」想吃饭店的酱排骨饭，就让「小弟」去买，「小弟」跑到「饭店」要个酱排骨饭。\n\t\t- 「饭店」酱排骨饭做好，送到「小弟」手上，「小弟」最后再把酱排骨饭拿给「大佬」。\n\t\t- 说白了，小弟就是个跑腿的，代理大佬的需求。\n\n\t- 数据流程\n\n\t\t- 数据请求过程：浏览器 -> 代理服务器 -> 目标服务器\n\t\t- 数据返回过程：目标服务器 -> 代理服务器 -> 浏览器\n\n\t- 应用\n\n\t\t- 最经典的应用就是科学上网：我是一个国内用户，我访问不了google，但是我能访问一个香港的某个代理服务器。这个香港的代理服务器可以访问google，于是我先把请求发送到那个代理服务器，告诉他我需要访问google，代理服务器去取内容，最后返回给我。\n\n- 反向代理\n\n\t- 解释\n\n\t\t- 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。\n\n\t- 数据流程\n\n\t\t- 数据请求过程：浏览器 ->【反向代理服务器 -> 处理数据的服务器】\n\t\t- 数据返回过程：【处理数据的服务器 -> 反向代理服务器】-> 浏览器\n\n\t- 通俗地说\n\n\t\t- 「浏览器」可以看作食客，「【反向代理服务器-》处理数据的服务器】」这一个整体可以看作饭店，其中「反向代理服务」相当于点单的服务员。「处理数据的服务器」可以理解为是厨师。\n\t\t- 「食客」向来到「饭店」向「服务员」点菜，但服务员并不会真正去做菜，他是下达命令让「厨师」去做菜。\n\t\t- 「厨师」把菜做好了给「服务员」，「服务员」再把菜端给「食客」。\n\t\t- 在外部看来，「代理服务器」和「处理数据的服务器」是一个整体。就好比，食客只会去饭店吃饭，而不是去找厨师吃饭（即对于浏览器来说，到达反向代理服务器已经完成任务了，后面的操作则由反向代理服务器负责）。具体饭店怎么操作，对食客是透明的。有可能某个服务员即当服务器也当厨师（即反向代理服务器和处理数据的服务器是同一台PC机）。\n\n- 比较\n\n\t- 从用途上来讲\n\n\t\t- 正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。\n\t\t- 反向代理的典型用途是为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。\n\n\t- 从安全性来讲\n\n\t\t- 正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。\n\t\t- 反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。\n\n\t- 从使用方来看\n\n\t\t- 正向代理是浏览器端进行配置的，与服务器端无关，甚至可以对服务端隐藏。\n\t\t- 反向代理是服务器端配置的，对浏览器端是透明的。\n\n- 总结\n\n\t- 正向代理代理客户端，反向代理代理服务器\n\n### 利用代理实现跨域\n\n- 正向代理\n\n\t- 对正向代理服务器进行配置，当获取非接口数据时，让代理服务器指向开发者本机的资源。当访问接口时，访问后端接口数据。\n\t- Charles、Fiddler\n\n- 反向代理\n\n\t- Nginx\n\n\t\t- 用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。\n\t\t- 原理\n\n\t\t\t- 只需要配置nginx，在一个服务器上配置多个前缀来转发http/https请求到多个真实的服务器即可。这样，这个服务器上所有url都是相同的域名、协议和端口。因此，对于浏览器来说，这些url都是同源的，没有跨域限制。而实际上，这些url实际上由物理服务器提供服务。这些服务器内的javascript可以跨域调用所有这些服务器上的url。\n\n\t\t- 使用\n\n\t\t\t- server {\n        listen       9000;  #配置第一台服务器\n        server_name  localhost;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n\n        location / {\n            #alias D:\\\\develop\\\\project1dir\\\\app\\\\; #配置别名到项目源代码目录，那么访问http://localhost:9000/即访问此目录\n            # Frontend Server\n            proxy_pass http://localhost:8001/;  #更聪明的做法是代理到前端服务器地址，比如gulp+browser-sync开启的服务器，能看到代码实时更新效果\n        }\n\n        location /api/ {\n            rewrite ^/api/(.*)$ /$1 break;   #所有对后端的请求加一个api前缀方便区分，真正访问的时候移除这个前缀\n            # API Server\n            proxy_pass http://www.serverA.com;  #将真正的请求代理到serverA,即真实的服务器地址，ajax的url为/api/user/1的请求将会访问http://www.serverA.com/user/1\n        }\n}\n*XMind: ZEN - Trial Version*"},f4eb:function(t,n,e){"use strict";e.r(n);var a=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+t.value,label:n+1+"."+t.label}})})),1),e(""+t.tab,{tag:"component"})],1)},r=[],s=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},o=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("pre",[t._v("    数据库相关：\n填充器 seeder\n迁移文件 migration\n模型工厂 factory    Faker 类库 \n数据库配置\nhttps://laravelacademy.org/post/19520.html#toc_1\n两个官网文档\nhttps://laravelacademy.org/laravel-docs-5_8\nhttps://learnku.com/docs/lumen/5.7\n\nphp artisan  命令 \n对于 laravel 原生支持的指令 但是 lumen 不支持 安装这个依赖包 \nlumen-generator\nhttps://github.com/flipboxstudio/lumen-generator\n\n速查表\nhttps://learnku.com/docs/laravel-cheatsheet/5.8\n\n")])])}],l={},i=l,c=e("2877"),p=Object(c["a"])(i,s,o,!1,null,"38331fa6",null),b=p.exports,u=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},v=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("pre",[t._v("       laravel artisan命令\n       https://laravelacademy.org/laravel-docs-5_8\nhttps://learnku.com/docs/lumen/5.7\n流程： 创建model -m 生成数据库迁移文件migration\n配置数据库迁移文件 \n配置 数据库模拟文件 seeds\n\n\n添加加载依赖项\ncomposer require laravel/socialite\n自动生成引入文件\ncomposer dump-auto\n\nphp artisan make:controller TaskController\n// restful 风格\nphp artisan make:controller PostController --resource\nRoute::resource('tasks', 'TaskController')\n//隐式控制器\n// Route::controller('foods','FoodsController');\n// restful 风格\n// Route::resource('foods','FoodsController');\n\nphp artisan make:middleware LoginMiddleware\n数据库迁移\nphp artisan make:migration goods\nphp artisan migrate \nphp artisan migrate:refresh\n模拟数据 \nphp artisan make:seeder UsersTableSeeder\nphp artisan db:seed --class=UsersTableSeeder\nphp artisan db:seed\n迁移加上模拟数据\nphp artisan migrate --seed \nphp artisan migrate:refresh --seed\n\ndebugbar 安装\ncomposer require barryvdh/laravel-debugbar\n在 config/app.php 里面的providers添加\nBarryvdh\\Debugbar\\ServiceProvider::class\n\neloquent\norm 数据库操作模型  \nconfig/database.php\n$app->withEloquent();\nhttps://laravelacademy.org/post/19531.html\n\n创建数据库交互模型文件\nphp artisan make:model Model/Order\nphp artisan make:model Order -m  //自动建立一个对应数据库迁移文件\n模型限定规则\n模型对应的数据库表名规则：单复数关系 User=>Users  或者 Users=>Users   lay=>laies\n主键id  \n\nmodel文件非默认规则(打破潜规则)：对应更改：\npublic $table=\"user\"; \npublic $primaryKey =\"cid\";\npublic $timestamps =false;\n\n\n\n\n\n\n\n\n\n   ")])])}],g={},m=g,_=Object(c["a"])(m,u,v,!1,null,"d53ec848",null),d=_.exports,h=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},f=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("pre",[t._v("            laravel  seeder 填充器\n            参考页面\nhttps://laravelacademy.org/post/9694.html\n模拟数据 \nphp artisan make:seeder UsersTableSeeder\nphp artisan db:seed --class=UsersTableSeeder\nphp artisan db:seed 一次 运行填充所有\n\nseeder  文件 的 run  方法 内容 可以如下 生成数据\n\n第一种方法\nDB::table('users')->insert([\n        'name' => str_random(10),\n        'email' => str_random(10).'@gmail.com',\n        'password' => bcrypt('secret'),\n    ]);\n\n第二种\n        $arr=[];\n\n        for($i=0;$i<100;$i++){\n            $tmp=[];\n            $tmp['country']=str_random(20);\n            $tmp['name']=str_random(10);\n            $arr[]=$tmp;\n        }\n\n        DB::table('tests')->insert($arr);\n\n第三种\nfactory(\\App\\User::class, 5)->create();\n        ")]),e("pre",[t._v("            数据库操作\n\n            参考 \nhttps://laravelacademy.org/post/19520.html#toc_1\n增删改查\nhttps://laravelacademy.org/post/9697.html#toc_0\n\nhttps://laravelacademy.org/post/9698.html\n\n首先 config/database.php 或者 lumen  的 bootstarp/app.php 开启门面 开启 eloqument\n参考 \n\n$users = DB::connection('read')->select(...);\n$users = DB::table('users')->get();\n$name = '学院君';\n$users = DB::table('users')->where('name', $name)->get();\n$user = DB::table('users')->where('name', $name)->first();\n$user = DB::table('users')->select('id', 'name', 'email')->where('name', $name)->first();\n        ")])])}],y={},S=y,w=Object(c["a"])(S,h,f,!1,null,"7fbd6105",null),k=w.exports,x=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("h4",[t._v("web.php")]),e("pre",[t._v("<?php\n\n/*\n|--------------------------------------------------------------------------\n| Web Routes\n|--------------------------------------------------------------------------\n|\n| Here is where you can register web routes for your application. These\n| routes are loaded by the RouteServiceProvider within a group which\n| contains the \"web\" middleware group. Now create something great!\n|\n*/\n\nRoute::get('/', function () {\n    return view('welcome');\n});\n\n// Route::get('/','WelcomeController@index');\n//这段代码的含义是将针对 / 路由的 GET 请求传递给 App\\Http\\Controllers\\WelcomeController 控制器的 index 方法进行处理。\n// Route::get('uesr/{id}',function($id){\n//     return '用户id: '.$id;\n// });\n// 为路由参数指定正则匹配规则：\n// Route::get('page/{id}', function ($id) {\n//     return '页面ID: ' . $id;\n// })->where('id', '[0-9]+');\n\n// Route::get('page/{name}', function ($name) {\n//     return '页面名称: ' . $name;\n// })->where('name', '[A-Za-z]+');\n\n// Route::get('page/{id}/{slug}', function ($id, $slug) {\n//     return $id . ':' . $slug;\n// })->where(['id' => '[0-9]+', 'slug' => '[A-Za-z]+']);\n\n//https://laravelacademy.org/post/9611.html\n// 路由命名\n// Route::get('user/{id?}', function ($id = 1) {\n//     return \"用户ID: \" . $id;\n// })->name('user.profile');\n\n\n  <a href=\""+t._s(t.url("/"))+'">\n <a href="'+t._s(t.route("user.profile",[!1]))+'">\n <a href="'+t._s(t.route("user.profile",[100]))+"\">\n\n// 输出：http://blog.test/user/100\n\nRoute::get('/task','TaskController@home');\nRoute::resource('post','PostController');\n// 可以通过 Artisan 命令 php artisan route:list 查看应用的所有路由：\n        ")])])},C=[],j={},P=j,T=Object(c["a"])(P,x,C,!1,null,"becc5444",null),E=T.exports,O=function(){var t=this,n=t.$createElement;t._self._c;return t._m(0)},M=[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("h4",[t._v("\n          lumen 从零开始创建项目 step0 \n       ")]),e("pre",[t._v("           下载 PHP\n把PHP 添加到系统 环境变量\n下载 composer 添加环境变量\n\n\n\ncomposer global require \"laravel/lumen-installer\"\n\ncomposer create-project --prefer-dist laravel/lumen blog\n\n添加  lumen  laravel 到环境变量 \nC:\\Users\\Administrator\\AppData\\Roaming\\Composer\\vendor\\bin\n\n配置 PHP 支持 MySQL \n1. 在 本机 的 PHP.INI 文件 中设置 extension_dir  语言支持包的路径为绝对路径\n   比如 C:\\Program Files\\php-7.3.6-nts-Win32-VC15-x64\\ext\n2. extension=php_mysqli.dll  \n   extension=pdo_mysql\nextension=mysqli\n\n配置 mysql  用户授权\n在 mysql 的 my.ini 文件中\ndefault_authentication_plugin=mysql_native_password\n\nmysql -uroot -p\n \nuse mysql;\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '你的密码'\n\n       ")]),e("h4",[t._v("lumen 从零开始创建项目 step1")]),e("pre",[t._v("       速查表 https://learnku.com/docs/laravel-cheatsheet/5.8\n安装   支持laravel 命令 的依赖库\nlumen-generator\nhttps://github.com/flipboxstudio/lumen-generator\ncomposer require flipbox/lumen-generator\n$app->register(Flipbox\\LumenGenerator\\LumenGeneratorServiceProvider::class);\n\n生成应用安全密钥\nphp artisan key:generate\n\n自动生成引入文件\ncomposer dump-auto\n\n查看当前 支持命令 \nphp artisan\n\n生成  Eloquent 模型 并 同时生成 数据库迁移文件\nphp artisan make:model  Test --migration OR -m\n\n生成 seeder  数据库 模拟文件 \nphp artisan make:seeder  TestTableSeeder\n\n生成  模型工厂类 文件  // 如果不支持 需要自己手动创建\nphp  artisan make:factory  TestModelFactory \n\n编写相对应的 迁移文件 ，工厂文件，模拟文件 \n模拟文件内  调用用模型工厂  批量生成数据\nfactory(\\App\\User::class, 5)->create();\n\n根据数据表生成迁移文件\n // --database   指定数据库连接（下同）\n // --force      当处于生产环境时强制执行，不询问（下同）\n // --path       指定单独迁移文件地址\n // --pretend    把将要运行的 SQL 语句打印出来（下同）\n // --seed       Seed 任务是否需要被重新运行（下同）\nphp artisan migrate [--database[='....']] [--force] [--path[='....']] [--pretend] [--seed]\n// 创建迁移数据库表\nphp artisan migrate:install [--database[=\"...\"]]\n生成/重置所有数据表\nphp artisan migrate[:fresh]\n\n生成所有假数据\nphp artisan db:seed \n\n生成 控制器\nphp  artisan make:controller TestController  [--plain]\nphp artisan make:controller PostController --resource\nRoute::resource('tasks', 'TaskController')\n\n生成 中间件\nphp artisan make:middleware LoginMiddleware\n\n其他的 事件 队列 服务注册 邮件 监听 轮询 等等 根据 需要自己 添加\n均有相应 命令 查看速查表 artisan \n\n对于 多数项目必须的 命令 如下\n  make:controller     Create a new controller class\n  make:event          Create a new event class\n  make:job            Create a new job class\n  make:listener       Create a new event listener class\n  make:mail           Create a new email class\n  make:middleware     Create a new middleware class\n  make:migration      Create a new migration file\n  make:model          Create a new Eloquent model class\n  make:policy         Create a new policy class\n  make:provider       Create a new service provider class\n\nkey:generate      Set the application key\n\nmake:command      Create a new Artisan command\nmake:controller   Create a new controller class\nmake:event        Create a new event class\nmake:job          Create a new job class\nmake:listener     Create a new event listener class\nmake:mail         Create a new email class\nmake:middleware   Create a new middleware class\nmake:migration    Create a new migration file\nmake:model        Create a new Eloquent model class\nmake:policy       Create a new policy class\nmake:provider     Create a new service provider class\nmake:seeder       Create a new seeder class\nmake:test         Create a new test class\n\n\n    \n       ")]),e("h4",[t._v("\nlumen 从零开始创建项目 step2\n")]),e("pre",[e("code",[t._v("\n    建表 数据 填充 \n\nSchema::create('users', function (Blueprint $table) {\n            $table->bigIncrements('id');\n            $table->string(\"name\");\n            $table->integer('age');\n            $table->string('country');\n            $table->string(\"email\");\n            $table->text(\"description\");\n            $table->date(\"borntime\");\n            $table->timestamps();\n        });\n\n    Schema::create('cafes', function( Blueprint $table ){\n        $table->increments('id');\n        $table->string('name');\n        $table->text('address');\n        $table->string('city');\n        $table->string('state');\n        $table->string('zip');\n        $table->decimal('latitude', 11, 8);\n        $table->decimal('longitude', 11, 8);\n        $table->timestamps();\n    });\n\n'password' => bcrypt('vienblog'),\n\n        Schema::create('admin_users', function(Blueprint $table)\n        {\n            $table->increments('id')->comment('ID');\n            $table->string('username')->unique('users_username_unique')->comment('用户名');\n            $table->string('email')->unique('users_email_unique')->comment('邮件');\n            $table->string('mobile', 11)->nullable()->comment('手机号码');\n            $table->smallInteger('sex')->default(1)->comment('性别');\n            $table->string('password', 60)->comment('密码');\n            $table->string('remember_token', 100)->nullable()->comment('TOKEN');\n            $table->timestamps();\n        });\n    }\n\n\n$factory->define(App\\User::class, function (Faker\\Generator $faker) {\n    return [\n\n        'name' => $faker->name,\n        \"age\" => $faker ->age,\n        \"country\" => $faker ->country,\n        'email' => $faker->email,\n        'description' => $faker->realText($maxNbChars = 200, $indexSize = 1),\n        \"borntime\" => $faker->dateTime($max = 'now', $timezone = null),\n    ];\n});\n\n\n    public function run()\n    {\n        //\n        factory(\\App\\User::class, 100)->create();\n    }\n\n    public function run()\n    {\n        \\DB::table('admin_users')->delete();\n        \\DB::table('admin_users')->insert(array (\n            0 => \n                array (\n                    'id'                =>  1,\n                    'username'          =>  'admin',\n                    'email'             =>  'admin@admin.com',\n                    'mobile'            =>  '18888888888',\n                    'sex'               =>  1,\n                    'password'          =>  '$2y$10$0nZ2IJJQzkuwTUvmsxVCYOAFw09sGceAk5b9p.AQ.h7I0YEj975rO', //f123456\n                    'remember_token'    =>  '',\n                    'created_at'        =>  date('Y-m-d H:i:s',time()),\n                    'updated_at'        =>  date('Y-m-d H:i:s',time()),\n                ),\n            )\n        );\n    }\n}\n\n\n\n\n    public function up()\n    {\n        Schema::create('blog_articles', function (Blueprint $table) {\n            $table->increments('id');\n            $table->string('slug')->unique();\n            $table->string('title', 255)->default('')->comment('title');\n            $table->string('keywords')->default('')->comment('keywords');\n            $table->string('description', 255)->default('')->comment('description');\n            $table->longText('markdown')->nullable()->comment('markdown content');\n            $table->integer('user_id')->default(0)->comment('author id');\n            $table->integer('cate_id')->default(0)->comment('category id');\n            $table->integer('comment_count')->default(0)->comment('comment count');\n            $table->integer('read_count')->default(0)->comment('read count');\n            $table->tinyInteger('status')->default(1)->comment('status: 1-public;0-private');\n            $table->integer('sort')->default(0)->comment('sort');\n            $table->tinyInteger('is_top')->default(0)->comment('sticky to top');\n            $table->integer('updated_at');\n            $table->integer('created_at');\n            $table->integer('deleted_at')->nullable();\n            $table->index('title');\n            $table->index('cate_id');\n            $table->index('user_id');\n            $table->index('created_at');\n        });\n    }\n")]),t._v("\n")]),e("h4",[t._v("\nlumen 从零开始创建项目 step3\n")]),e("pre",[t._v("    "),e("code",[t._v("\n        资源类 给返回的数据变形封装， 取出自己需要的  \nhttps://laravelacademy.org/post/19536.html\n\nprotected $hidden = ['password'];\nprotected $visible = ['first_name', 'last_name'];\nreturn $user->makeVisible('attribute')->toArray();\nreturn $user->makeHidden('attribute')->toArray();\nreturn $user->append('is_admin')->toArray();\n\nreturn $user->setAppends(['is_admin'])->toArray();\nprotected $casts = [\n    'birthday' => 'date:Y-m-d',\n    'joined_at' => 'datetime:Y-m-d H:00',\n];\n\nphp artisan make:resource UserCollection\n\nuse App\\User;\nuse App\\Http\\Resources\\UserCollection;\n\nRoute::get('/users', function () {\n    return new UserCollection(User::paginate());\n});\n\n<?php\n\nnamespace App\\Http\\Resources;\n\nuse Illuminate\\Http\\Resources\\Json\\JsonResource;\n\nclass User extends JsonResource\n{\n    /**\n     * Transform the resource into an array.\n     *\n     * @param  \\Illuminate\\Http\\Request\n     * @return array\n     */\n    public function toArray($request)\n    {\n        return [\n            'id' => $this->id,\n        ];\n    }\n\n    /**\n     * Customize the outgoing response for the resource.\n     *\n     * @param  \\Illuminate\\Http\\Request\n     * @param  \\Illuminate\\Http\\Response\n     * @return void\n     */\n    public function withResponse($request, $response)\n    {\n        $response->header('X-Value', 'True');\n    }\n}\n    ")]),t._v("\n")]),e("h4",[t._v("\nlumen 从零开始创建项目 step4\n")]),e("pre",[t._v("   获取  get 请求参数 \n一种 是 路径里面的参数   \n/aaa/{id}   =====> $id\n\n另一种 \n/aaa/vvv?aa=33   =====> $route=$request->route(); $route[2]['url参数'];\n\npost  请求的 获取参数  和文档一样 \n$request->input();\n\n\n \n")])])}],A={},N=A,I=Object(c["a"])(N,O,M,!1,null,"c504bc72",null),D=I.exports,z=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},$=[],R={},J=R,L=Object(c["a"])(J,z,$,!1,null,"165d6ed2",null),H=L.exports,q=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},F=[],W={},B=W,U=Object(c["a"])(B,q,F,!1,null,"272d53da",null),G=U.exports,V=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},X=[],Q={},Y=Q,K=Object(c["a"])(Y,V,X,!1,null,"7b158558",null),Z=K.exports,tt={components:{m1:b,m2:d,m3:k,m4:E,m5:D,m6:H,m7:G,m8:Z},data:function(){return{tab:"m1",tabs:[{label:"g",value:"m1"},{label:"基本",value:"m2"},{label:"基本",value:"m3"},{label:"基本",value:"m4"},{label:"基本",value:"m5"},{label:"基本",value:"m6"},{label:"基本",value:"m7"},{label:"基本",value:"m8"}]}}},nt=tt,et=Object(c["a"])(nt,a,r,!1,null,"2971a0f0",null);n["default"]=et.exports},f5d2:function(t,n,e){"use strict";e.r(n);var a=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("q-tabs",{staticClass:"text-teal",attrs:{align:"left","inline-label":"",dense:""},model:{value:t.tab,callback:function(n){t.tab=n},expression:"tab"}},t._l(t.tabs,(function(t,n){return e("q-tab",{key:"tabs_"+n,attrs:{name:""+(n+1),label:n+1+"."+t.text}})})),1),e("m"+t.tab,{tag:"component"})],1)},r=[],s=e("9523"),o=e.n(s),l=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n   rrrrrrrrrrrrrrrrrrrr\n")])},i=[],c={},p=c,b=e("2877"),u=Object(b["a"])(p,l,i,!1,null,"ff4455f4",null),v=u.exports,g=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    yyyyyyyyyyyyyyyyyyyyyyyy\n")])},m=[],_={},d=_,h=Object(b["a"])(d,g,m,!1,null,"259cfd6f",null),f=h.exports,y=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},S=[],w={},k=w,x=Object(b["a"])(k,y,S,!1,null,"283458d7",null),C=x.exports,j=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},P=[],T={},E=T,O=Object(b["a"])(E,j,P,!1,null,"037f7fd0",null),M=O.exports,A=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},N=[],I={},D=I,z=Object(b["a"])(D,A,N,!1,null,"5767b14e",null),$=z.exports,R=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},J=[],L={},H=L,q=Object(b["a"])(H,R,J,!1,null,"ab4fe2cc",null),F=q.exports,W=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},B=[],U={},G=U,V=Object(b["a"])(G,W,B,!1,null,"ff38144a",null),X=V.exports,Q=function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[t._v("\n    1\n")])},Y=[],K={},Z=K,tt=Object(b["a"])(Z,Q,Y,!1,null,"566fdd1c",null),nt=tt.exports,et={components:{m1:v,m2:f,m3:C,m4:M,m5:$,m6:F,m7:X,m8:nt},data:function(){return o()({tab:1,tabs:[1,2,3,4,5,6,7,8]},"tabs",[{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"},{text:"未开发"}])}},at=et,rt=Object(b["a"])(at,a,r,!1,null,"30cd76de",null);n["default"]=rt.exports},fa2e:function(t,n,e){}}]);